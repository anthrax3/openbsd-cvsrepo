head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.2
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	cxJ08BvJA9Pt2PTM;

1.22
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	GzHqjSTnBjdF7Wcw;

1.21
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	XRK22kO4se3v2i2I;

1.20
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	QP75iYx42Uo7mMxO;

1.19
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.02.23.37.10;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.03.15.58.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.01.20.23.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.57;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.23;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.37;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.56;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.48;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.37;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.44;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.09;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.27;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.16;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.41;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.14;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;

1.10.2.1
date	2005.12.18.04.57.47;	author brad;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2006.01.03.05.44.50;	author brad;	state Exp;
branches;
next	;

1.10.4.1
date	2005.12.18.04.55.56;	author brad;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2006.01.03.04.22.41;	author brad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    sv.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall
 *    and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'I wonder what the Entish is for "yes" and "no",' he thought.
 *                                                      --Pippin
 *
 *     [p.480 of _The Lord of the Rings_, III/iv: "Treebeard"]
 */

/*
 *
 *
 * This file contains the code that creates, manipulates and destroys
 * scalar values (SVs). The other types (AV, HV, GV, etc.) reuse the
 * structure of an SV, so their creation and destruction is handled
 * here; higher-level functions are in av.c, hv.c, and so on. Opcode
 * level functions (eg. substr, split, join) for each of the types are
 * in the pp*.c files.
 */

#include "EXTERN.h"
#define PERL_IN_SV_C
#include "perl.h"
#include "regcomp.h"
#ifdef __VMS
# include <rms.h>
#endif

#ifdef __Lynx__
/* Missing proto on LynxOS */
  char *gconvert(double, int, int,  char *);
#endif

#ifdef USE_QUADMATH
#  define SNPRINTF_G(nv, buffer, size, ndig) \
    quadmath_snprintf(buffer, size, "%.*Qg", (int)ndig, (NV)(nv))
#else
#  define SNPRINTF_G(nv, buffer, size, ndig) \
    PERL_UNUSED_RESULT(Gconvert((NV)(nv), (int)ndig, 0, buffer))
#endif

#ifndef SV_COW_THRESHOLD
#    define SV_COW_THRESHOLD                    0   /* COW iff len > K */
#endif
#ifndef SV_COWBUF_THRESHOLD
#    define SV_COWBUF_THRESHOLD                 1250 /* COW iff len > K */
#endif
#ifndef SV_COW_MAX_WASTE_THRESHOLD
#    define SV_COW_MAX_WASTE_THRESHOLD          80   /* COW iff (len - cur) < K */
#endif
#ifndef SV_COWBUF_WASTE_THRESHOLD
#    define SV_COWBUF_WASTE_THRESHOLD           80   /* COW iff (len - cur) < K */
#endif
#ifndef SV_COW_MAX_WASTE_FACTOR_THRESHOLD
#    define SV_COW_MAX_WASTE_FACTOR_THRESHOLD   2    /* COW iff len < (cur * K) */
#endif
#ifndef SV_COWBUF_WASTE_FACTOR_THRESHOLD
#    define SV_COWBUF_WASTE_FACTOR_THRESHOLD    2    /* COW iff len < (cur * K) */
#endif
/* Work around compiler warnings about unsigned >= THRESHOLD when thres-
   hold is 0. */
#if SV_COW_THRESHOLD
# define GE_COW_THRESHOLD(cur) ((cur) >= SV_COW_THRESHOLD)
#else
# define GE_COW_THRESHOLD(cur) 1
#endif
#if SV_COWBUF_THRESHOLD
# define GE_COWBUF_THRESHOLD(cur) ((cur) >= SV_COWBUF_THRESHOLD)
#else
# define GE_COWBUF_THRESHOLD(cur) 1
#endif
#if SV_COW_MAX_WASTE_THRESHOLD
# define GE_COW_MAX_WASTE_THRESHOLD(cur,len) (((len)-(cur)) < SV_COW_MAX_WASTE_THRESHOLD)
#else
# define GE_COW_MAX_WASTE_THRESHOLD(cur,len) 1
#endif
#if SV_COWBUF_WASTE_THRESHOLD
# define GE_COWBUF_WASTE_THRESHOLD(cur,len) (((len)-(cur)) < SV_COWBUF_WASTE_THRESHOLD)
#else
# define GE_COWBUF_WASTE_THRESHOLD(cur,len) 1
#endif
#if SV_COW_MAX_WASTE_FACTOR_THRESHOLD
# define GE_COW_MAX_WASTE_FACTOR_THRESHOLD(cur,len) ((len) < SV_COW_MAX_WASTE_FACTOR_THRESHOLD * (cur))
#else
# define GE_COW_MAX_WASTE_FACTOR_THRESHOLD(cur,len) 1
#endif
#if SV_COWBUF_WASTE_FACTOR_THRESHOLD
# define GE_COWBUF_WASTE_FACTOR_THRESHOLD(cur,len) ((len) < SV_COWBUF_WASTE_FACTOR_THRESHOLD * (cur))
#else
# define GE_COWBUF_WASTE_FACTOR_THRESHOLD(cur,len) 1
#endif

#define CHECK_COW_THRESHOLD(cur,len) (\
    GE_COW_THRESHOLD((cur)) && \
    GE_COW_MAX_WASTE_THRESHOLD((cur),(len)) && \
    GE_COW_MAX_WASTE_FACTOR_THRESHOLD((cur),(len)) \
)
#define CHECK_COWBUF_THRESHOLD(cur,len) (\
    GE_COWBUF_THRESHOLD((cur)) && \
    GE_COWBUF_WASTE_THRESHOLD((cur),(len)) && \
    GE_COWBUF_WASTE_FACTOR_THRESHOLD((cur),(len)) \
)

#ifdef PERL_UTF8_CACHE_ASSERT
/* if adding more checks watch out for the following tests:
 *   t/op/index.t t/op/length.t t/op/pat.t t/op/substr.t
 *   lib/utf8.t lib/Unicode/Collate/t/index.t
 * --jhi
 */
#   define ASSERT_UTF8_CACHE(cache) \
    STMT_START { if (cache) { assert((cache)[0] <= (cache)[1]); \
			      assert((cache)[2] <= (cache)[3]); \
			      assert((cache)[3] <= (cache)[1]);} \
			      } STMT_END
#else
#   define ASSERT_UTF8_CACHE(cache) NOOP
#endif

static const char S_destroy[] = "DESTROY";
#define S_destroy_len (sizeof(S_destroy)-1)

/* ============================================================================

=head1 Allocation and deallocation of SVs.
An SV (or AV, HV, etc.) is allocated in two parts: the head (struct
sv, av, hv...) contains type and reference count information, and for
many types, a pointer to the body (struct xrv, xpv, xpviv...), which
contains fields specific to each type.  Some types store all they need
in the head, so don't have a body.

In all but the most memory-paranoid configurations (ex: PURIFY), heads
and bodies are allocated out of arenas, which by default are
approximately 4K chunks of memory parcelled up into N heads or bodies.
Sv-bodies are allocated by their sv-type, guaranteeing size
consistency needed to allocate safely from arrays.

For SV-heads, the first slot in each arena is reserved, and holds a
link to the next arena, some flags, and a note of the number of slots.
Snaked through each arena chain is a linked list of free items; when
this becomes empty, an extra arena is allocated and divided up into N
items which are threaded into the free list.

SV-bodies are similar, but they use arena-sets by default, which
separate the link and info from the arena itself, and reclaim the 1st
slot in the arena.  SV-bodies are further described later.

The following global variables are associated with arenas:

 PL_sv_arenaroot     pointer to list of SV arenas
 PL_sv_root          pointer to list of free SV structures

 PL_body_arenas      head of linked-list of body arenas
 PL_body_roots[]     array of pointers to list of free bodies of svtype
                     arrays are indexed by the svtype needed

A few special SV heads are not allocated from an arena, but are
instead directly created in the interpreter structure, eg PL_sv_undef.
The size of arenas can be changed from the default by setting
PERL_ARENA_SIZE appropriately at compile time.

The SV arena serves the secondary purpose of allowing still-live SVs
to be located and destroyed during final cleanup.

At the lowest level, the macros new_SV() and del_SV() grab and free
an SV head.  (If debugging with -DD, del_SV() calls the function S_del_sv()
to return the SV to the free list with error checking.) new_SV() calls
more_sv() / sv_add_arena() to add an extra arena if the free list is empty.
SVs in the free list have their SvTYPE field set to all ones.

At the time of very final cleanup, sv_free_arenas() is called from
perl_destruct() to physically free all the arenas allocated since the
start of the interpreter.

The function visit() scans the SV arenas list, and calls a specified
function for each SV it finds which is still live - ie which has an SvTYPE
other than all 1's, and a non-zero SvREFCNT. visit() is used by the
following functions (specified as [function that calls visit()] / [function
called by visit() for each SV]):

    sv_report_used() / do_report_used()
			dump all remaining SVs (debugging aid)

    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
		      do_clean_named_io_objs(),do_curse()
			Attempt to free all objects pointed to by RVs,
			try to do the same for all objects indir-
			ectly referenced by typeglobs too, and
			then do a final sweep, cursing any
			objects that remain.  Called once from
			perl_destruct(), prior to calling sv_clean_all()
			below.

    sv_clean_all() / do_clean_all()
			SvREFCNT_dec(sv) each remaining SV, possibly
			triggering an sv_free(). It also sets the
			SVf_BREAK flag on the SV to indicate that the
			refcnt has been artificially lowered, and thus
			stopping sv_free() from giving spurious warnings
			about SVs which unexpectedly have a refcnt
			of zero.  called repeatedly from perl_destruct()
			until there are no SVs left.

=head2 Arena allocator API Summary

Private API to rest of sv.c

    new_SV(),  del_SV(),

    new_XPVNV(), del_XPVGV(),
    etc

Public API:

    sv_report_used(), sv_clean_objs(), sv_clean_all(), sv_free_arenas()

=cut

 * ========================================================================= */

/*
 * "A time to plant, and a time to uproot what was planted..."
 */

#ifdef PERL_MEM_LOG
#  define MEM_LOG_NEW_SV(sv, file, line, func)	\
	    Perl_mem_log_new_sv(sv, file, line, func)
#  define MEM_LOG_DEL_SV(sv, file, line, func)	\
	    Perl_mem_log_del_sv(sv, file, line, func)
#else
#  define MEM_LOG_NEW_SV(sv, file, line, func)	NOOP
#  define MEM_LOG_DEL_SV(sv, file, line, func)	NOOP
#endif

#ifdef DEBUG_LEAKING_SCALARS
#  define FREE_SV_DEBUG_FILE(sv) STMT_START { \
	if ((sv)->sv_debug_file) PerlMemShared_free((sv)->sv_debug_file); \
    } STMT_END
#  define DEBUG_SV_SERIAL(sv)						    \
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) del_SV\n",    \
	    PTR2UV(sv), (long)(sv)->sv_debug_serial))
#else
#  define FREE_SV_DEBUG_FILE(sv)
#  define DEBUG_SV_SERIAL(sv)	NOOP
#endif

#ifdef PERL_POISON
#  define SvARENA_CHAIN(sv)	((sv)->sv_u.svu_rv)
#  define SvARENA_CHAIN_SET(sv,val)	(sv)->sv_u.svu_rv = MUTABLE_SV((val))
/* Whilst I'd love to do this, it seems that things like to check on
   unreferenced scalars
#  define POISON_SV_HEAD(sv)	PoisonNew(sv, 1, struct STRUCT_SV)
*/
#  define POISON_SV_HEAD(sv)	PoisonNew(&SvANY(sv), 1, void *), \
				PoisonNew(&SvREFCNT(sv), 1, U32)
#else
#  define SvARENA_CHAIN(sv)	SvANY(sv)
#  define SvARENA_CHAIN_SET(sv,val)	SvANY(sv) = (void *)(val)
#  define POISON_SV_HEAD(sv)
#endif

/* Mark an SV head as unused, and add to free list.
 *
 * If SVf_BREAK is set, skip adding it to the free list, as this SV had
 * its refcount artificially decremented during global destruction, so
 * there may be dangling pointers to it. The last thing we want in that
 * case is for it to be reused. */

#define plant_SV(p) \
    STMT_START {					\
	const U32 old_flags = SvFLAGS(p);			\
	MEM_LOG_DEL_SV(p, __FILE__, __LINE__, FUNCTION__);  \
	DEBUG_SV_SERIAL(p);				\
	FREE_SV_DEBUG_FILE(p);				\
	POISON_SV_HEAD(p);				\
	SvFLAGS(p) = SVTYPEMASK;			\
	if (!(old_flags & SVf_BREAK)) {		\
	    SvARENA_CHAIN_SET(p, PL_sv_root);	\
	    PL_sv_root = (p);				\
	}						\
	--PL_sv_count;					\
    } STMT_END

#define uproot_SV(p) \
    STMT_START {					\
	(p) = PL_sv_root;				\
	PL_sv_root = MUTABLE_SV(SvARENA_CHAIN(p));		\
	++PL_sv_count;					\
    } STMT_END


/* make some more SVs by adding another arena */

STATIC SV*
S_more_sv(pTHX)
{
    SV* sv;
    char *chunk;                /* must use New here to match call to */
    Newx(chunk,PERL_ARENA_SIZE,char);  /* Safefree() in sv_free_arenas() */
    sv_add_arena(chunk, PERL_ARENA_SIZE, 0);
    uproot_SV(sv);
    return sv;
}

/* new_SV(): return a new, empty SV head */

#ifdef DEBUG_LEAKING_SCALARS
/* provide a real function for a debugger to play with */
STATIC SV*
S_new_SV(pTHX_ const char *file, int line, const char *func)
{
    SV* sv;

    if (PL_sv_root)
	uproot_SV(sv);
    else
	sv = S_more_sv(aTHX);
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
    sv->sv_debug_optype = PL_op ? PL_op->op_type : 0;
    sv->sv_debug_line = (U16) (PL_parser && PL_parser->copline != NOLINE
		? PL_parser->copline
		:  PL_curcop
		    ? CopLINE(PL_curcop)
		    : 0
	    );
    sv->sv_debug_inpad = 0;
    sv->sv_debug_parent = NULL;
    sv->sv_debug_file = PL_curcop ? savesharedpv(CopFILE(PL_curcop)): NULL;

    sv->sv_debug_serial = PL_sv_serial++;

    MEM_LOG_NEW_SV(sv, file, line, func);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) new_SV (from %s:%d [%s])\n",
	    PTR2UV(sv), (long)sv->sv_debug_serial, file, line, func));

    return sv;
}
#  define new_SV(p) (p)=S_new_SV(aTHX_ __FILE__, __LINE__, FUNCTION__)

#else
#  define new_SV(p) \
    STMT_START {					\
	if (PL_sv_root)					\
	    uproot_SV(p);				\
	else						\
	    (p) = S_more_sv(aTHX);			\
	SvANY(p) = 0;					\
	SvREFCNT(p) = 1;				\
	SvFLAGS(p) = 0;					\
	MEM_LOG_NEW_SV(p, __FILE__, __LINE__, FUNCTION__);  \
    } STMT_END
#endif


/* del_SV(): return an empty SV head to the free list */

#ifdef DEBUGGING

#define del_SV(p) \
    STMT_START {					\
	if (DEBUG_D_TEST)				\
	    del_sv(p);					\
	else						\
	    plant_SV(p);				\
    } STMT_END

STATIC void
S_del_sv(pTHX_ SV *p)
{
    PERL_ARGS_ASSERT_DEL_SV;

    if (DEBUG_D_TEST) {
	SV* sva;
	bool ok = 0;
	for (sva = PL_sv_arenaroot; sva; sva = MUTABLE_SV(SvANY(sva))) {
	    const SV * const sv = sva + 1;
	    const SV * const svend = &sva[SvREFCNT(sva)];
	    if (p >= sv && p < svend) {
		ok = 1;
		break;
	    }
	}
	if (!ok) {
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			     "Attempt to free non-arena SV: 0x%"UVxf
			     pTHX__FORMAT, PTR2UV(p) pTHX__VALUE);
	    return;
	}
    }
    plant_SV(p);
}

#else /* ! DEBUGGING */

#define del_SV(p)   plant_SV(p)

#endif /* DEBUGGING */


/*
=head1 SV Manipulation Functions

=for apidoc sv_add_arena

Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.

=cut
*/

static void
S_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags)
{
    SV *const sva = MUTABLE_SV(ptr);
    SV* sv;
    SV* svend;

    PERL_ARGS_ASSERT_SV_ADD_ARENA;

    /* The first SV in an arena isn't an SV. */
    SvANY(sva) = (void *) PL_sv_arenaroot;		/* ptr to next arena */
    SvREFCNT(sva) = size / sizeof(SV);		/* number of SV slots */
    SvFLAGS(sva) = flags;			/* FAKE if not to be freed */

    PL_sv_arenaroot = sva;
    PL_sv_root = sva + 1;

    svend = &sva[SvREFCNT(sva) - 1];
    sv = sva + 1;
    while (sv < svend) {
	SvARENA_CHAIN_SET(sv, (sv + 1));
#ifdef DEBUGGING
	SvREFCNT(sv) = 0;
#endif
	/* Must always set typemask because it's always checked in on cleanup
	   when the arenas are walked looking for objects.  */
	SvFLAGS(sv) = SVTYPEMASK;
	sv++;
    }
    SvARENA_CHAIN_SET(sv, 0);
#ifdef DEBUGGING
    SvREFCNT(sv) = 0;
#endif
    SvFLAGS(sv) = SVTYPEMASK;
}

/* visit(): call the named function for each non-free SV in the arenas
 * whose flags field matches the flags/mask args. */

STATIC I32
S_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask)
{
    SV* sva;
    I32 visited = 0;

    PERL_ARGS_ASSERT_VISIT;

    for (sva = PL_sv_arenaroot; sva; sva = MUTABLE_SV(SvANY(sva))) {
	const SV * const svend = &sva[SvREFCNT(sva)];
	SV* sv;
	for (sv = sva + 1; sv < svend; ++sv) {
	    if (SvTYPE(sv) != (svtype)SVTYPEMASK
		    && (sv->sv_flags & mask) == flags
		    && SvREFCNT(sv))
	    {
		(*f)(aTHX_ sv);
		++visited;
	    }
	}
    }
    return visited;
}

#ifdef DEBUGGING

/* called by sv_report_used() for each live SV */

static void
do_report_used(pTHX_ SV *const sv)
{
    if (SvTYPE(sv) != (svtype)SVTYPEMASK) {
	PerlIO_printf(Perl_debug_log, "****\n");
	sv_dump(sv);
    }
}
#endif

/*
=for apidoc sv_report_used

Dump the contents of all SVs not yet freed (debugging aid).

=cut
*/

void
Perl_sv_report_used(pTHX)
{
#ifdef DEBUGGING
    visit(do_report_used, 0, 0);
#else
    PERL_UNUSED_CONTEXT;
#endif
}

/* called by sv_clean_objs() for each live SV */

static void
do_clean_objs(pTHX_ SV *const ref)
{
    assert (SvROK(ref));
    {
	SV * const target = SvRV(ref);
	if (SvOBJECT(target)) {
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(ref)));
	    if (SvWEAKREF(ref)) {
		sv_del_backref(target, ref);
		SvWEAKREF_off(ref);
		SvRV_set(ref, NULL);
	    } else {
		SvROK_off(ref);
		SvRV_set(ref, NULL);
		SvREFCNT_dec_NN(target);
	    }
	}
    }
}


/* clear any slots in a GV which hold objects - except IO;
 * called by sv_clean_objs() for each live GV */

static void
do_clean_named_objs(pTHX_ SV *const sv)
{
    SV *obj;
    assert(SvTYPE(sv) == SVt_PVGV);
    assert(isGV_with_GP(sv));
    if (!GvGP(sv))
	return;

    /* freeing GP entries may indirectly free the current GV;
     * hold onto it while we mess with the GP slots */
    SvREFCNT_inc(sv);

    if ( ((obj = GvSV(sv) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob SV object:\n "), sv_dump(obj)));
	GvSV(sv) = NULL;
	SvREFCNT_dec_NN(obj);
    }
    if ( ((obj = MUTABLE_SV(GvAV(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob AV object:\n "), sv_dump(obj)));
	GvAV(sv) = NULL;
	SvREFCNT_dec_NN(obj);
    }
    if ( ((obj = MUTABLE_SV(GvHV(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob HV object:\n "), sv_dump(obj)));
	GvHV(sv) = NULL;
	SvREFCNT_dec_NN(obj);
    }
    if ( ((obj = MUTABLE_SV(GvCV(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob CV object:\n "), sv_dump(obj)));
	GvCV_set(sv, NULL);
	SvREFCNT_dec_NN(obj);
    }
    SvREFCNT_dec_NN(sv); /* undo the inc above */
}

/* clear any IO slots in a GV which hold objects (except stderr, defout);
 * called by sv_clean_objs() for each live GV */

static void
do_clean_named_io_objs(pTHX_ SV *const sv)
{
    SV *obj;
    assert(SvTYPE(sv) == SVt_PVGV);
    assert(isGV_with_GP(sv));
    if (!GvGP(sv) || sv == (SV*)PL_stderrgv || sv == (SV*)PL_defoutgv)
	return;

    SvREFCNT_inc(sv);
    if ( ((obj = MUTABLE_SV(GvIO(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob IO object:\n "), sv_dump(obj)));
	GvIOp(sv) = NULL;
	SvREFCNT_dec_NN(obj);
    }
    SvREFCNT_dec_NN(sv); /* undo the inc above */
}

/* Void wrapper to pass to visit() */
static void
do_curse(pTHX_ SV * const sv) {
    if ((PL_stderrgv && GvGP(PL_stderrgv) && (SV*)GvIO(PL_stderrgv) == sv)
     || (PL_defoutgv && GvGP(PL_defoutgv) && (SV*)GvIO(PL_defoutgv) == sv))
	return;
    (void)curse(sv, 0);
}

/*
=for apidoc sv_clean_objs

Attempt to destroy all objects not yet freed.

=cut
*/

void
Perl_sv_clean_objs(pTHX)
{
    GV *olddef, *olderr;
    PL_in_clean_objs = TRUE;
    visit(do_clean_objs, SVf_ROK, SVf_ROK);
    /* Some barnacles may yet remain, clinging to typeglobs.
     * Run the non-IO destructors first: they may want to output
     * error messages, close files etc */
    visit(do_clean_named_objs, SVt_PVGV|SVpgv_GP, SVTYPEMASK|SVp_POK|SVpgv_GP);
    visit(do_clean_named_io_objs, SVt_PVGV|SVpgv_GP, SVTYPEMASK|SVp_POK|SVpgv_GP);
    /* And if there are some very tenacious barnacles clinging to arrays,
       closures, or what have you.... */
    visit(do_curse, SVs_OBJECT, SVs_OBJECT);
    olddef = PL_defoutgv;
    PL_defoutgv = NULL; /* disable skip of PL_defoutgv */
    if (olddef && isGV_with_GP(olddef))
	do_clean_named_io_objs(aTHX_ MUTABLE_SV(olddef));
    olderr = PL_stderrgv;
    PL_stderrgv = NULL; /* disable skip of PL_stderrgv */
    if (olderr && isGV_with_GP(olderr))
	do_clean_named_io_objs(aTHX_ MUTABLE_SV(olderr));
    SvREFCNT_dec(olddef);
    PL_in_clean_objs = FALSE;
}

/* called by sv_clean_all() for each live SV */

static void
do_clean_all(pTHX_ SV *const sv)
{
    if (sv == (const SV *) PL_fdpid || sv == (const SV *)PL_strtab) {
	/* don't clean pid table and strtab */
	return;
    }
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops: SV at 0x%"UVxf"\n", PTR2UV(sv)) ));
    SvFLAGS(sv) |= SVf_BREAK;
    SvREFCNT_dec_NN(sv);
}

/*
=for apidoc sv_clean_all

Decrement the refcnt of each remaining SV, possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.

=cut
*/

I32
Perl_sv_clean_all(pTHX)
{
    I32 cleaned;
    PL_in_clean_all = TRUE;
    cleaned = visit(do_clean_all, 0,0);
    return cleaned;
}

/*
  ARENASETS: a meta-arena implementation which separates arena-info
  into struct arena_set, which contains an array of struct
  arena_descs, each holding info for a single arena.  By separating
  the meta-info from the arena, we recover the 1st slot, formerly
  borrowed for list management.  The arena_set is about the size of an
  arena, avoiding the needless malloc overhead of a naive linked-list.

  The cost is 1 arena-set malloc per ~320 arena-mallocs, + the unused
  memory in the last arena-set (1/2 on average).  In trade, we get
  back the 1st slot in each arena (ie 1.7% of a CV-arena, less for
  smaller types).  The recovery of the wasted space allows use of
  small arenas for large, rare body types, by changing array* fields
  in body_details_by_type[] below.
*/
struct arena_desc {
    char       *arena;		/* the raw storage, allocated aligned */
    size_t      size;		/* its size ~4k typ */
    svtype	utype;		/* bodytype stored in arena */
};

struct arena_set;

/* Get the maximum number of elements in set[] such that struct arena_set
   will fit within PERL_ARENA_SIZE, which is probably just under 4K, and
   therefore likely to be 1 aligned memory page.  */

#define ARENAS_PER_SET  ((PERL_ARENA_SIZE - sizeof(struct arena_set*) \
			  - 2 * sizeof(int)) / sizeof (struct arena_desc))

struct arena_set {
    struct arena_set* next;
    unsigned int   set_size;	/* ie ARENAS_PER_SET */
    unsigned int   curr;	/* index of next available arena-desc */
    struct arena_desc set[ARENAS_PER_SET];
};

/*
=for apidoc sv_free_arenas

Deallocate the memory used by all arenas.  Note that all the individual SV
heads and bodies within the arenas must already have been freed.

=cut

*/
void
Perl_sv_free_arenas(pTHX)
{
    SV* sva;
    SV* svanext;
    unsigned int i;

    /* Free arenas here, but be careful about fake ones.  (We assume
       contiguity of the fake ones with the corresponding real ones.) */

    for (sva = PL_sv_arenaroot; sva; sva = svanext) {
	svanext = MUTABLE_SV(SvANY(sva));
	while (svanext && SvFAKE(svanext))
	    svanext = MUTABLE_SV(SvANY(svanext));

	if (!SvFAKE(sva))
	    Safefree(sva);
    }

    {
	struct arena_set *aroot = (struct arena_set*) PL_body_arenas;

	while (aroot) {
	    struct arena_set *current = aroot;
	    i = aroot->curr;
	    while (i--) {
		assert(aroot->set[i].arena);
		Safefree(aroot->set[i].arena);
	    }
	    aroot = aroot->next;
	    Safefree(current);
	}
    }
    PL_body_arenas = 0;

    i = PERL_ARENA_ROOTS_SIZE;
    while (i--)
	PL_body_roots[i] = 0;

    PL_sv_arenaroot = 0;
    PL_sv_root = 0;
}

/*
  Here are mid-level routines that manage the allocation of bodies out
  of the various arenas.  There are 5 kinds of arenas:

  1. SV-head arenas, which are discussed and handled above
  2. regular body arenas
  3. arenas for reduced-size bodies
  4. Hash-Entry arenas

  Arena types 2 & 3 are chained by body-type off an array of
  arena-root pointers, which is indexed by svtype.  Some of the
  larger/less used body types are malloced singly, since a large
  unused block of them is wasteful.  Also, several svtypes dont have
  bodies; the data fits into the sv-head itself.  The arena-root
  pointer thus has a few unused root-pointers (which may be hijacked
  later for arena types 4,5)

  3 differs from 2 as an optimization; some body types have several
  unused fields in the front of the structure (which are kept in-place
  for consistency).  These bodies can be allocated in smaller chunks,
  because the leading fields arent accessed.  Pointers to such bodies
  are decremented to point at the unused 'ghost' memory, knowing that
  the pointers are used with offsets to the real memory.


=head1 SV-Body Allocation

=cut

Allocation of SV-bodies is similar to SV-heads, differing as follows;
the allocation mechanism is used for many body types, so is somewhat
more complicated, it uses arena-sets, and has no need for still-live
SV detection.

At the outermost level, (new|del)_X*V macros return bodies of the
appropriate type.  These macros call either (new|del)_body_type or
(new|del)_body_allocated macro pairs, depending on specifics of the
type.  Most body types use the former pair, the latter pair is used to
allocate body types with "ghost fields".

"ghost fields" are fields that are unused in certain types, and
consequently don't need to actually exist.  They are declared because
they're part of a "base type", which allows use of functions as
methods.  The simplest examples are AVs and HVs, 2 aggregate types
which don't use the fields which support SCALAR semantics.

For these types, the arenas are carved up into appropriately sized
chunks, we thus avoid wasted memory for those unaccessed members.
When bodies are allocated, we adjust the pointer back in memory by the
size of the part not allocated, so it's as if we allocated the full
structure.  (But things will all go boom if you write to the part that
is "not there", because you'll be overwriting the last members of the
preceding structure in memory.)

We calculate the correction using the STRUCT_OFFSET macro on the first
member present.  If the allocated structure is smaller (no initial NV
actually allocated) then the net effect is to subtract the size of the NV
from the pointer, to return a new pointer as if an initial NV were actually
allocated.  (We were using structures named *_allocated for this, but
this turned out to be a subtle bug, because a structure without an NV
could have a lower alignment constraint, but the compiler is allowed to
optimised accesses based on the alignment constraint of the actual pointer
to the full structure, for example, using a single 64 bit load instruction
because it "knows" that two adjacent 32 bit members will be 8-byte aligned.)

This is the same trick as was used for NV and IV bodies.  Ironically it
doesn't need to be used for NV bodies any more, because NV is now at
the start of the structure.  IV bodies, and also in some builds NV bodies,
don't need it either, because they are no longer allocated.

In turn, the new_body_* allocators call S_new_body(), which invokes
new_body_inline macro, which takes a lock, and takes a body off the
linked list at PL_body_roots[sv_type], calling Perl_more_bodies() if
necessary to refresh an empty list.  Then the lock is released, and
the body is returned.

Perl_more_bodies allocates a new arena, and carves it up into an array of N
bodies, which it strings into a linked list.  It looks up arena-size
and body-size from the body_details table described below, thus
supporting the multiple body-types.

If PURIFY is defined, or PERL_ARENA_SIZE=0, arenas are not used, and
the (new|del)_X*V macros are mapped directly to malloc/free.

For each sv-type, struct body_details bodies_by_type[] carries
parameters which control these aspects of SV handling:

Arena_size determines whether arenas are used for this body type, and if
so, how big they are.  PURIFY or PERL_ARENA_SIZE=0 set this field to
zero, forcing individual mallocs and frees.

Body_size determines how big a body is, and therefore how many fit into
each arena.  Offset carries the body-pointer adjustment needed for
"ghost fields", and is used in *_allocated macros.

But its main purpose is to parameterize info needed in
Perl_sv_upgrade().  The info here dramatically simplifies the function
vs the implementation in 5.8.8, making it table-driven.  All fields
are used for this, except for arena_size.

For the sv-types that have no bodies, arenas are not used, so those
PL_body_roots[sv_type] are unused, and can be overloaded.  In
something of a special case, SVt_NULL is borrowed for HE arenas;
PL_body_roots[HE_SVSLOT=SVt_NULL] is filled by S_more_he, but the
bodies_by_type[SVt_NULL] slot is not used, as the table is not
available in hv.c.

*/

struct body_details {
    U8 body_size;	/* Size to allocate  */
    U8 copy;		/* Size of structure to copy (may be shorter)  */
    U8 offset;		/* Size of unalloced ghost fields to first alloced field*/
    PERL_BITFIELD8 type : 4;        /* We have space for a sanity check. */
    PERL_BITFIELD8 cant_upgrade : 1;/* Cannot upgrade this type */
    PERL_BITFIELD8 zero_nv : 1;     /* zero the NV when upgrading from this */
    PERL_BITFIELD8 arena : 1;       /* Allocated from an arena */
    U32 arena_size;                 /* Size of arena to allocate */
};

#define HADNV FALSE
#define NONV TRUE


#ifdef PURIFY
/* With -DPURFIY we allocate everything directly, and don't use arenas.
   This seems a rather elegant way to simplify some of the code below.  */
#define HASARENA FALSE
#else
#define HASARENA TRUE
#endif
#define NOARENA FALSE

/* Size the arenas to exactly fit a given number of bodies.  A count
   of 0 fits the max number bodies into a PERL_ARENA_SIZE.block,
   simplifying the default.  If count > 0, the arena is sized to fit
   only that many bodies, allowing arenas to be used for large, rare
   bodies (XPVFM, XPVIO) without undue waste.  The arena size is
   limited by PERL_ARENA_SIZE, so we can safely oversize the
   declarations.
 */
#define FIT_ARENA0(body_size)				\
    ((size_t)(PERL_ARENA_SIZE / body_size) * body_size)
#define FIT_ARENAn(count,body_size)			\
    ( count * body_size <= PERL_ARENA_SIZE)		\
    ? count * body_size					\
    : FIT_ARENA0 (body_size)
#define FIT_ARENA(count,body_size)			\
   (U32)(count 						\
    ? FIT_ARENAn (count, body_size)			\
    : FIT_ARENA0 (body_size))

/* Calculate the length to copy. Specifically work out the length less any
   final padding the compiler needed to add.  See the comment in sv_upgrade
   for why copying the padding proved to be a bug.  */

#define copy_length(type, last_member) \
	STRUCT_OFFSET(type, last_member) \
	+ sizeof (((type*)SvANY((const SV *)0))->last_member)

static const struct body_details bodies_by_type[] = {
    /* HEs use this offset for their arena.  */
    { 0, 0, 0, SVt_NULL, FALSE, NONV, NOARENA, 0 },

    /* IVs are in the head, so the allocation size is 0.  */
    { 0,
      sizeof(IV), /* This is used to copy out the IV body.  */
      STRUCT_OFFSET(XPVIV, xiv_iv), SVt_IV, FALSE, NONV,
      NOARENA /* IVS don't need an arena  */, 0
    },

#if NVSIZE <= IVSIZE
    { 0, sizeof(NV),
      STRUCT_OFFSET(XPVNV, xnv_u),
      SVt_NV, FALSE, HADNV, NOARENA, 0 },
#else
    { sizeof(NV), sizeof(NV),
      STRUCT_OFFSET(XPVNV, xnv_u),
      SVt_NV, FALSE, HADNV, HASARENA, FIT_ARENA(0, sizeof(NV)) },
#endif

    { sizeof(XPV) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XPV, xpv_len) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_PV, FALSE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPV) - STRUCT_OFFSET(XPV, xpv_cur)) },

    { sizeof(XINVLIST) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XINVLIST, is_offset) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_INVLIST, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XINVLIST) - STRUCT_OFFSET(XPV, xpv_cur)) },

    { sizeof(XPVIV) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XPVIV, xiv_u) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_PVIV, FALSE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVIV) - STRUCT_OFFSET(XPV, xpv_cur)) },

    { sizeof(XPVNV) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XPVNV, xnv_u) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_PVNV, FALSE, HADNV, HASARENA,
      FIT_ARENA(0, sizeof(XPVNV) - STRUCT_OFFSET(XPV, xpv_cur)) },

    { sizeof(XPVMG), copy_length(XPVMG, xnv_u), 0, SVt_PVMG, FALSE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVMG)) },

    { sizeof(regexp),
      sizeof(regexp),
      0,
      SVt_REGEXP, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(regexp))
    },

    { sizeof(XPVGV), sizeof(XPVGV), 0, SVt_PVGV, TRUE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVGV)) },
    
    { sizeof(XPVLV), sizeof(XPVLV), 0, SVt_PVLV, TRUE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVLV)) },

    { sizeof(XPVAV),
      copy_length(XPVAV, xav_alloc),
      0,
      SVt_PVAV, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVAV)) },

    { sizeof(XPVHV),
      copy_length(XPVHV, xhv_max),
      0,
      SVt_PVHV, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVHV)) },

    { sizeof(XPVCV),
      sizeof(XPVCV),
      0,
      SVt_PVCV, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVCV)) },

    { sizeof(XPVFM),
      sizeof(XPVFM),
      0,
      SVt_PVFM, TRUE, NONV, NOARENA,
      FIT_ARENA(20, sizeof(XPVFM)) },

    { sizeof(XPVIO),
      sizeof(XPVIO),
      0,
      SVt_PVIO, TRUE, NONV, HASARENA,
      FIT_ARENA(24, sizeof(XPVIO)) },
};

#define new_body_allocated(sv_type)		\
    (void *)((char *)S_new_body(aTHX_ sv_type)	\
	     - bodies_by_type[sv_type].offset)

/* return a thing to the free list */

#define del_body(thing, root)				\
    STMT_START {					\
	void ** const thing_copy = (void **)thing;	\
	*thing_copy = *root;				\
	*root = (void*)thing_copy;			\
    } STMT_END

#ifdef PURIFY
#if !(NVSIZE <= IVSIZE)
#  define new_XNV()	safemalloc(sizeof(XPVNV))
#endif
#define new_XPVNV()	safemalloc(sizeof(XPVNV))
#define new_XPVMG()	safemalloc(sizeof(XPVMG))

#define del_XPVGV(p)	safefree(p)

#else /* !PURIFY */

#if !(NVSIZE <= IVSIZE)
#  define new_XNV()	new_body_allocated(SVt_NV)
#endif
#define new_XPVNV()	new_body_allocated(SVt_PVNV)
#define new_XPVMG()	new_body_allocated(SVt_PVMG)

#define del_XPVGV(p)	del_body(p + bodies_by_type[SVt_PVGV].offset,	\
				 &PL_body_roots[SVt_PVGV])

#endif /* PURIFY */

/* no arena for you! */

#define new_NOARENA(details) \
	safemalloc((details)->body_size + (details)->offset)
#define new_NOARENAZ(details) \
	safecalloc((details)->body_size + (details)->offset, 1)

void *
Perl_more_bodies (pTHX_ const svtype sv_type, const size_t body_size,
		  const size_t arena_size)
{
    void ** const root = &PL_body_roots[sv_type];
    struct arena_desc *adesc;
    struct arena_set *aroot = (struct arena_set *) PL_body_arenas;
    unsigned int curr;
    char *start;
    const char *end;
    const size_t good_arena_size = Perl_malloc_good_size(arena_size);
#if defined(DEBUGGING) && defined(PERL_GLOBAL_STRUCT)
    dVAR;
#endif
#if defined(DEBUGGING) && !defined(PERL_GLOBAL_STRUCT_PRIVATE)
    static bool done_sanity_check;

    /* PERL_GLOBAL_STRUCT_PRIVATE cannot coexist with global
     * variables like done_sanity_check. */
    if (!done_sanity_check) {
	unsigned int i = SVt_LAST;

	done_sanity_check = TRUE;

	while (i--)
	    assert (bodies_by_type[i].type == i);
    }
#endif

    assert(arena_size);

    /* may need new arena-set to hold new arena */
    if (!aroot || aroot->curr >= aroot->set_size) {
	struct arena_set *newroot;
	Newxz(newroot, 1, struct arena_set);
	newroot->set_size = ARENAS_PER_SET;
	newroot->next = aroot;
	aroot = newroot;
	PL_body_arenas = (void *) newroot;
	DEBUG_m(PerlIO_printf(Perl_debug_log, "new arenaset %p\n", (void*)aroot));
    }

    /* ok, now have arena-set with at least 1 empty/available arena-desc */
    curr = aroot->curr++;
    adesc = &(aroot->set[curr]);
    assert(!adesc->arena);
    
    Newx(adesc->arena, good_arena_size, char);
    adesc->size = good_arena_size;
    adesc->utype = sv_type;
    DEBUG_m(PerlIO_printf(Perl_debug_log, "arena %d added: %p size %"UVuf"\n", 
			  curr, (void*)adesc->arena, (UV)good_arena_size));

    start = (char *) adesc->arena;

    /* Get the address of the byte after the end of the last body we can fit.
       Remember, this is integer division:  */
    end = start + good_arena_size / body_size * body_size;

    /* computed count doesn't reflect the 1st slot reservation */
#if defined(MYMALLOC) || defined(HAS_MALLOC_GOOD_SIZE)
    DEBUG_m(PerlIO_printf(Perl_debug_log,
			  "arena %p end %p arena-size %d (from %d) type %d "
			  "size %d ct %d\n",
			  (void*)start, (void*)end, (int)good_arena_size,
			  (int)arena_size, sv_type, (int)body_size,
			  (int)good_arena_size / (int)body_size));
#else
    DEBUG_m(PerlIO_printf(Perl_debug_log,
			  "arena %p end %p arena-size %d type %d size %d ct %d\n",
			  (void*)start, (void*)end,
			  (int)arena_size, sv_type, (int)body_size,
			  (int)good_arena_size / (int)body_size));
#endif
    *root = (void *)start;

    while (1) {
	/* Where the next body would start:  */
	char * const next = start + body_size;

	if (next >= end) {
	    /* This is the last body:  */
	    assert(next == end);

	    *(void **)start = 0;
	    return *root;
	}

	*(void**) start = (void *)next;
	start = next;
    }
}

/* grab a new thing from the free list, allocating more if necessary.
   The inline version is used for speed in hot routines, and the
   function using it serves the rest (unless PURIFY).
*/
#define new_body_inline(xpv, sv_type) \
    STMT_START { \
	void ** const r3wt = &PL_body_roots[sv_type]; \
	xpv = (PTR_TBL_ENT_t*) (*((void **)(r3wt))      \
	  ? *((void **)(r3wt)) : Perl_more_bodies(aTHX_ sv_type, \
					     bodies_by_type[sv_type].body_size,\
					     bodies_by_type[sv_type].arena_size)); \
	*(r3wt) = *(void**)(xpv); \
    } STMT_END

#ifndef PURIFY

STATIC void *
S_new_body(pTHX_ const svtype sv_type)
{
    void *xpv;
    new_body_inline(xpv, sv_type);
    return xpv;
}

#endif

static const struct body_details fake_rv =
    { 0, 0, 0, SVt_IV, FALSE, NONV, NOARENA, 0 };

/*
=for apidoc sv_upgrade

Upgrade an SV to a more complex form.  Generally adds a new body type to the
SV, then copies across as much information as possible from the old body.
It croaks if the SV is already in a more complex form than requested.  You
generally want to use the C<SvUPGRADE> macro wrapper, which checks the type
before calling C<sv_upgrade>, and hence does not croak.  See also
C<L</svtype>>.

=cut
*/

void
Perl_sv_upgrade(pTHX_ SV *const sv, svtype new_type)
{
    void*	old_body;
    void*	new_body;
    const svtype old_type = SvTYPE(sv);
    const struct body_details *new_type_details;
    const struct body_details *old_type_details
	= bodies_by_type + old_type;
    SV *referant = NULL;

    PERL_ARGS_ASSERT_SV_UPGRADE;

    if (old_type == new_type)
	return;

    /* This clause was purposefully added ahead of the early return above to
       the shared string hackery for (sort {$a <=> $b} keys %hash), with the
       inference by Nick I-S that it would fix other troublesome cases. See
       changes 7162, 7163 (f130fd4589cf5fbb24149cd4db4137c8326f49c1 and parent)

       Given that shared hash key scalars are no longer PVIV, but PV, there is
       no longer need to unshare so as to free up the IVX slot for its proper
       purpose. So it's safe to move the early return earlier.  */

    if (new_type > SVt_PVMG && SvIsCOW(sv)) {
	sv_force_normal_flags(sv, 0);
    }

    old_body = SvANY(sv);

    /* Copying structures onto other structures that have been neatly zeroed
       has a subtle gotcha. Consider XPVMG

       +------+------+------+------+------+-------+-------+
       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH |
       +------+------+------+------+------+-------+-------+
       0      4      8     12     16     20      24      28

       where NVs are aligned to 8 bytes, so that sizeof that structure is
       actually 32 bytes long, with 4 bytes of padding at the end:

       +------+------+------+------+------+-------+-------+------+
       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH | ???  |
       +------+------+------+------+------+-------+-------+------+
       0      4      8     12     16     20      24      28     32

       so what happens if you allocate memory for this structure:

       +------+------+------+------+------+-------+-------+------+------+...
       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH |  GP  | NAME |
       +------+------+------+------+------+-------+-------+------+------+...
       0      4      8     12     16     20      24      28     32     36

       zero it, then copy sizeof(XPVMG) bytes on top of it? Not quite what you
       expect, because you copy the area marked ??? onto GP. Now, ??? may have
       started out as zero once, but it's quite possible that it isn't. So now,
       rather than a nicely zeroed GP, you have it pointing somewhere random.
       Bugs ensue.

       (In fact, GP ends up pointing at a previous GP structure, because the
       principle cause of the padding in XPVMG getting garbage is a copy of
       sizeof(XPVMG) bytes from a XPVGV structure in sv_unglob. Right now
       this happens to be moot because XPVGV has been re-ordered, with GP
       no longer after STASH)

       So we are careful and work out the size of used parts of all the
       structures.  */

    switch (old_type) {
    case SVt_NULL:
	break;
    case SVt_IV:
	if (SvROK(sv)) {
	    referant = SvRV(sv);
	    old_type_details = &fake_rv;
	    if (new_type == SVt_NV)
		new_type = SVt_PVNV;
	} else {
	    if (new_type < SVt_PVIV) {
		new_type = (new_type == SVt_NV)
		    ? SVt_PVNV : SVt_PVIV;
	    }
	}
	break;
    case SVt_NV:
	if (new_type < SVt_PVNV) {
	    new_type = SVt_PVNV;
	}
	break;
    case SVt_PV:
	assert(new_type > SVt_PV);
	STATIC_ASSERT_STMT(SVt_IV < SVt_PV);
	STATIC_ASSERT_STMT(SVt_NV < SVt_PV);
	break;
    case SVt_PVIV:
	break;
    case SVt_PVNV:
	break;
    case SVt_PVMG:
	/* Because the XPVMG of PL_mess_sv isn't allocated from the arena,
	   there's no way that it can be safely upgraded, because perl.c
	   expects to Safefree(SvANY(PL_mess_sv))  */
	assert(sv != PL_mess_sv);
	break;
    default:
	if (UNLIKELY(old_type_details->cant_upgrade))
	    Perl_croak(aTHX_ "Can't upgrade %s (%" UVuf ") to %" UVuf,
		       sv_reftype(sv, 0), (UV) old_type, (UV) new_type);
    }

    if (UNLIKELY(old_type > new_type))
	Perl_croak(aTHX_ "sv_upgrade from type %d down to type %d",
		(int)old_type, (int)new_type);

    new_type_details = bodies_by_type + new_type;

    SvFLAGS(sv) &= ~SVTYPEMASK;
    SvFLAGS(sv) |= new_type;

    /* This can't happen, as SVt_NULL is <= all values of new_type, so one of
       the return statements above will have triggered.  */
    assert (new_type != SVt_NULL);
    switch (new_type) {
    case SVt_IV:
	assert(old_type == SVt_NULL);
	SET_SVANY_FOR_BODYLESS_IV(sv);
	SvIV_set(sv, 0);
	return;
    case SVt_NV:
	assert(old_type == SVt_NULL);
#if NVSIZE <= IVSIZE
	SET_SVANY_FOR_BODYLESS_NV(sv);
#else
	SvANY(sv) = new_XNV();
#endif
	SvNV_set(sv, 0);
	return;
    case SVt_PVHV:
    case SVt_PVAV:
	assert(new_type_details->body_size);

#ifndef PURIFY	
	assert(new_type_details->arena);
	assert(new_type_details->arena_size);
	/* This points to the start of the allocated area.  */
	new_body_inline(new_body, new_type);
	Zero(new_body, new_type_details->body_size, char);
	new_body = ((char *)new_body) - new_type_details->offset;
#else
	/* We always allocated the full length item with PURIFY. To do this
	   we fake things so that arena is false for all 16 types..  */
	new_body = new_NOARENAZ(new_type_details);
#endif
	SvANY(sv) = new_body;
	if (new_type == SVt_PVAV) {
	    AvMAX(sv)	= -1;
	    AvFILLp(sv)	= -1;
	    AvREAL_only(sv);
	    if (old_type_details->body_size) {
		AvALLOC(sv) = 0;
	    } else {
		/* It will have been zeroed when the new body was allocated.
		   Lets not write to it, in case it confuses a write-back
		   cache.  */
	    }
	} else {
	    assert(!SvOK(sv));
	    SvOK_off(sv);
#ifndef NODEFAULT_SHAREKEYS
	    HvSHAREKEYS_on(sv);         /* key-sharing on by default */
#endif
            /* start with PERL_HASH_DEFAULT_HvMAX+1 buckets: */
	    HvMAX(sv) = PERL_HASH_DEFAULT_HvMAX;
	}

	/* SVt_NULL isn't the only thing upgraded to AV or HV.
	   The target created by newSVrv also is, and it can have magic.
	   However, it never has SvPVX set.
	*/
	if (old_type == SVt_IV) {
	    assert(!SvROK(sv));
	} else if (old_type >= SVt_PV) {
	    assert(SvPVX_const(sv) == 0);
	}

	if (old_type >= SVt_PVMG) {
	    SvMAGIC_set(sv, ((XPVMG*)old_body)->xmg_u.xmg_magic);
	    SvSTASH_set(sv, ((XPVMG*)old_body)->xmg_stash);
	} else {
	    sv->sv_u.svu_array = NULL; /* or svu_hash  */
	}
	break;

    case SVt_PVIV:
	/* XXX Is this still needed?  Was it ever needed?   Surely as there is
	   no route from NV to PVIV, NOK can never be true  */
	assert(!SvNOKp(sv));
	assert(!SvNOK(sv));
        /* FALLTHROUGH */
    case SVt_PVIO:
    case SVt_PVFM:
    case SVt_PVGV:
    case SVt_PVCV:
    case SVt_PVLV:
    case SVt_INVLIST:
    case SVt_REGEXP:
    case SVt_PVMG:
    case SVt_PVNV:
    case SVt_PV:

	assert(new_type_details->body_size);
	/* We always allocated the full length item with PURIFY. To do this
	   we fake things so that arena is false for all 16 types..  */
	if(new_type_details->arena) {
	    /* This points to the start of the allocated area.  */
	    new_body_inline(new_body, new_type);
	    Zero(new_body, new_type_details->body_size, char);
	    new_body = ((char *)new_body) - new_type_details->offset;
	} else {
	    new_body = new_NOARENAZ(new_type_details);
	}
	SvANY(sv) = new_body;

	if (old_type_details->copy) {
	    /* There is now the potential for an upgrade from something without
	       an offset (PVNV or PVMG) to something with one (PVCV, PVFM)  */
	    int offset = old_type_details->offset;
	    int length = old_type_details->copy;

	    if (new_type_details->offset > old_type_details->offset) {
		const int difference
		    = new_type_details->offset - old_type_details->offset;
		offset += difference;
		length -= difference;
	    }
	    assert (length >= 0);
		
	    Copy((char *)old_body + offset, (char *)new_body + offset, length,
		 char);
	}

#ifndef NV_ZERO_IS_ALLBITS_ZERO
	/* If NV 0.0 is stores as all bits 0 then Zero() already creates a
	 * correct 0.0 for us.  Otherwise, if the old body didn't have an
	 * NV slot, but the new one does, then we need to initialise the
	 * freshly created NV slot with whatever the correct bit pattern is
	 * for 0.0  */
	if (old_type_details->zero_nv && !new_type_details->zero_nv
	    && !isGV_with_GP(sv))
	    SvNV_set(sv, 0);
#endif

	if (UNLIKELY(new_type == SVt_PVIO)) {
	    IO * const io = MUTABLE_IO(sv);
	    GV *iogv = gv_fetchpvs("IO::File::", GV_ADD, SVt_PVHV);

	    SvOBJECT_on(io);
	    /* Clear the stashcache because a new IO could overrule a package
	       name */
            DEBUG_o(Perl_deb(aTHX_ "sv_upgrade clearing PL_stashcache\n"));
	    hv_clear(PL_stashcache);

	    SvSTASH_set(io, MUTABLE_HV(SvREFCNT_inc(GvHV(iogv))));
	    IoPAGE_LEN(sv) = 60;
	}
	if (UNLIKELY(new_type == SVt_REGEXP))
	    sv->sv_u.svu_rx = (regexp *)new_body;
	else if (old_type < SVt_PV) {
	    /* referant will be NULL unless the old type was SVt_IV emulating
	       SVt_RV */
	    sv->sv_u.svu_rv = referant;
	}
	break;
    default:
	Perl_croak(aTHX_ "panic: sv_upgrade to unknown type %lu",
		   (unsigned long)new_type);
    }

    /* if this is zero, this is a body-less SVt_NULL, SVt_IV/SVt_RV,
       and sometimes SVt_NV */
    if (old_type_details->body_size) {
#ifdef PURIFY
	safefree(old_body);
#else
	/* Note that there is an assumption that all bodies of types that
	   can be upgraded came from arenas. Only the more complex non-
	   upgradable types are allowed to be directly malloc()ed.  */
	assert(old_type_details->arena);
	del_body((void*)((char*)old_body + old_type_details->offset),
		 &PL_body_roots[old_type]);
#endif
    }
}

/*
=for apidoc sv_backoff

Remove any string offset.  You should normally use the C<SvOOK_off> macro
wrapper instead.

=cut
*/

/* prior to 5.000 stable, this function returned the new OOK-less SvFLAGS
   prior to 5.23.4 this function always returned 0
*/

void
Perl_sv_backoff(SV *const sv)
{
    STRLEN delta;
    const char * const s = SvPVX_const(sv);

    PERL_ARGS_ASSERT_SV_BACKOFF;

    assert(SvOOK(sv));
    assert(SvTYPE(sv) != SVt_PVHV);
    assert(SvTYPE(sv) != SVt_PVAV);

    SvOOK_offset(sv, delta);
    
    SvLEN_set(sv, SvLEN(sv) + delta);
    SvPV_set(sv, SvPVX(sv) - delta);
    SvFLAGS(sv) &= ~SVf_OOK;
    Move(s, SvPVX(sv), SvCUR(sv)+1, char);
    return;
}

/*
=for apidoc sv_grow

Expands the character buffer in the SV.  If necessary, uses C<sv_unref> and
upgrades the SV to C<SVt_PV>.  Returns a pointer to the character buffer.
Use the C<SvGROW> wrapper instead.

=cut
*/

static void S_sv_uncow(pTHX_ SV * const sv, const U32 flags);

char *
Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
{
    char *s;

    PERL_ARGS_ASSERT_SV_GROW;

    if (SvROK(sv))
	sv_unref(sv);
    if (SvTYPE(sv) < SVt_PV) {
	sv_upgrade(sv, SVt_PV);
	s = SvPVX_mutable(sv);
    }
    else if (SvOOK(sv)) {	/* pv is offset? */
	sv_backoff(sv);
	s = SvPVX_mutable(sv);
	if (newlen > SvLEN(sv))
	    newlen += 10 * (newlen - SvCUR(sv)); /* avoid copy each time */
    }
    else
    {
	if (SvIsCOW(sv)) S_sv_uncow(aTHX_ sv, 0);
	s = SvPVX_mutable(sv);
    }

#ifdef PERL_COPY_ON_WRITE
    /* the new COW scheme uses SvPVX(sv)[SvLEN(sv)-1] (if spare)
     * to store the COW count. So in general, allocate one more byte than
     * asked for, to make it likely this byte is always spare: and thus
     * make more strings COW-able.
     * If the new size is a big power of two, don't bother: we assume the
     * caller wanted a nice 2^N sized block and will be annoyed at getting
     * 2^N+1.
     * Only increment if the allocation isn't MEM_SIZE_MAX,
     * otherwise it will wrap to 0.
     */
    if (   (newlen < 0x1000 || (newlen & (newlen - 1)))
        && newlen != MEM_SIZE_MAX
    )
        newlen++;
#endif

#if defined(PERL_USE_MALLOC_SIZE) && defined(Perl_safesysmalloc_size)
#define PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
#endif

    if (newlen > SvLEN(sv)) {		/* need more room? */
	STRLEN minlen = SvCUR(sv);
	minlen += (minlen >> PERL_STRLEN_EXPAND_SHIFT) + 10;
	if (newlen < minlen)
	    newlen = minlen;
#ifndef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC

        /* Don't round up on the first allocation, as odds are pretty good that
         * the initial request is accurate as to what is really needed */
        if (SvLEN(sv)) {
            STRLEN rounded = PERL_STRLEN_ROUNDUP(newlen);
            if (rounded > newlen)
                newlen = rounded;
        }
#endif
	if (SvLEN(sv) && s) {
	    s = (char*)saferealloc(s, newlen);
	}
	else {
	    s = (char*)safemalloc(newlen);
	    if (SvPVX_const(sv) && SvCUR(sv)) {
	        Move(SvPVX_const(sv), s, (newlen < SvCUR(sv)) ? newlen : SvCUR(sv), char);
	    }
	}
	SvPV_set(sv, s);
#ifdef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
	/* Do this here, do it once, do it right, and then we will never get
	   called back into sv_grow() unless there really is some growing
	   needed.  */
	SvLEN_set(sv, Perl_safesysmalloc_size(s));
#else
        SvLEN_set(sv, newlen);
#endif
    }
    return s;
}

/*
=for apidoc sv_setiv

Copies an integer into the given SV, upgrading first if necessary.
Does not handle 'set' magic.  See also C<L</sv_setiv_mg>>.

=cut
*/

void
Perl_sv_setiv(pTHX_ SV *const sv, const IV i)
{
    PERL_ARGS_ASSERT_SV_SETIV;

    SV_CHECK_THINKFIRST_COW_DROP(sv);
    switch (SvTYPE(sv)) {
    case SVt_NULL:
    case SVt_NV:
	sv_upgrade(sv, SVt_IV);
	break;
    case SVt_PV:
	sv_upgrade(sv, SVt_PVIV);
	break;

    case SVt_PVGV:
	if (!isGV_with_GP(sv))
	    break;
    case SVt_PVAV:
    case SVt_PVHV:
    case SVt_PVCV:
    case SVt_PVFM:
    case SVt_PVIO:
	/* diag_listed_as: Can't coerce %s to %s in %s */
	Perl_croak(aTHX_ "Can't coerce %s to integer in %s", sv_reftype(sv,0),
		   OP_DESC(PL_op));
        break;
    default: NOOP;
    }
    (void)SvIOK_only(sv);			/* validate number */
    SvIV_set(sv, i);
    SvTAINT(sv);
}

/*
=for apidoc sv_setiv_mg

Like C<sv_setiv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setiv_mg(pTHX_ SV *const sv, const IV i)
{
    PERL_ARGS_ASSERT_SV_SETIV_MG;

    sv_setiv(sv,i);
    SvSETMAGIC(sv);
}

/*
=for apidoc sv_setuv

Copies an unsigned integer into the given SV, upgrading first if necessary.
Does not handle 'set' magic.  See also C<L</sv_setuv_mg>>.

=cut
*/

void
Perl_sv_setuv(pTHX_ SV *const sv, const UV u)
{
    PERL_ARGS_ASSERT_SV_SETUV;

    /* With the if statement to ensure that integers are stored as IVs whenever
       possible:
       u=1.49  s=0.52  cu=72.49  cs=10.64  scripts=270  tests=20865

       without
       u=1.35  s=0.47  cu=73.45  cs=11.43  scripts=270  tests=20865

       If you wish to remove the following if statement, so that this routine
       (and its callers) always return UVs, please benchmark to see what the
       effect is. Modern CPUs may be different. Or may not :-)
    */
    if (u <= (UV)IV_MAX) {
       sv_setiv(sv, (IV)u);
       return;
    }
    sv_setiv(sv, 0);
    SvIsUV_on(sv);
    SvUV_set(sv, u);
}

/*
=for apidoc sv_setuv_mg

Like C<sv_setuv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setuv_mg(pTHX_ SV *const sv, const UV u)
{
    PERL_ARGS_ASSERT_SV_SETUV_MG;

    sv_setuv(sv,u);
    SvSETMAGIC(sv);
}

/*
=for apidoc sv_setnv

Copies a double into the given SV, upgrading first if necessary.
Does not handle 'set' magic.  See also C<L</sv_setnv_mg>>.

=cut
*/

void
Perl_sv_setnv(pTHX_ SV *const sv, const NV num)
{
    PERL_ARGS_ASSERT_SV_SETNV;

    SV_CHECK_THINKFIRST_COW_DROP(sv);
    switch (SvTYPE(sv)) {
    case SVt_NULL:
    case SVt_IV:
	sv_upgrade(sv, SVt_NV);
	break;
    case SVt_PV:
    case SVt_PVIV:
	sv_upgrade(sv, SVt_PVNV);
	break;

    case SVt_PVGV:
	if (!isGV_with_GP(sv))
	    break;
    case SVt_PVAV:
    case SVt_PVHV:
    case SVt_PVCV:
    case SVt_PVFM:
    case SVt_PVIO:
	/* diag_listed_as: Can't coerce %s to %s in %s */
	Perl_croak(aTHX_ "Can't coerce %s to number in %s", sv_reftype(sv,0),
		   OP_DESC(PL_op));
        break;
    default: NOOP;
    }
    SvNV_set(sv, num);
    (void)SvNOK_only(sv);			/* validate number */
    SvTAINT(sv);
}

/*
=for apidoc sv_setnv_mg

Like C<sv_setnv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setnv_mg(pTHX_ SV *const sv, const NV num)
{
    PERL_ARGS_ASSERT_SV_SETNV_MG;

    sv_setnv(sv,num);
    SvSETMAGIC(sv);
}

/* Return a cleaned-up, printable version of sv, for non-numeric, or
 * not incrementable warning display.
 * Originally part of S_not_a_number().
 * The return value may be != tmpbuf.
 */

STATIC const char *
S_sv_display(pTHX_ SV *const sv, char *tmpbuf, STRLEN tmpbuf_size) {
    const char *pv;

     PERL_ARGS_ASSERT_SV_DISPLAY;

     if (DO_UTF8(sv)) {
          SV *dsv = newSVpvs_flags("", SVs_TEMP);
          pv = sv_uni_display(dsv, sv, 32, UNI_DISPLAY_ISPRINT);
     } else {
	  char *d = tmpbuf;
	  const char * const limit = tmpbuf + tmpbuf_size - 8;
	  /* each *s can expand to 4 chars + "...\0",
	     i.e. need room for 8 chars */
	
	  const char *s = SvPVX_const(sv);
	  const char * const end = s + SvCUR(sv);
	  for ( ; s < end && d < limit; s++ ) {
	       int ch = *s & 0xFF;
	       if (! isASCII(ch) && !isPRINT_LC(ch)) {
		    *d++ = 'M';
		    *d++ = '-';

                    /* Map to ASCII "equivalent" of Latin1 */
		    ch = LATIN1_TO_NATIVE(NATIVE_TO_LATIN1(ch) & 127);
	       }
	       if (ch == '\n') {
		    *d++ = '\\';
		    *d++ = 'n';
	       }
	       else if (ch == '\r') {
		    *d++ = '\\';
		    *d++ = 'r';
	       }
	       else if (ch == '\f') {
		    *d++ = '\\';
		    *d++ = 'f';
	       }
	       else if (ch == '\\') {
		    *d++ = '\\';
		    *d++ = '\\';
	       }
	       else if (ch == '\0') {
		    *d++ = '\\';
		    *d++ = '0';
	       }
	       else if (isPRINT_LC(ch))
		    *d++ = ch;
	       else {
		    *d++ = '^';
		    *d++ = toCTRL(ch);
	       }
	  }
	  if (s < end) {
	       *d++ = '.';
	       *d++ = '.';
	       *d++ = '.';
	  }
	  *d = '\0';
	  pv = tmpbuf;
    }

    return pv;
}

/* Print an "isn't numeric" warning, using a cleaned-up,
 * printable version of the offending string
 */

STATIC void
S_not_a_number(pTHX_ SV *const sv)
{
     char tmpbuf[64];
     const char *pv;

     PERL_ARGS_ASSERT_NOT_A_NUMBER;

     pv = sv_display(sv, tmpbuf, sizeof(tmpbuf));

    if (PL_op)
	Perl_warner(aTHX_ packWARN(WARN_NUMERIC),
		    /* diag_listed_as: Argument "%s" isn't numeric%s */
		    "Argument \"%s\" isn't numeric in %s", pv,
		    OP_DESC(PL_op));
    else
	Perl_warner(aTHX_ packWARN(WARN_NUMERIC),
		    /* diag_listed_as: Argument "%s" isn't numeric%s */
		    "Argument \"%s\" isn't numeric", pv);
}

STATIC void
S_not_incrementable(pTHX_ SV *const sv) {
     char tmpbuf[64];
     const char *pv;

     PERL_ARGS_ASSERT_NOT_INCREMENTABLE;

     pv = sv_display(sv, tmpbuf, sizeof(tmpbuf));

     Perl_warner(aTHX_ packWARN(WARN_NUMERIC),
                 "Argument \"%s\" treated as 0 in increment (++)", pv);
}

/*
=for apidoc looks_like_number

Test if the content of an SV looks like a number (or is a number).
C<Inf> and C<Infinity> are treated as numbers (so will not issue a
non-numeric warning), even if your C<atof()> doesn't grok them.  Get-magic is
ignored.

=cut
*/

I32
Perl_looks_like_number(pTHX_ SV *const sv)
{
    const char *sbegin;
    STRLEN len;
    int numtype;

    PERL_ARGS_ASSERT_LOOKS_LIKE_NUMBER;

    if (SvPOK(sv) || SvPOKp(sv)) {
	sbegin = SvPV_nomg_const(sv, len);
    }
    else
	return SvFLAGS(sv) & (SVf_NOK|SVp_NOK|SVf_IOK|SVp_IOK);
    numtype = grok_number(sbegin, len, NULL);
    return ((numtype & IS_NUMBER_TRAILING)) ? 0 : numtype;
}

STATIC bool
S_glob_2number(pTHX_ GV * const gv)
{
    PERL_ARGS_ASSERT_GLOB_2NUMBER;

    /* We know that all GVs stringify to something that is not-a-number,
	so no need to test that.  */
    if (ckWARN(WARN_NUMERIC))
    {
	SV *const buffer = sv_newmortal();
	gv_efullname3(buffer, gv, "*");
	not_a_number(buffer);
    }
    /* We just want something true to return, so that S_sv_2iuv_common
	can tail call us and return true.  */
    return TRUE;
}

/* Actually, ISO C leaves conversion of UV to IV undefined, but
   until proven guilty, assume that things are not that bad... */

/*
   NV_PRESERVES_UV:

   As 64 bit platforms often have an NV that doesn't preserve all bits of
   an IV (an assumption perl has been based on to date) it becomes necessary
   to remove the assumption that the NV always carries enough precision to
   recreate the IV whenever needed, and that the NV is the canonical form.
   Instead, IV/UV and NV need to be given equal rights. So as to not lose
   precision as a side effect of conversion (which would lead to insanity
   and the dragon(s) in t/op/numconvert.t getting very angry) the intent is
   1) to distinguish between IV/UV/NV slots that have a valid conversion cached
      where precision was lost, and IV/UV/NV slots that have a valid conversion
      which has lost no precision
   2) to ensure that if a numeric conversion to one form is requested that
      would lose precision, the precise conversion (or differently
      imprecise conversion) is also performed and cached, to prevent
      requests for different numeric formats on the same SV causing
      lossy conversion chains. (lossless conversion chains are perfectly
      acceptable (still))


   flags are used:
   SvIOKp is true if the IV slot contains a valid value
   SvIOK  is true only if the IV value is accurate (UV if SvIOK_UV true)
   SvNOKp is true if the NV slot contains a valid value
   SvNOK  is true only if the NV value is accurate

   so
   while converting from PV to NV, check to see if converting that NV to an
   IV(or UV) would lose accuracy over a direct conversion from PV to
   IV(or UV). If it would, cache both conversions, return NV, but mark
   SV as IOK NOKp (ie not NOK).

   While converting from PV to IV, check to see if converting that IV to an
   NV would lose accuracy over a direct conversion from PV to NV. If it
   would, cache both conversions, flag similarly.

   Before, the SV value "3.2" could become NV=3.2 IV=3 NOK, IOK quite
   correctly because if IV & NV were set NV *always* overruled.
   Now, "3.2" will become NV=3.2 IV=3 NOK, IOKp, because the flag's meaning
   changes - now IV and NV together means that the two are interchangeable:
   SvIVX == (IV) SvNVX && SvNVX == (NV) SvIVX;

   The benefit of this is that operations such as pp_add know that if
   SvIOK is true for both left and right operands, then integer addition
   can be used instead of floating point (for cases where the result won't
   overflow). Before, floating point was always used, which could lead to
   loss of precision compared with integer addition.

   * making IV and NV equal status should make maths accurate on 64 bit
     platforms
   * may speed up maths somewhat if pp_add and friends start to use
     integers when possible instead of fp. (Hopefully the overhead in
     looking for SvIOK and checking for overflow will not outweigh the
     fp to integer speedup)
   * will slow down integer operations (callers of SvIV) on "inaccurate"
     values, as the change from SvIOK to SvIOKp will cause a call into
     sv_2iv each time rather than a macro access direct to the IV slot
   * should speed up number->string conversion on integers as IV is
     favoured when IV and NV are equally accurate

   ####################################################################
   You had better be using SvIOK_notUV if you want an IV for arithmetic:
   SvIOK is true if (IV or UV), so you might be getting (IV)SvUV.
   On the other hand, SvUOK is true iff UV.
   ####################################################################

   Your mileage will vary depending your CPU's relative fp to integer
   performance ratio.
*/

#ifndef NV_PRESERVES_UV
#  define IS_NUMBER_UNDERFLOW_IV 1
#  define IS_NUMBER_UNDERFLOW_UV 2
#  define IS_NUMBER_IV_AND_UV    2
#  define IS_NUMBER_OVERFLOW_IV  4
#  define IS_NUMBER_OVERFLOW_UV  5

/* sv_2iuv_non_preserve(): private routine for use by sv_2iv() and sv_2uv() */

/* For sv_2nv these three cases are "SvNOK and don't bother casting"  */
STATIC int
S_sv_2iuv_non_preserve(pTHX_ SV *const sv
#  ifdef DEBUGGING
		       , I32 numtype
#  endif
		       )
{
    PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE;
    PERL_UNUSED_CONTEXT;

    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_2iuv_non '%s', IV=0x%"UVxf" NV=%"NVgf" inttype=%"UVXf"\n", SvPVX_const(sv), SvIVX(sv), SvNVX(sv), (UV)numtype));
    if (SvNVX(sv) < (NV)IV_MIN) {
	(void)SvIOKp_on(sv);
	(void)SvNOK_on(sv);
	SvIV_set(sv, IV_MIN);
	return IS_NUMBER_UNDERFLOW_IV;
    }
    if (SvNVX(sv) > (NV)UV_MAX) {
	(void)SvIOKp_on(sv);
	(void)SvNOK_on(sv);
	SvIsUV_on(sv);
	SvUV_set(sv, UV_MAX);
	return IS_NUMBER_OVERFLOW_UV;
    }
    (void)SvIOKp_on(sv);
    (void)SvNOK_on(sv);
    /* Can't use strtol etc to convert this string.  (See truth table in
       sv_2iv  */
    if (SvNVX(sv) <= (UV)IV_MAX) {
        SvIV_set(sv, I_V(SvNVX(sv)));
        if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
            SvIOK_on(sv); /* Integer is precise. NOK, IOK */
        } else {
            /* Integer is imprecise. NOK, IOKp */
        }
        return SvNVX(sv) < 0 ? IS_NUMBER_UNDERFLOW_UV : IS_NUMBER_IV_AND_UV;
    }
    SvIsUV_on(sv);
    SvUV_set(sv, U_V(SvNVX(sv)));
    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
        if (SvUVX(sv) == UV_MAX) {
            /* As we know that NVs don't preserve UVs, UV_MAX cannot
               possibly be preserved by NV. Hence, it must be overflow.
               NOK, IOKp */
            return IS_NUMBER_OVERFLOW_UV;
        }
        SvIOK_on(sv); /* Integer is precise. NOK, UOK */
    } else {
        /* Integer is imprecise. NOK, IOKp */
    }
    return IS_NUMBER_OVERFLOW_IV;
}
#endif /* !NV_PRESERVES_UV*/

/* If numtype is infnan, set the NV of the sv accordingly.
 * If numtype is anything else, try setting the NV using Atof(PV). */
#ifdef USING_MSVC6
#  pragma warning(push)
#  pragma warning(disable:4756;disable:4056)
#endif
static void
S_sv_setnv(pTHX_ SV* sv, int numtype)
{
    bool pok = cBOOL(SvPOK(sv));
    bool nok = FALSE;
    if ((numtype & IS_NUMBER_INFINITY)) {
        SvNV_set(sv, (numtype & IS_NUMBER_NEG) ? -NV_INF : NV_INF);
        nok = TRUE;
    }
    else if ((numtype & IS_NUMBER_NAN)) {
        SvNV_set(sv, NV_NAN);
        nok = TRUE;
    }
    else if (pok) {
        SvNV_set(sv, Atof(SvPVX_const(sv)));
        /* Purposefully no true nok here, since we don't want to blow
         * away the possible IOK/UV of an existing sv. */
    }
    if (nok) {
        SvNOK_only(sv); /* No IV or UV please, this is pure infnan. */
        if (pok)
            SvPOK_on(sv); /* PV is okay, though. */
    }
}
#ifdef USING_MSVC6
#  pragma warning(pop)
#endif

STATIC bool
S_sv_2iuv_common(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_SV_2IUV_COMMON;

    if (SvNOKp(sv)) {
	/* erm. not sure. *should* never get NOKp (without NOK) from sv_2nv
	 * without also getting a cached IV/UV from it at the same time
	 * (ie PV->NV conversion should detect loss of accuracy and cache
	 * IV or UV at same time to avoid this. */
	/* IV-over-UV optimisation - choose to cache IV if possible */

	if (SvTYPE(sv) == SVt_NV)
	    sv_upgrade(sv, SVt_PVNV);

	(void)SvIOKp_on(sv);	/* Must do this first, to clear any SvOOK */
	/* < not <= as for NV doesn't preserve UV, ((NV)IV_MAX+1) will almost
	   certainly cast into the IV range at IV_MAX, whereas the correct
	   answer is the UV IV_MAX +1. Hence < ensures that dodgy boundary
	   cases go to UV */
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	if (Perl_isnan(SvNVX(sv))) {
	    SvUV_set(sv, 0);
	    SvIsUV_on(sv);
	    return FALSE;
	}
#endif
	if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
	    SvIV_set(sv, I_V(SvNVX(sv)));
	    if (SvNVX(sv) == (NV) SvIVX(sv)
#ifndef NV_PRESERVES_UV
                && SvIVX(sv) != IV_MIN /* avoid negating IV_MIN below */
		&& (((UV)1 << NV_PRESERVES_UV_BITS) >
		    (UV)(SvIVX(sv) > 0 ? SvIVX(sv) : -SvIVX(sv)))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		) {
		if (SvNOK(sv))
		    SvIOK_on(sv);  /* Can this go wrong with rounding? NWC */
		else {
		    /* scalar has trailing garbage, eg "42a" */
		}
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" iv(%"NVgf" => %"IVdf") (precise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));

	    } else {
		/* IV not precise.  No need to convert from PV, as NV
		   conversion would already have cached IV if it detected
		   that PV->IV would be better than PV->NV->IV
		   flags already correct - don't set public IOK.  */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" iv(%"NVgf" => %"IVdf") (imprecise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));
	    }
	    /* Can the above go wrong if SvIVX == IV_MIN and SvNVX < IV_MIN,
	       but the cast (NV)IV_MIN rounds to a the value less (more
	       negative) than IV_MIN which happens to be equal to SvNVX ??
	       Analogous to 0xFFFFFFFFFFFFFFFF rounding up to NV (2**64) and
	       NV rounding back to 0xFFFFFFFFFFFFFFFF, so UVX == UV(NVX) and
	       (NV)UVX == NVX are both true, but the values differ. :-(
	       Hopefully for 2s complement IV_MIN is something like
	       0x8000000000000000 which will be exact. NWC */
	}
	else {
	    SvUV_set(sv, U_V(SvNVX(sv)));
	    if (
		(SvNVX(sv) == (NV) SvUVX(sv))
#ifndef  NV_PRESERVES_UV
		/* Make sure it's not 0xFFFFFFFFFFFFFFFF */
		/*&& (SvUVX(sv) != UV_MAX) irrelevant with code below */
		&& (((UV)1 << NV_PRESERVES_UV_BITS) > SvUVX(sv))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		&& SvNOK(sv)
		)
		SvIOK_on(sv);
	    SvIsUV_on(sv);
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2iv(%"UVuf" => %"IVdf") (as unsigned)\n",
				  PTR2UV(sv),
				  SvUVX(sv),
				  SvUVX(sv)));
	}
    }
    else if (SvPOKp(sv)) {
	UV value;
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
	/* We want to avoid a possible problem when we cache an IV/ a UV which
	   may be later translated to an NV, and the resulting NV is not
	   the same as the direct translation of the initial string
	   (eg 123.456 can shortcut to the IV 123 with atol(), but we must
	   be careful to ensure that the value with the .456 is around if the
	   NV value is requested in the future).
	
	   This means that if we cache such an IV/a UV, we need to cache the
	   NV as well.  Moreover, we trade speed for space, and do not
	   cache the NV if we are sure it's not needed.
	 */

	/* SVt_PVNV is one higher than SVt_PVIV, hence this order  */
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	     == IS_NUMBER_IN_UV) {
	    /* It's definitely an integer, only upgrade to PVIV */
	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	} else if (SvTYPE(sv) < SVt_PVNV)
	    sv_upgrade(sv, SVt_PVNV);

        if ((numtype & (IS_NUMBER_INFINITY | IS_NUMBER_NAN))) {
            if (ckWARN(WARN_NUMERIC) && ((numtype & IS_NUMBER_TRAILING)))
		not_a_number(sv);
            S_sv_setnv(aTHX_ sv, numtype);
            return FALSE;
        }

	/* If NVs preserve UVs then we only use the UV value if we know that
	   we aren't going to call atof() below. If NVs don't preserve UVs
	   then the value returned may have more precision than atof() will
	   return, even though value isn't perfectly accurate.  */
	if ((numtype & (IS_NUMBER_IN_UV
#ifdef NV_PRESERVES_UV
			| IS_NUMBER_NOT_INT
#endif
	    )) == IS_NUMBER_IN_UV) {
	    /* This won't turn off the public IOK flag if it was set above  */
	    (void)SvIOKp_on(sv);

	    if (!(numtype & IS_NUMBER_NEG)) {
		/* positive */;
		if (value <= (UV)IV_MAX) {
		    SvIV_set(sv, (IV)value);
		} else {
		    /* it didn't overflow, and it was positive. */
		    SvUV_set(sv, value);
		    SvIsUV_on(sv);
		}
	    } else {
		/* 2s complement assumption  */
		if (value <= (UV)IV_MIN) {
		    SvIV_set(sv, value == (UV)IV_MIN
                                    ? IV_MIN : -(IV)value);
		} else {
		    /* Too negative for an IV.  This is a double upgrade, but
		       I'm assuming it will be rare.  */
		    if (SvTYPE(sv) < SVt_PVNV)
			sv_upgrade(sv, SVt_PVNV);
		    SvNOK_on(sv);
		    SvIOK_off(sv);
		    SvIOKp_on(sv);
		    SvNV_set(sv, -(NV)value);
		    SvIV_set(sv, IV_MIN);
		}
	    }
	}
	/* For !NV_PRESERVES_UV and IS_NUMBER_IN_UV and IS_NUMBER_NOT_INT we
           will be in the previous block to set the IV slot, and the next
           block to set the NV slot.  So no else here.  */
	
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	    != IS_NUMBER_IN_UV) {
	    /* It wasn't an (integer that doesn't overflow the UV). */
            S_sv_setnv(aTHX_ sv, numtype);

	    if (! numtype && ckWARN(WARN_NUMERIC))
		not_a_number(sv);

	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%" NVgf ")\n",
				  PTR2UV(sv), SvNVX(sv)));

#ifdef NV_PRESERVES_UV
            (void)SvIOKp_on(sv);
            (void)SvNOK_on(sv);
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
            if (Perl_isnan(SvNVX(sv))) {
                SvUV_set(sv, 0);
                SvIsUV_on(sv);
                return FALSE;
            }
#endif
            if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
                SvIV_set(sv, I_V(SvNVX(sv)));
                if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
                    SvIOK_on(sv);
                } else {
		    NOOP;  /* Integer is imprecise. NOK, IOKp */
                }
                /* UV will not work better than IV */
            } else {
                if (SvNVX(sv) > (NV)UV_MAX) {
                    SvIsUV_on(sv);
                    /* Integer is inaccurate. NOK, IOKp, is UV */
                    SvUV_set(sv, UV_MAX);
                } else {
                    SvUV_set(sv, U_V(SvNVX(sv)));
                    /* 0xFFFFFFFFFFFFFFFF not an issue in here, NVs
                       NV preservse UV so can do correct comparison.  */
                    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
                        SvIOK_on(sv);
                    } else {
			NOOP;   /* Integer is imprecise. NOK, IOKp, is UV */
                    }
                }
		SvIsUV_on(sv);
            }
#else /* NV_PRESERVES_UV */
            if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
                == (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT)) {
                /* The IV/UV slot will have been set from value returned by
                   grok_number above.  The NV slot has just been set using
                   Atof.  */
	        SvNOK_on(sv);
                assert (SvIOKp(sv));
            } else {
                if (((UV)1 << NV_PRESERVES_UV_BITS) >
                    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
                    /* Small enough to preserve all bits. */
                    (void)SvIOKp_on(sv);
                    SvNOK_on(sv);
                    SvIV_set(sv, I_V(SvNVX(sv)));
                    if ((NV)(SvIVX(sv)) == SvNVX(sv))
                        SvIOK_on(sv);
                    /* Assumption: first non-preserved integer is < IV_MAX,
                       this NV is in the preserved range, therefore: */
                    if (!(U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))
                          < (UV)IV_MAX)) {
                        Perl_croak(aTHX_ "sv_2iv assumed (U_V(fabs((double)SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
                    }
                } else {
                    /* IN_UV NOT_INT
                         0      0	already failed to read UV.
                         0      1       already failed to read UV.
                         1      0       you won't get here in this case. IV/UV
                         	        slot set, public IOK, Atof() unneeded.
                         1      1       already read UV.
                       so there's no point in sv_2iuv_non_preserve() attempting
                       to use atol, strtol, strtoul etc.  */
#  ifdef DEBUGGING
                    sv_2iuv_non_preserve (sv, numtype);
#  else
                    sv_2iuv_non_preserve (sv);
#  endif
                }
            }
#endif /* NV_PRESERVES_UV */
	/* It might be more code efficient to go through the entire logic above
	   and conditionally set with SvIOKp_on() rather than SvIOK(), but it
	   gets complex and potentially buggy, so more programmer efficient
	   to do it this way, by turning off the public flags:  */
	if (!numtype)
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK);
	}
    }
    else  {
	if (isGV_with_GP(sv))
	    return glob_2number(MUTABLE_GV(sv));

	if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	if (SvTYPE(sv) < SVt_IV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    sv_upgrade(sv, SVt_IV);
	/* Return 0 from the caller.  */
	return TRUE;
    }
    return FALSE;
}

/*
=for apidoc sv_2iv_flags

Return the integer value of an SV, doing any necessary string
conversion.  If C<flags> has the C<SV_GMAGIC> bit set, does an C<mg_get()> first.
Normally used via the C<SvIV(sv)> and C<SvIVx(sv)> macros.

=cut
*/

IV
Perl_sv_2iv_flags(pTHX_ SV *const sv, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_2IV_FLAGS;

    assert (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVHV
	 && SvTYPE(sv) != SVt_PVFM);

    if (SvGMAGICAL(sv) && (flags & SV_GMAGIC))
	mg_get(sv);

    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV * tmpstr;
	    if (flags & SV_SKIP_OVERLOAD)
		return 0;
	    tmpstr = AMG_CALLunary(sv, numer_amg);
	    if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		return SvIV(tmpstr);
	    }
	}
	return PTR2IV(SvRV(sv));
    }

    if (SvVALID(sv) || isREGEXP(sv)) {
	/* FBMs use the space for SvIVX and SvNVX for other purposes, and use
	   the same flag bit as SVf_IVisUV, so must not let them cache IVs.
	   In practice they are extremely unlikely to actually get anywhere
	   accessible by user Perl code - the only way that I'm aware of is when
	   a constant subroutine which is used as the second argument to index.

	   Regexps have no SvIVX and SvNVX fields.
	*/
	assert(isREGEXP(sv) || SvPOKp(sv));
	{
	    UV value;
	    const char * const ptr =
		isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX_const(sv);
	    const int numtype
		= grok_number(ptr, SvCUR(sv), &value);

	    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
		== IS_NUMBER_IN_UV) {
		/* It's definitely an integer */
		if (numtype & IS_NUMBER_NEG) {
		    if (value < (UV)IV_MIN)
			return -(IV)value;
		} else {
		    if (value < (UV)IV_MAX)
			return (IV)value;
		}
	    }

            /* Quite wrong but no good choices. */
            if ((numtype & IS_NUMBER_INFINITY)) {
                return (numtype & IS_NUMBER_NEG) ? IV_MIN : IV_MAX;
            } else if ((numtype & IS_NUMBER_NAN)) {
                return 0; /* So wrong. */
            }

	    if (!numtype) {
		if (ckWARN(WARN_NUMERIC))
		    not_a_number(sv);
	    }
	    return I_V(Atof(ptr));
	}
    }

    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	    return 0;
	}
    }

    if (!SvIOKp(sv)) {
	if (S_sv_2iuv_common(aTHX_ sv))
	    return 0;
    }

    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%"IVdf")\n",
	PTR2UV(sv),SvIVX(sv)));
    return SvIsUV(sv) ? (IV)SvUVX(sv) : SvIVX(sv);
}

/*
=for apidoc sv_2uv_flags

Return the unsigned integer value of an SV, doing any necessary string
conversion.  If C<flags> has the C<SV_GMAGIC> bit set, does an C<mg_get()> first.
Normally used via the C<SvUV(sv)> and C<SvUVx(sv)> macros.

=cut
*/

UV
Perl_sv_2uv_flags(pTHX_ SV *const sv, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_2UV_FLAGS;

    if (SvGMAGICAL(sv) && (flags & SV_GMAGIC))
	mg_get(sv);

    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV *tmpstr;
	    if (flags & SV_SKIP_OVERLOAD)
		return 0;
	    tmpstr = AMG_CALLunary(sv, numer_amg);
	    if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		return SvUV(tmpstr);
	    }
	}
	return PTR2UV(SvRV(sv));
    }

    if (SvVALID(sv) || isREGEXP(sv)) {
	/* FBMs use the space for SvIVX and SvNVX for other purposes, and use
	   the same flag bit as SVf_IVisUV, so must not let them cache IVs.  
	   Regexps have no SvIVX and SvNVX fields. */
	assert(isREGEXP(sv) || SvPOKp(sv));
	{
	    UV value;
	    const char * const ptr =
		isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX_const(sv);
	    const int numtype
		= grok_number(ptr, SvCUR(sv), &value);

	    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
		== IS_NUMBER_IN_UV) {
		/* It's definitely an integer */
		if (!(numtype & IS_NUMBER_NEG))
		    return value;
	    }

            /* Quite wrong but no good choices. */
            if ((numtype & IS_NUMBER_INFINITY)) {
                return UV_MAX; /* So wrong. */
            } else if ((numtype & IS_NUMBER_NAN)) {
                return 0; /* So wrong. */
            }

	    if (!numtype) {
		if (ckWARN(WARN_NUMERIC))
		    not_a_number(sv);
	    }
	    return U_V(Atof(ptr));
	}
    }

    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	    return 0;
	}
    }

    if (!SvIOKp(sv)) {
	if (S_sv_2iuv_common(aTHX_ sv))
	    return 0;
    }

    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2uv(%"UVuf")\n",
			  PTR2UV(sv),SvUVX(sv)));
    return SvIsUV(sv) ? SvUVX(sv) : (UV)SvIVX(sv);
}

/*
=for apidoc sv_2nv_flags

Return the num value of an SV, doing any necessary string or integer
conversion.  If C<flags> has the C<SV_GMAGIC> bit set, does an C<mg_get()> first.
Normally used via the C<SvNV(sv)> and C<SvNVx(sv)> macros.

=cut
*/

NV
Perl_sv_2nv_flags(pTHX_ SV *const sv, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_2NV_FLAGS;

    assert (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVHV
	 && SvTYPE(sv) != SVt_PVFM);
    if (SvGMAGICAL(sv) || SvVALID(sv) || isREGEXP(sv)) {
	/* FBMs use the space for SvIVX and SvNVX for other purposes, and use
	   the same flag bit as SVf_IVisUV, so must not let them cache NVs.
	   Regexps have no SvIVX and SvNVX fields.  */
	const char *ptr;
	if (flags & SV_GMAGIC)
	    mg_get(sv);
	if (SvNOKp(sv))
	    return SvNVX(sv);
	if (SvPOKp(sv) && !SvIOKp(sv)) {
	    ptr = SvPVX_const(sv);
	  grokpv:
	    if (!SvIOKp(sv) && ckWARN(WARN_NUMERIC) &&
		!grok_number(ptr, SvCUR(sv), NULL))
		not_a_number(sv);
	    return Atof(ptr);
	}
	if (SvIOKp(sv)) {
	    if (SvIsUV(sv))
		return (NV)SvUVX(sv);
	    else
		return (NV)SvIVX(sv);
	}
        if (SvROK(sv)) {
	    goto return_rok;
	}
	if (isREGEXP(sv)) {
	    ptr = RX_WRAPPED((REGEXP *)sv);
	    goto grokpv;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit near the end of the
	   function. */
    } else if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	return_rok:
	    if (SvAMAGIC(sv)) {
		SV *tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return 0;
		tmpstr = AMG_CALLunary(sv, numer_amg);
                if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvNV(tmpstr);
		}
	    }
	    return PTR2NV(SvRV(sv));
	}
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	    return 0.0;
	}
    }
    if (SvTYPE(sv) < SVt_NV) {
	/* The logic to use SVt_PVNV if necessary is in sv_upgrade.  */
	sv_upgrade(sv, SVt_NV);
	DEBUG_c({
	    STORE_NUMERIC_LOCAL_SET_STANDARD();
	    PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" num(%" NVgf ")\n",
			  PTR2UV(sv), SvNVX(sv));
	    RESTORE_NUMERIC_LOCAL();
	});
    }
    else if (SvTYPE(sv) < SVt_PVNV)
	sv_upgrade(sv, SVt_PVNV);
    if (SvNOKp(sv)) {
        return SvNVX(sv);
    }
    if (SvIOKp(sv)) {
	SvNV_set(sv, SvIsUV(sv) ? (NV)SvUVX(sv) : (NV)SvIVX(sv));
#ifdef NV_PRESERVES_UV
	if (SvIOK(sv))
	    SvNOK_on(sv);
	else
	    SvNOKp_on(sv);
#else
	/* Only set the public NV OK flag if this NV preserves the IV  */
	/* Check it's not 0xFFFFFFFFFFFFFFFF */
	if (SvIOK(sv) &&
	    SvIsUV(sv) ? ((SvUVX(sv) != UV_MAX)&&(SvUVX(sv) == U_V(SvNVX(sv))))
		       : (SvIVX(sv) == I_V(SvNVX(sv))))
	    SvNOK_on(sv);
	else
	    SvNOKp_on(sv);
#endif
    }
    else if (SvPOKp(sv)) {
	UV value;
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
	if (!SvIOKp(sv) && !numtype && ckWARN(WARN_NUMERIC))
	    not_a_number(sv);
#ifdef NV_PRESERVES_UV
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	    == IS_NUMBER_IN_UV) {
	    /* It's definitely an integer */
	    SvNV_set(sv, (numtype & IS_NUMBER_NEG) ? -(NV)value : (NV)value);
	} else {
            S_sv_setnv(aTHX_ sv, numtype);
        }
	if (numtype)
	    SvNOK_on(sv);
	else
	    SvNOKp_on(sv);
#else
	SvNV_set(sv, Atof(SvPVX_const(sv)));
	/* Only set the public NV OK flag if this NV preserves the value in
	   the PV at least as well as an IV/UV would.
	   Not sure how to do this 100% reliably. */
	/* if that shift count is out of range then Configure's test is
	   wonky. We shouldn't be in here with NV_PRESERVES_UV_BITS ==
	   UV_BITS */
	if (((UV)1 << NV_PRESERVES_UV_BITS) >
	    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
	    SvNOK_on(sv); /* Definitely small enough to preserve all bits */
	} else if (!(numtype & IS_NUMBER_IN_UV)) {
            /* Can't use strtol etc to convert this string, so don't try.
               sv_2iv and sv_2uv will use the NV to convert, not the PV.  */
            SvNOK_on(sv);
        } else {
            /* value has been set.  It may not be precise.  */
	    if ((numtype & IS_NUMBER_NEG) && (value >= (UV)IV_MIN)) {
		/* 2s complement assumption for (UV)IV_MIN  */
                SvNOK_on(sv); /* Integer is too negative.  */
            } else {
                SvNOKp_on(sv);
                SvIOKp_on(sv);

                if (numtype & IS_NUMBER_NEG) {
                    /* -IV_MIN is undefined, but we should never reach
                     * this point with both IS_NUMBER_NEG and value ==
                     * (UV)IV_MIN */
                    assert(value != (UV)IV_MIN);
                    SvIV_set(sv, -(IV)value);
                } else if (value <= (UV)IV_MAX) {
		    SvIV_set(sv, (IV)value);
		} else {
		    SvUV_set(sv, value);
		    SvIsUV_on(sv);
		}

                if (numtype & IS_NUMBER_NOT_INT) {
                    /* I believe that even if the original PV had decimals,
                       they are lost beyond the limit of the FP precision.
                       However, neither is canonical, so both only get p
                       flags.  NWC, 2000/11/25 */
                    /* Both already have p flags, so do nothing */
                } else {
		    const NV nv = SvNVX(sv);
                    /* XXX should this spot have NAN_COMPARE_BROKEN, too? */
                    if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
                        if (SvIVX(sv) == I_V(nv)) {
                            SvNOK_on(sv);
                        } else {
                            /* It had no "." so it must be integer.  */
                        }
			SvIOK_on(sv);
                    } else {
                        /* between IV_MAX and NV(UV_MAX).
                           Could be slightly > UV_MAX */

                        if (numtype & IS_NUMBER_NOT_INT) {
                            /* UV and NV both imprecise.  */
                        } else {
			    const UV nv_as_uv = U_V(nv);

                            if (value == nv_as_uv && SvUVX(sv) != UV_MAX) {
                                SvNOK_on(sv);
                            }
			    SvIOK_on(sv);
                        }
                    }
                }
            }
        }
	/* It might be more code efficient to go through the entire logic above
	   and conditionally set with SvNOKp_on() rather than SvNOK(), but it
	   gets complex and potentially buggy, so more programmer efficient
	   to do it this way, by turning off the public flags:  */
	if (!numtype)
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK);
#endif /* NV_PRESERVES_UV */
    }
    else  {
	if (isGV_with_GP(sv)) {
	    glob_2number(MUTABLE_GV(sv));
	    return 0.0;
	}

	if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
	    report_uninit(sv);
	assert (SvTYPE(sv) >= SVt_NV);
	/* Typically the caller expects that sv_any is not NULL now.  */
	/* XXX Ilya implies that this is a bug in callers that assume this
	   and ideally should be fixed.  */
	return 0.0;
    }
    DEBUG_c({
	STORE_NUMERIC_LOCAL_SET_STANDARD();
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%" NVgf ")\n",
		      PTR2UV(sv), SvNVX(sv));
	RESTORE_NUMERIC_LOCAL();
    });
    return SvNVX(sv);
}

/*
=for apidoc sv_2num

Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  The caller is expected to have handled
get-magic already.

=cut
*/

SV *
Perl_sv_2num(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_SV_2NUM;

    if (!SvROK(sv))
	return sv;
    if (SvAMAGIC(sv)) {
	SV * const tmpsv = AMG_CALLunary(sv, numer_amg);
	TAINT_IF(tmpsv && SvTAINTED(tmpsv));
	if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv))))
	    return sv_2num(tmpsv);
    }
    return sv_2mortal(newSVuv(PTR2UV(SvRV(sv))));
}

/* uiv_2buf(): private routine for use by sv_2pv_flags(): print an IV or
 * UV as a string towards the end of buf, and return pointers to start and
 * end of it.
 *
 * We assume that buf is at least TYPE_CHARS(UV) long.
 */

static char *
S_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)
{
    char *ptr = buf + TYPE_CHARS(UV);
    char * const ebuf = ptr;
    int sign;

    PERL_ARGS_ASSERT_UIV_2BUF;

    if (is_uv)
	sign = 0;
    else if (iv >= 0) {
	uv = iv;
	sign = 0;
    } else {
        uv = (iv == IV_MIN) ? (UV)iv : (UV)(-iv);
	sign = 1;
    }
    do {
	*--ptr = '0' + (char)(uv % 10);
    } while (uv /= 10);
    if (sign)
	*--ptr = '-';
    *peob = ebuf;
    return ptr;
}

/* Helper for sv_2pv_flags and sv_vcatpvfn_flags.  If the NV is an
 * infinity or a not-a-number, writes the appropriate strings to the
 * buffer, including a zero byte.  On success returns the written length,
 * excluding the zero byte, on failure (not an infinity, not a nan)
 * returns zero, assert-fails on maxlen being too short.
 *
 * XXX for "Inf", "-Inf", and "NaN", we could have three read-only
 * shared string constants we point to, instead of generating a new
 * string for each instance. */
STATIC size_t
S_infnan_2pv(NV nv, char* buffer, size_t maxlen, char plus) {
    char* s = buffer;
    assert(maxlen >= 4);
    if (Perl_isinf(nv)) {
        if (nv < 0) {
            if (maxlen < 5) /* "-Inf\0"  */
                return 0;
            *s++ = '-';
        } else if (plus) {
            *s++ = '+';
        }
        *s++ = 'I';
        *s++ = 'n';
        *s++ = 'f';
    }
    else if (Perl_isnan(nv)) {
        *s++ = 'N';
        *s++ = 'a';
        *s++ = 'N';
        /* XXX optionally output the payload mantissa bits as
         * "(unsigned)" (to match the nan("...") C99 function,
         * or maybe as "(0xhhh...)"  would make more sense...
         * provide a format string so that the user can decide?
         * NOTE: would affect the maxlen and assert() logic.*/
    }
    else {
      return 0;
    }
    assert((s == buffer + 3) || (s == buffer + 4));
    *s++ = 0;
    return s - buffer - 1; /* -1: excluding the zero byte */
}

/*
=for apidoc sv_2pv_flags

Returns a pointer to the string value of an SV, and sets C<*lp> to its length.
If flags has the C<SV_GMAGIC> bit set, does an C<mg_get()> first.  Coerces C<sv> to a
string if necessary.  Normally invoked via the C<SvPV_flags> macro.
C<sv_2pv()> and C<sv_2pv_nomg> usually end up here too.

=cut
*/

char *
Perl_sv_2pv_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)
{
    char *s;

    PERL_ARGS_ASSERT_SV_2PV_FLAGS;

    assert (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVHV
	 && SvTYPE(sv) != SVt_PVFM);
    if (SvGMAGICAL(sv) && (flags & SV_GMAGIC))
	mg_get(sv);
    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV *tmpstr;
	    if (flags & SV_SKIP_OVERLOAD)
		return NULL;
	    tmpstr = AMG_CALLunary(sv, string_amg);
	    TAINT_IF(tmpstr && SvTAINTED(tmpstr));
	    if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		/* Unwrap this:  */
		/* char *pv = lp ? SvPV(tmpstr, *lp) : SvPV_nolen(tmpstr);
		 */

		char *pv;
		if ((SvFLAGS(tmpstr) & (SVf_POK)) == SVf_POK) {
		    if (flags & SV_CONST_RETURN) {
			pv = (char *) SvPVX_const(tmpstr);
		    } else {
			pv = (flags & SV_MUTABLE_RETURN)
			    ? SvPVX_mutable(tmpstr) : SvPVX(tmpstr);
		    }
		    if (lp)
			*lp = SvCUR(tmpstr);
		} else {
		    pv = sv_2pv_flags(tmpstr, lp, flags);
		}
		if (SvUTF8(tmpstr))
		    SvUTF8_on(sv);
		else
		    SvUTF8_off(sv);
		return pv;
	    }
	}
	{
	    STRLEN len;
	    char *retval;
	    char *buffer;
	    SV *const referent = SvRV(sv);

	    if (!referent) {
		len = 7;
		retval = buffer = savepvn("NULLREF", len);
	    } else if (SvTYPE(referent) == SVt_REGEXP &&
		       (!(PL_curcop->cop_hints & HINT_NO_AMAGIC) ||
			amagic_is_enabled(string_amg))) {
		REGEXP * const re = (REGEXP *)MUTABLE_PTR(referent);

		assert(re);
			
		/* If the regex is UTF-8 we want the containing scalar to
		   have an UTF-8 flag too */
		if (RX_UTF8(re))
		    SvUTF8_on(sv);
		else
		    SvUTF8_off(sv);	

		if (lp)
		    *lp = RX_WRAPLEN(re);
 
		return RX_WRAPPED(re);
	    } else {
		const char *const typestr = sv_reftype(referent, 0);
		const STRLEN typelen = strlen(typestr);
		UV addr = PTR2UV(referent);
		const char *stashname = NULL;
		STRLEN stashnamelen = 0; /* hush, gcc */
		const char *buffer_end;

		if (SvOBJECT(referent)) {
		    const HEK *const name = HvNAME_HEK(SvSTASH(referent));

		    if (name) {
			stashname = HEK_KEY(name);
			stashnamelen = HEK_LEN(name);

			if (HEK_UTF8(name)) {
			    SvUTF8_on(sv);
			} else {
			    SvUTF8_off(sv);
			}
		    } else {
			stashname = "__ANON__";
			stashnamelen = 8;
		    }
		    len = stashnamelen + 1 /* = */ + typelen + 3 /* (0x */
			+ 2 * sizeof(UV) + 2 /* )\0 */;
		} else {
		    len = typelen + 3 /* (0x */
			+ 2 * sizeof(UV) + 2 /* )\0 */;
		}

		Newx(buffer, len, char);
		buffer_end = retval = buffer + len;

		/* Working backwards  */
		*--retval = '\0';
		*--retval = ')';
		do {
		    *--retval = PL_hexdigit[addr & 15];
		} while (addr >>= 4);
		*--retval = 'x';
		*--retval = '0';
		*--retval = '(';

		retval -= typelen;
		memcpy(retval, typestr, typelen);

		if (stashname) {
		    *--retval = '=';
		    retval -= stashnamelen;
		    memcpy(retval, stashname, stashnamelen);
		}
		/* retval may not necessarily have reached the start of the
		   buffer here.  */
		assert (retval >= buffer);

		len = buffer_end - retval - 1; /* -1 for that \0  */
	    }
	    if (lp)
		*lp = len;
	    SAVEFREEPV(buffer);
	    return retval;
	}
    }

    if (SvPOKp(sv)) {
	if (lp)
	    *lp = SvCUR(sv);
	if (flags & SV_MUTABLE_RETURN)
	    return SvPVX_mutable(sv);
	if (flags & SV_CONST_RETURN)
	    return (char *)SvPVX_const(sv);
	return SvPVX(sv);
    }

    if (SvIOK(sv)) {
	/* I'm assuming that if both IV and NV are equally valid then
	   converting the IV is going to be more efficient */
	const U32 isUIOK = SvIsUV(sv);
	char buf[TYPE_CHARS(UV)];
	char *ebuf, *ptr;
	STRLEN len;

	if (SvTYPE(sv) < SVt_PVIV)
	    sv_upgrade(sv, SVt_PVIV);
 	ptr = uiv_2buf(buf, SvIVX(sv), SvUVX(sv), isUIOK, &ebuf);
	len = ebuf - ptr;
	/* inlined from sv_setpvn */
	s = SvGROW_mutable(sv, len + 1);
	Move(ptr, s, len, char);
	s += len;
	*s = '\0';
        SvPOK_on(sv);
    }
    else if (SvNOK(sv)) {
	if (SvTYPE(sv) < SVt_PVNV)
	    sv_upgrade(sv, SVt_PVNV);
	if (SvNVX(sv) == 0.0
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	    && !Perl_isnan(SvNVX(sv))
#endif
	) {
	    s = SvGROW_mutable(sv, 2);
	    *s++ = '0';
	    *s = '\0';
	} else {
            STRLEN len;
            STRLEN size = 5; /* "-Inf\0" */

            s = SvGROW_mutable(sv, size);
            len = S_infnan_2pv(SvNVX(sv), s, size, 0);
            if (len > 0) {
                s += len;
                SvPOK_on(sv);
            }
            else {
                /* some Xenix systems wipe out errno here */
                dSAVE_ERRNO;

                size =
                    1 + /* sign */
                    1 + /* "." */
                    NV_DIG +
                    1 + /* "e" */
                    1 + /* sign */
                    5 + /* exponent digits */
                    1 + /* \0 */
                    2; /* paranoia */

                s = SvGROW_mutable(sv, size);
#ifndef USE_LOCALE_NUMERIC
                SNPRINTF_G(SvNVX(sv), s, SvLEN(sv), NV_DIG);

                SvPOK_on(sv);
#else
                {
                    bool local_radix;
                    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
                    STORE_LC_NUMERIC_SET_TO_NEEDED();

                    local_radix = PL_numeric_local && PL_numeric_radix_sv;
                    if (local_radix && SvLEN(PL_numeric_radix_sv) > 1) {
                        size += SvLEN(PL_numeric_radix_sv) - 1;
                        s = SvGROW_mutable(sv, size);
                    }

                    SNPRINTF_G(SvNVX(sv), s, SvLEN(sv), NV_DIG);

                    /* If the radix character is UTF-8, and actually is in the
                     * output, turn on the UTF-8 flag for the scalar */
                    if (   local_radix
                        && SvUTF8(PL_numeric_radix_sv)
                        && instr(s, SvPVX_const(PL_numeric_radix_sv)))
                    {
                        SvUTF8_on(sv);
                    }

                    RESTORE_LC_NUMERIC();
                }

                /* We don't call SvPOK_on(), because it may come to
                 * pass that the locale changes so that the
                 * stringification we just did is no longer correct.  We
                 * will have to re-stringify every time it is needed */
#endif
                RESTORE_ERRNO;
            }
            while (*s) s++;
	}
    }
    else if (isGV_with_GP(sv)) {
	GV *const gv = MUTABLE_GV(sv);
	SV *const buffer = sv_newmortal();

	gv_efullname3(buffer, gv, "*");

	assert(SvPOK(buffer));
	if (SvUTF8(buffer))
	    SvUTF8_on(sv);
	if (lp)
	    *lp = SvCUR(buffer);
	return SvPVX(buffer);
    }
    else if (isREGEXP(sv)) {
	if (lp) *lp = RX_WRAPLEN((REGEXP *)sv);
	return RX_WRAPPED((REGEXP *)sv);
    }
    else {
	if (lp)
	    *lp = 0;
	if (flags & SV_UNDEF_RETURNS_NULL)
	    return NULL;
	if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
	    report_uninit(sv);
	/* Typically the caller expects that sv_any is not NULL now.  */
	if (!SvREADONLY(sv) && SvTYPE(sv) < SVt_PV)
	    sv_upgrade(sv, SVt_PV);
	return (char *)"";
    }

    {
	const STRLEN len = s - SvPVX_const(sv);
	if (lp) 
	    *lp = len;
	SvCUR_set(sv, len);
    }
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2pv(%s)\n",
			  PTR2UV(sv),SvPVX_const(sv)));
    if (flags & SV_CONST_RETURN)
	return (char *)SvPVX_const(sv);
    if (flags & SV_MUTABLE_RETURN)
	return SvPVX_mutable(sv);
    return SvPVX(sv);
}

/*
=for apidoc sv_copypv

Copies a stringified representation of the source SV into the
destination SV.  Automatically performs any necessary C<mg_get> and
coercion of numeric values into strings.  Guaranteed to preserve
C<UTF8> flag even from overloaded objects.  Similar in nature to
C<sv_2pv[_flags]> but operates directly on an SV instead of just the
string.  Mostly uses C<sv_2pv_flags> to do its work, except when that
would lose the UTF-8'ness of the PV.

=for apidoc sv_copypv_nomg

Like C<sv_copypv>, but doesn't invoke get magic first.

=for apidoc sv_copypv_flags

Implementation of C<sv_copypv> and C<sv_copypv_nomg>.  Calls get magic iff flags
has the C<SV_GMAGIC> bit set.

=cut
*/

void
Perl_sv_copypv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)
{
    STRLEN len;
    const char *s;

    PERL_ARGS_ASSERT_SV_COPYPV_FLAGS;

    s = SvPV_flags_const(ssv,len,(flags & SV_GMAGIC));
    sv_setpvn(dsv,s,len);
    if (SvUTF8(ssv))
	SvUTF8_on(dsv);
    else
	SvUTF8_off(dsv);
}

/*
=for apidoc sv_2pvbyte

Return a pointer to the byte-encoded representation of the SV, and set C<*lp>
to its length.  May cause the SV to be downgraded from UTF-8 as a
side-effect.

Usually accessed via the C<SvPVbyte> macro.

=cut
*/

char *
Perl_sv_2pvbyte(pTHX_ SV *sv, STRLEN *const lp)
{
    PERL_ARGS_ASSERT_SV_2PVBYTE;

    SvGETMAGIC(sv);
    if (((SvREADONLY(sv) || SvFAKE(sv)) && !SvIsCOW(sv))
     || isGV_with_GP(sv) || SvROK(sv)) {
	SV *sv2 = sv_newmortal();
	sv_copypv_nomg(sv2,sv);
	sv = sv2;
    }
    sv_utf8_downgrade(sv,0);
    return lp ? SvPV_nomg(sv,*lp) : SvPV_nomg_nolen(sv);
}

/*
=for apidoc sv_2pvutf8

Return a pointer to the UTF-8-encoded representation of the SV, and set C<*lp>
to its length.  May cause the SV to be upgraded to UTF-8 as a side-effect.

Usually accessed via the C<SvPVutf8> macro.

=cut
*/

char *
Perl_sv_2pvutf8(pTHX_ SV *sv, STRLEN *const lp)
{
    PERL_ARGS_ASSERT_SV_2PVUTF8;

    if (((SvREADONLY(sv) || SvFAKE(sv)) && !SvIsCOW(sv))
     || isGV_with_GP(sv) || SvROK(sv))
	sv = sv_mortalcopy(sv);
    else
        SvGETMAGIC(sv);
    sv_utf8_upgrade_nomg(sv);
    return lp ? SvPV_nomg(sv,*lp) : SvPV_nomg_nolen(sv);
}


/*
=for apidoc sv_2bool

This macro is only used by C<sv_true()> or its macro equivalent, and only if
the latter's argument is neither C<SvPOK>, C<SvIOK> nor C<SvNOK>.
It calls C<sv_2bool_flags> with the C<SV_GMAGIC> flag.

=for apidoc sv_2bool_flags

This function is only used by C<sv_true()> and friends,  and only if
the latter's argument is neither C<SvPOK>, C<SvIOK> nor C<SvNOK>.  If the flags
contain C<SV_GMAGIC>, then it does an C<mg_get()> first.


=cut
*/

bool
Perl_sv_2bool_flags(pTHX_ SV *sv, I32 flags)
{
    PERL_ARGS_ASSERT_SV_2BOOL_FLAGS;

    restart:
    if(flags & SV_GMAGIC) SvGETMAGIC(sv);

    if (!SvOK(sv))
	return 0;
    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV * const tmpsv = AMG_CALLunary(sv, bool__amg);
	    if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv)))) {
                bool svb;
                sv = tmpsv;
                if(SvGMAGICAL(sv)) {
                    flags = SV_GMAGIC;
                    goto restart; /* call sv_2bool */
                }
                /* expanded SvTRUE_common(sv, (flags = 0, goto restart)) */
                else if(!SvOK(sv)) {
                    svb = 0;
                }
                else if(SvPOK(sv)) {
                    svb = SvPVXtrue(sv);
                }
                else if((SvFLAGS(sv) & (SVf_IOK|SVf_NOK))) {
                    svb = (SvIOK(sv) && SvIVX(sv) != 0)
                        || (SvNOK(sv) && SvNVX(sv) != 0.0);
                }
                else {
                    flags = 0;
                    goto restart; /* call sv_2bool_nomg */
                }
                return cBOOL(svb);
            }
	}
	return SvRV(sv) != 0;
    }
    if (isREGEXP(sv))
	return
	  RX_WRAPLEN(sv) > 1 || (RX_WRAPLEN(sv) && *RX_WRAPPED(sv) != '0');
    return SvTRUE_common(sv, isGV_with_GP(sv) ? 1 : 0);
}

/*
=for apidoc sv_utf8_upgrade

Converts the PV of an SV to its UTF-8-encoded form.
Forces the SV to string form if it is not already.
Will C<mg_get> on C<sv> if appropriate.
Always sets the C<SvUTF8> flag to avoid future validity checks even
if the whole string is the same in UTF-8 as not.
Returns the number of bytes in the converted string

This is not a general purpose byte encoding to Unicode interface:
use the Encode extension for that.

=for apidoc sv_utf8_upgrade_nomg

Like C<sv_utf8_upgrade>, but doesn't do magic on C<sv>.

=for apidoc sv_utf8_upgrade_flags

Converts the PV of an SV to its UTF-8-encoded form.
Forces the SV to string form if it is not already.
Always sets the SvUTF8 flag to avoid future validity checks even
if all the bytes are invariant in UTF-8.
If C<flags> has C<SV_GMAGIC> bit set,
will C<mg_get> on C<sv> if appropriate, else not.

If C<flags> has C<SV_FORCE_UTF8_UPGRADE> set, this function assumes that the PV
will expand when converted to UTF-8, and skips the extra work of checking for
that.  Typically this flag is used by a routine that has already parsed the
string and found such characters, and passes this information on so that the
work doesn't have to be repeated.

Returns the number of bytes in the converted string.

This is not a general purpose byte encoding to Unicode interface:
use the Encode extension for that.

=for apidoc sv_utf8_upgrade_flags_grow

Like C<sv_utf8_upgrade_flags>, but has an additional parameter C<extra>, which is
the number of unused bytes the string of C<sv> is guaranteed to have free after
it upon return.  This allows the caller to reserve extra space that it intends
to fill, to avoid extra grows.

C<sv_utf8_upgrade>, C<sv_utf8_upgrade_nomg>, and C<sv_utf8_upgrade_flags>
are implemented in terms of this function.

Returns the number of bytes in the converted string (not including the spares).

=cut

(One might think that the calling routine could pass in the position of the
first variant character when it has set SV_FORCE_UTF8_UPGRADE, so it wouldn't
have to be found again.  But that is not the case, because typically when the
caller is likely to use this flag, it won't be calling this routine unless it
finds something that won't fit into a byte.  Otherwise it tries to not upgrade
and just use bytes.  But some things that do fit into a byte are variants in
utf8, and the caller may not have been keeping track of these.)

If the routine itself changes the string, it adds a trailing C<NUL>.  Such a
C<NUL> isn't guaranteed due to having other routines do the work in some input
cases, or if the input is already flagged as being in utf8.

The speed of this could perhaps be improved for many cases if someone wanted to
write a fast function that counts the number of variant characters in a string,
especially if it could return the position of the first one.

*/

STRLEN
Perl_sv_utf8_upgrade_flags_grow(pTHX_ SV *const sv, const I32 flags, STRLEN extra)
{
    PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS_GROW;

    if (sv == &PL_sv_undef)
	return 0;
    if (!SvPOK_nog(sv)) {
	STRLEN len = 0;
	if (SvREADONLY(sv) && (SvPOKp(sv) || SvIOKp(sv) || SvNOKp(sv))) {
	    (void) sv_2pv_flags(sv,&len, flags);
	    if (SvUTF8(sv)) {
		if (extra) SvGROW(sv, SvCUR(sv) + extra);
		return len;
	    }
	} else {
	    (void) SvPV_force_flags(sv,len,flags & SV_GMAGIC);
	}
    }

    if (SvUTF8(sv)) {
	if (extra) SvGROW(sv, SvCUR(sv) + extra);
	return SvCUR(sv);
    }

    if (SvIsCOW(sv)) {
        S_sv_uncow(aTHX_ sv, 0);
    }

    if (IN_ENCODING && !(flags & SV_UTF8_NO_ENCODING)) {
        sv_recode_to_utf8(sv, _get_encoding());
	if (extra) SvGROW(sv, SvCUR(sv) + extra);
	return SvCUR(sv);
    }

    if (SvCUR(sv) == 0) {
	if (extra) SvGROW(sv, extra);
    } else { /* Assume Latin-1/EBCDIC */
	/* This function could be much more efficient if we
	 * had a FLAG in SVs to signal if there are any variant
	 * chars in the PV.  Given that there isn't such a flag
	 * make the loop as fast as possible (although there are certainly ways
	 * to speed this up, eg. through vectorization) */
	U8 * s = (U8 *) SvPVX_const(sv);
	U8 * e = (U8 *) SvEND(sv);
	U8 *t = s;
	STRLEN two_byte_count = 0;
	
	if (flags & SV_FORCE_UTF8_UPGRADE) goto must_be_utf8;

	/* See if really will need to convert to utf8.  We mustn't rely on our
	 * incoming SV being well formed and having a trailing '\0', as certain
	 * code in pp_formline can send us partially built SVs. */

	while (t < e) {
	    const U8 ch = *t++;
	    if (NATIVE_BYTE_IS_INVARIANT(ch)) continue;

	    t--;    /* t already incremented; re-point to first variant */
	    two_byte_count = 1;
	    goto must_be_utf8;
	}

	/* utf8 conversion not needed because all are invariants.  Mark as
	 * UTF-8 even if no variant - saves scanning loop */
	SvUTF8_on(sv);
	if (extra) SvGROW(sv, SvCUR(sv) + extra);
	return SvCUR(sv);

      must_be_utf8:

	/* Here, the string should be converted to utf8, either because of an
	 * input flag (two_byte_count = 0), or because a character that
	 * requires 2 bytes was found (two_byte_count = 1).  t points either to
	 * the beginning of the string (if we didn't examine anything), or to
	 * the first variant.  In either case, everything from s to t - 1 will
	 * occupy only 1 byte each on output.
	 *
	 * There are two main ways to convert.  One is to create a new string
	 * and go through the input starting from the beginning, appending each
	 * converted value onto the new string as we go along.  It's probably
	 * best to allocate enough space in the string for the worst possible
	 * case rather than possibly running out of space and having to
	 * reallocate and then copy what we've done so far.  Since everything
	 * from s to t - 1 is invariant, the destination can be initialized
	 * with these using a fast memory copy
	 *
	 * The other way is to figure out exactly how big the string should be
	 * by parsing the entire input.  Then you don't have to make it big
	 * enough to handle the worst possible case, and more importantly, if
	 * the string you already have is large enough, you don't have to
	 * allocate a new string, you can copy the last character in the input
	 * string to the final position(s) that will be occupied by the
	 * converted string and go backwards, stopping at t, since everything
	 * before that is invariant.
	 *
	 * There are advantages and disadvantages to each method.
	 *
	 * In the first method, we can allocate a new string, do the memory
	 * copy from the s to t - 1, and then proceed through the rest of the
	 * string byte-by-byte.
	 *
	 * In the second method, we proceed through the rest of the input
	 * string just calculating how big the converted string will be.  Then
	 * there are two cases:
	 *  1)	if the string has enough extra space to handle the converted
	 *	value.  We go backwards through the string, converting until we
	 *	get to the position we are at now, and then stop.  If this
	 *	position is far enough along in the string, this method is
	 *	faster than the other method.  If the memory copy were the same
	 *	speed as the byte-by-byte loop, that position would be about
	 *	half-way, as at the half-way mark, parsing to the end and back
	 *	is one complete string's parse, the same amount as starting
	 *	over and going all the way through.  Actually, it would be
	 *	somewhat less than half-way, as it's faster to just count bytes
	 *	than to also copy, and we don't have the overhead of allocating
	 *	a new string, changing the scalar to use it, and freeing the
	 *	existing one.  But if the memory copy is fast, the break-even
	 *	point is somewhere after half way.  The counting loop could be
	 *	sped up by vectorization, etc, to move the break-even point
	 *	further towards the beginning.
	 *  2)	if the string doesn't have enough space to handle the converted
	 *	value.  A new string will have to be allocated, and one might
	 *	as well, given that, start from the beginning doing the first
	 *	method.  We've spent extra time parsing the string and in
	 *	exchange all we've gotten is that we know precisely how big to
	 *	make the new one.  Perl is more optimized for time than space,
	 *	so this case is a loser.
	 * So what I've decided to do is not use the 2nd method unless it is
	 * guaranteed that a new string won't have to be allocated, assuming
	 * the worst case.  I also decided not to put any more conditions on it
	 * than this, for now.  It seems likely that, since the worst case is
	 * twice as big as the unknown portion of the string (plus 1), we won't
	 * be guaranteed enough space, causing us to go to the first method,
	 * unless the string is short, or the first variant character is near
	 * the end of it.  In either of these cases, it seems best to use the
	 * 2nd method.  The only circumstance I can think of where this would
	 * be really slower is if the string had once had much more data in it
	 * than it does now, but there is still a substantial amount in it  */

	{
	    STRLEN invariant_head = t - s;
	    STRLEN size = invariant_head + (e - t) * 2 + 1 + extra;
	    if (SvLEN(sv) < size) {

		/* Here, have decided to allocate a new string */

		U8 *dst;
		U8 *d;

		Newx(dst, size, U8);

		/* If no known invariants at the beginning of the input string,
		 * set so starts from there.  Otherwise, can use memory copy to
		 * get up to where we are now, and then start from here */

		if (invariant_head == 0) {
		    d = dst;
		} else {
		    Copy(s, dst, invariant_head, char);
		    d = dst + invariant_head;
		}

		while (t < e) {
                    append_utf8_from_native_byte(*t, &d);
                    t++;
		}
		*d = '\0';
		SvPV_free(sv); /* No longer using pre-existing string */
		SvPV_set(sv, (char*)dst);
		SvCUR_set(sv, d - dst);
		SvLEN_set(sv, size);
	    } else {

		/* Here, have decided to get the exact size of the string.
		 * Currently this happens only when we know that there is
		 * guaranteed enough space to fit the converted string, so
		 * don't have to worry about growing.  If two_byte_count is 0,
		 * then t points to the first byte of the string which hasn't
		 * been examined yet.  Otherwise two_byte_count is 1, and t
		 * points to the first byte in the string that will expand to
		 * two.  Depending on this, start examining at t or 1 after t.
		 * */

		U8 *d = t + two_byte_count;


		/* Count up the remaining bytes that expand to two */

		while (d < e) {
		    const U8 chr = *d++;
		    if (! NATIVE_BYTE_IS_INVARIANT(chr)) two_byte_count++;
		}

		/* The string will expand by just the number of bytes that
		 * occupy two positions.  But we are one afterwards because of
		 * the increment just above.  This is the place to put the
		 * trailing NUL, and to set the length before we decrement */

		d += two_byte_count;
		SvCUR_set(sv, d - s);
		*d-- = '\0';


		/* Having decremented d, it points to the position to put the
		 * very last byte of the expanded string.  Go backwards through
		 * the string, copying and expanding as we go, stopping when we
		 * get to the part that is invariant the rest of the way down */

		e--;
		while (e >= t) {
		    if (NATIVE_BYTE_IS_INVARIANT(*e)) {
			*d-- = *e;
		    } else {
			*d-- = UTF8_EIGHT_BIT_LO(*e);
			*d-- = UTF8_EIGHT_BIT_HI(*e);
		    }
                    e--;
		}
	    }

	    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
		/* Update pos. We do it at the end rather than during
		 * the upgrade, to avoid slowing down the common case
		 * (upgrade without pos).
		 * pos can be stored as either bytes or characters.  Since
		 * this was previously a byte string we can just turn off
		 * the bytes flag. */
		MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
		if (mg) {
		    mg->mg_flags &= ~MGf_BYTES;
		}
		if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		    magic_setutf8(sv,mg); /* clear UTF8 cache */
	    }
	}
    }

    /* Mark as UTF-8 even if no variant - saves scanning loop */
    SvUTF8_on(sv);
    return SvCUR(sv);
}

/*
=for apidoc sv_utf8_downgrade

Attempts to convert the PV of an SV from characters to bytes.
If the PV contains a character that cannot fit
in a byte, this conversion will fail;
in this case, either returns false or, if C<fail_ok> is not
true, croaks.

This is not a general purpose Unicode to byte encoding interface:
use the C<Encode> extension for that.

=cut
*/

bool
Perl_sv_utf8_downgrade(pTHX_ SV *const sv, const bool fail_ok)
{
    PERL_ARGS_ASSERT_SV_UTF8_DOWNGRADE;

    if (SvPOKp(sv) && SvUTF8(sv)) {
        if (SvCUR(sv)) {
	    U8 *s;
	    STRLEN len;
	    int mg_flags = SV_GMAGIC;

            if (SvIsCOW(sv)) {
                S_sv_uncow(aTHX_ sv, 0);
            }
	    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
		/* update pos */
		MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
		if (mg && mg->mg_len > 0 && mg->mg_flags & MGf_BYTES) {
			mg->mg_len = sv_pos_b2u_flags(sv, mg->mg_len,
						SV_GMAGIC|SV_CONST_RETURN);
			mg_flags = 0; /* sv_pos_b2u does get magic */
		}
		if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		    magic_setutf8(sv,mg); /* clear UTF8 cache */

	    }
	    s = (U8 *) SvPV_flags(sv, len, mg_flags);

	    if (!utf8_to_bytes(s, &len)) {
	        if (fail_ok)
		    return FALSE;
		else {
		    if (PL_op)
		        Perl_croak(aTHX_ "Wide character in %s",
				   OP_DESC(PL_op));
		    else
		        Perl_croak(aTHX_ "Wide character");
		}
	    }
	    SvCUR_set(sv, len);
	}
    }
    SvUTF8_off(sv);
    return TRUE;
}

/*
=for apidoc sv_utf8_encode

Converts the PV of an SV to UTF-8, but then turns the C<SvUTF8>
flag off so that it looks like octets again.

=cut
*/

void
Perl_sv_utf8_encode(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_SV_UTF8_ENCODE;

    if (SvREADONLY(sv)) {
	sv_force_normal_flags(sv, 0);
    }
    (void) sv_utf8_upgrade(sv);
    SvUTF8_off(sv);
}

/*
=for apidoc sv_utf8_decode

If the PV of the SV is an octet sequence in UTF-8
and contains a multiple-byte character, the C<SvUTF8> flag is turned on
so that it looks like a character.  If the PV contains only single-byte
characters, the C<SvUTF8> flag stays off.
Scans PV for validity and returns false if the PV is invalid UTF-8.

=cut
*/

bool
Perl_sv_utf8_decode(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_SV_UTF8_DECODE;

    if (SvPOKp(sv)) {
        const U8 *start, *c;
        const U8 *e;

	/* The octets may have got themselves encoded - get them back as
	 * bytes
	 */
	if (!sv_utf8_downgrade(sv, TRUE))
	    return FALSE;

        /* it is actually just a matter of turning the utf8 flag on, but
         * we want to make sure everything inside is valid utf8 first.
         */
        c = start = (const U8 *) SvPVX_const(sv);
	if (!is_utf8_string(c, SvCUR(sv)))
	    return FALSE;
        e = (const U8 *) SvEND(sv);
        while (c < e) {
	    const U8 ch = *c++;
            if (!UTF8_IS_INVARIANT(ch)) {
		SvUTF8_on(sv);
		break;
	    }
        }
	if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	    /* XXX Is this dead code?  XS_utf8_decode calls SvSETMAGIC
		   after this, clearing pos.  Does anything on CPAN
		   need this? */
	    /* adjust pos to the start of a UTF8 char sequence */
	    MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
	    if (mg) {
		I32 pos = mg->mg_len;
		if (pos > 0) {
		    for (c = start + pos; c > start; c--) {
			if (UTF8_IS_START(*c))
			    break;
		    }
		    mg->mg_len  = c - start;
		}
	    }
	    if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		magic_setutf8(sv,mg); /* clear UTF8 cache */
	}
    }
    return TRUE;
}

/*
=for apidoc sv_setsv

Copies the contents of the source SV C<ssv> into the destination SV
C<dsv>.  The source SV may be destroyed if it is mortal, so don't use this
function if the source SV needs to be reused.  Does not handle 'set' magic on
destination SV.  Calls 'get' magic on source SV.  Loosely speaking, it
performs a copy-by-value, obliterating any previous content of the
destination.

You probably want to use one of the assortment of wrappers, such as
C<SvSetSV>, C<SvSetSV_nosteal>, C<SvSetMagicSV> and
C<SvSetMagicSV_nosteal>.

=for apidoc sv_setsv_flags

Copies the contents of the source SV C<ssv> into the destination SV
C<dsv>.  The source SV may be destroyed if it is mortal, so don't use this
function if the source SV needs to be reused.  Does not handle 'set' magic.
Loosely speaking, it performs a copy-by-value, obliterating any previous
content of the destination.
If the C<flags> parameter has the C<SV_GMAGIC> bit set, will C<mg_get> on
C<ssv> if appropriate, else not.  If the C<flags>
parameter has the C<SV_NOSTEAL> bit set then the
buffers of temps will not be stolen.  C<sv_setsv>
and C<sv_setsv_nomg> are implemented in terms of this function.

You probably want to use one of the assortment of wrappers, such as
C<SvSetSV>, C<SvSetSV_nosteal>, C<SvSetMagicSV> and
C<SvSetMagicSV_nosteal>.

This is the primary function for copying scalars, and most other
copy-ish functions and macros use this underneath.

=cut
*/

static void
S_glob_assign_glob(pTHX_ SV *const dstr, SV *const sstr, const int dtype)
{
    I32 mro_changes = 0; /* 1 = method, 2 = isa, 3 = recursive isa */
    HV *old_stash = NULL;

    PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB;

    if (dtype != SVt_PVGV && !isGV_with_GP(dstr)) {
	const char * const name = GvNAME(sstr);
	const STRLEN len = GvNAMELEN(sstr);
	{
	    if (dtype >= SVt_PV) {
		SvPV_free(dstr);
		SvPV_set(dstr, 0);
		SvLEN_set(dstr, 0);
		SvCUR_set(dstr, 0);
	    }
	    SvUPGRADE(dstr, SVt_PVGV);
	    (void)SvOK_off(dstr);
	    isGV_with_GP_on(dstr);
	}
	GvSTASH(dstr) = GvSTASH(sstr);
	if (GvSTASH(dstr))
	    Perl_sv_add_backref(aTHX_ MUTABLE_SV(GvSTASH(dstr)), dstr);
        gv_name_set(MUTABLE_GV(dstr), name, len,
                        GV_ADD | (GvNAMEUTF8(sstr) ? SVf_UTF8 : 0 ));
	SvFAKE_on(dstr);	/* can coerce to non-glob */
    }

    if(GvGP(MUTABLE_GV(sstr))) {
        /* If source has method cache entry, clear it */
        if(GvCVGEN(sstr)) {
            SvREFCNT_dec(GvCV(sstr));
            GvCV_set(sstr, NULL);
            GvCVGEN(sstr) = 0;
        }
        /* If source has a real method, then a method is
           going to change */
        else if(
         GvCV((const GV *)sstr) && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
        ) {
            mro_changes = 1;
        }
    }

    /* If dest already had a real method, that's a change as well */
    if(
        !mro_changes && GvGP(MUTABLE_GV(dstr)) && GvCVu((const GV *)dstr)
     && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
    ) {
        mro_changes = 1;
    }

    /* We don't need to check the name of the destination if it was not a
       glob to begin with. */
    if(dtype == SVt_PVGV) {
        const char * const name = GvNAME((const GV *)dstr);
        if(
            strEQ(name,"ISA")
         /* The stash may have been detached from the symbol table, so
            check its name. */
         && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
        )
            mro_changes = 2;
        else {
            const STRLEN len = GvNAMELEN(dstr);
            if ((len > 1 && name[len-2] == ':' && name[len-1] == ':')
             || (len == 1 && name[0] == ':')) {
                mro_changes = 3;

                /* Set aside the old stash, so we can reset isa caches on
                   its subclasses. */
                if((old_stash = GvHV(dstr)))
                    /* Make sure we do not lose it early. */
                    SvREFCNT_inc_simple_void_NN(
                     sv_2mortal((SV *)old_stash)
                    );
            }
        }

        SvREFCNT_inc_simple_void_NN(sv_2mortal(dstr));
    }

    /* freeing dstr's GP might free sstr (e.g. *x = $x),
     * so temporarily protect it */
    ENTER;
    SAVEFREESV(SvREFCNT_inc_simple_NN(sstr));
    gp_free(MUTABLE_GV(dstr));
    GvINTRO_off(dstr);		/* one-shot flag */
    GvGP_set(dstr, gp_ref(GvGP(sstr)));
    LEAVE;

    if (SvTAINTED(sstr))
	SvTAINT(dstr);
    if (GvIMPORTED(dstr) != GVf_IMPORTED
	&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
	{
	    GvIMPORTED_on(dstr);
	}
    GvMULTI_on(dstr);
    if(mro_changes == 2) {
      if (GvAV((const GV *)sstr)) {
	MAGIC *mg;
	SV * const sref = (SV *)GvAV((const GV *)dstr);
	if (SvSMAGICAL(sref) && (mg = mg_find(sref, PERL_MAGIC_isa))) {
	    if (SvTYPE(mg->mg_obj) != SVt_PVAV) {
		AV * const ary = newAV();
		av_push(ary, mg->mg_obj); /* takes the refcount */
		mg->mg_obj = (SV *)ary;
	    }
	    av_push((AV *)mg->mg_obj, SvREFCNT_inc_simple_NN(dstr));
	}
	else sv_magic(sref, dstr, PERL_MAGIC_isa, NULL, 0);
      }
      mro_isa_changed_in(GvSTASH(dstr));
    }
    else if(mro_changes == 3) {
	HV * const stash = GvHV(dstr);
	if(old_stash ? (HV *)HvENAME_get(old_stash) : stash)
	    mro_package_moved(
		stash, old_stash,
		(GV *)dstr, 0
	    );
    }
    else if(mro_changes) mro_method_changed_in(GvSTASH(dstr));
    if (GvIO(dstr) && dtype == SVt_PVGV) {
	DEBUG_o(Perl_deb(aTHX_
			"glob_assign_glob clearing PL_stashcache\n"));
	/* It's a cache. It will rebuild itself quite happily.
	   It's a lot of effort to work out exactly which key (or keys)
	   might be invalidated by the creation of the this file handle.
	 */
	hv_clear(PL_stashcache);
    }
    return;
}

void
Perl_gv_setref(pTHX_ SV *const dstr, SV *const sstr)
{
    SV * const sref = SvRV(sstr);
    SV *dref;
    const int intro = GvINTRO(dstr);
    SV **location;
    U8 import_flag = 0;
    const U32 stype = SvTYPE(sref);

    PERL_ARGS_ASSERT_GV_SETREF;

    if (intro) {
	GvINTRO_off(dstr);	/* one-shot flag */
	GvLINE(dstr) = CopLINE(PL_curcop);
	GvEGV(dstr) = MUTABLE_GV(dstr);
    }
    GvMULTI_on(dstr);
    switch (stype) {
    case SVt_PVCV:
	location = (SV **) &(GvGP(dstr)->gp_cv); /* XXX bypassing GvCV_set */
	import_flag = GVf_IMPORTED_CV;
	goto common;
    case SVt_PVHV:
	location = (SV **) &GvHV(dstr);
	import_flag = GVf_IMPORTED_HV;
	goto common;
    case SVt_PVAV:
	location = (SV **) &GvAV(dstr);
	import_flag = GVf_IMPORTED_AV;
	goto common;
    case SVt_PVIO:
	location = (SV **) &GvIOp(dstr);
	goto common;
    case SVt_PVFM:
	location = (SV **) &GvFORM(dstr);
	goto common;
    default:
	location = &GvSV(dstr);
	import_flag = GVf_IMPORTED_SV;
    common:
	if (intro) {
	    if (stype == SVt_PVCV) {
		/*if (GvCVGEN(dstr) && (GvCV(dstr) != (const CV *)sref || GvCVGEN(dstr))) {*/
		if (GvCVGEN(dstr)) {
		    SvREFCNT_dec(GvCV(dstr));
		    GvCV_set(dstr, NULL);
		    GvCVGEN(dstr) = 0; /* Switch off cacheness. */
		}
	    }
	    /* SAVEt_GVSLOT takes more room on the savestack and has more
	       overhead in leave_scope than SAVEt_GENERIC_SV.  But for CVs
	       leave_scope needs access to the GV so it can reset method
	       caches.  We must use SAVEt_GVSLOT whenever the type is
	       SVt_PVCV, even if the stash is anonymous, as the stash may
	       gain a name somehow before leave_scope. */
	    if (stype == SVt_PVCV) {
		/* There is no save_pushptrptrptr.  Creating it for this
		   one call site would be overkill.  So inline the ss add
		   routines here. */
                dSS_ADD;
		SS_ADD_PTR(dstr);
		SS_ADD_PTR(location);
		SS_ADD_PTR(SvREFCNT_inc(*location));
		SS_ADD_UV(SAVEt_GVSLOT);
		SS_ADD_END(4);
	    }
	    else SAVEGENERICSV(*location);
	}
	dref = *location;
	if (stype == SVt_PVCV && (*location != sref || GvCVGEN(dstr))) {
	    CV* const cv = MUTABLE_CV(*location);
	    if (cv) {
		if (!GvCVGEN((const GV *)dstr) &&
		    (CvROOT(cv) || CvXSUB(cv)) &&
		    /* redundant check that avoids creating the extra SV
		       most of the time: */
		    (CvCONST(cv) || ckWARN(WARN_REDEFINE)))
		    {
			SV * const new_const_sv =
			    CvCONST((const CV *)sref)
				 ? cv_const_sv((const CV *)sref)
				 : NULL;
			report_redefined_cv(
			   sv_2mortal(Perl_newSVpvf(aTHX_
				"%"HEKf"::%"HEKf,
				HEKfARG(
				 HvNAME_HEK(GvSTASH((const GV *)dstr))
				),
				HEKfARG(GvENAME_HEK(MUTABLE_GV(dstr)))
			   )),
			   cv,
			   CvCONST((const CV *)sref) ? &new_const_sv : NULL
			);
		    }
		if (!intro)
		    cv_ckproto_len_flags(cv, (const GV *)dstr,
				   SvPOK(sref) ? CvPROTO(sref) : NULL,
				   SvPOK(sref) ? CvPROTOLEN(sref) : 0,
                                   SvPOK(sref) ? SvUTF8(sref) : 0);
	    }
	    GvCVGEN(dstr) = 0; /* Switch off cacheness. */
	    GvASSUMECV_on(dstr);
	    if(GvSTASH(dstr)) { /* sub foo { 1 } sub bar { 2 } *bar = \&foo */
		if (intro && GvREFCNT(dstr) > 1) {
		    /* temporary remove extra savestack's ref */
		    --GvREFCNT(dstr);
		    gv_method_changed(dstr);
		    ++GvREFCNT(dstr);
		}
		else gv_method_changed(dstr);
	    }
	}
	*location = SvREFCNT_inc_simple_NN(sref);
	if (import_flag && !(GvFLAGS(dstr) & import_flag)
	    && CopSTASH_ne(PL_curcop, GvSTASH(dstr))) {
	    GvFLAGS(dstr) |= import_flag;
	}

	if (stype == SVt_PVHV) {
	    const char * const name = GvNAME((GV*)dstr);
	    const STRLEN len = GvNAMELEN(dstr);
	    if (
	        (
	           (len > 1 && name[len-2] == ':' && name[len-1] == ':')
	        || (len == 1 && name[0] == ':')
	        )
	     && (!dref || HvENAME_get(dref))
	    ) {
		mro_package_moved(
		    (HV *)sref, (HV *)dref,
		    (GV *)dstr, 0
		);
	    }
	}
	else if (
	    stype == SVt_PVAV && sref != dref
	 && strEQ(GvNAME((GV*)dstr), "ISA")
	 /* The stash may have been detached from the symbol table, so
	    check its name before doing anything. */
	 && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
	) {
	    MAGIC *mg;
	    MAGIC * const omg = dref && SvSMAGICAL(dref)
	                         ? mg_find(dref, PERL_MAGIC_isa)
	                         : NULL;
	    if (SvSMAGICAL(sref) && (mg = mg_find(sref, PERL_MAGIC_isa))) {
		if (SvTYPE(mg->mg_obj) != SVt_PVAV) {
		    AV * const ary = newAV();
		    av_push(ary, mg->mg_obj); /* takes the refcount */
		    mg->mg_obj = (SV *)ary;
		}
		if (omg) {
		    if (SvTYPE(omg->mg_obj) == SVt_PVAV) {
			SV **svp = AvARRAY((AV *)omg->mg_obj);
			I32 items = AvFILLp((AV *)omg->mg_obj) + 1;
			while (items--)
			    av_push(
			     (AV *)mg->mg_obj,
			     SvREFCNT_inc_simple_NN(*svp++)
			    );
		    }
		    else
			av_push(
			 (AV *)mg->mg_obj,
			 SvREFCNT_inc_simple_NN(omg->mg_obj)
			);
		}
		else
		    av_push((AV *)mg->mg_obj,SvREFCNT_inc_simple_NN(dstr));
	    }
	    else
	    {
                SSize_t i;
		sv_magic(
		 sref, omg ? omg->mg_obj : dstr, PERL_MAGIC_isa, NULL, 0
		);
                for (i = 0; i <= AvFILL(sref); ++i) {
                    SV **elem = av_fetch ((AV*)sref, i, 0);
                    if (elem) {
                        sv_magic(
                          *elem, sref, PERL_MAGIC_isaelem, NULL, i
                        );
                    }
                }
		mg = mg_find(sref, PERL_MAGIC_isa);
	    }
	    /* Since the *ISA assignment could have affected more than
	       one stash, don't call mro_isa_changed_in directly, but let
	       magic_clearisa do it for us, as it already has the logic for
	       dealing with globs vs arrays of globs. */
	    assert(mg);
	    Perl_magic_clearisa(aTHX_ NULL, mg);
	}
        else if (stype == SVt_PVIO) {
            DEBUG_o(Perl_deb(aTHX_ "gv_setref clearing PL_stashcache\n"));
            /* It's a cache. It will rebuild itself quite happily.
               It's a lot of effort to work out exactly which key (or keys)
               might be invalidated by the creation of the this file handle.
            */
            hv_clear(PL_stashcache);
        }
	break;
    }
    if (!intro) SvREFCNT_dec(dref);
    if (SvTAINTED(sstr))
	SvTAINT(dstr);
    return;
}




#ifdef PERL_DEBUG_READONLY_COW
# include <sys/mman.h>

# ifndef PERL_MEMORY_DEBUG_HEADER_SIZE
#  define PERL_MEMORY_DEBUG_HEADER_SIZE 0
# endif

void
Perl_sv_buf_to_ro(pTHX_ SV *sv)
{
    struct perl_memory_debug_header * const header =
	(struct perl_memory_debug_header *)(SvPVX(sv)-PERL_MEMORY_DEBUG_HEADER_SIZE);
    const MEM_SIZE len = header->size;
    PERL_ARGS_ASSERT_SV_BUF_TO_RO;
# ifdef PERL_TRACK_MEMPOOL
    if (!header->readonly) header->readonly = 1;
# endif
    if (mprotect(header, len, PROT_READ))
	Perl_warn(aTHX_ "mprotect RW for COW string %p %lu failed with %d",
			 header, len, errno);
}

static void
S_sv_buf_to_rw(pTHX_ SV *sv)
{
    struct perl_memory_debug_header * const header =
	(struct perl_memory_debug_header *)(SvPVX(sv)-PERL_MEMORY_DEBUG_HEADER_SIZE);
    const MEM_SIZE len = header->size;
    PERL_ARGS_ASSERT_SV_BUF_TO_RW;
    if (mprotect(header, len, PROT_READ|PROT_WRITE))
	Perl_warn(aTHX_ "mprotect for COW string %p %lu failed with %d",
			 header, len, errno);
# ifdef PERL_TRACK_MEMPOOL
    header->readonly = 0;
# endif
}

#else
# define sv_buf_to_ro(sv)	NOOP
# define sv_buf_to_rw(sv)	NOOP
#endif

void
Perl_sv_setsv_flags(pTHX_ SV *dstr, SV* sstr, const I32 flags)
{
    U32 sflags;
    int dtype;
    svtype stype;
    unsigned int both_type;

    PERL_ARGS_ASSERT_SV_SETSV_FLAGS;

    if (UNLIKELY( sstr == dstr ))
	return;

    if (UNLIKELY( !sstr ))
	sstr = &PL_sv_undef;

    stype = SvTYPE(sstr);
    dtype = SvTYPE(dstr);
    both_type = (stype | dtype);

    /* with these values, we can check that both SVs are NULL/IV (and not
     * freed) just by testing the or'ed types */
    STATIC_ASSERT_STMT(SVt_NULL == 0);
    STATIC_ASSERT_STMT(SVt_IV   == 1);
    if (both_type <= 1) {
        /* both src and dst are UNDEF/IV/RV, so we can do a lot of
         * special-casing */
        U32 sflags;
        U32 new_dflags;

        /* minimal subset of SV_CHECK_THINKFIRST_COW_DROP(dstr) */
        if (SvREADONLY(dstr))
            Perl_croak_no_modify();
        if (SvROK(dstr))
            sv_unref_flags(dstr, 0);

        assert(!SvGMAGICAL(sstr));
        assert(!SvGMAGICAL(dstr));

        sflags = SvFLAGS(sstr);
        if (sflags & (SVf_IOK|SVf_ROK)) {
            SET_SVANY_FOR_BODYLESS_IV(dstr);
            new_dflags = SVt_IV;

            if (sflags & SVf_ROK) {
                dstr->sv_u.svu_rv = SvREFCNT_inc(SvRV(sstr));
                new_dflags |= SVf_ROK;
            }
            else {
                /* both src and dst are <= SVt_IV, so sv_any points to the
                 * head; so access the head directly
                 */
                assert(    &(sstr->sv_u.svu_iv)
                        == &(((XPVIV*) SvANY(sstr))->xiv_iv));
                assert(    &(dstr->sv_u.svu_iv)
                        == &(((XPVIV*) SvANY(dstr))->xiv_iv));
                dstr->sv_u.svu_iv = sstr->sv_u.svu_iv;
                new_dflags |= (SVf_IOK|SVp_IOK|(sflags & SVf_IVisUV));
            }
        }
        else {
            new_dflags = dtype; /* turn off everything except the type */
        }
        SvFLAGS(dstr) = new_dflags;

        return;
    }

    if (UNLIKELY(both_type == SVTYPEMASK)) {
        if (SvIS_FREED(dstr)) {
            Perl_croak(aTHX_ "panic: attempt to copy value %" SVf
                       " to a freed scalar %p", SVfARG(sstr), (void *)dstr);
        }
        if (SvIS_FREED(sstr)) {
            Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p to %p",
                       (void*)sstr, (void*)dstr);
        }
    }



    SV_CHECK_THINKFIRST_COW_DROP(dstr);
    dtype = SvTYPE(dstr); /* THINKFIRST may have changed type */

    /* There's a lot of redundancy below but we're going for speed here */

    switch (stype) {
    case SVt_NULL:
      undef_sstr:
	if (LIKELY( dtype != SVt_PVGV && dtype != SVt_PVLV )) {
	    (void)SvOK_off(dstr);
	    return;
	}
	break;
    case SVt_IV:
	if (SvIOK(sstr)) {
	    switch (dtype) {
	    case SVt_NULL:
		/* For performance, we inline promoting to type SVt_IV. */
		/* We're starting from SVt_NULL, so provided that define is
		 * actual 0, we don't have to unset any SV type flags
		 * to promote to SVt_IV. */
		STATIC_ASSERT_STMT(SVt_NULL == 0);
		SET_SVANY_FOR_BODYLESS_IV(dstr);
		SvFLAGS(dstr) |= SVt_IV;
		break;
	    case SVt_NV:
	    case SVt_PV:
		sv_upgrade(dstr, SVt_PVIV);
		break;
	    case SVt_PVGV:
	    case SVt_PVLV:
		goto end_of_first_switch;
	    }
	    (void)SvIOK_only(dstr);
	    SvIV_set(dstr,  SvIVX(sstr));
	    if (SvIsUV(sstr))
		SvIsUV_on(dstr);
	    /* SvTAINTED can only be true if the SV has taint magic, which in
	       turn means that the SV type is PVMG (or greater). This is the
	       case statement for SVt_IV, so this cannot be true (whatever gcov
	       may say).  */
	    assert(!SvTAINTED(sstr));
	    return;
	}
	if (!SvROK(sstr))
	    goto undef_sstr;
	if (dtype < SVt_PV && dtype != SVt_IV)
	    sv_upgrade(dstr, SVt_IV);
	break;

    case SVt_NV:
	if (LIKELY( SvNOK(sstr) )) {
	    switch (dtype) {
	    case SVt_NULL:
	    case SVt_IV:
		sv_upgrade(dstr, SVt_NV);
		break;
	    case SVt_PV:
	    case SVt_PVIV:
		sv_upgrade(dstr, SVt_PVNV);
		break;
	    case SVt_PVGV:
	    case SVt_PVLV:
		goto end_of_first_switch;
	    }
	    SvNV_set(dstr, SvNVX(sstr));
	    (void)SvNOK_only(dstr);
	    /* SvTAINTED can only be true if the SV has taint magic, which in
	       turn means that the SV type is PVMG (or greater). This is the
	       case statement for SVt_NV, so this cannot be true (whatever gcov
	       may say).  */
	    assert(!SvTAINTED(sstr));
	    return;
	}
	goto undef_sstr;

    case SVt_PV:
	if (dtype < SVt_PV)
	    sv_upgrade(dstr, SVt_PV);
	break;
    case SVt_PVIV:
	if (dtype < SVt_PVIV)
	    sv_upgrade(dstr, SVt_PVIV);
	break;
    case SVt_PVNV:
	if (dtype < SVt_PVNV)
	    sv_upgrade(dstr, SVt_PVNV);
	break;
    default:
	{
	const char * const type = sv_reftype(sstr,0);
	if (PL_op)
	    /* diag_listed_as: Bizarre copy of %s */
	    Perl_croak(aTHX_ "Bizarre copy of %s in %s", type, OP_DESC(PL_op));
	else
	    Perl_croak(aTHX_ "Bizarre copy of %s", type);
	}
	NOT_REACHED; /* NOTREACHED */

    case SVt_REGEXP:
      upgregexp:
	if (dtype < SVt_REGEXP)
	{
	    if (dtype >= SVt_PV) {
		SvPV_free(dstr);
		SvPV_set(dstr, 0);
		SvLEN_set(dstr, 0);
		SvCUR_set(dstr, 0);
	    }
	    sv_upgrade(dstr, SVt_REGEXP);
	}
	break;

	case SVt_INVLIST:
    case SVt_PVLV:
    case SVt_PVGV:
    case SVt_PVMG:
	if (SvGMAGICAL(sstr) && (flags & SV_GMAGIC)) {
	    mg_get(sstr);
	    if (SvTYPE(sstr) != stype)
		stype = SvTYPE(sstr);
	}
	if (isGV_with_GP(sstr) && dtype <= SVt_PVLV) {
		    glob_assign_glob(dstr, sstr, dtype);
		    return;
	}
	if (stype == SVt_PVLV)
	{
	    if (isREGEXP(sstr)) goto upgregexp;
	    SvUPGRADE(dstr, SVt_PVNV);
	}
	else
	    SvUPGRADE(dstr, (svtype)stype);
    }
 end_of_first_switch:

    /* dstr may have been upgraded.  */
    dtype = SvTYPE(dstr);
    sflags = SvFLAGS(sstr);

    if (UNLIKELY( dtype == SVt_PVCV )) {
	/* Assigning to a subroutine sets the prototype.  */
	if (SvOK(sstr)) {
	    STRLEN len;
	    const char *const ptr = SvPV_const(sstr, len);

            SvGROW(dstr, len + 1);
            Copy(ptr, SvPVX(dstr), len + 1, char);
            SvCUR_set(dstr, len);
	    SvPOK_only(dstr);
	    SvFLAGS(dstr) |= sflags & SVf_UTF8;
	    CvAUTOLOAD_off(dstr);
	} else {
	    SvOK_off(dstr);
	}
    }
    else if (UNLIKELY(dtype == SVt_PVAV || dtype == SVt_PVHV
             || dtype == SVt_PVFM))
    {
	const char * const type = sv_reftype(dstr,0);
	if (PL_op)
	    /* diag_listed_as: Cannot copy to %s */
	    Perl_croak(aTHX_ "Cannot copy to %s in %s", type, OP_DESC(PL_op));
	else
	    Perl_croak(aTHX_ "Cannot copy to %s", type);
    } else if (sflags & SVf_ROK) {
	if (isGV_with_GP(dstr)
	    && SvTYPE(SvRV(sstr)) == SVt_PVGV && isGV_with_GP(SvRV(sstr))) {
	    sstr = SvRV(sstr);
	    if (sstr == dstr) {
		if (GvIMPORTED(dstr) != GVf_IMPORTED
		    && CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		{
		    GvIMPORTED_on(dstr);
		}
		GvMULTI_on(dstr);
		return;
	    }
	    glob_assign_glob(dstr, sstr, dtype);
	    return;
	}

	if (dtype >= SVt_PV) {
	    if (isGV_with_GP(dstr)) {
		gv_setref(dstr, sstr);
		return;
	    }
	    if (SvPVX_const(dstr)) {
		SvPV_free(dstr);
		SvLEN_set(dstr, 0);
                SvCUR_set(dstr, 0);
	    }
	}
	(void)SvOK_off(dstr);
	SvRV_set(dstr, SvREFCNT_inc(SvRV(sstr)));
	SvFLAGS(dstr) |= sflags & SVf_ROK;
	assert(!(sflags & SVp_NOK));
	assert(!(sflags & SVp_IOK));
	assert(!(sflags & SVf_NOK));
	assert(!(sflags & SVf_IOK));
    }
    else if (isGV_with_GP(dstr)) {
	if (!(sflags & SVf_OK)) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
			   "Undefined value assigned to typeglob");
	}
	else {
	    GV *gv = gv_fetchsv_nomg(sstr, GV_ADD, SVt_PVGV);
	    if (dstr != (const SV *)gv) {
		const char * const name = GvNAME((const GV *)dstr);
		const STRLEN len = GvNAMELEN(dstr);
		HV *old_stash = NULL;
		bool reset_isa = FALSE;
		if ((len > 1 && name[len-2] == ':' && name[len-1] == ':')
		 || (len == 1 && name[0] == ':')) {
		    /* Set aside the old stash, so we can reset isa caches
		       on its subclasses. */
		    if((old_stash = GvHV(dstr))) {
			/* Make sure we do not lose it early. */
			SvREFCNT_inc_simple_void_NN(
			 sv_2mortal((SV *)old_stash)
			);
		    }
		    reset_isa = TRUE;
		}

		if (GvGP(dstr)) {
		    SvREFCNT_inc_simple_void_NN(sv_2mortal(dstr));
		    gp_free(MUTABLE_GV(dstr));
		}
		GvGP_set(dstr, gp_ref(GvGP(gv)));

		if (reset_isa) {
		    HV * const stash = GvHV(dstr);
		    if(
		        old_stash ? (HV *)HvENAME_get(old_stash) : stash
		    )
			mro_package_moved(
			 stash, old_stash,
			 (GV *)dstr, 0
			);
		}
	    }
	}
    }
    else if ((dtype == SVt_REGEXP || dtype == SVt_PVLV)
	  && (stype == SVt_REGEXP || isREGEXP(sstr))) {
	reg_temp_copy((REGEXP*)dstr, (REGEXP*)sstr);
    }
    else if (sflags & SVp_POK) {
	const STRLEN cur = SvCUR(sstr);
	const STRLEN len = SvLEN(sstr);

	/*
	 * We have three basic ways to copy the string:
	 *
	 *  1. Swipe
	 *  2. Copy-on-write
	 *  3. Actual copy
	 * 
	 * Which we choose is based on various factors.  The following
	 * things are listed in order of speed, fastest to slowest:
	 *  - Swipe
	 *  - Copying a short string
	 *  - Copy-on-write bookkeeping
	 *  - malloc
	 *  - Copying a long string
	 * 
	 * We swipe the string (steal the string buffer) if the SV on the
	 * rhs is about to be freed anyway (TEMP and refcnt==1).  This is a
	 * big win on long strings.  It should be a win on short strings if
	 * SvPVX_const(dstr) has to be allocated.  If not, it should not 
	 * slow things down, as SvPVX_const(sstr) would have been freed
	 * soon anyway.
	 * 
	 * We also steal the buffer from a PADTMP (operator target) if it
	 * is ‘long enough’.  For short strings, a swipe does not help
	 * here, as it causes more malloc calls the next time the target
	 * is used.  Benchmarks show that even if SvPVX_const(dstr) has to
	 * be allocated it is still not worth swiping PADTMPs for short
	 * strings, as the savings here are small.
	 * 
	 * If swiping is not an option, then we see whether it is
	 * worth using copy-on-write.  If the lhs already has a buf-
	 * fer big enough and the string is short, we skip it and fall back
	 * to method 3, since memcpy is faster for short strings than the
	 * later bookkeeping overhead that copy-on-write entails.

	 * If the rhs is not a copy-on-write string yet, then we also
	 * consider whether the buffer is too large relative to the string
	 * it holds.  Some operations such as readline allocate a large
	 * buffer in the expectation of reusing it.  But turning such into
	 * a COW buffer is counter-productive because it increases memory
	 * usage by making readline allocate a new large buffer the sec-
	 * ond time round.  So, if the buffer is too large, again, we use
	 * method 3 (copy).
	 * 
	 * Finally, if there is no buffer on the left, or the buffer is too 
	 * small, then we use copy-on-write and make both SVs share the
	 * string buffer.
	 *
	 */

	/* Whichever path we take through the next code, we want this true,
	   and doing it now facilitates the COW check.  */
	(void)SvPOK_only(dstr);

	if (
                 (              /* Either ... */
				/* slated for free anyway (and not COW)? */
                    (sflags & (SVs_TEMP|SVf_IsCOW)) == SVs_TEMP
                                /* or a swipable TARG */
                 || ((sflags &
                           (SVs_PADTMP|SVf_READONLY|SVf_PROTECT|SVf_IsCOW))
                       == SVs_PADTMP
                                /* whose buffer is worth stealing */
                     && CHECK_COWBUF_THRESHOLD(cur,len)
                    )
                 ) &&
                 !(sflags & SVf_OOK) &&   /* and not involved in OOK hack? */
	         (!(flags & SV_NOSTEAL)) &&
					/* and we're allowed to steal temps */
                 SvREFCNT(sstr) == 1 &&   /* and no other references to it? */
                 len)             /* and really is a string */
	{	/* Passes the swipe test.  */
	    if (SvPVX_const(dstr))	/* we know that dtype >= SVt_PV */
		SvPV_free(dstr);
	    SvPV_set(dstr, SvPVX_mutable(sstr));
	    SvLEN_set(dstr, SvLEN(sstr));
	    SvCUR_set(dstr, SvCUR(sstr));

	    SvTEMP_off(dstr);
	    (void)SvOK_off(sstr);	/* NOTE: nukes most SvFLAGS on sstr */
	    SvPV_set(sstr, NULL);
	    SvLEN_set(sstr, 0);
	    SvCUR_set(sstr, 0);
	    SvTEMP_off(sstr);
        }
	else if (flags & SV_COW_SHARED_HASH_KEYS
	      &&
#ifdef PERL_COPY_ON_WRITE
		 (sflags & SVf_IsCOW
		   ? (!len ||
                       (  (CHECK_COWBUF_THRESHOLD(cur,len) || SvLEN(dstr) < cur+1)
			  /* If this is a regular (non-hek) COW, only so
			     many COW "copies" are possible. */
		       && CowREFCNT(sstr) != SV_COW_REFCNT_MAX  ))
		   : (  (sflags & CAN_COW_MASK) == CAN_COW_FLAGS
		     && !(SvFLAGS(dstr) & SVf_BREAK)
                     && CHECK_COW_THRESHOLD(cur,len) && cur+1 < len
                     && (CHECK_COWBUF_THRESHOLD(cur,len) || SvLEN(dstr) < cur+1)
		    ))
#else
		 sflags & SVf_IsCOW
	      && !(SvFLAGS(dstr) & SVf_BREAK)
#endif
            ) {
            /* Either it's a shared hash key, or it's suitable for
               copy-on-write.  */
            if (DEBUG_C_TEST) {
                PerlIO_printf(Perl_debug_log, "Copy on write: sstr --> dstr\n");
                sv_dump(sstr);
                sv_dump(dstr);
            }
#ifdef PERL_ANY_COW
            if (!(sflags & SVf_IsCOW)) {
                    SvIsCOW_on(sstr);
		    CowREFCNT(sstr) = 0;
            }
#endif
	    if (SvPVX_const(dstr)) {	/* we know that dtype >= SVt_PV */
		SvPV_free(dstr);
	    }

#ifdef PERL_ANY_COW
	    if (len) {
		    if (sflags & SVf_IsCOW) {
			sv_buf_to_rw(sstr);
		    }
		    CowREFCNT(sstr)++;
                    SvPV_set(dstr, SvPVX_mutable(sstr));
                    sv_buf_to_ro(sstr);
            } else
#endif
            {
                    /* SvIsCOW_shared_hash */
                    DEBUG_C(PerlIO_printf(Perl_debug_log,
                                          "Copy on write: Sharing hash\n"));

		    assert (SvTYPE(dstr) >= SVt_PV);
                    SvPV_set(dstr,
			     HEK_KEY(share_hek_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr)))));
	    }
	    SvLEN_set(dstr, len);
	    SvCUR_set(dstr, cur);
	    SvIsCOW_on(dstr);
	} else {
	    /* Failed the swipe test, and we cannot do copy-on-write either.
	       Have to copy the string.  */
	    SvGROW(dstr, cur + 1);	/* inlined from sv_setpvn */
	    Move(SvPVX_const(sstr),SvPVX(dstr),cur,char);
	    SvCUR_set(dstr, cur);
	    *SvEND(dstr) = '\0';
        }
	if (sflags & SVp_NOK) {
	    SvNV_set(dstr, SvNVX(sstr));
	}
	if (sflags & SVp_IOK) {
	    SvIV_set(dstr, SvIVX(sstr));
	    /* Must do this otherwise some other overloaded use of 0x80000000
	       gets confused. I guess SVpbm_VALID */
	    if (sflags & SVf_IVisUV)
		SvIsUV_on(dstr);
	}
	SvFLAGS(dstr) |= sflags & (SVf_IOK|SVp_IOK|SVf_NOK|SVp_NOK|SVf_UTF8);
	{
	    const MAGIC * const smg = SvVSTRING_mg(sstr);
	    if (smg) {
		sv_magic(dstr, NULL, PERL_MAGIC_vstring,
			 smg->mg_ptr, smg->mg_len);
		SvRMAGICAL_on(dstr);
	    }
	}
    }
    else if (sflags & (SVp_IOK|SVp_NOK)) {
	(void)SvOK_off(dstr);
	SvFLAGS(dstr) |= sflags & (SVf_IOK|SVp_IOK|SVf_IVisUV|SVf_NOK|SVp_NOK);
	if (sflags & SVp_IOK) {
	    /* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
	    SvIV_set(dstr, SvIVX(sstr));
	}
	if (sflags & SVp_NOK) {
	    SvNV_set(dstr, SvNVX(sstr));
	}
    }
    else {
	if (isGV_with_GP(sstr)) {
	    gv_efullname3(dstr, MUTABLE_GV(sstr), "*");
	}
	else
	    (void)SvOK_off(dstr);
    }
    if (SvTAINTED(sstr))
	SvTAINT(dstr);
}

/*
=for apidoc sv_setsv_mg

Like C<sv_setsv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setsv_mg(pTHX_ SV *const dstr, SV *const sstr)
{
    PERL_ARGS_ASSERT_SV_SETSV_MG;

    sv_setsv(dstr,sstr);
    SvSETMAGIC(dstr);
}

#ifdef PERL_ANY_COW
#  define SVt_COW SVt_PV
SV *
Perl_sv_setsv_cow(pTHX_ SV *dstr, SV *sstr)
{
    STRLEN cur = SvCUR(sstr);
    STRLEN len = SvLEN(sstr);
    char *new_pv;
#if defined(PERL_DEBUG_READONLY_COW) && defined(PERL_COPY_ON_WRITE)
    const bool already = cBOOL(SvIsCOW(sstr));
#endif

    PERL_ARGS_ASSERT_SV_SETSV_COW;

    if (DEBUG_C_TEST) {
	PerlIO_printf(Perl_debug_log, "Fast copy on write: %p -> %p\n",
		      (void*)sstr, (void*)dstr);
	sv_dump(sstr);
	if (dstr)
		    sv_dump(dstr);
    }

    if (dstr) {
	if (SvTHINKFIRST(dstr))
	    sv_force_normal_flags(dstr, SV_COW_DROP_PV);
	else if (SvPVX_const(dstr))
	    Safefree(SvPVX_mutable(dstr));
    }
    else
	new_SV(dstr);
    SvUPGRADE(dstr, SVt_COW);

    assert (SvPOK(sstr));
    assert (SvPOKp(sstr));

    if (SvIsCOW(sstr)) {

	if (SvLEN(sstr) == 0) {
	    /* source is a COW shared hash key.  */
	    DEBUG_C(PerlIO_printf(Perl_debug_log,
				  "Fast copy on write: Sharing hash\n"));
	    new_pv = HEK_KEY(share_hek_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr))));
	    goto common_exit;
	}
	assert(SvCUR(sstr)+1 < SvLEN(sstr));
	assert(CowREFCNT(sstr) < SV_COW_REFCNT_MAX);
    } else {
	assert ((SvFLAGS(sstr) & CAN_COW_MASK) == CAN_COW_FLAGS);
	SvUPGRADE(sstr, SVt_COW);
	SvIsCOW_on(sstr);
	DEBUG_C(PerlIO_printf(Perl_debug_log,
			      "Fast copy on write: Converting sstr to COW\n"));
	CowREFCNT(sstr) = 0;	
    }
#  ifdef PERL_DEBUG_READONLY_COW
    if (already) sv_buf_to_rw(sstr);
#  endif
    CowREFCNT(sstr)++;	
    new_pv = SvPVX_mutable(sstr);
    sv_buf_to_ro(sstr);

  common_exit:
    SvPV_set(dstr, new_pv);
    SvFLAGS(dstr) = (SVt_COW|SVf_POK|SVp_POK|SVf_IsCOW);
    if (SvUTF8(sstr))
	SvUTF8_on(dstr);
    SvLEN_set(dstr, len);
    SvCUR_set(dstr, cur);
    if (DEBUG_C_TEST) {
	sv_dump(dstr);
    }
    return dstr;
}
#endif

/*
=for apidoc sv_setpvn

Copies a string (possibly containing embedded C<NUL> characters) into an SV.
The C<len> parameter indicates the number of
bytes to be copied.  If the C<ptr> argument is NULL the SV will become
undefined.  Does not handle 'set' magic.  See C<L</sv_setpvn_mg>>.

=cut
*/

void
Perl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)
{
    char *dptr;

    PERL_ARGS_ASSERT_SV_SETPVN;

    SV_CHECK_THINKFIRST_COW_DROP(sv);
    if (!ptr) {
	(void)SvOK_off(sv);
	return;
    }
    else {
        /* len is STRLEN which is unsigned, need to copy to signed */
	const IV iv = len;
	if (iv < 0)
	    Perl_croak(aTHX_ "panic: sv_setpvn called with negative strlen %"
		       IVdf, iv);
    }
    SvUPGRADE(sv, SVt_PV);

    dptr = SvGROW(sv, len + 1);
    Move(ptr,dptr,len,char);
    dptr[len] = '\0';
    SvCUR_set(sv, len);
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
    SvTAINT(sv);
    if (SvTYPE(sv) == SVt_PVCV) CvAUTOLOAD_off(sv);
}

/*
=for apidoc sv_setpvn_mg

Like C<sv_setpvn>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setpvn_mg(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)
{
    PERL_ARGS_ASSERT_SV_SETPVN_MG;

    sv_setpvn(sv,ptr,len);
    SvSETMAGIC(sv);
}

/*
=for apidoc sv_setpv

Copies a string into an SV.  The string must be terminated with a C<NUL>
character.
Does not handle 'set' magic.  See C<L</sv_setpv_mg>>.

=cut
*/

void
Perl_sv_setpv(pTHX_ SV *const sv, const char *const ptr)
{
    STRLEN len;

    PERL_ARGS_ASSERT_SV_SETPV;

    SV_CHECK_THINKFIRST_COW_DROP(sv);
    if (!ptr) {
	(void)SvOK_off(sv);
	return;
    }
    len = strlen(ptr);
    SvUPGRADE(sv, SVt_PV);

    SvGROW(sv, len + 1);
    Move(ptr,SvPVX(sv),len+1,char);
    SvCUR_set(sv, len);
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
    SvTAINT(sv);
    if (SvTYPE(sv) == SVt_PVCV) CvAUTOLOAD_off(sv);
}

/*
=for apidoc sv_setpv_mg

Like C<sv_setpv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setpv_mg(pTHX_ SV *const sv, const char *const ptr)
{
    PERL_ARGS_ASSERT_SV_SETPV_MG;

    sv_setpv(sv,ptr);
    SvSETMAGIC(sv);
}

void
Perl_sv_sethek(pTHX_ SV *const sv, const HEK *const hek)
{
    PERL_ARGS_ASSERT_SV_SETHEK;

    if (!hek) {
	return;
    }

    if (HEK_LEN(hek) == HEf_SVKEY) {
	sv_setsv(sv, *(SV**)HEK_KEY(hek));
        return;
    } else {
	const int flags = HEK_FLAGS(hek);
	if (flags & HVhek_WASUTF8) {
	    STRLEN utf8_len = HEK_LEN(hek);
	    char *as_utf8 = (char *)bytes_to_utf8((U8*)HEK_KEY(hek), &utf8_len);
	    sv_usepvn_flags(sv, as_utf8, utf8_len, SV_HAS_TRAILING_NUL);
	    SvUTF8_on(sv);
            return;
        } else if (flags & HVhek_UNSHARED) {
	    sv_setpvn(sv, HEK_KEY(hek), HEK_LEN(hek));
	    if (HEK_UTF8(hek))
		SvUTF8_on(sv);
	    else SvUTF8_off(sv);
            return;
	}
        {
	    SV_CHECK_THINKFIRST_COW_DROP(sv);
	    SvUPGRADE(sv, SVt_PV);
	    SvPV_free(sv);
	    SvPV_set(sv,(char *)HEK_KEY(share_hek_hek(hek)));
	    SvCUR_set(sv, HEK_LEN(hek));
	    SvLEN_set(sv, 0);
	    SvIsCOW_on(sv);
	    SvPOK_on(sv);
	    if (HEK_UTF8(hek))
		SvUTF8_on(sv);
	    else SvUTF8_off(sv);
            return;
	}
    }
}


/*
=for apidoc sv_usepvn_flags

Tells an SV to use C<ptr> to find its string value.  Normally the
string is stored inside the SV, but sv_usepvn allows the SV to use an
outside string.  C<ptr> should point to memory that was allocated
by L<C<Newx>|perlclib/Memory Management and String Handling>.  It must be
the start of a C<Newx>-ed block of memory, and not a pointer to the
middle of it (beware of L<C<OOK>|perlguts/Offsets> and copy-on-write),
and not be from a non-C<Newx> memory allocator like C<malloc>.  The
string length, C<len>, must be supplied.  By default this function
will C<Renew> (i.e. realloc, move) the memory pointed to by C<ptr>,
so that pointer should not be freed or used by the programmer after
giving it to C<sv_usepvn>, and neither should any pointers from "behind"
that pointer (e.g. ptr + 1) be used.

If S<C<flags & SV_SMAGIC>> is true, will call C<SvSETMAGIC>.  If
S<C<flags> & SV_HAS_TRAILING_NUL>> is true, then C<ptr[len]> must be C<NUL>,
and the realloc
will be skipped (i.e. the buffer is actually at least 1 byte longer than
C<len>, and already meets the requirements for storing in C<SvPVX>).

=cut
*/

void
Perl_sv_usepvn_flags(pTHX_ SV *const sv, char *ptr, const STRLEN len, const U32 flags)
{
    STRLEN allocate;

    PERL_ARGS_ASSERT_SV_USEPVN_FLAGS;

    SV_CHECK_THINKFIRST_COW_DROP(sv);
    SvUPGRADE(sv, SVt_PV);
    if (!ptr) {
	(void)SvOK_off(sv);
	if (flags & SV_SMAGIC)
	    SvSETMAGIC(sv);
	return;
    }
    if (SvPVX_const(sv))
	SvPV_free(sv);

#ifdef DEBUGGING
    if (flags & SV_HAS_TRAILING_NUL)
	assert(ptr[len] == '\0');
#endif

    allocate = (flags & SV_HAS_TRAILING_NUL)
	? len + 1 :
#ifdef Perl_safesysmalloc_size
	len + 1;
#else 
	PERL_STRLEN_ROUNDUP(len + 1);
#endif
    if (flags & SV_HAS_TRAILING_NUL) {
	/* It's long enough - do nothing.
	   Specifically Perl_newCONSTSUB is relying on this.  */
    } else {
#ifdef DEBUGGING
	/* Force a move to shake out bugs in callers.  */
	char *new_ptr = (char*)safemalloc(allocate);
	Copy(ptr, new_ptr, len, char);
	PoisonFree(ptr,len,char);
	Safefree(ptr);
	ptr = new_ptr;
#else
	ptr = (char*) saferealloc (ptr, allocate);
#endif
    }
#ifdef Perl_safesysmalloc_size
    SvLEN_set(sv, Perl_safesysmalloc_size(ptr));
#else
    SvLEN_set(sv, allocate);
#endif
    SvCUR_set(sv, len);
    SvPV_set(sv, ptr);
    if (!(flags & SV_HAS_TRAILING_NUL)) {
	ptr[len] = '\0';
    }
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
    SvTAINT(sv);
    if (flags & SV_SMAGIC)
	SvSETMAGIC(sv);
}

/*
=for apidoc sv_force_normal_flags

Undo various types of fakery on an SV, where fakery means
"more than" a string: if the PV is a shared string, make
a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
an C<xpvmg>; if we're a copy-on-write scalar, this is the on-write time when
we do the copy, and is also used locally; if this is a
vstring, drop the vstring magic.  If C<SV_COW_DROP_PV> is set
then a copy-on-write scalar drops its PV buffer (if any) and becomes
C<SvPOK_off> rather than making a copy.  (Used where this
scalar is about to be set to some other value.)  In addition,
the C<flags> parameter gets passed to C<sv_unref_flags()>
when unreffing.  C<sv_force_normal> calls this function
with flags set to 0.

This function is expected to be used to signal to perl that this SV is
about to be written to, and any extra book-keeping needs to be taken care
of.  Hence, it croaks on read-only values.

=cut
*/

static void
S_sv_uncow(pTHX_ SV * const sv, const U32 flags)
{
    assert(SvIsCOW(sv));
    {
#ifdef PERL_ANY_COW
	const char * const pvx = SvPVX_const(sv);
	const STRLEN len = SvLEN(sv);
	const STRLEN cur = SvCUR(sv);

        if (DEBUG_C_TEST) {
                PerlIO_printf(Perl_debug_log,
                              "Copy on write: Force normal %ld\n",
                              (long) flags);
                sv_dump(sv);
        }
        SvIsCOW_off(sv);
# ifdef PERL_COPY_ON_WRITE
	if (len) {
	    /* Must do this first, since the CowREFCNT uses SvPVX and
	    we need to write to CowREFCNT, or de-RO the whole buffer if we are
	    the only owner left of the buffer. */
	    sv_buf_to_rw(sv); /* NOOP if RO-ing not supported */
	    {
		U8 cowrefcnt = CowREFCNT(sv);
		if(cowrefcnt != 0) {
		    cowrefcnt--;
		    CowREFCNT(sv) = cowrefcnt;
		    sv_buf_to_ro(sv);
		    goto copy_over;
		}
	    }
	    /* Else we are the only owner of the buffer. */
        }
	else
# endif
	{
            /* This SV doesn't own the buffer, so need to Newx() a new one:  */
            copy_over:
            SvPV_set(sv, NULL);
            SvCUR_set(sv, 0);
            SvLEN_set(sv, 0);
            if (flags & SV_COW_DROP_PV) {
                /* OK, so we don't need to copy our buffer.  */
                SvPOK_off(sv);
            } else {
                SvGROW(sv, cur + 1);
                Move(pvx,SvPVX(sv),cur,char);
                SvCUR_set(sv, cur);
                *SvEND(sv) = '\0';
            }
	    if (len) {
	    } else {
		unshare_hek(SvSHARED_HEK_FROM_PV(pvx));
	    }
            if (DEBUG_C_TEST) {
                sv_dump(sv);
            }
	}
#else
	    const char * const pvx = SvPVX_const(sv);
	    const STRLEN len = SvCUR(sv);
	    SvIsCOW_off(sv);
	    SvPV_set(sv, NULL);
	    SvLEN_set(sv, 0);
	    if (flags & SV_COW_DROP_PV) {
		/* OK, so we don't need to copy our buffer.  */
		SvPOK_off(sv);
	    } else {
		SvGROW(sv, len + 1);
		Move(pvx,SvPVX(sv),len,char);
		*SvEND(sv) = '\0';
	    }
	    unshare_hek(SvSHARED_HEK_FROM_PV(pvx));
#endif
    }
}

void
Perl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags)
{
    PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS;

    if (SvREADONLY(sv))
	Perl_croak_no_modify();
    else if (SvIsCOW(sv) && LIKELY(SvTYPE(sv) != SVt_PVHV))
	S_sv_uncow(aTHX_ sv, flags);
    if (SvROK(sv))
	sv_unref_flags(sv, flags);
    else if (SvFAKE(sv) && isGV_with_GP(sv))
	sv_unglob(sv, flags);
    else if (SvFAKE(sv) && isREGEXP(sv)) {
	/* Need to downgrade the REGEXP to a simple(r) scalar. This is analogous
	   to sv_unglob. We only need it here, so inline it.  */
	const bool islv = SvTYPE(sv) == SVt_PVLV;
	const svtype new_type =
	  islv ? SVt_NULL : SvMAGIC(sv) || SvSTASH(sv) ? SVt_PVMG : SVt_PV;
	SV *const temp = newSV_type(new_type);
	regexp *const temp_p = ReANY((REGEXP *)sv);

	if (new_type == SVt_PVMG) {
	    SvMAGIC_set(temp, SvMAGIC(sv));
	    SvMAGIC_set(sv, NULL);
	    SvSTASH_set(temp, SvSTASH(sv));
	    SvSTASH_set(sv, NULL);
	}
	if (!islv) SvCUR_set(temp, SvCUR(sv));
	/* Remember that SvPVX is in the head, not the body.  But
	   RX_WRAPPED is in the body. */
	assert(ReANY((REGEXP *)sv)->mother_re);
	/* Their buffer is already owned by someone else. */
	if (flags & SV_COW_DROP_PV) {
	    /* SvLEN is already 0.  For SVt_REGEXP, we have a brand new
	       zeroed body.  For SVt_PVLV, it should have been set to 0
	       before turning into a regexp. */
	    assert(!SvLEN(islv ? sv : temp));
	    sv->sv_u.svu_pv = 0;
	}
	else {
	    sv->sv_u.svu_pv = savepvn(RX_WRAPPED((REGEXP *)sv), SvCUR(sv));
	    SvLEN_set(islv ? sv : temp, SvCUR(sv)+1);
	    SvPOK_on(sv);
	}

	/* Now swap the rest of the bodies. */

	SvFAKE_off(sv);
	if (!islv) {
	    SvFLAGS(sv) &= ~SVTYPEMASK;
	    SvFLAGS(sv) |= new_type;
	    SvANY(sv) = SvANY(temp);
	}

	SvFLAGS(temp) &= ~(SVTYPEMASK);
	SvFLAGS(temp) |= SVt_REGEXP|SVf_FAKE;
	SvANY(temp) = temp_p;
	temp->sv_u.svu_rx = (regexp *)temp_p;

	SvREFCNT_dec_NN(temp);
    }
    else if (SvVOK(sv)) sv_unmagic(sv, PERL_MAGIC_vstring);
}

/*
=for apidoc sv_chop

Efficient removal of characters from the beginning of the string buffer.
C<SvPOK(sv)>, or at least C<SvPOKp(sv)>, must be true and C<ptr> must be a
pointer to somewhere inside the string buffer.  C<ptr> becomes the first
character of the adjusted string.  Uses the C<OOK> hack.  On return, only
C<SvPOK(sv)> and C<SvPOKp(sv)> among the C<OK> flags will be true.

Beware: after this function returns, C<ptr> and SvPVX_const(sv) may no longer
refer to the same chunk of data.

The unfortunate similarity of this function's name to that of Perl's C<chop>
operator is strictly coincidental.  This function works from the left;
C<chop> works from the right.

=cut
*/

void
Perl_sv_chop(pTHX_ SV *const sv, const char *const ptr)
{
    STRLEN delta;
    STRLEN old_delta;
    U8 *p;
#ifdef DEBUGGING
    const U8 *evacp;
    STRLEN evacn;
#endif
    STRLEN max_delta;

    PERL_ARGS_ASSERT_SV_CHOP;

    if (!ptr || !SvPOKp(sv))
	return;
    delta = ptr - SvPVX_const(sv);
    if (!delta) {
	/* Nothing to do.  */
	return;
    }
    max_delta = SvLEN(sv) ? SvLEN(sv) : SvCUR(sv);
    if (delta > max_delta)
	Perl_croak(aTHX_ "panic: sv_chop ptr=%p, start=%p, end=%p",
		   ptr, SvPVX_const(sv), SvPVX_const(sv) + max_delta);
    /* SvPVX(sv) may move in SV_CHECK_THINKFIRST(sv), so don't use ptr any more */
    SV_CHECK_THINKFIRST(sv);
    SvPOK_only_UTF8(sv);

    if (!SvOOK(sv)) {
	if (!SvLEN(sv)) { /* make copy of shared string */
	    const char *pvx = SvPVX_const(sv);
	    const STRLEN len = SvCUR(sv);
	    SvGROW(sv, len + 1);
	    Move(pvx,SvPVX(sv),len,char);
	    *SvEND(sv) = '\0';
	}
	SvOOK_on(sv);
	old_delta = 0;
    } else {
	SvOOK_offset(sv, old_delta);
    }
    SvLEN_set(sv, SvLEN(sv) - delta);
    SvCUR_set(sv, SvCUR(sv) - delta);
    SvPV_set(sv, SvPVX(sv) + delta);

    p = (U8 *)SvPVX_const(sv);

#ifdef DEBUGGING
    /* how many bytes were evacuated?  we will fill them with sentinel
       bytes, except for the part holding the new offset of course. */
    evacn = delta;
    if (old_delta)
	evacn += (old_delta < 0x100 ? 1 : 1 + sizeof(STRLEN));
    assert(evacn);
    assert(evacn <= delta + old_delta);
    evacp = p - evacn;
#endif

    /* This sets 'delta' to the accumulated value of all deltas so far */
    delta += old_delta;
    assert(delta);

    /* If 'delta' fits in a byte, store it just prior to the new beginning of
     * the string; otherwise store a 0 byte there and store 'delta' just prior
     * to that, using as many bytes as a STRLEN occupies.  Thus it overwrites a
     * portion of the chopped part of the string */
    if (delta < 0x100) {
	*--p = (U8) delta;
    } else {
	*--p = 0;
	p -= sizeof(STRLEN);
	Copy((U8*)&delta, p, sizeof(STRLEN), U8);
    }

#ifdef DEBUGGING
    /* Fill the preceding buffer with sentinals to verify that no-one is
       using it.  */
    while (p > evacp) {
	--p;
	*p = (U8)PTR2UV(p);
    }
#endif
}

/*
=for apidoc sv_catpvn

Concatenates the string onto the end of the string which is in the SV.
C<len> indicates number of bytes to copy.  If the SV has the UTF-8
status set, then the bytes appended should be valid UTF-8.
Handles 'get' magic, but not 'set' magic.  See C<L</sv_catpvn_mg>>.

=for apidoc sv_catpvn_flags

Concatenates the string onto the end of the string which is in the SV.  The
C<len> indicates number of bytes to copy.

By default, the string appended is assumed to be valid UTF-8 if the SV has
the UTF-8 status set, and a string of bytes otherwise.  One can force the
appended string to be interpreted as UTF-8 by supplying the C<SV_CATUTF8>
flag, and as bytes by supplying the C<SV_CATBYTES> flag; the SV or the
string appended will be upgraded to UTF-8 if necessary.

If C<flags> has the C<SV_SMAGIC> bit set, will
C<mg_set> on C<dsv> afterwards if appropriate.
C<sv_catpvn> and C<sv_catpvn_nomg> are implemented
in terms of this function.

=cut
*/

void
Perl_sv_catpvn_flags(pTHX_ SV *const dsv, const char *sstr, const STRLEN slen, const I32 flags)
{
    STRLEN dlen;
    const char * const dstr = SvPV_force_flags(dsv, dlen, flags);

    PERL_ARGS_ASSERT_SV_CATPVN_FLAGS;
    assert((flags & (SV_CATBYTES|SV_CATUTF8)) != (SV_CATBYTES|SV_CATUTF8));

    if (!(flags & SV_CATBYTES) || !SvUTF8(dsv)) {
      if (flags & SV_CATUTF8 && !SvUTF8(dsv)) {
	 sv_utf8_upgrade_flags_grow(dsv, 0, slen + 1);
	 dlen = SvCUR(dsv);
      }
      else SvGROW(dsv, dlen + slen + 1);
      if (sstr == dstr)
	sstr = SvPVX_const(dsv);
      Move(sstr, SvPVX(dsv) + dlen, slen, char);
      SvCUR_set(dsv, SvCUR(dsv) + slen);
    }
    else {
	/* We inline bytes_to_utf8, to avoid an extra malloc. */
	const char * const send = sstr + slen;
	U8 *d;

	/* Something this code does not account for, which I think is
	   impossible; it would require the same pv to be treated as
	   bytes *and* utf8, which would indicate a bug elsewhere. */
	assert(sstr != dstr);

	SvGROW(dsv, dlen + slen * 2 + 1);
	d = (U8 *)SvPVX(dsv) + dlen;

	while (sstr < send) {
            append_utf8_from_native_byte(*sstr, &d);
	    sstr++;
	}
	SvCUR_set(dsv, d-(const U8 *)SvPVX(dsv));
    }
    *SvEND(dsv) = '\0';
    (void)SvPOK_only_UTF8(dsv);		/* validate pointer */
    SvTAINT(dsv);
    if (flags & SV_SMAGIC)
	SvSETMAGIC(dsv);
}

/*
=for apidoc sv_catsv

Concatenates the string from SV C<ssv> onto the end of the string in SV
C<dsv>.  If C<ssv> is null, does nothing; otherwise modifies only C<dsv>.
Handles 'get' magic on both SVs, but no 'set' magic.  See C<L</sv_catsv_mg>>
and C<L</sv_catsv_nomg>>.

=for apidoc sv_catsv_flags

Concatenates the string from SV C<ssv> onto the end of the string in SV
C<dsv>.  If C<ssv> is null, does nothing; otherwise modifies only C<dsv>.
If C<flags> has the C<SV_GMAGIC> bit set, will call C<mg_get> on both SVs if
appropriate.  If C<flags> has the C<SV_SMAGIC> bit set, C<mg_set> will be called on
the modified SV afterward, if appropriate.  C<sv_catsv>, C<sv_catsv_nomg>,
and C<sv_catsv_mg> are implemented in terms of this function.

=cut */

void
Perl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_CATSV_FLAGS;

    if (ssv) {
	STRLEN slen;
	const char *spv = SvPV_flags_const(ssv, slen, flags);
        if (flags & SV_GMAGIC)
                SvGETMAGIC(dsv);
        sv_catpvn_flags(dsv, spv, slen,
			    DO_UTF8(ssv) ? SV_CATUTF8 : SV_CATBYTES);
        if (flags & SV_SMAGIC)
                SvSETMAGIC(dsv);
    }
}

/*
=for apidoc sv_catpv

Concatenates the C<NUL>-terminated string onto the end of the string which is
in the SV.
If the SV has the UTF-8 status set, then the bytes appended should be
valid UTF-8.  Handles 'get' magic, but not 'set' magic.  See
C<L</sv_catpv_mg>>.

=cut */

void
Perl_sv_catpv(pTHX_ SV *const sv, const char *ptr)
{
    STRLEN len;
    STRLEN tlen;
    char *junk;

    PERL_ARGS_ASSERT_SV_CATPV;

    if (!ptr)
	return;
    junk = SvPV_force(sv, tlen);
    len = strlen(ptr);
    SvGROW(sv, tlen + len + 1);
    if (ptr == junk)
	ptr = SvPVX_const(sv);
    Move(ptr,SvPVX(sv)+tlen,len+1,char);
    SvCUR_set(sv, SvCUR(sv) + len);
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
    SvTAINT(sv);
}

/*
=for apidoc sv_catpv_flags

Concatenates the C<NUL>-terminated string onto the end of the string which is
in the SV.
If the SV has the UTF-8 status set, then the bytes appended should
be valid UTF-8.  If C<flags> has the C<SV_SMAGIC> bit set, will C<mg_set>
on the modified SV if appropriate.

=cut
*/

void
Perl_sv_catpv_flags(pTHX_ SV *dstr, const char *sstr, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_CATPV_FLAGS;
    sv_catpvn_flags(dstr, sstr, strlen(sstr), flags);
}

/*
=for apidoc sv_catpv_mg

Like C<sv_catpv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catpv_mg(pTHX_ SV *const sv, const char *const ptr)
{
    PERL_ARGS_ASSERT_SV_CATPV_MG;

    sv_catpv(sv,ptr);
    SvSETMAGIC(sv);
}

/*
=for apidoc newSV

Creates a new SV.  A non-zero C<len> parameter indicates the number of
bytes of preallocated string space the SV should have.  An extra byte for a
trailing C<NUL> is also reserved.  (C<SvPOK> is not set for the SV even if string
space is allocated.)  The reference count for the new SV is set to 1.

In 5.9.3, C<newSV()> replaces the older C<NEWSV()> API, and drops the first
parameter, I<x>, a debug aid which allowed callers to identify themselves.
This aid has been superseded by a new build option, C<PERL_MEM_LOG> (see
L<perlhacktips/PERL_MEM_LOG>).  The older API is still there for use in XS
modules supporting older perls.

=cut
*/

SV *
Perl_newSV(pTHX_ const STRLEN len)
{
    SV *sv;

    new_SV(sv);
    if (len) {
	sv_grow(sv, len + 1);
    }
    return sv;
}
/*
=for apidoc sv_magicext

Adds magic to an SV, upgrading it if necessary.  Applies the
supplied C<vtable> and returns a pointer to the magic added.

Note that C<sv_magicext> will allow things that C<sv_magic> will not.
In particular, you can add magic to C<SvREADONLY> SVs, and add more than
one instance of the same C<how>.

If C<namlen> is greater than zero then a C<savepvn> I<copy> of C<name> is
stored, if C<namlen> is zero then C<name> is stored as-is and - as another
special case - if C<(name && namlen == HEf_SVKEY)> then C<name> is assumed
to contain an SV* and is stored as-is with its C<REFCNT> incremented.

(This is now used as a subroutine by C<sv_magic>.)

=cut
*/
MAGIC *	
Perl_sv_magicext(pTHX_ SV *const sv, SV *const obj, const int how, 
                const MGVTBL *const vtable, const char *const name, const I32 namlen)
{
    MAGIC* mg;

    PERL_ARGS_ASSERT_SV_MAGICEXT;

    SvUPGRADE(sv, SVt_PVMG);
    Newxz(mg, 1, MAGIC);
    mg->mg_moremagic = SvMAGIC(sv);
    SvMAGIC_set(sv, mg);

    /* Sometimes a magic contains a reference loop, where the sv and
       object refer to each other.  To prevent a reference loop that
       would prevent such objects being freed, we look for such loops
       and if we find one we avoid incrementing the object refcount.

       Note we cannot do this to avoid self-tie loops as intervening RV must
       have its REFCNT incremented to keep it in existence.

    */
    if (!obj || obj == sv ||
	how == PERL_MAGIC_arylen ||
	how == PERL_MAGIC_symtab ||
	(SvTYPE(obj) == SVt_PVGV &&
	    (GvSV(obj) == sv || GvHV(obj) == (const HV *)sv
	     || GvAV(obj) == (const AV *)sv || GvCV(obj) == (const CV *)sv
	     || GvIOp(obj) == (const IO *)sv || GvFORM(obj) == (const CV *)sv)))
    {
	mg->mg_obj = obj;
    }
    else {
	mg->mg_obj = SvREFCNT_inc_simple(obj);
	mg->mg_flags |= MGf_REFCOUNTED;
    }

    /* Normal self-ties simply pass a null object, and instead of
       using mg_obj directly, use the SvTIED_obj macro to produce a
       new RV as needed.  For glob "self-ties", we are tieing the PVIO
       with an RV obj pointing to the glob containing the PVIO.  In
       this case, to avoid a reference loop, we need to weaken the
       reference.
    */

    if (how == PERL_MAGIC_tiedscalar && SvTYPE(sv) == SVt_PVIO &&
        obj && SvROK(obj) && GvIO(SvRV(obj)) == (const IO *)sv)
    {
      sv_rvweaken(obj);
    }

    mg->mg_type = how;
    mg->mg_len = namlen;
    if (name) {
	if (namlen > 0)
	    mg->mg_ptr = savepvn(name, namlen);
	else if (namlen == HEf_SVKEY) {
	    /* Yes, this is casting away const. This is only for the case of
	       HEf_SVKEY. I think we need to document this aberation of the
	       constness of the API, rather than making name non-const, as
	       that change propagating outwards a long way.  */
	    mg->mg_ptr = (char*)SvREFCNT_inc_simple_NN((SV *)name);
	} else
	    mg->mg_ptr = (char *) name;
    }
    mg->mg_virtual = (MGVTBL *) vtable;

    mg_magical(sv);
    return mg;
}

MAGIC *
Perl_sv_magicext_mglob(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_MAGICEXT_MGLOB;
    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y') {
	/* This sv is only a delegate.  //g magic must be attached to
	   its target. */
	vivify_defelem(sv);
	sv = LvTARG(sv);
    }
    return sv_magicext(sv, NULL, PERL_MAGIC_regex_global,
		       &PL_vtbl_mglob, 0, 0);
}

/*
=for apidoc sv_magic

Adds magic to an SV.  First upgrades C<sv> to type C<SVt_PVMG> if
necessary, then adds a new magic item of type C<how> to the head of the
magic list.

See C<L</sv_magicext>> (which C<sv_magic> now calls) for a description of the
handling of the C<name> and C<namlen> arguments.

You need to use C<sv_magicext> to add magic to C<SvREADONLY> SVs and also
to add more than one instance of the same C<how>.

=cut
*/

void
Perl_sv_magic(pTHX_ SV *const sv, SV *const obj, const int how,
             const char *const name, const I32 namlen)
{
    const MGVTBL *vtable;
    MAGIC* mg;
    unsigned int flags;
    unsigned int vtable_index;

    PERL_ARGS_ASSERT_SV_MAGIC;

    if (how < 0 || (unsigned)how >= C_ARRAY_LENGTH(PL_magic_data)
	|| ((flags = PL_magic_data[how]),
	    (vtable_index = flags & PERL_MAGIC_VTABLE_MASK)
	    > magic_vtable_max))
	Perl_croak(aTHX_ "Don't know how to handle magic of type \\%o", how);

    /* PERL_MAGIC_ext is reserved for use by extensions not perl internals.
       Useful for attaching extension internal data to perl vars.
       Note that multiple extensions may clash if magical scalars
       etc holding private data from one are passed to another. */

    vtable = (vtable_index == magic_vtable_max)
	? NULL : PL_magic_vtables + vtable_index;

    if (SvREADONLY(sv)) {
	if (
	    !PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(how)
	   )
	{
	    Perl_croak_no_modify();
	}
    }
    if (SvMAGICAL(sv) || (how == PERL_MAGIC_taint && SvTYPE(sv) >= SVt_PVMG)) {
	if (SvMAGIC(sv) && (mg = mg_find(sv, how))) {
	    /* sv_magic() refuses to add a magic of the same 'how' as an
	       existing one
	     */
	    if (how == PERL_MAGIC_taint)
		mg->mg_len |= 1;
	    return;
	}
    }

    /* Force pos to be stored as characters, not bytes. */
    if (SvMAGICAL(sv) && DO_UTF8(sv)
      && (mg = mg_find(sv, PERL_MAGIC_regex_global))
      && mg->mg_len != -1
      && mg->mg_flags & MGf_BYTES) {
	mg->mg_len = (SSize_t)sv_pos_b2u_flags(sv, (STRLEN)mg->mg_len,
					       SV_CONST_RETURN);
	mg->mg_flags &= ~MGf_BYTES;
    }

    /* Rest of work is done else where */
    mg = sv_magicext(sv,obj,how,vtable,name,namlen);

    switch (how) {
    case PERL_MAGIC_taint:
	mg->mg_len = 1;
	break;
    case PERL_MAGIC_ext:
    case PERL_MAGIC_dbfile:
	SvRMAGICAL_on(sv);
	break;
    }
}

static int
S_sv_unmagicext_flags(pTHX_ SV *const sv, const int type, MGVTBL *vtbl, const U32 flags)
{
    MAGIC* mg;
    MAGIC** mgp;

    assert(flags <= 1);

    if (SvTYPE(sv) < SVt_PVMG || !SvMAGIC(sv))
	return 0;
    mgp = &(((XPVMG*) SvANY(sv))->xmg_u.xmg_magic);
    for (mg = *mgp; mg; mg = *mgp) {
	const MGVTBL* const virt = mg->mg_virtual;
	if (mg->mg_type == type && (!flags || virt == vtbl)) {
	    *mgp = mg->mg_moremagic;
	    if (virt && virt->svt_free)
		virt->svt_free(aTHX_ sv, mg);
	    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
		if (mg->mg_len > 0)
		    Safefree(mg->mg_ptr);
		else if (mg->mg_len == HEf_SVKEY)
		    SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
		else if (mg->mg_type == PERL_MAGIC_utf8)
		    Safefree(mg->mg_ptr);
            }
	    if (mg->mg_flags & MGf_REFCOUNTED)
		SvREFCNT_dec(mg->mg_obj);
	    Safefree(mg);
	}
	else
	    mgp = &mg->mg_moremagic;
    }
    if (SvMAGIC(sv)) {
	if (SvMAGICAL(sv))	/* if we're under save_magic, wait for restore_magic; */
	    mg_magical(sv);	/*    else fix the flags now */
    }
    else
	SvMAGICAL_off(sv);

    return 0;
}

/*
=for apidoc sv_unmagic

Removes all magic of type C<type> from an SV.

=cut
*/

int
Perl_sv_unmagic(pTHX_ SV *const sv, const int type)
{
    PERL_ARGS_ASSERT_SV_UNMAGIC;
    return S_sv_unmagicext_flags(aTHX_ sv, type, NULL, 0);
}

/*
=for apidoc sv_unmagicext

Removes all magic of type C<type> with the specified C<vtbl> from an SV.

=cut
*/

int
Perl_sv_unmagicext(pTHX_ SV *const sv, const int type, MGVTBL *vtbl)
{
    PERL_ARGS_ASSERT_SV_UNMAGICEXT;
    return S_sv_unmagicext_flags(aTHX_ sv, type, vtbl, 1);
}

/*
=for apidoc sv_rvweaken

Weaken a reference: set the C<SvWEAKREF> flag on this RV; give the
referred-to SV C<PERL_MAGIC_backref> magic if it hasn't already; and
push a back-reference to this RV onto the array of backreferences
associated with that magic.  If the RV is magical, set magic will be
called after the RV is cleared.

=cut
*/

SV *
Perl_sv_rvweaken(pTHX_ SV *const sv)
{
    SV *tsv;

    PERL_ARGS_ASSERT_SV_RVWEAKEN;

    if (!SvOK(sv))  /* let undefs pass */
	return sv;
    if (!SvROK(sv))
	Perl_croak(aTHX_ "Can't weaken a nonreference");
    else if (SvWEAKREF(sv)) {
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Reference is already weak");
	return sv;
    }
    else if (SvREADONLY(sv)) croak_no_modify();
    tsv = SvRV(sv);
    Perl_sv_add_backref(aTHX_ tsv, sv);
    SvWEAKREF_on(sv);
    SvREFCNT_dec_NN(tsv);
    return sv;
}

/*
=for apidoc sv_get_backrefs

If C<sv> is the target of a weak reference then it returns the back
references structure associated with the sv; otherwise return C<NULL>.

When returning a non-null result the type of the return is relevant. If it
is an AV then the elements of the AV are the weak reference RVs which
point at this item. If it is any other type then the item itself is the
weak reference.

See also C<Perl_sv_add_backref()>, C<Perl_sv_del_backref()>,
C<Perl_sv_kill_backrefs()>

=cut
*/

SV *
Perl_sv_get_backrefs(SV *const sv)
{
    SV *backrefs= NULL;

    PERL_ARGS_ASSERT_SV_GET_BACKREFS;

    /* find slot to store array or singleton backref */

    if (SvTYPE(sv) == SVt_PVHV) {
        if (SvOOK(sv)) {
            struct xpvhv_aux * const iter = HvAUX((HV *)sv);
            backrefs = (SV *)iter->xhv_backreferences;
        }
    } else if (SvMAGICAL(sv)) {
        MAGIC *mg = mg_find(sv, PERL_MAGIC_backref);
        if (mg)
            backrefs = mg->mg_obj;
    }
    return backrefs;
}

/* Give tsv backref magic if it hasn't already got it, then push a
 * back-reference to sv onto the array associated with the backref magic.
 *
 * As an optimisation, if there's only one backref and it's not an AV,
 * store it directly in the HvAUX or mg_obj slot, avoiding the need to
 * allocate an AV. (Whether the slot holds an AV tells us whether this is
 * active.)
 */

/* A discussion about the backreferences array and its refcount:
 *
 * The AV holding the backreferences is pointed to either as the mg_obj of
 * PERL_MAGIC_backref, or in the specific case of a HV, from the
 * xhv_backreferences field. The array is created with a refcount
 * of 2. This means that if during global destruction the array gets
 * picked on before its parent to have its refcount decremented by the
 * random zapper, it won't actually be freed, meaning it's still there for
 * when its parent gets freed.
 *
 * When the parent SV is freed, the extra ref is killed by
 * Perl_sv_kill_backrefs.  The other ref is killed, in the case of magic,
 * by mg_free() / MGf_REFCOUNTED, or for a hash, by Perl_hv_kill_backrefs.
 *
 * When a single backref SV is stored directly, it is not reference
 * counted.
 */

void
Perl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv)
{
    SV **svp;
    AV *av = NULL;
    MAGIC *mg = NULL;

    PERL_ARGS_ASSERT_SV_ADD_BACKREF;

    /* find slot to store array or singleton backref */

    if (SvTYPE(tsv) == SVt_PVHV) {
	svp = (SV**)Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
    } else {
        if (SvMAGICAL(tsv))
            mg = mg_find(tsv, PERL_MAGIC_backref);
	if (!mg)
            mg = sv_magicext(tsv, NULL, PERL_MAGIC_backref, &PL_vtbl_backref, NULL, 0);
	svp = &(mg->mg_obj);
    }

    /* create or retrieve the array */

    if (   (!*svp && SvTYPE(sv) == SVt_PVAV)
	|| (*svp && SvTYPE(*svp) != SVt_PVAV)
    ) {
	/* create array */
	if (mg)
	    mg->mg_flags |= MGf_REFCOUNTED;
	av = newAV();
	AvREAL_off(av);
	SvREFCNT_inc_simple_void_NN(av);
	/* av now has a refcnt of 2; see discussion above */
	av_extend(av, *svp ? 2 : 1);
	if (*svp) {
	    /* move single existing backref to the array */
	    AvARRAY(av)[++AvFILLp(av)] = *svp; /* av_push() */
	}
	*svp = (SV*)av;
    }
    else {
	av = MUTABLE_AV(*svp);
        if (!av) {
            /* optimisation: store single backref directly in HvAUX or mg_obj */
            *svp = sv;
            return;
        }
        assert(SvTYPE(av) == SVt_PVAV);
        if (AvFILLp(av) >= AvMAX(av)) {
            av_extend(av, AvFILLp(av)+1);
        }
    }
    /* push new backref */
    AvARRAY(av)[++AvFILLp(av)] = sv; /* av_push() */
}

/* delete a back-reference to ourselves from the backref magic associated
 * with the SV we point to.
 */

void
Perl_sv_del_backref(pTHX_ SV *const tsv, SV *const sv)
{
    SV **svp = NULL;

    PERL_ARGS_ASSERT_SV_DEL_BACKREF;

    if (SvTYPE(tsv) == SVt_PVHV) {
	if (SvOOK(tsv))
	    svp = (SV**)Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
    }
    else if (SvIS_FREED(tsv) && PL_phase == PERL_PHASE_DESTRUCT) {
	/* It's possible for the the last (strong) reference to tsv to have
	   become freed *before* the last thing holding a weak reference.
	   If both survive longer than the backreferences array, then when
	   the referent's reference count drops to 0 and it is freed, it's
	   not able to chase the backreferences, so they aren't NULLed.

	   For example, a CV holds a weak reference to its stash. If both the
	   CV and the stash survive longer than the backreferences array,
	   and the CV gets picked for the SvBREAK() treatment first,
	   *and* it turns out that the stash is only being kept alive because
	   of an our variable in the pad of the CV, then midway during CV
	   destruction the stash gets freed, but CvSTASH() isn't set to NULL.
	   It ends up pointing to the freed HV. Hence it's chased in here, and
	   if this block wasn't here, it would hit the !svp panic just below.

	   I don't believe that "better" destruction ordering is going to help
	   here - during global destruction there's always going to be the
	   chance that something goes out of order. We've tried to make it
	   foolproof before, and it only resulted in evolutionary pressure on
	   fools. Which made us look foolish for our hubris. :-(
	*/
	return;
    }
    else {
	MAGIC *const mg
	    = SvMAGICAL(tsv) ? mg_find(tsv, PERL_MAGIC_backref) : NULL;
	svp =  mg ? &(mg->mg_obj) : NULL;
    }

    if (!svp)
	Perl_croak(aTHX_ "panic: del_backref, svp=0");
    if (!*svp) {
	/* It's possible that sv is being freed recursively part way through the
	   freeing of tsv. If this happens, the backreferences array of tsv has
	   already been freed, and so svp will be NULL. If this is the case,
	   we should not panic. Instead, nothing needs doing, so return.  */
	if (PL_phase == PERL_PHASE_DESTRUCT && SvREFCNT(tsv) == 0)
	    return;
	Perl_croak(aTHX_ "panic: del_backref, *svp=%p phase=%s refcnt=%" UVuf,
		   (void*)*svp, PL_phase_names[PL_phase], (UV)SvREFCNT(tsv));
    }

    if (SvTYPE(*svp) == SVt_PVAV) {
#ifdef DEBUGGING
	int count = 1;
#endif
	AV * const av = (AV*)*svp;
	SSize_t fill;
	assert(!SvIS_FREED(av));
	fill = AvFILLp(av);
	assert(fill > -1);
	svp = AvARRAY(av);
	/* for an SV with N weak references to it, if all those
	 * weak refs are deleted, then sv_del_backref will be called
	 * N times and O(N^2) compares will be done within the backref
	 * array. To ameliorate this potential slowness, we:
	 * 1) make sure this code is as tight as possible;
	 * 2) when looking for SV, look for it at both the head and tail of the
	 *    array first before searching the rest, since some create/destroy
	 *    patterns will cause the backrefs to be freed in order.
	 */
	if (*svp == sv) {
	    AvARRAY(av)++;
	    AvMAX(av)--;
	}
	else {
	    SV **p = &svp[fill];
	    SV *const topsv = *p;
	    if (topsv != sv) {
#ifdef DEBUGGING
		count = 0;
#endif
		while (--p > svp) {
		    if (*p == sv) {
			/* We weren't the last entry.
			   An unordered list has this property that you
			   can take the last element off the end to fill
			   the hole, and it's still an unordered list :-)
			*/
			*p = topsv;
#ifdef DEBUGGING
			count++;
#else
			break; /* should only be one */
#endif
		    }
		}
	    }
	}
	assert(count ==1);
	AvFILLp(av) = fill-1;
    }
    else if (SvIS_FREED(*svp) && PL_phase == PERL_PHASE_DESTRUCT) {
	/* freed AV; skip */
    }
    else {
	/* optimisation: only a single backref, stored directly */
	if (*svp != sv)
	    Perl_croak(aTHX_ "panic: del_backref, *svp=%p, sv=%p",
                       (void*)*svp, (void*)sv);
	*svp = NULL;
    }

}

void
Perl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av)
{
    SV **svp;
    SV **last;
    bool is_array;

    PERL_ARGS_ASSERT_SV_KILL_BACKREFS;

    if (!av)
	return;

    /* after multiple passes through Perl_sv_clean_all() for a thingy
     * that has badly leaked, the backref array may have gotten freed,
     * since we only protect it against 1 round of cleanup */
    if (SvIS_FREED(av)) {
	if (PL_in_clean_all) /* All is fair */
	    return;
	Perl_croak(aTHX_
		   "panic: magic_killbackrefs (freed backref AV/SV)");
    }


    is_array = (SvTYPE(av) == SVt_PVAV);
    if (is_array) {
	assert(!SvIS_FREED(av));
	svp = AvARRAY(av);
	if (svp)
	    last = svp + AvFILLp(av);
    }
    else {
	/* optimisation: only a single backref, stored directly */
	svp = (SV**)&av;
	last = svp;
    }

    if (svp) {
	while (svp <= last) {
	    if (*svp) {
		SV *const referrer = *svp;
		if (SvWEAKREF(referrer)) {
		    /* XXX Should we check that it hasn't changed? */
		    assert(SvROK(referrer));
		    SvRV_set(referrer, 0);
		    SvOK_off(referrer);
		    SvWEAKREF_off(referrer);
		    SvSETMAGIC(referrer);
		} else if (SvTYPE(referrer) == SVt_PVGV ||
			   SvTYPE(referrer) == SVt_PVLV) {
		    assert(SvTYPE(sv) == SVt_PVHV); /* stash backref */
		    /* You lookin' at me?  */
		    assert(GvSTASH(referrer));
		    assert(GvSTASH(referrer) == (const HV *)sv);
		    GvSTASH(referrer) = 0;
		} else if (SvTYPE(referrer) == SVt_PVCV ||
			   SvTYPE(referrer) == SVt_PVFM) {
		    if (SvTYPE(sv) == SVt_PVHV) { /* stash backref */
			/* You lookin' at me?  */
			assert(CvSTASH(referrer));
			assert(CvSTASH(referrer) == (const HV *)sv);
			SvANY(MUTABLE_CV(referrer))->xcv_stash = 0;
		    }
		    else {
			assert(SvTYPE(sv) == SVt_PVGV);
			/* You lookin' at me?  */
			assert(CvGV(referrer));
			assert(CvGV(referrer) == (const GV *)sv);
			anonymise_cv_maybe(MUTABLE_GV(sv),
						MUTABLE_CV(referrer));
		    }

		} else {
		    Perl_croak(aTHX_
			       "panic: magic_killbackrefs (flags=%"UVxf")",
			       (UV)SvFLAGS(referrer));
		}

		if (is_array)
		    *svp = NULL;
	    }
	    svp++;
	}
    }
    if (is_array) {
	AvFILLp(av) = -1;
	SvREFCNT_dec_NN(av); /* remove extra count added by sv_add_backref() */
    }
    return;
}

/*
=for apidoc sv_insert

Inserts a string at the specified offset/length within the SV.  Similar to
the Perl C<substr()> function.  Handles get magic.

=for apidoc sv_insert_flags

Same as C<sv_insert>, but the extra C<flags> are passed to the
C<SvPV_force_flags> that applies to C<bigstr>.

=cut
*/

void
Perl_sv_insert_flags(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen, const U32 flags)
{
    char *big;
    char *mid;
    char *midend;
    char *bigend;
    SSize_t i;		/* better be sizeof(STRLEN) or bad things happen */
    STRLEN curlen;

    PERL_ARGS_ASSERT_SV_INSERT_FLAGS;

    SvPV_force_flags(bigstr, curlen, flags);
    (void)SvPOK_only_UTF8(bigstr);
    if (offset + len > curlen) {
	SvGROW(bigstr, offset+len+1);
	Zero(SvPVX(bigstr)+curlen, offset+len-curlen, char);
	SvCUR_set(bigstr, offset+len);
    }

    SvTAINT(bigstr);
    i = littlelen - len;
    if (i > 0) {			/* string might grow */
	big = SvGROW(bigstr, SvCUR(bigstr) + i + 1);
	mid = big + offset + len;
	midend = bigend = big + SvCUR(bigstr);
	bigend += i;
	*bigend = '\0';
	while (midend > mid)		/* shove everything down */
	    *--bigend = *--midend;
	Move(little,big+offset,littlelen,char);
	SvCUR_set(bigstr, SvCUR(bigstr) + i);
	SvSETMAGIC(bigstr);
	return;
    }
    else if (i == 0) {
	Move(little,SvPVX(bigstr)+offset,len,char);
	SvSETMAGIC(bigstr);
	return;
    }

    big = SvPVX(bigstr);
    mid = big + offset;
    midend = mid + len;
    bigend = big + SvCUR(bigstr);

    if (midend > bigend)
	Perl_croak(aTHX_ "panic: sv_insert, midend=%p, bigend=%p",
		   midend, bigend);

    if (mid - big > bigend - midend) {	/* faster to shorten from end */
	if (littlelen) {
	    Move(little, mid, littlelen,char);
	    mid += littlelen;
	}
	i = bigend - midend;
	if (i > 0) {
	    Move(midend, mid, i,char);
	    mid += i;
	}
	*mid = '\0';
	SvCUR_set(bigstr, mid - big);
    }
    else if ((i = mid - big)) {	/* faster from front */
	midend -= littlelen;
	mid = midend;
	Move(big, midend - i, i, char);
	sv_chop(bigstr,midend-i);
	if (littlelen)
	    Move(little, mid, littlelen,char);
    }
    else if (littlelen) {
	midend -= littlelen;
	sv_chop(bigstr,midend);
	Move(little,midend,littlelen,char);
    }
    else {
	sv_chop(bigstr,midend);
    }
    SvSETMAGIC(bigstr);
}

/*
=for apidoc sv_replace

Make the first argument a copy of the second, then delete the original.
The target SV physically takes over ownership of the body of the source SV
and inherits its flags; however, the target keeps any magic it owns,
and any magic in the source is discarded.
Note that this is a rather specialist SV copying operation; most of the
time you'll want to use C<sv_setsv> or one of its many macro front-ends.

=cut
*/

void
Perl_sv_replace(pTHX_ SV *const sv, SV *const nsv)
{
    const U32 refcnt = SvREFCNT(sv);

    PERL_ARGS_ASSERT_SV_REPLACE;

    SV_CHECK_THINKFIRST_COW_DROP(sv);
    if (SvREFCNT(nsv) != 1) {
	Perl_croak(aTHX_ "panic: reference miscount on nsv in sv_replace()"
		   " (%" UVuf " != 1)", (UV) SvREFCNT(nsv));
    }
    if (SvMAGICAL(sv)) {
	if (SvMAGICAL(nsv))
	    mg_free(nsv);
	else
	    sv_upgrade(nsv, SVt_PVMG);
	SvMAGIC_set(nsv, SvMAGIC(sv));
	SvFLAGS(nsv) |= SvMAGICAL(sv);
	SvMAGICAL_off(sv);
	SvMAGIC_set(sv, NULL);
    }
    SvREFCNT(sv) = 0;
    sv_clear(sv);
    assert(!SvREFCNT(sv));
#ifdef DEBUG_LEAKING_SCALARS
    sv->sv_flags  = nsv->sv_flags;
    sv->sv_any    = nsv->sv_any;
    sv->sv_refcnt = nsv->sv_refcnt;
    sv->sv_u      = nsv->sv_u;
#else
    StructCopy(nsv,sv,SV);
#endif
    if(SvTYPE(sv) == SVt_IV) {
	SET_SVANY_FOR_BODYLESS_IV(sv);
    }
	

    SvREFCNT(sv) = refcnt;
    SvFLAGS(nsv) |= SVTYPEMASK;		/* Mark as freed */
    SvREFCNT(nsv) = 0;
    del_SV(nsv);
}

/* We're about to free a GV which has a CV that refers back to us.
 * If that CV will outlive us, make it anonymous (i.e. fix up its CvGV
 * field) */

STATIC void
S_anonymise_cv_maybe(pTHX_ GV *gv, CV* cv)
{
    SV *gvname;
    GV *anongv;

    PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE;

    /* be assertive! */
    assert(SvREFCNT(gv) == 0);
    assert(isGV(gv) && isGV_with_GP(gv));
    assert(GvGP(gv));
    assert(!CvANON(cv));
    assert(CvGV(cv) == gv);
    assert(!CvNAMED(cv));

    /* will the CV shortly be freed by gp_free() ? */
    if (GvCV(gv) == cv && GvGP(gv)->gp_refcnt < 2 && SvREFCNT(cv) < 2) {
	SvANY(cv)->xcv_gv_u.xcv_gv = NULL;
	return;
    }

    /* if not, anonymise: */
    gvname = (GvSTASH(gv) && HvNAME(GvSTASH(gv)) && HvENAME(GvSTASH(gv)))
                    ? newSVhek(HvENAME_HEK(GvSTASH(gv)))
                    : newSVpvn_flags( "__ANON__", 8, 0 );
    sv_catpvs(gvname, "::__ANON__");
    anongv = gv_fetchsv(gvname, GV_ADDMULTI, SVt_PVCV);
    SvREFCNT_dec_NN(gvname);

    CvANON_on(cv);
    CvCVGV_RC_on(cv);
    SvANY(cv)->xcv_gv_u.xcv_gv = MUTABLE_GV(SvREFCNT_inc(anongv));
}


/*
=for apidoc sv_clear

Clear an SV: call any destructors, free up any memory used by the body,
and free the body itself.  The SV's head is I<not> freed, although
its type is set to all 1's so that it won't inadvertently be assumed
to be live during global destruction etc.
This function should only be called when C<REFCNT> is zero.  Most of the time
you'll want to call C<sv_free()> (or its macro wrapper C<SvREFCNT_dec>)
instead.

=cut
*/

void
Perl_sv_clear(pTHX_ SV *const orig_sv)
{
    dVAR;
    HV *stash;
    U32 type;
    const struct body_details *sv_type_details;
    SV* iter_sv = NULL;
    SV* next_sv = NULL;
    SV *sv = orig_sv;
    STRLEN hash_index = 0; /* initialise to make Coverity et al happy.
                              Not strictly necessary */

    PERL_ARGS_ASSERT_SV_CLEAR;

    /* within this loop, sv is the SV currently being freed, and
     * iter_sv is the most recent AV or whatever that's being iterated
     * over to provide more SVs */

    while (sv) {

	type = SvTYPE(sv);

	assert(SvREFCNT(sv) == 0);
	assert(SvTYPE(sv) != (svtype)SVTYPEMASK);

	if (type <= SVt_IV) {
	    /* See the comment in sv.h about the collusion between this
	     * early return and the overloading of the NULL slots in the
	     * size table.  */
	    if (SvROK(sv))
		goto free_rv;
	    SvFLAGS(sv) &= SVf_BREAK;
	    SvFLAGS(sv) |= SVTYPEMASK;
	    goto free_head;
	}

	/* objs are always >= MG, but pad names use the SVs_OBJECT flag
	   for another purpose  */
	assert(!SvOBJECT(sv) || type >= SVt_PVMG);

	if (type >= SVt_PVMG) {
	    if (SvOBJECT(sv)) {
		if (!curse(sv, 1)) goto get_next_sv;
		type = SvTYPE(sv); /* destructor may have changed it */
	    }
	    /* Free back-references before magic, in case the magic calls
	     * Perl code that has weak references to sv. */
	    if (type == SVt_PVHV) {
		Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
		if (SvMAGIC(sv))
		    mg_free(sv);
	    }
	    else if (SvMAGIC(sv)) {
		/* Free back-references before other types of magic. */
		sv_unmagic(sv, PERL_MAGIC_backref);
		mg_free(sv);
	    }
	    SvMAGICAL_off(sv);
	}
	switch (type) {
	    /* case SVt_INVLIST: */
	case SVt_PVIO:
	    if (IoIFP(sv) &&
		IoIFP(sv) != PerlIO_stdin() &&
		IoIFP(sv) != PerlIO_stdout() &&
		IoIFP(sv) != PerlIO_stderr() &&
		!(IoFLAGS(sv) & IOf_FAKE_DIRP))
	    {
		io_close(MUTABLE_IO(sv), NULL, FALSE,
			 (IoTYPE(sv) == IoTYPE_WRONLY ||
			  IoTYPE(sv) == IoTYPE_RDWR   ||
			  IoTYPE(sv) == IoTYPE_APPEND));
	    }
	    if (IoDIRP(sv) && !(IoFLAGS(sv) & IOf_FAKE_DIRP))
		PerlDir_close(IoDIRP(sv));
	    IoDIRP(sv) = (DIR*)NULL;
	    Safefree(IoTOP_NAME(sv));
	    Safefree(IoFMT_NAME(sv));
	    Safefree(IoBOTTOM_NAME(sv));
	    if ((const GV *)sv == PL_statgv)
		PL_statgv = NULL;
	    goto freescalar;
	case SVt_REGEXP:
	    /* FIXME for plugins */
	  freeregexp:
	    pregfree2((REGEXP*) sv);
	    goto freescalar;
	case SVt_PVCV:
	case SVt_PVFM:
	    cv_undef(MUTABLE_CV(sv));
	    /* If we're in a stash, we don't own a reference to it.
	     * However it does have a back reference to us, which needs to
	     * be cleared.  */
	    if ((stash = CvSTASH(sv)))
		sv_del_backref(MUTABLE_SV(stash), sv);
	    goto freescalar;
	case SVt_PVHV:
	    if (PL_last_swash_hv == (const HV *)sv) {
		PL_last_swash_hv = NULL;
	    }
	    if (HvTOTALKEYS((HV*)sv) > 0) {
		const HEK *hek;
		/* this statement should match the one at the beginning of
		 * hv_undef_flags() */
		if (   PL_phase != PERL_PHASE_DESTRUCT
		    && (hek = HvNAME_HEK((HV*)sv)))
		{
		    if (PL_stashcache) {
			DEBUG_o(Perl_deb(aTHX_
			    "sv_clear clearing PL_stashcache for '%"HEKf
			    "'\n",
			     HEKfARG(hek)));
			(void)hv_deletehek(PL_stashcache,
                                           hek, G_DISCARD);
                    }
		    hv_name_set((HV*)sv, NULL, 0, 0);
		}

		/* save old iter_sv in unused SvSTASH field */
		assert(!SvOBJECT(sv));
		SvSTASH(sv) = (HV*)iter_sv;
		iter_sv = sv;

		/* save old hash_index in unused SvMAGIC field */
		assert(!SvMAGICAL(sv));
		assert(!SvMAGIC(sv));
		((XPVMG*) SvANY(sv))->xmg_u.xmg_hash_index = hash_index;
		hash_index = 0;

		next_sv = Perl_hfree_next_entry(aTHX_ (HV*)sv, &hash_index);
		goto get_next_sv; /* process this new sv */
	    }
	    /* free empty hash */
	    Perl_hv_undef_flags(aTHX_ MUTABLE_HV(sv), HV_NAME_SETALL);
	    assert(!HvARRAY((HV*)sv));
	    break;
	case SVt_PVAV:
	    {
		AV* av = MUTABLE_AV(sv);
		if (PL_comppad == av) {
		    PL_comppad = NULL;
		    PL_curpad = NULL;
		}
		if (AvREAL(av) && AvFILLp(av) > -1) {
		    next_sv = AvARRAY(av)[AvFILLp(av)--];
		    /* save old iter_sv in top-most slot of AV,
		     * and pray that it doesn't get wiped in the meantime */
		    AvARRAY(av)[AvMAX(av)] = iter_sv;
		    iter_sv = sv;
		    goto get_next_sv; /* process this new sv */
		}
		Safefree(AvALLOC(av));
	    }

	    break;
	case SVt_PVLV:
	    if (LvTYPE(sv) == 'T') { /* for tie: return HE to pool */
		SvREFCNT_dec(HeKEY_sv((HE*)LvTARG(sv)));
		HeNEXT((HE*)LvTARG(sv)) = PL_hv_fetch_ent_mh;
		PL_hv_fetch_ent_mh = (HE*)LvTARG(sv);
	    }
	    else if (LvTYPE(sv) != 't') /* unless tie: unrefcnted fake SV**  */
		SvREFCNT_dec(LvTARG(sv));
	    if (isREGEXP(sv)) goto freeregexp;
            /* FALLTHROUGH */
	case SVt_PVGV:
	    if (isGV_with_GP(sv)) {
		if(GvCVu((const GV *)sv) && (stash = GvSTASH(MUTABLE_GV(sv)))
		   && HvENAME_get(stash))
		    mro_method_changed_in(stash);
		gp_free(MUTABLE_GV(sv));
		if (GvNAME_HEK(sv))
		    unshare_hek(GvNAME_HEK(sv));
		/* If we're in a stash, we don't own a reference to it.
		 * However it does have a back reference to us, which
		 * needs to be cleared.  */
		if (!SvVALID(sv) && (stash = GvSTASH(sv)))
			sv_del_backref(MUTABLE_SV(stash), sv);
	    }
	    /* FIXME. There are probably more unreferenced pointers to SVs
	     * in the interpreter struct that we should check and tidy in
	     * a similar fashion to this:  */
	    /* See also S_sv_unglob, which does the same thing. */
	    if ((const GV *)sv == PL_last_in_gv)
		PL_last_in_gv = NULL;
	    else if ((const GV *)sv == PL_statgv)
		PL_statgv = NULL;
            else if ((const GV *)sv == PL_stderrgv)
                PL_stderrgv = NULL;
            /* FALLTHROUGH */
	case SVt_PVMG:
	case SVt_PVNV:
	case SVt_PVIV:
	case SVt_INVLIST:
	case SVt_PV:
	  freescalar:
	    /* Don't bother with SvOOK_off(sv); as we're only going to
	     * free it.  */
	    if (SvOOK(sv)) {
		STRLEN offset;
		SvOOK_offset(sv, offset);
		SvPV_set(sv, SvPVX_mutable(sv) - offset);
		/* Don't even bother with turning off the OOK flag.  */
	    }
	    if (SvROK(sv)) {
	    free_rv:
		{
		    SV * const target = SvRV(sv);
		    if (SvWEAKREF(sv))
			sv_del_backref(target, sv);
		    else
			next_sv = target;
		}
	    }
#ifdef PERL_ANY_COW
	    else if (SvPVX_const(sv)
		     && !(SvTYPE(sv) == SVt_PVIO
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP)))
	    {
		if (SvIsCOW(sv)) {
		    if (DEBUG_C_TEST) {
			PerlIO_printf(Perl_debug_log, "Copy on write: clear\n");
			sv_dump(sv);
		    }
		    if (SvLEN(sv)) {
			if (CowREFCNT(sv)) {
			    sv_buf_to_rw(sv);
			    CowREFCNT(sv)--;
			    sv_buf_to_ro(sv);
			    SvLEN_set(sv, 0);
			}
		    } else {
			unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
		    }

		}
		if (SvLEN(sv)) {
		    Safefree(SvPVX_mutable(sv));
		}
	    }
#else
	    else if (SvPVX_const(sv) && SvLEN(sv)
		     && !(SvTYPE(sv) == SVt_PVIO
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP)))
		Safefree(SvPVX_mutable(sv));
	    else if (SvPVX_const(sv) && SvIsCOW(sv)) {
		unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
	    }
#endif
	    break;
	case SVt_NV:
	    break;
	}

      free_body:

	SvFLAGS(sv) &= SVf_BREAK;
	SvFLAGS(sv) |= SVTYPEMASK;

	sv_type_details = bodies_by_type + type;
	if (sv_type_details->arena) {
	    del_body(((char *)SvANY(sv) + sv_type_details->offset),
		     &PL_body_roots[type]);
	}
	else if (sv_type_details->body_size) {
	    safefree(SvANY(sv));
	}

      free_head:
	/* caller is responsible for freeing the head of the original sv */
	if (sv != orig_sv && !SvREFCNT(sv))
	    del_SV(sv);

	/* grab and free next sv, if any */
      get_next_sv:
	while (1) {
	    sv = NULL;
	    if (next_sv) {
		sv = next_sv;
		next_sv = NULL;
	    }
	    else if (!iter_sv) {
		break;
	    } else if (SvTYPE(iter_sv) == SVt_PVAV) {
		AV *const av = (AV*)iter_sv;
		if (AvFILLp(av) > -1) {
		    sv = AvARRAY(av)[AvFILLp(av)--];
		}
		else { /* no more elements of current AV to free */
		    sv = iter_sv;
		    type = SvTYPE(sv);
		    /* restore previous value, squirrelled away */
		    iter_sv = AvARRAY(av)[AvMAX(av)];
		    Safefree(AvALLOC(av));
		    goto free_body;
		}
	    } else if (SvTYPE(iter_sv) == SVt_PVHV) {
		sv = Perl_hfree_next_entry(aTHX_ (HV*)iter_sv, &hash_index);
		if (!sv && !HvTOTALKEYS((HV *)iter_sv)) {
		    /* no more elements of current HV to free */
		    sv = iter_sv;
		    type = SvTYPE(sv);
		    /* Restore previous values of iter_sv and hash_index,
		     * squirrelled away */
		    assert(!SvOBJECT(sv));
		    iter_sv = (SV*)SvSTASH(sv);
		    assert(!SvMAGICAL(sv));
		    hash_index = ((XPVMG*) SvANY(sv))->xmg_u.xmg_hash_index;
#ifdef DEBUGGING
		    /* perl -DA does not like rubbish in SvMAGIC. */
		    SvMAGIC_set(sv, 0);
#endif

		    /* free any remaining detritus from the hash struct */
		    Perl_hv_undef_flags(aTHX_ MUTABLE_HV(sv), HV_NAME_SETALL);
		    assert(!HvARRAY((HV*)sv));
		    goto free_body;
		}
	    }

	    /* unrolled SvREFCNT_dec and sv_free2 follows: */

	    if (!sv)
		continue;
	    if (!SvREFCNT(sv)) {
		sv_free(sv);
		continue;
	    }
	    if (--(SvREFCNT(sv)))
		continue;
#ifdef DEBUGGING
	    if (SvTEMP(sv)) {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING),
			 "Attempt to free temp prematurely: SV 0x%"UVxf
			 pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
		continue;
	    }
#endif
	    if (SvIMMORTAL(sv)) {
		/* make sure SvREFCNT(sv)==0 happens very seldom */
		SvREFCNT(sv) = SvREFCNT_IMMORTAL;
		continue;
	    }
	    break;
	} /* while 1 */

    } /* while sv */
}

/* This routine curses the sv itself, not the object referenced by sv. So
   sv does not have to be ROK. */

static bool
S_curse(pTHX_ SV * const sv, const bool check_refcnt) {
    PERL_ARGS_ASSERT_CURSE;
    assert(SvOBJECT(sv));

    if (PL_defstash &&	/* Still have a symbol table? */
	SvDESTROYABLE(sv))
    {
	dSP;
	HV* stash;
	do {
	  stash = SvSTASH(sv);
	  assert(SvTYPE(stash) == SVt_PVHV);
	  if (HvNAME(stash)) {
	    CV* destructor = NULL;
            struct mro_meta *meta;

	    assert (SvOOK(stash));

            DEBUG_o( Perl_deb(aTHX_ "Looking for DESTROY method for %s\n",
                         HvNAME(stash)) );

            /* don't make this an initialization above the assert, since it needs
               an AUX structure */
            meta = HvMROMETA(stash);
            if (meta->destroy_gen && meta->destroy_gen == PL_sub_generation) {
                destructor = meta->destroy;
                DEBUG_o( Perl_deb(aTHX_ "Using cached DESTROY method %p for %s\n",
                             (void *)destructor, HvNAME(stash)) );
            }
            else {
                bool autoload = FALSE;
		GV *gv =
                    gv_fetchmeth_pvn(stash, S_destroy, S_destroy_len, -1, 0);
		if (gv)
                    destructor = GvCV(gv);
                if (!destructor) {
                    gv = gv_autoload_pvn(stash, S_destroy, S_destroy_len,
                                         GV_AUTOLOAD_ISMETHOD);
                    if (gv)
                        destructor = GvCV(gv);
                    if (destructor)
                        autoload = TRUE;
                }
                /* we don't cache AUTOLOAD for DESTROY, since this code
                   would then need to set $__PACKAGE__::AUTOLOAD, or the
                   equivalent for XS AUTOLOADs */
                if (!autoload) {
                    meta->destroy_gen = PL_sub_generation;
                    meta->destroy = destructor;

                    DEBUG_o( Perl_deb(aTHX_ "Set cached DESTROY method %p for %s\n",
                                      (void *)destructor, HvNAME(stash)) );
                }
                else {
                    DEBUG_o( Perl_deb(aTHX_ "Not caching AUTOLOAD for DESTROY method for %s\n",
                                      HvNAME(stash)) );
                }
	    }
	    assert(!destructor || SvTYPE(destructor) == SVt_PVCV);
	    if (destructor
		/* A constant subroutine can have no side effects, so
		   don't bother calling it.  */
		&& !CvCONST(destructor)
		/* Don't bother calling an empty destructor or one that
		   returns immediately. */
		&& (CvISXSUB(destructor)
		|| (CvSTART(destructor)
		    && (CvSTART(destructor)->op_next->op_type
					!= OP_LEAVESUB)
		    && (CvSTART(destructor)->op_next->op_type
					!= OP_PUSHMARK
			|| CvSTART(destructor)->op_next->op_next->op_type
					!= OP_RETURN
		       )
		   ))
	       )
	    {
		SV* const tmpref = newRV(sv);
		SvREADONLY_on(tmpref); /* DESTROY() could be naughty */
		ENTER;
		PUSHSTACKi(PERLSI_DESTROY);
		EXTEND(SP, 2);
		PUSHMARK(SP);
		PUSHs(tmpref);
		PUTBACK;
		call_sv(MUTABLE_SV(destructor),
			    G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
		POPSTACK;
		SPAGAIN;
		LEAVE;
		if(SvREFCNT(tmpref) < 2) {
		    /* tmpref is not kept alive! */
		    SvREFCNT(sv)--;
		    SvRV_set(tmpref, NULL);
		    SvROK_off(tmpref);
		}
		SvREFCNT_dec_NN(tmpref);
	    }
	  }
	} while (SvOBJECT(sv) && SvSTASH(sv) != stash);


	if (check_refcnt && SvREFCNT(sv)) {
	    if (PL_in_clean_objs)
		Perl_croak(aTHX_
		  "DESTROY created new reference to dead object '%"HEKf"'",
		   HEKfARG(HvNAME_HEK(stash)));
	    /* DESTROY gave object new lease on life */
	    return FALSE;
	}
    }

    if (SvOBJECT(sv)) {
	HV * const stash = SvSTASH(sv);
	/* Curse before freeing the stash, as freeing the stash could cause
	   a recursive call into S_curse. */
	SvOBJECT_off(sv);	/* Curse the object. */
	SvSTASH_set(sv,0);	/* SvREFCNT_dec may try to read this */
	SvREFCNT_dec(stash); /* possibly of changed persuasion */
    }
    return TRUE;
}

/*
=for apidoc sv_newref

Increment an SV's reference count.  Use the C<SvREFCNT_inc()> wrapper
instead.

=cut
*/

SV *
Perl_sv_newref(pTHX_ SV *const sv)
{
    PERL_UNUSED_CONTEXT;
    if (sv)
	(SvREFCNT(sv))++;
    return sv;
}

/*
=for apidoc sv_free

Decrement an SV's reference count, and if it drops to zero, call
C<sv_clear> to invoke destructors and free up any memory used by
the body; finally, deallocating the SV's head itself.
Normally called via a wrapper macro C<SvREFCNT_dec>.

=cut
*/

void
Perl_sv_free(pTHX_ SV *const sv)
{
    SvREFCNT_dec(sv);
}


/* Private helper function for SvREFCNT_dec().
 * Called with rc set to original SvREFCNT(sv), where rc == 0 or 1 */

void
Perl_sv_free2(pTHX_ SV *const sv, const U32 rc)
{
    dVAR;

    PERL_ARGS_ASSERT_SV_FREE2;

    if (LIKELY( rc == 1 )) {
        /* normal case */
        SvREFCNT(sv) = 0;

#ifdef DEBUGGING
        if (SvTEMP(sv)) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING),
                             "Attempt to free temp prematurely: SV 0x%"UVxf
                             pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
            return;
        }
#endif
        if (SvIMMORTAL(sv)) {
            /* make sure SvREFCNT(sv)==0 happens very seldom */
            SvREFCNT(sv) = SvREFCNT_IMMORTAL;
            return;
        }
        sv_clear(sv);
        if (! SvREFCNT(sv)) /* may have have been resurrected */
            del_SV(sv);
        return;
    }

    /* handle exceptional cases */

    assert(rc == 0);

    if (SvFLAGS(sv) & SVf_BREAK)
        /* this SV's refcnt has been artificially decremented to
         * trigger cleanup */
        return;
    if (PL_in_clean_all) /* All is fair */
        return;
    if (SvIMMORTAL(sv)) {
        /* make sure SvREFCNT(sv)==0 happens very seldom */
        SvREFCNT(sv) = SvREFCNT_IMMORTAL;
        return;
    }
    if (ckWARN_d(WARN_INTERNAL)) {
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
        Perl_dump_sv_child(aTHX_ sv);
#else
    #ifdef DEBUG_LEAKING_SCALARS
        sv_dump(sv);
    #endif
#ifdef DEBUG_LEAKING_SCALARS_ABORT
        if (PL_warnhook == PERL_WARNHOOK_FATAL
            || ckDEAD(packWARN(WARN_INTERNAL))) {
            /* Don't let Perl_warner cause us to escape our fate:  */
            abort();
        }
#endif
        /* This may not return:  */
        Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                    "Attempt to free unreferenced scalar: SV 0x%"UVxf
                    pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
#endif
    }
#ifdef DEBUG_LEAKING_SCALARS_ABORT
    abort();
#endif

}


/*
=for apidoc sv_len

Returns the length of the string in the SV.  Handles magic and type
coercion and sets the UTF8 flag appropriately.  See also C<L</SvCUR>>, which
gives raw access to the C<xpv_cur> slot.

=cut
*/

STRLEN
Perl_sv_len(pTHX_ SV *const sv)
{
    STRLEN len;

    if (!sv)
	return 0;

    (void)SvPV_const(sv, len);
    return len;
}

/*
=for apidoc sv_len_utf8

Returns the number of characters in the string in an SV, counting wide
UTF-8 bytes as a single character.  Handles magic and type coercion.

=cut
*/

/*
 * The length is cached in PERL_MAGIC_utf8, in the mg_len field.  Also the
 * mg_ptr is used, by sv_pos_u2b() and sv_pos_b2u() - see the comments below.
 * (Note that the mg_len is not the length of the mg_ptr field.
 * This allows the cache to store the character length of the string without
 * needing to malloc() extra storage to attach to the mg_ptr.)
 *
 */

STRLEN
Perl_sv_len_utf8(pTHX_ SV *const sv)
{
    if (!sv)
	return 0;

    SvGETMAGIC(sv);
    return sv_len_utf8_nomg(sv);
}

STRLEN
Perl_sv_len_utf8_nomg(pTHX_ SV * const sv)
{
    STRLEN len;
    const U8 *s = (U8*)SvPV_nomg_const(sv, len);

    PERL_ARGS_ASSERT_SV_LEN_UTF8_NOMG;

    if (PL_utf8cache && SvUTF8(sv)) {
	    STRLEN ulen;
	    MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;

	    if (mg && (mg->mg_len != -1 || mg->mg_ptr)) {
		if (mg->mg_len != -1)
		    ulen = mg->mg_len;
		else {
		    /* We can use the offset cache for a headstart.
		       The longer value is stored in the first pair.  */
		    STRLEN *cache = (STRLEN *) mg->mg_ptr;

		    ulen = cache[0] + Perl_utf8_length(aTHX_ s + cache[1],
						       s + len);
		}
		
		if (PL_utf8cache < 0) {
		    const STRLEN real = Perl_utf8_length(aTHX_ s, s + len);
		    assert_uft8_cache_coherent("sv_len_utf8", ulen, real, sv);
		}
	    }
	    else {
		ulen = Perl_utf8_length(aTHX_ s, s + len);
		utf8_mg_len_cache_update(sv, &mg, ulen);
	    }
	    return ulen;
    }
    return SvUTF8(sv) ? Perl_utf8_length(aTHX_ s, s + len) : len;
}

/* Walk forwards to find the byte corresponding to the passed in UTF-8
   offset.  */
static STRLEN
S_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send,
		      STRLEN *const uoffset_p, bool *const at_end)
{
    const U8 *s = start;
    STRLEN uoffset = *uoffset_p;

    PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS;

    while (s < send && uoffset) {
	--uoffset;
	s += UTF8SKIP(s);
    }
    if (s == send) {
	*at_end = TRUE;
    }
    else if (s > send) {
	*at_end = TRUE;
	/* This is the existing behaviour. Possibly it should be a croak, as
	   it's actually a bounds error  */
	s = send;
    }
    *uoffset_p -= uoffset;
    return s - start;
}

/* Given the length of the string in both bytes and UTF-8 characters, decide
   whether to walk forwards or backwards to find the byte corresponding to
   the passed in UTF-8 offset.  */
static STRLEN
S_sv_pos_u2b_midway(const U8 *const start, const U8 *send,
		    STRLEN uoffset, const STRLEN uend)
{
    STRLEN backw = uend - uoffset;

    PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY;

    if (uoffset < 2 * backw) {
	/* The assumption is that going forwards is twice the speed of going
	   forward (that's where the 2 * backw comes from).
	   (The real figure of course depends on the UTF-8 data.)  */
	const U8 *s = start;

	while (s < send && uoffset--)
	    s += UTF8SKIP(s);
	assert (s <= send);
	if (s > send)
	    s = send;
	return s - start;
    }

    while (backw--) {
	send--;
	while (UTF8_IS_CONTINUATION(*send))
	    send--;
    }
    return send - start;
}

/* For the string representation of the given scalar, find the byte
   corresponding to the passed in UTF-8 offset.  uoffset0 and boffset0
   give another position in the string, *before* the sought offset, which
   (which is always true, as 0, 0 is a valid pair of positions), which should
   help reduce the amount of linear searching.
   If *mgp is non-NULL, it should point to the UTF-8 cache magic, which
   will be used to reduce the amount of linear searching. The cache will be
   created if necessary, and the found value offered to it for update.  */
static STRLEN
S_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start,
		    const U8 *const send, STRLEN uoffset,
		    STRLEN uoffset0, STRLEN boffset0)
{
    STRLEN boffset = 0; /* Actually always set, but let's keep gcc happy.  */
    bool found = FALSE;
    bool at_end = FALSE;

    PERL_ARGS_ASSERT_SV_POS_U2B_CACHED;

    assert (uoffset >= uoffset0);

    if (!uoffset)
	return 0;

    if (!SvREADONLY(sv) && !SvGMAGICAL(sv) && SvPOK(sv)
	&& PL_utf8cache
	&& (*mgp || (SvTYPE(sv) >= SVt_PVMG &&
		     (*mgp = mg_find(sv, PERL_MAGIC_utf8))))) {
	if ((*mgp)->mg_ptr) {
	    STRLEN *cache = (STRLEN *) (*mgp)->mg_ptr;
	    if (cache[0] == uoffset) {
		/* An exact match. */
		return cache[1];
	    }
	    if (cache[2] == uoffset) {
		/* An exact match. */
		return cache[3];
	    }

	    if (cache[0] < uoffset) {
		/* The cache already knows part of the way.   */
		if (cache[0] > uoffset0) {
		    /* The cache knows more than the passed in pair  */
		    uoffset0 = cache[0];
		    boffset0 = cache[1];
		}
		if ((*mgp)->mg_len != -1) {
		    /* And we know the end too.  */
		    boffset = boffset0
			+ sv_pos_u2b_midway(start + boffset0, send,
					      uoffset - uoffset0,
					      (*mgp)->mg_len - uoffset0);
		} else {
		    uoffset -= uoffset0;
		    boffset = boffset0
			+ sv_pos_u2b_forwards(start + boffset0,
					      send, &uoffset, &at_end);
		    uoffset += uoffset0;
		}
	    }
	    else if (cache[2] < uoffset) {
		/* We're between the two cache entries.  */
		if (cache[2] > uoffset0) {
		    /* and the cache knows more than the passed in pair  */
		    uoffset0 = cache[2];
		    boffset0 = cache[3];
		}

		boffset = boffset0
		    + sv_pos_u2b_midway(start + boffset0,
					  start + cache[1],
					  uoffset - uoffset0,
					  cache[0] - uoffset0);
	    } else {
		boffset = boffset0
		    + sv_pos_u2b_midway(start + boffset0,
					  start + cache[3],
					  uoffset - uoffset0,
					  cache[2] - uoffset0);
	    }
	    found = TRUE;
	}
	else if ((*mgp)->mg_len != -1) {
	    /* If we can take advantage of a passed in offset, do so.  */
	    /* In fact, offset0 is either 0, or less than offset, so don't
	       need to worry about the other possibility.  */
	    boffset = boffset0
		+ sv_pos_u2b_midway(start + boffset0, send,
				      uoffset - uoffset0,
				      (*mgp)->mg_len - uoffset0);
	    found = TRUE;
	}
    }

    if (!found || PL_utf8cache < 0) {
	STRLEN real_boffset;
	uoffset -= uoffset0;
	real_boffset = boffset0 + sv_pos_u2b_forwards(start + boffset0,
						      send, &uoffset, &at_end);
	uoffset += uoffset0;

	if (found && PL_utf8cache < 0)
	    assert_uft8_cache_coherent("sv_pos_u2b_cache", boffset,
				       real_boffset, sv);
	boffset = real_boffset;
    }

    if (PL_utf8cache && !SvGMAGICAL(sv) && SvPOK(sv)) {
	if (at_end)
	    utf8_mg_len_cache_update(sv, mgp, uoffset);
	else
	    utf8_mg_pos_cache_update(sv, mgp, boffset, uoffset, send - start);
    }
    return boffset;
}


/*
=for apidoc sv_pos_u2b_flags

Converts the offset from a count of UTF-8 chars from
the start of the string, to a count of the equivalent number of bytes; if
C<lenp> is non-zero, it does the same to C<lenp>, but this time starting from
C<offset>, rather than from the start
of the string.  Handles type coercion.
C<flags> is passed to C<SvPV_flags>, and usually should be
C<SV_GMAGIC|SV_CONST_RETURN> to handle magic.

=cut
*/

/*
 * sv_pos_u2b_flags() uses, like sv_pos_b2u(), the mg_ptr of the potential
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
 * byte offsets.  See also the comments of S_utf8_mg_pos_cache_update().
 *
 */

STRLEN
Perl_sv_pos_u2b_flags(pTHX_ SV *const sv, STRLEN uoffset, STRLEN *const lenp,
		      U32 flags)
{
    const U8 *start;
    STRLEN len;
    STRLEN boffset;

    PERL_ARGS_ASSERT_SV_POS_U2B_FLAGS;

    start = (U8*)SvPV_flags(sv, len, flags);
    if (len) {
	const U8 * const send = start + len;
	MAGIC *mg = NULL;
	boffset = sv_pos_u2b_cached(sv, &mg, start, send, uoffset, 0, 0);

	if (lenp
	    && *lenp /* don't bother doing work for 0, as its bytes equivalent
			is 0, and *lenp is already set to that.  */) {
	    /* Convert the relative offset to absolute.  */
	    const STRLEN uoffset2 = uoffset + *lenp;
	    const STRLEN boffset2
		= sv_pos_u2b_cached(sv, &mg, start, send, uoffset2,
				      uoffset, boffset) - boffset;

	    *lenp = boffset2;
	}
    } else {
	if (lenp)
	    *lenp = 0;
	boffset = 0;
    }

    return boffset;
}

/*
=for apidoc sv_pos_u2b

Converts the value pointed to by C<offsetp> from a count of UTF-8 chars from
the start of the string, to a count of the equivalent number of bytes; if
C<lenp> is non-zero, it does the same to C<lenp>, but this time starting from
the offset, rather than from the start of the string.  Handles magic and
type coercion.

Use C<sv_pos_u2b_flags> in preference, which correctly handles strings longer
than 2Gb.

=cut
*/

/*
 * sv_pos_u2b() uses, like sv_pos_b2u(), the mg_ptr of the potential
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
 * byte offsets.  See also the comments of S_utf8_mg_pos_cache_update().
 *
 */

/* This function is subject to size and sign problems */

void
Perl_sv_pos_u2b(pTHX_ SV *const sv, I32 *const offsetp, I32 *const lenp)
{
    PERL_ARGS_ASSERT_SV_POS_U2B;

    if (lenp) {
	STRLEN ulen = (STRLEN)*lenp;
	*offsetp = (I32)sv_pos_u2b_flags(sv, (STRLEN)*offsetp, &ulen,
					 SV_GMAGIC|SV_CONST_RETURN);
	*lenp = (I32)ulen;
    } else {
	*offsetp = (I32)sv_pos_u2b_flags(sv, (STRLEN)*offsetp, NULL,
					 SV_GMAGIC|SV_CONST_RETURN);
    }
}

static void
S_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp,
			   const STRLEN ulen)
{
    PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE;
    if (SvREADONLY(sv) || SvGMAGICAL(sv) || !SvPOK(sv))
	return;

    if (!*mgp && (SvTYPE(sv) < SVt_PVMG ||
		  !(*mgp = mg_find(sv, PERL_MAGIC_utf8)))) {
	*mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, &PL_vtbl_utf8, 0, 0);
    }
    assert(*mgp);

    (*mgp)->mg_len = ulen;
}

/* Create and update the UTF8 magic offset cache, with the proffered utf8/
   byte length pairing. The (byte) length of the total SV is passed in too,
   as blen, because for some (more esoteric) SVs, the call to SvPV_const()
   may not have updated SvCUR, so we can't rely on reading it directly.

   The proffered utf8/byte length pairing isn't used if the cache already has
   two pairs, and swapping either for the proffered pair would increase the
   RMS of the intervals between known byte offsets.

   The cache itself consists of 4 STRLEN values
   0: larger UTF-8 offset
   1: corresponding byte offset
   2: smaller UTF-8 offset
   3: corresponding byte offset

   Unused cache pairs have the value 0, 0.
   Keeping the cache "backwards" means that the invariant of
   cache[0] >= cache[2] is maintained even with empty slots, which means that
   the code that uses it doesn't need to worry if only 1 entry has actually
   been set to non-zero.  It also makes the "position beyond the end of the
   cache" logic much simpler, as the first slot is always the one to start
   from.   
*/
static void
S_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte,
                           const STRLEN utf8, const STRLEN blen)
{
    STRLEN *cache;

    PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE;

    if (SvREADONLY(sv))
	return;

    if (!*mgp && (SvTYPE(sv) < SVt_PVMG ||
		  !(*mgp = mg_find(sv, PERL_MAGIC_utf8)))) {
	*mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, (MGVTBL*)&PL_vtbl_utf8, 0,
			   0);
	(*mgp)->mg_len = -1;
    }
    assert(*mgp);

    if (!(cache = (STRLEN *)(*mgp)->mg_ptr)) {
	Newxz(cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
	(*mgp)->mg_ptr = (char *) cache;
    }
    assert(cache);

    if (PL_utf8cache < 0 && SvPOKp(sv)) {
	/* SvPOKp() because, if sv is a reference, then SvPVX() is actually
	   a pointer.  Note that we no longer cache utf8 offsets on refer-
	   ences, but this check is still a good idea, for robustness.  */
	const U8 *start = (const U8 *) SvPVX_const(sv);
	const STRLEN realutf8 = utf8_length(start, start + byte);

	assert_uft8_cache_coherent("utf8_mg_pos_cache_update", utf8, realutf8,
				   sv);
    }

    /* Cache is held with the later position first, to simplify the code
       that deals with unbounded ends.  */
       
    ASSERT_UTF8_CACHE(cache);
    if (cache[1] == 0) {
	/* Cache is totally empty  */
	cache[0] = utf8;
	cache[1] = byte;
    } else if (cache[3] == 0) {
	if (byte > cache[1]) {
	    /* New one is larger, so goes first.  */
	    cache[2] = cache[0];
	    cache[3] = cache[1];
	    cache[0] = utf8;
	    cache[1] = byte;
	} else {
	    cache[2] = utf8;
	    cache[3] = byte;
	}
    } else {
/* float casts necessary? XXX */
#define THREEWAY_SQUARE(a,b,c,d) \
	    ((float)((d) - (c))) * ((float)((d) - (c))) \
	    + ((float)((c) - (b))) * ((float)((c) - (b))) \
	       + ((float)((b) - (a))) * ((float)((b) - (a)))

	/* Cache has 2 slots in use, and we know three potential pairs.
	   Keep the two that give the lowest RMS distance. Do the
	   calculation in bytes simply because we always know the byte
	   length.  squareroot has the same ordering as the positive value,
	   so don't bother with the actual square root.  */
	if (byte > cache[1]) {
	    /* New position is after the existing pair of pairs.  */
	    const float keep_earlier
		= THREEWAY_SQUARE(0, cache[3], byte, blen);
	    const float keep_later
		= THREEWAY_SQUARE(0, cache[1], byte, blen);

	    if (keep_later < keep_earlier) {
                cache[2] = cache[0];
                cache[3] = cache[1];
	    }
            cache[0] = utf8;
            cache[1] = byte;
	}
	else {
	    const float keep_later = THREEWAY_SQUARE(0, byte, cache[1], blen);
	    float b, c, keep_earlier;
	    if (byte > cache[3]) {
		/* New position is between the existing pair of pairs.  */
		b = (float)cache[3];
		c = (float)byte;
	    } else {
		/* New position is before the existing pair of pairs.  */
		b = (float)byte;
		c = (float)cache[3];
	    }
	    keep_earlier = THREEWAY_SQUARE(0, b, c, blen);
	    if (byte > cache[3]) {
		if (keep_later < keep_earlier) {
		    cache[2] = utf8;
		    cache[3] = byte;
		}
		else {
		    cache[0] = utf8;
		    cache[1] = byte;
		}
	    }
	    else {
		if (! (keep_later < keep_earlier)) {
		    cache[0] = cache[2];
		    cache[1] = cache[3];
		}
		cache[2] = utf8;
		cache[3] = byte;
	    }
	}
    }
    ASSERT_UTF8_CACHE(cache);
}

/* We already know all of the way, now we may be able to walk back.  The same
   assumption is made as in S_sv_pos_u2b_midway(), namely that walking
   backward is half the speed of walking forward. */
static STRLEN
S_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target,
                    const U8 *end, STRLEN endu)
{
    const STRLEN forw = target - s;
    STRLEN backw = end - target;

    PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY;

    if (forw < 2 * backw) {
	return utf8_length(s, target);
    }

    while (end > target) {
	end--;
	while (UTF8_IS_CONTINUATION(*end)) {
	    end--;
	}
	endu--;
    }
    return endu;
}

/*
=for apidoc sv_pos_b2u_flags

Converts C<offset> from a count of bytes from the start of the string, to
a count of the equivalent number of UTF-8 chars.  Handles type coercion.
C<flags> is passed to C<SvPV_flags>, and usually should be
C<SV_GMAGIC|SV_CONST_RETURN> to handle magic.

=cut
*/

/*
 * sv_pos_b2u_flags() uses, like sv_pos_u2b_flags(), the mg_ptr of the
 * potential PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8
 * and byte offsets.
 *
 */
STRLEN
Perl_sv_pos_b2u_flags(pTHX_ SV *const sv, STRLEN const offset, U32 flags)
{
    const U8* s;
    STRLEN len = 0; /* Actually always set, but let's keep gcc happy.  */
    STRLEN blen;
    MAGIC* mg = NULL;
    const U8* send;
    bool found = FALSE;

    PERL_ARGS_ASSERT_SV_POS_B2U_FLAGS;

    s = (const U8*)SvPV_flags(sv, blen, flags);

    if (blen < offset)
	Perl_croak(aTHX_ "panic: sv_pos_b2u: bad byte offset, blen=%"UVuf
		   ", byte=%"UVuf, (UV)blen, (UV)offset);

    send = s + offset;

    if (!SvREADONLY(sv)
	&& PL_utf8cache
	&& SvTYPE(sv) >= SVt_PVMG
	&& (mg = mg_find(sv, PERL_MAGIC_utf8)))
    {
	if (mg->mg_ptr) {
	    STRLEN * const cache = (STRLEN *) mg->mg_ptr;
	    if (cache[1] == offset) {
		/* An exact match. */
		return cache[0];
	    }
	    if (cache[3] == offset) {
		/* An exact match. */
		return cache[2];
	    }

	    if (cache[1] < offset) {
		/* We already know part of the way. */
		if (mg->mg_len != -1) {
		    /* Actually, we know the end too.  */
		    len = cache[0]
			+ S_sv_pos_b2u_midway(aTHX_ s + cache[1], send,
					      s + blen, mg->mg_len - cache[0]);
		} else {
		    len = cache[0] + utf8_length(s + cache[1], send);
		}
	    }
	    else if (cache[3] < offset) {
		/* We're between the two cached pairs, so we do the calculation
		   offset by the byte/utf-8 positions for the earlier pair,
		   then add the utf-8 characters from the string start to
		   there.  */
		len = S_sv_pos_b2u_midway(aTHX_ s + cache[3], send,
					  s + cache[1], cache[0] - cache[2])
		    + cache[2];

	    }
	    else { /* cache[3] > offset */
		len = S_sv_pos_b2u_midway(aTHX_ s, send, s + cache[3],
					  cache[2]);

	    }
	    ASSERT_UTF8_CACHE(cache);
	    found = TRUE;
	} else if (mg->mg_len != -1) {
	    len = S_sv_pos_b2u_midway(aTHX_ s, send, s + blen, mg->mg_len);
	    found = TRUE;
	}
    }
    if (!found || PL_utf8cache < 0) {
	const STRLEN real_len = utf8_length(s, send);

	if (found && PL_utf8cache < 0)
	    assert_uft8_cache_coherent("sv_pos_b2u", len, real_len, sv);
	len = real_len;
    }

    if (PL_utf8cache) {
	if (blen == offset)
	    utf8_mg_len_cache_update(sv, &mg, len);
	else
	    utf8_mg_pos_cache_update(sv, &mg, offset, len, blen);
    }

    return len;
}

/*
=for apidoc sv_pos_b2u

Converts the value pointed to by C<offsetp> from a count of bytes from the
start of the string, to a count of the equivalent number of UTF-8 chars.
Handles magic and type coercion.

Use C<sv_pos_b2u_flags> in preference, which correctly handles strings
longer than 2Gb.

=cut
*/

/*
 * sv_pos_b2u() uses, like sv_pos_u2b(), the mg_ptr of the potential
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
 * byte offsets.
 *
 */
void
Perl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp)
{
    PERL_ARGS_ASSERT_SV_POS_B2U;

    if (!sv)
	return;

    *offsetp = (I32)sv_pos_b2u_flags(sv, (STRLEN)*offsetp,
				     SV_GMAGIC|SV_CONST_RETURN);
}

static void
S_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache,
			     STRLEN real, SV *const sv)
{
    PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT;

    /* As this is debugging only code, save space by keeping this test here,
       rather than inlining it in all the callers.  */
    if (from_cache == real)
	return;

    /* Need to turn the assertions off otherwise we may recurse infinitely
       while printing error messages.  */
    SAVEI8(PL_utf8cache);
    PL_utf8cache = 0;
    Perl_croak(aTHX_ "panic: %s cache %"UVuf" real %"UVuf" for %"SVf,
	       func, (UV) from_cache, (UV) real, SVfARG(sv));
}

/*
=for apidoc sv_eq

Returns a boolean indicating whether the strings in the two SVs are
identical.  Is UTF-8 and S<C<'use bytes'>> aware, handles get magic, and will
coerce its args to strings if necessary.

=for apidoc sv_eq_flags

Returns a boolean indicating whether the strings in the two SVs are
identical.  Is UTF-8 and S<C<'use bytes'>> aware and coerces its args to strings
if necessary.  If the flags has the C<SV_GMAGIC> bit set, it handles get-magic, too.

=cut
*/

I32
Perl_sv_eq_flags(pTHX_ SV *sv1, SV *sv2, const U32 flags)
{
    const char *pv1;
    STRLEN cur1;
    const char *pv2;
    STRLEN cur2;
    I32  eq     = 0;
    SV* svrecode = NULL;

    if (!sv1) {
	pv1 = "";
	cur1 = 0;
    }
    else {
	/* if pv1 and pv2 are the same, second SvPV_const call may
	 * invalidate pv1 (if we are handling magic), so we may need to
	 * make a copy */
	if (sv1 == sv2 && flags & SV_GMAGIC
	 && (SvTHINKFIRST(sv1) || SvGMAGICAL(sv1))) {
	    pv1 = SvPV_const(sv1, cur1);
	    sv1 = newSVpvn_flags(pv1, cur1, SVs_TEMP | SvUTF8(sv2));
	}
	pv1 = SvPV_flags_const(sv1, cur1, flags);
    }

    if (!sv2){
	pv2 = "";
	cur2 = 0;
    }
    else
	pv2 = SvPV_flags_const(sv2, cur2, flags);

    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTES) {
        /* Differing utf8ness.
	 * Do not UTF8size the comparands as a side-effect. */
	 if (IN_ENCODING) {
	      if (SvUTF8(sv1)) {
		   svrecode = newSVpvn(pv2, cur2);
		   sv_recode_to_utf8(svrecode, _get_encoding());
		   pv2 = SvPV_const(svrecode, cur2);
	      }
	      else {
		   svrecode = newSVpvn(pv1, cur1);
		   sv_recode_to_utf8(svrecode, _get_encoding());
		   pv1 = SvPV_const(svrecode, cur1);
	      }
	      /* Now both are in UTF-8. */
	      if (cur1 != cur2) {
		   SvREFCNT_dec_NN(svrecode);
		   return FALSE;
	      }
	 }
	 else {
	      if (SvUTF8(sv1)) {
		  /* sv1 is the UTF-8 one  */
		  return bytes_cmp_utf8((const U8*)pv2, cur2,
					(const U8*)pv1, cur1) == 0;
	      }
	      else {
		  /* sv2 is the UTF-8 one  */
		  return bytes_cmp_utf8((const U8*)pv1, cur1,
					(const U8*)pv2, cur2) == 0;
	      }
	 }
    }

    if (cur1 == cur2)
	eq = (pv1 == pv2) || memEQ(pv1, pv2, cur1);
	
    SvREFCNT_dec(svrecode);

    return eq;
}

/*
=for apidoc sv_cmp

Compares the strings in two SVs.  Returns -1, 0, or 1 indicating whether the
string in C<sv1> is less than, equal to, or greater than the string in
C<sv2>.  Is UTF-8 and S<C<'use bytes'>> aware, handles get magic, and will
coerce its args to strings if necessary.  See also C<L</sv_cmp_locale>>.

=for apidoc sv_cmp_flags

Compares the strings in two SVs.  Returns -1, 0, or 1 indicating whether the
string in C<sv1> is less than, equal to, or greater than the string in
C<sv2>.  Is UTF-8 and S<C<'use bytes'>> aware and will coerce its args to strings
if necessary.  If the flags has the C<SV_GMAGIC> bit set, it handles get magic.  See
also C<L</sv_cmp_locale_flags>>.

=cut
*/

I32
Perl_sv_cmp(pTHX_ SV *const sv1, SV *const sv2)
{
    return sv_cmp_flags(sv1, sv2, SV_GMAGIC);
}

I32
Perl_sv_cmp_flags(pTHX_ SV *const sv1, SV *const sv2,
		  const U32 flags)
{
    STRLEN cur1, cur2;
    const char *pv1, *pv2;
    I32  cmp;
    SV *svrecode = NULL;

    if (!sv1) {
	pv1 = "";
	cur1 = 0;
    }
    else
	pv1 = SvPV_flags_const(sv1, cur1, flags);

    if (!sv2) {
	pv2 = "";
	cur2 = 0;
    }
    else
	pv2 = SvPV_flags_const(sv2, cur2, flags);

    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTES) {
        /* Differing utf8ness.
	 * Do not UTF8size the comparands as a side-effect. */
	if (SvUTF8(sv1)) {
	    if (IN_ENCODING) {
		 svrecode = newSVpvn(pv2, cur2);
		 sv_recode_to_utf8(svrecode, _get_encoding());
		 pv2 = SvPV_const(svrecode, cur2);
	    }
	    else {
		const int retval = -bytes_cmp_utf8((const U8*)pv2, cur2,
						   (const U8*)pv1, cur1);
		return retval ? retval < 0 ? -1 : +1 : 0;
	    }
	}
	else {
	    if (IN_ENCODING) {
		 svrecode = newSVpvn(pv1, cur1);
		 sv_recode_to_utf8(svrecode, _get_encoding());
		 pv1 = SvPV_const(svrecode, cur1);
	    }
	    else {
		const int retval = bytes_cmp_utf8((const U8*)pv1, cur1,
						  (const U8*)pv2, cur2);
		return retval ? retval < 0 ? -1 : +1 : 0;
	    }
	}
    }

    /* Here, if both are non-NULL, then they have the same UTF8ness. */

    if (!cur1) {
	cmp = cur2 ? -1 : 0;
    } else if (!cur2) {
	cmp = 1;
    } else {
        STRLEN shortest_len = cur1 < cur2 ? cur1 : cur2;

#ifdef EBCDIC
        if (! DO_UTF8(sv1)) {
#endif
            const I32 retval = memcmp((const void*)pv1,
                                      (const void*)pv2,
                                      shortest_len);
            if (retval) {
                cmp = retval < 0 ? -1 : 1;
            } else if (cur1 == cur2) {
                cmp = 0;
            } else {
                cmp = cur1 < cur2 ? -1 : 1;
            }
#ifdef EBCDIC
        }
        else {  /* Both are to be treated as UTF-EBCDIC */

            /* EBCDIC UTF-8 is complicated by the fact that it is based on I8
             * which remaps code points 0-255.  We therefore generally have to
             * unmap back to the original values to get an accurate comparison.
             * But we don't have to do that for UTF-8 invariants, as by
             * definition, they aren't remapped, nor do we have to do it for
             * above-latin1 code points, as they also aren't remapped.  (This
             * code also works on ASCII platforms, but the memcmp() above is
             * much faster). */

            const char *e = pv1 + shortest_len;

            /* Find the first bytes that differ between the two strings */
            while (pv1 < e && *pv1 == *pv2) {
                pv1++;
                pv2++;
            }


            if (pv1 == e) { /* Are the same all the way to the end */
                if (cur1 == cur2) {
                    cmp = 0;
                } else {
                    cmp = cur1 < cur2 ? -1 : 1;
                }
            }
            else   /* Here *pv1 and *pv2 are not equal, but all bytes earlier
                    * in the strings were.  The current bytes may or may not be
                    * at the beginning of a character.  But neither or both are
                    * (or else earlier bytes would have been different).  And
                    * if we are in the middle of a character, the two
                    * characters are comprised of the same number of bytes
                    * (because in this case the start bytes are the same, and
                    * the start bytes encode the character's length). */
                 if (UTF8_IS_INVARIANT(*pv1))
            {
                /* If both are invariants; can just compare directly */
                if (UTF8_IS_INVARIANT(*pv2)) {
                    cmp = ((U8) *pv1 < (U8) *pv2) ? -1 : 1;
                }
                else   /* Since *pv1 is invariant, it is the whole character,
                          which means it is at the beginning of a character.
                          That means pv2 is also at the beginning of a
                          character (see earlier comment).  Since it isn't
                          invariant, it must be a start byte.  If it starts a
                          character whose code point is above 255, that
                          character is greater than any single-byte char, which
                          *pv1 is */
                      if (UTF8_IS_ABOVE_LATIN1_START(*pv2))
                {
                    cmp = -1;
                }
                else {
                    /* Here, pv2 points to a character composed of 2 bytes
                     * whose code point is < 256.  Get its code point and
                     * compare with *pv1 */
                    cmp = ((U8) *pv1 < EIGHT_BIT_UTF8_TO_NATIVE(*pv2, *(pv2 + 1)))
                           ?  -1
                           : 1;
                }
            }
            else   /* The code point starting at pv1 isn't a single byte */
                 if (UTF8_IS_INVARIANT(*pv2))
            {
                /* But here, the code point starting at *pv2 is a single byte,
                 * and so *pv1 must begin a character, hence is a start byte.
                 * If that character is above 255, it is larger than any
                 * single-byte char, which *pv2 is */
                if (UTF8_IS_ABOVE_LATIN1_START(*pv1)) {
                    cmp = 1;
                }
                else {
                    /* Here, pv1 points to a character composed of 2 bytes
                     * whose code point is < 256.  Get its code point and
                     * compare with the single byte character *pv2 */
                    cmp = (EIGHT_BIT_UTF8_TO_NATIVE(*pv1, *(pv1 + 1)) < (U8) *pv2)
                          ?  -1
                          : 1;
                }
            }
            else   /* Here, we've ruled out either *pv1 and *pv2 being
                      invariant.  That means both are part of variants, but not
                      necessarily at the start of a character */
                 if (   UTF8_IS_ABOVE_LATIN1_START(*pv1)
                     || UTF8_IS_ABOVE_LATIN1_START(*pv2))
            {
                /* Here, at least one is the start of a character, which means
                 * the other is also a start byte.  And the code point of at
                 * least one of the characters is above 255.  It is a
                 * characteristic of UTF-EBCDIC that all start bytes for
                 * above-latin1 code points are well behaved as far as code
                 * point comparisons go, and all are larger than all other
                 * start bytes, so the comparison with those is also well
                 * behaved */
                cmp = ((U8) *pv1 < (U8) *pv2) ? -1 : 1;
            }
            else {
                /* Here both *pv1 and *pv2 are part of variant characters.
                 * They could be both continuations, or both start characters.
                 * (One or both could even be an illegal start character (for
                 * an overlong) which for the purposes of sorting we treat as
                 * legal. */
                if (UTF8_IS_CONTINUATION(*pv1)) {

                    /* If they are continuations for code points above 255,
                     * then comparing the current byte is sufficient, as there
                     * is no remapping of these and so the comparison is
                     * well-behaved.   We determine if they are such
                     * continuations by looking at the preceding byte.  It
                     * could be a start byte, from which we can tell if it is
                     * for an above 255 code point.  Or it could be a
                     * continuation, which means the character occupies at
                     * least 3 bytes, so must be above 255.  */
                    if (   UTF8_IS_CONTINUATION(*(pv2 - 1))
                        || UTF8_IS_ABOVE_LATIN1_START(*(pv2 -1)))
                    {
                        cmp = ((U8) *pv1 < (U8) *pv2) ? -1 : 1;
                        goto cmp_done;
                    }

                    /* Here, the continuations are for code points below 256;
                     * back up one to get to the start byte */
                    pv1--;
                    pv2--;
                }

                /* We need to get the actual native code point of each of these
                 * variants in order to compare them */
                cmp =  (  EIGHT_BIT_UTF8_TO_NATIVE(*pv1, *(pv1 + 1))
                        < EIGHT_BIT_UTF8_TO_NATIVE(*pv2, *(pv2 + 1)))
                        ? -1
                        : 1;
            }
        }
      cmp_done: ;
#endif
    }

    SvREFCNT_dec(svrecode);

    return cmp;
}

/*
=for apidoc sv_cmp_locale

Compares the strings in two SVs in a locale-aware manner.  Is UTF-8 and
S<C<'use bytes'>> aware, handles get magic, and will coerce its args to strings
if necessary.  See also C<L</sv_cmp>>.

=for apidoc sv_cmp_locale_flags

Compares the strings in two SVs in a locale-aware manner.  Is UTF-8 and
S<C<'use bytes'>> aware and will coerce its args to strings if necessary.  If
the flags contain C<SV_GMAGIC>, it handles get magic.  See also
C<L</sv_cmp_flags>>.

=cut
*/

I32
Perl_sv_cmp_locale(pTHX_ SV *const sv1, SV *const sv2)
{
    return sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC);
}

I32
Perl_sv_cmp_locale_flags(pTHX_ SV *const sv1, SV *const sv2,
			 const U32 flags)
{
#ifdef USE_LOCALE_COLLATE

    char *pv1, *pv2;
    STRLEN len1, len2;
    I32 retval;

    if (PL_collation_standard)
	goto raw_compare;

    len1 = 0;
    pv1 = sv1 ? sv_collxfrm_flags(sv1, &len1, flags) : (char *) NULL;
    len2 = 0;
    pv2 = sv2 ? sv_collxfrm_flags(sv2, &len2, flags) : (char *) NULL;

    if (!pv1 || !len1) {
	if (pv2 && len2)
	    return -1;
	else
	    goto raw_compare;
    }
    else {
	if (!pv2 || !len2)
	    return 1;
    }

    retval = memcmp((void*)pv1, (void*)pv2, len1 < len2 ? len1 : len2);

    if (retval)
	return retval < 0 ? -1 : 1;

    /*
     * When the result of collation is equality, that doesn't mean
     * that there are no differences -- some locales exclude some
     * characters from consideration.  So to avoid false equalities,
     * we use the raw string as a tiebreaker.
     */

  raw_compare:
    /* FALLTHROUGH */

#else
    PERL_UNUSED_ARG(flags);
#endif /* USE_LOCALE_COLLATE */

    return sv_cmp(sv1, sv2);
}


#ifdef USE_LOCALE_COLLATE

/*
=for apidoc sv_collxfrm

This calls C<sv_collxfrm_flags> with the SV_GMAGIC flag.  See
C<L</sv_collxfrm_flags>>.

=for apidoc sv_collxfrm_flags

Add Collate Transform magic to an SV if it doesn't already have it.  If the
flags contain C<SV_GMAGIC>, it handles get-magic.

Any scalar variable may carry C<PERL_MAGIC_collxfrm> magic that contains the
scalar data of the variable, but transformed to such a format that a normal
memory comparison can be used to compare the data according to the locale
settings.

=cut
*/

char *
Perl_sv_collxfrm_flags(pTHX_ SV *const sv, STRLEN *const nxp, const I32 flags)
{
    MAGIC *mg;

    PERL_ARGS_ASSERT_SV_COLLXFRM_FLAGS;

    mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_collxfrm) : (MAGIC *) NULL;
    if (!mg || !mg->mg_ptr || *(U32*)mg->mg_ptr != PL_collation_ix) {
	const char *s;
	char *xf;
	STRLEN len, xlen;

	if (mg)
	    Safefree(mg->mg_ptr);
	s = SvPV_flags_const(sv, len, flags);
	if ((xf = mem_collxfrm(s, len, &xlen))) {
	    if (! mg) {
		mg = sv_magicext(sv, 0, PERL_MAGIC_collxfrm, &PL_vtbl_collxfrm,
				 0, 0);
		assert(mg);
	    }
	    mg->mg_ptr = xf;
	    mg->mg_len = xlen;
	}
	else {
	    if (mg) {
		mg->mg_ptr = NULL;
		mg->mg_len = -1;
	    }
	}
    }
    if (mg && mg->mg_ptr) {
	*nxp = mg->mg_len;
	return mg->mg_ptr + sizeof(PL_collation_ix);
    }
    else {
	*nxp = 0;
	return NULL;
    }
}

#endif /* USE_LOCALE_COLLATE */

static char *
S_sv_gets_append_to_utf8(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
{
    SV * const tsv = newSV(0);
    ENTER;
    SAVEFREESV(tsv);
    sv_gets(tsv, fp, 0);
    sv_utf8_upgrade_nomg(tsv);
    SvCUR_set(sv,append);
    sv_catsv(sv,tsv);
    LEAVE;
    return (SvCUR(sv) - append) ? SvPVX(sv) : NULL;
}

static char *
S_sv_gets_read_record(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
{
    SSize_t bytesread;
    const STRLEN recsize = SvUV(SvRV(PL_rs)); /* RsRECORD() guarantees > 0. */
      /* Grab the size of the record we're getting */
    char *buffer = SvGROW(sv, (STRLEN)(recsize + append + 1)) + append;
    
    /* Go yank in */
#ifdef __VMS
    int fd;
    Stat_t st;

    /* With a true, record-oriented file on VMS, we need to use read directly
     * to ensure that we respect RMS record boundaries.  The user is responsible
     * for providing a PL_rs value that corresponds to the FAB$W_MRS (maximum
     * record size) field.  N.B. This is likely to produce invalid results on
     * varying-width character data when a record ends mid-character.
     */
    fd = PerlIO_fileno(fp);
    if (fd != -1
	&& PerlLIO_fstat(fd, &st) == 0
	&& (st.st_fab_rfm == FAB$C_VAR
	    || st.st_fab_rfm == FAB$C_VFC
	    || st.st_fab_rfm == FAB$C_FIX)) {

	bytesread = PerlLIO_read(fd, buffer, recsize);
    }
    else /* in-memory file from PerlIO::Scalar
          * or not a record-oriented file
          */
#endif
    {
	bytesread = PerlIO_read(fp, buffer, recsize);

	/* At this point, the logic in sv_get() means that sv will
	   be treated as utf-8 if the handle is utf8.
	*/
	if (PerlIO_isutf8(fp) && bytesread > 0) {
	    char *bend = buffer + bytesread;
	    char *bufp = buffer;
	    size_t charcount = 0;
	    bool charstart = TRUE;
	    STRLEN skip = 0;

	    while (charcount < recsize) {
		/* count accumulated characters */
		while (bufp < bend) {
		    if (charstart) {
			skip = UTF8SKIP(bufp);
		    }
		    if (bufp + skip > bend) {
			/* partial at the end */
			charstart = FALSE;
			break;
		    }
		    else {
			++charcount;
			bufp += skip;
			charstart = TRUE;
		    }
		}

		if (charcount < recsize) {
		    STRLEN readsize;
		    STRLEN bufp_offset = bufp - buffer;
		    SSize_t morebytesread;

		    /* originally I read enough to fill any incomplete
		       character and the first byte of the next
		       character if needed, but if there's many
		       multi-byte encoded characters we're going to be
		       making a read call for every character beyond
		       the original read size.

		       So instead, read the rest of the character if
		       any, and enough bytes to match at least the
		       start bytes for each character we're going to
		       read.
		    */
		    if (charstart)
			readsize = recsize - charcount;
		    else 
			readsize = skip - (bend - bufp) + recsize - charcount - 1;
		    buffer = SvGROW(sv, append + bytesread + readsize + 1) + append;
		    bend = buffer + bytesread;
		    morebytesread = PerlIO_read(fp, bend, readsize);
		    if (morebytesread <= 0) {
			/* we're done, if we still have incomplete
			   characters the check code in sv_gets() will
			   warn about them.

			   I'd originally considered doing
			   PerlIO_ungetc() on all but the lead
			   character of the incomplete character, but
			   read() doesn't do that, so I don't.
			*/
			break;
		    }

		    /* prepare to scan some more */
		    bytesread += morebytesread;
		    bend = buffer + bytesread;
		    bufp = buffer + bufp_offset;
		}
	    }
	}
    }

    if (bytesread < 0)
	bytesread = 0;
    SvCUR_set(sv, bytesread + append);
    buffer[bytesread] = '\0';
    return (SvCUR(sv) - append) ? SvPVX(sv) : NULL;
}

/*
=for apidoc sv_gets

Get a line from the filehandle and store it into the SV, optionally
appending to the currently-stored string.  If C<append> is not 0, the
line is appended to the SV instead of overwriting it.  C<append> should
be set to the byte offset that the appended string should start at
in the SV (typically, C<SvCUR(sv)> is a suitable choice).

=cut
*/

char *
Perl_sv_gets(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
{
    const char *rsptr;
    STRLEN rslen;
    STDCHAR rslast;
    STDCHAR *bp;
    SSize_t cnt;
    int i = 0;
    int rspara = 0;

    PERL_ARGS_ASSERT_SV_GETS;

    if (SvTHINKFIRST(sv))
	sv_force_normal_flags(sv, append ? 0 : SV_COW_DROP_PV);
    /* XXX. If you make this PVIV, then copy on write can copy scalars read
       from <>.
       However, perlbench says it's slower, because the existing swipe code
       is faster than copy on write.
       Swings and roundabouts.  */
    SvUPGRADE(sv, SVt_PV);

    if (append) {
        /* line is going to be appended to the existing buffer in the sv */
	if (PerlIO_isutf8(fp)) {
	    if (!SvUTF8(sv)) {
		sv_utf8_upgrade_nomg(sv);
		sv_pos_u2b(sv,&append,0);
	    }
	} else if (SvUTF8(sv)) {
	    return S_sv_gets_append_to_utf8(aTHX_ sv, fp, append);
	}
    }

    SvPOK_only(sv);
    if (!append) {
        /* not appending - "clear" the string by setting SvCUR to 0,
         * the pv is still avaiable. */
        SvCUR_set(sv,0);
    }
    if (PerlIO_isutf8(fp))
	SvUTF8_on(sv);

    if (IN_PERL_COMPILETIME) {
	/* we always read code in line mode */
	rsptr = "\n";
	rslen = 1;
    }
    else if (RsSNARF(PL_rs)) {
    	/* If it is a regular disk file use size from stat() as estimate
	   of amount we are going to read -- may result in mallocing
	   more memory than we really need if the layers below reduce
	   the size we read (e.g. CRLF or a gzip layer).
	 */
	Stat_t st;
        int fd = PerlIO_fileno(fp);
	if (fd >= 0 && (PerlLIO_fstat(fd, &st) == 0) && S_ISREG(st.st_mode))  {
	    const Off_t offset = PerlIO_tell(fp);
	    if (offset != (Off_t) -1 && st.st_size + append > offset) {
#ifdef PERL_COPY_ON_WRITE
                /* Add an extra byte for the sake of copy-on-write's
                 * buffer reference count. */
		(void) SvGROW(sv, (STRLEN)((st.st_size - offset) + append + 2));
#else
		(void) SvGROW(sv, (STRLEN)((st.st_size - offset) + append + 1));
#endif
	    }
	}
	rsptr = NULL;
	rslen = 0;
    }
    else if (RsRECORD(PL_rs)) {
	return S_sv_gets_read_record(aTHX_ sv, fp, append);
    }
    else if (RsPARA(PL_rs)) {
	rsptr = "\n\n";
	rslen = 2;
	rspara = 1;
    }
    else {
	/* Get $/ i.e. PL_rs into same encoding as stream wants */
	if (PerlIO_isutf8(fp)) {
	    rsptr = SvPVutf8(PL_rs, rslen);
	}
	else {
	    if (SvUTF8(PL_rs)) {
		if (!sv_utf8_downgrade(PL_rs, TRUE)) {
		    Perl_croak(aTHX_ "Wide character in $/");
		}
	    }
            /* extract the raw pointer to the record separator */
	    rsptr = SvPV_const(PL_rs, rslen);
	}
    }

    /* rslast is the last character in the record separator
     * note we don't use rslast except when rslen is true, so the
     * null assign is a placeholder. */
    rslast = rslen ? rsptr[rslen - 1] : '\0';

    if (rspara) {		/* have to do this both before and after */
	do {			/* to make sure file boundaries work right */
	    if (PerlIO_eof(fp))
		return 0;
	    i = PerlIO_getc(fp);
	    if (i != '\n') {
		if (i == -1)
		    return 0;
		PerlIO_ungetc(fp,i);
		break;
	    }
	} while (i != EOF);
    }

    /* See if we know enough about I/O mechanism to cheat it ! */

    /* This used to be #ifdef test - it is made run-time test for ease
       of abstracting out stdio interface. One call should be cheap
       enough here - and may even be a macro allowing compile
       time optimization.
     */

    if (PerlIO_fast_gets(fp)) {
    /*
     * We can do buffer based IO operations on this filehandle.
     *
     * This means we can bypass a lot of subcalls and process
     * the buffer directly, it also means we know the upper bound
     * on the amount of data we might read of the current buffer
     * into our sv. Knowing this allows us to preallocate the pv
     * to be able to hold that maximum, which allows us to simplify
     * a lot of logic. */

    /*
     * We're going to steal some values from the stdio struct
     * and put EVERYTHING in the innermost loop into registers.
     */
    STDCHAR *ptr;       /* pointer into fp's read-ahead buffer */
    STRLEN bpx;         /* length of the data in the target sv
                           used to fix pointers after a SvGROW */
    I32 shortbuffered;  /* If the pv buffer is shorter than the amount
                           of data left in the read-ahead buffer.
                           If 0 then the pv buffer can hold the full
                           amount left, otherwise this is the amount it
                           can hold. */

    /* Here is some breathtakingly efficient cheating */

    /* When you read the following logic resist the urge to think
     * of record separators that are 1 byte long. They are an
     * uninteresting special (simple) case.
     *
     * Instead think of record separators which are at least 2 bytes
     * long, and keep in mind that we need to deal with such
     * separators when they cross a read-ahead buffer boundary.
     *
     * Also consider that we need to gracefully deal with separators
     * that may be longer than a single read ahead buffer.
     *
     * Lastly do not forget we want to copy the delimiter as well. We
     * are copying all data in the file _up_to_and_including_ the separator
     * itself.
     *
     * Now that you have all that in mind here is what is happening below:
     *
     * 1. When we first enter the loop we do some memory book keeping to see
     * how much free space there is in the target SV. (This sub assumes that
     * it is operating on the same SV most of the time via $_ and that it is
     * going to be able to reuse the same pv buffer each call.) If there is
     * "enough" room then we set "shortbuffered" to how much space there is
     * and start reading forward.
     *
     * 2. When we scan forward we copy from the read-ahead buffer to the target
     * SV's pv buffer. While we go we watch for the end of the read-ahead buffer,
     * and the end of the of pv, as well as for the "rslast", which is the last
     * char of the separator.
     *
     * 3. When scanning forward if we see rslast then we jump backwards in *pv*
     * (which has a "complete" record up to the point we saw rslast) and check
     * it to see if it matches the separator. If it does we are done. If it doesn't
     * we continue on with the scan/copy.
     *
     * 4. If we run out of read-ahead buffer (cnt goes to 0) then we have to get
     * the IO system to read the next buffer. We do this by doing a getc(), which
     * returns a single char read (or EOF), and prefills the buffer, and also
     * allows us to find out how full the buffer is.  We use this information to
     * SvGROW() the sv to the size remaining in the buffer, after which we copy
     * the returned single char into the target sv, and then go back into scan
     * forward mode.
     *
     * 5. If we run out of write-buffer then we SvGROW() it by the size of the
     * remaining space in the read-buffer.
     *
     * Note that this code despite its twisty-turny nature is pretty darn slick.
     * It manages single byte separators, multi-byte cross boundary separators,
     * and cross-read-buffer separators cleanly and efficiently at the cost
     * of potentially greatly overallocating the target SV.
     *
     * Yves
     */


    /* get the number of bytes remaining in the read-ahead buffer
     * on first call on a given fp this will return 0.*/
    cnt = PerlIO_get_cnt(fp);

    /* make sure we have the room */
    if ((I32)(SvLEN(sv) - append) <= cnt + 1) {
    	/* Not room for all of it
	   if we are looking for a separator and room for some
	 */
	if (rslen && cnt > 80 && (I32)SvLEN(sv) > append) {
	    /* just process what we have room for */
	    shortbuffered = cnt - SvLEN(sv) + append + 1;
	    cnt -= shortbuffered;
	}
	else {
            /* ensure that the target sv has enough room to hold
             * the rest of the read-ahead buffer */
	    shortbuffered = 0;
	    /* remember that cnt can be negative */
	    SvGROW(sv, (STRLEN)(append + (cnt <= 0 ? 2 : (cnt + 1))));
	}
    }
    else {
        /* we have enough room to hold the full buffer, lets scream */
	shortbuffered = 0;
    }

    /* extract the pointer to sv's string buffer, offset by append as necessary */
    bp = (STDCHAR*)SvPVX_const(sv) + append;  /* move these two too to registers */
    /* extract the point to the read-ahead buffer */
    ptr = (STDCHAR*)PerlIO_get_ptr(fp);

    /* some trace debug output */
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: entering, ptr=%"UVuf", cnt=%ld\n",PTR2UV(ptr),(long)cnt));
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: entering: PerlIO * thinks ptr=%"UVuf", cnt=%"IVdf", base=%"
	 UVuf"\n",
	       PTR2UV(PerlIO_get_ptr(fp)), (IV)PerlIO_get_cnt(fp),
	       PTR2UV(PerlIO_has_base(fp) ? PerlIO_get_base(fp) : 0)));

    for (;;) {
      screamer:
        /* if there is stuff left in the read-ahead buffer */
	if (cnt > 0) {
            /* if there is a separator */
	    if (rslen) {
                /* loop until we hit the end of the read-ahead buffer */
		while (cnt > 0) {		     /* this     |  eat */
                    /* scan forward copying and searching for rslast as we go */
		    cnt--;
		    if ((*bp++ = *ptr++) == rslast)  /* really   |  dust */
			goto thats_all_folks;	     /* screams  |  sed :-) */
		}
	    }
	    else {
                /* no separator, slurp the full buffer */
	        Copy(ptr, bp, cnt, char);	     /* this     |  eat */
		bp += cnt;			     /* screams  |  dust */
		ptr += cnt;			     /* louder   |  sed :-) */
		cnt = 0;
		assert (!shortbuffered);
		goto cannot_be_shortbuffered;
	    }
	}
	
	if (shortbuffered) {		/* oh well, must extend */
            /* we didnt have enough room to fit the line into the target buffer
             * so we must extend the target buffer and keep going */
	    cnt = shortbuffered;
	    shortbuffered = 0;
	    bpx = bp - (STDCHAR*)SvPVX_const(sv); /* box up before relocation */
	    SvCUR_set(sv, bpx);
            /* extned the target sv's buffer so it can hold the full read-ahead buffer */
	    SvGROW(sv, SvLEN(sv) + append + cnt + 2);
	    bp = (STDCHAR*)SvPVX_const(sv) + bpx; /* unbox after relocation */
	    continue;
	}

    cannot_be_shortbuffered:
        /* we need to refill the read-ahead buffer if possible */

	DEBUG_P(PerlIO_printf(Perl_debug_log,
			     "Screamer: going to getc, ptr=%"UVuf", cnt=%"IVdf"\n",
			      PTR2UV(ptr),(IV)cnt));
	PerlIO_set_ptrcnt(fp, (STDCHAR*)ptr, cnt); /* deregisterize cnt and ptr */

	DEBUG_Pv(PerlIO_printf(Perl_debug_log,
	   "Screamer: pre: FILE * thinks ptr=%"UVuf", cnt=%"IVdf", base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), (IV)PerlIO_get_cnt(fp),
	    PTR2UV(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));

        /*
            call PerlIO_getc() to let it prefill the lookahead buffer

            This used to call 'filbuf' in stdio form, but as that behaves like
            getc when cnt <= 0 we use PerlIO_getc here to avoid introducing
            another abstraction.

            Note we have to deal with the char in 'i' if we are not at EOF
        */
	i   = PerlIO_getc(fp);		/* get more characters */

	DEBUG_Pv(PerlIO_printf(Perl_debug_log,
	   "Screamer: post: FILE * thinks ptr=%"UVuf", cnt=%"IVdf", base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), (IV)PerlIO_get_cnt(fp),
	    PTR2UV(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));

        /* find out how much is left in the read-ahead buffer, and rextract its pointer */
	cnt = PerlIO_get_cnt(fp);
	ptr = (STDCHAR*)PerlIO_get_ptr(fp);	/* reregisterize cnt and ptr */
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	    "Screamer: after getc, ptr=%"UVuf", cnt=%"IVdf"\n",
	    PTR2UV(ptr),(IV)cnt));

	if (i == EOF)			/* all done for ever? */
	    goto thats_really_all_folks;

        /* make sure we have enough space in the target sv */
	bpx = bp - (STDCHAR*)SvPVX_const(sv);	/* box up before relocation */
	SvCUR_set(sv, bpx);
	SvGROW(sv, bpx + cnt + 2);
	bp = (STDCHAR*)SvPVX_const(sv) + bpx;	/* unbox after relocation */

        /* copy of the char we got from getc() */
	*bp++ = (STDCHAR)i;		/* store character from PerlIO_getc */

        /* make sure we deal with the i being the last character of a separator */
	if (rslen && (STDCHAR)i == rslast)  /* all done for now? */
	    goto thats_all_folks;
    }

  thats_all_folks:
    /* check if we have actually found the separator - only really applies
     * when rslen > 1 */
    if ((rslen > 1 && (STRLEN)(bp - (STDCHAR*)SvPVX_const(sv)) < rslen) ||
	  memNE((char*)bp - rslen, rsptr, rslen))
	goto screamer;				/* go back to the fray */
  thats_really_all_folks:
    if (shortbuffered)
	cnt += shortbuffered;
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	     "Screamer: quitting, ptr=%"UVuf", cnt=%"IVdf"\n",PTR2UV(ptr),(IV)cnt));
    PerlIO_set_ptrcnt(fp, (STDCHAR*)ptr, cnt);	/* put these back or we're in trouble */
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: end: FILE * thinks ptr=%"UVuf", cnt=%"IVdf", base=%"UVuf
	"\n",
	PTR2UV(PerlIO_get_ptr(fp)), (IV)PerlIO_get_cnt(fp),
	PTR2UV(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
    *bp = '\0';
    SvCUR_set(sv, bp - (STDCHAR*)SvPVX_const(sv));	/* set length */
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: done, len=%ld, string=|%.*s|\n",
	(long)SvCUR(sv),(int)SvCUR(sv),SvPVX_const(sv)));
    }
   else
    {
       /*The big, slow, and stupid way. */
#ifdef USE_HEAP_INSTEAD_OF_STACK	/* Even slower way. */
	STDCHAR *buf = NULL;
	Newx(buf, 8192, STDCHAR);
	assert(buf);
#else
	STDCHAR buf[8192];
#endif

      screamer2:
	if (rslen) {
            const STDCHAR * const bpe = buf + sizeof(buf);
	    bp = buf;
	    while ((i = PerlIO_getc(fp)) != EOF && (*bp++ = (STDCHAR)i) != rslast && bp < bpe)
		; /* keep reading */
	    cnt = bp - buf;
	}
	else {
	    cnt = PerlIO_read(fp,(char*)buf, sizeof(buf));
	    /* Accommodate broken VAXC compiler, which applies U8 cast to
	     * both args of ?: operator, causing EOF to change into 255
	     */
	    if (cnt > 0)
		 i = (U8)buf[cnt - 1];
	    else
		 i = EOF;
	}

	if (cnt < 0)
	    cnt = 0;  /* we do need to re-set the sv even when cnt <= 0 */
	if (append)
            sv_catpvn_nomg(sv, (char *) buf, cnt);
	else
            sv_setpvn(sv, (char *) buf, cnt);   /* "nomg" is implied */

	if (i != EOF &&			/* joy */
	    (!rslen ||
	     SvCUR(sv) < rslen ||
	     memNE(SvPVX_const(sv) + SvCUR(sv) - rslen, rsptr, rslen)))
	{
	    append = -1;
	    /*
	     * If we're reading from a TTY and we get a short read,
	     * indicating that the user hit his EOF character, we need
	     * to notice it now, because if we try to read from the TTY
	     * again, the EOF condition will disappear.
	     *
	     * The comparison of cnt to sizeof(buf) is an optimization
	     * that prevents unnecessary calls to feof().
	     *
	     * - jik 9/25/96
	     */
	    if (!(cnt < (I32)sizeof(buf) && PerlIO_eof(fp)))
		goto screamer2;
	}

#ifdef USE_HEAP_INSTEAD_OF_STACK
	Safefree(buf);
#endif
    }

    if (rspara) {		/* have to do this both before and after */
        while (i != EOF) {	/* to make sure file boundaries work right */
	    i = PerlIO_getc(fp);
	    if (i != '\n') {
		PerlIO_ungetc(fp,i);
		break;
	    }
	}
    }

    return (SvCUR(sv) - append) ? SvPVX(sv) : NULL;
}

/*
=for apidoc sv_inc

Auto-increment of the value in the SV, doing string to numeric conversion
if necessary.  Handles 'get' magic and operator overloading.

=cut
*/

void
Perl_sv_inc(pTHX_ SV *const sv)
{
    if (!sv)
	return;
    SvGETMAGIC(sv);
    sv_inc_nomg(sv);
}

/*
=for apidoc sv_inc_nomg

Auto-increment of the value in the SV, doing string to numeric conversion
if necessary.  Handles operator overloading.  Skips handling 'get' magic.

=cut
*/

void
Perl_sv_inc_nomg(pTHX_ SV *const sv)
{
    char *d;
    int flags;

    if (!sv)
	return;
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv)) {
		Perl_croak_no_modify();
	}
	if (SvROK(sv)) {
	    IV i;
	    if (SvAMAGIC(sv) && AMG_CALLunary(sv, inc_amg))
		return;
	    i = PTR2IV(SvRV(sv));
	    sv_unref(sv);
	    sv_setiv(sv, i);
	}
	else sv_force_normal_flags(sv, 0);
    }
    flags = SvFLAGS(sv);
    if ((flags & (SVp_NOK|SVp_IOK)) == SVp_NOK) {
	/* It's (privately or publicly) a float, but not tested as an
	   integer, so test it to see. */
	(void) SvIV(sv);
	flags = SvFLAGS(sv);
    }
    if ((flags & SVf_IOK) || ((flags & (SVp_IOK | SVp_NOK)) == SVp_IOK)) {
	/* It's publicly an integer, or privately an integer-not-float */
#ifdef PERL_PRESERVE_IVUV
      oops_its_int:
#endif
	if (SvIsUV(sv)) {
	    if (SvUVX(sv) == UV_MAX)
		sv_setnv(sv, UV_MAX_P1);
	    else
		(void)SvIOK_only_UV(sv);
		SvUV_set(sv, SvUVX(sv) + 1);
	} else {
	    if (SvIVX(sv) == IV_MAX)
		sv_setuv(sv, (UV)IV_MAX + 1);
	    else {
		(void)SvIOK_only(sv);
		SvIV_set(sv, SvIVX(sv) + 1);
	    }	
	}
	return;
    }
    if (flags & SVp_NOK) {
	const NV was = SvNVX(sv);
	if (LIKELY(!Perl_isinfnan(was)) &&
            NV_OVERFLOWS_INTEGERS_AT &&
	    was >= NV_OVERFLOWS_INTEGERS_AT) {
	    /* diag_listed_as: Lost precision when %s %f by 1 */
	    Perl_ck_warner(aTHX_ packWARN(WARN_IMPRECISION),
			   "Lost precision when incrementing %" NVff " by 1",
			   was);
	}
	(void)SvNOK_only(sv);
        SvNV_set(sv, was + 1.0);
	return;
    }

    /* treat AV/HV/CV/FM/IO and non-fake GVs as immutable */
    if (SvTYPE(sv) >= SVt_PVAV || (isGV_with_GP(sv) && !SvFAKE(sv)))
        Perl_croak_no_modify();

    if (!(flags & SVp_POK) || !*SvPVX_const(sv)) {
	if ((flags & SVTYPEMASK) < SVt_PVIV)
	    sv_upgrade(sv, ((flags & SVTYPEMASK) > SVt_IV ? SVt_PVIV : SVt_IV));
	(void)SvIOK_only(sv);
	SvIV_set(sv, 1);
	return;
    }
    d = SvPVX(sv);
    while (isALPHA(*d)) d++;
    while (isDIGIT(*d)) d++;
    if (d < SvEND(sv)) {
	const int numtype = grok_number_flags(SvPVX_const(sv), SvCUR(sv), NULL, PERL_SCAN_TRAILING);
#ifdef PERL_PRESERVE_IVUV
	/* Got to punt this as an integer if needs be, but we don't issue
	   warnings. Probably ought to make the sv_iv_please() that does
	   the conversion if possible, and silently.  */
	if (numtype && !(numtype & IS_NUMBER_INFINITY)) {
	    /* Need to try really hard to see if it's an integer.
	       9.22337203685478e+18 is an integer.
	       but "9.22337203685478e+18" + 0 is UV=9223372036854779904
	       so $a="9.22337203685478e+18"; $a+0; $a++
	       needs to be the same as $a="9.22337203685478e+18"; $a++
	       or we go insane. */
	
	    (void) sv_2iv(sv);
	    if (SvIOK(sv))
		goto oops_its_int;

	    /* sv_2iv *should* have made this an NV */
	    if (flags & SVp_NOK) {
		(void)SvNOK_only(sv);
                SvNV_set(sv, SvNVX(sv) + 1.0);
		return;
	    }
	    /* I don't think we can get here. Maybe I should assert this
	       And if we do get here I suspect that sv_setnv will croak. NWC
	       Fall through. */
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_inc punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"NVgf"\n",
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
	}
#endif /* PERL_PRESERVE_IVUV */
        if (!numtype && ckWARN(WARN_NUMERIC))
            not_incrementable(sv);
	sv_setnv(sv,Atof(SvPVX_const(sv)) + 1.0);
	return;
    }
    d--;
    while (d >= SvPVX_const(sv)) {
	if (isDIGIT(*d)) {
	    if (++*d <= '9')
		return;
	    *(d--) = '0';
	}
	else {
#ifdef EBCDIC
	    /* MKS: The original code here died if letters weren't consecutive.
	     * at least it didn't have to worry about non-C locales.  The
	     * new code assumes that ('z'-'a')==('Z'-'A'), letters are
	     * arranged in order (although not consecutively) and that only
	     * [A-Za-z] are accepted by isALPHA in the C locale.
	     */
	    if (isALPHA_FOLD_NE(*d, 'z')) {
		do { ++*d; } while (!isALPHA(*d));
		return;
	    }
	    *(d--) -= 'z' - 'a';
#else
	    ++*d;
	    if (isALPHA(*d))
		return;
	    *(d--) -= 'z' - 'a' + 1;
#endif
	}
    }
    /* oh,oh, the number grew */
    SvGROW(sv, SvCUR(sv) + 2);
    SvCUR_set(sv, SvCUR(sv) + 1);
    for (d = SvPVX(sv) + SvCUR(sv); d > SvPVX_const(sv); d--)
	*d = d[-1];
    if (isDIGIT(d[1]))
	*d = '1';
    else
	*d = d[1];
}

/*
=for apidoc sv_dec

Auto-decrement of the value in the SV, doing string to numeric conversion
if necessary.  Handles 'get' magic and operator overloading.

=cut
*/

void
Perl_sv_dec(pTHX_ SV *const sv)
{
    if (!sv)
	return;
    SvGETMAGIC(sv);
    sv_dec_nomg(sv);
}

/*
=for apidoc sv_dec_nomg

Auto-decrement of the value in the SV, doing string to numeric conversion
if necessary.  Handles operator overloading.  Skips handling 'get' magic.

=cut
*/

void
Perl_sv_dec_nomg(pTHX_ SV *const sv)
{
    int flags;

    if (!sv)
	return;
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv)) {
		Perl_croak_no_modify();
	}
	if (SvROK(sv)) {
	    IV i;
	    if (SvAMAGIC(sv) && AMG_CALLunary(sv, dec_amg))
		return;
	    i = PTR2IV(SvRV(sv));
	    sv_unref(sv);
	    sv_setiv(sv, i);
	}
	else sv_force_normal_flags(sv, 0);
    }
    /* Unlike sv_inc we don't have to worry about string-never-numbers
       and keeping them magic. But we mustn't warn on punting */
    flags = SvFLAGS(sv);
    if ((flags & SVf_IOK) || ((flags & (SVp_IOK | SVp_NOK)) == SVp_IOK)) {
	/* It's publicly an integer, or privately an integer-not-float */
#ifdef PERL_PRESERVE_IVUV
      oops_its_int:
#endif
	if (SvIsUV(sv)) {
	    if (SvUVX(sv) == 0) {
		(void)SvIOK_only(sv);
		SvIV_set(sv, -1);
	    }
	    else {
		(void)SvIOK_only_UV(sv);
		SvUV_set(sv, SvUVX(sv) - 1);
	    }	
	} else {
	    if (SvIVX(sv) == IV_MIN) {
		sv_setnv(sv, (NV)IV_MIN);
		goto oops_its_num;
	    }
	    else {
		(void)SvIOK_only(sv);
		SvIV_set(sv, SvIVX(sv) - 1);
	    }	
	}
	return;
    }
    if (flags & SVp_NOK) {
    oops_its_num:
	{
	    const NV was = SvNVX(sv);
	    if (LIKELY(!Perl_isinfnan(was)) &&
                NV_OVERFLOWS_INTEGERS_AT &&
		was <= -NV_OVERFLOWS_INTEGERS_AT) {
		/* diag_listed_as: Lost precision when %s %f by 1 */
		Perl_ck_warner(aTHX_ packWARN(WARN_IMPRECISION),
			       "Lost precision when decrementing %" NVff " by 1",
			       was);
	    }
	    (void)SvNOK_only(sv);
	    SvNV_set(sv, was - 1.0);
	    return;
	}
    }

    /* treat AV/HV/CV/FM/IO and non-fake GVs as immutable */
    if (SvTYPE(sv) >= SVt_PVAV || (isGV_with_GP(sv) && !SvFAKE(sv)))
        Perl_croak_no_modify();

    if (!(flags & SVp_POK)) {
	if ((flags & SVTYPEMASK) < SVt_PVIV)
	    sv_upgrade(sv, ((flags & SVTYPEMASK) > SVt_IV) ? SVt_PVIV : SVt_IV);
	SvIV_set(sv, -1);
	(void)SvIOK_only(sv);
	return;
    }
#ifdef PERL_PRESERVE_IVUV
    {
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), NULL);
	if (numtype && !(numtype & IS_NUMBER_INFINITY)) {
	    /* Need to try really hard to see if it's an integer.
	       9.22337203685478e+18 is an integer.
	       but "9.22337203685478e+18" + 0 is UV=9223372036854779904
	       so $a="9.22337203685478e+18"; $a+0; $a--
	       needs to be the same as $a="9.22337203685478e+18"; $a--
	       or we go insane. */
	
	    (void) sv_2iv(sv);
	    if (SvIOK(sv))
		goto oops_its_int;

	    /* sv_2iv *should* have made this an NV */
	    if (flags & SVp_NOK) {
		(void)SvNOK_only(sv);
                SvNV_set(sv, SvNVX(sv) - 1.0);
		return;
	    }
	    /* I don't think we can get here. Maybe I should assert this
	       And if we do get here I suspect that sv_setnv will croak. NWC
	       Fall through. */
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_dec punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"NVgf"\n",
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
	}
    }
#endif /* PERL_PRESERVE_IVUV */
    sv_setnv(sv,Atof(SvPVX_const(sv)) - 1.0);	/* punt */
}

/* this define is used to eliminate a chunk of duplicated but shared logic
 * it has the suffix __SV_C to signal that it isnt API, and isnt meant to be
 * used anywhere but here - yves
 */
#define PUSH_EXTEND_MORTAL__SV_C(AnSv) \
    STMT_START {      \
	SSize_t ix = ++PL_tmps_ix;		\
	if (UNLIKELY(ix >= PL_tmps_max))	\
	    ix = tmps_grow_p(ix);			\
	PL_tmps_stack[ix] = (AnSv); \
    } STMT_END

/*
=for apidoc sv_mortalcopy

Creates a new SV which is a copy of the original SV (using C<sv_setsv>).
The new SV is marked as mortal.  It will be destroyed "soon", either by an
explicit call to C<FREETMPS>, or by an implicit call at places such as
statement boundaries.  See also C<L</sv_newmortal>> and C<L</sv_2mortal>>.

=cut
*/

/* Make a string that will exist for the duration of the expression
 * evaluation.  Actually, it may have to last longer than that, but
 * hopefully we won't free it until it has been assigned to a
 * permanent location. */

SV *
Perl_sv_mortalcopy_flags(pTHX_ SV *const oldstr, U32 flags)
{
    SV *sv;

    if (flags & SV_GMAGIC)
	SvGETMAGIC(oldstr); /* before new_SV, in case it dies */
    new_SV(sv);
    sv_setsv_flags(sv,oldstr,flags & ~SV_GMAGIC);
    PUSH_EXTEND_MORTAL__SV_C(sv);
    SvTEMP_on(sv);
    return sv;
}

/*
=for apidoc sv_newmortal

Creates a new null SV which is mortal.  The reference count of the SV is
set to 1.  It will be destroyed "soon", either by an explicit call to
C<FREETMPS>, or by an implicit call at places such as statement boundaries.
See also C<L</sv_mortalcopy>> and C<L</sv_2mortal>>.

=cut
*/

SV *
Perl_sv_newmortal(pTHX)
{
    SV *sv;

    new_SV(sv);
    SvFLAGS(sv) = SVs_TEMP;
    PUSH_EXTEND_MORTAL__SV_C(sv);
    return sv;
}


/*
=for apidoc newSVpvn_flags

Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  The reference count for the
SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length
string.  You are responsible for ensuring that the source string is at least
C<len> bytes long.  If the C<s> argument is NULL the new SV will be undefined.
Currently the only flag bits accepted are C<SVf_UTF8> and C<SVs_TEMP>.
If C<SVs_TEMP> is set, then C<sv_2mortal()> is called on the result before
returning.  If C<SVf_UTF8> is set, C<s>
is considered to be in UTF-8 and the
C<SVf_UTF8> flag will be set on the new SV.
C<newSVpvn_utf8()> is a convenience wrapper for this function, defined as

    #define newSVpvn_utf8(s, len, u)			\
	newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

=cut
*/

SV *
Perl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)
{
    SV *sv;

    /* All the flags we don't support must be zero.
       And we're new code so I'm going to assert this from the start.  */
    assert(!(flags & ~(SVf_UTF8|SVs_TEMP)));
    new_SV(sv);
    sv_setpvn(sv,s,len);

    /* This code used to do a sv_2mortal(), however we now unroll the call to
     * sv_2mortal() and do what it does ourselves here.  Since we have asserted
     * that flags can only have the SVf_UTF8 and/or SVs_TEMP flags set above we
     * can use it to enable the sv flags directly (bypassing SvTEMP_on), which
     * in turn means we dont need to mask out the SVf_UTF8 flag below, which
     * means that we eliminate quite a few steps than it looks - Yves
     * (explaining patch by gfx) */

    SvFLAGS(sv) |= flags;

    if(flags & SVs_TEMP){
	PUSH_EXTEND_MORTAL__SV_C(sv);
    }

    return sv;
}

/*
=for apidoc sv_2mortal

Marks an existing SV as mortal.  The SV will be destroyed "soon", either
by an explicit call to C<FREETMPS>, or by an implicit call at places such as
statement boundaries.  C<SvTEMP()> is turned on which means that the SV's
string buffer can be "stolen" if this SV is copied.  See also
C<L</sv_newmortal>> and C<L</sv_mortalcopy>>.

=cut
*/

SV *
Perl_sv_2mortal(pTHX_ SV *const sv)
{
    dVAR;
    if (!sv)
	return sv;
    if (SvIMMORTAL(sv))
	return sv;
    PUSH_EXTEND_MORTAL__SV_C(sv);
    SvTEMP_on(sv);
    return sv;
}

/*
=for apidoc newSVpv

Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  The reference count for the
SV is set to 1.  If C<len> is zero, Perl will compute the length using
C<strlen()>, (which means if you use this option, that C<s> can't have embedded
C<NUL> characters and has to have a terminating C<NUL> byte).

For efficiency, consider using C<newSVpvn> instead.

=cut
*/

SV *
Perl_newSVpv(pTHX_ const char *const s, const STRLEN len)
{
    SV *sv;

    new_SV(sv);
    sv_setpvn(sv, s, len || s == NULL ? len : strlen(s));
    return sv;
}

/*
=for apidoc newSVpvn

Creates a new SV and copies a string into it, which may contain C<NUL> characters
(C<\0>) and other binary data.  The reference count for the SV is set to 1.
Note that if C<len> is zero, Perl will create a zero length (Perl) string.  You
are responsible for ensuring that the source buffer is at least
C<len> bytes long.  If the C<buffer> argument is NULL the new SV will be
undefined.

=cut
*/

SV *
Perl_newSVpvn(pTHX_ const char *const buffer, const STRLEN len)
{
    SV *sv;
    new_SV(sv);
    sv_setpvn(sv,buffer,len);
    return sv;
}

/*
=for apidoc newSVhek

Creates a new SV from the hash key structure.  It will generate scalars that
point to the shared string table where possible.  Returns a new (undefined)
SV if C<hek> is NULL.

=cut
*/

SV *
Perl_newSVhek(pTHX_ const HEK *const hek)
{
    if (!hek) {
	SV *sv;

	new_SV(sv);
	return sv;
    }

    if (HEK_LEN(hek) == HEf_SVKEY) {
	return newSVsv(*(SV**)HEK_KEY(hek));
    } else {
	const int flags = HEK_FLAGS(hek);
	if (flags & HVhek_WASUTF8) {
	    /* Trouble :-)
	       Andreas would like keys he put in as utf8 to come back as utf8
	    */
	    STRLEN utf8_len = HEK_LEN(hek);
	    SV * const sv = newSV_type(SVt_PV);
	    char *as_utf8 = (char *)bytes_to_utf8 ((U8*)HEK_KEY(hek), &utf8_len);
	    /* bytes_to_utf8() allocates a new string, which we can repurpose: */
	    sv_usepvn_flags(sv, as_utf8, utf8_len, SV_HAS_TRAILING_NUL);
	    SvUTF8_on (sv);
	    return sv;
        } else if (flags & HVhek_UNSHARED) {
            /* A hash that isn't using shared hash keys has to have
	       the flag in every key so that we know not to try to call
	       share_hek_hek on it.  */

	    SV * const sv = newSVpvn (HEK_KEY(hek), HEK_LEN(hek));
	    if (HEK_UTF8(hek))
		SvUTF8_on (sv);
	    return sv;
	}
	/* This will be overwhelminly the most common case.  */
	{
	    /* Inline most of newSVpvn_share(), because share_hek_hek() is far
	       more efficient than sharepvn().  */
	    SV *sv;

	    new_SV(sv);
	    sv_upgrade(sv, SVt_PV);
	    SvPV_set(sv, (char *)HEK_KEY(share_hek_hek(hek)));
	    SvCUR_set(sv, HEK_LEN(hek));
	    SvLEN_set(sv, 0);
	    SvIsCOW_on(sv);
	    SvPOK_on(sv);
	    if (HEK_UTF8(hek))
		SvUTF8_on(sv);
	    return sv;
	}
    }
}

/*
=for apidoc newSVpvn_share

Creates a new SV with its C<SvPVX_const> pointing to a shared string in the string
table.  If the string does not already exist in the table, it is
created first.  Turns on the C<SvIsCOW> flag (or C<READONLY>
and C<FAKE> in 5.16 and earlier).  If the C<hash> parameter
is non-zero, that value is used; otherwise the hash is computed.
The string's hash can later be retrieved from the SV
with the C<SvSHARED_HASH()> macro.  The idea here is
that as the string table is used for shared hash keys these strings will have
C<SvPVX_const == HeKEY> and hash lookup will avoid string compare.

=cut
*/

SV *
Perl_newSVpvn_share(pTHX_ const char *src, I32 len, U32 hash)
{
    dVAR;
    SV *sv;
    bool is_utf8 = FALSE;
    const char *const orig_src = src;

    if (len < 0) {
	STRLEN tmplen = -len;
        is_utf8 = TRUE;
	/* See the note in hv.c:hv_fetch() --jhi */
	src = (char*)bytes_from_utf8((const U8*)src, &tmplen, &is_utf8);
	len = tmplen;
    }
    if (!hash)
	PERL_HASH(hash, src, len);
    new_SV(sv);
    /* The logic for this is inlined in S_mro_get_linear_isa_dfs(), so if it
       changes here, update it there too.  */
    sv_upgrade(sv, SVt_PV);
    SvPV_set(sv, sharepvn(src, is_utf8?-len:len, hash));
    SvCUR_set(sv, len);
    SvLEN_set(sv, 0);
    SvIsCOW_on(sv);
    SvPOK_on(sv);
    if (is_utf8)
        SvUTF8_on(sv);
    if (src != orig_src)
	Safefree(src);
    return sv;
}

/*
=for apidoc newSVpv_share

Like C<newSVpvn_share>, but takes a C<NUL>-terminated string instead of a
string/length pair.

=cut
*/

SV *
Perl_newSVpv_share(pTHX_ const char *src, U32 hash)
{
    return newSVpvn_share(src, strlen(src), hash);
}

#if defined(PERL_IMPLICIT_CONTEXT)

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

SV *
Perl_newSVpvf_nocontext(const char *const pat, ...)
{
    dTHX;
    SV *sv;
    va_list args;

    PERL_ARGS_ASSERT_NEWSVPVF_NOCONTEXT;

    va_start(args, pat);
    sv = vnewSVpvf(pat, &args);
    va_end(args);
    return sv;
}
#endif

/*
=for apidoc newSVpvf

Creates a new SV and initializes it with the string formatted like
C<sv_catpvf>.

=cut
*/

SV *
Perl_newSVpvf(pTHX_ const char *const pat, ...)
{
    SV *sv;
    va_list args;

    PERL_ARGS_ASSERT_NEWSVPVF;

    va_start(args, pat);
    sv = vnewSVpvf(pat, &args);
    va_end(args);
    return sv;
}

/* backend for newSVpvf() and newSVpvf_nocontext() */

SV *
Perl_vnewSVpvf(pTHX_ const char *const pat, va_list *const args)
{
    SV *sv;

    PERL_ARGS_ASSERT_VNEWSVPVF;

    new_SV(sv);
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
    return sv;
}

/*
=for apidoc newSVnv

Creates a new SV and copies a floating point value into it.
The reference count for the SV is set to 1.

=cut
*/

SV *
Perl_newSVnv(pTHX_ const NV n)
{
    SV *sv;

    new_SV(sv);
    sv_setnv(sv,n);
    return sv;
}

/*
=for apidoc newSViv

Creates a new SV and copies an integer into it.  The reference count for the
SV is set to 1.

=cut
*/

SV *
Perl_newSViv(pTHX_ const IV i)
{
    SV *sv;

    new_SV(sv);

    /* Inlining ONLY the small relevant subset of sv_setiv here
     * for performance. Makes a significant difference. */

    /* We're starting from SVt_FIRST, so provided that's
     * actual 0, we don't have to unset any SV type flags
     * to promote to SVt_IV. */
    STATIC_ASSERT_STMT(SVt_FIRST == 0);

    SET_SVANY_FOR_BODYLESS_IV(sv);
    SvFLAGS(sv) |= SVt_IV;
    (void)SvIOK_on(sv);

    SvIV_set(sv, i);
    SvTAINT(sv);

    return sv;
}

/*
=for apidoc newSVuv

Creates a new SV and copies an unsigned integer into it.
The reference count for the SV is set to 1.

=cut
*/

SV *
Perl_newSVuv(pTHX_ const UV u)
{
    SV *sv;

    /* Inlining ONLY the small relevant subset of sv_setuv here
     * for performance. Makes a significant difference. */

    /* Using ivs is more efficient than using uvs - see sv_setuv */
    if (u <= (UV)IV_MAX) {
	return newSViv((IV)u);
    }

    new_SV(sv);

    /* We're starting from SVt_FIRST, so provided that's
     * actual 0, we don't have to unset any SV type flags
     * to promote to SVt_IV. */
    STATIC_ASSERT_STMT(SVt_FIRST == 0);

    SET_SVANY_FOR_BODYLESS_IV(sv);
    SvFLAGS(sv) |= SVt_IV;
    (void)SvIOK_on(sv);
    (void)SvIsUV_on(sv);

    SvUV_set(sv, u);
    SvTAINT(sv);

    return sv;
}

/*
=for apidoc newSV_type

Creates a new SV, of the type specified.  The reference count for the new SV
is set to 1.

=cut
*/

SV *
Perl_newSV_type(pTHX_ const svtype type)
{
    SV *sv;

    new_SV(sv);
    ASSUME(SvTYPE(sv) == SVt_FIRST);
    if(type != SVt_FIRST)
	sv_upgrade(sv, type);
    return sv;
}

/*
=for apidoc newRV_noinc

Creates an RV wrapper for an SV.  The reference count for the original
SV is B<not> incremented.

=cut
*/

SV *
Perl_newRV_noinc(pTHX_ SV *const tmpRef)
{
    SV *sv;

    PERL_ARGS_ASSERT_NEWRV_NOINC;

    new_SV(sv);

    /* We're starting from SVt_FIRST, so provided that's
     * actual 0, we don't have to unset any SV type flags
     * to promote to SVt_IV. */
    STATIC_ASSERT_STMT(SVt_FIRST == 0);

    SET_SVANY_FOR_BODYLESS_IV(sv);
    SvFLAGS(sv) |= SVt_IV;
    SvROK_on(sv);
    SvIV_set(sv, 0);

    SvTEMP_off(tmpRef);
    SvRV_set(sv, tmpRef);

    return sv;
}

/* newRV_inc is the official function name to use now.
 * newRV_inc is in fact #defined to newRV in sv.h
 */

SV *
Perl_newRV(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_NEWRV;

    return newRV_noinc(SvREFCNT_inc_simple_NN(sv));
}

/*
=for apidoc newSVsv

Creates a new SV which is an exact duplicate of the original SV.
(Uses C<sv_setsv>.)

=cut
*/

SV *
Perl_newSVsv(pTHX_ SV *const old)
{
    SV *sv;

    if (!old)
	return NULL;
    if (SvTYPE(old) == (svtype)SVTYPEMASK) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "semi-panic: attempt to dup freed string");
	return NULL;
    }
    /* Do this here, otherwise we leak the new SV if this croaks. */
    SvGETMAGIC(old);
    new_SV(sv);
    /* SV_NOSTEAL prevents TEMP buffers being, well, stolen, and saves games
       with SvTEMP_off and SvTEMP_on round a call to sv_setsv.  */
    sv_setsv_flags(sv, old, SV_NOSTEAL);
    return sv;
}

/*
=for apidoc sv_reset

Underlying implementation for the C<reset> Perl function.
Note that the perl-level function is vaguely deprecated.

=cut
*/

void
Perl_sv_reset(pTHX_ const char *s, HV *const stash)
{
    PERL_ARGS_ASSERT_SV_RESET;

    sv_resetpvn(*s ? s : NULL, strlen(s), stash);
}

void
Perl_sv_resetpvn(pTHX_ const char *s, STRLEN len, HV * const stash)
{
    char todo[PERL_UCHAR_MAX+1];
    const char *send;

    if (!stash || SvTYPE(stash) != SVt_PVHV)
	return;

    if (!s) {		/* reset ?? searches */
	MAGIC * const mg = mg_find((const SV *)stash, PERL_MAGIC_symtab);
	if (mg) {
	    const U32 count = mg->mg_len / sizeof(PMOP**);
	    PMOP **pmp = (PMOP**) mg->mg_ptr;
	    PMOP *const *const end = pmp + count;

	    while (pmp < end) {
#ifdef USE_ITHREADS
                SvREADONLY_off(PL_regex_pad[(*pmp)->op_pmoffset]);
#else
		(*pmp)->op_pmflags &= ~PMf_USED;
#endif
		++pmp;
	    }
	}
	return;
    }

    /* reset variables */

    if (!HvARRAY(stash))
	return;

    Zero(todo, 256, char);
    send = s + len;
    while (s < send) {
	I32 max;
	I32 i = (unsigned char)*s;
	if (s[1] == '-') {
	    s += 2;
	}
	max = (unsigned char)*s++;
	for ( ; i <= max; i++) {
	    todo[i] = 1;
	}
	for (i = 0; i <= (I32) HvMAX(stash); i++) {
	    HE *entry;
	    for (entry = HvARRAY(stash)[i];
		 entry;
		 entry = HeNEXT(entry))
	    {
		GV *gv;
		SV *sv;

		if (!todo[(U8)*HeKEY(entry)])
		    continue;
		gv = MUTABLE_GV(HeVAL(entry));
		sv = GvSV(gv);
		if (sv && !SvREADONLY(sv)) {
		    SV_CHECK_THINKFIRST_COW_DROP(sv);
		    if (!isGV(sv)) SvOK_off(sv);
		}
		if (GvAV(gv)) {
		    av_clear(GvAV(gv));
		}
		if (GvHV(gv) && !HvNAME_get(GvHV(gv))) {
		    hv_clear(GvHV(gv));
		}
	    }
	}
    }
}

/*
=for apidoc sv_2io

Using various gambits, try to get an IO from an SV: the IO slot if its a
GV; or the recursive result if we're an RV; or the IO slot of the symbol
named after the PV if we're a string.

'Get' magic is ignored on the C<sv> passed in, but will be called on
C<SvRV(sv)> if C<sv> is an RV.

=cut
*/

IO*
Perl_sv_2io(pTHX_ SV *const sv)
{
    IO* io;
    GV* gv;

    PERL_ARGS_ASSERT_SV_2IO;

    switch (SvTYPE(sv)) {
    case SVt_PVIO:
	io = MUTABLE_IO(sv);
	break;
    case SVt_PVGV:
    case SVt_PVLV:
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	    io = GvIO(gv);
	    if (!io)
		Perl_croak(aTHX_ "Bad filehandle: %"HEKf,
                                    HEKfARG(GvNAME_HEK(gv)));
	    break;
	}
	/* FALLTHROUGH */
    default:
	if (!SvOK(sv))
	    Perl_croak(aTHX_ PL_no_usym, "filehandle");
	if (SvROK(sv)) {
	    SvGETMAGIC(SvRV(sv));
	    return sv_2io(SvRV(sv));
	}
	gv = gv_fetchsv_nomg(sv, 0, SVt_PVIO);
	if (gv)
	    io = GvIO(gv);
	else
	    io = 0;
	if (!io) {
	    SV *newsv = sv;
	    if (SvGMAGICAL(sv)) {
		newsv = sv_newmortal();
		sv_setsv_nomg(newsv, sv);
	    }
	    Perl_croak(aTHX_ "Bad filehandle: %"SVf, SVfARG(newsv));
	}
	break;
    }
    return io;
}

/*
=for apidoc sv_2cv

Using various gambits, try to get a CV from an SV; in addition, try if
possible to set C<*st> and C<*gvp> to the stash and GV associated with it.
The flags in C<lref> are passed to C<gv_fetchsv>.

=cut
*/

CV *
Perl_sv_2cv(pTHX_ SV *sv, HV **const st, GV **const gvp, const I32 lref)
{
    GV *gv = NULL;
    CV *cv = NULL;

    PERL_ARGS_ASSERT_SV_2CV;

    if (!sv) {
	*st = NULL;
	*gvp = NULL;
	return NULL;
    }
    switch (SvTYPE(sv)) {
    case SVt_PVCV:
	*st = CvSTASH(sv);
	*gvp = NULL;
	return MUTABLE_CV(sv);
    case SVt_PVHV:
    case SVt_PVAV:
	*st = NULL;
	*gvp = NULL;
	return NULL;
    default:
	SvGETMAGIC(sv);
	if (SvROK(sv)) {
	    if (SvAMAGIC(sv))
		sv = amagic_deref_call(sv, to_cv_amg);

	    sv = SvRV(sv);
	    if (SvTYPE(sv) == SVt_PVCV) {
		cv = MUTABLE_CV(sv);
		*gvp = NULL;
		*st = CvSTASH(cv);
		return cv;
	    }
	    else if(SvGETMAGIC(sv), isGV_with_GP(sv))
		gv = MUTABLE_GV(sv);
	    else
		Perl_croak(aTHX_ "Not a subroutine reference");
	}
	else if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	}
	else {
	    gv = gv_fetchsv_nomg(sv, lref, SVt_PVCV);
	}
	*gvp = gv;
	if (!gv) {
	    *st = NULL;
	    return NULL;
	}
	/* Some flags to gv_fetchsv mean don't really create the GV  */
	if (!isGV_with_GP(gv)) {
	    *st = NULL;
	    return NULL;
	}
	*st = GvESTASH(gv);
	if (lref & ~GV_ADDMG && !GvCVu(gv)) {
	    /* XXX this is probably not what they think they're getting.
	     * It has the same effect as "sub name;", i.e. just a forward
	     * declaration! */
	    newSTUB(gv,0);
	}
	return GvCVu(gv);
    }
}

/*
=for apidoc sv_true

Returns true if the SV has a true value by Perl's rules.
Use the C<SvTRUE> macro instead, which may call C<sv_true()> or may
instead use an in-line version.

=cut
*/

I32
Perl_sv_true(pTHX_ SV *const sv)
{
    if (!sv)
	return 0;
    if (SvPOK(sv)) {
	const XPV* const tXpv = (XPV*)SvANY(sv);
	if (tXpv &&
		(tXpv->xpv_cur > 1 ||
		(tXpv->xpv_cur && *sv->sv_u.svu_pv != '0')))
	    return 1;
	else
	    return 0;
    }
    else {
	if (SvIOK(sv))
	    return SvIVX(sv) != 0;
	else {
	    if (SvNOK(sv))
		return SvNVX(sv) != 0.0;
	    else
		return sv_2bool(sv);
	}
    }
}

/*
=for apidoc sv_pvn_force

Get a sensible string out of the SV somehow.
A private implementation of the C<SvPV_force> macro for compilers which
can't cope with complex macro expressions.  Always use the macro instead.

=for apidoc sv_pvn_force_flags

Get a sensible string out of the SV somehow.
If C<flags> has the C<SV_GMAGIC> bit set, will C<mg_get> on C<sv> if
appropriate, else not.  C<sv_pvn_force> and C<sv_pvn_force_nomg> are
implemented in terms of this function.
You normally want to use the various wrapper macros instead: see
C<L</SvPV_force>> and C<L</SvPV_force_nomg>>.

=cut
*/

char *
Perl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS;

    if (flags & SV_GMAGIC) SvGETMAGIC(sv);
    if (SvTHINKFIRST(sv) && (!SvROK(sv) || SvREADONLY(sv)))
        sv_force_normal_flags(sv, 0);

    if (SvPOK(sv)) {
	if (lp)
	    *lp = SvCUR(sv);
    }
    else {
	char *s;
	STRLEN len;
 
	if (SvTYPE(sv) > SVt_PVLV
	    || isGV_with_GP(sv))
	    /* diag_listed_as: Can't coerce %s to %s in %s */
	    Perl_croak(aTHX_ "Can't coerce %s to string in %s", sv_reftype(sv,0),
		OP_DESC(PL_op));
	s = sv_2pv_flags(sv, &len, flags &~ SV_GMAGIC);
	if (!s) {
	  s = (char *)"";
	}
	if (lp)
	    *lp = len;

        if (SvTYPE(sv) < SVt_PV ||
            s != SvPVX_const(sv)) {	/* Almost, but not quite, sv_setpvn() */
	    if (SvROK(sv))
		sv_unref(sv);
	    SvUPGRADE(sv, SVt_PV);		/* Never FALSE */
	    SvGROW(sv, len + 1);
	    Move(s,SvPVX(sv),len,char);
	    SvCUR_set(sv, len);
	    SvPVX(sv)[len] = '\0';
	}
	if (!SvPOK(sv)) {
	    SvPOK_on(sv);		/* validate pointer */
	    SvTAINT(sv);
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2pv(%s)\n",
				  PTR2UV(sv),SvPVX_const(sv)));
	}
    }
    (void)SvPOK_only_UTF8(sv);
    return SvPVX_mutable(sv);
}

/*
=for apidoc sv_pvbyten_force

The backend for the C<SvPVbytex_force> macro.  Always use the macro
instead.

=cut
*/

char *
Perl_sv_pvbyten_force(pTHX_ SV *const sv, STRLEN *const lp)
{
    PERL_ARGS_ASSERT_SV_PVBYTEN_FORCE;

    sv_pvn_force(sv,lp);
    sv_utf8_downgrade(sv,0);
    *lp = SvCUR(sv);
    return SvPVX(sv);
}

/*
=for apidoc sv_pvutf8n_force

The backend for the C<SvPVutf8x_force> macro.  Always use the macro
instead.

=cut
*/

char *
Perl_sv_pvutf8n_force(pTHX_ SV *const sv, STRLEN *const lp)
{
    PERL_ARGS_ASSERT_SV_PVUTF8N_FORCE;

    sv_pvn_force(sv,0);
    sv_utf8_upgrade_nomg(sv);
    *lp = SvCUR(sv);
    return SvPVX(sv);
}

/*
=for apidoc sv_reftype

Returns a string describing what the SV is a reference to.

If ob is true and the SV is blessed, the string is the class name,
otherwise it is the type of the SV, "SCALAR", "ARRAY" etc.

=cut
*/

const char *
Perl_sv_reftype(pTHX_ const SV *const sv, const int ob)
{
    PERL_ARGS_ASSERT_SV_REFTYPE;
    if (ob && SvOBJECT(sv)) {
	return SvPV_nolen_const(sv_ref(NULL, sv, ob));
    }
    else {
        /* WARNING - There is code, for instance in mg.c, that assumes that
         * the only reason that sv_reftype(sv,0) would return a string starting
         * with 'L' or 'S' is that it is a LVALUE or a SCALAR.
         * Yes this a dodgy way to do type checking, but it saves practically reimplementing
         * this routine inside other subs, and it saves time.
         * Do not change this assumption without searching for "dodgy type check" in
         * the code.
         * - Yves */
	switch (SvTYPE(sv)) {
	case SVt_NULL:
	case SVt_IV:
	case SVt_NV:
	case SVt_PV:
	case SVt_PVIV:
	case SVt_PVNV:
	case SVt_PVMG:
				if (SvVOK(sv))
				    return "VSTRING";
				if (SvROK(sv))
				    return "REF";
				else
				    return "SCALAR";

	case SVt_PVLV:		return (char *)  (SvROK(sv) ? "REF"
				/* tied lvalues should appear to be
				 * scalars for backwards compatibility */
				: (isALPHA_FOLD_EQ(LvTYPE(sv), 't'))
				    ? "SCALAR" : "LVALUE");
	case SVt_PVAV:		return "ARRAY";
	case SVt_PVHV:		return "HASH";
	case SVt_PVCV:		return "CODE";
	case SVt_PVGV:		return (char *) (isGV_with_GP(sv)
				    ? "GLOB" : "SCALAR");
	case SVt_PVFM:		return "FORMAT";
	case SVt_PVIO:		return "IO";
	case SVt_INVLIST:	return "INVLIST";
	case SVt_REGEXP:	return "REGEXP";
	default:		return "UNKNOWN";
	}
    }
}

/*
=for apidoc sv_ref

Returns a SV describing what the SV passed in is a reference to.

dst can be a SV to be set to the description or NULL, in which case a
mortal SV is returned.

If ob is true and the SV is blessed, the description is the class
name, otherwise it is the type of the SV, "SCALAR", "ARRAY" etc.

=cut
*/

SV *
Perl_sv_ref(pTHX_ SV *dst, const SV *const sv, const int ob)
{
    PERL_ARGS_ASSERT_SV_REF;

    if (!dst)
        dst = sv_newmortal();

    if (ob && SvOBJECT(sv)) {
	HvNAME_get(SvSTASH(sv))
                    ? sv_sethek(dst, HvNAME_HEK(SvSTASH(sv)))
                    : sv_setpvn(dst, "__ANON__", 8);
    }
    else {
        const char * reftype = sv_reftype(sv, 0);
        sv_setpv(dst, reftype);
    }
    return dst;
}

/*
=for apidoc sv_isobject

Returns a boolean indicating whether the SV is an RV pointing to a blessed
object.  If the SV is not an RV, or if the object is not blessed, then this
will return false.

=cut
*/

int
Perl_sv_isobject(pTHX_ SV *sv)
{
    if (!sv)
	return 0;
    SvGETMAGIC(sv);
    if (!SvROK(sv))
	return 0;
    sv = SvRV(sv);
    if (!SvOBJECT(sv))
	return 0;
    return 1;
}

/*
=for apidoc sv_isa

Returns a boolean indicating whether the SV is blessed into the specified
class.  This does not check for subtypes; use C<sv_derived_from> to verify
an inheritance relationship.

=cut
*/

int
Perl_sv_isa(pTHX_ SV *sv, const char *const name)
{
    const char *hvname;

    PERL_ARGS_ASSERT_SV_ISA;

    if (!sv)
	return 0;
    SvGETMAGIC(sv);
    if (!SvROK(sv))
	return 0;
    sv = SvRV(sv);
    if (!SvOBJECT(sv))
	return 0;
    hvname = HvNAME_get(SvSTASH(sv));
    if (!hvname)
	return 0;

    return strEQ(hvname, name);
}

/*
=for apidoc newSVrv

Creates a new SV for the existing RV, C<rv>, to point to.  If C<rv> is not an
RV then it will be upgraded to one.  If C<classname> is non-null then the new
SV will be blessed in the specified package.  The new SV is returned and its
reference count is 1.  The reference count 1 is owned by C<rv>.

=cut
*/

SV*
Perl_newSVrv(pTHX_ SV *const rv, const char *const classname)
{
    SV *sv;

    PERL_ARGS_ASSERT_NEWSVRV;

    new_SV(sv);

    SV_CHECK_THINKFIRST_COW_DROP(rv);

    if (UNLIKELY( SvTYPE(rv) >= SVt_PVMG )) {
	const U32 refcnt = SvREFCNT(rv);
	SvREFCNT(rv) = 0;
	sv_clear(rv);
	SvFLAGS(rv) = 0;
	SvREFCNT(rv) = refcnt;

	sv_upgrade(rv, SVt_IV);
    } else if (SvROK(rv)) {
	SvREFCNT_dec(SvRV(rv));
    } else {
	prepare_SV_for_RV(rv);
    }

    SvOK_off(rv);
    SvRV_set(rv, sv);
    SvROK_on(rv);

    if (classname) {
	HV* const stash = gv_stashpv(classname, GV_ADD);
	(void)sv_bless(rv, stash);
    }
    return sv;
}

SV *
Perl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)
{
    SV * const lv = newSV_type(SVt_PVLV);
    PERL_ARGS_ASSERT_NEWSVAVDEFELEM;
    LvTYPE(lv) = 'y';
    sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
    LvTARG(lv) = SvREFCNT_inc_simple_NN(av);
    LvSTARGOFF(lv) = ix;
    LvTARGLEN(lv) = extendible ? 1 : (STRLEN)UV_MAX;
    return lv;
}

/*
=for apidoc sv_setref_pv

Copies a pointer into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  If the C<pv> argument is C<NULL>, then C<PL_sv_undef> will be placed
into the SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
will have a reference count of 1, and the RV will be returned.

Do not use with other Perl types such as HV, AV, SV, CV, because those
objects will become corrupted by the pointer copy process.

Note that C<sv_setref_pvn> copies the string while this copies the pointer.

=cut
*/

SV*
Perl_sv_setref_pv(pTHX_ SV *const rv, const char *const classname, void *const pv)
{
    PERL_ARGS_ASSERT_SV_SETREF_PV;

    if (!pv) {
	sv_setsv(rv, &PL_sv_undef);
	SvSETMAGIC(rv);
    }
    else
	sv_setiv(newSVrv(rv,classname), PTR2IV(pv));
    return rv;
}

/*
=for apidoc sv_setref_iv

Copies an integer into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
will have a reference count of 1, and the RV will be returned.

=cut
*/

SV*
Perl_sv_setref_iv(pTHX_ SV *const rv, const char *const classname, const IV iv)
{
    PERL_ARGS_ASSERT_SV_SETREF_IV;

    sv_setiv(newSVrv(rv,classname), iv);
    return rv;
}

/*
=for apidoc sv_setref_uv

Copies an unsigned integer into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
will have a reference count of 1, and the RV will be returned.

=cut
*/

SV*
Perl_sv_setref_uv(pTHX_ SV *const rv, const char *const classname, const UV uv)
{
    PERL_ARGS_ASSERT_SV_SETREF_UV;

    sv_setuv(newSVrv(rv,classname), uv);
    return rv;
}

/*
=for apidoc sv_setref_nv

Copies a double into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
will have a reference count of 1, and the RV will be returned.

=cut
*/

SV*
Perl_sv_setref_nv(pTHX_ SV *const rv, const char *const classname, const NV nv)
{
    PERL_ARGS_ASSERT_SV_SETREF_NV;

    sv_setnv(newSVrv(rv,classname), nv);
    return rv;
}

/*
=for apidoc sv_setref_pvn

Copies a string into a new SV, optionally blessing the SV.  The length of the
string must be specified with C<n>.  The C<rv> argument will be upgraded to
an RV.  That RV will be modified to point to the new SV.  The C<classname>
argument indicates the package for the blessing.  Set C<classname> to
C<NULL> to avoid the blessing.  The new SV will have a reference count
of 1, and the RV will be returned.

Note that C<sv_setref_pv> copies the pointer while this copies the string.

=cut
*/

SV*
Perl_sv_setref_pvn(pTHX_ SV *const rv, const char *const classname,
                   const char *const pv, const STRLEN n)
{
    PERL_ARGS_ASSERT_SV_SETREF_PVN;

    sv_setpvn(newSVrv(rv,classname), pv, n);
    return rv;
}

/*
=for apidoc sv_bless

Blesses an SV into a specified package.  The SV must be an RV.  The package
must be designated by its stash (see C<L</gv_stashpv>>).  The reference count
of the SV is unaffected.

=cut
*/

SV*
Perl_sv_bless(pTHX_ SV *const sv, HV *const stash)
{
    SV *tmpRef;
    HV *oldstash = NULL;

    PERL_ARGS_ASSERT_SV_BLESS;

    SvGETMAGIC(sv);
    if (!SvROK(sv))
        Perl_croak(aTHX_ "Can't bless non-reference value");
    tmpRef = SvRV(sv);
    if (SvFLAGS(tmpRef) & (SVs_OBJECT|SVf_READONLY|SVf_PROTECT)) {
	if (SvREADONLY(tmpRef))
	    Perl_croak_no_modify();
	if (SvOBJECT(tmpRef)) {
	    oldstash = SvSTASH(tmpRef);
	}
    }
    SvOBJECT_on(tmpRef);
    SvUPGRADE(tmpRef, SVt_PVMG);
    SvSTASH_set(tmpRef, MUTABLE_HV(SvREFCNT_inc_simple(stash)));
    SvREFCNT_dec(oldstash);

    if(SvSMAGICAL(tmpRef))
        if(mg_find(tmpRef, PERL_MAGIC_ext) || mg_find(tmpRef, PERL_MAGIC_uvar))
            mg_set(tmpRef);



    return sv;
}

/* Downgrades a PVGV to a PVMG. If it's actually a PVLV, we leave the type
 * as it is after unglobbing it.
 */

PERL_STATIC_INLINE void
S_sv_unglob(pTHX_ SV *const sv, U32 flags)
{
    void *xpvmg;
    HV *stash;
    SV * const temp = flags & SV_COW_DROP_PV ? NULL : sv_newmortal();

    PERL_ARGS_ASSERT_SV_UNGLOB;

    assert(SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV);
    SvFAKE_off(sv);
    if (!(flags & SV_COW_DROP_PV))
	gv_efullname3(temp, MUTABLE_GV(sv), "*");

    SvREFCNT_inc_simple_void_NN(sv_2mortal(sv));
    if (GvGP(sv)) {
        if(GvCVu((const GV *)sv) && (stash = GvSTASH(MUTABLE_GV(sv)))
	   && HvNAME_get(stash))
            mro_method_changed_in(stash);
	gp_free(MUTABLE_GV(sv));
    }
    if (GvSTASH(sv)) {
	sv_del_backref(MUTABLE_SV(GvSTASH(sv)), sv);
	GvSTASH(sv) = NULL;
    }
    GvMULTI_off(sv);
    if (GvNAME_HEK(sv)) {
	unshare_hek(GvNAME_HEK(sv));
    }
    isGV_with_GP_off(sv);

    if(SvTYPE(sv) == SVt_PVGV) {
	/* need to keep SvANY(sv) in the right arena */
	xpvmg = new_XPVMG();
	StructCopy(SvANY(sv), xpvmg, XPVMG);
	del_XPVGV(SvANY(sv));
	SvANY(sv) = xpvmg;

	SvFLAGS(sv) &= ~SVTYPEMASK;
	SvFLAGS(sv) |= SVt_PVMG;
    }

    /* Intentionally not calling any local SET magic, as this isn't so much a
       set operation as merely an internal storage change.  */
    if (flags & SV_COW_DROP_PV) SvOK_off(sv);
    else sv_setsv_flags(sv, temp, 0);

    if ((const GV *)sv == PL_last_in_gv)
	PL_last_in_gv = NULL;
    else if ((const GV *)sv == PL_statgv)
	PL_statgv = NULL;
}

/*
=for apidoc sv_unref_flags

Unsets the RV status of the SV, and decrements the reference count of
whatever was being referenced by the RV.  This can almost be thought of
as a reversal of C<newSVrv>.  The C<cflags> argument can contain
C<SV_IMMEDIATE_UNREF> to force the reference count to be decremented
(otherwise the decrementing is conditional on the reference count being
different from one or the reference being a readonly SV).
See C<L</SvROK_off>>.

=cut
*/

void
Perl_sv_unref_flags(pTHX_ SV *const ref, const U32 flags)
{
    SV* const target = SvRV(ref);

    PERL_ARGS_ASSERT_SV_UNREF_FLAGS;

    if (SvWEAKREF(ref)) {
    	sv_del_backref(target, ref);
	SvWEAKREF_off(ref);
	SvRV_set(ref, NULL);
	return;
    }
    SvRV_set(ref, NULL);
    SvROK_off(ref);
    /* You can't have a || SvREADONLY(target) here, as $a = $$a, where $a was
       assigned to as BEGIN {$a = \"Foo"} will fail.  */
    if (SvREFCNT(target) != 1 || (flags & SV_IMMEDIATE_UNREF))
	SvREFCNT_dec_NN(target);
    else /* XXX Hack, but hard to make $a=$a->[1] work otherwise */
	sv_2mortal(target);	/* Schedule for freeing later */
}

/*
=for apidoc sv_untaint

Untaint an SV.  Use C<SvTAINTED_off> instead.

=cut
*/

void
Perl_sv_untaint(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_SV_UNTAINT;
    PERL_UNUSED_CONTEXT;

    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	MAGIC * const mg = mg_find(sv, PERL_MAGIC_taint);
	if (mg)
	    mg->mg_len &= ~1;
    }
}

/*
=for apidoc sv_tainted

Test an SV for taintedness.  Use C<SvTAINTED> instead.

=cut
*/

bool
Perl_sv_tainted(pTHX_ SV *const sv)
{
    PERL_ARGS_ASSERT_SV_TAINTED;
    PERL_UNUSED_CONTEXT;

    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	const MAGIC * const mg = mg_find(sv, PERL_MAGIC_taint);
	if (mg && (mg->mg_len & 1) )
	    return TRUE;
    }
    return FALSE;
}

/*
=for apidoc sv_setpviv

Copies an integer into the given SV, also updating its string value.
Does not handle 'set' magic.  See C<L</sv_setpviv_mg>>.

=cut
*/

void
Perl_sv_setpviv(pTHX_ SV *const sv, const IV iv)
{
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char * const ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    PERL_ARGS_ASSERT_SV_SETPVIV;

    sv_setpvn(sv, ptr, ebuf - ptr);
}

/*
=for apidoc sv_setpviv_mg

Like C<sv_setpviv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setpviv_mg(pTHX_ SV *const sv, const IV iv)
{
    PERL_ARGS_ASSERT_SV_SETPVIV_MG;

    sv_setpviv(sv, iv);
    SvSETMAGIC(sv);
}

#if defined(PERL_IMPLICIT_CONTEXT)

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

void
Perl_sv_setpvf_nocontext(SV *const sv, const char *const pat, ...)
{
    dTHX;
    va_list args;

    PERL_ARGS_ASSERT_SV_SETPVF_NOCONTEXT;

    va_start(args, pat);
    sv_vsetpvf(sv, pat, &args);
    va_end(args);
}

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

void
Perl_sv_setpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
{
    dTHX;
    va_list args;

    PERL_ARGS_ASSERT_SV_SETPVF_MG_NOCONTEXT;

    va_start(args, pat);
    sv_vsetpvf_mg(sv, pat, &args);
    va_end(args);
}
#endif

/*
=for apidoc sv_setpvf

Works like C<sv_catpvf> but copies the text into the SV instead of
appending it.  Does not handle 'set' magic.  See C<L</sv_setpvf_mg>>.

=cut
*/

void
Perl_sv_setpvf(pTHX_ SV *const sv, const char *const pat, ...)
{
    va_list args;

    PERL_ARGS_ASSERT_SV_SETPVF;

    va_start(args, pat);
    sv_vsetpvf(sv, pat, &args);
    va_end(args);
}

/*
=for apidoc sv_vsetpvf

Works like C<sv_vcatpvf> but copies the text into the SV instead of
appending it.  Does not handle 'set' magic.  See C<L</sv_vsetpvf_mg>>.

Usually used via its frontend C<sv_setpvf>.

=cut
*/

void
Perl_sv_vsetpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args)
{
    PERL_ARGS_ASSERT_SV_VSETPVF;

    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
}

/*
=for apidoc sv_setpvf_mg

Like C<sv_setpvf>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
{
    va_list args;

    PERL_ARGS_ASSERT_SV_SETPVF_MG;

    va_start(args, pat);
    sv_vsetpvf_mg(sv, pat, &args);
    va_end(args);
}

/*
=for apidoc sv_vsetpvf_mg

Like C<sv_vsetpvf>, but also handles 'set' magic.

Usually used via its frontend C<sv_setpvf_mg>.

=cut
*/

void
Perl_sv_vsetpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args)
{
    PERL_ARGS_ASSERT_SV_VSETPVF_MG;

    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
    SvSETMAGIC(sv);
}

#if defined(PERL_IMPLICIT_CONTEXT)

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

void
Perl_sv_catpvf_nocontext(SV *const sv, const char *const pat, ...)
{
    dTHX;
    va_list args;

    PERL_ARGS_ASSERT_SV_CATPVF_NOCONTEXT;

    va_start(args, pat);
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
    va_end(args);
}

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

void
Perl_sv_catpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
{
    dTHX;
    va_list args;

    PERL_ARGS_ASSERT_SV_CATPVF_MG_NOCONTEXT;

    va_start(args, pat);
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
    SvSETMAGIC(sv);
    va_end(args);
}
#endif

/*
=for apidoc sv_catpvf

Processes its arguments like C<sv_catpvfn>, and appends the formatted
output to an SV.  As with C<sv_catpvfn> called with a non-null C-style
variable argument list, argument reordering is not supported.
If the appended data contains "wide" characters
(including, but not limited to, SVs with a UTF-8 PV formatted with C<%s>,
and characters >255 formatted with C<%c>), the original SV might get
upgraded to UTF-8.  Handles 'get' magic, but not 'set' magic.  See
C<L</sv_catpvf_mg>>.  If the original SV was UTF-8, the pattern should be
valid UTF-8; if the original SV was bytes, the pattern should be too.

=cut */

void
Perl_sv_catpvf(pTHX_ SV *const sv, const char *const pat, ...)
{
    va_list args;

    PERL_ARGS_ASSERT_SV_CATPVF;

    va_start(args, pat);
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
    va_end(args);
}

/*
=for apidoc sv_vcatpvf

Processes its arguments like C<sv_catpvfn> called with a non-null C-style
variable argument list, and appends the formatted
to an SV.  Does not handle 'set' magic.  See C<L</sv_vcatpvf_mg>>.

Usually used via its frontend C<sv_catpvf>.

=cut
*/

void
Perl_sv_vcatpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args)
{
    PERL_ARGS_ASSERT_SV_VCATPVF;

    sv_vcatpvfn_flags(sv, pat, strlen(pat), args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
}

/*
=for apidoc sv_catpvf_mg

Like C<sv_catpvf>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
{
    va_list args;

    PERL_ARGS_ASSERT_SV_CATPVF_MG;

    va_start(args, pat);
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
    SvSETMAGIC(sv);
    va_end(args);
}

/*
=for apidoc sv_vcatpvf_mg

Like C<sv_vcatpvf>, but also handles 'set' magic.

Usually used via its frontend C<sv_catpvf_mg>.

=cut
*/

void
Perl_sv_vcatpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args)
{
    PERL_ARGS_ASSERT_SV_VCATPVF_MG;

    sv_vcatpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
    SvSETMAGIC(sv);
}

/*
=for apidoc sv_vsetpvfn

Works like C<sv_vcatpvfn> but copies the text into the SV instead of
appending it.

Usually used via one of its frontends C<sv_vsetpvf> and C<sv_vsetpvf_mg>.

=cut
*/

void
Perl_sv_vsetpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen,
                 va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted)
{
    PERL_ARGS_ASSERT_SV_VSETPVFN;

    sv_setpvs(sv, "");
    sv_vcatpvfn_flags(sv, pat, patlen, args, svargs, svmax, maybe_tainted, 0);
}


/*
 * Warn of missing argument to sprintf. The value used in place of such
 * arguments should be &PL_sv_no; an undefined value would yield
 * inappropriate "use of uninit" warnings [perl #71000].
 */
STATIC void
S_warn_vcatpvfn_missing_argument(pTHX) {
    if (ckWARN(WARN_MISSING)) {
	Perl_warner(aTHX_ packWARN(WARN_MISSING), "Missing argument in %s",
		PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn()");
    }
}


STATIC I32
S_expect_number(pTHX_ char **const pattern)
{
    I32 var = 0;

    PERL_ARGS_ASSERT_EXPECT_NUMBER;

    switch (**pattern) {
    case '1': case '2': case '3':
    case '4': case '5': case '6':
    case '7': case '8': case '9':
	var = *(*pattern)++ - '0';
	while (isDIGIT(**pattern)) {
	    const I32 tmp = var * 10 + (*(*pattern)++ - '0');
	    if (tmp < var)
		Perl_croak(aTHX_ "Integer overflow in format string for %s", (PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn"));
	    var = tmp;
	}
    }
    return var;
}

STATIC char *
S_F0convert(NV nv, char *const endbuf, STRLEN *const len)
{
    const int neg = nv < 0;
    UV uv;

    PERL_ARGS_ASSERT_F0CONVERT;

    if (UNLIKELY(Perl_isinfnan(nv))) {
        STRLEN n = S_infnan_2pv(nv, endbuf - *len, *len, 0);
        *len = n;
        return endbuf - n;
    }
    if (neg)
	nv = -nv;
    if (nv < UV_MAX) {
	char *p = endbuf;
	nv += 0.5;
	uv = (UV)nv;
	if (uv & 1 && uv == nv)
	    uv--;			/* Round to even */
	do {
	    const unsigned dig = uv % 10;
	    *--p = '0' + dig;
	} while (uv /= 10);
	if (neg)
	    *--p = '-';
	*len = endbuf - p;
	return p;
    }
    return NULL;
}


/*
=for apidoc sv_vcatpvfn

=for apidoc sv_vcatpvfn_flags

Processes its arguments like C<vsprintf> and appends the formatted output
to an SV.  Uses an array of SVs if the C-style variable argument list is
missing (C<NULL>). Argument reordering (using format specifiers like C<%2$d>
or C<%*2$d>) is supported only when using an array of SVs; using a C-style
C<va_list> argument list with a format string that uses argument reordering
will yield an exception.

When running with taint checks enabled, indicates via
C<maybe_tainted> if results are untrustworthy (often due to the use of
locales).

If called as C<sv_vcatpvfn> or flags has the C<SV_GMAGIC> bit set, calls get magic.

Usually used via one of its frontends C<sv_vcatpvf> and C<sv_vcatpvf_mg>.

=cut
*/

#define VECTORIZE_ARGS	vecsv = va_arg(*args, SV*);\
			vecstr = (U8*)SvPV_const(vecsv,veclen);\
			vec_utf8 = DO_UTF8(vecsv);

/* XXX maybe_tainted is never assigned to, so the doc above is lying. */

void
Perl_sv_vcatpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen,
                 va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted)
{
    PERL_ARGS_ASSERT_SV_VCATPVFN;

    sv_vcatpvfn_flags(sv, pat, patlen, args, svargs, svmax, maybe_tainted, SV_GMAGIC|SV_SMAGIC);
}

#ifdef LONGDOUBLE_DOUBLEDOUBLE
/* The first double can be as large as 2**1023, or '1' x '0' x 1023.
 * The second double can be as small as 2**-1074, or '0' x 1073 . '1'.
 * The sum of them can be '1' . '0' x 2096 . '1', with implied radix point
 * after the first 1023 zero bits.
 *
 * XXX The 2098 is quite large (262.25 bytes) and therefore some sort
 * of dynamically growing buffer might be better, start at just 16 bytes
 * (for example) and grow only when necessary.  Or maybe just by looking
 * at the exponents of the two doubles? */
#  define DOUBLEDOUBLE_MAXBITS 2098
#endif

/* vhex will contain the values (0..15) of the hex digits ("nybbles"
 * of 4 bits); 1 for the implicit 1, and the mantissa bits, four bits
 * per xdigit.  For the double-double case, this can be rather many.
 * The non-double-double-long-double overshoots since all bits of NV
 * are not mantissa bits, there are also exponent bits. */
#ifdef LONGDOUBLE_DOUBLEDOUBLE
#  define VHEX_SIZE (3+DOUBLEDOUBLE_MAXBITS/4)
#else
#  define VHEX_SIZE (1+(NVSIZE * 8)/4)
#endif

/* If we do not have a known long double format, (including not using
 * long doubles, or long doubles being equal to doubles) then we will
 * fall back to the ldexp/frexp route, with which we can retrieve at
 * most as many bits as our widest unsigned integer type is.  We try
 * to get a 64-bit unsigned integer even if we are not using a 64-bit UV.
 *
 * (If you want to test the case of UVSIZE == 4, NVSIZE == 8,
 *  set the MANTISSATYPE to int and the MANTISSASIZE to 4.)
 */
#if defined(HAS_QUAD) && defined(Uquad_t)
#  define MANTISSATYPE Uquad_t
#  define MANTISSASIZE 8
#else
#  define MANTISSATYPE UV
#  define MANTISSASIZE UVSIZE
#endif

#if defined(DOUBLE_LITTLE_ENDIAN) || defined(LONGDOUBLE_LITTLE_ENDIAN)
#  define HEXTRACT_LITTLE_ENDIAN
#elif defined(DOUBLE_BIG_ENDIAN) || defined(LONGDOUBLE_BIG_ENDIAN)
#  define HEXTRACT_BIG_ENDIAN
#else
#  define HEXTRACT_MIX_ENDIAN
#endif

/* S_hextract() is a helper for Perl_sv_vcatpvfn_flags, for extracting
 * the hexadecimal values (for %a/%A).  The nv is the NV where the value
 * are being extracted from (either directly from the long double in-memory
 * presentation, or from the uquad computed via frexp+ldexp).  frexp also
 * is used to update the exponent.  vhex is the pointer to the beginning
 * of the output buffer (of VHEX_SIZE).
 *
 * The tricky part is that S_hextract() needs to be called twice:
 * the first time with vend as NULL, and the second time with vend as
 * the pointer returned by the first call.  What happens is that on
 * the first round the output size is computed, and the intended
 * extraction sanity checked.  On the second round the actual output
 * (the extraction of the hexadecimal values) takes place.
 * Sanity failures cause fatal failures during both rounds. */
STATIC U8*
S_hextract(pTHX_ const NV nv, int* exponent, U8* vhex, U8* vend)
{
    U8* v = vhex;
    int ix;
    int ixmin = 0, ixmax = 0;

    /* XXX Inf/NaN/denormal handling in the HEXTRACT_IMPLICIT_BIT,
     * and elsewhere. */

    /* These macros are just to reduce typos, they have multiple
     * repetitions below, but usually only one (or sometimes two)
     * of them is really being used. */
    /* HEXTRACT_OUTPUT() extracts the high nybble first. */
#define HEXTRACT_OUTPUT_HI(ix) (*v++ = nvp[ix] >> 4)
#define HEXTRACT_OUTPUT_LO(ix) (*v++ = nvp[ix] & 0xF)
#define HEXTRACT_OUTPUT(ix) \
    STMT_START { \
      HEXTRACT_OUTPUT_HI(ix); HEXTRACT_OUTPUT_LO(ix); \
   } STMT_END
#define HEXTRACT_COUNT(ix, c) \
    STMT_START { \
      v += c; if (ix < ixmin) ixmin = ix; else if (ix > ixmax) ixmax = ix; \
   } STMT_END
#define HEXTRACT_BYTE(ix) \
    STMT_START { \
      if (vend) HEXTRACT_OUTPUT(ix); else HEXTRACT_COUNT(ix, 2); \
   } STMT_END
#define HEXTRACT_LO_NYBBLE(ix) \
    STMT_START { \
      if (vend) HEXTRACT_OUTPUT_LO(ix); else HEXTRACT_COUNT(ix, 1); \
   } STMT_END
    /* HEXTRACT_TOP_NYBBLE is just convenience disguise,
     * to make it look less odd when the top bits of a NV
     * are extracted using HEXTRACT_LO_NYBBLE: the highest
     * order bits can be in the "low nybble" of a byte. */
#define HEXTRACT_TOP_NYBBLE(ix) HEXTRACT_LO_NYBBLE(ix)
#define HEXTRACT_BYTES_LE(a, b) \
    for (ix = a; ix >= b; ix--) { HEXTRACT_BYTE(ix); }
#define HEXTRACT_BYTES_BE(a, b) \
    for (ix = a; ix <= b; ix++) { HEXTRACT_BYTE(ix); }
#define HEXTRACT_IMPLICIT_BIT(nv) \
    STMT_START { \
        if (vend) *v++ = ((nv) == 0.0) ? 0 : 1; else v++; \
   } STMT_END

/* Most formats do.  Those which don't should undef this. */
#define HEXTRACT_HAS_IMPLICIT_BIT
/* Many formats do.  Those which don't should undef this. */
#define HEXTRACT_HAS_TOP_NYBBLE

    /* HEXTRACTSIZE is the maximum number of xdigits. */
#if defined(USE_LONG_DOUBLE) && defined(LONGDOUBLE_DOUBLEDOUBLE)
#  define HEXTRACTSIZE (2+DOUBLEDOUBLE_MAXBITS/4)
#else
#  define HEXTRACTSIZE 2 * NVSIZE
#endif

    const U8* vmaxend = vhex + HEXTRACTSIZE;
    PERL_UNUSED_VAR(ix); /* might happen */
    (void)Perl_frexp(PERL_ABS(nv), exponent);
    if (vend && (vend <= vhex || vend > vmaxend)) {
        /* diag_listed_as: Hexadecimal float: internal error (%s) */
        Perl_croak(aTHX_ "Hexadecimal float: internal error (entry)");
    }
    {
        /* First check if using long doubles. */
#if defined(USE_LONG_DOUBLE) && (NVSIZE > DOUBLESIZE)
#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
        /* Used in e.g. VMS and HP-UX IA-64, e.g. -0.1L:
         * 9a 99 99 99 99 99 99 99 99 99 99 99 99 99 fb 3f */
        /* The bytes 13..0 are the mantissa/fraction,
         * the 15,14 are the sign+exponent. */
        const U8* nvp = (const U8*)(&nv);
        HEXTRACT_IMPLICIT_BIT(nv);
#   undef HEXTRACT_HAS_TOP_NYBBLE
        HEXTRACT_BYTES_LE(13, 0);
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
        /* Used in e.g. Solaris Sparc and HP-UX PA-RISC, e.g. -0.1L:
         * bf fb 99 99 99 99 99 99 99 99 99 99 99 99 99 9a */
        /* The bytes 2..15 are the mantissa/fraction,
         * the 0,1 are the sign+exponent. */
        const U8* nvp = (const U8*)(&nv);
        HEXTRACT_IMPLICIT_BIT(nv);
#   undef HEXTRACT_HAS_TOP_NYBBLE
        HEXTRACT_BYTES_BE(2, 15);
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN
        /* x86 80-bit "extended precision", 64 bits of mantissa / fraction /
         * significand, 15 bits of exponent, 1 bit of sign.  NVSIZE can
         * be either 12 (ILP32, Solaris x86) or 16 (LP64, Linux and OS X),
         * meaning that 2 or 6 bytes are empty padding. */
        /* The bytes 7..0 are the mantissa/fraction */
        const U8* nvp = (const U8*)(&nv);
#    undef HEXTRACT_HAS_IMPLICIT_BIT
#    undef HEXTRACT_HAS_TOP_NYBBLE
        HEXTRACT_BYTES_LE(7, 0);
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN
        /* Does this format ever happen? (Wikipedia says the Motorola
         * 6888x math coprocessors used format _like_ this but padded
         * to 96 bits with 16 unused bits between the exponent and the
         * mantissa.) */
        const U8* nvp = (const U8*)(&nv);
#    undef HEXTRACT_HAS_IMPLICIT_BIT
#    undef HEXTRACT_HAS_TOP_NYBBLE
        HEXTRACT_BYTES_BE(0, 7);
#  else
#    define HEXTRACT_FALLBACK
        /* Double-double format: two doubles next to each other.
         * The first double is the high-order one, exactly like
         * it would be for a "lone" double.  The second double
         * is shifted down using the exponent so that that there
         * are no common bits.  The tricky part is that the value
         * of the double-double is the SUM of the two doubles and
         * the second one can be also NEGATIVE.
         *
         * Because of this tricky construction the bytewise extraction we
         * use for the other long double formats doesn't work, we must
         * extract the values bit by bit.
         *
         * The little-endian double-double is used .. somewhere?
         *
         * The big endian double-double is used in e.g. PPC/Power (AIX)
         * and MIPS (SGI).
         *
         * The mantissa bits are in two separate stretches, e.g. for -0.1L:
         * 9a 99 99 99 99 99 59 bc 9a 99 99 99 99 99 b9 3f (LE)
         * 3f b9 99 99 99 99 99 9a bc 59 99 99 99 99 99 9a (BE)
         */
#  endif
#else /* #if defined(USE_LONG_DOUBLE) && (NVSIZE > DOUBLESIZE) */
        /* Using normal doubles, not long doubles.
         *
         * We generate 4-bit xdigits (nybble/nibble) instead of 8-bit
         * bytes, since we might need to handle printf precision, and
         * also need to insert the radix. */
#  if NVSIZE == 8
#    ifdef HEXTRACT_LITTLE_ENDIAN
        /* 0 1 2 3 4 5 6 7 (MSB = 7, LSB = 0, 6+7 = exponent+sign) */
        const U8* nvp = (const U8*)(&nv);
        HEXTRACT_IMPLICIT_BIT(nv);
        HEXTRACT_TOP_NYBBLE(6);
        HEXTRACT_BYTES_LE(5, 0);
#    elif defined(HEXTRACT_BIG_ENDIAN)
        /* 7 6 5 4 3 2 1 0 (MSB = 7, LSB = 0, 6+7 = exponent+sign) */
        const U8* nvp = (const U8*)(&nv);
        HEXTRACT_IMPLICIT_BIT(nv);
        HEXTRACT_TOP_NYBBLE(1);
        HEXTRACT_BYTES_BE(2, 7);
#    elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE
        /* 4 5 6 7 0 1 2 3 (MSB = 7, LSB = 0, 6:7 = nybble:exponent:sign) */
        const U8* nvp = (const U8*)(&nv);
        HEXTRACT_IMPLICIT_BIT(nv);
        HEXTRACT_TOP_NYBBLE(2); /* 6 */
        HEXTRACT_BYTE(1); /* 5 */
        HEXTRACT_BYTE(0); /* 4 */
        HEXTRACT_BYTE(7); /* 3 */
        HEXTRACT_BYTE(6); /* 2 */
        HEXTRACT_BYTE(5); /* 1 */
        HEXTRACT_BYTE(4); /* 0 */
#    elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE
        /* 3 2 1 0 7 6 5 4 (MSB = 7, LSB = 0, 7:6 = sign:exponent:nybble) */
        const U8* nvp = (const U8*)(&nv);
        HEXTRACT_IMPLICIT_BIT(nv);
        HEXTRACT_TOP_NYBBLE(5); /* 6 */
        HEXTRACT_BYTE(6); /* 5 */
        HEXTRACT_BYTE(7); /* 4 */
        HEXTRACT_BYTE(0); /* 3 */
        HEXTRACT_BYTE(1); /* 2 */
        HEXTRACT_BYTE(2); /* 1 */
        HEXTRACT_BYTE(3); /* 0 */
#    else
#      define HEXTRACT_FALLBACK
#    endif
#  else
#    define HEXTRACT_FALLBACK
#  endif
#endif /* #if defined(USE_LONG_DOUBLE) && (NVSIZE > DOUBLESIZE) #else */
#  ifdef HEXTRACT_FALLBACK
#    undef HEXTRACT_HAS_TOP_NYBBLE /* Meaningless, but consistent. */
        /* The fallback is used for the double-double format, and
         * for unknown long double formats, and for unknown double
         * formats, or in general unknown NV formats. */
        if (nv == (NV)0.0) {
            if (vend)
                *v++ = 0;
            else
                v++;
            *exponent = 0;
        }
        else {
            NV d = nv < 0 ? -nv : nv;
            NV e = (NV)1.0;
            U8 ha = 0x0; /* hexvalue accumulator */
            U8 hd = 0x8; /* hexvalue digit */

            /* Shift d and e (and update exponent) so that e <= d < 2*e,
             * this is essentially manual frexp(). Multiplying by 0.5 and
             * doubling should be lossless in binary floating point. */

            *exponent = 1;

            while (e > d) {
                e *= (NV)0.5;
                (*exponent)--;
            }
            /* Now d >= e */

            while (d >= e + e) {
                e += e;
                (*exponent)++;
            }
            /* Now e <= d < 2*e */

            /* First extract the leading hexdigit (the implicit bit). */
            if (d >= e) {
                d -= e;
                if (vend)
                    *v++ = 1;
                else
                    v++;
            }
            else {
                if (vend)
                    *v++ = 0;
                else
                    v++;
            }
            e *= (NV)0.5;

            /* Then extract the remaining hexdigits. */
            while (d > (NV)0.0) {
                if (d >= e) {
                    ha |= hd;
                    d -= e;
                }
                if (hd == 1) {
                    /* Output or count in groups of four bits,
                     * that is, when the hexdigit is down to one. */
                    if (vend)
                        *v++ = ha;
                    else
                        v++;
                    /* Reset the hexvalue. */
                    ha = 0x0;
                    hd = 0x8;
                }
                else
                    hd >>= 1;
                e *= (NV)0.5;
            }

            /* Flush possible pending hexvalue. */
            if (ha) {
                if (vend)
                    *v++ = ha;
                else
                    v++;
            }
        }
#  endif
    }
    /* Croak for various reasons: if the output pointer escaped the
     * output buffer, if the extraction index escaped the extraction
     * buffer, or if the ending output pointer didn't match the
     * previously computed value. */
    if (v <= vhex || v - vhex >= VHEX_SIZE ||
        /* For double-double the ixmin and ixmax stay at zero,
         * which is convenient since the HEXTRACTSIZE is tricky
         * for double-double. */
        ixmin < 0 || ixmax >= NVSIZE ||
        (vend && v != vend)) {
        /* diag_listed_as: Hexadecimal float: internal error (%s) */
        Perl_croak(aTHX_ "Hexadecimal float: internal error (overflow)");
    }
    return v;
}

/* Helper for sv_vcatpvfn_flags().  */
#define FETCH_VCATPVFN_ARGUMENT(var, in_range, expr)   \
    STMT_START {                                       \
        if (in_range)                                  \
            (var) = (expr);                            \
        else {                                         \
            (var) = &PL_sv_no; /* [perl #71000] */     \
            arg_missing = TRUE;                        \
        }                                              \
    } STMT_END

void
Perl_sv_vcatpvfn_flags(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen,
                       va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted,
                       const U32 flags)
{
    char *p;
    char *q;
    const char *patend;
    STRLEN origlen;
    I32 svix = 0;
    static const char nullstr[] = "(null)";
    SV *argsv = NULL;
    bool has_utf8 = DO_UTF8(sv);    /* has the result utf8? */
    const bool pat_utf8 = has_utf8; /* the pattern is in utf8? */
    SV *nsv = NULL;
    /* Times 4: a decimal digit takes more than 3 binary digits.
     * NV_DIG: mantissa takes than many decimal digits.
     * Plus 32: Playing safe. */
    char ebuf[IV_DIG * 4 + NV_DIG + 32];
    bool no_redundant_warning = FALSE; /* did we use any explicit format parameter index? */
    bool hexfp = FALSE; /* hexadecimal floating point? */

    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;

    PERL_ARGS_ASSERT_SV_VCATPVFN_FLAGS;
    PERL_UNUSED_ARG(maybe_tainted);

    if (flags & SV_GMAGIC)
        SvGETMAGIC(sv);

    /* no matter what, this is a string now */
    (void)SvPV_force_nomg(sv, origlen);

    /* special-case "", "%s", and "%-p" (SVf - see below) */
    if (patlen == 0) {
	if (svmax && ckWARN(WARN_REDUNDANT))
	    Perl_warner(aTHX_ packWARN(WARN_REDUNDANT), "Redundant argument in %s",
			PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn()");
	return;
    }
    if (patlen == 2 && pat[0] == '%' && pat[1] == 's') {
	if (svmax > 1 && ckWARN(WARN_REDUNDANT))
	    Perl_warner(aTHX_ packWARN(WARN_REDUNDANT), "Redundant argument in %s",
			PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn()");

	if (args) {
	    const char * const s = va_arg(*args, char*);
	    sv_catpv_nomg(sv, s ? s : nullstr);
	}
	else if (svix < svmax) {
	    /* we want get magic on the source but not the target. sv_catsv can't do that, though */
	    SvGETMAGIC(*svargs);
	    sv_catsv_nomg(sv, *svargs);
	}
	else
	    S_warn_vcatpvfn_missing_argument(aTHX);
	return;
    }
    if (args && patlen == 3 && pat[0] == '%' &&
		pat[1] == '-' && pat[2] == 'p') {
	if (svmax > 1 && ckWARN(WARN_REDUNDANT))
	    Perl_warner(aTHX_ packWARN(WARN_REDUNDANT), "Redundant argument in %s",
			PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn()");
	argsv = MUTABLE_SV(va_arg(*args, void*));
	sv_catsv_nomg(sv, argsv);
	return;
    }

#if !defined(USE_LONG_DOUBLE) && !defined(USE_QUADMATH)
    /* special-case "%.<number>[gf]" */
    if ( !args && patlen <= 5 && pat[0] == '%' && pat[1] == '.'
	 && (pat[patlen-1] == 'g' || pat[patlen-1] == 'f') ) {
	unsigned digits = 0;
	const char *pp;

	pp = pat + 2;
	while (*pp >= '0' && *pp <= '9')
	    digits = 10 * digits + (*pp++ - '0');

	/* XXX: Why do this `svix < svmax` test? Couldn't we just
	   format the first argument and WARN_REDUNDANT if svmax > 1?
	   Munged by Nicholas Clark in v5.13.0-209-g95ea86d */
	if (pp - pat == (int)patlen - 1 && svix < svmax) {
	    const NV nv = SvNV(*svargs);
            if (LIKELY(!Perl_isinfnan(nv))) {
                if (*pp == 'g') {
                    /* Add check for digits != 0 because it seems that some
                       gconverts are buggy in this case, and we don't yet have
                       a Configure test for this.  */
                    if (digits && digits < sizeof(ebuf) - NV_DIG - 10) {
                        /* 0, point, slack */
                        STORE_LC_NUMERIC_SET_TO_NEEDED();
                        SNPRINTF_G(nv, ebuf, size, digits);
                        sv_catpv_nomg(sv, ebuf);
                        if (*ebuf)	/* May return an empty string for digits==0 */
                            return;
                    }
                } else if (!digits) {
                    STRLEN l;

                    if ((p = F0convert(nv, ebuf + sizeof ebuf, &l))) {
                        sv_catpvn_nomg(sv, p, l);
                        return;
                    }
                }
            }
	}
    }
#endif /* !USE_LONG_DOUBLE */

    if (!args && svix < svmax && DO_UTF8(*svargs))
	has_utf8 = TRUE;

    patend = (char*)pat + patlen;
    for (p = (char*)pat; p < patend; p = q) {
	bool alt = FALSE;
	bool left = FALSE;
	bool vectorize = FALSE;
	bool vectorarg = FALSE;
	bool vec_utf8 = FALSE;
	char fill = ' ';
	char plus = 0;
	char intsize = 0;
	STRLEN width = 0;
	STRLEN zeros = 0;
	bool has_precis = FALSE;
	STRLEN precis = 0;
	const I32 osvix = svix;
	bool is_utf8 = FALSE;  /* is this item utf8?   */
        bool used_explicit_ix = FALSE;
        bool arg_missing = FALSE;
#ifdef HAS_LDBL_SPRINTF_BUG
	/* This is to try to fix a bug with irix/nonstop-ux/powerux and
	   with sfio - Allen <allens@@cpan.org> */
	bool fix_ldbl_sprintf_bug = FALSE;
#endif

	char esignbuf[4];
	U8 utf8buf[UTF8_MAXBYTES+1];
	STRLEN esignlen = 0;

	const char *eptr = NULL;
	const char *fmtstart;
	STRLEN elen = 0;
	SV *vecsv = NULL;
	const U8 *vecstr = NULL;
	STRLEN veclen = 0;
	char c = 0;
	int i;
	unsigned base = 0;
	IV iv = 0;
	UV uv = 0;
	/* We need a long double target in case HAS_LONG_DOUBLE,
         * even without USE_LONG_DOUBLE, so that we can printf with
         * long double formats, even without NV being long double.
         * But we call the target 'fv' instead of 'nv', since most of
         * the time it is not (most compilers these days recognize
         * "long double", even if only as a synonym for "double").
	*/
#if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE > DOUBLESIZE && \
	defined(PERL_PRIgldbl) && !defined(USE_QUADMATH)
	long double fv;
#  ifdef Perl_isfinitel
#    define FV_ISFINITE(x) Perl_isfinitel(x)
#  endif
#  define FV_GF PERL_PRIgldbl
#    if defined(__VMS) && defined(__ia64) && defined(__IEEE_FLOAT)
       /* Work around breakage in OTS$CVT_FLOAT_T_X */
#      define NV_TO_FV(nv,fv) STMT_START {                   \
                                           double _dv = nv;  \
                                           fv = Perl_isnan(_dv) ? LDBL_QNAN : _dv; \
                              } STMT_END
#    else
#      define NV_TO_FV(nv,fv) (fv)=(nv)
#    endif
#else
	NV fv;
#  define FV_GF NVgf
#  define NV_TO_FV(nv,fv) (fv)=(nv)
#endif
#ifndef FV_ISFINITE
#  define FV_ISFINITE(x) Perl_isfinite((NV)(x))
#endif
        NV nv;
	STRLEN have;
	STRLEN need;
	STRLEN gap;
	const char *dotstr = ".";
	STRLEN dotstrlen = 1;
	I32 efix = 0; /* explicit format parameter index */
	I32 ewix = 0; /* explicit width index */
	I32 epix = 0; /* explicit precision index */
	I32 evix = 0; /* explicit vector index */
	bool asterisk = FALSE;
        bool infnan = FALSE;

	/* echo everything up to the next format specification */
	for (q = p; q < patend && *q != '%'; ++q) ;
	if (q > p) {
	    if (has_utf8 && !pat_utf8)
		sv_catpvn_nomg_utf8_upgrade(sv, p, q - p, nsv);
	    else
		sv_catpvn_nomg(sv, p, q - p);
	    p = q;
	}
	if (q++ >= patend)
	    break;

	fmtstart = q;

/*
    We allow format specification elements in this order:
	\d+\$              explicit format parameter index
	[-+ 0#]+           flags
	v|\*(\d+\$)?v      vector with optional (optionally specified) arg
	0		   flag (as above): repeated to allow "v02" 	
	\d+|\*(\d+\$)?     width using optional (optionally specified) arg
	\.(\d*|\*(\d+\$)?) precision using optional (optionally specified) arg
	[hlqLV]            size
    [%bcdefginopsuxDFOUX] format (mandatory)
*/

	if (args) {
/*  
	As of perl5.9.3, printf format checking is on by default.
	Internally, perl uses %p formats to provide an escape to
	some extended formatting.  This block deals with those
	extensions: if it does not match, (char*)q is reset and
	the normal format processing code is used.

	Currently defined extensions are:
		%p		include pointer address (standard)	
		%-p	(SVf)	include an SV (previously %_)
		%-<num>p	include an SV with precision <num>	
		%2p		include a HEK
		%3p		include a HEK with precision of 256
		%4p		char* preceded by utf8 flag and length
		%<num>p		(where num is 1 or > 4) reserved for future
				extensions

	Robin Barker 2005-07-14 (but modified since)

		%1p	(VDf)	removed.  RMB 2007-10-19
*/
 	    char* r = q; 
	    bool sv = FALSE;	
	    STRLEN n = 0;
	    if (*q == '-')
		sv = *q++;
	    else if (strnEQ(q, UTF8f, sizeof(UTF8f)-1)) { /* UTF8f */
		/* The argument has already gone through cBOOL, so the cast
		   is safe. */
		is_utf8 = (bool)va_arg(*args, int);
		elen = va_arg(*args, UV);
                /* if utf8 length is larger than 0x7ffff..., then it might
                 * have been a signed value that wrapped */
                if (elen  > ((~(STRLEN)0) >> 1)) {
                    assert(0); /* in DEBUGGING build we want to crash */
                    elen= 0; /* otherwise we want to treat this as an empty string */
                }
		eptr = va_arg(*args, char *);
		q += sizeof(UTF8f)-1;
		goto string;
	    }
	    n = expect_number(&q);
	    if (*q++ == 'p') {
		if (sv) {			/* SVf */
		    if (n) {
			precis = n;
			has_precis = TRUE;
		    }
		    argsv = MUTABLE_SV(va_arg(*args, void*));
		    eptr = SvPV_const(argsv, elen);
		    if (DO_UTF8(argsv))
			is_utf8 = TRUE;
		    goto string;
		}
		else if (n==2 || n==3) {	/* HEKf */
		    HEK * const hek = va_arg(*args, HEK *);
		    eptr = HEK_KEY(hek);
		    elen = HEK_LEN(hek);
		    if (HEK_UTF8(hek)) is_utf8 = TRUE;
		    if (n==3) precis = 256, has_precis = TRUE;
		    goto string;
		}
		else if (n) {
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
				     "internal %%<num>p might conflict with future printf extensions");
		}
	    }
	    q = r; 
	}

	if ( (width = expect_number(&q)) ) {
	    if (*q == '$') {
                if (args)
                    Perl_croak_nocontext(
                        "Cannot yet reorder sv_catpvfn() arguments from va_list");
		++q;
		efix = width;
                used_explicit_ix = TRUE;
	    } else {
		goto gotwidth;
	    }
	}

	/* FLAGS */

	while (*q) {
	    switch (*q) {
	    case ' ':
	    case '+':
		if (plus == '+' && *q == ' ') /* '+' over ' ' */
		    q++;
		else
		    plus = *q++;
		continue;

	    case '-':
		left = TRUE;
		q++;
		continue;

	    case '0':
		fill = *q++;
		continue;

	    case '#':
		alt = TRUE;
		q++;
		continue;

	    default:
		break;
	    }
	    break;
	}

      tryasterisk:
	if (*q == '*') {
	    q++;
	    if ( (ewix = expect_number(&q)) ) {
		if (*q++ == '$') {
                    if (args)
                        Perl_croak_nocontext(
                            "Cannot yet reorder sv_catpvfn() arguments from va_list");
                    used_explicit_ix = TRUE;
                } else
		    goto unknown;
            }
	    asterisk = TRUE;
	}
	if (*q == 'v') {
	    q++;
	    if (vectorize)
		goto unknown;
	    if ((vectorarg = asterisk)) {
		evix = ewix;
		ewix = 0;
		asterisk = FALSE;
	    }
	    vectorize = TRUE;
	    goto tryasterisk;
	}

	if (!asterisk)
	{
	    if( *q == '0' )
		fill = *q++;
	    width = expect_number(&q);
	}

	if (vectorize && vectorarg) {
	    /* vectorizing, but not with the default "." */
	    if (args)
		vecsv = va_arg(*args, SV*);
	    else if (evix) {
                FETCH_VCATPVFN_ARGUMENT(
                    vecsv, evix > 0 && evix <= svmax, svargs[evix-1]);
	    } else {
                FETCH_VCATPVFN_ARGUMENT(
                    vecsv, svix < svmax, svargs[svix++]);
	    }
	    dotstr = SvPV_const(vecsv, dotstrlen);
	    /* Keep the DO_UTF8 test *after* the SvPV call, else things go
	       bad with tied or overloaded values that return UTF8.  */
	    if (DO_UTF8(vecsv))
		is_utf8 = TRUE;
	    else if (has_utf8) {
		vecsv = sv_mortalcopy(vecsv);
		sv_utf8_upgrade(vecsv);
		dotstr = SvPV_const(vecsv, dotstrlen);
		is_utf8 = TRUE;
	    }		    
	}

	if (asterisk) {
	    if (args)
		i = va_arg(*args, int);
	    else
		i = (ewix ? ewix <= svmax : svix < svmax) ?
		    SvIVx(svargs[ewix ? ewix-1 : svix++]) : 0;
	    left |= (i < 0);
	    width = (i < 0) ? -i : i;
	}
      gotwidth:

	/* PRECISION */

	if (*q == '.') {
	    q++;
	    if (*q == '*') {
		q++;
                if ( (epix = expect_number(&q)) ) {
                    if (*q++ == '$') {
                        if (args)
                            Perl_croak_nocontext(
                                "Cannot yet reorder sv_catpvfn() arguments from va_list");
                        used_explicit_ix = TRUE;
                    } else
                        goto unknown;
                }
		if (args)
                    i = va_arg(*args, int);
		else {
                    SV *precsv;
                    if (epix)
                        FETCH_VCATPVFN_ARGUMENT(
                            precsv, epix > 0 && epix <= svmax, svargs[epix-1]);
                    else
                        FETCH_VCATPVFN_ARGUMENT(
                            precsv, svix < svmax, svargs[svix++]);
                    i = precsv == &PL_sv_no ? 0 : SvIVx(precsv);
                }
		precis = i;
		has_precis = !(i < 0);
	    }
	    else {
		precis = 0;
		while (isDIGIT(*q))
		    precis = precis * 10 + (*q++ - '0');
		has_precis = TRUE;
	    }
	}

	if (vectorize) {
	    if (args) {
		VECTORIZE_ARGS
	    }
	    else if (efix ? (efix > 0 && efix <= svmax) : svix < svmax) {
		vecsv = svargs[efix ? efix-1 : svix++];
		vecstr = (U8*)SvPV_const(vecsv,veclen);
		vec_utf8 = DO_UTF8(vecsv);

		/* if this is a version object, we need to convert
		 * back into v-string notation and then let the
		 * vectorize happen normally
		 */
		if (sv_isobject(vecsv) && sv_derived_from(vecsv, "version")) {
		    if ( hv_exists(MUTABLE_HV(SvRV(vecsv)), "alpha", 5 ) ) {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_PRINTF),
			"vector argument not supported with alpha versions");
			goto vdblank;
		    }
		    vecsv = sv_newmortal();
		    scan_vstring((char *)vecstr, (char *)vecstr + veclen,
				 vecsv);
		    vecstr = (U8*)SvPV_const(vecsv, veclen);
		    vec_utf8 = DO_UTF8(vecsv);
		}
	    }
	    else {
	      vdblank:
		vecstr = (U8*)"";
		veclen = 0;
	    }
	}

	/* SIZE */

	switch (*q) {
#ifdef WIN32
	case 'I':			/* Ix, I32x, and I64x */
#  ifdef USE_64_BIT_INT
	    if (q[1] == '6' && q[2] == '4') {
		q += 3;
		intsize = 'q';
		break;
	    }
#  endif
	    if (q[1] == '3' && q[2] == '2') {
		q += 3;
		break;
	    }
#  ifdef USE_64_BIT_INT
	    intsize = 'q';
#  endif
	    q++;
	    break;
#endif
#if (IVSIZE >= 8 || defined(HAS_LONG_DOUBLE)) || \
    (IVSIZE == 4 && !defined(HAS_LONG_DOUBLE))
	case 'L':			/* Ld */
	    /* FALLTHROUGH */
#  ifdef USE_QUADMATH
        case 'Q':
	    /* FALLTHROUGH */
#  endif
#  if IVSIZE >= 8
	case 'q':			/* qd */
#  endif
	    intsize = 'q';
	    q++;
	    break;
#endif
	case 'l':
	    ++q;
#if (IVSIZE >= 8 || defined(HAS_LONG_DOUBLE)) || \
    (IVSIZE == 4 && !defined(HAS_LONG_DOUBLE))
	    if (*q == 'l') {	/* lld, llf */
		intsize = 'q';
		++q;
	    }
	    else
#endif
		intsize = 'l';
	    break;
	case 'h':
	    if (*++q == 'h') {	/* hhd, hhu */
		intsize = 'c';
		++q;
	    }
	    else
		intsize = 'h';
	    break;
	case 'V':
	case 'z':
	case 't':
#ifdef I_STDINT
        case 'j':
#endif
	    intsize = *q++;
	    break;
	}

	/* CONVERSION */

	if (*q == '%') {
	    eptr = q++;
	    elen = 1;
	    if (vectorize) {
		c = '%';
		goto unknown;
	    }
	    goto string;
	}

	if (!vectorize && !args) {
	    if (efix) {
		const I32 i = efix-1;
                FETCH_VCATPVFN_ARGUMENT(argsv, i >= 0 && i < svmax, svargs[i]);
	    } else {
                FETCH_VCATPVFN_ARGUMENT(argsv, svix >= 0 && svix < svmax,
                                        svargs[svix++]);
	    }
	}

        if (argsv && strchr("BbcDdiOopuUXx",*q)) {
            /* XXX va_arg(*args) case? need peek, use va_copy? */
            SvGETMAGIC(argsv);
            if (UNLIKELY(SvAMAGIC(argsv)))
                argsv = sv_2num(argsv);
            infnan = UNLIKELY(isinfnansv(argsv));
        }

	switch (c = *q++) {

	    /* STRINGS */

	case 'c':
	    if (vectorize)
		goto unknown;
            if (infnan)
                Perl_croak(aTHX_ "Cannot printf %"NVgf" with '%c'",
                           /* no va_arg() case */
                           SvNV_nomg(argsv), (int)c);
	    uv = (args) ? va_arg(*args, int) : SvIV_nomg(argsv);
	    if ((uv > 255 ||
		 (!UVCHR_IS_INVARIANT(uv) && SvUTF8(sv)))
		&& !IN_BYTES) {
		eptr = (char*)utf8buf;
		elen = uvchr_to_utf8((U8*)eptr, uv) - utf8buf;
		is_utf8 = TRUE;
	    }
	    else {
		c = (char)uv;
		eptr = &c;
		elen = 1;
	    }
	    goto string;

	case 's':
	    if (vectorize)
		goto unknown;
	    if (args) {
		eptr = va_arg(*args, char*);
		if (eptr)
		    elen = strlen(eptr);
		else {
		    eptr = (char *)nullstr;
		    elen = sizeof nullstr - 1;
		}
	    }
	    else {
		eptr = SvPV_const(argsv, elen);
		if (DO_UTF8(argsv)) {
		    STRLEN old_precis = precis;
		    if (has_precis && precis < elen) {
			STRLEN ulen = sv_or_pv_len_utf8(argsv, eptr, elen);
			STRLEN p = precis > ulen ? ulen : precis;
			precis = sv_or_pv_pos_u2b(argsv, eptr, p, 0);
							/* sticks at end */
		    }
		    if (width) { /* fudge width (can't fudge elen) */
			if (has_precis && precis < elen)
			    width += precis - old_precis;
			else
			    width +=
				elen - sv_or_pv_len_utf8(argsv,eptr,elen);
		    }
		    is_utf8 = TRUE;
		}
	    }

	string:
	    if (has_precis && precis < elen)
		elen = precis;
	    break;

	    /* INTEGERS */

	case 'p':
            if (infnan) {
                goto floating_point;
            }
	    if (alt || vectorize)
		goto unknown;
	    uv = PTR2UV(args ? va_arg(*args, void*) : argsv);
	    base = 16;
	    goto integer;

	case 'D':
#ifdef IV_IS_QUAD
	    intsize = 'q';
#else
	    intsize = 'l';
#endif
	    /* FALLTHROUGH */
	case 'd':
	case 'i':
            if (infnan) {
                goto floating_point;
            }
	    if (vectorize) {
		STRLEN ulen;
		if (!veclen)
                    goto donevalidconversion;
		if (vec_utf8)
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
					UTF8_ALLOW_ANYUV);
		else {
		    uv = *vecstr;
		    ulen = 1;
		}
		vecstr += ulen;
		veclen -= ulen;
		if (plus)
		     esignbuf[esignlen++] = plus;
	    }
	    else if (args) {
		switch (intsize) {
		case 'c':	iv = (char)va_arg(*args, int); break;
		case 'h':	iv = (short)va_arg(*args, int); break;
		case 'l':	iv = va_arg(*args, long); break;
		case 'V':	iv = va_arg(*args, IV); break;
		case 'z':	iv = va_arg(*args, SSize_t); break;
#ifdef HAS_PTRDIFF_T
		case 't':	iv = va_arg(*args, ptrdiff_t); break;
#endif
		default:	iv = va_arg(*args, int); break;
#ifdef I_STDINT
		case 'j':	iv = va_arg(*args, intmax_t); break;
#endif
		case 'q':
#if IVSIZE >= 8
				iv = va_arg(*args, Quad_t); break;
#else
				goto unknown;
#endif
		}
	    }
	    else {
		IV tiv = SvIV_nomg(argsv); /* work around GCC bug #13488 */
		switch (intsize) {
		case 'c':	iv = (char)tiv; break;
		case 'h':	iv = (short)tiv; break;
		case 'l':	iv = (long)tiv; break;
		case 'V':
		default:	iv = tiv; break;
		case 'q':
#if IVSIZE >= 8
				iv = (Quad_t)tiv; break;
#else
				goto unknown;
#endif
		}
	    }
	    if ( !vectorize )	/* we already set uv above */
	    {
		if (iv >= 0) {
		    uv = iv;
		    if (plus)
			esignbuf[esignlen++] = plus;
		}
		else {
		    uv = (iv == IV_MIN) ? (UV)iv : (UV)(-iv);
		    esignbuf[esignlen++] = '-';
		}
	    }
	    base = 10;
	    goto integer;

	case 'U':
#ifdef IV_IS_QUAD
	    intsize = 'q';
#else
	    intsize = 'l';
#endif
	    /* FALLTHROUGH */
	case 'u':
	    base = 10;
	    goto uns_integer;

	case 'B':
	case 'b':
	    base = 2;
	    goto uns_integer;

	case 'O':
#ifdef IV_IS_QUAD
	    intsize = 'q';
#else
	    intsize = 'l';
#endif
	    /* FALLTHROUGH */
	case 'o':
	    base = 8;
	    goto uns_integer;

	case 'X':
	case 'x':
	    base = 16;

	uns_integer:
            if (infnan) {
                goto floating_point;
            }
	    if (vectorize) {
		STRLEN ulen;
	vector:
		if (!veclen)
                    goto donevalidconversion;
		if (vec_utf8)
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
					UTF8_ALLOW_ANYUV);
		else {
		    uv = *vecstr;
		    ulen = 1;
		}
		vecstr += ulen;
		veclen -= ulen;
	    }
	    else if (args) {
		switch (intsize) {
		case 'c':  uv = (unsigned char)va_arg(*args, unsigned); break;
		case 'h':  uv = (unsigned short)va_arg(*args, unsigned); break;
		case 'l':  uv = va_arg(*args, unsigned long); break;
		case 'V':  uv = va_arg(*args, UV); break;
		case 'z':  uv = va_arg(*args, Size_t); break;
#ifdef HAS_PTRDIFF_T
	        case 't':  uv = va_arg(*args, ptrdiff_t); break; /* will sign extend, but there is no uptrdiff_t, so oh well */
#endif
#ifdef I_STDINT
		case 'j':  uv = va_arg(*args, uintmax_t); break;
#endif
		default:   uv = va_arg(*args, unsigned); break;
		case 'q':
#if IVSIZE >= 8
			   uv = va_arg(*args, Uquad_t); break;
#else
			   goto unknown;
#endif
		}
	    }
	    else {
		UV tuv = SvUV_nomg(argsv); /* work around GCC bug #13488 */
		switch (intsize) {
		case 'c':	uv = (unsigned char)tuv; break;
		case 'h':	uv = (unsigned short)tuv; break;
		case 'l':	uv = (unsigned long)tuv; break;
		case 'V':
		default:	uv = tuv; break;
		case 'q':
#if IVSIZE >= 8
				uv = (Uquad_t)tuv; break;
#else
				goto unknown;
#endif
		}
	    }

	integer:
	    {
		char *ptr = ebuf + sizeof ebuf;
		bool tempalt = uv ? alt : FALSE; /* Vectors can't change alt */
                unsigned dig;
		zeros = 0;

		switch (base) {
		case 16:
		    p = (char *)((c == 'X') ? PL_hexdigit + 16 : PL_hexdigit);
		    do {
			dig = uv & 15;
			*--ptr = p[dig];
		    } while (uv >>= 4);
		    if (tempalt) {
			esignbuf[esignlen++] = '0';
			esignbuf[esignlen++] = c;  /* 'x' or 'X' */
		    }
		    break;
		case 8:
		    do {
			dig = uv & 7;
			*--ptr = '0' + dig;
		    } while (uv >>= 3);
		    if (alt && *ptr != '0')
			*--ptr = '0';
		    break;
		case 2:
		    do {
			dig = uv & 1;
			*--ptr = '0' + dig;
		    } while (uv >>= 1);
		    if (tempalt) {
			esignbuf[esignlen++] = '0';
			esignbuf[esignlen++] = c;
		    }
		    break;
		default:		/* it had better be ten or less */
		    do {
			dig = uv % base;
			*--ptr = '0' + dig;
		    } while (uv /= base);
		    break;
		}
		elen = (ebuf + sizeof ebuf) - ptr;
		eptr = ptr;
		if (has_precis) {
		    if (precis > elen)
			zeros = precis - elen;
		    else if (precis == 0 && elen == 1 && *eptr == '0'
			     && !(base == 8 && alt)) /* "%#.0o" prints "0" */
			elen = 0;

		/* a precision nullifies the 0 flag. */
		    if (fill == '0')
			fill = ' ';
		}
	    }
	    break;

	    /* FLOATING POINT */

        floating_point:

	case 'F':
	    c = 'f';		/* maybe %F isn't supported here */
	    /* FALLTHROUGH */
	case 'e': case 'E':
	case 'f':
	case 'g': case 'G':
	case 'a': case 'A':
	    if (vectorize)
		goto unknown;

	    /* This is evil, but floating point is even more evil */

	    /* for SV-style calling, we can only get NV
	       for C-style calling, we assume %f is double;
	       for simplicity we allow any of %Lf, %llf, %qf for long double
	    */
	    switch (intsize) {
	    case 'V':
#if defined(USE_LONG_DOUBLE) || defined(USE_QUADMATH)
		intsize = 'q';
#endif
		break;
/* [perl #20339] - we should accept and ignore %lf rather than die */
	    case 'l':
		/* FALLTHROUGH */
	    default:
#if defined(USE_LONG_DOUBLE) || defined(USE_QUADMATH)
		intsize = args ? 0 : 'q';
#endif
		break;
	    case 'q':
#if defined(HAS_LONG_DOUBLE)
		break;
#else
		/* FALLTHROUGH */
#endif
	    case 'c':
	    case 'h':
	    case 'z':
	    case 't':
	    case 'j':
		goto unknown;
	    }

            /* Now we need (long double) if intsize == 'q', else (double). */
            if (args) {
                /* Note: do not pull NVs off the va_list with va_arg()
                 * (pull doubles instead) because if you have a build
                 * with long doubles, you would always be pulling long
                 * doubles, which would badly break anyone using only
                 * doubles (i.e. the majority of builds). In other
                 * words, you cannot mix doubles and long doubles.
                 * The only case where you can pull off long doubles
                 * is when the format specifier explicitly asks so with
                 * e.g. "%Lg". */
#ifdef USE_QUADMATH
                fv = intsize == 'q' ?
                    va_arg(*args, NV) : va_arg(*args, double);
                nv = fv;
#elif LONG_DOUBLESIZE > DOUBLESIZE
                if (intsize == 'q') {
                    fv = va_arg(*args, long double);
                    nv = fv;
                } else {
                    nv = va_arg(*args, double);
                    NV_TO_FV(nv, fv);
                }
#else
                nv = va_arg(*args, double);
                fv = nv;
#endif
            }
            else
            {
                if (!infnan) SvGETMAGIC(argsv);
                nv = SvNV_nomg(argsv);
                NV_TO_FV(nv, fv);
            }

	    need = 0;
	    /* frexp() (or frexpl) has some unspecified behaviour for
             * nan/inf/-inf, so let's avoid calling that on non-finites. */
	    if (isALPHA_FOLD_NE(c, 'e') && FV_ISFINITE(fv)) {
                i = PERL_INT_MIN;
                (void)Perl_frexp((NV)fv, &i);
                if (i == PERL_INT_MIN)
                    Perl_die(aTHX_ "panic: frexp: %"FV_GF, fv);
                /* Do not set hexfp earlier since we want to printf
                 * Inf/NaN for Inf/NaN, not their hexfp. */
                hexfp = isALPHA_FOLD_EQ(c, 'a');
                if (UNLIKELY(hexfp)) {
                    /* This seriously overshoots in most cases, but
                     * better the undershooting.  Firstly, all bytes
                     * of the NV are not mantissa, some of them are
                     * exponent.  Secondly, for the reasonably common
                     * long doubles case, the "80-bit extended", two
                     * or six bytes of the NV are unused. */
                    need +=
                        (fv < 0) ? 1 : 0 + /* possible unary minus */
                        2 + /* "0x" */
                        1 + /* the very unlikely carry */
                        1 + /* "1" */
                        1 + /* "." */
                        2 * NVSIZE + /* 2 hexdigits for each byte */
                        2 + /* "p+" */
                        6 + /* exponent: sign, plus up to 16383 (quad fp) */
                        1;   /* \0 */
#ifdef LONGDOUBLE_DOUBLEDOUBLE
                    /* However, for the "double double", we need more.
                     * Since each double has their own exponent, the
                     * doubles may float (haha) rather far from each
                     * other, and the number of required bits is much
                     * larger, up to total of DOUBLEDOUBLE_MAXBITS bits.
                     * See the definition of DOUBLEDOUBLE_MAXBITS.
                     *
                     * Need 2 hexdigits for each byte. */
                    need += (DOUBLEDOUBLE_MAXBITS/8 + 1) * 2;
                    /* the size for the exponent already added */
#endif
#ifdef USE_LOCALE_NUMERIC
                        STORE_LC_NUMERIC_SET_TO_NEEDED();
                        if (PL_numeric_radix_sv && IN_LC(LC_NUMERIC))
                            need += SvLEN(PL_numeric_radix_sv);
                        RESTORE_LC_NUMERIC();
#endif
                }
                else if (i > 0) {
                    need = BIT_DIGITS(i);
                } /* if i < 0, the number of digits is hard to predict. */
	    }
	    need += has_precis ? precis : 6; /* known default */

	    if (need < width)
		need = width;

#ifdef HAS_LDBL_SPRINTF_BUG
	    /* This is to try to fix a bug with irix/nonstop-ux/powerux and
	       with sfio - Allen <allens@@cpan.org> */

#  ifdef DBL_MAX
#    define MY_DBL_MAX DBL_MAX
#  else /* XXX guessing! HUGE_VAL may be defined as infinity, so not using */
#    if DOUBLESIZE >= 8
#      define MY_DBL_MAX 1.7976931348623157E+308L
#    else
#      define MY_DBL_MAX 3.40282347E+38L
#    endif
#  endif

#  ifdef HAS_LDBL_SPRINTF_BUG_LESS1 /* only between -1L & 1L - Allen */
#    define MY_DBL_MAX_BUG 1L
#  else
#    define MY_DBL_MAX_BUG MY_DBL_MAX
#  endif

#  ifdef DBL_MIN
#    define MY_DBL_MIN DBL_MIN
#  else  /* XXX guessing! -Allen */
#    if DOUBLESIZE >= 8
#      define MY_DBL_MIN 2.2250738585072014E-308L
#    else
#      define MY_DBL_MIN 1.17549435E-38L
#    endif
#  endif

	    if ((intsize == 'q') && (c == 'f') &&
		((fv < MY_DBL_MAX_BUG) && (fv > -MY_DBL_MAX_BUG)) &&
		(need < DBL_DIG)) {
		/* it's going to be short enough that
		 * long double precision is not needed */

		if ((fv <= 0L) && (fv >= -0L))
		    fix_ldbl_sprintf_bug = TRUE; /* 0 is 0 - easiest */
		else {
		    /* would use Perl_fp_class as a double-check but not
		     * functional on IRIX - see perl.h comments */

		    if ((fv >= MY_DBL_MIN) || (fv <= -MY_DBL_MIN)) {
			/* It's within the range that a double can represent */
#if defined(DBL_MAX) && !defined(DBL_MIN)
			if ((fv >= ((long double)1/DBL_MAX)) ||
			    (fv <= (-(long double)1/DBL_MAX)))
#endif
			fix_ldbl_sprintf_bug = TRUE;
		    }
		}
		if (fix_ldbl_sprintf_bug == TRUE) {
		    double temp;

		    intsize = 0;
		    temp = (double)fv;
		    fv = (NV)temp;
		}
	    }

#  undef MY_DBL_MAX
#  undef MY_DBL_MAX_BUG
#  undef MY_DBL_MIN

#endif /* HAS_LDBL_SPRINTF_BUG */

	    need += 20; /* fudge factor */
	    if (PL_efloatsize < need) {
		Safefree(PL_efloatbuf);
		PL_efloatsize = need + 20; /* more fudge */
		Newx(PL_efloatbuf, PL_efloatsize, char);
		PL_efloatbuf[0] = '\0';
	    }

	    if ( !(width || left || plus || alt) && fill != '0'
		 && has_precis && intsize != 'q'	/* Shortcuts */
                 && LIKELY(!Perl_isinfnan((NV)fv)) ) {
		/* See earlier comment about buggy Gconvert when digits,
		   aka precis is 0  */
		if ( c == 'g' && precis ) {
                    STORE_LC_NUMERIC_SET_TO_NEEDED();
                    SNPRINTF_G(fv, PL_efloatbuf, PL_efloatsize, precis);
		    /* May return an empty string for digits==0 */
		    if (*PL_efloatbuf) {
			elen = strlen(PL_efloatbuf);
			goto float_converted;
		    }
		} else if ( c == 'f' && !precis ) {
		    if ((eptr = F0convert(nv, ebuf + sizeof ebuf, &elen)))
			break;
		}
	    }

            if (UNLIKELY(hexfp)) {
                /* Hexadecimal floating point. */
                char* p = PL_efloatbuf;
                U8 vhex[VHEX_SIZE];
                U8* v = vhex; /* working pointer to vhex */
                U8* vend; /* pointer to one beyond last digit of vhex */
                U8* vfnz = NULL; /* first non-zero */
                U8* vlnz = NULL; /* last non-zero */
                const bool lower = (c == 'a');
                /* At output the values of vhex (up to vend) will
                 * be mapped through the xdig to get the actual
                 * human-readable xdigits. */
                const char* xdig = PL_hexdigit;
                int zerotail = 0; /* how many extra zeros to append */
                int exponent = 0; /* exponent of the floating point input */
                bool hexradix = FALSE; /* should we output the radix */

                /* XXX: denormals, NaN, Inf.
                 *
                 * For example with denormals, (assuming the vanilla
                 * 64-bit double): the exponent is zero. 1xp-1074 is
                 * the smallest denormal and the smallest double, it
                 * should be output as 0x0.0000000000001p-1022 to
                 * match its internal structure. */

                vend = S_hextract(aTHX_ nv, &exponent, vhex, NULL);
                S_hextract(aTHX_ nv, &exponent, vhex, vend);

#if NVSIZE > DOUBLESIZE
#  ifdef HEXTRACT_HAS_IMPLICIT_BIT
                /* In this case there is an implicit bit,
                 * and therefore the exponent is shifted shift by one. */
                exponent--;
#  else
                /* In this case there is no implicit bit,
                 * and the exponent is shifted by the first xdigit. */
                exponent -= 4;
#  endif
#endif

                if (fv < 0
                    || Perl_signbit(nv)
                  )
                    *p++ = '-';
                else if (plus)
                    *p++ = plus;
                *p++ = '0';
                if (lower) {
                    *p++ = 'x';
                }
                else {
                    *p++ = 'X';
                    xdig += 16; /* Use uppercase hex. */
                }

                /* Find the first non-zero xdigit. */
                for (v = vhex; v < vend; v++) {
                    if (*v) {
                        vfnz = v;
                        break;
                    }
                }

                if (vfnz) {
                    /* Find the last non-zero xdigit. */
                    for (v = vend - 1; v >= vhex; v--) {
                        if (*v) {
                            vlnz = v;
                            break;
                        }
                    }

#if NVSIZE == DOUBLESIZE
                    if (fv != 0.0)
                        exponent--;
#endif

                    if (precis > 0) {
                        if ((SSize_t)(precis + 1) < vend - vhex) {
                            bool round;

                            v = vhex + precis + 1;
                            /* Round away from zero: if the tail
                             * beyond the precis xdigits is equal to
                             * or greater than 0x8000... */
                            round = *v > 0x8;
                            if (!round && *v == 0x8) {
                                for (v++; v < vend; v++) {
                                    if (*v) {
                                        round = TRUE;
                                        break;
                                    }
                                }
                            }
                            if (round) {
                                for (v = vhex + precis; v >= vhex; v--) {
                                    if (*v < 0xF) {
                                        (*v)++;
                                        break;
                                    }
                                    *v = 0;
                                    if (v == vhex) {
                                        /* If the carry goes all the way to
                                         * the front, we need to output
                                         * a single '1'. This goes against
                                         * the "xdigit and then radix"
                                         * but since this is "cannot happen"
                                         * category, that is probably good. */
                                        *p++ = xdig[1];
                                    }
                                }
                            }
                            /* The new effective "last non zero". */
                            vlnz = vhex + precis;
                        }
                        else {
                            zerotail = precis - (vlnz - vhex);
                        }
                    }

                    v = vhex;
                    *p++ = xdig[*v++];

                    /* If there are non-zero xdigits, the radix
                     * is output after the first one. */
                    if (vfnz < vlnz) {
                      hexradix = TRUE;
                    }
                }
                else {
                    *p++ = '0';
                    exponent = 0;
                    zerotail = precis;
                }

                /* The radix is always output if precis, or if alt. */
                if (precis > 0 || alt) {
                  hexradix = TRUE;
                }

                if (hexradix) {
#ifndef USE_LOCALE_NUMERIC
                        *p++ = '.';
#else
                        STORE_LC_NUMERIC_SET_TO_NEEDED();
                        if (PL_numeric_radix_sv && IN_LC(LC_NUMERIC)) {
                            STRLEN n;
                            const char* r = SvPV(PL_numeric_radix_sv, n);
                            Copy(r, p, n, char);
                            p += n;
                        }
                        else {
                            *p++ = '.';
                        }
                        RESTORE_LC_NUMERIC();
#endif
                }

                if (vlnz) {
                    while (v <= vlnz)
                        *p++ = xdig[*v++];
                }

                if (zerotail > 0) {
                  while (zerotail--) {
                    *p++ = '0';
                  }
                }

                elen = p - PL_efloatbuf;
                elen += my_snprintf(p, PL_efloatsize - elen,
                                    "%c%+d", lower ? 'p' : 'P',
                                    exponent);

                if (elen < width) {
                    if (left) {
                        /* Pad the back with spaces. */
                        memset(PL_efloatbuf + elen, ' ', width - elen);
                    }
                    else if (fill == '0') {
                        /* Insert the zeros between the "0x" and
                         * the digits, otherwise we end up with
                         * "0000xHHH..." */
                        STRLEN nzero = width - elen;
                        char* zerox = PL_efloatbuf + 2;
                        Move(zerox, zerox + nzero,  elen - 2, char);
                        memset(zerox, fill, nzero);
                    }
                    else {
                        /* Move it to the right. */
                        Move(PL_efloatbuf, PL_efloatbuf + width - elen,
                             elen, char);
                        /* Pad the front with spaces. */
                        memset(PL_efloatbuf, ' ', width - elen);
                    }
                    elen = width;
                }
            }
            else {
                elen = S_infnan_2pv(nv, PL_efloatbuf, PL_efloatsize, plus);
                if (elen) {
                    /* Not affecting infnan output: precision, alt, fill. */
                    if (elen < width) {
                        if (left) {
                            /* Pack the back with spaces. */
                            memset(PL_efloatbuf + elen, ' ', width - elen);
                        } else {
                            /* Move it to the right. */
                            Move(PL_efloatbuf, PL_efloatbuf + width - elen,
                                 elen, char);
                            /* Pad the front with spaces. */
                            memset(PL_efloatbuf, ' ', width - elen);
                        }
                        elen = width;
                    }
                }
            }

            if (elen == 0) {
                char *ptr = ebuf + sizeof ebuf;
                *--ptr = '\0';
                *--ptr = c;
#if defined(USE_QUADMATH)
		if (intsize == 'q') {
                    /* "g" -> "Qg" */
                    *--ptr = 'Q';
                }
                /* FIXME: what to do if HAS_LONG_DOUBLE but not PERL_PRIfldbl? */
#elif defined(HAS_LONG_DOUBLE) && defined(PERL_PRIfldbl)
		/* Note that this is HAS_LONG_DOUBLE and PERL_PRIfldbl,
		 * not USE_LONG_DOUBLE and NVff.  In other words,
		 * this needs to work without USE_LONG_DOUBLE. */
		if (intsize == 'q') {
		    /* Copy the one or more characters in a long double
		     * format before the 'base' ([efgEFG]) character to
		     * the format string. */
		    static char const ldblf[] = PERL_PRIfldbl;
		    char const *p = ldblf + sizeof(ldblf) - 3;
		    while (p >= ldblf) { *--ptr = *p--; }
		}
#endif
		if (has_precis) {
		    base = precis;
		    do { *--ptr = '0' + (base % 10); } while (base /= 10);
		    *--ptr = '.';
		}
		if (width) {
		    base = width;
		    do { *--ptr = '0' + (base % 10); } while (base /= 10);
		}
		if (fill == '0')
		    *--ptr = fill;
		if (left)
		    *--ptr = '-';
		if (plus)
		    *--ptr = plus;
		if (alt)
		    *--ptr = '#';
		*--ptr = '%';

		/* No taint.  Otherwise we are in the strange situation
		 * where printf() taints but print($float) doesn't.
		 * --jhi */

                STORE_LC_NUMERIC_SET_TO_NEEDED();

                /* hopefully the above makes ptr a very constrained format
                 * that is safe to use, even though it's not literal */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
#ifdef USE_QUADMATH
                {
                    const char* qfmt = quadmath_format_single(ptr);
                    if (!qfmt)
                        Perl_croak_nocontext("panic: quadmath invalid format \"%s\"", ptr);
                    elen = quadmath_snprintf(PL_efloatbuf, PL_efloatsize,
                                             qfmt, nv);
                    if ((IV)elen == -1)
                        Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", qfmt);
                    if (qfmt != ptr)
                        Safefree(qfmt);
                }
#elif defined(HAS_LONG_DOUBLE)
                elen = ((intsize == 'q')
                        ? my_snprintf(PL_efloatbuf, PL_efloatsize, ptr, fv)
                        : my_snprintf(PL_efloatbuf, PL_efloatsize, ptr, (double)fv));
#else
                elen = my_sprintf(PL_efloatbuf, ptr, fv);
#endif
                GCC_DIAG_RESTORE;
	    }

	float_converted:
	    eptr = PL_efloatbuf;
            assert((IV)elen > 0); /* here zero elen is bad */

#ifdef USE_LOCALE_NUMERIC
            /* If the decimal point character in the string is UTF-8, make the
             * output utf8 */
            if (PL_numeric_radix_sv && SvUTF8(PL_numeric_radix_sv)
                && instr(eptr, SvPVX_const(PL_numeric_radix_sv)))
            {
                is_utf8 = TRUE;
            }
#endif

	    break;

	    /* SPECIAL */

	case 'n':
	    if (vectorize)
		goto unknown;
	    i = SvCUR(sv) - origlen;
	    if (args) {
		switch (intsize) {
		case 'c':	*(va_arg(*args, char*)) = i; break;
		case 'h':	*(va_arg(*args, short*)) = i; break;
		default:	*(va_arg(*args, int*)) = i; break;
		case 'l':	*(va_arg(*args, long*)) = i; break;
		case 'V':	*(va_arg(*args, IV*)) = i; break;
		case 'z':	*(va_arg(*args, SSize_t*)) = i; break;
#ifdef HAS_PTRDIFF_T
		case 't':	*(va_arg(*args, ptrdiff_t*)) = i; break;
#endif
#ifdef I_STDINT
		case 'j':	*(va_arg(*args, intmax_t*)) = i; break;
#endif
		case 'q':
#if IVSIZE >= 8
				*(va_arg(*args, Quad_t*)) = i; break;
#else
				goto unknown;
#endif
		}
	    }
	    else
		sv_setuv_mg(argsv, has_utf8 ? (UV)sv_len_utf8(sv) : (UV)i);
            goto donevalidconversion;

	    /* UNKNOWN */

	default:
      unknown:
	    if (!args
		&& (PL_op->op_type == OP_PRTF || PL_op->op_type == OP_SPRINTF)
		&& ckWARN(WARN_PRINTF))
	    {
		SV * const msg = sv_newmortal();
		Perl_sv_setpvf(aTHX_ msg, "Invalid conversion in %sprintf: ",
			  (PL_op->op_type == OP_PRTF) ? "" : "s");
		if (fmtstart < patend) {
		    const char * const fmtend = q < patend ? q : patend;
		    const char * f;
		    sv_catpvs(msg, "\"%");
		    for (f = fmtstart; f < fmtend; f++) {
			if (isPRINT(*f)) {
			    sv_catpvn_nomg(msg, f, 1);
			} else {
			    Perl_sv_catpvf(aTHX_ msg,
					   "\\%03"UVof, (UV)*f & 0xFF);
			}
		    }
		    sv_catpvs(msg, "\"");
		} else {
		    sv_catpvs(msg, "end of string");
		}
		Perl_warner(aTHX_ packWARN(WARN_PRINTF), "%"SVf, SVfARG(msg)); /* yes, this is reentrant */
	    }

	    /* output mangled stuff ... */
	    if (c == '\0')
		--q;
	    eptr = p;
	    elen = q - p;

	    /* ... right here, because formatting flags should not apply */
	    SvGROW(sv, SvCUR(sv) + elen + 1);
	    p = SvEND(sv);
	    Copy(eptr, p, elen, char);
	    p += elen;
	    *p = '\0';
	    SvCUR_set(sv, p - SvPVX_const(sv));
	    svix = osvix;
	    continue;	/* not "break" */
	}

	if (is_utf8 != has_utf8) {
	    if (is_utf8) {
		if (SvCUR(sv))
		    sv_utf8_upgrade(sv);
	    }
	    else {
		const STRLEN old_elen = elen;
		SV * const nsv = newSVpvn_flags(eptr, elen, SVs_TEMP);
		sv_utf8_upgrade(nsv);
		eptr = SvPVX_const(nsv);
		elen = SvCUR(nsv);

		if (width) { /* fudge width (can't fudge elen) */
		    width += elen - old_elen;
		}
		is_utf8 = TRUE;
	    }
	}

        /* signed value that's wrapped? */
        assert(elen  <= ((~(STRLEN)0) >> 1));
	have = esignlen + zeros + elen;
	if (have < zeros)
	    croak_memory_wrap();

	need = (have > width ? have : width);
	gap = need - have;

	if (need >= (((STRLEN)~0) - SvCUR(sv) - dotstrlen - 1))
	    croak_memory_wrap();
	SvGROW(sv, SvCUR(sv) + need + dotstrlen + 1);
	p = SvEND(sv);
	if (esignlen && fill == '0') {
	    int i;
	    for (i = 0; i < (int)esignlen; i++)
		*p++ = esignbuf[i];
	}
	if (gap && !left) {
	    memset(p, fill, gap);
	    p += gap;
	}
	if (esignlen && fill != '0') {
	    int i;
	    for (i = 0; i < (int)esignlen; i++)
		*p++ = esignbuf[i];
	}
	if (zeros) {
	    int i;
	    for (i = zeros; i; i--)
		*p++ = '0';
	}
	if (elen) {
	    Copy(eptr, p, elen, char);
	    p += elen;
	}
	if (gap && left) {
	    memset(p, ' ', gap);
	    p += gap;
	}
	if (vectorize) {
	    if (veclen) {
		Copy(dotstr, p, dotstrlen, char);
		p += dotstrlen;
	    }
	    else
		vectorize = FALSE;		/* done iterating over vecstr */
	}
	if (is_utf8)
	    has_utf8 = TRUE;
	if (has_utf8)
	    SvUTF8_on(sv);
	*p = '\0';
	SvCUR_set(sv, p - SvPVX_const(sv));
	if (vectorize) {
	    esignlen = 0;
	    goto vector;
	}

      donevalidconversion:
        if (used_explicit_ix)
            no_redundant_warning = TRUE;
        if (arg_missing)
            S_warn_vcatpvfn_missing_argument(aTHX);
    }

    /* Now that we've consumed all our printf format arguments (svix)
     * do we have things left on the stack that we didn't use?
     */
    if (!no_redundant_warning && svmax >= svix + 1 && ckWARN(WARN_REDUNDANT)) {
	Perl_warner(aTHX_ packWARN(WARN_REDUNDANT), "Redundant argument in %s",
		PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn()");
    }

    SvTAINT(sv);

    RESTORE_LC_NUMERIC();   /* Done outside loop, so don't have to save/restore
                               each iteration. */
}

/* =========================================================================

=head1 Cloning an interpreter

=cut

All the macros and functions in this section are for the private use of
the main function, perl_clone().

The foo_dup() functions make an exact copy of an existing foo thingy.
During the course of a cloning, a hash table is used to map old addresses
to new addresses.  The table is created and manipulated with the
ptr_table_* functions.

 * =========================================================================*/


#if defined(USE_ITHREADS)

/* XXX Remove this so it doesn't have to go thru the macro and return for nothing */
#ifndef GpREFCNT_inc
#  define GpREFCNT_inc(gp)	((gp) ? (++(gp)->gp_refcnt, (gp)) : (GP*)NULL)
#endif


/* Certain cases in Perl_ss_dup have been merged, by relying on the fact
   that currently av_dup, gv_dup and hv_dup are the same as sv_dup.
   If this changes, please unmerge ss_dup.
   Likewise, sv_dup_inc_multiple() relies on this fact.  */
#define sv_dup_inc_NN(s,t)	SvREFCNT_inc_NN(sv_dup_inc(s,t))
#define av_dup(s,t)	MUTABLE_AV(sv_dup((const SV *)s,t))
#define av_dup_inc(s,t)	MUTABLE_AV(sv_dup_inc((const SV *)s,t))
#define hv_dup(s,t)	MUTABLE_HV(sv_dup((const SV *)s,t))
#define hv_dup_inc(s,t)	MUTABLE_HV(sv_dup_inc((const SV *)s,t))
#define cv_dup(s,t)	MUTABLE_CV(sv_dup((const SV *)s,t))
#define cv_dup_inc(s,t)	MUTABLE_CV(sv_dup_inc((const SV *)s,t))
#define io_dup(s,t)	MUTABLE_IO(sv_dup((const SV *)s,t))
#define io_dup_inc(s,t)	MUTABLE_IO(sv_dup_inc((const SV *)s,t))
#define gv_dup(s,t)	MUTABLE_GV(sv_dup((const SV *)s,t))
#define gv_dup_inc(s,t)	MUTABLE_GV(sv_dup_inc((const SV *)s,t))
#define SAVEPV(p)	((p) ? savepv(p) : NULL)
#define SAVEPVN(p,n)	((p) ? savepvn(p,n) : NULL)

/* clone a parser */

yy_parser *
Perl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param)
{
    yy_parser *parser;

    PERL_ARGS_ASSERT_PARSER_DUP;

    if (!proto)
	return NULL;

    /* look for it in the table first */
    parser = (yy_parser *)ptr_table_fetch(PL_ptr_table, proto);
    if (parser)
	return parser;

    /* create anew and remember what it is */
    Newxz(parser, 1, yy_parser);
    ptr_table_store(PL_ptr_table, proto, parser);

    /* XXX these not yet duped */
    parser->old_parser = NULL;
    parser->stack = NULL;
    parser->ps = NULL;
    parser->stack_size = 0;
    /* XXX parser->stack->state = 0; */

    /* XXX eventually, just Copy() most of the parser struct ? */

    parser->lex_brackets = proto->lex_brackets;
    parser->lex_casemods = proto->lex_casemods;
    parser->lex_brackstack = savepvn(proto->lex_brackstack,
		    (proto->lex_brackets < 120 ? 120 : proto->lex_brackets));
    parser->lex_casestack = savepvn(proto->lex_casestack,
		    (proto->lex_casemods < 12 ? 12 : proto->lex_casemods));
    parser->lex_defer	= proto->lex_defer;
    parser->lex_dojoin	= proto->lex_dojoin;
    parser->lex_formbrack = proto->lex_formbrack;
    parser->lex_inpat	= proto->lex_inpat;
    parser->lex_inwhat	= proto->lex_inwhat;
    parser->lex_op	= proto->lex_op;
    parser->lex_repl	= sv_dup_inc(proto->lex_repl, param);
    parser->lex_starts	= proto->lex_starts;
    parser->lex_stuff	= sv_dup_inc(proto->lex_stuff, param);
    parser->multi_close	= proto->multi_close;
    parser->multi_open	= proto->multi_open;
    parser->multi_start	= proto->multi_start;
    parser->multi_end	= proto->multi_end;
    parser->preambled	= proto->preambled;
    parser->sublex_info	= proto->sublex_info; /* XXX not quite right */
    parser->linestr	= sv_dup_inc(proto->linestr, param);
    parser->expect	= proto->expect;
    parser->copline	= proto->copline;
    parser->last_lop_op	= proto->last_lop_op;
    parser->lex_state	= proto->lex_state;
    parser->rsfp	= fp_dup(proto->rsfp, '<', param);
    /* rsfp_filters entries have fake IoDIRP() */
    parser->rsfp_filters= av_dup_inc(proto->rsfp_filters, param);
    parser->in_my	= proto->in_my;
    parser->in_my_stash	= hv_dup(proto->in_my_stash, param);
    parser->error_count	= proto->error_count;


    parser->linestr	= sv_dup_inc(proto->linestr, param);

    {
	char * const ols = SvPVX(proto->linestr);
	char * const ls  = SvPVX(parser->linestr);

	parser->bufptr	    = ls + (proto->bufptr >= ols ?
				    proto->bufptr -  ols : 0);
	parser->oldbufptr   = ls + (proto->oldbufptr >= ols ?
				    proto->oldbufptr -  ols : 0);
	parser->oldoldbufptr= ls + (proto->oldoldbufptr >= ols ?
				    proto->oldoldbufptr -  ols : 0);
	parser->linestart   = ls + (proto->linestart >= ols ?
				    proto->linestart -  ols : 0);
	parser->last_uni    = ls + (proto->last_uni >= ols ?
				    proto->last_uni -  ols : 0);
	parser->last_lop    = ls + (proto->last_lop >= ols ?
				    proto->last_lop -  ols : 0);

	parser->bufend	    = ls + SvCUR(parser->linestr);
    }

    Copy(proto->tokenbuf, parser->tokenbuf, 256, char);


    Copy(proto->nextval, parser->nextval, 5, YYSTYPE);
    Copy(proto->nexttype, parser->nexttype, 5,	I32);
    parser->nexttoke	= proto->nexttoke;

    /* XXX should clone saved_curcop here, but we aren't passed
     * proto_perl; so do it in perl_clone_using instead */

    return parser;
}


/* duplicate a file handle */

PerlIO *
Perl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param)
{
    PerlIO *ret;

    PERL_ARGS_ASSERT_FP_DUP;
    PERL_UNUSED_ARG(type);

    if (!fp)
	return (PerlIO*)NULL;

    /* look for it in the table first */
    ret = (PerlIO*)ptr_table_fetch(PL_ptr_table, fp);
    if (ret)
	return ret;

    /* create anew and remember what it is */
#ifdef __amigaos4__
    ret = PerlIO_fdupopen(aTHX_ fp, param, PERLIO_DUP_CLONE|PERLIO_DUP_FD);
#else
    ret = PerlIO_fdupopen(aTHX_ fp, param, PERLIO_DUP_CLONE);
#endif
    ptr_table_store(PL_ptr_table, fp, ret);
    return ret;
}

/* duplicate a directory handle */

DIR *
Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
{
    DIR *ret;

#if defined(HAS_FCHDIR) && defined(HAS_TELLDIR) && defined(HAS_SEEKDIR)
    DIR *pwd;
    const Direntry_t *dirent;
    char smallbuf[256]; /* XXX MAXPATHLEN, surely? */
    char *name = NULL;
    STRLEN len = 0;
    long pos;
#endif

    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_DIRP_DUP;

    if (!dp)
	return (DIR*)NULL;

    /* look for it in the table first */
    ret = (DIR*)ptr_table_fetch(PL_ptr_table, dp);
    if (ret)
	return ret;

#if defined(HAS_FCHDIR) && defined(HAS_TELLDIR) && defined(HAS_SEEKDIR)

    PERL_UNUSED_ARG(param);

    /* create anew */

    /* open the current directory (so we can switch back) */
    if (!(pwd = PerlDir_open("."))) return (DIR *)NULL;

    /* chdir to our dir handle and open the present working directory */
    if (fchdir(my_dirfd(dp)) < 0 || !(ret = PerlDir_open("."))) {
	PerlDir_close(pwd);
	return (DIR *)NULL;
    }
    /* Now we should have two dir handles pointing to the same dir. */

    /* Be nice to the calling code and chdir back to where we were. */
    /* XXX If this fails, then what? */
    PERL_UNUSED_RESULT(fchdir(my_dirfd(pwd)));

    /* We have no need of the pwd handle any more. */
    PerlDir_close(pwd);

#ifdef DIRNAMLEN
# define d_namlen(d) (d)->d_namlen
#else
# define d_namlen(d) strlen((d)->d_name)
#endif
    /* Iterate once through dp, to get the file name at the current posi-
       tion. Then step back. */
    pos = PerlDir_tell(dp);
    if ((dirent = PerlDir_read(dp))) {
	len = d_namlen(dirent);
        if (len > sizeof(dirent->d_name) && sizeof(dirent->d_name) > PTRSIZE) {
            /* If the len is somehow magically longer than the
             * maximum length of the directory entry, even though
             * we could fit it in a buffer, we could not copy it
             * from the dirent.  Bail out. */
            PerlDir_close(ret);
            return (DIR*)NULL;
        }
	if (len <= sizeof smallbuf) name = smallbuf;
	else Newx(name, len, char);
	Move(dirent->d_name, name, len, char);
    }
    PerlDir_seek(dp, pos);

    /* Iterate through the new dir handle, till we find a file with the
       right name. */
    if (!dirent) /* just before the end */
	for(;;) {
	    pos = PerlDir_tell(ret);
	    if (PerlDir_read(ret)) continue; /* not there yet */
	    PerlDir_seek(ret, pos); /* step back */
	    break;
	}
    else {
	const long pos0 = PerlDir_tell(ret);
	for(;;) {
	    pos = PerlDir_tell(ret);
	    if ((dirent = PerlDir_read(ret))) {
		if (len == (STRLEN)d_namlen(dirent)
                    && memEQ(name, dirent->d_name, len)) {
		    /* found it */
		    PerlDir_seek(ret, pos); /* step back */
		    break;
		}
		/* else we are not there yet; keep iterating */
	    }
	    else { /* This is not meant to happen. The best we can do is
	              reset the iterator to the beginning. */
		PerlDir_seek(ret, pos0);
		break;
	    }
	}
    }
#undef d_namlen

    if (name && name != smallbuf)
	Safefree(name);
#endif

#ifdef WIN32
    ret = win32_dirp_dup(dp, param);
#endif

    /* pop it in the pointer table */
    if (ret)
	ptr_table_store(PL_ptr_table, dp, ret);

    return ret;
}

/* duplicate a typeglob */

GP *
Perl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)
{
    GP *ret;

    PERL_ARGS_ASSERT_GP_DUP;

    if (!gp)
	return (GP*)NULL;
    /* look for it in the table first */
    ret = (GP*)ptr_table_fetch(PL_ptr_table, gp);
    if (ret)
	return ret;

    /* create anew and remember what it is */
    Newxz(ret, 1, GP);
    ptr_table_store(PL_ptr_table, gp, ret);

    /* clone */
    /* ret->gp_refcnt must be 0 before any other dups are called. We're relying
       on Newxz() to do this for us.  */
    ret->gp_sv		= sv_dup_inc(gp->gp_sv, param);
    ret->gp_io		= io_dup_inc(gp->gp_io, param);
    ret->gp_form	= cv_dup_inc(gp->gp_form, param);
    ret->gp_av		= av_dup_inc(gp->gp_av, param);
    ret->gp_hv		= hv_dup_inc(gp->gp_hv, param);
    ret->gp_egv	= gv_dup(gp->gp_egv, param);/* GvEGV is not refcounted */
    ret->gp_cv		= cv_dup_inc(gp->gp_cv, param);
    ret->gp_cvgen	= gp->gp_cvgen;
    ret->gp_line	= gp->gp_line;
    ret->gp_file_hek	= hek_dup(gp->gp_file_hek, param);
    return ret;
}

/* duplicate a chain of magic */

MAGIC *
Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)
{
    MAGIC *mgret = NULL;
    MAGIC **mgprev_p = &mgret;

    PERL_ARGS_ASSERT_MG_DUP;

    for (; mg; mg = mg->mg_moremagic) {
	MAGIC *nmg;

	if ((param->flags & CLONEf_JOIN_IN)
		&& mg->mg_type == PERL_MAGIC_backref)
	    /* when joining, we let the individual SVs add themselves to
	     * backref as needed. */
	    continue;

	Newx(nmg, 1, MAGIC);
	*mgprev_p = nmg;
	mgprev_p = &(nmg->mg_moremagic);

	/* There was a comment "XXX copy dynamic vtable?" but as we don't have
	   dynamic vtables, I'm not sure why Sarathy wrote it. The comment dates
	   from the original commit adding Perl_mg_dup() - revision 4538.
	   Similarly there is the annotation "XXX random ptr?" next to the
	   assignment to nmg->mg_ptr.  */
	*nmg = *mg;

	/* FIXME for plugins
	if (nmg->mg_type == PERL_MAGIC_qr) {
	    nmg->mg_obj	= MUTABLE_SV(CALLREGDUPE((REGEXP*)nmg->mg_obj, param));
	}
	else
	*/
	nmg->mg_obj = (nmg->mg_flags & MGf_REFCOUNTED)
			  ? nmg->mg_type == PERL_MAGIC_backref
				/* The backref AV has its reference
				 * count deliberately bumped by 1 */
				? SvREFCNT_inc(av_dup_inc((const AV *)
						    nmg->mg_obj, param))
				: sv_dup_inc(nmg->mg_obj, param)
			  : sv_dup(nmg->mg_obj, param);

	if (nmg->mg_ptr && nmg->mg_type != PERL_MAGIC_regex_global) {
	    if (nmg->mg_len > 0) {
		nmg->mg_ptr	= SAVEPVN(nmg->mg_ptr, nmg->mg_len);
		if (nmg->mg_type == PERL_MAGIC_overload_table &&
			AMT_AMAGIC((AMT*)nmg->mg_ptr))
		{
		    AMT * const namtp = (AMT*)nmg->mg_ptr;
		    sv_dup_inc_multiple((SV**)(namtp->table),
					(SV**)(namtp->table), NofAMmeth, param);
		}
	    }
	    else if (nmg->mg_len == HEf_SVKEY)
		nmg->mg_ptr = (char*)sv_dup_inc((const SV *)nmg->mg_ptr, param);
	}
	if ((nmg->mg_flags & MGf_DUP) && nmg->mg_virtual && nmg->mg_virtual->svt_dup) {
	    nmg->mg_virtual->svt_dup(aTHX_ nmg, param);
	}
    }
    return mgret;
}

#endif /* USE_ITHREADS */

struct ptr_tbl_arena {
    struct ptr_tbl_arena *next;
    struct ptr_tbl_ent array[1023/3]; /* as ptr_tbl_ent has 3 pointers.  */
};

/* create a new pointer-mapping table */

PTR_TBL_t *
Perl_ptr_table_new(pTHX)
{
    PTR_TBL_t *tbl;
    PERL_UNUSED_CONTEXT;

    Newx(tbl, 1, PTR_TBL_t);
    tbl->tbl_max	= 511;
    tbl->tbl_items	= 0;
    tbl->tbl_arena	= NULL;
    tbl->tbl_arena_next	= NULL;
    tbl->tbl_arena_end	= NULL;
    Newxz(tbl->tbl_ary, tbl->tbl_max + 1, PTR_TBL_ENT_t*);
    return tbl;
}

#define PTR_TABLE_HASH(ptr) \
  ((PTR2UV(ptr) >> 3) ^ (PTR2UV(ptr) >> (3 + 7)) ^ (PTR2UV(ptr) >> (3 + 17)))

/* map an existing pointer using a table */

STATIC PTR_TBL_ENT_t *
S_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)
{
    PTR_TBL_ENT_t *tblent;
    const UV hash = PTR_TABLE_HASH(sv);

    PERL_ARGS_ASSERT_PTR_TABLE_FIND;

    tblent = tbl->tbl_ary[hash & tbl->tbl_max];
    for (; tblent; tblent = tblent->next) {
	if (tblent->oldval == sv)
	    return tblent;
    }
    return NULL;
}

void *
Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)
{
    PTR_TBL_ENT_t const *const tblent = ptr_table_find(tbl, sv);

    PERL_ARGS_ASSERT_PTR_TABLE_FETCH;
    PERL_UNUSED_CONTEXT;

    return tblent ? tblent->newval : NULL;
}

/* add a new entry to a pointer-mapping table 'tbl'.  In hash terms, 'oldsv' is
 * the key; 'newsv' is the value.  The names "old" and "new" are specific to
 * the core's typical use of ptr_tables in thread cloning. */

void
Perl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv)
{
    PTR_TBL_ENT_t *tblent = ptr_table_find(tbl, oldsv);

    PERL_ARGS_ASSERT_PTR_TABLE_STORE;
    PERL_UNUSED_CONTEXT;

    if (tblent) {
	tblent->newval = newsv;
    } else {
	const UV entry = PTR_TABLE_HASH(oldsv) & tbl->tbl_max;

	if (tbl->tbl_arena_next == tbl->tbl_arena_end) {
	    struct ptr_tbl_arena *new_arena;

	    Newx(new_arena, 1, struct ptr_tbl_arena);
	    new_arena->next = tbl->tbl_arena;
	    tbl->tbl_arena = new_arena;
	    tbl->tbl_arena_next = new_arena->array;
	    tbl->tbl_arena_end = C_ARRAY_END(new_arena->array);
	}

	tblent = tbl->tbl_arena_next++;

	tblent->oldval = oldsv;
	tblent->newval = newsv;
	tblent->next = tbl->tbl_ary[entry];
	tbl->tbl_ary[entry] = tblent;
	tbl->tbl_items++;
	if (tblent->next && tbl->tbl_items > tbl->tbl_max)
	    ptr_table_split(tbl);
    }
}

/* double the hash bucket size of an existing ptr table */

void
Perl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl)
{
    PTR_TBL_ENT_t **ary = tbl->tbl_ary;
    const UV oldsize = tbl->tbl_max + 1;
    UV newsize = oldsize * 2;
    UV i;

    PERL_ARGS_ASSERT_PTR_TABLE_SPLIT;
    PERL_UNUSED_CONTEXT;

    Renew(ary, newsize, PTR_TBL_ENT_t*);
    Zero(&ary[oldsize], newsize-oldsize, PTR_TBL_ENT_t*);
    tbl->tbl_max = --newsize;
    tbl->tbl_ary = ary;
    for (i=0; i < oldsize; i++, ary++) {
	PTR_TBL_ENT_t **entp = ary;
	PTR_TBL_ENT_t *ent = *ary;
	PTR_TBL_ENT_t **curentp;
	if (!ent)
	    continue;
	curentp = ary + oldsize;
	do {
	    if ((newsize & PTR_TABLE_HASH(ent->oldval)) != i) {
		*entp = ent->next;
		ent->next = *curentp;
		*curentp = ent;
	    }
	    else
		entp = &ent->next;
	    ent = *entp;
	} while (ent);
    }
}

/* remove all the entries from a ptr table */
/* Deprecated - will be removed post 5.14 */

void
Perl_ptr_table_clear(pTHX_ PTR_TBL_t *const tbl)
{
    PERL_UNUSED_CONTEXT;
    if (tbl && tbl->tbl_items) {
	struct ptr_tbl_arena *arena = tbl->tbl_arena;

	Zero(tbl->tbl_ary, tbl->tbl_max + 1, struct ptr_tbl_ent *);

	while (arena) {
	    struct ptr_tbl_arena *next = arena->next;

	    Safefree(arena);
	    arena = next;
	};

	tbl->tbl_items = 0;
	tbl->tbl_arena = NULL;
	tbl->tbl_arena_next = NULL;
	tbl->tbl_arena_end = NULL;
    }
}

/* clear and free a ptr table */

void
Perl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl)
{
    struct ptr_tbl_arena *arena;

    PERL_UNUSED_CONTEXT;

    if (!tbl) {
        return;
    }

    arena = tbl->tbl_arena;

    while (arena) {
	struct ptr_tbl_arena *next = arena->next;

	Safefree(arena);
	arena = next;
    }

    Safefree(tbl->tbl_ary);
    Safefree(tbl);
}

#if defined(USE_ITHREADS)

void
Perl_rvpv_dup(pTHX_ SV *const dstr, const SV *const sstr, CLONE_PARAMS *const param)
{
    PERL_ARGS_ASSERT_RVPV_DUP;

    assert(!isREGEXP(sstr));
    if (SvROK(sstr)) {
	if (SvWEAKREF(sstr)) {
	    SvRV_set(dstr, sv_dup(SvRV_const(sstr), param));
	    if (param->flags & CLONEf_JOIN_IN) {
		/* if joining, we add any back references individually rather
		 * than copying the whole backref array */
		Perl_sv_add_backref(aTHX_ SvRV(dstr), dstr);
	    }
	}
	else
	    SvRV_set(dstr, sv_dup_inc(SvRV_const(sstr), param));
    }
    else if (SvPVX_const(sstr)) {
	/* Has something there */
	if (SvLEN(sstr)) {
	    /* Normal PV - clone whole allocated space */
	    SvPV_set(dstr, SAVEPVN(SvPVX_const(sstr), SvLEN(sstr)-1));
	    /* sstr may not be that normal, but actually copy on write.
	       But we are a true, independent SV, so:  */
	    SvIsCOW_off(dstr);
	}
	else {
	    /* Special case - not normally malloced for some reason */
	    if (isGV_with_GP(sstr)) {
		/* Don't need to do anything here.  */
	    }
	    else if ((SvIsCOW(sstr))) {
		/* A "shared" PV - clone it as "shared" PV */
		SvPV_set(dstr,
			 HEK_KEY(hek_dup(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr)),
					 param)));
	    }
	    else {
		/* Some other special case - random pointer */
		SvPV_set(dstr, (char *) SvPVX_const(sstr));		
	    }
	}
    }
    else {
	/* Copy the NULL */
	SvPV_set(dstr, NULL);
    }
}

/* duplicate a list of SVs. source and dest may point to the same memory.  */
static SV **
S_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest,
		      SSize_t items, CLONE_PARAMS *const param)
{
    PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE;

    while (items-- > 0) {
	*dest++ = sv_dup_inc(*source++, param);
    }

    return dest;
}

/* duplicate an SV of any type (including AV, HV etc) */

static SV *
S_sv_dup_common(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
{
    dVAR;
    SV *dstr;

    PERL_ARGS_ASSERT_SV_DUP_COMMON;

    if (SvTYPE(sstr) == (svtype)SVTYPEMASK) {
#ifdef DEBUG_LEAKING_SCALARS_ABORT
	abort();
#endif
	return NULL;
    }
    /* look for it in the table first */
    dstr = MUTABLE_SV(ptr_table_fetch(PL_ptr_table, sstr));
    if (dstr)
	return dstr;

    if(param->flags & CLONEf_JOIN_IN) {
        /** We are joining here so we don't want do clone
	    something that is bad **/
	if (SvTYPE(sstr) == SVt_PVHV) {
	    const HEK * const hvname = HvNAME_HEK(sstr);
	    if (hvname) {
		/** don't clone stashes if they already exist **/
		dstr = MUTABLE_SV(gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname),
                                                HEK_UTF8(hvname) ? SVf_UTF8 : 0));
		ptr_table_store(PL_ptr_table, sstr, dstr);
		return dstr;
	    }
        }
	else if (SvTYPE(sstr) == SVt_PVGV && !SvFAKE(sstr)) {
	    HV *stash = GvSTASH(sstr);
	    const HEK * hvname;
	    if (stash && (hvname = HvNAME_HEK(stash))) {
		/** don't clone GVs if they already exist **/
		SV **svp;
		stash = gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname),
				    HEK_UTF8(hvname) ? SVf_UTF8 : 0);
		svp = hv_fetch(
			stash, GvNAME(sstr),
			GvNAMEUTF8(sstr)
			    ? -GvNAMELEN(sstr)
			    :  GvNAMELEN(sstr),
			0
		      );
		if (svp && *svp && SvTYPE(*svp) == SVt_PVGV) {
		    ptr_table_store(PL_ptr_table, sstr, *svp);
		    return *svp;
		}
	    }
        }
    }

    /* create anew and remember what it is */
    new_SV(dstr);

#ifdef DEBUG_LEAKING_SCALARS
    dstr->sv_debug_optype = sstr->sv_debug_optype;
    dstr->sv_debug_line = sstr->sv_debug_line;
    dstr->sv_debug_inpad = sstr->sv_debug_inpad;
    dstr->sv_debug_parent = (SV*)sstr;
    FREE_SV_DEBUG_FILE(dstr);
    dstr->sv_debug_file = savesharedpv(sstr->sv_debug_file);
#endif

    ptr_table_store(PL_ptr_table, sstr, dstr);

    /* clone */
    SvFLAGS(dstr)	= SvFLAGS(sstr);
    SvFLAGS(dstr)	&= ~SVf_OOK;		/* don't propagate OOK hack */
    SvREFCNT(dstr)	= 0;			/* must be before any other dups! */

#ifdef DEBUGGING
    if (SvANY(sstr) && PL_watch_pvx && SvPVX_const(sstr) == PL_watch_pvx)
	PerlIO_printf(Perl_debug_log, "watch at %p hit, found string \"%s\"\n",
		      (void*)PL_watch_pvx, SvPVX_const(sstr));
#endif

    /* don't clone objects whose class has asked us not to */
    if (SvOBJECT(sstr)
     && ! (SvFLAGS(SvSTASH(sstr)) & SVphv_CLONEABLE))
    {
	SvFLAGS(dstr) = 0;
	return dstr;
    }

    switch (SvTYPE(sstr)) {
    case SVt_NULL:
	SvANY(dstr)	= NULL;
	break;
    case SVt_IV:
	SET_SVANY_FOR_BODYLESS_IV(dstr);
	if(SvROK(sstr)) {
	    Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	} else {
	    SvIV_set(dstr, SvIVX(sstr));
	}
	break;
    case SVt_NV:
#if NVSIZE <= IVSIZE
	SET_SVANY_FOR_BODYLESS_NV(dstr);
#else
	SvANY(dstr)	= new_XNV();
#endif
	SvNV_set(dstr, SvNVX(sstr));
	break;
    default:
	{
	    /* These are all the types that need complex bodies allocating.  */
	    void *new_body;
	    const svtype sv_type = SvTYPE(sstr);
	    const struct body_details *const sv_type_details
		= bodies_by_type + sv_type;

	    switch (sv_type) {
	    default:
		Perl_croak(aTHX_ "Bizarre SvTYPE [%" IVdf "]", (IV)SvTYPE(sstr));
		break;

	    case SVt_PVGV:
	    case SVt_PVIO:
	    case SVt_PVFM:
	    case SVt_PVHV:
	    case SVt_PVAV:
	    case SVt_PVCV:
	    case SVt_PVLV:
	    case SVt_REGEXP:
	    case SVt_PVMG:
	    case SVt_PVNV:
	    case SVt_PVIV:
            case SVt_INVLIST:
	    case SVt_PV:
		assert(sv_type_details->body_size);
		if (sv_type_details->arena) {
		    new_body_inline(new_body, sv_type);
		    new_body
			= (void*)((char*)new_body - sv_type_details->offset);
		} else {
		    new_body = new_NOARENA(sv_type_details);
		}
	    }
	    assert(new_body);
	    SvANY(dstr) = new_body;

#ifndef PURIFY
	    Copy(((char*)SvANY(sstr)) + sv_type_details->offset,
		 ((char*)SvANY(dstr)) + sv_type_details->offset,
		 sv_type_details->copy, char);
#else
	    Copy(((char*)SvANY(sstr)),
		 ((char*)SvANY(dstr)),
		 sv_type_details->body_size + sv_type_details->offset, char);
#endif

	    if (sv_type != SVt_PVAV && sv_type != SVt_PVHV
		&& !isGV_with_GP(dstr)
		&& !isREGEXP(dstr)
		&& !(sv_type == SVt_PVIO && !(IoFLAGS(dstr) & IOf_FAKE_DIRP)))
		Perl_rvpv_dup(aTHX_ dstr, sstr, param);

	    /* The Copy above means that all the source (unduplicated) pointers
	       are now in the destination.  We can check the flags and the
	       pointers in either, but it's possible that there's less cache
	       missing by always going for the destination.
	       FIXME - instrument and check that assumption  */
	    if (sv_type >= SVt_PVMG) {
		if (SvMAGIC(dstr))
		    SvMAGIC_set(dstr, mg_dup(SvMAGIC(dstr), param));
		if (SvOBJECT(dstr) && SvSTASH(dstr))
		    SvSTASH_set(dstr, hv_dup_inc(SvSTASH(dstr), param));
		else SvSTASH_set(dstr, 0); /* don't copy DESTROY cache */
	    }

	    /* The cast silences a GCC warning about unhandled types.  */
	    switch ((int)sv_type) {
	    case SVt_PV:
		break;
	    case SVt_PVIV:
		break;
	    case SVt_PVNV:
		break;
	    case SVt_PVMG:
		break;
	    case SVt_REGEXP:
	      duprex:
		/* FIXME for plugins */
		dstr->sv_u.svu_rx = ((REGEXP *)dstr)->sv_any;
		re_dup_guts((REGEXP*) sstr, (REGEXP*) dstr, param);
		break;
	    case SVt_PVLV:
		/* XXX LvTARGOFF sometimes holds PMOP* when DEBUGGING */
		if (LvTYPE(dstr) == 't') /* for tie: unrefcnted fake (SV**) */
		    LvTARG(dstr) = dstr;
		else if (LvTYPE(dstr) == 'T') /* for tie: fake HE */
		    LvTARG(dstr) = MUTABLE_SV(he_dup((HE*)LvTARG(dstr), 0, param));
		else
		    LvTARG(dstr) = sv_dup_inc(LvTARG(dstr), param);
		if (isREGEXP(sstr)) goto duprex;
	    case SVt_PVGV:
		/* non-GP case already handled above */
		if(isGV_with_GP(sstr)) {
		    GvNAME_HEK(dstr) = hek_dup(GvNAME_HEK(dstr), param);
		    /* Don't call sv_add_backref here as it's going to be
		       created as part of the magic cloning of the symbol
		       table--unless this is during a join and the stash
		       is not actually being cloned.  */
		    /* Danger Will Robinson - GvGP(dstr) isn't initialised
		       at the point of this comment.  */
		    GvSTASH(dstr) = hv_dup(GvSTASH(dstr), param);
		    if (param->flags & CLONEf_JOIN_IN)
			Perl_sv_add_backref(aTHX_ MUTABLE_SV(GvSTASH(dstr)), dstr);
		    GvGP_set(dstr, gp_dup(GvGP(sstr), param));
		    (void)GpREFCNT_inc(GvGP(dstr));
		}
		break;
	    case SVt_PVIO:
		/* PL_parser->rsfp_filters entries have fake IoDIRP() */
		if(IoFLAGS(dstr) & IOf_FAKE_DIRP) {
		    /* I have no idea why fake dirp (rsfps)
		       should be treated differently but otherwise
		       we end up with leaks -- sky*/
		    IoTOP_GV(dstr)      = gv_dup_inc(IoTOP_GV(dstr), param);
		    IoFMT_GV(dstr)      = gv_dup_inc(IoFMT_GV(dstr), param);
		    IoBOTTOM_GV(dstr)   = gv_dup_inc(IoBOTTOM_GV(dstr), param);
		} else {
		    IoTOP_GV(dstr)      = gv_dup(IoTOP_GV(dstr), param);
		    IoFMT_GV(dstr)      = gv_dup(IoFMT_GV(dstr), param);
		    IoBOTTOM_GV(dstr)   = gv_dup(IoBOTTOM_GV(dstr), param);
		    if (IoDIRP(dstr)) {
			IoDIRP(dstr)	= dirp_dup(IoDIRP(dstr), param);
		    } else {
			NOOP;
			/* IoDIRP(dstr) is already a copy of IoDIRP(sstr)  */
		    }
		    IoIFP(dstr)	= fp_dup(IoIFP(sstr), IoTYPE(dstr), param);
		}
		if (IoOFP(dstr) == IoIFP(sstr))
		    IoOFP(dstr) = IoIFP(dstr);
		else
		    IoOFP(dstr)	= fp_dup(IoOFP(dstr), IoTYPE(dstr), param);
		IoTOP_NAME(dstr)	= SAVEPV(IoTOP_NAME(dstr));
		IoFMT_NAME(dstr)	= SAVEPV(IoFMT_NAME(dstr));
		IoBOTTOM_NAME(dstr)	= SAVEPV(IoBOTTOM_NAME(dstr));
		break;
	    case SVt_PVAV:
		/* avoid cloning an empty array */
		if (AvARRAY((const AV *)sstr) && AvFILLp((const AV *)sstr) >= 0) {
		    SV **dst_ary, **src_ary;
		    SSize_t items = AvFILLp((const AV *)sstr) + 1;

		    src_ary = AvARRAY((const AV *)sstr);
		    Newxz(dst_ary, AvMAX((const AV *)sstr)+1, SV*);
		    ptr_table_store(PL_ptr_table, src_ary, dst_ary);
		    AvARRAY(MUTABLE_AV(dstr)) = dst_ary;
		    AvALLOC((const AV *)dstr) = dst_ary;
		    if (AvREAL((const AV *)sstr)) {
			dst_ary = sv_dup_inc_multiple(src_ary, dst_ary, items,
						      param);
		    }
		    else {
			while (items-- > 0)
			    *dst_ary++ = sv_dup(*src_ary++, param);
		    }
		    items = AvMAX((const AV *)sstr) - AvFILLp((const AV *)sstr);
		    while (items-- > 0) {
			*dst_ary++ = NULL;
		    }
		}
		else {
		    AvARRAY(MUTABLE_AV(dstr))	= NULL;
		    AvALLOC((const AV *)dstr)	= (SV**)NULL;
		    AvMAX(  (const AV *)dstr)	= -1;
		    AvFILLp((const AV *)dstr)	= -1;
		}
		break;
	    case SVt_PVHV:
		if (HvARRAY((const HV *)sstr)) {
		    STRLEN i = 0;
		    const bool sharekeys = !!HvSHAREKEYS(sstr);
		    XPVHV * const dxhv = (XPVHV*)SvANY(dstr);
		    XPVHV * const sxhv = (XPVHV*)SvANY(sstr);
		    char *darray;
		    Newx(darray, PERL_HV_ARRAY_ALLOC_BYTES(dxhv->xhv_max+1)
			+ (SvOOK(sstr) ? sizeof(struct xpvhv_aux) : 0),
			char);
		    HvARRAY(dstr) = (HE**)darray;
		    while (i <= sxhv->xhv_max) {
			const HE * const source = HvARRAY(sstr)[i];
			HvARRAY(dstr)[i] = source
			    ? he_dup(source, sharekeys, param) : 0;
			++i;
		    }
		    if (SvOOK(sstr)) {
			const struct xpvhv_aux * const saux = HvAUX(sstr);
			struct xpvhv_aux * const daux = HvAUX(dstr);
			/* This flag isn't copied.  */
			SvOOK_on(dstr);

			if (saux->xhv_name_count) {
			    HEK ** const sname = saux->xhv_name_u.xhvnameu_names;
			    const I32 count
			     = saux->xhv_name_count < 0
			        ? -saux->xhv_name_count
			        :  saux->xhv_name_count;
			    HEK **shekp = sname + count;
			    HEK **dhekp;
			    Newx(daux->xhv_name_u.xhvnameu_names, count, HEK *);
			    dhekp = daux->xhv_name_u.xhvnameu_names + count;
			    while (shekp-- > sname) {
				dhekp--;
				*dhekp = hek_dup(*shekp, param);
			    }
			}
			else {
			    daux->xhv_name_u.xhvnameu_name
				= hek_dup(saux->xhv_name_u.xhvnameu_name,
					  param);
			}
			daux->xhv_name_count = saux->xhv_name_count;

			daux->xhv_fill_lazy = saux->xhv_fill_lazy;
			daux->xhv_aux_flags = saux->xhv_aux_flags;
#ifdef PERL_HASH_RANDOMIZE_KEYS
			daux->xhv_rand = saux->xhv_rand;
			daux->xhv_last_rand = saux->xhv_last_rand;
#endif
			daux->xhv_riter = saux->xhv_riter;
			daux->xhv_eiter = saux->xhv_eiter
			    ? he_dup(saux->xhv_eiter,
					cBOOL(HvSHAREKEYS(sstr)), param) : 0;
			/* backref array needs refcnt=2; see sv_add_backref */
			daux->xhv_backreferences =
			    (param->flags & CLONEf_JOIN_IN)
				/* when joining, we let the individual GVs and
				 * CVs add themselves to backref as
				 * needed. This avoids pulling in stuff
				 * that isn't required, and simplifies the
				 * case where stashes aren't cloned back
				 * if they already exist in the parent
				 * thread */
			    ? NULL
			    : saux->xhv_backreferences
				? (SvTYPE(saux->xhv_backreferences) == SVt_PVAV)
				    ? MUTABLE_AV(SvREFCNT_inc(
					  sv_dup_inc((const SV *)
					    saux->xhv_backreferences, param)))
				    : MUTABLE_AV(sv_dup((const SV *)
					    saux->xhv_backreferences, param))
				: 0;

                        daux->xhv_mro_meta = saux->xhv_mro_meta
                            ? mro_meta_dup(saux->xhv_mro_meta, param)
                            : 0;

			/* Record stashes for possible cloning in Perl_clone(). */
			if (HvNAME(sstr))
			    av_push(param->stashes, dstr);
		    }
		}
		else
		    HvARRAY(MUTABLE_HV(dstr)) = NULL;
		break;
	    case SVt_PVCV:
		if (!(param->flags & CLONEf_COPY_STACKS)) {
		    CvDEPTH(dstr) = 0;
		}
		/* FALLTHROUGH */
	    case SVt_PVFM:
		/* NOTE: not refcounted */
		SvANY(MUTABLE_CV(dstr))->xcv_stash =
		    hv_dup(CvSTASH(dstr), param);
		if ((param->flags & CLONEf_JOIN_IN) && CvSTASH(dstr))
		    Perl_sv_add_backref(aTHX_ MUTABLE_SV(CvSTASH(dstr)), dstr);
		if (!CvISXSUB(dstr)) {
		    OP_REFCNT_LOCK;
		    CvROOT(dstr) = OpREFCNT_inc(CvROOT(dstr));
		    OP_REFCNT_UNLOCK;
		    CvSLABBED_off(dstr);
		} else if (CvCONST(dstr)) {
		    CvXSUBANY(dstr).any_ptr =
			sv_dup_inc((const SV *)CvXSUBANY(dstr).any_ptr, param);
		}
		assert(!CvSLABBED(dstr));
		if (CvDYNFILE(dstr)) CvFILE(dstr) = SAVEPV(CvFILE(dstr));
		if (CvNAMED(dstr))
		    SvANY((CV *)dstr)->xcv_gv_u.xcv_hek =
			hek_dup(CvNAME_HEK((CV *)sstr), param);
		/* don't dup if copying back - CvGV isn't refcounted, so the
		 * duped GV may never be freed. A bit of a hack! DAPM */
		else
		  SvANY(MUTABLE_CV(dstr))->xcv_gv_u.xcv_gv =
		    CvCVGV_RC(dstr)
		    ? gv_dup_inc(CvGV(sstr), param)
		    : (param->flags & CLONEf_JOIN_IN)
			? NULL
			: gv_dup(CvGV(sstr), param);

		if (!CvISXSUB(sstr)) {
		    PADLIST * padlist = CvPADLIST(sstr);
		    if(padlist)
			padlist = padlist_dup(padlist, param);
		    CvPADLIST_set(dstr, padlist);
		} else
/* unthreaded perl can't sv_dup so we dont support unthreaded's CvHSCXT */
		    PoisonPADLIST(dstr);

		CvOUTSIDE(dstr)	=
		    CvWEAKOUTSIDE(sstr)
		    ? cv_dup(    CvOUTSIDE(dstr), param)
		    : cv_dup_inc(CvOUTSIDE(dstr), param);
		break;
	    }
	}
    }

    return dstr;
 }

SV *
Perl_sv_dup_inc(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
{
    PERL_ARGS_ASSERT_SV_DUP_INC;
    return sstr ? SvREFCNT_inc(sv_dup_common(sstr, param)) : NULL;
}

SV *
Perl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
{
    SV *dstr = sstr ? sv_dup_common(sstr, param) : NULL;
    PERL_ARGS_ASSERT_SV_DUP;

    /* Track every SV that (at least initially) had a reference count of 0.
       We need to do this by holding an actual reference to it in this array.
       If we attempt to cheat, turn AvREAL_off(), and store only pointers
       (akin to the stashes hash, and the perl stack), we come unstuck if
       a weak reference (or other SV legitimately SvREFCNT() == 0 for this
       thread) is manipulated in a CLONE method, because CLONE runs before the
       unreferenced array is walked to find SVs still with SvREFCNT() == 0
       (and fix things up by giving each a reference via the temps stack).
       Instead, during CLONE, if the 0-referenced SV has SvREFCNT_inc() and
       then SvREFCNT_dec(), it will be cleaned up (and added to the free list)
       before the walk of unreferenced happens and a reference to that is SV
       added to the temps stack. At which point we have the same SV considered
       to be in use, and free to be re-used. Not good.
    */
    if (dstr && !(param->flags & CLONEf_COPY_STACKS) && !SvREFCNT(dstr)) {
	assert(param->unreferenced);
	av_push(param->unreferenced, SvREFCNT_inc(dstr));
    }

    return dstr;
}

/* duplicate a context */

PERL_CONTEXT *
Perl_cx_dup(pTHX_ PERL_CONTEXT *cxs, I32 ix, I32 max, CLONE_PARAMS* param)
{
    PERL_CONTEXT *ncxs;

    PERL_ARGS_ASSERT_CX_DUP;

    if (!cxs)
	return (PERL_CONTEXT*)NULL;

    /* look for it in the table first */
    ncxs = (PERL_CONTEXT*)ptr_table_fetch(PL_ptr_table, cxs);
    if (ncxs)
	return ncxs;

    /* create anew and remember what it is */
    Newx(ncxs, max + 1, PERL_CONTEXT);
    ptr_table_store(PL_ptr_table, cxs, ncxs);
    Copy(cxs, ncxs, max + 1, PERL_CONTEXT);

    while (ix >= 0) {
	PERL_CONTEXT * const ncx = &ncxs[ix];
	if (CxTYPE(ncx) == CXt_SUBST) {
	    Perl_croak(aTHX_ "Cloning substitution context is unimplemented");
	}
	else {
	    ncx->blk_oldcop = (COP*)any_dup(ncx->blk_oldcop, param->proto_perl);
	    switch (CxTYPE(ncx)) {
	    case CXt_SUB:
		ncx->blk_sub.cv		= cv_dup_inc(ncx->blk_sub.cv, param);
		if(CxHASARGS(ncx)){
		    ncx->blk_sub.savearray = av_dup_inc(ncx->blk_sub.savearray,param);
		} else {
		    ncx->blk_sub.savearray = NULL;
		}
		ncx->blk_sub.prevcomppad = (PAD*)ptr_table_fetch(PL_ptr_table,
					   ncx->blk_sub.prevcomppad);
		break;
	    case CXt_EVAL:
		ncx->blk_eval.old_namesv = sv_dup_inc(ncx->blk_eval.old_namesv,
						      param);
                /* XXX should this sv_dup_inc? Or only if SvSCREAM ???? */
		ncx->blk_eval.cur_text	= sv_dup(ncx->blk_eval.cur_text, param);
		ncx->blk_eval.cv = cv_dup(ncx->blk_eval.cv, param);
                /* XXX what do do with cur_top_env ???? */
		break;
	    case CXt_LOOP_LAZYSV:
		ncx->blk_loop.state_u.lazysv.end
		    = sv_dup_inc(ncx->blk_loop.state_u.lazysv.end, param);
                /* Fallthrough: duplicate lazysv.cur by using the ary.ary
                   duplication code instead.
                   We are taking advantage of (1) av_dup_inc and sv_dup_inc
                   actually being the same function, and (2) order
                   equivalence of the two unions.
		   We can assert the later [but only at run time :-(]  */
		assert ((void *) &ncx->blk_loop.state_u.ary.ary ==
			(void *) &ncx->blk_loop.state_u.lazysv.cur);
                /* FALLTHROUGH */
	    case CXt_LOOP_ARY:
		ncx->blk_loop.state_u.ary.ary
		    = av_dup_inc(ncx->blk_loop.state_u.ary.ary, param);
                /* FALLTHROUGH */
	    case CXt_LOOP_LIST:
	    case CXt_LOOP_LAZYIV:
                /* code common to all 'for' CXt_LOOP_* types */
		ncx->blk_loop.itersave =
                                    sv_dup_inc(ncx->blk_loop.itersave, param);
		if (CxPADLOOP(ncx)) {
                    PADOFFSET off = ncx->blk_loop.itervar_u.svp
                                    - &CX_CURPAD_SV(ncx->blk_loop, 0);
                    ncx->blk_loop.oldcomppad =
                                    (PAD*)ptr_table_fetch(PL_ptr_table,
                                                ncx->blk_loop.oldcomppad);
		    ncx->blk_loop.itervar_u.svp =
                                    &CX_CURPAD_SV(ncx->blk_loop, off);
                }
		else {
                    /* this copies the GV if CXp_FOR_GV, or the SV for an
                     * alias (for \$x (...)) - relies on gv_dup being the
                     * same as sv_dup */
		    ncx->blk_loop.itervar_u.gv
			= gv_dup((const GV *)ncx->blk_loop.itervar_u.gv,
				    param);
		}
		break;
	    case CXt_LOOP_PLAIN:
		break;
	    case CXt_FORMAT:
		ncx->blk_format.prevcomppad =
                        (PAD*)ptr_table_fetch(PL_ptr_table,
					   ncx->blk_format.prevcomppad);
		ncx->blk_format.cv	= cv_dup_inc(ncx->blk_format.cv, param);
		ncx->blk_format.gv	= gv_dup(ncx->blk_format.gv, param);
		ncx->blk_format.dfoutgv	= gv_dup_inc(ncx->blk_format.dfoutgv,
						     param);
		break;
	    case CXt_GIVEN:
		ncx->blk_givwhen.defsv_save =
                                sv_dup_inc(ncx->blk_givwhen.defsv_save, param);
		break;
	    case CXt_BLOCK:
	    case CXt_NULL:
	    case CXt_WHEN:
		break;
	    }
	}
	--ix;
    }
    return ncxs;
}

/* duplicate a stack info structure */

PERL_SI *
Perl_si_dup(pTHX_ PERL_SI *si, CLONE_PARAMS* param)
{
    PERL_SI *nsi;

    PERL_ARGS_ASSERT_SI_DUP;

    if (!si)
	return (PERL_SI*)NULL;

    /* look for it in the table first */
    nsi = (PERL_SI*)ptr_table_fetch(PL_ptr_table, si);
    if (nsi)
	return nsi;

    /* create anew and remember what it is */
    Newxz(nsi, 1, PERL_SI);
    ptr_table_store(PL_ptr_table, si, nsi);

    nsi->si_stack	= av_dup_inc(si->si_stack, param);
    nsi->si_cxix	= si->si_cxix;
    nsi->si_cxmax	= si->si_cxmax;
    nsi->si_cxstack	= cx_dup(si->si_cxstack, si->si_cxix, si->si_cxmax, param);
    nsi->si_type	= si->si_type;
    nsi->si_prev	= si_dup(si->si_prev, param);
    nsi->si_next	= si_dup(si->si_next, param);
    nsi->si_markoff	= si->si_markoff;

    return nsi;
}

#define POPINT(ss,ix)	((ss)[--(ix)].any_i32)
#define TOPINT(ss,ix)	((ss)[ix].any_i32)
#define POPLONG(ss,ix)	((ss)[--(ix)].any_long)
#define TOPLONG(ss,ix)	((ss)[ix].any_long)
#define POPIV(ss,ix)	((ss)[--(ix)].any_iv)
#define TOPIV(ss,ix)	((ss)[ix].any_iv)
#define POPUV(ss,ix)	((ss)[--(ix)].any_uv)
#define TOPUV(ss,ix)	((ss)[ix].any_uv)
#define POPBOOL(ss,ix)	((ss)[--(ix)].any_bool)
#define TOPBOOL(ss,ix)	((ss)[ix].any_bool)
#define POPPTR(ss,ix)	((ss)[--(ix)].any_ptr)
#define TOPPTR(ss,ix)	((ss)[ix].any_ptr)
#define POPDPTR(ss,ix)	((ss)[--(ix)].any_dptr)
#define TOPDPTR(ss,ix)	((ss)[ix].any_dptr)
#define POPDXPTR(ss,ix)	((ss)[--(ix)].any_dxptr)
#define TOPDXPTR(ss,ix)	((ss)[ix].any_dxptr)

/* XXXXX todo */
#define pv_dup_inc(p)	SAVEPV(p)
#define pv_dup(p)	SAVEPV(p)
#define svp_dup_inc(p,pp)	any_dup(p,pp)

/* map any object to the new equivent - either something in the
 * ptr table, or something in the interpreter structure
 */

void *
Perl_any_dup(pTHX_ void *v, const PerlInterpreter *proto_perl)
{
    void *ret;

    PERL_ARGS_ASSERT_ANY_DUP;

    if (!v)
	return (void*)NULL;

    /* look for it in the table first */
    ret = ptr_table_fetch(PL_ptr_table, v);
    if (ret)
	return ret;

    /* see if it is part of the interpreter structure */
    if (v >= (void*)proto_perl && v < (void*)(proto_perl+1))
	ret = (void*)(((char*)aTHX) + (((char*)v) - (char*)proto_perl));
    else {
	ret = v;
    }

    return ret;
}

/* duplicate the save stack */

ANY *
Perl_ss_dup(pTHX_ PerlInterpreter *proto_perl, CLONE_PARAMS* param)
{
    dVAR;
    ANY * const ss	= proto_perl->Isavestack;
    const I32 max	= proto_perl->Isavestack_max + SS_MAXPUSH;
    I32 ix		= proto_perl->Isavestack_ix;
    ANY *nss;
    const SV *sv;
    const GV *gv;
    const AV *av;
    const HV *hv;
    void* ptr;
    int intval;
    long longval;
    GP *gp;
    IV iv;
    I32 i;
    char *c = NULL;
    void (*dptr) (void*);
    void (*dxptr) (pTHX_ void*);

    PERL_ARGS_ASSERT_SS_DUP;

    Newxz(nss, max, ANY);

    while (ix > 0) {
	const UV uv = POPUV(ss,ix);
	const U8 type = (U8)uv & SAVE_MASK;

	TOPUV(nss,ix) = uv;
	switch (type) {
	case SAVEt_CLEARSV:
	case SAVEt_CLEARPADRANGE:
	    break;
	case SAVEt_HELEM:		/* hash element */
	case SAVEt_SV:			/* scalar reference */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = SvREFCNT_inc(sv_dup_inc(sv, param));
	    /* FALLTHROUGH */
	case SAVEt_ITEM:			/* normal string */
        case SAVEt_GVSV:			/* scalar slot in GV */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    if (type == SAVEt_SV)
		break;
	    /* FALLTHROUGH */
	case SAVEt_FREESV:
	case SAVEt_MORTALIZESV:
	case SAVEt_READONLY_OFF:
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    break;
	case SAVEt_FREEPADNAME:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = padname_dup((PADNAME *)ptr, param);
	    PadnameREFCNT((PADNAME *)TOPPTR(nss,ix))++;
	    break;
	case SAVEt_SHARED_PVREF:		/* char* in shared space */
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = savesharedpv(c);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    break;
        case SAVEt_GENERIC_SVREF:		/* generic sv */
        case SAVEt_SVREF:			/* scalar reference */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    if (type == SAVEt_SVREF)
		SvREFCNT_inc_simple_void((SV *)TOPPTR(nss,ix));
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = svp_dup_inc((SV**)ptr, proto_perl);/* XXXXX */
	    break;
        case SAVEt_GVSLOT:		/* any slot in GV */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = svp_dup_inc((SV**)ptr, proto_perl);/* XXXXX */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    break;
        case SAVEt_HV:				/* hash reference */
        case SAVEt_AV:				/* array reference */
	    sv = (const SV *) POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    /* FALLTHROUGH */
	case SAVEt_COMPPAD:
	case SAVEt_NSTAB:
	    sv = (const SV *) POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
	    break;
	case SAVEt_INT:				/* int reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    intval = (int)POPINT(ss,ix);
	    TOPINT(nss,ix) = intval;
	    break;
	case SAVEt_LONG:			/* long reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    longval = (long)POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    break;
	case SAVEt_I32:				/* I32 reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_IV:				/* IV reference */
	case SAVEt_STRLEN:			/* STRLEN/size_t ref */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
	    break;
	case SAVEt_TMPSFLOOR:
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
	    break;
	case SAVEt_HPTR:			/* HV* reference */
	case SAVEt_APTR:			/* AV* reference */
	case SAVEt_SPTR:			/* SV* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
	    break;
	case SAVEt_VPTR:			/* random* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    /* FALLTHROUGH */
	case SAVEt_INT_SMALL:
	case SAVEt_I32_SMALL:
	case SAVEt_I16:				/* I16 reference */
	case SAVEt_I8:				/* I8 reference */
	case SAVEt_BOOL:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    break;
	case SAVEt_GENERIC_PVREF:		/* generic char* */
	case SAVEt_PPTR:			/* char* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
	    break;
	case SAVEt_GP:				/* scalar reference */
	    gp = (GP*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gp = gp_dup(gp, param);
	    (void)GpREFCNT_inc(gp);
	    gv = (const GV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup_inc(gv, param);
	    break;
	case SAVEt_FREEOP:
	    ptr = POPPTR(ss,ix);
	    if (ptr && (((OP*)ptr)->op_private & OPpREFCOUNTED)) {
		/* these are assumed to be refcounted properly */
		OP *o;
		switch (((OP*)ptr)->op_type) {
		case OP_LEAVESUB:
		case OP_LEAVESUBLV:
		case OP_LEAVEEVAL:
		case OP_LEAVE:
		case OP_SCOPE:
		case OP_LEAVEWRITE:
		    TOPPTR(nss,ix) = ptr;
		    o = (OP*)ptr;
		    OP_REFCNT_LOCK;
		    (void) OpREFCNT_inc(o);
		    OP_REFCNT_UNLOCK;
		    break;
		default:
		    TOPPTR(nss,ix) = NULL;
		    break;
		}
	    }
	    else
		TOPPTR(nss,ix) = NULL;
	    break;
	case SAVEt_FREECOPHH:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = cophh_copy((COPHH *)ptr);
	    break;
	case SAVEt_ADELETE:
	    av = (const AV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup_inc(av, param);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_DELETE:
	    hv = (const HV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    /* FALLTHROUGH */
	case SAVEt_FREEPV:
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup_inc(c);
	    break;
	case SAVEt_STACK_POS:		/* Position on Perl stack */
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_DESTRUCTOR:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);	/* XXX quite arbitrary */
	    dptr = POPDPTR(ss,ix);
	    TOPDPTR(nss,ix) = DPTR2FPTR(void (*)(void*),
					any_dup(FPTR2DPTR(void *, dptr),
						proto_perl));
	    break;
	case SAVEt_DESTRUCTOR_X:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);	/* XXX quite arbitrary */
	    dxptr = POPDXPTR(ss,ix);
	    TOPDXPTR(nss,ix) = DPTR2FPTR(void (*)(pTHX_ void*),
					 any_dup(FPTR2DPTR(void *, dxptr),
						 proto_perl));
	    break;
	case SAVEt_REGCONTEXT:
	case SAVEt_ALLOC:
	    ix -= uv >> SAVE_TIGHT_SHIFT;
	    break;
	case SAVEt_AELEM:		/* array element */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = SvREFCNT_inc(sv_dup_inc(sv, param));
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    av = (const AV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup_inc(av, param);
	    break;
	case SAVEt_OP:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = ptr;
	    break;
	case SAVEt_HINTS:
	    ptr = POPPTR(ss,ix);
	    ptr = cophh_copy((COPHH*)ptr);
	    TOPPTR(nss,ix) = ptr;
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    if (i & HINT_LOCALIZE_HH) {
		hv = (const HV *)POPPTR(ss,ix);
		TOPPTR(nss,ix) = hv_dup_inc(hv, param);
	    }
	    break;
	case SAVEt_PADSV_AND_MORTALIZE:
	    longval = (long)POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    break;
	case SAVEt_SET_SVFLAGS:
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
	    break;
	case SAVEt_COMPILE_WARNINGS:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = DUP_WARNINGS((STRLEN*)ptr);
	    break;
	case SAVEt_PARSER:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = parser_dup((const yy_parser*)ptr, param);
	    break;
	default:
	    Perl_croak(aTHX_
		       "panic: ss_dup inconsistency (%"IVdf")", (IV) type);
	}
    }

    return nss;
}


/* if sv is a stash, call $class->CLONE_SKIP(), and set the SVphv_CLONEABLE
 * flag to the result. This is done for each stash before cloning starts,
 * so we know which stashes want their objects cloned */

static void
do_mark_cloneable_stash(pTHX_ SV *const sv)
{
    const HEK * const hvname = HvNAME_HEK((const HV *)sv);
    if (hvname) {
	GV* const cloner = gv_fetchmethod_autoload(MUTABLE_HV(sv), "CLONE_SKIP", 0);
	SvFLAGS(sv) |= SVphv_CLONEABLE; /* clone objects by default */
	if (cloner && GvCV(cloner)) {
	    dSP;
	    UV status;

	    ENTER;
	    SAVETMPS;
	    PUSHMARK(SP);
	    mXPUSHs(newSVhek(hvname));
	    PUTBACK;
	    call_sv(MUTABLE_SV(GvCV(cloner)), G_SCALAR);
	    SPAGAIN;
	    status = POPu;
	    PUTBACK;
	    FREETMPS;
	    LEAVE;
	    if (status)
		SvFLAGS(sv) &= ~SVphv_CLONEABLE;
	}
    }
}



/*
=for apidoc perl_clone

Create and return a new interpreter by cloning the current one.

C<perl_clone> takes these flags as parameters:

C<CLONEf_COPY_STACKS> - is used to, well, copy the stacks also,
without it we only clone the data and zero the stacks,
with it we copy the stacks and the new perl interpreter is
ready to run at the exact same point as the previous one.
The pseudo-fork code uses C<COPY_STACKS> while the
threads->create doesn't.

C<CLONEf_KEEP_PTR_TABLE> -
C<perl_clone> keeps a ptr_table with the pointer of the old
variable as a key and the new variable as a value,
this allows it to check if something has been cloned and not
clone it again but rather just use the value and increase the
refcount.  If C<KEEP_PTR_TABLE> is not set then C<perl_clone> will kill
the ptr_table using the function
C<ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;>,
reason to keep it around is if you want to dup some of your own
variable who are outside the graph perl scans, an example of this
code is in F<threads.xs> create.

C<CLONEf_CLONE_HOST> -
This is a win32 thing, it is ignored on unix, it tells perls
win32host code (which is c++) to clone itself, this is needed on
win32 if you want to run two threads at the same time,
if you just want to do some stuff in a separate perl interpreter
and then throw it away and return to the original one,
you don't need to do anything.

=cut
*/

/* XXX the above needs expanding by someone who actually understands it ! */
EXTERN_C PerlInterpreter *
perl_clone_host(PerlInterpreter* proto_perl, UV flags);

PerlInterpreter *
perl_clone(PerlInterpreter *proto_perl, UV flags)
{
   dVAR;
#ifdef PERL_IMPLICIT_SYS

    PERL_ARGS_ASSERT_PERL_CLONE;

   /* perlhost.h so we need to call into it
   to clone the host, CPerlHost should have a c interface, sky */

#ifndef __amigaos4__
   if (flags & CLONEf_CLONE_HOST) {
       return perl_clone_host(proto_perl,flags);
   }
#endif
   return perl_clone_using(proto_perl, flags,
			    proto_perl->IMem,
			    proto_perl->IMemShared,
			    proto_perl->IMemParse,
			    proto_perl->IEnv,
			    proto_perl->IStdIO,
			    proto_perl->ILIO,
			    proto_perl->IDir,
			    proto_perl->ISock,
			    proto_perl->IProc);
}

PerlInterpreter *
perl_clone_using(PerlInterpreter *proto_perl, UV flags,
		 struct IPerlMem* ipM, struct IPerlMem* ipMS,
		 struct IPerlMem* ipMP, struct IPerlEnv* ipE,
		 struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO,
		 struct IPerlDir* ipD, struct IPerlSock* ipS,
		 struct IPerlProc* ipP)
{
    /* XXX many of the string copies here can be optimized if they're
     * constants; they need to be allocated as common memory and just
     * their pointers copied. */

    IV i;
    CLONE_PARAMS clone_params;
    CLONE_PARAMS* const param = &clone_params;

    PerlInterpreter * const my_perl = (PerlInterpreter*)(*ipM->pMalloc)(ipM, sizeof(PerlInterpreter));

    PERL_ARGS_ASSERT_PERL_CLONE_USING;
#else		/* !PERL_IMPLICIT_SYS */
    IV i;
    CLONE_PARAMS clone_params;
    CLONE_PARAMS* param = &clone_params;
    PerlInterpreter * const my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));

    PERL_ARGS_ASSERT_PERL_CLONE;
#endif		/* PERL_IMPLICIT_SYS */

    /* for each stash, determine whether its objects should be cloned */
    S_visit(proto_perl, do_mark_cloneable_stash, SVt_PVHV, SVTYPEMASK);
    PERL_SET_THX(my_perl);

#ifdef DEBUGGING
    PoisonNew(my_perl, 1, PerlInterpreter);
    PL_op = NULL;
    PL_curcop = NULL;
    PL_defstash = NULL; /* may be used by perl malloc() */
    PL_markstack = 0;
    PL_scopestack = 0;
    PL_scopestack_name = 0;
    PL_savestack = 0;
    PL_savestack_ix = 0;
    PL_savestack_max = -1;
    PL_sig_pending = 0;
    PL_parser = NULL;
    Zero(&PL_debug_pad, 1, struct perl_debug_pad);
    Zero(&PL_padname_undef, 1, PADNAME);
    Zero(&PL_padname_const, 1, PADNAME);
#  ifdef DEBUG_LEAKING_SCALARS
    PL_sv_serial = (((UV)my_perl >> 2) & 0xfff) * 1000000;
#  endif
#  ifdef PERL_TRACE_OPS
    Zero(PL_op_exec_cnt, OP_max+2, UV);
#  endif
#else	/* !DEBUGGING */
    Zero(my_perl, 1, PerlInterpreter);
#endif	/* DEBUGGING */

#ifdef PERL_IMPLICIT_SYS
    /* host pointers */
    PL_Mem		= ipM;
    PL_MemShared	= ipMS;
    PL_MemParse		= ipMP;
    PL_Env		= ipE;
    PL_StdIO		= ipStd;
    PL_LIO		= ipLIO;
    PL_Dir		= ipD;
    PL_Sock		= ipS;
    PL_Proc		= ipP;
#endif		/* PERL_IMPLICIT_SYS */


    param->flags = flags;
    /* Nothing in the core code uses this, but we make it available to
       extensions (using mg_dup).  */
    param->proto_perl = proto_perl;
    /* Likely nothing will use this, but it is initialised to be consistent
       with Perl_clone_params_new().  */
    param->new_perl = my_perl;
    param->unreferenced = NULL;


    INIT_TRACK_MEMPOOL(my_perl->Imemory_debug_header, my_perl);

    PL_body_arenas = NULL;
    Zero(&PL_body_roots, 1, PL_body_roots);
    
    PL_sv_count		= 0;
    PL_sv_root		= NULL;
    PL_sv_arenaroot	= NULL;

    PL_debug		= proto_perl->Idebug;

    /* dbargs array probably holds garbage */
    PL_dbargs		= NULL;

    PL_compiling = proto_perl->Icompiling;

    /* pseudo environmental stuff */
    PL_origargc		= proto_perl->Iorigargc;
    PL_origargv		= proto_perl->Iorigargv;

#ifndef NO_TAINT_SUPPORT
    /* Set tainting stuff before PerlIO_debug can possibly get called */
    PL_tainting		= proto_perl->Itainting;
    PL_taint_warn	= proto_perl->Itaint_warn;
#else
    PL_tainting         = FALSE;
    PL_taint_warn	= FALSE;
#endif

    PL_minus_c		= proto_perl->Iminus_c;

    PL_localpatches	= proto_perl->Ilocalpatches;
    PL_splitstr		= proto_perl->Isplitstr;
    PL_minus_n		= proto_perl->Iminus_n;
    PL_minus_p		= proto_perl->Iminus_p;
    PL_minus_l		= proto_perl->Iminus_l;
    PL_minus_a		= proto_perl->Iminus_a;
    PL_minus_E		= proto_perl->Iminus_E;
    PL_minus_F		= proto_perl->Iminus_F;
    PL_doswitches	= proto_perl->Idoswitches;
    PL_dowarn		= proto_perl->Idowarn;
#ifdef PERL_SAWAMPERSAND
    PL_sawampersand	= proto_perl->Isawampersand;
#endif
    PL_unsafe		= proto_perl->Iunsafe;
    PL_perldb		= proto_perl->Iperldb;
    PL_perl_destruct_level = proto_perl->Iperl_destruct_level;
    PL_exit_flags       = proto_perl->Iexit_flags;

    /* XXX time(&PL_basetime) when asked for? */
    PL_basetime		= proto_perl->Ibasetime;

    PL_maxsysfd		= proto_perl->Imaxsysfd;
    PL_statusvalue	= proto_perl->Istatusvalue;
#ifdef __VMS
    PL_statusvalue_vms	= proto_perl->Istatusvalue_vms;
#else
    PL_statusvalue_posix = proto_perl->Istatusvalue_posix;
#endif

    /* RE engine related */
    PL_regmatch_slab	= NULL;
    PL_reg_curpm	= NULL;

    PL_sub_generation	= proto_perl->Isub_generation;

    /* funky return mechanisms */
    PL_forkprocess	= proto_perl->Iforkprocess;

    /* internal state */
    PL_maxo		= proto_perl->Imaxo;

    PL_main_start	= proto_perl->Imain_start;
    PL_eval_root	= proto_perl->Ieval_root;
    PL_eval_start	= proto_perl->Ieval_start;

    PL_filemode		= proto_perl->Ifilemode;
    PL_lastfd		= proto_perl->Ilastfd;
    PL_oldname		= proto_perl->Ioldname;		/* XXX not quite right */
    PL_Argv		= NULL;
    PL_Cmd		= NULL;
    PL_gensym		= proto_perl->Igensym;

    PL_laststatval	= proto_perl->Ilaststatval;
    PL_laststype	= proto_perl->Ilaststype;
    PL_mess_sv		= NULL;

    PL_profiledata	= NULL;

    PL_generation	= proto_perl->Igeneration;

    PL_in_clean_objs	= proto_perl->Iin_clean_objs;
    PL_in_clean_all	= proto_perl->Iin_clean_all;

    PL_delaymagic_uid	= proto_perl->Idelaymagic_uid;
    PL_delaymagic_euid	= proto_perl->Idelaymagic_euid;
    PL_delaymagic_gid	= proto_perl->Idelaymagic_gid;
    PL_delaymagic_egid	= proto_perl->Idelaymagic_egid;
    PL_nomemok		= proto_perl->Inomemok;
    PL_an		= proto_perl->Ian;
    PL_evalseq		= proto_perl->Ievalseq;
    PL_origenviron	= proto_perl->Iorigenviron;	/* XXX not quite right */
    PL_origalen		= proto_perl->Iorigalen;

    PL_sighandlerp	= proto_perl->Isighandlerp;

    PL_runops		= proto_perl->Irunops;

    PL_subline		= proto_perl->Isubline;

    PL_cv_has_eval	= proto_perl->Icv_has_eval;

#ifdef FCRYPT
    PL_cryptseen	= proto_perl->Icryptseen;
#endif

#ifdef USE_LOCALE_COLLATE
    PL_collation_ix	= proto_perl->Icollation_ix;
    PL_collation_standard	= proto_perl->Icollation_standard;
    PL_collxfrm_base	= proto_perl->Icollxfrm_base;
    PL_collxfrm_mult	= proto_perl->Icollxfrm_mult;
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    PL_numeric_standard	= proto_perl->Inumeric_standard;
    PL_numeric_local	= proto_perl->Inumeric_local;
#endif /* !USE_LOCALE_NUMERIC */

    /* Did the locale setup indicate UTF-8? */
    PL_utf8locale	= proto_perl->Iutf8locale;
    PL_in_utf8_CTYPE_locale = proto_perl->Iin_utf8_CTYPE_locale;
    /* Unicode features (see perlrun/-C) */
    PL_unicode		= proto_perl->Iunicode;

    /* Pre-5.8 signals control */
    PL_signals		= proto_perl->Isignals;

    /* times() ticks per second */
    PL_clocktick	= proto_perl->Iclocktick;

    /* Recursion stopper for PerlIO_find_layer */
    PL_in_load_module	= proto_perl->Iin_load_module;

    /* sort() routine */
    PL_sort_RealCmp	= proto_perl->Isort_RealCmp;

    /* Not really needed/useful since the reenrant_retint is "volatile",
     * but do it for consistency's sake. */
    PL_reentrant_retint	= proto_perl->Ireentrant_retint;

    /* Hooks to shared SVs and locks. */
    PL_sharehook	= proto_perl->Isharehook;
    PL_lockhook		= proto_perl->Ilockhook;
    PL_unlockhook	= proto_perl->Iunlockhook;
    PL_threadhook	= proto_perl->Ithreadhook;
    PL_destroyhook	= proto_perl->Idestroyhook;
    PL_signalhook	= proto_perl->Isignalhook;

    PL_globhook		= proto_perl->Iglobhook;

    /* swatch cache */
    PL_last_swash_hv	= NULL;	/* reinits on demand */
    PL_last_swash_klen	= 0;
    PL_last_swash_key[0]= '\0';
    PL_last_swash_tmps	= (U8*)NULL;
    PL_last_swash_slen	= 0;

    PL_srand_called	= proto_perl->Isrand_called;
    Copy(&(proto_perl->Irandom_state), &PL_random_state, 1, PL_RANDOM_STATE_TYPE);

    if (flags & CLONEf_COPY_STACKS) {
	/* next allocation will be PL_tmps_stack[PL_tmps_ix+1] */
	PL_tmps_ix		= proto_perl->Itmps_ix;
	PL_tmps_max		= proto_perl->Itmps_max;
	PL_tmps_floor		= proto_perl->Itmps_floor;

	/* next push_scope()/ENTER sets PL_scopestack[PL_scopestack_ix]
	 * NOTE: unlike the others! */
	PL_scopestack_ix	= proto_perl->Iscopestack_ix;
	PL_scopestack_max	= proto_perl->Iscopestack_max;

	/* next SSPUSHFOO() sets PL_savestack[PL_savestack_ix]
	 * NOTE: unlike the others! */
	PL_savestack_ix		= proto_perl->Isavestack_ix;
	PL_savestack_max	= proto_perl->Isavestack_max;
    }

    PL_start_env	= proto_perl->Istart_env;	/* XXXXXX */
    PL_top_env		= &PL_start_env;

    PL_op		= proto_perl->Iop;

    PL_Sv		= NULL;
    PL_Xpv		= (XPV*)NULL;
    my_perl->Ina	= proto_perl->Ina;

    PL_statbuf		= proto_perl->Istatbuf;
    PL_statcache	= proto_perl->Istatcache;

#ifndef NO_TAINT_SUPPORT
    PL_tainted		= proto_perl->Itainted;
#else
    PL_tainted          = FALSE;
#endif
    PL_curpm		= proto_perl->Icurpm;	/* XXX No PMOP ref count */

    PL_chopset		= proto_perl->Ichopset;	/* XXX never deallocated */

    PL_restartjmpenv	= proto_perl->Irestartjmpenv;
    PL_restartop	= proto_perl->Irestartop;
    PL_in_eval		= proto_perl->Iin_eval;
    PL_delaymagic	= proto_perl->Idelaymagic;
    PL_phase		= proto_perl->Iphase;
    PL_localizing	= proto_perl->Ilocalizing;

    PL_hv_fetch_ent_mh	= NULL;
    PL_modcount		= proto_perl->Imodcount;
    PL_lastgotoprobe	= NULL;
    PL_dumpindent	= proto_perl->Idumpindent;

    PL_efloatbuf	= NULL;		/* reinits on demand */
    PL_efloatsize	= 0;			/* reinits on demand */

    /* regex stuff */

    PL_colorset		= 0;		/* reinits PL_colors[] */
    /*PL_colors[6]	= {0,0,0,0,0,0};*/

    /* Pluggable optimizer */
    PL_peepp		= proto_perl->Ipeepp;
    PL_rpeepp		= proto_perl->Irpeepp;
    /* op_free() hook */
    PL_opfreehook	= proto_perl->Iopfreehook;

#ifdef USE_REENTRANT_API
    /* XXX: things like -Dm will segfault here in perlio, but doing
     *  PERL_SET_CONTEXT(proto_perl);
     * breaks too many other things
     */
    Perl_reentrant_init(aTHX);
#endif

    /* create SV map for pointer relocation */
    PL_ptr_table = ptr_table_new();

    /* initialize these special pointers as early as possible */
    init_constants();
    ptr_table_store(PL_ptr_table, &proto_perl->Isv_undef, &PL_sv_undef);
    ptr_table_store(PL_ptr_table, &proto_perl->Isv_no, &PL_sv_no);
    ptr_table_store(PL_ptr_table, &proto_perl->Isv_yes, &PL_sv_yes);
    ptr_table_store(PL_ptr_table, &proto_perl->Ipadname_const,
		    &PL_padname_const);

    /* create (a non-shared!) shared string table */
    PL_strtab		= newHV();
    HvSHAREKEYS_off(PL_strtab);
    hv_ksplit(PL_strtab, HvTOTALKEYS(proto_perl->Istrtab));
    ptr_table_store(PL_ptr_table, proto_perl->Istrtab, PL_strtab);

    Zero(PL_sv_consts, SV_CONSTS_COUNT, SV*);

    /* This PV will be free'd special way so must set it same way op.c does */
    PL_compiling.cop_file    = savesharedpv(PL_compiling.cop_file);
    ptr_table_store(PL_ptr_table, proto_perl->Icompiling.cop_file, PL_compiling.cop_file);

    ptr_table_store(PL_ptr_table, &proto_perl->Icompiling, &PL_compiling);
    PL_compiling.cop_warnings = DUP_WARNINGS(PL_compiling.cop_warnings);
    CopHINTHASH_set(&PL_compiling, cophh_copy(CopHINTHASH_get(&PL_compiling)));
    PL_curcop		= (COP*)any_dup(proto_perl->Icurcop, proto_perl);

    param->stashes      = newAV();  /* Setup array of objects to call clone on */
    /* This makes no difference to the implementation, as it always pushes
       and shifts pointers to other SVs without changing their reference
       count, with the array becoming empty before it is freed. However, it
       makes it conceptually clear what is going on, and will avoid some
       work inside av.c, filling slots between AvFILL() and AvMAX() with
       &PL_sv_undef, and SvREFCNT_dec()ing those.  */
    AvREAL_off(param->stashes);

    if (!(flags & CLONEf_COPY_STACKS)) {
	param->unreferenced = newAV();
    }

#ifdef PERLIO_LAYERS
    /* Clone PerlIO tables as soon as we can handle general xx_dup() */
    PerlIO_clone(aTHX_ proto_perl, param);
#endif

    PL_envgv		= gv_dup_inc(proto_perl->Ienvgv, param);
    PL_incgv		= gv_dup_inc(proto_perl->Iincgv, param);
    PL_hintgv		= gv_dup_inc(proto_perl->Ihintgv, param);
    PL_origfilename	= SAVEPV(proto_perl->Iorigfilename);
    PL_xsubfilename	= proto_perl->Ixsubfilename;
    PL_diehook		= sv_dup_inc(proto_perl->Idiehook, param);
    PL_warnhook		= sv_dup_inc(proto_perl->Iwarnhook, param);

    /* switches */
    PL_patchlevel	= sv_dup_inc(proto_perl->Ipatchlevel, param);
    PL_inplace		= SAVEPV(proto_perl->Iinplace);
    PL_e_script		= sv_dup_inc(proto_perl->Ie_script, param);

    /* magical thingies */

    PL_encoding		= sv_dup(proto_perl->Iencoding, param);
    PL_lex_encoding     = sv_dup(proto_perl->Ilex_encoding, param);

    sv_setpvs(PERL_DEBUG_PAD(0), "");	/* For regex debugging. */
    sv_setpvs(PERL_DEBUG_PAD(1), "");	/* ext/re needs these */
    sv_setpvs(PERL_DEBUG_PAD(2), "");	/* even without DEBUGGING. */

   
    /* Clone the regex array */
    /* ORANGE FIXME for plugins, probably in the SV dup code.
       newSViv(PTR2IV(CALLREGDUPE(
       INT2PTR(REGEXP *, SvIVX(regex)), param))))
    */
    PL_regex_padav = av_dup_inc(proto_perl->Iregex_padav, param);
    PL_regex_pad = AvARRAY(PL_regex_padav);

    PL_stashpadmax	= proto_perl->Istashpadmax;
    PL_stashpadix	= proto_perl->Istashpadix ;
    Newx(PL_stashpad, PL_stashpadmax, HV *);
    {
	PADOFFSET o = 0;
	for (; o < PL_stashpadmax; ++o)
	    PL_stashpad[o] = hv_dup(proto_perl->Istashpad[o], param);
    }

    /* shortcuts to various I/O objects */
    PL_ofsgv            = gv_dup_inc(proto_perl->Iofsgv, param);
    PL_stdingv		= gv_dup(proto_perl->Istdingv, param);
    PL_stderrgv		= gv_dup(proto_perl->Istderrgv, param);
    PL_defgv		= gv_dup(proto_perl->Idefgv, param);
    PL_argvgv		= gv_dup_inc(proto_perl->Iargvgv, param);
    PL_argvoutgv	= gv_dup(proto_perl->Iargvoutgv, param);
    PL_argvout_stack	= av_dup_inc(proto_perl->Iargvout_stack, param);

    /* shortcuts to regexp stuff */
    PL_replgv		= gv_dup_inc(proto_perl->Ireplgv, param);

    /* shortcuts to misc objects */
    PL_errgv		= gv_dup(proto_perl->Ierrgv, param);

    /* shortcuts to debugging objects */
    PL_DBgv		= gv_dup_inc(proto_perl->IDBgv, param);
    PL_DBline		= gv_dup_inc(proto_perl->IDBline, param);
    PL_DBsub		= gv_dup_inc(proto_perl->IDBsub, param);
    PL_DBsingle		= sv_dup(proto_perl->IDBsingle, param);
    PL_DBtrace		= sv_dup(proto_perl->IDBtrace, param);
    PL_DBsignal		= sv_dup(proto_perl->IDBsignal, param);
    Copy(proto_perl->IDBcontrol, PL_DBcontrol, DBVARMG_COUNT, IV);

    /* symbol tables */
    PL_defstash		= hv_dup_inc(proto_perl->Idefstash, param);
    PL_curstash		= hv_dup_inc(proto_perl->Icurstash, param);
    PL_debstash		= hv_dup(proto_perl->Idebstash, param);
    PL_globalstash	= hv_dup(proto_perl->Iglobalstash, param);
    PL_curstname	= sv_dup_inc(proto_perl->Icurstname, param);

    PL_beginav		= av_dup_inc(proto_perl->Ibeginav, param);
    PL_beginav_save	= av_dup_inc(proto_perl->Ibeginav_save, param);
    PL_checkav_save	= av_dup_inc(proto_perl->Icheckav_save, param);
    PL_unitcheckav      = av_dup_inc(proto_perl->Iunitcheckav, param);
    PL_unitcheckav_save = av_dup_inc(proto_perl->Iunitcheckav_save, param);
    PL_endav		= av_dup_inc(proto_perl->Iendav, param);
    PL_checkav		= av_dup_inc(proto_perl->Icheckav, param);
    PL_initav		= av_dup_inc(proto_perl->Iinitav, param);
    PL_savebegin	= proto_perl->Isavebegin;

    PL_isarev		= hv_dup_inc(proto_perl->Iisarev, param);

    /* subprocess state */
    PL_fdpid		= av_dup_inc(proto_perl->Ifdpid, param);

    if (proto_perl->Iop_mask)
	PL_op_mask	= SAVEPVN(proto_perl->Iop_mask, PL_maxo);
    else
	PL_op_mask 	= NULL;
    /* PL_asserting        = proto_perl->Iasserting; */

    /* current interpreter roots */
    PL_main_cv		= cv_dup_inc(proto_perl->Imain_cv, param);
    OP_REFCNT_LOCK;
    PL_main_root	= OpREFCNT_inc(proto_perl->Imain_root);
    OP_REFCNT_UNLOCK;

    /* runtime control stuff */
    PL_curcopdb		= (COP*)any_dup(proto_perl->Icurcopdb, proto_perl);

    PL_preambleav	= av_dup_inc(proto_perl->Ipreambleav, param);

    PL_ors_sv		= sv_dup_inc(proto_perl->Iors_sv, param);

    /* interpreter atexit processing */
    PL_exitlistlen	= proto_perl->Iexitlistlen;
    if (PL_exitlistlen) {
	Newx(PL_exitlist, PL_exitlistlen, PerlExitListEntry);
	Copy(proto_perl->Iexitlist, PL_exitlist, PL_exitlistlen, PerlExitListEntry);
    }
    else
	PL_exitlist	= (PerlExitListEntry*)NULL;

    PL_my_cxt_size = proto_perl->Imy_cxt_size;
    if (PL_my_cxt_size) {
	Newx(PL_my_cxt_list, PL_my_cxt_size, void *);
	Copy(proto_perl->Imy_cxt_list, PL_my_cxt_list, PL_my_cxt_size, void *);
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
	Newx(PL_my_cxt_keys, PL_my_cxt_size, const char *);
	Copy(proto_perl->Imy_cxt_keys, PL_my_cxt_keys, PL_my_cxt_size, char *);
#endif
    }
    else {
	PL_my_cxt_list	= (void**)NULL;
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
	PL_my_cxt_keys	= (const char**)NULL;
#endif
    }
    PL_modglobal	= hv_dup_inc(proto_perl->Imodglobal, param);
    PL_custom_op_names  = hv_dup_inc(proto_perl->Icustom_op_names,param);
    PL_custom_op_descs  = hv_dup_inc(proto_perl->Icustom_op_descs,param);
    PL_custom_ops	= hv_dup_inc(proto_perl->Icustom_ops, param);

    PL_compcv			= cv_dup(proto_perl->Icompcv, param);

    PAD_CLONE_VARS(proto_perl, param);

#ifdef HAVE_INTERP_INTERN
    sys_intern_dup(&proto_perl->Isys_intern, &PL_sys_intern);
#endif

    PL_DBcv		= cv_dup(proto_perl->IDBcv, param);

#ifdef PERL_USES_PL_PIDSTATUS
    PL_pidstatus	= newHV();			/* XXX flag for cloning? */
#endif
    PL_osname		= SAVEPV(proto_perl->Iosname);
    PL_parser		= parser_dup(proto_perl->Iparser, param);

    /* XXX this only works if the saved cop has already been cloned */
    if (proto_perl->Iparser) {
	PL_parser->saved_curcop = (COP*)any_dup(
				    proto_perl->Iparser->saved_curcop,
				    proto_perl);
    }

    PL_subname		= sv_dup_inc(proto_perl->Isubname, param);

#ifdef USE_LOCALE_CTYPE
    /* Should we warn if uses locale? */
    PL_warn_locale      = sv_dup_inc(proto_perl->Iwarn_locale, param);
#endif

#ifdef USE_LOCALE_COLLATE
    PL_collation_name	= SAVEPV(proto_perl->Icollation_name);
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    PL_numeric_name	= SAVEPV(proto_perl->Inumeric_name);
    PL_numeric_radix_sv	= sv_dup_inc(proto_perl->Inumeric_radix_sv, param);
#endif /* !USE_LOCALE_NUMERIC */

    /* Unicode inversion lists */
    PL_Latin1		= sv_dup_inc(proto_perl->ILatin1, param);
    PL_UpperLatin1	= sv_dup_inc(proto_perl->IUpperLatin1, param);
    PL_AboveLatin1	= sv_dup_inc(proto_perl->IAboveLatin1, param);
    PL_InBitmap         = sv_dup_inc(proto_perl->IInBitmap, param);

    PL_NonL1NonFinalFold = sv_dup_inc(proto_perl->INonL1NonFinalFold, param);
    PL_HasMultiCharFold = sv_dup_inc(proto_perl->IHasMultiCharFold, param);

    /* utf8 character class swashes */
    for (i = 0; i < POSIX_SWASH_COUNT; i++) {
        PL_utf8_swash_ptrs[i] = sv_dup_inc(proto_perl->Iutf8_swash_ptrs[i], param);
    }
    for (i = 0; i < POSIX_CC_COUNT; i++) {
        PL_XPosix_ptrs[i] = sv_dup_inc(proto_perl->IXPosix_ptrs[i], param);
    }
    PL_GCB_invlist = sv_dup_inc(proto_perl->IGCB_invlist, param);
    PL_SB_invlist = sv_dup_inc(proto_perl->ISB_invlist, param);
    PL_WB_invlist = sv_dup_inc(proto_perl->IWB_invlist, param);
    PL_utf8_mark	= sv_dup_inc(proto_perl->Iutf8_mark, param);
    PL_utf8_toupper	= sv_dup_inc(proto_perl->Iutf8_toupper, param);
    PL_utf8_totitle	= sv_dup_inc(proto_perl->Iutf8_totitle, param);
    PL_utf8_tolower	= sv_dup_inc(proto_perl->Iutf8_tolower, param);
    PL_utf8_tofold	= sv_dup_inc(proto_perl->Iutf8_tofold, param);
    PL_utf8_idstart	= sv_dup_inc(proto_perl->Iutf8_idstart, param);
    PL_utf8_xidstart	= sv_dup_inc(proto_perl->Iutf8_xidstart, param);
    PL_utf8_perl_idstart = sv_dup_inc(proto_perl->Iutf8_perl_idstart, param);
    PL_utf8_perl_idcont = sv_dup_inc(proto_perl->Iutf8_perl_idcont, param);
    PL_utf8_idcont	= sv_dup_inc(proto_perl->Iutf8_idcont, param);
    PL_utf8_xidcont	= sv_dup_inc(proto_perl->Iutf8_xidcont, param);
    PL_utf8_foldable	= sv_dup_inc(proto_perl->Iutf8_foldable, param);
    PL_utf8_charname_begin = sv_dup_inc(proto_perl->Iutf8_charname_begin, param);
    PL_utf8_charname_continue = sv_dup_inc(proto_perl->Iutf8_charname_continue, param);

    if (proto_perl->Ipsig_pend) {
	Newxz(PL_psig_pend, SIG_SIZE, int);
    }
    else {
	PL_psig_pend	= (int*)NULL;
    }

    if (proto_perl->Ipsig_name) {
	Newx(PL_psig_name, 2 * SIG_SIZE, SV*);
	sv_dup_inc_multiple(proto_perl->Ipsig_name, PL_psig_name, 2 * SIG_SIZE,
			    param);
	PL_psig_ptr = PL_psig_name + SIG_SIZE;
    }
    else {
	PL_psig_ptr	= (SV**)NULL;
	PL_psig_name	= (SV**)NULL;
    }

    if (flags & CLONEf_COPY_STACKS) {
	Newx(PL_tmps_stack, PL_tmps_max, SV*);
	sv_dup_inc_multiple(proto_perl->Itmps_stack, PL_tmps_stack,
			    PL_tmps_ix+1, param);

	/* next PUSHMARK() sets *(PL_markstack_ptr+1) */
	i = proto_perl->Imarkstack_max - proto_perl->Imarkstack;
	Newxz(PL_markstack, i, I32);
	PL_markstack_max	= PL_markstack + (proto_perl->Imarkstack_max
						  - proto_perl->Imarkstack);
	PL_markstack_ptr	= PL_markstack + (proto_perl->Imarkstack_ptr
						  - proto_perl->Imarkstack);
	Copy(proto_perl->Imarkstack, PL_markstack,
	     PL_markstack_ptr - PL_markstack + 1, I32);

	/* next push_scope()/ENTER sets PL_scopestack[PL_scopestack_ix]
	 * NOTE: unlike the others! */
	Newxz(PL_scopestack, PL_scopestack_max, I32);
	Copy(proto_perl->Iscopestack, PL_scopestack, PL_scopestack_ix, I32);

#ifdef DEBUGGING
	Newxz(PL_scopestack_name, PL_scopestack_max, const char *);
	Copy(proto_perl->Iscopestack_name, PL_scopestack_name, PL_scopestack_ix, const char *);
#endif
        /* reset stack AV to correct length before its duped via
         * PL_curstackinfo */
        AvFILLp(proto_perl->Icurstack) =
                            proto_perl->Istack_sp - proto_perl->Istack_base;

	/* NOTE: si_dup() looks at PL_markstack */
	PL_curstackinfo		= si_dup(proto_perl->Icurstackinfo, param);

	/* PL_curstack		= PL_curstackinfo->si_stack; */
	PL_curstack		= av_dup(proto_perl->Icurstack, param);
	PL_mainstack		= av_dup(proto_perl->Imainstack, param);

	/* next PUSHs() etc. set *(PL_stack_sp+1) */
	PL_stack_base		= AvARRAY(PL_curstack);
	PL_stack_sp		= PL_stack_base + (proto_perl->Istack_sp
						   - proto_perl->Istack_base);
	PL_stack_max		= PL_stack_base + AvMAX(PL_curstack);

	/*Newxz(PL_savestack, PL_savestack_max, ANY);*/
	PL_savestack		= ss_dup(proto_perl, param);
    }
    else {
	init_stacks();
	ENTER;			/* perl_destruct() wants to LEAVE; */
    }

    PL_statgv		= gv_dup(proto_perl->Istatgv, param);
    PL_statname		= sv_dup_inc(proto_perl->Istatname, param);

    PL_rs		= sv_dup_inc(proto_perl->Irs, param);
    PL_last_in_gv	= gv_dup(proto_perl->Ilast_in_gv, param);
    PL_defoutgv		= gv_dup_inc(proto_perl->Idefoutgv, param);
    PL_toptarget	= sv_dup_inc(proto_perl->Itoptarget, param);
    PL_bodytarget	= sv_dup_inc(proto_perl->Ibodytarget, param);
    PL_formtarget	= sv_dup(proto_perl->Iformtarget, param);

    PL_errors		= sv_dup_inc(proto_perl->Ierrors, param);

    PL_sortcop		= (OP*)any_dup(proto_perl->Isortcop, proto_perl);
    PL_firstgv		= gv_dup_inc(proto_perl->Ifirstgv, param);
    PL_secondgv		= gv_dup_inc(proto_perl->Isecondgv, param);

    PL_stashcache       = newHV();

    PL_watchaddr	= (char **) ptr_table_fetch(PL_ptr_table,
					    proto_perl->Iwatchaddr);
    PL_watchok		= PL_watchaddr ? * PL_watchaddr : NULL;
    if (PL_debug && PL_watchaddr) {
	PerlIO_printf(Perl_debug_log,
	  "WATCHING: %"UVxf" cloned as %"UVxf" with value %"UVxf"\n",
	  PTR2UV(proto_perl->Iwatchaddr), PTR2UV(PL_watchaddr),
	  PTR2UV(PL_watchok));
    }

    PL_registered_mros  = hv_dup_inc(proto_perl->Iregistered_mros, param);
    PL_blockhooks	= av_dup_inc(proto_perl->Iblockhooks, param);
    PL_utf8_foldclosures = hv_dup_inc(proto_perl->Iutf8_foldclosures, param);

    /* Call the ->CLONE method, if it exists, for each of the stashes
       identified by sv_dup() above.
    */
    while(av_tindex(param->stashes) != -1) {
	HV* const stash = MUTABLE_HV(av_shift(param->stashes));
	GV* const cloner = gv_fetchmethod_autoload(stash, "CLONE", 0);
	if (cloner && GvCV(cloner)) {
	    dSP;
	    ENTER;
	    SAVETMPS;
	    PUSHMARK(SP);
	    mXPUSHs(newSVhek(HvNAME_HEK(stash)));
	    PUTBACK;
	    call_sv(MUTABLE_SV(GvCV(cloner)), G_DISCARD);
	    FREETMPS;
	    LEAVE;
	}
    }

    if (!(flags & CLONEf_KEEP_PTR_TABLE)) {
        ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;
    }

    if (!(flags & CLONEf_COPY_STACKS)) {
	unreferenced_to_tmp_stack(param->unreferenced);
    }

    SvREFCNT_dec(param->stashes);

    /* orphaned? eg threads->new inside BEGIN or use */
    if (PL_compcv && ! SvREFCNT(PL_compcv)) {
	SvREFCNT_inc_simple_void(PL_compcv);
	SAVEFREESV(PL_compcv);
    }

    return my_perl;
}

static void
S_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced)
{
    PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK;
    
    if (AvFILLp(unreferenced) > -1) {
	SV **svp = AvARRAY(unreferenced);
	SV **const last = svp + AvFILLp(unreferenced);
	SSize_t count = 0;

	do {
	    if (SvREFCNT(*svp) == 1)
		++count;
	} while (++svp <= last);

	EXTEND_MORTAL(count);
	svp = AvARRAY(unreferenced);

	do {
	    if (SvREFCNT(*svp) == 1) {
		/* Our reference is the only one to this SV. This means that
		   in this thread, the scalar effectively has a 0 reference.
		   That doesn't work (cleanup never happens), so donate our
		   reference to it onto the save stack. */
		PL_tmps_stack[++PL_tmps_ix] = *svp;
	    } else {
		/* As an optimisation, because we are already walking the
		   entire array, instead of above doing either
		   SvREFCNT_inc(*svp) or *svp = &PL_sv_undef, we can instead
		   release our reference to the scalar, so that at the end of
		   the array owns zero references to the scalars it happens to
		   point to. We are effectively converting the array from
		   AvREAL() on to AvREAL() off. This saves the av_clear()
		   (triggered by the SvREFCNT_dec(unreferenced) below) from
		   walking the array a second time.  */
		SvREFCNT_dec(*svp);
	    }

	} while (++svp <= last);
	AvREAL_off(unreferenced);
    }
    SvREFCNT_dec_NN(unreferenced);
}

void
Perl_clone_params_del(CLONE_PARAMS *param)
{
    /* This seemingly funky ordering keeps the build with PERL_GLOBAL_STRUCT
       happy: */
    PerlInterpreter *const to = param->new_perl;
    dTHXa(to);
    PerlInterpreter *const was = PERL_GET_THX;

    PERL_ARGS_ASSERT_CLONE_PARAMS_DEL;

    if (was != to) {
	PERL_SET_THX(to);
    }

    SvREFCNT_dec(param->stashes);
    if (param->unreferenced)
	unreferenced_to_tmp_stack(param->unreferenced);

    Safefree(param);

    if (was != to) {
	PERL_SET_THX(was);
    }
}

CLONE_PARAMS *
Perl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)
{
    dVAR;
    /* Need to play this game, as newAV() can call safesysmalloc(), and that
       does a dTHX; to get the context from thread local storage.
       FIXME - under PERL_CORE Newx(), Safefree() and friends should expand to
       a version that passes in my_perl.  */
    PerlInterpreter *const was = PERL_GET_THX;
    CLONE_PARAMS *param;

    PERL_ARGS_ASSERT_CLONE_PARAMS_NEW;

    if (was != to) {
	PERL_SET_THX(to);
    }

    /* Given that we've set the context, we can do this unshared.  */
    Newx(param, 1, CLONE_PARAMS);

    param->flags = 0;
    param->proto_perl = from;
    param->new_perl = to;
    param->stashes = (AV *)Perl_newSV_type(to, SVt_PVAV);
    AvREAL_off(param->stashes);
    param->unreferenced = (AV *)Perl_newSV_type(to, SVt_PVAV);

    if (was != to) {
	PERL_SET_THX(was);
    }
    return param;
}

#endif /* USE_ITHREADS */

void
Perl_init_constants(pTHX)
{
    SvREFCNT(&PL_sv_undef)	= SvREFCNT_IMMORTAL;
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVf_PROTECT|SVt_NULL;
    SvANY(&PL_sv_undef)		= NULL;

    SvANY(&PL_sv_no)		= new_XPVNV();
    SvREFCNT(&PL_sv_no)		= SvREFCNT_IMMORTAL;
    SvFLAGS(&PL_sv_no)		= SVt_PVNV|SVf_READONLY|SVf_PROTECT
				  |SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK;

    SvANY(&PL_sv_yes)		= new_XPVNV();
    SvREFCNT(&PL_sv_yes)	= SvREFCNT_IMMORTAL;
    SvFLAGS(&PL_sv_yes)		= SVt_PVNV|SVf_READONLY|SVf_PROTECT
				  |SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK;

    SvPV_set(&PL_sv_no, (char*)PL_No);
    SvCUR_set(&PL_sv_no, 0);
    SvLEN_set(&PL_sv_no, 0);
    SvIV_set(&PL_sv_no, 0);
    SvNV_set(&PL_sv_no, 0);

    SvPV_set(&PL_sv_yes, (char*)PL_Yes);
    SvCUR_set(&PL_sv_yes, 1);
    SvLEN_set(&PL_sv_yes, 0);
    SvIV_set(&PL_sv_yes, 1);
    SvNV_set(&PL_sv_yes, 1);

    PadnamePV(&PL_padname_const) = (char *)PL_No;
}

/*
=head1 Unicode Support

=for apidoc sv_recode_to_utf8

C<encoding> is assumed to be an C<Encode> object, on entry the PV
of C<sv> is assumed to be octets in that encoding, and C<sv>
will be converted into Unicode (and UTF-8).

If C<sv> already is UTF-8 (or if it is not C<POK>), or if C<encoding>
is not a reference, nothing is done to C<sv>.  If C<encoding> is not
an C<Encode::XS> Encoding object, bad things will happen.
(See F<cpan/Encode/encoding.pm> and L<Encode>.)

The PV of C<sv> is returned.

=cut */

char *
Perl_sv_recode_to_utf8(pTHX_ SV *sv, SV *encoding)
{
    PERL_ARGS_ASSERT_SV_RECODE_TO_UTF8;

    if (SvPOK(sv) && !SvUTF8(sv) && !IN_BYTES && SvROK(encoding)) {
	SV *uni;
	STRLEN len;
	const char *s;
	dSP;
	SV *nsv = sv;
	ENTER;
	PUSHSTACK;
	SAVETMPS;
	if (SvPADTMP(nsv)) {
	    nsv = sv_newmortal();
	    SvSetSV_nosteal(nsv, sv);
	}
	save_re_context();
	PUSHMARK(sp);
	EXTEND(SP, 3);
	PUSHs(encoding);
	PUSHs(nsv);
/*
  NI-S 2002/07/09
  Passing sv_yes is wrong - it needs to be or'ed set of constants
  for Encode::XS, while UTf-8 decode (currently) assumes a true value means
  remove converted chars from source.

  Both will default the value - let them.

	XPUSHs(&PL_sv_yes);
*/
	PUTBACK;
	call_method("decode", G_SCALAR);
	SPAGAIN;
	uni = POPs;
	PUTBACK;
	s = SvPV_const(uni, len);
	if (s != SvPVX_const(sv)) {
	    SvGROW(sv, len + 1);
	    Move(s, SvPVX(sv), len + 1, char);
	    SvCUR_set(sv, len);
	}
	FREETMPS;
	POPSTACK;
	LEAVE;
	if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	    /* clear pos and any utf8 cache */
	    MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
	    if (mg)
		mg->mg_len = -1;
	    if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		magic_setutf8(sv,mg); /* clear UTF8 cache */
	}
	SvUTF8_on(sv);
	return SvPVX(sv);
    }
    return SvPOKp(sv) ? SvPVX(sv) : NULL;
}

/*
=for apidoc sv_cat_decode

C<encoding> is assumed to be an C<Encode> object, the PV of C<ssv> is
assumed to be octets in that encoding and decoding the input starts
from the position which S<C<(PV + *offset)>> pointed to.  C<dsv> will be
concatenated with the decoded UTF-8 string from C<ssv>.  Decoding will terminate
when the string C<tstr> appears in decoding output or the input ends on
the PV of C<ssv>.  The value which C<offset> points will be modified
to the last input position on C<ssv>.

Returns TRUE if the terminator was found, else returns FALSE.

=cut */

bool
Perl_sv_cat_decode(pTHX_ SV *dsv, SV *encoding,
		   SV *ssv, int *offset, char *tstr, int tlen)
{
    bool ret = FALSE;

    PERL_ARGS_ASSERT_SV_CAT_DECODE;

    if (SvPOK(ssv) && SvPOK(dsv) && SvROK(encoding)) {
	SV *offsv;
	dSP;
	ENTER;
	SAVETMPS;
	save_re_context();
	PUSHMARK(sp);
	EXTEND(SP, 6);
	PUSHs(encoding);
	PUSHs(dsv);
	PUSHs(ssv);
	offsv = newSViv(*offset);
	mPUSHs(offsv);
	mPUSHp(tstr, tlen);
	PUTBACK;
	call_method("cat_decode", G_SCALAR);
	SPAGAIN;
	ret = SvTRUE(TOPs);
	*offset = SvIV(offsv);
	PUTBACK;
	FREETMPS;
	LEAVE;
    }
    else
        Perl_croak(aTHX_ "Invalid argument to sv_cat_decode");
    return ret;

}

/* ---------------------------------------------------------------------
 *
 * support functions for report_uninit()
 */

/* the maxiumum size of array or hash where we will scan looking
 * for the undefined element that triggered the warning */

#define FUV_MAX_SEARCH_SIZE 1000

/* Look for an entry in the hash whose value has the same SV as val;
 * If so, return a mortal copy of the key. */

STATIC SV*
S_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val)
{
    dVAR;
    HE **array;
    I32 i;

    PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT;

    if (!hv || SvMAGICAL(hv) || !HvARRAY(hv) ||
			(HvTOTALKEYS(hv) > FUV_MAX_SEARCH_SIZE))
	return NULL;

    array = HvARRAY(hv);

    for (i=HvMAX(hv); i>=0; i--) {
	HE *entry;
	for (entry = array[i]; entry; entry = HeNEXT(entry)) {
	    if (HeVAL(entry) != val)
		continue;
	    if (    HeVAL(entry) == &PL_sv_undef ||
		    HeVAL(entry) == &PL_sv_placeholder)
		continue;
	    if (!HeKEY(entry))
		return NULL;
	    if (HeKLEN(entry) == HEf_SVKEY)
		return sv_mortalcopy(HeKEY_sv(entry));
	    return sv_2mortal(newSVhek(HeKEY_hek(entry)));
	}
    }
    return NULL;
}

/* Look for an entry in the array whose value has the same SV as val;
 * If so, return the index, otherwise return -1. */

STATIC I32
S_find_array_subscript(pTHX_ const AV *const av, const SV *const val)
{
    PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT;

    if (!av || SvMAGICAL(av) || !AvARRAY(av) ||
			(AvFILLp(av) > FUV_MAX_SEARCH_SIZE))
	return -1;

    if (val != &PL_sv_undef) {
	SV ** const svp = AvARRAY(av);
	I32 i;

	for (i=AvFILLp(av); i>=0; i--)
	    if (svp[i] == val)
		return i;
    }
    return -1;
}

/* varname(): return the name of a variable, optionally with a subscript.
 * If gv is non-zero, use the name of that global, along with gvtype (one
 * of "$", "@@", "%"); otherwise use the name of the lexical at pad offset
 * targ.  Depending on the value of the subscript_type flag, return:
 */

#define FUV_SUBSCRIPT_NONE	1	/* "@@foo"          */
#define FUV_SUBSCRIPT_ARRAY	2	/* "$foo[aindex]"  */
#define FUV_SUBSCRIPT_HASH	3	/* "$foo{keyname}" */
#define FUV_SUBSCRIPT_WITHIN	4	/* "within @@foo"   */

SV*
Perl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ,
	const SV *const keyname, I32 aindex, int subscript_type)
{

    SV * const name = sv_newmortal();
    if (gv && isGV(gv)) {
	char buffer[2];
	buffer[0] = gvtype;
	buffer[1] = 0;

	/* as gv_fullname4(), but add literal '^' for $^FOO names  */

	gv_fullname4(name, gv, buffer, 0);

	if ((unsigned int)SvPVX(name)[1] <= 26) {
	    buffer[0] = '^';
	    buffer[1] = SvPVX(name)[1] + 'A' - 1;

	    /* Swap the 1 unprintable control character for the 2 byte pretty
	       version - ie substr($name, 1, 1) = $buffer; */
	    sv_insert(name, 1, 1, buffer, 2);
	}
    }
    else {
	CV * const cv = gv ? ((CV *)gv) : find_runcv(NULL);
	PADNAME *sv;

	assert(!cv || SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM);

	if (!cv || !CvPADLIST(cv))
	    return NULL;
	sv = padnamelist_fetch(PadlistNAMES(CvPADLIST(cv)), targ);
	sv_setpvn(name, PadnamePV(sv), PadnameLEN(sv));
	SvUTF8_on(name);
    }

    if (subscript_type == FUV_SUBSCRIPT_HASH) {
	SV * const sv = newSV(0);
	*SvPVX(name) = '$';
	Perl_sv_catpvf(aTHX_ name, "{%s}",
	    pv_pretty(sv, SvPVX_const(keyname), SvCUR(keyname), 32, NULL, NULL,
		    PERL_PV_PRETTY_DUMP | PERL_PV_ESCAPE_UNI_DETECT ));
	SvREFCNT_dec_NN(sv);
    }
    else if (subscript_type == FUV_SUBSCRIPT_ARRAY) {
	*SvPVX(name) = '$';
	Perl_sv_catpvf(aTHX_ name, "[%"IVdf"]", (IV)aindex);
    }
    else if (subscript_type == FUV_SUBSCRIPT_WITHIN) {
	/* We know that name has no magic, so can use 0 instead of SV_GMAGIC */
	Perl_sv_insert_flags(aTHX_ name, 0, 0,  STR_WITH_LEN("within "), 0);
    }

    return name;
}


/*
=for apidoc find_uninit_var

Find the name of the undefined variable (if any) that caused the operator
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if its value matches C<uninit_sv>.
So roughly speaking, if a unary operator (such as C<OP_COS>) generates a
warning, then following the direct child of the op may yield an
C<OP_PADSV> or C<OP_GV> that gives the name of the undefined variable.  On the
other hand, with C<OP_ADD> there are two branches to follow, so we only print
the variable name if we get an exact match.
C<desc_p> points to a string pointer holding the description of the op.
This may be updated if needed.

The name is returned as a mortal SV.

Assumes that C<PL_op> is the OP that originally triggered the error, and that
C<PL_comppad>/C<PL_curpad> points to the currently executing pad.

=cut
*/

STATIC SV *
S_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv,
		  bool match, const char **desc_p)
{
    dVAR;
    SV *sv;
    const GV *gv;
    const OP *o, *o2, *kid;

    PERL_ARGS_ASSERT_FIND_UNINIT_VAR;

    if (!obase || (match && (!uninit_sv || uninit_sv == &PL_sv_undef ||
			    uninit_sv == &PL_sv_placeholder)))
	return NULL;

    switch (obase->op_type) {

    case OP_RV2AV:
    case OP_RV2HV:
    case OP_PADAV:
    case OP_PADHV:
      {
	const bool pad  = (    obase->op_type == OP_PADAV
                            || obase->op_type == OP_PADHV
                            || obase->op_type == OP_PADRANGE
                          );

	const bool hash = (    obase->op_type == OP_PADHV
                            || obase->op_type == OP_RV2HV
                            || (obase->op_type == OP_PADRANGE
                                && SvTYPE(PAD_SVl(obase->op_targ)) == SVt_PVHV)
                          );
	I32 index = 0;
	SV *keysv = NULL;
	int subscript_type = FUV_SUBSCRIPT_WITHIN;

	if (pad) { /* @@lex, %lex */
	    sv = PAD_SVl(obase->op_targ);
	    gv = NULL;
	}
	else {
	    if (cUNOPx(obase)->op_first->op_type == OP_GV) {
	    /* @@global, %global */
		gv = cGVOPx_gv(cUNOPx(obase)->op_first);
		if (!gv)
		    break;
		sv = hash ? MUTABLE_SV(GvHV(gv)): MUTABLE_SV(GvAV(gv));
	    }
	    else if (obase == PL_op) /* @@{expr}, %{expr} */
		return find_uninit_var(cUNOPx(obase)->op_first,
                                                uninit_sv, match, desc_p);
	    else /* @@{expr}, %{expr} as a sub-expression */
		return NULL;
	}

	/* attempt to find a match within the aggregate */
	if (hash) {
	    keysv = find_hash_subscript((const HV*)sv, uninit_sv);
	    if (keysv)
		subscript_type = FUV_SUBSCRIPT_HASH;
	}
	else {
	    index = find_array_subscript((const AV *)sv, uninit_sv);
	    if (index >= 0)
		subscript_type = FUV_SUBSCRIPT_ARRAY;
	}

	if (match && subscript_type == FUV_SUBSCRIPT_WITHIN)
	    break;

	return varname(gv, (char)(hash ? '%' : '@@'), obase->op_targ,
				    keysv, index, subscript_type);
      }

    case OP_RV2SV:
	if (cUNOPx(obase)->op_first->op_type == OP_GV) {
	    /* $global */
	    gv = cGVOPx_gv(cUNOPx(obase)->op_first);
	    if (!gv || !GvSTASH(gv))
		break;
	    if (match && (GvSV(gv) != uninit_sv))
		break;
	    return varname(gv, '$', 0, NULL, 0, FUV_SUBSCRIPT_NONE);
	}
	/* ${expr} */
	return find_uninit_var(cUNOPx(obase)->op_first, uninit_sv, 1, desc_p);

    case OP_PADSV:
	if (match && PAD_SVl(obase->op_targ) != uninit_sv)
	    break;
	return varname(NULL, '$', obase->op_targ,
				    NULL, 0, FUV_SUBSCRIPT_NONE);

    case OP_GVSV:
	gv = cGVOPx_gv(obase);
	if (!gv || (match && GvSV(gv) != uninit_sv) || !GvSTASH(gv))
	    break;
	return varname(gv, '$', 0, NULL, 0, FUV_SUBSCRIPT_NONE);

    case OP_AELEMFAST_LEX:
	if (match) {
	    SV **svp;
	    AV *av = MUTABLE_AV(PAD_SV(obase->op_targ));
	    if (!av || SvRMAGICAL(av))
		break;
	    svp = av_fetch(av, (I8)obase->op_private, FALSE);
	    if (!svp || *svp != uninit_sv)
		break;
	}
	return varname(NULL, '$', obase->op_targ,
		       NULL, (I8)obase->op_private, FUV_SUBSCRIPT_ARRAY);
    case OP_AELEMFAST:
	{
	    gv = cGVOPx_gv(obase);
	    if (!gv)
		break;
	    if (match) {
		SV **svp;
		AV *const av = GvAV(gv);
		if (!av || SvRMAGICAL(av))
		    break;
		svp = av_fetch(av, (I8)obase->op_private, FALSE);
		if (!svp || *svp != uninit_sv)
		    break;
	    }
	    return varname(gv, '$', 0,
		    NULL, (I8)obase->op_private, FUV_SUBSCRIPT_ARRAY);
	}
	NOT_REACHED; /* NOTREACHED */

    case OP_EXISTS:
	o = cUNOPx(obase)->op_first;
	if (!o || o->op_type != OP_NULL ||
		! (o->op_targ == OP_AELEM || o->op_targ == OP_HELEM))
	    break;
	return find_uninit_var(cBINOPo->op_last, uninit_sv, match, desc_p);

    case OP_AELEM:
    case OP_HELEM:
    {
	bool negate = FALSE;

	if (PL_op == obase)
	    /* $a[uninit_expr] or $h{uninit_expr} */
	    return find_uninit_var(cBINOPx(obase)->op_last,
                                                uninit_sv, match, desc_p);

	gv = NULL;
	o = cBINOPx(obase)->op_first;
	kid = cBINOPx(obase)->op_last;

	/* get the av or hv, and optionally the gv */
	sv = NULL;
	if  (o->op_type == OP_PADAV || o->op_type == OP_PADHV) {
	    sv = PAD_SV(o->op_targ);
	}
	else if ((o->op_type == OP_RV2AV || o->op_type == OP_RV2HV)
		&& cUNOPo->op_first->op_type == OP_GV)
	{
	    gv = cGVOPx_gv(cUNOPo->op_first);
	    if (!gv)
		break;
	    sv = o->op_type
		== OP_RV2HV ? MUTABLE_SV(GvHV(gv)) : MUTABLE_SV(GvAV(gv));
	}
	if (!sv)
	    break;

	if (kid && kid->op_type == OP_NEGATE) {
	    negate = TRUE;
	    kid = cUNOPx(kid)->op_first;
	}

	if (kid && kid->op_type == OP_CONST && SvOK(cSVOPx_sv(kid))) {
	    /* index is constant */
	    SV* kidsv;
	    if (negate) {
		kidsv = newSVpvs_flags("-", SVs_TEMP);
		sv_catsv(kidsv, cSVOPx_sv(kid));
	    }
	    else
		kidsv = cSVOPx_sv(kid);
	    if (match) {
		if (SvMAGICAL(sv))
		    break;
		if (obase->op_type == OP_HELEM) {
		    HE* he = hv_fetch_ent(MUTABLE_HV(sv), kidsv, 0, 0);
		    if (!he || HeVAL(he) != uninit_sv)
			break;
		}
		else {
		    SV * const  opsv = cSVOPx_sv(kid);
		    const IV  opsviv = SvIV(opsv);
		    SV * const * const svp = av_fetch(MUTABLE_AV(sv),
			negate ? - opsviv : opsviv,
			FALSE);
		    if (!svp || *svp != uninit_sv)
			break;
		}
	    }
	    if (obase->op_type == OP_HELEM)
		return varname(gv, '%', o->op_targ,
			    kidsv, 0, FUV_SUBSCRIPT_HASH);
	    else
		return varname(gv, '@@', o->op_targ, NULL,
		    negate ? - SvIV(cSVOPx_sv(kid)) : SvIV(cSVOPx_sv(kid)),
		    FUV_SUBSCRIPT_ARRAY);
	}
	else  {
	    /* index is an expression;
	     * attempt to find a match within the aggregate */
	    if (obase->op_type == OP_HELEM) {
		SV * const keysv = find_hash_subscript((const HV*)sv, uninit_sv);
		if (keysv)
		    return varname(gv, '%', o->op_targ,
						keysv, 0, FUV_SUBSCRIPT_HASH);
	    }
	    else {
		const I32 index
		    = find_array_subscript((const AV *)sv, uninit_sv);
		if (index >= 0)
		    return varname(gv, '@@', o->op_targ,
					NULL, index, FUV_SUBSCRIPT_ARRAY);
	    }
	    if (match)
		break;
	    return varname(gv,
		(char)((o->op_type == OP_PADAV || o->op_type == OP_RV2AV)
		? '@@' : '%'),
		o->op_targ, NULL, 0, FUV_SUBSCRIPT_WITHIN);
	}
	NOT_REACHED; /* NOTREACHED */
    }

    case OP_MULTIDEREF: {
        /* If we were executing OP_MULTIDEREF when the undef warning
         * triggered, then it must be one of the index values within
         * that triggered it. If not, then the only possibility is that
         * the value retrieved by the last aggregate lookup might be the
         * culprit. For the former, we set PL_multideref_pc each time before
         * using an index, so work though the item list until we reach
         * that point. For the latter, just work through the entire item
         * list; the last aggregate retrieved will be the candidate.
         */

        /* the named aggregate, if any */
        PADOFFSET agg_targ = 0;
        GV       *agg_gv   = NULL;
        /* the last-seen index */
        UV        index_type;
        PADOFFSET index_targ;
        GV       *index_gv;
        IV        index_const_iv = 0; /* init for spurious compiler warn */
        SV       *index_const_sv;
        int       depth = 0;  /* how many array/hash lookups we've done */

        UNOP_AUX_item *items = cUNOP_AUXx(obase)->op_aux;
        UNOP_AUX_item *last = NULL;
        UV actions = items->uv;
        bool is_hv;

        if (PL_op == obase) {
            last = PL_multideref_pc;
            assert(last >= items && last <= items + items[-1].uv);
        }

        assert(actions);

        while (1) {
            is_hv = FALSE;
            switch (actions & MDEREF_ACTION_MASK) {

            case MDEREF_reload:
                actions = (++items)->uv;
                continue;

            case MDEREF_HV_padhv_helem:               /* $lex{...} */
                is_hv = TRUE;
                /* FALLTHROUGH */
            case MDEREF_AV_padav_aelem:               /* $lex[...] */
                agg_targ = (++items)->pad_offset;
                agg_gv = NULL;
                break;

            case MDEREF_HV_gvhv_helem:                /* $pkg{...} */
                is_hv = TRUE;
                /* FALLTHROUGH */
            case MDEREF_AV_gvav_aelem:                /* $pkg[...] */
                agg_targ = 0;
                agg_gv = (GV*)UNOP_AUX_item_sv(++items);
                assert(isGV_with_GP(agg_gv));
                break;

            case MDEREF_HV_gvsv_vivify_rv2hv_helem:   /* $pkg->{...} */
            case MDEREF_HV_padsv_vivify_rv2hv_helem:  /* $lex->{...} */
                ++items;
                /* FALLTHROUGH */
            case MDEREF_HV_pop_rv2hv_helem:           /* expr->{...} */
            case MDEREF_HV_vivify_rv2hv_helem:        /* vivify, ->{...} */
                agg_targ = 0;
                agg_gv   = NULL;
                is_hv    = TRUE;
                break;

            case MDEREF_AV_gvsv_vivify_rv2av_aelem:   /* $pkg->[...] */
            case MDEREF_AV_padsv_vivify_rv2av_aelem:  /* $lex->[...] */
                ++items;
                /* FALLTHROUGH */
            case MDEREF_AV_pop_rv2av_aelem:           /* expr->[...] */
            case MDEREF_AV_vivify_rv2av_aelem:        /* vivify, ->[...] */
                agg_targ = 0;
                agg_gv   = NULL;
            } /* switch */

            index_targ     = 0;
            index_gv       = NULL;
            index_const_sv = NULL;

            index_type = (actions & MDEREF_INDEX_MASK);
            switch (index_type) {
            case MDEREF_INDEX_none:
                break;
            case MDEREF_INDEX_const:
                if (is_hv)
                    index_const_sv = UNOP_AUX_item_sv(++items)
                else
                    index_const_iv = (++items)->iv;
                break;
            case MDEREF_INDEX_padsv:
                index_targ = (++items)->pad_offset;
                break;
            case MDEREF_INDEX_gvsv:
                index_gv = (GV*)UNOP_AUX_item_sv(++items);
                assert(isGV_with_GP(index_gv));
                break;
            }

            if (index_type != MDEREF_INDEX_none)
                depth++;

            if (   index_type == MDEREF_INDEX_none
                || (actions & MDEREF_FLAG_last)
                || (last && items == last)
            )
                break;

            actions >>= MDEREF_SHIFT;
        } /* while */

	if (PL_op == obase) {
	    /* index was undef */

            *desc_p = (    (actions & MDEREF_FLAG_last)
                        && (obase->op_private
                                & (OPpMULTIDEREF_EXISTS|OPpMULTIDEREF_DELETE)))
                        ?
                            (obase->op_private & OPpMULTIDEREF_EXISTS)
                                ? "exists"
                                : "delete"
                        : is_hv ? "hash element" : "array element";
            assert(index_type != MDEREF_INDEX_none);
            if (index_gv)
                return varname(index_gv, '$', 0, NULL, 0, FUV_SUBSCRIPT_NONE);
            if (index_targ)
                return varname(NULL, '$', index_targ,
				    NULL, 0, FUV_SUBSCRIPT_NONE);
            assert(is_hv); /* AV index is an IV and can't be undef */
            /* can a const HV index ever be undef? */
            return NULL;
        }

        /* the SV returned by pp_multideref() was undef, if anything was */

        if (depth != 1)
            break;

        if (agg_targ)
	    sv = PAD_SV(agg_targ);
        else if (agg_gv)
            sv = is_hv ? MUTABLE_SV(GvHV(agg_gv)) : MUTABLE_SV(GvAV(agg_gv));
        else
            break;

	if (index_type == MDEREF_INDEX_const) {
	    if (match) {
		if (SvMAGICAL(sv))
		    break;
		if (is_hv) {
		    HE* he = hv_fetch_ent(MUTABLE_HV(sv), index_const_sv, 0, 0);
		    if (!he || HeVAL(he) != uninit_sv)
			break;
		}
		else {
		    SV * const * const svp =
                            av_fetch(MUTABLE_AV(sv), index_const_iv, FALSE);
		    if (!svp || *svp != uninit_sv)
			break;
		}
	    }
	    return is_hv
		? varname(agg_gv, '%', agg_targ,
                                index_const_sv, 0,    FUV_SUBSCRIPT_HASH)
		: varname(agg_gv, '@@', agg_targ,
                                NULL, index_const_iv, FUV_SUBSCRIPT_ARRAY);
	}
	else  {
	    /* index is an var */
	    if (is_hv) {
		SV * const keysv = find_hash_subscript((const HV*)sv, uninit_sv);
		if (keysv)
		    return varname(agg_gv, '%', agg_targ,
						keysv, 0, FUV_SUBSCRIPT_HASH);
	    }
	    else {
		const I32 index
		    = find_array_subscript((const AV *)sv, uninit_sv);
		if (index >= 0)
		    return varname(agg_gv, '@@', agg_targ,
					NULL, index, FUV_SUBSCRIPT_ARRAY);
	    }
	    if (match)
		break;
	    return varname(agg_gv,
		is_hv ? '%' : '@@',
		agg_targ, NULL, 0, FUV_SUBSCRIPT_WITHIN);
	}
	NOT_REACHED; /* NOTREACHED */
    }

    case OP_AASSIGN:
	/* only examine RHS */
	return find_uninit_var(cBINOPx(obase)->op_first, uninit_sv,
                                                                match, desc_p);

    case OP_OPEN:
	o = cUNOPx(obase)->op_first;
	if (   o->op_type == OP_PUSHMARK
	   || (o->op_type == OP_NULL && o->op_targ == OP_PUSHMARK)
        )
            o = OpSIBLING(o);

	if (!OpHAS_SIBLING(o)) {
	    /* one-arg version of open is highly magical */

	    if (o->op_type == OP_GV) { /* open FOO; */
		gv = cGVOPx_gv(o);
		if (match && GvSV(gv) != uninit_sv)
		    break;
		return varname(gv, '$', 0,
			    NULL, 0, FUV_SUBSCRIPT_NONE);
	    }
	    /* other possibilities not handled are:
	     * open $x; or open my $x;	should return '${*$x}'
	     * open expr;		should return '$'.expr ideally
	     */
	     break;
	}
	goto do_op;

    /* ops where $_ may be an implicit arg */
    case OP_TRANS:
    case OP_TRANSR:
    case OP_SUBST:
    case OP_MATCH:
	if ( !(obase->op_flags & OPf_STACKED)) {
	    if (uninit_sv == DEFSV)
		return newSVpvs_flags("$_", SVs_TEMP);
	    else if (obase->op_targ
		  && uninit_sv == PAD_SVl(obase->op_targ))
		return varname(NULL, '$', obase->op_targ, NULL, 0,
			       FUV_SUBSCRIPT_NONE);
	}
	goto do_op;

    case OP_PRTF:
    case OP_PRINT:
    case OP_SAY:
	match = 1; /* print etc can return undef on defined args */
	/* skip filehandle as it can't produce 'undef' warning  */
	o = cUNOPx(obase)->op_first;
	if ((obase->op_flags & OPf_STACKED)
            &&
               (   o->op_type == OP_PUSHMARK
               || (o->op_type == OP_NULL && o->op_targ == OP_PUSHMARK)))
            o = OpSIBLING(OpSIBLING(o));
	goto do_op2;


    case OP_ENTEREVAL: /* could be eval $undef or $x='$undef'; eval $x */
    case OP_CUSTOM: /* XS or custom code could trigger random warnings */

	/* the following ops are capable of returning PL_sv_undef even for
	 * defined arg(s) */

    case OP_BACKTICK:
    case OP_PIPE_OP:
    case OP_FILENO:
    case OP_BINMODE:
    case OP_TIED:
    case OP_GETC:
    case OP_SYSREAD:
    case OP_SEND:
    case OP_IOCTL:
    case OP_SOCKET:
    case OP_SOCKPAIR:
    case OP_BIND:
    case OP_CONNECT:
    case OP_LISTEN:
    case OP_ACCEPT:
    case OP_SHUTDOWN:
    case OP_SSOCKOPT:
    case OP_GETPEERNAME:
    case OP_FTRREAD:
    case OP_FTRWRITE:
    case OP_FTREXEC:
    case OP_FTROWNED:
    case OP_FTEREAD:
    case OP_FTEWRITE:
    case OP_FTEEXEC:
    case OP_FTEOWNED:
    case OP_FTIS:
    case OP_FTZERO:
    case OP_FTSIZE:
    case OP_FTFILE:
    case OP_FTDIR:
    case OP_FTLINK:
    case OP_FTPIPE:
    case OP_FTSOCK:
    case OP_FTBLK:
    case OP_FTCHR:
    case OP_FTTTY:
    case OP_FTSUID:
    case OP_FTSGID:
    case OP_FTSVTX:
    case OP_FTTEXT:
    case OP_FTBINARY:
    case OP_FTMTIME:
    case OP_FTATIME:
    case OP_FTCTIME:
    case OP_READLINK:
    case OP_OPEN_DIR:
    case OP_READDIR:
    case OP_TELLDIR:
    case OP_SEEKDIR:
    case OP_REWINDDIR:
    case OP_CLOSEDIR:
    case OP_GMTIME:
    case OP_ALARM:
    case OP_SEMGET:
    case OP_GETLOGIN:
    case OP_UNDEF:
    case OP_SUBSTR:
    case OP_AEACH:
    case OP_EACH:
    case OP_SORT:
    case OP_CALLER:
    case OP_DOFILE:
    case OP_PROTOTYPE:
    case OP_NCMP:
    case OP_SMARTMATCH:
    case OP_UNPACK:
    case OP_SYSOPEN:
    case OP_SYSSEEK:
	match = 1;
	goto do_op;

    case OP_ENTERSUB:
    case OP_GOTO:
	/* XXX tmp hack: these two may call an XS sub, and currently
	  XS subs don't have a SUB entry on the context stack, so CV and
	  pad determination goes wrong, and BAD things happen. So, just
	  don't try to determine the value under those circumstances.
	  Need a better fix at dome point. DAPM 11/2007 */
	break;

    case OP_FLIP:
    case OP_FLOP:
    {
	GV * const gv = gv_fetchpvs(".", GV_NOTQUAL, SVt_PV);
	if (gv && GvSV(gv) == uninit_sv)
	    return newSVpvs_flags("$.", SVs_TEMP);
	goto do_op;
    }

    case OP_POS:
	/* def-ness of rval pos() is independent of the def-ness of its arg */
	if ( !(obase->op_flags & OPf_MOD))
	    break;

    case OP_SCHOMP:
    case OP_CHOMP:
	if (SvROK(PL_rs) && uninit_sv == SvRV(PL_rs))
	    return newSVpvs_flags("${$/}", SVs_TEMP);
	/* FALLTHROUGH */

    default:
    do_op:
	if (!(obase->op_flags & OPf_KIDS))
	    break;
	o = cUNOPx(obase)->op_first;
	
    do_op2:
	if (!o)
	    break;

	/* This loop checks all the kid ops, skipping any that cannot pos-
	 * sibly be responsible for the uninitialized value; i.e., defined
	 * constants and ops that return nothing.  If there is only one op
	 * left that is not skipped, then we *know* it is responsible for
	 * the uninitialized value.  If there is more than one op left, we
	 * have to look for an exact match in the while() loop below.
         * Note that we skip padrange, because the individual pad ops that
         * it replaced are still in the tree, so we work on them instead.
	 */
	o2 = NULL;
	for (kid=o; kid; kid = OpSIBLING(kid)) {
	    const OPCODE type = kid->op_type;
	    if ( (type == OP_CONST && SvOK(cSVOPx_sv(kid)))
	      || (type == OP_NULL  && ! (kid->op_flags & OPf_KIDS))
	      || (type == OP_PUSHMARK)
	      || (type == OP_PADRANGE)
	    )
	    continue;

	    if (o2) { /* more than one found */
		o2 = NULL;
		break;
	    }
	    o2 = kid;
	}
	if (o2)
	    return find_uninit_var(o2, uninit_sv, match, desc_p);

	/* scan all args */
	while (o) {
	    sv = find_uninit_var(o, uninit_sv, 1, desc_p);
	    if (sv)
		return sv;
	    o = OpSIBLING(o);
	}
	break;
    }
    return NULL;
}


/*
=for apidoc report_uninit

Print appropriate "Use of uninitialized variable" warning.

=cut
*/

void
Perl_report_uninit(pTHX_ const SV *uninit_sv)
{
    const char *desc = NULL;
    SV* varname = NULL;

    if (PL_op) {
	desc = PL_op->op_type == OP_STRINGIFY && PL_op->op_folded
		? "join or string"
		: OP_DESC(PL_op);
	if (uninit_sv && PL_curpad) {
	    varname = find_uninit_var(PL_op, uninit_sv, 0, &desc);
	    if (varname)
		sv_insert(varname, 0, 0, " ", 1);
	}
    }
    else if (PL_curstackinfo->si_type == PERLSI_SORT && cxstack_ix == 0)
        /* we've reached the end of a sort block or sub,
         * and the uninit value is probably what that code returned */
        desc = "sort";

    /* PL_warn_uninit_sv is constant */
    GCC_DIAG_IGNORE(-Wformat-nonliteral);
    if (desc)
        /* diag_listed_as: Use of uninitialized value%s */
        Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit_sv,
                SVfARG(varname ? varname : &PL_sv_no),
                " in ", desc);
    else
        Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
                "", "", "");
    GCC_DIAG_RESTORE;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.22
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d34 2
a35 8

#ifndef HAS_C99
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L && !defined(VMS)
#  define HAS_C99 1
# endif
#endif
#ifdef HAS_C99
# include <stdint.h>
d43 8
a111 3
/* void Gconvert: on Linux at least, gcvt (which Gconvert gets deffed to),
 * has a mandatory return value, even though that value is just the same
 * as the buf arg */
d128 2
a129 4
#ifdef PERL_OLD_COPY_ON_WRITE
#define SV_COW_NEXT_SV(sv)	INT2PTR(SV *,SvUVX(sv))
#define SV_COW_NEXT_SV_SET(current,next)	SvUV_set(current, PTR2UV(next))
#endif
a133 1

d158 2
a159 2
    PL_sv_arenaroot	pointer to list of SV arenas
    PL_sv_root		pointer to list of free SV structures
d161 3
a163 3
    PL_body_arenas	head of linked-list of body arenas
    PL_body_roots[]	array of pointers to list of free bodies of svtype
			arrays are indexed by the svtype needed
d260 1
a260 1
#  define POSION_SV_HEAD(sv)	PoisonNew(sv, 1, struct STRUCT_SV)
d262 1
a262 1
#  define POSION_SV_HEAD(sv)	PoisonNew(&SvANY(sv), 1, void *), \
d267 1
a267 1
#  define POSION_SV_HEAD(sv)
d283 1
a283 1
	POSION_SV_HEAD(p);				\
a304 1
    dVAR;
a379 2
    dVAR;

a423 1
    dVAR;
a462 1
    dVAR;
a520 1
    dVAR;
a545 1
    dVAR;
a588 1
    dVAR;
a624 1
    dVAR;
a652 1
    dVAR;
a674 1
    dVAR;
d725 1
a729 1
    dVAR;
d797 2
d837 2
a838 2
the start of the structure.  IV bodies don't need it either, because
they are no longer allocated.
d882 6
a887 6
    U8 offset;
    unsigned int type : 4;	    /* We have space for a sanity check.  */
    unsigned int cant_upgrade : 1;  /* Cannot upgrade this type */
    unsigned int zero_nv : 1;	    /* zero the NV when upgrading from this */
    unsigned int arena : 1;	    /* Allocated from an arena */
    size_t arena_size;		    /* Size of arena to allocate */
d941 5
d949 1
d1036 3
a1038 2

#define new_XNV()	safemalloc(sizeof(XPVNV))
d1046 3
a1048 1
#define new_XNV()	new_body_allocated(SVt_NV)
a1067 1
    dVAR;
d1075 3
a1175 1
    dVAR;
d1194 1
a1194 1
C<svtype>.
a1201 1
    dVAR;
d1291 2
a1292 2
	assert(SVt_IV < SVt_PV);
	assert(SVt_NV < SVt_PV);
a1302 4
	/* This flag bit is used to mean other things in other scalar types.
	   Given that it only has meaning inside the pad, it shouldn't be set
	   on anything that can get upgraded.  */
	assert(!SvPAD_TYPED(sv));
d1325 1
a1325 1
	SvANY(sv) = (XPVIV*)((char*)&(sv->sv_u.svu_iv) - STRUCT_OFFSET(XPVIV, xiv_iv));
d1330 3
d1334 1
d1398 1
d1478 3
a1480 1
    if (old_type > SVt_IV) {
d1503 6
a1508 2
int
Perl_sv_backoff(pTHX_ SV *const sv)
a1513 1
    PERL_UNUSED_CONTEXT;
d1523 1
d1525 1
a1525 2
    SvFLAGS(sv) &= ~SVf_OOK;
    return 0;
d1565 1
a1565 1
#ifdef PERL_NEW_COPY_ON_WRITE
d1572 7
a1578 2
     * 2^N+1 */
    if (newlen & 0xff)
d1592 3
d1596 3
a1598 1
            newlen = PERL_STRLEN_ROUNDUP(newlen);
d1627 1
a1627 1
Does not handle 'set' magic.  See also C<sv_setiv_mg>.
a1634 2
    dVAR;

d1658 1
d1687 1
a1687 1
Does not handle 'set' magic.  See also C<sv_setuv_mg>.
d1738 1
a1738 1
Does not handle 'set' magic.  See also C<sv_setnv_mg>.
a1745 2
    dVAR;

d1770 1
d1795 4
a1798 2
/* Print an "isn't numeric" warning, using a cleaned-up,
 * printable version of the offending string
d1801 3
a1803 7
STATIC void
S_not_a_number(pTHX_ SV *const sv)
{
     dVAR;
     SV *dsv;
     char tmpbuf[64];
     const char *pv;
d1805 1
a1805 1
     PERL_ARGS_ASSERT_NOT_A_NUMBER;
d1808 2
a1809 2
          dsv = newSVpvs_flags("", SVs_TEMP);
          pv = sv_uni_display(dsv, sv, 10, UNI_DISPLAY_ISPRINT);
d1812 1
a1812 1
	  const char * const limit = tmpbuf + sizeof(tmpbuf) - 8;
d1863 17
d1891 13
d1909 1
a1909 1
non-numeric warning), even if your atof() doesn't grok them.  Get-magic is
d1920 1
d1929 2
a1930 1
    return grok_number(sbegin, len, NULL);
d1964 3
a1966 3
   1) to distinguish between IV/UV/NV slots that have cached a valid
      conversion where precision was lost and IV/UV/NV slots that have a
      valid conversion which has lost no precision
a2041 2
    dVAR;

d2043 1
d2089 34
a2125 2
    dVAR;

d2154 1
d2241 7
d2272 2
a2273 1
		    SvIV_set(sv, -(IV)value);
d2294 1
a2294 1
	    SvNV_set(sv, Atof(SvPVX_const(sv)));
d2299 1
a2299 5
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%" PERL_PRIgldbl ")\n",
				  PTR2UV(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%"NVgf")\n",
a2300 1
#endif
d2305 7
d2404 1
a2404 1
conversion.  If flags includes SV_GMAGIC, does an mg_get() first.
a2412 2
    dVAR;

d2462 8
a2478 5
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW(sv)) {
	    sv_force_normal_flags(sv, 0);
	}
#endif
d2500 1
a2500 1
conversion.  If flags includes SV_GMAGIC, does an mg_get() first.
a2508 2
    dVAR;

d2545 8
a2561 5
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW(sv)) {
	    sv_force_normal_flags(sv, 0);
	}
#endif
d2583 1
a2583 1
conversion.  If flags includes SV_GMAGIC, does an mg_get() first.
a2591 2
    dVAR;

a2642 5
#ifdef PERL_OLD_COPY_ON_WRITE
	if (SvIsCOW(sv)) {
	    sv_force_normal_flags(sv, 0);
	}
#endif
a2651 1
#ifdef USE_LONG_DOUBLE
d2655 1
a2655 8
			  "0x%"UVxf" num(%" PERL_PRIgldbl ")\n",
			  PTR2UV(sv), SvNVX(sv));
	    RESTORE_NUMERIC_LOCAL();
	});
#else
	DEBUG_c({
	    STORE_NUMERIC_LOCAL_SET_STANDARD();
	    PerlIO_printf(Perl_debug_log, "0x%"UVxf" num(%"NVgf")\n",
a2658 1
#endif
d2693 3
a2695 2
	} else
	    SvNV_set(sv, Atof(SvPVX_const(sv)));
d2717 1
a2717 1
	    if ((numtype & IS_NUMBER_NEG) && (value > (UV)IV_MIN)) {
d2725 4
d2745 1
a2792 8
#if defined(USE_LONG_DOUBLE)
    DEBUG_c({
	STORE_NUMERIC_LOCAL_SET_STANDARD();
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%" PERL_PRIgldbl ")\n",
		      PTR2UV(sv), SvNVX(sv));
	RESTORE_NUMERIC_LOCAL();
    });
#else
d2795 1
a2795 1
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 1nv(%"NVgf")\n",
a2798 1
#endif
d2806 2
a2807 2
reference or overload conversion.  You must use the C<SvNUM(sv)> macro to
access this function.
d2850 1
a2850 1
	uv = -iv;
d2862 43
d2908 2
a2909 2
Returns a pointer to the string value of an SV, and sets *lp to its length.
If flags includes SV_GMAGIC, does an mg_get() first.  Coerces sv to a
a2918 1
    dVAR;
d3083 5
a3087 1
	if (SvNVX(sv) == 0.0) {
d3092 22
a3113 4
	    dSAVE_ERRNO;
	    /* The +20 is pure guesswork.  Configure test needed. --jhi */
	    s = SvGROW_mutable(sv, NV_DIG + 20);
	    /* some Xenix systems wipe out errno here */
d3115 1
d3117 3
a3119 2
            PERL_UNUSED_RESULT(Gconvert(SvNVX(sv), NV_DIG, 0, s));
            SvPOK_on(sv);
d3121 21
a3141 3
            {
                DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED();
                PERL_UNUSED_RESULT(Gconvert(SvNVX(sv), NV_DIG, 0, s));
d3143 1
a3143 7
                /* If the radix character is UTF-8, and actually is in the
                 * output, turn on the UTF-8 flag for the scalar */
                if (PL_numeric_local
                    && PL_numeric_radix_sv && SvUTF8(PL_numeric_radix_sv)
                    && instr(s, SvPVX_const(PL_numeric_radix_sv)))
                {
                    SvUTF8_on(sv);
a3144 2
                RESTORE_LC_NUMERIC();
            }
d3146 4
a3149 4
            /* We don't call SvPOK_on(), because it may come to pass that the
             * locale changes so that the stringification we just did is no
             * longer correct.  We will have to re-stringify every time it is
             * needed */
d3151 3
a3153 2
	    RESTORE_ERRNO;
	    while (*s) s++;
d3205 1
a3205 1
destination SV.  Automatically performs any necessary mg_get and
d3207 3
a3209 3
UTF8 flag even from overloaded objects.  Similar in nature to
sv_2pv[_flags] but operates directly on an SV instead of just the
string.  Mostly uses sv_2pv_flags to do its work, except when that
d3214 1
a3214 1
Like sv_copypv, but doesn't invoke get magic first.
d3218 2
a3219 2
Implementation of sv_copypv and sv_copypv_nomg.  Calls get magic iff flags
include SV_GMAGIC.
a3224 8
Perl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv)
{
    PERL_ARGS_ASSERT_SV_COPYPV;

    sv_copypv_flags(dsv, ssv, 0);
}

void
d3232 1
a3232 3
    if ((flags & SV_GMAGIC) && SvGMAGICAL(ssv))
	mg_get(ssv);
    s = SvPV_nomg_const(ssv,len);
d3243 1
a3243 1
Return a pointer to the byte-encoded representation of the SV, and set *lp
d3271 1
a3271 1
Return a pointer to the UTF-8-encoded representation of the SV, and set *lp
d3297 3
a3299 3
This macro is only used by sv_true() or its macro equivalent, and only if
the latter's argument is neither SvPOK, SvIOK nor SvNOK.
It calls sv_2bool_flags with the SV_GMAGIC flag.
d3303 3
a3305 3
This function is only used by sv_true() and friends,  and only if
the latter's argument is neither SvPOK, SvIOK nor SvNOK.  If the flags
contain SV_GMAGIC, then it does an mg_get() first.
a3313 2
    dVAR;

d3363 1
a3363 1
Always sets the SvUTF8 flag to avoid future validity checks even
d3372 1
a3372 1
Like sv_utf8_upgrade, but doesn't do magic on C<sv>.
d3383 1
a3383 1
If C<flags> has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV
d3396 2
a3397 2
Like sv_utf8_upgrade_flags, but has an additional parameter C<extra>, which is
the number of unused bytes the string of 'sv' is guaranteed to have free after
a3428 2
    dVAR;

d3455 2
a3456 2
    if (PL_encoding && !(flags & SV_UTF8_NO_ENCODING)) {
        sv_recode_to_utf8(sv, PL_encoding);
d3495 1
a3495 1
must_be_utf8:
d3679 1
a3679 1
use the Encode extension for that.
a3686 2
    dVAR;

d3839 1
a3839 1
buffers of temps will not be stolen.  <sv_setsv>
d3936 4
d3943 2
d3990 2
a3991 2
static void
S_glob_assign_ref(pTHX_ SV *const dstr, SV *const sstr)
d4000 1
a4000 1
    PERL_ARGS_ASSERT_GLOB_ASSIGN_REF;
d4093 9
a4101 1
	    if(GvSTASH(dstr)) gv_method_changed(dstr); /* sub foo { 1 } sub bar { 2 } *bar = \&foo */
d4108 1
d4163 1
d4167 8
d4185 1
a4185 1
            DEBUG_o(Perl_deb(aTHX_ "glob_assign_ref clearing PL_stashcache\n"));
a4247 1
    dVAR;
d4251 1
d4255 1
a4255 1
    if (sstr == dstr)
d4258 1
a4258 6
    if (SvIS_FREED(dstr)) {
	Perl_croak(aTHX_ "panic: attempt to copy value %" SVf
		   " to a freed scalar %p", SVfARG(sstr), (void *)dstr);
    }
    SV_CHECK_THINKFIRST_COW_DROP(dstr);
    if (!sstr)
d4260 1
a4260 4
    if (SvIS_FREED(sstr)) {
	Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p to %p",
		   (void*)sstr, (void*)dstr);
    }
d4263 65
d4334 1
a4334 1
	if (dtype != SVt_PVGV && dtype != SVt_PVLV) {
d4343 7
a4349 1
		sv_upgrade(dstr, SVt_IV);
d4377 1
a4377 1
	if (SvNOK(sstr)) {
d4423 1
a4423 1
	break;
d4466 1
a4466 1
    if (dtype == SVt_PVCV) {
d4482 3
a4484 1
    else if (dtype == SVt_PVAV || dtype == SVt_PVHV || dtype == SVt_PVFM) {
d4510 1
a4510 1
		glob_assign_ref(dstr, sstr);
d4608 2
a4609 6
	 * If the rhs is already flagged as a copy-on-write string and COW
	 * is possible here, we use copy-on-write and make both SVs share
	 * the string buffer.
	 * 
	 * If the rhs is not flagged as copy-on-write, then we see whether
	 * it is worth upgrading it to such.  If the lhs already has a buf-
d4613 9
d4623 4
a4626 2
	 * If there is no buffer on the left, or the buffer is too small,
	 * then we use copy-on-write.
d4638 2
a4639 2
                 || ((sflags & (SVs_PADTMP|SVs_PADMY|SVf_READONLY
                               |SVf_IsCOW))
d4666 1
a4666 8
#ifdef PERL_OLD_COPY_ON_WRITE
		 (  sflags & SVf_IsCOW
		 || (   (sflags & CAN_COW_MASK) == CAN_COW_FLAGS
		     && (SvFLAGS(dstr) & CAN_COW_MASK) == CAN_COW_FLAGS
		     && SvTYPE(sstr) >= SVt_PVIV && len
		    )
		 )
#elif defined(PERL_NEW_COPY_ON_WRITE)
a4692 5
# ifdef PERL_OLD_COPY_ON_WRITE
                    /* Make the source SV into a loop of 1.
                       (about to become 2) */
                    SV_COW_NEXT_SV_SET(sstr, sstr);
# else
a4693 1
# endif
a4701 7
# ifdef PERL_OLD_COPY_ON_WRITE
		    assert (SvTYPE(dstr) >= SVt_PVIV);
                    /* SvIsCOW_normal */
                    /* splice us in between source and next-after-source.  */
                    SV_COW_NEXT_SV_SET(dstr, SV_COW_NEXT_SV(sstr));
                    SV_COW_NEXT_SV_SET(sstr, dstr);
# else
a4705 1
# endif
a4789 3
# ifdef PERL_OLD_COPY_ON_WRITE
#  define SVt_COW SVt_PVIV
# else
a4790 1
# endif
d4797 1
a4797 1
#if defined(PERL_DEBUG_READONLY_COW) && defined(PERL_NEW_COPY_ON_WRITE)
a4822 6
# ifdef PERL_OLD_COPY_ON_WRITE
    assert (!SvIOK(sstr));
    assert (!SvIOKp(sstr));
    assert (!SvNOK(sstr));
    assert (!SvNOKp(sstr));
# endif
a4832 3
# ifdef PERL_OLD_COPY_ON_WRITE
	SV_COW_NEXT_SV_SET(dstr, SV_COW_NEXT_SV(sstr));
# else
a4834 1
# endif
a4840 3
# ifdef PERL_OLD_COPY_ON_WRITE
	SV_COW_NEXT_SV_SET(dstr, sstr);
# else
a4841 1
# endif
a4842 3
# ifdef PERL_OLD_COPY_ON_WRITE
    SV_COW_NEXT_SV_SET(sstr, dstr);
# else
a4846 1
# endif
d4870 1
a4870 1
undefined.  Does not handle 'set' magic.  See C<sv_setpvn_mg>.
a4877 1
    dVAR;
d4927 1
a4927 1
Does not handle 'set' magic.  See C<sv_setpv_mg>.
a4934 1
    dVAR;
a4974 2
    dVAR;

d5022 5
a5026 5
outside string.  The C<ptr> should point to memory that was allocated
by L<Newx|perlclib/Memory Management and String Handling>.  It must be
the start of a Newx-ed block of memory, and not a pointer to the
middle of it (beware of L<OOK|perlguts/Offsets> and copy-on-write),
and not be from a non-Newx memory allocator like C<malloc>.  The
d5030 1
a5030 1
giving it to sv_usepvn, and neither should any pointers from "behind"
d5033 3
a5035 2
If C<flags> & SV_SMAGIC is true, will call SvSETMAGIC.  If C<flags> &
SV_HAS_TRAILING_NUL is true, then C<ptr[len]> must be C<NUL>, and the realloc
a5044 1
    dVAR;
a5102 38
#ifdef PERL_OLD_COPY_ON_WRITE
/* Need to do this *after* making the SV normal, as we need the buffer
   pointer to remain valid until after we've copied it.  If we let go too early,
   another thread could invalidate it by unsharing last of the same hash key
   (which it can do by means other than releasing copy-on-write Svs)
   or by changing the other copy-on-write SVs in the loop.  */
STATIC void
S_sv_release_COW(pTHX_ SV *sv, const char *pvx, SV *after)
{
    PERL_ARGS_ASSERT_SV_RELEASE_COW;

    { /* this SV was SvIsCOW_normal(sv) */
         /* we need to find the SV pointing to us.  */
        SV *current = SV_COW_NEXT_SV(after);

        if (current == sv) {
            /* The SV we point to points back to us (there were only two of us
               in the loop.)
               Hence other SV is no longer copy on write either.  */
            SvIsCOW_off(after);
            sv_buf_to_rw(after);
        } else {
            /* We need to follow the pointers around the loop.  */
            SV *next;
            while ((next = SV_COW_NEXT_SV(current)) != sv) {
                assert (next);
                current = next;
                 /* don't loop forever if the structure is bust, and we have
                    a pointer into a closed loop.  */
                assert (current != after);
                assert (SvPVX_const(current) == pvx);
            }
            /* Make the SV before us point to the SV after us.  */
            SV_COW_NEXT_SV_SET(current, after);
        }
    }
}
#endif
d5109 1
a5109 1
an xpvmg; if we're a copy-on-write scalar, this is the on-write time when
d5113 1
a5113 1
SvPOK_off rather than making a copy.  (Used where this
a5128 2
    dVAR;

a5134 6
# ifdef PERL_OLD_COPY_ON_WRITE
	/* next COW sv in the loop.  If len is 0 then this is a shared-hash
	   key scalar, so we mustn't attempt to call SV_COW_NEXT_SV(), as
	   we'll fail an assertion.  */
	SV * const next = len ? SV_COW_NEXT_SV(sv) : 0;
# endif
d5143 17
a5159 4
# ifdef PERL_NEW_COPY_ON_WRITE
	if (len && CowREFCNT(sv) == 0)
	    /* We own the buffer ourselves. */
	    sv_buf_to_rw(sv);
a5162 1
		
d5164 1
a5164 8
# ifdef PERL_NEW_COPY_ON_WRITE
	    /* Must do this first, since the macro uses SvPVX. */
	    if (len) {
		sv_buf_to_rw(sv);
		CowREFCNT(sv)--;
		sv_buf_to_ro(sv);
	    }
# endif
a5177 3
# ifdef PERL_OLD_COPY_ON_WRITE
		sv_release_COW(sv, pvx, next);
# endif
d5211 1
a5211 1
    else if (SvIsCOW(sv))
d5273 4
a5276 4
SvPOK(sv), or at least SvPOKp(sv), must be true and the C<ptr> must be a
pointer to somewhere inside the string buffer.  The C<ptr> becomes the first
character of the adjusted string.  Uses the "OOK hack".  On return, only
SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.
d5376 1
a5376 1
Concatenates the string onto the end of the string which is in the SV.  The
d5379 1
a5379 1
Handles 'get' magic, but not 'set' magic.  See C<sv_catpvn_mg>.
d5384 8
a5391 2
C<len> indicates number of bytes to copy.  If the SV has the UTF-8
status set, then the bytes appended should be valid UTF-8.
a5402 1
    dVAR;
d5451 2
a5452 2
Handles 'get' magic on both SVs, but no 'set' magic.  See C<sv_catsv_mg> and
C<sv_catsv_nomg>.
d5458 2
a5459 2
If C<flags> include C<SV_GMAGIC> bit set, will call C<mg_get> on both SVs if
appropriate.  If C<flags> include C<SV_SMAGIC>, C<mg_set> will be called on
a5467 2
    dVAR;
 
d5473 1
a5473 2
	if (spv) {
            if (flags & SV_GMAGIC)
d5475 1
a5475 1
	    sv_catpvn_flags(dsv, spv, slen,
d5477 1
a5477 1
            if (flags & SV_SMAGIC)
a5478 1
        }
d5488 2
a5489 1
valid UTF-8.  Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.
a5495 1
    dVAR;
d5556 1
a5556 1
trailing C<NUL> is also reserved.  (SvPOK is not set for the SV even if string
d5559 1
a5559 1
In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first
d5561 1
a5561 1
This aid has been superseded by a new build option, PERL_MEM_LOG (see
a5570 1
    dVAR;
d5575 1
a5575 2
	sv_upgrade(sv, SVt_PV);
	SvGROW(sv, len + 1);
d5583 1
a5583 1
supplied vtable and returns a pointer to the magic added.
d5586 2
a5587 2
In particular, you can add magic to SvREADONLY SVs, and add more than
one instance of the same 'how'.
d5592 1
a5592 1
to contain an C<SV*> and is stored as-is with its REFCNT incremented.
a5601 1
    dVAR;
a5605 2
    if (SvTYPE(sv)==SVt_PVAV) { assert (!AvPAD_NAMELIST(sv)); }

a5678 4
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv))
	sv_force_normal_flags(sv, 0);
#endif
d5690 1
a5690 1
See C<sv_magicext> (which C<sv_magic> now calls) for a description of the
d5693 2
a5694 2
You need to use C<sv_magicext> to add magic to SvREADONLY SVs and also
to add more than one instance of the same 'how'.
a5702 1
    dVAR;
a5723 4
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv))
        sv_force_normal_flags(sv, 0);
#endif
d5803 1
a5803 1
    else {
d5805 1
a5805 2
	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
    }
d5874 39
a5942 1
    dVAR;
a6002 1
    dVAR;
d6051 1
a6051 1
		   *svp, PL_phase_names[PL_phase], (UV)SvREFCNT(tsv));
d6110 2
a6111 1
	    Perl_croak(aTHX_ "panic: del_backref, *svp=%p, sv=%p", *svp, sv);
d6211 1
a6211 1
the Perl substr() function.  Handles get magic.
a6223 1
    dVAR;
a6232 2
    if (!bigstr)
	Perl_croak(aTHX_ "Can't modify nonexistent substring");
a6318 1
    dVAR;
d6350 1
a6350 2
	SvANY(sv)
	    = (XPVIV*)((char*)&(sv->sv_u.svu_iv) - STRUCT_OFFSET(XPVIV, xiv_iv));
a6353 22
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW_normal(nsv)) {
	/* We need to follow the pointers around the loop to make the
	   previous SV point to sv, rather than nsv.  */
	SV *next;
	SV *current = nsv;
	while ((next = SV_COW_NEXT_SV(current)) != nsv) {
	    assert(next);
	    current = next;
	    assert(SvPVX_const(current) == SvPVX_const(nsv));
	}
	/* Make the SV before us point to the SV after us.  */
	if (DEBUG_C_TEST) {
	    PerlIO_printf(Perl_debug_log, "previous is\n");
	    sv_dump(current);
	    PerlIO_printf(Perl_debug_log,
                          "move it from 0x%"UVxf" to 0x%"UVxf"\n",
			  (UV) SV_COW_NEXT_SV(current), (UV) sv);
	}
	SV_COW_NEXT_SV_SET(current, sv);
    }
#endif
d6407 1
a6407 1
This function should only be called when REFCNT is zero.  Most of the time
d6424 2
a6425 1
    STRLEN hash_index;
d6451 3
a6453 1
	assert(!SvOBJECT(sv) || type >= SVt_PVMG); /* objs are always >= MG */
d6467 1
a6467 6
	    else if (type == SVt_PVMG && SvPAD_OUR(sv)) {
		SvREFCNT_dec(SvOURSTASH(sv));
	    }
	    else if (type == SVt_PVAV && AvPAD_NAMELIST(sv)) {
		assert(!SvMAGICAL(sv));
	    } else if (SvMAGIC(sv)) {
a6472 2
	    if (type == SVt_PVMG && SvPAD_TYPED(sv))
		SvREFCNT_dec(SvSTASH(sv));
d6483 4
a6486 1
		io_close(MUTABLE_IO(sv), FALSE);
d6516 1
a6516 1
		const char *name;
d6520 1
a6520 1
		    && (name = HvNAME((HV*)sv)))
d6523 4
a6526 2
                    DEBUG_o(Perl_deb(aTHX_ "sv_clear clearing PL_stashcache for '%"SVf"'\n",
                                     sv));
d6528 1
a6528 1
					   HvNAME_HEK((HV*)sv), G_DISCARD);
d6579 1
d6604 1
a6639 3
# ifdef PERL_OLD_COPY_ON_WRITE
			sv_release_COW(sv, SvPVX_const(sv), SV_COW_NEXT_SV(sv));
# else
a6645 1
# endif
a6650 3
# ifdef PERL_OLD_COPY_ON_WRITE
		else
# endif
a6768 2
    dVAR;

d6782 2
d6785 40
a6824 14
	    if (!SvOBJECT(stash)) destructor = (CV *)SvSTASH(stash);
	    if (!destructor || HvMROMETA(stash)->destroy_gen
				!= PL_sub_generation)
	    {
		GV * const gv =
		    gv_fetchmeth_autoload(stash, "DESTROY", 7, 0);
		if (gv) destructor = GvCV(gv);
		if (!SvOBJECT(stash))
		{
		    SvSTASH(stash) =
			destructor ? (HV *)destructor : ((HV *)0)+1;
		    HvAUX(stash)->xhv_mro_meta->destroy_gen =
			PL_sub_generation;
		}
d6826 2
a6827 3
	    assert(!destructor || destructor == ((CV *)0)+1
		|| SvTYPE(destructor) == SVt_PVCV);
	    if (destructor && destructor != ((CV *)0)+1
d6914 1
a6914 1
the body; finally, deallocate the SV's head itself.
d7006 2
a7007 2
coercion and sets the UTF8 flag appropriately.  See also C<SvCUR>, which
gives raw access to the xpv_cur slot.
a7054 1
    dVAR;
d7273 2
a7274 2
lenp is non-zero, it does the same to lenp, but this time starting from
the offset, rather than from the start
d7276 1
a7276 1
I<flags> is passed to C<SvPV_flags>, and usually should be
d7328 1
a7328 1
Converts the value pointed to by offsetp from a count of UTF-8 chars from
d7330 1
a7330 1
lenp is non-zero, it does the same to lenp, but this time starting from
d7431 3
a7433 6
	/* SvPOKp() because it's possible that sv has string overloading, and
	   therefore is a reference, hence SvPVX() is actually a pointer.
	   This cures the (very real) symptoms of RT 69422, but I'm not actually
	   sure whether we should even be caching the results of UTF-8
	   operations on overloading, given that nothing stops overloading
	   returning a different value every time it's called.  */
d7461 1
a7481 22
                cache[0] = utf8;
                cache[1] = byte;
	    }
	    else {
                cache[0] = utf8;
                cache[1] = byte;
	    }
	}
	else if (byte > cache[3]) {
	    /* New position is between the existing pair of pairs.  */
	    const float keep_earlier
		= THREEWAY_SQUARE(0, cache[3], byte, blen);
	    const float keep_later
		= THREEWAY_SQUARE(0, byte, cache[1], blen);

	    if (keep_later < keep_earlier) {
                cache[2] = utf8;
                cache[3] = byte;
	    }
	    else {
                cache[0] = utf8;
                cache[1] = byte;
d7483 2
d7487 21
a7507 9
 	    /* New position is before the existing pair of pairs.  */
	    const float keep_earlier
		= THREEWAY_SQUARE(0, byte, cache[3], blen);
	    const float keep_later
		= THREEWAY_SQUARE(0, byte, cache[1], blen);

	    if (keep_later < keep_earlier) {
                cache[2] = utf8;
                cache[3] = byte;
d7510 6
a7515 4
                cache[0] = cache[2];
                cache[1] = cache[3];
                cache[2] = utf8;
                cache[3] = byte;
d7551 1
a7551 1
Converts the offset from a count of bytes from the start of the string, to
d7553 1
a7553 1
I<flags> is passed to C<SvPV_flags>, and usually should be
d7655 1
a7655 1
Converts the value pointed to by offsetp from a count of bytes from the
d7706 1
a7706 1
identical.  Is UTF-8 and 'use bytes' aware, handles get magic, and will
d7712 2
a7713 2
identical.  Is UTF-8 and 'use bytes' aware and coerces its args to strings
if necessary.  If the flags include SV_GMAGIC, it handles get-magic, too.
a7720 1
    dVAR;
d7754 1
a7754 1
	 if (PL_encoding) {
d7757 1
a7757 1
		   sv_recode_to_utf8(svrecode, PL_encoding);
d7762 1
a7762 1
		   sv_recode_to_utf8(svrecode, PL_encoding);
d7798 2
a7799 2
C<sv2>.  Is UTF-8 and 'use bytes' aware, handles get magic, and will
coerce its args to strings if necessary.  See also C<sv_cmp_locale>.
d7805 3
a7807 3
C<sv2>.  Is UTF-8 and 'use bytes' aware and will coerce its args to strings
if necessary.  If the flags include SV_GMAGIC, it handles get magic.  See
also C<sv_cmp_locale_flags>.
a7821 1
    dVAR;
d7845 1
a7845 1
	    if (PL_encoding) {
d7847 1
a7847 1
		 sv_recode_to_utf8(svrecode, PL_encoding);
d7857 1
a7857 1
	    if (PL_encoding) {
d7859 1
a7859 1
		 sv_recode_to_utf8(svrecode, PL_encoding);
d7870 2
d7877 36
a7912 1
        const I32 retval = memcmp((const void*)pv1, (const void*)pv2, cur1 < cur2 ? cur1 : cur2);
d7914 117
a8030 7
	if (retval) {
	    cmp = retval < 0 ? -1 : 1;
	} else if (cur1 == cur2) {
	    cmp = 0;
        } else {
	    cmp = cur1 < cur2 ? -1 : 1;
	}
d8042 2
a8043 2
'use bytes' aware, handles get magic, and will coerce its args to strings
if necessary.  See also C<sv_cmp>.
d8048 3
a8050 2
'use bytes' aware and will coerce its args to strings if necessary.  If the
flags contain SV_GMAGIC, it handles get magic.  See also C<sv_cmp_flags>.
a8064 1
    dVAR;
d8103 1
a8103 1
    /*FALLTHROUGH*/
d8119 1
a8119 1
C<sv_collxfrm_flags>.
d8124 1
a8124 1
flags contain SV_GMAGIC, it handles get-magic.
d8126 1
a8126 1
Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the
a8136 1
    dVAR;
a8151 4
#ifdef PERL_OLD_COPY_ON_WRITE
		if (SvIsCOW(sv))
		    sv_force_normal_flags(sv, 0);
#endif
d8201 1
a8201 2
#ifdef VMS
#include <rms.h>
a8322 1
    dVAR;
d8375 2
a8376 1
	if (!PerlLIO_fstat(PerlIO_fileno(fp), &st) && S_ISREG(st.st_mode))  {
d8379 1
a8379 1
#ifdef PERL_NEW_COPY_ON_WRITE
a8465 10
#if defined(VMS) && defined(PERLIO_IS_STDIO)
    /* An ungetc()d char is handled separately from the regular
     * buffer, so we getc() it back out and stuff it in the buffer.
     */
    i = PerlIO_getc(fp);
    if (i == EOF) return 0;
    *(--((*fp)->_ptr)) = (unsigned char) i;
    (*fp)->_cnt++;
#endif

d8558 1
a8558 1
	"Screamer: entering: PerlIO * thinks ptr=%"UVuf", cnt=%zd, base=%"
d8560 1
a8560 1
	       PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
d8605 2
a8606 2
			     "Screamer: going to getc, ptr=%"UVuf", cnt=%zd\n",
			      PTR2UV(ptr),cnt));
d8610 2
a8611 2
	   "Screamer: pre: FILE * thinks ptr=%"UVuf", cnt=%zd, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
d8626 2
a8627 2
	   "Screamer: post: FILE * thinks ptr=%"UVuf", cnt=%zd, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
d8634 2
a8635 2
	    "Screamer: after getc, ptr=%"UVuf", cnt=%zd\n",
	     PTR2UV(ptr),cnt));
d8654 1
a8654 1
thats_all_folks:
d8660 1
a8660 1
thats_really_all_folks:
d8664 1
a8664 1
	    "Screamer: quitting, ptr=%"UVuf", cnt=%zd\n",PTR2UV(ptr),cnt));
d8667 1
a8667 1
	"Screamer: end: FILE * thinks ptr=%"UVuf", cnt=%zd, base=%"UVuf
d8669 1
a8669 1
	PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
d8688 1
a8688 1
screamer2:
a8782 1
    dVAR;
d8832 2
a8833 1
	if (NV_OVERFLOWS_INTEGERS_AT &&
d8845 4
d8860 1
a8864 1
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), NULL);
a8885 4
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_inc punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"PERL_PRIgldbl"\n",
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
#else
a8887 1
#endif
d8890 2
d8910 1
a8910 1
	    if (*d != 'z' && *d != 'Z') {
a8945 1
    dVAR;
a8963 1
    dVAR;
d9015 2
a9016 1
	    if (NV_OVERFLOWS_INTEGERS_AT &&
d9028 5
a9063 4
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_dec punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"PERL_PRIgldbl"\n",
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
#else
a9065 1
#endif
d9078 4
a9081 2
	EXTEND_MORTAL(1); \
	PL_tmps_stack[++PL_tmps_ix] = (AnSv); \
d9089 2
a9090 2
explicit call to FREETMPS, or by an implicit call at places such as
statement boundaries.  See also C<sv_newmortal> and C<sv_2mortal>.
a9102 1
    dVAR;
d9119 2
a9120 2
FREETMPS, or by an implicit call at places such as statement boundaries.
See also C<sv_mortalcopy> and C<sv_2mortal>.
a9127 1
    dVAR;
a9160 1
    dVAR;
d9190 4
a9193 4
by an explicit call to FREETMPS, or by an implicit call at places such as
statement boundaries.  SvTEMP() is turned on which means that the SV's
string buffer can be "stolen" if this SV is copied.  See also C<sv_newmortal>
and C<sv_mortalcopy>.
d9203 1
a9203 1
	return NULL;
d9217 1
a9217 1
strlen(), (which means if you use this option, that C<s> can't have embedded
a9227 1
    dVAR;
a9250 1
    dVAR;
a9251 1

d9262 1
a9262 1
SV if the hek is NULL.
a9269 1
    dVAR;
d9325 1
a9325 1
Creates a new SV with its SvPVX_const pointing to a shared string in the string
d9327 2
a9328 2
created first.  Turns on the SvIsCOW flag (or READONLY
and FAKE in 5.16 and earlier).  If the C<hash> parameter
d9333 1
a9333 1
SvPVX_const == HeKEY and hash lookup will avoid string compare.
d9413 1
a9413 1
C<sprintf>.
a9436 1
    dVAR;
a9457 1
    dVAR;
a9476 1
    dVAR;
d9480 16
a9495 1
    sv_setiv(sv,i);
a9510 1
    dVAR;
d9513 8
d9522 14
a9535 1
    sv_setuv(sv,u);
d9554 3
a9556 1
    sv_upgrade(sv, type);
d9572 1
a9572 2
    dVAR;
    SV *sv = newSV_type(SVt_IV);
d9576 12
d9590 1
a9590 1
    SvROK_on(sv);
a9600 2
    dVAR;

a9617 1
    dVAR;
a9654 1
    dVAR;
d9732 2
a9733 2
'Get' magic is ignored on the sv passed in, but will be called on
C<SvRV(sv)> if sv is an RV.
d9760 1
a9760 1
	/* FALL THROUGH */
d9791 1
a9791 1
The flags in C<lref> are passed to gv_fetchsv.
a9798 1
    dVAR;
d9910 1
a9910 1
If C<flags> has C<SV_GMAGIC> bit set, will C<mg_get> on C<sv> if
d9914 1
a9914 1
C<SvPV_force> and C<SvPV_force_nomg>
a9921 2
    dVAR;

d10014 3
d10054 1
a10054 1
				: (LvTYPE(sv) == 't' || LvTYPE(sv) == 'T')
d10075 6
a10173 1
    dVAR;
d10182 1
a10182 1
    if (SvTYPE(rv) >= SVt_PVMG) {
d10225 1
a10225 1
the new SV.  If the C<pv> argument is NULL then C<PL_sv_undef> will be placed
a10240 2
    dVAR;

d10344 1
a10344 1
must be designated by its stash (see C<gv_stashpv()>).  The reference count
a10352 1
    dVAR;
d10362 1
a10362 1
    if (SvFLAGS(tmpRef) & (SVs_OBJECT|SVf_READONLY)) {
a10389 1
    dVAR;
d10449 1
a10449 1
See C<SvROK_off>.
d10489 1
d10510 1
d10524 1
a10524 1
Does not handle 'set' magic.  See C<sv_setpviv_mg>.
d10601 1
a10601 1
appending it.  Does not handle 'set' magic.  See C<sv_setpvf_mg>.
d10622 1
a10622 1
appending it.  Does not handle 'set' magic.  See C<sv_vsetpvf_mg>.
d10719 6
a10724 4
Processes its arguments like C<sprintf> and appends the formatted
output to an SV.  If the appended data contains "wide" characters
(including, but not limited to, SVs with a UTF-8 PV formatted with %s,
and characters >255 formatted with %c), the original SV might get
d10726 1
a10726 1
C<sv_catpvf_mg>.  If the original SV was UTF-8, the pattern should be
d10746 3
a10748 2
Processes its arguments like C<vsprintf> and appends the formatted output
to an SV.  Does not handle 'set' magic.  See C<sv_vcatpvf_mg>.
d10826 3
a10828 2
 * Warn of missing argument to sprintf, and then return a defined value
 * to avoid inappropriate "use of uninit" warnings [perl #71000].
d10830 2
a10831 3
#define WARN_MISSING WARN_UNINITIALIZED /* Not sure we want a new category */
STATIC SV*
S_vcatpvfn_missing_argument(pTHX) {
a10835 1
    return &PL_sv_no;
a10841 1
    dVAR;
d10869 5
d10901 7
a10907 2
to an SV.  Uses an array of SVs if the C style variable argument list is
missing (NULL).  When running with taint checks enabled, indicates via
d10911 1
a10911 1
If called as C<sv_vcatpvfn> or flags include C<SV_GMAGIC>, calls get magic.
d10933 351
a11288 1
    dVAR;
d11303 2
a11304 2
    /* large enough for "%#.#f" --chip */
    /* what about long double NVs? --jhi */
d11306 1
a11306 1
    DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED;
d11318 4
a11321 1
    if (patlen == 0)
d11323 1
d11325 4
d11339 1
a11339 1
	    S_vcatpvfn_missing_argument(aTHX);
d11344 3
d11352 1
a11352 1
#ifndef USE_LONG_DOUBLE
d11362 4
d11368 15
a11382 14
	    if (*pp == 'g') {
		/* Add check for digits != 0 because it seems that some
		   gconverts are buggy in this case, and we don't yet have
		   a Configure test for this.  */
		if (digits && digits < sizeof(ebuf) - NV_DIG - 10) {
		     /* 0, point, slack */
                    STORE_LC_NUMERIC_SET_TO_NEEDED();
		    PERL_UNUSED_RESULT(Gconvert(nv, (int)digits, 0, ebuf));
		    sv_catpv_nomg(sv, ebuf);
		    if (*ebuf)	/* May return an empty string for digits==0 */
			return;
		}
	    } else if (!digits) {
		STRLEN l;
d11384 6
a11389 5
		if ((p = F0convert(nv, ebuf + sizeof ebuf, &l))) {
		    sv_catpvn_nomg(sv, p, l);
		    return;
		}
	    }
d11413 2
d11436 6
a11441 2
	/* we need a long double target in case HAS_LONG_DOUBLE but
	   not USE_LONG_DOUBLE
d11443 16
a11458 2
#if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE > DOUBLESIZE
	long double nv;
d11460 3
a11462 1
	NV nv;
d11464 4
d11478 1
d11538 6
d11579 3
d11584 1
d11625 7
a11631 2
	    if ( (ewix = expect_number(&q)) )
		if (*q++ != '$')
d11633 1
d11661 2
a11662 2
		vecsv = (evix > 0 && evix <= svmax)
		    ? svargs[evix-1] : S_vcatpvfn_missing_argument(aTHX);
d11664 2
a11665 2
		vecsv = svix < svmax
		    ? svargs[svix++] : S_vcatpvfn_missing_argument(aTHX);
d11697 9
a11705 5
		if ( ((epix = expect_number(&q))) && (*q++ != '$') )
		    goto unknown;
		/* XXX: todo, support specified precision parameter */
		if (epix)
		    goto unknown;
d11707 11
a11717 4
		    i = va_arg(*args, int);
		else
		    i = (ewix ? ewix <= svmax : svix < svmax)
			? SvIVx(svargs[ewix ? ewix-1 : svix++]) : 0;
d11784 2
a11785 1
#if IVSIZE >= 8 || defined(HAS_LONG_DOUBLE)
d11787 6
a11792 2
	    /*FALLTHROUGH*/
#if IVSIZE >= 8
d11794 1
a11794 1
#endif
d11801 2
a11802 1
#if IVSIZE >= 8 || defined(HAS_LONG_DOUBLE)
d11822 1
a11822 1
#ifdef HAS_C99
d11844 1
a11844 2
		argsv = (i >= 0 && i < svmax)
		    ? svargs[i] : S_vcatpvfn_missing_argument(aTHX);
d11846 2
a11847 2
		argsv = (svix >= 0 && svix < svmax)
		    ? svargs[svix++] : S_vcatpvfn_missing_argument(aTHX);
d11851 8
d11866 5
a11870 1
	    uv = (args) ? va_arg(*args, int) : SvIV(argsv);
d11926 3
d11941 1
a11941 1
	    /*FALLTHROUGH*/
d11944 3
d11950 1
a11950 1
		    continue;
d11970 1
d11972 1
d11974 1
a11974 1
#ifdef HAS_C99
d11986 1
a11986 1
		IV tiv = SvIV(argsv); /* work around GCC bug #13488 */
d12009 1
a12009 1
		    uv = -iv;
d12022 1
a12022 1
	    /*FALLTHROUGH*/
d12038 1
a12038 1
	    /*FALLTHROUGH*/
d12048 3
d12055 1
a12055 1
		    continue;
d12073 1
d12075 2
a12076 1
#ifdef HAS_C99
d12089 1
a12089 1
		UV tuv = SvUV(argsv); /* work around GCC bug #13488 */
d12109 1
a12112 1
		    unsigned dig;
d12167 2
d12171 1
a12171 1
	    /*FALLTHROUGH*/
d12175 1
d12187 1
a12187 1
#if defined(USE_LONG_DOUBLE)
d12193 1
a12193 1
		/*FALLTHROUGH*/
d12195 1
a12195 1
#if defined(USE_LONG_DOUBLE)
d12203 1
a12203 1
		/*FALLTHROUGH*/
d12213 23
a12235 6
	    /* now we need (long double) if intsize == 'q', else (double) */
	    nv = (args) ?
#if LONG_DOUBLESIZE > DOUBLESIZE
		intsize == 'q' ?
		    va_arg(*args, long double) :
		    va_arg(*args, double)
d12237 2
a12238 1
		    va_arg(*args, double)
d12240 7
a12246 1
		: SvNV(argsv);
d12249 49
a12297 11
	    /* nv * 0 will be NaN for NaN, +Inf and -Inf, and 0 for anything
	       else. frexp() has some unspecified behaviour for those three */
	    if (c != 'e' && c != 'E' && (nv * 0) == 0) {
		i = PERL_INT_MIN;
		/* FIXME: if HAS_LONG_DOUBLE but not USE_LONG_DOUBLE this
		   will cast our (long double) to (double) */
		(void)Perl_frexp(nv, &i);
		if (i == PERL_INT_MIN)
		    Perl_die(aTHX_ "panic: frexp");
		if (i > 0)
		    need = BIT_DIGITS(i);
d12335 1
a12335 1
		((nv < MY_DBL_MAX_BUG) && (nv > -MY_DBL_MAX_BUG)) &&
d12340 1
a12340 1
		if ((nv <= 0L) && (nv >= -0L))
d12346 1
a12346 1
		    if ((nv >= MY_DBL_MIN) || (nv <= -MY_DBL_MIN)) {
d12349 2
a12350 2
			if ((nv >= ((long double)1/DBL_MAX)) ||
			    (nv <= (-(long double)1/DBL_MAX)))
d12359 2
a12360 2
		    temp = (double)nv;
		    nv = (NV)temp;
d12379 2
a12380 1
		 && has_precis && intsize != 'q' ) {	/* Shortcuts */
d12383 1
a12383 1
		if ( c == 'g' && precis) {
d12385 1
a12385 1
		    PERL_UNUSED_RESULT(Gconvert((NV)nv, (int)precis, 0, PL_efloatbuf));
d12391 1
a12391 1
		} else if ( c == 'f' && !precis) {
d12396 233
a12628 6
	    {
		char *ptr = ebuf + sizeof ebuf;
		*--ptr = '\0';
		*--ptr = c;
		/* FIXME: what to do if HAS_LONG_DOUBLE but not PERL_PRIfldbl? */
#if defined(HAS_LONG_DOUBLE) && defined(PERL_PRIfldbl)
d12633 3
a12635 3
		    static char const prifldbl[] = PERL_PRIfldbl;
		    char const *p = prifldbl + sizeof(prifldbl) - 3;
		    while (p >= prifldbl) { *--ptr = *p--; }
d12666 16
a12681 4
#if defined(HAS_LONG_DOUBLE)
		elen = ((intsize == 'q')
			? my_snprintf(PL_efloatbuf, PL_efloatsize, ptr, nv)
			: my_snprintf(PL_efloatbuf, PL_efloatsize, ptr, (double)nv));
d12683 1
a12683 1
		elen = my_sprintf(PL_efloatbuf, ptr, nv);
d12687 1
d12690 1
d12718 1
d12720 2
a12721 1
#ifdef HAS_C99
d12734 1
a12734 1
	    continue;	/* not "break" */
d12802 2
d12860 6
d12867 9
d12886 2
a12895 2
=cut

a12962 1
    parser->lex_expect	= proto->lex_expect;
a13013 17
#ifdef PERL_MAD
    parser->endwhite	= proto->endwhite;
    parser->faketokens	= proto->faketokens;
    parser->lasttoke	= proto->lasttoke;
    parser->nextwhite	= proto->nextwhite;
    parser->realtokenstart = proto->realtokenstart;
    parser->skipwhite	= proto->skipwhite;
    parser->thisclose	= proto->thisclose;
    parser->thismad	= proto->thismad;
    parser->thisopen	= proto->thisopen;
    parser->thisstuff	= proto->thisstuff;
    parser->thistoken	= proto->thistoken;
    parser->thiswhite	= proto->thiswhite;

    Copy(proto->nexttoke, parser->nexttoke, 5, NEXTTOKE);
    parser->curforce	= proto->curforce;
#else
a13016 1
#endif
d13044 3
d13048 1
d13063 1
a13063 1
    char smallbuf[256];
d13113 8
d13141 2
a13142 2
		if (len == d_namlen(dirent)
		 && memEQ(name, dirent->d_name, len)) {
d13414 1
d13418 1
a13418 1
	Zero(tbl->tbl_ary, tbl->tbl_max + 1, struct ptr_tbl_ent **);
d13441 2
d13609 3
a13611 1
    if (SvOBJECT(sstr) && ! (SvFLAGS(SvSTASH(sstr)) & SVphv_CLONEABLE)) {
d13621 1
a13621 1
	SvANY(dstr)	= (XPVIV*)((char*)&(dstr->sv_u.svu_iv) - STRUCT_OFFSET(XPVIV, xiv_iv));
d13629 3
d13633 1
d13696 1
a13696 5
		if ((sv_type == SVt_PVMG) && SvPAD_OUR(dstr)) {
		    SvOURSTASH_set(dstr, hv_dup_inc(SvOURSTASH(dstr), param));
		} else if (sv_type == SVt_PVAV && AvPAD_NAMELIST(dstr)) {
		    NOOP;
		} else if (SvMAGIC(dstr))
d13896 1
a13896 1
		/*FALLTHROUGH*/
d13916 1
a13916 1
			share_hek_hek(CvNAME_HEK((CV *)sstr));
d13927 9
a13935 1
		CvPADLIST(dstr) = padlist_dup(CvPADLIST(sstr), param);
d14014 8
a14021 13
		ncx->blk_sub.cv		= (ncx->blk_sub.olddepth == 0
					   ? cv_dup_inc(ncx->blk_sub.cv, param)
					   : cv_dup(ncx->blk_sub.cv,param));
		ncx->blk_sub.argarray	= (CxHASARGS(ncx)
					   ? av_dup_inc(ncx->blk_sub.argarray,
							param)
					   : NULL);
		ncx->blk_sub.savearray	=  (CxHASARGS(ncx)
                                            ? av_dup_inc(ncx->blk_sub.savearray,
						     param)
					   : NULL);
		ncx->blk_sub.oldcomppad = (PAD*)ptr_table_fetch(PL_ptr_table,
					   ncx->blk_sub.oldcomppad);
d14026 1
d14029 1
d14034 5
a14038 3
		/* We are taking advantage of av_dup_inc and sv_dup_inc
		   actually being the same function, and order equivalence of
		   the two unions.
d14042 2
a14043 1
	    case CXt_LOOP_FOR:
d14046 2
d14049 3
a14051 1
	    case CXt_LOOP_PLAIN:
d14053 12
a14064 4
		    ncx->blk_loop.itervar_u.oldcomppad
			= (PAD*)ptr_table_fetch(PL_ptr_table,
					ncx->blk_loop.itervar_u.oldcomppad);
		} else {
d14070 2
d14073 4
a14076 1
		ncx->blk_format.cv	= cv_dup(ncx->blk_format.cv, param);
d14081 4
a14087 1
	    case CXt_GIVEN:
d14187 1
a14187 1
    const I32 max	= proto_perl->Isavestack_max;
d14221 1
a14221 1
	    /* fall through */
d14228 1
a14228 1
	    /* fall through */
d14235 5
d14267 1
a14267 1
	    /* fall through */
d14298 4
d14313 1
a14313 1
	    /* Fall through */
d14377 1
a14377 1
	    /* Fall through */
d14502 1
a14502 1
perl_clone takes these flags as parameters:
d14504 1
a14504 1
CLONEf_COPY_STACKS - is used to, well, copy the stacks also,
d14508 1
a14508 1
The pseudo-fork code uses COPY_STACKS while the
d14511 2
a14512 2
CLONEf_KEEP_PTR_TABLE -
perl_clone keeps a ptr_table with the pointer of the old
d14516 1
a14516 1
refcount.  If KEEP_PTR_TABLE is not set then perl_clone will kill
d14520 2
a14521 2
variable who are outside the graph perl scans, example of this
code is in threads.xs create.
d14523 1
a14523 1
CLONEf_CLONE_HOST -
d14549 1
d14553 1
d14612 2
d14617 3
d14702 1
a14702 1
#ifdef VMS
d14758 2
d14898 2
d14940 1
a14945 1
    PL_apiversion	= sv_dup_inc(proto_perl->Iapiversion, param);
d14952 1
d14998 1
d15015 1
d15095 5
d15113 1
d15125 3
a15128 2
    PL_utf8_X_regular_begin	= sv_dup_inc(proto_perl->Iutf8_X_regular_begin, param);
    PL_utf8_X_extend	= sv_dup_inc(proto_perl->Iutf8_X_extend, param);
d15391 1
a15391 1
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVt_NULL;
d15396 1
a15396 1
    SvFLAGS(&PL_sv_no)		= SVt_PVNV|SVf_READONLY
d15402 1
a15402 1
    SvFLAGS(&PL_sv_yes)		= SVt_PVNV|SVf_READONLY
d15417 2
d15426 2
a15427 2
The encoding is assumed to be an Encode object, on entry the PV
of the sv is assumed to be octets in that encoding, and the sv
d15430 2
a15431 2
If the sv already is UTF-8 (or if it is not POK), or if the encoding
is not a reference, nothing is done to the sv.  If the encoding is not
d15433 1
a15433 1
(See F<lib/encoding.pm> and L<Encode>.)
d15435 1
a15435 1
The PV of the sv is returned.
a15441 2
    dVAR;

d15503 1
a15503 1
The encoding is assumed to be an Encode object, the PV of the ssv is
d15505 5
a15509 5
from the position which (PV + *offset) pointed to.  The dsv will be
concatenated the decoded UTF-8 string from ssv.  Decoding will terminate
when the string tstr appears in decoding output or the input ends on
the PV of the ssv.  The value which the offset points will be modified
to the last input position on the ssv.
a15518 1
    dVAR;
d15523 1
a15523 1
    if (SvPOK(ssv) && SvPOK(dsv) && SvROK(encoding) && offset) {
a15603 2
    dVAR;

d15658 1
a15658 2
	SV *sv;
	AV *av;
d15664 3
a15666 3
	av = *PadlistARRAY(CvPADLIST(cv));
	sv = *av_fetch(av, targ, FALSE);
	sv_setsv_flags(name, sv, 0);
d15695 2
a15696 2
If match is true, only return a name if its value matches uninit_sv.
So roughly speaking, if a unary operator (such as OP_COS) generates a
d15698 2
a15699 2
OP_PADSV or OP_GV that gives the name of the undefined variable.  On the
other hand, with OP_ADD there are two branches to follow, so we only print
d15701 2
d15706 2
a15707 2
Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.
d15714 1
a15714 1
		  bool match)
d15721 2
d15762 1
a15762 1
						    uninit_sv, match);
d15782 1
a15782 1
	return varname(gv, hash ? '%' : '@@', obase->op_targ,
d15797 1
a15797 1
	return find_uninit_var(cUNOPx(obase)->op_first, uninit_sv, 1);
d15840 1
a15840 1
	break;
d15847 1
a15847 1
	return find_uninit_var(cBINOPo->op_last, uninit_sv, match);
d15856 2
a15857 1
	    return find_uninit_var(cBINOPx(obase)->op_last, uninit_sv, match);
d15889 1
a15889 1
		kidsv = sv_2mortal(newSVpvs("-"));
d15939 2
a15940 2
		(o->op_type == OP_PADAV || o->op_type == OP_RV2AV)
		? '@@' : '%',
d15943 196
a16138 1
	break;
d16143 2
a16144 1
	return find_uninit_var(cBINOPx(obase)->op_first, uninit_sv, match);
d16151 1
a16151 1
	    o = o->op_sibling;
d16153 1
a16153 1
	if (!o->op_sibling) {
d16177 6
a16182 8
	    if (uninit_sv == ((obase->op_private & OPpTARGET_MY)
				 ? PAD_SVl(obase->op_targ)
				 : DEFSV))
	    {
		sv = sv_newmortal();
		sv_setpvs(sv, "$_");
		return sv;
	    }
d16196 1
a16196 1
	    o = o->op_sibling->op_sibling;
d16305 1
a16305 1
	/*FALLTHROUGH*/
d16327 9
a16335 10
	for (kid=o; kid; kid = kid->op_sibling) {
	    if (kid) {
		const OPCODE type = kid->op_type;
		if ( (type == OP_CONST && SvOK(cSVOPx_sv(kid)))
		  || (type == OP_NULL  && ! (kid->op_flags & OPf_KIDS))
		  || (type == OP_PUSHMARK)
		  || (type == OP_PADRANGE)
		)
		continue;
	    }
d16343 1
a16343 1
	    return find_uninit_var(o2, uninit_sv, match);
d16347 1
a16347 1
	    sv = find_uninit_var(o, uninit_sv, 1);
d16350 1
a16350 1
	    o = o->op_sibling;
d16369 3
a16371 1
    dVAR;
d16373 3
a16375 1
	SV* varname = NULL;
d16377 1
a16377 1
	    varname = find_uninit_var(PL_op, uninit_sv,0);
a16380 14
        /* PL_warn_uninit_sv is constant */
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
	/* diag_listed_as: Use of uninitialized value%s */
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit_sv,
		SVfARG(varname ? varname : &PL_sv_no),
		" in ", OP_DESC(PL_op));
        GCC_DIAG_RESTORE;
    }
    else {
        /* PL_warn_uninit is constant */
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
		    "", "", "");
        GCC_DIAG_RESTORE;
d16382 16
a16400 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.21
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d12701 1
a12701 1
			*dst_ary++ = &PL_sv_undef;
@


1.20
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d49 1
a49 2
#ifdef PERL_NEW_COPY_ON_WRITE
#   ifndef SV_COW_THRESHOLD
d51 2
a52 2
#   endif
#   ifndef SV_COWBUF_THRESHOLD
d54 2
a55 2
#   endif
#   ifndef SV_COW_MAX_WASTE_THRESHOLD
d57 2
a58 2
#   endif
#   ifndef SV_COWBUF_WASTE_THRESHOLD
d60 2
a61 2
#   endif
#   ifndef SV_COW_MAX_WASTE_FACTOR_THRESHOLD
d63 2
a64 2
#   endif
#   ifndef SV_COWBUF_WASTE_FACTOR_THRESHOLD
a65 1
#   endif
d931 1
a931 1
    count 						\
d933 1
a933 1
    : FIT_ARENA0 (body_size)
d3454 1
a3454 1
		if (invariant_head <= 0) {
d4416 2
a4417 1
                 || ((sflags & (SVs_PADTMP|SVf_READONLY|SVf_IsCOW))
d4848 1
a4848 1
by L<Newx|perlclib/Memory Management and String Handling>. It must be
d4851 1
a4851 1
and not be from a non-Newx memory allocator like C<malloc>. The
d13096 1
d13098 1
a13098 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
a13101 1
        case SAVEt_SV:				/* scalar reference */
d13104 2
d13123 2
d13277 1
a13277 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
@


1.19
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d36 1
a36 1
# if __STDC_VERSION__ >= 199901L && !defined(VMS)
d40 1
a40 1
#if HAS_C99
a43 2
#define FCALL *f

d49 67
d487 1
a487 1
		(FCALL)(aTHX_ sv);
d840 1
a840 1
member present. If the allocated structure is smaller (no initial NV
d843 1
a843 1
allocated. (We were using structures named *_allocated for this, but
d850 1
a850 1
This is the same trick as was used for NV and IV bodies. Ironically it
d852 1
a852 1
the start of the structure. IV bodies don't need it either, because
a948 5
    /* The bind placeholder pretends to be an RV for now.
       Also it's marked as "can't upgrade" to stop anyone using it before it's
       implemented.  */
    { 0, 0, 0, SVt_BIND, TRUE, NONV, NOARENA, 0 },

d966 6
d990 1
a990 1
      SVt_REGEXP, FALSE, NONV, HASARENA,
d1377 2
a1378 1
	    HvMAX(sv) = 7; /* (start with 8 buckets) */
d1409 1
d1538 2
a1546 11
    if (PL_madskills && newlen >= 0x100000) {
	PerlIO_printf(Perl_debug_log,
		      "Allocation too large: %"UVxf"\n", (UV)newlen);
    }
#ifdef HAS_64K_LIMIT
    if (newlen >= 0x10000) {
	PerlIO_printf(Perl_debug_log,
		      "Allocation too large: %"UVxf"\n", (UV)newlen);
	my_exit(1);
    }
#endif /* HAS_64K_LIMIT */
a1557 4
#ifdef HAS_64K_LIMIT
	if (newlen >= 0x10000)
	    newlen = 0xFFFF;
#endif
d1561 1
a1561 1
	if (SvIsCOW(sv)) sv_force_normal(sv);
d1565 16
d1586 4
a1589 2
#ifndef Perl_safesysmalloc_size
	newlen = PERL_STRLEN_ROUNDUP(newlen);
d1601 1
a1601 1
#ifdef Perl_safesysmalloc_size
d1814 1
a1814 1
	       if (ch & 128 && !isPRINT_LC(ch)) {
d1817 3
a1819 1
		    ch &= 127;
d2309 1
a2309 2
	if (!SvPADTMP(sv)) {
	    if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
a2310 1
	}
d2335 4
a2338 2
    if (!sv)
	return 0;
d2430 1
a2430 2
    if (!sv)
	return 0;
d2511 5
a2515 2
    if (!sv)
	return 0.0;
d2713 1
a2713 1
	if (!PL_localizing && !SvPADTMP(sv) && ckWARN(WARN_UNINITIALIZED))
d2816 4
a2819 5
    if (!sv) {
	if (lp)
	    *lp = 0;
	return (char *)"";
    }
d2973 1
d2987 25
a3011 1
	    Gconvert(SvNVX(sv), NV_DIG, 0, s);
a3014 4
#ifdef hcx
	if (s[-1] == '.')
	    *--s = '\0';
#endif
d3038 1
a3038 1
	if (!PL_localizing && !SvPADTMP(sv) && ckWARN(WARN_UNINITIALIZED))
a3051 1
    SvPOK_on(sv);
d3127 1
d3131 1
a3131 1
	sv_copypv(sv2,sv);
a3133 1
    else SvGETMAGIC(sv);
d3182 1
a3182 1
Perl_sv_2bool_flags(pTHX_ SV *const sv, const I32 flags)
d3188 1
d3196 24
a3219 2
	    if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv))))
		return cBOOL(SvTRUE(tmpsv));
d3223 3
d3254 8
a3261 3
Returns the number of bytes in the converted string
C<sv_utf8_upgrade> and
C<sv_utf8_upgrade_nomg> are implemented in terms of this function.
d3266 12
a3279 13
The grow version is currently not externally documented.  It adds a parameter,
extra, which is the number of unused bytes the string of 'sv' is guaranteed to
have free after it upon return.  This allows the caller to reserve extra space
that it intends to fill, to avoid extra grows.

Also externally undocumented for the moment is the flag SV_FORCE_UTF8_UPGRADE,
which can be used to tell this function to not first check to see if there are
any characters that are different in UTF-8 (variant characters) which would
force it to allocate a new string to sv, but to assume there are.  Typically
this flag is used by a routine that has already parsed the string to find that
there are such characters, and passes this information on so that the work
doesn't have to be repeated.

d3281 10
a3290 10
first such variant, so it wouldn't have to be found again.  But that is not the
case, because typically when the caller is likely to use this flag, it won't be
calling this routine unless it finds something that won't fit into a byte.
Otherwise it tries to not upgrade and just use bytes.  But some things that
do fit into a byte are variants in utf8, and the caller may not have been
keeping track of these.)

If the routine itself changes the string, it adds a trailing NUL.  Such a NUL
isn't guaranteed due to having other routines do the work in some input cases,
or if the input is already flagged as being in utf8.
d3326 1
a3326 1
        sv_force_normal_flags(sv, 0);
d3356 1
a3356 1
	    if (NATIVE_IS_INVARIANT(ch)) continue;
d3464 2
a3465 7
		    const UV uv = NATIVE8_TO_UNI(*t++);
		    if (UNI_IS_INVARIANT(uv))
			*d++ = (U8)UNI_TO_NATIVE(uv);
		    else {
			*d++ = (U8)UTF8_EIGHT_BIT_HI(uv);
			*d++ = (U8)UTF8_EIGHT_BIT_LO(uv);
		    }
d3491 1
a3491 1
		    if (! NATIVE_IS_INVARIANT(chr)) two_byte_count++;
d3511 2
a3512 3
		    const U8 ch = NATIVE8_TO_UNI(*e--);
		    if (UNI_IS_INVARIANT(ch)) {
			*d-- = UNI_TO_NATIVE(ch);
d3514 2
a3515 2
			*d-- = (U8)UTF8_EIGHT_BIT_LO(ch);
			*d-- = (U8)UTF8_EIGHT_BIT_HI(ch);
d3517 1
d3524 4
a3527 1
		 * (upgrade without pos) */
d3530 1
a3530 12
		    I32 pos = mg->mg_len;
		    if (pos > 0 && (U32)pos > invariant_head) {
			U8 *d = (U8*) SvPVX(sv) + invariant_head;
			STRLEN n = (U32)pos - invariant_head;
			while (n > 0) {
			    if (UTF8_IS_START(*d))
				d++;
			    d++;
			    n--;
			}
			mg->mg_len  = d - (U8*)SvPVX(sv);
		    }
d3572 1
a3572 1
                sv_force_normal_flags(sv, 0);
d3577 3
a3579 4
		if (mg) {
		    I32 pos = mg->mg_len;
		    if (pos > 0) {
			sv_pos_b2u(sv, &pos);
a3580 2
			mg->mg_len  = pos;
		    }
d3669 3
d3696 4
a3699 3
function if the source SV needs to be reused.  Does not handle 'set' magic.
Loosely speaking, it performs a copy-by-value, obliterating any previous
content of the destination.
d3714 1
a3714 1
parameter has the C<NOSTEAL> bit set then the
a3747 2
	    /* We have to turn this on here, even though we turn it off
	       below, as GvSTASH will fail an assertion otherwise. */
d3808 2
a3812 3
    isGV_with_GP_off(dstr); /* SvOK_off does not like globs. */
    (void)SvOK_off(dstr);
    isGV_with_GP_on(dstr);
d3848 9
d4052 40
a4091 9
/* Work around compiler warnings about unsigned >= THRESHOLD when thres-
   hold is 0. */
#if SV_COW_THRESHOLD
# define GE_COW_THRESHOLD(len)		((len) >= SV_COW_THRESHOLD)
#else
# define GE_COW_THRESHOLD(len)		1
#endif
#if SV_COWBUF_THRESHOLD
# define GE_COWBUF_THRESHOLD(len)	((len) >= SV_COWBUF_THRESHOLD)
d4093 2
a4094 1
# define GE_COWBUF_THRESHOLD(len)	1
d4228 1
a4228 1
	/* case SVt_BIND: */
d4339 2
a4340 1
		if (GvGP(dstr))
d4342 1
a4362 1
        bool isSwipe = 0;
d4367 40
a4406 7
	 * Check to see if we can just swipe the string.  If so, it's a
	 * possible small lose on short strings, but a big win on long ones.
	 * It might even be a win on short strings if SvPVX_const(dstr)
	 * has to be allocated and SvPVX_const(sstr) has to be freed.
	 * Likewise if we can set up COW rather than doing an actual copy, we
	 * drop to the else clause, as the swipe code and the COW setup code
	 * have much in common.
d4414 1
a4414 35
	    /* If we're already COW then this clause is not true, and if COW
	       is allowed then we drop down to the else and make dest COW 
	       with us.  If caller hasn't said that we're allowed to COW
	       shared hash keys then we don't do the COW setup, even if the
	       source scalar is a shared hash key scalar.  */
            (((flags & SV_COW_SHARED_HASH_KEYS)
	       ? !(sflags & SVf_IsCOW)
#ifdef PERL_NEW_COPY_ON_WRITE
		|| (len &&
		    ((!GE_COWBUF_THRESHOLD(cur) && SvLEN(dstr) > cur)
		   /* If this is a regular (non-hek) COW, only so many COW
		      "copies" are possible. */
		    || CowREFCNT(sstr) == SV_COW_REFCNT_MAX))
#endif
	       : 1 /* If making a COW copy is forbidden then the behaviour we
		       desire is as if the source SV isn't actually already
		       COW, even if it is.  So we act as if the source flags
		       are not COW, rather than actually testing them.  */
	      )
#ifndef PERL_ANY_COW
	     /* The change that added SV_COW_SHARED_HASH_KEYS makes the logic
		when PERL_OLD_COPY_ON_WRITE is defined a little wrong.
		Conceptually PERL_OLD_COPY_ON_WRITE being defined should
		override SV_COW_SHARED_HASH_KEYS, because it means "always COW"
		but in turn, it's somewhat dead code, never expected to go
		live, but more kept as a placeholder on how to do it better
		in a newer implementation.  */
	     /* If we are COW and dstr is a suitable target then we drop down
		into the else and make dest a COW of us.  */
	     || (SvFLAGS(dstr) & SVf_BREAK)
#endif
	     )
            &&
            !(isSwipe =
#ifdef PERL_NEW_COPY_ON_WRITE
d4416 8
a4423 4
                 (sflags & (SVs_TEMP|SVf_IsCOW)) == SVs_TEMP &&
#else
                 (sflags & SVs_TEMP) &&   /* slated for free anyway? */
#endif
d4429 19
a4447 4
#ifdef PERL_ANY_COW
            && ((flags & SV_COW_SHARED_HASH_KEYS)
		? (!((sflags & CAN_COW_MASK) == CAN_COW_FLAGS
# ifdef PERL_OLD_COPY_ON_WRITE
d4449 11
a4459 2
		     && SvTYPE(sstr) >= SVt_PVIV
# else
d4461 2
a4462 4
		     && !(sflags & SVf_IsCOW)
		     && GE_COW_THRESHOLD(cur) && cur+1 < len
		     && (GE_COWBUF_THRESHOLD(cur) || SvLEN(dstr) < cur+1)
# endif
d4464 3
a4466 1
		: 1)
a4468 9
            /* Failed the swipe test, and it's not a shared hash key either.
               Have to copy the string.  */
            SvGROW(dstr, cur + 1);	/* inlined from sv_setpvn */
            Move(SvPVX_const(sstr),SvPVX(dstr),cur,char);
            SvCUR_set(dstr, cur);
            *SvEND(dstr) = '\0';
        } else {
            /* If PERL_OLD_COPY_ON_WRITE is not defined, then isSwipe will always
               be true in here.  */
d4470 1
a4470 1
               copy-on-write or we can swipe the string.  */
d4477 1
a4477 2
            if (!isSwipe) {
                if (!(sflags & SVf_IsCOW)) {
a4485 1
                }
a4487 1
            /* Initial code is common.  */
a4491 2
            if (!isSwipe) {
                /* making another shared SV.  */
d4493 1
a4493 1
                if (len) {
d4501 3
d4507 2
a4508 1
                } else
d4510 1
a4510 1
		{
d4518 11
a4528 18
		}
                SvLEN_set(dstr, len);
                SvCUR_set(dstr, cur);
                SvIsCOW_on(dstr);
            }
            else
                {	/* Passes the swipe test.  */
                SvPV_set(dstr, SvPVX_mutable(sstr));
                SvLEN_set(dstr, SvLEN(sstr));
                SvCUR_set(dstr, SvCUR(sstr));

                SvTEMP_off(dstr);
                (void)SvOK_off(sstr);	/* NOTE: nukes most SvFLAGS on sstr */
                SvPV_set(sstr, NULL);
                SvLEN_set(sstr, 0);
                SvCUR_set(sstr, 0);
                SvTEMP_off(sstr);
            }
d4601 3
d4664 3
d4670 1
d4689 2
a4690 1
Copies a string into an SV.  The C<len> parameter indicates the number of
d4748 3
a4750 2
Copies a string into an SV.  The string must be null-terminated.  Does not
handle 'set' magic.  See C<sv_setpv_mg>.
d4828 1
a4828 1
	    Safefree(SvPVX(sv));
d4847 1
a4847 1
string is stored inside the SV but sv_usepvn allows the SV to use an
d4849 6
a4854 4
by C<malloc>.  It must be the start of a mallocked block
of memory, and not a pointer to the middle of it.  The
string length, C<len>, must be supplied.  By default
this function will realloc (i.e. move) the memory pointed to by C<ptr>,
d4860 1
a4860 1
SV_HAS_TRAILING_NUL is true, then C<ptr[len]> must be NUL, and the realloc
d4949 1
d4983 4
d4990 2
a4991 2
void
Perl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags)
d4995 2
a4996 2
    PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS;

a4997 5
    if (SvREADONLY(sv)) {
	if (IN_PERL_RUNTIME)
	    Perl_croak_no_modify();
    }
    else if (SvIsCOW(sv)) {
d5018 1
a5018 1
	    NOOP;
d5026 5
a5030 1
	    if (len) CowREFCNT(sv)--;
d5033 1
a5054 1
    }
a5055 6
    if (SvREADONLY(sv)) {
	if (IN_PERL_RUNTIME)
	    Perl_croak_no_modify();
    }
    else
	if (SvIsCOW(sv)) {
a5069 1
	}
d5071 12
d5217 1
d5220 5
d5299 2
a5300 7
	    const UV uv = NATIVE_TO_ASCII((U8)*sstr++);
	    if (UNI_IS_INVARIANT(uv))
		*d++ = (U8)UTF_TO_NATIVE(uv);
	    else {
		*d++ = (U8)UTF8_EIGHT_BIT_HI(uv);
		*d++ = (U8)UTF8_EIGHT_BIT_LO(uv);
	    }
d5354 2
a5355 1
Concatenates the string onto the end of the string which is in the SV.
d5387 2
a5388 1
Concatenates the string onto the end of the string which is in the SV.
d5425 1
a5425 1
trailing NUL is also reserved.  (SvPOK is not set for the SV even if string
d5478 2
d5543 18
d5589 1
a5589 1
    if (how < 0 || (unsigned)how > C_ARRAY_LENGTH(PL_magic_data)
d5603 1
a5603 1
#ifdef PERL_ANY_COW
d5609 1
a5609 5
	    /* its okay to attach magic to shared strings */
	    !SvIsCOW(sv)

	    && IN_PERL_RUNTIME
	    && !PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(how)
d5626 10
d5800 4
a5803 6
	if (! ((mg =
	    (SvMAGICAL(tsv) ? mg_find(tsv, PERL_MAGIC_backref) : NULL))))
	{
	    sv_magic(tsv, NULL, PERL_MAGIC_backref, NULL, 0);
	    mg = mg_find(tsv, PERL_MAGIC_backref);
	}
d5813 2
d5817 1
a5817 1
	SvREFCNT_inc_simple_void(av);
d5819 1
a5821 1
	    av_extend(av, 1);
a5824 2
	if (mg)
	    mg->mg_flags |= MGf_REFCOUNTED;
d5826 1
a5826 1
    else
d5828 9
a5836 5

    if (!av) {
	/* optimisation: store single backref directly in HvAUX or mg_obj */
	*svp = sv;
	return;
a5838 4
    assert(SvTYPE(av) == SVt_PVAV);
    if (AvFILLp(av) >= AvMAX(av)) {
        av_extend(av, AvFILLp(av)+1);
    }
d6339 3
d6352 1
a6352 1
	    /* case SVt_BIND: */
d6399 2
a6400 2
			(void)hv_delete(PL_stashcache, name,
			    HvNAMEUTF8((HV*)sv) ? -HvNAMELEN_get((HV*)sv) : HvNAMELEN_get((HV*)sv), G_DISCARD);
d6478 1
d6514 1
d6516 1
d6789 1
a6789 1
    if (rc == 1) {
d7124 1
a7124 1
Converts the value pointed to by offsetp from a count of UTF-8 chars from
a7232 3
    /* For now, treat "overflowed" as "still unknown". See RT #72924.  */
    if (ulen != (STRLEN) (*mgp)->mg_len)
	(*mgp)->mg_len = -1;
d7410 1
a7410 1
=for apidoc sv_pos_b2u
d7412 4
a7415 3
Converts the value pointed to by offsetp from a count of bytes from the
start of the string, to a count of the equivalent number of UTF-8 chars.
Handles magic and type coercion.
d7421 3
a7423 3
 * sv_pos_b2u() uses, like sv_pos_u2b(), the mg_ptr of the potential
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
 * byte offsets.
d7426 2
a7427 2
void
Perl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp)
a7429 1
    const STRLEN byte = *offsetp;
d7436 1
a7436 4
    PERL_ARGS_ASSERT_SV_POS_B2U;

    if (!sv)
	return;
d7438 1
a7438 1
    s = (const U8*)SvPV_const(sv, blen);
d7440 1
a7440 1
    if (blen < byte)
d7442 1
a7442 1
		   ", byte=%"UVuf, (UV)blen, (UV)byte);
d7444 1
a7444 1
    send = s + byte;
d7453 1
a7453 1
	    if (cache[1] == byte) {
d7455 1
a7455 2
		*offsetp = cache[0];
		return;
d7457 1
a7457 1
	    if (cache[3] == byte) {
d7459 1
a7459 2
		*offsetp = cache[2];
		return;
d7462 1
a7462 1
	    if (cache[1] < byte) {
d7473 1
a7473 1
	    else if (cache[3] < byte) {
d7483 1
a7483 1
	    else { /* cache[3] > byte */
a7501 1
    *offsetp = len;
d7504 1
a7504 1
	if (blen == byte)
d7507 1
a7507 1
	    utf8_mg_pos_cache_update(sv, &mg, byte, len, blen);
d7509 33
d7821 2
d8034 2
a8035 2
appending to the currently-stored string. If C<append> is not 0, the
line is appended to the SV instead of overwriting it. C<append> should
d8050 3
a8052 3
    I32 cnt;
    I32 i = 0;
    I32 rspara = 0;
d8066 1
d8079 2
d8101 7
a8107 1
	     	(void) SvGROW(sv, (STRLEN)((st.st_size - offset) + append + 1));
d8132 1
d8137 3
d8165 9
d8179 8
a8186 3
    STDCHAR *ptr;
    STRLEN bpx;
    I32 shortbuffered;
d8200 58
a8257 1
    cnt = PerlIO_get_cnt(fp);			/* get count into register */
d8269 2
d8276 2
a8277 1
    else
d8279 3
d8283 1
d8285 2
d8290 3
a8292 2
	"Screamer: entering: PerlIO * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	       PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
d8294 1
d8297 1
d8299 1
d8301 1
d8303 1
d8310 1
d8321 2
d8327 1
d8334 2
d8337 2
a8338 2
			      "Screamer: going to getc, ptr=%"UVuf", cnt=%ld\n",
			      PTR2UV(ptr),(long)cnt));
d8342 2
a8343 2
	    "Screamer: pre: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
d8346 9
a8354 3
	/* This used to call 'filbuf' in stdio form, but as that behaves like
	   getc when cnt <= 0 we use PerlIO_getc here to avoid introducing
	   another abstraction.  */
d8358 2
a8359 2
	    "Screamer: post: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
d8362 1
d8366 2
a8367 1
	    "Screamer: after getc, ptr=%"UVuf", cnt=%ld\n",PTR2UV(ptr),(long)cnt));
d8372 1
d8378 1
d8381 1
d8387 2
d8396 1
a8396 1
	    "Screamer: quitting, ptr=%"UVuf", cnt=%ld\n",PTR2UV(ptr),(long)cnt));
d8399 3
a8401 2
	"Screamer: end: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
a8521 2
	if (SvIsCOW(sv) || isGV_with_GP(sv))
	    sv_force_normal_flags(sv, 0);
a8522 1
	    if (IN_PERL_RUNTIME)
d8533 1
a8701 2
	if (SvIsCOW(sv) || isGV_with_GP(sv))
	    sv_force_normal_flags(sv, 0);
a8702 1
	    if (IN_PERL_RUNTIME)
d8713 1
d8872 2
a8873 1
Creates a new SV and copies a string into it.  The reference count for the
d8902 7
a8908 7
    /* This code used to a sv_2mortal(), however we now unroll the call to sv_2mortal()
     * and do what it does ourselves here.
     * Since we have asserted that flags can only have the SVf_UTF8 and/or SVs_TEMP flags
     * set above we can use it to enable the sv flags directly (bypassing SvTEMP_on), which
     * in turn means we dont need to mask out the SVf_UTF8 flag below, which means that we
     * eliminate quite a few steps than it looks - Yves (explaining patch by gfx)
     */
d8947 2
a8948 1
Creates a new SV and copies a string into it.  The reference count for the
d8950 4
a8953 1
strlen().  For efficiency, consider using C<newSVpvn> instead.
d8972 1
a8972 1
Creates a new SV and copies a buffer into it, which may contain NUL characters
d9111 1
a9111 1
Like C<newSVpvn_share>, but takes a nul-terminated string instead of a
d9354 1
a9354 1
    if (!stash)
d9406 3
a9408 15
		if (sv) {
		    if (SvTHINKFIRST(sv)) {
			if (!SvREADONLY(sv) && SvROK(sv))
			    sv_unref(sv);
			/* XXX Is this continue a bug? Why should THINKFIRST
			   exempt us from resetting arrays and hashes?  */
			continue;
		    }
		    SvOK_off(sv);
		    if (SvTYPE(sv) >= SVt_PV) {
			SvCUR_set(sv, 0);
			if (SvPVX_const(sv) != NULL)
			    *SvPVX(sv) = '\0';
			SvTAINT(sv);
		    }
a9413 3
#if defined(VMS)
		    Perl_die(aTHX_ "Can't reset %%ENV on this system");
#else /* ! VMS */
a9414 5
#  if defined(USE_ENVIRON_ARRAY)
		    if (gv == PL_envgv)
		        my_clearenv();
#  endif /* USE_ENVIRON_ARRAY */
#endif /* VMS */
d9624 1
a9624 1
    if (SvTHINKFIRST(sv) && !SvROK(sv))
a9634 8
	if (SvREADONLY(sv) && !(flags & SV_MUTABLE_RETURN)) {
	    const char * const ref = sv_reftype(sv,0);
	    if (PL_op)
		Perl_croak(aTHX_ "Can't coerce readonly %s to string in %s",
			   ref, OP_DESC(PL_op));
	    else
		Perl_croak(aTHX_ "Can't coerce readonly %s to string", ref);
	}
d9647 2
a9648 1
	if (s != SvPVX_const(sv)) {	/* Almost, but not quite, sv_setpvn() */
d9724 8
d9759 1
a9759 1
	case SVt_BIND:		return "BIND";
d9856 1
a9856 1
reference count is 1. The reference count 1 is owned by C<rv>.
d9898 13
d10048 1
d10052 1
d10057 1
a10057 1
	if (SvREADONLY(tmpRef) && !SvIsCOW(tmpRef))
d10060 1
a10060 1
	    SvREFCNT_dec(SvSTASH(tmpRef));
d10066 1
d10096 1
d10385 1
a10385 1
    sv_vcatpvf(sv, pat, &args);
d10403 2
a10404 1
    sv_vcatpvf_mg(sv, pat, &args);
d10430 1
a10430 1
    sv_vcatpvf(sv, pat, &args);
d10450 1
a10450 1
    sv_vcatpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d10469 2
a10470 1
    sv_vcatpvf_mg(sv, pat, &args);
d10638 2
d10691 2
a10692 1
		    Gconvert(nv, (int)digits, 0, ebuf);
d10808 2
a10809 1
		%<num>p		(where num != 2 or 3) reserved for future
d10821 9
d11045 1
a11045 1
#if defined(HAS_QUAD) || defined(HAS_LONG_DOUBLE)
d11048 1
a11048 1
#ifdef HAS_QUAD
d11057 1
a11057 1
#if defined(HAS_QUAD) || defined(HAS_LONG_DOUBLE)
d11077 1
a11077 1
#if HAS_C99
d11116 1
a11116 1
		 (!UNI_IS_INVARIANT(uv) && SvUTF8(sv)))
a11184 3
#if vdNUMBER
	format_vd:
#endif
d11210 1
a11210 1
#if HAS_C99
d11214 1
a11214 1
#ifdef HAS_QUAD
d11230 1
a11230 1
#ifdef HAS_QUAD
d11307 1
a11307 1
#if HAS_C99
d11312 1
a11312 1
#ifdef HAS_QUAD
d11328 1
a11328 1
#ifdef HAS_QUAD
d11549 2
a11550 1
		    Gconvert((NV)nv, (int)precis, 0, PL_efloatbuf);
d11598 6
d11611 1
d11615 11
d11643 1
a11643 1
#if HAS_C99
d11647 1
a11647 1
#ifdef HAS_QUAD
d11726 1
a11726 1
	    Perl_croak_memory_wrap();
d11732 1
a11732 1
	    Perl_croak_memory_wrap();
d11782 3
d11980 1
a11980 1
#ifdef HAS_FCHDIR
d12000 1
a12000 1
#ifdef HAS_FCHDIR
d12017 2
a12018 1
    fchdir(my_dirfd(pwd)); /* If this fails, then what? */
d12244 3
a12246 1
/* add a new entry to a pointer-mapping table */
d12268 1
a12268 2
	    tbl->tbl_arena_end = new_arena->array
		+ sizeof(new_arena->array) / sizeof(new_arena->array[0]);
a12538 1
	/* case SVt_BIND: */
d12563 1
d12601 2
d12757 6
a12789 1
			daux->xhv_super = NULL;
d12920 4
a12923 2
		ncx->blk_sub.savearray	= av_dup_inc(ncx->blk_sub.savearray,
						     param);
d13108 1
d13162 1
d13232 6
a13310 37
	case SAVEt_RE_STATE:
	    {
		const struct re_save_state *const old_state
		    = (struct re_save_state *)
		    (ss + ix - SAVESTACK_ALLOC_FOR_RE_SAVE_STATE);
		struct re_save_state *const new_state
		    = (struct re_save_state *)
		    (nss + ix - SAVESTACK_ALLOC_FOR_RE_SAVE_STATE);

		Copy(old_state, new_state, 1, struct re_save_state);
		ix -= SAVESTACK_ALLOC_FOR_RE_SAVE_STATE;

		new_state->re_state_bostr
		    = pv_dup(old_state->re_state_bostr);
		new_state->re_state_regeol
		    = pv_dup(old_state->re_state_regeol);
#ifdef PERL_ANY_COW
		new_state->re_state_nrs
		    = sv_dup(old_state->re_state_nrs, param);
#endif
		new_state->re_state_reg_magic
		    = (MAGIC*) any_dup(old_state->re_state_reg_magic, 
			       proto_perl);
		new_state->re_state_reg_oldcurpm
		    = (PMOP*) any_dup(old_state->re_state_reg_oldcurpm, 
			      proto_perl);
		new_state->re_state_reg_curpm
		    = (PMOP*)  any_dup(old_state->re_state_reg_curpm, 
			       proto_perl);
		new_state->re_state_reg_oldsaved
		    = pv_dup(old_state->re_state_reg_oldsaved);
		new_state->re_state_reg_poscache
		    = pv_dup(old_state->re_state_reg_poscache);
		new_state->re_state_reg_starttry
		    = pv_dup(old_state->re_state_reg_starttry);
		break;
	    }
d13527 1
a13527 1
#if !NO_TAINT_SUPPORT
a13567 1
    Zero(&PL_reg_state, 1, struct re_save_state);
d13569 1
a13620 2
    PL_hints		= proto_perl->Ihints;

d13635 1
d13673 1
d13704 1
a13704 5
#ifdef HAS_TIMES
    PL_timesbuf		= proto_perl->Itimesbuf;
#endif

#if !NO_TAINT_SUPPORT
a13729 1
    PL_regdummy		= proto_perl->Iregdummy;
d13762 2
d13791 3
a13793 3
    PL_envgv		= gv_dup(proto_perl->Ienvgv, param);
    PL_incgv		= gv_dup(proto_perl->Iincgv, param);
    PL_hintgv		= gv_dup(proto_perl->Ihintgv, param);
d13835 1
a13835 1
    PL_argvgv		= gv_dup(proto_perl->Iargvgv, param);
d13840 1
a13840 1
    PL_replgv		= gv_dup(proto_perl->Ireplgv, param);
d13846 3
a13848 3
    PL_DBgv		= gv_dup(proto_perl->IDBgv, param);
    PL_DBline		= gv_dup(proto_perl->IDBline, param);
    PL_DBsub		= gv_dup(proto_perl->IDBsub, param);
a13956 1
    PL_ASCII		= sv_dup_inc(proto_perl->IASCII, param);
d13958 2
d13962 1
a13962 1
    PL_HasMultiCharFold= sv_dup_inc(proto_perl->IHasMultiCharFold, param);
a13968 2
        PL_Posix_ptrs[i] = sv_dup_inc(proto_perl->IPosix_ptrs[i], param);
        PL_L1Posix_ptrs[i] = sv_dup_inc(proto_perl->IL1Posix_ptrs[i], param);
a13986 3
    PL_ASCII		= sv_dup_inc(proto_perl->IASCII, param);
    PL_AboveLatin1	= sv_dup_inc(proto_perl->IAboveLatin1, param);
    PL_Latin1		= sv_dup_inc(proto_perl->ILatin1, param);
d14069 2
a14070 3
    PL_sortstash	= hv_dup(proto_perl->Isortstash, param);
    PL_firstgv		= gv_dup(proto_perl->Ifirstgv, param);
    PL_secondgv		= gv_dup(proto_perl->Isecondgv, param);
d14091 1
a14091 1
    while(av_len(param->stashes) != -1) {
d14294 1
d14296 1
d14298 4
d14306 1
a14306 1
	PUSHs(sv);
d14329 1
d14662 1
a14662 1
	    svp = av_fetch(av, (I32)obase->op_private, FALSE);
d14667 1
a14667 1
		       NULL, (I32)obase->op_private, FUV_SUBSCRIPT_ARRAY);
d14678 1
a14678 1
		svp = av_fetch(av, (I32)obase->op_private, FALSE);
d14683 1
a14683 1
		    NULL, (I32)obase->op_private, FUV_SUBSCRIPT_ARRAY);
d14747 2
d14750 1
a14750 1
			negate ? - SvIV(cSVOPx_sv(kid)) : SvIV(cSVOPx_sv(kid)),
d15028 2
d15034 1
d15036 3
a15038 1
    else
d15041 2
@


1.18
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a68 2
/* This is a pessimistic view. Scalar must be purely a read-write PV to copy-
   on-write.  */
d134 1
a134 1
		      do_clean_named_io_objs()
d136 4
a139 2
			and try to do the same for all objects indirectly
			referenced by typeglobs too.  Called once from
d185 3
a187 1
#  define FREE_SV_DEBUG_FILE(sv) Safefree((sv)->sv_debug_file)
d280 1
a280 1
    sv->sv_debug_file = PL_curcop ? savepv(CopFILE(PL_curcop)): NULL;
d370 2
a371 2
    register SV* sv;
    register SV* svend;
d415 2
a416 2
	register const SV * const svend = &sva[SvREFCNT(sva)];
	register SV* sv;
d480 1
a480 1
		SvREFCNT_dec(target);
a483 2

    /* XXX Might want to check arrays, etc. */
d508 1
a508 1
	SvREFCNT_dec(obj);
d514 1
a514 1
	SvREFCNT_dec(obj);
d520 1
a520 1
	SvREFCNT_dec(obj);
d526 1
a526 1
	SvREFCNT_dec(obj);
d528 1
a528 1
    SvREFCNT_dec(sv); /* undo the inc above */
d549 1
a549 1
	SvREFCNT_dec(obj);
d551 1
a551 1
    SvREFCNT_dec(sv); /* undo the inc above */
d610 1
a610 1
    SvREFCNT_dec(sv);
d1139 1
a1139 1
Perl_sv_upgrade(pTHX_ register SV *const sv, svtype new_type)
d1164 1
a1164 1
    if (new_type != SVt_PV && SvIsCOW(sv)) {
d1249 1
a1249 1
	if (old_type_details->cant_upgrade)
d1254 1
a1254 1
    if (old_type > new_type)
a1331 5

    case SVt_REGEXP:
	/* This ensures that SvTHINKFIRST(sv) is true, and hence that
	   sv_force_normal_flags(sv) is called.  */
	SvFAKE_on(sv);
d1342 1
d1389 1
a1389 1
	if (new_type == SVt_PVIO) {
d1396 1
d1402 3
a1404 1
	if (old_type < SVt_PV) {
d1439 1
a1439 1
Perl_sv_backoff(pTHX_ register SV *const sv)
d1471 1
a1471 1
Perl_sv_grow(pTHX_ register SV *const sv, register STRLEN newlen)
d1473 1
a1473 1
    register char *s;
d1505 2
d1508 1
d1550 1
a1550 1
Perl_sv_setiv(pTHX_ register SV *const sv, const IV i)
d1593 1
a1593 1
Perl_sv_setiv_mg(pTHX_ register SV *const sv, const IV i)
d1611 1
a1611 1
Perl_sv_setuv(pTHX_ register SV *const sv, const UV u)
d1644 1
a1644 1
Perl_sv_setuv_mg(pTHX_ register SV *const sv, const UV u)
d1662 1
a1662 1
Perl_sv_setnv(pTHX_ register SV *const sv, const NV num)
d1706 1
a1706 1
Perl_sv_setnv_mg(pTHX_ register SV *const sv, const NV num)
d1807 1
a1807 1
    register const char *sbegin;
a1822 2
    SV *const buffer = sv_newmortal();

a1824 2
    gv_efullname3(buffer, gv, "*");

d1828 3
d1832 1
d1923 1
a1923 1
S_sv_2iuv_non_preserve(pTHX_ register SV *const sv
d2071 1
a2071 1
    else if (SvPOKp(sv) && SvLEN(sv)) {
d2258 1
a2258 1
Perl_sv_2iv_flags(pTHX_ register SV *const sv, const I32 flags)
d2261 1
d2264 18
a2281 1
    if (SvGMAGICAL(sv) || SvVALID(sv)) {
d2287 2
d2290 2
a2291 8
	if (flags & SV_GMAGIC)
	    mg_get(sv);
	if (SvIOKp(sv))
	    return SvIVX(sv);
	if (SvNOKp(sv)) {
	    return I_V(SvNVX(sv));
	}
	if (SvPOKp(sv) && SvLEN(sv)) {
d2293 2
d2296 1
a2296 1
		= grok_number(SvPVX_const(sv), SvCUR(sv), &value);
d2313 1
a2313 20
	    return I_V(Atof(SvPVX_const(sv)));
	}
        if (SvROK(sv)) {
	    goto return_rok;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit inside S_sv_2iuv_common.  */
    } else if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	return_rok:
	    if (SvAMAGIC(sv)) {
		SV * tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return 0;
		tmpstr = AMG_CALLunary(sv, numer_amg);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvIV(tmpstr);
		}
	    }
	    return PTR2IV(SvRV(sv));
d2315 4
d2322 1
d2329 1
d2334 1
d2351 1
a2351 1
Perl_sv_2uv_flags(pTHX_ register SV *const sv, const I32 flags)
d2354 1
d2357 18
a2374 1
    if (SvGMAGICAL(sv) || SvVALID(sv)) {
d2376 4
a2379 8
	   the same flag bit as SVf_IVisUV, so must not let them cache IVs.  */
	if (flags & SV_GMAGIC)
	    mg_get(sv);
	if (SvIOKp(sv))
	    return SvUVX(sv);
	if (SvNOKp(sv))
	    return U_V(SvNVX(sv));
	if (SvPOKp(sv) && SvLEN(sv)) {
d2381 2
d2384 1
a2384 1
		= grok_number(SvPVX_const(sv), SvCUR(sv), &value);
d2396 1
a2396 20
	    return U_V(Atof(SvPVX_const(sv)));
	}
        if (SvROK(sv)) {
	    goto return_rok;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit inside S_sv_2iuv_common.  */
    } else if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	return_rok:
	    if (SvAMAGIC(sv)) {
		SV *tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return 0;
		tmpstr = AMG_CALLunary(sv, numer_amg);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvUV(tmpstr);
		}
	    }
	    return PTR2UV(SvRV(sv));
d2398 4
d2405 1
d2412 1
d2434 1
a2434 1
Perl_sv_2nv_flags(pTHX_ register SV *const sv, const I32 flags)
d2439 1
a2439 1
    if (SvGMAGICAL(sv) || SvVALID(sv)) {
d2441 3
a2443 1
	   the same flag bit as SVf_IVisUV, so must not let them cache NVs.  */
d2448 3
a2450 1
	if ((SvPOKp(sv) && SvLEN(sv)) && !SvIOKp(sv)) {
d2452 1
a2452 1
		!grok_number(SvPVX_const(sv), SvCUR(sv), NULL))
d2454 1
a2454 1
	    return Atof(SvPVX_const(sv));
d2465 4
d2486 1
d2490 1
d2540 1
a2540 1
    else if (SvPOKp(sv) && SvLEN(sv)) {
d2673 1
a2673 1
Perl_sv_2num(pTHX_ register SV *const sv)
d2734 1
a2734 1
Perl_sv_2pv_flags(pTHX_ register SV *const sv, STRLEN *const lp, const I32 flags)
d2737 1
a2737 1
    register char *s;
d2744 13
a2756 15
    if (SvGMAGICAL(sv)) {
	if (flags & SV_GMAGIC)
	    mg_get(sv);
	if (SvPOKp(sv)) {
	    if (lp)
		*lp = SvCUR(sv);
	    if (flags & SV_MUTABLE_RETURN)
		return SvPVX_mutable(sv);
	    if (flags & SV_CONST_RETURN)
		return (char *)SvPVX_const(sv);
	    return SvPVX(sv);
	}
	if (SvIOKp(sv) || SvNOKp(sv)) {
	    char tbuf[64];  /* Must fit sprintf/Gconvert of longest IV/NV */
	    STRLEN len;
d2758 4
a2761 55
	    if (SvIOKp(sv)) {
		len = SvIsUV(sv)
		    ? my_snprintf(tbuf, sizeof(tbuf), "%"UVuf, (UV)SvUVX(sv))
		    : my_snprintf(tbuf, sizeof(tbuf), "%"IVdf, (IV)SvIVX(sv));
	    } else if(SvNVX(sv) == 0.0) {
		    tbuf[0] = '0';
		    tbuf[1] = 0;
		    len = 1;
	    } else {
		Gconvert(SvNVX(sv), NV_DIG, 0, tbuf);
		len = strlen(tbuf);
	    }
	    assert(!SvROK(sv));
	    {
		dVAR;

		SvUPGRADE(sv, SVt_PV);
		if (lp)
		    *lp = len;
		s = SvGROW_mutable(sv, len + 1);
		SvCUR_set(sv, len);
		SvPOKp_on(sv);
		return (char*)memcpy(s, tbuf, len + 1);
	    }
	}
        if (SvROK(sv)) {
	    goto return_rok;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit near the end of the
	   function. */
    } else if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	return_rok:
            if (SvAMAGIC(sv)) {
		SV *tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return NULL;
		tmpstr = AMG_CALLunary(sv, string_amg);
		TAINT_IF(tmpstr && SvTAINTED(tmpstr));
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    /* Unwrap this:  */
		    /* char *pv = lp ? SvPV(tmpstr, *lp) : SvPV_nolen(tmpstr);
		     */

		    char *pv;
		    if ((SvFLAGS(tmpstr) & (SVf_POK)) == SVf_POK) {
			if (flags & SV_CONST_RETURN) {
			    pv = (char *) SvPVX_const(tmpstr);
			} else {
			    pv = (flags & SV_MUTABLE_RETURN)
				? SvPVX_mutable(tmpstr) : SvPVX(tmpstr);
			}
			if (lp)
			    *lp = SvCUR(tmpstr);
d2763 2
a2764 1
			pv = sv_2pv_flags(tmpstr, lp, flags);
d2766 4
a2769 5
		    if (SvUTF8(tmpstr))
			SvUTF8_on(sv);
		    else
			SvUTF8_off(sv);
		    return pv;
d2771 5
d2777 14
a2790 15
	    {
		STRLEN len;
		char *retval;
		char *buffer;
		SV *const referent = SvRV(sv);

		if (!referent) {
		    len = 7;
		    retval = buffer = savepvn("NULLREF", len);
		} else if (SvTYPE(referent) == SVt_REGEXP && (
			      !(PL_curcop->cop_hints & HINT_NO_AMAGIC)
			   || amagic_is_enabled(string_amg)
			  )) {
		    REGEXP * const re = (REGEXP *)MUTABLE_PTR(referent);
		    I32 seen_evals = 0;
d2792 1
a2792 1
		    assert(re);
d2794 6
a2799 6
		    /* If the regex is UTF-8 we want the containing scalar to
		       have an UTF-8 flag too */
		    if (RX_UTF8(re))
			SvUTF8_on(sv);
		    else
			SvUTF8_off(sv);	
d2801 18
a2818 2
		    if ((seen_evals = RX_SEEN_EVALS(re)))
			PL_reginterp_cnt += seen_evals;
d2820 2
a2821 24
		    if (lp)
			*lp = RX_WRAPLEN(re);
 
		    return RX_WRAPPED(re);
		} else {
		    const char *const typestr = sv_reftype(referent, 0);
		    const STRLEN typelen = strlen(typestr);
		    UV addr = PTR2UV(referent);
		    const char *stashname = NULL;
		    STRLEN stashnamelen = 0; /* hush, gcc */
		    const char *buffer_end;

		    if (SvOBJECT(referent)) {
			const HEK *const name = HvNAME_HEK(SvSTASH(referent));

			if (name) {
			    stashname = HEK_KEY(name);
			    stashnamelen = HEK_LEN(name);

			    if (HEK_UTF8(name)) {
				SvUTF8_on(sv);
			    } else {
				SvUTF8_off(sv);
			    }
d2823 1
a2823 2
			    stashname = "__ANON__";
			    stashnamelen = 8;
a2824 2
			len = stashnamelen + 1 /* = */ + typelen + 3 /* (0x */
			    + 2 * sizeof(UV) + 2 /* )\0 */;
d2826 2
a2827 2
			len = typelen + 3 /* (0x */
			    + 2 * sizeof(UV) + 2 /* )\0 */;
d2829 6
d2836 2
a2837 2
		    Newx(buffer, len, char);
		    buffer_end = retval = buffer + len;
d2839 21
a2859 21
		    /* Working backwards  */
		    *--retval = '\0';
		    *--retval = ')';
		    do {
			*--retval = PL_hexdigit[addr & 15];
		    } while (addr >>= 4);
		    *--retval = 'x';
		    *--retval = '0';
		    *--retval = '(';

		    retval -= typelen;
		    memcpy(retval, typestr, typelen);

		    if (stashname) {
			*--retval = '=';
			retval -= stashnamelen;
			memcpy(retval, stashname, stashnamelen);
		    }
		    /* retval may not necessarily have reached the start of the
		       buffer here.  */
		    assert (retval >= buffer);
d2861 1
a2861 6
		    len = buffer_end - retval - 1; /* -1 for that \0  */
		}
		if (lp)
		    *lp = len;
		SAVEFREEPV(buffer);
		return retval;
a2862 2
	}
	if (SvREADONLY(sv) && !SvOK(sv)) {
d2864 3
a2866 6
		*lp = 0;
	    if (flags & SV_UNDEF_RETURNS_NULL)
		return NULL;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	    return (char *)"";
d2869 12
a2880 1
    if (SvIOK(sv) || ((SvIOKp(sv) && !SvNOKp(sv)))) {
d2898 1
a2898 1
    else if (SvNOKp(sv)) {
d2919 3
a2921 4
    else {
	if (isGV_with_GP(sv)) {
	    GV *const gv = MUTABLE_GV(sv);
	    SV *const buffer = sv_newmortal();
d2923 1
a2923 9
	    gv_efullname3(buffer, gv, "*");

	    assert(SvPOK(buffer));
	    if (lp) {
		    *lp = SvCUR(buffer);
	    }
            if ( SvUTF8(buffer) ) SvUTF8_on(sv);
	    return SvPVX(buffer);
	}
d2925 12
d2943 2
a2944 2
	if (SvTYPE(sv) < SVt_PV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
d2948 1
d2976 9
d2989 9
a2997 1
Perl_sv_copypv(pTHX_ SV *const dsv, register SV *const ssv)
d3000 1
a3000 1
    const char * const s = SvPV_const(ssv,len);
d3002 1
a3002 1
    PERL_ARGS_ASSERT_SV_COPYPV;
d3004 3
d3027 1
a3027 1
Perl_sv_2pvbyte(pTHX_ register SV *sv, STRLEN *const lp)
d3031 2
a3032 1
    if ((SvTHINKFIRST(sv) && !SvIsCOW(sv)) || isGV_with_GP(sv)) {
d3054 1
a3054 1
Perl_sv_2pvutf8(pTHX_ register SV *sv, STRLEN *const lp)
d3058 2
a3059 1
    if ((SvTHINKFIRST(sv) && !SvIsCOW(sv)) || isGV_with_GP(sv))
d3061 3
a3063 3
    sv_utf8_upgrade(sv);
    if (SvGMAGICAL(sv)) SvFLAGS(sv) &= ~SVf_POK;
    assert(SvPOKp(sv));
d3086 1
a3086 1
Perl_sv_2bool_flags(pTHX_ register SV *const sv, const I32 flags)
d3104 1
a3104 24
    if (SvPOKp(sv)) {
	register XPV* const Xpvtmp = (XPV*)SvANY(sv);
	if (Xpvtmp &&
		(*sv->sv_u.svu_pv > '0' ||
		Xpvtmp->xpv_cur > 1 ||
		(Xpvtmp->xpv_cur && *sv->sv_u.svu_pv != '0')))
	    return 1;
	else
	    return 0;
    }
    else {
	if (SvIOKp(sv))
	    return SvIVX(sv) != 0;
	else {
	    if (SvNOKp(sv))
		return SvNVX(sv) != 0.0;
	    else {
		if (isGV_with_GP(sv))
		    return TRUE;
		else
		    return FALSE;
	    }
	}
    }
d3117 1
a3117 1
This is not as a general purpose byte encoding to Unicode interface:
d3136 1
a3136 1
This is not as a general purpose byte encoding to Unicode interface:
d3173 1
a3173 1
Perl_sv_utf8_upgrade_flags_grow(pTHX_ register SV *const sv, const I32 flags, STRLEN extra)
d3181 1
a3181 1
    if (!SvPOK(sv)) {
d3439 1
a3439 1
This is not as a general purpose Unicode to byte encoding interface:
d3446 1
a3446 1
Perl_sv_utf8_downgrade(pTHX_ register SV *const sv, const bool fail_ok)
d3506 1
a3506 1
Perl_sv_utf8_encode(pTHX_ register SV *const sv)
d3530 1
a3530 1
Perl_sv_utf8_decode(pTHX_ register SV *const sv)
a3678 1
         && GvAV((const GV *)sstr)
d3713 1
d3725 2
a3726 1
	mro_isa_changed_in(GvSTASH(dstr));
d3743 2
a3744 2
    SV * const sref = SvREFCNT_inc(SvRV(sstr));
    SV *dref = NULL;
d3790 18
a3807 1
	    SAVEGENERICSV(*location);
d3809 1
a3809 2
	else
	    dref = *location;
d3843 1
a3843 1
	    if(GvSTASH(dstr)) mro_method_changed_in(GvSTASH(dstr)); /* sub foo { 1 } sub bar { 2 } *bar = \&foo */
d3845 1
a3845 1
	*location = sref;
d3916 8
d3926 1
a3926 1
    SvREFCNT_dec(dref);
d3932 13
d3946 1
a3946 1
Perl_sv_setsv_flags(pTHX_ SV *dstr, register SV* sstr, const I32 flags)
d3949 3
a3951 3
    register U32 sflags;
    register int dtype;
    register svtype stype;
a3971 7
    (void)SvAMAGIC_off(dstr);
    if ( SvVOK(dstr) )
    {
	/* need to nuke the magic */
	sv_unmagic(dstr, PERL_MAGIC_vstring);
    }

a4038 9
    case SVt_PVFM:
#ifdef PERL_OLD_COPY_ON_WRITE
	if ((SvFLAGS(sstr) & CAN_COW_MASK) == CAN_COW_FLAGS) {
	    if (dtype < SVt_PVIV)
		sv_upgrade(dstr, SVt_PVIV);
	    break;
	}
	/* Fall through */
#endif
d4063 1
d4065 7
d4073 1
d4090 2
d4093 1
d4103 1
a4103 1
    if (dtype == SVt_PVCV || dtype == SVt_PVFM) {
d4118 2
a4119 1
    } else if (dtype == SVt_PVAV || dtype == SVt_PVHV) {
d4204 2
a4205 1
    else if (dtype == SVt_REGEXP && stype == SVt_REGEXP) {
d4210 2
d4234 8
a4241 1
	       ? (sflags & (SVf_FAKE|SVf_READONLY)) != (SVf_FAKE|SVf_READONLY)
d4247 1
a4247 1
#ifndef PERL_OLD_COPY_ON_WRITE
d4257 1
a4257 1
	     || (SvFLAGS(dstr) & CAN_COW_MASK) != CAN_COW_FLAGS
d4262 4
d4267 1
d4272 2
a4273 2
                 SvLEN(sstr))             /* and really is a string */
#ifdef PERL_OLD_COPY_ON_WRITE
d4276 1
d4278 8
a4285 1
		     && SvTYPE(sstr) >= SVt_PVIV && SvTYPE(sstr) != SVt_PVFM))
d4291 3
a4293 4
	    STRLEN len = SvCUR(sstr);
            SvGROW(dstr, len + 1);	/* inlined from sv_setpvn */
            Move(SvPVX_const(sstr),SvPVX(dstr),len,char);
            SvCUR_set(dstr, len);
d4305 1
a4305 1
#ifdef PERL_OLD_COPY_ON_WRITE
d4307 3
a4309 4
                if ((sflags & (SVf_FAKE | SVf_READONLY))
                    != (SVf_FAKE | SVf_READONLY)) {
                    SvREADONLY_on(sstr);
                    SvFAKE_on(sstr);
d4313 3
d4326 1
a4326 3
                STRLEN cur = SvCUR(sstr);
                STRLEN len = SvLEN(sstr);
#ifdef PERL_OLD_COPY_ON_WRITE
d4328 1
d4334 3
d4351 1
a4351 2
                SvREADONLY_on(dstr);
                SvFAKE_on(dstr);
d4418 1
a4418 1
Perl_sv_setsv_mg(pTHX_ SV *const dstr, register SV *const sstr)
d4426 6
a4431 1
#ifdef PERL_OLD_COPY_ON_WRITE
d4437 1
a4437 1
    register char *new_pv;
d4453 1
a4453 1
	    Safefree(SvPVX_const(dstr));
d4457 1
a4457 1
    SvUPGRADE(dstr, SVt_PVIV);
d4461 1
d4466 1
d4477 1
d4479 4
d4485 2
a4486 3
	SvUPGRADE(sstr, SVt_PVIV);
	SvREADONLY_on(sstr);
	SvFAKE_on(sstr);
d4489 1
d4491 3
d4495 1
d4497 3
d4504 1
a4504 1
    SvFLAGS(dstr) = (SVt_PVIV|SVf_POK|SVp_POK|SVf_FAKE|SVf_READONLY);
d4527 1
a4527 1
Perl_sv_setpvn(pTHX_ register SV *const sv, register const char *const ptr, register const STRLEN len)
d4530 1
a4530 1
    register char *dptr;
d4566 1
a4566 1
Perl_sv_setpvn_mg(pTHX_ register SV *const sv, register const char *const ptr, register const STRLEN len)
d4584 1
a4584 1
Perl_sv_setpv(pTHX_ register SV *const sv, register const char *const ptr)
d4587 1
a4587 1
    register STRLEN len;
d4616 1
a4616 1
Perl_sv_setpv_mg(pTHX_ register SV *const sv, register const char *const ptr)
d4625 1
a4625 1
Perl_sv_sethek(pTHX_ register SV *const sv, const HEK *const hek)
d4646 1
a4646 1
	} else if (flags & (HVhek_REHASH|HVhek_UNSHARED)) {
d4656 1
d4660 1
a4660 2
	    SvREADONLY_on(sv);
	    SvFAKE_on(sv);
d4762 1
a4762 1
S_sv_release_COW(pTHX_ register SV *sv, const char *pvx, SV *after)
d4774 1
a4774 2
            SvFAKE_off(after);
            SvREADONLY_off(after);
d4795 2
a4796 1
Undo various types of fakery on an SV: if the PV is a shared string, make
d4799 2
a4800 1
we do the copy, and is also used locally.  If C<SV_COW_DROP_PV> is set
d4812 1
a4812 1
Perl_sv_force_normal_flags(pTHX_ register SV *const sv, const U32 flags)
d4818 1
a4818 1
#ifdef PERL_OLD_COPY_ON_WRITE
d4820 13
a4832 8
	if (SvFAKE(sv)) {
	    const char * const pvx = SvPVX_const(sv);
	    const STRLEN len = SvLEN(sv);
	    const STRLEN cur = SvCUR(sv);
	    /* next COW sv in the loop.  If len is 0 then this is a shared-hash
	       key scalar, so we mustn't attempt to call SV_COW_NEXT_SV(), as
	       we'll fail an assertion.  */
	    SV * const next = len ? SV_COW_NEXT_SV(sv) : 0;
d4834 1
a4834 1
            if (DEBUG_C_TEST) {
d4839 10
a4848 3
            }
            SvFAKE_off(sv);
            SvREADONLY_off(sv);
d4850 4
d4866 1
d4868 1
a4875 2
	else if (IN_PERL_RUNTIME)
	    Perl_croak_no_modify(aTHX);
d4879 4
d4886 1
a4886 2
	    SvFAKE_off(sv);
	    SvREADONLY_off(sv);
a4898 3
	else if (IN_PERL_RUNTIME)
	    Perl_croak_no_modify(aTHX);
    }
d4904 1
a4904 1
    else if (SvFAKE(sv) && SvTYPE(sv) == SVt_REGEXP) {
d4907 3
a4909 1
	const svtype new_type = SvMAGIC(sv) || SvSTASH(sv) ? SVt_PVMG : SVt_PV;
d4911 1
a4911 1
	void *const temp_p = SvANY(sv);
d4919 16
a4934 12
	SvCUR_set(temp, SvCUR(sv));
	/* Remember that SvPVX is in the head, not the body. */
	if (SvLEN(temp)) {
	    SvLEN_set(temp, SvLEN(sv));
	    /* This signals "buffer is owned by someone else" in sv_clear,
	       which is the least effort way to stop it freeing the buffer.
	    */
	    SvLEN_set(sv, SvLEN(sv)+1);
	} else {
	    /* Their buffer is already owned by someone else. */
	    SvPVX(sv) = savepvn(SvPVX(sv), SvCUR(sv));
	    SvLEN_set(temp, SvCUR(sv)+1);
d4939 6
a4944 3
	SvFLAGS(sv) &= ~(SVf_FAKE|SVTYPEMASK);
	SvFLAGS(sv) |= new_type;
	SvANY(sv) = SvANY(temp);
d4949 1
d4951 1
a4951 1
	SvREFCNT_dec(temp);
d4953 1
d4960 4
a4963 3
SvPOK(sv) must be true and the C<ptr> must be a pointer to somewhere inside
the string buffer.  The C<ptr> becomes the first character of the adjusted
string.  Uses the "OOK hack".
d4976 1
a4976 1
Perl_sv_chop(pTHX_ register SV *const sv, register const char *const ptr)
d5002 1
d5076 1
a5076 1
Perl_sv_catpvn_flags(pTHX_ register SV *const dsv, register const char *sstr, register const STRLEN slen, const I32 flags)
d5130 4
a5133 3
Concatenates the string from SV C<ssv> onto the end of the string in
SV C<dsv>.  Modifies C<dsv> but not C<ssv>.  Handles 'get' magic, but
not 'set' magic.  See C<sv_catsv_mg>.
d5137 6
a5142 6
Concatenates the string from SV C<ssv> onto the end of the string in
SV C<dsv>.  Modifies C<dsv> but not C<ssv>.  If C<flags> has C<SV_GMAGIC>
bit set, will C<mg_get> on the C<ssv>, if appropriate, before
reading it.  If the C<flags> contain C<SV_SMAGIC>, C<mg_set> will be
called on the modified SV afterward, if appropriate.  C<sv_catsv>
and C<sv_catsv_nomg> are implemented in terms of this function.
d5147 1
a5147 1
Perl_sv_catsv_flags(pTHX_ SV *const dsv, register SV *const ssv, const I32 flags)
d5153 1
a5153 1
   if (ssv) {
d5157 2
a5158 2
	    if (SvGMAGICAL(dsv) && (flags & SV_GMAGIC))
		mg_get(dsv);
d5161 3
a5163 1
	}
a5164 2
    if (flags & SV_SMAGIC)
	SvSETMAGIC(dsv);
d5177 1
a5177 1
Perl_sv_catpv(pTHX_ register SV *const sv, register const char *ptr)
d5180 1
a5180 1
    register STRLEN len;
d5226 1
a5226 1
Perl_sv_catpv_mg(pTHX_ register SV *const sv, register const char *const ptr)
d5255 1
a5255 1
    register SV *sv;
a5351 2
    if (SvGMAGICAL(sv))
	SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
d5372 1
a5372 1
Perl_sv_magic(pTHX_ register SV *const sv, SV *const obj, const int how, 
d5397 1
a5397 1
#ifdef PERL_OLD_COPY_ON_WRITE
d5410 1
a5410 1
	    Perl_croak_no_modify(aTHX);
d5418 1
a5418 1
	    if (how == PERL_MAGIC_taint) {
a5419 5
		/* Any scalar which already had taint magic on which someone
		   (erroneously?) did SvIOK_on() or similar will now be
		   incorrectly sporting public "OK" flags.  */
		SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
	    }
d5542 1
a5542 1
    SvREFCNT_dec(tsv);
d5765 1
a5765 1
    /* after multiple passes through Perl_sv_clean_all() for a thinngy
d5838 1
a5838 1
	SvREFCNT_dec(av); /* remove extra count added by sv_add_backref() */
d5861 5
a5865 5
    register char *big;
    register char *mid;
    register char *midend;
    register char *bigend;
    register SSize_t i;		/* better be sizeof(STRLEN) or bad things happen */
d5956 1
a5956 1
Perl_sv_replace(pTHX_ register SV *const sv, register SV *const nsv)
d6041 1
d6045 1
a6045 1
	SvANY(cv)->xcv_gv = NULL;
d6055 1
a6055 1
    SvREFCNT_dec(gvname);
d6059 1
a6059 1
    SvANY(cv)->xcv_gv = MUTABLE_GV(SvREFCNT_inc(anongv));
d6086 1
a6086 1
    register SV *sv = orig_sv;
d6160 1
d6183 3
a6185 1
		    if (PL_stashcache)
d6188 1
d6237 1
d6260 2
d6285 1
a6285 1
#ifdef PERL_OLD_COPY_ON_WRITE
d6296 1
d6298 6
d6308 6
a6313 3
		    SvFAKE_off(sv);
		} else if (SvLEN(sv)) {
		    Safefree(SvPVX_const(sv));
a6322 1
		SvFAKE_off(sv);
d6384 4
d6414 1
a6414 1
	    if (SvREADONLY(sv) && SvIMMORTAL(sv)) {
d6416 1
a6416 1
		SvREFCNT(sv) = (~(U32)0)/2;
d6441 23
a6463 4
	    CV* destructor;
	    stash = SvSTASH(sv);
	    destructor = StashHANDLER(stash,DESTROY);
	    if (destructor
d6500 1
a6500 1
		SvREFCNT_dec(tmpref);
d6502 1
d6517 3
a6519 1
	SvREFCNT_dec(SvSTASH(sv)); /* possibly of changed persuasion */
d6521 2
a6522 2
	if (SvTYPE(sv) != SVt_PVIO)
	    --PL_sv_objcount;/* XXX Might want something more general */
d6559 1
a6559 43
    dVAR;
    if (!sv)
	return;
    if (SvREFCNT(sv) == 0) {
	if (SvFLAGS(sv) & SVf_BREAK)
	    /* this SV's refcnt has been artificially decremented to
	     * trigger cleanup */
	    return;
	if (PL_in_clean_all) /* All is fair */
	    return;
	if (SvREADONLY(sv) && SvIMMORTAL(sv)) {
	    /* make sure SvREFCNT(sv)==0 happens very seldom */
	    SvREFCNT(sv) = (~(U32)0)/2;
	    return;
	}
	if (ckWARN_d(WARN_INTERNAL)) {
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
	    Perl_dump_sv_child(aTHX_ sv);
#else
  #ifdef DEBUG_LEAKING_SCALARS
	    sv_dump(sv);
  #endif
#ifdef DEBUG_LEAKING_SCALARS_ABORT
	    if (PL_warnhook == PERL_WARNHOOK_FATAL
		|| ckDEAD(packWARN(WARN_INTERNAL))) {
		/* Don't let Perl_warner cause us to escape our fate:  */
		abort();
	    }
#endif
	    /* This may not return:  */
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                        "Attempt to free unreferenced scalar: SV 0x%"UVxf
                        pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
#endif
	}
#ifdef DEBUG_LEAKING_SCALARS_ABORT
	abort();
#endif
	return;
    }
    if (--(SvREFCNT(sv)) > 0)
	return;
    Perl_sv_free2(aTHX_ sv);
d6562 4
d6567 1
a6567 1
Perl_sv_free2(pTHX_ SV *const sv)
d6573 4
d6578 32
a6609 5
    if (SvTEMP(sv)) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING),
			 "Attempt to free temp prematurely: SV 0x%"UVxf
			 pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
	return;
d6611 18
a6629 4
    if (SvREADONLY(sv) && SvIMMORTAL(sv)) {
	/* make sure SvREFCNT(sv)==0 happens very seldom */
	SvREFCNT(sv) = (~(U32)0)/2;
	return;
d6631 4
a6634 3
    sv_clear(sv);
    if (! SvREFCNT(sv))
	del_SV(sv);
d6637 1
d6642 2
a6643 1
coercion.  See also C<SvCUR>, which gives raw access to the xpv_cur slot.
d6649 1
a6649 1
Perl_sv_len(pTHX_ register SV *const sv)
d6656 1
a6656 4
    if (SvGMAGICAL(sv))
	len = mg_length(sv);
    else
        (void)SvPV_const(sv, len);
d6679 1
a6679 1
Perl_sv_len_utf8(pTHX_ register SV *const sv)
d6684 12
a6695 6
    if (SvGMAGICAL(sv))
	return mg_length(sv);
    else
    {
	STRLEN len;
	const U8 *s = (U8*)SvPV_const(sv, len);
d6697 1
a6697 1
	if (PL_utf8cache) {
a6722 2
	}
	return Perl_utf8_length(aTHX_ s, s + len);
d6724 1
d6812 1
a6812 1
    if (!SvREADONLY(sv)
d6895 1
a6895 1
    if (PL_utf8cache) {
d6987 1
a6987 1
Perl_sv_pos_u2b(pTHX_ register SV *const sv, I32 *const offsetp, I32 *const lenp)
d7007 1
a7007 1
    if (SvREADONLY(sv))
a7113 1
	const float existing = THREEWAY_SQUARE(0, cache[3], cache[1], blen);
d7122 4
a7125 6
		if (keep_later < existing) {
		    cache[2] = cache[0];
		    cache[3] = cache[1];
		    cache[0] = utf8;
		    cache[1] = byte;
		}
d7128 2
a7129 4
		if (keep_earlier < existing) {
		    cache[0] = utf8;
		    cache[1] = byte;
		}
d7140 2
a7141 4
		if (keep_later < existing) {
		    cache[2] = utf8;
		    cache[3] = byte;
		}
d7144 2
a7145 4
		if (keep_earlier < existing) {
		    cache[0] = utf8;
		    cache[1] = byte;
		}
d7156 2
a7157 4
		if (keep_later < existing) {
		    cache[2] = utf8;
		    cache[3] = byte;
		}
d7160 4
a7163 6
		if (keep_earlier < existing) {
		    cache[0] = cache[2];
		    cache[1] = cache[3];
		    cache[2] = utf8;
		    cache[3] = byte;
		}
d7213 1
a7213 1
Perl_sv_pos_b2u(pTHX_ register SV *const sv, I32 *const offsetp)
d7340 1
a7340 1
Perl_sv_eq_flags(pTHX_ register SV *sv1, register SV *sv2, const U32 flags)
d7389 1
a7389 1
		   SvREFCNT_dec(svrecode);
d7435 1
a7435 1
Perl_sv_cmp(pTHX_ register SV *const sv1, register SV *const sv2)
d7441 1
a7441 1
Perl_sv_cmp_flags(pTHX_ register SV *const sv1, register SV *const sv2,
a7446 1
    char *tpv = NULL;
a7509 2
    if (tpv)
	Safefree(tpv);
d7531 1
a7531 1
Perl_sv_cmp_locale(pTHX_ register SV *const sv1, register SV *const sv2)
d7537 1
a7537 1
Perl_sv_cmp_locale_flags(pTHX_ register SV *const sv1, register SV *const sv2,
d7674 2
a7675 2
    I32 bytesread;
    const U32 recsize = SvUV(SvRV(PL_rs)); /* RsRECORD() guarantees > 0. */
d7677 3
a7679 1
    char *const buffer = SvGROW(sv, (STRLEN)(recsize + append + 1)) + append;
d7681 1
d7683 1
a7683 1
#endif
d7685 6
a7690 7
    /* Go yank in */
#ifdef VMS
    /* VMS wants read instead of fread, because fread doesn't respect */
    /* RMS record boundaries. This is not necessarily a good thing to be */
    /* doing, but we've got no other real choice - except avoid stdio
       as implementation - perhaps write a :vms layer ?
    */
d7692 6
a7697 1
    if (fd != -1) {
d7700 3
a7702 1
    else /* in-memory file from PerlIO::Scalar */
d7706 73
d7792 4
a7795 1
appending to the currently-stored string.
d7801 1
a7801 1
Perl_sv_gets(pTHX_ register SV *const sv, register PerlIO *const fp, I32 append)
d7806 3
a7808 3
    register STDCHAR rslast;
    register STDCHAR *bp;
    register I32 cnt;
a7822 2
    SvSCREAM_off(sv);

d7915 1
a7915 1
    register STDCHAR *ptr;
d8061 1
a8061 1
            register const STDCHAR * const bpe = buf + sizeof(buf);
d8081 1
a8081 1
	     sv_catpvn(sv, (char *) buf, cnt);
d8083 1
a8083 1
	     sv_setpvn(sv, (char *) buf, cnt);
d8134 1
a8134 1
Perl_sv_inc(pTHX_ register SV *const sv)
d8152 1
a8152 1
Perl_sv_inc_nomg(pTHX_ register SV *const sv)
d8155 1
a8155 1
    register char *d;
d8165 1
a8165 1
		Perl_croak_no_modify(aTHX);
d8316 1
a8316 1
Perl_sv_dec(pTHX_ register SV *const sv)
d8335 1
a8335 1
Perl_sv_dec_nomg(pTHX_ register SV *const sv)
d8347 1
a8347 1
		Perl_croak_no_modify(aTHX);
d8474 1
a8474 1
Perl_sv_mortalcopy(pTHX_ SV *const oldstr)
d8477 1
a8477 1
    register SV *sv;
d8479 2
d8482 1
a8482 1
    sv_setsv(sv,oldstr);
d8503 1
a8503 1
    register SV *sv;
d8536 1
a8536 1
    register SV *sv;
d8574 1
a8574 1
Perl_sv_2mortal(pTHX_ register SV *const sv)
d8579 1
a8579 1
    if (SvREADONLY(sv) && SvIMMORTAL(sv))
d8600 1
a8600 1
    register SV *sv;
d8624 1
a8624 1
    register SV *sv;
d8667 2
a8668 7
	} else if (flags & (HVhek_REHASH|HVhek_UNSHARED)) {
	    /* We don't have a pointer to the hv, so we have to replicate the
	       flag into every HEK. This hv is using custom a hasing
	       algorithm. Hence we can't return a shared string scalar, as
	       that would contain the (wrong) hash value, and might get passed
	       into an hv routine with a regular hash.
	       Similarly, a hash that isn't using shared hash keys has to have
d8688 1
a8688 2
	    SvREADONLY_on(sv);
	    SvFAKE_on(sv);
d8702 2
a8703 1
created first.  Turns on READONLY and FAKE.  If the C<hash> parameter
d8717 1
a8717 1
    register SV *sv;
d8737 1
a8737 2
    SvREADONLY_on(sv);
    SvFAKE_on(sv);
d8772 1
a8772 1
    register SV *sv;
d8796 1
a8796 1
    register SV *sv;
d8813 1
a8813 1
    register SV *sv;
d8835 1
a8835 1
    register SV *sv;
d8855 1
a8855 1
    register SV *sv;
d8875 1
a8875 1
    register SV *sv;
d8894 1
a8894 1
    register SV *sv;
d8914 1
a8914 1
    register SV *sv = newSV_type(SVt_IV);
d8948 1
a8948 1
Perl_newSVsv(pTHX_ register SV *const old)
d8951 1
a8951 1
    register SV *sv;
d8959 2
d8962 1
a8962 2
    /* SV_GMAGIC is the default for sv_setv()
       SV_NOSTEAL prevents TEMP buffers being, well, stolen, and saves games
d8964 1
a8964 1
    sv_setsv_flags(sv, old, SV_GMAGIC | SV_NOSTEAL);
d8978 9
a8986 1
Perl_sv_reset(pTHX_ register const char *s, HV *const stash)
d8990 1
a8990 2

    PERL_ARGS_ASSERT_SV_RESET;
d8995 1
a8995 1
    if (!*s) {		/* reset ?? searches */
d9020 2
a9021 1
    while (*s) {
d9037 2
a9038 2
		register GV *gv;
		register SV *sv;
a9209 4
	    SV *tmpsv;
	    ENTER;
	    tmpsv = newSV(0);
	    gv_efullname3(tmpsv, gv, NULL);
d9213 1
a9213 7
	    newSUB(start_subparse(FALSE, 0),
		   newSVOP(OP_CONST, 0, tmpsv),
		   NULL, NULL);
	    LEAVE;
	    if (!GvCVu(gv))
		Perl_croak(aTHX_ "Unable to create sub named \"%"SVf"\"",
			   SVfARG(SvOK(sv) ? sv : &PL_sv_no));
d9230 1
a9230 1
Perl_sv_true(pTHX_ register SV *const sv)
d9235 1
a9235 1
	register const XPV* const tXpv = (XPV*)SvANY(sv);
d9301 1
a9301 1
	if ((SvTYPE(sv) > SVt_PVLV && SvTYPE(sv) != SVt_PVFM)
d9307 3
d9329 1
d9367 2
a9368 2
    sv_pvn_force(sv,lp);
    sv_utf8_upgrade(sv);
d9432 1
a9432 1
Perl_sv_ref(pTHX_ register SV *dst, const SV *const sv, const int ob)
d9510 4
a9513 4
Creates a new SV for the RV, C<rv>, to point to.  If C<rv> is not an RV then
it will be upgraded to one.  If C<classname> is non-null then the new SV will
be blessed in the specified package.  The new SV is returned and its
reference count is 1.
a9528 1
    (void)SvAMAGIC_off(rv);
d9699 2
a9700 4
	if (SvIsCOW(tmpRef))
	    sv_force_normal_flags(tmpRef, 0);
	if (SvREADONLY(tmpRef))
	    Perl_croak_no_modify(aTHX);
a9701 2
	    if (SvTYPE(tmpRef) != SVt_PVIO)
		--PL_sv_objcount;
a9705 2
    if (SvTYPE(tmpRef) != SVt_PVIO)
	++PL_sv_objcount;
a9708 5
    if (Gv_AMG(stash))
	SvAMAGIC_on(sv);
    else
	(void)SvAMAGIC_off(sv);

d9807 1
a9807 1
	SvREFCNT_dec(target);
d10149 1
a10149 1
    sv_vcatpvfn(sv, pat, patlen, args, svargs, svmax, maybe_tainted);
d10223 2
d10231 2
a10237 1

d10248 10
d10276 1
a10276 1
    PERL_ARGS_ASSERT_SV_VCATPVFN;
d10279 3
d10283 1
a10283 1
    (void)SvPV_force(sv, origlen);
d10291 1
a10291 1
	    sv_catpv(sv, s ? s : nullstr);
d10294 3
a10296 1
	    sv_catsv(sv, *svargs);
d10305 1
a10305 1
	sv_catsv(sv, argsv);
d10328 1
a10328 1
		    sv_catpv(sv, ebuf);
d10336 1
a10336 1
		    sv_catpvn(sv, p, l);
d10407 1
a10407 1
		sv_catpvn_utf8_upgrade(sv, p, q - p, nsv);
d10409 1
a10409 1
		sv_catpvn(sv, p, q - p);
a10628 1
		    char *version = savesvpv(vecsv);
d10630 1
a10630 1
			Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
d10632 1
a10632 1
			goto unknown;
d10635 2
a10636 1
		    scan_vstring(version, version + veclen, vecsv);
a10638 1
		    Safefree(version);
d10642 1
d10653 1
a10653 1
#  ifdef WIN64
d10664 1
a10664 1
#  ifdef WIN64
d10771 4
a10774 4
			STRLEN ulen = sv_len_utf8(argsv);
			I32 p = precis > ulen ? ulen : precis;
			sv_pos_u2b(argsv, &p, 0); /* sticks at end */
			precis = p;
d10780 2
a10781 1
			    width += elen - sv_len_utf8(argsv);
d11284 1
a11284 1
			    sv_catpvn(msg, f, 1);
d11335 1
a11335 1
	    Perl_croak_nocontext("%s", PL_memory_wrap);
d11341 1
a11341 1
	    Perl_croak_nocontext("%s", PL_memory_wrap);
a11485 1
    parser->pending_ident = proto->pending_ident;
d11588 1
a11588 1
    register const Direntry_t *dirent;
d11980 1
d11998 3
a12000 6
	    if (SvREADONLY(sstr) && SvFAKE(sstr)) {
		/* Not that normal - actually sstr is copy on write.
		   But we are a true, independent SV, so:  */
		SvREADONLY_off(dstr);
		SvFAKE_off(dstr);
	    }
d12007 1
a12007 1
	    else if ((SvREADONLY(sstr) && SvFAKE(sstr))) {
d12105 1
a12105 1
    dstr->sv_debug_file = savepv(sstr->sv_debug_file);
d12193 1
d12207 1
a12207 1
		if (SvSTASH(dstr))
d12209 1
d12223 1
d12225 1
d12236 1
d12386 1
d12411 1
d12416 1
d12418 3
d12423 2
a12424 1
		SvANY(MUTABLE_CV(dstr))->xcv_gv =
a12440 3
    if (SvOBJECT(dstr) && SvTYPE(dstr) != SVt_PVIO)
	++PL_sv_objcount;

d12689 1
d12719 8
a12911 2
		new_state->re_state_reginput
		    = pv_dup(old_state->re_state_reginput);
d12914 1
a12914 23
		new_state->re_state_regoffs
		    = (regexp_paren_pair*)
			any_dup(old_state->re_state_regoffs, proto_perl);
		new_state->re_state_reglastparen
		    = (U32*) any_dup(old_state->re_state_reglastparen, 
			      proto_perl);
		new_state->re_state_reglastcloseparen
		    = (U32*)any_dup(old_state->re_state_reglastcloseparen,
			      proto_perl);
		/* XXX This just has to be broken. The old save_re_context
		   code did SAVEGENERICPV(PL_reg_start_tmp);
		   PL_reg_start_tmp is char **.
		   Look above to what the dup code does for
		   SAVEt_GENERIC_PVREF
		   It can never have worked.
		   So this is merely a faithful copy of the exiting bug:  */
		new_state->re_state_reg_start_tmp
		    = (char **) pv_dup((char *)
				      old_state->re_state_reg_start_tmp);
		/* I assume that it only ever "worked" because no-one called
		   (pseudo)fork while the regexp engine had re-entered itself.
		*/
#ifdef PERL_OLD_COPY_ON_WRITE
d13120 1
d13130 1
a13136 1
    PL_sv_objcount	= 0;
a13141 15
    PL_hash_seed	= proto_perl->Ihash_seed;
    PL_rehash_seed	= proto_perl->Irehash_seed;

    SvANY(&PL_sv_undef)		= NULL;
    SvREFCNT(&PL_sv_undef)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVt_NULL;
    SvREFCNT(&PL_sv_no)		= (~(U32)0)/2;
    SvFLAGS(&PL_sv_no)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;

    SvANY(&PL_sv_yes)		= new_XPVNV();
    SvREFCNT(&PL_sv_yes)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_yes)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;

a13146 5
#ifdef PERL_DEBUG_READONLY_OPS
    PL_slabs = NULL;
    PL_slab_count = 0;
#endif

d13151 1
d13155 4
d13172 1
d13174 1
a13192 1
    PL_reginterp_cnt	= 0;
a13246 2
    PL_amagic_generation	= proto_perl->Iamagic_generation;

a13296 1
    PL_glob_index	= proto_perl->Iglob_index;
d13332 1
d13334 3
d13380 1
a13381 7

    SvANY(&PL_sv_no)		= new_XPVNV();
    SvPV_set(&PL_sv_no, savepvn(PL_No, 0));
    SvCUR_set(&PL_sv_no, 0);
    SvLEN_set(&PL_sv_no, 1);
    SvIV_set(&PL_sv_no, 0);
    SvNV_set(&PL_sv_no, 0);
a13382 6

    SvPV_set(&PL_sv_yes, savepvn(PL_Yes, 1));
    SvCUR_set(&PL_sv_yes, 1);
    SvLEN_set(&PL_sv_yes, 2);
    SvIV_set(&PL_sv_yes, 1);
    SvNV_set(&PL_sv_yes, 1);
d13391 1
a13391 4
    /* These two PVs will be free'd special way so must set them same way op.c does */
    PL_compiling.cop_stashpv = savesharedpv(PL_compiling.cop_stashpv);
    ptr_table_store(PL_ptr_table, proto_perl->Icompiling.cop_stashpv, PL_compiling.cop_stashpv);

a13431 1
    PL_formfeed		= sv_dup(proto_perl->Iformfeed, param);
d13448 9
d13587 2
a13588 44
    PL_PerlSpace	= sv_dup_inc(proto_perl->IPerlSpace, param);
    PL_XPerlSpace	= sv_dup_inc(proto_perl->IXPerlSpace, param);

    PL_L1PosixAlnum	= sv_dup_inc(proto_perl->IL1PosixAlnum, param);
    PL_PosixAlnum	= sv_dup_inc(proto_perl->IPosixAlnum, param);

    PL_L1PosixAlpha	= sv_dup_inc(proto_perl->IL1PosixAlpha, param);
    PL_PosixAlpha	= sv_dup_inc(proto_perl->IPosixAlpha, param);

    PL_PosixBlank	= sv_dup_inc(proto_perl->IPosixBlank, param);
    PL_XPosixBlank	= sv_dup_inc(proto_perl->IXPosixBlank, param);

    PL_L1Cased		= sv_dup_inc(proto_perl->IL1Cased, param);

    PL_PosixCntrl	= sv_dup_inc(proto_perl->IPosixCntrl, param);
    PL_XPosixCntrl	= sv_dup_inc(proto_perl->IXPosixCntrl, param);

    PL_PosixDigit	= sv_dup_inc(proto_perl->IPosixDigit, param);

    PL_L1PosixGraph	= sv_dup_inc(proto_perl->IL1PosixGraph, param);
    PL_PosixGraph	= sv_dup_inc(proto_perl->IPosixGraph, param);

    PL_L1PosixLower	= sv_dup_inc(proto_perl->IL1PosixLower, param);
    PL_PosixLower	= sv_dup_inc(proto_perl->IPosixLower, param);

    PL_L1PosixPrint	= sv_dup_inc(proto_perl->IL1PosixPrint, param);
    PL_PosixPrint	= sv_dup_inc(proto_perl->IPosixPrint, param);

    PL_L1PosixPunct	= sv_dup_inc(proto_perl->IL1PosixPunct, param);
    PL_PosixPunct	= sv_dup_inc(proto_perl->IPosixPunct, param);

    PL_PosixSpace	= sv_dup_inc(proto_perl->IPosixSpace, param);
    PL_XPosixSpace	= sv_dup_inc(proto_perl->IXPosixSpace, param);

    PL_L1PosixUpper	= sv_dup_inc(proto_perl->IL1PosixUpper, param);
    PL_PosixUpper	= sv_dup_inc(proto_perl->IPosixUpper, param);

    PL_L1PosixWord	= sv_dup_inc(proto_perl->IL1PosixWord, param);
    PL_PosixWord	= sv_dup_inc(proto_perl->IPosixWord, param);

    PL_PosixXDigit	= sv_dup_inc(proto_perl->IPosixXDigit, param);
    PL_XPosixXDigit	= sv_dup_inc(proto_perl->IXPosixXDigit, param);

    PL_VertSpace	= sv_dup_inc(proto_perl->IVertSpace, param);
d13591 8
a13598 10
    PL_utf8_alnum	= sv_dup_inc(proto_perl->Iutf8_alnum, param);
    PL_utf8_alpha	= sv_dup_inc(proto_perl->Iutf8_alpha, param);
    PL_utf8_space	= sv_dup_inc(proto_perl->Iutf8_space, param);
    PL_utf8_graph	= sv_dup_inc(proto_perl->Iutf8_graph, param);
    PL_utf8_digit	= sv_dup_inc(proto_perl->Iutf8_digit, param);
    PL_utf8_upper	= sv_dup_inc(proto_perl->Iutf8_upper, param);
    PL_utf8_lower	= sv_dup_inc(proto_perl->Iutf8_lower, param);
    PL_utf8_print	= sv_dup_inc(proto_perl->Iutf8_print, param);
    PL_utf8_punct	= sv_dup_inc(proto_perl->Iutf8_punct, param);
    PL_utf8_xdigit	= sv_dup_inc(proto_perl->Iutf8_xdigit, param);
d13600 1
a13600 1
    PL_utf8_X_begin	= sv_dup_inc(proto_perl->Iutf8_X_begin, param);
a13601 8
    PL_utf8_X_prepend	= sv_dup_inc(proto_perl->Iutf8_X_prepend, param);
    PL_utf8_X_non_hangul	= sv_dup_inc(proto_perl->Iutf8_X_non_hangul, param);
    PL_utf8_X_L	= sv_dup_inc(proto_perl->Iutf8_X_L, param);
    PL_utf8_X_LV	= sv_dup_inc(proto_perl->Iutf8_X_LV, param);
    PL_utf8_X_LVT	= sv_dup_inc(proto_perl->Iutf8_X_LVT, param);
    PL_utf8_X_T	= sv_dup_inc(proto_perl->Iutf8_X_T, param);
    PL_utf8_X_V	= sv_dup_inc(proto_perl->Iutf8_X_V, param);
    PL_utf8_X_LV_LVT_V	= sv_dup_inc(proto_perl->Iutf8_X_LV_LVT_V, param);
d13609 1
d13613 2
a13614 1
    PL_utf8_quotemeta	= sv_dup_inc(proto_perl->Iutf8_quotemeta, param);
a13618 1

d13661 5
d13800 1
a13800 1
    SvREFCNT_dec(unreferenced);
d13864 32
d13931 2
a13932 2
	XPUSHs(encoding);
	XPUSHs(sv);
d14002 3
a14004 3
	XPUSHs(encoding);
	XPUSHs(dsv);
	XPUSHs(ssv);
d14006 2
a14007 2
	mXPUSHs(offsv);
	mXPUSHp(tstr, tlen);
d14040 1
a14040 1
    register HE **array;
d14051 2
a14052 2
    for (i=HvMAX(hv); i>0; i--) {
	register HE *entry;
d14094 1
a14094 1
/* S_varname(): return the name of a variable, optionally with a subscript.
d14130 1
a14130 1
	CV * const cv = gv ? (CV *)gv : find_runcv(NULL);
d14134 1
a14134 1
	assert(!cv || SvTYPE(cv) == SVt_PVCV);
d14138 1
a14138 1
	av = MUTABLE_AV((*av_fetch(CvPADLIST(cv), 0, FALSE)));
d14140 1
a14140 1
	sv_setsv(name, sv);
d14149 1
a14149 1
	SvREFCNT_dec(sv);
d14204 10
a14213 2
	const bool pad  = (obase->op_type == OP_PADAV || obase->op_type == OP_PADHV);
	const bool hash = (obase->op_type == OP_PADHV || obase->op_type == OP_RV2HV);
d14419 3
a14421 1
	if (o->op_type == OP_PUSHMARK)
d14465 4
a14468 1
	if ((obase->op_flags & OPf_STACKED) && o->op_type == OP_PUSHMARK)
d14596 2
d14606 1
d14665 1
a14665 1
 * indent-tabs-mode: t
d14668 1
a14668 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.17
log
@merge in perl 5.12.2 plus local changes
@
text
@d35 9
d83 1
a83 1
In all but the most memory-paranoid configuations (ex: PURIFY), heads
d135 2
a136 1
    sv_clean_objs() / do_clean_objs(),do_clean_named_objs()
d138 1
a138 2
			and, unless DISABLE_DESTRUCTOR_KLUDGE is defined,
			try to do the same for all objects indirectly
d159 1
a159 2
    new_XIV(), del_XIV(),
    new_XNV(), del_XNV(),
a173 20
void
Perl_offer_nice_chunk(pTHX_ void *const chunk, const U32 chunk_size)
{
    dVAR;
    void *new_chunk;
    U32 new_chunk_size;

    PERL_ARGS_ASSERT_OFFER_NICE_CHUNK;

    new_chunk = (void *)(chunk);
    new_chunk_size = (chunk_size);
    if (new_chunk_size > PL_nice_chunk_size) {
	Safefree(PL_nice_chunk);
	PL_nice_chunk = (char *) new_chunk;
	PL_nice_chunk_size = new_chunk_size;
    } else {
	Safefree(chunk);
    }
}

d246 3
a248 11

    if (PL_nice_chunk) {
	sv_add_arena(PL_nice_chunk, PL_nice_chunk_size, 0);
	PL_nice_chunk = NULL;
        PL_nice_chunk_size = 0;
    }
    else {
	char *chunk;                /* must use New here to match call to */
	Newx(chunk,PERL_ARENA_SIZE,char);  /* Safefree() in sv_free_arenas() */
	sv_add_arena(chunk, PERL_ARENA_SIZE, 0);
    }
d277 1
a277 1
    sv->sv_debug_cloned = 0;
d416 1
a416 1
	    if (SvTYPE(sv) != SVTYPEMASK
d435 1
a435 1
    if (SvTYPE(sv) != SVTYPEMASK) {
d445 1
a445 1
Dump the contents of all SVs not yet freed. (Debugging aid).
a485 1
/* called by sv_clean_objs() for each live SV */
d487 3
a489 1
#ifndef DISABLE_DESTRUCTOR_KLUDGE
d494 45
d541 9
a549 16
    if (GvGP(sv)) {
	if ((
#ifdef PERL_DONT_CREATE_GVSV
	     GvSV(sv) &&
#endif
	     SvOBJECT(GvSV(sv))) ||
	     (GvAV(sv) && SvOBJECT(GvAV(sv))) ||
	     (GvHV(sv) && SvOBJECT(GvHV(sv))) ||
	     /* In certain rare cases GvIOp(sv) can be NULL, which would make SvOBJECT(GvIO(sv)) dereference NULL. */
	     (GvIO(sv) ? (SvFLAGS(GvIOp(sv)) & SVs_OBJECT) : 0) ||
	     (GvCV(sv) && SvOBJECT(GvCV(sv))) )
	{
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning named glob object:\n "), sv_dump(sv)));
	    SvFLAGS(sv) |= SVf_BREAK;
	    SvREFCNT_dec(sv);
	}
d551 10
a561 1
#endif
d566 1
a566 1
Attempt to destroy all objects not yet freed
d575 1
d578 3
a580 2
#ifndef DISABLE_DESTRUCTOR_KLUDGE
    /* some barnacles may yet remain, clinging to typeglobs */
d582 13
a594 1
#endif
d617 1
a617 1
cleanup. This function may have to be called multiple times to free
a629 1
    PL_in_clean_all = FALSE;
d673 1
a673 1
Deallocate the memory used by all arenas. Note that all the individual SV
a717 3
    Safefree(PL_nice_chunk);
    PL_nice_chunk = NULL;
    PL_nice_chunk_size = 0;
a729 1
  5. pte arenas (thread related)
a745 61
  HE, HEK arenas are managed separately, with separate code, but may
  be merge-able later..

  PTE arenas are not sv-bodies, but they share these mid-level
  mechanics, so are considered here.  The new mid-level mechanics rely
  on the sv_type of the body being allocated, so we just reserve one
  of the unused body-slots for PTEs, then use it in those (2) PTE
  contexts below (line ~10k)
*/

/* get_arena(size): this creates custom-sized arenas
   TBD: export properly for hv.c: S_more_he().
*/
void*
Perl_get_arena(pTHX_ const size_t arena_size, const svtype bodytype)
{
    dVAR;
    struct arena_desc* adesc;
    struct arena_set *aroot = (struct arena_set*) PL_body_arenas;
    unsigned int curr;

    /* shouldnt need this
    if (!arena_size)	arena_size = PERL_ARENA_SIZE;
    */

    /* may need new arena-set to hold new arena */
    if (!aroot || aroot->curr >= aroot->set_size) {
	struct arena_set *newroot;
	Newxz(newroot, 1, struct arena_set);
	newroot->set_size = ARENAS_PER_SET;
	newroot->next = aroot;
	aroot = newroot;
	PL_body_arenas = (void *) newroot;
	DEBUG_m(PerlIO_printf(Perl_debug_log, "new arenaset %p\n", (void*)aroot));
    }

    /* ok, now have arena-set with at least 1 empty/available arena-desc */
    curr = aroot->curr++;
    adesc = &(aroot->set[curr]);
    assert(!adesc->arena);
    
    Newx(adesc->arena, arena_size, char);
    adesc->size = arena_size;
    adesc->utype = bodytype;
    DEBUG_m(PerlIO_printf(Perl_debug_log, "arena %d added: %p size %"UVuf"\n", 
			  curr, (void*)adesc->arena, (UV)arena_size));

    return adesc->arena;
}


/* return a thing to the free list */

#define del_body(thing, root)			\
    STMT_START {				\
	void ** const thing_copy = (void **)thing;\
	*thing_copy = *root;			\
	*root = (void*)thing_copy;		\
    } STMT_END

/* 
d792 1
a792 1
linked list at PL_body_roots[sv_type], calling S_more_bodies() if
d796 1
a796 1
S_more_bodies calls get_arena(), and carves it up into an array of N
a803 4
*/

/* 

a826 7
PTEs also use arenas, but are never seen in Perl_sv_upgrade. Nonetheless,
they get their own slot in bodies_by_type[PTE_SVSLOT =SVt_IV], so they can
just use the same allocation semantics.  At first, PTEs were also
overloaded to a non-body sv-type, but this yielded hard-to-find malloc
bugs, so was simplified by claiming a new slot.  This choice has no
consequence at this time.

d881 2
a882 2
    { sizeof(HE), 0, 0, SVt_NULL,
      FALSE, NONV, NOARENA, FIT_ARENA(0, sizeof(HE)) },
d889 2
a890 3
    /* IVs are in the head, so the allocation size is 0.
       However, the slot is overloaded for PTEs.  */
    { sizeof(struct ptr_tbl_ent), /* This is used for PTEs.  */
d893 1
a893 3
      NOARENA /* IVS don't need an arena  */,
      /* But PTEs need to know the size of their arena  */
      FIT_ARENA(0, sizeof(struct ptr_tbl_ent))
d896 3
a898 3
    /* 8 bytes on most ILP32 with IEEE doubles */
    { sizeof(NV), sizeof(NV), 0, SVt_NV, FALSE, HADNV, HASARENA,
      FIT_ARENA(0, sizeof(NV)) },
a899 1
    /* 8 bytes on most ILP32 with IEEE doubles */
a905 1
    /* 12 */
d908 1
a908 1
      + STRUCT_OFFSET(XPVIV, xpv_cur),
d910 1
a910 1
      FIT_ARENA(0, sizeof(XPV) - STRUCT_OFFSET(XPV, xpv_cur)) },
d912 5
a916 3
    /* 20 */
    { sizeof(XPVNV), copy_length(XPVNV, xiv_u), 0, SVt_PVNV, FALSE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVNV)) },
d918 1
a918 2
    /* 28 */
    { sizeof(XPVMG), copy_length(XPVMG, xmg_stash), 0, SVt_PVMG, FALSE, HADNV,
d921 3
a923 4
    /* something big */
    { sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur),
      sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur),
      + STRUCT_OFFSET(regexp, xpv_cur),
d925 1
a925 1
      FIT_ARENA(0, sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur))
a927 1
    /* 48 */
a930 1
    /* 64 */
d934 3
a936 3
    { sizeof(XPVAV) - STRUCT_OFFSET(XPVAV, xav_fill),
      copy_length(XPVAV, xmg_stash) - STRUCT_OFFSET(XPVAV, xav_fill),
      + STRUCT_OFFSET(XPVAV, xav_fill),
d938 1
a938 1
      FIT_ARENA(0, sizeof(XPVAV) - STRUCT_OFFSET(XPVAV, xav_fill)) },
d940 3
a942 3
    { sizeof(XPVHV) - STRUCT_OFFSET(XPVHV, xhv_fill),
      copy_length(XPVHV, xmg_stash) - STRUCT_OFFSET(XPVHV, xhv_fill),
      + STRUCT_OFFSET(XPVHV, xhv_fill),
d944 1
a944 1
      FIT_ARENA(0, sizeof(XPVHV) - STRUCT_OFFSET(XPVHV, xhv_fill)) },
d946 3
a948 4
    /* 56 */
    { sizeof(XPVCV) - STRUCT_OFFSET(XPVCV, xpv_cur),
      sizeof(XPVCV) - STRUCT_OFFSET(XPVCV, xpv_cur),
      + STRUCT_OFFSET(XPVCV, xpv_cur),
d950 1
a950 1
      FIT_ARENA(0, sizeof(XPVCV) - STRUCT_OFFSET(XPVCV, xpv_cur)) },
d952 3
a954 3
    { sizeof(XPVFM) - STRUCT_OFFSET(XPVFM, xpv_cur),
      sizeof(XPVFM) - STRUCT_OFFSET(XPVFM, xpv_cur),
      + STRUCT_OFFSET(XPVFM, xpv_cur),
d956 1
a956 1
      FIT_ARENA(20, sizeof(XPVFM) - STRUCT_OFFSET(XPVFM, xpv_cur)) },
d958 3
a960 4
    /* XPVIO is 84 bytes, fits 48x */
    { sizeof(XPVIO) - STRUCT_OFFSET(XPVIO, xpv_cur),
      sizeof(XPVIO) - STRUCT_OFFSET(XPVIO, xpv_cur),
      + STRUCT_OFFSET(XPVIO, xpv_cur),
d962 1
a962 1
      FIT_ARENA(24, sizeof(XPVIO) - STRUCT_OFFSET(XPVIO, xpv_cur)) },
a964 7
#define new_body_type(sv_type)		\
    (void *)((char *)S_new_body(aTHX_ sv_type))

#define del_body_type(p, sv_type)	\
    del_body(p, &PL_body_roots[sv_type])


d969 1
a969 2
#define del_body_allocated(p, sv_type)		\
    del_body(p + bodies_by_type[sv_type].offset, &PL_body_roots[sv_type])
d971 6
a976 4

#define my_safemalloc(s)	(void*)safemalloc(s)
#define my_safecalloc(s)	(void*)safecalloc(s, 1)
#define my_safefree(p)	safefree((char*)p)
d980 3
a982 11
#define new_XNV()	my_safemalloc(sizeof(XPVNV))
#define del_XNV(p)	my_safefree(p)

#define new_XPVNV()	my_safemalloc(sizeof(XPVNV))
#define del_XPVNV(p)	my_safefree(p)

#define new_XPVAV()	my_safemalloc(sizeof(XPVAV))
#define del_XPVAV(p)	my_safefree(p)

#define new_XPVHV()	my_safemalloc(sizeof(XPVHV))
#define del_XPVHV(p)	my_safefree(p)
d984 1
a984 5
#define new_XPVMG()	my_safemalloc(sizeof(XPVMG))
#define del_XPVMG(p)	my_safefree(p)

#define new_XPVGV()	my_safemalloc(sizeof(XPVGV))
#define del_XPVGV(p)	my_safefree(p)
d988 3
a990 11
#define new_XNV()	new_body_type(SVt_NV)
#define del_XNV(p)	del_body_type(p, SVt_NV)

#define new_XPVNV()	new_body_type(SVt_PVNV)
#define del_XPVNV(p)	del_body_type(p, SVt_PVNV)

#define new_XPVAV()	new_body_allocated(SVt_PVAV)
#define del_XPVAV(p)	del_body_allocated(p, SVt_PVAV)

#define new_XPVHV()	new_body_allocated(SVt_PVHV)
#define del_XPVHV(p)	del_body_allocated(p, SVt_PVHV)
d992 2
a993 5
#define new_XPVMG()	new_body_type(SVt_PVMG)
#define del_XPVMG(p)	del_body_type(p, SVt_PVMG)

#define new_XPVGV()	new_body_type(SVt_PVGV)
#define del_XPVGV(p)	del_body_type(p, SVt_PVGV)
d1000 1
a1000 1
	my_safemalloc((details)->body_size + (details)->offset)
d1002 1
a1002 1
	my_safecalloc((details)->body_size + (details)->offset)
d1004 3
a1006 2
STATIC void *
S_more_bodies (pTHX_ const svtype sv_type)
d1010 3
a1012 2
    const struct body_details * const bdp = &bodies_by_type[sv_type];
    const size_t body_size = bdp->body_size;
d1015 1
a1015 1
    const size_t arena_size = Perl_malloc_good_size(bdp->arena_size);
d1031 23
a1053 1
    assert(bdp->arena_size);
d1055 1
a1055 1
    start = (char*) Perl_get_arena(aTHX_ arena_size, sv_type);
d1057 3
a1059 1
    end = start + arena_size - 2 * body_size;
d1061 1
a1061 1
    /* computed count doesnt reflect the 1st slot reservation */
d1066 3
a1068 3
			  (void*)start, (void*)end, (int)arena_size,
			  (int)bdp->arena_size, sv_type, (int)body_size,
			  (int)arena_size / (int)body_size));
d1073 2
a1074 2
			  (int)bdp->arena_size, sv_type, (int)body_size,
			  (int)bdp->arena_size / (int)body_size));
d1078 2
a1079 1
    while (start <= end) {
d1081 9
a1092 3
    *(void **)start = 0;

    return *root;
d1103 3
a1105 1
	  ? *((void **)(r3wt)) : more_bodies(sv_type)); \
d1130 4
a1133 1
You generally want to use the C<SvUPGRADE> macro wrapper. See also C<svtype>.
a1311 7
	    if (old_type_details->body_size) {
		HvFILL(sv) = 0;
	    } else {
		/* It will have been zeroed when the new body was allocated.
		   Lets not write to it, in case it confuses a write-back
		   cache.  */
	    }
d1416 1
a1416 1
    if (old_type > SVt_IV) { /* SVt_IVs are overloaded for PTEs */
d1418 1
a1418 1
	my_safefree(old_body);
d1433 1
a1433 1
Remove any string offset. You should normally use the C<SvOOK_off> macro
d1509 4
d1572 1
d1613 2
a1614 1
    /* With these two if statements:
d1620 3
a1622 1
       If you wish to remove them, please benchmark to see what the effect is
d1685 1
d1687 1
a1687 1
		   OP_NAME(PL_op));
d1728 1
a1728 1
          pv = sv_uni_display(dsv, sv, 10, 0);
d1782 1
d1787 1
d1796 2
a1797 1
non-numeric warning), even if your atof() doesn't grok them.
d1810 2
a1811 3
    if (SvPOK(sv)) {
	sbegin = SvPVX_const(sv);
	len = SvCUR(sv);
a1812 2
    else if (SvPOKp(sv))
	sbegin = SvPV_const(sv, len);
a1820 1
    const U32 wasfake = SvFLAGS(gv) & SVf_FAKE;
a1824 3
    /* FAKE globs can get coerced, so need to turn this off temporarily if it
       is on.  */
    SvFAKE_off(gv);
a1825 1
    SvFLAGS(gv) |= wasfake;
d2232 1
a2232 1
	if (!(SvFLAGS(sv) & SVs_PADTMP)) {
d2261 7
a2267 5
    if (SvGMAGICAL(sv) || (SvTYPE(sv) == SVt_PVGV && SvVALID(sv))) {
	/* FBMs use the same flag bit as SVf_IVisUV, so must let them
	   cache IVs just in case. In practice it seems that they never
	   actually anywhere accessible by user Perl code, let alone get used
	   in anything other than a string context.  */
d2306 4
a2309 1
		SV * const tmpstr=AMG_CALLun(sv,numer);
d2350 3
a2352 3
    if (SvGMAGICAL(sv) || (SvTYPE(sv) == SVt_PVGV && SvVALID(sv))) {
	/* FBMs use the same flag bit as SVf_IVisUV, so must let them
	   cache IVs just in case.  */
d2385 4
a2388 1
		SV *const tmpstr = AMG_CALLun(sv,numer);
d2415 1
a2415 1
=for apidoc sv_2nv
d2418 2
a2419 2
conversion, magic etc. Normally used via the C<SvNV(sv)> and C<SvNVx(sv)>
macros.
d2425 1
a2425 1
Perl_sv_2nv(pTHX_ register SV *const sv)
d2430 5
a2434 4
    if (SvGMAGICAL(sv) || (SvTYPE(sv) == SVt_PVGV && SvVALID(sv))) {
	/* FBMs use the same flag bit as SVf_IVisUV, so must let them
	   cache IVs just in case.  */
	mg_get(sv);
d2459 4
a2462 1
		SV *const tmpstr = AMG_CALLun(sv,numer);
d2617 1
a2617 1
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
d2661 2
a2662 1
	SV * const tmpsv = AMG_CALLun(sv,numer);
d2707 3
a2709 4
If flags includes SV_GMAGIC, does an mg_get() first. Coerces sv to a string
if necessary.
Normally invoked via the C<SvPV_flags> macro. C<sv_2pv()> and C<sv_2pv_nomg>
usually end up here too.
d2745 4
a2756 7
#ifdef FIXNEGATIVEZERO
		if (len == 2 && tbuf[0] == '-' && tbuf[1] == '0') {
		    tbuf[0] = '0';
		    tbuf[1] = 0;
		    len = 1;
		}
#endif
d2776 5
a2780 1
		SV *const tmpstr = AMG_CALLun(sv,string);
d2815 4
a2818 1
		} else if (SvTYPE(referent) == SVt_REGEXP) {
d2890 1
a2890 1
		    /* retval may not neccesarily have reached the start of the
a2930 1
	dSAVE_ERRNO;
d2933 9
a2941 9
	/* The +20 is pure guesswork.  Configure test needed. --jhi */
	s = SvGROW_mutable(sv, NV_DIG + 20);
	/* some Xenix systems wipe out errno here */
#ifdef apollo
	if (SvNVX(sv) == 0.0)
	    my_strlcpy(s, "0", SvLEN(sv));
	else
#endif /*apollo*/
	{
d2943 2
a2945 8
	RESTORE_ERRNO;
#ifdef FIXNEGATIVEZERO
        if (*s == '-' && s[1] == '0' && !s[2]) {
	    s[0] = '0';
	    s[1] = 0;
	}
#endif
	while (*s) s++;
a2953 1
	    const U32 wasfake = SvFLAGS(gv) & SVf_FAKE;
a2955 3
	    /* FAKE globs can get coerced, so need to turn this off temporarily
	       if it is on.  */
	    SvFAKE_off(gv);
a2956 1
	    SvFLAGS(gv) |= wasfake;
d2958 2
a2959 2
	    if (SvPOK(buffer)) {
		if (lp) {
a2960 7
		}
		return SvPVX(buffer);
	    }
	    else {
		if (lp)
		    *lp = 0;
		return (char *)"";
d2962 2
d2970 1
a2970 1
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
d3035 1
a3035 1
Perl_sv_2pvbyte(pTHX_ register SV *const sv, STRLEN *const lp)
d3039 6
d3046 1
a3046 1
    return lp ? SvPV(sv,*lp) : SvPV_nolen(sv);
d3061 1
a3061 1
Perl_sv_2pvutf8(pTHX_ register SV *const sv, STRLEN *const lp)
d3065 2
d3068 3
a3070 1
    return lp ? SvPV(sv,*lp) : SvPV_nolen(sv);
d3077 10
a3086 2
This function is only called on magical items, and is only used by
sv_true() or its macro equivalent.
d3092 1
a3092 1
Perl_sv_2bool(pTHX_ register SV *const sv)
d3096 1
a3096 1
    PERL_ARGS_ASSERT_SV_2BOOL;
d3098 1
a3098 1
    SvGETMAGIC(sv);
d3104 1
a3104 1
	    SV * const tmpsv = AMG_CALLun(sv,bool_);
d3106 1
a3106 1
		return (bool)SvTRUE(tmpsv);
d3151 1
a3151 1
Like sv_utf8_upgrade, but doesn't do magic on C<sv>
d3158 2
a3159 1
if all the bytes are invariant in UTF-8. If C<flags> has C<SV_GMAGIC> bit set,
d3219 1
a3219 1
	    (void) SvPV_force(sv,len);
d3269 1
d3428 23
d3485 1
d3490 17
a3506 1
	    s = (U8 *) SvPV(sv, len);
a3538 3
    if (SvIsCOW(sv)) {
        sv_force_normal_flags(sv, 0);
    }
d3540 1
a3540 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d3551 2
a3552 2
so that it looks like a character. If the PV contains only single-byte
characters, the C<SvUTF8> flag stays being off.
d3564 1
a3564 1
        const U8 *c;
d3576 2
a3577 2
        c = (const U8 *) SvPVX_const(sv);
	if (!is_utf8_string(c, SvCUR(sv)+1))
d3587 16
d3612 1
a3612 1
function if the source SV needs to be reused. Does not handle 'set' magic.
d3624 1
a3624 1
function if the source SV needs to be reused. Does not handle 'set' magic.
d3628 3
a3630 2
C<ssv> if appropriate, else not. If the C<flags> parameter has the
C<NOSTEAL> bit set then the buffers of temps will not be stolen. <sv_setsv>
d3646 2
a3647 1
    I32 mro_changes = 0; /* 1 = method, 2 = isa */
d3651 1
a3651 1
    if (dtype != SVt_PVGV) {
d3663 2
a3664 2
	    /* FIXME - why are we doing this, then turning it off and on again
	       below?  */
d3670 2
a3671 1
	gv_name_set(MUTABLE_GV(dstr), name, len, GV_ADD);
d3679 1
a3679 1
            GvCV(sstr) = NULL;
d3684 3
a3686 1
        else if(GvCV((const GV *)sstr)) {
d3692 4
a3695 1
    if(!mro_changes && GvGP(MUTABLE_GV(dstr)) && GvCVu((const GV *)dstr)) {
d3699 28
a3726 2
    if(strEQ(GvNAME((const GV *)dstr),"ISA"))
        mro_changes = 2;
d3729 1
a3729 1
    isGV_with_GP_off(dstr);
d3733 1
a3733 1
    GvGP(dstr) = gp_ref(GvGP(sstr));
d3742 22
a3763 1
    if(mro_changes == 2) mro_isa_changed_in(GvSTASH(dstr));
d3788 1
a3788 1
	location = (SV **) &GvCV(dstr);
d3814 1
a3814 1
		    GvCV(dstr) = NULL;
d3826 4
a3829 1
		    (CvROOT(cv) || CvXSUB(cv)))
d3831 15
a3845 27
			/* Redefining a sub - warning is mandatory if
			   it was a const and its value changed. */
			if (CvCONST(cv)	&& CvCONST((const CV *)sref)
			    && cv_const_sv(cv)
			    == cv_const_sv((const CV *)sref)) {
			    NOOP;
			    /* They are 2 constant subroutines generated from
			       the same constant. This probably means that
			       they are really the "same" proxy subroutine
			       instantiated in 2 places. Most likely this is
			       when a constant is exported twice.  Don't warn.
			    */
			}
			else if (ckWARN(WARN_REDEFINE)
				 || (CvCONST(cv)
				     && (!CvCONST((const CV *)sref)
					 || sv_cmp(cv_const_sv(cv),
						   cv_const_sv((const CV *)
							       sref))))) {
			    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
					(const char *)
					(CvCONST(cv)
					 ? "Constant subroutine %s::%s redefined"
					 : "Subroutine %s::%s redefined"),
					HvNAME_get(GvSTASH((const GV *)dstr)),
					GvENAME(MUTABLE_GV(dstr)));
			}
d3848 4
a3851 3
		    cv_ckproto_len(cv, (const GV *)dstr,
				   SvPOK(sref) ? SvPVX_const(sref) : NULL,
				   SvPOK(sref) ? SvCUR(sref) : 0);
d3862 65
a3926 3
	if (stype == SVt_PVAV && strEQ(GvNAME((GV*)dstr), "ISA")) {
	    sv_magic(sref, dstr, PERL_MAGIC_isa, NULL, 0);
	    mro_isa_changed_in(GvSTASH(dstr));
d3967 1
a3967 1
	mg_free(dstr);
d3975 1
a3975 1
	if (dtype != SVt_PVGV) {
d3991 1
d4023 1
d4062 2
a4063 1
	    Perl_croak(aTHX_ "Bizarre copy of %s in %s", type, OP_NAME(PL_op));
a4076 7
	if (isGV_with_GP(sstr) && dtype <= SVt_PVGV) {
	    glob_assign_glob(dstr, sstr, dtype);
	    return;
	}
	/* SvVALID means that this PVGV is playing at being an FBM.  */
	/*FALLTHROUGH*/

d4080 1
a4080 1
	    if (SvTYPE(sstr) != stype) {
d4082 2
a4083 1
		if (isGV_with_GP(sstr) && stype == SVt_PVGV && dtype <= SVt_PVGV) {
a4085 2
		}
	    }
d4109 1
d4116 2
a4117 1
	    Perl_croak(aTHX_ "Cannot copy to %s in %s", type, OP_NAME(PL_op));
d4121 1
a4121 1
	if (isGV_with_GP(dstr) && dtype == SVt_PVGV
d4138 1
a4138 1
	    if (dtype == SVt_PVGV && isGV_with_GP(dstr)) {
d4156 1
a4156 1
    else if (dtype == SVt_PVGV && isGV_with_GP(dstr)) {
d4162 1
a4162 1
	    GV *gv = gv_fetchsv(sstr, GV_ADD, SVt_PVGV);
d4164 17
d4183 12
a4194 1
		GvGP(dstr) = gp_ref(GvGP(gv));
d4251 1
a4251 3
                 SvLEN(sstr) 	&&	  /* and really is a string */
	    			/* and won't be needed again, potentially */
	      !(PL_op && PL_op->op_type == OP_AASSIGN))
a4368 7
	    /* This stringification rule for globs is spread in 3 places.
	       This feels bad. FIXME.  */
	    const U32 wasfake = sflags & SVf_FAKE;

	    /* FAKE globs can get coerced, so need to turn this off
	       temporarily if it is on.  */
	    SvFAKE_off(sstr);
a4369 1
	    SvFLAGS(sstr) |= wasfake;
d4493 2
a4494 1
	    Perl_croak(aTHX_ "panic: sv_setpvn called with negative strlen");
d4504 1
d4554 1
d4574 47
d4627 3
a4629 1
by C<malloc>.  The string length, C<len>, must be supplied.  By default
d4635 1
a4635 1
If C<flags> & SV_SMAGIC is true, will call SvSETMAGIC. If C<flags> &
d4637 2
a4638 2
will be skipped. (i.e. the buffer is actually at least 1 byte longer than
C<len>, and already meets the requirements for storing in C<SvPVX>)
d4676 1
a4676 1
	   Specfically Perl_newCONSTSUB is relying on this.  */
d4749 1
a4749 1
we do the copy, and is also used locally. If C<SV_COW_DROP_PV> is set
d4751 4
a4754 3
SvPOK_off rather than making a copy. (Used where this scalar is about to be
set to some other value.) In addition, the C<flags> parameter gets passed to
C<sv_unref_flags()> when unrefing. C<sv_force_normal> calls this function
d4808 1
a4808 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
d4812 1
a4812 1
	if (SvFAKE(sv)) {
d4819 8
a4826 3
	    SvGROW(sv, len + 1);
	    Move(pvx,SvPVX(sv),len,char);
	    *SvEND(sv) = '\0';
d4830 1
a4830 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
d4835 2
a4836 2
    else if (SvFAKE(sv) && SvTYPE(sv) == SVt_PVGV)
	sv_unglob(sv);
d4838 1
a4838 1
	/* Need to downgrade the REGEXP to a simple(r) scalar. This is analagous
d4884 2
a4885 1
string. Uses the "OOK hack".
d4889 4
d4903 2
a4904 1
    const U8 *real_start;
a4916 2
    /* SvPVX(sv) may move in SV_CHECK_THINKFIRST(sv), but after this line,
       nothing uses the value of ptr any more.  */
d4918 1
a4918 1
    if (ptr <= SvPVX_const(sv))
d4921 1
a4922 4
    if (delta > max_delta)
	Perl_croak(aTHX_ "panic: sv_chop ptr=%p (was %p), start=%p, end=%p",
		   SvPVX_const(sv) + delta, ptr, SvPVX_const(sv),
		   SvPVX_const(sv) + max_delta);
d4932 1
a4932 1
	SvFLAGS(sv) |= SVf_OOK;
a4942 2
    delta += old_delta;

d4944 8
a4951 1
    real_start = p - delta;
d4954 1
d4967 1
a4967 1
    while (p > real_start) {
d4987 3
a4989 2
If C<flags> has C<SV_GMAGIC> bit set, will C<mg_get> on C<dsv> if
appropriate, else not. C<sv_catpvn> and C<sv_catpvn_nomg> are implemented
d5003 1
d5005 7
a5011 2
    SvGROW(dsv, dlen + slen + 1);
    if (sstr == dstr)
d5013 27
a5039 2
    Move(sstr, SvPVX(dsv) + dlen, slen, char);
    SvCUR_set(dsv, SvCUR(dsv) + slen);
d5058 3
a5060 1
bit set, will C<mg_get> on the SVs if appropriate, else not. C<sv_catsv>
d5074 1
a5074 1
	const char *spv = SvPV_const(ssv, slen);
a5075 10
	    /*  sutf8 and dutf8 were type bool, but under USE_ITHREADS,
		gcc version 2.95.2 20000220 (Debian GNU/Linux) for
		Linux xxx 2.2.17 on sparc64 with gcc -O2, we erroneously
		get dutf8 = 0x20000000, (i.e.  SVf_UTF8) even though
		dsv->sv_flags doesn't have that bit set.
		Andy Dougherty  12 Oct 2001
	    */
	    const I32 sutf8 = DO_UTF8(ssv);
	    I32 dutf8;

d5078 2
a5079 15
	    dutf8 = DO_UTF8(dsv);

	    if (dutf8 != sutf8) {
		if (dutf8) {
		    /* Not modifying source SV, so taking a temporary copy. */
		    SV* const csv = newSVpvn_flags(spv, slen, SVs_TEMP);

		    sv_utf8_upgrade(csv);
		    spv = SvPV_const(csv, slen);
		}
		else
		    /* Leave enough space for the cat that's about to happen */
		    sv_utf8_upgrade_flags_grow(dsv, 0, slen);
	    }
	    sv_catpvn_nomg(dsv, spv, slen);
d5119 18
d5164 1
a5164 1
L<perlhack/PERL_MEM_LOG>).  The older API is still there for use in XS
d5186 1
a5186 1
Adds magic to an SV, upgrading it if necessary. Applies the
d5261 1
a5261 1
	       HEf_SVKEY. I think we need to document this abberation of the
d5279 3
a5281 2
Adds magic to an SV. First upgrades C<sv> to type C<SVt_PVMG> if necessary,
then adds a new magic item of type C<how> to the head of the magic list.
d5299 2
d5304 14
d5324 2
a5325 3
	    /* its okay to attach magic to shared strings; the subsequent
	     * upgrade to PVMG will unshare the string */
	    !(SvFAKE(sv) && SvTYPE(sv) < SVt_PVMG)
d5328 1
a5328 5
	    && how != PERL_MAGIC_regex_global
	    && how != PERL_MAGIC_bm
	    && how != PERL_MAGIC_fm
	    && how != PERL_MAGIC_sv
	    && how != PERL_MAGIC_backref
d5331 1
a5331 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
a5349 120
    switch (how) {
    case PERL_MAGIC_sv:
	vtable = &PL_vtbl_sv;
	break;
    case PERL_MAGIC_overload:
        vtable = &PL_vtbl_amagic;
        break;
    case PERL_MAGIC_overload_elem:
        vtable = &PL_vtbl_amagicelem;
        break;
    case PERL_MAGIC_overload_table:
        vtable = &PL_vtbl_ovrld;
        break;
    case PERL_MAGIC_bm:
	vtable = &PL_vtbl_bm;
	break;
    case PERL_MAGIC_regdata:
	vtable = &PL_vtbl_regdata;
	break;
    case PERL_MAGIC_regdatum:
	vtable = &PL_vtbl_regdatum;
	break;
    case PERL_MAGIC_env:
	vtable = &PL_vtbl_env;
	break;
    case PERL_MAGIC_fm:
	vtable = &PL_vtbl_fm;
	break;
    case PERL_MAGIC_envelem:
	vtable = &PL_vtbl_envelem;
	break;
    case PERL_MAGIC_regex_global:
	vtable = &PL_vtbl_mglob;
	break;
    case PERL_MAGIC_isa:
	vtable = &PL_vtbl_isa;
	break;
    case PERL_MAGIC_isaelem:
	vtable = &PL_vtbl_isaelem;
	break;
    case PERL_MAGIC_nkeys:
	vtable = &PL_vtbl_nkeys;
	break;
    case PERL_MAGIC_dbfile:
	vtable = NULL;
	break;
    case PERL_MAGIC_dbline:
	vtable = &PL_vtbl_dbline;
	break;
#ifdef USE_LOCALE_COLLATE
    case PERL_MAGIC_collxfrm:
        vtable = &PL_vtbl_collxfrm;
        break;
#endif /* USE_LOCALE_COLLATE */
    case PERL_MAGIC_tied:
	vtable = &PL_vtbl_pack;
	break;
    case PERL_MAGIC_tiedelem:
    case PERL_MAGIC_tiedscalar:
	vtable = &PL_vtbl_packelem;
	break;
    case PERL_MAGIC_qr:
	vtable = &PL_vtbl_regexp;
	break;
    case PERL_MAGIC_sig:
	vtable = &PL_vtbl_sig;
	break;
    case PERL_MAGIC_sigelem:
	vtable = &PL_vtbl_sigelem;
	break;
    case PERL_MAGIC_taint:
	vtable = &PL_vtbl_taint;
	break;
    case PERL_MAGIC_uvar:
	vtable = &PL_vtbl_uvar;
	break;
    case PERL_MAGIC_vec:
	vtable = &PL_vtbl_vec;
	break;
    case PERL_MAGIC_arylen_p:
    case PERL_MAGIC_rhash:
    case PERL_MAGIC_symtab:
    case PERL_MAGIC_vstring:
	vtable = NULL;
	break;
    case PERL_MAGIC_utf8:
	vtable = &PL_vtbl_utf8;
	break;
    case PERL_MAGIC_substr:
	vtable = &PL_vtbl_substr;
	break;
    case PERL_MAGIC_defelem:
	vtable = &PL_vtbl_defelem;
	break;
    case PERL_MAGIC_arylen:
	vtable = &PL_vtbl_arylen;
	break;
    case PERL_MAGIC_pos:
	vtable = &PL_vtbl_pos;
	break;
    case PERL_MAGIC_backref:
	vtable = &PL_vtbl_backref;
	break;
    case PERL_MAGIC_hintselem:
	vtable = &PL_vtbl_hintselem;
	break;
    case PERL_MAGIC_hints:
	vtable = &PL_vtbl_hints;
	break;
    case PERL_MAGIC_ext:
	/* Reserved for use by extensions not perl internals.	        */
	/* Useful for attaching extension internal data to perl vars.	*/
	/* Note that multiple extensions may clash if magical scalars	*/
	/* etc holding private data from one are passed to another.	*/
	vtable = NULL;
	break;
    default:
	Perl_croak(aTHX_ "Don't know how to handle magic of type \\%o", how);
    }

d5364 2
a5365 10
/*
=for apidoc sv_unmagic

Removes all magic of type C<type> from an SV.

=cut
*/

int
Perl_sv_unmagic(pTHX_ SV *const sv, const int type)
d5370 1
a5370 1
    PERL_ARGS_ASSERT_SV_UNMAGIC;
d5376 2
a5377 2
	if (mg->mg_type == type) {
            const MGVTBL* const vtbl = mg->mg_virtual;
d5379 2
a5380 2
	    if (vtbl && vtbl->svt_free)
		CALL_FPTR(vtbl->svt_free)(aTHX_ sv, mg);
d5408 30
d5443 1
a5443 1
associated with that magic. If the RV is magical, set magic will be
d5464 1
d5474 5
d5484 2
a5485 3
 * PERL_MAGIC_backref, or in the specific case of a HV that has the hv_aux
 * structure, from the xhv_backreferences field. (A HV without hv_aux will
 * have the standard magic instead.) The array is created with a refcount
d5487 10
a5496 9
 * picked on first to have its refcount decremented by the random zapper,
 * it won't actually be freed, meaning it's still theere for when its
 * parent gets freed.
 * When the parent SV is freed, in the case of magic, the magic is freed,
 * Perl_magic_killbackrefs is called which decrements one refcount, then
 * mg_obj is freed which kills the second count.
 * In the vase of a HV being freed, one ref is removed by
 * Perl_hv_kill_backrefs, the other by Perl_sv_kill_backrefs, which it
 * calls.
d5503 3
a5505 1
    AV *av;
d5509 2
d5512 10
a5521 1
	AV **const avp = Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
d5523 1
a5523 4
	av = *avp;
	if (!av) {
	    /* There is no AV in the offical place - try a fixup.  */
	    MAGIC *const mg = mg_find(tsv, PERL_MAGIC_backref);
d5525 12
a5536 15
	    if (mg) {
		/* Aha. They've got it stowed in magic.  Bring it back.  */
		av = MUTABLE_AV(mg->mg_obj);
		/* Stop mg_free decreasing the refernce count.  */
		mg->mg_obj = NULL;
		/* Stop mg_free even calling the destructor, given that
		   there's no AV to free up.  */
		mg->mg_virtual = 0;
		sv_unmagic(tsv, PERL_MAGIC_backref);
	    } else {
		av = newAV();
		AvREAL_off(av);
		SvREFCNT_inc_simple_void(av); /* see discussion above */
	    }
	    *avp = av;
d5538 1
a5538 3
    } else {
	const MAGIC *const mg
	    = SvMAGICAL(tsv) ? mg_find(tsv, PERL_MAGIC_backref) : NULL;
d5540 9
a5548 7
	    av = MUTABLE_AV(mg->mg_obj);
	else {
	    av = newAV();
	    AvREAL_off(av);
	    sv_magic(tsv, MUTABLE_SV(av), PERL_MAGIC_backref, NULL, 0);
	    /* av now has a refcnt of 2; see discussion above */
	}
d5550 2
d5562 2
a5563 2
STATIC void
S_sv_del_backref(pTHX_ SV *const tsv, SV *const sv)
d5566 1
a5566 3
    AV *av = NULL;
    SV **svp;
    I32 i;
d5570 27
a5596 6
    if (SvTYPE(tsv) == SVt_PVHV && SvOOK(tsv)) {
	av = *Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
	/* We mustn't attempt to "fix up" the hash here by moving the
	   backreference array back to the hv_aux structure, as that is stored
	   in the main HvARRAY(), and hfreentries assumes that no-one
	   reallocates HvARRAY() while it is running.  */
d5598 2
a5599 2
    if (!av) {
	const MAGIC *const mg
d5601 1
a5601 2
	if (mg)
	    av = MUTABLE_AV(mg->mg_obj);
d5604 12
a5615 2
    if (!av)
	Perl_croak(aTHX_ "panic: del_backref");
d5617 45
a5661 15
    assert(!SvIS_FREED(av));

    svp = AvARRAY(av);
    /* We shouldn't be in here more than once, but for paranoia reasons lets
       not assume this.  */
    for (i = AvFILLp(av); i >= 0; i--) {
	if (svp[i] == sv) {
	    const SSize_t fill = AvFILLp(av);
	    if (i != fill) {
		/* We weren't the last entry.
		   An unordered list has this property that you can take the
		   last element off the end to fill the hole, and it's still
		   an unordered list :-)
		*/
		svp[i] = svp[fill];
a5662 2
	    svp[fill] = NULL;
	    AvFILLp(av) = fill - 1;
d5664 11
d5676 1
d5679 1
a5679 1
int
d5682 3
a5684 1
    SV **svp = AvARRAY(av);
a5686 1
    PERL_UNUSED_ARG(sv);
d5688 27
a5714 1
    assert(!svp || !SvIS_FREED(av));
a5715 2
	SV *const *const last = svp + AvFILLp(av);

d5721 1
d5728 1
d5733 17
d5756 2
a5757 1
		*svp = NULL;
d5762 5
a5766 2
    SvREFCNT_dec(av); /* remove extra count added by sv_add_backref() */
    return 0;
d5772 2
a5773 2
Inserts a string at the specified offset/length within the SV. Similar to
the Perl substr() function. Handles get magic.
d5777 2
a5778 1
Same as C<sv_insert>, but the extra C<flags> are passed the C<SvPV_force_flags> that applies to C<bigstr>.
d5791 1
a5791 1
    register I32 i;
d5797 1
a5797 1
	Perl_croak(aTHX_ "Can't modify non-existent substring");
d5833 2
a5834 1
	Perl_croak(aTHX_ "panic: sv_insert");
d5949 39
d5992 1
a5992 1
and free the body itself. The SV's head is I<not> freed, although
d5995 1
a5995 1
This function should only be called when REFCNT is zero. Most of the time
d6003 1
a6003 1
Perl_sv_clear(pTHX_ register SV *const sv)
a6005 3
    const U32 type = SvTYPE(sv);
    const struct body_details *const sv_type_details
	= bodies_by_type + type;
d6007 6
a6014 2
    assert(SvREFCNT(sv) == 0);
    assert(SvTYPE(sv) != SVTYPEMASK);
d6016 46
a6061 10
    if (type <= SVt_IV) {
	/* See the comment in sv.h about the collusion between this early
	   return and the overloading of the NULL and IV slots in the size
	   table.  */
	if (SvROK(sv)) {
	    SV * const target = SvRV(sv);
	    if (SvWEAKREF(sv))
	        sv_del_backref(target, sv);
	    else
	        SvREFCNT_dec(target);
d6063 85
a6147 4
	SvFLAGS(sv) &= SVf_BREAK;
	SvFLAGS(sv) |= SVTYPEMASK;
	return;
    }
d6149 46
a6194 18
    if (SvOBJECT(sv)) {
	if (PL_defstash &&	/* Still have a symbol table? */
	    SvDESTROYABLE(sv))
	{
	    dSP;
	    HV* stash;
	    do {	
		CV* destructor;
		stash = SvSTASH(sv);
		destructor = StashHANDLER(stash,DESTROY);
		if (destructor
			/* A constant subroutine can have no side effects, so
			   don't bother calling it.  */
			&& !CvCONST(destructor)
			/* Don't bother calling an empty destructor */
			&& (CvISXSUB(destructor)
			|| (CvSTART(destructor)
			    && (CvSTART(destructor)->op_next->op_type != OP_LEAVESUB))))
d6196 21
a6216 19
		    SV* const tmpref = newRV(sv);
	            SvREADONLY_on(tmpref);   /* DESTROY() could be naughty */
		    ENTER;
		    PUSHSTACKi(PERLSI_DESTROY);
		    EXTEND(SP, 2);
		    PUSHMARK(SP);
		    PUSHs(tmpref);
		    PUTBACK;
		    call_sv(MUTABLE_SV(destructor), G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
		
		
		    POPSTACK;
		    SPAGAIN;
		    LEAVE;
		    if(SvREFCNT(tmpref) < 2) {
		        /* tmpref is not kept alive! */
		        SvREFCNT(sv)--;
			SvRV_set(tmpref, NULL);
			SvROK_off(tmpref);
d6218 4
a6221 1
		    SvREFCNT_dec(tmpref);
d6223 15
a6237 1
	    } while (SvOBJECT(sv) && SvSTASH(sv) != stash);
d6239 1
d6241 58
a6298 6
	    if (SvREFCNT(sv)) {
		if (PL_in_clean_objs)
		    Perl_croak(aTHX_ "DESTROY created new reference to dead object '%s'",
			  HvNAME_get(stash));
		/* DESTROY gave object new lease on life */
		return;
a6299 1
	}
d6301 38
a6338 111
	if (SvOBJECT(sv)) {
	    SvREFCNT_dec(SvSTASH(sv));	/* possibly of changed persuasion */
	    SvOBJECT_off(sv);	/* Curse the object. */
	    if (type != SVt_PVIO)
		--PL_sv_objcount;	/* XXX Might want something more general */
	}
    }
    if (type >= SVt_PVMG) {
	if (type == SVt_PVMG && SvPAD_OUR(sv)) {
	    SvREFCNT_dec(SvOURSTASH(sv));
	} else if (SvMAGIC(sv))
	    mg_free(sv);
	if (type == SVt_PVMG && SvPAD_TYPED(sv))
	    SvREFCNT_dec(SvSTASH(sv));
    }
    switch (type) {
	/* case SVt_BIND: */
    case SVt_PVIO:
	if (IoIFP(sv) &&
	    IoIFP(sv) != PerlIO_stdin() &&
	    IoIFP(sv) != PerlIO_stdout() &&
	    IoIFP(sv) != PerlIO_stderr())
	{
	    io_close(MUTABLE_IO(sv), FALSE);
	}
	if (IoDIRP(sv) && !(IoFLAGS(sv) & IOf_FAKE_DIRP))
	    PerlDir_close(IoDIRP(sv));
	IoDIRP(sv) = (DIR*)NULL;
	Safefree(IoTOP_NAME(sv));
	Safefree(IoFMT_NAME(sv));
	Safefree(IoBOTTOM_NAME(sv));
	goto freescalar;
    case SVt_REGEXP:
	/* FIXME for plugins */
	pregfree2((REGEXP*) sv);
	goto freescalar;
    case SVt_PVCV:
    case SVt_PVFM:
	cv_undef(MUTABLE_CV(sv));
	goto freescalar;
    case SVt_PVHV:
	if (PL_last_swash_hv == (const HV *)sv) {
	    PL_last_swash_hv = NULL;
	}
	Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
	hv_undef(MUTABLE_HV(sv));
	break;
    case SVt_PVAV:
	if (PL_comppad == MUTABLE_AV(sv)) {
	    PL_comppad = NULL;
	    PL_curpad = NULL;
	}
	av_undef(MUTABLE_AV(sv));
	break;
    case SVt_PVLV:
	if (LvTYPE(sv) == 'T') { /* for tie: return HE to pool */
	    SvREFCNT_dec(HeKEY_sv((HE*)LvTARG(sv)));
	    HeNEXT((HE*)LvTARG(sv)) = PL_hv_fetch_ent_mh;
	    PL_hv_fetch_ent_mh = (HE*)LvTARG(sv);
	}
	else if (LvTYPE(sv) != 't') /* unless tie: unrefcnted fake SV**  */
	    SvREFCNT_dec(LvTARG(sv));
    case SVt_PVGV:
	if (isGV_with_GP(sv)) {
            if(GvCVu((const GV *)sv) && (stash = GvSTASH(MUTABLE_GV(sv)))
	       && HvNAME_get(stash))
                mro_method_changed_in(stash);
	    gp_free(MUTABLE_GV(sv));
	    if (GvNAME_HEK(sv))
		unshare_hek(GvNAME_HEK(sv));
	    /* If we're in a stash, we don't own a reference to it. However it does
	       have a back reference to us, which needs to be cleared.  */
	    if (!SvVALID(sv) && (stash = GvSTASH(sv)))
		    sv_del_backref(MUTABLE_SV(stash), sv);
	}
	/* FIXME. There are probably more unreferenced pointers to SVs in the
	   interpreter struct that we should check and tidy in a similar
	   fashion to this:  */
	if ((const GV *)sv == PL_last_in_gv)
	    PL_last_in_gv = NULL;
    case SVt_PVMG:
    case SVt_PVNV:
    case SVt_PVIV:
    case SVt_PV:
      freescalar:
	/* Don't bother with SvOOK_off(sv); as we're only going to free it.  */
	if (SvOOK(sv)) {
	    STRLEN offset;
	    SvOOK_offset(sv, offset);
	    SvPV_set(sv, SvPVX_mutable(sv) - offset);
	    /* Don't even bother with turning off the OOK flag.  */
	}
	if (SvROK(sv)) {
	    SV * const target = SvRV(sv);
	    if (SvWEAKREF(sv))
	        sv_del_backref(target, sv);
	    else
	        SvREFCNT_dec(target);
	}
#ifdef PERL_OLD_COPY_ON_WRITE
	else if (SvPVX_const(sv)) {
            if (SvIsCOW(sv)) {
                if (DEBUG_C_TEST) {
                    PerlIO_printf(Perl_debug_log, "Copy on write: clear\n");
                    sv_dump(sv);
                }
		if (SvLEN(sv)) {
		    sv_release_COW(sv, SvPVX_const(sv), SV_COW_NEXT_SV(sv));
		} else {
		    unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
		}
d6340 58
a6397 11
                SvFAKE_off(sv);
            } else if (SvLEN(sv)) {
                Safefree(SvPVX_const(sv));
            }
	}
#else
	else if (SvPVX_const(sv) && SvLEN(sv))
	    Safefree(SvPVX_mutable(sv));
	else if (SvPVX_const(sv) && SvREADONLY(sv) && SvFAKE(sv)) {
	    unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
	    SvFAKE_off(sv);
a6398 4
#endif
	break;
    case SVt_NV:
	break;
d6401 5
a6405 9
    SvFLAGS(sv) &= SVf_BREAK;
    SvFLAGS(sv) |= SVTYPEMASK;

    if (sv_type_details->arena) {
	del_body(((char *)SvANY(sv) + sv_type_details->offset),
		 &PL_body_roots[type]);
    }
    else if (sv_type_details->body_size) {
	my_safefree(SvANY(sv));
d6407 1
d6413 1
a6413 1
Increment an SV's reference count. Use the C<SvREFCNT_inc()> wrapper
d6515 1
a6515 1
Returns the length of the string in the SV. Handles magic and type
d6540 1
a6540 1
UTF-8 bytes as a single character. Handles magic and type coercion.
d6571 12
a6582 2
	    if (mg && mg->mg_len != -1) {
		ulen = mg->mg_len;
d6585 1
a6585 10
		    if (real != ulen) {
			/* Need to turn the assertions off otherwise we may
			   recurse infinitely while printing error messages.
			*/
			SAVEI8(PL_utf8cache);
			PL_utf8cache = 0;
			Perl_croak(aTHX_ "panic: sv_len_utf8 cache %"UVuf
				   " real %"UVuf" for %"SVf,
				   (UV) ulen, (UV) real, SVfARG(sv));
		    }
d6590 1
a6590 13
		if (!SvREADONLY(sv)) {
		    if (!mg && (SvTYPE(sv) < SVt_PVMG ||
				!(mg = mg_find(sv, PERL_MAGIC_utf8)))) {
			mg = sv_magicext(sv, 0, PERL_MAGIC_utf8,
					 &PL_vtbl_utf8, 0, 0);
		    }
		    assert(mg);
		    mg->mg_len = ulen;
		    /* For now, treat "overflowed" as "still unknown".
		       See RT #72924.  */
		    if (ulen != (STRLEN) mg->mg_len)
			mg->mg_len = -1;
		}
d6602 1
a6602 1
		      STRLEN uoffset)
d6605 1
d6609 2
a6610 1
    while (s < send && uoffset--)
d6612 6
a6617 1
    if (s > send) {
d6622 1
d6631 1
a6631 1
		      const STRLEN uoffset, const STRLEN uend)
d6641 8
a6648 1
	return sv_pos_u2b_forwards(start, send, uoffset);
d6669 1
a6669 1
		    const U8 *const send, const STRLEN uoffset,
d6674 1
d6680 3
d6712 1
d6715 2
a6716 1
						send, uoffset - uoffset0);
d6754 9
a6762 15
	const STRLEN real_boffset
	    = boffset0 + sv_pos_u2b_forwards(start + boffset0,
					       send, uoffset - uoffset0);

	if (found && PL_utf8cache < 0) {
	    if (real_boffset != boffset) {
		/* Need to turn the assertions off otherwise we may recurse
		   infinitely while printing error messages.  */
		SAVEI8(PL_utf8cache);
		PL_utf8cache = 0;
		Perl_croak(aTHX_ "panic: sv_pos_u2b_cache cache %"UVuf
			   " real %"UVuf" for %"SVf,
			   (UV) boffset, (UV) real_boffset, SVfARG(sv));
	    }
	}
d6766 6
a6771 2
    if (PL_utf8cache)
	utf8_mg_pos_cache_update(sv, mgp, boffset, uoffset, send - start);
d6782 2
a6783 1
the offset, rather than from the start of the string. Handles type coercion.
d6813 3
a6815 1
	if (lenp) {
d6839 1
a6839 1
the offset, rather than from the start of the string. Handles magic and
d6873 20
d6951 2
a6952 8
	if (realutf8 != utf8) {
	    /* Need to turn the assertions off otherwise we may recurse
	       infinitely while printing error messages.  */
	    SAVEI8(PL_utf8cache);
	    PL_utf8cache = 0;
	    Perl_croak(aTHX_ "panic: utf8_mg_pos_cache_update cache %"UVuf
		       " real %"UVuf" for %"SVf, (UV) utf8, (UV) realutf8, SVfARG(sv));
	}
d6982 1
a6982 1
	   calcualation in bytes simply because we always know the byte
d7115 2
a7116 1
	Perl_croak(aTHX_ "panic: sv_pos_b2u: bad byte offset");
d7174 2
a7175 11
	if (found && PL_utf8cache < 0) {
	    if (len != real_len) {
		/* Need to turn the assertions off otherwise we may recurse
		   infinitely while printing error messages.  */
		SAVEI8(PL_utf8cache);
		PL_utf8cache = 0;
		Perl_croak(aTHX_ "panic: sv_pos_b2u cache %"UVuf
			   " real %"UVuf" for %"SVf,
			   (UV) len, (UV) real_len, SVfARG(sv));
	    }
	}
d7180 25
a7204 2
    if (PL_utf8cache)
	utf8_mg_pos_cache_update(sv, &mg, byte, len, blen);
d7211 1
a7211 1
identical. Is UTF-8 and 'use bytes' aware, handles get magic, and will
d7214 6
d7224 1
a7224 1
Perl_sv_eq(pTHX_ register SV *sv1, register SV *sv2)
a7231 1
    char *tpv   = NULL;
d7240 4
a7243 2
	 * invalidate pv1, so we may need to make a copy */
	if (sv1 == sv2 && (SvTHINKFIRST(sv1) || SvGMAGICAL(sv1))) {
d7247 1
a7247 1
	pv1 = SvPV_const(sv1, cur1);
d7255 1
a7255 1
	pv2 = SvPV_const(sv2, cur2);
a7277 2
	      bool is_utf8 = TRUE;

d7279 3
a7281 6
		   /* sv1 is the UTF-8 one,
		    * if is equal it must be downgrade-able */
		   char * const pv = (char*)bytes_from_utf8((const U8*)pv1,
						     &cur1, &is_utf8);
		   if (pv != pv1)
			pv1 = tpv = pv;
d7284 3
a7286 11
		   /* sv2 is the UTF-8 one,
		    * if is equal it must be downgrade-able */
		   char * const pv = (char *)bytes_from_utf8((const U8*)pv2,
						      &cur2, &is_utf8);
		   if (pv != pv2)
			pv2 = tpv = pv;
	      }
	      if (is_utf8) {
		   /* Downgrade not possible - cannot be eq */
		   assert (tpv == 0);
		   return FALSE;
a7294 2
    if (tpv)
	Safefree(tpv);
d7304 1
a7304 1
C<sv2>. Is UTF-8 and 'use bytes' aware, handles get magic, and will
d7307 8
d7321 7
d7340 1
a7340 1
	pv1 = SvPV_const(sv1, cur1);
d7347 1
a7347 1
	pv2 = SvPV_const(sv2, cur2);
d7359 3
a7361 1
		 pv2 = tpv = (char*)bytes_to_utf8((const U8*)pv2, &cur2);
d7371 3
a7373 1
		 pv1 = tpv = (char*)bytes_to_utf8((const U8*)pv1, &cur1);
d7404 1
a7404 1
Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
d7408 6
d7420 7
d7438 1
a7438 1
    pv1 = sv1 ? sv_collxfrm(sv1, &len1) : (char *) NULL;
d7440 1
a7440 1
    pv2 = sv2 ? sv_collxfrm(sv2, &len2) : (char *) NULL;
d7479 7
a7485 1
Add Collate Transform magic to an SV if it doesn't already have it.
d7496 1
a7496 1
Perl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp)
d7501 1
a7501 1
    PERL_ARGS_ASSERT_SV_COLLXFRM;
d7511 1
a7511 1
	s = SvPV_const(sv, len);
d7544 49
d7634 1
a7634 7
	    SV * const tsv = newSV(0);
	    sv_gets(tsv, fp, 0);
	    sv_utf8_upgrade_nomg(tsv);
	    SvCUR_set(sv,append);
	    sv_catsv(sv,tsv);
	    sv_free(tsv);
	    goto return_string_or_null;
d7639 3
d7667 1
a7667 32
      I32 bytesread;
      char *buffer;
      U32 recsize;
#ifdef VMS
      int fd;
#endif

      /* Grab the size of the record we're getting */
      recsize = SvUV(SvRV(PL_rs)); /* RsRECORD() guarantees > 0. */
      buffer = SvGROW(sv, (STRLEN)(recsize + append + 1)) + append;
      /* Go yank in */
#ifdef VMS
      /* VMS wants read instead of fread, because fread doesn't respect */
      /* RMS record boundaries. This is not necessarily a good thing to be */
      /* doing, but we've got no other real choice - except avoid stdio
         as implementation - perhaps write a :vms layer ?
       */
      fd = PerlIO_fileno(fp);
      if (fd == -1) { /* in-memory file from PerlIO::Scalar */
          bytesread = PerlIO_read(fp, buffer, recsize);
      }
      else {
          bytesread = PerlLIO_read(fd, buffer, recsize);
      }
#else
      bytesread = PerlIO_read(fp, buffer, recsize);
#endif
      if (bytesread < 0)
	  bytesread = 0;
      SvCUR_set(sv, bytesread + append);
      buffer[bytesread] = '\0';
      goto return_string_or_null;
d7777 2
d7792 1
d7797 2
a7798 2
#if 0
	DEBUG_P(PerlIO_printf(Perl_debug_log,
d7802 1
a7802 1
#endif
d7807 2
a7808 2
#if 0
	DEBUG_P(PerlIO_printf(Perl_debug_log,
d7812 1
a7812 1
#endif
d7873 1
a7873 1
	    /* Accomodate broken VAXC compiler, which applies U8 cast to
a7924 1
return_string_or_null:
d7932 1
a7932 1
if necessary. Handles 'get' magic.
d7940 18
a7963 1
    SvGETMAGIC(sv);
d7965 1
a7965 1
	if (SvIsCOW(sv))
d7969 1
a7969 1
		Perl_croak(aTHX_ "%s", PL_no_modify);
d7973 1
a7973 1
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,inc))
d8012 1
d8114 1
a8114 1
if necessary. Handles 'get' magic.
d8123 19
a8145 1
    SvGETMAGIC(sv);
d8147 1
a8147 1
	if (SvIsCOW(sv))
d8151 1
a8151 1
		Perl_croak(aTHX_ "%s", PL_no_modify);
d8155 1
a8155 1
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,dec))
d8197 1
d8265 1
a8265 1
The new SV is marked as mortal. It will be destroyed "soon", either by an
d8294 1
a8294 1
set to 1. It will be destroyed "soon", either by an explicit call to
d8322 3
a8324 2
If C<SVs_TEMP> is set, then C<sv2mortal()> is called on the result before
returning. If C<SVf_UTF8> is set, C<s> is considered to be in UTF-8 and the
d8347 1
a8347 1
     * and do what it does outselves here.
d8351 1
a8351 1
     * eleminate quite a few steps than it looks - Yves (explaining patch by gfx)
d8369 1
a8369 1
string buffer can be "stolen" if this SV is copied. See also C<sv_newmortal>
d8412 6
a8417 4
Creates a new SV and copies a string into it.  The reference count for the
SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length
string.  You are responsible for ensuring that the source string is at least
C<len> bytes long.  If the C<s> argument is NULL the new SV will be undefined.
d8423 1
a8423 1
Perl_newSVpvn(pTHX_ const char *const s, const STRLEN len)
d8429 1
a8429 1
    sv_setpvn(sv,s,len);
d8437 1
a8437 1
point to the shared string table where possible. Returns a new (undefined)
d8463 4
a8466 3
	    const U8 *as_utf8 = bytes_to_utf8 ((U8*)HEK_KEY(hek), &utf8_len);
	    SV * const sv = newSVpvn ((const char*)as_utf8, utf8_len);

a8467 1
	    Safefree (as_utf8); /* bytes_to_utf8() allocates a new string */
d8477 1
a8477 1
	       share_hek_kek on it.  */
d8509 5
a8513 4
table. If the string does not already exist in the table, it is created
first.  Turns on READONLY and FAKE. If the C<hash> parameter is non-zero, that
value is used; otherwise the hash is computed. The string's hash can be later
be retrieved from the SV with the C<SvSHARED_HASH()> macro. The idea here is
d8554 14
d8750 1
a8750 1
(Uses C<sv_setsv>).
d8763 1
a8763 1
    if (SvTYPE(old) == SVTYPEMASK) {
d8885 3
d8904 1
d8909 2
a8910 1
		Perl_croak(aTHX_ "Bad filehandle: %s", GvNAME(gv));
d8917 2
a8918 1
	if (SvROK(sv))
d8920 2
a8921 1
	gv = gv_fetchsv(sv, 0, SVt_PVIO);
d8926 8
a8933 2
	if (!io)
	    Perl_croak(aTHX_ "Bad filehandle: %"SVf, SVfARG(sv));
a8972 9
    case SVt_PVGV:
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	    *gvp = gv;
	    *st = GvESTASH(gv);
	    goto fix_gv;
	}
	/* FALL THROUGH */

d8974 1
d8976 2
a8977 3
	    SV * const *sp = &sv;	/* Used in tryAMAGICunDEREF macro. */
	    SvGETMAGIC(sv);
	    tryAMAGICunDEREF(to_cv);
d8986 1
a8986 1
	    else if(isGV_with_GP(sv))
a8991 1
	    SvGETMAGIC(sv);
d8994 3
a8996 2
	else
	    gv = gv_fetchsv(sv, lref, SVt_PVCV); /* Calls get magic */
d9008 1
a9008 2
    fix_gv:
	if (lref && !GvCVu(gv)) {
d9069 1
a9069 1
can't cope with complex macro expressions. Always use the macro instead.
d9075 1
a9075 1
appropriate, else not. C<sv_pvn_force> and C<sv_pvn_force_nomg> are
d9090 1
d9106 1
a9106 1
			   ref, OP_NAME(PL_op));
d9112 1
d9114 2
a9115 2
		OP_NAME(PL_op));
	s = sv_2pv_flags(sv, &len, flags);
d9141 2
a9142 1
The backend for the C<SvPVbytex_force> macro. Always use the macro instead.
d9161 2
a9162 1
The backend for the C<SvPVutf8x_force> macro. Always use the macro instead.
a9189 3

    /* The fact that I don't need to downcast to char * everywhere, only in ?:
       inside return suggests a const propagation bug in g++.  */
d9191 1
a9191 2
	char * const name = HvNAME_get(SvSTASH(sv));
	return name ? name : (char *) "__ANON__";
d9211 1
a9211 1
				 * scalars for backwards compatitbility */
d9222 1
a9222 1
	case SVt_REGEXP:	return "REGEXP"; 
d9229 28
d9508 1
a9508 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
d9535 2
a9536 1
/* Downgrades a PVGV to a PVMG.
d9539 2
a9540 2
STATIC void
S_sv_unglob(pTHX_ SV *const sv)
d9545 1
a9545 1
    SV * const temp = sv_newmortal();
d9549 1
a9549 1
    assert(SvTYPE(sv) == SVt_PVGV);
d9551 2
a9552 1
    gv_efullname3(temp, MUTABLE_GV(sv), "*");
d9570 6
a9575 5
    /* need to keep SvANY(sv) in the right arena */
    xpvmg = new_XPVMG();
    StructCopy(SvANY(sv), xpvmg, XPVMG);
    del_XPVGV(SvANY(sv));
    SvANY(sv) = xpvmg;
d9577 3
a9579 2
    SvFLAGS(sv) &= ~SVTYPEMASK;
    SvFLAGS(sv) |= SVt_PVMG;
d9583 7
a9589 1
    sv_setsv_flags(sv, temp, 0);
d9632 2
a9633 1
Untaint an SV. Use C<SvTAINTED_off> instead.
d9652 2
a9653 1
Test an SV for taintedness. Use C<SvTAINTED> instead.
d9873 1
a9873 1
C<sv_catpvf_mg>. If the original SV was UTF-8, the pattern should be
d10001 1
a10001 1
		Perl_croak(aTHX_ "Integer overflow in format string for %s", (PL_op ? OP_NAME(PL_op) : "sv_vcatpvfn"));
d10097 2
d10118 4
a10121 9
	if (pp - pat == (int)patlen - 1) {
	    NV nv;

	    if (svix < svmax)
		nv = SvNV(*svargs);
	    else
		return;
	    if (*pp == 'g') {
		/* Add check for digits != 0 because it seems that some
d10240 4
a10243 1
		%<num>p		reserved for future extensions
d10245 1
a10245 1
	Robin Barker 2005-07-14
d10267 8
d10352 19
a10370 11
	if (vectorize) {
	    if (vectorarg) {
		if (args)
		    vecsv = va_arg(*args, SV*);
		else if (evix) {
		    vecsv = (evix > 0 && evix <= svmax)
			? svargs[evix-1] : S_vcatpvfn_missing_argument(aTHX);
		} else {
		    vecsv = svix < svmax
			? svargs[svix++] : S_vcatpvfn_missing_argument(aTHX);
		}
d10372 2
a10373 41
		/* Keep the DO_UTF8 test *after* the SvPV call, else things go
		   bad with tied or overloaded values that return UTF8.  */
		if (DO_UTF8(vecsv))
		    is_utf8 = TRUE;
		else if (has_utf8) {
		    vecsv = sv_mortalcopy(vecsv);
		    sv_utf8_upgrade(vecsv);
		    dotstr = SvPV_const(vecsv, dotstrlen);
		    is_utf8 = TRUE;
		}		    
	    }
	    if (args) {
		VECTORIZE_ARGS
	    }
	    else if (efix ? (efix > 0 && efix <= svmax) : svix < svmax) {
		vecsv = svargs[efix ? efix-1 : svix++];
		vecstr = (U8*)SvPV_const(vecsv,veclen);
		vec_utf8 = DO_UTF8(vecsv);

		/* if this is a version object, we need to convert
		 * back into v-string notation and then let the
		 * vectorize happen normally
		 */
		if (sv_derived_from(vecsv, "version")) {
		    char *version = savesvpv(vecsv);
		    if ( hv_exists(MUTABLE_HV(SvRV(vecsv)), "alpha", 5 ) ) {
			Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			"vector argument not supported with alpha versions");
			goto unknown;
		    }
		    vecsv = sv_newmortal();
		    scan_vstring(version, version + veclen, vecsv);
		    vecstr = (U8*)SvPV_const(vecsv, veclen);
		    vec_utf8 = DO_UTF8(vecsv);
		    Safefree(version);
		}
	    }
	    else {
		vecstr = (U8*)"";
		veclen = 0;
	    }
d10414 33
d10480 1
d10482 1
a10482 1
	    if (*(q + 1) == 'l') {	/* lld, llf */
d10484 3
a10486 3
		q += 2;
		break;
	     }
d10488 2
a10489 1
	    /*FALLTHROUGH*/
d10491 7
a10497 1
	    /*FALLTHROUGH*/
d10499 5
d10629 1
d10633 2
d10636 3
d10650 1
d10727 1
d10731 5
d10748 1
d10859 1
d10861 3
d11043 1
d11048 5
d11062 1
a11062 1
		sv_setuv_mg(argsv, (UV)i);
d11188 1
d11200 1
a11200 1
to new addresses. The table is created and manipulated with the
d11220 1
a11220 2
#define sv_dup_inc(s,t)	SvREFCNT_inc(sv_dup(s,t))
#define sv_dup_inc_NN(s,t)	SvREFCNT_inc_NN(sv_dup(s,t))
d11222 1
a11222 1
#define av_dup_inc(s,t)	MUTABLE_AV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
d11224 1
a11224 1
#define hv_dup_inc(s,t)	MUTABLE_HV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
d11226 1
a11226 1
#define cv_dup_inc(s,t)	MUTABLE_CV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
d11228 1
a11228 1
#define io_dup_inc(s,t)	MUTABLE_IO(SvREFCNT_inc(sv_dup((const SV *)s,t)))
d11230 1
a11230 1
#define gv_dup_inc(s,t)	MUTABLE_GV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
a11254 3
    parser->yyerrstatus = 0;
    parser->yychar = YYEMPTY;		/* Cause a token to be read.  */

d11381 1
a11381 1
Perl_dirp_dup(pTHX_ DIR *const dp)
d11383 11
d11395 2
d11399 88
a11486 2
    /* XXX TODO */
    return dp;
d11537 7
d11561 8
a11568 11
	if(nmg->mg_type == PERL_MAGIC_backref) {
	    /* The backref AV has its reference count deliberately bumped by
	       1.  */
	    nmg->mg_obj
		= SvREFCNT_inc(av_dup_inc((const AV *) nmg->mg_obj, param));
	}
	else {
	    nmg->mg_obj	= (nmg->mg_flags & MGf_REFCOUNTED)
			      ? sv_dup_inc(nmg->mg_obj, param)
			      : sv_dup(nmg->mg_obj, param);
	}
d11585 1
a11585 1
	    CALL_FPTR(nmg->mg_virtual->svt_dup)(aTHX_ nmg, param);
d11593 5
d11609 3
a11618 8
/* 
   we use the PTE_SVSLOT 'reservation' made above, both here (in the
   following define) and at call to new_body_inline made below in 
   Perl_ptr_table_store()
 */

#define del_pte(p)     del_body_type(p, PTE_SVSLOT)

d11663 12
a11674 1
	new_body_inline(tblent, PTE_SVSLOT);
d11704 4
a11707 2
	PTR_TBL_ENT_t **curentp, **entp, *ent;
	if (!*ary)
d11710 1
a11710 1
	for (entp = ary, ent = *ary; ent; ent = *entp) {
a11714 1
		continue;
d11718 2
a11719 1
	}
d11724 1
d11730 3
a11732 2
	register PTR_TBL_ENT_t * const * const array = tbl->tbl_ary;
	UV riter = tbl->tbl_max;
d11734 2
a11735 2
	do {
	    PTR_TBL_ENT_t *entry = array[riter];
d11737 3
a11739 6
	    while (entry) {
		PTR_TBL_ENT_t * const oentry = entry;
		entry = entry->next;
		del_pte(oentry);
	    }
	} while (riter--);
d11742 3
d11753 2
d11758 10
a11767 1
    ptr_table_clear(tbl);
d11780 10
a11789 4
	SvRV_set(dstr, SvWEAKREF(sstr)
		       ? sv_dup(SvRV_const(sstr), param)
		       : sv_dup_inc(SvRV_const(sstr), param));

d11798 1
a11798 1
		   But we are a true, independant SV, so:  */
d11842 2
a11843 2
SV *
Perl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
d11848 1
a11848 1
    PERL_ARGS_ASSERT_SV_DUP;
d11850 1
a11850 3
    if (!sstr)
	return NULL;
    if (SvTYPE(sstr) == SVTYPEMASK) {
d11866 1
a11866 1
	    if (hvname)
d11868 26
a11893 1
		return MUTABLE_SV(gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname), 0));
d11904 2
a11905 1
    dstr->sv_debug_cloned = 1;
d11993 2
a11994 1
		&& !isGV_with_GP(dstr))
d12034 1
d12044 3
a12046 13
		    if(param->flags & CLONEf_JOIN_IN) {
			const HEK * const hvname
			 = HvNAME_HEK(GvSTASH(dstr));
			if( hvname
			 && GvSTASH(dstr) == gv_stashpvn(
			     HEK_KEY(hvname), HEK_LEN(hvname), 0
			    )
			  )
			    Perl_sv_add_backref(
			     aTHX_ MUTABLE_SV(GvSTASH(dstr)), dstr
			    );
		    }
		    GvGP(dstr)	= gp_dup(GvGP(sstr), param);
d12048 1
a12048 2
		} else
		    Perl_rvpv_dup(aTHX_ dstr, sstr, param);
a12050 5
		IoIFP(dstr)	= fp_dup(IoIFP(dstr), IoTYPE(dstr), param);
		if (IoOFP(dstr) == IoIFP(sstr))
		    IoOFP(dstr) = IoIFP(dstr);
		else
		    IoOFP(dstr)	= fp_dup(IoOFP(dstr), IoTYPE(dstr), param);
d12064 1
a12064 1
			IoDIRP(dstr)	= dirp_dup(IoDIRP(dstr));
d12069 1
d12071 4
a12096 5
			if (!(param->flags & CLONEf_COPY_STACKS)
			     && AvREIFY(sstr))
			{
			    av_reify(MUTABLE_AV(dstr)); /* #41138 */
			}
a12127 1
			HEK *hvname;
d12131 1
a12131 2
			/* SvOOK_on(hv) attacks the IV flags.  */
			SvFLAGS(dstr) |= SVf_OOK;
d12133 21
a12153 2
			hvname = saux->xhv_name;
			daux->xhv_name = hek_dup(hvname, param);
d12158 1
a12158 1
					(bool)!!HvSHAREKEYS(sstr), param) : 0;
d12161 16
a12176 3
			    saux->xhv_backreferences
			    ? MUTABLE_AV(SvREFCNT_inc(
						      sv_dup_inc((const SV *)saux->xhv_backreferences, param)))
d12184 1
a12184 1
			if (hvname)
d12195 1
d12198 6
a12203 3
		CvSTASH(dstr)	= hv_dup(CvSTASH(dstr), param);
		OP_REFCNT_LOCK;
		if (!CvISXSUB(dstr))
d12205 2
a12206 2
		OP_REFCNT_UNLOCK;
		if (CvCONST(dstr) && CvISXSUB(dstr)) {
d12210 1
d12213 8
a12220 3
		CvGV(dstr)	= (param->flags & CLONEf_JOIN_IN) ?
		    NULL : gv_dup(CvGV(dstr), param) ;
		PAD_DUP(CvPADLIST(dstr), CvPADLIST(sstr), param);
a12224 2
		if (!CvISXSUB(dstr))
		    CvFILE(dstr) = SAVEPV(CvFILE(dstr));
d12236 35
d12299 1
d12318 1
d12324 1
a12324 1
		   actually being the same function, and order equivalance of
d12335 1
a12335 1
		    ncx->blk_loop.oldcomppad
d12337 1
a12337 1
						ncx->blk_loop.oldcomppad);
d12339 3
a12341 3
		    ncx->blk_loop.oldcomppad
			= (PAD*)gv_dup((const GV *)ncx->blk_loop.oldcomppad,
				       param);
d12352 2
d12401 2
d12475 4
a12478 2
	const I32 type = POPINT(ss,ix);
	TOPINT(nss,ix) = type;
d12480 2
d12487 1
a12528 2
	    /* fall through */
	case SAVEt_CLEARSV:
a12532 3
	case SAVEt_I16:				/* I16 reference */
	case SAVEt_I8:				/* I8 reference */
	case SAVEt_COP_ARYBASE:			/* call CopARYBASE_set */
d12555 6
d12577 1
a12577 1
            break;
d12604 4
d12640 1
a12640 3
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    ix -= i;
d12656 1
a12656 5
	    if (ptr) {
		HINTS_REFCNT_LOCK;
		((struct refcounted_he *)ptr)->refcounted_he_refcnt++;
		HINTS_REFCNT_UNLOCK;
	    }
a12672 6
	case SAVEt_BOOL:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    longval = (long)POPBOOL(ss,ix);
	    TOPBOOL(nss,ix) = (bool)longval;
	    break;
d12808 1
a12808 1
CLONEf_KEEP_PTR_TABLE
d12813 1
a12813 1
refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill
d12818 1
a12818 1
code is in threads.xs create
d12820 1
a12820 1
CLONEf_CLONE_HOST
d12897 1
d12908 1
a12908 1
    PL_sv_serial = (((U32)my_perl >> 2) & 0xfff) * 1000000;
d12928 2
d12931 4
a12940 2
    PL_nice_chunk	= NULL;
    PL_nice_chunk_size	= 0;
d12951 236
a13198 3
    SvANY(&PL_sv_undef)		= NULL;
    SvREFCNT(&PL_sv_undef)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVt_NULL;
a13201 3
    SvREFCNT(&PL_sv_no)		= (~(U32)0)/2;
    SvFLAGS(&PL_sv_no)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
a13208 4
    SvANY(&PL_sv_yes)		= new_XPVNV();
    SvREFCNT(&PL_sv_yes)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_yes)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
a13215 3
    /* dbargs array probably holds garbage */
    PL_dbargs		= NULL;

a13221 2
    PL_compiling = proto_perl->Icompiling;

d13231 1
a13231 5
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
a13232 8
#ifdef PERL_DEBUG_READONLY_OPS
    PL_slabs = NULL;
    PL_slab_count = 0;
#endif

    /* pseudo environmental stuff */
    PL_origargc		= proto_perl->Iorigargc;
    PL_origargv		= proto_perl->Iorigargv;
d13235 7
d13243 3
a13245 3
    /* Set tainting stuff before PerlIO_debug can possibly get called */
    PL_tainting		= proto_perl->Itainting;
    PL_taint_warn	= proto_perl->Itaint_warn;
a13259 1
    PL_minus_c		= proto_perl->Iminus_c;
d13261 1
a13261 13
    PL_localpatches	= proto_perl->Ilocalpatches;
    PL_splitstr		= proto_perl->Isplitstr;
    PL_minus_n		= proto_perl->Iminus_n;
    PL_minus_p		= proto_perl->Iminus_p;
    PL_minus_l		= proto_perl->Iminus_l;
    PL_minus_a		= proto_perl->Iminus_a;
    PL_minus_E		= proto_perl->Iminus_E;
    PL_minus_F		= proto_perl->Iminus_F;
    PL_doswitches	= proto_perl->Idoswitches;
    PL_dowarn		= proto_perl->Idowarn;
    PL_doextract	= proto_perl->Idoextract;
    PL_sawampersand	= proto_perl->Isawampersand;
    PL_unsafe		= proto_perl->Iunsafe;
a13263 3
    PL_perldb		= proto_perl->Iperldb;
    PL_perl_destruct_level = proto_perl->Iperl_destruct_level;
    PL_exit_flags       = proto_perl->Iexit_flags;
a13265 2
    /* XXX time(&PL_basetime) when asked for? */
    PL_basetime		= proto_perl->Ibasetime;
a13267 7
    PL_maxsysfd		= proto_perl->Imaxsysfd;
    PL_statusvalue	= proto_perl->Istatusvalue;
#ifdef VMS
    PL_statusvalue_vms	= proto_perl->Istatusvalue_vms;
#else
    PL_statusvalue_posix = proto_perl->Istatusvalue_posix;
#endif
a13274 5
    /* RE engine related */
    Zero(&PL_reg_state, 1, struct re_save_state);
    PL_reginterp_cnt	= 0;
    PL_regmatch_slab	= NULL;
    
d13284 1
a13284 1
    PL_ofsgv            = gv_dup(proto_perl->Iofsgv, param);
d13308 1
a13308 1
    PL_curstash		= hv_dup(proto_perl->Icurstash, param);
a13321 1
    PL_sub_generation	= proto_perl->Isub_generation;
a13323 3
    /* funky return mechanisms */
    PL_forkprocess	= proto_perl->Iforkprocess;

a13326 2
    /* internal state */
    PL_maxo		= proto_perl->Imaxo;
a13337 3
    PL_main_start	= proto_perl->Imain_start;
    PL_eval_root	= proto_perl->Ieval_root;
    PL_eval_start	= proto_perl->Ieval_start;
a13341 6
    PL_filemode		= proto_perl->Ifilemode;
    PL_lastfd		= proto_perl->Ilastfd;
    PL_oldname		= proto_perl->Ioldname;		/* XXX not quite right */
    PL_Argv		= NULL;
    PL_Cmd		= NULL;
    PL_gensym		= proto_perl->Igensym;
a13342 3
    PL_laststatval	= proto_perl->Ilaststatval;
    PL_laststype	= proto_perl->Ilaststype;
    PL_mess_sv		= NULL;
d13373 1
a13373 2

    PL_profiledata	= NULL;
a13382 2
    /* more statics moved here */
    PL_generation	= proto_perl->Igeneration;
a13384 12
    PL_in_clean_objs	= proto_perl->Iin_clean_objs;
    PL_in_clean_all	= proto_perl->Iin_clean_all;

    PL_uid		= proto_perl->Iuid;
    PL_euid		= proto_perl->Ieuid;
    PL_gid		= proto_perl->Igid;
    PL_egid		= proto_perl->Iegid;
    PL_nomemok		= proto_perl->Inomemok;
    PL_an		= proto_perl->Ian;
    PL_evalseq		= proto_perl->Ievalseq;
    PL_origenviron	= proto_perl->Iorigenviron;	/* XXX not quite right */
    PL_origalen		= proto_perl->Iorigalen;
a13388 4
    PL_sighandlerp	= proto_perl->Isighandlerp;

    PL_runops		= proto_perl->Irunops;

a13397 1
    PL_subline		= proto_perl->Isubline;
a13399 8
#ifdef FCRYPT
    PL_cryptseen	= proto_perl->Icryptseen;
#endif

    PL_hints		= proto_perl->Ihints;

    PL_amagic_generation	= proto_perl->Iamagic_generation;

a13400 1
    PL_collation_ix	= proto_perl->Icollation_ix;
a13401 3
    PL_collation_standard	= proto_perl->Icollation_standard;
    PL_collxfrm_base	= proto_perl->Icollxfrm_base;
    PL_collxfrm_mult	= proto_perl->Icollxfrm_mult;
a13405 2
    PL_numeric_standard	= proto_perl->Inumeric_standard;
    PL_numeric_local	= proto_perl->Inumeric_local;
d13409 50
a13458 1
    /* utf8 character classes */
a13459 1
    PL_utf8_ascii	= sv_dup_inc(proto_perl->Iutf8_ascii, param);
a13461 1
    PL_utf8_cntrl	= sv_dup_inc(proto_perl->Iutf8_cntrl, param);
d13485 2
d13488 6
a13494 41
    /* Did the locale setup indicate UTF-8? */
    PL_utf8locale	= proto_perl->Iutf8locale;
    /* Unicode features (see perlrun/-C) */
    PL_unicode		= proto_perl->Iunicode;

    /* Pre-5.8 signals control */
    PL_signals		= proto_perl->Isignals;

    /* times() ticks per second */
    PL_clocktick	= proto_perl->Iclocktick;

    /* Recursion stopper for PerlIO_find_layer */
    PL_in_load_module	= proto_perl->Iin_load_module;

    /* sort() routine */
    PL_sort_RealCmp	= proto_perl->Isort_RealCmp;

    /* Not really needed/useful since the reenrant_retint is "volatile",
     * but do it for consistency's sake. */
    PL_reentrant_retint	= proto_perl->Ireentrant_retint;

    /* Hooks to shared SVs and locks. */
    PL_sharehook	= proto_perl->Isharehook;
    PL_lockhook		= proto_perl->Ilockhook;
    PL_unlockhook	= proto_perl->Iunlockhook;
    PL_threadhook	= proto_perl->Ithreadhook;
    PL_destroyhook	= proto_perl->Idestroyhook;

#ifdef THREADS_HAVE_PIDS
    PL_ppid		= proto_perl->Ippid;
#endif

    /* swatch cache */
    PL_last_swash_hv	= NULL;	/* reinits on demand */
    PL_last_swash_klen	= 0;
    PL_last_swash_key[0]= '\0';
    PL_last_swash_tmps	= (U8*)NULL;
    PL_last_swash_slen	= 0;

    PL_glob_index	= proto_perl->Iglob_index;
    PL_srand_called	= proto_perl->Isrand_called;
a13513 2
    /* intrpvar.h stuff */

a13514 4
	/* next allocation will be PL_tmps_stack[PL_tmps_ix+1] */
	PL_tmps_ix		= proto_perl->Itmps_ix;
	PL_tmps_max		= proto_perl->Itmps_max;
	PL_tmps_floor		= proto_perl->Itmps_floor;
a13530 2
	PL_scopestack_ix	= proto_perl->Iscopestack_ix;
	PL_scopestack_max	= proto_perl->Iscopestack_max;
a13550 4
	/* next SSPUSHFOO() sets PL_savestack[PL_savestack_ix]
	 * NOTE: unlike the others! */
	PL_savestack_ix		= proto_perl->Isavestack_ix;
	PL_savestack_max	= proto_perl->Isavestack_max;
a13556 13

	/* although we're not duplicating the tmps stack, we should still
	 * add entries for any SVs on the tmps stack that got cloned by a
	 * non-refcount means (eg a temp in @@_); otherwise they will be
	 * orphaned
	 */
	for (i = 0; i<= proto_perl->Itmps_ix; i++) {
	    SV * const nsv = MUTABLE_SV(ptr_table_fetch(PL_ptr_table,
		    proto_perl->Itmps_stack[i]));
	    if (nsv && !SvREFCNT(nsv)) {
		PUSH_EXTEND_MORTAL__SV_C(SvREFCNT_inc_simple(nsv));
	    }
	}
a13558 11
    PL_start_env	= proto_perl->Istart_env;	/* XXXXXX */
    PL_top_env		= &PL_start_env;

    PL_op		= proto_perl->Iop;

    PL_Sv		= NULL;
    PL_Xpv		= (XPV*)NULL;
    my_perl->Ina	= proto_perl->Ina;

    PL_statbuf		= proto_perl->Istatbuf;
    PL_statcache	= proto_perl->Istatcache;
a13560 3
#ifdef HAS_TIMES
    PL_timesbuf		= proto_perl->Itimesbuf;
#endif
a13561 2
    PL_tainted		= proto_perl->Itainted;
    PL_curpm		= proto_perl->Icurpm;	/* XXX No PMOP ref count */
a13564 1
    PL_chopset		= proto_perl->Ichopset;	/* XXX never deallocated */
a13568 6
    PL_restartop	= proto_perl->Irestartop;
    PL_in_eval		= proto_perl->Iin_eval;
    PL_delaymagic	= proto_perl->Idelaymagic;
    PL_dirty		= proto_perl->Idirty;
    PL_localizing	= proto_perl->Ilocalizing;

a13569 4
    PL_hv_fetch_ent_mh	= NULL;
    PL_modcount		= proto_perl->Imodcount;
    PL_lastgotoprobe	= NULL;
    PL_dumpindent	= proto_perl->Idumpindent;
a13574 21
    PL_efloatbuf	= NULL;		/* reinits on demand */
    PL_efloatsize	= 0;			/* reinits on demand */

    /* regex stuff */

    PL_screamfirst	= NULL;
    PL_screamnext	= NULL;
    PL_maxscream	= -1;			/* reinits on demand */
    PL_lastscream	= NULL;


    PL_regdummy		= proto_perl->Iregdummy;
    PL_colorset		= 0;		/* reinits PL_colors[] */
    /*PL_colors[6]	= {0,0,0,0,0,0};*/



    /* Pluggable optimizer */
    PL_peepp		= proto_perl->Ipeepp;
    /* op_free() hook */
    PL_opfreehook	= proto_perl->Iopfreehook;
d13589 2
d13616 3
d13631 103
d13748 1
a13748 1
(See F<lib/encoding.pm> and L<Encode>).
d13796 8
d13818 1
a13818 1
the PV of the ssv. The value which the offset points will be modified
d13945 2
a13946 2
STATIC SV*
S_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ,
d13951 1
a13951 1
    if (gv) {
d13970 1
a13970 1
	CV * const cv = find_runcv(NULL);
d13974 2
d13980 1
a13980 1
	sv_setpvn(name, SvPV_nolen_const(sv), SvCUR(sv));
d13987 2
a13988 1
	    pv_display(sv,SvPVX_const(keyname), SvCUR(keyname), 0, 32));
d14007 1
a14007 1
Find the name of the undefined variable (if any) that caused the operator o
d14009 1
a14009 1
If match is true, only return a name if it's value matches uninit_sv.
d14012 1
a14012 1
OP_PADSV or OP_GV that gives the name of the undefined variable. On the
d14062 1
a14062 1
	    else /* @@{expr}, %{expr} */
d14065 2
d14088 13
d14109 1
a14109 1
	if (!gv || (match && GvSV(gv) != uninit_sv))
d14113 12
d14126 1
a14126 14
	if (obase->op_flags & OPf_SPECIAL) { /* lexical array */
	    if (match) {
		SV **svp;
		AV *av = MUTABLE_AV(PAD_SV(obase->op_targ));
		if (!av || SvRMAGICAL(av))
		    break;
		svp = av_fetch(av, (I32)obase->op_private, FALSE);
		if (!svp || *svp != uninit_sv)
		    break;
	    }
	    return varname(NULL, '$', obase->op_targ,
		    NULL, (I32)obase->op_private, FUV_SUBSCRIPT_ARRAY);
	}
	else {
d14153 3
d14181 5
d14188 7
d14199 1
a14199 1
		    HE* he = hv_fetch_ent(MUTABLE_HV(sv), cSVOPx_sv(kid), 0, 0);
d14204 3
a14206 1
		    SV * const * const svp = av_fetch(MUTABLE_AV(sv), SvIV(cSVOPx_sv(kid)), FALSE);
d14213 1
a14213 1
			    cSVOPx_sv(kid), 0, FUV_SUBSCRIPT_HASH);
d14216 2
a14217 1
			    SvIV(cSVOPx_sv(kid)), FUV_SUBSCRIPT_ARRAY);
d14243 1
d14274 1
a14300 1
    case OP_RV2SV:
d14417 7
a14423 2
	/* if all except one arg are constant, or have no side-effects,
	 * or are optimized away, then it's unambiguous */
d14459 1
a14459 1
Print appropriate "Use of uninitialized variable" warning
d14470 1
a14470 1
	if (uninit_sv) {
d14475 3
a14477 2
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
		varname ? SvPV_nolen_const(varname) : "",
@


1.16
log
@Merge in perl 5.10.1
@
text
@d167 1
a167 1
Perl_offer_nice_chunk(pTHX_ void *chunk, U32 chunk_size)
d356 3
a358 4
	    if (ckWARN_d(WARN_INTERNAL))	
	        Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			    "Attempt to free non-arena SV: 0x%"UVxf
                            pTHX__FORMAT, PTR2UV(p) pTHX__VALUE);
d383 2
a384 2
void
Perl_sv_add_arena(pTHX_ char *ptr, U32 size, U32 flags)
d424 1
a424 1
S_visit(pTHX_ SVFUNC_t f, U32 flags, U32 mask)
d453 1
a453 1
do_report_used(pTHX_ SV *sv)
d483 1
a483 1
do_clean_objs(pTHX_ SV *ref)
d510 1
a510 1
do_clean_named_objs(pTHX_ SV *sv)
d559 1
a559 1
do_clean_all(pTHX_ SV *sv)
d610 1
a610 1
    U32		misc;		/* type, and in future other things. */
d723 1
a723 1
Perl_get_arena(pTHX_ size_t arena_size, U32 misc)
d752 1
a752 1
    adesc->misc = misc;
a937 3
    /* RVs are in the head now.  */
    { 0, 0, 0, SVt_RV, FALSE, NONV, NOARENA, 0 },

d959 9
a967 1
    
d1002 5
a1006 2
    { sizeof(XPVIO), sizeof(XPVIO), 0, SVt_PVIO, TRUE, HADNV,
      HASARENA, FIT_ARENA(24, sizeof(XPVIO)) },
d1078 1
a1078 1
S_more_bodies (pTHX_ svtype sv_type)
d1150 1
a1150 1
S_new_body(pTHX_ svtype sv_type)
d1160 3
d1174 1
a1174 1
Perl_sv_upgrade(pTHX_ register SV *sv, svtype new_type)
d1181 1
a1181 1
    const struct body_details *const old_type_details
d1183 1
d1187 12
a1202 3
    if (old_type == new_type)
	return;

d1247 10
a1256 3
	if (new_type < SVt_PVIV) {
	    new_type = (new_type == SVt_NV)
		? SVt_PVNV : SVt_PVIV;
a1263 2
    case SVt_RV:
	break;
a1311 5
    case SVt_RV:
	assert(old_type == SVt_NULL);
	SvANY(sv) = &sv->sv_u.svu_rv;
	SvRV_set(sv, 0);
	return;
d1360 3
a1362 1
	if (old_type >= SVt_RV) {
d1375 4
d1435 10
a1444 1
	if (new_type == SVt_PVIO)
d1446 6
a1451 2
	if (old_type < SVt_RV)
	    SvPV_set(sv, NULL);
d1458 1
a1458 5
    if (old_type_details->arena) {
	/* If there was an old body, then we need to free it.
	   Note that there is an assumption that all bodies of types that
	   can be upgraded came from arenas. Only the more complex non-
	   upgradable types are allowed to be directly malloc()ed.  */
d1462 4
d1482 1
a1482 1
Perl_sv_backoff(pTHX_ register SV *sv)
d1484 3
d1493 6
a1498 17
    if (SvIVX(sv)) {
	const char * const s = SvPVX_const(sv);
#ifdef DEBUGGING
	/* Validate the preceding buffer's sentinels to verify that no-one is
	   using it.  */
	const U8 *p = (const U8*) s;
	const U8 *const real_start = p - SvIVX(sv);
	while (p > real_start) {
	    --p;
	    assert (*p == (U8)PTR2UV(p));
	}
#endif
	SvLEN_set(sv, SvLEN(sv) + SvIVX(sv));
	SvPV_set(sv, SvPVX(sv) - SvIVX(sv));
	SvIV_set(sv, 0);
	Move(s, SvPVX(sv), SvCUR(sv)+1, char);
    }
d1514 1
a1514 1
Perl_sv_grow(pTHX_ register SV *sv, register STRLEN newlen)
d1586 1
a1586 1
Perl_sv_setiv(pTHX_ register SV *sv, IV i)
a1597 1
    case SVt_RV:
d1628 1
a1628 1
Perl_sv_setiv_mg(pTHX_ register SV *sv, IV i)
d1646 1
a1646 1
Perl_sv_setuv(pTHX_ register SV *sv, UV u)
d1676 1
a1676 1
Perl_sv_setuv_mg(pTHX_ register SV *sv, UV u)
d1694 1
a1694 1
Perl_sv_setnv(pTHX_ register SV *sv, NV num)
a1705 1
    case SVt_RV:
d1737 1
a1737 1
Perl_sv_setnv_mg(pTHX_ register SV *sv, NV num)
d1750 1
a1750 1
S_not_a_number(pTHX_ SV *sv)
d1833 1
a1833 1
Perl_looks_like_number(pTHX_ SV *sv)
a1873 21
STATIC char *
S_glob_2pv(pTHX_ GV * const gv, STRLEN * const len)
{
    const U32 wasfake = SvFLAGS(gv) & SVf_FAKE;
    SV *const buffer = sv_newmortal();

    PERL_ARGS_ASSERT_GLOB_2PV;

    /* FAKE globs can get coerced, so need to turn this off temporarily if it
       is on.  */
    SvFAKE_off(gv);
    gv_efullname3(buffer, gv, "*");
    SvFLAGS(gv) |= wasfake;

    assert(SvPOK(buffer));
    if (len) {
	*len = SvCUR(buffer);
    }
    return SvPVX(buffer);
}

d1959 1
a1959 1
S_sv_2iuv_non_preserve(pTHX_ register SV *sv
d2014 1
a2014 1
S_sv_2iuv_common(pTHX_ SV *sv)
d2294 1
a2294 1
Perl_sv_2iv_flags(pTHX_ register SV *sv, I32 flags)
d2378 1
a2378 1
Perl_sv_2uv_flags(pTHX_ register SV *sv, I32 flags)
d2455 1
a2455 1
Perl_sv_2nv(pTHX_ register SV *sv)
d2680 1
a2680 1
Perl_sv_2num(pTHX_ register SV *sv)
d2702 1
a2702 1
S_uiv_2buf(char *buf, IV iv, UV uv, int is_uv, char **peob)
d2741 1
a2741 1
Perl_sv_2pv_flags(pTHX_ register SV *sv, STRLEN *lp, I32 flags)
a2834 1
		MAGIC *mg;
d2840 20
a2859 16
		} else if (SvTYPE(referent) == SVt_PVMG
			   && ((SvFLAGS(referent) &
				(SVs_OBJECT|SVf_OK|SVs_GMG|SVs_SMG|SVs_RMG))
			       == (SVs_OBJECT|SVs_SMG))
			   && (mg = mg_find(referent, PERL_MAGIC_qr)))
                {
                    char *str = NULL;
                    I32 haseval = 0;
                    U32 flags = 0;
                    (str) = CALLREG_AS_STR(mg,lp,&flags,&haseval);
                    if (flags & 1)
	                SvUTF8_on(sv);
                    else
	                SvUTF8_off(sv);
                    PL_reginterp_cnt += haseval;
		    return str;
d2925 4
a2930 2
	    if (lp)
		*lp = 0;
d2981 23
a3003 2
	if (isGV_with_GP(sv))
	    return glob_2pv(MUTABLE_GV(sv), lp);
d3005 4
a3010 2
	if (lp)
	    *lp = 0;
d3047 1
a3047 1
Perl_sv_copypv(pTHX_ SV *dsv, register SV *ssv)
d3074 1
a3074 1
Perl_sv_2pvbyte(pTHX_ register SV *sv, STRLEN *lp)
d3094 1
a3094 1
Perl_sv_2pvutf8(pTHX_ register SV *sv, STRLEN *lp)
d3113 1
a3113 1
Perl_sv_2bool(pTHX_ register SV *sv)
d3189 30
d3222 1
a3222 1
Perl_sv_utf8_upgrade_flags(pTHX_ register SV *sv, I32 flags)
d3226 1
a3226 1
    PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS;
d3234 2
a3235 1
	    if (SvUTF8(sv))
d3237 1
d3244 1
d3252 1
a3252 1
    if (PL_encoding && !(flags & SV_UTF8_NO_ENCODING))
d3254 7
a3260 1
    else { /* Assume Latin-1/EBCDIC */
d3264 6
a3269 4
	 * make the loop as fast as possible. */
	const U8 * const s = (U8 *) SvPVX_const(sv);
	const U8 * const e = (U8 *) SvEND(sv);
	const U8 *t = s;
d3271 6
d3279 1
a3279 12
	    /* Check for variant */
	    if (!NATIVE_IS_INVARIANT(ch)) {
		STRLEN len = SvCUR(sv);
		/* *Currently* bytes_to_utf8() adds a '\0' after every string
		   it converts. This isn't documented. It's not clear if it's
		   a bad thing to be doing, and should be changed to do exactly
		   what the documentation says. If so, this code will have to
		   be changed.
		   As is, we mustn't rely on our incoming SV being well formed
		   and having a trailing '\0', as certain code in pp_formline
		   can send us partially built SVs. */
		U8 * const recoded = bytes_to_utf8((U8*)s, &len);
d3281 165
a3445 5
		SvPV_free(sv); /* No longer using what was there before. */
		SvPV_set(sv, (char*)recoded);
		SvCUR_set(sv, len);
		SvLEN_set(sv, len + 1); /* No longer know the real size. */
		break;
a3447 2
	/* Mark as UTF-8 even if no variant - saves scanning loop */
	SvUTF8_on(sv);
d3449 3
d3471 1
a3471 1
Perl_sv_utf8_downgrade(pTHX_ register SV* sv, bool fail_ok)
d3514 1
a3514 1
Perl_sv_utf8_encode(pTHX_ register SV *sv)
d3541 1
a3541 1
Perl_sv_utf8_decode(pTHX_ register SV *sv)
d3609 1
a3609 1
S_glob_assign_glob(pTHX_ SV *dstr, SV *sstr, const int dtype)
a3637 6
#ifdef GV_UNIQUE_CHECK
    if (GvUNIQUE((const GV *)dstr)) {
	Perl_croak(aTHX_ "%s", PL_no_modify);
    }
#endif

d3680 1
a3680 1
S_glob_assign_ref(pTHX_ SV *dstr, SV *sstr)
a3687 1
    bool mro_changes = FALSE;
a3690 6
#ifdef GV_UNIQUE_CHECK
    if (GvUNIQUE((const GV *)dstr)) {
	Perl_croak(aTHX_ "%s", PL_no_modify);
    }
#endif

a3707 2
        if (strEQ(GvNAME((GV*)dstr), "ISA"))
	    mro_changes = TRUE;
d3742 2
a3743 1
			    && cv_const_sv(cv) == cv_const_sv((CV*)sref)) {
d3756 2
a3757 1
						   cv_const_sv((CV*)sref))))) {
d3781 4
a3789 1
    if (mro_changes) mro_isa_changed_in(GvSTASH(dstr));
d3794 1
a3794 1
Perl_sv_setsv_flags(pTHX_ SV *dstr, register SV *sstr, I32 flags)
a3843 1
	    case SVt_RV:
d3861 5
a3865 1
	goto undef_sstr;
a3873 1
	    case SVt_RV:
a3891 4
    case SVt_RV:
	if (dtype < SVt_RV)
	    sv_upgrade(dstr, SVt_RV);
	break;
d3923 5
d4018 2
a4019 3
	    if (ckWARN(WARN_MISC))
		Perl_warner(aTHX_ packWARN(WARN_MISC),
			    "Undefined value assigned to typeglob");
d4030 3
d4090 1
a4090 1
		     && SvTYPE(sstr) >= SVt_PVIV))
a4173 1
	    SvOOK_off(dstr);
d4229 1
a4229 1
Perl_sv_setsv_mg(pTHX_ SV *dstr, register SV *sstr)
d4319 1
a4319 1
Perl_sv_setpvn(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
d4356 1
a4356 1
Perl_sv_setpvn_mg(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
d4374 1
a4374 1
Perl_sv_setpv(pTHX_ register SV *sv, register const char *ptr)
d4405 1
a4405 1
Perl_sv_setpv_mg(pTHX_ register SV *sv, register const char *ptr)
d4434 1
a4434 1
Perl_sv_usepvn_flags(pTHX_ SV *sv, char *ptr, STRLEN len, U32 flags)
d4550 1
a4550 1
Perl_sv_force_normal_flags(pTHX_ register SV *sv, U32 flags)
d4621 39
d4676 1
a4676 1
Perl_sv_chop(pTHX_ register SV *sv, register const char *ptr)
d4678 6
a4683 1
    register STRLEN delta;
a4700 1
    assert(ptr > SvPVX_const(sv));
a4701 4

    if (SvTYPE(sv) < SVt_PVIV)
	sv_upgrade(sv,SVt_PVIV);

a4706 1

a4714 4
	SvIV_set(sv, 0);
	/* Same SvOOK_on but SvOOK_on does a SvIOK_off
	   and we do that anyway inside the SvNIOK_off
	*/
d4716 3
a4719 1
    SvNIOK_off(sv);
d4723 5
a4727 1
    SvIV_set(sv, SvIVX(sv) + delta);
d4729 18
a4746 9
    {
	/* Fill the preceding buffer with sentinals to verify that no-one is
	   using it.  */
	U8 *p = (U8*) SvPVX(sv);
	const U8 *const real_start = p - SvIVX(sv);
	while (p > real_start) {
	    --p;
	    *p = (U8)PTR2UV(p);
	}
d4772 1
a4772 1
Perl_sv_catpvn_flags(pTHX_ register SV *dsv, register const char *sstr, register STRLEN slen, I32 flags)
d4809 1
a4809 1
Perl_sv_catsv_flags(pTHX_ SV *dsv, register SV *ssv, I32 flags)
d4842 2
a4843 1
		    sv_utf8_upgrade_nomg(dsv);
d4862 1
a4862 1
Perl_sv_catpv(pTHX_ register SV *sv, register const char *ptr)
d4893 1
a4893 1
Perl_sv_catpv_mg(pTHX_ register SV *sv, register const char *ptr)
d4919 1
a4919 1
Perl_newSV(pTHX_ STRLEN len)
d4951 2
a4952 2
Perl_sv_magicext(pTHX_ SV* sv, SV* obj, int how, const MGVTBL *vtable,
		 const char* name, I32 namlen)
a4974 1
	how == PERL_MAGIC_qr ||
d5040 2
a5041 1
Perl_sv_magic(pTHX_ register SV *sv, SV *obj, int how, const char *name, I32 namlen)
a5149 2
    case PERL_MAGIC_hints:
	/* As this vtable is all NULL, we can reuse it.  */
d5192 3
d5229 1
a5229 1
Perl_sv_unmagic(pTHX_ SV *sv, int type)
d5260 5
a5264 1
    if (!SvMAGIC(sv)) {
a5266 1
	SvMAGIC_set(sv, NULL);
a5267 1

d5284 1
a5284 1
Perl_sv_rvweaken(pTHX_ SV *sv)
d5295 1
a5295 2
	if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "Reference is already weak");
d5328 1
a5328 1
Perl_sv_add_backref(pTHX_ SV *tsv, SV *sv)
d5382 1
a5382 1
S_sv_del_backref(pTHX_ SV *tsv, SV *sv)
d5431 1
a5431 1
Perl_sv_kill_backrefs(pTHX_ SV *sv, AV *av)
d5583 1
a5583 1
Perl_sv_replace(pTHX_ register SV *sv, register SV *nsv)
d5592 2
a5593 2
	Perl_croak(aTHX_ "panic: reference miscount on nsv in sv_replace() (%"
		   UVuf " != 1)", (UV) SvREFCNT(nsv));
d5616 1
a5616 3
    /* Currently could join these into one piece of pointer arithmetic, but
       it would be unclear.  */
    if(SvTYPE(sv) == SVt_IV)
a5618 2
    else if (SvTYPE(sv) == SVt_RV) {
	SvANY(sv) = &sv->sv_u.svu_rv;
d5665 1
a5665 1
Perl_sv_clear(pTHX_ register SV *sv)
d5681 9
d5704 3
d5709 2
a5710 1
			|| CvSTART(destructor)->op_next->op_type != OP_LEAVESUB))
d5778 4
d5829 1
d5833 3
a5835 1
	    SvPV_set(sv, SvPVX_mutable(sv) - SvIVX(sv));
a5837 2
    case SVt_PV:
    case SVt_RV:
d5898 1
a5898 1
Perl_sv_newref(pTHX_ SV *sv)
d5918 1
a5918 1
Perl_sv_free(pTHX_ SV *sv)
d5966 1
a5966 1
Perl_sv_free2(pTHX_ SV *sv)
d5974 3
a5976 4
	if (ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
			"Attempt to free temp prematurely: SV 0x%"UVxf
                        pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
d6000 1
a6000 1
Perl_sv_len(pTHX_ register SV *sv)
d6033 1
a6033 1
Perl_sv_len_utf8(pTHX_ register SV *sv)
d6068 2
a6069 1
		    if (!mg) {
d6075 4
d6112 1
a6112 1
		      STRLEN uoffset, STRLEN uend)
d6142 2
a6143 2
S_sv_pos_u2b_cached(pTHX_ SV *sv, MAGIC **mgp, const U8 *const start,
		    const U8 *const send, STRLEN uoffset,
d6153 4
a6156 2
    if (SvMAGICAL(sv) && !SvREADONLY(sv) && PL_utf8cache
	&& (*mgp || (*mgp = mg_find(sv, PERL_MAGIC_utf8)))) {
d6247 1
a6247 1
=for apidoc sv_pos_u2b
d6252 3
a6254 2
the offset, rather than from the start of the string. Handles magic and
type coercion.
d6260 1
a6260 1
 * sv_pos_u2b() uses, like sv_pos_b2u(), the mg_ptr of the potential
d6266 3
a6268 2
void
Perl_sv_pos_u2b(pTHX_ register SV *sv, I32* offsetp, I32* lenp)
d6272 1
d6274 1
a6274 1
    PERL_ARGS_ASSERT_SV_POS_U2B;
d6276 1
a6276 4
    if (!sv)
	return;

    start = (U8*)SvPV_const(sv, len);
a6277 1
	STRLEN uoffset = (STRLEN) *offsetp;
d6280 1
a6280 4
	const STRLEN boffset = sv_pos_u2b_cached(sv, &mg, start, send,
					     uoffset, 0, 0);

	*offsetp = (I32) boffset;
d6284 1
a6284 1
	    const STRLEN uoffset2 = uoffset + (STRLEN) *lenp;
d6291 4
d6296 41
a6336 4
    else {
	 *offsetp = 0;
	 if (lenp)
	      *lenp = 0;
a6337 2

    return;
d6364 2
a6365 2
S_utf8_mg_pos_cache_update(pTHX_ SV *sv, MAGIC **mgp, STRLEN byte, STRLEN utf8,
			   STRLEN blen)
d6374 2
a6375 1
    if (!*mgp) {
d6388 7
a6394 1
    if (PL_utf8cache < 0) {
d6511 2
a6512 2
S_sv_pos_b2u_midway(pTHX_ const U8 *s, const U8 *const target, const U8 *end,
		    STRLEN endu)
d6550 1
a6550 1
Perl_sv_pos_b2u(pTHX_ register SV* sv, I32* offsetp)
d6572 5
a6576 2
    if (SvMAGICAL(sv) && !SvREADONLY(sv) && PL_utf8cache
	&& (mg = mg_find(sv, PERL_MAGIC_utf8))) {
d6757 1
a6757 1
Perl_sv_cmp(pTHX_ register SV *sv1, register SV *sv2)
d6839 1
a6839 1
Perl_sv_cmp_locale(pTHX_ register SV *sv1, register SV *sv2)
d6904 1
a6904 1
Perl_sv_collxfrm(pTHX_ SV *sv, STRLEN *nxp)
d6962 1
a6962 1
Perl_sv_gets(pTHX_ register SV *sv, register PerlIO *fp, I32 append)
d7329 1
a7329 1
Perl_sv_inc(pTHX_ register SV *sv)
d7383 7
d7391 1
a7391 1
        SvNV_set(sv, SvNVX(sv) + 1.0);
d7405 1
a7405 1
    if (*d) {
d7493 1
a7493 1
Perl_sv_dec(pTHX_ register SV *sv)
d7535 4
a7538 2
	    if (SvIVX(sv) == IV_MIN)
		sv_setnv(sv, (NV)IV_MIN - 1.0);
d7547 13
a7559 3
        SvNV_set(sv, SvNVX(sv) - 1.0);
	(void)SvNOK_only(sv);
	return;
d7605 10
d7632 1
a7632 1
Perl_sv_mortalcopy(pTHX_ SV *oldstr)
d7639 1
a7639 2
    EXTEND_MORTAL(1);
    PL_tmps_stack[++PL_tmps_ix] = sv;
d7663 1
a7663 2
    EXTEND_MORTAL(1);
    PL_tmps_stack[++PL_tmps_ix] = sv;
d7677 2
a7678 1
returning. If C<SVf_UTF8> is set, then it will be set on the new SV.
d7688 1
a7688 1
Perl_newSVpvn_flags(pTHX_ const char *s, STRLEN len, U32 flags)
d7698 16
a7713 2
    SvFLAGS(sv) |= (flags & SVf_UTF8);
    return (flags & SVs_TEMP) ? sv_2mortal(sv) : sv;
d7729 1
a7729 1
Perl_sv_2mortal(pTHX_ register SV *sv)
d7736 1
a7736 2
    EXTEND_MORTAL(1);
    PL_tmps_stack[++PL_tmps_ix] = sv;
d7752 1
a7752 1
Perl_newSVpv(pTHX_ const char *s, STRLEN len)
d7774 1
a7774 1
Perl_newSVpvn(pTHX_ const char *s, STRLEN len)
d7795 1
a7795 1
Perl_newSVhek(pTHX_ const HEK *hek)
d7913 1
a7913 1
Perl_newSVpvf_nocontext(const char* pat, ...)
d7938 1
a7938 1
Perl_newSVpvf(pTHX_ const char* pat, ...)
d7954 1
a7954 1
Perl_vnewSVpvf(pTHX_ const char* pat, va_list* args)
d7976 1
a7976 1
Perl_newSVnv(pTHX_ NV n)
d7996 1
a7996 1
Perl_newSViv(pTHX_ IV i)
d8016 1
a8016 1
Perl_newSVuv(pTHX_ UV u)
d8036 1
a8036 1
Perl_newSV_type(pTHX_ svtype type)
d8055 1
a8055 1
Perl_newRV_noinc(pTHX_ SV *tmpRef)
d8058 1
a8058 1
    register SV *sv = newSV_type(SVt_RV);
d8073 1
a8073 1
Perl_newRV(pTHX_ SV *sv)
d8092 1
a8092 1
Perl_newSVsv(pTHX_ register SV *old)
d8100 1
a8100 2
        if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "semi-panic: attempt to dup freed string");
d8121 1
a8121 1
Perl_sv_reset(pTHX_ register const char *s, HV *stash)
d8225 1
a8225 1
Perl_sv_2io(pTHX_ SV *sv)
d8267 1
a8267 1
The flags in C<lref> are passed to sv_fetchsv.
d8273 1
a8273 1
Perl_sv_2cv(pTHX_ SV *sv, HV **st, GV **gvp, I32 lref)
d8372 1
a8372 1
Perl_sv_true(pTHX_ register SV *sv)
d8417 1
a8417 1
Perl_sv_pvn_force_flags(pTHX_ SV *sv, STRLEN *lp, I32 flags)
d8478 1
a8478 1
Perl_sv_pvbyten_force(pTHX_ SV *sv, STRLEN *lp)
d8497 1
a8497 1
Perl_sv_pvutf8n_force(pTHX_ SV *sv, STRLEN *lp)
d8516 1
a8516 1
Perl_sv_reftype(pTHX_ const SV *sv, int ob)
a8530 1
	case SVt_RV:
d8555 1
d8596 1
a8596 1
Perl_sv_isa(pTHX_ SV *sv, const char *name)
d8629 1
a8629 1
Perl_newSVrv(pTHX_ SV *rv, const char *classname)
d8648 1
a8648 1
	sv_upgrade(rv, SVt_RV);
d8685 1
a8685 1
Perl_sv_setref_pv(pTHX_ SV *rv, const char *classname, void *pv)
d8713 1
a8713 1
Perl_sv_setref_iv(pTHX_ SV *rv, const char *classname, IV iv)
d8734 1
a8734 1
Perl_sv_setref_uv(pTHX_ SV *rv, const char *classname, UV uv)
d8755 1
a8755 1
Perl_sv_setref_nv(pTHX_ SV *rv, const char *classname, NV nv)
d8779 2
a8780 1
Perl_sv_setref_pvn(pTHX_ SV *rv, const char *classname, const char *pv, STRLEN n)
d8799 1
a8799 1
Perl_sv_bless(pTHX_ SV *sv, HV *stash)
d8844 1
a8844 1
S_sv_unglob(pTHX_ SV *sv)
d8902 1
a8902 1
Perl_sv_unref_flags(pTHX_ SV *ref, U32 flags)
d8932 1
a8932 1
Perl_sv_untaint(pTHX_ SV *sv)
d8951 1
a8951 1
Perl_sv_tainted(pTHX_ SV *sv)
d8973 1
a8973 1
Perl_sv_setpviv(pTHX_ SV *sv, IV iv)
d8993 1
a8993 1
Perl_sv_setpviv_mg(pTHX_ SV *sv, IV iv)
d9009 1
a9009 1
Perl_sv_setpvf_nocontext(SV *sv, const char* pat, ...)
d9027 1
a9027 1
Perl_sv_setpvf_mg_nocontext(SV *sv, const char* pat, ...)
d9050 1
a9050 1
Perl_sv_setpvf(pTHX_ SV *sv, const char* pat, ...)
d9073 1
a9073 1
Perl_sv_vsetpvf(pTHX_ SV *sv, const char* pat, va_list* args)
d9089 1
a9089 1
Perl_sv_setpvf_mg(pTHX_ SV *sv, const char* pat, ...)
d9111 1
a9111 1
Perl_sv_vsetpvf_mg(pTHX_ SV *sv, const char* pat, va_list* args)
d9127 1
a9127 1
Perl_sv_catpvf_nocontext(SV *sv, const char* pat, ...)
d9145 1
a9145 1
Perl_sv_catpvf_mg_nocontext(SV *sv, const char* pat, ...)
d9172 1
a9172 1
Perl_sv_catpvf(pTHX_ SV *sv, const char* pat, ...)
d9195 1
a9195 1
Perl_sv_vcatpvf(pTHX_ SV *sv, const char* pat, va_list* args)
d9211 1
a9211 1
Perl_sv_catpvf_mg(pTHX_ SV *sv, const char* pat, ...)
d9233 1
a9233 1
Perl_sv_vcatpvf_mg(pTHX_ SV *sv, const char* pat, va_list* args)
d9253 2
a9254 1
Perl_sv_vsetpvfn(pTHX_ SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *maybe_tainted)
d9262 16
d9279 1
a9279 1
S_expect_number(pTHX_ char** pattern)
d9302 1
a9302 1
S_F0convert(NV nv, char *endbuf, STRLEN *len)
d9352 2
a9353 1
Perl_sv_vcatpvfn(pTHX_ SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *maybe_tainted)
d9469 1
d9510 2
d9561 2
a9562 3
		    if (ckWARN_d(WARN_INTERNAL))
			Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			"internal %%<num>p might conflict with future printf extensions");
d9643 1
a9643 1
			? svargs[evix-1] : &PL_sv_undef;
d9645 2
a9646 1
		    vecsv = svix < svmax ? svargs[svix++] : &PL_sv_undef;
d9793 2
a9794 1
		argsv = (i >= 0 && i < svmax) ? svargs[i] : &PL_sv_undef;
d9797 1
a9797 1
		    ? svargs[svix++] : &PL_sv_undef;
a9828 6
#ifdef MACOS_TRADITIONAL
		  /* On MacOS, %#s format is used for Pascal strings */
		  if (alt)
		    elen = *eptr++;
		  else
#endif
d9903 1
d9905 3
a9907 1
		case 'q':	iv = va_arg(*args, Quad_t); break;
d9918 1
d9920 3
a9922 1
		case 'q':	iv = (Quad_t)tiv; break;
d9994 1
d9996 3
a9998 1
		case 'q':  uv = va_arg(*args, Uquad_t); break;
d10009 1
d10011 3
a10013 1
		case 'q':	uv = (Uquad_t)tuv; break;
d10299 1
d10301 3
a10303 1
		case 'q':	*(va_arg(*args, Quad_t*)) = i; break;
d10322 14
a10335 9
		if (c) {
		    if (isPRINT(c))
			Perl_sv_catpvf(aTHX_ msg,
				       "\"%%%c\"", c & 0xFF);
		    else
			Perl_sv_catpvf(aTHX_ msg,
				       "\"%%\\%03"UVof"\"",
				       (UV)c & 0xFF);
		} else
d10337 1
d10463 2
a10464 1
   If this changes, please unmerge ss_dup.  */
d10483 1
a10483 1
Perl_parser_dup(pTHX_ const yy_parser *proto, CLONE_PARAMS* param)
d10606 1
a10606 1
Perl_fp_dup(pTHX_ PerlIO *fp, char type, CLONE_PARAMS *param)
d10630 1
a10630 1
Perl_dirp_dup(pTHX_ DIR *dp)
d10642 1
a10642 1
Perl_gp_dup(pTHX_ GP *gp, CLONE_PARAMS* param)
d10678 1
a10678 1
Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS* param)
d10680 2
a10681 2
    MAGIC *mgprev = (MAGIC*)NULL;
    MAGIC *mgret;
a10684 7
    if (!mg)
	return (MAGIC*)NULL;
    /* look for it in the table first */
    mgret = (MAGIC*)ptr_table_fetch(PL_ptr_table, mg);
    if (mgret)
	return mgret;

d10687 15
a10701 3
	Newxz(nmg, 1, MAGIC);
	if (mgprev)
	    mgprev->mg_moremagic = nmg;
d10703 2
a10704 9
	    mgret = nmg;
	nmg->mg_virtual	= mg->mg_virtual;	/* XXX copy dynamic vtable? */
	nmg->mg_private	= mg->mg_private;
	nmg->mg_type	= mg->mg_type;
	nmg->mg_flags	= mg->mg_flags;
	if (mg->mg_type == PERL_MAGIC_qr) {
	    nmg->mg_obj	= MUTABLE_SV(CALLREGDUPE((REGEXP*)mg->mg_obj, param));
	}
	else if(mg->mg_type == PERL_MAGIC_backref) {
d10708 1
a10708 1
		= SvREFCNT_inc(av_dup_inc((const AV *) mg->mg_obj, param));
d10711 10
a10720 11
	    nmg->mg_obj	= (mg->mg_flags & MGf_REFCOUNTED)
			      ? sv_dup_inc(mg->mg_obj, param)
			      : sv_dup(mg->mg_obj, param);
	}
	nmg->mg_len	= mg->mg_len;
	nmg->mg_ptr	= mg->mg_ptr;	/* XXX random ptr? */
	if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
	    if (mg->mg_len > 0) {
		nmg->mg_ptr	= SAVEPVN(mg->mg_ptr, mg->mg_len);
		if (mg->mg_type == PERL_MAGIC_overload_table &&
			AMT_AMAGIC((AMT*)mg->mg_ptr))
a10721 1
		    const AMT * const amtp = (AMT*)mg->mg_ptr;
d10723 2
a10724 4
		    I32 i;
		    for (i = 1; i < NofAMmeth; i++) {
			namtp->table[i] = cv_dup_inc(amtp->table[i], param);
		    }
d10727 2
a10728 2
	    else if (mg->mg_len == HEf_SVKEY)
		nmg->mg_ptr = (char*)sv_dup_inc((const SV *)mg->mg_ptr, param);
d10730 1
a10730 1
	if ((mg->mg_flags & MGf_DUP) && mg->mg_virtual && mg->mg_virtual->svt_dup) {
a10732 1
	mgprev = nmg;
d10747 1
a10747 1
    Newxz(tbl, 1, PTR_TBL_t);
d10768 1
a10768 1
S_ptr_table_find(PTR_TBL_t *tbl, const void *sv)
d10784 1
a10784 1
Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *tbl, const void *sv)
d10797 1
a10797 1
Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, const void *oldsv, void *newsv)
d10824 1
a10824 1
Perl_ptr_table_split(pTHX_ PTR_TBL_t *tbl)
d10859 1
a10859 1
Perl_ptr_table_clear(pTHX_ PTR_TBL_t *tbl)
d10882 1
a10882 1
Perl_ptr_table_free(pTHX_ PTR_TBL_t *tbl)
d10895 1
a10895 1
Perl_rvpv_dup(pTHX_ SV *dstr, const SV *sstr, CLONE_PARAMS* param)
d10936 13
a10948 4
	if (SvTYPE(dstr) == SVt_RV)
	    SvRV_set(dstr, NULL);
	else
	    SvPV_set(dstr, NULL);
d10950 2
d10957 1
a10957 1
Perl_sv_dup(pTHX_ const SV *sstr, CLONE_PARAMS* param)
d11024 5
a11028 1
	SvIV_set(dstr, SvIVX(sstr));
a11033 4
    case SVt_RV:
	SvANY(dstr)	= &(dstr->sv_u.svu_rv);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	break;
a11048 3
		if (GvUNIQUE((const GV *)sstr)) {
		    NOOP;   /* Do sharing here, and fall through */
		}
d11055 1
d11110 4
d11127 2
a11128 1
		       table.  */
d11132 12
d11190 2
a11191 2
			while (items-- > 0)
			    *dst_ary++ = sv_dup_inc(*src_ary++, param);
d11196 5
d11209 3
a11211 3
		    AvALLOC(MUTABLE_AV(dstr))	= (SV**)NULL;
		    AvMAX(  MUTABLE_AV(dstr))	= -1;
		    AvFILLp(MUTABLE_AV(dstr))	= -1;
d11277 1
a11277 2
		    CvXSUBANY(dstr).any_ptr = GvUNIQUE(CvGV(dstr)) ?
			SvREFCNT_inc(CvXSUBANY(dstr).any_ptr) :
d11349 23
a11371 12
	    case CXt_LOOP:
		ncx->blk_loop.iterdata	= (CxPADLOOP(ncx)
					   ? ncx->blk_loop.iterdata
					   : gv_dup((const GV *)ncx->blk_loop.iterdata,
						    param));
		ncx->blk_loop.oldcomppad
		    = (PAD*)ptr_table_fetch(PL_ptr_table,
					    ncx->blk_loop.oldcomppad);
		ncx->blk_loop.iterlval	= sv_dup_inc(ncx->blk_loop.iterlval,
						     param);
		ncx->blk_loop.iterary	= av_dup_inc(ncx->blk_loop.iterary,
						     param);
d11374 3
a11376 3
		ncx->blk_sub.cv		= cv_dup(ncx->blk_sub.cv, param);
		ncx->blk_sub.gv		= gv_dup(ncx->blk_sub.gv, param);
		ncx->blk_sub.dfoutgv	= gv_dup_inc(ncx->blk_sub.dfoutgv,
a11671 2
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
d11679 2
d11775 1
a11775 13
	    TOPPTR(nss,ix) = ptr ? 
		    parser_dup((const yy_parser*)ptr, param) : NULL;
	    break;
	case SAVEt_PADSV:
	    /* Nothing should be using this any more, post the integration of
	       blead change 33080. But keep it, in case something out there is
	       generating these on the scope stack.  */
	    longval = (long)POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
d11792 1
a11792 1
do_mark_cloneable_stash(pTHX_ SV *sv)
d11907 8
d11920 1
a11920 1
#  ifdef DEBUGGING
d11926 1
d11933 4
a11936 1
#  else	/* !DEBUGGING */
d11938 1
a11938 1
#  endif	/* DEBUGGING */
d11940 1
d11951 1
a11951 11
#else		/* !PERL_IMPLICIT_SYS */
    IV i;
    CLONE_PARAMS clone_params;
    CLONE_PARAMS* param = &clone_params;
    PerlInterpreter * const my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));

    PERL_ARGS_ASSERT_PERL_CLONE;

    /* for each stash, determine whether its objects should be cloned */
    S_visit(proto_perl, do_mark_cloneable_stash, SVt_PVHV, SVTYPEMASK);
    PERL_SET_THX(my_perl);
a11952 16
#    ifdef DEBUGGING
    PoisonNew(my_perl, 1, PerlInterpreter);
    PL_op = NULL;
    PL_curcop = NULL;
    PL_markstack = 0;
    PL_scopestack = 0;
    PL_savestack = 0;
    PL_savestack_ix = 0;
    PL_savestack_max = -1;
    PL_sig_pending = 0;
    PL_parser = NULL;
    Zero(&PL_debug_pad, 1, struct perl_debug_pad);
#    else	/* !DEBUGGING */
    Zero(my_perl, 1, PerlInterpreter);
#    endif	/* DEBUGGING */
#endif		/* PERL_IMPLICIT_SYS */
d12012 3
a12069 1
    PL_preprocess	= proto_perl->Ipreprocess;
d12112 5
a12116 20
    PL_regex_padav = newAV();
    {
	const I32 len = av_len((AV*)proto_perl->Iregex_padav);
	SV* const * const regexen = AvARRAY((AV*)proto_perl->Iregex_padav);
	IV i;
	av_push(PL_regex_padav, sv_dup_inc_NN(regexen[0],param));
	for(i = 1; i <= len; i++) {
	    const SV * const regex = regexen[i];
	    SV * const sv =
		SvREPADTMP(regex)
		    ? sv_dup_inc(regex, param)
		    : SvREFCNT_inc(
			newSViv(PTR2IV(CALLREGDUPE(
				INT2PTR(REGEXP *, SvIVX(regex)), param))))
		;
	    if (SvFLAGS(regex) & SVf_BREAK)
		SvFLAGS(sv) |= SVf_BREAK; /* unrefcnted PL_curpm */
	    av_push(PL_regex_padav, sv);
	}
    }
d12120 1
a12140 1
    PL_dbargs		= av_dup(proto_perl->Idbargs, param);
d12262 1
a12262 2
    PL_parser		= proto_perl->Iparser ?
			    parser_dup(proto_perl->Iparser, param): NULL;
a12298 1
    PL_utf8_alnumc	= sv_dup_inc(proto_perl->Iutf8_alnumc, param);
d12311 10
a12368 1
    PL_bitcount		= NULL;	/* reinits on demand */
d12377 5
a12381 7
    if (proto_perl->Ipsig_ptr) {
	Newxz(PL_psig_ptr,  SIG_SIZE, SV*);
	Newxz(PL_psig_name, SIG_SIZE, SV*);
	for (i = 1; i < SIG_SIZE; i++) {
	    PL_psig_ptr[i]  = sv_dup_inc(proto_perl->Ipsig_ptr[i], param);
	    PL_psig_name[i] = sv_dup_inc(proto_perl->Ipsig_name[i], param);
	}
d12395 3
a12397 6
	Newxz(PL_tmps_stack, PL_tmps_max, SV*);
	i = 0;
	while (i <= PL_tmps_ix) {
	    PL_tmps_stack[i]	= sv_dup_inc(proto_perl->Itmps_stack[i], param);
	    ++i;
	}
d12416 4
d12453 1
a12453 2
		EXTEND_MORTAL(1);
		PL_tmps_stack[++PL_tmps_ix] = SvREFCNT_inc_simple(nsv);
d12465 1
a12465 1
    PL_na		= proto_perl->Ina;
a12478 1
    PL_ofs_sv		= sv_dup_inc(proto_perl->Iofs_sv, param);
d12520 2
d12708 1
a12708 1
S_find_hash_subscript(pTHX_ HV *hv, SV* val)
d12744 1
a12744 1
S_find_array_subscript(pTHX_ AV *av, SV* val)
d12777 2
a12778 2
S_varname(pTHX_ GV *gv, const char gvtype, PADOFFSET targ,
	SV* keyname, I32 aindex, int subscript_type)
d12853 2
a12854 1
S_find_uninit_var(pTHX_ OP* obase, SV* uninit_sv, bool match)
d12858 2
a12859 3
    AV *av;
    GV *gv;
    OP *o, *o2, *kid;
d12897 1
a12897 1
	    keysv = find_hash_subscript((HV*)sv, uninit_sv);
d12902 1
a12902 1
	    index = find_array_subscript((AV *)sv, uninit_sv);
d12930 1
a12930 1
		av = MUTABLE_AV(PAD_SV(obase->op_targ));
d12946 1
a12946 1
		av = GvAV(gv);
d13019 1
a13019 1
		SV * const keysv = find_hash_subscript((HV*)sv, uninit_sv);
d13026 1
a13026 1
		    = find_array_subscript((AV *)sv, uninit_sv);
d13159 1
a13159 1
    /* case OP_AEACH: not in 5.10.x */
d13182 8
d13255 1
a13255 1
Perl_report_uninit(pTHX_ SV* uninit_sv)
@


1.15
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 3
a5 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d10 10
a19 1
 * "I wonder what the Entish is for 'yes' and 'no'," he thought.
d160 1
a160 1
============================================================================ */
d172 3
d186 10
d198 3
d203 1
d208 1
d217 1
d221 7
d230 3
a234 1
	SvARENA_CHAIN(p) = (void *)PL_sv_root;		\
d236 4
a239 1
	PL_sv_root = (p);				\
d246 1
a246 1
	PL_sv_root = (SV*)SvARENA_CHAIN(p);		\
d278 1
a278 1
S_new_SV(pTHX)
d290 3
a292 3
    sv->sv_debug_line = (U16) (PL_parser
	    ?  PL_parser->copline == NOLINE
		?  PL_curcop
d295 1
a295 2
		: PL_parser->copline
	    : 0);
d299 7
a305 1
    
d308 1
a308 1
#  define new_SV(p) (p)=S_new_SV(aTHX)
d320 1
d341 3
d347 1
a347 1
	for (sva = PL_sv_arenaroot; sva; sva = (SV *) SvANY(sva)) {
d388 1
a388 1
    SV* const sva = (SV*)ptr;
d392 2
d405 1
a405 1
	SvARENA_CHAIN(sv) = (void *)(SV*)(sv + 1);
d414 1
a414 1
    SvARENA_CHAIN(sv) = 0;
d431 3
a433 1
    for (sva = PL_sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
d563 4
d650 1
a650 1
	svanext = (SV*) SvANY(sva);
d652 1
a652 1
	    svanext = (SV*) SvANY(svanext);
d786 1
a786 1
consequently dont need to actually exist.  They are declared because
d791 1
a791 1
For these types, the arenas are carved up into *_allocated size
d794 1
a794 1
size of the bit not allocated, so it's as if we allocated the full
d799 10
a808 6
We calculate the correction using the STRUCT_OFFSET macro. For
example, if xpv_allocated is the same structure as XPV then the two
OFFSETs sum to zero, and the pointer is unchanged. If the allocated
structure is smaller (no initial NV actually allocated) then the net
effect is to subtract the size of the NV from the pointer, to return a
new pointer as if an initial NV were actually allocated.
d842 1
a842 1
*_allocated body types, and is used in *_allocated macros.
d846 1
a846 1
vs the implementation in 5.8.7, making it table-driven.  All fields
a907 20
/* A macro to work out the offset needed to subtract from a pointer to (say)

typedef struct {
    STRLEN	xpv_cur;
    STRLEN	xpv_len;
} xpv_allocated;

to make its members accessible via a pointer to (say)

struct xpv {
    NV		xnv_nv;
    STRLEN	xpv_cur;
    STRLEN	xpv_len;
};

*/

#define relative_STRUCT_OFFSET(longer, shorter, member) \
    (STRUCT_OFFSET(shorter, member) - STRUCT_OFFSET(longer, member))

d914 1
a914 1
	+ sizeof (((type*)SvANY((SV*)0))->last_member)
d943 5
a947 5
    { sizeof(xpv_allocated),
      copy_length(XPV, xpv_len)
      - relative_STRUCT_OFFSET(xpv_allocated, XPV, xpv_cur),
      + relative_STRUCT_OFFSET(xpv_allocated, XPV, xpv_cur),
      SVt_PV, FALSE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpv_allocated)) },
d950 5
a954 5
    { sizeof(xpviv_allocated),
      copy_length(XPVIV, xiv_u)
      - relative_STRUCT_OFFSET(xpviv_allocated, XPVIV, xpv_cur),
      + relative_STRUCT_OFFSET(xpviv_allocated, XPVIV, xpv_cur),
      SVt_PVIV, FALSE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpviv_allocated)) },
d972 11
a982 11
    { sizeof(xpvav_allocated),
      copy_length(XPVAV, xmg_stash)
      - relative_STRUCT_OFFSET(xpvav_allocated, XPVAV, xav_fill),
      + relative_STRUCT_OFFSET(xpvav_allocated, XPVAV, xav_fill),
      SVt_PVAV, TRUE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpvav_allocated)) },

    { sizeof(xpvhv_allocated),
      copy_length(XPVHV, xmg_stash)
      - relative_STRUCT_OFFSET(xpvhv_allocated, XPVHV, xhv_fill),
      + relative_STRUCT_OFFSET(xpvhv_allocated, XPVHV, xhv_fill),
      SVt_PVHV, TRUE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpvhv_allocated)) },
d985 11
a995 7
    { sizeof(xpvcv_allocated), sizeof(xpvcv_allocated),
      + relative_STRUCT_OFFSET(xpvcv_allocated, XPVCV, xpv_cur),
      SVt_PVCV, TRUE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpvcv_allocated)) },

    { sizeof(xpvfm_allocated), sizeof(xpvfm_allocated),
      + relative_STRUCT_OFFSET(xpvfm_allocated, XPVFM, xpv_cur),
      SVt_PVFM, TRUE, NONV, NOARENA, FIT_ARENA(20, sizeof(xpvfm_allocated)) },
d1079 1
d1097 1
a1097 1
    start = (char*) Perl_get_arena(aTHX_ bdp->arena_size, sv_type);
d1099 1
a1099 1
    end = start + bdp->arena_size - body_size;
d1102 8
d1115 1
a1115 1

d1118 1
a1118 1
    while (start < end) {
d1174 2
a1182 5
    if (old_type > new_type)
	Perl_croak(aTHX_ "sv_upgrade from type %d down to type %d",
		(int)old_type, (int)new_type);


d1263 5
d1313 21
d1445 1
d1447 1
d1453 10
d1487 2
d1520 1
d1522 1
a1523 7
#ifdef MYMALLOC
	    const STRLEN l = malloced_size((void*)SvPVX_const(sv));
	    if (newlen <= l) {
		SvLEN_set(sv, l);
		return s;
	    } else
#endif
d1533 6
d1540 1
d1558 3
d1564 1
a1566 3
    case SVt_NV:
	sv_upgrade(sv, SVt_PVNV);
	break;
d1573 2
d1600 2
d1618 2
d1648 2
d1667 3
d1683 2
d1710 2
d1728 2
d1731 1
a1731 1
          dsv = sv_2mortal(newSVpvs(""));
d1809 2
d1828 2
d1851 2
d1951 5
a1955 1
S_sv_2iuv_non_preserve(pTHX_ register SV *sv, I32 numtype)
d1958 3
a1960 1
    PERL_UNUSED_ARG(numtype); /* Used only under DEBUGGING? */
d2006 2
a2007 1
S_sv_2iuv_common(pTHX_ SV *sv) {
d2009 3
d2045 5
a2049 1
		SvIOK_on(sv);  /* Can this go wrong with rounding? NWC */
d2088 1
d2242 1
d2244 3
d2250 6
d2260 1
a2260 1
	    return glob_2number((GV *)sv);
d2524 4
a2527 1
	SvNOK_on(sv);
d2531 2
a2532 1
	if (SvIsUV(sv) ? ((SvUVX(sv) != UV_MAX)&&(SvUVX(sv) == U_V(SvNVX(sv))))
d2551 4
a2554 1
	SvNOK_on(sv);
d2621 6
d2631 1
a2631 1
	    glob_2number((GV *)sv);
d2674 2
d2700 2
d2828 1
a2828 1
		const SV *const referent = (SV*)SvRV(sv);
d2940 1
a2940 1
	const int olderrno = errno;
d2954 1
a2954 1
	errno = olderrno;
d2969 1
a2969 1
	    return glob_2pv((GV *)sv, lp);
d3015 3
d3040 2
d3060 2
d3080 3
d3126 1
d3128 2
a3129 1
if all the bytes have hibit clear.
d3134 4
d3143 4
a3146 2
if all the bytes have hibit clear. If C<flags> has C<SV_GMAGIC> bit set,
will C<mg_get> on C<sv> if appropriate, else not. C<sv_utf8_upgrade> and
d3159 3
d3187 1
a3187 1
	 * had a FLAG in SVs to signal if there are any hibit
d3196 1
a3196 1
	    /* Check for hi bit */
d3198 9
a3206 1
		STRLEN len = SvCUR(sv) + 1; /* Plus the \0 */
d3211 2
a3212 2
		SvCUR_set(sv, len - 1);
		SvLEN_set(sv, len); /* No longer know the real size. */
d3216 1
a3216 1
	/* Mark as UTF-8 even if no hibit - saves scanning loop */
d3226 2
a3227 1
If the PV contains a character beyond byte, this conversion will fail;
d3241 3
d3283 2
d3289 1
a3289 1
	Perl_croak(aTHX_ PL_no_modify);
d3310 2
d3380 2
d3400 2
a3401 2
	    Perl_sv_add_backref(aTHX_ (SV*)GvSTASH(dstr), dstr);
	gv_name_set((GV *)dstr, name, len, GV_ADD);
d3406 2
a3407 2
    if (GvUNIQUE((GV*)dstr)) {
	Perl_croak(aTHX_ PL_no_modify);
d3411 1
a3411 1
    if(GvGP((GV*)sstr)) {
d3420 1
a3420 1
        else if(GvCV((GV*)sstr)) {
d3426 1
a3426 1
    if(!mro_changes && GvGP((GV*)dstr) && GvCVu((GV*)dstr)) {
d3430 1
a3430 1
    if(strEQ(GvNAME((GV*)dstr),"ISA"))
d3433 1
a3433 1
    gp_free((GV*)dstr);
d3453 2
a3454 1
S_glob_assign_ref(pTHX_ SV *dstr, SV *sstr) {
d3461 1
d3463 1
d3466 2
a3467 2
    if (GvUNIQUE((GV*)dstr)) {
	Perl_croak(aTHX_ PL_no_modify);
d3474 1
a3474 1
	GvEGV(dstr) = (GV*)dstr;
d3488 2
d3497 1
d3504 1
a3504 1
		/*if (GvCVGEN(dstr) && (GvCV(dstr) != (CV*)sref || GvCVGEN(dstr))) {*/
d3516 1
a3516 1
	    CV* const cv = (CV*)*location;
d3518 1
a3518 1
		if (!GvCVGEN((GV*)dstr) &&
d3523 1
a3523 1
			if (CvCONST(cv)	&& CvCONST((CV*)sref)
d3535 1
a3535 1
				     && (!CvCONST((CV*)sref)
d3543 2
a3544 2
					HvNAME_get(GvSTASH((GV*)dstr)),
					GvENAME((GV*)dstr));
d3548 1
a3548 1
		    cv_ckproto_len(cv, (GV*)dstr,
d3566 1
d3578 2
a3601 1
	SvRMAGICAL_off(dstr);
d3756 1
a3756 1
	    && SvTYPE(SvRV(sstr)) == SVt_PVGV) {
d3798 1
a3798 1
	    if (dstr != (SV*)gv) {
d3800 1
a3800 1
		    gp_free((GV*)dstr);
a3884 6
                /* I believe I should acquire a global SV mutex if
                   it's a COW sv (not a shared hash key) to stop
                   it going un copy-on-write.
                   If the source SV has gone un copy on write between up there
                   and down here, then (assert() that) it is of the correct
                   form to make it copy on write again */
a3926 1
                /* Relesase a global SV mutex.  */
d3983 1
a3983 1
	    gv_efullname3(dstr, (GV *)sstr, "*");
d4004 2
d4018 2
d4097 2
d4131 2
d4152 2
d4180 2
d4211 3
d4231 6
a4236 1
	? len + 1: PERL_STRLEN_ROUNDUP(len + 1);
d4252 6
a4258 2
    SvCUR_set(sv, len);
    SvLEN_set(sv, allocate);
d4277 2
d4326 3
a4330 1
        /* At this point I believe I should acquire a global SV mutex.  */
d4370 1
a4370 2
	    Perl_croak(aTHX_ PL_no_modify);
        /* At this point I believe that I can drop the global SV mutex.  */
d4387 1
a4387 1
	    Perl_croak(aTHX_ PL_no_modify);
d4413 4
d4420 11
d4432 1
d4436 6
d4461 12
d4502 2
d4536 4
a4539 1
    if (ssv) {
d4560 1
a4560 1
		    SV* const csv = sv_2mortal(newSVpvn(spv, slen));
d4592 2
d4618 2
d4680 2
d4701 3
a4703 3
	    (GvSV(obj) == sv || GvHV(obj) == (HV*)sv || GvAV(obj) == (AV*)sv ||
	    GvCV(obj) == (CV*)sv || GvIOp(obj) == (IO*)sv ||
	    GvFORM(obj) == (CV*)sv)))
d4721 1
a4721 1
        obj && SvROK(obj) && GvIO(SvRV(obj)) == (IO*)sv)
d4731 7
a4737 3
	else if (namlen == HEf_SVKEY)
	    mg->mg_ptr = (char*)SvREFCNT_inc_simple_NN((SV*)name);
	else
d4770 2
d4790 1
a4790 1
	    Perl_croak(aTHX_ PL_no_modify);
d4955 3
d4971 1
a4971 1
		    SvREFCNT_dec((SV*)mg->mg_ptr);
d5007 3
d5030 18
d5054 2
d5057 1
a5057 1
	AV **const avp = Perl_hv_backreferences_p(aTHX_ (HV*)tsv);
d5066 1
a5066 1
		av = (AV*)mg->mg_obj;
d5076 1
a5076 1
		SvREFCNT_inc_simple_void(av);
d5084 1
a5084 1
	    av = (AV*)mg->mg_obj;
d5088 2
a5089 4
	    sv_magic(tsv, (SV*)av, PERL_MAGIC_backref, NULL, 0);
	    /* av now has a refcnt of 2, which avoids it getting freed
	     * before us during global cleanup. The extra ref is removed
	     * by magic_killbackrefs() when tsv is being freed */
d5110 2
d5113 1
a5113 1
	av = *Perl_hv_backreferences_p(aTHX_ (HV*)tsv);
d5123 1
a5123 1
	    av = (AV *)mg->mg_obj;
d5125 2
a5126 3
    if (!av) {
	if (PL_in_clean_all)
	    return;
a5127 1
    }
d5129 1
a5129 2
    if (SvIS_FREED(av))
	return;
d5156 1
d5159 2
a5160 3
    /* Not sure why the av can get freed ahead of its sv, but somehow it does
       in ext/B/t/bytecode.t test 15 (involving print <DATA>)  */
    if (svp && !SvIS_FREED(av)) {
d5176 1
a5176 1
		    assert(GvSTASH(referrer) == (HV*)sv);
d5197 5
a5201 1
the Perl substr() function.
d5207 1
a5207 1
Perl_sv_insert(pTHX_ SV *bigstr, STRLEN offset, STRLEN len, const char *little, STRLEN littlelen)
d5217 1
d5221 1
a5221 1
    SvPV_force(bigstr, curlen);
d5274 1
a5275 3
	big += i;
	while (i--)
	    *--midend = *--big;
d5308 3
d5398 1
a5398 1
    assert(sv);
d5400 1
d5419 5
a5423 1
		if (destructor) {
d5432 1
a5432 1
		    call_sv((SV*)destructor, G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
d5481 1
a5481 1
	    io_close((IO*)sv, FALSE);
d5492 1
a5492 1
	cv_undef((CV*)sv);
d5495 5
a5499 2
	Perl_hv_kill_backrefs(aTHX_ (HV*)sv);
	hv_undef((HV*)sv);
d5502 1
a5502 1
	if (PL_comppad == (AV*)sv) {
d5506 1
a5506 1
	av_undef((AV*)sv);
d5518 2
a5519 1
            if(GvCVu((GV*)sv) && (stash = GvSTASH((GV*)sv)) && HvNAME_get(stash))
d5521 1
a5521 1
	    gp_free((GV*)sv);
d5527 1
a5527 1
		    sv_del_backref((SV*)stash, sv);
d5532 1
a5532 1
	if ((GV*)sv == PL_last_in_gv)
a5554 2
                /* I believe I need to grab the global SV mutex here and
                   then recheck the COW status.  */
a5564 1
                /* And drop it here.  */
a5642 3
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                        "Attempt to free unreferenced scalar: SV 0x%"UVxf
                        pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
d5647 1
a5647 1
	sv_dump(sv);
d5649 11
d5662 3
d5676 3
d5732 1
a5732 1
 * The length is cached in PERL_UTF8_magic, in the mg_len field.  Also the
d5798 2
d5818 3
d5847 2
a5848 1
		    STRLEN uoffset0, STRLEN boffset0) {
d5852 2
d5941 2
a5942 1
    S_utf8_mg_pos_cache_update(aTHX_ sv, mgp, boffset, uoffset, send - start);
d5961 1
a5961 1
 * PERL_UTF8_magic of the sv to store the mapping between UTF-8 and
d5972 2
d6034 3
d6176 2
d6204 1
a6204 1
 * PERL_UTF8_magic of the sv to store the mapping between UTF-8 and
d6219 2
d6297 2
a6298 1
    S_utf8_mg_pos_cache_update(aTHX_ sv, &mg, byte, len, blen);
d6332 1
a6332 2
	    sv1 = sv_2mortal(newSVpvn(pv1, cur1));
	    if (SvUTF8(sv2)) SvUTF8_on(sv1);
d6489 1
a6489 1
if necessary.  See also C<sv_cmp_locale>.  See also C<sv_cmp>.
d6565 2
a6576 5
	    if (SvREADONLY(sv)) {
		SAVEFREEPV(xf);
		*nxp = xlen;
		return xf + sizeof(PL_collation_ix);
	    }
d6629 2
d6688 3
d6702 7
a6708 1
      bytesread = PerlLIO_read(PerlIO_fileno(fp), buffer, recsize);
d6714 1
a6714 1
      SvCUR_set(sv, bytesread += append);
d6999 1
a6999 1
		Perl_croak(aTHX_ PL_no_modify);
d7155 1
a7155 1
		Perl_croak(aTHX_ PL_no_modify);
d7296 34
a7398 1

d7503 2
d7533 3
d7557 3
d7573 3
d7674 3
d7691 3
d7742 2
d7748 1
a7748 1
	MAGIC * const mg = mg_find((SV *)stash, PERL_MAGIC_symtab);
d7793 1
a7793 1
		gv = (GV*)HeVAL(entry);
d7846 2
d7850 1
a7850 1
	io = (IO*)sv;
d7853 8
a7860 5
	gv = (GV*)sv;
	io = GvIO(gv);
	if (!io)
	    Perl_croak(aTHX_ "Bad filehandle: %s", GvNAME(gv));
	break;
d7895 2
d7906 1
a7906 1
	return (CV*)sv;
d7913 7
a7919 4
	gv = (GV*)sv;
	*gvp = gv;
	*st = GvESTASH(gv);
	goto fix_gv;
a7921 1
	SvGETMAGIC(sv);
d7924 1
d7929 1
a7929 1
		cv = (CV*)sv;
d7934 2
a7935 2
	    else if(isGV(sv))
		gv = (GV*)sv;
d7939 4
a7942 2
	else if (isGV(sv))
	    gv = (GV*)sv;
d7944 1
a7944 1
	    gv = gv_fetchsv(sv, lref, SVt_PVCV);
d7951 1
a7951 1
	if (SvTYPE(gv) != SVt_PVGV) {
d7971 1
a7971 1
			   SVfARG(sv));
d8036 3
d8058 2
a8059 1
	if (SvTYPE(sv) > SVt_PVLV && SvTYPE(sv) != SVt_PVFM)
d8096 2
d8115 2
d8134 2
d8167 2
a8168 1
	case SVt_PVGV:		return "GLOB";
d8195 1
a8195 1
    sv = (SV*)SvRV(sv);
d8215 3
d8223 1
a8223 1
    sv = (SV*)SvRV(sv);
d8250 2
d8267 2
a8268 6
    } else if (SvTYPE(rv) < SVt_RV)
	sv_upgrade(rv, SVt_RV);
    else if (SvTYPE(rv) > SVt_RV) {
	SvPV_free(rv);
	SvCUR_set(rv, 0);
	SvLEN_set(rv, 0);
d8304 3
d8331 2
d8352 2
d8373 2
d8397 2
d8418 3
d8428 1
a8428 1
	    Perl_croak(aTHX_ PL_no_modify);
d8439 1
a8439 1
    SvSTASH_set(tmpRef, (HV*)SvREFCNT_inc_simple(stash));
d8466 2
d8470 1
a8470 1
    gv_efullname3(temp, (GV *) sv, "*");
d8473 2
a8474 1
        if(GvCVu((GV*)sv) && (stash = GvSTASH((GV*)sv)) && HvNAME_get(stash))
d8476 1
a8476 1
	gp_free((GV*)sv);
d8479 1
a8479 1
	sv_del_backref((SV*)GvSTASH(sv), sv);
d8521 2
d8549 2
d8568 2
d8594 2
d8610 2
d8628 3
d8646 3
d8668 3
d8690 2
d8707 3
d8728 2
d8746 3
d8764 3
d8790 3
d8812 2
d8829 3
d8850 2
d8870 3
a8872 1
    sv_setpvn(sv, "", 0);
d8881 3
d8905 2
d8970 1
d8991 1
a8991 1
	argsv = (SV*)va_arg(*args, void*);
d9148 1
a9148 1
		    argsv = (SV*)va_arg(*args, void*);
d9268 1
a9268 1
		    if ( hv_exists((HV*)SvRV(vecsv), "alpha", 5 ) ) {
d9437 1
a9437 1
		    I32 old_precis = precis;
d9439 2
a9440 1
			I32 p = precis;
d9455 1
a9455 1
	    if (has_precis && elen > precis)
d9943 1
a9943 1
		SV * const nsv = sv_2mortal(newSVpvn(eptr, elen));
d9957 1
a9957 1
	    Perl_croak_nocontext(PL_memory_wrap);
d9963 1
a9963 1
	    Perl_croak_nocontext(PL_memory_wrap);
d10028 1
a10028 1
============================================================================*/
d10044 10
a10053 10
#define av_dup(s,t)	(AV*)sv_dup((SV*)s,t)
#define av_dup_inc(s,t)	(AV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define hv_dup(s,t)	(HV*)sv_dup((SV*)s,t)
#define hv_dup_inc(s,t)	(HV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define cv_dup(s,t)	(CV*)sv_dup((SV*)s,t)
#define cv_dup_inc(s,t)	(CV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define io_dup(s,t)	(IO*)sv_dup((SV*)s,t)
#define io_dup_inc(s,t)	(IO*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define gv_dup(s,t)	(GV*)sv_dup((SV*)s,t)
#define gv_dup_inc(s,t)	(GV*)SvREFCNT_inc(sv_dup((SV*)s,t))
d10064 2
d10172 4
d10187 1
d10223 2
d10237 2
a10238 1
    ret->gp_refcnt	= 0;			/* must be before any other dups! */
d10259 3
d10281 1
a10281 1
	    nmg->mg_obj	= (SV*)CALLREGDUPE((REGEXP*)mg->mg_obj, param);
d10286 2
a10287 1
	    nmg->mg_obj = SvREFCNT_inc(av_dup_inc((AV*) mg->mg_obj, param));
d10311 1
a10311 1
		nmg->mg_ptr	= (char*)sv_dup_inc((SV*)mg->mg_ptr, param);
d10352 2
a10353 1
S_ptr_table_find(PTR_TBL_t *tbl, const void *sv) {
d10356 3
a10358 1
    assert(tbl);
d10371 2
d10374 1
d10384 2
d10414 2
d10481 2
d10485 2
a10486 2
		       ? sv_dup(SvRV(sstr), param)
		       : sv_dup_inc(SvRV(sstr), param));
d10514 1
a10514 1
		SvPV_set(dstr, SvPVX(sstr));		
d10535 8
a10542 1
    if (!sstr || SvTYPE(sstr) == SVTYPEMASK)
d10544 1
d10546 1
a10546 1
    dstr = (SV*)ptr_table_fetch(PL_ptr_table, sstr);
d10557 1
a10557 1
		return (SV*)gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname), 0);
d10622 1
a10622 1
		if (GvUNIQUE((GV*)sstr)) {
d10690 1
a10690 1
		    LvTARG(dstr) = (SV*)he_dup((HE*)LvTARG(dstr), 0, param);
d10695 1
a10695 2
		    if (GvNAME_HEK(dstr))
			GvNAME_HEK(dstr) = hek_dup(GvNAME_HEK(dstr), param);
d10737 2
a10738 1
		if (AvARRAY((AV*)sstr)) {
d10740 1
a10740 1
		    SSize_t items = AvFILLp((AV*)sstr) + 1;
d10742 2
a10743 2
		    src_ary = AvARRAY((AV*)sstr);
		    Newxz(dst_ary, AvMAX((AV*)sstr)+1, SV*);
d10745 3
a10747 3
		    AvARRAY((AV*)dstr) = dst_ary;
		    AvALLOC((AV*)dstr) = dst_ary;
		    if (AvREAL((AV*)sstr)) {
d10755 1
a10755 1
		    items = AvMAX((AV*)sstr) - AvFILLp((AV*)sstr);
d10761 4
a10764 2
		    AvARRAY((AV*)dstr)	= NULL;
		    AvALLOC((AV*)dstr)	= (SV**)NULL;
d10768 1
a10768 1
		if (HvARRAY((HV*)sstr)) {
d10793 1
a10793 1
			daux->xhv_name = hvname ? hek_dup(hvname, param) : hvname;
d10799 1
d10802 2
a10803 2
				? (AV*) SvREFCNT_inc(
					sv_dup((SV*)saux->xhv_backreferences, param))
d10816 1
a10816 1
		    HvARRAY((HV*)dstr) = NULL;
d10832 1
a10832 1
			sv_dup_inc((SV *)CvXSUBANY(dstr).any_ptr, param);
d10863 2
d10874 1
a10874 1
    Newxz(ncxs, max + 1, PERL_CONTEXT);
d10876 1
a10878 1
	PERL_CONTEXT * const cx = &cxs[ix];
d10880 1
a10880 2
	ncx->cx_type	= cx->cx_type;
	if (CxTYPE(cx) == CXt_SUBST) {
d10884 1
a10884 7
	    ncx->blk_oldsp	= cx->blk_oldsp;
	    ncx->blk_oldcop	= cx->blk_oldcop;
	    ncx->blk_oldmarksp	= cx->blk_oldmarksp;
	    ncx->blk_oldscopesp	= cx->blk_oldscopesp;
	    ncx->blk_oldpm	= cx->blk_oldpm;
	    ncx->blk_gimme	= cx->blk_gimme;
	    switch (CxTYPE(cx)) {
d10886 6
a10891 5
		ncx->blk_sub.cv		= (cx->blk_sub.olddepth == 0
					   ? cv_dup_inc(cx->blk_sub.cv, param)
					   : cv_dup(cx->blk_sub.cv,param));
		ncx->blk_sub.argarray	= (cx->blk_sub.hasargs
					   ? av_dup_inc(cx->blk_sub.argarray, param)
d10893 2
a10894 5
		ncx->blk_sub.savearray	= av_dup_inc(cx->blk_sub.savearray, param);
		ncx->blk_sub.olddepth	= cx->blk_sub.olddepth;
		ncx->blk_sub.hasargs	= cx->blk_sub.hasargs;
		ncx->blk_sub.lval	= cx->blk_sub.lval;
		ncx->blk_sub.retop	= cx->blk_sub.retop;
d10896 1
a10896 1
					   cx->blk_sub.oldcomppad);
d10899 3
a10901 6
		ncx->blk_eval.old_in_eval = cx->blk_eval.old_in_eval;
		ncx->blk_eval.old_op_type = cx->blk_eval.old_op_type;
		ncx->blk_eval.old_namesv = sv_dup_inc(cx->blk_eval.old_namesv, param);
		ncx->blk_eval.old_eval_root = cx->blk_eval.old_eval_root;
		ncx->blk_eval.cur_text	= sv_dup(cx->blk_eval.cur_text, param);
		ncx->blk_eval.retop = cx->blk_eval.retop;
d10904 4
a10907 6
		ncx->blk_loop.label	= cx->blk_loop.label;
		ncx->blk_loop.resetsp	= cx->blk_loop.resetsp;
		ncx->blk_loop.my_op	= cx->blk_loop.my_op;
		ncx->blk_loop.iterdata	= (CxPADLOOP(cx)
					   ? cx->blk_loop.iterdata
					   : gv_dup((GV*)cx->blk_loop.iterdata, param));
d10910 5
a10914 6
					    cx->blk_loop.oldcomppad);
		ncx->blk_loop.itersave	= sv_dup_inc(cx->blk_loop.itersave, param);
		ncx->blk_loop.iterlval	= sv_dup_inc(cx->blk_loop.iterlval, param);
		ncx->blk_loop.iterary	= av_dup_inc(cx->blk_loop.iterary, param);
		ncx->blk_loop.iterix	= cx->blk_loop.iterix;
		ncx->blk_loop.itermax	= cx->blk_loop.itermax;
d10917 4
a10920 5
		ncx->blk_sub.cv		= cv_dup(cx->blk_sub.cv, param);
		ncx->blk_sub.gv		= gv_dup(cx->blk_sub.gv, param);
		ncx->blk_sub.dfoutgv	= gv_dup_inc(cx->blk_sub.dfoutgv, param);
		ncx->blk_sub.hasargs	= cx->blk_sub.hasargs;
		ncx->blk_sub.retop	= cx->blk_sub.retop;
d10939 2
d10994 2
d11024 4
a11027 4
    SV *sv;
    GV *gv;
    AV *av;
    HV *hv;
d11038 2
d11047 1
a11047 1
	    sv = (SV*)POPPTR(ss,ix);
d11052 1
a11052 1
	    sv = (SV*)POPPTR(ss,ix);
d11057 1
a11057 1
	    sv = (SV*)POPPTR(ss,ix);
d11068 1
a11068 1
	    sv = (SV*)POPPTR(ss,ix);
d11075 1
a11075 1
	    sv = (SV*) POPPTR(ss,ix);
d11080 1
a11080 1
	    sv = (SV*) POPPTR(ss,ix);
d11117 1
a11117 1
	    sv = (SV*)POPPTR(ss,ix);
d11137 1
a11137 1
	    gv = (GV*)POPPTR(ss,ix);
d11166 6
a11175 6
	case SAVEt_DELETE:
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup_inc(c);
	    /* fall through */
d11203 1
a11203 1
	    sv = (SV*)POPPTR(ss,ix);
d11207 1
a11207 1
	    av = (AV*)POPPTR(ss,ix);
d11225 1
a11225 1
		hv = (HV*)POPPTR(ss,ix);
d11229 1
a11229 1
	case SAVEt_PADSV:
d11234 2
a11235 2
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
d11248 1
a11248 1
	    sv = (SV*)POPPTR(ss,ix);
d11318 13
a11330 1
	    TOPPTR(nss,ix) = parser_dup((const yy_parser*)ptr, param);
d11349 1
a11349 1
    const HEK * const hvname = HvNAME_HEK((HV*)sv);
d11351 1
a11351 1
	GV* const cloner = gv_fetchmethod_autoload((HV*)sv, "CLONE_SKIP", 0);
d11360 1
a11360 1
	    XPUSHs(sv_2mortal(newSVhek(hvname)));
d11362 1
a11362 1
	    call_sv((SV*)GvCV(cloner), G_SCALAR);
d11423 2
d11460 3
d11498 3
d11667 3
a11669 3
    sv_setpvn(PERL_DEBUG_PAD(0), "", 0);	/* For regex debugging. */
    sv_setpvn(PERL_DEBUG_PAD(1), "", 0);	/* ext/re needs these */
    sv_setpvn(PERL_DEBUG_PAD(2), "", 0);	/* even without DEBUGGING. */
d11843 9
a11851 1
    PL_parser		= parser_dup(proto_perl->Iparser, param);
d12025 2
a12026 2
	    SV * const nsv = (SV*)ptr_table_fetch(PL_ptr_table,
		    proto_perl->Itmps_stack[i]);
d12110 1
a12110 4
    if (!(flags & CLONEf_KEEP_PTR_TABLE)) {
        ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;
    }
d12116 1
a12116 1
	HV* const stash = (HV*) av_shift(param->stashes);
d12123 1
a12123 1
	    XPUSHs(sv_2mortal(newSVhek(HvNAME_HEK(stash))));
d12125 1
a12125 1
	    call_sv((SV*)GvCV(cloner), G_DISCARD);
d12131 6
d12172 3
d12237 3
d12251 3
a12253 2
	XPUSHs(offsv = sv_2mortal(newSViv(*offset)));
	XPUSHs(sv_2mortal(newSVpvn(tstr, tlen)));
d12289 2
d12309 1
a12309 1
	    return sv_2mortal(newSVpvn(HeKEY(entry), HeKLEN(entry)));
d12322 3
d12382 1
a12382 1
	av = (AV*)(*av_fetch(CvPADLIST(cv), 0, FALSE));
d12398 4
a12401 2
    else if (subscript_type == FUV_SUBSCRIPT_WITHIN)
	Perl_sv_insert(aTHX_ name, 0, 0,  STR_WITH_LEN("within "));
d12463 1
a12463 1
		sv = hash ? (SV*)GvHV(gv): (SV*)GvAV(gv);
d12477 1
a12477 1
	    index = find_array_subscript((AV*)sv, uninit_sv);
d12505 1
a12505 1
		av = (AV*)PAD_SV(obase->op_targ);
d12561 2
a12562 1
	    sv = o->op_type == OP_RV2HV ? (SV*)GvHV(gv) : (SV*)GvAV(gv);
d12573 1
a12573 1
		    HE* he = hv_fetch_ent((HV*)sv, cSVOPx_sv(kid), 0, 0);
d12578 1
a12578 1
		    SV * const * const svp = av_fetch((AV*)sv, SvIV(cSVOPx_sv(kid)), FALSE);
d12600 2
a12601 1
		const I32 index = find_array_subscript((AV*)sv, uninit_sv);
d12652 1
a12652 1
		sv_setpvn(sv, "$_", 2);
d12661 1
d12669 1
d12671 75
a12745 2
    case OP_CUSTOM:
	match = 1; /* XS or custom code could trigger random warnings */
d12757 1
d12766 1
a12766 1
	    return sv_2mortal(newSVpvs("${$/}"));
@


1.14
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d33 1
a33 7
/* The cache element 0 is the Unicode offset;
 * the cache element 1 is the byte offset of the element 0;
 * the cache element 2 is the Unicode length of the substring;
 * the cache element 3 is the byte length of the substring;
 * The checking of the substring side would be good
 * but substr() has enough code paths to make my head spin;
 * if adding more checks watch out for the following tests:
d38 5
a42 2
#define ASSERT_UTF8_CACHE(cache) \
	STMT_START { if (cache) { assert((cache)[0] <= (cache)[1]); } } STMT_END
d44 8
a51 1
#define ASSERT_UTF8_CACHE(cache) NOOP
d58 21
a78 12
An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv,
av, hv...) contains type and reference count information, as well as a
pointer to the body (struct xrv, xpv, xpviv...), which contains fields
specific to each type.

Normally, this allocation is done using arenas, which by default are
approximately 4K chunks of memory parcelled up into N heads or bodies.  The
first slot in each arena is reserved, and is used to hold a link to the next
arena.  In the case of heads, the unused first slot also contains some flags
and a note of the number of slots.  Snaked through each arena chain is a
linked list of free items; when this becomes empty, an extra arena is
allocated and divided up into N items which are threaded into the free list.
d85 8
a92 11
    PL_foo_arenaroot	pointer to list of foo arenas,
    PL_foo_root		pointer to list of free foo bodies
			    ... for foo in xiv, xnv, xrv, xpv etc.

Note that some of the larger and more rarely used body types (eg xpvio)
are not allocated using arenas, but are instead just malloc()/free()ed as
required. Also, if PURIFY is defined, arenas are abandoned altogether,
with all items individually malloc()ed. In addition, a few SV heads are
not allocated from an arena, but are instead directly created as static
or auto variables, eg PL_sv_undef.  The size of arenas can be changed from
the default by setting PERL_ARENA_SIZE appropriately at compile time.
a102 7
Similarly, there are macros new_XIV()/del_XIV(), new_XNV()/del_XNV() etc
that allocate and return individual body types. Normally these are mapped
to the arena-manipulating functions new_xiv()/del_xiv() etc, but may be
instead mapped directly to malloc()/free() if PURIFY is defined. The
new/del functions remove from, or add to, the appropriate PL_foo_root
list, and call more_xiv() etc to add a new arena if the list is empty.

d105 1
a105 6
start of the interpreter.  Note that this also clears PL_he_arenaroot,
which is otherwise dealt with in hv.c.

Manipulation of any of the PL_*root pointers is protected by enclosing
LOCK_SV_MUTEX; ... UNLOCK_SV_MUTEX calls which should Do the Right Thing
if threads are enabled.
d114 1
a114 1
    			dump all remaining SVs (debugging aid)
d134 1
a134 1
=head2 Summary
a147 1

a151 2


a155 4
/*
 * nice_chunk and nice_chunk size need to be set
 * and queried under the protection of sv_mutex
 */
d159 1
a161 1
    LOCK_SV_MUTEX;
a170 1
    UNLOCK_SV_MUTEX;
d173 19
d194 3
a196 1
	SvANY(p) = (void *)PL_sv_root;			\
a201 1
/* sv_mutex must be held while calling uproot_SV() */
d205 1
a205 1
	PL_sv_root = (SV*)SvANY(p);			\
a211 1
/* sv_mutex must be held while calling more_sv() */
d215 1
d220 1
a220 1
	PL_nice_chunk = Nullch;
d225 1
a225 1
	Newx(chunk,PERL_ARENA_SIZE,char);   /* Safefree() in sv_free_arenas()     */
a240 1
    LOCK_SV_MUTEX;
a244 1
    UNLOCK_SV_MUTEX;
d248 12
a266 1
	LOCK_SV_MUTEX;					\
a270 1
	UNLOCK_SV_MUTEX;				\
a283 1
	LOCK_SV_MUTEX;					\
a287 1
	UNLOCK_SV_MUTEX;				\
d293 1
d337 2
a338 1
    SV* sva = (SV*)ptr;
d353 1
a353 1
	SvANY(sv) = (void *)(SV*)(sv + 1);
d357 1
a357 1
	/* Must always set typemask because it's awlays checked in on cleanup
d362 1
a362 1
    SvANY(sv) = 0;
d375 1
d422 2
d430 1
a430 1
do_clean_objs(pTHX_ SV *sv)
d432 15
a446 12
    SV* rv;

    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
	DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(sv)));
	if (SvWEAKREF(sv)) {
	    sv_del_backref(sv);
	    SvWEAKREF_off(sv);
	    SvRV_set(sv, NULL);
	} else {
	    SvROK_off(sv);
	    SvRV_set(sv, NULL);
	    SvREFCNT_dec(rv);
d459 4
a462 1
    if (SvTYPE(sv) == SVt_PVGV && GvGP(sv)) {
d470 2
a471 1
	     (GvIO(sv) && SvOBJECT(GvIO(sv))) ||
d493 1
d498 1
a498 1
    visit(do_clean_named_objs, SVt_PVGV, SVTYPEMASK);
d508 1
d527 1
d536 37
a579 1

d583 1
d586 1
a586 1
    XPV *arena, *arenanext;
d600 2
a601 6
    for (arena = PL_xiv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xiv_arenaroot = 0;
    PL_xiv_root = 0;
d603 10
a612 3
    for (arena = PL_xnv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
d614 1
a614 2
    PL_xnv_arenaroot = 0;
    PL_xnv_root = 0;
d616 3
a618 85
    for (arena = PL_xrv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xrv_arenaroot = 0;
    PL_xrv_root = 0;

    for (arena = PL_xpv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpv_arenaroot = 0;
    PL_xpv_root = 0;

    for (arena = (XPV*)PL_xpviv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpviv_arenaroot = 0;
    PL_xpviv_root = 0;

    for (arena = (XPV*)PL_xpvnv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvnv_arenaroot = 0;
    PL_xpvnv_root = 0;

    for (arena = (XPV*)PL_xpvcv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvcv_arenaroot = 0;
    PL_xpvcv_root = 0;

    for (arena = (XPV*)PL_xpvav_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvav_arenaroot = 0;
    PL_xpvav_root = 0;

    for (arena = (XPV*)PL_xpvhv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvhv_arenaroot = 0;
    PL_xpvhv_root = 0;

    for (arena = (XPV*)PL_xpvmg_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvmg_arenaroot = 0;
    PL_xpvmg_root = 0;

    for (arena = (XPV*)PL_xpvlv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvlv_arenaroot = 0;
    PL_xpvlv_root = 0;

    for (arena = (XPV*)PL_xpvbm_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvbm_arenaroot = 0;
    PL_xpvbm_root = 0;

    for (arena = (XPV*)PL_he_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_he_arenaroot = 0;
    PL_he_root = 0;

#if defined(USE_ITHREADS)
    for (arena = (XPV*)PL_pte_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_pte_arenaroot = 0;
    PL_pte_root = 0;
#endif
d621 1
a621 1
    PL_nice_chunk = Nullch;
d628 2
a629 1
=for apidoc report_uninit
d631 41
a671 1
Print appropriate "Use of uninitialized variable" warning
d673 3
a675 2
=cut
*/
d677 23
a699 8
void
Perl_report_uninit(pTHX)
{
    if (PL_op)
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
		    " in ", OP_DESC(PL_op));
    else
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit, "", "");
a701 1
/* allocate another arena's worth of struct xrv */
d703 10
a712 20
STATIC void
S_more_xrv(pTHX)
{
    XRV* xrv;
    XRV* xrvend;
    XPV *ptr;
    New(712, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xrv_arenaroot;
    PL_xrv_arenaroot = ptr;

    xrv = (XRV*) ptr;
    xrvend = &xrv[PERL_ARENA_SIZE / sizeof(XRV) - 1];
    xrv += (sizeof(XPV) - 1) / sizeof(XRV) + 1;
    PL_xrv_root = xrv;
    while (xrv < xrvend) {
	xrv->xrv_rv = (SV*)(xrv + 1);
	xrv++;
    }
    xrv->xrv_rv = 0;
}
d714 1
a714 1
/* allocate another arena's worth of IV bodies */
d716 47
a762 20
STATIC void
S_more_xiv(pTHX)
{
    IV* xiv;
    IV* xivend;
    XPV* ptr;
    New(705, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xiv_arenaroot;	/* linked list of xiv arenas */
    PL_xiv_arenaroot = ptr;			/* to keep Purify happy */

    xiv = (IV*) ptr;
    xivend = &xiv[PERL_ARENA_SIZE / sizeof(IV) - 1];
    xiv += (sizeof(XPV) - 1) / sizeof(IV) + 1;	/* fudge by size of XPV */
    PL_xiv_root = xiv;
    while (xiv < xivend) {
	*(IV**)xiv = (IV *)(xiv + 1);
	xiv++;
    }
    *(IV**)xiv = 0;
}
d764 2
a765 1
/* allocate another arena's worth of NV bodies */
d767 1
a767 20
STATIC void
S_more_xnv(pTHX)
{
    NV* xnv;
    NV* xnvend;
    XPV *ptr;
    New(711, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xnv_arenaroot;
    PL_xnv_arenaroot = ptr;

    xnv = (NV*) ptr;
    xnvend = &xnv[PERL_ARENA_SIZE / sizeof(NV) - 1];
    xnv += (sizeof(XPVIV) - 1) / sizeof(NV) + 1; /* fudge by sizeof XPVIV */
    PL_xnv_root = xnv;
    while (xnv < xnvend) {
	*(NV**)xnv = (NV*)(xnv + 1);
	xnv++;
    }
    *(NV**)xnv = 0;
}
d769 1
a769 1
/* allocate another arena's worth of struct xpv */
d771 2
a772 8
STATIC void
S_more_xpv(pTHX)
{
    XPV* xpv;
    XPV* xpvend;
    New(713, xpv, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    xpv->xpv_pv = (char*)PL_xpv_arenaroot;
    PL_xpv_arenaroot = xpv;
d774 26
a799 8
    xpvend = &xpv[PERL_ARENA_SIZE / sizeof(XPV) - 1];
    PL_xpv_root = ++xpv;
    while (xpv < xpvend) {
	xpv->xpv_pv = (char*)(xpv + 1);
	xpv++;
    }
    xpv->xpv_pv = 0;
}
d801 1
a801 1
/* allocate another arena's worth of struct xpviv */
d803 10
a812 8
STATIC void
S_more_xpviv(pTHX)
{
    XPVIV* xpviv;
    XPVIV* xpvivend;
    New(714, xpviv, PERL_ARENA_SIZE/sizeof(XPVIV), XPVIV);
    xpviv->xpv_pv = (char*)PL_xpviv_arenaroot;
    PL_xpviv_arenaroot = xpviv;
d814 2
a815 8
    xpvivend = &xpviv[PERL_ARENA_SIZE / sizeof(XPVIV) - 1];
    PL_xpviv_root = ++xpviv;
    while (xpviv < xpvivend) {
	xpviv->xpv_pv = (char*)(xpviv + 1);
	xpviv++;
    }
    xpviv->xpv_pv = 0;
}
a816 1
/* allocate another arena's worth of struct xpvnv */
d818 8
a825 16
STATIC void
S_more_xpvnv(pTHX) {
    XPVNV* xpvnv;
    XPVNV* xpvnvend;
    New(715, xpvnv, PERL_ARENA_SIZE/sizeof(XPVNV), XPVNV);
    xpvnv->xpv_pv = (char*)PL_xpvnv_arenaroot;
    PL_xpvnv_arenaroot = xpvnv;

    xpvnvend = &xpvnv[PERL_ARENA_SIZE / sizeof(XPVNV) - 1];
    PL_xpvnv_root = ++xpvnv;
    while (xpvnv < xpvnvend) {
	xpvnv->xpv_pv = (char*)(xpvnv + 1);
	xpvnv++;
    }
    xpvnv->xpv_pv = 0;
}
d827 139
a965 1
/* allocate another arena's worth of struct xpvcv */
d967 2
a968 8
STATIC void
S_more_xpvcv(pTHX)
{
    XPVCV* xpvcv;
    XPVCV* xpvcvend;
    New(716, xpvcv, PERL_ARENA_SIZE/sizeof(XPVCV), XPVCV);
    xpvcv->xpv_pv = (char*)PL_xpvcv_arenaroot;
    PL_xpvcv_arenaroot = xpvcv;
a969 8
    xpvcvend = &xpvcv[PERL_ARENA_SIZE / sizeof(XPVCV) - 1];
    PL_xpvcv_root = ++xpvcv;
    while (xpvcv < xpvcvend) {
	xpvcv->xpv_pv = (char*)(xpvcv + 1);
	xpvcv++;
    }
    xpvcv->xpv_pv = 0;
}
d971 3
a973 1
/* allocate another arena's worth of struct xpvav */
d975 1
a975 8
STATIC void
S_more_xpvav(pTHX)
{
    XPVAV* xpvav;
    XPVAV* xpvavend;
    New(717, xpvav, PERL_ARENA_SIZE/sizeof(XPVAV), XPVAV);
    xpvav->xav_array = (char*)PL_xpvav_arenaroot;
    PL_xpvav_arenaroot = xpvav;
d977 2
a978 8
    xpvavend = &xpvav[PERL_ARENA_SIZE / sizeof(XPVAV) - 1];
    PL_xpvav_root = ++xpvav;
    while (xpvav < xpvavend) {
	xpvav->xav_array = (char*)(xpvav + 1);
	xpvav++;
    }
    xpvav->xav_array = 0;
}
d980 2
a981 1
/* allocate another arena's worth of struct xpvhv */
d983 2
a984 8
STATIC void
S_more_xpvhv(pTHX)
{
    XPVHV* xpvhv;
    XPVHV* xpvhvend;
    New(718, xpvhv, PERL_ARENA_SIZE/sizeof(XPVHV), XPVHV);
    xpvhv->xhv_array = (char*)PL_xpvhv_arenaroot;
    PL_xpvhv_arenaroot = xpvhv;
d986 2
a987 8
    xpvhvend = &xpvhv[PERL_ARENA_SIZE / sizeof(XPVHV) - 1];
    PL_xpvhv_root = ++xpvhv;
    while (xpvhv < xpvhvend) {
	xpvhv->xhv_array = (char*)(xpvhv + 1);
	xpvhv++;
    }
    xpvhv->xhv_array = 0;
}
d989 2
a990 1
/* allocate another arena's worth of struct xpvmg */
d992 2
a993 8
STATIC void
S_more_xpvmg(pTHX)
{
    XPVMG* xpvmg;
    XPVMG* xpvmgend;
    New(719, xpvmg, PERL_ARENA_SIZE/sizeof(XPVMG), XPVMG);
    xpvmg->xpv_pv = (char*)PL_xpvmg_arenaroot;
    PL_xpvmg_arenaroot = xpvmg;
d995 1
a995 8
    xpvmgend = &xpvmg[PERL_ARENA_SIZE / sizeof(XPVMG) - 1];
    PL_xpvmg_root = ++xpvmg;
    while (xpvmg < xpvmgend) {
	xpvmg->xpv_pv = (char*)(xpvmg + 1);
	xpvmg++;
    }
    xpvmg->xpv_pv = 0;
}
d997 2
a998 1
/* allocate another arena's worth of struct xpvlv */
d1000 2
a1001 8
STATIC void
S_more_xpvlv(pTHX)
{
    XPVLV* xpvlv;
    XPVLV* xpvlvend;
    New(720, xpvlv, PERL_ARENA_SIZE/sizeof(XPVLV), XPVLV);
    xpvlv->xpv_pv = (char*)PL_xpvlv_arenaroot;
    PL_xpvlv_arenaroot = xpvlv;
d1003 2
a1004 8
    xpvlvend = &xpvlv[PERL_ARENA_SIZE / sizeof(XPVLV) - 1];
    PL_xpvlv_root = ++xpvlv;
    while (xpvlv < xpvlvend) {
	xpvlv->xpv_pv = (char*)(xpvlv + 1);
	xpvlv++;
    }
    xpvlv->xpv_pv = 0;
}
d1006 2
a1007 1
/* allocate another arena's worth of struct xpvbm */
d1009 2
a1010 8
STATIC void
S_more_xpvbm(pTHX)
{
    XPVBM* xpvbm;
    XPVBM* xpvbmend;
    New(721, xpvbm, PERL_ARENA_SIZE/sizeof(XPVBM), XPVBM);
    xpvbm->xpv_pv = (char*)PL_xpvbm_arenaroot;
    PL_xpvbm_arenaroot = xpvbm;
d1012 2
a1013 8
    xpvbmend = &xpvbm[PERL_ARENA_SIZE / sizeof(XPVBM) - 1];
    PL_xpvbm_root = ++xpvbm;
    while (xpvbm < xpvbmend) {
	xpvbm->xpv_pv = (char*)(xpvbm + 1);
	xpvbm++;
    }
    xpvbm->xpv_pv = 0;
}
d1015 1
a1015 1
/* grab a new struct xrv from the free list, allocating more if necessary */
d1017 1
a1017 12
STATIC XRV*
S_new_xrv(pTHX)
{
    XRV* xrv;
    LOCK_SV_MUTEX;
    if (!PL_xrv_root)
	S_more_xrv(aTHX);
    xrv = PL_xrv_root;
    PL_xrv_root = (XRV*)xrv->xrv_rv;
    UNLOCK_SV_MUTEX;
    return xrv;
}
d1019 21
a1039 1
/* return a struct xrv to the free list */
d1041 1
a1041 8
STATIC void
S_del_xrv(pTHX_ XRV *p)
{
    LOCK_SV_MUTEX;
    p->xrv_rv = (SV*)PL_xrv_root;
    PL_xrv_root = p;
    UNLOCK_SV_MUTEX;
}
d1043 4
a1046 1
/* grab a new IV body from the free list, allocating more if necessary */
d1048 1
a1048 15
STATIC XPVIV*
S_new_xiv(pTHX)
{
    IV* xiv;
    LOCK_SV_MUTEX;
    if (!PL_xiv_root)
	S_more_xiv(aTHX);
    xiv = PL_xiv_root;
    /*
     * See comment in more_xiv() -- RAM.
     */
    PL_xiv_root = *(IV**)xiv;
    UNLOCK_SV_MUTEX;
    return (XPVIV*)((char*)xiv - STRUCT_OFFSET(XPVIV, xiv_iv));
}
d1050 1
a1050 1
/* return an IV body to the free list */
d1052 1
a1052 9
STATIC void
S_del_xiv(pTHX_ XPVIV *p)
{
    IV* xiv = (IV*)((char*)(p) + STRUCT_OFFSET(XPVIV, xiv_iv));
    LOCK_SV_MUTEX;
    *(IV**)xiv = PL_xiv_root;
    PL_xiv_root = xiv;
    UNLOCK_SV_MUTEX;
}
d1054 6
a1059 1
/* grab a new NV body from the free list, allocating more if necessary */
d1061 1
a1061 12
STATIC XPVNV*
S_new_xnv(pTHX)
{
    NV* xnv;
    LOCK_SV_MUTEX;
    if (!PL_xnv_root)
	S_more_xnv(aTHX);
    xnv = PL_xnv_root;
    PL_xnv_root = *(NV**)xnv;
    UNLOCK_SV_MUTEX;
    return (XPVNV*)((char*)xnv - STRUCT_OFFSET(XPVNV, xnv_nv));
}
d1063 6
a1068 1
/* return an NV body to the free list */
d1070 1
a1070 23
STATIC void
S_del_xnv(pTHX_ XPVNV *p)
{
    NV* xnv = (NV*)((char*)(p) + STRUCT_OFFSET(XPVNV, xnv_nv));
    LOCK_SV_MUTEX;
    *(NV**)xnv = PL_xnv_root;
    PL_xnv_root = xnv;
    UNLOCK_SV_MUTEX;
}

/* grab a new struct xpv from the free list, allocating more if necessary */

STATIC XPV*
S_new_xpv(pTHX)
{
    XPV* xpv;
    LOCK_SV_MUTEX;
    if (!PL_xpv_root)
	S_more_xpv(aTHX);
    xpv = PL_xpv_root;
    PL_xpv_root = (XPV*)xpv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpv;
d1073 13
a1085 1
/* return a struct xpv to the free list */
d1087 2
a1088 2
STATIC void
S_del_xpv(pTHX_ XPV *p)
d1090 4
a1093 4
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpv_root;
    PL_xpv_root = p;
    UNLOCK_SV_MUTEX;
d1096 1
a1096 1
/* grab a new struct xpviv from the free list, allocating more if necessary */
d1098 2
a1099 12
STATIC XPVIV*
S_new_xpviv(pTHX)
{
    XPVIV* xpviv;
    LOCK_SV_MUTEX;
    if (!PL_xpviv_root)
	S_more_xpviv(aTHX);
    xpviv = PL_xpviv_root;
    PL_xpviv_root = (XPVIV*)xpviv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpviv;
}
d1101 3
a1103 1
/* return a struct xpviv to the free list */
d1105 2
a1106 8
STATIC void
S_del_xpviv(pTHX_ XPVIV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpviv_root;
    PL_xpviv_root = p;
    UNLOCK_SV_MUTEX;
}
d1108 2
a1109 4
/* grab a new struct xpvnv from the free list, allocating more if necessary */

STATIC XPVNV*
S_new_xpvnv(pTHX)
d1111 7
a1117 9
    XPVNV* xpvnv;
    LOCK_SV_MUTEX;
    if (!PL_xpvnv_root)
	S_more_xpvnv(aTHX);
    xpvnv = PL_xpvnv_root;
    PL_xpvnv_root = (XPVNV*)xpvnv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvnv;
}
d1119 3
a1121 1
/* return a struct xpvnv to the free list */
d1123 2
a1124 8
STATIC void
S_del_xpvnv(pTHX_ XPVNV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvnv_root;
    PL_xpvnv_root = p;
    UNLOCK_SV_MUTEX;
}
d1126 3
a1128 1
/* grab a new struct xpvcv from the free list, allocating more if necessary */
a1129 12
STATIC XPVCV*
S_new_xpvcv(pTHX)
{
    XPVCV* xpvcv;
    LOCK_SV_MUTEX;
    if (!PL_xpvcv_root)
	S_more_xpvcv(aTHX);
    xpvcv = PL_xpvcv_root;
    PL_xpvcv_root = (XPVCV*)xpvcv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvcv;
}
d1131 1
a1131 1
/* return a struct xpvcv to the free list */
d1133 2
a1134 8
STATIC void
S_del_xpvcv(pTHX_ XPVCV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvcv_root;
    PL_xpvcv_root = p;
    UNLOCK_SV_MUTEX;
}
d1136 4
a1139 1
/* grab a new struct xpvav from the free list, allocating more if necessary */
d1141 2
a1142 12
STATIC XPVAV*
S_new_xpvav(pTHX)
{
    XPVAV* xpvav;
    LOCK_SV_MUTEX;
    if (!PL_xpvav_root)
	S_more_xpvav(aTHX);
    xpvav = PL_xpvav_root;
    PL_xpvav_root = (XPVAV*)xpvav->xav_array;
    UNLOCK_SV_MUTEX;
    return xpvav;
}
d1144 4
a1147 1
/* return a struct xpvav to the free list */
d1149 1
a1149 8
STATIC void
S_del_xpvav(pTHX_ XPVAV *p)
{
    LOCK_SV_MUTEX;
    p->xav_array = (char*)PL_xpvav_root;
    PL_xpvav_root = p;
    UNLOCK_SV_MUTEX;
}
d1151 4
a1154 1
/* grab a new struct xpvhv from the free list, allocating more if necessary */
d1156 5
a1160 12
STATIC XPVHV*
S_new_xpvhv(pTHX)
{
    XPVHV* xpvhv;
    LOCK_SV_MUTEX;
    if (!PL_xpvhv_root)
	S_more_xpvhv(aTHX);
    xpvhv = PL_xpvhv_root;
    PL_xpvhv_root = (XPVHV*)xpvhv->xhv_array;
    UNLOCK_SV_MUTEX;
    return xpvhv;
}
d1162 5
a1166 1
/* return a struct xpvhv to the free list */
d1168 2
a1169 8
STATIC void
S_del_xpvhv(pTHX_ XPVHV *p)
{
    LOCK_SV_MUTEX;
    p->xhv_array = (char*)PL_xpvhv_root;
    PL_xpvhv_root = p;
    UNLOCK_SV_MUTEX;
}
d1171 41
a1211 1
/* grab a new struct xpvmg from the free list, allocating more if necessary */
d1213 2
a1214 12
STATIC XPVMG*
S_new_xpvmg(pTHX)
{
    XPVMG* xpvmg;
    LOCK_SV_MUTEX;
    if (!PL_xpvmg_root)
	S_more_xpvmg(aTHX);
    xpvmg = PL_xpvmg_root;
    PL_xpvmg_root = (XPVMG*)xpvmg->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvmg;
}
d1216 22
a1237 1
/* return a struct xpvmg to the free list */
d1239 18
a1256 8
STATIC void
S_del_xpvmg(pTHX_ XPVMG *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvmg_root;
    PL_xpvmg_root = p;
    UNLOCK_SV_MUTEX;
}
d1258 7
a1264 1
/* grab a new struct xpvlv from the free list, allocating more if necessary */
d1266 7
a1272 12
STATIC XPVLV*
S_new_xpvlv(pTHX)
{
    XPVLV* xpvlv;
    LOCK_SV_MUTEX;
    if (!PL_xpvlv_root)
	S_more_xpvlv(aTHX);
    xpvlv = PL_xpvlv_root;
    PL_xpvlv_root = (XPVLV*)xpvlv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvlv;
}
a1273 1
/* return a struct xpvlv to the free list */
d1275 13
a1287 8
STATIC void
S_del_xpvlv(pTHX_ XPVLV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvlv_root;
    PL_xpvlv_root = p;
    UNLOCK_SV_MUTEX;
}
d1289 12
a1300 1
/* grab a new struct xpvbm from the free list, allocating more if necessary */
d1302 17
a1318 102
STATIC XPVBM*
S_new_xpvbm(pTHX)
{
    XPVBM* xpvbm;
    LOCK_SV_MUTEX;
    if (!PL_xpvbm_root)
	S_more_xpvbm(aTHX);
    xpvbm = PL_xpvbm_root;
    PL_xpvbm_root = (XPVBM*)xpvbm->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvbm;
}

/* return a struct xpvbm to the free list */

STATIC void
S_del_xpvbm(pTHX_ XPVBM *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvbm_root;
    PL_xpvbm_root = p;
    UNLOCK_SV_MUTEX;
}

#define my_safemalloc(s)	(void*)safemalloc(s)
#define my_safefree(p)	safefree((char*)p)

#ifdef PURIFY

#define new_XIV()	my_safemalloc(sizeof(XPVIV))
#define del_XIV(p)	my_safefree(p)

#define new_XNV()	my_safemalloc(sizeof(XPVNV))
#define del_XNV(p)	my_safefree(p)

#define new_XRV()	my_safemalloc(sizeof(XRV))
#define del_XRV(p)	my_safefree(p)

#define new_XPV()	my_safemalloc(sizeof(XPV))
#define del_XPV(p)	my_safefree(p)

#define new_XPVIV()	my_safemalloc(sizeof(XPVIV))
#define del_XPVIV(p)	my_safefree(p)

#define new_XPVNV()	my_safemalloc(sizeof(XPVNV))
#define del_XPVNV(p)	my_safefree(p)

#define new_XPVCV()	my_safemalloc(sizeof(XPVCV))
#define del_XPVCV(p)	my_safefree(p)

#define new_XPVAV()	my_safemalloc(sizeof(XPVAV))
#define del_XPVAV(p)	my_safefree(p)

#define new_XPVHV()	my_safemalloc(sizeof(XPVHV))
#define del_XPVHV(p)	my_safefree(p)

#define new_XPVMG()	my_safemalloc(sizeof(XPVMG))
#define del_XPVMG(p)	my_safefree(p)

#define new_XPVLV()	my_safemalloc(sizeof(XPVLV))
#define del_XPVLV(p)	my_safefree(p)

#define new_XPVBM()	my_safemalloc(sizeof(XPVBM))
#define del_XPVBM(p)	my_safefree(p)

#else /* !PURIFY */

#define new_XIV()	(void*)new_xiv()
#define del_XIV(p)	del_xiv((XPVIV*) p)

#define new_XNV()	(void*)new_xnv()
#define del_XNV(p)	del_xnv((XPVNV*) p)

#define new_XRV()	(void*)new_xrv()
#define del_XRV(p)	del_xrv((XRV*) p)

#define new_XPV()	(void*)new_xpv()
#define del_XPV(p)	del_xpv((XPV *)p)

#define new_XPVIV()	(void*)new_xpviv()
#define del_XPVIV(p)	del_xpviv((XPVIV *)p)

#define new_XPVNV()	(void*)new_xpvnv()
#define del_XPVNV(p)	del_xpvnv((XPVNV *)p)

#define new_XPVCV()	(void*)new_xpvcv()
#define del_XPVCV(p)	del_xpvcv((XPVCV *)p)

#define new_XPVAV()	(void*)new_xpvav()
#define del_XPVAV(p)	del_xpvav((XPVAV *)p)

#define new_XPVHV()	(void*)new_xpvhv()
#define del_XPVHV(p)	del_xpvhv((XPVHV *)p)

#define new_XPVMG()	(void*)new_xpvmg()
#define del_XPVMG(p)	del_xpvmg((XPVMG *)p)

#define new_XPVLV()	(void*)new_xpvlv()
#define del_XPVLV(p)	del_xpvlv((XPVLV *)p)

#define new_XPVBM()	(void*)new_xpvbm()
#define del_XPVBM(p)	del_xpvbm((XPVBM *)p)
d1320 15
a1334 114
#endif /* PURIFY */

#define new_XPVGV()	my_safemalloc(sizeof(XPVGV))
#define del_XPVGV(p)	my_safefree(p)

#define new_XPVFM()	my_safemalloc(sizeof(XPVFM))
#define del_XPVFM(p)	my_safefree(p)

#define new_XPVIO()	my_safemalloc(sizeof(XPVIO))
#define del_XPVIO(p)	my_safefree(p)

/*
=for apidoc sv_upgrade

Upgrade an SV to a more complex form.  Generally adds a new body type to the
SV, then copies across as much information as possible from the old body.
You generally want to use the C<SvUPGRADE> macro wrapper. See also C<svtype>.

=cut
*/

bool
Perl_sv_upgrade(pTHX_ register SV *sv, U32 mt)
{

    char*	pv;
    U32		cur;
    U32		len;
    IV		iv;
    NV		nv;
    MAGIC*	magic;
    HV*		stash;

    if (mt != SVt_PV && SvREADONLY(sv) && SvFAKE(sv)) {
	sv_force_normal(sv);
    }

    if (SvTYPE(sv) == mt)
	return TRUE;

    if (mt < SVt_PVIV)
	(void)SvOOK_off(sv);

    pv = NULL;
    cur = 0;
    len = 0;
    iv = 0;
    nv = 0.0;
    magic = NULL;
    stash = Nullhv;

    switch (SvTYPE(sv)) {
    case SVt_NULL:
	break;
    case SVt_IV:
	iv	= SvIVX(sv);
	del_XIV(SvANY(sv));
	if (mt == SVt_NV)
	    mt = SVt_PVNV;
	else if (mt < SVt_PVIV)
	    mt = SVt_PVIV;
	break;
    case SVt_NV:
	nv	= SvNVX(sv);
	del_XNV(SvANY(sv));
	if (mt < SVt_PVNV)
	    mt = SVt_PVNV;
	break;
    case SVt_RV:
	pv	= (char*)SvRV(sv);
	del_XRV(SvANY(sv));
	break;
    case SVt_PV:
	pv	= SvPVX_mutable(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	del_XPV(SvANY(sv));
	if (mt <= SVt_IV)
	    mt = SVt_PVIV;
	else if (mt == SVt_NV)
	    mt = SVt_PVNV;
	break;
    case SVt_PVIV:
	pv	= SvPVX_mutable(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	del_XPVIV(SvANY(sv));
	break;
    case SVt_PVNV:
	pv	= SvPVX_mutable(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= SvNVX(sv);
	del_XPVNV(SvANY(sv));
	break;
    case SVt_PVMG:
	/* Because the XPVMG of PL_mess_sv isn't allocated from the arena,
	   there's no way that it can be safely upgraded, because perl.c
	   expects to Safefree(SvANY(PL_mess_sv))  */
	assert(sv != PL_mess_sv);
	/* This flag bit is used to mean other things in other scalar types.
	   Given that it only has meaning inside the pad, it shouldn't be set
	   on anything that can get upgraded.  */
	assert((SvFLAGS(sv) & SVpad_TYPED) == 0);
	pv	= SvPVX_mutable(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= SvNVX(sv);
	magic	= SvMAGIC(sv);
	stash	= SvSTASH(sv);
	del_XPVMG(SvANY(sv));
d1337 2
a1338 1
	Perl_croak(aTHX_ "Can't upgrade that kind of scalar");
d1341 11
a1351 159
    SvFLAGS(sv) &= ~SVTYPEMASK;
    SvFLAGS(sv) |= mt;

    switch (mt) {
    case SVt_NULL:
	Perl_croak(aTHX_ "Can't upgrade to undef");
    case SVt_IV:
	SvANY(sv) = new_XIV();
	SvIV_set(sv, iv);
	break;
    case SVt_NV:
	SvANY(sv) = new_XNV();
	SvNV_set(sv, nv);
	break;
    case SVt_RV:
	SvANY(sv) = new_XRV();
	SvRV_set(sv, (SV*)pv);
	break;
    case SVt_PV:
	SvANY(sv) = new_XPV();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	break;
    case SVt_PVIV:
	SvANY(sv) = new_XPVIV();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	if (SvNIOK(sv))
	    (void)SvIOK_on(sv);
	SvNOK_off(sv);
	break;
    case SVt_PVNV:
	SvANY(sv) = new_XPVNV();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	break;
    case SVt_PVMG:
	SvANY(sv) = new_XPVMG();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	break;
    case SVt_PVLV:
	SvANY(sv) = new_XPVLV();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	LvTARGOFF(sv)	= 0;
	LvTARGLEN(sv)	= 0;
	LvTARG(sv)	= 0;
	LvTYPE(sv)	= 0;
	break;
    case SVt_PVAV:
	SvANY(sv) = new_XPVAV();
	if (pv)
	    Safefree(pv);
	SvPV_set(sv, (char*)0);
	AvMAX(sv)	= -1;
	AvFILLp(sv)	= -1;
	SvIV_set(sv, 0);
	SvNV_set(sv, 0.0);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	AvALLOC(sv)	= 0;
	AvARYLEN(sv)	= 0;
	AvFLAGS(sv)	= AVf_REAL;
	break;
    case SVt_PVHV:
	SvANY(sv) = new_XPVHV();
	if (pv)
	    Safefree(pv);
	SvPV_set(sv, (char*)0);
	HvFILL(sv)	= 0;
	HvMAX(sv)	= 0;
	HvTOTALKEYS(sv)	= 0;
	HvPLACEHOLDERS_set(sv, 0);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	HvRITER(sv)	= 0;
	HvEITER(sv)	= 0;
	HvPMROOT(sv)	= 0;
	HvNAME(sv)	= 0;
	break;
    case SVt_PVCV:
	SvANY(sv) = new_XPVCV();
	Zero(SvANY(sv), 1, XPVCV);
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	break;
    case SVt_PVGV:
	SvANY(sv) = new_XPVGV();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	GvGP(sv)	= 0;
	GvNAME(sv)	= 0;
	GvNAMELEN(sv)	= 0;
	GvSTASH(sv)	= 0;
	GvFLAGS(sv)	= 0;
	break;
    case SVt_PVBM:
	SvANY(sv) = new_XPVBM();
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	BmRARE(sv)	= 0;
	BmUSEFUL(sv)	= 0;
	BmPREVIOUS(sv)	= 0;
	break;
    case SVt_PVFM:
	SvANY(sv) = new_XPVFM();
	Zero(SvANY(sv), 1, XPVFM);
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	break;
    case SVt_PVIO:
	SvANY(sv) = new_XPVIO();
	Zero(SvANY(sv), 1, XPVIO);
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
	IoPAGE_LEN(sv)	= 60;
	break;
a1352 1
    return TRUE;
d1367 1
d1369 2
d1397 4
a1400 2


d1437 1
a1437 1
	    s = saferealloc(s, newlen);
d1440 1
a1440 7
	    /* sv_force_normal_flags() must not try to unshare the new
	       PVX we allocate below. AMS 20010713 */
	    if (SvREADONLY(sv) && SvFAKE(sv)) {
		SvFAKE_off(sv);
		SvREADONLY_off(sv);
	    }
	    s = safemalloc(newlen);
d1463 2
a1464 1
    SV_CHECK_THINKFIRST(sv);
d1485 1
a1546 2
    sv_setiv(sv, 0);
    SvIsUV_on(sv);
d1563 2
a1564 1
    SV_CHECK_THINKFIRST(sv);
d1584 1
d1613 1
d1619 1
a1619 1
          dsv = sv_2mortal(newSVpvn("", 0));
d1627 3
a1629 3
	  const char *s, *end;
	  for (s = SvPVX_const(sv), end = s + SvCUR(sv); s < end && d < limit;
	       s++) {
d1708 40
d1835 2
d1881 3
a1883 58
/*
=for apidoc sv_2iv

Return the integer value of an SV, doing any necessary string conversion,
magic etc. Normally used via the C<SvIV(sv)> and C<SvIVx(sv)> macros.

=cut
*/

IV
Perl_sv_2iv(pTHX_ register SV *sv)
{
    if (!sv)
	return 0;
    if (SvGMAGICAL(sv)) {
	mg_get(sv);
	if (SvIOKp(sv))
	    return SvIVX(sv);
	if (SvNOKp(sv)) {
	    return I_V(SvNVX(sv));
	}
	if (SvPOKp(sv) && SvLEN(sv))
	    return asIV(sv);
	if (!SvROK(sv)) {
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
	    }
	    return 0;
	}
    }
    if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	    if (SvAMAGIC(sv)) {
		SV * const tmpstr=AMG_CALLun(sv,numer);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvIV(tmpstr);
		}
	    }
	    return PTR2IV(SvRV(sv));
	}
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
	}
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
	    return 0;
	}
    }
    if (SvIOKp(sv)) {
	if (SvIsUV(sv)) {
	    return (IV)(SvUVX(sv));
	}
	else {
	    return SvIVX(sv);
	}
    }
d1888 2
a1889 1
	 * IV or UV at same time to avoid this.  NWC */
d1899 7
a1958 1
	  ret_iv_max:
a1963 1
	    return (IV)SvUVX(sv);
d1969 1
a1969 1
	/* We want to avoid a possible problem when we cache an IV which
d1976 1
a1976 1
	   This means that if we cache such an IV, we need to cache the
d1991 1
a1991 1
	/* If NV preserves UV then we only use the UV value if we know that
d2008 1
a2048 1

d2050 35
a2084 37
	    (void)SvIOKp_on(sv);
	    (void)SvNOK_on(sv);
	    if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
		SvIV_set(sv, I_V(SvNVX(sv)));
		if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
		    SvIOK_on(sv);
		} else {
		    /* Integer is imprecise. NOK, IOKp */
		}
		/* UV will not work better than IV */
	    } else {
		if (SvNVX(sv) > (NV)UV_MAX) {
		    SvIsUV_on(sv);
		    /* Integer is inaccurate. NOK, IOKp, is UV */
		    SvUV_set(sv, UV_MAX);
		    SvIsUV_on(sv);
		} else {
		    SvUV_set(sv, U_V(SvNVX(sv)));
		    /* 0xFFFFFFFFFFFFFFFF not an issue in here */
		    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
			SvIOK_on(sv);
			SvIsUV_on(sv);
		    } else {
			/* Integer is imprecise. NOK, IOKp, is UV */
			SvIsUV_on(sv);
		    }
		}
		goto ret_iv_max;
	    }
#else /* NV_PRESERVES_UV */
            if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
                == (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT)) {
                /* The IV slot will have been set from value returned by
                   grok_number above.  The NV slot has just been set using
                   Atof.  */
	        SvNOK_on(sv);
                assert (SvIOKp(sv));
d2109 1
a2109 3
                    if (sv_2iuv_non_preserve (sv, numtype)
                        >= IS_NUMBER_OVERFLOW_IV)
                    goto ret_iv_max;
d2114 9
a2122 3
    } else  {
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
	    report_uninit();
d2126 2
a2127 1
	return 0;
d2129 1
a2129 3
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%"IVdf")\n",
	PTR2UV(sv),SvIVX(sv)));
    return SvIsUV(sv) ? (IV)SvUVX(sv) : SvIVX(sv);
d2133 1
a2133 1
=for apidoc sv_2uv
d2135 3
a2137 3
Return the unsigned integer value of an SV, doing any necessary string
conversion, magic etc. Normally used via the C<SvUV(sv)> and C<SvUVx(sv)>
macros.
d2142 2
a2143 2
UV
Perl_sv_2uv(pTHX_ register SV *sv)
d2145 1
d2148 7
a2154 2
    if (SvGMAGICAL(sv)) {
	mg_get(sv);
d2156 23
a2178 9
	    return SvUVX(sv);
	if (SvNOKp(sv))
	    return U_V(SvNVX(sv));
	if (SvPOKp(sv) && SvLEN(sv))
	    return asUV(sv);
	if (!SvROK(sv)) {
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
d2180 4
a2183 1
	    return 0;
d2185 3
a2187 2
    }
    if (SvTHINKFIRST(sv)) {
d2189 8
a2196 5
	  SV* tmpstr;
          if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)) &&
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv))))
	      return SvUV(tmpstr);
	  return PTR2UV(SvRV(sv));
d2198 2
a2199 2
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
d2203 1
a2203 1
		report_uninit();
d2207 3
a2209 7
    if (SvIOKp(sv)) {
	if (SvIsUV(sv)) {
	    return SvUVX(sv);
	}
	else {
	    return (UV)SvIVX(sv);
	}
d2211 7
a2217 6
    if (SvNOKp(sv)) {
	/* erm. not sure. *should* never get NOKp (without NOK) from sv_2nv
	 * without also getting a cached IV/UV from it at the same time
	 * (ie PV->NV conversion should detect loss of accuracy and cache
	 * IV or UV at same time to avoid this. */
	/* IV-over-UV optimisation - choose to cache IV if possible */
d2219 3
a2221 2
	if (SvTYPE(sv) == SVt_NV)
	    sv_upgrade(sv, SVt_PVNV);
d2223 2
a2224 18
	(void)SvIOKp_on(sv);	/* Must do this first, to clear any SvOOK */
	if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
	    SvIV_set(sv, I_V(SvNVX(sv)));
	    if (SvNVX(sv) == (NV) SvIVX(sv)
#ifndef NV_PRESERVES_UV
		&& (((UV)1 << NV_PRESERVES_UV_BITS) >
		    (UV)(SvIVX(sv) > 0 ? SvIVX(sv) : -SvIVX(sv)))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		) {
		SvIOK_on(sv);  /* Can this go wrong with rounding? NWC */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" uv(%"NVgf" => %"IVdf") (precise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));
d2226 29
a2254 10
	    } else {
		/* IV not precise.  No need to convert from PV, as NV
		   conversion would already have cached IV if it detected
		   that PV->IV would be better than PV->NV->IV
		   flags already correct - don't set public IOK.  */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" uv(%"NVgf" => %"IVdf") (imprecise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));
d2256 1
a2256 8
	    /* Can the above go wrong if SvIVX == IV_MIN and SvNVX < IV_MIN,
	       but the cast (NV)IV_MIN rounds to a the value less (more
	       negative) than IV_MIN which happens to be equal to SvNVX ??
	       Analogous to 0xFFFFFFFFFFFFFFFF rounding up to NV (2**64) and
	       NV rounding back to 0xFFFFFFFFFFFFFFFF, so UVX == UV(NVX) and
	       (NV)UVX == NVX are both true, but the values differ. :-(
	       Hopefully for 2s complement IV_MIN is something like
	       0x8000000000000000 which will be exact. NWC */
d2258 2
a2259 20
	else {
	    SvUV_set(sv, U_V(SvNVX(sv)));
	    if (
		(SvNVX(sv) == (NV) SvUVX(sv))
#ifndef  NV_PRESERVES_UV
		/* Make sure it's not 0xFFFFFFFFFFFFFFFF */
		/*&& (SvUVX(sv) != UV_MAX) irrelevant with code below */
		&& (((UV)1 << NV_PRESERVES_UV_BITS) > SvUVX(sv))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		)
		SvIOK_on(sv);
	    SvIsUV_on(sv);
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2uv(%"UVuf" => %"IVdf") (as unsigned)\n",
				  PTR2UV(sv),
				  SvUVX(sv),
				  SvUVX(sv)));
d2261 9
a2269 59
    }
    else if (SvPOKp(sv) && SvLEN(sv)) {
	UV value;
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);

	/* We want to avoid a possible problem when we cache a UV which
	   may be later translated to an NV, and the resulting NV is not
	   the translation of the initial data.
	
	   This means that if we cache such a UV, we need to cache the
	   NV as well.  Moreover, we trade speed for space, and do not
	   cache the NV if not needed.
	 */

	/* SVt_PVNV is one higher than SVt_PVIV, hence this order  */
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	     == IS_NUMBER_IN_UV) {
	    /* It's definitely an integer, only upgrade to PVIV */
	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	} else if (SvTYPE(sv) < SVt_PVNV)
	    sv_upgrade(sv, SVt_PVNV);

	/* If NV preserves UV then we only use the UV value if we know that
	   we aren't going to call atof() below. If NVs don't preserve UVs
	   then the value returned may have more precision than atof() will
	   return, even though it isn't accurate.  */
	if ((numtype & (IS_NUMBER_IN_UV
#ifdef NV_PRESERVES_UV
			| IS_NUMBER_NOT_INT
#endif
	    )) == IS_NUMBER_IN_UV) {
	    /* This won't turn off the public IOK flag if it was set above  */
	    (void)SvIOKp_on(sv);

	    if (!(numtype & IS_NUMBER_NEG)) {
		/* positive */;
		if (value <= (UV)IV_MAX) {
		    SvIV_set(sv, (IV)value);
		} else {
		    /* it didn't overflow, and it was positive. */
		    SvUV_set(sv, value);
		    SvIsUV_on(sv);
		}
	    } else {
		/* 2s complement assumption  */
		if (value <= (UV)IV_MIN) {
		    SvIV_set(sv, -(IV)value);
		} else {
		    /* Too negative for an IV.  This is a double upgrade, but
		       I'm assuming it will be rare.  */
		    if (SvTYPE(sv) < SVt_PVNV)
			sv_upgrade(sv, SVt_PVNV);
		    SvNOK_on(sv);
		    SvIOK_off(sv);
		    SvIOKp_on(sv);
		    SvNV_set(sv, -(NV)value);
		    SvIV_set(sv, IV_MIN);
d2272 4
d2277 4
a2280 74
	
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	    != IS_NUMBER_IN_UV) {
	    /* It wasn't an integer, or it overflowed the UV. */
	    SvNV_set(sv, Atof(SvPVX_const(sv)));

            if (! numtype && ckWARN(WARN_NUMERIC))
		    not_a_number(sv);

#if defined(USE_LONG_DOUBLE)
            DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2uv(%" PERL_PRIgldbl ")\n",
                                  PTR2UV(sv), SvNVX(sv)));
#else
            DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2uv(%"NVgf")\n",
                                  PTR2UV(sv), SvNVX(sv)));
#endif

#ifdef NV_PRESERVES_UV
            (void)SvIOKp_on(sv);
            (void)SvNOK_on(sv);
            if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
                SvIV_set(sv, I_V(SvNVX(sv)));
                if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
                    SvIOK_on(sv);
                } else {
                    /* Integer is imprecise. NOK, IOKp */
                }
                /* UV will not work better than IV */
            } else {
                if (SvNVX(sv) > (NV)UV_MAX) {
                    SvIsUV_on(sv);
                    /* Integer is inaccurate. NOK, IOKp, is UV */
                    SvUV_set(sv, UV_MAX);
                    SvIsUV_on(sv);
                } else {
                    SvUV_set(sv, U_V(SvNVX(sv)));
                    /* 0xFFFFFFFFFFFFFFFF not an issue in here, NVs
                       NV preservse UV so can do correct comparison.  */
                    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
                        SvIOK_on(sv);
                        SvIsUV_on(sv);
                    } else {
                        /* Integer is imprecise. NOK, IOKp, is UV */
                        SvIsUV_on(sv);
                    }
                }
            }
#else /* NV_PRESERVES_UV */
            if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
                == (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT)) {
                /* The UV slot will have been set from value returned by
                   grok_number above.  The NV slot has just been set using
                   Atof.  */
	        SvNOK_on(sv);
                assert (SvIOKp(sv));
            } else {
                if (((UV)1 << NV_PRESERVES_UV_BITS) >
                    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
                    /* Small enough to preserve all bits. */
                    (void)SvIOKp_on(sv);
                    SvNOK_on(sv);
                    SvIV_set(sv, I_V(SvNVX(sv)));
                    if ((NV)(SvIVX(sv)) == SvNVX(sv))
                        SvIOK_on(sv);
                    /* Assumption: first non-preserved integer is < IV_MAX,
                       this NV is in the preserved range, therefore: */
                    if (!(U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))
                          < (UV)IV_MAX)) {
                        Perl_croak(aTHX_ "sv_2uv assumed (U_V(fabs((double)SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
                    }
                } else
                    sv_2iuv_non_preserve (sv, numtype);
            }
#endif /* NV_PRESERVES_UV */
d2283 3
a2285 9
    else  {
	if (!(SvFLAGS(sv) & SVs_PADTMP)) {
	    if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		report_uninit();
	}
	if (SvTYPE(sv) < SVt_IV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    sv_upgrade(sv, SVt_IV);
	return 0;
d2306 1
d2309 3
a2311 1
    if (SvGMAGICAL(sv)) {
d2315 1
a2315 1
	if (SvPOKp(sv) && SvLEN(sv)) {
d2326 15
a2340 5
	}	
        if (!SvROK(sv)) {
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
d2342 1
a2342 10
            return (NV)0;
        }
    }
    if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	  SV* tmpstr;
          if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)) &&
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv))))
	      return SvNV(tmpstr);
	  return PTR2NV(SvRV(sv));
d2344 2
a2345 2
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
d2349 1
a2349 1
		report_uninit();
d2354 2
a2355 4
	if (SvTYPE(sv) == SVt_IV)
	    sv_upgrade(sv, SVt_PVNV);
	else
	    sv_upgrade(sv, SVt_NV);
a2448 1
                            SvIOK_on(sv);
a2449 1
                            SvIOK_on(sv);
d2452 1
a2463 3
                                SvIOK_on(sv);
                            } else {
                                SvIOK_on(sv);
d2465 1
d2474 5
d2480 5
a2484 6
	    report_uninit();
	if (SvTYPE(sv) < SVt_NV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    /* XXX Ilya implies that this is a bug in callers that assume this
	       and ideally should be fixed.  */
	    sv_upgrade(sv, SVt_NV);
d2505 2
a2506 48
/* asIV(): extract an integer from the string value of an SV.
 * Caller must validate PVX  */

STATIC IV
S_asIV(pTHX_ SV *sv)
{
    UV value;
    const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);

    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	== IS_NUMBER_IN_UV) {
	/* It's definitely an integer */
	if (numtype & IS_NUMBER_NEG) {
	    if (value < (UV)IV_MIN)
		return -(IV)value;
	} else {
	    if (value < (UV)IV_MAX)
		return (IV)value;
	}
    }
    if (!numtype) {
	if (ckWARN(WARN_NUMERIC))
	    not_a_number(sv);
    }
    return I_V(Atof(SvPVX_const(sv)));
}

/* asUV(): extract an unsigned integer from the string value of an SV
 * Caller must validate PVX  */

STATIC UV
S_asUV(pTHX_ SV *sv)
{
    UV value;
    const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);

    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	== IS_NUMBER_IN_UV) {
	/* It's definitely an integer */
	if (!(numtype & IS_NUMBER_NEG))
	    return value;
    }
    if (!numtype) {
	if (ckWARN(WARN_NUMERIC))
	    not_a_number(sv);
    }
    return U_V(Atof(SvPVX_const(sv)));
}
d2508 3
a2510 2
/*
=for apidoc sv_2pv_nolen
a2511 2
Like C<sv_2pv()>, but doesn't return the length too. You should usually
use the macro wrapper C<SvPV_nolen(sv)> instead.
d2515 2
a2516 2
char *
Perl_sv_2pv_nolen(pTHX_ register SV *sv)
d2518 8
a2525 1
    return sv_2pv(sv, 0);
a2559 10
/* sv_2pv() is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_2pv(pTHX_ register SV *sv, STRLEN *lp)
{
    return sv_2pv_flags(sv, lp, SV_GMAGIC);
}

d2575 1
a2576 4
    int olderrno;
    SV *tsv, *origsv;
    char tbuf[64];	/* Must fit sprintf/Gconvert of longest IV/NV */
    char *tmpbuf = tbuf;
d2595 11
a2605 17
	if (SvIOKp(sv)) {
	    if (SvIsUV(sv))
		(void)sprintf(tmpbuf,"%"UVuf, (UV)SvUVX(sv));
	    else
		(void)sprintf(tmpbuf,"%"IVdf, (IV)SvIVX(sv));
	    tsv = Nullsv;
	    goto tokensave;
	}
	if (SvNOKp(sv)) {
	    Gconvert(SvNVX(sv), NV_DIG, 0, tmpbuf);
	    tsv = Nullsv;
	    goto tokensave;
	}
        if (!SvROK(sv)) {
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
d2607 27
a2633 6
	    if (lp)
		*lp = 0;
            return (char *)"";
        }
    }
    if (SvTHINKFIRST(sv)) {
d2635 18
a2652 11
	    SV* tmpstr;
            register const char *typestr;
            if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,string)) &&
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		/* Unwrap this:  */
		/* char *pv = lp ? SvPV(tmpstr, *lp) : SvPV_nolen(tmpstr); */

                char *pv;
		if ((SvFLAGS(tmpstr) & (SVf_POK)) == SVf_POK) {
		    if (flags & SV_CONST_RETURN) {
			pv = (char *) SvPVX_const(tmpstr);
d2654 1
a2654 2
			pv = (flags & SV_MUTABLE_RETURN)
			    ? SvPVX_mutable(tmpstr) : SvPVX(tmpstr);
d2656 5
a2660 4
		    if (lp)
			*lp = SvCUR(tmpstr);
		} else {
		    pv = sv_2pv_flags(tmpstr, lp, flags);
d2662 5
a2666 11
                if (SvUTF8(tmpstr))
                    SvUTF8_on(sv);
                else
                    SvUTF8_off(sv);
                return pv;
            }
	    origsv = sv;
	    sv = (SV*)SvRV(sv);
	    if (!sv)
		typestr = "NULLREF";
	    else {
d2668 1
a2668 65
		
		switch (SvTYPE(sv)) {
		case SVt_PVMG:
		    if ( ((SvFLAGS(sv) &
			   (SVs_OBJECT|SVf_OK|SVs_GMG|SVs_SMG|SVs_RMG))
			  == (SVs_OBJECT|SVs_SMG))
			 && (mg = mg_find(sv, PERL_MAGIC_qr))) {
                        const regexp *re = (regexp *)mg->mg_obj;

			if (!mg->mg_ptr) {
                            const char *fptr = "msix";
			    char reflags[6];
			    char ch;
			    int left = 0;
			    int right = 4;
                            char need_newline = 0;
 			    U16 reganch = (U16)((re->reganch & PMf_COMPILETIME) >> 12);

 			    while((ch = *fptr++)) {
 				if(reganch & 1) {
 				    reflags[left++] = ch;
 				}
 				else {
 				    reflags[right--] = ch;
 				}
 				reganch >>= 1;
 			    }
 			    if(left != 4) {
 				reflags[left] = '-';
 				left = 5;
 			    }

			    mg->mg_len = re->prelen + 4 + left;
                            /*
                             * If /x was used, we have to worry about a regex
                             * ending with a comment later being embedded
                             * within another regex. If so, we don't want this
                             * regex's "commentization" to leak out to the
                             * right part of the enclosing regex, we must cap
                             * it with a newline.
                             *
                             * So, if /x was used, we scan backwards from the
                             * end of the regex. If we find a '#' before we
                             * find a newline, we need to add a newline
                             * ourself. If we find a '\n' first (or if we
                             * don't find '#' or '\n'), we don't need to add
                             * anything.  -jfriedl
                             */
                            if (PMf_EXTENDED & re->reganch)
                            {
                                const char *endptr = re->precomp + re->prelen;
                                while (endptr >= re->precomp)
                                {
                                    const char c = *(endptr--);
                                    if (c == '\n')
                                        break; /* don't need another */
                                    if (c == '#') {
                                        /* we end while in a comment, so we
                                           need a newline */
                                        mg->mg_len++; /* save space for it */
                                        need_newline = 1; /* note to add it */
					break;
                                    }
                                }
                            }
d2670 42
a2711 9
			    Newx(mg->mg_ptr, mg->mg_len + 1 + left, char);
			    Copy("(?", mg->mg_ptr, 2, char);
			    Copy(reflags, mg->mg_ptr+2, left, char);
			    Copy(":", mg->mg_ptr+left+2, 1, char);
			    Copy(re->precomp, mg->mg_ptr+3+left, re->prelen, char);
                            if (need_newline)
                                mg->mg_ptr[mg->mg_len - 2] = '\n';
			    mg->mg_ptr[mg->mg_len - 1] = ')';
			    mg->mg_ptr[mg->mg_len] = 0;
d2713 9
a2721 1
			PL_reginterp_cnt += re->program[0].next_off;
d2723 17
a2739 7
			if (re->reganch & ROPT_UTF8)
			    SvUTF8_on(origsv);
			else
			    SvUTF8_off(origsv);
			if (lp)
			    *lp = mg->mg_len;
			return mg->mg_ptr;
d2741 10
a2750 31
					/* Fall through */
		case SVt_NULL:
		case SVt_IV:
		case SVt_NV:
		case SVt_RV:
		case SVt_PV:
		case SVt_PVIV:
		case SVt_PVNV:
		case SVt_PVBM:	typestr = SvROK(sv) ? "REF" : "SCALAR"; break;
		case SVt_PVLV:	typestr = SvROK(sv) ? "REF"
				/* tied lvalues should appear to be
				 * scalars for backwards compatitbility */
				: (LvTYPE(sv) == 't' || LvTYPE(sv) == 'T')
				    ? "SCALAR" : "LVALUE";	break;
		case SVt_PVAV:	typestr = "ARRAY";	break;
		case SVt_PVHV:	typestr = "HASH";	break;
		case SVt_PVCV:	typestr = "CODE";	break;
		case SVt_PVGV:	typestr = "GLOB";	break;
		case SVt_PVFM:	typestr = "FORMAT";	break;
		case SVt_PVIO:	typestr = "IO";		break;
		default:	typestr = "UNKNOWN";	break;
		}
		tsv = NEWSV(0,0);
		if (SvOBJECT(sv)) {
		    const char *name = HvNAME_get(SvSTASH(sv));
		    Perl_sv_setpvf(aTHX_ tsv, "%s=%s(0x%"UVxf")",
				   name ? name : "__ANON__" , typestr, PTR2UV(sv));
		}
		else
		    Perl_sv_setpvf(aTHX_ tsv, "%s(0x%"UVxf")", typestr, PTR2UV(sv));
		goto tokensaveref;
a2751 3
	    if (lp)
		*lp = strlen(typestr);
	    return (char *)typestr;
d2755 1
a2755 1
		report_uninit();
a2763 1
	const U32 isIOK = SvIOK(sv);
d2767 1
d2771 2
a2772 4
	if (isUIOK)
	    ptr = uiv_2buf(buf, 0, SvUVX(sv), 1, &ebuf);
	else
	    ptr = uiv_2buf(buf, SvIVX(sv), 0, 0, &ebuf);
d2774 3
a2776 4
	SvGROW_mutable(sv, (STRLEN)(ebuf - ptr + 1));
	Move(ptr,SvPVX_mutable(sv),ebuf - ptr,char);
	SvCUR_set(sv, ebuf - ptr);
	s = SvEND(sv);
a2777 6
	if (isIOK)
	    SvIOK_on(sv);
	else
	    SvIOKp_on(sv);
	if (isUIOK)
	    SvIsUV_on(sv);
d2780 1
d2785 1
a2785 1
	olderrno = errno;	/* some Xenix systems wipe out errno here */
d2788 1
a2788 1
	    (void)strcpy(s,"0");
d2796 4
a2799 2
        if (*s == '-' && s[1] == '0' && !s[2])
	    strcpy(s,"0");
d2808 3
d2812 1
a2812 1
	    report_uninit();
d2814 1
a2814 1
	*lp = 0;
a2833 40

  tokensave:
    if (SvROK(sv)) {	/* XXX Skip this when sv_pvn_force calls */
	/* Sneaky stuff here */

      tokensaveref:
	if (!tsv)
	    tsv = newSVpv(tmpbuf, 0);
	sv_2mortal(tsv);
	if (lp)
	    *lp = SvCUR(tsv);
	return SvPVX(tsv);
    }
    else {
    	STRLEN len;
        const char *t;

	if (tsv) {
	    sv_2mortal(tsv);
	    t = SvPVX_const(tsv);
	    len = SvCUR(tsv);
	}
	else {
	    t = tmpbuf;
	    len = strlen(tmpbuf);
	}
#ifdef FIXNEGATIVEZERO
	if (len == 2 && t[0] == '-' && t[1] == '0') {
	    t = "0";
	    len = 1;
	}
#endif
	(void)SvUPGRADE(sv, SVt_PV);
	if (lp)
	    *lp = len;
	s = SvGROW_mutable(sv, len + 1);
	SvCUR_set(sv, len);
	SvPOKp_on(sv);
	return memcpy(s, t, len + 1);
    }
d2842 1
a2842 1
UTF-8 flag even from overloaded objects.  Similar in nature to
a2862 17
=for apidoc sv_2pvbyte_nolen

Return a pointer to the byte-encoded representation of the SV.
May cause the SV to be downgraded from UTF-8 as a side-effect.

Usually accessed via the C<SvPVbyte_nolen> macro.

=cut
*/

char *
Perl_sv_2pvbyte_nolen(pTHX_ register SV *sv)
{
    return sv_2pvbyte(sv, 0);
}

/*
a2881 17
=for apidoc sv_2pvutf8_nolen

Return a pointer to the UTF-8-encoded representation of the SV.
May cause the SV to be upgraded to UTF-8 as a side-effect.

Usually accessed via the C<SvPVutf8_nolen> macro.

=cut
*/

char *
Perl_sv_2pvutf8_nolen(pTHX_ register SV *sv)
{
    return sv_2pvutf8(sv, 0);
}

/*
d2899 1
d2912 2
a2913 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d2918 6
a2923 5
	SV* tmpsv;
        if (SvAMAGIC(sv) && (tmpsv=AMG_CALLun(sv,bool_)) &&
                (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv))))
	    return (bool)SvTRUE(tmpsv);
      return SvRV(sv) != 0;
d2928 1
a2928 1
		(*Xpvtmp->xpv_pv > '0' ||
d2930 1
a2930 1
		(Xpvtmp->xpv_cur && *Xpvtmp->xpv_pv != '0')))
d2941 6
a2946 2
	    else
		return FALSE;
a2950 11
/* sv_utf8_upgrade() is now a macro using sv_utf8_upgrade_flags();
 * this function provided for binary compatibility only
 */


STRLEN
Perl_sv_utf8_upgrade(pTHX_ register SV *sv)
{
    return sv_utf8_upgrade_flags(sv, SV_GMAGIC);
}

d2980 1
d2998 2
a2999 2
    if (SvREADONLY(sv) && SvFAKE(sv)) {
	sv_force_normal(sv);
d3009 2
a3010 2
	const U8 *s = (U8 *) SvPVX_const(sv);
	const U8 *e = (U8 *) SvEND(sv);
a3011 1
	int hibit = 0;
d3015 9
a3023 1
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
d3025 1
a3025 10
	}
	if (hibit) {
	    STRLEN len = SvCUR(sv) + 1; /* Plus the \0 */
	    U8 * const recoded = bytes_to_utf8((U8*)s, &len);

	    SvPV_free(sv); /* No longer using what was there before. */

	    SvPV_set(sv, (char*)recoded);
	    SvCUR_set(sv, len - 1);
	    SvLEN_set(sv, len); /* No longer know the real size. */
d3050 1
d3056 3
a3058 2
	    if (SvREADONLY(sv) && SvFAKE(sv))
		sv_force_normal(sv);
a3089 1
    (void) sv_utf8_upgrade(sv);
d3096 1
d3129 1
a3129 1
	if (!is_utf8_string((U8 *)c, SvCUR(sv)+1))
a3142 10
/* sv_setsv() is now a macro using Perl_sv_setsv_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_setsv(pTHX_ SV *dstr, register SV *sstr)
{
    sv_setsv_flags(dstr, sstr, SV_GMAGIC);
}

d3162 201
a3362 15
content of the destination.
If the C<flags> parameter has the C<SV_GMAGIC> bit set, will C<mg_get> on
C<ssv> if appropriate, else not. If the C<flags> parameter has the
C<NOSTEAL> bit set then the buffers of temps will not be stolen. <sv_setsv>
and C<sv_setsv_nomg> are implemented in terms of this function.

You probably want to use one of the assortment of wrappers, such as
C<SvSetSV>, C<SvSetSV_nosteal>, C<SvSetMagicSV> and
C<SvSetMagicSV_nosteal>.

This is the primary function for copying scalars, and most other
copy-ish functions and macros use this underneath.

=cut
*/
d3367 1
d3370 1
a3370 1
    register int stype;
d3374 6
a3379 1
    SV_CHECK_THINKFIRST(dstr);
d3382 4
d3389 2
a3390 2
    SvAMAGIC_off(dstr);
    if ( SvVOK(dstr) ) 
a3413 2
		sv_upgrade(dstr, SVt_PVNV);
		break;
d3418 2
d3425 5
a3429 2
	    if (SvTAINTED(sstr))
		SvTAINT(dstr);
d3446 2
d3451 5
a3455 2
	    if (SvTAINTED(sstr))
		SvTAINT(dstr);
d3463 7
a3469 13
	else if (dtype == SVt_PVGV &&
		 SvROK(sstr) && SvTYPE(SvRV(sstr)) == SVt_PVGV) {
	    sstr = SvRV(sstr);
	    if (sstr == dstr) {
		if (GvIMPORTED(dstr) != GVf_IMPORTED
		    && CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		{
		    GvIMPORTED_on(dstr);
		}
		GvMULTI_on(dstr);
		return;
	    }
	    goto glob_assign;
d3471 2
a3472 1
	break;
a3473 1
    case SVt_PVFM:
d3485 1
a3485 4
    case SVt_PVAV:
    case SVt_PVHV:
    case SVt_PVCV:
    case SVt_PVIO:
d3495 2
d3498 2
a3499 36
	if (dtype <= SVt_PVGV) {
  glob_assign:
	    if (dtype != SVt_PVGV) {
		const char * const name = GvNAME(sstr);
		const STRLEN len = GvNAMELEN(sstr);
		sv_upgrade(dstr, SVt_PVGV);
		sv_magic(dstr, dstr, PERL_MAGIC_glob, Nullch, 0);
		GvSTASH(dstr) = (HV*)SvREFCNT_inc(GvSTASH(sstr));
		GvNAME(dstr) = savepvn(name, len);
		GvNAMELEN(dstr) = len;
		SvFAKE_on(dstr);	/* can coerce to non-glob */
	    }
	    /* ahem, death to those who redefine active sort subs */
	    else if (PL_curstackinfo->si_type == PERLSI_SORT
		     && GvCV(dstr) && PL_sortcop == CvSTART(GvCV(dstr)))
		Perl_croak(aTHX_ "Can't redefine active sort subroutine %s",
		      GvNAME(dstr));

#ifdef GV_UNIQUE_CHECK
                if (GvUNIQUE((GV*)dstr)) {
                    Perl_croak(aTHX_ PL_no_modify);
                }
#endif

	    (void)SvOK_off(dstr);
	    GvINTRO_off(dstr);		/* one-shot flag */
	    gp_free((GV*)dstr);
	    GvGP(dstr) = gp_ref(GvGP(sstr));
	    if (SvTAINTED(sstr))
		SvTAINT(dstr);
	    if (GvIMPORTED(dstr) != GVf_IMPORTED
		&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
	    {
		GvIMPORTED_on(dstr);
	    }
	    GvMULTI_on(dstr);
d3502 2
a3503 1
	/* FALL THROUGH */
d3505 1
a3505 1
    default:
d3508 1
a3508 1
	    if ((int)SvTYPE(sstr) != stype) {
d3510 4
a3513 2
		if (stype == SVt_PVGV && dtype <= SVt_PVGV)
		    goto glob_assign;
d3517 1
a3517 1
	    (void)SvUPGRADE(dstr, SVt_PVNV);
d3519 1
a3519 1
	    (void)SvUPGRADE(dstr, (U32)stype);
d3521 1
d3523 2
d3527 5
a3531 6
    if (sflags & SVf_ROK) {
	if (dtype >= SVt_PV) {
	    if (dtype == SVt_PVGV) {
		SV * const sref = SvREFCNT_inc(SvRV(sstr));
		SV *dref = 0;
		const int intro = GvINTRO(dstr);
d3533 23
a3555 10
#ifdef GV_UNIQUE_CHECK
                if (GvUNIQUE((GV*)dstr)) {
                    Perl_croak(aTHX_ PL_no_modify);
                }
#endif

		if (intro) {
		    GvINTRO_off(dstr);	/* one-shot flag */
		    GvLINE(dstr) = CopLINE(PL_curcop);
		    GvEGV(dstr) = (GV*)dstr;
d3558 9
a3566 114
		switch (SvTYPE(sref)) {
		case SVt_PVAV:
		    if (intro)
			SAVEGENERICSV(GvAV(dstr));
		    else
			dref = (SV*)GvAV(dstr);
		    GvAV(dstr) = (AV*)sref;
		    if (!GvIMPORTED_AV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
			GvIMPORTED_AV_on(dstr);
		    }
		    break;
		case SVt_PVHV:
		    if (intro)
			SAVEGENERICSV(GvHV(dstr));
		    else
			dref = (SV*)GvHV(dstr);
		    GvHV(dstr) = (HV*)sref;
		    if (!GvIMPORTED_HV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
			GvIMPORTED_HV_on(dstr);
		    }
		    break;
		case SVt_PVCV:
		    if (intro) {
			if (GvCVGEN(dstr) && GvCV(dstr) != (CV*)sref) {
			    SvREFCNT_dec(GvCV(dstr));
			    GvCV(dstr) = Nullcv;
			    GvCVGEN(dstr) = 0; /* Switch off cacheness. */
			    PL_sub_generation++;
			}
			SAVEGENERICSV(GvCV(dstr));
		    }
		    else
			dref = (SV*)GvCV(dstr);
		    if (GvCV(dstr) != (CV*)sref) {
			CV* const cv = GvCV(dstr);
			if (cv) {
			    if (!GvCVGEN((GV*)dstr) &&
				(CvROOT(cv) || CvXSUB(cv)))
			    {
				/* ahem, death to those who redefine
				 * active sort subs */
				if (PL_curstackinfo->si_type == PERLSI_SORT &&
				      PL_sortcop == CvSTART(cv))
				    Perl_croak(aTHX_
				    "Can't redefine active sort subroutine %s",
					  GvENAME((GV*)dstr));
 				/* Redefining a sub - warning is mandatory if
 				   it was a const and its value changed. */
 				if (ckWARN(WARN_REDEFINE)
 				    || (CvCONST(cv)
 					&& (!CvCONST((CV*)sref)
 					    || sv_cmp(cv_const_sv(cv),
 						      cv_const_sv((CV*)sref)))))
 				{
 				    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
 					CvCONST(cv)
 					? "Constant subroutine %s::%s redefined"
 					: "Subroutine %s::%s redefined",
					HvNAME_get(GvSTASH((GV*)dstr)),
 					GvENAME((GV*)dstr));
 				}
			    }
			    if (!intro)
				cv_ckproto(cv, (GV*)dstr,
					   SvPOK(sref)
					   ? (char *)SvPVX_const(sref)
					   : Nullch);
			}
			GvCV(dstr) = (CV*)sref;
			GvCVGEN(dstr) = 0; /* Switch off cacheness. */
			GvASSUMECV_on(dstr);
			PL_sub_generation++;
		    }
		    if (!GvIMPORTED_CV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
			GvIMPORTED_CV_on(dstr);
		    }
		    break;
		case SVt_PVIO:
		    if (intro)
			SAVEGENERICSV(GvIOp(dstr));
		    else
			dref = (SV*)GvIOp(dstr);
		    GvIOp(dstr) = (IO*)sref;
		    break;
		case SVt_PVFM:
		    if (intro)
			SAVEGENERICSV(GvFORM(dstr));
		    else
			dref = (SV*)GvFORM(dstr);
		    GvFORM(dstr) = (CV*)sref;
		    break;
		default:
		    if (intro)
			SAVEGENERICSV(GvSV(dstr));
		    else
			dref = (SV*)GvSV(dstr);
		    GvSV(dstr) = sref;
		    if (!GvIMPORTED_SV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
			GvIMPORTED_SV_on(dstr);
		    }
		    break;
		}
		if (dref)
		    SvREFCNT_dec(dref);
		if (SvTAINTED(sstr))
		    SvTAINT(dstr);
d3577 11
a3587 7
	SvROK_on(dstr);
	if (sflags & SVp_NOK) {
	    SvNOKp_on(dstr);
	    /* Only set the public OK flag if the source has public OK.  */
	    if (sflags & SVf_NOK)
		SvFLAGS(dstr) |= SVf_NOK;
	    SvNV_set(dstr, SvNVX(sstr));
d3589 7
a3595 10
	if (sflags & SVp_IOK) {
	    (void)SvIOKp_on(dstr);
	    if (sflags & SVf_IOK)
		SvFLAGS(dstr) |= SVf_IOK;
	    if (sflags & SVf_IVisUV)
		SvIsUV_on(dstr);
	    SvIV_set(dstr, SvIVX(sstr));
	}
	if (SvAMAGIC(sstr)) {
	    SvAMAGIC_on(dstr);
d3599 1
d3606 3
d3611 38
a3648 5
	if (SvTEMP(sstr) &&		/* slated for free anyway? */
	    SvREFCNT(sstr) == 1 && 	/* and no other references to it? */
	    (!(flags & SV_NOSTEAL)) &&	/* and we're allowed to steal temps */
	    !(sflags & SVf_OOK) && 	/* and not involved in OOK hack? */
	    SvLEN(sstr) 	&&	/* and really is a string */
d3650 45
a3694 2
	    !(PL_op && PL_op->op_type == OP_AASSIGN))
	{
d3698 44
a3741 22
	    (void)SvPOK_only(dstr);
	    SvPV_set(dstr, SvPVX(sstr));
	    SvLEN_set(dstr, SvLEN(sstr));
	    SvCUR_set(dstr, SvCUR(sstr));

	    SvTEMP_off(dstr);
	    (void)SvOK_off(sstr);	/* NOTE: nukes most SvFLAGS on sstr */
	    SvPV_set(sstr, Nullch);
	    SvLEN_set(sstr, 0);
	    SvCUR_set(sstr, 0);
	    SvTEMP_off(sstr);
	}
	else {				/* have to copy actual string */
	    STRLEN len = SvCUR(sstr);
	    SvGROW(dstr, len + 1);	/* inlined from sv_setpvn */
	    Move(SvPVX_const(sstr),SvPVX(dstr),len,char);
	    SvCUR_set(dstr, len);
	    *SvEND(dstr) = '\0';
	    (void)SvPOK_only(dstr);
	}
	if (sflags & SVf_UTF8)
	    SvUTF8_on(dstr);
a3742 3
	    SvNOKp_on(dstr);
	    if (sflags & SVf_NOK)
		SvFLAGS(dstr) |= SVf_NOK;
d3746 4
a3749 3
	    (void)SvIOKp_on(dstr);
	    if (sflags & SVf_IOK)
		SvFLAGS(dstr) |= SVf_IOK;
a3751 1
	    SvIV_set(dstr, SvIVX(sstr));
d3753 9
a3761 6
	if ( SvVOK(sstr) ) {
	    MAGIC *smg = mg_find(sstr,PERL_MAGIC_vstring);
	    sv_magic(dstr, NULL, PERL_MAGIC_vstring,
		     smg->mg_ptr, smg->mg_len);
	    SvRMAGICAL_on(dstr);
	} 
d3763 6
a3768 6
    else if (sflags & SVp_IOK) {
	if (sflags & SVf_IOK)
	    (void)SvIOK_only(dstr);
	else {
	    (void)SvOK_off(dstr);
	    (void)SvIOKp_on(dstr);
a3769 4
	/* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
	if (sflags & SVf_IVisUV)
	    SvIsUV_on(dstr);
	SvIV_set(dstr, SvIVX(sstr));
a3770 4
	    if (sflags & SVf_NOK)
		(void)SvNOK_on(dstr);
	    else
		(void)SvNOKp_on(dstr);
a3773 9
    else if (sflags & SVp_NOK) {
	if (sflags & SVf_NOK)
	    (void)SvNOK_only(dstr);
	else {
	    (void)SvOK_off(dstr);
	    SvNOKp_on(dstr);
	}
	SvNV_set(dstr, SvNVX(sstr));
    }
d3775 10
a3784 3
	if (dtype == SVt_PVGV) {
	    if (ckWARN(WARN_MISC))
		Perl_warner(aTHX_ packWARN(WARN_MISC), "Undefined value assigned to typeglob");
d3808 69
d3890 1
d3893 1
a3893 1
    SV_CHECK_THINKFIRST(sv);
d3904 1
a3904 1
    (void)SvUPGRADE(sv, SVt_PV);
d3941 1
d3944 1
a3944 1
    SV_CHECK_THINKFIRST(sv);
d3950 1
a3950 1
    (void)SvUPGRADE(sv, SVt_PV);
d3975 1
a3975 1
=for apidoc sv_usepvn
d3977 13
a3989 7
Tells an SV to use C<ptr> to find its string value.  Normally the string is
stored inside the SV but sv_usepvn allows the SV to use an outside string.
The C<ptr> should point to memory that was allocated by C<malloc>.  The
string length, C<len>, must be supplied.  This function will realloc the
memory pointed to by C<ptr>, so that pointer should not be freed or used by
the programmer after giving it to sv_usepvn.  Does not handle 'set' magic.
See C<sv_usepvn_mg>.
d3995 1
a3995 1
Perl_sv_usepvn(pTHX_ register SV *sv, register char *ptr, register STRLEN len)
d3997 1
d3999 2
a4000 2
    SV_CHECK_THINKFIRST(sv);
    (void)SvUPGRADE(sv, SVt_PV);
d4003 2
d4010 22
a4031 2
    allocate = PERL_STRLEN_ROUNDUP(len + 1);
    ptr = saferealloc (ptr, allocate);
d4035 3
a4037 1
    *SvEND(sv) = '\0';
d4040 2
d4044 8
a4051 10
/*
=for apidoc sv_usepvn_mg

Like C<sv_usepvn>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_usepvn_mg(pTHX_ register SV *sv, register char *ptr, register STRLEN len)
d4053 25
a4077 2
    sv_usepvn(sv,ptr,len);
    SvSETMAGIC(sv);
d4079 1
a4079 1

d4085 7
a4091 2
an xpvmg. The C<flags> parameter gets passed to  C<sv_unref_flags()>
when unrefing. C<sv_force_normal> calls this function with flags set to 0.
d4099 47
a4149 1
	    const U32 hash = SvSHARED_HASH(sv);
d4152 2
d4157 1
a4157 1
	    unsharepvn(pvx, SvUTF8(sv) ? -(I32)len : len, hash);
d4162 1
a4169 16
=for apidoc sv_force_normal

Undo various types of fakery on an SV: if the PV is a shared string, make
a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
an xpvmg. See also C<sv_force_normal_flags>.

=cut
*/

void
Perl_sv_force_normal(pTHX_ register SV *sv)
{
    sv_force_normal_flags(sv, 0);
}

/*
d4183 1
a4183 1
Perl_sv_chop(pTHX_ register SV *sv, register char *ptr)
d4205 1
a4205 1
	SvFLAGS(sv) |= SVf_OOK; 
a4213 10
/* sv_catpvn() is now a macro using Perl_sv_catpvn_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_catpvn(pTHX_ SV *dsv, const char* sstr, STRLEN slen)
{
    sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC);
}

d4237 1
d4239 1
a4239 1
    const char *dstr = SvPV_force_flags(dsv, dlen, flags);
d4249 2
a4250 25
}

/*
=for apidoc sv_catpvn_mg

Like C<sv_catpvn>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catpvn_mg(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
{
    sv_catpvn(sv,ptr,len);
    SvSETMAGIC(sv);
}

/* sv_catsv() is now a macro using Perl_sv_catsv_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_catsv(pTHX_ SV *dstr, register SV *sstr)
{
    sv_catsv_flags(dstr, sstr, SV_GMAGIC);
d4272 10
a4281 10
    const char *spv;
    STRLEN slen;
    if (!ssv)
	return;
    if ((spv = SvPV_const(ssv, slen))) {
	/*  sutf8 and dutf8 were type bool, but under USE_ITHREADS,
	    gcc version 2.95.2 20000220 (Debian GNU/Linux) for
	    Linux xxx 2.2.17 on sparc64 with gcc -O2, we erroneously
	    get dutf8 = 0x20000000, (i.e.  SVf_UTF8) even though
	    dsv->sv_flags doesn't have that bit set.
d4283 3
a4285 3
	*/
	const I32 sutf8 = DO_UTF8(ssv);
	I32 dutf8;
d4287 8
a4294 8
	if (SvGMAGICAL(dsv) && (flags & SV_GMAGIC))
	    mg_get(dsv);
	dutf8 = DO_UTF8(dsv);

	if (dutf8 != sutf8) {
	    if (dutf8) {
		/* Not modifying source SV, so taking a temporary copy. */
		SV* csv = sv_2mortal(newSVpvn(spv, slen));
d4296 5
a4300 2
		sv_utf8_upgrade(csv);
		spv = SvPV_const(csv, slen);
d4302 1
a4302 2
	    else
		sv_utf8_upgrade_nomg(dsv);
a4303 1
	sv_catpvn_nomg(dsv, spv, slen);
d4305 2
a4306 15
}

/*
=for apidoc sv_catsv_mg

Like C<sv_catsv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catsv_mg(pTHX_ SV *dsv, register SV *ssv)
{
    sv_catsv(dsv,ssv);
    SvSETMAGIC(dsv);
d4321 1
d4357 10
a4366 3
Create a new null SV, or if len > 0, create a new empty SVt_PV type SV
with an initial PV allocation of len+1. Normally accessed via the C<NEWSV>
macro.
d4374 1
d4404 1
a4404 1
Perl_sv_magicext(pTHX_ SV* sv, SV* obj, int how, MGVTBL *vtable,
d4407 1
d4410 1
a4410 3
    if (SvTYPE(sv) < SVt_PVMG) {
	(void)SvUPGRADE(sv, SVt_PVMG);
    }
d4427 1
d4436 1
a4436 1
	mg->mg_obj = SvREFCNT_inc(obj);
d4460 1
a4460 1
	    mg->mg_ptr = (char*)SvREFCNT_inc((SV*)name);
d4464 1
a4464 1
    mg->mg_virtual = vtable;
d4490 1
d4494 4
d4520 1
a4520 1
	    if (how == PERL_MAGIC_taint)
d4522 5
a4579 5
#ifdef USE_5005THREADS
    case PERL_MAGIC_mutex:
	vtable = &PL_vtbl_mutex;
	break;
#endif /* USE_5005THREADS */
d4595 2
d4612 3
d4619 2
a4620 2
        vtable = &PL_vtbl_utf8;
        break;
a4626 3
    case PERL_MAGIC_glob:
	vtable = &PL_vtbl_glob;
	break;
d4636 3
d4651 1
a4651 1
    mg = sv_magicext(sv,obj,how,(MGVTBL*)vtable,name,namlen);
d4679 1
a4679 1
    mgp = &SvMAGIC(sv);
d4691 1
a4691 1
		else if (mg->mg_type == PERL_MAGIC_utf8 && mg->mg_ptr)
d4703 2
a4704 1
       SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d4716 2
a4717 1
associated with that magic.
d4736 1
a4736 1
    sv_add_backref(tsv, sv);
d4746 2
a4747 2
STATIC void
S_sv_add_backref(pTHX_ SV *tsv, SV *sv)
d4749 1
d4751 38
a4788 9
    MAGIC *mg;
    if (SvMAGICAL(tsv) && (mg = mg_find(tsv, PERL_MAGIC_backref)))
	av = (AV*)mg->mg_obj;
    else {
	av = newAV();
	sv_magic(tsv, (SV*)av, PERL_MAGIC_backref, NULL, 0);
	/* av now has a refcnt of 2, which avoids it getting freed
	 * before us during global cleanup. The extra ref is removed
	 * by magic_killbackrefs() when tsv is being freed */
d4801 1
a4801 1
S_sv_del_backref(pTHX_ SV *sv)
d4803 2
a4804 1
    AV *av;
d4807 17
a4823 3
    SV * const tsv = SvRV(sv);
    MAGIC *mg = NULL;
    if (!SvMAGICAL(tsv) || !(mg = mg_find(tsv, PERL_MAGIC_backref)))
d4825 5
a4829 1
    av = (AV *)mg->mg_obj;
d4844 1
a4844 1
	    svp[fill] = Nullsv;
d4850 42
d4902 1
a4902 1
Perl_sv_insert(pTHX_ SV *bigstr, STRLEN offset, STRLEN len, char *little, STRLEN littlelen)
d4904 1
d5002 1
d5004 5
a5008 3
    SV_CHECK_THINKFIRST(sv);
    if (SvREFCNT(nsv) != 1 && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "Reference miscount in sv_replace()");
d5022 6
d5029 33
d5085 6
a5090 1
    HV* stash;
d5094 7
d5102 3
a5104 1
	if (PL_defstash) {		/* Still have a symbol table? */
d5106 1
d5121 2
a5122 2
		   
		    
d5149 1
a5149 1
	    if (SvTYPE(sv) != SVt_PVIO)
d5153 4
a5156 2
    if (SvTYPE(sv) >= SVt_PVMG) {
    	if (SvMAGIC(sv))
d5158 1
a5158 1
	if (SvTYPE(sv) == SVt_PVMG && SvFLAGS(sv) & SVpad_TYPED)
d5161 2
a5162 2
    stash = NULL;
    switch (SvTYPE(sv)) {
a5176 2
	/* FALL THROUGH */
    case SVt_PVBM:
d5183 1
d5187 4
a5200 1
	goto freescalar;
d5202 16
a5217 8
	gp_free((GV*)sv);
	Safefree(GvNAME(sv));
	/* cannot decrease stash refcount yet, as we might recursively delete
	   ourselves when the refcnt drops to zero. Delay SvREFCNT_dec
	   of stash until current sv is completely gone.
	   -- JohnPC, 27 Mar 1998 */
	stash = GvSTASH(sv);
	/* FALL THROUGH */
a5226 1
	/* FALL THROUGH */
d5230 1
d5232 1
a5232 1
	        sv_del_backref(sv);
d5234 22
a5255 1
	        SvREFCNT_dec(SvRV(sv));
d5257 1
d5261 1
a5261 3
	    unsharepvn(SvPVX_const(sv),
		       SvUTF8(sv) ? -(I32)SvCUR(sv) : SvCUR(sv),
		       SvUVX(sv));
d5264 1
a5265 1
/*
a5266 2
    case SVt_IV:
    case SVt_NULL:
a5267 1
*/
a5269 55
    switch (SvTYPE(sv)) {
    case SVt_NULL:
	break;
    case SVt_IV:
	del_XIV(SvANY(sv));
	break;
    case SVt_NV:
	del_XNV(SvANY(sv));
	break;
    case SVt_RV:
	del_XRV(SvANY(sv));
	break;
    case SVt_PV:
	del_XPV(SvANY(sv));
	break;
    case SVt_PVIV:
	del_XPVIV(SvANY(sv));
	break;
    case SVt_PVNV:
	del_XPVNV(SvANY(sv));
	break;
    case SVt_PVMG:
	del_XPVMG(SvANY(sv));
	break;
    case SVt_PVLV:
	del_XPVLV(SvANY(sv));
	break;
    case SVt_PVAV:
	del_XPVAV(SvANY(sv));
	break;
    case SVt_PVHV:
	del_XPVHV(SvANY(sv));
	break;
    case SVt_PVCV:
	del_XPVCV(SvANY(sv));
	break;
    case SVt_PVGV:
	del_XPVGV(SvANY(sv));
	/* code duplication for increased performance. */
	SvFLAGS(sv) &= SVf_BREAK;
	SvFLAGS(sv) |= SVTYPEMASK;
	/* decrease refcount of the stash that owns this GV, if any */
	if (stash)
	    SvREFCNT_dec(stash);
	return; /* not break, SvFLAGS reset already happened */
    case SVt_PVBM:
	del_XPVBM(SvANY(sv));
	break;
    case SVt_PVFM:
	del_XPVFM(SvANY(sv));
	break;
    case SVt_PVIO:
	del_XPVIO(SvANY(sv));
	break;
    }
d5272 8
d5294 1
d5296 1
a5296 1
	ATOMIC_INC(SvREFCNT(sv));
d5314 1
a5314 2
    int refcount_is_zero;

d5335 4
d5343 1
a5343 2
    ATOMIC_DEC_AND_TEST(refcount_is_zero, SvREFCNT(sv));
    if (!refcount_is_zero)
d5345 7
d5406 4
a5409 2
 * mg_ptr is used, by sv_pos_u2b(), see the comments of S_utf8_mg_pos_init().
 * (Note that the mg_len is not the length of the mg_ptr field.)
d5423 1
a5423 1
	STRLEN len, ulen;
a5424 1
	MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : 0;
d5426 32
a5457 15
	if (mg && mg->mg_len != -1 && (mg->mg_len > 0 || len == 0)) {
	     ulen = mg->mg_len;
#ifdef PERL_UTF8_CACHE_ASSERT
	    assert(ulen == Perl_utf8_length(aTHX_ s, s + len));
#endif
        }
	else {
	     ulen = Perl_utf8_length(aTHX_ (U8 *)s, (U8 *)s + len);
	     if (!mg && !SvREADONLY(sv)) {
		  sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
		  mg = mg_find(sv, PERL_MAGIC_utf8);
		  assert(mg);
	     }
	     if (mg)
		  mg->mg_len = ulen;
d5459 1
a5459 1
	return ulen;
d5463 5
a5467 13
/* S_utf8_mg_pos_init() is used to initialize the mg_ptr field of
 * a PERL_UTF8_magic.  The mg_ptr is used to store the mapping
 * between UTF-8 and byte offsets.  There are two (substr offset and substr
 * length, the i offset, PERL_MAGIC_UTF8_CACHESIZE) times two (UTF-8 offset
 * and byte offset) cache positions.
 *
 * The mg_len field is used by sv_len_utf8(), see its comments.
 * Note that the mg_len is not the length of the mg_ptr field.
 *
 */
STATIC bool
S_utf8_mg_pos_init(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i,
		   I32 offsetp, const U8 *s, const U8 *start)
d5469 1
a5469 1
    bool found = FALSE; 
d5471 9
a5479 4
    if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
	if (!*mgp)
	    *mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, (MGVTBL*)&PL_vtbl_utf8, 0, 0);
	assert(*mgp);
d5481 14
a5494 7
	if ((*mgp)->mg_ptr)
	    *cachep = (STRLEN *) (*mgp)->mg_ptr;
	else {
	    Newxz(*cachep, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
	    (*mgp)->mg_ptr = (char *) *cachep;
	}
	assert(*cachep);
d5496 4
a5499 3
	(*cachep)[i]   = offsetp;
	(*cachep)[i+1] = s - start;
	found = TRUE;
d5501 1
a5501 2

    return found;
d5504 13
a5516 10
/*
 * S_utf8_mg_pos() is used to query and update mg_ptr field of
 * a PERL_UTF8_magic.  The mg_ptr is used to store the mapping
 * between UTF-8 and byte offsets.  See also the comments of
 * S_utf8_mg_pos_init().
 *
 */
STATIC bool
S_utf8_mg_pos(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i, I32 *offsetp, I32 uoff, const U8 **sp, const U8 *start, const U8 *send)
{
d5519 82
a5600 83
    if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
        if (!*mgp)
            *mgp = mg_find(sv, PERL_MAGIC_utf8);
        if (*mgp && (*mgp)->mg_ptr) {
            *cachep = (STRLEN *) (*mgp)->mg_ptr;
	    ASSERT_UTF8_CACHE(*cachep);
            if ((*cachep)[i] == (STRLEN)uoff)	/* An exact match. */
		 found = TRUE;
	    else {			/* We will skip to the right spot. */
		 STRLEN forw  = 0;
		 STRLEN backw = 0;
		 const U8* p = NULL;

		 /* The assumption is that going backward is half
		  * the speed of going forward (that's where the
		  * 2 * backw in the below comes from).  (The real
		  * figure of course depends on the UTF-8 data.) */

		 if ((*cachep)[i] > (STRLEN)uoff) {
		      forw  = uoff;
		      backw = (*cachep)[i] - (STRLEN)uoff;

		      if (forw < 2 * backw)
			   p = start;
		      else
			   p = start + (*cachep)[i+1];
		 }
		 /* Try this only for the substr offset (i == 0),
		  * not for the substr length (i == 2). */
		 else if (i == 0) { /* (*cachep)[i] < uoff */
		      const STRLEN ulen = sv_len_utf8(sv);

		      if ((STRLEN)uoff < ulen) {
			   forw  = (STRLEN)uoff - (*cachep)[i];
			   backw = ulen - (STRLEN)uoff;

			   if (forw < 2 * backw)
				p = start + (*cachep)[i+1];
			   else
				p = send;
		      }

		      /* If the string is not long enough for uoff,
		       * we could extend it, but not at this low a level. */
		 }

		 if (p) {
		      if (forw < 2 * backw) {
			   while (forw--)
				p += UTF8SKIP(p);
		      }
		      else {
			   while (backw--) {
				p--;
				while (UTF8_IS_CONTINUATION(*p))
				     p--;
			   }
		      }

		      /* Update the cache. */
		      (*cachep)[i]   = (STRLEN)uoff;
		      (*cachep)[i+1] = p - start;

		      /* Drop the stale "length" cache */
		      if (i == 0) {
			  (*cachep)[2] = 0;
			  (*cachep)[3] = 0;
		      }

		      found = TRUE;
		 }
	    }
	    if (found) {	/* Setup the return values. */
		 *offsetp = (*cachep)[i+1];
		 *sp = start + *offsetp;
		 if (*sp >= send) {
		      *sp = send;
		      *offsetp = send - start;
		 }
		 else if (*sp < start) {
		      *sp = start;
		      *offsetp = 0;
		 }
d5603 1
a5603 16
#ifdef PERL_UTF8_CACHE_ASSERT
	if (found) {
	     U8 *s = start;
	     I32 n = uoff;

	     while (n-- && s < send)
		  s += UTF8SKIP(s);

	     if (i == 0) {
		  assert(*offsetp == s - start);
		  assert((*cachep)[0] == (STRLEN)uoff);
		  assert((*cachep)[1] == *offsetp);
	     }
	     ASSERT_UTF8_CACHE(*cachep);
	}
#endif
d5606 2
a5607 1
    return found;
d5610 1
d5626 1
a5626 1
 * byte offsets.  See also the comments of S_utf8_mg_pos().
d5641 17
a5657 38
	STRLEN boffset = 0;
	STRLEN *cache = 0;
	const U8 *s = start;
	I32 uoffset = *offsetp;
	const U8 * const send = s + len;
	MAGIC *mg = 0;
	bool found = FALSE;

         if (utf8_mg_pos(sv, &mg, &cache, 0, offsetp, *offsetp, &s, start, send))
             found = TRUE;
	 if (!found && uoffset > 0) {
	      while (s < send && uoffset--)
		   s += UTF8SKIP(s);
	      if (s >= send)
		   s = send;
              if (utf8_mg_pos_init(sv, &mg, &cache, 0, *offsetp, s, start))
                  boffset = cache[1];
	      *offsetp = s - start;
	 }
	 if (lenp) {
	      found = FALSE;
	      start = s;
              if (utf8_mg_pos(sv, &mg, &cache, 2, lenp, *lenp, &s, start, send)) {
                  *lenp -= boffset;
                  found = TRUE;
              }
	      if (!found && *lenp > 0) {
		   I32 ulen = *lenp;
		   if (ulen > 0)
			while (s < send && ulen--)
			     s += UTF8SKIP(s);
		   if (s >= send)
			s = send;
                   utf8_mg_pos_init(sv, &mg, &cache, 2, *lenp, s, start);
	      }
	      *lenp = s - start;
	 }
	 ASSERT_UTF8_CACHE(cache);
d5668 181
d5862 1
a5862 1
 * byte offsets.  See also the comments of S_utf8_mg_pos().
a5864 1

d5869 6
a5874 1
    STRLEN len;
d5879 3
a5881 2
    s = (const U8*)SvPV_const(sv, len);
    if ((I32)len < *offsetp)
a5882 46
    else {
	const U8* send = s + *offsetp;
	MAGIC* mg = NULL;
	STRLEN *cache = NULL;
      
	len = 0;

	if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
	    mg = mg_find(sv, PERL_MAGIC_utf8);
	    if (mg && mg->mg_ptr) {
		cache = (STRLEN *) mg->mg_ptr;
		if (cache[1] == (STRLEN)*offsetp) {
		    /* An exact match. */
		    *offsetp = cache[0];

		    return;
		}
		else if (cache[1] < (STRLEN)*offsetp) {
		    /* We already know part of the way. */
		    len = cache[0];
		    s  += cache[1];
		    /* Let the below loop do the rest. */ 
		}
		else { /* cache[1] > *offsetp */
		    /* We already know all of the way, now we may
		     * be able to walk back.  The same assumption
		     * is made as in S_utf8_mg_pos(), namely that
		     * walking backward is twice slower than
		     * walking forward. */
		    const STRLEN forw  = *offsetp;
		    STRLEN backw = cache[1] - *offsetp;

		    if (!(forw < 2 * backw)) {
			const U8 *p = s + cache[1];
			STRLEN ubackw = 0;
			     
			cache[1] -= backw;

			while (backw--) {
			    p--;
			    while (UTF8_IS_CONTINUATION(*p)) {
				p--;
				backw--;
			    }
			    ubackw++;
			}
d5884 1
a5884 2
			cache[0] -= ubackw;
			*offsetp = cache[0];
d5886 14
a5899 3
			/* Drop the stale "length" cache */
			cache[2] = 0;
			cache[3] = 0;
d5901 9
a5909 2
			return;
		    }
d5912 13
a5924 5
	    ASSERT_UTF8_CACHE(cache);
	 }

	while (s < send) {
	    STRLEN n = 1;
a5925 7
	    /* Call utf8n_to_uvchr() to validate the sequence
	     * (unless a simple non-UTF character) */
	    if (!UTF8_IS_INVARIANT(*s))
		utf8n_to_uvchr((U8 *)s, UTF8SKIP(s), &n, 0);
	    if (n > 0) {
		s += n;
		len++;
d5927 5
a5931 2
	    else
		break;
d5933 3
d5937 9
a5945 4
	if (!SvREADONLY(sv)) {
	    if (!mg) {
		sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
		mg = mg_find(sv, PERL_MAGIC_utf8);
a5946 13
	    assert(mg);

	    if (!mg->mg_ptr) {
		Newxz(cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
		mg->mg_ptr = (char *) cache;
	    }
	    assert(cache);

	    cache[0] = len;
	    cache[1] = *offsetp;
	    /* Drop the stale "length" cache */
	    cache[2] = 0;
	    cache[3] = 0;
d5948 1
a5948 2

	*offsetp = len;
d5950 1
d5952 1
a5952 1
    return;
d5968 1
d5974 2
a5975 2
    char *tpv   = Nullch;
    SV* svrecode = Nullsv;
d5981 8
a5988 1
    else
d5990 1
d6025 1
a6025 1
		   char * const pv = (char*)bytes_from_utf8((U8*)pv1,
d6033 1
a6033 1
		   char * const pv = (char *)bytes_from_utf8((U8*)pv2,
d6040 1
d6047 1
a6047 1
	eq = memEQ(pv1, pv2, cur1);
d6049 1
a6049 3
    if (svrecode)
	 SvREFCNT_dec(svrecode);

d6070 1
d6073 1
a6073 1
    char *tpv = Nullch;
d6075 1
a6075 1
    SV *svrecode = Nullsv;
d6101 1
a6101 1
		 pv2 = tpv = (char*)bytes_to_utf8((U8*)pv2, &cur2);
d6111 1
a6111 1
		 pv1 = tpv = (char*)bytes_to_utf8((U8*)pv1, &cur1);
d6132 1
a6132 3
    if (svrecode)
	 SvREFCNT_dec(svrecode);

d6152 1
d6191 1
a6191 1
    /* FALL THROUGH */
d6217 1
d6236 6
a6241 2
		sv_magic(sv, 0, PERL_MAGIC_collxfrm, 0, 0);
		mg = mg_find(sv, PERL_MAGIC_collxfrm);
d6278 1
a6285 1
    I32 recsize;
d6294 1
a6294 1
    (void)SvUPGRADE(sv, SVt_PV);
d6305 1
a6305 1
	    SV * const tsv = NEWSV(0,0);
d6325 4
a6328 4
    	/* If it is a regular disk file use size from stat() as estimate 
	   of amount we are going to read - may result in malloc-ing 
	   more memory than we realy need if layers bellow reduce 
	   size we read (e.g. CRLF or a gzip layer)
d6343 1
d6346 1
a6346 1
      recsize = SvIV(SvRV(PL_rs));
d6433 1
a6433 1
    if ((I32)(SvLEN(sv) - append) <= cnt + 1) { 
d6435 1
a6435 1
	   if we are looking for a separator and room for some 
d6438 1
a6438 1
	    /* just process what we have room for */ 
d6448 1
a6448 1
    else 
d6549 1
a6549 1
	STDCHAR *buf = 0;
d6558 1
a6558 1
            register const STDCHAR *bpe = buf + sizeof(buf);
d6599 1
a6599 1
	    if (!(cnt < sizeof(buf) && PerlIO_eof(fp)))
d6619 1
a6619 1
    return (SvCUR(sv) - append) ? SvPVX(sv) : Nullch;
d6634 1
d6640 1
a6640 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d6642 2
a6643 2
	if (SvREADONLY(sv) && SvFAKE(sv))
	    sv_force_normal(sv);
d6693 1
a6693 1
	    sv_upgrade(sv, SVt_IV);
d6791 1
d6796 1
a6796 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d6798 2
a6799 2
	if (SvREADONLY(sv) && SvFAKE(sv))
	    sv_force_normal(sv);
d6908 1
d6933 1
d6958 1
d6960 1
a6960 1
	return sv;
d6982 1
d6986 1
a6986 1
    sv_setpvn(sv,s,len ? len : strlen(s));
d7004 1
d7026 1
d7049 1
a7049 1
	} else if (flags & HVhek_REHASH) {
d7054 4
a7057 1
	       into an hv routine with a regular hash  */
d7065 17
a7081 3
	return newSVpvn_share(HEK_KEY(hek),
			      (HEK_UTF8(hek) ? -HEK_LEN(hek) : HEK_LEN(hek)),
			      HEK_HASH(hek));
d7090 5
a7094 5
first.  Turns on READONLY and FAKE.  The string's hash is stored in the UV
slot of the SV; if the C<hash> parameter is non-zero, that value is used;
otherwise the hash is computed.  The idea here is that as the string table
is used for shared hash keys these strings will have SvPVX_const == HeKEY and
hash lookup will avoid string compare.
d7102 1
d7105 2
d7111 1
a7111 1
	src = (char*)bytes_from_utf8((U8*)src, &tmplen, &is_utf8);
d7117 1
a7117 1
    sv_upgrade(sv, SVt_PVIV);
a7119 1
    SvUV_set(sv, hash);
d7126 2
d7177 1
d7180 1
a7180 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
d7196 1
d7216 1
d7236 1
d7245 19
d7275 2
a7276 4
    register SV *sv;

    new_SV(sv);
    sv_upgrade(sv, SVt_RV);
d7288 1
a7288 1
Perl_newRV(pTHX_ SV *tmpRef)
d7290 2
a7291 1
    return newRV_noinc(SvREFCNT_inc(tmpRef));
d7306 1
d7310 1
a7310 1
	return Nullsv;
d7314 1
a7314 1
	return Nullsv;
d7334 1
a7334 1
Perl_sv_reset(pTHX_ register char *s, HV *stash)
d7336 1
a7336 1
    register PMOP *pm;
d7343 14
a7356 2
	for (pm = HvPMROOT(stash); pm; pm = pm->op_pmnext) {
	    pm->op_pmdynflags &= ~PMdf_USED;
d7401 1
a7401 1
			if (SvPVX_const(sv) != Nullch)
a7439 1
    STRLEN n_a;
d7456 1
a7456 1
	gv = gv_fetchpv(SvPV(sv,n_a), FALSE, SVt_PVIO);
d7462 1
a7462 1
	    Perl_croak(aTHX_ "Bad filehandle: %"SVf, sv);
d7473 1
d7481 3
a7483 3
    GV *gv = Nullgv;
    CV *cv = Nullcv;
    STRLEN n_a;
d7485 5
a7489 2
    if (!sv)
	return *gvp = Nullgv, Nullcv;
d7493 1
a7493 1
	*gvp = Nullgv;
d7497 3
a7499 2
	*gvp = Nullgv;
	return Nullcv;
d7507 1
a7507 2
	if (SvGMAGICAL(sv))
	    mg_get(sv);
d7515 1
a7515 1
		*gvp = Nullgv;
d7527 1
a7527 1
	    gv = gv_fetchpv(SvPV(sv, n_a), lref, SVt_PVCV);
d7529 9
a7537 2
	if (!gv)
	    return Nullcv;
d7543 2
a7544 2
	    tmpsv = NEWSV(704,0);
	    gv_efullname3(tmpsv, gv, Nullch);
d7550 1
a7550 2
		   Nullop,
		   Nullop);
d7554 1
a7554 1
			   sv);
d7579 1
a7579 1
		(tXpv->xpv_cur && *tXpv->xpv_pv != '0')))
a7596 114
=for apidoc sv_iv

A private implementation of the C<SvIVx> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

IV
Perl_sv_iv(pTHX_ register SV *sv)
{
    if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    return (IV)SvUVX(sv);
	return SvIVX(sv);
    }
    return sv_2iv(sv);
}

/*
=for apidoc sv_uv

A private implementation of the C<SvUVx> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

UV
Perl_sv_uv(pTHX_ register SV *sv)
{
    if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    return SvUVX(sv);
	return (UV)SvIVX(sv);
    }
    return sv_2uv(sv);
}

/*
=for apidoc sv_nv

A private implementation of the C<SvNVx> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

NV
Perl_sv_nv(pTHX_ register SV *sv)
{
    if (SvNOK(sv))
	return SvNVX(sv);
    return sv_2nv(sv);
}

/* sv_pv() is now a macro using SvPV_nolen();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pv(pTHX_ SV *sv)
{
    if (SvPOK(sv))
	return SvPVX(sv);

    return sv_2pv(sv, 0);
}

/*
=for apidoc sv_pv

Use the C<SvPV_nolen> macro instead

=for apidoc sv_pvn

A private implementation of the C<SvPV> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

char *
Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp)
{
    if (SvPOK(sv)) {
	*lp = SvCUR(sv);
	return SvPVX(sv);
    }
    return sv_2pv(sv, lp);
}


char *
Perl_sv_pvn_nomg(pTHX_ register SV *sv, STRLEN *lp)
{
    if (SvPOK(sv)) {
	*lp = SvCUR(sv);
	return SvPVX(sv);
    }
    return sv_2pv_flags(sv, lp, 0);
}

/* sv_pvn_force() is now a macro using Perl_sv_pvn_force_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvn_force(pTHX_ SV *sv, STRLEN *lp)
{
    return sv_pvn_force_flags(sv, lp, SV_GMAGIC);
}

/*
d7618 1
a7618 1

d7620 1
a7620 1
	sv_force_normal(sv);
d7648 1
a7648 1
	    (void)SvUPGRADE(sv, SVt_PV);		/* Never FALSE */
d7652 1
a7652 1
	    *SvEND(sv) = '\0';
a7663 32
/* sv_pvbyte () is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvbyte(pTHX_ SV *sv)
{
    sv_utf8_downgrade(sv,0);
    return sv_pv(sv);
}

/*
=for apidoc sv_pvbyte

Use C<SvPVbyte_nolen> instead.

=for apidoc sv_pvbyten

A private implementation of the C<SvPVbyte> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.

=cut
*/

char *
Perl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp)
{
    sv_utf8_downgrade(sv,0);
    return sv_pvn(sv,lp);
}

d7667 1
a7667 3
A private implementation of the C<SvPVbytex_force> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.
a7680 32
/* sv_pvutf8 () is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvutf8(pTHX_ SV *sv)
{
    sv_utf8_upgrade(sv);
    return sv_pv(sv);
}

/*
=for apidoc sv_pvutf8

Use the C<SvPVutf8_nolen> macro instead

=for apidoc sv_pvutf8n

A private implementation of the C<SvPVutf8> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.

=cut
*/

char *
Perl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp)
{
    sv_utf8_upgrade(sv);
    return sv_pvn(sv,lp);
}

d7684 1
a7684 3
A private implementation of the C<SvPVutf8_force> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.
d7706 2
a7707 2
char *
Perl_sv_reftype(pTHX_ SV *sv, int ob)
d7725 2
a7726 1
	case SVt_PVBM:
d7743 1
d7764 1
a7764 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d7789 1
a7789 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d7816 1
d7821 2
a7822 2
    SV_CHECK_THINKFIRST(rv);
    SvAMAGIC_off(rv);
a7829 1
    }
d7831 4
a7834 1
    if (SvTYPE(rv) < SVt_RV)
d7847 1
a7847 1
	HV* const stash = gv_stashpv(classname, TRUE);
d7860 1
a7860 1
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
d7874 1
d7890 1
a7890 1
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
d7909 1
a7909 1
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
d7928 1
a7928 1
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
d7948 1
a7948 1
C<Nullch> to avoid the blessing.  The new SV will have a reference count 
d7957 1
a7957 1
Perl_sv_setref_pvn(pTHX_ SV *rv, const char *classname, char *pv, STRLEN n)
d7976 1
d7982 2
d7995 2
a7996 2
    (void)SvUPGRADE(tmpRef, SVt_PVMG);
    SvSTASH_set(tmpRef, (HV*)SvREFCNT_inc(stash));
d8001 1
a8001 1
	SvAMAGIC_off(sv);
d8018 1
d8020 2
d8025 5
a8029 1
    if (GvGP(sv))
d8031 1
d8033 2
a8034 2
	SvREFCNT_dec(GvSTASH(sv));
	GvSTASH(sv) = Nullhv;
a8035 2
    sv_unmagic(sv, PERL_MAGIC_glob);
    Safefree(GvNAME(sv));
d8037 4
d8050 4
d8071 1
a8071 1
Perl_sv_unref_flags(pTHX_ SV *sv, U32 flags)
d8073 1
a8073 1
    SV const * rv = SvRV(sv);
d8075 4
a8078 4
    if (SvWEAKREF(sv)) {
    	sv_del_backref(sv);
	SvWEAKREF_off(sv);
	SvRV_set(sv, NULL);
d8081 3
a8083 3
    SvRV_set(sv, NULL);
    SvROK_off(sv);
    /* You can't have a || SvREADONLY(rv) here, as $a = $$a, where $a was
d8085 2
a8086 2
    if (SvREFCNT(rv) != 1 || (flags & SV_IMMEDIATE_UNREF))
	SvREFCNT_dec(rv);
d8088 1
a8088 31
	sv_2mortal((SV *)rv);		/* Schedule for freeing later */
}

/*
=for apidoc sv_unref

Unsets the RV status of the SV, and decrements the reference count of
whatever was being referenced by the RV.  This can almost be thought of
as a reversal of C<newSVrv>.  This is C<sv_unref_flags> with the C<flag>
being zero.  See C<SvROK_off>.

=cut
*/

void
Perl_sv_unref(pTHX_ SV *sv)
{
    sv_unref_flags(sv, 0);
}

/*
=for apidoc sv_taint

Taint an SV. Use C<SvTAINTED_on> instead.
=cut
*/

void
Perl_sv_taint(pTHX_ SV *sv)
{
    sv_magic((sv), Nullsv, PERL_MAGIC_taint, Nullch, 0);
d8120 1
a8120 1
	if (mg && ((mg->mg_len & 1) || ((mg->mg_len & 2) && mg->mg_obj == sv)))
d8156 1
a8156 5
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char * const ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    sv_setpvn(sv, ptr, ebuf - ptr);
d8225 1
a8225 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
d8258 1
a8258 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
d8331 1
a8331 1
    sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
d8364 1
a8364 1
    sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
a8385 2
/* private function for use in sv_vcatpvfn via the EXPECT_NUMBER macro */

d8389 1
d8395 7
a8401 2
	while (isDIGIT(**pattern))
	    var = var * 10 + (*(*pattern)++ - '0');
a8404 1
#define EXPECT_NUMBER(pattern, var) (var = S_expect_number(aTHX_ &pattern))
d8406 2
a8407 2
static char *
F0convert(NV nv, char *endbuf, STRLEN *len)
d8429 1
a8429 1
    return Nullch;
a8441 2
XXX Except that it maybe_tainted is never assigned to.

d8447 5
d8457 1
d8464 1
a8464 1
    SV *argsv = Nullsv;
d8467 1
a8467 1
    SV *nsv = Nullsv;
d8480 1
a8480 1
    /* special-case "", "%s", and "%_" */
d8483 1
a8483 3
    if (patlen == 2 && pat[0] == '%') {
	switch (pat[1]) {
	case 's':
a8489 2
	    if (DO_UTF8(*svargs))
		SvUTF8_on(sv);
d8492 6
a8497 11
	case '_':
	    if (args) {
		argsv = va_arg(*args, SV*);
		sv_catsv(sv, argsv);
		if (DO_UTF8(argsv))
		    SvUTF8_on(sv);
		return;
	    }
	    /* See comment on '_' below */
	    break;
	}
d8557 1
a8557 1
	I32 osvix = svix;
d8569 1
a8569 1
	const char *eptr = Nullch;
d8571 2
a8572 2
	SV *vecsv = Nullsv;
	const U8 *vecstr = Null(U8*);
d8619 1
a8619 1
    [%bcdefginopsux_DFOUX] format (mandatory)
d8621 47
a8667 1
	if (EXPECT_NUMBER(q, width)) {
d8682 4
a8685 1
		plus = *q++;
d8711 1
a8711 1
	    if (EXPECT_NUMBER(q, ewix))
d8731 1
a8731 1
	    if( *q == '0' ) 
d8733 1
a8733 1
	    EXPECT_NUMBER(q, width);
a8735 5
#ifdef CHECK_FORMAT
	if ((*q == 'p') && left) {
            vectorize = (width == 1);
	}
#endif
d8759 1
a8759 3
		vecsv = va_arg(*args, SV*);
		vecstr = (U8*)SvPV_const(vecsv,veclen);
		vec_utf8 = DO_UTF8(vecsv);
d8765 18
a8784 1
		vecsv = &PL_sv_undef;
d8807 1
a8807 1
		if (EXPECT_NUMBER(q, epix) && *q++ != '$')
d8817 2
a8818 1
		precis = (i < 0) ? 0 : i;
d8824 1
a8825 1
	    has_precis = TRUE;
d8852 1
a8852 1
	    /* FALL THROUGH */
d8868 1
a8868 1
	    /* FALL THROUGH */
d8870 1
a8870 1
	    /* FALL THROUGH */
d8881 4
d8888 1
a8888 3
	if (vectorize)
	    argsv = vecsv;
	else if (!args) {
d8903 3
a8905 1
	    uv = (args && !vectorize) ? va_arg(*args, int) : SvIVx(argsv);
d8921 3
a8923 1
	    if (args && !vectorize) {
d8939 1
a8939 1
		eptr = SvPVx_const(argsv, elen);
d8941 1
d8948 4
a8951 1
			width += elen - sv_len_utf8(argsv);
a8955 17
	    goto string;

	case '_':
#ifdef CHECK_FORMAT
	format_sv:
#endif
	    /*
	     * The "%_" hack might have to be changed someday,
	     * if ISO or ANSI decide to use '_' for something.
	     * So we keep it hidden from users' code.
	     */
	    if (!args || vectorize)
		goto unknown;
	    argsv = va_arg(*args, SV*);
	    eptr = SvPVx(argsv, elen);
	    if (DO_UTF8(argsv))
		is_utf8 = TRUE;
a8957 1
	    vectorize = FALSE;
a8964 15
#ifdef CHECK_FORMAT
	    if (left) {
		left = FALSE;
	        if (!width)
		    goto format_sv;	/* %-p	-> %_	*/
		if (vectorize) {
		    width = 0;
		    goto format_vd;	/* %-1p	-> %vd  */      
		}
		precis = width;
		has_precis = TRUE;
		width = 0;
		goto format_sv;		/* %-Np	-> %.N_	*/	
	    }
#endif
d8977 1
a8977 1
	    /* FALL THROUGH */
d8980 1
a8980 1
#ifdef CHECK_FORMAT
d8988 1
a8988 1
		    uv = utf8n_to_uvchr((U8 *)vecstr, veclen, &ulen,
d9011 1
a9011 1
		IV tiv = SvIVx(argsv); /* work around GCC bug #13488 */
d9043 1
a9043 1
	    /* FALL THROUGH */
d9048 1
d9059 1
a9059 1
	    /* FALL THROUGH */
d9075 1
a9075 1
		    uv = utf8n_to_uvchr((U8 *)vecstr, veclen, &ulen,
d9096 1
a9096 1
		UV tuv = SvUVx(argsv); /* work around GCC bug #13488 */
d9111 3
d9117 1
a9117 4
		    if (!uv)
			alt = FALSE;
		    p = (char*)((c == 'X')
				? "0123456789ABCDEF" : "0123456789abcdef");
d9122 1
a9122 1
		    if (alt) {
a9135 2
		    if (!uv)
			alt = FALSE;
d9140 1
a9140 1
		    if (alt) {
d9142 1
a9142 1
			esignbuf[esignlen++] = 'b';
a9145 13
#if defined(PERL_Y2KWARN)
		    if (ckWARN(WARN_Y2K)) {
			STRLEN n;
			const char *const s = SvPV_const(sv,n);
			if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
			    && (n == 2 || !isDIGIT(s[n-3])))
			    {
				Perl_warner(aTHX_ packWARN(WARN_Y2K),
					    "Possible Y2K bug: %%%c %s",
					    c, "format string following '19'");
			    }
		    }
#endif
d9157 2
a9158 1
		    else if (precis == 0 && elen == 1 && *ptr == '0')
d9160 4
d9172 1
a9172 1
	    /* FALL THROUGH */
d9176 2
d9193 1
a9193 1
		/* FALL THROUGH */
d9203 1
a9203 1
		/* FALL THROUGH */
d9210 1
a9210 1
	    nv = (args && !vectorize) ?
d9218 1
a9218 1
		: SvNVx(argsv);
d9221 3
a9223 2
	    vectorize = FALSE;
	    if (c != 'e' && c != 'E') {
d9318 3
a9320 1
		    if (*PL_efloatbuf)	/* May return an empty string for digits==0 */
d9322 1
d9366 3
a9368 4
		if (intsize == 'q')
		    (void)sprintf(PL_efloatbuf, ptr, nv);
		else
		    (void)sprintf(PL_efloatbuf, ptr, (double)nv);
d9370 1
a9370 1
		(void)sprintf(PL_efloatbuf, ptr, nv);
a9374 1
	    elen = strlen(PL_efloatbuf);
d9380 2
d9383 1
a9383 1
	    if (args && !vectorize) {
a9395 1
	    vectorize = FALSE;
d9406 1
a9406 1
		SV *msg = sv_newmortal();
d9418 2
a9419 2
		    sv_catpv(msg, "end of string");
		Perl_warner(aTHX_ packWARN(WARN_PRINTF), "%"SVf, msg); /* yes, this is reentrant */
d9439 19
a9457 1
	/* calculate width before utf8_upgrade changes it */
a9461 23
	if (is_utf8 != has_utf8) {
	     if (is_utf8) {
		  if (SvCUR(sv))
		       sv_utf8_upgrade(sv);
	     }
	     else {
		  SV * const nsv = sv_2mortal(newSVpvn(eptr, elen));
		  sv_utf8_upgrade(nsv);
		  eptr = SvPVX_const(nsv);
		  elen = SvCUR(nsv);
	     }
	     SvGROW(sv, SvCUR(sv) + elen + 1);
	     p = SvEND(sv);
	     *p = '\0';
	}
	/* Use memchr() instead of strchr(), as eptr is not guaranteed */
	/* to point to a null-terminated string.                       */
	if (left && ckWARN(WARN_PRINTF) && memchr(eptr, '\n', elen) && 
	    (PL_op->op_type == OP_PRTF || PL_op->op_type == OP_SPRINTF)) 
	    Perl_warner(aTHX_ packWARN(WARN_PRINTF),
		"Newline in left-justified string for %sprintf",
			(PL_op->op_type == OP_PRTF) ? "" : "s");
	
d9524 1
a9524 1
The foo_dup() functions make an exact copy of an existing foo thinngy.
d9536 1
a9536 4
#if defined(USE_5005THREADS)
#  include "error: USE_5005THREADS and USE_ITHREADS are incompatible"
#endif

d9542 3
d9546 1
d9557 2
a9558 2
#define SAVEPV(p)	(p ? savepv(p) : Nullch)
#define SAVEPVN(p,n)	(p ? savepvn(p,n) : Nullch)
d9560 1
d9562 2
a9563 5
/* Duplicate a regexp. Required reading: pregcomp() and pregfree() in
   regcomp.c. AMS 20010712 */

REGEXP *
Perl_re_dup(pTHX_ REGEXP *r, CLONE_PARAMS *param)
d9565 1
a9565 3
    REGEXP *ret;
    int i, len, npar;
    struct reg_substr_datum *s;
d9567 2
a9568 2
    if (!r)
	return (REGEXP *)NULL;
d9570 4
a9573 2
    if ((ret = (REGEXP *)ptr_table_fetch(PL_ptr_table, r)))
	return ret;
d9575 3
a9577 5
    len = r->offsets[0];
    npar = r->nparens+1;

    Newxc(ret, sizeof(regexp) + (len+1)*sizeof(regnode), char, regexp);
    Copy(r->program, ret->program, len+1, regnode);
d9579 2
a9580 52
    Newx(ret->startp, npar, I32);
    Copy(r->startp, ret->startp, npar, I32);
    Newx(ret->endp, npar, I32);
    Copy(r->startp, ret->startp, npar, I32);

    Newx(ret->substrs, 1, struct reg_substr_data);
    for (s = ret->substrs->data, i = 0; i < 3; i++, s++) {
	s->min_offset = r->substrs->data[i].min_offset;
	s->max_offset = r->substrs->data[i].max_offset;
	s->substr     = sv_dup_inc(r->substrs->data[i].substr, param);
	s->utf8_substr = sv_dup_inc(r->substrs->data[i].utf8_substr, param);
    }

    ret->regstclass = NULL;
    if (r->data) {
	struct reg_data *d;
        const int count = r->data->count;
	int i;

	Newxc(d, sizeof(struct reg_data) + count*sizeof(void *),
		char, struct reg_data);
	Newx(d->what, count, U8);

	d->count = count;
	for (i = 0; i < count; i++) {
	    d->what[i] = r->data->what[i];
	    switch (d->what[i]) {
	    case 's':
		d->data[i] = sv_dup_inc((SV *)r->data->data[i], param);
		break;
	    case 'p':
		d->data[i] = av_dup_inc((AV *)r->data->data[i], param);
		break;
	    case 'f':
		/* This is cheating. */
		Newx(d->data[i], 1, struct regnode_charclass_class);
		StructCopy(r->data->data[i], d->data[i],
			    struct regnode_charclass_class);
		ret->regstclass = (regnode*)d->data[i];
		break;
	    case 'o':
		/* Compiled op trees are readonly, and can thus be
		   shared without duplication. */
		OP_REFCNT_LOCK;
		d->data[i] = (void*)OpREFCNT_inc((OP*)r->data->data[i]);
		OP_REFCNT_UNLOCK;
		break;
	    case 'n':
		d->data[i] = r->data->data[i];
		break;
	    }
	}
d9582 43
a9624 4
	ret->data = d;
    }
    else
	ret->data = NULL;
a9625 2
    Newx(ret->offsets, 2*len+1, U32);
    Copy(r->offsets, ret->offsets, 2*len+1, U32);
d9627 1
a9627 8
    ret->precomp        = SAVEPVN(r->precomp, r->prelen);
    ret->refcnt         = r->refcnt;
    ret->minlen         = r->minlen;
    ret->prelen         = r->prelen;
    ret->nparens        = r->nparens;
    ret->lastparen      = r->lastparen;
    ret->lastcloseparen = r->lastcloseparen;
    ret->reganch        = r->reganch;
d9629 3
a9631 1
    ret->sublen         = r->sublen;
d9633 32
a9664 4
    if (RX_MATCH_COPIED(ret))
	ret->subbeg  = SAVEPVN(r->subbeg, r->sublen);
    else
	ret->subbeg = Nullch;
d9666 8
a9673 2
    ptr_table_store(PL_ptr_table, r, ret);
    return ret;
d9676 1
d9705 1
d9718 1
a9739 1
    ret->gp_flags	= gp->gp_flags;
d9741 1
a9741 1
    ret->gp_file	= gp->gp_file;		/* points to COP.cop_file */
d9771 1
a9771 1
	    nmg->mg_obj	= (SV*)re_dup((REGEXP*)mg->mg_obj, param);
d9774 3
a9776 9
	    const AV * const av = (AV*) mg->mg_obj;
	    SV **svp;
	    I32 i;
	    (void)SvREFCNT_inc(nmg->mg_obj = (SV*)newAV());
	    svp = AvARRAY(av);
	    for (i = AvFILLp(av); i >= 0; i--) {
		if (!svp[i]) continue;
		av_push((AV*)nmg->mg_obj,sv_dup(svp[i],param));
	    }
d9791 2
a9792 2
		    AMT *amtp = (AMT*)mg->mg_ptr;
		    AMT *namtp = (AMT*)nmg->mg_ptr;
d9810 2
d9818 2
d9830 5
d9836 1
a9836 38

STATIC void
S_more_pte(pTHX)
{
    struct ptr_tbl_ent* pte;
    struct ptr_tbl_ent* pteend;
    XPV *ptr;
    New(54, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_pte_arenaroot;
    PL_pte_arenaroot = ptr;

    pte = (struct ptr_tbl_ent*)ptr;
    pteend = &pte[PERL_ARENA_SIZE / sizeof(struct ptr_tbl_ent) - 1];
    PL_pte_root = ++pte;
    while (pte < pteend) {
	pte->next = pte + 1;
	pte++;
    }
    pte->next = 0;
}

STATIC struct ptr_tbl_ent*
S_new_pte(pTHX)
{
    struct ptr_tbl_ent* pte;
    if (!PL_pte_root)
	S_more_pte(aTHX);
    pte = PL_pte_root;
    PL_pte_root = pte->next;
    return pte;
}

STATIC void
S_del_pte(pTHX_ struct ptr_tbl_ent*p)
{
    p->next = PL_pte_root;
    PL_pte_root = p;
}
d9840 2
a9841 3
void *
Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *tbl, void *sv)
{
d9848 1
a9848 1
	    return tblent->newval;
d9850 9
a9858 1
    return (void*)NULL;
d9864 1
a9864 1
Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, void *oldsv, void *newsv)
d9866 2
a9867 6
    PTR_TBL_ENT_t *tblent, **otblent;
    /* XXX this may be pessimal on platforms where pointers aren't good
     * hash values e.g. if they grow faster in the most significant
     * bits */
    const UV hash = PTR_TABLE_HASH(oldsv);
    bool empty = 1;
d9869 14
a9882 7
    assert(tbl);
    otblent = &tbl->tbl_ary[hash & tbl->tbl_max];
    for (tblent = *otblent; tblent; empty=0, tblent = tblent->next) {
	if (tblent->oldval == oldsv) {
	    tblent->newval = newsv;
	    return;
	}
a9883 8
    tblent = S_new_pte(aTHX);
    tblent->oldval = oldsv;
    tblent->newval = newsv;
    tblent->next = *otblent;
    *otblent = tblent;
    tbl->tbl_items++;
    if (!empty && tbl->tbl_items > tbl->tbl_max)
	ptr_table_split(tbl);
d9895 1
d9924 3
a9926 4
    register PTR_TBL_ENT_t **array;
    register PTR_TBL_ENT_t *entry;
    UV riter = 0;
    UV max;
d9928 2
a9929 3
    if (!tbl || !tbl->tbl_items) {
        return;
    }
d9931 6
a9936 3
    array = tbl->tbl_ary;
    entry = array[0];
    max = tbl->tbl_max;
d9938 1
a9938 12
    for (;;) {
        if (entry) {
            PTR_TBL_ENT_t *oentry = entry;
            entry = entry->next;
            S_del_pte(aTHX_ oentry);
        }
        if (!entry) {
            if (++riter > max) {
                break;
            }
            entry = array[riter];
        }
a9939 2

    tbl->tbl_items = 0;
d9955 1
a9955 6
#ifdef DEBUGGING
char *PL_watch_pvx;
#endif


/* duplicate an SV of any type (including AV, HV etc) */
d9958 1
a9958 1
Perl_rvpv_dup(pTHX_ SV *dstr, SV *sstr, CLONE_PARAMS* param)
d9971 6
d9980 8
a9987 16
	    if (SvREADONLY(sstr) && SvFAKE(sstr)) {
		/* A "shared" PV - clone it as unshared string */
                if(SvPADTMP(sstr)) {
                    /* However, some of them live in the pad
                       and they should not have these flags
                       turned off */

                    SvPV_set(dstr, sharepvn(SvPVX_const(sstr), SvCUR(sstr),
                                           SvUVX(sstr)));
                    SvUV_set(dstr, SvUVX(sstr));
                } else {

                    SvPV_set(dstr, SAVEPVN(SvPVX_const(sstr), SvCUR(sstr)));
                    SvFAKE_off(dstr);
                    SvREADONLY_off(dstr);
                }
d9992 1
a9992 1
            }
d9996 1
a9996 1
	/* Copy the Null */
d10000 1
a10000 1
	    SvPV_set(dstr, 0);
d10004 2
d10007 1
a10007 1
Perl_sv_dup(pTHX_ SV *sstr, CLONE_PARAMS* param)
d10009 1
d10013 1
a10013 1
	return Nullsv;
d10022 5
a10026 6
	const char *hvname;

        if(SvTYPE(sstr) == SVt_PVHV &&
	   (hvname = HvNAME_get(sstr))) {
	    /** don't clone stashes if they already exist **/
	    return (SV*)gv_stashpv(hvname,0);
d10032 9
d10051 1
a10051 1
		      PL_watch_pvx, SvPVX_const(sstr));
d10056 1
a10056 2
	SvFLAGS(dstr) &= ~SVTYPEMASK;
	SvOBJECT_off(dstr);
d10065 1
a10065 1
	SvANY(dstr)	= new_XIV();
d10073 1
a10073 1
	SvANY(dstr)	= new_XRV();
d10076 36
a10111 146
    case SVt_PV:
	SvANY(dstr)	= new_XPV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	break;
    case SVt_PVIV:
	SvANY(dstr)	= new_XPVIV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	break;
    case SVt_PVNV:
	SvANY(dstr)	= new_XPVNV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	break;
    case SVt_PVMG:
	SvANY(dstr)	= new_XPVMG();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	break;
    case SVt_PVBM:
	SvANY(dstr)	= new_XPVBM();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	BmRARE(dstr)	= BmRARE(sstr);
	BmUSEFUL(dstr)	= BmUSEFUL(sstr);
	BmPREVIOUS(dstr)= BmPREVIOUS(sstr);
	break;
    case SVt_PVLV:
	SvANY(dstr)	= new_XPVLV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	LvTARGOFF(dstr)	= LvTARGOFF(sstr);	/* XXX sometimes holds PMOP* when DEBUGGING */
	LvTARGLEN(dstr)	= LvTARGLEN(sstr);
	if (LvTYPE(sstr) == 't') /* for tie: unrefcnted fake (SV**) */
	    LvTARG(dstr) = dstr;
	else if (LvTYPE(sstr) == 'T') /* for tie: fake HE */
	    LvTARG(dstr) = (SV*)he_dup((HE*)LvTARG(sstr), 0, param);
	else
	    LvTARG(dstr) = sv_dup_inc(LvTARG(sstr), param);
	LvTYPE(dstr)	= LvTYPE(sstr);
	break;
    case SVt_PVGV:
	if (GvUNIQUE((GV*)sstr)) {
	    /* Do sharing here.  */
	}
	SvANY(dstr)	= new_XPVGV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	GvNAMELEN(dstr)	= GvNAMELEN(sstr);
	GvNAME(dstr)	= SAVEPVN(GvNAME(sstr), GvNAMELEN(sstr));
    	GvSTASH(dstr)	= hv_dup_inc(GvSTASH(sstr), param);
	GvFLAGS(dstr)	= GvFLAGS(sstr);
	GvGP(dstr)	= gp_dup(GvGP(sstr), param);
	(void)GpREFCNT_inc(GvGP(dstr));
	break;
    case SVt_PVIO:
	SvANY(dstr)	= new_XPVIO();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	IoIFP(dstr)	= fp_dup(IoIFP(sstr), IoTYPE(sstr), param);
	if (IoOFP(sstr) == IoIFP(sstr))
	    IoOFP(dstr) = IoIFP(dstr);
	else
	    IoOFP(dstr)	= fp_dup(IoOFP(sstr), IoTYPE(sstr), param);
	/* PL_rsfp_filters entries have fake IoDIRP() */
	if (IoDIRP(sstr) && !(IoFLAGS(sstr) & IOf_FAKE_DIRP))
	    IoDIRP(dstr)	= dirp_dup(IoDIRP(sstr));
	else
	    IoDIRP(dstr)	= IoDIRP(sstr);
	IoLINES(dstr)		= IoLINES(sstr);
	IoPAGE(dstr)		= IoPAGE(sstr);
	IoPAGE_LEN(dstr)	= IoPAGE_LEN(sstr);
	IoLINES_LEFT(dstr)	= IoLINES_LEFT(sstr);
        if(IoFLAGS(sstr) & IOf_FAKE_DIRP) { 
            /* I have no idea why fake dirp (rsfps)
               should be treaded differently but otherwise
               we end up with leaks -- sky*/
            IoTOP_GV(dstr)      = gv_dup_inc(IoTOP_GV(sstr), param);
            IoFMT_GV(dstr)      = gv_dup_inc(IoFMT_GV(sstr), param);
            IoBOTTOM_GV(dstr)   = gv_dup_inc(IoBOTTOM_GV(sstr), param);
        } else {
            IoTOP_GV(dstr)      = gv_dup(IoTOP_GV(sstr), param);
            IoFMT_GV(dstr)      = gv_dup(IoFMT_GV(sstr), param);
            IoBOTTOM_GV(dstr)   = gv_dup(IoBOTTOM_GV(sstr), param);
        }
	IoTOP_NAME(dstr)	= SAVEPV(IoTOP_NAME(sstr));
	IoFMT_NAME(dstr)	= SAVEPV(IoFMT_NAME(sstr));
	IoBOTTOM_NAME(dstr)	= SAVEPV(IoBOTTOM_NAME(sstr));
	IoSUBPROCESS(dstr)	= IoSUBPROCESS(sstr);
	IoTYPE(dstr)		= IoTYPE(sstr);
	IoFLAGS(dstr)		= IoFLAGS(sstr);
	break;
    case SVt_PVAV:
	SvANY(dstr)	= new_XPVAV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	AvARYLEN((AV*)dstr) = sv_dup_inc(AvARYLEN((AV*)sstr), param);
	AvFLAGS((AV*)dstr) = AvFLAGS((AV*)sstr);
	if (AvARRAY((AV*)sstr)) {
	    SV **dst_ary, **src_ary;
	    SSize_t items = AvFILLp((AV*)sstr) + 1;

	    src_ary = AvARRAY((AV*)sstr);
	    Newz(0, dst_ary, AvMAX((AV*)sstr)+1, SV*);
	    ptr_table_store(PL_ptr_table, src_ary, dst_ary);
	    SvPV_set(dstr, (char*)dst_ary);
	    AvALLOC((AV*)dstr) = dst_ary;
	    if (AvREAL((AV*)sstr)) {
		while (items-- > 0)
		    *dst_ary++ = sv_dup_inc(*src_ary++, param);
d10113 29
a10141 3
	    else {
		while (items-- > 0)
		    *dst_ary++ = sv_dup(*src_ary++, param);
d10143 169
a10311 31
	    items = AvMAX((AV*)sstr) - AvFILLp((AV*)sstr);
	    while (items-- > 0) {
		*dst_ary++ = &PL_sv_undef;
	    }
	}
	else {
	    SvPV_set(dstr, Nullch);
	    AvALLOC((AV*)dstr)	= (SV**)NULL;
	}
	break;
    case SVt_PVHV:
	SvANY(dstr)	= new_XPVHV();
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	HvTOTALKEYS(dstr) = HvTOTALKEYS(sstr);
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	HvRITER_set((HV*)dstr, HvRITER_get((HV*)sstr));
	if (HvARRAY((HV*)sstr)) {
	    bool sharekeys = !!HvSHAREKEYS(sstr);
	    STRLEN i = 0;
	    XPVHV *dxhv = (XPVHV*)SvANY(dstr);
	    XPVHV *sxhv = (XPVHV*)SvANY(sstr);
	    Newx(dxhv->xhv_array,
		 PERL_HV_ARRAY_ALLOC_BYTES(dxhv->xhv_max+1), char);
	    while (i <= sxhv->xhv_max) {
		HE *source = HvARRAY(sstr)[i];
		HvARRAY(dstr)[i]
			= source ? he_dup(source, sharekeys, param) : 0;
		++i;
a10312 48
	    dxhv->xhv_eiter = he_dup(sxhv->xhv_eiter,
				     (bool)!!HvSHAREKEYS(sstr), param);
	}
	else {
	    SvPV_set(dstr, Nullch);
	    HvEITER_set((HV*)dstr, (HE*)NULL);
	}
	HvPMROOT((HV*)dstr)	= HvPMROOT((HV*)sstr);		/* XXX */
	HvNAME((HV*)dstr)	= SAVEPV(HvNAME((HV*)sstr));
	/* Record stashes for possible cloning in Perl_clone(). */
	if(HvNAME((HV*)dstr))
	    av_push(param->stashes, dstr);
	break;
    case SVt_PVFM:
	SvANY(dstr)	= new_XPVFM();
	FmLINES(dstr)	= FmLINES(sstr);
	goto dup_pvcv;
	/* NOTREACHED */
    case SVt_PVCV:
	SvANY(dstr)	= new_XPVCV();
        dup_pvcv:
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	CvSTASH(dstr)	= hv_dup(CvSTASH(sstr), param); /* NOTE: not refcounted */
	CvSTART(dstr)	= CvSTART(sstr);
	OP_REFCNT_LOCK;
	CvROOT(dstr)	= OpREFCNT_inc(CvROOT(sstr));
	OP_REFCNT_UNLOCK;
	CvXSUB(dstr)	= CvXSUB(sstr);
	CvXSUBANY(dstr)	= CvXSUBANY(sstr);
	if (CvCONST(sstr)) {
	    CvXSUBANY(dstr).any_ptr = GvUNIQUE(CvGV(sstr)) ?
                SvREFCNT_inc(CvXSUBANY(sstr).any_ptr) :
                sv_dup_inc(CvXSUBANY(sstr).any_ptr, param);
	}
	/* don't dup if copying back - CvGV isn't refcounted, so the
	 * duped GV may never be freed. A bit of a hack! DAPM */
	CvGV(dstr)	= (param->flags & CLONEf_JOIN_IN) ?
		Nullgv : gv_dup(CvGV(sstr), param) ;
	if (param->flags & CLONEf_COPY_STACKS) {
	  CvDEPTH(dstr)	= CvDEPTH(sstr);
	} else {
	  CvDEPTH(dstr) = 0;
a10313 12
	PAD_DUP(CvPADLIST(dstr), CvPADLIST(sstr), param);
	CvOUTSIDE_SEQ(dstr) = CvOUTSIDE_SEQ(sstr);
	CvOUTSIDE(dstr)	=
		CvWEAKOUTSIDE(sstr)
			? cv_dup(    CvOUTSIDE(sstr), param)
			: cv_dup_inc(CvOUTSIDE(sstr), param);
	CvFLAGS(dstr)	= CvFLAGS(sstr);
	CvFILE(dstr) = CvXSUB(sstr) ? CvFILE(sstr) : SAVEPV(CvFILE(sstr));
	break;
    default:
	Perl_croak(aTHX_ "Bizarre SvTYPE [%" IVdf "]", (IV)SvTYPE(sstr));
	break;
d10342 2
a10343 2
	PERL_CONTEXT *cx = &cxs[ix];
	PERL_CONTEXT *ncx = &ncxs[ix];
a10350 1
	    ncx->blk_oldretsp	= cx->blk_oldretsp;
d10362 1
a10362 1
					   : Nullav);
d10367 3
d10377 1
d10382 1
a10382 3
		ncx->blk_loop.redo_op	= cx->blk_loop.redo_op;
		ncx->blk_loop.next_op	= cx->blk_loop.next_op;
		ncx->blk_loop.last_op	= cx->blk_loop.last_op;
d10400 1
d10468 1
a10468 1
Perl_any_dup(pTHX_ void *v, PerlInterpreter *proto_perl)
d10495 4
a10498 3
    ANY * const ss	= proto_perl->Tsavestack;
    const I32 max	= proto_perl->Tsavestack_max;
    I32 ix		= proto_perl->Tsavestack_ix;
d10509 1
d10517 4
a10520 4
	I32 i = POPINT(ss,ix);
	TOPINT(nss,ix) = i;
	switch (i) {
	case SAVEt_ITEM:			/* normal string */
d10523 3
d10528 3
a10530 2
	    break;
        case SAVEt_SV:				/* scalar reference */
a10532 8
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup_inc(gv, param);
	    break;
	case SAVEt_GENERIC_PVREF:		/* generic char* */
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
d10547 1
d10549 7
a10555 10
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup_inc(av, param);
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup(gv, param);
	    break;
        case SAVEt_HV:				/* hash reference */
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup(gv, param);
d10566 2
d10574 1
d10586 2
d10600 1
a10606 16
	case SAVEt_HPTR:			/* HV* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup(hv, param);
	    break;
	case SAVEt_APTR:			/* AV* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup(av, param);
	    break;
	case SAVEt_NSTAB:
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup(gv, param);
	    break;
a10612 6
            c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
a10613 5
	case SAVEt_FREESV:
	case SAVEt_MORTALIZESV:
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    break;
d10628 3
a10630 1
		    OpREFCNT_inc(o);
d10633 1
a10633 1
		    TOPPTR(nss,ix) = Nullop;
d10638 1
a10638 1
		TOPPTR(nss,ix) = Nullop;
a10643 4
	case SAVEt_CLEARSV:
	    longval = POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    break;
d10649 2
a10675 4
	case SAVEt_STACK_POS:		/* Position on Perl stack */
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
a10683 8
	case SAVEt_HELEM:		/* hash element */
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
	    break;
d10691 11
a10701 4
	    break;
	case SAVEt_COMPPAD:
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup(av, param);
d10717 77
d10795 2
a10796 1
	    Perl_croak(aTHX_ "panic: ss_dup inconsistency");
d10811 1
a10811 1
    const char *const hvname = HvNAME_get((HV*)sv);
d10822 1
a10822 1
	    XPUSHs(sv_2mortal(newSVpv(hvname, 0)));
d10845 6
a10850 6
CLONEf_COPY_STACKS - is used to, well, copy the stacks also, 
without it we only clone the data and zero the stacks, 
with it we copy the stacks and the new perl interpreter is 
ready to run at the exact same point as the previous one. 
The pseudo-fork code uses COPY_STACKS while the 
threads->new doesn't.
d10853 9
a10861 9
perl_clone keeps a ptr_table with the pointer of the old 
variable as a key and the new variable as a value, 
this allows it to check if something has been cloned and not 
clone it again but rather just use the value and increase the 
refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill 
the ptr_table using the function 
C<ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;>, 
reason to keep it around is if you want to dup some of your own 
variable who are outside the graph perl scans, example of this 
d10865 5
a10869 5
This is a win32 thing, it is ignored on unix, it tells perls 
win32host code (which is c++) to clone itself, this is needed on 
win32 if you want to run two threads at the same time, 
if you just want to do some stuff in a separate perl interpreter 
and then throw it away and return to the original one, 
d10882 1
d10917 1
a10917 1
    CLONE_PARAMS* param = &clone_params;
d10919 1
a10919 1
    PerlInterpreter *my_perl = (PerlInterpreter*)(*ipM->pMalloc)(ipM, sizeof(PerlInterpreter));
d10925 3
a10927 3
    Poison(my_perl, 1, PerlInterpreter);
    PL_op = Nullop;
    PL_curcop = (COP *)Nullop;
a10932 1
    PL_retstack = 0;
d10934 1
d10954 1
a10954 1
    PerlInterpreter *my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
d10960 3
a10962 3
    Poison(my_perl, 1, PerlInterpreter);
    PL_op = Nullop;
    PL_curcop = (COP *)Nullop;
a10967 1
    PL_retstack = 0;
d10969 1
d10978 5
a10982 31
    /* arena roots */
    PL_xiv_arenaroot	= NULL;
    PL_xiv_root		= NULL;
    PL_xnv_arenaroot	= NULL;
    PL_xnv_root		= NULL;
    PL_xrv_arenaroot	= NULL;
    PL_xrv_root		= NULL;
    PL_xpv_arenaroot	= NULL;
    PL_xpv_root		= NULL;
    PL_xpviv_arenaroot	= NULL;
    PL_xpviv_root	= NULL;
    PL_xpvnv_arenaroot	= NULL;
    PL_xpvnv_root	= NULL;
    PL_xpvcv_arenaroot	= NULL;
    PL_xpvcv_root	= NULL;
    PL_xpvav_arenaroot	= NULL;
    PL_xpvav_root	= NULL;
    PL_xpvhv_arenaroot	= NULL;
    PL_xpvhv_root	= NULL;
    PL_xpvmg_arenaroot	= NULL;
    PL_xpvmg_root	= NULL;
    PL_xpvlv_arenaroot	= NULL;
    PL_xpvlv_root	= NULL;
    PL_xpvbm_arenaroot	= NULL;
    PL_xpvbm_root	= NULL;
    PL_he_arenaroot	= NULL;
    PL_he_root		= NULL;
#if defined(USE_ITHREADS)
    PL_pte_arenaroot	= NULL;
    PL_pte_root		= NULL;
#endif
d10987 2
a10988 2
    PL_sv_root		= Nullsv;
    PL_sv_arenaroot	= Nullsv;
d11016 1
a11016 1
    SvPV_set(&PL_sv_no, SAVEPVN(PL_No, 0));
d11027 1
a11027 1
    SvPV_set(&PL_sv_yes, SAVEPVN(PL_Yes, 1));
d11050 11
a11060 5
    if (!specialWARN(PL_compiling.cop_warnings))
	PL_compiling.cop_warnings = sv_dup_inc(PL_compiling.cop_warnings, param);
    if (!specialCopIO(PL_compiling.cop_io))
	PL_compiling.cop_io = sv_dup_inc(PL_compiling.cop_io, param);
    PL_curcop		= (COP*)any_dup(proto_perl->Tcurcop, proto_perl);
d11068 4
d11094 1
a11112 1
    PL_multiline	= proto_perl->Imultiline;
d11116 2
d11125 6
d11135 1
a11135 1
	SV** const regexen = AvARRAY((AV*)proto_perl->Iregex_padav);
d11137 1
a11137 2
	av_push(PL_regex_padav,
		sv_dup_inc(regexen[0],param));
d11139 11
a11149 9
            if(SvREPADTMP(regexen[i])) {
	      av_push(PL_regex_padav, sv_dup_inc(regexen[i], param));
            } else {
	        av_push(PL_regex_padav,
                    SvREFCNT_inc(
                        newSViv(PTR2IV(re_dup(INT2PTR(REGEXP *,
                             SvIVX(regexen[i])), param)))
                       ));
	    }
a11174 1
    PL_lineary		= av_dup(proto_perl->Ilineary, param);
d11178 2
a11179 3
    PL_defstash		= hv_dup_inc(proto_perl->Tdefstash, param);
    PL_curstash		= hv_dup(proto_perl->Tcurstash, param);
    PL_nullstash       = hv_dup(proto_perl->Inullstash, param);
d11187 2
d11194 1
a11202 2
    PL_tainting		= proto_perl->Itainting;
    PL_taint_warn       = proto_perl->Itaint_warn;
d11207 2
a11208 1
	PL_op_mask 	= Nullch;
d11212 1
d11214 1
a11220 1
    PL_copline		= proto_perl->Icopline;
d11226 1
a11226 1
    PL_Cmd		= Nullch;
a11227 1
    PL_preambled	= proto_perl->Ipreambled;
d11231 1
a11231 1
    PL_mess_sv		= Nullsv;
a11233 1
    PL_ofmt		= SAVEPV(proto_perl->Iofmt);
d11243 16
a11263 3
    PL_rsfp		= fp_dup(proto_perl->Irsfp, '<', param);
    /* PL_rsfp_filters entries have fake IoDIRP() */
    PL_rsfp_filters	= av_dup_inc(proto_perl->Irsfp_filters, param);
a11285 1
    PL_op_seqmax	= proto_perl->Iop_seqmax;
d11289 1
d11291 1
a11292 1
    PL_sh_path_compat	= proto_perl->Ish_path_compat; /* XXX never deallocated */
a11294 1

d11297 1
a11297 61
    Copy(proto_perl->Itokenbuf, PL_tokenbuf, 256, char);

#ifdef CSH
    PL_cshlen		= proto_perl->Icshlen;
    PL_cshname		= proto_perl->Icshname; /* XXX never deallocated */
#endif

    PL_lex_state	= proto_perl->Ilex_state;
    PL_lex_defer	= proto_perl->Ilex_defer;
    PL_lex_expect	= proto_perl->Ilex_expect;
    PL_lex_formbrack	= proto_perl->Ilex_formbrack;
    PL_lex_dojoin	= proto_perl->Ilex_dojoin;
    PL_lex_starts	= proto_perl->Ilex_starts;
    PL_lex_stuff	= sv_dup_inc(proto_perl->Ilex_stuff, param);
    PL_lex_repl		= sv_dup_inc(proto_perl->Ilex_repl, param);
    PL_lex_op		= proto_perl->Ilex_op;
    PL_lex_inpat	= proto_perl->Ilex_inpat;
    PL_lex_inwhat	= proto_perl->Ilex_inwhat;
    PL_lex_brackets	= proto_perl->Ilex_brackets;
    i = (PL_lex_brackets < 120 ? 120 : PL_lex_brackets);
    PL_lex_brackstack	= SAVEPVN(proto_perl->Ilex_brackstack,i);
    PL_lex_casemods	= proto_perl->Ilex_casemods;
    i = (PL_lex_casemods < 12 ? 12 : PL_lex_casemods);
    PL_lex_casestack	= SAVEPVN(proto_perl->Ilex_casestack,i);

    Copy(proto_perl->Inextval, PL_nextval, 5, YYSTYPE);
    Copy(proto_perl->Inexttype, PL_nexttype, 5,	I32);
    PL_nexttoke		= proto_perl->Inexttoke;

    /* XXX This is probably masking the deeper issue of why
     * SvANY(proto_perl->Ilinestr) can be NULL at this point. For test case:
     * http://archive.develooper.com/perl5-porters%40perl.org/msg83298.html
     * (A little debugging with a watchpoint on it may help.)
     */
    if (SvANY(proto_perl->Ilinestr)) {
	PL_linestr		= sv_dup_inc(proto_perl->Ilinestr, param);
	i = proto_perl->Ibufptr - SvPVX_const(proto_perl->Ilinestr);
	PL_bufptr		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ioldbufptr - SvPVX_const(proto_perl->Ilinestr);
	PL_oldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ioldoldbufptr - SvPVX_const(proto_perl->Ilinestr);
	PL_oldoldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ilinestart - SvPVX_const(proto_perl->Ilinestr);
	PL_linestart	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    }
    else {
        PL_linestr = NEWSV(65,79);
        sv_upgrade(PL_linestr,SVt_PVIV);
        sv_setpvn(PL_linestr,"",0);
	PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart = SvPVX(PL_linestr);
    }
    PL_bufend		= SvPVX(PL_linestr) + SvCUR(PL_linestr);
    PL_pending_ident	= proto_perl->Ipending_ident;
    PL_sublex_info	= proto_perl->Isublex_info;	/* XXX not quite right */

    PL_expect		= proto_perl->Iexpect;

    PL_multi_start	= proto_perl->Imulti_start;
    PL_multi_end	= proto_perl->Imulti_end;
    PL_multi_open	= proto_perl->Imulti_open;
    PL_multi_close	= proto_perl->Imulti_close;
a11298 1
    PL_error_count	= proto_perl->Ierror_count;
a11301 15
    /* XXX See comment on SvANY(proto_perl->Ilinestr) above */
    if (SvANY(proto_perl->Ilinestr)) {
	i = proto_perl->Ilast_uni - SvPVX_const(proto_perl->Ilinestr);
	PL_last_uni		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ilast_lop - SvPVX_const(proto_perl->Ilinestr);
	PL_last_lop		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	PL_last_lop_op	= proto_perl->Ilast_lop_op;
    }
    else {
	PL_last_uni	= SvPVX(PL_linestr);
	PL_last_lop	= SvPVX(PL_linestr);
	PL_last_lop_op	= 0;
    }
    PL_in_my		= proto_perl->Iin_my;
    PL_in_my_stash	= hv_dup(proto_perl->Iin_my_stash, param);
d11373 1
a11373 3

    PL_runops_std	= proto_perl->Irunops_std;
    PL_runops_dbg	= proto_perl->Irunops_dbg;
d11380 1
a11380 1
    PL_last_swash_hv	= Nullhv;	/* reinits on demand */
a11385 8
    /* perly.c globals */
    PL_yydebug		= proto_perl->Iyydebug;
    PL_yynerrs		= proto_perl->Iyynerrs;
    PL_yyerrflag	= proto_perl->Iyyerrflag;
    PL_yychar		= proto_perl->Iyychar;
    PL_yyval		= proto_perl->Iyyval;
    PL_yylval		= proto_perl->Iyylval;

d11388 1
a11388 2
    PL_uudmap['M']	= 0;		/* reinits on demand */
    PL_bitcount		= Nullch;	/* reinits on demand */
d11410 1
a11410 1
    /* thrdvar.h stuff */
d11414 3
a11416 3
	PL_tmps_ix		= proto_perl->Ttmps_ix;
	PL_tmps_max		= proto_perl->Ttmps_max;
	PL_tmps_floor		= proto_perl->Ttmps_floor;
d11420 1
a11420 1
	    PL_tmps_stack[i]	= sv_dup_inc(proto_perl->Ttmps_stack[i], param);
d11425 1
a11425 1
	i = proto_perl->Tmarkstack_max - proto_perl->Tmarkstack;
d11427 5
a11431 5
	PL_markstack_max	= PL_markstack + (proto_perl->Tmarkstack_max
						  - proto_perl->Tmarkstack);
	PL_markstack_ptr	= PL_markstack + (proto_perl->Tmarkstack_ptr
						  - proto_perl->Tmarkstack);
	Copy(proto_perl->Tmarkstack, PL_markstack,
d11436 2
a11437 2
	PL_scopestack_ix	= proto_perl->Tscopestack_ix;
	PL_scopestack_max	= proto_perl->Tscopestack_max;
d11439 1
a11439 8
	Copy(proto_perl->Tscopestack, PL_scopestack, PL_scopestack_ix, I32);

	/* next push_return() sets PL_retstack[PL_retstack_ix]
	 * NOTE: unlike the others! */
	PL_retstack_ix		= proto_perl->Tretstack_ix;
	PL_retstack_max		= proto_perl->Tretstack_max;
	Newz(54, PL_retstack, PL_retstack_max, OP*);
	Copy(proto_perl->Tretstack, PL_retstack, PL_retstack_ix, OP*);
d11442 1
a11442 1
	PL_curstackinfo		= si_dup(proto_perl->Tcurstackinfo, param);
d11445 2
a11446 2
	PL_curstack		= av_dup(proto_perl->Tcurstack, param);
	PL_mainstack		= av_dup(proto_perl->Tmainstack, param);
d11450 2
a11451 2
	PL_stack_sp		= PL_stack_base + (proto_perl->Tstack_sp
						   - proto_perl->Tstack_base);
d11456 2
a11457 2
	PL_savestack_ix		= proto_perl->Tsavestack_ix;
	PL_savestack_max	= proto_perl->Tsavestack_max;
d11470 3
a11472 3
	for (i = 0; i<= proto_perl->Ttmps_ix; i++) {
	    SV *nsv = (SV*)ptr_table_fetch(PL_ptr_table,
		    proto_perl->Ttmps_stack[i]);
d11475 1
a11475 1
		PL_tmps_stack[++PL_tmps_ix] = SvREFCNT_inc(nsv);
d11480 1
a11480 1
    PL_start_env	= proto_perl->Tstart_env;	/* XXXXXX */
d11483 1
a11483 1
    PL_op		= proto_perl->Top;
d11485 1
a11485 1
    PL_Sv		= Nullsv;
d11487 1
a11487 1
    PL_na		= proto_perl->Tna;
d11489 4
a11492 4
    PL_statbuf		= proto_perl->Tstatbuf;
    PL_statcache	= proto_perl->Tstatcache;
    PL_statgv		= gv_dup(proto_perl->Tstatgv, param);
    PL_statname		= sv_dup_inc(proto_perl->Tstatname, param);
d11494 1
a11494 1
    PL_timesbuf		= proto_perl->Ttimesbuf;
d11497 28
a11524 32
    PL_tainted		= proto_perl->Ttainted;
    PL_curpm		= proto_perl->Tcurpm;	/* XXX No PMOP ref count */
    PL_rs		= sv_dup_inc(proto_perl->Trs, param);
    PL_last_in_gv	= gv_dup(proto_perl->Tlast_in_gv, param);
    PL_ofs_sv		= sv_dup_inc(proto_perl->Tofs_sv, param);
    PL_defoutgv		= gv_dup_inc(proto_perl->Tdefoutgv, param);
    PL_chopset		= proto_perl->Tchopset;	/* XXX never deallocated */
    PL_toptarget	= sv_dup_inc(proto_perl->Ttoptarget, param);
    PL_bodytarget	= sv_dup_inc(proto_perl->Tbodytarget, param);
    PL_formtarget	= sv_dup(proto_perl->Tformtarget, param);

    PL_restartop	= proto_perl->Trestartop;
    PL_in_eval		= proto_perl->Tin_eval;
    PL_delaymagic	= proto_perl->Tdelaymagic;
    PL_dirty		= proto_perl->Tdirty;
    PL_localizing	= proto_perl->Tlocalizing;

#ifdef PERL_FLEXIBLE_EXCEPTIONS
    PL_protect		= proto_perl->Tprotect;
#endif
    PL_errors		= sv_dup_inc(proto_perl->Terrors, param);
    PL_hv_fetch_ent_mh	= Nullhe;
    PL_modcount		= proto_perl->Tmodcount;
    PL_lastgotoprobe	= Nullop;
    PL_dumpindent	= proto_perl->Tdumpindent;

    PL_sortcop		= (OP*)any_dup(proto_perl->Tsortcop, proto_perl);
    PL_sortstash	= hv_dup(proto_perl->Tsortstash, param);
    PL_firstgv		= gv_dup(proto_perl->Tfirstgv, param);
    PL_secondgv		= gv_dup(proto_perl->Tsecondgv, param);
    PL_sortcxix		= proto_perl->Tsortcxix;
    PL_efloatbuf	= Nullch;		/* reinits on demand */
d11532 1
a11532 1
    PL_lastscream	= Nullsv;
a11533 2
    PL_watchaddr	= NULL;
    PL_watchok		= Nullch;
d11535 1
a11535 15
    PL_regdummy		= proto_perl->Tregdummy;
    PL_regcomp_parse	= Nullch;
    PL_regxend		= Nullch;
    PL_regcode		= (regnode*)NULL;
    PL_regnaughty	= 0;
    PL_regsawback	= 0;
    PL_regprecomp	= Nullch;
    PL_regnpar		= 0;
    PL_regsize		= 0;
    PL_regflags		= 0;
    PL_regseen		= 0;
    PL_seen_zerolen	= 0;
    PL_seen_evals	= 0;
    PL_regcomp_rx	= (regexp*)NULL;
    PL_extralen		= 0;
a11537 41
    PL_reg_whilem_seen	= 0;
    PL_reginput		= Nullch;
    PL_regbol		= Nullch;
    PL_regeol		= Nullch;
    PL_regstartp	= (I32*)NULL;
    PL_regendp		= (I32*)NULL;
    PL_reglastparen	= (U32*)NULL;
    PL_reglastcloseparen	= (U32*)NULL;
    PL_regtill		= Nullch;
    PL_reg_start_tmp	= (char**)NULL;
    PL_reg_start_tmpl	= 0;
    PL_regdata		= (struct reg_data*)NULL;
    PL_bostr		= Nullch;
    PL_reg_flags	= 0;
    PL_reg_eval_set	= 0;
    PL_regnarrate	= 0;
    PL_regprogram	= (regnode*)NULL;
    PL_regindent	= 0;
    PL_regcc		= (CURCUR*)NULL;
    PL_reg_call_cc	= (struct re_cc_state*)NULL;
    PL_reg_re		= (regexp*)NULL;
    PL_reg_ganch	= Nullch;
    PL_reg_sv		= Nullsv;
    PL_reg_match_utf8	= FALSE;
    PL_reg_magic	= (MAGIC*)NULL;
    PL_reg_oldpos	= 0;
    PL_reg_oldcurpm	= (PMOP*)NULL;
    PL_reg_curpm	= (PMOP*)NULL;
    PL_reg_oldsaved	= Nullch;
    PL_reg_oldsavedlen	= 0;
    PL_reg_maxiter	= 0;
    PL_reg_leftiter	= 0;
    PL_reg_poscache	= Nullch;
    PL_reg_poscache_size= 0;

    /* RE engine - function pointers */
    PL_regcompp		= proto_perl->Tregcompp;
    PL_regexecp		= proto_perl->Tregexecp;
    PL_regint_start	= proto_perl->Tregint_start;
    PL_regint_string	= proto_perl->Tregint_string;
    PL_regfree		= proto_perl->Tregfree;
d11539 1
a11539 2
    PL_reginterp_cnt	= 0;
    PL_reg_starttry	= 0;
d11542 1
a11542 1
    PL_peepp		= proto_perl->Tpeepp;
d11546 10
d11572 1
a11572 1
	    XPUSHs(sv_2mortal(newSVpv(HvNAME_get(stash), 0)));
d11584 1
a11584 1
	(void)SvREFCNT_inc(PL_compcv);
d11614 1
d11627 1
a11627 1
/* 
d11630 1
a11630 1
  for Encode::XS, while UTf-8 decode (currently) assumes a true value means 
d11634 1
a11634 1
  
d11675 1
d11702 488
@


1.13
log
@The official fix for the Perl sprintf buffer overflow.

ok millert@@
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d59 5
a63 5
Normally, this allocation is done using arenas, which are approximately
1K chunks of memory parcelled up into N heads or bodies. The first slot
in each arena is reserved, and is used to hold a link to the next arena.
In the case of heads, the unused first slot also contains some flags and
a note of the number of slots.  Snaked through each arena chain is a
d65 1
a65 2
allocated and divided up into N items which are threaded into the free
list.
d81 2
a82 1
or auto variables, eg PL_sv_undef.
d161 22
d200 22
d235 1
a235 1
	sv = more_sv();
d251 1
a251 1
	    (p) = more_sv();				\
d279 1
a279 3
	SV* sv;
	SV* svend;
	int ok = 0;
d281 3
a283 3
	    sv = sva + 1;
	    svend = &sva[SvREFCNT(sva)];
	    if (p >= sv && p < svend)
d285 2
d336 1
d338 3
d345 3
a350 22
/* make some more SVs by adding another arena */

/* sv_mutex must be held while calling more_sv() */
STATIC SV*
S_more_sv(pTHX)
{
    register SV* sv;

    if (PL_nice_chunk) {
	sv_add_arena(PL_nice_chunk, PL_nice_chunk_size, 0);
	PL_nice_chunk = Nullch;
        PL_nice_chunk_size = 0;
    }
    else {
	char *chunk;                /* must use New here to match call to */
	New(704,chunk,1008,char);   /* Safefree() in sv_free_arenas()     */
	sv_add_arena(chunk, 1008, 0);
    }
    uproot_SV(sv);
    return sv;
}

a357 2
    SV* sv;
    register SV* svend;
d361 2
a362 1
	svend = &sva[SvREFCNT(sva)];
d418 1
a418 1
	    SvRV(sv) = 0;
d421 1
a421 1
	    SvRV(sv) = 0;
d436 5
a440 1
	if ( SvOBJECT(GvSV(sv)) ||
d529 1
a529 1
	    Safefree((void *)sva);
d623 10
a632 2
    if (PL_nice_chunk)
	Safefree(PL_nice_chunk);
d657 1
a657 1
/* grab a new IV body from the free list, allocating more if necessary */
d659 2
a660 2
STATIC XPVIV*
S_new_xiv(pTHX)
d662 6
a667 12
    IV* xiv;
    LOCK_SV_MUTEX;
    if (!PL_xiv_root)
	more_xiv();
    xiv = PL_xiv_root;
    /*
     * See comment in more_xiv() -- RAM.
     */
    PL_xiv_root = *(IV**)xiv;
    UNLOCK_SV_MUTEX;
    return (XPVIV*)((char*)xiv - STRUCT_OFFSET(XPVIV, xiv_iv));
}
d669 9
a677 10
/* return an IV body to the free list */

STATIC void
S_del_xiv(pTHX_ XPVIV *p)
{
    IV* xiv = (IV*)((char*)(p) + STRUCT_OFFSET(XPVIV, xiv_iv));
    LOCK_SV_MUTEX;
    *(IV**)xiv = PL_xiv_root;
    PL_xiv_root = xiv;
    UNLOCK_SV_MUTEX;
d685 2
a686 2
    register IV* xiv;
    register IV* xivend;
d688 1
a688 1
    New(705, ptr, 1008/sizeof(XPV), XPV);
d693 1
a693 1
    xivend = &xiv[1008 / sizeof(IV) - 1];
a702 27
/* grab a new NV body from the free list, allocating more if necessary */

STATIC XPVNV*
S_new_xnv(pTHX)
{
    NV* xnv;
    LOCK_SV_MUTEX;
    if (!PL_xnv_root)
	more_xnv();
    xnv = PL_xnv_root;
    PL_xnv_root = *(NV**)xnv;
    UNLOCK_SV_MUTEX;
    return (XPVNV*)((char*)xnv - STRUCT_OFFSET(XPVNV, xnv_nv));
}

/* return an NV body to the free list */

STATIC void
S_del_xnv(pTHX_ XPVNV *p)
{
    NV* xnv = (NV*)((char*)(p) + STRUCT_OFFSET(XPVNV, xnv_nv));
    LOCK_SV_MUTEX;
    *(NV**)xnv = PL_xnv_root;
    PL_xnv_root = xnv;
    UNLOCK_SV_MUTEX;
}

d708 2
a709 2
    register NV* xnv;
    register NV* xnvend;
d711 1
a711 1
    New(711, ptr, 1008/sizeof(XPV), XPV);
d716 1
a716 1
    xnvend = &xnv[1008 / sizeof(NV) - 1];
d726 179
d913 1
a913 1
	more_xrv();
d931 19
a949 1
/* allocate another arena's worth of struct xrv */
d952 13
a964 1
S_more_xrv(pTHX)
d966 11
a976 6
    register XRV* xrv;
    register XRV* xrvend;
    XPV *ptr;
    New(712, ptr, 1008/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xrv_arenaroot;
    PL_xrv_arenaroot = ptr;
d978 8
a985 9
    xrv = (XRV*) ptr;
    xrvend = &xrv[1008 / sizeof(XRV) - 1];
    xrv += (sizeof(XPV) - 1) / sizeof(XRV) + 1;
    PL_xrv_root = xrv;
    while (xrv < xrvend) {
	xrv->xrv_rv = (SV*)(xrv + 1);
	xrv++;
    }
    xrv->xrv_rv = 0;
d996 1
a996 1
	more_xpv();
a1013 20
/* allocate another arena's worth of struct xpv */

STATIC void
S_more_xpv(pTHX)
{
    register XPV* xpv;
    register XPV* xpvend;
    New(713, xpv, 1008/sizeof(XPV), XPV);
    xpv->xpv_pv = (char*)PL_xpv_arenaroot;
    PL_xpv_arenaroot = xpv;

    xpvend = &xpv[1008 / sizeof(XPV) - 1];
    PL_xpv_root = ++xpv;
    while (xpv < xpvend) {
	xpv->xpv_pv = (char*)(xpv + 1);
	xpv++;
    }
    xpv->xpv_pv = 0;
}

d1022 1
a1022 1
	more_xpviv();
a1039 20
/* allocate another arena's worth of struct xpviv */

STATIC void
S_more_xpviv(pTHX)
{
    register XPVIV* xpviv;
    register XPVIV* xpvivend;
    New(714, xpviv, 1008/sizeof(XPVIV), XPVIV);
    xpviv->xpv_pv = (char*)PL_xpviv_arenaroot;
    PL_xpviv_arenaroot = xpviv;

    xpvivend = &xpviv[1008 / sizeof(XPVIV) - 1];
    PL_xpviv_root = ++xpviv;
    while (xpviv < xpvivend) {
	xpviv->xpv_pv = (char*)(xpviv + 1);
	xpviv++;
    }
    xpviv->xpv_pv = 0;
}

d1048 1
a1048 1
	more_xpvnv();
a1065 20
/* allocate another arena's worth of struct xpvnv */

STATIC void
S_more_xpvnv(pTHX)
{
    register XPVNV* xpvnv;
    register XPVNV* xpvnvend;
    New(715, xpvnv, 1008/sizeof(XPVNV), XPVNV);
    xpvnv->xpv_pv = (char*)PL_xpvnv_arenaroot;
    PL_xpvnv_arenaroot = xpvnv;

    xpvnvend = &xpvnv[1008 / sizeof(XPVNV) - 1];
    PL_xpvnv_root = ++xpvnv;
    while (xpvnv < xpvnvend) {
	xpvnv->xpv_pv = (char*)(xpvnv + 1);
	xpvnv++;
    }
    xpvnv->xpv_pv = 0;
}

d1074 1
a1074 1
	more_xpvcv();
a1091 20
/* allocate another arena's worth of struct xpvcv */

STATIC void
S_more_xpvcv(pTHX)
{
    register XPVCV* xpvcv;
    register XPVCV* xpvcvend;
    New(716, xpvcv, 1008/sizeof(XPVCV), XPVCV);
    xpvcv->xpv_pv = (char*)PL_xpvcv_arenaroot;
    PL_xpvcv_arenaroot = xpvcv;

    xpvcvend = &xpvcv[1008 / sizeof(XPVCV) - 1];
    PL_xpvcv_root = ++xpvcv;
    while (xpvcv < xpvcvend) {
	xpvcv->xpv_pv = (char*)(xpvcv + 1);
	xpvcv++;
    }
    xpvcv->xpv_pv = 0;
}

d1100 1
a1100 1
	more_xpvav();
a1117 20
/* allocate another arena's worth of struct xpvav */

STATIC void
S_more_xpvav(pTHX)
{
    register XPVAV* xpvav;
    register XPVAV* xpvavend;
    New(717, xpvav, 1008/sizeof(XPVAV), XPVAV);
    xpvav->xav_array = (char*)PL_xpvav_arenaroot;
    PL_xpvav_arenaroot = xpvav;

    xpvavend = &xpvav[1008 / sizeof(XPVAV) - 1];
    PL_xpvav_root = ++xpvav;
    while (xpvav < xpvavend) {
	xpvav->xav_array = (char*)(xpvav + 1);
	xpvav++;
    }
    xpvav->xav_array = 0;
}

d1126 1
a1126 1
	more_xpvhv();
a1143 20
/* allocate another arena's worth of struct xpvhv */

STATIC void
S_more_xpvhv(pTHX)
{
    register XPVHV* xpvhv;
    register XPVHV* xpvhvend;
    New(718, xpvhv, 1008/sizeof(XPVHV), XPVHV);
    xpvhv->xhv_array = (char*)PL_xpvhv_arenaroot;
    PL_xpvhv_arenaroot = xpvhv;

    xpvhvend = &xpvhv[1008 / sizeof(XPVHV) - 1];
    PL_xpvhv_root = ++xpvhv;
    while (xpvhv < xpvhvend) {
	xpvhv->xhv_array = (char*)(xpvhv + 1);
	xpvhv++;
    }
    xpvhv->xhv_array = 0;
}

d1152 1
a1152 1
	more_xpvmg();
a1169 20
/* allocate another arena's worth of struct xpvmg */

STATIC void
S_more_xpvmg(pTHX)
{
    register XPVMG* xpvmg;
    register XPVMG* xpvmgend;
    New(719, xpvmg, 1008/sizeof(XPVMG), XPVMG);
    xpvmg->xpv_pv = (char*)PL_xpvmg_arenaroot;
    PL_xpvmg_arenaroot = xpvmg;

    xpvmgend = &xpvmg[1008 / sizeof(XPVMG) - 1];
    PL_xpvmg_root = ++xpvmg;
    while (xpvmg < xpvmgend) {
	xpvmg->xpv_pv = (char*)(xpvmg + 1);
	xpvmg++;
    }
    xpvmg->xpv_pv = 0;
}

d1178 1
a1178 1
	more_xpvlv();
a1195 20
/* allocate another arena's worth of struct xpvlv */

STATIC void
S_more_xpvlv(pTHX)
{
    register XPVLV* xpvlv;
    register XPVLV* xpvlvend;
    New(720, xpvlv, 1008/sizeof(XPVLV), XPVLV);
    xpvlv->xpv_pv = (char*)PL_xpvlv_arenaroot;
    PL_xpvlv_arenaroot = xpvlv;

    xpvlvend = &xpvlv[1008 / sizeof(XPVLV) - 1];
    PL_xpvlv_root = ++xpvlv;
    while (xpvlv < xpvlvend) {
	xpvlv->xpv_pv = (char*)(xpvlv + 1);
	xpvlv++;
    }
    xpvlv->xpv_pv = 0;
}

d1204 1
a1204 1
	more_xpvbm();
a1221 20
/* allocate another arena's worth of struct xpvbm */

STATIC void
S_more_xpvbm(pTHX)
{
    register XPVBM* xpvbm;
    register XPVBM* xpvbmend;
    New(721, xpvbm, 1008/sizeof(XPVBM), XPVBM);
    xpvbm->xpv_pv = (char*)PL_xpvbm_arenaroot;
    PL_xpvbm_arenaroot = xpvbm;

    xpvbmend = &xpvbm[1008 / sizeof(XPVBM) - 1];
    PL_xpvbm_root = ++xpvbm;
    while (xpvbm < xpvbmend) {
	xpvbm->xpv_pv = (char*)(xpvbm + 1);
	xpvbm++;
    }
    xpvbm->xpv_pv = 0;
}

d1326 7
a1332 7
    char*	pv = NULL;
    U32		cur = 0;
    U32		len = 0;
    IV		iv = 0;
    NV		nv = 0.0;
    MAGIC*	magic = NULL;
    HV*		stash = Nullhv;
d1344 8
a1353 7
	pv	= 0;
	cur	= 0;
	len	= 0;
	iv	= 0;
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
a1355 3
	pv	= 0;
	cur	= 0;
	len	= 0;
a1356 1
	nv	= (NV)SvIVX(sv);
a1357 2
	magic	= 0;
	stash	= 0;
a1363 3
	pv	= 0;
	cur	= 0;
	len	= 0;
a1364 3
	iv	= I_V(nv);
	magic	= 0;
	stash	= 0;
a1365 1
	SvANY(sv) = 0;
a1370 4
	cur	= 0;
	len	= 0;
	iv	= PTR2IV(pv);
	nv	= PTR2NV(pv);
a1371 2
	magic	= 0;
	stash	= 0;
d1374 1
a1374 1
	pv	= SvPVX(sv);
a1376 4
	iv	= 0;
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
d1384 1
a1384 1
	pv	= SvPVX(sv);
a1387 3
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
d1391 1
a1391 1
	pv	= SvPVX(sv);
a1395 2
	magic	= 0;
	stash	= 0;
d1399 9
a1407 1
	pv	= SvPVX(sv);
d1420 3
d1428 1
a1428 1
	SvIVX(sv)	= iv;
d1432 1
a1432 1
	SvNVX(sv)	= nv;
d1436 1
a1436 1
	SvRV(sv) = (SV*)pv;
d1440 3
a1442 3
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
d1446 4
a1449 4
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
d1456 5
a1460 5
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
d1464 7
a1470 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1474 7
a1480 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1490 1
a1490 1
	SvPVX(sv)	= 0;
d1493 4
a1496 4
	SvIVX(sv)	= 0;
	SvNVX(sv)	= 0.0;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1505 1
a1505 1
	SvPVX(sv)	= 0;
d1509 3
a1511 3
	HvPLACEHOLDERS(sv) = 0;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1520 7
a1526 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1530 7
a1536 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1545 7
a1551 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1559 7
a1565 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
d1570 7
a1576 7
	SvPVX(sv)	= pv;
	SvCUR(sv)	= cur;
	SvLEN(sv)	= len;
	SvIVX(sv)	= iv;
	SvNVX(sv)	= nv;
	SvMAGIC(sv)	= magic;
	SvSTASH(sv)	= stash;
a1579 2
    SvFLAGS(sv) &= ~SVTYPEMASK;
    SvFLAGS(sv) |= mt;
d1597 3
a1599 3
	char *s = SvPVX(sv);
	SvLEN(sv) += SvIVX(sv);
	SvPVX(sv) -= SvIVX(sv);
d1635 1
a1635 1
	s = SvPVX(sv);
d1639 1
a1639 1
	s = SvPVX(sv);
d1648 1
a1648 1
	s = SvPVX(sv);
d1651 1
d1654 1
a1654 1
	    STRLEN l = malloced_size((void*)SvPVX(sv));
d1660 1
a1660 1
	    Renew(s,newlen,char);
d1662 1
a1662 1
        else {
d1669 3
a1671 3
	    New(703, s, newlen, char);
	    if (SvPVX(sv) && SvCUR(sv)) {
	        Move(SvPVX(sv), s, (newlen < SvCUR(sv)) ? newlen : SvCUR(sv), char);
d1715 1
a1715 1
    SvIVX(sv) = i;
d1760 1
a1760 1
    SvUVX(sv) = u;
d1774 3
a1776 15
    /* With these two if statements:
       u=1.49  s=0.52  cu=72.49  cs=10.64  scripts=270  tests=20865

       without
       u=1.35  s=0.47  cu=73.45  cs=11.43  scripts=270  tests=20865

       If you wish to remove them, please benchmark to see what the effect is
    */
    if (u <= (UV)IV_MAX) {
       sv_setiv(sv, (IV)u);
    } else {
       sv_setiv(sv, 0);
       SvIsUV_on(sv);
       sv_setuv(sv,u);
    }
d1813 1
a1813 1
    SvNVX(sv) = num;
d1842 1
a1842 1
     char *pv;
d1845 1
a1845 1
          dsv = sv_2mortal(newSVpv("", 0));
d1849 1
a1849 1
	  char *limit = tmpbuf + sizeof(tmpbuf) - 8;
d1853 3
a1855 2
	  char *s, *end;
	  for (s = SvPVX(sv), end = s + SvCUR(sv); s < end && d < limit; s++) {
d1920 1
a1920 1
    register char *sbegin;
d1924 1
a1924 1
	sbegin = SvPVX(sv);
d1928 1
a1928 1
	sbegin = SvPV(sv, len);
d2021 1
a2021 1
    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_2iuv_non '%s', IV=0x%"UVxf" NV=%"NVgf" inttype=%"UVXf"\n", SvPVX(sv), SvIVX(sv), SvNVX(sv), (UV)numtype));
d2025 1
a2025 1
	SvIVX(sv) = IV_MIN;
d2032 1
a2032 1
	SvUVX(sv) = UV_MAX;
d2040 1
a2040 1
        SvIVX(sv) = I_V(SvNVX(sv));
d2049 1
a2049 1
    SvUVX(sv) = U_V(SvNVX(sv));
d2090 1
a2090 1
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
d2098 7
a2104 5
	  SV* tmpstr;
          if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)) &&
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv))))
	      return SvIV(tmpstr);
	  return PTR2IV(SvRV(sv));
d2138 1
a2138 1
	    SvIVX(sv) = I_V(SvNVX(sv));
d2176 1
a2176 1
	    SvUVX(sv) = U_V(SvNVX(sv));
d2201 1
a2201 1
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d2239 1
a2239 1
		    SvIVX(sv) = (IV)value;
d2241 1
a2241 1
		    SvUVX(sv) = value;
d2247 1
a2247 1
		    SvIVX(sv) = -(IV)value;
d2256 2
a2257 2
		    SvNVX(sv) = -(NV)value;
		    SvIVX(sv) = IV_MIN;
d2268 1
a2268 1
	    SvNVX(sv) = Atof(SvPVX(sv));
d2286 1
a2286 1
		SvIVX(sv) = I_V(SvNVX(sv));
d2297 1
a2297 1
		    SvUVX(sv) = UV_MAX;
d2300 1
a2300 1
		    SvUVX(sv) = U_V(SvNVX(sv));
d2326 1
a2326 1
                    SvIVX(sv) = I_V(SvNVX(sv));
d2352 1
a2352 1
	if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d2389 1
a2389 1
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
d2432 1
a2432 1
	    SvIVX(sv) = I_V(SvNVX(sv));
d2470 1
a2470 1
	    SvUVX(sv) = U_V(SvNVX(sv));
d2493 1
a2493 1
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d2529 1
a2529 1
		    SvIVX(sv) = (IV)value;
d2532 1
a2532 1
		    SvUVX(sv) = value;
d2538 1
a2538 1
		    SvIVX(sv) = -(IV)value;
d2547 2
a2548 2
		    SvNVX(sv) = -(NV)value;
		    SvIVX(sv) = IV_MIN;
d2556 1
a2556 1
	    SvNVX(sv) = Atof(SvPVX(sv));
d2573 1
a2573 1
                SvIVX(sv) = I_V(SvNVX(sv));
d2584 1
a2584 1
                    SvUVX(sv) = UV_MAX;
d2587 1
a2587 1
                    SvUVX(sv) = U_V(SvNVX(sv));
d2613 1
a2613 1
                    SvIVX(sv) = I_V(SvNVX(sv));
d2630 1
a2630 1
	    if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
d2664 2
a2665 2
	    if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) &&
		!grok_number(SvPVX(sv), SvCUR(sv), NULL))
d2667 1
a2667 1
	    return Atof(SvPVX(sv));
d2677 1
a2677 1
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
d2680 1
a2680 1
            return 0;
d2728 1
a2728 1
	SvNVX(sv) = SvIsUV(sv) ? (NV)SvUVX(sv) : (NV)SvIVX(sv);
d2743 2
a2744 2
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
	if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) && !numtype)
d2750 1
a2750 1
	    SvNVX(sv) = (numtype & IS_NUMBER_NEG) ? -(NV)value : (NV)value;
d2752 1
a2752 1
	    SvNVX(sv) = Atof(SvPVX(sv));
d2755 1
a2755 1
	SvNVX(sv) = Atof(SvPVX(sv));
d2779 1
a2779 1
                    SvIVX(sv) = -(IV)value;
d2781 1
a2781 1
		    SvIVX(sv) = (IV)value;
d2783 1
a2783 1
		    SvUVX(sv) = value;
d2794 1
a2794 1
                    NV nv = SvNVX(sv);
d2810 1
a2810 1
                            UV nv_as_uv = U_V(nv);
d2826 1
a2826 1
	if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d2860 1
a2860 1
    int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d2877 1
a2877 1
    return I_V(Atof(SvPVX(sv)));
d2887 1
a2887 1
    int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d2899 1
a2899 1
    return U_V(Atof(SvPVX(sv)));
d2913 1
a2913 2
    STRLEN n_a;
    return sv_2pv(sv, &n_a);
d2924 1
a2924 1
uiv_2buf(char *buf, IV iv, UV uv, int is_uv, char **peob)
d2927 1
a2927 1
    char *ebuf = ptr;
d2980 3
a2982 2
	*lp = 0;
	return "";
d2988 6
a2993 1
	    *lp = SvCUR(sv);
d3011 1
a3011 1
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
d3014 3
a3016 2
            *lp = 0;
            return "";
d3022 1
d3025 16
a3040 1
                char *pv = SvPV(tmpstr, *lp);
d3050 1
a3050 1
		s = "NULLREF";
d3060 1
a3060 1
			regexp *re = (regexp *)mg->mg_obj;
d3063 1
a3063 1
			    char *fptr = "msix";
d3103 1
a3103 1
                                char *endptr = re->precomp + re->prelen;
d3106 1
a3106 1
                                    char c = *(endptr--);
d3119 1
a3119 1
			    New(616, mg->mg_ptr, mg->mg_len + 1 + left, char);
d3135 2
a3136 1
			*lp = mg->mg_len;
d3147 2
a3148 5
		case SVt_PVBM:	if (SvROK(sv))
				    s = "REF";
				else
				    s = "SCALAR";		break;
		case SVt_PVLV:	s = SvROK(sv) ? "REF"
d3153 7
a3159 7
		case SVt_PVAV:	s = "ARRAY";			break;
		case SVt_PVHV:	s = "HASH";			break;
		case SVt_PVCV:	s = "CODE";			break;
		case SVt_PVGV:	s = "GLOB";			break;
		case SVt_PVFM:	s = "FORMAT";			break;
		case SVt_PVIO:	s = "IO";			break;
		default:	s = "UNKNOWN";			break;
d3163 4
a3166 8
                    HV *svs = SvSTASH(sv);
		    Perl_sv_setpvf(
                        aTHX_ tsv, "%s=%s",
                        /* [20011101.072] This bandaid for C<package;>
                           should eventually be removed. AMS 20011103 */
                        (svs ? HvNAME(svs) : "<none>"), s
                    );
                }
d3168 1
a3168 2
		    sv_setpv(tsv, s);
		Perl_sv_catpvf(aTHX_ tsv, "(0x%"UVxf")", PTR2UV(sv));
d3171 3
a3173 2
	    *lp = strlen(s);
	    return s;
d3178 3
a3180 2
	    *lp = 0;
	    return "";
d3186 2
a3187 2
	U32 isIOK = SvIOK(sv);
	U32 isUIOK = SvIsUV(sv);
d3197 3
a3199 2
	SvGROW(sv, (STRLEN)(ebuf - ptr + 1));	/* inlined from sv_setpvn */
	Move(ptr,SvPVX(sv),ebuf - ptr,char);
d3214 1
a3214 2
	SvGROW(sv, NV_DIG + 20);
	s = SvPVX(sv);
d3236 1
a3236 2
	if (ckWARN(WARN_UNINITIALIZED)
	    && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d3238 1
d3243 7
a3249 1
	return "";
a3250 2
    *lp = s - SvPVX(sv);
    SvCUR_set(sv, *lp);
d3253 5
a3257 1
			  PTR2UV(sv),SvPVX(sv)));
d3268 2
a3269 1
	*lp = SvCUR(tsv);
d3273 2
a3274 2
	STRLEN len;
	char *t;
d3278 1
a3278 1
	    t = SvPVX(tsv);
d3292 3
a3294 2
	*lp = len;
	s = SvGROW(sv, len + 1);
d3297 1
a3297 1
	return strcpy(s, t);
d3319 1
a3319 2
    char *s;
    s = SvPV(ssv,len);
d3341 1
a3341 2
    STRLEN n_a;
    return sv_2pvbyte(sv, &n_a);
d3360 1
a3360 1
    return SvPV(sv,*lp);
d3377 1
a3377 2
    STRLEN n_a;
    return sv_2pvutf8(sv, &n_a);
d3395 1
a3395 1
    return SvPV(sv,*lp);
d3423 2
a3424 2
	register XPV* Xpvtmp;
	if ((Xpvtmp = (XPV*)SvANY(sv)) &&
a3483 3
    U8 *s, *t, *e;
    int  hibit = 0;

d3508 26
a3533 25
	 /* This function could be much more efficient if we
	  * had a FLAG in SVs to signal if there are any hibit
	  * chars in the PV.  Given that there isn't such a flag
	  * make the loop as fast as possible. */
	 s = (U8 *) SvPVX(sv);
	 e = (U8 *) SvEND(sv);
	 t = s;
	 while (t < e) {
	      U8 ch = *t++;
	      if ((hibit = !NATIVE_IS_INVARIANT(ch)))
		   break;
	 }
	 if (hibit) {
	      STRLEN len;
	      (void)SvOOK_off(sv);
	      s = (U8*)SvPVX(sv);
	      len = SvCUR(sv) + 1; /* Plus the \0 */
	      SvPVX(sv) = (char*)bytes_to_utf8((U8*)s, &len);
	      SvCUR(sv) = len - 1;
	      if (SvLEN(sv) != 0)
		   Safefree(s); /* No longer using what was there before. */
	      SvLEN(sv) = len; /* No longer know the real size. */
	 }
	 /* Mark as UTF-8 even if no hibit - saves scanning loop */
	 SvUTF8_on(sv);
d3574 1
a3574 1
	    SvCUR(sv) = len;
d3619 2
a3620 2
        U8 *c;
        U8 *e;
d3631 2
a3632 2
        c = (U8 *) SvPVX(sv);
	if (!is_utf8_string(c, SvCUR(sv)+1))
d3634 1
a3634 1
        e = (U8 *) SvEND(sv);
d3636 1
a3636 1
	    U8 ch = *c++;
d3739 1
a3739 1
	    SvIVX(dstr) = SvIVX(sstr);
d3761 1
a3761 1
	    SvNVX(dstr) = SvNVX(sstr);
d3804 2
d3807 1
a3807 2
	    Perl_croak(aTHX_ "Bizarre copy of %s in %s", sv_reftype(sstr, 0),
		OP_NAME(PL_op));
d3809 2
a3810 1
	    Perl_croak(aTHX_ "Bizarre copy of %s", sv_reftype(sstr, 0));
d3817 2
a3818 2
		char *name = GvNAME(sstr);
		STRLEN len = GvNAMELEN(sstr);
d3874 1
a3874 1
		SV *sref = SvREFCNT_inc(SvRV(sstr));
d3876 1
a3876 1
		int intro = GvINTRO(dstr);
d3928 1
a3928 1
			CV* cv = GvCV(dstr);
d3952 1
a3952 1
					HvNAME(GvSTASH((GV*)dstr)),
d3958 3
a3960 1
					SvPOK(sref) ? SvPVX(sref) : Nullch);
d4006 4
a4009 5
	    if (SvPVX(dstr)) {
		(void)SvOOK_off(dstr);		/* backoff */
		if (SvLEN(dstr))
		    Safefree(SvPVX(dstr));
		SvLEN(dstr)=SvCUR(dstr)=0;
d4013 1
a4013 1
	SvRV(dstr) = SvREFCNT_inc(SvRV(sstr));
d4020 1
a4020 1
	    SvNVX(dstr) = SvNVX(sstr);
d4028 1
a4028 1
	    SvIVX(dstr) = SvIVX(sstr);
d4039 2
a4040 2
	 * It might even be a win on short strings if SvPVX(dstr)
	 * has to be allocated and SvPVX(sstr) has to be freed.
d4051 2
a4052 7
	    if (SvPVX(dstr)) {		/* we know that dtype >= SVt_PV */
		if (SvOOK(dstr)) {
		    SvFLAGS(dstr) &= ~SVf_OOK;
		    Safefree(SvPVX(dstr) - SvIVX(dstr));
		}
		else if (SvLEN(dstr))
		    Safefree(SvPVX(dstr));
d4069 1
a4069 1
	    Move(SvPVX(sstr),SvPVX(dstr),len,char);
a4075 1
	/*SUPPRESS 560*/
d4080 1
a4080 1
	    SvNVX(dstr) = SvNVX(sstr);
d4088 1
a4088 1
	    SvIVX(dstr) = SvIVX(sstr);
d4107 1
a4107 1
	SvIVX(dstr) = SvIVX(sstr);
d4113 1
a4113 1
	    SvNVX(dstr) = SvNVX(sstr);
d4123 1
a4123 1
	SvNVX(dstr) = SvNVX(sstr);
d4174 1
a4174 1
	IV iv = len;
d4180 1
a4180 2
    SvGROW(sv, len + 1);
    dptr = SvPVX(sv);
d4264 1
d4271 6
a4276 5
    (void)SvOOK_off(sv);
    if (SvPVX(sv) && SvLEN(sv))
	Safefree(SvPVX(sv));
    Renew(ptr, len+1, char);
    SvPVX(sv) = ptr;
d4278 1
a4278 1
    SvLEN_set(sv, len+1);
d4315 3
a4317 3
	    char *pvx = SvPVX(sv);
	    STRLEN len = SvCUR(sv);
            U32 hash   = SvUVX(sv);
d4357 1
a4357 1
Beware: after this function returns, C<ptr> and SvPVX(sv) may no longer
d4369 1
a4369 1
    delta = ptr - SvPVX(sv);
d4376 2
a4377 2
	    char *pvx = SvPVX(sv);
	    STRLEN len = SvCUR(sv);
d4382 1
a4382 1
	SvIVX(sv) = 0;
d4389 4
a4392 4
    SvLEN(sv) -= delta;
    SvCUR(sv) -= delta;
    SvPVX(sv) += delta;
    SvIVX(sv) += delta;
d4429 1
a4429 1
    char *dstr;
a4430 1
    dstr = SvPV_force_flags(dsv, dlen, flags);
d4433 1
a4433 1
	sstr = SvPVX(dsv);
d4435 1
a4435 1
    SvCUR(dsv) += slen;
d4485 1
a4485 1
    char *spv;
d4489 1
a4489 1
    if ((spv = SvPV(ssv, slen))) {
d4497 1
a4497 1
	I32 sutf8 = DO_UTF8(ssv);
d4510 1
a4510 1
		spv = SvPV(csv, slen);
d4556 1
a4556 1
	ptr = SvPVX(sv);
d4558 1
a4558 1
    SvCUR(sv) += len;
d4628 1
a4628 1
    Newz(702,mg, 1, MAGIC);
d4630 1
a4630 1
    SvMAGIC(sv) = mg;
d4632 4
a4635 4
    /* Some magic sontains a reference loop, where the sv and object refer to
       each other.  To prevent a reference loop that would prevent such
       objects being freed, we look for such loops and if we find one we
       avoid incrementing the object refcount.
d4697 3
d4706 1
a4707 1
    MGVTBL *vtable = 0;
d4710 6
a4715 1
	if (IN_PERL_RUNTIME
d4781 1
a4781 1
	vtable = 0;
d4822 1
a4822 1
	vtable = 0;
d4850 1
d4857 1
a4857 1
    mg = sv_magicext(sv,obj,how,vtable,name,namlen);
d4888 1
a4888 1
	    MGVTBL* vtbl = mg->mg_virtual;
a4964 7
        I32 i;
        SV **svp = AvARRAY(av);
        for (i = AvFILLp(av); i >= 0; i--)
            if (!svp[i]) {
                svp[i] = sv;        /* reuse the slot */
                return;
            }
d4980 1
a4980 1
    SV *tsv = SvRV(sv);
d4986 17
a5002 2
    for (i = AvFILLp(av); i >= 0; i--)
	if (svp[i] == sv) svp[i] = Nullsv;
d5046 1
a5046 1
	SvCUR(bigstr) += i;
a5076 1
    /*SUPPRESS 560*/
d5114 1
a5114 1
    U32 refcnt = SvREFCNT(sv);
d5123 1
a5123 1
	SvMAGIC(nsv) = SvMAGIC(sv);
d5126 1
a5126 1
	SvMAGIC(sv) = 0;
a5161 4
	    CV* destructor;



d5163 1
d5167 1
a5167 1
		    SV* tmpref = newRV(sv);
d5184 1
a5184 1
			SvRV(tmpref) = 0;
d5195 1
a5195 1
			  HvNAME(stash));
d5211 1
a5211 1
	if (SvFLAGS(sv) & SVpad_TYPED)
d5265 5
a5269 1
	SvOOK_off(sv);
d5279 4
a5282 4
	else if (SvPVX(sv) && SvLEN(sv))
	    Safefree(SvPVX(sv));
	else if (SvPVX(sv) && SvREADONLY(sv) && SvFAKE(sv)) {
	    unsharepvn(SvPVX(sv),
d5402 1
a5402 1
	if (ckWARN_d(WARN_INTERNAL))
d5406 4
d5454 1
a5454 1
        (void)SvPV(sv, len);
d5485 1
a5485 1
	U8 *s = (U8*)SvPV(sv, len);
d5495 1
a5495 1
	     ulen = Perl_utf8_length(aTHX_ s, s + len);
d5519 2
a5520 1
S_utf8_mg_pos_init(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i, I32 *offsetp, U8 *s, U8 *start)
d5526 1
a5526 1
	    *mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, &PL_vtbl_utf8, 0, 0);
d5529 7
a5535 7
        if ((*mgp)->mg_ptr)
            *cachep = (STRLEN *) (*mgp)->mg_ptr;
        else {
            Newz(0, *cachep, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
            (*mgp)->mg_ptr = (char *) *cachep;
        }
        assert(*cachep);
d5537 3
a5539 3
        (*cachep)[i]   = *offsetp;
        (*cachep)[i+1] = s - start;
        found = TRUE;
d5553 1
a5553 1
S_utf8_mg_pos(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i, I32 *offsetp, I32 uoff, U8 **sp, U8 *start, U8 *send)
d5568 1
a5568 1
		 U8* p = NULL;
d5587 1
a5587 1
		      STRLEN ulen = sv_len_utf8(sv);
d5685 1
a5685 2
    U8 *start;
    U8 *s;
a5686 2
    STRLEN *cache = 0;
    STRLEN boffset = 0;
d5691 1
a5691 1
    start = s = (U8*)SvPV(sv, len);
d5693 7
a5699 4
	 I32 uoffset = *offsetp;
	 U8 *send = s + len;
	 MAGIC *mg = 0;
	 bool found = FALSE;
d5708 1
a5708 1
              if (utf8_mg_pos_init(sv, &mg, &cache, 0, offsetp, s, start))
d5715 1
a5715 1
              if (utf8_mg_pos(sv, &mg, &cache, 2, lenp, *lenp + *offsetp, &s, start, send)) {
d5726 1
a5726 1
                   utf8_mg_pos_init(sv, &mg, &cache, 2, lenp, s, start);
d5761 1
a5761 1
    U8* s;
d5767 1
a5767 1
    s = (U8*)SvPV(sv, len);
d5771 1
a5771 1
	U8* send = s + *offsetp;
d5799 1
a5799 1
		    STRLEN forw  = *offsetp;
d5803 1
a5803 1
			U8 *p = s + cache[1];
d5837 1
a5837 1
		utf8n_to_uvchr(s, UTF8SKIP(s), &n, 0);
d5854 1
a5854 1
		Newz(0, cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
d5885 1
a5885 1
    char *pv1;
d5887 1
a5887 1
    char *pv2;
d5898 1
a5898 1
	pv1 = SvPV(sv1, cur1);
d5905 1
a5905 1
	pv2 = SvPV(sv2, cur2);
d5914 1
a5914 1
		   pv2 = SvPV(svrecode, cur2);
d5919 1
a5919 1
		   pv1 = SvPV(svrecode, cur1);
d5933 1
a5933 1
		   char *pv = (char*)bytes_from_utf8((U8*)pv1,
d5941 1
a5941 1
		   char *pv = (char *)bytes_from_utf8((U8*)pv2,
d5980 2
a5981 1
    char *pv1, *pv2, *tpv = Nullch;
d5990 1
a5990 1
	pv1 = SvPV(sv1, cur1);
d5997 1
a5997 1
	pv2 = SvPV(sv2, cur2);
d6006 1
a6006 1
		 pv2 = SvPV(svrecode, cur2);
d6016 1
a6016 1
		 pv1 = SvPV(svrecode, cur1);
d6029 1
a6029 1
	I32 retval = memcmp((void*)pv1, (void*)pv2, cur1 < cur2 ? cur1 : cur2);
d6130 2
a6131 1
	char *s, *xf;
d6136 1
a6136 1
	s = SvPV(sv, len);
d6182 1
a6182 1
    char *rsptr;
d6209 1
a6209 1
	    SV *tsv = NEWSV(0,0);
d6236 1
a6236 1
	    Off_t offset = PerlIO_tell(fp);
d6284 1
a6284 1
	    rsptr = SvPV(PL_rs, rslen);
d6353 1
a6353 1
    bp = (STDCHAR*)SvPVX(sv) + append;  /* move these two too to registers */
d6382 1
a6382 1
	    bpx = bp - (STDCHAR*)SvPVX(sv); /* box up before relocation */
d6385 1
a6385 1
	    bp = (STDCHAR*)SvPVX(sv) + bpx; /* unbox after relocation */
d6417 1
a6417 1
	bpx = bp - (STDCHAR*)SvPVX(sv);	/* box up before relocation */
d6420 1
a6420 1
	bp = (STDCHAR*)SvPVX(sv) + bpx;	/* unbox after relocation */
d6429 1
a6429 1
    if ((rslen > 1 && (STRLEN)(bp - (STDCHAR*)SvPVX(sv)) < rslen) ||
d6443 1
a6443 1
    SvCUR_set(sv, bp - (STDCHAR*)SvPVX(sv));	/* set length */
d6446 1
a6446 1
	(long)SvCUR(sv),(int)SvCUR(sv),SvPVX(sv)));
d6451 1
a6451 11

      /* Any stack-challenged places. */
#if defined(EPOC)
      /* EPOC: need to work around SDK features.         *
       * On WINS: MS VC5 generates calls to _chkstk,     *
       * if a "large" stack frame is allocated.          *
       * gcc on MARM does not generate calls like these. */
#   define USEHEAPINSTEADOFSTACK
#endif

#ifdef USEHEAPINSTEADOFSTACK
d6453 1
a6453 1
	New(0, buf, 8192, STDCHAR);
d6461 1
a6461 1
	    register STDCHAR *bpe = buf + sizeof(buf);
d6488 1
a6488 1
	     memNE(SvPVX(sv) + SvCUR(sv) - rslen, rsptr, rslen)))
d6506 1
a6506 1
#ifdef USEHEAPINSTEADOFSTACK
d6577 1
a6577 1
		++SvUVX(sv);
d6583 1
a6583 1
		++SvIVX(sv);
d6590 1
a6590 1
	SvNVX(sv) += 1.0;
d6594 1
a6594 1
    if (!(flags & SVp_POK) || !*SvPVX(sv)) {
d6598 1
a6598 1
	SvIVX(sv) = 1;
d6609 1
a6609 1
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), NULL);
d6625 1
a6625 1
		SvNVX(sv) += 1.0;
d6633 1
a6633 1
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
d6636 1
a6636 1
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
d6640 1
a6640 1
	sv_setnv(sv,Atof(SvPVX(sv)) + 1.0);
d6644 1
a6644 1
    while (d >= SvPVX(sv)) {
d6673 2
a6674 2
    SvCUR(sv)++;
    for (d = SvPVX(sv) + SvCUR(sv); d > SvPVX(sv); d--)
d6727 1
a6727 1
		SvIVX(sv) = -1;
d6731 1
a6731 1
		--SvUVX(sv);
d6738 1
a6738 1
		--SvIVX(sv);
d6744 1
a6744 1
	SvNVX(sv) -= 1.0;
d6749 4
a6752 4
	if ((flags & SVTYPEMASK) < SVt_PVNV)
	    sv_upgrade(sv, SVt_NV);
	SvNVX(sv) = -1.0;
	(void)SvNOK_only(sv);
d6757 1
a6757 1
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), NULL);
d6773 1
a6773 1
		SvNVX(sv) -= 1.0;
d6781 1
a6781 1
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
d6784 1
a6784 1
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
d6789 1
a6789 1
    sv_setnv(sv,Atof(SvPVX(sv)) - 1.0);	/* punt */
d6885 1
a6885 3
    if (!len)
	len = strlen(s);
    sv_setpvn(sv,s,len);
d6910 55
d6968 1
a6968 1
Creates a new SV with its SvPVX pointing to a shared string in the string
d6973 1
a6973 1
is used for shared hash keys these strings will have SvPVX == HeKEY and
d6995 4
a6998 4
    SvPVX(sv) = sharepvn(src, is_utf8?-len:len, hash);
    SvCUR(sv) = len;
    SvUVX(sv) = hash;
    SvLEN(sv) = 0;
d7133 1
a7133 1
    SvRV(sv) = tmpRef;
d7170 4
a7173 7
    if (SvTEMP(old)) {
	SvTEMP_off(old);
	sv_setsv(sv,old);
	SvTEMP_on(old);
    }
    else
	sv_setsv(sv,old);
a7188 4
    register HE *entry;
    register GV *gv;
    register SV *sv;
    register I32 i;
a7189 1
    register I32 max;
d7209 2
a7210 1
	i = (unsigned char)*s;
d7219 1
d7224 3
d7231 15
a7245 11
		if (SvTHINKFIRST(sv)) {
		    if (!SvREADONLY(sv) && SvROK(sv))
			sv_unref(sv);
		    continue;
		}
		SvOK_off(sv);
		if (SvTYPE(sv) >= SVt_PV) {
		    SvCUR_set(sv, 0);
		    if (SvPVX(sv) != Nullch)
			*SvPVX(sv) = '\0';
		    SvTAINT(sv);
d7250 4
a7253 1
		if (GvHV(gv) && !HvNAME(GvHV(gv))) {
d7255 5
a7259 12
#ifndef PERL_MICRO
#ifdef USE_ENVIRON_ARRAY
		    if (gv == PL_envgv
#  ifdef USE_ITHREADS
			&& PL_curinterp == aTHX
#  endif
		    )
		    {
			environ[0] = Nullch;
		    }
#endif
#endif /* !PERL_MICRO */
d7347 1
a7347 1
	    SV **sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
d7408 2
a7409 2
	register XPV* tXpv;
	if ((tXpv = (XPV*)SvANY(sv)) &&
a7491 2
    STRLEN n_a;

d7495 1
a7495 1
    return sv_2pv(sv, &n_a);
a7563 1
    char *s = NULL;
d7569 2
a7570 1
	*lp = SvCUR(sv);
d7573 12
a7584 1
	if (SvTYPE(sv) > SVt_PVLV && SvTYPE(sv) != SVt_PVFM) {
d7587 5
a7591 6
	}
	else
	    s = sv_2pv_flags(sv, lp, flags);
	if (s != SvPVX(sv)) {	/* Almost, but not quite, sv_setpvn() */
	    STRLEN len = *lp;
	
d7604 1
a7604 1
				  PTR2UV(sv),SvPVX(sv)));
d7607 1
a7607 1
    return SvPVX(sv);
d7723 2
d7726 2
a7727 4
        HV *svs = SvSTASH(sv);
        /* [20011101.072] This bandaid for C<package;> should eventually
           be removed. AMS 20011103 */
        return (svs ? HvNAME(svs) : "<none>");
d7744 2
a7745 2
				
	case SVt_PVLV:		return SvROK(sv) ? "REF"
d7749 1
a7749 1
				    ? "SCALAR" : "LVALUE";
d7799 1
d7809 3
d7813 1
a7813 1
    return strEQ(HvNAME(SvSTASH(sv)), name);
d7838 1
a7838 1
	U32 refcnt = SvREFCNT(rv);
d7848 1
a7848 3
	SvOOK_off(rv);
	if (SvPVX(rv) && SvLEN(rv))
	    Safefree(SvPVX(rv));
d7854 1
a7854 1
    SvRV(rv) = sv;
d7858 1
a7858 1
	HV* stash = gv_stashpv(classname, TRUE);
d8003 1
a8003 1
    SvSTASH(tmpRef) = (HV*)SvREFCNT_inc(stash);
d8066 1
a8066 1
    SV* rv = SvRV(sv);
d8071 1
a8071 1
	SvRV(sv) = 0;
d8074 1
a8074 1
    SvRV(sv) = 0;
d8081 1
a8081 1
	sv_2mortal(rv);		/* Schedule for freeing later */
d8125 1
a8125 1
	MAGIC *mg = mg_find(sv, PERL_MAGIC_taint);
d8142 1
a8142 1
	MAGIC *mg = mg_find(sv, PERL_MAGIC_taint);
d8163 1
a8163 1
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);
d8181 1
a8181 1
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);
d8330 2
a8331 1
C<sv_catpvf_mg>.
d8433 1
a8433 1
    int neg = nv < 0;
a8434 1
    char *p = endbuf;
d8439 1
d8445 1
a8445 1
	    unsigned dig = uv % 10;
d8466 2
d8473 2
d8480 1
a8480 1
    char *patend;
d8483 1
a8483 1
    static char nullstr[] = "(null)";
d8485 2
a8486 2
    bool has_utf8; /* has the result utf8? */
    bool pat_utf8; /* the pattern is in utf8? */
d8495 1
a8495 1
    has_utf8 = pat_utf8 = DO_UTF8(sv);
d8506 10
a8515 10
	    if (args) {
		char *s = va_arg(*args, char*);
		sv_catpv(sv, s ? s : nullstr);
	    }
	    else if (svix < svmax) {
		sv_catsv(sv, *svargs);
		if (DO_UTF8(*svargs))
		    SvUTF8_on(sv);
	    }
	    return;
d8531 1
a8531 1
    if ( patlen <= 5 && pat[0] == '%' && pat[1] == '.'
d8542 1
a8542 3
	    if (args)
		nv = (NV)va_arg(*args, double);
	    else if (svix < svmax)
d8595 1
a8595 1
	U8 utf8buf[UTF8_MAXLEN+1];
d8598 1
a8598 1
	char *eptr = Nullch;
d8601 1
a8601 1
	U8 *vecstr = Null(U8*);
d8619 1
a8619 1
	char *dotstr = ".";
d8710 1
d8714 1
d8716 5
d8731 3
a8733 1
		dotstr = SvPVx(vecsv, dotstrlen);
d8736 6
d8745 1
a8745 1
		vecstr = (U8*)SvPVx(vecsv,veclen);
d8750 1
a8750 1
		vecstr = (U8*)SvPVx(vecsv,veclen);
d8897 1
a8897 1
		    eptr = nullstr;
d8902 1
a8902 1
		eptr = SvPVx(argsv, elen);
d8918 3
d8942 15
d8972 3
d8980 1
a8980 1
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
d9066 1
a9066 1
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
d9100 39
a9138 38
	    eptr = ebuf + sizeof ebuf;
	    switch (base) {
		unsigned dig;
	    case 16:
		if (!uv)
		    alt = FALSE;
		p = (char*)((c == 'X')
			    ? "0123456789ABCDEF" : "0123456789abcdef");
		do {
		    dig = uv & 15;
		    *--eptr = p[dig];
		} while (uv >>= 4);
		if (alt) {
		    esignbuf[esignlen++] = '0';
		    esignbuf[esignlen++] = c;  /* 'x' or 'X' */
		}
		break;
	    case 8:
		do {
		    dig = uv & 7;
		    *--eptr = '0' + dig;
		} while (uv >>= 3);
		if (alt && *eptr != '0')
		    *--eptr = '0';
		break;
	    case 2:
		if (!uv)
		    alt = FALSE;
		do {
		    dig = uv & 1;
		    *--eptr = '0' + dig;
		} while (uv >>= 1);
		if (alt) {
		    esignbuf[esignlen++] = '0';
		    esignbuf[esignlen++] = 'b';
		}
		break;
	    default:		/* it had better be ten or less */
d9140 10
a9149 9
		if (ckWARN(WARN_Y2K)) {
		    STRLEN n;
		    char *s = SvPV(sv,n);
		    if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
			&& (n == 2 || !isDIGIT(s[n-3])))
		    {
			Perl_warner(aTHX_ packWARN(WARN_Y2K),
				    "Possible Y2K bug: %%%c %s",
				    c, "format string following '19'");
d9151 14
a9165 13
#endif
		do {
		    dig = uv % base;
		    *--eptr = '0' + dig;
		} while (uv /= base);
		break;
	    }
	    elen = (ebuf + sizeof ebuf) - eptr;
	    if (has_precis) {
		if (precis > elen)
		    zeros = precis - elen;
		else if (precis == 0 && elen == 1 && *eptr == '0')
		    elen = 0;
d9306 1
a9306 1
		New(906, PL_efloatbuf, PL_efloatsize, char);
d9323 5
a9327 4
	    eptr = ebuf + sizeof ebuf;
	    *--eptr = '\0';
	    *--eptr = c;
	    /* FIXME: what to do if HAS_LONG_DOUBLE but not PERL_PRIfldbl? */
d9329 31
a9359 31
	    if (intsize == 'q') {
		/* Copy the one or more characters in a long double
		 * format before the 'base' ([efgEFG]) character to
		 * the format string. */
		static char const prifldbl[] = PERL_PRIfldbl;
		char const *p = prifldbl + sizeof(prifldbl) - 3;
		while (p >= prifldbl) { *--eptr = *p--; }
	    }
#endif
	    if (has_precis) {
		base = precis;
		do { *--eptr = '0' + (base % 10); } while (base /= 10);
		*--eptr = '.';
	    }
	    if (width) {
		base = width;
		do { *--eptr = '0' + (base % 10); } while (base /= 10);
	    }
	    if (fill == '0')
		*--eptr = fill;
	    if (left)
		*--eptr = '-';
	    if (plus)
		*--eptr = plus;
	    if (alt)
		*--eptr = '#';
	    *--eptr = '%';

	    /* No taint.  Otherwise we are in the strange situation
	     * where printf() taints but print($float) doesn't.
	     * --jhi */
d9361 4
a9364 4
	    if (intsize == 'q')
		(void)sprintf(PL_efloatbuf, eptr, nv);
	    else
		(void)sprintf(PL_efloatbuf, eptr, (double)nv);
d9366 1
a9366 1
	    (void)sprintf(PL_efloatbuf, eptr, nv);
d9368 1
d9398 4
a9401 2
	    if (!args && ckWARN(WARN_PRINTF) &&
		  (PL_op->op_type == OP_PRTF || PL_op->op_type == OP_SPRINTF)) {
d9430 1
a9430 1
	    SvCUR(sv) = p - SvPVX(sv);
d9446 1
a9446 1
		  SV *nsv = sv_2mortal(newSVpvn(eptr, elen));
d9448 1
a9448 1
		  eptr = SvPVX(nsv);
d9471 1
d9480 1
d9485 1
d9510 1
a9510 1
	SvCUR(sv) = p - SvPVX(sv);
d9580 1
a9580 1
    Newc(0, ret, sizeof(regexp) + (len+1)*sizeof(regnode), char, regexp);
d9583 1
a9583 1
    New(0, ret->startp, npar, I32);
d9585 1
a9585 1
    New(0, ret->endp, npar, I32);
d9588 1
a9588 1
    New(0, ret->substrs, 1, struct reg_substr_data);
d9599 2
a9600 1
	int count = r->data->count;
d9602 1
a9602 1
	Newc(0, d, sizeof(struct reg_data) + count*sizeof(void *),
d9604 1
a9604 1
	New(0, d->what, count, U8);
d9618 1
a9618 1
		New(0, d->data[i], 1, struct regnode_charclass_class);
d9626 1
d9628 1
d9641 1
a9641 1
    New(0, ret->offsets, 2*len+1, U32);
d9670 3
d9712 1
a9712 1
    Newz(0, ret, 1, GP);
d9747 1
a9747 1
	Newz(0, nmg, 1, MAGIC);
d9760 1
a9760 1
	    AV *av = (AV*) mg->mg_obj;
d9763 1
a9763 1
	    SvREFCNT_inc(nmg->mg_obj = (SV*)newAV());
d9808 1
a9808 1
    Newz(0, tbl, 1, PTR_TBL_t);
d9811 1
a9811 1
    Newz(0, tbl->tbl_ary, tbl->tbl_max + 1, PTR_TBL_ENT_t*);
d9815 42
a9856 5
#if (PTRSIZE == 8)
#  define PTR_TABLE_HASH(ptr) (PTR2UV(ptr) >> 3)
#else
#  define PTR_TABLE_HASH(ptr) (PTR2UV(ptr) >> 2)
#endif
d9864 1
a9864 1
    UV hash = PTR_TABLE_HASH(sv);
d9877 1
a9877 1
Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, void *oldv, void *newv)
d9883 1
a9883 1
    UV hash = PTR_TABLE_HASH(oldv);
d9889 2
a9890 2
	if (tblent->oldval == oldv) {
	    tblent->newval = newv;
d9894 3
a9896 3
    Newz(0, tblent, 1, PTR_TBL_ENT_t);
    tblent->oldval = oldv;
    tblent->newval = newv;
d9910 1
a9910 1
    UV oldsize = tbl->tbl_max + 1;
a9942 1
    register PTR_TBL_ENT_t *oentry = Null(PTR_TBL_ENT_t*);
d9956 1
a9956 1
            oentry = entry;
d9958 1
a9958 1
            Safefree(oentry);
a9987 56
/* attempt to make everything in the typeglob readonly */

STATIC SV *
S_gv_share(pTHX_ SV *sstr, CLONE_PARAMS *param)
{
    GV *gv = (GV*)sstr;
    SV *sv = &param->proto_perl->Isv_no; /* just need SvREADONLY-ness */

    if (GvIO(gv) || GvFORM(gv)) {
        GvUNIQUE_off(gv); /* GvIOs cannot be shared. nor can GvFORMs */
    }
    else if (!GvCV(gv)) {
        GvCV(gv) = (CV*)sv;
    }
    else {
        /* CvPADLISTs cannot be shared */
        if (!SvREADONLY(GvCV(gv)) && !CvXSUB(GvCV(gv))) {
            GvUNIQUE_off(gv);
        }
    }

    if (!GvUNIQUE(gv)) {
#if 0
        PerlIO_printf(Perl_debug_log, "gv_share: unable to share %s::%s\n",
                      HvNAME(GvSTASH(gv)), GvNAME(gv));
#endif
        return Nullsv;
    }

    /*
     * write attempts will die with
     * "Modification of a read-only value attempted"
     */
    if (!GvSV(gv)) {
        GvSV(gv) = sv;
    }
    else {
        SvREADONLY_on(GvSV(gv));
    }

    if (!GvAV(gv)) {
        GvAV(gv) = (AV*)sv;
    }
    else {
        SvREADONLY_on(GvAV(gv));
    }

    if (!GvHV(gv)) {
        GvHV(gv) = (HV*)sv;
    }
    else {
        SvREADONLY_on(GvHV(gv));
    }

    return sstr; /* he_dup() will SvREFCNT_inc() */
}
d9995 4
a9998 3
        SvRV(dstr) = SvWEAKREF(sstr)
		     ? sv_dup(SvRV(sstr), param)
		     : sv_dup_inc(SvRV(sstr), param);
d10000 1
a10000 1
    else if (SvPVX(sstr)) {
d10004 1
a10004 1
	    SvPVX(dstr) = SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
d10015 3
a10017 3
                    SvPVX(dstr) = sharepvn(SvPVX(sstr), SvCUR(sstr),
                                           SvUVX(sstr));
                    SvUVX(dstr) = SvUVX(sstr);
d10020 1
a10020 1
                    SvPVX(dstr) = SAVEPVN(SvPVX(sstr), SvCUR(sstr));
d10027 1
a10027 1
		SvPVX(dstr) = SvPVX(sstr);		
d10033 4
a10036 1
	SvPVX(dstr) = SvPVX(sstr);
d10055 1
d10058 1
a10058 1
	   HvNAME(sstr)) {
d10060 1
a10060 2
	    HV* old_stash = gv_stashpv(HvNAME(sstr),0);
	    return (SV*) old_stash;
d10074 1
a10074 1
    if (SvANY(sstr) && PL_watch_pvx && SvPVX(sstr) == PL_watch_pvx)
d10076 1
a10076 1
		      PL_watch_pvx, SvPVX(sstr));
d10079 7
d10092 1
a10092 1
	SvIVX(dstr)	= SvIVX(sstr);
d10096 1
a10096 1
	SvNVX(dstr)	= SvNVX(sstr);
d10104 2
a10105 2
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
d10110 3
a10112 3
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
d10117 4
a10120 4
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
d10125 6
a10130 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10135 6
a10140 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10148 6
a10153 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10167 1
a10167 11
            SV *share;
            if ((share = gv_share(sstr, param))) {
                del_SV(dstr);
                dstr = share;
                ptr_table_store(PL_ptr_table, sstr, dstr);
#if 0
                PerlIO_printf(Perl_debug_log, "sv_dup: sharing %s::%s\n",
                              HvNAME(GvSTASH(share)), GvNAME(share));
#endif
                break;
            }
d10170 6
a10175 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10186 6
a10191 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10228 6
a10233 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10243 1
a10243 1
	    SvPVX(dstr)	= (char*)dst_ary;
d10259 1
a10259 1
	    SvPVX(dstr)		= Nullch;
d10265 7
a10271 7
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	HvRITER((HV*)dstr)	= HvRITER((HV*)sstr);
d10273 1
d10277 1
a10277 1
	    Newz(0, dxhv->xhv_array,
d10280 3
a10282 3
		((HE**)dxhv->xhv_array)[i] = he_dup(((HE**)sxhv->xhv_array)[i],
						    (bool)!!HvSHAREKEYS(sstr),
						    param);
d10289 2
a10290 2
	    SvPVX(dstr)		= Nullch;
	    HvEITER((HV*)dstr)	= (HE*)NULL;
d10294 1
a10294 1
    /* Record stashes for possible cloning in Perl_clone(). */
d10306 6
a10311 6
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d10315 1
d10317 1
d10370 1
a10370 1
    Newz(56, ncxs, max + 1, PERL_CONTEXT);
d10458 1
a10458 1
    Newz(56, nsi, 1, PERL_SI);
d10525 3
a10527 3
    ANY *ss	= proto_perl->Tsavestack;
    I32 ix	= proto_perl->Tsavestack_ix;
    I32 max	= proto_perl->Tsavestack_max;
a10537 1
    I32 i;
a10540 1
    OP *o;
d10542 1
a10542 1
    Newz(54, nss, max, ANY);
d10545 1
a10545 1
	i = POPINT(ss,ix);
d10673 1
d10713 3
a10715 1
	    TOPDPTR(nss,ix) = (void (*)(void*))any_dup((void *)dptr, proto_perl);
d10721 3
a10723 1
	    TOPDXPTR(nss,ix) = (void (*)(pTHX_ void*))any_dup((void *)dxptr, proto_perl);
d10785 35
d10901 2
d10907 2
d10936 2
a10939 2


d10942 2
d10986 4
d10999 3
d11023 5
a11027 5
    SvPVX(&PL_sv_no)		= SAVEPVN(PL_No, 0);
    SvCUR(&PL_sv_no)		= 0;
    SvLEN(&PL_sv_no)		= 1;
    SvIVX(&PL_sv_no)		= 0;
    SvNVX(&PL_sv_no)		= 0;
d11034 5
a11038 5
    SvPVX(&PL_sv_yes)		= SAVEPVN(PL_Yes, 1);
    SvCUR(&PL_sv_yes)		= 1;
    SvLEN(&PL_sv_yes)		= 2;
    SvIVX(&PL_sv_yes)		= 1;
    SvNVX(&PL_sv_yes)		= 1;
d11044 1
a11044 1
    hv_ksplit(PL_strtab, 512);
d11123 3
a11125 2
	I32 len = av_len((AV*)proto_perl->Iregex_padav);
	SV** regexen = AvARRAY((AV*)proto_perl->Iregex_padav);
d11227 1
a11227 1
	New(0, PL_exitlist, PL_exitlistlen, PerlExitListEntry);
d11310 1
a11310 1
	i = proto_perl->Ibufptr - SvPVX(proto_perl->Ilinestr);
d11312 1
a11312 1
	i = proto_perl->Ioldbufptr - SvPVX(proto_perl->Ilinestr);
d11314 1
a11314 1
	i = proto_perl->Ioldoldbufptr - SvPVX(proto_perl->Ilinestr);
d11316 1
a11316 1
	i = proto_perl->Ilinestart - SvPVX(proto_perl->Ilinestr);
d11342 1
a11342 1
	i = proto_perl->Ilast_uni - SvPVX(proto_perl->Ilinestr);
d11344 1
a11344 1
	i = proto_perl->Ilast_lop - SvPVX(proto_perl->Ilinestr);
a11450 2
    PL_hash_seed	= proto_perl->Ihash_seed;
    PL_rehash_seed	= proto_perl->Irehash_seed;
d11455 1
a11455 1
	Newz(0, PL_psig_pend, SIG_SIZE, int);
d11462 2
a11463 2
	Newz(0, PL_psig_ptr,  SIG_SIZE, SV*);
	Newz(0, PL_psig_name, SIG_SIZE, SV*);
d11481 1
a11481 1
	Newz(50, PL_tmps_stack, PL_tmps_max, SV*);
d11490 1
a11490 1
	Newz(54, PL_markstack, i, I32);
d11502 1
a11502 1
	Newz(54, PL_scopestack, PL_scopestack_max, I32);
d11529 1
a11529 1
	/*Newz(54, PL_savestack, PL_savestack_max, ANY);*/
d11535 14
d11688 2
a11689 2
        HV* stash = (HV*) av_shift(param->stashes);
	GV* cloner = gv_fetchmethod_autoload(stash, "CLONE", 0);
d11695 1
a11695 1
           XPUSHs(sv_2mortal(newSVpv(HvNAME(stash), 0)));
d11705 6
d11740 1
a11740 1
	char *s;
d11764 2
a11765 2
	s = SvPV(uni, len);
	if (s != SvPVX(sv)) {
d11767 1
a11767 1
	    Move(s, SvPVX(sv), len, char);
a11768 1
	    SvPVX(sv)[len] = 0;	
d11825 9
@


1.12
log
@Use PERL_INT_MAX instead of INT_MAX in previous commit for consistency
with the rest of perl.  On OpenBSD PERL_INT_MAX is the same as INT_MAX.
From rse@@engelschall.com.
@
text
@d8544 1
a8544 1
		efix = width > PERL_INT_MAX ? PERL_INT_MAX : width;
d8609 6
a8614 3
		else
		    vecsv = (evix ? evix <= svmax : svix < svmax) ?
			svargs[evix ? evix-1 : svix++] : &PL_sv_undef;
d8624 1
a8624 1
	    else if (efix ? efix <= svmax : svix < svmax) {
d8630 1
d8731 9
a8739 3
	else if (!args)
	    argsv = (efix ? efix <= svmax : svix < svmax) ?
		    svargs[efix ? efix-1 : svix++] : &PL_sv_undef;
d8981 2
d9285 2
d9314 2
@


1.11
log
@Fix an int oflow bug in perl's parameter format string code.
Credit: Jack Louis of Dyad Security
@
text
@d8544 1
a8544 1
		efix = width > INT_MAX ? INT_MAX : width;
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d8544 1
a8544 1
		efix = width;
@


1.10.2.1
log
@MFC:
Fix by millert@@

Fix an int oflow bug in perl's parameter format string code.
Credit: Jack Louis of Dyad Security

ok deraadt@@ millert@@
@
text
@d8544 1
a8544 1
		efix = width > PERL_INT_MAX ? PERL_INT_MAX : width;
@


1.10.2.2
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d8544 1
a8544 1
		efix = width;
d8609 3
a8611 6
		else if (evix) {
		    vecsv = (evix > 0 && evix <= svmax)
			? svargs[evix-1] : &PL_sv_undef;
		} else {
		    vecsv = svix < svmax ? svargs[svix++] : &PL_sv_undef;
		}
d8621 1
a8621 1
	    else if (efix ? (efix > 0 && efix <= svmax) : svix < svmax) {
a8626 1
		vecsv = &PL_sv_undef;
d8727 3
a8729 9
	else if (!args) {
	    if (efix) {
		const I32 i = efix-1;
		argsv = (i >= 0 && i < svmax) ? svargs[i] : &PL_sv_undef;
	    } else {
		argsv = (svix >= 0 && svix < svmax)
		    ? svargs[svix++] : &PL_sv_undef;
	    }
	}
a8970 2
		if (!uv)
		    alt = FALSE;
a9272 2
	if (have < zeros)
	    Perl_croak_nocontext(PL_memory_wrap);
a9299 2
	if (need >= (((STRLEN)~0) - SvCUR(sv) - dotstrlen - 1))
	    Perl_croak_nocontext(PL_memory_wrap);
@


1.10.4.1
log
@MFC:
Fix by millert@@

Fix an int oflow bug in perl's parameter format string code.
Credit: Jack Louis of Dyad Security

ok deraadt@@ millert@@
@
text
@d8544 1
a8544 1
		efix = width > PERL_INT_MAX ? PERL_INT_MAX : width;
@


1.10.4.2
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d8544 1
a8544 1
		efix = width;
d8609 3
a8611 6
		else if (evix) {
		    vecsv = (evix > 0 && evix <= svmax)
			? svargs[evix-1] : &PL_sv_undef;
		} else {
		    vecsv = svix < svmax ? svargs[svix++] : &PL_sv_undef;
		}
d8621 1
a8621 1
	    else if (efix ? (efix > 0 && efix <= svmax) : svix < svmax) {
a8626 1
		vecsv = &PL_sv_undef;
d8727 3
a8729 9
	else if (!args) {
	    if (efix) {
		const I32 i = efix-1;
		argsv = (i >= 0 && i < svmax) ? svargs[i] : &PL_sv_undef;
	    } else {
		argsv = (svix >= 0 && svix < svmax)
		    ? svargs[svix++] : &PL_sv_undef;
	    }
	}
a8970 2
		if (!uv)
		    alt = FALSE;
a9272 2
	if (have < zeros)
	    Perl_croak_nocontext(PL_memory_wrap);
a9299 2
	if (need >= (((STRLEN)~0) - SvCUR(sv) - dotstrlen - 1))
	    Perl_croak_nocontext(PL_memory_wrap);
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d1286 1
d1476 1
a1476 1
	AvFLAGS(sv)	= 0;
a3255 1
	(void)strcpy(s, t);
d3257 1
a3257 1
	return s;
d3642 3
a3644 2
C<ssv> if appropriate, else not. C<sv_setsv> and C<sv_setsv_nomg> are
implemented in terms of this function.
d4007 1
d4572 1
a4572 1
supplied vtable and returns pointer to the magic added.
d4574 8
a4581 8
Note that sv_magicext will allow things that sv_magic will not.
In particular you can add magic to SvREADONLY SVs and and more than
one instance of the same 'how'

I C<namelen> is greater then zero then a savepvn() I<copy> of C<name> is stored,
if C<namelen> is zero then C<name> is stored as-is and - as another special
case - if C<(name && namelen == HEf_SVKEY)> then C<name> is assumed to contain
an C<SV*> and has its REFCNT incremented
d4583 1
a4583 1
(This is now used as a subroutine by sv_magic.)
d4662 3
d5220 1
a5220 1
	(void)SvOOK_off(sv);
d7140 1
a7140 1
		(void)SvOK_off(sv);
d7740 1
a7740 1
	(void)SvOOK_off(rv);
d7747 1
a7747 1
    (void)SvOK_off(rv);
d8117 2
a8118 2
Processes its arguments like C<sprintf> and sets an SV to the formatted
output.  Does not handle 'set' magic.  See C<sv_setpvf_mg>.
d8132 10
a8141 1
/* backend for C<sv_setpvf> and C<sv_setpvf_nocontext> */
d8166 9
a8174 1
/* backend for C<sv_setpvf_mg> C<setpvf_mg_nocontext> */
d8223 2
a8224 3
upgraded to UTF-8.  Handles 'get' magic, but not 'set' magic.
C<SvSETMAGIC()> must typically be called after calling this function
to handle 'set' magic.
d8237 10
a8246 1
/* backend for C<sv_catpvf> and C<catpvf_mg_nocontext> */
d8271 9
a8279 1
/* backend for C<catpvf_mg> and C<catpvf_mg_nocontext> */
d8291 1
a8291 1
Works like C<vcatpvfn> but copies the text into the SV instead of
d8294 1
a8294 1
Usually used via one of its frontends C<sv_setpvf> and C<sv_setpvf_mg>.
d8359 1
a8359 1
Usually used via one of its frontends C<sv_catpvf> and C<sv_catpvf_mg>.
d10809 2
a10810 1
    SvFLAGS(&PL_sv_no)		= SVp_NOK|SVf_NOK|SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
d10814 1
d10820 2
a10821 1
    SvFLAGS(&PL_sv_yes)		= SVp_NOK|SVf_NOK|SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
d10825 1
d11543 1
d11545 1
a11545 1
    return SvPVX(sv);
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d27 5
d247 2
a248 2
			    "Attempt to free non-arena SV: 0x%"UVxf,
			    PTR2UV(p));
a278 1
    Zero(ptr, size, char);
d292 1
d322 2
a323 1
/* visit(): call the named function for each non-free SV in the arenas. */
d326 1
a326 1
S_visit(pTHX_ SVFUNC_t f)
d336 4
a339 1
	    if (SvTYPE(sv) != SVTYPEMASK && SvREFCNT(sv)) {
d374 1
a374 1
    visit(do_report_used);
d415 1
d434 1
a434 1
    visit(do_clean_objs);
d437 1
a437 1
    visit(do_clean_named_objs);
d467 1
a467 1
    cleaned = visit(do_clean_all);
d1918 1
a1918 1
	return 1; /* Historic.  Wrong?  */
d3421 1
a3421 1
Convert the PV of an SV to its UTF-8-encoded form.
d3431 1
a3431 1
Convert the PV of an SV to its UTF-8-encoded form.
d3450 1
a3450 1
    if (!sv)
a3451 1

d3454 7
a3460 3
	(void) sv_2pv_flags(sv,&len, flags);
	if (!SvPOK(sv))
	     return len;
d3463 1
a3463 1
    if (SvUTF8(sv))
d3465 1
d3488 2
a3489 1
	
d3506 3
a3508 3
Attempt to convert the PV of an SV from UTF-8-encoded to byte encoding.
This may not be possible if the PV contains non-byte encoding characters;
if this is the case, either returns false or, if C<fail_ok> is not
d3520 1
a3520 1
    if (SvPOK(sv) && SvUTF8(sv)) {
d3549 2
a3550 3
Convert the PV of an SV to UTF-8-encoded, but then turn off the C<SvUTF8>
flag so that it looks like octets again. Used as a building block
for encode_utf8 in Encode.xs
d3559 6
d3571 5
a3575 3
Convert the octets in the PV from UTF-8 to chars. Scan for validity and then
turn off SvUTF8 if needed so that we see characters. Used as a building block
for decode_utf8 in Encode.xs
d3583 1
a3583 1
    if (SvPOK(sv)) {
d4122 2
a4123 1
bytes to be copied.  Does not handle 'set' magic.  See C<sv_setpvn_mg>.
d4919 1
d4921 2
a4922 3
        I32 i = AvFILLp(av);
        while (i >= 0) {
            if (svp[i] == &PL_sv_undef) {
a4925 2
            i--;
        }
d4947 2
a4948 7
    i = AvFILLp(av);
    while (i >= 0) {
	if (svp[i] == sv) {
	    svp[i] = &PL_sv_undef; /* XXX */
	}
	i--;
    }
d5350 2
a5351 2
                        "Attempt to free unreferenced scalar: SV 0x%"UVxf,
                PTR2UV(sv));
d5361 2
a5362 2
			"Attempt to free temp prematurely: SV 0x%"UVxf,
			PTR2UV(sv));
d5667 1
a5667 2
                   if (utf8_mg_pos_init(sv, &mg, &cache, 2, lenp, s, start))
			cache[2] += *offsetp;
d5760 5
d5802 3
d5863 2
a5864 1
	      if (cur1 != cur2)
d5866 1
d6798 3
a6800 1
statement boundaries.  See also C<sv_newmortal> and C<sv_mortalcopy>.
d6846 1
a6846 1
C<len> bytes long.
d7546 1
d7548 2
a7549 1
    return sv_pvn_force(sv,lp);
d7597 1
d7599 2
a7600 1
    return sv_pvn_force(sv,lp);
d9233 3
a9258 1
	have = esignlen + zeros + elen;
d9432 1
a9432 1
    ret->precomp        = SAVEPV(r->precomp);
d9444 1
a9444 1
	ret->subbeg  = SAVEPV(r->subbeg);
d9545 9
a9553 10
	     AV *av = (AV*) mg->mg_obj;
	     SV **svp;
	     I32 i;
	     nmg->mg_obj = (SV*)newAV();
	     svp = AvARRAY(av);
	     i = AvFILLp(av);
	     while (i >= 0) {
		  av_push((AV*)nmg->mg_obj,sv_dup(svp[i],param));
		  i--;
	     }
d9600 6
d9612 1
a9612 1
    UV hash = PTR2UV(sv);
d9631 2
a9632 2
    UV hash = PTR2UV(oldv);
    bool i = 1;
d9636 1
a9636 1
    for (tblent = *otblent; tblent; i=0, tblent = tblent->next) {
d9648 1
a9648 1
    if (i && tbl->tbl_items > tbl->tbl_max)
d9672 1
a9672 1
	    if ((newsize & PTR2UV(ent->oldval)) != i) {
d10126 4
a10129 1
	CvGV(dstr)	= gv_dup(CvGV(sstr), param);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4260 2
a4264 2
	    SvFAKE_off(sv);
	    SvREADONLY_off(sv);
d4652 1
d5450 3
a5452 5
        if (!*mgp) {
            sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
            *mgp = mg_find(sv, PERL_MAGIC_utf8);
        }
        assert(*mgp);
d5545 6
d5697 3
a5699 3
	 U8* send = s + *offsetp;
	 MAGIC* mg = NULL;
	 STRLEN *cache = NULL;
d5701 1
a5701 1
	 len = 0;
d5703 7
a5709 7
	 if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
	      mg = mg_find(sv, PERL_MAGIC_utf8);
	      if (mg && mg->mg_ptr) {
		   cache = (STRLEN *) mg->mg_ptr;
                   if (cache[1] == (STRLEN)*offsetp) {
                        /* An exact match. */
                        *offsetp = cache[0];
d5711 20
a5730 20
			return;
		   }
		   else if (cache[1] < (STRLEN)*offsetp) {
			/* We already know part of the way. */
			len = cache[0];
			s  += cache[1];
			/* Let the below loop do the rest. */ 
		   }
		   else { /* cache[1] > *offsetp */
			/* We already know all of the way, now we may
			 * be able to walk back.  The same assumption
			 * is made as in S_utf8_mg_pos(), namely that
			 * walking backward is twice slower than
			 * walking forward. */
			STRLEN forw  = *offsetp;
			STRLEN backw = cache[1] - *offsetp;

			if (!(forw < 2 * backw)) {
			     U8 *p = s + cache[1];
			     STRLEN ubackw = 0;
d5732 1
a5732 1
			     cache[1] -= backw;
d5734 1
a5734 1
			     while (backw--) {
d5752 2
a5753 2
	 while (s < send) {
	      STRLEN n = 1;
d5755 11
a5765 11
	      /* Call utf8n_to_uvchr() to validate the sequence
	       * (unless a simple non-UTF character) */
	      if (!UTF8_IS_INVARIANT(*s))
		   utf8n_to_uvchr(s, UTF8SKIP(s), &n, 0);
	      if (n > 0) {
		   s += n;
		   len++;
	      }
	      else
		   break;
	 }
d5767 6
a5772 6
	 if (!SvREADONLY(sv)) {
	      if (!mg) {
		   sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
		   mg = mg_find(sv, PERL_MAGIC_utf8);
	      }
	      assert(mg);
d5774 5
a5778 5
	      if (!mg->mg_ptr) {
		   Newz(0, cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
		   mg->mg_ptr = (char *) cache;
	      }
	      assert(cache);
d5780 3
a5782 3
	      cache[0] = len;
	      cache[1] = *offsetp;
	 }
d5784 1
a5784 1
	 *offsetp = len;
d6105 7
a6111 1
    SV_CHECK_THINKFIRST(sv);
d8254 27
d8308 6
d8349 42
a8421 7
	/* Times 4: a decimal digit takes more than 3 binary digits.
	 * NV_DIG: mantissa takes than many decimal digits.
	 * Plus 32: Playing safe. */
	char ebuf[IV_DIG * 4 + NV_DIG + 32];
	/* large enough for "%#.#f" --chip */
	/* what about long double NVs? --jhi */

a8769 1
		default:	iv = va_arg(*args, int); break;
d8772 1
d8779 1
a8779 1
		iv = SvIVx(argsv);
d8781 4
a8784 4
		case 'h':	iv = (short)iv; break;
		default:	break;
		case 'l':	iv = (long)iv; break;
		case 'V':	break;
d8786 1
a8786 1
		case 'q':	iv = (Quad_t)iv; break;
a8853 1
		default:   uv = va_arg(*args, unsigned); break;
d8856 1
d8858 1
a8858 1
		case 'q':  uv = va_arg(*args, Quad_t); break;
d8863 1
a8863 1
		uv = SvUVx(argsv);
d8865 4
a8868 4
		case 'h':	uv = (unsigned short)uv; break;
		default:	break;
		case 'l':	uv = (unsigned long)uv; break;
		case 'V':	break;
d8870 1
a8870 1
		case 'q':	uv = (Quad_t)uv; break;
d9081 13
d9138 1
d9750 1
a9750 1
        SvREADONLY_on(GvAV(gv));
d10712 4
a10715 3
#ifdef DEBUGGING
    PERL_SET_CONTEXT(proto_perl);
#endif
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
a25 1
#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) sv_force_normal(sv)
d27 17
d175 22
a196 1
#define new_SV(p) \
d208 1
d495 1
d502 1
d509 1
d516 1
d523 1
d530 1
d537 1
d544 1
d551 1
d558 1
d565 1
d572 1
d579 1
d1173 2
a1174 7
#ifdef LEAKTEST
#  define my_safemalloc(s)	(void*)safexmalloc(717,s)
#  define my_safefree(p)	safexfree((char*)p)
#else
#  define my_safemalloc(s)	(void*)safemalloc(s)
#  define my_safefree(p)	safefree((char*)p)
#endif
d1620 1
a1620 1
#if defined(MYMALLOC) && !defined(LEAKTEST)
d2078 1
a2078 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
d2309 1
a2309 1
                        Perl_croak(aTHX_ "sv_2iv assumed (U_V(fabs(SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
d2375 1
a2375 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
d2596 1
a2596 1
                        Perl_croak(aTHX_ "sv_2uv assumed (U_V(fabs(SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
d2663 1
a2663 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
d2925 10
d2952 1
a2952 1
    SV *tsv;
d2993 9
a3001 2
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
		return SvPV(tmpstr,*lp);
d3012 1
a3012 2
			  == (SVs_OBJECT|SVs_RMG))
			 && strEQ(s=HvNAME(SvSTASH(sv)), "Regexp")
d3068 1
d3084 5
d3104 5
a3108 1
		case SVt_PVLV:	s = "LVALUE";			break;
d3268 8
a3275 22
    SV *tmpsv;

    if ( SvTHINKFIRST(ssv) && SvROK(ssv) && SvAMAGIC(ssv) &&
	 (tmpsv = AMG_CALLun(ssv,string))) {
	if (SvTYPE(tmpsv) != SVt_RV || (SvRV(tmpsv) != SvRV(ssv))) {
	    SvSetSV(dsv,tmpsv);
	    return;
	}
    } else {
        tmpsv = sv_newmortal();
    }
    {
	STRLEN len;
	char *s;
	s = SvPV(ssv,len);
	sv_setpvn(tmpsv,s,len);
	if (SvUTF8(ssv))
	    SvUTF8_on(tmpsv);
	else
	    SvUTF8_off(tmpsv);
	SvSetSV(dsv,tmpsv);
    }
d3282 1
a3282 1
May cause the SV to be downgraded from UTF8 as a side-effect.
d3300 1
a3300 1
to its length.  May cause the SV to be downgraded from UTF8 as a
d3318 2
a3319 2
Return a pointer to the UTF8-encoded representation of the SV.
May cause the SV to be upgraded to UTF8 as a side-effect.
d3336 2
a3337 2
Return a pointer to the UTF8-encoded representation of the SV, and set *lp
to its length.  May cause the SV to be upgraded to UTF8 as a side-effect.
d3397 11
d3411 1
a3411 1
Convert the PV of an SV to its UTF8-encoded form.
d3421 1
a3421 1
Convert the PV of an SV to its UTF8-encoded form.
d3457 1
a3457 1
    if (PL_encoding)
d3491 1
a3491 1
Attempt to convert the PV of an SV from UTF8-encoded to byte encoding.
d3534 1
a3534 1
Convert the PV of an SV to UTF8-encoded, but then turn off the C<SvUTF8>
d3589 10
d3649 6
d3715 1
a3715 1
		 SvTYPE(SvRV(sstr)) == SVt_PVGV) {
d3833 1
a3833 1
			SAVESPTR(GvAV(dstr));
d3845 1
a3845 1
			SAVESPTR(GvHV(dstr));
d3863 1
a3863 1
			SAVESPTR(GvCV(dstr));
d3913 1
a3913 1
			SAVESPTR(GvIOp(dstr));
d3920 1
a3920 1
			SAVESPTR(GvFORM(dstr));
d3927 1
a3927 1
			SAVESPTR(GvSV(dstr));
a3939 2
		if (intro)
		    SAVEFREESV(sref);
d4034 6
d4267 1
a4267 1
	else if (PL_curcop != &PL_compiling)
d4299 2
a4308 1

d4311 1
d4325 4
a4328 1
	SvFLAGS(sv) |= SVf_OOK;
d4330 1
a4330 2
    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVp_IOK|SVp_NOK|SVf_IVisUV);
    delta = ptr - SvPVX(sv);
d4337 10
d4351 2
a4352 2
C<len> indicates number of bytes to copy.  If the SV has the UTF8
status set, then the bytes appended should be valid UTF8.
d4358 2
a4359 2
C<len> indicates number of bytes to copy.  If the SV has the UTF8
status set, then the bytes appended should be valid UTF8.
d4399 10
d4481 2
a4482 2
If the SV has the UTF8 status set, then the bytes appended should be
valid UTF8.  Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.
d4581 1
a4581 2
       have its REFCNT incremented to keep it in existence - instead we could
       special case them in sv_free() -- NI-S
d4598 15
d4647 1
a4647 1
	if (PL_curcop != &PL_compiling
d4752 6
d4827 2
d4890 15
a4904 1
	SvREFCNT_dec(av);           /* for sv_magic */
d4906 1
a4906 1
    av_push(av,sv);
d5064 1
a5092 1
	    SV tmpref;
d5094 1
a5094 5
	    Zero(&tmpref, 1, SV);
	    sv_upgrade(&tmpref, SVt_RV);
	    SvROK_on(&tmpref);
	    SvREADONLY_on(&tmpref);	/* DESTROY() could be naughty */
	    SvREFCNT(&tmpref) = 1;
d5100 2
a5103 1
		    SvRV(&tmpref) = SvREFCNT_inc(sv);
d5106 1
a5106 1
		    PUSHs(&tmpref);
d5108 3
a5110 2
		    call_sv((SV*)destructor, G_DISCARD|G_EVAL|G_KEEPERR);
		    SvREFCNT(sv)--;
d5114 7
a5123 1
	    del_XRV(SvANY(&tmpref));
d5177 7
a5183 1
	SvREFCNT_dec(LvTARG(sv));
d5332 3
a5334 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "Attempt to free unreferenced scalar");
d5387 1
a5387 1
UTF8 bytes as a single character. Handles magic and type coercion.
d5392 7
d5409 1
a5409 1
	STRLEN len;
d5411 21
d5433 145
a5577 1
	return Perl_utf8_length(aTHX_ s, s + len);
d5579 2
d5586 1
a5586 1
Converts the value pointed to by offsetp from a count of UTF8 chars from
d5595 7
a5606 2
    U8 *send;
    I32 uoffset = *offsetp;
d5608 2
d5615 42
a5656 14
    send = s + len;
    while (s < send && uoffset--)
	s += UTF8SKIP(s);
    if (s >= send)
	s = send;
    *offsetp = s - start;
    if (lenp) {
	I32 ulen = *lenp;
	start = s;
	while (s < send && ulen--)
	    s += UTF8SKIP(s);
	if (s >= send)
	    s = send;
	*lenp = s - start;
d5658 1
d5666 1
a5666 1
start of the string, to a count of the equivalent number of UTF8 chars.
d5672 7
d5680 1
a5680 1
Perl_sv_pos_b2u(pTHX_ register SV *sv, I32* offsetp)
d5682 1
a5682 2
    U8 *s;
    U8 *send;
d5691 89
a5779 14
    send = s + *offsetp;
    len = 0;
    while (s < send) {
	STRLEN n = 1;
	/* Call utf8n_to_uvchr() to validate the sequence
	 * (unless a simple non-UTF character) */
	if (!UTF8_IS_INVARIANT(*s))
	    utf8n_to_uvchr(s, UTF8SKIP(s), &n, 0);
	if (n > 0) {
	    s += n;
	    len++;
	}
	else
	    break;
d5781 1
a5781 1
    *offsetp = len;
d6098 1
d6105 22
a6126 1
    if (PL_curcop == &PL_compiling) {
d6132 12
d6148 1
a6148 1
      I32 recsize, bytesread;
d6153 1
a6153 2
      (void)SvPOK_only(sv);    /* Validate pointer */
      buffer = SvGROW(sv, (STRLEN)(recsize + 1));
d6158 3
a6160 1
      /* doing, but we've got no other real choice */
d6165 3
a6167 1
      SvCUR_set(sv, bytesread);
d6169 1
a6169 5
      if (PerlIO_isutf8(fp))
	SvUTF8_on(sv);
      else
	SvUTF8_off(sv);
      return(SvCUR(sv) ? SvPVX(sv) : Nullch);
d6238 7
a6244 3
    (void)SvPOK_only(sv);		/* validate pointer */
    if ((I32)(SvLEN(sv) - append) <= cnt + 1) { /* make sure we have the room */
	if (cnt > 80 && (I32)SvLEN(sv) > append) {
d6254 1
a6254 1
    else
d6353 16
a6368 2
#ifndef EPOC
       /*The big, slow, and stupid way */
a6369 6
#else
	/* Need to work around EPOC SDK features          */
	/* On WINS: MS VC5 generates calls to _chkstk,    */
	/* if a `large' stack frame is allocated          */
	/* gcc on MARM does not generate calls like these */
	STDCHAR buf[1024];
d6418 4
d6434 1
a6434 5
    if (PerlIO_isutf8(fp))
	SvUTF8_on(sv);
    else
	SvUTF8_off(sv);

d6461 1
a6461 1
	    if (PL_curcop != &PL_compiling)
d6617 1
a6617 1
	    if (PL_curcop != &PL_compiling)
d7109 1
d7120 1
d7165 1
a7165 1
	    Perl_croak(aTHX_ "Bad filehandle: %s", SvPV(sv,n_a));
d7246 2
a7247 1
		Perl_croak(aTHX_ "Unable to create sub named \"%s\"", SvPV(sv,n_a));
d7346 15
d7395 10
d7463 11
d7512 11
d7593 6
a7598 1
	case SVt_PVLV:		return "LVALUE";
d7719 1
a7719 1
will be returned and will have a reference count of 1.
d7748 1
a7748 1
will be returned and will have a reference count of 1.
d7767 1
a7767 1
will be returned and will have a reference count of 1.
d7786 1
a7786 1
will be returned and will have a reference count of 1.
d7805 2
a7806 2
C<Nullch> to avoid the blessing.  The new SV will be returned and will have
a reference count of 1.
d7923 3
a7925 1
    if (SvREFCNT(rv) != 1 || SvREADONLY(rv) || flags) /* SV_IMMEDIATE_UNREF */
d7996 38
d8267 5
a8271 1
    bool has_utf8 = FALSE; /* has the result utf8? */
d8306 1
a8306 1
        has_utf8 = TRUE;
d8322 1
d8324 6
a8329 1
	
d8340 1
a8340 1
        /* large enough for "%#.#f" --chip */
d8373 4
a8376 1
	    sv_catpvn(sv, p, q - p);
d8387 1
d8453 2
d8463 1
a8463 1
			svargs[ewix ? ewix-1 : svix++] : &PL_sv_undef;
d8555 1
a8555 1
             if (*(q + 1) == 'l') {	/* lld, llf */
d8882 3
a8896 2
		/* FALL THROUGH */
	    case 'l':
d8904 2
a8905 2
	            va_arg(*args, long double) :
	            va_arg(*args, double)
d8907 1
a8907 1
	            va_arg(*args, double)
d8924 1
d8928 66
a9073 1
	    vectorize = FALSE;
d9077 2
a9078 2
		Perl_sv_setpvf(aTHX_ msg, "Invalid conversion in %s: ",
			  (PL_op->op_type == OP_PRTF) ? "printf" : "sprintf");
d9105 1
d9124 7
d9683 14
a9696 3
		SvFAKE_off(dstr);
		SvREADONLY_off(dstr);
		SvPVX(dstr) = SAVEPVN(SvPVX(sstr), SvCUR(sstr));
d9722 12
d9820 6
a9825 1
	LvTARG(dstr)	= sv_dup_inc(LvTARG(sstr), param);
d9880 12
a9892 1
	IoTOP_GV(dstr)		= gv_dup(IoTOP_GV(sstr), param);
a9893 1
	IoFMT_GV(dstr)		= gv_dup(IoFMT_GV(sstr), param);
a9894 1
	IoBOTTOM_GV(dstr)	= gv_dup(IoBOTTOM_GV(sstr), param);
d10001 6
a10006 13
	if (CvPADLIST(sstr) && !AvREAL(CvPADLIST(sstr))) {
	    /* XXX padlists are real, but pretend to be not */
	    AvREAL_on(CvPADLIST(sstr));
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr), param);
	    AvREAL_off(CvPADLIST(sstr));
	    AvREAL_off(CvPADLIST(dstr));
	}
	else
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr), param);
	if (!CvANON(sstr) || CvCLONED(sstr))
	    CvOUTSIDE(dstr)	= cv_dup_inc(CvOUTSIDE(sstr), param);
	else
	    CvOUTSIDE(dstr)	= cv_dup(CvOUTSIDE(sstr), param);
d10084 3
a10086 3
		ncx->blk_loop.oldcurpad
		    = (SV**)ptr_table_fetch(PL_ptr_table,
					    cx->blk_loop.oldcurpad);
d10146 2
d10435 6
d10454 29
d10537 2
d10570 2
d10619 3
d10676 1
a10676 6
    i = PL_origargc;
    New(0, PL_origargv, i+1, char*);
    PL_origargv[i] = '\0';
    while (i-- > 0) {
	PL_origargv[i]	= SAVEPV(proto_perl->Iorigargv[i]);
    }
d10786 1
d10801 1
d10852 2
a10853 6
    PL_comppad			= av_dup(proto_perl->Icomppad, param);
    PL_comppad_name		= av_dup(proto_perl->Icomppad_name, param);
    PL_comppad_name_fill	= proto_perl->Icomppad_name_fill;
    PL_comppad_name_floor	= proto_perl->Icomppad_name_floor;
    PL_curpad			= (SV**)ptr_table_fetch(PL_ptr_table,
							proto_perl->Tcurpad);
a10871 1
    PL_cop_seqmax	= proto_perl->Icop_seqmax;
d10878 1
a10878 1
    PL_sh_path		= proto_perl->Ish_path; /* XXX never deallocated */
a10949 6
    PL_min_intro_pending	= proto_perl->Imin_intro_pending;
    PL_max_intro_pending	= proto_perl->Imax_intro_pending;
    PL_padix			= proto_perl->Ipadix;
    PL_padix_floor		= proto_perl->Ipadix_floor;
    PL_pad_reset_pending	= proto_perl->Ipad_reset_pending;

d11010 34
d11061 2
d11187 1
a11187 3
    PL_av_fetch_sv	= Nullsv;
    PL_hv_fetch_sv	= Nullsv;
    Zero(&PL_hv_fetch_ent_mh, 1, HE);			/* XXX */
d11234 1
d11275 2
d11329 12
a11340 11
    if (SvPOK(sv) && !DO_UTF8(sv) && SvROK(encoding)) {
	  SV *uni;
	  STRLEN len;
	  char *s;
	  dSP;
	  ENTER;
	  SAVETMPS;
	  PUSHMARK(sp);
	  EXTEND(SP, 3);
	  XPUSHs(encoding);
	  XPUSHs(sv);
d11349 1
a11349 1
	  XPUSHs(&PL_sv_yes);
d11351 15
a11365 15
	  PUTBACK;
	  call_method("decode", G_SCALAR);
	  SPAGAIN;
	  uni = POPs;
	  PUTBACK;
	  s = SvPV(uni, len);
	  if (s != SvPVX(sv)) {
	       SvGROW(sv, len + 1);
	       Move(s, SvPVX(sv), len, char);
	       SvCUR_set(sv, len);
	       SvPVX(sv)[len] = 0;	
	  }
	  FREETMPS;
	  LEAVE;
	  SvUTF8_on(sv);
d11370 10
d11381 35
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
a7 3
 */

/*
d9 8
d22 1
d27 107
a133 6
static void do_report_used(pTHXo_ SV *sv);
static void do_clean_objs(pTHXo_ SV *sv);
#ifndef DISABLE_DESTRUCTOR_KLUDGE
static void do_clean_named_objs(pTHXo_ SV *sv);
#endif
static void do_clean_all(pTHXo_ SV *sv);
d155 3
d171 3
d179 1
a179 1
	if (PL_debug & 32768)				\
d189 1
a189 1
    if (PL_debug & 32768) {
d202 1
a202 1
	        Perl_warner(aTHX_ WARN_INTERNAL,
d217 12
d256 2
d267 1
d278 2
d292 1
a292 1
		(FCALL)(aTHXo_ sv);
d300 22
d325 1
d327 43
d371 9
d393 20
d423 9
d537 8
d549 2
a550 2
	Perl_warner(aTHX_ WARN_UNINITIALIZED, PL_warn_uninit,
		    " in ", PL_op_desc[PL_op->op_type]);
d552 1
a552 1
	Perl_warner(aTHX_ WARN_UNINITIALIZED, PL_warn_uninit, "", "");
d555 2
d573 2
d585 2
d594 1
a594 1
    ptr->xpv_pv = (char*)PL_xiv_arenaroot;		/* linked list of xiv arenas */
d599 1
a599 1
    xiv += (sizeof(XPV) - 1) / sizeof(IV) + 1;   /* fudge by size of XPV */
d608 2
d623 2
d635 2
d658 2
d673 2
d684 2
d707 2
d722 2
d733 2
d753 2
d768 2
d779 2
d799 2
d814 2
d825 2
d845 2
d860 2
d871 2
d891 2
d906 2
d917 2
d937 2
d952 2
d963 2
d983 2
d998 2
d1009 2
d1029 2
d1044 2
d1055 2
d1075 2
d1090 2
d1101 2
d1157 1
a1157 1
  
d1195 1
a1195 1
  
d1209 1
a1209 1
 
d1212 1
a1212 1
  
d1219 3
a1221 2
Upgrade an SV to a more complex form.  Use C<SvUPGRADE>.  See
C<svtype>.
d1229 11
a1239 7
    char*	pv;
    U32		cur;
    U32		len;
    IV		iv;
    NV		nv;
    MAGIC*	magic;
    HV*		stash;
d1427 2
a1428 2
	HvKEYS(sv)	= 0;
	SvNVX(sv)	= 0.0;
d1504 9
d1531 3
a1533 3
Expands the character buffer in the SV.  This will use C<sv_unref> and will
upgrade the SV to C<SVt_PV>.  Returns a pointer to the character buffer.
Use C<SvGROW>.
d1543 2
d1570 1
d1582 12
a1593 2
        else
	    New(703,s,newlen,char);
d1603 2
a1604 2
Copies an integer into the given SV.  Does not handle 'set' magic.  See
C<sv_setiv_mg>.
d1632 1
a1632 1
		   PL_op_desc[PL_op->op_type]);
d1657 2
a1658 2
Copies an unsigned integer into the given SV.  Does not handle 'set' magic.
See C<sv_setuv_mg>.
d1666 12
d1694 15
a1708 1
    sv_setuv(sv,u);
d1715 2
a1716 2
Copies a double into the given SV.  Does not handle 'set' magic.  See
C<sv_setnv_mg>.
d1743 1
a1743 1
		   PL_op_name[PL_op->op_type]);
d1765 4
d1772 55
a1826 36
    char tmpbuf[64];
    char *d = tmpbuf;
    char *s;
    char *limit = tmpbuf + sizeof(tmpbuf) - 8;
                  /* each *s can expand to 4 chars + "...\0",
                     i.e. need room for 8 chars */

    for (s = SvPVX(sv); *s && d < limit; s++) {
	int ch = *s & 0xFF;
	if (ch & 128 && !isPRINT_LC(ch)) {
	    *d++ = 'M';
	    *d++ = '-';
	    ch &= 127;
	}
	if (ch == '\n') {
	    *d++ = '\\';
	    *d++ = 'n';
	}
	else if (ch == '\r') {
	    *d++ = '\\';
	    *d++ = 'r';
	}
	else if (ch == '\f') {
	    *d++ = '\\';
	    *d++ = 'f';
	}
	else if (ch == '\\') {
	    *d++ = '\\';
	    *d++ = '\\';
	}
	else if (isPRINT_LC(ch))
	    *d++ = ch;
	else {
	    *d++ = '^';
	    *d++ = toCTRL(ch);
	}
a1827 6
    if (*s) {
	*d++ = '.';
	*d++ = '.';
	*d++ = '.';
    }
    *d = '\0';
d1830 3
a1832 3
	Perl_warner(aTHX_ WARN_NUMERIC,
		    "Argument \"%s\" isn't numeric in %s", tmpbuf,
		PL_op_desc[PL_op->op_type]);
d1834 2
a1835 2
	Perl_warner(aTHX_ WARN_NUMERIC,
		    "Argument \"%s\" isn't numeric", tmpbuf);
d1838 26
a1863 6
/* the number can be converted to integer with atol() or atoll() */
#define IS_NUMBER_TO_INT_BY_ATOL 0x01
#define IS_NUMBER_TO_INT_BY_ATOF 0x02 /* atol() may be != atof() */
#define IS_NUMBER_NOT_IV	 0x04 /* (IV)atof() may be != atof() */
#define IS_NUMBER_NEG		 0x08 /* not good to cache UV */
#define IS_NUMBER_INFINITY	 0x10 /* this is big */
d1868 137
d2031 1
a2031 1
                  (SvRV(tmpstr) != SvRV(sv)))
d2035 3
d2053 4
a2056 4
	/* We can cache the IV/UV value even if it not good enough
	 * to reconstruct NV, since the conversion to PV will prefer
	 * NV over IV/UV.
	 */
d2061 6
a2066 2
	(void)SvIOK_on(sv);
	if (SvNVX(sv) < (NV)IV_MAX + 0.5)
d2068 36
d2106 12
d2120 1
a2120 1
	    DEBUG_c(PerlIO_printf(Perl_debug_log, 
d2129 2
a2130 2
	I32 numtype = looks_like_number(sv);

d2133 5
a2137 2
	   the translation of the initial data.
	  
d2140 1
a2140 1
	   cache the NV if not needed.
d2142 5
a2146 29
	if (numtype & IS_NUMBER_NOT_IV) {
	    /* May be not an integer.  Need to cache NV if we cache IV
	     * - otherwise future conversion to NV will be wrong.  */
	    NV d;

	    d = Atof(SvPVX(sv));

	    if (SvTYPE(sv) < SVt_PVNV)
		sv_upgrade(sv, SVt_PVNV);
	    SvNVX(sv) = d;
	    (void)SvNOK_on(sv);
	    (void)SvIOK_on(sv);
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%" PERL_PRIgldbl ")\n",
				  PTR2UV(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%g)\n",
				  PTR2UV(sv), SvNVX(sv)));
#endif
	    if (SvNVX(sv) < (NV)IV_MAX + 0.5)
		SvIVX(sv) = I_V(SvNVX(sv));
	    else {
		SvUVX(sv) = U_V(SvNVX(sv));
		SvIsUV_on(sv);
		goto ret_iv_max;
	    }
	}
	else {	/* The NV may be reconstructed from IV - safe to cache IV,
		   which may be calculated by atol(). */
d2150 49
a2198 1
	    SvIVX(sv) = Atol(SvPVX(sv));
d2201 78
d2280 1
a2280 2
    }
    else  {
d2293 10
d2328 1
a2328 1
                  (SvRV(tmpstr) != SvRV(sv)))
d2332 3
d2350 6
a2355 4
	/* We can cache the IV/UV value even if it not good enough
	 * to reconstruct NV, since the conversion to PV will prefer
	 * NV over IV/UV.
	 */
d2358 39
a2396 4
	(void)SvIOK_on(sv);
	if (SvNVX(sv) >= -0.5) {
	    SvIsUV_on(sv);
	    SvUVX(sv) = U_V(SvNVX(sv));
d2399 16
a2414 4
	    SvIVX(sv) = I_V(SvNVX(sv));
	  ret_zero:
	    DEBUG_c(PerlIO_printf(Perl_debug_log, 
				  "0x%"UVxf" 2uv(%"IVdf" => %"IVdf") (as signed)\n",
d2416 2
a2417 3
				  SvIVX(sv),
				  (IV)(UV)SvIVX(sv)));
	    return (UV)SvIVX(sv);
d2421 2
a2422 1
	I32 numtype = looks_like_number(sv);
d2427 1
a2427 1
	  
d2432 7
a2438 11
	if (numtype & IS_NUMBER_NOT_IV) {
	    /* May be not an integer.  Need to cache NV if we cache IV
	     * - otherwise future conversion to NV will be wrong.  */
	    NV d;

	    d = Atof(SvPVX(sv));

	    if (SvTYPE(sv) < SVt_PVNV)
		sv_upgrade(sv, SVt_PVNV);
	    SvNVX(sv) = d;
	    (void)SvNOK_on(sv);
d2440 24
a2463 12
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2nv(%" PERL_PRIgldbl ")\n",
				  PTR2UV(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2nv(%g)\n",
				  PTR2UV(sv), SvNVX(sv)));
#endif
	    if (SvNVX(sv) < -0.5) {
		SvIVX(sv) = I_V(SvNVX(sv));
		goto ret_zero;
d2465 14
a2478 2
		SvUVX(sv) = U_V(SvNVX(sv));
		SvIsUV_on(sv);
d2481 15
a2495 20
	else if (numtype & IS_NUMBER_NEG) {
	    /* The NV may be reconstructed from IV - safe to cache IV,
	       which may be calculated by atol(). */
	    if (SvTYPE(sv) == SVt_PV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    SvIVX(sv) = (IV)Atol(SvPVX(sv));
	}
	else if (numtype) {		/* Non-negative */
	    /* The NV may be reconstructed from UV - safe to cache UV,
	       which may be calculated by strtoul()/atol. */
	    if (SvTYPE(sv) == SVt_PV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    (void)SvIsUV_on(sv);
#ifdef HAS_STRTOUL
	    SvUVX(sv) = Strtoul(SvPVX(sv), Null(char**), 10);
#else			/* no atou(), but we know the number fits into IV... */
	    		/* The only problem may be if it is negative... */
	    SvUVX(sv) = (UV)Atol(SvPVX(sv));
d2497 58
a2554 10
	}
	else {				/* Not a number.  Cache 0. */
	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    (void)SvIsUV_on(sv);
	    SvUVX(sv) = 0;		/* We assume that 0s have the
					   same bitmap in IV and UV. */
	    if (ckWARN(WARN_NUMERIC))
		not_a_number(sv);
d2573 10
d2593 2
a2594 1
	    if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) && !looks_like_number(sv))
d2599 1
a2599 1
	    if (SvIsUV(sv)) 
d2616 1
a2616 1
                  (SvRV(tmpstr) != SvRV(sv)))
d2620 3
d2634 1
a2634 1
#if defined(USE_LONG_DOUBLE)
d2645 1
a2645 1
	    PerlIO_printf(Perl_debug_log, "0x%"UVxf" num(%g)\n",
d2653 4
a2656 3
    if (SvIOKp(sv) &&
	    (!SvPOKp(sv) || !strchr(SvPVX(sv),'.') || !looks_like_number(sv)))
    {
d2658 11
d2671 3
a2673 1
	if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) && !looks_like_number(sv))
d2675 9
d2685 68
d2759 2
a2763 1
    SvNOK_on(sv);
d2774 1
a2774 1
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 1nv(%g)\n",
d2782 3
d2788 2
a2789 2
    I32 numtype = looks_like_number(sv);
    NV d;
d2791 11
a2801 2
    if (numtype & IS_NUMBER_TO_INT_BY_ATOL)
	return Atol(SvPVX(sv));
d2806 1
a2806 2
    d = Atof(SvPVX(sv));
    return I_V(d);
d2809 3
d2815 2
a2816 1
    I32 numtype = looks_like_number(sv);
d2818 6
a2823 4
#ifdef HAS_STRTOUL
    if (numtype & IS_NUMBER_TO_INT_BY_ATOL)
	return Strtoul(SvPVX(sv), Null(char**), 10);
#endif
d2832 1
a2832 18
 * Returns a combination of (advisory only - can get false negatives)
 * 	IS_NUMBER_TO_INT_BY_ATOL, IS_NUMBER_TO_INT_BY_ATOF, IS_NUMBER_NOT_IV,
 *	IS_NUMBER_NEG
 * 0 if does not look like number.
 *
 * In fact possible values are 0 and
 * IS_NUMBER_TO_INT_BY_ATOL				123
 * IS_NUMBER_TO_INT_BY_ATOL | IS_NUMBER_NOT_IV		123.1
 * IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV		123e0
 * IS_NUMBER_INFINITY
 * with a possible addition of IS_NUMBER_NEG.
 */

/*
=for apidoc looks_like_number

Test if an the content of an SV looks like a number (or is a
number).
d2834 2
a2838 131
I32
Perl_looks_like_number(pTHX_ SV *sv)
{
    register char *s;
    register char *send;
    register char *sbegin;
    register char *nbegin;
    I32 numtype = 0;
    I32 sawinf  = 0;
    STRLEN len;
#ifdef USE_LOCALE_NUMERIC
    bool specialradix = FALSE;
#endif

    if (SvPOK(sv)) {
	sbegin = SvPVX(sv); 
	len = SvCUR(sv);
    }
    else if (SvPOKp(sv))
	sbegin = SvPV(sv, len);
    else
	return 1;
    send = sbegin + len;

    s = sbegin;
    while (isSPACE(*s))
	s++;
    if (*s == '-') {
	s++;
	numtype = IS_NUMBER_NEG;
    }
    else if (*s == '+')
	s++;

    nbegin = s;
    /*
     * we return IS_NUMBER_TO_INT_BY_ATOL if the number can be converted
     * to _integer_ with atol() and IS_NUMBER_TO_INT_BY_ATOF if you need
     * (int)atof().
     */

    /* next must be digit or the radix separator or beginning of infinity */
    if (isDIGIT(*s)) {
        do {
	    s++;
        } while (isDIGIT(*s));

	if (s - nbegin >= TYPE_DIGITS(IV))	/* Cannot cache ato[ul]() */
	    numtype |= IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV;
	else
	    numtype |= IS_NUMBER_TO_INT_BY_ATOL;

        if (*s == '.'
#ifdef USE_LOCALE_NUMERIC
	    || (specialradix = IS_NUMERIC_RADIX(s))
#endif
	    ) {
#ifdef USE_LOCALE_NUMERIC
	    if (specialradix)
		s += SvCUR(PL_numeric_radix_sv);
	    else
#endif
		s++;
	    numtype |= IS_NUMBER_NOT_IV;
            while (isDIGIT(*s))  /* optional digits after the radix */
                s++;
        }
    }
    else if (*s == '.'
#ifdef USE_LOCALE_NUMERIC
	    || (specialradix = IS_NUMERIC_RADIX(s))
#endif
	    ) {
#ifdef USE_LOCALE_NUMERIC
	if (specialradix)
	    s += SvCUR(PL_numeric_radix_sv);
	else
#endif
	    s++;
	numtype |= IS_NUMBER_TO_INT_BY_ATOL | IS_NUMBER_NOT_IV;
        /* no digits before the radix means we need digits after it */
        if (isDIGIT(*s)) {
	    do {
	        s++;
            } while (isDIGIT(*s));
        }
        else
	    return 0;
    }
    else if (*s == 'I' || *s == 'i') {
	s++; if (*s != 'N' && *s != 'n') return 0;
	s++; if (*s != 'F' && *s != 'f') return 0;
	s++; if (*s == 'I' || *s == 'i') {
	    s++; if (*s != 'N' && *s != 'n') return 0;
	    s++; if (*s != 'I' && *s != 'i') return 0;
	    s++; if (*s != 'T' && *s != 't') return 0;
	    s++; if (*s != 'Y' && *s != 'y') return 0;
	}
	sawinf = 1;
    }
    else
        return 0;

    if (sawinf)
	numtype = IS_NUMBER_INFINITY;
    else {
	/* we can have an optional exponent part */
	if (*s == 'e' || *s == 'E') {
	    numtype &= ~IS_NUMBER_NEG;
	    numtype |= IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV;
	    s++;
	    if (*s == '+' || *s == '-')
		s++;
	    if (isDIGIT(*s)) {
		do {
		    s++;
		} while (isDIGIT(*s));
	    }
	    else
		return 0;
	}
    }
    while (isSPACE(*s))
	s++;
    if (s >= send)
	return numtype;
    if (len == 10 && memEQ(sbegin, "0 but true", 10))
	return IS_NUMBER_TO_INT_BY_ATOL;
    return 0;
}

d2846 7
a2852 1
/* We assume that buf is at least TYPE_CHARS(UV) long. */
d2870 1
a2870 1
	*--ptr = '0' + (uv % 10);
d2878 12
d2891 1
a2891 1
Perl_sv_2pv(pTHX_ register SV *sv, STRLEN *lp)
d2904 2
a2905 1
	mg_get(sv);
d2911 1
a2911 1
	    if (SvIsUV(sv)) 
d2936 1
a2936 1
                    (SvRV(tmpstr) != SvRV(sv)))
d2947 1
a2947 1
			   (SVs_OBJECT|SVf_OK|SVs_GMG|SVs_SMG|SVs_RMG)) 
d2950 1
a2950 1
			 && (mg = mg_find(sv, 'r'))) {
d2959 2
a2960 1
 			    U16 reganch = (re->reganch & PMf_COMPILETIME) >> 12;
d2977 32
d3014 2
d3031 4
a3034 1
		case SVt_PVBM:	s = "SCALAR";			break;
d3045 9
a3053 2
		if (SvOBJECT(sv))
		    Perl_sv_setpvf(aTHX_ tsv, "%s=%s", HvNAME(SvSTASH(sv)), s);
d3069 27
a3095 5
    if (SvNOKp(sv)) {			/* See note in sv_2uv() */
	/* XXXX 64-bit?  IV may have better precision... */
	/* I tried changing this to be 64-bit-aware and
	 * the t/op/numconvert.t became very, very, angry.
	 * --jhi Sep 1999 */
d3098 1
a3098 1
	/* The +20 is pure guesswork.  Configure test needed. --jhi */ 
a3120 25
    else if (SvIOKp(sv)) {
	U32 isIOK = SvIOK(sv);
	U32 isUIOK = SvIsUV(sv);
	char buf[TYPE_CHARS(UV)];
	char *ebuf, *ptr;

	if (SvTYPE(sv) < SVt_PVIV)
	    sv_upgrade(sv, SVt_PVIV);
	if (isUIOK)
	    ptr = uiv_2buf(buf, 0, SvUVX(sv), 1, &ebuf);
	else
	    ptr = uiv_2buf(buf, SvIVX(sv), 0, 0, &ebuf);
	SvGROW(sv, ebuf - ptr + 1);	/* inlined from sv_setpvn */
	Move(ptr,SvPVX(sv),ebuf - ptr,char);
	SvCUR_set(sv, ebuf - ptr);
	s = SvEND(sv);
	*s = '\0';
	if (isIOK)
	    SvIOK_on(sv);
	else
	    SvIOKp_on(sv);
	if (isUIOK)
	    SvIsUV_on(sv);
	SvPOK_on(sv);
    }
d3178 52
d3237 12
d3252 2
a3253 1
    return sv_2pv(sv,lp);
d3256 11
d3274 11
d3291 10
a3300 2
 
/* This function is only called on magical items */
d3312 2
a3313 2
                (SvRV(tmpsv) != SvRV(sv)))
	    return SvTRUE(tmpsv);
d3342 18
d3364 2
a3365 2
void
Perl_sv_utf8_upgrade(pTHX_ register SV *sv)
d3367 1
a3367 1
    char *s, *t, *e;
d3370 2
a3371 2
    if (!sv || !SvPOK(sv) || SvUTF8(sv))
	return;
d3373 5
a3377 10
    /* This function could be much more efficient if we had a FLAG in SVs
     * to signal if there are any hibit chars in the PV.
     * Given that there isn't make loop fast as possible
     */
    s = SvPVX(sv);
    e = SvEND(sv);
    t = s;
    while (t < e) {
	if ((hibit = UTF8_IS_CONTINUED(*t++)))
	    break;
d3380 6
a3385 2
    if (hibit) {
	STRLEN len;
d3387 27
a3413 11
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
	    s = SvPVX(sv);
	}
	len = SvCUR(sv) + 1; /* Plus the \0 */
	SvPVX(sv) = (char*)bytes_to_utf8((U8*)s, &len);
	SvCUR(sv) = len - 1;
	if (SvLEN(sv) != 0)
	    Safefree(s); /* No longer using what was there before. */
	SvLEN(sv) = len; /* No longer know the real size. */
	SvUTF8_on(sv);
d3415 1
d3426 3
d3437 1
a3437 1
	    char *s;
d3442 2
a3443 2
	    s = SvPV(sv, len);
	    if (!utf8_to_bytes((U8*)s, &len)) {
d3449 1
a3449 1
				   PL_op_desc[PL_op->op_type]);
a3455 1
	SvUTF8_off(sv);
d3457 1
a3457 1

d3465 2
a3466 1
flag so that it looks like bytes again. Nothing calls this. 
d3474 1
a3474 1
    sv_utf8_upgrade(sv);
d3478 10
d3492 7
a3498 4
        char *c;
        char *e;
        bool has_utf = FALSE;
        if (!sv_utf8_downgrade(sv, TRUE))
d3504 2
a3505 2
        c = SvPVX(sv);
	if (!is_utf8_string((U8*)c, SvCUR(sv)+1))
d3507 1
a3507 1
        e = SvEND(sv);
d3509 2
a3510 1
            if (UTF8_IS_CONTINUED(*c++)) {
d3519 12
d3532 10
a3541 4
/* Note: sv_setsv() should not be called with a source string that needs
 * to be reused, since it may destroy the source string if it is marked
 * as temporary.
 */
d3543 3
a3545 2
/*
=for apidoc sv_setsv
d3547 2
a3548 4
Copies the contents of the source SV C<ssv> into the destination SV C<dsv>.
The source SV may be destroyed if it is mortal.  Does not handle 'set'
magic.  See the macro forms C<SvSetSV>, C<SvSetSV_nosteal> and
C<sv_setsv_mg>.
d3554 1
a3554 1
Perl_sv_setsv(pTHX_ SV *dstr, register SV *sstr)
d3662 1
a3662 1
		PL_op_name[PL_op->op_type]);
d3674 1
a3674 1
		sv_magic(dstr, dstr, '*', Nullch, 0);
d3685 7
d3709 1
a3709 1
	if (SvGMAGICAL(sstr)) {
d3711 1
a3711 1
	    if (SvTYPE(sstr) != stype) {
d3720 1
a3720 1
	    (void)SvUPGRADE(dstr, stype);
d3732 6
a3738 2
		    GP *gp;
		    gp_free((GV*)dstr);
a3739 3
		    Newz(602,gp, 1, GP);
		    GvGP(dstr) = gp_ref(gp);
		    GvSV(dstr) = NEWSV(72,0);
a3786 6
				SV *const_sv = cv_const_sv(cv);
				bool const_changed = TRUE; 
				if(const_sv)
				    const_changed = sv_cmp(const_sv, 
					   op_const_sv(CvSTART((CV*)sref), 
						       Nullcv));
d3791 1
a3791 1
				    Perl_croak(aTHX_ 
d3794 15
a3808 5
				if ((const_changed || const_sv) && ckWARN(WARN_REDEFINE))
				    Perl_warner(aTHX_ WARN_REDEFINE, const_sv ? 
					     "Constant subroutine %s redefined"
					     : "Subroutine %s redefined", 
					     GvENAME((GV*)dstr));
d3810 3
a3812 2
			    cv_ckproto(cv, (GV*)dstr,
				       SvPOK(sref) ? SvPVX(sref) : Nullch);
d3832 7
d3871 4
a3874 1
	    SvNOK_on(dstr);
d3878 3
a3880 2
	    (void)SvIOK_on(dstr);
	    SvIVX(dstr) = SvIVX(sstr);
d3883 1
d3900 4
a3903 1
	    !(sflags & SVf_OOK)) 	/* and not involved in OOK hack? */
d3919 1
a3919 1
	    (void)SvOK_off(sstr);		/* NOTE: nukes most SvFLAGS on sstr */
d3925 1
a3925 1
	else {					/* have to copy actual string */
d3927 1
a3927 2

	    SvGROW(dstr, len + 1);		/* inlined from sv_setpvn */
d3937 3
a3939 1
	    SvNOK_on(dstr);
d3943 3
a3945 2
	    (void)SvIOK_on(dstr);
	    SvIVX(dstr) = SvIVX(sstr);
a3947 7
	}
    }
    else if (sflags & SVp_NOK) {
	SvNVX(dstr) = SvNVX(sstr);
	(void)SvNOK_only(dstr);
	if (sflags & SVf_IOK) {
	    (void)SvIOK_on(dstr);
a3948 3
	    /* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
	    if (sflags & SVf_IVisUV)
		SvIsUV_on(dstr);
d3952 7
a3958 2
	(void)SvIOK_only(dstr);
	SvIVX(dstr) = SvIVX(sstr);
d3961 17
d3982 1
a3982 1
		Perl_warner(aTHX_ WARN_MISC, "Undefined value assigned to typeglob");
d4028 2
a4029 1
	assert(iv >= 0);
d4038 1
a4038 1
    (void)SvPOK_only(sv);		/* validate pointer */
d4082 1
a4082 1
    (void)SvPOK_only(sv);		/* validate pointer */
d4105 1
a4105 1
stored inside the SV but sv_usepvn allows the SV to use an outside string. 
d4132 1
a4132 1
    (void)SvPOK_only(sv);		/* validate pointer */
d4151 11
d4163 1
a4163 1
Perl_sv_force_normal(pTHX_ register SV *sv)
d4166 12
a4177 1
	if (PL_curcop != &PL_compiling)
d4181 1
a4181 1
	sv_unref(sv);
d4185 17
a4201 1
    
d4205 1
a4205 1
Efficient removal of characters from the beginning of the string buffer. 
d4208 1
a4208 1
string.
d4214 1
a4214 3
Perl_sv_chop(pTHX_ register SV *sv, register char *ptr)	/* like set but assuming ptr is in sv */
                
                   
d4247 12
a4258 2
C<len> indicates number of bytes to copy.  Handles 'get' magic, but not
'set' magic.  See C<sv_catpvn_mg>.
d4264 1
a4264 1
Perl_sv_catpvn(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
d4266 2
a4267 2
    STRLEN tlen;
    char *junk;
d4269 9
a4277 9
    junk = SvPV_force(sv, tlen);
    SvGROW(sv, tlen + len + 1);
    if (ptr == junk)
	ptr = SvPVX(sv);
    Move(ptr,SvPVX(sv)+tlen,len,char);
    SvCUR(sv) += len;
    *SvEND(sv) = '\0';
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
    SvTAINT(sv);
d4302 7
d4312 1
a4312 1
Perl_sv_catsv(pTHX_ SV *dstr, register SV *sstr)
d4316 1
a4316 1
    if (!sstr)
d4318 14
a4331 3
    if ((spv = SvPV(sstr, slen))) {
	bool dutf8 = DO_UTF8(dstr);
	bool sutf8 = DO_UTF8(sstr);
d4333 1
a4333 3
	if (dutf8 == sutf8)
	    sv_catpvn(dstr,spv,slen);
	else {
d4335 5
a4339 13
		SV* cstr = newSVsv(sstr);
		char *cpv;
		STRLEN clen;

		sv_utf8_upgrade(cstr);
		cpv = SvPV(cstr,clen);
		sv_catpvn(dstr,cpv,clen);
		sv_2mortal(cstr);
	    }
	    else {
		sv_utf8_upgrade(dstr);
		sv_catpvn(dstr,spv,slen);
		SvUTF8_on(dstr);
d4341 2
d4344 1
d4357 1
a4357 1
Perl_sv_catsv_mg(pTHX_ SV *dstr, register SV *sstr)
d4359 2
a4360 2
    sv_catsv(dstr,sstr);
    SvSETMAGIC(dstr);
d4367 2
a4368 1
Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.
d4370 1
a4370 2
=cut
*/
d4407 10
d4421 1
a4421 1
    
d4426 75
a4500 2
    }
    return sv;
a4502 2
/* name is assumed to contain an SV* if (name && namelen == HEf_SVKEY) */

d4506 2
a4507 1
Adds magic to an SV.
d4516 2
a4517 1
    
d4519 7
a4525 1
	if (PL_curcop != &PL_compiling && !strchr("gBf", how))
d4527 1
d4529 1
a4529 1
    if (SvMAGICAL(sv) || (how == 't' && SvTYPE(sv) >= SVt_PVMG)) {
d4531 4
a4534 1
	    if (how == 't')
a4538 6
    else {
        (void)SvUPGRADE(sv, SVt_PVMG);
    }
    Newz(702,mg, 1, MAGIC);
    mg->mg_moremagic = SvMAGIC(sv);
    SvMAGIC(sv) = mg;
a4539 24
    /* Some magic sontains a reference loop, where the sv and object refer to
       each other.  To prevent a avoid a reference loop that would prevent such
       objects being freed, we look for such loops and if we find one we avoid
       incrementing the object refcount. */
    if (!obj || obj == sv || how == '#' || how == 'r' ||
	(SvTYPE(obj) == SVt_PVGV &&
	    (GvSV(obj) == sv || GvHV(obj) == (HV*)sv || GvAV(obj) == (AV*)sv ||
	    GvCV(obj) == (CV*)sv || GvIOp(obj) == (IO*)sv ||
	    GvFORM(obj) == (CV*)sv)))
    {
	mg->mg_obj = obj;
    }
    else {
	mg->mg_obj = SvREFCNT_inc(obj);
	mg->mg_flags |= MGf_REFCOUNTED;
    }
    mg->mg_type = how;
    mg->mg_len = namlen;
    if (name)
	if (namlen >= 0)
	    mg->mg_ptr = savepvn(name, namlen);
	else if (namlen == HEf_SVKEY)
	    mg->mg_ptr = (char*)SvREFCNT_inc((SV*)name);
    
d4541 2
a4542 2
    case 0:
	mg->mg_virtual = &PL_vtbl_sv;
d4544 2
a4545 2
    case 'A':
        mg->mg_virtual = &PL_vtbl_amagic;
d4547 2
a4548 2
    case 'a':
        mg->mg_virtual = &PL_vtbl_amagicelem;
d4550 2
a4551 2
    case 'c':
        mg->mg_virtual = 0;
d4553 2
a4554 2
    case 'B':
	mg->mg_virtual = &PL_vtbl_bm;
d4556 2
a4557 2
    case 'D':
	mg->mg_virtual = &PL_vtbl_regdata;
d4559 2
a4560 2
    case 'd':
	mg->mg_virtual = &PL_vtbl_regdatum;
d4562 2
a4563 2
    case 'E':
	mg->mg_virtual = &PL_vtbl_env;
d4565 2
a4566 2
    case 'f':
	mg->mg_virtual = &PL_vtbl_fm;
d4568 2
a4569 2
    case 'e':
	mg->mg_virtual = &PL_vtbl_envelem;
d4571 2
a4572 2
    case 'g':
	mg->mg_virtual = &PL_vtbl_mglob;
d4574 2
a4575 2
    case 'I':
	mg->mg_virtual = &PL_vtbl_isa;
d4577 2
a4578 2
    case 'i':
	mg->mg_virtual = &PL_vtbl_isaelem;
d4580 2
a4581 2
    case 'k':
	mg->mg_virtual = &PL_vtbl_nkeys;
d4583 2
a4584 3
    case 'L':
	SvRMAGICAL_on(sv);
	mg->mg_virtual = 0;
d4586 2
a4587 2
    case 'l':
	mg->mg_virtual = &PL_vtbl_dbline;
d4589 3
a4591 3
#ifdef USE_THREADS
    case 'm':
	mg->mg_virtual = &PL_vtbl_mutex;
d4593 1
a4593 1
#endif /* USE_THREADS */
d4595 2
a4596 2
    case 'o':
        mg->mg_virtual = &PL_vtbl_collxfrm;
d4599 2
a4600 2
    case 'P':
	mg->mg_virtual = &PL_vtbl_pack;
d4602 3
a4604 3
    case 'p':
    case 'q':
	mg->mg_virtual = &PL_vtbl_packelem;
d4606 2
a4607 2
    case 'r':
	mg->mg_virtual = &PL_vtbl_regexp;
d4609 2
a4610 2
    case 'S':
	mg->mg_virtual = &PL_vtbl_sig;
d4612 2
a4613 2
    case 's':
	mg->mg_virtual = &PL_vtbl_sigelem;
d4615 2
a4616 3
    case 't':
	mg->mg_virtual = &PL_vtbl_taint;
	mg->mg_len = 1;
d4618 2
a4619 2
    case 'U':
	mg->mg_virtual = &PL_vtbl_uvar;
d4621 2
a4622 2
    case 'v':
	mg->mg_virtual = &PL_vtbl_vec;
d4624 2
a4625 2
    case 'x':
	mg->mg_virtual = &PL_vtbl_substr;
d4627 2
a4628 2
    case 'y':
	mg->mg_virtual = &PL_vtbl_defelem;
d4630 2
a4631 2
    case '*':
	mg->mg_virtual = &PL_vtbl_glob;
d4633 2
a4634 2
    case '#':
	mg->mg_virtual = &PL_vtbl_arylen;
d4636 2
a4637 2
    case '.':
	mg->mg_virtual = &PL_vtbl_pos;
d4639 2
a4640 2
    case '<':
	mg->mg_virtual = &PL_vtbl_backref;
d4642 2
a4643 1
    case '~':	/* Reserved for use by extensions not perl internals.	*/
d4647 14
a4662 2
    default:
	Perl_croak(aTHX_ "Don't know how to handle magic of type '%c'", how);
a4663 3
    mg_magical(sv);
    if (SvGMAGICAL(sv))
	SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
d4669 1
a4669 1
Removes magic from an SV.
d4688 2
a4689 2
	    if (mg->mg_ptr && mg->mg_type != 'g')
		if (mg->mg_len >= 0)
d4693 1
d4703 1
a4703 1
	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d4712 4
a4715 1
Weaken a reference.
d4730 1
a4730 1
	    Perl_warner(aTHX_ WARN_MISC, "Reference is already weak");
d4736 1
a4736 1
    SvREFCNT_dec(tsv);              
d4740 6
a4745 2
void
Perl_sv_add_backref(pTHX_ SV *tsv, SV *sv)
d4749 1
a4749 1
    if (SvMAGICAL(tsv) && (mg = mg_find(tsv, '<')))
d4753 1
a4753 1
	sv_magic(tsv, (SV*)av, '<', NULL, 0);
d4759 6
a4764 2
void 
Perl_sv_del_backref(pTHX_ SV *sv)
d4770 2
a4771 2
    MAGIC *mg;
    if (!SvMAGICAL(tsv) || !(mg = mg_find(tsv, '<')))
d4802 1
a4802 1
    
d4882 5
d4897 1
a4897 1
	Perl_warner(aTHX_ WARN_INTERNAL, "Reference miscount in sv_replace()");
d4920 7
a4926 2
Clear an SV, making it empty. Does not free the memory used by the SV
itself.
d4941 1
a4941 1
	    GV* destructor;
d4950 1
a4950 1
	    do {
d4952 1
a4952 1
		destructor = gv_fetchmethod(SvSTASH(sv), "DESTROY");
d4961 1
a4961 2
		    call_sv((SV*)GvCV(destructor),
			    G_DISCARD|G_EVAL|G_KEEPERR);
d4987 6
a4992 2
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv))
	mg_free(sv);
d5050 6
d5124 9
d5144 4
a5147 1
Free the memory used by an SV.
d5161 2
d5172 1
a5172 1
	    Perl_warner(aTHX_ WARN_INTERNAL, "Attempt to free unreferenced scalar");
d5181 1
a5181 1
	    Perl_warner(aTHX_ WARN_DEBUGGING,
d5200 2
a5201 1
Returns the length of the string in the SV.  See also C<SvCUR>.
a5208 1
    char *junk;
d5217 1
a5217 1
	junk = SvPV(sv, len);
d5225 1
a5225 1
UTF8 bytes as a single character.
a5235 1
#ifdef NOTYET
a5238 1
#endif
d5247 12
d5290 10
d5311 1
a5311 1
    if (len < *offsetp)
d5316 6
a5321 3
	STRLEN n;

	if (utf8_to_uv(s, UTF8SKIP(s), &n, 0)) {
d5336 2
a5337 1
identical.
d5350 2
a5351 2
    bool pv1tmp = FALSE;
    bool pv2tmp = FALSE;
d5367 42
a5408 16
    /* do not utf8ize the comparands as a side-effect */
    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTE) {
	bool is_utf8 = TRUE;

	if (SvUTF8(sv1)) {
	    char *pv = (char*)bytes_from_utf8((U8*)pv1, &cur1, &is_utf8);

	    if ((pv1tmp = (pv != pv1)))
		pv1 = pv;
	}
	else {
	    char *pv = (char *)bytes_from_utf8((U8*)pv2, &cur2, &is_utf8);

	    if ((pv2tmp = (pv != pv2)))
		pv2 = pv;
	}
d5414 5
a5418 4
    if (pv1tmp)
	Safefree(pv1);
    if (pv2tmp)
	Safefree(pv2);
d5428 2
a5429 1
C<sv2>.
d5438 3
a5440 4
    char *pv1, *pv2;
    I32  cmp; 
    bool pv1tmp = FALSE;
    bool pv2tmp = FALSE;
d5449 1
a5449 1
    if (!sv2){
d5456 3
a5458 2
    /* do not utf8ize the comparands as a side-effect */
    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTE) {
d5460 8
a5467 2
	    pv2 = (char*)bytes_to_utf8((U8*)pv2, &cur2);
	    pv2tmp = TRUE;
d5470 8
a5477 2
	    pv1 = (char*)bytes_to_utf8((U8*)pv1, &cur1);
	    pv1tmp = TRUE;
d5497 5
a5501 4
    if (pv1tmp)
	Safefree(pv1);
    if (pv2tmp)
	Safefree(pv2);
d5509 3
a5511 2
Compares the strings in two SVs in a locale-aware manner. See
L</sv_cmp_locale>
d5564 1
d5566 1
d5568 12
a5579 5
 * Any scalar variable may carry an 'o' magic that contains the
 * scalar data of the variable transformed to such a format that
 * a normal memory comparison can be used to compare the data
 * according to the locale settings.
 */
d5585 1
a5585 1
    mg = SvMAGICAL(sv) ? mg_find(sv, 'o') : (MAGIC *) NULL;
d5600 2
a5601 2
		sv_magic(sv, 0, 'o', 0, 0);
		mg = mg_find(sv, 'o');
d5643 2
a5644 1
    I32 i;
d5651 6
a5656 1
    if (RsSNARF(PL_rs)) {
d5667 1
a5667 1
      buffer = SvGROW(sv, recsize + 1);
d5679 4
a5682 1
      SvUTF8_off(sv);
d5688 1
d5692 8
a5699 3
	if (SvUTF8(PL_rs)) {
	    if (!sv_utf8_downgrade(PL_rs, TRUE)) {
		Perl_croak(aTHX_ "Wide character in $/");
d5701 1
a5702 1
	rsptr = SvPV(PL_rs, rslen);
d5707 1
a5707 1
    if (RsPARA(PL_rs)) {		/* have to do this both before and after */
d5724 1
a5724 1
       of abstracting out stdio interface. One call should be cheap 
d5753 2
a5754 2
    if (SvLEN(sv) - append <= cnt + 1) { /* make sure we have the room */
	if (cnt > 80 && SvLEN(sv) > append) {
d5761 1
a5761 1
	    SvGROW(sv, append + (cnt <= 0 ? 2 : (cnt + 1)));
d5771 2
a5772 2
	"Screamer: entering: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	       PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
d5785 2
a5786 2
	        Copy(ptr, bp, cnt, char);	     /* this     |  eat */    
		bp += cnt;			     /* screams  |  dust */   
d5805 2
a5806 1
	PerlIO_set_ptrcnt(fp, ptr, cnt); /* deregisterize cnt and ptr */
d5809 1
a5809 1
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
d5811 2
a5812 1
	/* This used to call 'filbuf' in stdio form, but as that behaves like 
d5816 1
d5819 1
a5819 1
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
d5821 1
d5835 1
a5835 1
	*bp++ = i;			/* store character from PerlIO_getc */
d5842 1
a5842 1
    if ((rslen > 1 && (bp - (STDCHAR*)SvPVX(sv) < rslen)) ||
d5850 1
a5850 1
    PerlIO_set_ptrcnt(fp, ptr, cnt);	/* put these back or we're in trouble */
d5853 1
a5853 1
	PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
d5878 1
a5878 1
	    while ((i = PerlIO_getc(fp)) != EOF && (*bp++ = i) != rslast && bp < bpe)
d5887 4
a5890 1
	    if (cnt) { i = (U8)buf[cnt - 1]; } else { i = EOF; }
d5893 2
d5896 1
a5896 1
	    sv_catpvn(sv, (char *) buf, cnt);
d5898 1
a5898 1
	    sv_setpvn(sv, (char *) buf, cnt);
d5922 1
a5922 1
    if (RsPARA(PL_rs)) {		/* have to do this both before and after */  
d5932 4
a5935 1
    SvUTF8_off(sv);
a5939 1

d5943 2
a5944 1
Auto-increment of the value in the SV.
d5960 2
d5976 11
a5986 6
    if (flags & SVp_NOK) {
	(void)SvNOK_only(sv);
	SvNVX(sv) += 1.0;
	return;
    }
    if (flags & SVp_IOK) {
d5989 1
a5989 1
		sv_setnv(sv, (NV)UV_MAX + 1.0);
d5995 1
a5995 1
		sv_setnv(sv, (NV)IV_MAX + 1.0);
d5999 1
a5999 1
	    }	    
d6003 6
d6010 4
a6013 4
	if ((flags & SVTYPEMASK) < SVt_PVNV)
	    sv_upgrade(sv, SVt_NV);
	SvNVX(sv) = 1.0;
	(void)SvNOK_only(sv);
d6020 36
a6055 1
	sv_setnv(sv,Atof(SvPVX(sv)) + 1.0);  /* punt */
d6070 1
a6070 1
	     * arranged in order (although not consecutively) and that only 
d6100 2
a6101 1
Auto-decrement of the value in the SV.
d6116 2
d6131 2
d6134 5
a6138 6
    if (flags & SVp_NOK) {
	SvNVX(sv) -= 1.0;
	(void)SvNOK_only(sv);
	return;
    }
    if (flags & SVp_IOK) {
d6147 1
a6147 1
	    }	    
d6154 1
a6154 1
	    }	    
d6158 5
d6170 34
d6210 4
a6213 2
Creates a new SV which is a copy of the original SV.  The new SV is marked
as mortal.
d6239 4
a6242 1
Creates a new SV which is mortal.  The reference count of the SV is set to 1.
d6262 3
a6264 2
Marks an SV as mortal.  The SV will be destroyed when the current context
ends.
a6268 2
/* same thing without the copying */

d6308 1
a6308 1
SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length 
d6325 43
d6369 6
d6391 1
a6391 1
Creates a new SV an initialize it with the string formatted like
d6408 2
d6498 4
a6501 1
/* newRV_inc is #defined to newRV in sv.h */
d6512 1
a6516 2
/* make an exact duplicate of old */

d6526 1
a6526 1
	    Perl_warner(aTHX_ WARN_INTERNAL, "semi-panic: attempt to dup freed string");
d6540 9
d6612 6
a6617 1
		    if (gv == PL_envgv)
d6619 1
d6627 10
d6671 9
d6683 2
a6684 2
    GV *gv;
    CV *cv;
d6756 2
d6788 9
d6808 9
d6828 9
d6845 13
d6859 1
a6859 1
Perl_sv_pv(pTHX_ SV *sv)
d6861 2
a6862 3
    STRLEN n_a;

    if (SvPOK(sv))
d6864 3
a6867 2
    return sv_2pv(sv, &n_a);
}
d6870 1
a6870 1
Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp)
d6876 1
a6876 1
    return sv_2pv(sv, lp);
d6883 11
d6899 1
a6899 1
Perl_sv_pvn_force(pTHX_ SV *sv, STRLEN *lp)
d6901 1
a6901 1
    char *s;
d6905 1
a6905 1
    
d6912 1
a6912 1
		PL_op_name[PL_op->op_type]);
d6915 1
a6915 1
	    s = sv_2pv(sv, lp);
d6918 1
a6918 1
	    
d6935 12
a6946 1
}
d6948 2
a6949 5
char *
Perl_sv_pvbyte(pTHX_ SV *sv)
{
    return sv_pv(sv);
}
d6954 1
d6958 10
d6971 1
d6975 13
a6987 6
char *
Perl_sv_pvutf8(pTHX_ SV *sv)
{
    sv_utf8_upgrade(sv);
    return sv_pv(sv);
}
d6999 3
a7001 2
Get a sensible UTF8-encoded string out of the SV somehow. See
L</sv_pvn_force>.
d7024 6
a7029 2
    if (ob && SvOBJECT(sv))
	return HvNAME(SvSTASH(sv));
d7208 19
d7304 6
d7313 3
d7329 1
a7329 1
    sv_unmagic(sv, '*');
d7344 1
a7344 1
=for apidoc sv_unref
d7348 5
a7352 1
as a reversal of C<newSVrv>.  See C<SvROK_off>.
d7358 1
a7358 1
Perl_sv_unref(pTHX_ SV *sv)
d7370 1
a7370 1
    if (SvREFCNT(rv) != 1 || SvREADONLY(rv))
d7372 1
a7372 1
    else
d7376 24
d7403 1
a7403 1
    sv_magic((sv), Nullsv, 't', Nullch, 0);
d7406 7
d7417 1
a7417 1
	MAGIC *mg = mg_find(sv, 't');
d7423 7
d7434 1
a7434 1
	MAGIC *mg = mg_find(sv, 't');
d7441 1
a7441 2
/*
=for apidoc sv_setpviv
d7443 4
a7446 35
Copies an integer into the given SV, also updating its string value.
Does not handle 'set' magic.  See C<sv_setpviv_mg>.

=cut
*/

void
Perl_sv_setpviv(pTHX_ SV *sv, IV iv)
{
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    sv_setpvn(sv, ptr, ebuf - ptr);
}


/*
=for apidoc sv_setpviv_mg

Like C<sv_setpviv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setpviv_mg(pTHX_ SV *sv, IV iv)
{
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    sv_setpvn(sv, ptr, ebuf - ptr);
    SvSETMAGIC(sv);
}
a7447 1
#if defined(PERL_IMPLICIT_CONTEXT)
d7458 4
d7492 2
d7517 2
d7527 6
d7543 5
d7562 7
a7568 3
Processes its arguments like C<sprintf> and appends the formatted output
to an SV.  Handles 'get' magic, but not 'set' magic.  C<SvSETMAGIC()> must
typically be called after calling this function to handle 'set' magic.
d7570 1
a7570 2
=cut
*/
d7581 2
d7606 2
d7621 2
d7633 17
d7659 2
d7673 2
a7674 1
    SV *argsv;
d7708 3
d7716 2
a7717 1
	bool utf = FALSE;
d7725 2
a7726 2
	bool is_utf = FALSE;

d7740 1
a7740 1
	SV *vecsv;
d7743 1
a7743 1
	char c;
d7745 9
a7753 3
	unsigned base;
	IV iv;
	UV uv;
d7755 1
d7761 5
d7767 1
d7776 19
a7817 20
	    case '*':			/* printf("%*vX",":",$ipv6addr) */
		if (q[1] != 'v')
		    break;
		q++;
		if (args)
		    vecsv = va_arg(*args, SV*);
		else if (svix < svmax)
		    vecsv = svargs[svix++];
		else
		    continue;
		dotstr = SvPVx(vecsv,dotstrlen);
		if (DO_UTF8(vecsv))
		    is_utf = TRUE;
		/* FALL THROUGH */

	    case 'v':
		vectorize = TRUE;
		q++;
		continue;

d7824 20
a7843 1
	/* WIDTH */
d7845 29
a7873 8
	switch (*q) {
	case '1': case '2': case '3':
	case '4': case '5': case '6':
	case '7': case '8': case '9':
	    width = 0;
	    while (isDIGIT(*q))
		width = width * 10 + (*q++ - '0');
	    break;
d7875 1
a7875 1
	case '*':
d7879 2
a7880 1
		i = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
a7882 2
	    q++;
	    break;
d7884 1
d7891 6
d7900 2
a7901 1
		    i = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
a7902 1
		q++;
a7911 17
	if (vectorize) {
	    if (args) {
		vecsv = va_arg(*args, SV*);
		vecstr = (U8*)SvPVx(vecsv,veclen);
		utf = DO_UTF8(vecsv);
	    }
	    else if (svix < svmax) {
		vecsv = svargs[svix++];
		vecstr = (U8*)SvPVx(vecsv,veclen);
		utf = DO_UTF8(vecsv);
	    }
	    else {
		vecstr = (U8*)"";
		veclen = 0;
	    }
	}

d7915 20
a7934 1
#if defined(HAS_QUAD) || (defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE))
a7936 1
#endif
d7939 1
d7945 1
a7945 1
#if defined(HAS_QUAD) || (defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE))
d7962 12
a7977 5
	case '%':
	    eptr = q - 1;
	    elen = 1;
	    goto string;

d7979 4
a7982 5
	    if (args)
		uv = va_arg(*args, int);
	    else
		uv = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
	    if ((uv > 255 || (uv > 127 && SvUTF8(sv))) && !IN_BYTE) {
d7984 2
a7985 2
		elen = uv_to_utf8((U8*)eptr, uv) - utf8buf;
		is_utf = TRUE;
d7995 1
a7995 1
	    if (args) {
d8010 1
a8010 2
	    else if (svix < svmax) {
		argsv = svargs[svix++];
d8021 1
a8021 1
		    is_utf = TRUE;
d8032 1
a8032 1
	    if (!args)
d8034 1
a8034 1
	    argsv = va_arg(*args,SV*);
d8037 1
a8037 1
		is_utf = TRUE;
d8048 1
a8048 1
	    if (alt)
d8050 1
a8050 4
	    if (args)
		uv = PTR2UV(va_arg(*args, void*));
	    else
		uv = (svix < svmax) ? PTR2UV(svargs[svix++]) : 0;
d8065 5
a8069 6
		if (!veclen) {
		    vectorize = FALSE;
		    break;
		}
		if (utf)
		    iv = (IV)utf8_to_uv(vecstr, veclen, &ulen, 0);
d8071 1
a8071 1
		    iv = *vecstr;
d8076 2
d8091 1
a8091 1
		iv = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
d8102 11
a8112 8
	    if (iv >= 0) {
		uv = iv;
		if (plus)
		    esignbuf[esignlen++] = plus;
	    }
	    else {
		uv = -iv;
		esignbuf[esignlen++] = '-';
d8151 5
a8155 6
		if (!veclen) {
		    vectorize = FALSE;
		    break;
		}
		if (utf)
		    uv = utf8_to_uv(vecstr, veclen, &ulen, 0);
d8175 1
a8175 1
		uv = (svix < svmax) ? SvUVx(svargs[svix++]) : 0;
d8231 1
a8231 1
			Perl_warner(aTHX_ WARN_Y2K,
d8252 37
a8288 1
	    /* FLOATING POINT */
d8290 10
a8299 8
	case 'F':
	    c = 'f';		/* maybe %F isn't supported here */
	    /* FALL THROUGH */
	case 'e': case 'E':
	case 'f':
	case 'g': case 'G':

	    /* This is evil, but floating point is even more evil */
d8301 1
a8302 6
	    if (args)
		nv = va_arg(*args, NV);
	    else
		nv = (svix < svmax) ? SvNVx(svargs[svix++]) : 0.0;

	    need = 0;
d8305 2
d8328 3
a8330 2
#if defined(USE_LONG_DOUBLE) && defined(PERL_PRIfldbl)
	    {
d8361 6
d8368 1
a8368 1

a8375 1
	    vectorize = FALSE;
d8377 1
a8377 1
	    if (args) {
d8388 3
a8390 2
	    else if (svix < svmax)
		sv_setuv_mg(svargs[svix++], (UV)i);
d8405 1
a8405 1
			Perl_sv_catpvf(aTHX_ msg, 
d8413 1
a8413 1
		Perl_warner(aTHX_ WARN_PRINTF, "%"SVf, msg); /* yes, this is reentrant */
d8425 1
a8425 1
	    memcpy(p, eptr, elen);
d8432 16
d8455 1
a8455 1
	    for (i = 0; i < esignlen; i++)
d8463 1
a8463 1
	    for (i = 0; i < esignlen; i++)
d8471 1
a8471 1
	    memcpy(p, eptr, elen);
d8480 1
a8480 1
		memcpy(p, dotstr, dotstrlen);
d8486 3
a8488 1
	if (is_utf)
d8499 17
d8518 2
a8519 2
#if defined(USE_THREADS)
#  include "error: USE_THREADS and USE_ITHREADS are incompatible"
d8527 11
a8537 11
#define sv_dup_inc(s)	SvREFCNT_inc(sv_dup(s))
#define av_dup(s)	(AV*)sv_dup((SV*)s)
#define av_dup_inc(s)	(AV*)SvREFCNT_inc(sv_dup((SV*)s))
#define hv_dup(s)	(HV*)sv_dup((SV*)s)
#define hv_dup_inc(s)	(HV*)SvREFCNT_inc(sv_dup((SV*)s))
#define cv_dup(s)	(CV*)sv_dup((SV*)s)
#define cv_dup_inc(s)	(CV*)SvREFCNT_inc(sv_dup((SV*)s))
#define io_dup(s)	(IO*)sv_dup((SV*)s)
#define io_dup_inc(s)	(IO*)SvREFCNT_inc(sv_dup((SV*)s))
#define gv_dup(s)	(GV*)sv_dup((SV*)s)
#define gv_dup_inc(s)	(GV*)SvREFCNT_inc(sv_dup((SV*)s))
d8541 4
d8546 1
a8546 1
Perl_re_dup(pTHX_ REGEXP *r)
d8548 92
a8639 2
    /* XXX fix when pmop->op_pmregexp becomes shared */
    return ReREFCNT_inc(r);
d8642 2
d8645 1
a8645 1
Perl_fp_dup(pTHX_ PerlIO *fp, char type)
d8657 1
a8657 1
    ret = PerlIO_fdupopen(fp);
d8662 2
d8673 2
d8676 1
a8676 1
Perl_gp_dup(pTHX_ GP *gp)
d8692 7
a8698 7
    ret->gp_sv		= sv_dup_inc(gp->gp_sv);
    ret->gp_io		= io_dup_inc(gp->gp_io);
    ret->gp_form	= cv_dup_inc(gp->gp_form);
    ret->gp_av		= av_dup_inc(gp->gp_av);
    ret->gp_hv		= hv_dup_inc(gp->gp_hv);
    ret->gp_egv		= gv_dup(gp->gp_egv);	/* GvEGV is not refcounted */
    ret->gp_cv		= cv_dup_inc(gp->gp_cv);
d8706 2
d8709 1
a8709 1
Perl_mg_dup(pTHX_ MAGIC *mg)
d8731 14
a8744 2
	if (mg->mg_type == 'r') {
	    nmg->mg_obj	= (SV*)re_dup((REGEXP*)mg->mg_obj);
d8748 2
a8749 2
			      ? sv_dup_inc(mg->mg_obj)
			      : sv_dup(mg->mg_obj);
d8753 2
a8754 2
	if (mg->mg_ptr && mg->mg_type != 'g') {
	    if (mg->mg_len >= 0) {
d8756 3
a8758 1
		if (mg->mg_type == 'c' && AMT_AMAGIC((AMT*)mg->mg_ptr)) {
d8763 1
a8763 1
			namtp->table[i] = cv_dup_inc(amtp->table[i]);
d8768 4
a8771 1
		nmg->mg_ptr	= (char*)sv_dup_inc((SV*)mg->mg_ptr);
d8778 2
d8791 2
d8807 2
a8823 1
	    tbl->tbl_items++;
d8837 2
d8869 2
d8905 2
d8922 93
d9016 1
a9016 1
Perl_sv_dup(pTHX_ SV *sstr)
d9056 1
a9056 1
	SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
d9062 1
a9062 6
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9069 1
a9069 6
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9077 1
a9077 6
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9085 3
a9087 8
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9095 3
a9097 8
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9108 3
a9110 8
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9113 1
a9113 1
	LvTARG(dstr)	= sv_dup_inc(LvTARG(sstr));
d9117 13
d9135 3
a9137 8
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d9140 1
a9140 1
	GvSTASH(dstr)	= hv_dup_inc(GvSTASH(sstr));
d9142 1
a9142 1
	GvGP(dstr)	= gp_dup(GvGP(sstr));
d9151 4
a9154 9
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	IoIFP(dstr)	= fp_dup(IoIFP(sstr), IoTYPE(sstr));
d9158 1
a9158 1
	    IoOFP(dstr)	= fp_dup(IoOFP(sstr), IoTYPE(sstr));
d9169 1
a9169 1
	IoTOP_GV(dstr)		= gv_dup(IoTOP_GV(sstr));
d9171 1
a9171 1
	IoFMT_GV(dstr)		= gv_dup(IoFMT_GV(sstr));
d9173 1
a9173 1
	IoBOTTOM_GV(dstr)	= gv_dup(IoBOTTOM_GV(sstr));
d9184 3
a9186 3
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	AvARYLEN((AV*)dstr) = sv_dup_inc(AvARYLEN((AV*)sstr));
d9199 1
a9199 1
		    *dst_ary++ = sv_dup_inc(*src_ary++);
d9203 1
a9203 1
		    *dst_ary++ = sv_dup(*src_ary++);
d9221 2
a9222 2
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
d9232 2
a9233 1
						    !!HvSHAREKEYS(sstr));
d9236 2
a9237 1
	    dxhv->xhv_eiter = he_dup(sxhv->xhv_eiter, !!HvSHAREKEYS(sstr));
d9245 3
d9256 1
a9256 1
dup_pvcv:
d9261 4
a9264 7
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	CvSTASH(dstr)	= hv_dup(CvSTASH(sstr));/* NOTE: not refcounted */
d9269 11
a9279 2
	CvGV(dstr)	= gv_dup(CvGV(sstr));
	CvDEPTH(dstr)	= CvDEPTH(sstr);
d9283 1
a9283 1
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr));
d9288 1
a9288 1
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr));
d9290 1
a9290 1
	    CvOUTSIDE(dstr)	= cv_dup_inc(CvOUTSIDE(sstr));
d9292 1
a9292 1
	    CvOUTSIDE(dstr)	= cv_dup(CvOUTSIDE(sstr));
d9294 1
d9297 1
a9297 1
	Perl_croak(aTHX_ "Bizarre SvTYPE [%d]", SvTYPE(sstr));
d9305 3
a9307 1
}
d9310 1
a9310 1
Perl_cx_dup(pTHX_ PERL_CONTEXT *cxs, I32 ix, I32 max)
d9344 2
a9345 2
					   ? cv_dup_inc(cx->blk_sub.cv)
					   : cv_dup(cx->blk_sub.cv));
d9347 1
a9347 1
					   ? av_dup_inc(cx->blk_sub.argarray)
d9349 1
a9349 1
		ncx->blk_sub.savearray	= av_dup_inc(cx->blk_sub.savearray);
d9357 1
a9357 1
		ncx->blk_eval.old_namesv = sv_dup_inc(cx->blk_eval.old_namesv);
d9359 1
a9359 1
		ncx->blk_eval.cur_text	= sv_dup(cx->blk_eval.cur_text);
d9369 1
a9369 1
					   : gv_dup((GV*)cx->blk_loop.iterdata));
d9373 3
a9375 3
		ncx->blk_loop.itersave	= sv_dup_inc(cx->blk_loop.itersave);
		ncx->blk_loop.iterlval	= sv_dup_inc(cx->blk_loop.iterlval);
		ncx->blk_loop.iterary	= av_dup_inc(cx->blk_loop.iterary);
d9380 3
a9382 3
		ncx->blk_sub.cv		= cv_dup(cx->blk_sub.cv);
		ncx->blk_sub.gv		= gv_dup(cx->blk_sub.gv);
		ncx->blk_sub.dfoutgv	= gv_dup_inc(cx->blk_sub.dfoutgv);
d9395 2
d9398 1
a9398 1
Perl_si_dup(pTHX_ PERL_SI *si)
d9414 1
a9414 1
    nsi->si_stack	= av_dup_inc(si->si_stack);
d9417 1
a9417 1
    nsi->si_cxstack	= cx_dup(si->si_cxstack, si->si_cxix, si->si_cxmax);
d9419 2
a9420 2
    nsi->si_prev	= si_dup(si->si_prev);
    nsi->si_next	= si_dup(si->si_next);
d9444 4
d9463 2
a9464 2
	ret = (void*)(((char*)aTHXo) + (((char*)v) - (char*)proto_perl));
    else
d9466 1
d9471 2
d9474 1
a9474 1
Perl_ss_dup(pTHX_ PerlInterpreter *proto_perl)
d9490 1
a9490 1
    char *c;
d9492 1
a9492 1
    void (*dxptr) (pTHXo_ void*);
d9503 1
a9503 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9505 1
a9505 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9509 1
a9509 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9511 1
a9511 1
	    TOPPTR(nss,ix) = gv_dup_inc(gv);
d9519 6
d9528 1
a9528 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9534 1
a9534 1
	    TOPPTR(nss,ix) = av_dup_inc(av);
d9536 1
a9536 1
	    TOPPTR(nss,ix) = gv_dup(gv);
d9540 1
a9540 1
	    TOPPTR(nss,ix) = hv_dup_inc(hv);
d9542 1
a9542 1
	    TOPPTR(nss,ix) = gv_dup(gv);
d9574 1
a9574 1
	    TOPPTR(nss,ix) = sv_dup(sv);
d9592 1
a9592 1
	    TOPPTR(nss,ix) = hv_dup(hv);
d9598 1
a9598 1
	    TOPPTR(nss,ix) = av_dup(av);
d9602 1
a9602 1
	    TOPPTR(nss,ix) = gv_dup(gv);
d9606 1
a9606 1
	    TOPPTR(nss,ix) = gp = gp_dup(gp);
d9609 1
a9609 1
	    TOPPTR(nss,ix) = gv_dup_inc(c);
d9620 1
a9620 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9655 1
a9655 1
	    TOPPTR(nss,ix) = hv_dup_inc(hv);
d9671 1
a9671 1
	    TOPDXPTR(nss,ix) = (void (*)(pTHXo_ void*))any_dup((void *)dxptr, proto_perl);
d9685 1
a9685 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9689 1
a9689 1
	    TOPPTR(nss,ix) = av_dup_inc(av);
d9693 1
a9693 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9695 1
a9695 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
d9697 1
a9697 1
	    TOPPTR(nss,ix) = hv_dup_inc(hv);
d9709 1
a9709 1
	    TOPPTR(nss,ix) = av_dup(av);
d9717 1
a9717 1
	    TOPPTR(nss,ix) = sv_dup(sv);
d9727 11
a9737 3
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif
d9742 4
a9745 3
#ifdef PERL_OBJECT
    CPerlObj *pPerl = (CPerlObj*)proto_perl;
#endif
d9747 4
a9750 2
#ifdef PERL_IMPLICIT_SYS
    return perl_clone_using(proto_perl, flags,
d9775 3
a9777 5
#  ifdef PERL_OBJECT
    CPerlObj *pPerl = new(ipM) CPerlObj(ipM, ipMS, ipMP, ipE, ipStd, ipLIO,
					ipD, ipS, ipP);
    PERL_SET_THX(pPerl);
#  else		/* !PERL_OBJECT */
d9781 2
a9782 2
#    ifdef DEBUGGING
    memset(my_perl, 0xab, sizeof(PerlInterpreter));
d9787 3
a9789 1
#    else	/* !DEBUGGING */
d9791 1
a9791 1
#    endif	/* DEBUGGING */
a9802 1
#  endif	/* PERL_OBJECT */
d9805 2
d9810 2
d9813 1
a9813 1
    memset(my_perl, 0xab, sizeof(PerlInterpreter));
d9818 2
d9824 2
d9863 4
a9875 3
#ifdef PERL_OBJECT
    SvUPGRADE(&PL_sv_no, SVt_PVNV);
#else
a9876 1
#endif
a9884 3
#ifdef PERL_OBJECT
    SvUPGRADE(&PL_sv_yes, SVt_PVNV);
#else
a9885 1
#endif
d9894 1
a9894 1
    /* create shared string table */
d9900 9
a9908 3
    PL_compiling		= proto_perl->Icompiling;
    PL_compiling.cop_stashpv	= SAVEPV(PL_compiling.cop_stashpv);
    PL_compiling.cop_file	= SAVEPV(PL_compiling.cop_file);
d9911 3
a9913 1
	PL_compiling.cop_warnings = sv_dup_inc(PL_compiling.cop_warnings);
d9924 11
a9934 3
    PL_envgv		= gv_dup(proto_perl->Ienvgv);
    PL_incgv		= gv_dup(proto_perl->Iincgv);
    PL_hintgv		= gv_dup(proto_perl->Ihintgv);
d9936 2
a9937 2
    PL_diehook		= sv_dup_inc(proto_perl->Idiehook);
    PL_warnhook		= sv_dup_inc(proto_perl->Iwarnhook);
d9941 1
a9941 1
    PL_patchlevel	= sv_dup_inc(proto_perl->Ipatchlevel);
d9956 1
a9956 1
    PL_e_script		= sv_dup_inc(proto_perl->Ie_script);
d9959 1
d9964 1
a9964 1
    PL_formfeed		= sv_dup(proto_perl->Iformfeed);
d9972 26
d10000 6
a10005 6
    PL_stdingv		= gv_dup(proto_perl->Istdingv);
    PL_stderrgv		= gv_dup(proto_perl->Istderrgv);
    PL_defgv		= gv_dup(proto_perl->Idefgv);
    PL_argvgv		= gv_dup(proto_perl->Iargvgv);
    PL_argvoutgv	= gv_dup(proto_perl->Iargvoutgv);
    PL_argvout_stack	= av_dup_inc(proto_perl->Iargvout_stack);
d10008 1
a10008 1
    PL_replgv		= gv_dup(proto_perl->Ireplgv);
d10011 1
a10011 1
    PL_errgv		= gv_dup(proto_perl->Ierrgv);
d10014 8
a10021 8
    PL_DBgv		= gv_dup(proto_perl->IDBgv);
    PL_DBline		= gv_dup(proto_perl->IDBline);
    PL_DBsub		= gv_dup(proto_perl->IDBsub);
    PL_DBsingle		= sv_dup(proto_perl->IDBsingle);
    PL_DBtrace		= sv_dup(proto_perl->IDBtrace);
    PL_DBsignal		= sv_dup(proto_perl->IDBsignal);
    PL_lineary		= av_dup(proto_perl->Ilineary);
    PL_dbargs		= av_dup(proto_perl->Idbargs);
d10024 12
a10035 10
    PL_defstash		= hv_dup_inc(proto_perl->Tdefstash);
    PL_curstash		= hv_dup(proto_perl->Tcurstash);
    PL_debstash		= hv_dup(proto_perl->Idebstash);
    PL_globalstash	= hv_dup(proto_perl->Iglobalstash);
    PL_curstname	= sv_dup_inc(proto_perl->Icurstname);

    PL_beginav		= av_dup_inc(proto_perl->Ibeginav);
    PL_endav		= av_dup_inc(proto_perl->Iendav);
    PL_checkav		= av_dup_inc(proto_perl->Icheckav);
    PL_initav		= av_dup_inc(proto_perl->Iinitav);
d10043 1
a10043 1
    PL_fdpid		= av_dup_inc(proto_perl->Ifdpid);
d10054 1
a10054 1
    PL_main_cv		= cv_dup_inc(proto_perl->Imain_cv);
d10071 1
a10071 1
    PL_preambleav	= av_dup_inc(proto_perl->Ipreambleav);
d10076 1
a10076 2
    PL_orslen		= proto_perl->Iorslen;
    PL_ors		= SAVEPVN(proto_perl->Iors, PL_orslen);
d10087 3
a10089 1
    PL_modglobal	= hv_dup_inc(proto_perl->Imodglobal);
d10092 1
a10092 1
    PL_rsfp		= fp_dup(proto_perl->Irsfp, '<');
d10094 1
a10094 1
    PL_rsfp_filters	= av_dup_inc(proto_perl->Irsfp_filters);
d10096 3
a10098 3
    PL_compcv			= cv_dup(proto_perl->Icompcv);
    PL_comppad			= av_dup(proto_perl->Icomppad);
    PL_comppad_name		= av_dup(proto_perl->Icomppad_name);
d10110 1
a10110 1
    PL_DBcv		= cv_dup(proto_perl->IDBcv);
d10128 1
a10128 1
    PL_sh_path		= SAVEPV(proto_perl->Ish_path);
d10138 1
a10138 1
    PL_cshname		= SAVEPVN(proto_perl->Icshname, PL_cshlen);
d10147 2
a10148 2
    PL_lex_stuff	= sv_dup_inc(proto_perl->Ilex_stuff);
    PL_lex_repl		= sv_dup_inc(proto_perl->Ilex_repl);
d10163 22
a10184 7
    PL_linestr		= sv_dup_inc(proto_perl->Ilinestr);
    i = proto_perl->Ibufptr - SvPVX(proto_perl->Ilinestr);
    PL_bufptr		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    i = proto_perl->Ioldbufptr - SvPVX(proto_perl->Ilinestr);
    PL_oldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    i = proto_perl->Ioldoldbufptr - SvPVX(proto_perl->Ilinestr);
    PL_oldoldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
a10185 2
    i = proto_perl->Ilinestart - SvPVX(proto_perl->Ilinestr);
    PL_linestart	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
d10198 1
a10198 1
    PL_subname		= sv_dup_inc(proto_perl->Isubname);
d10206 13
a10218 5
    i = proto_perl->Ilast_uni - SvPVX(proto_perl->Ilinestr);
    PL_last_uni		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    i = proto_perl->Ilast_lop - SvPVX(proto_perl->Ilinestr);
    PL_last_lop		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    PL_last_lop_op	= proto_perl->Ilast_lop_op;
d10220 1
a10220 1
    PL_in_my_stash	= hv_dup(proto_perl->Iin_my_stash);
d10241 1
a10241 1
    PL_numeric_radix_sv	= sv_dup_inc(proto_perl->Inumeric_radix_sv);
d10245 20
a10264 17
    PL_utf8_alnum	= sv_dup_inc(proto_perl->Iutf8_alnum);
    PL_utf8_alnumc	= sv_dup_inc(proto_perl->Iutf8_alnumc);
    PL_utf8_ascii	= sv_dup_inc(proto_perl->Iutf8_ascii);
    PL_utf8_alpha	= sv_dup_inc(proto_perl->Iutf8_alpha);
    PL_utf8_space	= sv_dup_inc(proto_perl->Iutf8_space);
    PL_utf8_cntrl	= sv_dup_inc(proto_perl->Iutf8_cntrl);
    PL_utf8_graph	= sv_dup_inc(proto_perl->Iutf8_graph);
    PL_utf8_digit	= sv_dup_inc(proto_perl->Iutf8_digit);
    PL_utf8_upper	= sv_dup_inc(proto_perl->Iutf8_upper);
    PL_utf8_lower	= sv_dup_inc(proto_perl->Iutf8_lower);
    PL_utf8_print	= sv_dup_inc(proto_perl->Iutf8_print);
    PL_utf8_punct	= sv_dup_inc(proto_perl->Iutf8_punct);
    PL_utf8_xdigit	= sv_dup_inc(proto_perl->Iutf8_xdigit);
    PL_utf8_mark	= sv_dup_inc(proto_perl->Iutf8_mark);
    PL_utf8_toupper	= sv_dup_inc(proto_perl->Iutf8_toupper);
    PL_utf8_totitle	= sv_dup_inc(proto_perl->Iutf8_totitle);
    PL_utf8_tolower	= sv_dup_inc(proto_perl->Iutf8_tolower);
d10286 7
d10294 5
a10298 6
	int sig_num[] = { SIG_NUM };
	Newz(0, PL_psig_ptr, sizeof(sig_num)/sizeof(*sig_num), SV*);
	Newz(0, PL_psig_name, sizeof(sig_num)/sizeof(*sig_num), SV*);
	for (i = 1; PL_sig_name[i]; i++) {
	    PL_psig_ptr[i] = sv_dup_inc(proto_perl->Ipsig_ptr[i]);
	    PL_psig_name[i] = sv_dup_inc(proto_perl->Ipsig_name[i]);
d10316 1
a10316 1
	    PL_tmps_stack[i]	= sv_dup_inc(proto_perl->Ttmps_stack[i]);
d10342 1
a10342 1
	Copy(proto_perl->Tretstack, PL_retstack, PL_retstack_ix, I32);
d10345 1
a10345 1
	PL_curstackinfo		= si_dup(proto_perl->Tcurstackinfo);
d10348 2
a10349 2
	PL_curstack		= av_dup(proto_perl->Tcurstack);
	PL_mainstack		= av_dup(proto_perl->Tmainstack);
d10362 1
a10362 1
	PL_savestack		= ss_dup(proto_perl);
d10380 2
a10381 2
    PL_statgv		= gv_dup(proto_perl->Tstatgv);
    PL_statname		= sv_dup_inc(proto_perl->Tstatname);
d10388 4
a10391 6
    PL_nrs		= sv_dup_inc(proto_perl->Tnrs);
    PL_rs		= sv_dup_inc(proto_perl->Trs);
    PL_last_in_gv	= gv_dup(proto_perl->Tlast_in_gv);
    PL_ofslen		= proto_perl->Tofslen;
    PL_ofs		= SAVEPVN(proto_perl->Tofs, PL_ofslen);
    PL_defoutgv		= gv_dup_inc(proto_perl->Tdefoutgv);
d10393 3
a10395 3
    PL_toptarget	= sv_dup_inc(proto_perl->Ttoptarget);
    PL_bodytarget	= sv_dup_inc(proto_perl->Tbodytarget);
    PL_formtarget	= sv_dup(proto_perl->Tformtarget);
d10406 1
a10406 1
    PL_errors		= sv_dup_inc(proto_perl->Terrors);
d10415 3
a10417 3
    PL_sortstash	= hv_dup(proto_perl->Tsortstash);
    PL_firstgv		= gv_dup(proto_perl->Tfirstgv);
    PL_secondgv		= gv_dup(proto_perl->Tsecondgv);
a10456 1
    PL_regprev		= '\n';
d10471 1
d10493 3
d10501 21
a10521 3
#ifdef PERL_OBJECT
    return (PerlInterpreter*)pPerl;
#else
a10522 1
#endif
d10525 1
a10525 1
#else	/* !USE_ITHREADS */
d10527 2
a10528 3
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif
d10530 1
a10530 1
#endif /* USE_ITHREADS */
d10532 3
a10534 8
static void
do_report_used(pTHXo_ SV *sv)
{
    if (SvTYPE(sv) != SVTYPEMASK) {
	PerlIO_printf(Perl_debug_log, "****\n");
	sv_dump(sv);
    }
}
d10536 4
a10539 4
static void
do_clean_objs(pTHXo_ SV *sv)
{
    SV* rv;
d10541 1
a10541 12
    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
	DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(sv));)
	if (SvWEAKREF(sv)) {
	    sv_del_backref(sv);
	    SvWEAKREF_off(sv);
	    SvRV(sv) = 0;
	} else {
	    SvROK_off(sv);
	    SvRV(sv) = 0;
	    SvREFCNT_dec(rv);
	}
    }
d10543 1
a10543 2
    /* XXX Might want to check arrays, etc. */
}
d10545 2
a10546 3
#ifndef DISABLE_DESTRUCTOR_KLUDGE
static void
do_clean_named_objs(pTHXo_ SV *sv)
d10548 36
a10583 10
    if (SvTYPE(sv) == SVt_PVGV && GvGP(sv)) {
	if ( SvOBJECT(GvSV(sv)) ||
	     (GvAV(sv) && SvOBJECT(GvAV(sv))) ||
	     (GvHV(sv) && SvOBJECT(GvHV(sv))) ||
	     (GvIO(sv) && SvOBJECT(GvIO(sv))) ||
	     (GvCV(sv) && SvOBJECT(GvCV(sv))) )
	{
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning named glob object:\n "), sv_dump(sv));)
	    SvREFCNT_dec(sv);
	}
d10585 1
a10586 1
#endif
d10588 1
a10588 7
static void
do_clean_all(pTHXo_ SV *sv)
{
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops: SV at 0x%"UVxf"\n", PTR2UV(sv)) );)
    SvFLAGS(sv) |= SVf_BREAK;
    SvREFCNT_dec(sv);
}
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d150 1
a150 1
STATIC void
d156 1
d161 1
a161 1
	    if (SvTYPE(sv) != SVTYPEMASK)
d163 2
d167 1
d188 1
a188 1
void
d191 1
d193 1
a193 1
    visit(do_clean_all);
d195 1
d203 1
d217 78
d388 6
a393 1
    New(711, xnv, 1008/sizeof(NV), NV);
d431 6
a436 2
    New(712, PL_xrv_root, 1008/sizeof(XRV), XRV);
    xrv = PL_xrv_root;
d438 2
d474 4
a477 2
    New(713, PL_xpv_root, 1008/sizeof(XPV), XPV);
    xpv = PL_xpv_root;
d479 1
a508 1

d514 4
a517 2
    New(714, PL_xpviv_root, 1008/sizeof(XPVIV), XPVIV);
    xpviv = PL_xpviv_root;
d519 1
a526 1

a548 1

d554 4
a557 2
    New(715, PL_xpvnv_root, 1008/sizeof(XPVNV), XPVNV);
    xpvnv = PL_xpvnv_root;
d559 1
a566 2


a588 1

d594 4
a597 2
    New(716, PL_xpvcv_root, 1008/sizeof(XPVCV), XPVCV);
    xpvcv = PL_xpvcv_root;
d599 1
a606 2


a628 1

d634 4
a637 2
    New(717, PL_xpvav_root, 1008/sizeof(XPVAV), XPVAV);
    xpvav = PL_xpvav_root;
d639 1
a646 2


a668 1

d674 4
a677 2
    New(718, PL_xpvhv_root, 1008/sizeof(XPVHV), XPVHV);
    xpvhv = PL_xpvhv_root;
d679 1
a686 1

a708 1

d714 4
a717 2
    New(719, PL_xpvmg_root, 1008/sizeof(XPVMG), XPVMG);
    xpvmg = PL_xpvmg_root;
d719 1
a726 2


a748 1

d754 4
a757 2
    New(720, PL_xpvlv_root, 1008/sizeof(XPVLV), XPVLV);
    xpvlv = PL_xpvlv_root;
d759 1
a766 1

a788 1

d794 4
a797 2
    New(721, PL_xpvbm_root, 1008/sizeof(XPVBM), XPVBM);
    xpvbm = PL_xpvbm_root;
d799 1
d1290 2
a1291 5
	{
	    dTHR;
	    Perl_croak(aTHX_ "Can't coerce %s to integer in %s", sv_reftype(sv,0),
		  PL_op_desc[PL_op->op_type]);
	}
d1375 2
a1376 5
	{
	    dTHR;
	    Perl_croak(aTHX_ "Can't coerce %s to number in %s", sv_reftype(sv,0),
		  PL_op_name[PL_op->op_type]);
	}
a1400 1
    dTHR;
d1459 1
a1479 1
		dTHR;
d1489 2
a1490 1
	  if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv, numer)))
a1494 1
	    dTHR;
d1570 3
a1572 4
	else if (numtype) {
	    /* The NV may be reconstructed from IV - safe to cache IV,
	       which may be calculated by atol(). */
	    if (SvTYPE(sv) == SVt_PV)
d1576 1
a1576 9
	}
	else {				/* Not a number.  Cache 0. */
	    dTHR;

	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
	    SvIVX(sv) = 0;
	    (void)SvIOK_on(sv);
	    if (ckWARN(WARN_NUMERIC))
a1580 1
	dTHR;
a1607 1
		dTHR;
d1617 2
a1618 1
	  if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv, numer)))
a1622 1
	    dTHR;
a1721 2
	    dTHR;

d1724 2
a1727 2
	    (void)SvIOK_on(sv);
	    (void)SvIsUV_on(sv);
a1733 1
	    dTHR;
a1757 1
	    dTHR;
a1769 1
		dTHR;
d1779 2
a1780 1
	  if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)))
a1784 1
	    dTHR;
d1797 1
a1797 1
	    RESTORE_NUMERIC_STANDARD();
d1805 1
a1805 1
	    RESTORE_NUMERIC_STANDARD();
a1819 1
	dTHR;
a1824 1
	dTHR;
d1835 1
a1835 1
	RESTORE_NUMERIC_STANDARD();
d1842 1
a1842 1
	RESTORE_NUMERIC_STANDARD();
a1859 1
	dTHR;
a1876 1
	dTHR;
d1893 1
d1914 1
d1916 3
d1947 1
a1947 1
    /* next must be digit or the radix separator */
d1959 2
a1960 2
#ifdef USE_LOCALE_NUMERIC 
	    || IS_NUMERIC_RADIX(*s)
d1963 6
a1968 1
	    s++;
d1975 2
a1976 2
#ifdef USE_LOCALE_NUMERIC 
	    || IS_NUMERIC_RADIX(*s)
d1979 6
a1984 1
        s++;
d1995 11
d2009 7
a2015 6
    /* we can have an optional exponent part */
    if (*s == 'e' || *s == 'E') {
	numtype &= ~IS_NUMBER_NEG;
	numtype |= IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV;
	s++;
	if (*s == '+' || *s == '-')
d2017 10
a2026 7
        if (isDIGIT(*s)) {
            do {
                s++;
            } while (isDIGIT(*s));
        }
        else
            return 0;
a2103 1
		dTHR;
d2114 2
a2115 1
	    if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,string)))
a2129 1
			dTHR;
a2196 1
	    dTHR;
d2205 1
a2205 1
	/* I tried changing this for to be 64-bit-aware and
d2210 2
a2211 1
	SvGROW(sv, 28);
a2258 1
	dTHR;
a2260 1
	{
a2261 1
	}
d2339 1
a2339 1
    return sv_2pv(sv,lp);
a2351 1
	dTHR;
d2353 2
a2354 1
	if (SvAMAGIC(sv) && (tmpsv = AMG_CALLun(sv,bool_)))
d2380 8
d2391 2
a2392 2
    int hicount;
    char *c;
d2397 3
a2399 2
    /* This function could be much more efficient if we had a FLAG
     * to signal if there are any hibit chars in the string
d2401 10
a2410 24
    hicount = 0;
    for (c = SvPVX(sv); c < SvEND(sv); c++) {
	if (*c & 0x80)
	    hicount++;
    }

    if (hicount) {
	char *src, *dst;
	SvGROW(sv, SvCUR(sv) + hicount + 1);

	src = SvEND(sv) - 1;
	SvCUR_set(sv, SvCUR(sv) + hicount);
	dst = SvEND(sv) - 1;

	while (src < dst) {
	    if (*src & 0x80) {
		dst--;
		uv_to_utf8((U8*)dst, (U8)*src--);
		dst--;
	    }
	    else {
		*dst-- = *src--;
	    }
	}
d2412 10
d2426 11
d2441 16
a2456 14
        char *c = SvPVX(sv);
        char *first_hi = 0;
        /* need to figure out if this is possible at all first */
        while (c < SvEND(sv)) {
            if (*c & 0x80) {
                I32 len;
                UV uv = utf8_to_uv((U8*)c, &len);
                if (uv >= 256) {
		    if (fail_ok)
			return FALSE;
		    else {
			/* XXX might want to make a callback here instead */
			Perl_croak(aTHX_ "Big byte");
		    }
d2458 5
a2462 8
                if (!first_hi)
                    first_hi = c;
                c += len;
            }
            else {
                c++;
            }
        }
a2463 18
        if (first_hi) {
            char *src = first_hi;
            char *dst = first_hi;
            while (src < SvEND(sv)) {
                if (*src & 0x80) {
                    I32 len;
                    U8 u = (U8)utf8_to_uv((U8*)src, &len);
                    *dst++ = u;
                    src += len;
                }
                else {
                    *dst++ = *src++;
                }
            }
            SvCUR_set(sv, dst - SvPVX(sv));
        }
        SvUTF8_off(sv);
    }
d2467 9
d2488 1
d2497 8
a2504 14
        while (c < SvEND(sv)) {
            if (*c & 0x80) {
                I32 len;
                (void)utf8_to_uv((U8*)c, &len);
                if (len == 1) {
                    /* bad utf8 */
                    return FALSE;
                }
                c += len;
                has_utf = TRUE;
            }
            else {
                c++;
            }
a2505 3

        if (has_utf)
            SvUTF8_on(sv);
a2529 1
    dTHR;
d2572 2
a2573 1
	    SvTAINT(dstr);
d2593 2
a2594 1
	    SvTAINT(dstr);
d2648 1
a2648 1
		sv_magic(dstr, dstr, '*', name, len);
d2663 2
a2664 1
	    SvTAINT(dstr);
d2810 2
a2811 1
		SvTAINT(dstr);
d2831 1
a2831 1
	    if (SvIsUV(sstr))
a2862 4
	    if (SvUTF8(sstr))
		SvUTF8_on(dstr);
	    else
		SvUTF8_off(dstr);
d2865 1
a2865 1
	    (void)SvOK_off(sstr);
d2880 1
a2880 1
	if (DO_UTF8(sstr))
d2890 1
a2890 1
	    if (SvIsUV(sstr))
d2897 1
a2897 1
	if (SvIOK(sstr)) {
d2901 1
a2901 1
	    if (SvIsUV(sstr))
d2908 1
a2908 1
	if (SvIsUV(sstr))
d2919 2
a2920 1
    SvTAINT(dstr);
d2951 1
a2951 2
    assert(len >= 0);  /* STRLEN is probably unsigned, so this may
			  elicit a warning, but it won't hurt. */
d2957 5
a3085 1
	dTHR;
d3183 3
a3185 2
Concatenates the string from SV C<ssv> onto the end of the string in SV
C<dsv>.  Handles 'get' magic, but not 'set' magic.  See C<sv_catsv_mg>.
d3187 1
a3187 2
=cut
*/
d3192 2
a3193 2
    char *s;
    STRLEN len;
d3196 23
a3218 6
    if ((s = SvPV(sstr, len))) {
	if (SvUTF8(sstr))
	    sv_utf8_upgrade(dstr);
	sv_catpvn(dstr,s,len);
	if (SvUTF8(sstr))
	    SvUTF8_on(dstr);
a3309 1
	dTHR;
d3325 1
d3327 10
a3336 2
    SvMAGIC(sv) = mg;
    if (!obj || obj == sv || how == '#' || how == 'r')
d3338 1
a3339 1
	dTHR;
d3469 8
d3511 8
a3527 1
	dTHR;
d3539 2
a3540 2
STATIC void
S_sv_add_backref(pTHX_ SV *tsv, SV *sv)
d3554 2
a3555 2
STATIC void 
S_sv_del_backref(pTHX_ SV *sv)
d3598 1
d3669 7
a3675 1
/* make sv point to what nstr did */
a3679 1
    dTHR;
d3703 9
a3719 1
	dTHR;
d3721 1
a3721 1
	    djSP;
d3904 8
a3914 1
    dTHR;
d3979 9
a3990 4
    U8 *s;
    U8 *send;
    STRLEN len;

d3996 1
a3996 1
	len = mg_length(sv);
d3999 5
a4003 6
	s = (U8*)SvPV(sv, len);
    send = s + len;
    len = 0;
    while (s < send) {
	s += UTF8SKIP(s);
	len++;
a4004 1
    return len;
d4050 1
a4050 1
	Perl_croak(aTHX_ "panic: bad byte offset");
d4054 8
a4061 8
	s += UTF8SKIP(s);
	++len;
    }
    if (s != send) {
        dTHR;
	if (ckWARN_d(WARN_UTF8))    
	    Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-8 character");
	--len;
d4077 1
a4077 1
Perl_sv_eq(pTHX_ register SV *str1, register SV *str2)
d4083 3
d4087 1
a4087 1
    if (!str1) {
d4092 1
a4092 1
	pv1 = SvPV(str1, cur1);
d4094 4
a4097 2
    if (!str2)
	return !cur1;
d4099 14
a4112 1
	pv2 = SvPV(str2, cur2);
d4114 12
a4125 2
    if (cur1 != cur2)
	return 0;
d4127 1
a4127 1
    return memEQ(pv1, pv2, cur1);
d4141 1
a4141 1
Perl_sv_cmp(pTHX_ register SV *str1, register SV *str2)
d4145 3
a4147 1
    I32 retval;
d4149 3
a4151 2
    if (str1) {
        pv1 = SvPV(str1, cur1);
d4153 6
a4158 2
    else {
	cur1 = 0;
d4160 2
d4163 6
a4168 17
    if (str2) {
	if (SvPOK(str2)) {
	    if (SvPOK(str1) && SvUTF8(str1) != SvUTF8(str2) && !IN_BYTE) {
		/* must upgrade other to UTF8 first */
		if (SvUTF8(str1)) {
		    sv_utf8_upgrade(str2);
		}
		else {
		    sv_utf8_upgrade(str1);
		    /* refresh pointer and length */
		    pv1  = SvPVX(str1);
		    cur1 = SvCUR(str1);
		}
	    }
	    pv2  = SvPVX(str2);
	    cur2 = SvCUR(str2);
    	}
d4170 2
a4171 1
	    pv2 = sv_2pv(str2, &cur2);
d4174 15
a4188 2
    else {
	cur2 = 0;
d4191 4
a4194 2
    if (!cur1)
	return cur2 ? -1 : 0;
d4196 2
a4197 2
    if (!cur2)
	return 1;
d4199 2
a4200 1
    retval = memcmp((void*)pv1, (void*)pv2, cur1 < cur2 ? cur1 : cur2);
d4202 2
a4203 2
    if (retval)
	return retval < 0 ? -1 : 1;
d4205 2
a4206 5
    if (cur1 == cur2)
	return 0;
    else
	return cur1 < cur2 ? -1 : 1;
}
d4309 9
a4320 1
    dTHR;
d4356 1
d4363 7
a4369 1
    else
d4371 2
d4591 2
a4616 1
	    dTHR;
a4723 1
	    dTHR;
a4788 1
    dTHR;
a4809 1
    dTHR;
a4832 1
    dTHR;
a4997 1
    dTHR;
a5027 1
    dTHR;
d5110 1
a5110 1
#ifndef VMS  /* VMS has no environ array */
a5181 1
	    dTHR;
d5226 8
a5236 1
    dTHR;
d5311 8
a5331 1
	    dTHR;
d5390 9
d5406 8
a5510 1
    dTHR;
d5518 8
d5527 8
a5534 1
      sv_upgrade(rv, SVt_RV);
a5649 1
    dTHR;
a5971 1
    dTHR;
d6028 1
a6028 1
	U8 utf8buf[UTF8_MAXLEN];
a6103 11
		if (args)
		    vecsv = va_arg(*args, SV*);
		else if (svix < svmax)
		    vecsv = svargs[svix++];
		else {
		    vecstr = (U8*)"";
		    veclen = 0;
		    continue;
		}
		vecstr = (U8*)SvPVx(vecsv,veclen);
		utf = DO_UTF8(vecsv);
d6154 17
d6174 4
a6178 1
	case 'L':			/* Ld */
d6185 2
a6186 2
#ifdef HAS_QUAD
             if (*(q + 1) == 'l') {	/* lld */
d6283 2
d6302 1
a6302 1
		I32 ulen;
d6308 1
a6308 1
		    iv = (IV)utf8_to_uv(vecstr, &ulen);
d6331 1
a6331 1
		default:	iv = (int)iv; break;
d6383 1
a6383 1
		I32 ulen;
d6390 1
a6390 1
		    uv = utf8_to_uv(vecstr, &ulen);
d6413 1
a6413 1
		default:	uv = (unsigned)uv; break;
d6528 1
a6528 1
#ifdef USE_LONG_DOUBLE
d6530 6
a6535 3
		static char const my_prifldbl[] = PERL_PRIfldbl;
		char const *p = my_prifldbl + sizeof my_prifldbl - 3;
		while (p >= my_prifldbl) { *--eptr = *p--; }
d6557 4
a6560 5
	    {
		RESTORE_NUMERIC_STANDARD();
		(void)sprintf(PL_efloatbuf, eptr, nv);
		RESTORE_NUMERIC_LOCAL();
	    }
d6583 1
a6583 1
		sv_setuv(svargs[svix++], (UV)i);
d6767 2
a6768 2
    MAGIC *mgret = (MAGIC*)NULL;
    MAGIC *mgprev;
d6779 3
a6781 1
	if (!mgret)
a6782 2
	else
	    mgprev->mg_moremagic = nmg;
d6901 45
d7229 1
a7229 1
	CvGV(dstr)	= gv_dup_inc(CvGV(sstr));
d7240 4
a7243 1
	CvOUTSIDE(dstr)	= cv_dup_inc(CvOUTSIDE(sstr));
d7297 1
a7297 1
		ncx->blk_sub.savearray	= av_dup(cx->blk_sub.savearray);
d7452 6
d7551 1
d7644 8
d7745 1
d7747 1
d7749 1
d7751 1
d7753 1
d7755 1
d7757 1
d7759 1
d7761 1
d7763 1
d7765 1
d7767 1
d7881 1
a7881 1
    PL_argvout_stack	= av_dup(proto_perl->Iargvout_stack);
d8093 1
a8093 1
    PL_numeric_radix	= proto_perl->Inumeric_radix;
d8151 1
a8151 1
    if (flags & 1) {
d8209 1
d8338 5
d8374 9
a8382 3
	SvROK_off(sv);
	SvRV(sv) = 0;
	SvREFCNT_dec(rv);
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d15 1
d18 2
a19 21
#ifdef OVR_DBL_DIG
/* Use an overridden DBL_DIG */
# ifdef DBL_DIG
#  undef DBL_DIG
# endif
# define DBL_DIG OVR_DBL_DIG
#else
/* The following is all to get DBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert.
   (see config.h)
*/
#ifdef I_LIMITS
#include <limits.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif
#endif
d21 4
a24 2
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE) && !defined(__QNX__)
#  define FAST_SV_GETS
d26 1
a26 138

#ifdef PERL_OBJECT
#define FCALL this->*f
#define VTBL this->*vtbl

#else /* !PERL_OBJECT */

static IV asIV _((SV* sv));
static UV asUV _((SV* sv));
static SV *more_sv _((void));
static void more_xiv _((void));
static void more_xnv _((void));
static void more_xpv _((void));
static void more_xrv _((void));
static XPVIV *new_xiv _((void));
static XPVNV *new_xnv _((void));
static XPV *new_xpv _((void));
static XRV *new_xrv _((void));
static void del_xiv _((XPVIV* p));
static void del_xnv _((XPVNV* p));
static void del_xpv _((XPV* p));
static void del_xrv _((XRV* p));
static void sv_mortalgrow _((void));
static void sv_unglob _((SV* sv));
static void sv_check_thinkfirst _((SV *sv));

#ifndef PURIFY
static void *my_safemalloc(MEM_SIZE size);
#endif

typedef void (*SVFUNC) _((SV*));
#define VTBL *vtbl
#define FCALL *f

#endif /* PERL_OBJECT */

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) sv_check_thinkfirst(sv)

#ifdef PURIFY

#define new_SV(p)			\
    do {				\
	LOCK_SV_MUTEX;			\
	(p) = (SV*)safemalloc(sizeof(SV)); \
	reg_add(p);			\
	UNLOCK_SV_MUTEX;		\
    } while (0)

#define del_SV(p)			\
    do {				\
	LOCK_SV_MUTEX;			\
	reg_remove(p);			\
        Safefree((char*)(p));		\
	UNLOCK_SV_MUTEX;		\
    } while (0)

static SV **registry;
static I32 registry_size;

#define REGHASH(sv,size)  ((((U32)(sv)) >> 2) % (size))

#define REG_REPLACE(sv,a,b) \
    do {				\
	void* p = sv->sv_any;		\
	I32 h = REGHASH(sv, registry_size);	\
	I32 i = h;			\
	while (registry[i] != (a)) {	\
	    if (++i >= registry_size)	\
		i = 0;			\
	    if (i == h)			\
		die("SV registry bug");	\
	}				\
	registry[i] = (b);		\
    } while (0)

#define REG_ADD(sv)	REG_REPLACE(sv,Nullsv,sv)
#define REG_REMOVE(sv)	REG_REPLACE(sv,sv,Nullsv)

static void
reg_add(sv)
SV* sv;
{
    if (PL_sv_count >= (registry_size >> 1))
    {
	SV **oldreg = registry;
	I32 oldsize = registry_size;

	registry_size = registry_size ? ((registry_size << 2) + 1) : 2037;
	Newz(707, registry, registry_size, SV*);

	if (oldreg) {
	    I32 i;

	    for (i = 0; i < oldsize; ++i) {
		SV* oldsv = oldreg[i];
		if (oldsv)
		    REG_ADD(oldsv);
	    }
	    Safefree(oldreg);
	}
    }

    REG_ADD(sv);
    ++PL_sv_count;
}

static void
reg_remove(sv)
SV* sv;
{
    REG_REMOVE(sv);
    --PL_sv_count;
}

static void
visit(f)
SVFUNC f;
{
    I32 i;

    for (i = 0; i < registry_size; ++i) {
	SV* sv = registry[i];
	if (sv && SvTYPE(sv) != SVTYPEMASK)
	    (*f)(sv);
    }
}

void
sv_add_arena(ptr, size, flags)
char* ptr;
U32 size;
U32 flags;
{
    if (!(flags & SVf_FAKE))
	Safefree(ptr);
}

#else /* ! PURIFY */
d32 7
a38 7
#define plant_SV(p)			\
    do {				\
	SvANY(p) = (void *)PL_sv_root;	\
	SvFLAGS(p) = SVTYPEMASK;	\
	PL_sv_root = (p);			\
	--PL_sv_count;			\
    } while (0)
d41 19
a59 15
#define uproot_SV(p)			\
    do {				\
	(p) = PL_sv_root;			\
	PL_sv_root = (SV*)SvANY(p);	\
	++PL_sv_count;			\
    } while (0)

#define new_SV(p)	do {	\
	LOCK_SV_MUTEX;		\
	if (PL_sv_root)		\
	    uproot_SV(p);	\
	else			\
	    (p) = more_sv();	\
	UNLOCK_SV_MUTEX;	\
    } while (0)
d63 9
a71 8
#define del_SV(p)	do {	\
	LOCK_SV_MUTEX;		\
	if (PL_debug & 32768)	\
	    del_sv(p);		\
	else			\
	    plant_SV(p);	\
	UNLOCK_SV_MUTEX;	\
    } while (0)
d74 1
a74 1
del_sv(SV *p)
d88 4
a91 1
	    warn("Attempt to free non-arena SV: 0x%lx", (unsigned long)p);
d105 1
a105 1
sv_add_arena(char *ptr, U32 size, U32 flags)
d110 1
a110 1
    Zero(sva, size, char);
d133 1
a133 1
more_sv(void)
d151 1
a151 1
visit(SVFUNC f)
d161 1
a161 1
		(FCALL)(sv);
a165 12
#endif /* PURIFY */

STATIC void
do_report_used(SV *sv)
{
    if (SvTYPE(sv) != SVTYPEMASK) {
	/* XXX Perhaps this ought to go to Perl_debug_log, if DEBUGGING. */
	PerlIO_printf(PerlIO_stderr(), "****\n");
	sv_dump(sv);
    }
}

d167 1
a167 23
sv_report_used(void)
{
    visit(FUNC_NAME_TO_PTR(do_report_used));
}

STATIC void
do_clean_objs(SV *sv)
{
    SV* rv;

    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
	DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(sv));)
	SvROK_off(sv);
	SvRV(sv) = 0;
	SvREFCNT_dec(rv);
    }

    /* XXX Might want to check arrays, etc. */
}

#ifndef DISABLE_DESTRUCTOR_KLUDGE
STATIC void
do_clean_named_objs(SV *sv)
d169 1
a169 11
    if (SvTYPE(sv) == SVt_PVGV) {
	if ( SvOBJECT(GvSV(sv)) ||
	     GvAV(sv) && SvOBJECT(GvAV(sv)) ||
	     GvHV(sv) && SvOBJECT(GvHV(sv)) ||
	     GvIO(sv) && SvOBJECT(GvIO(sv)) ||
	     GvCV(sv) && SvOBJECT(GvCV(sv)) )
	{
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning named glob object:\n "), sv_dump(sv));)
	    SvREFCNT_dec(sv);
	}
    }
a170 1
#endif
d173 1
a173 1
sv_clean_objs(void)
d176 1
a176 1
    visit(FUNC_NAME_TO_PTR(do_clean_objs));
d179 1
a179 1
    visit(FUNC_NAME_TO_PTR(do_clean_named_objs));
a183 8
STATIC void
do_clean_all(SV *sv)
{
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops: SV at 0x%lx\n", sv) );)
    SvFLAGS(sv) |= SVf_BREAK;
    SvREFCNT_dec(sv);
}

d185 1
a185 1
sv_clean_all(void)
d188 1
a188 1
    visit(FUNC_NAME_TO_PTR(do_clean_all));
d193 1
a193 1
sv_free_arenas(void)
d218 10
d229 1
a229 1
new_xiv(void)
d245 1
a245 1
del_xiv(XPVIV *p)
d255 1
a255 1
more_xiv(void)
d276 1
a276 1
new_xnv(void)
d278 1
a278 1
    double* xnv;
d283 1
a283 1
    PL_xnv_root = *(double**)xnv;
d289 1
a289 1
del_xnv(XPVNV *p)
d291 1
a291 1
    double* xnv = (double*)((char*)(p) + STRUCT_OFFSET(XPVNV, xnv_nv));
d293 2
a294 2
     *(double**)xnv = PL_xnv_root;
     PL_xnv_root = xnv;
d299 1
a299 1
more_xnv(void)
d301 5
a305 5
    register double* xnv;
    register double* xnvend;
    New(711, xnv, 1008/sizeof(double), double);
    xnvend = &xnv[1008 / sizeof(double) - 1];
    xnv += (sizeof(XPVIV) - 1) / sizeof(double) + 1; /* fudge by sizeof XPVIV */
d308 1
a308 1
	*(double**)xnv = (double*)(xnv + 1);
d311 1
a311 1
    *(double**)xnv = 0;
d315 1
a315 1
new_xrv(void)
d328 1
a328 1
del_xrv(XRV *p)
d331 2
a332 2
     p->xrv_rv = (SV*)PL_xrv_root;
     PL_xrv_root = p;
d337 1
a337 1
more_xrv(void)
d352 1
a352 1
new_xpv(void)
d365 1
a365 1
del_xpv(XPV *p)
d368 2
a369 2
     p->xpv_pv = (char*)PL_xpv_root;
     PL_xpv_root = p;
d374 1
a374 1
more_xpv(void)
d388 22
a409 7
#ifdef PURIFY
#define new_XIV() (void*)safemalloc(sizeof(XPVIV))
#define del_XIV(p) Safefree((char*)p)
#else
#define new_XIV() (void*)new_xiv()
#define del_XIV(p) del_xiv((XPVIV*) p)
#endif
d411 14
a424 7
#ifdef PURIFY
#define new_XNV() (void*)safemalloc(sizeof(XPVNV))
#define del_XNV(p) Safefree((char*)p)
#else
#define new_XNV() (void*)new_xnv()
#define del_XNV(p) del_xnv((XPVNV*) p)
#endif
a425 7
#ifdef PURIFY
#define new_XRV() (void*)safemalloc(sizeof(XRV))
#define del_XRV(p) Safefree((char*)p)
#else
#define new_XRV() (void*)new_xrv()
#define del_XRV(p) del_xrv((XRV*) p)
#endif
d427 12
a438 7
#ifdef PURIFY
#define new_XPV() (void*)safemalloc(sizeof(XPV))
#define del_XPV(p) Safefree((char*)p)
#else
#define new_XPV() (void*)new_xpv()
#define del_XPV(p) del_xpv((XPV *)p)
#endif
d440 2
a441 6
#ifdef PURIFY
#  define my_safemalloc(s) safemalloc(s)
#  define my_safefree(s) free(s)
#else
STATIC void* 
my_safemalloc(MEM_SIZE size)
d443 4
a446 3
    char *p;
    New(717, p, size, char);
    return (void*)p;
a447 2
#  define my_safefree(s) Safefree(s)
#endif 
a448 32
#define new_XPVIV() (void*)my_safemalloc(sizeof(XPVIV))
#define del_XPVIV(p) my_safefree((char*)p)
  
#define new_XPVNV() (void*)my_safemalloc(sizeof(XPVNV))
#define del_XPVNV(p) my_safefree((char*)p)
  
#define new_XPVMG() (void*)my_safemalloc(sizeof(XPVMG))
#define del_XPVMG(p) my_safefree((char*)p)
  
#define new_XPVLV() (void*)my_safemalloc(sizeof(XPVLV))
#define del_XPVLV(p) my_safefree((char*)p)
  
#define new_XPVAV() (void*)my_safemalloc(sizeof(XPVAV))
#define del_XPVAV(p) my_safefree((char*)p)
  
#define new_XPVHV() (void*)my_safemalloc(sizeof(XPVHV))
#define del_XPVHV(p) my_safefree((char*)p)
  
#define new_XPVCV() (void*)my_safemalloc(sizeof(XPVCV))
#define del_XPVCV(p) my_safefree((char*)p)
  
#define new_XPVGV() (void*)my_safemalloc(sizeof(XPVGV))
#define del_XPVGV(p) my_safefree((char*)p)
  
#define new_XPVBM() (void*)my_safemalloc(sizeof(XPVBM))
#define del_XPVBM(p) my_safefree((char*)p)
  
#define new_XPVFM() (void*)my_safemalloc(sizeof(XPVFM))
#define del_XPVFM(p) my_safefree((char*)p)
  
#define new_XPVIO() (void*)my_safemalloc(sizeof(XPVIO))
#define del_XPVIO(p) my_safefree((char*)p)
d450 2
a451 2
bool
sv_upgrade(register SV *sv, U32 mt)
d453 11
a463 7
    char*	pv;
    U32		cur;
    U32		len;
    IV		iv;
    double	nv;
    MAGIC*	magic;
    HV*		stash;
a464 2
    if (SvTYPE(sv) == mt)
	return TRUE;
a465 2
    if (mt < SVt_PVIV)
	(void)SvOOK_off(sv);
d467 451
a917 94
    switch (SvTYPE(sv)) {
    case SVt_NULL:
	pv	= 0;
	cur	= 0;
	len	= 0;
	iv	= 0;
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
	break;
    case SVt_IV:
	pv	= 0;
	cur	= 0;
	len	= 0;
	iv	= SvIVX(sv);
	nv	= (double)SvIVX(sv);
	del_XIV(SvANY(sv));
	magic	= 0;
	stash	= 0;
	if (mt == SVt_NV)
	    mt = SVt_PVNV;
	else if (mt < SVt_PVIV)
	    mt = SVt_PVIV;
	break;
    case SVt_NV:
	pv	= 0;
	cur	= 0;
	len	= 0;
	nv	= SvNVX(sv);
	iv	= I_32(nv);
	magic	= 0;
	stash	= 0;
	del_XNV(SvANY(sv));
	SvANY(sv) = 0;
	if (mt < SVt_PVNV)
	    mt = SVt_PVNV;
	break;
    case SVt_RV:
	pv	= (char*)SvRV(sv);
	cur	= 0;
	len	= 0;
	iv	= (IV)pv;
	nv	= (double)(unsigned long)pv;
	del_XRV(SvANY(sv));
	magic	= 0;
	stash	= 0;
	break;
    case SVt_PV:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= 0;
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
	del_XPV(SvANY(sv));
	if (mt <= SVt_IV)
	    mt = SVt_PVIV;
	else if (mt == SVt_NV)
	    mt = SVt_PVNV;
	break;
    case SVt_PVIV:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
	del_XPVIV(SvANY(sv));
	break;
    case SVt_PVNV:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= SvNVX(sv);
	magic	= 0;
	stash	= 0;
	del_XPVNV(SvANY(sv));
	break;
    case SVt_PVMG:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= SvNVX(sv);
	magic	= SvMAGIC(sv);
	stash	= SvSTASH(sv);
	del_XPVMG(SvANY(sv));
	break;
    default:
	croak("Can't upgrade that kind of scalar");
    }
d921 1
a921 1
	croak("Can't upgrade to undef");
d1081 2
a1082 2
char *
sv_peek(SV *sv)
d1084 7
a1090 10
#ifdef DEBUGGING
    SV *t = sv_newmortal();
    STRLEN prevlen;
    int unref = 0;

    sv_setpvn(t, "", 0);
  retry:
    if (!sv) {
	sv_catpv(t, "VOID");
	goto finish;
d1092 3
a1094 54
    else if (sv == (SV*)0x55555555 || SvTYPE(sv) == 'U') {
	sv_catpv(t, "WILD");
	goto finish;
    }
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes) {
	if (sv == &PL_sv_undef) {
	    sv_catpv(t, "SV_UNDEF");
	    if (!(SvFLAGS(sv) & (SVf_OK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		SvREADONLY(sv))
		goto finish;
	}
	else if (sv == &PL_sv_no) {
	    sv_catpv(t, "SV_NO");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 0 &&
		SvNVX(sv) == 0.0)
		goto finish;
	}
	else {
	    sv_catpv(t, "SV_YES");
	    if (!(SvFLAGS(sv) & (SVf_ROK|SVf_OOK|SVs_OBJECT|
				 SVs_GMG|SVs_SMG|SVs_RMG)) &&
		!(~SvFLAGS(sv) & (SVf_POK|SVf_NOK|SVf_READONLY|
				  SVp_POK|SVp_NOK)) &&
		SvCUR(sv) == 1 &&
		SvPVX(sv) && *SvPVX(sv) == '1' &&
		SvNVX(sv) == 1.0)
		goto finish;
	}
	sv_catpv(t, ":");
    }
    else if (SvREFCNT(sv) == 0) {
	sv_catpv(t, "(");
	unref++;
    }
    if (SvROK(sv)) {
	sv_catpv(t, "\\");
	if (SvCUR(t) + unref > 10) {
	    SvCUR(t) = unref + 3;
	    *SvEND(t) = '\0';
	    sv_catpv(t, "...");
	    goto finish;
	}
	sv = (SV*)SvRV(sv);
	goto retry;
    }
    switch (SvTYPE(sv)) {
    default:
	sv_catpv(t, "FREED");
	goto finish;
d1096 2
a1097 52
    case SVt_NULL:
	sv_catpv(t, "UNDEF");
	goto finish;
    case SVt_IV:
	sv_catpv(t, "IV");
	break;
    case SVt_NV:
	sv_catpv(t, "NV");
	break;
    case SVt_RV:
	sv_catpv(t, "RV");
	break;
    case SVt_PV:
	sv_catpv(t, "PV");
	break;
    case SVt_PVIV:
	sv_catpv(t, "PVIV");
	break;
    case SVt_PVNV:
	sv_catpv(t, "PVNV");
	break;
    case SVt_PVMG:
	sv_catpv(t, "PVMG");
	break;
    case SVt_PVLV:
	sv_catpv(t, "PVLV");
	break;
    case SVt_PVAV:
	sv_catpv(t, "AV");
	break;
    case SVt_PVHV:
	sv_catpv(t, "HV");
	break;
    case SVt_PVCV:
	if (CvGV(sv))
	    sv_catpvf(t, "CV(%s)", GvNAME(CvGV(sv)));
	else
	    sv_catpv(t, "CV()");
	goto finish;
    case SVt_PVGV:
	sv_catpv(t, "GV");
	break;
    case SVt_PVBM:
	sv_catpv(t, "BM");
	break;
    case SVt_PVFM:
	sv_catpv(t, "FM");
	break;
    case SVt_PVIO:
	sv_catpv(t, "IO");
	break;
    }
d1099 3
a1101 27
    if (SvPOKp(sv)) {
	if (!SvPVX(sv))
	    sv_catpv(t, "(null)");
	if (SvOOK(sv))
	    sv_catpvf(t, "(%ld+\"%.127s\")",(long)SvIVX(sv),SvPVX(sv));
	else
	    sv_catpvf(t, "(\"%.127s\")",SvPVX(sv));
    }
    else if (SvNOKp(sv)) {
	SET_NUMERIC_STANDARD();
	sv_catpvf(t, "(%g)",SvNVX(sv));
    }
    else if (SvIOKp(sv))
	sv_catpvf(t, "(%ld)",(long)SvIVX(sv));
    else
	sv_catpv(t, "()");
    
  finish:
    if (unref) {
	while (unref--)
	    sv_catpv(t, ")");
    }
    return SvPV(t, prevlen);
#else	/* DEBUGGING */
    return "";
#endif	/* DEBUGGING */
}
d1103 2
a1104 14
int
sv_backoff(register SV *sv)
{
    assert(SvOOK(sv));
    if (SvIVX(sv)) {
	char *s = SvPVX(sv);
	SvLEN(sv) += SvIVX(sv);
	SvPVX(sv) -= SvIVX(sv);
	SvIV_set(sv, 0);
	Move(s, SvPVX(sv), SvCUR(sv)+1, char);
    }
    SvFLAGS(sv) &= ~SVf_OOK;
    return 0;
}
d1107 1
a1107 5
#ifndef DOSISH
sv_grow(register SV *sv, register I32 newlen)
#else
sv_grow(SV* sv, unsigned long newlen)
#endif
d1113 2
a1114 1
	PerlIO_printf(Perl_debug_log, "Allocation too large: %lx\n", newlen);
d1138 1
a1138 1
#if defined(MYMALLOC) && !defined(PURIFY) && !defined(LEAKTEST)
d1155 9
d1165 1
a1165 1
sv_setiv(register SV *sv, IV i)
a1180 5
	if (SvFAKE(sv)) {
	    sv_unglob(sv);
	    break;
	}
	/* FALL THROUGH */
d1188 2
a1189 2
	    croak("Can't coerce %s to integer in %s", sv_reftype(sv,0),
		  op_desc[PL_op->op_type]);
d1197 8
d1206 1
a1206 1
sv_setiv_mg(register SV *sv, IV i)
d1212 9
d1222 1
a1222 1
sv_setuv(register SV *sv, UV u)
d1224 3
a1226 4
    if (u <= IV_MAX)
	sv_setiv(sv, u);
    else
	sv_setnv(sv, (double)u);
d1229 8
d1238 1
a1238 1
sv_setuv_mg(register SV *sv, UV u)
d1244 9
d1254 1
a1254 1
sv_setnv(register SV *sv, double num)
a1268 5
	if (SvFAKE(sv)) {
	    sv_unglob(sv);
	    break;
	}
	/* FALL THROUGH */
d1276 2
a1277 2
	    croak("Can't coerce %s to number in %s", sv_reftype(sv,0),
		  op_name[PL_op->op_type]);
d1285 8
d1294 1
a1294 1
sv_setnv_mg(register SV *sv, double num)
d1301 1
a1301 1
not_a_number(SV *sv)
d1349 3
a1351 2
	warn("Argument \"%s\" isn't numeric in %s", tmpbuf,
		op_name[PL_op->op_type]);
d1353 2
a1354 1
	warn("Argument \"%s\" isn't numeric", tmpbuf);
d1357 9
d1367 1
a1367 1
sv_2iv(register SV *sv)
d1376 1
a1376 4
	    if (SvNVX(sv) < 0.0)
		return I_V(SvNVX(sv));
	    else
		return (IV) U_V(SvNVX(sv));
d1381 1
a1381 1
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
d1383 2
a1384 2
		if (!PL_localizing)
		    warn(warn_uninit);
a1390 1
#ifdef OVERLOAD
d1393 2
a1394 3
	    return SvIV(tmpstr);
#endif /* OVERLOAD */
	  return (IV)SvRV(sv);
d1396 4
a1399 11
	if (SvREADONLY(sv)) {
	    if (SvNOKp(sv)) {
		if (SvNVX(sv) < 0.0)
		    return I_V(SvNVX(sv));
		else
		    return (IV) U_V(SvNVX(sv));
	    }
	    if (SvPOKp(sv) && SvLEN(sv))
		return asIV(sv);
	    if (PL_dowarn)
		warn(warn_uninit);
d1403 7
a1409 10
    switch (SvTYPE(sv)) {
    case SVt_NULL:
	sv_upgrade(sv, SVt_IV);
	break;
    case SVt_PV:
	sv_upgrade(sv, SVt_PVIV);
	break;
    case SVt_NV:
	sv_upgrade(sv, SVt_PVNV);
	break;
d1412 8
d1421 1
a1421 1
	if (SvNVX(sv) < 0.0)
d1423 1
a1423 1
	else
d1425 9
d1436 55
a1490 2
	(void)SvIOK_on(sv);
	SvIVX(sv) = asIV(sv);
d1494 5
a1498 2
	if (PL_dowarn && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	    warn(warn_uninit);
d1501 3
a1503 3
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2iv(%ld)\n",
	(unsigned long)sv,(long)SvIVX(sv)));
    return SvIVX(sv);
d1507 1
a1507 1
sv_2uv(register SV *sv)
d1520 1
a1520 1
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
d1522 2
a1523 2
		if (!PL_localizing)
		    warn(warn_uninit);
a1529 1
#ifdef OVERLOAD
d1532 2
a1533 3
	    return SvUV(tmpstr);
#endif /* OVERLOAD */
	  return (UV)SvRV(sv);
d1535 4
a1538 8
	if (SvREADONLY(sv)) {
	    if (SvNOKp(sv)) {
		return U_V(SvNVX(sv));
	    }
	    if (SvPOKp(sv) && SvLEN(sv))
		return asUV(sv);
	    if (PL_dowarn)
		warn(warn_uninit);
d1542 7
a1548 10
    switch (SvTYPE(sv)) {
    case SVt_NULL:
	sv_upgrade(sv, SVt_IV);
	break;
    case SVt_PV:
	sv_upgrade(sv, SVt_PVIV);
	break;
    case SVt_NV:
	sv_upgrade(sv, SVt_PVNV);
	break;
d1551 6
d1558 14
a1571 1
	SvUVX(sv) = U_V(SvNVX(sv));
d1574 73
a1646 2
	(void)SvIOK_on(sv);
	SvUVX(sv) = asUV(sv);
d1649 1
a1649 1
	if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
d1651 2
a1652 2
	    if (!PL_localizing)
		warn(warn_uninit);
d1654 3
d1659 4
a1662 3
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2uv(%lu)\n",
	(unsigned long)sv,SvUVX(sv)));
    return SvUVX(sv);
d1665 2
a1666 2
double
sv_2nv(register SV *sv)
d1675 2
a1676 1
	    if (PL_dowarn && !SvIOKp(sv) && !looks_like_number(sv))
d1678 1
a1678 2
	    SET_NUMERIC_STANDARD();
	    return atof(SvPVX(sv));
d1680 6
a1685 2
	if (SvIOKp(sv))
	    return (double)SvIVX(sv);
d1687 1
a1687 1
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
d1689 2
a1690 2
		if (!PL_localizing)
		    warn(warn_uninit);
a1696 1
#ifdef OVERLOAD
d1699 2
a1700 3
	    return SvNV(tmpstr);
#endif /* OVERLOAD */
	  return (double)(unsigned long)SvRV(sv);
d1702 4
a1705 11
	if (SvREADONLY(sv)) {
	    if (SvPOKp(sv) && SvLEN(sv)) {
		if (PL_dowarn && !SvIOKp(sv) && !looks_like_number(sv))
		    not_a_number(sv);
		SET_NUMERIC_STANDARD();
		return atof(SvPVX(sv));
	    }
	    if (SvIOKp(sv))
		return (double)SvIVX(sv);
	    if (PL_dowarn)
		warn(warn_uninit);
d1714 16
a1729 3
	DEBUG_c(SET_NUMERIC_STANDARD());
	DEBUG_c(PerlIO_printf(Perl_debug_log,
			      "0x%lx num(%g)\n",(unsigned long)sv,SvNVX(sv)));
d1736 1
a1736 1
	SvNVX(sv) = (double)SvIVX(sv);
d1739 2
a1740 1
	if (PL_dowarn && !SvIOKp(sv) && !looks_like_number(sv))
d1742 1
a1742 2
	SET_NUMERIC_STANDARD();
	SvNVX(sv) = atof(SvPVX(sv));
d1746 5
a1750 2
	if (PL_dowarn && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	    warn(warn_uninit);
d1754 15
a1768 3
    DEBUG_c(SET_NUMERIC_STANDARD());
    DEBUG_c(PerlIO_printf(Perl_debug_log,
			  "0x%lx 2nv(%g)\n",(unsigned long)sv,SvNVX(sv)));
d1773 1
a1773 1
asIV(SV *sv)
d1776 1
a1776 1
    double d;
d1778 9
a1786 10
    if (numtype == 1)
	return atol(SvPVX(sv));
    if (!numtype && PL_dowarn)
	not_a_number(sv);
    SET_NUMERIC_STANDARD();
    d = atof(SvPVX(sv));
    if (d < 0.0)
	return I_V(d);
    else
	return (IV) U_V(d);
d1790 1
a1790 1
asUV(SV *sv)
d1795 2
a1796 2
    if (numtype == 1)
	return strtoul(SvPVX(sv), Null(char**), 10);
d1798 6
a1803 4
    if (!numtype && PL_dowarn)
	not_a_number(sv);
    SET_NUMERIC_STANDARD();
    return U_V(atof(SvPVX(sv)));
d1806 22
d1829 1
a1829 1
looks_like_number(SV *sv)
d1834 2
a1835 1
    I32 numtype;
d1851 1
a1851 1
    if (*s == '+' || *s == '-')
d1853 11
d1865 1
a1865 1
    /* next must be digit or '.' */
d1870 11
a1880 1
        if (*s == '.') {
d1882 2
a1883 1
            while (isDIGIT(*s))  /* optional digits after "." */
d1887 5
a1891 1
    else if (*s == '.') {
d1893 2
a1894 1
        /* no digits before '.' means we need digits after it */
a1905 6
    /*
     * we return 1 if the number can be converted to _integer_ with atol()
     * and 2 if you need (int)atof().
     */
    numtype = 1;

d1908 2
a1909 1
	numtype = 2;
d1926 1
a1926 1
	return 1;
d1931 34
a1964 1
sv_2pv(register SV *sv, STRLEN *lp)
d1969 2
a1970 1
    char tmpbuf[64];	/* Must fit sprintf/Gconvert of longest IV/NV */
d1983 4
a1986 1
	    (void)sprintf(tmpbuf,"%ld",(long)SvIVX(sv));
d1991 1
a1991 2
	    SET_NUMERIC_STANDARD();
	    Gconvert(SvNVX(sv), DBL_DIG, 0, tmpbuf);
d1996 1
a1996 1
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
d1998 2
a1999 2
		if (!PL_localizing)
		    warn(warn_uninit);
a2006 1
#ifdef OVERLOAD
d2009 1
a2009 2
	      return SvPV(tmpstr,*lp);
#endif /* OVERLOAD */
d2034 1
a2034 1
 			    while(ch = *fptr++) {
d2081 1
a2081 1
		    sv_setpvf(tsv, "%s=%s", HvNAME(SvSTASH(sv)), s);
d2084 1
a2084 1
		sv_catpvf(tsv, "(0x%lx)", (unsigned long)sv);
d2090 4
a2093 14
	if (SvREADONLY(sv)) {
	    if (SvNOKp(sv)) {
		SET_NUMERIC_STANDARD();
		Gconvert(SvNVX(sv), DBL_DIG, 0, tmpbuf);
		tsv = Nullsv;
		goto tokensave;
	    }
	    if (SvIOKp(sv)) {
		(void)sprintf(tmpbuf,"%ld",(long)SvIVX(sv));
		tsv = Nullsv;
		goto tokensave;
	    }
	    if (PL_dowarn)
		warn(warn_uninit);
d2098 5
a2102 2
    (void)SvUPGRADE(sv, SVt_PV);
    if (SvNOKp(sv)) {
d2114 1
a2114 2
	    SET_NUMERIC_STANDARD();
	    Gconvert(SvNVX(sv), DBL_DIG, 0, s);
d2128 5
a2132 1
	U32 oldIOK = SvIOK(sv);
d2135 7
a2141 3
	olderrno = errno;	/* some Xenix systems wipe out errno here */
	sv_setpviv(sv, SvIVX(sv));
	errno = olderrno;
d2143 2
a2144 1
	if (oldIOK)
d2148 3
d2154 5
a2158 2
	if (PL_dowarn && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	    warn(warn_uninit);
d2160 3
d2168 2
a2169 1
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2pv(%s)\n",(unsigned long)sv,SvPVX(sv)));
d2212 27
d2241 1
a2241 1
sv_2bool(register SV *sv)
a2248 2
#ifdef OVERLOAD
      {
d2252 1
a2252 3
	  return SvTRUE(tmpsv);
      }
#endif /* OVERLOAD */
d2277 133
d2415 11
d2427 1
a2427 1
sv_setsv(SV *dstr, register SV *sstr)
d2442 1
a2442 6
    if (dtype == SVt_PVGV && (SvFLAGS(dstr) & SVf_FAKE)) {
        sv_unglob(dstr);     /* so fake GLOB won't perpetuate */
	sv_setpvn(dstr, "", 0);
        (void)SvPOK_only(dstr);
        dtype = SvTYPE(dstr);
    }
a2443 3
#ifdef OVERLOAD
    SvAMAGIC_off(dstr);
#endif /* OVERLOAD */
d2470 2
d2504 3
a2506 1
		if (PL_curcop->cop_stash != GvSTASH(dstr))
d2508 1
d2533 2
a2534 2
	    croak("Bizarre copy of %s in %s", sv_reftype(sstr, 0),
		op_name[PL_op->op_type]);
d2536 1
a2536 1
	    croak("Bizarre copy of %s", sv_reftype(sstr, 0));
d2555 1
a2555 1
		croak("Can't redefine active sort subroutine %s",
d2562 3
a2564 1
	    if (PL_curcop->cop_stash != GvSTASH(dstr))
d2566 1
d2582 1
a2582 1
	    SvUPGRADE(dstr, SVt_PVNV);
d2584 1
a2584 1
	    SvUPGRADE(dstr, stype);
d2598 1
a2598 1
		    GvGP(dstr)->gp_refcnt--;
d2603 1
a2603 1
		    GvLINE(dstr) = PL_curcop->cop_line;
d2614 3
a2616 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d2618 1
d2626 3
a2628 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d2630 1
d2660 1
a2660 1
				    croak(
d2663 2
a2664 6
				if (PL_dowarn || (const_changed && const_sv)) {
				    if (!(CvGV(cv) && GvSTASH(CvGV(cv))
					  && HvNAME(GvSTASH(CvGV(cv)))
					  && strEQ(HvNAME(GvSTASH(CvGV(cv))),
						   "autouse")))
					warn(const_sv ? 
a2667 1
				}
d2677 3
a2679 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d2681 1
d2696 3
a2698 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d2700 1
d2712 2
a2713 1
		Safefree(SvPVX(dstr));
d2727 2
a2729 1
#ifdef OVERLOAD
a2732 1
#endif /* OVERLOAD */
d2752 1
a2752 1
		else
d2759 5
d2780 2
d2790 2
d2800 3
d2808 2
d2813 2
a2814 2
	    if (PL_dowarn)
		warn("Undefined value assigned to typeglob");
d2822 8
d2831 1
a2831 1
sv_setsv_mg(SV *dstr, register SV *sstr)
d2837 9
d2847 1
a2847 1
sv_setpvn(register SV *sv, register const char *ptr, register STRLEN len)
d2857 1
a2857 6
    if (SvTYPE(sv) >= SVt_PV) {
	if (SvFAKE(sv) && SvTYPE(sv) == SVt_PVGV)
	    sv_unglob(sv);
    }
    else
	sv_upgrade(sv, SVt_PV);
d2868 8
d2877 1
a2877 1
sv_setpvn_mg(register SV *sv, register const char *ptr, register STRLEN len)
d2883 9
d2893 1
a2893 1
sv_setpv(register SV *sv, register const char *ptr)
d2903 1
a2903 6
    if (SvTYPE(sv) >= SVt_PV) {
	if (SvFAKE(sv) && SvTYPE(sv) == SVt_PVGV)
	    sv_unglob(sv);
    }
    else 
	sv_upgrade(sv, SVt_PV);
d2912 8
d2921 1
a2921 1
sv_setpv_mg(register SV *sv, register const char *ptr)
d2927 14
d2942 1
a2942 1
sv_usepvn(register SV *sv, register char *ptr, register STRLEN len)
d2950 2
a2951 1
    if (SvPVX(sv))
d2962 8
d2971 1
a2971 1
sv_usepvn_mg(register SV *sv, register char *ptr, register STRLEN len)
d2977 2
a2978 2
STATIC void
sv_check_thinkfirst(register SV *sv)
d2983 1
a2983 1
	    croak(no_modify);
d2987 2
d2991 11
d3003 1
a3003 1
sv_chop(register SV *sv, register char *ptr)	/* like set but assuming ptr is in sv */
d3016 7
d3026 1
a3026 1
    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVp_IOK|SVp_NOK);
d3034 10
d3045 1
a3045 1
sv_catpvn(register SV *sv, register char *ptr, register STRLEN len)
d3057 1
a3057 1
    (void)SvPOK_only(sv);		/* validate pointer */
d3061 8
d3070 1
a3070 1
sv_catpvn_mg(register SV *sv, register char *ptr, register STRLEN len)
d3076 9
d3086 1
a3086 1
sv_catsv(SV *dstr, register SV *sstr)
d3092 3
a3094 1
    if (s = SvPV(sstr, len))
d3096 3
d3101 8
d3110 1
a3110 1
sv_catsv_mg(SV *dstr, register SV *sstr)
d3116 9
d3126 1
a3126 1
sv_catpv(register SV *sv, register char *ptr)
d3141 1
a3141 1
    (void)SvPOK_only(sv);		/* validate pointer */
d3145 8
d3154 1
a3154 1
sv_catpv_mg(register SV *sv, register char *ptr)
d3161 1
a3161 1
newSV(STRLEN len)
a3165 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d3175 8
d3184 1
a3184 1
sv_magic(register SV *sv, SV *obj, int how, char *name, I32 namlen)
d3191 1
a3191 1
	    croak(no_modify);
d3224 1
a3224 1
	mg->mg_virtual = &vtbl_sv;
a3225 1
#ifdef OVERLOAD
d3227 1
a3227 1
        mg->mg_virtual = &vtbl_amagic;
d3230 1
a3230 1
        mg->mg_virtual = &vtbl_amagicelem;
a3234 1
#endif /* OVERLOAD */
d3236 7
a3242 1
	mg->mg_virtual = &vtbl_bm;
d3245 1
a3245 1
	mg->mg_virtual = &vtbl_env;
d3248 1
a3248 1
	mg->mg_virtual = &vtbl_fm;
d3251 1
a3251 1
	mg->mg_virtual = &vtbl_envelem;
d3254 1
a3254 1
	mg->mg_virtual = &vtbl_mglob;
d3257 1
a3257 1
	mg->mg_virtual = &vtbl_isa;
d3260 1
a3260 1
	mg->mg_virtual = &vtbl_isaelem;
d3263 1
a3263 1
	mg->mg_virtual = &vtbl_nkeys;
d3270 1
a3270 1
	mg->mg_virtual = &vtbl_dbline;
d3274 1
a3274 1
	mg->mg_virtual = &vtbl_mutex;
d3279 1
a3279 1
        mg->mg_virtual = &vtbl_collxfrm;
d3283 1
a3283 1
	mg->mg_virtual = &vtbl_pack;
d3287 1
a3287 1
	mg->mg_virtual = &vtbl_packelem;
d3290 1
a3290 1
	mg->mg_virtual = &vtbl_regexp;
d3293 1
a3293 1
	mg->mg_virtual = &vtbl_sig;
d3296 1
a3296 1
	mg->mg_virtual = &vtbl_sigelem;
d3299 1
a3299 1
	mg->mg_virtual = &vtbl_taint;
d3303 1
a3303 1
	mg->mg_virtual = &vtbl_uvar;
d3306 1
a3306 1
	mg->mg_virtual = &vtbl_vec;
d3309 1
a3309 1
	mg->mg_virtual = &vtbl_substr;
d3312 1
a3312 1
	mg->mg_virtual = &vtbl_defelem;
d3315 1
a3315 1
	mg->mg_virtual = &vtbl_glob;
d3318 1
a3318 1
	mg->mg_virtual = &vtbl_arylen;
d3321 4
a3324 1
	mg->mg_virtual = &vtbl_pos;
d3333 1
a3333 1
	croak("Don't know how to handle magic of type '%c'", how);
d3341 1
a3341 1
sv_unmagic(SV *sv, int type)
d3352 2
a3353 2
	    if (vtbl && (vtbl->svt_free != NULL))
		(VTBL->svt_free)(sv, mg);
d3374 66
d3441 1
a3441 1
sv_insert(SV *bigstr, STRLEN offset, STRLEN len, char *little, STRLEN littlelen)
d3452 1
a3452 1
	croak("Can't modify non-existent substring");
d3460 1
d3487 1
a3487 1
	croak("panic: sv_insert");
d3503 1
a3503 1
    else if (i = mid - big) {	/* faster from front */
d3527 1
a3527 1
sv_replace(register SV *sv, register SV *nsv)
d3529 1
d3532 2
a3533 2
    if (SvREFCNT(nsv) != 1)
	warn("Reference miscount in sv_replace()");
d3554 1
a3554 1
sv_clear(register SV *sv)
d3584 2
a3585 2
		    perl_call_sv((SV*)GvCV(destructor),
				 G_DISCARD|G_EVAL|G_KEEPERR);
d3588 1
d3594 8
a3609 6
	if (SvREFCNT(sv)) {
		if (PL_in_clean_objs)
		    croak("DESTROY created new reference to dead object");
		/* DESTROY gave object new lease on life */
		return;
	}
d3620 6
a3625 1
	  io_close((IO*)sv);
d3662 6
a3667 2
	if (SvROK(sv))
	    SvREFCNT_dec(SvRV(sv));
d3739 1
a3739 1
sv_newref(SV *sv)
d3747 1
a3747 1
sv_free(SV *sv)
d3749 1
d3764 2
a3765 1
	warn("Attempt to free unreferenced scalar");
d3773 4
a3776 1
	warn("Attempt to free temp prematurely: SV 0x%lx", (unsigned long)sv);
d3790 8
d3799 1
a3799 1
sv_len(register SV *sv)
d3814 2
a3815 2
I32
sv_eq(register SV *str1, register SV *str2)
d3817 3
a3819 4
    char *pv1;
    STRLEN cur1;
    char *pv2;
    STRLEN cur2;
d3821 2
a3822 6
    if (!str1) {
	pv1 = "";
	cur1 = 0;
    }
    else
	pv1 = SvPV(str1, cur1);
d3824 3
a3826 2
    if (!str2)
	return !cur1;
d3828 99
a3926 1
	pv2 = SvPV(str2, cur2);
d3934 10
d3945 1
a3945 1
sv_cmp(register SV *str1, register SV *str2)
d3947 2
a3948 4
    STRLEN cur1 = 0;
    char *pv1 = str1 ? SvPV(str1, cur1) : (char *) NULL;
    STRLEN cur2 = 0;
    char *pv2 = str2 ? SvPV(str2, cur2) : (char *) NULL;
d3951 32
d4001 1
a4001 1
sv_cmp_locale(register SV *sv1, register SV *sv2)
d4056 1
a4056 1
sv_collxfrm(SV *sv, STRLEN *nxp)
d4102 1
a4102 1
sv_gets(register SV *sv, register PerlIO *fp, I32 append)
d4114 1
d4212 1
a4212 1
	"Screamer: entering, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
d4214 3
a4216 3
	"Screamer: entering: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	       (long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	       (long)(PerlIO_has_base(fp) ? PerlIO_get_base(fp) : 0)));
d4246 2
a4247 1
	    "Screamer: going to getc, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
d4250 3
a4252 3
	    "Screamer: pre: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	    (long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	    (long)(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
d4258 3
a4260 3
	    "Screamer: post: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	    (long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	    (long)(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
d4264 1
a4264 1
	    "Screamer: after getc, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
d4288 1
a4288 1
	    "Screamer: quitting, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
d4291 3
a4293 3
	"Screamer: end: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	(long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	(long)(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
d4302 1
d4305 7
a4365 4
#ifdef WIN32
    win32_strip_return(sv);
#endif

d4370 8
d4379 1
a4379 1
sv_inc(register SV *sv)
d4392 1
a4392 1
		croak(no_modify);
d4396 3
a4398 4
#ifdef OVERLOAD
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,inc)) return;
#endif /* OVERLOAD */
	    i = (IV)SvRV(sv);
d4410 13
a4422 5
	if (SvIVX(sv) == IV_MAX)
	    sv_setnv(sv, (double)IV_MAX + 1.0);
	else {
	    (void)SvIOK_only(sv);
	    ++SvIVX(sv);
d4437 1
a4437 2
	SET_NUMERIC_STANDARD();
	sv_setnv(sv,atof(SvPVX(sv)) + 1.0);  /* punt */
d4479 8
d4488 1
a4488 1
sv_dec(register SV *sv)
d4500 1
a4500 1
		croak(no_modify);
d4504 3
a4506 4
#ifdef OVERLOAD
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,dec)) return;
#endif /* OVERLOAD */
	    i = (IV)SvRV(sv);
d4518 16
a4533 5
	if (SvIVX(sv) == IV_MIN)
	    sv_setnv(sv, (double)IV_MIN - 1.0);
	else {
	    (void)SvIOK_only(sv);
	    --SvIVX(sv);
d4544 1
a4544 2
    SET_NUMERIC_STANDARD();
    sv_setnv(sv,atof(SvPVX(sv)) - 1.0);	/* punt */
d4547 9
a4560 8
STATIC void
sv_mortalgrow(void)
{
    dTHR;
    PL_tmps_max += (PL_tmps_max < 512) ? 128 : 512;
    Renew(PL_tmps_stack, PL_tmps_max, SV*);
}

d4562 1
a4562 1
sv_mortalcopy(SV *oldstr)
a4567 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4569 2
a4570 3
    if (++PL_tmps_ix >= PL_tmps_max)
	sv_mortalgrow();
    PL_tmps_stack[PL_tmps_ix] = sv;
d4575 8
d4584 1
a4584 1
sv_newmortal(void)
a4589 2
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
d4591 2
a4592 3
    if (++PL_tmps_ix >= PL_tmps_max)
	sv_mortalgrow();
    PL_tmps_stack[PL_tmps_ix] = sv;
d4596 9
d4608 1
a4608 1
sv_2mortal(register SV *sv)
d4615 2
a4616 3
    if (++PL_tmps_ix >= PL_tmps_max)
	sv_mortalgrow();
    PL_tmps_stack[PL_tmps_ix] = sv;
d4621 10
d4632 1
a4632 1
newSVpv(char *s, STRLEN len)
a4636 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4643 11
d4655 1
a4655 1
newSVpvn(char *s, STRLEN len)
a4659 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4664 1
d4666 1
a4666 1
newSVpvf(const char* pat, ...)
d4668 1
d4671 15
d4687 5
a4691 4
    new_SV(sv);
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4693 1
a4693 1
    sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d4698 17
d4717 1
a4717 1
newSVnv(double n)
a4721 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4726 9
d4736 1
a4736 1
newSViv(IV i)
a4740 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4745 28
d4774 1
a4774 1
newRV_noinc(SV *tmpRef)
a4779 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4787 1
d4789 1
a4789 1
newRV(SV *tmpRef)
d4794 8
d4805 1
a4805 1
newSVsv(register SV *old)
d4807 1
d4813 2
a4814 1
	warn("semi-panic: attempt to dup freed string");
a4817 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
d4829 1
a4829 1
sv_reset(register char *s, HV *stash)
d4837 1
a4837 1
    char todo[256];
d4856 1
a4856 1
	i = *s;
d4860 1
a4860 1
	max = *s++;
d4866 2
a4867 2
	         entry;
	         entry = HeNEXT(entry))
d4875 1
a4875 1
        		sv_unref(sv);
d4901 1
a4901 1
sv_2io(SV *sv)
d4915 1
a4915 1
	    croak("Bad filehandle: %s", GvNAME(gv));
d4919 1
a4919 1
	    croak(no_usym, "filehandle");
d4928 1
a4928 1
	    croak("Bad filehandle: %s", SvPV(sv,n_a));
d4935 1
a4935 1
sv_2cv(SV *sv, HV **st, GV **gvp, I32 lref)
d4962 4
d4976 1
a4976 1
		croak("Not a subroutine reference");
d4992 3
d5001 1
a5001 1
		croak("Unable to create sub named \"%s\"", SvPV(sv,n_a));
d5008 1
a5008 1
sv_true(register SV *sv)
d5016 1
a5016 2
		(*tXpv->xpv_pv > '0' ||
		tXpv->xpv_cur > 1 ||
d5035 1
a5035 1
sv_iv(register SV *sv)
d5037 3
a5039 1
    if (SvIOK(sv))
d5041 1
d5046 1
a5046 1
sv_uv(register SV *sv)
d5048 5
a5052 2
    if (SvIOK(sv))
	return SvUVX(sv);
d5056 2
a5057 2
double
sv_nv(register SV *sv)
d5065 12
a5076 1
sv_pvn(SV *sv, STRLEN *lp)
d5086 1
a5086 1
sv_pvn_force(SV *sv, STRLEN *lp)
d5090 2
a5091 5
    if (SvREADONLY(sv)) {
	dTHR;
	if (PL_curcop != &PL_compiling)
	    croak(no_modify);
    }
d5098 3
a5100 10
	    if (SvFAKE(sv) && SvTYPE(sv) == SVt_PVGV) {
		sv_unglob(sv);
		s = SvPVX(sv);
		*lp = SvCUR(sv);
	    }
	    else {
		dTHR;
		croak("Can't coerce %s to string in %s", sv_reftype(sv,0),
		    op_name[PL_op->op_type]);
	    }
d5118 2
a5119 2
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2pv(%s)\n",
		(unsigned long)sv,SvPVX(sv)));
d5126 40
a5165 1
sv_reftype(SV *sv, int ob)
d5190 1
d5196 10
d5207 1
a5207 1
sv_isobject(SV *sv)
d5221 10
d5232 1
a5232 1
sv_isa(SV *sv, char *name)
d5247 11
d5259 1
a5259 1
newSVrv(SV *rv, char *classname)
a5264 3
    SvANY(sv) = 0;
    SvREFCNT(sv) = 0;
    SvFLAGS(sv) = 0;
a5266 1
#ifdef OVERLOAD
a5267 1
#endif /* OVERLOAD */
d5273 1
a5273 1
    SvRV(rv) = SvREFCNT_inc(sv);
d5283 18
d5302 1
a5302 1
sv_setref_pv(SV *rv, char *classname, void *pv)
d5309 1
a5309 1
	sv_setiv(newSVrv(rv,classname), (IV)pv);
d5313 12
d5326 1
a5326 1
sv_setref_iv(SV *rv, char *classname, IV iv)
d5332 12
d5345 1
a5345 1
sv_setref_nv(SV *rv, char *classname, double nv)
d5351 15
d5367 1
a5367 1
sv_setref_pvn(SV *rv, char *classname, char *pv, I32 n)
d5373 10
d5384 1
a5384 1
sv_bless(SV *sv, HV *stash)
d5389 1
a5389 1
        croak("Can't bless non-reference value");
d5393 1
a5393 1
	    croak(no_modify);
a5405 1
#ifdef OVERLOAD
a5409 1
#endif /* OVERLOAD */
d5415 1
a5415 1
sv_unglob(SV *sv)
d5417 2
d5430 7
d5441 10
d5452 1
a5452 1
sv_unref(SV *sv)
d5455 7
a5461 1
    
d5471 1
a5471 1
sv_taint(SV *sv)
d5477 1
a5477 1
sv_untaint(SV *sv)
d5487 1
a5487 1
sv_tainted(SV *sv)
d5491 1
a5491 1
	if (mg && ((mg->mg_len & 1) || (mg->mg_len & 2) && mg->mg_obj == sv))
d5497 9
d5507 1
a5507 1
sv_setpviv(SV *sv, IV iv)
d5509 3
a5511 6
    STRLEN len;
    char buf[TYPE_DIGITS(UV)];
    char *ptr = buf + sizeof(buf);
    int sign;
    UV uv;
    char *p;
d5513 1
a5513 21
    sv_setpvn(sv, "", 0);
    if (iv >= 0) {
	uv = iv;
	sign = 0;
    } else {
	uv = -iv;
	sign = 1;
    }
    do {
	*--ptr = '0' + (uv % 10);
    } while (uv /= 10);
    len = (buf + sizeof(buf)) - ptr;
    /* taking advantage of SvCUR(sv) == 0 */
    SvGROW(sv, sign + len + 1);
    p = SvPVX(sv);
    if (sign)
	*p++ = '-';
    memcpy(p, ptr, len);
    p += len;
    *p = '\0';
    SvCUR(sv) = p - SvPVX(sv);
d5517 8
d5526 1
a5526 1
sv_setpviv_mg(SV *sv, IV iv)
d5528 5
a5532 1
    sv_setpviv(sv,iv);
d5536 1
d5538 1
a5538 1
sv_setpvf(SV *sv, const char* pat, ...)
d5540 1
d5543 1
a5543 1
    sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d5549 1
a5549 1
sv_setpvf_mg(SV *sv, const char* pat, ...)
d5551 1
d5554 1
a5554 1
    sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d5556 48
d5607 1
d5609 1
a5609 1
sv_catpvf(SV *sv, const char* pat, ...)
d5611 1
d5614 1
a5614 1
    sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d5619 1
a5619 1
sv_catpvf_mg(SV *sv, const char* pat, ...)
d5621 1
d5624 1
a5624 1
    sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d5626 49
d5678 9
d5688 1
a5688 1
sv_vsetpvfn(SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *used_locale)
d5691 1
a5691 1
    sv_vcatpvfn(sv, pat, patlen, args, svargs, svmax, used_locale);
d5694 12
d5707 1
a5707 1
sv_vcatpvfn(SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *used_locale)
d5716 1
d5731 1
a5731 1
	    else if (svix < svmax)
d5733 3
d5739 4
a5742 1
		sv_catsv(sv, va_arg(*args, SV*));
d5754 2
d5763 1
d5766 1
d5771 10
a5780 7
	char ebuf[TYPE_DIGITS(int) * 2 + 16]; /* large enough for "%#.#f" */

#ifndef PERL_OBJECT
	static char *efloatbuf = Nullch;
	static STRLEN efloatsize = 0;
#endif

d5786 1
a5786 1
	double nv;
d5790 2
d5824 31
d5906 7
d5914 2
a5915 2
#if 0  /* when quads have better support within Perl */
	    if (*(q + 1) == 'l') {
d5919 1
a5919 1
	    }
d5923 1
d5942 1
a5942 1
		c = va_arg(*args, int);
d5944 11
a5954 3
		c = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
	    eptr = &c;
	    elen = 1;
d5961 6
d5973 15
a5987 2
	    else if (svix < svmax)
		eptr = SvPVx(svargs[svix++], elen);
d5998 4
a6001 1
	    eptr = SvPVx(va_arg(*args, SV*), elen);
d6004 1
d6013 1
a6013 1
		uv = (UV)va_arg(*args, void*);
d6015 1
a6015 1
		uv = (svix < svmax) ? (UV)svargs[svix++] : 0;
d6020 3
d6024 1
d6028 16
a6043 1
	    if (args) {
d6049 3
d6061 3
d6079 3
d6083 1
d6089 4
d6094 3
d6098 1
d6109 17
a6125 1
	    if (args) {
d6131 3
d6143 3
d6156 2
a6157 1
		p = (c == 'X') ? "0123456789ABCDEF" : "0123456789abcdef";
d6175 10
d6186 13
d6225 1
d6227 1
a6227 1
		nv = va_arg(*args, double);
d6234 1
a6234 1
		(void)frexp(nv, &i);
d6236 1
a6236 1
		    die("panic: frexp");
d6245 5
a6249 4
	    if (efloatsize < need) {
		Safefree(efloatbuf);
		efloatsize = need + 20; /* more fudge */
		New(906, efloatbuf, efloatsize, char);
d6255 7
d6281 5
a6285 14
	    (void)sprintf(efloatbuf, eptr, nv);

	    eptr = efloatbuf;
	    elen = strlen(efloatbuf);

#ifdef LC_NUMERIC
	    /*
	     * User-defined locales may include arbitrary characters.
	     * And, unfortunately, some system may alloc the "C" locale
	     * to be overridden by a malicious user.
	     */
	    if (used_locale)
		*used_locale = TRUE;
#endif /* LC_NUMERIC */
d6287 2
d6294 1
d6302 3
d6315 2
a6316 1
	    if (!args && PL_dowarn &&
d6319 1
a6319 1
		sv_setpvf(msg, "Invalid conversion in %s: ",
d6321 9
a6329 4
		if (c)
		    sv_catpvf(msg, isPRINT(c) ? "\"%%%c\"" : "\"%%\\%03o\"",
			      c & 0xFF);
		else
d6331 1
a6331 1
		warn("%_", msg); /* yes, this is reentrant */
d6354 1
a6354 1
	SvGROW(sv, SvCUR(sv) + need + 1);
d6380 10
d6392 4
d6399 168
d6568 1
a6568 1
sv_dump(SV *sv)
d6570 6
a6575 5
#ifdef DEBUGGING
    SV *d = sv_newmortal();
    char *s;
    U32 flags;
    U32 type;
d6577 8
a6584 3
    if (!sv) {
	PerlIO_printf(Perl_debug_log, "SV = 0\n");
	return;
d6586 9
a6594 3
    
    flags = SvFLAGS(sv);
    type = SvTYPE(sv);
d6596 23
a6618 55
    sv_setpvf(d, "(0x%lx)\n  REFCNT = %ld\n  FLAGS = (",
	      (unsigned long)SvANY(sv), (long)SvREFCNT(sv));
    if (flags & SVs_PADBUSY)	sv_catpv(d, "PADBUSY,");
    if (flags & SVs_PADTMP)	sv_catpv(d, "PADTMP,");
    if (flags & SVs_PADMY)	sv_catpv(d, "PADMY,");
    if (flags & SVs_TEMP)	sv_catpv(d, "TEMP,");
    if (flags & SVs_OBJECT)	sv_catpv(d, "OBJECT,");
    if (flags & SVs_GMG)	sv_catpv(d, "GMG,");
    if (flags & SVs_SMG)	sv_catpv(d, "SMG,");
    if (flags & SVs_RMG)	sv_catpv(d, "RMG,");

    if (flags & SVf_IOK)	sv_catpv(d, "IOK,");
    if (flags & SVf_NOK)	sv_catpv(d, "NOK,");
    if (flags & SVf_POK)	sv_catpv(d, "POK,");
    if (flags & SVf_ROK)	sv_catpv(d, "ROK,");
    if (flags & SVf_OOK)	sv_catpv(d, "OOK,");
    if (flags & SVf_FAKE)	sv_catpv(d, "FAKE,");
    if (flags & SVf_READONLY)	sv_catpv(d, "READONLY,");

#ifdef OVERLOAD
    if (flags & SVf_AMAGIC)	sv_catpv(d, "OVERLOAD,");
#endif /* OVERLOAD */
    if (flags & SVp_IOK)	sv_catpv(d, "pIOK,");
    if (flags & SVp_NOK)	sv_catpv(d, "pNOK,");
    if (flags & SVp_POK)	sv_catpv(d, "pPOK,");
    if (flags & SVp_SCREAM)	sv_catpv(d, "SCREAM,");

    switch (type) {
    case SVt_PVCV:
    case SVt_PVFM:
	if (CvANON(sv))		sv_catpv(d, "ANON,");
	if (CvUNIQUE(sv))	sv_catpv(d, "UNIQUE,");
	if (CvCLONE(sv))	sv_catpv(d, "CLONE,");
	if (CvCLONED(sv))	sv_catpv(d, "CLONED,");
	if (CvNODEBUG(sv))	sv_catpv(d, "NODEBUG,");
	break;
    case SVt_PVHV:
	if (HvSHAREKEYS(sv))	sv_catpv(d, "SHAREKEYS,");
	if (HvLAZYDEL(sv))	sv_catpv(d, "LAZYDEL,");
	break;
    case SVt_PVGV:
	if (GvINTRO(sv))	sv_catpv(d, "INTRO,");
	if (GvMULTI(sv))	sv_catpv(d, "MULTI,");
	if (GvASSUMECV(sv))	sv_catpv(d, "ASSUMECV,");
	if (GvIMPORTED(sv)) {
	    sv_catpv(d, "IMPORT");
	    if (GvIMPORTED(sv) == GVf_IMPORTED)
		sv_catpv(d, "ALL,");
	    else {
		sv_catpv(d, "(");
		if (GvIMPORTED_SV(sv))	sv_catpv(d, " SV");
		if (GvIMPORTED_AV(sv))	sv_catpv(d, " AV");
		if (GvIMPORTED_HV(sv))	sv_catpv(d, " HV");
		if (GvIMPORTED_CV(sv))	sv_catpv(d, " CV");
		sv_catpv(d, " ),");
d6620 2
a6622 4
    case SVt_PVBM:
	if (SvTAIL(sv))	sv_catpv(d, "TAIL,");
	if (SvCOMPILED(sv))	sv_catpv(d, "COMPILED,");
	break;
d6624 26
d6651 5
a6655 4
    if (*(SvEND(d) - 1) == ',')
	SvPVX(d)[--SvCUR(d)] = '\0';
    sv_catpv(d, ")");
    s = SvPVX(d);
d6657 1
a6657 2
    PerlIO_printf(Perl_debug_log, "SV = ");
    switch (type) {
d6659 2
a6660 2
	PerlIO_printf(Perl_debug_log, "NULL%s\n", s);
	return;
d6662 2
a6663 1
	PerlIO_printf(Perl_debug_log, "IV%s\n", s);
d6666 2
a6667 1
	PerlIO_printf(Perl_debug_log, "NV%s\n", s);
d6670 2
a6671 1
	PerlIO_printf(Perl_debug_log, "RV%s\n", s);
d6674 9
a6682 1
	PerlIO_printf(Perl_debug_log, "PV%s\n", s);
d6685 10
a6694 1
	PerlIO_printf(Perl_debug_log, "PVIV%s\n", s);
d6697 26
a6722 1
	PerlIO_printf(Perl_debug_log, "PVNV%s\n", s);
d6725 35
a6759 1
	PerlIO_printf(Perl_debug_log, "PVBM%s\n", s);
d6761 20
a6780 2
    case SVt_PVMG:
	PerlIO_printf(Perl_debug_log, "PVMG%s\n", s);
d6782 37
a6818 2
    case SVt_PVLV:
	PerlIO_printf(Perl_debug_log, "PVLV%s\n", s);
d6821 35
a6855 1
	PerlIO_printf(Perl_debug_log, "PVAV%s\n", s);
d6858 27
a6884 1
	PerlIO_printf(Perl_debug_log, "PVHV%s\n", s);
d6886 5
d6892 30
a6921 1
	PerlIO_printf(Perl_debug_log, "PVCV%s\n", s);
d6923 2
a6924 5
    case SVt_PVGV:
	PerlIO_printf(Perl_debug_log, "PVGV%s\n", s);
	break;
    case SVt_PVFM:
	PerlIO_printf(Perl_debug_log, "PVFM%s\n", s);
a6925 6
    case SVt_PVIO:
	PerlIO_printf(Perl_debug_log, "PVIO%s\n", s);
	break;
    default:
	PerlIO_printf(Perl_debug_log, "UNKNOWN%s\n", s);
	return;
d6927 89
a7015 5
    if (type >= SVt_PVIV || type == SVt_IV)
	PerlIO_printf(Perl_debug_log, "  IV = %ld\n", (long)SvIVX(sv));
    if (type >= SVt_PVNV || type == SVt_NV) {
	SET_NUMERIC_STANDARD();
	PerlIO_printf(Perl_debug_log, "  NV = %.*g\n", DBL_DIG, SvNVX(sv));
d7017 300
a7316 4
    if (SvROK(sv)) {
	PerlIO_printf(Perl_debug_log, "  RV = 0x%lx\n", (long)SvRV(sv));
	sv_dump(SvRV(sv));
	return;
d7318 291
a7608 8
    if (type < SVt_PV)
	return;
    if (type <= SVt_PVLV) {
	if (SvPVX(sv))
	    PerlIO_printf(Perl_debug_log, "  PV = 0x%lx \"%s\"\n  CUR = %ld\n  LEN = %ld\n",
		(long)SvPVX(sv), SvPVX(sv), (long)SvCUR(sv), (long)SvLEN(sv));
	else
	    PerlIO_printf(Perl_debug_log, "  PV = 0\n");
d7610 182
a7791 3
    if (type >= SVt_PVMG) {
	if (SvMAGIC(sv)) {
	    PerlIO_printf(Perl_debug_log, "  MAGIC = 0x%lx\n", (long)SvMAGIC(sv));
a7792 2
	if (SvSTASH(sv))
	    PerlIO_printf(Perl_debug_log, "  STASH = \"%s\"\n", HvNAME(SvSTASH(sv)));
d7794 245
a8038 51
    switch (type) {
    case SVt_PVLV:
	PerlIO_printf(Perl_debug_log, "  TYPE = %c\n", LvTYPE(sv));
	PerlIO_printf(Perl_debug_log, "  TARGOFF = %ld\n", (long)LvTARGOFF(sv));
	PerlIO_printf(Perl_debug_log, "  TARGLEN = %ld\n", (long)LvTARGLEN(sv));
	PerlIO_printf(Perl_debug_log, "  TARG = 0x%lx\n", (long)LvTARG(sv));
	sv_dump(LvTARG(sv));
	break;
    case SVt_PVAV:
	PerlIO_printf(Perl_debug_log, "  ARRAY = 0x%lx\n", (long)AvARRAY(sv));
	PerlIO_printf(Perl_debug_log, "  ALLOC = 0x%lx\n", (long)AvALLOC(sv));
	PerlIO_printf(Perl_debug_log, "  FILL = %ld\n", (long)AvFILLp(sv));
	PerlIO_printf(Perl_debug_log, "  MAX = %ld\n", (long)AvMAX(sv));
	PerlIO_printf(Perl_debug_log, "  ARYLEN = 0x%lx\n", (long)AvARYLEN(sv));
	flags = AvFLAGS(sv);
	sv_setpv(d, "");
	if (flags & AVf_REAL)	sv_catpv(d, ",REAL");
	if (flags & AVf_REIFY)	sv_catpv(d, ",REIFY");
	if (flags & AVf_REUSED)	sv_catpv(d, ",REUSED");
	PerlIO_printf(Perl_debug_log, "  FLAGS = (%s)\n",
		      SvCUR(d) ? SvPVX(d) + 1 : "");
	break;
    case SVt_PVHV:
	PerlIO_printf(Perl_debug_log, "  ARRAY = 0x%lx\n",(long)HvARRAY(sv));
	PerlIO_printf(Perl_debug_log, "  KEYS = %ld\n", (long)HvKEYS(sv));
	PerlIO_printf(Perl_debug_log, "  FILL = %ld\n", (long)HvFILL(sv));
	PerlIO_printf(Perl_debug_log, "  MAX = %ld\n", (long)HvMAX(sv));
	PerlIO_printf(Perl_debug_log, "  RITER = %ld\n", (long)HvRITER(sv));
	PerlIO_printf(Perl_debug_log, "  EITER = 0x%lx\n",(long) HvEITER(sv));
	if (HvPMROOT(sv))
	    PerlIO_printf(Perl_debug_log, "  PMROOT = 0x%lx\n",(long)HvPMROOT(sv));
	if (HvNAME(sv))
	    PerlIO_printf(Perl_debug_log, "  NAME = \"%s\"\n", HvNAME(sv));
	break;
    case SVt_PVCV:
	if (SvPOK(sv)) {
	    STRLEN n_a;
	    PerlIO_printf(Perl_debug_log, "  PROTOTYPE = \"%s\"\n", SvPV(sv,n_a));
	}
	/* FALL THROUGH */
    case SVt_PVFM:
	PerlIO_printf(Perl_debug_log, "  STASH = 0x%lx\n", (long)CvSTASH(sv));
	PerlIO_printf(Perl_debug_log, "  START = 0x%lx\n", (long)CvSTART(sv));
	PerlIO_printf(Perl_debug_log, "  ROOT = 0x%lx\n", (long)CvROOT(sv));
	PerlIO_printf(Perl_debug_log, "  XSUB = 0x%lx\n", (long)CvXSUB(sv));
	PerlIO_printf(Perl_debug_log, "  XSUBANY = %ld\n", (long)CvXSUBANY(sv).any_i32);
	PerlIO_printf(Perl_debug_log, "  GV = 0x%lx", (long)CvGV(sv));
	if (CvGV(sv) && GvNAME(CvGV(sv))) {
	    PerlIO_printf(Perl_debug_log, "  \"%s\"\n", GvNAME(CvGV(sv)));
	} else {
	    PerlIO_printf(Perl_debug_log, "\n");
a8039 50
	PerlIO_printf(Perl_debug_log, "  FILEGV = 0x%lx\n", (long)CvFILEGV(sv));
	PerlIO_printf(Perl_debug_log, "  DEPTH = %ld\n", (long)CvDEPTH(sv));
	PerlIO_printf(Perl_debug_log, "  PADLIST = 0x%lx\n", (long)CvPADLIST(sv));
	PerlIO_printf(Perl_debug_log, "  OUTSIDE = 0x%lx\n", (long)CvOUTSIDE(sv));
#ifdef USE_THREADS
	PerlIO_printf(Perl_debug_log, "  MUTEXP = 0x%lx\n", (long)CvMUTEXP(sv));
	PerlIO_printf(Perl_debug_log, "  OWNER = 0x%lx\n", (long)CvOWNER(sv));
#endif /* USE_THREADS */
	PerlIO_printf(Perl_debug_log, "  FLAGS = 0x%lx\n",
		      (unsigned long)CvFLAGS(sv));
	if (type == SVt_PVFM)
	    PerlIO_printf(Perl_debug_log, "  LINES = %ld\n", (long)FmLINES(sv));
	break;
    case SVt_PVGV:
	PerlIO_printf(Perl_debug_log, "  NAME = \"%s\"\n", GvNAME(sv));
	PerlIO_printf(Perl_debug_log, "  NAMELEN = %ld\n", (long)GvNAMELEN(sv));
	PerlIO_printf(Perl_debug_log, "  STASH = \"%s\"\n",
	    SvTYPE(GvSTASH(sv)) == SVt_PVHV ? HvNAME(GvSTASH(sv)) : "(deleted)");
	PerlIO_printf(Perl_debug_log, "  GP = 0x%lx\n", (long)GvGP(sv));
	PerlIO_printf(Perl_debug_log, "    SV = 0x%lx\n", (long)GvSV(sv));
	PerlIO_printf(Perl_debug_log, "    REFCNT = %ld\n", (long)GvREFCNT(sv));
	PerlIO_printf(Perl_debug_log, "    IO = 0x%lx\n", (long)GvIOp(sv));
	PerlIO_printf(Perl_debug_log, "    FORM = 0x%lx\n", (long)GvFORM(sv));
	PerlIO_printf(Perl_debug_log, "    AV = 0x%lx\n", (long)GvAV(sv));
	PerlIO_printf(Perl_debug_log, "    HV = 0x%lx\n", (long)GvHV(sv));
	PerlIO_printf(Perl_debug_log, "    CV = 0x%lx\n", (long)GvCV(sv));
	PerlIO_printf(Perl_debug_log, "    CVGEN = 0x%lx\n", (long)GvCVGEN(sv));
	PerlIO_printf(Perl_debug_log, "    LASTEXPR = %ld\n", (long)GvLASTEXPR(sv));
	PerlIO_printf(Perl_debug_log, "    LINE = %ld\n", (long)GvLINE(sv));
	PerlIO_printf(Perl_debug_log, "    FILEGV = 0x%lx\n", (long)GvFILEGV(sv));
	PerlIO_printf(Perl_debug_log, "    EGV = 0x%lx\n", (long)GvEGV(sv));
	break;
    case SVt_PVIO:
	PerlIO_printf(Perl_debug_log, "  IFP = 0x%lx\n", (long)IoIFP(sv));
	PerlIO_printf(Perl_debug_log, "  OFP = 0x%lx\n", (long)IoOFP(sv));
	PerlIO_printf(Perl_debug_log, "  DIRP = 0x%lx\n", (long)IoDIRP(sv));
	PerlIO_printf(Perl_debug_log, "  LINES = %ld\n", (long)IoLINES(sv));
	PerlIO_printf(Perl_debug_log, "  PAGE = %ld\n", (long)IoPAGE(sv));
	PerlIO_printf(Perl_debug_log, "  PAGE_LEN = %ld\n", (long)IoPAGE_LEN(sv));
	PerlIO_printf(Perl_debug_log, "  LINES_LEFT = %ld\n", (long)IoLINES_LEFT(sv));
	PerlIO_printf(Perl_debug_log, "  TOP_NAME = \"%s\"\n", IoTOP_NAME(sv));
	PerlIO_printf(Perl_debug_log, "  TOP_GV = 0x%lx\n", (long)IoTOP_GV(sv));
	PerlIO_printf(Perl_debug_log, "  FMT_NAME = \"%s\"\n", IoFMT_NAME(sv));
	PerlIO_printf(Perl_debug_log, "  FMT_GV = 0x%lx\n", (long)IoFMT_GV(sv));
	PerlIO_printf(Perl_debug_log, "  BOTTOM_NAME = \"%s\"\n", IoBOTTOM_NAME(sv));
	PerlIO_printf(Perl_debug_log, "  BOTTOM_GV = 0x%lx\n", (long)IoBOTTOM_GV(sv));
	PerlIO_printf(Perl_debug_log, "  SUBPROCESS = %ld\n", (long)IoSUBPROCESS(sv));
	PerlIO_printf(Perl_debug_log, "  TYPE = %c\n", IoTYPE(sv));
	PerlIO_printf(Perl_debug_log, "  FLAGS = 0x%lx\n", (long)IoFLAGS(sv));
	break;
a8040 1
#endif	/* DEBUGGING */
d8042 10
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d43 6
d52 4
a55 4
static XPVIV *more_xiv _((void));
static XPVNV *more_xnv _((void));
static XPV *more_xpv _((void));
static XRV *more_xrv _((void));
d66 5
d73 6
d84 1
d87 1
d92 1
d94 2
a95 1
        free((char*)(p));		\
d99 1
a99 1
static I32 regsize;
d106 1
a106 1
	I32 h = REGHASH(sv, regsize);	\
d109 1
a109 1
	    if (++i >= regsize)		\
d124 1
a124 1
    if (sv_count >= (regsize >> 1))
d127 1
a127 1
	I32 oldsize = regsize;
d129 2
a130 3
	regsize = regsize ? ((regsize << 2) + 1) : 2037;
	registry = (SV**)safemalloc(regsize * sizeof(SV*));
	memzero(registry, regsize * sizeof(SV*));
d145 1
a145 1
    ++sv_count;
d153 1
a153 1
    --sv_count;
d162 1
a162 1
    for (i = 0; i < regsize; ++i) {
d164 1
a164 1
	if (sv)
d176 1
a176 1
	free(ptr);
d187 1
a187 1
	SvANY(p) = (void *)sv_root;	\
d189 2
a190 2
	sv_root = (p);			\
	--sv_count;			\
d193 1
d196 3
a198 3
	(p) = sv_root;			\
	sv_root = (SV*)SvANY(p);	\
	++sv_count;			\
d201 8
a208 5
#define new_SV(p)			\
    if (sv_root)			\
	uproot_SV(p);			\
    else				\
	(p) = more_sv()
d212 8
a219 5
#define del_SV(p)			\
    if (debug & 32768)			\
	del_sv(p);			\
    else				\
	plant_SV(p)
d221 2
a222 3
static void
del_sv(p)
SV* p;
d224 1
a224 1
    if (debug & 32768) {
d229 1
a229 1
	for (sva = sv_arenaroot; sva; sva = (SV *) SvANY(sva)) {
d250 1
a250 4
sv_add_arena(ptr, size, flags)
char* ptr;
U32 size;
U32 flags;
d258 1
a258 1
    SvANY(sva) = (void *) sv_arenaroot;		/* ptr to next arena */
d262 2
a263 2
    sv_arenaroot = sva;
    sv_root = sva + 1;
d276 3
a278 2
static SV*
more_sv()
d282 3
a284 3
    if (nice_chunk) {
	sv_add_arena(nice_chunk, nice_chunk_size, 0);
	nice_chunk = Nullch;
d295 2
a296 3
static void
visit(f)
SVFUNC f;
d302 1
a302 1
    for (sva = sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
d306 1
a306 1
		(*f)(sv);
d313 2
a314 3
static void
do_report_used(sv)
SV* sv;
d324 1
a324 1
sv_report_used()
d326 1
a326 1
    visit(do_report_used);
d329 2
a330 3
static void
do_clean_objs(sv)
SV* sv;
d345 2
a346 3
static void
do_clean_named_objs(sv)
SV* sv;
d348 11
a358 2
    if (SvTYPE(sv) == SVt_PVGV && GvSV(sv))
	do_clean_objs(GvSV(sv));
a361 2
static bool in_clean_objs = FALSE;

d363 1
a363 1
sv_clean_objs()
d365 2
a366 1
    in_clean_objs = TRUE;
d368 2
a369 1
    visit(do_clean_named_objs);
d371 1
a371 2
    visit(do_clean_objs);
    in_clean_objs = FALSE;
d374 2
a375 3
static void
do_clean_all(sv)
SV* sv;
d377 1
a377 1
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops:\n "), sv_dump(sv));)
a381 2
static bool in_clean_all = FALSE;

d383 1
a383 1
sv_clean_all()
d385 3
a387 3
    in_clean_all = TRUE;
    visit(do_clean_all);
    in_clean_all = FALSE;
d391 1
a391 1
sv_free_arenas()
d399 1
a399 1
    for (sva = sv_arenaroot; sva; sva = svanext) {
d408 48
a455 41
    sv_arenaroot = 0;
    sv_root = 0;
}

static XPVIV*
new_xiv()
{
    IV** xiv;
    if (xiv_root) {
	xiv = xiv_root;
	/*
	 * See comment in more_xiv() -- RAM.
	 */
	xiv_root = (IV**)*xiv;
	return (XPVIV*)((char*)xiv - sizeof(XPV));
    }
    return more_xiv();
}

static void
del_xiv(p)
XPVIV* p;
{
    IV** xiv = (IV**)((char*)(p) + sizeof(XPV));
    *xiv = (IV *)xiv_root;
    xiv_root = xiv;
}

static XPVIV*
more_xiv()
{
    register IV** xiv;
    register IV** xivend;
    XPV* ptr = (XPV*)safemalloc(1008);
    ptr->xpv_pv = (char*)xiv_arenaroot;		/* linked list of xiv arenas */
    xiv_arenaroot = ptr;			/* to keep Purify happy */

    xiv = (IV**) ptr;
    xivend = &xiv[1008 / sizeof(IV *) - 1];
    xiv += (sizeof(XPV) - 1) / sizeof(IV *) + 1;   /* fudge by size of XPV */
    xiv_root = xiv;
d457 1
a457 1
	*xiv = (IV *)(xiv + 1);
d460 1
a460 2
    *xiv = 0;
    return new_xiv();
d463 2
a464 2
static XPVNV*
new_xnv()
d467 17
a483 6
    if (xnv_root) {
	xnv = xnv_root;
	xnv_root = *(double**)xnv;
	return (XPVNV*)((char*)xnv - sizeof(XPVIV));
    }
    return more_xnv();
d486 2
a487 11
static void
del_xnv(p)
XPVNV* p;
{
    double* xnv = (double*)((char*)(p) + sizeof(XPVIV));
    *(double**)xnv = xnv_root;
    xnv_root = xnv;
}

static XPVNV*
more_xnv()
d491 1
a491 1
    xnv = (double*)safemalloc(1008);
d494 1
a494 1
    xnv_root = xnv;
a499 1
    return new_xnv();
d502 2
a503 2
static XRV*
new_xrv()
d506 16
a521 6
    if (xrv_root) {
	xrv = xrv_root;
	xrv_root = (XRV*)xrv->xrv_rv;
	return xrv;
    }
    return more_xrv();
d524 2
a525 10
static void
del_xrv(p)
XRV* p;
{
    p->xrv_rv = (SV*)xrv_root;
    xrv_root = p;
}

static XRV*
more_xrv()
d529 2
a530 2
    xrv_root = (XRV*)safemalloc(1008);
    xrv = xrv_root;
a536 1
    return new_xrv();
d539 2
a540 2
static XPV*
new_xpv()
d543 16
a558 6
    if (xpv_root) {
	xpv = xpv_root;
	xpv_root = (XPV*)xpv->xpv_pv;
	return xpv;
    }
    return more_xpv();
d561 2
a562 10
static void
del_xpv(p)
XPV* p;
{
    p->xpv_pv = (char*)xpv_root;
    xpv_root = p;
}

static XPV*
more_xpv()
d566 2
a567 2
    xpv_root = (XPV*)safemalloc(1008);
    xpv = xpv_root;
a573 1
    return new_xpv();
d578 1
a578 1
#define del_XIV(p) free((char*)p)
d581 1
a581 1
#define del_XIV(p) del_xiv(p)
d586 1
a586 1
#define del_XNV(p) free((char*)p)
d589 1
a589 1
#define del_XNV(p) del_xnv(p)
d594 1
a594 1
#define del_XRV(p) free((char*)p)
d597 1
a597 1
#define del_XRV(p) del_xrv(p)
d602 1
a602 1
#define del_XPV(p) free((char*)p)
d605 1
a605 1
#define del_XPV(p) del_xpv(p)
d608 13
a620 2
#define new_XPVIV() (void*)safemalloc(sizeof(XPVIV))
#define del_XPVIV(p) free((char*)p)
d622 32
a653 29
#define new_XPVNV() (void*)safemalloc(sizeof(XPVNV))
#define del_XPVNV(p) free((char*)p)

#define new_XPVMG() (void*)safemalloc(sizeof(XPVMG))
#define del_XPVMG(p) free((char*)p)

#define new_XPVLV() (void*)safemalloc(sizeof(XPVLV))
#define del_XPVLV(p) free((char*)p)

#define new_XPVAV() (void*)safemalloc(sizeof(XPVAV))
#define del_XPVAV(p) free((char*)p)

#define new_XPVHV() (void*)safemalloc(sizeof(XPVHV))
#define del_XPVHV(p) free((char*)p)

#define new_XPVCV() (void*)safemalloc(sizeof(XPVCV))
#define del_XPVCV(p) free((char*)p)

#define new_XPVGV() (void*)safemalloc(sizeof(XPVGV))
#define del_XPVGV(p) free((char*)p)

#define new_XPVBM() (void*)safemalloc(sizeof(XPVBM))
#define del_XPVBM(p) free((char*)p)

#define new_XPVFM() (void*)safemalloc(sizeof(XPVFM))
#define del_XPVFM(p) free((char*)p)

#define new_XPVIO() (void*)safemalloc(sizeof(XPVIO))
#define del_XPVIO(p) free((char*)p)
d656 1
a656 3
sv_upgrade(sv, mt)
register SV* sv;
U32 mt;
d836 1
a836 1
	AvFILL(sv)	= -1;
a928 1
#ifdef DEBUGGING
d930 1
a930 2
sv_peek(sv)
register SV *sv;
d932 1
d947 2
a948 2
    else if (sv == &sv_undef || sv == &sv_no || sv == &sv_yes) {
	if (sv == &sv_undef) {
d955 1
a955 1
	else if (sv == &sv_no) {
d1073 4
a1076 1
    return SvPV(t, na);
a1077 1
#endif
d1080 1
a1080 2
sv_backoff(sv)
register SV *sv;
a1094 2
sv_grow(sv,newlen)
register SV *sv;
d1096 1
a1096 1
register I32 newlen;
d1098 1
a1098 1
unsigned long newlen;
d1120 4
d1128 8
a1135 1
        if (SvLEN(sv) && s)
d1137 1
d1147 1
a1147 3
sv_setiv(sv,i)
register SV *sv;
IV i;
d1149 1
a1149 6
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
d1173 5
a1177 2
	croak("Can't coerce %s to integer in %s", sv_reftype(sv,0),
	    op_desc[op->op_type]);
d1185 8
a1192 3
sv_setuv(sv,u)
register SV *sv;
UV u;
d1201 8
a1208 3
sv_setnv(sv,num)
register SV *sv;
double num;
d1210 1
a1210 6
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
a1215 1
    case SVt_NV:
a1219 7
	/* FALL THROUGH */
    case SVt_PVNV:
    case SVt_PVMG:
    case SVt_PVBM:
    case SVt_PVLV:
	if (SvOOK(sv))
	    (void)SvOOK_off(sv);
d1221 1
d1233 5
a1237 2
	croak("Can't coerce %s to number in %s", sv_reftype(sv,0),
	    op_name[op->op_type]);
d1244 9
a1252 3
static void
not_a_number(sv)
SV *sv;
d1254 1
d1299 1
a1299 1
    if (op)
d1301 1
a1301 1
		op_name[op->op_type]);
d1307 1
a1307 2
sv_2iv(sv)
register SV *sv;
d1324 5
a1328 2
	    if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
		warn(warn_uninit);
d1350 1
a1350 1
	    if (dowarn)
d1378 2
a1379 1
	if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d1389 1
a1389 2
sv_2uv(sv)
register SV *sv;
d1402 5
a1406 2
	    if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
		warn(warn_uninit);
d1425 1
a1425 1
	    if (dowarn)
d1450 5
a1454 2
	if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	    warn(warn_uninit);
d1463 1
a1463 2
sv_2nv(sv)
register SV *sv;
d1472 1
a1472 1
	    if (dowarn && !SvIOKp(sv) && !looks_like_number(sv))
d1480 5
a1484 2
	    if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
		warn(warn_uninit);
d1499 1
a1499 1
		if (dowarn && !SvIOKp(sv) && !looks_like_number(sv))
d1506 1
a1506 1
	    if (dowarn)
d1528 1
a1528 1
	if (dowarn && !SvIOKp(sv) && !looks_like_number(sv))
d1534 2
a1535 1
	if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d1546 2
a1547 3
static IV
asIV(sv)
SV *sv;
d1554 1
a1554 1
    if (!numtype && dowarn)
d1564 2
a1565 3
static UV
asUV(sv)
SV *sv;
d1573 1
a1573 1
    if (!numtype && dowarn)
d1580 1
a1580 2
looks_like_number(sv)
SV *sv;
d1659 1
a1659 3
sv_2pv(sv, lp)
register SV *sv;
STRLEN *lp;
d1664 1
d1677 1
a1677 1
	    (void)sprintf(tokenbuf,"%ld",(long)SvIVX(sv));
d1683 1
a1683 1
	    Gconvert(SvNVX(sv), DBL_DIG, 0, tokenbuf);
d1688 5
a1692 2
	    if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
		warn(warn_uninit);
d1708 2
d1711 45
d1763 1
a1763 2
		case SVt_PVBM:
		case SVt_PVMG:	s = "SCALAR";			break;
d1769 1
a1769 1
		case SVt_PVFM:	s = "FORMATLINE";		break;
d1787 1
a1787 1
		Gconvert(SvNVX(sv), DBL_DIG, 0, tokenbuf);
d1792 1
a1792 1
		(void)sprintf(tokenbuf,"%ld",(long)SvIVX(sv));
d1796 1
a1796 1
	    if (dowarn)
d1802 1
a1802 2
    if (!SvUPGRADE(sv, SVt_PV))
	return 0;
d1843 2
a1844 1
	if (dowarn && !localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d1861 1
a1861 1
	    tsv = newSVpv(tokenbuf, 0);
d1876 2
a1877 2
	    t = tokenbuf;
	    len = strlen(tokenbuf);
d1897 1
a1897 2
sv_2bool(sv)
register SV *sv;
d1907 1
d1916 5
a1920 5
	register XPV* Xpv;
	if ((Xpv = (XPV*)SvANY(sv)) &&
		(*Xpv->xpv_pv > '0' ||
		Xpv->xpv_cur > 1 ||
		(Xpv->xpv_cur && *Xpv->xpv_pv != '0')))
d1943 1
a1943 3
sv_setsv(dstr,sstr)
SV *dstr;
register SV *sstr;
d1945 1
d1952 1
a1952 6
    if (SvTHINKFIRST(dstr)) {
	if (SvREADONLY(dstr) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(dstr))
	    sv_unref(dstr);
    }
d1954 1
a1954 1
	sstr = &sv_undef;
d1972 6
a1977 2
	(void)SvOK_off(dstr);
	return;
d1979 3
a1981 2
	if (dtype != SVt_IV && dtype < SVt_PVIV) {
	    if (dtype < SVt_IV)
d1983 2
a1984 1
	    else if (dtype == SVt_NV)
d1986 3
a1988 1
	    else
d1990 6
d1997 2
a1998 1
	break;
d2000 4
a2003 2
	if (dtype != SVt_NV && dtype < SVt_PVNV) {
	    if (dtype < SVt_NV)
d2005 4
a2008 1
	    else
d2010 6
d2017 2
a2018 1
	break;
d2026 1
a2026 1
		if (curcop->cop_stash != GvSTASH(dstr))
a2046 5

    case SVt_PVLV:
	sv_upgrade(dstr, SVt_PVLV);
	break;

d2051 1
a2051 1
	if (op)
d2053 1
a2053 1
		op_name[op->op_type]);
d2066 1
a2066 1
		GvSTASH(dstr) = GvSTASH(sstr);
d2072 2
a2073 2
	    else if (curstack == sortstack
		     && GvCV(dstr) && sortcop == CvSTART(GvCV(dstr)))
d2081 1
a2081 1
	    if (curcop->cop_stash != GvSTASH(dstr))
d2097 4
a2100 2
	if (dtype < stype)
	    sv_upgrade(dstr, stype);
d2119 1
a2119 1
		    GvLINE(dstr) = curcop->cop_line;
d2130 1
a2130 1
		    if (curcop->cop_stash != GvSTASH(dstr))
d2139 1
a2139 1
		    if (curcop->cop_stash != GvSTASH(dstr))
d2148 1
a2148 1
			    sub_generation++;
d2160 6
d2168 2
a2169 2
				if (curstack == sortstack &&
				      sortcop == CvSTART(cv))
d2173 10
a2182 6
				if (cv_const_sv(cv))
				    warn("Constant subroutine %s redefined",
					 GvENAME((GV*)dstr));
				else if (dowarn)
				    warn("Subroutine %s redefined",
					 GvENAME((GV*)dstr));
d2190 1
a2190 1
			sub_generation++;
d2192 1
a2192 1
		    if (curcop->cop_stash != GvSTASH(dstr))
d2208 1
a2208 1
		    if (curcop->cop_stash != GvSTASH(dstr))
d2252 1
d2306 6
a2311 1
	(void)SvOK_off(dstr);
d2317 8
a2324 4
sv_setpvn(sv,ptr,len)
register SV *sv;
register const char *ptr;
register STRLEN len;
d2326 1
d2329 1
a2329 6
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
d2338 3
a2340 2
    else if (!sv_upgrade(sv, SVt_PV))
	return;
d2342 3
a2344 1
    Move(ptr,SvPVX(sv),len,char);
a2345 1
    *SvEND(sv) = '\0';
d2351 8
a2358 3
sv_setpv(sv,ptr)
register SV *sv;
register const char *ptr;
d2362 1
a2362 6
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
d2372 3
a2374 2
    else if (!sv_upgrade(sv, SVt_PV))
	return;
d2383 1
a2383 4
sv_usepvn(sv,ptr,len)
register SV *sv;
register char *ptr;
register STRLEN len;
d2385 9
a2393 8
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
    if (!SvUPGRADE(sv, SVt_PV))
	return;
d2410 22
a2431 3
sv_chop(sv,ptr)	/* like set but assuming ptr is in sv */
register SV *sv;
register char *ptr;
d2437 1
a2437 6
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
d2454 1
a2454 4
sv_catpvn(sv,ptr,len)
register SV *sv;
register char *ptr;
register STRLEN len;
d2471 8
a2478 3
sv_catsv(dstr,sstr)
SV *dstr;
register SV *sstr;
d2489 8
a2496 3
sv_catpv(sv,ptr)
register SV *sv;
register char *ptr;
d2515 7
d2523 1
a2523 7
#ifdef LEAKTEST
newSV(x,len)
I32 x;
#else
newSV(len)
#endif
STRLEN len;
d2541 1
a2541 6
sv_magic(sv, obj, how, name, namlen)
register SV *sv;
SV *obj;
int how;
char *name;
I32 namlen;
d2545 5
a2549 2
    if (SvREADONLY(sv) && curcop != &compiling && !strchr("gBf", how))
	croak(no_modify);
d2558 1
a2558 2
	if (!SvUPGRADE(sv, SVt_PVMG))
	    return;
d2564 1
a2564 1
    if (!obj || obj == sv || how == '#')
d2567 1
d2625 5
d2642 3
d2691 1
a2691 3
sv_unmagic(sv, type)
SV* sv;
int type;
d2702 2
a2703 2
	    if (vtbl && vtbl->svt_free)
		(*vtbl->svt_free)(sv, mg);
d2725 1
a2725 6
sv_insert(bigstr,offset,len,little,littlelen)
SV *bigstr;
STRLEN offset;
STRLEN len;
char *little;
STRLEN littlelen;
d2732 2
d2737 6
a2742 1
    SvPV_force(bigstr, na);
d2810 1
a2810 3
sv_replace(sv,nsv)
register SV *sv;
register SV *nsv;
d2813 1
a2813 6
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
d2836 1
a2836 2
sv_clear(sv)
register SV *sv;
d2838 1
d2843 3
a2845 2
	if (defstash) {		/* Still have a symbol table? */
	    dSP;
d2847 1
d2849 5
a2853 2
	    ENTER;
	    SAVEFREESV(SvSTASH(sv));
d2855 18
a2872 21
	    destructor = gv_fetchmethod(SvSTASH(sv), "DESTROY");
	    if (destructor) {
		SV ref;

		Zero(&ref, 1, SV);
		sv_upgrade(&ref, SVt_RV);
		SvRV(&ref) = SvREFCNT_inc(sv);
		SvROK_on(&ref);
		SvREFCNT(&ref) = 1;	/* Fake, but otherwise
					   creating+destructing a ref
					   leads to disaster. */

		EXTEND(SP, 2);
		PUSHMARK(SP);
		PUSHs(&ref);
		PUTBACK;
		perl_call_sv((SV*)GvCV(destructor),
			     G_DISCARD|G_EVAL|G_KEEPERR);
		del_XRV(SvANY(&ref));
		SvREFCNT(sv)--;
	    }
d2874 1
a2874 1
	    LEAVE;
d2876 1
a2876 2
	else
	    SvREFCNT_dec(SvSTASH(sv));
d2878 1
d2881 1
a2881 1
		--sv_objcount;	/* XXX Might want something more general */
d2884 1
a2884 1
		if (in_clean_objs)
d2892 1
d2895 2
a2896 1
	if (IoIFP(sv) != PerlIO_stdin() &&
d2916 3
d2922 5
a2927 1
    case SVt_PVLV:
d2987 7
a2993 1
	break;
d3009 1
a3009 2
sv_newref(sv)
SV* sv;
d3012 1
a3012 1
	SvREFCNT(sv)++;
d3017 1
a3017 2
sv_free(sv)
SV *sv;
d3019 2
a3022 4
    if (SvREADONLY(sv)) {
	if (sv == &sv_undef || sv == &sv_yes || sv == &sv_no)
	    return;
    }
d3026 5
a3030 1
	if (in_clean_all) /* All is fair */
d3032 1
d3036 2
a3037 1
    if (--SvREFCNT(sv) > 0)
d3041 1
a3041 1
	warn("Attempt to free temp prematurely");
d3045 5
d3056 1
a3056 2
sv_len(sv)
register SV *sv;
d3065 1
a3065 1
	len = mg_len(sv);
d3072 1
a3072 3
sv_eq(str1,str2)
register SV *str1;
register SV *str2;
d3098 1
a3098 3
sv_cmp(str1, str2)
register SV *str1;
register SV *str2;
d3101 1
a3101 1
    char *pv1 = str1 ? SvPV(str1, cur1) : NULL;
d3103 1
a3103 1
    char *pv2 = str2 ? SvPV(str2, cur2) : NULL;
d3124 1
a3124 3
sv_cmp_locale(sv1, sv2)
register SV *sv1;
register SV *sv2;
d3132 1
a3132 1
    if (collation_standard)
d3136 1
a3136 1
    pv1 = sv1 ? sv_collxfrm(sv1, &len1) : NULL;
d3138 1
a3138 1
    pv2 = sv2 ? sv_collxfrm(sv2, &len2) : NULL;
d3179 1
a3179 3
sv_collxfrm(sv, nxp)
     SV *sv;
     STRLEN *nxp;
d3183 2
a3184 2
    mg = SvMAGICAL(sv) ? mg_find(sv, 'o') : NULL;
    if (!mg || !mg->mg_ptr || *(U32*)mg->mg_ptr != collation_ix) {
d3195 1
a3195 1
		return xf + sizeof(collation_ix);
d3214 1
a3214 1
	return mg->mg_ptr + sizeof(collation_ix);
d3225 1
a3225 4
sv_gets(sv,fp,append)
register SV *sv;
register PerlIO *fp;
I32 append;
d3227 1
d3235 2
a3236 8
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
	if (SvROK(sv))
	    sv_unref(sv);
    }
    if (!SvUPGRADE(sv, SVt_PV))
	return 0;
d3239 1
a3239 1
    if (RsSNARF(rs)) {
d3243 22
a3264 1
    else if (RsPARA(rs)) {
d3269 1
a3269 1
	rsptr = SvPV(rs, rslen);
d3272 1
a3272 1
    if (RsPARA(rs)) {		/* have to do this both before and after */
d3469 1
a3469 1
    if (RsPARA(rs)) {		/* have to do this both before and after */  
d3479 4
d3488 1
a3488 2
sv_inc(sv)
register SV *sv;
d3495 2
d3498 5
a3502 2
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
d3504 1
d3506 1
a3506 1
	  if (SvAMAGIC(sv) && AMG_CALLun(sv,inc)) return;
d3508 3
a3510 1
	  sv_unref(sv);
a3512 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d3551 13
d3568 1
d3583 1
a3583 2
sv_dec(sv)
register SV *sv;
d3589 2
d3592 5
a3596 2
	if (SvREADONLY(sv) && curcop != &compiling)
	    croak(no_modify);
d3598 1
d3600 1
a3600 1
	  if (SvAMAGIC(sv) && AMG_CALLun(sv,dec)) return;
d3602 3
a3604 1
	  sv_unref(sv);
a3606 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d3638 2
a3639 2
static void
sv_mortalgrow()
d3641 3
a3643 2
    tmps_max += (tmps_max < 512) ? 128 : 512;
    Renew(tmps_stack, tmps_max, SV*);
d3647 1
a3647 2
sv_mortalcopy(oldstr)
SV *oldstr;
d3649 1
d3657 1
a3657 1
    if (++tmps_ix >= tmps_max)
d3659 1
a3659 1
    tmps_stack[tmps_ix] = sv;
d3665 1
a3665 1
sv_newmortal()
d3667 1
d3674 1
a3674 1
    if (++tmps_ix >= tmps_max)
d3676 1
a3676 1
    tmps_stack[tmps_ix] = sv;
d3683 1
a3683 2
sv_2mortal(sv)
register SV *sv;
d3685 1
d3688 3
a3690 3
    if (SvREADONLY(sv) && curcop != &compiling)
	croak(no_modify);
    if (++tmps_ix >= tmps_max)
d3692 1
a3692 1
    tmps_stack[tmps_ix] = sv;
d3698 1
a3698 3
newSVpv(s,len)
char *s;
STRLEN len;
d3712 13
a3724 1
#ifdef I_STDARG
a3726 7
#else
/*VARARGS0*/
SV *
newSVpvf(pat, va_alist)
const char *pat;
va_dcl
#endif
a3734 1
#ifdef I_STDARG
a3735 3
#else
    va_start(args);
#endif
d3743 1
a3743 2
newSVnv(n)
double n;
d3756 1
a3756 2
newSViv(i)
IV i;
d3769 1
a3769 2
newRV(ref)
SV *ref;
d3771 1
d3779 2
a3780 2
    SvTEMP_off(ref);
    SvRV(sv) = SvREFCNT_inc(ref);
a3784 1
#ifdef CRIPPLED_CC
d3786 1
a3786 2
newRV_noinc(ref)
SV *ref;
d3788 1
a3788 5
    register SV *sv;

    sv = newRV(ref);
    SvREFCNT_dec(ref);
    return sv;
a3789 1
#endif /* CRIPPLED_CC */
d3794 1
a3794 2
newSVsv(old)
register SV *old;
d3819 1
a3819 3
sv_reset(s,stash)
register char *s;
HV *stash;
d3829 3
d3834 1
a3834 1
	    pm->op_pmflags &= ~PMf_USED;
d3856 3
a3858 2
	      entry;
	      entry = HeNEXT(entry)) {
d3863 5
d3881 1
a3881 1
		    if (gv == envgv)
d3891 1
a3891 2
sv_2io(sv)
SV *sv;
d3895 1
d3912 1
a3912 1
	gv = gv_fetchpv(SvPV(sv,na), FALSE, SVt_PVIO);
d3918 1
a3918 1
	    croak("Bad filehandle: %s", SvPV(sv,na));
d3925 1
a3925 5
sv_2cv(sv, st, gvp, lref)
SV *sv;
HV **st;
GV **gvp;
I32 lref;
d3929 1
d3952 10
a3961 2
	    cv = (CV*)SvRV(sv);
	    if (SvTYPE(cv) != SVt_PVCV)
a3962 3
	    *gvp = Nullgv;
	    *st = CvSTASH(cv);
	    return cv;
d3964 1
a3964 1
	if (isGV(sv))
d3967 1
a3967 1
	    gv = gv_fetchpv(SvPV(sv, na), lref, SVt_PVCV);
d3984 1
a3984 1
		croak("Unable to create sub named \"%s\"", SvPV(sv,na));
a3989 1
#ifndef SvTRUE
d3991 1
a3991 2
SvTRUE(sv)
register SV *sv;
d3993 1
a3995 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d3997 5
a4001 5
	register XPV* Xpv;
	if ((Xpv = (XPV*)SvANY(sv)) &&
		(*Xpv->xpv_pv > '0' ||
		Xpv->xpv_cur > 1 ||
		(Xpv->xpv_cur && *Xpv->xpv_pv != '0')))
a4016 1
#endif /* !SvTRUE */
a4017 1
#ifndef SvIV
d4019 1
a4019 2
SvIV(sv)
register SV *sv;
a4024 1
#endif /* !SvIV */
a4025 1
#ifndef SvUV
d4027 1
a4027 2
SvUV(sv)
register SV *sv;
a4032 1
#endif /* !SvUV */
a4033 1
#ifndef SvNV
d4035 1
a4035 2
SvNV(sv)
register SV *sv;
a4040 1
#endif /* !SvNV */
a4041 1
#ifdef CRIPPLED_CC
d4043 1
a4043 3
sv_pvn(sv, lp)
SV *sv;
STRLEN *lp;
a4050 1
#endif
d4053 1
a4053 3
sv_pvn_force(sv, lp)
SV *sv;
STRLEN *lp;
d4057 5
a4061 2
    if (SvREADONLY(sv) && curcop != &compiling)
	croak(no_modify);
d4073 2
a4074 1
	    else
d4076 2
a4077 1
		    op_name[op->op_type]);
d4103 1
a4103 3
sv_reftype(sv, ob)
SV* sv;
int ob;
d4127 1
a4127 1
	case SVt_PVFM:		return "FORMLINE";
d4134 1
a4134 2
sv_isobject(sv)
SV *sv;
d4149 1
a4149 3
sv_isa(sv, name)
SV *sv;
char *name;
d4165 1
a4165 3
newSVrv(rv, classname)
SV *rv;
char *classname;
d4167 1
d4174 10
a4183 1
    sv_upgrade(rv, SVt_RV);
d4195 1
a4195 4
sv_setref_pv(rv, classname, pv)
SV *rv;
char *classname;
void* pv;
d4197 4
a4200 2
    if (!pv)
	sv_setsv(rv, &sv_undef);
d4207 1
a4207 4
sv_setref_iv(rv, classname, iv)
SV *rv;
char *classname;
IV iv;
d4214 1
a4214 4
sv_setref_nv(rv, classname, nv)
SV *rv;
char *classname;
double nv;
d4221 1
a4221 5
sv_setref_pvn(rv, classname, pv, n)
SV *rv;
char *classname;
char* pv;
I32 n;
d4228 1
a4228 3
sv_bless(sv,stash)
SV* sv;
HV* stash;
d4230 2
a4231 1
    SV *ref;
d4234 3
a4236 3
    ref = SvRV(sv);
    if (SvFLAGS(ref) & (SVs_OBJECT|SVf_READONLY)) {
	if (SvREADONLY(ref))
d4238 4
a4241 4
	if (SvOBJECT(ref)) {
	    if (SvTYPE(ref) != SVt_PVIO)
		--sv_objcount;
	    SvREFCNT_dec(SvSTASH(ref));
d4244 5
a4248 5
    SvOBJECT_on(ref);
    if (SvTYPE(ref) != SVt_PVIO)
	++sv_objcount;
    (void)SvUPGRADE(ref, SVt_PVMG);
    SvSTASH(ref) = (HV*)SvREFCNT_inc(stash);
d4260 2
a4261 3
static void
sv_unglob(sv)
SV* sv;
d4267 4
d4279 1
a4279 2
sv_unref(sv)
SV* sv;
d4292 1
a4292 2
sv_taint(sv)
SV *sv;
d4298 1
a4298 2
sv_untaint(sv)
SV *sv;
d4308 1
a4308 2
sv_tainted(sv)
SV *sv;
d4319 1
a4319 3
sv_setpviv(sv, iv)
SV *sv;
IV iv;
d4351 8
a4358 1
#ifdef I_STDARG
d4361 8
a4368 2
#else
/*VARARGS0*/
d4370 1
a4370 5
sv_setpvf(sv, pat, va_alist)
    SV *sv;
    const char *pat;
    va_dcl
#endif
a4372 1
#ifdef I_STDARG
a4373 3
#else
    va_start(args);
#endif
d4376 1
a4378 1
#ifdef I_STDARG
d4381 7
a4387 2
#else
/*VARARGS0*/
d4389 1
a4389 5
sv_catpvf(sv, pat, va_alist)
    SV *sv;
    const char *pat;
    va_dcl
#endif
a4391 1
#ifdef I_STDARG
a4392 3
#else
    va_start(args);
#endif
d4395 1
d4399 1
a4399 8
sv_vsetpvfn(sv, pat, patlen, args, svargs, svmax, used_locale)
    SV *sv;
    const char *pat;
    STRLEN patlen;
    va_list *args;
    SV **svargs;
    I32 svmax;
    bool *used_locale;
d4406 1
a4406 8
sv_vcatpvfn(sv, pat, patlen, args, svargs, svmax, used_locale)
    SV *sv;
    const char *pat;
    STRLEN patlen;
    va_list *args;
    SV **svargs;
    I32 svmax;
    bool *used_locale;
d4408 1
d4461 1
d4464 1
d4708 2
d4736 6
a4741 2
	    if (has_precis && precis > elen)
		zeros = precis - elen;
d4839 2
a4840 2
	    if (!args && dowarn &&
		  (op->op_type == OP_PRTF || op->op_type == OP_SPRINTF)) {
d4843 1
a4843 1
			  (op->op_type == OP_PRTF) ? "printf" : "sprintf");
a4902 1
#ifdef DEBUGGING
d4904 1
a4904 2
sv_dump(sv)
SV* sv;
d4906 1
d4977 4
d5080 1
a5080 1
	PerlIO_printf(Perl_debug_log, "  FILL = %ld\n", (long)AvFILL(sv));
d5104 4
a5107 2
	if (SvPOK(sv))
	    PerlIO_printf(Perl_debug_log, "  PROTOTYPE = \"%s\"\n", SvPV(sv,na));
d5125 6
d5137 2
a5138 1
	PerlIO_printf(Perl_debug_log, "  STASH = \"%s\"\n", HvNAME(GvSTASH(sv)));
d5172 1
a5173 7
#else
void
sv_dump(sv)
SV* sv;
{
}
#endif
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d39 1
a39 1
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE)
d43 2
a49 1
static SV *new_sv _((void));
d59 1
d61 1
a61 1
static void sv_unglob _((SV* sv));
d65 83
a147 2
#define new_SV() sv = (SV*)safemalloc(sizeof(SV))
#define del_SV(p) free((char*)p)
d159 13
a171 1
#else
d173 4
a176 4
#define new_SV()			\
    if (sv_root) {			\
	sv = sv_root;			\
	sv_root = (SV*)SvANY(sv);	\
d178 5
a182 1
    }					\
d184 1
a184 1
	sv = more_sv();
d186 1
a186 12
static SV*
new_sv()
{
    SV* sv;
    if (sv_root) {
	sv = sv_root;
	sv_root = (SV*)SvANY(sv);
	++sv_count;
	return sv;
    }
    return more_sv();
}
a187 1
#ifdef DEBUGGING
d191 2
a192 5
    else {				\
	SvANY(p) = (void *)sv_root;	\
	sv_root = p;			\
	--sv_count;			\
    }
d214 1
a214 3
    SvANY(p) = (void *) sv_root;
    sv_root = p;
    --sv_count;
a215 5
#else
#define del_SV(p)			\
    SvANY(p) = (void *)sv_root;		\
    sv_root = p;			\
    --sv_count;
d217 5
a221 1
#endif
d256 2
d262 7
a268 3
    else
	sv_add_arena(safemalloc(1008), 1008, 0);
    return new_sv();
a269 1
#endif
d271 3
a273 2
void
sv_report_used()
d279 1
a279 2
    for (sva = sv_arenaroot; sva; sva = (SV *) SvANY(sva)) {
	sv = sva + 1;
d281 3
a283 6
	while (sv < svend) {
	    if (SvTYPE(sv) != SVTYPEMASK) {
		fprintf(stderr, "****\n");
		sv_dump(sv);
	    }
	    ++sv;
d288 13
d302 8
a309 1
sv_clean_objs()
a310 3
    SV* sva;
    register SV* sv;
    register SV* svend;
d313 26
d340 1
a340 19
    register GV* gv;
    for (sva = sv_arenaroot; sva; sva = (SV *) SvANY(sva)) {
	gv = sva + 1;
	svend = &sva[SvREFCNT(sva)];
	while (gv < svend) {
	    if (SvTYPE(gv) == SVt_PVGV && (sv = GvSV(gv)) &&
		SvROK(sv) && SvOBJECT(rv = SvRV(sv)))
	    {
		DEBUG_D((fprintf(stderr, "Cleaning object ref:\n "),
			 sv_dump(sv));)
		SvROK_off(sv);
		SvRV(sv) = 0;
		SvREFCNT_dec(rv);
	    }
	    ++gv;
	}
    }
    if (!sv_objcount)
	return;
d342 11
a352 15
    for (sva = sv_arenaroot; sva; sva = (SV *) SvANY(sva)) {
	sv = sva + 1;
	svend = &sva[SvREFCNT(sva)];
	while (sv < svend) {
	    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
		DEBUG_D((fprintf(stderr, "Cleaning object ref:\n "),
			 sv_dump(sv));)
		SvROK_off(sv);
		SvRV(sv) = 0;
		SvREFCNT_dec(rv);
	    }
	    /* XXX Might want to check arrays, etc. */
	    ++sv;
	}
    }
d355 2
d360 3
a362 16
    SV* sva;
    register SV* sv;
    register SV* svend;

    for (sva = sv_arenaroot; sva; sva = (SV*) SvANY(sva)) {
	sv = sva + 1;
	svend = &sva[SvREFCNT(sva)];
	while (sv < svend) {
	    if (SvTYPE(sv) != SVTYPEMASK) {
		DEBUG_D((fprintf(stderr, "Cleaning loops:\n "), sv_dump(sv));)
		SvFLAGS(sv) |= SVf_BREAK;
		SvREFCNT_dec(sv);
	    }
	    ++sv;
	}
    }
d380 1
a380 1
	    Safefree(sva);
d382 3
a673 1
	nv = 0.0;
a687 1
	nv = 0.0;
a697 1
	nv = SvNVX(sv);
d789 2
a790 2
	AvMAX(sv)	= 0;
	AvFILL(sv)	= 0;
d888 2
a889 1
    char *t = tokenbuf;
d892 1
d895 1
a895 1
	strcpy(t, "VOID");
d899 1
a899 1
	strcpy(t, "WILD");
d904 1
a904 1
	    strcpy(t, "SV_UNDEF");
d911 1
a911 1
	    strcpy(t, "SV_NO");
d921 1
a921 1
	    strcpy(t, "SV_YES");
d931 1
a931 2
	t += strlen(t);
	*t++ = ':';
d934 1
a934 1
	*t++ = '(';
d938 5
a942 3
	*t++ = '\\';
	if (t - tokenbuf + unref > 10) {
	    strcpy(tokenbuf + unref + 3,"...");
d950 1
a950 1
	strcpy(t,"FREED");
d954 2
a955 2
	strcpy(t,"UNDEF");
	return tokenbuf;
d957 1
a957 1
	strcpy(t,"IV");
d960 1
a960 1
	strcpy(t,"NV");
d963 1
a963 1
	strcpy(t,"RV");
d966 1
a966 1
	strcpy(t,"PV");
d969 1
a969 1
	strcpy(t,"PVIV");
d972 1
a972 1
	strcpy(t,"PVNV");
d975 1
a975 1
	strcpy(t,"PVMG");
d978 1
a978 1
	strcpy(t,"PVLV");
d981 1
a981 1
	strcpy(t,"AV");
d984 1
a984 1
	strcpy(t,"HV");
d988 1
a988 1
	    sprintf(t, "CV(%s)", GvNAME(CvGV(sv)));
d990 1
a990 1
	    strcpy(t, "CV()");
d993 1
a993 1
	strcpy(t,"GV");
d996 1
a996 1
	strcpy(t,"BM");
d999 1
a999 1
	strcpy(t,"FM");
d1002 1
a1002 1
	strcpy(t,"IO");
a1004 1
    t += strlen(t);
d1008 1
a1008 1
	    strcpy(t, "(null)");
d1010 1
a1010 1
	    sprintf(t,"(%ld+\"%.127s\")",(long)SvIVX(sv),SvPVX(sv));
d1012 5
a1016 1
	    sprintf(t,"(\"%.127s\")",SvPVX(sv));
a1017 2
    else if (SvNOKp(sv))
	sprintf(t,"(%g)",SvNVX(sv));
d1019 1
a1019 1
	sprintf(t,"(%ld)",(long)SvIVX(sv));
d1021 1
a1021 1
	strcpy(t,"()");
a1024 1
	t += strlen(t);
d1026 1
a1026 2
	    *t++ = ')';
	*t = '\0';
d1028 1
a1028 1
    return tokenbuf;
d1059 1
a1059 1
#ifdef MSDOS
d1061 1
a1061 1
	fprintf(stderr, "Allocation too large: %lx\n", newlen);
d1064 1
a1064 1
#endif /* MSDOS */
d1125 1
a1125 1
	    op_name[op->op_type]);
d1133 11
d1198 7
a1204 5
    int i;

    for (s = SvPVX(sv), i = 50; *s && i; s++,i--) {
	int ch = *s;
	if (ch & 128 && !isprint(ch)) {
d1209 17
a1225 1
	if (isprint(ch))
d1229 1
a1229 1
	    *d++ = ch ^ 64;
d1262 6
a1267 4
	if (SvPOKp(sv) && SvLEN(sv)) {
	    if (dowarn && !looks_like_number(sv))
		not_a_number(sv);
	    return (IV)atol(SvPVX(sv));
a1268 3
        if (!SvROK(sv)) {
            return 0;
        }
d1286 2
a1287 5
	    if (SvPOKp(sv) && SvLEN(sv)) {
		if (dowarn && !looks_like_number(sv))
		    not_a_number(sv);
		return (IV)atol(SvPVX(sv));
	    }
d1296 1
a1296 1
	return SvIVX(sv);
d1309 1
a1309 1
	    SvIVX(sv) = (IV) U_V(SvNVX(sv));
a1311 2
	if (dowarn && !looks_like_number(sv))
	    not_a_number(sv);
d1313 1
a1313 1
	SvIVX(sv) = (IV)atol(SvPVX(sv));
d1320 1
a1320 1
    DEBUG_c(fprintf(stderr,"0x%lx 2iv(%ld)\n",
d1325 69
d1407 1
d1413 2
d1431 1
d1446 3
a1448 1
	DEBUG_c(fprintf(stderr,"0x%lx num(%g)\n",(unsigned long)sv,SvNVX(sv)));
d1460 1
d1469 3
a1471 1
    DEBUG_c(fprintf(stderr,"0x%lx 2nv(%g)\n",(unsigned long)sv,SvNVX(sv)));
d1475 115
d1597 1
d1611 1
d1615 1
d1617 1
d1621 2
d1654 1
a1654 1
		case SVt_PVIO:	s = "FILEHANDLE";		break;
d1657 1
d1659 1
a1659 2
		    sprintf(tokenbuf, "%s=%s(0x%lx)",
				HvNAME(SvSTASH(sv)), s, (unsigned long)sv);
d1661 2
a1662 1
		    sprintf(tokenbuf, "%s(0x%lx)", s, (unsigned long)sv);
d1670 1
d1672 1
d1677 1
d1699 2
d1702 1
d1711 1
a1711 1
	    s--;
d1715 1
a1717 2
	SvGROW(sv, 11);
	s = SvPVX(sv);
d1719 1
a1719 1
	(void)sprintf(s,"%ld",(long)SvIVX(sv));
d1721 5
a1725 1
	while (*s) s++;
a1732 1
    *s = '\0';
d1736 1
a1736 1
    DEBUG_c(fprintf(stderr,"0x%lx 2pv(%s)\n",(unsigned long)sv,SvPVX(sv)));
d1744 5
a1748 4
	sv = sv_newmortal();
	*lp = strlen(tokenbuf);
	sv_setpvn(sv, tokenbuf, *lp);
	return SvPVX(sv);
d1752 11
a1762 1
	
d1764 4
a1767 2
	if (*tokenbuf == '-' && tokenbuf[1] == '0' && !tokenbuf[2])
	    strcpy(tokenbuf,"0");
d1770 1
a1770 1
	len = *lp = strlen(tokenbuf);
d1773 2
a1774 2
	(void)strcpy(s, tokenbuf);
	/* NO SvPOK_on(sv) here! */
d1865 1
a1865 1
	if (dtype <= SVt_PV) {
d1870 1
a1870 1
	    else if (dtype <= SVt_PV)
d1875 1
a1875 1
	if (dtype <= SVt_PVIV) {
d1878 1
a1878 3
	    else if (dtype == SVt_PVIV)
		sv_upgrade(dstr, SVt_PVNV);
	    else if (dtype <= SVt_PV)
d1898 1
d1912 1
a1912 1
	sv_upgrade(dstr, SVt_PVNV);
d1939 5
d1946 1
a1946 1
	    gp_free(dstr);
d1957 8
a1966 2
	if (SvGMAGICAL(sstr))
	    mg_get(sstr);
d1983 1
a1983 2
		    GvGP(dstr) = gp;
		    GvREFCNT(dstr) = 1;
d1986 1
a1986 1
		    GvEGV(dstr) = dstr;
d2009 7
a2015 1
		    if (intro)
d2017 4
a2020 1
		    else {
d2023 19
a2041 7
			    dref = (SV*)cv;
			    if (dowarn && sref != dref &&
				    !GvCVGEN((GV*)dstr) &&
				    (CvROOT(cv) || CvXSUB(cv)) )
				warn("Subroutine %s redefined",
				    GvENAME((GV*)dstr));
			    SvFAKE_on(cv);
a2042 2
		    }
		    if (GvCV(dstr) != (CV*)sref) {
d2044 1
d2046 1
d2076 1
d2169 1
a2169 1
register char *ptr;
d2172 2
a2173 1
    assert(len >= 0);
d2201 1
a2201 1
register char *ptr;
d2354 1
a2354 1
    new_SV();
d2365 2
d2377 1
a2377 1
    if (SvREADONLY(sv) && curcop != &compiling && !strchr("gB", how))
d2402 6
a2407 2
    if (name && namlen >= 0)
	mg->mg_ptr = savepvn(name, namlen);
d2429 3
d2444 3
d2454 5
d2485 3
d2528 4
a2531 1
		Safefree(mg->mg_ptr);
d2656 1
d2659 1
a2670 3
	dSP;
	GV* destructor;

d2672 2
a2673 1
	    destructor = gv_fetchmethod(SvSTASH(sv), "DESTROY");
d2677 3
a2679 1
	    if (destructor && GvCV(destructor)) {
a2683 1
		SAVEI32(SvREFCNT(sv));
d2686 3
d2694 2
a2695 1
		perl_call_sv((SV*)destructor, G_DISCARD|G_EVAL|G_KEEPERR);
d2697 1
d2699 1
d2709 6
d2720 4
a2723 1
	io_close((IO*)sv);
d2741 1
a2741 1
	gp_free(sv);
d2755 1
a2755 1
	else if (SvPVX(sv))
d2841 2
d2855 2
a2856 1
    del_SV(sv);
d2901 1
a2901 1
    return !bcmp(pv1, pv2, cur1);
d2905 1
a2905 1
sv_cmp(str1,str2)
d2909 4
a2913 18
    char *pv1;
    STRLEN cur1;
    char *pv2;
    STRLEN cur2;

    if (!str1) {
	pv1 = "";
	cur1 = 0;
    }
    else
	pv1 = SvPV(str1, cur1);

    if (!str2) {
	pv2 = "";
	cur2 = 0;
    }
    else
	pv2 = SvPV(str2, cur2);
d2917 1
d2921 33
a2953 4
    if (cur1 < cur2) {
	/*SUPPRESS 560*/
	if (retval = memcmp((void*)pv1, (void*)pv2, cur1))
	    return retval < 0 ? -1 : 1;
d2955 5
a2959 1
	    return -1;
d2961 4
a2964 2
    /*SUPPRESS 560*/
    else if (retval = memcmp((void*)pv1, (void*)pv2, cur2))
d2966 67
a3032 4
    else if (cur1 == cur2)
	return 0;
    else
	return 1;
d3035 2
d3040 1
a3040 1
register FILE *fp;
a3049 10
#ifdef FAST_SV_GETS
    /*
     * We're going to steal some values from the stdio struct
     * and put EVERYTHING in the innermost loop into registers.
     */
    register STDCHAR *ptr;
    STRLEN bpx;
    I32 shortbuffered;
#endif

d3058 1
d3074 1
a3074 1
	    if (feof(fp))
d3076 1
a3076 1
	    i = getc(fp);
d3080 1
a3080 1
		ungetc(i,fp);
d3086 27
a3112 1
#ifdef FAST_SV_GETS
d3116 1
a3116 1
    cnt = FILE_cnt(fp);			/* get count into register */
d3125 2
a3126 1
	    SvGROW(sv, append+cnt+2);/* (remembering cnt can be -1) */
d3132 7
a3138 1
    ptr = FILE_ptr(fp);
d3143 2
a3144 1
		while (--cnt >= 0) {		     /* this     |  eat */
d3150 1
a3150 1
	        memcpy((char*)bp, (char*)ptr, cnt);  /* this     |  eat */    
d3167 19
a3185 5
	FILE_cnt(fp) = cnt;		/* deregisterize cnt and ptr */
	FILE_ptr(fp) = ptr;
	i = _filbuf(fp);		/* get more characters */
	cnt = FILE_cnt(fp);
	ptr = FILE_ptr(fp);		/* reregisterize cnt and ptr */
d3195 1
a3195 1
	*bp++ = i;			/* store character from _filbuf */
d3203 2
a3204 2
	  bcmp((char*)bp - rslen, rsptr, rslen))
	goto screamer;			/* go back to the fray */
d3208 7
a3214 2
    FILE_cnt(fp) = cnt;			/* put these back or we're in trouble */
    FILE_ptr(fp) = ptr;
d3216 6
a3221 6
    SvCUR_set(sv, bp - (STDCHAR*)SvPVX(sv));  /* set length */

#else /* SV_FAST_GETS */

    /*The big, slow, and stupid way */

d3223 1
d3226 1
a3226 1
screamer:
d3230 1
a3230 1
	    while ((i = getc(fp)) != EOF && (*bp++ = i) != rslast && bp < bpe)
d3235 5
a3239 2
	    cnt = fread((char*)buf, 1, sizeof(buf), fp);
	    i = cnt ? (U8)buf[cnt - 1] : EOF;
d3243 1
a3243 1
	    sv_catpvn(sv, buf, cnt);
d3245 1
a3245 1
	    sv_setpvn(sv, buf, cnt);
d3250 1
a3250 1
	     bcmp(SvPVX(sv) + SvCUR(sv) - rslen, rsptr, rslen)))
d3253 13
a3265 1
	    goto screamer;
a3268 2
#endif /* SV_FAST_GETS */

d3271 1
a3271 1
	    i = getc(fp);
d3273 1
a3273 1
		ungetc(i,fp);
d3282 1
d3305 3
a3307 3
    if (flags & SVp_IOK) {
	(void)SvIOK_only(sv);
	++SvIVX(sv);
d3310 7
a3316 3
    if (flags & SVp_NOK) {
	SvNVX(sv) += 1.0;
	(void)SvNOK_only(sv);
d3330 2
a3331 1
        sv_setnv(sv,atof(SvPVX(sv)) + 1.0);  /* punt */
a3379 5
    if (flags & SVp_IOK) {
	(void)SvIOK_only(sv);
	--SvIVX(sv);
	return;
    }
d3385 9
d3401 2
a3402 1
    sv_setnv(sv,atof(SvPVX(sv)) - 1.0);
d3413 1
a3413 1
    tmps_max += 128;
d3423 1
a3423 1
    new_SV();
d3440 1
a3440 1
    new_SV();
d3474 1
a3474 1
    new_SV();
d3484 29
d3519 1
a3519 1
    new_SV();
d3533 1
a3533 1
    new_SV();
d3547 1
a3547 1
    new_SV();
d3558 13
d3585 1
a3585 1
    new_SV();
d3637 2
a3638 2
	      entry = entry->hent_next) {
		if (!todo[(U8)*entry->hent_key])
d3640 1
a3640 1
		gv = (GV*)entry->hent_val;
a3644 1
		    SvTAINT(sv);
d3647 1
d3652 1
a3652 3
		if (GvHV(gv)) {
		    if (HvNAME(GvHV(gv)))
			continue;
d3664 34
d3745 1
a3745 1
	if (lref && !GvCV(gv)) {
d3749 2
a3750 2
	    gv_efullname(tmpsv, gv);
	    newSUB(start_subparse(),
d3755 1
a3755 1
	    if (!GvCV(gv))
d3758 1
a3758 1
	return GvCV(gv);
d3792 1
a3792 1
#endif /* SvTRUE */
d3795 3
a3797 2
IV SvIV(Sv)
register SV *Sv;
d3799 3
a3801 3
    if (SvIOK(Sv))
	return SvIVX(Sv);
    return sv_2iv(Sv);
d3803 1
a3803 1
#endif /* SvIV */
d3805 10
d3817 3
a3819 2
double SvNV(Sv)
register SV *Sv;
d3821 3
a3823 5
    if (SvNOK(Sv))
	return SvNVX(Sv);
    if (SvIOK(Sv))
	return (double)SvIVX(Sv);
    return sv_2nv(Sv);
d3825 1
a3825 1
#endif /* SvNV */
d3881 1
a3881 1
	    DEBUG_c(fprintf(stderr,"0x%lx 2pv(%s)\n",
d3925 4
d3942 4
d3962 1
a3962 1
    new_SV();
d4033 5
a4037 2
	if (SvOBJECT(ref) && SvTYPE(ref) != SVt_PVIO)
	    --sv_objcount;
d4040 2
a4041 1
    ++sv_objcount;
d4046 4
a4049 4
    SvAMAGIC_off(sv);
    if (Gv_AMG(stash)) {
      SvAMAGIC_on(sv);
    }
d4062 1
a4062 1
	gp_free(sv);
d4084 619
d4708 2
a4709 2
    char tmpbuf[1024];
    char *d = tmpbuf;
d4714 1
a4714 1
	fprintf(stderr, "SV = 0\n");
d4721 63
a4783 31
    sprintf(d, "(0x%lx)\n  REFCNT = %ld\n  FLAGS = (",
	(unsigned long)SvANY(sv), (long)SvREFCNT(sv));
    d += strlen(d);
    if (flags & SVs_PADBUSY)	strcat(d, "PADBUSY,");
    if (flags & SVs_PADTMP)	strcat(d, "PADTMP,");
    if (flags & SVs_PADMY)	strcat(d, "PADMY,");
    if (flags & SVs_TEMP)	strcat(d, "TEMP,");
    if (flags & SVs_OBJECT)	strcat(d, "OBJECT,");
    if (flags & SVs_GMG)	strcat(d, "GMG,");
    if (flags & SVs_SMG)	strcat(d, "SMG,");
    if (flags & SVs_RMG)	strcat(d, "RMG,");
    d += strlen(d);

    if (flags & SVf_IOK)	strcat(d, "IOK,");
    if (flags & SVf_NOK)	strcat(d, "NOK,");
    if (flags & SVf_POK)	strcat(d, "POK,");
    if (flags & SVf_ROK)	strcat(d, "ROK,");
    if (flags & SVf_OOK)	strcat(d, "OOK,");
    if (flags & SVf_FAKE)	strcat(d, "FAKE,");
    if (flags & SVf_READONLY)	strcat(d, "READONLY,");
    d += strlen(d);

    if (flags & SVp_IOK)	strcat(d, "pIOK,");
    if (flags & SVp_NOK)	strcat(d, "pNOK,");
    if (flags & SVp_POK)	strcat(d, "pPOK,");
    if (flags & SVp_SCREAM)	strcat(d, "SCREAM,");
    d += strlen(d);
    if (d[-1] == ',')
	d--;
    *d++ = ')';
    *d = '\0';
d4785 1
a4785 1
    fprintf(stderr, "SV = ");
d4788 1
a4788 1
	fprintf(stderr,"NULL%s\n", tmpbuf);
d4791 1
a4791 1
	fprintf(stderr,"IV%s\n", tmpbuf);
d4794 1
a4794 1
	fprintf(stderr,"NV%s\n", tmpbuf);
d4797 1
a4797 1
	fprintf(stderr,"RV%s\n", tmpbuf);
d4800 1
a4800 1
	fprintf(stderr,"PV%s\n", tmpbuf);
d4803 1
a4803 1
	fprintf(stderr,"PVIV%s\n", tmpbuf);
d4806 1
a4806 1
	fprintf(stderr,"PVNV%s\n", tmpbuf);
d4809 1
a4809 1
	fprintf(stderr,"PVBM%s\n", tmpbuf);
d4812 1
a4812 1
	fprintf(stderr,"PVMG%s\n", tmpbuf);
d4815 1
a4815 1
	fprintf(stderr,"PVLV%s\n", tmpbuf);
d4818 1
a4818 1
	fprintf(stderr,"PVAV%s\n", tmpbuf);
d4821 1
a4821 1
	fprintf(stderr,"PVHV%s\n", tmpbuf);
d4824 1
a4824 1
	fprintf(stderr,"PVCV%s\n", tmpbuf);
d4827 1
a4827 1
	fprintf(stderr,"PVGV%s\n", tmpbuf);
d4830 1
a4830 1
	fprintf(stderr,"PVFM%s\n", tmpbuf);
d4833 1
a4833 1
	fprintf(stderr,"PVIO%s\n", tmpbuf);
d4836 1
a4836 1
	fprintf(stderr,"UNKNOWN%s\n", tmpbuf);
d4840 5
a4844 3
	fprintf(stderr, "  IV = %ld\n", (long)SvIVX(sv));
    if (type >= SVt_PVNV || type == SVt_NV)
	fprintf(stderr, "  NV = %.*g\n", DBL_DIG, SvNVX(sv));
d4846 1
a4846 1
	fprintf(stderr, "  RV = 0x%lx\n", (long)SvRV(sv));
d4854 1
a4854 1
	    fprintf(stderr, "  PV = 0x%lx \"%s\"\n  CUR = %ld\n  LEN = %ld\n",
d4857 1
a4857 1
	    fprintf(stderr, "  PV = 0\n");
d4861 1
a4861 1
	    fprintf(stderr, "  MAGIC = 0x%lx\n", (long)SvMAGIC(sv));
d4864 1
a4864 1
	    fprintf(stderr, "  STASH = %s\n", HvNAME(SvSTASH(sv)));
d4868 4
a4871 4
	fprintf(stderr, "  TYPE = %c\n", LvTYPE(sv));
	fprintf(stderr, "  TARGOFF = %ld\n", (long)LvTARGOFF(sv));
	fprintf(stderr, "  TARGLEN = %ld\n", (long)LvTARGLEN(sv));
	fprintf(stderr, "  TARG = 0x%lx\n", (long)LvTARG(sv));
d4875 5
a4879 5
	fprintf(stderr, "  ARRAY = 0x%lx\n", (long)AvARRAY(sv));
	fprintf(stderr, "  ALLOC = 0x%lx\n", (long)AvALLOC(sv));
	fprintf(stderr, "  FILL = %ld\n", (long)AvFILL(sv));
	fprintf(stderr, "  MAX = %ld\n", (long)AvMAX(sv));
	fprintf(stderr, "  ARYLEN = 0x%lx\n", (long)AvARYLEN(sv));
d4881 6
a4886 7
	d = tmpbuf;
	if (flags & AVf_REAL)	strcat(d, "REAL,");
	if (flags & AVf_REIFY)	strcat(d, "REIFY,");
	if (flags & AVf_REUSED)	strcat(d, "REUSED,");
	if (*d)
	    d[strlen(d)-1] = '\0';
	fprintf(stderr, "  FLAGS = (%s)\n", d);
d4889 6
a4894 6
	fprintf(stderr, "  ARRAY = 0x%lx\n",(long)HvARRAY(sv));
	fprintf(stderr, "  KEYS = %ld\n", (long)HvKEYS(sv));
	fprintf(stderr, "  FILL = %ld\n", (long)HvFILL(sv));
	fprintf(stderr, "  MAX = %ld\n", (long)HvMAX(sv));
	fprintf(stderr, "  RITER = %ld\n", (long)HvRITER(sv));
	fprintf(stderr, "  EITER = 0x%lx\n",(long) HvEITER(sv));
d4896 1
a4896 1
	    fprintf(stderr, "  PMROOT = 0x%lx\n",(long)HvPMROOT(sv));
d4898 1
a4898 1
	    fprintf(stderr, "  NAME = \"%s\"\n", HvNAME(sv));
d4900 4
d4905 15
a4919 10
    case SVt_PVCV:
	fprintf(stderr, "  STASH = 0x%lx\n", (long)CvSTASH(sv));
	fprintf(stderr, "  START = 0x%lx\n", (long)CvSTART(sv));
	fprintf(stderr, "  ROOT = 0x%lx\n", (long)CvROOT(sv));
	fprintf(stderr, "  XSUB = 0x%lx\n", (long)CvXSUB(sv));
	fprintf(stderr, "  XSUBANY = %ld\n", (long)CvXSUBANY(sv).any_i32);
	fprintf(stderr, "  FILEGV = 0x%lx\n", (long)CvFILEGV(sv));
	fprintf(stderr, "  DEPTH = %ld\n", (long)CvDEPTH(sv));
	fprintf(stderr, "  PADLIST = 0x%lx\n", (long)CvPADLIST(sv));
	fprintf(stderr, "  OUTSIDE = 0x%lx\n", (long)CvOUTSIDE(sv));
d4921 1
a4921 1
	    fprintf(stderr, "  LINES = %ld\n", (long)FmLINES(sv));
d4924 16
a4939 17
	fprintf(stderr, "  NAME = %s\n", GvNAME(sv));
	fprintf(stderr, "  NAMELEN = %ld\n", (long)GvNAMELEN(sv));
	fprintf(stderr, "  STASH = 0x%lx\n", (long)GvSTASH(sv));
	fprintf(stderr, "  GP = 0x%lx\n", (long)GvGP(sv));
	fprintf(stderr, "    SV = 0x%lx\n", (long)GvSV(sv));
	fprintf(stderr, "    REFCNT = %ld\n", (long)GvREFCNT(sv));
	fprintf(stderr, "    IO = 0x%lx\n", (long)GvIOp(sv));
	fprintf(stderr, "    FORM = 0x%lx\n", (long)GvFORM(sv));
	fprintf(stderr, "    AV = 0x%lx\n", (long)GvAV(sv));
	fprintf(stderr, "    HV = 0x%lx\n", (long)GvHV(sv));
	fprintf(stderr, "    CV = 0x%lx\n", (long)GvCV(sv));
	fprintf(stderr, "    CVGEN = 0x%lx\n", (long)GvCVGEN(sv));
	fprintf(stderr, "    LASTEXPR = %ld\n", (long)GvLASTEXPR(sv));
	fprintf(stderr, "    LINE = %ld\n", (long)GvLINE(sv));
	fprintf(stderr, "    FLAGS = 0x%x\n", (int)GvFLAGS(sv));
	fprintf(stderr, "    STASH = 0x%lx\n", (long)GvSTASH(sv));
	fprintf(stderr, "    EGV = 0x%lx\n", (long)GvEGV(sv));
d4942 16
a4957 16
	fprintf(stderr, "  IFP = 0x%lx\n", (long)IoIFP(sv));
	fprintf(stderr, "  OFP = 0x%lx\n", (long)IoOFP(sv));
	fprintf(stderr, "  DIRP = 0x%lx\n", (long)IoDIRP(sv));
	fprintf(stderr, "  LINES = %ld\n", (long)IoLINES(sv));
	fprintf(stderr, "  PAGE = %ld\n", (long)IoPAGE(sv));
	fprintf(stderr, "  PAGE_LEN = %ld\n", (long)IoPAGE_LEN(sv));
	fprintf(stderr, "  LINES_LEFT = %ld\n", (long)IoLINES_LEFT(sv));
	fprintf(stderr, "  TOP_NAME = %s\n", IoTOP_NAME(sv));
	fprintf(stderr, "  TOP_GV = 0x%lx\n", (long)IoTOP_GV(sv));
	fprintf(stderr, "  FMT_NAME = %s\n", IoFMT_NAME(sv));
	fprintf(stderr, "  FMT_GV = 0x%lx\n", (long)IoFMT_GV(sv));
	fprintf(stderr, "  BOTTOM_NAME = %s\n", IoBOTTOM_NAME(sv));
	fprintf(stderr, "  BOTTOM_GV = 0x%lx\n", (long)IoBOTTOM_GV(sv));
	fprintf(stderr, "  SUBPROCESS = %ld\n", (long)IoSUBPROCESS(sv));
	fprintf(stderr, "  TYPE = %c\n", IoTYPE(sv));
	fprintf(stderr, "  FLAGS = 0x%lx\n", (long)IoFLAGS(sv));
a4967 35

IO*
sv_2io(sv)
SV *sv;
{
    IO* io;
    GV* gv;

    switch (SvTYPE(sv)) {
    case SVt_PVIO:
	io = (IO*)sv;
	break;
    case SVt_PVGV:
	gv = (GV*)sv;
	io = GvIO(gv);
	if (!io)
	    croak("Bad filehandle: %s", GvNAME(gv));
	break;
    default:
	if (!SvOK(sv))
	    croak(no_usym, "filehandle");
	if (SvROK(sv))
	    return sv_2io(SvRV(sv));
	gv = gv_fetchpv(SvPV(sv,na), FALSE, SVt_PVIO);
	if (gv)
	    io = GvIO(gv);
	else
	    io = 0;
	if (!io)
	    croak("Bad filehandle: %s", SvPV(sv,na));
	break;
    }
    return io;
}

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d39 1
a39 1
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE) && !defined(__QNX__)
a42 8
#ifdef PERL_OBJECT
#define FCALL this->*f
#define VTBL this->*vtbl

#else /* !PERL_OBJECT */

static IV asIV _((SV* sv));
static UV asUV _((SV* sv));
d44 5
a48 4
static void more_xiv _((void));
static void more_xnv _((void));
static void more_xpv _((void));
static void more_xrv _((void));
d58 1
a59 13
static void sv_check_thinkfirst _((SV *sv));

#ifndef PURIFY
static void *my_safemalloc(MEM_SIZE size);
#endif

typedef void (*SVFUNC) _((SV*));
#define VTBL *vtbl
#define FCALL *f

#endif /* PERL_OBJECT */

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) sv_check_thinkfirst(sv)
d63 2
a64 86
#define new_SV(p)			\
    do {				\
	LOCK_SV_MUTEX;			\
	(p) = (SV*)safemalloc(sizeof(SV)); \
	reg_add(p);			\
	UNLOCK_SV_MUTEX;		\
    } while (0)

#define del_SV(p)			\
    do {				\
	LOCK_SV_MUTEX;			\
	reg_remove(p);			\
        Safefree((char*)(p));		\
	UNLOCK_SV_MUTEX;		\
    } while (0)

static SV **registry;
static I32 registry_size;

#define REGHASH(sv,size)  ((((U32)(sv)) >> 2) % (size))

#define REG_REPLACE(sv,a,b) \
    do {				\
	void* p = sv->sv_any;		\
	I32 h = REGHASH(sv, registry_size);	\
	I32 i = h;			\
	while (registry[i] != (a)) {	\
	    if (++i >= registry_size)	\
		i = 0;			\
	    if (i == h)			\
		die("SV registry bug");	\
	}				\
	registry[i] = (b);		\
    } while (0)

#define REG_ADD(sv)	REG_REPLACE(sv,Nullsv,sv)
#define REG_REMOVE(sv)	REG_REPLACE(sv,sv,Nullsv)

static void
reg_add(sv)
SV* sv;
{
    if (PL_sv_count >= (registry_size >> 1))
    {
	SV **oldreg = registry;
	I32 oldsize = registry_size;

	registry_size = registry_size ? ((registry_size << 2) + 1) : 2037;
	Newz(707, registry, registry_size, SV*);

	if (oldreg) {
	    I32 i;

	    for (i = 0; i < oldsize; ++i) {
		SV* oldsv = oldreg[i];
		if (oldsv)
		    REG_ADD(oldsv);
	    }
	    Safefree(oldreg);
	}
    }

    REG_ADD(sv);
    ++PL_sv_count;
}

static void
reg_remove(sv)
SV* sv;
{
    REG_REMOVE(sv);
    --PL_sv_count;
}

static void
visit(f)
SVFUNC f;
{
    I32 i;

    for (i = 0; i < registry_size; ++i) {
	SV* sv = registry[i];
	if (sv && SvTYPE(sv) != SVTYPEMASK)
	    (*f)(sv);
    }
}
d73 1
a73 1
	Safefree(ptr);
d76 1
a76 1
#else /* ! PURIFY */
d78 8
a85 3
/*
 * "A time to plant, and a time to uproot what was planted..."
 */
d87 12
a98 24
#define plant_SV(p)			\
    do {				\
	SvANY(p) = (void *)PL_sv_root;	\
	SvFLAGS(p) = SVTYPEMASK;	\
	PL_sv_root = (p);			\
	--PL_sv_count;			\
    } while (0)

/* sv_mutex must be held while calling uproot_SV() */
#define uproot_SV(p)			\
    do {				\
	(p) = PL_sv_root;			\
	PL_sv_root = (SV*)SvANY(p);	\
	++PL_sv_count;			\
    } while (0)

#define new_SV(p)	do {	\
	LOCK_SV_MUTEX;		\
	if (PL_sv_root)		\
	    uproot_SV(p);	\
	else			\
	    (p) = more_sv();	\
	UNLOCK_SV_MUTEX;	\
    } while (0)
d101 8
d110 3
a112 11
#define del_SV(p)	do {	\
	LOCK_SV_MUTEX;		\
	if (PL_debug & 32768)	\
	    del_sv(p);		\
	else			\
	    plant_SV(p);	\
	UNLOCK_SV_MUTEX;	\
    } while (0)

STATIC void
del_sv(SV *p)
d114 1
a114 1
    if (PL_debug & 32768) {
d119 1
a119 1
	for (sva = PL_sv_arenaroot; sva; sva = (SV *) SvANY(sva)) {
d130 3
a132 1
    plant_SV(p);
d134 5
d140 1
a140 5
#else /* ! DEBUGGING */

#define del_SV(p)   plant_SV(p)

#endif /* DEBUGGING */
d143 4
a146 1
sv_add_arena(char *ptr, U32 size, U32 flags)
d154 1
a154 1
    SvANY(sva) = (void *) PL_sv_arenaroot;		/* ptr to next arena */
d158 2
a159 2
    PL_sv_arenaroot = sva;
    PL_sv_root = sva + 1;
d172 2
a173 3
/* sv_mutex must be held while calling more_sv() */
STATIC SV*
more_sv(void)
d175 3
a177 5
    register SV* sv;

    if (PL_nice_chunk) {
	sv_add_arena(PL_nice_chunk, PL_nice_chunk_size, 0);
	PL_nice_chunk = Nullch;
d179 3
a181 7
    else {
	char *chunk;                /* must use New here to match call to */
	New(704,chunk,1008,char);   /* Safefree() in sv_free_arenas()     */
	sv_add_arena(chunk, 1008, 0);
    }
    uproot_SV(sv);
    return sv;
d183 1
d185 2
a186 2
STATIC void
visit(SVFUNC f)
d192 2
a193 1
    for (sva = PL_sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
d195 6
a200 3
	for (sv = sva + 1; sv < svend; ++sv) {
	    if (SvTYPE(sv) != SVTYPEMASK)
		(FCALL)(sv);
a204 12
#endif /* PURIFY */

STATIC void
do_report_used(SV *sv)
{
    if (SvTYPE(sv) != SVTYPEMASK) {
	/* XXX Perhaps this ought to go to Perl_debug_log, if DEBUGGING. */
	PerlIO_printf(PerlIO_stderr(), "****\n");
	sv_dump(sv);
    }
}

d206 1
a206 7
sv_report_used(void)
{
    visit(FUNC_NAME_TO_PTR(do_report_used));
}

STATIC void
do_clean_objs(SV *sv)
d208 3
d213 17
a229 5
    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
	DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(sv));)
	SvROK_off(sv);
	SvRV(sv) = 0;
	SvREFCNT_dec(rv);
d231 16
a246 17

    /* XXX Might want to check arrays, etc. */
}

#ifndef DISABLE_DESTRUCTOR_KLUDGE
STATIC void
do_clean_named_objs(SV *sv)
{
    if (SvTYPE(sv) == SVt_PVGV) {
	if ( SvOBJECT(GvSV(sv)) ||
	     GvAV(sv) && SvOBJECT(GvAV(sv)) ||
	     GvHV(sv) && SvOBJECT(GvHV(sv)) ||
	     GvIO(sv) && SvOBJECT(GvIO(sv)) ||
	     GvCV(sv) && SvOBJECT(GvCV(sv)) )
	{
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning named glob object:\n "), sv_dump(sv));)
	    SvREFCNT_dec(sv);
a249 1
#endif
d252 1
a252 1
sv_clean_objs(void)
d254 3
a256 8
    PL_in_clean_objs = TRUE;
    visit(FUNC_NAME_TO_PTR(do_clean_objs));
#ifndef DISABLE_DESTRUCTOR_KLUDGE
    /* some barnacles may yet remain, clinging to typeglobs */
    visit(FUNC_NAME_TO_PTR(do_clean_named_objs));
#endif
    PL_in_clean_objs = FALSE;
}
d258 12
a269 14
STATIC void
do_clean_all(SV *sv)
{
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops: SV at 0x%lx\n", sv) );)
    SvFLAGS(sv) |= SVf_BREAK;
    SvREFCNT_dec(sv);
}

void
sv_clean_all(void)
{
    PL_in_clean_all = TRUE;
    visit(FUNC_NAME_TO_PTR(do_clean_all));
    PL_in_clean_all = FALSE;
d273 1
a273 1
sv_free_arenas(void)
d281 1
a281 1
    for (sva = PL_sv_arenaroot; sva; sva = svanext) {
d287 1
a287 1
	    Safefree((void *)sva);
d289 1
d291 13
a303 6
    if (PL_nice_chunk)
	Safefree(PL_nice_chunk);
    PL_nice_chunk = Nullch;
    PL_nice_chunk_size = 0;
    PL_sv_arenaroot = 0;
    PL_sv_root = 0;
d306 3
a308 2
STATIC XPVIV*
new_xiv(void)
d310 18
a327 37
    IV* xiv;
    LOCK_SV_MUTEX;
    if (!PL_xiv_root)
	more_xiv();
    xiv = PL_xiv_root;
    /*
     * See comment in more_xiv() -- RAM.
     */
    PL_xiv_root = *(IV**)xiv;
    UNLOCK_SV_MUTEX;
    return (XPVIV*)((char*)xiv - STRUCT_OFFSET(XPVIV, xiv_iv));
}

STATIC void
del_xiv(XPVIV *p)
{
    IV* xiv = (IV*)((char*)(p) + STRUCT_OFFSET(XPVIV, xiv_iv));
    LOCK_SV_MUTEX;
    *(IV**)xiv = PL_xiv_root;
    PL_xiv_root = xiv;
    UNLOCK_SV_MUTEX;
}

STATIC void
more_xiv(void)
{
    register IV* xiv;
    register IV* xivend;
    XPV* ptr;
    New(705, ptr, 1008/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xiv_arenaroot;		/* linked list of xiv arenas */
    PL_xiv_arenaroot = ptr;			/* to keep Purify happy */

    xiv = (IV*) ptr;
    xivend = &xiv[1008 / sizeof(IV) - 1];
    xiv += (sizeof(XPV) - 1) / sizeof(IV) + 1;   /* fudge by size of XPV */
    PL_xiv_root = xiv;
d329 1
a329 1
	*(IV**)xiv = (IV *)(xiv + 1);
d332 2
a333 1
    *(IV**)xiv = 0;
d336 2
a337 2
STATIC XPVNV*
new_xnv(void)
d340 15
a354 17
    LOCK_SV_MUTEX;
    if (!PL_xnv_root)
	more_xnv();
    xnv = PL_xnv_root;
    PL_xnv_root = *(double**)xnv;
    UNLOCK_SV_MUTEX;
    return (XPVNV*)((char*)xnv - STRUCT_OFFSET(XPVNV, xnv_nv));
}

STATIC void
del_xnv(XPVNV *p)
{
    double* xnv = (double*)((char*)(p) + STRUCT_OFFSET(XPVNV, xnv_nv));
    LOCK_SV_MUTEX;
     *(double**)xnv = PL_xnv_root;
     PL_xnv_root = xnv;
    UNLOCK_SV_MUTEX;
d357 2
a358 2
STATIC void
more_xnv(void)
d362 1
a362 1
    New(711, xnv, 1008/sizeof(double), double);
d365 1
a365 1
    PL_xnv_root = xnv;
d371 1
d374 2
a375 2
STATIC XRV*
new_xrv(void)
d378 14
a391 16
    LOCK_SV_MUTEX;
    if (!PL_xrv_root)
	more_xrv();
    xrv = PL_xrv_root;
    PL_xrv_root = (XRV*)xrv->xrv_rv;
    UNLOCK_SV_MUTEX;
    return xrv;
}

STATIC void
del_xrv(XRV *p)
{
    LOCK_SV_MUTEX;
     p->xrv_rv = (SV*)PL_xrv_root;
     PL_xrv_root = p;
    UNLOCK_SV_MUTEX;
d394 2
a395 2
STATIC void
more_xrv(void)
d399 2
a400 2
    New(712, PL_xrv_root, 1008/sizeof(XRV), XRV);
    xrv = PL_xrv_root;
d407 1
d410 2
a411 2
STATIC XPV*
new_xpv(void)
d414 6
a419 16
    LOCK_SV_MUTEX;
    if (!PL_xpv_root)
	more_xpv();
    xpv = PL_xpv_root;
    PL_xpv_root = (XPV*)xpv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpv;
}

STATIC void
del_xpv(XPV *p)
{
    LOCK_SV_MUTEX;
     p->xpv_pv = (char*)PL_xpv_root;
     PL_xpv_root = p;
    UNLOCK_SV_MUTEX;
d422 10
a431 2
STATIC void
more_xpv(void)
d435 2
a436 2
    New(713, PL_xpv_root, 1008/sizeof(XPV), XPV);
    xpv = PL_xpv_root;
d443 1
d448 1
a448 1
#define del_XIV(p) Safefree((char*)p)
d451 1
a451 1
#define del_XIV(p) del_xiv((XPVIV*) p)
d456 1
a456 1
#define del_XNV(p) Safefree((char*)p)
d459 1
a459 1
#define del_XNV(p) del_xnv((XPVNV*) p)
d464 1
a464 1
#define del_XRV(p) Safefree((char*)p)
d467 1
a467 1
#define del_XRV(p) del_xrv((XRV*) p)
d472 1
a472 1
#define del_XPV(p) Safefree((char*)p)
d475 1
a475 1
#define del_XPV(p) del_xpv((XPV *)p)
d478 32
a509 46
#ifdef PURIFY
#  define my_safemalloc(s) safemalloc(s)
#  define my_safefree(s) free(s)
#else
STATIC void* 
my_safemalloc(MEM_SIZE size)
{
    char *p;
    New(717, p, size, char);
    return (void*)p;
}
#  define my_safefree(s) Safefree(s)
#endif 

#define new_XPVIV() (void*)my_safemalloc(sizeof(XPVIV))
#define del_XPVIV(p) my_safefree((char*)p)
  
#define new_XPVNV() (void*)my_safemalloc(sizeof(XPVNV))
#define del_XPVNV(p) my_safefree((char*)p)
  
#define new_XPVMG() (void*)my_safemalloc(sizeof(XPVMG))
#define del_XPVMG(p) my_safefree((char*)p)
  
#define new_XPVLV() (void*)my_safemalloc(sizeof(XPVLV))
#define del_XPVLV(p) my_safefree((char*)p)
  
#define new_XPVAV() (void*)my_safemalloc(sizeof(XPVAV))
#define del_XPVAV(p) my_safefree((char*)p)
  
#define new_XPVHV() (void*)my_safemalloc(sizeof(XPVHV))
#define del_XPVHV(p) my_safefree((char*)p)
  
#define new_XPVCV() (void*)my_safemalloc(sizeof(XPVCV))
#define del_XPVCV(p) my_safefree((char*)p)
  
#define new_XPVGV() (void*)my_safemalloc(sizeof(XPVGV))
#define del_XPVGV(p) my_safefree((char*)p)
  
#define new_XPVBM() (void*)my_safemalloc(sizeof(XPVBM))
#define del_XPVBM(p) my_safefree((char*)p)
  
#define new_XPVFM() (void*)my_safemalloc(sizeof(XPVFM))
#define del_XPVFM(p) my_safefree((char*)p)
  
#define new_XPVIO() (void*)my_safemalloc(sizeof(XPVIO))
#define del_XPVIO(p) my_safefree((char*)p)
d512 3
a514 1
sv_upgrade(register SV *sv, U32 mt)
d578 1
d593 1
d604 1
d696 2
a697 2
	AvMAX(sv)	= -1;
	AvFILLp(sv)	= -1;
d790 1
d792 2
a793 1
sv_peek(SV *sv)
d795 1
a795 3
#ifdef DEBUGGING
    SV *t = sv_newmortal();
    STRLEN prevlen;
a797 1
    sv_setpvn(t, "", 0);
d800 1
a800 1
	sv_catpv(t, "VOID");
d804 1
a804 1
	sv_catpv(t, "WILD");
d807 3
a809 3
    else if (sv == &PL_sv_undef || sv == &PL_sv_no || sv == &PL_sv_yes) {
	if (sv == &PL_sv_undef) {
	    sv_catpv(t, "SV_UNDEF");
d815 2
a816 2
	else if (sv == &PL_sv_no) {
	    sv_catpv(t, "SV_NO");
d826 1
a826 1
	    sv_catpv(t, "SV_YES");
d836 2
a837 1
	sv_catpv(t, ":");
d840 1
a840 1
	sv_catpv(t, "(");
d844 3
a846 5
	sv_catpv(t, "\\");
	if (SvCUR(t) + unref > 10) {
	    SvCUR(t) = unref + 3;
	    *SvEND(t) = '\0';
	    sv_catpv(t, "...");
d854 1
a854 1
	sv_catpv(t, "FREED");
d858 2
a859 2
	sv_catpv(t, "UNDEF");
	goto finish;
d861 1
a861 1
	sv_catpv(t, "IV");
d864 1
a864 1
	sv_catpv(t, "NV");
d867 1
a867 1
	sv_catpv(t, "RV");
d870 1
a870 1
	sv_catpv(t, "PV");
d873 1
a873 1
	sv_catpv(t, "PVIV");
d876 1
a876 1
	sv_catpv(t, "PVNV");
d879 1
a879 1
	sv_catpv(t, "PVMG");
d882 1
a882 1
	sv_catpv(t, "PVLV");
d885 1
a885 1
	sv_catpv(t, "AV");
d888 1
a888 1
	sv_catpv(t, "HV");
d892 1
a892 1
	    sv_catpvf(t, "CV(%s)", GvNAME(CvGV(sv)));
d894 1
a894 1
	    sv_catpv(t, "CV()");
d897 1
a897 1
	sv_catpv(t, "GV");
d900 1
a900 1
	sv_catpv(t, "BM");
d903 1
a903 1
	sv_catpv(t, "FM");
d906 1
a906 1
	sv_catpv(t, "IO");
d909 1
d913 1
a913 1
	    sv_catpv(t, "(null)");
d915 1
a915 1
	    sv_catpvf(t, "(%ld+\"%.127s\")",(long)SvIVX(sv),SvPVX(sv));
d917 1
a917 5
	    sv_catpvf(t, "(\"%.127s\")",SvPVX(sv));
    }
    else if (SvNOKp(sv)) {
	SET_NUMERIC_STANDARD();
	sv_catpvf(t, "(%g)",SvNVX(sv));
d919 2
d922 1
a922 1
	sv_catpvf(t, "(%ld)",(long)SvIVX(sv));
d924 1
a924 1
	sv_catpv(t, "()");
d928 1
d930 2
a931 1
	    sv_catpv(t, ")");
d933 1
a933 4
    return SvPV(t, prevlen);
#else	/* DEBUGGING */
    return "";
#endif	/* DEBUGGING */
d935 1
d938 2
a939 1
sv_backoff(register SV *sv)
d954 2
d957 1
a957 1
sv_grow(register SV *sv, register I32 newlen)
d959 1
a959 1
sv_grow(SV* sv, unsigned long newlen)
d964 1
a964 1
#ifdef HAS_64K_LIMIT
d966 1
a966 1
	PerlIO_printf(Perl_debug_log, "Allocation too large: %lx\n", newlen);
d969 1
a969 1
#endif /* HAS_64K_LIMIT */
a980 4
#ifdef HAS_64K_LIMIT
	if (newlen >= 0x10000)
	    newlen = 0xFFFF;
#endif
d985 1
a985 8
	if (SvLEN(sv) && s) {
#if defined(MYMALLOC) && !defined(PURIFY) && !defined(LEAKTEST)
	    STRLEN l = malloced_size((void*)SvPVX(sv));
	    if (newlen <= l) {
		SvLEN_set(sv, l);
		return s;
	    } else
#endif
a986 1
	}
d996 3
a998 1
sv_setiv(register SV *sv, IV i)
d1000 6
a1005 1
    SV_CHECK_THINKFIRST(sv);
d1029 2
a1030 5
	{
	    dTHR;
	    croak("Can't coerce %s to integer in %s", sv_reftype(sv,0),
		  op_desc[PL_op->op_type]);
	}
d1038 3
a1040 1
sv_setiv_mg(register SV *sv, IV i)
d1042 6
a1047 24
    sv_setiv(sv,i);
    SvSETMAGIC(sv);
}

void
sv_setuv(register SV *sv, UV u)
{
    if (u <= IV_MAX)
	sv_setiv(sv, u);
    else
	sv_setnv(sv, (double)u);
}

void
sv_setuv_mg(register SV *sv, UV u)
{
    sv_setuv(sv,u);
    SvSETMAGIC(sv);
}

void
sv_setnv(register SV *sv, double num)
{
    SV_CHECK_THINKFIRST(sv);
d1053 1
d1058 7
a1065 1

d1077 2
a1078 5
	{
	    dTHR;
	    croak("Can't coerce %s to number in %s", sv_reftype(sv,0),
		  op_name[PL_op->op_type]);
	}
d1085 3
a1087 9
void
sv_setnv_mg(register SV *sv, double num)
{
    sv_setnv(sv,num);
    SvSETMAGIC(sv);
}

STATIC void
not_a_number(SV *sv)
a1088 1
    dTHR;
d1092 5
a1096 7
    char *limit = tmpbuf + sizeof(tmpbuf) - 8;
                  /* each *s can expand to 4 chars + "...\0",
                     i.e. need room for 8 chars */

    for (s = SvPVX(sv); *s && d < limit; s++) {
	int ch = *s & 0xFF;
	if (ch & 128 && !isPRINT_LC(ch)) {
d1101 1
a1101 17
	if (ch == '\n') {
	    *d++ = '\\';
	    *d++ = 'n';
	}
	else if (ch == '\r') {
	    *d++ = '\\';
	    *d++ = 'r';
	}
	else if (ch == '\f') {
	    *d++ = '\\';
	    *d++ = 'f';
	}
	else if (ch == '\\') {
	    *d++ = '\\';
	    *d++ = '\\';
	}
	else if (isPRINT_LC(ch))
d1105 1
a1105 1
	    *d++ = toCTRL(ch);
d1115 1
a1115 1
    if (PL_op)
d1117 1
a1117 1
		op_name[PL_op->op_type]);
d1123 2
a1124 1
sv_2iv(register SV *sv)
d1138 4
a1141 9
	if (SvPOKp(sv) && SvLEN(sv))
	    return asIV(sv);
	if (!SvROK(sv)) {
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
		dTHR;
		if (!PL_localizing)
		    warn(warn_uninit);
	    }
	    return 0;
d1143 3
d1163 6
a1168 3
	    if (SvPOKp(sv) && SvLEN(sv))
		return asIV(sv);
	    if (PL_dowarn)
d1176 1
a1176 1
	break;
d1189 1
a1189 1
	    SvUVX(sv) = U_V(SvNVX(sv));
d1192 2
d1195 1
a1195 1
	SvIVX(sv) = asIV(sv);
d1198 1
a1198 2
	dTHR;
	if (PL_dowarn && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d1202 1
a1202 1
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2iv(%ld)\n",
d1207 3
a1209 2
UV
sv_2uv(register SV *sv)
d1212 1
a1212 1
	return 0;
a1214 2
	if (SvIOKp(sv))
	    return SvUVX(sv);
d1216 5
a1220 10
	    return U_V(SvNVX(sv));
	if (SvPOKp(sv) && SvLEN(sv))
	    return asUV(sv);
	if (!SvROK(sv)) {
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
		dTHR;
		if (!PL_localizing)
		    warn(warn_uninit);
	    }
	    return 0;
d1222 5
d1232 2
a1233 2
	  if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv, numer)))
	    return SvUV(tmpstr);
d1235 1
a1235 1
	  return (UV)SvRV(sv);
d1238 4
a1241 2
	    if (SvNOKp(sv)) {
		return U_V(SvNVX(sv));
d1243 3
a1245 3
	    if (SvPOKp(sv) && SvLEN(sv))
		return asUV(sv);
	    if (PL_dowarn)
d1247 1
a1247 1
	    return 0;
d1250 8
a1257 8
    switch (SvTYPE(sv)) {
    case SVt_NULL:
	sv_upgrade(sv, SVt_IV);
	break;
    case SVt_PV:
	sv_upgrade(sv, SVt_PVIV);
	break;
    case SVt_NV:
d1259 4
a1262 87
	break;
    }
    if (SvNOKp(sv)) {
	(void)SvIOK_on(sv);
	SvUVX(sv) = U_V(SvNVX(sv));
    }
    else if (SvPOKp(sv) && SvLEN(sv)) {
	(void)SvIOK_on(sv);
	SvUVX(sv) = asUV(sv);
    }
    else  {
	if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
	    dTHR;
	    if (!PL_localizing)
		warn(warn_uninit);
	}
	return 0;
    }
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2uv(%lu)\n",
	(unsigned long)sv,SvUVX(sv)));
    return SvUVX(sv);
}

double
sv_2nv(register SV *sv)
{
    if (!sv)
	return 0.0;
    if (SvGMAGICAL(sv)) {
	mg_get(sv);
	if (SvNOKp(sv))
	    return SvNVX(sv);
	if (SvPOKp(sv) && SvLEN(sv)) {
	    if (PL_dowarn && !SvIOKp(sv) && !looks_like_number(sv))
		not_a_number(sv);
	    SET_NUMERIC_STANDARD();
	    return atof(SvPVX(sv));
	}
	if (SvIOKp(sv))
	    return (double)SvIVX(sv);
        if (!SvROK(sv)) {
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
		dTHR;
		if (!PL_localizing)
		    warn(warn_uninit);
	    }
            return 0;
        }
    }
    if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
#ifdef OVERLOAD
	  SV* tmpstr;
	  if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)))
	    return SvNV(tmpstr);
#endif /* OVERLOAD */
	  return (double)(unsigned long)SvRV(sv);
	}
	if (SvREADONLY(sv)) {
	    if (SvPOKp(sv) && SvLEN(sv)) {
		if (PL_dowarn && !SvIOKp(sv) && !looks_like_number(sv))
		    not_a_number(sv);
		SET_NUMERIC_STANDARD();
		return atof(SvPVX(sv));
	    }
	    if (SvIOKp(sv))
		return (double)SvIVX(sv);
	    if (PL_dowarn)
		warn(warn_uninit);
	    return 0.0;
	}
    }
    if (SvTYPE(sv) < SVt_NV) {
	if (SvTYPE(sv) == SVt_IV)
	    sv_upgrade(sv, SVt_PVNV);
	else
	    sv_upgrade(sv, SVt_NV);
	DEBUG_c(SET_NUMERIC_STANDARD());
	DEBUG_c(PerlIO_printf(Perl_debug_log,
			      "0x%lx num(%g)\n",(unsigned long)sv,SvNVX(sv)));
    }
    else if (SvTYPE(sv) < SVt_PVNV)
	sv_upgrade(sv, SVt_PVNV);
    if (SvIOKp(sv) &&
	    (!SvPOKp(sv) || !strchr(SvPVX(sv),'.') || !looks_like_number(sv)))
    {
	SvNVX(sv) = (double)SvIVX(sv);
d1265 1
a1265 1
	if (PL_dowarn && !SvIOKp(sv) && !looks_like_number(sv))
a1266 1
	SET_NUMERIC_STANDARD();
d1270 1
a1270 2
	dTHR;
	if (PL_dowarn && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d1275 1
a1275 3
    DEBUG_c(SET_NUMERIC_STANDARD());
    DEBUG_c(PerlIO_printf(Perl_debug_log,
			  "0x%lx 2nv(%g)\n",(unsigned long)sv,SvNVX(sv)));
a1278 112
STATIC IV
asIV(SV *sv)
{
    I32 numtype = looks_like_number(sv);
    double d;

    if (numtype == 1)
	return atol(SvPVX(sv));
    if (!numtype && PL_dowarn)
	not_a_number(sv);
    SET_NUMERIC_STANDARD();
    d = atof(SvPVX(sv));
    if (d < 0.0)
	return I_V(d);
    else
	return (IV) U_V(d);
}

STATIC UV
asUV(SV *sv)
{
    I32 numtype = looks_like_number(sv);

#ifdef HAS_STRTOUL
    if (numtype == 1)
	return strtoul(SvPVX(sv), Null(char**), 10);
#endif
    if (!numtype && PL_dowarn)
	not_a_number(sv);
    SET_NUMERIC_STANDARD();
    return U_V(atof(SvPVX(sv)));
}

I32
looks_like_number(SV *sv)
{
    register char *s;
    register char *send;
    register char *sbegin;
    I32 numtype;
    STRLEN len;

    if (SvPOK(sv)) {
	sbegin = SvPVX(sv); 
	len = SvCUR(sv);
    }
    else if (SvPOKp(sv))
	sbegin = SvPV(sv, len);
    else
	return 1;
    send = sbegin + len;

    s = sbegin;
    while (isSPACE(*s))
	s++;
    if (*s == '+' || *s == '-')
	s++;

    /* next must be digit or '.' */
    if (isDIGIT(*s)) {
        do {
	    s++;
        } while (isDIGIT(*s));
        if (*s == '.') {
	    s++;
            while (isDIGIT(*s))  /* optional digits after "." */
                s++;
        }
    }
    else if (*s == '.') {
        s++;
        /* no digits before '.' means we need digits after it */
        if (isDIGIT(*s)) {
	    do {
	        s++;
            } while (isDIGIT(*s));
        }
        else
	    return 0;
    }
    else
        return 0;

    /*
     * we return 1 if the number can be converted to _integer_ with atol()
     * and 2 if you need (int)atof().
     */
    numtype = 1;

    /* we can have an optional exponent part */
    if (*s == 'e' || *s == 'E') {
	numtype = 2;
	s++;
	if (*s == '+' || *s == '-')
	    s++;
        if (isDIGIT(*s)) {
            do {
                s++;
            } while (isDIGIT(*s));
        }
        else
            return 0;
    }
    while (isSPACE(*s))
	s++;
    if (s >= send)
	return numtype;
    if (len == 10 && memEQ(sbegin, "0 but true", 10))
	return 1;
    return 0;
}

d1280 3
a1282 1
sv_2pv(register SV *sv, STRLEN *lp)
a1285 2
    SV *tsv;
    char tmpbuf[64];	/* Must fit sprintf/Gconvert of longest IV/NV */
d1298 1
a1298 2
	    (void)sprintf(tmpbuf,"%ld",(long)SvIVX(sv));
	    tsv = Nullsv;
d1302 1
a1302 3
	    SET_NUMERIC_STANDARD();
	    Gconvert(SvNVX(sv), DBL_DIG, 0, tmpbuf);
	    tsv = Nullsv;
a1305 5
	    if (PL_dowarn && !(SvFLAGS(sv) & SVs_PADTMP)) {
		dTHR;
		if (!PL_localizing)
		    warn(warn_uninit);
	    }
a1320 2
		MAGIC *mg;
		
a1321 45
		case SVt_PVMG:
		    if ( ((SvFLAGS(sv) &
			   (SVs_OBJECT|SVf_OK|SVs_GMG|SVs_SMG|SVs_RMG)) 
			  == (SVs_OBJECT|SVs_RMG))
			 && strEQ(s=HvNAME(SvSTASH(sv)), "Regexp")
			 && (mg = mg_find(sv, 'r'))) {
			dTHR;
			regexp *re = (regexp *)mg->mg_obj;

			if (!mg->mg_ptr) {
			    char *fptr = "msix";
			    char reflags[6];
			    char ch;
			    int left = 0;
			    int right = 4;
 			    U16 reganch = (re->reganch & PMf_COMPILETIME) >> 12;

 			    while(ch = *fptr++) {
 				if(reganch & 1) {
 				    reflags[left++] = ch;
 				}
 				else {
 				    reflags[right--] = ch;
 				}
 				reganch >>= 1;
 			    }
 			    if(left != 4) {
 				reflags[left] = '-';
 				left = 5;
 			    }

			    mg->mg_len = re->prelen + 4 + left;
			    New(616, mg->mg_ptr, mg->mg_len + 1 + left, char);
			    Copy("(?", mg->mg_ptr, 2, char);
			    Copy(reflags, mg->mg_ptr+2, left, char);
			    Copy(":", mg->mg_ptr+left+2, 1, char);
			    Copy(re->precomp, mg->mg_ptr+3+left, re->prelen, char);
			    mg->mg_ptr[mg->mg_len - 1] = ')';
			    mg->mg_ptr[mg->mg_len] = 0;
			}
			PL_reginterp_cnt += re->program[0].next_off;
			*lp = mg->mg_len;
			return mg->mg_ptr;
		    }
					/* Fall through */
d1329 2
a1330 1
		case SVt_PVBM:	s = "SCALAR";			break;
d1336 2
a1337 2
		case SVt_PVFM:	s = "FORMAT";			break;
		case SVt_PVIO:	s = "IO";			break;
a1339 1
		tsv = NEWSV(0,0);
d1341 2
a1342 1
		    sv_setpvf(tsv, "%s=%s", HvNAME(SvSTASH(sv)), s);
d1344 1
a1344 2
		    sv_setpv(tsv, s);
		sv_catpvf(tsv, "(0x%lx)", (unsigned long)sv);
d1352 1
a1352 3
		SET_NUMERIC_STANDARD();
		Gconvert(SvNVX(sv), DBL_DIG, 0, tmpbuf);
		tsv = Nullsv;
d1356 1
a1356 2
		(void)sprintf(tmpbuf,"%ld",(long)SvIVX(sv));
		tsv = Nullsv;
d1359 1
a1359 1
	    if (PL_dowarn)
d1365 2
a1366 1
    (void)SvUPGRADE(sv, SVt_PV);
a1377 2
	{
	    SET_NUMERIC_STANDARD();
a1378 1
	}
d1387 1
a1387 1
	    *--s = '\0';
a1390 1
	U32 oldIOK = SvIOK(sv);
d1393 2
d1396 1
a1396 1
	sv_setpviv(sv, SvIVX(sv));
d1398 1
a1398 5
	s = SvEND(sv);
	if (oldIOK)
	    SvIOK_on(sv);
	else
	    SvIOKp_on(sv);
d1401 1
a1401 2
	dTHR;
	if (PL_dowarn && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
d1406 1
d1410 1
a1410 1
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2pv(%s)\n",(unsigned long)sv,SvPVX(sv)));
d1418 4
a1421 5
	if (!tsv)
	    tsv = newSVpv(tmpbuf, 0);
	sv_2mortal(tsv);
	*lp = SvCUR(tsv);
	return SvPVX(tsv);
d1425 1
a1425 11
	char *t;

	if (tsv) {
	    sv_2mortal(tsv);
	    t = SvPVX(tsv);
	    len = SvCUR(tsv);
	}
	else {
	    t = tmpbuf;
	    len = strlen(tmpbuf);
	}
d1427 2
a1428 4
	if (len == 2 && t[0] == '-' && t[1] == '0') {
	    t = "0";
	    len = 1;
	}
d1431 1
a1431 1
	*lp = len;
d1434 2
a1435 2
	(void)strcpy(s, t);
	SvPOKp_on(sv);
d1442 2
a1443 1
sv_2bool(register SV *sv)
a1452 1
	dTHR;
d1461 5
a1465 5
	register XPV* Xpvtmp;
	if ((Xpvtmp = (XPV*)SvANY(sv)) &&
		(*Xpvtmp->xpv_pv > '0' ||
		Xpvtmp->xpv_cur > 1 ||
		(Xpvtmp->xpv_cur && *Xpvtmp->xpv_pv != '0')))
d1488 3
a1490 1
sv_setsv(SV *dstr, register SV *sstr)
a1491 1
    dTHR;
d1498 6
a1503 1
    SV_CHECK_THINKFIRST(dstr);
d1505 1
a1505 1
	sstr = &PL_sv_undef;
d1523 2
a1524 6
      undef_sstr:
	if (dtype != SVt_PVGV) {
	    (void)SvOK_off(dstr);
	    return;
	}
	break;
d1526 2
a1527 3
	if (SvIOK(sstr)) {
	    switch (dtype) {
	    case SVt_NULL:
d1529 1
a1529 2
		break;
	    case SVt_NV:
d1531 1
a1531 3
		break;
	    case SVt_RV:
	    case SVt_PV:
a1532 6
		break;
	    }
	    (void)SvIOK_only(dstr);
	    SvIVX(dstr) = SvIVX(sstr);
	    SvTAINT(dstr);
	    return;
d1534 1
a1534 2
	goto undef_sstr;

d1536 2
a1537 4
	if (SvNOK(sstr)) {
	    switch (dtype) {
	    case SVt_NULL:
	    case SVt_IV:
d1539 3
a1541 4
		break;
	    case SVt_RV:
	    case SVt_PV:
	    case SVt_PVIV:
a1542 6
		break;
	    }
	    SvNVX(dstr) = SvNVX(sstr);
	    (void)SvNOK_only(dstr);
	    SvTAINT(dstr);
	    return;
d1544 1
a1544 2
	goto undef_sstr;

d1552 1
a1552 1
		if (PL_curcop->cop_stash != GvSTASH(dstr))
a1560 1
    case SVt_PVFM:
d1572 5
d1581 1
a1581 1
	if (PL_op)
d1583 1
a1583 1
		op_name[PL_op->op_type]);
d1596 1
a1596 1
		GvSTASH(dstr) = (HV*)SvREFCNT_inc(GvSTASH(sstr));
a1600 5
	    /* ahem, death to those who redefine active sort subs */
	    else if (PL_curstackinfo->si_type == PERLSI_SORT
		     && GvCV(dstr) && PL_sortcop == CvSTART(GvCV(dstr)))
		croak("Can't redefine active sort subroutine %s",
		      GvNAME(dstr));
d1603 1
a1603 1
	    gp_free((GV*)dstr);
d1606 1
a1606 1
	    if (PL_curcop->cop_stash != GvSTASH(dstr))
d1614 3
a1616 1
	if (SvGMAGICAL(sstr)) {
a1617 10
	    if (SvTYPE(sstr) != stype) {
		stype = SvTYPE(sstr);
		if (stype == SVt_PVGV && dtype <= SVt_PVGV)
		    goto glob_assign;
	    }
	}
	if (stype == SVt_PVLV)
	    SvUPGRADE(dstr, SVt_PVNV);
	else
	    SvUPGRADE(dstr, stype);
d1634 2
a1635 1
		    GvGP(dstr) = gp_ref(gp);
d1637 2
a1638 2
		    GvLINE(dstr) = PL_curcop->cop_line;
		    GvEGV(dstr) = (GV*)dstr;
d1648 1
a1648 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d1657 1
a1657 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d1661 1
a1661 7
		    if (intro) {
			if (GvCVGEN(dstr) && GvCV(dstr) != (CV*)sref) {
			    SvREFCNT_dec(GvCV(dstr));
			    GvCV(dstr) = Nullcv;
			    GvCVGEN(dstr) = 0; /* Switch off cacheness. */
			    PL_sub_generation++;
			}
d1663 1
a1663 4
		    }
		    else
			dref = (SV*)GvCV(dstr);
		    if (GvCV(dstr) != (CV*)sref) {
d1666 7
a1672 29
			    if (!GvCVGEN((GV*)dstr) &&
				(CvROOT(cv) || CvXSUB(cv)))
			    {
				SV *const_sv = cv_const_sv(cv);
				bool const_changed = TRUE; 
				if(const_sv)
				    const_changed = sv_cmp(const_sv, 
					   op_const_sv(CvSTART((CV*)sref), 
						       Nullcv));
				/* ahem, death to those who redefine
				 * active sort subs */
				if (PL_curstackinfo->si_type == PERLSI_SORT &&
				      PL_sortcop == CvSTART(cv))
				    croak(
				    "Can't redefine active sort subroutine %s",
					  GvENAME((GV*)dstr));
				if (PL_dowarn || (const_changed && const_sv)) {
				    if (!(CvGV(cv) && GvSTASH(CvGV(cv))
					  && HvNAME(GvSTASH(CvGV(cv)))
					  && strEQ(HvNAME(GvSTASH(CvGV(cv))),
						   "autouse")))
					warn(const_sv ? 
					     "Constant subroutine %s redefined"
					     : "Subroutine %s redefined", 
					     GvENAME((GV*)dstr));
				}
			    }
			    cv_ckproto(cv, (GV*)dstr,
				       SvPOK(sref) ? SvPVX(sref) : Nullch);
d1674 2
a1676 1
			GvCVGEN(dstr) = 0; /* Switch off cacheness. */
a1677 1
			PL_sub_generation++;
d1679 1
a1679 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
d1695 1
a1695 1
		    if (PL_curcop->cop_stash != GvSTASH(dstr))
a1706 1
		(void)SvOOK_off(dstr);		/* backoff */
a1737 1
	    SvREFCNT(sstr) == 1 && 	/* and no other references to it? */
d1791 1
a1791 6
	if (dtype == SVt_PVGV) {
	    if (PL_dowarn)
		warn("Undefined value assigned to typeglob");
	}
	else
	    (void)SvOK_off(dstr);
d1797 4
a1800 1
sv_setsv_mg(SV *dstr, register SV *sstr)
d1802 7
a1808 11
    sv_setsv(dstr,sstr);
    SvSETMAGIC(dstr);
}

void
sv_setpvn(register SV *sv, register const char *ptr, register STRLEN len)
{
    register char *dptr;
    assert(len >= 0);  /* STRLEN is probably unsigned, so this may
			  elicit a warning, but it won't hurt. */
    SV_CHECK_THINKFIRST(sv);
d1817 2
a1818 3
    else
	sv_upgrade(sv, SVt_PV);

d1820 1
a1820 3
    dptr = SvPVX(sv);
    Move(ptr,dptr,len,char);
    dptr[len] = '\0';
d1822 1
d1828 3
a1830 8
sv_setpvn_mg(register SV *sv, register const char *ptr, register STRLEN len)
{
    sv_setpvn(sv,ptr,len);
    SvSETMAGIC(sv);
}

void
sv_setpv(register SV *sv, register const char *ptr)
d1834 6
a1839 1
    SV_CHECK_THINKFIRST(sv);
d1849 2
a1850 3
    else 
	sv_upgrade(sv, SVt_PV);

d1859 4
a1862 1
sv_setpv_mg(register SV *sv, register const char *ptr)
d1864 8
a1871 9
    sv_setpv(sv,ptr);
    SvSETMAGIC(sv);
}

void
sv_usepvn(register SV *sv, register char *ptr, register STRLEN len)
{
    SV_CHECK_THINKFIRST(sv);
    (void)SvUPGRADE(sv, SVt_PV);
d1888 3
a1890 22
sv_usepvn_mg(register SV *sv, register char *ptr, register STRLEN len)
{
    sv_usepvn(sv,ptr,len);
    SvSETMAGIC(sv);
}

STATIC void
sv_check_thinkfirst(register SV *sv)
{
    if (SvREADONLY(sv)) {
	dTHR;
	if (PL_curcop != &PL_compiling)
	    croak(no_modify);
    }
    if (SvROK(sv))
	sv_unref(sv);
}
    
void
sv_chop(register SV *sv, register char *ptr)	/* like set but assuming ptr is in sv */
                
                   
d1896 6
a1901 1
    SV_CHECK_THINKFIRST(sv);
d1918 4
a1921 1
sv_catpvn(register SV *sv, register char *ptr, register STRLEN len)
d1938 3
a1940 8
sv_catpvn_mg(register SV *sv, register char *ptr, register STRLEN len)
{
    sv_catpvn(sv,ptr,len);
    SvSETMAGIC(sv);
}

void
sv_catsv(SV *dstr, register SV *sstr)
d1951 3
a1953 8
sv_catsv_mg(SV *dstr, register SV *sstr)
{
    sv_catsv(dstr,sstr);
    SvSETMAGIC(dstr);
}

void
sv_catpv(register SV *sv, register char *ptr)
a1971 7
void
sv_catpv_mg(register SV *sv, register char *ptr)
{
    sv_catpv(sv,ptr);
    SvSETMAGIC(sv);
}

d1973 7
a1979 1
newSV(STRLEN len)
d1983 1
a1983 1
    new_SV(sv);
a1993 2
/* name is assumed to contain an SV* if (name && namelen == HEf_SVKEY) */

d1995 6
a2000 1
sv_magic(register SV *sv, SV *obj, int how, char *name, I32 namlen)
d2004 2
a2005 5
    if (SvREADONLY(sv)) {
	dTHR;
	if (PL_curcop != &PL_compiling && !strchr("gBf", how))
	    croak(no_modify);
    }
d2014 2
a2015 1
        (void)SvUPGRADE(sv, SVt_PVMG);
d2021 1
a2021 1
    if (!obj || obj == sv || how == '#' || how == 'r')
a2023 1
	dTHR;
d2029 2
a2030 6
    if (name)
	if (namlen >= 0)
	    mg->mg_ptr = savepvn(name, namlen);
	else if (namlen == HEf_SVKEY)
	    mg->mg_ptr = (char*)SvREFCNT_inc((SV*)name);
    
a2051 3
    case 'f':
	mg->mg_virtual = &vtbl_fm;
	break;
a2063 3
    case 'k':
	mg->mg_virtual = &vtbl_nkeys;
	break;
a2070 10
#ifdef USE_THREADS
    case 'm':
	mg->mg_virtual = &vtbl_mutex;
	break;
#endif /* USE_THREADS */
#ifdef USE_LOCALE_COLLATE
    case 'o':
        mg->mg_virtual = &vtbl_collxfrm;
        break;
#endif /* USE_LOCALE_COLLATE */
a2077 3
    case 'r':
	mg->mg_virtual = &vtbl_regexp;
	break;
a2096 3
    case 'y':
	mg->mg_virtual = &vtbl_defelem;
	break;
d2121 3
a2123 1
sv_unmagic(SV *sv, int type)
d2134 2
a2135 2
	    if (vtbl && (vtbl->svt_free != NULL))
		(VTBL->svt_free)(sv, mg);
d2137 1
a2137 4
		if (mg->mg_len >= 0)
		    Safefree(mg->mg_ptr);
		else if (mg->mg_len == HEf_SVKEY)
		    SvREFCNT_dec((SV*)mg->mg_ptr);
d2154 6
a2159 1
sv_insert(SV *bigstr, STRLEN offset, STRLEN len, char *little, STRLEN littlelen)
a2165 2
    STRLEN curlen;
    
d2169 1
a2169 6
    SvPV_force(bigstr, curlen);
    if (offset + len > curlen) {
	SvGROW(bigstr, offset+len+1);
	Zero(SvPVX(bigstr)+curlen, offset+len-curlen, char);
	SvCUR_set(bigstr, offset+len);
    }
d2237 3
a2239 1
sv_replace(register SV *sv, register SV *nsv)
d2242 6
a2247 1
    SV_CHECK_THINKFIRST(sv);
a2261 1
    assert(!SvREFCNT(sv));
a2263 1
    SvFLAGS(nsv) |= SVTYPEMASK;		/* Mark as freed */
d2268 2
a2269 1
sv_clear(register SV *sv)
a2270 1
    HV* stash;
d2275 2
a2276 30
	dTHR;
	if (PL_defstash) {		/* Still have a symbol table? */
	    djSP;
	    GV* destructor;
	    SV tmpref;

	    Zero(&tmpref, 1, SV);
	    sv_upgrade(&tmpref, SVt_RV);
	    SvROK_on(&tmpref);
	    SvREADONLY_on(&tmpref);	/* DESTROY() could be naughty */
	    SvREFCNT(&tmpref) = 1;

	    do {
		stash = SvSTASH(sv);
		destructor = gv_fetchmethod(SvSTASH(sv), "DESTROY");
		if (destructor) {
		    ENTER;
		    PUSHSTACKi(PERLSI_DESTROY);
		    SvRV(&tmpref) = SvREFCNT_inc(sv);
		    EXTEND(SP, 2);
		    PUSHMARK(SP);
		    PUSHs(&tmpref);
		    PUTBACK;
		    perl_call_sv((SV*)GvCV(destructor),
				 G_DISCARD|G_EVAL|G_KEEPERR);
		    SvREFCNT(sv)--;
		    POPSTACK;
		    LEAVE;
		}
	    } while (SvOBJECT(sv) && SvSTASH(sv) != stash);
d2278 2
a2279 2
	    del_XRV(SvANY(&tmpref));
	}
d2281 22
a2303 1
	    SvREFCNT_dec(SvSTASH(sv));	/* possibly of changed persuasion */
d2306 1
a2306 7
		--PL_sv_objcount;	/* XXX Might want something more general */
	}
	if (SvREFCNT(sv)) {
		if (PL_in_clean_objs)
		    croak("DESTROY created new reference to dead object");
		/* DESTROY gave object new lease on life */
		return;
a2310 1
    stash = NULL;
d2313 1
a2313 5
	if (IoIFP(sv) &&
	    IoIFP(sv) != PerlIO_stdin() &&
	    IoIFP(sv) != PerlIO_stdout() &&
	    IoIFP(sv) != PerlIO_stderr())
	  io_close((IO*)sv);
a2329 3
    case SVt_PVLV:
	SvREFCNT_dec(LvTARG(sv));
	goto freescalar;
d2331 1
a2331 1
	gp_free((GV*)sv);
a2332 5
	/* cannot decrease stash refcount yet, as we might recursively delete
	   ourselves when the refcnt drops to zero. Delay SvREFCNT_dec
	   of stash until current sv is completely gone.
	   -- JohnPC, 27 Mar 1998 */
	stash = GvSTASH(sv);
d2334 1
d2345 1
a2345 1
	else if (SvPVX(sv) && SvLEN(sv))
d2394 1
a2394 7
	/* code duplication for increased performance. */
	SvFLAGS(sv) &= SVf_BREAK;
	SvFLAGS(sv) |= SVTYPEMASK;
	/* decrease refcount of the stash that owns this GV, if any */
	if (stash)
	    SvREFCNT_dec(stash);
	return; /* not break, SvFLAGS reset already happened */
d2410 2
a2411 1
sv_newref(SV *sv)
d2414 1
a2414 1
	ATOMIC_INC(SvREFCNT(sv));
d2419 2
a2420 1
sv_free(SV *sv)
a2421 2
    int refcount_is_zero;

d2424 4
a2430 7
	if (PL_in_clean_all) /* All is fair */
	    return;
	if (SvREADONLY(sv) && SvIMMORTAL(sv)) {
	    /* make sure SvREFCNT(sv)==0 happens very seldom */
	    SvREFCNT(sv) = (~(U32)0)/2;
	    return;
	}
d2434 1
a2434 2
    ATOMIC_DEC_AND_TEST(refcount_is_zero, SvREFCNT(sv));
    if (!refcount_is_zero)
d2438 1
a2438 1
	warn("Attempt to free temp prematurely: SV 0x%lx", (unsigned long)sv);
a2441 5
    if (SvREADONLY(sv) && SvIMMORTAL(sv)) {
	/* make sure SvREFCNT(sv)==0 happens very seldom */
	SvREFCNT(sv) = (~(U32)0)/2;
	return;
    }
d2443 1
a2443 2
    if (! SvREFCNT(sv))
	del_SV(sv);
d2447 2
a2448 1
sv_len(register SV *sv)
d2457 1
a2457 1
	len = mg_length(sv);
d2464 3
a2466 1
sv_eq(register SV *str1, register SV *str2)
d2488 1
a2488 1
    return memEQ(pv1, pv2, cur1);
d2492 3
a2494 1
sv_cmp(register SV *str1, register SV *str2)
a2495 4
    STRLEN cur1 = 0;
    char *pv1 = str1 ? SvPV(str1, cur1) : (char *) NULL;
    STRLEN cur2 = 0;
    char *pv2 = str2 ? SvPV(str2, cur2) : (char *) NULL;
d2497 18
a2517 1

d2521 9
a2529 3
    retval = memcmp((void*)pv1, (void*)pv2, cur1 < cur2 ? cur1 : cur2);

    if (retval)
d2531 1
a2531 2

    if (cur1 == cur2)
d2534 1
a2534 1
	return cur1 < cur2 ? -1 : 1;
a2536 101
I32
sv_cmp_locale(register SV *sv1, register SV *sv2)
{
#ifdef USE_LOCALE_COLLATE

    char *pv1, *pv2;
    STRLEN len1, len2;
    I32 retval;

    if (PL_collation_standard)
	goto raw_compare;

    len1 = 0;
    pv1 = sv1 ? sv_collxfrm(sv1, &len1) : (char *) NULL;
    len2 = 0;
    pv2 = sv2 ? sv_collxfrm(sv2, &len2) : (char *) NULL;

    if (!pv1 || !len1) {
	if (pv2 && len2)
	    return -1;
	else
	    goto raw_compare;
    }
    else {
	if (!pv2 || !len2)
	    return 1;
    }

    retval = memcmp((void*)pv1, (void*)pv2, len1 < len2 ? len1 : len2);

    if (retval)
	return retval < 0 ? -1 : 1;

    /*
     * When the result of collation is equality, that doesn't mean
     * that there are no differences -- some locales exclude some
     * characters from consideration.  So to avoid false equalities,
     * we use the raw string as a tiebreaker.
     */

  raw_compare:
    /* FALL THROUGH */

#endif /* USE_LOCALE_COLLATE */

    return sv_cmp(sv1, sv2);
}

#ifdef USE_LOCALE_COLLATE
/*
 * Any scalar variable may carry an 'o' magic that contains the
 * scalar data of the variable transformed to such a format that
 * a normal memory comparison can be used to compare the data
 * according to the locale settings.
 */
char *
sv_collxfrm(SV *sv, STRLEN *nxp)
{
    MAGIC *mg;

    mg = SvMAGICAL(sv) ? mg_find(sv, 'o') : (MAGIC *) NULL;
    if (!mg || !mg->mg_ptr || *(U32*)mg->mg_ptr != PL_collation_ix) {
	char *s, *xf;
	STRLEN len, xlen;

	if (mg)
	    Safefree(mg->mg_ptr);
	s = SvPV(sv, len);
	if ((xf = mem_collxfrm(s, len, &xlen))) {
	    if (SvREADONLY(sv)) {
		SAVEFREEPV(xf);
		*nxp = xlen;
		return xf + sizeof(PL_collation_ix);
	    }
	    if (! mg) {
		sv_magic(sv, 0, 'o', 0, 0);
		mg = mg_find(sv, 'o');
		assert(mg);
	    }
	    mg->mg_ptr = xf;
	    mg->mg_len = xlen;
	}
	else {
	    if (mg) {
		mg->mg_ptr = NULL;
		mg->mg_len = -1;
	    }
	}
    }
    if (mg && mg->mg_ptr) {
	*nxp = mg->mg_len;
	return mg->mg_ptr + sizeof(PL_collation_ix);
    }
    else {
	*nxp = 0;
	return NULL;
    }
}

#endif /* USE_LOCALE_COLLATE */

d2538 4
a2541 1
sv_gets(register SV *sv, register PerlIO *fp, I32 append)
a2542 1
    dTHR;
d2550 18
a2567 3
    SV_CHECK_THINKFIRST(sv);
    (void)SvUPGRADE(sv, SVt_PV);
    SvSCREAM_off(sv);
d2569 1
a2569 1
    if (RsSNARF(PL_rs)) {
d2573 1
a2573 22
    else if (RsRECORD(PL_rs)) {
      I32 recsize, bytesread;
      char *buffer;

      /* Grab the size of the record we're getting */
      recsize = SvIV(SvRV(PL_rs));
      (void)SvPOK_only(sv);    /* Validate pointer */
      buffer = SvGROW(sv, recsize + 1);
      /* Go yank in */
#ifdef VMS
      /* VMS wants read instead of fread, because fread doesn't respect */
      /* RMS record boundaries. This is not necessarily a good thing to be */
      /* doing, but we've got no other real choice */
      bytesread = PerlLIO_read(PerlIO_fileno(fp), buffer, recsize);
#else
      bytesread = PerlIO_read(fp, buffer, recsize);
#endif
      SvCUR_set(sv, bytesread);
      buffer[bytesread] = '\0';
      return(SvCUR(sv) ? SvPVX(sv) : Nullch);
    }
    else if (RsPARA(PL_rs)) {
d2578 1
a2578 1
	rsptr = SvPV(PL_rs, rslen);
d2581 1
a2581 1
    if (RsPARA(PL_rs)) {		/* have to do this both before and after */
d2583 1
a2583 1
	    if (PerlIO_eof(fp))
d2585 1
a2585 1
	    i = PerlIO_getc(fp);
d2589 1
a2589 1
		PerlIO_ungetc(fp,i);
d2595 1
a2595 27
    /* See if we know enough about I/O mechanism to cheat it ! */

    /* This used to be #ifdef test - it is made run-time test for ease
       of abstracting out stdio interface. One call should be cheap 
       enough here - and may even be a macro allowing compile
       time optimization.
     */

    if (PerlIO_fast_gets(fp)) {

    /*
     * We're going to steal some values from the stdio struct
     * and put EVERYTHING in the innermost loop into registers.
     */
    register STDCHAR *ptr;
    STRLEN bpx;
    I32 shortbuffered;

#if defined(VMS) && defined(PERLIO_IS_STDIO)
    /* An ungetc()d char is handled separately from the regular
     * buffer, so we getc() it back out and stuff it in the buffer.
     */
    i = PerlIO_getc(fp);
    if (i == EOF) return 0;
    *(--((*fp)->_ptr)) = (unsigned char) i;
    (*fp)->_cnt++;
#endif
d2599 1
a2599 1
    cnt = PerlIO_get_cnt(fp);			/* get count into register */
d2608 1
a2608 2
	    /* remember that cnt can be negative */
	    SvGROW(sv, append + (cnt <= 0 ? 2 : (cnt + 1)));
d2614 1
a2614 7
    ptr = (STDCHAR*)PerlIO_get_ptr(fp);
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: entering, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: entering: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	       (long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	       (long)(PerlIO_has_base(fp) ? PerlIO_get_base(fp) : 0)));
d2619 1
a2619 2
		while (cnt > 0) {		     /* this     |  eat */
		    cnt--;
d2625 1
a2625 1
	        Copy(ptr, bp, cnt, char);	     /* this     |  eat */    
d2642 5
a2646 19
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	    "Screamer: going to getc, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
	PerlIO_set_ptrcnt(fp, ptr, cnt); /* deregisterize cnt and ptr */
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	    "Screamer: pre: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	    (long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	    (long)(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
	/* This used to call 'filbuf' in stdio form, but as that behaves like 
	   getc when cnt <= 0 we use PerlIO_getc here to avoid introducing
	   another abstraction.  */
	i   = PerlIO_getc(fp);		/* get more characters */
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	    "Screamer: post: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	    (long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	    (long)(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
	cnt = PerlIO_get_cnt(fp);
	ptr = (STDCHAR*)PerlIO_get_ptr(fp);	/* reregisterize cnt and ptr */
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	    "Screamer: after getc, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
d2656 1
a2656 1
	*bp++ = i;			/* store character from PerlIO_getc */
d2664 2
a2665 2
	  memNE((char*)bp - rslen, rsptr, rslen))
	goto screamer;				/* go back to the fray */
d2669 2
a2670 7
	DEBUG_P(PerlIO_printf(Perl_debug_log,
	    "Screamer: quitting, ptr=%ld, cnt=%ld\n",(long)ptr,(long)cnt));
    PerlIO_set_ptrcnt(fp, ptr, cnt);	/* put these back or we're in trouble */
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: end: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n",
	(long)PerlIO_get_ptr(fp), (long)PerlIO_get_cnt(fp), 
	(long)(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
d2672 6
a2677 6
    SvCUR_set(sv, bp - (STDCHAR*)SvPVX(sv));	/* set length */
    DEBUG_P(PerlIO_printf(Perl_debug_log,
	"Screamer: done, len=%ld, string=|%.*s|\n",
	(long)SvCUR(sv),(int)SvCUR(sv),SvPVX(sv)));
    }
   else
a2678 1
       /*The big, slow, and stupid way */
d2681 1
a2681 1
screamer2:
d2685 1
a2685 1
	    while ((i = PerlIO_getc(fp)) != EOF && (*bp++ = i) != rslast && bp < bpe)
d2690 2
a2691 5
	    cnt = PerlIO_read(fp,(char*)buf, sizeof(buf));
	    /* Accomodate broken VAXC compiler, which applies U8 cast to
	     * both args of ?: operator, causing EOF to change into 255
	     */
	    if (cnt) { i = (U8)buf[cnt - 1]; } else { i = EOF; }
d2695 1
a2695 1
	    sv_catpvn(sv, (char *) buf, cnt);
d2697 1
a2697 1
	    sv_setpvn(sv, (char *) buf, cnt);
d2702 1
a2702 1
	     memNE(SvPVX(sv) + SvCUR(sv) - rslen, rsptr, rslen)))
d2705 1
a2705 13
	    /*
	     * If we're reading from a TTY and we get a short read,
	     * indicating that the user hit his EOF character, we need
	     * to notice it now, because if we try to read from the TTY
	     * again, the EOF condition will disappear.
	     *
	     * The comparison of cnt to sizeof(buf) is an optimization
	     * that prevents unnecessary calls to feof().
	     *
	     * - jik 9/25/96
	     */
	    if (!(cnt < sizeof(buf) && PerlIO_eof(fp)))
		goto screamer2;
d2709 3
a2711 1
    if (RsPARA(PL_rs)) {		/* have to do this both before and after */  
d2713 1
a2713 1
	    i = PerlIO_getc(fp);
d2715 1
a2715 1
		PerlIO_ungetc(fp,i);
a2720 4
#ifdef WIN32
    win32_strip_return(sv);
#endif

a2723 1

d2725 2
a2726 1
sv_inc(register SV *sv)
a2732 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d2734 2
a2735 5
	if (SvREADONLY(sv)) {
	    dTHR;
	    if (PL_curcop != &PL_compiling)
		croak(no_modify);
	}
a2736 1
	    IV i;
d2738 1
a2738 1
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,inc)) return;
d2740 1
a2740 3
	    i = (IV)SvRV(sv);
	    sv_unref(sv);
	    sv_setiv(sv, i);
d2743 2
d2746 5
d2752 1
a2753 10
	SvNVX(sv) += 1.0;
	return;
    }
    if (flags & SVp_IOK) {
	if (SvIVX(sv) == IV_MAX)
	    sv_setnv(sv, (double)IV_MAX + 1.0);
	else {
	    (void)SvIOK_only(sv);
	    ++SvIVX(sv);
	}
d2767 1
a2767 2
	SET_NUMERIC_STANDARD();
	sv_setnv(sv,atof(SvPVX(sv)) + 1.0);  /* punt */
a2777 13
#ifdef EBCDIC
	    /* MKS: The original code here died if letters weren't consecutive.
	     * at least it didn't have to worry about non-C locales.  The
	     * new code assumes that ('z'-'a')==('Z'-'A'), letters are
	     * arranged in order (although not consecutively) and that only 
	     * [A-Za-z] are accepted by isALPHA in the C locale.
	     */
	    if (*d != 'z' && *d != 'Z') {
		do { ++*d; } while (!isALPHA(*d));
		return;
	    }
	    *(d--) -= 'z' - 'a';
#else
a2781 1
#endif
d2796 2
a2797 1
sv_dec(register SV *sv)
a2802 2
    if (SvGMAGICAL(sv))
	mg_get(sv);
d2804 2
a2805 5
	if (SvREADONLY(sv)) {
	    dTHR;
	    if (PL_curcop != &PL_compiling)
		croak(no_modify);
	}
a2806 1
	    IV i;
d2808 1
a2808 1
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,dec)) return;
d2810 1
a2810 3
	    i = (IV)SvRV(sv);
	    sv_unref(sv);
	    sv_setiv(sv, i);
d2813 2
d2816 5
a2825 9
    if (flags & SVp_IOK) {
	if (SvIVX(sv) == IV_MIN)
	    sv_setnv(sv, (double)IV_MIN - 1.0);
	else {
	    (void)SvIOK_only(sv);
	    --SvIVX(sv);
	}
	return;
    }
d2833 1
a2833 2
    SET_NUMERIC_STANDARD();
    sv_setnv(sv,atof(SvPVX(sv)) - 1.0);	/* punt */
d2841 2
a2842 2
STATIC void
sv_mortalgrow(void)
d2844 2
a2845 3
    dTHR;
    PL_tmps_max += (PL_tmps_max < 512) ? 128 : 512;
    Renew(PL_tmps_stack, PL_tmps_max, SV*);
d2849 2
a2850 1
sv_mortalcopy(SV *oldstr)
a2851 1
    dTHR;
d2854 1
a2854 1
    new_SV(sv);
d2859 1
a2859 1
    if (++PL_tmps_ix >= PL_tmps_max)
d2861 1
a2861 1
    PL_tmps_stack[PL_tmps_ix] = sv;
d2867 1
a2867 1
sv_newmortal(void)
a2868 1
    dTHR;
d2871 1
a2871 1
    new_SV(sv);
d2875 1
a2875 1
    if (++PL_tmps_ix >= PL_tmps_max)
d2877 1
a2877 1
    PL_tmps_stack[PL_tmps_ix] = sv;
d2884 2
a2885 1
sv_2mortal(register SV *sv)
a2886 1
    dTHR;
d2889 3
a2891 3
    if (SvREADONLY(sv) && SvIMMORTAL(sv))
	return sv;
    if (++PL_tmps_ix >= PL_tmps_max)
d2893 1
a2893 1
    PL_tmps_stack[PL_tmps_ix] = sv;
d2899 3
a2901 1
newSVpv(char *s, STRLEN len)
d2905 1
a2905 1
    new_SV(sv);
d2916 2
a2917 31
newSVpvn(char *s, STRLEN len)
{
    register SV *sv;

    new_SV(sv);
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
    sv_setpvn(sv,s,len);
    return sv;
}

SV *
newSVpvf(const char* pat, ...)
{
    register SV *sv;
    va_list args;

    new_SV(sv);
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
    va_start(args, pat);
    sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
    va_end(args);
    return sv;
}


SV *
newSVnv(double n)
d2921 1
a2921 1
    new_SV(sv);
d2930 2
a2931 1
newSViv(IV i)
d2935 1
a2935 1
    new_SV(sv);
d2944 2
a2945 1
newRV_noinc(SV *tmpRef)
a2946 1
    dTHR;
d2949 1
a2949 1
    new_SV(sv);
d2954 2
a2955 2
    SvTEMP_off(tmpRef);
    SvRV(sv) = tmpRef;
a2959 6
SV *
newRV(SV *tmpRef)
{
    return newRV_noinc(SvREFCNT_inc(tmpRef));
}

d2963 2
a2964 1
newSVsv(register SV *old)
d2974 1
a2974 1
    new_SV(sv);
d2989 3
a2991 1
sv_reset(register char *s, HV *stash)
a3000 3
    if (!stash)
	return;

d3003 1
a3003 1
	    pm->op_pmdynflags &= ~PMdf_USED;
d3025 3
a3027 4
	         entry;
	         entry = HeNEXT(entry))
	    {
		if (!todo[(U8)*HeKEY(entry)])
d3029 1
a3029 1
		gv = (GV*)HeVAL(entry);
a3030 5
		if (SvTHINKFIRST(sv)) {
		    if (!SvREADONLY(sv) && SvROK(sv))
        		sv_unref(sv);
		    continue;
		}
d3034 1
a3036 1
		    SvTAINT(sv);
d3041 3
a3043 1
		if (GvHV(gv) && !HvNAME(GvHV(gv))) {
d3046 1
a3046 1
		    if (gv == PL_envgv)
a3054 34
IO*
sv_2io(SV *sv)
{
    IO* io;
    GV* gv;
    STRLEN n_a;

    switch (SvTYPE(sv)) {
    case SVt_PVIO:
	io = (IO*)sv;
	break;
    case SVt_PVGV:
	gv = (GV*)sv;
	io = GvIO(gv);
	if (!io)
	    croak("Bad filehandle: %s", GvNAME(gv));
	break;
    default:
	if (!SvOK(sv))
	    croak(no_usym, "filehandle");
	if (SvROK(sv))
	    return sv_2io(SvRV(sv));
	gv = gv_fetchpv(SvPV(sv,n_a), FALSE, SVt_PVIO);
	if (gv)
	    io = GvIO(gv);
	else
	    io = 0;
	if (!io)
	    croak("Bad filehandle: %s", SvPV(sv,n_a));
	break;
    }
    return io;
}

d3056 5
a3060 1
sv_2cv(SV *sv, HV **st, GV **gvp, I32 lref)
a3063 1
    STRLEN n_a;
d3086 2
a3087 10
	    sv = SvRV(sv);
	    if (SvTYPE(sv) == SVt_PVCV) {
		cv = (CV*)sv;
		*gvp = Nullgv;
		*st = CvSTASH(cv);
		return cv;
	    }
	    else if(isGV(sv))
		gv = (GV*)sv;
	    else
d3089 3
d3093 1
a3093 1
	else if (isGV(sv))
d3096 1
a3096 1
	    gv = gv_fetchpv(SvPV(sv, n_a), lref, SVt_PVCV);
d3102 1
a3102 1
	if (lref && !GvCVu(gv)) {
d3106 2
a3107 2
	    gv_efullname3(tmpsv, gv, Nullch);
	    newSUB(start_subparse(FALSE, 0),
d3112 2
a3113 2
	    if (!GvCVu(gv))
		croak("Unable to create sub named \"%s\"", SvPV(sv,n_a));
d3115 1
a3115 1
	return GvCVu(gv);
d3119 1
d3121 2
a3122 1
sv_true(register SV *sv)
a3123 1
    dTHR;
d3126 2
d3129 5
a3133 5
	register XPV* tXpv;
	if ((tXpv = (XPV*)SvANY(sv)) &&
		(*tXpv->xpv_pv > '0' ||
		tXpv->xpv_cur > 1 ||
		(tXpv->xpv_cur && *tXpv->xpv_pv != '0')))
d3149 1
d3151 3
a3153 2
IV
sv_iv(register SV *sv)
d3155 3
a3157 3
    if (SvIOK(sv))
	return SvIVX(sv);
    return sv_2iv(sv);
d3159 1
a3160 7
UV
sv_uv(register SV *sv)
{
    if (SvIOK(sv))
	return SvUVX(sv);
    return sv_2uv(sv);
}
d3162 3
a3164 2
double
sv_nv(register SV *sv)
d3166 5
a3170 3
    if (SvNOK(sv))
	return SvNVX(sv);
    return sv_2nv(sv);
d3172 1
d3174 1
d3176 3
a3178 1
sv_pvn(SV *sv, STRLEN *lp)
d3186 1
d3189 3
a3191 1
sv_pvn_force(SV *sv, STRLEN *lp)
d3195 2
a3196 5
    if (SvREADONLY(sv)) {
	dTHR;
	if (PL_curcop != &PL_compiling)
	    croak(no_modify);
    }
d3208 1
a3208 2
	    else {
		dTHR;
d3210 1
a3210 2
		    op_name[PL_op->op_type]);
	    }
d3228 1
a3228 1
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%lx 2pv(%s)\n",
d3236 3
a3238 1
sv_reftype(SV *sv, int ob)
d3262 1
a3262 1
	case SVt_PVFM:		return "FORMAT";
d3269 2
a3270 1
sv_isobject(SV *sv)
a3271 4
    if (!sv)
	return 0;
    if (SvGMAGICAL(sv))
	mg_get(sv);
d3281 3
a3283 1
sv_isa(SV *sv, char *name)
a3284 4
    if (!sv)
	return 0;
    if (SvGMAGICAL(sv))
	mg_get(sv);
d3295 3
a3297 1
newSVrv(SV *rv, char *classname)
a3298 1
    dTHR;
d3301 1
a3301 1
    new_SV(sv);
d3305 1
a3305 10

    SV_CHECK_THINKFIRST(rv);
#ifdef OVERLOAD
    SvAMAGIC_off(rv);
#endif /* OVERLOAD */

    if (SvTYPE(rv) < SVt_RV)
      sv_upgrade(rv, SVt_RV);

    (void)SvOK_off(rv);
d3317 4
a3320 1
sv_setref_pv(SV *rv, char *classname, void *pv)
d3322 2
a3323 4
    if (!pv) {
	sv_setsv(rv, &PL_sv_undef);
	SvSETMAGIC(rv);
    }
d3330 4
a3333 1
sv_setref_iv(SV *rv, char *classname, IV iv)
d3340 4
a3343 1
sv_setref_nv(SV *rv, char *classname, double nv)
d3350 5
a3354 1
sv_setref_pvn(SV *rv, char *classname, char *pv, I32 n)
d3361 3
a3363 1
sv_bless(SV *sv, HV *stash)
d3365 1
a3365 2
    dTHR;
    SV *tmpRef;
d3368 3
a3370 3
    tmpRef = SvRV(sv);
    if (SvFLAGS(tmpRef) & (SVs_OBJECT|SVf_READONLY)) {
	if (SvREADONLY(tmpRef))
d3372 2
a3373 5
	if (SvOBJECT(tmpRef)) {
	    if (SvTYPE(tmpRef) != SVt_PVIO)
		--PL_sv_objcount;
	    SvREFCNT_dec(SvSTASH(tmpRef));
	}
d3375 4
a3378 5
    SvOBJECT_on(tmpRef);
    if (SvTYPE(tmpRef) != SVt_PVIO)
	++PL_sv_objcount;
    (void)SvUPGRADE(tmpRef, SVt_PVMG);
    SvSTASH(tmpRef) = (HV*)SvREFCNT_inc(stash);
d3381 4
a3384 4
    if (Gv_AMG(stash))
	SvAMAGIC_on(sv);
    else
	SvAMAGIC_off(sv);
d3390 3
a3392 2
STATIC void
sv_unglob(SV *sv)
d3397 1
a3397 5
	gp_free((GV*)sv);
    if (GvSTASH(sv)) {
	SvREFCNT_dec(GvSTASH(sv));
	GvSTASH(sv) = Nullhv;
    }
d3406 2
a3407 1
sv_unref(SV *sv)
d3419 1
d3421 2
a3422 1
sv_taint(SV *sv)
d3424 2
a3425 615
    sv_magic((sv), Nullsv, 't', Nullch, 0);
}

void
sv_untaint(SV *sv)
{
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	MAGIC *mg = mg_find(sv, 't');
	if (mg)
	    mg->mg_len &= ~1;
    }
}

bool
sv_tainted(SV *sv)
{
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	MAGIC *mg = mg_find(sv, 't');
	if (mg && ((mg->mg_len & 1) || (mg->mg_len & 2) && mg->mg_obj == sv))
	    return TRUE;
    }
    return FALSE;
}

void
sv_setpviv(SV *sv, IV iv)
{
    STRLEN len;
    char buf[TYPE_DIGITS(UV)];
    char *ptr = buf + sizeof(buf);
    int sign;
    UV uv;
    char *p;

    sv_setpvn(sv, "", 0);
    if (iv >= 0) {
	uv = iv;
	sign = 0;
    } else {
	uv = -iv;
	sign = 1;
    }
    do {
	*--ptr = '0' + (uv % 10);
    } while (uv /= 10);
    len = (buf + sizeof(buf)) - ptr;
    /* taking advantage of SvCUR(sv) == 0 */
    SvGROW(sv, sign + len + 1);
    p = SvPVX(sv);
    if (sign)
	*p++ = '-';
    memcpy(p, ptr, len);
    p += len;
    *p = '\0';
    SvCUR(sv) = p - SvPVX(sv);
}


void
sv_setpviv_mg(SV *sv, IV iv)
{
    sv_setpviv(sv,iv);
    SvSETMAGIC(sv);
}

void
sv_setpvf(SV *sv, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
    va_end(args);
}


void
sv_setpvf_mg(SV *sv, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
    va_end(args);
    SvSETMAGIC(sv);
}

void
sv_catpvf(SV *sv, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
    va_end(args);
}

void
sv_catpvf_mg(SV *sv, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
    va_end(args);
    SvSETMAGIC(sv);
}

void
sv_vsetpvfn(SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *used_locale)
{
    sv_setpvn(sv, "", 0);
    sv_vcatpvfn(sv, pat, patlen, args, svargs, svmax, used_locale);
}

void
sv_vcatpvfn(SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *used_locale)
{
    dTHR;
    char *p;
    char *q;
    char *patend;
    STRLEN origlen;
    I32 svix = 0;
    static char nullstr[] = "(null)";

    /* no matter what, this is a string now */
    (void)SvPV_force(sv, origlen);

    /* special-case "", "%s", and "%_" */
    if (patlen == 0)
	return;
    if (patlen == 2 && pat[0] == '%') {
	switch (pat[1]) {
	case 's':
	    if (args) {
		char *s = va_arg(*args, char*);
		sv_catpv(sv, s ? s : nullstr);
	    }
	    else if (svix < svmax)
		sv_catsv(sv, *svargs);
	    return;
	case '_':
	    if (args) {
		sv_catsv(sv, va_arg(*args, SV*));
		return;
	    }
	    /* See comment on '_' below */
	    break;
	}
    }

    patend = (char*)pat + patlen;
    for (p = (char*)pat; p < patend; p = q) {
	bool alt = FALSE;
	bool left = FALSE;
	char fill = ' ';
	char plus = 0;
	char intsize = 0;
	STRLEN width = 0;
	STRLEN zeros = 0;
	bool has_precis = FALSE;
	STRLEN precis = 0;

	char esignbuf[4];
	STRLEN esignlen = 0;

	char *eptr = Nullch;
	STRLEN elen = 0;
	char ebuf[TYPE_DIGITS(int) * 2 + 16]; /* large enough for "%#.#f" */

#ifndef PERL_OBJECT
	static char *efloatbuf = Nullch;
	static STRLEN efloatsize = 0;
#endif

	char c;
	int i;
	unsigned base;
	IV iv;
	UV uv;
	double nv;
	STRLEN have;
	STRLEN need;
	STRLEN gap;

	for (q = p; q < patend && *q != '%'; ++q) ;
	if (q > p) {
	    sv_catpvn(sv, p, q - p);
	    p = q;
	}
	if (q++ >= patend)
	    break;

	/* FLAGS */

	while (*q) {
	    switch (*q) {
	    case ' ':
	    case '+':
		plus = *q++;
		continue;

	    case '-':
		left = TRUE;
		q++;
		continue;

	    case '0':
		fill = *q++;
		continue;

	    case '#':
		alt = TRUE;
		q++;
		continue;

	    default:
		break;
	    }
	    break;
	}

	/* WIDTH */

	switch (*q) {
	case '1': case '2': case '3':
	case '4': case '5': case '6':
	case '7': case '8': case '9':
	    width = 0;
	    while (isDIGIT(*q))
		width = width * 10 + (*q++ - '0');
	    break;

	case '*':
	    if (args)
		i = va_arg(*args, int);
	    else
		i = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
	    left |= (i < 0);
	    width = (i < 0) ? -i : i;
	    q++;
	    break;
	}

	/* PRECISION */

	if (*q == '.') {
	    q++;
	    if (*q == '*') {
		if (args)
		    i = va_arg(*args, int);
		else
		    i = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
		precis = (i < 0) ? 0 : i;
		q++;
	    }
	    else {
		precis = 0;
		while (isDIGIT(*q))
		    precis = precis * 10 + (*q++ - '0');
	    }
	    has_precis = TRUE;
	}

	/* SIZE */

	switch (*q) {
	case 'l':
#if 0  /* when quads have better support within Perl */
	    if (*(q + 1) == 'l') {
		intsize = 'q';
		q += 2;
		break;
	    }
#endif
	    /* FALL THROUGH */
	case 'h':
	case 'V':
	    intsize = *q++;
	    break;
	}

	/* CONVERSION */

	switch (c = *q++) {

	    /* STRINGS */

	case '%':
	    eptr = q - 1;
	    elen = 1;
	    goto string;

	case 'c':
	    if (args)
		c = va_arg(*args, int);
	    else
		c = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
	    eptr = &c;
	    elen = 1;
	    goto string;

	case 's':
	    if (args) {
		eptr = va_arg(*args, char*);
		if (eptr)
		    elen = strlen(eptr);
		else {
		    eptr = nullstr;
		    elen = sizeof nullstr - 1;
		}
	    }
	    else if (svix < svmax)
		eptr = SvPVx(svargs[svix++], elen);
	    goto string;

	case '_':
	    /*
	     * The "%_" hack might have to be changed someday,
	     * if ISO or ANSI decide to use '_' for something.
	     * So we keep it hidden from users' code.
	     */
	    if (!args)
		goto unknown;
	    eptr = SvPVx(va_arg(*args, SV*), elen);

	string:
	    if (has_precis && elen > precis)
		elen = precis;
	    break;

	    /* INTEGERS */

	case 'p':
	    if (args)
		uv = (UV)va_arg(*args, void*);
	    else
		uv = (svix < svmax) ? (UV)svargs[svix++] : 0;
	    base = 16;
	    goto integer;

	case 'D':
	    intsize = 'l';
	    /* FALL THROUGH */
	case 'd':
	case 'i':
	    if (args) {
		switch (intsize) {
		case 'h':	iv = (short)va_arg(*args, int); break;
		default:	iv = va_arg(*args, int); break;
		case 'l':	iv = va_arg(*args, long); break;
		case 'V':	iv = va_arg(*args, IV); break;
		}
	    }
	    else {
		iv = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
		switch (intsize) {
		case 'h':	iv = (short)iv; break;
		default:	iv = (int)iv; break;
		case 'l':	iv = (long)iv; break;
		case 'V':	break;
		}
	    }
	    if (iv >= 0) {
		uv = iv;
		if (plus)
		    esignbuf[esignlen++] = plus;
	    }
	    else {
		uv = -iv;
		esignbuf[esignlen++] = '-';
	    }
	    base = 10;
	    goto integer;

	case 'U':
	    intsize = 'l';
	    /* FALL THROUGH */
	case 'u':
	    base = 10;
	    goto uns_integer;

	case 'O':
	    intsize = 'l';
	    /* FALL THROUGH */
	case 'o':
	    base = 8;
	    goto uns_integer;

	case 'X':
	case 'x':
	    base = 16;

	uns_integer:
	    if (args) {
		switch (intsize) {
		case 'h':  uv = (unsigned short)va_arg(*args, unsigned); break;
		default:   uv = va_arg(*args, unsigned); break;
		case 'l':  uv = va_arg(*args, unsigned long); break;
		case 'V':  uv = va_arg(*args, UV); break;
		}
	    }
	    else {
		uv = (svix < svmax) ? SvUVx(svargs[svix++]) : 0;
		switch (intsize) {
		case 'h':	uv = (unsigned short)uv; break;
		default:	uv = (unsigned)uv; break;
		case 'l':	uv = (unsigned long)uv; break;
		case 'V':	break;
		}
	    }

	integer:
	    eptr = ebuf + sizeof ebuf;
	    switch (base) {
		unsigned dig;
	    case 16:
		if (!uv)
		    alt = FALSE;
		p = (c == 'X') ? "0123456789ABCDEF" : "0123456789abcdef";
		do {
		    dig = uv & 15;
		    *--eptr = p[dig];
		} while (uv >>= 4);
		if (alt) {
		    esignbuf[esignlen++] = '0';
		    esignbuf[esignlen++] = c;  /* 'x' or 'X' */
		}
		break;
	    case 8:
		do {
		    dig = uv & 7;
		    *--eptr = '0' + dig;
		} while (uv >>= 3);
		if (alt && *eptr != '0')
		    *--eptr = '0';
		break;
	    default:		/* it had better be ten or less */
		do {
		    dig = uv % base;
		    *--eptr = '0' + dig;
		} while (uv /= base);
		break;
	    }
	    elen = (ebuf + sizeof ebuf) - eptr;
	    if (has_precis) {
		if (precis > elen)
		    zeros = precis - elen;
		else if (precis == 0 && elen == 1 && *eptr == '0')
		    elen = 0;
	    }
	    break;

	    /* FLOATING POINT */

	case 'F':
	    c = 'f';		/* maybe %F isn't supported here */
	    /* FALL THROUGH */
	case 'e': case 'E':
	case 'f':
	case 'g': case 'G':

	    /* This is evil, but floating point is even more evil */

	    if (args)
		nv = va_arg(*args, double);
	    else
		nv = (svix < svmax) ? SvNVx(svargs[svix++]) : 0.0;

	    need = 0;
	    if (c != 'e' && c != 'E') {
		i = PERL_INT_MIN;
		(void)frexp(nv, &i);
		if (i == PERL_INT_MIN)
		    die("panic: frexp");
		if (i > 0)
		    need = BIT_DIGITS(i);
	    }
	    need += has_precis ? precis : 6; /* known default */
	    if (need < width)
		need = width;

	    need += 20; /* fudge factor */
	    if (efloatsize < need) {
		Safefree(efloatbuf);
		efloatsize = need + 20; /* more fudge */
		New(906, efloatbuf, efloatsize, char);
	    }

	    eptr = ebuf + sizeof ebuf;
	    *--eptr = '\0';
	    *--eptr = c;
	    if (has_precis) {
		base = precis;
		do { *--eptr = '0' + (base % 10); } while (base /= 10);
		*--eptr = '.';
	    }
	    if (width) {
		base = width;
		do { *--eptr = '0' + (base % 10); } while (base /= 10);
	    }
	    if (fill == '0')
		*--eptr = fill;
	    if (left)
		*--eptr = '-';
	    if (plus)
		*--eptr = plus;
	    if (alt)
		*--eptr = '#';
	    *--eptr = '%';

	    (void)sprintf(efloatbuf, eptr, nv);

	    eptr = efloatbuf;
	    elen = strlen(efloatbuf);

#ifdef LC_NUMERIC
	    /*
	     * User-defined locales may include arbitrary characters.
	     * And, unfortunately, some system may alloc the "C" locale
	     * to be overridden by a malicious user.
	     */
	    if (used_locale)
		*used_locale = TRUE;
#endif /* LC_NUMERIC */

	    break;

	    /* SPECIAL */

	case 'n':
	    i = SvCUR(sv) - origlen;
	    if (args) {
		switch (intsize) {
		case 'h':	*(va_arg(*args, short*)) = i; break;
		default:	*(va_arg(*args, int*)) = i; break;
		case 'l':	*(va_arg(*args, long*)) = i; break;
		case 'V':	*(va_arg(*args, IV*)) = i; break;
		}
	    }
	    else if (svix < svmax)
		sv_setuv(svargs[svix++], (UV)i);
	    continue;	/* not "break" */

	    /* UNKNOWN */

	default:
      unknown:
	    if (!args && PL_dowarn &&
		  (PL_op->op_type == OP_PRTF || PL_op->op_type == OP_SPRINTF)) {
		SV *msg = sv_newmortal();
		sv_setpvf(msg, "Invalid conversion in %s: ",
			  (PL_op->op_type == OP_PRTF) ? "printf" : "sprintf");
		if (c)
		    sv_catpvf(msg, isPRINT(c) ? "\"%%%c\"" : "\"%%\\%03o\"",
			      c & 0xFF);
		else
		    sv_catpv(msg, "end of string");
		warn("%_", msg); /* yes, this is reentrant */
	    }

	    /* output mangled stuff ... */
	    if (c == '\0')
		--q;
	    eptr = p;
	    elen = q - p;

	    /* ... right here, because formatting flags should not apply */
	    SvGROW(sv, SvCUR(sv) + elen + 1);
	    p = SvEND(sv);
	    memcpy(p, eptr, elen);
	    p += elen;
	    *p = '\0';
	    SvCUR(sv) = p - SvPVX(sv);
	    continue;	/* not "break" */
	}

	have = esignlen + zeros + elen;
	need = (have > width ? have : width);
	gap = need - have;

	SvGROW(sv, SvCUR(sv) + need + 1);
	p = SvEND(sv);
	if (esignlen && fill == '0') {
	    for (i = 0; i < esignlen; i++)
		*p++ = esignbuf[i];
	}
	if (gap && !left) {
	    memset(p, fill, gap);
	    p += gap;
	}
	if (esignlen && fill != '0') {
	    for (i = 0; i < esignlen; i++)
		*p++ = esignbuf[i];
	}
	if (zeros) {
	    for (i = zeros; i; i--)
		*p++ = '0';
	}
	if (elen) {
	    memcpy(p, eptr, elen);
	    p += elen;
	}
	if (gap && left) {
	    memset(p, ' ', gap);
	    p += gap;
	}
	*p = '\0';
	SvCUR(sv) = p - SvPVX(sv);
    }
}

void
sv_dump(SV *sv)
{
#ifdef DEBUGGING
    SV *d = sv_newmortal();
    char *s;
d3430 1
a3430 1
	PerlIO_printf(Perl_debug_log, "SV = 0\n");
d3437 31
a3467 18
    sv_setpvf(d, "(0x%lx)\n  REFCNT = %ld\n  FLAGS = (",
	      (unsigned long)SvANY(sv), (long)SvREFCNT(sv));
    if (flags & SVs_PADBUSY)	sv_catpv(d, "PADBUSY,");
    if (flags & SVs_PADTMP)	sv_catpv(d, "PADTMP,");
    if (flags & SVs_PADMY)	sv_catpv(d, "PADMY,");
    if (flags & SVs_TEMP)	sv_catpv(d, "TEMP,");
    if (flags & SVs_OBJECT)	sv_catpv(d, "OBJECT,");
    if (flags & SVs_GMG)	sv_catpv(d, "GMG,");
    if (flags & SVs_SMG)	sv_catpv(d, "SMG,");
    if (flags & SVs_RMG)	sv_catpv(d, "RMG,");

    if (flags & SVf_IOK)	sv_catpv(d, "IOK,");
    if (flags & SVf_NOK)	sv_catpv(d, "NOK,");
    if (flags & SVf_POK)	sv_catpv(d, "POK,");
    if (flags & SVf_ROK)	sv_catpv(d, "ROK,");
    if (flags & SVf_OOK)	sv_catpv(d, "OOK,");
    if (flags & SVf_FAKE)	sv_catpv(d, "FAKE,");
    if (flags & SVf_READONLY)	sv_catpv(d, "READONLY,");
d3469 1
a3469 50
#ifdef OVERLOAD
    if (flags & SVf_AMAGIC)	sv_catpv(d, "OVERLOAD,");
#endif /* OVERLOAD */
    if (flags & SVp_IOK)	sv_catpv(d, "pIOK,");
    if (flags & SVp_NOK)	sv_catpv(d, "pNOK,");
    if (flags & SVp_POK)	sv_catpv(d, "pPOK,");
    if (flags & SVp_SCREAM)	sv_catpv(d, "SCREAM,");

    switch (type) {
    case SVt_PVCV:
    case SVt_PVFM:
	if (CvANON(sv))		sv_catpv(d, "ANON,");
	if (CvUNIQUE(sv))	sv_catpv(d, "UNIQUE,");
	if (CvCLONE(sv))	sv_catpv(d, "CLONE,");
	if (CvCLONED(sv))	sv_catpv(d, "CLONED,");
	if (CvNODEBUG(sv))	sv_catpv(d, "NODEBUG,");
	break;
    case SVt_PVHV:
	if (HvSHAREKEYS(sv))	sv_catpv(d, "SHAREKEYS,");
	if (HvLAZYDEL(sv))	sv_catpv(d, "LAZYDEL,");
	break;
    case SVt_PVGV:
	if (GvINTRO(sv))	sv_catpv(d, "INTRO,");
	if (GvMULTI(sv))	sv_catpv(d, "MULTI,");
	if (GvASSUMECV(sv))	sv_catpv(d, "ASSUMECV,");
	if (GvIMPORTED(sv)) {
	    sv_catpv(d, "IMPORT");
	    if (GvIMPORTED(sv) == GVf_IMPORTED)
		sv_catpv(d, "ALL,");
	    else {
		sv_catpv(d, "(");
		if (GvIMPORTED_SV(sv))	sv_catpv(d, " SV");
		if (GvIMPORTED_AV(sv))	sv_catpv(d, " AV");
		if (GvIMPORTED_HV(sv))	sv_catpv(d, " HV");
		if (GvIMPORTED_CV(sv))	sv_catpv(d, " CV");
		sv_catpv(d, " ),");
	    }
	}
    case SVt_PVBM:
	if (SvTAIL(sv))	sv_catpv(d, "TAIL,");
	if (SvCOMPILED(sv))	sv_catpv(d, "COMPILED,");
	break;
    }

    if (*(SvEND(d) - 1) == ',')
	SvPVX(d)[--SvCUR(d)] = '\0';
    sv_catpv(d, ")");
    s = SvPVX(d);

    PerlIO_printf(Perl_debug_log, "SV = ");
d3472 1
a3472 1
	PerlIO_printf(Perl_debug_log, "NULL%s\n", s);
d3475 1
a3475 1
	PerlIO_printf(Perl_debug_log, "IV%s\n", s);
d3478 1
a3478 1
	PerlIO_printf(Perl_debug_log, "NV%s\n", s);
d3481 1
a3481 1
	PerlIO_printf(Perl_debug_log, "RV%s\n", s);
d3484 1
a3484 1
	PerlIO_printf(Perl_debug_log, "PV%s\n", s);
d3487 1
a3487 1
	PerlIO_printf(Perl_debug_log, "PVIV%s\n", s);
d3490 1
a3490 1
	PerlIO_printf(Perl_debug_log, "PVNV%s\n", s);
d3493 1
a3493 1
	PerlIO_printf(Perl_debug_log, "PVBM%s\n", s);
d3496 1
a3496 1
	PerlIO_printf(Perl_debug_log, "PVMG%s\n", s);
d3499 1
a3499 1
	PerlIO_printf(Perl_debug_log, "PVLV%s\n", s);
d3502 1
a3502 1
	PerlIO_printf(Perl_debug_log, "PVAV%s\n", s);
d3505 1
a3505 1
	PerlIO_printf(Perl_debug_log, "PVHV%s\n", s);
d3508 1
a3508 1
	PerlIO_printf(Perl_debug_log, "PVCV%s\n", s);
d3511 1
a3511 1
	PerlIO_printf(Perl_debug_log, "PVGV%s\n", s);
d3514 1
a3514 1
	PerlIO_printf(Perl_debug_log, "PVFM%s\n", s);
d3517 1
a3517 1
	PerlIO_printf(Perl_debug_log, "PVIO%s\n", s);
d3520 1
a3520 1
	PerlIO_printf(Perl_debug_log, "UNKNOWN%s\n", s);
d3524 3
a3526 5
	PerlIO_printf(Perl_debug_log, "  IV = %ld\n", (long)SvIVX(sv));
    if (type >= SVt_PVNV || type == SVt_NV) {
	SET_NUMERIC_STANDARD();
	PerlIO_printf(Perl_debug_log, "  NV = %.*g\n", DBL_DIG, SvNVX(sv));
    }
d3528 1
a3528 1
	PerlIO_printf(Perl_debug_log, "  RV = 0x%lx\n", (long)SvRV(sv));
d3536 1
a3536 1
	    PerlIO_printf(Perl_debug_log, "  PV = 0x%lx \"%s\"\n  CUR = %ld\n  LEN = %ld\n",
d3539 1
a3539 1
	    PerlIO_printf(Perl_debug_log, "  PV = 0\n");
d3543 1
a3543 1
	    PerlIO_printf(Perl_debug_log, "  MAGIC = 0x%lx\n", (long)SvMAGIC(sv));
d3546 1
a3546 1
	    PerlIO_printf(Perl_debug_log, "  STASH = \"%s\"\n", HvNAME(SvSTASH(sv)));
d3550 4
a3553 4
	PerlIO_printf(Perl_debug_log, "  TYPE = %c\n", LvTYPE(sv));
	PerlIO_printf(Perl_debug_log, "  TARGOFF = %ld\n", (long)LvTARGOFF(sv));
	PerlIO_printf(Perl_debug_log, "  TARGLEN = %ld\n", (long)LvTARGLEN(sv));
	PerlIO_printf(Perl_debug_log, "  TARG = 0x%lx\n", (long)LvTARG(sv));
d3557 5
a3561 5
	PerlIO_printf(Perl_debug_log, "  ARRAY = 0x%lx\n", (long)AvARRAY(sv));
	PerlIO_printf(Perl_debug_log, "  ALLOC = 0x%lx\n", (long)AvALLOC(sv));
	PerlIO_printf(Perl_debug_log, "  FILL = %ld\n", (long)AvFILLp(sv));
	PerlIO_printf(Perl_debug_log, "  MAX = %ld\n", (long)AvMAX(sv));
	PerlIO_printf(Perl_debug_log, "  ARYLEN = 0x%lx\n", (long)AvARYLEN(sv));
d3563 7
a3569 6
	sv_setpv(d, "");
	if (flags & AVf_REAL)	sv_catpv(d, ",REAL");
	if (flags & AVf_REIFY)	sv_catpv(d, ",REIFY");
	if (flags & AVf_REUSED)	sv_catpv(d, ",REUSED");
	PerlIO_printf(Perl_debug_log, "  FLAGS = (%s)\n",
		      SvCUR(d) ? SvPVX(d) + 1 : "");
d3572 6
a3577 6
	PerlIO_printf(Perl_debug_log, "  ARRAY = 0x%lx\n",(long)HvARRAY(sv));
	PerlIO_printf(Perl_debug_log, "  KEYS = %ld\n", (long)HvKEYS(sv));
	PerlIO_printf(Perl_debug_log, "  FILL = %ld\n", (long)HvFILL(sv));
	PerlIO_printf(Perl_debug_log, "  MAX = %ld\n", (long)HvMAX(sv));
	PerlIO_printf(Perl_debug_log, "  RITER = %ld\n", (long)HvRITER(sv));
	PerlIO_printf(Perl_debug_log, "  EITER = 0x%lx\n",(long) HvEITER(sv));
d3579 1
a3579 1
	    PerlIO_printf(Perl_debug_log, "  PMROOT = 0x%lx\n",(long)HvPMROOT(sv));
d3581 1
a3581 1
	    PerlIO_printf(Perl_debug_log, "  NAME = \"%s\"\n", HvNAME(sv));
d3583 1
d3585 9
a3593 27
	if (SvPOK(sv)) {
	    STRLEN n_a;
	    PerlIO_printf(Perl_debug_log, "  PROTOTYPE = \"%s\"\n", SvPV(sv,n_a));
	}
	/* FALL THROUGH */
    case SVt_PVFM:
	PerlIO_printf(Perl_debug_log, "  STASH = 0x%lx\n", (long)CvSTASH(sv));
	PerlIO_printf(Perl_debug_log, "  START = 0x%lx\n", (long)CvSTART(sv));
	PerlIO_printf(Perl_debug_log, "  ROOT = 0x%lx\n", (long)CvROOT(sv));
	PerlIO_printf(Perl_debug_log, "  XSUB = 0x%lx\n", (long)CvXSUB(sv));
	PerlIO_printf(Perl_debug_log, "  XSUBANY = %ld\n", (long)CvXSUBANY(sv).any_i32);
	PerlIO_printf(Perl_debug_log, "  GV = 0x%lx", (long)CvGV(sv));
	if (CvGV(sv) && GvNAME(CvGV(sv))) {
	    PerlIO_printf(Perl_debug_log, "  \"%s\"\n", GvNAME(CvGV(sv)));
	} else {
	    PerlIO_printf(Perl_debug_log, "\n");
	}
	PerlIO_printf(Perl_debug_log, "  FILEGV = 0x%lx\n", (long)CvFILEGV(sv));
	PerlIO_printf(Perl_debug_log, "  DEPTH = %ld\n", (long)CvDEPTH(sv));
	PerlIO_printf(Perl_debug_log, "  PADLIST = 0x%lx\n", (long)CvPADLIST(sv));
	PerlIO_printf(Perl_debug_log, "  OUTSIDE = 0x%lx\n", (long)CvOUTSIDE(sv));
#ifdef USE_THREADS
	PerlIO_printf(Perl_debug_log, "  MUTEXP = 0x%lx\n", (long)CvMUTEXP(sv));
	PerlIO_printf(Perl_debug_log, "  OWNER = 0x%lx\n", (long)CvOWNER(sv));
#endif /* USE_THREADS */
	PerlIO_printf(Perl_debug_log, "  FLAGS = 0x%lx\n",
		      (unsigned long)CvFLAGS(sv));
d3595 1
a3595 1
	    PerlIO_printf(Perl_debug_log, "  LINES = %ld\n", (long)FmLINES(sv));
d3598 17
a3614 17
	PerlIO_printf(Perl_debug_log, "  NAME = \"%s\"\n", GvNAME(sv));
	PerlIO_printf(Perl_debug_log, "  NAMELEN = %ld\n", (long)GvNAMELEN(sv));
	PerlIO_printf(Perl_debug_log, "  STASH = \"%s\"\n",
	    SvTYPE(GvSTASH(sv)) == SVt_PVHV ? HvNAME(GvSTASH(sv)) : "(deleted)");
	PerlIO_printf(Perl_debug_log, "  GP = 0x%lx\n", (long)GvGP(sv));
	PerlIO_printf(Perl_debug_log, "    SV = 0x%lx\n", (long)GvSV(sv));
	PerlIO_printf(Perl_debug_log, "    REFCNT = %ld\n", (long)GvREFCNT(sv));
	PerlIO_printf(Perl_debug_log, "    IO = 0x%lx\n", (long)GvIOp(sv));
	PerlIO_printf(Perl_debug_log, "    FORM = 0x%lx\n", (long)GvFORM(sv));
	PerlIO_printf(Perl_debug_log, "    AV = 0x%lx\n", (long)GvAV(sv));
	PerlIO_printf(Perl_debug_log, "    HV = 0x%lx\n", (long)GvHV(sv));
	PerlIO_printf(Perl_debug_log, "    CV = 0x%lx\n", (long)GvCV(sv));
	PerlIO_printf(Perl_debug_log, "    CVGEN = 0x%lx\n", (long)GvCVGEN(sv));
	PerlIO_printf(Perl_debug_log, "    LASTEXPR = %ld\n", (long)GvLASTEXPR(sv));
	PerlIO_printf(Perl_debug_log, "    LINE = %ld\n", (long)GvLINE(sv));
	PerlIO_printf(Perl_debug_log, "    FILEGV = 0x%lx\n", (long)GvFILEGV(sv));
	PerlIO_printf(Perl_debug_log, "    EGV = 0x%lx\n", (long)GvEGV(sv));
d3617 56
a3672 16
	PerlIO_printf(Perl_debug_log, "  IFP = 0x%lx\n", (long)IoIFP(sv));
	PerlIO_printf(Perl_debug_log, "  OFP = 0x%lx\n", (long)IoOFP(sv));
	PerlIO_printf(Perl_debug_log, "  DIRP = 0x%lx\n", (long)IoDIRP(sv));
	PerlIO_printf(Perl_debug_log, "  LINES = %ld\n", (long)IoLINES(sv));
	PerlIO_printf(Perl_debug_log, "  PAGE = %ld\n", (long)IoPAGE(sv));
	PerlIO_printf(Perl_debug_log, "  PAGE_LEN = %ld\n", (long)IoPAGE_LEN(sv));
	PerlIO_printf(Perl_debug_log, "  LINES_LEFT = %ld\n", (long)IoLINES_LEFT(sv));
	PerlIO_printf(Perl_debug_log, "  TOP_NAME = \"%s\"\n", IoTOP_NAME(sv));
	PerlIO_printf(Perl_debug_log, "  TOP_GV = 0x%lx\n", (long)IoTOP_GV(sv));
	PerlIO_printf(Perl_debug_log, "  FMT_NAME = \"%s\"\n", IoFMT_NAME(sv));
	PerlIO_printf(Perl_debug_log, "  FMT_GV = 0x%lx\n", (long)IoFMT_GV(sv));
	PerlIO_printf(Perl_debug_log, "  BOTTOM_NAME = \"%s\"\n", IoBOTTOM_NAME(sv));
	PerlIO_printf(Perl_debug_log, "  BOTTOM_GV = 0x%lx\n", (long)IoBOTTOM_GV(sv));
	PerlIO_printf(Perl_debug_log, "  SUBPROCESS = %ld\n", (long)IoSUBPROCESS(sv));
	PerlIO_printf(Perl_debug_log, "  TYPE = %c\n", IoTYPE(sv));
	PerlIO_printf(Perl_debug_log, "  FLAGS = 0x%lx\n", (long)IoFLAGS(sv));
d3675 1
a3675 1
#endif	/* DEBUGGING */
d3677 1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a14 1
#define PERL_IN_SV_C
d17 57
a74 1
#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) sv_force_normal(sv)
d76 104
a179 6
static void do_report_used(pTHXo_ SV *sv);
static void do_clean_objs(pTHXo_ SV *sv);
#ifndef DISABLE_DESTRUCTOR_KLUDGE
static void do_clean_named_objs(pTHXo_ SV *sv);
#endif
static void do_clean_all(pTHXo_ SV *sv);
d185 7
a191 7
#define plant_SV(p) \
    STMT_START {					\
	SvANY(p) = (void *)PL_sv_root;			\
	SvFLAGS(p) = SVTYPEMASK;			\
	PL_sv_root = (p);				\
	--PL_sv_count;					\
    } STMT_END
d194 15
a208 19
#define uproot_SV(p) \
    STMT_START {					\
	(p) = PL_sv_root;				\
	PL_sv_root = (SV*)SvANY(p);			\
	++PL_sv_count;					\
    } STMT_END

#define new_SV(p) \
    STMT_START {					\
	LOCK_SV_MUTEX;					\
	if (PL_sv_root)					\
	    uproot_SV(p);				\
	else						\
	    (p) = more_sv();				\
	UNLOCK_SV_MUTEX;				\
	SvANY(p) = 0;					\
	SvREFCNT(p) = 1;				\
	SvFLAGS(p) = 0;					\
    } STMT_END
d212 8
a219 9
#define del_SV(p) \
    STMT_START {					\
	LOCK_SV_MUTEX;					\
	if (PL_debug & 32768)				\
	    del_sv(p);					\
	else						\
	    plant_SV(p);				\
	UNLOCK_SV_MUTEX;				\
    } STMT_END
d222 1
a222 1
S_del_sv(pTHX_ SV *p)
d236 1
a236 4
	    if (ckWARN_d(WARN_INTERNAL))	
	        Perl_warner(aTHX_ WARN_INTERNAL,
			    "Attempt to free non-arena SV: 0x%"UVxf,
			    PTR2UV(p));
d250 1
a250 1
Perl_sv_add_arena(pTHX_ char *ptr, U32 size, U32 flags)
d255 1
a255 1
    Zero(ptr, size, char);
d278 1
a278 1
S_more_sv(pTHX)
d296 1
a296 1
S_visit(pTHX_ SVFUNC_t f)
d306 1
a306 1
		(FCALL)(aTHXo_ sv);
d311 12
d324 23
a346 1
Perl_sv_report_used(pTHX)
d348 11
a358 1
    visit(do_report_used);
d360 1
d363 1
a363 1
Perl_sv_clean_objs(pTHX)
d366 1
a366 1
    visit(do_clean_objs);
d369 1
a369 1
    visit(do_clean_named_objs);
d374 8
d383 1
a383 1
Perl_sv_clean_all(pTHX)
d386 1
a386 1
    visit(do_clean_all);
d391 1
a391 1
Perl_sv_free_arenas(pTHX)
a415 10
void
Perl_report_uninit(pTHX)
{
    if (PL_op)
	Perl_warner(aTHX_ WARN_UNINITIALIZED, PL_warn_uninit,
		    " in ", PL_op_desc[PL_op->op_type]);
    else
	Perl_warner(aTHX_ WARN_UNINITIALIZED, PL_warn_uninit, "", "");
}

d417 1
a417 1
S_new_xiv(pTHX)
d433 1
a433 1
S_del_xiv(pTHX_ XPVIV *p)
d443 1
a443 1
S_more_xiv(pTHX)
d464 1
a464 1
S_new_xnv(pTHX)
d466 1
a466 1
    NV* xnv;
d471 1
a471 1
    PL_xnv_root = *(NV**)xnv;
d477 1
a477 1
S_del_xnv(pTHX_ XPVNV *p)
d479 1
a479 1
    NV* xnv = (NV*)((char*)(p) + STRUCT_OFFSET(XPVNV, xnv_nv));
d481 2
a482 2
    *(NV**)xnv = PL_xnv_root;
    PL_xnv_root = xnv;
d487 1
a487 1
S_more_xnv(pTHX)
d489 5
a493 5
    register NV* xnv;
    register NV* xnvend;
    New(711, xnv, 1008/sizeof(NV), NV);
    xnvend = &xnv[1008 / sizeof(NV) - 1];
    xnv += (sizeof(XPVIV) - 1) / sizeof(NV) + 1; /* fudge by sizeof XPVIV */
d496 1
a496 1
	*(NV**)xnv = (NV*)(xnv + 1);
d499 1
a499 1
    *(NV**)xnv = 0;
d503 1
a503 1
S_new_xrv(pTHX)
d516 1
a516 1
S_del_xrv(pTHX_ XRV *p)
d519 2
a520 2
    p->xrv_rv = (SV*)PL_xrv_root;
    PL_xrv_root = p;
d525 1
a525 1
S_more_xrv(pTHX)
d540 1
a540 1
S_new_xpv(pTHX)
d553 1
a553 1
S_del_xpv(pTHX_ XPV *p)
d556 2
a557 2
    p->xpv_pv = (char*)PL_xpv_root;
    PL_xpv_root = p;
d562 1
a562 1
S_more_xpv(pTHX)
d576 15
a590 12
STATIC XPVIV*
S_new_xpviv(pTHX)
{
    XPVIV* xpviv;
    LOCK_SV_MUTEX;
    if (!PL_xpviv_root)
	more_xpviv();
    xpviv = PL_xpviv_root;
    PL_xpviv_root = (XPVIV*)xpviv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpviv;
}
d592 7
a598 8
STATIC void
S_del_xpviv(pTHX_ XPVIV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpviv_root;
    PL_xpviv_root = p;
    UNLOCK_SV_MUTEX;
}
d600 7
d608 6
a613 2
STATIC void
S_more_xpviv(pTHX)
d615 3
a617 10
    register XPVIV* xpviv;
    register XPVIV* xpvivend;
    New(714, PL_xpviv_root, 1008/sizeof(XPVIV), XPVIV);
    xpviv = PL_xpviv_root;
    xpvivend = &xpviv[1008 / sizeof(XPVIV) - 1];
    while (xpviv < xpvivend) {
	xpviv->xpv_pv = (char*)(xpviv + 1);
	xpviv++;
    }
    xpviv->xpv_pv = 0;
d619 2
d622 32
d655 2
a656 2
STATIC XPVNV*
S_new_xpvnv(pTHX)
d658 7
a664 9
    XPVNV* xpvnv;
    LOCK_SV_MUTEX;
    if (!PL_xpvnv_root)
	more_xpvnv();
    xpvnv = PL_xpvnv_root;
    PL_xpvnv_root = (XPVNV*)xpvnv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvnv;
}
d666 2
a667 8
STATIC void
S_del_xpvnv(pTHX_ XPVNV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvnv_root;
    PL_xpvnv_root = p;
    UNLOCK_SV_MUTEX;
}
d669 2
d672 93
a764 11
STATIC void
S_more_xpvnv(pTHX)
{
    register XPVNV* xpvnv;
    register XPVNV* xpvnvend;
    New(715, PL_xpvnv_root, 1008/sizeof(XPVNV), XPVNV);
    xpvnv = PL_xpvnv_root;
    xpvnvend = &xpvnv[1008 / sizeof(XPVNV) - 1];
    while (xpvnv < xpvnvend) {
	xpvnv->xpv_pv = (char*)(xpvnv + 1);
	xpvnv++;
a765 2
    xpvnv->xpv_pv = 0;
}
d767 10
a776 464


STATIC XPVCV*
S_new_xpvcv(pTHX)
{
    XPVCV* xpvcv;
    LOCK_SV_MUTEX;
    if (!PL_xpvcv_root)
	more_xpvcv();
    xpvcv = PL_xpvcv_root;
    PL_xpvcv_root = (XPVCV*)xpvcv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvcv;
}

STATIC void
S_del_xpvcv(pTHX_ XPVCV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvcv_root;
    PL_xpvcv_root = p;
    UNLOCK_SV_MUTEX;
}


STATIC void
S_more_xpvcv(pTHX)
{
    register XPVCV* xpvcv;
    register XPVCV* xpvcvend;
    New(716, PL_xpvcv_root, 1008/sizeof(XPVCV), XPVCV);
    xpvcv = PL_xpvcv_root;
    xpvcvend = &xpvcv[1008 / sizeof(XPVCV) - 1];
    while (xpvcv < xpvcvend) {
	xpvcv->xpv_pv = (char*)(xpvcv + 1);
	xpvcv++;
    }
    xpvcv->xpv_pv = 0;
}



STATIC XPVAV*
S_new_xpvav(pTHX)
{
    XPVAV* xpvav;
    LOCK_SV_MUTEX;
    if (!PL_xpvav_root)
	more_xpvav();
    xpvav = PL_xpvav_root;
    PL_xpvav_root = (XPVAV*)xpvav->xav_array;
    UNLOCK_SV_MUTEX;
    return xpvav;
}

STATIC void
S_del_xpvav(pTHX_ XPVAV *p)
{
    LOCK_SV_MUTEX;
    p->xav_array = (char*)PL_xpvav_root;
    PL_xpvav_root = p;
    UNLOCK_SV_MUTEX;
}


STATIC void
S_more_xpvav(pTHX)
{
    register XPVAV* xpvav;
    register XPVAV* xpvavend;
    New(717, PL_xpvav_root, 1008/sizeof(XPVAV), XPVAV);
    xpvav = PL_xpvav_root;
    xpvavend = &xpvav[1008 / sizeof(XPVAV) - 1];
    while (xpvav < xpvavend) {
	xpvav->xav_array = (char*)(xpvav + 1);
	xpvav++;
    }
    xpvav->xav_array = 0;
}



STATIC XPVHV*
S_new_xpvhv(pTHX)
{
    XPVHV* xpvhv;
    LOCK_SV_MUTEX;
    if (!PL_xpvhv_root)
	more_xpvhv();
    xpvhv = PL_xpvhv_root;
    PL_xpvhv_root = (XPVHV*)xpvhv->xhv_array;
    UNLOCK_SV_MUTEX;
    return xpvhv;
}

STATIC void
S_del_xpvhv(pTHX_ XPVHV *p)
{
    LOCK_SV_MUTEX;
    p->xhv_array = (char*)PL_xpvhv_root;
    PL_xpvhv_root = p;
    UNLOCK_SV_MUTEX;
}


STATIC void
S_more_xpvhv(pTHX)
{
    register XPVHV* xpvhv;
    register XPVHV* xpvhvend;
    New(718, PL_xpvhv_root, 1008/sizeof(XPVHV), XPVHV);
    xpvhv = PL_xpvhv_root;
    xpvhvend = &xpvhv[1008 / sizeof(XPVHV) - 1];
    while (xpvhv < xpvhvend) {
	xpvhv->xhv_array = (char*)(xpvhv + 1);
	xpvhv++;
    }
    xpvhv->xhv_array = 0;
}


STATIC XPVMG*
S_new_xpvmg(pTHX)
{
    XPVMG* xpvmg;
    LOCK_SV_MUTEX;
    if (!PL_xpvmg_root)
	more_xpvmg();
    xpvmg = PL_xpvmg_root;
    PL_xpvmg_root = (XPVMG*)xpvmg->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvmg;
}

STATIC void
S_del_xpvmg(pTHX_ XPVMG *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvmg_root;
    PL_xpvmg_root = p;
    UNLOCK_SV_MUTEX;
}


STATIC void
S_more_xpvmg(pTHX)
{
    register XPVMG* xpvmg;
    register XPVMG* xpvmgend;
    New(719, PL_xpvmg_root, 1008/sizeof(XPVMG), XPVMG);
    xpvmg = PL_xpvmg_root;
    xpvmgend = &xpvmg[1008 / sizeof(XPVMG) - 1];
    while (xpvmg < xpvmgend) {
	xpvmg->xpv_pv = (char*)(xpvmg + 1);
	xpvmg++;
    }
    xpvmg->xpv_pv = 0;
}



STATIC XPVLV*
S_new_xpvlv(pTHX)
{
    XPVLV* xpvlv;
    LOCK_SV_MUTEX;
    if (!PL_xpvlv_root)
	more_xpvlv();
    xpvlv = PL_xpvlv_root;
    PL_xpvlv_root = (XPVLV*)xpvlv->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvlv;
}

STATIC void
S_del_xpvlv(pTHX_ XPVLV *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvlv_root;
    PL_xpvlv_root = p;
    UNLOCK_SV_MUTEX;
}


STATIC void
S_more_xpvlv(pTHX)
{
    register XPVLV* xpvlv;
    register XPVLV* xpvlvend;
    New(720, PL_xpvlv_root, 1008/sizeof(XPVLV), XPVLV);
    xpvlv = PL_xpvlv_root;
    xpvlvend = &xpvlv[1008 / sizeof(XPVLV) - 1];
    while (xpvlv < xpvlvend) {
	xpvlv->xpv_pv = (char*)(xpvlv + 1);
	xpvlv++;
    }
    xpvlv->xpv_pv = 0;
}


STATIC XPVBM*
S_new_xpvbm(pTHX)
{
    XPVBM* xpvbm;
    LOCK_SV_MUTEX;
    if (!PL_xpvbm_root)
	more_xpvbm();
    xpvbm = PL_xpvbm_root;
    PL_xpvbm_root = (XPVBM*)xpvbm->xpv_pv;
    UNLOCK_SV_MUTEX;
    return xpvbm;
}

STATIC void
S_del_xpvbm(pTHX_ XPVBM *p)
{
    LOCK_SV_MUTEX;
    p->xpv_pv = (char*)PL_xpvbm_root;
    PL_xpvbm_root = p;
    UNLOCK_SV_MUTEX;
}


STATIC void
S_more_xpvbm(pTHX)
{
    register XPVBM* xpvbm;
    register XPVBM* xpvbmend;
    New(721, PL_xpvbm_root, 1008/sizeof(XPVBM), XPVBM);
    xpvbm = PL_xpvbm_root;
    xpvbmend = &xpvbm[1008 / sizeof(XPVBM) - 1];
    while (xpvbm < xpvbmend) {
	xpvbm->xpv_pv = (char*)(xpvbm + 1);
	xpvbm++;
    }
    xpvbm->xpv_pv = 0;
}

#ifdef LEAKTEST
#  define my_safemalloc(s)	(void*)safexmalloc(717,s)
#  define my_safefree(p)	safexfree((char*)p)
#else
#  define my_safemalloc(s)	(void*)safemalloc(s)
#  define my_safefree(p)	safefree((char*)p)
#endif

#ifdef PURIFY

#define new_XIV()	my_safemalloc(sizeof(XPVIV))
#define del_XIV(p)	my_safefree(p)

#define new_XNV()	my_safemalloc(sizeof(XPVNV))
#define del_XNV(p)	my_safefree(p)

#define new_XRV()	my_safemalloc(sizeof(XRV))
#define del_XRV(p)	my_safefree(p)

#define new_XPV()	my_safemalloc(sizeof(XPV))
#define del_XPV(p)	my_safefree(p)

#define new_XPVIV()	my_safemalloc(sizeof(XPVIV))
#define del_XPVIV(p)	my_safefree(p)

#define new_XPVNV()	my_safemalloc(sizeof(XPVNV))
#define del_XPVNV(p)	my_safefree(p)

#define new_XPVCV()	my_safemalloc(sizeof(XPVCV))
#define del_XPVCV(p)	my_safefree(p)

#define new_XPVAV()	my_safemalloc(sizeof(XPVAV))
#define del_XPVAV(p)	my_safefree(p)

#define new_XPVHV()	my_safemalloc(sizeof(XPVHV))
#define del_XPVHV(p)	my_safefree(p)
  
#define new_XPVMG()	my_safemalloc(sizeof(XPVMG))
#define del_XPVMG(p)	my_safefree(p)

#define new_XPVLV()	my_safemalloc(sizeof(XPVLV))
#define del_XPVLV(p)	my_safefree(p)

#define new_XPVBM()	my_safemalloc(sizeof(XPVBM))
#define del_XPVBM(p)	my_safefree(p)

#else /* !PURIFY */

#define new_XIV()	(void*)new_xiv()
#define del_XIV(p)	del_xiv((XPVIV*) p)

#define new_XNV()	(void*)new_xnv()
#define del_XNV(p)	del_xnv((XPVNV*) p)

#define new_XRV()	(void*)new_xrv()
#define del_XRV(p)	del_xrv((XRV*) p)

#define new_XPV()	(void*)new_xpv()
#define del_XPV(p)	del_xpv((XPV *)p)

#define new_XPVIV()	(void*)new_xpviv()
#define del_XPVIV(p)	del_xpviv((XPVIV *)p)

#define new_XPVNV()	(void*)new_xpvnv()
#define del_XPVNV(p)	del_xpvnv((XPVNV *)p)

#define new_XPVCV()	(void*)new_xpvcv()
#define del_XPVCV(p)	del_xpvcv((XPVCV *)p)

#define new_XPVAV()	(void*)new_xpvav()
#define del_XPVAV(p)	del_xpvav((XPVAV *)p)

#define new_XPVHV()	(void*)new_xpvhv()
#define del_XPVHV(p)	del_xpvhv((XPVHV *)p)
  
#define new_XPVMG()	(void*)new_xpvmg()
#define del_XPVMG(p)	del_xpvmg((XPVMG *)p)

#define new_XPVLV()	(void*)new_xpvlv()
#define del_XPVLV(p)	del_xpvlv((XPVLV *)p)

#define new_XPVBM()	(void*)new_xpvbm()
#define del_XPVBM(p)	del_xpvbm((XPVBM *)p)

#endif /* PURIFY */

#define new_XPVGV()	my_safemalloc(sizeof(XPVGV))
#define del_XPVGV(p)	my_safefree(p)
 
#define new_XPVFM()	my_safemalloc(sizeof(XPVFM))
#define del_XPVFM(p)	my_safefree(p)
  
#define new_XPVIO()	my_safemalloc(sizeof(XPVIO))
#define del_XPVIO(p)	my_safefree(p)

/*
=for apidoc sv_upgrade

Upgrade an SV to a more complex form.  Use C<SvUPGRADE>.  See
C<svtype>.

=cut
*/

bool
Perl_sv_upgrade(pTHX_ register SV *sv, U32 mt)
{
    char*	pv;
    U32		cur;
    U32		len;
    IV		iv;
    NV		nv;
    MAGIC*	magic;
    HV*		stash;

    if (SvTYPE(sv) == mt)
	return TRUE;

    if (mt < SVt_PVIV)
	(void)SvOOK_off(sv);

    switch (SvTYPE(sv)) {
    case SVt_NULL:
	pv	= 0;
	cur	= 0;
	len	= 0;
	iv	= 0;
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
	break;
    case SVt_IV:
	pv	= 0;
	cur	= 0;
	len	= 0;
	iv	= SvIVX(sv);
	nv	= (NV)SvIVX(sv);
	del_XIV(SvANY(sv));
	magic	= 0;
	stash	= 0;
	if (mt == SVt_NV)
	    mt = SVt_PVNV;
	else if (mt < SVt_PVIV)
	    mt = SVt_PVIV;
	break;
    case SVt_NV:
	pv	= 0;
	cur	= 0;
	len	= 0;
	nv	= SvNVX(sv);
	iv	= I_V(nv);
	magic	= 0;
	stash	= 0;
	del_XNV(SvANY(sv));
	SvANY(sv) = 0;
	if (mt < SVt_PVNV)
	    mt = SVt_PVNV;
	break;
    case SVt_RV:
	pv	= (char*)SvRV(sv);
	cur	= 0;
	len	= 0;
	iv	= PTR2IV(pv);
	nv	= PTR2NV(pv);
	del_XRV(SvANY(sv));
	magic	= 0;
	stash	= 0;
	break;
    case SVt_PV:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= 0;
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
	del_XPV(SvANY(sv));
	if (mt <= SVt_IV)
	    mt = SVt_PVIV;
	else if (mt == SVt_NV)
	    mt = SVt_PVNV;
	break;
    case SVt_PVIV:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= 0.0;
	magic	= 0;
	stash	= 0;
	del_XPVIV(SvANY(sv));
	break;
    case SVt_PVNV:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= SvNVX(sv);
	magic	= 0;
	stash	= 0;
	del_XPVNV(SvANY(sv));
	break;
    case SVt_PVMG:
	pv	= SvPVX(sv);
	cur	= SvCUR(sv);
	len	= SvLEN(sv);
	iv	= SvIVX(sv);
	nv	= SvNVX(sv);
	magic	= SvMAGIC(sv);
	stash	= SvSTASH(sv);
	del_XPVMG(SvANY(sv));
	break;
    default:
	Perl_croak(aTHX_ "Can't upgrade that kind of scalar");
    }

    switch (mt) {
    case SVt_NULL:
	Perl_croak(aTHX_ "Can't upgrade to undef");
    case SVt_IV:
	SvANY(sv) = new_XIV();
	SvIVX(sv)	= iv;
	break;
    case SVt_NV:
	SvANY(sv) = new_XNV();
	SvNVX(sv)	= nv;
d929 150
d1080 1
a1080 1
Perl_sv_backoff(pTHX_ register SV *sv)
a1093 10
/*
=for apidoc sv_grow

Expands the character buffer in the SV.  This will use C<sv_unref> and will
upgrade the SV to C<SVt_PV>.  Returns a pointer to the character buffer.
Use C<SvGROW>.

=cut
*/

d1095 5
a1099 1
Perl_sv_grow(pTHX_ register SV *sv, register STRLEN newlen)
d1105 1
a1105 2
	PerlIO_printf(Perl_debug_log,
		      "Allocation too large: %"UVxf"\n", (UV)newlen);
d1129 1
a1129 1
#if defined(MYMALLOC) && !defined(LEAKTEST)
a1145 9
/*
=for apidoc sv_setiv

Copies an integer into the given SV.  Does not handle 'set' magic.  See
C<sv_setiv_mg>.

=cut
*/

d1147 1
a1147 1
Perl_sv_setiv(pTHX_ register SV *sv, IV i)
d1163 5
d1175 2
a1176 2
	    Perl_croak(aTHX_ "Can't coerce %s to integer in %s", sv_reftype(sv,0),
		  PL_op_desc[PL_op->op_type]);
a1183 8
/*
=for apidoc sv_setiv_mg

Like C<sv_setiv>, but also handles 'set' magic.

=cut
*/

d1185 1
a1185 1
Perl_sv_setiv_mg(pTHX_ register SV *sv, IV i)
a1190 9
/*
=for apidoc sv_setuv

Copies an unsigned integer into the given SV.  Does not handle 'set' magic.
See C<sv_setuv_mg>.

=cut
*/

d1192 1
a1192 1
Perl_sv_setuv(pTHX_ register SV *sv, UV u)
d1194 4
a1197 3
    sv_setiv(sv, 0);
    SvIsUV_on(sv);
    SvUVX(sv) = u;
a1199 8
/*
=for apidoc sv_setuv_mg

Like C<sv_setuv>, but also handles 'set' magic.

=cut
*/

d1201 1
a1201 1
Perl_sv_setuv_mg(pTHX_ register SV *sv, UV u)
a1206 9
/*
=for apidoc sv_setnv

Copies a double into the given SV.  Does not handle 'set' magic.  See
C<sv_setnv_mg>.

=cut
*/

d1208 1
a1208 1
Perl_sv_setnv(pTHX_ register SV *sv, NV num)
d1223 5
d1235 2
a1236 2
	    Perl_croak(aTHX_ "Can't coerce %s to number in %s", sv_reftype(sv,0),
		  PL_op_name[PL_op->op_type]);
a1243 8
/*
=for apidoc sv_setnv_mg

Like C<sv_setnv>, but also handles 'set' magic.

=cut
*/

d1245 1
a1245 1
Perl_sv_setnv_mg(pTHX_ register SV *sv, NV num)
d1252 1
a1252 1
S_not_a_number(pTHX_ SV *sv)
d1300 2
a1301 3
	Perl_warner(aTHX_ WARN_NUMERIC,
		    "Argument \"%s\" isn't numeric in %s", tmpbuf,
		PL_op_desc[PL_op->op_type]);
d1303 1
a1303 2
	Perl_warner(aTHX_ WARN_NUMERIC,
		    "Argument \"%s\" isn't numeric", tmpbuf);
a1305 9
/* the number can be converted to integer with atol() or atoll() */
#define IS_NUMBER_TO_INT_BY_ATOL 0x01
#define IS_NUMBER_TO_INT_BY_ATOF 0x02 /* atol() may be != atof() */
#define IS_NUMBER_NOT_IV	 0x04 /* (IV)atof() may be != atof() */
#define IS_NUMBER_NEG		 0x08 /* not good to cache UV */

/* Actually, ISO C leaves conversion of UV to IV undefined, but
   until proven guilty, assume that things are not that bad... */

d1307 1
a1307 1
Perl_sv_2iv(pTHX_ register SV *sv)
d1316 4
a1319 1
	    return I_V(SvNVX(sv));
d1324 1
a1324 1
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
d1326 2
a1327 2
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
		    report_uninit();
d1334 1
d1337 3
a1339 2
	      return SvIV(tmpstr);
	  return PTR2IV(SvRV(sv));
d1341 11
a1351 4
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    dTHR;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
d1355 10
a1364 7
    if (SvIOKp(sv)) {
	if (SvIsUV(sv)) {
	    return (IV)(SvUVX(sv));
	}
	else {
	    return SvIVX(sv);
	}
a1366 8
	/* We can cache the IV/UV value even if it not good enough
	 * to reconstruct NV, since the conversion to PV will prefer
	 * NV over IV/UV.
	 */

	if (SvTYPE(sv) == SVt_NV)
	    sv_upgrade(sv, SVt_PVNV);

d1368 1
a1368 1
	if (SvNVX(sv) < (NV)IV_MAX + 0.5)
d1370 1
a1370 1
	else {
a1371 9
	    SvIsUV_on(sv);
	  ret_iv_max:
	    DEBUG_c(PerlIO_printf(Perl_debug_log, 
				  "0x%"UVxf" 2iv(%"UVuf" => %"IVdf") (as unsigned)\n",
				  PTR2UV(sv),
				  SvUVX(sv),
				  SvUVX(sv)));
	    return (IV)SvUVX(sv);
	}
d1374 2
a1375 55
	I32 numtype = looks_like_number(sv);

	/* We want to avoid a possible problem when we cache an IV which
	   may be later translated to an NV, and the resulting NV is not
	   the translation of the initial data.
	  
	   This means that if we cache such an IV, we need to cache the
	   NV as well.  Moreover, we trade speed for space, and do not
	   cache the NV if not needed.
	 */
	if (numtype & IS_NUMBER_NOT_IV) {
	    /* May be not an integer.  Need to cache NV if we cache IV
	     * - otherwise future conversion to NV will be wrong.  */
	    NV d;

	    d = Atof(SvPVX(sv));

	    if (SvTYPE(sv) < SVt_PVNV)
		sv_upgrade(sv, SVt_PVNV);
	    SvNVX(sv) = d;
	    (void)SvNOK_on(sv);
	    (void)SvIOK_on(sv);
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%" PERL_PRIgldbl ")\n",
				  PTR2UV(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%g)\n",
				  PTR2UV(sv), SvNVX(sv)));
#endif
	    if (SvNVX(sv) < (NV)IV_MAX + 0.5)
		SvIVX(sv) = I_V(SvNVX(sv));
	    else {
		SvUVX(sv) = U_V(SvNVX(sv));
		SvIsUV_on(sv);
		goto ret_iv_max;
	    }
	}
	else if (numtype) {
	    /* The NV may be reconstructed from IV - safe to cache IV,
	       which may be calculated by atol(). */
	    if (SvTYPE(sv) == SVt_PV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    SvIVX(sv) = Atol(SvPVX(sv));
	}
	else {				/* Not a number.  Cache 0. */
	    dTHR;

	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
	    SvIVX(sv) = 0;
	    (void)SvIOK_on(sv);
	    if (ckWARN(WARN_NUMERIC))
		not_a_number(sv);
	}
d1379 2
a1380 5
	if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	    report_uninit();
	if (SvTYPE(sv) < SVt_IV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    sv_upgrade(sv, SVt_IV);
d1383 3
a1385 3
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%"IVdf")\n",
	PTR2UV(sv),SvIVX(sv)));
    return SvIsUV(sv) ? (IV)SvUVX(sv) : SvIVX(sv);
d1389 1
a1389 1
Perl_sv_2uv(pTHX_ register SV *sv)
d1402 1
a1402 1
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
d1404 2
a1405 2
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
		    report_uninit();
d1412 1
d1415 3
a1417 2
	      return SvUV(tmpstr);
	  return PTR2UV(SvRV(sv));
d1419 8
a1426 4
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    dTHR;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
d1430 10
a1439 7
    if (SvIOKp(sv)) {
	if (SvIsUV(sv)) {
	    return SvUVX(sv);
	}
	else {
	    return (UV)SvIVX(sv);
	}
a1441 6
	/* We can cache the IV/UV value even if it not good enough
	 * to reconstruct NV, since the conversion to PV will prefer
	 * NV over IV/UV.
	 */
	if (SvTYPE(sv) == SVt_NV)
	    sv_upgrade(sv, SVt_PVNV);
d1443 1
a1443 14
	if (SvNVX(sv) >= -0.5) {
	    SvIsUV_on(sv);
	    SvUVX(sv) = U_V(SvNVX(sv));
	}
	else {
	    SvIVX(sv) = I_V(SvNVX(sv));
	  ret_zero:
	    DEBUG_c(PerlIO_printf(Perl_debug_log, 
				  "0x%"UVxf" 2uv(%"IVdf" => %"IVdf") (as signed)\n",
				  PTR2UV(sv),
				  SvIVX(sv),
				  (IV)(UV)SvIVX(sv)));
	    return (UV)SvIVX(sv);
	}
d1446 2
a1447 73
	I32 numtype = looks_like_number(sv);

	/* We want to avoid a possible problem when we cache a UV which
	   may be later translated to an NV, and the resulting NV is not
	   the translation of the initial data.
	  
	   This means that if we cache such a UV, we need to cache the
	   NV as well.  Moreover, we trade speed for space, and do not
	   cache the NV if not needed.
	 */
	if (numtype & IS_NUMBER_NOT_IV) {
	    /* May be not an integer.  Need to cache NV if we cache IV
	     * - otherwise future conversion to NV will be wrong.  */
	    NV d;

	    d = Atof(SvPVX(sv));

	    if (SvTYPE(sv) < SVt_PVNV)
		sv_upgrade(sv, SVt_PVNV);
	    SvNVX(sv) = d;
	    (void)SvNOK_on(sv);
	    (void)SvIOK_on(sv);
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2nv(%" PERL_PRIgldbl ")\n",
				  PTR2UV(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2nv(%g)\n",
				  PTR2UV(sv), SvNVX(sv)));
#endif
	    if (SvNVX(sv) < -0.5) {
		SvIVX(sv) = I_V(SvNVX(sv));
		goto ret_zero;
	    } else {
		SvUVX(sv) = U_V(SvNVX(sv));
		SvIsUV_on(sv);
	    }
	}
	else if (numtype & IS_NUMBER_NEG) {
	    /* The NV may be reconstructed from IV - safe to cache IV,
	       which may be calculated by atol(). */
	    if (SvTYPE(sv) == SVt_PV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    SvIVX(sv) = (IV)Atol(SvPVX(sv));
	}
	else if (numtype) {		/* Non-negative */
	    /* The NV may be reconstructed from UV - safe to cache UV,
	       which may be calculated by strtoul()/atol. */
	    if (SvTYPE(sv) == SVt_PV)
		sv_upgrade(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    (void)SvIsUV_on(sv);
#ifdef HAS_STRTOUL
	    SvUVX(sv) = Strtoul(SvPVX(sv), Null(char**), 10);
#else			/* no atou(), but we know the number fits into IV... */
	    		/* The only problem may be if it is negative... */
	    SvUVX(sv) = (UV)Atol(SvPVX(sv));
#endif
	}
	else {				/* Not a number.  Cache 0. */
	    dTHR;

	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
	    SvUVX(sv) = 0;		/* We assume that 0s have the
					   same bitmap in IV and UV. */
	    (void)SvIOK_on(sv);
	    (void)SvIsUV_on(sv);
	    if (ckWARN(WARN_NUMERIC))
		not_a_number(sv);
	}
d1450 1
a1450 1
	if (!(SvFLAGS(sv) & SVs_PADTMP)) {
d1452 2
a1453 2
	    if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
		report_uninit();
a1454 3
	if (SvTYPE(sv) < SVt_IV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    sv_upgrade(sv, SVt_IV);
d1457 3
a1459 4

    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2uv(%"UVuf")\n",
			  PTR2UV(sv),SvUVX(sv)));
    return SvIsUV(sv) ? SvUVX(sv) : (UV)SvIVX(sv);
d1462 2
a1463 2
NV
Perl_sv_2nv(pTHX_ register SV *sv)
d1472 1
a1472 2
	    dTHR;
	    if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) && !looks_like_number(sv))
d1474 2
a1475 1
	    return Atof(SvPVX(sv));
d1477 2
a1478 6
	if (SvIOKp(sv)) {
	    if (SvIsUV(sv)) 
		return (NV)SvUVX(sv);
	    else
		return (NV)SvIVX(sv);
	}	
d1480 1
a1480 1
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
d1482 2
a1483 2
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
		    report_uninit();
d1490 1
d1493 3
a1495 2
	      return SvNV(tmpstr);
	  return PTR2NV(SvRV(sv));
d1497 11
a1507 4
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    dTHR;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
d1516 3
a1518 16
#if defined(USE_LONG_DOUBLE)
	DEBUG_c({
	    RESTORE_NUMERIC_STANDARD();
	    PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" num(%" PERL_PRIgldbl ")\n",
			  PTR2UV(sv), SvNVX(sv));
	    RESTORE_NUMERIC_LOCAL();
	});
#else
	DEBUG_c({
	    RESTORE_NUMERIC_STANDARD();
	    PerlIO_printf(Perl_debug_log, "0x%"UVxf" num(%g)\n",
			  PTR2UV(sv), SvNVX(sv));
	    RESTORE_NUMERIC_LOCAL();
	});
#endif
d1525 1
a1525 1
	SvNVX(sv) = SvIsUV(sv) ? (NV)SvUVX(sv) : (NV)SvIVX(sv);
d1528 1
a1528 2
	dTHR;
	if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) && !looks_like_number(sv))
d1530 2
a1531 1
	SvNVX(sv) = Atof(SvPVX(sv));
d1535 2
a1536 5
	if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	    report_uninit();
	if (SvTYPE(sv) < SVt_NV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    sv_upgrade(sv, SVt_NV);
d1540 3
a1542 15
#if defined(USE_LONG_DOUBLE)
    DEBUG_c({
	RESTORE_NUMERIC_STANDARD();
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2nv(%" PERL_PRIgldbl ")\n",
		      PTR2UV(sv), SvNVX(sv));
	RESTORE_NUMERIC_LOCAL();
    });
#else
    DEBUG_c({
	RESTORE_NUMERIC_STANDARD();
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 1nv(%g)\n",
		      PTR2UV(sv), SvNVX(sv));
	RESTORE_NUMERIC_LOCAL();
    });
#endif
d1547 1
a1547 1
S_asIV(pTHX_ SV *sv)
d1550 1
a1550 1
    NV d;
d1552 10
a1561 9
    if (numtype & IS_NUMBER_TO_INT_BY_ATOL)
	return Atol(SvPVX(sv));
    if (!numtype) {
	dTHR;
	if (ckWARN(WARN_NUMERIC))
	    not_a_number(sv);
    }
    d = Atof(SvPVX(sv));
    return I_V(d);
d1565 1
a1565 1
S_asUV(pTHX_ SV *sv)
d1570 2
a1571 2
    if (numtype & IS_NUMBER_TO_INT_BY_ATOL)
	return Strtoul(SvPVX(sv), Null(char**), 10);
d1573 4
a1576 6
    if (!numtype) {
	dTHR;
	if (ckWARN(WARN_NUMERIC))
	    not_a_number(sv);
    }
    return U_V(Atof(SvPVX(sv)));
a1578 22
/*
 * Returns a combination of (advisory only - can get false negatives)
 * 	IS_NUMBER_TO_INT_BY_ATOL, IS_NUMBER_TO_INT_BY_ATOF, IS_NUMBER_NOT_IV,
 *	IS_NUMBER_NEG
 * 0 if does not look like number.
 *
 * In fact possible values are 0 and
 * IS_NUMBER_TO_INT_BY_ATOL				123
 * IS_NUMBER_TO_INT_BY_ATOL | IS_NUMBER_NOT_IV		123.1
 * IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV		123e0
 * with a possible addition of IS_NUMBER_NEG.
 */

/*
=for apidoc looks_like_number

Test if an the content of an SV looks like a number (or is a
number).

=cut
*/

d1580 1
a1580 1
Perl_looks_like_number(pTHX_ SV *sv)
d1585 1
a1585 2
    register char *nbegin;
    I32 numtype = 0;
d1601 1
a1601 1
    if (*s == '-') {
a1602 11
	numtype = IS_NUMBER_NEG;
    }
    else if (*s == '+')
	s++;

    nbegin = s;
    /*
     * we return IS_NUMBER_TO_INT_BY_ATOL if the number can be converted
     * to _integer_ with atol() and IS_NUMBER_TO_INT_BY_ATOF if you need
     * (int)atof().
     */
d1604 1
a1604 1
    /* next must be digit or the radix separator */
d1609 1
a1609 11

	if (s - nbegin >= TYPE_DIGITS(IV))	/* Cannot cache ato[ul]() */
	    numtype |= IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV;
	else
	    numtype |= IS_NUMBER_TO_INT_BY_ATOL;

        if (*s == '.'
#ifdef USE_LOCALE_NUMERIC 
	    || IS_NUMERIC_RADIX(*s)
#endif
	    ) {
d1611 1
a1611 2
	    numtype |= IS_NUMBER_NOT_IV;
            while (isDIGIT(*s))  /* optional digits after the radix */
d1615 1
a1615 5
    else if (*s == '.'
#ifdef USE_LOCALE_NUMERIC 
	    || IS_NUMERIC_RADIX(*s)
#endif
	    ) {
d1617 1
a1617 2
	numtype |= IS_NUMBER_TO_INT_BY_ATOL | IS_NUMBER_NOT_IV;
        /* no digits before the radix means we need digits after it */
d1629 6
d1637 1
a1637 2
	numtype &= ~IS_NUMBER_NEG;
	numtype |= IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV;
d1654 1
a1654 1
	return IS_NUMBER_TO_INT_BY_ATOL;
d1659 1
a1659 34
Perl_sv_2pv_nolen(pTHX_ register SV *sv)
{
    STRLEN n_a;
    return sv_2pv(sv, &n_a);
}

/* We assume that buf is at least TYPE_CHARS(UV) long. */
static char *
uiv_2buf(char *buf, IV iv, UV uv, int is_uv, char **peob)
{
    char *ptr = buf + TYPE_CHARS(UV);
    char *ebuf = ptr;
    int sign;

    if (is_uv)
	sign = 0;
    else if (iv >= 0) {
	uv = iv;
	sign = 0;
    } else {
	uv = -iv;
	sign = 1;
    }
    do {
	*--ptr = '0' + (uv % 10);
    } while (uv /= 10);
    if (sign)
	*--ptr = '-';
    *peob = ebuf;
    return ptr;
}

char *
Perl_sv_2pv(pTHX_ register SV *sv, STRLEN *lp)
d1664 1
a1664 2
    char tbuf[64];	/* Must fit sprintf/Gconvert of longest IV/NV */
    char *tmpbuf = tbuf;
d1677 1
a1677 4
	    if (SvIsUV(sv)) 
		(void)sprintf(tmpbuf,"%"UVuf, (UV)SvUVX(sv));
	    else
		(void)sprintf(tmpbuf,"%"IVdf, (IV)SvIVX(sv));
d1682 2
a1683 1
	    Gconvert(SvNVX(sv), NV_DIG, 0, tmpbuf);
d1688 1
a1688 1
	    if (!(SvFLAGS(sv) & SVs_PADTMP)) {
d1690 2
a1691 2
		if (ckWARN(WARN_UNINITIALIZED) && !PL_localizing)
		    report_uninit();
d1699 1
d1702 2
a1703 1
		return SvPV(tmpstr,*lp);
d1728 1
a1728 1
 			    while((ch = *fptr++)) {
d1775 1
a1775 1
		    Perl_sv_setpvf(aTHX_ tsv, "%s=%s", HvNAME(SvSTASH(sv)), s);
d1778 1
a1778 1
		Perl_sv_catpvf(aTHX_ tsv, "(0x%"UVxf")", PTR2UV(sv));
d1784 14
a1797 4
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    dTHR;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
d1802 2
a1803 5
    if (SvNOKp(sv)) {			/* See note in sv_2uv() */
	/* XXXX 64-bit?  IV may have better precision... */
	/* I tried changing this for to be 64-bit-aware and
	 * the t/op/numconvert.t became very, very, angry.
	 * --jhi Sep 1999 */
d1815 2
a1816 1
	    Gconvert(SvNVX(sv), NV_DIG, 0, s);
d1830 1
a1830 5
	U32 isIOK = SvIOK(sv);
	U32 isUIOK = SvIsUV(sv);
	char buf[TYPE_CHARS(UV)];
	char *ebuf, *ptr;

d1833 3
a1835 7
	if (isUIOK)
	    ptr = uiv_2buf(buf, 0, SvUVX(sv), 1, &ebuf);
	else
	    ptr = uiv_2buf(buf, SvIVX(sv), 0, 0, &ebuf);
	SvGROW(sv, ebuf - ptr + 1);	/* inlined from sv_setpvn */
	Move(ptr,SvPVX(sv),ebuf - ptr,char);
	SvCUR_set(sv, ebuf - ptr);
d1837 1
a1837 2
	*s = '\0';
	if (isIOK)
a1840 3
	if (isUIOK)
	    SvIsUV_on(sv);
	SvPOK_on(sv);
d1844 2
a1845 5
	if (ckWARN(WARN_UNINITIALIZED)
	    && !PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP))
	{
	    report_uninit();
	}
a1846 3
	if (SvTYPE(sv) < SVt_PV)
	    /* Typically the caller expects that sv_any is not NULL now.  */
	    sv_upgrade(sv, SVt_PV);
d1852 1
a1852 2
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2pv(%s)\n",
			  PTR2UV(sv),SvPVX(sv)));
a1894 27
char *
Perl_sv_2pvbyte_nolen(pTHX_ register SV *sv)
{
    STRLEN n_a;
    return sv_2pvbyte(sv, &n_a);
}

char *
Perl_sv_2pvbyte(pTHX_ register SV *sv, STRLEN *lp)
{
    return sv_2pv(sv,lp);
}

char *
Perl_sv_2pvutf8_nolen(pTHX_ register SV *sv)
{
    STRLEN n_a;
    return sv_2pvutf8(sv, &n_a);
}

char *
Perl_sv_2pvutf8(pTHX_ register SV *sv, STRLEN *lp)
{
    sv_utf8_upgrade(sv);
    return sv_2pv(sv,lp);
}
 
d1897 1
a1897 1
Perl_sv_2bool(pTHX_ register SV *sv)
d1905 2
d1910 3
a1912 1
	    return SvTRUE(tmpsv);
a1936 133
void
Perl_sv_utf8_upgrade(pTHX_ register SV *sv)
{
    int hicount;
    char *c;

    if (!sv || !SvPOK(sv) || SvUTF8(sv))
	return;

    /* This function could be much more efficient if we had a FLAG
     * to signal if there are any hibit chars in the string
     */
    hicount = 0;
    for (c = SvPVX(sv); c < SvEND(sv); c++) {
	if (*c & 0x80)
	    hicount++;
    }

    if (hicount) {
	char *src, *dst;
	SvGROW(sv, SvCUR(sv) + hicount + 1);

	src = SvEND(sv) - 1;
	SvCUR_set(sv, SvCUR(sv) + hicount);
	dst = SvEND(sv) - 1;

	while (src < dst) {
	    if (*src & 0x80) {
		dst--;
		uv_to_utf8((U8*)dst, (U8)*src--);
		dst--;
	    }
	    else {
		*dst-- = *src--;
	    }
	}

	SvUTF8_on(sv);
    }
}

bool
Perl_sv_utf8_downgrade(pTHX_ register SV* sv, bool fail_ok)
{
    if (SvPOK(sv) && SvUTF8(sv)) {
        char *c = SvPVX(sv);
        char *first_hi = 0;
        /* need to figure out if this is possible at all first */
        while (c < SvEND(sv)) {
            if (*c & 0x80) {
                I32 len;
                UV uv = utf8_to_uv((U8*)c, &len);
                if (uv >= 256) {
		    if (fail_ok)
			return FALSE;
		    else {
			/* XXX might want to make a callback here instead */
			Perl_croak(aTHX_ "Big byte");
		    }
		}
                if (!first_hi)
                    first_hi = c;
                c += len;
            }
            else {
                c++;
            }
        }

        if (first_hi) {
            char *src = first_hi;
            char *dst = first_hi;
            while (src < SvEND(sv)) {
                if (*src & 0x80) {
                    I32 len;
                    U8 u = (U8)utf8_to_uv((U8*)src, &len);
                    *dst++ = u;
                    src += len;
                }
                else {
                    *dst++ = *src++;
                }
            }
            SvCUR_set(sv, dst - SvPVX(sv));
        }
        SvUTF8_off(sv);
    }
    return TRUE;
}

void
Perl_sv_utf8_encode(pTHX_ register SV *sv)
{
    sv_utf8_upgrade(sv);
    SvUTF8_off(sv);
}

bool
Perl_sv_utf8_decode(pTHX_ register SV *sv)
{
    if (SvPOK(sv)) {
        char *c;
        bool has_utf = FALSE;
        if (!sv_utf8_downgrade(sv, TRUE))
	    return FALSE;

        /* it is actually just a matter of turning the utf8 flag on, but
         * we want to make sure everything inside is valid utf8 first.
         */
        c = SvPVX(sv);
        while (c < SvEND(sv)) {
            if (*c & 0x80) {
                I32 len;
                (void)utf8_to_uv((U8*)c, &len);
                if (len == 1) {
                    /* bad utf8 */
                    return FALSE;
                }
                c += len;
                has_utf = TRUE;
            }
            else {
                c++;
            }
        }

        if (has_utf)
            SvUTF8_on(sv);
    }
    return TRUE;
}


a1941 11
/*
=for apidoc sv_setsv

Copies the contents of the source SV C<ssv> into the destination SV C<dsv>.
The source SV may be destroyed if it is mortal.  Does not handle 'set'
magic.  See the macro forms C<SvSetSV>, C<SvSetSV_nosteal> and
C<sv_setsv_mg>.

=cut
*/

d1943 1
a1943 1
Perl_sv_setsv(pTHX_ SV *dstr, register SV *sstr)
d1958 8
d1967 1
a1967 1

a1993 2
	    if (SvIsUV(sstr))
		SvIsUV_on(dstr);
d2026 1
a2026 3
		if (GvIMPORTED(dstr) != GVf_IMPORTED
		    && CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		{
a2027 1
		}
d2052 2
a2053 2
	    Perl_croak(aTHX_ "Bizarre copy of %s in %s", sv_reftype(sstr, 0),
		PL_op_name[PL_op->op_type]);
d2055 1
a2055 1
	    Perl_croak(aTHX_ "Bizarre copy of %s", sv_reftype(sstr, 0));
d2074 1
a2074 1
		Perl_croak(aTHX_ "Can't redefine active sort subroutine %s",
d2081 1
a2081 3
	    if (GvIMPORTED(dstr) != GVf_IMPORTED
		&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
	    {
a2082 1
	    }
d2098 1
a2098 1
	    (void)SvUPGRADE(dstr, SVt_PVNV);
d2100 1
a2100 1
	    (void)SvUPGRADE(dstr, stype);
d2114 1
a2114 1
		    gp_free((GV*)dstr);
d2119 1
a2119 1
		    GvLINE(dstr) = CopLINE(PL_curcop);
d2130 1
a2130 3
		    if (!GvIMPORTED_AV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
a2131 1
		    }
d2139 1
a2139 3
		    if (!GvIMPORTED_HV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
a2140 1
		    }
d2170 1
a2170 1
				    Perl_croak(aTHX_ 
d2173 6
a2178 2
				if ((const_changed || const_sv) && ckWARN(WARN_REDEFINE))
				    Perl_warner(aTHX_ WARN_REDEFINE, const_sv ? 
d2182 1
d2192 1
a2192 3
		    if (!GvIMPORTED_CV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
a2193 1
		    }
d2208 1
a2208 3
		    if (!GvIMPORTED_SV(dstr)
			&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		    {
a2209 1
		    }
d2221 1
a2221 2
		if (SvLEN(dstr))
		    Safefree(SvPVX(dstr));
a2234 2
	    if (SvIsUV(sstr))
		SvIsUV_on(dstr);
d2236 1
d2240 1
d2260 1
a2260 1
		else if (SvLEN(dstr))
a2266 5
	    if (SvUTF8(sstr))
		SvUTF8_on(dstr);
	    else
		SvUTF8_off(dstr);

a2282 2
	if (DO_UTF8(sstr))
	    SvUTF8_on(dstr);
a2290 2
	    if (SvIsUV(sstr))
		SvIsUV_on(dstr);
a2298 3
	    /* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
	    if (SvIsUV(sstr))
		SvIsUV_on(dstr);
a2303 2
	if (SvIsUV(sstr))
	    SvIsUV_on(dstr);
d2307 2
a2308 2
	    if (ckWARN(WARN_MISC))
		Perl_warner(aTHX_ WARN_MISC, "Undefined value assigned to typeglob");
a2315 8
/*
=for apidoc sv_setsv_mg

Like C<sv_setsv>, but also handles 'set' magic.

=cut
*/

d2317 1
a2317 1
Perl_sv_setsv_mg(pTHX_ SV *dstr, register SV *sstr)
a2322 9
/*
=for apidoc sv_setpvn

Copies a string into an SV.  The C<len> parameter indicates the number of
bytes to be copied.  Does not handle 'set' magic.  See C<sv_setpvn_mg>.

=cut
*/

d2324 1
a2324 1
Perl_sv_setpvn(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
d2334 6
a2339 1
    (void)SvUPGRADE(sv, SVt_PV);
a2349 8
/*
=for apidoc sv_setpvn_mg

Like C<sv_setpvn>, but also handles 'set' magic.

=cut
*/

d2351 1
a2351 1
Perl_sv_setpvn_mg(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
a2356 9
/*
=for apidoc sv_setpv

Copies a string into an SV.  The string must be null-terminated.  Does not
handle 'set' magic.  See C<sv_setpv_mg>.

=cut
*/

d2358 1
a2358 1
Perl_sv_setpv(pTHX_ register SV *sv, register const char *ptr)
d2368 6
a2373 1
    (void)SvUPGRADE(sv, SVt_PV);
a2381 8
/*
=for apidoc sv_setpv_mg

Like C<sv_setpv>, but also handles 'set' magic.

=cut
*/

d2383 1
a2383 1
Perl_sv_setpv_mg(pTHX_ register SV *sv, register const char *ptr)
a2388 14
/*
=for apidoc sv_usepvn

Tells an SV to use C<ptr> to find its string value.  Normally the string is
stored inside the SV but sv_usepvn allows the SV to use an outside string. 
The C<ptr> should point to memory that was allocated by C<malloc>.  The
string length, C<len>, must be supplied.  This function will realloc the
memory pointed to by C<ptr>, so that pointer should not be freed or used by
the programmer after giving it to sv_usepvn.  Does not handle 'set' magic.
See C<sv_usepvn_mg>.

=cut
*/

d2390 1
a2390 1
Perl_sv_usepvn(pTHX_ register SV *sv, register char *ptr, register STRLEN len)
d2398 1
a2398 2
    (void)SvOOK_off(sv);
    if (SvPVX(sv) && SvLEN(sv))
a2408 8
/*
=for apidoc sv_usepvn_mg

Like C<sv_usepvn>, but also handles 'set' magic.

=cut
*/

d2410 1
a2410 1
Perl_sv_usepvn_mg(pTHX_ register SV *sv, register char *ptr, register STRLEN len)
d2416 2
a2417 2
void
Perl_sv_force_normal(pTHX_ register SV *sv)
d2422 1
a2422 1
	    Perl_croak(aTHX_ PL_no_modify);
a2425 2
    else if (SvFAKE(sv) && SvTYPE(sv) == SVt_PVGV)
	sv_unglob(sv);
a2427 11
/*
=for apidoc sv_chop

Efficient removal of characters from the beginning of the string buffer. 
SvPOK(sv) must be true and the C<ptr> must be a pointer to somewhere inside
the string buffer.  The C<ptr> becomes the first character of the adjusted
string.

=cut
*/

d2429 1
a2429 1
Perl_sv_chop(pTHX_ register SV *sv, register char *ptr)	/* like set but assuming ptr is in sv */
a2441 7
	if (!SvLEN(sv)) { /* make copy of shared string */
	    char *pvx = SvPVX(sv);
	    STRLEN len = SvCUR(sv);
	    SvGROW(sv, len + 1);
	    Move(pvx,SvPVX(sv),len,char);
	    *SvEND(sv) = '\0';
	}
d2445 1
a2445 1
    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVp_IOK|SVp_NOK|SVf_IVisUV);
a2452 10
/*
=for apidoc sv_catpvn

Concatenates the string onto the end of the string which is in the SV.  The
C<len> indicates number of bytes to copy.  Handles 'get' magic, but not
'set' magic.  See C<sv_catpvn_mg>.

=cut
*/

d2454 1
a2454 1
Perl_sv_catpvn(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
d2466 1
a2466 1
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
a2469 8
/*
=for apidoc sv_catpvn_mg

Like C<sv_catpvn>, but also handles 'set' magic.

=cut
*/

d2471 1
a2471 1
Perl_sv_catpvn_mg(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
a2476 9
/*
=for apidoc sv_catsv

Concatenates the string from SV C<ssv> onto the end of the string in SV
C<dsv>.  Handles 'get' magic, but not 'set' magic.  See C<sv_catsv_mg>.

=cut
*/

d2478 1
a2478 1
Perl_sv_catsv(pTHX_ SV *dstr, register SV *sstr)
d2484 1
a2484 3
    if ((s = SvPV(sstr, len))) {
	if (SvUTF8(sstr))
	    sv_utf8_upgrade(dstr);
a2485 3
	if (SvUTF8(sstr))
	    SvUTF8_on(dstr);
    }
a2487 8
/*
=for apidoc sv_catsv_mg

Like C<sv_catsv>, but also handles 'set' magic.

=cut
*/

d2489 1
a2489 1
Perl_sv_catsv_mg(pTHX_ SV *dstr, register SV *sstr)
a2494 9
/*
=for apidoc sv_catpv

Concatenates the string onto the end of the string which is in the SV.
Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.

=cut
*/

d2496 1
a2496 1
Perl_sv_catpv(pTHX_ register SV *sv, register const char *ptr)
d2511 1
a2511 1
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
a2514 8
/*
=for apidoc sv_catpv_mg

Like C<sv_catpv>, but also handles 'set' magic.

=cut
*/

d2516 1
a2516 1
Perl_sv_catpv_mg(pTHX_ register SV *sv, register const char *ptr)
d2523 1
a2523 1
Perl_newSV(pTHX_ STRLEN len)
d2528 3
a2539 8
/*
=for apidoc sv_magic

Adds magic to an SV.

=cut
*/

d2541 1
a2541 1
Perl_sv_magic(pTHX_ register SV *sv, SV *obj, int how, const char *name, I32 namlen)
d2548 1
a2548 1
	    Perl_croak(aTHX_ PL_no_modify);
d2581 1
a2581 1
	mg->mg_virtual = &PL_vtbl_sv;
d2583 1
d2585 1
a2585 1
        mg->mg_virtual = &PL_vtbl_amagic;
d2588 1
a2588 1
        mg->mg_virtual = &PL_vtbl_amagicelem;
d2593 1
d2595 1
a2595 7
	mg->mg_virtual = &PL_vtbl_bm;
	break;
    case 'D':
	mg->mg_virtual = &PL_vtbl_regdata;
	break;
    case 'd':
	mg->mg_virtual = &PL_vtbl_regdatum;
d2598 1
a2598 1
	mg->mg_virtual = &PL_vtbl_env;
d2601 1
a2601 1
	mg->mg_virtual = &PL_vtbl_fm;
d2604 1
a2604 1
	mg->mg_virtual = &PL_vtbl_envelem;
d2607 1
a2607 1
	mg->mg_virtual = &PL_vtbl_mglob;
d2610 1
a2610 1
	mg->mg_virtual = &PL_vtbl_isa;
d2613 1
a2613 1
	mg->mg_virtual = &PL_vtbl_isaelem;
d2616 1
a2616 1
	mg->mg_virtual = &PL_vtbl_nkeys;
d2623 1
a2623 1
	mg->mg_virtual = &PL_vtbl_dbline;
d2627 1
a2627 1
	mg->mg_virtual = &PL_vtbl_mutex;
d2632 1
a2632 1
        mg->mg_virtual = &PL_vtbl_collxfrm;
d2636 1
a2636 1
	mg->mg_virtual = &PL_vtbl_pack;
d2640 1
a2640 1
	mg->mg_virtual = &PL_vtbl_packelem;
d2643 1
a2643 1
	mg->mg_virtual = &PL_vtbl_regexp;
d2646 1
a2646 1
	mg->mg_virtual = &PL_vtbl_sig;
d2649 1
a2649 1
	mg->mg_virtual = &PL_vtbl_sigelem;
d2652 1
a2652 1
	mg->mg_virtual = &PL_vtbl_taint;
d2656 1
a2656 1
	mg->mg_virtual = &PL_vtbl_uvar;
d2659 1
a2659 1
	mg->mg_virtual = &PL_vtbl_vec;
d2662 1
a2662 1
	mg->mg_virtual = &PL_vtbl_substr;
d2665 1
a2665 1
	mg->mg_virtual = &PL_vtbl_defelem;
d2668 1
a2668 1
	mg->mg_virtual = &PL_vtbl_glob;
d2671 1
a2671 1
	mg->mg_virtual = &PL_vtbl_arylen;
d2674 1
a2674 4
	mg->mg_virtual = &PL_vtbl_pos;
	break;
    case '<':
	mg->mg_virtual = &PL_vtbl_backref;
d2683 1
a2683 1
	Perl_croak(aTHX_ "Don't know how to handle magic of type '%c'", how);
d2691 1
a2691 1
Perl_sv_unmagic(pTHX_ SV *sv, int type)
d2702 2
a2703 2
	    if (vtbl && vtbl->svt_free)
		CALL_FPTR(vtbl->svt_free)(aTHX_ sv, mg);
a2723 66
SV *
Perl_sv_rvweaken(pTHX_ SV *sv)
{
    SV *tsv;
    if (!SvOK(sv))  /* let undefs pass */
	return sv;
    if (!SvROK(sv))
	Perl_croak(aTHX_ "Can't weaken a nonreference");
    else if (SvWEAKREF(sv)) {
	dTHR;
	if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ WARN_MISC, "Reference is already weak");
	return sv;
    }
    tsv = SvRV(sv);
    sv_add_backref(tsv, sv);
    SvWEAKREF_on(sv);
    SvREFCNT_dec(tsv);              
    return sv;
}

STATIC void
S_sv_add_backref(pTHX_ SV *tsv, SV *sv)
{
    AV *av;
    MAGIC *mg;
    if (SvMAGICAL(tsv) && (mg = mg_find(tsv, '<')))
	av = (AV*)mg->mg_obj;
    else {
	av = newAV();
	sv_magic(tsv, (SV*)av, '<', NULL, 0);
	SvREFCNT_dec(av);           /* for sv_magic */
    }
    av_push(av,sv);
}

STATIC void 
S_sv_del_backref(pTHX_ SV *sv)
{
    AV *av;
    SV **svp;
    I32 i;
    SV *tsv = SvRV(sv);
    MAGIC *mg;
    if (!SvMAGICAL(tsv) || !(mg = mg_find(tsv, '<')))
	Perl_croak(aTHX_ "panic: del_backref");
    av = (AV *)mg->mg_obj;
    svp = AvARRAY(av);
    i = AvFILLp(av);
    while (i >= 0) {
	if (svp[i] == sv) {
	    svp[i] = &PL_sv_undef; /* XXX */
	}
	i--;
    }
}

/*
=for apidoc sv_insert

Inserts a string at the specified offset/length within the SV. Similar to
the Perl substr() function.

=cut
*/

d2725 1
a2725 1
Perl_sv_insert(pTHX_ SV *bigstr, STRLEN offset, STRLEN len, char *little, STRLEN littlelen)
d2736 1
a2736 1
	Perl_croak(aTHX_ "Can't modify non-existent substring");
a2743 1
    SvTAINT(bigstr);
d2770 1
a2770 1
	Perl_croak(aTHX_ "panic: sv_insert");
d2786 1
a2786 1
    else if ((i = mid - big)) {	/* faster from front */
d2810 1
a2810 1
Perl_sv_replace(pTHX_ register SV *sv, register SV *nsv)
a2811 1
    dTHR;
d2814 2
a2815 2
    if (SvREFCNT(nsv) != 1 && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL, "Reference miscount in sv_replace()");
d2836 1
a2836 1
Perl_sv_clear(pTHX_ register SV *sv)
d2866 2
a2867 2
		    call_sv((SV*)GvCV(destructor),
			    G_DISCARD|G_EVAL|G_KEEPERR);
a2869 1
		    SPAGAIN;
a2874 8

	    if (SvREFCNT(sv)) {
		if (PL_in_clean_objs)
		    Perl_croak(aTHX_ "DESTROY created new reference to dead object '%s'",
			  HvNAME(stash));
		/* DESTROY gave object new lease on life */
		return;
	    }
d2883 6
d2899 1
a2899 6
	{
	    io_close((IO*)sv, FALSE);
	}
	if (IoDIRP(sv) && !(IoFLAGS(sv) & IOf_FAKE_DIRP))
	    PerlDir_close(IoDIRP(sv));
	IoDIRP(sv) = (DIR*)NULL;
d2936 2
a2937 6
	if (SvROK(sv)) {
	    if (SvWEAKREF(sv))
	        sv_del_backref(sv);
	    else
	        SvREFCNT_dec(SvRV(sv));
	}
d3009 1
a3009 1
Perl_sv_newref(pTHX_ SV *sv)
d3017 1
a3017 1
Perl_sv_free(pTHX_ SV *sv)
a3018 1
    dTHR;
d3033 1
a3033 2
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL, "Attempt to free unreferenced scalar");
d3041 1
a3041 4
	if (ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ WARN_DEBUGGING,
			"Attempt to free temp prematurely: SV 0x%"UVxf,
			PTR2UV(sv));
a3054 8
/*
=for apidoc sv_len

Returns the length of the string in the SV.  See also C<SvCUR>.

=cut
*/

d3056 1
a3056 1
Perl_sv_len(pTHX_ register SV *sv)
a3070 94
STRLEN
Perl_sv_len_utf8(pTHX_ register SV *sv)
{
    U8 *s;
    U8 *send;
    STRLEN len;

    if (!sv)
	return 0;

#ifdef NOTYET
    if (SvGMAGICAL(sv))
	len = mg_length(sv);
    else
#endif
	s = (U8*)SvPV(sv, len);
    send = s + len;
    len = 0;
    while (s < send) {
	s += UTF8SKIP(s);
	len++;
    }
    return len;
}

void
Perl_sv_pos_u2b(pTHX_ register SV *sv, I32* offsetp, I32* lenp)
{
    U8 *start;
    U8 *s;
    U8 *send;
    I32 uoffset = *offsetp;
    STRLEN len;

    if (!sv)
	return;

    start = s = (U8*)SvPV(sv, len);
    send = s + len;
    while (s < send && uoffset--)
	s += UTF8SKIP(s);
    if (s >= send)
	s = send;
    *offsetp = s - start;
    if (lenp) {
	I32 ulen = *lenp;
	start = s;
	while (s < send && ulen--)
	    s += UTF8SKIP(s);
	if (s >= send)
	    s = send;
	*lenp = s - start;
    }
    return;
}

void
Perl_sv_pos_b2u(pTHX_ register SV *sv, I32* offsetp)
{
    U8 *s;
    U8 *send;
    STRLEN len;

    if (!sv)
	return;

    s = (U8*)SvPV(sv, len);
    if (len < *offsetp)
	Perl_croak(aTHX_ "panic: bad byte offset");
    send = s + *offsetp;
    len = 0;
    while (s < send) {
	s += UTF8SKIP(s);
	++len;
    }
    if (s != send) {
        dTHR;
	if (ckWARN_d(WARN_UTF8))    
	    Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-8 character");
	--len;
    }
    *offsetp = len;
    return;
}

/*
=for apidoc sv_eq

Returns a boolean indicating whether the strings in the two SVs are
identical.

=cut
*/

d3072 1
a3072 1
Perl_sv_eq(pTHX_ register SV *str1, register SV *str2)
a3096 10
/*
=for apidoc sv_cmp

Compares the strings in two SVs.  Returns -1, 0, or 1 indicating whether the
string in C<sv1> is less than, equal to, or greater than the string in
C<sv2>.

=cut
*/

d3098 1
a3098 1
Perl_sv_cmp(pTHX_ register SV *str1, register SV *str2)
d3100 4
a3103 2
    STRLEN cur1, cur2;
    char *pv1, *pv2;
a3105 32
    if (str1) {
        pv1 = SvPV(str1, cur1);
    }
    else {
	cur1 = 0;
    }

    if (str2) {
	if (SvPOK(str2)) {
	    if (SvPOK(str1) && SvUTF8(str1) != SvUTF8(str2) && !IN_BYTE) {
		/* must upgrade other to UTF8 first */
		if (SvUTF8(str1)) {
		    sv_utf8_upgrade(str2);
		}
		else {
		    sv_utf8_upgrade(str1);
		    /* refresh pointer and length */
		    pv1  = SvPVX(str1);
		    cur1 = SvCUR(str1);
		}
	    }
	    pv2  = SvPVX(str2);
	    cur2 = SvCUR(str2);
    	}
	else {
	    pv2 = sv_2pv(str2, &cur2);
	}
    }
    else {
	cur2 = 0;
    }

d3124 1
a3124 1
Perl_sv_cmp_locale(pTHX_ register SV *sv1, register SV *sv2)
d3179 1
a3179 1
Perl_sv_collxfrm(pTHX_ SV *sv, STRLEN *nxp)
d3225 1
a3225 1
Perl_sv_gets(pTHX_ register SV *sv, register PerlIO *fp, I32 append)
a3236 1

d3334 1
a3334 1
	"Screamer: entering, ptr=%"UVuf", cnt=%ld\n",PTR2UV(ptr),(long)cnt));
d3336 3
a3338 3
	"Screamer: entering: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	       PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
	       PTR2UV(PerlIO_has_base(fp) ? PerlIO_get_base(fp) : 0)));
d3368 1
a3368 2
			      "Screamer: going to getc, ptr=%"UVuf", cnt=%ld\n",
			      PTR2UV(ptr),(long)cnt));
d3371 3
a3373 3
	    "Screamer: pre: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
	    PTR2UV(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
d3379 3
a3381 3
	    "Screamer: post: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
	    PTR2UV(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
d3385 1
a3385 1
	    "Screamer: after getc, ptr=%"UVuf", cnt=%ld\n",PTR2UV(ptr),(long)cnt));
d3409 1
a3409 1
	    "Screamer: quitting, ptr=%"UVuf", cnt=%ld\n",PTR2UV(ptr),(long)cnt));
d3412 3
a3414 3
	"Screamer: end: FILE * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp), 
	PTR2UV(PerlIO_has_base (fp) ? PerlIO_get_base(fp) : 0)));
a3422 1
#ifndef EPOC
a3424 7
#else
	/* Need to work around EPOC SDK features          */
	/* On WINS: MS VC5 generates calls to _chkstk,    */
	/* if a `large' stack frame is allocated          */
	/* gcc on MARM does not generate calls like these */
	STDCHAR buf[1024];
#endif
d3479 4
a3486 8
/*
=for apidoc sv_inc

Auto-increment of the value in the SV.

=cut
*/

d3488 1
a3488 1
Perl_sv_inc(pTHX_ register SV *sv)
d3501 1
a3501 1
		Perl_croak(aTHX_ PL_no_modify);
d3505 4
a3508 3
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,inc))
		return;
	    i = PTR2IV(SvRV(sv));
d3520 5
a3524 13
	if (SvIsUV(sv)) {
	    if (SvUVX(sv) == UV_MAX)
		sv_setnv(sv, (NV)UV_MAX + 1.0);
	    else
		(void)SvIOK_only_UV(sv);
		++SvUVX(sv);
	} else {
	    if (SvIVX(sv) == IV_MAX)
		sv_setnv(sv, (NV)IV_MAX + 1.0);
	    else {
		(void)SvIOK_only(sv);
		++SvIVX(sv);
	    }	    
d3539 2
a3540 1
	sv_setnv(sv,Atof(SvPVX(sv)) + 1.0);  /* punt */
a3581 8
/*
=for apidoc sv_dec

Auto-decrement of the value in the SV.

=cut
*/

d3583 1
a3583 1
Perl_sv_dec(pTHX_ register SV *sv)
d3595 1
a3595 1
		Perl_croak(aTHX_ PL_no_modify);
d3599 4
a3602 3
	    if (SvAMAGIC(sv) && AMG_CALLun(sv,dec))
		return;
	    i = PTR2IV(SvRV(sv));
d3614 5
a3618 16
	if (SvIsUV(sv)) {
	    if (SvUVX(sv) == 0) {
		(void)SvIOK_only(sv);
		SvIVX(sv) = -1;
	    }
	    else {
		(void)SvIOK_only_UV(sv);
		--SvUVX(sv);
	    }	    
	} else {
	    if (SvIVX(sv) == IV_MIN)
		sv_setnv(sv, (NV)IV_MIN - 1.0);
	    else {
		(void)SvIOK_only(sv);
		--SvIVX(sv);
	    }	    
d3629 2
a3630 1
    sv_setnv(sv,Atof(SvPVX(sv)) - 1.0);	/* punt */
a3632 9
/*
=for apidoc sv_mortalcopy

Creates a new SV which is a copy of the original SV.  The new SV is marked
as mortal.

=cut
*/

d3638 8
d3647 1
a3647 1
Perl_sv_mortalcopy(pTHX_ SV *oldstr)
d3653 3
d3657 3
a3659 2
    EXTEND_MORTAL(1);
    PL_tmps_stack[++PL_tmps_ix] = sv;
a3663 8
/*
=for apidoc sv_newmortal

Creates a new SV which is mortal.  The reference count of the SV is set to 1.

=cut
*/

d3665 1
a3665 1
Perl_sv_newmortal(pTHX)
d3671 2
d3674 3
a3676 2
    EXTEND_MORTAL(1);
    PL_tmps_stack[++PL_tmps_ix] = sv;
a3679 9
/*
=for apidoc sv_2mortal

Marks an SV as mortal.  The SV will be destroyed when the current context
ends.

=cut
*/

d3683 1
a3683 1
Perl_sv_2mortal(pTHX_ register SV *sv)
d3690 3
a3692 2
    EXTEND_MORTAL(1);
    PL_tmps_stack[++PL_tmps_ix] = sv;
a3696 10
/*
=for apidoc newSVpv

Creates a new SV and copies a string into it.  The reference count for the
SV is set to 1.  If C<len> is zero, Perl will compute the length using
strlen().  For efficiency, consider using C<newSVpvn> instead.

=cut
*/

d3698 1
a3698 1
Perl_newSVpv(pTHX_ const char *s, STRLEN len)
d3703 3
a3711 11
/*
=for apidoc newSVpvn

Creates a new SV and copies a string into it.  The reference count for the
SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length 
string.  You are responsible for ensuring that the source string is at least
C<len> bytes long.

=cut
*/

d3713 1
a3713 1
Perl_newSVpvn(pTHX_ const char *s, STRLEN len)
d3718 3
a3724 1
#if defined(PERL_IMPLICIT_CONTEXT)
d3726 1
a3726 1
Perl_newSVpvf_nocontext(const char* pat, ...)
a3727 1
    dTHX;
a3729 6
    va_start(args, pat);
    sv = vnewSVpvf(pat, &args);
    va_end(args);
    return sv;
}
#endif
d3731 4
a3734 14
/*
=for apidoc newSVpvf

Creates a new SV an initialize it with the string formatted like
C<sprintf>.

=cut
*/

SV *
Perl_newSVpvf(pTHX_ const char* pat, ...)
{
    register SV *sv;
    va_list args;
d3736 1
a3736 1
    sv = vnewSVpvf(pat, &args);
a3740 17
SV *
Perl_vnewSVpvf(pTHX_ const char* pat, va_list* args)
{
    register SV *sv;
    new_SV(sv);
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
    return sv;
}

/*
=for apidoc newSVnv

Creates a new SV and copies a floating point value into it.
The reference count for the SV is set to 1.

=cut
*/
d3743 1
a3743 1
Perl_newSVnv(pTHX_ NV n)
d3748 3
a3754 9
/*
=for apidoc newSViv

Creates a new SV and copies an integer into it.  The reference count for the
SV is set to 1.

=cut
*/

d3756 1
a3756 1
Perl_newSViv(pTHX_ IV i)
d3761 3
a3767 28
/*
=for apidoc newSVuv

Creates a new SV and copies an unsigned integer into it.
The reference count for the SV is set to 1.

=cut
*/

SV *
Perl_newSVuv(pTHX_ UV u)
{
    register SV *sv;

    new_SV(sv);
    sv_setuv(sv,u);
    return sv;
}

/*
=for apidoc newRV_noinc

Creates an RV wrapper for an SV.  The reference count for the original
SV is B<not> incremented.

=cut
*/

d3769 1
a3769 1
Perl_newRV_noinc(pTHX_ SV *tmpRef)
d3775 3
a3784 1
/* newRV_inc is #defined to newRV in sv.h */
d3786 1
a3786 1
Perl_newRV(pTHX_ SV *tmpRef)
a3790 8
/*
=for apidoc newSVsv

Creates a new SV which is an exact duplicate of the original SV.

=cut
*/

d3794 1
a3794 1
Perl_newSVsv(pTHX_ register SV *old)
a3795 1
    dTHR;
d3801 1
a3801 2
        if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL, "semi-panic: attempt to dup freed string");
d3805 3
d3819 1
a3819 1
Perl_sv_reset(pTHX_ register char *s, HV *stash)
d3827 1
a3827 1
    char todo[PERL_UCHAR_MAX+1];
d3846 1
a3846 1
	i = (unsigned char)*s;
d3850 1
a3850 1
	max = (unsigned char)*s++;
d3856 2
a3857 2
		 entry;
		 entry = HeNEXT(entry))
d3865 1
a3865 1
			sv_unref(sv);
d3891 1
a3891 1
Perl_sv_2io(pTHX_ SV *sv)
d3905 1
a3905 1
	    Perl_croak(aTHX_ "Bad filehandle: %s", GvNAME(gv));
d3909 1
a3909 1
	    Perl_croak(aTHX_ PL_no_usym, "filehandle");
d3918 1
a3918 1
	    Perl_croak(aTHX_ "Bad filehandle: %s", SvPV(sv,n_a));
d3925 1
a3925 1
Perl_sv_2cv(pTHX_ SV *sv, HV **st, GV **gvp, I32 lref)
a3951 4
	    dTHR;
	    SV **sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
	    tryAMAGICunDEREF(to_cv);

d3962 1
a3962 1
		Perl_croak(aTHX_ "Not a subroutine reference");
a3977 3
	    /* XXX this is probably not what they think they're getting.
	     * It has the same effect as "sub name;", i.e. just a forward
	     * declaration! */
d3984 1
a3984 1
		Perl_croak(aTHX_ "Unable to create sub named \"%s\"", SvPV(sv,n_a));
d3991 1
a3991 1
Perl_sv_true(pTHX_ register SV *sv)
d3999 2
a4000 1
		(tXpv->xpv_cur > 1 ||
d4019 1
a4019 1
Perl_sv_iv(pTHX_ register SV *sv)
d4021 1
a4021 3
    if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    return (IV)SvUVX(sv);
a4022 1
    }
d4027 1
a4027 1
Perl_sv_uv(pTHX_ register SV *sv)
d4029 2
a4030 5
    if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    return SvUVX(sv);
	return (UV)SvIVX(sv);
    }
d4034 2
a4035 2
NV
Perl_sv_nv(pTHX_ register SV *sv)
d4043 1
a4043 12
Perl_sv_pv(pTHX_ SV *sv)
{
    STRLEN n_a;

    if (SvPOK(sv))
	return SvPVX(sv);

    return sv_2pv(sv, &n_a);
}

char *
Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp)
d4053 1
a4053 1
Perl_sv_pvn_force(pTHX_ SV *sv, STRLEN *lp)
d4057 5
a4061 2
    if (SvTHINKFIRST(sv) && !SvROK(sv))
	sv_force_normal(sv);
d4068 10
a4077 3
	    dTHR;
	    Perl_croak(aTHX_ "Can't coerce %s to string in %s", sv_reftype(sv,0),
		PL_op_name[PL_op->op_type]);
d4095 2
a4096 2
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2pv(%s)\n",
				  PTR2UV(sv),SvPVX(sv)));
d4103 1
a4103 40
Perl_sv_pvbyte(pTHX_ SV *sv)
{
    return sv_pv(sv);
}

char *
Perl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp)
{
    return sv_pvn(sv,lp);
}

char *
Perl_sv_pvbyten_force(pTHX_ SV *sv, STRLEN *lp)
{
    return sv_pvn_force(sv,lp);
}

char *
Perl_sv_pvutf8(pTHX_ SV *sv)
{
    sv_utf8_upgrade(sv);
    return sv_pv(sv);
}

char *
Perl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp)
{
    sv_utf8_upgrade(sv);
    return sv_pvn(sv,lp);
}

char *
Perl_sv_pvutf8n_force(pTHX_ SV *sv, STRLEN *lp)
{
    sv_utf8_upgrade(sv);
    return sv_pvn_force(sv,lp);
}

char *
Perl_sv_reftype(pTHX_ SV *sv, int ob)
a4127 1
	case SVt_PVIO:		return "IO";
a4132 10
/*
=for apidoc sv_isobject

Returns a boolean indicating whether the SV is an RV pointing to a blessed
object.  If the SV is not an RV, or if the object is not blessed, then this
will return false.

=cut
*/

d4134 1
a4134 1
Perl_sv_isobject(pTHX_ SV *sv)
a4147 10
/*
=for apidoc sv_isa

Returns a boolean indicating whether the SV is blessed into the specified
class.  This does not check for subtypes; use C<sv_derived_from> to verify
an inheritance relationship.

=cut
*/

d4149 1
a4149 1
Perl_sv_isa(pTHX_ SV *sv, const char *name)
a4163 11
/*
=for apidoc newSVrv

Creates a new SV for the RV, C<rv>, to point to.  If C<rv> is not an RV then
it will be upgraded to one.  If C<classname> is non-null then the new SV will
be blessed in the specified package.  The new SV is returned and its
reference count is 1.

=cut
*/

d4165 1
a4165 1
Perl_newSVrv(pTHX_ SV *rv, const char *classname)
d4171 3
d4176 1
d4178 1
d4184 1
a4184 1
    SvRV(rv) = sv;
a4193 18
/*
=for apidoc sv_setref_pv

Copies a pointer into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  If the C<pv> argument is NULL then C<PL_sv_undef> will be placed
into the SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
will be returned and will have a reference count of 1.

Do not use with other Perl types such as HV, AV, SV, CV, because those
objects will become corrupted by the pointer copy process.

Note that C<sv_setref_pvn> copies the string while this copies the pointer.

=cut
*/

d4195 1
a4195 1
Perl_sv_setref_pv(pTHX_ SV *rv, const char *classname, void *pv)
d4202 1
a4202 1
	sv_setiv(newSVrv(rv,classname), PTR2IV(pv));
a4205 12
/*
=for apidoc sv_setref_iv

Copies an integer into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
will be returned and will have a reference count of 1.

=cut
*/

d4207 1
a4207 1
Perl_sv_setref_iv(pTHX_ SV *rv, const char *classname, IV iv)
a4212 12
/*
=for apidoc sv_setref_nv

Copies a double into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
will be returned and will have a reference count of 1.

=cut
*/

d4214 1
a4214 1
Perl_sv_setref_nv(pTHX_ SV *rv, const char *classname, NV nv)
a4219 15
/*
=for apidoc sv_setref_pvn

Copies a string into a new SV, optionally blessing the SV.  The length of the
string must be specified with C<n>.  The C<rv> argument will be upgraded to
an RV.  That RV will be modified to point to the new SV.  The C<classname>
argument indicates the package for the blessing.  Set C<classname> to
C<Nullch> to avoid the blessing.  The new SV will be returned and will have
a reference count of 1.

Note that C<sv_setref_pv> copies the pointer while this copies the string.

=cut
*/

d4221 1
a4221 1
Perl_sv_setref_pvn(pTHX_ SV *rv, const char *classname, char *pv, STRLEN n)
a4226 10
/*
=for apidoc sv_bless

Blesses an SV into a specified package.  The SV must be an RV.  The package
must be designated by its stash (see C<gv_stashpv()>).  The reference count
of the SV is unaffected.

=cut
*/

d4228 1
a4228 1
Perl_sv_bless(pTHX_ SV *sv, HV *stash)
d4233 1
a4233 1
        Perl_croak(aTHX_ "Can't bless non-reference value");
d4237 1
a4237 1
	    Perl_croak(aTHX_ PL_no_modify);
d4250 1
d4255 1
d4261 1
a4261 1
S_sv_unglob(pTHX_ SV *sv)
a4262 2
    void *xpvmg;

a4273 7

    /* need to keep SvANY(sv) in the right arena */
    xpvmg = new_XPVMG();
    StructCopy(SvANY(sv), xpvmg, XPVMG);
    del_XPVGV(SvANY(sv));
    SvANY(sv) = xpvmg;

a4277 10
/*
=for apidoc sv_unref

Unsets the RV status of the SV, and decrements the reference count of
whatever was being referenced by the RV.  This can almost be thought of
as a reversal of C<newSVrv>.  See C<SvROK_off>.

=cut
*/

d4279 1
a4279 1
Perl_sv_unref(pTHX_ SV *sv)
d4282 1
a4282 7

    if (SvWEAKREF(sv)) {
    	sv_del_backref(sv);
	SvWEAKREF_off(sv);
	SvRV(sv) = 0;
	return;
    }
d4292 1
a4292 1
Perl_sv_taint(pTHX_ SV *sv)
d4298 1
a4298 1
Perl_sv_untaint(pTHX_ SV *sv)
d4308 1
a4308 1
Perl_sv_tainted(pTHX_ SV *sv)
d4312 1
a4312 1
	if (mg && ((mg->mg_len & 1) || ((mg->mg_len & 2) && mg->mg_obj == sv)))
a4317 9
/*
=for apidoc sv_setpviv

Copies an integer into the given SV, also updating its string value.
Does not handle 'set' magic.  See C<sv_setpviv_mg>.

=cut
*/

d4319 1
a4319 1
Perl_sv_setpviv(pTHX_ SV *sv, IV iv)
d4321 6
a4326 3
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);
d4328 21
a4348 1
    sv_setpvn(sv, ptr, ebuf - ptr);
a4351 8
/*
=for apidoc sv_setpviv_mg

Like C<sv_setpviv>, but also handles 'set' magic.

=cut
*/

d4353 1
a4353 1
Perl_sv_setpviv_mg(pTHX_ SV *sv, IV iv)
d4355 1
a4355 5
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    sv_setpvn(sv, ptr, ebuf - ptr);
a4358 32
#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_sv_setpvf_nocontext(SV *sv, const char* pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    sv_vsetpvf(sv, pat, &args);
    va_end(args);
}


void
Perl_sv_setpvf_mg_nocontext(SV *sv, const char* pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    sv_vsetpvf_mg(sv, pat, &args);
    va_end(args);
}
#endif

/*
=for apidoc sv_setpvf

Processes its arguments like C<sprintf> and sets an SV to the formatted
output.  Does not handle 'set' magic.  See C<sv_setpvf_mg>.

=cut
*/

d4360 1
a4360 1
Perl_sv_setpvf(pTHX_ SV *sv, const char* pat, ...)
d4364 1
a4364 1
    sv_vsetpvf(sv, pat, &args);
a4367 13
void
Perl_sv_vsetpvf(pTHX_ SV *sv, const char* pat, va_list* args)
{
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
}

/*
=for apidoc sv_setpvf_mg

Like C<sv_setpvf>, but also handles 'set' magic.

=cut
*/
d4370 1
a4370 1
Perl_sv_setpvf_mg(pTHX_ SV *sv, const char* pat, ...)
d4374 1
a4374 1
    sv_vsetpvf_mg(sv, pat, &args);
a4375 6
}

void
Perl_sv_vsetpvf_mg(pTHX_ SV *sv, const char* pat, va_list* args)
{
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
a4378 32
#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_sv_catpvf_nocontext(SV *sv, const char* pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    sv_vcatpvf(sv, pat, &args);
    va_end(args);
}

void
Perl_sv_catpvf_mg_nocontext(SV *sv, const char* pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    sv_vcatpvf_mg(sv, pat, &args);
    va_end(args);
}
#endif

/*
=for apidoc sv_catpvf

Processes its arguments like C<sprintf> and appends the formatted output
to an SV.  Handles 'get' magic, but not 'set' magic.  C<SvSETMAGIC()> must
typically be called after calling this function to handle 'set' magic.

=cut
*/

d4380 1
a4380 1
Perl_sv_catpvf(pTHX_ SV *sv, const char* pat, ...)
d4384 1
a4384 1
    sv_vcatpvf(sv, pat, &args);
d4389 1
a4389 15
Perl_sv_vcatpvf(pTHX_ SV *sv, const char* pat, va_list* args)
{
    sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
}

/*
=for apidoc sv_catpvf_mg

Like C<sv_catpvf>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catpvf_mg(pTHX_ SV *sv, const char* pat, ...)
d4393 1
a4393 1
    sv_vcatpvf_mg(sv, pat, &args);
a4394 6
}

void
Perl_sv_vcatpvf_mg(pTHX_ SV *sv, const char* pat, va_list* args)
{
    sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
a4397 9
/*
=for apidoc sv_vsetpvfn

Works like C<vcatpvfn> but copies the text into the SV instead of
appending it.

=cut
*/

d4399 1
a4399 1
Perl_sv_vsetpvfn(pTHX_ SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *maybe_tainted)
d4402 1
a4402 1
    sv_vcatpvfn(sv, pat, patlen, args, svargs, svmax, maybe_tainted);
a4404 12
/*
=for apidoc sv_vcatpvfn

Processes its arguments like C<vsprintf> and appends the formatted output
to an SV.  Uses an array of SVs if the C style variable argument list is
missing (NULL).  When running with taint checks enabled, indicates via
C<maybe_tainted> if results are untrustworthy (often due to the use of
locales).

=cut
*/

d4406 1
a4406 1
Perl_sv_vcatpvfn(pTHX_ SV *sv, const char *pat, STRLEN patlen, va_list *args, SV **svargs, I32 svmax, bool *maybe_tainted)
a4414 1
    SV *argsv;
d4429 1
a4429 1
	    else if (svix < svmax) {
a4430 3
		if (DO_UTF8(*svargs))
		    SvUTF8_on(sv);
	    }
d4434 1
a4434 4
		argsv = va_arg(*args, SV*);
		sv_catsv(sv, argsv);
		if (DO_UTF8(argsv))
		    SvUTF8_on(sv);
a4445 2
	bool vectorize = FALSE;
	bool utf = FALSE;
a4452 1
	bool is_utf = FALSE;
a4454 1
	U8 utf8buf[UTF8_MAXLEN];
d4459 7
a4465 10
	/* Times 4: a decimal digit takes more than 3 binary digits.
	 * NV_DIG: mantissa takes than many decimal digits.
	 * Plus 32: Playing safe. */
	char ebuf[IV_DIG * 4 + NV_DIG + 32];
        /* large enough for "%#.#f" --chip */
	/* what about long double NVs? --jhi */

	SV *vecsv;
	U8 *vecstr = Null(U8*);
	STRLEN veclen = 0;
d4471 1
a4471 1
	NV nv;
a4474 2
	char *dotstr = ".";
	STRLEN dotstrlen = 1;
a4506 31
	    case '*':			/* printf("%*vX",":",$ipv6addr) */
		if (q[1] != 'v')
		    break;
		q++;
		if (args)
		    vecsv = va_arg(*args, SV*);
		else if (svix < svmax)
		    vecsv = svargs[svix++];
		else
		    continue;
		dotstr = SvPVx(vecsv,dotstrlen);
		if (DO_UTF8(vecsv))
		    is_utf = TRUE;
		/* FALL THROUGH */

	    case 'v':
		vectorize = TRUE;
		q++;
		if (args)
		    vecsv = va_arg(*args, SV*);
		else if (svix < svmax)
		    vecsv = svargs[svix++];
		else {
		    vecstr = (U8*)"";
		    veclen = 0;
		    continue;
		}
		vecstr = (U8*)SvPVx(vecsv,veclen);
		utf = DO_UTF8(vecsv);
		continue;

a4557 7
#ifdef HAS_QUAD
	case 'L':			/* Ld */
	case 'q':			/* qd */
	    intsize = 'q';
	    q++;
	    break;
#endif
d4559 2
a4560 2
#ifdef HAS_QUAD
             if (*(q + 1) == 'l') {	/* lld */
d4564 1
a4564 1
	     }
a4567 1
	    /* FALL THROUGH */
d4586 1
a4586 1
		uv = va_arg(*args, int);
d4588 3
a4590 11
		uv = (svix < svmax) ? SvIVx(svargs[svix++]) : 0;
	    if ((uv > 255 || (uv > 127 && SvUTF8(sv))) && !IN_BYTE) {
		eptr = (char*)utf8buf;
		elen = uv_to_utf8((U8*)eptr, uv) - utf8buf;
		is_utf = TRUE;
	    }
	    else {
		c = (char)uv;
		eptr = &c;
		elen = 1;
	    }
a4596 6
#ifdef MACOS_TRADITIONAL
		  /* On MacOS, %#s format is used for Pascal strings */
		  if (alt)
		    elen = *eptr++;
		  else
#endif
d4603 2
a4604 15
	    else if (svix < svmax) {
		argsv = svargs[svix++];
		eptr = SvPVx(argsv, elen);
		if (DO_UTF8(argsv)) {
		    if (has_precis && precis < elen) {
			I32 p = precis;
			sv_pos_u2b(argsv, &p, 0); /* sticks at end */
			precis = p;
		    }
		    if (width) { /* fudge width (can't fudge elen) */
			width += elen - sv_len_utf8(argsv);
		    }
		    is_utf = TRUE;
		}
	    }
d4615 1
a4615 4
	    argsv = va_arg(*args,SV*);
	    eptr = SvPVx(argsv, elen);
	    if (DO_UTF8(argsv))
		is_utf = TRUE;
a4617 1
	    vectorize = FALSE;
d4626 1
a4626 1
		uv = PTR2UV(va_arg(*args, void*));
d4628 1
a4628 1
		uv = (svix < svmax) ? PTR2UV(svargs[svix++]) : 0;
a4632 3
#ifdef IV_IS_QUAD
	    intsize = 'q';
#else
a4633 1
#endif
d4637 1
a4637 16
	    if (vectorize) {
		I32 ulen;
		if (!veclen) {
		    vectorize = FALSE;
		    break;
		}
		if (utf)
		    iv = (IV)utf8_to_uv(vecstr, &ulen);
		else {
		    iv = *vecstr;
		    ulen = 1;
		}
		vecstr += ulen;
		veclen -= ulen;
	    }
	    else if (args) {
a4642 3
#ifdef HAS_QUAD
		case 'q':	iv = va_arg(*args, Quad_t); break;
#endif
a4651 3
#ifdef HAS_QUAD
		case 'q':	iv = (Quad_t)iv; break;
#endif
a4666 3
#ifdef IV_IS_QUAD
	    intsize = 'q';
#else
a4667 1
#endif
a4672 4
	case 'b':
	    base = 2;
	    goto uns_integer;

a4673 3
#ifdef IV_IS_QUAD
	    intsize = 'q';
#else
a4674 1
#endif
d4685 1
a4685 17
	    if (vectorize) {
		I32 ulen;
	vector:
		if (!veclen) {
		    vectorize = FALSE;
		    break;
		}
		if (utf)
		    uv = utf8_to_uv(vecstr, &ulen);
		else {
		    uv = *vecstr;
		    ulen = 1;
		}
		vecstr += ulen;
		veclen -= ulen;
	    }
	    else if (args) {
a4690 3
#ifdef HAS_QUAD
		case 'q':  uv = va_arg(*args, Quad_t); break;
#endif
a4699 3
#ifdef HAS_QUAD
		case 'q':	uv = (Quad_t)uv; break;
#endif
d4710 1
a4710 2
		p = (char*)((c == 'X')
			    ? "0123456789ABCDEF" : "0123456789abcdef");
a4727 10
	    case 2:
		do {
		    dig = uv & 1;
		    *--eptr = '0' + dig;
		} while (uv >>= 1);
		if (alt) {
		    esignbuf[esignlen++] = '0';
		    esignbuf[esignlen++] = 'b';
		}
		break;
a4728 13
#if defined(PERL_Y2KWARN)
		if (ckWARN(WARN_Y2K)) {
		    STRLEN n;
		    char *s = SvPV(sv,n);
		    if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
			&& (n == 2 || !isDIGIT(s[n-3])))
		    {
			Perl_warner(aTHX_ WARN_Y2K,
				    "Possible Y2K bug: %%%c %s",
				    c, "format string following '19'");
		    }
		}
#endif
a4754 1
	    vectorize = FALSE;
d4756 1
a4756 1
		nv = va_arg(*args, NV);
d4763 1
a4763 1
		(void)Perl_frexp(nv, &i);
d4765 1
a4765 1
		    Perl_die(aTHX_ "panic: frexp");
d4774 4
a4777 5
	    if (PL_efloatsize < need) {
		Safefree(PL_efloatbuf);
		PL_efloatsize = need + 20; /* more fudge */
		New(906, PL_efloatbuf, PL_efloatsize, char);
		PL_efloatbuf[0] = '\0';
a4782 7
#ifdef USE_LONG_DOUBLE
	    {
		static char const my_prifldbl[] = PERL_PRIfldbl;
		char const *p = my_prifldbl + sizeof my_prifldbl - 3;
		while (p >= my_prifldbl) { *--eptr = *p--; }
	    }
#endif
d4802 14
a4815 5
	    {
		RESTORE_NUMERIC_STANDARD();
		(void)sprintf(PL_efloatbuf, eptr, nv);
		RESTORE_NUMERIC_LOCAL();
	    }
a4816 2
	    eptr = PL_efloatbuf;
	    elen = strlen(PL_efloatbuf);
a4821 1
	    vectorize = FALSE;
a4828 3
#ifdef HAS_QUAD
		case 'q':	*(va_arg(*args, Quad_t*)) = i; break;
#endif
d4839 1
a4839 2
	    vectorize = FALSE;
	    if (!args && ckWARN(WARN_PRINTF) &&
d4842 1
a4842 1
		Perl_sv_setpvf(aTHX_ msg, "Invalid conversion in %s: ",
d4844 4
a4847 9
		if (c) {
		    if (isPRINT(c))
			Perl_sv_catpvf(aTHX_ msg, 
				       "\"%%%c\"", c & 0xFF);
		    else
			Perl_sv_catpvf(aTHX_ msg,
				       "\"%%\\%03"UVof"\"",
				       (UV)c & 0xFF);
		} else
d4849 1
a4849 1
		Perl_warner(aTHX_ WARN_PRINTF, "%"SVf, msg); /* yes, this is reentrant */
d4872 1
a4872 1
	SvGROW(sv, SvCUR(sv) + need + dotstrlen + 1);
a4897 10
	if (vectorize) {
	    if (veclen) {
		memcpy(p, dotstr, dotstrlen);
		p += dotstrlen;
	    }
	    else
		vectorize = FALSE;		/* done iterating over vecstr */
	}
	if (is_utf)
	    SvUTF8_on(sv);
a4899 4
	if (vectorize) {
	    esignlen = 0;
	    goto vector;
	}
d4903 2
a4904 145
#if defined(USE_ITHREADS)

#if defined(USE_THREADS)
#  include "error: USE_THREADS and USE_ITHREADS are incompatible"
#endif

#ifndef GpREFCNT_inc
#  define GpREFCNT_inc(gp)	((gp) ? (++(gp)->gp_refcnt, (gp)) : (GP*)NULL)
#endif


#define sv_dup_inc(s)	SvREFCNT_inc(sv_dup(s))
#define av_dup(s)	(AV*)sv_dup((SV*)s)
#define av_dup_inc(s)	(AV*)SvREFCNT_inc(sv_dup((SV*)s))
#define hv_dup(s)	(HV*)sv_dup((SV*)s)
#define hv_dup_inc(s)	(HV*)SvREFCNT_inc(sv_dup((SV*)s))
#define cv_dup(s)	(CV*)sv_dup((SV*)s)
#define cv_dup_inc(s)	(CV*)SvREFCNT_inc(sv_dup((SV*)s))
#define io_dup(s)	(IO*)sv_dup((SV*)s)
#define io_dup_inc(s)	(IO*)SvREFCNT_inc(sv_dup((SV*)s))
#define gv_dup(s)	(GV*)sv_dup((SV*)s)
#define gv_dup_inc(s)	(GV*)SvREFCNT_inc(sv_dup((SV*)s))
#define SAVEPV(p)	(p ? savepv(p) : Nullch)
#define SAVEPVN(p,n)	(p ? savepvn(p,n) : Nullch)

REGEXP *
Perl_re_dup(pTHX_ REGEXP *r)
{
    /* XXX fix when pmop->op_pmregexp becomes shared */
    return ReREFCNT_inc(r);
}

PerlIO *
Perl_fp_dup(pTHX_ PerlIO *fp, char type)
{
    PerlIO *ret;
    if (!fp)
	return (PerlIO*)NULL;

    /* look for it in the table first */
    ret = (PerlIO*)ptr_table_fetch(PL_ptr_table, fp);
    if (ret)
	return ret;

    /* create anew and remember what it is */
    ret = PerlIO_fdupopen(fp);
    ptr_table_store(PL_ptr_table, fp, ret);
    return ret;
}

DIR *
Perl_dirp_dup(pTHX_ DIR *dp)
{
    if (!dp)
	return (DIR*)NULL;
    /* XXX TODO */
    return dp;
}

GP *
Perl_gp_dup(pTHX_ GP *gp)
{
    GP *ret;
    if (!gp)
	return (GP*)NULL;
    /* look for it in the table first */
    ret = (GP*)ptr_table_fetch(PL_ptr_table, gp);
    if (ret)
	return ret;

    /* create anew and remember what it is */
    Newz(0, ret, 1, GP);
    ptr_table_store(PL_ptr_table, gp, ret);

    /* clone */
    ret->gp_refcnt	= 0;			/* must be before any other dups! */
    ret->gp_sv		= sv_dup_inc(gp->gp_sv);
    ret->gp_io		= io_dup_inc(gp->gp_io);
    ret->gp_form	= cv_dup_inc(gp->gp_form);
    ret->gp_av		= av_dup_inc(gp->gp_av);
    ret->gp_hv		= hv_dup_inc(gp->gp_hv);
    ret->gp_egv		= gv_dup(gp->gp_egv);	/* GvEGV is not refcounted */
    ret->gp_cv		= cv_dup_inc(gp->gp_cv);
    ret->gp_cvgen	= gp->gp_cvgen;
    ret->gp_flags	= gp->gp_flags;
    ret->gp_line	= gp->gp_line;
    ret->gp_file	= gp->gp_file;		/* points to COP.cop_file */
    return ret;
}

MAGIC *
Perl_mg_dup(pTHX_ MAGIC *mg)
{
    MAGIC *mgret = (MAGIC*)NULL;
    MAGIC *mgprev;
    if (!mg)
	return (MAGIC*)NULL;
    /* look for it in the table first */
    mgret = (MAGIC*)ptr_table_fetch(PL_ptr_table, mg);
    if (mgret)
	return mgret;

    for (; mg; mg = mg->mg_moremagic) {
	MAGIC *nmg;
	Newz(0, nmg, 1, MAGIC);
	if (!mgret)
	    mgret = nmg;
	else
	    mgprev->mg_moremagic = nmg;
	nmg->mg_virtual	= mg->mg_virtual;	/* XXX copy dynamic vtable? */
	nmg->mg_private	= mg->mg_private;
	nmg->mg_type	= mg->mg_type;
	nmg->mg_flags	= mg->mg_flags;
	if (mg->mg_type == 'r') {
	    nmg->mg_obj	= (SV*)re_dup((REGEXP*)mg->mg_obj);
	}
	else {
	    nmg->mg_obj	= (mg->mg_flags & MGf_REFCOUNTED)
			      ? sv_dup_inc(mg->mg_obj)
			      : sv_dup(mg->mg_obj);
	}
	nmg->mg_len	= mg->mg_len;
	nmg->mg_ptr	= mg->mg_ptr;	/* XXX random ptr? */
	if (mg->mg_ptr && mg->mg_type != 'g') {
	    if (mg->mg_len >= 0) {
		nmg->mg_ptr	= SAVEPVN(mg->mg_ptr, mg->mg_len);
		if (mg->mg_type == 'c' && AMT_AMAGIC((AMT*)mg->mg_ptr)) {
		    AMT *amtp = (AMT*)mg->mg_ptr;
		    AMT *namtp = (AMT*)nmg->mg_ptr;
		    I32 i;
		    for (i = 1; i < NofAMmeth; i++) {
			namtp->table[i] = cv_dup_inc(amtp->table[i]);
		    }
		}
	    }
	    else if (mg->mg_len == HEf_SVKEY)
		nmg->mg_ptr	= (char*)sv_dup_inc((SV*)mg->mg_ptr);
	}
	mgprev = nmg;
    }
    return mgret;
}

PTR_TBL_t *
Perl_ptr_table_new(pTHX)
d4906 5
a4910 7
    PTR_TBL_t *tbl;
    Newz(0, tbl, 1, PTR_TBL_t);
    tbl->tbl_max	= 511;
    tbl->tbl_items	= 0;
    Newz(0, tbl->tbl_ary, tbl->tbl_max + 1, PTR_TBL_ENT_t*);
    return tbl;
}
d4912 3
a4914 10
void *
Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *tbl, void *sv)
{
    PTR_TBL_ENT_t *tblent;
    UV hash = PTR2UV(sv);
    assert(tbl);
    tblent = tbl->tbl_ary[hash & tbl->tbl_max];
    for (; tblent; tblent = tblent->next) {
	if (tblent->oldval == sv)
	    return tblent->newval;
d4916 3
a4918 12
    return (void*)NULL;
}

void
Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, void *oldv, void *newv)
{
    PTR_TBL_ENT_t *tblent, **otblent;
    /* XXX this may be pessimal on platforms where pointers aren't good
     * hash values e.g. if they grow faster in the most significant
     * bits */
    UV hash = PTR2UV(oldv);
    bool i = 1;
d4920 26
a4945 18
    assert(tbl);
    otblent = &tbl->tbl_ary[hash & tbl->tbl_max];
    for (tblent = *otblent; tblent; i=0, tblent = tblent->next) {
	if (tblent->oldval == oldv) {
	    tblent->newval = newv;
	    tbl->tbl_items++;
	    return;
	}
    }
    Newz(0, tblent, 1, PTR_TBL_ENT_t);
    tblent->oldval = oldv;
    tblent->newval = newv;
    tblent->next = *otblent;
    *otblent = tblent;
    tbl->tbl_items++;
    if (i && tbl->tbl_items > tbl->tbl_max)
	ptr_table_split(tbl);
}
d4947 28
a4974 23
void
Perl_ptr_table_split(pTHX_ PTR_TBL_t *tbl)
{
    PTR_TBL_ENT_t **ary = tbl->tbl_ary;
    UV oldsize = tbl->tbl_max + 1;
    UV newsize = oldsize * 2;
    UV i;

    Renew(ary, newsize, PTR_TBL_ENT_t*);
    Zero(&ary[oldsize], newsize-oldsize, PTR_TBL_ENT_t*);
    tbl->tbl_max = --newsize;
    tbl->tbl_ary = ary;
    for (i=0; i < oldsize; i++, ary++) {
	PTR_TBL_ENT_t **curentp, **entp, *ent;
	if (!*ary)
	    continue;
	curentp = ary + oldsize;
	for (entp = ary, ent = *ary; ent; ent = *entp) {
	    if ((newsize & PTR2UV(ent->oldval)) != i) {
		*entp = ent->next;
		ent->next = *curentp;
		*curentp = ent;
		continue;
a4975 2
	    else
		entp = &ent->next;
d4977 4
a4981 10
}

#ifdef DEBUGGING
char *PL_watch_pvx;
#endif

SV *
Perl_sv_dup(pTHX_ SV *sstr)
{
    SV *dstr;
d4983 4
a4986 21
    if (!sstr || SvTYPE(sstr) == SVTYPEMASK)
	return Nullsv;
    /* look for it in the table first */
    dstr = (SV*)ptr_table_fetch(PL_ptr_table, sstr);
    if (dstr)
	return dstr;

    /* create anew and remember what it is */
    new_SV(dstr);
    ptr_table_store(PL_ptr_table, sstr, dstr);

    /* clone */
    SvFLAGS(dstr)	= SvFLAGS(sstr);
    SvFLAGS(dstr)	&= ~SVf_OOK;		/* don't propagate OOK hack */
    SvREFCNT(dstr)	= 0;			/* must be before any other dups! */

#ifdef DEBUGGING
    if (SvANY(sstr) && PL_watch_pvx && SvPVX(sstr) == PL_watch_pvx)
	PerlIO_printf(Perl_debug_log, "watch at %p hit, found string \"%s\"\n",
		      PL_watch_pvx, SvPVX(sstr));
#endif
d4988 2
a4989 1
    switch (SvTYPE(sstr)) {
d4991 2
a4992 2
	SvANY(dstr)	= NULL;
	break;
d4994 1
a4994 2
	SvANY(dstr)	= new_XIV();
	SvIVX(dstr)	= SvIVX(sstr);
d4997 1
a4997 2
	SvANY(dstr)	= new_XNV();
	SvNVX(dstr)	= SvNVX(sstr);
d5000 1
a5000 2
	SvANY(dstr)	= new_XRV();
	SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
d5003 1
a5003 9
	SvANY(dstr)	= new_XPV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d5006 1
a5006 10
	SvANY(dstr)	= new_XPVIV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d5009 4
a5012 11
	SvANY(dstr)	= new_XPVNV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
d5015 1
a5015 31
	SvANY(dstr)	= new_XPVMG();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	break;
    case SVt_PVBM:
	SvANY(dstr)	= new_XPVBM();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	BmRARE(dstr)	= BmRARE(sstr);
	BmUSEFUL(dstr)	= BmUSEFUL(sstr);
	BmPREVIOUS(dstr)= BmPREVIOUS(sstr);
d5018 1
a5018 17
	SvANY(dstr)	= new_XPVLV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	LvTARGOFF(dstr)	= LvTARGOFF(sstr);	/* XXX sometimes holds PMOP* when DEBUGGING */
	LvTARGLEN(dstr)	= LvTARGLEN(sstr);
	LvTARG(dstr)	= sv_dup_inc(LvTARG(sstr));
	LvTYPE(dstr)	= LvTYPE(sstr);
d5020 2
a5021 20
    case SVt_PVGV:
	SvANY(dstr)	= new_XPVGV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	GvNAMELEN(dstr)	= GvNAMELEN(sstr);
	GvNAME(dstr)	= SAVEPVN(GvNAME(sstr), GvNAMELEN(sstr));
	GvSTASH(dstr)	= hv_dup_inc(GvSTASH(sstr));
	GvFLAGS(dstr)	= GvFLAGS(sstr);
	GvGP(dstr)	= gp_dup(GvGP(sstr));
	(void)GpREFCNT_inc(GvGP(dstr));
d5023 2
a5024 37
    case SVt_PVIO:
	SvANY(dstr)	= new_XPVIO();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvROK(sstr))
	    SvRV(dstr)	= sv_dup_inc(SvRV(sstr));
	else if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	IoIFP(dstr)	= fp_dup(IoIFP(sstr), IoTYPE(sstr));
	if (IoOFP(sstr) == IoIFP(sstr))
	    IoOFP(dstr) = IoIFP(dstr);
	else
	    IoOFP(dstr)	= fp_dup(IoOFP(sstr), IoTYPE(sstr));
	/* PL_rsfp_filters entries have fake IoDIRP() */
	if (IoDIRP(sstr) && !(IoFLAGS(sstr) & IOf_FAKE_DIRP))
	    IoDIRP(dstr)	= dirp_dup(IoDIRP(sstr));
	else
	    IoDIRP(dstr)	= IoDIRP(sstr);
	IoLINES(dstr)		= IoLINES(sstr);
	IoPAGE(dstr)		= IoPAGE(sstr);
	IoPAGE_LEN(dstr)	= IoPAGE_LEN(sstr);
	IoLINES_LEFT(dstr)	= IoLINES_LEFT(sstr);
	IoTOP_NAME(dstr)	= SAVEPV(IoTOP_NAME(sstr));
	IoTOP_GV(dstr)		= gv_dup(IoTOP_GV(sstr));
	IoFMT_NAME(dstr)	= SAVEPV(IoFMT_NAME(sstr));
	IoFMT_GV(dstr)		= gv_dup(IoFMT_GV(sstr));
	IoBOTTOM_NAME(dstr)	= SAVEPV(IoBOTTOM_NAME(sstr));
	IoBOTTOM_GV(dstr)	= gv_dup(IoBOTTOM_GV(sstr));
	IoSUBPROCESS(dstr)	= IoSUBPROCESS(sstr);
	IoTYPE(dstr)		= IoTYPE(sstr);
	IoFLAGS(dstr)		= IoFLAGS(sstr);
d5026 2
a5027 36
    case SVt_PVAV:
	SvANY(dstr)	= new_XPVAV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	AvARYLEN((AV*)dstr) = sv_dup_inc(AvARYLEN((AV*)sstr));
	AvFLAGS((AV*)dstr) = AvFLAGS((AV*)sstr);
	if (AvARRAY((AV*)sstr)) {
	    SV **dst_ary, **src_ary;
	    SSize_t items = AvFILLp((AV*)sstr) + 1;

	    src_ary = AvARRAY((AV*)sstr);
	    Newz(0, dst_ary, AvMAX((AV*)sstr)+1, SV*);
	    ptr_table_store(PL_ptr_table, src_ary, dst_ary);
	    SvPVX(dstr)	= (char*)dst_ary;
	    AvALLOC((AV*)dstr) = dst_ary;
	    if (AvREAL((AV*)sstr)) {
		while (items-- > 0)
		    *dst_ary++ = sv_dup_inc(*src_ary++);
	    }
	    else {
		while (items-- > 0)
		    *dst_ary++ = sv_dup(*src_ary++);
	    }
	    items = AvMAX((AV*)sstr) - AvFILLp((AV*)sstr);
	    while (items-- > 0) {
		*dst_ary++ = &PL_sv_undef;
	    }
	}
	else {
	    SvPVX(dstr)		= Nullch;
	    AvALLOC((AV*)dstr)	= (SV**)NULL;
	}
d5029 2
a5030 28
    case SVt_PVHV:
	SvANY(dstr)	= new_XPVHV();
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	HvRITER((HV*)dstr)	= HvRITER((HV*)sstr);
	if (HvARRAY((HV*)sstr)) {
	    STRLEN i = 0;
	    XPVHV *dxhv = (XPVHV*)SvANY(dstr);
	    XPVHV *sxhv = (XPVHV*)SvANY(sstr);
	    Newz(0, dxhv->xhv_array,
		 PERL_HV_ARRAY_ALLOC_BYTES(dxhv->xhv_max+1), char);
	    while (i <= sxhv->xhv_max) {
		((HE**)dxhv->xhv_array)[i] = he_dup(((HE**)sxhv->xhv_array)[i],
						    !!HvSHAREKEYS(sstr));
		++i;
	    }
	    dxhv->xhv_eiter = he_dup(sxhv->xhv_eiter, !!HvSHAREKEYS(sstr));
	}
	else {
	    SvPVX(dstr)		= Nullch;
	    HvEITER((HV*)dstr)	= (HE*)NULL;
	}
	HvPMROOT((HV*)dstr)	= HvPMROOT((HV*)sstr);		/* XXX */
	HvNAME((HV*)dstr)	= SAVEPV(HvNAME((HV*)sstr));
d5033 4
a5036 35
	SvANY(dstr)	= new_XPVFM();
	FmLINES(dstr)	= FmLINES(sstr);
	goto dup_pvcv;
	/* NOTREACHED */
    case SVt_PVCV:
	SvANY(dstr)	= new_XPVCV();
dup_pvcv:
	SvCUR(dstr)	= SvCUR(sstr);
	SvLEN(dstr)	= SvLEN(sstr);
	SvIVX(dstr)	= SvIVX(sstr);
	SvNVX(dstr)	= SvNVX(sstr);
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr));
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr));
	if (SvPVX(sstr) && SvLEN(sstr))
	    SvPVX(dstr)	= SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	else
	    SvPVX(dstr)	= SvPVX(sstr);		/* XXX shared string/random ptr? */
	CvSTASH(dstr)	= hv_dup(CvSTASH(sstr));/* NOTE: not refcounted */
	CvSTART(dstr)	= CvSTART(sstr);
	CvROOT(dstr)	= OpREFCNT_inc(CvROOT(sstr));
	CvXSUB(dstr)	= CvXSUB(sstr);
	CvXSUBANY(dstr)	= CvXSUBANY(sstr);
	CvGV(dstr)	= gv_dup_inc(CvGV(sstr));
	CvDEPTH(dstr)	= CvDEPTH(sstr);
	if (CvPADLIST(sstr) && !AvREAL(CvPADLIST(sstr))) {
	    /* XXX padlists are real, but pretend to be not */
	    AvREAL_on(CvPADLIST(sstr));
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr));
	    AvREAL_off(CvPADLIST(sstr));
	    AvREAL_off(CvPADLIST(dstr));
	}
	else
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr));
	CvOUTSIDE(dstr)	= cv_dup_inc(CvOUTSIDE(sstr));
	CvFLAGS(dstr)	= CvFLAGS(sstr);
d5039 2
a5040 2
	Perl_croak(aTHX_ "Bizarre SvTYPE [%d]", SvTYPE(sstr));
	break;
d5042 5
a5046 89

    if (SvOBJECT(dstr) && SvTYPE(dstr) != SVt_PVIO)
	++PL_sv_objcount;

    return dstr;
}

PERL_CONTEXT *
Perl_cx_dup(pTHX_ PERL_CONTEXT *cxs, I32 ix, I32 max)
{
    PERL_CONTEXT *ncxs;

    if (!cxs)
	return (PERL_CONTEXT*)NULL;

    /* look for it in the table first */
    ncxs = (PERL_CONTEXT*)ptr_table_fetch(PL_ptr_table, cxs);
    if (ncxs)
	return ncxs;

    /* create anew and remember what it is */
    Newz(56, ncxs, max + 1, PERL_CONTEXT);
    ptr_table_store(PL_ptr_table, cxs, ncxs);

    while (ix >= 0) {
	PERL_CONTEXT *cx = &cxs[ix];
	PERL_CONTEXT *ncx = &ncxs[ix];
	ncx->cx_type	= cx->cx_type;
	if (CxTYPE(cx) == CXt_SUBST) {
	    Perl_croak(aTHX_ "Cloning substitution context is unimplemented");
	}
	else {
	    ncx->blk_oldsp	= cx->blk_oldsp;
	    ncx->blk_oldcop	= cx->blk_oldcop;
	    ncx->blk_oldretsp	= cx->blk_oldretsp;
	    ncx->blk_oldmarksp	= cx->blk_oldmarksp;
	    ncx->blk_oldscopesp	= cx->blk_oldscopesp;
	    ncx->blk_oldpm	= cx->blk_oldpm;
	    ncx->blk_gimme	= cx->blk_gimme;
	    switch (CxTYPE(cx)) {
	    case CXt_SUB:
		ncx->blk_sub.cv		= (cx->blk_sub.olddepth == 0
					   ? cv_dup_inc(cx->blk_sub.cv)
					   : cv_dup(cx->blk_sub.cv));
		ncx->blk_sub.argarray	= (cx->blk_sub.hasargs
					   ? av_dup_inc(cx->blk_sub.argarray)
					   : Nullav);
		ncx->blk_sub.savearray	= av_dup(cx->blk_sub.savearray);
		ncx->blk_sub.olddepth	= cx->blk_sub.olddepth;
		ncx->blk_sub.hasargs	= cx->blk_sub.hasargs;
		ncx->blk_sub.lval	= cx->blk_sub.lval;
		break;
	    case CXt_EVAL:
		ncx->blk_eval.old_in_eval = cx->blk_eval.old_in_eval;
		ncx->blk_eval.old_op_type = cx->blk_eval.old_op_type;
		ncx->blk_eval.old_namesv = sv_dup_inc(cx->blk_eval.old_namesv);
		ncx->blk_eval.old_eval_root = cx->blk_eval.old_eval_root;
		ncx->blk_eval.cur_text	= sv_dup(cx->blk_eval.cur_text);
		break;
	    case CXt_LOOP:
		ncx->blk_loop.label	= cx->blk_loop.label;
		ncx->blk_loop.resetsp	= cx->blk_loop.resetsp;
		ncx->blk_loop.redo_op	= cx->blk_loop.redo_op;
		ncx->blk_loop.next_op	= cx->blk_loop.next_op;
		ncx->blk_loop.last_op	= cx->blk_loop.last_op;
		ncx->blk_loop.iterdata	= (CxPADLOOP(cx)
					   ? cx->blk_loop.iterdata
					   : gv_dup((GV*)cx->blk_loop.iterdata));
		ncx->blk_loop.oldcurpad
		    = (SV**)ptr_table_fetch(PL_ptr_table,
					    cx->blk_loop.oldcurpad);
		ncx->blk_loop.itersave	= sv_dup_inc(cx->blk_loop.itersave);
		ncx->blk_loop.iterlval	= sv_dup_inc(cx->blk_loop.iterlval);
		ncx->blk_loop.iterary	= av_dup_inc(cx->blk_loop.iterary);
		ncx->blk_loop.iterix	= cx->blk_loop.iterix;
		ncx->blk_loop.itermax	= cx->blk_loop.itermax;
		break;
	    case CXt_FORMAT:
		ncx->blk_sub.cv		= cv_dup(cx->blk_sub.cv);
		ncx->blk_sub.gv		= gv_dup(cx->blk_sub.gv);
		ncx->blk_sub.dfoutgv	= gv_dup_inc(cx->blk_sub.dfoutgv);
		ncx->blk_sub.hasargs	= cx->blk_sub.hasargs;
		break;
	    case CXt_BLOCK:
	    case CXt_NULL:
		break;
	    }
	}
	--ix;
d5048 4
a5051 300
    return ncxs;
}

PERL_SI *
Perl_si_dup(pTHX_ PERL_SI *si)
{
    PERL_SI *nsi;

    if (!si)
	return (PERL_SI*)NULL;

    /* look for it in the table first */
    nsi = (PERL_SI*)ptr_table_fetch(PL_ptr_table, si);
    if (nsi)
	return nsi;

    /* create anew and remember what it is */
    Newz(56, nsi, 1, PERL_SI);
    ptr_table_store(PL_ptr_table, si, nsi);

    nsi->si_stack	= av_dup_inc(si->si_stack);
    nsi->si_cxix	= si->si_cxix;
    nsi->si_cxmax	= si->si_cxmax;
    nsi->si_cxstack	= cx_dup(si->si_cxstack, si->si_cxix, si->si_cxmax);
    nsi->si_type	= si->si_type;
    nsi->si_prev	= si_dup(si->si_prev);
    nsi->si_next	= si_dup(si->si_next);
    nsi->si_markoff	= si->si_markoff;

    return nsi;
}

#define POPINT(ss,ix)	((ss)[--(ix)].any_i32)
#define TOPINT(ss,ix)	((ss)[ix].any_i32)
#define POPLONG(ss,ix)	((ss)[--(ix)].any_long)
#define TOPLONG(ss,ix)	((ss)[ix].any_long)
#define POPIV(ss,ix)	((ss)[--(ix)].any_iv)
#define TOPIV(ss,ix)	((ss)[ix].any_iv)
#define POPPTR(ss,ix)	((ss)[--(ix)].any_ptr)
#define TOPPTR(ss,ix)	((ss)[ix].any_ptr)
#define POPDPTR(ss,ix)	((ss)[--(ix)].any_dptr)
#define TOPDPTR(ss,ix)	((ss)[ix].any_dptr)
#define POPDXPTR(ss,ix)	((ss)[--(ix)].any_dxptr)
#define TOPDXPTR(ss,ix)	((ss)[ix].any_dxptr)

/* XXXXX todo */
#define pv_dup_inc(p)	SAVEPV(p)
#define pv_dup(p)	SAVEPV(p)
#define svp_dup_inc(p,pp)	any_dup(p,pp)

void *
Perl_any_dup(pTHX_ void *v, PerlInterpreter *proto_perl)
{
    void *ret;

    if (!v)
	return (void*)NULL;

    /* look for it in the table first */
    ret = ptr_table_fetch(PL_ptr_table, v);
    if (ret)
	return ret;

    /* see if it is part of the interpreter structure */
    if (v >= (void*)proto_perl && v < (void*)(proto_perl+1))
	ret = (void*)(((char*)aTHXo) + (((char*)v) - (char*)proto_perl));
    else
	ret = v;

    return ret;
}

ANY *
Perl_ss_dup(pTHX_ PerlInterpreter *proto_perl)
{
    ANY *ss	= proto_perl->Tsavestack;
    I32 ix	= proto_perl->Tsavestack_ix;
    I32 max	= proto_perl->Tsavestack_max;
    ANY *nss;
    SV *sv;
    GV *gv;
    AV *av;
    HV *hv;
    void* ptr;
    int intval;
    long longval;
    GP *gp;
    IV iv;
    I32 i;
    char *c;
    void (*dptr) (void*);
    void (*dxptr) (pTHXo_ void*);
    OP *o;

    Newz(54, nss, max, ANY);

    while (ix > 0) {
	i = POPINT(ss,ix);
	TOPINT(nss,ix) = i;
	switch (i) {
	case SAVEt_ITEM:			/* normal string */
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    break;
        case SAVEt_SV:				/* scalar reference */
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup_inc(gv);
	    break;
        case SAVEt_GENERIC_SVREF:		/* generic sv */
        case SAVEt_SVREF:			/* scalar reference */
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = svp_dup_inc((SV**)ptr, proto_perl);/* XXXXX */
	    break;
        case SAVEt_AV:				/* array reference */
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup_inc(av);
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup(gv);
	    break;
        case SAVEt_HV:				/* hash reference */
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv);
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup(gv);
	    break;
	case SAVEt_INT:				/* int reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    intval = (int)POPINT(ss,ix);
	    TOPINT(nss,ix) = intval;
	    break;
	case SAVEt_LONG:			/* long reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    longval = (long)POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    break;
	case SAVEt_I32:				/* I32 reference */
	case SAVEt_I16:				/* I16 reference */
	case SAVEt_I8:				/* I8 reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_IV:				/* IV reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
	    break;
	case SAVEt_SPTR:			/* SV* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv);
	    break;
	case SAVEt_VPTR:			/* random* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    break;
	case SAVEt_PPTR:			/* char* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
	    break;
	case SAVEt_HPTR:			/* HV* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup(hv);
	    break;
	case SAVEt_APTR:			/* AV* reference */
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup(av);
	    break;
	case SAVEt_NSTAB:
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup(gv);
	    break;
	case SAVEt_GP:				/* scalar reference */
	    gp = (GP*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gp = gp_dup(gp);
	    (void)GpREFCNT_inc(gp);
	    gv = (GV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = gv_dup_inc(c);
            c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
	    iv = POPIV(ss,ix);
	    TOPIV(nss,ix) = iv;
            break;
	case SAVEt_FREESV:
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    break;
	case SAVEt_FREEOP:
	    ptr = POPPTR(ss,ix);
	    if (ptr && (((OP*)ptr)->op_private & OPpREFCOUNTED)) {
		/* these are assumed to be refcounted properly */
		switch (((OP*)ptr)->op_type) {
		case OP_LEAVESUB:
		case OP_LEAVESUBLV:
		case OP_LEAVEEVAL:
		case OP_LEAVE:
		case OP_SCOPE:
		case OP_LEAVEWRITE:
		    TOPPTR(nss,ix) = ptr;
		    o = (OP*)ptr;
		    OpREFCNT_inc(o);
		    break;
		default:
		    TOPPTR(nss,ix) = Nullop;
		    break;
		}
	    }
	    else
		TOPPTR(nss,ix) = Nullop;
	    break;
	case SAVEt_FREEPV:
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup_inc(c);
	    break;
	case SAVEt_CLEARSV:
	    longval = POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    break;
	case SAVEt_DELETE:
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv);
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup_inc(c);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_DESTRUCTOR:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);	/* XXX quite arbitrary */
	    dptr = POPDPTR(ss,ix);
	    TOPDPTR(nss,ix) = (void (*)(void*))any_dup((void *)dptr, proto_perl);
	    break;
	case SAVEt_DESTRUCTOR_X:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);	/* XXX quite arbitrary */
	    dxptr = POPDXPTR(ss,ix);
	    TOPDXPTR(nss,ix) = (void (*)(pTHXo_ void*))any_dup((void *)dxptr, proto_perl);
	    break;
	case SAVEt_REGCONTEXT:
	case SAVEt_ALLOC:
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    ix -= i;
	    break;
	case SAVEt_STACK_POS:		/* Position on Perl stack */
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_AELEM:		/* array element */
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup_inc(av);
	    break;
	case SAVEt_HELEM:		/* hash element */
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv);
	    hv = (HV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = hv_dup_inc(hv);
	    break;
	case SAVEt_OP:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = ptr;
	    break;
	case SAVEt_HINTS:
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
	case SAVEt_COMPPAD:
	    av = (AV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup(av);
	    break;
	default:
	    Perl_croak(aTHX_ "panic: ss_dup inconsistency");
	}
d5053 8
a5060 291

    return nss;
}

#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

PerlInterpreter *
perl_clone(PerlInterpreter *proto_perl, UV flags)
{
#ifdef PERL_OBJECT
    CPerlObj *pPerl = (CPerlObj*)proto_perl;
#endif

#ifdef PERL_IMPLICIT_SYS
    return perl_clone_using(proto_perl, flags,
			    proto_perl->IMem,
			    proto_perl->IMemShared,
			    proto_perl->IMemParse,
			    proto_perl->IEnv,
			    proto_perl->IStdIO,
			    proto_perl->ILIO,
			    proto_perl->IDir,
			    proto_perl->ISock,
			    proto_perl->IProc);
}

PerlInterpreter *
perl_clone_using(PerlInterpreter *proto_perl, UV flags,
		 struct IPerlMem* ipM, struct IPerlMem* ipMS,
		 struct IPerlMem* ipMP, struct IPerlEnv* ipE,
		 struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO,
		 struct IPerlDir* ipD, struct IPerlSock* ipS,
		 struct IPerlProc* ipP)
{
    /* XXX many of the string copies here can be optimized if they're
     * constants; they need to be allocated as common memory and just
     * their pointers copied. */

    IV i;
#  ifdef PERL_OBJECT
    CPerlObj *pPerl = new(ipM) CPerlObj(ipM, ipMS, ipMP, ipE, ipStd, ipLIO,
					ipD, ipS, ipP);
    PERL_SET_THX(pPerl);
#  else		/* !PERL_OBJECT */
    PerlInterpreter *my_perl = (PerlInterpreter*)(*ipM->pMalloc)(ipM, sizeof(PerlInterpreter));
    PERL_SET_THX(my_perl);

#    ifdef DEBUGGING
    memset(my_perl, 0xab, sizeof(PerlInterpreter));
    PL_markstack = 0;
    PL_scopestack = 0;
    PL_savestack = 0;
    PL_retstack = 0;
#    else	/* !DEBUGGING */
    Zero(my_perl, 1, PerlInterpreter);
#    endif	/* DEBUGGING */

    /* host pointers */
    PL_Mem		= ipM;
    PL_MemShared	= ipMS;
    PL_MemParse		= ipMP;
    PL_Env		= ipE;
    PL_StdIO		= ipStd;
    PL_LIO		= ipLIO;
    PL_Dir		= ipD;
    PL_Sock		= ipS;
    PL_Proc		= ipP;
#  endif	/* PERL_OBJECT */
#else		/* !PERL_IMPLICIT_SYS */
    IV i;
    PerlInterpreter *my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
    PERL_SET_THX(my_perl);

#    ifdef DEBUGGING
    memset(my_perl, 0xab, sizeof(PerlInterpreter));
    PL_markstack = 0;
    PL_scopestack = 0;
    PL_savestack = 0;
    PL_retstack = 0;
#    else	/* !DEBUGGING */
    Zero(my_perl, 1, PerlInterpreter);
#    endif	/* DEBUGGING */
#endif		/* PERL_IMPLICIT_SYS */

    /* arena roots */
    PL_xiv_arenaroot	= NULL;
    PL_xiv_root		= NULL;
    PL_xnv_root		= NULL;
    PL_xrv_root		= NULL;
    PL_xpv_root		= NULL;
    PL_xpviv_root	= NULL;
    PL_xpvnv_root	= NULL;
    PL_xpvcv_root	= NULL;
    PL_xpvav_root	= NULL;
    PL_xpvhv_root	= NULL;
    PL_xpvmg_root	= NULL;
    PL_xpvlv_root	= NULL;
    PL_xpvbm_root	= NULL;
    PL_he_root		= NULL;
    PL_nice_chunk	= NULL;
    PL_nice_chunk_size	= 0;
    PL_sv_count		= 0;
    PL_sv_objcount	= 0;
    PL_sv_root		= Nullsv;
    PL_sv_arenaroot	= Nullsv;

    PL_debug		= proto_perl->Idebug;

    /* create SV map for pointer relocation */
    PL_ptr_table = ptr_table_new();

    /* initialize these special pointers as early as possible */
    SvANY(&PL_sv_undef)		= NULL;
    SvREFCNT(&PL_sv_undef)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVt_NULL;
    ptr_table_store(PL_ptr_table, &proto_perl->Isv_undef, &PL_sv_undef);

#ifdef PERL_OBJECT
    SvUPGRADE(&PL_sv_no, SVt_PVNV);
#else
    SvANY(&PL_sv_no)		= new_XPVNV();
#endif
    SvREFCNT(&PL_sv_no)		= (~(U32)0)/2;
    SvFLAGS(&PL_sv_no)		= SVp_NOK|SVf_NOK|SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
    SvPVX(&PL_sv_no)		= SAVEPVN(PL_No, 0);
    SvCUR(&PL_sv_no)		= 0;
    SvLEN(&PL_sv_no)		= 1;
    SvNVX(&PL_sv_no)		= 0;
    ptr_table_store(PL_ptr_table, &proto_perl->Isv_no, &PL_sv_no);

#ifdef PERL_OBJECT
    SvUPGRADE(&PL_sv_yes, SVt_PVNV);
#else
    SvANY(&PL_sv_yes)		= new_XPVNV();
#endif
    SvREFCNT(&PL_sv_yes)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_yes)		= SVp_NOK|SVf_NOK|SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
    SvPVX(&PL_sv_yes)		= SAVEPVN(PL_Yes, 1);
    SvCUR(&PL_sv_yes)		= 1;
    SvLEN(&PL_sv_yes)		= 2;
    SvNVX(&PL_sv_yes)		= 1;
    ptr_table_store(PL_ptr_table, &proto_perl->Isv_yes, &PL_sv_yes);

    /* create shared string table */
    PL_strtab		= newHV();
    HvSHAREKEYS_off(PL_strtab);
    hv_ksplit(PL_strtab, 512);
    ptr_table_store(PL_ptr_table, proto_perl->Istrtab, PL_strtab);

    PL_compiling		= proto_perl->Icompiling;
    PL_compiling.cop_stashpv	= SAVEPV(PL_compiling.cop_stashpv);
    PL_compiling.cop_file	= SAVEPV(PL_compiling.cop_file);
    ptr_table_store(PL_ptr_table, &proto_perl->Icompiling, &PL_compiling);
    if (!specialWARN(PL_compiling.cop_warnings))
	PL_compiling.cop_warnings = sv_dup_inc(PL_compiling.cop_warnings);
    PL_curcop		= (COP*)any_dup(proto_perl->Tcurcop, proto_perl);

    /* pseudo environmental stuff */
    PL_origargc		= proto_perl->Iorigargc;
    i = PL_origargc;
    New(0, PL_origargv, i+1, char*);
    PL_origargv[i] = '\0';
    while (i-- > 0) {
	PL_origargv[i]	= SAVEPV(proto_perl->Iorigargv[i]);
    }
    PL_envgv		= gv_dup(proto_perl->Ienvgv);
    PL_incgv		= gv_dup(proto_perl->Iincgv);
    PL_hintgv		= gv_dup(proto_perl->Ihintgv);
    PL_origfilename	= SAVEPV(proto_perl->Iorigfilename);
    PL_diehook		= sv_dup_inc(proto_perl->Idiehook);
    PL_warnhook		= sv_dup_inc(proto_perl->Iwarnhook);

    /* switches */
    PL_minus_c		= proto_perl->Iminus_c;
    PL_patchlevel	= sv_dup_inc(proto_perl->Ipatchlevel);
    PL_localpatches	= proto_perl->Ilocalpatches;
    PL_splitstr		= proto_perl->Isplitstr;
    PL_preprocess	= proto_perl->Ipreprocess;
    PL_minus_n		= proto_perl->Iminus_n;
    PL_minus_p		= proto_perl->Iminus_p;
    PL_minus_l		= proto_perl->Iminus_l;
    PL_minus_a		= proto_perl->Iminus_a;
    PL_minus_F		= proto_perl->Iminus_F;
    PL_doswitches	= proto_perl->Idoswitches;
    PL_dowarn		= proto_perl->Idowarn;
    PL_doextract	= proto_perl->Idoextract;
    PL_sawampersand	= proto_perl->Isawampersand;
    PL_unsafe		= proto_perl->Iunsafe;
    PL_inplace		= SAVEPV(proto_perl->Iinplace);
    PL_e_script		= sv_dup_inc(proto_perl->Ie_script);
    PL_perldb		= proto_perl->Iperldb;
    PL_perl_destruct_level = proto_perl->Iperl_destruct_level;

    /* magical thingies */
    /* XXX time(&PL_basetime) when asked for? */
    PL_basetime		= proto_perl->Ibasetime;
    PL_formfeed		= sv_dup(proto_perl->Iformfeed);

    PL_maxsysfd		= proto_perl->Imaxsysfd;
    PL_multiline	= proto_perl->Imultiline;
    PL_statusvalue	= proto_perl->Istatusvalue;
#ifdef VMS
    PL_statusvalue_vms	= proto_perl->Istatusvalue_vms;
#endif

    /* shortcuts to various I/O objects */
    PL_stdingv		= gv_dup(proto_perl->Istdingv);
    PL_stderrgv		= gv_dup(proto_perl->Istderrgv);
    PL_defgv		= gv_dup(proto_perl->Idefgv);
    PL_argvgv		= gv_dup(proto_perl->Iargvgv);
    PL_argvoutgv	= gv_dup(proto_perl->Iargvoutgv);
    PL_argvout_stack	= av_dup(proto_perl->Iargvout_stack);

    /* shortcuts to regexp stuff */
    PL_replgv		= gv_dup(proto_perl->Ireplgv);

    /* shortcuts to misc objects */
    PL_errgv		= gv_dup(proto_perl->Ierrgv);

    /* shortcuts to debugging objects */
    PL_DBgv		= gv_dup(proto_perl->IDBgv);
    PL_DBline		= gv_dup(proto_perl->IDBline);
    PL_DBsub		= gv_dup(proto_perl->IDBsub);
    PL_DBsingle		= sv_dup(proto_perl->IDBsingle);
    PL_DBtrace		= sv_dup(proto_perl->IDBtrace);
    PL_DBsignal		= sv_dup(proto_perl->IDBsignal);
    PL_lineary		= av_dup(proto_perl->Ilineary);
    PL_dbargs		= av_dup(proto_perl->Idbargs);

    /* symbol tables */
    PL_defstash		= hv_dup_inc(proto_perl->Tdefstash);
    PL_curstash		= hv_dup(proto_perl->Tcurstash);
    PL_debstash		= hv_dup(proto_perl->Idebstash);
    PL_globalstash	= hv_dup(proto_perl->Iglobalstash);
    PL_curstname	= sv_dup_inc(proto_perl->Icurstname);

    PL_beginav		= av_dup_inc(proto_perl->Ibeginav);
    PL_endav		= av_dup_inc(proto_perl->Iendav);
    PL_checkav		= av_dup_inc(proto_perl->Icheckav);
    PL_initav		= av_dup_inc(proto_perl->Iinitav);

    PL_sub_generation	= proto_perl->Isub_generation;

    /* funky return mechanisms */
    PL_forkprocess	= proto_perl->Iforkprocess;

    /* subprocess state */
    PL_fdpid		= av_dup_inc(proto_perl->Ifdpid);

    /* internal state */
    PL_tainting		= proto_perl->Itainting;
    PL_maxo		= proto_perl->Imaxo;
    if (proto_perl->Iop_mask)
	PL_op_mask	= SAVEPVN(proto_perl->Iop_mask, PL_maxo);
    else
	PL_op_mask 	= Nullch;

    /* current interpreter roots */
    PL_main_cv		= cv_dup_inc(proto_perl->Imain_cv);
    PL_main_root	= OpREFCNT_inc(proto_perl->Imain_root);
    PL_main_start	= proto_perl->Imain_start;
    PL_eval_root	= proto_perl->Ieval_root;
    PL_eval_start	= proto_perl->Ieval_start;

    /* runtime control stuff */
    PL_curcopdb		= (COP*)any_dup(proto_perl->Icurcopdb, proto_perl);
    PL_copline		= proto_perl->Icopline;

    PL_filemode		= proto_perl->Ifilemode;
    PL_lastfd		= proto_perl->Ilastfd;
    PL_oldname		= proto_perl->Ioldname;		/* XXX not quite right */
    PL_Argv		= NULL;
    PL_Cmd		= Nullch;
    PL_gensym		= proto_perl->Igensym;
    PL_preambled	= proto_perl->Ipreambled;
    PL_preambleav	= av_dup_inc(proto_perl->Ipreambleav);
    PL_laststatval	= proto_perl->Ilaststatval;
    PL_laststype	= proto_perl->Ilaststype;
    PL_mess_sv		= Nullsv;

    PL_orslen		= proto_perl->Iorslen;
    PL_ors		= SAVEPVN(proto_perl->Iors, PL_orslen);
    PL_ofmt		= SAVEPV(proto_perl->Iofmt);

    /* interpreter atexit processing */
    PL_exitlistlen	= proto_perl->Iexitlistlen;
    if (PL_exitlistlen) {
	New(0, PL_exitlist, PL_exitlistlen, PerlExitListEntry);
	Copy(proto_perl->Iexitlist, PL_exitlist, PL_exitlistlen, PerlExitListEntry);
d5062 3
a5064 182
    else
	PL_exitlist	= (PerlExitListEntry*)NULL;
    PL_modglobal	= hv_dup_inc(proto_perl->Imodglobal);

    PL_profiledata	= NULL;
    PL_rsfp		= fp_dup(proto_perl->Irsfp, '<');
    /* PL_rsfp_filters entries have fake IoDIRP() */
    PL_rsfp_filters	= av_dup_inc(proto_perl->Irsfp_filters);

    PL_compcv			= cv_dup(proto_perl->Icompcv);
    PL_comppad			= av_dup(proto_perl->Icomppad);
    PL_comppad_name		= av_dup(proto_perl->Icomppad_name);
    PL_comppad_name_fill	= proto_perl->Icomppad_name_fill;
    PL_comppad_name_floor	= proto_perl->Icomppad_name_floor;
    PL_curpad			= (SV**)ptr_table_fetch(PL_ptr_table,
							proto_perl->Tcurpad);

#ifdef HAVE_INTERP_INTERN
    sys_intern_dup(&proto_perl->Isys_intern, &PL_sys_intern);
#endif

    /* more statics moved here */
    PL_generation	= proto_perl->Igeneration;
    PL_DBcv		= cv_dup(proto_perl->IDBcv);

    PL_in_clean_objs	= proto_perl->Iin_clean_objs;
    PL_in_clean_all	= proto_perl->Iin_clean_all;

    PL_uid		= proto_perl->Iuid;
    PL_euid		= proto_perl->Ieuid;
    PL_gid		= proto_perl->Igid;
    PL_egid		= proto_perl->Iegid;
    PL_nomemok		= proto_perl->Inomemok;
    PL_an		= proto_perl->Ian;
    PL_cop_seqmax	= proto_perl->Icop_seqmax;
    PL_op_seqmax	= proto_perl->Iop_seqmax;
    PL_evalseq		= proto_perl->Ievalseq;
    PL_origenviron	= proto_perl->Iorigenviron;	/* XXX not quite right */
    PL_origalen		= proto_perl->Iorigalen;
    PL_pidstatus	= newHV();			/* XXX flag for cloning? */
    PL_osname		= SAVEPV(proto_perl->Iosname);
    PL_sh_path		= SAVEPV(proto_perl->Ish_path);
    PL_sighandlerp	= proto_perl->Isighandlerp;


    PL_runops		= proto_perl->Irunops;

    Copy(proto_perl->Itokenbuf, PL_tokenbuf, 256, char);

#ifdef CSH
    PL_cshlen		= proto_perl->Icshlen;
    PL_cshname		= SAVEPVN(proto_perl->Icshname, PL_cshlen);
#endif

    PL_lex_state	= proto_perl->Ilex_state;
    PL_lex_defer	= proto_perl->Ilex_defer;
    PL_lex_expect	= proto_perl->Ilex_expect;
    PL_lex_formbrack	= proto_perl->Ilex_formbrack;
    PL_lex_dojoin	= proto_perl->Ilex_dojoin;
    PL_lex_starts	= proto_perl->Ilex_starts;
    PL_lex_stuff	= sv_dup_inc(proto_perl->Ilex_stuff);
    PL_lex_repl		= sv_dup_inc(proto_perl->Ilex_repl);
    PL_lex_op		= proto_perl->Ilex_op;
    PL_lex_inpat	= proto_perl->Ilex_inpat;
    PL_lex_inwhat	= proto_perl->Ilex_inwhat;
    PL_lex_brackets	= proto_perl->Ilex_brackets;
    i = (PL_lex_brackets < 120 ? 120 : PL_lex_brackets);
    PL_lex_brackstack	= SAVEPVN(proto_perl->Ilex_brackstack,i);
    PL_lex_casemods	= proto_perl->Ilex_casemods;
    i = (PL_lex_casemods < 12 ? 12 : PL_lex_casemods);
    PL_lex_casestack	= SAVEPVN(proto_perl->Ilex_casestack,i);

    Copy(proto_perl->Inextval, PL_nextval, 5, YYSTYPE);
    Copy(proto_perl->Inexttype, PL_nexttype, 5,	I32);
    PL_nexttoke		= proto_perl->Inexttoke;

    PL_linestr		= sv_dup_inc(proto_perl->Ilinestr);
    i = proto_perl->Ibufptr - SvPVX(proto_perl->Ilinestr);
    PL_bufptr		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    i = proto_perl->Ioldbufptr - SvPVX(proto_perl->Ilinestr);
    PL_oldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    i = proto_perl->Ioldoldbufptr - SvPVX(proto_perl->Ilinestr);
    PL_oldoldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    PL_bufend		= SvPVX(PL_linestr) + SvCUR(PL_linestr);
    i = proto_perl->Ilinestart - SvPVX(proto_perl->Ilinestr);
    PL_linestart	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    PL_pending_ident	= proto_perl->Ipending_ident;
    PL_sublex_info	= proto_perl->Isublex_info;	/* XXX not quite right */

    PL_expect		= proto_perl->Iexpect;

    PL_multi_start	= proto_perl->Imulti_start;
    PL_multi_end	= proto_perl->Imulti_end;
    PL_multi_open	= proto_perl->Imulti_open;
    PL_multi_close	= proto_perl->Imulti_close;

    PL_error_count	= proto_perl->Ierror_count;
    PL_subline		= proto_perl->Isubline;
    PL_subname		= sv_dup_inc(proto_perl->Isubname);

    PL_min_intro_pending	= proto_perl->Imin_intro_pending;
    PL_max_intro_pending	= proto_perl->Imax_intro_pending;
    PL_padix			= proto_perl->Ipadix;
    PL_padix_floor		= proto_perl->Ipadix_floor;
    PL_pad_reset_pending	= proto_perl->Ipad_reset_pending;

    i = proto_perl->Ilast_uni - SvPVX(proto_perl->Ilinestr);
    PL_last_uni		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    i = proto_perl->Ilast_lop - SvPVX(proto_perl->Ilinestr);
    PL_last_lop		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    PL_last_lop_op	= proto_perl->Ilast_lop_op;
    PL_in_my		= proto_perl->Iin_my;
    PL_in_my_stash	= hv_dup(proto_perl->Iin_my_stash);
#ifdef FCRYPT
    PL_cryptseen	= proto_perl->Icryptseen;
#endif

    PL_hints		= proto_perl->Ihints;

    PL_amagic_generation	= proto_perl->Iamagic_generation;

#ifdef USE_LOCALE_COLLATE
    PL_collation_ix	= proto_perl->Icollation_ix;
    PL_collation_name	= SAVEPV(proto_perl->Icollation_name);
    PL_collation_standard	= proto_perl->Icollation_standard;
    PL_collxfrm_base	= proto_perl->Icollxfrm_base;
    PL_collxfrm_mult	= proto_perl->Icollxfrm_mult;
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    PL_numeric_name	= SAVEPV(proto_perl->Inumeric_name);
    PL_numeric_standard	= proto_perl->Inumeric_standard;
    PL_numeric_local	= proto_perl->Inumeric_local;
    PL_numeric_radix	= proto_perl->Inumeric_radix;
#endif /* !USE_LOCALE_NUMERIC */

    /* utf8 character classes */
    PL_utf8_alnum	= sv_dup_inc(proto_perl->Iutf8_alnum);
    PL_utf8_alnumc	= sv_dup_inc(proto_perl->Iutf8_alnumc);
    PL_utf8_ascii	= sv_dup_inc(proto_perl->Iutf8_ascii);
    PL_utf8_alpha	= sv_dup_inc(proto_perl->Iutf8_alpha);
    PL_utf8_space	= sv_dup_inc(proto_perl->Iutf8_space);
    PL_utf8_cntrl	= sv_dup_inc(proto_perl->Iutf8_cntrl);
    PL_utf8_graph	= sv_dup_inc(proto_perl->Iutf8_graph);
    PL_utf8_digit	= sv_dup_inc(proto_perl->Iutf8_digit);
    PL_utf8_upper	= sv_dup_inc(proto_perl->Iutf8_upper);
    PL_utf8_lower	= sv_dup_inc(proto_perl->Iutf8_lower);
    PL_utf8_print	= sv_dup_inc(proto_perl->Iutf8_print);
    PL_utf8_punct	= sv_dup_inc(proto_perl->Iutf8_punct);
    PL_utf8_xdigit	= sv_dup_inc(proto_perl->Iutf8_xdigit);
    PL_utf8_mark	= sv_dup_inc(proto_perl->Iutf8_mark);
    PL_utf8_toupper	= sv_dup_inc(proto_perl->Iutf8_toupper);
    PL_utf8_totitle	= sv_dup_inc(proto_perl->Iutf8_totitle);
    PL_utf8_tolower	= sv_dup_inc(proto_perl->Iutf8_tolower);

    /* swatch cache */
    PL_last_swash_hv	= Nullhv;	/* reinits on demand */
    PL_last_swash_klen	= 0;
    PL_last_swash_key[0]= '\0';
    PL_last_swash_tmps	= (U8*)NULL;
    PL_last_swash_slen	= 0;

    /* perly.c globals */
    PL_yydebug		= proto_perl->Iyydebug;
    PL_yynerrs		= proto_perl->Iyynerrs;
    PL_yyerrflag	= proto_perl->Iyyerrflag;
    PL_yychar		= proto_perl->Iyychar;
    PL_yyval		= proto_perl->Iyyval;
    PL_yylval		= proto_perl->Iyylval;

    PL_glob_index	= proto_perl->Iglob_index;
    PL_srand_called	= proto_perl->Isrand_called;
    PL_uudmap['M']	= 0;		/* reinits on demand */
    PL_bitcount		= Nullch;	/* reinits on demand */

    if (proto_perl->Ipsig_ptr) {
	int sig_num[] = { SIG_NUM };
	Newz(0, PL_psig_ptr, sizeof(sig_num)/sizeof(*sig_num), SV*);
	Newz(0, PL_psig_name, sizeof(sig_num)/sizeof(*sig_num), SV*);
	for (i = 1; PL_sig_name[i]; i++) {
	    PL_psig_ptr[i] = sv_dup_inc(proto_perl->Ipsig_ptr[i]);
	    PL_psig_name[i] = sv_dup_inc(proto_perl->Ipsig_name[i]);
d5066 2
d5069 51
a5119 245
    else {
	PL_psig_ptr	= (SV**)NULL;
	PL_psig_name	= (SV**)NULL;
    }

    /* thrdvar.h stuff */

    if (flags & 1) {
	/* next allocation will be PL_tmps_stack[PL_tmps_ix+1] */
	PL_tmps_ix		= proto_perl->Ttmps_ix;
	PL_tmps_max		= proto_perl->Ttmps_max;
	PL_tmps_floor		= proto_perl->Ttmps_floor;
	Newz(50, PL_tmps_stack, PL_tmps_max, SV*);
	i = 0;
	while (i <= PL_tmps_ix) {
	    PL_tmps_stack[i]	= sv_dup_inc(proto_perl->Ttmps_stack[i]);
	    ++i;
	}

	/* next PUSHMARK() sets *(PL_markstack_ptr+1) */
	i = proto_perl->Tmarkstack_max - proto_perl->Tmarkstack;
	Newz(54, PL_markstack, i, I32);
	PL_markstack_max	= PL_markstack + (proto_perl->Tmarkstack_max
						  - proto_perl->Tmarkstack);
	PL_markstack_ptr	= PL_markstack + (proto_perl->Tmarkstack_ptr
						  - proto_perl->Tmarkstack);
	Copy(proto_perl->Tmarkstack, PL_markstack,
	     PL_markstack_ptr - PL_markstack + 1, I32);

	/* next push_scope()/ENTER sets PL_scopestack[PL_scopestack_ix]
	 * NOTE: unlike the others! */
	PL_scopestack_ix	= proto_perl->Tscopestack_ix;
	PL_scopestack_max	= proto_perl->Tscopestack_max;
	Newz(54, PL_scopestack, PL_scopestack_max, I32);
	Copy(proto_perl->Tscopestack, PL_scopestack, PL_scopestack_ix, I32);

	/* next push_return() sets PL_retstack[PL_retstack_ix]
	 * NOTE: unlike the others! */
	PL_retstack_ix		= proto_perl->Tretstack_ix;
	PL_retstack_max		= proto_perl->Tretstack_max;
	Newz(54, PL_retstack, PL_retstack_max, OP*);
	Copy(proto_perl->Tretstack, PL_retstack, PL_retstack_ix, I32);

	/* NOTE: si_dup() looks at PL_markstack */
	PL_curstackinfo		= si_dup(proto_perl->Tcurstackinfo);

	/* PL_curstack		= PL_curstackinfo->si_stack; */
	PL_curstack		= av_dup(proto_perl->Tcurstack);
	PL_mainstack		= av_dup(proto_perl->Tmainstack);

	/* next PUSHs() etc. set *(PL_stack_sp+1) */
	PL_stack_base		= AvARRAY(PL_curstack);
	PL_stack_sp		= PL_stack_base + (proto_perl->Tstack_sp
						   - proto_perl->Tstack_base);
	PL_stack_max		= PL_stack_base + AvMAX(PL_curstack);

	/* next SSPUSHFOO() sets PL_savestack[PL_savestack_ix]
	 * NOTE: unlike the others! */
	PL_savestack_ix		= proto_perl->Tsavestack_ix;
	PL_savestack_max	= proto_perl->Tsavestack_max;
	/*Newz(54, PL_savestack, PL_savestack_max, ANY);*/
	PL_savestack		= ss_dup(proto_perl);
    }
    else {
	init_stacks();
    }

    PL_start_env	= proto_perl->Tstart_env;	/* XXXXXX */
    PL_top_env		= &PL_start_env;

    PL_op		= proto_perl->Top;

    PL_Sv		= Nullsv;
    PL_Xpv		= (XPV*)NULL;
    PL_na		= proto_perl->Tna;

    PL_statbuf		= proto_perl->Tstatbuf;
    PL_statcache	= proto_perl->Tstatcache;
    PL_statgv		= gv_dup(proto_perl->Tstatgv);
    PL_statname		= sv_dup_inc(proto_perl->Tstatname);
#ifdef HAS_TIMES
    PL_timesbuf		= proto_perl->Ttimesbuf;
#endif

    PL_tainted		= proto_perl->Ttainted;
    PL_curpm		= proto_perl->Tcurpm;	/* XXX No PMOP ref count */
    PL_nrs		= sv_dup_inc(proto_perl->Tnrs);
    PL_rs		= sv_dup_inc(proto_perl->Trs);
    PL_last_in_gv	= gv_dup(proto_perl->Tlast_in_gv);
    PL_ofslen		= proto_perl->Tofslen;
    PL_ofs		= SAVEPVN(proto_perl->Tofs, PL_ofslen);
    PL_defoutgv		= gv_dup_inc(proto_perl->Tdefoutgv);
    PL_chopset		= proto_perl->Tchopset;	/* XXX never deallocated */
    PL_toptarget	= sv_dup_inc(proto_perl->Ttoptarget);
    PL_bodytarget	= sv_dup_inc(proto_perl->Tbodytarget);
    PL_formtarget	= sv_dup(proto_perl->Tformtarget);

    PL_restartop	= proto_perl->Trestartop;
    PL_in_eval		= proto_perl->Tin_eval;
    PL_delaymagic	= proto_perl->Tdelaymagic;
    PL_dirty		= proto_perl->Tdirty;
    PL_localizing	= proto_perl->Tlocalizing;

#ifdef PERL_FLEXIBLE_EXCEPTIONS
    PL_protect		= proto_perl->Tprotect;
#endif
    PL_errors		= sv_dup_inc(proto_perl->Terrors);
    PL_av_fetch_sv	= Nullsv;
    PL_hv_fetch_sv	= Nullsv;
    Zero(&PL_hv_fetch_ent_mh, 1, HE);			/* XXX */
    PL_modcount		= proto_perl->Tmodcount;
    PL_lastgotoprobe	= Nullop;
    PL_dumpindent	= proto_perl->Tdumpindent;

    PL_sortcop		= (OP*)any_dup(proto_perl->Tsortcop, proto_perl);
    PL_sortstash	= hv_dup(proto_perl->Tsortstash);
    PL_firstgv		= gv_dup(proto_perl->Tfirstgv);
    PL_secondgv		= gv_dup(proto_perl->Tsecondgv);
    PL_sortcxix		= proto_perl->Tsortcxix;
    PL_efloatbuf	= Nullch;		/* reinits on demand */
    PL_efloatsize	= 0;			/* reinits on demand */

    /* regex stuff */

    PL_screamfirst	= NULL;
    PL_screamnext	= NULL;
    PL_maxscream	= -1;			/* reinits on demand */
    PL_lastscream	= Nullsv;

    PL_watchaddr	= NULL;
    PL_watchok		= Nullch;

    PL_regdummy		= proto_perl->Tregdummy;
    PL_regcomp_parse	= Nullch;
    PL_regxend		= Nullch;
    PL_regcode		= (regnode*)NULL;
    PL_regnaughty	= 0;
    PL_regsawback	= 0;
    PL_regprecomp	= Nullch;
    PL_regnpar		= 0;
    PL_regsize		= 0;
    PL_regflags		= 0;
    PL_regseen		= 0;
    PL_seen_zerolen	= 0;
    PL_seen_evals	= 0;
    PL_regcomp_rx	= (regexp*)NULL;
    PL_extralen		= 0;
    PL_colorset		= 0;		/* reinits PL_colors[] */
    /*PL_colors[6]	= {0,0,0,0,0,0};*/
    PL_reg_whilem_seen	= 0;
    PL_reginput		= Nullch;
    PL_regbol		= Nullch;
    PL_regeol		= Nullch;
    PL_regstartp	= (I32*)NULL;
    PL_regendp		= (I32*)NULL;
    PL_reglastparen	= (U32*)NULL;
    PL_regtill		= Nullch;
    PL_regprev		= '\n';
    PL_reg_start_tmp	= (char**)NULL;
    PL_reg_start_tmpl	= 0;
    PL_regdata		= (struct reg_data*)NULL;
    PL_bostr		= Nullch;
    PL_reg_flags	= 0;
    PL_reg_eval_set	= 0;
    PL_regnarrate	= 0;
    PL_regprogram	= (regnode*)NULL;
    PL_regindent	= 0;
    PL_regcc		= (CURCUR*)NULL;
    PL_reg_call_cc	= (struct re_cc_state*)NULL;
    PL_reg_re		= (regexp*)NULL;
    PL_reg_ganch	= Nullch;
    PL_reg_sv		= Nullsv;
    PL_reg_magic	= (MAGIC*)NULL;
    PL_reg_oldpos	= 0;
    PL_reg_oldcurpm	= (PMOP*)NULL;
    PL_reg_curpm	= (PMOP*)NULL;
    PL_reg_oldsaved	= Nullch;
    PL_reg_oldsavedlen	= 0;
    PL_reg_maxiter	= 0;
    PL_reg_leftiter	= 0;
    PL_reg_poscache	= Nullch;
    PL_reg_poscache_size= 0;

    /* RE engine - function pointers */
    PL_regcompp		= proto_perl->Tregcompp;
    PL_regexecp		= proto_perl->Tregexecp;
    PL_regint_start	= proto_perl->Tregint_start;
    PL_regint_string	= proto_perl->Tregint_string;
    PL_regfree		= proto_perl->Tregfree;

    PL_reginterp_cnt	= 0;
    PL_reg_starttry	= 0;

#ifdef PERL_OBJECT
    return (PerlInterpreter*)pPerl;
#else
    return my_perl;
#endif
}

#else	/* !USE_ITHREADS */

#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

#endif /* USE_ITHREADS */

static void
do_report_used(pTHXo_ SV *sv)
{
    if (SvTYPE(sv) != SVTYPEMASK) {
	PerlIO_printf(Perl_debug_log, "****\n");
	sv_dump(sv);
    }
}

static void
do_clean_objs(pTHXo_ SV *sv)
{
    SV* rv;

    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
	DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(sv));)
	SvROK_off(sv);
	SvRV(sv) = 0;
	SvREFCNT_dec(rv);
    }

    /* XXX Might want to check arrays, etc. */
}

#ifndef DISABLE_DESTRUCTOR_KLUDGE
static void
do_clean_named_objs(pTHXo_ SV *sv)
{
    if (SvTYPE(sv) == SVt_PVGV && GvGP(sv)) {
	if ( SvOBJECT(GvSV(sv)) ||
	     (GvAV(sv) && SvOBJECT(GvAV(sv))) ||
	     (GvHV(sv) && SvOBJECT(GvHV(sv))) ||
	     (GvIO(sv) && SvOBJECT(GvIO(sv))) ||
	     (GvCV(sv) && SvOBJECT(GvCV(sv))) )
	{
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning named glob object:\n "), sv_dump(sv));)
	    SvREFCNT_dec(sv);
d5121 50
d5172 1
a5173 10
#endif

static void
do_clean_all(pTHXo_ SV *sv)
{
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops: SV at 0x%"UVxf"\n", PTR2UV(sv)) );)
    SvFLAGS(sv) |= SVf_BREAK;
    SvREFCNT_dec(sv);
}

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d150 1
a150 1
STATIC I32
a155 1
    I32 visited = 0;
d160 1
a160 1
	    if (SvTYPE(sv) != SVTYPEMASK && SvREFCNT(sv)) {
a161 2
		++visited;
	    }
a163 1
    return visited;
d184 1
a184 1
I32
a186 1
    I32 cleaned;
d188 1
a188 1
    cleaned = visit(do_clean_all);
a189 1
    return cleaned;
a196 1
    XPV *arena, *arenanext;
a209 78
    for (arena = PL_xiv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xiv_arenaroot = 0;

    for (arena = PL_xnv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xnv_arenaroot = 0;

    for (arena = PL_xrv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xrv_arenaroot = 0;

    for (arena = PL_xpv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpv_arenaroot = 0;

    for (arena = (XPV*)PL_xpviv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpviv_arenaroot = 0;

    for (arena = (XPV*)PL_xpvnv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvnv_arenaroot = 0;

    for (arena = (XPV*)PL_xpvcv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvcv_arenaroot = 0;

    for (arena = (XPV*)PL_xpvav_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvav_arenaroot = 0;

    for (arena = (XPV*)PL_xpvhv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvhv_arenaroot = 0;

    for (arena = (XPV*)PL_xpvmg_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvmg_arenaroot = 0;

    for (arena = (XPV*)PL_xpvlv_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvlv_arenaroot = 0;

    for (arena = (XPV*)PL_xpvbm_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_xpvbm_arenaroot = 0;

    for (arena = (XPV*)PL_he_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_he_arenaroot = 0;

d303 1
a303 6
    XPV *ptr;
    New(711, ptr, 1008/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xnv_arenaroot;
    PL_xnv_arenaroot = ptr;

    xnv = (NV*) ptr;
d341 2
a342 6
    XPV *ptr;
    New(712, ptr, 1008/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xrv_arenaroot;
    PL_xrv_arenaroot = ptr;

    xrv = (XRV*) ptr;
a343 2
    xrv += (sizeof(XPV) - 1) / sizeof(XRV) + 1;
    PL_xrv_root = xrv;
d378 2
a379 4
    New(713, xpv, 1008/sizeof(XPV), XPV);
    xpv->xpv_pv = (char*)PL_xpv_arenaroot;
    PL_xpv_arenaroot = xpv;

a380 1
    PL_xpv_root = ++xpv;
d410 1
d416 2
a417 4
    New(714, xpviv, 1008/sizeof(XPVIV), XPVIV);
    xpviv->xpv_pv = (char*)PL_xpviv_arenaroot;
    PL_xpviv_arenaroot = xpviv;

a418 1
    PL_xpviv_root = ++xpviv;
d426 1
d449 1
d455 2
a456 4
    New(715, xpvnv, 1008/sizeof(XPVNV), XPVNV);
    xpvnv->xpv_pv = (char*)PL_xpvnv_arenaroot;
    PL_xpvnv_arenaroot = xpvnv;

a457 1
    PL_xpvnv_root = ++xpvnv;
d465 2
d489 1
d495 2
a496 4
    New(716, xpvcv, 1008/sizeof(XPVCV), XPVCV);
    xpvcv->xpv_pv = (char*)PL_xpvcv_arenaroot;
    PL_xpvcv_arenaroot = xpvcv;

a497 1
    PL_xpvcv_root = ++xpvcv;
d505 2
d529 1
d535 2
a536 4
    New(717, xpvav, 1008/sizeof(XPVAV), XPVAV);
    xpvav->xav_array = (char*)PL_xpvav_arenaroot;
    PL_xpvav_arenaroot = xpvav;

a537 1
    PL_xpvav_root = ++xpvav;
d545 2
d569 1
d575 2
a576 4
    New(718, xpvhv, 1008/sizeof(XPVHV), XPVHV);
    xpvhv->xhv_array = (char*)PL_xpvhv_arenaroot;
    PL_xpvhv_arenaroot = xpvhv;

a577 1
    PL_xpvhv_root = ++xpvhv;
d585 1
d608 1
d614 2
a615 4
    New(719, xpvmg, 1008/sizeof(XPVMG), XPVMG);
    xpvmg->xpv_pv = (char*)PL_xpvmg_arenaroot;
    PL_xpvmg_arenaroot = xpvmg;

a616 1
    PL_xpvmg_root = ++xpvmg;
d624 2
d648 1
d654 2
a655 4
    New(720, xpvlv, 1008/sizeof(XPVLV), XPVLV);
    xpvlv->xpv_pv = (char*)PL_xpvlv_arenaroot;
    PL_xpvlv_arenaroot = xpvlv;

a656 1
    PL_xpvlv_root = ++xpvlv;
d664 1
d687 1
d693 2
a694 4
    New(721, xpvbm, 1008/sizeof(XPVBM), XPVBM);
    xpvbm->xpv_pv = (char*)PL_xpvbm_arenaroot;
    PL_xpvbm_arenaroot = xpvbm;

a695 1
    PL_xpvbm_root = ++xpvbm;
d1186 5
a1190 2
	Perl_croak(aTHX_ "Can't coerce %s to integer in %s", sv_reftype(sv,0),
		   PL_op_desc[PL_op->op_type]);
d1274 5
a1278 2
	Perl_croak(aTHX_ "Can't coerce %s to number in %s", sv_reftype(sv,0),
		   PL_op_name[PL_op->op_type]);
d1303 1
a1361 1
#define IS_NUMBER_INFINITY	 0x10 /* this is big */
d1382 1
d1392 1
a1392 2
          if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)) &&
                  (SvRV(tmpstr) != SvRV(sv)))
d1397 1
d1473 11
a1483 2
	else {	/* The NV may be reconstructed from IV - safe to cache IV,
		   which may be calculated by atol(). */
d1486 1
d1488 1
a1488 2
	    SvIVX(sv) = Atol(SvPVX(sv));
	    if (! numtype && ckWARN(WARN_NUMERIC))
d1493 1
d1521 1
d1531 1
a1531 2
          if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)) &&
                  (SvRV(tmpstr) != SvRV(sv)))
d1536 1
d1636 2
d1640 2
a1643 2
	    SvUVX(sv) = 0;		/* We assume that 0s have the
					   same bitmap in IV and UV. */
d1650 1
d1675 1
d1688 1
d1698 1
a1698 2
          if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,numer)) &&
                  (SvRV(tmpstr) != SvRV(sv)))
d1703 1
d1716 1
a1716 1
	    STORE_NUMERIC_LOCAL_SET_STANDARD();
d1724 1
a1724 1
	    STORE_NUMERIC_LOCAL_SET_STANDARD();
d1739 1
d1745 1
d1756 1
a1756 1
	STORE_NUMERIC_LOCAL_SET_STANDARD();
d1763 1
a1763 1
	STORE_NUMERIC_LOCAL_SET_STANDARD();
d1781 1
d1799 1
a1815 1
 * IS_NUMBER_INFINITY
a1835 1
    I32 sawinf  = 0;
a1836 3
#ifdef USE_LOCALE_NUMERIC
    bool specialradix = FALSE;
#endif
d1865 1
a1865 1
    /* next must be digit or the radix separator or beginning of infinity */
d1877 2
a1878 2
#ifdef USE_LOCALE_NUMERIC
	    || (specialradix = IS_NUMERIC_RADIX(s))
d1881 1
a1881 6
#ifdef USE_LOCALE_NUMERIC
	    if (specialradix)
		s += SvCUR(PL_numeric_radix_sv);
	    else
#endif
		s++;
d1888 2
a1889 2
#ifdef USE_LOCALE_NUMERIC
	    || (specialradix = IS_NUMERIC_RADIX(s))
d1892 1
a1892 6
#ifdef USE_LOCALE_NUMERIC
	if (specialradix)
	    s += SvCUR(PL_numeric_radix_sv);
	else
#endif
	    s++;
a1902 11
    else if (*s == 'I' || *s == 'i') {
	s++; if (*s != 'N' && *s != 'n') return 0;
	s++; if (*s != 'F' && *s != 'f') return 0;
	s++; if (*s == 'I' || *s == 'i') {
	    s++; if (*s != 'N' && *s != 'n') return 0;
	    s++; if (*s != 'I' && *s != 'i') return 0;
	    s++; if (*s != 'T' && *s != 't') return 0;
	    s++; if (*s != 'Y' && *s != 'y') return 0;
	}
	sawinf = 1;
    }
d1906 6
a1911 7
    if (sawinf)
	numtype = IS_NUMBER_INFINITY;
    else {
	/* we can have an optional exponent part */
	if (*s == 'e' || *s == 'E') {
	    numtype &= ~IS_NUMBER_NEG;
	    numtype |= IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV;
d1913 7
a1919 10
	    if (*s == '+' || *s == '-')
		s++;
	    if (isDIGIT(*s)) {
		do {
		    s++;
		} while (isDIGIT(*s));
	    }
	    else
		return 0;
	}
d1997 1
d2008 1
a2008 2
            if (SvAMAGIC(sv) && (tmpstr=AMG_CALLun(sv,string)) &&
                    (SvRV(tmpstr) != SvRV(sv)))
d2023 1
d2091 1
d2100 1
a2100 1
	/* I tried changing this to be 64-bit-aware and
d2105 1
a2105 2
	/* The +20 is pure guesswork.  Configure test needed. --jhi */ 
	SvGROW(sv, NV_DIG + 20);
d2153 1
d2156 1
d2158 1
d2236 1
a2236 1
    return SvPV(sv,*lp);
d2249 1
d2251 1
a2251 2
        if (SvAMAGIC(sv) && (tmpsv=AMG_CALLun(sv,bool_)) &&
                (SvRV(tmpsv) != SvRV(sv)))
a2276 8
/*
=for apidoc sv_utf8_upgrade

Convert the PV of an SV to its UTF8-encoded form.

=cut
*/

d2280 2
a2281 2
    char *s, *t, *e;
    int  hibit = 0;
d2286 2
a2287 3
    /* This function could be much more efficient if we had a FLAG in SVs
     * to signal if there are any hibit chars in the PV.
     * Given that there isn't make loop fast as possible
d2289 24
a2312 10
    s = SvPVX(sv);
    e = SvEND(sv);
    t = s;
    while (t < e) {
	if ((hibit = UTF8_IS_CONTINUED(*t++)))
	    break;
    }

    if (hibit) {
	STRLEN len;
a2313 10
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
	    s = SvPVX(sv);
	}
	len = SvCUR(sv) + 1; /* Plus the \0 */
	SvPVX(sv) = (char*)bytes_to_utf8((U8*)s, &len);
	SvCUR(sv) = len - 1;
	if (SvLEN(sv) != 0)
	    Safefree(s); /* No longer using what was there before. */
	SvLEN(sv) = len; /* No longer know the real size. */
a2317 11
/*
=for apidoc sv_utf8_downgrade

Attempt to convert the PV of an SV from UTF8-encoded to byte encoding.
This may not be possible if the PV contains non-byte encoding characters;
if this is the case, either returns false or, if C<fail_ok> is not
true, croaks.

=cut
*/

d2322 14
a2335 16
        if (SvCUR(sv)) {
	    char *s;
	    STRLEN len;

	    if (SvREADONLY(sv) && SvFAKE(sv))
		sv_force_normal(sv);
	    s = SvPV(sv, len);
	    if (!utf8_to_bytes((U8*)s, &len)) {
	        if (fail_ok)
		    return FALSE;
		else {
		    if (PL_op)
		        Perl_croak(aTHX_ "Wide character in %s",
				   PL_op_desc[PL_op->op_type]);
		    else
		        Perl_croak(aTHX_ "Wide character");
d2337 26
a2362 4
	    }
	    SvCUR(sv) = len;
	}
	SvUTF8_off(sv);
a2363 1

a2366 9
/*
=for apidoc sv_utf8_encode

Convert the PV of an SV to UTF8-encoded, but then turn off the C<SvUTF8>
flag so that it looks like bytes again. Nothing calls this. 

=cut
*/

a2378 1
        char *e;
d2387 14
a2400 8
	if (!is_utf8_string((U8*)c, SvCUR(sv)+1))
	    return FALSE;
        e = SvEND(sv);
        while (c < e) {
            if (UTF8_IS_CONTINUED(*c++)) {
		SvUTF8_on(sv);
		break;
	    }
d2402 3
d2429 1
d2472 1
a2472 2
	    if (SvTAINTED(sstr))
		SvTAINT(dstr);
d2492 1
a2492 2
	    if (SvTAINTED(sstr))
		SvTAINT(dstr);
d2546 1
a2546 1
		sv_magic(dstr, dstr, '*', Nullch, 0);
d2561 1
a2561 2
	    if (SvTAINTED(sstr))
		SvTAINT(dstr);
d2707 1
a2707 2
		if (SvTAINTED(sstr))
		    SvTAINT(dstr);
d2727 1
a2727 1
	    if (sflags & SVf_IVisUV)
d2759 4
d2765 1
a2765 1
	    (void)SvOK_off(sstr);		/* NOTE: nukes most SvFLAGS on sstr */
d2780 1
a2780 1
	if (sflags & SVf_UTF8)
d2790 1
a2790 1
	    if (sflags & SVf_IVisUV)
d2797 1
a2797 1
	if (sflags & SVf_IOK) {
d2801 1
a2801 1
	    if (sflags & SVf_IVisUV)
d2808 1
a2808 1
	if (sflags & SVf_IVisUV)
d2819 1
a2819 2
    if (SvTAINTED(sstr))
	SvTAINT(dstr);
d2850 2
a2851 1

a2856 5
    else {
        /* len is STRLEN which is unsigned, need to copy to signed */
	IV iv = len;
	assert(iv >= 0);
    }
d2981 1
d3079 2
a3080 3
Concatenates the string from SV C<ssv> onto the end of the string in
SV C<dsv>.  Modifies C<dsv> but not C<ssv>.  Handles 'get' magic, but
not 'set' magic.  See C<sv_catsv_mg>.
d3082 2
a3083 1
=cut */
d3088 2
a3089 2
    char *spv;
    STRLEN slen;
d3092 6
a3097 23
    if ((spv = SvPV(sstr, slen))) {
	bool dutf8 = DO_UTF8(dstr);
	bool sutf8 = DO_UTF8(sstr);

	if (dutf8 == sutf8)
	    sv_catpvn(dstr,spv,slen);
	else {
	    if (dutf8) {
		SV* cstr = newSVsv(sstr);
		char *cpv;
		STRLEN clen;

		sv_utf8_upgrade(cstr);
		cpv = SvPV(cstr,clen);
		sv_catpvn(dstr,cpv,clen);
		sv_2mortal(cstr);
	    }
	    else {
		sv_utf8_upgrade(dstr);
		sv_catpvn(dstr,spv,slen);
		SvUTF8_on(dstr);
	    }
	}
d3189 1
d3205 1
d3207 1
a3207 11

    /* Some magic sontains a reference loop, where the sv and object refer to
       each other.  To prevent a avoid a reference loop that would prevent such
       objects being freed, we look for such loops and if we find one we avoid
       incrementing the object refcount. */
    if (!obj || obj == sv || how == '#' || how == 'r' ||
	(SvTYPE(obj) == SVt_PVGV &&
	    (GvSV(obj) == sv || GvHV(obj) == (HV*)sv || GvAV(obj) == (AV*)sv ||
	    GvCV(obj) == (CV*)sv || GvIOp(obj) == (IO*)sv ||
	    GvFORM(obj) == (CV*)sv)))
    {
a3208 1
    }
d3210 1
a3339 8
/*
=for apidoc sv_unmagic

Removes magic from an SV.

=cut
*/

a3373 8
/*
=for apidoc sv_rvweaken

Weaken a reference.

=cut
*/

d3383 1
d3395 2
a3396 2
void
Perl_sv_add_backref(pTHX_ SV *tsv, SV *sv)
d3410 2
a3411 2
void 
Perl_sv_del_backref(pTHX_ SV *sv)
a3453 1
    (void)SvPOK_only_UTF8(bigstr);
d3524 1
a3524 7
/*
=for apidoc sv_replace

Make the first argument a copy of the second, then delete the original.

=cut
*/
d3529 1
a3552 9
/*
=for apidoc sv_clear

Clear an SV, making it empty. Does not free the memory used by the SV
itself.

=cut
*/

d3561 1
d3563 1
a3563 1
	    dSP;
a3745 8
/*
=for apidoc sv_free

Free the memory used by an SV.

=cut
*/

d3749 1
a3813 9
/*
=for apidoc sv_len_utf8

Returns the number of characters in the string in an SV, counting wide
UTF8 bytes as a single character.

=cut
*/

d3817 4
d3826 1
a3826 1
	return mg_length(sv);
d3829 6
a3834 5
    {
	STRLEN len;
	U8 *s = (U8*)SvPV(sv, len);

	return Perl_utf8_length(aTHX_ s, s + len);
d3836 1
d3882 1
a3882 1
	Perl_croak(aTHX_ "panic: sv_pos_b2u: bad byte offset");
d3886 8
a3893 8
	STRLEN n;

	if (utf8_to_uv(s, UTF8SKIP(s), &n, 0)) {
	    s += n;
	    len++;
	}
	else
	    break;
d3909 1
a3909 1
Perl_sv_eq(pTHX_ register SV *sv1, register SV *sv2)
a3914 3
    I32  eq     = 0;
    bool pv1tmp = FALSE;
    bool pv2tmp = FALSE;
d3916 1
a3916 1
    if (!sv1) {
d3921 1
a3921 1
	pv1 = SvPV(sv1, cur1);
d3923 2
a3924 4
    if (!sv2){
	pv2 = "";
	cur2 = 0;
    }
d3926 1
a3926 1
	pv2 = SvPV(sv2, cur2);
d3928 2
a3929 12
    /* do not utf8ize the comparands as a side-effect */
    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTE) {
	bool is_utf8 = TRUE;

	if (SvUTF8(sv1)) {
	    char *pv = (char*)bytes_from_utf8((U8*)pv1, &cur1, &is_utf8);

	    if ((pv1tmp = (pv != pv1)))
		pv1 = pv;
	}
	else {
	    char *pv = (char *)bytes_from_utf8((U8*)pv2, &cur2, &is_utf8);
d3931 1
a3931 14
	    if ((pv2tmp = (pv != pv2)))
		pv2 = pv;
	}
    }

    if (cur1 == cur2)
	eq = memEQ(pv1, pv2, cur1);
	
    if (pv1tmp)
	Safefree(pv1);
    if (pv2tmp)
	Safefree(pv2);

    return eq;
d3945 1
a3945 1
Perl_sv_cmp(pTHX_ register SV *sv1, register SV *sv2)
d3949 1
a3949 3
    I32  cmp; 
    bool pv1tmp = FALSE;
    bool pv2tmp = FALSE;
d3951 4
a3954 2
    if (!sv1) {
	pv1 = "";
a3956 9
    else
	pv1 = SvPV(sv1, cur1);

    if (!sv2){
	pv2 = "";
	cur2 = 0;
    }
    else
	pv2 = SvPV(sv2, cur2);
d3958 17
a3974 6
    /* do not utf8ize the comparands as a side-effect */
    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTE) {
	if (SvUTF8(sv1)) {
	    pv2 = (char*)bytes_to_utf8((U8*)pv2, &cur2);
	    pv2tmp = TRUE;
	}
d3976 1
a3976 2
	    pv1 = (char*)bytes_to_utf8((U8*)pv1, &cur1);
	    pv1tmp = TRUE;
d3979 2
a3980 15

    if (!cur1) {
	cmp = cur2 ? -1 : 0;
    } else if (!cur2) {
	cmp = 1;
    } else {
	I32 retval = memcmp((void*)pv1, (void*)pv2, cur1 < cur2 ? cur1 : cur2);

	if (retval) {
	    cmp = retval < 0 ? -1 : 1;
	} else if (cur1 == cur2) {
	    cmp = 0;
        } else {
	    cmp = cur1 < cur2 ? -1 : 1;
	}
d3983 2
a3984 4
    if (pv1tmp)
	Safefree(pv1);
    if (pv2tmp)
	Safefree(pv2);
d3986 2
a3987 2
    return cmp;
}
d3989 1
a3989 2
/*
=for apidoc sv_cmp_locale
d3991 2
a3992 2
Compares the strings in two SVs in a locale-aware manner. See
L</sv_cmp_locale>
d3994 5
a3998 2
=cut
*/
a4100 9
/*
=for apidoc sv_gets

Get a line from the filehandle and store it into the SV, optionally
appending to the currently-stored string.

=cut
*/

d4104 1
a4139 1
      SvUTF8_off(sv);
d4146 1
a4146 7
    else {
	/* Get $/ i.e. PL_rs into same encoding as stream wants */
	if (SvUTF8(PL_rs)) {
	    if (!sv_utf8_downgrade(PL_rs, TRUE)) {
		Perl_croak(aTHX_ "Wide character in $/");
	    }
	}
a4147 2
    }

a4365 2
    SvUTF8_off(sv);

d4390 1
d4498 1
d4564 1
d4586 1
d4610 1
d4776 1
d4807 1
d4890 1
a4890 1
#ifdef USE_ENVIRON_ARRAY
d4962 1
a5006 8
/*
=for apidoc sv_true

Returns true if the SV has a true value by Perl's rules.

=cut
*/

d5010 1
a5084 8
/*
=for apidoc sv_pvn_force

Get a sensible string out of the SV somehow.

=cut
*/

d5098 1
a5156 9
/*
=for apidoc sv_pvutf8n_force

Get a sensible UTF8-encoded string out of the SV somehow. See
L</sv_pvn_force>.

=cut
*/

a5163 8
/*
=for apidoc sv_reftype

Returns a string describing what the SV is a reference to.

=cut
*/

d5261 1
a5268 8
    if (SvTYPE(rv) >= SVt_PVMG) {
	U32 refcnt = SvREFCNT(rv);
	SvREFCNT(rv) = 0;
	sv_clear(rv);
	SvFLAGS(rv) = 0;
	SvREFCNT(rv) = refcnt;
    }

d5270 1
a5270 8
	sv_upgrade(rv, SVt_RV);
    else if (SvTYPE(rv) > SVt_RV) {
	(void)SvOOK_off(rv);
	if (SvPVX(rv) && SvLEN(rv))
	    Safefree(SvPVX(rv));
	SvCUR_set(rv, 0);
	SvLEN_set(rv, 0);
    }
d5386 1
d5709 1
d5766 1
a5766 1
	U8 utf8buf[UTF8_MAXLEN+1];
d5842 11
a5902 17
	if (vectorize) {
	    if (args) {
		vecsv = va_arg(*args, SV*);
		vecstr = (U8*)SvPVx(vecsv,veclen);
		utf = DO_UTF8(vecsv);
	    }
	    else if (svix < svmax) {
		vecsv = svargs[svix++];
		vecstr = (U8*)SvPVx(vecsv,veclen);
		utf = DO_UTF8(vecsv);
	    }
	    else {
		vecstr = (U8*)"";
		veclen = 0;
	    }
	}

d5906 1
a5906 1
#if defined(HAS_QUAD) || (defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE))
a5907 3
	    /* FALL THROUGH */
#endif
#ifdef HAS_QUAD
d5914 2
a5915 2
#if defined(HAS_QUAD) || (defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE))
             if (*(q + 1) == 'l') {	/* lld, llf */
a6011 2
	    if (alt)
		goto unknown;
d6029 1
a6029 1
		STRLEN ulen;
d6035 1
a6035 1
		    iv = (IV)utf8_to_uv(vecstr, veclen, &ulen, 0);
d6058 1
a6058 1
		default:	break;
d6110 1
a6110 1
		STRLEN ulen;
d6117 1
a6117 1
		    uv = utf8_to_uv(vecstr, veclen, &ulen, 0);
d6140 1
a6140 1
		default:	break;
d6255 1
a6255 1
#if defined(USE_LONG_DOUBLE) && defined(PERL_PRIfldbl)
d6257 3
a6259 6
		/* Copy the one or more characters in a long double
		 * format before the 'base' ([efgEFG]) character to
		 * the format string. */
		static char const prifldbl[] = PERL_PRIfldbl;
		char const *p = prifldbl + sizeof(prifldbl) - 3;
		while (p >= prifldbl) { *--eptr = *p--; }
d6281 5
a6285 4
	    /* No taint.  Otherwise we are in the strange situation
	     * where printf() taints but print($float) doesn't.
	     * --jhi */
	    (void)sprintf(PL_efloatbuf, eptr, nv);
d6308 1
a6308 1
		sv_setuv_mg(svargs[svix++], (UV)i);
d6492 2
a6493 2
    MAGIC *mgprev = (MAGIC*)NULL;
    MAGIC *mgret;
d6504 3
a6506 1
	if (mgprev)
a6507 2
	else
	    mgret = nmg;
a6625 45
void
Perl_ptr_table_clear(pTHX_ PTR_TBL_t *tbl)
{
    register PTR_TBL_ENT_t **array;
    register PTR_TBL_ENT_t *entry;
    register PTR_TBL_ENT_t *oentry = Null(PTR_TBL_ENT_t*);
    UV riter = 0;
    UV max;

    if (!tbl || !tbl->tbl_items) {
        return;
    }

    array = tbl->tbl_ary;
    entry = array[0];
    max = tbl->tbl_max;

    for (;;) {
        if (entry) {
            oentry = entry;
            entry = entry->next;
            Safefree(oentry);
        }
        if (!entry) {
            if (++riter > max) {
                break;
            }
            entry = array[riter];
        }
    }

    tbl->tbl_items = 0;
}

void
Perl_ptr_table_free(pTHX_ PTR_TBL_t *tbl)
{
    if (!tbl) {
        return;
    }
    ptr_table_clear(tbl);
    Safefree(tbl->tbl_ary);
    Safefree(tbl);
}

d6909 1
a6909 1
	CvGV(dstr)	= gv_dup(CvGV(sstr));
d6920 1
a6920 4
	if (!CvANON(sstr) || CvCLONED(sstr))
	    CvOUTSIDE(dstr)	= cv_dup_inc(CvOUTSIDE(sstr));
	else
	    CvOUTSIDE(dstr)	= cv_dup(CvOUTSIDE(sstr));
d6974 1
a6974 1
		ncx->blk_sub.savearray	= av_dup_inc(cx->blk_sub.savearray);
a7128 6
	case SAVEt_GENERIC_PVREF:		/* generic char* */
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    break;
a7221 1
	case SAVEt_MORTALIZESV:
a7313 8
	case SAVEt_PADSV:
	    longval = (long)POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv);
	    break;
a7406 1
    PL_xnv_arenaroot	= NULL;
a7407 1
    PL_xrv_arenaroot	= NULL;
a7408 1
    PL_xpv_arenaroot	= NULL;
a7409 1
    PL_xpviv_arenaroot	= NULL;
a7410 1
    PL_xpvnv_arenaroot	= NULL;
a7411 1
    PL_xpvcv_arenaroot	= NULL;
a7412 1
    PL_xpvav_arenaroot	= NULL;
a7413 1
    PL_xpvhv_arenaroot	= NULL;
a7414 1
    PL_xpvmg_arenaroot	= NULL;
a7415 1
    PL_xpvlv_arenaroot	= NULL;
a7416 1
    PL_xpvbm_arenaroot	= NULL;
a7417 1
    PL_he_arenaroot	= NULL;
d7531 1
a7531 1
    PL_argvout_stack	= av_dup_inc(proto_perl->Iargvout_stack);
d7743 1
a7743 1
    PL_numeric_radix_sv	= sv_dup_inc(proto_perl->Inumeric_radix_sv);
d7801 1
a7801 1
    if (flags & CLONEf_COPY_STACKS) {
a7858 1
	ENTER;			/* perl_destruct() wants to LEAVE; */
a7986 5
    if (!(flags & CLONEf_KEEP_PTR_TABLE)) {
        ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;
    }

d8018 3
a8020 9
	if (SvWEAKREF(sv)) {
	    sv_del_backref(sv);
	    SvWEAKREF_off(sv);
	    SvRV(sv) = 0;
	} else {
	    SvROK_off(sv);
	    SvRV(sv) = 0;
	    SvREFCNT_dec(rv);
	}
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d8 3
a11 8
 *
 *
 * This file contains the code that creates, manipulates and destroys
 * scalar values (SVs). The other types (AV, HV, GV, etc.) reuse the
 * structure of an SV, so their creation and destruction is handled
 * here; higher-level functions are in av.c, hv.c, and so on. Opcode
 * level functions (eg. substr, split, join) for each of the types are
 * in the pp*.c files.
a16 1
#include "regcomp.h"
d21 6
a26 107

/* ============================================================================

=head1 Allocation and deallocation of SVs.

An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv,
av, hv...) contains type and reference count information, as well as a
pointer to the body (struct xrv, xpv, xpviv...), which contains fields
specific to each type.

Normally, this allocation is done using arenas, which are approximately
1K chunks of memory parcelled up into N heads or bodies. The first slot
in each arena is reserved, and is used to hold a link to the next arena.
In the case of heads, the unused first slot also contains some flags and
a note of the number of slots.  Snaked through each arena chain is a
linked list of free items; when this becomes empty, an extra arena is
allocated and divided up into N items which are threaded into the free
list.

The following global variables are associated with arenas:

    PL_sv_arenaroot	pointer to list of SV arenas
    PL_sv_root		pointer to list of free SV structures

    PL_foo_arenaroot	pointer to list of foo arenas,
    PL_foo_root		pointer to list of free foo bodies
			    ... for foo in xiv, xnv, xrv, xpv etc.

Note that some of the larger and more rarely used body types (eg xpvio)
are not allocated using arenas, but are instead just malloc()/free()ed as
required. Also, if PURIFY is defined, arenas are abandoned altogether,
with all items individually malloc()ed. In addition, a few SV heads are
not allocated from an arena, but are instead directly created as static
or auto variables, eg PL_sv_undef.

The SV arena serves the secondary purpose of allowing still-live SVs
to be located and destroyed during final cleanup.

At the lowest level, the macros new_SV() and del_SV() grab and free
an SV head.  (If debugging with -DD, del_SV() calls the function S_del_sv()
to return the SV to the free list with error checking.) new_SV() calls
more_sv() / sv_add_arena() to add an extra arena if the free list is empty.
SVs in the free list have their SvTYPE field set to all ones.

Similarly, there are macros new_XIV()/del_XIV(), new_XNV()/del_XNV() etc
that allocate and return individual body types. Normally these are mapped
to the arena-manipulating functions new_xiv()/del_xiv() etc, but may be
instead mapped directly to malloc()/free() if PURIFY is defined. The
new/del functions remove from, or add to, the appropriate PL_foo_root
list, and call more_xiv() etc to add a new arena if the list is empty.

At the time of very final cleanup, sv_free_arenas() is called from
perl_destruct() to physically free all the arenas allocated since the
start of the interpreter.  Note that this also clears PL_he_arenaroot,
which is otherwise dealt with in hv.c.

Manipulation of any of the PL_*root pointers is protected by enclosing
LOCK_SV_MUTEX; ... UNLOCK_SV_MUTEX calls which should Do the Right Thing
if threads are enabled.

The function visit() scans the SV arenas list, and calls a specified
function for each SV it finds which is still live - ie which has an SvTYPE
other than all 1's, and a non-zero SvREFCNT. visit() is used by the
following functions (specified as [function that calls visit()] / [function
called by visit() for each SV]):

    sv_report_used() / do_report_used()
    			dump all remaining SVs (debugging aid)

    sv_clean_objs() / do_clean_objs(),do_clean_named_objs()
			Attempt to free all objects pointed to by RVs,
			and, unless DISABLE_DESTRUCTOR_KLUDGE is defined,
			try to do the same for all objects indirectly
			referenced by typeglobs too.  Called once from
			perl_destruct(), prior to calling sv_clean_all()
			below.

    sv_clean_all() / do_clean_all()
			SvREFCNT_dec(sv) each remaining SV, possibly
			triggering an sv_free(). It also sets the
			SVf_BREAK flag on the SV to indicate that the
			refcnt has been artificially lowered, and thus
			stopping sv_free() from giving spurious warnings
			about SVs which unexpectedly have a refcnt
			of zero.  called repeatedly from perl_destruct()
			until there are no SVs left.

=head2 Summary

Private API to rest of sv.c

    new_SV(),  del_SV(),

    new_XIV(), del_XIV(),
    new_XNV(), del_XNV(),
    etc

Public API:

    sv_report_used(), sv_clean_objs(), sv_clean_all(), sv_free_arenas()


=cut

============================================================================ */


a47 3

/* new_SV(): return a new, empty SV head */

a60 3

/* del_SV(): return an empty SV head to the free list */

d66 1
a66 1
	if (DEBUG_D_TEST)				\
d76 1
a76 1
    if (DEBUG_D_TEST) {
d89 1
a89 1
	        Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
a103 12

/*
=head1 SV Manipulation Functions

=for apidoc sv_add_arena

Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.

=cut
*/

a130 2
/* make some more SVs by adding another arena */

a139 1
        PL_nice_chunk_size = 0;
a149 2
/* visit(): call the named function for each non-free SV in the arenas. */

d162 1
a162 1
		(FCALL)(aTHX_ sv);
a169 22
#ifdef DEBUGGING

/* called by sv_report_used() for each live SV */

static void
do_report_used(pTHX_ SV *sv)
{
    if (SvTYPE(sv) != SVTYPEMASK) {
	PerlIO_printf(Perl_debug_log, "****\n");
	sv_dump(sv);
    }
}
#endif

/*
=for apidoc sv_report_used

Dump the contents of all SVs not yet freed. (Debugging aid).

=cut
*/

a172 1
#ifdef DEBUGGING
a173 43
#endif
}

/* called by sv_clean_objs() for each live SV */

static void
do_clean_objs(pTHX_ SV *sv)
{
    SV* rv;

    if (SvROK(sv) && SvOBJECT(rv = SvRV(sv))) {
	DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(sv)));
	if (SvWEAKREF(sv)) {
	    sv_del_backref(sv);
	    SvWEAKREF_off(sv);
	    SvRV(sv) = 0;
	} else {
	    SvROK_off(sv);
	    SvRV(sv) = 0;
	    SvREFCNT_dec(rv);
	}
    }

    /* XXX Might want to check arrays, etc. */
}

/* called by sv_clean_objs() for each live SV */

#ifndef DISABLE_DESTRUCTOR_KLUDGE
static void
do_clean_named_objs(pTHX_ SV *sv)
{
    if (SvTYPE(sv) == SVt_PVGV && GvGP(sv)) {
	if ( SvOBJECT(GvSV(sv)) ||
	     (GvAV(sv) && SvOBJECT(GvAV(sv))) ||
	     (GvHV(sv) && SvOBJECT(GvHV(sv))) ||
	     (GvIO(sv) && SvOBJECT(GvIO(sv))) ||
	     (GvCV(sv) && SvOBJECT(GvCV(sv))) )
	{
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning named glob object:\n "), sv_dump(sv)));
	    SvREFCNT_dec(sv);
	}
    }
a174 9
#endif

/*
=for apidoc sv_clean_objs

Attempt to destroy all objects not yet freed

=cut
*/
a187 20
/* called by sv_clean_all() for each live SV */

static void
do_clean_all(pTHX_ SV *sv)
{
    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning loops: SV at 0x%"UVxf"\n", PTR2UV(sv)) ));
    SvFLAGS(sv) |= SVf_BREAK;
    SvREFCNT_dec(sv);
}

/*
=for apidoc sv_clean_all

Decrement the refcnt of each remaining SV, possibly triggering a
cleanup. This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.

=cut
*/

a197 9
/*
=for apidoc sv_free_arenas

Deallocate the memory used by all arenas. Note that all the individual SV
heads and bodies within the arenas must already have been freed.

=cut
*/

a302 8
/*
=for apidoc report_uninit

Print appropriate "Use of uninitialized variable" warning

=cut
*/

d307 2
a308 2
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
		    " in ", OP_DESC(PL_op));
d310 1
a310 1
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit, "", "");
a312 2
/* grab a new IV body from the free list, allocating more if necessary */

a328 2
/* return an IV body to the free list */

a338 2
/* allocate another arena's worth of IV bodies */

d346 1
a346 1
    ptr->xpv_pv = (char*)PL_xiv_arenaroot;	/* linked list of xiv arenas */
d351 1
a351 1
    xiv += (sizeof(XPV) - 1) / sizeof(IV) + 1;	/* fudge by size of XPV */
a359 2
/* grab a new NV body from the free list, allocating more if necessary */

a372 2
/* return an NV body to the free list */

a382 2
/* allocate another arena's worth of NV bodies */

a403 2
/* grab a new struct xrv from the free list, allocating more if necessary */

a416 2
/* return a struct xrv to the free list */

a425 2
/* allocate another arena's worth of struct xrv */

a446 2
/* grab a new struct xpv from the free list, allocating more if necessary */

a459 2
/* return a struct xpv to the free list */

a468 2
/* allocate another arena's worth of struct xpv */

a486 2
/* grab a new struct xpviv from the free list, allocating more if necessary */

a499 2
/* return a struct xpviv to the free list */

a508 2
/* allocate another arena's worth of struct xpviv */

a526 2
/* grab a new struct xpvnv from the free list, allocating more if necessary */

a539 2
/* return a struct xpvnv to the free list */

a548 2
/* allocate another arena's worth of struct xpvnv */

a566 2
/* grab a new struct xpvcv from the free list, allocating more if necessary */

a579 2
/* return a struct xpvcv to the free list */

a588 2
/* allocate another arena's worth of struct xpvcv */

a606 2
/* grab a new struct xpvav from the free list, allocating more if necessary */

a619 2
/* return a struct xpvav to the free list */

a628 2
/* allocate another arena's worth of struct xpvav */

a646 2
/* grab a new struct xpvhv from the free list, allocating more if necessary */

a659 2
/* return a struct xpvhv to the free list */

a668 2
/* allocate another arena's worth of struct xpvhv */

a686 2
/* grab a new struct xpvmg from the free list, allocating more if necessary */

a699 2
/* return a struct xpvmg to the free list */

a708 2
/* allocate another arena's worth of struct xpvmg */

a726 2
/* grab a new struct xpvlv from the free list, allocating more if necessary */

a739 2
/* return a struct xpvlv to the free list */

a748 2
/* allocate another arena's worth of struct xpvlv */

a766 2
/* grab a new struct xpvbm from the free list, allocating more if necessary */

a779 2
/* return a struct xpvbm to the free list */

a788 2
/* allocate another arena's worth of struct xpvbm */

d843 1
a843 1

d881 1
a881 1

d895 1
a895 1

d898 1
a898 1

d905 2
a906 3
Upgrade an SV to a more complex form.  Generally adds a new body type to the
SV, then copies across as much information as possible from the old body.
You generally want to use the C<SvUPGRADE> macro wrapper. See also C<svtype>.
d914 7
a920 11
    char*	pv = NULL;
    U32		cur = 0;
    U32		len = 0;
    IV		iv = 0;
    NV		nv = 0.0;
    MAGIC*	magic = NULL;
    HV*		stash = Nullhv;

    if (mt != SVt_PV && SvREADONLY(sv) && SvFAKE(sv)) {
	sv_force_normal(sv);
    }
d1108 2
a1109 2
	HvTOTALKEYS(sv)	= 0;
	HvPLACEHOLDERS(sv) = 0;
a1184 9
/*
=for apidoc sv_backoff

Remove any string offset. You should normally use the C<SvOOK_off> macro
wrapper instead.

=cut
*/

d1203 3
a1205 3
Expands the character buffer in the SV.  If necessary, uses C<sv_unref> and
upgrades the SV to C<SVt_PV>.  Returns a pointer to the character buffer.
Use the C<SvGROW> wrapper instead.
a1214 2


a1239 1

d1251 2
a1252 12
        else {
	    /* sv_force_normal_flags() must not try to unshare the new
	       PVX we allocate below. AMS 20010713 */
	    if (SvREADONLY(sv) && SvFAKE(sv)) {
		SvFAKE_off(sv);
		SvREADONLY_off(sv);
	    }
	    New(703, s, newlen, char);
	    if (SvPVX(sv) && SvCUR(sv)) {
	        Move(SvPVX(sv), s, (newlen < SvCUR(sv)) ? newlen : SvCUR(sv), char);
	    }
	}
d1262 2
a1263 2
Copies an integer into the given SV, upgrading first if necessary.
Does not handle 'set' magic.  See also C<sv_setiv_mg>.
d1291 1
a1291 1
		   OP_DESC(PL_op));
d1316 2
a1317 2
Copies an unsigned integer into the given SV, upgrading first if necessary.
Does not handle 'set' magic.  See also C<sv_setuv_mg>.
a1324 12
    /* With these two if statements:
       u=1.49  s=0.52  cu=72.49  cs=10.64  scripts=270  tests=20865

       without
       u=1.35  s=0.47  cu=73.45  cs=11.43  scripts=270  tests=20865

       If you wish to remove them, please benchmark to see what the effect is
    */
    if (u <= (UV)IV_MAX) {
       sv_setiv(sv, (IV)u);
       return;
    }
d1341 1
a1341 15
    /* With these two if statements:
       u=1.49  s=0.52  cu=72.49  cs=10.64  scripts=270  tests=20865

       without
       u=1.35  s=0.47  cu=73.45  cs=11.43  scripts=270  tests=20865

       If you wish to remove them, please benchmark to see what the effect is
    */
    if (u <= (UV)IV_MAX) {
       sv_setiv(sv, (IV)u);
    } else {
       sv_setiv(sv, 0);
       SvIsUV_on(sv);
       sv_setuv(sv,u);
    }
d1348 2
a1349 2
Copies a double into the given SV, upgrading first if necessary.
Does not handle 'set' magic.  See also C<sv_setnv_mg>.
d1376 1
a1376 1
		   OP_NAME(PL_op));
a1397 4
/* Print an "isn't numeric" warning, using a cleaned-up,
 * printable version of the offending string
 */

d1401 41
a1441 55
     SV *dsv;
     char tmpbuf[64];
     char *pv;

     if (DO_UTF8(sv)) {
          dsv = sv_2mortal(newSVpv("", 0));
          pv = sv_uni_display(dsv, sv, 10, 0);
     } else {
	  char *d = tmpbuf;
	  char *limit = tmpbuf + sizeof(tmpbuf) - 8;
	  /* each *s can expand to 4 chars + "...\0",
	     i.e. need room for 8 chars */
	
	  char *s, *end;
	  for (s = SvPVX(sv), end = s + SvCUR(sv); s < end && d < limit; s++) {
	       int ch = *s & 0xFF;
	       if (ch & 128 && !isPRINT_LC(ch)) {
		    *d++ = 'M';
		    *d++ = '-';
		    ch &= 127;
	       }
	       if (ch == '\n') {
		    *d++ = '\\';
		    *d++ = 'n';
	       }
	       else if (ch == '\r') {
		    *d++ = '\\';
		    *d++ = 'r';
	       }
	       else if (ch == '\f') {
		    *d++ = '\\';
		    *d++ = 'f';
	       }
	       else if (ch == '\\') {
		    *d++ = '\\';
		    *d++ = '\\';
	       }
	       else if (ch == '\0') {
		    *d++ = '\\';
		    *d++ = '0';
	       }
	       else if (isPRINT_LC(ch))
		    *d++ = ch;
	       else {
		    *d++ = '^';
		    *d++ = toCTRL(ch);
	       }
	  }
	  if (s < end) {
	       *d++ = '.';
	       *d++ = '.';
	       *d++ = '.';
	  }
	  *d = '\0';
	  pv = tmpbuf;
d1443 1
d1446 3
a1448 3
	Perl_warner(aTHX_ packWARN(WARN_NUMERIC),
		    "Argument \"%s\" isn't numeric in %s", pv,
		    OP_DESC(PL_op));
d1450 2
a1451 2
	Perl_warner(aTHX_ packWARN(WARN_NUMERIC),
		    "Argument \"%s\" isn't numeric", pv);
d1454 6
a1459 26
/*
=for apidoc looks_like_number

Test if the content of an SV looks like a number (or is a number).
C<Inf> and C<Infinity> are treated as numbers (so will not issue a
non-numeric warning), even if your atof() doesn't grok them.

=cut
*/

I32
Perl_looks_like_number(pTHX_ SV *sv)
{
    register char *sbegin;
    STRLEN len;

    if (SvPOK(sv)) {
	sbegin = SvPVX(sv);
	len = SvCUR(sv);
    }
    else if (SvPOKp(sv))
	sbegin = SvPV(sv, len);
    else
	return 1; /* Historic.  Wrong?  */
    return grok_number(sbegin, len, NULL);
}
a1463 137
/*
   NV_PRESERVES_UV:

   As 64 bit platforms often have an NV that doesn't preserve all bits of
   an IV (an assumption perl has been based on to date) it becomes necessary
   to remove the assumption that the NV always carries enough precision to
   recreate the IV whenever needed, and that the NV is the canonical form.
   Instead, IV/UV and NV need to be given equal rights. So as to not lose
   precision as a side effect of conversion (which would lead to insanity
   and the dragon(s) in t/op/numconvert.t getting very angry) the intent is
   1) to distinguish between IV/UV/NV slots that have cached a valid
      conversion where precision was lost and IV/UV/NV slots that have a
      valid conversion which has lost no precision
   2) to ensure that if a numeric conversion to one form is requested that
      would lose precision, the precise conversion (or differently
      imprecise conversion) is also performed and cached, to prevent
      requests for different numeric formats on the same SV causing
      lossy conversion chains. (lossless conversion chains are perfectly
      acceptable (still))


   flags are used:
   SvIOKp is true if the IV slot contains a valid value
   SvIOK  is true only if the IV value is accurate (UV if SvIOK_UV true)
   SvNOKp is true if the NV slot contains a valid value
   SvNOK  is true only if the NV value is accurate

   so
   while converting from PV to NV, check to see if converting that NV to an
   IV(or UV) would lose accuracy over a direct conversion from PV to
   IV(or UV). If it would, cache both conversions, return NV, but mark
   SV as IOK NOKp (ie not NOK).

   While converting from PV to IV, check to see if converting that IV to an
   NV would lose accuracy over a direct conversion from PV to NV. If it
   would, cache both conversions, flag similarly.

   Before, the SV value "3.2" could become NV=3.2 IV=3 NOK, IOK quite
   correctly because if IV & NV were set NV *always* overruled.
   Now, "3.2" will become NV=3.2 IV=3 NOK, IOKp, because the flag's meaning
   changes - now IV and NV together means that the two are interchangeable:
   SvIVX == (IV) SvNVX && SvNVX == (NV) SvIVX;

   The benefit of this is that operations such as pp_add know that if
   SvIOK is true for both left and right operands, then integer addition
   can be used instead of floating point (for cases where the result won't
   overflow). Before, floating point was always used, which could lead to
   loss of precision compared with integer addition.

   * making IV and NV equal status should make maths accurate on 64 bit
     platforms
   * may speed up maths somewhat if pp_add and friends start to use
     integers when possible instead of fp. (Hopefully the overhead in
     looking for SvIOK and checking for overflow will not outweigh the
     fp to integer speedup)
   * will slow down integer operations (callers of SvIV) on "inaccurate"
     values, as the change from SvIOK to SvIOKp will cause a call into
     sv_2iv each time rather than a macro access direct to the IV slot
   * should speed up number->string conversion on integers as IV is
     favoured when IV and NV are equally accurate

   ####################################################################
   You had better be using SvIOK_notUV if you want an IV for arithmetic:
   SvIOK is true if (IV or UV), so you might be getting (IV)SvUV.
   On the other hand, SvUOK is true iff UV.
   ####################################################################

   Your mileage will vary depending your CPU's relative fp to integer
   performance ratio.
*/

#ifndef NV_PRESERVES_UV
#  define IS_NUMBER_UNDERFLOW_IV 1
#  define IS_NUMBER_UNDERFLOW_UV 2
#  define IS_NUMBER_IV_AND_UV    2
#  define IS_NUMBER_OVERFLOW_IV  4
#  define IS_NUMBER_OVERFLOW_UV  5

/* sv_2iuv_non_preserve(): private routine for use by sv_2iv() and sv_2uv() */

/* For sv_2nv these three cases are "SvNOK and don't bother casting"  */
STATIC int
S_sv_2iuv_non_preserve(pTHX_ register SV *sv, I32 numtype)
{
    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_2iuv_non '%s', IV=0x%"UVxf" NV=%"NVgf" inttype=%"UVXf"\n", SvPVX(sv), SvIVX(sv), SvNVX(sv), (UV)numtype));
    if (SvNVX(sv) < (NV)IV_MIN) {
	(void)SvIOKp_on(sv);
	(void)SvNOK_on(sv);
	SvIVX(sv) = IV_MIN;
	return IS_NUMBER_UNDERFLOW_IV;
    }
    if (SvNVX(sv) > (NV)UV_MAX) {
	(void)SvIOKp_on(sv);
	(void)SvNOK_on(sv);
	SvIsUV_on(sv);
	SvUVX(sv) = UV_MAX;
	return IS_NUMBER_OVERFLOW_UV;
    }
    (void)SvIOKp_on(sv);
    (void)SvNOK_on(sv);
    /* Can't use strtol etc to convert this string.  (See truth table in
       sv_2iv  */
    if (SvNVX(sv) <= (UV)IV_MAX) {
        SvIVX(sv) = I_V(SvNVX(sv));
        if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
            SvIOK_on(sv); /* Integer is precise. NOK, IOK */
        } else {
            /* Integer is imprecise. NOK, IOKp */
        }
        return SvNVX(sv) < 0 ? IS_NUMBER_UNDERFLOW_UV : IS_NUMBER_IV_AND_UV;
    }
    SvIsUV_on(sv);
    SvUVX(sv) = U_V(SvNVX(sv));
    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
        if (SvUVX(sv) == UV_MAX) {
            /* As we know that NVs don't preserve UVs, UV_MAX cannot
               possibly be preserved by NV. Hence, it must be overflow.
               NOK, IOKp */
            return IS_NUMBER_OVERFLOW_UV;
        }
        SvIOK_on(sv); /* Integer is precise. NOK, UOK */
    } else {
        /* Integer is imprecise. NOK, IOKp */
    }
    return IS_NUMBER_OVERFLOW_IV;
}
#endif /* !NV_PRESERVES_UV*/

/*
=for apidoc sv_2iv

Return the integer value of an SV, doing any necessary string conversion,
magic etc. Normally used via the C<SvIV(sv)> and C<SvIVx(sv)> macros.

=cut
*/

d1490 1
a1490 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
a1493 3
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
	}
d1509 4
a1512 4
	/* erm. not sure. *should* never get NOKp (without NOK) from sv_2nv
	 * without also getting a cached IV/UV from it at the same time
	 * (ie PV->NV conversion should detect loss of accuracy and cache
	 * IV or UV at same time to avoid this.  NWC */
d1517 2
a1518 6
	(void)SvIOKp_on(sv);	/* Must do this first, to clear any SvOOK */
	/* < not <= as for NV doesn't preserve UV, ((NV)IV_MAX+1) will almost
	   certainly cast into the IV range at IV_MAX, whereas the correct
	   answer is the UV IV_MAX +1. Hence < ensures that dodgy boundary
	   cases go to UV */
	if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
a1519 36
	    if (SvNVX(sv) == (NV) SvIVX(sv)
#ifndef NV_PRESERVES_UV
		&& (((UV)1 << NV_PRESERVES_UV_BITS) >
		    (UV)(SvIVX(sv) > 0 ? SvIVX(sv) : -SvIVX(sv)))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		) {
		SvIOK_on(sv);  /* Can this go wrong with rounding? NWC */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" iv(%"NVgf" => %"IVdf") (precise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));

	    } else {
		/* IV not precise.  No need to convert from PV, as NV
		   conversion would already have cached IV if it detected
		   that PV->IV would be better than PV->NV->IV
		   flags already correct - don't set public IOK.  */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" iv(%"NVgf" => %"IVdf") (imprecise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));
	    }
	    /* Can the above go wrong if SvIVX == IV_MIN and SvNVX < IV_MIN,
	       but the cast (NV)IV_MIN rounds to a the value less (more
	       negative) than IV_MIN which happens to be equal to SvNVX ??
	       Analogous to 0xFFFFFFFFFFFFFFFF rounding up to NV (2**64) and
	       NV rounding back to 0xFFFFFFFFFFFFFFFF, so UVX == UV(NVX) and
	       (NV)UVX == NVX are both true, but the values differ. :-(
	       Hopefully for 2s complement IV_MIN is something like
	       0x8000000000000000 which will be exact. NWC */
	}
a1521 12
	    if (
		(SvNVX(sv) == (NV) SvUVX(sv))
#ifndef  NV_PRESERVES_UV
		/* Make sure it's not 0xFFFFFFFFFFFFFFFF */
		/*&& (SvUVX(sv) != UV_MAX) irrelevant with code below */
		&& (((UV)1 << NV_PRESERVES_UV_BITS) > SvUVX(sv))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		)
		SvIOK_on(sv);
d1524 1
a1524 1
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
d1533 2
a1534 2
	UV value;
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d1537 2
a1538 5
	   the same as the direct translation of the initial string
	   (eg 123.456 can shortcut to the IV 123 with atol(), but we must
	   be careful to ensure that the value with the .456 is around if the
	   NV value is requested in the future).
	
d1541 1
a1541 1
	   cache the NV if we are sure it's not needed.
d1543 29
a1571 5

	/* SVt_PVNV is one higher than SVt_PVIV, hence this order  */
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	     == IS_NUMBER_IN_UV) {
	    /* It's definitely an integer, only upgrade to PVIV */
d1575 1
a1575 49
	} else if (SvTYPE(sv) < SVt_PVNV)
	    sv_upgrade(sv, SVt_PVNV);

	/* If NV preserves UV then we only use the UV value if we know that
	   we aren't going to call atof() below. If NVs don't preserve UVs
	   then the value returned may have more precision than atof() will
	   return, even though value isn't perfectly accurate.  */
	if ((numtype & (IS_NUMBER_IN_UV
#ifdef NV_PRESERVES_UV
			| IS_NUMBER_NOT_INT
#endif
	    )) == IS_NUMBER_IN_UV) {
	    /* This won't turn off the public IOK flag if it was set above  */
	    (void)SvIOKp_on(sv);

	    if (!(numtype & IS_NUMBER_NEG)) {
		/* positive */;
		if (value <= (UV)IV_MAX) {
		    SvIVX(sv) = (IV)value;
		} else {
		    SvUVX(sv) = value;
		    SvIsUV_on(sv);
		}
	    } else {
		/* 2s complement assumption  */
		if (value <= (UV)IV_MIN) {
		    SvIVX(sv) = -(IV)value;
		} else {
		    /* Too negative for an IV.  This is a double upgrade, but
		       I'm assuming it will be rare.  */
		    if (SvTYPE(sv) < SVt_PVNV)
			sv_upgrade(sv, SVt_PVNV);
		    SvNOK_on(sv);
		    SvIOK_off(sv);
		    SvIOKp_on(sv);
		    SvNVX(sv) = -(NV)value;
		    SvIVX(sv) = IV_MIN;
		}
	    }
	}
	/* For !NV_PRESERVES_UV and IS_NUMBER_IN_UV and IS_NUMBER_NOT_INT we
           will be in the previous block to set the IV slot, and the next
           block to set the NV slot.  So no else here.  */
	
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	    != IS_NUMBER_IN_UV) {
	    /* It wasn't an (integer that doesn't overflow the UV). */
	    SvNVX(sv) = Atof(SvPVX(sv));

a1577 78

#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%" PERL_PRIgldbl ")\n",
				  PTR2UV(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%"NVgf")\n",
				  PTR2UV(sv), SvNVX(sv)));
#endif


#ifdef NV_PRESERVES_UV
	    (void)SvIOKp_on(sv);
	    (void)SvNOK_on(sv);
	    if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
		SvIVX(sv) = I_V(SvNVX(sv));
		if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
		    SvIOK_on(sv);
		} else {
		    /* Integer is imprecise. NOK, IOKp */
		}
		/* UV will not work better than IV */
	    } else {
		if (SvNVX(sv) > (NV)UV_MAX) {
		    SvIsUV_on(sv);
		    /* Integer is inaccurate. NOK, IOKp, is UV */
		    SvUVX(sv) = UV_MAX;
		    SvIsUV_on(sv);
		} else {
		    SvUVX(sv) = U_V(SvNVX(sv));
		    /* 0xFFFFFFFFFFFFFFFF not an issue in here */
		    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
			SvIOK_on(sv);
			SvIsUV_on(sv);
		    } else {
			/* Integer is imprecise. NOK, IOKp, is UV */
			SvIsUV_on(sv);
		    }
		}
		goto ret_iv_max;
	    }
#else /* NV_PRESERVES_UV */
            if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
                == (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT)) {
                /* The IV slot will have been set from value returned by
                   grok_number above.  The NV slot has just been set using
                   Atof.  */
	        SvNOK_on(sv);
                assert (SvIOKp(sv));
            } else {
                if (((UV)1 << NV_PRESERVES_UV_BITS) >
                    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
                    /* Small enough to preserve all bits. */
                    (void)SvIOKp_on(sv);
                    SvNOK_on(sv);
                    SvIVX(sv) = I_V(SvNVX(sv));
                    if ((NV)(SvIVX(sv)) == SvNVX(sv))
                        SvIOK_on(sv);
                    /* Assumption: first non-preserved integer is < IV_MAX,
                       this NV is in the preserved range, therefore: */
                    if (!(U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))
                          < (UV)IV_MAX)) {
                        Perl_croak(aTHX_ "sv_2iv assumed (U_V(fabs(SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
                    }
                } else {
                    /* IN_UV NOT_INT
                         0      0	already failed to read UV.
                         0      1       already failed to read UV.
                         1      0       you won't get here in this case. IV/UV
                         	        slot set, public IOK, Atof() unneeded.
                         1      1       already read UV.
                       so there's no point in sv_2iuv_non_preserve() attempting
                       to use atol, strtol, strtoul etc.  */
                    if (sv_2iuv_non_preserve (sv, numtype)
                        >= IS_NUMBER_OVERFLOW_IV)
                    goto ret_iv_max;
                }
            }
#endif /* NV_PRESERVES_UV */
d1579 2
a1580 1
    } else  {
a1592 10
/*
=for apidoc sv_2uv

Return the unsigned integer value of an SV, doing any necessary string
conversion, magic etc. Normally used via the C<SvUV(sv)> and C<SvUVx(sv)>
macros.

=cut
*/

d1618 1
a1618 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
a1621 3
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
	}
d1637 4
a1640 6
	/* erm. not sure. *should* never get NOKp (without NOK) from sv_2nv
	 * without also getting a cached IV/UV from it at the same time
	 * (ie PV->NV conversion should detect loss of accuracy and cache
	 * IV or UV at same time to avoid this. */
	/* IV-over-UV optimisation - choose to cache IV if possible */

d1643 4
a1646 39

	(void)SvIOKp_on(sv);	/* Must do this first, to clear any SvOOK */
	if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
	    SvIVX(sv) = I_V(SvNVX(sv));
	    if (SvNVX(sv) == (NV) SvIVX(sv)
#ifndef NV_PRESERVES_UV
		&& (((UV)1 << NV_PRESERVES_UV_BITS) >
		    (UV)(SvIVX(sv) > 0 ? SvIVX(sv) : -SvIVX(sv)))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		) {
		SvIOK_on(sv);  /* Can this go wrong with rounding? NWC */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" uv(%"NVgf" => %"IVdf") (precise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));

	    } else {
		/* IV not precise.  No need to convert from PV, as NV
		   conversion would already have cached IV if it detected
		   that PV->IV would be better than PV->NV->IV
		   flags already correct - don't set public IOK.  */
		DEBUG_c(PerlIO_printf(Perl_debug_log,
				      "0x%"UVxf" uv(%"NVgf" => %"IVdf") (imprecise)\n",
				      PTR2UV(sv),
				      SvNVX(sv),
				      SvIVX(sv)));
	    }
	    /* Can the above go wrong if SvIVX == IV_MIN and SvNVX < IV_MIN,
	       but the cast (NV)IV_MIN rounds to a the value less (more
	       negative) than IV_MIN which happens to be equal to SvNVX ??
	       Analogous to 0xFFFFFFFFFFFFFFFF rounding up to NV (2**64) and
	       NV rounding back to 0xFFFFFFFFFFFFFFFF, so UVX == UV(NVX) and
	       (NV)UVX == NVX are both true, but the values differ. :-(
	       Hopefully for 2s complement IV_MIN is something like
	       0x8000000000000000 which will be exact. NWC */
d1649 4
a1652 16
	    SvUVX(sv) = U_V(SvNVX(sv));
	    if (
		(SvNVX(sv) == (NV) SvUVX(sv))
#ifndef  NV_PRESERVES_UV
		/* Make sure it's not 0xFFFFFFFFFFFFFFFF */
		/*&& (SvUVX(sv) != UV_MAX) irrelevant with code below */
		&& (((UV)1 << NV_PRESERVES_UV_BITS) > SvUVX(sv))
		/* Don't flag it as "accurately an integer" if the number
		   came from a (by definition imprecise) NV operation, and
		   we're outside the range of NV integer precision */
#endif
		)
		SvIOK_on(sv);
	    SvIsUV_on(sv);
	    DEBUG_c(PerlIO_printf(Perl_debug_log,
				  "0x%"UVxf" 2uv(%"UVuf" => %"IVdf") (as unsigned)\n",
d1654 3
a1656 2
				  SvUVX(sv),
				  SvUVX(sv)));
d1660 1
a1660 2
	UV value;
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d1665 1
a1665 1
	
d1670 11
a1680 7

	/* SVt_PVNV is one higher than SVt_PVIV, hence this order  */
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	     == IS_NUMBER_IN_UV) {
	    /* It's definitely an integer, only upgrade to PVIV */
	    if (SvTYPE(sv) < SVt_PVIV)
		sv_upgrade(sv, SVt_PVIV);
d1682 12
a1693 24
	} else if (SvTYPE(sv) < SVt_PVNV)
	    sv_upgrade(sv, SVt_PVNV);

	/* If NV preserves UV then we only use the UV value if we know that
	   we aren't going to call atof() below. If NVs don't preserve UVs
	   then the value returned may have more precision than atof() will
	   return, even though it isn't accurate.  */
	if ((numtype & (IS_NUMBER_IN_UV
#ifdef NV_PRESERVES_UV
			| IS_NUMBER_NOT_INT
#endif
	    )) == IS_NUMBER_IN_UV) {
	    /* This won't turn off the public IOK flag if it was set above  */
	    (void)SvIOKp_on(sv);

	    if (!(numtype & IS_NUMBER_NEG)) {
		/* positive */;
		if (value <= (UV)IV_MAX) {
		    SvIVX(sv) = (IV)value;
		} else {
		    /* it didn't overflow, and it was positive. */
		    SvUVX(sv) = value;
		    SvIsUV_on(sv);
		}
d1695 2
a1696 14
		/* 2s complement assumption  */
		if (value <= (UV)IV_MIN) {
		    SvIVX(sv) = -(IV)value;
		} else {
		    /* Too negative for an IV.  This is a double upgrade, but
		       I'm assuming it will be rare.  */
		    if (SvTYPE(sv) < SVt_PVNV)
			sv_upgrade(sv, SVt_PVNV);
		    SvNOK_on(sv);
		    SvIOK_off(sv);
		    SvIOKp_on(sv);
		    SvNVX(sv) = -(NV)value;
		    SvIVX(sv) = IV_MIN;
		}
d1699 20
a1718 15
	
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	    != IS_NUMBER_IN_UV) {
	    /* It wasn't an integer, or it overflowed the UV. */
	    SvNVX(sv) = Atof(SvPVX(sv));

            if (! numtype && ckWARN(WARN_NUMERIC))
		    not_a_number(sv);

#if defined(USE_LONG_DOUBLE)
            DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2uv(%" PERL_PRIgldbl ")\n",
                                  PTR2UV(sv), SvNVX(sv)));
#else
            DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2uv(%"NVgf")\n",
                                  PTR2UV(sv), SvNVX(sv)));
d1720 10
a1729 58

#ifdef NV_PRESERVES_UV
            (void)SvIOKp_on(sv);
            (void)SvNOK_on(sv);
            if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
                SvIVX(sv) = I_V(SvNVX(sv));
                if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
                    SvIOK_on(sv);
                } else {
                    /* Integer is imprecise. NOK, IOKp */
                }
                /* UV will not work better than IV */
            } else {
                if (SvNVX(sv) > (NV)UV_MAX) {
                    SvIsUV_on(sv);
                    /* Integer is inaccurate. NOK, IOKp, is UV */
                    SvUVX(sv) = UV_MAX;
                    SvIsUV_on(sv);
                } else {
                    SvUVX(sv) = U_V(SvNVX(sv));
                    /* 0xFFFFFFFFFFFFFFFF not an issue in here, NVs
                       NV preservse UV so can do correct comparison.  */
                    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
                        SvIOK_on(sv);
                        SvIsUV_on(sv);
                    } else {
                        /* Integer is imprecise. NOK, IOKp, is UV */
                        SvIsUV_on(sv);
                    }
                }
            }
#else /* NV_PRESERVES_UV */
            if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
                == (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT)) {
                /* The UV slot will have been set from value returned by
                   grok_number above.  The NV slot has just been set using
                   Atof.  */
	        SvNOK_on(sv);
                assert (SvIOKp(sv));
            } else {
                if (((UV)1 << NV_PRESERVES_UV_BITS) >
                    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
                    /* Small enough to preserve all bits. */
                    (void)SvIOKp_on(sv);
                    SvNOK_on(sv);
                    SvIVX(sv) = I_V(SvNVX(sv));
                    if ((NV)(SvIVX(sv)) == SvNVX(sv))
                        SvIOK_on(sv);
                    /* Assumption: first non-preserved integer is < IV_MAX,
                       this NV is in the preserved range, therefore: */
                    if (!(U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))
                          < (UV)IV_MAX)) {
                        Perl_croak(aTHX_ "sv_2uv assumed (U_V(fabs(SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
                    }
                } else
                    sv_2iuv_non_preserve (sv, numtype);
            }
#endif /* NV_PRESERVES_UV */
a1747 10
/*
=for apidoc sv_2nv

Return the num value of an SV, doing any necessary string or integer
conversion, magic etc. Normally used via the C<SvNV(sv)> and C<SvNVx(sv)>
macros.

=cut
*/

d1758 1
a1758 2
	    if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) &&
		!grok_number(SvPVX(sv), SvCUR(sv), NULL))
d1763 1
a1763 1
	    if (SvIsUV(sv))
d1780 1
a1780 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
a1783 3
	if (SvREADONLY(sv) && SvFAKE(sv)) {
	    sv_force_normal(sv);
	}
d1795 1
a1795 1
#ifdef USE_LONG_DOUBLE
d1806 1
a1806 1
	    PerlIO_printf(Perl_debug_log, "0x%"UVxf" num(%"NVgf")\n",
d1814 3
a1816 4
    if (SvNOKp(sv)) {
        return SvNVX(sv);
    }
    if (SvIOKp(sv)) {
a1817 11
#ifdef NV_PRESERVES_UV
	SvNOK_on(sv);
#else
	/* Only set the public NV OK flag if this NV preserves the IV  */
	/* Check it's not 0xFFFFFFFFFFFFFFFF */
	if (SvIsUV(sv) ? ((SvUVX(sv) != UV_MAX)&&(SvUVX(sv) == U_V(SvNVX(sv))))
		       : (SvIVX(sv) == I_V(SvNVX(sv))))
	    SvNOK_on(sv);
	else
	    SvNOKp_on(sv);
#endif
d1820 1
a1820 3
	UV value;
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
	if (ckWARN(WARN_NUMERIC) && !SvIOKp(sv) && !numtype)
a1821 9
#ifdef NV_PRESERVES_UV
	if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	    == IS_NUMBER_IN_UV) {
	    /* It's definitely an integer */
	    SvNVX(sv) = (numtype & IS_NUMBER_NEG) ? -(NV)value : (NV)value;
	} else
	    SvNVX(sv) = Atof(SvPVX(sv));
	SvNOK_on(sv);
#else
a1822 68
	/* Only set the public NV OK flag if this NV preserves the value in
	   the PV at least as well as an IV/UV would.
	   Not sure how to do this 100% reliably. */
	/* if that shift count is out of range then Configure's test is
	   wonky. We shouldn't be in here with NV_PRESERVES_UV_BITS ==
	   UV_BITS */
	if (((UV)1 << NV_PRESERVES_UV_BITS) >
	    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
	    SvNOK_on(sv); /* Definitely small enough to preserve all bits */
	} else if (!(numtype & IS_NUMBER_IN_UV)) {
            /* Can't use strtol etc to convert this string, so don't try.
               sv_2iv and sv_2uv will use the NV to convert, not the PV.  */
            SvNOK_on(sv);
        } else {
            /* value has been set.  It may not be precise.  */
	    if ((numtype & IS_NUMBER_NEG) && (value > (UV)IV_MIN)) {
		/* 2s complement assumption for (UV)IV_MIN  */
                SvNOK_on(sv); /* Integer is too negative.  */
            } else {
                SvNOKp_on(sv);
                SvIOKp_on(sv);

                if (numtype & IS_NUMBER_NEG) {
                    SvIVX(sv) = -(IV)value;
                } else if (value <= (UV)IV_MAX) {
		    SvIVX(sv) = (IV)value;
		} else {
		    SvUVX(sv) = value;
		    SvIsUV_on(sv);
		}

                if (numtype & IS_NUMBER_NOT_INT) {
                    /* I believe that even if the original PV had decimals,
                       they are lost beyond the limit of the FP precision.
                       However, neither is canonical, so both only get p
                       flags.  NWC, 2000/11/25 */
                    /* Both already have p flags, so do nothing */
                } else {
                    NV nv = SvNVX(sv);
                    if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
                        if (SvIVX(sv) == I_V(nv)) {
                            SvNOK_on(sv);
                            SvIOK_on(sv);
                        } else {
                            SvIOK_on(sv);
                            /* It had no "." so it must be integer.  */
                        }
                    } else {
                        /* between IV_MAX and NV(UV_MAX).
                           Could be slightly > UV_MAX */

                        if (numtype & IS_NUMBER_NOT_INT) {
                            /* UV and NV both imprecise.  */
                        } else {
                            UV nv_as_uv = U_V(nv);

                            if (value == nv_as_uv && SvUVX(sv) != UV_MAX) {
                                SvNOK_on(sv);
                                SvIOK_on(sv);
                            } else {
                                SvIOK_on(sv);
                            }
                        }
                    }
                }
            }
        }
#endif /* NV_PRESERVES_UV */
a1828 2
	    /* XXX Ilya implies that this is a bug in callers that assume this
	       and ideally should be fixed.  */
d1832 1
d1843 1
a1843 1
	PerlIO_printf(Perl_debug_log, "0x%"UVxf" 1nv(%"NVgf")\n",
a1850 3
/* asIV(): extract an integer from the string value of an SV.
 * Caller must validate PVX  */

d1854 2
a1855 2
    UV value;
    int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d1857 2
a1858 11
    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	== IS_NUMBER_IN_UV) {
	/* It's definitely an integer */
	if (numtype & IS_NUMBER_NEG) {
	    if (value < (UV)IV_MIN)
		return -(IV)value;
	} else {
	    if (value < (UV)IV_MAX)
		return (IV)value;
	}
    }
d1863 2
a1864 1
    return I_V(Atof(SvPVX(sv)));
a1866 3
/* asUV(): extract an unsigned integer from the string value of an SV
 * Caller must validate PVX  */

d1870 1
a1870 2
    UV value;
    int numtype = grok_number(SvPVX(sv), SvCUR(sv), &value);
d1872 4
a1875 6
    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
	== IS_NUMBER_IN_UV) {
	/* It's definitely an integer */
	if (!(numtype & IS_NUMBER_NEG))
	    return value;
    }
d1884 18
a1901 1
=for apidoc sv_2pv_nolen
a1902 2
Like C<sv_2pv()>, but doesn't return the length too. You should usually
use the macro wrapper C<SvPV_nolen(sv)> instead.
d1906 131
d2044 1
a2044 7
/* uiv_2buf(): private routine for use by sv_2pv_flags(): print an IV or
 * UV as a string towards the end of buf, and return pointers to start and
 * end of it.
 *
 * We assume that buf is at least TYPE_CHARS(UV) long.
 */

d2062 1
a2062 1
	*--ptr = '0' + (char)(uv % 10);
a2069 12
/*
=for apidoc sv_2pv_flags

Returns a pointer to the string value of an SV, and sets *lp to its length.
If flags includes SV_GMAGIC, does an mg_get() first. Coerces sv to a string
if necessary.
Normally invoked via the C<SvPV_flags> macro. C<sv_2pv()> and C<sv_2pv_nomg>
usually end up here too.

=cut
*/

d2071 1
a2071 1
Perl_sv_2pv_flags(pTHX_ register SV *sv, STRLEN *lp, I32 flags)
d2084 1
a2084 2
	if (flags & SV_GMAGIC)
	    mg_get(sv);
d2090 1
a2090 1
	    if (SvIsUV(sv))
d2115 1
a2115 1
                (SvTYPE(tmpstr) != SVt_RV || (SvRV(tmpstr) != SvRV(sv))))
d2126 1
a2126 1
			   (SVs_OBJECT|SVf_OK|SVs_GMG|SVs_SMG|SVs_RMG))
d2129 1
a2129 1
			 && (mg = mg_find(sv, PERL_MAGIC_qr))) {
d2138 1
a2138 2
                            char need_newline = 0;
 			    U16 reganch = (U16)((re->reganch & PMf_COMPILETIME) >> 12);
a2154 32
                            /*
                             * If /x was used, we have to worry about a regex
                             * ending with a comment later being embedded
                             * within another regex. If so, we don't want this
                             * regex's "commentization" to leak out to the
                             * right part of the enclosing regex, we must cap
                             * it with a newline.
                             *
                             * So, if /x was used, we scan backwards from the
                             * end of the regex. If we find a '#' before we
                             * find a newline, we need to add a newline
                             * ourself. If we find a '\n' first (or if we
                             * don't find '#' or '\n'), we don't need to add
                             * anything.  -jfriedl
                             */
                            if (PMf_EXTENDED & re->reganch)
                            {
                                char *endptr = re->precomp + re->prelen;
                                while (endptr >= re->precomp)
                                {
                                    char c = *(endptr--);
                                    if (c == '\n')
                                        break; /* don't need another */
                                    if (c == '#') {
                                        /* we end while in a comment, so we
                                           need a newline */
                                        mg->mg_len++; /* save space for it */
                                        need_newline = 1; /* note to add it */
                                    }
                                }
                            }

a2159 2
                            if (need_newline)
                                mg->mg_ptr[mg->mg_len - 2] = '\n';
d2175 1
a2175 4
		case SVt_PVBM:	if (SvROK(sv))
				    s = "REF";
				else
				    s = "SCALAR";		break;
d2186 2
a2187 9
		if (SvOBJECT(sv)) {
                    HV *svs = SvSTASH(sv);
		    Perl_sv_setpvf(
                        aTHX_ tsv, "%s=%s",
                        /* [20011101.072] This bandaid for C<package;>
                           should eventually be removed. AMS 20011103 */
                        (svs ? HvNAME(svs) : "<none>"), s
                    );
                }
d2203 5
a2207 27
    if (SvIOK(sv) || ((SvIOKp(sv) && !SvNOKp(sv)))) {
	/* I'm assuming that if both IV and NV are equally valid then
	   converting the IV is going to be more efficient */
	U32 isIOK = SvIOK(sv);
	U32 isUIOK = SvIsUV(sv);
	char buf[TYPE_CHARS(UV)];
	char *ebuf, *ptr;

	if (SvTYPE(sv) < SVt_PVIV)
	    sv_upgrade(sv, SVt_PVIV);
	if (isUIOK)
	    ptr = uiv_2buf(buf, 0, SvUVX(sv), 1, &ebuf);
	else
	    ptr = uiv_2buf(buf, SvIVX(sv), 0, 0, &ebuf);
	SvGROW(sv, (STRLEN)(ebuf - ptr + 1));	/* inlined from sv_setpvn */
	Move(ptr,SvPVX(sv),ebuf - ptr,char);
	SvCUR_set(sv, ebuf - ptr);
	s = SvEND(sv);
	*s = '\0';
	if (isIOK)
	    SvIOK_on(sv);
	else
	    SvIOKp_on(sv);
	if (isUIOK)
	    SvIsUV_on(sv);
    }
    else if (SvNOKp(sv)) {
d2210 1
a2210 1
	/* The +20 is pure guesswork.  Configure test needed. --jhi */
d2233 25
a2314 52
/*
=for apidoc sv_copypv

Copies a stringified representation of the source SV into the
destination SV.  Automatically performs any necessary mg_get and
coercion of numeric values into strings.  Guaranteed to preserve
UTF-8 flag even from overloaded objects.  Similar in nature to
sv_2pv[_flags] but operates directly on an SV instead of just the
string.  Mostly uses sv_2pv_flags to do its work, except when that
would lose the UTF-8'ness of the PV.

=cut
*/

void
Perl_sv_copypv(pTHX_ SV *dsv, register SV *ssv)
{
    SV *tmpsv;

    if ( SvTHINKFIRST(ssv) && SvROK(ssv) && SvAMAGIC(ssv) &&
	 (tmpsv = AMG_CALLun(ssv,string))) {
	if (SvTYPE(tmpsv) != SVt_RV || (SvRV(tmpsv) != SvRV(ssv))) {
	    SvSetSV(dsv,tmpsv);
	    return;
	}
    } else {
        tmpsv = sv_newmortal();
    }
    {
	STRLEN len;
	char *s;
	s = SvPV(ssv,len);
	sv_setpvn(tmpsv,s,len);
	if (SvUTF8(ssv))
	    SvUTF8_on(tmpsv);
	else
	    SvUTF8_off(tmpsv);
	SvSetSV(dsv,tmpsv);
    }
}

/*
=for apidoc sv_2pvbyte_nolen

Return a pointer to the byte-encoded representation of the SV.
May cause the SV to be downgraded from UTF8 as a side-effect.

Usually accessed via the C<SvPVbyte_nolen> macro.

=cut
*/

a2321 12
/*
=for apidoc sv_2pvbyte

Return a pointer to the byte-encoded representation of the SV, and set *lp
to its length.  May cause the SV to be downgraded from UTF8 as a
side-effect.

Usually accessed via the C<SvPVbyte> macro.

=cut
*/

d2325 1
a2325 2
    sv_utf8_downgrade(sv,0);
    return SvPV(sv,*lp);
a2327 11
/*
=for apidoc sv_2pvutf8_nolen

Return a pointer to the UTF8-encoded representation of the SV.
May cause the SV to be upgraded to UTF8 as a side-effect.

Usually accessed via the C<SvPVutf8_nolen> macro.

=cut
*/

a2334 11
/*
=for apidoc sv_2pvutf8

Return a pointer to the UTF8-encoded representation of the SV, and set *lp
to its length.  May cause the SV to be upgraded to UTF8 as a side-effect.

Usually accessed via the C<SvPVutf8> macro.

=cut
*/

d2341 2
a2342 10

/*
=for apidoc sv_2bool

This function is only called on magical items, and is only used by
sv_true() or its macro equivalent.

=cut
*/

d2354 2
a2355 2
                (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv))))
	    return (bool)SvTRUE(tmpsv);
a2383 18
Forces the SV to string form if it is not already.
Always sets the SvUTF8 flag to avoid future validity checks even
if all the bytes have hibit clear.

This is not as a general purpose byte encoding to Unicode interface:
use the Encode extension for that.

=for apidoc sv_utf8_upgrade_flags

Convert the PV of an SV to its UTF8-encoded form.
Forces the SV to string form if it is not already.
Always sets the SvUTF8 flag to avoid future validity checks even
if all the bytes have hibit clear. If C<flags> has C<SV_GMAGIC> bit set,
will C<mg_get> on C<sv> if appropriate, else not. C<sv_utf8_upgrade> and
C<sv_utf8_upgrade_nomg> are implemented in terms of this function.

This is not as a general purpose byte encoding to Unicode interface:
use the Encode extension for that.
d2388 2
a2389 2
STRLEN
Perl_sv_utf8_upgrade_flags(pTHX_ register SV *sv, I32 flags)
d2391 1
a2391 1
    U8 *s, *t, *e;
d2394 2
a2395 2
    if (!sv)
	return 0;
d2397 10
a2406 5
    if (!SvPOK(sv)) {
	STRLEN len = 0;
	(void) sv_2pv_flags(sv,&len, flags);
	if (!SvPOK(sv))
	     return len;
d2409 2
a2410 2
    if (SvUTF8(sv))
	return SvCUR(sv);
d2412 11
a2422 31
    if (SvREADONLY(sv) && SvFAKE(sv)) {
	sv_force_normal(sv);
    }

    if (PL_encoding)
        sv_recode_to_utf8(sv, PL_encoding);
    else { /* Assume Latin-1/EBCDIC */
	 /* This function could be much more efficient if we
	  * had a FLAG in SVs to signal if there are any hibit
	  * chars in the PV.  Given that there isn't such a flag
	  * make the loop as fast as possible. */
	 s = (U8 *) SvPVX(sv);
	 e = (U8 *) SvEND(sv);
	 t = s;
	 while (t < e) {
	      U8 ch = *t++;
	      if ((hibit = !NATIVE_IS_INVARIANT(ch)))
		   break;
	 }
	 if (hibit) {
	      STRLEN len;
	
	      len = SvCUR(sv) + 1; /* Plus the \0 */
	      SvPVX(sv) = (char*)bytes_to_utf8((U8*)s, &len);
	      SvCUR(sv) = len - 1;
	      if (SvLEN(sv) != 0)
		   Safefree(s); /* No longer using what was there before. */
	      SvLEN(sv) = len; /* No longer know the real size. */
	 }
	 /* Mark as UTF-8 even if no hibit - saves scanning loop */
	 SvUTF8_on(sv);
a2423 1
    return SvCUR(sv);
a2433 3
This is not as a general purpose Unicode to byte encoding interface:
use the Encode extension for that.

d2442 1
a2442 1
	    U8 *s;
d2447 2
a2448 2
	    s = (U8 *) SvPV(sv, len);
	    if (!utf8_to_bytes(s, &len)) {
d2454 1
a2454 1
				   OP_DESC(PL_op));
d2461 1
d2463 1
a2463 1
    SvUTF8_off(sv);
d2471 1
a2471 2
flag so that it looks like octets again. Used as a building block
for encode_utf8 in Encode.xs
d2479 1
a2479 1
    (void) sv_utf8_upgrade(sv);
a2482 10
/*
=for apidoc sv_utf8_decode

Convert the octets in the PV from UTF-8 to chars. Scan for validity and then
turn off SvUTF8 if needed so that we see characters. Used as a building block
for decode_utf8 in Encode.xs

=cut
*/

d2487 4
a2490 7
        U8 *c;
        U8 *e;

	/* The octets may have got themselves encoded - get them back as
	 * bytes
	 */
	if (!sv_utf8_downgrade(sv, TRUE))
d2496 2
a2497 2
        c = (U8 *) SvPVX(sv);
	if (!is_utf8_string(c, SvCUR(sv)+1))
d2499 1
a2499 1
        e = (U8 *) SvEND(sv);
d2501 1
a2501 2
	    U8 ch = *c++;
            if (!UTF8_IS_INVARIANT(ch)) {
d2510 6
d2519 4
a2522 27
Copies the contents of the source SV C<ssv> into the destination SV
C<dsv>.  The source SV may be destroyed if it is mortal, so don't use this
function if the source SV needs to be reused. Does not handle 'set' magic.
Loosely speaking, it performs a copy-by-value, obliterating any previous
content of the destination.

You probably want to use one of the assortment of wrappers, such as
C<SvSetSV>, C<SvSetSV_nosteal>, C<SvSetMagicSV> and
C<SvSetMagicSV_nosteal>.

=for apidoc sv_setsv_flags

Copies the contents of the source SV C<ssv> into the destination SV
C<dsv>.  The source SV may be destroyed if it is mortal, so don't use this
function if the source SV needs to be reused. Does not handle 'set' magic.
Loosely speaking, it performs a copy-by-value, obliterating any previous
content of the destination.
If the C<flags> parameter has the C<SV_GMAGIC> bit set, will C<mg_get> on
C<ssv> if appropriate, else not. C<sv_setsv> and C<sv_setsv_nomg> are
implemented in terms of this function.

You probably want to use one of the assortment of wrappers, such as
C<SvSetSV>, C<SvSetSV_nosteal>, C<SvSetMagicSV> and
C<SvSetMagicSV_nosteal>.

This is the primary function for copying scalars, and most other
copy-ish functions and macros use this underneath.
d2528 1
a2528 1
Perl_sv_setsv_flags(pTHX_ SV *dstr, register SV *sstr, I32 flags)
d2636 1
a2636 1
		OP_NAME(PL_op));
d2648 1
a2648 1
		sv_magic(dstr, dstr, PERL_MAGIC_glob, Nullch, 0);
a2658 7

#ifdef GV_UNIQUE_CHECK
                if (GvUNIQUE((GV*)dstr)) {
                    Perl_croak(aTHX_ PL_no_modify);
                }
#endif

d2676 1
a2676 1
	if (SvGMAGICAL(sstr) && (flags & SV_GMAGIC)) {
d2678 1
a2678 1
	    if ((int)SvTYPE(sstr) != stype) {
d2687 1
a2687 1
	    (void)SvUPGRADE(dstr, (U32)stype);
a2698 6
#ifdef GV_UNIQUE_CHECK
                if (GvUNIQUE((GV*)dstr)) {
                    Perl_croak(aTHX_ PL_no_modify);
                }
#endif

d2700 2
d2703 3
d2753 6
d2763 1
a2763 1
				    Perl_croak(aTHX_
d2766 5
a2770 15
 				/* Redefining a sub - warning is mandatory if
 				   it was a const and its value changed. */
 				if (ckWARN(WARN_REDEFINE)
 				    || (CvCONST(cv)
 					&& (!CvCONST((CV*)sref)
 					    || sv_cmp(cv_const_sv(cv),
 						      cv_const_sv((CV*)sref)))))
 				{
 				    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
 					CvCONST(cv)
 					? "Constant subroutine %s::%s redefined"
 					: "Subroutine %s::%s redefined",
					HvNAME(GvSTASH((GV*)dstr)),
 					GvENAME((GV*)dstr));
 				}
d2772 2
a2773 3
			    if (!intro)
				cv_ckproto(cv, (GV*)dstr,
					SvPOK(sref) ? SvPVX(sref) : Nullch);
a2792 7
		case SVt_PVFM:
		    if (intro)
			SAVESPTR(GvFORM(dstr));
		    else
			dref = (SV*)GvFORM(dstr);
		    GvFORM(dstr) = (CV*)sref;
		    break;
d2825 1
a2825 4
	    SvNOKp_on(dstr);
	    /* Only set the public OK flag if the source has public OK.  */
	    if (sflags & SVf_NOK)
		SvFLAGS(dstr) |= SVf_NOK;
d2829 2
a2830 3
	    (void)SvIOKp_on(dstr);
	    if (sflags & SVf_IOK)
		SvFLAGS(dstr) |= SVf_IOK;
a2832 1
	    SvIVX(dstr) = SvIVX(sstr);
d2849 1
a2849 4
	    !(sflags & SVf_OOK) && 	/* and not involved in OOK hack? */
	    SvLEN(sstr) 	&&	/* and really is a string */
	    			/* and won't be needed again, potentially */
	    !(PL_op && PL_op->op_type == OP_AASSIGN))
d2865 1
a2865 1
	    (void)SvOK_off(sstr);	/* NOTE: nukes most SvFLAGS on sstr */
d2871 1
a2871 1
	else {				/* have to copy actual string */
d2873 2
a2874 1
	    SvGROW(dstr, len + 1);	/* inlined from sv_setpvn */
d2884 1
a2884 3
	    SvNOKp_on(dstr);
	    if (sflags & SVf_NOK)
		SvFLAGS(dstr) |= SVf_NOK;
d2888 2
a2889 3
	    (void)SvIOKp_on(dstr);
	    if (sflags & SVf_IOK)
		SvFLAGS(dstr) |= SVf_IOK;
d2892 7
d2900 3
d2906 2
a2907 7
	if (sflags & SVf_IOK)
	    (void)SvIOK_only(dstr);
	else {
	    (void)SvOK_off(dstr);
	    (void)SvIOKp_on(dstr);
	}
	/* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
a2909 17
	SvIVX(dstr) = SvIVX(sstr);
	if (sflags & SVp_NOK) {
	    if (sflags & SVf_NOK)
		(void)SvNOK_on(dstr);
	    else
		(void)SvNOKp_on(dstr);
	    SvNVX(dstr) = SvNVX(sstr);
	}
    }
    else if (sflags & SVp_NOK) {
	if (sflags & SVf_NOK)
	    (void)SvNOK_only(dstr);
	else {
	    (void)SvOK_off(dstr);
	    SvNOKp_on(dstr);
	}
	SvNVX(dstr) = SvNVX(sstr);
d2914 1
a2914 1
		Perl_warner(aTHX_ packWARN(WARN_MISC), "Undefined value assigned to typeglob");
d2960 1
a2960 2
	if (iv < 0)
	    Perl_croak(aTHX_ "panic: sv_setpvn called with negative strlen");
d2969 1
a2969 1
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
d3013 1
a3013 1
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
d3036 1
a3036 1
stored inside the SV but sv_usepvn allows the SV to use an outside string.
d3063 1
a3063 1
    (void)SvPOK_only_UTF8(sv);		/* validate pointer */
a3081 11
/*
=for apidoc sv_force_normal_flags

Undo various types of fakery on an SV: if the PV is a shared string, make
a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
an xpvmg. The C<flags> parameter gets passed to  C<sv_unref_flags()>
when unrefing. C<sv_force_normal> calls this function with flags set to 0.

=cut
*/

d3083 1
a3083 1
Perl_sv_force_normal_flags(pTHX_ register SV *sv, U32 flags)
d3086 1
a3086 12
	if (SvFAKE(sv)) {
	    char *pvx = SvPVX(sv);
	    STRLEN len = SvCUR(sv);
            U32 hash   = SvUVX(sv);
	    SvGROW(sv, len + 1);
	    Move(pvx,SvPVX(sv),len,char);
	    *SvEND(sv) = '\0';
	    SvFAKE_off(sv);
	    SvREADONLY_off(sv);
	    unsharepvn(pvx, SvUTF8(sv) ? -(I32)len : len, hash);
	}
	else if (PL_curcop != &PL_compiling)
d3090 1
a3090 1
	sv_unref_flags(sv, flags);
d3094 1
a3094 17

/*
=for apidoc sv_force_normal

Undo various types of fakery on an SV: if the PV is a shared string, make
a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
an xpvmg. See also C<sv_force_normal_flags>.

=cut
*/

void
Perl_sv_force_normal(pTHX_ register SV *sv)
{
    sv_force_normal_flags(sv, 0);
}

d3098 1
a3098 1
Efficient removal of characters from the beginning of the string buffer.
d3101 1
a3101 1
string. Uses the "OOK hack".
d3107 3
a3109 1
Perl_sv_chop(pTHX_ register SV *sv, register char *ptr)
d3142 2
a3143 12
C<len> indicates number of bytes to copy.  If the SV has the UTF8
status set, then the bytes appended should be valid UTF8.
Handles 'get' magic, but not 'set' magic.  See C<sv_catpvn_mg>.

=for apidoc sv_catpvn_flags

Concatenates the string onto the end of the string which is in the SV.  The
C<len> indicates number of bytes to copy.  If the SV has the UTF8
status set, then the bytes appended should be valid UTF8.
If C<flags> has C<SV_GMAGIC> bit set, will C<mg_get> on C<dsv> if
appropriate, else not. C<sv_catpvn> and C<sv_catpvn_nomg> are implemented
in terms of this function.
d3149 1
a3149 1
Perl_sv_catpvn_flags(pTHX_ register SV *dsv, register const char *sstr, register STRLEN slen, I32 flags)
d3151 2
a3152 2
    STRLEN dlen;
    char *dstr;
d3154 9
a3162 9
    dstr = SvPV_force_flags(dsv, dlen, flags);
    SvGROW(dsv, dlen + slen + 1);
    if (sstr == dstr)
	sstr = SvPVX(dsv);
    Move(sstr, SvPVX(dsv) + dlen, slen, char);
    SvCUR(dsv) += slen;
    *SvEND(dsv) = '\0';
    (void)SvPOK_only_UTF8(dsv);		/* validate pointer */
    SvTAINT(dsv);
a3186 7
=for apidoc sv_catsv_flags

Concatenates the string from SV C<ssv> onto the end of the string in
SV C<dsv>.  Modifies C<dsv> but not C<ssv>.  If C<flags> has C<SV_GMAGIC>
bit set, will C<mg_get> on the SVs if appropriate, else not. C<sv_catsv>
and C<sv_catsv_nomg> are implemented in terms of this function.

d3190 1
a3190 1
Perl_sv_catsv_flags(pTHX_ SV *dsv, register SV *ssv, I32 flags)
d3194 1
a3194 1
    if (!ssv)
d3196 3
a3198 14
    if ((spv = SvPV(ssv, slen))) {
	/*  sutf8 and dutf8 were type bool, but under USE_ITHREADS,
	    gcc version 2.95.2 20000220 (Debian GNU/Linux) for
	    Linux xxx 2.2.17 on sparc64 with gcc -O2, we erroneously
	    get dutf8 = 0x20000000, (i.e.  SVf_UTF8) even though
	    dsv->sv_flags doesn't have that bit set.
		Andy Dougherty  12 Oct 2001
	*/
	I32 sutf8 = DO_UTF8(ssv);
	I32 dutf8;

	if (SvGMAGICAL(dsv) && (flags & SV_GMAGIC))
	    mg_get(dsv);
	dutf8 = DO_UTF8(dsv);
d3200 3
a3202 1
	if (dutf8 != sutf8) {
d3204 13
a3216 5
		/* Not modifying source SV, so taking a temporary copy. */
		SV* csv = sv_2mortal(newSVpvn(spv, slen));

		sv_utf8_upgrade(csv);
		spv = SvPV(csv, slen);
a3217 2
	    else
		sv_utf8_upgrade_nomg(dsv);
a3218 1
	sv_catpvn_nomg(dsv, spv, slen);
d3231 1
a3231 1
Perl_sv_catsv_mg(pTHX_ SV *dsv, register SV *ssv)
d3233 2
a3234 2
    sv_catsv(dsv,ssv);
    SvSETMAGIC(dsv);
d3241 1
a3241 2
If the SV has the UTF8 status set, then the bytes appended should be
valid UTF8.  Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.
d3243 2
a3244 1
=cut */
a3280 10
/*
=for apidoc newSV

Create a new null SV, or if len > 0, create a new empty SVt_PV type SV
with an initial PV allocation of len+1. Normally accessed via the C<NEWSV>
macro.

=cut
*/

d3285 1
a3285 1

a3292 2
/*
=for apidoc sv_magicext
d3294 1
a3294 2
Adds magic to an SV, upgrading it if necessary. Applies the
supplied vtable and returns pointer to the magic added.
d3296 2
a3297 8
Note that sv_magicext will allow things that sv_magic will not.
In particular you can add magic to SvREADONLY SVs and and more than
one instance of the same 'how'

I C<namelen> is greater then zero then a savepvn() I<copy> of C<name> is stored,
if C<namelen> is zero then C<name> is stored as-is and - as another special
case - if C<(name && namelen == HEf_SVKEY)> then C<name> is assumed to contain
an C<SV*> and has its REFCNT incremented
d3299 1
a3299 1
(This is now used as a subroutine by sv_magic.)
d3303 3
a3305 3
MAGIC *	
Perl_sv_magicext(pTHX_ SV* sv, SV* obj, int how, MGVTBL *vtable,
		 const char* name, I32 namlen)
d3308 14
a3321 3

    if (SvTYPE(sv) < SVt_PVMG) {
	(void)SvUPGRADE(sv, SVt_PVMG);
d3328 4
a3331 12
       each other.  To prevent a reference loop that would prevent such
       objects being freed, we look for such loops and if we find one we
       avoid incrementing the object refcount.

       Note we cannot do this to avoid self-tie loops as intervening RV must
       have its REFCNT incremented to keep it in existence - instead we could
       special case them in sv_free() -- NI-S

    */
    if (!obj || obj == sv ||
	how == PERL_MAGIC_arylen ||
	how == PERL_MAGIC_qr ||
d3345 2
a3346 2
    if (name) {
	if (namlen > 0)
d3350 1
a3350 48
	else
	    mg->mg_ptr = (char *) name;
    }
    mg->mg_virtual = vtable;

    mg_magical(sv);
    if (SvGMAGICAL(sv))
	SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
    return mg;
}

/*
=for apidoc sv_magic

Adds magic to an SV. First upgrades C<sv> to type C<SVt_PVMG> if necessary,
then adds a new magic item of type C<how> to the head of the magic list.

=cut
*/

void
Perl_sv_magic(pTHX_ register SV *sv, SV *obj, int how, const char *name, I32 namlen)
{
    MAGIC* mg;
    MGVTBL *vtable = 0;

    if (SvREADONLY(sv)) {
	if (PL_curcop != &PL_compiling
	    && how != PERL_MAGIC_regex_global
	    && how != PERL_MAGIC_bm
	    && how != PERL_MAGIC_fm
	    && how != PERL_MAGIC_sv
	   )
	{
	    Perl_croak(aTHX_ PL_no_modify);
	}
    }
    if (SvMAGICAL(sv) || (how == PERL_MAGIC_taint && SvTYPE(sv) >= SVt_PVMG)) {
	if (SvMAGIC(sv) && (mg = mg_find(sv, how))) {
	    /* sv_magic() refuses to add a magic of the same 'how' as an
	       existing one
	     */
	    if (how == PERL_MAGIC_taint)
		mg->mg_len |= 1;
	    return;
	}
    }

d3352 2
a3353 2
    case PERL_MAGIC_sv:
	vtable = &PL_vtbl_sv;
d3355 2
a3356 2
    case PERL_MAGIC_overload:
        vtable = &PL_vtbl_amagic;
d3358 2
a3359 2
    case PERL_MAGIC_overload_elem:
        vtable = &PL_vtbl_amagicelem;
d3361 2
a3362 2
    case PERL_MAGIC_overload_table:
        vtable = &PL_vtbl_ovrld;
d3364 2
a3365 2
    case PERL_MAGIC_bm:
	vtable = &PL_vtbl_bm;
d3367 2
a3368 2
    case PERL_MAGIC_regdata:
	vtable = &PL_vtbl_regdata;
d3370 2
a3371 2
    case PERL_MAGIC_regdatum:
	vtable = &PL_vtbl_regdatum;
d3373 2
a3374 2
    case PERL_MAGIC_env:
	vtable = &PL_vtbl_env;
d3376 2
a3377 2
    case PERL_MAGIC_fm:
	vtable = &PL_vtbl_fm;
d3379 2
a3380 2
    case PERL_MAGIC_envelem:
	vtable = &PL_vtbl_envelem;
d3382 2
a3383 2
    case PERL_MAGIC_regex_global:
	vtable = &PL_vtbl_mglob;
d3385 2
a3386 2
    case PERL_MAGIC_isa:
	vtable = &PL_vtbl_isa;
d3388 2
a3389 2
    case PERL_MAGIC_isaelem:
	vtable = &PL_vtbl_isaelem;
d3391 2
a3392 2
    case PERL_MAGIC_nkeys:
	vtable = &PL_vtbl_nkeys;
d3394 3
a3396 2
    case PERL_MAGIC_dbfile:
	vtable = 0;
d3398 2
a3399 2
    case PERL_MAGIC_dbline:
	vtable = &PL_vtbl_dbline;
d3401 3
a3403 3
#ifdef USE_5005THREADS
    case PERL_MAGIC_mutex:
	vtable = &PL_vtbl_mutex;
d3405 1
a3405 1
#endif /* USE_5005THREADS */
d3407 2
a3408 2
    case PERL_MAGIC_collxfrm:
        vtable = &PL_vtbl_collxfrm;
d3411 2
a3412 2
    case PERL_MAGIC_tied:
	vtable = &PL_vtbl_pack;
d3414 3
a3416 3
    case PERL_MAGIC_tiedelem:
    case PERL_MAGIC_tiedscalar:
	vtable = &PL_vtbl_packelem;
d3418 2
a3419 2
    case PERL_MAGIC_qr:
	vtable = &PL_vtbl_regexp;
d3421 2
a3422 2
    case PERL_MAGIC_sig:
	vtable = &PL_vtbl_sig;
d3424 2
a3425 2
    case PERL_MAGIC_sigelem:
	vtable = &PL_vtbl_sigelem;
d3427 3
a3429 2
    case PERL_MAGIC_taint:
	vtable = &PL_vtbl_taint;
d3431 2
a3432 2
    case PERL_MAGIC_uvar:
	vtable = &PL_vtbl_uvar;
d3434 2
a3435 2
    case PERL_MAGIC_vec:
	vtable = &PL_vtbl_vec;
d3437 2
a3438 2
    case PERL_MAGIC_substr:
	vtable = &PL_vtbl_substr;
d3440 2
a3441 2
    case PERL_MAGIC_defelem:
	vtable = &PL_vtbl_defelem;
d3443 2
a3444 2
    case PERL_MAGIC_glob:
	vtable = &PL_vtbl_glob;
d3446 2
a3447 2
    case PERL_MAGIC_arylen:
	vtable = &PL_vtbl_arylen;
d3449 2
a3450 2
    case PERL_MAGIC_pos:
	vtable = &PL_vtbl_pos;
d3452 2
a3453 2
    case PERL_MAGIC_backref:
	vtable = &PL_vtbl_backref;
d3455 1
a3455 2
    case PERL_MAGIC_ext:
	/* Reserved for use by extensions not perl internals.	        */
d3459 1
d3462 1
a3462 14
	Perl_croak(aTHX_ "Don't know how to handle magic of type \\%o", how);
    }

    /* Rest of work is done else where */
    mg = sv_magicext(sv,obj,how,vtable,name,namlen);

    switch (how) {
    case PERL_MAGIC_taint:
	mg->mg_len = 1;
	break;
    case PERL_MAGIC_ext:
    case PERL_MAGIC_dbfile:
	SvRMAGICAL_on(sv);
	break;
d3464 3
d3472 1
a3472 1
Removes all magic of type C<type> from an SV.
d3491 2
a3492 2
	    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
		if (mg->mg_len > 0)
a3495 1
            }
d3505 1
a3505 1
       SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d3514 1
a3514 4
Weaken a reference: set the C<SvWEAKREF> flag on this RV; give the
referred-to SV C<PERL_MAGIC_backref> magic if it hasn't already; and
push a back-reference to this RV onto the array of backreferences
associated with that magic.
d3529 1
a3529 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "Reference is already weak");
d3535 1
a3535 1
    SvREFCNT_dec(tsv);
d3539 2
a3540 6
/* Give tsv backref magic if it hasn't already got it, then push a
 * back-reference to sv onto the array associated with the backref magic.
 */

STATIC void
S_sv_add_backref(pTHX_ SV *tsv, SV *sv)
d3544 1
a3544 1
    if (SvMAGICAL(tsv) && (mg = mg_find(tsv, PERL_MAGIC_backref)))
d3548 1
a3548 1
	sv_magic(tsv, (SV*)av, PERL_MAGIC_backref, NULL, 0);
d3554 2
a3555 6
/* delete a back-reference to ourselves from the backref magic associated
 * with the SV we point to.
 */

STATIC void
S_sv_del_backref(pTHX_ SV *sv)
d3561 2
a3562 2
    MAGIC *mg = NULL;
    if (!SvMAGICAL(tsv) || !(mg = mg_find(tsv, PERL_MAGIC_backref)))
d3593 1
a3593 1

a3672 5
The target SV physically takes over ownership of the body of the source SV
and inherits its flags; however, the target keeps any magic it owns,
and any magic in the source is discarded.
Note that this is a rather specialist SV copying operation; most of the
time you'll want to use C<sv_setsv> or one of its many macro front-ends.
d3683 1
a3683 1
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "Reference miscount in sv_replace()");
d3706 2
a3707 7
Clear an SV: call any destructors, free up any memory used by the body,
and free the body itself. The SV's head is I<not> freed, although
its type is set to all 1's so that it won't inadvertently be assumed
to be live during global destruction etc.
This function should only be called when REFCNT is zero. Most of the time
you'll want to call C<sv_free()> (or its macro wrapper C<SvREFCNT_dec>)
instead.
d3722 1
a3722 1
	    CV* destructor;
d3731 1
a3731 1
	    do {	
d3733 1
a3733 1
		destructor = StashHANDLER(stash,DESTROY);
d3742 2
a3743 1
		    call_sv((SV*)destructor, G_DISCARD|G_EVAL|G_KEEPERR);
d3769 2
a3770 6
    if (SvTYPE(sv) >= SVt_PVMG) {
    	if (SvMAGIC(sv))
	    mg_free(sv);
	if (SvFLAGS(sv) & SVpad_TYPED)
	    SvREFCNT_dec(SvSTASH(sv));
    }
a3827 6
	else if (SvPVX(sv) && SvREADONLY(sv) && SvFAKE(sv)) {
	    unsharepvn(SvPVX(sv),
		       SvUTF8(sv) ? -(I32)SvCUR(sv) : SvCUR(sv),
		       SvUVX(sv));
	    SvFAKE_off(sv);
	}
a3895 9
/*
=for apidoc sv_newref

Increment an SV's reference count. Use the C<SvREFCNT_inc()> wrapper
instead.

=cut
*/

d3907 1
a3907 4
Decrement an SV's reference count, and if it drops to zero, call
C<sv_clear> to invoke destructors and free up any memory used by
the body; finally, deallocate the SV's head itself.
Normally called via a wrapper macro C<SvREFCNT_dec>.
a3920 2
	    /* this SV's refcnt has been artificially decremented to
	     * trigger cleanup */
d3930 1
a3930 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "Attempt to free unreferenced scalar");
d3939 1
a3939 1
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
d3958 1
a3958 2
Returns the length of the string in the SV. Handles magic and type
coercion.  See also C<SvCUR>, which gives raw access to the xpv_cur slot.
d3966 1
d3975 1
a3975 1
        (void)SvPV(sv, len);
d3983 1
a3983 1
UTF8 bytes as a single character. Handles magic and type coercion.
d3994 1
d3998 1
a4006 12
/*
=for apidoc sv_pos_u2b

Converts the value pointed to by offsetp from a count of UTF8 chars from
the start of the string, to a count of the equivalent number of bytes; if
lenp is non-zero, it does the same to lenp, but this time starting from
the offset, rather than from the start of the string. Handles magic and
type coercion.

=cut
*/

a4037 10
/*
=for apidoc sv_pos_b2u

Converts the value pointed to by offsetp from a count of bytes from the
start of the string, to a count of the equivalent number of UTF8 chars.
Handles magic and type coercion.

=cut
*/

d4049 1
a4049 1
    if ((I32)len < *offsetp)
d4054 3
a4056 6
	STRLEN n = 1;
	/* Call utf8n_to_uvchr() to validate the sequence
	 * (unless a simple non-UTF character) */
	if (!UTF8_IS_INVARIANT(*s))
	    utf8n_to_uvchr(s, UTF8SKIP(s), &n, 0);
	if (n > 0) {
d4071 1
a4071 2
identical. Is UTF-8 and 'use bytes' aware, handles get magic, and will
coerce its args to strings if necessary.
d4084 2
a4085 2
    char *tpv   = Nullch;
    SV* svrecode = Nullsv;
d4101 16
a4116 42
    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTES) {
        /* Differing utf8ness.
	 * Do not UTF8size the comparands as a side-effect. */
	 if (PL_encoding) {
	      if (SvUTF8(sv1)) {
		   svrecode = newSVpvn(pv2, cur2);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   pv2 = SvPV(svrecode, cur2);
	      }
	      else {
		   svrecode = newSVpvn(pv1, cur1);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   pv1 = SvPV(svrecode, cur1);
	      }
	      /* Now both are in UTF-8. */
	      if (cur1 != cur2)
		   return FALSE;
	 }
	 else {
	      bool is_utf8 = TRUE;

	      if (SvUTF8(sv1)) {
		   /* sv1 is the UTF-8 one,
		    * if is equal it must be downgrade-able */
		   char *pv = (char*)bytes_from_utf8((U8*)pv1,
						     &cur1, &is_utf8);
		   if (pv != pv1)
			pv1 = tpv = pv;
	      }
	      else {
		   /* sv2 is the UTF-8 one,
		    * if is equal it must be downgrade-able */
		   char *pv = (char *)bytes_from_utf8((U8*)pv2,
						      &cur2, &is_utf8);
		   if (pv != pv2)
			pv2 = tpv = pv;
	      }
	      if (is_utf8) {
		   /* Downgrade not possible - cannot be eq */
		   return FALSE;
	      }
	 }
d4122 4
a4125 5
    if (svrecode)
	 SvREFCNT_dec(svrecode);

    if (tpv)
	Safefree(tpv);
d4135 1
a4135 2
C<sv2>. Is UTF-8 and 'use bytes' aware, handles get magic, and will
coerce its args to strings if necessary.  See also C<sv_cmp_locale>.
d4144 4
a4147 3
    char *pv1, *pv2, *tpv = Nullch;
    I32  cmp;
    SV *svrecode = Nullsv;
d4156 1
a4156 1
    if (!sv2) {
d4163 2
a4164 3
    if (cur1 && cur2 && SvUTF8(sv1) != SvUTF8(sv2) && !IN_BYTES) {
        /* Differing utf8ness.
	 * Do not UTF8size the comparands as a side-effect. */
d4166 2
a4167 8
	    if (PL_encoding) {
		 svrecode = newSVpvn(pv2, cur2);
		 sv_recode_to_utf8(svrecode, PL_encoding);
		 pv2 = SvPV(svrecode, cur2);
	    }
	    else {
		 pv2 = tpv = (char*)bytes_to_utf8((U8*)pv2, &cur2);
	    }
d4170 2
a4171 8
	    if (PL_encoding) {
		 svrecode = newSVpvn(pv1, cur1);
		 sv_recode_to_utf8(svrecode, PL_encoding);
		 pv1 = SvPV(svrecode, cur1);
	    }
	    else {
		 pv1 = tpv = (char*)bytes_to_utf8((U8*)pv1, &cur1);
	    }
d4191 4
a4194 5
    if (svrecode)
	 SvREFCNT_dec(svrecode);

    if (tpv)
	Safefree(tpv);
d4202 2
a4203 3
Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
'use bytes' aware, handles get magic, and will coerce its args to strings
if necessary.  See also C<sv_cmp_locale>.  See also C<sv_cmp>.
a4255 1

a4256 1

d4258 5
a4262 12
=for apidoc sv_collxfrm

Add Collate Transform magic to an SV if it doesn't already have it.

Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the
scalar data of the variable, but transformed to such a format that a normal
memory comparison can be used to compare the data according to the locale
settings.

=cut
*/

d4268 1
a4268 1
    mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_collxfrm) : (MAGIC *) NULL;
d4283 2
a4284 2
		sv_magic(sv, 0, PERL_MAGIC_collxfrm, 0, 0);
		mg = mg_find(sv, PERL_MAGIC_collxfrm);
d4326 1
a4326 2
    I32 i = 0;
    I32 rspara = 0;
d4333 1
a4333 6
    if (PL_curcop == &PL_compiling) {
	/* we always read code in line mode */
	rsptr = "\n";
	rslen = 1;
    }
    else if (RsSNARF(PL_rs)) {
d4344 1
a4344 1
      buffer = SvGROW(sv, (STRLEN)(recsize + 1));
d4356 1
a4356 4
      if (PerlIO_isutf8(fp))
	SvUTF8_on(sv);
      else
	SvUTF8_off(sv);
a4361 1
	rspara = 1;
d4365 3
a4367 8
	if (PerlIO_isutf8(fp)) {
	    rsptr = SvPVutf8(PL_rs, rslen);
	}
	else {
	    if (SvUTF8(PL_rs)) {
		if (!sv_utf8_downgrade(PL_rs, TRUE)) {
		    Perl_croak(aTHX_ "Wide character in $/");
		}
a4368 1
	    rsptr = SvPV(PL_rs, rslen);
d4370 1
d4375 1
a4375 1
    if (rspara) {		/* have to do this both before and after */
d4392 1
a4392 1
       of abstracting out stdio interface. One call should be cheap
d4421 2
a4422 2
    if ((I32)(SvLEN(sv) - append) <= cnt + 1) { /* make sure we have the room */
	if (cnt > 80 && (I32)SvLEN(sv) > append) {
d4429 1
a4429 1
	    SvGROW(sv, (STRLEN)(append + (cnt <= 0 ? 2 : (cnt + 1))));
d4439 2
a4440 2
	"Screamer: entering: PerlIO * thinks ptr=%"UVuf", cnt=%ld, base=%"UVuf"\n",
	       PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
d4453 2
a4454 2
	        Copy(ptr, bp, cnt, char);	     /* this     |  eat */
		bp += cnt;			     /* screams  |  dust */
d4473 1
a4473 2
	PerlIO_set_ptrcnt(fp, (STDCHAR*)ptr, cnt); /* deregisterize cnt and ptr */
#if 0
d4476 1
a4476 1
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
d4478 1
a4478 2
#endif
	/* This used to call 'filbuf' in stdio form, but as that behaves like
a4481 1
#if 0
d4484 1
a4484 1
	    PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
a4485 1
#endif
d4499 1
a4499 1
	*bp++ = (STDCHAR)i;		/* store character from PerlIO_getc */
d4506 1
a4506 1
    if ((rslen > 1 && (STRLEN)(bp - (STDCHAR*)SvPVX(sv)) < rslen) ||
d4514 1
a4514 1
    PerlIO_set_ptrcnt(fp, (STDCHAR*)ptr, cnt);	/* put these back or we're in trouble */
d4517 1
a4517 1
	PTR2UV(PerlIO_get_ptr(fp)), (long)PerlIO_get_cnt(fp),
d4542 1
a4542 1
	    while ((i = PerlIO_getc(fp)) != EOF && (*bp++ = (STDCHAR)i) != rslast && bp < bpe)
d4551 1
a4551 4
	    if (cnt > 0)
		 i = (U8)buf[cnt - 1];
	    else
		 i = EOF;
a4553 2
	if (cnt < 0)
	    cnt = 0;  /* we do need to re-set the sv even when cnt <= 0 */
d4555 1
a4555 1
	     sv_catpvn(sv, (char *) buf, cnt);
d4557 1
a4557 1
	     sv_setpvn(sv, (char *) buf, cnt);
d4581 1
a4581 1
    if (rspara) {		/* have to do this both before and after */
d4591 1
a4591 4
    if (PerlIO_isutf8(fp))
	SvUTF8_on(sv);
    else
	SvUTF8_off(sv);
d4596 1
d4600 1
a4600 2
Auto-increment of the value in the SV, doing string to numeric conversion
if necessary. Handles 'get' magic.
a4615 2
	if (SvREADONLY(sv) && SvFAKE(sv))
	    sv_force_normal(sv);
d4630 6
a4635 11
    if ((flags & (SVp_NOK|SVp_IOK)) == SVp_NOK) {
	/* It's (privately or publicly) a float, but not tested as an
	   integer, so test it to see. */
	(void) SvIV(sv);
	flags = SvFLAGS(sv);
    }
    if ((flags & SVf_IOK) || ((flags & (SVp_IOK | SVp_NOK)) == SVp_IOK)) {
	/* It's publicly an integer, or privately an integer-not-float */
#ifdef PERL_PRESERVE_IVUV
      oops_its_int:
#endif
d4638 1
a4638 1
		sv_setnv(sv, UV_MAX_P1);
d4644 1
a4644 1
		sv_setuv(sv, (UV)IV_MAX + 1);
d4648 1
a4648 1
	    }	
d4652 4
a4655 1
    if (flags & SVp_NOK) {
a4656 9
	SvNVX(sv) += 1.0;
	return;
    }

    if (!(flags & SVp_POK) || !*SvPVX(sv)) {
	if ((flags & SVTYPEMASK) < SVt_PVIV)
	    sv_upgrade(sv, SVt_IV);
	(void)SvIOK_only(sv);
	SvIVX(sv) = 1;
d4663 1
a4663 36
#ifdef PERL_PRESERVE_IVUV
	/* Got to punt this as an integer if needs be, but we don't issue
	   warnings. Probably ought to make the sv_iv_please() that does
	   the conversion if possible, and silently.  */
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), NULL);
	if (numtype && !(numtype & IS_NUMBER_INFINITY)) {
	    /* Need to try really hard to see if it's an integer.
	       9.22337203685478e+18 is an integer.
	       but "9.22337203685478e+18" + 0 is UV=9223372036854779904
	       so $a="9.22337203685478e+18"; $a+0; $a++
	       needs to be the same as $a="9.22337203685478e+18"; $a++
	       or we go insane. */
	
	    (void) sv_2iv(sv);
	    if (SvIOK(sv))
		goto oops_its_int;

	    /* sv_2iv *should* have made this an NV */
	    if (flags & SVp_NOK) {
		(void)SvNOK_only(sv);
		SvNVX(sv) += 1.0;
		return;
	    }
	    /* I don't think we can get here. Maybe I should assert this
	       And if we do get here I suspect that sv_setnv will croak. NWC
	       Fall through. */
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_inc punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"PERL_PRIgldbl"\n",
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_inc punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"NVgf"\n",
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
#endif
	}
#endif /* PERL_PRESERVE_IVUV */
	sv_setnv(sv,Atof(SvPVX(sv)) + 1.0);
d4678 1
a4678 1
	     * arranged in order (although not consecutively) and that only
d4708 1
a4708 2
Auto-decrement of the value in the SV, doing string to numeric conversion
if necessary. Handles 'get' magic.
a4722 2
	if (SvREADONLY(sv) && SvFAKE(sv))
	    sv_force_normal(sv);
a4735 2
    /* Unlike sv_inc we don't have to worry about string-never-numbers
       and keeping them magic. But we mustn't warn on punting */
d4737 6
a4742 5
    if ((flags & SVf_IOK) || ((flags & (SVp_IOK | SVp_NOK)) == SVp_IOK)) {
	/* It's publicly an integer, or privately an integer-not-float */
#ifdef PERL_PRESERVE_IVUV
      oops_its_int:
#endif
d4751 1
a4751 1
	    }	
d4758 1
a4758 1
	    }	
a4761 5
    if (flags & SVp_NOK) {
	SvNVX(sv) -= 1.0;
	(void)SvNOK_only(sv);
	return;
    }
a4768 34
#ifdef PERL_PRESERVE_IVUV
    {
	int numtype = grok_number(SvPVX(sv), SvCUR(sv), NULL);
	if (numtype && !(numtype & IS_NUMBER_INFINITY)) {
	    /* Need to try really hard to see if it's an integer.
	       9.22337203685478e+18 is an integer.
	       but "9.22337203685478e+18" + 0 is UV=9223372036854779904
	       so $a="9.22337203685478e+18"; $a+0; $a--
	       needs to be the same as $a="9.22337203685478e+18"; $a--
	       or we go insane. */
	
	    (void) sv_2iv(sv);
	    if (SvIOK(sv))
		goto oops_its_int;

	    /* sv_2iv *should* have made this an NV */
	    if (flags & SVp_NOK) {
		(void)SvNOK_only(sv);
		SvNVX(sv) -= 1.0;
		return;
	    }
	    /* I don't think we can get here. Maybe I should assert this
	       And if we do get here I suspect that sv_setnv will croak. NWC
	       Fall through. */
#if defined(USE_LONG_DOUBLE)
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_dec punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"PERL_PRIgldbl"\n",
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
#else
	    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_dec punt failed to convert '%s' to IOK or NOKp, UV=0x%"UVxf" NV=%"NVgf"\n",
				  SvPVX(sv), SvIVX(sv), SvNVX(sv)));
#endif
	}
    }
#endif /* PERL_PRESERVE_IVUV */
d4775 2
a4776 4
Creates a new SV which is a copy of the original SV (using C<sv_setsv>).
The new SV is marked as mortal. It will be destroyed "soon", either by an
explicit call to FREETMPS, or by an implicit call at places such as
statement boundaries.  See also C<sv_newmortal> and C<sv_2mortal>.
d4802 1
a4802 4
Creates a new null SV which is mortal.  The reference count of the SV is
set to 1. It will be destroyed "soon", either by an explicit call to
FREETMPS, or by an implicit call at places such as statement boundaries.
See also C<sv_mortalcopy> and C<sv_2mortal>.
d4822 2
a4823 3
Marks an existing SV as mortal.  The SV will be destroyed "soon", either
by an explicit call to FREETMPS, or by an implicit call at places such as
statement boundaries.  See also C<sv_newmortal> and C<sv_mortalcopy>.
d4828 2
d4869 1
a4869 1
SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length
a4885 43
/*
=for apidoc newSVpvn_share

Creates a new SV with its SvPVX pointing to a shared string in the string
table. If the string does not already exist in the table, it is created
first.  Turns on READONLY and FAKE.  The string's hash is stored in the UV
slot of the SV; if the C<hash> parameter is non-zero, that value is used;
otherwise the hash is computed.  The idea here is that as the string table
is used for shared hash keys these strings will have SvPVX == HeKEY and
hash lookup will avoid string compare.

=cut
*/

SV *
Perl_newSVpvn_share(pTHX_ const char *src, I32 len, U32 hash)
{
    register SV *sv;
    bool is_utf8 = FALSE;
    if (len < 0) {
	STRLEN tmplen = -len;
        is_utf8 = TRUE;
	/* See the note in hv.c:hv_fetch() --jhi */
	src = (char*)bytes_from_utf8((U8*)src, &tmplen, &is_utf8);
	len = tmplen;
    }
    if (!hash)
	PERL_HASH(hash, src, len);
    new_SV(sv);
    sv_upgrade(sv, SVt_PVIV);
    SvPVX(sv) = sharepvn(src, is_utf8?-len:len, hash);
    SvCUR(sv) = len;
    SvUVX(sv) = hash;
    SvLEN(sv) = 0;
    SvREADONLY_on(sv);
    SvFAKE_on(sv);
    SvPOK_on(sv);
    if (is_utf8)
        SvUTF8_on(sv);
    return sv;
}


a4886 6

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

d4903 1
a4903 1
Creates a new SV and initializes it with the string formatted like
a4919 2
/* backend for newSVpvf() and newSVpvf_nocontext() */

d5008 1
a5008 4
/* newRV_inc is the official function name to use now.
 * newRV_inc is in fact #defined to newRV in sv.h
 */

a5018 1
(Uses C<sv_setsv>).
d5023 2
d5034 1
a5034 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "semi-panic: attempt to dup freed string");
a5047 9
/*
=for apidoc sv_reset

Underlying implementation for the C<reset> Perl function.
Note that the perl-level function is vaguely deprecated.

=cut
*/

d5111 1
a5111 6
		    if (gv == PL_envgv
#  ifdef USE_ITHREADS
			&& PL_curinterp == aTHX
#  endif
		    )
		    {
a5112 1
		    }
a5119 10
/*
=for apidoc sv_2io

Using various gambits, try to get an IO from an SV: the IO slot if its a
GV; or the recursive result if we're an RV; or the IO slot of the symbol
named after the PV if we're a string.

=cut
*/

a5153 9
/*
=for apidoc sv_2cv

Using various gambits, try to get a CV from an SV; in addition, try if
possible to set C<*st> and C<*gvp> to the stash and GV associated with it.

=cut
*/

d5157 2
a5158 2
    GV *gv = Nullgv;
    CV *cv = Nullcv;
a5229 2
Use the C<SvTRUE> macro instead, which may call C<sv_true()> or may
instead use an in-line version.
a5259 9
/*
=for apidoc sv_iv

A private implementation of the C<SvIVx> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

a5270 9
/*
=for apidoc sv_uv

A private implementation of the C<SvUVx> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

a5281 9
/*
=for apidoc sv_nv

A private implementation of the C<SvNVx> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

a5289 13
/*
=for apidoc sv_pv

Use the C<SvPV_nolen> macro instead

=for apidoc sv_pvn

A private implementation of the C<SvPV> macro for compilers which can't
cope with complex macro expressions. Always use the macro instead.

=cut
*/

d5291 1
a5291 1
Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp)
d5293 3
a5295 2
    if (SvPOK(sv)) {
	*lp = SvCUR(sv);
d5297 2
a5298 2
    }
    return sv_2pv(sv, lp);
a5300 1

d5302 1
a5302 1
Perl_sv_pvn_nomg(pTHX_ register SV *sv, STRLEN *lp)
d5308 1
a5308 1
    return sv_2pv_flags(sv, lp, 0);
a5314 11
A private implementation of the C<SvPV_force> macro for compilers which
can't cope with complex macro expressions. Always use the macro instead.

=for apidoc sv_pvn_force_flags

Get a sensible string out of the SV somehow.
If C<flags> has C<SV_GMAGIC> bit set, will C<mg_get> on C<sv> if
appropriate, else not. C<sv_pvn_force> and C<sv_pvn_force_nomg> are
implemented in terms of this function.
You normally want to use the various wrapper macros instead: see
C<SvPV_force> and C<SvPV_force_nomg>
d5320 1
a5320 1
Perl_sv_pvn_force_flags(pTHX_ SV *sv, STRLEN *lp, I32 flags)
d5322 1
a5322 1
    char *s = NULL;
d5326 1
a5326 1

d5333 1
a5333 1
		OP_NAME(PL_op));
d5336 1
a5336 1
	    s = sv_2pv_flags(sv, lp, flags);
d5339 1
a5339 1
	
d5358 5
a5362 13
/*
=for apidoc sv_pvbyte

Use C<SvPVbyte_nolen> instead.

=for apidoc sv_pvbyten

A private implementation of the C<SvPVbyte> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.

=cut
*/
a5366 1
    sv_utf8_downgrade(sv,0);
a5369 10
/*
=for apidoc sv_pvbyten_force

A private implementation of the C<SvPVbytex_force> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.

=cut
*/

a5372 1
    sv_utf8_downgrade(sv,0);
d5376 6
a5381 13
/*
=for apidoc sv_pvutf8

Use the C<SvPVutf8_nolen> macro instead

=for apidoc sv_pvutf8n

A private implementation of the C<SvPVutf8> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.

=cut
*/
d5393 2
a5394 3
A private implementation of the C<SvPVutf8_force> macro for compilers
which can't cope with complex macro expressions. Always use the macro
instead.
d5417 2
a5418 6
    if (ob && SvOBJECT(sv)) {
        HV *svs = SvSTASH(sv);
        /* [20011101.072] This bandaid for C<package;> should eventually
           be removed. AMS 20011103 */
        return (svs ? HvNAME(svs) : "<none>");
    }
a5596 19
=for apidoc sv_setref_uv

Copies an unsigned integer into a new SV, optionally blessing the SV.  The C<rv>
argument will be upgraded to an RV.  That RV will be modified to point to
the new SV.  The C<classname> argument indicates the package for the
blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV
will be returned and will have a reference count of 1.

=cut
*/

SV*
Perl_sv_setref_uv(pTHX_ SV *rv, const char *classname, UV uv)
{
    sv_setuv(newSVrv(rv,classname), uv);
    return rv;
}

/*
a5673 6
    if(SvSMAGICAL(tmpRef))
        if(mg_find(tmpRef, PERL_MAGIC_ext) || mg_find(tmpRef, PERL_MAGIC_uvar))
            mg_set(tmpRef);



a5676 3
/* Downgrades a PVGV to a PVMG.
 */

d5690 1
a5690 1
    sv_unmagic(sv, PERL_MAGIC_glob);
d5705 1
a5705 1
=for apidoc sv_unref_flags
d5709 1
a5709 5
as a reversal of C<newSVrv>.  The C<cflags> argument can contain
C<SV_IMMEDIATE_UNREF> to force the reference count to be decremented
(otherwise the decrementing is conditional on the reference count being
different from one or the reference being a readonly SV).
See C<SvROK_off>.
d5715 1
a5715 1
Perl_sv_unref_flags(pTHX_ SV *sv, U32 flags)
d5727 1
a5727 1
    if (SvREFCNT(rv) != 1 || SvREADONLY(rv) || flags) /* SV_IMMEDIATE_UNREF */
d5729 1
a5729 1
    else /* XXX Hack, but hard to make $a=$a->[1] work otherwise */
d5733 5
a5737 10
/*
=for apidoc sv_unref

Unsets the RV status of the SV, and decrements the reference count of
whatever was being referenced by the RV.  This can almost be thought of
as a reversal of C<newSVrv>.  This is C<sv_unref_flags> with the C<flag>
being zero.  See C<SvROK_off>.

=cut
*/
d5740 1
a5740 1
Perl_sv_unref(pTHX_ SV *sv)
d5742 5
a5746 1
    sv_unref_flags(sv, 0);
d5749 2
a5750 9
/*
=for apidoc sv_taint

Taint an SV. Use C<SvTAINTED_on> instead.
=cut
*/

void
Perl_sv_taint(pTHX_ SV *sv)
d5752 6
a5757 1
    sv_magic((sv), Nullsv, PERL_MAGIC_taint, Nullch, 0);
d5761 4
a5764 1
=for apidoc sv_untaint
a5765 1
Untaint an SV. Use C<SvTAINTED_off> instead.
d5770 1
a5770 1
Perl_sv_untaint(pTHX_ SV *sv)
d5772 5
a5776 5
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	MAGIC *mg = mg_find(sv, PERL_MAGIC_taint);
	if (mg)
	    mg->mg_len &= ~1;
    }
d5779 1
d5781 3
a5783 1
=for apidoc sv_tainted
a5784 1
Test an SV for taintedness. Use C<SvTAINTED> instead.
d5788 2
a5789 2
bool
Perl_sv_tainted(pTHX_ SV *sv)
d5791 6
a5796 6
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	MAGIC *mg = mg_find(sv, PERL_MAGIC_taint);
	if (mg && ((mg->mg_len & 1) || ((mg->mg_len & 2) && mg->mg_obj == sv)))
	    return TRUE;
    }
    return FALSE;
a5799 6

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

a5809 4
/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */
a5839 2
/* backend for C<sv_setpvf> and C<sv_setpvf_nocontext> */

a5862 2
/* backend for C<sv_setpvf_mg> C<setpvf_mg_nocontext> */

a5870 6

/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

a5880 5
/* pTHX_ magic can't cope with varargs, so this is a no-context
 * version of the main function, (which may itself be aliased to us).
 * Don't access this version directly.
 */

d5895 3
a5897 7
Processes its arguments like C<sprintf> and appends the formatted
output to an SV.  If the appended data contains "wide" characters
(including, but not limited to, SVs with a UTF-8 PV formatted with %s,
and characters >255 formatted with %c), the original SV might get
upgraded to UTF-8.  Handles 'get' magic, but not 'set' magic.
C<SvSETMAGIC()> must typically be called after calling this function
to handle 'set' magic.
d5899 2
a5900 1
=cut */
a5910 2
/* backend for C<sv_catpvf> and C<catpvf_mg_nocontext> */

a5933 2
/* backend for C<catpvf_mg> and C<catpvf_mg_nocontext> */

a5946 2
Usually used via one of its frontends C<sv_setpvf> and C<sv_setpvf_mg>.

a5956 17
/* private function for use in sv_vcatpvfn via the EXPECT_NUMBER macro */

STATIC I32
S_expect_number(pTHX_ char** pattern)
{
    I32 var = 0;
    switch (**pattern) {
    case '1': case '2': case '3':
    case '4': case '5': case '6':
    case '7': case '8': case '9':
	while (isDIGIT(**pattern))
	    var = var * 10 + (*(*pattern)++ - '0');
    }
    return var;
}
#define EXPECT_NUMBER(pattern, var) (var = S_expect_number(aTHX_ &pattern))

a5965 2
Usually used via one of its frontends C<sv_catpvf> and C<sv_catpvf_mg>.

d5978 1
a5978 2
    SV *argsv = Nullsv;
    bool has_utf8 = FALSE; /* has the result utf8? */
a6011 3
    if (!args && svix < svmax && DO_UTF8(*svargs))
        has_utf8 = TRUE;

d6017 1
a6017 2
	bool vectorarg = FALSE;
	bool vec_utf8 = FALSE;
d6025 2
a6026 2
	bool is_utf8 = FALSE;  /* is this item utf8?   */
	
d6040 1
a6040 1
	SV *vecsv = Nullsv;
d6043 1
a6043 1
	char c = 0;
d6045 3
a6047 9
	unsigned base = 0;
	IV iv = 0;
	UV uv = 0;
	/* we need a long double target in case HAS_LONG_DOUBLE but
	   not USE_LONG_DOUBLE
	*/
#if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE > DOUBLESIZE
	long double nv;
#else
a6048 1
#endif
a6053 5
	I32 efix = 0; /* explicit format parameter index */
	I32 ewix = 0; /* explicit width index */
	I32 epix = 0; /* explicit precision index */
	I32 evix = 0; /* explicit vector index */
	bool asterisk = FALSE;
a6054 1
	/* echo everything up to the next format specification */
a6062 19
/*
    We allow format specification elements in this order:
	\d+\$              explicit format parameter index
	[-+ 0#]+           flags
	v|\*(\d+\$)?v      vector with optional (optionally specified) arg
	\d+|\*(\d+\$)?     width using optional (optionally specified) arg
	\.(\d*|\*(\d+\$)?) precision using optional (optionally specified) arg
	[hlqLV]            size
    [%bcdefginopsux_DFOUX] format (mandatory)
*/
	if (EXPECT_NUMBER(q, width)) {
	    if (*q == '$') {
		++q;
		efix = width;
	    } else {
		goto gotwidth;
	    }
	}

d6086 20
d6112 1
a6112 23
      tryasterisk:
	if (*q == '*') {
	    q++;
	    if (EXPECT_NUMBER(q, ewix))
		if (*q++ != '$')
		    goto unknown;
	    asterisk = TRUE;
	}
	if (*q == 'v') {
	    q++;
	    if (vectorize)
		goto unknown;
	    if ((vectorarg = asterisk)) {
		evix = ewix;
		ewix = 0;
		asterisk = FALSE;
	    }
	    vectorize = TRUE;
	    goto tryasterisk;
	}

	if (!asterisk)
	    EXPECT_NUMBER(q, width);
d6114 8
a6121 26
	if (vectorize) {
	    if (vectorarg) {
		if (args)
		    vecsv = va_arg(*args, SV*);
		else
		    vecsv = (evix ? evix <= svmax : svix < svmax) ?
			svargs[ewix ? ewix-1 : svix++] : &PL_sv_undef;
		dotstr = SvPVx(vecsv, dotstrlen);
		if (DO_UTF8(vecsv))
		    is_utf8 = TRUE;
	    }
	    if (args) {
		vecsv = va_arg(*args, SV*);
		vecstr = (U8*)SvPVx(vecsv,veclen);
		vec_utf8 = DO_UTF8(vecsv);
	    }
	    else if (efix ? efix <= svmax : svix < svmax) {
		vecsv = svargs[efix ? efix-1 : svix++];
		vecstr = (U8*)SvPVx(vecsv,veclen);
		vec_utf8 = DO_UTF8(vecsv);
	    }
	    else {
		vecstr = (U8*)"";
		veclen = 0;
	    }
	}
d6123 1
a6123 1
	if (asterisk) {
d6127 1
a6127 2
		i = (ewix ? ewix <= svmax : svix < svmax) ?
		    SvIVx(svargs[ewix ? ewix-1 : svix++]) : 0;
d6130 2
a6132 1
      gotwidth:
a6138 6
		q++;
		if (EXPECT_NUMBER(q, epix) && *q++ != '$')
		    goto unknown;
		/* XXX: todo, support specified precision parameter */
		if (epix)
		    goto unknown;
d6142 1
a6142 2
		    i = (ewix ? ewix <= svmax : svix < svmax)
			? SvIVx(svargs[ewix ? ewix-1 : svix++]) : 0;
d6144 1
d6154 17
d6174 1
a6174 20
#ifdef WIN32
	case 'I':			/* Ix, I32x, and I64x */
#  ifdef WIN64
	    if (q[1] == '6' && q[2] == '4') {
		q += 3;
		intsize = 'q';
		break;
	    }
#  endif
	    if (q[1] == '3' && q[2] == '2') {
		q += 3;
		break;
	    }
#  ifdef WIN64
	    intsize = 'q';
#  endif
	    q++;
	    break;
#endif
#if defined(HAS_QUAD) || defined(HAS_LONG_DOUBLE)
d6177 1
a6179 1
#endif
d6185 1
a6185 1
#if defined(HAS_QUAD) || defined(HAS_LONG_DOUBLE)
a6201 12
	if (*q == '%') {
	    eptr = q++;
	    elen = 1;
	    goto string;
	}

	if (vectorize)
	    argsv = vecsv;
	else if (!args)
	    argsv = (efix ? efix <= svmax : svix < svmax) ?
		    svargs[efix ? efix-1 : svix++] : &PL_sv_undef;

d6206 5
d6212 5
a6216 4
	    uv = (args && !vectorize) ? va_arg(*args, int) : SvIVx(argsv);
	    if ((uv > 255 ||
		 (!UNI_IS_INVARIANT(uv) && SvUTF8(sv)))
		&& !IN_BYTES) {
d6218 2
a6219 2
		elen = uvchr_to_utf8((U8*)eptr, uv) - utf8buf;
		is_utf8 = TRUE;
d6229 1
a6229 1
	    if (args && !vectorize) {
d6244 2
a6245 1
	    else {
d6256 1
a6256 1
		    is_utf8 = TRUE;
d6267 1
a6267 1
	    if (!args || vectorize)
d6269 1
a6269 1
	    argsv = va_arg(*args, SV*);
d6272 1
a6272 1
		is_utf8 = TRUE;
d6283 1
a6283 1
	    if (alt || vectorize)
d6285 4
a6288 1
	    uv = PTR2UV(args ? va_arg(*args, void*) : argsv);
d6303 6
a6308 5
		if (!veclen)
		    continue;
		if (vec_utf8)
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
					UTF8_ALLOW_ANYUV);
d6310 1
a6310 1
		    uv = *vecstr;
a6314 2
		if (plus)
		     esignbuf[esignlen++] = plus;
d6328 1
a6328 1
		iv = SvIVx(argsv);
d6339 8
a6346 11
	    if ( !vectorize )	/* we already set uv above */
	    {
		if (iv >= 0) {
		    uv = iv;
		    if (plus)
			esignbuf[esignlen++] = plus;
		}
		else {
		    uv = -iv;
		    esignbuf[esignlen++] = '-';
		}
d6385 6
a6390 5
		if (!veclen)
		    continue;
		if (vec_utf8)
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
					UTF8_ALLOW_ANYUV);
d6410 1
a6410 1
		uv = SvUVx(argsv);
d6466 1
a6466 1
			Perl_warner(aTHX_ packWARN(WARN_Y2K),
d6498 5
a6502 37
	    /* for SV-style calling, we can only get NV
	       for C-style calling, we assume %f is double;
	       for simplicity we allow any of %Lf, %llf, %qf for long double
	    */
	    switch (intsize) {
	    case 'V':
#if defined(USE_LONG_DOUBLE)
		intsize = 'q';
#endif
		break;
	    default:
#if defined(USE_LONG_DOUBLE)
		intsize = args ? 0 : 'q';
#endif
		break;
	    case 'q':
#if defined(HAS_LONG_DOUBLE)
		break;
#else
		/* FALL THROUGH */
#endif
	    case 'h':
		/* FALL THROUGH */
	    case 'l':
		goto unknown;
	    }

	    /* now we need (long double) if intsize == 'q', else (double) */
	    nv = (args && !vectorize) ?
#if LONG_DOUBLESIZE > DOUBLESIZE
		intsize == 'q' ?
	            va_arg(*args, long double) :
	            va_arg(*args, double)
#else
	            va_arg(*args, double)
#endif
		: SvNVx(argsv);
a6504 1
	    vectorize = FALSE;
a6506 2
		/* FIXME: if HAS_LONG_DOUBLE but not USE_LONG_DOUBLE this
		   will cast our (long double) to (double) */
d6528 2
a6529 3
	    /* FIXME: what to do if HAS_LONG_DOUBLE but not PERL_PRIfldbl? */
#if defined(HAS_LONG_DOUBLE) && defined(PERL_PRIfldbl)
	    if (intsize == 'q') {
a6559 6
#if defined(HAS_LONG_DOUBLE)
	    if (intsize == 'q')
		(void)sprintf(PL_efloatbuf, eptr, nv);
	    else
		(void)sprintf(PL_efloatbuf, eptr, (double)nv);
#else
d6561 1
a6561 1
#endif
d6569 1
d6571 1
a6571 1
	    if (args && !vectorize) {
d6582 2
a6583 3
	    else
		sv_setuv_mg(argsv, (UV)i);
	    vectorize = FALSE;
d6598 1
a6598 1
			Perl_sv_catpvf(aTHX_ msg,
d6606 1
a6606 1
		Perl_warner(aTHX_ packWARN(WARN_PRINTF), "%"SVf, msg); /* yes, this is reentrant */
d6618 1
a6618 1
	    Copy(eptr, p, elen, char);
a6624 16
	if (is_utf8 != has_utf8) {
	     if (is_utf8) {
		  if (SvCUR(sv))
		       sv_utf8_upgrade(sv);
	     }
	     else {
		  SV *nsv = sv_2mortal(newSVpvn(eptr, elen));
		  sv_utf8_upgrade(nsv);
		  eptr = SvPVX(nsv);
		  elen = SvCUR(nsv);
	     }
	     SvGROW(sv, SvCUR(sv) + elen + 1);
	     p = SvEND(sv);
	     *p = '\0';
	}
	
d6632 1
a6632 1
	    for (i = 0; i < (int)esignlen; i++)
d6640 1
a6640 1
	    for (i = 0; i < (int)esignlen; i++)
d6648 1
a6648 1
	    Copy(eptr, p, elen, char);
d6657 1
a6657 1
		Copy(dotstr, p, dotstrlen, char);
d6663 1
a6663 3
	if (is_utf8)
	    has_utf8 = TRUE;
	if (has_utf8)
a6673 17
/* =========================================================================

=head1 Cloning an interpreter

All the macros and functions in this section are for the private use of
the main function, perl_clone().

The foo_dup() functions make an exact copy of an existing foo thinngy.
During the course of a cloning, a hash table is used to map old addresses
to new addresses. The table is created and manipulated with the
ptr_table_* functions.

=cut

============================================================================*/


d6676 2
a6677 2
#if defined(USE_5005THREADS)
#  include "error: USE_5005THREADS and USE_ITHREADS are incompatible"
d6685 11
a6695 11
#define sv_dup_inc(s,t)	SvREFCNT_inc(sv_dup(s,t))
#define av_dup(s,t)	(AV*)sv_dup((SV*)s,t)
#define av_dup_inc(s,t)	(AV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define hv_dup(s,t)	(HV*)sv_dup((SV*)s,t)
#define hv_dup_inc(s,t)	(HV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define cv_dup(s,t)	(CV*)sv_dup((SV*)s,t)
#define cv_dup_inc(s,t)	(CV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define io_dup(s,t)	(IO*)sv_dup((SV*)s,t)
#define io_dup_inc(s,t)	(IO*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define gv_dup(s,t)	(GV*)sv_dup((SV*)s,t)
#define gv_dup_inc(s,t)	(GV*)SvREFCNT_inc(sv_dup((SV*)s,t))
a6698 4

/* Duplicate a regexp. Required reading: pregcomp() and pregfree() in
   regcomp.c. AMS 20010712 */

d6700 1
a6700 1
Perl_re_dup(pTHX_ REGEXP *r, CLONE_PARAMS *param)
d6702 2
a6703 92
    REGEXP *ret;
    int i, len, npar;
    struct reg_substr_datum *s;

    if (!r)
	return (REGEXP *)NULL;

    if ((ret = (REGEXP *)ptr_table_fetch(PL_ptr_table, r)))
	return ret;

    len = r->offsets[0];
    npar = r->nparens+1;

    Newc(0, ret, sizeof(regexp) + (len+1)*sizeof(regnode), char, regexp);
    Copy(r->program, ret->program, len+1, regnode);

    New(0, ret->startp, npar, I32);
    Copy(r->startp, ret->startp, npar, I32);
    New(0, ret->endp, npar, I32);
    Copy(r->startp, ret->startp, npar, I32);

    New(0, ret->substrs, 1, struct reg_substr_data);
    for (s = ret->substrs->data, i = 0; i < 3; i++, s++) {
	s->min_offset = r->substrs->data[i].min_offset;
	s->max_offset = r->substrs->data[i].max_offset;
	s->substr     = sv_dup_inc(r->substrs->data[i].substr, param);
	s->utf8_substr = sv_dup_inc(r->substrs->data[i].utf8_substr, param);
    }

    ret->regstclass = NULL;
    if (r->data) {
	struct reg_data *d;
	int count = r->data->count;

	Newc(0, d, sizeof(struct reg_data) + count*sizeof(void *),
		char, struct reg_data);
	New(0, d->what, count, U8);

	d->count = count;
	for (i = 0; i < count; i++) {
	    d->what[i] = r->data->what[i];
	    switch (d->what[i]) {
	    case 's':
		d->data[i] = sv_dup_inc((SV *)r->data->data[i], param);
		break;
	    case 'p':
		d->data[i] = av_dup_inc((AV *)r->data->data[i], param);
		break;
	    case 'f':
		/* This is cheating. */
		New(0, d->data[i], 1, struct regnode_charclass_class);
		StructCopy(r->data->data[i], d->data[i],
			    struct regnode_charclass_class);
		ret->regstclass = (regnode*)d->data[i];
		break;
	    case 'o':
		/* Compiled op trees are readonly, and can thus be
		   shared without duplication. */
		d->data[i] = (void*)OpREFCNT_inc((OP*)r->data->data[i]);
		break;
	    case 'n':
		d->data[i] = r->data->data[i];
		break;
	    }
	}

	ret->data = d;
    }
    else
	ret->data = NULL;

    New(0, ret->offsets, 2*len+1, U32);
    Copy(r->offsets, ret->offsets, 2*len+1, U32);

    ret->precomp        = SAVEPV(r->precomp);
    ret->refcnt         = r->refcnt;
    ret->minlen         = r->minlen;
    ret->prelen         = r->prelen;
    ret->nparens        = r->nparens;
    ret->lastparen      = r->lastparen;
    ret->lastcloseparen = r->lastcloseparen;
    ret->reganch        = r->reganch;

    ret->sublen         = r->sublen;

    if (RX_MATCH_COPIED(ret))
	ret->subbeg  = SAVEPV(r->subbeg);
    else
	ret->subbeg = Nullch;

    ptr_table_store(PL_ptr_table, r, ret);
    return ret;
a6705 2
/* duplicate a file handle */

d6707 1
a6707 1
Perl_fp_dup(pTHX_ PerlIO *fp, char type, CLONE_PARAMS *param)
d6719 1
a6719 1
    ret = PerlIO_fdupopen(aTHX_ fp, param, PERLIO_DUP_CLONE);
a6723 2
/* duplicate a directory handle */

a6732 2
/* duplicate a typeglob */

d6734 1
a6734 1
Perl_gp_dup(pTHX_ GP *gp, CLONE_PARAMS* param)
d6750 7
a6756 7
    ret->gp_sv		= sv_dup_inc(gp->gp_sv, param);
    ret->gp_io		= io_dup_inc(gp->gp_io, param);
    ret->gp_form	= cv_dup_inc(gp->gp_form, param);
    ret->gp_av		= av_dup_inc(gp->gp_av, param);
    ret->gp_hv		= hv_dup_inc(gp->gp_hv, param);
    ret->gp_egv	= gv_dup(gp->gp_egv, param);/* GvEGV is not refcounted */
    ret->gp_cv		= cv_dup_inc(gp->gp_cv, param);
a6763 2
/* duplicate a chain of magic */

d6765 1
a6765 1
Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS* param)
d6787 2
a6788 14
	if (mg->mg_type == PERL_MAGIC_qr) {
	    nmg->mg_obj	= (SV*)re_dup((REGEXP*)mg->mg_obj, param);
	}
	else if(mg->mg_type == PERL_MAGIC_backref) {
	     AV *av = (AV*) mg->mg_obj;
	     SV **svp;
	     I32 i;
	     nmg->mg_obj = (SV*)newAV();
	     svp = AvARRAY(av);
	     i = AvFILLp(av);
	     while (i >= 0) {
		  av_push((AV*)nmg->mg_obj,sv_dup(svp[i],param));
		  i--;
	     }
d6792 2
a6793 2
			      ? sv_dup_inc(mg->mg_obj, param)
			      : sv_dup(mg->mg_obj, param);
d6797 2
a6798 2
	if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
	    if (mg->mg_len > 0) {
d6800 1
a6800 3
		if (mg->mg_type == PERL_MAGIC_overload_table &&
			AMT_AMAGIC((AMT*)mg->mg_ptr))
		{
d6805 1
a6805 1
			namtp->table[i] = cv_dup_inc(amtp->table[i], param);
d6810 1
a6810 4
		nmg->mg_ptr	= (char*)sv_dup_inc((SV*)mg->mg_ptr, param);
	}
	if ((mg->mg_flags & MGf_DUP) && mg->mg_virtual && mg->mg_virtual->svt_dup) {
	    CALL_FPTR(nmg->mg_virtual->svt_dup)(aTHX_ nmg, param);
a6816 2
/* create a new pointer-mapping table */

a6827 2
/* map an existing pointer using a table */

a6841 2
/* add a new entry to a pointer-mapping table */

d6857 1
a6870 2
/* double the hash bucket size of an existing ptr table */

a6900 2
/* remove all the entries from a ptr table */

a6934 2
/* clear and free a ptr table */

a6949 93
/* attempt to make everything in the typeglob readonly */

STATIC SV *
S_gv_share(pTHX_ SV *sstr, CLONE_PARAMS *param)
{
    GV *gv = (GV*)sstr;
    SV *sv = &param->proto_perl->Isv_no; /* just need SvREADONLY-ness */

    if (GvIO(gv) || GvFORM(gv)) {
        GvUNIQUE_off(gv); /* GvIOs cannot be shared. nor can GvFORMs */
    }
    else if (!GvCV(gv)) {
        GvCV(gv) = (CV*)sv;
    }
    else {
        /* CvPADLISTs cannot be shared */
        if (!SvREADONLY(GvCV(gv)) && !CvXSUB(GvCV(gv))) {
            GvUNIQUE_off(gv);
        }
    }

    if (!GvUNIQUE(gv)) {
#if 0
        PerlIO_printf(Perl_debug_log, "gv_share: unable to share %s::%s\n",
                      HvNAME(GvSTASH(gv)), GvNAME(gv));
#endif
        return Nullsv;
    }

    /*
     * write attempts will die with
     * "Modification of a read-only value attempted"
     */
    if (!GvSV(gv)) {
        GvSV(gv) = sv;
    }
    else {
        SvREADONLY_on(GvSV(gv));
    }

    if (!GvAV(gv)) {
        GvAV(gv) = (AV*)sv;
    }
    else {
        SvREADONLY_on(GvAV(gv));
    }

    if (!GvHV(gv)) {
        GvHV(gv) = (HV*)sv;
    }
    else {
        SvREADONLY_on(GvAV(gv));
    }

    return sstr; /* he_dup() will SvREFCNT_inc() */
}

/* duplicate an SV of any type (including AV, HV etc) */

void
Perl_rvpv_dup(pTHX_ SV *dstr, SV *sstr, CLONE_PARAMS* param)
{
    if (SvROK(sstr)) {
        SvRV(dstr) = SvWEAKREF(sstr)
		     ? sv_dup(SvRV(sstr), param)
		     : sv_dup_inc(SvRV(sstr), param);
    }
    else if (SvPVX(sstr)) {
	/* Has something there */
	if (SvLEN(sstr)) {
	    /* Normal PV - clone whole allocated space */
	    SvPVX(dstr) = SAVEPVN(SvPVX(sstr), SvLEN(sstr)-1);
	}
	else {
	    /* Special case - not normally malloced for some reason */
	    if (SvREADONLY(sstr) && SvFAKE(sstr)) {
		/* A "shared" PV - clone it as unshared string */
		SvFAKE_off(dstr);
		SvREADONLY_off(dstr);
		SvPVX(dstr) = SAVEPVN(SvPVX(sstr), SvCUR(sstr));
	    }
	    else {
		/* Some other special case - random pointer */
		SvPVX(dstr) = SvPVX(sstr);		
            }
	}
    }
    else {
	/* Copy the Null */
	SvPVX(dstr) = SvPVX(sstr);
    }
}

d6951 1
a6951 1
Perl_sv_dup(pTHX_ SV *sstr, CLONE_PARAMS* param)
d6991 1
a6991 1
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d6997 6
a7002 1
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7009 6
a7014 1
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7022 6
a7027 1
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7035 8
a7042 3
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7050 8
a7057 3
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7068 8
a7075 3
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7078 1
a7078 1
	LvTARG(dstr)	= sv_dup_inc(LvTARG(sstr), param);
a7081 13
	if (GvUNIQUE((GV*)sstr)) {
            SV *share;
            if ((share = gv_share(sstr, param))) {
                del_SV(dstr);
                dstr = share;
                ptr_table_store(PL_ptr_table, sstr, dstr);
#if 0
                PerlIO_printf(Perl_debug_log, "sv_dup: sharing %s::%s\n",
                              HvNAME(GvSTASH(share)), GvNAME(share));
#endif
                break;
            }
	}
d7087 8
a7094 3
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
d7097 1
a7097 1
    	GvSTASH(dstr)	= hv_dup_inc(GvSTASH(sstr), param);
d7099 1
a7099 1
	GvGP(dstr)	= gp_dup(GvGP(sstr), param);
d7108 9
a7116 4
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	IoIFP(dstr)	= fp_dup(IoIFP(sstr), IoTYPE(sstr), param);
d7120 1
a7120 1
	    IoOFP(dstr)	= fp_dup(IoOFP(sstr), IoTYPE(sstr), param);
d7131 1
a7131 1
	IoTOP_GV(dstr)		= gv_dup(IoTOP_GV(sstr), param);
d7133 1
a7133 1
	IoFMT_GV(dstr)		= gv_dup(IoFMT_GV(sstr), param);
d7135 1
a7135 1
	IoBOTTOM_GV(dstr)	= gv_dup(IoBOTTOM_GV(sstr), param);
d7146 3
a7148 3
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	AvARYLEN((AV*)dstr) = sv_dup_inc(AvARYLEN((AV*)sstr), param);
d7161 1
a7161 1
		    *dst_ary++ = sv_dup_inc(*src_ary++, param);
d7165 1
a7165 1
		    *dst_ary++ = sv_dup(*src_ary++, param);
d7183 2
a7184 2
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
d7194 1
a7194 2
						    (bool)!!HvSHAREKEYS(sstr),
						    param);
d7197 1
a7197 2
	    dxhv->xhv_eiter = he_dup(sxhv->xhv_eiter,
				     (bool)!!HvSHAREKEYS(sstr), param);
a7204 3
    /* Record stashes for possible cloning in Perl_clone(). */
	if(HvNAME((HV*)dstr))
	    av_push(param->stashes, dstr);
d7213 1
a7213 1
        dup_pvcv:
d7218 7
a7224 4
	SvMAGIC(dstr)	= mg_dup(SvMAGIC(sstr), param);
	SvSTASH(dstr)	= hv_dup_inc(SvSTASH(sstr), param);
	Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	CvSTASH(dstr)	= hv_dup(CvSTASH(sstr), param); /* NOTE: not refcounted */
d7229 2
a7230 11
	if (CvCONST(sstr)) {
	    CvXSUBANY(dstr).any_ptr = GvUNIQUE(CvGV(sstr)) ?
                SvREFCNT_inc(CvXSUBANY(sstr).any_ptr) :
                sv_dup_inc(CvXSUBANY(sstr).any_ptr, param);
	}
	CvGV(dstr)	= gv_dup(CvGV(sstr), param);
	if (param->flags & CLONEf_COPY_STACKS) {
	  CvDEPTH(dstr)	= CvDEPTH(sstr);
	} else {
	  CvDEPTH(dstr) = 0;
	}
d7234 1
a7234 1
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr), param);
d7239 1
a7239 1
	    CvPADLIST(dstr)	= av_dup_inc(CvPADLIST(sstr), param);
d7241 1
a7241 1
	    CvOUTSIDE(dstr)	= cv_dup_inc(CvOUTSIDE(sstr), param);
d7243 1
a7243 1
	    CvOUTSIDE(dstr)	= cv_dup(CvOUTSIDE(sstr), param);
a7244 1
	CvFILE(dstr) = CvXSUB(sstr) ? CvFILE(sstr) : SAVEPV(CvFILE(sstr));
d7247 1
a7247 1
	Perl_croak(aTHX_ "Bizarre SvTYPE [%" IVdf "]", (IV)SvTYPE(sstr));
d7255 1
a7255 3
 }

/* duplicate a context */
d7258 1
a7258 1
Perl_cx_dup(pTHX_ PERL_CONTEXT *cxs, I32 ix, I32 max, CLONE_PARAMS* param)
d7292 2
a7293 2
					   ? cv_dup_inc(cx->blk_sub.cv, param)
					   : cv_dup(cx->blk_sub.cv,param));
d7295 1
a7295 1
					   ? av_dup_inc(cx->blk_sub.argarray, param)
d7297 1
a7297 1
		ncx->blk_sub.savearray	= av_dup_inc(cx->blk_sub.savearray, param);
d7305 1
a7305 1
		ncx->blk_eval.old_namesv = sv_dup_inc(cx->blk_eval.old_namesv, param);
d7307 1
a7307 1
		ncx->blk_eval.cur_text	= sv_dup(cx->blk_eval.cur_text, param);
d7317 1
a7317 1
					   : gv_dup((GV*)cx->blk_loop.iterdata, param));
d7321 3
a7323 3
		ncx->blk_loop.itersave	= sv_dup_inc(cx->blk_loop.itersave, param);
		ncx->blk_loop.iterlval	= sv_dup_inc(cx->blk_loop.iterlval, param);
		ncx->blk_loop.iterary	= av_dup_inc(cx->blk_loop.iterary, param);
d7328 3
a7330 3
		ncx->blk_sub.cv		= cv_dup(cx->blk_sub.cv, param);
		ncx->blk_sub.gv		= gv_dup(cx->blk_sub.gv, param);
		ncx->blk_sub.dfoutgv	= gv_dup_inc(cx->blk_sub.dfoutgv, param);
a7342 2
/* duplicate a stack info structure */

d7344 1
a7344 1
Perl_si_dup(pTHX_ PERL_SI *si, CLONE_PARAMS* param)
d7360 1
a7360 1
    nsi->si_stack	= av_dup_inc(si->si_stack, param);
d7363 1
a7363 1
    nsi->si_cxstack	= cx_dup(si->si_cxstack, si->si_cxix, si->si_cxmax, param);
d7365 2
a7366 2
    nsi->si_prev	= si_dup(si->si_prev, param);
    nsi->si_next	= si_dup(si->si_next, param);
a7389 4
/* map any object to the new equivent - either something in the
 * ptr table, or something in the interpreter structure
 */

d7405 2
a7406 2
	ret = (void*)(((char*)aTHX) + (((char*)v) - (char*)proto_perl));
    else {
a7407 1
    }
a7411 2
/* duplicate the save stack */

d7413 1
a7413 1
Perl_ss_dup(pTHX_ PerlInterpreter *proto_perl, CLONE_PARAMS* param)
d7429 1
a7429 1
    char *c = NULL;
d7431 1
a7431 1
    void (*dxptr) (pTHX_ void*);
d7442 1
a7442 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7444 1
a7444 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7448 1
a7448 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7450 1
a7450 1
	    TOPPTR(nss,ix) = gv_dup_inc(gv, param);
a7457 6
	case SAVEt_SHARED_PVREF:		/* char* in shared space */
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = savesharedpv(c);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    break;
d7461 1
a7461 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7467 1
a7467 1
	    TOPPTR(nss,ix) = av_dup_inc(av, param);
d7469 1
a7469 1
	    TOPPTR(nss,ix) = gv_dup(gv, param);
d7473 1
a7473 1
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
d7475 1
a7475 1
	    TOPPTR(nss,ix) = gv_dup(gv, param);
d7507 1
a7507 1
	    TOPPTR(nss,ix) = sv_dup(sv, param);
d7525 1
a7525 1
	    TOPPTR(nss,ix) = hv_dup(hv, param);
d7531 1
a7531 1
	    TOPPTR(nss,ix) = av_dup(av, param);
d7535 1
a7535 1
	    TOPPTR(nss,ix) = gv_dup(gv, param);
d7539 1
a7539 1
	    TOPPTR(nss,ix) = gp = gp_dup(gp, param);
d7542 1
a7542 1
	    TOPPTR(nss,ix) = gv_dup_inc(gv, param);
d7553 1
a7553 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7588 1
a7588 1
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
d7604 1
a7604 1
	    TOPDXPTR(nss,ix) = (void (*)(pTHX_ void*))any_dup((void *)dxptr, proto_perl);
d7618 1
a7618 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7622 1
a7622 1
	    TOPPTR(nss,ix) = av_dup_inc(av, param);
d7626 1
a7626 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7628 1
a7628 1
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d7630 1
a7630 1
	    TOPPTR(nss,ix) = hv_dup_inc(hv, param);
d7642 1
a7642 1
	    TOPPTR(nss,ix) = av_dup(av, param);
d7650 1
a7650 1
	    TOPPTR(nss,ix) = sv_dup(sv, param);
d7660 3
a7662 11
/*
=for apidoc perl_clone

Create and return a new interpreter by cloning the current one.

=cut
*/

/* XXX the above needs expanding by someone who actually understands it ! */
EXTERN_C PerlInterpreter *
perl_clone_host(PerlInterpreter* proto_perl, UV flags);
d7667 4
d7672 1
a7672 8

   /* perlhost.h so we need to call into it
   to clone the host, CPerlHost should have a c interface, sky */

   if (flags & CLONEf_CLONE_HOST) {
       return perl_clone_host(proto_perl,flags);
   }
   return perl_clone_using(proto_perl, flags,
d7697 5
a7701 3
    CLONE_PARAMS clone_params;
    CLONE_PARAMS* param = &clone_params;

d7705 2
a7706 2
#  ifdef DEBUGGING
    Poison(my_perl, 1, PerlInterpreter);
d7711 1
a7711 3
    PL_sig_pending = 0;
    Zero(&PL_debug_pad, 1, struct perl_debug_pad);
#  else	/* !DEBUGGING */
d7713 1
a7713 1
#  endif	/* DEBUGGING */
d7725 1
a7727 2
    CLONE_PARAMS clone_params;
    CLONE_PARAMS* param = &clone_params;
a7730 2


d7732 1
a7732 1
    Poison(my_perl, 1, PerlInterpreter);
a7736 2
    PL_sig_pending = 0;
    Zero(&PL_debug_pad, 1, struct perl_debug_pad);
a7740 2
    param->flags = flags;
    param->proto_perl = proto_perl;
a7777 4
#ifdef USE_REENTRANT_API
    Perl_reentrant_init(aTHX);
#endif

d7787 3
d7791 1
d7800 3
d7804 1
d7813 1
a7813 1
    /* create (a non-shared!) shared string table */
d7819 3
a7821 9
    PL_compiling = proto_perl->Icompiling;

    /* These two PVs will be free'd special way so must set them same way op.c does */
    PL_compiling.cop_stashpv = savesharedpv(PL_compiling.cop_stashpv);
    ptr_table_store(PL_ptr_table, proto_perl->Icompiling.cop_stashpv, PL_compiling.cop_stashpv);

    PL_compiling.cop_file    = savesharedpv(PL_compiling.cop_file);
    ptr_table_store(PL_ptr_table, proto_perl->Icompiling.cop_file, PL_compiling.cop_file);

d7824 1
a7824 3
	PL_compiling.cop_warnings = sv_dup_inc(PL_compiling.cop_warnings, param);
    if (!specialCopIO(PL_compiling.cop_io))
	PL_compiling.cop_io = sv_dup_inc(PL_compiling.cop_io, param);
d7835 3
a7837 11

    param->stashes      = newAV();  /* Setup array of objects to call clone on */

#ifdef PERLIO_LAYERS
    /* Clone PerlIO tables as soon as we can handle general xx_dup() */
    PerlIO_clone(aTHX_ proto_perl, param);
#endif

    PL_envgv		= gv_dup(proto_perl->Ienvgv, param);
    PL_incgv		= gv_dup(proto_perl->Iincgv, param);
    PL_hintgv		= gv_dup(proto_perl->Ihintgv, param);
d7839 2
a7840 2
    PL_diehook		= sv_dup_inc(proto_perl->Idiehook, param);
    PL_warnhook		= sv_dup_inc(proto_perl->Iwarnhook, param);
d7844 1
a7844 1
    PL_patchlevel	= sv_dup_inc(proto_perl->Ipatchlevel, param);
d7859 1
a7859 1
    PL_e_script		= sv_dup_inc(proto_perl->Ie_script, param);
a7861 1
    PL_exit_flags       = proto_perl->Iexit_flags;
d7866 1
a7866 1
    PL_formfeed		= sv_dup(proto_perl->Iformfeed, param);
a7873 26
    PL_encoding		= sv_dup(proto_perl->Iencoding, param);

    sv_setpvn(PERL_DEBUG_PAD(0), "", 0);	/* For regex debugging. */
    sv_setpvn(PERL_DEBUG_PAD(1), "", 0);	/* ext/re needs these */
    sv_setpvn(PERL_DEBUG_PAD(2), "", 0);	/* even without DEBUGGING. */

    /* Clone the regex array */
    PL_regex_padav = newAV();
    {
	I32 len = av_len((AV*)proto_perl->Iregex_padav);
	SV** regexen = AvARRAY((AV*)proto_perl->Iregex_padav);
	av_push(PL_regex_padav,
		sv_dup_inc(regexen[0],param));
	for(i = 1; i <= len; i++) {
            if(SvREPADTMP(regexen[i])) {
	      av_push(PL_regex_padav, sv_dup_inc(regexen[i], param));
            } else {
	        av_push(PL_regex_padav,
                    SvREFCNT_inc(
                        newSViv(PTR2IV(re_dup(INT2PTR(REGEXP *,
                             SvIVX(regexen[i])), param)))
                       ));
	    }
	}
    }
    PL_regex_pad = AvARRAY(PL_regex_padav);
d7876 6
a7881 6
    PL_stdingv		= gv_dup(proto_perl->Istdingv, param);
    PL_stderrgv		= gv_dup(proto_perl->Istderrgv, param);
    PL_defgv		= gv_dup(proto_perl->Idefgv, param);
    PL_argvgv		= gv_dup(proto_perl->Iargvgv, param);
    PL_argvoutgv	= gv_dup(proto_perl->Iargvoutgv, param);
    PL_argvout_stack	= av_dup_inc(proto_perl->Iargvout_stack, param);
d7884 1
a7884 1
    PL_replgv		= gv_dup(proto_perl->Ireplgv, param);
d7887 1
a7887 1
    PL_errgv		= gv_dup(proto_perl->Ierrgv, param);
d7890 8
a7897 8
    PL_DBgv		= gv_dup(proto_perl->IDBgv, param);
    PL_DBline		= gv_dup(proto_perl->IDBline, param);
    PL_DBsub		= gv_dup(proto_perl->IDBsub, param);
    PL_DBsingle		= sv_dup(proto_perl->IDBsingle, param);
    PL_DBtrace		= sv_dup(proto_perl->IDBtrace, param);
    PL_DBsignal		= sv_dup(proto_perl->IDBsignal, param);
    PL_lineary		= av_dup(proto_perl->Ilineary, param);
    PL_dbargs		= av_dup(proto_perl->Idbargs, param);
d7900 10
a7909 12
    PL_defstash		= hv_dup_inc(proto_perl->Tdefstash, param);
    PL_curstash		= hv_dup(proto_perl->Tcurstash, param);
    PL_nullstash       = hv_dup(proto_perl->Inullstash, param);
    PL_debstash		= hv_dup(proto_perl->Idebstash, param);
    PL_globalstash	= hv_dup(proto_perl->Iglobalstash, param);
    PL_curstname	= sv_dup_inc(proto_perl->Icurstname, param);

    PL_beginav		= av_dup_inc(proto_perl->Ibeginav, param);
    PL_beginav_save	= av_dup_inc(proto_perl->Ibeginav_save, param);
    PL_endav		= av_dup_inc(proto_perl->Iendav, param);
    PL_checkav		= av_dup_inc(proto_perl->Icheckav, param);
    PL_initav		= av_dup_inc(proto_perl->Iinitav, param);
d7917 1
a7917 1
    PL_fdpid		= av_dup_inc(proto_perl->Ifdpid, param);
d7928 1
a7928 1
    PL_main_cv		= cv_dup_inc(proto_perl->Imain_cv, param);
d7945 1
a7945 1
    PL_preambleav	= av_dup_inc(proto_perl->Ipreambleav, param);
d7950 2
a7951 1
    PL_ors_sv		= sv_dup_inc(proto_perl->Iors_sv, param);
d7962 1
a7962 3
    PL_modglobal	= hv_dup_inc(proto_perl->Imodglobal, param);
    PL_custom_op_names  = hv_dup_inc(proto_perl->Icustom_op_names,param);
    PL_custom_op_descs  = hv_dup_inc(proto_perl->Icustom_op_descs,param);
d7965 1
a7965 1
    PL_rsfp		= fp_dup(proto_perl->Irsfp, '<', param);
d7967 1
a7967 1
    PL_rsfp_filters	= av_dup_inc(proto_perl->Irsfp_filters, param);
d7969 3
a7971 3
    PL_compcv			= cv_dup(proto_perl->Icompcv, param);
    PL_comppad			= av_dup(proto_perl->Icomppad, param);
    PL_comppad_name		= av_dup(proto_perl->Icomppad_name, param);
d7983 1
a7983 1
    PL_DBcv		= cv_dup(proto_perl->IDBcv, param);
d8001 1
a8001 1
    PL_sh_path		= proto_perl->Ish_path; /* XXX never deallocated */
d8011 1
a8011 1
    PL_cshname		= proto_perl->Icshname; /* XXX never deallocated */
d8020 2
a8021 2
    PL_lex_stuff	= sv_dup_inc(proto_perl->Ilex_stuff, param);
    PL_lex_repl		= sv_dup_inc(proto_perl->Ilex_repl, param);
d8036 7
a8042 22
    /* XXX This is probably masking the deeper issue of why
     * SvANY(proto_perl->Ilinestr) can be NULL at this point. For test case:
     * http://archive.develooper.com/perl5-porters%40perl.org/msg83298.html
     * (A little debugging with a watchpoint on it may help.)
     */
    if (SvANY(proto_perl->Ilinestr)) {
	PL_linestr		= sv_dup_inc(proto_perl->Ilinestr, param);
	i = proto_perl->Ibufptr - SvPVX(proto_perl->Ilinestr);
	PL_bufptr		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ioldbufptr - SvPVX(proto_perl->Ilinestr);
	PL_oldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ioldoldbufptr - SvPVX(proto_perl->Ilinestr);
	PL_oldoldbufptr	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ilinestart - SvPVX(proto_perl->Ilinestr);
	PL_linestart	= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
    }
    else {
        PL_linestr = NEWSV(65,79);
        sv_upgrade(PL_linestr,SVt_PVIV);
        sv_setpvn(PL_linestr,"",0);
	PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart = SvPVX(PL_linestr);
    }
d8044 2
d8058 1
a8058 1
    PL_subname		= sv_dup_inc(proto_perl->Isubname, param);
d8066 5
a8070 13
    /* XXX See comment on SvANY(proto_perl->Ilinestr) above */
    if (SvANY(proto_perl->Ilinestr)) {
	i = proto_perl->Ilast_uni - SvPVX(proto_perl->Ilinestr);
	PL_last_uni		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	i = proto_perl->Ilast_lop - SvPVX(proto_perl->Ilinestr);
	PL_last_lop		= SvPVX(PL_linestr) + (i < 0 ? 0 : i);
	PL_last_lop_op	= proto_perl->Ilast_lop_op;
    }
    else {
	PL_last_uni	= SvPVX(PL_linestr);
	PL_last_lop	= SvPVX(PL_linestr);
	PL_last_lop_op	= 0;
    }
d8072 1
a8072 1
    PL_in_my_stash	= hv_dup(proto_perl->Iin_my_stash, param);
d8093 1
a8093 1
    PL_numeric_radix_sv	= sv_dup_inc(proto_perl->Inumeric_radix_sv, param);
d8097 17
a8113 20
    PL_utf8_alnum	= sv_dup_inc(proto_perl->Iutf8_alnum, param);
    PL_utf8_alnumc	= sv_dup_inc(proto_perl->Iutf8_alnumc, param);
    PL_utf8_ascii	= sv_dup_inc(proto_perl->Iutf8_ascii, param);
    PL_utf8_alpha	= sv_dup_inc(proto_perl->Iutf8_alpha, param);
    PL_utf8_space	= sv_dup_inc(proto_perl->Iutf8_space, param);
    PL_utf8_cntrl	= sv_dup_inc(proto_perl->Iutf8_cntrl, param);
    PL_utf8_graph	= sv_dup_inc(proto_perl->Iutf8_graph, param);
    PL_utf8_digit	= sv_dup_inc(proto_perl->Iutf8_digit, param);
    PL_utf8_upper	= sv_dup_inc(proto_perl->Iutf8_upper, param);
    PL_utf8_lower	= sv_dup_inc(proto_perl->Iutf8_lower, param);
    PL_utf8_print	= sv_dup_inc(proto_perl->Iutf8_print, param);
    PL_utf8_punct	= sv_dup_inc(proto_perl->Iutf8_punct, param);
    PL_utf8_xdigit	= sv_dup_inc(proto_perl->Iutf8_xdigit, param);
    PL_utf8_mark	= sv_dup_inc(proto_perl->Iutf8_mark, param);
    PL_utf8_toupper	= sv_dup_inc(proto_perl->Iutf8_toupper, param);
    PL_utf8_totitle	= sv_dup_inc(proto_perl->Iutf8_totitle, param);
    PL_utf8_tolower	= sv_dup_inc(proto_perl->Iutf8_tolower, param);
    PL_utf8_tofold	= sv_dup_inc(proto_perl->Iutf8_tofold, param);
    PL_utf8_idstart	= sv_dup_inc(proto_perl->Iutf8_idstart, param);
    PL_utf8_idcont	= sv_dup_inc(proto_perl->Iutf8_idcont, param);
a8134 7
    if (proto_perl->Ipsig_pend) {
	Newz(0, PL_psig_pend, SIG_SIZE, int);
    }
    else {
	PL_psig_pend	= (int*)NULL;
    }

d8136 6
a8141 5
	Newz(0, PL_psig_ptr,  SIG_SIZE, SV*);
	Newz(0, PL_psig_name, SIG_SIZE, SV*);
	for (i = 1; i < SIG_SIZE; i++) {
	    PL_psig_ptr[i]  = sv_dup_inc(proto_perl->Ipsig_ptr[i], param);
	    PL_psig_name[i] = sv_dup_inc(proto_perl->Ipsig_name[i], param);
d8159 1
a8159 1
	    PL_tmps_stack[i]	= sv_dup_inc(proto_perl->Ttmps_stack[i], param);
d8185 1
a8185 1
	Copy(proto_perl->Tretstack, PL_retstack, PL_retstack_ix, OP*);
d8188 1
a8188 1
	PL_curstackinfo		= si_dup(proto_perl->Tcurstackinfo, param);
d8191 2
a8192 2
	PL_curstack		= av_dup(proto_perl->Tcurstack, param);
	PL_mainstack		= av_dup(proto_perl->Tmainstack, param);
d8205 1
a8205 1
	PL_savestack		= ss_dup(proto_perl, param);
d8223 2
a8224 2
    PL_statgv		= gv_dup(proto_perl->Tstatgv, param);
    PL_statname		= sv_dup_inc(proto_perl->Tstatname, param);
d8231 6
a8236 4
    PL_rs		= sv_dup_inc(proto_perl->Trs, param);
    PL_last_in_gv	= gv_dup(proto_perl->Tlast_in_gv, param);
    PL_ofs_sv		= sv_dup_inc(proto_perl->Tofs_sv, param);
    PL_defoutgv		= gv_dup_inc(proto_perl->Tdefoutgv, param);
d8238 3
a8240 3
    PL_toptarget	= sv_dup_inc(proto_perl->Ttoptarget, param);
    PL_bodytarget	= sv_dup_inc(proto_perl->Tbodytarget, param);
    PL_formtarget	= sv_dup(proto_perl->Tformtarget, param);
d8251 1
a8251 1
    PL_errors		= sv_dup_inc(proto_perl->Terrors, param);
d8260 3
a8262 3
    PL_sortstash	= hv_dup(proto_perl->Tsortstash, param);
    PL_firstgv		= gv_dup(proto_perl->Tfirstgv, param);
    PL_secondgv		= gv_dup(proto_perl->Tsecondgv, param);
d8302 1
a8316 1
    PL_reg_match_utf8	= FALSE;
a8337 3
    /* Pluggable optimizer */
    PL_peepp		= proto_perl->Tpeepp;

d8343 3
a8345 21
    /* Call the ->CLONE method, if it exists, for each of the stashes
       identified by sv_dup() above.
    */
    while(av_len(param->stashes) != -1) {
        HV* stash = (HV*) av_shift(param->stashes);
	GV* cloner = gv_fetchmethod_autoload(stash, "CLONE", 0);
	if (cloner && GvCV(cloner)) {
	    dSP;
	    ENTER;
	    SAVETMPS;
	    PUSHMARK(SP);
           XPUSHs(sv_2mortal(newSVpv(HvNAME(stash), 0)));
	    PUTBACK;
	    call_sv((SV*)GvCV(cloner), G_DISCARD);
	    FREETMPS;
	    LEAVE;
	}
    }

    SvREFCNT_dec(param->stashes);

d8347 1
d8350 1
a8350 1
#endif /* USE_ITHREADS */
d8352 3
a8354 2
/*
=head1 Unicode Support
d8356 1
a8356 1
=for apidoc sv_recode_to_utf8
d8358 8
a8365 3
The encoding is assumed to be an Encode object, on entry the PV
of the sv is assumed to be octets in that encoding, and the sv
will be converted into Unicode (and UTF-8).
d8367 4
a8370 4
If the sv already is UTF-8 (or if it is not POK), or if the encoding
is not a reference, nothing is done to the sv.  If the encoding is not
an C<Encode::XS> Encoding object, bad things will happen.
(See F<lib/encoding.pm> and L<Encode>).
d8372 12
a8383 1
The PV of the sv is returned.
d8385 2
a8386 1
=cut */
d8388 3
a8390 2
char *
Perl_sv_recode_to_utf8(pTHX_ SV *sv, SV *encoding)
d8392 10
a8401 36
    if (SvPOK(sv) && !DO_UTF8(sv) && SvROK(encoding)) {
	  SV *uni;
	  STRLEN len;
	  char *s;
	  dSP;
	  ENTER;
	  SAVETMPS;
	  PUSHMARK(sp);
	  EXTEND(SP, 3);
	  XPUSHs(encoding);
	  XPUSHs(sv);
/* 
  NI-S 2002/07/09
  Passing sv_yes is wrong - it needs to be or'ed set of constants
  for Encode::XS, while UTf-8 decode (currently) assumes a true value means 
  remove converted chars from source.

  Both will default the value - let them.
  
	  XPUSHs(&PL_sv_yes);
*/
	  PUTBACK;
	  call_method("decode", G_SCALAR);
	  SPAGAIN;
	  uni = POPs;
	  PUTBACK;
	  s = SvPV(uni, len);
	  if (s != SvPVX(sv)) {
	       SvGROW(sv, len + 1);
	       Move(s, SvPVX(sv), len, char);
	       SvCUR_set(sv, len);
	       SvPVX(sv)[len] = 0;	
	  }
	  FREETMPS;
	  LEAVE;
	  SvUTF8_on(sv);
a8402 1
    return SvPVX(sv);
d8404 1
d8406 7
a8412 1

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d25 1
a26 17
#ifdef PERL_UTF8_CACHE_ASSERT
/* The cache element 0 is the Unicode offset;
 * the cache element 1 is the byte offset of the element 0;
 * the cache element 2 is the Unicode length of the substring;
 * the cache element 3 is the byte length of the substring;
 * The checking of the substring side would be good
 * but substr() has enough code paths to make my head spin;
 * if adding more checks watch out for the following tests:
 *   t/op/index.t t/op/length.t t/op/pat.t t/op/substr.t
 *   lib/utf8.t lib/Unicode/Collate/t/index.t
 * --jhi
 */
#define ASSERT_UTF8_CACHE(cache) \
	STMT_START { if (cache) { assert((cache)[0] <= (cache)[1]); } } STMT_END
#else
#define ASSERT_UTF8_CACHE(cache) NOOP
#endif
d158 1
a158 22
#ifdef DEBUG_LEAKING_SCALARS
/* provide a real function for a debugger to play with */
STATIC SV*
S_new_SV(pTHX)
{
    SV* sv;

    LOCK_SV_MUTEX;
    if (PL_sv_root)
	uproot_SV(sv);
    else
	sv = more_sv();
    UNLOCK_SV_MUTEX;
    SvANY(sv) = 0;
    SvREFCNT(sv) = 1;
    SvFLAGS(sv) = 0;
    return sv;
}
#  define new_SV(p) (p)=S_new_SV(aTHX)

#else
#  define new_SV(p) \
a169 1
#endif
a455 1
    PL_xiv_root = 0;
a461 1
    PL_xnv_root = 0;
a467 1
    PL_xrv_root = 0;
a473 1
    PL_xpv_root = 0;
a479 1
    PL_xpviv_root = 0;
a485 1
    PL_xpvnv_root = 0;
a491 1
    PL_xpvcv_root = 0;
a497 1
    PL_xpvav_root = 0;
a503 1
    PL_xpvhv_root = 0;
a509 1
    PL_xpvmg_root = 0;
a515 1
    PL_xpvlv_root = 0;
a521 1
    PL_xpvbm_root = 0;
a527 1
    PL_he_root = 0;
d1121 7
a1127 2
#define my_safemalloc(s)	(void*)safemalloc(s)
#define my_safefree(p)	safefree((char*)p)
d1573 1
a1573 1
#ifdef MYMALLOC
d2031 1
a2031 1
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv))))
d2262 1
a2262 1
                        Perl_croak(aTHX_ "sv_2iv assumed (U_V(fabs((double)SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
d2328 1
a2328 1
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv))))
d2549 1
a2549 1
                        Perl_croak(aTHX_ "sv_2uv assumed (U_V(fabs((double)SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%"NVgf" U_V is 0x%"UVxf", IV_MAX is 0x%"UVxf"\n", SvNVX(sv), U_V(SvNVX(sv)), (UV)IV_MAX);
d2616 1
a2616 1
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv))))
a2877 10
/* sv_2pv() is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_2pv(pTHX_ register SV *sv, STRLEN *lp)
{
    return sv_2pv_flags(sv, lp, SV_GMAGIC);
}

d2895 1
a2895 1
    SV *tsv, *origsv;
d2936 2
a2937 9
                (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
                char *pv = SvPV(tmpstr, *lp);
                if (SvUTF8(tmpstr))
                    SvUTF8_on(sv);
                else
                    SvUTF8_off(sv);
                return pv;
            }
	    origsv = sv;
d2948 2
a2949 1
			  == (SVs_OBJECT|SVs_SMG))
a3004 1
					break;
a3019 5

			if (re->reganch & ROPT_UTF8)
			    SvUTF8_on(origsv);
			else
			    SvUTF8_off(origsv);
d3035 1
a3035 5
		case SVt_PVLV:	s = SvROK(sv) ? "REF"
				/* tied lvalues should appear to be
				 * scalars for backwards compatitbility */
				: (LvTYPE(sv) == 't' || LvTYPE(sv) == 'T')
				    ? "SCALAR" : "LVALUE";	break;
d3195 22
a3216 8
    STRLEN len;
    char *s;
    s = SvPV(ssv,len);
    sv_setpvn(dsv,s,len);
    if (SvUTF8(ssv))
	SvUTF8_on(dsv);
    else
	SvUTF8_off(dsv);
d3223 1
a3223 1
May cause the SV to be downgraded from UTF-8 as a side-effect.
d3241 1
a3241 1
to its length.  May cause the SV to be downgraded from UTF-8 as a
d3259 2
a3260 2
Return a pointer to the UTF-8-encoded representation of the SV.
May cause the SV to be upgraded to UTF-8 as a side-effect.
d3277 2
a3278 2
Return a pointer to the UTF-8-encoded representation of the SV, and set *lp
to its length.  May cause the SV to be upgraded to UTF-8 as a side-effect.
a3337 11
/* sv_utf8_upgrade() is now a macro using sv_utf8_upgrade_flags();
 * this function provided for binary compatibility only
 */


STRLEN
Perl_sv_utf8_upgrade(pTHX_ register SV *sv)
{
    return sv_utf8_upgrade_flags(sv, SV_GMAGIC);
}

d3341 1
a3341 1
Convert the PV of an SV to its UTF-8-encoded form.
d3351 1
a3351 1
Convert the PV of an SV to its UTF-8-encoded form.
d3387 1
a3387 1
    if (PL_encoding && !(flags & SV_UTF8_NO_ENCODING))
d3421 1
a3421 1
Attempt to convert the PV of an SV from UTF-8-encoded to byte encoding.
d3464 1
a3464 1
Convert the PV of an SV to UTF-8-encoded, but then turn off the C<SvUTF8>
a3518 10
/* sv_setsv() is now a macro using Perl_sv_setsv_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_setsv(pTHX_ SV *dstr, register SV *sstr)
{
    sv_setsv_flags(dstr, sstr, SV_GMAGIC);
}

a3568 6
    if ( SvVOK(dstr) ) 
    {
	/* need to nuke the magic */
	mg_free(dstr);
	SvRMAGICAL_off(dstr);
    }
d3629 1
a3629 1
		 SvROK(sstr) && SvTYPE(SvRV(sstr)) == SVt_PVGV) {
d3747 1
a3747 1
			SAVEGENERICSV(GvAV(dstr));
d3759 1
a3759 1
			SAVEGENERICSV(GvHV(dstr));
d3777 1
a3777 1
			SAVEGENERICSV(GvCV(dstr));
d3827 1
a3827 1
			SAVEGENERICSV(GvIOp(dstr));
d3834 1
a3834 1
			SAVEGENERICSV(GvFORM(dstr));
d3841 1
a3841 1
			SAVEGENERICSV(GvSV(dstr));
d3854 2
a3949 6
	if ( SvVOK(sstr) ) {
	    MAGIC *smg = mg_find(sstr,PERL_MAGIC_vstring);
	    sv_magic(dstr, NULL, PERL_MAGIC_vstring,
		     smg->mg_ptr, smg->mg_len);
	    SvRMAGICAL_on(dstr);
	} 
d4177 1
a4177 1
	else if (IN_PERL_RUNTIME)
a4208 2
Beware: after this function returns, C<ptr> and SvPVX(sv) may no longer
refer to the same chunk of data.
d4217 1
a4219 1
    delta = ptr - SvPVX(sv);
d4233 1
a4233 4
	/* Same SvOOK_on but SvOOK_on does a SvIOK_off
	   and we do that anyway inside the SvNIOK_off
	*/
	SvFLAGS(sv) |= SVf_OOK; 
d4235 2
a4236 1
    SvNIOK_off(sv);
a4242 10
/* sv_catpvn() is now a macro using Perl_sv_catpvn_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_catpvn(pTHX_ SV *dsv, const char* sstr, STRLEN slen)
{
    sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC);
}

d4247 2
a4248 2
C<len> indicates number of bytes to copy.  If the SV has the UTF-8
status set, then the bytes appended should be valid UTF-8.
d4254 2
a4255 2
C<len> indicates number of bytes to copy.  If the SV has the UTF-8
status set, then the bytes appended should be valid UTF-8.
a4294 10
/* sv_catsv() is now a macro using Perl_sv_catsv_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_catsv(pTHX_ SV *dstr, register SV *sstr)
{
    sv_catsv_flags(dstr, sstr, SV_GMAGIC);
}

d4367 2
a4368 2
If the SV has the UTF-8 status set, then the bytes appended should be
valid UTF-8.  Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.
d4467 2
a4468 1
       have its REFCNT incremented to keep it in existence.
a4484 15

    /* Normal self-ties simply pass a null object, and instead of
       using mg_obj directly, use the SvTIED_obj macro to produce a
       new RV as needed.  For glob "self-ties", we are tieing the PVIO
       with an RV obj pointing to the glob containing the PVIO.  In
       this case, to avoid a reference loop, we need to weaken the
       reference.
    */

    if (how == PERL_MAGIC_tiedscalar && SvTYPE(sv) == SVt_PVIO &&
        obj && SvROK(obj) && GvIO(SvRV(obj)) == (IO*)sv)
    {
      sv_rvweaken(obj);
    }

d4519 1
a4519 1
	if (IN_PERL_RUNTIME
a4623 6
    case PERL_MAGIC_vstring:
	vtable = 0;
	break;
    case PERL_MAGIC_utf8:
        vtable = &PL_vtbl_utf8;
        break;
a4692 2
		else if (mg->mg_type == PERL_MAGIC_utf8 && mg->mg_ptr)
		    Safefree(mg->mg_ptr);
d4754 1
a4754 15
	/* av now has a refcnt of 2, which avoids it getting freed
	 * before us during global cleanup. The extra ref is removed
	 * by magic_killbackrefs() when tsv is being freed */
    }
    if (AvFILLp(av) >= AvMAX(av)) {
        SV **svp = AvARRAY(av);
        I32 i = AvFILLp(av);
        while (i >= 0) {
            if (svp[i] == &PL_sv_undef) {
                svp[i] = sv;        /* reuse the slot */
                return;
            }
            i--;
        }
        av_extend(av, AvFILLp(av)+1);
d4756 1
a4756 1
    AvARRAY(av)[++AvFILLp(av)] = sv; /* av_push() */
a4913 1
    SvREFCNT(nsv) = 0;
d4942 1
d4944 5
a4948 1

a4953 2
		    SV* tmpref = newRV(sv);
	            SvREADONLY_on(tmpref);   /* DESTROY() could be naughty */
d4956 1
d4959 1
a4959 1
		    PUSHs(tmpref);
d4961 2
a4962 3
		    call_sv((SV*)destructor, G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
		   
		    
a4965 7
		    if(SvREFCNT(tmpref) < 2) {
		        /* tmpref is not kept alive! */
		        SvREFCNT(sv)--;
			SvRV(tmpref) = 0;
			SvROK_off(tmpref);
		    }
		    SvREFCNT_dec(tmpref);
d4969 1
d5023 1
a5023 7
	if (LvTYPE(sv) == 'T') { /* for tie: return HE to pool */
	    SvREFCNT_dec(HeKEY_sv((HE*)LvTARG(sv)));
	    HeNEXT((HE*)LvTARG(sv)) = PL_hv_fetch_ent_mh;
	    PL_hv_fetch_ent_mh = (HE*)LvTARG(sv);
	}
	else if (LvTYPE(sv) != 't') /* unless tie: unrefcnted fake SV**  */
	    SvREFCNT_dec(LvTARG(sv));
d5172 1
a5172 3
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                        "Attempt to free unreferenced scalar: SV 0x%"UVxf,
                PTR2UV(sv));
d5225 1
a5225 1
UTF-8 bytes as a single character. Handles magic and type coercion.
a5229 7
/*
 * The length is cached in PERL_UTF8_magic, in the mg_len field.  Also the
 * mg_ptr is used, by sv_pos_u2b(), see the comments of S_utf8_mg_pos_init().
 * (Note that the mg_len is not the length of the mg_ptr field.)
 *
 */

d5240 1
a5240 1
	STRLEN len, ulen;
a5241 21
	MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : 0;

	if (mg && mg->mg_len != -1 && (mg->mg_len > 0 || len == 0)) {
	     ulen = mg->mg_len;
#ifdef PERL_UTF8_CACHE_ASSERT
	    assert(ulen == Perl_utf8_length(aTHX_ s, s + len));
#endif
        }
	else {
	     ulen = Perl_utf8_length(aTHX_ s, s + len);
	     if (!mg && !SvREADONLY(sv)) {
		  sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
		  mg = mg_find(sv, PERL_MAGIC_utf8);
		  assert(mg);
	     }
	     if (mg)
		  mg->mg_len = ulen;
	}
	return ulen;
    }
}
d5243 1
a5243 145
/* S_utf8_mg_pos_init() is used to initialize the mg_ptr field of
 * a PERL_UTF8_magic.  The mg_ptr is used to store the mapping
 * between UTF-8 and byte offsets.  There are two (substr offset and substr
 * length, the i offset, PERL_MAGIC_UTF8_CACHESIZE) times two (UTF-8 offset
 * and byte offset) cache positions.
 *
 * The mg_len field is used by sv_len_utf8(), see its comments.
 * Note that the mg_len is not the length of the mg_ptr field.
 *
 */
STATIC bool
S_utf8_mg_pos_init(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i, I32 *offsetp, U8 *s, U8 *start)
{
    bool found = FALSE; 

    if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
        if (!*mgp) {
            sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
            *mgp = mg_find(sv, PERL_MAGIC_utf8);
        }
        assert(*mgp);

        if ((*mgp)->mg_ptr)
            *cachep = (STRLEN *) (*mgp)->mg_ptr;
        else {
            Newz(0, *cachep, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
            (*mgp)->mg_ptr = (char *) *cachep;
        }
        assert(*cachep);

        (*cachep)[i]   = *offsetp;
        (*cachep)[i+1] = s - start;
        found = TRUE;
    }

    return found;
}

/*
 * S_utf8_mg_pos() is used to query and update mg_ptr field of
 * a PERL_UTF8_magic.  The mg_ptr is used to store the mapping
 * between UTF-8 and byte offsets.  See also the comments of
 * S_utf8_mg_pos_init().
 *
 */
STATIC bool
S_utf8_mg_pos(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i, I32 *offsetp, I32 uoff, U8 **sp, U8 *start, U8 *send)
{
    bool found = FALSE;

    if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
        if (!*mgp)
            *mgp = mg_find(sv, PERL_MAGIC_utf8);
        if (*mgp && (*mgp)->mg_ptr) {
            *cachep = (STRLEN *) (*mgp)->mg_ptr;
	    ASSERT_UTF8_CACHE(*cachep);
            if ((*cachep)[i] == (STRLEN)uoff)	/* An exact match. */
		 found = TRUE;
	    else {			/* We will skip to the right spot. */
		 STRLEN forw  = 0;
		 STRLEN backw = 0;
		 U8* p = NULL;

		 /* The assumption is that going backward is half
		  * the speed of going forward (that's where the
		  * 2 * backw in the below comes from).  (The real
		  * figure of course depends on the UTF-8 data.) */

		 if ((*cachep)[i] > (STRLEN)uoff) {
		      forw  = uoff;
		      backw = (*cachep)[i] - (STRLEN)uoff;

		      if (forw < 2 * backw)
			   p = start;
		      else
			   p = start + (*cachep)[i+1];
		 }
		 /* Try this only for the substr offset (i == 0),
		  * not for the substr length (i == 2). */
		 else if (i == 0) { /* (*cachep)[i] < uoff */
		      STRLEN ulen = sv_len_utf8(sv);

		      if ((STRLEN)uoff < ulen) {
			   forw  = (STRLEN)uoff - (*cachep)[i];
			   backw = ulen - (STRLEN)uoff;

			   if (forw < 2 * backw)
				p = start + (*cachep)[i+1];
			   else
				p = send;
		      }

		      /* If the string is not long enough for uoff,
		       * we could extend it, but not at this low a level. */
		 }

		 if (p) {
		      if (forw < 2 * backw) {
			   while (forw--)
				p += UTF8SKIP(p);
		      }
		      else {
			   while (backw--) {
				p--;
				while (UTF8_IS_CONTINUATION(*p))
				     p--;
			   }
		      }

		      /* Update the cache. */
		      (*cachep)[i]   = (STRLEN)uoff;
		      (*cachep)[i+1] = p - start;

		      found = TRUE;
		 }
	    }
	    if (found) {	/* Setup the return values. */
		 *offsetp = (*cachep)[i+1];
		 *sp = start + *offsetp;
		 if (*sp >= send) {
		      *sp = send;
		      *offsetp = send - start;
		 }
		 else if (*sp < start) {
		      *sp = start;
		      *offsetp = 0;
		 }
	    }
	}
#ifdef PERL_UTF8_CACHE_ASSERT
	if (found) {
	     U8 *s = start;
	     I32 n = uoff;

	     while (n-- && s < send)
		  s += UTF8SKIP(s);

	     if (i == 0) {
		  assert(*offsetp == s - start);
		  assert((*cachep)[0] == (STRLEN)uoff);
		  assert((*cachep)[1] == *offsetp);
	     }
	     ASSERT_UTF8_CACHE(*cachep);
	}
#endif
a5244 2

    return found;
d5250 1
a5250 1
Converts the value pointed to by offsetp from a count of UTF-8 chars from
a5258 7
/*
 * sv_pos_u2b() uses, like sv_pos_b2u(), the mg_ptr of the potential
 * PERL_UTF8_magic of the sv to store the mapping between UTF-8 and
 * byte offsets.  See also the comments of S_utf8_mg_pos().
 *
 */

d5264 2
a5266 2
    STRLEN *cache = 0;
    STRLEN boffset = 0;
d5272 14
a5285 42
    if (len) {
	 I32 uoffset = *offsetp;
	 U8 *send = s + len;
	 MAGIC *mg = 0;
	 bool found = FALSE;

         if (utf8_mg_pos(sv, &mg, &cache, 0, offsetp, *offsetp, &s, start, send))
             found = TRUE;
	 if (!found && uoffset > 0) {
	      while (s < send && uoffset--)
		   s += UTF8SKIP(s);
	      if (s >= send)
		   s = send;
              if (utf8_mg_pos_init(sv, &mg, &cache, 0, offsetp, s, start))
                  boffset = cache[1];
	      *offsetp = s - start;
	 }
	 if (lenp) {
	      found = FALSE;
	      start = s;
              if (utf8_mg_pos(sv, &mg, &cache, 2, lenp, *lenp + *offsetp, &s, start, send)) {
                  *lenp -= boffset;
                  found = TRUE;
              }
	      if (!found && *lenp > 0) {
		   I32 ulen = *lenp;
		   if (ulen > 0)
			while (s < send && ulen--)
			     s += UTF8SKIP(s);
		   if (s >= send)
			s = send;
                   if (utf8_mg_pos_init(sv, &mg, &cache, 2, lenp, s, start))
			cache[2] += *offsetp;
	      }
	      *lenp = s - start;
	 }
	 ASSERT_UTF8_CACHE(cache);
    }
    else {
	 *offsetp = 0;
	 if (lenp)
	      *lenp = 0;
a5286 1

d5294 1
a5294 1
start of the string, to a count of the equivalent number of UTF-8 chars.
a5299 7
/*
 * sv_pos_b2u() uses, like sv_pos_u2b(), the mg_ptr of the potential
 * PERL_UTF8_magic of the sv to store the mapping between UTF-8 and
 * byte offsets.  See also the comments of S_utf8_mg_pos().
 *
 */

d5301 1
a5301 1
Perl_sv_pos_b2u(pTHX_ register SV* sv, I32* offsetp)
d5303 2
a5304 1
    U8* s;
d5313 14
a5326 89
    else {
	 U8* send = s + *offsetp;
	 MAGIC* mg = NULL;
	 STRLEN *cache = NULL;
      
	 len = 0;

	 if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
	      mg = mg_find(sv, PERL_MAGIC_utf8);
	      if (mg && mg->mg_ptr) {
		   cache = (STRLEN *) mg->mg_ptr;
                   if (cache[1] == (STRLEN)*offsetp) {
                        /* An exact match. */
                        *offsetp = cache[0];

			return;
		   }
		   else if (cache[1] < (STRLEN)*offsetp) {
			/* We already know part of the way. */
			len = cache[0];
			s  += cache[1];
			/* Let the below loop do the rest. */ 
		   }
		   else { /* cache[1] > *offsetp */
			/* We already know all of the way, now we may
			 * be able to walk back.  The same assumption
			 * is made as in S_utf8_mg_pos(), namely that
			 * walking backward is twice slower than
			 * walking forward. */
			STRLEN forw  = *offsetp;
			STRLEN backw = cache[1] - *offsetp;

			if (!(forw < 2 * backw)) {
			     U8 *p = s + cache[1];
			     STRLEN ubackw = 0;
			     
			     cache[1] -= backw;

			     while (backw--) {
			    p--;
			    while (UTF8_IS_CONTINUATION(*p)) {
				p--;
				backw--;
			    }
			    ubackw++;
			}

			cache[0] -= ubackw;
			*offsetp = cache[0];
			return;
		    }
		}
	    }
	    ASSERT_UTF8_CACHE(cache);
	 }

	 while (s < send) {
	      STRLEN n = 1;

	      /* Call utf8n_to_uvchr() to validate the sequence
	       * (unless a simple non-UTF character) */
	      if (!UTF8_IS_INVARIANT(*s))
		   utf8n_to_uvchr(s, UTF8SKIP(s), &n, 0);
	      if (n > 0) {
		   s += n;
		   len++;
	      }
	      else
		   break;
	 }

	 if (!SvREADONLY(sv)) {
	      if (!mg) {
		   sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
		   mg = mg_find(sv, PERL_MAGIC_utf8);
	      }
	      assert(mg);

	      if (!mg->mg_ptr) {
		   Newz(0, cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
		   mg->mg_ptr = (char *) cache;
	      }
	      assert(cache);

	      cache[0] = len;
	      cache[1] = *offsetp;
	 }

	 *offsetp = len;
d5328 1
a5328 1

a5644 1
    I32 recsize;
d5651 1
a5651 22
    if (append) {
	if (PerlIO_isutf8(fp)) {
	    if (!SvUTF8(sv)) {
		sv_utf8_upgrade_nomg(sv);
		sv_pos_u2b(sv,&append,0);
	    }
	} else if (SvUTF8(sv)) {
	    SV *tsv = NEWSV(0,0);
	    sv_gets(tsv, fp, 0);
	    sv_utf8_upgrade_nomg(tsv);
	    SvCUR_set(sv,append);
	    sv_catsv(sv,tsv);
	    sv_free(tsv);
	    goto return_string_or_null;
	}
    }

    SvPOK_only(sv);
    if (PerlIO_isutf8(fp))
	SvUTF8_on(sv);

    if (IN_PERL_COMPILETIME) {
a5656 12
    	/* If it is a regular disk file use size from stat() as estimate 
	   of amount we are going to read - may result in malloc-ing 
	   more memory than we realy need if layers bellow reduce 
	   size we read (e.g. CRLF or a gzip layer)
	 */
	Stat_t st;
	if (!PerlLIO_fstat(PerlIO_fileno(fp), &st) && S_ISREG(st.st_mode))  {
	    Off_t offset = PerlIO_tell(fp);
	    if (offset != (Off_t) -1 && st.st_size + append > offset) {
	     	(void) SvGROW(sv, (STRLEN)((st.st_size - offset) + append + 1));
	    }
	}
d5661 1
a5661 1
      I32 bytesread;
d5666 2
a5667 1
      buffer = SvGROW(sv, (STRLEN)(recsize + append + 1)) + append;
d5672 1
a5672 3
      /* doing, but we've got no other real choice - except avoid stdio
         as implementation - perhaps write a :vms layer ?
       */
d5677 1
a5677 3
      if (bytesread < 0)
	  bytesread = 0;
      SvCUR_set(sv, bytesread += append);
d5679 5
a5683 1
      goto return_string_or_null;
d5752 3
a5754 7
    /* make sure we have the room */
    if ((I32)(SvLEN(sv) - append) <= cnt + 1) { 
    	/* Not room for all of it
	   if we are looking for a separator and room for some 
	 */
	if (rslen && cnt > 80 && (I32)SvLEN(sv) > append) {
	    /* just process what we have room for */ 
d5764 1
a5764 1
    else 
d5863 3
a5865 15
       /*The big, slow, and stupid way. */

      /* Any stack-challenged places. */
#if defined(EPOC)
      /* EPOC: need to work around SDK features.         *
       * On WINS: MS VC5 generates calls to _chkstk,     *
       * if a "large" stack frame is allocated.          *
       * gcc on MARM does not generate calls like these. */
#   define USEHEAPINSTEADOFSTACK
#endif

#ifdef USEHEAPINSTEADOFSTACK
	STDCHAR *buf = 0;
	New(0, buf, 8192, STDCHAR);
	assert(buf);
d5867 5
a5871 1
	STDCHAR buf[8192];
a5919 4

#ifdef USEHEAPINSTEADOFSTACK
	Safefree(buf);
#endif
d5932 5
a5936 1
return_string_or_null:
d5963 1
a5963 1
	    if (IN_PERL_RUNTIME)
d6119 1
a6119 1
	    if (IN_PERL_RUNTIME)
a6610 1
#ifndef PERL_MICRO
a6620 1
#endif /* !PERL_MICRO */
d6665 1
a6665 1
	    Perl_croak(aTHX_ "Bad filehandle: %"SVf, sv);
d6746 1
a6746 2
		Perl_croak(aTHX_ "Unable to create sub named \"%"SVf"\"",
			   sv);
a6844 15
/* sv_pv() is now a macro using SvPV_nolen();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pv(pTHX_ SV *sv)
{
    STRLEN n_a;

    if (SvPOK(sv))
	return SvPVX(sv);

    return sv_2pv(sv, &n_a);
}

a6878 10
/* sv_pvn_force() is now a macro using Perl_sv_pvn_force_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvn_force(pTHX_ SV *sv, STRLEN *lp)
{
    return sv_pvn_force_flags(sv, lp, SV_GMAGIC);
}

a6936 11
/* sv_pvbyte () is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvbyte(pTHX_ SV *sv)
{
    sv_utf8_downgrade(sv,0);
    return sv_pv(sv);
}

a6974 11
/* sv_pvutf8 () is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvutf8(pTHX_ SV *sv)
{
    sv_utf8_upgrade(sv);
    return sv_pv(sv);
}

d7045 1
a7045 6
				
	case SVt_PVLV:		return SvROK(sv) ? "REF"
				/* tied lvalues should appear to be
				 * scalars for backwards compatitbility */
				: (LvTYPE(sv) == 't' || LvTYPE(sv) == 'T')
				    ? "SCALAR" : "LVALUE";
d7166 1
a7166 1
will have a reference count of 1, and the RV will be returned.
d7195 1
a7195 1
will have a reference count of 1, and the RV will be returned.
d7214 1
a7214 1
will have a reference count of 1, and the RV will be returned.
d7233 1
a7233 1
will have a reference count of 1, and the RV will be returned.
d7252 2
a7253 2
C<Nullch> to avoid the blessing.  The new SV will have a reference count 
of 1, and the RV will be returned.
d7370 1
a7370 3
    /* You can't have a || SvREADONLY(rv) here, as $a = $$a, where $a was
       assigned to as BEGIN {$a = \"Foo"} will fail.  */
    if (SvREFCNT(rv) != 1 || (flags & SV_IMMEDIATE_UNREF))
a7440 38
/*
=for apidoc sv_setpviv

Copies an integer into the given SV, also updating its string value.
Does not handle 'set' magic.  See C<sv_setpviv_mg>.

=cut
*/

void
Perl_sv_setpviv(pTHX_ SV *sv, IV iv)
{
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    sv_setpvn(sv, ptr, ebuf - ptr);
}

/*
=for apidoc sv_setpviv_mg

Like C<sv_setpviv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_setpviv_mg(pTHX_ SV *sv, IV iv)
{
    char buf[TYPE_CHARS(UV)];
    char *ebuf;
    char *ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);

    sv_setpvn(sv, ptr, ebuf - ptr);
    SvSETMAGIC(sv);
}

d7674 1
a7674 5
    bool has_utf8; /* has the result utf8? */
    bool pat_utf8; /* the pattern is in utf8? */
    SV *nsv = Nullsv;

    has_utf8 = pat_utf8 = DO_UTF8(sv);
d7709 1
a7709 1
	has_utf8 = TRUE;
a7724 1
	I32 osvix = svix;
d7726 1
a7726 6
#ifdef HAS_LDBL_SPRINTF_BUG
	/* This is to try to fix a bug with irix/nonstop-ux/powerux and
	   with sfio - Allen <allens@@cpan.org> */
	bool fix_ldbl_sprintf_bug = FALSE;
#endif

d7737 1
a7737 1
	/* large enough for "%#.#f" --chip */
d7770 1
a7770 4
	    if (has_utf8 && !pat_utf8)
		sv_catpvn_utf8_upgrade(sv, p, q - p, nsv);
	    else
		sv_catpvn(sv, p, q - p);
a7780 1
	0		   flag (as above): repeated to allow "v02" 	
a7845 2
	    if( *q == '0' ) 
		fill = *q++;
d7854 1
a7854 1
			svargs[evix ? evix-1 : svix++] : &PL_sv_undef;
d7946 1
a7946 1
	    if (*(q + 1) == 'l') {	/* lld, llf */
a8272 3
/* [perl #20339] - we should accept and ignore %lf rather than die */
	    case 'l':
		/* FALL THROUGH */
d8285 2
d8294 2
a8295 2
		    va_arg(*args, long double) :
		    va_arg(*args, double)
d8297 1
a8297 1
		    va_arg(*args, double)
a8313 1

a8316 66
#ifdef HAS_LDBL_SPRINTF_BUG
	    /* This is to try to fix a bug with irix/nonstop-ux/powerux and
	       with sfio - Allen <allens@@cpan.org> */

#  ifdef DBL_MAX
#    define MY_DBL_MAX DBL_MAX
#  else /* XXX guessing! HUGE_VAL may be defined as infinity, so not using */
#    if DOUBLESIZE >= 8
#      define MY_DBL_MAX 1.7976931348623157E+308L
#    else
#      define MY_DBL_MAX 3.40282347E+38L
#    endif
#  endif

#  ifdef HAS_LDBL_SPRINTF_BUG_LESS1 /* only between -1L & 1L - Allen */
#    define MY_DBL_MAX_BUG 1L
#  else
#    define MY_DBL_MAX_BUG MY_DBL_MAX
#  endif

#  ifdef DBL_MIN
#    define MY_DBL_MIN DBL_MIN
#  else  /* XXX guessing! -Allen */
#    if DOUBLESIZE >= 8
#      define MY_DBL_MIN 2.2250738585072014E-308L
#    else
#      define MY_DBL_MIN 1.17549435E-38L
#    endif
#  endif

	    if ((intsize == 'q') && (c == 'f') &&
		((nv < MY_DBL_MAX_BUG) && (nv > -MY_DBL_MAX_BUG)) &&
		(need < DBL_DIG)) {
		/* it's going to be short enough that
		 * long double precision is not needed */

		if ((nv <= 0L) && (nv >= -0L))
		    fix_ldbl_sprintf_bug = TRUE; /* 0 is 0 - easiest */
		else {
		    /* would use Perl_fp_class as a double-check but not
		     * functional on IRIX - see perl.h comments */

		    if ((nv >= MY_DBL_MIN) || (nv <= -MY_DBL_MIN)) {
			/* It's within the range that a double can represent */
#if defined(DBL_MAX) && !defined(DBL_MIN)
			if ((nv >= ((long double)1/DBL_MAX)) ||
			    (nv <= (-(long double)1/DBL_MAX)))
#endif
			fix_ldbl_sprintf_bug = TRUE;
		    }
		}
		if (fix_ldbl_sprintf_bug == TRUE) {
		    double temp;

		    intsize = 0;
		    temp = (double)nv;
		    nv = (NV)temp;
		}
	    }

#  undef MY_DBL_MAX
#  undef MY_DBL_MAX_BUG
#  undef MY_DBL_MIN

#endif /* HAS_LDBL_SPRINTF_BUG */

d8397 1
d8401 2
a8402 2
		Perl_sv_setpvf(aTHX_ msg, "Invalid conversion in %sprintf: ",
			  (PL_op->op_type == OP_PRTF) ? "" : "s");
a8428 1
	    svix = osvix;
a8446 7
	/* Use memchr() instead of strchr(), as eptr is not guaranteed */
	/* to point to a null-terminated string.                       */
	if (left && ckWARN(WARN_PRINTF) && memchr(eptr, '\n', elen) && 
	    (PL_op->op_type == OP_PRTF || PL_op->op_type == OP_SPRINTF)) 
	    Perl_warner(aTHX_ packWARN(WARN_PRINTF),
		"Newline in left-justified string for %sprintf",
			(PL_op->op_type == OP_PRTF) ? "" : "s");
d8999 3
a9001 14
                if(SvPADTMP(sstr)) {
                    /* However, some of them live in the pad
                       and they should not have these flags
                       turned off */

                    SvPVX(dstr) = sharepvn(SvPVX(sstr), SvCUR(sstr),
                                           SvUVX(sstr));
                    SvUVX(dstr) = SvUVX(sstr);
                } else {

                    SvPVX(dstr) = SAVEPVN(SvPVX(sstr), SvCUR(sstr));
                    SvFAKE_off(dstr);
                    SvREADONLY_off(dstr);
                }
a9026 12
    if(param->flags & CLONEf_JOIN_IN) {
        /** We are joining here so we don't want do clone
	    something that is bad **/

        if(SvTYPE(sstr) == SVt_PVHV &&
	   HvNAME(sstr)) {
	    /** don't clone stashes if they already exist **/
	    HV* old_stash = gv_stashpv(HvNAME(sstr),0);
	    return (SV*) old_stash;
        }
    }

d9113 1
a9113 6
	if (LvTYPE(sstr) == 't') /* for tie: unrefcnted fake (SV**) */
	    LvTARG(dstr) = dstr;
	else if (LvTYPE(sstr) == 'T') /* for tie: fake HE */
	    LvTARG(dstr) = (SV*)he_dup((HE*)LvTARG(sstr), 0, param);
	else
	    LvTARG(dstr) = sv_dup_inc(LvTARG(sstr), param);
a9167 12
        if(IoFLAGS(sstr) & IOf_FAKE_DIRP) { 
            /* I have no idea why fake dirp (rsfps)
               should be treaded differently but otherwise
               we end up with leaks -- sky*/
            IoTOP_GV(dstr)      = gv_dup_inc(IoTOP_GV(sstr), param);
            IoFMT_GV(dstr)      = gv_dup_inc(IoFMT_GV(sstr), param);
            IoBOTTOM_GV(dstr)   = gv_dup_inc(IoBOTTOM_GV(sstr), param);
        } else {
            IoTOP_GV(dstr)      = gv_dup(IoTOP_GV(sstr), param);
            IoFMT_GV(dstr)      = gv_dup(IoFMT_GV(sstr), param);
            IoBOTTOM_GV(dstr)   = gv_dup(IoBOTTOM_GV(sstr), param);
        }
d9169 1
d9171 1
d9173 1
d9280 13
a9292 6
	PAD_DUP(CvPADLIST(dstr), CvPADLIST(sstr), param);
	CvOUTSIDE_SEQ(dstr) = CvOUTSIDE_SEQ(sstr);
	CvOUTSIDE(dstr)	=
		CvWEAKOUTSIDE(sstr)
			? cv_dup(    CvOUTSIDE(sstr), param)
			: cv_dup_inc(CvOUTSIDE(sstr), param);
d9370 3
a9372 3
		ncx->blk_loop.oldcomppad
		    = (PAD*)ptr_table_fetch(PL_ptr_table,
					    cx->blk_loop.oldcomppad);
a9431 2
#define POPBOOL(ss,ix)	((ss)[--(ix)].any_bool)
#define TOPBOOL(ss,ix)	((ss)[ix].any_bool)
a9718 6
	case SAVEt_BOOL:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    longval = (long)POPBOOL(ss,ix);
	    TOPBOOL(nss,ix) = (bool)longval;
	    break;
a9731 29
perl_clone takes these flags as parameters:

CLONEf_COPY_STACKS - is used to, well, copy the stacks also, 
without it we only clone the data and zero the stacks, 
with it we copy the stacks and the new perl interpreter is 
ready to run at the exact same point as the previous one. 
The pseudo-fork code uses COPY_STACKS while the 
threads->new doesn't.

CLONEf_KEEP_PTR_TABLE
perl_clone keeps a ptr_table with the pointer of the old 
variable as a key and the new variable as a value, 
this allows it to check if something has been cloned and not 
clone it again but rather just use the value and increase the 
refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill 
the ptr_table using the function 
C<ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;>, 
reason to keep it around is if you want to dup some of your own 
variable who are outside the graph perl scans, example of this 
code is in threads.xs create

CLONEf_CLONE_HOST
This is a win32 thing, it is ignored on unix, it tells perls 
win32host code (which is c++) to clone itself, this is needed on 
win32 if you want to run two threads at the same time, 
if you just want to do some stuff in a separate perl interpreter 
and then throw it away and return to the original one, 
you don't need to do anything.

a9785 2
    PL_savestack_ix = 0;
    PL_savestack_max = -1;
a9816 2
    PL_savestack_ix = 0;
    PL_savestack_max = -1;
a9863 3
#ifdef DEBUGGING
    PERL_SET_CONTEXT(proto_perl);
#endif
d9918 6
a9923 1
    PL_origargv		= proto_perl->Iorigargv;
a10032 1
    PL_checkav_save	= av_dup_inc(proto_perl->Icheckav_save, param);
a10046 1
    PL_taint_warn       = proto_perl->Itaint_warn;
d10097 6
a10102 2

    PAD_CLONE_VARS(proto_perl, param);
d10121 1
d10128 1
a10128 1
    PL_sh_path_compat	= proto_perl->Ish_path_compat; /* XXX never deallocated */
d10200 6
a10265 34
    /* Did the locale setup indicate UTF-8? */
    PL_utf8locale	= proto_perl->Iutf8locale;
    /* Unicode features (see perlrun/-C) */
    PL_unicode		= proto_perl->Iunicode;

    /* Pre-5.8 signals control */
    PL_signals		= proto_perl->Isignals;

    /* times() ticks per second */
    PL_clocktick	= proto_perl->Iclocktick;

    /* Recursion stopper for PerlIO_find_layer */
    PL_in_load_module	= proto_perl->Iin_load_module;

    /* sort() routine */
    PL_sort_RealCmp	= proto_perl->Isort_RealCmp;

    /* Not really needed/useful since the reenrant_retint is "volatile",
     * but do it for consistency's sake. */
    PL_reentrant_retint	= proto_perl->Ireentrant_retint;

    /* Hooks to shared SVs and locks. */
    PL_sharehook	= proto_perl->Isharehook;
    PL_lockhook		= proto_perl->Ilockhook;
    PL_unlockhook	= proto_perl->Iunlockhook;
    PL_threadhook	= proto_perl->Ithreadhook;

    PL_runops_std	= proto_perl->Irunops_std;
    PL_runops_dbg	= proto_perl->Irunops_dbg;

#ifdef THREADS_HAVE_PIDS
    PL_ppid		= proto_perl->Ippid;
#endif

a10282 2
    PL_hash_seed	= proto_perl->Ihash_seed;
    PL_rehash_seed	= proto_perl->Irehash_seed;
d10407 3
a10409 1
    PL_hv_fetch_ent_mh	= Nullhe;
a10455 1
    PL_reglastcloseparen	= (U32*)NULL;
a10495 2
    PL_stashcache       = newHV();

d10548 11
a10558 12
    if (SvPOK(sv) && !SvUTF8(sv) && !IN_BYTES && SvROK(encoding)) {
	SV *uni;
	STRLEN len;
	char *s;
	dSP;
	ENTER;
	SAVETMPS;
	save_re_context();
	PUSHMARK(sp);
	EXTEND(SP, 3);
	XPUSHs(encoding);
	XPUSHs(sv);
d10567 1
a10567 1
	XPUSHs(&PL_sv_yes);
d10569 15
a10583 15
	PUTBACK;
	call_method("decode", G_SCALAR);
	SPAGAIN;
	uni = POPs;
	PUTBACK;
	s = SvPV(uni, len);
	if (s != SvPVX(sv)) {
	    SvGROW(sv, len + 1);
	    Move(s, SvPVX(sv), len, char);
	    SvCUR_set(sv, len);
	    SvPVX(sv)[len] = 0;	
	}
	FREETMPS;
	LEAVE;
	SvUTF8_on(sv);
a10587 10
/*
=for apidoc sv_cat_decode

The encoding is assumed to be an Encode object, the PV of the ssv is
assumed to be octets in that encoding and decoding the input starts
from the position which (PV + *offset) pointed to.  The dsv will be
concatenated the decoded UTF-8 string from ssv.  Decoding will terminate
when the string tstr appears in decoding output or the input ends on
the PV of the ssv. The value which the offset points will be modified
to the last input position on the ssv.
a10588 35
Returns TRUE if the terminator was found, else returns FALSE.

=cut */

bool
Perl_sv_cat_decode(pTHX_ SV *dsv, SV *encoding,
		   SV *ssv, int *offset, char *tstr, int tlen)
{
    bool ret = FALSE;
    if (SvPOK(ssv) && SvPOK(dsv) && SvROK(encoding) && offset) {
	SV *offsv;
	dSP;
	ENTER;
	SAVETMPS;
	save_re_context();
	PUSHMARK(sp);
	EXTEND(SP, 6);
	XPUSHs(encoding);
	XPUSHs(dsv);
	XPUSHs(ssv);
	XPUSHs(offsv = sv_2mortal(newSViv(*offset)));
	XPUSHs(sv_2mortal(newSVpvn(tstr, tlen)));
	PUTBACK;
	call_method("cat_decode", G_SCALAR);
	SPAGAIN;
	ret = SvTRUE(TOPs);
	*offset = SvIV(offsv);
	PUTBACK;
	FREETMPS;
	LEAVE;
    }
    else
        Perl_croak(aTHX_ "Invalid argument to sv_cat_decode");
    return ret;
}
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a4259 2
	    SvFAKE_off(sv);
	    SvREADONLY_off(sv);
d4263 2
a4651 1
	    && how != PERL_MAGIC_backref
d5449 5
a5453 3
	if (!*mgp)
	    *mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, &PL_vtbl_utf8, 0, 0);
	assert(*mgp);
a5545 6
		      /* Drop the stale "length" cache */
		      if (i == 0) {
			  (*cachep)[2] = 0;
			  (*cachep)[3] = 0;
		      }

d5692 3
a5694 3
	U8* send = s + *offsetp;
	MAGIC* mg = NULL;
	STRLEN *cache = NULL;
d5696 1
a5696 1
	len = 0;
d5698 7
a5704 7
	if (SvMAGICAL(sv) && !SvREADONLY(sv)) {
	    mg = mg_find(sv, PERL_MAGIC_utf8);
	    if (mg && mg->mg_ptr) {
		cache = (STRLEN *) mg->mg_ptr;
		if (cache[1] == (STRLEN)*offsetp) {
		    /* An exact match. */
		    *offsetp = cache[0];
d5706 20
a5725 20
		    return;
		}
		else if (cache[1] < (STRLEN)*offsetp) {
		    /* We already know part of the way. */
		    len = cache[0];
		    s  += cache[1];
		    /* Let the below loop do the rest. */ 
		}
		else { /* cache[1] > *offsetp */
		    /* We already know all of the way, now we may
		     * be able to walk back.  The same assumption
		     * is made as in S_utf8_mg_pos(), namely that
		     * walking backward is twice slower than
		     * walking forward. */
		    STRLEN forw  = *offsetp;
		    STRLEN backw = cache[1] - *offsetp;

		    if (!(forw < 2 * backw)) {
			U8 *p = s + cache[1];
			STRLEN ubackw = 0;
d5727 1
a5727 1
			cache[1] -= backw;
d5729 1
a5729 1
			while (backw--) {
d5747 2
a5748 2
	while (s < send) {
	    STRLEN n = 1;
d5750 11
a5760 11
	    /* Call utf8n_to_uvchr() to validate the sequence
	     * (unless a simple non-UTF character) */
	    if (!UTF8_IS_INVARIANT(*s))
		utf8n_to_uvchr(s, UTF8SKIP(s), &n, 0);
	    if (n > 0) {
		s += n;
		len++;
	    }
	    else
		break;
	}
d5762 6
a5767 6
	if (!SvREADONLY(sv)) {
	    if (!mg) {
		sv_magic(sv, 0, PERL_MAGIC_utf8, 0, 0);
		mg = mg_find(sv, PERL_MAGIC_utf8);
	    }
	    assert(mg);
d5769 5
a5773 5
	    if (!mg->mg_ptr) {
		Newz(0, cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
		mg->mg_ptr = (char *) cache;
	    }
	    assert(cache);
d5775 3
a5777 3
	    cache[0] = len;
	    cache[1] = *offsetp;
	}
d5779 1
a5779 1
	*offsetp = len;
d6100 1
a6100 7
    if (SvTHINKFIRST(sv))
	sv_force_normal_flags(sv, append ? 0 : SV_COW_DROP_PV);
    /* XXX. If you make this PVIV, then copy on write can copy scalars read
       from <>.
       However, perlbench says it's slower, because the existing swipe code
       is faster than copy on write.
       Swings and roundabouts.  */
a8242 27
static char *
F0convert(NV nv, char *endbuf, STRLEN *len)
{
    int neg = nv < 0;
    UV uv;
    char *p = endbuf;

    if (neg)
	nv = -nv;
    if (nv < UV_MAX) {
	nv += 0.5;
	uv = (UV)nv;
	if (uv & 1 && uv == nv)
	    uv--;			/* Round to even */
	do {
	    unsigned dig = uv % 10;
	    *--p = '0' + dig;
	} while (uv /= 10);
	if (neg)
	    *--p = '-';
	*len = endbuf - p;
	return p;
    }
    return Nullch;
}


a8269 6
    /* Times 4: a decimal digit takes more than 3 binary digits.
     * NV_DIG: mantissa takes than many decimal digits.
     * Plus 32: Playing safe. */
    char ebuf[IV_DIG * 4 + NV_DIG + 32];
    /* large enough for "%#.#f" --chip */
    /* what about long double NVs? --jhi */
a8304 42
#ifndef USE_LONG_DOUBLE
    /* special-case "%.<number>[gf]" */
    if ( patlen <= 5 && pat[0] == '%' && pat[1] == '.'
	 && (pat[patlen-1] == 'g' || pat[patlen-1] == 'f') ) {
	unsigned digits = 0;
	const char *pp;

	pp = pat + 2;
	while (*pp >= '0' && *pp <= '9')
	    digits = 10 * digits + (*pp++ - '0');
	if (pp - pat == (int)patlen - 1) {
	    NV nv;

	    if (args)
		nv = (NV)va_arg(*args, double);
	    else if (svix < svmax)
		nv = SvNV(*svargs);
	    else
		return;
	    if (*pp == 'g') {
		/* Add check for digits != 0 because it seems that some
		   gconverts are buggy in this case, and we don't yet have
		   a Configure test for this.  */
		if (digits && digits < sizeof(ebuf) - NV_DIG - 10) {
		     /* 0, point, slack */
		    Gconvert(nv, (int)digits, 0, ebuf);
		    sv_catpv(sv, ebuf);
		    if (*ebuf)	/* May return an empty string for digits==0 */
			return;
		}
	    } else if (!digits) {
		STRLEN l;

		if ((p = F0convert(nv, ebuf + sizeof ebuf, &l))) {
		    sv_catpvn(sv, p, l);
		    return;
		}
	    }
	}
    }
#endif /* !USE_LONG_DOUBLE */

d8336 7
d8691 1
a8693 1
		default:	iv = va_arg(*args, int); break;
d8700 1
a8700 1
		IV tiv = SvIVx(argsv); /* work around GCC bug #13488 */
d8702 4
a8705 4
		case 'h':	iv = (short)tiv; break;
		case 'l':	iv = (long)tiv; break;
		case 'V':
		default:	iv = tiv; break;
d8707 1
a8707 1
		case 'q':	iv = (Quad_t)tiv; break;
d8775 1
a8777 1
		default:   uv = va_arg(*args, unsigned); break;
d8779 1
a8779 1
		case 'q':  uv = va_arg(*args, Uquad_t); break;
d8784 1
a8784 1
		UV tuv = SvUVx(argsv); /* work around GCC bug #13488 */
d8786 4
a8789 4
		case 'h':	uv = (unsigned short)tuv; break;
		case 'l':	uv = (unsigned long)tuv; break;
		case 'V':
		default:	uv = tuv; break;
d8791 1
a8791 1
		case 'q':	uv = (Uquad_t)tuv; break;
a9001 13
	    if ( !(width || left || plus || alt) && fill != '0'
		 && has_precis && intsize != 'q' ) {	/* Shortcuts */
		/* See earlier comment about buggy Gconvert when digits,
		   aka precis is 0  */
		if ( c == 'g' && precis) {
		    Gconvert((NV)nv, (int)precis, 0, PL_efloatbuf);
		    if (*PL_efloatbuf)	/* May return an empty string for digits==0 */
			goto float_converted;
		} else if ( c == 'f' && !precis) {
		    if ((eptr = F0convert(nv, ebuf + sizeof ebuf, &elen)))
			break;
		}
	    }
a9045 1
	float_converted:
d9657 1
a9657 1
        SvREADONLY_on(GvHV(gv));
d10619 3
a10621 4
    /* XXX: things like -Dm will segfault here in perlio, but doing
     *  PERL_SET_CONTEXT(proto_perl);
     * breaks too many other things
     */
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a26 5
#ifdef __Lynx__
/* Missing proto on LynxOS */
  char *gconvert(double, int, int,  char *);
#endif

d242 2
a243 2
			    "Attempt to free non-arena SV: 0x%"UVxf
                            pTHX__FORMAT, PTR2UV(p) pTHX__VALUE);
d274 1
a287 1
	SvREFCNT(sv) = 0;
d317 1
a317 2
/* visit(): call the named function for each non-free SV in the arenas
 * whose flags field matches the flags/mask args. */
d320 1
a320 1
S_visit(pTHX_ SVFUNC_t f, U32 flags, U32 mask)
d330 1
a330 4
	    if (SvTYPE(sv) != SVTYPEMASK
		    && (sv->sv_flags & mask) == flags
		    && SvREFCNT(sv))
	    {
d365 1
a365 1
    visit(do_report_used, 0, 0);
a405 1
	    SvFLAGS(sv) |= SVf_BREAK;
d424 1
a424 1
    visit(do_clean_objs, SVf_ROK, SVf_ROK);
d427 1
a427 1
    visit(do_clean_named_objs, SVt_PVGV, SVTYPEMASK);
d457 1
a457 1
    cleaned = visit(do_clean_all, 0,0);
d1908 1
a1908 1
	return SvFLAGS(sv) & (SVf_NOK|SVp_NOK|SVf_IOK|SVp_IOK);
d3411 1
a3411 1
Converts the PV of an SV to its UTF-8-encoded form.
d3421 1
a3421 1
Converts the PV of an SV to its UTF-8-encoded form.
d3440 1
a3440 1
    if (sv == &PL_sv_undef)
d3442 1
d3445 3
a3447 7
	if (SvREADONLY(sv) && (SvPOKp(sv) || SvIOKp(sv) || SvNOKp(sv))) {
	    (void) sv_2pv_flags(sv,&len, flags);
	    if (SvUTF8(sv))
		return len;
	} else {
	    (void) SvPV_force(sv,len);
	}
d3450 1
a3450 1
    if (SvUTF8(sv)) {
a3451 1
    }
d3474 1
a3474 2
	      (void)SvOOK_off(sv);
	      s = (U8*)SvPVX(sv);
d3491 3
a3493 3
Attempts to convert the PV of an SV from characters to bytes.
If the PV contains a character beyond byte, this conversion will fail;
in this case, either returns false or, if C<fail_ok> is not
d3505 1
a3505 1
    if (SvPOKp(sv) && SvUTF8(sv)) {
d3534 3
a3536 2
Converts the PV of an SV to UTF-8, but then turns the C<SvUTF8>
flag off so that it looks like octets again.
a3544 6
    if (SvIsCOW(sv)) {
        sv_force_normal_flags(sv, 0);
    }
    if (SvREADONLY(sv)) {
	Perl_croak(aTHX_ PL_no_modify);
    }
d3551 3
a3553 5
If the PV of the SV is an octet sequence in UTF-8
and contains a multiple-byte character, the C<SvUTF8> flag is turned on
so that it looks like a character. If the PV contains only single-byte
characters, the C<SvUTF8> flag stays being off.
Scans PV for validity and returns false if the PV is invalid UTF-8.
d3561 1
a3561 1
    if (SvPOKp(sv)) {
d4100 1
a4100 2
bytes to be copied.  If the C<ptr> argument is NULL the SV will become
undefined.  Does not handle 'set' magic.  See C<sv_setpvn_mg>.
a4895 1
        I32 i;
d4897 3
a4899 2
        for (i = AvFILLp(av); i >= 0; i--)
            if (!svp[i]) {
d4903 2
d4926 7
a4932 2
    for (i = AvFILLp(av); i >= 0; i--)
	if (svp[i] == sv) svp[i] = Nullsv;
d5334 2
a5335 2
                        "Attempt to free unreferenced scalar: SV 0x%"UVxf
                        pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
d5345 2
a5346 2
			"Attempt to free temp prematurely: SV 0x%"UVxf
                        pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
d5651 2
a5652 1
                   utf8_mg_pos_init(sv, &mg, &cache, 2, lenp, s, start);
a5744 5

			/* Drop the stale "length" cache */
			cache[2] = 0;
			cache[3] = 0;

a5781 3
	    /* Drop the stale "length" cache */
	    cache[2] = 0;
	    cache[3] = 0;
d5840 1
a5840 2
	      if (cur1 != cur2) {
		   SvREFCNT_dec(svrecode);
a5841 1
	      }
d6773 1
a6773 3
statement boundaries.  SvTEMP() is turned on which means that the SV's
string buffer can be "stolen" if this SV is copied. See also C<sv_newmortal>
and C<sv_mortalcopy>.
d6819 1
a6819 1
C<len> bytes long.  If the C<s> argument is NULL the new SV will be undefined.
a7518 1
    sv_pvn_force(sv,lp);
d7520 1
a7520 2
    *lp = SvCUR(sv);
    return SvPVX(sv);
a7567 1
    sv_pvn_force(sv,lp);
d7569 1
a7569 2
    *lp = SvCUR(sv);
    return SvPVX(sv);
a9201 3
	/* calculate width before utf8_upgrade changes it */
	have = esignlen + zeros + elen;

d9225 1
d9399 1
a9399 1
    ret->precomp        = SAVEPVN(r->precomp, r->prelen);
d9411 1
a9411 1
	ret->subbeg  = SAVEPVN(r->subbeg, r->sublen);
d9512 10
a9521 9
	    AV *av = (AV*) mg->mg_obj;
	    SV **svp;
	    I32 i;
	    SvREFCNT_inc(nmg->mg_obj = (SV*)newAV());
	    svp = AvARRAY(av);
	    for (i = AvFILLp(av); i >= 0; i--) {
		if (!svp[i]) continue;
		av_push((AV*)nmg->mg_obj,sv_dup(svp[i],param));
	    }
a9567 6
#if (PTRSIZE == 8)
#  define PTR_TABLE_HASH(ptr) (PTR2UV(ptr) >> 3)
#else
#  define PTR_TABLE_HASH(ptr) (PTR2UV(ptr) >> 2)
#endif

d9574 1
a9574 1
    UV hash = PTR_TABLE_HASH(sv);
d9593 2
a9594 2
    UV hash = PTR_TABLE_HASH(oldv);
    bool empty = 1;
d9598 1
a9598 1
    for (tblent = *otblent; tblent; empty=0, tblent = tblent->next) {
d9610 1
a9610 1
    if (!empty && tbl->tbl_items > tbl->tbl_max)
d9634 1
a9634 1
	    if ((newsize & PTR_TABLE_HASH(ent->oldval)) != i) {
d10088 1
a10088 4
	/* don't dup if copying back - CvGV isn't refcounted, so the
	 * duped GV may never be freed. A bit of a hack! DAPM */
	CvGV(dstr)	= (param->flags & CLONEf_JOIN_IN) ?
		Nullgv : gv_dup(CvGV(sstr), param) ;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a1285 1

d1475 1
a1475 1
	AvFLAGS(sv)	= AVf_REAL;
d3255 1
d3257 1
a3257 1
	return strcpy(s, t);
d3642 2
a3643 3
C<ssv> if appropriate, else not. If the C<flags> parameter has the
C<NOSTEAL> bit set then the buffers of temps will not be stolen. <sv_setsv>
and C<sv_setsv_nomg> are implemented in terms of this function.
a4005 1
	    (!(flags & SV_NOSTEAL)) &&	/* and we're allowed to steal temps */
d4570 1
a4570 1
supplied vtable and returns a pointer to the magic added.
d4572 8
a4579 8
Note that C<sv_magicext> will allow things that C<sv_magic> will not.
In particular, you can add magic to SvREADONLY SVs, and add more than
one instance of the same 'how'.

If C<namlen> is greater than zero then a C<savepvn> I<copy> of C<name> is
stored, if C<namlen> is zero then C<name> is stored as-is and - as another
special case - if C<(name && namlen == HEf_SVKEY)> then C<name> is assumed
to contain an C<SV*> and is stored as-is with its REFCNT incremented.
d4581 1
a4581 1
(This is now used as a subroutine by C<sv_magic>.)
a4659 3
See C<sv_magicext> (which C<sv_magic> now calls) for a description of the
handling of the C<name> and C<namlen> arguments.

d5215 1
a5215 1
	SvOOK_off(sv);
d7135 1
a7135 1
		SvOK_off(sv);
d7735 1
a7735 1
	SvOOK_off(rv);
d7742 1
a7742 1
    SvOK_off(rv);
d8112 2
a8113 2
Works like C<sv_catpvf> but copies the text into the SV instead of
appending it.  Does not handle 'set' magic.  See C<sv_setpvf_mg>.
d8127 1
a8127 10
/*
=for apidoc sv_vsetpvf

Works like C<sv_vcatpvf> but copies the text into the SV instead of
appending it.  Does not handle 'set' magic.  See C<sv_vsetpvf_mg>.

Usually used via its frontend C<sv_setpvf>.

=cut
*/
d8152 1
a8152 9
/*
=for apidoc sv_vsetpvf_mg

Like C<sv_vsetpvf>, but also handles 'set' magic.

Usually used via its frontend C<sv_setpvf_mg>.

=cut
*/
d8201 3
a8203 2
upgraded to UTF-8.  Handles 'get' magic, but not 'set' magic.  See
C<sv_catpvf_mg>.
d8216 1
a8216 10
/*
=for apidoc sv_vcatpvf

Processes its arguments like C<vsprintf> and appends the formatted output
to an SV.  Does not handle 'set' magic.  See C<sv_vcatpvf_mg>.

Usually used via its frontend C<sv_catpvf>.

=cut
*/
d8241 1
a8241 9
/*
=for apidoc sv_vcatpvf_mg

Like C<sv_vcatpvf>, but also handles 'set' magic.

Usually used via its frontend C<sv_catpvf_mg>.

=cut
*/
d8253 1
a8253 1
Works like C<sv_vcatpvfn> but copies the text into the SV instead of
d8256 1
a8256 1
Usually used via one of its frontends C<sv_vsetpvf> and C<sv_vsetpvf_mg>.
d8321 1
a8321 1
Usually used via one of its frontends C<sv_vcatpvf> and C<sv_vcatpvf_mg>.
d10771 1
a10771 2
    SvFLAGS(&PL_sv_no)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
a10774 1
    SvIVX(&PL_sv_no)		= 0;
d10780 1
a10780 2
    SvFLAGS(&PL_sv_yes)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;
a10783 1
    SvIVX(&PL_sv_yes)		= 1;
a11500 1
	return SvPVX(sv);
d11502 1
a11502 1
    return SvPOKp(sv) ? SvPVX(sv) : NULL;
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d59 5
a63 5
Normally, this allocation is done using arenas, which by default are
approximately 4K chunks of memory parcelled up into N heads or bodies.  The
first slot in each arena is reserved, and is used to hold a link to the next
arena.  In the case of heads, the unused first slot also contains some flags
and a note of the number of slots.  Snaked through each arena chain is a
d65 2
a66 1
allocated and divided up into N items which are threaded into the free list.
d82 1
a82 2
or auto variables, eg PL_sv_undef.  The size of arenas can be changed from
the default by setting PERL_ARENA_SIZE appropriately at compile time.
a160 22
/*
 * nice_chunk and nice_chunk size need to be set
 * and queried under the protection of sv_mutex
 */
void
Perl_offer_nice_chunk(pTHX_ void *chunk, U32 chunk_size)
{
    void *new_chunk;
    U32 new_chunk_size;
    LOCK_SV_MUTEX;
    new_chunk = (void *)(chunk);
    new_chunk_size = (chunk_size);
    if (new_chunk_size > PL_nice_chunk_size) {
	Safefree(PL_nice_chunk);
	PL_nice_chunk = (char *) new_chunk;
	PL_nice_chunk_size = new_chunk_size;
    } else {
	Safefree(chunk);
    }
    UNLOCK_SV_MUTEX;
}

a177 22
/* make some more SVs by adding another arena */

/* sv_mutex must be held while calling more_sv() */
STATIC SV*
S_more_sv(pTHX)
{
    SV* sv;

    if (PL_nice_chunk) {
	sv_add_arena(PL_nice_chunk, PL_nice_chunk_size, 0);
	PL_nice_chunk = Nullch;
        PL_nice_chunk_size = 0;
    }
    else {
	char *chunk;                /* must use New here to match call to */
	Newx(chunk,PERL_ARENA_SIZE,char);   /* Safefree() in sv_free_arenas()     */
	sv_add_arena(chunk, PERL_ARENA_SIZE, 0);
    }
    uproot_SV(sv);
    return sv;
}

d191 1
a191 1
	sv = S_more_sv(aTHX);
d207 1
a207 1
	    (p) = S_more_sv(aTHX);			\
d235 3
a237 1
	bool ok = 0;
d239 3
a241 3
	    const SV * const sv = sva + 1;
	    const SV * const svend = &sva[SvREFCNT(sva)];
	    if (p >= sv && p < svend) {
a242 2
		break;
	    }
a291 1
#ifdef DEBUGGING
a292 3
#endif
	/* Must always set typemask because it's awlays checked in on cleanup
	   when the arenas are walked looking for objects.  */
a296 3
#ifdef DEBUGGING
    SvREFCNT(sv) = 0;
#endif
d300 22
d329 2
d334 1
a334 2
	register const SV * const svend = &sva[SvREFCNT(sva)];
	register SV* sv;
d390 1
a390 1
	    SvRV_set(sv, NULL);
d393 1
a393 1
	    SvRV_set(sv, NULL);
d408 1
a408 5
	if ((
#ifdef PERL_DONT_CREATE_GVSV
	     GvSV(sv) &&
#endif
	     SvOBJECT(GvSV(sv))) ||
d497 1
a497 1
	    Safefree(sva);
d591 2
a592 10
#if defined(USE_ITHREADS)
    for (arena = (XPV*)PL_pte_arenaroot; arena; arena = arenanext) {
	arenanext = (XPV*)arena->xpv_pv;
	Safefree(arena);
    }
    PL_pte_arenaroot = 0;
    PL_pte_root = 0;
#endif

    Safefree(PL_nice_chunk);
a616 274
/* allocate another arena's worth of struct xrv */

STATIC void
S_more_xrv(pTHX)
{
    XRV* xrv;
    XRV* xrvend;
    XPV *ptr;
    New(712, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xrv_arenaroot;
    PL_xrv_arenaroot = ptr;

    xrv = (XRV*) ptr;
    xrvend = &xrv[PERL_ARENA_SIZE / sizeof(XRV) - 1];
    xrv += (sizeof(XPV) - 1) / sizeof(XRV) + 1;
    PL_xrv_root = xrv;
    while (xrv < xrvend) {
	xrv->xrv_rv = (SV*)(xrv + 1);
	xrv++;
    }
    xrv->xrv_rv = 0;
}

/* allocate another arena's worth of IV bodies */

STATIC void
S_more_xiv(pTHX)
{
    IV* xiv;
    IV* xivend;
    XPV* ptr;
    New(705, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xiv_arenaroot;	/* linked list of xiv arenas */
    PL_xiv_arenaroot = ptr;			/* to keep Purify happy */

    xiv = (IV*) ptr;
    xivend = &xiv[PERL_ARENA_SIZE / sizeof(IV) - 1];
    xiv += (sizeof(XPV) - 1) / sizeof(IV) + 1;	/* fudge by size of XPV */
    PL_xiv_root = xiv;
    while (xiv < xivend) {
	*(IV**)xiv = (IV *)(xiv + 1);
	xiv++;
    }
    *(IV**)xiv = 0;
}

/* allocate another arena's worth of NV bodies */

STATIC void
S_more_xnv(pTHX)
{
    NV* xnv;
    NV* xnvend;
    XPV *ptr;
    New(711, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_xnv_arenaroot;
    PL_xnv_arenaroot = ptr;

    xnv = (NV*) ptr;
    xnvend = &xnv[PERL_ARENA_SIZE / sizeof(NV) - 1];
    xnv += (sizeof(XPVIV) - 1) / sizeof(NV) + 1; /* fudge by sizeof XPVIV */
    PL_xnv_root = xnv;
    while (xnv < xnvend) {
	*(NV**)xnv = (NV*)(xnv + 1);
	xnv++;
    }
    *(NV**)xnv = 0;
}

/* allocate another arena's worth of struct xpv */

STATIC void
S_more_xpv(pTHX)
{
    XPV* xpv;
    XPV* xpvend;
    New(713, xpv, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    xpv->xpv_pv = (char*)PL_xpv_arenaroot;
    PL_xpv_arenaroot = xpv;

    xpvend = &xpv[PERL_ARENA_SIZE / sizeof(XPV) - 1];
    PL_xpv_root = ++xpv;
    while (xpv < xpvend) {
	xpv->xpv_pv = (char*)(xpv + 1);
	xpv++;
    }
    xpv->xpv_pv = 0;
}

/* allocate another arena's worth of struct xpviv */

STATIC void
S_more_xpviv(pTHX)
{
    XPVIV* xpviv;
    XPVIV* xpvivend;
    New(714, xpviv, PERL_ARENA_SIZE/sizeof(XPVIV), XPVIV);
    xpviv->xpv_pv = (char*)PL_xpviv_arenaroot;
    PL_xpviv_arenaroot = xpviv;

    xpvivend = &xpviv[PERL_ARENA_SIZE / sizeof(XPVIV) - 1];
    PL_xpviv_root = ++xpviv;
    while (xpviv < xpvivend) {
	xpviv->xpv_pv = (char*)(xpviv + 1);
	xpviv++;
    }
    xpviv->xpv_pv = 0;
}

/* allocate another arena's worth of struct xpvnv */

STATIC void
S_more_xpvnv(pTHX) {
    XPVNV* xpvnv;
    XPVNV* xpvnvend;
    New(715, xpvnv, PERL_ARENA_SIZE/sizeof(XPVNV), XPVNV);
    xpvnv->xpv_pv = (char*)PL_xpvnv_arenaroot;
    PL_xpvnv_arenaroot = xpvnv;

    xpvnvend = &xpvnv[PERL_ARENA_SIZE / sizeof(XPVNV) - 1];
    PL_xpvnv_root = ++xpvnv;
    while (xpvnv < xpvnvend) {
	xpvnv->xpv_pv = (char*)(xpvnv + 1);
	xpvnv++;
    }
    xpvnv->xpv_pv = 0;
}

/* allocate another arena's worth of struct xpvcv */

STATIC void
S_more_xpvcv(pTHX)
{
    XPVCV* xpvcv;
    XPVCV* xpvcvend;
    New(716, xpvcv, PERL_ARENA_SIZE/sizeof(XPVCV), XPVCV);
    xpvcv->xpv_pv = (char*)PL_xpvcv_arenaroot;
    PL_xpvcv_arenaroot = xpvcv;

    xpvcvend = &xpvcv[PERL_ARENA_SIZE / sizeof(XPVCV) - 1];
    PL_xpvcv_root = ++xpvcv;
    while (xpvcv < xpvcvend) {
	xpvcv->xpv_pv = (char*)(xpvcv + 1);
	xpvcv++;
    }
    xpvcv->xpv_pv = 0;
}

/* allocate another arena's worth of struct xpvav */

STATIC void
S_more_xpvav(pTHX)
{
    XPVAV* xpvav;
    XPVAV* xpvavend;
    New(717, xpvav, PERL_ARENA_SIZE/sizeof(XPVAV), XPVAV);
    xpvav->xav_array = (char*)PL_xpvav_arenaroot;
    PL_xpvav_arenaroot = xpvav;

    xpvavend = &xpvav[PERL_ARENA_SIZE / sizeof(XPVAV) - 1];
    PL_xpvav_root = ++xpvav;
    while (xpvav < xpvavend) {
	xpvav->xav_array = (char*)(xpvav + 1);
	xpvav++;
    }
    xpvav->xav_array = 0;
}

/* allocate another arena's worth of struct xpvhv */

STATIC void
S_more_xpvhv(pTHX)
{
    XPVHV* xpvhv;
    XPVHV* xpvhvend;
    New(718, xpvhv, PERL_ARENA_SIZE/sizeof(XPVHV), XPVHV);
    xpvhv->xhv_array = (char*)PL_xpvhv_arenaroot;
    PL_xpvhv_arenaroot = xpvhv;

    xpvhvend = &xpvhv[PERL_ARENA_SIZE / sizeof(XPVHV) - 1];
    PL_xpvhv_root = ++xpvhv;
    while (xpvhv < xpvhvend) {
	xpvhv->xhv_array = (char*)(xpvhv + 1);
	xpvhv++;
    }
    xpvhv->xhv_array = 0;
}

/* allocate another arena's worth of struct xpvmg */

STATIC void
S_more_xpvmg(pTHX)
{
    XPVMG* xpvmg;
    XPVMG* xpvmgend;
    New(719, xpvmg, PERL_ARENA_SIZE/sizeof(XPVMG), XPVMG);
    xpvmg->xpv_pv = (char*)PL_xpvmg_arenaroot;
    PL_xpvmg_arenaroot = xpvmg;

    xpvmgend = &xpvmg[PERL_ARENA_SIZE / sizeof(XPVMG) - 1];
    PL_xpvmg_root = ++xpvmg;
    while (xpvmg < xpvmgend) {
	xpvmg->xpv_pv = (char*)(xpvmg + 1);
	xpvmg++;
    }
    xpvmg->xpv_pv = 0;
}

/* allocate another arena's worth of struct xpvlv */

STATIC void
S_more_xpvlv(pTHX)
{
    XPVLV* xpvlv;
    XPVLV* xpvlvend;
    New(720, xpvlv, PERL_ARENA_SIZE/sizeof(XPVLV), XPVLV);
    xpvlv->xpv_pv = (char*)PL_xpvlv_arenaroot;
    PL_xpvlv_arenaroot = xpvlv;

    xpvlvend = &xpvlv[PERL_ARENA_SIZE / sizeof(XPVLV) - 1];
    PL_xpvlv_root = ++xpvlv;
    while (xpvlv < xpvlvend) {
	xpvlv->xpv_pv = (char*)(xpvlv + 1);
	xpvlv++;
    }
    xpvlv->xpv_pv = 0;
}

/* allocate another arena's worth of struct xpvbm */

STATIC void
S_more_xpvbm(pTHX)
{
    XPVBM* xpvbm;
    XPVBM* xpvbmend;
    New(721, xpvbm, PERL_ARENA_SIZE/sizeof(XPVBM), XPVBM);
    xpvbm->xpv_pv = (char*)PL_xpvbm_arenaroot;
    PL_xpvbm_arenaroot = xpvbm;

    xpvbmend = &xpvbm[PERL_ARENA_SIZE / sizeof(XPVBM) - 1];
    PL_xpvbm_root = ++xpvbm;
    while (xpvbm < xpvbmend) {
	xpvbm->xpv_pv = (char*)(xpvbm + 1);
	xpvbm++;
    }
    xpvbm->xpv_pv = 0;
}

/* grab a new struct xrv from the free list, allocating more if necessary */

STATIC XRV*
S_new_xrv(pTHX)
{
    XRV* xrv;
    LOCK_SV_MUTEX;
    if (!PL_xrv_root)
	S_more_xrv(aTHX);
    xrv = PL_xrv_root;
    PL_xrv_root = (XRV*)xrv->xrv_rv;
    UNLOCK_SV_MUTEX;
    return xrv;
}

/* return a struct xrv to the free list */

STATIC void
S_del_xrv(pTHX_ XRV *p)
{
    LOCK_SV_MUTEX;
    p->xrv_rv = (SV*)PL_xrv_root;
    PL_xrv_root = p;
    UNLOCK_SV_MUTEX;
}

d625 1
a625 1
	S_more_xiv(aTHX);
d647 23
d678 1
a678 1
	S_more_xnv(aTHX);
d697 72
d777 1
a777 1
	S_more_xpv(aTHX);
d795 20
d823 1
a823 1
	S_more_xpviv(aTHX);
d841 20
d869 1
a869 1
	S_more_xpvnv(aTHX);
d887 20
d915 1
a915 1
	S_more_xpvcv(aTHX);
d933 20
d961 1
a961 1
	S_more_xpvav(aTHX);
d979 20
d1007 1
a1007 1
	S_more_xpvhv(aTHX);
d1025 20
d1053 1
a1053 1
	S_more_xpvmg(aTHX);
d1071 20
d1099 1
a1099 1
	S_more_xpvlv(aTHX);
d1117 20
d1145 1
a1145 1
	S_more_xpvbm(aTHX);
d1163 20
d1287 7
a1293 7
    char*	pv;
    U32		cur;
    U32		len;
    IV		iv;
    NV		nv;
    MAGIC*	magic;
    HV*		stash;
a1304 8
    pv = NULL;
    cur = 0;
    len = 0;
    iv = 0;
    nv = 0.0;
    magic = NULL;
    stash = Nullhv;

d1307 7
d1316 3
d1320 1
d1322 2
d1330 3
d1334 3
d1338 1
d1344 4
d1349 2
d1353 1
a1353 1
	pv	= SvPVX_mutable(sv);
d1356 4
d1367 1
a1367 1
	pv	= SvPVX_mutable(sv);
d1371 3
d1377 1
a1377 1
	pv	= SvPVX_mutable(sv);
d1382 2
d1387 1
a1387 9
	/* Because the XPVMG of PL_mess_sv isn't allocated from the arena,
	   there's no way that it can be safely upgraded, because perl.c
	   expects to Safefree(SvANY(PL_mess_sv))  */
	assert(sv != PL_mess_sv);
	/* This flag bit is used to mean other things in other scalar types.
	   Given that it only has meaning inside the pad, it shouldn't be set
	   on anything that can get upgraded.  */
	assert((SvFLAGS(sv) & SVpad_TYPED) == 0);
	pv	= SvPVX_mutable(sv);
a1399 3
    SvFLAGS(sv) &= ~SVTYPEMASK;
    SvFLAGS(sv) |= mt;

d1405 1
a1405 1
	SvIV_set(sv, iv);
d1409 1
a1409 1
	SvNV_set(sv, nv);
d1413 1
a1413 1
	SvRV_set(sv, (SV*)pv);
d1417 3
a1419 3
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
d1423 4
a1426 4
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
d1433 5
a1437 5
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
d1441 7
a1447 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1451 7
a1457 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1467 1
a1467 1
	SvPV_set(sv, (char*)0);
d1470 4
a1473 4
	SvIV_set(sv, 0);
	SvNV_set(sv, 0.0);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1482 1
a1482 1
	SvPV_set(sv, (char*)0);
d1486 3
a1488 3
	HvPLACEHOLDERS_set(sv, 0);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1497 7
a1503 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1507 7
a1513 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1522 7
a1528 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1536 7
a1542 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1547 7
a1553 7
	SvPV_set(sv, pv);
	SvCUR_set(sv, cur);
	SvLEN_set(sv, len);
	SvIV_set(sv, iv);
	SvNV_set(sv, nv);
	SvMAGIC_set(sv, magic);
	SvSTASH_set(sv, stash);
d1557 2
d1576 3
a1578 3
	const char * const s = SvPVX_const(sv);
	SvLEN_set(sv, SvLEN(sv) + SvIVX(sv));
	SvPV_set(sv, SvPVX(sv) - SvIVX(sv));
d1614 1
a1614 1
	s = SvPVX_mutable(sv);
d1618 1
a1618 1
	s = SvPVX_mutable(sv);
d1627 1
a1627 1
	s = SvPVX_mutable(sv);
a1629 1
	newlen = PERL_STRLEN_ROUNDUP(newlen);
d1632 1
a1632 1
	    const STRLEN l = malloced_size((void*)SvPVX_const(sv));
d1638 1
a1638 1
	    s = saferealloc(s, newlen);
d1640 1
a1640 1
	else {
d1647 3
a1649 3
	    s = safemalloc(newlen);
	    if (SvPVX_const(sv) && SvCUR(sv)) {
	        Move(SvPVX_const(sv), s, (newlen < SvCUR(sv)) ? newlen : SvCUR(sv), char);
d1693 1
a1693 1
    SvIV_set(sv, i);
d1738 1
a1738 1
    SvUV_set(sv, u);
d1752 15
a1766 3
    sv_setiv(sv, 0);
    SvIsUV_on(sv);
    sv_setuv(sv,u);
d1803 1
a1803 1
    SvNV_set(sv, num);
d1832 1
a1832 1
     const char *pv;
d1835 1
a1835 1
          dsv = sv_2mortal(newSVpvn("", 0));
d1839 1
a1839 1
	  const char * const limit = tmpbuf + sizeof(tmpbuf) - 8;
d1843 2
a1844 3
	  const char *s, *end;
	  for (s = SvPVX_const(sv), end = s + SvCUR(sv); s < end && d < limit;
	       s++) {
d1909 1
a1909 1
    register const char *sbegin;
d1913 1
a1913 1
	sbegin = SvPVX_const(sv);
d1917 1
a1917 1
	sbegin = SvPV_const(sv, len);
d2010 1
a2010 1
    DEBUG_c(PerlIO_printf(Perl_debug_log,"sv_2iuv_non '%s', IV=0x%"UVxf" NV=%"NVgf" inttype=%"UVXf"\n", SvPVX_const(sv), SvIVX(sv), SvNVX(sv), (UV)numtype));
d2014 1
a2014 1
	SvIV_set(sv, IV_MIN);
d2021 1
a2021 1
	SvUV_set(sv, UV_MAX);
d2029 1
a2029 1
        SvIV_set(sv, I_V(SvNVX(sv)));
d2038 1
a2038 1
    SvUV_set(sv, U_V(SvNVX(sv)));
d2079 1
a2079 1
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2086 6
a2091 8
	if (SvROK(sv)) {
	    if (SvAMAGIC(sv)) {
		SV * const tmpstr=AMG_CALLun(sv,numer);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvIV(tmpstr);
		}
	    }
	    return PTR2IV(SvRV(sv));
d2125 1
a2125 1
	    SvIV_set(sv, I_V(SvNVX(sv)));
d2163 1
a2163 1
	    SvUV_set(sv, U_V(SvNVX(sv)));
d2188 1
a2188 1
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
d2226 1
a2226 1
		    SvIV_set(sv, (IV)value);
d2228 1
a2228 1
		    SvUV_set(sv, value);
d2234 1
a2234 1
		    SvIV_set(sv, -(IV)value);
d2243 2
a2244 2
		    SvNV_set(sv, -(NV)value);
		    SvIV_set(sv, IV_MIN);
d2255 1
a2255 1
	    SvNV_set(sv, Atof(SvPVX_const(sv)));
d2273 1
a2273 1
		SvIV_set(sv, I_V(SvNVX(sv)));
d2284 1
a2284 1
		    SvUV_set(sv, UV_MAX);
d2287 1
a2287 1
		    SvUV_set(sv, U_V(SvNVX(sv)));
d2313 1
a2313 1
                    SvIV_set(sv, I_V(SvNVX(sv)));
d2339 1
a2339 1
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
d2376 1
a2376 1
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2419 1
a2419 1
	    SvIV_set(sv, I_V(SvNVX(sv)));
d2457 1
a2457 1
	    SvUV_set(sv, U_V(SvNVX(sv)));
d2480 1
a2480 1
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
d2516 1
a2516 1
		    SvIV_set(sv, (IV)value);
d2519 1
a2519 1
		    SvUV_set(sv, value);
d2525 1
a2525 1
		    SvIV_set(sv, -(IV)value);
d2534 2
a2535 2
		    SvNV_set(sv, -(NV)value);
		    SvIV_set(sv, IV_MIN);
d2543 1
a2543 1
	    SvNV_set(sv, Atof(SvPVX_const(sv)));
d2560 1
a2560 1
                SvIV_set(sv, I_V(SvNVX(sv)));
d2571 1
a2571 1
                    SvUV_set(sv, UV_MAX);
d2574 1
a2574 1
                    SvUV_set(sv, U_V(SvNVX(sv)));
d2600 1
a2600 1
                    SvIV_set(sv, I_V(SvNVX(sv)));
d2617 1
a2617 1
	    if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2651 2
a2652 2
	    if (!SvIOKp(sv) && ckWARN(WARN_NUMERIC) &&
		!grok_number(SvPVX_const(sv), SvCUR(sv), NULL))
d2654 1
a2654 1
	    return Atof(SvPVX_const(sv));
d2664 1
a2664 1
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2667 1
a2667 1
            return (NV)0;
d2715 1
a2715 1
	SvNV_set(sv, SvIsUV(sv) ? (NV)SvUVX(sv) : (NV)SvIVX(sv));
d2730 2
a2731 2
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
	if (!SvIOKp(sv) && !numtype && ckWARN(WARN_NUMERIC))
d2737 1
a2737 1
	    SvNV_set(sv, (numtype & IS_NUMBER_NEG) ? -(NV)value : (NV)value);
d2739 1
a2739 1
	    SvNV_set(sv, Atof(SvPVX_const(sv)));
d2742 1
a2742 1
	SvNV_set(sv, Atof(SvPVX_const(sv)));
d2766 1
a2766 1
                    SvIV_set(sv, -(IV)value);
d2768 1
a2768 1
		    SvIV_set(sv, (IV)value);
d2770 1
a2770 1
		    SvUV_set(sv, value);
d2781 1
a2781 1
		    const NV nv = SvNVX(sv);
d2797 1
a2797 1
			    const UV nv_as_uv = U_V(nv);
d2813 1
a2813 1
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
d2847 1
a2847 1
    const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
d2864 1
a2864 1
    return I_V(Atof(SvPVX_const(sv)));
d2874 1
a2874 1
    const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), &value);
d2886 1
a2886 1
    return U_V(Atof(SvPVX_const(sv)));
d2900 2
a2901 1
    return sv_2pv(sv, 0);
d2912 1
a2912 1
S_uiv_2buf(char *buf, IV iv, UV uv, int is_uv, char **peob)
d2915 1
a2915 1
    char * const ebuf = ptr;
d2968 2
a2969 3
	if (lp)
	    *lp = 0;
	return (char *)"";
d2975 1
a2975 6
	    if (lp)
		*lp = SvCUR(sv);
	    if (flags & SV_MUTABLE_RETURN)
		return SvPVX_mutable(sv);
	    if (flags & SV_CONST_RETURN)
		return (char *)SvPVX_const(sv);
d2993 1
a2993 1
		if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2996 2
a2997 3
	    if (lp)
		*lp = 0;
            return (char *)"";
a3002 1
            register const char *typestr;
d3005 1
a3005 16
		/* Unwrap this:  */
		/* char *pv = lp ? SvPV(tmpstr, *lp) : SvPV_nolen(tmpstr); */

                char *pv;
		if ((SvFLAGS(tmpstr) & (SVf_POK)) == SVf_POK) {
		    if (flags & SV_CONST_RETURN) {
			pv = (char *) SvPVX_const(tmpstr);
		    } else {
			pv = (flags & SV_MUTABLE_RETURN)
			    ? SvPVX_mutable(tmpstr) : SvPVX(tmpstr);
		    }
		    if (lp)
			*lp = SvCUR(tmpstr);
		} else {
		    pv = sv_2pv_flags(tmpstr, lp, flags);
		}
d3015 1
a3015 1
		typestr = "NULLREF";
d3025 1
a3025 1
                        const regexp *re = (regexp *)mg->mg_obj;
d3028 1
a3028 1
                            const char *fptr = "msix";
d3068 1
a3068 1
                                const char *endptr = re->precomp + re->prelen;
d3071 1
a3071 1
                                    const char c = *(endptr--);
d3084 1
a3084 1
			    Newx(mg->mg_ptr, mg->mg_len + 1 + left, char);
d3100 1
a3100 2
			if (lp)
			    *lp = mg->mg_len;
d3111 5
a3115 2
		case SVt_PVBM:	typestr = SvROK(sv) ? "REF" : "SCALAR"; break;
		case SVt_PVLV:	typestr = SvROK(sv) ? "REF"
d3120 7
a3126 7
		case SVt_PVAV:	typestr = "ARRAY";	break;
		case SVt_PVHV:	typestr = "HASH";	break;
		case SVt_PVCV:	typestr = "CODE";	break;
		case SVt_PVGV:	typestr = "GLOB";	break;
		case SVt_PVFM:	typestr = "FORMAT";	break;
		case SVt_PVIO:	typestr = "IO";		break;
		default:	typestr = "UNKNOWN";	break;
d3130 8
a3137 4
		    const char *name = HvNAME_get(SvSTASH(sv));
		    Perl_sv_setpvf(aTHX_ tsv, "%s=%s(0x%"UVxf")",
				   name ? name : "__ANON__" , typestr, PTR2UV(sv));
		}
d3139 2
a3140 1
		    Perl_sv_setpvf(aTHX_ tsv, "%s(0x%"UVxf")", typestr, PTR2UV(sv));
d3143 2
a3144 3
	    if (lp)
		*lp = strlen(typestr);
	    return (char *)typestr;
d3149 2
a3150 3
	    if (lp)
		*lp = 0;
	    return (char *)"";
d3156 2
a3157 2
	const U32 isIOK = SvIOK(sv);
	const U32 isUIOK = SvIsUV(sv);
d3167 2
a3168 3
	/* inlined from sv_setpvn */
	SvGROW_mutable(sv, (STRLEN)(ebuf - ptr + 1));
	Move(ptr,SvPVX_mutable(sv),ebuf - ptr,char);
d3183 2
a3184 1
	s = SvGROW_mutable(sv, NV_DIG + 20);
d3206 2
a3207 1
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
a3208 1
	if (lp)
d3213 1
a3213 7
	return (char *)"";
    }
    {
	const STRLEN len = s - SvPVX_const(sv);
	if (lp) 
	    *lp = len;
	SvCUR_set(sv, len);
d3215 2
d3219 1
a3219 5
			  PTR2UV(sv),SvPVX_const(sv)));
    if (flags & SV_CONST_RETURN)
	return (char *)SvPVX_const(sv);
    if (flags & SV_MUTABLE_RETURN)
	return SvPVX_mutable(sv);
d3230 1
a3230 2
	if (lp)
	    *lp = SvCUR(tsv);
d3234 2
a3235 2
    	STRLEN len;
        const char *t;
d3239 1
a3239 1
	    t = SvPVX_const(tsv);
d3253 2
a3254 3
	if (lp)
	    *lp = len;
	s = SvGROW_mutable(sv, len + 1);
d3257 1
a3257 1
	return memcpy(s, t, len + 1);
d3279 2
a3280 1
    const char * const s = SvPV_const(ssv,len);
d3302 2
a3303 1
    return sv_2pvbyte(sv, 0);
d3322 1
a3322 1
    return lp ? SvPV(sv,*lp) : SvPV_nolen(sv);
d3339 2
a3340 1
    return sv_2pvutf8(sv, 0);
d3358 1
a3358 1
    return lp ? SvPV(sv,*lp) : SvPV_nolen(sv);
d3386 2
a3387 2
	register XPV* const Xpvtmp = (XPV*)SvANY(sv);
	if (Xpvtmp &&
d3447 3
d3474 25
a3498 26
	/* This function could be much more efficient if we
	 * had a FLAG in SVs to signal if there are any hibit
	 * chars in the PV.  Given that there isn't such a flag
	 * make the loop as fast as possible. */
	const U8 *s = (U8 *) SvPVX_const(sv);
	const U8 *e = (U8 *) SvEND(sv);
	const U8 *t = s;
	int hibit = 0;
	
	while (t < e) {
	    const U8 ch = *t++;
	    if ((hibit = !NATIVE_IS_INVARIANT(ch)))
		break;
	}
	if (hibit) {
	    STRLEN len = SvCUR(sv) + 1; /* Plus the \0 */
	    U8 * const recoded = bytes_to_utf8((U8*)s, &len);

	    SvPV_free(sv); /* No longer using what was there before. */

	    SvPV_set(sv, (char*)recoded);
	    SvCUR_set(sv, len - 1);
	    SvLEN_set(sv, len); /* No longer know the real size. */
	}
	/* Mark as UTF-8 even if no hibit - saves scanning loop */
	SvUTF8_on(sv);
d3539 1
a3539 1
	    SvCUR_set(sv, len);
d3584 2
a3585 2
        const U8 *c;
        const U8 *e;
d3596 2
a3597 2
        c = (const U8 *) SvPVX_const(sv);
	if (!is_utf8_string((U8 *)c, SvCUR(sv)+1))
d3599 1
a3599 1
        e = (const U8 *) SvEND(sv);
d3601 1
a3601 1
	    const U8 ch = *c++;
d3704 1
a3704 1
	    SvIV_set(dstr,  SvIVX(sstr));
d3726 1
a3726 1
	    SvNV_set(dstr, SvNVX(sstr));
a3768 2
	{
	const char * const type = sv_reftype(sstr,0);
d3770 2
a3771 1
	    Perl_croak(aTHX_ "Bizarre copy of %s in %s", type, OP_NAME(PL_op));
d3773 1
a3773 2
	    Perl_croak(aTHX_ "Bizarre copy of %s", type);
	}
d3780 2
a3781 2
		const char * const name = GvNAME(sstr);
		const STRLEN len = GvNAMELEN(sstr);
d3837 1
a3837 1
		SV * const sref = SvREFCNT_inc(SvRV(sstr));
d3839 1
a3839 1
		const int intro = GvINTRO(dstr);
d3891 1
a3891 1
			CV* const cv = GvCV(dstr);
d3915 1
a3915 1
					HvNAME_get(GvSTASH((GV*)dstr)),
d3921 1
a3921 3
					   SvPOK(sref)
					   ? (char *)SvPVX_const(sref)
					   : Nullch);
d3967 5
a3971 4
	    if (SvPVX_const(dstr)) {
		SvPV_free(dstr);
		SvLEN_set(dstr, 0);
                SvCUR_set(dstr, 0);
d3975 1
a3975 1
	SvRV_set(dstr, SvREFCNT_inc(SvRV(sstr)));
d3982 1
a3982 1
	    SvNV_set(dstr, SvNVX(sstr));
d3990 1
a3990 1
	    SvIV_set(dstr, SvIVX(sstr));
d4001 2
a4002 2
	 * It might even be a win on short strings if SvPVX_const(dstr)
	 * has to be allocated and SvPVX_const(sstr) has to be freed.
d4013 7
a4019 2
	    if (SvPVX_const(dstr)) {	/* we know that dtype >= SVt_PV */
		SvPV_free(dstr);
d4036 1
a4036 1
	    Move(SvPVX_const(sstr),SvPVX(dstr),len,char);
d4043 1
d4048 1
a4048 1
	    SvNV_set(dstr, SvNVX(sstr));
d4056 1
a4056 1
	    SvIV_set(dstr, SvIVX(sstr));
d4075 1
a4075 1
	SvIV_set(dstr, SvIVX(sstr));
d4081 1
a4081 1
	    SvNV_set(dstr, SvNVX(sstr));
d4091 1
a4091 1
	SvNV_set(dstr, SvNVX(sstr));
d4142 1
a4142 1
	const IV iv = len;
d4148 2
a4149 1
    dptr = SvGROW(sv, len + 1);
a4232 1
    STRLEN allocate;
d4239 5
a4243 6
    if (SvPVX_const(sv))
	SvPV_free(sv);

    allocate = PERL_STRLEN_ROUNDUP(len + 1);
    ptr = saferealloc (ptr, allocate);
    SvPV_set(sv, ptr);
d4245 1
a4245 1
    SvLEN_set(sv, allocate);
d4282 3
a4284 3
	    const char * const pvx = SvPVX_const(sv);
	    const STRLEN len = SvCUR(sv);
	    const U32 hash = SvSHARED_HASH(sv);
d4324 1
a4324 1
Beware: after this function returns, C<ptr> and SvPVX_const(sv) may no longer
d4336 1
a4336 1
    delta = ptr - SvPVX_const(sv);
d4343 2
a4344 2
	    const char *pvx = SvPVX_const(sv);
	    const STRLEN len = SvCUR(sv);
d4349 1
a4349 1
	SvIV_set(sv, 0);
d4356 4
a4359 4
    SvLEN_set(sv, SvLEN(sv) - delta);
    SvCUR_set(sv, SvCUR(sv) - delta);
    SvPV_set(sv, SvPVX(sv) + delta);
    SvIV_set(sv, SvIVX(sv) + delta);
d4396 1
a4396 1
    const char *dstr = SvPV_force_flags(dsv, dlen, flags);
d4398 1
d4401 1
a4401 1
	sstr = SvPVX_const(dsv);
d4403 1
a4403 1
    SvCUR_set(dsv, SvCUR(dsv) + slen);
d4453 1
a4453 1
    const char *spv;
d4457 1
a4457 1
    if ((spv = SvPV_const(ssv, slen))) {
d4465 1
a4465 1
	const I32 sutf8 = DO_UTF8(ssv);
d4478 1
a4478 1
		spv = SvPV_const(csv, slen);
d4524 1
a4524 1
	ptr = SvPVX_const(sv);
d4526 1
a4526 1
    SvCUR_set(sv, SvCUR(sv) + len);
d4596 1
a4596 1
    Newxz(mg, 1, MAGIC);
d4598 1
a4598 1
    SvMAGIC_set(sv, mg);
d4600 4
a4603 4
    /* Sometimes a magic contains a reference loop, where the sv and
       object refer to each other.  To prevent a reference loop that
       would prevent such objects being freed, we look for such loops
       and if we find one we avoid incrementing the object refcount.
a4664 3
You need to use C<sv_magicext> to add magic to SvREADONLY SVs and also
to add more than one instance of the same 'how'.

a4670 1
    const MGVTBL *vtable;
d4672 1
d4675 1
a4675 6
	if (
	    /* its okay to attach magic to shared strings; the subsequent
	     * upgrade to PVMG will unshare the string */
	    !(SvFAKE(sv) && SvTYPE(sv) < SVt_PVMG)

	    && IN_PERL_RUNTIME
d4741 1
a4741 1
	vtable = NULL;
d4782 1
a4782 1
	vtable = NULL;
a4809 1
	vtable = NULL;
d4816 1
a4816 1
    mg = sv_magicext(sv,obj,how,(MGVTBL*)vtable,name,namlen);
d4847 1
a4847 1
            const MGVTBL* const vtbl = mg->mg_virtual;
d4924 7
d4946 1
a4946 1
    SV * const tsv = SvRV(sv);
d4952 2
a4953 17
    /* We shouldn't be in here more than once, but for paranoia reasons lets
       not assume this.  */
    for (i = AvFILLp(av); i >= 0; i--) {
	if (svp[i] == sv) {
	    const SSize_t fill = AvFILLp(av);
	    if (i != fill) {
		/* We weren't the last entry.
		   An unordered list has this property that you can take the
		   last element off the end to fill the hole, and it's still
		   an unordered list :-)
		*/
		svp[i] = svp[fill];
	    }
	    svp[fill] = Nullsv;
	    AvFILLp(av) = fill - 1;
	}
    }
d4997 1
a4997 1
	SvCUR_set(bigstr, SvCUR(bigstr) + i);
d5028 1
d5066 1
a5066 1
    const U32 refcnt = SvREFCNT(sv);
d5075 1
a5075 1
	SvMAGIC_set(nsv, SvMAGIC(sv));
d5078 1
a5078 1
	SvMAGIC_set(sv, NULL);
d5114 4
a5118 1
		CV* destructor;
d5122 1
a5122 1
		    SV* const tmpref = newRV(sv);
d5139 1
a5139 1
			SvRV_set(tmpref, NULL);
d5150 1
a5150 1
			  HvNAME_get(stash));
d5166 1
a5166 1
	if (SvTYPE(sv) == SVt_PVMG && SvFLAGS(sv) & SVpad_TYPED)
d5220 1
a5220 5
	/* Don't bother with SvOOK_off(sv); as we're only going to free it.  */
	if (SvOOK(sv)) {
	    SvPV_set(sv, SvPVX_mutable(sv) - SvIVX(sv));
	    /* Don't even bother with turning off the OOK flag.  */
	}
d5230 4
a5233 4
	else if (SvPVX_const(sv) && SvLEN(sv))
	    Safefree(SvPVX_mutable(sv));
	else if (SvPVX_const(sv) && SvREADONLY(sv) && SvFAKE(sv)) {
	    unsharepvn(SvPVX_const(sv),
d5353 1
a5353 1
	if (ckWARN_d(WARN_INTERNAL)) {
a5356 4
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
	    Perl_dump_sv_child(aTHX_ sv);
#endif
	}
d5401 1
a5401 1
        (void)SvPV_const(sv, len);
d5432 1
a5432 1
	const U8 *s = (U8*)SvPV_const(sv, len);
d5442 1
a5442 1
	     ulen = Perl_utf8_length(aTHX_ (U8 *)s, (U8 *)s + len);
d5466 1
a5466 2
S_utf8_mg_pos_init(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i,
		   I32 offsetp, const U8 *s, const U8 *start)
d5472 1
a5472 1
	    *mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, (MGVTBL*)&PL_vtbl_utf8, 0, 0);
d5475 7
a5481 7
	if ((*mgp)->mg_ptr)
	    *cachep = (STRLEN *) (*mgp)->mg_ptr;
	else {
	    Newxz(*cachep, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
	    (*mgp)->mg_ptr = (char *) *cachep;
	}
	assert(*cachep);
d5483 3
a5485 3
	(*cachep)[i]   = offsetp;
	(*cachep)[i+1] = s - start;
	found = TRUE;
d5499 1
a5499 1
S_utf8_mg_pos(pTHX_ SV *sv, MAGIC **mgp, STRLEN **cachep, I32 i, I32 *offsetp, I32 uoff, const U8 **sp, const U8 *start, const U8 *send)
d5514 1
a5514 1
		 const U8* p = NULL;
d5533 1
a5533 1
		      const STRLEN ulen = sv_len_utf8(sv);
d5631 2
a5632 1
    const U8 *start;
d5634 2
d5640 1
a5640 1
    start = (U8*)SvPV_const(sv, len);
d5642 4
a5645 7
	STRLEN boffset = 0;
	STRLEN *cache = 0;
	const U8 *s = start;
	I32 uoffset = *offsetp;
	const U8 * const send = s + len;
	MAGIC *mg = 0;
	bool found = FALSE;
d5654 1
a5654 1
              if (utf8_mg_pos_init(sv, &mg, &cache, 0, *offsetp, s, start))
d5661 1
a5661 1
              if (utf8_mg_pos(sv, &mg, &cache, 2, lenp, *lenp, &s, start, send)) {
d5672 1
a5672 1
                   utf8_mg_pos_init(sv, &mg, &cache, 2, *lenp, s, start);
d5707 1
a5707 1
    const U8* s;
d5713 1
a5713 1
    s = (const U8*)SvPV_const(sv, len);
d5717 1
a5717 1
	const U8* send = s + *offsetp;
d5745 1
a5745 1
		    const STRLEN forw  = *offsetp;
d5749 1
a5749 1
			const U8 *p = s + cache[1];
d5783 1
a5783 1
		utf8n_to_uvchr((U8 *)s, UTF8SKIP(s), &n, 0);
d5800 1
a5800 1
		Newxz(cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
d5831 1
a5831 1
    const char *pv1;
d5833 1
a5833 1
    const char *pv2;
d5844 1
a5844 1
	pv1 = SvPV_const(sv1, cur1);
d5851 1
a5851 1
	pv2 = SvPV_const(sv2, cur2);
d5860 1
a5860 1
		   pv2 = SvPV_const(svrecode, cur2);
d5865 1
a5865 1
		   pv1 = SvPV_const(svrecode, cur1);
d5879 1
a5879 1
		   char * const pv = (char*)bytes_from_utf8((U8*)pv1,
d5887 1
a5887 1
		   char * const pv = (char *)bytes_from_utf8((U8*)pv2,
d5926 1
a5926 2
    const char *pv1, *pv2;
    char *tpv = Nullch;
d5935 1
a5935 1
	pv1 = SvPV_const(sv1, cur1);
d5942 1
a5942 1
	pv2 = SvPV_const(sv2, cur2);
d5951 1
a5951 1
		 pv2 = SvPV_const(svrecode, cur2);
d5961 1
a5961 1
		 pv1 = SvPV_const(svrecode, cur1);
d5974 1
a5974 1
        const I32 retval = memcmp((const void*)pv1, (const void*)pv2, cur1 < cur2 ? cur1 : cur2);
d6075 1
a6075 2
	const char *s;
	char *xf;
d6080 1
a6080 1
	s = SvPV_const(sv, len);
d6126 1
a6126 1
    const char *rsptr;
d6153 1
a6153 1
	    SV * const tsv = NEWSV(0,0);
d6180 1
a6180 1
	    const Off_t offset = PerlIO_tell(fp);
d6228 1
a6228 1
	    rsptr = SvPV_const(PL_rs, rslen);
d6297 1
a6297 1
    bp = (STDCHAR*)SvPVX_const(sv) + append;  /* move these two too to registers */
d6326 1
a6326 1
	    bpx = bp - (STDCHAR*)SvPVX_const(sv); /* box up before relocation */
d6329 1
a6329 1
	    bp = (STDCHAR*)SvPVX_const(sv) + bpx; /* unbox after relocation */
d6361 1
a6361 1
	bpx = bp - (STDCHAR*)SvPVX_const(sv);	/* box up before relocation */
d6364 1
a6364 1
	bp = (STDCHAR*)SvPVX_const(sv) + bpx;	/* unbox after relocation */
d6373 1
a6373 1
    if ((rslen > 1 && (STRLEN)(bp - (STDCHAR*)SvPVX_const(sv)) < rslen) ||
d6387 1
a6387 1
    SvCUR_set(sv, bp - (STDCHAR*)SvPVX_const(sv));	/* set length */
d6390 1
a6390 1
	(long)SvCUR(sv),(int)SvCUR(sv),SvPVX_const(sv)));
d6395 11
a6405 1
#ifdef USE_HEAP_INSTEAD_OF_STACK	/* Even slower way. */
d6407 1
a6407 1
	Newx(buf, 8192, STDCHAR);
d6415 1
a6415 1
            register const STDCHAR *bpe = buf + sizeof(buf);
d6442 1
a6442 1
	     memNE(SvPVX_const(sv) + SvCUR(sv) - rslen, rsptr, rslen)))
d6460 1
a6460 1
#ifdef USE_HEAP_INSTEAD_OF_STACK
d6531 1
a6531 1
		SvUV_set(sv, SvUVX(sv) + 1);
d6537 1
a6537 1
		SvIV_set(sv, SvIVX(sv) + 1);
d6544 1
a6544 1
        SvNV_set(sv, SvNVX(sv) + 1.0);
d6548 1
a6548 1
    if (!(flags & SVp_POK) || !*SvPVX_const(sv)) {
d6552 1
a6552 1
	SvIV_set(sv, 1);
d6563 1
a6563 1
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), NULL);
d6579 1
a6579 1
                SvNV_set(sv, SvNVX(sv) + 1.0);
d6587 1
a6587 1
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
d6590 1
a6590 1
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
d6594 1
a6594 1
	sv_setnv(sv,Atof(SvPVX_const(sv)) + 1.0);
d6598 1
a6598 1
    while (d >= SvPVX_const(sv)) {
d6627 2
a6628 2
    SvCUR_set(sv, SvCUR(sv) + 1);
    for (d = SvPVX(sv) + SvCUR(sv); d > SvPVX_const(sv); d--)
d6681 1
a6681 1
		SvIV_set(sv, -1);
d6685 1
a6685 1
		SvUV_set(sv, SvUVX(sv) - 1);
d6692 1
a6692 1
		SvIV_set(sv, SvIVX(sv) - 1);
d6698 1
a6698 1
        SvNV_set(sv, SvNVX(sv) - 1.0);
d6703 4
a6706 4
	if ((flags & SVTYPEMASK) < SVt_PVIV)
	    sv_upgrade(sv, ((flags & SVTYPEMASK) > SVt_IV) ? SVt_PVIV : SVt_IV);
	SvIV_set(sv, -1);
	(void)SvIOK_only(sv);
d6711 1
a6711 1
	const int numtype = grok_number(SvPVX_const(sv), SvCUR(sv), NULL);
d6727 1
a6727 1
                SvNV_set(sv, SvNVX(sv) - 1.0);
d6735 1
a6735 1
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
d6738 1
a6738 1
				  SvPVX_const(sv), SvIVX(sv), SvNVX(sv)));
d6743 1
a6743 1
    sv_setnv(sv,Atof(SvPVX_const(sv)) - 1.0);	/* punt */
d6839 3
a6841 1
    sv_setpvn(sv,s,len ? len : strlen(s));
a6865 55

/*
=for apidoc newSVhek

Creates a new SV from the hash key structure.  It will generate scalars that
point to the shared string table where possible. Returns a new (undefined)
SV if the hek is NULL.

=cut
*/

SV *
Perl_newSVhek(pTHX_ const HEK *hek)
{
    if (!hek) {
	SV *sv;

	new_SV(sv);
	return sv;
    }

    if (HEK_LEN(hek) == HEf_SVKEY) {
	return newSVsv(*(SV**)HEK_KEY(hek));
    } else {
	const int flags = HEK_FLAGS(hek);
	if (flags & HVhek_WASUTF8) {
	    /* Trouble :-)
	       Andreas would like keys he put in as utf8 to come back as utf8
	    */
	    STRLEN utf8_len = HEK_LEN(hek);
	    const U8 *as_utf8 = bytes_to_utf8 ((U8*)HEK_KEY(hek), &utf8_len);
	    SV * const sv = newSVpvn ((const char*)as_utf8, utf8_len);

	    SvUTF8_on (sv);
	    Safefree (as_utf8); /* bytes_to_utf8() allocates a new string */
	    return sv;
	} else if (flags & HVhek_REHASH) {
	    /* We don't have a pointer to the hv, so we have to replicate the
	       flag into every HEK. This hv is using custom a hasing
	       algorithm. Hence we can't return a shared string scalar, as
	       that would contain the (wrong) hash value, and might get passed
	       into an hv routine with a regular hash  */

	    SV * const sv = newSVpvn (HEK_KEY(hek), HEK_LEN(hek));
	    if (HEK_UTF8(hek))
		SvUTF8_on (sv);
	    return sv;
	}
	/* This will be overwhelminly the most common case.  */
	return newSVpvn_share(HEK_KEY(hek),
			      (HEK_UTF8(hek) ? -HEK_LEN(hek) : HEK_LEN(hek)),
			      HEK_HASH(hek));
    }
}

d6869 1
a6869 1
Creates a new SV with its SvPVX_const pointing to a shared string in the string
d6874 1
a6874 1
is used for shared hash keys these strings will have SvPVX_const == HeKEY and
d6896 4
a6899 4
    SvPV_set(sv, sharepvn(src, is_utf8?-len:len, hash));
    SvCUR_set(sv, len);
    SvUV_set(sv, hash);
    SvLEN_set(sv, 0);
d7034 1
a7034 1
    SvRV_set(sv, tmpRef);
d7071 7
a7077 4
    /* SV_GMAGIC is the default for sv_setv()
       SV_NOSTEAL prevents TEMP buffers being, well, stolen, and saves games
       with SvTEMP_off and SvTEMP_on round a call to sv_setsv.  */
    sv_setsv_flags(sv, old, SV_GMAGIC | SV_NOSTEAL);
d7093 4
d7098 1
d7118 1
a7118 2
	I32 max;
	I32 i = (unsigned char)*s;
a7126 1
	    HE *entry;
a7130 3
		register GV *gv;
		register SV *sv;

d7135 11
a7145 15
		if (sv) {
		    if (SvTHINKFIRST(sv)) {
			if (!SvREADONLY(sv) && SvROK(sv))
			    sv_unref(sv);
			/* XXX Is this continue a bug? Why should THINKFIRST
			   exempt us from resetting arrays and hashes?  */
			continue;
		    }
		    SvOK_off(sv);
		    if (SvTYPE(sv) >= SVt_PV) {
			SvCUR_set(sv, 0);
			if (SvPVX_const(sv) != Nullch)
			    *SvPVX(sv) = '\0';
			SvTAINT(sv);
		    }
d7150 1
a7150 4
		if (GvHV(gv) && !HvNAME_get(GvHV(gv))) {
#if defined(VMS)
		    Perl_die(aTHX_ "Can't reset %%ENV on this system");
#else /* ! VMS */
d7152 12
a7163 5
#  if defined(USE_ENVIRON_ARRAY)
		    if (gv == PL_envgv)
		        my_clearenv();
#  endif /* USE_ENVIRON_ARRAY */
#endif /* VMS */
d7251 1
a7251 1
	    SV * const *sp = &sv;	/* Used in tryAMAGICunDEREF macro. */
d7312 2
a7313 2
	register const XPV* const tXpv = (XPV*)SvANY(sv);
	if (tXpv &&
d7396 2
d7401 1
a7401 1
    return sv_2pv(sv, 0);
d7470 1
d7476 1
a7476 2
	if (lp)
	    *lp = SvCUR(sv);
d7479 1
a7479 12
	char *s;
	STRLEN len;
 
	if (SvREADONLY(sv) && !(flags & SV_MUTABLE_RETURN)) {
	    const char * const ref = sv_reftype(sv,0);
	    if (PL_op)
		Perl_croak(aTHX_ "Can't coerce readonly %s to string in %s",
			   ref, OP_NAME(PL_op));
	    else
		Perl_croak(aTHX_ "Can't coerce readonly %s to string", ref);
	}
	if (SvTYPE(sv) > SVt_PVLV && SvTYPE(sv) != SVt_PVFM)
d7482 6
a7487 5
	s = sv_2pv_flags(sv, &len, flags);
	if (lp)
	    *lp = len;

	if (s != SvPVX_const(sv)) {	/* Almost, but not quite, sv_setpvn() */
d7500 1
a7500 1
				  PTR2UV(sv),SvPVX_const(sv)));
d7503 1
a7503 1
    return SvPVX_mutable(sv);
a7618 2
    /* The fact that I don't need to downcast to char * everywhere, only in ?:
       inside return suggests a const propagation bug in g++.  */
d7620 4
a7623 2
	char * const name = HvNAME_get(SvSTASH(sv));
	return name ? name : (char *) "__ANON__";
d7640 2
a7641 2

	case SVt_PVLV:		return (char *)  (SvROK(sv) ? "REF"
d7645 1
a7645 1
				    ? "SCALAR" : "LVALUE");
a7694 1
    const char *hvname;
a7703 3
    hvname = HvNAME_get(SvSTASH(sv));
    if (!hvname)
	return 0;
d7705 1
a7705 1
    return strEQ(hvname, name);
d7730 1
a7730 1
	const U32 refcnt = SvREFCNT(rv);
d7740 3
a7742 1
	SvPV_free(rv);
d7748 1
a7748 1
    SvRV_set(rv, sv);
d7752 1
a7752 1
	HV* const stash = gv_stashpv(classname, TRUE);
d7897 1
a7897 1
    SvSTASH_set(tmpRef, (HV*)SvREFCNT_inc(stash));
d7960 1
a7960 1
    SV const * rv = SvRV(sv);
d7965 1
a7965 1
	SvRV_set(sv, NULL);
d7968 1
a7968 1
    SvRV_set(sv, NULL);
d7975 1
a7975 1
	sv_2mortal((SV *)rv);		/* Schedule for freeing later */
d8019 1
a8019 1
	MAGIC * const mg = mg_find(sv, PERL_MAGIC_taint);
d8036 1
a8036 1
	const MAGIC * const mg = mg_find(sv, PERL_MAGIC_taint);
d8057 1
a8057 1
    char * const ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);
d8075 1
a8075 1
    char * const ptr = uiv_2buf(buf, iv, 0, 0, &ebuf);
d8224 1
a8224 2
C<sv_catpvf_mg>. If the original SV was UTF-8, the pattern should be
valid UTF-8; if the original SV was bytes, the pattern should be too.
d8326 1
a8326 1
    const int neg = nv < 0;
d8328 1
a8332 1
	char *p = endbuf;
d8338 1
a8338 1
	    const unsigned dig = uv % 10;
a8358 2
XXX Except that it maybe_tainted is never assigned to.

a8363 2
/* XXX maybe_tainted is never assigned to, so the doc above is lying. */

d8369 1
a8369 1
    const char *patend;
d8372 1
a8372 1
    static const char nullstr[] = "(null)";
d8374 2
a8375 2
    bool has_utf8 = DO_UTF8(sv);    /* has the result utf8? */
    const bool pat_utf8 = has_utf8; /* the pattern is in utf8? */
d8384 1
a8384 1
    PERL_UNUSED_ARG(maybe_tainted);
d8395 10
a8404 10
	if (args) {
	    const char * const s = va_arg(*args, char*);
	    sv_catpv(sv, s ? s : nullstr);
	}
	else if (svix < svmax) {
	    sv_catsv(sv, *svargs);
	    if (DO_UTF8(*svargs))
		SvUTF8_on(sv);
	}
	return;
d8420 1
a8420 1
    if ( !args && patlen <= 5 && pat[0] == '%' && pat[1] == '.'
d8431 3
a8433 1
	    if (svix < svmax)
d8486 1
a8486 1
	U8 utf8buf[UTF8_MAXBYTES+1];
d8489 1
a8489 1
	const char *eptr = Nullch;
d8492 1
a8492 1
	const U8 *vecstr = Null(U8*);
d8510 1
a8510 1
	const char *dotstr = ".";
a8600 1
	{
a8603 1
	}
a8604 5
#ifdef CHECK_FORMAT
	if ((*q == 'p') && left) {
            vectorize = (width == 1);
	}
#endif
d8609 4
a8612 9
		else if (evix) {
		    vecsv = (evix > 0 && evix <= svmax)
			? svargs[evix-1] : &PL_sv_undef;
		} else {
		    vecsv = svix < svmax ? svargs[svix++] : &PL_sv_undef;
		}
		dotstr = SvPV_const(vecsv, dotstrlen);
		/* Keep the DO_UTF8 test *after* the SvPV call, else things go
		   bad with tied or overloaded values that return UTF8.  */
a8614 6
		else if (has_utf8) {
		    vecsv = sv_mortalcopy(vecsv);
		    sv_utf8_upgrade(vecsv);
		    dotstr = SvPV_const(vecsv, dotstrlen);
		    is_utf8 = TRUE;
		}		    
d8618 1
a8618 1
		vecstr = (U8*)SvPV_const(vecsv,veclen);
d8621 1
a8621 1
	    else if (efix ? (efix > 0 && efix <= svmax) : svix < svmax) {
d8623 1
a8623 1
		vecstr = (U8*)SvPV_const(vecsv,veclen);
a8626 1
		vecsv = &PL_sv_undef;
d8727 3
a8729 9
	else if (!args) {
	    if (efix) {
		const I32 i = efix-1;
		argsv = (i >= 0 && i < svmax) ? svargs[i] : &PL_sv_undef;
	    } else {
		argsv = (svix >= 0 && svix < svmax)
		    ? svargs[svix++] : &PL_sv_undef;
	    }
	}
d8763 1
a8763 1
		    eptr = (char *)nullstr;
d8768 1
a8768 1
		eptr = SvPVx_const(argsv, elen);
a8783 3
#ifdef CHECK_FORMAT
	format_sv:
#endif
a8804 15
#ifdef CHECK_FORMAT
	    if (left) {
		left = FALSE;
	        if (!width)
		    goto format_sv;	/* %-p	-> %_	*/
		if (vectorize) {
		    width = 0;
		    goto format_vd;	/* %-1p	-> %vd  */      
		}
		precis = width;
		has_precis = TRUE;
		width = 0;
		goto format_sv;		/* %-Np	-> %.N_	*/	
	    }
#endif
a8819 3
#ifdef CHECK_FORMAT
	format_vd:
#endif
d8825 1
a8825 1
		    uv = utf8n_to_uvchr((U8 *)vecstr, veclen, &ulen,
d8911 1
a8911 1
		    uv = utf8n_to_uvchr((U8 *)vecstr, veclen, &ulen,
d8945 36
a8980 39
	    {
		char *ptr = ebuf + sizeof ebuf;
		switch (base) {
		    unsigned dig;
		case 16:
		    if (!uv)
			alt = FALSE;
		    p = (char*)((c == 'X')
				? "0123456789ABCDEF" : "0123456789abcdef");
		    do {
			dig = uv & 15;
			*--ptr = p[dig];
		    } while (uv >>= 4);
		    if (alt) {
			esignbuf[esignlen++] = '0';
			esignbuf[esignlen++] = c;  /* 'x' or 'X' */
		    }
		    break;
		case 8:
		    do {
			dig = uv & 7;
			*--ptr = '0' + dig;
		    } while (uv >>= 3);
		    if (alt && *ptr != '0')
			*--ptr = '0';
		    break;
		case 2:
		    if (!uv)
			alt = FALSE;
		    do {
			dig = uv & 1;
			*--ptr = '0' + dig;
		    } while (uv >>= 1);
		    if (alt) {
			esignbuf[esignlen++] = '0';
			esignbuf[esignlen++] = 'b';
		    }
		    break;
		default:		/* it had better be ten or less */
d8982 9
a8990 10
		    if (ckWARN(WARN_Y2K)) {
			STRLEN n;
			const char *const s = SvPV_const(sv,n);
			if (n >= 2 && s[n-2] == '1' && s[n-1] == '9'
			    && (n == 2 || !isDIGIT(s[n-3])))
			    {
				Perl_warner(aTHX_ packWARN(WARN_Y2K),
					    "Possible Y2K bug: %%%c %s",
					    c, "format string following '19'");
			    }
d8992 1
d8994 12
a9005 14
		    do {
			dig = uv % base;
			*--ptr = '0' + dig;
		    } while (uv /= base);
		    break;
		}
		elen = (ebuf + sizeof ebuf) - ptr;
		eptr = ptr;
		if (has_precis) {
		    if (precis > elen)
			zeros = precis - elen;
		    else if (precis == 0 && elen == 1 && *ptr == '0')
			elen = 0;
		}
d9146 1
a9146 1
		Newx(PL_efloatbuf, PL_efloatsize, char);
d9163 4
a9166 5
	    {
		char *ptr = ebuf + sizeof ebuf;
		*--ptr = '\0';
		*--ptr = c;
		/* FIXME: what to do if HAS_LONG_DOUBLE but not PERL_PRIfldbl? */
d9168 31
a9198 31
		if (intsize == 'q') {
		    /* Copy the one or more characters in a long double
		     * format before the 'base' ([efgEFG]) character to
		     * the format string. */
		    static char const prifldbl[] = PERL_PRIfldbl;
		    char const *p = prifldbl + sizeof(prifldbl) - 3;
		    while (p >= prifldbl) { *--ptr = *p--; }
		}
#endif
		if (has_precis) {
		    base = precis;
		    do { *--ptr = '0' + (base % 10); } while (base /= 10);
		    *--ptr = '.';
		}
		if (width) {
		    base = width;
		    do { *--ptr = '0' + (base % 10); } while (base /= 10);
		}
		if (fill == '0')
		    *--ptr = fill;
		if (left)
		    *--ptr = '-';
		if (plus)
		    *--ptr = plus;
		if (alt)
		    *--ptr = '#';
		*--ptr = '%';

		/* No taint.  Otherwise we are in the strange situation
		 * where printf() taints but print($float) doesn't.
		 * --jhi */
d9200 4
a9203 4
		if (intsize == 'q')
		    (void)sprintf(PL_efloatbuf, ptr, nv);
		else
		    (void)sprintf(PL_efloatbuf, ptr, (double)nv);
d9205 1
a9205 1
		(void)sprintf(PL_efloatbuf, ptr, nv);
a9206 1
	    }
d9236 2
a9237 4
	    if (!args
		&& (PL_op->op_type == OP_PRTF || PL_op->op_type == OP_SPRINTF)
		&& ckWARN(WARN_PRINTF))
	    {
d9266 1
a9266 1
	    SvCUR_set(sv, p - SvPVX_const(sv));
a9272 2
	if (have < zeros)
	    Perl_croak_nocontext(PL_memory_wrap);
d9280 1
a9280 1
		  SV * const nsv = sv_2mortal(newSVpvn(eptr, elen));
d9282 1
a9282 1
		  eptr = SvPVX_const(nsv);
a9299 2
	if (need >= (((STRLEN)~0) - SvCUR(sv) - dotstrlen - 1))
	    Perl_croak_nocontext(PL_memory_wrap);
a9302 1
	    int i;
a9310 1
	    int i;
a9314 1
	    int i;
d9339 1
a9339 1
	SvCUR_set(sv, p - SvPVX_const(sv));
d9409 1
a9409 1
    Newxc(ret, sizeof(regexp) + (len+1)*sizeof(regnode), char, regexp);
d9412 1
a9412 1
    Newx(ret->startp, npar, I32);
d9414 1
a9414 1
    Newx(ret->endp, npar, I32);
d9417 1
a9417 1
    Newx(ret->substrs, 1, struct reg_substr_data);
d9428 1
a9428 2
        const int count = r->data->count;
	int i;
d9430 1
a9430 1
	Newxc(d, sizeof(struct reg_data) + count*sizeof(void *),
d9432 1
a9432 1
	Newx(d->what, count, U8);
d9446 1
a9446 1
		Newx(d->data[i], 1, struct regnode_charclass_class);
a9453 1
		OP_REFCNT_LOCK;
a9454 1
		OP_REFCNT_UNLOCK;
d9467 1
a9467 1
    Newx(ret->offsets, 2*len+1, U32);
a9495 3

    PERL_UNUSED_ARG(type);

d9535 1
a9535 1
    Newxz(ret, 1, GP);
d9570 1
a9570 1
	Newxz(nmg, 1, MAGIC);
d9583 1
a9583 1
	    const AV * const av = (AV*) mg->mg_obj;
d9586 1
a9586 1
	    (void)SvREFCNT_inc(nmg->mg_obj = (SV*)newAV());
d9631 1
a9631 1
    Newxz(tbl, 1, PTR_TBL_t);
d9634 1
a9634 1
    Newxz(tbl->tbl_ary, tbl->tbl_max + 1, PTR_TBL_ENT_t*);
d9638 5
a9642 42
#define PTR_TABLE_HASH(ptr) \
  ((PTR2UV(ptr) >> 3) ^ (PTR2UV(ptr) >> (3 + 7)) ^ (PTR2UV(ptr) >> (3 + 17)))



STATIC void
S_more_pte(pTHX)
{
    struct ptr_tbl_ent* pte;
    struct ptr_tbl_ent* pteend;
    XPV *ptr;
    New(54, ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_pte_arenaroot;
    PL_pte_arenaroot = ptr;

    pte = (struct ptr_tbl_ent*)ptr;
    pteend = &pte[PERL_ARENA_SIZE / sizeof(struct ptr_tbl_ent) - 1];
    PL_pte_root = ++pte;
    while (pte < pteend) {
	pte->next = pte + 1;
	pte++;
    }
    pte->next = 0;
}

STATIC struct ptr_tbl_ent*
S_new_pte(pTHX)
{
    struct ptr_tbl_ent* pte;
    if (!PL_pte_root)
	S_more_pte(aTHX);
    pte = PL_pte_root;
    PL_pte_root = pte->next;
    return pte;
}

STATIC void
S_del_pte(pTHX_ struct ptr_tbl_ent*p)
{
    p->next = PL_pte_root;
    PL_pte_root = p;
}
d9650 1
a9650 1
    const UV hash = PTR_TABLE_HASH(sv);
d9663 1
a9663 1
Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, void *oldsv, void *newsv)
d9669 1
a9669 1
    const UV hash = PTR_TABLE_HASH(oldsv);
d9675 2
a9676 2
	if (tblent->oldval == oldsv) {
	    tblent->newval = newsv;
d9680 3
a9682 3
    tblent = S_new_pte(aTHX);
    tblent->oldval = oldsv;
    tblent->newval = newsv;
d9696 1
a9696 1
    const UV oldsize = tbl->tbl_max + 1;
d9729 1
d9743 1
a9743 1
            PTR_TBL_ENT_t *oentry = entry;
d9745 1
a9745 1
            S_del_pte(aTHX_ oentry);
d9775 56
d9838 3
a9840 4
	SvRV_set(dstr, SvWEAKREF(sstr)
		       ? sv_dup(SvRV(sstr), param)
		       : sv_dup_inc(SvRV(sstr), param));

d9842 1
a9842 1
    else if (SvPVX_const(sstr)) {
d9846 1
a9846 1
	    SvPV_set(dstr, SAVEPVN(SvPVX_const(sstr), SvLEN(sstr)-1));
d9857 3
a9859 3
                    SvPV_set(dstr, sharepvn(SvPVX_const(sstr), SvCUR(sstr),
                                           SvUVX(sstr)));
                    SvUV_set(dstr, SvUVX(sstr));
d9862 1
a9862 1
                    SvPV_set(dstr, SAVEPVN(SvPVX_const(sstr), SvCUR(sstr)));
d9869 1
a9869 1
		SvPV_set(dstr, SvPVX(sstr));		
d9875 1
a9875 4
	if (SvTYPE(dstr) == SVt_RV)
	    SvRV_set(dstr, NULL);
	else
	    SvPV_set(dstr, 0);
a9893 1
	const char *hvname;
d9896 1
a9896 1
	   (hvname = HvNAME_get(sstr))) {
d9898 2
a9899 1
	    return (SV*)gv_stashpv(hvname,0);
d9913 1
a9913 1
    if (SvANY(sstr) && PL_watch_pvx && SvPVX_const(sstr) == PL_watch_pvx)
d9915 1
a9915 1
		      PL_watch_pvx, SvPVX_const(sstr));
a9917 7
    /* don't clone objects whose class has asked us not to */
    if (SvOBJECT(sstr) && ! (SvFLAGS(SvSTASH(sstr)) & SVphv_CLONEABLE)) {
	SvFLAGS(dstr) &= ~SVTYPEMASK;
	SvOBJECT_off(dstr);
	return dstr;
    }

d9924 1
a9924 1
	SvIV_set(dstr, SvIVX(sstr));
d9928 1
a9928 1
	SvNV_set(dstr, SvNVX(sstr));
d9936 2
a9937 2
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
d9942 3
a9944 3
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
d9949 4
a9952 4
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
d9957 6
a9962 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
d9967 6
a9972 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
d9980 6
a9985 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
d9999 11
a10009 1
	    /* Do sharing here.  */
d10012 6
a10017 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
d10028 6
a10033 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
d10070 6
a10075 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
d10085 1
a10085 1
	    SvPV_set(dstr, (char*)dst_ary);
d10101 1
a10101 1
	    SvPV_set(dstr, Nullch);
d10107 7
a10113 7
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	HvTOTALKEYS(dstr) = HvTOTALKEYS(sstr);
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
	HvRITER_set((HV*)dstr, HvRITER_get((HV*)sstr));
a10114 1
	    bool sharekeys = !!HvSHAREKEYS(sstr);
d10118 1
a10118 1
	    Newx(dxhv->xhv_array,
d10121 3
a10123 3
		HE *source = HvARRAY(sstr)[i];
		HvARRAY(dstr)[i]
			= source ? he_dup(source, sharekeys, param) : 0;
d10130 2
a10131 2
	    SvPV_set(dstr, Nullch);
	    HvEITER_set((HV*)dstr, (HE*)NULL);
d10135 1
a10135 1
	/* Record stashes for possible cloning in Perl_clone(). */
d10147 6
a10152 6
	SvCUR_set(dstr, SvCUR(sstr));
	SvLEN_set(dstr, SvLEN(sstr));
	SvIV_set(dstr, SvIVX(sstr));
	SvNV_set(dstr, SvNVX(sstr));
	SvMAGIC_set(dstr, mg_dup(SvMAGIC(sstr), param));
	SvSTASH_set(dstr, hv_dup_inc(SvSTASH(sstr), param));
a10155 1
	OP_REFCNT_LOCK;
a10156 1
	OP_REFCNT_UNLOCK;
d10209 1
a10209 1
    Newxz(ncxs, max + 1, PERL_CONTEXT);
d10297 1
a10297 1
    Newxz(nsi, 1, PERL_SI);
d10364 3
a10366 3
    ANY * const ss	= proto_perl->Tsavestack;
    const I32 max	= proto_perl->Tsavestack_max;
    I32 ix		= proto_perl->Tsavestack_ix;
d10377 1
d10381 1
d10383 1
a10383 1
    Newxz(nss, max, ANY);
d10386 1
a10386 1
	I32 i = POPINT(ss,ix);
a10513 1
		OP *o;
d10553 1
a10553 3
	    TOPDPTR(nss,ix) = DPTR2FPTR(void (*)(void*),
					any_dup(FPTR2DPTR(void *, dptr),
						proto_perl));
d10559 1
a10559 3
	    TOPDXPTR(nss,ix) = DPTR2FPTR(void (*)(pTHX_ void*),
					 any_dup(FPTR2DPTR(void *, dxptr),
						 proto_perl));
a10620 35

/* if sv is a stash, call $class->CLONE_SKIP(), and set the SVphv_CLONEABLE
 * flag to the result. This is done for each stash before cloning starts,
 * so we know which stashes want their objects cloned */

static void
do_mark_cloneable_stash(pTHX_ SV *sv)
{
    const char *const hvname = HvNAME_get((HV*)sv);
    if (hvname) {
	GV* const cloner = gv_fetchmethod_autoload((HV*)sv, "CLONE_SKIP", 0);
	SvFLAGS(sv) |= SVphv_CLONEABLE; /* clone objects by default */
	if (cloner && GvCV(cloner)) {
	    dSP;
	    UV status;

	    ENTER;
	    SAVETMPS;
	    PUSHMARK(SP);
	    XPUSHs(sv_2mortal(newSVpv(hvname, 0)));
	    PUTBACK;
	    call_sv((SV*)GvCV(cloner), G_SCALAR);
	    SPAGAIN;
	    status = POPu;
	    PUTBACK;
	    FREETMPS;
	    LEAVE;
	    if (status)
		SvFLAGS(sv) &= ~SVphv_CLONEABLE;
	}
    }
}



a10701 2
    /* for each stash, determine whether its objects should be cloned */
    S_visit(proto_perl, do_mark_cloneable_stash, SVt_PVHV, SVTYPEMASK);
a10705 2
    PL_op = Nullop;
    PL_curcop = (COP *)Nullop;
a10732 2
    /* for each stash, determine whether its objects should be cloned */
    S_visit(proto_perl, do_mark_cloneable_stash, SVt_PVHV, SVTYPEMASK);
d10735 2
a10738 2
    PL_op = Nullop;
    PL_curcop = (COP *)Nullop;
a10780 4
#if defined(USE_ITHREADS)
    PL_pte_arenaroot	= NULL;
    PL_pte_root		= NULL;
#endif
a10789 3
    PL_hash_seed	= proto_perl->Ihash_seed;
    PL_rehash_seed	= proto_perl->Irehash_seed;

d10811 5
a10815 5
    SvPV_set(&PL_sv_no, SAVEPVN(PL_No, 0));
    SvCUR_set(&PL_sv_no, 0);
    SvLEN_set(&PL_sv_no, 1);
    SvIV_set(&PL_sv_no, 0);
    SvNV_set(&PL_sv_no, 0);
d10822 5
a10826 5
    SvPV_set(&PL_sv_yes, SAVEPVN(PL_Yes, 1));
    SvCUR_set(&PL_sv_yes, 1);
    SvLEN_set(&PL_sv_yes, 2);
    SvIV_set(&PL_sv_yes, 1);
    SvNV_set(&PL_sv_yes, 1);
d10832 1
a10832 1
    hv_ksplit(PL_strtab, HvTOTALKEYS(proto_perl->Istrtab));
d10911 2
a10912 3
	const I32 len = av_len((AV*)proto_perl->Iregex_padav);
	SV** const regexen = AvARRAY((AV*)proto_perl->Iregex_padav);
	IV i;
d11014 1
a11014 1
	Newx(PL_exitlist, PL_exitlistlen, PerlExitListEntry);
d11097 1
a11097 1
	i = proto_perl->Ibufptr - SvPVX_const(proto_perl->Ilinestr);
d11099 1
a11099 1
	i = proto_perl->Ioldbufptr - SvPVX_const(proto_perl->Ilinestr);
d11101 1
a11101 1
	i = proto_perl->Ioldoldbufptr - SvPVX_const(proto_perl->Ilinestr);
d11103 1
a11103 1
	i = proto_perl->Ilinestart - SvPVX_const(proto_perl->Ilinestr);
d11129 1
a11129 1
	i = proto_perl->Ilast_uni - SvPVX_const(proto_perl->Ilinestr);
d11131 1
a11131 1
	i = proto_perl->Ilast_lop - SvPVX_const(proto_perl->Ilinestr);
d11238 2
d11244 1
a11244 1
	Newxz(PL_psig_pend, SIG_SIZE, int);
d11251 2
a11252 2
	Newxz(PL_psig_ptr,  SIG_SIZE, SV*);
	Newxz(PL_psig_name, SIG_SIZE, SV*);
d11270 1
a11270 1
	Newxz(PL_tmps_stack, PL_tmps_max, SV*);
d11279 1
a11279 1
	Newxz(PL_markstack, i, I32);
d11291 1
a11291 1
	Newxz(PL_scopestack, PL_scopestack_max, I32);
d11318 1
a11318 1
	/*Newxz(PL_savestack, PL_savestack_max, ANY);*/
a11323 14

	/* although we're not duplicating the tmps stack, we should still
	 * add entries for any SVs on the tmps stack that got cloned by a
	 * non-refcount means (eg a temp in @@_); otherwise they will be
	 * orphaned
	 */
	for (i = 0; i<= proto_perl->Ttmps_ix; i++) {
	    SV *nsv = (SV*)ptr_table_fetch(PL_ptr_table,
		    proto_perl->Ttmps_stack[i]);
	    if (nsv && !SvREFCNT(nsv)) {
		EXTEND_MORTAL(1);
		PL_tmps_stack[++PL_tmps_ix] = SvREFCNT_inc(nsv);
	    }
	}
d11463 2
a11464 2
	HV* const stash = (HV*) av_shift(param->stashes);
	GV* const cloner = gv_fetchmethod_autoload(stash, "CLONE", 0);
d11470 1
a11470 1
	    XPUSHs(sv_2mortal(newSVpv(HvNAME_get(stash), 0)));
a11479 6
    /* orphaned? eg threads->new inside BEGIN or use */
    if (PL_compcv && ! SvREFCNT(PL_compcv)) {
	(void)SvREFCNT_inc(PL_compcv);
	SAVEFREESV(PL_compcv);
    }

d11509 1
a11509 1
	const char *s;
d11533 2
a11534 2
	s = SvPV_const(uni, len);
	if (s != SvPVX_const(sv)) {
d11536 1
a11536 1
	    Move(s, SvPVX(sv), len + 1, char);
d11538 1
a11594 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d33 7
a39 1
/* if adding more checks watch out for the following tests:
d44 2
a45 5
#   define ASSERT_UTF8_CACHE(cache) \
    STMT_START { if (cache) { assert((cache)[0] <= (cache)[1]); \
			      assert((cache)[2] <= (cache)[3]); \
			      assert((cache)[3] <= (cache)[1]);} \
			      } STMT_END
d47 1
a47 8
#   define ASSERT_UTF8_CACHE(cache) NOOP
#endif

#ifdef PERL_OLD_COPY_ON_WRITE
#define SV_COW_NEXT_SV(sv)	INT2PTR(SV *,SvUVX(sv))
#define SV_COW_NEXT_SV_SET(current,next)	SvUV_set(current, PTR2UV(next))
/* This is a pessimistic view. Scalar must be purely a read-write PV to copy-
   on-write.  */
d54 12
a65 21
An SV (or AV, HV, etc.) is allocated in two parts: the head (struct
sv, av, hv...) contains type and reference count information, and for
many types, a pointer to the body (struct xrv, xpv, xpviv...), which
contains fields specific to each type.  Some types store all they need
in the head, so don't have a body.

In all but the most memory-paranoid configuations (ex: PURIFY), heads
and bodies are allocated out of arenas, which by default are
approximately 4K chunks of memory parcelled up into N heads or bodies.
Sv-bodies are allocated by their sv-type, guaranteeing size
consistency needed to allocate safely from arrays.

For SV-heads, the first slot in each arena is reserved, and holds a
link to the next arena, some flags, and a note of the number of slots.
Snaked through each arena chain is a linked list of free items; when
this becomes empty, an extra arena is allocated and divided up into N
items which are threaded into the free list.

SV-bodies are similar, but they use arena-sets by default, which
separate the link and info from the arena itself, and reclaim the 1st
slot in the arena.  SV-bodies are further described later.
d72 11
a82 8
    PL_body_arenas	head of linked-list of body arenas
    PL_body_roots[]	array of pointers to list of free bodies of svtype
			arrays are indexed by the svtype needed

A few special SV heads are not allocated from an arena, but are
instead directly created in the interpreter structure, eg PL_sv_undef.
The size of arenas can be changed from the default by setting
PERL_ARENA_SIZE appropriately at compile time.
d93 7
d102 6
a107 1
start of the interpreter.
d116 1
a116 1
			dump all remaining SVs (debugging aid)
d136 1
a136 1
=head2 Arena allocator API Summary
d150 1
d155 2
d161 4
a167 1
    dVAR;
d170 1
d180 1
a182 19
#ifdef DEBUG_LEAKING_SCALARS
#  define FREE_SV_DEBUG_FILE(sv) Safefree((sv)->sv_debug_file)
#else
#  define FREE_SV_DEBUG_FILE(sv)
#endif

#ifdef PERL_POISON
#  define SvARENA_CHAIN(sv)	((sv)->sv_u.svu_rv)
/* Whilst I'd love to do this, it seems that things like to check on
   unreferenced scalars
#  define POSION_SV_HEAD(sv)	PoisonNew(sv, 1, struct STRUCT_SV)
*/
#  define POSION_SV_HEAD(sv)	PoisonNew(&SvANY(sv), 1, void *), \
				PoisonNew(&SvREFCNT(sv), 1, U32)
#else
#  define SvARENA_CHAIN(sv)	SvANY(sv)
#  define POSION_SV_HEAD(sv)
#endif

d185 1
a185 3
	FREE_SV_DEBUG_FILE(p);				\
	POSION_SV_HEAD(p);				\
	SvARENA_CHAIN(p) = (void *)PL_sv_root;		\
d191 1
d195 1
a195 1
	PL_sv_root = (SV*)SvARENA_CHAIN(p);		\
d202 1
a205 1
    dVAR;
d210 1
a210 1
	PL_nice_chunk = NULL;
d215 1
a215 1
	Newx(chunk,PERL_ARENA_SIZE,char);  /* Safefree() in sv_free_arenas() */
d231 1
d236 1
a239 12
    sv->sv_debug_optype = PL_op ? PL_op->op_type : 0;
    sv->sv_debug_line = (U16) (PL_parser
	    ?  PL_parser->copline == NOLINE
		?  PL_curcop
		    ? CopLINE(PL_curcop)
		    : 0
		: PL_parser->copline
	    : 0);
    sv->sv_debug_inpad = 0;
    sv->sv_debug_cloned = 0;
    sv->sv_debug_file = PL_curcop ? savepv(CopFILE(PL_curcop)): NULL;
    
d247 1
d252 1
d266 1
d271 1
a276 1
    dVAR;
d320 1
a320 2
    dVAR;
    SV* const sva = (SV*)ptr;
d335 1
a335 1
	SvARENA_CHAIN(sv) = (void *)(SV*)(sv + 1);
d339 1
a339 1
	/* Must always set typemask because it's always checked in on cleanup
d344 1
a344 1
    SvARENA_CHAIN(sv) = 0;
a356 1
    dVAR;
a402 2
#else
    PERL_UNUSED_CONTEXT;
d409 1
a409 1
do_clean_objs(pTHX_ SV *ref)
d411 12
a422 15
    dVAR;
    assert (SvROK(ref));
    {
	SV * const target = SvRV(ref);
	if (SvOBJECT(target)) {
	    DEBUG_D((PerlIO_printf(Perl_debug_log, "Cleaning object ref:\n "), sv_dump(ref)));
	    if (SvWEAKREF(ref)) {
		sv_del_backref(target, ref);
		SvWEAKREF_off(ref);
		SvRV_set(ref, NULL);
	    } else {
		SvROK_off(ref);
		SvRV_set(ref, NULL);
		SvREFCNT_dec(target);
	    }
d435 1
a435 4
    dVAR;
    assert(SvTYPE(sv) == SVt_PVGV);
    assert(isGV_with_GP(sv));
    if (GvGP(sv)) {
d443 1
a443 2
	     /* In certain rare cases GvIOp(sv) can be NULL, which would make SvOBJECT(GvIO(sv)) dereference NULL. */
	     (GvIO(sv) ? (SvFLAGS(GvIOp(sv)) & SVs_OBJECT) : 0) ||
a464 1
    dVAR;
d469 1
a469 1
    visit(do_clean_named_objs, SVt_PVGV|SVpgv_GP, SVTYPEMASK|SVp_POK|SVpgv_GP);
a478 1
    dVAR;
a496 1
    dVAR;
a504 37
  ARENASETS: a meta-arena implementation which separates arena-info
  into struct arena_set, which contains an array of struct
  arena_descs, each holding info for a single arena.  By separating
  the meta-info from the arena, we recover the 1st slot, formerly
  borrowed for list management.  The arena_set is about the size of an
  arena, avoiding the needless malloc overhead of a naive linked-list.

  The cost is 1 arena-set malloc per ~320 arena-mallocs, + the unused
  memory in the last arena-set (1/2 on average).  In trade, we get
  back the 1st slot in each arena (ie 1.7% of a CV-arena, less for
  smaller types).  The recovery of the wasted space allows use of
  small arenas for large, rare body types, by changing array* fields
  in body_details_by_type[] below.
*/
struct arena_desc {
    char       *arena;		/* the raw storage, allocated aligned */
    size_t      size;		/* its size ~4k typ */
    U32		misc;		/* type, and in future other things. */
};

struct arena_set;

/* Get the maximum number of elements in set[] such that struct arena_set
   will fit within PERL_ARENA_SIZE, which is probably just under 4K, and
   therefore likely to be 1 aligned memory page.  */

#define ARENAS_PER_SET  ((PERL_ARENA_SIZE - sizeof(struct arena_set*) \
			  - 2 * sizeof(int)) / sizeof (struct arena_desc))

struct arena_set {
    struct arena_set* next;
    unsigned int   set_size;	/* ie ARENAS_PER_SET */
    unsigned int   curr;	/* index of next available arena-desc */
    struct arena_desc set[ARENAS_PER_SET];
};

/*
d512 1
a515 1
    dVAR;
d518 1
a518 1
    unsigned int i;
d532 83
a614 2
    {
	struct arena_set *aroot = (struct arena_set*) PL_body_arenas;
d616 3
a618 10
	while (aroot) {
	    struct arena_set *current = aroot;
	    i = aroot->curr;
	    while (i--) {
		assert(aroot->set[i].arena);
		Safefree(aroot->set[i].arena);
	    }
	    aroot = aroot->next;
	    Safefree(current);
	}
d620 2
a621 1
    PL_body_arenas = 0;
d623 8
a630 3
    i = PERL_ARENA_ROOTS_SIZE;
    while (i--)
	PL_body_roots[i] = 0;
d633 1
a633 1
    PL_nice_chunk = NULL;
d640 1
a640 2
  Here are mid-level routines that manage the allocation of bodies out
  of the various arenas.  There are 5 kinds of arenas:
d642 1
a642 41
  1. SV-head arenas, which are discussed and handled above
  2. regular body arenas
  3. arenas for reduced-size bodies
  4. Hash-Entry arenas
  5. pte arenas (thread related)

  Arena types 2 & 3 are chained by body-type off an array of
  arena-root pointers, which is indexed by svtype.  Some of the
  larger/less used body types are malloced singly, since a large
  unused block of them is wasteful.  Also, several svtypes dont have
  bodies; the data fits into the sv-head itself.  The arena-root
  pointer thus has a few unused root-pointers (which may be hijacked
  later for arena types 4,5)

  3 differs from 2 as an optimization; some body types have several
  unused fields in the front of the structure (which are kept in-place
  for consistency).  These bodies can be allocated in smaller chunks,
  because the leading fields arent accessed.  Pointers to such bodies
  are decremented to point at the unused 'ghost' memory, knowing that
  the pointers are used with offsets to the real memory.

  HE, HEK arenas are managed separately, with separate code, but may
  be merge-able later..

  PTE arenas are not sv-bodies, but they share these mid-level
  mechanics, so are considered here.  The new mid-level mechanics rely
  on the sv_type of the body being allocated, so we just reserve one
  of the unused body-slots for PTEs, then use it in those (2) PTE
  contexts below (line ~10k)
*/

/* get_arena(size): this creates custom-sized arenas
   TBD: export properly for hv.c: S_more_he().
*/
void*
Perl_get_arena(pTHX_ size_t arena_size, U32 misc)
{
    dVAR;
    struct arena_desc* adesc;
    struct arena_set *aroot = (struct arena_set*) PL_body_arenas;
    unsigned int curr;
d644 2
a645 3
    /* shouldnt need this
    if (!arena_size)	arena_size = PERL_ARENA_SIZE;
    */
d647 8
a654 23
    /* may need new arena-set to hold new arena */
    if (!aroot || aroot->curr >= aroot->set_size) {
	struct arena_set *newroot;
	Newxz(newroot, 1, struct arena_set);
	newroot->set_size = ARENAS_PER_SET;
	newroot->next = aroot;
	aroot = newroot;
	PL_body_arenas = (void *) newroot;
	DEBUG_m(PerlIO_printf(Perl_debug_log, "new arenaset %p\n", (void*)aroot));
    }

    /* ok, now have arena-set with at least 1 empty/available arena-desc */
    curr = aroot->curr++;
    adesc = &(aroot->set[curr]);
    assert(!adesc->arena);
    
    Newx(adesc->arena, arena_size, char);
    adesc->size = arena_size;
    adesc->misc = misc;
    DEBUG_m(PerlIO_printf(Perl_debug_log, "arena %d added: %p size %"UVuf"\n", 
			  curr, (void*)adesc->arena, (UV)arena_size));

    return adesc->arena;
d657 22
d680 1
a680 8
/* return a thing to the free list */

#define del_body(thing, root)			\
    STMT_START {				\
	void ** const thing_copy = (void **)thing;\
	*thing_copy = *root;			\
	*root = (void*)thing_copy;		\
    } STMT_END
d682 20
a701 1
/* 
d703 1
a703 1
=head1 SV-Body Allocation
d705 20
a724 47
Allocation of SV-bodies is similar to SV-heads, differing as follows;
the allocation mechanism is used for many body types, so is somewhat
more complicated, it uses arena-sets, and has no need for still-live
SV detection.

At the outermost level, (new|del)_X*V macros return bodies of the
appropriate type.  These macros call either (new|del)_body_type or
(new|del)_body_allocated macro pairs, depending on specifics of the
type.  Most body types use the former pair, the latter pair is used to
allocate body types with "ghost fields".

"ghost fields" are fields that are unused in certain types, and
consequently dont need to actually exist.  They are declared because
they're part of a "base type", which allows use of functions as
methods.  The simplest examples are AVs and HVs, 2 aggregate types
which don't use the fields which support SCALAR semantics.

For these types, the arenas are carved up into *_allocated size
chunks, we thus avoid wasted memory for those unaccessed members.
When bodies are allocated, we adjust the pointer back in memory by the
size of the bit not allocated, so it's as if we allocated the full
structure.  (But things will all go boom if you write to the part that
is "not there", because you'll be overwriting the last members of the
preceding structure in memory.)

We calculate the correction using the STRUCT_OFFSET macro. For
example, if xpv_allocated is the same structure as XPV then the two
OFFSETs sum to zero, and the pointer is unchanged. If the allocated
structure is smaller (no initial NV actually allocated) then the net
effect is to subtract the size of the NV from the pointer, to return a
new pointer as if an initial NV were actually allocated.

This is the same trick as was used for NV and IV bodies. Ironically it
doesn't need to be used for NV bodies any more, because NV is now at
the start of the structure. IV bodies don't need it either, because
they are no longer allocated.

In turn, the new_body_* allocators call S_new_body(), which invokes
new_body_inline macro, which takes a lock, and takes a body off the
linked list at PL_body_roots[sv_type], calling S_more_bodies() if
necessary to refresh an empty list.  Then the lock is released, and
the body is returned.

S_more_bodies calls get_arena(), and carves it up into an array of N
bodies, which it strings into a linked list.  It looks up arena-size
and body-size from the body_details table described below, thus
supporting the multiple body-types.
d726 1
a726 2
If PURIFY is defined, or PERL_ARENA_SIZE=0, arenas are not used, and
the (new|del)_X*V macros are mapped directly to malloc/free.
d728 8
a735 1
*/
d737 8
a744 1
/* 
d746 1
a746 2
For each sv-type, struct body_details bodies_by_type[] carries
parameters which control these aspects of SV handling:
d748 8
a755 26
Arena_size determines whether arenas are used for this body type, and if
so, how big they are.  PURIFY or PERL_ARENA_SIZE=0 set this field to
zero, forcing individual mallocs and frees.

Body_size determines how big a body is, and therefore how many fit into
each arena.  Offset carries the body-pointer adjustment needed for
*_allocated body types, and is used in *_allocated macros.

But its main purpose is to parameterize info needed in
Perl_sv_upgrade().  The info here dramatically simplifies the function
vs the implementation in 5.8.7, making it table-driven.  All fields
are used for this, except for arena_size.

For the sv-types that have no bodies, arenas are not used, so those
PL_body_roots[sv_type] are unused, and can be overloaded.  In
something of a special case, SVt_NULL is borrowed for HE arenas;
PL_body_roots[HE_SVSLOT=SVt_NULL] is filled by S_more_he, but the
bodies_by_type[SVt_NULL] slot is not used, as the table is not
available in hv.c.

PTEs also use arenas, but are never seen in Perl_sv_upgrade. Nonetheless,
they get their own slot in bodies_by_type[PTE_SVSLOT =SVt_IV], so they can
just use the same allocation semantics.  At first, PTEs were also
overloaded to a non-body sv-type, but this yielded hard-to-find malloc
bugs, so was simplified by claiming a new slot.  This choice has no
consequence at this time.
d757 8
a764 1
*/
d766 1
a766 10
struct body_details {
    U8 body_size;	/* Size to allocate  */
    U8 copy;		/* Size of structure to copy (may be shorter)  */
    U8 offset;
    unsigned int type : 4;	    /* We have space for a sanity check.  */
    unsigned int cant_upgrade : 1;  /* Cannot upgrade this type */
    unsigned int zero_nv : 1;	    /* zero the NV when upgrading from this */
    unsigned int arena : 1;	    /* Allocated from an arena */
    size_t arena_size;		    /* Size of arena to allocate */
};
d768 16
a783 2
#define HADNV FALSE
#define NONV TRUE
d785 1
d787 8
a794 8
#ifdef PURIFY
/* With -DPURFIY we allocate everything directly, and don't use arenas.
   This seems a rather elegant way to simplify some of the code below.  */
#define HASARENA FALSE
#else
#define HASARENA TRUE
#endif
#define NOARENA FALSE
d796 8
a803 139
/* Size the arenas to exactly fit a given number of bodies.  A count
   of 0 fits the max number bodies into a PERL_ARENA_SIZE.block,
   simplifying the default.  If count > 0, the arena is sized to fit
   only that many bodies, allowing arenas to be used for large, rare
   bodies (XPVFM, XPVIO) without undue waste.  The arena size is
   limited by PERL_ARENA_SIZE, so we can safely oversize the
   declarations.
 */
#define FIT_ARENA0(body_size)				\
    ((size_t)(PERL_ARENA_SIZE / body_size) * body_size)
#define FIT_ARENAn(count,body_size)			\
    ( count * body_size <= PERL_ARENA_SIZE)		\
    ? count * body_size					\
    : FIT_ARENA0 (body_size)
#define FIT_ARENA(count,body_size)			\
    count 						\
    ? FIT_ARENAn (count, body_size)			\
    : FIT_ARENA0 (body_size)

/* A macro to work out the offset needed to subtract from a pointer to (say)

typedef struct {
    STRLEN	xpv_cur;
    STRLEN	xpv_len;
} xpv_allocated;

to make its members accessible via a pointer to (say)

struct xpv {
    NV		xnv_nv;
    STRLEN	xpv_cur;
    STRLEN	xpv_len;
};

*/

#define relative_STRUCT_OFFSET(longer, shorter, member) \
    (STRUCT_OFFSET(shorter, member) - STRUCT_OFFSET(longer, member))

/* Calculate the length to copy. Specifically work out the length less any
   final padding the compiler needed to add.  See the comment in sv_upgrade
   for why copying the padding proved to be a bug.  */

#define copy_length(type, last_member) \
	STRUCT_OFFSET(type, last_member) \
	+ sizeof (((type*)SvANY((SV*)0))->last_member)

static const struct body_details bodies_by_type[] = {
    { sizeof(HE), 0, 0, SVt_NULL,
      FALSE, NONV, NOARENA, FIT_ARENA(0, sizeof(HE)) },

    /* The bind placeholder pretends to be an RV for now.
       Also it's marked as "can't upgrade" to stop anyone using it before it's
       implemented.  */
    { 0, 0, 0, SVt_BIND, TRUE, NONV, NOARENA, 0 },

    /* IVs are in the head, so the allocation size is 0.
       However, the slot is overloaded for PTEs.  */
    { sizeof(struct ptr_tbl_ent), /* This is used for PTEs.  */
      sizeof(IV), /* This is used to copy out the IV body.  */
      STRUCT_OFFSET(XPVIV, xiv_iv), SVt_IV, FALSE, NONV,
      NOARENA /* IVS don't need an arena  */,
      /* But PTEs need to know the size of their arena  */
      FIT_ARENA(0, sizeof(struct ptr_tbl_ent))
    },

    /* 8 bytes on most ILP32 with IEEE doubles */
    { sizeof(NV), sizeof(NV), 0, SVt_NV, FALSE, HADNV, HASARENA,
      FIT_ARENA(0, sizeof(NV)) },

    /* RVs are in the head now.  */
    { 0, 0, 0, SVt_RV, FALSE, NONV, NOARENA, 0 },

    /* 8 bytes on most ILP32 with IEEE doubles */
    { sizeof(xpv_allocated),
      copy_length(XPV, xpv_len)
      - relative_STRUCT_OFFSET(xpv_allocated, XPV, xpv_cur),
      + relative_STRUCT_OFFSET(xpv_allocated, XPV, xpv_cur),
      SVt_PV, FALSE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpv_allocated)) },

    /* 12 */
    { sizeof(xpviv_allocated),
      copy_length(XPVIV, xiv_u)
      - relative_STRUCT_OFFSET(xpviv_allocated, XPVIV, xpv_cur),
      + relative_STRUCT_OFFSET(xpviv_allocated, XPVIV, xpv_cur),
      SVt_PVIV, FALSE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpviv_allocated)) },

    /* 20 */
    { sizeof(XPVNV), copy_length(XPVNV, xiv_u), 0, SVt_PVNV, FALSE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVNV)) },

    /* 28 */
    { sizeof(XPVMG), copy_length(XPVMG, xmg_stash), 0, SVt_PVMG, FALSE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVMG)) },
    
    /* 48 */
    { sizeof(XPVGV), sizeof(XPVGV), 0, SVt_PVGV, TRUE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVGV)) },
    
    /* 64 */
    { sizeof(XPVLV), sizeof(XPVLV), 0, SVt_PVLV, TRUE, HADNV,
      HASARENA, FIT_ARENA(0, sizeof(XPVLV)) },

    { sizeof(xpvav_allocated),
      copy_length(XPVAV, xmg_stash)
      - relative_STRUCT_OFFSET(xpvav_allocated, XPVAV, xav_fill),
      + relative_STRUCT_OFFSET(xpvav_allocated, XPVAV, xav_fill),
      SVt_PVAV, TRUE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpvav_allocated)) },

    { sizeof(xpvhv_allocated),
      copy_length(XPVHV, xmg_stash)
      - relative_STRUCT_OFFSET(xpvhv_allocated, XPVHV, xhv_fill),
      + relative_STRUCT_OFFSET(xpvhv_allocated, XPVHV, xhv_fill),
      SVt_PVHV, TRUE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpvhv_allocated)) },

    /* 56 */
    { sizeof(xpvcv_allocated), sizeof(xpvcv_allocated),
      + relative_STRUCT_OFFSET(xpvcv_allocated, XPVCV, xpv_cur),
      SVt_PVCV, TRUE, NONV, HASARENA, FIT_ARENA(0, sizeof(xpvcv_allocated)) },

    { sizeof(xpvfm_allocated), sizeof(xpvfm_allocated),
      + relative_STRUCT_OFFSET(xpvfm_allocated, XPVFM, xpv_cur),
      SVt_PVFM, TRUE, NONV, NOARENA, FIT_ARENA(20, sizeof(xpvfm_allocated)) },

    /* XPVIO is 84 bytes, fits 48x */
    { sizeof(XPVIO), sizeof(XPVIO), 0, SVt_PVIO, TRUE, HADNV,
      HASARENA, FIT_ARENA(24, sizeof(XPVIO)) },
};

#define new_body_type(sv_type)		\
    (void *)((char *)S_new_body(aTHX_ sv_type))

#define del_body_type(p, sv_type)	\
    del_body(p, &PL_body_roots[sv_type])


#define new_body_allocated(sv_type)		\
    (void *)((char *)S_new_body(aTHX_ sv_type)	\
	     - bodies_by_type[sv_type].offset)
d805 1
a805 2
#define del_body_allocated(p, sv_type)		\
    del_body(p + bodies_by_type[sv_type].offset, &PL_body_roots[sv_type])
d807 8
d816 8
a823 3
#define my_safemalloc(s)	(void*)safemalloc(s)
#define my_safecalloc(s)	(void*)safecalloc(s, 1)
#define my_safefree(p)	safefree((char*)p)
d825 1
a825 1
#ifdef PURIFY
d827 8
a834 2
#define new_XNV()	my_safemalloc(sizeof(XPVNV))
#define del_XNV(p)	my_safefree(p)
d836 8
a843 2
#define new_XPVNV()	my_safemalloc(sizeof(XPVNV))
#define del_XPVNV(p)	my_safefree(p)
d845 1
a845 2
#define new_XPVAV()	my_safemalloc(sizeof(XPVAV))
#define del_XPVAV(p)	my_safefree(p)
d847 8
a854 2
#define new_XPVHV()	my_safemalloc(sizeof(XPVHV))
#define del_XPVHV(p)	my_safefree(p)
d856 8
a863 2
#define new_XPVMG()	my_safemalloc(sizeof(XPVMG))
#define del_XPVMG(p)	my_safefree(p)
d865 1
a865 2
#define new_XPVGV()	my_safemalloc(sizeof(XPVGV))
#define del_XPVGV(p)	my_safefree(p)
d867 8
a874 1
#else /* !PURIFY */
d876 8
a883 2
#define new_XNV()	new_body_type(SVt_NV)
#define del_XNV(p)	del_body_type(p, SVt_NV)
d885 1
a885 2
#define new_XPVNV()	new_body_type(SVt_PVNV)
#define del_XPVNV(p)	del_body_type(p, SVt_PVNV)
d887 8
a894 2
#define new_XPVAV()	new_body_allocated(SVt_PVAV)
#define del_XPVAV(p)	del_body_allocated(p, SVt_PVAV)
d896 8
a903 2
#define new_XPVHV()	new_body_allocated(SVt_PVHV)
#define del_XPVHV(p)	del_body_allocated(p, SVt_PVHV)
d905 1
a905 2
#define new_XPVMG()	new_body_type(SVt_PVMG)
#define del_XPVMG(p)	del_body_type(p, SVt_PVMG)
d907 12
a918 2
#define new_XPVGV()	new_body_type(SVt_PVGV)
#define del_XPVGV(p)	del_body_type(p, SVt_PVGV)
d920 1
a920 1
#endif /* PURIFY */
d922 8
a929 1
/* no arena for you! */
d931 1
a931 21
#define new_NOARENA(details) \
	my_safemalloc((details)->body_size + (details)->offset)
#define new_NOARENAZ(details) \
	my_safecalloc((details)->body_size + (details)->offset)

STATIC void *
S_more_bodies (pTHX_ svtype sv_type)
{
    dVAR;
    void ** const root = &PL_body_roots[sv_type];
    const struct body_details * const bdp = &bodies_by_type[sv_type];
    const size_t body_size = bdp->body_size;
    char *start;
    const char *end;
#if defined(DEBUGGING) && !defined(PERL_GLOBAL_STRUCT_PRIVATE)
    static bool done_sanity_check;

    /* PERL_GLOBAL_STRUCT_PRIVATE cannot coexist with global
     * variables like done_sanity_check. */
    if (!done_sanity_check) {
	unsigned int i = SVt_LAST;
d933 15
a947 1
	done_sanity_check = TRUE;
d949 1
a949 4
	while (i--)
	    assert (bodies_by_type[i].type == i);
    }
#endif
d951 9
a959 1
    assert(bdp->arena_size);
d961 1
a961 1
    start = (char*) Perl_get_arena(aTHX_ bdp->arena_size, sv_type);
d963 12
a974 1
    end = start + bdp->arena_size - body_size;
d976 1
a976 6
    /* computed count doesnt reflect the 1st slot reservation */
    DEBUG_m(PerlIO_printf(Perl_debug_log,
			  "arena %p end %p arena-size %d type %d size %d ct %d\n",
			  (void*)start, (void*)end,
			  (int)bdp->arena_size, sv_type, (int)body_size,
			  (int)bdp->arena_size / (int)body_size));
d978 24
a1001 1
    *root = (void *)start;
d1003 1
a1003 6
    while (start < end) {
	char * const next = start + body_size;
	*(void**) start = (void *)next;
	start = next;
    }
    *(void **)start = 0;
d1005 7
a1011 1
    return *root;
d1014 14
a1027 11
/* grab a new thing from the free list, allocating more if necessary.
   The inline version is used for speed in hot routines, and the
   function using it serves the rest (unless PURIFY).
*/
#define new_body_inline(xpv, sv_type) \
    STMT_START { \
	void ** const r3wt = &PL_body_roots[sv_type]; \
	xpv = (PTR_TBL_ENT_t*) (*((void **)(r3wt))      \
	  ? *((void **)(r3wt)) : more_bodies(sv_type)); \
	*(r3wt) = *(void**)(xpv); \
    } STMT_END
d1029 1
a1029 1
#ifndef PURIFY
d1031 2
a1032 2
STATIC void *
S_new_body(pTHX_ svtype sv_type)
d1034 4
a1037 4
    dVAR;
    void *xpv;
    new_body_inline(xpv, sv_type);
    return xpv;
d1040 14
a1053 1
#endif
d1055 1
a1055 2
/*
=for apidoc sv_upgrade
d1057 8
a1064 3
Upgrade an SV to a more complex form.  Generally adds a new body type to the
SV, then copies across as much information as possible from the old body.
You generally want to use the C<SvUPGRADE> macro wrapper. See also C<svtype>.
d1066 1
a1066 2
=cut
*/
d1068 2
a1069 2
void
Perl_sv_upgrade(pTHX_ register SV *sv, svtype new_type)
d1071 9
a1079 7
    dVAR;
    void*	old_body;
    void*	new_body;
    const svtype old_type = SvTYPE(sv);
    const struct body_details *new_type_details;
    const struct body_details *const old_type_details
	= bodies_by_type + old_type;
d1081 1
a1081 3
    if (new_type != SVt_PV && SvIsCOW(sv)) {
	sv_force_normal_flags(sv, 0);
    }
d1083 8
a1090 2
    if (old_type == new_type)
	return;
d1092 1
a1092 3
    if (old_type > new_type)
	Perl_croak(aTHX_ "sv_upgrade from type %d down to type %d",
		(int)old_type, (int)new_type);
d1094 12
d1107 1
a1107 1
    old_body = SvANY(sv);
d1109 8
a1116 2
    /* Copying structures onto other structures that have been neatly zeroed
       has a subtle gotcha. Consider XPVMG
d1118 1
a1118 4
       +------+------+------+------+------+-------+-------+
       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH |
       +------+------+------+------+------+-------+-------+
       0      4      8     12     16     20      24      28
d1120 12
a1131 2
       where NVs are aligned to 8 bytes, so that sizeof that structure is
       actually 32 bytes long, with 4 bytes of padding at the end:
d1133 1
a1133 4
       +------+------+------+------+------+-------+-------+------+
       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH | ???  |
       +------+------+------+------+------+-------+-------+------+
       0      4      8     12     16     20      24      28     32
d1135 8
a1142 1
       so what happens if you allocate memory for this structure:
d1144 1
a1144 4
       +------+------+------+------+------+-------+-------+------+------+...
       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH |  GP  | NAME |
       +------+------+------+------+------+-------+-------+------+------+...
       0      4      8     12     16     20      24      28     32     36
d1146 12
a1157 5
       zero it, then copy sizeof(XPVMG) bytes on top of it? Not quite what you
       expect, because you copy the area marked ??? onto GP. Now, ??? may have
       started out as zero once, but it's quite possible that it isn't. So now,
       rather than a nicely zeroed GP, you have it pointing somewhere random.
       Bugs ensue.
d1159 1
a1159 5
       (In fact, GP ends up pointing at a previous GP structure, because the
       principle cause of the padding in XPVMG getting garbage is a copy of
       sizeof(XPVMG) bytes from a XPVGV structure in sv_unglob. Right now
       this happens to be moot because XPVGV has been re-ordered, with GP
       no longer after STASH)
d1161 8
a1168 2
       So we are careful and work out the size of used parts of all the
       structures.  */
d1170 1
a1170 41
    switch (old_type) {
    case SVt_NULL:
	break;
    case SVt_IV:
	if (new_type < SVt_PVIV) {
	    new_type = (new_type == SVt_NV)
		? SVt_PVNV : SVt_PVIV;
	}
	break;
    case SVt_NV:
	if (new_type < SVt_PVNV) {
	    new_type = SVt_PVNV;
	}
	break;
    case SVt_RV:
	break;
    case SVt_PV:
	assert(new_type > SVt_PV);
	assert(SVt_IV < SVt_PV);
	assert(SVt_NV < SVt_PV);
	break;
    case SVt_PVIV:
	break;
    case SVt_PVNV:
	break;
    case SVt_PVMG:
	/* Because the XPVMG of PL_mess_sv isn't allocated from the arena,
	   there's no way that it can be safely upgraded, because perl.c
	   expects to Safefree(SvANY(PL_mess_sv))  */
	assert(sv != PL_mess_sv);
	/* This flag bit is used to mean other things in other scalar types.
	   Given that it only has meaning inside the pad, it shouldn't be set
	   on anything that can get upgraded.  */
	assert(!SvPAD_TYPED(sv));
	break;
    default:
	if (old_type_details->cant_upgrade)
	    Perl_croak(aTHX_ "Can't upgrade %s (%" UVuf ") to %" UVuf,
		       sv_reftype(sv, 0), (UV) old_type, (UV) new_type);
    }
    new_type_details = bodies_by_type + new_type;
d1172 12
a1183 2
    SvFLAGS(sv) &= ~SVTYPEMASK;
    SvFLAGS(sv) |= new_type;
d1185 1
a1185 22
    /* This can't happen, as SVt_NULL is <= all values of new_type, so one of
       the return statements above will have triggered.  */
    assert (new_type != SVt_NULL);
    switch (new_type) {
    case SVt_IV:
	assert(old_type == SVt_NULL);
	SvANY(sv) = (XPVIV*)((char*)&(sv->sv_u.svu_iv) - STRUCT_OFFSET(XPVIV, xiv_iv));
	SvIV_set(sv, 0);
	return;
    case SVt_NV:
	assert(old_type == SVt_NULL);
	SvANY(sv) = new_XNV();
	SvNV_set(sv, 0);
	return;
    case SVt_RV:
	assert(old_type == SVt_NULL);
	SvANY(sv) = &sv->sv_u.svu_rv;
	SvRV_set(sv, 0);
	return;
    case SVt_PVHV:
    case SVt_PVAV:
	assert(new_type_details->body_size);
d1187 8
a1194 18
#ifndef PURIFY	
	assert(new_type_details->arena);
	assert(new_type_details->arena_size);
	/* This points to the start of the allocated area.  */
	new_body_inline(new_body, new_type);
	Zero(new_body, new_type_details->body_size, char);
	new_body = ((char *)new_body) - new_type_details->offset;
#else
	/* We always allocated the full length item with PURIFY. To do this
	   we fake things so that arena is false for all 16 types..  */
	new_body = new_NOARENAZ(new_type_details);
#endif
	SvANY(sv) = new_body;
	if (new_type == SVt_PVAV) {
	    AvMAX(sv)	= -1;
	    AvFILLp(sv)	= -1;
	    AvREAL_only(sv);
	}
d1196 1
a1196 7
	/* SVt_NULL isn't the only thing upgraded to AV or HV.
	   The target created by newSVrv also is, and it can have magic.
	   However, it never has SvPVX set.
	*/
	if (old_type >= SVt_RV) {
	    assert(SvPVX_const(sv) == 0);
	}
d1198 135
a1332 7
	if (old_type >= SVt_PVMG) {
	    SvMAGIC_set(sv, ((XPVMG*)old_body)->xmg_u.xmg_magic);
	    SvSTASH_set(sv, ((XPVMG*)old_body)->xmg_stash);
	} else {
	    sv->sv_u.svu_array = NULL; /* or svu_hash  */
	}
	break;
d1334 3
d1338 2
a1339 13
    case SVt_PVIV:
	/* XXX Is this still needed?  Was it ever needed?   Surely as there is
	   no route from NV to PVIV, NOK can never be true  */
	assert(!SvNOKp(sv));
	assert(!SvNOK(sv));
    case SVt_PVIO:
    case SVt_PVFM:
    case SVt_PVGV:
    case SVt_PVCV:
    case SVt_PVLV:
    case SVt_PVMG:
    case SVt_PVNV:
    case SVt_PV:
d1341 2
a1342 12
	assert(new_type_details->body_size);
	/* We always allocated the full length item with PURIFY. To do this
	   we fake things so that arena is false for all 16 types..  */
	if(new_type_details->arena) {
	    /* This points to the start of the allocated area.  */
	    new_body_inline(new_body, new_type);
	    Zero(new_body, new_type_details->body_size, char);
	    new_body = ((char *)new_body) - new_type_details->offset;
	} else {
	    new_body = new_NOARENAZ(new_type_details);
	}
	SvANY(sv) = new_body;
d1344 7
a1350 17
	if (old_type_details->copy) {
	    /* There is now the potential for an upgrade from something without
	       an offset (PVNV or PVMG) to something with one (PVCV, PVFM)  */
	    int offset = old_type_details->offset;
	    int length = old_type_details->copy;

	    if (new_type_details->offset > old_type_details->offset) {
		const int difference
		    = new_type_details->offset - old_type_details->offset;
		offset += difference;
		length -= difference;
	    }
	    assert (length >= 0);
		
	    Copy((char *)old_body + offset, (char *)new_body + offset, length,
		 char);
	}
d1352 63
a1414 15
#ifndef NV_ZERO_IS_ALLBITS_ZERO
	/* If NV 0.0 is stores as all bits 0 then Zero() already creates a
	 * correct 0.0 for us.  Otherwise, if the old body didn't have an
	 * NV slot, but the new one does, then we need to initialise the
	 * freshly created NV slot with whatever the correct bit pattern is
	 * for 0.0  */
	if (old_type_details->zero_nv && !new_type_details->zero_nv
	    && !isGV_with_GP(sv))
	    SvNV_set(sv, 0);
#endif

	if (new_type == SVt_PVIO)
	    IoPAGE_LEN(sv) = 60;
	if (old_type < SVt_RV)
	    SvPV_set(sv, NULL);
d1417 1
a1417 2
	Perl_croak(aTHX_ "panic: sv_upgrade to unknown type %lu",
		   (unsigned long)new_type);
d1420 159
a1578 11
    if (old_type_details->arena) {
	/* If there was an old body, then we need to free it.
	   Note that there is an assumption that all bodies of types that
	   can be upgraded came from arenas. Only the more complex non-
	   upgradable types are allowed to be directly malloc()ed.  */
#ifdef PURIFY
	my_safefree(old_body);
#else
	del_body((void*)((char*)old_body + old_type_details->offset),
		 &PL_body_roots[old_type]);
#endif
d1580 1
a1594 1
    PERL_UNUSED_CONTEXT;
a1595 2
    assert(SvTYPE(sv) != SVt_PVHV);
    assert(SvTYPE(sv) != SVt_PVAV);
d1622 2
a1623 4
    if (PL_madskills && newlen >= 0x100000) {
	PerlIO_printf(Perl_debug_log,
		      "Allocation too large: %"UVxf"\n", (UV)newlen);
    }
d1660 1
a1660 1
	    s = (char*)saferealloc(s, newlen);
d1663 7
a1669 1
	    s = (char*)safemalloc(newlen);
d1692 1
a1692 2
    dVAR;
    SV_CHECK_THINKFIRST_COW_DROP(sv);
a1712 1
    default: NOOP;
d1774 2
d1792 1
a1792 2
    dVAR;
    SV_CHECK_THINKFIRST_COW_DROP(sv);
a1811 1
    default: NOOP;
a1839 1
     dVAR;
d1845 1
a1845 1
          dsv = sv_2mortal(newSVpvs(""));
d1853 3
a1855 3
	  const char *s = SvPVX_const(sv);
	  const char * const end = s + SvCUR(sv);
	  for ( ; s < end && d < limit; s++ ) {
a1933 40
STATIC bool
S_glob_2number(pTHX_ GV * const gv)
{
    const U32 wasfake = SvFLAGS(gv) & SVf_FAKE;
    SV *const buffer = sv_newmortal();

    /* FAKE globs can get coerced, so need to turn this off temporarily if it
       is on.  */
    SvFAKE_off(gv);
    gv_efullname3(buffer, gv, "*");
    SvFLAGS(gv) |= wasfake;

    /* We know that all GVs stringify to something that is not-a-number,
	so no need to test that.  */
    if (ckWARN(WARN_NUMERIC))
	not_a_number(buffer);
    /* We just want something true to return, so that S_sv_2iuv_common
	can tail call us and return true.  */
    return TRUE;
}

STATIC char *
S_glob_2pv(pTHX_ GV * const gv, STRLEN * const len)
{
    const U32 wasfake = SvFLAGS(gv) & SVf_FAKE;
    SV *const buffer = sv_newmortal();

    /* FAKE globs can get coerced, so need to turn this off temporarily if it
       is on.  */
    SvFAKE_off(gv);
    gv_efullname3(buffer, gv, "*");
    SvFLAGS(gv) |= wasfake;

    assert(SvPOK(buffer));
    if (len) {
	*len = SvCUR(buffer);
    }
    return SvPVX(buffer);
}

a2020 2
    dVAR;
    PERL_UNUSED_ARG(numtype); /* Used only under DEBUGGING? */
d2065 58
a2122 3
STATIC bool
S_sv_2iuv_common(pTHX_ SV *sv) {
    dVAR;
d2127 1
a2127 2
	 * IV or UV at same time to avoid this. */
	/* IV-over-UV optimisation - choose to cache IV if possible */
a2136 7
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	if (Perl_isnan(SvNVX(sv))) {
	    SvUV_set(sv, 0);
	    SvIsUV_on(sv);
	    return FALSE;
	}
#endif
d2190 1
d2196 1
d2202 1
a2202 1
	/* We want to avoid a possible problem when we cache an IV/ a UV which
d2209 1
a2209 1
	   This means that if we cache such an IV/a UV, we need to cache the
d2224 1
a2224 1
	/* If NVs preserve UVs then we only use the UV value if we know that
a2240 1
		    /* it didn't overflow, and it was positive. */
d2281 1
d2283 37
a2319 10
            (void)SvIOKp_on(sv);
            (void)SvNOK_on(sv);
            if (SvNVX(sv) < (NV)IV_MAX + 0.5) {
                SvIV_set(sv, I_V(SvNVX(sv)));
                if ((NV)(SvIVX(sv)) == SvNVX(sv)) {
                    SvIOK_on(sv);
                } else {
		    NOOP;  /* Integer is imprecise. NOK, IOKp */
                }
                /* UV will not work better than IV */
d2321 4
a2324 29
                if (SvNVX(sv) > (NV)UV_MAX) {
                    SvIsUV_on(sv);
                    /* Integer is inaccurate. NOK, IOKp, is UV */
                    SvUV_set(sv, UV_MAX);
                } else {
                    SvUV_set(sv, U_V(SvNVX(sv)));
                    /* 0xFFFFFFFFFFFFFFFF not an issue in here, NVs
                       NV preservse UV so can do correct comparison.  */
                    if ((NV)(SvUVX(sv)) == SvNVX(sv)) {
                        SvIOK_on(sv);
                    } else {
			NOOP;   /* Integer is imprecise. NOK, IOKp, is UV */
                    }
                }
		SvIsUV_on(sv);
            }
#else /* NV_PRESERVES_UV */
            if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
                == (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT)) {
                /* The IV/UV slot will have been set from value returned by
                   grok_number above.  The NV slot has just been set using
                   Atof.  */
	        SvNOK_on(sv);
                assert (SvIOKp(sv));
            } else {
                if (((UV)1 << NV_PRESERVES_UV_BITS) >
                    U_V(SvNVX(sv) > 0 ? SvNVX(sv) : -SvNVX(sv))) {
                    /* Small enough to preserve all bits. */
                    (void)SvIOKp_on(sv);
d2344 3
a2346 1
                    sv_2iuv_non_preserve (sv, numtype);
d2351 3
a2353 9
    }
    else  {
	if (isGV_with_GP(sv))
	    return glob_2number((GV *)sv);

	if (!(SvFLAGS(sv) & SVs_PADTMP)) {
	    if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	}
d2357 1
a2357 2
	/* Return 0 from the caller.  */
	return TRUE;
d2359 3
a2361 1
    return FALSE;
d2365 1
a2365 1
=for apidoc sv_2iv_flags
d2367 3
a2369 3
Return the integer value of an SV, doing any necessary string
conversion.  If flags includes SV_GMAGIC, does an mg_get() first.
Normally used via the C<SvIV(sv)> and C<SvIVx(sv)> macros.
d2374 2
a2375 2
IV
Perl_sv_2iv_flags(pTHX_ register SV *sv, I32 flags)
a2376 1
    dVAR;
d2379 2
a2380 7
    if (SvGMAGICAL(sv) || (SvTYPE(sv) == SVt_PVGV && SvVALID(sv))) {
	/* FBMs use the same flag bit as SVf_IVisUV, so must let them
	   cache IVs just in case. In practice it seems that they never
	   actually anywhere accessible by user Perl code, let alone get used
	   in anything other than a string context.  */
	if (flags & SV_GMAGIC)
	    mg_get(sv);
d2382 9
a2390 19
	    return SvIVX(sv);
	if (SvNOKp(sv)) {
	    return I_V(SvNVX(sv));
	}
	if (SvPOKp(sv) && SvLEN(sv)) {
	    UV value;
	    const int numtype
		= grok_number(SvPVX_const(sv), SvCUR(sv), &value);

	    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
		== IS_NUMBER_IN_UV) {
		/* It's definitely an integer */
		if (numtype & IS_NUMBER_NEG) {
		    if (value < (UV)IV_MIN)
			return -(IV)value;
		} else {
		    if (value < (UV)IV_MAX)
			return (IV)value;
		}
d2392 1
a2392 5
	    if (!numtype) {
		if (ckWARN(WARN_NUMERIC))
		    not_a_number(sv);
	    }
	    return I_V(Atof(SvPVX_const(sv)));
d2394 2
a2395 6
        if (SvROK(sv)) {
	    goto return_rok;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit inside S_sv_2iuv_common.  */
    } else if (SvTHINKFIRST(sv)) {
d2397 5
a2401 8
	return_rok:
	    if (SvAMAGIC(sv)) {
		SV * const tmpstr=AMG_CALLun(sv,numer);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvIV(tmpstr);
		}
	    }
	    return PTR2IV(SvRV(sv));
d2403 2
a2404 2
	if (SvIsCOW(sv)) {
	    sv_force_normal_flags(sv, 0);
d2408 1
a2408 1
		report_uninit(sv);
d2412 78
a2489 3
    if (!SvIOKp(sv)) {
	if (S_sv_2iuv_common(aTHX_ sv))
	    return 0;
d2491 34
a2524 4
    DEBUG_c(PerlIO_printf(Perl_debug_log, "0x%"UVxf" 2iv(%"IVdf")\n",
	PTR2UV(sv),SvIVX(sv)));
    return SvIsUV(sv) ? (IV)SvUVX(sv) : SvIVX(sv);
}
d2526 31
a2556 2
/*
=for apidoc sv_2uv_flags
d2558 2
a2559 3
Return the unsigned integer value of an SV, doing any necessary string
conversion.  If flags includes SV_GMAGIC, does an mg_get() first.
Normally used via the C<SvUV(sv)> and C<SvUVx(sv)> macros.
d2561 7
a2567 2
=cut
*/
d2569 57
a2625 31
UV
Perl_sv_2uv_flags(pTHX_ register SV *sv, I32 flags)
{
    dVAR;
    if (!sv)
	return 0;
    if (SvGMAGICAL(sv) || (SvTYPE(sv) == SVt_PVGV && SvVALID(sv))) {
	/* FBMs use the same flag bit as SVf_IVisUV, so must let them
	   cache IVs just in case.  */
	if (flags & SV_GMAGIC)
	    mg_get(sv);
	if (SvIOKp(sv))
	    return SvUVX(sv);
	if (SvNOKp(sv))
	    return U_V(SvNVX(sv));
	if (SvPOKp(sv) && SvLEN(sv)) {
	    UV value;
	    const int numtype
		= grok_number(SvPVX_const(sv), SvCUR(sv), &value);

	    if ((numtype & (IS_NUMBER_IN_UV | IS_NUMBER_NOT_INT))
		== IS_NUMBER_IN_UV) {
		/* It's definitely an integer */
		if (!(numtype & IS_NUMBER_NEG))
		    return value;
	    }
	    if (!numtype) {
		if (ckWARN(WARN_NUMERIC))
		    not_a_number(sv);
	    }
	    return U_V(Atof(SvPVX_const(sv)));
d2627 5
a2631 2
        if (SvROK(sv)) {
	    goto return_rok;
d2633 4
a2636 25
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit inside S_sv_2iuv_common.  */
    } else if (SvTHINKFIRST(sv)) {
	if (SvROK(sv)) {
	return_rok:
	    if (SvAMAGIC(sv)) {
		SV *const tmpstr = AMG_CALLun(sv,numer);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvUV(tmpstr);
		}
	    }
	    return PTR2UV(SvRV(sv));
	}
	if (SvIsCOW(sv)) {
	    sv_force_normal_flags(sv, 0);
	}
	if (SvREADONLY(sv) && !SvOK(sv)) {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
	    return 0;
	}
    }
    if (!SvIOKp(sv)) {
	if (S_sv_2iuv_common(aTHX_ sv))
	    return 0;
a2656 1
    dVAR;
d2659 1
a2659 3
    if (SvGMAGICAL(sv) || (SvTYPE(sv) == SVt_PVGV && SvVALID(sv))) {
	/* FBMs use the same flag bit as SVf_IVisUV, so must let them
	   cache IVs just in case.  */
d2663 1
a2663 1
	if ((SvPOKp(sv) && SvLEN(sv)) && !SvIOKp(sv)) {
d2674 10
a2683 8
	}
        if (SvROK(sv)) {
	    goto return_rok;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit near the end of the
	   function. */
    } else if (SvTHINKFIRST(sv)) {
d2685 5
a2689 8
	return_rok:
	    if (SvAMAGIC(sv)) {
		SV *const tmpstr = AMG_CALLun(sv,numer);
                if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    return SvNV(tmpstr);
		}
	    }
	    return PTR2NV(SvRV(sv));
d2691 2
a2692 2
	if (SvIsCOW(sv)) {
	    sv_force_normal_flags(sv, 0);
d2696 1
a2696 1
		report_uninit(sv);
d2701 4
a2704 2
	/* The logic to use SVt_PVNV if necessary is in sv_upgrade.  */
	sv_upgrade(sv, SVt_NV);
d2798 1
d2800 1
a2802 1
			SvIOK_on(sv);
d2814 3
a2817 1
			    SvIOK_on(sv);
a2825 5
	if (isGV_with_GP(sv)) {
	    glob_2number((GV *)sv);
	    return 0.0;
	}

d2827 6
a2832 5
	    report_uninit(sv);
	assert (SvTYPE(sv) >= SVt_NV);
	/* Typically the caller expects that sv_any is not NULL now.  */
	/* XXX Ilya implies that this is a bug in callers that assume this
	   and ideally should be fixed.  */
d2853 49
d2903 1
a2903 5
=for apidoc sv_2num

Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  You must use the C<SvNUM(sv)> macro to
access this function.
d2905 2
d2910 2
a2911 2
SV *
Perl_sv_2num(pTHX_ register SV *sv)
d2913 1
a2913 8
    if (!SvROK(sv))
	return sv;
    if (SvAMAGIC(sv)) {
	SV * const tmpsv = AMG_CALLun(sv,numer);
	if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv))))
	    return sv_2num(tmpsv);
    }
    return sv_2mortal(newSVuv(PTR2UV(SvRV(sv))));
d2948 10
a2972 1
    dVAR;
d2974 4
d2996 17
a3012 11
	if (SvIOKp(sv) || SvNOKp(sv)) {
	    char tbuf[64];  /* Must fit sprintf/Gconvert of longest IV/NV */
	    STRLEN len;

	    if (SvIOKp(sv)) {
		len = SvIsUV(sv)
		    ? my_snprintf(tbuf, sizeof(tbuf), "%"UVuf, (UV)SvUVX(sv))
		    : my_snprintf(tbuf, sizeof(tbuf), "%"IVdf, (IV)SvIVX(sv));
	    } else {
		Gconvert(SvNVX(sv), NV_DIG, 0, tbuf);
		len = strlen(tbuf);
d3014 6
a3019 27
	    assert(!SvROK(sv));
	    {
		dVAR;

#ifdef FIXNEGATIVEZERO
		if (len == 2 && tbuf[0] == '-' && tbuf[1] == '0') {
		    tbuf[0] = '0';
		    tbuf[1] = 0;
		    len = 1;
		}
#endif
		SvUPGRADE(sv, SVt_PV);
		if (lp)
		    *lp = len;
		s = SvGROW_mutable(sv, len + 1);
		SvCUR_set(sv, len);
		SvPOKp_on(sv);
		return (char*)memcpy(s, tbuf, len + 1);
	    }
	}
        if (SvROK(sv)) {
	    goto return_rok;
	}
	assert(SvTYPE(sv) >= SVt_PVMG);
	/* This falls through to the report_uninit near the end of the
	   function. */
    } else if (SvTHINKFIRST(sv)) {
d3021 11
a3031 18
	return_rok:
            if (SvAMAGIC(sv)) {
		SV *const tmpstr = AMG_CALLun(sv,string);
		if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		    /* Unwrap this:  */
		    /* char *pv = lp ? SvPV(tmpstr, *lp) : SvPV_nolen(tmpstr);
		     */

		    char *pv;
		    if ((SvFLAGS(tmpstr) & (SVf_POK)) == SVf_POK) {
			if (flags & SV_CONST_RETURN) {
			    pv = (char *) SvPVX_const(tmpstr);
			} else {
			    pv = (flags & SV_MUTABLE_RETURN)
				? SvPVX_mutable(tmpstr) : SvPVX(tmpstr);
			}
			if (lp)
			    *lp = SvCUR(tmpstr);
d3033 2
a3034 1
			pv = sv_2pv_flags(tmpstr, lp, flags);
d3036 4
a3039 5
		    if (SvUTF8(tmpstr))
			SvUTF8_on(sv);
		    else
			SvUTF8_off(sv);
		    return pv;
d3041 11
a3051 5
	    }
	    {
		STRLEN len;
		char *retval;
		char *buffer;
d3053 65
a3117 1
		const SV *const referent = (SV*)SvRV(sv);
d3119 9
a3127 42
		if (!referent) {
		    len = 7;
		    retval = buffer = savepvn("NULLREF", len);
		} else if (SvTYPE(referent) == SVt_PVMG
			   && ((SvFLAGS(referent) &
				(SVs_OBJECT|SVf_OK|SVs_GMG|SVs_SMG|SVs_RMG))
			       == (SVs_OBJECT|SVs_SMG))
			   && (mg = mg_find(referent, PERL_MAGIC_qr)))
                {
                    char *str = NULL;
                    I32 haseval = 0;
                    U32 flags = 0;
                    (str) = CALLREG_AS_STR(mg,lp,&flags,&haseval);
                    if (flags & 1)
	                SvUTF8_on(sv);
                    else
	                SvUTF8_off(sv);
                    PL_reginterp_cnt += haseval;
		    return str;
		} else {
		    const char *const typestr = sv_reftype(referent, 0);
		    const STRLEN typelen = strlen(typestr);
		    UV addr = PTR2UV(referent);
		    const char *stashname = NULL;
		    STRLEN stashnamelen = 0; /* hush, gcc */
		    const char *buffer_end;

		    if (SvOBJECT(referent)) {
			const HEK *const name = HvNAME_HEK(SvSTASH(referent));

			if (name) {
			    stashname = HEK_KEY(name);
			    stashnamelen = HEK_LEN(name);

			    if (HEK_UTF8(name)) {
				SvUTF8_on(sv);
			    } else {
				SvUTF8_off(sv);
			    }
			} else {
			    stashname = "__ANON__";
			    stashnamelen = 8;
d3129 1
a3129 6
			len = stashnamelen + 1 /* = */ + typelen + 3 /* (0x */
			    + 2 * sizeof(UV) + 2 /* )\0 */;
		    } else {
			len = typelen + 3 /* (0x */
			    + 2 * sizeof(UV) + 2 /* )\0 */;
		    }
d3131 7
a3137 20
		    Newx(buffer, len, char);
		    buffer_end = retval = buffer + len;

		    /* Working backwards  */
		    *--retval = '\0';
		    *--retval = ')';
		    do {
			*--retval = PL_hexdigit[addr & 15];
		    } while (addr >>= 4);
		    *--retval = 'x';
		    *--retval = '0';
		    *--retval = '(';

		    retval -= typelen;
		    memcpy(retval, typestr, typelen);

		    if (stashname) {
			*--retval = '=';
			retval -= stashnamelen;
			memcpy(retval, stashname, stashnamelen);
d3139 31
a3169 10
		    /* retval may not neccesarily have reached the start of the
		       buffer here.  */
		    assert (retval >= buffer);

		    len = buffer_end - retval - 1; /* -1 for that \0  */
		}
		if (lp)
		    *lp = len;
		SAVEFREEPV(buffer);
		return retval;
d3171 3
d3177 1
a3177 1
		report_uninit(sv);
d3186 1
a3189 1
	STRLEN len;
d3193 4
a3196 2
 	ptr = uiv_2buf(buf, SvIVX(sv), SvUVX(sv), isUIOK, &ebuf);
	len = ebuf - ptr;
d3198 4
a3201 3
	s = SvGROW_mutable(sv, len + 1);
	Move(ptr, s, len, char);
	s += len;
d3203 6
a3210 1
	const int olderrno = errno;
d3215 1
a3215 1
	/* some Xenix systems wipe out errno here */
d3218 1
a3218 1
	    my_strlcpy(s, "0", SvLEN(sv));
d3226 2
a3227 4
        if (*s == '-' && s[1] == '0' && !s[2]) {
	    s[0] = '0';
	    s[1] = 0;
	}
a3235 3
	if (isGV_with_GP(sv))
	    return glob_2pv((GV *)sv, lp);

d3237 1
a3237 1
	    report_uninit(sv);
d3239 1
a3239 1
	    *lp = 0;
d3259 40
d3307 1
a3307 1
UTF8 flag even from overloaded objects.  Similar in nature to
d3328 17
d3364 17
a3397 1

d3410 2
a3411 2
    dVAR;
    SvGETMAGIC(sv);
d3416 5
a3420 6
	if (SvAMAGIC(sv)) {
	    SV * const tmpsv = AMG_CALLun(sv,bool_);
	    if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv))))
		return (bool)SvTRUE(tmpsv);
	}
	return SvRV(sv) != 0;
d3425 1
a3425 1
		(*sv->sv_u.svu_pv > '0' ||
d3427 1
a3427 1
		(Xpvtmp->xpv_cur && *sv->sv_u.svu_pv != '0')))
d3438 2
a3439 6
	    else {
		if (isGV_with_GP(sv))
		    return TRUE;
		else
		    return FALSE;
	    }
d3444 11
a3483 1
    dVAR;
d3501 2
a3502 2
    if (SvIsCOW(sv)) {
        sv_force_normal_flags(sv, 0);
d3512 2
a3513 2
	const U8 * const s = (U8 *) SvPVX_const(sv);
	const U8 * const e = (U8 *) SvEND(sv);
d3515 1
d3519 1
a3519 9
	    /* Check for hi bit */
	    if (!NATIVE_IS_INVARIANT(ch)) {
		STRLEN len = SvCUR(sv) + 1; /* Plus the \0 */
		U8 * const recoded = bytes_to_utf8((U8*)s, &len);

		SvPV_free(sv); /* No longer using what was there before. */
		SvPV_set(sv, (char*)recoded);
		SvCUR_set(sv, len - 1);
		SvLEN_set(sv, len); /* No longer know the real size. */
d3521 10
a3530 1
	    }
a3554 1
    dVAR;
d3560 2
a3561 3
            if (SvIsCOW(sv)) {
                sv_force_normal_flags(sv, 0);
            }
d3593 1
a3599 1
    (void) sv_utf8_upgrade(sv);
d3632 1
a3632 1
	if (!is_utf8_string(c, SvCUR(sv)+1))
d3646 10
a3690 186
static void
S_glob_assign_glob(pTHX_ SV *dstr, SV *sstr, const int dtype)
{
    I32 mro_changes = 0; /* 1 = method, 2 = isa */

    if (dtype != SVt_PVGV) {
	const char * const name = GvNAME(sstr);
	const STRLEN len = GvNAMELEN(sstr);
	{
	    if (dtype >= SVt_PV) {
		SvPV_free(dstr);
		SvPV_set(dstr, 0);
		SvLEN_set(dstr, 0);
		SvCUR_set(dstr, 0);
	    }
	    SvUPGRADE(dstr, SVt_PVGV);
	    (void)SvOK_off(dstr);
	    /* FIXME - why are we doing this, then turning it off and on again
	       below?  */
	    isGV_with_GP_on(dstr);
	}
	GvSTASH(dstr) = GvSTASH(sstr);
	if (GvSTASH(dstr))
	    Perl_sv_add_backref(aTHX_ (SV*)GvSTASH(dstr), dstr);
	gv_name_set((GV *)dstr, name, len, GV_ADD);
	SvFAKE_on(dstr);	/* can coerce to non-glob */
    }

#ifdef GV_UNIQUE_CHECK
    if (GvUNIQUE((GV*)dstr)) {
	Perl_croak(aTHX_ PL_no_modify);
    }
#endif

    if(GvGP((GV*)sstr)) {
        /* If source has method cache entry, clear it */
        if(GvCVGEN(sstr)) {
            SvREFCNT_dec(GvCV(sstr));
            GvCV(sstr) = NULL;
            GvCVGEN(sstr) = 0;
        }
        /* If source has a real method, then a method is
           going to change */
        else if(GvCV((GV*)sstr)) {
            mro_changes = 1;
        }
    }

    /* If dest already had a real method, that's a change as well */
    if(!mro_changes && GvGP((GV*)dstr) && GvCVu((GV*)dstr)) {
        mro_changes = 1;
    }

    if(strEQ(GvNAME((GV*)dstr),"ISA"))
        mro_changes = 2;

    gp_free((GV*)dstr);
    isGV_with_GP_off(dstr);
    (void)SvOK_off(dstr);
    isGV_with_GP_on(dstr);
    GvINTRO_off(dstr);		/* one-shot flag */
    GvGP(dstr) = gp_ref(GvGP(sstr));
    if (SvTAINTED(sstr))
	SvTAINT(dstr);
    if (GvIMPORTED(dstr) != GVf_IMPORTED
	&& CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
	{
	    GvIMPORTED_on(dstr);
	}
    GvMULTI_on(dstr);
    if(mro_changes == 2) mro_isa_changed_in(GvSTASH(dstr));
    else if(mro_changes) mro_method_changed_in(GvSTASH(dstr));
    return;
}

static void
S_glob_assign_ref(pTHX_ SV *dstr, SV *sstr) {
    SV * const sref = SvREFCNT_inc(SvRV(sstr));
    SV *dref = NULL;
    const int intro = GvINTRO(dstr);
    SV **location;
    U8 import_flag = 0;
    const U32 stype = SvTYPE(sref);


#ifdef GV_UNIQUE_CHECK
    if (GvUNIQUE((GV*)dstr)) {
	Perl_croak(aTHX_ PL_no_modify);
    }
#endif

    if (intro) {
	GvINTRO_off(dstr);	/* one-shot flag */
	GvLINE(dstr) = CopLINE(PL_curcop);
	GvEGV(dstr) = (GV*)dstr;
    }
    GvMULTI_on(dstr);
    switch (stype) {
    case SVt_PVCV:
	location = (SV **) &GvCV(dstr);
	import_flag = GVf_IMPORTED_CV;
	goto common;
    case SVt_PVHV:
	location = (SV **) &GvHV(dstr);
	import_flag = GVf_IMPORTED_HV;
	goto common;
    case SVt_PVAV:
	location = (SV **) &GvAV(dstr);
	import_flag = GVf_IMPORTED_AV;
	goto common;
    case SVt_PVIO:
	location = (SV **) &GvIOp(dstr);
	goto common;
    case SVt_PVFM:
	location = (SV **) &GvFORM(dstr);
    default:
	location = &GvSV(dstr);
	import_flag = GVf_IMPORTED_SV;
    common:
	if (intro) {
	    if (stype == SVt_PVCV) {
		/*if (GvCVGEN(dstr) && (GvCV(dstr) != (CV*)sref || GvCVGEN(dstr))) {*/
		if (GvCVGEN(dstr)) {
		    SvREFCNT_dec(GvCV(dstr));
		    GvCV(dstr) = NULL;
		    GvCVGEN(dstr) = 0; /* Switch off cacheness. */
		}
	    }
	    SAVEGENERICSV(*location);
	}
	else
	    dref = *location;
	if (stype == SVt_PVCV && (*location != sref || GvCVGEN(dstr))) {
	    CV* const cv = (CV*)*location;
	    if (cv) {
		if (!GvCVGEN((GV*)dstr) &&
		    (CvROOT(cv) || CvXSUB(cv)))
		    {
			/* Redefining a sub - warning is mandatory if
			   it was a const and its value changed. */
			if (CvCONST(cv)	&& CvCONST((CV*)sref)
			    && cv_const_sv(cv) == cv_const_sv((CV*)sref)) {
			    NOOP;
			    /* They are 2 constant subroutines generated from
			       the same constant. This probably means that
			       they are really the "same" proxy subroutine
			       instantiated in 2 places. Most likely this is
			       when a constant is exported twice.  Don't warn.
			    */
			}
			else if (ckWARN(WARN_REDEFINE)
				 || (CvCONST(cv)
				     && (!CvCONST((CV*)sref)
					 || sv_cmp(cv_const_sv(cv),
						   cv_const_sv((CV*)sref))))) {
			    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
					(const char *)
					(CvCONST(cv)
					 ? "Constant subroutine %s::%s redefined"
					 : "Subroutine %s::%s redefined"),
					HvNAME_get(GvSTASH((GV*)dstr)),
					GvENAME((GV*)dstr));
			}
		    }
		if (!intro)
		    cv_ckproto_len(cv, (GV*)dstr,
				   SvPOK(sref) ? SvPVX_const(sref) : NULL,
				   SvPOK(sref) ? SvCUR(sref) : 0);
	    }
	    GvCVGEN(dstr) = 0; /* Switch off cacheness. */
	    GvASSUMECV_on(dstr);
	    if(GvSTASH(dstr)) mro_method_changed_in(GvSTASH(dstr)); /* sub foo { 1 } sub bar { 2 } *bar = \&foo */
	}
	*location = sref;
	if (import_flag && !(GvFLAGS(dstr) & import_flag)
	    && CopSTASH_ne(PL_curcop, GvSTASH(dstr))) {
	    GvFLAGS(dstr) |= import_flag;
	}
	break;
    }
    SvREFCNT_dec(dref);
    if (SvTAINTED(sstr))
	SvTAINT(dstr);
    return;
}

a3693 1
    dVAR;
d3696 1
a3696 1
    register svtype stype;
d3700 1
a3700 6

    if (SvIS_FREED(dstr)) {
	Perl_croak(aTHX_ "panic: attempt to copy value %" SVf
		   " to a freed scalar %p", SVfARG(sstr), (void *)dstr);
    }
    SV_CHECK_THINKFIRST_COW_DROP(dstr);
a3702 4
    if (SvIS_FREED(sstr)) {
	Perl_croak(aTHX_ "panic: attempt to copy freed scalar %p to %p",
		   (void*)sstr, (void*)dstr);
    }
d3706 2
a3707 2
    (void)SvAMAGIC_off(dstr);
    if ( SvVOK(dstr) )
d3731 2
a3736 2
	    case SVt_PVGV:
		goto end_of_first_switch;
d3742 2
a3743 5
	    /* SvTAINTED can only be true if the SV has taint magic, which in
	       turn means that the SV type is PVMG (or greater). This is the
	       case statement for SVt_IV, so this cannot be true (whatever gcov
	       may say).  */
	    assert(!SvTAINTED(sstr));
a3759 2
	    case SVt_PVGV:
		goto end_of_first_switch;
d3763 2
a3764 5
	    /* SvTAINTED can only be true if the SV has taint magic, which in
	       turn means that the SV type is PVMG (or greater). This is the
	       case statement for SVt_NV, so this cannot be true (whatever gcov
	       may say).  */
	    assert(!SvTAINTED(sstr));
d3772 14
d3787 1
a3788 9
#ifdef PERL_OLD_COPY_ON_WRITE
	if ((SvFLAGS(sstr) & CAN_COW_MASK) == CAN_COW_FLAGS) {
	    if (dtype < SVt_PVIV)
		sv_upgrade(dstr, SVt_PVIV);
	    break;
	}
	/* Fall through */
#endif
    case SVt_PV:
d3800 4
a3803 1
    default:
a3812 2
	/* case SVt_BIND: */
    case SVt_PVLV:
d3814 36
a3849 2
	if (isGV_with_GP(sstr) && dtype <= SVt_PVGV) {
	    glob_assign_glob(dstr, sstr, dtype);
d3852 1
a3852 2
	/* SvVALID means that this PVGV is playing at being an FBM.  */
	/*FALLTHROUGH*/
d3854 1
a3854 1
    case SVt_PVMG:
d3857 1
a3857 1
	    if (SvTYPE(sstr) != stype) {
d3859 2
a3860 4
		if (isGV_with_GP(sstr) && stype == SVt_PVGV && dtype <= SVt_PVGV) {
		    glob_assign_glob(dstr, sstr, dtype);
		    return;
		}
d3864 1
a3864 1
	    SvUPGRADE(dstr, SVt_PVNV);
d3866 1
a3866 1
	    SvUPGRADE(dstr, (svtype)stype);
a3867 1
 end_of_first_switch:
a3868 2
    /* dstr may have been upgraded.  */
    dtype = SvTYPE(dstr);
d3871 12
a3882 5
    if (dtype == SVt_PVCV || dtype == SVt_PVFM) {
	/* Assigning to a subroutine sets the prototype.  */
	if (SvOK(sstr)) {
	    STRLEN len;
	    const char *const ptr = SvPV_const(sstr, len);
d3884 4
a3887 23
            SvGROW(dstr, len + 1);
            Copy(ptr, SvPVX(dstr), len + 1, char);
            SvCUR_set(dstr, len);
	    SvPOK_only(dstr);
	    SvFLAGS(dstr) |= sflags & SVf_UTF8;
	} else {
	    SvOK_off(dstr);
	}
    } else if (dtype == SVt_PVAV || dtype == SVt_PVHV) {
	const char * const type = sv_reftype(dstr,0);
	if (PL_op)
	    Perl_croak(aTHX_ "Cannot copy to %s in %s", type, OP_NAME(PL_op));
	else
	    Perl_croak(aTHX_ "Cannot copy to %s", type);
    } else if (sflags & SVf_ROK) {
	if (isGV_with_GP(dstr) && dtype == SVt_PVGV
	    && SvTYPE(SvRV(sstr)) == SVt_PVGV) {
	    sstr = SvRV(sstr);
	    if (sstr == dstr) {
		if (GvIMPORTED(dstr) != GVf_IMPORTED
		    && CopSTASH_ne(PL_curcop, GvSTASH(dstr)))
		{
		    GvIMPORTED_on(dstr);
d3890 114
a4003 9
		return;
	    }
	    glob_assign_glob(dstr, sstr, dtype);
	    return;
	}

	if (dtype >= SVt_PV) {
	    if (dtype == SVt_PVGV && isGV_with_GP(dstr)) {
		glob_assign_ref(dstr, sstr);
d4014 15
a4028 11
	SvFLAGS(dstr) |= sflags & SVf_ROK;
	assert(!(sflags & SVp_NOK));
	assert(!(sflags & SVp_IOK));
	assert(!(sflags & SVf_NOK));
	assert(!(sflags & SVf_IOK));
    }
    else if (dtype == SVt_PVGV && isGV_with_GP(dstr)) {
	if (!(sflags & SVf_OK)) {
	    if (ckWARN(WARN_MISC))
		Perl_warner(aTHX_ packWARN(WARN_MISC),
			    "Undefined value assigned to typeglob");
d4030 2
a4031 7
	else {
	    GV *gv = gv_fetchsv(sstr, GV_ADD, SVt_PVGV);
	    if (dstr != (SV*)gv) {
		if (GvGP(dstr))
		    gp_free((GV*)dstr);
		GvGP(dstr) = gp_ref(GvGP(gv));
	    }
a4034 1
        bool isSwipe = 0;
a4040 3
	 * Likewise if we can set up COW rather than doing an actual copy, we
	 * drop to the else clause, as the swipe code and the COW setup code
	 * have much in common.
d4043 5
a4047 38
	/* Whichever path we take through the next code, we want this true,
	   and doing it now facilitates the COW check.  */
	(void)SvPOK_only(dstr);

	if (
	    /* If we're already COW then this clause is not true, and if COW
	       is allowed then we drop down to the else and make dest COW 
	       with us.  If caller hasn't said that we're allowed to COW
	       shared hash keys then we don't do the COW setup, even if the
	       source scalar is a shared hash key scalar.  */
            (((flags & SV_COW_SHARED_HASH_KEYS)
	       ? (sflags & (SVf_FAKE|SVf_READONLY)) != (SVf_FAKE|SVf_READONLY)
	       : 1 /* If making a COW copy is forbidden then the behaviour we
		       desire is as if the source SV isn't actually already
		       COW, even if it is.  So we act as if the source flags
		       are not COW, rather than actually testing them.  */
	      )
#ifndef PERL_OLD_COPY_ON_WRITE
	     /* The change that added SV_COW_SHARED_HASH_KEYS makes the logic
		when PERL_OLD_COPY_ON_WRITE is defined a little wrong.
		Conceptually PERL_OLD_COPY_ON_WRITE being defined should
		override SV_COW_SHARED_HASH_KEYS, because it means "always COW"
		but in turn, it's somewhat dead code, never expected to go
		live, but more kept as a placeholder on how to do it better
		in a newer implementation.  */
	     /* If we are COW and dstr is a suitable target then we drop down
		into the else and make dest a COW of us.  */
	     || (SvFLAGS(dstr) & CAN_COW_MASK) != CAN_COW_FLAGS
#endif
	     )
            &&
            !(isSwipe =
                 (sflags & SVs_TEMP) &&   /* slated for free anyway? */
                 !(sflags & SVf_OOK) &&   /* and not involved in OOK hack? */
	         (!(flags & SV_NOSTEAL)) &&
					/* and we're allowed to steal temps */
                 SvREFCNT(sstr) == 1 &&   /* and no other references to it? */
                 SvLEN(sstr) 	&&	  /* and really is a string */
d4049 2
a4050 45
	      !(PL_op && PL_op->op_type == OP_AASSIGN))
#ifdef PERL_OLD_COPY_ON_WRITE
            && ((flags & SV_COW_SHARED_HASH_KEYS)
		? (!((sflags & CAN_COW_MASK) == CAN_COW_FLAGS
		     && (SvFLAGS(dstr) & CAN_COW_MASK) == CAN_COW_FLAGS
		     && SvTYPE(sstr) >= SVt_PVIV))
		: 1)
#endif
            ) {
            /* Failed the swipe test, and it's not a shared hash key either.
               Have to copy the string.  */
	    STRLEN len = SvCUR(sstr);
            SvGROW(dstr, len + 1);	/* inlined from sv_setpvn */
            Move(SvPVX_const(sstr),SvPVX(dstr),len,char);
            SvCUR_set(dstr, len);
            *SvEND(dstr) = '\0';
        } else {
            /* If PERL_OLD_COPY_ON_WRITE is not defined, then isSwipe will always
               be true in here.  */
            /* Either it's a shared hash key, or it's suitable for
               copy-on-write or we can swipe the string.  */
            if (DEBUG_C_TEST) {
                PerlIO_printf(Perl_debug_log, "Copy on write: sstr --> dstr\n");
                sv_dump(sstr);
                sv_dump(dstr);
            }
#ifdef PERL_OLD_COPY_ON_WRITE
            if (!isSwipe) {
                /* I believe I should acquire a global SV mutex if
                   it's a COW sv (not a shared hash key) to stop
                   it going un copy-on-write.
                   If the source SV has gone un copy on write between up there
                   and down here, then (assert() that) it is of the correct
                   form to make it copy on write again */
                if ((sflags & (SVf_FAKE | SVf_READONLY))
                    != (SVf_FAKE | SVf_READONLY)) {
                    SvREADONLY_on(sstr);
                    SvFAKE_on(sstr);
                    /* Make the source SV into a loop of 1.
                       (about to become 2) */
                    SV_COW_NEXT_SV_SET(sstr, sstr);
                }
            }
#endif
            /* Initial code is common.  */
d4054 22
a4075 44

            if (!isSwipe) {
                /* making another shared SV.  */
                STRLEN cur = SvCUR(sstr);
                STRLEN len = SvLEN(sstr);
#ifdef PERL_OLD_COPY_ON_WRITE
                if (len) {
		    assert (SvTYPE(dstr) >= SVt_PVIV);
                    /* SvIsCOW_normal */
                    /* splice us in between source and next-after-source.  */
                    SV_COW_NEXT_SV_SET(dstr, SV_COW_NEXT_SV(sstr));
                    SV_COW_NEXT_SV_SET(sstr, dstr);
                    SvPV_set(dstr, SvPVX_mutable(sstr));
                } else
#endif
		{
                    /* SvIsCOW_shared_hash */
                    DEBUG_C(PerlIO_printf(Perl_debug_log,
                                          "Copy on write: Sharing hash\n"));

		    assert (SvTYPE(dstr) >= SVt_PV);
                    SvPV_set(dstr,
			     HEK_KEY(share_hek_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr)))));
		}
                SvLEN_set(dstr, len);
                SvCUR_set(dstr, cur);
                SvREADONLY_on(dstr);
                SvFAKE_on(dstr);
                /* Relesase a global SV mutex.  */
            }
            else
                {	/* Passes the swipe test.  */
                SvPV_set(dstr, SvPVX_mutable(sstr));
                SvLEN_set(dstr, SvLEN(sstr));
                SvCUR_set(dstr, SvCUR(sstr));

                SvTEMP_off(dstr);
                (void)SvOK_off(sstr);	/* NOTE: nukes most SvFLAGS on sstr */
                SvPV_set(sstr, NULL);
                SvLEN_set(sstr, 0);
                SvCUR_set(sstr, 0);
                SvTEMP_off(sstr);
            }
        }
d4077 3
d4083 3
a4085 4
	    SvOOK_off(dstr);
	    SvIV_set(dstr, SvIVX(sstr));
	    /* Must do this otherwise some other overloaded use of 0x80000000
	       gets confused. I guess SVpbm_VALID */
d4088 1
d4090 6
a4095 9
	SvFLAGS(dstr) |= sflags & (SVf_IOK|SVp_IOK|SVf_NOK|SVp_NOK|SVf_UTF8);
	{
	    const MAGIC * const smg = SvVSTRING_mg(sstr);
	    if (smg) {
		sv_magic(dstr, NULL, PERL_MAGIC_vstring,
			 smg->mg_ptr, smg->mg_len);
		SvRMAGICAL_on(dstr);
	    }
	}
d4097 6
a4102 6
    else if (sflags & (SVp_IOK|SVp_NOK)) {
	(void)SvOK_off(dstr);
	SvFLAGS(dstr) |= sflags & (SVf_IOK|SVp_IOK|SVf_IVisUV|SVf_NOK|SVp_NOK);
	if (sflags & SVp_IOK) {
	    /* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
	    SvIV_set(dstr, SvIVX(sstr));
d4104 4
d4109 4
d4116 9
d4126 3
a4128 10
	if (isGV_with_GP(sstr)) {
	    /* This stringification rule for globs is spread in 3 places.
	       This feels bad. FIXME.  */
	    const U32 wasfake = sflags & SVf_FAKE;

	    /* FAKE globs can get coerced, so need to turn this off
	       temporarily if it is on.  */
	    SvFAKE_off(sstr);
	    gv_efullname3(dstr, (GV *)sstr, "*");
	    SvFLAGS(sstr) |= wasfake;
a4151 69
#ifdef PERL_OLD_COPY_ON_WRITE
SV *
Perl_sv_setsv_cow(pTHX_ SV *dstr, SV *sstr)
{
    STRLEN cur = SvCUR(sstr);
    STRLEN len = SvLEN(sstr);
    register char *new_pv;

    if (DEBUG_C_TEST) {
	PerlIO_printf(Perl_debug_log, "Fast copy on write: %p -> %p\n",
		      (void*)sstr, (void*)dstr);
	sv_dump(sstr);
	if (dstr)
		    sv_dump(dstr);
    }

    if (dstr) {
	if (SvTHINKFIRST(dstr))
	    sv_force_normal_flags(dstr, SV_COW_DROP_PV);
	else if (SvPVX_const(dstr))
	    Safefree(SvPVX_const(dstr));
    }
    else
	new_SV(dstr);
    SvUPGRADE(dstr, SVt_PVIV);

    assert (SvPOK(sstr));
    assert (SvPOKp(sstr));
    assert (!SvIOK(sstr));
    assert (!SvIOKp(sstr));
    assert (!SvNOK(sstr));
    assert (!SvNOKp(sstr));

    if (SvIsCOW(sstr)) {

	if (SvLEN(sstr) == 0) {
	    /* source is a COW shared hash key.  */
	    DEBUG_C(PerlIO_printf(Perl_debug_log,
				  "Fast copy on write: Sharing hash\n"));
	    new_pv = HEK_KEY(share_hek_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr))));
	    goto common_exit;
	}
	SV_COW_NEXT_SV_SET(dstr, SV_COW_NEXT_SV(sstr));
    } else {
	assert ((SvFLAGS(sstr) & CAN_COW_MASK) == CAN_COW_FLAGS);
	SvUPGRADE(sstr, SVt_PVIV);
	SvREADONLY_on(sstr);
	SvFAKE_on(sstr);
	DEBUG_C(PerlIO_printf(Perl_debug_log,
			      "Fast copy on write: Converting sstr to COW\n"));
	SV_COW_NEXT_SV_SET(dstr, sstr);
    }
    SV_COW_NEXT_SV_SET(sstr, dstr);
    new_pv = SvPVX_mutable(sstr);

  common_exit:
    SvPV_set(dstr, new_pv);
    SvFLAGS(dstr) = (SVt_PVIV|SVf_POK|SVp_POK|SVf_FAKE|SVf_READONLY);
    if (SvUTF8(sstr))
	SvUTF8_on(dstr);
    SvLEN_set(dstr, len);
    SvCUR_set(dstr, cur);
    if (DEBUG_C_TEST) {
	sv_dump(dstr);
    }
    return dstr;
}
#endif

a4164 1
    dVAR;
d4167 1
a4167 1
    SV_CHECK_THINKFIRST_COW_DROP(sv);
d4178 1
a4178 1
    SvUPGRADE(sv, SVt_PV);
a4214 1
    dVAR;
d4217 1
a4217 1
    SV_CHECK_THINKFIRST_COW_DROP(sv);
d4223 1
a4223 1
    SvUPGRADE(sv, SVt_PV);
d4248 1
a4248 1
=for apidoc sv_usepvn_flags
d4250 7
a4256 13
Tells an SV to use C<ptr> to find its string value.  Normally the
string is stored inside the SV but sv_usepvn allows the SV to use an
outside string.  The C<ptr> should point to memory that was allocated
by C<malloc>.  The string length, C<len>, must be supplied.  By default
this function will realloc (i.e. move) the memory pointed to by C<ptr>,
so that pointer should not be freed or used by the programmer after
giving it to sv_usepvn, and neither should any pointers from "behind"
that pointer (e.g. ptr + 1) be used.

If C<flags> & SV_SMAGIC is true, will call SvSETMAGIC. If C<flags> &
SV_HAS_TRAILING_NUL is true, then C<ptr[len]> must be NUL, and the realloc
will be skipped. (i.e. the buffer is actually at least 1 byte longer than
C<len>, and already meets the requirements for storing in C<SvPVX>)
d4262 1
a4262 1
Perl_sv_usepvn_flags(pTHX_ SV *sv, char *ptr, STRLEN len, U32 flags)
a4263 1
    dVAR;
d4265 2
a4266 2
    SV_CHECK_THINKFIRST_COW_DROP(sv);
    SvUPGRADE(sv, SVt_PV);
a4268 2
	if (flags & SV_SMAGIC)
	    SvSETMAGIC(sv);
d4274 2
a4275 22
#ifdef DEBUGGING
    if (flags & SV_HAS_TRAILING_NUL)
	assert(ptr[len] == '\0');
#endif

    allocate = (flags & SV_HAS_TRAILING_NUL)
	? len + 1: PERL_STRLEN_ROUNDUP(len + 1);
    if (flags & SV_HAS_TRAILING_NUL) {
	/* It's long enough - do nothing.
	   Specfically Perl_newCONSTSUB is relying on this.  */
    } else {
#ifdef DEBUGGING
	/* Force a move to shake out bugs in callers.  */
	char *new_ptr = (char*)safemalloc(allocate);
	Copy(ptr, new_ptr, len, char);
	PoisonFree(ptr,len,char);
	Safefree(ptr);
	ptr = new_ptr;
#else
	ptr = (char*) saferealloc (ptr, allocate);
#endif
    }
d4279 1
a4279 3
    if (!(flags & SV_HAS_TRAILING_NUL)) {
	ptr[len] = '\0';
    }
a4281 2
    if (flags & SV_SMAGIC)
	SvSETMAGIC(sv);
d4284 10
a4293 8
#ifdef PERL_OLD_COPY_ON_WRITE
/* Need to do this *after* making the SV normal, as we need the buffer
   pointer to remain valid until after we've copied it.  If we let go too early,
   another thread could invalidate it by unsharing last of the same hash key
   (which it can do by means other than releasing copy-on-write Svs)
   or by changing the other copy-on-write SVs in the loop.  */
STATIC void
S_sv_release_COW(pTHX_ register SV *sv, const char *pvx, SV *after)
d4295 2
a4296 25
    { /* this SV was SvIsCOW_normal(sv) */
         /* we need to find the SV pointing to us.  */
        SV *current = SV_COW_NEXT_SV(after);

        if (current == sv) {
            /* The SV we point to points back to us (there were only two of us
               in the loop.)
               Hence other SV is no longer copy on write either.  */
            SvFAKE_off(after);
            SvREADONLY_off(after);
        } else {
            /* We need to follow the pointers around the loop.  */
            SV *next;
            while ((next = SV_COW_NEXT_SV(current)) != sv) {
                assert (next);
                current = next;
                 /* don't loop forever if the structure is bust, and we have
                    a pointer into a closed loop.  */
                assert (current != after);
                assert (SvPVX_const(current) == pvx);
            }
            /* Make the SV before us point to the SV after us.  */
            SV_COW_NEXT_SV_SET(current, after);
        }
    }
d4298 1
a4298 1
#endif
d4304 2
a4305 7
an xpvmg; if we're a copy-on-write scalar, this is the on-write time when
we do the copy, and is also used locally. If C<SV_COW_DROP_PV> is set
then a copy-on-write scalar drops its PV buffer (if any) and becomes
SvPOK_off rather than making a copy. (Used where this scalar is about to be
set to some other value.) In addition, the C<flags> parameter gets passed to
C<sv_unref_flags()> when unrefing. C<sv_force_normal> calls this function
with flags set to 0.
a4312 47
    dVAR;
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvREADONLY(sv)) {
        /* At this point I believe I should acquire a global SV mutex.  */
	if (SvFAKE(sv)) {
	    const char * const pvx = SvPVX_const(sv);
	    const STRLEN len = SvLEN(sv);
	    const STRLEN cur = SvCUR(sv);
	    /* next COW sv in the loop.  If len is 0 then this is a shared-hash
	       key scalar, so we mustn't attempt to call SV_COW_NEXT_SV(), as
	       we'll fail an assertion.  */
	    SV * const next = len ? SV_COW_NEXT_SV(sv) : 0;

            if (DEBUG_C_TEST) {
                PerlIO_printf(Perl_debug_log,
                              "Copy on write: Force normal %ld\n",
                              (long) flags);
                sv_dump(sv);
            }
            SvFAKE_off(sv);
            SvREADONLY_off(sv);
            /* This SV doesn't own the buffer, so need to Newx() a new one:  */
            SvPV_set(sv, NULL);
            SvLEN_set(sv, 0);
            if (flags & SV_COW_DROP_PV) {
                /* OK, so we don't need to copy our buffer.  */
                SvPOK_off(sv);
            } else {
                SvGROW(sv, cur + 1);
                Move(pvx,SvPVX(sv),cur,char);
                SvCUR_set(sv, cur);
                *SvEND(sv) = '\0';
            }
	    if (len) {
		sv_release_COW(sv, pvx, next);
	    } else {
		unshare_hek(SvSHARED_HEK_FROM_PV(pvx));
	    }
            if (DEBUG_C_TEST) {
                sv_dump(sv);
            }
	}
	else if (IN_PERL_RUNTIME)
	    Perl_croak(aTHX_ PL_no_modify);
        /* At this point I believe that I can drop the global SV mutex.  */
    }
#else
d4317 1
a4319 2
	    SvPV_set(sv, NULL);
	    SvLEN_set(sv, 0);
d4323 1
a4323 1
	    unshare_hek(SvSHARED_HEK_FROM_PV(pvx));
a4327 1
#endif
d4335 16
d4364 1
a4364 1
Perl_sv_chop(pTHX_ register SV *sv, register const char *ptr)
d4386 1
a4386 1
	SvFLAGS(sv) |= SVf_OOK;
d4395 10
a4427 1
    dVAR;
d4429 1
a4429 1
    const char * const dstr = SvPV_force_flags(dsv, dlen, flags);
d4439 25
a4463 2
    if (flags & SV_SMAGIC)
	SvSETMAGIC(dsv);
d4485 10
a4494 10
    dVAR;
    if (ssv) {
	STRLEN slen;
	const char *spv = SvPV_const(ssv, slen);
	if (spv) {
	    /*  sutf8 and dutf8 were type bool, but under USE_ITHREADS,
		gcc version 2.95.2 20000220 (Debian GNU/Linux) for
		Linux xxx 2.2.17 on sparc64 with gcc -O2, we erroneously
		get dutf8 = 0x20000000, (i.e.  SVf_UTF8) even though
		dsv->sv_flags doesn't have that bit set.
d4496 3
a4498 3
	    */
	    const I32 sutf8 = DO_UTF8(ssv);
	    I32 dutf8;
d4500 8
a4507 8
	    if (SvGMAGICAL(dsv) && (flags & SV_GMAGIC))
		mg_get(dsv);
	    dutf8 = DO_UTF8(dsv);

	    if (dutf8 != sutf8) {
		if (dutf8) {
		    /* Not modifying source SV, so taking a temporary copy. */
		    SV* const csv = sv_2mortal(newSVpvn(spv, slen));
d4509 2
a4510 5
		    sv_utf8_upgrade(csv);
		    spv = SvPV_const(csv, slen);
		}
		else
		    sv_utf8_upgrade_nomg(dsv);
d4512 20
a4531 5
	    sv_catpvn_nomg(dsv, spv, slen);
	}
    }
    if (flags & SV_SMAGIC)
	SvSETMAGIC(dsv);
a4545 1
    dVAR;
d4581 3
a4583 10
Creates a new SV.  A non-zero C<len> parameter indicates the number of
bytes of preallocated string space the SV should have.  An extra byte for a
trailing NUL is also reserved.  (SvPOK is not set for the SV even if string
space is allocated.)  The reference count for the new SV is set to 1.

In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first
parameter, I<x>, a debug aid which allowed callers to identify themselves.
This aid has been superseded by a new build option, PERL_MEM_LOG (see
L<perlhack/PERL_MEM_LOG>).  The older API is still there for use in XS
modules supporting older perls.
a4590 1
    dVAR;
d4620 1
a4620 1
Perl_sv_magicext(pTHX_ SV* sv, SV* obj, int how, const MGVTBL *vtable,
a4622 1
    dVAR;
d4625 3
a4627 1
    SvUPGRADE(sv, SVt_PVMG);
a4643 1
	how == PERL_MAGIC_symtab ||
d4652 1
a4652 1
	mg->mg_obj = SvREFCNT_inc_simple(obj);
d4676 1
a4676 1
	    mg->mg_ptr = (char*)SvREFCNT_inc_simple_NN((SV*)name);
d4680 1
a4680 1
    mg->mg_virtual = (MGVTBL *) vtable;
a4705 1
    dVAR;
a4708 4
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv))
        sv_force_normal_flags(sv, 0);
#endif
d4731 1
a4731 1
	    if (how == PERL_MAGIC_taint) {
a4732 5
		/* Any scalar which already had taint magic on which someone
		   (erroneously?) did SvIOK_on() or similar will now be
		   incorrectly sporting public "OK" flags.  */
		SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
	    }
d4786 5
a4805 2
    case PERL_MAGIC_hints:
	/* As this vtable is all NULL, we can reuse it.  */
a4820 3
    case PERL_MAGIC_arylen_p:
    case PERL_MAGIC_rhash:
    case PERL_MAGIC_symtab:
d4825 2
a4826 2
	vtable = &PL_vtbl_utf8;
	break;
d4833 3
a4844 3
    case PERL_MAGIC_hintselem:
	vtable = &PL_vtbl_hintselem;
	break;
d4857 1
a4857 1
    mg = sv_magicext(sv,obj,how,vtable,name,namlen);
d4885 1
a4885 1
    mgp = &(((XPVMG*) SvANY(sv))->xmg_u.xmg_magic);
d4897 1
a4897 1
		else if (mg->mg_type == PERL_MAGIC_utf8)
d4909 1
a4909 2
	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
	SvMAGIC_set(sv, NULL);
d4921 1
a4921 2
associated with that magic. If the RV is magical, set magic will be
called after the RV is cleared.
d4940 1
a4940 1
    Perl_sv_add_backref(aTHX_ tsv, sv);
d4950 2
a4951 2
void
Perl_sv_add_backref(pTHX_ SV *tsv, SV *sv)
a4952 1
    dVAR;
d4954 9
a4962 38

    if (SvTYPE(tsv) == SVt_PVHV) {
	AV **const avp = Perl_hv_backreferences_p(aTHX_ (HV*)tsv);

	av = *avp;
	if (!av) {
	    /* There is no AV in the offical place - try a fixup.  */
	    MAGIC *const mg = mg_find(tsv, PERL_MAGIC_backref);

	    if (mg) {
		/* Aha. They've got it stowed in magic.  Bring it back.  */
		av = (AV*)mg->mg_obj;
		/* Stop mg_free decreasing the refernce count.  */
		mg->mg_obj = NULL;
		/* Stop mg_free even calling the destructor, given that
		   there's no AV to free up.  */
		mg->mg_virtual = 0;
		sv_unmagic(tsv, PERL_MAGIC_backref);
	    } else {
		av = newAV();
		AvREAL_off(av);
		SvREFCNT_inc_simple_void(av);
	    }
	    *avp = av;
	}
    } else {
	const MAGIC *const mg
	    = SvMAGICAL(tsv) ? mg_find(tsv, PERL_MAGIC_backref) : NULL;
	if (mg)
	    av = (AV*)mg->mg_obj;
	else {
	    av = newAV();
	    AvREAL_off(av);
	    sv_magic(tsv, (SV*)av, PERL_MAGIC_backref, NULL, 0);
	    /* av now has a refcnt of 2, which avoids it getting freed
	     * before us during global cleanup. The extra ref is removed
	     * by magic_killbackrefs() when tsv is being freed */
	}
d4975 1
a4975 1
S_sv_del_backref(pTHX_ SV *tsv, SV *sv)
d4977 1
a4977 2
    dVAR;
    AV *av = NULL;
d4980 3
a4982 17

    if (SvTYPE(tsv) == SVt_PVHV && SvOOK(tsv)) {
	av = *Perl_hv_backreferences_p(aTHX_ (HV*)tsv);
	/* We mustn't attempt to "fix up" the hash here by moving the
	   backreference array back to the hv_aux structure, as that is stored
	   in the main HvARRAY(), and hfreentries assumes that no-one
	   reallocates HvARRAY() while it is running.  */
    }
    if (!av) {
	const MAGIC *const mg
	    = SvMAGICAL(tsv) ? mg_find(tsv, PERL_MAGIC_backref) : NULL;
	if (mg)
	    av = (AV *)mg->mg_obj;
    }
    if (!av) {
	if (PL_in_clean_all)
	    return;
d4984 1
a4984 5
    }

    if (SvIS_FREED(av))
	return;

d4999 1
a4999 1
	    svp[fill] = NULL;
a5004 42
int
Perl_sv_kill_backrefs(pTHX_ SV *sv, AV *av)
{
    SV **svp = AvARRAY(av);

    PERL_UNUSED_ARG(sv);

    /* Not sure why the av can get freed ahead of its sv, but somehow it does
       in ext/B/t/bytecode.t test 15 (involving print <DATA>)  */
    if (svp && !SvIS_FREED(av)) {
	SV *const *const last = svp + AvFILLp(av);

	while (svp <= last) {
	    if (*svp) {
		SV *const referrer = *svp;
		if (SvWEAKREF(referrer)) {
		    /* XXX Should we check that it hasn't changed? */
		    SvRV_set(referrer, 0);
		    SvOK_off(referrer);
		    SvWEAKREF_off(referrer);
		    SvSETMAGIC(referrer);
		} else if (SvTYPE(referrer) == SVt_PVGV ||
			   SvTYPE(referrer) == SVt_PVLV) {
		    /* You lookin' at me?  */
		    assert(GvSTASH(referrer));
		    assert(GvSTASH(referrer) == (HV*)sv);
		    GvSTASH(referrer) = 0;
		} else {
		    Perl_croak(aTHX_
			       "panic: magic_killbackrefs (flags=%"UVxf")",
			       (UV)SvFLAGS(referrer));
		}

		*svp = NULL;
	    }
	    svp++;
	}
    }
    SvREFCNT_dec(av); /* remove extra count added by sv_add_backref() */
    return 0;
}

d5015 1
a5015 1
Perl_sv_insert(pTHX_ SV *bigstr, STRLEN offset, STRLEN len, const char *little, STRLEN littlelen)
a5016 1
    dVAR;
a5113 1
    dVAR;
d5115 3
a5117 5
    SV_CHECK_THINKFIRST_COW_DROP(sv);
    if (SvREFCNT(nsv) != 1) {
	Perl_croak(aTHX_ "panic: reference miscount on nsv in sv_replace() (%"
		   UVuf " != 1)", (UV) SvREFCNT(nsv));
    }
a5130 6
#ifdef DEBUG_LEAKING_SCALARS
    sv->sv_flags  = nsv->sv_flags;
    sv->sv_any    = nsv->sv_any;
    sv->sv_refcnt = nsv->sv_refcnt;
    sv->sv_u      = nsv->sv_u;
#else
a5131 33
#endif
    /* Currently could join these into one piece of pointer arithmetic, but
       it would be unclear.  */
    if(SvTYPE(sv) == SVt_IV)
	SvANY(sv)
	    = (XPVIV*)((char*)&(sv->sv_u.svu_iv) - STRUCT_OFFSET(XPVIV, xiv_iv));
    else if (SvTYPE(sv) == SVt_RV) {
	SvANY(sv) = &sv->sv_u.svu_rv;
    }
	

#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW_normal(nsv)) {
	/* We need to follow the pointers around the loop to make the
	   previous SV point to sv, rather than nsv.  */
	SV *next;
	SV *current = nsv;
	while ((next = SV_COW_NEXT_SV(current)) != nsv) {
	    assert(next);
	    current = next;
	    assert(SvPVX_const(current) == SvPVX_const(nsv));
	}
	/* Make the SV before us point to the SV after us.  */
	if (DEBUG_C_TEST) {
	    PerlIO_printf(Perl_debug_log, "previous is\n");
	    sv_dump(current);
	    PerlIO_printf(Perl_debug_log,
                          "move it from 0x%"UVxf" to 0x%"UVxf"\n",
			  (UV) SV_COW_NEXT_SV(current), (UV) sv);
	}
	SV_COW_NEXT_SV_SET(current, sv);
    }
#endif
d5155 1
a5155 6
    dVAR;
    const U32 type = SvTYPE(sv);
    const struct body_details *const sv_type_details
	= bodies_by_type + type;
    HV *stash;

a5158 7
    if (type <= SVt_IV) {
	/* See the comment in sv.h about the collusion between this early
	   return and the overloading of the NULL and IV slots in the size
	   table.  */
	return;
    }

d5160 1
a5160 3
	if (PL_defstash &&	/* Still have a symbol table? */
	    SvDESTROYABLE(sv))
	{
a5161 1
	    HV* stash;
d5176 2
a5177 2
		
		
d5204 1
a5204 1
	    if (type != SVt_PVIO)
d5208 2
a5209 4
    if (type >= SVt_PVMG) {
	if (type == SVt_PVMG && SvPAD_OUR(sv)) {
	    SvREFCNT_dec(SvOURSTASH(sv));
	} else if (SvMAGIC(sv))
d5211 1
a5211 1
	if (type == SVt_PVMG && SvPAD_TYPED(sv))
d5214 2
a5215 2
    switch (type) {
	/* case SVt_BIND: */
d5230 2
a5237 1
	Perl_hv_kill_backrefs(aTHX_ (HV*)sv);
a5240 4
	if (PL_comppad == (AV*)sv) {
	    PL_comppad = NULL;
	    PL_curpad = NULL;
	}
d5251 1
d5253 8
a5260 16
	if (isGV_with_GP(sv)) {
            if(GvCVu((GV*)sv) && (stash = GvSTASH((GV*)sv)) && HvNAME_get(stash))
                mro_method_changed_in(stash);
	    gp_free((GV*)sv);
	    if (GvNAME_HEK(sv))
		unshare_hek(GvNAME_HEK(sv));
	    /* If we're in a stash, we don't own a reference to it. However it does
	       have a back reference to us, which needs to be cleared.  */
	    if (!SvVALID(sv) && (stash = GvSTASH(sv)))
		    sv_del_backref((SV*)stash, sv);
	}
	/* FIXME. There are probably more unreferenced pointers to SVs in the
	   interpreter struct that we should check and tidy in a similar
	   fashion to this:  */
	if ((GV*)sv == PL_last_in_gv)
	    PL_last_in_gv = NULL;
d5270 1
a5273 1
	    SV * const target = SvRV(sv);
d5275 1
a5275 1
	        sv_del_backref(target, sv);
d5277 1
a5277 1
	        SvREFCNT_dec(target);
a5278 22
#ifdef PERL_OLD_COPY_ON_WRITE
	else if (SvPVX_const(sv)) {
            if (SvIsCOW(sv)) {
                /* I believe I need to grab the global SV mutex here and
                   then recheck the COW status.  */
                if (DEBUG_C_TEST) {
                    PerlIO_printf(Perl_debug_log, "Copy on write: clear\n");
                    sv_dump(sv);
                }
		if (SvLEN(sv)) {
		    sv_release_COW(sv, SvPVX_const(sv), SV_COW_NEXT_SV(sv));
		} else {
		    unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
		}

                /* And drop it here.  */
                SvFAKE_off(sv);
            } else if (SvLEN(sv)) {
                Safefree(SvPVX_const(sv));
            }
	}
#else
d5282 3
a5284 1
	    unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
a5286 1
#endif
d5288 1
d5290 2
d5293 1
d5296 55
a5352 8

    if (sv_type_details->arena) {
	del_body(((char *)SvANY(sv) + sv_type_details->offset),
		 &PL_body_roots[type]);
    }
    else if (sv_type_details->body_size) {
	my_safefree(SvANY(sv));
    }
a5366 1
    PERL_UNUSED_CONTEXT;
d5368 1
a5368 1
	(SvREFCNT(sv))++;
d5386 2
a5387 1
    dVAR;
a5407 4
#else
  #ifdef DEBUG_LEAKING_SCALARS
	sv_dump(sv);
  #endif
d5412 2
a5413 1
    if (--(SvREFCNT(sv)) > 0)
a5414 7
    Perl_sv_free2(aTHX_ sv);
}

void
Perl_sv_free2(pTHX_ SV *sv)
{
    dVAR;
d5469 2
a5470 4
 * mg_ptr is used, by sv_pos_u2b() and sv_pos_b2u() - see the comments below.
 * (Note that the mg_len is not the length of the mg_ptr field.
 * This allows the cache to store the character length of the string without
 * needing to malloc() extra storage to attach to the mg_ptr.)
d5484 1
a5484 1
	STRLEN len;
d5486 1
d5488 15
a5502 32
	if (PL_utf8cache) {
	    STRLEN ulen;
	    MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;

	    if (mg && mg->mg_len != -1) {
		ulen = mg->mg_len;
		if (PL_utf8cache < 0) {
		    const STRLEN real = Perl_utf8_length(aTHX_ s, s + len);
		    if (real != ulen) {
			/* Need to turn the assertions off otherwise we may
			   recurse infinitely while printing error messages.
			*/
			SAVEI8(PL_utf8cache);
			PL_utf8cache = 0;
			Perl_croak(aTHX_ "panic: sv_len_utf8 cache %"UVuf
				   " real %"UVuf" for %"SVf,
				   (UV) ulen, (UV) real, SVfARG(sv));
		    }
		}
	    }
	    else {
		ulen = Perl_utf8_length(aTHX_ s, s + len);
		if (!SvREADONLY(sv)) {
		    if (!mg) {
			mg = sv_magicext(sv, 0, PERL_MAGIC_utf8,
					 &PL_vtbl_utf8, 0, 0);
		    }
		    assert(mg);
		    mg->mg_len = ulen;
		}
	    }
	    return ulen;
d5504 1
a5504 1
	return Perl_utf8_length(aTHX_ s, s + len);
d5508 13
a5520 5
/* Walk forwards to find the byte corresponding to the passed in UTF-8
   offset.  */
static STRLEN
S_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send,
		      STRLEN uoffset)
d5522 6
a5527 1
    const U8 *s = start;
d5529 7
a5535 9
    while (s < send && uoffset--)
	s += UTF8SKIP(s);
    if (s > send) {
	/* This is the existing behaviour. Possibly it should be a croak, as
	   it's actually a bounds error  */
	s = send;
    }
    return s - start;
}
d5537 3
a5539 13
/* Given the length of the string in both bytes and UTF-8 characters, decide
   whether to walk forwards or backwards to find the byte corresponding to
   the passed in UTF-8 offset.  */
static STRLEN
S_sv_pos_u2b_midway(const U8 *const start, const U8 *send,
		      STRLEN uoffset, STRLEN uend)
{
    STRLEN backw = uend - uoffset;
    if (uoffset < 2 * backw) {
	/* The assumption is that going forwards is twice the speed of going
	   forward (that's where the 2 * backw comes from).
	   (The real figure of course depends on the UTF-8 data.)  */
	return sv_pos_u2b_forwards(start, send, uoffset);
d5542 1
a5542 6
    while (backw--) {
	send--;
	while (UTF8_IS_CONTINUATION(*send))
	    send--;
    }
    return send - start;
d5545 10
a5554 13
/* For the string representation of the given scalar, find the byte
   corresponding to the passed in UTF-8 offset.  uoffset0 and boffset0
   give another position in the string, *before* the sought offset, which
   (which is always true, as 0, 0 is a valid pair of positions), which should
   help reduce the amount of linear searching.
   If *mgp is non-NULL, it should point to the UTF-8 cache magic, which
   will be used to reduce the amount of linear searching. The cache will be
   created if necessary, and the found value offered to it for update.  */
static STRLEN
S_sv_pos_u2b_cached(pTHX_ SV *sv, MAGIC **mgp, const U8 *const start,
		    const U8 *const send, STRLEN uoffset,
		    STRLEN uoffset0, STRLEN boffset0) {
    STRLEN boffset = 0; /* Actually always set, but let's keep gcc happy.  */
d5557 84
a5640 65
    assert (uoffset >= uoffset0);

    if (SvMAGICAL(sv) && !SvREADONLY(sv) && PL_utf8cache
	&& (*mgp || (*mgp = mg_find(sv, PERL_MAGIC_utf8)))) {
	if ((*mgp)->mg_ptr) {
	    STRLEN *cache = (STRLEN *) (*mgp)->mg_ptr;
	    if (cache[0] == uoffset) {
		/* An exact match. */
		return cache[1];
	    }
	    if (cache[2] == uoffset) {
		/* An exact match. */
		return cache[3];
	    }

	    if (cache[0] < uoffset) {
		/* The cache already knows part of the way.   */
		if (cache[0] > uoffset0) {
		    /* The cache knows more than the passed in pair  */
		    uoffset0 = cache[0];
		    boffset0 = cache[1];
		}
		if ((*mgp)->mg_len != -1) {
		    /* And we know the end too.  */
		    boffset = boffset0
			+ sv_pos_u2b_midway(start + boffset0, send,
					      uoffset - uoffset0,
					      (*mgp)->mg_len - uoffset0);
		} else {
		    boffset = boffset0
			+ sv_pos_u2b_forwards(start + boffset0,
						send, uoffset - uoffset0);
		}
	    }
	    else if (cache[2] < uoffset) {
		/* We're between the two cache entries.  */
		if (cache[2] > uoffset0) {
		    /* and the cache knows more than the passed in pair  */
		    uoffset0 = cache[2];
		    boffset0 = cache[3];
		}

		boffset = boffset0
		    + sv_pos_u2b_midway(start + boffset0,
					  start + cache[1],
					  uoffset - uoffset0,
					  cache[0] - uoffset0);
	    } else {
		boffset = boffset0
		    + sv_pos_u2b_midway(start + boffset0,
					  start + cache[3],
					  uoffset - uoffset0,
					  cache[2] - uoffset0);
	    }
	    found = TRUE;
	}
	else if ((*mgp)->mg_len != -1) {
	    /* If we can take advantage of a passed in offset, do so.  */
	    /* In fact, offset0 is either 0, or less than offset, so don't
	       need to worry about the other possibility.  */
	    boffset = boffset0
		+ sv_pos_u2b_midway(start + boffset0, send,
				      uoffset - uoffset0,
				      (*mgp)->mg_len - uoffset0);
	    found = TRUE;
d5642 14
a5655 17
    }

    if (!found || PL_utf8cache < 0) {
	const STRLEN real_boffset
	    = boffset0 + sv_pos_u2b_forwards(start + boffset0,
					       send, uoffset - uoffset0);

	if (found && PL_utf8cache < 0) {
	    if (real_boffset != boffset) {
		/* Need to turn the assertions off otherwise we may recurse
		   infinitely while printing error messages.  */
		SAVEI8(PL_utf8cache);
		PL_utf8cache = 0;
		Perl_croak(aTHX_ "panic: sv_pos_u2b_cache cache %"UVuf
			   " real %"UVuf" for %"SVf,
			   (UV) boffset, (UV) real_boffset, SVfARG(sv));
	    }
d5657 1
a5657 1
	boffset = real_boffset;
d5660 1
a5660 2
    S_utf8_mg_pos_cache_update(aTHX_ sv, mgp, boffset, uoffset, send - start);
    return boffset;
a5662 1

d5678 1
a5678 1
 * byte offsets.  See also the comments of S_utf8_mg_pos_cache_update().
d5693 38
a5730 17
	STRLEN uoffset = (STRLEN) *offsetp;
	const U8 * const send = start + len;
	MAGIC *mg = NULL;
	const STRLEN boffset = sv_pos_u2b_cached(sv, &mg, start, send,
					     uoffset, 0, 0);

	*offsetp = (I32) boffset;

	if (lenp) {
	    /* Convert the relative offset to absolute.  */
	    const STRLEN uoffset2 = uoffset + (STRLEN) *lenp;
	    const STRLEN boffset2
		= sv_pos_u2b_cached(sv, &mg, start, send, uoffset2,
				      uoffset, boffset) - boffset;

	    *lenp = boffset2;
	}
a5740 181
/* Create and update the UTF8 magic offset cache, with the proffered utf8/
   byte length pairing. The (byte) length of the total SV is passed in too,
   as blen, because for some (more esoteric) SVs, the call to SvPV_const()
   may not have updated SvCUR, so we can't rely on reading it directly.

   The proffered utf8/byte length pairing isn't used if the cache already has
   two pairs, and swapping either for the proffered pair would increase the
   RMS of the intervals between known byte offsets.

   The cache itself consists of 4 STRLEN values
   0: larger UTF-8 offset
   1: corresponding byte offset
   2: smaller UTF-8 offset
   3: corresponding byte offset

   Unused cache pairs have the value 0, 0.
   Keeping the cache "backwards" means that the invariant of
   cache[0] >= cache[2] is maintained even with empty slots, which means that
   the code that uses it doesn't need to worry if only 1 entry has actually
   been set to non-zero.  It also makes the "position beyond the end of the
   cache" logic much simpler, as the first slot is always the one to start
   from.   
*/
static void
S_utf8_mg_pos_cache_update(pTHX_ SV *sv, MAGIC **mgp, STRLEN byte, STRLEN utf8,
			   STRLEN blen)
{
    STRLEN *cache;
    if (SvREADONLY(sv))
	return;

    if (!*mgp) {
	*mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, (MGVTBL*)&PL_vtbl_utf8, 0,
			   0);
	(*mgp)->mg_len = -1;
    }
    assert(*mgp);

    if (!(cache = (STRLEN *)(*mgp)->mg_ptr)) {
	Newxz(cache, PERL_MAGIC_UTF8_CACHESIZE * 2, STRLEN);
	(*mgp)->mg_ptr = (char *) cache;
    }
    assert(cache);

    if (PL_utf8cache < 0) {
	const U8 *start = (const U8 *) SvPVX_const(sv);
	const STRLEN realutf8 = utf8_length(start, start + byte);

	if (realutf8 != utf8) {
	    /* Need to turn the assertions off otherwise we may recurse
	       infinitely while printing error messages.  */
	    SAVEI8(PL_utf8cache);
	    PL_utf8cache = 0;
	    Perl_croak(aTHX_ "panic: utf8_mg_pos_cache_update cache %"UVuf
		       " real %"UVuf" for %"SVf, (UV) utf8, (UV) realutf8, SVfARG(sv));
	}
    }

    /* Cache is held with the later position first, to simplify the code
       that deals with unbounded ends.  */
       
    ASSERT_UTF8_CACHE(cache);
    if (cache[1] == 0) {
	/* Cache is totally empty  */
	cache[0] = utf8;
	cache[1] = byte;
    } else if (cache[3] == 0) {
	if (byte > cache[1]) {
	    /* New one is larger, so goes first.  */
	    cache[2] = cache[0];
	    cache[3] = cache[1];
	    cache[0] = utf8;
	    cache[1] = byte;
	} else {
	    cache[2] = utf8;
	    cache[3] = byte;
	}
    } else {
#define THREEWAY_SQUARE(a,b,c,d) \
	    ((float)((d) - (c))) * ((float)((d) - (c))) \
	    + ((float)((c) - (b))) * ((float)((c) - (b))) \
	       + ((float)((b) - (a))) * ((float)((b) - (a)))

	/* Cache has 2 slots in use, and we know three potential pairs.
	   Keep the two that give the lowest RMS distance. Do the
	   calcualation in bytes simply because we always know the byte
	   length.  squareroot has the same ordering as the positive value,
	   so don't bother with the actual square root.  */
	const float existing = THREEWAY_SQUARE(0, cache[3], cache[1], blen);
	if (byte > cache[1]) {
	    /* New position is after the existing pair of pairs.  */
	    const float keep_earlier
		= THREEWAY_SQUARE(0, cache[3], byte, blen);
	    const float keep_later
		= THREEWAY_SQUARE(0, cache[1], byte, blen);

	    if (keep_later < keep_earlier) {
		if (keep_later < existing) {
		    cache[2] = cache[0];
		    cache[3] = cache[1];
		    cache[0] = utf8;
		    cache[1] = byte;
		}
	    }
	    else {
		if (keep_earlier < existing) {
		    cache[0] = utf8;
		    cache[1] = byte;
		}
	    }
	}
	else if (byte > cache[3]) {
	    /* New position is between the existing pair of pairs.  */
	    const float keep_earlier
		= THREEWAY_SQUARE(0, cache[3], byte, blen);
	    const float keep_later
		= THREEWAY_SQUARE(0, byte, cache[1], blen);

	    if (keep_later < keep_earlier) {
		if (keep_later < existing) {
		    cache[2] = utf8;
		    cache[3] = byte;
		}
	    }
	    else {
		if (keep_earlier < existing) {
		    cache[0] = utf8;
		    cache[1] = byte;
		}
	    }
	}
	else {
 	    /* New position is before the existing pair of pairs.  */
	    const float keep_earlier
		= THREEWAY_SQUARE(0, byte, cache[3], blen);
	    const float keep_later
		= THREEWAY_SQUARE(0, byte, cache[1], blen);

	    if (keep_later < keep_earlier) {
		if (keep_later < existing) {
		    cache[2] = utf8;
		    cache[3] = byte;
		}
	    }
	    else {
		if (keep_earlier < existing) {
		    cache[0] = cache[2];
		    cache[1] = cache[3];
		    cache[2] = utf8;
		    cache[3] = byte;
		}
	    }
	}
    }
    ASSERT_UTF8_CACHE(cache);
}

/* We already know all of the way, now we may be able to walk back.  The same
   assumption is made as in S_sv_pos_u2b_midway(), namely that walking
   backward is half the speed of walking forward. */
static STRLEN
S_sv_pos_b2u_midway(pTHX_ const U8 *s, const U8 *const target, const U8 *end,
		    STRLEN endu)
{
    const STRLEN forw = target - s;
    STRLEN backw = end - target;

    if (forw < 2 * backw) {
	return utf8_length(s, target);
    }

    while (end > target) {
	end--;
	while (UTF8_IS_CONTINUATION(*end)) {
	    end--;
	}
	endu--;
    }
    return endu;
}

d5754 1
a5754 1
 * byte offsets.
d5757 1
d5762 1
a5762 6
    const STRLEN byte = *offsetp;
    STRLEN len = 0; /* Actually always set, but let's keep gcc happy.  */
    STRLEN blen;
    MAGIC* mg = NULL;
    const U8* send;
    bool found = FALSE;
d5767 17
a5783 1
    s = (const U8*)SvPV_const(sv, blen);
d5785 31
a5815 2
    if (blen < byte)
	Perl_croak(aTHX_ "panic: sv_pos_b2u: bad byte offset");
d5817 2
a5818 1
    send = s + byte;
d5820 3
a5822 14
    if (SvMAGICAL(sv) && !SvREADONLY(sv) && PL_utf8cache
	&& (mg = mg_find(sv, PERL_MAGIC_utf8))) {
	if (mg->mg_ptr) {
	    STRLEN * const cache = (STRLEN *) mg->mg_ptr;
	    if (cache[1] == byte) {
		/* An exact match. */
		*offsetp = cache[0];
		return;
	    }
	    if (cache[3] == byte) {
		/* An exact match. */
		*offsetp = cache[2];
		return;
	    }
d5824 2
a5825 9
	    if (cache[1] < byte) {
		/* We already know part of the way. */
		if (mg->mg_len != -1) {
		    /* Actually, we know the end too.  */
		    len = cache[0]
			+ S_sv_pos_b2u_midway(aTHX_ s + cache[1], send,
					      s + blen, mg->mg_len - cache[0]);
		} else {
		    len = cache[0] + utf8_length(s + cache[1], send);
d5828 5
a5832 13
	    else if (cache[3] < byte) {
		/* We're between the two cached pairs, so we do the calculation
		   offset by the byte/utf-8 positions for the earlier pair,
		   then add the utf-8 characters from the string start to
		   there.  */
		len = S_sv_pos_b2u_midway(aTHX_ s + cache[3], send,
					  s + cache[1], cache[0] - cache[2])
		    + cache[2];

	    }
	    else { /* cache[3] > byte */
		len = S_sv_pos_b2u_midway(aTHX_ s, send, s + cache[3],
					  cache[2]);
d5834 7
d5842 2
a5843 5
	    ASSERT_UTF8_CACHE(cache);
	    found = TRUE;
	} else if (mg->mg_len != -1) {
	    len = S_sv_pos_b2u_midway(aTHX_ s, send, s + blen, mg->mg_len);
	    found = TRUE;
a5844 3
    }
    if (!found || PL_utf8cache < 0) {
	const STRLEN real_len = utf8_length(s, send);
d5846 10
a5855 9
	if (found && PL_utf8cache < 0) {
	    if (len != real_len) {
		/* Need to turn the assertions off otherwise we may recurse
		   infinitely while printing error messages.  */
		SAVEI8(PL_utf8cache);
		PL_utf8cache = 0;
		Perl_croak(aTHX_ "panic: sv_pos_b2u cache %"UVuf
			   " real %"UVuf" for %"SVf,
			   (UV) len, (UV) real_len, SVfARG(sv));
d5857 7
d5865 2
a5866 1
	len = real_len;
a5867 1
    *offsetp = len;
d5869 1
a5869 1
    S_utf8_mg_pos_cache_update(aTHX_ sv, &mg, byte, len, blen);
a5884 1
    dVAR;
d5890 2
a5891 2
    char *tpv   = NULL;
    SV* svrecode = NULL;
d5897 1
a5897 8
    else {
	/* if pv1 and pv2 are the same, second SvPV_const call may
	 * invalidate pv1, so we may need to make a copy */
	if (sv1 == sv2 && (SvTHINKFIRST(sv1) || SvGMAGICAL(sv1))) {
	    pv1 = SvPV_const(sv1, cur1);
	    sv1 = sv_2mortal(newSVpvn(pv1, cur1));
	    if (SvUTF8(sv2)) SvUTF8_on(sv1);
	}
a5898 1
    }
d5933 1
a5933 1
		   char * const pv = (char*)bytes_from_utf8((const U8*)pv1,
d5941 1
a5941 1
		   char * const pv = (char *)bytes_from_utf8((const U8*)pv2,
a5947 1
		   assert (tpv == 0);
d5954 1
a5954 1
	eq = (pv1 == pv2) || memEQ(pv1, pv2, cur1);
d5956 3
a5958 1
    SvREFCNT_dec(svrecode);
a5978 1
    dVAR;
d5981 1
a5981 1
    char *tpv = NULL;
d5983 1
a5983 1
    SV *svrecode = NULL;
d6009 1
a6009 1
		 pv2 = tpv = (char*)bytes_to_utf8((const U8*)pv2, &cur2);
d6019 1
a6019 1
		 pv1 = tpv = (char*)bytes_to_utf8((const U8*)pv1, &cur1);
d6040 3
a6042 1
    SvREFCNT_dec(svrecode);
a6061 1
    dVAR;
d6100 1
a6100 1
    /*FALLTHROUGH*/
a6125 1
    dVAR;
d6144 2
a6145 6
#ifdef PERL_OLD_COPY_ON_WRITE
		if (SvIsCOW(sv))
		    sv_force_normal_flags(sv, 0);
#endif
		mg = sv_magicext(sv, 0, PERL_MAGIC_collxfrm, &PL_vtbl_collxfrm,
				 0, 0);
a6181 1
    dVAR;
d6189 1
d6198 1
a6198 1
    SvUPGRADE(sv, SVt_PV);
d6209 1
a6209 1
	    SV * const tsv = newSV(0);
d6229 4
a6232 4
    	/* If it is a regular disk file use size from stat() as estimate
	   of amount we are going to read -- may result in mallocing
	   more memory than we really need if the layers below reduce
	   the size we read (e.g. CRLF or a gzip layer).
a6246 1
      U32 recsize;
d6249 1
a6249 1
      recsize = SvUV(SvRV(PL_rs)); /* RsRECORD() guarantees > 0. */
d6336 1
a6336 1
    if ((I32)(SvLEN(sv) - append) <= cnt + 1) {
d6338 1
a6338 1
	   if we are looking for a separator and room for some
d6341 1
a6341 1
	    /* just process what we have room for */
d6351 1
a6351 1
    else
d6452 1
a6452 1
	STDCHAR *buf = NULL;
d6461 1
a6461 1
            register const STDCHAR * const bpe = buf + sizeof(buf);
d6502 1
a6502 1
	    if (!(cnt < (I32)sizeof(buf) && PerlIO_eof(fp)))
d6522 1
a6522 1
    return (SvCUR(sv) - append) ? SvPVX(sv) : NULL;
a6536 1
    dVAR;
d6542 2
a6543 1
    SvGETMAGIC(sv);
d6545 2
a6546 2
	if (SvIsCOW(sv))
	    sv_force_normal_flags(sv, 0);
d6596 1
a6596 1
	    sv_upgrade(sv, ((flags & SVTYPEMASK) > SVt_IV ? SVt_PVIV : SVt_IV));
a6693 1
    dVAR;
d6698 2
a6699 1
    SvGETMAGIC(sv);
d6701 2
a6702 2
	if (SvIsCOW(sv))
	    sv_force_normal_flags(sv, 0);
a6810 1
    dVAR;
a6834 1
    dVAR;
a6858 1
    dVAR;
d6860 1
a6860 1
	return NULL;
a6881 1
    dVAR;
d6885 1
a6885 1
    sv_setpvn(sv, s, len || s == NULL ? len : strlen(s));
a6902 1
    dVAR;
a6923 1
    dVAR;
d6946 1
a6946 1
	} else if (flags & (HVhek_REHASH|HVhek_UNSHARED)) {
d6951 1
a6951 4
	       into an hv routine with a regular hash.
	       Similarly, a hash that isn't using shared hash keys has to have
	       the flag in every key so that we know not to try to call
	       share_hek_kek on it.  */
d6959 3
a6961 17
	{
	    /* Inline most of newSVpvn_share(), because share_hek_hek() is far
	       more efficient than sharepvn().  */
	    SV *sv;

	    new_SV(sv);
	    sv_upgrade(sv, SVt_PV);
	    SvPV_set(sv, (char *)HEK_KEY(share_hek_hek(hek)));
	    SvCUR_set(sv, HEK_LEN(hek));
	    SvLEN_set(sv, 0);
	    SvREADONLY_on(sv);
	    SvFAKE_on(sv);
	    SvPOK_on(sv);
	    if (HEK_UTF8(hek))
		SvUTF8_on(sv);
	    return sv;
	}
d6970 5
a6974 5
first.  Turns on READONLY and FAKE. If the C<hash> parameter is non-zero, that
value is used; otherwise the hash is computed. The string's hash can be later
be retrieved from the SV with the C<SvSHARED_HASH()> macro. The idea here is
that as the string table is used for shared hash keys these strings will have
SvPVX_const == HeKEY and hash lookup will avoid string compare.
a6981 1
    dVAR;
a6983 2
    const char *const orig_src = src;

d6988 1
a6988 1
	src = (char*)bytes_from_utf8((const U8*)src, &tmplen, &is_utf8);
d6994 1
a6994 1
    sv_upgrade(sv, SVt_PV);
d6997 1
a7003 2
    if (src != orig_src)
	Safefree(src);
a7052 1
    dVAR;
d7055 1
a7055 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
a7070 1
    dVAR;
a7089 1
    dVAR;
a7108 1
    dVAR;
a7116 19
=for apidoc newSV_type

Creates a new SV, of the type specified.  The reference count for the new SV
is set to 1.

=cut
*/

SV *
Perl_newSV_type(pTHX_ svtype type)
{
    register SV *sv;

    new_SV(sv);
    sv_upgrade(sv, type);
    return sv;
}

/*
d7128 4
a7131 2
    dVAR;
    register SV *sv = newSV_type(SVt_RV);
d7143 1
a7143 1
Perl_newRV(pTHX_ SV *sv)
d7145 1
a7145 2
    dVAR;
    return newRV_noinc(SvREFCNT_inc_simple_NN(sv));
a7159 1
    dVAR;
d7163 1
a7163 1
	return NULL;
d7167 1
a7167 1
	return NULL;
d7187 1
a7187 1
Perl_sv_reset(pTHX_ register const char *s, HV *stash)
d7189 1
a7189 1
    dVAR;
d7196 2
a7197 14
	MAGIC * const mg = mg_find((SV *)stash, PERL_MAGIC_symtab);
	if (mg) {
	    const U32 count = mg->mg_len / sizeof(PMOP**);
	    PMOP **pmp = (PMOP**) mg->mg_ptr;
	    PMOP *const *const end = pmp + count;

	    while (pmp < end) {
#ifdef USE_ITHREADS
                SvREADONLY_off(PL_regex_pad[(*pmp)->op_pmoffset]);
#else
		(*pmp)->op_pmflags &= ~PMf_USED;
#endif
		++pmp;
	    }
d7242 1
a7242 1
			if (SvPVX_const(sv) != NULL)
d7281 1
d7298 1
a7298 1
	gv = gv_fetchsv(sv, 0, SVt_PVIO);
d7304 1
a7304 1
	    Perl_croak(aTHX_ "Bad filehandle: %"SVf, SVfARG(sv));
a7314 1
The flags in C<lref> are passed to sv_fetchsv.
d7322 3
a7324 3
    dVAR;
    GV *gv = NULL;
    CV *cv = NULL;
d7326 2
a7327 5
    if (!sv) {
	*st = NULL;
	*gvp = NULL;
	return NULL;
    }
d7331 1
a7331 1
	*gvp = NULL;
d7335 2
a7336 3
	*st = NULL;
	*gvp = NULL;
	return NULL;
d7344 2
a7345 1
	SvGETMAGIC(sv);
d7353 1
a7353 1
		*gvp = NULL;
d7365 1
a7365 1
	    gv = gv_fetchsv(sv, lref, SVt_PVCV);
d7367 2
a7368 9
	if (!gv) {
	    *st = NULL;
	    return NULL;
	}
	/* Some flags to gv_fetchsv mean don't really create the GV  */
	if (SvTYPE(gv) != SVt_PVGV) {
	    *st = NULL;
	    return NULL;
	}
d7374 2
a7375 2
	    tmpsv = newSV(0);
	    gv_efullname3(tmpsv, gv, NULL);
d7381 2
a7382 1
		   NULL, NULL);
d7386 1
a7386 1
			   SVfARG(sv));
d7411 1
a7411 1
		(tXpv->xpv_cur && *sv->sv_u.svu_pv != '0')))
d7429 114
d7564 1
a7564 1
    dVAR;
d7566 1
a7566 1
        sv_force_normal_flags(sv, 0);
d7594 1
a7594 1
	    SvUPGRADE(sv, SVt_PV);		/* Never FALSE */
d7598 1
a7598 1
	    SvPVX(sv)[len] = '\0';
d7610 32
d7645 3
a7647 1
The backend for the C<SvPVbytex_force> macro. Always use the macro instead.
d7661 32
d7696 3
a7698 1
The backend for the C<SvPVutf8x_force> macro. Always use the macro instead.
d7720 2
a7721 2
const char *
Perl_sv_reftype(pTHX_ const SV *sv, int ob)
d7739 1
a7739 2
				if (SvVOK(sv))
				    return "VSTRING";
a7755 1
	case SVt_BIND:		return "BIND";
d7776 2
a7777 1
    SvGETMAGIC(sv);
d7802 2
a7803 1
    SvGETMAGIC(sv);
a7829 1
    dVAR;
d7834 2
a7835 2
    SV_CHECK_THINKFIRST_COW_DROP(rv);
    (void)SvAMAGIC_off(rv);
d7843 1
d7845 1
a7845 4
	sv_upgrade(rv, SVt_RV);
    } else if (SvROK(rv)) {
	SvREFCNT_dec(SvRV(rv));
    } else if (SvTYPE(rv) < SVt_RV)
d7858 1
a7858 1
	HV* const stash = gv_stashpv(classname, GV_ADD);
d7871 1
a7871 1
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
a7884 1
    dVAR;
d7900 1
a7900 1
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
d7919 1
a7919 1
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
d7938 1
a7938 1
blessing.  Set C<classname> to C<NULL> to avoid the blessing.  The new SV
d7958 1
a7958 1
C<NULL> to avoid the blessing.  The new SV will have a reference count
d7967 1
a7967 1
Perl_sv_setref_pvn(pTHX_ SV *rv, const char *classname, const char *pv, STRLEN n)
a7985 1
    dVAR;
a7990 2
	if (SvIsCOW(tmpRef))
	    sv_force_normal_flags(tmpRef, 0);
d8002 2
a8003 2
    SvUPGRADE(tmpRef, SVt_PVMG);
    SvSTASH_set(tmpRef, (HV*)SvREFCNT_inc_simple(stash));
d8008 1
a8008 1
	(void)SvAMAGIC_off(sv);
a8024 1
    dVAR;
a8025 2
    HV *stash;
    SV * const temp = sv_newmortal();
d8029 1
a8029 5
    gv_efullname3(temp, (GV *) sv, "*");

    if (GvGP(sv)) {
        if(GvCVu((GV*)sv) && (stash = GvSTASH((GV*)sv)) && HvNAME_get(stash))
            mro_method_changed_in(stash);
a8030 1
    }
d8032 2
a8033 2
	sv_del_backref((SV*)GvSTASH(sv), sv);
	GvSTASH(sv) = NULL;
d8035 2
a8037 4
    if (GvNAME_HEK(sv)) {
	unshare_hek(GvNAME_HEK(sv));
    }
    isGV_with_GP_off(sv);
a8046 4

    /* Intentionally not calling any local SET magic, as this isn't so much a
       set operation as merely an internal storage change.  */
    sv_setsv_flags(sv, temp, 0);
d8064 1
a8064 1
Perl_sv_unref_flags(pTHX_ SV *ref, U32 flags)
d8066 1
a8066 1
    SV* const target = SvRV(ref);
d8068 4
a8071 4
    if (SvWEAKREF(ref)) {
    	sv_del_backref(target, ref);
	SvWEAKREF_off(ref);
	SvRV_set(ref, NULL);
d8074 3
a8076 3
    SvRV_set(ref, NULL);
    SvROK_off(ref);
    /* You can't have a || SvREADONLY(target) here, as $a = $$a, where $a was
d8078 2
a8079 2
    if (SvREFCNT(target) != 1 || (flags & SV_IMMEDIATE_UNREF))
	SvREFCNT_dec(target);
d8081 31
a8111 1
	sv_2mortal(target);	/* Schedule for freeing later */
d8143 1
a8143 1
	if (mg && (mg->mg_len & 1) )
d8179 5
a8183 1
    sv_setpviv(sv, iv);
d8252 1
a8252 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d8285 1
a8285 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d8358 1
a8358 1
    sv_vcatpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d8391 1
a8391 1
    sv_vcatpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d8413 2
a8417 1
    dVAR;
d8423 2
a8424 7
	var = *(*pattern)++ - '0';
	while (isDIGIT(**pattern)) {
	    const I32 tmp = var * 10 + (*(*pattern)++ - '0');
	    if (tmp < var)
		Perl_croak(aTHX_ "Integer overflow in format string for %s", (PL_op ? OP_NAME(PL_op) : "sv_vcatpvfn"));
	    var = tmp;
	}
d8428 1
d8430 2
a8431 2
STATIC char *
S_F0convert(NV nv, char *endbuf, STRLEN *len)
d8453 1
a8453 1
    return NULL;
d8466 2
a8472 5

#define VECTORIZE_ARGS	vecsv = va_arg(*args, SV*);\
			vecstr = (U8*)SvPV_const(vecsv,veclen);\
			vec_utf8 = DO_UTF8(vecsv);

a8477 1
    dVAR;
d8484 1
a8484 1
    SV *argsv = NULL;
d8487 1
a8487 1
    SV *nsv = NULL;
d8500 1
a8500 1
    /* special-case "", "%s", and "%-p" (SVf - see below) */
d8503 3
a8505 1
    if (patlen == 2 && pat[0] == '%' && pat[1] == 's') {
d8512 2
d8516 11
a8526 6
    }
    if (args && patlen == 3 && pat[0] == '%' &&
		pat[1] == '-' && pat[2] == 'p') {
	argsv = (SV*)va_arg(*args, void*);
	sv_catsv(sv, argsv);
	return;
d8586 1
a8586 1
	const I32 osvix = svix;
d8598 1
a8598 1
	const char *eptr = NULL;
d8600 2
a8601 2
	SV *vecsv = NULL;
	const U8 *vecstr = NULL;
d8648 1
a8648 1
    [%bcdefginopsuxDFOUX] format (mandatory)
d8650 1
a8650 47

	if (args) {
/*  
	As of perl5.9.3, printf format checking is on by default.
	Internally, perl uses %p formats to provide an escape to
	some extended formatting.  This block deals with those
	extensions: if it does not match, (char*)q is reset and
	the normal format processing code is used.

	Currently defined extensions are:
		%p		include pointer address (standard)	
		%-p	(SVf)	include an SV (previously %_)
		%-<num>p	include an SV with precision <num>	
		%<num>p		reserved for future extensions

	Robin Barker 2005-07-14

		%1p	(VDf)	removed.  RMB 2007-10-19
*/
 	    char* r = q; 
	    bool sv = FALSE;	
	    STRLEN n = 0;
	    if (*q == '-')
		sv = *q++;
	    n = expect_number(&q);
	    if (*q++ == 'p') {
		if (sv) {			/* SVf */
		    if (n) {
			precis = n;
			has_precis = TRUE;
		    }
		    argsv = (SV*)va_arg(*args, void*);
		    eptr = SvPV_const(argsv, elen);
		    if (DO_UTF8(argsv))
			is_utf8 = TRUE;
		    goto string;
		}
		else if (n) {
		    if (ckWARN_d(WARN_INTERNAL))
			Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			"internal %%<num>p might conflict with future printf extensions");
		}
	    }
	    q = r; 
	}

	if ( (width = expect_number(&q)) ) {
d8665 1
a8665 4
		if (plus == '+' && *q == ' ') /* '+' over ' ' */
		    q++;
		else
		    plus = *q++;
d8691 1
a8691 1
	    if ( (ewix = expect_number(&q)) )
d8711 1
a8711 1
	    if( *q == '0' )
d8713 1
a8713 1
	    width = expect_number(&q);
d8716 5
d8744 3
a8746 1
		VECTORIZE_ARGS
a8751 18

		/* if this is a version object, we need to convert
		 * back into v-string notation and then let the
		 * vectorize happen normally
		 */
		if (sv_derived_from(vecsv, "version")) {
		    char *version = savesvpv(vecsv);
		    if ( hv_exists((HV*)SvRV(vecsv), "alpha", 5 ) ) {
			Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			"vector argument not supported with alpha versions");
			goto unknown;
		    }
		    vecsv = sv_newmortal();
		    scan_vstring(version, version + veclen, vecsv);
		    vecstr = (U8*)SvPV_const(vecsv, veclen);
		    vec_utf8 = DO_UTF8(vecsv);
		    Safefree(version);
		}
d8754 1
d8777 1
a8777 1
		if ( ((epix = expect_number(&q))) && (*q++ != '$') )
d8787 1
a8787 2
		precis = i;
		has_precis = !(i < 0);
a8792 1
		has_precis = TRUE;
d8794 1
d8821 1
a8821 1
	    /*FALLTHROUGH*/
d8837 1
a8837 1
	    /*FALLTHROUGH*/
d8839 1
a8839 1
	    /*FALLTHROUGH*/
a8849 4
	    if (vectorize) {
		c = '%';
		goto unknown;
	    }
d8853 3
a8855 1
	if (!vectorize && !args) {
d8870 1
a8870 3
	    if (vectorize)
		goto unknown;
	    uv = (args) ? va_arg(*args, int) : SvIV(argsv);
d8886 1
a8886 3
	    if (vectorize)
		goto unknown;
	    if (args) {
d8902 1
a8902 1
		eptr = SvPV_const(argsv, elen);
a8903 1
		    I32 old_precis = precis;
d8910 1
a8910 4
			if (has_precis && precis < elen)
			    width += precis - old_precis;
			else
			    width += elen - sv_len_utf8(argsv);
d8915 17
d8934 1
d8942 15
d8969 1
a8969 1
	    /*FALLTHROUGH*/
d8972 1
a8972 1
#if vdNUMBER
d8980 1
a8980 1
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
d9003 1
a9003 1
		IV tiv = SvIV(argsv); /* work around GCC bug #13488 */
d9035 1
a9035 1
	    /*FALLTHROUGH*/
a9039 1
	case 'B':
d9050 1
a9050 1
	    /*FALLTHROUGH*/
d9066 1
a9066 1
		    uv = utf8n_to_uvchr(vecstr, veclen, &ulen,
d9087 1
a9087 1
		UV tuv = SvUV(argsv); /* work around GCC bug #13488 */
a9101 3
		bool tempalt = uv ? alt : FALSE; /* Vectors can't change alt */
		zeros = 0;

d9105 4
a9108 1
		    p = (char *)((c == 'X') ? PL_hexdigit + 16 : PL_hexdigit);
d9113 1
a9113 1
		    if (tempalt) {
d9127 2
d9133 1
a9133 1
		    if (tempalt) {
d9135 1
a9135 1
			esignbuf[esignlen++] = c;
d9139 13
d9163 1
a9163 2
		    else if (precis == 0 && elen == 1 && *eptr == '0'
			     && !(base == 8 && alt)) /* "%#.0o" prints "0" */
a9164 4

		/* a precision nullifies the 0 flag. */
		    if (fill == '0')
			fill = ' ';
d9173 1
a9173 1
	    /*FALLTHROUGH*/
a9176 2
	    if (vectorize)
		goto unknown;
d9192 1
a9192 1
		/*FALLTHROUGH*/
d9202 1
a9202 1
		/*FALLTHROUGH*/
d9209 1
a9209 1
	    nv = (args) ?
d9217 1
a9217 1
		: SvNV(argsv);
d9220 2
a9221 3
	    /* nv * 0 will be NaN for NaN, +Inf and -Inf, and 0 for anything
	       else. frexp() has some unspecified behaviour for those three */
	    if (c != 'e' && c != 'E' && (nv * 0) == 0) {
d9316 1
a9316 3
		    /* May return an empty string for digits==0 */
		    if (*PL_efloatbuf) {
			elen = strlen(PL_efloatbuf);
a9317 1
		    }
d9361 4
a9364 3
		elen = ((intsize == 'q')
			? my_snprintf(PL_efloatbuf, PL_efloatsize, ptr, nv)
			: my_snprintf(PL_efloatbuf, PL_efloatsize, ptr, (double)nv));
d9366 1
a9366 1
		elen = my_sprintf(PL_efloatbuf, ptr, nv);
d9371 1
a9376 2
	    if (vectorize)
		goto unknown;
d9378 1
a9378 1
	    if (args) {
d9391 1
d9402 1
a9402 1
		SV * const msg = sv_newmortal();
d9414 2
a9415 2
		    sv_catpvs(msg, "end of string");
		Perl_warner(aTHX_ packWARN(WARN_PRINTF), "%"SVf, SVfARG(msg)); /* yes, this is reentrant */
d9435 1
a9435 19
	if (is_utf8 != has_utf8) {
	    if (is_utf8) {
		if (SvCUR(sv))
		    sv_utf8_upgrade(sv);
	    }
	    else {
		const STRLEN old_elen = elen;
		SV * const nsv = sv_2mortal(newSVpvn(eptr, elen));
		sv_utf8_upgrade(nsv);
		eptr = SvPVX_const(nsv);
		elen = SvCUR(nsv);

		if (width) { /* fudge width (can't fudge elen) */
		    width += elen - old_elen;
		}
		is_utf8 = TRUE;
	    }
	}

d9440 23
d9525 1
a9525 1
The foo_dup() functions make an exact copy of an existing foo thingy.
d9537 4
a9540 1
/* XXX Remove this so it doesn't have to go thru the macro and return for nothing */
a9545 3
/* Certain cases in Perl_ss_dup have been merged, by relying on the fact
   that currently av_dup, gv_dup and hv_dup are the same as sv_dup.
   If this changes, please unmerge ss_dup.  */
a9546 1
#define sv_dup_inc_NN(s,t)	SvREFCNT_inc_NN(sv_dup(s,t))
d9557 2
a9558 2
#define SAVEPV(p)	((p) ? savepv(p) : NULL)
#define SAVEPVN(p,n)	((p) ? savepvn(p,n) : NULL)
a9559 1
/* clone a parser */
d9561 5
a9565 2
yy_parser *
Perl_parser_dup(pTHX_ const yy_parser *proto, CLONE_PARAMS* param)
d9567 6
a9572 1
    yy_parser *parser;
d9574 5
a9578 2
    if (!proto)
	return NULL;
d9580 2
a9581 4
    /* look for it in the table first */
    parser = (yy_parser *)ptr_table_fetch(PL_ptr_table, proto);
    if (parser)
	return parser;
d9583 18
a9600 3
    /* create anew and remember what it is */
    Newxz(parser, 1, yy_parser);
    ptr_table_store(PL_ptr_table, proto, parser);
d9602 33
a9634 2
    parser->yyerrstatus = 0;
    parser->yychar = YYEMPTY;		/* Cause a token to be read.  */
d9636 4
a9639 43
    /* XXX these not yet duped */
    parser->old_parser = NULL;
    parser->stack = NULL;
    parser->ps = NULL;
    parser->stack_size = 0;
    /* XXX parser->stack->state = 0; */

    /* XXX eventually, just Copy() most of the parser struct ? */

    parser->lex_brackets = proto->lex_brackets;
    parser->lex_casemods = proto->lex_casemods;
    parser->lex_brackstack = savepvn(proto->lex_brackstack,
		    (proto->lex_brackets < 120 ? 120 : proto->lex_brackets));
    parser->lex_casestack = savepvn(proto->lex_casestack,
		    (proto->lex_casemods < 12 ? 12 : proto->lex_casemods));
    parser->lex_defer	= proto->lex_defer;
    parser->lex_dojoin	= proto->lex_dojoin;
    parser->lex_expect	= proto->lex_expect;
    parser->lex_formbrack = proto->lex_formbrack;
    parser->lex_inpat	= proto->lex_inpat;
    parser->lex_inwhat	= proto->lex_inwhat;
    parser->lex_op	= proto->lex_op;
    parser->lex_repl	= sv_dup_inc(proto->lex_repl, param);
    parser->lex_starts	= proto->lex_starts;
    parser->lex_stuff	= sv_dup_inc(proto->lex_stuff, param);
    parser->multi_close	= proto->multi_close;
    parser->multi_open	= proto->multi_open;
    parser->multi_start	= proto->multi_start;
    parser->multi_end	= proto->multi_end;
    parser->pending_ident = proto->pending_ident;
    parser->preambled	= proto->preambled;
    parser->sublex_info	= proto->sublex_info; /* XXX not quite right */
    parser->linestr	= sv_dup_inc(proto->linestr, param);
    parser->expect	= proto->expect;
    parser->copline	= proto->copline;
    parser->last_lop_op	= proto->last_lop_op;
    parser->lex_state	= proto->lex_state;
    parser->rsfp	= fp_dup(proto->rsfp, '<', param);
    /* rsfp_filters entries have fake IoDIRP() */
    parser->rsfp_filters= av_dup_inc(proto->rsfp_filters, param);
    parser->in_my	= proto->in_my;
    parser->in_my_stash	= hv_dup(proto->in_my_stash, param);
    parser->error_count	= proto->error_count;
d9641 2
d9644 8
a9651 1
    parser->linestr	= sv_dup_inc(proto->linestr, param);
d9653 1
a9653 3
    {
	char * const ols = SvPVX(proto->linestr);
	char * const ls  = SvPVX(parser->linestr);
d9655 4
a9658 32
	parser->bufptr	    = ls + (proto->bufptr >= ols ?
				    proto->bufptr -  ols : 0);
	parser->oldbufptr   = ls + (proto->oldbufptr >= ols ?
				    proto->oldbufptr -  ols : 0);
	parser->oldoldbufptr= ls + (proto->oldoldbufptr >= ols ?
				    proto->oldoldbufptr -  ols : 0);
	parser->linestart   = ls + (proto->linestart >= ols ?
				    proto->linestart -  ols : 0);
	parser->last_uni    = ls + (proto->last_uni >= ols ?
				    proto->last_uni -  ols : 0);
	parser->last_lop    = ls + (proto->last_lop >= ols ?
				    proto->last_lop -  ols : 0);

	parser->bufend	    = ls + SvCUR(parser->linestr);
    }

    Copy(proto->tokenbuf, parser->tokenbuf, 256, char);


#ifdef PERL_MAD
    parser->endwhite	= proto->endwhite;
    parser->faketokens	= proto->faketokens;
    parser->lasttoke	= proto->lasttoke;
    parser->nextwhite	= proto->nextwhite;
    parser->realtokenstart = proto->realtokenstart;
    parser->skipwhite	= proto->skipwhite;
    parser->thisclose	= proto->thisclose;
    parser->thismad	= proto->thismad;
    parser->thisopen	= proto->thisopen;
    parser->thisstuff	= proto->thisstuff;
    parser->thistoken	= proto->thistoken;
    parser->thiswhite	= proto->thiswhite;
d9660 2
a9661 8
    Copy(proto->nexttoke, parser->nexttoke, 5, NEXTTOKE);
    parser->curforce	= proto->curforce;
#else
    Copy(proto->nextval, parser->nextval, 5, YYSTYPE);
    Copy(proto->nexttype, parser->nexttype, 5,	I32);
    parser->nexttoke	= proto->nexttoke;
#endif
    return parser;
a9663 1

a9691 1
    PERL_UNUSED_CONTEXT;
a9703 1

d9725 1
d9727 1
a9727 1
    ret->gp_file_hek	= hek_dup(gp->gp_file_hek, param);
d9757 1
a9757 1
	    nmg->mg_obj	= (SV*)CALLREGDUPE((REGEXP*)mg->mg_obj, param);
d9760 9
a9768 3
	    /* The backref AV has its reference count deliberately bumped by
	       1.  */
	    nmg->mg_obj = SvREFCNT_inc(av_dup_inc((AV*) mg->mg_obj, param));
d9783 2
a9784 2
		    const AMT * const amtp = (AMT*)mg->mg_ptr;
		    AMT * const namtp = (AMT*)nmg->mg_ptr;
a9801 2
#endif /* USE_ITHREADS */

a9807 2
    PERL_UNUSED_CONTEXT;

a9817 5
/* 
   we use the PTE_SVSLOT 'reservation' made above, both here (in the
   following define) and at call to new_body_inline made below in 
   Perl_ptr_table_store()
 */
d9819 38
a9856 1
#define del_pte(p)     del_body_type(p, PTE_SVSLOT)
d9860 3
a9862 2
STATIC PTR_TBL_ENT_t *
S_ptr_table_find(PTR_TBL_t *tbl, const void *sv) {
d9869 1
a9869 1
	    return tblent;
d9871 1
a9871 9
    return NULL;
}

void *
Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *tbl, const void *sv)
{
    PTR_TBL_ENT_t const *const tblent = ptr_table_find(tbl, sv);
    PERL_UNUSED_CONTEXT;
    return tblent ? tblent->newval : NULL;
d9877 1
a9877 1
Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, const void *oldsv, void *newsv)
d9879 6
a9884 2
    PTR_TBL_ENT_t *tblent = ptr_table_find(tbl, oldsv);
    PERL_UNUSED_CONTEXT;
d9886 7
a9892 14
    if (tblent) {
	tblent->newval = newsv;
    } else {
	const UV entry = PTR_TABLE_HASH(oldsv) & tbl->tbl_max;

	new_body_inline(tblent, PTE_SVSLOT);

	tblent->oldval = oldsv;
	tblent->newval = newsv;
	tblent->next = tbl->tbl_ary[entry];
	tbl->tbl_ary[entry] = tblent;
	tbl->tbl_items++;
	if (tblent->next && tbl->tbl_items > tbl->tbl_max)
	    ptr_table_split(tbl);
d9894 8
a9912 1
    PERL_UNUSED_CONTEXT;
d9941 4
a9944 3
    if (tbl && tbl->tbl_items) {
	register PTR_TBL_ENT_t * const * const array = tbl->tbl_ary;
	UV riter = tbl->tbl_max;
d9946 3
a9948 2
	do {
	    PTR_TBL_ENT_t *entry = array[riter];
d9950 3
a9952 6
	    while (entry) {
		PTR_TBL_ENT_t * const oentry = entry;
		entry = entry->next;
		del_pte(oentry);
	    }
	} while (riter--);
d9954 12
a9965 1
	tbl->tbl_items = 0;
d9967 2
d9984 6
a9989 1
#if defined(USE_ITHREADS)
d9992 1
a9992 1
Perl_rvpv_dup(pTHX_ SV *dstr, const SV *sstr, CLONE_PARAMS* param)
a10004 6
	    if (SvREADONLY(sstr) && SvFAKE(sstr)) {
		/* Not that normal - actually sstr is copy on write.
		   But we are a true, independant SV, so:  */
		SvREADONLY_off(dstr);
		SvFAKE_off(dstr);
	    }
d10008 16
a10023 8
	    if (isGV_with_GP(sstr)) {
		/* Don't need to do anything here.  */
	    }
	    else if ((SvREADONLY(sstr) && SvFAKE(sstr))) {
		/* A "shared" PV - clone it as "shared" PV */
		SvPV_set(dstr,
			 HEK_KEY(hek_dup(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr)),
					 param)));
d10028 1
a10028 1
	    }
d10032 1
a10032 1
	/* Copy the NULL */
d10036 1
a10036 1
	    SvPV_set(dstr, NULL);
a10039 2
/* duplicate an SV of any type (including AV, HV etc) */

d10041 1
a10041 1
Perl_sv_dup(pTHX_ const SV *sstr, CLONE_PARAMS* param)
a10042 1
    dVAR;
d10046 1
a10046 1
	return NULL;
d10055 6
a10060 5
	if (SvTYPE(sstr) == SVt_PVHV) {
	    const HEK * const hvname = HvNAME_HEK(sstr);
	    if (hvname)
		/** don't clone stashes if they already exist **/
		return (SV*)gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname), 0);
a10065 9

#ifdef DEBUG_LEAKING_SCALARS
    dstr->sv_debug_optype = sstr->sv_debug_optype;
    dstr->sv_debug_line = sstr->sv_debug_line;
    dstr->sv_debug_inpad = sstr->sv_debug_inpad;
    dstr->sv_debug_cloned = 1;
    dstr->sv_debug_file = savepv(sstr->sv_debug_file);
#endif

d10076 1
a10076 1
		      (void*)PL_watch_pvx, SvPVX_const(sstr));
d10081 2
a10082 1
	SvFLAGS(dstr) = 0;
d10091 1
a10091 1
	SvANY(dstr)	= (XPVIV*)((char*)&(dstr->sv_u.svu_iv) - STRUCT_OFFSET(XPVIV, xiv_iv));
d10099 93
a10191 1
	SvANY(dstr)	= &(dstr->sv_u.svu_rv);
d10193 32
d10226 26
a10251 36
	/* case SVt_BIND: */
    default:
	{
	    /* These are all the types that need complex bodies allocating.  */
	    void *new_body;
	    const svtype sv_type = SvTYPE(sstr);
	    const struct body_details *const sv_type_details
		= bodies_by_type + sv_type;

	    switch (sv_type) {
	    default:
		Perl_croak(aTHX_ "Bizarre SvTYPE [%" IVdf "]", (IV)SvTYPE(sstr));
		break;

	    case SVt_PVGV:
		if (GvUNIQUE((GV*)sstr)) {
		    NOOP;   /* Do sharing here, and fall through */
		}
	    case SVt_PVIO:
	    case SVt_PVFM:
	    case SVt_PVHV:
	    case SVt_PVAV:
	    case SVt_PVCV:
	    case SVt_PVLV:
	    case SVt_PVMG:
	    case SVt_PVNV:
	    case SVt_PVIV:
	    case SVt_PV:
		assert(sv_type_details->body_size);
		if (sv_type_details->arena) {
		    new_body_inline(new_body, sv_type);
		    new_body
			= (void*)((char*)new_body - sv_type_details->offset);
		} else {
		    new_body = new_NOARENA(sv_type_details);
		}
d10253 3
a10255 29
	    assert(new_body);
	    SvANY(dstr) = new_body;

#ifndef PURIFY
	    Copy(((char*)SvANY(sstr)) + sv_type_details->offset,
		 ((char*)SvANY(dstr)) + sv_type_details->offset,
		 sv_type_details->copy, char);
#else
	    Copy(((char*)SvANY(sstr)),
		 ((char*)SvANY(dstr)),
		 sv_type_details->body_size + sv_type_details->offset, char);
#endif

	    if (sv_type != SVt_PVAV && sv_type != SVt_PVHV
		&& !isGV_with_GP(dstr))
		Perl_rvpv_dup(aTHX_ dstr, sstr, param);

	    /* The Copy above means that all the source (unduplicated) pointers
	       are now in the destination.  We can check the flags and the
	       pointers in either, but it's possible that there's less cache
	       missing by always going for the destination.
	       FIXME - instrument and check that assumption  */
	    if (sv_type >= SVt_PVMG) {
		if ((sv_type == SVt_PVMG) && SvPAD_OUR(dstr)) {
		    SvOURSTASH_set(dstr, hv_dup_inc(SvOURSTASH(dstr), param));
		} else if (SvMAGIC(dstr))
		    SvMAGIC_set(dstr, mg_dup(SvMAGIC(dstr), param));
		if (SvSTASH(dstr))
		    SvSTASH_set(dstr, hv_dup_inc(SvSTASH(dstr), param));
d10257 27
a10283 169

	    /* The cast silences a GCC warning about unhandled types.  */
	    switch ((int)sv_type) {
	    case SVt_PV:
		break;
	    case SVt_PVIV:
		break;
	    case SVt_PVNV:
		break;
	    case SVt_PVMG:
		break;
	    case SVt_PVLV:
		/* XXX LvTARGOFF sometimes holds PMOP* when DEBUGGING */
		if (LvTYPE(dstr) == 't') /* for tie: unrefcnted fake (SV**) */
		    LvTARG(dstr) = dstr;
		else if (LvTYPE(dstr) == 'T') /* for tie: fake HE */
		    LvTARG(dstr) = (SV*)he_dup((HE*)LvTARG(dstr), 0, param);
		else
		    LvTARG(dstr) = sv_dup_inc(LvTARG(dstr), param);
	    case SVt_PVGV:
		if(isGV_with_GP(sstr)) {
		    if (GvNAME_HEK(dstr))
			GvNAME_HEK(dstr) = hek_dup(GvNAME_HEK(dstr), param);
		    /* Don't call sv_add_backref here as it's going to be
		       created as part of the magic cloning of the symbol
		       table.  */
		    /* Danger Will Robinson - GvGP(dstr) isn't initialised
		       at the point of this comment.  */
		    GvSTASH(dstr) = hv_dup(GvSTASH(dstr), param);
		    GvGP(dstr)	= gp_dup(GvGP(sstr), param);
		    (void)GpREFCNT_inc(GvGP(dstr));
		} else
		    Perl_rvpv_dup(aTHX_ dstr, sstr, param);
		break;
	    case SVt_PVIO:
		IoIFP(dstr)	= fp_dup(IoIFP(dstr), IoTYPE(dstr), param);
		if (IoOFP(dstr) == IoIFP(sstr))
		    IoOFP(dstr) = IoIFP(dstr);
		else
		    IoOFP(dstr)	= fp_dup(IoOFP(dstr), IoTYPE(dstr), param);
		/* PL_parser->rsfp_filters entries have fake IoDIRP() */
		if(IoFLAGS(dstr) & IOf_FAKE_DIRP) {
		    /* I have no idea why fake dirp (rsfps)
		       should be treated differently but otherwise
		       we end up with leaks -- sky*/
		    IoTOP_GV(dstr)      = gv_dup_inc(IoTOP_GV(dstr), param);
		    IoFMT_GV(dstr)      = gv_dup_inc(IoFMT_GV(dstr), param);
		    IoBOTTOM_GV(dstr)   = gv_dup_inc(IoBOTTOM_GV(dstr), param);
		} else {
		    IoTOP_GV(dstr)      = gv_dup(IoTOP_GV(dstr), param);
		    IoFMT_GV(dstr)      = gv_dup(IoFMT_GV(dstr), param);
		    IoBOTTOM_GV(dstr)   = gv_dup(IoBOTTOM_GV(dstr), param);
		    if (IoDIRP(dstr)) {
			IoDIRP(dstr)	= dirp_dup(IoDIRP(dstr));
		    } else {
			NOOP;
			/* IoDIRP(dstr) is already a copy of IoDIRP(sstr)  */
		    }
		}
		IoTOP_NAME(dstr)	= SAVEPV(IoTOP_NAME(dstr));
		IoFMT_NAME(dstr)	= SAVEPV(IoFMT_NAME(dstr));
		IoBOTTOM_NAME(dstr)	= SAVEPV(IoBOTTOM_NAME(dstr));
		break;
	    case SVt_PVAV:
		if (AvARRAY((AV*)sstr)) {
		    SV **dst_ary, **src_ary;
		    SSize_t items = AvFILLp((AV*)sstr) + 1;

		    src_ary = AvARRAY((AV*)sstr);
		    Newxz(dst_ary, AvMAX((AV*)sstr)+1, SV*);
		    ptr_table_store(PL_ptr_table, src_ary, dst_ary);
		    AvARRAY((AV*)dstr) = dst_ary;
		    AvALLOC((AV*)dstr) = dst_ary;
		    if (AvREAL((AV*)sstr)) {
			while (items-- > 0)
			    *dst_ary++ = sv_dup_inc(*src_ary++, param);
		    }
		    else {
			while (items-- > 0)
			    *dst_ary++ = sv_dup(*src_ary++, param);
		    }
		    items = AvMAX((AV*)sstr) - AvFILLp((AV*)sstr);
		    while (items-- > 0) {
			*dst_ary++ = &PL_sv_undef;
		    }
		}
		else {
		    AvARRAY((AV*)dstr)	= NULL;
		    AvALLOC((AV*)dstr)	= (SV**)NULL;
		}
		break;
	    case SVt_PVHV:
		if (HvARRAY((HV*)sstr)) {
		    STRLEN i = 0;
		    const bool sharekeys = !!HvSHAREKEYS(sstr);
		    XPVHV * const dxhv = (XPVHV*)SvANY(dstr);
		    XPVHV * const sxhv = (XPVHV*)SvANY(sstr);
		    char *darray;
		    Newx(darray, PERL_HV_ARRAY_ALLOC_BYTES(dxhv->xhv_max+1)
			+ (SvOOK(sstr) ? sizeof(struct xpvhv_aux) : 0),
			char);
		    HvARRAY(dstr) = (HE**)darray;
		    while (i <= sxhv->xhv_max) {
			const HE * const source = HvARRAY(sstr)[i];
			HvARRAY(dstr)[i] = source
			    ? he_dup(source, sharekeys, param) : 0;
			++i;
		    }
		    if (SvOOK(sstr)) {
			HEK *hvname;
			const struct xpvhv_aux * const saux = HvAUX(sstr);
			struct xpvhv_aux * const daux = HvAUX(dstr);
			/* This flag isn't copied.  */
			/* SvOOK_on(hv) attacks the IV flags.  */
			SvFLAGS(dstr) |= SVf_OOK;

			hvname = saux->xhv_name;
			daux->xhv_name = hvname ? hek_dup(hvname, param) : hvname;

			daux->xhv_riter = saux->xhv_riter;
			daux->xhv_eiter = saux->xhv_eiter
			    ? he_dup(saux->xhv_eiter,
					(bool)!!HvSHAREKEYS(sstr), param) : 0;
			daux->xhv_backreferences =
			    saux->xhv_backreferences
				? (AV*) SvREFCNT_inc(
					sv_dup((SV*)saux->xhv_backreferences, param))
				: 0;

                        daux->xhv_mro_meta = saux->xhv_mro_meta
                            ? mro_meta_dup(saux->xhv_mro_meta, param)
                            : 0;

			/* Record stashes for possible cloning in Perl_clone(). */
			if (hvname)
			    av_push(param->stashes, dstr);
		    }
		}
		else
		    HvARRAY((HV*)dstr) = NULL;
		break;
	    case SVt_PVCV:
		if (!(param->flags & CLONEf_COPY_STACKS)) {
		    CvDEPTH(dstr) = 0;
		}
	    case SVt_PVFM:
		/* NOTE: not refcounted */
		CvSTASH(dstr)	= hv_dup(CvSTASH(dstr), param);
		OP_REFCNT_LOCK;
		if (!CvISXSUB(dstr))
		    CvROOT(dstr) = OpREFCNT_inc(CvROOT(dstr));
		OP_REFCNT_UNLOCK;
		if (CvCONST(dstr) && CvISXSUB(dstr)) {
		    CvXSUBANY(dstr).any_ptr = GvUNIQUE(CvGV(dstr)) ?
			SvREFCNT_inc(CvXSUBANY(dstr).any_ptr) :
			sv_dup_inc((SV *)CvXSUBANY(dstr).any_ptr, param);
		}
		/* don't dup if copying back - CvGV isn't refcounted, so the
		 * duped GV may never be freed. A bit of a hack! DAPM */
		CvGV(dstr)	= (param->flags & CLONEf_JOIN_IN) ?
		    NULL : gv_dup(CvGV(dstr), param) ;
		PAD_DUP(CvPADLIST(dstr), CvPADLIST(sstr), param);
		CvOUTSIDE(dstr)	=
		    CvWEAKOUTSIDE(sstr)
		    ? cv_dup(    CvOUTSIDE(dstr), param)
		    : cv_dup_inc(CvOUTSIDE(dstr), param);
		if (!CvISXSUB(dstr))
		    CvFILE(dstr) = SAVEPV(CvFILE(dstr));
		break;
d10285 48
d10334 12
d10374 2
a10375 2
	PERL_CONTEXT * const cx = &cxs[ix];
	PERL_CONTEXT * const ncx = &ncxs[ix];
d10383 1
d10395 1
a10395 1
					   : NULL);
a10399 3
		ncx->blk_sub.retop	= cx->blk_sub.retop;
		ncx->blk_sub.oldcomppad = (PAD*)ptr_table_fetch(PL_ptr_table,
					   cx->blk_sub.oldcomppad);
a10406 1
		ncx->blk_eval.retop = cx->blk_eval.retop;
d10411 3
a10413 1
		ncx->blk_loop.my_op	= cx->blk_loop.my_op;
a10430 1
		ncx->blk_sub.retop	= cx->blk_sub.retop;
d10498 1
a10498 1
Perl_any_dup(pTHX_ void *v, const PerlInterpreter *proto_perl)
d10525 3
a10527 4
    dVAR;
    ANY * const ss	= proto_perl->Isavestack;
    const I32 max	= proto_perl->Isavestack_max;
    I32 ix		= proto_perl->Isavestack_ix;
a10537 1
    I32 i;
d10545 4
a10548 4
	const I32 type = POPINT(ss,ix);
	TOPINT(nss,ix) = type;
	switch (type) {
	case SAVEt_HELEM:		/* hash element */
a10550 3
	    /* fall through */
	case SAVEt_ITEM:			/* normal string */
        case SAVEt_SV:				/* scalar reference */
d10553 2
a10554 3
	    /* fall through */
	case SAVEt_FREESV:
	case SAVEt_MORTALIZESV:
d10557 8
d10579 6
d10586 4
a10589 8
        case SAVEt_AV:				/* array reference */
	    sv = (SV*) POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    /* fall through */
	case SAVEt_COMPPAD:
	case SAVEt_NSTAB:
	    sv = (SV*) POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
a10599 2
	    /* fall through */
	case SAVEt_CLEARSV:
a10605 1
	case SAVEt_COP_ARYBASE:			/* call CopARYBASE_set */
a10616 2
	case SAVEt_HPTR:			/* HV* reference */
	case SAVEt_APTR:			/* AV* reference */
a10628 1
	case SAVEt_GENERIC_PVREF:		/* generic char* */
d10632 18
a10649 2
	    c = (char*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = pv_dup(c);
d10657 6
d10664 5
d10683 1
a10683 3
		    OP_REFCNT_LOCK;
		    (void) OpREFCNT_inc(o);
		    OP_REFCNT_UNLOCK;
d10686 1
a10686 1
		    TOPPTR(nss,ix) = NULL;
d10691 1
a10691 1
		TOPPTR(nss,ix) = NULL;
d10697 4
a10705 2
	    /* fall through */
	case SAVEt_STACK_POS:		/* Position on Perl stack */
d10731 4
d10743 8
d10758 4
a10761 11
	    ptr = POPPTR(ss,ix);
	    if (ptr) {
		HINTS_REFCNT_LOCK;
		((struct refcounted_he *)ptr)->refcounted_he_refcnt++;
		HINTS_REFCNT_UNLOCK;
	    }
	    TOPPTR(nss,ix) = ptr;
	    if (i & HINT_LOCALIZE_HH) {
		hv = (HV*)POPPTR(ss,ix);
		TOPPTR(nss,ix) = hv_dup_inc(hv, param);
	    }
a10776 77
	case SAVEt_SET_SVFLAGS:
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
	    break;
	case SAVEt_RE_STATE:
	    {
		const struct re_save_state *const old_state
		    = (struct re_save_state *)
		    (ss + ix - SAVESTACK_ALLOC_FOR_RE_SAVE_STATE);
		struct re_save_state *const new_state
		    = (struct re_save_state *)
		    (nss + ix - SAVESTACK_ALLOC_FOR_RE_SAVE_STATE);

		Copy(old_state, new_state, 1, struct re_save_state);
		ix -= SAVESTACK_ALLOC_FOR_RE_SAVE_STATE;

		new_state->re_state_bostr
		    = pv_dup(old_state->re_state_bostr);
		new_state->re_state_reginput
		    = pv_dup(old_state->re_state_reginput);
		new_state->re_state_regeol
		    = pv_dup(old_state->re_state_regeol);
		new_state->re_state_regoffs
		    = (regexp_paren_pair*)
			any_dup(old_state->re_state_regoffs, proto_perl);
		new_state->re_state_reglastparen
		    = (U32*) any_dup(old_state->re_state_reglastparen, 
			      proto_perl);
		new_state->re_state_reglastcloseparen
		    = (U32*)any_dup(old_state->re_state_reglastcloseparen,
			      proto_perl);
		/* XXX This just has to be broken. The old save_re_context
		   code did SAVEGENERICPV(PL_reg_start_tmp);
		   PL_reg_start_tmp is char **.
		   Look above to what the dup code does for
		   SAVEt_GENERIC_PVREF
		   It can never have worked.
		   So this is merely a faithful copy of the exiting bug:  */
		new_state->re_state_reg_start_tmp
		    = (char **) pv_dup((char *)
				      old_state->re_state_reg_start_tmp);
		/* I assume that it only ever "worked" because no-one called
		   (pseudo)fork while the regexp engine had re-entered itself.
		*/
#ifdef PERL_OLD_COPY_ON_WRITE
		new_state->re_state_nrs
		    = sv_dup(old_state->re_state_nrs, param);
#endif
		new_state->re_state_reg_magic
		    = (MAGIC*) any_dup(old_state->re_state_reg_magic, 
			       proto_perl);
		new_state->re_state_reg_oldcurpm
		    = (PMOP*) any_dup(old_state->re_state_reg_oldcurpm, 
			      proto_perl);
		new_state->re_state_reg_curpm
		    = (PMOP*)  any_dup(old_state->re_state_reg_curpm, 
			       proto_perl);
		new_state->re_state_reg_oldsaved
		    = pv_dup(old_state->re_state_reg_oldsaved);
		new_state->re_state_reg_poscache
		    = pv_dup(old_state->re_state_reg_poscache);
		new_state->re_state_reg_starttry
		    = pv_dup(old_state->re_state_reg_starttry);
		break;
	    }
	case SAVEt_COMPILE_WARNINGS:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = DUP_WARNINGS((STRLEN*)ptr);
	    break;
	case SAVEt_PARSER:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = parser_dup((const yy_parser*)ptr, param);
	    break;
d10778 1
a10778 2
	    Perl_croak(aTHX_
		       "panic: ss_dup inconsistency (%"IVdf")", (IV) type);
d10793 1
a10793 1
    const HEK * const hvname = HvNAME_HEK((HV*)sv);
d10804 1
a10804 1
	    XPUSHs(sv_2mortal(newSVhek(hvname)));
d10827 6
a10832 6
CLONEf_COPY_STACKS - is used to, well, copy the stacks also,
without it we only clone the data and zero the stacks,
with it we copy the stacks and the new perl interpreter is
ready to run at the exact same point as the previous one.
The pseudo-fork code uses COPY_STACKS while the
threads->create doesn't.
d10835 9
a10843 9
perl_clone keeps a ptr_table with the pointer of the old
variable as a key and the new variable as a value,
this allows it to check if something has been cloned and not
clone it again but rather just use the value and increase the
refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill
the ptr_table using the function
C<ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;>,
reason to keep it around is if you want to dup some of your own
variable who are outside the graph perl scans, example of this
d10847 5
a10851 5
This is a win32 thing, it is ignored on unix, it tells perls
win32host code (which is c++) to clone itself, this is needed on
win32 if you want to run two threads at the same time,
if you just want to do some stuff in a separate perl interpreter
and then throw it away and return to the original one,
a10863 1
   dVAR;
d10898 1
a10898 1
    CLONE_PARAMS* const param = &clone_params;
d10900 1
a10900 1
    PerlInterpreter * const my_perl = (PerlInterpreter*)(*ipM->pMalloc)(ipM, sizeof(PerlInterpreter));
d10906 3
a10908 3
    PoisonNew(my_perl, 1, PerlInterpreter);
    PL_op = NULL;
    PL_curcop = NULL;
d10914 1
a10915 1
    PL_parser = NULL;
d10935 1
a10935 1
    PerlInterpreter * const my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
d10941 3
a10943 3
    PoisonNew(my_perl, 1, PerlInterpreter);
    PL_op = NULL;
    PL_curcop = NULL;
d10949 1
a10950 1
    PL_parser = NULL;
d10959 31
a10989 5
    INIT_TRACK_MEMPOOL(my_perl->Imemory_debug_header, my_perl);

    PL_body_arenas = NULL;
    Zero(&PL_body_roots, 1, PL_body_roots);
    
d10994 2
a10995 2
    PL_sv_root		= NULL;
    PL_sv_arenaroot	= NULL;
d11023 1
a11023 1
    SvPV_set(&PL_sv_no, savepvn(PL_No, 0));
d11034 1
a11034 1
    SvPV_set(&PL_sv_yes, savepvn(PL_Yes, 1));
d11057 5
a11061 11
    PL_compiling.cop_warnings = DUP_WARNINGS(PL_compiling.cop_warnings);
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
    PL_curcop		= (COP*)any_dup(proto_perl->Icurcop, proto_perl);
#ifdef PERL_DEBUG_READONLY_OPS
    PL_slabs = NULL;
    PL_slab_count = 0;
#endif
a11068 4
    /* Set tainting stuff before PerlIO_debug can possibly get called */
    PL_tainting		= proto_perl->Itainting;
    PL_taint_warn	= proto_perl->Itaint_warn;

a11090 1
    PL_minus_E		= proto_perl->Iminus_E;
d11109 1
a11112 2
#else
    PL_statusvalue_posix = proto_perl->Istatusvalue_posix;
a11119 6
   
    /* RE engine related */
    Zero(&PL_reg_state, 1, struct re_save_state);
    PL_reginterp_cnt	= 0;
    PL_regmatch_slab	= NULL;
    
d11124 1
a11124 1
	SV* const * const regexen = AvARRAY((AV*)proto_perl->Iregex_padav);
d11126 2
a11127 1
	av_push(PL_regex_padav, sv_dup_inc_NN(regexen[0],param));
d11129 9
a11137 11
	    const SV * const regex = regexen[i];
	    SV * const sv =
		SvREPADTMP(regex)
		    ? sv_dup_inc(regex, param)
		    : SvREFCNT_inc(
			newSViv(PTR2IV(CALLREGDUPE(
				INT2PTR(REGEXP *, SvIVX(regex)), param))))
		;
	    if (SvFLAGS(regex) & SVf_BREAK)
		SvFLAGS(sv) |= SVf_BREAK; /* unrefcnted PL_curpm */
	    av_push(PL_regex_padav, sv);
d11163 1
d11167 3
a11169 2
    PL_defstash		= hv_dup_inc(proto_perl->Idefstash, param);
    PL_curstash		= hv_dup(proto_perl->Icurstash, param);
a11176 2
    PL_unitcheckav      = av_dup_inc(proto_perl->Iunitcheckav, param);
    PL_unitcheckav_save = av_dup_inc(proto_perl->Iunitcheckav_save, param);
a11181 1
    PL_isarev		= hv_dup_inc(proto_perl->Iisarev, param);
d11190 2
d11196 1
a11196 2
	PL_op_mask 	= NULL;
    /* PL_asserting        = proto_perl->Iasserting; */
a11199 1
    OP_REFCNT_LOCK;
a11200 1
    OP_REFCNT_UNLOCK;
d11207 1
d11213 1
a11213 1
    PL_Cmd		= NULL;
d11215 1
d11219 1
a11219 1
    PL_mess_sv		= NULL;
d11222 1
a11231 16

    PL_my_cxt_size = proto_perl->Imy_cxt_size;
    if (PL_my_cxt_size) {
	Newx(PL_my_cxt_list, PL_my_cxt_size, void *);
	Copy(proto_perl->Imy_cxt_list, PL_my_cxt_list, PL_my_cxt_size, void *);
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
	Newx(PL_my_cxt_keys, PL_my_cxt_size, const char *);
	Copy(proto_perl->Imy_cxt_keys, PL_my_cxt_keys, PL_my_cxt_size, char *);
#endif
    }
    else {
	PL_my_cxt_list	= (void**)NULL;
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
	PL_my_cxt_keys	= (const char**)NULL;
#endif
    }
d11237 3
d11262 1
a11265 1
#ifdef PERL_USES_PL_PIDSTATUS
a11266 1
#endif
d11268 1
d11271 1
d11274 61
a11334 1
    PL_parser		= parser_dup(proto_perl->Iparser, param);
d11336 1
d11340 15
d11426 3
a11428 1
    PL_destroyhook	= proto_perl->Idestroyhook;
d11435 1
a11435 1
    PL_last_swash_hv	= NULL;	/* reinits on demand */
d11441 8
d11451 2
a11452 1
    PL_bitcount		= NULL;	/* reinits on demand */
d11474 1
a11474 1
    /* intrpvar.h stuff */
d11478 3
a11480 3
	PL_tmps_ix		= proto_perl->Itmps_ix;
	PL_tmps_max		= proto_perl->Itmps_max;
	PL_tmps_floor		= proto_perl->Itmps_floor;
d11484 1
a11484 1
	    PL_tmps_stack[i]	= sv_dup_inc(proto_perl->Itmps_stack[i], param);
d11489 1
a11489 1
	i = proto_perl->Imarkstack_max - proto_perl->Imarkstack;
d11491 5
a11495 5
	PL_markstack_max	= PL_markstack + (proto_perl->Imarkstack_max
						  - proto_perl->Imarkstack);
	PL_markstack_ptr	= PL_markstack + (proto_perl->Imarkstack_ptr
						  - proto_perl->Imarkstack);
	Copy(proto_perl->Imarkstack, PL_markstack,
d11500 2
a11501 2
	PL_scopestack_ix	= proto_perl->Iscopestack_ix;
	PL_scopestack_max	= proto_perl->Iscopestack_max;
d11503 8
a11510 1
	Copy(proto_perl->Iscopestack, PL_scopestack, PL_scopestack_ix, I32);
d11513 1
a11513 1
	PL_curstackinfo		= si_dup(proto_perl->Icurstackinfo, param);
d11516 2
a11517 2
	PL_curstack		= av_dup(proto_perl->Icurstack, param);
	PL_mainstack		= av_dup(proto_perl->Imainstack, param);
d11521 2
a11522 2
	PL_stack_sp		= PL_stack_base + (proto_perl->Istack_sp
						   - proto_perl->Istack_base);
d11527 2
a11528 2
	PL_savestack_ix		= proto_perl->Isavestack_ix;
	PL_savestack_max	= proto_perl->Isavestack_max;
d11541 3
a11543 3
	for (i = 0; i<= proto_perl->Itmps_ix; i++) {
	    SV * const nsv = (SV*)ptr_table_fetch(PL_ptr_table,
		    proto_perl->Itmps_stack[i]);
d11546 1
a11546 1
		PL_tmps_stack[++PL_tmps_ix] = SvREFCNT_inc_simple(nsv);
d11551 1
a11551 1
    PL_start_env	= proto_perl->Istart_env;	/* XXXXXX */
d11554 1
a11554 1
    PL_op		= proto_perl->Iop;
d11556 1
a11556 1
    PL_Sv		= NULL;
d11558 1
a11558 1
    PL_na		= proto_perl->Ina;
d11560 4
a11563 4
    PL_statbuf		= proto_perl->Istatbuf;
    PL_statcache	= proto_perl->Istatcache;
    PL_statgv		= gv_dup(proto_perl->Istatgv, param);
    PL_statname		= sv_dup_inc(proto_perl->Istatname, param);
d11565 1
a11565 1
    PL_timesbuf		= proto_perl->Itimesbuf;
d11568 32
a11599 28
    PL_tainted		= proto_perl->Itainted;
    PL_curpm		= proto_perl->Icurpm;	/* XXX No PMOP ref count */
    PL_rs		= sv_dup_inc(proto_perl->Irs, param);
    PL_last_in_gv	= gv_dup(proto_perl->Ilast_in_gv, param);
    PL_ofs_sv		= sv_dup_inc(proto_perl->Iofs_sv, param);
    PL_defoutgv		= gv_dup_inc(proto_perl->Idefoutgv, param);
    PL_chopset		= proto_perl->Ichopset;	/* XXX never deallocated */
    PL_toptarget	= sv_dup_inc(proto_perl->Itoptarget, param);
    PL_bodytarget	= sv_dup_inc(proto_perl->Ibodytarget, param);
    PL_formtarget	= sv_dup(proto_perl->Iformtarget, param);

    PL_restartop	= proto_perl->Irestartop;
    PL_in_eval		= proto_perl->Iin_eval;
    PL_delaymagic	= proto_perl->Idelaymagic;
    PL_dirty		= proto_perl->Idirty;
    PL_localizing	= proto_perl->Ilocalizing;

    PL_errors		= sv_dup_inc(proto_perl->Ierrors, param);
    PL_hv_fetch_ent_mh	= NULL;
    PL_modcount		= proto_perl->Imodcount;
    PL_lastgotoprobe	= NULL;
    PL_dumpindent	= proto_perl->Idumpindent;

    PL_sortcop		= (OP*)any_dup(proto_perl->Isortcop, proto_perl);
    PL_sortstash	= hv_dup(proto_perl->Isortstash, param);
    PL_firstgv		= gv_dup(proto_perl->Ifirstgv, param);
    PL_secondgv		= gv_dup(proto_perl->Isecondgv, param);
    PL_efloatbuf	= NULL;		/* reinits on demand */
d11607 1
a11607 1
    PL_lastscream	= NULL;
d11609 2
d11612 15
a11626 1
    PL_regdummy		= proto_perl->Iregdummy;
d11629 41
d11671 2
a11672 1

d11675 1
a11675 1
    PL_peepp		= proto_perl->Ipeepp;
a11678 10
    PL_watchaddr	= (char **) ptr_table_fetch(PL_ptr_table,
					    proto_perl->Iwatchaddr);
    PL_watchok		= PL_watchaddr ? * PL_watchaddr : NULL;
    if (PL_debug && PL_watchaddr) {
	PerlIO_printf(Perl_debug_log,
	  "WATCHING: %"UVxf" cloned as %"UVxf" with value %"UVxf"\n",
	  PTR2UV(proto_perl->Iwatchaddr), PTR2UV(PL_watchaddr),
	  PTR2UV(PL_watchok));
    }

d11695 1
a11695 1
	    XPUSHs(sv_2mortal(newSVhek(HvNAME_HEK(stash))));
d11707 1
a11707 1
	SvREFCNT_inc_simple_void(PL_compcv);
a11736 1
    dVAR;
d11749 1
a11749 1
/*
d11752 1
a11752 1
  for Encode::XS, while UTf-8 decode (currently) assumes a true value means
d11756 1
a11756 1

a11796 1
    dVAR;
a11822 488

}

/* ---------------------------------------------------------------------
 *
 * support functions for report_uninit()
 */

/* the maxiumum size of array or hash where we will scan looking
 * for the undefined element that triggered the warning */

#define FUV_MAX_SEARCH_SIZE 1000

/* Look for an entry in the hash whose value has the same SV as val;
 * If so, return a mortal copy of the key. */

STATIC SV*
S_find_hash_subscript(pTHX_ HV *hv, SV* val)
{
    dVAR;
    register HE **array;
    I32 i;

    if (!hv || SvMAGICAL(hv) || !HvARRAY(hv) ||
			(HvTOTALKEYS(hv) > FUV_MAX_SEARCH_SIZE))
	return NULL;

    array = HvARRAY(hv);

    for (i=HvMAX(hv); i>0; i--) {
	register HE *entry;
	for (entry = array[i]; entry; entry = HeNEXT(entry)) {
	    if (HeVAL(entry) != val)
		continue;
	    if (    HeVAL(entry) == &PL_sv_undef ||
		    HeVAL(entry) == &PL_sv_placeholder)
		continue;
	    if (!HeKEY(entry))
		return NULL;
	    if (HeKLEN(entry) == HEf_SVKEY)
		return sv_mortalcopy(HeKEY_sv(entry));
	    return sv_2mortal(newSVpvn(HeKEY(entry), HeKLEN(entry)));
	}
    }
    return NULL;
}

/* Look for an entry in the array whose value has the same SV as val;
 * If so, return the index, otherwise return -1. */

STATIC I32
S_find_array_subscript(pTHX_ AV *av, SV* val)
{
    dVAR;
    if (!av || SvMAGICAL(av) || !AvARRAY(av) ||
			(AvFILLp(av) > FUV_MAX_SEARCH_SIZE))
	return -1;

    if (val != &PL_sv_undef) {
	SV ** const svp = AvARRAY(av);
	I32 i;

	for (i=AvFILLp(av); i>=0; i--)
	    if (svp[i] == val)
		return i;
    }
    return -1;
}

/* S_varname(): return the name of a variable, optionally with a subscript.
 * If gv is non-zero, use the name of that global, along with gvtype (one
 * of "$", "@@", "%"); otherwise use the name of the lexical at pad offset
 * targ.  Depending on the value of the subscript_type flag, return:
 */

#define FUV_SUBSCRIPT_NONE	1	/* "@@foo"          */
#define FUV_SUBSCRIPT_ARRAY	2	/* "$foo[aindex]"  */
#define FUV_SUBSCRIPT_HASH	3	/* "$foo{keyname}" */
#define FUV_SUBSCRIPT_WITHIN	4	/* "within @@foo"   */

STATIC SV*
S_varname(pTHX_ GV *gv, const char gvtype, PADOFFSET targ,
	SV* keyname, I32 aindex, int subscript_type)
{

    SV * const name = sv_newmortal();
    if (gv) {
	char buffer[2];
	buffer[0] = gvtype;
	buffer[1] = 0;

	/* as gv_fullname4(), but add literal '^' for $^FOO names  */

	gv_fullname4(name, gv, buffer, 0);

	if ((unsigned int)SvPVX(name)[1] <= 26) {
	    buffer[0] = '^';
	    buffer[1] = SvPVX(name)[1] + 'A' - 1;

	    /* Swap the 1 unprintable control character for the 2 byte pretty
	       version - ie substr($name, 1, 1) = $buffer; */
	    sv_insert(name, 1, 1, buffer, 2);
	}
    }
    else {
	CV * const cv = find_runcv(NULL);
	SV *sv;
	AV *av;

	if (!cv || !CvPADLIST(cv))
	    return NULL;
	av = (AV*)(*av_fetch(CvPADLIST(cv), 0, FALSE));
	sv = *av_fetch(av, targ, FALSE);
	sv_setpvn(name, SvPV_nolen_const(sv), SvCUR(sv));
    }

    if (subscript_type == FUV_SUBSCRIPT_HASH) {
	SV * const sv = newSV(0);
	*SvPVX(name) = '$';
	Perl_sv_catpvf(aTHX_ name, "{%s}",
	    pv_display(sv,SvPVX_const(keyname), SvCUR(keyname), 0, 32));
	SvREFCNT_dec(sv);
    }
    else if (subscript_type == FUV_SUBSCRIPT_ARRAY) {
	*SvPVX(name) = '$';
	Perl_sv_catpvf(aTHX_ name, "[%"IVdf"]", (IV)aindex);
    }
    else if (subscript_type == FUV_SUBSCRIPT_WITHIN)
	Perl_sv_insert(aTHX_ name, 0, 0,  STR_WITH_LEN("within "));

    return name;
}


/*
=for apidoc find_uninit_var

Find the name of the undefined variable (if any) that caused the operator o
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if it's value matches uninit_sv.
So roughly speaking, if a unary operator (such as OP_COS) generates a
warning, then following the direct child of the op may yield an
OP_PADSV or OP_GV that gives the name of the undefined variable. On the
other hand, with OP_ADD there are two branches to follow, so we only print
the variable name if we get an exact match.

The name is returned as a mortal SV.

Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.

=cut
*/

STATIC SV *
S_find_uninit_var(pTHX_ OP* obase, SV* uninit_sv, bool match)
{
    dVAR;
    SV *sv;
    AV *av;
    GV *gv;
    OP *o, *o2, *kid;

    if (!obase || (match && (!uninit_sv || uninit_sv == &PL_sv_undef ||
			    uninit_sv == &PL_sv_placeholder)))
	return NULL;

    switch (obase->op_type) {

    case OP_RV2AV:
    case OP_RV2HV:
    case OP_PADAV:
    case OP_PADHV:
      {
	const bool pad  = (obase->op_type == OP_PADAV || obase->op_type == OP_PADHV);
	const bool hash = (obase->op_type == OP_PADHV || obase->op_type == OP_RV2HV);
	I32 index = 0;
	SV *keysv = NULL;
	int subscript_type = FUV_SUBSCRIPT_WITHIN;

	if (pad) { /* @@lex, %lex */
	    sv = PAD_SVl(obase->op_targ);
	    gv = NULL;
	}
	else {
	    if (cUNOPx(obase)->op_first->op_type == OP_GV) {
	    /* @@global, %global */
		gv = cGVOPx_gv(cUNOPx(obase)->op_first);
		if (!gv)
		    break;
		sv = hash ? (SV*)GvHV(gv): (SV*)GvAV(gv);
	    }
	    else /* @@{expr}, %{expr} */
		return find_uninit_var(cUNOPx(obase)->op_first,
						    uninit_sv, match);
	}

	/* attempt to find a match within the aggregate */
	if (hash) {
	    keysv = find_hash_subscript((HV*)sv, uninit_sv);
	    if (keysv)
		subscript_type = FUV_SUBSCRIPT_HASH;
	}
	else {
	    index = find_array_subscript((AV*)sv, uninit_sv);
	    if (index >= 0)
		subscript_type = FUV_SUBSCRIPT_ARRAY;
	}

	if (match && subscript_type == FUV_SUBSCRIPT_WITHIN)
	    break;

	return varname(gv, hash ? '%' : '@@', obase->op_targ,
				    keysv, index, subscript_type);
      }

    case OP_PADSV:
	if (match && PAD_SVl(obase->op_targ) != uninit_sv)
	    break;
	return varname(NULL, '$', obase->op_targ,
				    NULL, 0, FUV_SUBSCRIPT_NONE);

    case OP_GVSV:
	gv = cGVOPx_gv(obase);
	if (!gv || (match && GvSV(gv) != uninit_sv))
	    break;
	return varname(gv, '$', 0, NULL, 0, FUV_SUBSCRIPT_NONE);

    case OP_AELEMFAST:
	if (obase->op_flags & OPf_SPECIAL) { /* lexical array */
	    if (match) {
		SV **svp;
		av = (AV*)PAD_SV(obase->op_targ);
		if (!av || SvRMAGICAL(av))
		    break;
		svp = av_fetch(av, (I32)obase->op_private, FALSE);
		if (!svp || *svp != uninit_sv)
		    break;
	    }
	    return varname(NULL, '$', obase->op_targ,
		    NULL, (I32)obase->op_private, FUV_SUBSCRIPT_ARRAY);
	}
	else {
	    gv = cGVOPx_gv(obase);
	    if (!gv)
		break;
	    if (match) {
		SV **svp;
		av = GvAV(gv);
		if (!av || SvRMAGICAL(av))
		    break;
		svp = av_fetch(av, (I32)obase->op_private, FALSE);
		if (!svp || *svp != uninit_sv)
		    break;
	    }
	    return varname(gv, '$', 0,
		    NULL, (I32)obase->op_private, FUV_SUBSCRIPT_ARRAY);
	}
	break;

    case OP_EXISTS:
	o = cUNOPx(obase)->op_first;
	if (!o || o->op_type != OP_NULL ||
		! (o->op_targ == OP_AELEM || o->op_targ == OP_HELEM))
	    break;
	return find_uninit_var(cBINOPo->op_last, uninit_sv, match);

    case OP_AELEM:
    case OP_HELEM:
	if (PL_op == obase)
	    /* $a[uninit_expr] or $h{uninit_expr} */
	    return find_uninit_var(cBINOPx(obase)->op_last, uninit_sv, match);

	gv = NULL;
	o = cBINOPx(obase)->op_first;
	kid = cBINOPx(obase)->op_last;

	/* get the av or hv, and optionally the gv */
	sv = NULL;
	if  (o->op_type == OP_PADAV || o->op_type == OP_PADHV) {
	    sv = PAD_SV(o->op_targ);
	}
	else if ((o->op_type == OP_RV2AV || o->op_type == OP_RV2HV)
		&& cUNOPo->op_first->op_type == OP_GV)
	{
	    gv = cGVOPx_gv(cUNOPo->op_first);
	    if (!gv)
		break;
	    sv = o->op_type == OP_RV2HV ? (SV*)GvHV(gv) : (SV*)GvAV(gv);
	}
	if (!sv)
	    break;

	if (kid && kid->op_type == OP_CONST && SvOK(cSVOPx_sv(kid))) {
	    /* index is constant */
	    if (match) {
		if (SvMAGICAL(sv))
		    break;
		if (obase->op_type == OP_HELEM) {
		    HE* he = hv_fetch_ent((HV*)sv, cSVOPx_sv(kid), 0, 0);
		    if (!he || HeVAL(he) != uninit_sv)
			break;
		}
		else {
		    SV * const * const svp = av_fetch((AV*)sv, SvIV(cSVOPx_sv(kid)), FALSE);
		    if (!svp || *svp != uninit_sv)
			break;
		}
	    }
	    if (obase->op_type == OP_HELEM)
		return varname(gv, '%', o->op_targ,
			    cSVOPx_sv(kid), 0, FUV_SUBSCRIPT_HASH);
	    else
		return varname(gv, '@@', o->op_targ, NULL,
			    SvIV(cSVOPx_sv(kid)), FUV_SUBSCRIPT_ARRAY);
	}
	else  {
	    /* index is an expression;
	     * attempt to find a match within the aggregate */
	    if (obase->op_type == OP_HELEM) {
		SV * const keysv = find_hash_subscript((HV*)sv, uninit_sv);
		if (keysv)
		    return varname(gv, '%', o->op_targ,
						keysv, 0, FUV_SUBSCRIPT_HASH);
	    }
	    else {
		const I32 index = find_array_subscript((AV*)sv, uninit_sv);
		if (index >= 0)
		    return varname(gv, '@@', o->op_targ,
					NULL, index, FUV_SUBSCRIPT_ARRAY);
	    }
	    if (match)
		break;
	    return varname(gv,
		(o->op_type == OP_PADAV || o->op_type == OP_RV2AV)
		? '@@' : '%',
		o->op_targ, NULL, 0, FUV_SUBSCRIPT_WITHIN);
	}
	break;

    case OP_AASSIGN:
	/* only examine RHS */
	return find_uninit_var(cBINOPx(obase)->op_first, uninit_sv, match);

    case OP_OPEN:
	o = cUNOPx(obase)->op_first;
	if (o->op_type == OP_PUSHMARK)
	    o = o->op_sibling;

	if (!o->op_sibling) {
	    /* one-arg version of open is highly magical */

	    if (o->op_type == OP_GV) { /* open FOO; */
		gv = cGVOPx_gv(o);
		if (match && GvSV(gv) != uninit_sv)
		    break;
		return varname(gv, '$', 0,
			    NULL, 0, FUV_SUBSCRIPT_NONE);
	    }
	    /* other possibilities not handled are:
	     * open $x; or open my $x;	should return '${*$x}'
	     * open expr;		should return '$'.expr ideally
	     */
	     break;
	}
	goto do_op;

    /* ops where $_ may be an implicit arg */
    case OP_TRANS:
    case OP_SUBST:
    case OP_MATCH:
	if ( !(obase->op_flags & OPf_STACKED)) {
	    if (uninit_sv == ((obase->op_private & OPpTARGET_MY)
				 ? PAD_SVl(obase->op_targ)
				 : DEFSV))
	    {
		sv = sv_newmortal();
		sv_setpvn(sv, "$_", 2);
		return sv;
	    }
	}
	goto do_op;

    case OP_PRTF:
    case OP_PRINT:
    case OP_SAY:
	/* skip filehandle as it can't produce 'undef' warning  */
	o = cUNOPx(obase)->op_first;
	if ((obase->op_flags & OPf_STACKED) && o->op_type == OP_PUSHMARK)
	    o = o->op_sibling->op_sibling;
	goto do_op2;


    case OP_RV2SV:
    case OP_CUSTOM:
	match = 1; /* XS or custom code could trigger random warnings */
	goto do_op;

    case OP_ENTERSUB:
    case OP_GOTO:
	/* XXX tmp hack: these two may call an XS sub, and currently
	  XS subs don't have a SUB entry on the context stack, so CV and
	  pad determination goes wrong, and BAD things happen. So, just
	  don't try to determine the value under those circumstances.
	  Need a better fix at dome point. DAPM 11/2007 */
	break;

    case OP_POS:
	/* def-ness of rval pos() is independent of the def-ness of its arg */
	if ( !(obase->op_flags & OPf_MOD))
	    break;

    case OP_SCHOMP:
    case OP_CHOMP:
	if (SvROK(PL_rs) && uninit_sv == SvRV(PL_rs))
	    return sv_2mortal(newSVpvs("${$/}"));
	/*FALLTHROUGH*/

    default:
    do_op:
	if (!(obase->op_flags & OPf_KIDS))
	    break;
	o = cUNOPx(obase)->op_first;
	
    do_op2:
	if (!o)
	    break;

	/* if all except one arg are constant, or have no side-effects,
	 * or are optimized away, then it's unambiguous */
	o2 = NULL;
	for (kid=o; kid; kid = kid->op_sibling) {
	    if (kid) {
		const OPCODE type = kid->op_type;
		if ( (type == OP_CONST && SvOK(cSVOPx_sv(kid)))
		  || (type == OP_NULL  && ! (kid->op_flags & OPf_KIDS))
		  || (type == OP_PUSHMARK)
		)
		continue;
	    }
	    if (o2) { /* more than one found */
		o2 = NULL;
		break;
	    }
	    o2 = kid;
	}
	if (o2)
	    return find_uninit_var(o2, uninit_sv, match);

	/* scan all args */
	while (o) {
	    sv = find_uninit_var(o, uninit_sv, 1);
	    if (sv)
		return sv;
	    o = o->op_sibling;
	}
	break;
    }
    return NULL;
}


/*
=for apidoc report_uninit

Print appropriate "Use of uninitialized variable" warning

=cut
*/

void
Perl_report_uninit(pTHX_ SV* uninit_sv)
{
    dVAR;
    if (PL_op) {
	SV* varname = NULL;
	if (uninit_sv) {
	    varname = find_uninit_var(PL_op, uninit_sv,0);
	    if (varname)
		sv_insert(varname, 0, 0, " ", 1);
	}
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
		varname ? SvPV_nolen_const(varname) : "",
		" in ", OP_DESC(PL_op));
    }
    else
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit,
		    "", "", "");
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 3
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall
 *    and others
d9 1
a9 10
 */

/*
 * 'I wonder what the Entish is for "yes" and "no",' he thought.
 *                                                      --Pippin
 *
 *     [p.480 of _The Lord of the Rings_, III/iv: "Treebeard"]
 */

/*
d150 1
a150 1
 * ========================================================================= */
a161 3

    PERL_ARGS_ASSERT_OFFER_NICE_CHUNK;

a172 10
#ifdef PERL_MEM_LOG
#  define MEM_LOG_NEW_SV(sv, file, line, func)	\
	    Perl_mem_log_new_sv(sv, file, line, func)
#  define MEM_LOG_DEL_SV(sv, file, line, func)	\
	    Perl_mem_log_del_sv(sv, file, line, func)
#else
#  define MEM_LOG_NEW_SV(sv, file, line, func)	NOOP
#  define MEM_LOG_DEL_SV(sv, file, line, func)	NOOP
#endif

a174 3
#  define DEBUG_SV_SERIAL(sv)						    \
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) del_SV\n",    \
	    PTR2UV(sv), (long)(sv)->sv_debug_serial))
a176 1
#  define DEBUG_SV_SERIAL(sv)	NOOP
a180 1
#  define SvARENA_CHAIN_SET(sv,val)	(sv)->sv_u.svu_rv = MUTABLE_SV((val))
a188 1
#  define SvARENA_CHAIN_SET(sv,val)	SvANY(sv) = (void *)(val)
a191 7
/* Mark an SV head as unused, and add to free list.
 *
 * If SVf_BREAK is set, skip adding it to the free list, as this SV had
 * its refcount artificially decremented during global destruction, so
 * there may be dangling pointers to it. The last thing we want in that
 * case is for it to be reused. */

a193 3
	const U32 old_flags = SvFLAGS(p);			\
	MEM_LOG_DEL_SV(p, __FILE__, __LINE__, FUNCTION__);  \
	DEBUG_SV_SERIAL(p);				\
d196 1
d198 1
a198 4
	if (!(old_flags & SVf_BREAK)) {		\
	    SvARENA_CHAIN_SET(p, PL_sv_root);	\
	    PL_sv_root = (p);				\
	}						\
d205 1
a205 1
	PL_sv_root = MUTABLE_SV(SvARENA_CHAIN(p));		\
d237 1
a237 1
S_new_SV(pTHX_ const char *file, int line, const char *func)
d249 3
a251 3
    sv->sv_debug_line = (U16) (PL_parser && PL_parser->copline != NOLINE
		? PL_parser->copline
		:  PL_curcop
d254 2
a255 1
	    );
d259 1
a259 7

    sv->sv_debug_serial = PL_sv_serial++;

    MEM_LOG_NEW_SV(sv, file, line, func);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) new_SV (from %s:%d [%s])\n",
	    PTR2UV(sv), (long)sv->sv_debug_serial, file, line, func));

d262 1
a262 1
#  define new_SV(p) (p)=S_new_SV(aTHX_ __FILE__, __LINE__, FUNCTION__)
a273 1
	MEM_LOG_NEW_SV(p, __FILE__, __LINE__, FUNCTION__);  \
a293 3

    PERL_ARGS_ASSERT_DEL_SV;

d297 1
a297 1
	for (sva = PL_sv_arenaroot; sva; sva = MUTABLE_SV(SvANY(sva))) {
d338 1
a338 1
    SV *const sva = MUTABLE_SV(ptr);
a341 2
    PERL_ARGS_ASSERT_SV_ADD_ARENA;

d353 1
a353 1
	SvARENA_CHAIN_SET(sv, (sv + 1));
d362 1
a362 1
    SvARENA_CHAIN_SET(sv, 0);
d379 1
a379 3
    PERL_ARGS_ASSERT_VISIT;

    for (sva = PL_sv_arenaroot; sva; sva = MUTABLE_SV(SvANY(sva))) {
a508 4
    if (sv == (const SV *) PL_fdpid || sv == (const SV *)PL_strtab) {
	/* don't clean pid table and strtab */
	return;
    }
d592 1
a592 1
	svanext = MUTABLE_SV(SvANY(sva));
d594 1
a594 1
	    svanext = MUTABLE_SV(SvANY(svanext));
d728 1
a728 1
consequently don't need to actually exist.  They are declared because
d733 1
a733 1
For these types, the arenas are carved up into appropriately sized
d736 1
a736 1
size of the part not allocated, so it's as if we allocated the full
d741 6
a746 10
We calculate the correction using the STRUCT_OFFSET macro on the first
member present. If the allocated structure is smaller (no initial NV
actually allocated) then the net effect is to subtract the size of the NV
from the pointer, to return a new pointer as if an initial NV were actually
allocated. (We were using structures named *_allocated for this, but
this turned out to be a subtle bug, because a structure without an NV
could have a lower alignment constraint, but the compiler is allowed to
optimised accesses based on the alignment constraint of the actual pointer
to the full structure, for example, using a single 64 bit load instruction
because it "knows" that two adjacent 32 bit members will be 8-byte aligned.)
d780 1
a780 1
"ghost fields", and is used in *_allocated macros.
d784 1
a784 1
vs the implementation in 5.8.8, making it table-driven.  All fields
d846 20
d872 1
a872 1
	+ sizeof (((type*)SvANY((const SV *)0))->last_member)
d901 5
a905 5
    { sizeof(XPV) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XPV, xpv_len) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_PV, FALSE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPV) - STRUCT_OFFSET(XPV, xpv_cur)) },
d908 5
a912 5
    { sizeof(XPVIV) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XPVIV, xiv_u) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPVIV, xpv_cur),
      SVt_PVIV, FALSE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPV) - STRUCT_OFFSET(XPV, xpv_cur)) },
d930 11
a940 11
    { sizeof(XPVAV) - STRUCT_OFFSET(XPVAV, xav_fill),
      copy_length(XPVAV, xmg_stash) - STRUCT_OFFSET(XPVAV, xav_fill),
      + STRUCT_OFFSET(XPVAV, xav_fill),
      SVt_PVAV, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVAV) - STRUCT_OFFSET(XPVAV, xav_fill)) },

    { sizeof(XPVHV) - STRUCT_OFFSET(XPVHV, xhv_fill),
      copy_length(XPVHV, xmg_stash) - STRUCT_OFFSET(XPVHV, xhv_fill),
      + STRUCT_OFFSET(XPVHV, xhv_fill),
      SVt_PVHV, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVHV) - STRUCT_OFFSET(XPVHV, xhv_fill)) },
d943 7
a949 11
    { sizeof(XPVCV) - STRUCT_OFFSET(XPVCV, xpv_cur),
      sizeof(XPVCV) - STRUCT_OFFSET(XPVCV, xpv_cur),
      + STRUCT_OFFSET(XPVCV, xpv_cur),
      SVt_PVCV, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XPVCV) - STRUCT_OFFSET(XPVCV, xpv_cur)) },

    { sizeof(XPVFM) - STRUCT_OFFSET(XPVFM, xpv_cur),
      sizeof(XPVFM) - STRUCT_OFFSET(XPVFM, xpv_cur),
      + STRUCT_OFFSET(XPVFM, xpv_cur),
      SVt_PVFM, TRUE, NONV, NOARENA,
      FIT_ARENA(20, sizeof(XPVFM) - STRUCT_OFFSET(XPVFM, xpv_cur)) },
a1032 1
    const size_t arena_size = Perl_malloc_good_size(bdp->arena_size);
d1050 1
a1050 1
    start = (char*) Perl_get_arena(aTHX_ arena_size, sv_type);
d1052 1
a1052 1
    end = start + arena_size - 2 * body_size;
a1054 8
#if defined(MYMALLOC) || defined(HAS_MALLOC_GOOD_SIZE)
    DEBUG_m(PerlIO_printf(Perl_debug_log,
			  "arena %p end %p arena-size %d (from %d) type %d "
			  "size %d ct %d\n",
			  (void*)start, (void*)end, (int)arena_size,
			  (int)bdp->arena_size, sv_type, (int)body_size,
			  (int)arena_size / (int)body_size));
#else
d1060 1
a1060 1
#endif
d1063 1
a1063 1
    while (start <= end) {
a1118 2
    PERL_ARGS_ASSERT_SV_UPGRADE;

d1126 5
a1210 5

    if (old_type > new_type)
	Perl_croak(aTHX_ "sv_upgrade from type %d down to type %d",
		(int)old_type, (int)new_type);

a1255 21
	    if (old_type_details->body_size) {
		AvALLOC(sv) = 0;
	    } else {
		/* It will have been zeroed when the new body was allocated.
		   Lets not write to it, in case it confuses a write-back
		   cache.  */
	    }
	} else {
	    assert(!SvOK(sv));
	    SvOK_off(sv);
#ifndef NODEFAULT_SHAREKEYS
	    HvSHAREKEYS_on(sv);         /* key-sharing on by default */
#endif
	    HvMAX(sv) = 7; /* (start with 8 buckets) */
	    if (old_type_details->body_size) {
		HvFILL(sv) = 0;
	    } else {
		/* It will have been zeroed when the new body was allocated.
		   Lets not write to it, in case it confuses a write-back
		   cache.  */
	    }
a1366 1
    PERL_ARGS_ASSERT_SV_BACKOFF;
a1367 1

a1372 10
#ifdef DEBUGGING
	/* Validate the preceding buffer's sentinels to verify that no-one is
	   using it.  */
	const U8 *p = (const U8*) s;
	const U8 *const real_start = p - SvIVX(sv);
	while (p > real_start) {
	    --p;
	    assert (*p == (U8)PTR2UV(p));
	}
#endif
a1396 2
    PERL_ARGS_ASSERT_SV_GROW;

a1427 1
#ifndef Perl_safesysmalloc_size
d1429 7
a1436 1
	if (SvLEN(sv) && s) {
a1445 6
#ifdef Perl_safesysmalloc_size
	/* Do this here, do it once, do it right, and then we will never get
	   called back into sv_grow() unless there really is some growing
	   needed.  */
	SvLEN_set(sv, Perl_safesysmalloc_size(s));
#else
a1446 1
#endif
a1463 3

    PERL_ARGS_ASSERT_SV_SETIV;

d1467 2
d1470 1
a1470 1
	sv_upgrade(sv, SVt_IV);
a1477 2
	if (!isGV_with_GP(sv))
	    break;
a1502 2
    PERL_ARGS_ASSERT_SV_SETIV_MG;

a1518 2
    PERL_ARGS_ASSERT_SV_SETUV;

a1546 2
    PERL_ARGS_ASSERT_SV_SETUV_MG;

a1563 3

    PERL_ARGS_ASSERT_SV_SETNV;

a1576 2
	if (!isGV_with_GP(sv))
	    break;
a1601 2
    PERL_ARGS_ASSERT_SV_SETNV_MG;

a1617 2
     PERL_ARGS_ASSERT_NOT_A_NUMBER;

d1619 1
a1619 1
          dsv = newSVpvs_flags("", SVs_TEMP);
a1696 2
    PERL_ARGS_ASSERT_LOOKS_LIKE_NUMBER;

a1713 2
    PERL_ARGS_ASSERT_GLOB_2NUMBER;

a1734 2
    PERL_ARGS_ASSERT_GLOB_2PV;

d1833 1
a1833 5
S_sv_2iuv_non_preserve(pTHX_ register SV *sv
#  ifdef DEBUGGING
		       , I32 numtype
#  endif
		       )
d1836 1
a1836 3

    PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE;

d1882 1
a1882 2
S_sv_2iuv_common(pTHX_ SV *sv)
{
a1883 3

    PERL_ARGS_ASSERT_SV_2IUV_COMMON;

d1917 1
a1917 5
		if (SvNOK(sv))
		    SvIOK_on(sv);  /* Can this go wrong with rounding? NWC */
		else {
		    /* scalar has trailing garbage, eg "42a" */
		}
a1955 1
		&& SvNOK(sv)
a2108 1
#  ifdef DEBUGGING
a2109 3
#  else
                    sv_2iuv_non_preserve (sv);
#  endif
a2112 6
	/* It might be more code efficient to go through the entire logic above
	   and conditionally set with SvIOKp_on() rather than SvIOK(), but it
	   gets complex and potentially buggy, so more programmer efficient
	   to do it this way, by turning off the public flags:  */
	if (!numtype)
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK);
d2117 1
a2117 1
	    return glob_2number(MUTABLE_GV(sv));
d2381 1
a2381 4
	if (SvIOK(sv))
	    SvNOK_on(sv);
	else
	    SvNOKp_on(sv);
d2385 1
a2385 2
	if (SvIOK(sv) &&
	    SvIsUV(sv) ? ((SvUVX(sv) != UV_MAX)&&(SvUVX(sv) == U_V(SvNVX(sv))))
d2404 1
a2404 4
	if (numtype)
	    SvNOK_on(sv);
	else
	    SvNOKp_on(sv);
a2470 6
	/* It might be more code efficient to go through the entire logic above
	   and conditionally set with SvNOKp_on() rather than SvNOK(), but it
	   gets complex and potentially buggy, so more programmer efficient
	   to do it this way, by turning off the public flags:  */
	if (!numtype)
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK);
d2475 1
a2475 1
	    glob_2number(MUTABLE_GV(sv));
a2517 2
    PERL_ARGS_ASSERT_SV_2NUM;

a2541 2
    PERL_ARGS_ASSERT_UIV_2BUF;

d2668 1
a2668 1
		SV *const referent = SvRV(sv);
d2780 1
a2780 1
	dSAVE_ERRNO;
d2794 1
a2794 1
	RESTORE_ERRNO;
d2809 1
a2809 1
	    return glob_2pv(MUTABLE_GV(sv), lp);
a2854 3

    PERL_ARGS_ASSERT_SV_COPYPV;

a2876 2
    PERL_ARGS_ASSERT_SV_2PVBYTE;

a2894 2
    PERL_ARGS_ASSERT_SV_2PVUTF8;

a2912 3

    PERL_ARGS_ASSERT_SV_2BOOL;

a2955 1
Will C<mg_get> on C<sv> if appropriate.
d2957 1
a2957 2
if the whole string is the same in UTF-8 as not.
Returns the number of bytes in the converted string
a2961 4
=for apidoc sv_utf8_upgrade_nomg

Like sv_utf8_upgrade, but doesn't do magic on C<sv>

d2967 2
a2968 4
if all the bytes are invariant in UTF-8. If C<flags> has C<SV_GMAGIC> bit set,
will C<mg_get> on C<sv> if appropriate, else not.
Returns the number of bytes in the converted string
C<sv_utf8_upgrade> and
a2980 3

    PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS;

d3006 1
a3006 1
	 * had a FLAG in SVs to signal if there are any variant
d3015 1
a3015 1
	    /* Check for variant */
d3017 1
a3017 9
		STRLEN len = SvCUR(sv);
		/* *Currently* bytes_to_utf8() adds a '\0' after every string
		   it converts. This isn't documented. It's not clear if it's
		   a bad thing to be doing, and should be changed to do exactly
		   what the documentation says. If so, this code will have to
		   be changed.
		   As is, we mustn't rely on our incoming SV being well formed
		   and having a trailing '\0', as certain code in pp_formline
		   can send us partially built SVs. */
d3022 2
a3023 2
		SvCUR_set(sv, len);
		SvLEN_set(sv, len + 1); /* No longer know the real size. */
d3027 1
a3027 1
	/* Mark as UTF-8 even if no variant - saves scanning loop */
d3037 1
a3037 2
If the PV contains a character that cannot fit
in a byte, this conversion will fail;
a3050 3

    PERL_ARGS_ASSERT_SV_UTF8_DOWNGRADE;

a3089 2
    PERL_ARGS_ASSERT_SV_UTF8_ENCODE;

d3094 1
a3094 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
a3114 2
    PERL_ARGS_ASSERT_SV_UTF8_DECODE;

a3182 2
    PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB;

d3201 2
a3202 2
	    Perl_sv_add_backref(aTHX_ MUTABLE_SV(GvSTASH(dstr)), dstr);
	gv_name_set(MUTABLE_GV(dstr), name, len, GV_ADD);
d3207 2
a3208 2
    if (GvUNIQUE((const GV *)dstr)) {
	Perl_croak(aTHX_ "%s", PL_no_modify);
d3212 1
a3212 1
    if(GvGP(MUTABLE_GV(sstr))) {
d3221 1
a3221 1
        else if(GvCV((const GV *)sstr)) {
d3227 1
a3227 1
    if(!mro_changes && GvGP(MUTABLE_GV(dstr)) && GvCVu((const GV *)dstr)) {
d3231 1
a3231 1
    if(strEQ(GvNAME((const GV *)dstr),"ISA"))
d3234 1
a3234 1
    gp_free(MUTABLE_GV(dstr));
d3254 1
a3254 2
S_glob_assign_ref(pTHX_ SV *dstr, SV *sstr)
{
a3260 1
    bool mro_changes = FALSE;
a3261 1
    PERL_ARGS_ASSERT_GLOB_ASSIGN_REF;
d3264 2
a3265 2
    if (GvUNIQUE((const GV *)dstr)) {
	Perl_croak(aTHX_ "%s", PL_no_modify);
d3272 1
a3272 1
	GvEGV(dstr) = MUTABLE_GV(dstr);
a3285 2
        if (strEQ(GvNAME((GV*)dstr), "ISA"))
	    mro_changes = TRUE;
a3292 1
	goto common;
d3299 1
a3299 1
		/*if (GvCVGEN(dstr) && (GvCV(dstr) != (const CV *)sref || GvCVGEN(dstr))) {*/
d3311 1
a3311 1
	    CV* const cv = MUTABLE_CV(*location);
d3313 1
a3313 1
		if (!GvCVGEN((const GV *)dstr) &&
d3318 1
a3318 1
			if (CvCONST(cv)	&& CvCONST((const CV *)sref)
d3330 1
a3330 1
				     && (!CvCONST((const CV *)sref)
d3338 2
a3339 2
					HvNAME_get(GvSTASH((const GV *)dstr)),
					GvENAME(MUTABLE_GV(dstr)));
d3343 1
a3343 1
		    cv_ckproto_len(cv, (const GV *)dstr,
a3360 1
    if (mro_changes) mro_isa_changed_in(GvSTASH(dstr));
a3371 2
    PERL_ARGS_ASSERT_SV_SETSV_FLAGS;

d3394 1
d3549 1
a3549 1
	    && SvTYPE(SvRV(sstr)) == SVt_PVGV && isGV_with_GP(SvRV(sstr))) {
d3591 1
a3591 1
	    if (dstr != (const SV *)gv) {
d3593 1
a3593 1
		    gp_free(MUTABLE_GV(dstr));
d3678 6
d3726 1
d3783 1
a3783 1
	    gv_efullname3(dstr, MUTABLE_GV(sstr), "*");
a3803 2
    PERL_ARGS_ASSERT_SV_SETSV_MG;

a3815 2
    PERL_ARGS_ASSERT_SV_SETSV_COW;

a3892 2
    PERL_ARGS_ASSERT_SV_SETPVN;

a3924 2
    PERL_ARGS_ASSERT_SV_SETPVN_MG;

a3943 2
    PERL_ARGS_ASSERT_SV_SETPV;

a3969 2
    PERL_ARGS_ASSERT_SV_SETPV_MG;

a3998 3

    PERL_ARGS_ASSERT_SV_USEPVN_FLAGS;

d4016 1
a4016 6
	? len + 1 :
#ifdef Perl_safesysmalloc_size
	len + 1;
#else 
	PERL_STRLEN_ROUNDUP(len + 1);
#endif
d4032 2
a4033 3
#ifdef Perl_safesysmalloc_size
    SvLEN_set(sv, Perl_safesysmalloc_size(ptr));
#else
a4034 3
#endif
    SvCUR_set(sv, len);
    SvPV_set(sv, ptr);
a4052 2
    PERL_ARGS_ASSERT_SV_RELEASE_COW;

a4099 3

    PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS;

d4102 1
d4142 2
a4143 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
d4160 1
a4160 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
a4185 4
    STRLEN max_delta;

    PERL_ARGS_ASSERT_SV_CHOP;

a4188 11
    if (!delta) {
	/* Nothing to do.  */
	return;
    }
    /* SvPVX(sv) may move in SV_CHECK_THINKFIRST(sv), but after this line,
       nothing uses the value of ptr any more.  */
    max_delta = SvLEN(sv) ? SvLEN(sv) : SvCUR(sv);
    if (ptr <= SvPVX_const(sv))
	Perl_croak(aTHX_ "panic: sv_chop ptr=%p, start=%p, end=%p",
		   ptr, SvPVX_const(sv), SvPVX_const(sv) + max_delta);
    assert(ptr > SvPVX_const(sv));
a4189 1

a4192 6
    if (delta > max_delta)
	Perl_croak(aTHX_ "panic: sv_chop ptr=%p (was %p), start=%p, end=%p",
		   SvPVX_const(sv) + delta, ptr, SvPVX_const(sv),
		   SvPVX_const(sv) + max_delta);


a4211 12
#ifdef DEBUGGING
    {
	/* Fill the preceding buffer with sentinals to verify that no-one is
	   using it.  */
	U8 *p = (U8*) SvPVX(sv);
	const U8 *const real_start = p - SvIVX(sv);
	while (p > real_start) {
	    --p;
	    *p = (U8)PTR2UV(p);
	}
    }
#endif
a4240 2
    PERL_ARGS_ASSERT_SV_CATPVN_FLAGS;

d4273 1
a4273 4
 
    PERL_ARGS_ASSERT_SV_CATSV_FLAGS;

   if (ssv) {
d4294 1
a4294 1
		    SV* const csv = newSVpvn_flags(spv, slen, SVs_TEMP);
a4325 2
    PERL_ARGS_ASSERT_SV_CATPV;

a4349 2
    PERL_ARGS_ASSERT_SV_CATPV_MG;

a4409 2
    PERL_ARGS_ASSERT_SV_MAGICEXT;

d4429 3
a4431 3
	    (GvSV(obj) == sv || GvHV(obj) == (const HV *)sv
	     || GvAV(obj) == (const AV *)sv || GvCV(obj) == (const CV *)sv
	     || GvIOp(obj) == (const IO *)sv || GvFORM(obj) == (const CV *)sv)))
d4449 1
a4449 1
        obj && SvROK(obj) && GvIO(SvRV(obj)) == (const IO *)sv)
d4459 3
a4461 7
	else if (namlen == HEf_SVKEY) {
	    /* Yes, this is casting away const. This is only for the case of
	       HEf_SVKEY. I think we need to document this abberation of the
	       constness of the API, rather than making name non-const, as
	       that change propagating outwards a long way.  */
	    mg->mg_ptr = (char*)SvREFCNT_inc_simple_NN((SV *)name);
	} else
a4493 2
    PERL_ARGS_ASSERT_SV_MAGIC;

d4512 1
a4512 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
a4676 3

    PERL_ARGS_ASSERT_SV_UNMAGIC;

d4690 1
a4690 1
		    SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
a4725 3

    PERL_ARGS_ASSERT_SV_RVWEAKEN;

a4745 18
/* A discussion about the backreferences array and its refcount:
 *
 * The AV holding the backreferences is pointed to either as the mg_obj of
 * PERL_MAGIC_backref, or in the specific case of a HV that has the hv_aux
 * structure, from the xhv_backreferences field. (A HV without hv_aux will
 * have the standard magic instead.) The array is created with a refcount
 * of 2. This means that if during global destruction the array gets
 * picked on first to have its refcount decremented by the random zapper,
 * it won't actually be freed, meaning it's still theere for when its
 * parent gets freed.
 * When the parent SV is freed, in the case of magic, the magic is freed,
 * Perl_magic_killbackrefs is called which decrements one refcount, then
 * mg_obj is freed which kills the second count.
 * In the vase of a HV being freed, one ref is removed by
 * Perl_hv_kill_backrefs, the other by Perl_sv_kill_backrefs, which it
 * calls.
 */

a4751 2
    PERL_ARGS_ASSERT_SV_ADD_BACKREF;

d4753 1
a4753 1
	AV **const avp = Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
d4762 1
a4762 1
		av = MUTABLE_AV(mg->mg_obj);
d4772 1
a4772 1
		SvREFCNT_inc_simple_void(av); /* see discussion above */
d4780 1
a4780 1
	    av = MUTABLE_AV(mg->mg_obj);
d4784 4
a4787 2
	    sv_magic(tsv, MUTABLE_SV(av), PERL_MAGIC_backref, NULL, 0);
	    /* av now has a refcnt of 2; see discussion above */
a4807 2
    PERL_ARGS_ASSERT_SV_DEL_BACKREF;

d4809 1
a4809 1
	av = *Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
d4819 1
a4819 1
	    av = MUTABLE_AV(mg->mg_obj);
d4821 3
a4823 2

    if (!av)
d4825 1
d4827 2
a4828 1
    assert(!SvIS_FREED(av));
a4854 1
    PERL_ARGS_ASSERT_SV_KILL_BACKREFS;
d4857 3
a4859 2
    assert(!svp || !SvIS_FREED(av));
    if (svp) {
d4875 1
a4875 1
		    assert(GvSTASH(referrer) == (const HV *)sv);
d4896 1
a4896 5
the Perl substr() function. Handles get magic.

=for apidoc sv_insert_flags

Same as C<sv_insert>, but the extra C<flags> are passed the C<SvPV_force_flags> that applies to C<bigstr>.
d4902 1
a4902 1
Perl_sv_insert_flags(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen, const U32 flags)
a4911 1
    PERL_ARGS_ASSERT_SV_INSERT_FLAGS;
d4915 1
a4915 1
    SvPV_force_flags(bigstr, curlen, flags);
a4967 1
	Move(big, midend - i, i, char);
d4969 3
a5003 3

    PERL_ARGS_ASSERT_SV_REPLACE;

d5091 1
a5091 1
    PERL_ARGS_ASSERT_SV_CLEAR;
a5092 1
    assert(SvTYPE(sv) != SVTYPEMASK);
d5111 1
a5111 5
		if (destructor
			/* Don't bother calling an empty destructor */
			&& (CvISXSUB(destructor)
			|| CvSTART(destructor)->op_next->op_type != OP_LEAVESUB))
		{
d5120 1
a5120 1
		    call_sv(MUTABLE_SV(destructor), G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
d5169 1
a5169 1
	    io_close(MUTABLE_IO(sv), FALSE);
d5180 1
a5180 1
	cv_undef(MUTABLE_CV(sv));
d5183 2
a5184 5
	if (PL_last_swash_hv == (const HV *)sv) {
	    PL_last_swash_hv = NULL;
	}
	Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
	hv_undef(MUTABLE_HV(sv));
d5187 1
a5187 1
	if (PL_comppad == MUTABLE_AV(sv)) {
d5191 1
a5191 1
	av_undef(MUTABLE_AV(sv));
d5203 1
a5203 2
            if(GvCVu((const GV *)sv) && (stash = GvSTASH(MUTABLE_GV(sv)))
	       && HvNAME_get(stash))
d5205 1
a5205 1
	    gp_free(MUTABLE_GV(sv));
d5211 1
a5211 1
		    sv_del_backref(MUTABLE_SV(stash), sv);
d5216 1
a5216 1
	if ((const GV *)sv == PL_last_in_gv)
d5239 2
d5251 1
d5330 3
d5337 1
a5337 1
	    sv_dump(sv);
a5338 11
#ifdef DEBUG_LEAKING_SCALARS_ABORT
	    if (PL_warnhook == PERL_WARNHOOK_FATAL
		|| ckDEAD(packWARN(WARN_INTERNAL))) {
		/* Don't let Perl_warner cause us to escape our fate:  */
		abort();
	    }
#endif
	    /* This may not return:  */
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                        "Attempt to free unreferenced scalar: SV 0x%"UVxf
                        pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
a5340 3
#ifdef DEBUG_LEAKING_SCALARS_ABORT
	abort();
#endif
a5351 3

    PERL_ARGS_ASSERT_SV_FREE2;

d5405 1
a5405 1
 * The length is cached in PERL_MAGIC_utf8, in the mg_len field.  Also the
a5470 2
    PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS;

a5488 3

    PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY;

d5515 1
a5515 2
		    STRLEN uoffset0, STRLEN boffset0)
{
a5518 2
    PERL_ARGS_ASSERT_SV_POS_U2B_CACHED;

d5606 1
a5606 2
    if (PL_utf8cache)
	utf8_mg_pos_cache_update(sv, mgp, boffset, uoffset, send - start);
d5625 1
a5625 1
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
a5635 2
    PERL_ARGS_ASSERT_SV_POS_U2B;

a5695 3

    PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE;

a5834 2
    PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY;

d5861 1
a5861 1
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
a5875 2
    PERL_ARGS_ASSERT_SV_POS_B2U;

d5952 1
a5952 2
    if (PL_utf8cache)
	utf8_mg_pos_cache_update(sv, &mg, byte, len, blen);
d5986 2
a5987 1
	    sv1 = newSVpvn_flags(pv1, cur1, SVs_TEMP | SvUTF8(sv2));
d6144 1
a6144 1
if necessary.  See also C<sv_cmp>.
a6219 2
    PERL_ARGS_ASSERT_SV_COLLXFRM;

d6230 5
a6286 2
    PERL_ARGS_ASSERT_SV_GETS;

a6343 3
#ifdef VMS
      int fd;
#endif
d6355 1
a6355 7
      fd = PerlIO_fileno(fp);
      if (fd == -1) { /* in-memory file from PerlIO::Scalar */
          bytesread = PerlIO_read(fp, buffer, recsize);
      }
      else {
          bytesread = PerlLIO_read(fd, buffer, recsize);
      }
d6361 1
a6361 1
      SvCUR_set(sv, bytesread + append);
d6646 1
a6646 1
		Perl_croak(aTHX_ "%s", PL_no_modify);
d6802 1
a6802 1
		Perl_croak(aTHX_ "%s", PL_no_modify);
a6942 34

/*
=for apidoc newSVpvn_flags

Creates a new SV and copies a string into it.  The reference count for the
SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length
string.  You are responsible for ensuring that the source string is at least
C<len> bytes long.  If the C<s> argument is NULL the new SV will be undefined.
Currently the only flag bits accepted are C<SVf_UTF8> and C<SVs_TEMP>.
If C<SVs_TEMP> is set, then C<sv2mortal()> is called on the result before
returning. If C<SVf_UTF8> is set, then it will be set on the new SV.
C<newSVpvn_utf8()> is a convenience wrapper for this function, defined as

    #define newSVpvn_utf8(s, len, u)			\
	newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

=cut
*/

SV *
Perl_newSVpvn_flags(pTHX_ const char *s, STRLEN len, U32 flags)
{
    dVAR;
    register SV *sv;

    /* All the flags we don't support must be zero.
       And we're new code so I'm going to assert this from the start.  */
    assert(!(flags & ~(SVf_UTF8|SVs_TEMP)));
    new_SV(sv);
    sv_setpvn(sv,s,len);
    SvFLAGS(sv) |= (flags & SVf_UTF8);
    return (flags & SVs_TEMP) ? sv_2mortal(sv) : sv;
}

d7012 1
a7116 2
    /* The logic for this is inlined in S_mro_get_linear_isa_dfs(), so if it
       changes here, update it there too.  */
a7144 3

    PERL_ARGS_ASSERT_NEWSVPVF_NOCONTEXT;

a7165 3

    PERL_ARGS_ASSERT_NEWSVPVF;

a7178 3

    PERL_ARGS_ASSERT_VNEWSVPVF;

a7276 3

    PERL_ARGS_ASSERT_NEWRV_NOINC;

a7290 3

    PERL_ARGS_ASSERT_NEWRV;

a7338 2
    PERL_ARGS_ASSERT_SV_RESET;

d7343 1
a7343 1
	MAGIC * const mg = mg_find((const SV *)stash, PERL_MAGIC_symtab);
d7388 1
a7388 1
		gv = MUTABLE_GV(HeVAL(entry));
a7440 2
    PERL_ARGS_ASSERT_SV_2IO;

d7443 1
a7443 1
	io = MUTABLE_IO(sv);
d7446 5
a7450 8
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	    io = GvIO(gv);
	    if (!io)
		Perl_croak(aTHX_ "Bad filehandle: %s", GvNAME(gv));
	    break;
	}
	/* FALL THROUGH */
a7484 2
    PERL_ARGS_ASSERT_SV_2CV;

d7494 1
a7494 1
	return MUTABLE_CV(sv);
d7501 4
a7504 7
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	    *gvp = gv;
	    *st = GvESTASH(gv);
	    goto fix_gv;
	}
	/* FALL THROUGH */
d7507 1
a7509 1
	    SvGETMAGIC(sv);
d7514 1
a7514 1
		cv = MUTABLE_CV(sv);
d7519 2
a7520 2
	    else if(isGV_with_GP(sv))
		gv = MUTABLE_GV(sv);
d7524 2
a7525 4
	else if (isGV_with_GP(sv)) {
	    SvGETMAGIC(sv);
	    gv = MUTABLE_GV(sv);
	}
d7527 1
a7527 1
	    gv = gv_fetchsv(sv, lref, SVt_PVCV); /* Calls get magic */
d7534 1
a7534 1
	if (!isGV_with_GP(gv)) {
d7554 1
a7554 1
			   SVfARG(SvOK(sv) ? sv : &PL_sv_no));
a7618 3

    PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS;

d7638 1
a7638 2
	if ((SvTYPE(sv) > SVt_PVLV && SvTYPE(sv) != SVt_PVFM)
	    || isGV_with_GP(sv))
a7674 2
    PERL_ARGS_ASSERT_SV_PVBYTEN_FORCE;

a7691 2
    PERL_ARGS_ASSERT_SV_PVUTF8N_FORCE;

a7708 2
    PERL_ARGS_ASSERT_SV_REFTYPE;

d7740 1
a7740 2
	case SVt_PVGV:		return (char *) (isGV_with_GP(sv)
				    ? "GLOB" : "SCALAR");
d7767 1
a7767 1
    sv = SvRV(sv);
a7786 3

    PERL_ARGS_ASSERT_SV_ISA;

d7792 1
a7792 1
    sv = SvRV(sv);
a7818 2
    PERL_ARGS_ASSERT_NEWSVRV;

d7834 6
a7839 2
    } else {
	prepare_SV_for_RV(rv);
a7874 3

    PERL_ARGS_ASSERT_SV_SETREF_PV;

a7898 2
    PERL_ARGS_ASSERT_SV_SETREF_IV;

a7917 2
    PERL_ARGS_ASSERT_SV_SETREF_UV;

a7936 2
    PERL_ARGS_ASSERT_SV_SETREF_NV;

a7958 2
    PERL_ARGS_ASSERT_SV_SETREF_PVN;

a7977 3

    PERL_ARGS_ASSERT_SV_BLESS;

d7985 1
a7985 1
	    Perl_croak(aTHX_ "%s", PL_no_modify);
d7996 1
a7996 1
    SvSTASH_set(tmpRef, MUTABLE_HV(SvREFCNT_inc_simple(stash)));
a8022 2
    PERL_ARGS_ASSERT_SV_UNGLOB;

d8025 1
a8025 1
    gv_efullname3(temp, MUTABLE_GV(sv), "*");
d8028 1
a8028 2
        if(GvCVu((const GV *)sv) && (stash = GvSTASH(MUTABLE_GV(sv)))
	   && HvNAME_get(stash))
d8030 1
a8030 1
	gp_free(MUTABLE_GV(sv));
d8033 1
a8033 1
	sv_del_backref(MUTABLE_SV(GvSTASH(sv)), sv);
a8074 2
    PERL_ARGS_ASSERT_SV_UNREF_FLAGS;

a8100 2
    PERL_ARGS_ASSERT_SV_UNTAINT;

a8117 2
    PERL_ARGS_ASSERT_SV_TAINTED;

a8141 2
    PERL_ARGS_ASSERT_SV_SETPVIV;

a8155 2
    PERL_ARGS_ASSERT_SV_SETPVIV_MG;

a8171 3

    PERL_ARGS_ASSERT_SV_SETPVF_NOCONTEXT;

a8186 3

    PERL_ARGS_ASSERT_SV_SETPVF_MG_NOCONTEXT;

a8205 3

    PERL_ARGS_ASSERT_SV_SETPVF;

a8224 2
    PERL_ARGS_ASSERT_SV_VSETPVF;

a8239 3

    PERL_ARGS_ASSERT_SV_SETPVF_MG;

a8257 2
    PERL_ARGS_ASSERT_SV_VSETPVF_MG;

a8273 3

    PERL_ARGS_ASSERT_SV_CATPVF_NOCONTEXT;

a8288 3

    PERL_ARGS_ASSERT_SV_CATPVF_MG_NOCONTEXT;

a8311 3

    PERL_ARGS_ASSERT_SV_CATPVF;

a8330 2
    PERL_ARGS_ASSERT_SV_VCATPVF;

a8345 3

    PERL_ARGS_ASSERT_SV_CATPVF_MG;

a8363 2
    PERL_ARGS_ASSERT_SV_VCATPVF_MG;

d8382 1
a8382 3
    PERL_ARGS_ASSERT_SV_VSETPVFN;

    sv_setpvs(sv, "");
a8390 3

    PERL_ARGS_ASSERT_EXPECT_NUMBER;

a8411 2
    PERL_ARGS_ASSERT_F0CONVERT;

a8474 1
    PERL_ARGS_ASSERT_SV_VCATPVFN;
d8495 1
a8495 1
	argsv = MUTABLE_SV(va_arg(*args, void*));
d8652 1
a8652 1
		    argsv = MUTABLE_SV(va_arg(*args, void*));
d8772 1
a8772 1
		    if ( hv_exists(MUTABLE_HV(SvRV(vecsv)), "alpha", 5 ) ) {
d8941 1
a8941 1
		    STRLEN old_precis = precis;
d8943 1
a8943 2
			STRLEN ulen = sv_len_utf8(argsv);
			I32 p = precis > ulen ? ulen : precis;
d8958 1
a8958 1
	    if (has_precis && precis < elen)
d9446 1
a9446 1
		SV * const nsv = newSVpvn_flags(eptr, elen, SVs_TEMP);
d9460 1
a9460 1
	    Perl_croak_nocontext("%s", PL_memory_wrap);
d9466 1
a9466 1
	    Perl_croak_nocontext("%s", PL_memory_wrap);
d9531 1
a9531 1
 * =========================================================================*/
d9547 10
a9556 10
#define av_dup(s,t)	MUTABLE_AV(sv_dup((const SV *)s,t))
#define av_dup_inc(s,t)	MUTABLE_AV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
#define hv_dup(s,t)	MUTABLE_HV(sv_dup((const SV *)s,t))
#define hv_dup_inc(s,t)	MUTABLE_HV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
#define cv_dup(s,t)	MUTABLE_CV(sv_dup((const SV *)s,t))
#define cv_dup_inc(s,t)	MUTABLE_CV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
#define io_dup(s,t)	MUTABLE_IO(sv_dup((const SV *)s,t))
#define io_dup_inc(s,t)	MUTABLE_IO(SvREFCNT_inc(sv_dup((const SV *)s,t)))
#define gv_dup(s,t)	MUTABLE_GV(sv_dup((const SV *)s,t))
#define gv_dup_inc(s,t)	MUTABLE_GV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
a9566 2
    PERL_ARGS_ASSERT_PARSER_DUP;

a9672 4

    /* XXX should clone saved_curcop here, but we aren't passed
     * proto_perl; so do it in perl_clone_using instead */

a9683 1
    PERL_ARGS_ASSERT_FP_DUP;
a9718 2
    PERL_ARGS_ASSERT_GP_DUP;

d9731 1
a9731 2
    /* ret->gp_refcnt must be 0 before any other dups are called. We're relying
       on Newxz() to do this for us.  */
a9751 3

    PERL_ARGS_ASSERT_MG_DUP;

d9771 1
a9771 1
	    nmg->mg_obj	= MUTABLE_SV(CALLREGDUPE((REGEXP*)mg->mg_obj, param));
d9776 1
a9776 2
	    nmg->mg_obj
		= SvREFCNT_inc(av_dup_inc((const AV *) mg->mg_obj, param));
d9800 1
a9800 1
		nmg->mg_ptr = (char*)sv_dup_inc((const SV *)mg->mg_ptr, param);
d9841 1
a9841 2
S_ptr_table_find(PTR_TBL_t *tbl, const void *sv)
{
d9844 1
a9844 3

    PERL_ARGS_ASSERT_PTR_TABLE_FIND;

a9856 2

    PERL_ARGS_ASSERT_PTR_TABLE_FETCH;
a9857 1

a9866 2

    PERL_ARGS_ASSERT_PTR_TABLE_STORE;
a9894 2

    PERL_ARGS_ASSERT_PTR_TABLE_SPLIT;
a9959 2
    PERL_ARGS_ASSERT_RVPV_DUP;

d9962 2
a9963 2
		       ? sv_dup(SvRV_const(sstr), param)
		       : sv_dup_inc(SvRV_const(sstr), param));
d9991 1
a9991 1
		SvPV_set(dstr, (char *) SvPVX_const(sstr));		
d10012 1
a10012 8
    PERL_ARGS_ASSERT_SV_DUP;

    if (!sstr)
	return NULL;
    if (SvTYPE(sstr) == SVTYPEMASK) {
#ifdef DEBUG_LEAKING_SCALARS_ABORT
	abort();
#endif
a10013 1
    }
d10015 1
a10015 1
    dstr = MUTABLE_SV(ptr_table_fetch(PL_ptr_table, sstr));
d10026 1
a10026 1
		return MUTABLE_SV(gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname), 0));
d10091 1
a10091 1
		if (GvUNIQUE((const GV *)sstr)) {
d10159 1
a10159 1
		    LvTARG(dstr) = MUTABLE_SV(he_dup((HE*)LvTARG(dstr), 0, param));
d10164 2
a10165 1
		    GvNAME_HEK(dstr) = hek_dup(GvNAME_HEK(dstr), param);
d10207 1
a10207 2
		/* avoid cloning an empty array */
		if (AvARRAY((const AV *)sstr) && AvFILLp((const AV *)sstr) >= 0) {
d10209 1
a10209 1
		    SSize_t items = AvFILLp((const AV *)sstr) + 1;
d10211 2
a10212 2
		    src_ary = AvARRAY((const AV *)sstr);
		    Newxz(dst_ary, AvMAX((const AV *)sstr)+1, SV*);
d10214 3
a10216 3
		    AvARRAY(MUTABLE_AV(dstr)) = dst_ary;
		    AvALLOC((const AV *)dstr) = dst_ary;
		    if (AvREAL((const AV *)sstr)) {
d10224 1
a10224 1
		    items = AvMAX((const AV *)sstr) - AvFILLp((const AV *)sstr);
d10230 2
a10231 4
		    AvARRAY(MUTABLE_AV(dstr))	= NULL;
		    AvALLOC(MUTABLE_AV(dstr))	= (SV**)NULL;
		    AvMAX(  MUTABLE_AV(dstr))	= -1;
		    AvFILLp(MUTABLE_AV(dstr))	= -1;
d10235 1
a10235 1
		if (HvARRAY((const HV *)sstr)) {
d10260 1
a10260 1
			daux->xhv_name = hek_dup(hvname, param);
a10265 1
			/* backref array needs refcnt=2; see sv_add_backref */
d10268 2
a10269 2
			    ? MUTABLE_AV(SvREFCNT_inc(
						      sv_dup_inc((const SV *)saux->xhv_backreferences, param)))
d10282 1
a10282 1
		    HvARRAY(MUTABLE_HV(dstr)) = NULL;
d10298 1
a10298 1
			sv_dup_inc((const SV *)CvXSUBANY(dstr).any_ptr, param);
a10328 2
    PERL_ARGS_ASSERT_CX_DUP;

d10338 1
a10338 1
    Newx(ncxs, max + 1, PERL_CONTEXT);
a10339 1
    Copy(cxs, ncxs, max + 1, PERL_CONTEXT);
d10342 1
d10344 2
a10345 1
	if (CxTYPE(ncx) == CXt_SUBST) {
d10349 7
a10355 1
	    switch (CxTYPE(ncx)) {
d10357 5
a10361 6
		ncx->blk_sub.cv		= (ncx->blk_sub.olddepth == 0
					   ? cv_dup_inc(ncx->blk_sub.cv, param)
					   : cv_dup(ncx->blk_sub.cv,param));
		ncx->blk_sub.argarray	= (CxHASARGS(ncx)
					   ? av_dup_inc(ncx->blk_sub.argarray,
							param)
d10363 5
a10367 2
		ncx->blk_sub.savearray	= av_dup_inc(ncx->blk_sub.savearray,
						     param);
d10369 1
a10369 1
					   ncx->blk_sub.oldcomppad);
d10372 6
a10377 3
		ncx->blk_eval.old_namesv = sv_dup_inc(ncx->blk_eval.old_namesv,
						      param);
		ncx->blk_eval.cur_text	= sv_dup(ncx->blk_eval.cur_text, param);
d10380 6
a10385 4
		ncx->blk_loop.iterdata	= (CxPADLOOP(ncx)
					   ? ncx->blk_loop.iterdata
					   : gv_dup((const GV *)ncx->blk_loop.iterdata,
						    param));
d10388 6
a10393 5
					    ncx->blk_loop.oldcomppad);
		ncx->blk_loop.iterlval	= sv_dup_inc(ncx->blk_loop.iterlval,
						     param);
		ncx->blk_loop.iterary	= av_dup_inc(ncx->blk_loop.iterary,
						     param);
d10396 5
a10400 4
		ncx->blk_sub.cv		= cv_dup(ncx->blk_sub.cv, param);
		ncx->blk_sub.gv		= gv_dup(ncx->blk_sub.gv, param);
		ncx->blk_sub.dfoutgv	= gv_dup_inc(ncx->blk_sub.dfoutgv,
						     param);
a10418 2
    PERL_ARGS_ASSERT_SI_DUP;

a10471 2
    PERL_ARGS_ASSERT_ANY_DUP;

d10500 4
a10503 4
    const SV *sv;
    const GV *gv;
    const AV *av;
    const HV *hv;
a10513 2
    PERL_ARGS_ASSERT_SS_DUP;

d10521 1
a10521 1
	    sv = (const SV *)POPPTR(ss,ix);
d10526 1
a10526 1
	    sv = (const SV *)POPPTR(ss,ix);
d10531 1
a10531 1
	    sv = (const SV *)POPPTR(ss,ix);
d10542 1
a10542 1
	    sv = (const SV *)POPPTR(ss,ix);
d10549 1
a10549 1
	    sv = (const SV *) POPPTR(ss,ix);
d10554 1
a10554 1
	    sv = (const SV *) POPPTR(ss,ix);
d10591 1
a10591 1
	    sv = (const SV *)POPPTR(ss,ix);
d10611 1
a10611 1
	    gv = (const GV *)POPPTR(ss,ix);
d10640 4
d10645 1
a10645 1
	    hv = (const HV *)POPPTR(ss,ix);
a10646 4
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    /* Fall through */
	case SAVEt_FREEPV:
d10649 1
a10649 1
	    break;
d10677 1
a10677 1
	    sv = (const SV *)POPPTR(ss,ix);
d10681 1
a10681 1
	    av = (const AV *)POPPTR(ss,ix);
d10699 1
a10699 1
		hv = (const HV *)POPPTR(ss,ix);
d10703 1
a10703 1
	case SAVEt_PADSV_AND_MORTALIZE:
d10708 2
a10709 2
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
d10722 1
a10722 1
	    sv = (const SV *)POPPTR(ss,ix);
d10792 1
a10792 13
	    TOPPTR(nss,ix) = ptr ? 
		    parser_dup((const yy_parser*)ptr, param) : NULL;
	    break;
	case SAVEt_PADSV:
	    /* Nothing should be using this any more, post the integration of
	       blead change 33080. But keep it, in case something out there is
	       generating these on the scope stack.  */
	    longval = (long)POPLONG(ss,ix);
	    TOPLONG(nss,ix) = longval;
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = any_dup(ptr, proto_perl);
	    sv = (SV*)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup(sv, param);
d10811 1
a10811 1
    const HEK * const hvname = HvNAME_HEK((const HV *)sv);
d10813 1
a10813 1
	GV* const cloner = gv_fetchmethod_autoload(MUTABLE_HV(sv), "CLONE_SKIP", 0);
d10822 1
a10822 1
	    mXPUSHs(newSVhek(hvname));
d10824 1
a10824 1
	    call_sv(MUTABLE_SV(GvCV(cloner)), G_SCALAR);
a10884 2
    PERL_ARGS_ASSERT_PERL_CLONE;

a10919 3

    PERL_ARGS_ASSERT_PERL_CLONE_USING;

a10954 3

    PERL_ARGS_ASSERT_PERL_CLONE;

d11121 3
a11123 3
    sv_setpvs(PERL_DEBUG_PAD(0), "");	/* For regex debugging. */
    sv_setpvs(PERL_DEBUG_PAD(1), "");	/* ext/re needs these */
    sv_setpvs(PERL_DEBUG_PAD(2), "");	/* even without DEBUGGING. */
d11297 1
a11297 9
    PL_parser		= proto_perl->Iparser ?
			    parser_dup(proto_perl->Iparser, param): NULL;

    /* XXX this only works if the saved cop has already been cloned */
    if (proto_perl->Iparser) {
	PL_parser->saved_curcop = (COP*)any_dup(
				    proto_perl->Iparser->saved_curcop,
				    proto_perl);
    }
d11471 2
a11472 2
	    SV * const nsv = MUTABLE_SV(ptr_table_fetch(PL_ptr_table,
		    proto_perl->Itmps_stack[i]));
d11556 4
a11559 1
    PL_registered_mros  = hv_dup_inc(proto_perl->Iregistered_mros, param);
d11565 1
a11565 1
	HV* const stash = MUTABLE_HV(av_shift(param->stashes));
d11572 1
a11572 1
	    mXPUSHs(newSVhek(HvNAME_HEK(stash)));
d11574 1
a11574 1
	    call_sv(MUTABLE_SV(GvCV(cloner)), G_DISCARD);
a11579 6
    if (!(flags & CLONEf_KEEP_PTR_TABLE)) {
        ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;
    }


a11614 3

    PERL_ARGS_ASSERT_SV_RECODE_TO_UTF8;

a11676 3

    PERL_ARGS_ASSERT_SV_CAT_DECODE;

d11688 2
a11689 3
	offsv = newSViv(*offset);
	mXPUSHs(offsv);
	mXPUSHp(tstr, tlen);
a11724 2
    PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT;

d11743 1
a11743 1
	    return sv_2mortal(newSVhek(HeKEY_hek(entry)));
a11755 3

    PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT;

d11813 1
a11813 1
	av = MUTABLE_AV((*av_fetch(CvPADLIST(cv), 0, FALSE)));
d11829 2
a11830 4
    else if (subscript_type == FUV_SUBSCRIPT_WITHIN) {
	/* We know that name has no magic, so can use 0 instead of SV_GMAGIC */
	Perl_sv_insert_flags(aTHX_ name, 0, 0,  STR_WITH_LEN("within "), 0);
    }
d11892 1
a11892 1
		sv = hash ? MUTABLE_SV(GvHV(gv)): MUTABLE_SV(GvAV(gv));
d11906 1
a11906 1
	    index = find_array_subscript((AV *)sv, uninit_sv);
d11934 1
a11934 1
		av = MUTABLE_AV(PAD_SV(obase->op_targ));
d11990 1
a11990 2
	    sv = o->op_type
		== OP_RV2HV ? MUTABLE_SV(GvHV(gv)) : MUTABLE_SV(GvAV(gv));
d12001 1
a12001 1
		    HE* he = hv_fetch_ent(MUTABLE_HV(sv), cSVOPx_sv(kid), 0, 0);
d12006 1
a12006 1
		    SV * const * const svp = av_fetch(MUTABLE_AV(sv), SvIV(cSVOPx_sv(kid)), FALSE);
d12028 1
a12028 2
		const I32 index
		    = find_array_subscript((AV *)sv, uninit_sv);
d12079 1
a12079 1
		sv_setpvs(sv, "$_");
a12087 1
	match = 1; /* print etc can return undef on defined args */
a12094 1
    case OP_ENTEREVAL: /* could be eval $undef or $x='$undef'; eval $x */
d12096 2
a12097 75
    case OP_CUSTOM: /* XS or custom code could trigger random warnings */

	/* the following ops are capable of returning PL_sv_undef even for
	 * defined arg(s) */

    case OP_BACKTICK:
    case OP_PIPE_OP:
    case OP_FILENO:
    case OP_BINMODE:
    case OP_TIED:
    case OP_GETC:
    case OP_SYSREAD:
    case OP_SEND:
    case OP_IOCTL:
    case OP_SOCKET:
    case OP_SOCKPAIR:
    case OP_BIND:
    case OP_CONNECT:
    case OP_LISTEN:
    case OP_ACCEPT:
    case OP_SHUTDOWN:
    case OP_SSOCKOPT:
    case OP_GETPEERNAME:
    case OP_FTRREAD:
    case OP_FTRWRITE:
    case OP_FTREXEC:
    case OP_FTROWNED:
    case OP_FTEREAD:
    case OP_FTEWRITE:
    case OP_FTEEXEC:
    case OP_FTEOWNED:
    case OP_FTIS:
    case OP_FTZERO:
    case OP_FTSIZE:
    case OP_FTFILE:
    case OP_FTDIR:
    case OP_FTLINK:
    case OP_FTPIPE:
    case OP_FTSOCK:
    case OP_FTBLK:
    case OP_FTCHR:
    case OP_FTTTY:
    case OP_FTSUID:
    case OP_FTSGID:
    case OP_FTSVTX:
    case OP_FTTEXT:
    case OP_FTBINARY:
    case OP_FTMTIME:
    case OP_FTATIME:
    case OP_FTCTIME:
    case OP_READLINK:
    case OP_OPEN_DIR:
    case OP_READDIR:
    case OP_TELLDIR:
    case OP_SEEKDIR:
    case OP_REWINDDIR:
    case OP_CLOSEDIR:
    case OP_GMTIME:
    case OP_ALARM:
    case OP_SEMGET:
    case OP_GETLOGIN:
    case OP_UNDEF:
    case OP_SUBSTR:
    /* case OP_AEACH: not in 5.10.x */
    case OP_EACH:
    case OP_SORT:
    case OP_CALLER:
    case OP_DOFILE:
    case OP_PROTOTYPE:
    case OP_NCMP:
    case OP_SMARTMATCH:
    case OP_UNPACK:
    case OP_SYSOPEN:
    case OP_SYSSEEK:
	match = 1;
a12108 1

d12117 1
a12117 1
	    return newSVpvs_flags("${$/}", SVs_TEMP);
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d167 1
a167 1
Perl_offer_nice_chunk(pTHX_ void *const chunk, const U32 chunk_size)
d356 4
a359 3
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			     "Attempt to free non-arena SV: 0x%"UVxf
			     pTHX__FORMAT, PTR2UV(p) pTHX__VALUE);
d384 2
a385 2
static void
S_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags)
d425 1
a425 1
S_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask)
d454 1
a454 1
do_report_used(pTHX_ SV *const sv)
d484 1
a484 1
do_clean_objs(pTHX_ SV *const ref)
d511 1
a511 1
do_clean_named_objs(pTHX_ SV *const sv)
d560 1
a560 1
do_clean_all(pTHX_ SV *const sv)
d611 1
a611 1
    svtype	utype;		/* bodytype stored in arena */
d724 1
a724 1
Perl_get_arena(pTHX_ const size_t arena_size, const svtype bodytype)
d753 1
a753 1
    adesc->utype = bodytype;
d939 3
d963 1
a963 9

    /* something big */
    { sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur),
      sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur),
      + STRUCT_OFFSET(regexp, xpv_cur),
      SVt_REGEXP, FALSE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur))
    },

d998 2
a999 5
    { sizeof(XPVIO) - STRUCT_OFFSET(XPVIO, xpv_cur),
      sizeof(XPVIO) - STRUCT_OFFSET(XPVIO, xpv_cur),
      + STRUCT_OFFSET(XPVIO, xpv_cur),
      SVt_PVIO, TRUE, NONV, HASARENA,
      FIT_ARENA(24, sizeof(XPVIO) - STRUCT_OFFSET(XPVIO, xpv_cur)) },
d1071 1
a1071 1
S_more_bodies (pTHX_ const svtype sv_type)
d1143 1
a1143 1
S_new_body(pTHX_ const svtype sv_type)
a1152 3
static const struct body_details fake_rv =
    { 0, 0, 0, SVt_IV, FALSE, NONV, NOARENA, 0 };

d1164 1
a1164 1
Perl_sv_upgrade(pTHX_ register SV *const sv, svtype new_type)
d1171 1
a1171 1
    const struct body_details *old_type_details
a1172 1
    SV *referant = NULL;
a1175 12
    if (old_type == new_type)
	return;

    /* This clause was purposefully added ahead of the early return above to
       the shared string hackery for (sort {$a <=> $b} keys %hash), with the
       inference by Nick I-S that it would fix other troublesome cases. See
       changes 7162, 7163 (f130fd4589cf5fbb24149cd4db4137c8326f49c1 and parent)

       Given that shared hash key scalars are no longer PVIV, but PV, there is
       no longer need to unshare so as to free up the IVX slot for its proper
       purpose. So it's safe to move the early return earlier.  */

d1180 3
d1227 3
a1229 10
	if (SvROK(sv)) {
	    referant = SvRV(sv);
	    old_type_details = &fake_rv;
	    if (new_type == SVt_NV)
		new_type = SVt_PVNV;
	} else {
	    if (new_type < SVt_PVIV) {
		new_type = (new_type == SVt_NV)
		    ? SVt_PVNV : SVt_PVIV;
	    }
d1237 2
d1287 5
d1340 1
a1340 3
	if (old_type == SVt_IV) {
	    assert(!SvROK(sv));
	} else if (old_type >= SVt_PV) {
a1352 4
    case SVt_REGEXP:
	/* This ensures that SvTHINKFIRST(sv) is true, and hence that
	   sv_force_normal_flags(sv) is called.  */
	SvFAKE_on(sv);
d1409 1
a1409 10
	if (new_type == SVt_PVIO) {
	    IO * const io = MUTABLE_IO(sv);
	    GV *iogv = gv_fetchpvs("IO::File::", GV_ADD, SVt_PVHV);

	    SvOBJECT_on(io);
	    /* Clear the stashcache because a new IO could overrule a package
	       name */
	    hv_clear(PL_stashcache);

	    SvSTASH_set(io, MUTABLE_HV(SvREFCNT_inc(GvHV(iogv))));
d1411 2
a1412 6
	}
	if (old_type < SVt_PV) {
	    /* referant will be NULL unless the old type was SVt_IV emulating
	       SVt_RV */
	    sv->sv_u.svu_rv = referant;
	}
d1419 5
a1423 1
    if (old_type > SVt_IV) { /* SVt_IVs are overloaded for PTEs */
a1426 4
	/* Note that there is an assumption that all bodies of types that
	   can be upgraded came from arenas. Only the more complex non-
	   upgradable types are allowed to be directly malloc()ed.  */
	assert(old_type_details->arena);
d1443 1
a1443 1
Perl_sv_backoff(pTHX_ register SV *const sv)
a1444 3
    STRLEN delta;
    const char * const s = SvPVX_const(sv);

d1451 17
a1467 6

    SvOOK_offset(sv, delta);
    
    SvLEN_set(sv, SvLEN(sv) + delta);
    SvPV_set(sv, SvPVX(sv) - delta);
    Move(s, SvPVX(sv), SvCUR(sv)+1, char);
d1483 1
a1483 1
Perl_sv_grow(pTHX_ register SV *const sv, register STRLEN newlen)
d1555 1
a1555 1
Perl_sv_setiv(pTHX_ register SV *const sv, const IV i)
d1567 1
d1598 1
a1598 1
Perl_sv_setiv_mg(pTHX_ register SV *const sv, const IV i)
d1616 1
a1616 1
Perl_sv_setuv(pTHX_ register SV *const sv, const UV u)
d1646 1
a1646 1
Perl_sv_setuv_mg(pTHX_ register SV *const sv, const UV u)
d1664 1
a1664 1
Perl_sv_setnv(pTHX_ register SV *const sv, const NV num)
d1676 1
d1708 1
a1708 1
Perl_sv_setnv_mg(pTHX_ register SV *const sv, const NV num)
d1721 1
a1721 1
S_not_a_number(pTHX_ SV *const sv)
d1804 1
a1804 1
Perl_looks_like_number(pTHX_ SV *const sv)
d1845 21
d1951 1
a1951 1
S_sv_2iuv_non_preserve(pTHX_ register SV *const sv
d2006 1
a2006 1
S_sv_2iuv_common(pTHX_ SV *const sv)
d2286 1
a2286 1
Perl_sv_2iv_flags(pTHX_ register SV *const sv, const I32 flags)
d2370 1
a2370 1
Perl_sv_2uv_flags(pTHX_ register SV *const sv, const I32 flags)
d2447 1
a2447 1
Perl_sv_2nv(pTHX_ register SV *const sv)
d2672 1
a2672 1
Perl_sv_2num(pTHX_ register SV *const sv)
d2694 1
a2694 1
S_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)
d2733 1
a2733 1
Perl_sv_2pv_flags(pTHX_ register SV *const sv, STRLEN *const lp, const I32 flags)
d2827 1
d2833 16
a2848 20
		} else if (SvTYPE(referent) == SVt_REGEXP) {
		    REGEXP * const re = (REGEXP *)MUTABLE_PTR(referent);
		    I32 seen_evals = 0;

		    assert(re);
			
		    /* If the regex is UTF-8 we want the containing scalar to
		       have an UTF-8 flag too */
		    if (RX_UTF8(re))
			SvUTF8_on(sv);
		    else
			SvUTF8_off(sv);	

		    if ((seen_evals = RX_SEEN_EVALS(re)))
			PL_reginterp_cnt += seen_evals;

		    if (lp)
			*lp = RX_WRAPLEN(re);
 
		    return RX_WRAPPED(re);
d2914 2
a2917 4
	    if (flags & SV_UNDEF_RETURNS_NULL)
		return NULL;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(sv);
d2968 2
a2969 23
	if (isGV_with_GP(sv)) {
	    GV *const gv = MUTABLE_GV(sv);
	    const U32 wasfake = SvFLAGS(gv) & SVf_FAKE;
	    SV *const buffer = sv_newmortal();

	    /* FAKE globs can get coerced, so need to turn this off temporarily
	       if it is on.  */
	    SvFAKE_off(gv);
	    gv_efullname3(buffer, gv, "*");
	    SvFLAGS(gv) |= wasfake;

	    if (SvPOK(buffer)) {
		if (lp) {
		    *lp = SvCUR(buffer);
		}
		return SvPVX(buffer);
	    }
	    else {
		if (lp)
		    *lp = 0;
		return (char *)"";
	    }
	}
d2971 2
a2974 4
	if (flags & SV_UNDEF_RETURNS_NULL)
	    return NULL;
	if (!PL_localizing && !(SvFLAGS(sv) & SVs_PADTMP) && ckWARN(WARN_UNINITIALIZED))
	    report_uninit(sv);
d3011 1
a3011 1
Perl_sv_copypv(pTHX_ SV *const dsv, register SV *const ssv)
d3038 1
a3038 1
Perl_sv_2pvbyte(pTHX_ register SV *const sv, STRLEN *const lp)
d3058 1
a3058 1
Perl_sv_2pvutf8(pTHX_ register SV *const sv, STRLEN *const lp)
d3077 1
a3077 1
Perl_sv_2bool(pTHX_ register SV *const sv)
a3152 30

The grow version is currently not externally documented.  It adds a parameter,
extra, which is the number of unused bytes the string of 'sv' is guaranteed to
have free after it upon return.  This allows the caller to reserve extra space
that it intends to fill, to avoid extra grows.

Also externally undocumented for the moment is the flag SV_FORCE_UTF8_UPGRADE,
which can be used to tell this function to not first check to see if there are
any characters that are different in UTF-8 (variant characters) which would
force it to allocate a new string to sv, but to assume there are.  Typically
this flag is used by a routine that has already parsed the string to find that
there are such characters, and passes this information on so that the work
doesn't have to be repeated.

(One might think that the calling routine could pass in the position of the
first such variant, so it wouldn't have to be found again.  But that is not the
case, because typically when the caller is likely to use this flag, it won't be
calling this routine unless it finds something that won't fit into a byte.
Otherwise it tries to not upgrade and just use bytes.  But some things that
do fit into a byte are variants in utf8, and the caller may not have been
keeping track of these.)

If the routine itself changes the string, it adds a trailing NUL.  Such a NUL
isn't guaranteed due to having other routines do the work in some input cases,
or if the input is already flagged as being in utf8.

The speed of this could perhaps be improved for many cases if someone wanted to
write a fast function that counts the number of variant characters in a string,
especially if it could return the position of the first one.

d3156 1
a3156 1
Perl_sv_utf8_upgrade_flags_grow(pTHX_ register SV *const sv, const I32 flags, STRLEN extra)
d3160 1
a3160 1
    PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS_GROW;
d3168 1
a3168 2
	    if (SvUTF8(sv)) {
		if (extra) SvGROW(sv, SvCUR(sv) + extra);
a3169 1
	    }
a3175 1
	if (extra) SvGROW(sv, SvCUR(sv) + extra);
d3183 1
a3183 1
    if (PL_encoding && !(flags & SV_UTF8_NO_ENCODING)) {
d3185 1
a3185 7
	if (extra) SvGROW(sv, SvCUR(sv) + extra);
	return SvCUR(sv);
    }

    if (SvCUR(sv) == 0) {
	if (extra) SvGROW(sv, extra);
    } else { /* Assume Latin-1/EBCDIC */
d3189 4
a3192 6
	 * make the loop as fast as possible (although there are certainly ways
	 * to speed this up, eg. through vectorization) */
	U8 * s = (U8 *) SvPVX_const(sv);
	U8 * e = (U8 *) SvEND(sv);
	U8 *t = s;
	STRLEN two_byte_count = 0;
a3193 6
	if (flags & SV_FORCE_UTF8_UPGRADE) goto must_be_utf8;

	/* See if really will need to convert to utf8.  We mustn't rely on our
	 * incoming SV being well formed and having a trailing '\0', as certain
	 * code in pp_formline can send us partially built SVs. */

d3196 12
a3207 1
	    if (NATIVE_IS_INVARIANT(ch)) continue;
d3209 6
a3214 3
	    t--;    /* t already incremented; re-point to first variant */
	    two_byte_count = 1;
	    goto must_be_utf8;
d3216 1
a3216 3

	/* utf8 conversion not needed because all are invariants.  Mark as
	 * UTF-8 even if no variant - saves scanning loop */
a3217 159
	return SvCUR(sv);

must_be_utf8:

	/* Here, the string should be converted to utf8, either because of an
	 * input flag (two_byte_count = 0), or because a character that
	 * requires 2 bytes was found (two_byte_count = 1).  t points either to
	 * the beginning of the string (if we didn't examine anything), or to
	 * the first variant.  In either case, everything from s to t - 1 will
	 * occupy only 1 byte each on output.
	 *
	 * There are two main ways to convert.  One is to create a new string
	 * and go through the input starting from the beginning, appending each
	 * converted value onto the new string as we go along.  It's probably
	 * best to allocate enough space in the string for the worst possible
	 * case rather than possibly running out of space and having to
	 * reallocate and then copy what we've done so far.  Since everything
	 * from s to t - 1 is invariant, the destination can be initialized
	 * with these using a fast memory copy
	 *
	 * The other way is to figure out exactly how big the string should be
	 * by parsing the entire input.  Then you don't have to make it big
	 * enough to handle the worst possible case, and more importantly, if
	 * the string you already have is large enough, you don't have to
	 * allocate a new string, you can copy the last character in the input
	 * string to the final position(s) that will be occupied by the
	 * converted string and go backwards, stopping at t, since everything
	 * before that is invariant.
	 *
	 * There are advantages and disadvantages to each method.
	 *
	 * In the first method, we can allocate a new string, do the memory
	 * copy from the s to t - 1, and then proceed through the rest of the
	 * string byte-by-byte.
	 *
	 * In the second method, we proceed through the rest of the input
	 * string just calculating how big the converted string will be.  Then
	 * there are two cases:
	 *  1)	if the string has enough extra space to handle the converted
	 *	value.  We go backwards through the string, converting until we
	 *	get to the position we are at now, and then stop.  If this
	 *	position is far enough along in the string, this method is
	 *	faster than the other method.  If the memory copy were the same
	 *	speed as the byte-by-byte loop, that position would be about
	 *	half-way, as at the half-way mark, parsing to the end and back
	 *	is one complete string's parse, the same amount as starting
	 *	over and going all the way through.  Actually, it would be
	 *	somewhat less than half-way, as it's faster to just count bytes
	 *	than to also copy, and we don't have the overhead of allocating
	 *	a new string, changing the scalar to use it, and freeing the
	 *	existing one.  But if the memory copy is fast, the break-even
	 *	point is somewhere after half way.  The counting loop could be
	 *	sped up by vectorization, etc, to move the break-even point
	 *	further towards the beginning.
	 *  2)	if the string doesn't have enough space to handle the converted
	 *	value.  A new string will have to be allocated, and one might
	 *	as well, given that, start from the beginning doing the first
	 *	method.  We've spent extra time parsing the string and in
	 *	exchange all we've gotten is that we know precisely how big to
	 *	make the new one.  Perl is more optimized for time than space,
	 *	so this case is a loser.
	 * So what I've decided to do is not use the 2nd method unless it is
	 * guaranteed that a new string won't have to be allocated, assuming
	 * the worst case.  I also decided not to put any more conditions on it
	 * than this, for now.  It seems likely that, since the worst case is
	 * twice as big as the unknown portion of the string (plus 1), we won't
	 * be guaranteed enough space, causing us to go to the first method,
	 * unless the string is short, or the first variant character is near
	 * the end of it.  In either of these cases, it seems best to use the
	 * 2nd method.  The only circumstance I can think of where this would
	 * be really slower is if the string had once had much more data in it
	 * than it does now, but there is still a substantial amount in it  */

	{
	    STRLEN invariant_head = t - s;
	    STRLEN size = invariant_head + (e - t) * 2 + 1 + extra;
	    if (SvLEN(sv) < size) {

		/* Here, have decided to allocate a new string */

		U8 *dst;
		U8 *d;

		Newx(dst, size, U8);

		/* If no known invariants at the beginning of the input string,
		 * set so starts from there.  Otherwise, can use memory copy to
		 * get up to where we are now, and then start from here */

		if (invariant_head <= 0) {
		    d = dst;
		} else {
		    Copy(s, dst, invariant_head, char);
		    d = dst + invariant_head;
		}

		while (t < e) {
		    const UV uv = NATIVE8_TO_UNI(*t++);
		    if (UNI_IS_INVARIANT(uv))
			*d++ = (U8)UNI_TO_NATIVE(uv);
		    else {
			*d++ = (U8)UTF8_EIGHT_BIT_HI(uv);
			*d++ = (U8)UTF8_EIGHT_BIT_LO(uv);
		    }
		}
		*d = '\0';
		SvPV_free(sv); /* No longer using pre-existing string */
		SvPV_set(sv, (char*)dst);
		SvCUR_set(sv, d - dst);
		SvLEN_set(sv, size);
	    } else {

		/* Here, have decided to get the exact size of the string.
		 * Currently this happens only when we know that there is
		 * guaranteed enough space to fit the converted string, so
		 * don't have to worry about growing.  If two_byte_count is 0,
		 * then t points to the first byte of the string which hasn't
		 * been examined yet.  Otherwise two_byte_count is 1, and t
		 * points to the first byte in the string that will expand to
		 * two.  Depending on this, start examining at t or 1 after t.
		 * */

		U8 *d = t + two_byte_count;


		/* Count up the remaining bytes that expand to two */

		while (d < e) {
		    const U8 chr = *d++;
		    if (! NATIVE_IS_INVARIANT(chr)) two_byte_count++;
		}

		/* The string will expand by just the number of bytes that
		 * occupy two positions.  But we are one afterwards because of
		 * the increment just above.  This is the place to put the
		 * trailing NUL, and to set the length before we decrement */

		d += two_byte_count;
		SvCUR_set(sv, d - s);
		*d-- = '\0';


		/* Having decremented d, it points to the position to put the
		 * very last byte of the expanded string.  Go backwards through
		 * the string, copying and expanding as we go, stopping when we
		 * get to the part that is invariant the rest of the way down */

		e--;
		while (e >= t) {
		    const U8 ch = NATIVE8_TO_UNI(*e--);
		    if (UNI_IS_INVARIANT(ch)) {
			*d-- = UNI_TO_NATIVE(ch);
		    } else {
			*d-- = (U8)UTF8_EIGHT_BIT_LO(ch);
			*d-- = (U8)UTF8_EIGHT_BIT_HI(ch);
		    }
		}
	    }
	}
a3218 3

    /* Mark as UTF-8 even if no variant - saves scanning loop */
    SvUTF8_on(sv);
d3238 1
a3238 1
Perl_sv_utf8_downgrade(pTHX_ register SV *const sv, const bool fail_ok)
d3281 1
a3281 1
Perl_sv_utf8_encode(pTHX_ register SV *const sv)
d3308 1
a3308 1
Perl_sv_utf8_decode(pTHX_ register SV *const sv)
d3376 1
a3376 1
S_glob_assign_glob(pTHX_ SV *const dstr, SV *const sstr, const int dtype)
d3405 6
d3453 1
a3453 1
S_glob_assign_ref(pTHX_ SV *const dstr, SV *const sstr)
d3461 1
d3465 6
d3488 2
d3524 1
a3524 2
			    && cv_const_sv(cv)
			    == cv_const_sv((const CV *)sref)) {
d3537 1
a3537 2
						   cv_const_sv((const CV *)
							       sref))))) {
a3560 4
	if (stype == SVt_PVAV && strEQ(GvNAME((GV*)dstr), "ISA")) {
	    sv_magic(sref, dstr, PERL_MAGIC_isa, NULL, 0);
	    mro_isa_changed_in(GvSTASH(dstr));
	}
d3566 1
d3571 1
a3571 1
Perl_sv_setsv_flags(pTHX_ SV *dstr, register SV* sstr, const I32 flags)
d3621 1
d3639 1
a3639 5
	if (!SvROK(sstr))
	    goto undef_sstr;
	if (dtype < SVt_PV && dtype != SVt_IV)
	    sv_upgrade(dstr, SVt_IV);
	break;
d3648 1
d3667 4
a3701 5
    case SVt_REGEXP:
	if (dtype < SVt_REGEXP)
	    sv_upgrade(dstr, SVt_REGEXP);
	break;

d3792 3
a3794 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
			   "Undefined value assigned to typeglob");
a3804 3
    else if (dtype == SVt_REGEXP && stype == SVt_REGEXP) {
	reg_temp_copy((REGEXP*)dstr, (REGEXP*)sstr);
    }
d3862 1
a3862 1
		     && SvTYPE(sstr) >= SVt_PVIV && SvTYPE(sstr) != SVt_PVFM))
d3946 1
d4002 1
a4002 1
Perl_sv_setsv_mg(pTHX_ SV *const dstr, register SV *const sstr)
d4092 1
a4092 1
Perl_sv_setpvn(pTHX_ register SV *const sv, register const char *const ptr, register const STRLEN len)
d4129 1
a4129 1
Perl_sv_setpvn_mg(pTHX_ register SV *const sv, register const char *const ptr, register const STRLEN len)
d4147 1
a4147 1
Perl_sv_setpv(pTHX_ register SV *const sv, register const char *const ptr)
d4178 1
a4178 1
Perl_sv_setpv_mg(pTHX_ register SV *const sv, register const char *const ptr)
d4207 1
a4207 1
Perl_sv_usepvn_flags(pTHX_ SV *const sv, char *ptr, const STRLEN len, const U32 flags)
d4323 1
a4323 1
Perl_sv_force_normal_flags(pTHX_ register SV *const sv, const U32 flags)
a4393 39
    else if (SvFAKE(sv) && SvTYPE(sv) == SVt_REGEXP) {
	/* Need to downgrade the REGEXP to a simple(r) scalar. This is analagous
	   to sv_unglob. We only need it here, so inline it.  */
	const svtype new_type = SvMAGIC(sv) || SvSTASH(sv) ? SVt_PVMG : SVt_PV;
	SV *const temp = newSV_type(new_type);
	void *const temp_p = SvANY(sv);

	if (new_type == SVt_PVMG) {
	    SvMAGIC_set(temp, SvMAGIC(sv));
	    SvMAGIC_set(sv, NULL);
	    SvSTASH_set(temp, SvSTASH(sv));
	    SvSTASH_set(sv, NULL);
	}
	SvCUR_set(temp, SvCUR(sv));
	/* Remember that SvPVX is in the head, not the body. */
	if (SvLEN(temp)) {
	    SvLEN_set(temp, SvLEN(sv));
	    /* This signals "buffer is owned by someone else" in sv_clear,
	       which is the least effort way to stop it freeing the buffer.
	    */
	    SvLEN_set(sv, SvLEN(sv)+1);
	} else {
	    /* Their buffer is already owned by someone else. */
	    SvPVX(sv) = savepvn(SvPVX(sv), SvCUR(sv));
	    SvLEN_set(temp, SvCUR(sv)+1);
	}

	/* Now swap the rest of the bodies. */

	SvFLAGS(sv) &= ~(SVf_FAKE|SVTYPEMASK);
	SvFLAGS(sv) |= new_type;
	SvANY(sv) = SvANY(temp);

	SvFLAGS(temp) &= ~(SVTYPEMASK);
	SvFLAGS(temp) |= SVt_REGEXP|SVf_FAKE;
	SvANY(temp) = temp_p;

	SvREFCNT_dec(temp);
    }
d4410 1
a4410 1
Perl_sv_chop(pTHX_ register SV *const sv, register const char *const ptr)
d4412 1
a4412 6
    STRLEN delta;
    STRLEN old_delta;
    U8 *p;
#ifdef DEBUGGING
    const U8 *real_start;
#endif
d4430 1
d4432 4
d4441 1
d4450 4
a4454 3
	old_delta = 0;
    } else {
	SvOOK_offset(sv, old_delta);
d4456 1
d4460 1
a4460 5

    p = (U8 *)SvPVX_const(sv);

    delta += old_delta;

d4462 9
a4470 18
    real_start = p - delta;
#endif

    assert(delta);
    if (delta < 0x100) {
	*--p = (U8) delta;
    } else {
	*--p = 0;
	p -= sizeof(STRLEN);
	Copy((U8*)&delta, p, sizeof(STRLEN), U8);
    }

#ifdef DEBUGGING
    /* Fill the preceding buffer with sentinals to verify that no-one is
       using it.  */
    while (p > real_start) {
	--p;
	*p = (U8)PTR2UV(p);
d4496 1
a4496 1
Perl_sv_catpvn_flags(pTHX_ register SV *const dsv, register const char *sstr, register const STRLEN slen, const I32 flags)
d4533 1
a4533 1
Perl_sv_catsv_flags(pTHX_ SV *const dsv, register SV *const ssv, const I32 flags)
d4566 1
a4566 2
		    /* Leave enough space for the cat that's about to happen */
		    sv_utf8_upgrade_flags_grow(dsv, 0, slen);
d4585 1
a4585 1
Perl_sv_catpv(pTHX_ register SV *const sv, register const char *ptr)
d4616 1
a4616 1
Perl_sv_catpv_mg(pTHX_ register SV *const sv, register const char *const ptr)
d4642 1
a4642 1
Perl_newSV(pTHX_ const STRLEN len)
d4674 2
a4675 2
Perl_sv_magicext(pTHX_ SV *const sv, SV *const obj, const int how, 
                const MGVTBL *const vtable, const char *const name, const I32 namlen)
d4698 1
d4764 1
a4764 2
Perl_sv_magic(pTHX_ register SV *const sv, SV *const obj, const int how, 
             const char *const name, const I32 namlen)
d4873 2
a4916 3
    case PERL_MAGIC_hints:
	vtable = &PL_vtbl_hints;
	break;
d4951 1
a4951 1
Perl_sv_unmagic(pTHX_ SV *const sv, const int type)
d4982 1
a4982 5
    if (SvMAGIC(sv)) {
	if (SvMAGICAL(sv))	/* if we're under save_magic, wait for restore_magic; */
	    mg_magical(sv);	/*    else fix the flags now */
    }
    else {
d4985 1
d4987 1
d5004 1
a5004 1
Perl_sv_rvweaken(pTHX_ SV *const sv)
d5015 2
a5016 1
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Reference is already weak");
d5049 1
a5049 1
Perl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv)
d5103 1
a5103 1
S_sv_del_backref(pTHX_ SV *const tsv, SV *const sv)
d5152 1
a5152 1
Perl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av)
d5304 1
a5304 1
Perl_sv_replace(pTHX_ register SV *const sv, register SV *const nsv)
d5313 2
a5314 2
	Perl_croak(aTHX_ "panic: reference miscount on nsv in sv_replace()"
		   " (%" UVuf " != 1)", (UV) SvREFCNT(nsv));
d5337 3
a5339 1
    if(SvTYPE(sv) == SVt_IV) {
d5342 2
d5390 1
a5390 1
Perl_sv_clear(pTHX_ register SV *const sv)
a5405 9
	if (SvROK(sv)) {
	    SV * const target = SvRV(sv);
	    if (SvWEAKREF(sv))
	        sv_del_backref(target, sv);
	    else
	        SvREFCNT_dec(target);
	}
	SvFLAGS(sv) &= SVf_BREAK;
	SvFLAGS(sv) |= SVTYPEMASK;
a5419 3
			/* A constant subroutine can have no side effects, so
			   don't bother calling it.  */
			&& !CvCONST(destructor)
d5422 1
a5422 2
			|| (CvSTART(destructor)
			    && (CvSTART(destructor)->op_next->op_type != OP_LEAVESUB))))
a5489 4
    case SVt_REGEXP:
	/* FIXME for plugins */
	pregfree2((REGEXP*) sv);
	goto freescalar;
a5536 1
    case SVt_PV:
d5540 1
a5540 3
	    STRLEN offset;
	    SvOOK_offset(sv, offset);
	    SvPV_set(sv, SvPVX_mutable(sv) - offset);
d5543 2
d5605 1
a5605 1
Perl_sv_newref(pTHX_ SV *const sv)
d5625 1
a5625 1
Perl_sv_free(pTHX_ SV *const sv)
d5673 1
a5673 1
Perl_sv_free2(pTHX_ SV *const sv)
d5681 4
a5684 3
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING),
			 "Attempt to free temp prematurely: SV 0x%"UVxf
			 pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
d5708 1
a5708 1
Perl_sv_len(pTHX_ register SV *const sv)
d5741 1
a5741 1
Perl_sv_len_utf8(pTHX_ register SV *const sv)
d5776 1
a5776 2
		    if (!mg && (SvTYPE(sv) < SVt_PVMG ||
				!(mg = mg_find(sv, PERL_MAGIC_utf8)))) {
a5781 4
		    /* For now, treat "overflowed" as "still unknown".
		       See RT #72924.  */
		    if (ulen != (STRLEN) mg->mg_len)
			mg->mg_len = -1;
d5815 1
a5815 1
		      const STRLEN uoffset, const STRLEN uend)
d5845 2
a5846 2
S_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start,
		    const U8 *const send, const STRLEN uoffset,
d5856 2
a5857 4
    if (!SvREADONLY(sv)
	&& PL_utf8cache
	&& (*mgp || (SvTYPE(sv) >= SVt_PVMG &&
		     (*mgp = mg_find(sv, PERL_MAGIC_utf8))))) {
d5948 1
a5948 1
=for apidoc sv_pos_u2b_flags
d5953 2
a5954 3
the offset, rather than from the start of the string. Handles type coercion.
I<flags> is passed to C<SvPV_flags>, and usually should be
C<SV_GMAGIC|SV_CONST_RETURN> to handle magic.
d5960 1
a5960 1
 * sv_pos_u2b_flags() uses, like sv_pos_b2u(), the mg_ptr of the potential
d5966 2
a5967 3
STRLEN
Perl_sv_pos_u2b_flags(pTHX_ SV *const sv, STRLEN uoffset, STRLEN *const lenp,
		      U32 flags)
a5970 1
    STRLEN boffset;
d5972 1
a5972 1
    PERL_ARGS_ASSERT_SV_POS_U2B_FLAGS;
d5974 4
a5977 1
    start = (U8*)SvPV_flags(sv, len, flags);
d5979 1
d5982 4
a5985 1
	boffset = sv_pos_u2b_cached(sv, &mg, start, send, uoffset, 0, 0);
d5989 1
a5989 1
	    const STRLEN uoffset2 = uoffset + *lenp;
d5996 5
a6000 4
    } else {
	if (lenp)
	    *lenp = 0;
	boffset = 0;
d6003 1
a6003 41
    return boffset;
}

/*
=for apidoc sv_pos_u2b

Converts the value pointed to by offsetp from a count of UTF-8 chars from
the start of the string, to a count of the equivalent number of bytes; if
lenp is non-zero, it does the same to lenp, but this time starting from
the offset, rather than from the start of the string. Handles magic and
type coercion.

Use C<sv_pos_u2b_flags> in preference, which correctly handles strings longer
than 2Gb.

=cut
*/

/*
 * sv_pos_u2b() uses, like sv_pos_b2u(), the mg_ptr of the potential
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
 * byte offsets.  See also the comments of S_utf8_mg_pos_cache_update().
 *
 */

/* This function is subject to size and sign problems */

void
Perl_sv_pos_u2b(pTHX_ register SV *const sv, I32 *const offsetp, I32 *const lenp)
{
    PERL_ARGS_ASSERT_SV_POS_U2B;

    if (lenp) {
	STRLEN ulen = (STRLEN)*lenp;
	*offsetp = (I32)sv_pos_u2b_flags(sv, (STRLEN)*offsetp, &ulen,
					 SV_GMAGIC|SV_CONST_RETURN);
	*lenp = (I32)ulen;
    } else {
	*offsetp = (I32)sv_pos_u2b_flags(sv, (STRLEN)*offsetp, NULL,
					 SV_GMAGIC|SV_CONST_RETURN);
    }
d6030 2
a6031 2
S_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte,
                           const STRLEN utf8, const STRLEN blen)
d6040 1
a6040 2
    if (!*mgp && (SvTYPE(sv) < SVt_PVMG ||
		  !(*mgp = mg_find(sv, PERL_MAGIC_utf8)))) {
d6053 1
a6053 7
    if (PL_utf8cache < 0 && SvPOKp(sv)) {
	/* SvPOKp() because it's possible that sv has string overloading, and
	   therefore is a reference, hence SvPVX() is actually a pointer.
	   This cures the (very real) symptoms of RT 69422, but I'm not actually
	   sure whether we should even be caching the results of UTF-8
	   operations on overloading, given that nothing stops overloading
	   returning a different value every time it's called.  */
d6170 2
a6171 2
S_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target,
                    const U8 *end, STRLEN endu)
d6209 1
a6209 1
Perl_sv_pos_b2u(pTHX_ register SV *const sv, I32 *const offsetp)
d6231 2
a6232 5
    if (!SvREADONLY(sv)
	&& PL_utf8cache
	&& SvTYPE(sv) >= SVt_PVMG
	&& (mg = mg_find(sv, PERL_MAGIC_utf8)))
    {
d6413 1
a6413 1
Perl_sv_cmp(pTHX_ register SV *const sv1, register SV *const sv2)
d6495 1
a6495 1
Perl_sv_cmp_locale(pTHX_ register SV *const sv1, register SV *const sv2)
d6560 1
a6560 1
Perl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp)
d6618 1
a6618 1
Perl_sv_gets(pTHX_ register SV *const sv, register PerlIO *const fp, I32 append)
d6985 1
a6985 1
Perl_sv_inc(pTHX_ register SV *const sv)
a7038 7
	const NV was = SvNVX(sv);
	if (NV_OVERFLOWS_INTEGERS_AT &&
	    was >= NV_OVERFLOWS_INTEGERS_AT) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_IMPRECISION),
			   "Lost precision when incrementing %" NVff " by 1",
			   was);
	}
d7040 1
a7040 1
        SvNV_set(sv, was + 1.0);
d7054 1
a7054 1
    if (d < SvEND(sv)) {
d7142 1
a7142 1
Perl_sv_dec(pTHX_ register SV *const sv)
d7184 2
a7185 4
	    if (SvIVX(sv) == IV_MIN) {
		sv_setnv(sv, (NV)IV_MIN);
		goto oops_its_num;
	    }
d7194 3
a7196 13
    oops_its_num:
	{
	    const NV was = SvNVX(sv);
	    if (NV_OVERFLOWS_INTEGERS_AT &&
		was <= -NV_OVERFLOWS_INTEGERS_AT) {
		Perl_ck_warner(aTHX_ packWARN(WARN_IMPRECISION),
			       "Lost precision when decrementing %" NVff " by 1",
			       was);
	    }
	    (void)SvNOK_only(sv);
	    SvNV_set(sv, was - 1.0);
	    return;
	}
a7241 10
/* this define is used to eliminate a chunk of duplicated but shared logic
 * it has the suffix __SV_C to signal that it isnt API, and isnt meant to be
 * used anywhere but here - yves
 */
#define PUSH_EXTEND_MORTAL__SV_C(AnSv) \
    STMT_START {      \
	EXTEND_MORTAL(1); \
	PL_tmps_stack[++PL_tmps_ix] = (AnSv); \
    } STMT_END

d7259 1
a7259 1
Perl_sv_mortalcopy(pTHX_ SV *const oldstr)
d7266 2
a7267 1
    PUSH_EXTEND_MORTAL__SV_C(sv);
d7291 2
a7292 1
    PUSH_EXTEND_MORTAL__SV_C(sv);
d7306 1
a7306 2
returning. If C<SVf_UTF8> is set, C<s> is considered to be in UTF-8 and the
C<SVf_UTF8> flag will be set on the new SV.
d7316 1
a7316 1
Perl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)
d7326 2
a7327 16

    /* This code used to a sv_2mortal(), however we now unroll the call to sv_2mortal()
     * and do what it does outselves here.
     * Since we have asserted that flags can only have the SVf_UTF8 and/or SVs_TEMP flags
     * set above we can use it to enable the sv flags directly (bypassing SvTEMP_on), which
     * in turn means we dont need to mask out the SVf_UTF8 flag below, which means that we
     * eleminate quite a few steps than it looks - Yves (explaining patch by gfx)
     */

    SvFLAGS(sv) |= flags;

    if(flags & SVs_TEMP){
	PUSH_EXTEND_MORTAL__SV_C(sv);
    }

    return sv;
d7343 1
a7343 1
Perl_sv_2mortal(pTHX_ register SV *const sv)
d7350 2
a7351 1
    PUSH_EXTEND_MORTAL__SV_C(sv);
d7367 1
a7367 1
Perl_newSVpv(pTHX_ const char *const s, const STRLEN len)
d7389 1
a7389 1
Perl_newSVpvn(pTHX_ const char *const s, const STRLEN len)
d7410 1
a7410 1
Perl_newSVhek(pTHX_ const HEK *const hek)
d7528 1
a7528 1
Perl_newSVpvf_nocontext(const char *const pat, ...)
d7553 1
a7553 1
Perl_newSVpvf(pTHX_ const char *const pat, ...)
d7569 1
a7569 1
Perl_vnewSVpvf(pTHX_ const char *const pat, va_list *const args)
d7591 1
a7591 1
Perl_newSVnv(pTHX_ const NV n)
d7611 1
a7611 1
Perl_newSViv(pTHX_ const IV i)
d7631 1
a7631 1
Perl_newSVuv(pTHX_ const UV u)
d7651 1
a7651 1
Perl_newSV_type(pTHX_ const svtype type)
d7670 1
a7670 1
Perl_newRV_noinc(pTHX_ SV *const tmpRef)
d7673 1
a7673 1
    register SV *sv = newSV_type(SVt_IV);
d7688 1
a7688 1
Perl_newRV(pTHX_ SV *const sv)
d7707 1
a7707 1
Perl_newSVsv(pTHX_ register SV *const old)
d7715 2
a7716 1
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "semi-panic: attempt to dup freed string");
d7737 1
a7737 1
Perl_sv_reset(pTHX_ register const char *s, HV *const stash)
d7841 1
a7841 1
Perl_sv_2io(pTHX_ SV *const sv)
d7883 1
a7883 1
The flags in C<lref> are passed to gv_fetchsv.
d7889 1
a7889 1
Perl_sv_2cv(pTHX_ SV *sv, HV **const st, GV **const gvp, const I32 lref)
d7988 1
a7988 1
Perl_sv_true(pTHX_ register SV *const sv)
d8033 1
a8033 1
Perl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)
d8094 1
a8094 1
Perl_sv_pvbyten_force(pTHX_ SV *const sv, STRLEN *const lp)
d8113 1
a8113 1
Perl_sv_pvutf8n_force(pTHX_ SV *const sv, STRLEN *const lp)
d8132 1
a8132 1
Perl_sv_reftype(pTHX_ const SV *const sv, const int ob)
d8147 1
a8171 1
	case SVt_REGEXP:	return "REGEXP"; 
d8212 1
a8212 1
Perl_sv_isa(pTHX_ SV *sv, const char *const name)
d8245 1
a8245 1
Perl_newSVrv(pTHX_ SV *const rv, const char *const classname)
d8264 1
a8264 1
	sv_upgrade(rv, SVt_IV);
d8301 1
a8301 1
Perl_sv_setref_pv(pTHX_ SV *const rv, const char *const classname, void *const pv)
d8329 1
a8329 1
Perl_sv_setref_iv(pTHX_ SV *const rv, const char *const classname, const IV iv)
d8350 1
a8350 1
Perl_sv_setref_uv(pTHX_ SV *const rv, const char *const classname, const UV uv)
d8371 1
a8371 1
Perl_sv_setref_nv(pTHX_ SV *const rv, const char *const classname, const NV nv)
d8395 1
a8395 2
Perl_sv_setref_pvn(pTHX_ SV *const rv, const char *const classname,
                   const char *const pv, const STRLEN n)
d8414 1
a8414 1
Perl_sv_bless(pTHX_ SV *const sv, HV *const stash)
d8459 1
a8459 1
S_sv_unglob(pTHX_ SV *const sv)
d8517 1
a8517 1
Perl_sv_unref_flags(pTHX_ SV *const ref, const U32 flags)
d8547 1
a8547 1
Perl_sv_untaint(pTHX_ SV *const sv)
d8566 1
a8566 1
Perl_sv_tainted(pTHX_ SV *const sv)
d8588 1
a8588 1
Perl_sv_setpviv(pTHX_ SV *const sv, const IV iv)
d8608 1
a8608 1
Perl_sv_setpviv_mg(pTHX_ SV *const sv, const IV iv)
d8624 1
a8624 1
Perl_sv_setpvf_nocontext(SV *const sv, const char *const pat, ...)
d8642 1
a8642 1
Perl_sv_setpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
d8665 1
a8665 1
Perl_sv_setpvf(pTHX_ SV *const sv, const char *const pat, ...)
d8688 1
a8688 1
Perl_sv_vsetpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args)
d8704 1
a8704 1
Perl_sv_setpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
d8726 1
a8726 1
Perl_sv_vsetpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args)
d8742 1
a8742 1
Perl_sv_catpvf_nocontext(SV *const sv, const char *const pat, ...)
d8760 1
a8760 1
Perl_sv_catpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
d8787 1
a8787 1
Perl_sv_catpvf(pTHX_ SV *const sv, const char *const pat, ...)
d8810 1
a8810 1
Perl_sv_vcatpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args)
d8826 1
a8826 1
Perl_sv_catpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
d8848 1
a8848 1
Perl_sv_vcatpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args)
d8868 1
a8868 2
Perl_sv_vsetpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen,
                 va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted)
a8875 16

/*
 * Warn of missing argument to sprintf, and then return a defined value
 * to avoid inappropriate "use of uninit" warnings [perl #71000].
 */
#define WARN_MISSING WARN_UNINITIALIZED /* Not sure we want a new category */
STATIC SV*
S_vcatpvfn_missing_argument(pTHX) {
    if (ckWARN(WARN_MISSING)) {
	Perl_warner(aTHX_ packWARN(WARN_MISSING), "Missing argument in %s",
		PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn()");
    }
    return &PL_sv_no;
}


d8877 1
a8877 1
S_expect_number(pTHX_ char **const pattern)
d8900 1
a8900 1
S_F0convert(NV nv, char *const endbuf, STRLEN *const len)
d8950 1
a8950 2
Perl_sv_vcatpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen,
                 va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted)
a9065 1
	const char *fmtstart;
a9105 2
	fmtstart = q;

d9155 3
a9157 2
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
				     "internal %%<num>p might conflict with future printf extensions");
d9238 1
a9238 1
			? svargs[evix-1] : S_vcatpvfn_missing_argument(aTHX);
d9240 1
a9240 2
		    vecsv = svix < svmax
			? svargs[svix++] : S_vcatpvfn_missing_argument(aTHX);
d9387 1
a9387 2
		argsv = (i >= 0 && i < svmax)
		    ? svargs[i] : S_vcatpvfn_missing_argument(aTHX);
d9390 1
a9390 1
		    ? svargs[svix++] : S_vcatpvfn_missing_argument(aTHX);
d9422 6
a9501 1
		case 'q':
d9503 1
a9503 3
				iv = va_arg(*args, Quad_t); break;
#else
				goto unknown;
a9513 1
		case 'q':
d9515 1
a9515 3
				iv = (Quad_t)tiv; break;
#else
				goto unknown;
a9586 1
		case 'q':
d9588 1
a9588 3
			   uv = va_arg(*args, Uquad_t); break;
#else
			   goto unknown;
a9598 1
		case 'q':
d9600 1
a9600 3
				uv = (Uquad_t)tuv; break;
#else
				goto unknown;
a9885 1
		case 'q':
d9887 1
a9887 3
				*(va_arg(*args, Quad_t*)) = i; break;
#else
				goto unknown;
d9906 9
a9914 14
		if (fmtstart < patend) {
		    const char * const fmtend = q < patend ? q : patend;
		    const char * f;
		    sv_catpvs(msg, "\"%");
		    for (f = fmtstart; f < fmtend; f++) {
			if (isPRINT(*f)) {
			    sv_catpvn(msg, f, 1);
			} else {
			    Perl_sv_catpvf(aTHX_ msg,
					   "\\%03"UVof, (UV)*f & 0xFF);
			}
		    }
		    sv_catpvs(msg, "\"");
		} else {
a9915 1
		}
d10041 1
a10041 2
   If this changes, please unmerge ss_dup.
   Likewise, sv_dup_inc_multiple() relies on this fact.  */
d10060 1
a10060 1
Perl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param)
d10183 1
a10183 1
Perl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param)
d10207 1
a10207 1
Perl_dirp_dup(pTHX_ DIR *const dp)
d10219 1
a10219 1
Perl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)
d10255 1
a10255 1
Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)
d10257 2
a10258 2
    MAGIC *mgret = NULL;
    MAGIC **mgprev_p = &mgret;
d10262 7
d10271 11
a10281 14
	Newx(nmg, 1, MAGIC);
	*mgprev_p = nmg;
	mgprev_p = &(nmg->mg_moremagic);

	/* There was a comment "XXX copy dynamic vtable?" but as we don't have
	   dynamic vtables, I'm not sure why Sarathy wrote it. The comment dates
	   from the original commit adding Perl_mg_dup() - revision 4538.
	   Similarly there is the annotation "XXX random ptr?" next to the
	   assignment to nmg->mg_ptr.  */
	*nmg = *mg;

	/* FIXME for plugins
	if (nmg->mg_type == PERL_MAGIC_qr) {
	    nmg->mg_obj	= MUTABLE_SV(CALLREGDUPE((REGEXP*)nmg->mg_obj, param));
d10283 1
a10283 3
	else
	*/
	if(nmg->mg_type == PERL_MAGIC_backref) {
d10287 1
a10287 1
		= SvREFCNT_inc(av_dup_inc((const AV *) nmg->mg_obj, param));
d10290 11
a10300 10
	    nmg->mg_obj	= (nmg->mg_flags & MGf_REFCOUNTED)
			      ? sv_dup_inc(nmg->mg_obj, param)
			      : sv_dup(nmg->mg_obj, param);
	}

	if (nmg->mg_ptr && nmg->mg_type != PERL_MAGIC_regex_global) {
	    if (nmg->mg_len > 0) {
		nmg->mg_ptr	= SAVEPVN(nmg->mg_ptr, nmg->mg_len);
		if (nmg->mg_type == PERL_MAGIC_overload_table &&
			AMT_AMAGIC((AMT*)nmg->mg_ptr))
d10302 1
d10304 4
a10307 2
		    sv_dup_inc_multiple((SV**)(namtp->table),
					(SV**)(namtp->table), NofAMmeth, param);
d10310 2
a10311 2
	    else if (nmg->mg_len == HEf_SVKEY)
		nmg->mg_ptr = (char*)sv_dup_inc((const SV *)nmg->mg_ptr, param);
d10313 1
a10313 1
	if ((nmg->mg_flags & MGf_DUP) && nmg->mg_virtual && nmg->mg_virtual->svt_dup) {
d10316 1
d10331 1
a10331 1
    Newx(tbl, 1, PTR_TBL_t);
d10352 1
a10352 1
S_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)
d10368 1
a10368 1
Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)
d10381 1
a10381 1
Perl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv)
d10408 1
a10408 1
Perl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl)
d10443 1
a10443 1
Perl_ptr_table_clear(pTHX_ PTR_TBL_t *const tbl)
d10466 1
a10466 1
Perl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl)
d10479 1
a10479 1
Perl_rvpv_dup(pTHX_ SV *const dstr, const SV *const sstr, CLONE_PARAMS *const param)
d10520 4
a10523 13
	SvPV_set(dstr, NULL);
    }
}

/* duplicate a list of SVs. source and dest may point to the same memory.  */
static SV **
S_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest,
		      SSize_t items, CLONE_PARAMS *const param)
{
    PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE;

    while (items-- > 0) {
	*dest++ = sv_dup_inc(*source++, param);
a10524 2

    return dest;
d10530 1
a10530 1
Perl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
d10597 1
a10597 5
	if(SvROK(sstr)) {
	    Perl_rvpv_dup(aTHX_ dstr, sstr, param);
	} else {
	    SvIV_set(dstr, SvIVX(sstr));
	}
d10603 4
d10622 3
a10630 1
	    case SVt_REGEXP:
a10684 4
	    case SVt_REGEXP:
		/* FIXME for plugins */
		re_dup_guts((REGEXP*) sstr, (REGEXP*) dstr, param);
		break;
d10698 1
a10698 2
		       table--unless this is during a join and the stash
		       is not actually being cloned.  */
a10701 12
		    if(param->flags & CLONEf_JOIN_IN) {
			const HEK * const hvname
			 = HvNAME_HEK(GvSTASH(dstr));
			if( hvname
			 && GvSTASH(dstr) == gv_stashpvn(
			     HEK_KEY(hvname), HEK_LEN(hvname), 0
			    )
			  )
			    Perl_sv_add_backref(
			     aTHX_ MUTABLE_SV(GvSTASH(dstr)), dstr
			    );
		    }
d10748 2
a10749 2
			dst_ary = sv_dup_inc_multiple(src_ary, dst_ary, items,
						      param);
a10753 5
			if (!(param->flags & CLONEf_COPY_STACKS)
			     && AvREIFY(sstr))
			{
			    av_reify(MUTABLE_AV(dstr)); /* #41138 */
			}
d10762 3
a10764 3
		    AvALLOC((const AV *)dstr)	= (SV**)NULL;
		    AvMAX(  (const AV *)dstr)	= -1;
		    AvFILLp((const AV *)dstr)	= -1;
d10830 2
a10831 1
		    CvXSUBANY(dstr).any_ptr =
d10903 12
a10914 23
	    case CXt_LOOP_LAZYSV:
		ncx->blk_loop.state_u.lazysv.end
		    = sv_dup_inc(ncx->blk_loop.state_u.lazysv.end, param);
		/* We are taking advantage of av_dup_inc and sv_dup_inc
		   actually being the same function, and order equivalance of
		   the two unions.
		   We can assert the later [but only at run time :-(]  */
		assert ((void *) &ncx->blk_loop.state_u.ary.ary ==
			(void *) &ncx->blk_loop.state_u.lazysv.cur);
	    case CXt_LOOP_FOR:
		ncx->blk_loop.state_u.ary.ary
		    = av_dup_inc(ncx->blk_loop.state_u.ary.ary, param);
	    case CXt_LOOP_LAZYIV:
	    case CXt_LOOP_PLAIN:
		if (CxPADLOOP(ncx)) {
		    ncx->blk_loop.oldcomppad
			= (PAD*)ptr_table_fetch(PL_ptr_table,
						ncx->blk_loop.oldcomppad);
		} else {
		    ncx->blk_loop.oldcomppad
			= (PAD*)gv_dup((const GV *)ncx->blk_loop.oldcomppad,
				       param);
		}
d10917 3
a10919 3
		ncx->blk_format.cv	= cv_dup(ncx->blk_format.cv, param);
		ncx->blk_format.gv	= gv_dup(ncx->blk_format.gv, param);
		ncx->blk_format.dfoutgv	= gv_dup_inc(ncx->blk_format.dfoutgv,
d11215 2
a11223 2
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
d11318 13
a11330 1
	    TOPPTR(nss,ix) = parser_dup((const yy_parser*)ptr, param);
d11347 1
a11347 1
do_mark_cloneable_stash(pTHX_ SV *const sv)
a11461 8
#else		/* !PERL_IMPLICIT_SYS */
    IV i;
    CLONE_PARAMS clone_params;
    CLONE_PARAMS* param = &clone_params;
    PerlInterpreter * const my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));

    PERL_ARGS_ASSERT_PERL_CLONE;
#endif		/* PERL_IMPLICIT_SYS */
d11467 1
a11467 1
#ifdef DEBUGGING
a11472 1
    PL_scopestack_name = 0;
d11479 1
a11479 4
#  ifdef DEBUG_LEAKING_SCALARS
    PL_sv_serial = (((U32)my_perl >> 2) & 0xfff) * 1000000;
#  endif
#else	/* !DEBUGGING */
d11481 1
a11481 1
#endif	/* DEBUGGING */
a11482 1
#ifdef PERL_IMPLICIT_SYS
d11493 27
a11520 1

a11579 3
    /* dbargs array probably holds garbage */
    PL_dbargs		= NULL;

d11635 1
d11678 20
a11697 5
    /* ORANGE FIXME for plugins, probably in the SV dup code.
       newSViv(PTR2IV(CALLREGDUPE(
       INT2PTR(REGEXP *, SvIVX(regex)), param))))
    */
    PL_regex_padav = av_dup_inc(proto_perl->Iregex_padav, param);
a11700 1
    PL_ofsgv            = gv_dup(proto_perl->Iofsgv, param);
d11721 1
d11843 2
a11844 1
    PL_parser		= parser_dup(proto_perl->Iparser, param);
d11881 1
a11893 10
    PL_utf8_X_begin	= sv_dup_inc(proto_perl->Iutf8_X_begin, param);
    PL_utf8_X_extend	= sv_dup_inc(proto_perl->Iutf8_X_extend, param);
    PL_utf8_X_prepend	= sv_dup_inc(proto_perl->Iutf8_X_prepend, param);
    PL_utf8_X_non_hangul	= sv_dup_inc(proto_perl->Iutf8_X_non_hangul, param);
    PL_utf8_X_L	= sv_dup_inc(proto_perl->Iutf8_X_L, param);
    PL_utf8_X_LV	= sv_dup_inc(proto_perl->Iutf8_X_LV, param);
    PL_utf8_X_LVT	= sv_dup_inc(proto_perl->Iutf8_X_LVT, param);
    PL_utf8_X_T	= sv_dup_inc(proto_perl->Iutf8_X_T, param);
    PL_utf8_X_V	= sv_dup_inc(proto_perl->Iutf8_X_V, param);
    PL_utf8_X_LV_LVT_V	= sv_dup_inc(proto_perl->Iutf8_X_LV_LVT_V, param);
d11942 1
d11951 7
a11957 5
    if (proto_perl->Ipsig_name) {
	Newx(PL_psig_name, 2 * SIG_SIZE, SV*);
	sv_dup_inc_multiple(proto_perl->Ipsig_name, PL_psig_name, 2 * SIG_SIZE,
			    param);
	PL_psig_ptr = PL_psig_name + SIG_SIZE;
d11971 6
a11976 3
	Newx(PL_tmps_stack, PL_tmps_max, SV*);
	sv_dup_inc_multiple(proto_perl->Itmps_stack, PL_tmps_stack,
			    PL_tmps_ix+1, param);
a11994 4
#ifdef DEBUGGING
	Newxz(PL_scopestack_name, PL_scopestack_max, const char *);
	Copy(proto_perl->Iscopestack_name, PL_scopestack_name, PL_scopestack_ix, const char *);
#endif
d12028 2
a12029 1
		PUSH_EXTEND_MORTAL__SV_C(SvREFCNT_inc_simple(nsv));
d12041 1
a12041 1
    my_perl->Ina	= proto_perl->Ina;
d12055 1
a12096 2
    /* op_free() hook */
    PL_opfreehook	= proto_perl->Iopfreehook;
d12283 1
a12283 1
S_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val)
d12319 1
a12319 1
S_find_array_subscript(pTHX_ const AV *const av, const SV *const val)
d12352 2
a12353 2
S_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ,
	const SV *const keyname, I32 aindex, int subscript_type)
d12428 1
a12428 2
S_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv,
		  bool match)
d12432 3
a12434 2
    const GV *gv;
    const OP *o, *o2, *kid;
d12472 1
a12472 1
	    keysv = find_hash_subscript((const HV*)sv, uninit_sv);
d12477 1
a12477 1
	    index = find_array_subscript((const AV *)sv, uninit_sv);
d12505 1
a12505 1
		AV *av = MUTABLE_AV(PAD_SV(obase->op_targ));
d12521 1
a12521 1
		AV *const av = GvAV(gv);
d12594 1
a12594 1
		SV * const keysv = find_hash_subscript((const HV*)sv, uninit_sv);
d12601 1
a12601 1
		    = find_array_subscript((const AV *)sv, uninit_sv);
d12734 1
a12734 1
    case OP_AEACH:
a12756 8
    case OP_FLIP:
    case OP_FLOP:
    {
	GV * const gv = gv_fetchpvs(".", GV_NOTQUAL, SVt_PV);
	if (gv && GvSV(gv) == uninit_sv)
	    return newSVpvs_flags("$.", SVs_TEMP);
	goto do_op;
    }
d12822 1
a12822 1
Perl_report_uninit(pTHX_ const SV *uninit_sv)
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a34 9
#ifndef HAS_C99
# if __STDC_VERSION__ >= 199901L && !defined(VMS)
#  define HAS_C99 1
# endif
#endif
#if HAS_C99
# include <stdint.h>
#endif

d74 1
a74 1
In all but the most memory-paranoid configurations (ex: PURIFY), heads
d126 1
a126 2
    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
		      do_clean_named_io_objs()
d128 2
a129 1
			and try to do the same for all objects indirectly
d150 2
a151 1
    new_XPVNV(), del_XPVGV(),
d166 20
d258 11
a268 3
    char *chunk;                /* must use New here to match call to */
    Newx(chunk,PERL_ARENA_SIZE,char);  /* Safefree() in sv_free_arenas() */
    sv_add_arena(chunk, PERL_ARENA_SIZE, 0);
d297 1
a297 1
    sv->sv_debug_parent = NULL;
d436 1
a436 1
	    if (SvTYPE(sv) != (svtype)SVTYPEMASK
d455 1
a455 1
    if (SvTYPE(sv) != (svtype)SVTYPEMASK) {
d465 1
a465 1
Dump the contents of all SVs not yet freed (debugging aid).
d506 1
d508 1
a508 3
/* clear any slots in a GV which hold objects - except IO;
 * called by sv_clean_objs() for each live GV */

a512 1
    SV *obj;
d515 16
a530 30
    if (!GvGP(sv))
	return;

    /* freeing GP entries may indirectly free the current GV;
     * hold onto it while we mess with the GP slots */
    SvREFCNT_inc(sv);

    if ( ((obj = GvSV(sv) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob SV object:\n "), sv_dump(obj)));
	GvSV(sv) = NULL;
	SvREFCNT_dec(obj);
    }
    if ( ((obj = MUTABLE_SV(GvAV(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob AV object:\n "), sv_dump(obj)));
	GvAV(sv) = NULL;
	SvREFCNT_dec(obj);
    }
    if ( ((obj = MUTABLE_SV(GvHV(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob HV object:\n "), sv_dump(obj)));
	GvHV(sv) = NULL;
	SvREFCNT_dec(obj);
    }
    if ( ((obj = MUTABLE_SV(GvCV(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob CV object:\n "), sv_dump(obj)));
	GvCV_set(sv, NULL);
	SvREFCNT_dec(obj);
a531 33
    SvREFCNT_dec(sv); /* undo the inc above */
}

/* clear any IO slots in a GV which hold objects (except stderr, defout);
 * called by sv_clean_objs() for each live GV */

static void
do_clean_named_io_objs(pTHX_ SV *const sv)
{
    dVAR;
    SV *obj;
    assert(SvTYPE(sv) == SVt_PVGV);
    assert(isGV_with_GP(sv));
    if (!GvGP(sv) || sv == (SV*)PL_stderrgv || sv == (SV*)PL_defoutgv)
	return;

    SvREFCNT_inc(sv);
    if ( ((obj = MUTABLE_SV(GvIO(sv)) )) && SvOBJECT(obj)) {
	DEBUG_D((PerlIO_printf(Perl_debug_log,
		"Cleaning named glob IO object:\n "), sv_dump(obj)));
	GvIOp(sv) = NULL;
	SvREFCNT_dec(obj);
    }
    SvREFCNT_dec(sv); /* undo the inc above */
}

/* Void wrapper to pass to visit() */
static void
do_curse(pTHX_ SV * const sv) {
    if ((PL_stderrgv && GvGP(PL_stderrgv) && (SV*)GvIO(PL_stderrgv) == sv)
     || (PL_defoutgv && GvGP(PL_defoutgv) && (SV*)GvIO(PL_defoutgv) == sv))
	return;
    (void)curse(sv, 0);
d533 1
d538 1
a538 1
Attempt to destroy all objects not yet freed.
a546 1
    GV *olddef, *olderr;
d549 2
a550 3
    /* Some barnacles may yet remain, clinging to typeglobs.
     * Run the non-IO destructors first: they may want to output
     * error messages, close files etc */
d552 1
a552 13
    visit(do_clean_named_io_objs, SVt_PVGV|SVpgv_GP, SVTYPEMASK|SVp_POK|SVpgv_GP);
    /* And if there are some very tenacious barnacles clinging to arrays,
       closures, or what have you.... */
    visit(do_curse, SVs_OBJECT, SVs_OBJECT);
    olddef = PL_defoutgv;
    PL_defoutgv = NULL; /* disable skip of PL_defoutgv */
    if (olddef && isGV_with_GP(olddef))
	do_clean_named_io_objs(aTHX_ MUTABLE_SV(olddef));
    olderr = PL_stderrgv;
    PL_stderrgv = NULL; /* disable skip of PL_stderrgv */
    if (olderr && isGV_with_GP(olderr))
	do_clean_named_io_objs(aTHX_ MUTABLE_SV(olderr));
    SvREFCNT_dec(olddef);
d575 1
a575 1
cleanup.  This function may have to be called multiple times to free
d588 1
d632 1
a632 1
Deallocate the memory used by all arenas.  Note that all the individual SV
d677 3
d692 1
d709 61
d816 1
a816 1
linked list at PL_body_roots[sv_type], calling Perl_more_bodies() if
d820 1
a820 1
Perl_more_bodies allocates a new arena, and carves it up into an array of N
d828 4
d855 7
d916 2
a917 2
    /* HEs use this offset for their arena.  */
    { 0, 0, 0, SVt_NULL, FALSE, NONV, NOARENA, 0 },
d924 3
a926 2
    /* IVs are in the head, so the allocation size is 0.  */
    { 0,
d929 3
a931 1
      NOARENA /* IVS don't need an arena  */, 0
d934 3
a936 3
    { sizeof(NV), sizeof(NV),
      STRUCT_OFFSET(XPVNV, xnv_u),
      SVt_NV, FALSE, HADNV, HASARENA, FIT_ARENA(0, sizeof(NV)) },
d938 1
d945 1
d948 1
a948 1
      + STRUCT_OFFSET(XPV, xpv_cur),
d950 1
a950 1
      FIT_ARENA(0, sizeof(XPVIV) - STRUCT_OFFSET(XPV, xpv_cur)) },
d952 3
a954 5
    { sizeof(XPVNV) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XPVNV, xnv_u) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_PVNV, FALSE, HADNV, HASARENA,
      FIT_ARENA(0, sizeof(XPVNV) - STRUCT_OFFSET(XPV, xpv_cur)) },
d956 2
a957 1
    { sizeof(XPVMG), copy_length(XPVMG, xnv_u), 0, SVt_PVMG, FALSE, HADNV,
d960 4
a963 3
    { sizeof(regexp),
      sizeof(regexp),
      0,
d965 1
a965 1
      FIT_ARENA(0, sizeof(regexp))
d968 1
d972 1
d976 3
a978 3
    { sizeof(XPVAV),
      copy_length(XPVAV, xav_alloc),
      0,
d980 1
a980 1
      FIT_ARENA(0, sizeof(XPVAV)) },
d982 3
a984 3
    { sizeof(XPVHV),
      copy_length(XPVHV, xhv_max),
      0,
d986 1
a986 1
      FIT_ARENA(0, sizeof(XPVHV)) },
d988 4
a991 3
    { sizeof(XPVCV),
      sizeof(XPVCV),
      0,
d993 1
a993 1
      FIT_ARENA(0, sizeof(XPVCV)) },
d995 3
a997 3
    { sizeof(XPVFM),
      sizeof(XPVFM),
      0,
d999 1
a999 1
      FIT_ARENA(20, sizeof(XPVFM)) },
d1001 4
a1004 3
    { sizeof(XPVIO),
      sizeof(XPVIO),
      0,
d1006 1
a1006 1
      FIT_ARENA(24, sizeof(XPVIO)) },
d1009 7
d1020 3
a1022 1
/* return a thing to the free list */
d1024 3
a1026 6
#define del_body(thing, root)				\
    STMT_START {					\
	void ** const thing_copy = (void **)thing;	\
	*thing_copy = *root;				\
	*root = (void*)thing_copy;			\
    } STMT_END
d1030 11
a1040 3
#define new_XNV()	safemalloc(sizeof(XPVNV))
#define new_XPVNV()	safemalloc(sizeof(XPVNV))
#define new_XPVMG()	safemalloc(sizeof(XPVMG))
d1042 5
a1046 1
#define del_XPVGV(p)	safefree(p)
d1050 11
a1060 3
#define new_XNV()	new_body_allocated(SVt_NV)
#define new_XPVNV()	new_body_allocated(SVt_PVNV)
#define new_XPVMG()	new_body_allocated(SVt_PVMG)
d1062 5
a1066 2
#define del_XPVGV(p)	del_body(p + bodies_by_type[SVt_PVGV].offset,	\
				 &PL_body_roots[SVt_PVGV])
d1073 1
a1073 1
	safemalloc((details)->body_size + (details)->offset)
d1075 1
a1075 1
	safecalloc((details)->body_size + (details)->offset, 1)
d1077 2
a1078 3
void *
Perl_more_bodies (pTHX_ const svtype sv_type, const size_t body_size,
		  const size_t arena_size)
d1082 2
a1083 3
    struct arena_desc *adesc;
    struct arena_set *aroot = (struct arena_set *) PL_body_arenas;
    unsigned int curr;
d1086 1
a1086 1
    const size_t good_arena_size = Perl_malloc_good_size(arena_size);
d1102 1
a1102 23
    assert(arena_size);

    /* may need new arena-set to hold new arena */
    if (!aroot || aroot->curr >= aroot->set_size) {
	struct arena_set *newroot;
	Newxz(newroot, 1, struct arena_set);
	newroot->set_size = ARENAS_PER_SET;
	newroot->next = aroot;
	aroot = newroot;
	PL_body_arenas = (void *) newroot;
	DEBUG_m(PerlIO_printf(Perl_debug_log, "new arenaset %p\n", (void*)aroot));
    }

    /* ok, now have arena-set with at least 1 empty/available arena-desc */
    curr = aroot->curr++;
    adesc = &(aroot->set[curr]);
    assert(!adesc->arena);
    
    Newx(adesc->arena, good_arena_size, char);
    adesc->size = good_arena_size;
    adesc->utype = sv_type;
    DEBUG_m(PerlIO_printf(Perl_debug_log, "arena %d added: %p size %"UVuf"\n", 
			  curr, (void*)adesc->arena, (UV)good_arena_size));
d1104 1
a1104 1
    start = (char *) adesc->arena;
d1106 1
a1106 3
    /* Get the address of the byte after the end of the last body we can fit.
       Remember, this is integer division:  */
    end = start + good_arena_size / body_size * body_size;
d1108 1
a1108 1
    /* computed count doesn't reflect the 1st slot reservation */
d1113 3
a1115 3
			  (void*)start, (void*)end, (int)good_arena_size,
			  (int)arena_size, sv_type, (int)body_size,
			  (int)good_arena_size / (int)body_size));
d1120 2
a1121 2
			  (int)arena_size, sv_type, (int)body_size,
			  (int)good_arena_size / (int)body_size));
d1125 1
a1125 2
    while (1) {
	/* Where the next body would start:  */
a1126 9

	if (next >= end) {
	    /* This is the last body:  */
	    assert(next == end);

	    *(void **)start = 0;
	    return *root;
	}

d1130 3
d1143 1
a1143 3
	  ? *((void **)(r3wt)) : Perl_more_bodies(aTHX_ sv_type, \
					     bodies_by_type[sv_type].body_size,\
					     bodies_by_type[sv_type].arena_size)); \
d1168 1
a1168 4
It croaks if the SV is already in a more complex form than requested.  You
generally want to use the C<SvUPGRADE> macro wrapper, which checks the type
before calling C<sv_upgrade>, and hence does not croak.  See also
C<svtype>.
d1347 7
d1458 1
a1458 1
    if (old_type > SVt_IV) {
d1460 1
a1460 1
	safefree(old_body);
d1475 1
a1475 1
Remove any string offset.  You should normally use the C<SvOOK_off> macro
a1550 4
	STRLEN minlen = SvCUR(sv);
	minlen += (minlen >> PERL_STRLEN_EXPAND_SHIFT) + 10;
	if (newlen < minlen)
	    newlen = minlen;
a1609 1
	/* diag_listed_as: Can't coerce %s to %s in %s */
d1650 1
a1650 2
    /* With the if statement to ensure that integers are stored as IVs whenever
       possible:
d1656 1
a1656 3
       If you wish to remove the following if statement, so that this routine
       (and its callers) always return UVs, please benchmark to see what the
       effect is. Modern CPUs may be different. Or may not :-)
a1718 1
	/* diag_listed_as: Can't coerce %s to %s in %s */
d1720 1
a1720 1
		   OP_DESC(PL_op));
d1761 1
a1761 1
          pv = sv_uni_display(dsv, sv, 10, UNI_DISPLAY_ISPRINT);
a1814 1
		    /* diag_listed_as: Argument "%s" isn't numeric%s */
a1818 1
		    /* diag_listed_as: Argument "%s" isn't numeric%s */
d1827 1
a1827 2
non-numeric warning), even if your atof() doesn't grok them.  Get-magic is
ignored.
d1840 3
a1842 2
    if (SvPOK(sv) || SvPOKp(sv)) {
	sbegin = SvPV_nomg_const(sv, len);
d1844 2
d1854 1
d1859 3
d1863 1
d2270 1
a2270 1
	if (!SvPADTMP(sv)) {
d2299 5
a2303 7
    if (SvGMAGICAL(sv) || SvVALID(sv)) {
	/* FBMs use the space for SvIVX and SvNVX for other purposes, and use
	   the same flag bit as SVf_IVisUV, so must not let them cache IVs.
	   In practice they are extremely unlikely to actually get anywhere
	   accessible by user Perl code - the only way that I'm aware of is when
	   a constant subroutine which is used as the second argument to index.
	*/
d2342 1
a2342 4
		SV * tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return 0;
		tmpstr = AMG_CALLunary(sv, numer_amg);
d2383 3
a2385 3
    if (SvGMAGICAL(sv) || SvVALID(sv)) {
	/* FBMs use the space for SvIVX and SvNVX for other purposes, and use
	   the same flag bit as SVf_IVisUV, so must not let them cache IVs.  */
d2418 1
a2418 4
		SV *tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return 0;
		tmpstr = AMG_CALLunary(sv, numer_amg);
d2445 1
a2445 1
=for apidoc sv_2nv_flags
d2448 2
a2449 2
conversion.  If flags includes SV_GMAGIC, does an mg_get() first.
Normally used via the C<SvNV(sv)> and C<SvNVx(sv)> macros.
d2455 1
a2455 1
Perl_sv_2nv_flags(pTHX_ register SV *const sv, const I32 flags)
d2460 4
a2463 5
    if (SvGMAGICAL(sv) || SvVALID(sv)) {
	/* FBMs use the space for SvIVX and SvNVX for other purposes, and use
	   the same flag bit as SVf_IVisUV, so must not let them cache NVs.  */
	if (flags & SV_GMAGIC)
	    mg_get(sv);
d2488 1
a2488 4
		SV *tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return 0;
		tmpstr = AMG_CALLunary(sv, numer_amg);
d2643 1
a2643 1
	if (!PL_localizing && !SvPADTMP(sv) && ckWARN(WARN_UNINITIALIZED))
d2687 1
a2687 2
	SV * const tmpsv = AMG_CALLunary(sv, numer_amg);
	TAINT_IF(tmpsv && SvTAINTED(tmpsv));
d2732 4
a2735 3
If flags includes SV_GMAGIC, does an mg_get() first.  Coerces sv to a
string if necessary.  Normally invoked via the C<SvPV_flags> macro.
C<sv_2pv()> and C<sv_2pv_nomg> usually end up here too.
a2770 4
	    } else if(SvNVX(sv) == 0.0) {
		    tbuf[0] = '0';
		    tbuf[1] = 0;
		    len = 1;
d2779 7
d2805 1
a2805 5
		SV *tmpstr;
		if (flags & SV_SKIP_OVERLOAD)
		    return NULL;
		tmpstr = AMG_CALLunary(sv, string_amg);
		TAINT_IF(tmpstr && SvTAINTED(tmpstr));
d2840 1
a2840 4
		} else if (SvTYPE(referent) == SVt_REGEXP && (
			      !(PL_curcop->cop_hints & HINT_NO_AMAGIC)
			   || amagic_is_enabled(string_amg)
			  )) {
d2912 1
a2912 1
		    /* retval may not necessarily have reached the start of the
d2953 1
d2956 9
a2964 9
	if (SvNVX(sv) == 0.0) {
	    s = SvGROW_mutable(sv, 2);
	    *s++ = '0';
	    *s = '\0';
	} else {
	    dSAVE_ERRNO;
	    /* The +20 is pure guesswork.  Configure test needed. --jhi */
	    s = SvGROW_mutable(sv, NV_DIG + 20);
	    /* some Xenix systems wipe out errno here */
a2965 2
	    RESTORE_ERRNO;
	    while (*s) s++;
d2967 8
d2983 1
d2986 3
d2990 1
d2992 2
a2993 2
	    assert(SvPOK(buffer));
	    if (lp) {
d2995 7
a3002 2
            if ( SvUTF8(buffer) ) SvUTF8_on(sv);
	    return SvPVX(buffer);
d3009 1
a3009 1
	if (!PL_localizing && !SvPADTMP(sv) && ckWARN(WARN_UNINITIALIZED))
d3074 1
a3074 1
Perl_sv_2pvbyte(pTHX_ register SV *sv, STRLEN *const lp)
a3077 6
    if ((SvTHINKFIRST(sv) && !SvIsCOW(sv)) || isGV_with_GP(sv)) {
	SV *sv2 = sv_newmortal();
	sv_copypv(sv2,sv);
	sv = sv2;
    }
    else SvGETMAGIC(sv);
d3079 1
a3079 1
    return lp ? SvPV_nomg(sv,*lp) : SvPV_nomg_nolen(sv);
d3094 1
a3094 1
Perl_sv_2pvutf8(pTHX_ register SV *sv, STRLEN *const lp)
a3097 2
    if ((SvTHINKFIRST(sv) && !SvIsCOW(sv)) || isGV_with_GP(sv))
	sv = sv_mortalcopy(sv);
d3099 1
a3099 3
    if (SvGMAGICAL(sv)) SvFLAGS(sv) &= ~SVf_POK;
    assert(SvPOKp(sv));
    return lp ? SvPV_nomg(sv,*lp) : SvPV_nomg_nolen(sv);
d3106 2
a3107 10
This macro is only used by sv_true() or its macro equivalent, and only if
the latter's argument is neither SvPOK, SvIOK nor SvNOK.
It calls sv_2bool_flags with the SV_GMAGIC flag.

=for apidoc sv_2bool_flags

This function is only used by sv_true() and friends,  and only if
the latter's argument is neither SvPOK, SvIOK nor SvNOK.  If the flags
contain SV_GMAGIC, then it does an mg_get() first.

d3113 1
a3113 1
Perl_sv_2bool_flags(pTHX_ register SV *const sv, const I32 flags)
d3117 1
a3117 1
    PERL_ARGS_ASSERT_SV_2BOOL_FLAGS;
d3119 1
a3119 1
    if(flags & SV_GMAGIC) SvGETMAGIC(sv);
d3125 1
a3125 1
	    SV * const tmpsv = AMG_CALLunary(sv, bool__amg);
d3127 1
a3127 1
		return cBOOL(SvTRUE(tmpsv));
d3172 1
a3172 1
Like sv_utf8_upgrade, but doesn't do magic on C<sv>.
d3179 1
a3179 2
if all the bytes are invariant in UTF-8.
If C<flags> has C<SV_GMAGIC> bit set,
d3239 1
a3239 1
	    (void) SvPV_force_flags(sv,len,flags & SV_GMAGIC);
a3288 1
	if (extra) SvGROW(sv, SvCUR(sv) + extra);
a3446 23

	    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
		/* Update pos. We do it at the end rather than during
		 * the upgrade, to avoid slowing down the common case
		 * (upgrade without pos) */
		MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
		if (mg) {
		    I32 pos = mg->mg_len;
		    if (pos > 0 && (U32)pos > invariant_head) {
			U8 *d = (U8*) SvPVX(sv) + invariant_head;
			STRLEN n = (U32)pos - invariant_head;
			while (n > 0) {
			    if (UTF8_IS_START(*d))
				d++;
			    d++;
			    n--;
			}
			mg->mg_len  = d - (U8*)SvPVX(sv);
		    }
		}
		if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		    magic_setutf8(sv,mg); /* clear UTF8 cache */
	    }
a3480 1
	    int mg_flags = SV_GMAGIC;
d3485 1
a3485 17
	    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
		/* update pos */
		MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
		if (mg) {
		    I32 pos = mg->mg_len;
		    if (pos > 0) {
			sv_pos_b2u(sv, &pos);
			mg_flags = 0; /* sv_pos_b2u does get magic */
			mg->mg_len  = pos;
		    }
		}
		if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		    magic_setutf8(sv,mg); /* clear UTF8 cache */

	    }
	    s = (U8 *) SvPV_flags(sv, len, mg_flags);

d3518 3
d3522 1
a3522 1
	sv_force_normal_flags(sv, 0);
d3533 2
a3534 2
so that it looks like a character.  If the PV contains only single-byte
characters, the C<SvUTF8> flag stays off.
d3546 1
a3546 1
        const U8 *start, *c;
d3558 2
a3559 2
        c = start = (const U8 *) SvPVX_const(sv);
	if (!is_utf8_string(c, SvCUR(sv)))
a3568 16
	if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	    /* adjust pos to the start of a UTF8 char sequence */
	    MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
	    if (mg) {
		I32 pos = mg->mg_len;
		if (pos > 0) {
		    for (c = start + pos; c > start; c--) {
			if (UTF8_IS_START(*c))
			    break;
		    }
		    mg->mg_len  = c - start;
		}
	    }
	    if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		magic_setutf8(sv,mg); /* clear UTF8 cache */
	}
d3578 1
a3578 1
function if the source SV needs to be reused.  Does not handle 'set' magic.
d3590 1
a3590 1
function if the source SV needs to be reused.  Does not handle 'set' magic.
d3594 2
a3595 3
C<ssv> if appropriate, else not.  If the C<flags>
parameter has the C<NOSTEAL> bit set then the
buffers of temps will not be stolen.  <sv_setsv>
d3611 1
a3611 2
    I32 mro_changes = 0; /* 1 = method, 2 = isa, 3 = recursive isa */
    HV *old_stash = NULL;
d3615 1
a3615 1
    if (dtype != SVt_PVGV && !isGV_with_GP(dstr)) {
d3627 2
a3628 2
	    /* We have to turn this on here, even though we turn it off
	       below, as GvSTASH will fail an assertion otherwise. */
d3634 1
a3634 2
        gv_name_set(MUTABLE_GV(dstr), name, len,
                        GV_ADD | (GvNAMEUTF8(sstr) ? SVf_UTF8 : 0 ));
d3642 1
a3642 1
            GvCV_set(sstr, NULL);
d3647 1
a3647 3
        else if(
         GvCV((const GV *)sstr) && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
        ) {
d3653 1
a3653 4
    if(
        !mro_changes && GvGP(MUTABLE_GV(dstr)) && GvCVu((const GV *)dstr)
     && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
    ) {
d3657 2
a3658 28
    /* We don't need to check the name of the destination if it was not a
       glob to begin with. */
    if(dtype == SVt_PVGV) {
        const char * const name = GvNAME((const GV *)dstr);
        if(
            strEQ(name,"ISA")
         /* The stash may have been detached from the symbol table, so
            check its name. */
         && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
         && GvAV((const GV *)sstr)
        )
            mro_changes = 2;
        else {
            const STRLEN len = GvNAMELEN(dstr);
            if ((len > 1 && name[len-2] == ':' && name[len-1] == ':')
             || (len == 1 && name[0] == ':')) {
                mro_changes = 3;

                /* Set aside the old stash, so we can reset isa caches on
                   its subclasses. */
                if((old_stash = GvHV(dstr)))
                    /* Make sure we do not lose it early. */
                    SvREFCNT_inc_simple_void_NN(
                     sv_2mortal((SV *)old_stash)
                    );
            }
        }
    }
d3661 1
a3661 1
    isGV_with_GP_off(dstr); /* SvOK_off does not like globs. */
d3665 1
a3665 1
    GvGP_set(dstr, gp_ref(GvGP(sstr)));
d3674 1
a3674 22
    if(mro_changes == 2) {
	MAGIC *mg;
	SV * const sref = (SV *)GvAV((const GV *)dstr);
	if (SvSMAGICAL(sref) && (mg = mg_find(sref, PERL_MAGIC_isa))) {
	    if (SvTYPE(mg->mg_obj) != SVt_PVAV) {
		AV * const ary = newAV();
		av_push(ary, mg->mg_obj); /* takes the refcount */
		mg->mg_obj = (SV *)ary;
	    }
	    av_push((AV *)mg->mg_obj, SvREFCNT_inc_simple_NN(dstr));
	}
	else sv_magic(sref, dstr, PERL_MAGIC_isa, NULL, 0);
	mro_isa_changed_in(GvSTASH(dstr));
    }
    else if(mro_changes == 3) {
	HV * const stash = GvHV(dstr);
	if(old_stash ? (HV *)HvENAME_get(old_stash) : stash)
	    mro_package_moved(
		stash, old_stash,
		(GV *)dstr, 0
	    );
    }
d3699 1
a3699 1
	location = (SV **) &(GvGP(dstr)->gp_cv); /* XXX bypassing GvCV_set */
d3725 1
a3725 1
		    GvCV_set(dstr, NULL);
d3737 1
a3737 4
		    (CvROOT(cv) || CvXSUB(cv)) &&
		    /* redundant check that avoids creating the extra SV
		       most of the time: */
		    (CvCONST(cv) || ckWARN(WARN_REDEFINE)))
d3739 27
a3765 15
			SV * const new_const_sv =
			    CvCONST((const CV *)sref)
				 ? cv_const_sv((const CV *)sref)
				 : NULL;
			report_redefined_cv(
			   sv_2mortal(Perl_newSVpvf(aTHX_
				"%"HEKf"::%"HEKf,
				HEKfARG(
				 HvNAME_HEK(GvSTASH((const GV *)dstr))
				),
				HEKfARG(GvENAME_HEK(MUTABLE_GV(dstr)))
			   )),
			   cv,
			   CvCONST((const CV *)sref) ? &new_const_sv : NULL
			);
d3768 3
a3770 4
		    cv_ckproto_len_flags(cv, (const GV *)dstr,
				   SvPOK(sref) ? CvPROTO(sref) : NULL,
				   SvPOK(sref) ? CvPROTOLEN(sref) : 0,
                                   SvPOK(sref) ? SvUTF8(sref) : 0);
d3781 3
a3783 65
	if (stype == SVt_PVHV) {
	    const char * const name = GvNAME((GV*)dstr);
	    const STRLEN len = GvNAMELEN(dstr);
	    if (
	        (
	           (len > 1 && name[len-2] == ':' && name[len-1] == ':')
	        || (len == 1 && name[0] == ':')
	        )
	     && (!dref || HvENAME_get(dref))
	    ) {
		mro_package_moved(
		    (HV *)sref, (HV *)dref,
		    (GV *)dstr, 0
		);
	    }
	}
	else if (
	    stype == SVt_PVAV && sref != dref
	 && strEQ(GvNAME((GV*)dstr), "ISA")
	 /* The stash may have been detached from the symbol table, so
	    check its name before doing anything. */
	 && GvSTASH(dstr) && HvENAME(GvSTASH(dstr))
	) {
	    MAGIC *mg;
	    MAGIC * const omg = dref && SvSMAGICAL(dref)
	                         ? mg_find(dref, PERL_MAGIC_isa)
	                         : NULL;
	    if (SvSMAGICAL(sref) && (mg = mg_find(sref, PERL_MAGIC_isa))) {
		if (SvTYPE(mg->mg_obj) != SVt_PVAV) {
		    AV * const ary = newAV();
		    av_push(ary, mg->mg_obj); /* takes the refcount */
		    mg->mg_obj = (SV *)ary;
		}
		if (omg) {
		    if (SvTYPE(omg->mg_obj) == SVt_PVAV) {
			SV **svp = AvARRAY((AV *)omg->mg_obj);
			I32 items = AvFILLp((AV *)omg->mg_obj) + 1;
			while (items--)
			    av_push(
			     (AV *)mg->mg_obj,
			     SvREFCNT_inc_simple_NN(*svp++)
			    );
		    }
		    else
			av_push(
			 (AV *)mg->mg_obj,
			 SvREFCNT_inc_simple_NN(omg->mg_obj)
			);
		}
		else
		    av_push((AV *)mg->mg_obj,SvREFCNT_inc_simple_NN(dstr));
	    }
	    else
	    {
		sv_magic(
		 sref, omg ? omg->mg_obj : dstr, PERL_MAGIC_isa, NULL, 0
		);
		mg = mg_find(sref, PERL_MAGIC_isa);
	    }
	    /* Since the *ISA assignment could have affected more than
	       one stash, don't call mro_isa_changed_in directly, but let
	       magic_clearisa do it for us, as it already has the logic for
	       dealing with globs vs arrays of globs. */
	    assert(mg);
	    Perl_magic_clearisa(aTHX_ NULL, mg);
d3824 1
a3824 1
	sv_unmagic(dstr, PERL_MAGIC_vstring);
d3832 1
a3832 1
	if (dtype != SVt_PVGV && dtype != SVt_PVLV) {
a3847 1
	    case SVt_PVLV:
a3878 1
	    case SVt_PVLV:
d3917 1
a3917 2
	    /* diag_listed_as: Bizarre copy of %s */
	    Perl_croak(aTHX_ "Bizarre copy of %s in %s", type, OP_DESC(PL_op));
d3931 7
d3941 1
a3941 1
	    if (SvTYPE(sstr) != stype)
d3943 1
a3943 2
	}
	if (isGV_with_GP(sstr) && dtype <= SVt_PVLV) {
d3946 2
a3970 1
	    CvAUTOLOAD_off(dstr);
d3977 1
a3977 2
	    /* diag_listed_as: Cannot copy to %s */
	    Perl_croak(aTHX_ "Cannot copy to %s in %s", type, OP_DESC(PL_op));
d3981 1
a3981 1
	if (isGV_with_GP(dstr)
d3998 1
a3998 1
	    if (isGV_with_GP(dstr)) {
d4016 1
a4016 1
    else if (isGV_with_GP(dstr)) {
d4022 1
a4022 1
	    GV *gv = gv_fetchsv_nomg(sstr, GV_ADD, SVt_PVGV);
a4023 17
		const char * const name = GvNAME((const GV *)dstr);
		const STRLEN len = GvNAMELEN(dstr);
		HV *old_stash = NULL;
		bool reset_isa = FALSE;
		if ((len > 1 && name[len-2] == ':' && name[len-1] == ':')
		 || (len == 1 && name[0] == ':')) {
		    /* Set aside the old stash, so we can reset isa caches
		       on its subclasses. */
		    if((old_stash = GvHV(dstr))) {
			/* Make sure we do not lose it early. */
			SvREFCNT_inc_simple_void_NN(
			 sv_2mortal((SV *)old_stash)
			);
		    }
		    reset_isa = TRUE;
		}

d4026 1
a4026 12
		GvGP_set(dstr, gp_ref(GvGP(gv)));

		if (reset_isa) {
		    HV * const stash = GvHV(dstr);
		    if(
		        old_stash ? (HV *)HvENAME_get(old_stash) : stash
		    )
			mro_package_moved(
			 stash, old_stash,
			 (GV *)dstr, 0
			);
		}
d4083 3
a4085 1
                 SvLEN(sstr))             /* and really is a string */
d4203 7
d4211 1
d4335 1
a4335 2
	    Perl_croak(aTHX_ "panic: sv_setpvn called with negative strlen %"
		       IVdf, iv);
a4344 1
    if (SvTYPE(sv) == SVt_PVCV) CvAUTOLOAD_off(sv);
a4393 1
    if (SvTYPE(sv) == SVt_PVCV) CvAUTOLOAD_off(sv);
a4412 47
void
Perl_sv_sethek(pTHX_ register SV *const sv, const HEK *const hek)
{
    dVAR;

    PERL_ARGS_ASSERT_SV_SETHEK;

    if (!hek) {
	return;
    }

    if (HEK_LEN(hek) == HEf_SVKEY) {
	sv_setsv(sv, *(SV**)HEK_KEY(hek));
        return;
    } else {
	const int flags = HEK_FLAGS(hek);
	if (flags & HVhek_WASUTF8) {
	    STRLEN utf8_len = HEK_LEN(hek);
	    char *as_utf8 = (char *)bytes_to_utf8((U8*)HEK_KEY(hek), &utf8_len);
	    sv_usepvn_flags(sv, as_utf8, utf8_len, SV_HAS_TRAILING_NUL);
	    SvUTF8_on(sv);
            return;
	} else if (flags & (HVhek_REHASH|HVhek_UNSHARED)) {
	    sv_setpvn(sv, HEK_KEY(hek), HEK_LEN(hek));
	    if (HEK_UTF8(hek))
		SvUTF8_on(sv);
	    else SvUTF8_off(sv);
            return;
	}
        {
	    SV_CHECK_THINKFIRST_COW_DROP(sv);
	    SvUPGRADE(sv, SVt_PV);
	    SvPV_set(sv,(char *)HEK_KEY(share_hek_hek(hek)));
	    SvCUR_set(sv, HEK_LEN(hek));
	    SvLEN_set(sv, 0);
	    SvREADONLY_on(sv);
	    SvFAKE_on(sv);
	    SvPOK_on(sv);
	    if (HEK_UTF8(hek))
		SvUTF8_on(sv);
	    else SvUTF8_off(sv);
            return;
	}
    }
}


d4419 1
a4419 3
by C<malloc>.  It must be the start of a mallocked block
of memory, and not a pointer to the middle of it.  The
string length, C<len>, must be supplied.  By default
d4425 1
a4425 1
If C<flags> & SV_SMAGIC is true, will call SvSETMAGIC.  If C<flags> &
d4427 2
a4428 2
will be skipped (i.e. the buffer is actually at least 1 byte longer than
C<len>, and already meets the requirements for storing in C<SvPVX>).
d4466 1
a4466 1
	   Specifically Perl_newCONSTSUB is relying on this.  */
d4539 1
a4539 1
we do the copy, and is also used locally.  If C<SV_COW_DROP_PV> is set
d4541 3
a4543 4
SvPOK_off rather than making a copy.  (Used where this
scalar is about to be set to some other value.)  In addition,
the C<flags> parameter gets passed to C<sv_unref_flags()>
when unreffing.  C<sv_force_normal> calls this function
d4597 1
a4597 1
	    Perl_croak_no_modify(aTHX);
d4601 1
a4601 1
	if (SvIsCOW(sv)) {
d4608 3
a4610 8
	    if (flags & SV_COW_DROP_PV) {
		/* OK, so we don't need to copy our buffer.  */
		SvPOK_off(sv);
	    } else {
		SvGROW(sv, len + 1);
		Move(pvx,SvPVX(sv),len,char);
		*SvEND(sv) = '\0';
	    }
d4614 1
a4614 1
	    Perl_croak_no_modify(aTHX);
d4619 2
a4620 2
    else if (SvFAKE(sv) && isGV_with_GP(sv))
	sv_unglob(sv, flags);
d4622 1
a4622 1
	/* Need to downgrade the REGEXP to a simple(r) scalar. This is analogous
d4668 1
a4668 2
string.  Uses the "OOK hack".

a4671 4
The unfortunate similarity of this function's name to that of Perl's C<chop>
operator is strictly coincidental.  This function works from the left;
C<chop> works from the right.

d4682 1
a4682 2
    const U8 *evacp;
    STRLEN evacn;
d4695 2
d4698 1
a4698 1
    if (delta > max_delta)
a4700 1
    /* SvPVX(sv) may move in SV_CHECK_THINKFIRST(sv), so don't use ptr any more */
d4702 4
d4715 1
a4715 1
	SvOOK_on(sv);
d4726 2
d4729 1
a4729 8
    /* how many bytes were evacuated?  we will fill them with sentinel
       bytes, except for the part holding the new offset of course. */
    evacn = delta;
    if (old_delta)
	evacn += (old_delta < 0x100 ? 1 : 1 + sizeof(STRLEN));
    assert(evacn);
    assert(evacn <= delta + old_delta);
    evacp = p - evacn;
a4731 1
    delta += old_delta;
d4744 1
a4744 1
    while (p > evacp) {
d4764 2
a4765 3
If C<flags> has the C<SV_SMAGIC> bit set, will
C<mg_set> on C<dsv> afterwards if appropriate.
C<sv_catpvn> and C<sv_catpvn_nomg> are implemented
a4778 1
    assert((flags & (SV_CATBYTES|SV_CATUTF8)) != (SV_CATBYTES|SV_CATUTF8));
d4780 2
a4781 7
    if (!(flags & SV_CATBYTES) || !SvUTF8(dsv)) {
      if (flags & SV_CATUTF8 && !SvUTF8(dsv)) {
	 sv_utf8_upgrade_flags_grow(dsv, 0, slen + 1);
	 dlen = SvCUR(dsv);
      }
      else SvGROW(dsv, dlen + slen + 1);
      if (sstr == dstr)
d4783 2
a4784 27
      Move(sstr, SvPVX(dsv) + dlen, slen, char);
      SvCUR_set(dsv, SvCUR(dsv) + slen);
    }
    else {
	/* We inline bytes_to_utf8, to avoid an extra malloc. */
	const char * const send = sstr + slen;
	U8 *d;

	/* Something this code does not account for, which I think is
	   impossible; it would require the same pv to be treated as
	   bytes *and* utf8, which would indicate a bug elsewhere. */
	assert(sstr != dstr);

	SvGROW(dsv, dlen + slen * 2 + 1);
	d = (U8 *)SvPVX(dsv) + dlen;

	while (sstr < send) {
	    const UV uv = NATIVE_TO_ASCII((U8)*sstr++);
	    if (UNI_IS_INVARIANT(uv))
		*d++ = (U8)UTF_TO_NATIVE(uv);
	    else {
		*d++ = (U8)UTF8_EIGHT_BIT_HI(uv);
		*d++ = (U8)UTF8_EIGHT_BIT_LO(uv);
	    }
	}
	SvCUR_set(dsv, d-(const U8 *)SvPVX(dsv));
    }
d4803 1
a4803 3
bit set, will C<mg_get> on the C<ssv>, if appropriate, before
reading it.  If the C<flags> contain C<SV_SMAGIC>, C<mg_set> will be
called on the modified SV afterward, if appropriate.  C<sv_catsv>
d4817 1
a4817 1
	const char *spv = SvPV_flags_const(ssv, slen, flags);
d4819 10
d4831 15
a4845 2
	    sv_catpvn_flags(dsv, spv, slen,
			    DO_UTF8(ssv) ? SV_CATUTF8 : SV_CATBYTES);
a4884 18
=for apidoc sv_catpv_flags

Concatenates the string onto the end of the string which is in the SV.
If the SV has the UTF-8 status set, then the bytes appended should
be valid UTF-8.  If C<flags> has the C<SV_SMAGIC> bit set, will C<mg_set>
on the modified SV if appropriate.

=cut
*/

void
Perl_sv_catpv_flags(pTHX_ SV *dstr, const char *sstr, const I32 flags)
{
    PERL_ARGS_ASSERT_SV_CATPV_FLAGS;
    sv_catpvn_flags(dstr, sstr, strlen(sstr), flags);
}

/*
d4912 1
a4912 1
L<perlhacktips/PERL_MEM_LOG>).  The older API is still there for use in XS
d4934 1
a4934 1
Adds magic to an SV, upgrading it if necessary.  Applies the
d5009 1
a5009 1
	       HEf_SVKEY. I think we need to document this aberation of the
d5027 2
a5028 3
Adds magic to an SV.  First upgrades C<sv> to type C<SVt_PVMG> if
necessary, then adds a new magic item of type C<how> to the head of the
magic list.
a5045 2
    unsigned int flags;
    unsigned int vtable_index;
a5048 14
    if (how < 0 || (unsigned)how > C_ARRAY_LENGTH(PL_magic_data)
	|| ((flags = PL_magic_data[how]),
	    (vtable_index = flags & PERL_MAGIC_VTABLE_MASK)
	    > magic_vtable_max))
	Perl_croak(aTHX_ "Don't know how to handle magic of type \\%o", how);

    /* PERL_MAGIC_ext is reserved for use by extensions not perl internals.
       Useful for attaching extension internal data to perl vars.
       Note that multiple extensions may clash if magical scalars
       etc holding private data from one are passed to another. */

    vtable = (vtable_index == magic_vtable_max)
	? NULL : PL_magic_vtables + vtable_index;

d5055 3
a5057 2
	    /* its okay to attach magic to shared strings */
	    !SvIsCOW(sv)
d5060 5
a5064 1
	    && !PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(how)
d5067 1
a5067 1
	    Perl_croak_no_modify(aTHX);
d5086 120
d5220 10
a5229 2
static int
S_sv_unmagicext_flags(pTHX_ SV *const sv, const int type, MGVTBL *vtbl, const U32 flags)
d5234 1
a5234 1
    assert(flags <= 1);
d5240 2
a5241 2
	const MGVTBL* const virt = mg->mg_virtual;
	if (mg->mg_type == type && (!flags || virt == vtbl)) {
d5243 2
a5244 2
	    if (virt && virt->svt_free)
		virt->svt_free(aTHX_ sv, mg);
a5271 30
=for apidoc sv_unmagic

Removes all magic of type C<type> from an SV.

=cut
*/

int
Perl_sv_unmagic(pTHX_ SV *const sv, const int type)
{
    PERL_ARGS_ASSERT_SV_UNMAGIC;
    return S_sv_unmagicext_flags(aTHX_ sv, type, NULL, 0);
}

/*
=for apidoc sv_unmagicext

Removes all magic of type C<type> with the specified C<vtbl> from an SV.

=cut
*/

int
Perl_sv_unmagicext(pTHX_ SV *const sv, const int type, MGVTBL *vtbl)
{
    PERL_ARGS_ASSERT_SV_UNMAGICEXT;
    return S_sv_unmagicext_flags(aTHX_ sv, type, vtbl, 1);
}

/*
d5277 1
a5277 1
associated with that magic.  If the RV is magical, set magic will be
a5297 1
    else if (SvREADONLY(sv)) croak_no_modify();
a5306 5
 *
 * As an optimisation, if there's only one backref and it's not an AV,
 * store it directly in the HvAUX or mg_obj slot, avoiding the need to
 * allocate an AV. (Whether the slot holds an AV tells us whether this is
 * active.)
d5312 3
a5314 2
 * PERL_MAGIC_backref, or in the specific case of a HV, from the
 * xhv_backreferences field. The array is created with a refcount
d5316 9
a5324 10
 * picked on before its parent to have its refcount decremented by the
 * random zapper, it won't actually be freed, meaning it's still there for
 * when its parent gets freed.
 *
 * When the parent SV is freed, the extra ref is killed by
 * Perl_sv_kill_backrefs.  The other ref is killed, in the case of magic,
 * by mg_free() / MGf_REFCOUNTED, or for a hash, by Perl_hv_kill_backrefs.
 *
 * When a single backref SV is stored directly, it is not reference
 * counted.
d5331 1
a5331 3
    SV **svp;
    AV *av = NULL;
    MAGIC *mg = NULL;
a5334 2
    /* find slot to store array or singleton backref */

d5336 1
a5336 10
	svp = (SV**)Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
    } else {
	if (! ((mg =
	    (SvMAGICAL(tsv) ? mg_find(tsv, PERL_MAGIC_backref) : NULL))))
	{
	    sv_magic(tsv, NULL, PERL_MAGIC_backref, NULL, 0);
	    mg = mg_find(tsv, PERL_MAGIC_backref);
	}
	svp = &(mg->mg_obj);
    }
d5338 4
a5341 1
    /* create or retrieve the array */
d5343 15
a5357 12
    if (   (!*svp && SvTYPE(sv) == SVt_PVAV)
	|| (*svp && SvTYPE(*svp) != SVt_PVAV)
    ) {
	/* create array */
	av = newAV();
	AvREAL_off(av);
	SvREFCNT_inc_simple_void(av);
	/* av now has a refcnt of 2; see discussion above */
	if (*svp) {
	    /* move single existing backref to the array */
	    av_extend(av, 1);
	    AvARRAY(av)[++AvFILLp(av)] = *svp; /* av_push() */
d5359 3
a5361 1
	*svp = (SV*)av;
d5363 7
a5369 9
	    mg->mg_flags |= MGf_REFCOUNTED;
    }
    else
	av = MUTABLE_AV(*svp);

    if (!av) {
	/* optimisation: store single backref directly in HvAUX or mg_obj */
	*svp = sv;
	return;
a5370 2
    /* push new backref */
    assert(SvTYPE(av) == SVt_PVAV);
d5381 2
a5382 2
void
Perl_sv_del_backref(pTHX_ SV *const tsv, SV *const sv)
d5385 3
a5387 1
    SV **svp = NULL;
d5391 6
a5396 3
    if (SvTYPE(tsv) == SVt_PVHV) {
	if (SvOOK(tsv))
	    svp = (SV**)Perl_hv_backreferences_p(aTHX_ MUTABLE_HV(tsv));
d5398 2
a5399 26
    else if (SvIS_FREED(tsv) && PL_phase == PERL_PHASE_DESTRUCT) {
	/* It's possible for the the last (strong) reference to tsv to have
	   become freed *before* the last thing holding a weak reference.
	   If both survive longer than the backreferences array, then when
	   the referent's reference count drops to 0 and it is freed, it's
	   not able to chase the backreferences, so they aren't NULLed.

	   For example, a CV holds a weak reference to its stash. If both the
	   CV and the stash survive longer than the backreferences array,
	   and the CV gets picked for the SvBREAK() treatment first,
	   *and* it turns out that the stash is only being kept alive because
	   of an our variable in the pad of the CV, then midway during CV
	   destruction the stash gets freed, but CvSTASH() isn't set to NULL.
	   It ends up pointing to the freed HV. Hence it's chased in here, and
	   if this block wasn't here, it would hit the !svp panic just below.

	   I don't believe that "better" destruction ordering is going to help
	   here - during global destruction there's always going to be the
	   chance that something goes out of order. We've tried to make it
	   foolproof before, and it only resulted in evolutionary pressure on
	   fools. Which made us look foolish for our hubris. :-(
	*/
	return;
    }
    else {
	MAGIC *const mg
d5401 2
a5402 1
	svp =  mg ? &(mg->mg_obj) : NULL;
d5405 4
a5408 12
    if (!svp)
	Perl_croak(aTHX_ "panic: del_backref, svp=0");
    if (!*svp) {
	/* It's possible that sv is being freed recursively part way through the
	   freeing of tsv. If this happens, the backreferences array of tsv has
	   already been freed, and so svp will be NULL. If this is the case,
	   we should not panic. Instead, nothing needs doing, so return.  */
	if (PL_phase == PERL_PHASE_DESTRUCT && SvREFCNT(tsv) == 0)
	    return;
	Perl_croak(aTHX_ "panic: del_backref, *svp=%p phase=%s refcnt=%" UVuf,
		   *svp, PL_phase_names[PL_phase], (UV)SvREFCNT(tsv));
    }
d5410 13
a5422 45
    if (SvTYPE(*svp) == SVt_PVAV) {
#ifdef DEBUGGING
	int count = 1;
#endif
	AV * const av = (AV*)*svp;
	SSize_t fill;
	assert(!SvIS_FREED(av));
	fill = AvFILLp(av);
	assert(fill > -1);
	svp = AvARRAY(av);
	/* for an SV with N weak references to it, if all those
	 * weak refs are deleted, then sv_del_backref will be called
	 * N times and O(N^2) compares will be done within the backref
	 * array. To ameliorate this potential slowness, we:
	 * 1) make sure this code is as tight as possible;
	 * 2) when looking for SV, look for it at both the head and tail of the
	 *    array first before searching the rest, since some create/destroy
	 *    patterns will cause the backrefs to be freed in order.
	 */
	if (*svp == sv) {
	    AvARRAY(av)++;
	    AvMAX(av)--;
	}
	else {
	    SV **p = &svp[fill];
	    SV *const topsv = *p;
	    if (topsv != sv) {
#ifdef DEBUGGING
		count = 0;
#endif
		while (--p > svp) {
		    if (*p == sv) {
			/* We weren't the last entry.
			   An unordered list has this property that you
			   can take the last element off the end to fill
			   the hole, and it's still an unordered list :-)
			*/
			*p = topsv;
#ifdef DEBUGGING
			count++;
#else
			break; /* should only be one */
#endif
		    }
		}
d5424 2
a5426 11
	assert(count ==1);
	AvFILLp(av) = fill-1;
    }
    else if (SvIS_FREED(*svp) && PL_phase == PERL_PHASE_DESTRUCT) {
	/* freed AV; skip */
    }
    else {
	/* optimisation: only a single backref, stored directly */
	if (*svp != sv)
	    Perl_croak(aTHX_ "panic: del_backref, *svp=%p, sv=%p", *svp, sv);
	*svp = NULL;
a5427 1

d5430 1
a5430 1
void
d5433 1
a5433 3
    SV **svp;
    SV **last;
    bool is_array;
d5436 1
d5438 3
a5440 26
    if (!av)
	return;

    /* after multiple passes through Perl_sv_clean_all() for a thinngy
     * that has badly leaked, the backref array may have gotten freed,
     * since we only protect it against 1 round of cleanup */
    if (SvIS_FREED(av)) {
	if (PL_in_clean_all) /* All is fair */
	    return;
	Perl_croak(aTHX_
		   "panic: magic_killbackrefs (freed backref AV/SV)");
    }


    is_array = (SvTYPE(av) == SVt_PVAV);
    if (is_array) {
	assert(!SvIS_FREED(av));
	svp = AvARRAY(av);
	if (svp)
	    last = svp + AvFILLp(av);
    }
    else {
	/* optimisation: only a single backref, stored directly */
	svp = (SV**)&av;
	last = svp;
    }
a5441 1
    if (svp) {
a5446 1
		    assert(SvROK(referrer));
a5452 1
		    assert(SvTYPE(sv) == SVt_PVHV); /* stash backref */
a5456 17
		} else if (SvTYPE(referrer) == SVt_PVCV ||
			   SvTYPE(referrer) == SVt_PVFM) {
		    if (SvTYPE(sv) == SVt_PVHV) { /* stash backref */
			/* You lookin' at me?  */
			assert(CvSTASH(referrer));
			assert(CvSTASH(referrer) == (const HV *)sv);
			SvANY(MUTABLE_CV(referrer))->xcv_stash = 0;
		    }
		    else {
			assert(SvTYPE(sv) == SVt_PVGV);
			/* You lookin' at me?  */
			assert(CvGV(referrer));
			assert(CvGV(referrer) == (const GV *)sv);
			anonymise_cv_maybe(MUTABLE_GV(sv),
						MUTABLE_CV(referrer));
		    }

d5463 1
a5463 2
		if (is_array)
		    *svp = NULL;
d5468 2
a5469 5
    if (is_array) {
	AvFILLp(av) = -1;
	SvREFCNT_dec(av); /* remove extra count added by sv_add_backref() */
    }
    return;
d5475 2
a5476 2
Inserts a string at the specified offset/length within the SV.  Similar to
the Perl substr() function.  Handles get magic.
d5480 1
a5480 2
Same as C<sv_insert>, but the extra C<flags> are passed to the
C<SvPV_force_flags> that applies to C<bigstr>.
d5493 1
a5493 1
    register SSize_t i;		/* better be sizeof(STRLEN) or bad things happen */
d5499 1
a5499 1
	Perl_croak(aTHX_ "Can't modify nonexistent substring");
d5535 1
a5535 2
	Perl_croak(aTHX_ "panic: sv_insert, midend=%p, bigend=%p",
		   midend, bigend);
a5649 39
/* We're about to free a GV which has a CV that refers back to us.
 * If that CV will outlive us, make it anonymous (i.e. fix up its CvGV
 * field) */

STATIC void
S_anonymise_cv_maybe(pTHX_ GV *gv, CV* cv)
{
    SV *gvname;
    GV *anongv;

    PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE;

    /* be assertive! */
    assert(SvREFCNT(gv) == 0);
    assert(isGV(gv) && isGV_with_GP(gv));
    assert(GvGP(gv));
    assert(!CvANON(cv));
    assert(CvGV(cv) == gv);

    /* will the CV shortly be freed by gp_free() ? */
    if (GvCV(gv) == cv && GvGP(gv)->gp_refcnt < 2 && SvREFCNT(cv) < 2) {
	SvANY(cv)->xcv_gv = NULL;
	return;
    }

    /* if not, anonymise: */
    gvname = (GvSTASH(gv) && HvNAME(GvSTASH(gv)) && HvENAME(GvSTASH(gv)))
                    ? newSVhek(HvENAME_HEK(GvSTASH(gv)))
                    : newSVpvn_flags( "__ANON__", 8, 0 );
    sv_catpvs(gvname, "::__ANON__");
    anongv = gv_fetchsv(gvname, GV_ADDMULTI, SVt_PVCV);
    SvREFCNT_dec(gvname);

    CvANON_on(cv);
    CvCVGV_RC_on(cv);
    SvANY(cv)->xcv_gv = MUTABLE_GV(SvREFCNT_inc(anongv));
}


d5654 1
a5654 1
and free the body itself.  The SV's head is I<not> freed, although
d5657 1
a5657 1
This function should only be called when REFCNT is zero.  Most of the time
d5665 1
a5665 1
Perl_sv_clear(pTHX_ SV *const orig_sv)
d5668 3
a5671 6
    U32 type;
    const struct body_details *sv_type_details;
    SV* iter_sv = NULL;
    SV* next_sv = NULL;
    register SV *sv = orig_sv;
    STRLEN hash_index;
d5674 2
d5677 10
a5686 46
    /* within this loop, sv is the SV currently being freed, and
     * iter_sv is the most recent AV or whatever that's being iterated
     * over to provide more SVs */

    while (sv) {

	type = SvTYPE(sv);

	assert(SvREFCNT(sv) == 0);
	assert(SvTYPE(sv) != (svtype)SVTYPEMASK);

	if (type <= SVt_IV) {
	    /* See the comment in sv.h about the collusion between this
	     * early return and the overloading of the NULL slots in the
	     * size table.  */
	    if (SvROK(sv))
		goto free_rv;
	    SvFLAGS(sv) &= SVf_BREAK;
	    SvFLAGS(sv) |= SVTYPEMASK;
	    goto free_head;
	}

	assert(!SvOBJECT(sv) || type >= SVt_PVMG); /* objs are always >= MG */

	if (type >= SVt_PVMG) {
	    if (SvOBJECT(sv)) {
		if (!curse(sv, 1)) goto get_next_sv;
		type = SvTYPE(sv); /* destructor may have changed it */
	    }
	    /* Free back-references before magic, in case the magic calls
	     * Perl code that has weak references to sv. */
	    if (type == SVt_PVHV) {
		Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
		if (SvMAGIC(sv))
		    mg_free(sv);
	    }
	    else if (type == SVt_PVMG && SvPAD_OUR(sv)) {
		SvREFCNT_dec(SvOURSTASH(sv));
	    } else if (SvMAGIC(sv)) {
		/* Free back-references before other types of magic. */
		sv_unmagic(sv, PERL_MAGIC_backref);
		mg_free(sv);
	    }
	    SvMAGICAL_off(sv);
	    if (type == SVt_PVMG && SvPAD_TYPED(sv))
		SvREFCNT_dec(SvSTASH(sv));
d5688 4
a5691 85
	switch (type) {
	    /* case SVt_BIND: */
	case SVt_PVIO:
	    if (IoIFP(sv) &&
		IoIFP(sv) != PerlIO_stdin() &&
		IoIFP(sv) != PerlIO_stdout() &&
		IoIFP(sv) != PerlIO_stderr() &&
		!(IoFLAGS(sv) & IOf_FAKE_DIRP))
	    {
		io_close(MUTABLE_IO(sv), FALSE);
	    }
	    if (IoDIRP(sv) && !(IoFLAGS(sv) & IOf_FAKE_DIRP))
		PerlDir_close(IoDIRP(sv));
	    IoDIRP(sv) = (DIR*)NULL;
	    Safefree(IoTOP_NAME(sv));
	    Safefree(IoFMT_NAME(sv));
	    Safefree(IoBOTTOM_NAME(sv));
	    if ((const GV *)sv == PL_statgv)
		PL_statgv = NULL;
	    goto freescalar;
	case SVt_REGEXP:
	    /* FIXME for plugins */
	    pregfree2((REGEXP*) sv);
	    goto freescalar;
	case SVt_PVCV:
	case SVt_PVFM:
	    cv_undef(MUTABLE_CV(sv));
	    /* If we're in a stash, we don't own a reference to it.
	     * However it does have a back reference to us, which needs to
	     * be cleared.  */
	    if ((stash = CvSTASH(sv)))
		sv_del_backref(MUTABLE_SV(stash), sv);
	    goto freescalar;
	case SVt_PVHV:
	    if (PL_last_swash_hv == (const HV *)sv) {
		PL_last_swash_hv = NULL;
	    }
	    if (HvTOTALKEYS((HV*)sv) > 0) {
		const char *name;
		/* this statement should match the one at the beginning of
		 * hv_undef_flags() */
		if (   PL_phase != PERL_PHASE_DESTRUCT
		    && (name = HvNAME((HV*)sv)))
		{
		    if (PL_stashcache)
			(void)hv_delete(PL_stashcache, name,
			    HvNAMEUTF8((HV*)sv) ? -HvNAMELEN_get((HV*)sv) : HvNAMELEN_get((HV*)sv), G_DISCARD);
		    hv_name_set((HV*)sv, NULL, 0, 0);
		}

		/* save old iter_sv in unused SvSTASH field */
		assert(!SvOBJECT(sv));
		SvSTASH(sv) = (HV*)iter_sv;
		iter_sv = sv;

		/* save old hash_index in unused SvMAGIC field */
		assert(!SvMAGICAL(sv));
		assert(!SvMAGIC(sv));
		((XPVMG*) SvANY(sv))->xmg_u.xmg_hash_index = hash_index;
		hash_index = 0;

		next_sv = Perl_hfree_next_entry(aTHX_ (HV*)sv, &hash_index);
		goto get_next_sv; /* process this new sv */
	    }
	    /* free empty hash */
	    Perl_hv_undef_flags(aTHX_ MUTABLE_HV(sv), HV_NAME_SETALL);
	    assert(!HvARRAY((HV*)sv));
	    break;
	case SVt_PVAV:
	    {
		AV* av = MUTABLE_AV(sv);
		if (PL_comppad == av) {
		    PL_comppad = NULL;
		    PL_curpad = NULL;
		}
		if (AvREAL(av) && AvFILLp(av) > -1) {
		    next_sv = AvARRAY(av)[AvFILLp(av)--];
		    /* save old iter_sv in top-most slot of AV,
		     * and pray that it doesn't get wiped in the meantime */
		    AvARRAY(av)[AvMAX(av)] = iter_sv;
		    iter_sv = sv;
		    goto get_next_sv; /* process this new sv */
		}
		Safefree(AvALLOC(av));
	    }
d5693 18
a5710 46
	    break;
	case SVt_PVLV:
	    if (LvTYPE(sv) == 'T') { /* for tie: return HE to pool */
		SvREFCNT_dec(HeKEY_sv((HE*)LvTARG(sv)));
		HeNEXT((HE*)LvTARG(sv)) = PL_hv_fetch_ent_mh;
		PL_hv_fetch_ent_mh = (HE*)LvTARG(sv);
	    }
	    else if (LvTYPE(sv) != 't') /* unless tie: unrefcnted fake SV**  */
		SvREFCNT_dec(LvTARG(sv));
	case SVt_PVGV:
	    if (isGV_with_GP(sv)) {
		if(GvCVu((const GV *)sv) && (stash = GvSTASH(MUTABLE_GV(sv)))
		   && HvENAME_get(stash))
		    mro_method_changed_in(stash);
		gp_free(MUTABLE_GV(sv));
		if (GvNAME_HEK(sv))
		    unshare_hek(GvNAME_HEK(sv));
		/* If we're in a stash, we don't own a reference to it.
		 * However it does have a back reference to us, which
		 * needs to be cleared.  */
		if (!SvVALID(sv) && (stash = GvSTASH(sv)))
			sv_del_backref(MUTABLE_SV(stash), sv);
	    }
	    /* FIXME. There are probably more unreferenced pointers to SVs
	     * in the interpreter struct that we should check and tidy in
	     * a similar fashion to this:  */
	    /* See also S_sv_unglob, which does the same thing. */
	    if ((const GV *)sv == PL_last_in_gv)
		PL_last_in_gv = NULL;
	    else if ((const GV *)sv == PL_statgv)
		PL_statgv = NULL;
	case SVt_PVMG:
	case SVt_PVNV:
	case SVt_PVIV:
	case SVt_PV:
	  freescalar:
	    /* Don't bother with SvOOK_off(sv); as we're only going to
	     * free it.  */
	    if (SvOOK(sv)) {
		STRLEN offset;
		SvOOK_offset(sv, offset);
		SvPV_set(sv, SvPVX_mutable(sv) - offset);
		/* Don't even bother with turning off the OOK flag.  */
	    }
	    if (SvROK(sv)) {
	    free_rv:
d5712 19
a5730 21
		    SV * const target = SvRV(sv);
		    if (SvWEAKREF(sv))
			sv_del_backref(target, sv);
		    else
			next_sv = target;
		}
	    }
#ifdef PERL_OLD_COPY_ON_WRITE
	    else if (SvPVX_const(sv)
		     && !(SvTYPE(sv) == SVt_PVIO
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP)))
	    {
		if (SvIsCOW(sv)) {
		    if (DEBUG_C_TEST) {
			PerlIO_printf(Perl_debug_log, "Copy on write: clear\n");
			sv_dump(sv);
		    }
		    if (SvLEN(sv)) {
			sv_release_COW(sv, SvPVX_const(sv), SV_COW_NEXT_SV(sv));
		    } else {
			unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
d5732 1
a5732 4

		    SvFAKE_off(sv);
		} else if (SvLEN(sv)) {
		    Safefree(SvPVX_const(sv));
d5734 1
a5734 15
	    }
#else
	    else if (SvPVX_const(sv) && SvLEN(sv)
		     && !(SvTYPE(sv) == SVt_PVIO
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP)))
		Safefree(SvPVX_mutable(sv));
	    else if (SvPVX_const(sv) && SvIsCOW(sv)) {
		unshare_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sv)));
		SvFAKE_off(sv);
	    }
#endif
	    break;
	case SVt_NV:
	    break;
	}
a5735 1
      free_body:
d5737 6
a5742 58
	SvFLAGS(sv) &= SVf_BREAK;
	SvFLAGS(sv) |= SVTYPEMASK;

	sv_type_details = bodies_by_type + type;
	if (sv_type_details->arena) {
	    del_body(((char *)SvANY(sv) + sv_type_details->offset),
		     &PL_body_roots[type]);
	}
	else if (sv_type_details->body_size) {
	    safefree(SvANY(sv));
	}

      free_head:
	/* caller is responsible for freeing the head of the original sv */
	if (sv != orig_sv && !SvREFCNT(sv))
	    del_SV(sv);

	/* grab and free next sv, if any */
      get_next_sv:
	while (1) {
	    sv = NULL;
	    if (next_sv) {
		sv = next_sv;
		next_sv = NULL;
	    }
	    else if (!iter_sv) {
		break;
	    } else if (SvTYPE(iter_sv) == SVt_PVAV) {
		AV *const av = (AV*)iter_sv;
		if (AvFILLp(av) > -1) {
		    sv = AvARRAY(av)[AvFILLp(av)--];
		}
		else { /* no more elements of current AV to free */
		    sv = iter_sv;
		    type = SvTYPE(sv);
		    /* restore previous value, squirrelled away */
		    iter_sv = AvARRAY(av)[AvMAX(av)];
		    Safefree(AvALLOC(av));
		    goto free_body;
		}
	    } else if (SvTYPE(iter_sv) == SVt_PVHV) {
		sv = Perl_hfree_next_entry(aTHX_ (HV*)iter_sv, &hash_index);
		if (!sv && !HvTOTALKEYS((HV *)iter_sv)) {
		    /* no more elements of current HV to free */
		    sv = iter_sv;
		    type = SvTYPE(sv);
		    /* Restore previous values of iter_sv and hash_index,
		     * squirrelled away */
		    assert(!SvOBJECT(sv));
		    iter_sv = (SV*)SvSTASH(sv);
		    assert(!SvMAGICAL(sv));
		    hash_index = ((XPVMG*) SvANY(sv))->xmg_u.xmg_hash_index;

		    /* free any remaining detritus from the hash struct */
		    Perl_hv_undef_flags(aTHX_ MUTABLE_HV(sv), HV_NAME_SETALL);
		    assert(!HvARRAY((HV*)sv));
		    goto free_body;
		}
d5744 1
d5746 111
a5856 1
	    /* unrolled SvREFCNT_dec and sv_free2 follows: */
d5858 12
a5869 15
	    if (!sv)
		continue;
	    if (!SvREFCNT(sv)) {
		sv_free(sv);
		continue;
	    }
	    if (--(SvREFCNT(sv)))
		continue;
#ifdef DEBUGGING
	    if (SvTEMP(sv)) {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING),
			 "Attempt to free temp prematurely: SV 0x%"UVxf
			 pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
		continue;
	    }
d5871 4
a5874 17
	    if (SvREADONLY(sv) && SvIMMORTAL(sv)) {
		/* make sure SvREFCNT(sv)==0 happens very seldom */
		SvREFCNT(sv) = (~(U32)0)/2;
		continue;
	    }
	    break;
	} /* while 1 */

    } /* while sv */
}

/* This routine curses the sv itself, not the object referenced by sv. So
   sv does not have to be ROK. */

static bool
S_curse(pTHX_ SV * const sv, const bool check_refcnt) {
    dVAR;
d5876 2
a5877 2
    PERL_ARGS_ASSERT_CURSE;
    assert(SvOBJECT(sv));
d5879 3
a5881 59
    if (PL_defstash &&	/* Still have a symbol table? */
	SvDESTROYABLE(sv))
    {
	dSP;
	HV* stash;
	do {
	    CV* destructor;
	    stash = SvSTASH(sv);
	    destructor = StashHANDLER(stash,DESTROY);
	    if (destructor
		/* A constant subroutine can have no side effects, so
		   don't bother calling it.  */
		&& !CvCONST(destructor)
		/* Don't bother calling an empty destructor or one that
		   returns immediately. */
		&& (CvISXSUB(destructor)
		|| (CvSTART(destructor)
		    && (CvSTART(destructor)->op_next->op_type
					!= OP_LEAVESUB)
		    && (CvSTART(destructor)->op_next->op_type
					!= OP_PUSHMARK
			|| CvSTART(destructor)->op_next->op_next->op_type
					!= OP_RETURN
		       )
		   ))
	       )
	    {
		SV* const tmpref = newRV(sv);
		SvREADONLY_on(tmpref); /* DESTROY() could be naughty */
		ENTER;
		PUSHSTACKi(PERLSI_DESTROY);
		EXTEND(SP, 2);
		PUSHMARK(SP);
		PUSHs(tmpref);
		PUTBACK;
		call_sv(MUTABLE_SV(destructor),
			    G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
		POPSTACK;
		SPAGAIN;
		LEAVE;
		if(SvREFCNT(tmpref) < 2) {
		    /* tmpref is not kept alive! */
		    SvREFCNT(sv)--;
		    SvRV_set(tmpref, NULL);
		    SvROK_off(tmpref);
		}
		SvREFCNT_dec(tmpref);
	    }
	} while (SvOBJECT(sv) && SvSTASH(sv) != stash);


	if (check_refcnt && SvREFCNT(sv)) {
	    if (PL_in_clean_objs)
		Perl_croak(aTHX_
		  "DESTROY created new reference to dead object '%"HEKf"'",
		   HEKfARG(HvNAME_HEK(stash)));
	    /* DESTROY gave object new lease on life */
	    return FALSE;
	}
d5883 2
a5884 6

    if (SvOBJECT(sv)) {
	SvREFCNT_dec(SvSTASH(sv)); /* possibly of changed persuasion */
	SvOBJECT_off(sv);	/* Curse the object. */
	if (SvTYPE(sv) != SVt_PVIO)
	    --PL_sv_objcount;/* XXX Might want something more general */
a5885 1
    return TRUE;
d5891 1
a5891 1
Increment an SV's reference count.  Use the C<SvREFCNT_inc()> wrapper
d5993 1
a5993 1
Returns the length of the string in the SV.  Handles magic and type
d6018 1
a6018 1
UTF-8 bytes as a single character.  Handles magic and type coercion.
d6049 2
a6050 12
	    if (mg && (mg->mg_len != -1 || mg->mg_ptr)) {
		if (mg->mg_len != -1)
		    ulen = mg->mg_len;
		else {
		    /* We can use the offset cache for a headstart.
		       The longer value is stored in the first pair.  */
		    STRLEN *cache = (STRLEN *) mg->mg_ptr;

		    ulen = cache[0] + Perl_utf8_length(aTHX_ s + cache[1],
						       s + len);
		}
		
d6053 10
a6062 1
		    assert_uft8_cache_coherent("sv_len_utf8", ulen, real, sv);
d6067 13
a6079 1
		utf8_mg_len_cache_update(sv, &mg, ulen);
d6091 1
a6091 1
		      STRLEN *const uoffset_p, bool *const at_end)
a6093 1
    STRLEN uoffset = *uoffset_p;
d6097 1
a6097 2
    while (s < send && uoffset) {
	--uoffset;
d6099 1
a6099 6
    }
    if (s == send) {
	*at_end = TRUE;
    }
    else if (s > send) {
	*at_end = TRUE;
a6103 1
    *uoffset_p -= uoffset;
d6112 1
a6112 1
		    STRLEN uoffset, const STRLEN uend)
d6122 1
a6122 8
	const U8 *s = start;

	while (s < send && uoffset--)
	    s += UTF8SKIP(s);
	assert (s <= send);
	if (s > send)
	    s = send;
	return s - start;
d6143 1
a6143 1
		    const U8 *const send, STRLEN uoffset,
a6147 1
    bool at_end = FALSE;
a6152 3
    if (!uoffset)
	return 0;

a6181 1
		    uoffset -= uoffset0;
d6184 1
a6184 2
					      send, &uoffset, &at_end);
		    uoffset += uoffset0;
d6222 15
a6236 9
	STRLEN real_boffset;
	uoffset -= uoffset0;
	real_boffset = boffset0 + sv_pos_u2b_forwards(start + boffset0,
						      send, &uoffset, &at_end);
	uoffset += uoffset0;

	if (found && PL_utf8cache < 0)
	    assert_uft8_cache_coherent("sv_pos_u2b_cache", boffset,
				       real_boffset, sv);
d6240 2
a6241 6
    if (PL_utf8cache) {
	if (at_end)
	    utf8_mg_len_cache_update(sv, mgp, uoffset);
	else
	    utf8_mg_pos_cache_update(sv, mgp, boffset, uoffset, send - start);
    }
d6252 1
a6252 2
the offset, rather than from the start
of the string.  Handles type coercion.
d6282 1
a6282 3
	if (lenp
	    && *lenp /* don't bother doing work for 0, as its bytes equivalent
			is 0, and *lenp is already set to that.  */) {
d6306 1
a6306 1
the offset, rather than from the start of the string.  Handles magic and
a6339 20
static void
S_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp,
			   const STRLEN ulen)
{
    PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE;
    if (SvREADONLY(sv))
	return;

    if (!*mgp && (SvTYPE(sv) < SVt_PVMG ||
		  !(*mgp = mg_find(sv, PERL_MAGIC_utf8)))) {
	*mgp = sv_magicext(sv, 0, PERL_MAGIC_utf8, &PL_vtbl_utf8, 0, 0);
    }
    assert(*mgp);

    (*mgp)->mg_len = ulen;
    /* For now, treat "overflowed" as "still unknown". See RT #72924.  */
    if (ulen != (STRLEN) (*mgp)->mg_len)
	(*mgp)->mg_len = -1;
}

d6398 8
a6405 2
	assert_uft8_cache_coherent("utf8_mg_pos_cache_update", utf8, realutf8,
				   sv);
d6435 1
a6435 1
	   calculation in bytes simply because we always know the byte
d6568 1
a6568 2
	Perl_croak(aTHX_ "panic: sv_pos_b2u: bad byte offset, blen=%"UVuf
		   ", byte=%"UVuf, (UV)blen, (UV)byte);
d6626 11
a6636 2
	if (found && PL_utf8cache < 0)
	    assert_uft8_cache_coherent("sv_pos_b2u", len, real_len, sv);
d6641 2
a6642 25
    if (PL_utf8cache) {
	if (blen == byte)
	    utf8_mg_len_cache_update(sv, &mg, len);
	else
	    utf8_mg_pos_cache_update(sv, &mg, byte, len, blen);
    }
}

static void
S_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache,
			     STRLEN real, SV *const sv)
{
    PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT;

    /* As this is debugging only code, save space by keeping this test here,
       rather than inlining it in all the callers.  */
    if (from_cache == real)
	return;

    /* Need to turn the assertions off otherwise we may recurse infinitely
       while printing error messages.  */
    SAVEI8(PL_utf8cache);
    PL_utf8cache = 0;
    Perl_croak(aTHX_ "panic: %s cache %"UVuf" real %"UVuf" for %"SVf,
	       func, (UV) from_cache, (UV) real, SVfARG(sv));
d6649 1
a6649 1
identical.  Is UTF-8 and 'use bytes' aware, handles get magic, and will
a6651 6
=for apidoc sv_eq_flags

Returns a boolean indicating whether the strings in the two SVs are
identical.  Is UTF-8 and 'use bytes' aware and coerces its args to strings
if necessary.  If the flags include SV_GMAGIC, it handles get-magic, too.

d6656 1
a6656 1
Perl_sv_eq_flags(pTHX_ register SV *sv1, register SV *sv2, const U32 flags)
d6664 1
d6673 2
a6674 4
	 * invalidate pv1 (if we are handling magic), so we may need to
	 * make a copy */
	if (sv1 == sv2 && flags & SV_GMAGIC
	 && (SvTHINKFIRST(sv1) || SvGMAGICAL(sv1))) {
d6678 1
a6678 1
	pv1 = SvPV_flags_const(sv1, cur1, flags);
d6686 1
a6686 1
	pv2 = SvPV_flags_const(sv2, cur2, flags);
d6709 2
d6712 6
a6717 3
		  /* sv1 is the UTF-8 one  */
		  return bytes_cmp_utf8((const U8*)pv2, cur2,
					(const U8*)pv1, cur1) == 0;
d6720 11
a6730 3
		  /* sv2 is the UTF-8 one  */
		  return bytes_cmp_utf8((const U8*)pv1, cur1,
					(const U8*)pv2, cur2) == 0;
d6739 2
d6750 1
a6750 1
C<sv2>.  Is UTF-8 and 'use bytes' aware, handles get magic, and will
a6752 8
=for apidoc sv_cmp_flags

Compares the strings in two SVs.  Returns -1, 0, or 1 indicating whether the
string in C<sv1> is less than, equal to, or greater than the string in
C<sv2>.  Is UTF-8 and 'use bytes' aware and will coerce its args to strings
if necessary.  If the flags include SV_GMAGIC, it handles get magic.  See
also C<sv_cmp_locale_flags>.

a6758 7
    return sv_cmp_flags(sv1, sv2, SV_GMAGIC);
}

I32
Perl_sv_cmp_flags(pTHX_ register SV *const sv1, register SV *const sv2,
		  const U32 flags)
{
d6771 1
a6771 1
	pv1 = SvPV_flags_const(sv1, cur1, flags);
d6778 1
a6778 1
	pv2 = SvPV_flags_const(sv2, cur2, flags);
d6790 1
a6790 3
		const int retval = -bytes_cmp_utf8((const U8*)pv2, cur2,
						   (const U8*)pv1, cur1);
		return retval ? retval < 0 ? -1 : +1 : 0;
d6800 1
a6800 3
		const int retval = bytes_cmp_utf8((const U8*)pv1, cur1,
						  (const U8*)pv2, cur2);
		return retval ? retval < 0 ? -1 : +1 : 0;
d6831 1
a6831 1
Compares the strings in two SVs in a locale-aware manner.  Is UTF-8 and
a6834 6
=for apidoc sv_cmp_locale_flags

Compares the strings in two SVs in a locale-aware manner.  Is UTF-8 and
'use bytes' aware and will coerce its args to strings if necessary.  If the
flags contain SV_GMAGIC, it handles get magic.  See also C<sv_cmp_flags>.

a6840 7
    return sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC);
}

I32
Perl_sv_cmp_locale_flags(pTHX_ register SV *const sv1, register SV *const sv2,
			 const U32 flags)
{
d6852 1
a6852 1
    pv1 = sv1 ? sv_collxfrm_flags(sv1, &len1, flags) : (char *) NULL;
d6854 1
a6854 1
    pv2 = sv2 ? sv_collxfrm_flags(sv2, &len2, flags) : (char *) NULL;
d6893 1
a6893 7
This calls C<sv_collxfrm_flags> with the SV_GMAGIC flag.  See
C<sv_collxfrm_flags>.

=for apidoc sv_collxfrm_flags

Add Collate Transform magic to an SV if it doesn't already have it.  If the
flags contain SV_GMAGIC, it handles get-magic.
d6904 1
a6904 1
Perl_sv_collxfrm_flags(pTHX_ SV *const sv, STRLEN *const nxp, const I32 flags)
d6909 1
a6909 1
    PERL_ARGS_ASSERT_SV_COLLXFRM_FLAGS;
d6919 1
a6919 1
	s = SvPV_flags_const(sv, len, flags);
a6951 49
static char *
S_sv_gets_append_to_utf8(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
{
    SV * const tsv = newSV(0);
    ENTER;
    SAVEFREESV(tsv);
    sv_gets(tsv, fp, 0);
    sv_utf8_upgrade_nomg(tsv);
    SvCUR_set(sv,append);
    sv_catsv(sv,tsv);
    LEAVE;
    return (SvCUR(sv) - append) ? SvPVX(sv) : NULL;
}

static char *
S_sv_gets_read_record(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
{
    I32 bytesread;
    const U32 recsize = SvUV(SvRV(PL_rs)); /* RsRECORD() guarantees > 0. */
      /* Grab the size of the record we're getting */
    char *const buffer = SvGROW(sv, (STRLEN)(recsize + append + 1)) + append;
#ifdef VMS
    int fd;
#endif

    /* Go yank in */
#ifdef VMS
    /* VMS wants read instead of fread, because fread doesn't respect */
    /* RMS record boundaries. This is not necessarily a good thing to be */
    /* doing, but we've got no other real choice - except avoid stdio
       as implementation - perhaps write a :vms layer ?
    */
    fd = PerlIO_fileno(fp);
    if (fd != -1) {
	bytesread = PerlLIO_read(fd, buffer, recsize);
    }
    else /* in-memory file from PerlIO::Scalar */
#endif
    {
	bytesread = PerlIO_read(fp, buffer, recsize);
    }

    if (bytesread < 0)
	bytesread = 0;
    SvCUR_set(sv, bytesread + append);
    buffer[bytesread] = '\0';
    return (SvCUR(sv) - append) ? SvPVX(sv) : NULL;
}

d6993 7
a6999 1
	    return S_sv_gets_append_to_utf8(aTHX_ sv, fp, append);
a7003 3
    if (!append) {
        SvCUR_set(sv,0);
    }
d7029 32
a7060 1
	return S_sv_gets_read_record(aTHX_ sv, fp, append);
a7169 2
		assert (!shortbuffered);
		goto cannot_be_shortbuffered;
a7182 1
    cannot_be_shortbuffered:
d7187 2
a7188 2

	DEBUG_Pv(PerlIO_printf(Perl_debug_log,
d7192 1
a7192 1

d7197 2
a7198 2

	DEBUG_Pv(PerlIO_printf(Perl_debug_log,
d7202 1
a7202 1

d7263 1
a7263 1
	    /* Accommodate broken VAXC compiler, which applies U8 cast to
d7315 1
d7323 1
a7323 1
if necessary.  Handles 'get' magic and operator overloading.
a7330 18
    if (!sv)
	return;
    SvGETMAGIC(sv);
    sv_inc_nomg(sv);
}

/*
=for apidoc sv_inc_nomg

Auto-increment of the value in the SV, doing string to numeric conversion
if necessary.  Handles operator overloading.  Skips handling 'get' magic.

=cut
*/

void
Perl_sv_inc_nomg(pTHX_ register SV *const sv)
{
d7337 1
d7339 1
a7339 1
	if (SvIsCOW(sv) || isGV_with_GP(sv))
d7343 1
a7343 1
		Perl_croak_no_modify(aTHX);
d7347 1
a7347 1
	    if (SvAMAGIC(sv) && AMG_CALLunary(sv, inc_amg))
a7385 1
	    /* diag_listed_as: Lost precision when %s %f by 1 */
d7487 1
a7487 1
if necessary.  Handles 'get' magic and operator overloading.
a7495 19
    if (!sv)
	return;
    SvGETMAGIC(sv);
    sv_dec_nomg(sv);
}

/*
=for apidoc sv_dec_nomg

Auto-decrement of the value in the SV, doing string to numeric conversion
if necessary.  Handles operator overloading.  Skips handling 'get' magic.

=cut
*/

void
Perl_sv_dec_nomg(pTHX_ register SV *const sv)
{
    dVAR;
d7500 1
d7502 1
a7502 1
	if (SvIsCOW(sv) || isGV_with_GP(sv))
d7506 1
a7506 1
		Perl_croak_no_modify(aTHX);
d7510 1
a7510 1
	    if (SvAMAGIC(sv) && AMG_CALLunary(sv, dec_amg))
a7551 1
		/* diag_listed_as: Lost precision when %s %f by 1 */
d7619 1
a7619 1
The new SV is marked as mortal.  It will be destroyed "soon", either by an
d7648 1
a7648 1
set to 1.  It will be destroyed "soon", either by an explicit call to
d7676 2
a7677 3
If C<SVs_TEMP> is set, then C<sv_2mortal()> is called on the result before
returning.  If C<SVf_UTF8> is set, C<s>
is considered to be in UTF-8 and the
d7700 1
a7700 1
     * and do what it does ourselves here.
d7704 1
a7704 1
     * eliminate quite a few steps than it looks - Yves (explaining patch by gfx)
d7722 1
a7722 1
string buffer can be "stolen" if this SV is copied.  See also C<sv_newmortal>
d7765 4
a7768 6
Creates a new SV and copies a buffer into it, which may contain NUL characters
(C<\0>) and other binary data.  The reference count for the SV is set to 1.
Note that if C<len> is zero, Perl will create a zero length (Perl) string.  You
are responsible for ensuring that the source buffer is at least
C<len> bytes long.  If the C<buffer> argument is NULL the new SV will be
undefined.
d7774 1
a7774 1
Perl_newSVpvn(pTHX_ const char *const buffer, const STRLEN len)
d7780 1
a7780 1
    sv_setpvn(sv,buffer,len);
d7788 1
a7788 1
point to the shared string table where possible.  Returns a new (undefined)
d7814 3
a7816 4
	    SV * const sv = newSV_type(SVt_PV);
	    char *as_utf8 = (char *)bytes_to_utf8 ((U8*)HEK_KEY(hek), &utf8_len);
	    /* bytes_to_utf8() allocates a new string, which we can repurpose: */
	    sv_usepvn_flags(sv, as_utf8, utf8_len, SV_HAS_TRAILING_NUL);
d7818 1
d7828 1
a7828 1
	       share_hek_hek on it.  */
d7860 4
a7863 5
table.  If the string does not already exist in the table, it is
created first.  Turns on READONLY and FAKE.  If the C<hash> parameter
is non-zero, that value is used; otherwise the hash is computed.
The string's hash can later be retrieved from the SV
with the C<SvSHARED_HASH()> macro.  The idea here is
a7903 14
/*
=for apidoc newSVpv_share

Like C<newSVpvn_share>, but takes a nul-terminated string instead of a
string/length pair.

=cut
*/

SV *
Perl_newSVpv_share(pTHX_ const char *src, U32 hash)
{
    return newSVpvn_share(src, strlen(src), hash);
}
d8086 1
a8086 1
(Uses C<sv_setsv>.)
d8099 1
a8099 1
    if (SvTYPE(old) == (svtype)SVTYPEMASK) {
a8220 3
'Get' magic is ignored on the sv passed in, but will be called on
C<SvRV(sv)> if sv is an RV.

a8236 1
    case SVt_PVLV:
d8241 1
a8241 2
		Perl_croak(aTHX_ "Bad filehandle: %"HEKf,
                                    HEKfARG(GvNAME_HEK(gv)));
d8248 1
a8248 2
	if (SvROK(sv)) {
	    SvGETMAGIC(SvRV(sv));
d8250 1
a8250 2
	}
	gv = gv_fetchsv_nomg(sv, 0, SVt_PVIO);
d8255 2
a8256 8
	if (!io) {
	    SV *newsv = sv;
	    if (SvGMAGICAL(sv)) {
		newsv = sv_newmortal();
		sv_setsv_nomg(newsv, sv);
	    }
	    Perl_croak(aTHX_ "Bad filehandle: %"SVf, SVfARG(newsv));
	}
d8296 9
a8305 1
	SvGETMAGIC(sv);
d8307 3
a8309 2
	    if (SvAMAGIC(sv))
		sv = amagic_deref_call(sv, to_cv_amg);
d8318 1
a8318 1
	    else if(SvGETMAGIC(sv), isGV_with_GP(sv))
d8324 1
d8327 2
a8328 3
	else {
	    gv = gv_fetchsv_nomg(sv, lref, SVt_PVCV);
	}
d8340 2
a8341 1
	if (lref & ~GV_ADDMG && !GvCVu(gv)) {
d8402 1
a8402 1
can't cope with complex macro expressions.  Always use the macro instead.
d8408 1
a8408 1
appropriate, else not.  C<sv_pvn_force> and C<sv_pvn_force_nomg> are
a8422 1
    if (flags & SV_GMAGIC) SvGETMAGIC(sv);
d8438 1
a8438 1
			   ref, OP_DESC(PL_op));
a8443 1
	    /* diag_listed_as: Can't coerce %s to %s in %s */
d8445 2
a8446 2
		OP_DESC(PL_op));
	s = sv_2pv_flags(sv, &len, flags &~ SV_GMAGIC);
d8472 1
a8472 2
The backend for the C<SvPVbytex_force> macro.  Always use the macro
instead.
d8491 1
a8491 2
The backend for the C<SvPVutf8x_force> macro.  Always use the macro
instead.
d8519 3
d8523 2
a8524 1
	return SvPV_nolen_const(sv_ref(NULL, sv, ob));
d8544 1
a8544 1
				 * scalars for backwards compatibility */
d8555 1
a8555 1
	case SVt_REGEXP:	return "REGEXP";
a8561 28
=for apidoc sv_ref

Returns a SV describing what the SV passed in is a reference to.

=cut
*/

SV *
Perl_sv_ref(pTHX_ register SV *dst, const SV *const sv, const int ob)
{
    PERL_ARGS_ASSERT_SV_REF;

    if (!dst)
        dst = sv_newmortal();

    if (ob && SvOBJECT(sv)) {
	HvNAME_get(SvSTASH(sv))
                    ? sv_sethek(dst, HvNAME_HEK(SvSTASH(sv)))
                    : sv_setpvn(dst, "__ANON__", 8);
    }
    else {
        const char * reftype = sv_reftype(sv, 0);
        sv_setpv(dst, reftype);
    }
    return dst;
}

/*
d8813 1
a8813 1
	    Perl_croak_no_modify(aTHX);
d8840 1
a8840 2
/* Downgrades a PVGV to a PVMG. If it's actually a PVLV, we leave the type
 * as it is after unglobbing it.
d8843 2
a8844 2
PERL_STATIC_INLINE void
S_sv_unglob(pTHX_ SV *const sv, U32 flags)
d8849 1
a8849 1
    SV * const temp = flags & SV_COW_DROP_PV ? NULL : sv_newmortal();
d8853 1
a8853 1
    assert(SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV);
d8855 1
a8855 2
    if (!(flags & SV_COW_DROP_PV))
	gv_efullname3(temp, MUTABLE_GV(sv), "*");
d8873 5
a8877 6
    if(SvTYPE(sv) == SVt_PVGV) {
	/* need to keep SvANY(sv) in the right arena */
	xpvmg = new_XPVMG();
	StructCopy(SvANY(sv), xpvmg, XPVMG);
	del_XPVGV(SvANY(sv));
	SvANY(sv) = xpvmg;
d8879 2
a8880 3
	SvFLAGS(sv) &= ~SVTYPEMASK;
	SvFLAGS(sv) |= SVt_PVMG;
    }
d8884 1
a8884 7
    if (flags & SV_COW_DROP_PV) SvOK_off(sv);
    else sv_setsv_flags(sv, temp, 0);

    if ((const GV *)sv == PL_last_in_gv)
	PL_last_in_gv = NULL;
    else if ((const GV *)sv == PL_statgv)
	PL_statgv = NULL;
d8927 1
a8927 2
Untaint an SV.  Use C<SvTAINTED_off> instead.

d8946 1
a8946 2
Test an SV for taintedness.  Use C<SvTAINTED> instead.

d9166 1
a9166 1
C<sv_catpvf_mg>.  If the original SV was UTF-8, the pattern should be
d9294 1
a9294 1
		Perl_croak(aTHX_ "Integer overflow in format string for %s", (PL_op ? OP_DESC(PL_op) : "sv_vcatpvfn"));
a9389 2
	else
	    S_vcatpvfn_missing_argument(aTHX);
d9409 7
a9415 2
	if (pp - pat == (int)patlen - 1 && svix < svmax) {
	    const NV nv = SvNV(*svargs);
d9536 1
a9536 4
		%2p		include a HEK
		%3p		include a HEK with precision of 256
		%<num>p		(where num != 2 or 3) reserved for future
				extensions
d9538 1
a9538 1
	Robin Barker 2005-07-14 (but modified since)
d9560 1
a9560 9
		else if (n==2 || n==3) {	/* HEKf */
		    HEK * const hek = va_arg(*args, HEK *);
		    eptr = HEK_KEY(hek);
		    elen = HEK_LEN(hek);
		    if (HEK_UTF8(hek)) is_utf8 = TRUE;
		    if (n==3) precis = 256, has_precis = TRUE;
		    goto string;
		}
		else if (n) {
d9637 52
a9688 10
	if (vectorize && vectorarg) {
	    /* vectorizing, but not with the default "." */
	    if (args)
		vecsv = va_arg(*args, SV*);
	    else if (evix) {
		vecsv = (evix > 0 && evix <= svmax)
		    ? svargs[evix-1] : S_vcatpvfn_missing_argument(aTHX);
	    } else {
		vecsv = svix < svmax
		    ? svargs[svix++] : S_vcatpvfn_missing_argument(aTHX);
a9689 11
	    dotstr = SvPV_const(vecsv, dotstrlen);
	    /* Keep the DO_UTF8 test *after* the SvPV call, else things go
	       bad with tied or overloaded values that return UTF8.  */
	    if (DO_UTF8(vecsv))
		is_utf8 = TRUE;
	    else if (has_utf8) {
		vecsv = sv_mortalcopy(vecsv);
		sv_utf8_upgrade(vecsv);
		dotstr = SvPV_const(vecsv, dotstrlen);
		is_utf8 = TRUE;
	    }		    
a9729 33
	if (vectorize) {
	    if (args) {
		VECTORIZE_ARGS
	    }
	    else if (efix ? (efix > 0 && efix <= svmax) : svix < svmax) {
		vecsv = svargs[efix ? efix-1 : svix++];
		vecstr = (U8*)SvPV_const(vecsv,veclen);
		vec_utf8 = DO_UTF8(vecsv);

		/* if this is a version object, we need to convert
		 * back into v-string notation and then let the
		 * vectorize happen normally
		 */
		if (sv_isobject(vecsv) && sv_derived_from(vecsv, "version")) {
		    char *version = savesvpv(vecsv);
		    if ( hv_exists(MUTABLE_HV(SvRV(vecsv)), "alpha", 5 ) ) {
			Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			"vector argument not supported with alpha versions");
			goto unknown;
		    }
		    vecsv = sv_newmortal();
		    scan_vstring(version, version + veclen, vecsv);
		    vecstr = (U8*)SvPV_const(vecsv, veclen);
		    vec_utf8 = DO_UTF8(vecsv);
		    Safefree(version);
		}
	    }
	    else {
		vecstr = (U8*)"";
		veclen = 0;
	    }
	}

a9762 1
	    ++q;
d9764 1
a9764 1
	    if (*q == 'l') {	/* lld, llf */
d9766 3
a9768 3
		++q;
	    }
	    else
d9770 1
a9770 2
		intsize = 'l';
	    break;
d9772 1
a9772 7
	    if (*++q == 'h') {	/* hhd, hhu */
		intsize = 'c';
		++q;
	    }
	    else
		intsize = 'h';
	    break;
a9773 5
	case 'z':
	case 't':
#if HAS_C99
        case 'j':
#endif
a9898 1
		case 'c':	iv = (char)va_arg(*args, int); break;
a9901 2
		case 'z':	iv = va_arg(*args, SSize_t); break;
		case 't':	iv = va_arg(*args, ptrdiff_t); break;
a9902 3
#if HAS_C99
		case 'j':	iv = va_arg(*args, intmax_t); break;
#endif
a9913 1
		case 'c':	iv = (char)tiv; break;
a9989 1
		case 'c':  uv = (unsigned char)va_arg(*args, unsigned); break;
a9992 5
		case 'z':  uv = va_arg(*args, Size_t); break;
	        case 't':  uv = va_arg(*args, ptrdiff_t); break; /* will sign extend, but there is no uptrdiff_t, so oh well */
#if HAS_C99
		case 'j':  uv = va_arg(*args, uintmax_t); break;
#endif
a10004 1
		case 'c':	uv = (unsigned char)tuv; break;
a10114 1
	    case 'c':
a10115 3
	    case 'z':
	    case 't':
	    case 'j':
a10294 1
		case 'c':	*(va_arg(*args, char*)) = i; break;
a10298 5
		case 'z':	*(va_arg(*args, SSize_t*)) = i; break;
		case 't':	*(va_arg(*args, ptrdiff_t*)) = i; break;
#if HAS_C99
		case 'j':	*(va_arg(*args, intmax_t*)) = i; break;
#endif
d10308 1
a10308 1
		sv_setuv_mg(argsv, has_utf8 ? (UV)sv_len_utf8(sv) : (UV)i);
a10433 1
    SvTAINT(sv);
d10445 1
a10445 1
to new addresses.  The table is created and manipulated with the
d10465 2
a10466 1
#define sv_dup_inc_NN(s,t)	SvREFCNT_inc_NN(sv_dup_inc(s,t))
d10468 1
a10468 1
#define av_dup_inc(s,t)	MUTABLE_AV(sv_dup_inc((const SV *)s,t))
d10470 1
a10470 1
#define hv_dup_inc(s,t)	MUTABLE_HV(sv_dup_inc((const SV *)s,t))
d10472 1
a10472 1
#define cv_dup_inc(s,t)	MUTABLE_CV(sv_dup_inc((const SV *)s,t))
d10474 1
a10474 1
#define io_dup_inc(s,t)	MUTABLE_IO(sv_dup_inc((const SV *)s,t))
d10476 1
a10476 1
#define gv_dup_inc(s,t)	MUTABLE_GV(sv_dup_inc((const SV *)s,t))
d10501 3
d10630 1
a10630 1
Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
a10631 11
    DIR *ret;

#ifdef HAS_FCHDIR
    DIR *pwd;
    register const Direntry_t *dirent;
    char smallbuf[256];
    char *name = NULL;
    STRLEN len = 0;
    long pos;
#endif

a10632 2
    PERL_ARGS_ASSERT_DIRP_DUP;

d10635 2
a10636 88

    /* look for it in the table first */
    ret = (DIR*)ptr_table_fetch(PL_ptr_table, dp);
    if (ret)
	return ret;

#ifdef HAS_FCHDIR

    PERL_UNUSED_ARG(param);

    /* create anew */

    /* open the current directory (so we can switch back) */
    if (!(pwd = PerlDir_open("."))) return (DIR *)NULL;

    /* chdir to our dir handle and open the present working directory */
    if (fchdir(my_dirfd(dp)) < 0 || !(ret = PerlDir_open("."))) {
	PerlDir_close(pwd);
	return (DIR *)NULL;
    }
    /* Now we should have two dir handles pointing to the same dir. */

    /* Be nice to the calling code and chdir back to where we were. */
    fchdir(my_dirfd(pwd)); /* If this fails, then what? */

    /* We have no need of the pwd handle any more. */
    PerlDir_close(pwd);

#ifdef DIRNAMLEN
# define d_namlen(d) (d)->d_namlen
#else
# define d_namlen(d) strlen((d)->d_name)
#endif
    /* Iterate once through dp, to get the file name at the current posi-
       tion. Then step back. */
    pos = PerlDir_tell(dp);
    if ((dirent = PerlDir_read(dp))) {
	len = d_namlen(dirent);
	if (len <= sizeof smallbuf) name = smallbuf;
	else Newx(name, len, char);
	Move(dirent->d_name, name, len, char);
    }
    PerlDir_seek(dp, pos);

    /* Iterate through the new dir handle, till we find a file with the
       right name. */
    if (!dirent) /* just before the end */
	for(;;) {
	    pos = PerlDir_tell(ret);
	    if (PerlDir_read(ret)) continue; /* not there yet */
	    PerlDir_seek(ret, pos); /* step back */
	    break;
	}
    else {
	const long pos0 = PerlDir_tell(ret);
	for(;;) {
	    pos = PerlDir_tell(ret);
	    if ((dirent = PerlDir_read(ret))) {
		if (len == d_namlen(dirent)
		 && memEQ(name, dirent->d_name, len)) {
		    /* found it */
		    PerlDir_seek(ret, pos); /* step back */
		    break;
		}
		/* else we are not there yet; keep iterating */
	    }
	    else { /* This is not meant to happen. The best we can do is
	              reset the iterator to the beginning. */
		PerlDir_seek(ret, pos0);
		break;
	    }
	}
    }
#undef d_namlen

    if (name && name != smallbuf)
	Safefree(name);
#endif

#ifdef WIN32
    ret = win32_dirp_dup(dp, param);
#endif

    /* pop it in the pointer table */
    if (ret)
	ptr_table_store(PL_ptr_table, dp, ret);

    return ret;
a10686 7

	if ((param->flags & CLONEf_JOIN_IN)
		&& mg->mg_type == PERL_MAGIC_backref)
	    /* when joining, we let the individual SVs add themselves to
	     * backref as needed. */
	    continue;

d10704 11
a10714 8
	nmg->mg_obj = (nmg->mg_flags & MGf_REFCOUNTED)
			  ? nmg->mg_type == PERL_MAGIC_backref
				/* The backref AV has its reference
				 * count deliberately bumped by 1 */
				? SvREFCNT_inc(av_dup_inc((const AV *)
						    nmg->mg_obj, param))
				: sv_dup_inc(nmg->mg_obj, param)
			  : sv_dup(nmg->mg_obj, param);
d10731 1
a10731 1
	    nmg->mg_virtual->svt_dup(aTHX_ nmg, param);
a10738 5
struct ptr_tbl_arena {
    struct ptr_tbl_arena *next;
    struct ptr_tbl_ent array[1023/3]; /* as ptr_tbl_ent has 3 pointers.  */
};

a10749 3
    tbl->tbl_arena	= NULL;
    tbl->tbl_arena_next	= NULL;
    tbl->tbl_arena_end	= NULL;
d10757 8
d10809 1
a10809 12
	if (tbl->tbl_arena_next == tbl->tbl_arena_end) {
	    struct ptr_tbl_arena *new_arena;

	    Newx(new_arena, 1, struct ptr_tbl_arena);
	    new_arena->next = tbl->tbl_arena;
	    tbl->tbl_arena = new_arena;
	    tbl->tbl_arena_next = new_arena->array;
	    tbl->tbl_arena_end = new_arena->array
		+ sizeof(new_arena->array) / sizeof(new_arena->array[0]);
	}

	tblent = tbl->tbl_arena_next++;
d10839 2
a10840 4
	PTR_TBL_ENT_t **entp = ary;
	PTR_TBL_ENT_t *ent = *ary;
	PTR_TBL_ENT_t **curentp;
	if (!ent)
d10843 1
a10843 1
	do {
d10848 1
d10852 1
a10852 2
	    ent = *entp;
	} while (ent);
a10856 1
/* Deprecated - will be removed post 5.14 */
d10862 2
a10863 1
	struct ptr_tbl_arena *arena = tbl->tbl_arena;
d10865 2
a10866 1
	Zero(tbl->tbl_ary, tbl->tbl_max + 1, struct ptr_tbl_ent **);
d10868 6
a10873 6
	while (arena) {
	    struct ptr_tbl_arena *next = arena->next;

	    Safefree(arena);
	    arena = next;
	};
a10875 3
	tbl->tbl_arena = NULL;
	tbl->tbl_arena_next = NULL;
	tbl->tbl_arena_end = NULL;
a10883 2
    struct ptr_tbl_arena *arena;

d10887 1
a10887 10

    arena = tbl->tbl_arena;

    while (arena) {
	struct ptr_tbl_arena *next = arena->next;

	Safefree(arena);
	arena = next;
    }

d10900 4
a10903 10
	if (SvWEAKREF(sstr)) {
	    SvRV_set(dstr, sv_dup(SvRV_const(sstr), param));
	    if (param->flags & CLONEf_JOIN_IN) {
		/* if joining, we add any back references individually rather
		 * than copying the whole backref array */
		Perl_sv_add_backref(aTHX_ SvRV(dstr), dstr);
	    }
	}
	else
	    SvRV_set(dstr, sv_dup_inc(SvRV_const(sstr), param));
d10912 1
a10912 1
		   But we are a true, independent SV, so:  */
d10956 2
a10957 2
static SV *
S_sv_dup_common(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
d10962 1
a10962 1
    PERL_ARGS_ASSERT_SV_DUP_COMMON;
d10964 3
a10966 1
    if (SvTYPE(sstr) == (svtype)SVTYPEMASK) {
d10982 1
a10982 1
	    if (hvname) {
d10984 1
a10984 26
		dstr = MUTABLE_SV(gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname),
                                                HEK_UTF8(hvname) ? SVf_UTF8 : 0));
		ptr_table_store(PL_ptr_table, sstr, dstr);
		return dstr;
	    }
        }
	else if (SvTYPE(sstr) == SVt_PVGV && !SvFAKE(sstr)) {
	    HV *stash = GvSTASH(sstr);
	    const HEK * hvname;
	    if (stash && (hvname = HvNAME_HEK(stash))) {
		/** don't clone GVs if they already exist **/
		SV **svp;
		stash = gv_stashpvn(HEK_KEY(hvname), HEK_LEN(hvname),
				    HEK_UTF8(hvname) ? SVf_UTF8 : 0);
		svp = hv_fetch(
			stash, GvNAME(sstr),
			GvNAMEUTF8(sstr)
			    ? -GvNAMELEN(sstr)
			    :  GvNAMELEN(sstr),
			0
		      );
		if (svp && *svp && SvTYPE(*svp) == SVt_PVGV) {
		    ptr_table_store(PL_ptr_table, sstr, *svp);
		    return *svp;
		}
	    }
d10995 1
a10995 2
    dstr->sv_debug_parent = (SV*)sstr;
    FREE_SV_DEBUG_FILE(dstr);
d11083 1
a11083 2
		&& !isGV_with_GP(dstr)
		&& !(sv_type == SVt_PVIO && !(IoFLAGS(dstr) & IOf_FAKE_DIRP)))
a11122 1
		/* non-GP case already handled above */
d11132 13
a11144 3
		    if (param->flags & CLONEf_JOIN_IN)
			Perl_sv_add_backref(aTHX_ MUTABLE_SV(GvSTASH(dstr)), dstr);
		    GvGP_set(dstr, gp_dup(GvGP(sstr), param));
d11146 2
a11147 1
		}
d11150 5
d11168 1
a11168 1
			IoDIRP(dstr)	= dirp_dup(IoDIRP(dstr), param);
a11172 1
		    IoIFP(dstr)	= fp_dup(IoIFP(sstr), IoTYPE(dstr), param);
a11173 4
		if (IoOFP(dstr) == IoIFP(sstr))
		    IoOFP(dstr) = IoIFP(dstr);
		else
		    IoOFP(dstr)	= fp_dup(IoOFP(dstr), IoTYPE(dstr), param);
d11196 5
d11232 1
d11236 2
a11237 1
			SvOOK_on(dstr);
d11239 2
a11240 21
			if (saux->xhv_name_count) {
			    HEK ** const sname = saux->xhv_name_u.xhvnameu_names;
			    const I32 count
			     = saux->xhv_name_count < 0
			        ? -saux->xhv_name_count
			        :  saux->xhv_name_count;
			    HEK **shekp = sname + count;
			    HEK **dhekp;
			    Newx(daux->xhv_name_u.xhvnameu_names, count, HEK *);
			    dhekp = daux->xhv_name_u.xhvnameu_names + count;
			    while (shekp-- > sname) {
				dhekp--;
				*dhekp = hek_dup(*shekp, param);
			    }
			}
			else {
			    daux->xhv_name_u.xhvnameu_name
				= hek_dup(saux->xhv_name_u.xhvnameu_name,
					  param);
			}
			daux->xhv_name_count = saux->xhv_name_count;
d11245 1
a11245 1
					cBOOL(HvSHAREKEYS(sstr)), param) : 0;
d11248 3
a11250 16
			    (param->flags & CLONEf_JOIN_IN)
				/* when joining, we let the individual GVs and
				 * CVs add themselves to backref as
				 * needed. This avoids pulling in stuff
				 * that isn't required, and simplifies the
				 * case where stashes aren't cloned back
				 * if they already exist in the parent
				 * thread */
			    ? NULL
			    : saux->xhv_backreferences
				? (SvTYPE(saux->xhv_backreferences) == SVt_PVAV)
				    ? MUTABLE_AV(SvREFCNT_inc(
					  sv_dup_inc((const SV *)
					    saux->xhv_backreferences, param)))
				    : MUTABLE_AV(sv_dup((const SV *)
					    saux->xhv_backreferences, param))
d11258 1
a11258 1
			if (HvNAME(sstr))
a11268 1
		/*FALLTHROUGH*/
d11271 3
a11273 6
		SvANY(MUTABLE_CV(dstr))->xcv_stash =
		    hv_dup(CvSTASH(dstr), param);
		if ((param->flags & CLONEf_JOIN_IN) && CvSTASH(dstr))
		    Perl_sv_add_backref(aTHX_ MUTABLE_SV(CvSTASH(dstr)), dstr);
		if (!CvISXSUB(dstr)) {
		    OP_REFCNT_LOCK;
d11275 2
a11276 2
		    OP_REFCNT_UNLOCK;
		} else if (CvCONST(dstr)) {
a11279 1
		if (CvDYNFILE(dstr)) CvFILE(dstr) = SAVEPV(CvFILE(dstr));
d11282 3
a11284 8
		SvANY(MUTABLE_CV(dstr))->xcv_gv =
		    CvCVGV_RC(dstr)
		    ? gv_dup_inc(CvGV(sstr), param)
		    : (param->flags & CLONEf_JOIN_IN)
			? NULL
			: gv_dup(CvGV(sstr), param);

		CvPADLIST(dstr) = padlist_dup(CvPADLIST(sstr), param);
d11289 2
a11301 35
SV *
Perl_sv_dup_inc(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
{
    PERL_ARGS_ASSERT_SV_DUP_INC;
    return sstr ? SvREFCNT_inc(sv_dup_common(sstr, param)) : NULL;
}

SV *
Perl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
{
    SV *dstr = sstr ? sv_dup_common(sstr, param) : NULL;
    PERL_ARGS_ASSERT_SV_DUP;

    /* Track every SV that (at least initially) had a reference count of 0.
       We need to do this by holding an actual reference to it in this array.
       If we attempt to cheat, turn AvREAL_off(), and store only pointers
       (akin to the stashes hash, and the perl stack), we come unstuck if
       a weak reference (or other SV legitimately SvREFCNT() == 0 for this
       thread) is manipulated in a CLONE method, because CLONE runs before the
       unreferenced array is walked to find SVs still with SvREFCNT() == 0
       (and fix things up by giving each a reference via the temps stack).
       Instead, during CLONE, if the 0-referenced SV has SvREFCNT_inc() and
       then SvREFCNT_dec(), it will be cleaned up (and added to the free list)
       before the walk of unreferenced happens and a reference to that is SV
       added to the temps stack. At which point we have the same SV considered
       to be in use, and free to be re-used. Not good.
    */
    if (dstr && !(param->flags & CLONEf_COPY_STACKS) && !SvREFCNT(dstr)) {
	assert(param->unreferenced);
	av_push(param->unreferenced, SvREFCNT_inc(dstr));
    }

    return dstr;
}

a11329 1
	    ncx->blk_oldcop = (COP*)any_dup(ncx->blk_oldcop, param->proto_perl);
a11347 1
		ncx->blk_eval.cv = cv_dup(ncx->blk_eval.cv, param);
d11353 1
a11353 1
		   actually being the same function, and order equivalence of
d11364 1
a11364 1
		    ncx->blk_loop.itervar_u.oldcomppad
d11366 1
a11366 1
					ncx->blk_loop.itervar_u.oldcomppad);
d11368 3
a11370 3
		    ncx->blk_loop.itervar_u.gv
			= gv_dup((const GV *)ncx->blk_loop.itervar_u.gv,
				    param);
a11380 2
	    case CXt_WHEN:
	    case CXt_GIVEN:
a11427 2
#define POPUV(ss,ix)	((ss)[--(ix)].any_uv)
#define TOPUV(ss,ix)	((ss)[ix].any_uv)
d11500 2
a11501 4
	const UV uv = POPUV(ss,ix);
	const U8 type = (U8)uv & SAVE_MASK;

	TOPUV(nss,ix) = uv;
a11502 2
	case SAVEt_CLEARSV:
	    break;
a11507 1
        case SAVEt_GVSV:			/* scalar slot in GV */
d11549 2
d11555 3
a11579 6
	    /* Fall through */
	case SAVEt_INT_SMALL:
	case SAVEt_I32_SMALL:
	case SAVEt_I16:				/* I16 reference */
	case SAVEt_I8:				/* I8 reference */
	case SAVEt_BOOL:
d11596 1
a11596 1
	    break;
a11622 4
	case SAVEt_FREECOPHH:
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = cophh_copy((COPHH *)ptr);
	    break;
d11655 3
a11657 1
	    ix -= uv >> SAVE_TIGHT_SHIFT;
d11673 5
a11677 1
	    ptr = cophh_copy((COPHH*)ptr);
d11694 6
d11835 1
a11835 1
CLONEf_KEEP_PTR_TABLE -
d11840 1
a11840 1
refcount.  If KEEP_PTR_TABLE is not set then perl_clone will kill
d11845 1
a11845 1
code is in threads.xs create.
d11847 1
a11847 1
CLONEf_CLONE_HOST -
a11923 1
    PL_defstash = NULL; /* may be used by perl malloc() */
d11934 1
a11934 1
    PL_sv_serial = (((UV)my_perl >> 2) & 0xfff) * 1000000;
a11953 2
    /* Nothing in the core code uses this, but we make it available to
       extensions (using mg_dup).  */
a11954 4
    /* Likely nothing will use this, but it is initialised to be consistent
       with Perl_clone_params_new().  */
    param->new_perl = my_perl;
    param->unreferenced = NULL;
d11961 2
a11972 236
    SvANY(&PL_sv_undef)		= NULL;
    SvREFCNT(&PL_sv_undef)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVt_NULL;
    SvREFCNT(&PL_sv_no)		= (~(U32)0)/2;
    SvFLAGS(&PL_sv_no)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;

    SvANY(&PL_sv_yes)		= new_XPVNV();
    SvREFCNT(&PL_sv_yes)	= (~(U32)0)/2;
    SvFLAGS(&PL_sv_yes)		= SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK|SVf_READONLY|SVt_PVNV;

    /* dbargs array probably holds garbage */
    PL_dbargs		= NULL;

    PL_compiling = proto_perl->Icompiling;

#ifdef PERL_DEBUG_READONLY_OPS
    PL_slabs = NULL;
    PL_slab_count = 0;
#endif

    /* pseudo environmental stuff */
    PL_origargc		= proto_perl->Iorigargc;
    PL_origargv		= proto_perl->Iorigargv;

    /* Set tainting stuff before PerlIO_debug can possibly get called */
    PL_tainting		= proto_perl->Itainting;
    PL_taint_warn	= proto_perl->Itaint_warn;

    PL_minus_c		= proto_perl->Iminus_c;

    PL_localpatches	= proto_perl->Ilocalpatches;
    PL_splitstr		= proto_perl->Isplitstr;
    PL_minus_n		= proto_perl->Iminus_n;
    PL_minus_p		= proto_perl->Iminus_p;
    PL_minus_l		= proto_perl->Iminus_l;
    PL_minus_a		= proto_perl->Iminus_a;
    PL_minus_E		= proto_perl->Iminus_E;
    PL_minus_F		= proto_perl->Iminus_F;
    PL_doswitches	= proto_perl->Idoswitches;
    PL_dowarn		= proto_perl->Idowarn;
    PL_sawampersand	= proto_perl->Isawampersand;
    PL_unsafe		= proto_perl->Iunsafe;
    PL_perldb		= proto_perl->Iperldb;
    PL_perl_destruct_level = proto_perl->Iperl_destruct_level;
    PL_exit_flags       = proto_perl->Iexit_flags;

    /* XXX time(&PL_basetime) when asked for? */
    PL_basetime		= proto_perl->Ibasetime;

    PL_maxsysfd		= proto_perl->Imaxsysfd;
    PL_statusvalue	= proto_perl->Istatusvalue;
#ifdef VMS
    PL_statusvalue_vms	= proto_perl->Istatusvalue_vms;
#else
    PL_statusvalue_posix = proto_perl->Istatusvalue_posix;
#endif

    /* RE engine related */
    Zero(&PL_reg_state, 1, struct re_save_state);
    PL_reginterp_cnt	= 0;
    PL_regmatch_slab	= NULL;

    PL_sub_generation	= proto_perl->Isub_generation;

    /* funky return mechanisms */
    PL_forkprocess	= proto_perl->Iforkprocess;

    /* internal state */
    PL_maxo		= proto_perl->Imaxo;

    PL_main_start	= proto_perl->Imain_start;
    PL_eval_root	= proto_perl->Ieval_root;
    PL_eval_start	= proto_perl->Ieval_start;

    PL_filemode		= proto_perl->Ifilemode;
    PL_lastfd		= proto_perl->Ilastfd;
    PL_oldname		= proto_perl->Ioldname;		/* XXX not quite right */
    PL_Argv		= NULL;
    PL_Cmd		= NULL;
    PL_gensym		= proto_perl->Igensym;

    PL_laststatval	= proto_perl->Ilaststatval;
    PL_laststype	= proto_perl->Ilaststype;
    PL_mess_sv		= NULL;

    PL_profiledata	= NULL;

    PL_generation	= proto_perl->Igeneration;

    PL_in_clean_objs	= proto_perl->Iin_clean_objs;
    PL_in_clean_all	= proto_perl->Iin_clean_all;

    PL_delaymagic_uid	= proto_perl->Idelaymagic_uid;
    PL_delaymagic_euid	= proto_perl->Idelaymagic_euid;
    PL_delaymagic_gid	= proto_perl->Idelaymagic_gid;
    PL_delaymagic_egid	= proto_perl->Idelaymagic_egid;
    PL_nomemok		= proto_perl->Inomemok;
    PL_an		= proto_perl->Ian;
    PL_evalseq		= proto_perl->Ievalseq;
    PL_origenviron	= proto_perl->Iorigenviron;	/* XXX not quite right */
    PL_origalen		= proto_perl->Iorigalen;

    PL_sighandlerp	= proto_perl->Isighandlerp;

    PL_runops		= proto_perl->Irunops;

    PL_subline		= proto_perl->Isubline;

#ifdef FCRYPT
    PL_cryptseen	= proto_perl->Icryptseen;
#endif

    PL_hints		= proto_perl->Ihints;

    PL_amagic_generation	= proto_perl->Iamagic_generation;

#ifdef USE_LOCALE_COLLATE
    PL_collation_ix	= proto_perl->Icollation_ix;
    PL_collation_standard	= proto_perl->Icollation_standard;
    PL_collxfrm_base	= proto_perl->Icollxfrm_base;
    PL_collxfrm_mult	= proto_perl->Icollxfrm_mult;
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    PL_numeric_standard	= proto_perl->Inumeric_standard;
    PL_numeric_local	= proto_perl->Inumeric_local;
#endif /* !USE_LOCALE_NUMERIC */

    /* Did the locale setup indicate UTF-8? */
    PL_utf8locale	= proto_perl->Iutf8locale;
    /* Unicode features (see perlrun/-C) */
    PL_unicode		= proto_perl->Iunicode;

    /* Pre-5.8 signals control */
    PL_signals		= proto_perl->Isignals;

    /* times() ticks per second */
    PL_clocktick	= proto_perl->Iclocktick;

    /* Recursion stopper for PerlIO_find_layer */
    PL_in_load_module	= proto_perl->Iin_load_module;

    /* sort() routine */
    PL_sort_RealCmp	= proto_perl->Isort_RealCmp;

    /* Not really needed/useful since the reenrant_retint is "volatile",
     * but do it for consistency's sake. */
    PL_reentrant_retint	= proto_perl->Ireentrant_retint;

    /* Hooks to shared SVs and locks. */
    PL_sharehook	= proto_perl->Isharehook;
    PL_lockhook		= proto_perl->Ilockhook;
    PL_unlockhook	= proto_perl->Iunlockhook;
    PL_threadhook	= proto_perl->Ithreadhook;
    PL_destroyhook	= proto_perl->Idestroyhook;
    PL_signalhook	= proto_perl->Isignalhook;

    PL_globhook		= proto_perl->Iglobhook;

    /* swatch cache */
    PL_last_swash_hv	= NULL;	/* reinits on demand */
    PL_last_swash_klen	= 0;
    PL_last_swash_key[0]= '\0';
    PL_last_swash_tmps	= (U8*)NULL;
    PL_last_swash_slen	= 0;

    PL_glob_index	= proto_perl->Iglob_index;
    PL_srand_called	= proto_perl->Isrand_called;

    if (flags & CLONEf_COPY_STACKS) {
	/* next allocation will be PL_tmps_stack[PL_tmps_ix+1] */
	PL_tmps_ix		= proto_perl->Itmps_ix;
	PL_tmps_max		= proto_perl->Itmps_max;
	PL_tmps_floor		= proto_perl->Itmps_floor;

	/* next push_scope()/ENTER sets PL_scopestack[PL_scopestack_ix]
	 * NOTE: unlike the others! */
	PL_scopestack_ix	= proto_perl->Iscopestack_ix;
	PL_scopestack_max	= proto_perl->Iscopestack_max;

	/* next SSPUSHFOO() sets PL_savestack[PL_savestack_ix]
	 * NOTE: unlike the others! */
	PL_savestack_ix		= proto_perl->Isavestack_ix;
	PL_savestack_max	= proto_perl->Isavestack_max;
    }

    PL_start_env	= proto_perl->Istart_env;	/* XXXXXX */
    PL_top_env		= &PL_start_env;

    PL_op		= proto_perl->Iop;

    PL_Sv		= NULL;
    PL_Xpv		= (XPV*)NULL;
    my_perl->Ina	= proto_perl->Ina;

    PL_statbuf		= proto_perl->Istatbuf;
    PL_statcache	= proto_perl->Istatcache;

#ifdef HAS_TIMES
    PL_timesbuf		= proto_perl->Itimesbuf;
#endif

    PL_tainted		= proto_perl->Itainted;
    PL_curpm		= proto_perl->Icurpm;	/* XXX No PMOP ref count */

    PL_chopset		= proto_perl->Ichopset;	/* XXX never deallocated */

    PL_restartjmpenv	= proto_perl->Irestartjmpenv;
    PL_restartop	= proto_perl->Irestartop;
    PL_in_eval		= proto_perl->Iin_eval;
    PL_delaymagic	= proto_perl->Idelaymagic;
    PL_phase		= proto_perl->Iphase;
    PL_localizing	= proto_perl->Ilocalizing;

    PL_hv_fetch_ent_mh	= NULL;
    PL_modcount		= proto_perl->Imodcount;
    PL_lastgotoprobe	= NULL;
    PL_dumpindent	= proto_perl->Idumpindent;

    PL_efloatbuf	= NULL;		/* reinits on demand */
    PL_efloatsize	= 0;			/* reinits on demand */

    /* regex stuff */

    PL_regdummy		= proto_perl->Iregdummy;
    PL_colorset		= 0;		/* reinits PL_colors[] */
    /*PL_colors[6]	= {0,0,0,0,0,0};*/

    /* Pluggable optimizer */
    PL_peepp		= proto_perl->Ipeepp;
    PL_rpeepp		= proto_perl->Irpeepp;
    /* op_free() hook */
    PL_opfreehook	= proto_perl->Iopfreehook;

d11985 3
d11991 3
d12001 4
d12012 3
d12021 2
d12032 5
a12036 1
    CopHINTHASH_set(&PL_compiling, cophh_copy(CopHINTHASH_get(&PL_compiling)));
d12038 8
a12047 7
    /* This makes no difference to the implementation, as it always pushes
       and shifts pointers to other SVs without changing their reference
       count, with the array becoming empty before it is freed. However, it
       makes it conceptually clear what is going on, and will avoid some
       work inside av.c, filling slots between AvFILL() and AvMAX() with
       &PL_sv_undef, and SvREFCNT_dec()ing those.  */
    AvREAL_off(param->stashes);
d12049 3
a12051 3
    if (!(flags & CLONEf_COPY_STACKS)) {
	param->unreferenced = newAV();
    }
d12064 17
a12080 4

    /* switches */
    PL_patchlevel	= sv_dup_inc(proto_perl->Ipatchlevel, param);
    PL_apiversion	= sv_dup_inc(proto_perl->Iapiversion, param);
d12083 3
d12088 2
d12092 7
d12106 5
d12120 1
a12120 1
    PL_ofsgv            = gv_dup_inc(proto_perl->Iofsgv, param);
d12144 1
a12144 1
    PL_curstash		= hv_dup_inc(proto_perl->Icurstash, param);
d12158 1
d12161 3
d12167 2
d12180 3
d12187 6
d12194 3
d12227 2
a12228 1
    PL_custom_ops	= hv_dup_inc(proto_perl->Icustom_ops, param);
d12238 2
d12242 12
d12258 4
d12271 1
d12274 8
d12283 1
d12285 3
d12292 2
d12297 1
a12297 50
    /* Unicode inversion lists */
    PL_ASCII		= sv_dup_inc(proto_perl->IASCII, param);
    PL_Latin1		= sv_dup_inc(proto_perl->ILatin1, param);

    PL_PerlSpace	= sv_dup_inc(proto_perl->IPerlSpace, param);
    PL_XPerlSpace	= sv_dup_inc(proto_perl->IXPerlSpace, param);

    PL_L1PosixAlnum	= sv_dup_inc(proto_perl->IL1PosixAlnum, param);
    PL_PosixAlnum	= sv_dup_inc(proto_perl->IPosixAlnum, param);

    PL_L1PosixAlpha	= sv_dup_inc(proto_perl->IL1PosixAlpha, param);
    PL_PosixAlpha	= sv_dup_inc(proto_perl->IPosixAlpha, param);

    PL_PosixBlank	= sv_dup_inc(proto_perl->IPosixBlank, param);
    PL_XPosixBlank	= sv_dup_inc(proto_perl->IXPosixBlank, param);

    PL_L1Cased		= sv_dup_inc(proto_perl->IL1Cased, param);

    PL_PosixCntrl	= sv_dup_inc(proto_perl->IPosixCntrl, param);
    PL_XPosixCntrl	= sv_dup_inc(proto_perl->IXPosixCntrl, param);

    PL_PosixDigit	= sv_dup_inc(proto_perl->IPosixDigit, param);

    PL_L1PosixGraph	= sv_dup_inc(proto_perl->IL1PosixGraph, param);
    PL_PosixGraph	= sv_dup_inc(proto_perl->IPosixGraph, param);

    PL_L1PosixLower	= sv_dup_inc(proto_perl->IL1PosixLower, param);
    PL_PosixLower	= sv_dup_inc(proto_perl->IPosixLower, param);

    PL_L1PosixPrint	= sv_dup_inc(proto_perl->IL1PosixPrint, param);
    PL_PosixPrint	= sv_dup_inc(proto_perl->IPosixPrint, param);

    PL_L1PosixPunct	= sv_dup_inc(proto_perl->IL1PosixPunct, param);
    PL_PosixPunct	= sv_dup_inc(proto_perl->IPosixPunct, param);

    PL_PosixSpace	= sv_dup_inc(proto_perl->IPosixSpace, param);
    PL_XPosixSpace	= sv_dup_inc(proto_perl->IXPosixSpace, param);

    PL_L1PosixUpper	= sv_dup_inc(proto_perl->IL1PosixUpper, param);
    PL_PosixUpper	= sv_dup_inc(proto_perl->IPosixUpper, param);

    PL_L1PosixWord	= sv_dup_inc(proto_perl->IL1PosixWord, param);
    PL_PosixWord	= sv_dup_inc(proto_perl->IPosixWord, param);

    PL_PosixXDigit	= sv_dup_inc(proto_perl->IPosixXDigit, param);
    PL_XPosixXDigit	= sv_dup_inc(proto_perl->IXPosixXDigit, param);

    PL_VertSpace	= sv_dup_inc(proto_perl->IVertSpace, param);

    /* utf8 character class swashes */
d12299 1
d12302 1
a12325 2
    PL_utf8_xidstart	= sv_dup_inc(proto_perl->Iutf8_xidstart, param);
    PL_utf8_perl_idstart = sv_dup_inc(proto_perl->Iutf8_perl_idstart, param);
a12326 6
    PL_utf8_xidcont	= sv_dup_inc(proto_perl->Iutf8_xidcont, param);
    PL_utf8_foldable	= sv_dup_inc(proto_perl->Iutf8_foldable, param);
    PL_utf8_quotemeta	= sv_dup_inc(proto_perl->Iutf8_quotemeta, param);
    PL_ASCII		= sv_dup_inc(proto_perl->IASCII, param);
    PL_AboveLatin1	= sv_dup_inc(proto_perl->IAboveLatin1, param);
    PL_Latin1		= sv_dup_inc(proto_perl->ILatin1, param);
d12328 41
d12388 2
d12391 4
d12411 2
d12433 4
d12443 13
d12458 11
d12471 3
d12475 2
d12480 1
d12485 6
d12492 4
d12501 21
a12535 2
    PL_blockhooks	= av_dup_inc(proto_perl->Iblockhooks, param);
    PL_utf8_foldclosures = hv_dup_inc(proto_perl->Iutf8_foldclosures, param);
a12560 3
    if (!(flags & CLONEf_COPY_STACKS)) {
	unreferenced_to_tmp_stack(param->unreferenced);
    }
a12572 103
static void
S_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced)
{
    PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK;
    
    if (AvFILLp(unreferenced) > -1) {
	SV **svp = AvARRAY(unreferenced);
	SV **const last = svp + AvFILLp(unreferenced);
	SSize_t count = 0;

	do {
	    if (SvREFCNT(*svp) == 1)
		++count;
	} while (++svp <= last);

	EXTEND_MORTAL(count);
	svp = AvARRAY(unreferenced);

	do {
	    if (SvREFCNT(*svp) == 1) {
		/* Our reference is the only one to this SV. This means that
		   in this thread, the scalar effectively has a 0 reference.
		   That doesn't work (cleanup never happens), so donate our
		   reference to it onto the save stack. */
		PL_tmps_stack[++PL_tmps_ix] = *svp;
	    } else {
		/* As an optimisation, because we are already walking the
		   entire array, instead of above doing either
		   SvREFCNT_inc(*svp) or *svp = &PL_sv_undef, we can instead
		   release our reference to the scalar, so that at the end of
		   the array owns zero references to the scalars it happens to
		   point to. We are effectively converting the array from
		   AvREAL() on to AvREAL() off. This saves the av_clear()
		   (triggered by the SvREFCNT_dec(unreferenced) below) from
		   walking the array a second time.  */
		SvREFCNT_dec(*svp);
	    }

	} while (++svp <= last);
	AvREAL_off(unreferenced);
    }
    SvREFCNT_dec(unreferenced);
}

void
Perl_clone_params_del(CLONE_PARAMS *param)
{
    /* This seemingly funky ordering keeps the build with PERL_GLOBAL_STRUCT
       happy: */
    PerlInterpreter *const to = param->new_perl;
    dTHXa(to);
    PerlInterpreter *const was = PERL_GET_THX;

    PERL_ARGS_ASSERT_CLONE_PARAMS_DEL;

    if (was != to) {
	PERL_SET_THX(to);
    }

    SvREFCNT_dec(param->stashes);
    if (param->unreferenced)
	unreferenced_to_tmp_stack(param->unreferenced);

    Safefree(param);

    if (was != to) {
	PERL_SET_THX(was);
    }
}

CLONE_PARAMS *
Perl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)
{
    dVAR;
    /* Need to play this game, as newAV() can call safesysmalloc(), and that
       does a dTHX; to get the context from thread local storage.
       FIXME - under PERL_CORE Newx(), Safefree() and friends should expand to
       a version that passes in my_perl.  */
    PerlInterpreter *const was = PERL_GET_THX;
    CLONE_PARAMS *param;

    PERL_ARGS_ASSERT_CLONE_PARAMS_NEW;

    if (was != to) {
	PERL_SET_THX(to);
    }

    /* Given that we've set the context, we can do this unshared.  */
    Newx(param, 1, CLONE_PARAMS);

    param->flags = 0;
    param->proto_perl = from;
    param->new_perl = to;
    param->stashes = (AV *)Perl_newSV_type(to, SVt_PVAV);
    AvREAL_off(param->stashes);
    param->unreferenced = (AV *)Perl_newSV_type(to, SVt_PVAV);

    if (was != to) {
	PERL_SET_THX(was);
    }
    return param;
}

d12587 1
a12587 1
(See F<lib/encoding.pm> and L<Encode>.)
a12634 8
	if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	    /* clear pos and any utf8 cache */
	    MAGIC * mg = mg_find(sv, PERL_MAGIC_regex_global);
	    if (mg)
		mg->mg_len = -1;
	    if ((mg = mg_find(sv, PERL_MAGIC_utf8)))
		magic_setutf8(sv,mg); /* clear UTF8 cache */
	}
d12649 1
a12649 1
the PV of the ssv.  The value which the offset points will be modified
d12776 2
a12777 2
SV*
Perl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ,
d12782 1
a12782 1
    if (gv && isGV(gv)) {
d12801 1
a12801 1
	CV * const cv = gv ? (CV *)gv : find_runcv(NULL);
a12804 2
	assert(!cv || SvTYPE(cv) == SVt_PVCV);

d12809 1
a12809 1
	sv_setsv(name, sv);
d12816 1
a12816 2
	    pv_pretty(sv, SvPVX_const(keyname), SvCUR(keyname), 32, NULL, NULL,
		    PERL_PV_PRETTY_DUMP | PERL_PV_ESCAPE_UNI_DETECT ));
d12835 1
a12835 1
Find the name of the undefined variable (if any) that caused the operator
d12837 1
a12837 1
If match is true, only return a name if its value matches uninit_sv.
d12840 1
a12840 1
OP_PADSV or OP_GV that gives the name of the undefined variable.  On the
d12890 1
a12890 1
	    else if (obase == PL_op) /* @@{expr}, %{expr} */
a12892 2
	    else /* @@{expr}, %{expr} as a sub-expression */
		return NULL;
a12913 13
    case OP_RV2SV:
	if (cUNOPx(obase)->op_first->op_type == OP_GV) {
	    /* $global */
	    gv = cGVOPx_gv(cUNOPx(obase)->op_first);
	    if (!gv || !GvSTASH(gv))
		break;
	    if (match && (GvSV(gv) != uninit_sv))
		break;
	    return varname(gv, '$', 0, NULL, 0, FUV_SUBSCRIPT_NONE);
	}
	/* ${expr} */
	return find_uninit_var(cUNOPx(obase)->op_first, uninit_sv, 1);

d12922 1
a12922 1
	if (!gv || (match && GvSV(gv) != uninit_sv) || !GvSTASH(gv))
d12926 13
a12938 9
    case OP_AELEMFAST_LEX:
	if (match) {
	    SV **svp;
	    AV *av = MUTABLE_AV(PAD_SV(obase->op_targ));
	    if (!av || SvRMAGICAL(av))
		break;
	    svp = av_fetch(av, (I32)obase->op_private, FALSE);
	    if (!svp || *svp != uninit_sv)
		break;
d12940 1
a12940 4
	return varname(NULL, '$', obase->op_targ,
		       NULL, (I32)obase->op_private, FUV_SUBSCRIPT_ARRAY);
    case OP_AELEMFAST:
	{
a12966 3
    {
	bool negate = FALSE;

a12991 5
	if (kid && kid->op_type == OP_NEGATE) {
	    negate = TRUE;
	    kid = cUNOPx(kid)->op_first;
	}

a12993 7
	    SV* kidsv;
	    if (negate) {
		kidsv = sv_2mortal(newSVpvs("-"));
		sv_catsv(kidsv, cSVOPx_sv(kid));
	    }
	    else
		kidsv = cSVOPx_sv(kid);
d12998 1
a12998 1
		    HE* he = hv_fetch_ent(MUTABLE_HV(sv), kidsv, 0, 0);
d13003 1
a13003 3
		    SV * const * const svp = av_fetch(MUTABLE_AV(sv),
			negate ? - SvIV(cSVOPx_sv(kid)) : SvIV(cSVOPx_sv(kid)),
			FALSE);
d13010 1
a13010 1
			    kidsv, 0, FUV_SUBSCRIPT_HASH);
d13013 1
a13013 2
		    negate ? - SvIV(cSVOPx_sv(kid)) : SvIV(cSVOPx_sv(kid)),
		    FUV_SUBSCRIPT_ARRAY);
a13038 1
    }
a13068 1
    case OP_TRANSR:
d13095 1
d13212 2
a13213 7
	/* This loop checks all the kid ops, skipping any that cannot pos-
	 * sibly be responsible for the uninitialized value; i.e., defined
	 * constants and ops that return nothing.  If there is only one op
	 * left that is not skipped, then we *know* it is responsible for
	 * the uninitialized value.  If there is more than one op left, we
	 * have to look for an exact match in the while() loop below.
	 */
d13249 1
a13249 1
Print appropriate "Use of uninitialized variable" warning.
d13260 1
a13260 1
	if (uninit_sv && PL_curpad) {
d13265 2
a13266 3
	/* diag_listed_as: Use of uninitialized value%s */
	Perl_warner(aTHX_ packWARN(WARN_UNINITIALIZED), PL_warn_uninit_sv,
		SVfARG(varname ? varname : &PL_sv_no),
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d69 2
d136 1
a136 1
		      do_clean_named_io_objs(),do_curse()
d138 2
a139 4
			try to do the same for all objects indir-
			ectly referenced by typeglobs too, and
			then do a final sweep, cursing any
			objects that remain.  Called once from
d185 1
a185 3
#  define FREE_SV_DEBUG_FILE(sv) STMT_START { \
	if ((sv)->sv_debug_file) PerlMemShared_free((sv)->sv_debug_file); \
    } STMT_END
d278 1
a278 1
    sv->sv_debug_file = PL_curcop ? savesharedpv(CopFILE(PL_curcop)): NULL;
d368 2
a369 2
    SV* sv;
    SV* svend;
d413 2
a414 2
	const SV * const svend = &sva[SvREFCNT(sva)];
	SV* sv;
d478 1
a478 1
		SvREFCNT_dec_NN(target);
d482 2
d508 1
a508 1
	SvREFCNT_dec_NN(obj);
d514 1
a514 1
	SvREFCNT_dec_NN(obj);
d520 1
a520 1
	SvREFCNT_dec_NN(obj);
d526 1
a526 1
	SvREFCNT_dec_NN(obj);
d528 1
a528 1
    SvREFCNT_dec_NN(sv); /* undo the inc above */
d549 1
a549 1
	SvREFCNT_dec_NN(obj);
d551 1
a551 1
    SvREFCNT_dec_NN(sv); /* undo the inc above */
d610 1
a610 1
    SvREFCNT_dec_NN(sv);
d1139 1
a1139 1
Perl_sv_upgrade(pTHX_ SV *const sv, svtype new_type)
d1164 1
a1164 1
    if (new_type > SVt_PVMG && SvIsCOW(sv)) {
d1249 1
a1249 1
	if (UNLIKELY(old_type_details->cant_upgrade))
d1254 1
a1254 1
    if (UNLIKELY(old_type > new_type))
d1332 5
a1346 1
    case SVt_REGEXP:
d1393 1
a1393 1
	if (UNLIKELY(new_type == SVt_PVIO)) {
a1399 1
            DEBUG_o(Perl_deb(aTHX_ "sv_upgrade clearing PL_stashcache\n"));
d1405 1
a1405 3
	if (UNLIKELY(new_type == SVt_REGEXP))
	    sv->sv_u.svu_rx = (regexp *)new_body;
	else if (old_type < SVt_PV) {
d1440 1
a1440 1
Perl_sv_backoff(pTHX_ SV *const sv)
d1472 1
a1472 1
Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
d1474 1
a1474 1
    char *s;
a1505 2
    {
	if (SvIsCOW(sv)) sv_force_normal(sv);
a1506 1
    }
d1548 1
a1548 1
Perl_sv_setiv(pTHX_ SV *const sv, const IV i)
d1591 1
a1591 1
Perl_sv_setiv_mg(pTHX_ SV *const sv, const IV i)
d1609 1
a1609 1
Perl_sv_setuv(pTHX_ SV *const sv, const UV u)
d1642 1
a1642 1
Perl_sv_setuv_mg(pTHX_ SV *const sv, const UV u)
d1660 1
a1660 1
Perl_sv_setnv(pTHX_ SV *const sv, const NV num)
d1704 1
a1704 1
Perl_sv_setnv_mg(pTHX_ SV *const sv, const NV num)
d1805 1
a1805 1
    const char *sbegin;
d1821 2
d1825 2
a1829 3
    {
	SV *const buffer = sv_newmortal();
	gv_efullname3(buffer, gv, "*");
a1830 1
    }
d1921 1
a1921 1
S_sv_2iuv_non_preserve(pTHX_ SV *const sv
d2069 1
a2069 1
    else if (SvPOKp(sv)) {
d2256 1
a2256 1
Perl_sv_2iv_flags(pTHX_ SV *const sv, const I32 flags)
a2258 1

d2261 1
a2261 18

    if (SvGMAGICAL(sv) && (flags & SV_GMAGIC))
	mg_get(sv);

    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV * tmpstr;
	    if (flags & SV_SKIP_OVERLOAD)
		return 0;
	    tmpstr = AMG_CALLunary(sv, numer_amg);
	    if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		return SvIV(tmpstr);
	    }
	}
	return PTR2IV(SvRV(sv));
    }

    if (SvVALID(sv) || isREGEXP(sv)) {
a2266 2

	   Regexps have no SvIVX and SvNVX fields.
d2268 8
a2275 2
	assert(isREGEXP(sv) || SvPOKp(sv));
	{
a2276 2
	    const char * const ptr =
		isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX_const(sv);
d2278 1
a2278 1
		= grok_number(ptr, SvCUR(sv), &value);
d2295 20
a2314 1
	    return I_V(Atof(ptr));
a2315 4
    }

    if (SvTHINKFIRST(sv)) {
#ifdef PERL_OLD_COPY_ON_WRITE
a2318 1
#endif
a2324 1

a2328 1

d2345 1
a2345 1
Perl_sv_2uv_flags(pTHX_ SV *const sv, const I32 flags)
a2347 1

d2350 1
a2350 18

    if (SvGMAGICAL(sv) && (flags & SV_GMAGIC))
	mg_get(sv);

    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV *tmpstr;
	    if (flags & SV_SKIP_OVERLOAD)
		return 0;
	    tmpstr = AMG_CALLunary(sv, numer_amg);
	    if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		return SvUV(tmpstr);
	    }
	}
	return PTR2UV(SvRV(sv));
    }

    if (SvVALID(sv) || isREGEXP(sv)) {
d2352 8
a2359 4
	   the same flag bit as SVf_IVisUV, so must not let them cache IVs.  
	   Regexps have no SvIVX and SvNVX fields. */
	assert(isREGEXP(sv) || SvPOKp(sv));
	{
a2360 2
	    const char * const ptr =
		isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX_const(sv);
d2362 1
a2362 1
		= grok_number(ptr, SvCUR(sv), &value);
d2374 20
a2393 1
	    return U_V(Atof(ptr));
a2394 4
    }

    if (SvTHINKFIRST(sv)) {
#ifdef PERL_OLD_COPY_ON_WRITE
a2397 1
#endif
a2403 1

d2425 1
a2425 1
Perl_sv_2nv_flags(pTHX_ SV *const sv, const I32 flags)
d2430 1
a2430 1
    if (SvGMAGICAL(sv) || SvVALID(sv) || isREGEXP(sv)) {
d2432 1
a2432 3
	   the same flag bit as SVf_IVisUV, so must not let them cache NVs.
	   Regexps have no SvIVX and SvNVX fields.  */
	const char *ptr;
d2437 1
a2437 3
	if (SvPOKp(sv) && !SvIOKp(sv)) {
	    ptr = SvPVX_const(sv);
	  grokpv:
d2439 1
a2439 1
		!grok_number(ptr, SvCUR(sv), NULL))
d2441 1
a2441 1
	    return Atof(ptr);
a2451 4
	if (isREGEXP(sv)) {
	    ptr = RX_WRAPPED((REGEXP *)sv);
	    goto grokpv;
	}
a2468 1
#ifdef PERL_OLD_COPY_ON_WRITE
a2471 1
#endif
d2521 1
a2521 1
    else if (SvPOKp(sv)) {
d2654 1
a2654 1
Perl_sv_2num(pTHX_ SV *const sv)
d2715 1
a2715 1
Perl_sv_2pv_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)
d2718 1
a2718 1
    char *s;
d2725 31
a2755 13
    if (SvGMAGICAL(sv) && (flags & SV_GMAGIC))
	mg_get(sv);
    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    SV *tmpstr;
	    if (flags & SV_SKIP_OVERLOAD)
		return NULL;
	    tmpstr = AMG_CALLunary(sv, string_amg);
	    TAINT_IF(tmpstr && SvTAINTED(tmpstr));
	    if (tmpstr && (!SvROK(tmpstr) || (SvRV(tmpstr) != SvRV(sv)))) {
		/* Unwrap this:  */
		/* char *pv = lp ? SvPV(tmpstr, *lp) : SvPV_nolen(tmpstr);
		 */
d2757 39
a2795 4
		char *pv;
		if ((SvFLAGS(tmpstr) & (SVf_POK)) == SVf_POK) {
		    if (flags & SV_CONST_RETURN) {
			pv = (char *) SvPVX_const(tmpstr);
d2797 1
a2797 2
			pv = (flags & SV_MUTABLE_RETURN)
			    ? SvPVX_mutable(tmpstr) : SvPVX(tmpstr);
d2799 5
a2803 4
		    if (lp)
			*lp = SvCUR(tmpstr);
		} else {
		    pv = sv_2pv_flags(tmpstr, lp, flags);
a2804 5
		if (SvUTF8(tmpstr))
		    SvUTF8_on(sv);
		else
		    SvUTF8_off(sv);
		return pv;
d2806 15
a2820 14
	}
	{
	    STRLEN len;
	    char *retval;
	    char *buffer;
	    SV *const referent = SvRV(sv);

	    if (!referent) {
		len = 7;
		retval = buffer = savepvn("NULLREF", len);
	    } else if (SvTYPE(referent) == SVt_REGEXP &&
		       (!(PL_curcop->cop_hints & HINT_NO_AMAGIC) ||
			amagic_is_enabled(string_amg))) {
		REGEXP * const re = (REGEXP *)MUTABLE_PTR(referent);
d2822 1
a2822 1
		assert(re);
d2824 9
a2832 6
		/* If the regex is UTF-8 we want the containing scalar to
		   have an UTF-8 flag too */
		if (RX_UTF8(re))
		    SvUTF8_on(sv);
		else
		    SvUTF8_off(sv);	
d2834 2
a2835 2
		if (lp)
		    *lp = RX_WRAPLEN(re);
d2837 21
a2857 18
		return RX_WRAPPED(re);
	    } else {
		const char *const typestr = sv_reftype(referent, 0);
		const STRLEN typelen = strlen(typestr);
		UV addr = PTR2UV(referent);
		const char *stashname = NULL;
		STRLEN stashnamelen = 0; /* hush, gcc */
		const char *buffer_end;

		if (SvOBJECT(referent)) {
		    const HEK *const name = HvNAME_HEK(SvSTASH(referent));

		    if (name) {
			stashname = HEK_KEY(name);
			stashnamelen = HEK_LEN(name);

			if (HEK_UTF8(name)) {
			    SvUTF8_on(sv);
d2859 2
a2860 1
			    SvUTF8_off(sv);
d2862 2
d2865 2
a2866 2
			stashname = "__ANON__";
			stashnamelen = 8;
a2867 6
		    len = stashnamelen + 1 /* = */ + typelen + 3 /* (0x */
			+ 2 * sizeof(UV) + 2 /* )\0 */;
		} else {
		    len = typelen + 3 /* (0x */
			+ 2 * sizeof(UV) + 2 /* )\0 */;
		}
d2869 2
a2870 2
		Newx(buffer, len, char);
		buffer_end = retval = buffer + len;
d2872 21
a2892 21
		/* Working backwards  */
		*--retval = '\0';
		*--retval = ')';
		do {
		    *--retval = PL_hexdigit[addr & 15];
		} while (addr >>= 4);
		*--retval = 'x';
		*--retval = '0';
		*--retval = '(';

		retval -= typelen;
		memcpy(retval, typestr, typelen);

		if (stashname) {
		    *--retval = '=';
		    retval -= stashnamelen;
		    memcpy(retval, stashname, stashnamelen);
		}
		/* retval may not necessarily have reached the start of the
		   buffer here.  */
		assert (retval >= buffer);
d2894 6
a2899 1
		len = buffer_end - retval - 1; /* -1 for that \0  */
d2901 2
d2904 6
a2909 3
		*lp = len;
	    SAVEFREEPV(buffer);
	    return retval;
d2912 1
a2912 12

    if (SvPOKp(sv)) {
	if (lp)
	    *lp = SvCUR(sv);
	if (flags & SV_MUTABLE_RETURN)
	    return SvPVX_mutable(sv);
	if (flags & SV_CONST_RETURN)
	    return (char *)SvPVX_const(sv);
	return SvPVX(sv);
    }

    if (SvIOK(sv)) {
d2930 1
a2930 1
    else if (SvNOK(sv)) {
d2951 6
a2956 3
    else if (isGV_with_GP(sv)) {
	GV *const gv = MUTABLE_GV(sv);
	SV *const buffer = sv_newmortal();
d2958 7
a2964 1
	gv_efullname3(buffer, gv, "*");
a2965 12
	assert(SvPOK(buffer));
	if (SvUTF8(buffer))
	    SvUTF8_on(sv);
	if (lp)
	    *lp = SvCUR(buffer);
	return SvPVX(buffer);
    }
    else if (isREGEXP(sv)) {
	if (lp) *lp = RX_WRAPLEN((REGEXP *)sv);
	return RX_WRAPPED((REGEXP *)sv);
    }
    else {
d2972 2
a2973 2
	/* Typically the caller expects that sv_any is not NULL now.  */
	if (!SvREADONLY(sv) && SvTYPE(sv) < SVt_PV)
a2976 1

a3003 9
=for apidoc sv_copypv_nomg

Like sv_copypv, but doesn't invoke get magic first.

=for apidoc sv_copypv_flags

Implementation of sv_copypv and sv_copypv_nomg.  Calls get magic iff flags
include SV_GMAGIC.

d3008 1
a3008 9
Perl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv)
{
    PERL_ARGS_ASSERT_SV_COPYPV;

    sv_copypv_flags(dsv, ssv, 0);
}

void
Perl_sv_copypv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)
d3011 1
a3011 1
    const char *s;
d3013 1
a3013 1
    PERL_ARGS_ASSERT_SV_COPYPV_FLAGS;
a3014 3
    if ((flags & SV_GMAGIC) && SvGMAGICAL(ssv))
	mg_get(ssv);
    s = SvPV_nomg_const(ssv,len);
d3035 1
a3035 1
Perl_sv_2pvbyte(pTHX_ SV *sv, STRLEN *const lp)
d3039 1
a3039 2
    if (((SvREADONLY(sv) || SvFAKE(sv)) && !SvIsCOW(sv))
     || isGV_with_GP(sv) || SvROK(sv)) {
d3061 1
a3061 1
Perl_sv_2pvutf8(pTHX_ SV *sv, STRLEN *const lp)
d3065 1
a3065 2
    if (((SvREADONLY(sv) || SvFAKE(sv)) && !SvIsCOW(sv))
     || isGV_with_GP(sv) || SvROK(sv))
d3067 3
a3069 3
    else
        SvGETMAGIC(sv);
    sv_utf8_upgrade_nomg(sv);
d3092 1
a3092 1
Perl_sv_2bool_flags(pTHX_ SV *const sv, const I32 flags)
d3110 24
a3133 1
    return SvTRUE_common(sv, isGV_with_GP(sv) ? 1 : 0);
d3146 1
a3146 1
This is not a general purpose byte encoding to Unicode interface:
d3165 1
a3165 1
This is not a general purpose byte encoding to Unicode interface:
d3202 1
a3202 1
Perl_sv_utf8_upgrade_flags_grow(pTHX_ SV *const sv, const I32 flags, STRLEN extra)
d3210 1
a3210 1
    if (!SvPOK_nog(sv)) {
d3468 1
a3468 1
This is not a general purpose Unicode to byte encoding interface:
d3475 1
a3475 1
Perl_sv_utf8_downgrade(pTHX_ SV *const sv, const bool fail_ok)
d3535 1
a3535 1
Perl_sv_utf8_encode(pTHX_ SV *const sv)
d3559 1
a3559 1
Perl_sv_utf8_decode(pTHX_ SV *const sv)
d3708 1
a3742 1
      if (GvAV((const GV *)sstr)) {
d3754 1
a3754 2
      }
      mro_isa_changed_in(GvSTASH(dstr));
d3771 2
a3772 2
    SV * const sref = SvRV(sstr);
    SV *dref;
d3818 1
a3818 18
	    /* SAVEt_GVSLOT takes more room on the savestack and has more
	       overhead in leave_scope than SAVEt_GENERIC_SV.  But for CVs
	       leave_scope needs access to the GV so it can reset method
	       caches.  We must use SAVEt_GVSLOT whenever the type is
	       SVt_PVCV, even if the stash is anonymous, as the stash may
	       gain a name somehow before leave_scope. */
	    if (stype == SVt_PVCV) {
		/* There is no save_pushptrptrptr.  Creating it for this
		   one call site would be overkill.  So inline the ss add
		   routines here. */
                dSS_ADD;
		SS_ADD_PTR(dstr);
		SS_ADD_PTR(location);
		SS_ADD_PTR(SvREFCNT_inc(*location));
		SS_ADD_UV(SAVEt_GVSLOT);
		SS_ADD_END(4);
	    }
	    else SAVEGENERICSV(*location);
d3820 2
a3821 1
	dref = *location;
d3855 1
a3855 1
	    if(GvSTASH(dstr)) gv_method_changed(dstr); /* sub foo { 1 } sub bar { 2 } *bar = \&foo */
d3857 1
a3857 1
	*location = SvREFCNT_inc_simple_NN(sref);
a3927 8
        else if (stype == SVt_PVIO) {
            DEBUG_o(Perl_deb(aTHX_ "glob_assign_ref clearing PL_stashcache\n"));
            /* It's a cache. It will rebuild itself quite happily.
               It's a lot of effort to work out exactly which key (or keys)
               might be invalidated by the creation of the this file handle.
            */
            hv_clear(PL_stashcache);
        }
d3930 1
a3930 1
    if (!intro) SvREFCNT_dec(dref);
a3935 13
/* Work around compiler warnings about unsigned >= THRESHOLD when thres-
   hold is 0. */
#if SV_COW_THRESHOLD
# define GE_COW_THRESHOLD(len)		((len) >= SV_COW_THRESHOLD)
#else
# define GE_COW_THRESHOLD(len)		1
#endif
#if SV_COWBUF_THRESHOLD
# define GE_COWBUF_THRESHOLD(len)	((len) >= SV_COWBUF_THRESHOLD)
#else
# define GE_COWBUF_THRESHOLD(len)	1
#endif

d3937 1
a3937 1
Perl_sv_setsv_flags(pTHX_ SV *dstr, SV* sstr, const I32 flags)
d3940 3
a3942 3
    U32 sflags;
    int dtype;
    svtype stype;
d3963 7
d4037 9
a4069 1
      upgregexp:
a4070 7
	{
	    if (dtype >= SVt_PV) {
		SvPV_free(dstr);
		SvPV_set(dstr, 0);
		SvLEN_set(dstr, 0);
		SvCUR_set(dstr, 0);
	    }
a4071 1
	}
a4087 2
	{
	    if (isREGEXP(sstr)) goto upgregexp;
a4088 1
	}
d4098 1
a4098 1
    if (dtype == SVt_PVCV) {
d4113 1
a4113 2
    }
    else if (dtype == SVt_PVAV || dtype == SVt_PVHV || dtype == SVt_PVFM) {
d4198 1
a4198 2
    else if ((dtype == SVt_REGEXP || dtype == SVt_PVLV)
	  && (stype == SVt_REGEXP || isREGEXP(sstr))) {
a4202 2
	const STRLEN cur = SvCUR(sstr);
	const STRLEN len = SvLEN(sstr);
d4225 1
a4225 8
	       ? !(sflags & SVf_IsCOW)
#ifdef PERL_NEW_COPY_ON_WRITE
		|| (len &&
		    ((!GE_COWBUF_THRESHOLD(cur) && SvLEN(dstr) > cur)
		   /* If this is a regular (non-hek) COW, only so many COW
		      "copies" are possible. */
		    || CowREFCNT(sstr) == SV_COW_REFCNT_MAX))
#endif
d4231 1
a4231 1
#ifndef PERL_ANY_COW
d4241 1
a4241 1
	     || (SvFLAGS(dstr) & SVf_BREAK)
a4245 4
#ifdef PERL_NEW_COPY_ON_WRITE
				/* slated for free anyway (and not COW)? */
                 (sflags & (SVs_TEMP|SVf_IsCOW)) == SVs_TEMP &&
#else
a4246 1
#endif
d4251 2
a4252 2
                 len)             /* and really is a string */
#ifdef PERL_ANY_COW
a4254 1
# ifdef PERL_OLD_COPY_ON_WRITE
d4256 1
a4256 8
		     && SvTYPE(sstr) >= SVt_PVIV
# else
		     && !(SvFLAGS(dstr) & SVf_BREAK)
		     && !(sflags & SVf_IsCOW)
		     && GE_COW_THRESHOLD(cur) && cur+1 < len
		     && (GE_COWBUF_THRESHOLD(cur) || SvLEN(dstr) < cur+1)
# endif
		    ))
d4262 4
a4265 3
            SvGROW(dstr, cur + 1);	/* inlined from sv_setpvn */
            Move(SvPVX_const(sstr),SvPVX(dstr),cur,char);
            SvCUR_set(dstr, cur);
d4277 1
a4277 1
#ifdef PERL_ANY_COW
d4279 4
a4282 3
                if (!(sflags & SVf_IsCOW)) {
                    SvIsCOW_on(sstr);
# ifdef PERL_OLD_COPY_ON_WRITE
a4285 3
# else
		    CowREFCNT(sstr) = 0;
# endif
d4296 3
a4298 1
#ifdef PERL_ANY_COW
a4299 1
# ifdef PERL_OLD_COPY_ON_WRITE
a4304 3
# else
		    CowREFCNT(sstr)++;
# endif
d4319 2
a4320 1
                SvIsCOW_on(dstr);
d4387 1
a4387 1
Perl_sv_setsv_mg(pTHX_ SV *const dstr, SV *const sstr)
d4395 1
a4395 6
#ifdef PERL_ANY_COW
# ifdef PERL_OLD_COPY_ON_WRITE
#  define SVt_COW SVt_PVIV
# else
#  define SVt_COW SVt_PV
# endif
d4401 1
a4401 1
    char *new_pv;
d4417 1
a4417 1
	    Safefree(SvPVX_mutable(dstr));
d4421 1
a4421 1
    SvUPGRADE(dstr, SVt_COW);
a4424 1
# ifdef PERL_OLD_COPY_ON_WRITE
a4428 1
# endif
a4438 1
# ifdef PERL_OLD_COPY_ON_WRITE
a4439 4
# else
	assert(SvCUR(sstr)+1 < SvLEN(sstr));
	assert(CowREFCNT(sstr) < SV_COW_REFCNT_MAX);
# endif
d4442 3
a4444 2
	SvUPGRADE(sstr, SVt_COW);
	SvIsCOW_on(sstr);
a4446 1
# ifdef PERL_OLD_COPY_ON_WRITE
a4447 3
# else
	CowREFCNT(sstr) = 0;	
# endif
a4448 1
# ifdef PERL_OLD_COPY_ON_WRITE
a4449 3
# else
    CowREFCNT(sstr)++;	
# endif
d4454 1
a4454 1
    SvFLAGS(dstr) = (SVt_COW|SVf_POK|SVp_POK|SVf_IsCOW);
d4477 1
a4477 1
Perl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)
d4480 1
a4480 1
    char *dptr;
d4516 1
a4516 1
Perl_sv_setpvn_mg(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)
d4534 1
a4534 1
Perl_sv_setpv(pTHX_ SV *const sv, const char *const ptr)
d4537 1
a4537 1
    STRLEN len;
d4566 1
a4566 1
Perl_sv_setpv_mg(pTHX_ SV *const sv, const char *const ptr)
d4575 1
a4575 1
Perl_sv_sethek(pTHX_ SV *const sv, const HEK *const hek)
d4596 1
a4596 1
        } else if (flags & HVhek_UNSHARED) {
a4605 1
	    Safefree(SvPVX(sv));
d4609 2
a4610 1
	    SvIsCOW_on(sv);
d4712 1
a4712 1
S_sv_release_COW(pTHX_ SV *sv, const char *pvx, SV *after)
d4724 2
a4725 1
            SvIsCOW_off(after);
d4746 1
a4746 2
Undo various types of fakery on an SV, where fakery means
"more than" a string: if the PV is a shared string, make
d4749 1
a4749 2
we do the copy, and is also used locally; if this is a
vstring, drop the vstring magic.  If C<SV_COW_DROP_PV> is set
d4761 1
a4761 1
Perl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags)
d4767 1
a4767 1
#ifdef PERL_ANY_COW
d4769 8
a4776 13
	if (IN_PERL_RUNTIME)
	    Perl_croak_no_modify();
    }
    else if (SvIsCOW(sv)) {
	const char * const pvx = SvPVX_const(sv);
	const STRLEN len = SvLEN(sv);
	const STRLEN cur = SvCUR(sv);
# ifdef PERL_OLD_COPY_ON_WRITE
	/* next COW sv in the loop.  If len is 0 then this is a shared-hash
	   key scalar, so we mustn't attempt to call SV_COW_NEXT_SV(), as
	   we'll fail an assertion.  */
	SV * const next = len ? SV_COW_NEXT_SV(sv) : 0;
# endif
d4778 1
a4778 1
        if (DEBUG_C_TEST) {
d4783 3
a4785 10
        }
        SvIsCOW_off(sv);
# ifdef PERL_NEW_COPY_ON_WRITE
	if (len && CowREFCNT(sv) == 0)
	    /* We own the buffer ourselves. */
	    NOOP;
	else
# endif
	{
		
a4786 4
# ifdef PERL_NEW_COPY_ON_WRITE
	    /* Must do this first, since the macro uses SvPVX. */
	    if (len) CowREFCNT(sv)--;
# endif
a4798 1
# ifdef PERL_OLD_COPY_ON_WRITE
a4799 1
# endif
d4807 2
a4811 4
	if (IN_PERL_RUNTIME)
	    Perl_croak_no_modify();
    }
    else
d4815 2
a4816 1
	    SvIsCOW_off(sv);
d4829 3
d4837 1
a4837 1
    else if (SvFAKE(sv) && isREGEXP(sv)) {
d4840 1
a4840 3
	const bool islv = SvTYPE(sv) == SVt_PVLV;
	const svtype new_type =
	  islv ? SVt_NULL : SvMAGIC(sv) || SvSTASH(sv) ? SVt_PVMG : SVt_PV;
d4842 1
a4842 1
	regexp *const temp_p = ReANY((REGEXP *)sv);
d4850 12
a4861 16
	if (!islv) SvCUR_set(temp, SvCUR(sv));
	/* Remember that SvPVX is in the head, not the body.  But
	   RX_WRAPPED is in the body. */
	assert(ReANY((REGEXP *)sv)->mother_re);
	/* Their buffer is already owned by someone else. */
	if (flags & SV_COW_DROP_PV) {
	    /* SvLEN is already 0.  For SVt_REGEXP, we have a brand new
	       zeroed body.  For SVt_PVLV, it should have been set to 0
	       before turning into a regexp. */
	    assert(!SvLEN(islv ? sv : temp));
	    sv->sv_u.svu_pv = 0;
	}
	else {
	    sv->sv_u.svu_pv = savepvn(RX_WRAPPED((REGEXP *)sv), SvCUR(sv));
	    SvLEN_set(islv ? sv : temp, SvCUR(sv)+1);
	    SvPOK_on(sv);
d4866 3
a4868 6
	SvFAKE_off(sv);
	if (!islv) {
	    SvFLAGS(sv) &= ~SVTYPEMASK;
	    SvFLAGS(sv) |= new_type;
	    SvANY(sv) = SvANY(temp);
	}
a4872 1
	temp->sv_u.svu_rx = (regexp *)temp_p;
d4874 1
a4874 1
	SvREFCNT_dec_NN(temp);
a4875 1
    else if (SvVOK(sv)) sv_unmagic(sv, PERL_MAGIC_vstring);
d4882 3
a4884 4
SvPOK(sv), or at least SvPOKp(sv), must be true and the C<ptr> must be a
pointer to somewhere inside the string buffer.  The C<ptr> becomes the first
character of the adjusted string.  Uses the "OOK hack".  On return, only
SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.
d4897 1
a4897 1
Perl_sv_chop(pTHX_ SV *const sv, const char *const ptr)
a4922 1
    SvPOK_only_UTF8(sv);
d4996 1
a4996 1
Perl_sv_catpvn_flags(pTHX_ SV *const dsv, const char *sstr, const STRLEN slen, const I32 flags)
d5050 3
a5052 4
Concatenates the string from SV C<ssv> onto the end of the string in SV
C<dsv>.  If C<ssv> is null, does nothing; otherwise modifies only C<dsv>.
Handles 'get' magic on both SVs, but no 'set' magic.  See C<sv_catsv_mg> and
C<sv_catsv_nomg>.
d5056 6
a5061 6
Concatenates the string from SV C<ssv> onto the end of the string in SV
C<dsv>.  If C<ssv> is null, does nothing; otherwise modifies only C<dsv>.
If C<flags> include C<SV_GMAGIC> bit set, will call C<mg_get> on both SVs if
appropriate.  If C<flags> include C<SV_SMAGIC>, C<mg_set> will be called on
the modified SV afterward, if appropriate.  C<sv_catsv>, C<sv_catsv_nomg>,
and C<sv_catsv_mg> are implemented in terms of this function.
d5066 1
a5066 1
Perl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)
d5072 1
a5072 1
    if (ssv) {
d5076 2
a5077 2
            if (flags & SV_GMAGIC)
                SvGETMAGIC(dsv);
d5080 1
a5080 3
            if (flags & SV_SMAGIC)
                SvSETMAGIC(dsv);
        }
d5082 2
d5096 1
a5096 1
Perl_sv_catpv(pTHX_ SV *const sv, const char *ptr)
d5099 1
a5099 1
    STRLEN len;
d5145 1
a5145 1
Perl_sv_catpv_mg(pTHX_ SV *const sv, const char *const ptr)
d5174 1
a5174 1
    SV *sv;
d5271 2
d5293 1
a5293 1
Perl_sv_magic(pTHX_ SV *const sv, SV *const obj, const int how,
d5318 1
a5318 1
#ifdef PERL_ANY_COW
d5331 1
a5331 1
	    Perl_croak_no_modify();
d5339 1
a5339 1
	    if (how == PERL_MAGIC_taint)
d5341 5
d5468 1
a5468 1
    SvREFCNT_dec_NN(tsv);
d5691 1
a5691 1
    /* after multiple passes through Perl_sv_clean_all() for a thingy
d5764 1
a5764 1
	SvREFCNT_dec_NN(av); /* remove extra count added by sv_add_backref() */
d5787 5
a5791 5
    char *big;
    char *mid;
    char *midend;
    char *bigend;
    SSize_t i;		/* better be sizeof(STRLEN) or bad things happen */
d5882 1
a5882 1
Perl_sv_replace(pTHX_ SV *const sv, SV *const nsv)
a5966 1
    assert(!CvNAMED(cv));
d5970 1
a5970 1
	SvANY(cv)->xcv_gv_u.xcv_gv = NULL;
d5980 1
a5980 1
    SvREFCNT_dec_NN(gvname);
d5984 1
a5984 1
    SvANY(cv)->xcv_gv_u.xcv_gv = MUTABLE_GV(SvREFCNT_inc(anongv));
d6011 1
a6011 1
    SV *sv = orig_sv;
a6084 1
	  freeregexp:
d6107 1
a6107 3
		    if (PL_stashcache) {
                    DEBUG_o(Perl_deb(aTHX_ "sv_clear clearing PL_stashcache for '%"SVf"'\n",
                                     sv));
a6109 1
                    }
a6157 1
	    if (isREGEXP(sv)) goto freeregexp;
a6179 2
            else if ((const GV *)sv == PL_stderrgv)
                PL_stderrgv = NULL;
d6203 1
a6203 1
#ifdef PERL_ANY_COW
a6213 1
# ifdef PERL_OLD_COPY_ON_WRITE
a6214 6
# else
			if (CowREFCNT(sv)) {
			    CowREFCNT(sv)--;
			    SvLEN_set(sv, 0);
			}
# endif
d6219 3
a6221 6
		}
# ifdef PERL_OLD_COPY_ON_WRITE
		else
# endif
		if (SvLEN(sv)) {
		    Safefree(SvPVX_mutable(sv));
d6231 1
a6292 4
#ifdef DEBUGGING
		    /* perl -DA does not like rubbish in SvMAGIC. */
		    SvMAGIC_set(sv, 0);
#endif
d6319 1
a6319 1
	    if (SvIMMORTAL(sv)) {
d6321 1
a6321 1
		SvREFCNT(sv) = SvREFCNT_IMMORTAL;
d6346 4
a6349 23
	  stash = SvSTASH(sv);
	  assert(SvTYPE(stash) == SVt_PVHV);
	  if (HvNAME(stash)) {
	    CV* destructor = NULL;
	    assert (SvOOK(stash));
	    if (!SvOBJECT(stash)) destructor = (CV *)SvSTASH(stash);
	    if (!destructor || HvMROMETA(stash)->destroy_gen
				!= PL_sub_generation)
	    {
		GV * const gv =
		    gv_fetchmeth_autoload(stash, "DESTROY", 7, 0);
		if (gv) destructor = GvCV(gv);
		if (!SvOBJECT(stash))
		{
		    SvSTASH(stash) =
			destructor ? (HV *)destructor : ((HV *)0)+1;
		    HvAUX(stash)->xhv_mro_meta->destroy_gen =
			PL_sub_generation;
		}
	    }
	    assert(!destructor || destructor == ((CV *)0)+1
		|| SvTYPE(destructor) == SVt_PVCV);
	    if (destructor && destructor != ((CV *)0)+1
d6386 1
a6386 1
		SvREFCNT_dec_NN(tmpref);
a6387 1
	  }
d6402 1
a6402 3
	HV * const stash = SvSTASH(sv);
	/* Curse before freeing the stash, as freeing the stash could cause
	   a recursive call into S_curse. */
d6404 2
a6405 2
	SvSTASH_set(sv,0);	/* SvREFCNT_dec may try to read this */
	SvREFCNT_dec(stash); /* possibly of changed persuasion */
d6442 43
a6484 1
    SvREFCNT_dec(sv);
a6486 4

/* Private helper function for SvREFCNT_dec().
 * Called with rc set to original SvREFCNT(sv), where rc == 0 or 1 */

d6488 1
a6488 1
Perl_sv_free2(pTHX_ SV *const sv, const U32 rc)
a6493 4
    if (rc == 1) {
        /* normal case */
        SvREFCNT(sv) = 0;

d6495 5
a6499 32
        if (SvTEMP(sv)) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING),
                             "Attempt to free temp prematurely: SV 0x%"UVxf
                             pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
            return;
        }
#endif
        if (SvIMMORTAL(sv)) {
            /* make sure SvREFCNT(sv)==0 happens very seldom */
            SvREFCNT(sv) = SvREFCNT_IMMORTAL;
            return;
        }
        sv_clear(sv);
        if (! SvREFCNT(sv)) /* may have have been resurrected */
            del_SV(sv);
        return;
    }

    /* handle exceptional cases */

    assert(rc == 0);

    if (SvFLAGS(sv) & SVf_BREAK)
        /* this SV's refcnt has been artificially decremented to
         * trigger cleanup */
        return;
    if (PL_in_clean_all) /* All is fair */
        return;
    if (SvIMMORTAL(sv)) {
        /* make sure SvREFCNT(sv)==0 happens very seldom */
        SvREFCNT(sv) = SvREFCNT_IMMORTAL;
        return;
a6500 18
    if (ckWARN_d(WARN_INTERNAL)) {
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
        Perl_dump_sv_child(aTHX_ sv);
#else
    #ifdef DEBUG_LEAKING_SCALARS
        sv_dump(sv);
    #endif
#ifdef DEBUG_LEAKING_SCALARS_ABORT
        if (PL_warnhook == PERL_WARNHOOK_FATAL
            || ckDEAD(packWARN(WARN_INTERNAL))) {
            /* Don't let Perl_warner cause us to escape our fate:  */
            abort();
        }
#endif
        /* This may not return:  */
        Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                    "Attempt to free unreferenced scalar: SV 0x%"UVxf
                    pTHX__FORMAT, PTR2UV(sv) pTHX__VALUE);
d6502 4
d6507 3
a6509 4
#ifdef DEBUG_LEAKING_SCALARS_ABORT
    abort();
#endif

a6511 1

d6516 1
a6516 2
coercion and sets the UTF8 flag appropriately.  See also C<SvCUR>, which
gives raw access to the xpv_cur slot.
d6522 1
a6522 1
Perl_sv_len(pTHX_ SV *const sv)
d6529 4
a6532 1
    (void)SvPV_const(sv, len);
d6555 1
a6555 1
Perl_sv_len_utf8(pTHX_ SV *const sv)
d6560 6
a6565 3
    SvGETMAGIC(sv);
    return sv_len_utf8_nomg(sv);
}
d6567 1
a6567 10
STRLEN
Perl_sv_len_utf8_nomg(pTHX_ SV * const sv)
{
    dVAR;
    STRLEN len;
    const U8 *s = (U8*)SvPV_nomg_const(sv, len);

    PERL_ARGS_ASSERT_SV_LEN_UTF8_NOMG;

    if (PL_utf8cache && SvUTF8(sv)) {
d6593 2
a6595 1
    return SvUTF8(sv) ? Perl_utf8_length(aTHX_ s, s + len) : len;
d6683 1
a6683 1
    if (!SvREADONLY(sv) && !SvGMAGICAL(sv) && SvPOK(sv)
d6766 1
a6766 1
    if (PL_utf8cache && !SvGMAGICAL(sv) && SvPOK(sv)) {
d6858 1
a6858 1
Perl_sv_pos_u2b(pTHX_ SV *const sv, I32 *const offsetp, I32 *const lenp)
d6878 1
a6878 1
    if (SvREADONLY(sv) || SvGMAGICAL(sv) || !SvPOK(sv))
d6985 1
d6994 6
a6999 4
                cache[2] = cache[0];
                cache[3] = cache[1];
                cache[0] = utf8;
                cache[1] = byte;
d7002 4
a7005 2
                cache[0] = utf8;
                cache[1] = byte;
d7016 4
a7019 2
                cache[2] = utf8;
                cache[3] = byte;
d7022 4
a7025 2
                cache[0] = utf8;
                cache[1] = byte;
d7036 4
a7039 2
                cache[2] = utf8;
                cache[3] = byte;
d7042 6
a7047 4
                cache[0] = cache[2];
                cache[1] = cache[3];
                cache[2] = utf8;
                cache[3] = byte;
d7097 1
a7097 1
Perl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp)
d7224 1
a7224 1
Perl_sv_eq_flags(pTHX_ SV *sv1, SV *sv2, const U32 flags)
d7273 1
a7273 1
		   SvREFCNT_dec_NN(svrecode);
d7319 1
a7319 1
Perl_sv_cmp(pTHX_ SV *const sv1, SV *const sv2)
d7325 1
a7325 1
Perl_sv_cmp_flags(pTHX_ SV *const sv1, SV *const sv2,
d7331 1
d7395 2
d7418 1
a7418 1
Perl_sv_cmp_locale(pTHX_ SV *const sv1, SV *const sv2)
d7424 1
a7424 1
Perl_sv_cmp_locale_flags(pTHX_ SV *const sv1, SV *const sv2,
d7561 2
a7562 2
    SSize_t bytesread;
    const STRLEN recsize = SvUV(SvRV(PL_rs)); /* RsRECORD() guarantees > 0. */
d7564 1
a7564 3
    char *buffer = SvGROW(sv, (STRLEN)(recsize + append + 1)) + append;
    
    /* Go yank in */
a7565 1
#include <rms.h>
d7567 1
a7567 1
    Stat_t st;
d7569 7
a7575 6
    /* With a true, record-oriented file on VMS, we need to use read directly
     * to ensure that we respect RMS record boundaries.  The user is responsible
     * for providing a PL_rs value that corresponds to the FAB$W_MRS (maximum
     * record size) field.  N.B. This is likely to produce invalid results on
     * varying-width character data when a record ends mid-character.
     */
d7577 1
a7577 6
    if (fd != -1
	&& PerlLIO_fstat(fd, &st) == 0
	&& (st.st_fab_rfm == FAB$C_VAR
	    || st.st_fab_rfm == FAB$C_VFC
	    || st.st_fab_rfm == FAB$C_FIX)) {

d7580 1
a7580 3
    else /* in-memory file from PerlIO::Scalar
          * or not a record-oriented file
          */
a7583 73

	/* At this point, the logic in sv_get() means that sv will
	   be treated as utf-8 if the handle is utf8.
	*/
	if (PerlIO_isutf8(fp) && bytesread > 0) {
	    char *bend = buffer + bytesread;
	    char *bufp = buffer;
	    size_t charcount = 0;
	    bool charstart = TRUE;
	    STRLEN skip = 0;

	    while (charcount < recsize) {
		/* count accumulated characters */
		while (bufp < bend) {
		    if (charstart) {
			skip = UTF8SKIP(bufp);
		    }
		    if (bufp + skip > bend) {
			/* partial at the end */
			charstart = FALSE;
			break;
		    }
		    else {
			++charcount;
			bufp += skip;
			charstart = TRUE;
		    }
		}

		if (charcount < recsize) {
		    STRLEN readsize;
		    STRLEN bufp_offset = bufp - buffer;
		    SSize_t morebytesread;

		    /* originally I read enough to fill any incomplete
		       character and the first byte of the next
		       character if needed, but if there's many
		       multi-byte encoded characters we're going to be
		       making a read call for every character beyond
		       the original read size.

		       So instead, read the rest of the character if
		       any, and enough bytes to match at least the
		       start bytes for each character we're going to
		       read.
		    */
		    if (charstart)
			readsize = recsize - charcount;
		    else 
			readsize = skip - (bend - bufp) + recsize - charcount - 1;
		    buffer = SvGROW(sv, append + bytesread + readsize + 1) + append;
		    bend = buffer + bytesread;
		    morebytesread = PerlIO_read(fp, bend, readsize);
		    if (morebytesread <= 0) {
			/* we're done, if we still have incomplete
			   characters the check code in sv_gets() will
			   warn about them.

			   I'd originally considered doing
			   PerlIO_ungetc() on all but the lead
			   character of the incomplete character, but
			   read() doesn't do that, so I don't.
			*/
			break;
		    }

		    /* prepare to scan some more */
		    bytesread += morebytesread;
		    bend = buffer + bytesread;
		    bufp = buffer + bufp_offset;
		}
	    }
	}
d7597 1
a7597 4
appending to the currently-stored string. If C<append> is not 0, the
line is appended to the SV instead of overwriting it. C<append> should
be set to the byte offset that the appended string should start at
in the SV (typically, C<SvCUR(sv)> is a suitable choice).
d7603 1
a7603 1
Perl_sv_gets(pTHX_ SV *const sv, PerlIO *const fp, I32 append)
d7608 3
a7610 3
    STDCHAR rslast;
    STDCHAR *bp;
    I32 cnt;
d7625 2
d7719 1
a7719 1
    STDCHAR *ptr;
d7865 1
a7865 1
            const STDCHAR * const bpe = buf + sizeof(buf);
d7885 1
a7885 1
            sv_catpvn_nomg(sv, (char *) buf, cnt);
d7887 1
a7887 1
            sv_setpvn(sv, (char *) buf, cnt);   /* "nomg" is implied */
d7938 1
a7938 1
Perl_sv_inc(pTHX_ SV *const sv)
d7956 1
a7956 1
Perl_sv_inc_nomg(pTHX_ SV *const sv)
d7959 1
a7959 1
    char *d;
d7969 1
a7969 1
		Perl_croak_no_modify();
d8120 1
a8120 1
Perl_sv_dec(pTHX_ SV *const sv)
d8139 1
a8139 1
Perl_sv_dec_nomg(pTHX_ SV *const sv)
d8151 1
a8151 1
		Perl_croak_no_modify();
d8278 1
a8278 1
Perl_sv_mortalcopy_flags(pTHX_ SV *const oldstr, U32 flags)
d8281 1
a8281 1
    SV *sv;
a8282 2
    if (flags & SV_GMAGIC)
	SvGETMAGIC(oldstr); /* before new_SV, in case it dies */
d8284 1
a8284 1
    sv_setsv_flags(sv,oldstr,flags & ~SV_GMAGIC);
d8305 1
a8305 1
    SV *sv;
d8338 1
a8338 1
    SV *sv;
d8376 1
a8376 1
Perl_sv_2mortal(pTHX_ SV *const sv)
d8381 1
a8381 1
    if (SvIMMORTAL(sv))
d8402 1
a8402 1
    SV *sv;
d8426 1
a8426 1
    SV *sv;
d8469 7
a8475 2
        } else if (flags & HVhek_UNSHARED) {
            /* A hash that isn't using shared hash keys has to have
d8495 2
a8496 1
	    SvIsCOW_on(sv);
d8510 1
a8510 2
created first.  Turns on the SvIsCOW flag (or READONLY
and FAKE in 5.16 and earlier).  If the C<hash> parameter
d8524 1
a8524 1
    SV *sv;
d8544 2
a8545 1
    SvIsCOW_on(sv);
d8580 1
a8580 1
    SV *sv;
d8604 1
a8604 1
    SV *sv;
d8621 1
a8621 1
    SV *sv;
d8643 1
a8643 1
    SV *sv;
d8663 1
a8663 1
    SV *sv;
d8683 1
a8683 1
    SV *sv;
d8702 1
a8702 1
    SV *sv;
d8722 1
a8722 1
    SV *sv = newSV_type(SVt_IV);
d8756 1
a8756 1
Perl_newSVsv(pTHX_ SV *const old)
d8759 1
a8759 1
    SV *sv;
a8766 2
    /* Do this here, otherwise we leak the new SV if this croaks. */
    SvGETMAGIC(old);
d8768 2
a8769 1
    /* SV_NOSTEAL prevents TEMP buffers being, well, stolen, and saves games
d8771 1
a8771 1
    sv_setsv_flags(sv, old, SV_NOSTEAL);
d8785 1
a8785 9
Perl_sv_reset(pTHX_ const char *s, HV *const stash)
{
    PERL_ARGS_ASSERT_SV_RESET;

    sv_resetpvn(*s ? s : NULL, strlen(s), stash);
}

void
Perl_sv_resetpvn(pTHX_ const char *s, STRLEN len, HV * const stash)
d8789 2
a8790 1
    const char *send;
d8795 1
a8795 1
    if (!s) {		/* reset ?? searches */
d8820 1
a8820 2
    send = s + len;
    while (s < send) {
d8836 2
a8837 2
		GV *gv;
		SV *sv;
d9009 4
d9016 7
a9022 1
	    newSTUB(gv,0);
d9039 1
a9039 1
Perl_sv_true(pTHX_ SV *const sv)
d9044 1
a9044 1
	const XPV* const tXpv = (XPV*)SvANY(sv);
d9110 1
a9110 1
	if (SvTYPE(sv) > SVt_PVLV
a9115 3
	if (!s) {
	  s = (char *)"";
	}
a9134 1
    (void)SvPOK_only_UTF8(sv);
d9172 2
a9173 2
    sv_pvn_force(sv,0);
    sv_utf8_upgrade_nomg(sv);
d9237 1
a9237 1
Perl_sv_ref(pTHX_ SV *dst, const SV *const sv, const int ob)
d9315 4
a9318 4
Creates a new SV for the existing RV, C<rv>, to point to.  If C<rv> is not an
RV then it will be upgraded to one.  If C<classname> is non-null then the new
SV will be blessed in the specified package.  The new SV is returned and its
reference count is 1. The reference count 1 is owned by C<rv>.
d9334 1
d9505 4
a9508 2
	if (SvREADONLY(tmpRef) && !SvIsCOW(tmpRef))
	    Perl_croak_no_modify();
d9510 2
d9516 2
d9521 5
d9624 1
a9624 1
	SvREFCNT_dec_NN(target);
d9966 1
a9966 1
    sv_vcatpvfn_flags(sv, pat, patlen, args, svargs, svmax, maybe_tainted, 0);
a10039 2
=for apidoc sv_vcatpvfn_flags

a10045 2
If called as C<sv_vcatpvfn> or flags include C<SV_GMAGIC>, calls get magic.

d10051 1
a10061 10
    PERL_ARGS_ASSERT_SV_VCATPVFN;

    sv_vcatpvfn_flags(sv, pat, patlen, args, svargs, svmax, maybe_tainted, SV_GMAGIC|SV_SMAGIC);
}

void
Perl_sv_vcatpvfn_flags(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen,
                       va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted,
                       const U32 flags)
{
d10080 1
a10080 1
    PERL_ARGS_ASSERT_SV_VCATPVFN_FLAGS;
a10082 3
    if (flags & SV_GMAGIC)
        SvGETMAGIC(sv);

d10084 1
a10084 1
    (void)SvPV_force_nomg(sv, origlen);
d10092 1
a10092 1
	    sv_catpv_nomg(sv, s ? s : nullstr);
d10095 1
a10095 3
	    /* we want get magic on the source but not the target. sv_catsv can't do that, though */
	    SvGETMAGIC(*svargs);
	    sv_catsv_nomg(sv, *svargs);
d10104 1
a10104 1
	sv_catsv_nomg(sv, argsv);
d10127 1
a10127 1
		    sv_catpv_nomg(sv, ebuf);
d10135 1
a10135 1
		    sv_catpvn_nomg(sv, p, l);
d10206 1
a10206 1
		sv_catpvn_nomg_utf8_upgrade(sv, p, q - p, nsv);
d10208 1
a10208 1
		sv_catpvn_nomg(sv, p, q - p);
d10428 1
d10430 1
a10430 1
			Perl_ck_warner_d(aTHX_ packWARN(WARN_PRINTF),
d10432 1
a10432 1
			goto vdblank;
d10435 1
a10435 2
		    scan_vstring((char *)vecstr, (char *)vecstr + veclen,
				 vecsv);
d10438 1
a10441 1
	      vdblank:
d10452 1
a10452 1
#  ifdef USE_64_BIT_INT
d10463 1
a10463 1
#  ifdef USE_64_BIT_INT
d10570 4
a10573 4
			STRLEN ulen = sv_or_pv_len_utf8(argsv, eptr, elen);
			STRLEN p = precis > ulen ? ulen : precis;
			precis = sv_or_pv_pos_u2b(argsv, eptr, p, 0);
							/* sticks at end */
d10579 1
a10579 2
			    width +=
				elen - sv_or_pv_len_utf8(argsv,eptr,elen);
d11082 1
a11082 1
			    sv_catpvn_nomg(msg, f, 1);
d11133 1
a11133 1
	    Perl_croak_memory_wrap();
d11139 1
a11139 1
	    Perl_croak_memory_wrap();
d11284 1
d11387 1
a11387 1
    const Direntry_t *dirent;
a11778 1
    assert(!isREGEXP(sstr));
d11796 6
a11801 3
	    /* sstr may not be that normal, but actually copy on write.
	       But we are a true, independent SV, so:  */
	    SvIsCOW_off(dstr);
d11808 1
a11808 1
	    else if ((SvIsCOW(sstr))) {
d11906 1
a11906 1
    dstr->sv_debug_file = savesharedpv(sstr->sv_debug_file);
a11993 1
		&& !isREGEXP(dstr)
d12007 1
a12007 1
		if (SvOBJECT(dstr) && SvSTASH(dstr))
a12008 1
		else SvSTASH_set(dstr, 0); /* don't copy DESTROY cache */
a12021 1
	      duprex:
a12022 1
		dstr->sv_u.svu_rx = ((REGEXP *)dstr)->sv_any;
a12032 1
		if (isREGEXP(sstr)) goto duprex;
a12181 1
			daux->xhv_super = NULL;
a12205 1
		    CvSLABBED_off(dstr);
a12209 1
		assert(!CvSLABBED(dstr));
a12210 3
		if (CvNAMED(dstr))
		    SvANY((CV *)dstr)->xcv_gv_u.xcv_hek =
			share_hek_hek(CvNAME_HEK((CV *)sstr));
d12213 1
a12213 2
		else
		  SvANY(MUTABLE_CV(dstr))->xcv_gv_u.xcv_gv =
d12230 3
a12480 1
	case SAVEt_CLEARPADRANGE:
a12509 8
        case SAVEt_GVSLOT:		/* any slot in GV */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    ptr = POPPTR(ss,ix);
	    TOPPTR(nss,ix) = svp_dup_inc((SV**)ptr, proto_perl);/* XXXXX */
	    sv = (const SV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = sv_dup_inc(sv, param);
	    break;
d12695 2
d12699 23
a12721 1
#ifdef PERL_ANY_COW
a12926 1

a12935 1

d12942 1
d12948 15
d12968 5
a12976 1
#if !NO_TAINT_SUPPORT
a12979 4
#else
    PL_tainting         = FALSE;
    PL_taint_warn	= FALSE;
#endif
a12992 1
#ifdef PERL_SAWAMPERSAND
a12993 1
#endif
d13012 1
d13067 2
d13119 1
a13154 1
#if !NO_TAINT_SUPPORT
a13155 3
#else
    PL_tainted          = FALSE;
#endif
a13198 1
    init_constants();
d13200 7
d13208 6
d13222 4
a13225 1
    /* This PV will be free'd special way so must set it same way op.c does */
d13266 1
a13282 9
    PL_stashpadmax	= proto_perl->Istashpadmax;
    PL_stashpadix	= proto_perl->Istashpadix ;
    Newx(PL_stashpad, PL_stashpadmax, HV *);
    {
	PADOFFSET o = 0;
	for (; o < PL_stashpadmax; ++o)
	    PL_stashpad[o] = hv_dup(proto_perl->Istashpad[o], param);
    }

d13413 44
a13456 2
    PL_NonL1NonFinalFold = sv_dup_inc(proto_perl->INonL1NonFinalFold, param);
    PL_HasMultiCharFold= sv_dup_inc(proto_perl->IHasMultiCharFold, param);
d13459 10
a13468 8
    for (i = 0; i < POSIX_SWASH_COUNT; i++) {
        PL_utf8_swash_ptrs[i] = sv_dup_inc(proto_perl->Iutf8_swash_ptrs[i], param);
    }
    for (i = 0; i < POSIX_CC_COUNT; i++) {
        PL_Posix_ptrs[i] = sv_dup_inc(proto_perl->IPosix_ptrs[i], param);
        PL_L1Posix_ptrs[i] = sv_dup_inc(proto_perl->IL1Posix_ptrs[i], param);
        PL_XPosix_ptrs[i] = sv_dup_inc(proto_perl->IXPosix_ptrs[i], param);
    }
d13470 1
a13470 1
    PL_utf8_X_regular_begin	= sv_dup_inc(proto_perl->Iutf8_X_regular_begin, param);
d13472 8
a13486 1
    PL_utf8_perl_idcont = sv_dup_inc(proto_perl->Iutf8_perl_idcont, param);
d13490 1
a13490 2
    PL_utf8_charname_begin = sv_dup_inc(proto_perl->Iutf8_charname_begin, param);
    PL_utf8_charname_continue = sv_dup_inc(proto_perl->Iutf8_charname_continue, param);
d13495 1
a13537 5
        /* reset stack AV to correct length before its duped via
         * PL_curstackinfo */
        AvFILLp(proto_perl->Icurstack) =
                            proto_perl->Istack_sp - proto_perl->Istack_base;

d13672 1
a13672 1
    SvREFCNT_dec_NN(unreferenced);
a13735 32
void
Perl_init_constants(pTHX)
{
    SvREFCNT(&PL_sv_undef)	= SvREFCNT_IMMORTAL;
    SvFLAGS(&PL_sv_undef)	= SVf_READONLY|SVt_NULL;
    SvANY(&PL_sv_undef)		= NULL;

    SvANY(&PL_sv_no)		= new_XPVNV();
    SvREFCNT(&PL_sv_no)		= SvREFCNT_IMMORTAL;
    SvFLAGS(&PL_sv_no)		= SVt_PVNV|SVf_READONLY
				  |SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK;

    SvANY(&PL_sv_yes)		= new_XPVNV();
    SvREFCNT(&PL_sv_yes)	= SvREFCNT_IMMORTAL;
    SvFLAGS(&PL_sv_yes)		= SVt_PVNV|SVf_READONLY
				  |SVp_IOK|SVf_IOK|SVp_NOK|SVf_NOK
				  |SVp_POK|SVf_POK;

    SvPV_set(&PL_sv_no, (char*)PL_No);
    SvCUR_set(&PL_sv_no, 0);
    SvLEN_set(&PL_sv_no, 0);
    SvIV_set(&PL_sv_no, 0);
    SvNV_set(&PL_sv_no, 0);

    SvPV_set(&PL_sv_yes, (char*)PL_Yes);
    SvCUR_set(&PL_sv_yes, 1);
    SvLEN_set(&PL_sv_yes, 0);
    SvIV_set(&PL_sv_yes, 1);
    SvNV_set(&PL_sv_yes, 1);
}

d13771 2
a13772 2
	PUSHs(encoding);
	PUSHs(sv);
d13842 3
a13844 3
	PUSHs(encoding);
	PUSHs(dsv);
	PUSHs(ssv);
d13846 2
a13847 2
	mPUSHs(offsv);
	mPUSHp(tstr, tlen);
d13880 1
a13880 1
    HE **array;
d13891 2
a13892 2
    for (i=HvMAX(hv); i>=0; i--) {
	HE *entry;
d13934 1
a13934 1
/* varname(): return the name of a variable, optionally with a subscript.
d13970 1
a13970 1
	CV * const cv = gv ? ((CV *)gv) : find_runcv(NULL);
d13974 1
a13974 1
	assert(!cv || SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM);
d13978 1
a13978 1
	av = *PadlistARRAY(CvPADLIST(cv));
d13980 1
a13980 1
	sv_setsv_flags(name, sv, 0);
d13989 1
a13989 1
	SvREFCNT_dec_NN(sv);
d14044 2
a14045 10
	const bool pad  = (    obase->op_type == OP_PADAV
                            || obase->op_type == OP_PADHV
                            || obase->op_type == OP_PADRANGE
                          );

	const bool hash = (    obase->op_type == OP_PADHV
                            || obase->op_type == OP_RV2HV
                            || (obase->op_type == OP_PADRANGE
                                && SvTYPE(PAD_SVl(obase->op_targ)) == SVt_PVHV)
                          );
d14251 1
a14251 3
	if (   o->op_type == OP_PUSHMARK
	   || (o->op_type == OP_NULL && o->op_targ == OP_PUSHMARK)
        )
d14295 1
a14295 4
	if ((obase->op_flags & OPf_STACKED)
            &&
               (   o->op_type == OP_PUSHMARK
               || (o->op_type == OP_NULL && o->op_targ == OP_PUSHMARK)))
a14422 2
         * Note that we skip padrange, because the individual pad ops that
         * it replaced are still in the tree, so we work on them instead.
a14430 1
		  || (type == OP_PADRANGE)
d14489 1
a14489 1
 * indent-tabs-mode: nil
d14492 1
a14492 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d36 1
a36 1
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L && !defined(VMS)
d40 1
a40 1
#ifdef HAS_C99
d44 2
a50 67
#ifdef PERL_NEW_COPY_ON_WRITE
#   ifndef SV_COW_THRESHOLD
#    define SV_COW_THRESHOLD                    0   /* COW iff len > K */
#   endif
#   ifndef SV_COWBUF_THRESHOLD
#    define SV_COWBUF_THRESHOLD                 1250 /* COW iff len > K */
#   endif
#   ifndef SV_COW_MAX_WASTE_THRESHOLD
#    define SV_COW_MAX_WASTE_THRESHOLD          80   /* COW iff (len - cur) < K */
#   endif
#   ifndef SV_COWBUF_WASTE_THRESHOLD
#    define SV_COWBUF_WASTE_THRESHOLD           80   /* COW iff (len - cur) < K */
#   endif
#   ifndef SV_COW_MAX_WASTE_FACTOR_THRESHOLD
#    define SV_COW_MAX_WASTE_FACTOR_THRESHOLD   2    /* COW iff len < (cur * K) */
#   endif
#   ifndef SV_COWBUF_WASTE_FACTOR_THRESHOLD
#    define SV_COWBUF_WASTE_FACTOR_THRESHOLD    2    /* COW iff len < (cur * K) */
#   endif
#endif
/* Work around compiler warnings about unsigned >= THRESHOLD when thres-
   hold is 0. */
#if SV_COW_THRESHOLD
# define GE_COW_THRESHOLD(cur) ((cur) >= SV_COW_THRESHOLD)
#else
# define GE_COW_THRESHOLD(cur) 1
#endif
#if SV_COWBUF_THRESHOLD
# define GE_COWBUF_THRESHOLD(cur) ((cur) >= SV_COWBUF_THRESHOLD)
#else
# define GE_COWBUF_THRESHOLD(cur) 1
#endif
#if SV_COW_MAX_WASTE_THRESHOLD
# define GE_COW_MAX_WASTE_THRESHOLD(cur,len) (((len)-(cur)) < SV_COW_MAX_WASTE_THRESHOLD)
#else
# define GE_COW_MAX_WASTE_THRESHOLD(cur,len) 1
#endif
#if SV_COWBUF_WASTE_THRESHOLD
# define GE_COWBUF_WASTE_THRESHOLD(cur,len) (((len)-(cur)) < SV_COWBUF_WASTE_THRESHOLD)
#else
# define GE_COWBUF_WASTE_THRESHOLD(cur,len) 1
#endif
#if SV_COW_MAX_WASTE_FACTOR_THRESHOLD
# define GE_COW_MAX_WASTE_FACTOR_THRESHOLD(cur,len) ((len) < SV_COW_MAX_WASTE_FACTOR_THRESHOLD * (cur))
#else
# define GE_COW_MAX_WASTE_FACTOR_THRESHOLD(cur,len) 1
#endif
#if SV_COWBUF_WASTE_FACTOR_THRESHOLD
# define GE_COWBUF_WASTE_FACTOR_THRESHOLD(cur,len) ((len) < SV_COWBUF_WASTE_FACTOR_THRESHOLD * (cur))
#else
# define GE_COWBUF_WASTE_FACTOR_THRESHOLD(cur,len) 1
#endif

#define CHECK_COW_THRESHOLD(cur,len) (\
    GE_COW_THRESHOLD((cur)) && \
    GE_COW_MAX_WASTE_THRESHOLD((cur),(len)) && \
    GE_COW_MAX_WASTE_FACTOR_THRESHOLD((cur),(len)) \
)
#define CHECK_COWBUF_THRESHOLD(cur,len) (\
    GE_COWBUF_THRESHOLD((cur)) && \
    GE_COWBUF_WASTE_THRESHOLD((cur),(len)) && \
    GE_COWBUF_WASTE_FACTOR_THRESHOLD((cur),(len)) \
)
/* void Gconvert: on Linux at least, gcvt (which Gconvert gets deffed to),
 * has a mandatory return value, even though that value is just the same
 * as the buf arg */

d422 1
a422 1
		(*f)(aTHX_ sv);
d775 1
a775 1
member present.  If the allocated structure is smaller (no initial NV
d778 1
a778 1
allocated.  (We were using structures named *_allocated for this, but
d785 1
a785 1
This is the same trick as was used for NV and IV bodies.  Ironically it
d787 1
a787 1
the start of the structure.  IV bodies don't need it either, because
d884 5
a905 6
    { sizeof(XINVLIST) - STRUCT_OFFSET(XPV, xpv_cur),
      copy_length(XINVLIST, is_offset) - STRUCT_OFFSET(XPV, xpv_cur),
      + STRUCT_OFFSET(XPV, xpv_cur),
      SVt_INVLIST, TRUE, NONV, HASARENA,
      FIT_ARENA(0, sizeof(XINVLIST) - STRUCT_OFFSET(XPV, xpv_cur)) },

d924 1
a924 1
      SVt_REGEXP, TRUE, NONV, HASARENA,
d1311 1
a1311 2
            /* start with PERL_HASH_DEFAULT_HvMAX+1 buckets: */
	    HvMAX(sv) = PERL_HASH_DEFAULT_HvMAX;
a1341 1
    case SVt_INVLIST:
a1469 2
static void S_sv_uncow(pTHX_ SV * const sv, const U32 flags);

d1477 11
d1499 4
d1506 1
a1506 1
	if (SvIsCOW(sv)) S_sv_uncow(aTHX_ sv, 0);
a1509 16
#ifdef PERL_NEW_COPY_ON_WRITE
    /* the new COW scheme uses SvPVX(sv)[SvLEN(sv)-1] (if spare)
     * to store the COW count. So in general, allocate one more byte than
     * asked for, to make it likely this byte is always spare: and thus
     * make more strings COW-able.
     * If the new size is a big power of two, don't bother: we assume the
     * caller wanted a nice 2^N sized block and will be annoyed at getting
     * 2^N+1 */
    if (newlen & 0xff)
        newlen++;
#endif

#if defined(PERL_USE_MALLOC_SIZE) && defined(Perl_safesysmalloc_size)
#define PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
#endif

d1515 2
a1516 4
#ifndef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
        if (SvLEN(sv)) {
            newlen = PERL_STRLEN_ROUNDUP(newlen);
        }
d1528 1
a1528 1
#ifdef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
d1741 1
a1741 1
	       if (! isASCII(ch) && !isPRINT_LC(ch)) {
d1744 1
a1744 3

                    /* Map to ASCII "equivalent" of Latin1 */
		    ch = LATIN1_TO_NATIVE(NATIVE_TO_LATIN1(ch) & 127);
d2234 2
a2235 1
	if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2237 1
d2262 2
a2263 4
    PERL_ARGS_ASSERT_SV_2IV_FLAGS;

    assert (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVHV
	 && SvTYPE(sv) != SVt_PVFM);
d2355 2
a2356 1
    PERL_ARGS_ASSERT_SV_2UV_FLAGS;
d2437 2
a2438 5

    PERL_ARGS_ASSERT_SV_2NV_FLAGS;

    assert (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVHV
	 && SvTYPE(sv) != SVt_PVFM);
d2636 1
a2636 1
	if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2739 5
a2743 4
    PERL_ARGS_ASSERT_SV_2PV_FLAGS;

    assert (SvTYPE(sv) != SVt_PVAV && SvTYPE(sv) != SVt_PVHV
	 && SvTYPE(sv) != SVt_PVFM);
a2896 1
        SvPOK_on(sv);
d2910 1
a2910 25

#ifndef USE_LOCALE_NUMERIC
            PERL_UNUSED_RESULT(Gconvert(SvNVX(sv), NV_DIG, 0, s));
            SvPOK_on(sv);
#else
            {
                DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED();
                PERL_UNUSED_RESULT(Gconvert(SvNVX(sv), NV_DIG, 0, s));

                /* If the radix character is UTF-8, and actually is in the
                 * output, turn on the UTF-8 flag for the scalar */
                if (PL_numeric_local
                    && PL_numeric_radix_sv && SvUTF8(PL_numeric_radix_sv)
                    && instr(s, SvPVX_const(PL_numeric_radix_sv)))
                {
                    SvUTF8_on(sv);
                }
                RESTORE_LC_NUMERIC();
            }

            /* We don't call SvPOK_on(), because it may come to pass that the
             * locale changes so that the stringification we just did is no
             * longer correct.  We will have to re-stringify every time it is
             * needed */
#endif
d2914 4
d2941 1
a2941 1
	if (!PL_localizing && ckWARN(WARN_UNINITIALIZED))
d2955 1
a3030 1
    SvGETMAGIC(sv);
d3034 1
a3034 1
	sv_copypv_nomg(sv2,sv);
d3037 1
d3086 1
a3086 1
Perl_sv_2bool_flags(pTHX_ SV *sv, I32 flags)
a3091 1
    restart:
d3099 2
a3100 24
	    if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv)))) {
                bool svb;
                sv = tmpsv;
                if(SvGMAGICAL(sv)) {
                    flags = SV_GMAGIC;
                    goto restart; /* call sv_2bool */
                }
                /* expanded SvTRUE_common(sv, (flags = 0, goto restart)) */
                else if(!SvOK(sv)) {
                    svb = 0;
                }
                else if(SvPOK(sv)) {
                    svb = SvPVXtrue(sv);
                }
                else if((SvFLAGS(sv) & (SVf_IOK|SVf_NOK))) {
                    svb = (SvIOK(sv) && SvIVX(sv) != 0)
                        || (SvNOK(sv) && SvNVX(sv) != 0.0);
                }
                else {
                    flags = 0;
                    goto restart; /* call sv_2bool_nomg */
                }
                return cBOOL(svb);
            }
a3103 3
    if (isREGEXP(sv))
	return
	  RX_WRAPLEN(sv) > 1 || (RX_WRAPLEN(sv) && *RX_WRAPPED(sv) != '0');
d3132 3
a3134 8

If C<flags> has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV
will expand when converted to UTF-8, and skips the extra work of checking for
that.  Typically this flag is used by a routine that has already parsed the
string and found such characters, and passes this information on so that the
work doesn't have to be repeated.

Returns the number of bytes in the converted string.
d3139 1
a3139 11
=for apidoc sv_utf8_upgrade_flags_grow

Like sv_utf8_upgrade_flags, but has an additional parameter C<extra>, which is
the number of unused bytes the string of 'sv' is guaranteed to have free after
it upon return.  This allows the caller to reserve extra space that it intends
to fill, to avoid extra grows.

C<sv_utf8_upgrade>, C<sv_utf8_upgrade_nomg>, and C<sv_utf8_upgrade_flags>
are implemented in terms of this function.

Returns the number of bytes in the converted string (not including the spares).
d3141 12
a3152 1
=cut
d3155 10
a3164 10
first variant character when it has set SV_FORCE_UTF8_UPGRADE, so it wouldn't
have to be found again.  But that is not the case, because typically when the
caller is likely to use this flag, it won't be calling this routine unless it
finds something that won't fit into a byte.  Otherwise it tries to not upgrade
and just use bytes.  But some things that do fit into a byte are variants in
utf8, and the caller may not have been keeping track of these.)

If the routine itself changes the string, it adds a trailing C<NUL>.  Such a
C<NUL> isn't guaranteed due to having other routines do the work in some input
cases, or if the input is already flagged as being in utf8.
d3200 1
a3200 1
        S_sv_uncow(aTHX_ sv, 0);
d3230 1
a3230 1
	    if (NATIVE_BYTE_IS_INVARIANT(ch)) continue;
d3338 7
a3344 2
                    append_utf8_from_native_byte(*t, &d);
                    t++;
d3370 1
a3370 1
		    if (! NATIVE_BYTE_IS_INVARIANT(chr)) two_byte_count++;
d3390 3
a3392 2
		    if (NATIVE_BYTE_IS_INVARIANT(*e)) {
			*d-- = *e;
d3394 2
a3395 2
			*d-- = UTF8_EIGHT_BIT_LO(*e);
			*d-- = UTF8_EIGHT_BIT_HI(*e);
a3396 1
                    e--;
d3403 1
a3403 4
		 * (upgrade without pos).
		 * pos can be stored as either bytes or characters.  Since
		 * this was previously a byte string we can just turn off
		 * the bytes flag. */
d3406 12
a3417 1
		    mg->mg_flags &= ~MGf_BYTES;
d3459 1
a3459 1
                S_sv_uncow(aTHX_ sv, 0);
d3464 4
a3467 3
		if (mg && mg->mg_len > 0 && mg->mg_flags & MGf_BYTES) {
			mg->mg_len = sv_pos_b2u_flags(sv, mg->mg_len,
						SV_GMAGIC|SV_CONST_RETURN);
d3469 2
a3558 3
	    /* XXX Is this dead code?  XS_utf8_decode calls SvSETMAGIC
		   after this, clearing pos.  Does anything on CPAN
		   need this? */
d3583 3
a3585 4
function if the source SV needs to be reused.  Does not handle 'set' magic on
destination SV.  Calls 'get' magic on source SV.  Loosely speaking, it
performs a copy-by-value, obliterating any previous content of the
destination.
d3600 1
a3600 1
parameter has the C<SV_NOSTEAL> bit set then the
d3634 2
a3695 2

        SvREFCNT_inc_simple_void_NN(sv_2mortal(dstr));
d3699 3
a3736 9
    if (GvIO(dstr) && dtype == SVt_PVGV) {
	DEBUG_o(Perl_deb(aTHX_
			"glob_assign_glob clearing PL_stashcache\n"));
	/* It's a cache. It will rebuild itself quite happily.
	   It's a lot of effort to work out exactly which key (or keys)
	   might be invalidated by the creation of the this file handle.
	 */
	hv_clear(PL_stashcache);
    }
d3932 9
a3940 40



#ifdef PERL_DEBUG_READONLY_COW
# include <sys/mman.h>

# ifndef PERL_MEMORY_DEBUG_HEADER_SIZE
#  define PERL_MEMORY_DEBUG_HEADER_SIZE 0
# endif

void
Perl_sv_buf_to_ro(pTHX_ SV *sv)
{
    struct perl_memory_debug_header * const header =
	(struct perl_memory_debug_header *)(SvPVX(sv)-PERL_MEMORY_DEBUG_HEADER_SIZE);
    const MEM_SIZE len = header->size;
    PERL_ARGS_ASSERT_SV_BUF_TO_RO;
# ifdef PERL_TRACK_MEMPOOL
    if (!header->readonly) header->readonly = 1;
# endif
    if (mprotect(header, len, PROT_READ))
	Perl_warn(aTHX_ "mprotect RW for COW string %p %lu failed with %d",
			 header, len, errno);
}

static void
S_sv_buf_to_rw(pTHX_ SV *sv)
{
    struct perl_memory_debug_header * const header =
	(struct perl_memory_debug_header *)(SvPVX(sv)-PERL_MEMORY_DEBUG_HEADER_SIZE);
    const MEM_SIZE len = header->size;
    PERL_ARGS_ASSERT_SV_BUF_TO_RW;
    if (mprotect(header, len, PROT_READ|PROT_WRITE))
	Perl_warn(aTHX_ "mprotect for COW string %p %lu failed with %d",
			 header, len, errno);
# ifdef PERL_TRACK_MEMPOOL
    header->readonly = 0;
# endif
}

d3942 1
a3942 2
# define sv_buf_to_ro(sv)	NOOP
# define sv_buf_to_rw(sv)	NOOP
d4076 1
a4076 1
	case SVt_INVLIST:
d4187 1
a4187 2
		if (GvGP(dstr)) {
		    SvREFCNT_inc_simple_void_NN(sv_2mortal(dstr));
a4188 1
		}
d4209 1
d4214 7
a4220 40
	 * We have three basic ways to copy the string:
	 *
	 *  1. Swipe
	 *  2. Copy-on-write
	 *  3. Actual copy
	 * 
	 * Which we choose is based on various factors.  The following
	 * things are listed in order of speed, fastest to slowest:
	 *  - Swipe
	 *  - Copying a short string
	 *  - Copy-on-write bookkeeping
	 *  - malloc
	 *  - Copying a long string
	 * 
	 * We swipe the string (steal the string buffer) if the SV on the
	 * rhs is about to be freed anyway (TEMP and refcnt==1).  This is a
	 * big win on long strings.  It should be a win on short strings if
	 * SvPVX_const(dstr) has to be allocated.  If not, it should not 
	 * slow things down, as SvPVX_const(sstr) would have been freed
	 * soon anyway.
	 * 
	 * We also steal the buffer from a PADTMP (operator target) if it
	 * is ‘long enough’.  For short strings, a swipe does not help
	 * here, as it causes more malloc calls the next time the target
	 * is used.  Benchmarks show that even if SvPVX_const(dstr) has to
	 * be allocated it is still not worth swiping PADTMPs for short
	 * strings, as the savings here are small.
	 * 
	 * If the rhs is already flagged as a copy-on-write string and COW
	 * is possible here, we use copy-on-write and make both SVs share
	 * the string buffer.
	 * 
	 * If the rhs is not flagged as copy-on-write, then we see whether
	 * it is worth upgrading it to such.  If the lhs already has a buf-
	 * fer big enough and the string is short, we skip it and fall back
	 * to method 3, since memcpy is faster for short strings than the
	 * later bookkeeping overhead that copy-on-write entails.
	 * 
	 * If there is no buffer on the left, or the buffer is too small,
	 * then we use copy-on-write.
d4228 35
a4262 1
                 (              /* Either ... */
d4264 4
a4267 8
                    (sflags & (SVs_TEMP|SVf_IsCOW)) == SVs_TEMP
                                /* or a swipable TARG */
                 || ((sflags & (SVs_PADTMP|SVf_READONLY|SVf_IsCOW))
                       == SVs_PADTMP
                                /* whose buffer is worth stealing */
                     && CHECK_COWBUF_THRESHOLD(cur,len)
                    )
                 ) &&
d4273 4
a4276 19
	{	/* Passes the swipe test.  */
	    if (SvPVX_const(dstr))	/* we know that dtype >= SVt_PV */
		SvPV_free(dstr);
	    SvPV_set(dstr, SvPVX_mutable(sstr));
	    SvLEN_set(dstr, SvLEN(sstr));
	    SvCUR_set(dstr, SvCUR(sstr));

	    SvTEMP_off(dstr);
	    (void)SvOK_off(sstr);	/* NOTE: nukes most SvFLAGS on sstr */
	    SvPV_set(sstr, NULL);
	    SvLEN_set(sstr, 0);
	    SvCUR_set(sstr, 0);
	    SvTEMP_off(sstr);
        }
	else if (flags & SV_COW_SHARED_HASH_KEYS
	      &&
#ifdef PERL_OLD_COPY_ON_WRITE
		 (  sflags & SVf_IsCOW
		 || (   (sflags & CAN_COW_MASK) == CAN_COW_FLAGS
d4278 2
a4279 11
		     && SvTYPE(sstr) >= SVt_PVIV && len
		    )
		 )
#elif defined(PERL_NEW_COPY_ON_WRITE)
		 (sflags & SVf_IsCOW
		   ? (!len ||
                       (  (CHECK_COWBUF_THRESHOLD(cur,len) || SvLEN(dstr) < cur+1)
			  /* If this is a regular (non-hek) COW, only so
			     many COW "copies" are possible. */
		       && CowREFCNT(sstr) != SV_COW_REFCNT_MAX  ))
		   : (  (sflags & CAN_COW_MASK) == CAN_COW_FLAGS
d4281 4
a4284 2
                     && CHECK_COW_THRESHOLD(cur,len) && cur+1 < len
                     && (CHECK_COWBUF_THRESHOLD(cur,len) || SvLEN(dstr) < cur+1)
d4286 1
a4286 3
#else
		 sflags & SVf_IsCOW
	      && !(SvFLAGS(dstr) & SVf_BREAK)
d4289 9
d4299 1
a4299 1
               copy-on-write.  */
d4306 2
a4307 1
            if (!(sflags & SVf_IsCOW)) {
d4316 1
d4319 1
d4324 2
d4327 1
a4327 1
	    if (len) {
a4334 3
		    if (sflags & SVf_IsCOW) {
			sv_buf_to_rw(sstr);
		    }
d4338 1
a4338 2
                    sv_buf_to_ro(sstr);
            } else
d4340 1
a4340 1
            {
d4348 18
a4365 11
	    }
	    SvLEN_set(dstr, len);
	    SvCUR_set(dstr, cur);
	    SvIsCOW_on(dstr);
	} else {
	    /* Failed the swipe test, and we cannot do copy-on-write either.
	       Have to copy the string.  */
	    SvGROW(dstr, cur + 1);	/* inlined from sv_setpvn */
	    Move(SvPVX_const(sstr),SvPVX(dstr),cur,char);
	    SvCUR_set(dstr, cur);
	    *SvEND(dstr) = '\0';
a4437 3
#if defined(PERL_DEBUG_READONLY_COW) && defined(PERL_NEW_COPY_ON_WRITE)
    const bool already = cBOOL(SvIsCOW(sstr));
#endif
a4497 3
#  ifdef PERL_DEBUG_READONLY_COW
    if (already) sv_buf_to_rw(sstr);
#  endif
a4500 1
    sv_buf_to_ro(sstr);
d4519 1
a4519 2
Copies a string (possibly containing embedded C<NUL> characters) into an SV.
The C<len> parameter indicates the number of
d4577 2
a4578 3
Copies a string into an SV.  The string must be terminated with a C<NUL>
character.
Does not handle 'set' magic.  See C<sv_setpv_mg>.
d4656 1
a4656 1
	    SvPV_free(sv);
d4675 1
a4675 1
string is stored inside the SV, but sv_usepvn allows the SV to use an
d4677 4
a4680 6
by L<Newx|perlclib/Memory Management and String Handling>. It must be
the start of a Newx-ed block of memory, and not a pointer to the
middle of it (beware of L<OOK|perlguts/Offsets> and copy-on-write),
and not be from a non-Newx memory allocator like C<malloc>. The
string length, C<len>, must be supplied.  By default this function
will C<Renew> (i.e. realloc, move) the memory pointed to by C<ptr>,
d4686 1
a4686 1
SV_HAS_TRAILING_NUL is true, then C<ptr[len]> must be C<NUL>, and the realloc
a4774 1
            sv_buf_to_rw(after);
a4807 4
This function is expected to be used to signal to perl that this SV is
about to be written to, and any extra book-keeping needs to be taken care
of.  Hence, it croaks on read-only values.

d4811 2
a4812 2
static void
S_sv_uncow(pTHX_ SV * const sv, const U32 flags)
d4816 2
a4817 2
    assert(SvIsCOW(sv));
    {
d4819 5
d4844 1
a4844 1
	    sv_buf_to_rw(sv);
d4852 1
a4852 5
	    if (len) {
		sv_buf_to_rw(sv);
		CowREFCNT(sv)--;
		sv_buf_to_ro(sv);
	    }
a4854 1
            SvCUR_set(sv, 0);
d4876 1
d4878 6
d4898 1
a4899 12
    }
}

void
Perl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags)
{
    PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS;

    if (SvREADONLY(sv))
	Perl_croak_no_modify();
    else if (SvIsCOW(sv))
	S_sv_uncow(aTHX_ sv, flags);
a5033 1
    /* This sets 'delta' to the accumulated value of all deltas so far */
a5035 5

    /* If 'delta' fits in a byte, store it just prior to the new beginning of
     * the string; otherwise store a 0 byte there and store 'delta' just prior
     * to that, using as many bytes as a STRLEN occupies.  Thus it overwrites a
     * portion of the chopped part of the string */
d5110 7
a5116 2
            append_utf8_from_native_byte(*sstr, &d);
	    sstr++;
d5170 1
a5170 2
Concatenates the C<NUL>-terminated string onto the end of the string which is
in the SV.
d5202 1
a5202 2
Concatenates the C<NUL>-terminated string onto the end of the string which is
in the SV.
d5239 1
a5239 1
trailing C<NUL> is also reserved.  (SvPOK is not set for the SV even if string
a5291 2
    if (SvTYPE(sv)==SVt_PVAV) { assert (!AvPAD_NAMELIST(sv)); }

a5354 18
MAGIC *
Perl_sv_magicext_mglob(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_MAGICEXT_MGLOB;
    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y') {
	/* This sv is only a delegate.  //g magic must be attached to
	   its target. */
	vivify_defelem(sv);
	sv = LvTARG(sv);
    }
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv))
	sv_force_normal_flags(sv, 0);
#endif
    return sv_magicext(sv, NULL, PERL_MAGIC_regex_global,
		       &PL_vtbl_mglob, 0, 0);
}

d5383 1
a5383 1
    if (how < 0 || (unsigned)how >= C_ARRAY_LENGTH(PL_magic_data)
d5397 1
a5397 1
#ifdef PERL_OLD_COPY_ON_WRITE
d5403 5
a5407 1
	    !PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(how)
a5423 10
    /* Force pos to be stored as characters, not bytes. */
    if (SvMAGICAL(sv) && DO_UTF8(sv)
      && (mg = mg_find(sv, PERL_MAGIC_regex_global))
      && mg->mg_len != -1
      && mg->mg_flags & MGf_BYTES) {
	mg->mg_len = (SSize_t)sv_pos_b2u_flags(sv, (STRLEN)mg->mg_len,
					       SV_CONST_RETURN);
	mg->mg_flags &= ~MGf_BYTES;
    }

d5588 6
a5593 4
        if (SvMAGICAL(tsv))
            mg = mg_find(tsv, PERL_MAGIC_backref);
	if (!mg)
            mg = sv_magicext(tsv, NULL, PERL_MAGIC_backref, &PL_vtbl_backref, NULL, 0);
a5602 2
	if (mg)
	    mg->mg_flags |= MGf_REFCOUNTED;
d5605 1
a5605 1
	SvREFCNT_inc_simple_void_NN(av);
a5606 1
	av_extend(av, *svp ? 2 : 1);
d5609 1
d5613 2
d5616 1
a5616 1
    else {
d5618 5
a5622 9
        if (!av) {
            /* optimisation: store single backref directly in HvAUX or mg_obj */
            *svp = sv;
            return;
        }
        assert(SvTYPE(av) == SVt_PVAV);
        if (AvFILLp(av) >= AvMAX(av)) {
            av_extend(av, AvFILLp(av)+1);
        }
d5625 4
a6128 3
	    }
	    else if (type == SVt_PVAV && AvPAD_NAMELIST(sv)) {
		assert(!SvMAGICAL(sv));
d6139 1
a6139 1
	    /* case SVt_INVLIST: */
d6186 2
a6187 2
			(void)hv_deletehek(PL_stashcache,
					   HvNAME_HEK((HV*)sv), G_DISCARD);
a6264 1
	case SVt_INVLIST:
a6299 1
			    sv_buf_to_rw(sv);
a6300 1
			    sv_buf_to_ro(sv);
d6573 1
a6573 1
    if (LIKELY( rc == 1 )) {
d6908 1
a6908 1
Converts the offset from a count of UTF-8 chars from
d7017 3
d7197 1
a7197 1
=for apidoc sv_pos_b2u_flags
d7199 3
a7201 4
Converts the offset from a count of bytes from the start of the string, to
a count of the equivalent number of UTF-8 chars.  Handles type coercion.
I<flags> is passed to C<SvPV_flags>, and usually should be
C<SV_GMAGIC|SV_CONST_RETURN> to handle magic.
d7207 3
a7209 3
 * sv_pos_b2u_flags() uses, like sv_pos_u2b_flags(), the mg_ptr of the
 * potential PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8
 * and byte offsets.
d7212 2
a7213 2
STRLEN
Perl_sv_pos_b2u_flags(pTHX_ SV *const sv, STRLEN const offset, U32 flags)
d7216 1
d7223 4
a7226 1
    PERL_ARGS_ASSERT_SV_POS_B2U_FLAGS;
d7228 1
a7228 1
    s = (const U8*)SvPV_flags(sv, blen, flags);
d7230 1
a7230 1
    if (blen < offset)
d7232 1
a7232 1
		   ", byte=%"UVuf, (UV)blen, (UV)offset);
d7234 1
a7234 1
    send = s + offset;
d7243 1
a7243 1
	    if (cache[1] == offset) {
d7245 2
a7246 1
		return cache[0];
d7248 1
a7248 1
	    if (cache[3] == offset) {
d7250 2
a7251 1
		return cache[2];
d7254 1
a7254 1
	    if (cache[1] < offset) {
d7265 1
a7265 1
	    else if (cache[3] < offset) {
d7275 1
a7275 1
	    else { /* cache[3] > offset */
d7294 1
d7297 1
a7297 1
	if (blen == offset)
d7300 1
a7300 1
	    utf8_mg_pos_cache_update(sv, &mg, offset, len, blen);
a7301 33

    return len;
}

/*
=for apidoc sv_pos_b2u

Converts the value pointed to by offsetp from a count of bytes from the
start of the string, to a count of the equivalent number of UTF-8 chars.
Handles magic and type coercion.

Use C<sv_pos_b2u_flags> in preference, which correctly handles strings
longer than 2Gb.

=cut
*/

/*
 * sv_pos_b2u() uses, like sv_pos_u2b(), the mg_ptr of the potential
 * PERL_MAGIC_utf8 of the sv to store the mapping between UTF-8 and
 * byte offsets.
 *
 */
void
Perl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp)
{
    PERL_ARGS_ASSERT_SV_POS_B2U;

    if (!sv)
	return;

    *offsetp = (I32)sv_pos_b2u_flags(sv, (STRLEN)*offsetp,
				     SV_GMAGIC|SV_CONST_RETURN);
a7580 2
#else
    PERL_UNUSED_ARG(flags);
d7792 2
a7793 2
appending to the currently-stored string.  If C<append> is not 0, the
line is appended to the SV instead of overwriting it.  C<append> should
d7808 3
a7810 3
    SSize_t cnt;
    int i = 0;
    int rspara = 0;
a7823 1
        /* line is going to be appended to the existing buffer in the sv */
a7835 2
        /* not appending - "clear" the string by setting SvCUR to 0,
         * the pv is still avaiable. */
d7856 1
a7856 7
#ifdef PERL_NEW_COPY_ON_WRITE
                /* Add an extra byte for the sake of copy-on-write's
                 * buffer reference count. */
		(void) SvGROW(sv, (STRLEN)((st.st_size - offset) + append + 2));
#else
		(void) SvGROW(sv, (STRLEN)((st.st_size - offset) + append + 1));
#endif
a7880 1
            /* extract the raw pointer to the record separator */
a7884 3
    /* rslast is the last character in the record separator
     * note we don't use rslast except when rslen is true, so the
     * null assign is a placeholder. */
a7909 9
    /*
     * We can do buffer based IO operations on this filehandle.
     *
     * This means we can bypass a lot of subcalls and process
     * the buffer directly, it also means we know the upper bound
     * on the amount of data we might read of the current buffer
     * into our sv. Knowing this allows us to preallocate the pv
     * to be able to hold that maximum, which allows us to simplify
     * a lot of logic. */
d7915 3
a7917 8
    STDCHAR *ptr;       /* pointer into fp's read-ahead buffer */
    STRLEN bpx;         /* length of the data in the target sv
                           used to fix pointers after a SvGROW */
    I32 shortbuffered;  /* If the pv buffer is shorter than the amount
                           of data left in the read-ahead buffer.
                           If 0 then the pv buffer can hold the full
                           amount left, otherwise this is the amount it
                           can hold. */
d7931 1
a7931 58
    /* When you read the following logic resist the urge to think
     * of record separators that are 1 byte long. They are an
     * uninteresting special (simple) case.
     *
     * Instead think of record separators which are at least 2 bytes
     * long, and keep in mind that we need to deal with such
     * separators when they cross a read-ahead buffer boundary.
     *
     * Also consider that we need to gracefully deal with separators
     * that may be longer than a single read ahead buffer.
     *
     * Lastly do not forget we want to copy the delimiter as well. We
     * are copying all data in the file _up_to_and_including_ the separator
     * itself.
     *
     * Now that you have all that in mind here is what is happening below:
     *
     * 1. When we first enter the loop we do some memory book keeping to see
     * how much free space there is in the target SV. (This sub assumes that
     * it is operating on the same SV most of the time via $_ and that it is
     * going to be able to reuse the same pv buffer each call.) If there is
     * "enough" room then we set "shortbuffered" to how much space there is
     * and start reading forward.
     *
     * 2. When we scan forward we copy from the read-ahead buffer to the target
     * SV's pv buffer. While we go we watch for the end of the read-ahead buffer,
     * and the end of the of pv, as well as for the "rslast", which is the last
     * char of the separator.
     *
     * 3. When scanning forward if we see rslast then we jump backwards in *pv*
     * (which has a "complete" record up to the point we saw rslast) and check
     * it to see if it matches the separator. If it does we are done. If it doesn't
     * we continue on with the scan/copy.
     *
     * 4. If we run out of read-ahead buffer (cnt goes to 0) then we have to get
     * the IO system to read the next buffer. We do this by doing a getc(), which
     * returns a single char read (or EOF), and prefills the buffer, and also
     * allows us to find out how full the buffer is.  We use this information to
     * SvGROW() the sv to the size remaining in the buffer, after which we copy
     * the returned single char into the target sv, and then go back into scan
     * forward mode.
     *
     * 5. If we run out of write-buffer then we SvGROW() it by the size of the
     * remaining space in the read-buffer.
     *
     * Note that this code despite its twisty-turny nature is pretty darn slick.
     * It manages single byte separators, multi-byte cross boundary separators,
     * and cross-read-buffer separators cleanly and efficiently at the cost
     * of potentially greatly overallocating the target SV.
     *
     * Yves
     */


    /* get the number of bytes remaining in the read-ahead buffer
     * on first call on a given fp this will return 0.*/
    cnt = PerlIO_get_cnt(fp);

a7942 2
            /* ensure that the target sv has enough room to hold
             * the rest of the read-ahead buffer */
d7948 1
a7948 2
    else {
        /* we have enough room to hold the full buffer, lets scream */
a7949 3
    }

    /* extract the pointer to sv's string buffer, offset by append as necessary */
a7950 1
    /* extract the point to the read-ahead buffer */
a7951 2

    /* some trace debug output */
d7955 2
a7956 3
	"Screamer: entering: PerlIO * thinks ptr=%"UVuf", cnt=%zd, base=%"
	 UVuf"\n",
	       PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
a7957 1

a7959 1
        /* if there is stuff left in the read-ahead buffer */
a7960 1
            /* if there is a separator */
a7961 1
                /* loop until we hit the end of the read-ahead buffer */
a7962 1
                    /* scan forward copying and searching for rslast as we go */
a7968 1
                /* no separator, slurp the full buffer */
a7978 2
            /* we didnt have enough room to fit the line into the target buffer
             * so we must extend the target buffer and keep going */
a7982 1
            /* extned the target sv's buffer so it can hold the full read-ahead buffer */
a7988 2
        /* we need to refill the read-ahead buffer if possible */

d7990 2
a7991 2
			     "Screamer: going to getc, ptr=%"UVuf", cnt=%zd\n",
			      PTR2UV(ptr),cnt));
d7995 2
a7996 2
	   "Screamer: pre: FILE * thinks ptr=%"UVuf", cnt=%zd, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
d7999 3
a8001 9
        /*
            call PerlIO_getc() to let it prefill the lookahead buffer

            This used to call 'filbuf' in stdio form, but as that behaves like
            getc when cnt <= 0 we use PerlIO_getc here to avoid introducing
            another abstraction.

            Note we have to deal with the char in 'i' if we are not at EOF
        */
d8005 2
a8006 2
	   "Screamer: post: FILE * thinks ptr=%"UVuf", cnt=%zd, base=%"UVuf"\n",
	    PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
a8008 1
        /* find out how much is left in the read-ahead buffer, and rextract its pointer */
d8012 1
a8012 2
	    "Screamer: after getc, ptr=%"UVuf", cnt=%zd\n",
	     PTR2UV(ptr),cnt));
a8016 1
        /* make sure we have enough space in the target sv */
a8021 1
        /* copy of the char we got from getc() */
a8023 1
        /* make sure we deal with the i being the last character of a separator */
a8028 2
    /* check if we have actually found the separator - only really applies
     * when rslen > 1 */
d8036 1
a8036 1
	    "Screamer: quitting, ptr=%"UVuf", cnt=%zd\n",PTR2UV(ptr),cnt));
d8039 2
a8040 3
	"Screamer: end: FILE * thinks ptr=%"UVuf", cnt=%zd, base=%"UVuf
	"\n",
	PTR2UV(PerlIO_get_ptr(fp)), PerlIO_get_cnt(fp),
d8161 2
d8164 1
a8174 1
	else sv_force_normal_flags(sv, 0);
d8343 2
d8346 1
a8356 1
	else sv_force_normal_flags(sv, 0);
d8515 1
a8515 2
Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  The reference count for the
d8544 7
a8550 7
    /* This code used to do a sv_2mortal(), however we now unroll the call to
     * sv_2mortal() and do what it does ourselves here.  Since we have asserted
     * that flags can only have the SVf_UTF8 and/or SVs_TEMP flags set above we
     * can use it to enable the sv flags directly (bypassing SvTEMP_on), which
     * in turn means we dont need to mask out the SVf_UTF8 flag below, which
     * means that we eliminate quite a few steps than it looks - Yves
     * (explaining patch by gfx) */
d8589 1
a8589 2
Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  The reference count for the
d8591 1
a8591 4
strlen(), (which means if you use this option, that C<s> can't have embedded
C<NUL> characters and has to have a terminating C<NUL> byte).

For efficiency, consider using C<newSVpvn> instead.
d8610 1
a8610 1
Creates a new SV and copies a string into it, which may contain C<NUL> characters
d8749 1
a8749 1
Like C<newSVpvn_share>, but takes a C<NUL>-terminated string instead of a
d8992 1
a8992 1
    if (!stash || SvTYPE(stash) != SVt_PVHV)
d9044 15
a9058 3
		if (sv && !SvREADONLY(sv)) {
		    SV_CHECK_THINKFIRST_COW_DROP(sv);
		    if (!isGV(sv)) SvOK_off(sv);
d9064 3
d9068 5
d9282 1
a9282 1
    if (SvTHINKFIRST(sv) && (!SvROK(sv) || SvREADONLY(sv)))
d9293 8
d9313 1
a9313 2
        if (SvTYPE(sv) < SVt_PV ||
            s != SvPVX_const(sv)) {	/* Almost, but not quite, sv_setpvn() */
a9388 8
        /* WARNING - There is code, for instance in mg.c, that assumes that
         * the only reason that sv_reftype(sv,0) would return a string starting
         * with 'L' or 'S' is that it is a LVALUE or a SCALAR.
         * Yes this a dodgy way to do type checking, but it saves practically reimplementing
         * this routine inside other subs, and it saves time.
         * Do not change this assumption without searching for "dodgy type check" in
         * the code.
         * - Yves */
d9416 1
a9416 1
	case SVt_INVLIST:	return "INVLIST";
d9513 1
a9513 1
reference count is 1.  The reference count 1 is owned by C<rv>.
a9554 13
SV *
Perl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)
{
    SV * const lv = newSV_type(SVt_PVLV);
    PERL_ARGS_ASSERT_NEWSVAVDEFELEM;
    LvTYPE(lv) = 'y';
    sv_magic(lv, NULL, PERL_MAGIC_defelem, NULL, 0);
    LvTARG(lv) = SvREFCNT_inc_simple_NN(av);
    LvSTARGOFF(lv) = ix;
    LvTARGLEN(lv) = extendible ? 1 : (STRLEN)UV_MAX;
    return lv;
}

a9691 1
    HV *oldstash = NULL;
a9694 1
    SvGETMAGIC(sv);
d9699 1
a9699 1
	if (SvREADONLY(tmpRef))
d9702 1
a9702 1
	    oldstash = SvSTASH(tmpRef);
a9707 1
    SvREFCNT_dec(oldstash);
a9736 1
    SvREFCNT_inc_simple_void_NN(sv_2mortal(sv));
d10025 1
a10025 1
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
d10043 1
a10043 2
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
    SvSETMAGIC(sv);
d10069 1
a10069 1
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
d10089 1
a10089 1
    sv_vcatpvfn_flags(sv, pat, strlen(pat), args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
d10108 1
a10108 2
    sv_vcatpvfn_flags(sv, pat, strlen(pat), &args, NULL, 0, NULL, SV_GMAGIC|SV_SMAGIC);
    SvSETMAGIC(sv);
a10275 2
    DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED;

d10327 1
a10327 2
                    STORE_LC_NUMERIC_SET_TO_NEEDED();
		    PERL_UNUSED_RESULT(Gconvert(nv, (int)digits, 0, ebuf));
d10443 1
a10443 2
		%4p		char* preceded by utf8 flag and length
		%<num>p		(where num is 1 or > 4) reserved for future
a10454 9
	    else if (strnEQ(q, UTF8f, sizeof(UTF8f)-1)) { /* UTF8f */
		/* The argument has already gone through cBOOL, so the cast
		   is safe. */
		is_utf8 = (bool)va_arg(*args, int);
		elen = va_arg(*args, UV);
		eptr = va_arg(*args, char *);
		q += sizeof(UTF8f)-1;
		goto string;
	    }
d10670 1
a10670 1
#if IVSIZE >= 8 || defined(HAS_LONG_DOUBLE)
d10673 1
a10673 1
#if IVSIZE >= 8
d10682 1
a10682 1
#if IVSIZE >= 8 || defined(HAS_LONG_DOUBLE)
d10702 1
a10702 1
#ifdef HAS_C99
d10741 1
a10741 1
		 (!UVCHR_IS_INVARIANT(uv) && SvUTF8(sv)))
d10810 3
d10838 1
a10838 1
#ifdef HAS_C99
d10842 1
a10842 1
#if IVSIZE >= 8
d10858 1
a10858 1
#if IVSIZE >= 8
d10935 1
a10935 1
#ifdef HAS_C99
d10940 1
a10940 1
#if IVSIZE >= 8
d10956 1
a10956 1
#if IVSIZE >= 8
d11177 1
a11177 2
                    STORE_LC_NUMERIC_SET_TO_NEEDED();
		    PERL_UNUSED_RESULT(Gconvert((NV)nv, (int)precis, 0, PL_efloatbuf));
a11224 6

                STORE_LC_NUMERIC_SET_TO_NEEDED();

                /* hopefully the above makes ptr a very constrained format
                 * that is safe to use, even though it's not literal */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
a11231 1
                GCC_DIAG_RESTORE;
a11234 11

#ifdef USE_LOCALE_NUMERIC
            /* If the decimal point character in the string is UTF-8, make the
             * output utf8 */
            if (PL_numeric_radix_sv && SvUTF8(PL_numeric_radix_sv)
                && instr(eptr, SvPVX_const(PL_numeric_radix_sv)))
            {
                is_utf8 = TRUE;
            }
#endif

d11252 1
a11252 1
#ifdef HAS_C99
d11256 1
a11256 1
#if IVSIZE >= 8
d11335 1
a11335 1
	    croak_memory_wrap();
d11341 1
a11341 1
	    croak_memory_wrap();
a11390 3

    RESTORE_LC_NUMERIC();   /* Done outside loop, so don't have to save/restore
                               each iteration. */
d11586 1
a11586 1
#if defined(HAS_FCHDIR) && defined(HAS_TELLDIR) && defined(HAS_SEEKDIR)
d11606 1
a11606 1
#if defined(HAS_FCHDIR) && defined(HAS_TELLDIR) && defined(HAS_SEEKDIR)
d11623 1
a11623 2
    /* XXX If this fails, then what? */
    PERL_UNUSED_RESULT(fchdir(my_dirfd(pwd)));
d11849 1
a11849 3
/* add a new entry to a pointer-mapping table 'tbl'.  In hash terms, 'oldsv' is
 * the key; 'newsv' is the value.  The names "old" and "new" are specific to
 * the core's typical use of ptr_tables in thread cloning. */
d11871 2
a11872 1
	    tbl->tbl_arena_end = C_ARRAY_END(new_arena->array);
d12143 1
a12167 1
            case SVt_INVLIST:
a12204 2
		} else if (sv_type == SVt_PVAV && AvPAD_NAMELIST(dstr)) {
		    NOOP;
a12358 6
			daux->xhv_fill_lazy = saux->xhv_fill_lazy;
			daux->xhv_aux_flags = saux->xhv_aux_flags;
#ifdef PERL_HASH_RANDOMIZE_KEYS
			daux->xhv_rand = saux->xhv_rand;
			daux->xhv_last_rand = saux->xhv_last_rand;
#endif
d12386 1
d12517 2
a12518 4
		ncx->blk_sub.savearray	=  (CxHASARGS(ncx)
                                            ? av_dup_inc(ncx->blk_sub.savearray,
						     param)
					   : NULL);
a12702 1
	case SAVEt_READONLY_OFF:
a12755 1
	case SAVEt_STRLEN:			/* STRLEN/size_t ref */
a12824 6
	case SAVEt_ADELETE:
	    av = (const AV *)POPPTR(ss,ix);
	    TOPPTR(nss,ix) = av_dup_inc(av, param);
	    i = POPINT(ss,ix);
	    TOPINT(nss,ix) = i;
	    break;
d12898 37
d13151 1
a13151 1
#ifndef NO_TAINT_SUPPORT
d13192 1
a13193 1
    PL_reg_curpm	= NULL;
d13245 2
a13260 1
    PL_in_utf8_CTYPE_locale = proto_perl->Iin_utf8_CTYPE_locale;
a13297 1
    Copy(&(proto_perl->Irandom_state), &PL_random_state, 1, PL_RANDOM_STATE_TYPE);
d13328 5
a13332 1
#ifndef NO_TAINT_SUPPORT
d13358 1
a13390 2
    Zero(PL_sv_consts, SV_CONSTS_COUNT, SV*);

d13418 3
a13420 3
    PL_envgv		= gv_dup_inc(proto_perl->Ienvgv, param);
    PL_incgv		= gv_dup_inc(proto_perl->Iincgv, param);
    PL_hintgv		= gv_dup_inc(proto_perl->Ihintgv, param);
d13462 1
a13462 1
    PL_argvgv		= gv_dup_inc(proto_perl->Iargvgv, param);
d13467 1
a13467 1
    PL_replgv		= gv_dup_inc(proto_perl->Ireplgv, param);
d13473 3
a13475 3
    PL_DBgv		= gv_dup_inc(proto_perl->IDBgv, param);
    PL_DBline		= gv_dup_inc(proto_perl->IDBline, param);
    PL_DBsub		= gv_dup_inc(proto_perl->IDBsub, param);
d13584 1
a13585 2
    PL_UpperLatin1	= sv_dup_inc(proto_perl->IUpperLatin1, param);
    PL_AboveLatin1	= sv_dup_inc(proto_perl->IAboveLatin1, param);
d13588 1
a13588 1
    PL_HasMultiCharFold = sv_dup_inc(proto_perl->IHasMultiCharFold, param);
d13595 2
d13615 3
d13700 3
a13702 2
    PL_firstgv		= gv_dup_inc(proto_perl->Ifirstgv, param);
    PL_secondgv		= gv_dup_inc(proto_perl->Isecondgv, param);
d13723 1
a13723 1
    while(av_tindex(param->stashes) != -1) {
a13925 1
	SV *nsv = sv;
a13926 1
	PUSHSTACK;
a13927 4
	if (SvPADTMP(nsv)) {
	    nsv = sv_newmortal();
	    SvSetSV_nosteal(nsv, sv);
	}
d13932 1
a13932 1
	PUSHs(nsv);
a13954 1
	POPSTACK;
d14287 1
a14287 1
	    svp = av_fetch(av, (I8)obase->op_private, FALSE);
d14292 1
a14292 1
		       NULL, (I8)obase->op_private, FUV_SUBSCRIPT_ARRAY);
d14303 1
a14303 1
		svp = av_fetch(av, (I8)obase->op_private, FALSE);
d14308 1
a14308 1
		    NULL, (I8)obase->op_private, FUV_SUBSCRIPT_ARRAY);
a14371 2
		    SV * const  opsv = cSVOPx_sv(kid);
		    const IV  opsviv = SvIV(opsv);
d14373 1
a14373 1
			negate ? - opsviv : opsviv,
a14650 2
        /* PL_warn_uninit_sv is constant */
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
a14654 1
        GCC_DIAG_RESTORE;
d14656 1
a14656 3
    else {
        /* PL_warn_uninit is constant */
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
a14658 2
        GCC_DIAG_RESTORE;
    }
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d49 2
a50 1
#ifndef SV_COW_THRESHOLD
d52 2
a53 2
#endif
#ifndef SV_COWBUF_THRESHOLD
d55 2
a56 2
#endif
#ifndef SV_COW_MAX_WASTE_THRESHOLD
d58 2
a59 2
#endif
#ifndef SV_COWBUF_WASTE_THRESHOLD
d61 2
a62 2
#endif
#ifndef SV_COW_MAX_WASTE_FACTOR_THRESHOLD
d64 2
a65 2
#endif
#ifndef SV_COWBUF_WASTE_FACTOR_THRESHOLD
d67 1
d933 1
a933 1
   (U32)(count 						\
d935 1
a935 1
    : FIT_ARENA0 (body_size))
d3456 1
a3456 1
		if (invariant_head == 0) {
d4418 1
a4418 2
                 || ((sflags & (SVs_PADTMP|SVs_PADMY|SVf_READONLY
                               |SVf_IsCOW))
d4849 1
a4849 1
by L<Newx|perlclib/Memory Management and String Handling>.  It must be
d4852 1
a4852 1
and not be from a non-Newx memory allocator like C<malloc>.  The
a13096 1
	case SAVEt_SV:			/* scalar reference */
d13098 1
a13098 1
	    TOPPTR(nss,ix) = SvREFCNT_inc(sv_dup_inc(sv, param));
d13102 1
a13104 2
	    if (type == SAVEt_SV)
		break;
a13121 2
	    if (type == SAVEt_SVREF)
		SvREFCNT_inc_simple_void((SV *)TOPPTR(nss,ix));
d13274 1
a13274 1
	    TOPPTR(nss,ix) = SvREFCNT_inc(sv_dup_inc(sv, param));
@


