head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.18
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.16
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.14
	OPENBSD_5_0:1.10.0.12
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.34.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.03.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.48.37;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.37.22;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.37;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.04;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.30;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.12.49;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.28;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.06.25;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@perl 5.004_04
@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -Ilib -w

# This file should really be extracted from a .PL file

use strict;
use Config;		# for config options in the makefile
use File::Spec::Functions qw(rel2abs no_upwards);
use Getopt::Long;	# for command-line parsing
use Cwd;
use Pod::Html 'anchorify';

=head1 NAME

installhtml - converts a collection of POD pages to HTML format.

=head1 SYNOPSIS

  installhtml  [--help] [--podpath=<name>:...:<name>] [--podroot=<name>]
       [--htmldir=<name>] [--htmlroot=<name>]  [--norecurse] [--recurse]
       [--splithead=<name>,...,<name>]   [--splititem=<name>,...,<name>]
       [--ignore=<name>,...,<name>]  [--verbose]

=head1 DESCRIPTION

I<installhtml> converts a collection of POD pages to a corresponding
collection of HTML pages.  This is primarily used to convert the pod
pages found in the perl distribution.

=head1 OPTIONS

=over 4

=item B<--help> help

Displays the usage.

=item B<--podroot> POD search path base directory

The base directory to search for all .pod and .pm files to be converted.
Default is current directory.

=item B<--podpath> POD search path

The list of directories to search for .pod and .pm files to be converted.
Default is 'podroot/.'.

=item B<--recurse> recurse on subdirectories

Whether or not to convert all .pm and .pod files found in subdirectories
too.  Default is to not recurse.

=item B<--htmldir> HTML destination directory

The base directory which all HTML files will be written to.  This should
be a path relative to the filesystem, not the resulting URL.

=item B<--htmlroot> URL base directory

The base directory which all resulting HTML files will be visible at in
a URL.  The default is '/'.

=item B<--splithead> POD files to split on =head directive

Comma-separated list of pod files to split by the =head directive.  The
.pod suffix is optional. These files should have names specified
relative to podroot.

=item B<--splititem> POD files to split on =item directive

Comma-separated list of all pod files to split by the =item directive.
The .pod suffix is optional.  I<installhtml> does not do the actual
split, rather it invokes I<splitpod> to do the dirty work.  As with
--splithead, these files should have names specified relative to podroot.

=item B<--splitpod> Directory containing the splitpod program

The directory containing the splitpod program. The default is 'podroot/pod'.

=item B<--ignore> files to be ignored

Comma-separated of files that shouldn't be installed, given relative
to podroot.

=item B<--verbose> verbose output

Self-explanatory.

=back

=head1 EXAMPLE

The following command-line is an example of the one we use to convert
perl documentation:

    ./installhtml --podpath=lib:ext:pod:vms   \
			--podroot=/usr/src/perl     \
			--htmldir=/perl/nmanual     \
			--htmlroot=/perl/nmanual    \
			--splithead=pod/perlipc     \
			--splititem=pod/perlfunc    \
			--recurse \
			--verbose

=head1 AUTHOR

Chris Hall E<lt>hallc@@cs.colorado.eduE<gt>

=cut

my $usage;

$usage =<<END_OF_USAGE;
Usage: $0 --help --podpath=<name>:...:<name> --podroot=<name>
         --htmldir=<name> --htmlroot=<name> --norecurse --recurse
         --splithead=<name>,...,<name> --splititem=<name>,...,<name>
         --ignore=<name>,...,<name> --verbose

    --help      - this message
    --podpath   - colon-separated list of directories containing .pod and
                  .pm files to be converted (. by default).
    --podroot   - filesystem base directory from which all relative paths in
                  podpath stem (default is .).
    --htmldir   - directory to store resulting html files in relative
                  to the filesystem (\$podroot/html by default).
    --htmlroot  - http-server base directory from which all relative paths
                  in podpath stem (default is /).
    --norecurse - don't recurse on those subdirectories listed in podpath.
                  (default behavior).
    --recurse   - recurse on those subdirectories listed in podpath
    --splithead - comma-separated list of .pod or .pm files to split.  will
                  split each file into several smaller files at every occurrence
                  of a pod =head[1-6] directive.
    --splititem - comma-separated list of .pod or .pm files to split using
                  splitpod.
    --splitpod  - directory where the program splitpod can be found
                  (\$podroot/pod by default).
    --ignore    - comma-separated list of files that shouldn't be installed.
    --verbose   - self-explanatory.

END_OF_USAGE

my (@@podpath, $podroot, $htmldir, $htmlroot, $recurse, @@splithead,
    @@splititem, $splitpod, $verbose, $pod2html, @@ignore);

@@podpath = ( "." );	# colon-separated list of directories containing .pod
			# and .pm files to be converted.
$podroot = ".";		# assume the pods we want are here
$htmldir = "";		# nothing for now...
$htmlroot = "/";	# default value
$recurse = 0;		# default behavior
@@splithead = ();	# don't split any files by default
@@splititem = ();	# don't split any files by default
$splitpod = "";		# nothing for now.

$verbose = 0;		# whether or not to print debugging info

$pod2html = "pod/pod2html";

usage("") unless @@ARGV;

# Overcome shell's p1,..,p8 limitation.  
# See vms/descrip_mms.template -> descrip.mms for invocation.
if ( $^O eq 'VMS' ) { @@ARGV = split(/\s+/,$ARGV[0]); }

use vars qw( %Options );

# parse the command-line
my $result = GetOptions( \%Options, qw(
	help
	podpath=s
	podroot=s
	htmldir=s
	htmlroot=s
	ignore=s
	recurse!
	splithead=s
	splititem=s
	splitpod=s
	verbose
));
usage("invalid parameters") unless $result;
parse_command_line();


# set these variables to appropriate values if the user didn't specify
#  values for them.
$htmldir = "$htmlroot/html" unless $htmldir;
$splitpod = "$podroot/pod" unless $splitpod;


# make sure that the destination directory exists
(mkdir($htmldir, 0755) ||
	die "$0: cannot make directory $htmldir: $!\n") if ! -d $htmldir;


# the following array will eventually contain files that are to be
# ignored in the conversion process.  these are files that have been
# process by splititem or splithead and should not be converted as a
# result.
my @@splitdirs;

# split pods. It's important to do this before convert ANY pods because
# it may affect some of the links
@@splitdirs = ();    # files in these directories won't get an index
split_on_head($podroot, $htmldir, \@@splitdirs, \@@ignore, @@splithead);
split_on_item($podroot,           \@@splitdirs, \@@ignore, @@splititem);


# convert the pod pages found in @@poddirs
#warn "converting files\n" if $verbose;
#warn "\@@ignore\t= @@ignore\n" if $verbose;
foreach my $dir (@@podpath) {
    installdir($dir, $recurse, $podroot, \@@splitdirs, \@@ignore);
}


# now go through and create master indices for each pod we split
foreach my $dir (@@splititem) {
    print "creating index $htmldir/$dir.html\n" if $verbose;
    create_index("$htmldir/$dir.html", "$htmldir/$dir");
}

foreach my $dir (@@splithead) {
    (my $pod = $dir) =~ s,^.*/,,;
    $dir .= ".pod" unless $dir =~ /(\.pod|\.pm)$/;
    # let pod2html create the file
    runpod2html($dir, 1);

    # now go through and truncate after the index
    $dir =~ /^(.*?)(\.pod|\.pm)?$/sm;
    my $file = "$htmldir/$1";
    print "creating index $file.html\n" if $verbose;

    # read in everything until what would have been the first =head
    # directive, patching the index as we go.
    open(H, "<$file.html") ||
	die "$0: error opening $file.html for input: $!\n";
    $/ = "";
    my @@data = ();
    while (<H>) {
	last if /name="name"/i;
	$_ =~ s{href="#(.*)">}{
	    my $url = "$pod/$1.html" ;
	    $url = Pod::Html::relativize_url( $url, "$file.html" )
	    if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' );
	    "href=\"$url\">" ;
	}egi;
	push @@data, $_;
    }
    close(H);

    # now rewrite the file
    open(H, ">$file.html") ||
	die "$0: error opening $file.html for output: $!\n";
    print H "@@data", "\n";
    close(H);
}

##############################################################################


sub usage {
    warn "$0: @@_\n" if @@_;
    die $usage;
}


sub parse_command_line {
    usage() if defined $Options{help};
    $Options{help} = ""; 	    	    # make -w shut up

    # list of directories
    @@podpath   = split(":", $Options{podpath}) if defined $Options{podpath};

    # lists of files
    @@splithead = split(",", $Options{splithead}) if defined $Options{splithead};
    @@splititem = split(",", $Options{splititem}) if defined $Options{splititem};

    $htmldir  = $Options{htmldir}	    if defined $Options{htmldir};
    $htmlroot = $Options{htmlroot}	    if defined $Options{htmlroot};
    $podroot  = $Options{podroot}	    if defined $Options{podroot};
    $splitpod = $Options{splitpod}	    if defined $Options{splitpod};

    $recurse  = $Options{recurse}	    if defined $Options{recurse};
    $verbose  = $Options{verbose}	    if defined $Options{verbose};

    @@ignore = map "$podroot/$_", split(",", $Options{ignore}) if defined $Options{ignore};
}


sub create_index {
    my($html, $dir) = @@_;
    (my $pod = $dir) =~ s,^.*/,,;

    # get the list of .html files in this directory
    opendir(DIR, $dir) ||
	die "$0: error opening directory $dir for reading: $!\n";
    my @@files = sort(grep(/\.html?$/, readdir(DIR)));
    closedir(DIR);

    open(HTML, ">$html") ||
	die "$0: error opening $html for output: $!\n";

    # for each .html file in the directory, extract the index
    #	embedded in the file and throw it into the big index.
    print HTML "<DL COMPACT>\n";
    foreach my $file (@@files) {

	my $filedata = do {
	    open(my $in, "<$dir/$file") ||
		die "$0: error opening $dir/$file for input: $!\n";
	    local $/ = undef;
	    <$in>;
	};

	# pull out the NAME section
	my($lcp1, $lcp2) =
	    ($filedata =~
		m#<h1 id="NAME">NAME</h1>\s*<p>\s*(\S+)\s+-\s+(\S.*?\S)</p>#);
	defined $lcp1 or die "$0: can't find NAME section in $dir/$file\n";

	my $url= "$pod/$file" ;
	if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' ) {
	    $url = Pod::Html::relativize_url( "$pod/$file", $html ) ;
	}

	print HTML qq(<DT><A HREF="$url">);
	print HTML "$lcp1</A></DT><DD>$lcp2</DD>\n";
    }
    print HTML "</DL>\n";

    close(HTML);
}


sub split_on_head {
    my($podroot, $htmldir, $splitdirs, $ignore, @@splithead) = @@_;
    my($pod, $dirname, $filename);

    # split the files specified in @@splithead on =head[1-6] pod directives
    print "splitting files by head.\n" if $verbose && $#splithead >= 0;
    foreach $pod (@@splithead) {
	# figure out the directory name and filename
	$pod      =~ s,^([^/]*)$,/$1,;
	$pod      =~ m,(.*)/(.*?)(\.pod)?$,;
	$dirname  = $1;
	$filename = "$2.pod";

	# since we are splitting this file it shouldn't be converted.
	push(@@$ignore, "$podroot/$dirname/$filename");

	# split the pod
	splitpod("$podroot/$dirname/$filename", "$podroot/$dirname", $htmldir,
	    $splitdirs);
    }
}


sub split_on_item {
    my($podroot, $splitdirs, $ignore, @@splititem) = @@_;
    my($pwd, $dirname, $filename);

    print "splitting files by item.\n" if $verbose && $#splititem >= 0;
    $pwd = getcwd();
    my $splitter = rel2abs("$splitpod/splitpod", $pwd);
    my $perl = rel2abs($^X, $pwd);
    foreach my $pod (@@splititem) {
	# figure out the directory to split into
	$pod      =~ s,^([^/]*)$,/$1,;
	$pod      =~ m,(.*)/(.*?)(\.pod)?$,;
	$dirname  = "$1/$2";
	$filename = "$2.pod";

	# since we are splitting this file it shouldn't be converted.
	push(@@$ignore, "$podroot/$dirname.pod");

	# split the pod
	push(@@$splitdirs, "$podroot/$dirname");
	if (! -d "$podroot/$dirname") {
	    mkdir("$podroot/$dirname", 0755) ||
		    die "$0: error creating directory $podroot/$dirname: $!\n";
	}
	chdir("$podroot/$dirname") ||
	    die "$0: error changing to directory $podroot/$dirname: $!\n";
	die "$splitter not found. Use '-splitpod dir' option.\n"
	    unless -f $splitter;
	system($perl, $splitter, "../$filename") &&
	    warn "$0: error running '$splitter ../$filename'"
		 ." from $podroot/$dirname";
    }
    chdir($pwd);
}


#
# splitpod - splits a .pod file into several smaller .pod files
#  where a new file is started each time a =head[1-6] pod directive
#  is encountered in the input file.
#
sub splitpod {
    my($pod, $poddir, $htmldir, $splitdirs) = @@_;
    my(@@poddata, @@filedata, @@heads);
    my($file, $i, $j, $prevsec, $section, $nextsec);

    print "splitting $pod\n" if $verbose;

    # read the file in paragraphs
    $/ = "";
    open(SPLITIN, "<$pod") ||
	die "$0: error opening $pod for input: $!\n";
    @@filedata = <SPLITIN>;
    close(SPLITIN) ||
	die "$0: error closing $pod: $!\n";

    # restore the file internally by =head[1-6] sections
    @@poddata = ();
    for ($i = 0, $j = -1; $i <= $#filedata; $i++) {
	$j++ if ($filedata[$i] =~ /^\s*=head[1-6]/);
	if ($j >= 0) { 
	    $poddata[$j]  = "" unless defined $poddata[$j];
	    $poddata[$j] .= "\n$filedata[$i]" if $j >= 0;
	}
    }

    # create list of =head[1-6] sections so that we can rewrite
    #  L<> links as necessary.
    my %heads = ();
    foreach $i (0..$#poddata) {
	$heads{anchorify($1)} = 1 if $poddata[$i] =~ /=head[1-6]\s+(.*)/;
    }

    # create a directory of a similar name and store all the
    #  files in there
    $pod =~ s,.*/(.*),$1,;	# get the last part of the name
    my $dir = $pod;
    $dir =~ s/\.pod//g;
    push(@@$splitdirs, "$poddir/$dir");
    mkdir("$poddir/$dir", 0755) ||
	die "$0: could not create directory $poddir/$dir: $!\n"
	unless -d "$poddir/$dir";

    $poddata[0] =~ /^\s*=head[1-6]\s+(.*)/;
    $section    = "";
    $nextsec    = $1;

    # for each section of the file create a separate pod file
    for ($i = 0; $i <= $#poddata; $i++) {
	# determine the "prev" and "next" links
	$prevsec = $section;
	$section = $nextsec;
	if ($i < $#poddata) {
	    $poddata[$i+1] =~ /^\s*=head[1-6]\s+(.*)/;
	    $nextsec       = $1;
	} else {
	    $nextsec = "";
	}

	# determine an appropriate filename (this must correspond with
	#  what pod2html will try and guess)
	# $poddata[$i] =~ /^\s*=head[1-6]\s+(.*)/;
	$file = "$dir/" . anchorify($section) . ".pod";

	# create the new .pod file
	print "\tcreating $poddir/$file\n" if $verbose;
	open(SPLITOUT, ">$poddir/$file") ||
	    die "$0: error opening $poddir/$file for output: $!\n";
	$poddata[$i] =~ s,L<([^<>]*)>,
			defined $heads{anchorify($1)} ? "L<$dir/$1>" : "L<$1>"
		     ,ge;
	print SPLITOUT $poddata[$i]."\n\n";
	print SPLITOUT "=over 4\n\n";
	print SPLITOUT "=item *\n\nBack to L<$dir/\"$prevsec\">\n\n" if $prevsec;
	print SPLITOUT "=item *\n\nForward to L<$dir/\"$nextsec\">\n\n" if $nextsec;
	print SPLITOUT "=item *\n\nUp to L<$dir>\n\n";
	print SPLITOUT "=back\n\n";
	close(SPLITOUT) ||
	    die "$0: error closing $poddir/$file: $!\n";
    }
}


#
# installdir - takes care of converting the .pod and .pm files in the
#  current directory to .html files and then installing those.
#
sub installdir {
    my($dir, $recurse, $podroot, $splitdirs, $ignore) = @@_;

    my @@dirlist; # directories to recurse on
    my @@podlist; # .pod files to install
    my @@pmlist;  # .pm files to install

    # should files in this directory get an index?
    my $doindex = (grep($_ eq "$podroot/$dir", @@$splitdirs) ? 0 : 1);

    opendir(DIR, "$podroot/$dir")
	|| die "$0: error opening directory $podroot/$dir: $!\n";

    while(readdir DIR) {
	no_upwards($_) or next;
	my $is_dir = -d "$podroot/$dir/$_";
	next if $is_dir and not $recurse;
	my $target
	    = $is_dir    ? \@@dirlist
	    : s/\.pod$// ? \@@podlist
	    : s/\.pm$//  ? \@@pmlist
	    : undef
	    ;
	push @@$target, "$dir/$_" if $target;
    }

    closedir(DIR);

    if ($^O eq 'VMS') { s/\.dir$//i for @@dirlist }

    # recurse on all subdirectories we kept track of
    foreach $dir (@@dirlist) {
	installdir($dir, $recurse, $podroot, $splitdirs, $ignore);
    }

    # install all the pods we found
    foreach my $pod (@@podlist) {
	# check if we should ignore it.
	next if $pod =~ m(/t/); # comes from a test file
	next if grep($_ eq "$pod.pod", @@$ignore);

	# check if a .pm files exists too
	if (grep($_ eq $pod, @@pmlist)) {
	    print  "$0: Warning both '$podroot/$pod.pod' and "
		. "'$podroot/$pod.pm' exist, using pod\n";
	    push(@@ignore, "$pod.pm");
	}
	runpod2html("$pod.pod", $doindex);
    }

    # install all the .pm files we found
    foreach my $pm (@@pmlist) {
	# check if we should ignore it.
	next if $pm =~ m(/t/); # comes from a test file
	next if grep($_ eq "$pm.pm", @@ignore);

	runpod2html("$pm.pm", $doindex);
    }
}


#
# runpod2html - invokes pod2html to convert a .pod or .pm file to a .html
#  file.
#
sub runpod2html {
    my($pod, $doindex) = @@_;
    my($html, $i, $dir, @@dirs);

    $html = $pod;
    $html =~ s/\.(pod|pm)$/.html/g;

    # make sure the destination directories exist
    @@dirs = split("/", $html);
    $dir  = "$htmldir/";
    for ($i = 0; $i < $#dirs; $i++) {
	if (! -d "$dir$dirs[$i]") {
	    mkdir("$dir$dirs[$i]", 0755) ||
		die "$0: error creating directory $dir$dirs[$i]: $!\n";
	}
	$dir .= "$dirs[$i]/";
    }

    # invoke pod2html
    print "$podroot/$pod => $htmldir/$html\n" if $verbose;
    Pod::Html::pod2html(
        "--htmldir=$htmldir",
	"--htmlroot=$htmlroot",
	"--podpath=".join(":", @@podpath),
	"--podroot=$podroot",
	"--header",
	($doindex ? "--index" : "--noindex"),
	"--" . ($recurse ? "" : "no") . "recurse",
	"--infile=$podroot/$pod", "--outfile=$htmldir/$html");
    die "$0: error running $pod2html: $!\n" if $?;
}
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d503 6
a508 6
	my $target = (
	    $is_dir    ? \@@dirlist :
	    s/\.pod$// ? \@@podlist :
	    s/\.pm$//  ? \@@pmlist  :
	    undef
	);
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d18 4
a21 4
    installhtml  [--help] [--podpath=<name>:...:<name>] [--podroot=<name>]
         [--htmldir=<name>] [--htmlroot=<name>]  [--norecurse] [--recurse]
         [--splithead=<name>,...,<name>]   [--splititem=<name>,...,<name>]
         [--ignore=<name>,...,<name>]  [--verbose]
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d7 1
a7 1
use File::Spec;
d365 2
a366 2
    my $splitter = File::Spec->rel2abs("$splitpod/splitpod", $pwd);
    my $perl = File::Spec->rel2abs($^X, $pwd);
a487 1
    my(@@dirlist, @@podlist, @@pmlist, $doindex);
d489 3
a491 3
    @@dirlist = ();	# directories to recurse on
    @@podlist = ();	# .pod files to install
    @@pmlist  = ();	# .pm files to install
d494 1
a494 1
    $doindex = (grep($_ eq "$podroot/$dir", @@$splitdirs) ? 0 : 1);
d499 12
a510 13
    # find the directories to recurse on
    @@dirlist = map { if ($^O eq 'VMS') {/^(.*)\.dir$/i; "$dir/$1";} else {"$dir/$_";}}
	grep(-d "$podroot/$dir/$_" && !/^\.{1,2}/, readdir(DIR)) if $recurse;
    rewinddir(DIR);

    # find all the .pod files within the directory
    @@podlist = map { /^(.*)\.pod$/; "$dir/$1" }
	grep(! -d "$podroot/$dir/$_" && /\.pod$/, readdir(DIR));
    rewinddir(DIR);

    # find all the .pm files within the directory
    @@pmlist = map { /^(.*)\.pm$/; "$dir/$1" }
	grep(! -d "$podroot/$dir/$_" && /\.pm$/, readdir(DIR));
d513 2
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d21 1
a21 2
         [--libpods=<name>,...,<name>]        [--ignore=<name>,...,<name>]
         [--verbose]
a78 5
=item B<--libpods> library PODs for LE<lt>E<gt> links

Comma-separated list of "library" pod files.  This is the same list that
will be passed to pod2html when any pod is converted.

a100 1
			--libpods=perlfunc,perlguts,perlvar,perlrun,perlop \
d116 1
a116 1
         --libpods=<name>,...,<name> --ignore=<name>,...,<name> --verbose
a126 3
    --libpods   - comma-separated list of files to search for =item pod
                  directives in as targets of C<> and implicit links (empty
                  by default).
d142 1
a142 1
my (@@libpods, @@podpath, $podroot, $htmldir, $htmlroot, $recurse, @@splithead,
a144 1
@@libpods = ();
d162 1
a162 1
# See vms/descrip_mms.template -> descrip.mms for invokation.
a173 1
	libpods=s
a277 1
    @@libpods   = split(",", $Options{libpods}) if defined $Options{libpods};
a293 3
    my(@@files, @@filedata, @@index, $file);
    my($lcp1,$lcp2);

d298 1
a298 1
    @@files = sort(grep(/\.html?$/, readdir(DIR)));
d307 1
a307 2
    foreach $file (@@files) {
	$/ = "";
d309 6
a314 4
	open(IN, "<$dir/$file") ||
	    die "$0: error opening $dir/$file for input: $!\n";
	@@filedata = <IN>;
	close(IN);
d317 5
a321 6
	my $name;
	($name) = grep(/name="name"/i, @@filedata);
	($lcp1,$lcp2) = ($name =~ m,/H1>\s(\S+)\s[\s-]*(.*?)\s*$,smi);
	if (defined $lcp1 and $lcp1 =~ m,^<P>$,i) { # Uninteresting.  Try again.
	    ($lcp1,$lcp2) = ($name =~ m,/H1>\s<P>\s*(\S+)\s[\s-]*(.*?)\s*$,smi);
	}
d327 2
a328 14
	if (defined $lcp1) {
	    print HTML qq(<DT><A HREF="$url">);
	    print HTML "$lcp1</A></DT><DD>$lcp2</DD>\n";
	}

	next;

	@@index = grep(/<!-- INDEX BEGIN -->.*<!-- INDEX END -->/s,
		    @@filedata);
	for (@@index) {
	    s/<!-- INDEX BEGIN -->(\s*<!--)(.*)(-->\s*)<!-- INDEX END -->/$lcp2/s;
	    s,#,$dir/$file#,g;
	    print HTML "$_\n<P><HR><P>\n";
	}
d575 1
a575 1
	"--podroot=$podroot", "--netscape",
a578 1
	($#libpods >= 0) ? "--libpods=" . join(":", @@libpods) : "",
@


1.9
log
@merge in perl 5.8.8
@
text
@d46 1
a46 1
Default is `podroot/.'.
d61 1
a61 1
a URL.  The default is `/'.
d78 1
a78 1
The directory containing the splitpod program. The default is `podroot/pod'.
a114 2
=head1 TODO

d557 2
a558 2
	    print  "$0: Warning both `$podroot/$pod.pod' and "
		. "`$podroot/$pod.pm' exist, using pod\n";
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d21 2
a22 1
	 [--libpods=<name>,...,<name>]  [--verbose]
d85 5
d125 1
a125 1
	 --libpods=<name>,...,<name> --verbose
d133 1
a133 1
                  to the filesystem (\$podroot/html by default). 
d149 1
d155 1
a155 1
    @@splititem, $splitpod, $verbose, $pod2html);
d168 1
a168 1
$verbose = 0; 	    	# whether or not to print debugging info
d188 1
a213 1
my @@ignore = ();
d216 2
a217 2
# split pods.  its important to do this before convert ANY pods because
#  it may effect some of the links
d266 1
a266 1
    # now rewrite the file 
d301 2
d554 2
a555 1
	next if grep($_ eq "$podroot/$pod.pod", @@$ignore);
d569 1
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d7 1
a296 9
sub absolute_path {
    my($cwd, $path) = @@_;
	return "$cwd/$path" unless $path =~ m:/:;
    # add cwd if path is not already an absolute path
    $path = "$cwd/$path" if (substr($path,0,1) ne '/');
    return $path;
}


d386 2
a387 2
    my $splitter = absolute_path($pwd, "$splitpod/splitpod");
    my $perl = absolute_path($pwd, $^X);
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d395 1
d416 1
a416 1
	system($^X, $splitter, "../$filename") &&
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d9 1
a9 1
use Pod::Html;
d230 1
d247 7
a253 7
	last if /NAME=/;
	$_ =~ s{HREF="#(.*)">}{
	    my $url = "$file/$1.html" ;
            $url = Pod::Html::relativize_url( $url, "$file.html" )
                if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' );
            "HREF=\"$url\">" ;
        }eg;
d255 1
a255 1
    } 
d307 1
d333 5
a337 5
  my $name;
	($name) = grep(/NAME=/, @@filedata);
	($lcp1,$lcp2) = ($name =~ m,/H1>\s(\S+)\s[\s-]*(.*?)\s*$,sm);
	if (defined $lcp1 and $lcp1 eq '<P>') { # Uninteresting.  Try again.
	   ($lcp1,$lcp2) = ($name =~ m,/H1>\s<P>\s(\S+)\s[\s-]*(.*?)\s*$,sm);
d339 1
a339 1
	my $url= "$dir/$file" ;
d341 1
a341 1
	    $url = Pod::Html::relativize_url( "$dir/$file", $html ) ;
d344 4
a347 3
	print HTML qq(<A HREF="$url">);
	print HTML "<DT>$lcp1</A><DD>$lcp2\n" if defined $lcp1;
#	print HTML qq(<A HREF="$url">$lcp1</A><BR>\n") if defined $lcp1;
a355 1
	    # print HTML "$_\n";
d374 1
a374 1
	$pod      =~ m,(.*?)/(.*?)(\.pod)?$,;
d394 1
a394 1
	my $splitter = absolute_path($pwd, "$splitpod/splitpod");
d398 1
a398 1
	$pod      =~ m,(.*?)/(.*?)(\.pod)?$,;
d415 1
a415 1
	system("perl", $splitter, "../$filename") &&
d457 1
a457 1
	$heads{htmlize($1)} = 1 if $poddata[$i] =~ /=head[1-6]\s+(.*)/;
d489 1
a489 1
	$file = "$dir/" . htmlize($section) . ".pod";
d496 2
a497 2
			    defined $heads{htmlize($1)} ? "L<$dir/$1>" : "L<$1>"
			 ,ge;
d555 1
a555 1
	if (grep($_ eq "$pod.pm", @@pmlist)) {
d597 1
a597 3
#system("./pod2html",
        Pod::Html'pod2html(
        #Pod::Html'pod2html($pod2html,
a608 2

sub htmlize { htmlify(0, @@_) }
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 1
a1 1
#!./perl -w
d5 1
a5 2
use lib 'lib';		# use source library if present

d112 2
d146 3
d170 2
d173 1
a173 1
$result = GetOptions( qw(
d205 2
a206 2
@@ignore = ();

d218 1
a218 1
foreach $dir (@@podpath) {
d224 1
a224 1
foreach $dir (@@splititem) {
d229 1
a229 1
foreach $dir (@@splithead) {
d236 1
a236 1
    $file = "$htmldir/$1";
d244 1
a244 1
    @@data = ();
d250 1
a250 1
                if ( ! defined $opt_htmlroot || $opt_htmlroot eq '' ) ;
d260 1
a260 1
    print H "@@data\n";
d274 2
a275 2
    usage() if defined $opt_help;
    $opt_help = ""; 	    	    # make -w shut up
d278 1
a278 1
    @@podpath   = split(":", $opt_podpath) if defined $opt_podpath;
d281 8
a288 8
    @@splithead = split(",", $opt_splithead) if defined $opt_splithead;
    @@splititem = split(",", $opt_splititem) if defined $opt_splititem;
    @@libpods   = split(",", $opt_libpods) if defined $opt_libpods;

    $htmldir  = $opt_htmldir	    if defined $opt_htmldir;
    $htmlroot = $opt_htmlroot	    if defined $opt_htmlroot;
    $podroot  = $opt_podroot	    if defined $opt_podroot;
    $splitpod = $opt_splitpod	    if defined $opt_splitpod;
d290 2
a291 2
    $recurse  = $opt_recurse	    if defined $opt_recurse;
    $verbose  = $opt_verbose	    if defined $opt_verbose;
d331 1
d338 1
a338 1
	if ( ! defined $opt_htmlroot || $opt_htmlroot eq '' ) {
d393 1
a393 1
    foreach $pod (@@splititem) {
d453 1
a453 1
    %heads = ();
d461 1
a461 1
    $dir = $pod;
d548 1
a548 1
    foreach $pod (@@podlist) {
d562 1
a562 1
    foreach $pm (@@pmlist) {
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
# This file should really be a extracted from a .PL
d595 1
@


1.2
log
@perl5.005_03 (stock)
@
text
@a11 2
umask 022;

d64 1
a64 1
Colon-separated list of pod files to split by the =head directive.  The
d70 1
a70 1
Colon-separated list of all pod files to split by the =item directive.
d81 1
a81 1
Colon-separated list of "library" pod files.  This is the same list that
d101 1
a101 1
			--libpods=perlfunc:perlguts:perlvar:perlrun:perlop \
d162 4
d241 6
a246 1
	s,HREF="#(.*)">,HREF="$file/$1.html">,g;
d301 2
d326 12
a337 4
	$name =~ m,/H1>\s(\S+)\s[\s-]*(.*?)\s*$,sm;
	print HTML qq(<A HREF="$dir/$file">);
	print HTML "<DT>$1</A><DD>$2\n" if defined $1;
#	print HTML qq(<A HREF="$dir/$file">$1</A><BR>\n") if defined $1;
d344 1
a344 1
	    s/<!-- INDEX BEGIN -->(\s*<!--)(.*)(-->\s*)<!-- INDEX END -->/$2/s;
d520 1
a520 1
    @@dirlist = map { "$dir/$_" }
d591 1
@


1.1
log
@perl 5.004_04
@
text
@d298 1
a298 1
    @@files = sort(grep(/\.html$/, readdir(DIR)));
@


1.1.1.1
log
@perl5.005_03
@
text
@d298 1
a298 1
    @@files = sort(grep(/\.html?$/, readdir(DIR)));
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d12 2
d66 1
a66 1
Comma-separated list of pod files to split by the =head directive.  The
d72 1
a72 1
Comma-separated list of all pod files to split by the =item directive.
d83 1
a83 1
Comma-separated list of "library" pod files.  This is the same list that
d103 1
a103 1
			--libpods=perlfunc,perlguts,perlvar,perlrun,perlop \
a163 4
# Overcome shell's p1,..,p8 limitation.  
# See vms/descrip_mms.template -> descrip.mms for invokation.
if ( $^O eq 'VMS' ) { @@ARGV = split(/\s+/,$ARGV[0]); }

d239 1
a239 6
	$_ =~ s{HREF="#(.*)">}{
	    my $url = "$file/$1.html" ;
            $url = Pod::Html::relativize_url( $url, "$file.html" )
                if ( ! defined $opt_htmlroot || $opt_htmlroot eq '' ) ;
            "HREF=\"$url\">" ;
        }eg;
a293 2
    my($lcp1,$lcp2);

d317 4
a320 12
	($lcp1,$lcp2) = ($name =~ m,/H1>\s(\S+)\s[\s-]*(.*?)\s*$,sm);
	if (defined $lcp1 and $lcp1 eq '<P>') { # Uninteresting.  Try again.
	   ($lcp1,$lcp2) = ($name =~ m,/H1>\s<P>\s(\S+)\s[\s-]*(.*?)\s*$,sm);
	}
	my $url= "$dir/$file" ;
	if ( ! defined $opt_htmlroot || $opt_htmlroot eq '' ) {
	    $url = Pod::Html::relativize_url( "$dir/$file", $html ) ;
	}

	print HTML qq(<A HREF="$url">);
	print HTML "<DT>$lcp1</A><DD>$lcp2\n" if defined $lcp1;
#	print HTML qq(<A HREF="$url">$lcp1</A><BR>\n") if defined $lcp1;
d327 1
a327 1
	    s/<!-- INDEX BEGIN -->(\s*<!--)(.*)(-->\s*)<!-- INDEX END -->/$lcp2/s;
d503 1
a503 1
    @@dirlist = map { if ($^O eq 'VMS') {/^(.*)\.dir$/i; "$dir/$1";} else {"$dir/$_";}}
a573 1
        "--htmldir=$htmldir",
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
# This file should really be extracted from a .PL file
a594 1
	"--header",
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d1 1
a1 1
#!./perl -Ilib -w
d5 2
a6 1
use strict;
a112 2
my $usage;

a144 3
my (@@libpods, @@podpath, $podroot, $htmldir, $htmlroot, $recurse, @@splithead,
    @@splititem, $splitpod, $verbose, $pod2html);

a165 2
use vars qw( %Options );

d167 1
a167 1
my $result = GetOptions( \%Options, qw(
d199 2
a200 2
my @@ignore = ();
my @@splitdirs;
d212 1
a212 1
foreach my $dir (@@podpath) {
d218 1
a218 1
foreach my $dir (@@splititem) {
d223 1
a223 1
foreach my $dir (@@splithead) {
d230 1
a230 1
    my $file = "$htmldir/$1";
d238 1
a238 1
    my @@data = ();
d244 1
a244 1
                if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' );
d254 1
a254 1
    print H "@@data", "\n";
d268 2
a269 2
    usage() if defined $Options{help};
    $Options{help} = ""; 	    	    # make -w shut up
d272 1
a272 1
    @@podpath   = split(":", $Options{podpath}) if defined $Options{podpath};
d275 8
a282 8
    @@splithead = split(",", $Options{splithead}) if defined $Options{splithead};
    @@splititem = split(",", $Options{splititem}) if defined $Options{splititem};
    @@libpods   = split(",", $Options{libpods}) if defined $Options{libpods};

    $htmldir  = $Options{htmldir}	    if defined $Options{htmldir};
    $htmlroot = $Options{htmlroot}	    if defined $Options{htmlroot};
    $podroot  = $Options{podroot}	    if defined $Options{podroot};
    $splitpod = $Options{splitpod}	    if defined $Options{splitpod};
d284 2
a285 2
    $recurse  = $Options{recurse}	    if defined $Options{recurse};
    $verbose  = $Options{verbose}	    if defined $Options{verbose};
a324 1
  my $name;
d331 1
a331 1
	if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' ) {
d386 1
a386 1
    foreach my $pod (@@splititem) {
d446 1
a446 1
    my %heads = ();
d454 1
a454 1
    my $dir = $pod;
d541 1
a541 1
    foreach my $pod (@@podlist) {
d555 1
a555 1
    foreach my $pm (@@pmlist) {
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
use Pod::Html 'anchorify';
a229 1
    (my $pod = $dir) =~ s,^.*/,,;
d246 7
a252 7
	last if /name="name"/i;
	$_ =~ s{href="#(.*)">}{
	    my $url = "$pod/$1.html" ;
	    $url = Pod::Html::relativize_url( $url, "$file.html" )
	    if ( ! defined $Options{htmlroot} || $Options{htmlroot} eq '' );
	    "href=\"$url\">" ;
	}egi;
d254 1
a254 1
    }
a305 1
    (my $pod = $dir) =~ s,^.*/,,;
d331 5
a335 5
	my $name;
	($name) = grep(/name="name"/i, @@filedata);
	($lcp1,$lcp2) = ($name =~ m,/H1>\s(\S+)\s[\s-]*(.*?)\s*$,smi);
	if (defined $lcp1 and $lcp1 =~ m,^<P>$,i) { # Uninteresting.  Try again.
	    ($lcp1,$lcp2) = ($name =~ m,/H1>\s<P>\s*(\S+)\s[\s-]*(.*?)\s*$,smi);
d337 1
a337 1
	my $url= "$pod/$file" ;
d339 1
a339 1
	    $url = Pod::Html::relativize_url( "$pod/$file", $html ) ;
d342 3
a344 4
	if (defined $lcp1) {
	    print HTML qq(<DT><A HREF="$url">);
	    print HTML "$lcp1</A></DT><DD>$lcp2</DD>\n";
	}
d353 1
d372 1
a372 1
	$pod      =~ m,(.*)/(.*?)(\.pod)?$,;
d392 1
a392 1
    my $splitter = absolute_path($pwd, "$splitpod/splitpod");
d396 1
a396 1
	$pod      =~ m,(.*)/(.*?)(\.pod)?$,;
d413 1
a413 1
	system($^X, $splitter, "../$filename") &&
d455 1
a455 1
	$heads{anchorify($1)} = 1 if $poddata[$i] =~ /=head[1-6]\s+(.*)/;
d487 1
a487 1
	$file = "$dir/" . anchorify($section) . ".pod";
d494 2
a495 2
			defined $heads{anchorify($1)} ? "L<$dir/$1>" : "L<$1>"
		     ,ge;
d553 1
a553 1
	if (grep($_ eq $pod, @@pmlist)) {
d595 3
a597 1
    Pod::Html::pod2html(
d609 2
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@a394 1
    my $perl = absolute_path($pwd, $^X);
d415 1
a415 1
	system($perl, $splitter, "../$filename") &&
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a6 1
use File::Spec;
d296 9
d394 2
a395 2
    my $splitter = File::Spec->rel2abs("$splitpod/splitpod", $pwd);
    my $perl = File::Spec->rel2abs($^X, $pwd);
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d21 1
a21 2
         [--libpods=<name>,...,<name>]        [--ignore=<name>,...,<name>]
         [--verbose]
a83 5
=item B<--ignore> files to be ignored

Comma-separated of files that shouldn't be installed, given relative
to podroot.

d119 1
a119 1
         --libpods=<name>,...,<name> --ignore=<name>,...,<name> --verbose
d127 1
a127 1
                  to the filesystem (\$podroot/html by default).
a142 1
    --ignore    - comma-separated list of files that shouldn't be installed.
d148 1
a148 1
    @@splititem, $splitpod, $verbose, $pod2html, @@ignore);
d161 1
a161 1
$verbose = 0;		# whether or not to print debugging info
a180 1
	ignore=s
d206 1
d209 2
a210 2
# split pods. It's important to do this before convert ANY pods because
# it may affect some of the links
d259 1
a259 1
    # now rewrite the file
a293 2

    @@ignore = map "$podroot/$_", split(",", $Options{ignore}) if defined $Options{ignore};
d545 1
a545 2
	next if $pod =~ m(/t/); # comes from a test file
	next if grep($_ eq "$pod.pod", @@$ignore);
a558 1
	next if $pm =~ m(/t/); # comes from a test file
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d46 1
a46 1
Default is 'podroot/.'.
d61 1
a61 1
a URL.  The default is '/'.
d78 1
a78 1
The directory containing the splitpod program. The default is 'podroot/pod'.
d115 2
d559 2
a560 2
	    print  "$0: Warning both '$podroot/$pod.pod' and "
		. "'$podroot/$pod.pm' exist, using pod\n";
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d21 2
a22 1
         [--ignore=<name>,...,<name>]  [--verbose]
d80 5
d107 1
d123 1
a123 1
         --ignore=<name>,...,<name> --verbose
d134 3
d152 1
a152 1
my (@@podpath, $podroot, $htmldir, $htmlroot, $recurse, @@splithead,
d155 1
d173 1
a173 1
# See vms/descrip_mms.template -> descrip.mms for invocation.
d185 1
d290 1
d307 3
d314 1
a314 1
    my @@files = sort(grep(/\.html?$/, readdir(DIR)));
d323 2
a324 1
    foreach my $file (@@files) {
d326 4
a329 6
	my $filedata = do {
	    open(my $in, "<$dir/$file") ||
		die "$0: error opening $dir/$file for input: $!\n";
	    local $/ = undef;
	    <$in>;
	};
d332 6
a337 5
	my($lcp1, $lcp2) =
	    ($filedata =~
		m#<h1 id="NAME">NAME</h1>\s*<p>\s*(\S+)\s+-\s+(\S.*?\S)</p>#);
	defined $lcp1 or die "$0: can't find NAME section in $dir/$file\n";

d343 14
a356 2
	print HTML qq(<DT><A HREF="$url">);
	print HTML "$lcp1</A></DT><DD>$lcp2</DD>\n";
d603 1
a603 1
	"--podroot=$podroot",
d607 1
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d7 1
a7 1
use File::Spec::Functions qw(rel2abs no_upwards);
d365 2
a366 2
    my $splitter = rel2abs("$splitpod/splitpod", $pwd);
    my $perl = rel2abs($^X, $pwd);
d488 1
d490 3
a492 3
    my @@dirlist; # directories to recurse on
    my @@podlist; # .pod files to install
    my @@pmlist;  # .pm files to install
d495 1
a495 1
    my $doindex = (grep($_ eq "$podroot/$dir", @@$splitdirs) ? 0 : 1);
d500 13
a512 12
    while(readdir DIR) {
	no_upwards($_) or next;
	my $is_dir = -d "$podroot/$dir/$_";
	next if $is_dir and not $recurse;
	my $target = (
	    $is_dir    ? \@@dirlist :
	    s/\.pod$// ? \@@podlist :
	    s/\.pm$//  ? \@@pmlist  :
	    undef
	);
	push @@$target, "$dir/$_" if $target;
    }
a514 2

    if ($^O eq 'VMS') { s/\.dir$//i for @@dirlist }
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d18 4
a21 4
  installhtml  [--help] [--podpath=<name>:...:<name>] [--podroot=<name>]
       [--htmldir=<name>] [--htmlroot=<name>]  [--norecurse] [--recurse]
       [--splithead=<name>,...,<name>]   [--splititem=<name>,...,<name>]
       [--ignore=<name>,...,<name>]  [--verbose]
@


