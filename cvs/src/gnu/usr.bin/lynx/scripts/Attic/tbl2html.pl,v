head	1.3;
access;
symbols
	OPENBSD_5_5:1.1.0.22
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.18
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.16
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.14
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.12
	OPENBSD_5_0:1.1.0.10
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.8
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.6
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2014.07.23.19.13.25;	author deraadt;	state dead;
branches;
next	1.2;
commitid	EcR8E7r0stjLUV4p;

1.2
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.1;
commitid	lGGuvDWEniklWrQe;

1.1
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@delinked from tree, now it goes to the bit bucket
@
text
@#!/usr/bin/perl -w
# $LynxId: tbl2html.pl,v 1.5 2011/05/21 15:18:16 tom Exp $
#
# Translate one or more ".tbl" files into ".html" files which can be used to
# test the charset support in lynx.  Each of the ".html" files will use the
# charset that corresponds to the input ".tbl" file.

use strict;

use Getopt::Std;
use File::Basename;
use POSIX qw(strtod);

sub field($$) {
	my $value = $_[0];
	my $count = $_[1];

	while ( $count > 0 ) {
		$count -= 1;
		$value =~ s/^\S*\s*//;
	}
	$value =~ s/\s.*//;
	return $value;
}

sub notes($) {
	my $value = $_[0];

	$value =~ s/^[^#]*//;
	$value =~ s/^#//;
	$value =~ s/^\s+//;

	return $value;
}

sub make_header($$$) {
	my $source   = $_[0];
	my $charset  = $_[1];
	my $official = $_[2];

	printf FP "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n";
	printf FP "<HTML>\n";
	printf FP "<HEAD>\n";
	printf FP "<!-- $source -->\n";
	printf FP "<TITLE>%s table</TITLE>\n", &escaped($official);
	printf FP "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n", &escaped($charset);
	printf FP "</HEAD>\n";
	printf FP "\n";
	printf FP "<BODY> \n";
	printf FP "\n";
	printf FP "<H1 ALIGN=center>%s table</H1> \n", &escaped($charset);
	printf FP "\n";
	printf FP "<PRE>\n";
	printf FP "Code  Char  Entity   Render          Description\n";
}

sub make_mark() {
	printf FP "----  ----  ------   ------          -----------------------------------\n";
}

sub escaped($) {
	my $result = $_[0];
	$result =~ s/&/&amp;/g;
	$result =~ s/</&lt;/g;
	$result =~ s/>/&gt;/g;
	return $result;
}

sub make_row($$$) {
	my $old_code = $_[0];
	my $new_code = $_[1];
	my $comments = $_[2];

	# printf "# make_row %d %d %s\n", $old_code, $new_code, $comments;
	my $visible = sprintf("&amp;#%d;      ", $new_code);
	if ($old_code < 256) {
		printf FP "%4x    %c   %.13s  &#%d;             %s\n",
			$old_code, $old_code,
			$visible, $new_code,
			&escaped($comments);
	} else {
		printf FP "%4x    .   %.13s  &#%d;             %s\n",
			$old_code,
			$visible, $new_code,
			&escaped($comments);
	}
}

sub null_row($$) {
	my $old_code = $_[0];
	my $comments = $_[1];

	if ($old_code < 256) {
		printf FP "%4x    %c                     %s\n",
			$old_code, $old_code,
			&escaped($comments);
	} else {
		printf FP "%4x    .                     %s\n",
			$old_code,
			&escaped($comments);
	}
}

sub make_footer() {
	printf FP "</PRE>\n";
	printf FP "</BODY>\n";
	printf FP "</HTML>\n";
}

# return true if the string describes a range
sub is_range($) {
	return ($_[0] =~ /.*-.*/);
}

# convert the U+'s to 0x's so strtod() can convert them.
sub zeroxes($) {
	my $result = $_[0];
	$result =~ s/^U\+/0x/;
	$result =~ s/-U\+/-0x/;
	return $result;
}

# convert a string to a number (-1's are outside the range of Unicode).
sub value_of($) {
	my ($result, $oops) = strtod($_[0]);
	$result = -1 if ($oops ne 0);
	return $result;
}

# return the first number in a range
sub first_of($) {
	my $range = &zeroxes($_[0]);
	$range =~ s/-.*//;
	return &value_of($range);
}

# return the last number in a range
sub last_of($) {
	my $range = &zeroxes($_[0]);
	$range =~ s/^.*-//;
	return &value_of($range);
}

sub one_many($$$) {
	my $oldcode = $_[0];
	my $newcode = &zeroxes($_[1]);
	my $comment = $_[2];

	my $old_code = &value_of($oldcode);
	if ( $old_code lt 0 ) {
		printf "? Problem with number \"%s\"\n", $oldcode;
	} else {
		&make_mark if (( $old_code % 8 ) == 0 );

		if ( $newcode =~ /^#.*/ ) {
			&null_row($old_code, $comment);
		} elsif ( &is_range($newcode) ) {
			my $first_item = &first_of($newcode);
			my $last_item  = &last_of($newcode);
			my $item;

			if ( $first_item lt 0 or $last_item lt 0 ) {
				printf "? Problem with one:many numbers \"%s\"\n", $newcode;
			} else {
				if ( $comment =~ /^$/ ) {
					$comment = sprintf("mapped: %#x to %#x..%#x", $old_code, $first_item, $last_item);
				} else {
					$comment = $comment . " (range)";
				}
				for $item ( $first_item..$last_item) {
					&make_row($old_code, $item, $comment);
				}
			}
		} else {
			my $new_code = &value_of($newcode);
			if ( $new_code lt 0 ) {
				printf "? Problem with number \"%s\"\n", $newcode;
			} else {
				if ( $comment =~ /^$/ ) {
					$comment = sprintf("mapped: %#x to %#x", $old_code, $new_code);
				}
				&make_row($old_code, $new_code, $comment);
			}
		}
	}
}

sub many_many($$$) {
	my $oldcode = $_[0];
	my $newcode = $_[1];
	my $comment = $_[2];

	my $first_old = &first_of($oldcode);
	my $last_old  = &last_of($oldcode);
	my $item;

	if (&is_range($newcode)) {
		my $first_new = &first_of($newcode);
		my $last_new  = &last_of($newcode);
		for $item ( $first_old..$last_old) {
			&one_many($item, $first_new, $comment);
			$first_new += 1;
		}
	} else {
		for $item ( $first_old..$last_old) {
			&one_many($item, $newcode, $comment);
		}
	}
}

sub approximate($$$) {
	my $values = $_[0];
	my $expect = sprintf("%-8s", $_[1]);
	my $comment = $_[2];
	my $escaped = &escaped($expect);
	my $left;
	my $this;
	my $next;

	$escaped =~ s/\\134/\\/g;
	$escaped =~ s/\\015/\&#13\;/g;
	$escaped =~ s/\\012/\&#10\;/g;

	while ( $escaped =~ /^.*\\[0-7]{3}.*$/ ) {
		$left = $escaped;
		$left =~ s/\\[0-7]{3}.*//;
		$this = substr $escaped,length($left)+1,3;
		$next = substr $escaped,length($left)+4;
		$escaped = sprintf("%s&#%d;%s", $left, oct $this, $next);
	}

	my $visible = sprintf("&amp;#%d;      ", $values);
	if ($values < 256) {
		printf FP "%4x    %c   %.13s  &#%d;             approx: %s\n",
			$values, $values,
			$visible,
			$values,
			$escaped;
	} else {
		printf FP "%4x    .   %.13s  &#%d;             approx: %s\n",
			$values,
			$visible,
			$values,
			$escaped;
	}
}

sub doit($) {
	my $source = $_[0];

	printf "** %s\n", $source;

	my $target = basename($source, ".tbl");

	# Read the file into an array in memory.
	open(FP,$source) || do {
		print STDERR "Can't open input $source: $!\n";
		return;
	};
	my (@@input) = <FP>;
	chomp @@input;
	close(FP);

	my $n;
	my $charset = "";
	my $official = "";
	my $empty = 1;

	for $n (0..$#input) {
		$input[$n] =~ s/\s*$//; # trim trailing blanks
		$input[$n] =~ s/^\s*//; # trim leading blanks
		$input[$n] =~ s/^#0x/0x/; # uncomment redundant stuff

		next if $input[$n] =~ /^$/;
		next if $input[$n] =~ /^#.*$/;

		if ( $empty 
		  and ( $input[$n] =~ /^\d/
		     or $input[$n] =~ /^U\+/ ) ) {
			$target = $charset . ".html";
			printf "=> %s\n", $target;
			open(FP,">$target") || do {
				print STDERR "Can't open output $target: $!\n";
				return;
			};
			&make_header($source, $charset, $official);
			$empty = 0;
		}

		if ( $input[$n] =~ /^M.*/ ) {
			$charset = $input[$n];
			$charset =~ s/^.//;
		} elsif ( $input[$n] =~ /^O.*/ ) {
			$official = $input[$n];
			$official =~ s/^.//;
		} elsif ( $input[$n] =~ /^\d/ ) {

			my $newcode = &field($input[$n], 1);

			next if ( $newcode eq "idem" );
			next if ( $newcode eq "" );

			my $oldcode = &field($input[$n], 0);
			if ( &is_range($oldcode) ) {
				&many_many($oldcode, $newcode, &notes($input[$n]));
			} else {
				&one_many($oldcode, $newcode, &notes($input[$n]));
			}
		} elsif ( $input[$n] =~ /^U\+/ ) {
			if ( $input[$n] =~ /^U\+\w+:/ ) {
				my $values = $input[$n];
				my $expect = $input[$n];

				$values =~ s/:.*//;
				$values = &zeroxes($values);
				$expect =~ s/^[^:]+://;

				if ( &is_range($values) ) {
					printf "fixme:%s(%s)(%s)\n", $input[$n], $values, $expect;
				} else {
					&approximate(&value_of($values), $expect, &notes($input[$n]));
				}
			} else {
				my $value = $input[$n];
				$value =~ s/\s*".*//;
				$value = &value_of(&zeroxes($value));
				if ($value gt 0) {
					my $quote = $input[$n];
					my $comment = &notes($input[$n]);
					$quote =~ s/^[^"]*"//;
					$quote =~ s/".*//;
					&approximate($value, $quote, $comment);
				} else {
					printf "fixme:%d(%s)\n", $n, $input[$n];
				}
			}
		} else {
			# printf "skipping line %d:%s\n", $n + 1, $input[$n];
		}
	}
	if ( ! $empty ) {
		&make_footer();
	}
	close FP;
}

sub usage() {
	print <<USAGE;
Usage: $0 [tbl-files]

The script writes a new ".html" file for each input, using
the same name as the input, stripping the ".tbl" suffix.
USAGE
	exit(1);
}

if ( $#ARGV < 0 ) {
	usage();
} else {
	while ( $#ARGV >= 0 ) {
		&doit ( shift @@ARGV );
	}
}
exit (0);
@


1.2
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.1
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 1
d45 2
a46 2
	printf FP "<TITLE>%s table</TITLE>\n", escaped($official);
	printf FP "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n", escaped($charset);
d51 1
a51 1
	printf FP "<H1 ALIGN=center>%s table</H1> \n", escaped($charset);
d80 1
a80 1
			escaped($comments);
d85 1
a85 1
			escaped($comments);
d96 1
a96 1
			escaped($comments);
d100 1
a100 1
			escaped($comments);
d132 1
a132 1
	my $range = zeroxes($_[0]);
d134 1
a134 1
	return value_of($range);
d139 1
a139 1
	my $range = zeroxes($_[0]);
d141 1
a141 1
	return value_of($range);
d146 1
a146 1
	my $newcode = zeroxes($_[1]);
d149 1
a149 1
	my $old_code = value_of($oldcode);
d153 1
a153 1
		make_mark if (( $old_code % 8 ) == 0 );
d156 4
a159 4
			null_row($old_code, $comment);
		} elsif ( is_range($newcode) ) {
			my $first_item = first_of($newcode);
			my $last_item  = last_of($newcode);
d171 1
a171 1
					make_row($old_code, $item, $comment);
d175 1
a175 1
			my $new_code = value_of($newcode);
d182 1
a182 1
				make_row($old_code, $new_code, $comment);
d193 2
a194 2
	my $first_old = first_of($oldcode);
	my $last_old  = last_of($oldcode);
d197 3
a199 3
	if (is_range($newcode)) {
		my $first_new = first_of($newcode);
		my $last_new  = last_of($newcode);
d201 1
a201 1
			one_many($item, $first_new, $comment);
d206 1
a206 1
			one_many($item, $newcode, $comment);
d215 16
d238 1
a238 1
			escaped($expect);
d244 1
a244 1
			escaped($expect);
d273 1
d276 14
a296 11
			if ( $empty ) {
				$target = $charset . ".html";
				printf "=> %s\n", $target;
				open(FP,">$target") || do {
					print STDERR "Can't open output $target: $!\n";
					return;
				};

				make_header($source, $charset, $official);
				$empty = 0;
			}
d298 1
a298 1
			my $newcode = field($input[$n], 1);
d303 3
a305 3
			my $oldcode = field($input[$n], 0);
			if ( is_range($oldcode) ) {
				many_many($oldcode, $newcode, notes($input[$n]));
d307 1
a307 1
				one_many($oldcode, $newcode, notes($input[$n]));
d315 1
a315 1
				$values = zeroxes($values);
d318 2
a319 2
				if ( is_range($values) ) {
					# printf "fixme:%s(%s)(%s)\n", $input[$n], $values, $expect;
d321 1
a321 1
					approximate(value_of($values), $expect, notes($input[$n]));
d326 1
a326 1
				$value = value_of(zeroxes($value));
d329 1
a329 1
					my $comment = notes($input[$n]);
d332 1
a332 4
					$quote =~ s/\\134/\\/g;
					$quote =~ s/\\015/\&#13\;/g;
					$quote =~ s/\\012/\&#10\;/g;
					approximate($value, $quote, $comment);
d334 1
a334 1
					printf "fixme:%s(%s)\n", $input[$n];
d342 1
a342 1
		make_footer();
@

