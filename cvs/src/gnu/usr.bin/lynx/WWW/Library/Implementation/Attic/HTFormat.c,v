head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.21.18.53.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.47;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTFormat.c,v 1.82 2013/11/28 11:12:32 tom Exp $
 *
 *		Manage different file formats			HTFormat.c
 *		=============================
 *
 * Bugs:
 *	Not reentrant.
 *
 *	Assumes the incoming stream is ASCII, rather than a local file
 *	format, and so ALWAYS converts from ASCII on non-ASCII machines.
 *	Therefore, non-ASCII machines can't read local files.
 *
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>

/* Implements:
*/
#include <HTFormat.h>

static float HTMaxSecs = 1e10;	/* No effective limit */

#ifdef UNIX
#ifdef NeXT
#define PRESENT_POSTSCRIPT "open %s; /bin/rm -f %s\n"
#else
#define PRESENT_POSTSCRIPT "(ghostview %s ; /bin/rm -f %s)&\n"
			   /* Full pathname would be better! */
#endif /* NeXT */
#endif /* UNIX */

#include <HTML.h>
#include <HTMLDTD.h>
#include <HText.h>
#include <HTAlert.h>
#include <HTList.h>
#include <HTInit.h>
#include <HTTCP.h>
#include <HTTP.h>
/*	Streams and structured streams which we use:
*/
#include <HTFWriter.h>
#include <HTPlain.h>
#include <SGML.h>
#include <HTMLGen.h>

#include <LYexit.h>
#include <LYUtils.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYLeaks.h>

#ifdef DISP_PARTIAL
#include <LYMainLoop.h>
#endif

BOOL HTOutputSource = NO;	/* Flag: shortcut parser to stdout */

/* this version used by the NetToText stream */
struct _HTStream {
    const HTStreamClass *isa;
    BOOL had_cr;
    HTStream *sink;
};

/*	Presentation methods
 *	--------------------
 */
HTList *HTPresentations = NULL;
HTPresentation *default_presentation = NULL;

/*
 *	To free off the presentation list.
 */
#ifdef LY_FIND_LEAKS
static void HTFreePresentations(void);
#endif

/*	Define a presentation system command for a content-type
 *	-------------------------------------------------------
 */
void HTSetPresentation(const char *representation,
		       const char *command,
		       const char *testcommand,
		       double quality,
		       double secs,
		       double secs_per_byte,
		       long int maxbytes,
		       AcceptMedia media)
{
    HTPresentation *pres = typecalloc(HTPresentation);

    if (pres == NULL)
	outofmem(__FILE__, "HTSetPresentation");

    assert(pres != NULL);
    assert(representation != NULL);

    CTRACE2(TRACE_CFG,
	    (tfp,
	     "HTSetPresentation rep=%s, command=%s, test=%s, qual=%f\n",
	     NonNull(representation),
	     NonNull(command),
	     NonNull(testcommand),
	     quality));

    pres->rep = HTAtom_for(representation);
    pres->rep_out = WWW_PRESENT;	/* Fixed for now ... :-) */
    pres->converter = HTSaveAndExecute;		/* Fixed for now ...     */
    pres->quality = (float) quality;
    pres->secs = (float) secs;
    pres->secs_per_byte = (float) secs_per_byte;
    pres->maxbytes = maxbytes;
    pres->get_accept = 0;
    pres->accept_opt = media;

    pres->command = NULL;
    StrAllocCopy(pres->command, command);

    pres->testcommand = NULL;
    StrAllocCopy(pres->testcommand, testcommand);

    /*
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    if (!HTPresentations) {
	HTPresentations = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTFreePresentations);
#endif
    }

    if (strcmp(representation, "*") == 0) {
	FREE(default_presentation);
	default_presentation = pres;
    } else {
	HTList_addObject(HTPresentations, pres);
    }
}

/*	Define a built-in function for a content-type
 *	---------------------------------------------
 */
void HTSetConversion(const char *representation_in,
		     const char *representation_out,
		     HTConverter *converter,
		     double quality,
		     double secs,
		     double secs_per_byte,
		     long int maxbytes,
		     AcceptMedia media)
{
    HTPresentation *pres = typecalloc(HTPresentation);

    if (pres == NULL)
	outofmem(__FILE__, "HTSetConversion");

    assert(pres != NULL);

    CTRACE2(TRACE_CFG,
	    (tfp,
	     "HTSetConversion rep_in=%s, rep_out=%s, qual=%f\n",
	     NonNull(representation_in),
	     NonNull(representation_out),
	     quality));

    pres->rep = HTAtom_for(representation_in);
    pres->rep_out = HTAtom_for(representation_out);
    pres->converter = converter;
    pres->command = NULL;
    pres->testcommand = NULL;
    pres->quality = (float) quality;
    pres->secs = (float) secs;
    pres->secs_per_byte = (float) secs_per_byte;
    pres->maxbytes = maxbytes;
    pres->get_accept = TRUE;
    pres->accept_opt = media;

    /*
     * Memory Leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    if (!HTPresentations) {
	HTPresentations = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTFreePresentations);
#endif
    }

    HTList_addObject(HTPresentations, pres);
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free the presentation list.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		Made to clean up Lynx's bad leakage.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void HTFreePresentations(void)
{
    HTPresentation *pres = NULL;

    /*
     * Loop through the list.
     */
    while (!HTList_isEmpty(HTPresentations)) {
	/*
	 * Free off each item.  May also need to free off it's items, but not
	 * sure as of yet.
	 */
	pres = (HTPresentation *) HTList_removeLastObject(HTPresentations);
	FREE(pres->command);
	FREE(pres->testcommand);
	FREE(pres);
    }
    /*
     * Free the list itself.
     */
    HTList_delete(HTPresentations);
    HTPresentations = NULL;
}
#endif /* LY_FIND_LEAKS */

/*	File buffering
 *	--------------
 *
 *	The input file is read using the macro which can read from
 *	a socket or a file.
 *	The input buffer size, if large will give greater efficiency and
 *	release the server faster, and if small will save space on PCs etc.
 */
#define INPUT_BUFFER_SIZE 4096	/* Tradeoff */
static char input_buffer[INPUT_BUFFER_SIZE];
static char *input_pointer;
static char *input_limit;
static int input_file_number;

/*	Set up the buffering
 *
 *	These routines are public because they are in fact needed by
 *	many parsers, and on PCs and Macs we should not duplicate
 *	the static buffer area.
 */
void HTInitInput(int file_number)
{
    input_file_number = file_number;
    input_pointer = input_limit = input_buffer;
}

int interrupted_in_htgetcharacter = 0;
int HTGetCharacter(void)
{
    char ch;

    interrupted_in_htgetcharacter = 0;
    do {
	if (input_pointer >= input_limit) {
	    int status = NETREAD(input_file_number,
				 input_buffer, INPUT_BUFFER_SIZE);

	    if (status <= 0) {
		if (status == 0)
		    return EOF;
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetCharacter\n"));
		    interrupted_in_htgetcharacter = 1;
		    return EOF;
		}
		CTRACE((tfp, "HTFormat: File read error %d\n", status));
		return EOF;	/* -1 is returned by UCX
				   at end of HTTP link */
	    }
	    input_pointer = input_buffer;
	    input_limit = input_buffer + status;
	}
	ch = *input_pointer++;
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */

    return FROMASCII(UCH(ch));
}

#ifdef USE_SSL
int HTGetSSLCharacter(void *handle)
{
    char ch;

    interrupted_in_htgetcharacter = 0;
    if (!handle)
	return (char) EOF;
    do {
	if (input_pointer >= input_limit) {
	    int status = SSL_read((SSL *) handle,
				  input_buffer, INPUT_BUFFER_SIZE);

	    if (status <= 0) {
		if (status == 0)
		    return (char) EOF;
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp,
			    "HTFormat: Interrupted in HTGetSSLCharacter\n"));
		    interrupted_in_htgetcharacter = 1;
		    return (char) EOF;
		}
		CTRACE((tfp, "HTFormat: SSL_read error %d\n", status));
		return (char) EOF;	/* -1 is returned by UCX
					   at end of HTTP link */
	    }
	    input_pointer = input_buffer;
	    input_limit = input_buffer + status;
	}
	ch = *input_pointer++;
    } while (ch == (char) 13);	/* Ignore ASCII carriage return */

    return FROMASCII(ch);
}
#endif /* USE_SSL */

/* Match maintype to any MIME type starting with maintype, for example: 
 * image/gif should match image
 */
static int half_match(char *trial_type, char *target)
{
    char *cp = StrChr(trial_type, '/');

    /* if no '/' or no '*' */
    if (!cp || *(cp + 1) != '*')
	return 0;

    CTRACE((tfp, "HTFormat: comparing %s and %s for half match\n",
	    trial_type, target));

    /* main type matches */
    if (!StrNCmp(trial_type, target, ((cp - trial_type) - 1)))
	return 1;

    return 0;
}

/*
 * Evaluate a deferred mailcap test command, i.e.,. one that substitutes the
 * document's charset or other values in %{name} format.
 */
static BOOL failsMailcap(HTPresentation *pres, HTParentAnchor *anchor)
{
    if (pres->testcommand != 0) {
	if (LYTestMailcapCommand(pres->testcommand,
				 anchor->content_type_params) != 0)
	    return TRUE;
    }
    return FALSE;
}

#define WWW_WILDCARD_REP_OUT HTAtom_for("*")

/*		Look up a presentation
 *		----------------------
 *
 *	If fill_in is NULL, only look for an exact match.
 *	If a wildcard match is made, *fill_in is used to store
 *	a possibly modified presentation, and a pointer to it is
 *	returned.  For an exact match, a pointer to the presentation
 *	in the HTPresentations list is returned.  Returns NULL if
 *	nothing found. - kw
 *
 */
static HTPresentation *HTFindPresentation(HTFormat rep_in,
					  HTFormat rep_out,
					  HTPresentation *fill_in,
					  HTParentAnchor *anchor)
{
    HTAtom *wildcard = NULL;	/* = HTAtom_for("*"); lookup when needed - kw */
    int n;
    int i;
    HTPresentation *pres;
    HTPresentation *match;
    HTPresentation *strong_wildcard_match = 0;
    HTPresentation *weak_wildcard_match = 0;
    HTPresentation *last_default_match = 0;
    HTPresentation *strong_subtype_wildcard_match = 0;

    CTRACE((tfp, "HTFormat: Looking up presentation for %s to %s\n",
	    HTAtom_name(rep_in), HTAtom_name(rep_out)));

    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i++) {
	pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (pres->rep == rep_in) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		CTRACE((tfp, "FindPresentation: found exact match: %s -> %s\n",
			HTAtom_name(pres->rep),
			HTAtom_name(pres->rep_out)));
		return pres;

	    } else if (!fill_in) {
		continue;
	    } else {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
		    if (!strong_wildcard_match)
			strong_wildcard_match = pres;
		    /* otherwise use the first one */
		    CTRACE((tfp,
			    "StreamStack: found strong wildcard match: %s -> %s\n",
			    HTAtom_name(pres->rep),
			    HTAtom_name(pres->rep_out)));
		}
	    }

	} else if (!fill_in) {
	    continue;

	} else if (half_match(HTAtom_name(pres->rep),
			      HTAtom_name(rep_in))) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!strong_subtype_wildcard_match)
		    strong_subtype_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found strong subtype wildcard match: %s -> %s\n",
			HTAtom_name(pres->rep),
			HTAtom_name(pres->rep_out)));
	    }
	}

	if (pres->rep == WWW_SOURCE) {
	    if (pres->rep_out == rep_out) {
		if (failsMailcap(pres, anchor))
		    continue;
		if (!weak_wildcard_match)
		    weak_wildcard_match = pres;
		/* otherwise use the first one */
		CTRACE((tfp,
			"StreamStack: found weak wildcard match: %s\n",
			HTAtom_name(pres->rep_out)));

	    } else if (!last_default_match) {
		if (!wildcard)
		    wildcard = WWW_WILDCARD_REP_OUT;
		if (pres->rep_out == wildcard) {
		    if (failsMailcap(pres, anchor))
			continue;
		    last_default_match = pres;
		    /* otherwise use the first one */
		}
	    }
	}
    }

    match = (strong_subtype_wildcard_match
	     ? strong_subtype_wildcard_match
	     : (strong_wildcard_match
		? strong_wildcard_match
		: (weak_wildcard_match
		   ? weak_wildcard_match
		   : last_default_match)));

    if (match) {
	*fill_in = *match;	/* Specific instance */
	fill_in->rep = rep_in;	/* yuk */
	fill_in->rep_out = rep_out;	/* yuk */
	return fill_in;
    }

    return NULL;
}

/*		Create a filter stack
 *		---------------------
 *
 *	If a wildcard match is made, a temporary HTPresentation
 *	structure is made to hold the destination format while the
 *	new stack is generated. This is just to pass the out format to
 *	MIME so far.  Storing the format of a stream in the stream might
 *	be a lot neater.
 *
 */
HTStream *HTStreamStack(HTFormat rep_in,
			HTFormat rep_out,
			HTStream *sink,
			HTParentAnchor *anchor)
{
    HTPresentation temp;
    HTPresentation *match;
    HTStream *result;

    CTRACE((tfp, "StreamStack: Constructing stream stack for %s to %s (%s)\n",
	    HTAtom_name(rep_in),
	    HTAtom_name(rep_out),
	    NONNULL(anchor->content_type_params)));

    if (rep_out == rep_in) {
	result = sink;

    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp, anchor))) {
	if (match == &temp) {
	    CTRACE((tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out)));
	} else {
	    CTRACE((tfp, "StreamStack: found exact match: %s -> %s\n",
		    HTAtom_name(match->rep),
		    HTAtom_name(match->rep_out)));
	}
	result = (*match->converter) (match, anchor, sink);
    } else {
	result = NULL;
    }
    if (TRACE) {
	if (result && result->isa && result->isa->name) {
	    CTRACE((tfp, "StreamStack: Returning \"%s\"\n", result->isa->name));
	} else if (result) {
	    CTRACE((tfp, "StreamStack: Returning *unknown* stream!\n"));
	} else {
	    CTRACE((tfp, "StreamStack: Returning NULL!\n"));
	    CTRACE_FLUSH(tfp);	/* a crash may be imminent... - kw */
	}
    }
    return result;
}

/*		Put a presentation near start of list
 *		-------------------------------------
 *
 *	Look up a presentation (exact match only) and, if found, reorder
 *	it to the start of the HTPresentations list. - kw
 */
void HTReorderPresentation(HTFormat rep_in,
			   HTFormat rep_out)
{
    HTPresentation *match;

    if ((match = HTFindPresentation(rep_in, rep_out, NULL, NULL))) {
	HTList_removeObject(HTPresentations, match);
	HTList_addObject(HTPresentations, match);
    }
}

/*
 * Setup 'get_accept' flag to denote presentations that are not redundant,
 * and will be listed in "Accept:" header.
 */
void HTFilterPresentations(void)
{
    int i, j;
    int n = HTList_count(HTPresentations);
    HTPresentation *p, *q;
    BOOL matched;
    char *s, *t;

    CTRACE((tfp, "HTFilterPresentations (AcceptMedia %#x)\n", LYAcceptMedia));
    for (i = 0; i < n; i++) {
	p = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	s = HTAtom_name(p->rep);

	p->get_accept = FALSE;
	if ((LYAcceptMedia & p->accept_opt) != 0
	    && p->rep_out == WWW_PRESENT
	    && p->rep != WWW_SOURCE
	    && strcasecomp(s, "www/mime")
	    && strcasecomp(s, "www/compressed")
	    && p->quality <= 1.0 && p->quality >= 0.0) {
	    matched = TRUE;
	    for (j = 0; j < i; j++) {
		q = (HTPresentation *) HTList_objectAt(HTPresentations, j);
		t = HTAtom_name(q->rep);

		if (!strcasecomp(s, t)) {
		    matched = FALSE;
		    CTRACE((tfp, "  match %s %s\n", s, t));
		    break;
		}
	    }
	    p->get_accept = matched;
	}
    }
}

/*		Find the cost of a filter stack
 *		-------------------------------
 *
 *	Must return the cost of the same stack which StreamStack would set up.
 *
 * On entry,
 *	length	The size of the data to be converted
 */
float HTStackValue(HTFormat rep_in,
		   HTFormat rep_out,
		   double initial_value,
		   long int length)
{
    HTAtom *wildcard = WWW_WILDCARD_REP_OUT;

    CTRACE((tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
	    HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));

    if (rep_out == WWW_SOURCE || rep_out == rep_in)
	return 0.0;

    {
	int n = HTList_count(HTPresentations);
	int i;
	HTPresentation *pres;

	for (i = 0; i < n; i++) {
	    pres = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	    if (pres->rep == rep_in &&
		(pres->rep_out == rep_out || pres->rep_out == wildcard)) {
		float value = (float) (initial_value * pres->quality);

		if (HTMaxSecs > 0.0)
		    value = (value
			     - ((float) length * pres->secs_per_byte
				+ pres->secs)
			     / HTMaxSecs);
		return value;
	    }
	}
    }

    return (float) -1e30;	/* Really bad */

}

/*	Display the page while transfer in progress
 *	-------------------------------------------
 *
 *   Repaint the page only when necessary.
 *   This is a traverse call for HText_pageDisplay() - it works!.
 *
 */
void HTDisplayPartial(void)
{
#ifdef DISP_PARTIAL
    if (display_partial) {
	/*
	 * HText_getNumOfLines() = "current" number of complete lines received
	 * NumOfLines_partial = number of lines at the moment of last repaint. 
	 * (we update NumOfLines_partial only when we repaint the display.)
	 *
	 * display_partial could only be enabled in HText_new() so a new
	 * HTMainText object available - all HText_ functions use it, lines
	 * counter HText_getNumOfLines() in particular.
	 *
	 * Otherwise HTMainText holds info from the previous document and we
	 * may repaint it instead of the new one:  prev doc scrolled to the
	 * first line (=Newline_partial) is not good looking :-) 23 Aug 1998
	 * Leonid Pauzner
	 *
	 * So repaint the page only when necessary:
	 */
	int Newline_partial = LYGetNewline();

	if (((Newline_partial + display_lines) - 1 > NumOfLines_partial)
	/* current page not complete... */
	    && (partial_threshold > 0 ?
		((Newline_partial + partial_threshold) - 1 <=
		 HText_getNumOfLines()) :
		((Newline_partial + display_lines) - 1 <= HText_getNumOfLines()))
	/*
	 * Originally we rendered by increments of 2 lines,
	 * but that got annoying on slow network connections.
	 * Then we switched to full-pages.  Now it's configurable.
	 * If partial_threshold <= 0, then it's a full page
	 */
	    ) {
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
	}
    }
#else /* nothing */
#endif /* DISP_PARTIAL */
}

/* Put this as early as possible, OK just after HTDisplayPartial() */
void HTFinishDisplayPartial(void)
{
#ifdef DISP_PARTIAL
    /*
     * End of incremental rendering stage here.
     */
    display_partial = FALSE;
#endif /* DISP_PARTIAL */
}

/*	Push data from a socket down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream, i.e., containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-2		Unexpected disconnect before any data received.
 *	-1		Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-2		socket still open, target stream still valid.
 *	-1		socket still open, target aborted.
 *	otherwise	socket closed,	target stream still valid.
 */
int HTCopy(HTParentAnchor *anchor,
	   int file_number,
	   void *handle GCC_UNUSED,
	   HTStream *sink)
{
    HTStreamClass targetClass;
    BOOL suppress_readprogress = NO;
    off_t limit = anchor ? anchor->content_length : 0;
    off_t bytes = anchor ? anchor->actual_length : 0;
    off_t total;
    int rv = 0;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push binary from socket down sink
     *
     * This operation could be put into a main event loop
     */
    HTReadProgress(bytes, (off_t) 0);
    for (;;) {
	int status;

	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    (*targetClass._abort) (sink, NULL);
	    rv = -1;
	    goto finished;
	}

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    (*targetClass._abort) (sink, NULL);
	    if (bytes)
		rv = HT_INTERRUPTED;
	    else
		rv = -1;
	    goto finished;
	}
#ifdef USE_SSL
	if (handle)
	    status = SSL_read((SSL *) handle, input_buffer, INPUT_BUFFER_SIZE);
	else
	    status = NETREAD(file_number, input_buffer, INPUT_BUFFER_SIZE);
#else
	status = NETREAD(file_number, input_buffer, INPUT_BUFFER_SIZE);
#endif /* USE_SSL */

	if (status <= 0) {
	    if (status == 0) {
		break;
	    } else if (status == HT_INTERRUPTED) {
		_HTProgress(TRANSFER_INTERRUPTED);
		(*targetClass._abort) (sink, NULL);
		if (bytes)
		    rv = HT_INTERRUPTED;
		else
		    rv = -1;
		goto finished;
	    } else if (SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS			/* 1997/11/10 (Mon) 16:57:18 */
		       SOCKET_ERRNO == ETIMEDOUT ||
#endif
		       SOCKET_ERRNO == ECONNRESET ||
		       SOCKET_ERRNO == EPIPE) {
		/*
		 * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
		 */
		if (bytes <= 0) {
		    /*
		     * Don't have any data, so let the calling function decide
		     * what to do about it.  - FM
		     */
		    rv = -2;
		    goto finished;
		} else {
#ifdef UNIX
		    /*
		     * Treat what we've received already as the complete
		     * transmission, but not without giving the user an alert. 
		     * I don't know about all the different TCP stacks for VMS
		     * etc., so this is currently only for UNIX.  - kw
		     */
		    HTInetStatus("NETREAD");
		    HTAlert("Unexpected server disconnect.");
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
#else /* !UNIX */
		    /*
		     * Treat what we've gotten already as the complete
		     * transmission.  - FM
		     */
		    CTRACE((tfp,
			    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
		    status = 0;
#endif /* UNIX */
		}
#ifdef UNIX
	    } else {		/* status < 0 and other errno */
		/*
		 * Treat what we've received already as the complete
		 * transmission, but not without giving the user an alert.  I
		 * don't know about all the different TCP stacks for VMS etc.,
		 * so this is currently only for UNIX.  - kw
		 */
		HTInetStatus("NETREAD");
		HTAlert("Unexpected read error.");
		if (bytes) {
		    (void) NETCLOSE(file_number);
		    rv = HT_LOADED;
		} else {
		    (*targetClass._abort) (sink, NULL);
		    rv = -1;
		}
		goto finished;
#endif
	    }
	    break;
	}

	/*
	 * Suppress ReadProgress messages when collecting a redirection
	 * message, at least initially (unless/until anchor->content_type gets
	 * changed, probably by the MIME message parser).  That way messages
	 * put up by the HTTP module or elsewhere can linger in the statusline
	 * for a while.  - kw
	 */
	suppress_readprogress = (BOOL) (anchor && anchor->content_type &&
					!strcmp(anchor->content_type,
						"message/x-http-redirection"));
#ifdef NOT_ASCII
	{
	    char *p;

	    for (p = input_buffer; p < input_buffer + status; p++) {
		*p = FROMASCII(*p);
	    }
	}
#endif /* NOT_ASCII */

	total = bytes + status;
	if (limit == 0 || bytes == 0 || (total < limit)) {
	    (*targetClass.put_block) (sink, input_buffer, status);
	} else if (bytes < limit) {
	    (*targetClass.put_block) (sink, input_buffer, (int) (limit - bytes));
	}
	bytes = total;
	if (!suppress_readprogress)
	    HTReadProgress(bytes, limit);
	HTDisplayPartial();

    }				/* next bufferload */
    if (anchor != 0) {
	CTRACE((tfp, "HTCopy copied %"
		PRI_off_t " actual, %"
		PRI_off_t " limit\n", bytes, limit));
	anchor->actual_length = bytes;
    }

    _HTProgress(TRANSFER_COMPLETE);
    (void) NETCLOSE(file_number);
    rv = HT_LOADED;

  finished:
    HTFinishDisplayPartial();
    return (rv);
}

/*	Push data from a file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open, target stream still valid.
 */
int HTFileCopy(FILE *fp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status;
    off_t bytes;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  Push binary from socket down sink
     */
    HTReadProgress(bytes = 0, (off_t) 0);
    for (;;) {
	status = (int) fread(input_buffer,
			     (size_t) 1,
			     (size_t) INPUT_BUFFER_SIZE, fp);
	if (status == 0) {	/* EOF or error */
	    if (ferror(fp) == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTFormat: Read error, read returns %d\n",
		    ferror(fp)));
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, (off_t) 0);
	/* Suppress last screen update in partial mode - a regular update under
	 * control of mainloop() should follow anyway.  - kw
	 */
#ifdef DISP_PARTIAL
	if (display_partial && bytes != HTMainAnchor->content_length)
	    HTDisplayPartial();
#endif

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}

#ifdef USE_SOURCE_CACHE
/*	Push data from an HTChunk down a stream
 *	---------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) and target (sink) assumed valid.
 *
 *  Return values:
 *	HT_LOADED	All data sent.
 *	HT_INTERRUPTED  Interruption after some data read.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged, target stream still valid.
 */
int HTMemCopy(HTChunk *chunk, HTStream *sink)
{
    HTStreamClass targetClass;
    off_t bytes;
    int rv = HT_OK;

    targetClass = *(sink->isa);
    HTReadProgress(bytes = 0, (off_t) 0);
    for (; chunk != NULL; chunk = chunk->next) {

	/* Push the data down the stream a piece at a time, in case we're
	 * running a large document on a slow machine.
	 */
	(*targetClass.put_block) (sink, chunk->data, chunk->size);
	bytes += chunk->size;

	HTReadProgress(bytes, (off_t) 0);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
	    break;
	}
    }

    HTFinishDisplayPartial();
    return rv;
}
#endif

#ifdef USE_ZLIB
/*	Push data from a gzip file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      gzFile (gzfp) assumed open (should have gzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp still open, target stream still valid.
 */
static int HTGzFileCopy(gzFile gzfp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status;
    off_t bytes;
    int gzerrnum;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  read and inflate gzip'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, (off_t) 0);
    for (;;) {
	status = gzread(gzfp, input_buffer, INPUT_BUFFER_SIZE);
	if (status <= 0) {	/* EOF or error */
	    if (status == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
		    status));
	    CTRACE((tfp, "gzerror   : %s\n",
		    gzerror(gzfp, &gzerrnum)));
	    if (TRACE) {
		if (gzerrnum == Z_ERRNO)
		    perror("gzerror   ");
	    }
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, (off_t) -1);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    rv = HT_INTERRUPTED;
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}

#ifndef HAVE_ZERROR
#define zError(s) LynxZError(s)
static const char *zError(int status)
{
    static char result[80];

    sprintf(result, "zlib error %d", status);
    return result;
}
#endif

/*	Push data from a deflate file pointer down a stream
 *	-------------------------------------
 *
 *  This routine is responsible for creating and PRESENTING any
 *  graphic (or other) objects described by the file.  The code is
 *  loosely based on the inflate.c file from w3m.
 *
 *
 *  State of file and target stream on entry:
 *		      FILE (zzfp) assumed open (should have deflated content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp still open, target stream still valid.
 */
static int HTZzFileCopy(FILE *zzfp, HTStream *sink)
{
    static char dummy_head[1 + 1] =
    {
	0x8 + 0x7 * 0x10,
	(((0x8 + 0x7 * 0x10) * 0x100 + 30) / 31 * 31) & 0xFF,
    };

    z_stream s;
    HTStreamClass targetClass;
    off_t bytes;
    int rv = HT_OK;
    char output_buffer[INPUT_BUFFER_SIZE];
    int status;
    int flush;
    int retry = 0;
    int len = 0;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    s.zalloc = Z_NULL;
    s.zfree = Z_NULL;
    s.opaque = Z_NULL;
    status = inflateInit(&s);
    if (status != Z_OK) {
	CTRACE((tfp, "HTZzFileCopy inflateInit() %s\n", zError(status)));
	exit_immediately(EXIT_FAILURE);
    }
    s.avail_in = 0;
    s.next_out = (Bytef *) output_buffer;
    s.avail_out = sizeof(output_buffer);
    flush = Z_NO_FLUSH;

    /*  read and inflate deflate'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, (off_t) 0);
    for (;;) {
	if (s.avail_in == 0) {
	    s.next_in = (Bytef *) input_buffer;
	    s.avail_in = (uInt) fread(input_buffer,
				      (size_t) 1,
				      (size_t) INPUT_BUFFER_SIZE, zzfp);
	    len = (int) s.avail_in;
	}
	status = inflate(&s, flush);
	if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
	    len = (int) sizeof(output_buffer) - (int) s.avail_out;
	    if (len > 0) {
		(*targetClass.put_block) (sink, output_buffer, len);
		bytes += len;
		HTReadProgress(bytes, (off_t) -1);
		HTDisplayPartial();
	    }
	    rv = HT_LOADED;
	    break;
	} else if (status == Z_DATA_ERROR && !retry++) {
	    status = inflateReset(&s);
	    if (status != Z_OK) {
		CTRACE((tfp, "HTZzFileCopy inflateReset() %s\n", zError(status)));
		rv = -1;
		break;
	    }
	    s.next_in = (Bytef *) dummy_head;
	    s.avail_in = sizeof(dummy_head);
	    (void) inflate(&s, flush);
	    s.next_in = (Bytef *) input_buffer;
	    s.avail_in = (unsigned) len;
	    continue;
	} else if (status != Z_OK) {
	    CTRACE((tfp, "HTZzFileCopy inflate() %s\n", zError(status)));
	    rv = bytes ? HT_PARTIAL_CONTENT : -1;
	    break;
	} else if (s.avail_out == 0) {
	    len = sizeof(output_buffer);
	    s.next_out = (Bytef *) output_buffer;
	    s.avail_out = sizeof(output_buffer);

	    (*targetClass.put_block) (sink, output_buffer, len);
	    bytes += len;
	    HTReadProgress(bytes, (off_t) -1);
	    HTDisplayPartial();

	    if (HTCheckForInterrupt()) {
		_HTProgress(TRANSFER_INTERRUPTED);
		rv = bytes ? HT_INTERRUPTED : -1;
		break;
	    }
	}
	retry = 1;
    }				/* next bufferload */

    inflateEnd(&s);
    HTFinishDisplayPartial();
    return rv;
}
#endif /* USE_ZLIB */

#ifdef USE_BZLIB
/*	Push data from a bzip file pointer down a stream
 *	-------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *
 *  State of file and target stream on entry:
 *		      BZFILE (bzfp) assumed open (should have bzipped content),
 *		      target (sink) assumed valid.
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption after some data read.
 *	HT_PARTIAL_CONTENT	Error after some data read.
 *	-1		Error before any data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp still open, target stream still valid.
 */
static int HTBzFileCopy(BZFILE * bzfp, HTStream *sink)
{
    HTStreamClass targetClass;
    int status;
    off_t bytes;
    int bzerrnum;
    int rv = HT_OK;

    /*  Push the data down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*  read and inflate bzip'd file, and push binary down sink
     */
    HTReadProgress(bytes = 0, (off_t) 0);
    for (;;) {
	status = BZ2_bzread(bzfp, input_buffer, INPUT_BUFFER_SIZE);
	if (status <= 0) {	/* EOF or error */
	    if (status == 0) {
		rv = HT_LOADED;
		break;
	    }
	    CTRACE((tfp, "HTBzFileCopy: Read error, bzread returns %d\n",
		    status));
	    CTRACE((tfp, "bzerror   : %s\n",
		    BZ2_bzerror(bzfp, &bzerrnum)));
	    if (bytes) {
		rv = HT_PARTIAL_CONTENT;
	    } else {
		rv = -1;
	    }
	    break;
	}

	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
	HTReadProgress(bytes, (off_t) -1);
	HTDisplayPartial();

	if (HTCheckForInterrupt()) {
	    _HTProgress(TRANSFER_INTERRUPTED);
	    rv = HT_INTERRUPTED;
	    break;
	}
    }				/* next bufferload */

    HTFinishDisplayPartial();
    return rv;
}
#endif /* USE_BZLIB */

/*	Push data from a socket down a stream STRIPPING CR
 *	--------------------------------------------------
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the socket.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 */
void HTCopyNoCR(HTParentAnchor *anchor GCC_UNUSED,
		int file_number,
		HTStream *sink)
{
    HTStreamClass targetClass;
    int character;

    /*  Push the data, ignoring CRLF, down the stream
     */
    targetClass = *(sink->isa);	/* Copy pointers to procedures */

    /*
     * Push text from telnet socket down sink
     *
     * @@@@@@@@@@ To push strings could be faster?  (especially is we cheat and
     * don't ignore CR!  :-}
     */
    HTInitInput(file_number);
    for (;;) {
	character = HTGetCharacter();
	if (character == EOF)
	    break;
	(*targetClass.put_character) (sink, (char) character);
    }
}

/*	Parse a socket given format and file number
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to LF for unix
 *   when the format is textual.
 *
 *  State of socket and target stream on entry:
 *			socket (file_number) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	HT_INTERRUPTED  Interruption or error after some data received.
 *	-501		Stream stack failed (cannot present or convert).
 *	-2		Unexpected disconnect before any data received.
 *	-1		Stream stack failed (cannot present or convert), or
 *			Interruption or error before any data received, or
 *			(UNIX) other read error before any data received, or
 *			download cancelled.
 *	HT_LOADED	Normal close of socket (end of file indication
 *			received), or
 *			unexpected disconnect after some data received, or
 *			other read error after some data received, or
 *			(not UNIX) other read error before any data received.
 *
 *  State of socket and target stream on return depends on return value:
 *	HT_INTERRUPTED	socket still open, target aborted.
 *	-501		socket still open, target stream NULL.
 *	-2		socket still open, target freed.
 *	-1		socket still open, target stream aborted or NULL.
 *	otherwise	socket closed,	target stream freed.
 */
int HTParseSocket(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  int file_number,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream) {
	char *buffer = 0;

	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
	}
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat: %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);	/* returns -501 */
	FREE(buffer);
    } else {
	/*
	 * Push the data, don't worry about CRLF we can strip them later.
	 */
	targetClass = *(stream->isa);	/* Copy pointers to procedures */
	rv = HTCopy(anchor, file_number, NULL, stream);
	if (rv != -1 && rv != HT_INTERRUPTED)
	    (*targetClass._free) (stream);
    }
    return rv;
    /* Originally:  full: HT_LOADED;  partial: HT_INTERRUPTED;  no bytes: -1 */
}

/*	Parse a file given format and file pointer
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *   The file number given is assumed to be a TELNET stream ie containing
 *   CRLF at the end of lines which need to be stripped to \n for unix
 *   when the format is textual.
 *
 *  State of file and target stream on entry:
 *			FILE* (fp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		fp still open; target freed, aborted, or NULL.
 */
int HTParseFile(HTFormat rep_in,
		HTFormat format_out,
		HTParentAnchor *anchor,
		FILE *fp,
		HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;
    int result;

    if (fp == NULL) {
	result = HT_LOADED;
    } else {
	stream = HTStreamStack(rep_in, format_out, sink, anchor);

	if (!stream || !stream->isa) {
	    char *buffer = 0;

	    if (LYCancelDownload) {
		LYCancelDownload = FALSE;
		result = -1;
	    } else {
		HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
			   HTAtom_name(rep_in), HTAtom_name(format_out));
		CTRACE((tfp, "HTFormat(in HTParseFile): %s\n", buffer));
		rv = HTLoadError(sink, 501, buffer);
		FREE(buffer);
		result = rv;
	    }
	} else {

	    /*
	     * Push the data down the stream
	     *
	     * @@@@ Bug:  This decision ought to be made based on "encoding"
	     * rather than on content-type.  @@@@@@ When we handle encoding.  The
	     * current method smells anyway.
	     */
	    targetClass = *(stream->isa);	/* Copy pointers to procedures */
	    rv = HTFileCopy(fp, stream);
	    if (rv == -1 || rv == HT_INTERRUPTED) {
		(*targetClass._abort) (stream, NULL);
	    } else {
		(*targetClass._free) (stream);
	    }

	    if (rv == -1) {
		result = HT_NO_DATA;
	    } else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED)) {
		result = HT_PARTIAL_CONTENT;
	    } else {
		result = HT_LOADED;
	    }
	}
    }
    return result;
}

#ifdef USE_SOURCE_CACHE
/*	Parse a document in memory given format and memory block pointer
 *
 *   This routine is responsible for creating and PRESENTING any
 *   graphic (or other) objects described by the file.
 *
 *  State of memory and target stream on entry:
 *			HTChunk* (chunk) assumed valid,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	HT_LOADED	All data sent.
 *
 *  State of memory and target stream on return:
 *	always		chunk unchanged; target freed, aborted, or NULL.
 */
int HTParseMem(HTFormat rep_in,
	       HTFormat format_out,
	       HTParentAnchor *anchor,
	       HTChunk *chunk,
	       HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;
    int result;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);
    if (!stream || !stream->isa) {
	char *buffer = 0;

	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseMem): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	result = rv;
    } else {

	/* Push the data down the stream
	 */
	targetClass = *(stream->isa);
	(void) HTMemCopy(chunk, stream);
	(*targetClass._free) (stream);
	result = HT_LOADED;
    }
    return result;
}
#endif

#ifdef USE_ZLIB
static int HTCloseGzFile(gzFile gzfp)
{
    int gzres;

    if (gzfp == NULL)
	return 0;
    gzres = gzclose(gzfp);
    if (TRACE) {
	if (gzres == Z_ERRNO) {
	    perror("gzclose   ");
	} else if (gzres != Z_OK) {
	    CTRACE((tfp, "gzclose   : error number %d\n", gzres));
	}
    }
    return (gzres);
}

/*	HTParseGzFile
 *
 *  State of file and target stream on entry:
 *			gzFile (gzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		gzfp closed; target freed, aborted, or NULL.
 */
int HTParseGzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  gzFile gzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;
    int result;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream || !stream->isa) {
	char *buffer = 0;

	HTCloseGzFile(gzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    result = -1;
	} else {
	    HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		       HTAtom_name(rep_in), HTAtom_name(format_out));
	    CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	    rv = HTLoadError(sink, 501, buffer);
	    FREE(buffer);
	    result = rv;
	}
    } else {

	/*
	 * Push the data down the stream
	 *
	 * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
	 * on content-type.  @@@@@@ When we handle encoding.  The current method
	 * smells anyway.
	 */
	targetClass = *(stream->isa);	/* Copy pointers to procedures */
	rv = HTGzFileCopy(gzfp, stream);
	if (rv == -1 || rv == HT_INTERRUPTED) {
	    (*targetClass._abort) (stream, NULL);
	} else {
	    (*targetClass._free) (stream);
	}

	HTCloseGzFile(gzfp);
	if (rv == -1) {
	    result = HT_NO_DATA;
	} else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED)) {
	    result = HT_PARTIAL_CONTENT;
	} else {
	    result = HT_LOADED;
	}
    }
    return result;
}

/*	HTParseZzFile
 *
 *  State of file and target stream on entry:
 *			FILE (zzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		zzfp closed; target freed, aborted, or NULL.
 */
int HTParseZzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  FILE *zzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;
    int result;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream || !stream->isa) {
	char *buffer = 0;

	fclose(zzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    result = -1;
	} else {
	    HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		       HTAtom_name(rep_in), HTAtom_name(format_out));
	    CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	    rv = HTLoadError(sink, 501, buffer);
	    FREE(buffer);
	    result = rv;
	}
    } else {

	/*
	 * Push the data down the stream
	 *
	 * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
	 * on content-type.  @@@@@@ When we handle encoding.  The current method
	 * smells anyway.
	 */
	targetClass = *(stream->isa);	/* Copy pointers to procedures */
	rv = HTZzFileCopy(zzfp, stream);
	if (rv == -1 || rv == HT_INTERRUPTED) {
	    (*targetClass._abort) (stream, NULL);
	} else {
	    (*targetClass._free) (stream);
	}

	fclose(zzfp);
	if (rv == -1) {
	    result = HT_NO_DATA;
	} else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED)) {
	    result = HT_PARTIAL_CONTENT;
	} else {
	    result = HT_LOADED;
	}
    }
    return result;
}
#endif /* USE_ZLIB */

#ifdef USE_BZLIB
static void HTCloseBzFile(BZFILE * bzfp)
{
    if (bzfp)
	BZ2_bzclose(bzfp);
}

/*	HTParseBzFile
 *
 *  State of file and target stream on entry:
 *			bzFile (bzfp) assumed open,
 *			target (sink) usually NULL (will call stream stack).
 *
 *  Return values:
 *	-501		Stream stack failed (cannot present or convert).
 *	-1		Download cancelled.
 *	HT_NO_DATA	Error before any data read.
 *	HT_PARTIAL_CONTENT	Interruption or error after some data read.
 *	HT_LOADED	Normal end of file indication on reading.
 *
 *  State of file and target stream on return:
 *	always		bzfp closed; target freed, aborted, or NULL.
 */
int HTParseBzFile(HTFormat rep_in,
		  HTFormat format_out,
		  HTParentAnchor *anchor,
		  BZFILE * bzfp,
		  HTStream *sink)
{
    HTStream *stream;
    HTStreamClass targetClass;
    int rv;
    int result;

    stream = HTStreamStack(rep_in, format_out, sink, anchor);

    if (!stream || !stream->isa) {
	char *buffer = 0;

	HTCloseBzFile(bzfp);
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    result = -1;
	} else {
	    HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		       HTAtom_name(rep_in), HTAtom_name(format_out));
	    CTRACE((tfp, "HTFormat(in HTParseBzFile): %s\n", buffer));
	    rv = HTLoadError(sink, 501, buffer);
	    FREE(buffer);
	    result = rv;
	}
    } else {

	/*
	 * Push the data down the stream
	 *
	 * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
	 * on content-type.  @@@@@@ When we handle encoding.  The current method
	 * smells anyway.
	 */
	targetClass = *(stream->isa);	/* Copy pointers to procedures */
	rv = HTBzFileCopy(bzfp, stream);
	if (rv == -1 || rv == HT_INTERRUPTED) {
	    (*targetClass._abort) (stream, NULL);
	} else {
	    (*targetClass._free) (stream);
	}

	HTCloseBzFile(bzfp);
	if (rv == -1) {
	    result = HT_NO_DATA;
	} else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED)) {
	    result = HT_PARTIAL_CONTENT;
	} else {
	    result = HT_LOADED;
	}
    }
    return result;
}
#endif /* USE_BZLIB */

/*	Converter stream: Network Telnet to internal character text
 *	-----------------------------------------------------------
 *
 *	The input is assumed to be in ASCII, with lines delimited
 *	by (13,10) pairs, These pairs are converted into (CR,LF)
 *	pairs in the local representation.  The (CR,LF) sequence
 *	when found is changed to a '\n' character, the internal
 *	C representation of a new line.
 */

static void NetToText_put_character(HTStream *me, int net_char)
{
    char c = (char) FROMASCII(net_char);

    if (me->had_cr) {
	if (c == LF) {
	    me->sink->isa->put_character(me->sink, '\n');	/* Newline */
	    me->had_cr = NO;
	    return;
	} else {
	    me->sink->isa->put_character(me->sink, CR);		/* leftover */
	}
    }
    me->had_cr = (BOOL) (c == CR);
    if (!me->had_cr)
	me->sink->isa->put_character(me->sink, c);	/* normal */
}

static void NetToText_put_string(HTStream *me, const char *s)
{
    const char *p;

    for (p = s; *p; p++)
	NetToText_put_character(me, *p);
}

static void NetToText_put_block(HTStream *me, const char *s, int l)
{
    const char *p;

    for (p = s; p < (s + l); p++)
	NetToText_put_character(me, *p);
}

static void NetToText_free(HTStream *me)
{
    (me->sink->isa->_free) (me->sink);	/* Close rest of pipe */
    FREE(me);
}

static void NetToText_abort(HTStream *me, HTError e)
{
    me->sink->isa->_abort(me->sink, e);		/* Abort rest of pipe */
    FREE(me);
}

/*	The class structure
*/
static HTStreamClass NetToTextClass =
{
    "NetToText",
    NetToText_free,
    NetToText_abort,
    NetToText_put_character,
    NetToText_put_string,
    NetToText_put_block
};

/*	The creation method
*/
HTStream *HTNetToText(HTStream *sink)
{
    HTStream *me = typecalloc(HTStream);

    if (me == NULL)
	outofmem(__FILE__, "NetToText");

    assert(me != NULL);

    me->isa = &NetToTextClass;

    me->had_cr = NO;
    me->sink = sink;
    return me;
}

static HTStream HTBaseStreamInstance;	/* Made static */

/*
 *	ERROR STREAM
 *	------------
 *	There is only one error stream shared by anyone who wants a
 *	generic error returned from all stream methods.
 */
static void HTErrorStream_put_character(HTStream *me GCC_UNUSED, int c GCC_UNUSED)
{
    LYCancelDownload = TRUE;
}

static void HTErrorStream_put_string(HTStream *me GCC_UNUSED, const char *s)
{
    if (s && *s)
	LYCancelDownload = TRUE;
}

static void HTErrorStream_write(HTStream *me GCC_UNUSED, const char *s, int l)
{
    if (l && s)
	LYCancelDownload = TRUE;
}

static void HTErrorStream_free(HTStream *me GCC_UNUSED)
{
    return;
}

static void HTErrorStream_abort(HTStream *me GCC_UNUSED, HTError e GCC_UNUSED)
{
    return;
}

static const HTStreamClass HTErrorStreamClass =
{
    "ErrorStream",
    HTErrorStream_free,
    HTErrorStream_abort,
    HTErrorStream_put_character,
    HTErrorStream_put_string,
    HTErrorStream_write
};

HTStream *HTErrorStream(void)
{
    CTRACE((tfp, "ErrorStream. Created\n"));
    HTBaseStreamInstance.isa = &HTErrorStreamClass;	/* The rest is random */
    return &HTBaseStreamInstance;
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTFormat.c,v 1.68 2009/05/10 23:07:26 tom Exp $
d16 2
a61 7
#ifdef ORIGINAL
struct _HTStream {
    const HTStreamClass *isa;
    /* ... */
};
#endif /* ORIGINAL */

d99 3
d151 3
a153 3
		     float quality,
		     float secs,
		     float secs_per_byte,
d162 2
d176 3
a178 3
    pres->quality = quality;
    pres->secs = secs;
    pres->secs_per_byte = secs_per_byte;
d331 1
a331 1
    char *cp = strchr(trial_type, '/');
d341 1
a341 1
    if (!strncmp(trial_type, target, (cp - trial_type) - 1))
d501 1
a501 1
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s (%s)\n",
a505 8
    /* don't return on WWW_SOURCE some people might like
     * to make use of the source!!!!  LJM
     */
#if 0
    if (rep_out == WWW_SOURCE || rep_out == rep_in)
	return sink;		/*  LJM */
#endif

d601 1
a601 1
		   float initial_value,
d621 1
a621 1
		float value = initial_value * pres->quality;
d624 4
a627 2
		    value = value - (length * pres->secs_per_byte + pres->secs)
			/ HTMaxSecs;
d737 3
a739 1
    int bytes;
d751 1
a751 1
    HTReadProgress(bytes = 0, 0);
a818 1
		    status = 0;
d872 7
a878 2
	(*targetClass.put_block) (sink, input_buffer, status);
	bytes += status;
d880 1
a880 1
	    HTReadProgress(bytes, anchor ? anchor->content_length : 0);
d884 6
d923 2
a924 1
    int status, bytes;
d933 1
a933 1
    HTReadProgress(bytes = 0, 0);
d935 3
a937 1
	status = fread(input_buffer, 1, INPUT_BUFFER_SIZE, fp);
d955 1
a955 1
	HTReadProgress(bytes, 0);
d999 1
a999 1
    int bytes = 0;
d1003 1
a1003 1
    HTReadProgress(0, 0);
d1012 1
a1012 1
	HTReadProgress(bytes, 0);
d1055 2
a1056 1
    int status, bytes;
d1066 1
a1066 1
    HTReadProgress(bytes = 0, 0);
d1092 1
a1092 1
	HTReadProgress(bytes, -1);
d1097 1
a1097 5
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
d1148 1
a1148 1
    int bytes;
d1175 1
a1175 1
    HTReadProgress(bytes = 0, 0);
d1179 4
a1182 1
	    len = s.avail_in = fread(input_buffer, 1, INPUT_BUFFER_SIZE, zzfp);
d1186 1
a1186 1
	    len = sizeof(output_buffer) - s.avail_out;
d1190 1
a1190 1
		HTReadProgress(bytes, -1);
d1199 1
a1199 1
		rv = bytes ? HT_PARTIAL_CONTENT : -1;
d1204 1
a1204 1
	    status = inflate(&s, flush);
d1206 1
a1206 1
	    s.avail_in = len;
d1219 1
a1219 1
	    HTReadProgress(bytes, -1);
d1261 2
a1262 1
    int status, bytes;
d1272 1
a1272 1
    HTReadProgress(bytes = 0, 0);
d1294 1
a1294 1
	HTReadProgress(bytes, -1);
d1299 1
a1299 5
	    if (bytes) {
		rv = HT_INTERRUPTED;
	    } else {
		rv = -1;
	    }
d1342 1
a1342 1
	(*targetClass.put_character) (sink, UCH(character));
d1449 1
d1451 4
a1454 2
    if (fp == NULL)
	return HT_LOADED;
d1456 15
a1470 1
    stream = HTStreamStack(rep_in, format_out, sink, anchor);
d1472 14
a1485 2
    if (!stream) {
	char *buffer = 0;
d1487 7
a1493 3
	if (LYCancelDownload) {
	    LYCancelDownload = FALSE;
	    return -1;
a1494 6
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
d1496 1
a1496 22

    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTFileCopy(fp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
    }

    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
d1525 1
d1528 1
a1528 1
    if (!stream) {
d1536 9
a1544 1
	return rv;
d1546 1
a1546 7

    /* Push the data down the stream
     */
    targetClass = *(stream->isa);
    rv = HTMemCopy(chunk, stream);
    (*targetClass._free) (stream);
    return HT_LOADED;
d1593 1
d1597 1
a1597 1
    if (!stream) {
d1603 24
a1626 1
	    return -1;
a1627 7
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }
d1629 8
a1636 13
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTGzFileCopy(gzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
d1638 1
a1638 8

    HTCloseGzFile(gzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
d1666 1
d1670 1
a1670 1
    if (!stream) {
d1676 24
a1699 1
	    return -1;
a1700 7
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseGzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }
d1702 8
a1709 13
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTZzFileCopy(zzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
d1711 1
a1711 8

    fclose(zzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
d1747 1
d1751 1
a1751 1
    if (!stream) {
d1757 24
a1780 1
	    return -1;
a1781 7
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(rep_in), HTAtom_name(format_out));
	CTRACE((tfp, "HTFormat(in HTParseBzFile): %s\n", buffer));
	rv = HTLoadError(sink, 501, buffer);
	FREE(buffer);
	return rv;
    }
d1783 8
a1790 13
    /*
     * Push the data down the stream
     *
     * @@@@ Bug:  This decision ought to be made based on "encoding" rather than
     * on content-type.  @@@@@@ When we handle encoding.  The current method
     * smells anyway.
     */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTBzFileCopy(bzfp, stream);
    if (rv == -1 || rv == HT_INTERRUPTED) {
	(*targetClass._abort) (stream, NULL);
    } else {
	(*targetClass._free) (stream);
d1792 1
a1792 8

    HTCloseBzFile(bzfp);
    if (rv == -1)
	return HT_NO_DATA;
    else if (rv == HT_INTERRUPTED || (rv > 0 && rv != HT_LOADED))
	return HT_PARTIAL_CONTENT;
    else
	return HT_LOADED;
d1806 1
a1806 1
static void NetToText_put_character(HTStream *me, char net_char)
d1808 1
a1808 1
    char c = FROMASCII(net_char);
d1872 3
d1890 1
a1890 1
static void HTErrorStream_put_character(HTStream *me GCC_UNUSED, char c GCC_UNUSED)
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		Manage different file formats			HTFormat.c
d104 8
d164 7
d291 1
a291 1
char HTGetSSLCharacter(void *handle)
d399 3
a401 2
		CTRACE((tfp, "FindPresentation: found exact match: %s\n",
			HTAtom_name(pres->rep)));
d416 3
a418 2
			    "StreamStack: found strong wildcard match: %s\n",
			    HTAtom_name(pres->rep)));
d434 3
a436 2
			"StreamStack: found strong subtype wildcard match: %s\n",
			HTAtom_name(pres->rep)));
d521 3
a523 2
	    CTRACE((tfp, "StreamStack: found exact match: %s\n",
		    HTAtom_name(match->rep)));
d631 1
a631 1
		if (HTMaxSecs != 0.0)
a823 1
		    break;
a831 1
		    break;
d864 3
a866 3
	suppress_readprogress = (anchor && anchor->content_type &&
				 !strcmp(anchor->content_type,
					 "message/x-http-redirection"));
d1105 1
d1160 1
a1160 1
	exit_immediately(1);
a1443 1
#ifdef SH_EX			/* 1998/01/04 (Sun) 16:04:09 */
a1445 1
#endif
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 10
a11 10
**		=============================
**
** Bugs:
**	Not reentrant.
**
**	Assumes the incoming stream is ASCII, rather than a local file
**	format, and so ALWAYS converts from ASCII on non-ASCII machines.
**	Therefore, non-ASCII machines can't read local files.
**
*/
d19 1
a19 3
PUBLIC float HTMaxSecs = 1e10;		/* No effective limit */
PUBLIC float HTMaxLength = 1e10;	/* No effective limit */
PUBLIC long int HTMaxBytes  = 0;	/* No effective limit */
d55 1
a55 1
PUBLIC	BOOL HTOutputSource = NO;	/* Flag: shortcut parser to stdout */
d59 2
a60 2
      CONST HTStreamClass*	isa;
      /* ... */
d66 3
a68 3
	CONST HTStreamClass *	isa;
	BOOL			had_cr;
	HTStream *		sink;
d72 4
a75 4
**	--------------------
*/
PUBLIC	HTList * HTPresentations = NULL;
PUBLIC	HTPresentation * default_presentation = NULL;
d81 1
a81 1
PRIVATE void HTFreePresentations NOPARAMS;
d85 10
a94 9
**	-------------------------------------------------------
*/
PUBLIC void HTSetPresentation ARGS6(
	CONST char *,	representation,
	CONST char *,	command,
	double,		quality,
	double,		secs,
	double,		secs_per_byte,
	long int,	maxbytes)
d96 2
a97 1
    HTPresentation * pres = typecalloc(HTPresentation);
d102 2
a103 2
    pres->rep_out = WWW_PRESENT;		/* Fixed for now ... :-) */
    pres->converter = HTSaveAndExecute;		/* Fixed for now ...	 */
d108 3
d114 3
d118 2
a119 2
     *	Memory leak fixed.
     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d121 1
a121 1
    if (!HTPresentations)	{
d128 1
a128 1
    if (strcmp(representation, "*")==0) {
d137 10
a146 10
**	---------------------------------------------
*/
PUBLIC void HTSetConversion ARGS7(
	CONST char *,	representation_in,
	CONST char *,	representation_out,
	HTConverter*,	converter,
	float,		quality,
	float,		secs,
	float,		secs_per_byte,
	long int,	maxbytes)
d148 2
a149 1
    HTPresentation * pres = typecalloc(HTPresentation);
d156 2
a157 1
    pres->command = NULL;		/* Fixed */
d162 2
a163 1
    pres->command = NULL;
d166 2
a167 2
     *	Memory Leak fixed.
     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d169 1
a169 1
    if (!HTPresentations)	{
d181 9
a189 9
**	Purpose:	Free the presentation list.
**	Arguments:	void
**	Return Value:	void
**	Remarks/Portability/Dependencies/Restrictions:
**		Made to clean up Lynx's bad leakage.
**	Revision History:
**		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void HTFreePresentations NOARGS
d191 1
a191 1
    HTPresentation * pres = NULL;
d194 1
a194 1
     *	Loop through the list.
d198 2
a199 3
	 *  Free off each item.
	 *  May also need to free off it's items, but not sure
	 *  as of yet.
d201 1
a201 1
	pres = (HTPresentation *)HTList_removeLastObject(HTPresentations);
d203 1
d207 1
a207 1
     *	Free the list itself.
d215 12
a226 12
**	--------------
**
**	The input file is read using the macro which can read from
**	a socket or a file.
**	The input buffer size, if large will give greater efficiency and
**	release the server faster, and if small will save space on PCs etc.
*/
#define INPUT_BUFFER_SIZE 4096		/* Tradeoff */
PRIVATE char input_buffer[INPUT_BUFFER_SIZE];
PRIVATE char * input_pointer;
PRIVATE char * input_limit;
PRIVATE int input_file_number;
d229 6
a234 6
**
**	These routines are public because they are in fact needed by
**	many parsers, and on PCs and Macs we should not duplicate
**	the static buffer area.
*/
PUBLIC void HTInitInput ARGS1 (int,file_number)
d240 2
a241 2
PUBLIC int interrupted_in_htgetcharacter = 0;
PUBLIC int HTGetCharacter NOARGS
d244 1
d250 1
d260 2
a261 2
		return EOF; /* -1 is returned by UCX
			       at end of HTTP link */
d267 1
a267 1
    } while (ch == (char) 13); /* Ignore ASCII carriage return */
d273 1
a273 1
PUBLIC char HTGetSSLCharacter ARGS1(void *, handle)
d276 1
d278 2
a279 2
    if(!handle)
	return (char)EOF;
d282 3
a284 2
	    int status = SSL_read((SSL *)handle,
				 input_buffer, INPUT_BUFFER_SIZE);
d287 1
a287 1
		    return (char)EOF;
d289 2
a290 1
		    CTRACE((tfp, "HTFormat: Interrupted in HTGetSSLCharacter\n"));
d292 1
a292 1
		    return (char)EOF;
d295 2
a296 2
		return (char)EOF; /* -1 is returned by UCX
				     at end of HTTP link */
d302 1
a302 1
    } while (ch == (char) 13); /* Ignore ASCII carriage return */
d308 2
a309 2
/*  Match maintype to any MIME type starting with maintype,
 *  for example:  image/gif should match image
d311 1
a311 1
PRIVATE int half_match ARGS2(char *,trial_type, char *,target)
d316 1
a316 1
    if (!cp || *(cp+1) != '*')
d320 1
a320 1
		trial_type, target));
d322 2
a323 2
	/* main type matches */
    if (!strncmp(trial_type, target, (cp-trial_type)-1))
d329 14
d346 24
a369 16
**		----------------------
**
**	If fill_in is NULL, only look for an exact match.
**	If a wildcard match is made, *fill_in is used to store
**	a possibly modified presentation, and a pointer to it is
**	returned.  For an exact match, a pointer to the presentation
**	in the HTPresentations list is returned.  Returns NULL if
**	nothing found. - kw
**
*/
PRIVATE HTPresentation * HTFindPresentation ARGS3(
	HTFormat,		rep_in,
	HTFormat,		rep_out,
	HTPresentation*,	fill_in)
{
    HTAtom * wildcard = NULL; /* = HTAtom_for("*"); lookup when needed - kw */
d372 1
a372 1
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d374 6
a379 21
    /* don't do anymore do it in the Lynx code at startup LJM */
    /* if (!HTPresentations) HTFormatInit(); */ /* set up the list */

    {
	int n = HTList_count(HTPresentations);
	int i;
	HTPresentation * pres, *match,
			*strong_wildcard_match=0,
			*weak_wildcard_match=0,
			*last_default_match=0,
			*strong_subtype_wildcard_match=0;

	for (i = 0; i < n; i++) {
	    pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
	    if (pres->rep == rep_in) {
		if (pres->rep_out == rep_out) {
		    CTRACE((tfp, "FindPresentation: found exact match: %s\n",
				HTAtom_name(pres->rep)));
		    return pres;

		} else if (!fill_in) {
d381 3
a383 10
		} else {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard) {
			if (!strong_wildcard_match)
			    strong_wildcard_match = pres;
			/* otherwise use the first one */
			CTRACE((tfp, "StreamStack: found strong wildcard match: %s\n",
				    HTAtom_name(pres->rep)));
		    }
		}
d387 8
a394 6

	    } else if (half_match(HTAtom_name(pres->rep),
					      HTAtom_name(rep_in))) {
		if (pres->rep_out == rep_out) {
		    if (!strong_subtype_wildcard_match)
			strong_subtype_wildcard_match = pres;
d396 3
a398 2
		    CTRACE((tfp, "StreamStack: found strong subtype wildcard match: %s\n",
				HTAtom_name(pres->rep)));
d402 16
a417 7
	    if (pres->rep == WWW_SOURCE) {
		if (pres->rep_out == rep_out) {
		    if (!weak_wildcard_match)
			weak_wildcard_match = pres;
		    /* otherwise use the first one */
		    CTRACE((tfp, "StreamStack: found weak wildcard match: %s\n",
				HTAtom_name(pres->rep_out)));
d419 18
a436 4
		} else if (!last_default_match) {
		    if (!wildcard) wildcard = WWW_WILDCARD_REP_OUT;
		    if (pres->rep_out == wildcard)
			 last_default_match = pres;
d441 1
d443 13
a455 11
	match = strong_subtype_wildcard_match ? strong_subtype_wildcard_match :
		strong_wildcard_match ? strong_wildcard_match :
		weak_wildcard_match ? weak_wildcard_match :
		last_default_match;

	if (match) {
	    *fill_in = *match;		/* Specific instance */
	    fill_in->rep = rep_in;		/* yuk */
	    fill_in->rep_out = rep_out; /* yuk */
	    return fill_in;
	}
d462 13
a474 14
**		---------------------
**
**	If a wildcard match is made, a temporary HTPresentation
**	structure is made to hold the destination format while the
**	new stack is generated. This is just to pass the out format to
**	MIME so far.  Storing the format of a stream in the stream might
**	be a lot neater.
**
*/
PUBLIC HTStream * HTStreamStack ARGS4(
	HTFormat,		rep_in,
	HTFormat,		rep_out,
	HTStream*,		sink,
	HTParentAnchor*,	anchor)
d480 4
a483 2
    CTRACE((tfp, "HTFormat: Constructing stream stack for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out)));
d490 1
a490 1
	return sink;	/*  LJM */
d496 1
a496 1
    } else if ((match = HTFindPresentation(rep_in, rep_out, &temp))) {
d501 1
a501 1
			HTAtom_name(match->rep)));
d503 1
a503 1
	result = (*match->converter)(match, anchor, sink);
d521 7
a527 8
**		-------------------------------------
**
**	Look up a presentation (exact match only) and, if found, reorder
**	it to the start of the HTPresentations list. - kw
*/
PUBLIC void HTReorderPresentation ARGS2(
	HTFormat,		rep_in,
	HTFormat,		rep_out)
d530 2
a531 1
    if ((match = HTFindPresentation(rep_in, rep_out, NULL))) {
d541 1
a541 1
PUBLIC void HTFilterPresentations NOARGS
d547 1
a547 1
    char *s, *t, *x, *y;
d549 1
d551 1
a551 1
	p = (HTPresentation *)HTList_objectAt(HTPresentations, i);
d554 16
a569 25
	if (p->rep_out == WWW_PRESENT) {
	    if (p->rep != WWW_SOURCE
	     && strcasecomp(s, "www/mime")
	     && strcasecomp(s, "www/compressed")
	     && p->quality <= 1.0 && p->quality >= 0.0) {
		for (j = 0, matched = FALSE; j < i; j++) {
		    q = (HTPresentation *)HTList_objectAt(HTPresentations, j);
		    t = HTAtom_name(q->rep);

		    if (!strcasecomp(s, t)) {
			matched = TRUE;
			break;
		    }
		    if ((x = strchr(s, '/')) != 0
		     && (y = strchr(t, '/')) != 0) {
			int len1 = x++ - s;
			int len2 = y++ - t;
			int lens = (len1 > len2) ? len1 : len2;

			if ((*t == '*' || !strncasecomp(s, t, lens))
			 && (*y == '*' || !strcasecomp(x, y))) {
			    matched = TRUE;
			    break;
			}
		    }
a570 2
		if (!matched)
		    p->get_accept = TRUE;
d572 1
d578 11
a588 12
**		-------------------------------
**
**	Must return the cost of the same stack which StreamStack would set up.
**
** On entry,
**	length	The size of the data to be converted
*/
PUBLIC float HTStackValue ARGS4(
	HTFormat,		rep_in,
	HTFormat,		rep_out,
	float,			initial_value,
	long int,		length)
d590 1
a590 1
    HTAtom * wildcard = WWW_WILDCARD_REP_OUT;
d593 1
a593 1
		HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out)));
a597 3
    /* don't do anymore do it in the Lynx code at startup LJM */
    /* if (!HTPresentations) HTFormatInit(); */ /* set up the list */

d601 2
a602 1
	HTPresentation * pres;
d604 1
a604 1
	    pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
d608 1
d610 2
a611 2
		    value = value - (length*pres->secs_per_byte + pres->secs)
					 /HTMaxSecs;
d622 7
a628 7
**	-------------------------------------------
**
**   Repaint the page only when necessary.
**   This is a traverse call for HText_pageDisplay() - it works!.
**
*/
PUBLIC void HTDisplayPartial NOARGS
d633 15
a647 15
	**  HText_getNumOfLines() = "current" number of complete lines received
	**  NumOfLines_partial = number of lines at the moment of last repaint.
	**  (we update NumOfLines_partial only when we repaint the display.)
	**
	**  display_partial could only be enabled in HText_new()
	**  so a new HTMainText object available - all HText_ functions use it,
	**  lines counter HText_getNumOfLines() in particular.
	**
	**  Otherwise HTMainText holds info from the previous document
	**  and we may repaint it instead of the new one:
	**  prev doc scrolled to the first line (=Newline_partial)
	**  is not good looking :-)	  23 Aug 1998 Leonid Pauzner
	**
	**  So repaint the page only when necessary:
	*/
d651 4
a654 3
		/* current page not complete... */
	&& (partial_threshold > 0 ?
		((Newline_partial + partial_threshold) -1 <= HText_getNumOfLines()) :
d656 7
a662 7
		/*
		 * Originally we rendered by increments of 2 lines,
		 * but that got annoying on slow network connections.
		 * Then we switched to full-pages.  Now it's configurable.
		 * If partial_threshold <= 0, then it's a full page
		 */
	) {
d668 1
a668 1
#endif  /* DISP_PARTIAL */
d672 1
a672 1
PUBLIC void HTFinishDisplayPartial NOARGS
d675 4
a678 4
		    /*
		     *  End of incremental rendering stage here.
		     */
		    display_partial = FALSE;
d683 35
a717 36
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**   The file number given is assumed to be a TELNET stream, i.e., containing
**   CRLF at the end of lines which need to be stripped to LF for unix
**   when the format is textual.
**
**  State of socket and target stream on entry:
**			socket (file_number) assumed open,
**			target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption or error after some data received.
**	-2		Unexpected disconnect before any data received.
**	-1		Interruption or error before any data received, or
**			(UNIX) other read error before any data received, or
**			download cancelled.
**	HT_LOADED	Normal close of socket (end of file indication
**			received), or
**			unexpected disconnect after some data received, or
**			other read error after some data received, or
**			(not UNIX) other read error before any data received.
**
**  State of socket and target stream on return depends on return value:
**	HT_INTERRUPTED	socket still open, target aborted.
**	-2		socket still open, target stream still valid.
**	-1		socket still open, target aborted.
**	otherwise	socket closed,	target stream still valid.
*/
PUBLIC int HTCopy ARGS4(
	HTParentAnchor *,	anchor,
	int,			file_number,
	void*,			handle GCC_UNUSED,
	HTStream*,		sink)
d724 9
a732 8
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */

    /*	Push binary from socket down sink
    **
    **	This operation could be put into a main event loop
    */
d739 1
a739 1
	    (*targetClass._abort)(sink, NULL);
d745 2
a746 2
	    _HTProgress (TRANSFER_INTERRUPTED);
	    (*targetClass._abort)(sink, NULL);
a752 1

d755 1
a755 1
	    status = SSL_read((SSL *)handle, input_buffer, INPUT_BUFFER_SIZE);
d766 2
a767 2
		_HTProgress (TRANSFER_INTERRUPTED);
		(*targetClass._abort)(sink, NULL);
d774 1
a774 1
#ifdef _WINDOWS	/* 1997/11/10 (Mon) 16:57:18 */
d780 1
a780 1
		 *  Arrrrgh, HTTP 0/1 compatibility problem, maybe.
d784 2
a785 2
		     *	Don't have any data, so let the calling
		     *	function decide what to do about it. - FM
d791 21
a811 22
		   /*
		    *  Treat what we've received already as the complete
		    *  transmission, but not without giving the user
		    *  an alert.  I don't know about all the different
		    *  TCP stacks for VMS etc., so this is currently
		    *  only for UNIX. - kw
		    */
		   HTInetStatus("NETREAD");
		   HTAlert("Unexpected server disconnect.");
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n"));
		   status = 0;
		   break;
#else  /* !UNIX */
		   /*
		    *  Treat what we've gotten already
		    *  as the complete transmission. - FM
		    */
		   CTRACE((tfp,
	    "HTCopy: Unexpected server disconnect.  Treating as completed.\n"));
		   status = 0;
		   break;
d817 4
a820 5
		 *  Treat what we've received already as the complete
		 *  transmission, but not without giving the user
		 *  an alert.  I don't know about all the different
		 *  TCP stacks for VMS etc., so this is currently
		 *  only for UNIX. - kw
d825 1
a825 1
		    (void)NETCLOSE(file_number);
d828 1
a828 1
		    (*targetClass._abort)(sink, NULL);
d838 5
a842 5
	 *  Suppress ReadProgress messages when collecting a redirection
	 *  message, at least initially (unless/until anchor->content_type
	 *  gets changed, probably by the MIME message parser).  That way
	 *  messages put up by the HTTP module or elsewhere can linger in
	 *  the statusline for a while. - kw
d849 3
a851 2
	    char * p;
	    for (p = input_buffer; p < input_buffer+status; p++) {
d857 1
a857 1
	(*targetClass.put_block)(sink, input_buffer, status);
d863 1
a863 1
    } /* next bufferload */
d866 1
a866 1
    (void)NETCLOSE(file_number);
d869 1
a869 1
finished:
d871 1
a871 1
    return(rv);
d875 20
a894 22
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**			FILE* (fp) assumed open,
**			target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		fp still open, target stream still valid.
*/
PUBLIC int HTFileCopy ARGS2(
	FILE *,			fp,
	HTStream*,		sink)
d900 3
a902 3
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */
d904 2
a905 2
    /*	Push binary from socket down sink
    */
d909 1
a909 1
	if (status == 0) { /* EOF or error */
d915 1
a915 1
			ferror(fp)));
d924 1
a924 1
	(*targetClass.put_block)(sink, input_buffer, status);
d927 2
a928 2
	/*  Suppress last screen update in partial mode - a regular update
	 *  under control of mainloop() should follow anyway. - kw
d936 1
a936 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d944 1
a944 1
    } /* next bufferload */
d952 16
a967 18
**	---------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**  State of memory and target stream on entry:
**			HTChunk* (chunk) and target (sink) assumed valid.
**
**  Return values:
**	HT_LOADED	All data sent.
**	HT_INTERRUPTED  Interruption after some data read.
**
**  State of memory and target stream on return:
**	always		chunk unchanged, target stream still valid.
*/
PUBLIC int HTMemCopy ARGS2(
	HTChunk *,		chunk,
	HTStream *,		sink)
a970 1
    CONST char *data = chunk->data;
d975 2
a976 1
    for (;;) {
d978 5
a982 10
	** running a large document on a slow machine.
	*/
	int n = INPUT_BUFFER_SIZE;
	if (n > chunk->size - bytes)
	    n = chunk->size - bytes;
	if (n == 0)
	    break;
	(*targetClass.put_block)(sink, data, n);
	bytes += n;
	data += n;
d987 1
a987 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d1004 20
a1023 22
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**		      gzFile (gzfp) assumed open (should have gzipped content),
**		      target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		gzfp still open, target stream still valid.
*/
PRIVATE int HTGzFileCopy ARGS2(
	gzFile,			gzfp,
	HTStream*,		sink)
d1030 3
a1032 3
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */
d1034 2
a1035 2
    /*	read and inflate gzip'd file, and push binary down sink
    */
d1039 1
a1039 1
	if (status <= 0) { /* EOF or error */
d1045 1
a1045 1
			status));
d1047 1
a1047 1
			gzerror(gzfp, &gzerrnum)));
d1060 1
a1060 1
	(*targetClass.put_block)(sink, input_buffer, status);
d1066 1
a1066 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d1074 126
a1199 1
    } /* next bufferload */
d1201 1
d1209 20
a1228 22
**	-------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**
**  State of file and target stream on entry:
**		      BZFILE (bzfp) assumed open (should have bzipped content),
**		      target (sink) assumed valid.
**
**  Return values:
**	HT_INTERRUPTED  Interruption after some data read.
**	HT_PARTIAL_CONTENT	Error after some data read.
**	-1		Error before any data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		bzfp still open, target stream still valid.
*/
PRIVATE int HTBzFileCopy ARGS2(
	BZFILE *,		bzfp,
	HTStream*,		sink)
d1235 3
a1237 3
    /*	Push the data down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */
d1239 2
a1240 2
    /*	read and inflate bzip'd file, and push binary down sink
    */
d1244 1
a1244 1
	if (status <= 0) { /* EOF or error */
d1250 1
a1250 1
			status));
d1252 1
a1252 1
			BZ2_bzerror(bzfp, &bzerrnum)));
d1261 1
a1261 1
	(*targetClass.put_block)(sink, input_buffer, status);
d1267 1
a1267 1
	    _HTProgress (TRANSFER_INTERRUPTED);
d1275 1
a1275 1
    } /* next bufferload */
d1283 13
a1295 14
**	--------------------------------------------------
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the socket.
**
**   The file number given is assumed to be a TELNET stream ie containing
**   CRLF at the end of lines which need to be stripped to LF for unix
**   when the format is textual.
**
*/
PUBLIC void HTCopyNoCR ARGS3(
	HTParentAnchor *,	anchor GCC_UNUSED,
	int,			file_number,
	HTStream*,		sink)
d1300 10
a1309 9
    /*	Push the data, ignoring CRLF, down the stream
    */
    targetClass = *(sink->isa); /* Copy pointers to procedures */

    /*	Push text from telnet socket down sink
    **
    **	@@@@@@@@@@ To push strings could be faster? (especially is we
    **	cheat and don't ignore CR! :-}
    */
d1315 1
a1315 1
	(*targetClass.put_character)(sink, UCH(character));
d1320 38
a1357 39
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**   The file number given is assumed to be a TELNET stream ie containing
**   CRLF at the end of lines which need to be stripped to LF for unix
**   when the format is textual.
**
**  State of socket and target stream on entry:
**			socket (file_number) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	HT_INTERRUPTED  Interruption or error after some data received.
**	-501		Stream stack failed (cannot present or convert).
**	-2		Unexpected disconnect before any data received.
**	-1		Stream stack failed (cannot present or convert), or
**			Interruption or error before any data received, or
**			(UNIX) other read error before any data received, or
**			download cancelled.
**	HT_LOADED	Normal close of socket (end of file indication
**			received), or
**			unexpected disconnect after some data received, or
**			other read error after some data received, or
**			(not UNIX) other read error before any data received.
**
**  State of socket and target stream on return depends on return value:
**	HT_INTERRUPTED	socket still open, target aborted.
**	-501		socket still open, target stream NULL.
**	-2		socket still open, target freed.
**	-1		socket still open, target stream aborted or NULL.
**	otherwise	socket closed,	target stream freed.
*/
PUBLIC int HTParseSocket ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	int,			file_number,
	HTStream*,		sink)
d1359 1
a1359 1
    HTStream * stream;
d1367 1
d1373 1
a1373 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1375 1
a1375 1
	rv = HTLoadError(sink, 501, buffer); /* returns -501 */
d1379 2
a1380 2
	** Push the data, don't worry about CRLF we can strip them later.
	*/
d1384 1
a1384 1
	    (*targetClass._free)(stream);
d1391 27
a1417 28
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**   The file number given is assumed to be a TELNET stream ie containing
**   CRLF at the end of lines which need to be stripped to \n for unix
**   when the format is textual.
**
**  State of file and target stream on entry:
**			FILE* (fp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		fp still open; target freed, aborted, or NULL.
*/
PUBLIC int HTParseFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	FILE *,			fp,
	HTStream*,		sink)
d1419 1
a1419 1
    HTStream * stream;
d1423 1
a1423 1
#ifdef SH_EX		/* 1998/01/04 (Sun) 16:04:09 */
d1432 1
d1438 1
a1438 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1445 7
a1451 6
    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
d1455 1
a1455 1
	(*targetClass._abort)(stream, NULL);
d1457 1
a1457 1
	(*targetClass._free)(stream);
d1470 20
a1489 21
**
**   This routine is responsible for creating and PRESENTING any
**   graphic (or other) objects described by the file.
**
**  State of memory and target stream on entry:
**			HTChunk* (chunk) assumed valid,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	HT_LOADED	All data sent.
**
**  State of memory and target stream on return:
**	always		chunk unchanged; target freed, aborted, or NULL.
*/
PUBLIC int HTParseMem ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	HTChunk *,		chunk,
	HTStream *,		sink)
d1491 1
a1491 1
    HTStream * stream;
d1498 1
d1508 1
a1508 1
    */
d1511 1
a1511 1
    (*targetClass._free)(stream);
d1517 1
a1517 2
PRIVATE int HTCloseGzFile ARGS1(
	gzFile,			gzfp)
d1520 1
d1531 1
a1531 1
    return(gzres);
d1535 20
a1554 21
**
**  State of file and target stream on entry:
**			gzFile (gzfp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		gzfp closed; target freed, aborted, or NULL.
*/
PUBLIC int HTParseGzFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	gzFile,			gzfp,
	HTStream*,		sink)
d1556 1
a1556 1
    HTStream * stream;
d1564 1
d1571 1
a1571 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1578 7
a1584 6
    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
d1588 1
a1588 1
	(*targetClass._abort)(stream, NULL);
d1590 1
a1590 1
	(*targetClass._free)(stream);
d1601 68
d1672 1
a1672 2
PRIVATE void HTCloseBzFile ARGS1(
	BZFILE *,		bzfp)
d1679 20
a1698 21
**
**  State of file and target stream on entry:
**			bzFile (bzfp) assumed open,
**			target (sink) usually NULL (will call stream stack).
**
**  Return values:
**	-501		Stream stack failed (cannot present or convert).
**	-1		Download cancelled.
**	HT_NO_DATA	Error before any data read.
**	HT_PARTIAL_CONTENT	Interruption or error after some data read.
**	HT_LOADED	Normal end of file indication on reading.
**
**  State of file and target stream on return:
**	always		bzfp closed; target freed, aborted, or NULL.
*/
PUBLIC int HTParseBzFile ARGS5(
	HTFormat,		rep_in,
	HTFormat,		format_out,
	HTParentAnchor *,	anchor,
	BZFILE*,		bzfp,
	HTStream*,		sink)
d1700 1
a1700 1
    HTStream * stream;
d1708 1
d1715 1
a1715 1
		HTAtom_name(rep_in), HTAtom_name(format_out));
d1722 7
a1728 6
    /*	Push the data down the stream
    **
    **	@@@@  Bug:  This decision ought to be made based on "encoding"
    **	rather than on content-type.  @@@@@@  When we handle encoding.
    **	The current method smells anyway.
    */
d1732 1
a1732 1
	(*targetClass._abort)(stream, NULL);
d1734 1
a1734 1
	(*targetClass._free)(stream);
d1748 8
a1755 8
**	-----------------------------------------------------------
**
**	The input is assumed to be in ASCII, with lines delimited
**	by (13,10) pairs, These pairs are converted into (CR,LF)
**	pairs in the local representation.  The (CR,LF) sequence
**	when found is changed to a '\n' character, the internal
**	C representation of a new line.
*/
d1757 1
a1757 1
PRIVATE void NetToText_put_character ARGS2(HTStream *, me, char, net_char)
d1760 1
d1767 1
a1767 1
	    me->sink->isa->put_character(me->sink, CR); /* leftover */
d1772 1
a1772 1
	me->sink->isa->put_character(me->sink, c);		/* normal */
d1775 1
a1775 1
PRIVATE void NetToText_put_string ARGS2(HTStream *, me, CONST char *, s)
d1777 1
a1777 1
    CONST char * p;
d1783 1
a1783 1
PRIVATE void NetToText_put_block ARGS3(HTStream *, me, CONST char*, s, int, l)
d1785 1
a1785 1
    CONST char * p;
d1787 1
a1787 1
    for (p = s; p < (s+l); p++)
d1791 1
a1791 1
PRIVATE void NetToText_free ARGS1(HTStream *, me)
d1793 1
a1793 1
    (me->sink->isa->_free)(me->sink);		/* Close rest of pipe */
d1797 1
a1797 1
PRIVATE void NetToText_abort ARGS2(HTStream *, me, HTError, e)
d1799 1
a1799 1
    me->sink->isa->_abort(me->sink,e);		/* Abort rest of pipe */
d1805 2
a1806 1
PRIVATE HTStreamClass NetToTextClass = {
d1817 1
a1817 1
PUBLIC HTStream * HTNetToText ARGS1(HTStream *, sink)
d1819 1
a1819 1
    HTStream* me = typecalloc(HTStream);
d1830 2
a1831 1
PRIVATE HTStream	HTBaseStreamInstance;		      /* Made static */
d1833 6
a1838 6
**	ERROR STREAM
**	------------
**	There is only one error stream shared by anyone who wants a
**	generic error returned from all stream methods.
*/
PRIVATE void HTErrorStream_put_character ARGS2(HTStream *, me GCC_UNUSED, char, c GCC_UNUSED)
d1843 1
a1843 1
PRIVATE void HTErrorStream_put_string ARGS2(HTStream *, me GCC_UNUSED, CONST char *, s)
d1849 1
a1849 1
PRIVATE void HTErrorStream_write ARGS3(HTStream *, me GCC_UNUSED, CONST char *, s, int, l)
d1855 1
a1855 1
PRIVATE void HTErrorStream_free ARGS1(HTStream *, me GCC_UNUSED)
d1860 1
a1860 1
PRIVATE void HTErrorStream_abort ARGS2(HTStream *, me GCC_UNUSED, HTError, e GCC_UNUSED)
d1865 1
a1865 1
PRIVATE CONST HTStreamClass HTErrorStreamClass =
d1875 1
a1875 1
PUBLIC HTStream * HTErrorStream NOARGS
d1878 1
a1878 1
    HTBaseStreamInstance.isa = &HTErrorStreamClass;    /* The rest is random */
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a57 1
/* extern  BOOL interactive; LJM */
d629 2
a630 2
	    NumOfLines_partial = HText_getNumOfLines();
	    LYMainLoop_pageDisplay(Newline_partial);
a689 6
#ifdef _WINDOWS	/* 1997/11/11 (Tue) 15:18:16 */
    long file_length;
    extern int bytes_already_read;

    file_length = anchor->content_length;
#endif
d920 1
a920 1
#ifdef SOURCE_CACHE
d1060 77
d1322 1
a1322 1
#ifdef SOURCE_CACHE
d1455 76
@


1.3
log
@a little bit of glue to call openssl; mark@@moxienet.com
@
text
@a18 6
#ifdef USE_SSL
#define free_func free__func
#include <openssl/ssl.h>
#undef free_func
#endif /* USE_SSL */

d23 1
a23 1
#ifdef unix
d30 1
a30 1
#endif /* unix */
d39 1
d53 4
d93 3
a95 3
	float,		quality,
	float,		secs,
	float,		secs_per_byte,
d98 1
a98 1
    HTPresentation * pres = (HTPresentation *)malloc(sizeof(HTPresentation));
d105 3
a107 3
    pres->quality = quality;
    pres->secs = secs;
    pres->secs_per_byte = secs_per_byte;
d143 1
a143 1
    HTPresentation * pres = (HTPresentation *)malloc(sizeof(HTPresentation));
d245 1
a245 1
		    CTRACE(tfp, "HTFormat: Interrupted in HTGetCharacter\n");
d249 1
a249 1
		CTRACE(tfp, "HTFormat: File read error %d\n", status);
d259 1
a259 1
    return FROMASCII((unsigned char)ch);
d277 1
a277 1
		    CTRACE(tfp, "HTFormat: Interrupted in HTGetSSLCharacter\n");
d281 1
a281 1
		CTRACE(tfp, "HTFormat: SSL_read error %d\n", status);
d300 1
a300 1
    char *cp=strchr(trial_type,'/');
d306 2
a307 2
    CTRACE(tfp, "HTFormat: comparing %s and %s for half match\n",
		trial_type, target);
d316 2
d334 1
a334 1
    HTAtom * wildcard = HTAtom_for("*");
d336 2
a337 2
    CTRACE(tfp, "HTFormat: Looking up presentation for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out));
d355 2
a356 2
		    CTRACE(tfp, "FindPresentation: found exact match: %s\n",
				HTAtom_name(pres->rep));
d361 9
a369 6
		} else if (pres->rep_out == wildcard) {
		    if (!strong_wildcard_match)
			strong_wildcard_match = pres;
		    /* otherwise use the first one */
		    CTRACE(tfp, "StreamStack: found strong wildcard match: %s\n",
				HTAtom_name(pres->rep));
d381 2
a382 2
		    CTRACE(tfp, "StreamStack: found strong subtype wildcard match: %s\n",
				HTAtom_name(pres->rep));
d391 6
a396 5
		    CTRACE(tfp, "StreamStack: found weak wildcard match: %s\n",
				HTAtom_name(pres->rep_out));
		}
		if (pres->rep_out == wildcard) {
		    if (!last_default_match)
d437 1
d439 2
a440 2
    CTRACE(tfp, "HTFormat: Constructing stream stack for %s to %s\n",
		HTAtom_name(rep_in), HTAtom_name(rep_out));
d444 2
a445 1
     *//*
d447 2
a448 1
	return sink;  LJM */
d450 2
a451 2
    if (rep_out == rep_in)
	return sink;
d453 1
a453 1
    if ((match = HTFindPresentation(rep_in, rep_out, &temp))) {
d455 1
a455 1
	    CTRACE(tfp, "StreamStack: Using %s\n", HTAtom_name(temp.rep_out));
d457 2
a458 2
	    CTRACE(tfp, "StreamStack: found exact match: %s\n",
			HTAtom_name(match->rep));
d460 1
a460 1
	return (*match->converter)(match, anchor, sink);
d462 11
a472 1
	return NULL;
d474 1
d493 50
d557 1
a557 1
    HTAtom * wildcard = HTAtom_for("*");
d559 2
a560 2
    CTRACE(tfp, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
		HTAtom_name(rep_in), initial_value, HTAtom_name(rep_out));
d585 1
a585 1
    return -1e30;		/* Really bad */
d601 1
a601 1
	**  HText_getNumOfLines() = "current" number of lines received
d603 1
d605 3
a607 5
	**  We update NumOfLines_partial only when we repaint the display.
	**  -1 is the special value:
	**  This is a synchronization flag switched to 0 when HText_new()
	**  starts a new HTMainText object - all HText_ functions use it,
	**  lines counter in particular [we call it from HText_getNumOfLines()].
d616 3
a618 3
	if ((NumOfLines_partial != -1)
		/* new HText object available  */
	&& ((Newline_partial + display_lines) > NumOfLines_partial)
d621 2
a622 2
		((Newline_partial + partial_threshold) < HText_getNumOfLines()) :
		((Newline_partial + display_lines) < HText_getNumOfLines()))
d631 1
a631 1
	    HText_pageDisplay(Newline_partial, "");
a641 10
		    if (display_partial) {
			/*
			 *  Override Newline with a new value if user
			 *  scrolled the document while downloading.
			 */
			if (Newline_partial != Newline
			 && NumOfLines_partial > 0)
			    Newline = Newline_partial;
		    }

a645 4
		    NumOfLines_partial = -1;       /* initialize to -1 */
				/* -1 restrict HTDisplayPartial()   */
				/* until HText_new() start next HTMainText */
				/* and set the flag to 0  */
d688 1
d691 6
d748 3
d772 4
a775 4
		    HTInetStatus("NETREAD");
		    HTAlert("Unexpected server disconnect.");
		   CTRACE(tfp,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n");
d783 2
a784 2
		   CTRACE(tfp,
	    "HTCopy: Unexpected server disconnect.  Treating as completed.\n");
d813 10
d834 2
a835 1
	HTReadProgress(bytes, anchor ? anchor->content_length : 0);
d891 2
a892 2
	    CTRACE(tfp, "HTFormat: Read error, read returns %d\n",
			ferror(fp));
d904 7
a910 1
	HTDisplayPartial();
d948 1
a948 1
    HTStreamClass targetClass = *(sink->isa);
d953 1
d1030 4
a1033 4
	    CTRACE(tfp, "HTGzFileCopy: Read error, gzread returns %d\n",
			status);
	    CTRACE(tfp, "gzerror   : %s\n",
			gzerror(gzfp, &gzerrnum));
d1084 1
a1084 1
    char character;
d1098 1
a1098 1
	if (character == (char)EOF)
d1100 1
a1100 1
	(*targetClass.put_character)(sink, character);
d1159 1
a1159 1
	CTRACE(tfp, "HTFormat: %s\n", buffer);
d1209 6
a1214 3
    stream = HTStreamStack(rep_in,
			format_out,
			sink , anchor);
d1224 1
a1224 1
	CTRACE(tfp, "HTFormat(in HTParseFile): %s\n", buffer);
d1266 1
a1266 1
**  Stat of memory and target stream on return:
d1285 1
a1285 1
	CTRACE(tfp, "HTFormat(in HTParseMem): %s\n", buffer);
d1312 1
a1312 1
	    CTRACE(tfp, "gzclose   : error number %d\n", gzres);
d1345 1
a1345 3
    stream = HTStreamStack(rep_in,
			format_out,
			sink , anchor);
d1356 1
a1356 1
	CTRACE(tfp, "HTFormat(in HTParseGzFile): %s\n", buffer);
d1408 1
a1408 1
    me->had_cr = (c == CR);
d1456 1
a1456 1
    HTStream* me = (HTStream*)malloc(sizeof(*me));
d1467 50
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d19 6
d263 33
d666 6
d673 1
@


1.1
log
@Initial revision
@
text
@d13 1
a13 3
#include "HTUtils.h"
#include "tcp.h"
#include "HTAccess.h"
d17 1
a17 1
#include "HTFormat.h"
d32 7
a38 7
#include "HTML.h"
#include "HTMLDTD.h"
#include "HText.h"
#include "HTAlert.h"
#include "HTList.h"
#include "HTInit.h"
#include "HTTCP.h"
d41 10
a50 14
#include "HTFWriter.h"
#include "HTPlain.h"
#include "SGML.h"
#include "HTML.h"
#include "HTMLGen.h"

#include "LYexit.h"
#include "LYUtils.h"
#include "LYGlobalDefs.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

extern int HTCheckForInterrupt NOPARAMS;
d78 1
d80 1
d99 1
a99 1
    pres->converter = HTSaveAndExecute; 	/* Fixed for now ...	 */
d113 1
d115 1
d158 1
d160 1
d166 1
d199 1
d228 1
a228 1
PUBLIC char HTGetCharacter NOARGS
d238 1
a238 1
		    return (char)EOF;
d240 1
a240 3
		    if (TRACE)
			fprintf(stderr,
				"HTFormat: Interrupted in HTGetCharacter\n");
d242 1
a242 1
		    return (char)EOF;
d244 3
a246 4
		if (TRACE)
		    fprintf(stderr, "HTFormat: File read error %d\n", status);
		return (char)EOF; /* -1 is returned by UCX
				     at end of HTTP link */
d254 1
a254 1
    return FROMASCII(ch);
d268 2
a269 3
    if (TRACE)
	fprintf(stderr,"HTFormat: comparing %s and %s for half match\n",
						      trial_type, target);
d296 1
a296 3
    if (TRACE)
	fprintf(stderr,
		"HTFormat: Looking up presentation for %s to %s\n",
d315 1
a315 3
		    if (TRACE)
			fprintf(stderr,
				"FindPresentation: found exact match: %s\n",
d325 1
a325 3
		    if (TRACE)
			fprintf(stderr,
			     "StreamStack: found strong wildcard match: %s\n",
d338 1
a338 3
		    if (TRACE)
			fprintf(stderr,
		     "StreamStack: found strong subtype wildcard match: %s\n",
d348 1
a348 3
		    if (TRACE)
			fprintf(stderr,
			    "StreamStack: found weak wildcard match: %s\n",
d394 1
a394 3
    if (TRACE)
	fprintf(stderr,
		"HTFormat: Constructing stream stack for %s to %s\n",
d408 1
a408 3
	    if (TRACE)
		fprintf(stderr,
			"StreamStack: Using %s\n", HTAtom_name(temp.rep_out));
d410 1
a410 3
	    if (TRACE)
		fprintf(stderr,
			"StreamStack: found exact match: %s\n",
d451 1
a451 3
    if (TRACE)
	fprintf(stderr,
		"HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",
d481 75
d562 1
a562 1
**   The file number given is assumed to be a TELNET stream ie containing
d566 21
d595 1
a595 2
    char line[256];
    int bytes = 0;
d606 1
d618 1
a618 1
	    _HTProgress ("Data transfer interrupted.");
d633 1
a633 1
		_HTProgress ("Data transfer interrupted.");
d644 1
a644 1
		 *  Arrrrgh, HTTP 0/1 compability problem, maybe.
d654 15
d673 2
a674 3
		   if (TRACE)
		       fprintf(stderr,
	    "HTCopy: Unexpected server disconnect. Treating as completed.\n");
d677 19
d697 2
a712 1

d714 2
a715 6
	if (anchor && anchor->content_length > 0)
	    sprintf(line, "Read %d of %d bytes of data.",
			  bytes, anchor->content_length);
	else
	    sprintf(line, "Read %d bytes of data.", bytes);
	HTProgress(line);
d719 1
a719 1
    _HTProgress("Data transfer complete");
d724 1
d735 12
d749 1
a749 1
	FILE *, 		fp,
d753 1
a753 2
    char line[256];
    int status, bytes = 0, nreads = 0, nprogr = 0;
d762 1
a764 1
	nreads++;
d770 1
a770 3
	    if (TRACE)
		fprintf(stderr,
			"HTFormat: Read error, read returns %d\n",
d779 1
d781 3
d785 4
a788 30
	bytes += status;
	if (nreads >= 100) {
	    /*
	    **	Show progress messages for local files, and check for
	    **	user interruption.  Start doing so only after a certain
	    **	number of reads have been done, and don't update it on
	    **	every read (normally reading in a local file should be
	    **	speedy). - KW
	    */
	    if (nprogr == 0) {
		if (bytes < 1024000) {
		    sprintf(line, "Read %d bytes of data.", bytes);
		} else {
		    sprintf(line, "Read %d KB of data. %s",
				  bytes/1024,
		    "(Press 'z' if you want to abort loading.)");
		}
		HTProgress(line);
		if (HTCheckForInterrupt()) {
		    _HTProgress ("Data transfer interrupted.");
		    if (bytes) {
			rv = HT_INTERRUPTED;
		    } else {
			rv = -1;
		    }
		    break;
		}
		nprogr++;
	    } else if (nprogr == 25) {
		nprogr = 0;
d790 1
a790 1
		nprogr++;
d792 1
d796 58
d856 1
d866 12
d880 1
a880 1
	gzFile, 		gzfp,
d884 1
a884 2
    char line[256];
    int status, bytes = 0, nreads = 0, nprogr = 0;
d892 1
a892 1
    /*	read and inflate gzipped file, and push binary down sink
d894 1
a896 1
	nreads++;
d902 1
a902 3
	    if (TRACE) {
		fprintf(stderr,
			"HTGzFileCopy: Read error, gzread returns %d\n",
d904 1
a904 2
		fprintf(stderr,
			"gzerror   : %s\n",
d906 1
d917 1
d919 3
d923 4
a926 31
	bytes += status;
	if (nreads >= 100) {
	    /*
	    **	Show progress messages for local files, and check for
	    **	user interruption.  Start doing so only after a certain
	    **	number of reads have been done, and don't update it on
	    **	every read (normally reading in a local file should be
	    **	speedy). - KW
	    */
	    if (nprogr == 0) {
		if (bytes < 1024000) {
		    sprintf(line,
			    "Read %d uncompressed bytes of data.", bytes);
		} else {
		    sprintf(line, "Read %d uncompressed KB of data. %s",
				  bytes/1024,
		    "(Press 'z' to abort.)");
		}
		HTProgress(line);
		if (HTCheckForInterrupt()) {
		    _HTProgress ("Data transfer interrupted.");
		    if (bytes) {
			rv = HT_INTERRUPTED;
		    } else {
			rv = -1;
		    }
		    break;
		}
		nprogr++;
	    } else if (nprogr == 25) {
		nprogr = 0;
d928 1
a928 1
		nprogr++;
d930 1
d934 1
d985 24
d1024 1
a1024 1
	char buffer[1024];	/* @@@@@@@@@@@@@@@@ */
d1029 1
a1029 1
	sprintf(buffer, "Sorry, can't convert from %s to %s.",
d1031 11
a1041 3
	if (TRACE)
	    fprintf(stderr, "HTFormat: %s\n", buffer);
	return HTLoadError(sink, 501, buffer); /* returns -501 */
d1043 2
a1044 10

    /*
    ** Push the data, don't worry about CRLF we can strip them later.
    */
    targetClass = *(stream->isa);	/* Copy pointers to procedures */
    rv = HTCopy(anchor, file_number, NULL, stream);
    if (rv != -1 && rv != HT_INTERRUPTED)
	(*targetClass._free)(stream);

    return rv; /* full: HT_LOADED;  partial: HT_INTERRUPTED;  no bytes: -1 */
d1056 13
d1074 1
a1074 1
	FILE *, 		fp,
d1086 1
a1086 1
	char buffer[1024];	/* @@@@@@@@@@@@@@@@ */
d1091 1
a1091 1
	sprintf(buffer, "Sorry, can't convert from %s to %s.",
d1093 4
a1096 3
	if (TRACE)
	    fprintf(stderr, "HTFormat(in HTParseFile): %s\n", buffer);
	return HTLoadError(sink, 501, buffer);
d1121 48
d1171 1
a1171 1
	gzFile, 		gzfp)
d1181 1
a1181 1
	    fprintf(stderr, "gzclose   : error number %d\n", gzres);
d1187 16
d1207 1
a1207 1
	gzFile, 		gzfp,
d1219 1
a1219 2
	char buffer[1024];	/* @@@@@@@@@@@@@@@@ */
	extern char LYCancelDownload;
d1225 1
a1225 1
	sprintf(buffer, "Sorry, can't convert from %s to %s.",
d1227 4
a1230 3
	if (TRACE)
	    fprintf(stderr, "HTFormat(in HTParseGzFile): %s\n", buffer);
	return HTLoadError(sink, 501, buffer);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
