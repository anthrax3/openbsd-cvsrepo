head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.25.14.29.10;	author margarida;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.48;	author maja;	state Exp;
branches
	1.2.10.1
	1.2.12.1;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;

1.2.10.1
date	2003.01.22.23.54.21;	author miod;	state Exp;
branches;
next	;

1.2.12.1
date	2002.12.04.15.50.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTParse.c,v 1.75 2014/02/12 23:15:42 tom Exp $
 *
 *		Parse HyperText Document Address		HTParse.c
 *		================================
 */

#include <HTUtils.h>
#include <HTParse.h>

#include <LYUtils.h>
#include <LYLeaks.h>
#include <LYStrings.h>
#include <LYCharUtils.h>
#include <LYGlobalDefs.h>

#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef __MINGW32__
#include <malloc.h>
#endif /* __MINGW32__ */
#endif

#ifdef USE_IDNA
#include <idna.h>
#include <idn-free.h>
#endif

#define HEX_ESCAPE '%'

struct struct_parts {
    char *access;
    char *host;
    char *absolute;
    char *relative;
    char *search;		/* treated normally as part of path */
    char *anchor;
};

#if 0				/* for debugging */
static void show_parts(const char *name, struct struct_parts *parts, int line)
{
    if (TRACE) {
	CTRACE((tfp, "struct_parts(%s) %s@@%d\n", name, __FILE__, line));
	CTRACE((tfp, "   access   '%s'\n", NONNULL(parts->access)));
	CTRACE((tfp, "   host     '%s'\n", NONNULL(parts->host)));
	CTRACE((tfp, "   absolute '%s'\n", NONNULL(parts->absolute)));
	CTRACE((tfp, "   relative '%s'\n", NONNULL(parts->relative)));
	CTRACE((tfp, "   search   '%s'\n", NONNULL(parts->search)));
	CTRACE((tfp, "   anchor   '%s'\n", NONNULL(parts->anchor)));
    }
}
#define SHOW_PARTS(name) show_parts(#name, &name, __LINE__)
#else
#define SHOW_PARTS(name)	/* nothing */
#endif

/*	Strip white space off a string.				HTStrip()
 *	-------------------------------
 *
 * On exit,
 *	Return value points to first non-white character, or to 0 if none.
 *	All trailing white space is OVERWRITTEN with zero.
 */
char *HTStrip(char *s)
{
#define SPACE(c) ((c == ' ') || (c == '\t') || (c == '\n'))
    char *p;

    for (p = s; *p; p++) {	/* Find end of string */
	;
    }
    for (p--; p >= s; p--) {
	if (SPACE(*p))
	    *p = '\0';		/* Zap trailing blanks */
	else
	    break;
    }
    while (SPACE(*s))
	s++;			/* Strip leading blanks */
    return s;
}

/*	Scan a filename for its constituents.			scan()
 *	-------------------------------------
 *
 * On entry,
 *	name	points to a document name which may be incomplete.
 * On exit,
 *	absolute or relative may be nonzero (but not both).
 *	host, anchor and access may be nonzero if they were specified.
 *	Any which are nonzero point to zero terminated strings.
 */
static void scan(char *name,
		 struct struct_parts *parts)
{
    char *after_access;
    char *p;

    parts->access = NULL;
    parts->host = NULL;
    parts->absolute = NULL;
    parts->relative = NULL;
    parts->search = NULL;	/* normally not used - kw */
    parts->anchor = NULL;

    /*
     * Scan left-to-right for a scheme (access).
     */
    after_access = name;
    for (p = name; *p; p++) {
	if (*p == ':') {
	    *p = '\0';
	    parts->access = name;	/* Access name has been specified */
	    after_access = (p + 1);
	    break;
	}
	if (*p == '/' || *p == '#' || *p == ';' || *p == '?')
	    break;
    }

    /*
     * Scan left-to-right for a fragment (anchor).
     */
    for (p = after_access; *p; p++) {
	if (*p == '#') {
	    parts->anchor = (p + 1);
	    *p = '\0';		/* terminate the rest */
	    break;		/* leave things after first # alone - kw */
	}
    }

    /*
     * Scan left-to-right for a host or absolute path.
     */
    p = after_access;
    if (*p == '/') {
	if (p[1] == '/') {
	    parts->host = (p + 2);	/* host has been specified    */
	    *p = '\0';		/* Terminate access           */
	    p = StrChr(parts->host, '/');	/* look for end of host name if any */
	    if (p != NULL) {
		*p = '\0';	/* Terminate host */
		parts->absolute = (p + 1);	/* Root has been found */
	    } else {
		p = StrChr(parts->host, '?');
		if (p != NULL) {
		    *p = '\0';	/* Terminate host */
		    parts->search = (p + 1);
		}
	    }
	} else {
	    parts->absolute = (p + 1);	/* Root found but no host */
	}
    } else {
	parts->relative = (*after_access) ?
	    after_access : NULL;	/* NULL for "" */
    }

    /*
     * Check schemes that commonly have unescaped hashes.
     */
    if (parts->access && parts->anchor &&
    /* optimize */ StrChr("lnsdLNSD", *parts->access) != NULL) {
	if ((!parts->host && strcasecomp(parts->access, "lynxcgi")) ||
	    !strcasecomp(parts->access, "nntp") ||
	    !strcasecomp(parts->access, "snews") ||
	    !strcasecomp(parts->access, "news") ||
	    !strcasecomp(parts->access, "data")) {
	    /*
	     * Access specified but no host and not a lynxcgi URL, so the
	     * anchor may not really be one, e.g., news:j462#36487@@foo.bar, or
	     * it's an nntp or snews URL, or news URL with a host.  Restore the
	     * '#' in the address.
	     */
	    /* but only if we have found a path component of which this will
	     * become part. - kw  */
	    if (parts->relative || parts->absolute) {
		*(parts->anchor - 1) = '#';
		parts->anchor = NULL;
	    }
	}
    }
}				/*scan */

#if defined(HAVE_ALLOCA) && !defined(LY_FIND_LEAKS)
#define LYalloca(x)        alloca(x)
#define LYalloca_free(x)   {}
#else
#define LYalloca(x)        malloc(x)
#define LYalloca_free(x)   free(x)
#endif

static char *strchr_or_end(char *string, int ch)
{
    char *result = StrChr(string, ch);

    if (result == 0) {
	result = string + strlen(string);
    }
    return result;
}

/*
 * Given a host specification that may end with a port number, e.g.,
 *	foobar:123
 * point to the ':' which begins the ":port" to make it simple to handle the
 * substring.
 *
 * If no port is found (or a syntax error), return null.
 */
char *HTParsePort(char *host, int *portp)
{
    int brackets = 0;
    char *result = NULL;

    *portp = 0;
    if (host != NULL) {
	while (*host != '\0' && result == 0) {
	    switch (*host++) {
	    case ':':
		if (brackets == 0 && isdigit(UCH(*host))) {
		    char *next = NULL;

		    *portp = (int) strtol(host, &next, 10);
		    if (next != 0 && next != host && *next == '\0') {
			result = (host - 1);
			CTRACE((tfp, "HTParsePort %d\n", *portp));
		    }
		}
		break;
	    case '[':		/* for ipv6 */
		++brackets;
		break;
	    case ']':		/* for ipv6 */
		--brackets;
		break;
	    }
	}
    }
    return result;
}

#ifdef USE_IDNA
static int hex_decode(int ch)
{
    int result = -1;

    if (ch >= '0' && ch <= '9')
	result = (ch - '0');
    else if (ch >= 'a' && ch <= 'f')
	result = (ch - 'a') + 10;
    else if (ch >= 'A' && ch <= 'F')
	result = (ch - 'A') + 10;
    return result;
}

/*
 * Convert in-place the given hostname to IDNA form.  That requires up to 64
 * characters, and we've allowed for that, with MIN_PARSE.
 */
static void convert_to_idna(char *host)
{
    size_t length = strlen(host);
    char *endhost = host + length;
    char *buffer = malloc(length + 1);
    char *output = NULL;
    char *src, *dst;
    int code;
    int hi, lo;

    if (buffer != 0) {
	code = TRUE;
	for (dst = buffer, src = host; src < endhost; ++dst) {
	    int ch = *src++;

	    if (ch == HEX_ESCAPE) {
		if ((src + 1) < endhost
		    && (hi = hex_decode(src[0])) >= 0
		    && (lo = hex_decode(src[1])) >= 0) {

		    *dst = (char) ((hi << 4) | lo);
		    src += 2;
		} else {
		    CTRACE((tfp, "convert_to_idna: `%s' is malformed\n", host));
		    code = FALSE;
		    break;
		}
	    } else {
		*dst = (char) ch;
	    }
	}
	if (code) {
	    *dst = '\0';
	    code = idna_to_ascii_8z(buffer, &output, IDNA_USE_STD3_ASCII_RULES);
	    if (code == IDNA_SUCCESS) {
		strcpy(host, output);
	    } else {
		CTRACE((tfp, "convert_to_idna: `%s': %s\n",
			buffer,
			idna_strerror((Idna_rc) code)));
	    }
	    if (output)
		idn_free (output);
	}
	free(buffer);
    }
}
#define MIN_PARSE 80
#else
#define MIN_PARSE 8
#endif

/*	Parse a Name relative to another name.			HTParse()
 *	--------------------------------------
 *
 *	This returns those parts of a name which are given (and requested)
 *	substituting bits from the related name where necessary.
 *
 * On entry,
 *	aName		A filename given
 *	relatedName	A name relative to which aName is to be parsed
 *	wanted		A mask for the bits which are wanted.
 *
 * On exit,
 *     returns         A pointer to a malloc'd string which MUST BE FREED
 */
char *HTParse(const char *aName,
	      const char *relatedName,
	      int wanted)
{
    char *result = NULL;
    char *tail = NULL;		/* a pointer to the end of the 'result' string */
    char *return_value = NULL;
    size_t len, len1, len2;
    size_t need;
    char *name = NULL;
    char *rel = NULL;
    char *p, *q;
    char *acc_method;
    struct struct_parts given, related;

    CTRACE((tfp, "HTParse: aName:`%s'\n", aName));
    CTRACE((tfp, "   relatedName:`%s'\n", relatedName));

    if (wanted & (PARSE_STRICTPATH | PARSE_QUERY)) {	/* if detail wanted... */
	if ((wanted & (PARSE_STRICTPATH | PARSE_QUERY))
	    == (PARSE_STRICTPATH | PARSE_QUERY))	/* if strictpath AND query */
	    wanted |= PARSE_PATH;	/* then treat as if PARSE_PATH wanted */
	if (wanted & PARSE_PATH)	/* if PARSE_PATH wanted */
	    wanted &= ~(PARSE_STRICTPATH | PARSE_QUERY);	/* ignore details */
    }
/* *INDENT-OFF* */
    CTRACE((tfp, "   want:%s%s%s%s%s%s%s\n",
	    wanted & PARSE_PUNCTUATION ? " punc"   : "",
	    wanted & PARSE_ANCHOR      ? " anchor" : "",
	    wanted & PARSE_PATH        ? " path"   : "",
	    wanted & PARSE_HOST        ? " host"   : "",
	    wanted & PARSE_ACCESS      ? " access" : "",
	    wanted & PARSE_STRICTPATH  ? " PATH"   : "",
	    wanted & PARSE_QUERY       ? " QUERY"  : ""));
/* *INDENT-ON* */

    /*
     * Allocate the temporary string. Optimized.
     */
    len1 = strlen(aName) + 1;
    len2 = strlen(relatedName) + 1;
    len = len1 + len2 + MIN_PARSE;	/* Lots of space: more than enough */

    need = (len * 2 + len1 + len2);
    if (need > (size_t) max_uri_size ||
	(int) need < (int) len1 ||
	(int) need < (int) len2)
	return StrAllocCopy(return_value, "");

    result = tail = (char *) LYalloca(need);
    if (result == NULL) {
	outofmem(__FILE__, "HTParse");

	assert(result != NULL);
    }
    *result = '\0';
    name = result + len;
    rel = name + len1;

    /*
     * Make working copy of the input string to cut up.
     */
    MemCpy(name, aName, len1);

    /*
     * Cut up the string into URL fields.
     */
    scan(name, &given);
    SHOW_PARTS(given);

    /*
     * Now related string.
     */
    if ((given.access && given.host && given.absolute) || !*relatedName) {
	/*
	 * Inherit nothing!
	 */
	related.access = NULL;
	related.host = NULL;
	related.absolute = NULL;
	related.relative = NULL;
	related.search = NULL;
	related.anchor = NULL;
    } else {
	MemCpy(rel, relatedName, len2);
	scan(rel, &related);
    }
    SHOW_PARTS(related);

    /*
     * Handle the scheme (access) field.
     */
    if (given.access && given.host && !given.relative && !given.absolute) {
	if (!strcmp(given.access, "http") ||
	    !strcmp(given.access, "https") ||
	    !strcmp(given.access, "ftp")) {

	    /*
	     * Assume root.
	     */
	    given.absolute = empty_string;
	}
    }
    acc_method = given.access ? given.access : related.access;
    if (wanted & PARSE_ACCESS) {
	if (acc_method) {
	    strcpy(tail, acc_method);
	    tail += strlen(tail);
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = ':';
		*tail = '\0';
	    }
	}
    }

    /*
     * If different schemes, inherit nothing.
     *
     * We'll try complying with RFC 1808 and the Fielding draft, and inherit
     * nothing if both schemes are given, rather than only when they differ,
     * except for file URLs - FM
     *
     * After trying it for a while, it's still premature, IHMO, to go along
     * with it, so this is back to inheriting for identical schemes whether or
     * not they are "file".  If you want to try it again yourself, uncomment
     * the strcasecomp() below.  - FM
     */
    if ((given.access && related.access) &&
	(			/* strcasecomp(given.access, "file") || */
	    strcmp(given.access, related.access))) {
	related.host = NULL;
	related.absolute = NULL;
	related.relative = NULL;
	related.search = NULL;
	related.anchor = NULL;
    }

    /*
     * Handle the host field.
     */
    if (wanted & PARSE_HOST) {
	if (given.host || related.host) {
	    if (wanted & PARSE_PUNCTUATION) {
		*tail++ = '/';
		*tail++ = '/';
	    }
	    strcpy(tail, given.host ? given.host : related.host);
#define CLEAN_URLS
#ifdef CLEAN_URLS
	    /*
	     * Ignore default port numbers, and trailing dots on FQDNs, which
	     * will only cause identical addresses to look different.  (related
	     * is already a clean url).
	     */
	    {
		char *p2, *h;
		int portnumber;

		if ((p2 = StrChr(result, '@@')) != NULL)
		    tail = (p2 + 1);
		p2 = HTParsePort(result, &portnumber);
		if (p2 != NULL && acc_method != NULL) {
		    /*
		     * Port specified.
		     */
#define ACC_METHOD(a,b) (!strcmp(acc_method, a) && (portnumber == b))
		    if (ACC_METHOD("http", 80) ||
			ACC_METHOD("https", 443) ||
			ACC_METHOD("gopher", 70) ||
			ACC_METHOD("ftp", 21) ||
			ACC_METHOD("wais", 210) ||
			ACC_METHOD("nntp", 119) ||
			ACC_METHOD("news", 119) ||
			ACC_METHOD("newspost", 119) ||
			ACC_METHOD("newsreply", 119) ||
			ACC_METHOD("snews", 563) ||
			ACC_METHOD("snewspost", 563) ||
			ACC_METHOD("snewsreply", 563) ||
			ACC_METHOD("finger", 79) ||
			ACC_METHOD("telnet", 23) ||
			ACC_METHOD("tn3270", 23) ||
			ACC_METHOD("rlogin", 513) ||
			ACC_METHOD("cso", 105))
			*p2 = '\0';	/* It is the default: ignore it */
		}
		if (p2 == NULL) {
		    int len3 = (int) strlen(tail);

		    if (len3 > 0) {
			h = tail + len3 - 1;	/* last char of hostname */
			if (*h == '.')
			    *h = '\0';	/* chop final . */
		    }
		} else if (p2 != result) {
		    h = p2;
		    h--;	/* End of hostname */
		    if (*h == '.') {
			/*
			 * Slide p2 over h.
			 */
			while (*p2 != '\0')
			    *h++ = *p2++;
			*h = '\0';	/* terminate */
		    }
		}
	    }
#ifdef USE_IDNA
	    /*
	     * Depending on locale-support, we could have a literal UTF-8
	     * string as a host name, or a URL-encoded form of that.
	     */
	    convert_to_idna(tail);
#endif
#endif /* CLEAN_URLS */
	}
    }

    /*
     * Trim any blanks from the result so far - there's no excuse for blanks
     * in a hostname.  Also update the tail here.
     */
    tail = LYRemoveBlanks(result);

    /*
     * If host in given or related was ended directly with a '?' (no slash),
     * fake the search part into absolute.  This is the only case search is
     * returned from scan.  A host must have been present.  this restores the
     * '?' at which the host part had been truncated in scan, we have to do
     * this after host part handling is done.  - kw
     */
    if (given.search && *(given.search - 1) == '\0') {
	given.absolute = given.search - 1;
	given.absolute[0] = '?';
    } else if (related.search && !related.absolute &&
	       *(related.search - 1) == '\0') {
	related.absolute = related.search - 1;
	related.absolute[0] = '?';
    }

    /*
     * If different hosts, inherit no path.
     */
    if (given.host && related.host)
	if (strcmp(given.host, related.host) != 0) {
	    related.absolute = NULL;
	    related.relative = NULL;
	    related.anchor = NULL;
	}

    /*
     * Handle the path.
     */
    if (wanted & (PARSE_PATH | PARSE_STRICTPATH | PARSE_QUERY)) {
	int want_detail = (wanted & (PARSE_STRICTPATH | PARSE_QUERY));

	if (acc_method && !given.absolute && given.relative) {
	    /*
	     * Treat all given nntp or snews paths, or given paths for news
	     * URLs with a host, as absolute.
	     */
	    switch (*acc_method) {
	    case 'N':
	    case 'n':
		if (!strcasecomp(acc_method, "nntp") ||
		    (!strcasecomp(acc_method, "news") &&
		     !strncasecomp(result, "news://", 7))) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
	    case 'S':
	    case 's':
		if (!strcasecomp(acc_method, "snews")) {
		    given.absolute = given.relative;
		    given.relative = NULL;
		}
		break;
	    }
	}

	if (given.absolute) {	/* All is given */
	    if (wanted & PARSE_PUNCTUATION)
		*tail++ = '/';
	    strcpy(tail, given.absolute);
	    CTRACE((tfp, "HTParse: (ABS)\n"));
	} else if (related.absolute) {	/* Adopt path not name */
	    char *base = tail;

	    *tail++ = '/';
	    strcpy(tail, related.absolute);
	    if (given.relative) {
		/* RFC 1808 part 4 step 5 (if URL path is empty) */
		/* a) if given has params, add/replace that */
		if (given.relative[0] == ';') {
		    strcpy(strchr_or_end(tail, ';'), given.relative);
		}
		/* b) if given has query, add/replace that */
		else if (given.relative[0] == '?') {
		    strcpy(strchr_or_end(tail, '?'), given.relative);
		}
		/* otherwise fall through to RFC 1808 part 4 step 6 */
		else {
		    p = StrChr(tail, '?');	/* Search part? */
		    if (p == NULL)
			p = (tail + strlen(tail) - 1);
		    for (; *p != '/'; p--) ;	/* last / */
		    p[1] = '\0';	/* Remove filename */
		    strcat(p, given.relative);	/* Add given one */
		}
		HTSimplify(base);
		if (*base == '\0')
		    strcpy(base, "/");
	    }
	    CTRACE((tfp, "HTParse: (Related-ABS)\n"));
	} else if (given.relative) {
	    strcpy(tail, given.relative);	/* what we've got */
	    CTRACE((tfp, "HTParse: (REL)\n"));
	} else if (related.relative) {
	    strcpy(tail, related.relative);
	    CTRACE((tfp, "HTParse: (Related-REL)\n"));
	} else {		/* No inheritance */
	    if (!isLYNXCGI(aName) &&
		!isLYNXEXEC(aName) &&
		!isLYNXPROG(aName)) {
		*tail++ = '/';
		*tail = '\0';
	    }
	    if (!strcmp(result, "news:/"))
		result[5] = '*';
	    CTRACE((tfp, "HTParse: (No inheritance)\n"));
	}
	if (want_detail) {
	    p = StrChr(tail, '?');	/* Search part? */
	    if (p) {
		if (PARSE_STRICTPATH) {
		    *p = '\0';
		} else {
		    if (!(wanted & PARSE_PUNCTUATION))
			p++;
		    do {
			*tail++ = *p;
		    } while (*p++);
		}
	    } else {
		if (wanted & PARSE_QUERY)
		    *tail = '\0';
	    }
	}
    }

    /*
     * Handle the fragment (anchor).  Never inherit.
     */
    if (wanted & PARSE_ANCHOR) {
	if (given.anchor && *given.anchor) {
	    tail += strlen(tail);
	    if (wanted & PARSE_PUNCTUATION)
		*tail++ = '#';
	    strcpy(tail, given.anchor);
	}
    }

    /*
     * If there are any blanks remaining in the string, escape them as needed.
     * See the discussion in LYLegitimizeHREF() for example.
     */
    if ((p = StrChr(result, ' ')) != 0) {
	switch (is_url(result)) {
	case UNKNOWN_URL_TYPE:
	    CTRACE((tfp, "HTParse:      ignore:`%s'\n", result));
	    break;
	case LYNXEXEC_URL_TYPE:
	case LYNXPROG_URL_TYPE:
	case LYNXCGI_URL_TYPE:
	case LYNXPRINT_URL_TYPE:
	case LYNXHIST_URL_TYPE:
	case LYNXDOWNLOAD_URL_TYPE:
	case LYNXKEYMAP_URL_TYPE:
	case LYNXIMGMAP_URL_TYPE:
	case LYNXCOOKIE_URL_TYPE:
	case LYNXCACHE_URL_TYPE:
	case LYNXDIRED_URL_TYPE:
	case LYNXOPTIONS_URL_TYPE:
	case LYNXCFG_URL_TYPE:
	case LYNXCOMPILE_OPTS_URL_TYPE:
	case LYNXMESSAGES_URL_TYPE:
	    CTRACE((tfp, "HTParse:      spaces:`%s'\n", result));
	    break;
	case NOT_A_URL_TYPE:
	default:
	    CTRACE((tfp, "HTParse:      encode:`%s'\n", result));
	    do {
		q = p + strlen(p) + 2;

		while (q != p + 1) {
		    q[0] = q[-2];
		    --q;
		}
		p[0] = HEX_ESCAPE;
		p[1] = '2';
		p[2] = '0';
	    } while ((p = StrChr(result, ' ')) != 0);
	    break;
	}
    }
    CTRACE((tfp, "HTParse:      result:`%s'\n", result));

    StrAllocCopy(return_value, result);
    LYalloca_free(result);

    /* FIXME: could be optimized using HTParse() internals */
    if (*relatedName &&
	((wanted & PARSE_ALL_WITHOUT_ANCHOR) == PARSE_ALL_WITHOUT_ANCHOR)) {
	/*
	 * Check whether to fill in localhost.  - FM
	 */
	LYFillLocalFileURL(&return_value, relatedName);
	CTRACE((tfp, "pass LYFillLocalFile:`%s'\n", return_value));
    }

    return return_value;	/* exactly the right length */
}

/*	HTParseAnchor(), fast HTParse() specialization
 *	----------------------------------------------
 *
 * On exit,
 *	returns		A pointer within input string (probably to its end '\0')
 */
const char *HTParseAnchor(const char *aName)
{
    const char *p = aName;

    for (; *p && *p != '#'; p++) {
	;
    }
    if (*p == '#') {
	/* the safe way based on HTParse() -
	 * keeping in mind scan() peculiarities on schemes:
	 */
	struct struct_parts given;
	size_t need = ((unsigned) ((p - aName) + (int) strlen(p) + 1));
	char *name;

	if (need > (size_t) max_uri_size) {
	    p += strlen(p);
	} else {
	    name = (char *) LYalloca(need);

	    if (name == NULL) {
		outofmem(__FILE__, "HTParseAnchor");

		assert(name != NULL);
	    }
	    strcpy(name, aName);
	    scan(name, &given);
	    LYalloca_free(name);

	    p++;		/*next to '#' */
	    if (given.anchor == NULL) {
		for (; *p; p++)	/*scroll to end '\0' */
		    ;
	    }
	}
    }
    return p;
}

/*	Simplify a filename.				HTSimplify()
 *	--------------------
 *
 *  A unix-style file is allowed to contain the sequence xxx/../ which may
 *  be replaced by "" , and the sequence "/./" which may be replaced by "/".
 *  Simplification helps us recognize duplicate filenames.
 *
 *	Thus,	/etc/junk/../fred	becomes /etc/fred
 *		/etc/junk/./fred	becomes /etc/junk/fred
 *
 *	but we should NOT change
 *		http://fred.xxx.edu/../..
 *
 *	or	../../albert.html
 */
void HTSimplify(char *filename)
{
    char *p;
    char *q, *q1;

    if (filename == NULL)
	return;

    if (!(filename[0] && filename[1]) ||
	filename[0] == '?' || filename[1] == '?' || filename[2] == '?')
	return;

    if (StrChr(filename, '/') != NULL) {
	for (p = (filename + 2); *p; p++) {
	    if (*p == '?') {
		/*
		 * We're still treating a ?searchpart as part of the path in
		 * HTParse() and scan(), but if we encounter a '?' here, assume
		 * it's the delimiter and break.  We also could check for a
		 * parameter delimiter (';') here, but the current Fielding
		 * draft (wisely or ill-advisedly :) says that it should be
		 * ignored and collapsing be allowed in it's value).  The only
		 * defined parameter at present is ;type=[A, I, or D] for ftp
		 * URLs, so if there's a "/..", "/../", "/./", or terminal '.'
		 * following the ';', it must be due to the ';' being an
		 * unescaped path character and not actually a parameter
		 * delimiter.  - FM
		 */
		break;
	    }
	    if (*p == '/') {
		if ((p[1] == '.') && (p[2] == '.') &&
		    (p[3] == '/' || p[3] == '?' || p[3] == '\0')) {
		    /*
		     * Handle "../", "..?" or "..".
		     */
		    for (q = (p - 1); (q >= filename) && (*q != '/'); q--)
			/*
			 * Back up to previous slash or beginning of string.
			 */
			;
		    if ((q[0] == '/') &&
			(StrNCmp(q, "/../", 4) &&
			 StrNCmp(q, "/..?", 4)) &&
			!((q - 1) > filename && q[-1] == '/')) {
			/*
			 * Not at beginning of string or in a host field, so
			 * remove the "/xxx/..".
			 */
			q1 = (p + 3);
			p = q;
			while (*q1 != '\0')
			    *p++ = *q1++;
			*p = '\0';	/* terminate */
			/*
			 * Start again with previous slash.
			 */
			p = (q - 1);
		    }
		} else if (p[1] == '.' && p[2] == '/') {
		    /*
		     * Handle "./" by removing both characters.
		     */
		    q = p;
		    q1 = (p + 2);
		    while (*q1 != '\0')
			*q++ = *q1++;
		    *q = '\0';	/* terminate */
		    p--;
		} else if (p[1] == '.' && p[2] == '?') {
		    /*
		     * Handle ".?" by removing the dot.
		     */
		    q = (p + 1);
		    q1 = (p + 2);
		    while (*q1 != '\0')
			*q++ = *q1++;
		    *q = '\0';	/* terminate */
		    p--;
		} else if (p[1] == '.' && p[2] == '\0') {
		    /*
		     * Handle terminal "." by removing the character.
		     */
		    p[1] = '\0';
		}
	    }
	}
	if (p >= filename + 2 && *p == '?' && *(p - 1) == '.') {
	    if (*(p - 2) == '/') {
		/*
		 * Handle "/.?" by removing the dot.
		 */
		q = p - 1;
		q1 = p;
		while (*q1 != '\0')
		    *q++ = *q1++;
		*q = '\0';
	    } else if (*(p - 2) == '.' &&
		       p >= filename + 4 && *(p - 3) == '/' &&
		       (*(p - 4) != '/' ||
			(p > filename + 4 && *(p - 5) != ':'))) {
		/*
		 * Handle "xxx/..?"
		 */
		for (q = (p - 4); (q > filename) && (*q != '/'); q--)
		    /*
		     * Back up to previous slash or beginning of string.
		     */
		    ;
		if (*q == '/') {
		    if (q > filename && *(q - 1) == '/' &&
			!(q > filename + 1 && *(q - 1) != ':'))
			return;
		    q++;
		}
		if (StrNCmp(q, "../", 3) && StrNCmp(q, "./", 2)) {
		    /*
		     * Not after "//" at beginning of string or after "://",
		     * and xxx is not ".." or ".", so remove the "xxx/..".
		     */
		    q1 = p;
		    p = q;
		    while (*q1 != '\0')
			*p++ = *q1++;
		    *p = '\0';	/* terminate */
		}
	    }
	}
    }
}

/*	Make Relative Name.					HTRelative()
 *	-------------------
 *
 * This function creates and returns a string which gives an expression of
 * one address as related to another.  Where there is no relation, an absolute
 * address is returned.
 *
 *  On entry,
 *	Both names must be absolute, fully qualified names of nodes
 *	(no anchor bits)
 *
 *  On exit,
 *	The return result points to a newly allocated name which, if
 *	parsed by HTParse relative to relatedName, will yield aName.
 *	The caller is responsible for freeing the resulting name later.
 *
 */
char *HTRelative(const char *aName,
		 const char *relatedName)
{
    char *result = NULL;
    const char *p = aName;
    const char *q = relatedName;
    const char *after_access = NULL;
    const char *path = NULL;
    const char *last_slash = NULL;
    int slashes = 0;

    for (; *p; p++, q++) {	/* Find extent of match */
	if (*p != *q)
	    break;
	if (*p == ':')
	    after_access = p + 1;
	if (*p == '/') {
	    last_slash = p;
	    slashes++;
	    if (slashes == 3)
		path = p;
	}
    }

    /* q, p point to the first non-matching character or zero */

    if (!after_access) {	/* Different access */
	StrAllocCopy(result, aName);
    } else if (slashes < 3) {	/* Different nodes */
	StrAllocCopy(result, after_access);
    } else if (slashes == 3) {	/* Same node, different path */
	StrAllocCopy(result, path);
    } else {			/* Some path in common */
	unsigned levels = 0;

	for (; *q && (*q != '#'); q++)
	    if (*q == '/')
		levels++;
	result = typecallocn(char, 3 * levels + strlen(last_slash) + 1);

	if (result == NULL)
	    outofmem(__FILE__, "HTRelative");

	assert(result != NULL);

	result[0] = '\0';
	for (; levels; levels--)
	    strcat(result, "../");
	strcat(result, last_slash + 1);
    }
    CTRACE((tfp,
	    "HTparse: `%s' expressed relative to\n   `%s' is\n   `%s'.\n",
	    aName, relatedName, result));
    return result;
}

#define AlloCopy(next,base,extra) \
	typecallocn(char, ((next - base) + ((int) extra)))

/*	Escape undesirable characters using %			HTEscape()
 *	-------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a calloc'd string.
 */
/* *INDENT-OFF* */
static const unsigned char isAcceptable[96] =

/*	Bit 0		xalpha		-- see HTFile.h
 *	Bit 1		xpalpha		-- as xalpha but with plus.
 *	Bit 2 ...	path		-- as xpalphas but with /
 */
    /*	 0 1 2 3 4 5 6 7 8 9 A B C D E F */
    {	 0,0,0,0,0,0,0,0,0,0,7,6,0,7,7,4,	/* 2x	!"#$%&'()*+,-./  */
	 7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,	/* 3x  0123456789:;<=>?  */
	 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,	/* 4x  @@ABCDEFGHIJKLMNO  */
	 7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,7,	/* 5X  PQRSTUVWXYZ[\]^_  */
	 0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,	/* 6x  `abcdefghijklmno  */
	 7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0 };	/* 7X  pqrstuvwxyz{|}~	DEL */
/* *INDENT-ON* */

static const char *hex = "0123456789ABCDEF";

#define ACCEPTABLE(a)	( a>=32 && a<128 && ((isAcceptable[a-32]) & mask))

char *HTEscape(const char *str,
	       unsigned mask)
{
    const char *p;
    char *q;
    char *result;
    size_t unacceptable = 0;

    for (p = str; *p; p++)
	if (!ACCEPTABLE(UCH(TOASCII(*p))))
	    unacceptable++;
    result = AlloCopy(p, str, (unacceptable * 2) + 1);

    if (result == NULL)
	outofmem(__FILE__, "HTEscape");

    assert(result != NULL);

    for (q = result, p = str; *p; p++) {
	unsigned char a = UCH(TOASCII(*p));

	if (!ACCEPTABLE(a)) {
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else
	    *q++ = *p;
    }
    *q = '\0';			/* Terminate */
    return result;
}

/*	Escape unsafe characters using %			HTEscapeUnsafe()
 *	--------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be that may be unsafe are unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits.
 *
 *	Unlike HTUnEscape(), this routine returns a malloc'd string.
 */
#define UNSAFE(ch) (((ch) <= 32) || ((ch) >= 127))

char *HTEscapeUnsafe(const char *str)
{
    const char *p;
    char *q;
    char *result;
    size_t unacceptable = 0;

    for (p = str; *p; p++)
	if (UNSAFE(UCH(TOASCII(*p))))
	    unacceptable++;
    result = AlloCopy(p, str, (unacceptable * 2) + 1);

    if (result == NULL)
	outofmem(__FILE__, "HTEscapeUnsafe");

    assert(result != NULL);

    for (q = result, p = str; *p; p++) {
	unsigned char a = UCH(TOASCII(*p));

	if (UNSAFE(a)) {
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else
	    *q++ = *p;
    }
    *q = '\0';			/* Terminate */
    return result;
}

/*	Escape undesirable characters using % but space to +.	HTEscapeSP()
 *	-----------------------------------------------------
 *
 *	This function takes a pointer to a string in which
 *	some characters may be unacceptable unescaped.
 *	It returns a string which has these characters
 *	represented by a '%' character followed by two hex digits,
 *	except that spaces are converted to '+' instead of %2B.
 *
 *	Unlike HTUnEscape(), this routine returns a calloced string.
 */
char *HTEscapeSP(const char *str,
		 unsigned mask)
{
    const char *p;
    char *q;
    char *result;
    size_t unacceptable = 0;

    for (p = str; *p; p++)
	if (!(*p == ' ' || ACCEPTABLE(UCH(TOASCII(*p)))))
	    unacceptable++;
    result = AlloCopy(p, str, (unacceptable * 2) + 1);

    if (result == NULL)
	outofmem(__FILE__, "HTEscape");

    assert(result != NULL);

    for (q = result, p = str; *p; p++) {
	unsigned char a = UCH(TOASCII(*p));

	if (a == 32) {
	    *q++ = '+';
	} else if (!ACCEPTABLE(a)) {
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
	    *q++ = hex[a >> 4];
	    *q++ = hex[a & 15];
	} else {
	    *q++ = *p;
	}
    }
    *q = '\0';			/* Terminate */
    return result;
}

/*	Decode %xx escaped characters.				HTUnEscape()
 *	------------------------------
 *
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y.
 *	The string is converted in place, as it will never grow.
 */
static char from_hex(int c)
{
    return (char) (c >= '0' && c <= '9' ? c - '0'
		   : c >= 'A' && c <= 'F' ? c - 'A' + 10
		   : c - 'a' + 10);	/* accept small letters just in case */
}

char *HTUnEscape(char *str)
{
    char *p = str;
    char *q = str;

    if (!(p && *p))
	return str;

    while (*p != '\0') {
	if (*p == HEX_ESCAPE &&
	/*
	 * Tests shouldn't be needed, but better safe than sorry.
	 */
	    p[1] && p[2] &&
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2]))) {
	    p++;
	    if (*p)
		*q = (char) (from_hex(*p++) * 16);
	    if (*p) {
		/*
		 * Careful! FROMASCII() may evaluate its arg more than once!
		 */
		/* S/390 -- gil -- 0221 */
		*q = (char) (*q + from_hex(*p++));
	    }
	    *q = FROMASCII(*q);
	    q++;
	} else {
	    *q++ = *p++;
	}
    }

    *q = '\0';
    return str;

}				/* HTUnEscape */

/*	Decode some %xx escaped characters.		      HTUnEscapeSome()
 *	-----------------------------------			Klaus Weide
 *							    (kweide@@tezcat.com)
 *	This function takes a pointer to a string in which some
 *	characters may have been encoded in %xy form, where xy is
 *	the ASCII hex code for character 16x+y, and a pointer to
 *	a second string containing one or more characters which
 *	should be unescaped if escaped in the first string.
 *	The first string is converted in place, as it will never grow.
 */
char *HTUnEscapeSome(char *str,
		     const char *do_trans)
{
    char *p = str;
    char *q = str;
    char testcode;

    if (p == NULL || *p == '\0' || do_trans == NULL || *do_trans == '\0')
	return str;

    while (*p != '\0') {
	if (*p == HEX_ESCAPE &&
	    p[1] && p[2] &&	/* tests shouldn't be needed, but.. */
	    isxdigit(UCH(p[1])) &&
	    isxdigit(UCH(p[2])) &&
	    (testcode = (char) FROMASCII(from_hex(p[1]) * 16 +
					 from_hex(p[2]))) &&	/* %00 no good */
	    StrChr(do_trans, testcode)) {	/* it's one of the ones we want */
	    *q++ = testcode;
	    p += 3;
	} else {
	    *q++ = *p++;
	}
    }

    *q = '\0';
    return str;

}				/* HTUnEscapeSome */
/* *INDENT-OFF* */
static const unsigned char crfc[96] =

/*	Bit 0		xalpha		-- need "quoting"
 *	Bit 1		xpalpha		-- need \escape if quoted
 */
    /*	 0 1 2 3 4 5 6 7 8 9 A B C D E F */
    {	 1,0,3,0,0,0,0,0,1,1,0,0,1,0,1,0,	/* 2x	!"#$%&'()*+,-./  */
	 0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,	/* 3x  0123456789:;<=>?  */
	 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 4x  @@ABCDEFGHIJKLMNO  */
	 0,0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,	/* 5X  PQRSTUVWXYZ[\]^_  */
	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 6x  `abcdefghijklmno  */
	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3 };	/* 7X  pqrstuvwxyz{|}~	DEL */
/* *INDENT-ON* */

#define ASCII_TAB '\011'
#define ASCII_LF  '\012'
#define ASCII_CR  '\015'
#define ASCII_SPC '\040'
#define ASCII_BAK '\134'

/*
 *  Turn a string which is not a RFC 822 token into a quoted-string. - KW
 *  The "quoted" parameter tells whether we need the beginning/ending quote
 *  marks.  If not, the caller will provide them -TD
 */
void HTMake822Word(char **str,
		   int quoted)
{
    const char *p;
    char *q;
    char *result;
    unsigned char a;
    unsigned added = 0;

    if (isEmpty(*str)) {
	StrAllocCopy(*str, quoted ? "\"\"" : "");
	return;
    }
    for (p = *str; *p; p++) {
	a = UCH(TOASCII(*p));	/* S/390 -- gil -- 0240 */
	if (a < 32 || a >= 128 ||
	    ((crfc[a - 32]) & 1)) {
	    if (!added)
		added = 2;
	    if (a >= 160 || a == '\t')
		continue;
	    if (a == '\r' || a == '\n')
		added += 2;
	    else if ((a & 127) < 32 || ((crfc[a - 32]) & 2))
		added++;
	}
    }
    if (!added)
	return;
    result = AlloCopy(p, *str, added + 1);
    if (result == NULL)
	outofmem(__FILE__, "HTMake822Word");

    assert(result != NULL);

    q = result;
    if (quoted)
	*q++ = '"';
    /*
     * Having converted the character to ASCII, we can't use symbolic
     * escape codes, since they're in the host character set, which
     * is not necessarily ASCII.  Thus we use octal escape codes instead.
     * -- gil (Paul Gilmartin) <pg@@sweng.stortek.com>
     */
    /* S/390 -- gil -- 0268 */
    for (p = *str; *p; p++) {
	a = UCH(TOASCII(*p));
	if ((a != ASCII_TAB) &&
	    ((a & 127) < ASCII_SPC ||
	     (a < 128 && ((crfc[a - 32]) & 2))))
	    *q++ = ASCII_BAK;
	*q++ = *p;
	if (a == ASCII_LF ||
	    (a == ASCII_CR && (TOASCII(*(p + 1)) != ASCII_LF)))
	    *q++ = ' ';
    }
    if (quoted)
	*q++ = '"';
    *q = '\0';			/* Terminate */
    FREE(*str);
    *str = result;
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTParse.c,v 1.51 2009/01/03 01:11:14 tom Exp $
d15 1
d25 4
a28 1
#define MAX_URI_SIZE 8192
d69 1
a69 1
    char *p = s;
d71 3
a73 1
    for (p = s; *p; p++) ;	/* Find end of string */
d142 1
a142 1
	    p = strchr(parts->host, '/');	/* look for end of host name if any */
d147 1
a147 1
		p = strchr(parts->host, '?');
d165 1
a165 1
    /* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
d197 1
a197 1
    char *result = strchr(string, ch);
d226 1
a226 1
		    *portp = strtol(host, &next, 10);
d245 70
d370 1
a370 1
    len = len1 + len2 + 8;	/* Lots of space: more than enough */
d373 3
a375 3
    if (need > MAX_URI_SIZE ||
	len1 > MAX_URI_SIZE ||
	len2 > MAX_URI_SIZE)
d381 2
d391 1
a391 1
    memcpy(name, aName, len1);
d413 1
a413 1
	memcpy(rel, relatedName, len2);
a424 1
	    static char empty_string[] = "";
d487 1
a487 1
		if ((p2 = strchr(result, '@@')) != NULL)
d535 7
d631 1
a631 1
		    p = strchr(tail, '?');	/* Search part? */
d661 1
a661 1
	    p = strchr(tail, '?');	/* Search part? */
d695 1
a695 1
    if ((p = strchr(result, ' ')) != 0) {
d727 1
a727 1
		p[0] = '%';
d730 1
a730 1
	    } while ((p = strchr(result, ' ')) != 0);
d773 1
a773 1
	if (strlen(aName) > MAX_URI_SIZE) {
d780 2
d824 1
a824 1
    if (strchr(filename, '/') != NULL) {
d854 2
a855 2
			(strncmp(q, "/../", 4) &&
			 strncmp(q, "/..?", 4)) &&
d927 1
a927 1
		if (strncmp(q, "../", 3) && strncmp(q, "./", 2)) {
d1002 3
d1017 1
a1017 1
	typecallocn(char, (unsigned) ((next - base) + ((int) extra)))
d1050 1
a1050 1
	       unsigned char mask)
d1055 1
a1055 1
    unsigned unacceptable = 0;
d1064 3
d1077 1
a1077 1
    *q++ = '\0';		/* Terminate */
d1098 1
a1098 1
    unsigned unacceptable = 0;
d1107 3
d1120 1
a1120 1
    *q++ = '\0';		/* Terminate */
d1136 1
a1136 1
		 unsigned char mask)
d1141 1
a1141 1
    unsigned unacceptable = 0;
d1150 3
d1166 1
a1166 1
    *q++ = '\0';		/* Terminate */
d1178 1
a1178 1
static char from_hex(char c)
d1218 1
a1218 1
    *q++ = '\0';
d1250 1
a1250 1
	    strchr(do_trans, testcode)) {	/* it's one of the ones we want */
d1258 1
a1258 1
    *q++ = '\0';
d1321 2
d1346 1
a1346 1
    *q++ = '\0';		/* Terminate */
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		Parse HyperText Document Address		HTParse.c
d24 2
d199 40
d260 2
a261 1
    int len, len1, len2;
d296 7
a302 1
    result = tail = (char *) LYalloca(len * 2 + len1 + len2);
d346 3
a348 1
	    !strcmp(given.access, "ftp"))
d352 2
a353 1
	    given.absolute = "";
d408 1
d412 2
a413 7
		p2 = strchr(tail, ':');
		if (p2 != NULL && !isdigit(UCH(p2[1])))
		    /*
		     * Colon not followed by a port number.
		     */
		    *p2 = '\0';
		if (p2 != NULL && *p2 != '\0' && acc_method != NULL) {
d417 18
a434 18
#define ACC_METHOD(a,b) (!strcmp(acc_method, a) && !strcmp(p2, b))
		    if (ACC_METHOD("http", ":80") ||
			ACC_METHOD("https", ":443") ||
			ACC_METHOD("gopher", ":70") ||
			ACC_METHOD("ftp", ":21") ||
			ACC_METHOD("wais", ":210") ||
			ACC_METHOD("nntp", ":119") ||
			ACC_METHOD("news", ":119") ||
			ACC_METHOD("newspost", ":119") ||
			ACC_METHOD("newsreply", ":119") ||
			ACC_METHOD("snews", ":563") ||
			ACC_METHOD("snewspost", ":563") ||
			ACC_METHOD("snewsreply", ":563") ||
			ACC_METHOD("finger", ":79") ||
			ACC_METHOD("telnet", ":23") ||
			ACC_METHOD("tn3270", ":23") ||
			ACC_METHOD("rlogin", ":513") ||
			ACC_METHOD("cso", ":105"))
d438 1
a438 1
		    int len3 = strlen(tail);
d625 1
d678 3
a680 1
    for (; *p && *p != '#'; p++) ;
d686 2
d689 4
a692 1
	char *name = (char *) LYalloca((p - aName) + strlen(p) + 1);
d694 12
a705 11
	if (name == NULL) {
	    outofmem(__FILE__, "HTParseAnchor");
	}
	strcpy(name, aName);
	scan(name, &given);
	LYalloca_free(name);

	p++;			/*next to '#' */
	if (given.anchor == NULL) {
	    for (; *p; p++)	/*scroll to end '\0' */
		;
d907 1
a907 1
	int levels = 0;
d927 3
d966 1
a966 1
    int unacceptable = 0;
d971 1
a971 1
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);
d976 1
a976 1
	unsigned char a = TOASCII(*p);
d1006 1
a1006 1
    int unacceptable = 0;
d1011 1
a1011 1
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);
d1016 1
a1016 1
	unsigned char a = TOASCII(*p);
d1046 1
a1046 1
    int unacceptable = 0;
d1051 1
a1051 1
    result = typecallocn(char, p - str + unacceptable + unacceptable + 1);
d1056 1
a1056 1
	unsigned char a = TOASCII(*p);
d1197 1
a1197 1
    int added = 0;
d1204 1
a1204 1
	a = TOASCII(*p);	/* S/390 -- gil -- 0240 */
d1219 1
a1219 1
    result = typecallocn(char, p - (*str) + added + 1);
d1234 1
a1234 1
	a = TOASCII(*p);
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 2
a3 2
**		================================
*/
d24 6
a29 6
	char * access;
	char * host;
	char * absolute;
	char * relative;
	char * search;		/* treated normally as part of path */
	char * anchor;
d32 17
d51 7
a57 8
**	-------------------------------
**
** On exit,
**	Return value points to first non-white character, or to 0 if none.
**	All trailing white space is OVERWRITTEN with zero.
*/
PUBLIC char * HTStrip ARGS1(
	char *,		s)
d60 3
a62 3
    char * p = s;
    for (p = s; *p; p++)
	;			/* Find end of string */
d75 11
a85 12
**	-------------------------------------
**
** On entry,
**	name	points to a document name which may be incomplete.
** On exit,
**	absolute or relative may be nonzero (but not both).
**	host, anchor and access may be nonzero if they were specified.
**	Any which are nonzero point to zero terminated strings.
*/
PRIVATE void scan ARGS2(
	char *,			name,
	struct struct_parts *,	parts)
d87 2
a88 2
    char * after_access;
    char * p;
d98 2
a99 2
    **	Scan left-to-right for a scheme (access).
    */
d102 1
a102 1
	if (*p==':') {
d113 2
a114 2
    **	Scan left-to-right for a fragment (anchor).
    */
d116 1
a116 1
	if (*p =='#') {
d118 1
a118 1
	    *p = '\0';			/* terminate the rest */
d124 2
a125 2
    **	Scan left-to-right for a host or absolute path.
    */
d129 3
a131 3
	    parts->host = (p + 2);	  /* host has been specified	*/
	    *p = '\0';			  /* Terminate access		*/
	    p = strchr(parts->host, '/'); /* look for end of host name if any */
d133 1
a133 1
		*p = '\0';			/* Terminate host */
d138 1
a138 1
		    *p = '\0';			/* Terminate host */
d143 1
a143 1
	    parts->absolute = (p + 1);		/* Root found but no host */
d147 1
a147 1
			     after_access : NULL; /* NULL for "" */
d151 2
a152 2
    **	Check schemes that commonly have unescaped hashes.
    */
d154 1
a154 1
		/* optimize */ strchr("lnsdLNSD", *parts->access) != NULL) {
d161 4
a164 4
	     *	Access specified but no host and not a lynxcgi URL, so the
	     *	anchor may not really be one, e.g., news:j462#36487@@foo.bar,
	     *	or it's an nntp or snews URL, or news URL with a host.
	     *	Restore the '#' in the address.
d174 1
a174 1
} /*scan */
d184 10
d195 16
a210 17
**	--------------------------------------
**
**	This returns those parts of a name which are given (and requested)
**	substituting bits from the related name where necessary.
**
** On entry,
**	aName		A filename given
**	relatedName	A name relative to which aName is to be parsed
**	wanted		A mask for the bits which are wanted.
**
** On exit,
**     returns         A pointer to a malloc'd string which MUST BE FREED
*/
PUBLIC char * HTParse ARGS3(
	CONST char *,	aName,
	CONST char *,	relatedName,
	int,		wanted)
d212 3
a214 3
    char * result = NULL;
    char * tail = NULL;  /* a pointer to the end of the 'result' string */
    char * return_value = NULL;
d216 4
a219 4
    char * name = NULL;
    char * rel = NULL;
    char * p;
    char * acc_method;
d225 1
a225 1
    if (wanted & (PARSE_STRICTPATH | PARSE_QUERY)) { /* if detail wanted... */
d227 4
a230 4
	    == (PARSE_STRICTPATH | PARSE_QUERY)) /* if strictpath AND query */
	    wanted |= PARSE_PATH; /* then treat as if PARSE_PATH wanted */
	if (wanted & PARSE_PATH) /* if PARSE_PATH wanted */
	    wanted &= ~(PARSE_STRICTPATH | PARSE_QUERY); /* ignore details */
d232 1
d241 1
d244 2
a245 2
    ** Allocate the temporary string. Optimized.
    */
d248 1
a248 1
    len = len1 + len2 + 8;     /* Lots of space: more than enough */
d250 1
a250 1
    result = tail = (char*)LYalloca(len * 2 + len1 + len2);
d259 2
a260 2
    **	Make working copy of the input string to cut up.
    */
d264 2
a265 2
    **	Cut up the string into URL fields.
    */
d267 1
d270 2
a271 2
    **	Now related string.
    */
d274 2
a275 2
	**  Inherit nothing!
	*/
d284 1
a284 1
	scan(rel,  &related);
d286 1
a286 1

d289 2
a290 2
    **	Handle the scheme (access) field.
    */
d296 2
a297 2
	    **	Assume root.
	    */
d313 11
a323 15
    **	If different schemes, inherit nothing.
    **
    **	We'll try complying with RFC 1808 and
    **	the Fielding draft, and inherit nothing
    **	if both schemes are given, rather than
    **	only when they differ, except for
    **	file URLs - FM
    **
    **	After trying it for a while, it's still
    **	premature, IHMO, to go along with it, so
    **	this is back to inheriting for identical
    **	schemes whether or not they are "file".
    **	If you want to try it again yourself,
    **	uncomment the strcasecomp() below. - FM
    */
d325 2
a326 2
	(/* strcasecomp(given.access, "file") || */
	 strcmp(given.access, related.access))) {
d335 2
a336 2
    **	Handle the host field.
    */
d347 4
a350 4
	    **	Ignore default port numbers, and trailing dots on FQDNs,
	    **	which will only cause identical addresses to look different.
	    **  (related is already a clean url).
	    */
d353 1
d355 1
a355 1
		   tail = (p2 + 1);
d359 2
a360 2
		    **	Colon not followed by a port number.
		    */
d364 21
a384 20
		    **	Port specified.
		    */
		    if ((!strcmp(acc_method, "http"	 ) && !strcmp(p2, ":80" )) ||
			(!strcmp(acc_method, "https"	 ) && !strcmp(p2, ":443")) ||
			(!strcmp(acc_method, "gopher"	 ) && !strcmp(p2, ":70" )) ||
			(!strcmp(acc_method, "ftp"	 ) && !strcmp(p2, ":21" )) ||
			(!strcmp(acc_method, "wais"	 ) && !strcmp(p2, ":210")) ||
			(!strcmp(acc_method, "nntp"	 ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "news"	 ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "newspost"  ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "newsreply" ) && !strcmp(p2, ":119")) ||
			(!strcmp(acc_method, "snews"	 ) && !strcmp(p2, ":563")) ||
			(!strcmp(acc_method, "snewspost" ) && !strcmp(p2, ":563")) ||
			(!strcmp(acc_method, "snewsreply") && !strcmp(p2, ":563")) ||
			(!strcmp(acc_method, "finger"	 ) && !strcmp(p2, ":79" )) ||
			(!strcmp(acc_method, "telnet"	 ) && !strcmp(p2, ":23" )) ||
			(!strcmp(acc_method, "tn3270"	 ) && !strcmp(p2, ":23" )) ||
			(!strcmp(acc_method, "rlogin"	 ) && !strcmp(p2, ":513")) ||
			(!strcmp(acc_method, "cso"	 ) && !strcmp(p2, ":105")))
		    *p2 = '\0'; /* It is the default: ignore it */
d392 1
a392 1
			    *h = '\0';		/* chop final . */
d396 1
a396 1
		    h--;		/* End of hostname */
d399 2
a400 2
			**  Slide p2 over h.
			*/
d418 6
a423 6
    **	If host in given or related was ended directly with a '?' (no
    **  slash), fake the search part into absolute.  This is the only
    **  case search is returned from scan.  A host must have been present.
    **  this restores the '?' at which the host part had been truncated in
    **  scan, we have to do this after host part handling is done. - kw
    */
d434 2
a435 2
    **	If different hosts, inherit no path.
    */
d444 2
a445 2
    **	Handle the path.
    */
d474 1
a474 1
	if (given.absolute) {			/* All is given */
d479 3
a481 1
	} else if (related.absolute) {		/* Adopt path not name */
d485 21
a505 8
		p = strchr(tail, '?');	/* Search part? */
		if (p == NULL)
		    p = (tail + strlen(tail) - 1);
		for (; *p != '/'; p--)
		    ;				/* last / */
		p[1] = '\0';			/* Remove filename */
		strcat(p, given.relative); /* Add given one */
		HTSimplify (result);
d509 1
a509 1
	    strcpy(tail, given.relative);		/* what we've got */
d514 1
a514 1
	} else {  /* No inheritance */
d545 2
a546 2
    **	Handle the fragment (anchor). Never inherit.
    */
d585 2
a586 1
		char *q = p + strlen(p) + 2;
d607 1
a607 1
	 *  Check whether to fill in localhost. - FM
d613 1
a613 1
    return return_value;		/* exactly the right length */
d617 6
a622 7
**	----------------------------------------------
**
** On exit,
**	returns		A pointer within input string (probably to its end '\0')
*/
PUBLIC CONST char * HTParseAnchor ARGS1(
	CONST char *,	aName)
d624 3
a626 3
    CONST char* p = aName;
    for ( ; *p && *p != '#'; p++)
	;
d633 2
a634 1
	char* name = (char*)LYalloca((p - aName) + strlen(p) + 1);
d642 1
a642 1
	p++; /*next to '#'*/
d644 1
a644 1
	    for ( ; *p; p++)  /*scroll to end '\0'*/
d652 15
a666 16
**	--------------------
**
**  A unix-style file is allowed to contain the sequence xxx/../ which may
**  be replaced by "" , and the sequence "/./" which may be replaced by "/".
**  Simplification helps us recognize duplicate filenames.
**
**	Thus,	/etc/junk/../fred	becomes /etc/fred
**		/etc/junk/./fred	becomes /etc/junk/fred
**
**	but we should NOT change
**		http://fred.xxx.edu/../..
**
**	or	../../albert.html
*/
PUBLIC void HTSimplify ARGS1(
	char *,		filename)
d682 12
a693 14
		**  We're still treating a ?searchpart as part of
		**  the path in HTParse() and scan(), but if we
		**  encounter a '?' here, assume it's the delimiter
		**  and break.	We also could check for a parameter
		**  delimiter (';') here, but the current Fielding
		**  draft (wisely or ill-advisedly :) says that it
		**  should be ignored and collapsing be allowed in
		**  it's value).  The only defined parameter at
		**  present is ;type=[A, I, or D] for ftp URLs, so
		**  if there's a "/..", "/../", "/./", or terminal
		**  '.' following the ';', it must be due to the
		**  ';' being an unescaped path character and not
		**  actually a parameter delimiter. - FM
		*/
d700 2
a701 2
		    **	Handle "../", "..?" or "..".
		    */
d704 2
a705 2
			**  Back up to previous slash or beginning of string.
			*/
d712 3
a714 3
			**  Not at beginning of string or in a
			**  host field, so remove the "/xxx/..".
			*/
d719 1
a719 1
			*p = '\0';		/* terminate */
d721 2
a722 2
			**  Start again with previous slash.
			*/
d727 2
a728 2
		    **	Handle "./" by removing both characters.
		    */
d733 1
a733 1
		    *q = '\0';		/* terminate */
d737 2
a738 2
		    **	Handle ".?" by removing the dot.
		    */
d743 1
a743 1
		    *q = '\0';		/* terminate */
d747 2
a748 2
		    **	Handle terminal "." by removing the character.
		    */
d753 2
a754 2
	if (p >= filename + 2 && *p == '?' && *(p-1)  == '.') {
	    if (*(p-2) == '/') {
d756 2
a757 2
		**  Handle "/.?" by removing the dot.
		*/
d763 8
a770 4
	    } else if (*(p-2) == '.' &&
		       p >= filename + 4 && *(p-3) == '/' &&
		       (*(p-4) != '/' ||
			(p > filename + 4 && *(p-5) != ':'))) {
d772 2
a773 6
		    **	Handle "xxx/..?"
		    */
		for (q = (p - 4); (q > filename) && (*q != '/'); q--)
			/*
			**  Back up to previous slash or beginning of string.
			*/
d776 2
a777 2
		    if (q > filename && *(q-1) == '/' &&
			!(q > filename + 1 && *(q-1) != ':'))
d782 4
a785 5
			/*
			**  Not after "//" at beginning of string or
			**  after "://", and xxx is not ".." or ".",
			**  so remove the "xxx/..".
			*/
d790 1
a790 1
		    *p = '\0';		/* terminate */
d798 18
a815 19
**	-------------------
**
** This function creates and returns a string which gives an expression of
** one address as related to another.  Where there is no relation, an absolute
** address is returned.
**
**  On entry,
**	Both names must be absolute, fully qualified names of nodes
**	(no anchor bits)
**
**  On exit,
**	The return result points to a newly allocated name which, if
**	parsed by HTParse relative to relatedName, will yield aName.
**	The caller is responsible for freeing the resulting name later.
**
*/
PUBLIC char * HTRelative ARGS2(
	CONST char *,	aName,
	CONST char *,	relatedName)
d817 6
a822 6
    char * result = NULL;
    CONST char *p = aName;
    CONST char *q = relatedName;
    CONST char * after_access = NULL;
    CONST char * path = NULL;
    CONST char * last_slash = NULL;
d829 1
a829 1
	    after_access = p+1;
d834 1
a834 1
		path=p;
d840 1
a840 1
    if (!after_access) {			/* Different access */
d842 1
a842 1
    } else if (slashes < 3){			/* Different nodes */
d844 1
a844 1
    } else if (slashes == 3){			/* Same node, different path */
d846 1
a846 1
    } else {					/* Some path in common */
d848 1
d852 2
a853 1
	result = typecallocn(char, 3*levels + strlen(last_slash) + 1);
d859 1
a859 1
	strcat(result, last_slash+1);
d868 11
a878 10
**	-------------------------------------
**
**	This function takes a pointer to a string in which
**	some characters may be unacceptable unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two hex digits.
**
**	Unlike HTUnEscape(), this routine returns a calloc'd string.
*/
PRIVATE CONST unsigned char isAcceptable[96] =
d881 3
a883 3
**	Bit 1		xpalpha		-- as xalpha but with plus.
**	Bit 2 ...	path		-- as xpalphas but with /
*/
d891 3
a894 1
PRIVATE char *hex = "0123456789ABCDEF";
d897 2
a898 3
PUBLIC char * HTEscape ARGS2(
	CONST char *,	str,
	unsigned char,	mask)
d900 3
a902 3
    CONST char * p;
    char * q;
    char * result;
d904 1
d908 2
a909 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d914 1
d919 2
a920 2
	}
	else *q++ = *p;
d927 9
a935 9
**	--------------------------------
**
**	This function takes a pointer to a string in which
**	some characters may be that may be unsafe are unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two hex digits.
**
**	Unlike HTUnEscape(), this routine returns a malloc'd string.
*/
d938 1
a938 2
PUBLIC char *HTEscapeUnsafe ARGS1(
	CONST char *,	str)
d940 3
a942 3
    CONST char * p;
    char * q;
    char * result;
d944 1
d948 2
a949 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d954 1
d959 2
a960 2
	}
	else *q++ = *p;
d967 12
a978 13
**	-----------------------------------------------------
**
**	This function takes a pointer to a string in which
**	some characters may be unacceptable unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two hex digits,
**	except that spaces are converted to '+' instead of %2B.
**
**	Unlike HTUnEscape(), this routine returns a calloced string.
*/
PUBLIC char * HTEscapeSP ARGS2(
	CONST char *,	str,
	unsigned char,	mask)
d980 3
a982 3
    CONST char * p;
    char * q;
    char * result;
d984 1
d988 2
a989 1
    result = typecallocn(char, p-str + unacceptable + unacceptable + 1);
d994 1
d1005 1
a1005 1
    *q++ = '\0';			/* Terminate */
d1010 8
a1017 9
**	------------------------------
**
**	This function takes a pointer to a string in which some
**	characters may have been encoded in %xy form, where xy is
**	the ASCII hex code for character 16x+y.
**	The string is converted in place, as it will never grow.
*/
PRIVATE char from_hex ARGS1(
	char,		c)
d1019 3
a1021 3
    return (char) ( c >= '0' && c <= '9' ?  c - '0'
	    : c >= 'A' && c <= 'F'? c - 'A' + 10
	    : c - 'a' + 10);     /* accept small letters just in case */
d1024 1
a1024 2
PUBLIC char * HTUnEscape ARGS1(
	char *,		str)
d1026 2
a1027 2
    char * p = str;
    char * q = str;
d1034 3
a1036 3
	    /*
	     *	Tests shouldn't be needed, but better safe than sorry.
	     */
d1045 3
a1047 2
		** Careful! FROMASCII() may evaluate its arg more than once!
		*/  /* S/390 -- gil -- 0221 */
d1060 1
a1060 1
} /* HTUnEscape */
d1063 11
a1073 12
**	-----------------------------------			Klaus Weide
**							    (kweide@@tezcat.com)
**	This function takes a pointer to a string in which some
**	characters may have been encoded in %xy form, where xy is
**	the ASCII hex code for character 16x+y, and a pointer to
**	a second string containing one or more characters which
**	should be unescaped if escaped in the first string.
**	The first string is converted in place, as it will never grow.
*/
PUBLIC char * HTUnEscapeSome ARGS2(
	char *,		str,
	CONST char *,	do_trans)
d1075 2
a1076 2
    char * p = str;
    char * q = str;
d1087 3
a1089 3
	    (testcode = (char) FROMASCII(from_hex(p[1])*16 +
		from_hex(p[2]))) && /* %00 no good*/
	    strchr(do_trans, testcode)) { /* it's one of the ones we want */
d1100 3
a1102 3
} /* HTUnEscapeSome */

PRIVATE CONST unsigned char crfc[96] =
d1105 2
a1106 2
**	Bit 1		xpalpha		-- need \escape if quoted
*/
d1114 7
d1123 6
a1128 7
**  Turn a string which is not a RFC 822 token into a quoted-string. - KW
**  The "quoted" parameter tells whether we need the beginning/ending quote
**  marks.  If not, the caller will provide them -TD
*/
PUBLIC void HTMake822Word ARGS2(
	char **,	str,
	int,		quoted)
d1130 3
a1132 3
    CONST char * p;
    char * q;
    char * result;
d1141 1
a1141 1
	a = TOASCII(*p);  /* S/390 -- gil -- 0240 */
d1143 1
a1143 1
	    ((crfc[a-32]) & 1)) {
d1150 1
a1150 1
	    else if ((a & 127) < 32 || ((crfc[a-32]) & 2))
d1156 1
a1156 1
    result = typecallocn(char, p-(*str) + added + 1);
d1164 6
a1169 5
    ** Having converted the character to ASCII, we can't use symbolic
    ** escape codes, since they're in the host character set, which
    ** is not necessarily ASCII.  Thus we use octal escape codes instead.
    ** -- gil (Paul Gilmartin) <pg@@sweng.stortek.com>
    */  /* S/390 -- gil -- 0268 */
d1172 4
a1175 3
	if ((a != '\011') && ((a & 127) < 32 ||
			    ( a < 128 && ((crfc[a-32]) & 2))))
	    *q++ = '\033';
d1177 2
a1178 1
	if (a == '\012' || (a == '\015' && (TOASCII(*(p+1)) != '\012')))
d1183 1
a1183 1
    *q++ = '\0';			/* Terminate */
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d8 1
d10 10
d58 2
a59 2
/*	Scan a filename for its consituents.			scan()
**	------------------------------------
a73 3
#ifdef NOTDEFINED
    int length = strlen(name);
#endif /* NOTDEFINED */
a96 3
#ifdef NOTDEFINED
    for (p = (name + length-1); p >= name; p--) {}
#endif /* NOTDEFINED */
d138 2
a139 1
    if (parts->access && parts->anchor) {
a158 13

#ifdef NOT_DEFINED	/* search is just treated as part of path */
    {
	char *p = (relative ? relative : absolute);
	if (p != NULL) {
	    char *q = strchr(p, '?');	/* Any search string? */
	    if (q != NULL) {
		*q = '\0';		/* If so, chop that off. */
		parts->search = (q + 1);
	    }
	}
    }
#endif /* NOT_DEFINED */
d161 7
d181 1
a181 1
**	returns		A pointer to a calloc'd string which MUST BE FREED
d189 1
d191 1
a191 1
    int len;
d208 9
d218 1
a218 1
    **	Allocate the output string.
d220 5
a224 2
    len = strlen(aName) + strlen(relatedName) + 10;
    result = typecallocn(char, len);	/* Lots of space: more than enough */
d228 3
d233 1
a233 1
    **	Make working copies of the input strings to cut up.
d235 1
a235 2
    StrAllocCopy(name, aName);
    StrAllocCopy(rel, relatedName);
d238 1
a238 1
    **	Cut up the strings into URL fields.
d241 19
a259 1
    scan(rel,  &related);
d276 6
a281 3
	    strcat(result, acc_method);
	    if (wanted & PARSE_PUNCTUATION)
		strcat(result, ":");
d314 1
a314 1
    if (wanted & PARSE_HOST)
d316 5
a320 4
	    char *tail = result + strlen(result);
	    if (wanted & PARSE_PUNCTUATION)
		strcat(result, "//");
	    strcat(result, given.host ? given.host : related.host);
d326 1
d362 1
a362 1
		    int len2 = strlen(tail);
d364 2
a365 2
		    if (len2 > 0) {
			h = tail + len2 - 1;	/* last char of hostname */
d384 7
a397 1
    **
a421 1
	char *tail = NULL;
d423 1
a423 2
	if (want_detail)
	    tail = result + strlen(result);
d425 21
a445 11
	    if (!strcasecomp(acc_method, "nntp") ||
		!strcasecomp(acc_method, "snews") ||
		(!strcasecomp(acc_method, "news") &&
		 !strncasecomp(result, "news://", 7))) {
		/*
		 *  Treat all given nntp or snews paths,
		 *  or given paths for news URLs with a host,
		 *  as absolute.
		 */
		given.absolute = given.relative;
		given.relative = NULL;
d448 1
d451 2
a452 2
		strcat(result, "/");
	    strcat(result, given.absolute);
d455 2
a456 2
	    strcat(result, "/");
	    strcat(result, related.absolute);
d458 1
a458 1
		p = strchr(result, '?');	/* Search part? */
d460 1
a460 1
		    p = (result + strlen(result) - 1);
d464 1
a464 1
		strcat(result, given.relative); /* Add given one */
d469 1
a469 1
	    strcat(result, given.relative);		/* what we've got */
d472 1
a472 1
	    strcat(result, related.relative);
d475 5
a479 4
	    if (strncasecomp(aName, "lynxcgi:", 8) &&
		strncasecomp(aName, "lynxexec:", 9) &&
		strncasecomp(aName, "lynxprog:", 9)) {
		strcat(result, "/");
d505 1
a505 1
    **	Handle the fragment (anchor).
d507 3
a509 3
    if (wanted & PARSE_ANCHOR)
	if ((given.anchor && *given.anchor) ||
	    (!given.anchor && related.anchor)) {
d511 47
a557 7
		strcat(result, "#");
	    strcat(result, (given.anchor) ?
			     given.anchor : related.anchor);
	}
    CTRACE((tfp, "HTParse:      result:%s\n", result));
    FREE(rel);
    FREE(name);
d560 11
a570 1
    FREE(result);
d575 35
d613 2
a614 2
**  A unix-style file is allowed to contain the seqeunce xxx/../ which may
**  be replaced by "" , and the seqeunce "/./" which may be replaced by "/".
a681 9
#ifdef NOTDEFINED
			/*
			**  Make sure filename has at least one slash.
			*/
			if (*filename == '\0') {
			    *filename = '/';
			    *(filename + 1) = '\0';
			}
#endif /* NOTDEFINED */
d694 1
a694 1
		       *q++ = *q1++;
d704 1
a704 1
		       *q++ = *q1++;
d765 1
a765 1
** address is retured.
d824 2
a825 2
	"HTparse: `%s' expressed relative to\n	 `%s' is\n   `%s'.\n",
		aName, relatedName, result));
d837 1
a837 1
**	Unlike HTUnEscape(), this routine returns a calloced string.
d951 1
a951 1
	    *q++ = HEX_ESCAPE;	/* Means hex commming */
d967 1
a967 1
**	the acsii hex code for character 16x+y.
d1021 1
a1021 1
**	the acsii hex code for character 16x+y, and a pointer to
d1072 2
d1075 3
a1077 2
PUBLIC void HTMake822Word ARGS1(
	char **,	str)
d1084 3
a1086 2
    if (!(*str) || !(**str)) {
	StrAllocCopy(*str, "\"\"");
d1108 4
a1111 1
    result[0] = '"';
d1118 1
a1118 1
    for (q = result + 1, p = *str; *p; p++) {
d1127 2
a1128 1
    *q++ = '"';
@


1.3
log
@Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d17 1
a17 1
/*	char * search;		no - treated as part of path */
d22 1
a22 1
/*	Strip white space off a string. 			HTStrip()
d30 1
a30 1
	char *, 	s)
d58 1
a58 1
	char *, 		name,
d71 1
d115 6
d181 1
a181 1
**	returns 	A pointer to a calloc'd string which MUST BE FREED
d197 2
a198 1
    CTRACE(tfp, "HTParse: aName:%s   relatedName:%s\n", aName, relatedName);
d211 1
a211 1
    result = (char *)calloc(1, len);	/* Lots of space: more than enough */
d271 1
d295 1
a295 1
		if (p2 != NULL && !isdigit((unsigned char)p2[1]))
d331 1
a331 1
		} else {
d348 17
d400 1
a400 1
	    CTRACE(tfp, "1\n");
d414 1
a414 1
	    CTRACE(tfp, "2\n");
d417 1
a417 1
	    CTRACE(tfp, "3\n");
d420 1
a420 1
	    CTRACE(tfp, "4\n");
d429 1
a429 1
	    CTRACE(tfp, "5\n");
d461 1
a461 1
    CTRACE(tfp, "HTParse:      result:%s\n", result);
d487 1
a487 1
	char *, 	filename)
d685 1
a685 1
	result = (char *)calloc(1, (3*levels + strlen(last_slash) + 1));
d693 3
a695 2
    CTRACE(tfp, "HT: `%s' expressed relative to\n    `%s' is\n   `%s'.",
		aName, relatedName, result);
d699 1
a699 1
/*	Escape undesirable characters using %		HTEscape()
d712 1
a712 1
**	Bit 1		xpalpha 	-- as xalpha but with plus.
d735 1
a735 1
	if (!ACCEPTABLE((unsigned char)TOASCII(*p)))
d737 1
a737 1
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
d757 1
a757 1
**	some characters that may be unsafe are unescaped.
d759 1
a759 1
**	represented by a '%' character followed by two new hex digits.
d763 1
a763 1
#define UNSAFE(ch) (((ch) <= 32 ) || ((ch) >= 127))
d773 1
a773 1
        if (UNSAFE((unsigned char)TOASCII(*p)))
d775 1
a775 1
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
d777 1
a777 1
       outofmem(__FILE__, "HTEscapeUnsafe");
d779 1
a779 1
       unsigned char a = TOASCII(*p);
d781 5
a785 5
	  *q++ = HEX_ESCAPE;	/* Means hex coming */
	  *q++ = hex[a >> 4];
	  *q++ = hex[a & 15];
       }
       else *q++ = *p;
d811 1
a811 1
	if (!(*p == ' ' || ACCEPTABLE((unsigned char)TOASCII(*p))))
d813 1
a813 1
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
d828 1
a828 1
    *q++ = '\0';		/* Terminate */
d843 1
a843 1
    return  c >= '0' && c <= '9' ?  c - '0'
d845 1
a845 1
	    : c - 'a' + 10;	/* accept small letters just in case */
d849 1
a849 1
	char *, 	str)
d863 2
a864 2
	    isxdigit((unsigned char)p[1]) &&
	    isxdigit((unsigned char)p[2])) {
d867 2
a868 2
	        *q = from_hex(*p++) * 16;
	    if (*p)
d870 1
a870 1
		** Careful!  FROMASCII() may evaluate its arg more than once!
d872 3
a874 2
		*q =           *q + from_hex(*p++) ;
		*q = FROMASCII(*q                 );
d897 1
a897 1
	char *, 	str,
d910 4
a913 3
	    isxdigit((unsigned char)p[1]) &&
	    isxdigit((unsigned char)p[2]) &&
	    (testcode = FROMASCII(from_hex(p[1])*16 + from_hex(p[2]))) && /* %00 no good*/
d930 1
a930 1
**	Bit 1		xpalpha 	-- need \escape if quoted
d971 1
a971 1
    result = (char *)calloc(1, (p-(*str) + added + 1));
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d672 2
a673 2
/*		Escape undesirable characters using %		HTEscape()
**		-------------------------------------
d686 1
a686 1
**	Bit 3 ...	path		-- as xpalphas but with /
d716 1
a716 1
	    *q++ = HEX_ESCAPE;	/* Means hex commming */
d722 39
a760 1
    *q++ = '\0';			/* Terminate */
d801 1
a801 1
    *q++ = '\0';			/* Terminate */
@


1.2.10.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html
@
text
@d672 2
a673 2
/*	Escape undesirable characters using %		HTEscape()
**	-------------------------------------
d686 1
a686 1
**	Bit 2 ...	path		-- as xpalphas but with /
d716 1
a716 1
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
d722 1
a722 39
    *q++ = '\0';		/* Terminate */
    return result;
}

/*	Escape unsafe characters using %			HTEscapeUnsafe()
**	--------------------------------
**
**	This function takes a pointer to a string in which
**	some characters that may be unsafe are unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two new hex digits.
**
**	Unlike HTUnEscape(), this routine returns a malloc'd string.
*/
#define UNSAFE(ch) (((ch) <= 32 ) || ((ch) >= 127))

PUBLIC char *HTEscapeUnsafe ARGS1(
	CONST char *,	str)
{
    CONST char * p;
    char * q;
    char * result;
    int unacceptable = 0;
    for (p = str; *p; p++)
        if (UNSAFE((unsigned char)TOASCII(*p)))
	    unacceptable++;
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
    if (result == NULL)
       outofmem(__FILE__, "HTEscapeUnsafe");
    for (q = result, p = str; *p; p++) {
       unsigned char a = TOASCII(*p);
	if (UNSAFE(a)) {
	  *q++ = HEX_ESCAPE;	/* Means hex coming */
	  *q++ = hex[a >> 4];
	  *q++ = hex[a & 15];
       }
       else *q++ = *p;
    }
    *q++ = '\0';		/* Terminate */
d763 1
a763 1
    *q++ = '\0';		/* Terminate */
@


1.2.12.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d672 2
a673 2
/*	Escape undesirable characters using %		HTEscape()
**	-------------------------------------
d686 1
a686 1
**	Bit 2 ...	path		-- as xpalphas but with /
d716 1
a716 1
	    *q++ = HEX_ESCAPE;	/* Means hex coming */
d722 1
a722 39
    *q++ = '\0';		/* Terminate */
    return result;
}

/*	Escape unsafe characters using %			HTEscapeUnsafe()
**	--------------------------------
**
**	This function takes a pointer to a string in which
**	some characters that may be unsafe are unescaped.
**	It returns a string which has these characters
**	represented by a '%' character followed by two new hex digits.
**
**	Unlike HTUnEscape(), this routine returns a malloc'd string.
*/
#define UNSAFE(ch) (((ch) <= 32 ) || ((ch) >= 127))

PUBLIC char *HTEscapeUnsafe ARGS1(
	CONST char *,	str)
{
    CONST char * p;
    char * q;
    char * result;
    int unacceptable = 0;
    for (p = str; *p; p++)
        if (UNSAFE((unsigned char)TOASCII(*p)))
	    unacceptable++;
    result = (char *)calloc(1, (p-str + unacceptable + unacceptable + 1));
    if (result == NULL)
       outofmem(__FILE__, "HTEscapeUnsafe");
    for (q = result, p = str; *p; p++) {
       unsigned char a = TOASCII(*p);
	if (UNSAFE(a)) {
	  *q++ = HEX_ESCAPE;	/* Means hex coming */
	  *q++ = hex[a >> 4];
	  *q++ = hex[a & 15];
       }
       else *q++ = *p;
    }
    *q++ = '\0';		/* Terminate */
d763 1
a763 1
    *q++ = '\0';		/* Terminate */
@


1.1
log
@Initial revision
@
text
@d5 2
a6 3
#include "HTUtils.h"
#include "tcp.h"
#include "HTParse.h"
d8 1
a8 3
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d190 1
a190 3
    if (TRACE)
	fprintf(stderr,
		"HTParse: aName:%s   relatedName:%s\n", aName, relatedName);
d192 7
d255 1
a255 1
    **	uncomment the strncasecomp() below. - FM
d351 5
a355 1
    if (wanted & PARSE_PATH) {
d374 1
a374 2
	    if (TRACE)
		fprintf(stderr, "1\n");
d388 1
a388 2
	    if (TRACE)
		fprintf(stderr, "2\n");
d391 1
a391 2
	    if (TRACE)
		fprintf(stderr, "3\n");
d394 1
a394 2
	    if (TRACE)
		fprintf(stderr, "4\n");
d403 18
a420 2
	    if (TRACE)
		fprintf(stderr, "5\n");
d435 1
a435 2
    if (TRACE)
	fprintf(stderr, "HTParse: result:%s\n", result);
d608 1
a608 1
** one address as related to another. Where there is no relation, an absolute
d667 1
a667 2
    if (TRACE)
	fprintf(stderr, "HT: `%s' expressed relative to\n    `%s' is\n   `%s'.",
d804 5
a808 1
	        *q = FROMASCII(*q + from_hex(*p++));
d846 1
a846 1
	    (testcode = from_hex(p[1])*16 + from_hex(p[2])) && /* %00 no good*/
d848 1
a848 1
	    *q++ = FROMASCII(testcode);
d889 1
a889 1
	a = *p;
d908 6
d916 1
a916 1
	if ((a != '\t') && ((a & 127) < 32 ||
d918 1
a918 1
	    *q++ = '\\';
d920 1
a920 1
	if (a == '\n' || (a == '\r' && (TOASCII(*(p+1)) != '\n')))
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
