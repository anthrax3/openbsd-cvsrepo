head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.22
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.18
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.16
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.14
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.12
	OPENBSD_5_0:1.4.0.10
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.8
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.18
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.16
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.4;
commitid	EcR8E7r0stjLUV4p;

1.4
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.47;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.43;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.43;	author maja;	state Exp;
branches;
next	;


desc
@@


1.5
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*                                    GROUP FILE ROUTINES

 */

#ifndef HTGROUP_H
#define HTGROUP_H

#include <HTList.h>

#ifdef __cplusplus
extern "C" {
#endif
    typedef HTList GroupDefList;
    typedef HTList ItemList;

    typedef struct {
	char *group_name;
	ItemList *item_list;
    } GroupDef;

/*
 * Access Authorization failure reasons
 */
    typedef enum {
	HTAA_OK,		/* 200 OK                               */
	HTAA_OK_GATEWAY,	/* 200 OK, acting as a gateway          */
	HTAA_NO_AUTH,		/* 401 Unauthorized, not authenticated  */
	HTAA_NOT_MEMBER,	/* 401 Unauthorized, not authorized     */
	HTAA_IP_MASK,		/* 403 Forbidden by IP mask             */
	HTAA_BY_RULE,		/* 403 Forbidden by rule                */
	HTAA_NO_ACL,		/* 403 Forbidden, ACL non-existent      */
	HTAA_NO_ENTRY,		/* 403 Forbidden, no ACL entry          */
	HTAA_SETUP_ERROR,	/* 403 Forbidden, server setup error    */
	HTAA_DOTDOT,		/* 403 Forbidden, URL with /../ illegal */
	HTAA_HTBIN,		/* 403 Forbidden, /htbin not enabled    */
	HTAA_NOT_FOUND		/* 404 Not found, or read protected     */
    } HTAAFailReasonType;

/*

Group definition grammar

  string
                         "sequence of alphanumeric characters"

  user_name
                         string

  group_name
                         string

  group_ref
                         group_name

  user_def
                         user_name | group_ref

  user_def_list
                           user_def { ',' user_def }

  user_part
                         user_def | '(' user_def_list ')'

  templ

                         "sequence of alphanumeric characters and '*'s"

  ip_number_mask
                         templ '.' templ '.' templ '.' templ

  domain_name_mask
                         templ { '.' templ }

  address

                         ip_number_mask | domain_name_mask

  address_def

                         address

  address_def_list
                         address_def { ',' address_def }

  address_part
                         address_def | '(' address_def_list ')'

  item
                         [user_part] ['@@' address_part]

  item_list
                         item { ',' item }

  group_def
                         item_list

  group_decl
                         group_name ':' group_def

  PARSE GROUP DEFINITION

 */

    extern GroupDef *HTAA_parseGroupDef(FILE *fp);

/*

Fill in Pointers to referenced Group Definitions in a Group Definition

   References to groups (by their name) are resolved from group_def_list and pointers to
   those structures are added to group_def.

 */

    extern void HTAA_resolveGroupReferences(GroupDef *group_def,
					    GroupDefList *group_def_list);

/*

Read Group File (and do caching)

   If group file is already in cache returns a pointer to previously read group definition
   list.

 */

    extern GroupDefList *HTAA_readGroupFile(const char *filename);

/*

Delete Group Definition

   Groups in cache should never be freed by this function.  This should only be used to
   free group definitions read by HTAA_parseGroupDef.

 */

    extern void GroupDef_delete(GroupDef *group_def);

/*

Print Out Group Definition (for trace purposes)

 */

    extern void HTAA_printGroupDef(GroupDef *group_def);

/*

Does a User Belong to a Given Set of Groups

   This function checks both the username and the internet address.

 */

/* PUBLIC                                       HTAA_userAndInetInGroup()
 *              CHECK IF USER BELONGS TO TO A GIVEN GROUP
 *              AND THAT THE CONNECTION COMES FROM AN
 *              ADDRESS THAT IS ALLOWED BY THAT GROUP
 * ON ENTRY:
 *      group           the group definition structure.
 *      username        connecting user.
 *      ip_number       browser host IP number, optional.
 *      ip_name         browser host IP name, optional.
 *                      However, one of ip_number or ip_name
 *                      must be given.
 * ON EXIT:
 *      returns         HTAA_IP_MASK, if IP address mask was
 *                      reason for failing.
 *                      HTAA_NOT_MEMBER, if user does not belong
 *                      to the group.
 *                      HTAA_OK if both IP address and user are ok.
 */
    extern HTAAFailReasonType HTAA_userAndInetInGroup(GroupDef *group,
						      char *username,
						      char *ip_number,
						      char *ip_name);

#ifdef __cplusplus
}
#endif
#endif				/* not HTGROUP_H */
@


1.4
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@@


1.3
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d10 28
a37 27

typedef HTList GroupDefList;
typedef HTList ItemList;

typedef struct {
    char *      group_name;
    ItemList *  item_list;
} GroupDef;


/*
** Access Authorization failure reasons
*/
typedef enum {
    HTAA_OK,            /* 200 OK                               */
    HTAA_OK_GATEWAY,    /* 200 OK, acting as a gateway          */
    HTAA_NO_AUTH,       /* 401 Unauthorized, not authenticated  */
    HTAA_NOT_MEMBER,    /* 401 Unauthorized, not authorized     */
    HTAA_IP_MASK,       /* 403 Forbidden by IP mask             */
    HTAA_BY_RULE,       /* 403 Forbidden by rule                */
    HTAA_NO_ACL,        /* 403 Forbidden, ACL non-existent      */
    HTAA_NO_ENTRY,      /* 403 Forbidden, no ACL entry          */
    HTAA_SETUP_ERROR,   /* 403 Forbidden, server setup error    */
    HTAA_DOTDOT,        /* 403 Forbidden, URL with /../ illegal */
    HTAA_HTBIN,         /* 403 Forbidden, /htbin not enabled    */
    HTAA_NOT_FOUND      /* 404 Not found, or read protected     */
} HTAAFailReasonType;
d104 2
a105 1
PUBLIC GroupDef *HTAA_parseGroupDef PARAMS((FILE * fp));
d115 3
a117 2
PUBLIC void HTAA_resolveGroupReferences PARAMS((GroupDef *     group_def,
                                                GroupDefList * group_def_list));
d127 2
a128 1
PUBLIC GroupDefList *HTAA_readGroupFile PARAMS((CONST char * filename));
d138 2
a139 1
PUBLIC void GroupDef_delete PARAMS((GroupDef * group_def));
d146 2
a147 1
PUBLIC void HTAA_printGroupDef PARAMS((GroupDef * group_def));
d157 26
a182 23
**              CHECK IF USER BELONGS TO TO A GIVEN GROUP
**              AND THAT THE CONNECTION COMES FROM AN
**              ADDRESS THAT IS ALLOWED BY THAT GROUP
** ON ENTRY:
**      group           the group definition structure.
**      username        connecting user.
**      ip_number       browser host IP number, optional.
**      ip_name         browser host IP name, optional.
**                      However, one of ip_number or ip_name
**                      must be given.
** ON EXIT:
**      returns         HTAA_IP_MASK, if IP address mask was
**                      reason for failing.
**                      HTAA_NOT_MEMBER, if user does not belong
**                      to the group.
**                      HTAA_OK if both IP address and user are ok.
*/
PUBLIC HTAAFailReasonType HTAA_userAndInetInGroup PARAMS((GroupDef * group,
                                                          char *     username,
                                                          char *     ip_number,
                                                          char *     ip_name));

#endif /* not HTGROUP_H */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a171 3
/*

 */
a173 3
/*

   End of file HTGroup.h.  */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
                                             
d8 2
a9 12
#ifndef HTUTILS_H
#include "HTUtils.h"
#endif /* HTUTILS_H */
#include "HTList.h"

#ifdef SHORT_NAMES
#define HTAApGrD        HTAA_parseGroupDef
#define HTAArGrR        HTAA_resolveGroupReferences
#define HTAApGrD        HTAA_printGroupDef
#define HTAAGD_d        GroupDef_delete
#define HTAAuIIG        HTAA_userAndInetInGroup
#endif /* SHORT_NAMES */
d44 1
a44 1
                         
d47 1
a47 1
                         
d50 1
a50 1
                         
d53 1
a53 1
                         
d56 1
a56 1
                         
d59 1
a59 1
                         
d62 1
a62 1
                         
d64 1
a64 1
                         
d66 1
a66 1
                         
d69 1
a69 1
                         
d72 1
a72 1
                         
d74 1
a74 1
                         
d76 1
a76 1
                         
d78 1
a78 1
                         
d80 1
a80 1
                         
d83 1
a83 1
                         
d86 1
a86 1
                         
d89 1
a89 1
                         
d92 1
a92 1
                         
d95 1
a95 1
                         
d98 1
a98 1
                         
d100 1
a100 1
  
d110 1
a110 1
   
d121 1
a121 1
   
d129 1
a129 1
   Groups in cache should never be freed by this function. This should only be used to
d131 1
a131 1
   
d147 1
a147 1
   
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
