head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.49;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.42;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.42;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTVMS_WaisProt.c,v 1.9 2010/09/24 23:51:22 tom Exp $
 *
 *							  HTVMS_WAISProt.c
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	31-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/

/*
 *	Routines originally from WProt.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.

 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris
 * -	removed chunk code from WAISSearchAPDU,
 * -	added makeWAISQueryType1Query() and readWAISType1Query() which replace
 * makeWAISQueryTerms() and makeWAISQueryDocs().
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 * - renamed makeWAISType1Query() to makeWAISTextQuery()
 * renamed readWAISType1Query() to readWAISTextQuery()
 * 5.29.90  TS - fixed bug in makeWAISQueryDocs
 * added CSTFreeWAISFoo functions
 */

#define _C_WAIS_protocol_

/*	This file implements the Z39.50 extensions required for WAIS
*/

#include <HTUtils.h>
#include <HTVMS_WaisUI.h>
#include <HTVMS_WaisProt.h>

#include <LYLeaks.h>

/* very rough estimates of the size of an object */
#define DefWAISInitResponseSize		(size_t)200
#define DefWAISSearchSize			(size_t)3000
#define DefWAISSearchResponseSize	(size_t)6000
#define DefWAISPresentSize			(size_t)1000
#define DefWAISPresentResponseSize	(size_t)6000
#define DefWAISDocHeaderSize		(size_t)500
#define DefWAISShortHeaderSize		(size_t)200
#define DefWAISLongHeaderSize		(size_t)800
#define DefWAISDocTextSize			(size_t)6000
#define DefWAISDocHeadlineSize		(size_t)500
#define DefWAISDocCodeSize			(size_t)500

#define RESERVE_SPACE_FOR_WAIS_HEADER(len)	\
     if (*len > 0)				\
	*len -= header_len;

#define S_MALLOC(type) (type*)s_malloc(sizeof(type))
#define S_MALLOC2(type) (type*)s_malloc(sizeof(type) * 2)

#define S_REALLOC2(type, ptr, num) (type*)s_realloc((char*)ptr, (sizeof(type) * (num + 2)))

/*----------------------------------------------------------------------*/

static unsigned long userInfoTagSize(data_tag tag,
				     unsigned long length)
/* return the number of bytes required to write the user info tag and
   length
 */
{
    unsigned long size;

    /* calculate bytes required to represent tag.  max tag is 16K */
    size = writtenCompressedIntSize(tag);
    size += writtenCompressedIntSize(length);

    return (size);
}

/*----------------------------------------------------------------------*/

static char *writeUserInfoHeader(data_tag tag,
				 long infoSize,
				 long estHeaderSize,
				 char *buffer,
				 long *len)
/* write the tag and size, making sure the info fits.  return the true end
   of the info (after adjustment) note that the argument infoSize includes
   estHeaderSize.  Note that the argument len is the number of bytes remaining
   in the buffer.  Since we write the tag and size at the begining of the
   buffer (in space that we reserved) we don't want to pass len the calls which
   do that writing.
 */
{
    long dummyLen = 100;	/* plenty of space for a tag and size */
    char *buf = buffer;
    long realSize = infoSize - estHeaderSize;
    long realHeaderSize = userInfoTagSize(tag, realSize);

    if (buffer == NULL || *len == 0)
	return (NULL);

    /* write the tag */
    buf = writeTag(tag, buf, &dummyLen);

    /* see if the if the header size was correct. if not,
       we have to shift the info to fit the real header size */
    if (estHeaderSize != realHeaderSize) {	/* make sure there is enough space */
	CHECK_FOR_SPACE_LEFT(realHeaderSize - estHeaderSize, len);
	memmove(buffer + realHeaderSize, buffer + estHeaderSize, (size_t) (realSize));
    }

    /* write the size */
    writeCompressedInteger(realSize, buf, &dummyLen);

    /* return the true end of buffer */
    return (buffer + realHeaderSize + realSize);
}

/*----------------------------------------------------------------------*/

static char *readUserInfoHeader(data_tag *tag,
				unsigned long *num,
				char *buffer)
/* read the tag and size */
{
    char *buf = buffer;

    buf = readTag(tag, buf);
    buf = readCompressedInteger(num, buf);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISInitResponse *makeWAISInitResponse(long chunkCode,
				       long chunkIDLen,
				       char *chunkMarker,
				       char *highlightMarker,
				       char *deHighlightMarker,
				       char *newLineChars)
/* create a WAIS init response object */
{
    WAISInitResponse *init = S_MALLOC(WAISInitResponse);

    init->ChunkCode = chunkCode;	/* note: none are copied! */
    init->ChunkIDLength = chunkIDLen;
    init->ChunkMarker = chunkMarker;
    init->HighlightMarker = highlightMarker;
    init->DeHighlightMarker = deHighlightMarker;
    init->NewlineCharacters = newLineChars;

    return (init);
}

/*----------------------------------------------------------------------*/

void freeWAISInitResponse(WAISInitResponse *init)
/* free an object made with makeWAISInitResponse */
{
    s_free(init->ChunkMarker);
    s_free(init->HighlightMarker);
    s_free(init->DeHighlightMarker);
    s_free(init->NewlineCharacters);
    s_free(init);
}

/*----------------------------------------------------------------------*/

char *writeInitResponseInfo(InitResponseAPDU *init,
			    char *buffer,
			    long *len)
/* write an init response object */
{
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISInitResponseSize);
    char *buf = buffer + header_len;
    WAISInitResponse *info = (WAISInitResponse *) init->UserInformationField;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeNum(info->ChunkCode, DT_ChunkCode, buf, len);
    buf = writeNum(info->ChunkIDLength, DT_ChunkIDLength, buf, len);
    buf = writeString(info->ChunkMarker, DT_ChunkMarker, buf, len);
    buf = writeString(info->HighlightMarker, DT_HighlightMarker, buf, len);
    buf = writeString(info->DeHighlightMarker, DT_DeHighlightMarker, buf, len);
    buf = writeString(info->NewlineCharacters, DT_NewlineCharacters, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readInitResponseInfo(void **info,
			   char *buffer)
/* read an init response object */
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    long chunkCode, chunkIDLen;
    data_tag tag1;
    char *chunkMarker = NULL;
    char *highlightMarker = NULL;
    char *deHighlightMarker = NULL;
    char *newLineChars = NULL;

    chunkCode = chunkIDLen = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ChunkCode:
	    buf = readNum(&chunkCode, buf);
	    break;
	case DT_ChunkIDLength:
	    buf = readNum(&chunkIDLen, buf);
	    break;
	case DT_ChunkMarker:
	    buf = readString(&chunkMarker, buf);
	    break;
	case DT_HighlightMarker:
	    buf = readString(&highlightMarker, buf);
	    break;
	case DT_DeHighlightMarker:
	    buf = readString(&deHighlightMarker, buf);
	    break;
	case DT_NewlineCharacters:
	    buf = readString(&newLineChars, buf);
	    break;
	default:
	    s_free(highlightMarker);
	    s_free(deHighlightMarker);
	    s_free(newLineChars);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *info = (void *) makeWAISInitResponse(chunkCode, chunkIDLen, chunkMarker,
					  highlightMarker, deHighlightMarker,
					  newLineChars);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISSearch *makeWAISSearch(char *seedWords,
			   DocObj **docs,
			   char **textList,
			   long dateFactor,
			   char *beginDateRange,
			   char *endDateRange,
			   long maxDocsRetrieved)

/* create a type 3 query object */
{
    WAISSearch *query = S_MALLOC(WAISSearch);

    query->SeedWords = seedWords;	/* not copied! */
    query->Docs = docs;		/* not copied! */
    query->TextList = textList;	/* not copied! */
    query->DateFactor = dateFactor;
    query->BeginDateRange = beginDateRange;
    query->EndDateRange = endDateRange;
    query->MaxDocumentsRetrieved = maxDocsRetrieved;

    return (query);
}

/*----------------------------------------------------------------------*/

void freeWAISSearch(WAISSearch *query)

/* destroy an object made with makeWAISSearch() */
{
    void *ptr = NULL;
    long i;

    s_free(query->SeedWords);

    if (query->Docs != NULL)
	for (i = 0, ptr = (void *) query->Docs[i];
	     ptr != NULL;
	     ptr = (void *) query->Docs[++i])
	    freeDocObj((DocObj *) ptr);
    s_free(query->Docs);

    if (query->TextList != NULL)	/* XXX revisit when textlist is fully defined */
	for (i = 0, ptr = (void *) query->TextList[i];
	     ptr != NULL;
	     ptr = (void *) query->TextList[++i])
	    s_free(ptr);
    s_free(query->TextList);

    s_free(query->BeginDateRange);
    s_free(query->EndDateRange);
    s_free(query);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingWholeDocument(any *docID,
				     char *type)

/* construct a document object using byte chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->DocumentID = docID;	/* not copied! */
    doc->Type = type;		/* not copied! */
    doc->ChunkCode = CT_document;
    return (doc);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingLines(any *docID,
			     char *type,
			     long start,
			     long end)

/* construct a document object using line chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_line;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingBytes(any *docID,
			     char *type,
			     long start,
			     long end)

/* construct a document object using byte chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_byte;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;		/* not copied! */
    doc->ChunkStart.Pos = start;
    doc->ChunkEnd.Pos = end;
    return (doc);
}

/*----------------------------------------------------------------------*/

DocObj *makeDocObjUsingParagraphs(any *docID,
				  char *type,
				  any *start,
				  any *end)

/* construct a document object using byte chunks - only for use by
   servers */
{
    DocObj *doc = S_MALLOC(DocObj);

    doc->ChunkCode = CT_paragraph;
    doc->DocumentID = docID;	/* not copied */
    doc->Type = type;
    doc->ChunkStart.ID = start;
    doc->ChunkEnd.ID = end;
    return (doc);
}

/*----------------------------------------------------------------------*/

void freeDocObj(DocObj *doc)

/* free a docObj */
{
    freeAny(doc->DocumentID);
    s_free(doc->Type);
    if (doc->ChunkCode == CT_paragraph) {
	freeAny(doc->ChunkStart.ID);
	freeAny(doc->ChunkEnd.ID);
    }
    s_free(doc);
}

/*----------------------------------------------------------------------*/

static char *writeDocObj(DocObj *doc,
			 char *buffer,
			 long *len)

/* write as little as we can about the doc obj */
{
    char *buf = buffer;

    /* we alwasy have to write the id, but its tag depends on if its a chunk */
    if (doc->ChunkCode == CT_document)
	buf = writeAny(doc->DocumentID, DT_DocumentID, buf, len);
    else
	buf = writeAny(doc->DocumentID, DT_DocumentIDChunk, buf, len);

    if (doc->Type != NULL)
	buf = writeString(doc->Type, DT_TYPE, buf, len);

    switch (doc->ChunkCode) {
    case CT_document:
	/* do nothing - there is no chunk data */
	break;
    case CT_byte:
    case CT_line:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeNum(doc->ChunkStart.Pos, DT_ChunkStartID, buf, len);
	buf = writeNum(doc->ChunkEnd.Pos, DT_ChunkEndID, buf, len);
	break;
    case CT_paragraph:
	buf = writeNum(doc->ChunkCode, DT_ChunkCode, buf, len);
	buf = writeAny(doc->ChunkStart.ID, DT_ChunkStartID, buf, len);
	buf = writeAny(doc->ChunkEnd.ID, DT_ChunkEndID, buf, len);
	break;
    default:
	panic("Implementation error: unknown chuck type %ld",
	      doc->ChunkCode);
	break;
    }

    return (buf);
}

/*----------------------------------------------------------------------*/

static char *readDocObj(DocObj **doc,
			char *buffer)

/* read whatever we have about the new document */
{
    char *buf = buffer;
    data_tag tag;

    *doc = S_MALLOC(DocObj);

    tag = peekTag(buf);
    buf = readAny(&((*doc)->DocumentID), buf);

    if (tag == DT_DocumentID) {
	(*doc)->ChunkCode = CT_document;
	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != what comes next */
	    buf = readString(&((*doc)->Type), buf);
	/* ChunkStart and ChunkEnd are undefined */
    } else if (tag == DT_DocumentIDChunk) {
	boolean readParagraphs = false;		/* for cleanup */

	tag = peekTag(buf);
	if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != CT_FOO */
	    buf = readString(&((*doc)->Type), buf);
	buf = readNum(&((*doc)->ChunkCode), buf);
	switch ((*doc)->ChunkCode) {
	case CT_byte:
	case CT_line:
	    buf = readNum(&((*doc)->ChunkStart.Pos), buf);
	    buf = readNum(&((*doc)->ChunkEnd.Pos), buf);
	    break;
	case CT_paragraph:
	    buf = readAny(&((*doc)->ChunkStart.ID), buf);
	    buf = readAny(&((*doc)->ChunkEnd.ID), buf);
	    break;
	default:
	    freeAny((*doc)->DocumentID);
	    if (readParagraphs) {
		freeAny((*doc)->ChunkStart.ID);
		freeAny((*doc)->ChunkEnd.ID);
	    }
	    s_free(doc);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    } else {
	freeAny((*doc)->DocumentID);
	s_free(*doc);
	REPORT_READ_ERROR(buf);
    }
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writeSearchInfo(SearchAPDU *query,
		      char *buffer,
		      long *len)

/* write out a WAIS query (type 1 or 3) */
{
    if (strcmp(query->QueryType, QT_TextRetrievalQuery) == 0) {
	return (writeAny((any *) query->Query, DT_Query, buffer, len));
    } else {
	unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
						   DefWAISSearchSize);
	char *buf = buffer + header_len;
	WAISSearch *info = (WAISSearch *) query->Query;
	unsigned long size;
	long i;

	RESERVE_SPACE_FOR_WAIS_HEADER(len);

	buf = writeString(info->SeedWords, DT_SeedWords, buf, len);

	if (info->Docs != NULL) {
	    for (i = 0; info->Docs[i] != NULL; i++) {
		buf = writeDocObj(info->Docs[i], buf, len);
	    }
	}

	/* XXX text list */

	buf = writeNum(info->DateFactor,
		       DT_DateFactor,
		       buf,
		       len);
	buf = writeString(info->BeginDateRange,
			  DT_BeginDateRange,
			  buf,
			  len);
	buf = writeString(info->EndDateRange,
			  DT_EndDateRange,
			  buf,
			  len);
	buf = writeNum(info->MaxDocumentsRetrieved,
		       DT_MaxDocumentsRetrieved,
		       buf,
		       len);

	/* now write the header and size */
	size = buf - buffer;
	buf = writeUserInfoHeader(DT_UserInformationLength,
				  size,
				  header_len,
				  buffer,
				  len);

	return (buf);
    }
}

/*----------------------------------------------------------------------*/

char *readSearchInfo(void **info,
		     char *buffer)

/* read a WAIS query (type 1 or 3) */
{
    data_tag type = peekTag(buffer);

    if (type == DT_Query)	/* this is a type 1 query */
    {
	char *buf = buffer;
	any *query = NULL;

	buf = readAny(&query, buf);
	*info = (void *) query;
	return (buf);
    } else {			/* a type 3 query */
	char *buf = buffer;
	unsigned long size;
	unsigned long headerSize;
	data_tag tag1;
	char *seedWords = NULL;
	char *beginDateRange = NULL;
	char *endDateRange = NULL;
	long dateFactor, maxDocsRetrieved;
	char **textList = NULL;
	DocObj **docIDs = NULL;
	DocObj *doc = NULL;
	long docs = 0;
	long i;
	void *ptr = NULL;

	dateFactor = maxDocsRetrieved = UNUSED;

	buf = readUserInfoHeader(&tag1, &size, buf);
	headerSize = buf - buffer;

	while (buf < (buffer + size + headerSize)) {
	    data_tag tag = peekTag(buf);

	    switch (tag) {
	    case DT_SeedWords:
		buf = readString(&seedWords, buf);
		break;
	    case DT_DocumentID:
	    case DT_DocumentIDChunk:
		if (docIDs == NULL)	/* create a new doc list */
		{
		    docIDs = S_MALLOC2(DocObj *);
		} else {	/* grow the doc list */
		    docIDs = S_REALLOC2(DocObj *, docIDs, docs);
		}
		buf = readDocObj(&doc, buf);
		if (buf == NULL) {
		    s_free(seedWords);
		    s_free(beginDateRange);
		    s_free(endDateRange);
		    if (docIDs != NULL)
			for (i = 0, ptr = (void *) docIDs[i];
			     ptr != NULL;
			     ptr = (void *) docIDs[++i])
			    freeDocObj((DocObj *) ptr);
		    s_free(docIDs);
		    /* XXX should also free textlist when it is fully defined */
		}
		RETURN_ON_NULL(buf);
		docIDs[docs++] = doc;	/* put it in the list */
		docIDs[docs] = NULL;
		break;
	    case DT_TextList:
		/* XXX */
		break;
	    case DT_DateFactor:
		buf = readNum(&dateFactor, buf);
		break;
	    case DT_BeginDateRange:
		buf = readString(&beginDateRange, buf);
		break;
	    case DT_EndDateRange:
		buf = readString(&endDateRange, buf);
		break;
	    case DT_MaxDocumentsRetrieved:
		buf = readNum(&maxDocsRetrieved, buf);
		break;
	    default:
		s_free(seedWords);
		s_free(beginDateRange);
		s_free(endDateRange);
		if (docIDs != NULL)
		    for (i = 0, ptr = (void *) docIDs[i];
			 ptr != NULL;
			 ptr = (void *) docIDs[++i])
			freeDocObj((DocObj *) ptr);
		s_free(docIDs);
		/* XXX should also free textlist when it is fully defined */
		REPORT_READ_ERROR(buf);
		break;
	    }
	}

	*info = (void *) makeWAISSearch(seedWords, docIDs, textList,
					dateFactor, beginDateRange, endDateRange,
					maxDocsRetrieved);
	return (buf);
    }
}

/*----------------------------------------------------------------------*/

WAISDocumentHeader *makeWAISDocumentHeader(any *docID,
					   long versionNumber,
					   long score,
					   long bestMatch,
					   long docLen,
					   long lines,
					   char **types,
					   char *source,
					   char *date,
					   char *headline,
					   char *originCity)

/* construct a standard document header, note that no fields are copied!
   if the application needs to save these fields, it should copy them,
   or set the field in this object to NULL before freeing it.
 */
{
    WAISDocumentHeader *header = S_MALLOC(WAISDocumentHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeader(WAISDocumentHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here ! */
    s_free(header->Types);
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeader(WAISDocumentHeader *header, char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeaderGroup,
					       DefWAISDocHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
	}
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeader(WAISDocumentHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types = NULL;
    char *source = NULL;
    char *date = NULL;
    char *headline = NULL;
    char *originCity = NULL;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		buf = readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
		}
	    }
	    /* FALLTHRU */
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *header = makeWAISDocumentHeader(docID, versionNumber, score, bestMatch,
				     docLength, lines, types, source, date, headline,
				     originCity);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentShortHeader *makeWAISDocumentShortHeader(any *docID,
						     long versionNumber,
						     long score,
						     long bestMatch,
						     long docLen,
						     long lines)
/* construct a short document header, note that no fields are copied!
   if the application needs to save these fields, it should copy them,
   or set the field in this object to NULL before freeing it.
 */
{
    WAISDocumentShortHeader *header = S_MALLOC(WAISDocumentShortHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
{
    freeAny(header->DocumentID);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentShortHeader(WAISDocumentShortHeader *header, char *buffer,
				   long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentShortHeaderGroup,
					       DefWAISShortHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentShortHeaderGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentShortHeader(WAISDocumentShortHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID = NULL;
    long versionNumber, score, bestMatch, docLength, lines;

    versionNumber = score = bestMatch = docLength = lines = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	default:
	    freeAny(docID);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *header = makeWAISDocumentShortHeader(docID, versionNumber, score, bestMatch,
					  docLength, lines);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentLongHeader *makeWAISDocumentLongHeader(any *docID,
						   long versionNumber,
						   long score,
						   long bestMatch,
						   long docLen,
						   long lines,
						   char **types,
						   char *source,
						   char *date,
						   char *headline,
						   char *originCity,
						   char *stockCodes,
						   char *companyCodes,
						   char *industryCodes)
/* construct a long document header, note that no fields are copied!
   if the application needs to save these fields, it should copy them,
   or set the field in this object to NULL before freeing it.
 */
{
    WAISDocumentLongHeader *header = S_MALLOC(WAISDocumentLongHeader);

    header->DocumentID = docID;
    header->VersionNumber = versionNumber;
    header->Score = score;
    header->BestMatch = bestMatch;
    header->DocumentLength = docLen;
    header->Lines = lines;
    header->Types = types;
    header->Source = source;
    header->Date = date;
    header->Headline = headline;
    header->OriginCity = originCity;
    header->StockCodes = stockCodes;
    header->CompanyCodes = companyCodes;
    header->IndustryCodes = industryCodes;

    return (header);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
{
    freeAny(header->DocumentID);
    doList((void **) header->Types, fs_free);	/* can't use the macro here! */
    s_free(header->Source);
    s_free(header->Date);
    s_free(header->Headline);
    s_free(header->OriginCity);
    s_free(header->StockCodes);
    s_free(header->CompanyCodes);
    s_free(header->IndustryCodes);
    s_free(header);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentLongHeader(WAISDocumentLongHeader *header, char *buffer,
				  long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentLongHeaderGroup,
					       DefWAISLongHeaderSize);
    char *buf = buffer + header_len;
    unsigned long size1;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(header->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(header->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeNum(header->Score, DT_Score, buf, len);
    buf = writeNum(header->BestMatch, DT_BestMatch, buf, len);
    buf = writeNum(header->DocumentLength, DT_DocumentLength, buf, len);
    buf = writeNum(header->Lines, DT_Lines, buf, len);
    if (header->Types != NULL) {
	long size;
	char *ptr = NULL;
	long i;

	buf = writeTag(DT_TYPE_BLOCK, buf, len);
	for (i = 0, size = 0, ptr = header->Types[i];
	     ptr != NULL;
	     ptr = header->Types[++i]) {
	    long typeSize = strlen(ptr);

	    size += writtenTagSize(DT_TYPE);
	    size += writtenCompressedIntSize(typeSize);
	    size += typeSize;
	}
	buf = writeCompressedInteger((unsigned long) size, buf, len);
	for (i = 0, ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	    buf = writeString(ptr, DT_TYPE, buf, len);
    }
    buf = writeString(header->Source, DT_Source, buf, len);
    buf = writeString(header->Date, DT_Date, buf, len);
    buf = writeString(header->Headline, DT_Headline, buf, len);
    buf = writeString(header->OriginCity, DT_OriginCity, buf, len);
    buf = writeString(header->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(header->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(header->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size1 = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,
			      size1,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentLongHeader(WAISDocumentLongHeader **header, char *buffer)
{
    char *buf = buffer;
    unsigned long size1;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber, score, bestMatch, docLength, lines;
    char **types;
    char *source, *date, *headline, *originCity, *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber =
	score =
	bestMatch =
	docLength =
	lines = UNUSED;
    types = NULL;
    source =
	date =
	headline =
	originCity =
	stockCodes =
	companyCodes =
	industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size1, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size1 + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Score:
	    buf = readNum(&score, buf);
	    break;
	case DT_BestMatch:
	    buf = readNum(&bestMatch, buf);
	    break;
	case DT_DocumentLength:
	    buf = readNum(&docLength, buf);
	    break;
	case DT_Lines:
	    buf = readNum(&lines, buf);
	    break;
	case DT_TYPE_BLOCK:
	    {
		unsigned long size = -1;
		long numTypes = 0;

		buf = readTag(&tag, buf);
		readCompressedInteger(&size, buf);
		while (size > 0) {
		    char *type = NULL;
		    char *originalBuf = buf;

		    buf = readString(&type, buf);
		    types = S_REALLOC2(char *, types, numTypes);

		    types[numTypes++] = type;
		    types[numTypes] = NULL;
		    size -= (buf - originalBuf);
		}
	    }
	    /* FALLTHRU */
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
	    break;
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
	    break;
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    s_free(stockCodes);
	    s_free(companyCodes);
	    s_free(industryCodes);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *header = makeWAISDocumentLongHeader(docID,
					 versionNumber,
					 score,
					 bestMatch,
					 docLength,
					 lines,
					 types,
					 source,
					 date,
					 headline,
					 originCity,
					 stockCodes,
					 companyCodes,
					 industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISSearchResponse *
  makeWAISSearchResponse(
			    char *seedWordsUsed,
			    WAISDocumentHeader **docHeaders,
			    WAISDocumentShortHeader **shortHeaders,
			    WAISDocumentLongHeader **longHeaders,
			    WAISDocumentText **text,
			    WAISDocumentHeadlines **headlines,
			    WAISDocumentCodes **codes,
			    diagnosticRecord ** diagnostics)
{
    WAISSearchResponse *response = S_MALLOC(WAISSearchResponse);

    response->SeedWordsUsed = seedWordsUsed;
    response->DocHeaders = docHeaders;
    response->ShortHeaders = shortHeaders;
    response->LongHeaders = longHeaders;
    response->Text = text;
    response->Headlines = headlines;
    response->Codes = codes;
    response->Diagnostics = diagnostics;

    return (response);
}

/*----------------------------------------------------------------------*/

void freeWAISSearchResponse(WAISSearchResponse * response)
{
    void *ptr = NULL;
    long i;

    s_free(response->SeedWordsUsed);

    if (response->DocHeaders != NULL)
	for (i = 0, ptr = (void *) response->DocHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->DocHeaders[++i])
	    freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
    s_free(response->DocHeaders);

    if (response->ShortHeaders != NULL)
	for (i = 0, ptr = (void *) response->ShortHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->ShortHeaders[++i])
	    freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
    s_free(response->ShortHeaders);

    if (response->LongHeaders != NULL)
	for (i = 0, ptr = (void *) response->LongHeaders[i];
	     ptr != NULL;
	     ptr = (void *) response->LongHeaders[++i])
	    freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
    s_free(response->LongHeaders);

    if (response->Text != NULL)
	for (i = 0, ptr = (void *) response->Text[i];
	     ptr != NULL;
	     ptr = (void *) response->Text[++i])
	    freeWAISDocumentText((WAISDocumentText *) ptr);
    s_free(response->Text);

    if (response->Headlines != NULL)
	for (i = 0, ptr = (void *) response->Headlines[i];
	     ptr != NULL;
	     ptr = (void *) response->Headlines[++i])
	    freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
    s_free(response->Headlines);

    if (response->Codes != NULL)
	for (i = 0, ptr = (void *) response->Codes[i];
	     ptr != NULL;
	     ptr = (void *) response->Codes[++i])
	    freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
    s_free(response->Codes);

    if (response->Diagnostics != NULL)
	for (i = 0, ptr = (void *) response->Diagnostics[i];
	     ptr != NULL;
	     ptr = (void *) response->Diagnostics[++i])
	    freeDiag((diagnosticRecord *) ptr);
    s_free(response->Diagnostics);

    s_free(response);
}

/*----------------------------------------------------------------------*/

char *writeSearchResponseInfo(SearchResponseAPDU *query,
			      char *buffer,
			      long *len)
{
    unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					       DefWAISSearchResponseSize);
    char *buf = buffer + header_len;
    WAISSearchResponse *info = (WAISSearchResponse *) query->DatabaseDiagnosticRecords;
    unsigned long size;
    void *header = NULL;
    long i;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeString(info->SeedWordsUsed, DT_SeedWordsUsed, buf, len);

    /* write out all the headers */
    if (info->DocHeaders != NULL) {
	for (i = 0, header = (void *) info->DocHeaders[i];
	     header != NULL;
	     header = (void *) info->DocHeaders[++i])
	    buf = writeWAISDocumentHeader((WAISDocumentHeader *) header, buf, len);
    }

    if (info->ShortHeaders != NULL) {
	for (i = 0, header = (void *) info->ShortHeaders[i];
	     header != NULL;
	     header = (void *) info->ShortHeaders[++i])
	    buf = writeWAISDocumentShortHeader((WAISDocumentShortHeader *) header,
					       buf,
					       len);
    }

    if (info->LongHeaders != NULL) {
	for (i = 0, header = (void *) info->LongHeaders[i];
	     header != NULL;
	     header = (void *) info->LongHeaders[++i])
	    buf = writeWAISDocumentLongHeader((WAISDocumentLongHeader *) header,
					      buf,
					      len);
    }

    if (info->Text != NULL) {
	for (i = 0, header = (void *) info->Text[i];
	     header != NULL;
	     header = (void *) info->Text[++i])
	    buf = writeWAISDocumentText((WAISDocumentText *) header, buf, len);
    }

    if (info->Headlines != NULL) {
	for (i = 0, header = (void *) info->Headlines[i];
	     header != NULL;
	     header = (void *) info->Headlines[++i])
	    buf = writeWAISDocumentHeadlines((WAISDocumentHeadlines *) header,
					     buf,
					     len);
    }

    if (info->Codes != NULL) {
	for (i = 0, header = (void *) info->Codes[i];
	     header != NULL;
	     header = (void *) info->Codes[++i])
	    buf = writeWAISDocumentCodes((WAISDocumentCodes *) header, buf, len);
    }

    if (info->Diagnostics != NULL) {
	for (i = 0, header = (void *) info->Diagnostics[i];
	     header != NULL;
	     header = (void *) info->Diagnostics[++i])
	    buf = writeDiag((diagnosticRecord *) header, buf, len);
    }

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_UserInformationLength,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

static void cleanUpWaisSearchResponse(char *buf,
				      char *seedWordsUsed,
				      WAISDocumentHeader **docHeaders,
				      WAISDocumentShortHeader **shortHeaders,
				      WAISDocumentLongHeader **longHeaders,
				      WAISDocumentText **text,
				      WAISDocumentHeadlines **headlines,
				      WAISDocumentCodes **codes,
				      diagnosticRecord ** diags)
/* if buf is NULL, we have just gotten a read error, and need to clean up
   any state we have built.  If not, then everything is going fine, and
   we should just hang loose
 */
{
    void *ptr = NULL;
    long i;

    if (buf == NULL) {
	s_free(seedWordsUsed);
	if (docHeaders != NULL)
	    for (i = 0, ptr = (void *) docHeaders[i]; ptr != NULL;
		 ptr = (void *) docHeaders[++i])
		freeWAISDocumentHeader((WAISDocumentHeader *) ptr);
	s_free(docHeaders);
	if (shortHeaders != NULL)
	    for (i = 0, ptr = (void *) shortHeaders[i]; ptr != NULL;
		 ptr = (void *) shortHeaders[++i])
		freeWAISDocumentShortHeader((WAISDocumentShortHeader *) ptr);
	s_free(shortHeaders);
	if (longHeaders != NULL)
	    for (i = 0, ptr = (void *) longHeaders[i]; ptr != NULL;
		 ptr = (void *) longHeaders[++i])
		freeWAISDocumentLongHeader((WAISDocumentLongHeader *) ptr);
	s_free(longHeaders);
	if (text != NULL)
	    for (i = 0, ptr = (void *) text[i];
		 ptr != NULL;
		 ptr = (void *) text[++i])
		freeWAISDocumentText((WAISDocumentText *) ptr);
	s_free(text);
	if (headlines != NULL)
	    for (i = 0, ptr = (void *) headlines[i]; ptr != NULL;
		 ptr = (void *) headlines[++i])
		freeWAISDocumentHeadlines((WAISDocumentHeadlines *) ptr);
	s_free(headlines);
	if (codes != NULL)
	    for (i = 0, ptr = (void *) codes[i]; ptr != NULL;
		 ptr = (void *) codes[++i])
		freeWAISDocumentCodes((WAISDocumentCodes *) ptr);
	s_free(codes);
	if (diags != NULL)
	    for (i = 0, ptr = (void *) diags[i]; ptr != NULL;
		 ptr = (void *) diags[++i])
		freeDiag((diagnosticRecord *) ptr);
	s_free(diags);
    }
}

/*----------------------------------------------------------------------*/

char *readSearchResponseInfo(void **info,
			     char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    void *header = NULL;
    WAISDocumentHeader **docHeaders = NULL;
    WAISDocumentShortHeader **shortHeaders = NULL;
    WAISDocumentLongHeader **longHeaders = NULL;
    WAISDocumentText **text = NULL;
    WAISDocumentHeadlines **headlines = NULL;
    WAISDocumentCodes **codes = NULL;
    long numDocHeaders, numLongHeaders, numShortHeaders, numText, numHeadlines;
    long numCodes;
    char *seedWordsUsed = NULL;
    diagnosticRecord **diags = NULL;
    diagnosticRecord *diag = NULL;
    long numDiags = 0;

    numDocHeaders =
	numLongHeaders =
	numShortHeaders =
	numText =
	numHeadlines =
	numCodes = 0;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_SeedWordsUsed:
	    buf = readString(&seedWordsUsed, buf);
	    break;
	case DT_DatabaseDiagnosticRecords:
	    if (diags == NULL)	/* create a new diag list */
	    {
		diags = S_MALLOC2(diagnosticRecord *);
	    } else {		/* grow the diag list */
		diags = S_REALLOC2(diagnosticRecord *, diags, numDiags);
	    }
	    buf = readDiag(&diag, buf);
	    diags[numDiags++] = diag;	/* put it in the list */
	    diags[numDiags] = NULL;
	    break;
	case DT_DocumentHeaderGroup:
	    if (docHeaders == NULL)	/* create a new header list */
	    {
		docHeaders = S_MALLOC2(WAISDocumentHeader *);
	    } else {		/* grow the doc list */
		docHeaders = S_REALLOC2(WAISDocumentHeader *, docHeaders, numDocHeaders);
	    }
	    buf = readWAISDocumentHeader((WAISDocumentHeader **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    docHeaders[numDocHeaders++] =
		(WAISDocumentHeader *) header;	/* put it in the list */
	    docHeaders[numDocHeaders] = NULL;
	    break;
	case DT_DocumentShortHeaderGroup:
	    if (shortHeaders == NULL)	/* create a new header list */
	    {
		shortHeaders = S_MALLOC2(WAISDocumentShortHeader *);
	    } else {		/* grow the doc list */
		shortHeaders = S_REALLOC2(WAISDocumentShortHeader *,
					  shortHeaders,
					  numShortHeaders);
	    }
	    buf = readWAISDocumentShortHeader((WAISDocumentShortHeader **) &header,
					      buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    shortHeaders[numShortHeaders++] =
		(WAISDocumentShortHeader *) header;	/* put it in the list */
	    shortHeaders[numShortHeaders] = NULL;
	    break;
	case DT_DocumentLongHeaderGroup:
	    if (longHeaders == NULL)	/* create a new header list */
	    {
		longHeaders = S_MALLOC2(WAISDocumentLongHeader *);
	    } else {		/* grow the doc list */
		longHeaders = S_REALLOC2(WAISDocumentLongHeader *,
					 longHeaders,
					 numLongHeaders);
	    }
	    buf = readWAISDocumentLongHeader((WAISDocumentLongHeader **) &header,
					     buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    longHeaders[numLongHeaders++] =
		(WAISDocumentLongHeader *) header;	/* put it in the list */
	    longHeaders[numLongHeaders] = NULL;
	    break;
	case DT_DocumentTextGroup:
	    if (text == NULL)	/* create a new list */
	    {
		text = S_MALLOC2(WAISDocumentText *);
	    } else {		/* grow the list */
		text = S_REALLOC2(WAISDocumentText *, text, numText);
	    }
	    buf = readWAISDocumentText((WAISDocumentText **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    text[numText++] =
		(WAISDocumentText *) header;	/* put it in the list */
	    text[numText] = NULL;
	    break;
	case DT_DocumentHeadlineGroup:
	    if (headlines == NULL)	/* create a new list */
	    {
		headlines = S_MALLOC2(WAISDocumentHeadlines *);
	    } else {		/* grow the list */
		headlines = S_REALLOC2(WAISDocumentHeadlines *, headlines, numHeadlines);
	    }
	    buf = readWAISDocumentHeadlines((WAISDocumentHeadlines **) &header,
					    buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    headlines[numHeadlines++] =
		(WAISDocumentHeadlines *) header;	/* put it in the list */
	    headlines[numHeadlines] = NULL;
	    break;
	case DT_DocumentCodeGroup:
	    if (codes == NULL)	/* create a new list */
	    {
		codes = S_MALLOC2(WAISDocumentCodes *);
	    } else {		/* grow the list */
		codes = S_REALLOC2(WAISDocumentCodes *, codes, numCodes);
	    }
	    buf = readWAISDocumentCodes((WAISDocumentCodes **) &header, buf);
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    RETURN_ON_NULL(buf);
	    codes[numCodes++] =
		(WAISDocumentCodes *) header;	/* put it in the list */
	    codes[numCodes] = NULL;
	    break;
	default:
	    cleanUpWaisSearchResponse(buf,
				      seedWordsUsed,
				      docHeaders,
				      shortHeaders,
				      longHeaders,
				      text,
				      headlines,
				      codes,
				      diags);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *info = (void *) makeWAISSearchResponse(seedWordsUsed,
					    docHeaders,
					    shortHeaders,
					    longHeaders,
					    text,
					    headlines,
					    codes,
					    diags);

    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentText *makeWAISDocumentText(any *docID,
				       long versionNumber,
				       any *documentText)
{
    WAISDocumentText *docText = S_MALLOC(WAISDocumentText);

    docText->DocumentID = docID;
    docText->VersionNumber = versionNumber;
    docText->DocumentText = documentText;

    return (docText);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentText(WAISDocumentText *docText)
{
    freeAny(docText->DocumentID);
    freeAny(docText->DocumentText);
    s_free(docText);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentText(WAISDocumentText *docText, char *buffer,
			    long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentTextGroup,
					       DefWAISDocTextSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docText->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docText->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeAny(docText->DocumentText, DT_DocumentText, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentTextGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentText(WAISDocumentText **docText, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID, *documentText;
    long versionNumber;

    docID = documentText = NULL;
    versionNumber = UNUSED;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_DocumentText:
	    buf = readAny(&documentText, buf);
	    break;
	default:
	    freeAny(docID);
	    freeAny(documentText);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docText = makeWAISDocumentText(docID, versionNumber, documentText);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentHeadlines *makeWAISDocumentHeadlines(any *docID,
						 long versionNumber,
						 char *source,
						 char *date,
						 char *headline,
						 char *originCity)
{
    WAISDocumentHeadlines *docHeadline = S_MALLOC(WAISDocumentHeadlines);

    docHeadline->DocumentID = docID;
    docHeadline->VersionNumber = versionNumber;
    docHeadline->Source = source;
    docHeadline->Date = date;
    docHeadline->Headline = headline;
    docHeadline->OriginCity = originCity;

    return (docHeadline);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline)
{
    freeAny(docHeadline->DocumentID);
    s_free(docHeadline->Source);
    s_free(docHeadline->Date);
    s_free(docHeadline->Headline);
    s_free(docHeadline->OriginCity);
    s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentHeadlines(WAISDocumentHeadlines *docHeadline, char *buffer,
				 long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentHeadlineGroup,
					       DefWAISDocHeadlineSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docHeadline->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docHeadline->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docHeadline->Source, DT_Source, buf, len);
    buf = writeString(docHeadline->Date, DT_Date, buf, len);
    buf = writeString(docHeadline->Headline, DT_Headline, buf, len);
    buf = writeString(docHeadline->OriginCity, DT_OriginCity, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentHeadlineGroup,
			      size,
			      header_len,
			      buffer,
			      len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentHeadlines(WAISDocumentHeadlines **docHeadline, char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *source, *date, *headline, *originCity;

    docID = NULL;
    versionNumber = UNUSED;
    source = date = headline = originCity = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_Source:
	    buf = readString(&source, buf);
	    break;
	case DT_Date:
	    buf = readString(&date, buf);
	    break;
	case DT_Headline:
	    buf = readString(&headline, buf);
	    break;
	case DT_OriginCity:
	    buf = readString(&originCity, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(source);
	    s_free(date);
	    s_free(headline);
	    s_free(originCity);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docHeadline = makeWAISDocumentHeadlines(docID, versionNumber, source, date,
					     headline, originCity);
    return (buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentCodes *makeWAISDocumentCodes(any *docID,
					 long versionNumber,
					 char *stockCodes,
					 char *companyCodes,
					 char *industryCodes)
{
    WAISDocumentCodes *docCodes = S_MALLOC(WAISDocumentCodes);

    docCodes->DocumentID = docID;
    docCodes->VersionNumber = versionNumber;
    docCodes->StockCodes = stockCodes;
    docCodes->CompanyCodes = companyCodes;
    docCodes->IndustryCodes = industryCodes;

    return (docCodes);
}

/*----------------------------------------------------------------------*/

void freeWAISDocumentCodes(WAISDocumentCodes *docCodes)
{
    freeAny(docCodes->DocumentID);
    s_free(docCodes->StockCodes);
    s_free(docCodes->CompanyCodes);
    s_free(docCodes->IndustryCodes);
    s_free(docCodes);
}

/*----------------------------------------------------------------------*/

char *writeWAISDocumentCodes(WAISDocumentCodes *docCodes,
			     char *buffer,
			     long *len)
{
    unsigned long header_len = userInfoTagSize(DT_DocumentCodeGroup,
					       DefWAISDocCodeSize);
    char *buf = buffer + header_len;
    unsigned long size;

    RESERVE_SPACE_FOR_WAIS_HEADER(len);

    buf = writeAny(docCodes->DocumentID, DT_DocumentID, buf, len);
    buf = writeNum(docCodes->VersionNumber, DT_VersionNumber, buf, len);
    buf = writeString(docCodes->StockCodes, DT_StockCodes, buf, len);
    buf = writeString(docCodes->CompanyCodes, DT_CompanyCodes, buf, len);
    buf = writeString(docCodes->IndustryCodes, DT_IndustryCodes, buf, len);

    /* now write the header and size */
    size = buf - buffer;
    buf = writeUserInfoHeader(DT_DocumentCodeGroup, size, header_len, buffer, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readWAISDocumentCodes(WAISDocumentCodes **docCodes,
			    char *buffer)
{
    char *buf = buffer;
    unsigned long size;
    unsigned long headerSize;
    data_tag tag1;
    any *docID;
    long versionNumber;
    char *stockCodes, *companyCodes, *industryCodes;

    docID = NULL;
    versionNumber = UNUSED;
    stockCodes = companyCodes = industryCodes = NULL;

    buf = readUserInfoHeader(&tag1, &size, buf);
    headerSize = buf - buffer;

    while (buf < (buffer + size + headerSize)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_DocumentID:
	    buf = readAny(&docID, buf);
	    break;
	case DT_VersionNumber:
	    buf = readNum(&versionNumber, buf);
	    break;
	case DT_StockCodes:
	    buf = readString(&stockCodes, buf);
	    break;
	case DT_CompanyCodes:
	    buf = readString(&companyCodes, buf);
	    break;
	case DT_IndustryCodes:
	    buf = readString(&industryCodes, buf);
	    break;
	default:
	    freeAny(docID);
	    s_free(stockCodes);
	    s_free(companyCodes);
	    s_free(industryCodes);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    *docCodes = makeWAISDocumentCodes(docID, versionNumber, stockCodes,
				      companyCodes, industryCodes);
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writePresentInfo(PresentAPDU * present GCC_UNUSED, char *buffer,
		       long *len GCC_UNUSED)
{
    /* The WAIS protocol doesn't use present info */
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *readPresentInfo(void **info,
		      char *buffer)
{
    /* The WAIS protocol doesn't use present info */
    *info = NULL;
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *writePresentResponseInfo(PresentResponseAPDU * response GCC_UNUSED, char *buffer,
			       long *len GCC_UNUSED)
{
    /* The WAIS protocol doesn't use presentResponse info */
    return (buffer);
}

/*----------------------------------------------------------------------*/

char *readPresentResponseInfo(void **info,
			      char *buffer)
{
    /* The WAIS protocol doesn't use presentResponse info */
    *info = NULL;
    return (buffer);
}

/*----------------------------------------------------------------------*/

/* support for type 1 queries */

/* new use values (for the chunk types) */
#define	BYTE		"wb"
#define	LINE		"wl"
#define	PARAGRAPH	"wp"
#define DATA_TYPE	"wt"

/* WAIS supports the following semantics for type 1 queries:

     1.  retrieve the header/codes from a document:

	    System_Control_Number = docID
	    Data Type = type (optional)
	    And

     2.  retrieve a fragment of the text of a document:

	    System_Control_Number = docID
	    Data Type = type (optional)
	    And
		Chunk >= start
		And
		Chunk < end
		And

		Information from multiple documents may be requested by using
		groups of the above joined by:

	    OR

		( XXX does an OR come after every group but the first, or do they
	      all come at the end? )

	( XXX return type could be in the element set)
*/

static query_term **makeWAISQueryTerms(DocObj **docs)
/* given a null terminated list of docObjs, construct the appropriate
   query of the form given above
 */
{
    query_term **terms = NULL;
    long numTerms = 0;
    DocObj *doc = NULL;
    long i;

    if (docs == NULL)
	return ((query_term **) NULL);

    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 1));

    terms[numTerms] = NULL;

    /* loop through the docs making terms for them all */
    for (i = 0, doc = docs[i]; doc != NULL; doc = docs[++i]) {
	any *type = NULL;

	if (doc->Type != NULL)
	    type = stringToAny(doc->Type);

	if (doc->ChunkCode == CT_document)	/* a whole document */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms + 2);

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE, IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL,
						      IGNORE, IGNORE, IGNORE,
						      IGNORE, type);
		terms[numTerms++] = makeOperatorTerm(AND);
	    }
	    terms[numTerms] = NULL;
	} else {		/* a document fragment */
	    char chunk_att[ATTRIBUTE_SIZE];
	    any *startChunk = NULL;
	    any *endChunk = NULL;

	    terms = S_REALLOC2(query_term *, terms, numTerms + 6);

	    switch (doc->ChunkCode) {
	    case CT_byte:
	    case CT_line:
		{
		    char start[20], end[20];

		    (doc->ChunkCode == CT_byte) ?
			StrNCpy(chunk_att, BYTE, ATTRIBUTE_SIZE) :
			StrNCpy(chunk_att, LINE, ATTRIBUTE_SIZE);
		    sprintf(start, "%ld", doc->ChunkStart.Pos);
		    startChunk = stringToAny(start);
		    sprintf(end, "%ld", doc->ChunkEnd.Pos);
		    endChunk = stringToAny(end);
		}
		break;
	    case CT_paragraph:
		StrNCpy(chunk_att, PARAGRAPH, ATTRIBUTE_SIZE);
		startChunk = doc->ChunkStart.ID;
		endChunk = doc->ChunkEnd.ID;
		break;
	    default:
		/* error */
		break;
	    }

	    terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						  EQUAL, IGNORE, IGNORE,
						  IGNORE,
						  IGNORE, doc->DocumentID);
	    if (type != NULL) {
		terms[numTerms++] = makeAttributeTerm(DATA_TYPE, EQUAL, IGNORE,
						      IGNORE, IGNORE, IGNORE,
						      type);
		terms[numTerms++] = makeOperatorTerm(AND);
	    }
	    terms[numTerms++] = makeAttributeTerm(chunk_att,
						  GREATER_THAN_OR_EQUAL,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  startChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms++] = makeAttributeTerm(chunk_att, LESS_THAN,
						  IGNORE, IGNORE, IGNORE,
						  IGNORE,
						  endChunk);
	    terms[numTerms++] = makeOperatorTerm(AND);
	    terms[numTerms] = NULL;

	    if (doc->ChunkCode == CT_byte || doc->ChunkCode == CT_line) {
		freeAny(startChunk);
		freeAny(endChunk);
	    }
	}

	freeAny(type);

	if (i != 0)		/* multiple independent queries, need a disjunction */
	{
	    terms = S_REALLOC2(query_term *, terms, numTerms);

	    terms[numTerms++] = makeOperatorTerm(OR);
	    terms[numTerms] = NULL;
	}
    }

    return (terms);
}

/*----------------------------------------------------------------------*/

static DocObj **makeWAISQueryDocs(query_term **terms)
/* given a list of terms in the form given above, convert them to
   DocObjs.
 */
{
    query_term *docTerm = NULL;
    query_term *fragmentTerm = NULL;
    DocObj **docs = NULL;
    DocObj *doc = NULL;
    long docNum, termNum;

    docNum = termNum = 0;

    docs = S_MALLOC(DocObj *);

    docs[docNum] = NULL;

    /* translate the terms into DocObjs */
    while (true) {
	query_term *typeTerm = NULL;
	char *type = NULL;
	long startTermOffset;

	docTerm = terms[termNum];

	if (docTerm == NULL)
	    break;		/* we're done converting */

	typeTerm = terms[termNum + 1];	/* get the lead Term if it exists */

	if (strcmp(typeTerm->Use, DATA_TYPE) == 0)	/* we do have a type */
	{
	    startTermOffset = 3;
	    type = anyToString(typeTerm->Term);
	} else {		/* no type */
	    startTermOffset = 1;
	    typeTerm = NULL;
	    type = NULL;
	}

	/* grow the doc list */
	docs = S_REALLOC2(DocObj *, docs, docNum);

	/* figure out what kind of docObj to build - and build it */
	fragmentTerm = terms[termNum + startTermOffset];
	if (fragmentTerm != NULL && fragmentTerm->TermType == TT_Attribute) {	/* build a document fragment */
	    query_term *startTerm = fragmentTerm;
	    query_term *endTerm = terms[termNum + startTermOffset + 2];

	    if (strcmp(startTerm->Use, BYTE) == 0) {	/* a byte chunk */
		doc = makeDocObjUsingBytes(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("byte");
	    } else if (strcmp(startTerm->Use, LINE) == 0) {	/* a line chunk */
		doc = makeDocObjUsingLines(duplicateAny(docTerm->Term),
					   type,
					   anyToLong(startTerm->Term),
					   anyToLong(endTerm->Term));
		log_write("line");
	    } else {
		log_write("chunk");	/* a paragraph chunk */
		doc = makeDocObjUsingParagraphs(duplicateAny(docTerm->Term),
						type,
						duplicateAny(startTerm->Term),
						duplicateAny(endTerm->Term));
	    }
	    termNum += (startTermOffset + 4);	/* point to next term */
	} else {		/* build a full document */
	    doc = makeDocObjUsingWholeDocument(duplicateAny(docTerm->Term),
					       type);
	    log_write("whole doc");
	    termNum += startTermOffset;		/* point to next term */
	}

	docs[docNum++] = doc;	/* insert the new document */

	docs[docNum] = NULL;	/* keep the doc list terminated */

	if (terms[termNum] != NULL)
	    termNum++;		/* skip the OR operator it necessary */
	else
	    break;		/* we are done */
    }

    return (docs);
}

/*----------------------------------------------------------------------*/

any *makeWAISTextQuery(DocObj **docs)
/* given a list of DocObjs, return an any whose contents is the corresponding
   type 1 query
 */
{
    any *buf = NULL;
    query_term **terms = NULL;

    terms = makeWAISQueryTerms(docs);
    buf = writeQuery(terms);

    doList((void **) terms, freeTerm);
    s_free(terms);

    return (buf);
}

/*----------------------------------------------------------------------*/

DocObj **readWAISTextQuery(any *buf)
/* given an any whose contents are type 1 queries of the WAIS sort,
   construct a list of the corresponding DocObjs
 */
{
    query_term **terms = NULL;
    DocObj **docs = NULL;

    terms = readQuery(buf);
    docs = makeWAISQueryDocs(terms);

    doList((void **) terms, freeTerm);
    s_free(terms);

    return (docs);
}

/*----------------------------------------------------------------------*/
/* Customized free WAIS object routines:                                */
/*                                                                      */
/*   This set of procedures is for applications to free a WAIS object   */
/*   which was made with makeWAISFOO.                                   */
/*   Each procedure frees only the memory that was allocated in its     */
/*   associated makeWAISFOO routine, thus it's not necessary for the    */
/*   caller to assign nulls to the pointer fields of the WAIS object.  */
/*----------------------------------------------------------------------*/

void CSTFreeWAISInitResponse(WAISInitResponse *init)
/* free an object made with makeWAISInitResponse */
{
    s_free(init);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISSearch(WAISSearch *query)
/* destroy an object made with makeWAISSearch() */
{
    s_free(query);
}

/*----------------------------------------------------------------------*/

void CSTFreeDocObj(DocObj *doc)
/* free a docObj */
{
    s_free(doc);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentHeader(WAISDocumentHeader *header)
{
    s_free(header);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentShortHeader(WAISDocumentShortHeader *header)
{
    s_free(header);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentLongHeader(WAISDocumentLongHeader *header)
{
    s_free(header);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISSearchResponse(WAISSearchResponse * response)
{
    s_free(response);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentText(WAISDocumentText *docText)
{
    s_free(docText);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocHeadlines(WAISDocumentHeadlines *docHeadline)
{
    s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISDocumentCodes(WAISDocumentCodes *docCodes)
{
    s_free(docCodes);
}

/*----------------------------------------------------------------------*/

void CSTFreeWAISTextQuery(any *query)
{
    freeAny(query);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from WMessage.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 * 3.26.90
 */

/* This file is for reading and writing the wais packet header.
 * Morris@@think.com
 */

/* to do:
 *  add check sum
 *  what do you do when checksum is wrong?
 */

/*---------------------------------------------------------------------*/

void readWAISPacketHeader(char *msgBuffer,
			  WAISMessage * header_struct)
{
    /* msgBuffer is a string containing at least HEADER_LENGTH bytes. */

    memmove(header_struct->msg_len, msgBuffer, (size_t) 10);
    header_struct->msg_type = char_downcase((unsigned long) msgBuffer[10]);
    header_struct->hdr_vers = char_downcase((unsigned long) msgBuffer[11]);
    memmove(header_struct->server, (void *) (msgBuffer + 12), (size_t) 10);
    header_struct->compression = char_downcase((unsigned long) msgBuffer[22]);
    header_struct->encoding = char_downcase((unsigned long) msgBuffer[23]);
    header_struct->msg_checksum = char_downcase((unsigned long) msgBuffer[24]);
}

/*---------------------------------------------------------------------*/

/* this modifies the header argument.  See wais-message.h for the different
 * options for the arguments.
 */

void writeWAISPacketHeader(char *header,
			   long dataLen,
			   long type,
			   char *server,
			   long compression,
			   long encoding,
			   long version)
/* Puts together the new wais before-the-z39-packet header. */
{
    char lengthBuf[11];
    char serverBuf[11];

    long serverLen = strlen(server);

    if (serverLen > 10)
	serverLen = 10;

    sprintf(lengthBuf, "%010ld", dataLen);
    StrNCpy(header, lengthBuf, 10);

    header[10] = type & 0xFF;
    header[11] = version & 0xFF;

    StrNCpy(serverBuf, server, serverLen);
    StrNCpy((char *) (header + 12), serverBuf, serverLen);

    header[22] = compression & 0xFF;
    header[23] = encoding & 0xFF;
    header[24] = '0';		/* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
}

/*---------------------------------------------------------------------*/
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*							HTVMS_WAISProt.c
a484 1
	    readParagraphs = true;
d2117 2
a2118 2
			strncpy(chunk_att, BYTE, ATTRIBUTE_SIZE) :
			strncpy(chunk_att, LINE, ATTRIBUTE_SIZE);
d2126 1
a2126 1
		strncpy(chunk_att, PARAGRAPH, ATTRIBUTE_SIZE);
d2456 1
a2456 1
    strncpy(header, lengthBuf, 10);
d2461 2
a2462 2
    strncpy(serverBuf, server, serverLen);
    strncpy((char *) (header + 12), serverBuf, serverLen);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 6
a7 6
**
**	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
**
**	31-May-1994 FM	Initial version.
**
**----------------------------------------------------------------------*/
d10 3
a12 3
**	Routines originally from WProt.c -- FM
**
**----------------------------------------------------------------------*/
d14 2
a15 2
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.
d17 11
a27 11
   3.26.90	Harry Morris, morris@@think.com
   3.30.90  Harry Morris
   -	removed chunk code from WAISSearchAPDU,
   -	added makeWAISQueryType1Query() and readWAISType1Query() which replace
   makeWAISQueryTerms() and makeWAISQueryDocs().
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
   - renamed makeWAISType1Query() to makeWAISTextQuery()
   renamed readWAISType1Query() to readWAISTextQuery()
   5.29.90  TS - fixed bug in makeWAISQueryDocs
   added CSTFreeWAISFoo functions
*/
a39 1

d57 5
d64 2
a65 7
static unsigned long userInfoTagSize PARAMS((data_tag tag,
					  unsigned long length));

static unsigned long
userInfoTagSize(tag,length)
data_tag tag;
unsigned long length;
d70 1
a70 1
  unsigned long size;
d72 3
a74 3
  /* calculate bytes required to represent tag.  max tag is 16K */
  size = writtenCompressedIntSize(tag);
  size += writtenCompressedIntSize(length);
d76 1
a76 1
  return(size);
d81 5
a85 11
static char* writeUserInfoHeader PARAMS((data_tag tag,long infoSize,
				      long estHeaderSize,char* buffer,
				      long* len));

static char*
writeUserInfoHeader(tag,infoSize,estHeaderSize,buffer,len)
data_tag tag;
long infoSize;
long estHeaderSize;
char* buffer;
long* len;
d94 16
a109 17
  long dummyLen = 100;		/* plenty of space for a tag and size */
  char* buf = buffer;
  long realSize = infoSize - estHeaderSize;
  long realHeaderSize = userInfoTagSize(tag,realSize);

  if (buffer == NULL || *len == 0)
    return(NULL);

  /* write the tag */
  buf = writeTag(tag,buf,&dummyLen);

  /* see if the if the header size was correct. if not,
     we have to shift the info to fit the real header size */
  if (estHeaderSize != realHeaderSize)
    {				/* make sure there is enough space */
      CHECK_FOR_SPACE_LEFT(realHeaderSize - estHeaderSize,len);
      memmove(buffer + realHeaderSize,buffer + estHeaderSize,(size_t)(realSize));
d112 2
a113 2
  /* write the size */
  writeCompressedInteger(realSize,buf,&dummyLen);
d115 2
a116 2
  /* return the true end of buffer */
  return(buffer + realHeaderSize + realSize);
d121 3
a123 8
static char* readUserInfoHeader PARAMS((data_tag* tag,unsigned long* num,
				     char* buffer));

static char*
readUserInfoHeader(tag,num,buffer)
data_tag* tag;
unsigned long* num;
char* buffer;
d126 5
a130 4
  char* buf = buffer;
  buf = readTag(tag,buf);
  buf = readCompressedInteger(num,buf);
  return(buf);
d135 6
a140 13
WAISInitResponse*
makeWAISInitResponse(chunkCode,
		     chunkIDLen,
		     chunkMarker,
		     highlightMarker,
		     deHighlightMarker,
		     newLineChars)
long chunkCode;
long chunkIDLen;
char* chunkMarker;
char* highlightMarker;
char* deHighlightMarker;
char* newLineChars;
d143 1
a143 1
  WAISInitResponse* init = (WAISInitResponse*)s_malloc((size_t)sizeof(WAISInitResponse));
d145 6
a150 6
  init->ChunkCode = chunkCode;	/* note: none are copied! */
  init->ChunkIDLength = chunkIDLen;
  init->ChunkMarker = chunkMarker;
  init->HighlightMarker = highlightMarker;
  init->DeHighlightMarker = deHighlightMarker;
  init->NewlineCharacters = newLineChars;
d152 1
a152 1
  return(init);
d157 1
a157 3
void
freeWAISInitResponse(init)
WAISInitResponse* init;
d160 5
a164 5
  s_free(init->ChunkMarker);
  s_free(init->HighlightMarker);
  s_free(init->DeHighlightMarker);
  s_free(init->NewlineCharacters);
  s_free(init);
d169 3
a171 5
char*
writeInitResponseInfo(init,buffer,len)
InitResponseAPDU* init;
char* buffer;
long* len;
d174 5
a178 5
  unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					     DefWAISInitResponseSize);
  char* buf = buffer + header_len;
  WAISInitResponse* info = (WAISInitResponse*)init->UserInformationField;
  unsigned long size;
d180 1
a180 1
  RESERVE_SPACE_FOR_WAIS_HEADER(len);
d182 6
a187 6
  buf = writeNum(info->ChunkCode,DT_ChunkCode,buf,len);
  buf = writeNum(info->ChunkIDLength,DT_ChunkIDLength,buf,len);
  buf = writeString(info->ChunkMarker,DT_ChunkMarker,buf,len);
  buf = writeString(info->HighlightMarker,DT_HighlightMarker,buf,len);
  buf = writeString(info->DeHighlightMarker,DT_DeHighlightMarker,buf,len);
  buf = writeString(info->NewlineCharacters,DT_NewlineCharacters,buf,len);
d189 7
a195 3
  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_UserInformationLength,size,header_len,buffer,len);
d197 1
a197 1
  return(buf);
d202 2
a203 4
char*
readInitResponseInfo(info,buffer)
void** info;
char* buffer;
d206 30
a235 29
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  long chunkCode,chunkIDLen;
  data_tag tag1;
  char* chunkMarker = NULL;
  char* highlightMarker = NULL;
  char* deHighlightMarker = NULL;
  char* newLineChars = NULL;

  chunkCode = chunkIDLen = UNUSED;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_ChunkCode:
	    buf = readNum(&chunkCode,buf);
	    break;
	  case DT_ChunkIDLength:
	    buf = readNum(&chunkIDLen,buf);
	    break;
	  case DT_ChunkMarker:
	    buf = readString(&chunkMarker,buf);
	    break;
	  case DT_HighlightMarker:
	    buf = readString(&highlightMarker,buf);
d237 2
a238 2
	  case DT_DeHighlightMarker:
	    buf = readString(&deHighlightMarker,buf);
d240 2
a241 2
	  case DT_NewlineCharacters:
	    buf = readString(&newLineChars,buf);
d243 1
a243 1
	  default:
d249 1
a249 1
	  }
d252 4
a255 4
  *info = (void *)makeWAISInitResponse(chunkCode,chunkIDLen,chunkMarker,
			       highlightMarker,deHighlightMarker,
			       newLineChars);
  return(buf);
d260 7
a266 15
WAISSearch*
makeWAISSearch(seedWords,
	       docs,
	       textList,
	       dateFactor,
	       beginDateRange,
	       endDateRange,
	       maxDocsRetrieved)
char* seedWords;
DocObj** docs;
char** textList;
long dateFactor;
char* beginDateRange;
char* endDateRange;
long maxDocsRetrieved;
d270 1
a270 1
  WAISSearch* query = (WAISSearch*)s_malloc((size_t)sizeof(WAISSearch));
d272 7
a278 7
  query->SeedWords = seedWords;	/* not copied! */
  query->Docs = docs;		/* not copied! */
  query->TextList = textList;	/* not copied! */
  query->DateFactor = dateFactor;
  query->BeginDateRange = beginDateRange;
  query->EndDateRange = endDateRange;
  query->MaxDocumentsRetrieved = maxDocsRetrieved;
d280 1
a280 1
  return(query);
d285 1
a285 3
void
freeWAISSearch(query)
WAISSearch* query;
d289 2
a290 2
  void* ptr = NULL;
  long i;
d292 1
a292 1
  s_free(query->SeedWords);
d294 6
a299 4
  if (query->Docs != NULL)
    for (i = 0,ptr = (void *)query->Docs[i]; ptr != NULL; ptr = (void *)query->Docs[++i])
      freeDocObj((DocObj*)ptr);
  s_free(query->Docs);
d301 6
a306 4
  if (query->TextList != NULL)	/* XXX revisit when textlist is fully defined */
    for (i = 0,ptr = (void *)query->TextList[i]; ptr != NULL; ptr = (void *)query->TextList[++i])
      s_free(ptr);
  s_free(query->TextList);
d308 3
a310 3
  s_free(query->BeginDateRange);
  s_free(query->EndDateRange);
  s_free(query);
d315 2
a316 4
DocObj*
makeDocObjUsingWholeDocument(docID,type)
any* docID;
char* type;
d321 6
a326 5
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->DocumentID = docID;		/* not copied! */
  doc->Type = type;		/* not copied! */
  doc->ChunkCode = CT_document;
  return(doc);
d331 4
a334 6
DocObj*
makeDocObjUsingLines(docID,type,start,end)
any* docID;
char* type;
long start;
long end;
d339 8
a346 7
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->ChunkCode = CT_line;
  doc->DocumentID = docID;		/* not copied */
  doc->Type = type;		/* not copied! */
  doc->ChunkStart.Pos = start;
  doc->ChunkEnd.Pos = end;
  return(doc);
d351 4
a354 6
DocObj*
makeDocObjUsingBytes(docID,type,start,end)
any* docID;
char* type;
long start;
long end;
d359 8
a366 7
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->ChunkCode = CT_byte;
  doc->DocumentID = docID;		/* not copied */
  doc->Type = type;		/* not copied! */
  doc->ChunkStart.Pos = start;
  doc->ChunkEnd.Pos = end;
  return(doc);
d371 4
a374 6
DocObj*
makeDocObjUsingParagraphs(docID,type,start,end)
any* docID;
char* type;
any* start;
any* end;
d379 8
a386 7
  DocObj* doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
  doc->ChunkCode = CT_paragraph;
  doc->DocumentID = docID;		/* not copied */
  doc->Type = type;
  doc->ChunkStart.ID = start;
  doc->ChunkEnd.ID = end;
  return(doc);
d391 1
a391 3
void
freeDocObj(doc)
DocObj* doc;
d395 5
a399 5
  freeAny(doc->DocumentID);
  s_free(doc->Type);
  if (doc->ChunkCode == CT_paragraph)
    { freeAny(doc->ChunkStart.ID);
      freeAny(doc->ChunkEnd.ID);
d401 1
a401 1
  s_free(doc);
d406 3
a408 7
static char* writeDocObj PARAMS((DocObj* doc,char* buffer,long* len));

static char*
writeDocObj(doc,buffer,len)
DocObj* doc;
char* buffer;
long* len;
d412 1
a412 1
  char* buf = buffer;
d414 5
a418 5
  /* we alwasy have to write the id, but its tag depends on if its a chunk */
  if (doc->ChunkCode == CT_document)
    buf = writeAny(doc->DocumentID,DT_DocumentID,buf,len);
  else
    buf = writeAny(doc->DocumentID,DT_DocumentIDChunk,buf,len);
d420 2
a421 2
  if (doc->Type != NULL)
    buf = writeString(doc->Type,DT_TYPE,buf,len);
d423 2
a424 2
  switch (doc->ChunkCode)
    { case CT_document:
d427 5
a431 5
      case CT_byte:
      case CT_line:
	buf = writeNum(doc->ChunkCode,DT_ChunkCode,buf,len);
	buf = writeNum(doc->ChunkStart.Pos,DT_ChunkStartID,buf,len);
	buf = writeNum(doc->ChunkEnd.Pos,DT_ChunkEndID,buf,len);
d433 4
a436 4
      case CT_paragraph:
	buf = writeNum(doc->ChunkCode,DT_ChunkCode,buf,len);
	buf = writeAny(doc->ChunkStart.ID,DT_ChunkStartID,buf,len);
	buf = writeAny(doc->ChunkEnd.ID,DT_ChunkEndID,buf,len);
d438 1
a438 1
      default:
d442 1
a442 1
      }
d444 1
a444 1
  return(buf);
d449 2
a450 6
static char* readDocObj PARAMS((DocObj** doc,char* buffer));

static char*
readDocObj(doc,buffer)
DocObj** doc;
char* buffer;
d454 2
a455 2
  char* buf = buffer;
  data_tag tag;
d457 1
a457 1
  *doc = (DocObj*)s_malloc((size_t)sizeof(DocObj));
d459 2
a460 2
  tag = peekTag(buf);
  buf = readAny(&((*doc)->DocumentID),buf);
d462 18
a479 18
  if (tag == DT_DocumentID)
    { (*doc)->ChunkCode = CT_document;
      tag = peekTag(buf);
      if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != what comes next */
	buf = readString(&((*doc)->Type),buf);
      /* ChunkStart and ChunkEnd are undefined */
    }
  else if (tag == DT_DocumentIDChunk)
    { boolean readParagraphs = false; /* for cleanup */
      tag = peekTag(buf);
      if (tag == DT_TYPE)	/* XXX depends on DT_TYPE != CT_FOO */
	buf = readString(&((*doc)->Type),buf);
      buf = readNum(&((*doc)->ChunkCode),buf);
      switch ((*doc)->ChunkCode)
	{ case CT_byte:
	  case CT_line:
	    buf = readNum(&((*doc)->ChunkStart.Pos),buf);
	    buf = readNum(&((*doc)->ChunkEnd.Pos),buf);
d481 1
a481 1
	  case CT_paragraph:
d483 2
a484 2
	    buf = readAny(&((*doc)->ChunkStart.ID),buf);
	    buf = readAny(&((*doc)->ChunkEnd.ID),buf);
d486 1
a486 1
	  default:
d488 2
a489 2
	    if (readParagraphs)
	      { freeAny((*doc)->ChunkStart.ID);
d491 1
a491 1
	      }
d495 5
a499 1
	  }
d501 1
a501 6
  else
    { freeAny((*doc)->DocumentID);
      s_free(*doc);
      REPORT_READ_ERROR(buf);
    }
  return(buf);
d506 3
a508 5
char*
writeSearchInfo(query,buffer,len)
SearchAPDU* query;
char* buffer;
long* len;
d512 18
a529 19
  if (strcmp(query->QueryType,QT_TextRetrievalQuery) == 0)
    { return(writeAny((any*)query->Query,DT_Query,buffer,len));
    }
  else
    { unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
						 DefWAISSearchSize);
      char* buf = buffer + header_len;
      WAISSearch* info = (WAISSearch*)query->Query;
      unsigned long size;
      long i;

      RESERVE_SPACE_FOR_WAIS_HEADER(len);

      buf = writeString(info->SeedWords,DT_SeedWords,buf,len);

      if (info->Docs != NULL)
      { for (i = 0; info->Docs[i] != NULL; i++)
	  { buf = writeDocObj(info->Docs[i],buf,len);
	  }
d532 1
a532 6
      /* XXX text list */

      buf = writeNum(info->DateFactor,DT_DateFactor,buf,len);
      buf = writeString(info->BeginDateRange,DT_BeginDateRange,buf,len);
      buf = writeString(info->EndDateRange,DT_EndDateRange,buf,len);
      buf = writeNum(info->MaxDocumentsRetrieved,DT_MaxDocumentsRetrieved,buf,len);
d534 24
a557 3
      /* now write the header and size */
      size = buf - buffer;
      buf = writeUserInfoHeader(DT_UserInformationLength,size,header_len,buffer,len);
d559 1
a559 1
      return(buf);
d565 2
a566 4
char*
readSearchInfo(info,buffer)
void** info;
char* buffer;
d570 37
a606 34
  data_tag type = peekTag(buffer);
  if (type == DT_Query)		/* this is a type 1 query */
    { char* buf = buffer;
      any* query = NULL;
      buf = readAny(&query,buf);
      *info = (void *)query;
      return(buf);
    }
  else				/* a type 3 query */
    { char* buf = buffer;
      unsigned long size;
      unsigned long headerSize;
      data_tag tag1;
      char* seedWords = NULL;
      char* beginDateRange = NULL;
      char* endDateRange = NULL;
      long dateFactor,maxDocsRetrieved;
      char** textList = NULL;
      DocObj** docIDs = NULL;
      DocObj* doc = NULL;
      long docs = 0;
      long i;
      void* ptr = NULL;

      dateFactor = maxDocsRetrieved = UNUSED;

      buf = readUserInfoHeader(&tag1,&size,buf);
      headerSize = buf - buffer;

      while (buf < (buffer + size + headerSize))
	{ data_tag tag = peekTag(buf);
	  switch (tag)
	    { case DT_SeedWords:
		buf = readString(&seedWords,buf);
d608 11
a618 11
	      case DT_DocumentID:
	      case DT_DocumentIDChunk:
		if (docIDs == NULL) /* create a new doc list */
		  { docIDs = (DocObj**)s_malloc((size_t)sizeof(DocObj*) * 2);
		  }
		else		/* grow the doc list */
		  { docIDs = (DocObj**)s_realloc((char*)docIDs,(size_t)(sizeof(DocObj*) * (docs + 2)));
		  }
		buf = readDocObj(&doc,buf);
		if (buf == NULL)
		  { s_free(seedWords);
d622 4
a625 2
		      for (i = 0,ptr = (void *)docIDs[i]; ptr != NULL; ptr = (void *)docIDs[++i])
			freeDocObj((DocObj*)ptr);
d628 1
a628 1
		  }
d630 1
a630 1
		docIDs[docs++] = doc; /* put it in the list */
d633 1
a633 1
	      case DT_TextList:
d636 2
a637 2
	      case DT_DateFactor:
		buf = readNum(&dateFactor,buf);
d639 2
a640 2
	      case DT_BeginDateRange:
		buf = readString(&beginDateRange,buf);
d642 2
a643 2
	      case DT_EndDateRange:
		buf = readString(&endDateRange,buf);
d645 2
a646 2
	      case DT_MaxDocumentsRetrieved:
		buf = readNum(&maxDocsRetrieved,buf);
d648 1
a648 1
	      default:
d653 4
a656 2
		  for (i = 0,ptr = (void *)docIDs[i]; ptr != NULL; ptr = (void *)docIDs[++i])
		    freeDocObj((DocObj*)ptr);
d661 1
a661 1
	      }
d664 4
a667 4
      *info = (void *)makeWAISSearch(seedWords,docIDs,textList,
				     dateFactor,beginDateRange,endDateRange,
				     maxDocsRetrieved);
      return(buf);
d673 11
a683 23
WAISDocumentHeader*
makeWAISDocumentHeader(docID,
		       versionNumber,
		       score,
		       bestMatch,
		       docLen,
		       lines,
		       types,
		       source,
		       date,
		       headline,
		       originCity)
any* docID;
long versionNumber;
long score;
long bestMatch;
long docLen;
long lines;
char** types;
char* source;
char* date;
char* headline;
char* originCity;
d690 30
a719 2
  WAISDocumentHeader* header =
    (WAISDocumentHeader*)s_malloc((size_t)sizeof(WAISDocumentHeader));
d721 32
a752 63
  header->DocumentID = docID;
  header->VersionNumber = versionNumber;
  header->Score = score;
  header->BestMatch = bestMatch;
  header->DocumentLength = docLen;
  header->Lines = lines;
  header->Types = types;
  header->Source = source;
  header->Date = date;
  header->Headline = headline;
  header->OriginCity = originCity;

  return(header);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentHeader(header)
WAISDocumentHeader* header;

{
  freeAny(header->DocumentID);
  doList((void**)header->Types,fs_free); /* can't use the macro here ! */
  s_free(header->Types);
  s_free(header->Source);
  s_free(header->Date);
  s_free(header->Headline);
  s_free(header->OriginCity);
  s_free(header);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentHeader(header,buffer,len)
WAISDocumentHeader* header;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentHeaderGroup ,
					     DefWAISDocHeaderSize);
  char* buf = buffer + header_len;
  unsigned long size1;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(header->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(header->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeNum(header->Score,DT_Score,buf,len);
  buf = writeNum(header->BestMatch,DT_BestMatch,buf,len);
  buf = writeNum(header->DocumentLength,DT_DocumentLength,buf,len);
  buf = writeNum(header->Lines,DT_Lines,buf,len);
  if (header->Types != NULL)
    { long size;
      char* ptr = NULL;
      long i;
      buf = writeTag(DT_TYPE_BLOCK,buf,len);
      for (i = 0,size = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	{ long typeSize = strlen(ptr);
	  size += writtenTagSize(DT_TYPE);
	  size += writtenCompressedIntSize(typeSize);
	  size += typeSize;
d754 80
a833 74
      buf = writeCompressedInteger((unsigned long)size,buf,len);
      for (i = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	buf = writeString(ptr,DT_TYPE,buf,len);
    }
  buf = writeString(header->Source,DT_Source,buf,len);
  buf = writeString(header->Date,DT_Date,buf,len);
  buf = writeString(header->Headline,DT_Headline,buf,len);
  buf = writeString(header->OriginCity,DT_OriginCity,buf,len);

  /* now write the header and size */
  size1 = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentHeaderGroup,size1,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentHeader(header,buffer)
WAISDocumentHeader** header;
char* buffer;
{
  char* buf = buffer;
  unsigned long size1;
  unsigned long headerSize;
  data_tag tag1;
  any* docID = NULL;
  long versionNumber,score,bestMatch,docLength,lines;
  char** types = NULL;
  char *source = NULL;
  char *date = NULL;
  char *headline = NULL;
  char *originCity = NULL;

  versionNumber = score = bestMatch = docLength = lines = UNUSED;

  buf = readUserInfoHeader(&tag1,&size1,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size1 + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_DocumentID:
	    buf = readAny(&docID,buf);
	    break;
	  case DT_VersionNumber:
	    buf = readNum(&versionNumber,buf);
	    break;
	  case DT_Score:
	    buf = readNum(&score,buf);
	    break;
	  case DT_BestMatch:
	    buf = readNum(&bestMatch,buf);
	    break;
	  case DT_DocumentLength:
	    buf = readNum(&docLength,buf);
	    break;
	  case DT_Lines:
	    buf = readNum(&lines,buf);
	    break;
	  case DT_TYPE_BLOCK:
	    { unsigned long size = -1;
	      long numTypes = 0;
	      buf = readTag(&tag,buf);
	      buf = readCompressedInteger(&size,buf);
	      while (size > 0)
		{ char* type = NULL;
		  char* originalBuf = buf;
		  buf = readString(&type,buf);
		  types = (char**)s_realloc(types,(size_t)(sizeof(char*) * (numTypes + 2)));
		  types[numTypes++] = type;
		  types[numTypes] = NULL;
		  size -= (buf - originalBuf);
d837 2
a838 2
	  case DT_Source:
	    buf = readString(&source,buf);
d840 2
a841 2
	  case DT_Date:
	    buf = readString(&date,buf);
d843 2
a844 2
	  case DT_Headline:
	    buf = readString(&headline,buf);
d846 2
a847 2
	  case DT_OriginCity:
	    buf = readString(&originCity,buf);
d849 1
a849 1
	  default:
d857 1
a857 1
	  }
d860 4
a863 4
  *header = makeWAISDocumentHeader(docID,versionNumber,score,bestMatch,
				   docLength,lines,types,source,date,headline,
				   originCity);
  return(buf);
d868 6
a873 13
WAISDocumentShortHeader*
makeWAISDocumentShortHeader(docID,
			    versionNumber,
			    score,
			    bestMatch,
			    docLen,
			    lines)
any* docID;
long versionNumber;
long score;
long bestMatch;
long docLen;
long lines;
d879 1
a879 2
  WAISDocumentShortHeader* header =
    (WAISDocumentShortHeader*)s_malloc((size_t)sizeof(WAISDocumentShortHeader));
d881 6
a886 6
  header->DocumentID = docID;
  header->VersionNumber = versionNumber;
  header->Score = score;
  header->BestMatch = bestMatch;
  header->DocumentLength = docLen;
  header->Lines = lines;
d888 1
a888 1
  return(header);
d893 1
a893 3
void
freeWAISDocumentShortHeader(header)
WAISDocumentShortHeader* header;
d895 2
a896 2
  freeAny(header->DocumentID);
  s_free(header);
d901 2
a902 5
char*
writeWAISDocumentShortHeader(header,buffer,len)
WAISDocumentShortHeader* header;
char* buffer;
long* len;
d904 4
a907 4
  unsigned long header_len = userInfoTagSize(DT_DocumentShortHeaderGroup ,
					     DefWAISShortHeaderSize);
  char* buf = buffer + header_len;
  unsigned long size;
d909 1
a909 1
  RESERVE_SPACE_FOR_WAIS_HEADER(len);
d911 6
a916 6
  buf = writeAny(header->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(header->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeNum(header->Score,DT_Score,buf,len);
  buf = writeNum(header->BestMatch,DT_BestMatch,buf,len);
  buf = writeNum(header->DocumentLength,DT_DocumentLength,buf,len);
  buf = writeNum(header->Lines,DT_Lines,buf,len);
d918 7
a924 3
  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentShortHeaderGroup,size,header_len,buffer,len);
d926 1
a926 1
  return(buf);
d931 1
a931 4
char*
readWAISDocumentShortHeader(header,buffer)
WAISDocumentShortHeader** header;
char* buffer;
d933 8
a940 6
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any* docID = NULL;
  long versionNumber,score,bestMatch,docLength,lines;
d942 2
a943 1
  versionNumber = score = bestMatch = docLength = lines = UNUSED;
d945 2
a946 2
  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;
d948 3
a950 5
  while (buf < (buffer + size + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_DocumentID:
	    buf = readAny(&docID,buf);
d952 2
a953 2
	  case DT_VersionNumber:
	    buf = readNum(&versionNumber,buf);
d955 2
a956 2
	  case DT_Score:
	    buf = readNum(&score,buf);
d958 2
a959 2
	  case DT_BestMatch:
	    buf = readNum(&bestMatch,buf);
d961 2
a962 2
	  case DT_DocumentLength:
	    buf = readNum(&docLength,buf);
d964 2
a965 2
	  case DT_Lines:
	    buf = readNum(&lines,buf);
d967 1
a967 1
	  default:
d971 1
a971 1
	  }
d974 3
a976 3
  *header = makeWAISDocumentShortHeader(docID,versionNumber,score,bestMatch,
					docLength,lines);
  return(buf);
d981 14
a994 29
WAISDocumentLongHeader*
makeWAISDocumentLongHeader(docID,
			   versionNumber,
			   score,
			   bestMatch,
			   docLen,
			   lines,
			   types,
			   source,
			   date,
			   headline,
			   originCity,
			   stockCodes,
			   companyCodes,
			   industryCodes)
any* docID;
long versionNumber;
long score;
long bestMatch;
long docLen;
long lines;
char** types;
char* source;
char* date;
char* headline;
char* originCity;
char* stockCodes;
char* companyCodes;
char* industryCodes;
d1000 21
a1020 2
  WAISDocumentLongHeader* header =
    (WAISDocumentLongHeader*)s_malloc((size_t)sizeof(WAISDocumentLongHeader));
d1022 46
a1067 67
  header->DocumentID = docID;
  header->VersionNumber = versionNumber;
  header->Score = score;
  header->BestMatch = bestMatch;
  header->DocumentLength = docLen;
  header->Lines = lines;
  header->Types = types;
  header->Source = source;
  header->Date = date;
  header->Headline = headline;
  header->OriginCity = originCity;
  header->StockCodes = stockCodes;
  header->CompanyCodes = companyCodes;
  header->IndustryCodes = industryCodes;

  return(header);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentLongHeader(header)
WAISDocumentLongHeader* header;
{
  freeAny(header->DocumentID);
  doList((void**)header->Types,fs_free); /* can't use the macro here! */
  s_free(header->Source);
  s_free(header->Date);
  s_free(header->Headline);
  s_free(header->OriginCity);
  s_free(header->StockCodes);
  s_free(header->CompanyCodes);
  s_free(header->IndustryCodes);
  s_free(header);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentLongHeader(header,buffer,len)
WAISDocumentLongHeader* header;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentLongHeaderGroup ,
					     DefWAISLongHeaderSize);
  char* buf = buffer + header_len;
  unsigned long size1;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(header->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(header->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeNum(header->Score,DT_Score,buf,len);
  buf = writeNum(header->BestMatch,DT_BestMatch,buf,len);
  buf = writeNum(header->DocumentLength,DT_DocumentLength,buf,len);
  buf = writeNum(header->Lines,DT_Lines,buf,len);
  if (header->Types != NULL)
    { long size;
      char* ptr = NULL;
      long i;
      buf = writeTag(DT_TYPE_BLOCK,buf,len);
      for (i = 0,size = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	{ long typeSize = strlen(ptr);
	  size += writtenTagSize(DT_TYPE);
	  size += writtenCompressedIntSize(typeSize);
	  size += typeSize;
d1069 93
a1161 77
      buf = writeCompressedInteger((unsigned long)size,buf,len);
      for (i = 0,ptr = header->Types[i]; ptr != NULL; ptr = header->Types[++i])
	buf = writeString(ptr,DT_TYPE,buf,len);
    }
  buf = writeString(header->Source,DT_Source,buf,len);
  buf = writeString(header->Date,DT_Date,buf,len);
  buf = writeString(header->Headline,DT_Headline,buf,len);
  buf = writeString(header->OriginCity,DT_OriginCity,buf,len);
  buf = writeString(header->StockCodes,DT_StockCodes,buf,len);
  buf = writeString(header->CompanyCodes,DT_CompanyCodes,buf,len);
  buf = writeString(header->IndustryCodes,DT_IndustryCodes,buf,len);

  /* now write the header and size */
  size1 = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,size1,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentLongHeader(header,buffer)
WAISDocumentLongHeader** header;
char* buffer;
{
  char* buf = buffer;
  unsigned long size1;
  unsigned long headerSize;
  data_tag tag1;
  any* docID;
  long versionNumber,score,bestMatch,docLength,lines;
  char **types;
  char *source,*date,*headline,*originCity,*stockCodes,*companyCodes,*industryCodes;

  docID = NULL;
  versionNumber = score = bestMatch = docLength = lines = UNUSED;
  types = NULL;
  source = date = headline = originCity = stockCodes = companyCodes = industryCodes = NULL;

  buf = readUserInfoHeader(&tag1,&size1,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size1 + headerSize))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_DocumentID:
	    buf = readAny(&docID,buf);
	    break;
	  case DT_VersionNumber:
	    buf = readNum(&versionNumber,buf);
	    break;
	  case DT_Score:
	    buf = readNum(&score,buf);
	    break;
	  case DT_BestMatch:
	    buf = readNum(&bestMatch,buf);
	    break;
	  case DT_DocumentLength:
	    buf = readNum(&docLength,buf);
	    break;
	  case DT_Lines:
	    buf = readNum(&lines,buf);
	    break;
	  case DT_TYPE_BLOCK:
	    { unsigned long size = -1;
	      long numTypes = 0;
	      buf = readTag(&tag,buf);
	      readCompressedInteger(&size,buf);
	      while (size > 0)
		{ char* type = NULL;
		  char* originalBuf = buf;
		  buf = readString(&type,buf);
		  types = (char**)s_realloc(types,(size_t)(sizeof(char*) * (numTypes + 2)));
		  types[numTypes++] = type;
		  types[numTypes] = NULL;
		  size -= (buf - originalBuf);
d1165 2
a1166 2
	  case DT_Source:
	    buf = readString(&source,buf);
d1168 2
a1169 2
	  case DT_Date:
	    buf = readString(&date,buf);
d1171 2
a1172 2
	  case DT_Headline:
	    buf = readString(&headline,buf);
d1174 2
a1175 2
	  case DT_OriginCity:
	    buf = readString(&originCity,buf);
d1177 2
a1178 2
	  case DT_StockCodes:
	    buf = readString(&stockCodes,buf);
d1180 2
a1181 2
	  case DT_CompanyCodes:
	    buf = readString(&companyCodes,buf);
d1183 2
a1184 2
	  case DT_IndustryCodes:
	    buf = readString(&industryCodes,buf);
d1186 1
a1186 1
	  default:
d1197 157
a1353 1
	  }
d1356 45
a1400 177
  *header = makeWAISDocumentLongHeader(docID,versionNumber,score,bestMatch,
				       docLength,lines,types,source,date,headline,
				       originCity,stockCodes,companyCodes,
				       industryCodes);
  return(buf);
}

/*----------------------------------------------------------------------*/

WAISSearchResponse*
makeWAISSearchResponse(seedWordsUsed,
		       docHeaders,
		       shortHeaders,
		       longHeaders,
		       text,
		       headlines,
		       codes,
		       diagnostics)
char* seedWordsUsed;
WAISDocumentHeader** docHeaders;
WAISDocumentShortHeader** shortHeaders;
WAISDocumentLongHeader** longHeaders;
WAISDocumentText** text;
WAISDocumentHeadlines** headlines;
WAISDocumentCodes** codes;
diagnosticRecord** diagnostics;
{
  WAISSearchResponse* response = (WAISSearchResponse*)s_malloc((size_t)sizeof(WAISSearchResponse));

  response->SeedWordsUsed = seedWordsUsed;
  response->DocHeaders = docHeaders;
  response->ShortHeaders = shortHeaders;
  response->LongHeaders = longHeaders;
  response->Text = text;
  response->Headlines = headlines;
  response->Codes = codes;
  response->Diagnostics = diagnostics;

  return(response);
}

/*----------------------------------------------------------------------*/

void
freeWAISSearchResponse(response)
WAISSearchResponse* response;
{
  void* ptr = NULL;
  long i;

  s_free(response->SeedWordsUsed);

  if (response->DocHeaders != NULL)
    for (i = 0,ptr = (void *)response->DocHeaders[i]; ptr != NULL; ptr = (void *)response->DocHeaders[++i])
      freeWAISDocumentHeader((WAISDocumentHeader*)ptr);
  s_free(response->DocHeaders);

  if (response->ShortHeaders != NULL)
    for (i = 0,ptr = (void *)response->ShortHeaders[i]; ptr != NULL; ptr = (void *)response->ShortHeaders[++i])
      freeWAISDocumentShortHeader((WAISDocumentShortHeader*)ptr);
  s_free(response->ShortHeaders);

  if (response->LongHeaders != NULL)
    for (i = 0,ptr = (void *)response->LongHeaders[i]; ptr != NULL; ptr = (void *)response->LongHeaders[++i])
      freeWAISDocumentLongHeader((WAISDocumentLongHeader*)ptr);
  s_free(response->LongHeaders);

  if (response->Text != NULL)
    for (i = 0,ptr = (void *)response->Text[i]; ptr != NULL; ptr = (void *)response->Text[++i])
      freeWAISDocumentText((WAISDocumentText*)ptr);
  s_free(response->Text);

  if (response->Headlines != NULL)
    for (i = 0,ptr = (void *)response->Headlines[i]; ptr != NULL; ptr = (void *)response->Headlines[++i])
      freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);
  s_free(response->Headlines);

  if (response->Codes != NULL)
    for (i = 0,ptr = (void *)response->Codes[i]; ptr != NULL; ptr = (void *)response->Codes[++i])
      freeWAISDocumentCodes((WAISDocumentCodes*)ptr);
  s_free(response->Codes);

  if (response->Diagnostics != NULL)
    for (i = 0,ptr = (void *)response->Diagnostics[i]; ptr != NULL; ptr = (void *)response->Diagnostics[++i])
      freeDiag((diagnosticRecord*)ptr);
  s_free(response->Diagnostics);

  s_free(response);
}

/*----------------------------------------------------------------------*/

char*
writeSearchResponseInfo(query,buffer,len)
SearchResponseAPDU* query;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_UserInformationLength,
					     DefWAISSearchResponseSize);
  char* buf = buffer + header_len;
  WAISSearchResponse* info = (WAISSearchResponse*)query->DatabaseDiagnosticRecords;
  unsigned long size;
  void* header = NULL;
  long i;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeString(info->SeedWordsUsed,DT_SeedWordsUsed,buf,len);

  /* write out all the headers */
  if (info->DocHeaders != NULL)
    { for (i = 0,header = (void *)info->DocHeaders[i]; header != NULL; header = (void *)info->DocHeaders[++i])
	buf = writeWAISDocumentHeader((WAISDocumentHeader*)header,buf,len);
      }

  if (info->ShortHeaders != NULL)
    { for (i = 0,header = (void *)info->ShortHeaders[i]; header != NULL; header = (void *)info->ShortHeaders[++i])
	buf = writeWAISDocumentShortHeader((WAISDocumentShortHeader*)header,buf,len);
      }

  if (info->LongHeaders != NULL)
    { for (i = 0,header = (void *)info->LongHeaders[i]; header != NULL; header = (void *)info->LongHeaders[++i])
	buf = writeWAISDocumentLongHeader((WAISDocumentLongHeader*)header,buf,len);
      }

  if (info->Text != NULL)
    { for (i = 0,header = (void *)info->Text[i]; header != NULL; header = (void *)info->Text[++i])
	buf = writeWAISDocumentText((WAISDocumentText*)header,buf,len);
      }

  if (info->Headlines != NULL)
    { for (i = 0,header = (void *)info->Headlines[i]; header != NULL; header = (void *)info->Headlines[++i])
	buf = writeWAISDocumentHeadlines((WAISDocumentHeadlines*)header,buf,len);
      }

  if (info->Codes != NULL)
    { for (i = 0,header = (void *)info->Codes[i]; header != NULL;header = (void *)info->Codes[++i])
	buf = writeWAISDocumentCodes((WAISDocumentCodes*)header,buf,len);
      }

  if (info->Diagnostics != NULL)
    { for (i = 0, header = (void *)info->Diagnostics[i]; header != NULL; header = (void *)info->Diagnostics[++i])
	buf = writeDiag((diagnosticRecord*)header,buf,len);
      }

  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_UserInformationLength,size,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

static void
cleanUpWaisSearchResponse PARAMS((char* buf,char* seedWordsUsed,
			       WAISDocumentHeader** docHeaders,
			       WAISDocumentShortHeader** shortHeaders,
			       WAISDocumentLongHeader** longHeaders,
			       WAISDocumentText** text,
			       WAISDocumentHeadlines** headlines,
			       WAISDocumentCodes** codes,
			       diagnosticRecord**diags));

static void
cleanUpWaisSearchResponse (buf,seedWordsUsed,docHeaders,shortHeaders,
			   longHeaders,text,headlines,codes,diags)
char* buf;
char* seedWordsUsed;
WAISDocumentHeader** docHeaders;
WAISDocumentShortHeader** shortHeaders;
WAISDocumentLongHeader** longHeaders;
WAISDocumentText** text;
WAISDocumentHeadlines** headlines;
WAISDocumentCodes** codes;
diagnosticRecord** diags;
d1406 43
a1448 2
  void* ptr = NULL;
  long i;
d1450 40
a1489 75
  if (buf == NULL)
   { s_free(seedWordsUsed);
     if (docHeaders != NULL)
       for (i = 0,ptr = (void *)docHeaders[i]; ptr != NULL;
	    ptr = (void *)docHeaders[++i])
	 freeWAISDocumentHeader((WAISDocumentHeader*)ptr);
     s_free(docHeaders);
     if (shortHeaders != NULL)
       for (i = 0,ptr = (void *)shortHeaders[i]; ptr != NULL;
	    ptr = (void *)shortHeaders[++i])
	 freeWAISDocumentShortHeader((WAISDocumentShortHeader*)ptr);
     s_free(shortHeaders);
     if (longHeaders != NULL)
       for (i = 0,ptr = (void *)longHeaders[i]; ptr != NULL;
	    ptr = (void *)longHeaders[++i])
	 freeWAISDocumentLongHeader((WAISDocumentLongHeader*)ptr);
     s_free(longHeaders);
     if (text != NULL)
       for (i = 0,ptr = (void *)text[i]; ptr != NULL; ptr = (void *)text[++i])
	 freeWAISDocumentText((WAISDocumentText*)ptr);
     s_free(text);
     if (headlines != NULL)
       for (i = 0,ptr = (void *)headlines[i]; ptr != NULL;
	    ptr = (void *)headlines[++i])
	 freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);
     s_free(headlines);
     if (codes != NULL)
       for (i = 0,ptr = (void *)codes[i]; ptr != NULL;
	    ptr = (void *)codes[++i])
	 freeWAISDocumentCodes((WAISDocumentCodes*)ptr);
     s_free(codes);
     if (diags != NULL)
       for (i = 0,ptr = (void *)diags[i]; ptr != NULL;
	    ptr = (void *)diags[++i])
	 freeDiag((diagnosticRecord*)ptr);
     s_free(diags);
   }
}

/*----------------------------------------------------------------------*/

char*
readSearchResponseInfo(info,buffer)
void** info;
char* buffer;
{
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  void* header = NULL;
  WAISDocumentHeader** docHeaders = NULL;
  WAISDocumentShortHeader** shortHeaders = NULL;
  WAISDocumentLongHeader** longHeaders = NULL;
  WAISDocumentText** text = NULL;
  WAISDocumentHeadlines** headlines = NULL;
  WAISDocumentCodes** codes = NULL;
  long numDocHeaders,numLongHeaders,numShortHeaders,numText,numHeadlines;
  long numCodes;
  char* seedWordsUsed = NULL;
  diagnosticRecord** diags = NULL;
  diagnosticRecord* diag = NULL;
  long numDiags = 0;

  numDocHeaders = numLongHeaders = numShortHeaders = numText = numHeadlines = numCodes = 0;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_SeedWordsUsed:
	  buf = readString(&seedWordsUsed,buf);
	  break;
d1491 10
a1500 10
	  if (diags == NULL) /* create a new diag list */
	   { diags = (diagnosticRecord**)s_malloc((size_t)sizeof(diagnosticRecord*) * 2);
	   }
	  else /* grow the diag list */
	   { diags = (diagnosticRecord**)s_realloc((char*)diags,(size_t)(sizeof(diagnosticRecord*) * (numDiags + 2)));
	   }
	  buf = readDiag(&diag,buf);
	  diags[numDiags++] = diag; /* put it in the list */
	  diags[numDiags] = NULL;
	  break;
d1502 71
a1572 41
		  if (docHeaders == NULL) /* create a new header list */
		   { docHeaders = (WAISDocumentHeader**)s_malloc((size_t)sizeof(WAISDocumentHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { docHeaders = (WAISDocumentHeader**)s_realloc((char*)docHeaders,(size_t)(sizeof(WAISDocumentHeader*) * (numDocHeaders + 2)));
		   }
		  buf = readWAISDocumentHeader((WAISDocumentHeader**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  docHeaders[numDocHeaders++] =
		    (WAISDocumentHeader*)header; /* put it in the list */
		  docHeaders[numDocHeaders] = NULL;
		  break;
		case DT_DocumentShortHeaderGroup:
		  if (shortHeaders == NULL) /* create a new header list */
		   { shortHeaders = (WAISDocumentShortHeader**)s_malloc((size_t)sizeof(WAISDocumentShortHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { shortHeaders = (WAISDocumentShortHeader**)s_realloc((char*)shortHeaders,(size_t)(sizeof(WAISDocumentShortHeader*) * (numShortHeaders + 2)));
		   }
		  buf = readWAISDocumentShortHeader((WAISDocumentShortHeader**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  shortHeaders[numShortHeaders++] =
		    (WAISDocumentShortHeader*)header; /* put it in the list */
		  shortHeaders[numShortHeaders] = NULL;
		  break;
		case DT_DocumentLongHeaderGroup:
		  if (longHeaders == NULL) /* create a new header list */
		   { longHeaders = (WAISDocumentLongHeader**)s_malloc((size_t)sizeof(WAISDocumentLongHeader*) * 2);
		   }
		  else /* grow the doc list */
		   { longHeaders = (WAISDocumentLongHeader**)s_realloc((char*)longHeaders,(size_t)(sizeof(WAISDocumentLongHeader*) * (numLongHeaders + 2)));
		   }
		  buf = readWAISDocumentLongHeader((WAISDocumentLongHeader**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  longHeaders[numLongHeaders++] =
		    (WAISDocumentLongHeader*)header; /* put it in the list */
		  longHeaders[numLongHeaders] = NULL;
		  break;
d1574 66
a1639 41
		  if (text == NULL) /* create a new list */
		   { text = (WAISDocumentText**)s_malloc((size_t)sizeof(WAISDocumentText*) * 2);
		   }
		  else /* grow the list */
		   { text = (WAISDocumentText**)s_realloc((char*)text,(size_t)(sizeof(WAISDocumentText*) * (numText + 2)));
		   }
		  buf = readWAISDocumentText((WAISDocumentText**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  text[numText++] =
		    (WAISDocumentText*)header; /* put it in the list */
		  text[numText] = NULL;
		  break;
		case DT_DocumentHeadlineGroup:
		  if (headlines == NULL) /* create a new list */
		   { headlines = (WAISDocumentHeadlines**)s_malloc((size_t)sizeof(WAISDocumentHeadlines*) * 2);
		   }
		  else /* grow the list */
		   { headlines = (WAISDocumentHeadlines**)s_realloc((char*)headlines,(size_t)(sizeof(WAISDocumentHeadlines*) * (numHeadlines + 2)));
		   }
		  buf = readWAISDocumentHeadlines((WAISDocumentHeadlines**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  headlines[numHeadlines++] =
		    (WAISDocumentHeadlines*)header; /* put it in the list */
		  headlines[numHeadlines] = NULL;
		  break;
		case DT_DocumentCodeGroup:
		  if (codes == NULL) /* create a new list */
		   { codes = (WAISDocumentCodes**)s_malloc((size_t)sizeof(WAISDocumentCodes*) * 2);
		   }
		  else /* grow the list */
		   { codes = (WAISDocumentCodes**)s_realloc((char*)codes,(size_t)(sizeof(WAISDocumentCodes*) * (numCodes + 2)));
		   }
		  buf = readWAISDocumentCodes((WAISDocumentCodes**)&header,buf);
		  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
		  RETURN_ON_NULL(buf);
		  codes[numCodes++] =
		    (WAISDocumentCodes*)header; /* put it in the list */
		  codes[numCodes] = NULL;
		  break;
d1641 13
a1653 5
	  cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }
d1655 8
a1662 2
  *info = (void *)makeWAISSearchResponse(seedWordsUsed,docHeaders,shortHeaders,
				 longHeaders,text,headlines,codes,diags);
d1664 1
a1664 1
  return(buf);
d1669 3
a1671 5
WAISDocumentText*
makeWAISDocumentText(docID,versionNumber,documentText)
any* docID;
long versionNumber;
any* documentText;
d1673 1
a1673 1
  WAISDocumentText* docText = (WAISDocumentText*)s_malloc((size_t)sizeof(WAISDocumentText));
d1675 3
a1677 3
  docText->DocumentID = docID;
  docText->VersionNumber = versionNumber;
  docText->DocumentText = documentText;
d1679 1
a1679 1
  return(docText);
d1684 1
a1684 3
void
freeWAISDocumentText(docText)
WAISDocumentText* docText;
d1686 3
a1688 3
  freeAny(docText->DocumentID);
  freeAny(docText->DocumentText);
  s_free(docText);
d1693 2
a1694 5
char*
writeWAISDocumentText(docText,buffer,len)
WAISDocumentText* docText;
char* buffer;
long* len;
d1696 4
a1699 4
  unsigned long header_len = userInfoTagSize(DT_DocumentTextGroup,
											DefWAISDocTextSize);
  char* buf = buffer + header_len;
  unsigned long size;
d1701 1
a1701 1
  RESERVE_SPACE_FOR_WAIS_HEADER(len);
d1703 3
a1705 3
  buf = writeAny(docText->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(docText->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeAny(docText->DocumentText,DT_DocumentText,buf,len);
d1707 3
a1709 3
  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentTextGroup,size,header_len,buffer,len);
d1711 1
a1711 1
  return(buf);
d1716 1
a1716 4
char*
readWAISDocumentText(docText,buffer)
WAISDocumentText** docText;
char* buffer;
d1718 6
a1723 6
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any *docID,*documentText;
  long versionNumber;
d1725 2
a1726 2
  docID = documentText = NULL;
  versionNumber = UNUSED;
d1728 2
a1729 2
  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;
d1731 13
a1743 12
  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_DocumentID:
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_DocumentText:
		  buf = readAny(&documentText,buf);
		  break;
d1745 115
a1859 126
	  freeAny(docID);
	  freeAny(documentText);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }

  *docText = makeWAISDocumentText(docID,versionNumber,documentText);
  return(buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentHeadlines*
makeWAISDocumentHeadlines(docID,
			  versionNumber,
			  source,
			  date,
			  headline,
			  originCity)
any* docID;
long versionNumber;
char* source;
char* date;
char* headline;
char* originCity;
{
  WAISDocumentHeadlines* docHeadline =
    (WAISDocumentHeadlines*)s_malloc((size_t)sizeof(WAISDocumentHeadlines));

  docHeadline->DocumentID = docID;
  docHeadline->VersionNumber = versionNumber;
  docHeadline->Source = source;
  docHeadline->Date = date;
  docHeadline->Headline = headline;
  docHeadline->OriginCity = originCity;

  return(docHeadline);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentHeadlines(docHeadline)
WAISDocumentHeadlines* docHeadline;
{
  freeAny(docHeadline->DocumentID);
  s_free(docHeadline->Source);
  s_free(docHeadline->Date);
  s_free(docHeadline->Headline);
  s_free(docHeadline->OriginCity);
  s_free(docHeadline);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentHeadlines(docHeadline,buffer,len)
WAISDocumentHeadlines* docHeadline;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentHeadlineGroup,
											DefWAISDocHeadlineSize);
  char* buf = buffer + header_len;
  unsigned long size;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(docHeadline->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(docHeadline->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeString(docHeadline->Source,DT_Source,buf,len);
  buf = writeString(docHeadline->Date,DT_Date,buf,len);
  buf = writeString(docHeadline->Headline,DT_Headline,buf,len);
  buf = writeString(docHeadline->OriginCity,DT_OriginCity,buf,len);

  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentHeadlineGroup,size,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentHeadlines(docHeadline,buffer)
WAISDocumentHeadlines** docHeadline;
char* buffer;
{
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any* docID;
  long versionNumber;
  char *source,*date,*headline,*originCity;

  docID = NULL;
  versionNumber = UNUSED;
  source = date = headline = originCity = NULL;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_DocumentID:
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_Source:
		  buf = readString(&source,buf);
		  break;
		case DT_Date:
		  buf = readString(&date,buf);
		  break;
		case DT_Headline:
		  buf = readString(&headline,buf);
		  break;
		case DT_OriginCity:
		  buf = readString(&originCity,buf);
		  break;
d1861 110
a1970 121
	  freeAny(docID);
	  s_free(source);
	  s_free(date);
	  s_free(headline);
	  s_free(originCity);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }

  *docHeadline = makeWAISDocumentHeadlines(docID,versionNumber,source,date,
									       headline,originCity);
  return(buf);
}

/*----------------------------------------------------------------------*/

WAISDocumentCodes*
makeWAISDocumentCodes(docID,
		      versionNumber,
		      stockCodes,
		      companyCodes,
		      industryCodes)
any* docID;
long versionNumber;
char* stockCodes;
char* companyCodes;
char* industryCodes;
{
  WAISDocumentCodes* docCodes = (WAISDocumentCodes*)s_malloc((size_t)sizeof(WAISDocumentCodes));

  docCodes->DocumentID = docID;
  docCodes->VersionNumber = versionNumber;
  docCodes->StockCodes = stockCodes;
  docCodes->CompanyCodes = companyCodes;
  docCodes->IndustryCodes = industryCodes;

  return(docCodes);
}

/*----------------------------------------------------------------------*/

void
freeWAISDocumentCodes(docCodes)
WAISDocumentCodes* docCodes;
{
  freeAny(docCodes->DocumentID);
  s_free(docCodes->StockCodes);
  s_free(docCodes->CompanyCodes);
  s_free(docCodes->IndustryCodes);
  s_free(docCodes);
}

/*----------------------------------------------------------------------*/

char*
writeWAISDocumentCodes(docCodes,buffer,len)
WAISDocumentCodes* docCodes;
char* buffer;
long* len;
{
  unsigned long header_len = userInfoTagSize(DT_DocumentCodeGroup ,
											DefWAISDocCodeSize);
  char* buf = buffer + header_len;
  unsigned long size;

  RESERVE_SPACE_FOR_WAIS_HEADER(len);

  buf = writeAny(docCodes->DocumentID,DT_DocumentID,buf,len);
  buf = writeNum(docCodes->VersionNumber,DT_VersionNumber,buf,len);
  buf = writeString(docCodes->StockCodes,DT_StockCodes,buf,len);
  buf = writeString(docCodes->CompanyCodes,DT_CompanyCodes,buf,len);
  buf = writeString(docCodes->IndustryCodes,DT_IndustryCodes,buf,len);

  /* now write the header and size */
  size = buf - buffer;
  buf = writeUserInfoHeader(DT_DocumentCodeGroup,size,header_len,buffer,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readWAISDocumentCodes(docCodes,buffer)
WAISDocumentCodes** docCodes;
char* buffer;
{
  char* buf = buffer;
  unsigned long size;
  unsigned long headerSize;
  data_tag tag1;
  any* docID;
  long versionNumber;
  char *stockCodes,*companyCodes,*industryCodes;

  docID = NULL;
  versionNumber = UNUSED;
  stockCodes = companyCodes = industryCodes = NULL;

  buf = readUserInfoHeader(&tag1,&size,buf);
  headerSize = buf - buffer;

  while (buf < (buffer + size + headerSize))
   { data_tag tag = peekTag(buf);
     switch (tag)
      { case DT_DocumentID:
		  buf = readAny(&docID,buf);
		  break;
		case DT_VersionNumber:
		  buf = readNum(&versionNumber,buf);
		  break;
		case DT_StockCodes:
		  buf = readString(&stockCodes,buf);
		  break;
		case DT_CompanyCodes:
		  buf = readString(&companyCodes,buf);
		  break;
		case DT_IndustryCodes:
		  buf = readString(&industryCodes,buf);
		  break;
d1972 8
a1979 8
	  freeAny(docID);
	  s_free(stockCodes);
	  s_free(companyCodes);
	  s_free(industryCodes);
	  REPORT_READ_ERROR(buf);
	  break;
      }
   }
d1981 3
a1983 3
  *docCodes = makeWAISDocumentCodes(docID,versionNumber,stockCodes,
									companyCodes,industryCodes);
  return(buf);
d1988 2
a1989 5
char*
writePresentInfo(present,buffer,len)
PresentAPDU* present GCC_UNUSED;
char* buffer;
long* len GCC_UNUSED;
d1991 2
a1992 2
  /* The WAIS protocol doesn't use present info */
  return(buffer);
d1997 2
a1998 4
char*
readPresentInfo(info,buffer)
void** info;
char* buffer;
d2000 3
a2002 3
  /* The WAIS protocol doesn't use present info */
  *info = NULL;
  return(buffer);
d2007 2
a2008 5
char*
writePresentResponseInfo(response,buffer,len)
PresentResponseAPDU* response GCC_UNUSED;
char* buffer;
long* len GCC_UNUSED;
d2010 2
a2011 2
  /* The WAIS protocol doesn't use presentResponse info */
  return(buffer);
d2016 2
a2017 4
char*
readPresentResponseInfo(info,buffer)
void** info;
char* buffer;
d2019 3
a2021 3
  /* The WAIS protocol doesn't use presentResponse info */
  *info = NULL;
  return(buffer);
d2063 1
a2063 5
static query_term** makeWAISQueryTerms PARAMS((DocObj** docs));

static query_term**
makeWAISQueryTerms(docs)
DocObj** docs;
d2068 30
a2097 80
  query_term** terms = NULL;
  long numTerms = 0;
  DocObj* doc = NULL;
  long i;

  if (docs == NULL)
    return((query_term**)NULL);

  terms = (query_term**)s_malloc((size_t)(sizeof(query_term*) * 1));
  terms[numTerms] = NULL;

  /* loop through the docs making terms for them all */
  for (i = 0,doc = docs[i]; doc != NULL; doc = docs[++i])
    { any* type = NULL;

      if (doc->Type != NULL)
	type = stringToAny(doc->Type);

      if (doc->ChunkCode == CT_document) /* a whole document */
	{ terms = (query_term**)s_realloc((char*)terms,
					  (size_t)(sizeof(query_term*) *
						   (numTerms + 3 + 1)));
	  terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						EQUAL,IGNORE,IGNORE,
						IGNORE,IGNORE,doc->DocumentID);
	  if (type != NULL)
	   { terms[numTerms++] = makeAttributeTerm(DATA_TYPE,EQUAL,
						   IGNORE,IGNORE,IGNORE,
						   IGNORE,type);
	     terms[numTerms++] = makeOperatorTerm(AND);
	   }
	  terms[numTerms] = NULL;
	}
      else			/* a document fragment */
	{	char chunk_att[ATTRIBUTE_SIZE];
		any* startChunk = NULL;
		any* endChunk = NULL;

		terms = (query_term**)s_realloc((char*)terms,
						(size_t)(sizeof(query_term*) *
							 (numTerms + 7 + 1)));

		switch (doc->ChunkCode)
		  { case CT_byte:
		    case CT_line:
		      { char start[20],end[20];
			(doc->ChunkCode == CT_byte) ?
			  strncpy(chunk_att,BYTE,ATTRIBUTE_SIZE) :
			strncpy(chunk_att,LINE,ATTRIBUTE_SIZE);
			sprintf(start,"%ld",doc->ChunkStart.Pos);
			startChunk = stringToAny(start);
			sprintf(end,"%ld",doc->ChunkEnd.Pos);
			endChunk = stringToAny(end);
		      }
		      break;
		    case CT_paragraph:
		      strncpy(chunk_att,PARAGRAPH,ATTRIBUTE_SIZE);
		      startChunk = doc->ChunkStart.ID;
		      endChunk = doc->ChunkEnd.ID;
		      break;
		    default:
		      /* error */
		      break;
		    }

		terms[numTerms++] = makeAttributeTerm(SYSTEM_CONTROL_NUMBER,
						      EQUAL,IGNORE,IGNORE,
						      IGNORE,
						      IGNORE,doc->DocumentID);
		if (type != NULL)
		 { terms[numTerms++] = makeAttributeTerm(DATA_TYPE,EQUAL,IGNORE,
							 IGNORE,IGNORE,IGNORE,
							 type);
		   terms[numTerms++] = makeOperatorTerm(AND);
		 }
		terms[numTerms++] = makeAttributeTerm(chunk_att,
						      GREATER_THAN_OR_EQUAL,
						      IGNORE,IGNORE,IGNORE,
						      IGNORE,
						      startChunk);
d2099 42
a2140 4
		terms[numTerms++] = makeAttributeTerm(chunk_att,LESS_THAN,
						      IGNORE,IGNORE,IGNORE,
						      IGNORE,
						      endChunk);
d2142 21
a2162 1
		terms[numTerms] = NULL;
d2164 6
a2169 14
		if (doc->ChunkCode == CT_byte || doc->ChunkCode == CT_line)
		  { freeAny(startChunk);
		    freeAny(endChunk);
		  }
	      }

      freeAny(type);

     if (i != 0) /* multiple independent queries, need a disjunction */
	{ terms = (query_term**)s_realloc((char*)terms,
					  (size_t)(sizeof(query_term*) *
						   (numTerms + 1 + 1)));
	  terms[numTerms++] = makeOperatorTerm(OR);
	  terms[numTerms] = NULL;
d2173 1
a2173 1
  return(terms);
d2178 1
a2178 5
static DocObj** makeWAISQueryDocs PARAMS((query_term** terms));

static DocObj**
makeWAISQueryDocs(terms)
query_term** terms;
d2183 19
a2201 5
  query_term* docTerm = NULL;
  query_term* fragmentTerm = NULL;
  DocObj** docs = NULL;
  DocObj* doc = NULL;
  long docNum,termNum;
d2203 2
a2204 1
  docNum = termNum = 0;
d2206 1
a2206 2
  docs = (DocObj**)s_malloc((size_t)(sizeof(DocObj*) * 1));
  docs[docNum] = NULL;
d2208 1
a2208 57
  /* translate the terms into DocObjs */
  while (true)
    {
      query_term* typeTerm = NULL;
      char* type = NULL;
      long startTermOffset;

      docTerm = terms[termNum];

      if (docTerm == NULL)
	break;			/* we're done converting */

      typeTerm = terms[termNum + 1]; /* get the lead Term if it exists */

      if (strcmp(typeTerm->Use,DATA_TYPE) == 0)	/* we do have a type */
       { startTermOffset = 3;
	 type = anyToString(typeTerm->Term);
       }
      else			/* no type */
       { startTermOffset = 1;
	 typeTerm = NULL;
	 type = NULL;
       }

      /* grow the doc list */
      docs = (DocObj**)s_realloc((char*)docs,(size_t)(sizeof(DocObj*) *
						      (docNum + 1 + 1)));

      /* figure out what kind of docObj to build - and build it */
      fragmentTerm = terms[termNum + startTermOffset];
      if (fragmentTerm != NULL && fragmentTerm->TermType == TT_Attribute)
	{			/* build a document fragment */
	  query_term* startTerm = fragmentTerm;
	  query_term* endTerm = terms[termNum + startTermOffset + 2];

	  if (strcmp(startTerm->Use,BYTE) == 0){ /* a byte chunk */
	    doc = makeDocObjUsingBytes(duplicateAny(docTerm->Term),
				       type,
				       anyToLong(startTerm->Term),
				       anyToLong(endTerm->Term));
	   log_write("byte");
	  }else if (strcmp(startTerm->Use,LINE) == 0){ /* a line chunk */
	    doc = makeDocObjUsingLines(duplicateAny(docTerm->Term),
				       type,
				       anyToLong(startTerm->Term),
				       anyToLong(endTerm->Term));
	    log_write("line");
	  }else{
	log_write("chunk");			/* a paragraph chunk */
	    doc = makeDocObjUsingParagraphs(duplicateAny(docTerm->Term),
					    type,
					    duplicateAny(startTerm->Term),
					    duplicateAny(endTerm->Term));
}
	  termNum += (startTermOffset + 4);	/* point to next term */
	}
      else			/* build a full document */
d2210 6
a2215 4
	  doc = makeDocObjUsingWholeDocument(duplicateAny(docTerm->Term),
					     type);
log_write("whole doc");
	  termNum += startTermOffset;	/* point to next term */
d2218 35
a2252 1
      docs[docNum++] = doc;	/* insert the new document */
d2254 1
a2254 1
      docs[docNum] = NULL;	/* keep the doc list terminated */
d2256 1
d2258 4
a2261 4
      if (terms[termNum] != NULL)
	termNum++; /* skip the OR operator it necessary */
      else
	break; /* we are done */
d2264 1
a2264 1
  return(docs);
d2269 1
a2269 3
any*
makeWAISTextQuery(docs)
DocObj** docs;
d2274 2
a2275 2
  any *buf = NULL;
  query_term** terms = NULL;
d2277 2
a2278 2
  terms = makeWAISQueryTerms(docs);
  buf = writeQuery(terms);
d2280 2
a2281 2
  doList((void**)terms,freeTerm);
  s_free(terms);
d2283 1
a2283 1
  return(buf);
d2288 1
a2288 3
DocObj**
readWAISTextQuery(buf)
any* buf;
d2293 2
a2294 2
  query_term** terms = NULL;
  DocObj** docs = NULL;
d2296 2
a2297 2
  terms = readQuery(buf);
  docs = makeWAISQueryDocs(terms);
d2299 2
a2300 2
  doList((void**)terms,freeTerm);
  s_free(terms);
d2302 1
a2302 1
  return(docs);
d2315 1
a2315 3
void
CSTFreeWAISInitResponse(init)
WAISInitResponse* init;
d2318 1
a2318 1
  s_free(init);
d2323 1
a2323 3
void
CSTFreeWAISSearch(query)
WAISSearch* query;
d2326 1
a2326 1
  s_free(query);
d2331 1
a2331 3
void
CSTFreeDocObj(doc)
DocObj* doc;
d2339 1
a2339 3
void
CSTFreeWAISDocumentHeader(header)
WAISDocumentHeader* header;
d2346 1
a2346 3
void
CSTFreeWAISDocumentShortHeader(header)
WAISDocumentShortHeader* header;
d2348 1
a2348 1
  s_free(header);
d2350 1
d2353 1
a2353 3
void
CSTFreeWAISDocumentLongHeader(header)
WAISDocumentLongHeader* header;
d2355 1
a2355 1
  s_free(header);
d2360 1
a2360 3
void
CSTFreeWAISSearchResponse(response)
WAISSearchResponse* response;
d2362 1
a2362 1
  s_free(response);
d2367 1
a2367 3
void
CSTFreeWAISDocumentText(docText)
WAISDocumentText* docText;
d2369 1
a2369 1
  s_free(docText);
d2374 1
a2374 3
void
CSTFreeWAISDocHeadlines(docHeadline)
WAISDocumentHeadlines* docHeadline;
d2376 1
a2376 1
  s_free(docHeadline);
d2381 1
a2381 3
void
CSTFreeWAISDocumentCodes(docCodes)
WAISDocumentCodes* docCodes;
d2383 1
a2383 1
  s_free(docCodes);
d2388 1
a2388 3
void
CSTFreeWAISTextQuery(query)
any* query;
d2390 1
a2390 1
   freeAny(query);
a2394 1

d2396 3
a2398 3
**	Routines originally from WMessage.c -- FM
**
**----------------------------------------------------------------------*/
d2400 4
a2403 4
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.
   3.26.90
*/
d2416 12
a2427 14
void
readWAISPacketHeader(msgBuffer,header_struct)
char* msgBuffer;
WAISMessage *header_struct;
{
  /* msgBuffer is a string containing at least HEADER_LENGTH bytes. */

  memmove(header_struct->msg_len,msgBuffer,(size_t)10);
  header_struct->msg_type = char_downcase((unsigned long)msgBuffer[10]);
  header_struct->hdr_vers = char_downcase((unsigned long)msgBuffer[11]);
  memmove(header_struct->server,(void*)(msgBuffer + 12),(size_t)10);
  header_struct->compression = char_downcase((unsigned long)msgBuffer[22]);
  header_struct->encoding = char_downcase((unsigned long)msgBuffer[23]);
  header_struct->msg_checksum = char_downcase((unsigned long)msgBuffer[24]);
d2436 7
a2442 15
void
writeWAISPacketHeader(header,
		      dataLen,
		      type,
		      server,
		      compression,
		      encoding,
		      version)
char* header;
long dataLen;
long type;
char* server;
long compression;
long encoding;
long version;
d2445 2
a2446 2
  char lengthBuf[11];
  char serverBuf[11];
d2448 1
a2448 3
  long serverLen = strlen(server);
  if (serverLen > 10)
    serverLen = 10;
d2450 2
a2451 2
  sprintf(lengthBuf, "%010ld", dataLen);
  strncpy(header,lengthBuf,10);
d2453 2
a2454 2
  header[10] = type & 0xFF;
  header[11] = version & 0xFF;
d2456 2
a2457 2
  strncpy(serverBuf,server,serverLen);
  strncpy((char*)(header + 12),serverBuf,serverLen);
d2459 6
a2464 3
  header[22] = compression & 0xFF;
  header[23] = encoding & 0xFF;
  header[24] = '0'; /* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */
a2467 1

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d15 2
a16 2
   disclaimer.	
  
d18 1
a18 1
   3.30.90  Harry Morris 
d31 1
a31 1
/*	This file implements the Z39.50 extensions required for WAIS 
d56 1
a56 1
     	*len -= header_len;
d68 1
a68 1
   length 
d76 1
a76 1
      
d78 1
a78 1
}   
d82 1
a82 1
static char* writeUserInfoHeader PARAMS((data_tag tag,long infoSize,	
d98 1
a98 1
   do that writing. 
d108 1
a108 1
  
d111 1
a111 1
  
d119 1
a119 1
   
d122 1
a122 1
  
d142 1
a142 1
  return(buf); 
d147 1
a147 1
WAISInitResponse* 
d170 1
a170 1
  
d176 1
a176 1
void 
d202 1
a202 1
  
d204 1
a204 1
    
d211 1
a211 1
  
d213 1
a213 1
  size = buf - buffer; 
d215 1
a215 1
  
d228 1
a228 1
  unsigned long size; 
d236 1
a236 1
  
d238 1
a238 1
  
d241 1
a241 1
    
d271 1
a271 1
  	  
d280 1
a280 1
WAISSearch* 
d297 1
a297 1
{ 
d307 1
a307 1
  
d313 1
a313 1
void 
d321 1
a321 1
  
d323 1
a323 1
  
d328 1
a328 1
   
d341 1
a341 1
DocObj* 
d358 1
a358 1
DocObj* 
d379 1
a379 1
DocObj* 
d400 1
a400 1
DocObj* 
d414 2
a415 2
  doc->ChunkStart.ID = start; 
  doc->ChunkEnd.ID = end; 
d449 1
a449 1
  
d455 1
a455 1
  
d458 1
a458 1
  
d479 1
a479 1
   
d496 1
a496 1
  
d498 1
a498 1
  
d501 1
a501 1
  
d542 1
a542 1
  return(buf);  
d547 1
a547 1
char* 
d560 1
a560 1
						 DefWAISSearchSize); 
d565 1
a565 1
  
d567 1
a567 1
       
d575 1
a575 1
   
d577 1
a577 1
 
d582 1
a582 1
  
d584 1
a584 1
      size = buf - buffer; 
d586 1
a586 1
   
d593 1
a593 1
char* 
d610 1
a610 1
      unsigned long size; 
d617 1
a617 1
      char** textList = NULL; 
d625 1
a625 1
  
d628 1
a628 1
  
d644 1
a644 1
		if (buf == NULL) 
d686 1
a686 1
  	  
d725 1
a725 1
  WAISDocumentHeader* header = 
d739 1
a739 1
  
d772 1
a772 1
  
d774 1
a774 1
   
d790 1
a790 1
	  size += typeSize; 
d800 1
a800 1
  
d802 1
a802 1
  size1 = buf - buffer; 
d816 1
a816 1
  unsigned long size1; 
d826 1
a826 1
  
d828 1
a828 1
  
d831 1
a831 1
    
d891 1
a891 1
  	  
d918 1
a918 1
  WAISDocumentShortHeader* header = 
d927 1
a927 1
  
d953 1
a953 1
  
d955 1
a955 1
   
d962 1
a962 1
  
d964 1
a964 1
  size = buf - buffer; 
d978 1
a978 1
  unsigned long size; 
d983 1
a983 1
  
d985 1
a985 1
  
d988 1
a988 1
    
d1016 1
a1016 1
  	  
d1058 1
a1058 1
  WAISDocumentLongHeader* header = 
d1075 1
a1075 1
  
d1109 1
a1109 1
  
d1111 1
a1111 1
   
d1127 1
a1127 1
	  size += typeSize; 
d1140 1
a1140 1
  
d1142 1
a1142 1
  size1 = buf - buffer; 
d1156 1
a1156 1
  unsigned long size1; 
d1163 1
a1163 1
  
d1168 1
a1168 1
  
d1171 1
a1171 1
    
d1243 1
a1243 1
  	  
d1272 1
a1272 1
  
d1281 1
a1281 1
  
d1300 1
a1300 1
   
d1305 1
a1305 1
   
d1310 1
a1310 1
   
d1315 1
a1315 1
   
d1320 1
a1320 1
   
d1325 1
a1325 1
   
d1330 1
a1330 1
  
d1336 1
a1336 1
char* 
d1349 1
a1349 1
  
d1351 1
a1351 1
  
d1353 1
a1353 1
  
d1359 1
a1359 1
   
d1389 1
a1389 1
   
d1391 1
a1391 1
  size = buf - buffer; 
d1393 1
a1393 1
  
d1421 1
a1421 1
/* if buf is NULL, we have just gotten a read error, and need to clean up 
d1429 8
a1436 8
  if (buf == NULL)						
   { s_free(seedWordsUsed);				
     if (docHeaders != NULL)				
       for (i = 0,ptr = (void *)docHeaders[i]; ptr != NULL; 
	    ptr = (void *)docHeaders[++i])		
	 freeWAISDocumentHeader((WAISDocumentHeader*)ptr);	
     s_free(docHeaders);				
     if (shortHeaders != NULL)	
d1438 1
a1438 1
	    ptr = (void *)shortHeaders[++i])	
d1440 4
a1443 4
     s_free(shortHeaders);						
     if (longHeaders != NULL)				
       for (i = 0,ptr = (void *)longHeaders[i]; ptr != NULL; 
	    ptr = (void *)longHeaders[++i])	
d1445 2
a1446 2
     s_free(longHeaders);				
     if (text != NULL)					
d1448 3
a1450 3
	 freeWAISDocumentText((WAISDocumentText*)ptr);	
     s_free(text);					
     if (headlines != NULL)					
d1452 12
a1463 12
	    ptr = (void *)headlines[++i])		
	 freeWAISDocumentHeadlines((WAISDocumentHeadlines*)ptr);	
     s_free(headlines);						
     if (codes != NULL)				     
       for (i = 0,ptr = (void *)codes[i]; ptr != NULL; 
	    ptr = (void *)codes[++i])				
	 freeWAISDocumentCodes((WAISDocumentCodes*)ptr);	 
     s_free(codes);					
     if (diags != NULL)				      	
       for (i = 0,ptr = (void *)diags[i]; ptr != NULL; 
	    ptr = (void *)diags[++i])	 
	 freeDiag((diagnosticRecord*)ptr);	     
d1476 1
a1476 1
  unsigned long size; 
d1492 1
a1492 1
  
d1494 1
a1494 1
  
d1497 1
a1497 1
    
d1502 21
a1522 21
      	  buf = readString(&seedWordsUsed,buf);
      	  break;
      	case DT_DatabaseDiagnosticRecords:
      	  if (diags == NULL) /* create a new diag list */
      	   { diags = (diagnosticRecord**)s_malloc((size_t)sizeof(diagnosticRecord*) * 2);
      	   }
      	  else /* grow the diag list */
      	   { diags = (diagnosticRecord**)s_realloc((char*)diags,(size_t)(sizeof(diagnosticRecord*) * (numDiags + 2)));
      	   }
      	  buf = readDiag(&diag,buf);
      	  diags[numDiags++] = diag; /* put it in the list */
      	  diags[numDiags] = NULL;
      	  break;
      	case DT_DocumentHeaderGroup:
  		  if (docHeaders == NULL) /* create a new header list */
  		   { docHeaders = (WAISDocumentHeader**)s_malloc((size_t)sizeof(WAISDocumentHeader*) * 2);
  		   }
  		  else /* grow the doc list */
  		   { docHeaders = (WAISDocumentHeader**)s_realloc((char*)docHeaders,(size_t)(sizeof(WAISDocumentHeader*) * (numDocHeaders + 2)));
  		   }
  		  buf = readWAISDocumentHeader((WAISDocumentHeader**)&header,buf);
d1524 2
a1525 2
  		  RETURN_ON_NULL(buf);
  		  docHeaders[numDocHeaders++] = 
d1527 10
a1536 10
  		  docHeaders[numDocHeaders] = NULL;
  		  break;
  		case DT_DocumentShortHeaderGroup:
  		  if (shortHeaders == NULL) /* create a new header list */
  		   { shortHeaders = (WAISDocumentShortHeader**)s_malloc((size_t)sizeof(WAISDocumentShortHeader*) * 2);
  		   }
  		  else /* grow the doc list */
  		   { shortHeaders = (WAISDocumentShortHeader**)s_realloc((char*)shortHeaders,(size_t)(sizeof(WAISDocumentShortHeader*) * (numShortHeaders + 2)));
  		   }
  		  buf = readWAISDocumentShortHeader((WAISDocumentShortHeader**)&header,buf);
d1538 2
a1539 2
  		  RETURN_ON_NULL(buf);
  		  shortHeaders[numShortHeaders++] = 
d1541 10
a1550 10
  		  shortHeaders[numShortHeaders] = NULL;
  		  break;
  		case DT_DocumentLongHeaderGroup:
  		  if (longHeaders == NULL) /* create a new header list */
  		   { longHeaders = (WAISDocumentLongHeader**)s_malloc((size_t)sizeof(WAISDocumentLongHeader*) * 2);
  		   }
  		  else /* grow the doc list */
  		   { longHeaders = (WAISDocumentLongHeader**)s_realloc((char*)longHeaders,(size_t)(sizeof(WAISDocumentLongHeader*) * (numLongHeaders + 2)));
  		   }
  		  buf = readWAISDocumentLongHeader((WAISDocumentLongHeader**)&header,buf);
d1552 2
a1553 2
  		  RETURN_ON_NULL(buf);
  		  longHeaders[numLongHeaders++] = 
d1555 10
a1564 10
  		  longHeaders[numLongHeaders] = NULL;
  		  break;
        case DT_DocumentTextGroup:
  		  if (text == NULL) /* create a new list */
  		   { text = (WAISDocumentText**)s_malloc((size_t)sizeof(WAISDocumentText*) * 2);
  		   }
  		  else /* grow the list */
  		   { text = (WAISDocumentText**)s_realloc((char*)text,(size_t)(sizeof(WAISDocumentText*) * (numText + 2)));
  		   }
  		  buf = readWAISDocumentText((WAISDocumentText**)&header,buf);
d1566 2
a1567 2
  		  RETURN_ON_NULL(buf);
  		  text[numText++] = 
d1569 10
a1578 10
  		  text[numText] = NULL;
  		  break;
  		case DT_DocumentHeadlineGroup:
  		  if (headlines == NULL) /* create a new list */
  		   { headlines = (WAISDocumentHeadlines**)s_malloc((size_t)sizeof(WAISDocumentHeadlines*) * 2);
  		   }
  		  else /* grow the list */
  		   { headlines = (WAISDocumentHeadlines**)s_realloc((char*)headlines,(size_t)(sizeof(WAISDocumentHeadlines*) * (numHeadlines + 2)));
  		   }
  		  buf = readWAISDocumentHeadlines((WAISDocumentHeadlines**)&header,buf);
d1580 2
a1581 2
  		  RETURN_ON_NULL(buf);
  		  headlines[numHeadlines++] = 
d1583 10
a1592 10
  		  headlines[numHeadlines] = NULL;
  		  break;
  		case DT_DocumentCodeGroup:
  		  if (codes == NULL) /* create a new list */
  		   { codes = (WAISDocumentCodes**)s_malloc((size_t)sizeof(WAISDocumentCodes*) * 2);
  		   }
  		  else /* grow the list */
  		   { codes = (WAISDocumentCodes**)s_realloc((char*)codes,(size_t)(sizeof(WAISDocumentCodes*) * (numCodes + 2)));
  		   }
  		  buf = readWAISDocumentCodes((WAISDocumentCodes**)&header,buf);
d1594 2
a1595 2
  		  RETURN_ON_NULL(buf);
  		  codes[numCodes++] = 
d1597 6
a1602 6
  		  codes[numCodes] = NULL;
  		  break;
        default:
          cleanUpWaisSearchResponse(buf,seedWordsUsed,docHeaders,shortHeaders,longHeaders,text,headlines,codes,diags);
          REPORT_READ_ERROR(buf);
          break;
d1605 1
a1605 1
  	  
d1608 1
a1608 1
  
d1625 1
a1625 1
  
d1631 1
a1631 1
void 
d1642 1
a1642 1
char* 
d1652 1
a1652 1
  
d1658 1
a1658 1
  
d1660 1
a1660 1
  size = buf - buffer; 
d1668 1
a1668 1
char* 
d1674 1
a1674 1
  unsigned long size; 
d1679 1
a1679 1
  
d1682 1
a1682 1
  
d1685 1
a1685 1
    
d1690 13
a1702 13
  		  buf = readAny(&docID,buf);
  		  break;
  		case DT_VersionNumber:
  		  buf = readNum(&versionNumber,buf);
  		  break;
  		case DT_DocumentText:
  		  buf = readAny(&documentText,buf);
  		  break;
        default:
          freeAny(docID);
          freeAny(documentText);
          REPORT_READ_ERROR(buf);
          break;
d1705 1
a1705 1
  	  
d1735 1
a1735 1
  
d1741 1
a1741 1
void 
d1755 1
a1755 1
char* 
d1765 1
a1765 1
  
d1774 1
a1774 1
  
d1776 1
a1776 1
  size = buf - buffer; 
d1784 1
a1784 1
char* 
d1790 1
a1790 1
  unsigned long size; 
d1796 1
a1796 1
  
d1800 1
a1800 1
  
d1803 1
a1803 1
    
d1808 25
a1832 25
  		  buf = readAny(&docID,buf);
  		  break;
  		case DT_VersionNumber:
  		  buf = readNum(&versionNumber,buf);
  		  break;
  		case DT_Source:
  		  buf = readString(&source,buf);
  		  break;
  		case DT_Date:
  		  buf = readString(&date,buf);
  		  break;
  		case DT_Headline:
  		  buf = readString(&headline,buf);
  		  break;
  		case DT_OriginCity:
  		  buf = readString(&originCity,buf);
  		  break;
        default:
          freeAny(docID);
          s_free(source);
          s_free(date);
          s_free(headline);
          s_free(originCity);
          REPORT_READ_ERROR(buf);
          break;
d1835 1
a1835 1
  	  
d1837 1
a1837 1
  									       headline,originCity);
d1862 1
a1862 1
  
d1868 1
a1868 1
void 
d1881 1
a1881 1
char* 
d1891 1
a1891 1
  
d1899 1
a1899 1
  
d1901 1
a1901 1
  size = buf - buffer; 
d1909 1
a1909 1
char* 
d1915 1
a1915 1
  unsigned long size; 
d1921 1
a1921 1
  
d1925 1
a1925 1
  
d1928 1
a1928 1
    
d1933 21
a1953 21
  		  buf = readAny(&docID,buf);
  		  break;
  		case DT_VersionNumber:
  		  buf = readNum(&versionNumber,buf);
  		  break;
  		case DT_StockCodes:
  		  buf = readString(&stockCodes,buf);
  		  break;
  		case DT_CompanyCodes:
  		  buf = readString(&companyCodes,buf);
  		  break;
  		case DT_IndustryCodes:
  		  buf = readString(&industryCodes,buf);
  		  break;
        default:
          freeAny(docID);
          s_free(stockCodes);
          s_free(companyCodes);
          s_free(industryCodes);
          REPORT_READ_ERROR(buf);
          break;
d1956 1
a1956 1
  	  
d1958 1
a1958 1
  									companyCodes,industryCodes);
d1964 1
a1964 1
char* 
d1976 1
a1976 1
char* 
d1988 1
a1988 1
char* 
d2000 1
a2000 1
char* 
d2021 1
a2021 1
       
d2024 3
a2026 3
            System_Control_Number = docID
            Data Type = type (optional)
            And
d2030 17
a2046 17
            System_Control_Number = docID
            Data Type = type (optional)
            And
	    	Chunk >= start
	    	And
	    	Chunk < end
	    	And

   		Information from multiple documents may be requested by using 
   		groups of the above joined by:

            OR

   		( XXX does an OR come after every group but the first, or do they
              all come at the end? )
              
        ( XXX return type could be in the element set)
d2050 1
a2050 1
   
d2078 1
a2078 1
					  (size_t)(sizeof(query_term*) * 
d2088 1
a2088 1
           }
d2095 1
a2095 1
 
d2097 1
a2097 1
						(size_t)(sizeof(query_term*) * 
d2106 1
a2106 1
			strncpy(chunk_att,LINE,ATTRIBUTE_SIZE);	
d2135 1
a2135 1
						      IGNORE,IGNORE,IGNORE, 
d2151 1
a2151 1
      
d2153 1
a2153 1
      
d2156 1
a2156 1
					  (size_t)(sizeof(query_term*) * 
d2170 1
a2170 1
static DocObj** 
d2173 1
a2173 1
/* given a list of terms in the form given above, convert them to 
d2184 1
a2184 1
  
d2190 1
a2190 1
    {	      
d2196 1
a2196 1
     
d2203 1
a2203 1
       { startTermOffset = 3;	
d2206 1
a2206 1
      else 				   	/* no type */
d2213 1
a2213 1
      docs = (DocObj**)s_realloc((char*)docs,(size_t)(sizeof(DocObj*) * 
d2221 1
a2221 1
	  query_term* endTerm = terms[termNum + startTermOffset + 2]; 
d2228 1
a2228 1
           log_write("byte");
d2234 1
a2234 1
            log_write("line");
d2245 1
a2245 1
	{ 
d2251 1
a2251 1
     
d2253 1
a2253 1
	 
d2256 1
a2256 1
	 
d2268 1
a2268 1
any* 
d2277 1
a2277 1
  
d2280 1
a2280 1
  
d2283 1
a2283 1
  
d2289 1
a2289 1
DocObj** 
d2292 1
a2292 1
/* given an any whose contents are type 1 queries of the WAIS sort, 
d2298 1
a2298 1
  
d2301 1
a2301 1
  
d2304 1
a2304 1
  
d2318 1
a2318 1
void 
d2328 1
a2328 1
void 
d2332 1
a2332 1
{ 
d2342 1
a2342 1
{ 
d2351 1
a2351 1
{ 
d2360 1
a2360 1
{ 
d2377 1
a2377 1
{ 
d2383 1
a2383 1
void 
d2386 1
a2386 1
{ 
d2392 1
a2392 1
void 
d2395 1
a2395 1
{ 
d2401 1
a2401 1
void 
d2410 1
a2410 1
void 
d2426 1
a2426 1
   disclaimer.    
d2441 1
a2441 1
void 
d2447 2
a2448 2
		    
  memmove(header_struct->msg_len,msgBuffer,(size_t)10); 
d2456 1
a2456 1
 
d2462 1
a2462 1
 
d2487 1
a2487 1
  sprintf(lengthBuf, "%010ld", dataLen);  
d2490 1
a2490 1
  header[10] = type & 0xFF; 
d2493 1
a2493 1
  strncpy(serverBuf,server,serverLen);       
d2496 5
a2500 5
  header[22] = compression & 0xFF;    
  header[23] = encoding & 0xFF;    
  header[24] = '0'; /* checkSum(header + HEADER_LENGTH,dataLen);   XXX the result must be ascii */	
}              
              
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d868 1
d1208 1
d2198 1
a2198 1
	break;			/* we're done converting */;
@


1.1
log
@Initial revision
@
text
@d34 3
a36 4
#include "HTUtils.h"
#include "tcp.h"
#include "HTVMS_WaisUI.h"
#include "HTVMS_WaisProt.h"
d38 1
a38 1
#include "LYLeaks.h"
d60 1
a60 1
static unsigned long userInfoTagSize _AP((data_tag tag,
d82 1
a82 1
static char* writeUserInfoHeader _AP((data_tag tag,long infoSize,	
d129 1
a129 1
static char* readUserInfoHeader _AP((data_tag* tag,unsigned long* num,
a229 1
  data_tag tag;
d231 1
d239 1
a239 1
  buf = readUserInfoHeader(&tag,&size,buf);
d438 1
a438 1
static char* writeDocObj _AP((DocObj* doc,char* buffer,long* len));
d485 1
a485 1
static char* readDocObj _AP((DocObj** doc,char* buffer));
d612 1
a612 1
      data_tag tag;
d626 1
a626 1
      buf = readUserInfoHeader(&tag,&size,buf);
d771 1
a771 1
  unsigned long size;
d802 2
a803 2
  size = buf - buffer; 
  buf = writeUserInfoHeader(DT_DocumentHeaderGroup,size,header_len,buffer,len);
d816 1
a816 1
  unsigned long size; 
d818 1
a818 1
  data_tag tag;
d829 1
a829 1
  buf = readUserInfoHeader(&tag,&size,buf);
d832 1
a832 1
  while (buf < (buffer + size + headerSize))
d979 1
a979 1
  data_tag tag;
d985 1
a985 1
  buf = readUserInfoHeader(&tag,&size,buf);
d1107 1
a1107 1
  unsigned long size;
d1141 2
a1142 2
  size = buf - buffer; 
  buf = writeUserInfoHeader(DT_DocumentLongHeaderGroup,size,header_len,buffer,len);
d1155 1
a1155 1
  unsigned long size; 
d1157 1
a1157 1
  data_tag tag;
d1168 1
a1168 1
  buf = readUserInfoHeader(&tag,&size,buf);
d1171 1
a1171 1
  while (buf < (buffer + size + headerSize))
d1398 1
a1398 1
cleanUpWaisSearchResponse _AP((char* buf,char* seedWordsUsed,
d1476 1
a1476 1
  data_tag tag;
d1493 1
a1493 1
  buf = readUserInfoHeader(&tag,&size,buf);
d1674 1
a1674 1
  data_tag tag;
d1681 1
a1681 1
  buf = readUserInfoHeader(&tag,&size,buf);
d1790 1
a1790 1
  data_tag tag;
d1799 1
a1799 1
  buf = readUserInfoHeader(&tag,&size,buf);
d1915 1
a1915 1
  data_tag tag;
d1924 1
a1924 1
  buf = readUserInfoHeader(&tag,&size,buf);
d1964 1
a1964 1
PresentAPDU* present;
d1966 1
a1966 1
long* len;
d1988 1
a1988 1
PresentResponseAPDU* response;
d1990 1
a1990 1
long* len;
d2047 1
a2047 1
static query_term** makeWAISQueryTerms _AP((DocObj** docs));
d2166 1
a2166 1
static DocObj** makeWAISQueryDocs _AP((query_term** terms));
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
