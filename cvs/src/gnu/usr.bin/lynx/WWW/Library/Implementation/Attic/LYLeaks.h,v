head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.50;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.42;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.42;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYLeaks.h,v 1.14 2012/02/10 00:15:56 tom Exp $
 */
#ifndef __LYLEAKS_H
/*
 *	Avoid include redundancy
 *	Include only if finding memory leaks.
 */
#define __LYLEAKS_H

/*
 *  Copyright (c) 1994, University of Kansas, All Rights Reserved
 *
 *  Include File:	LYLeaks.h
 *  Purpose:		Header to convert requests for allocation to Lynx
 *			custom functions to track memory leaks.
 *  Remarks/Portability/Dependencies/Restrictions:
 *	For the stdlib.h allocation functions to be overriden by the
 *		Lynx memory tracking functions all modules allocating,
 *		freeing, or resizing memory must have LY_FIND_LEAKS
 *		defined before including this file.
 *	This header file should be included in every source file which
 *		does any memory manipulation through use of the
 *		stdlib.h memory functions.
 *	For proper reporting of memory leaks, the function LYLeaks
 *		should be registered for execution by atexit as the
 *		very first executable statement in main.
 *	This code is slow and should not be used except in debugging
 *		circumstances (don't define LY_FIND_LEAKS).
 *	If you are using LY_FIND_LEAKS and don't want the LYLeak*
 *		memory functions to be used in a certain file,
 *		define NO_MEMORY_TRACKING before including this file.
 *	The only safe way to call the LYLeak* functions is to use
 *		the below macros because they depend on the static
 *		string created by __FILE__ to not be dynamic in
 *		nature (don't free it and assume will exist at all
 *		times during execution).
 *	If you are using LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED and
 *		want only normal memory tracking (not extended for
 *		HTSprintf/HTSprintf0) to be used in a certain file,
 *		define NO_EXTENDED_MEMORY_TRACKING and don't define
 *		NO_MEMORY_TRACKING before including this file.
 *  Revision History:
 *	05-26-94	created for Lynx 2-3-1, Garrett Arch Blythe
 *	10-30-97	modified to handle StrAllocCopy() and
 *			StrAllocCat(). - KW & FM
 *	1999-10-17	modified to handle HTSprintf0 and HTSprintf(),
 *			and to provide mark_malloced, if
 *			LY_FIND_LEAKS_EXTENDED is defined. - kw
 *	2003-01-22	add sequence-id for counting mallocs/frees -TD
 *	2004-04-27	ANSIfy'd -TD
 *	2012-02-09	add bstring interfaces -TD
 */

/* Undefine this to get no improved HTSprintf0/HTSprintf tracking: */
#define LY_FIND_LEAKS_EXTENDED

/*
 *  Required includes
 */

#ifndef HTUTILS_H
#include <HTUtils.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
/*
 *	Constant defines
 */
#define MAX_CONTENT_LENGTH 50
#ifdef VMS
#define LEAKAGE_SINK "sys$login:Lynx.leaks"
#else
#define LEAKAGE_SINK "Lynx.leaks"
#endif				/* VMS */
/*
 * Data structures
 */ typedef struct SourceLocation_tag {
	/*
	 * The file name and line number of where an event took place.
	 */
	const char *cp_FileName;
	short ssi_LineNumber;
    } SourceLocation;

    typedef struct AllocationList_tag {
	/*
	 * A singly linked list.
	 */
	struct AllocationList_tag *ALp_Next;

	/*
	 * Count the number of mallocs.
	 */
	long st_Sequence;

	/*
	 * The memory pointer allocated.  If set to NULL, then an invalid request
	 * was made.  The invalid pointer also.
	 */
	void *vp_Alloced;
	void *vp_BadRequest;

	/*
	 * The size in bytes of the allocated memory.
	 */
	size_t st_Bytes;

	/*
	 * The source location of specific event (calloc, malloc, free).  realloc
	 * kept separate since will track last realloc on pointer.
	 */
	SourceLocation SL_memory;
	SourceLocation SL_realloc;
    } AllocationList;

/*
 *  Global variable declarations
 */

/*
 *  Macros
 */
#if defined(LY_FIND_LEAKS) && !defined(NO_MEMORY_TRACKING)
/*
 * Only use these macros if we are to track memory allocations.  The reason for
 * using a macro instead of a define is that we want to track where the initial
 * allocation took place or where the last reallocation took place.  Track
 * where the allocation took place by the __FILE__ and __LINE__ defines which
 * are automatic to the compiler.
 */
#ifdef malloc
#undef malloc
#endif				/* malloc */
#define malloc(st_bytes) LYLeakMalloc(st_bytes, __FILE__, __LINE__)

#ifdef calloc
#undef calloc
#endif				/* calloc */
#define calloc(st_number, st_bytes) LYLeakCalloc(st_number, st_bytes, \
	__FILE__, __LINE__)

#ifdef realloc
#undef realloc
#endif				/* realloc */
#define realloc(vp_alloced, st_newbytes) LYLeakRealloc(vp_alloced, \
	st_newbytes, __FILE__, __LINE__)

#ifdef free
#undef free
#endif				/* free */
#define free(vp_alloced) LYLeakFree(vp_alloced, __FILE__, __LINE__)

/*
 * Added the following two defines to track Lynx's frequent use of those
 * macros.  - KW 1997-10-12
 */
#ifdef StrAllocCopy
#undef StrAllocCopy
#endif				/* StrAllocCopy */
#define StrAllocCopy(dest, src) LYLeakSACopy(&(dest), src, __FILE__, __LINE__)

#ifdef StrAllocCat
#undef StrAllocCat
#endif				/* StrAllocCat */
#define StrAllocCat(dest, src)  LYLeakSACat(&(dest), src, __FILE__, __LINE__)

#ifdef BStrAlloc
#undef BStrAlloc
#endif
#define BStrAlloc(d,n)   LYLeakSABAlloc( &(d), n, __FILE__, __LINE__)

#ifdef BStrCopy
#undef BStrCopy
#endif
#define BStrCopy(d,s)  LYLeakSABCopy( &(d), BStrData(s), BStrLen(s), __FILE__, __LINE__)

#ifdef BStrCopy0
#undef BStrCopy0
#endif
#define BStrCopy0(d,s)  LYLeakSABCopy0( &(d), s, __FILE__, __LINE__)

#ifdef BStrCat
#undef BStrCat
#endif
#define BStrCat(d,s)  LYLeakSABCat( &(d), BStrData(s), BStrLen(s), __FILE__, __LINE__)

#ifdef BStrCat0
#undef BStrCat0
#endif
#define BStrCat0(d,s)  LYLeakSABCat0( &(d), s, __FILE__, __LINE__)

#define mark_malloced(a,size) LYLeak_mark_malloced(a,size, __FILE__, __LINE__)

#if defined(LY_FIND_LEAKS_EXTENDED) && !defined(NO_EXTENDED_MEMORY_TRACKING)

#ifdef HTSprintf0
#undef HTSprintf0
#endif				/* HTSprintf0 */
#define HTSprintf0 (Get_htsprintf0_fn(__FILE__,__LINE__))

#ifdef HTSprintf
#undef HTSprintf
#endif				/* HTSprintf */
#define HTSprintf (Get_htsprintf_fn(__FILE__,__LINE__))

#endif				/* LY_FIND_LEAKS_EXTENDED and not NO_EXTENDED_MEMORY_TRACKING */

#else				/* LY_FIND_LEAKS && !NO_MEMORY_TRACKING */

#define mark_malloced(a,size)	/* no-op */
#define LYLeakSequence() (-1)

#endif				/* LY_FIND_LEAKS && !NO_MEMORY_TRACKING */

#if defined(LY_FIND_LEAKS)
#define PUBLIC_IF_FIND_LEAKS	/* nothing */
#else
#define PUBLIC_IF_FIND_LEAKS static
#endif

/*
 * Function declarations.
 * See the appropriate source file for usage.
 */
#ifndef LYLeakSequence
    extern long LYLeakSequence(void);
#endif
    extern void LYLeaks(void);

#ifdef LY_FIND_LEAKS_EXTENDED
    extern AllocationList *LYLeak_mark_malloced(void *vp_alloced,
						size_t st_bytes,
						const char *cp_File,
						const short ssi_Line);
#endif				/* LY_FIND_LEAKS_EXTENDED */
    extern void *LYLeakMalloc(size_t st_bytes, const char *cp_File,
			      const short ssi_Line);
    extern void *LYLeakCalloc(size_t st_number, size_t st_bytes, const char *cp_File,
			      const short ssi_Line);
    extern void *LYLeakRealloc(void *vp_alloced,
			       size_t st_newbytes,
			       const char *cp_File,
			       const short ssi_Line);
    extern void LYLeakFree(void *vp_alloced,
			   const char *cp_File,
			   const short ssi_Line);
    extern char *LYLeakSACopy(char **dest,
			      const char *src,
			      const char *cp_File,
			      const short ssi_Line);
    extern char *LYLeakSACat(char **dest,
			     const char *src,
			     const char *cp_File,
			     const short ssi_Line);
    extern void LYLeakSABAlloc(bstring **dest,
			       int len,
			       const char *cp_File,
			       const short ssi_Line);
    extern void LYLeakSABCopy(bstring **dest,
			      const char *src,
			      int len,
			      const char *cp_File,
			      const short ssi_Line);
    extern void LYLeakSABCopy0(bstring **dest,
			       const char *src,
			       const char *cp_File,
			       const short ssi_Line);
    extern void LYLeakSABCat(bstring **dest,
			     const char *src,
			     int len,
			     const char *cp_File,
			     const short ssi_Line);
    extern void LYLeakSABCat0(bstring **dest,
			      const char *src,
			      const char *cp_File,
			      const short ssi_Line);
    extern void LYLeakSABFree(bstring **ptr,
			      const char *cp_File,
			      const short ssi_Line);

#ifdef LY_FIND_LEAKS_EXTENDED
/*
 * Trick to get tracking of var arg functions without relying on var arg
 * preprocessor macros:
 */
    typedef char *HTSprintflike(char **, const char *,...);
    extern HTSprintflike *Get_htsprintf_fn(const char *cp_File,
					   const short ssi_Line);
    extern HTSprintflike *Get_htsprintf0_fn(const char *cp_File,
					    const short ssi_Line);
#endif				/* LY_FIND_LEAKS_EXTENDED */

#ifdef __cplusplus
}
#endif
#endif				/* __LYLEAKS_H */
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d50 3
d170 25
d258 25
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d9 39
a47 39
**  Copyright (c) 1994, University of Kansas, All Rights Reserved
**
**  Include File:	LYLeaks.h
**  Purpose:		Header to convert requests for allocation to Lynx
**			custom functions to track memory leaks.
**  Remarks/Portability/Dependencies/Restrictions:
**	For the stdlib.h allocation functions to be overriden by the
**		Lynx memory tracking functions all modules allocating,
**		freeing, or resizing memory must have LY_FIND_LEAKS
**		defined before including this file.
**	This header file should be included in every source file which
**		does any memory manipulation through use of the
**		stdlib.h memory functions.
**	For proper reporting of memory leaks, the function LYLeaks
**		should be registered for execution by atexit as the
**		very first executable statement in main.
**	This code is slow and should not be used except in debugging
**		circumstances (don't define LY_FIND_LEAKS).
**	If you are using LY_FIND_LEAKS and don't want the LYLeak*
**		memory functions to be used in a certain file,
**		define NO_MEMORY_TRACKING before including this file.
**	The only safe way to call the LYLeak* functions is to use
**		the below macros because they depend on the static
**		string created by __FILE__ to not be dynamic in
**		nature (don't free it and assume will exist at all
**		times during execution).
**	If you are using LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED and
**		want only normal memory tracking (not extended for
**		HTSprintf/HTSprintf0) to be used in a certain file,
**		define NO_EXTENDED_MEMORY_TRACKING and don't define
**		NO_MEMORY_TRACKING before including this file.
**  Revision History:
**	05-26-94	created for Lynx 2-3-1, Garrett Arch Blythe
**	10-30-97	modified to handle StrAllocCopy() and
**			StrAllocCat(). - KW & FM
**	1999-10-17	modified to handle HTSprintf0 and HTSprintf(),
**			and to provide mark_malloced, if
**			LY_FIND_LEAKS_EXTENDED is defined. - kw
*/
d53 2
a54 2
**  Required includes
*/
d60 3
d64 2
a65 2
**	Constant defines
*/
d71 1
a71 2
#endif /* VMS */

d73 2
a74 3
**	Data structures
*/
typedef struct SourceLocation_tag	{
d76 1
a76 1
	 *	The file name and line number of where an event took place.
d78 1
a78 1
	CONST char *cp_FileName;
d80 1
a80 2
}
SourceLocation;
d82 1
a82 1
typedef struct AllocationList_tag	{
d84 1
a84 1
	 *	A singly linked list.
d89 1
a89 1
	 *	Count the number of mallocs.
d94 2
a95 3
	 *	The memory pointer allocated.
	 *	If set to NULL, then an invalid request was made.
	 *	The invalid pointer also.
d101 1
a101 1
	 *	The size in bytes of the allocated memory.
d106 2
a107 2
	 *	The source location of specific event (calloc, malloc, free).
	 *	realloc kept separate since will track last realloc on pointer.
d111 1
a111 1
} AllocationList;
d114 2
a115 2
**  Global variable declarations
*/
d118 2
a119 2
**  Macros
*/
d122 6
a127 7
**	Only use these macros if we are to track memory allocations.
**	The reason for using a macro instead of a define is that we want
**		to track where the initial allocation took place or where
**		the last reallocation took place.
**	Track where the allocation took place by the __FILE__ and __LINE__
**		defines which are automatic to the compiler.
*/
d130 1
a130 1
#endif /* malloc */
d135 1
a135 1
#endif /* calloc */
d141 1
a141 1
#endif /* realloc */
d147 1
a147 1
#endif /* free */
d151 3
a153 3
**  Added the following two defines to track Lynx's frequent use
**  of those macros. - KW 1997-10-12
*/
d156 1
a156 1
#endif /* StrAllocCopy */
d161 1
a161 1
#endif /* StrAllocCat */
d170 1
a170 1
#endif /* HTSprintf0 */
d175 1
a175 1
#endif /* HTSprintf */
d178 1
a178 1
#endif /* LY_FIND_LEAKS_EXTENDED and not NO_EXTENDED_MEMORY_TRACKING */
d180 1
a180 1
#else /* LY_FIND_LEAKS && !NO_MEMORY_TRACKING */
d185 1
a185 1
#endif /* LY_FIND_LEAKS && !NO_MEMORY_TRACKING */
d188 1
a188 1
#define PUBLIC_IF_FIND_LEAKS PUBLIC
d190 1
a190 1
#define PUBLIC_IF_FIND_LEAKS PRIVATE
d194 5
a198 5
**	Function declarations
**	See the appropriate source file for usage.
*/
#ifndef LYLeakSequence 
extern long LYLeakSequence NOPARAMS;
d200 2
a201 1
extern void LYLeaks NOPARAMS;
d203 24
a226 34
extern AllocationList *LYLeak_mark_malloced PARAMS((
	void *		vp_alloced,
	size_t		st_bytes,
	CONST char *	cp_File,
	CONST short	ssi_Line));
#endif /* LY_FIND_LEAKS_EXTENDED */
extern void *LYLeakMalloc PARAMS((
	size_t		st_bytes,
	CONST char *	cp_File,
	CONST short	ssi_Line));
extern void *LYLeakCalloc PARAMS((
	size_t		st_number,
	size_t		st_bytes,
	CONST char *	cp_File,
	CONST short	ssi_Line));
extern void *LYLeakRealloc PARAMS((
	void *		vp_alloced,
	size_t		st_newbytes,
	CONST char *	cp_File,
	CONST short	ssi_Line));
extern void LYLeakFree PARAMS((
	void *		vp_alloced,
	CONST char *	cp_File,
	CONST short	ssi_Line));
extern char * LYLeakSACopy PARAMS((
	char **		dest,
	CONST char *	src,
	CONST char *	cp_File,
	CONST short	ssi_Line));
extern char * LYLeakSACat PARAMS((
	char **		dest,
	CONST char *	src,
	CONST char *	cp_File,
	CONST short	ssi_Line));
d229 10
a238 2
/* Trick to get tracking of var arg functions without relying
   on var arg preprocessor macros: */
d240 4
a243 10
typedef char * HTSprintflike PARAMS((char **, CONST char *, ...));
extern HTSprintflike *Get_htsprintf_fn PARAMS((
			   CONST char *	cp_File,
			   CONST short	ssi_Line));
extern HTSprintflike *Get_htsprintf0_fn PARAMS((
			   CONST char *	cp_File,
			   CONST short	ssi_Line));
#endif /* LY_FIND_LEAKS_EXTENDED */

#endif /* __LYLEAKS_H */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d89 5
d160 1
d169 1
d174 1
d179 1
d185 1
d194 1
d199 3
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d35 5
d44 3
d49 3
d160 17
d179 5
d189 7
d224 13
@


1.1
log
@Initial revision
@
text
@d44 4
a47 2
#include <stdlib.h>
#include "HTUtils.h"
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
