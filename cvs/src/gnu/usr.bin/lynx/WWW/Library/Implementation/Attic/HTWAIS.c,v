head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.50;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTWAIS.c,v 1.38 2013/11/28 11:16:03 tom Exp $
 *
 *	WorldWideWeb - Wide Area Informaion Server Access	HTWAIS.c
 *	==================================================
 *
 *	This module allows a WWW server or client to read data from a
 *	remote	WAIS
 *  server, and provide that data to a WWW client in hypertext form.
 *  Source files, once retrieved, are stored and used to provide
 *  information about the index when that is acessed.
 *
 *  Authors
 *	BK	Brewster Kahle, Thinking Machines, <Brewster@@think.com>
 *	TBL	Tim Berners-Lee, CERN <timbl@@info.cern.ch>
 *	FM	Foteos Macrides, WFEB <macrides@@sci.wfeb.edu>
 *
 *  History
 *	   Sep 91	TBL adapted shell-ui.c (BK) with HTRetrieve.c from WWW.
 *	   Feb 91	TBL Generated HTML cleaned up a bit (quotes, escaping)
 *			    Refers to lists of sources.
 *	   Mar 93	TBL Lib 2.0 compatible module made.
 *	   May 94	FM  Added DIRECT_WAIS support for VMS.
 *
 *  Bugs
 *	Uses C stream i/o to read and write sockets, which won't work
 *	on VMS TCP systems.
 *
 *	Should cache connections.
 *
 *	ANSI C only as written
 *
 *  Bugs fixed
 *	NT Nathan Torkington (Nathan.Torkington@@vuw.ac.nz)
 *
 *  WAIS comments:
 *
 *	1.	Separate directories for different system's .o would help
 *	2.	Document ids are rather long!
 *
 * W WW Address mapping convention:
 *
 *	/servername/database/type/length/document-id
 *
 *	/servername/database?word+word+word
 */
/* WIDE AREA INFORMATION SERVER SOFTWARE:
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   Brewster@@think.com
*/

#include <HTUtils.h>
#include <HTParse.h>
#include <HTAccess.h>		/* We implement a protocol */
#include <HTML.h>		/* The object we will generate */
#include <HTWSRC.h>
#include <HTTCP.h>
#include <HTCJK.h>
#include <HTAlert.h>
#include <LYStrings.h>

#undef lines			/* term.h conflict with wais.h */
#undef alloca			/* alloca.h conflict with wais.h */

/*			From WAIS
 *			---------
 */
#ifdef VMS
#include <HTVMS_WaisUI.h>
#include <HTVMS_WaisProt.h>
#elif defined(HAVE_WAIS_H)
#include <wais.h>
#else
#include <ui.h>
#endif /* VMS */

#define MAX_MESSAGE_LEN 100000
#define CHARS_PER_PAGE 10000	/* number of chars retrieved in each request */

#define WAISSEARCH_DATE "Fri Jul 19 1991"

/*			FROM WWW
 *			--------
 */
#include <LYUtils.h>
#include <LYLeaks.h>

#define DIRECTORY "/cnidr.org:210/directory-of-servers"
/* #define DIRECTORY "/quake.think.com:210/directory-of-servers" */

#define BIG 1024		/* identifier size limit  @@@@@@@@@@ */

#define BUFFER_SIZE 4096	/* Arbitrary size for efficiency */

#define HEX_ESCAPE '%'

static BOOL as_gate;		/* Client is using us as gateway */

static char line[2048];		/* For building strings to display */

				/* Must be able to take id */

#define PUTC(c) (*target->isa->put_character)(target, c)
#define PUTS(s) (*target->isa->put_string)(target, s)
#define START(e) (*target->isa->start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*target->isa->end_element)(target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*target->isa->end_element)(target, e, 0)
#define FREE_TARGET (*target->isa->_free)(target)

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

/* ------------------------------------------------------------------------ */
/* ---------------- Local copy of connect_to_server calls ----------------- */
/* ------------------------------------------------------------------------ */
/* Returns 1 on success, 0 on fail, -1 on interrupt. */
static int fd_mosaic_connect_to_server(char *host_name,
				       long port,
				       long *fd)
{
    char *dummy = NULL;
    int status;
    int result;

    HTSprintf0(&dummy, "%s//%s:%ld/", STR_WAIS_URL, host_name, port);

    status = HTDoConnect(dummy, "WAIS", 210, (int *) fd);
    if (status == HT_INTERRUPTED) {
	result = -1;
    } else if (status < 0) {
	result = 0;
    } else {
	result = 1;
    }
    FREE(dummy);
    return result;
}

/* Returns 1 on success, 0 on fail, -1 on interrupt. */
#ifdef VMS
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    long *fdp)
#else
static int mosaic_connect_to_server(char *host_name,
				    long port,
				    FILE **fp)
#endif				/* VMS */
{
#ifndef VMS
    FILE *file;
#endif /* VMS */
    long fd;
    int rv;

    rv = fd_mosaic_connect_to_server(host_name, port, &fd);
    if (rv == 0) {
	HTAlert(gettext("Could not connect to WAIS server."));
	return 0;
    } else if (rv == -1) {
	HTAlert(CONNECTION_INTERRUPTED);
	return -1;
    }
#ifndef VMS
    if ((file = fdopen(fd, "r+")) == NULL) {
	HTAlert(gettext("Could not open WAIS connection for reading."));
	return 0;
    }

    *fp = file;
#else
    *fdp = fd;
#endif /* VMS */
    return 1;
}
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*								showDiags
*/
/* modified from Jonny G's version in ui/question.c */
static void showDiags(HTStream *target, diagnosticRecord ** d)
{
    long i;

    for (i = 0; d[i] != NULL; i++) {
	if (d[i]->ADDINFO != NULL) {
	    PUTS(gettext("Diagnostic code is "));
	    PUTS(d[i]->DIAG);
	    PUTC(' ');
	    PUTS(d[i]->ADDINFO);
	    PUTC('\n');
	}
    }
}

/*	Matrix of allowed characters in filenames
 *	-----------------------------------------
 */

static BOOL acceptable[256];
static BOOL acceptable_inited = NO;

static void init_acceptable(void)
{
    unsigned int i;
    char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
	acceptable[i] = NO;
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
    acceptable_inited = YES;
}

/*	Transform file identifier into WWW address
 *	------------------------------------------
 *
 *
 * On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char *WWW_from_archie(char *file)
{
    char *end;
    char *result;
    char *colon;

    for (end = file; *end > ' '; end++) ;	/* assumes ASCII encoding */
    result = (char *) malloc(10 + (end - file));
    if (!result)
	return result;		/* Malloc error */
    strcpy(result, "file://");
    StrNCat(result, file, end - file);
    colon = StrChr(result + 7, ':');	/* Expect colon after host */
    if (colon) {
	for (; colon[0]; colon[0] = colon[1], colon++) ;	/* move down */
    }
    return result;
}				/* WWW_from_archie */

/*	Transform document identifier into URL
 *	--------------------------------------
 *
 *  Bugs: A static buffer of finite size is used!
 *	The format of the docid MUST be good!
 *
 *  On exit,
 *	returns		nil if error
 *			pointer to malloced string (must be freed) if ok
 */
static char hex[17] = "0123456789ABCDEF";

static char *WWW_from_WAIS(any *docid)
{
    static char buf[BIG];
    char *q = buf;
    char *p = (docid->bytes);
    char *result = NULL;
    int i, l;

    if (TRACE) {
	char *p2;

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p2 = docid->bytes; p2 < docid->bytes + docid->size; p2++) {
	    if ((*p2 >= ' ') && (*p2 <= '~'))	/* Assume ASCII! */
		fprintf(tfp, "%c", *p2);
	    else
		fprintf(tfp, "<%x>", (unsigned) *p2);
	}
	fprintf(tfp, "\n");
    }
    for (p = docid->bytes;
	 (p < docid->bytes + docid->size) && (q < &buf[BIG]);) {
	CTRACE((tfp, "    Record type %d, length %d\n", p[0], p[1]));
	if (*p > 10) {
	    CTRACE((tfp, "Eh?  DOCID record type of %d!\n", *p));
	    return 0;
	} {			/* Bug fix -- allow any byte value 15 Apr 93 */
	    unsigned int i2 = (unsigned) *p++;

	    if (i2 > 99) {
		*q++ = (i2 / 100) + '0';
		i2 = i2 % 100;
	    }
	    if (i2 > 9) {
		*q++ = (i2 / 10) + '0';
		i2 = i2 % 10;
	    }
	    *q++ = i2 + '0';	/* Record type */
	}
	*q++ = '=';		/* Separate */
	l = *p++;		/* Length */
	for (i = 0; i < l; i++, p++) {
	    if (!acceptable[UCH(*p)]) {
		*q++ = HEX_ESCAPE;	/* Means hex coming */
		*q++ = hex[(*p) >> 4];
		*q++ = hex[(*p) & 15];
	    } else
		*q++ = *p;
	}
	*q++ = ';';		/* Terminate field */
    }
    *q++ = 0;			/* Terminate string */
    CTRACE((tfp, "WWW form of id: %s\n", buf));
    StrAllocCopy(result, buf);
    return result;
}				/* WWW_from_WAIS */

/*	Transform URL into WAIS document identifier
 *	-------------------------------------------
 *
 *  On entry,
 *	docname		points to valid name produced originally by
 *			WWW_from_WAIS
 *  On exit,
 *	docid->size	is valid
 *	docid->bytes	is malloced and must later be freed.
 */
static any *WAIS_from_WWW(any *docid, char *docname)
{
    char *z;			/* Output pointer */
    char *sor;			/* Start of record - points to size field. */
    char *p;			/* Input pointer */
    char *q;			/* Poisition of "=" */
    char *s;			/* Position of semicolon */
    int n;			/* size */

    CTRACE((tfp, "WWW id (to become WAIS id): %s\n", docname));
    for (n = 0, p = docname; *p; p++) {		/* Count sizes of strings */
	n++;
	if (*p == ';')
	    n--;		/* Not converted */
	else if (*p == HEX_ESCAPE)
	    n = n - 2;		/* Save two bytes */
	docid->size = n;
    }

    if (!(docid->bytes = (char *) malloc(docid->size)))		/* result record */
	outofmem(__FILE__, "WAIS_from_WWW");
    z = docid->bytes;

    for (p = docname; *p;) {	/* Convert of strings */
	/* Record type */

	*z = 0;			/* Initialize record type */
	while (*p >= '0' && *p <= '9') {
	    *z = *z * 10 + (*p++ - '0');	/* Decode decimal record type */
	}
	z++;
	if (*p != '=')
	    return 0;
	q = p;

	s = StrChr(q, ';');	/* (Check only) */
	if (!s)
	    return 0;		/* Bad! No ';'; */
	sor = z;		/* Remember where the size field was */
	z++;			/* Skip record size for now     */
	for (p = q + 1; *p != ';';) {
	    if (*p == HEX_ESCAPE) {
		char c;
		unsigned int b;

		p++;
		c = *p++;
		b = from_hex(c);
		c = *p++;
		if (!c)
		    break;	/* Odd number of chars! */
		*z++ = (b << 4) + from_hex(c);
	    } else {
		*z++ = *p++;	/* Record */
	    }
	}
	*sor = (z - sor - 1);	/* Fill in size -- not counting size itself */
	p++;			/* After semicolon: start of next record */
    }

    if (TRACE) {
	char *p2;

	fprintf(tfp, "WAIS id (%d bytes) is ", (int) docid->size);
	for (p2 = docid->bytes; p2 < docid->bytes + docid->size; p2++) {
	    if ((*p2 >= ' ') && (*p2 <= '~'))	/* Assume ASCII! */
		fprintf(tfp, "%c", *p2);
	    else
		fprintf(tfp, "<%x>", (unsigned) *p2);
	}
	fprintf(tfp, "\n");
    }
    return docid;		/* Ok */

}				/* WAIS_from_WWW */

/*	Send a plain text record to the client		output_text_record()
 *	--------------------------------------
 */
static void output_text_record(HTStream *target,
			       WAISDocumentText *record,
			       boolean binary)
{
    unsigned long count;

    /* printf(" Text\n");
       print_any("     DocumentID:  ", record->DocumentID);
       printf("     VersionNumber:  %d\n", record->VersionNumber);
     */

    if (binary) {
	(*target->isa->put_block) (target,
				   record->DocumentText->bytes,
				   record->DocumentText->size);
	return;
    }

    for (count = 0; count < record->DocumentText->size; count++) {
	long ch = (unsigned char) record->DocumentText->bytes[count];

	if (ch == 27) {		/* What is this in for?  Tim */
	    /* then we have an escape code */
	    /* if the next letter is '(' or ')', then ignore two letters */
	    if ('(' == record->DocumentText->bytes[count + 1] ||
		')' == record->DocumentText->bytes[count + 1])
		count += 1;	/* it is a term marker */
	    else
		count += 4;	/* it is a paragraph marker */
	} else if (ch == '\n' || ch == '\r') {
	    PUTC('\n');
	} else if (IS_CJK_TTY || ch == '\t' || isprint(ch)) {
	    PUTC(ch);
	}
    }
}				/* output text record */

/*	Format A Search response for the client		display_search_response
 *	---------------------------------------
 */
/* modified from tracy shen's version in wutil.c
 * displays either a text record or a set of headlines.
 */
static void display_search_response(HTStructured * target, SearchResponseAPDU *response,
				    char *the_database,
				    char *keywords)
{
    WAISSearchResponse *info;
    long i, k;

    BOOL archie = strstr(the_database, "archie") != 0;	/* Special handling */

    CTRACE((tfp, "HTWAIS: Displaying search response\n"));
    PUTS(gettext("Index "));
    START(HTML_EM);
    PUTS(the_database);
    END(HTML_EM);
    sprintf(line, gettext(" contains the following %d item%s relevant to \""),
	    (int) (response->NumberOfRecordsReturned),
	    response->NumberOfRecordsReturned == 1 ? "" : "s");
    PUTS(line);
    START(HTML_EM);
    PUTS(keywords);
    END(HTML_EM);
    PUTS("\".\n");
    PUTS(gettext("The first figure after each entry is its relative score, "));
    PUTS(gettext("the second is the number of lines in the item."));
    START(HTML_BR);
    START(HTML_BR);
    PUTC('\n');
    START(HTML_OL);

    if (response->DatabaseDiagnosticRecords != 0) {
	info = (WAISSearchResponse *) response->DatabaseDiagnosticRecords;
	i = 0;

	if (info->Diagnostics != NULL)
	    showDiags((HTStream *) target, info->Diagnostics);

	if (info->DocHeaders != 0) {
	    for (k = 0; info->DocHeaders[k] != 0; k++) {
		WAISDocumentHeader *head = info->DocHeaders[k];
		char *headline = trim_junk(head->Headline);
		any *docid = head->DocumentID;
		char *docname;	/* printable version of docid */

		i++;
		/*
		 * Make a printable string out of the document id.
		 */
		CTRACE((tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
			i,
			(long int) (info->DocHeaders[k]->Score),
			(long int) (info->DocHeaders[k]->Lines),
			headline));

		START(HTML_LI);

		if (archie) {
		    char *www_name = WWW_from_archie(headline);

		    if (www_name) {
			HTStartAnchor(target, NULL, www_name);
			PUTS(headline);
			END(HTML_A);
			FREE(www_name);
		    } else {
			PUTS(headline);
			PUTS(gettext(" (bad file name)"));
		    }
		} else {	/* Not archie */
		    docname = WWW_from_WAIS(docid);
		    if (docname) {
			if ((head->Types) &&
			    (!strcmp(head->Types[0], "URL"))) {
			    HTStartAnchor(target, NULL, headline);
			} else {
			    char *dbname = HTEscape(the_database, URL_XPALPHAS);
			    char *w3_address = NULL;

			    HTSprintf0(&w3_address,
				       "/%s/%s/%d/%s",
				       dbname,
				       head->Types ? head->Types[0] : "TEXT",
				       (int) (head->DocumentLength),
				       docname);
			    HTStartAnchor(target, NULL, w3_address);
			    FREE(w3_address);
			    FREE(dbname);
			}
			PUTS(headline);
			END(HTML_A);
			FREE(docname);
		    } else {
			PUTS(gettext("(bad doc id)"));
		    }
		}

		sprintf(line, "%5ld  %5ld  ",
			head->Score,
			head->Lines);
		PUTS(line);
		MAYBE_END(HTML_LI);
	    }			/* next document header */
	}
	/* if there were any document headers */
	if (info->ShortHeaders != 0) {
	    k = 0;
	    while (info->ShortHeaders[k] != 0) {
		i++;
		PUTS(gettext("(Short Header record, can't display)"));
	    }
	}
	if (info->LongHeaders != 0) {
	    k = 0;
	    while (info->LongHeaders[k] != 0) {
		i++;
		PUTS(gettext("\nLong Header record, can't display\n"));
	    }
	}
	if (info->Text != 0) {
	    k = 0;
	    while (info->Text[k] != 0) {
		i++;
		PUTS(gettext("\nText record\n"));
		output_text_record((HTStream *) target,
				   info->Text[k++], false);
	    }
	}
	if (info->Headlines != 0) {
	    k = 0;
	    while (info->Headlines[k] != 0) {
		i++;
		PUTS(gettext("\nHeadline record, can't display\n"));
		/* dsply_headline_record( info->Headlines[k++]); */
	    }
	}
	if (info->Codes != 0) {
	    k = 0;
	    while (info->Codes[k] != 0) {
		i++;
		PUTS(gettext("\nCode record, can't display\n"));
		/* dsply_code_record( info->Codes[k++]); */
	    }
	}
    }				/* Loop: display user info */
    END(HTML_OL);
    PUTC('\n');
}

/*		Load by name					HTLoadWAIS
 *		============
 *
 *  This renders any object or search as required.
 */
int HTLoadWAIS(const char *arg,
	       HTParentAnchor *anAnchor,
	       HTFormat format_out,
	       HTStream *sink)
#define MAX_KEYWORDS_LENGTH 1000
#define MAX_SERVER_LENGTH 1000
#define MAX_DATABASE_LENGTH 1000
#define MAX_SERVICE_LENGTH 1000
#define MAXDOCS 200

{
    char *key;			/* pointer to keywords in URL */
    char *request_message = NULL;	/* arbitrary message limit */
    char *response_message = NULL;	/* arbitrary message limit */
    long request_buffer_length;	/* how of the request is left */
    SearchResponseAPDU *retrieval_response = 0;
    char keywords[MAX_KEYWORDS_LENGTH + 1];
    char *the_server_name;
    char *wais_database = NULL;	/* name of current database */
    char *www_database;		/* Same name escaped */
    char *service;
    char *doctype;
    char *doclength;
    long document_length = 0;
    char *docname = 0;

#ifdef VMS
    long connection = 0;

#else
    FILE *connection = NULL;
#endif /* VMS */
    char *names;		/* Copy of arg to be hacked up */
    BOOL ok = NO;
    int return_status = HT_LOADED;
    int rv;

    if (!acceptable_inited)
	init_acceptable();

    /* Decipher and check syntax of WWW address:
     * ----------------------------------------
     *
     * First we remove the "wais:" if it was specified.  920110
     */
    names = HTParse(arg, "", PARSE_HOST | PARSE_PATH | PARSE_PUNCTUATION);
    key = StrChr(names, '?');

    if (key) {
	char *p;

	*key++ = 0;		/* Split off keywords */
	for (p = key; *p; p++)
	    if (*p == '+')
		*p = ' ';
	HTUnEscape(key);
    }
    if (names[0] == '/') {
	the_server_name = names + 1;
	if ((as_gate = (*the_server_name == '/')) != 0)
	    the_server_name++;	/* Accept one or two */
	www_database = StrChr(the_server_name, '/');
	if (www_database) {
	    *www_database++ = 0;	/* Separate database name */
	    doctype = StrChr(www_database, '/');
	    if (key)
		ok = YES;	/* Don't need doc details */
	    else if (doctype) {	/* If not search parse doc details */
		*doctype++ = 0;	/* Separate rest of doc address */
		doclength = StrChr(doctype, '/');
		if (doclength) {
		    *doclength++ = 0;
		    document_length = atol(doclength);
		    if (document_length) {
			docname = StrChr(doclength, '/');
			if (docname) {
			    *docname++ = 0;
			    ok = YES;	/* To avoid a goto! */
			}	/* if docname */
		    }		/* if document_length valid */
		}		/* if doclength */
	    } else {		/* no doctype?  Assume index required */
		if (!key)
		    key = "";
		ok = YES;
	    }			/* if doctype */
	}			/* if database */
    }

    if (!ok)
	return HTLoadError(sink, 500, gettext("Syntax error in WAIS URL"));

    CTRACE((tfp, "HTWAIS: Parsed OK\n"));

    service = StrChr(names, ':');
    if (service)
	*service++ = 0;
    else
	service = "210";

    if (the_server_name[0] == 0) {
#ifdef VMS
	connection = 0;
#else
	connection = NULL;
#endif /* VMS */

    } else if (!(key && !*key)) {
	int status;

	CTRACE((tfp, "===WAIS=== calling mosaic_connect_to_server\n"));
	status = mosaic_connect_to_server(the_server_name,
					  atoi(service),
					  &connection);
	if (status == 0) {
	    CTRACE((tfp, "===WAIS=== connection failed\n"));
	    FREE(names);
	    return HT_NOT_LOADED;
	} else if (status == -1) {
	    CTRACE((tfp, "===WAIS=== connection interrupted\n"));
	    FREE(names);
	    return HT_NOT_LOADED;
	}
    }

    StrAllocCopy(wais_database, www_database);
    HTUnEscape(wais_database);

    /*
     * This below fixed size stuff is terrible.
     */
#ifdef VMS
    if ((request_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
	  outofmem(__FILE__, "HTLoadWAIS");
    if ((response_message = typecallocn(char, MAX_MESSAGE_LEN)) == 0)
	  outofmem(__FILE__, "HTLoadWAIS");

#else
    request_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
    response_message = (char *) s_malloc((size_t) MAX_MESSAGE_LEN * sizeof(char));
#endif /* VMS */

    /*
     * If keyword search is performed but there are no keywords, the user has
     * followed a link to the index itself.  It would be appropriate at this
     * point to send him the .SRC file - how?
     */
    if (key && !*key) {		/* I N D E X */
#ifdef CACHE_FILE_PREFIX
	char *filename = NULL;
	FILE *fp;
#endif
	HTStructured *target = HTML_new(anAnchor, format_out, sink);

	START(HTML_HEAD);
	PUTC('\n');
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY, NULL);
	PUTC('\n');

	{
	    START(HTML_TITLE);
	    PUTS(wais_database);
	    PUTS(gettext(" (WAIS Index)"));
	    END(HTML_TITLE);
	    PUTC('\n');
	    END(HTML_HEAD);
	    PUTC('\n');

	    START(HTML_H1);
	    PUTS(gettext("WAIS Index: "));
	    START(HTML_EM);
	    PUTS(wais_database);
	    END(HTML_EM);
	    END(HTML_H1);
	    PUTC('\n');
	    PUTS(gettext("This is a link for searching the "));
	    START(HTML_EM);
	    PUTS(wais_database);
	    END(HTML_EM);
	    PUTS(gettext(" WAIS Index.\n"));

	}
	/*
	 * If we have seen a source file for this database, use that.
	 */
#ifdef CACHE_FILE_PREFIX
	HTSprintf0(&filename, "%sWSRC-%s:%s:%.100s.txt",
		   CACHE_FILE_PREFIX,
		   the_server_name, service, www_database);

	fp = fopen(filename, "r");	/* Have we found this already? */
	CTRACE((tfp, "HTWAIS: Description of server %s %s.\n",
		filename,
		fp ? "exists already" : "does NOT exist!"));

	if (fp) {
	    char c;

	    START(HTML_PRE);	/* Preformatted description */
	    PUTC('\n');
	    while ((c = getc(fp)) != EOF)
		PUTC(c);	/* Transfer file */
	    END(HTML_PRE);
	    fclose(fp);
	}
	FREE(filename);
#endif
	START(HTML_P);
	PUTS(gettext("\nEnter the 's'earch command and then specify search words.\n"));

	FREE_TARGET;
    } else if (key) {		/* S E A R C H */
	char *p;
	HTStructured *target;

	LYStrNCpy(keywords, key, MAX_KEYWORDS_LENGTH);
	while ((p = StrChr(keywords, '+')) != 0)
	    *p = ' ';

	/*
	 * Send advance title to get something fast to the other end.
	 */
	target = HTML_new(anAnchor, format_out, sink);

	START(HTML_HEAD);
	PUTC('\n');
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY, NULL);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(keywords);
	PUTS(gettext(" (in "));
	PUTS(wais_database);
	PUTC(')');
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);
	PUTC('\n');

	START(HTML_H1);
	PUTS(gettext("WAIS Search of \""));
	START(HTML_EM);
	PUTS(keywords);
	END(HTML_EM);
	PUTS(gettext("\" in: "));
	START(HTML_EM);
	PUTS(wais_database);
	END(HTML_EM);
	END(HTML_H1);
	PUTC('\n');

	request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
	CTRACE((tfp, "HTWAIS: Search for `%s' in `%s'\n",
		keywords, wais_database));
	if (NULL ==
	    generate_search_apdu(request_message + HEADER_LENGTH,
				 &request_buffer_length,
				 keywords, wais_database, NULL, MAXDOCS)) {
#ifdef VMS
	    HTAlert(gettext("HTWAIS: Request too large."));
	    return_status = HT_NOT_LOADED;
	    FREE_TARGET;
	    goto CleanUp;
#else
	    panic("request too large");
#endif /* VMS */
	}

	HTProgress(gettext("Searching WAIS database..."));
	rv = interpret_message(request_message,
			       MAX_MESSAGE_LEN - request_buffer_length,
			       response_message,
			       MAX_MESSAGE_LEN,
			       connection,
			       false	/* true verbose */
	    );

	if (rv == HT_INTERRUPTED) {
	    HTAlert(gettext("Search interrupted."));
	    return_status = HT_INTERRUPTED;
	    FREE_TARGET;
	    goto CleanUp;
	} else if (!rv) {
#ifdef VMS
	    HTAlert(HTWAIS_MESSAGE_TOO_BIG);
	    return_status = HT_NOT_LOADED;
	    FREE_TARGET;
	    goto CleanUp;
#else
	    panic("returned message too large");
#endif /* VMS */
	} else {		/* returned message ok */
	    SearchResponseAPDU *query_response = 0;

	    readSearchResponseAPDU(&query_response,
				   response_message + HEADER_LENGTH);
	    display_search_response(target,
				    query_response, wais_database, keywords);
	    if (query_response->DatabaseDiagnosticRecords)
		freeWAISSearchResponse(query_response->DatabaseDiagnosticRecords);
	    freeSearchResponseAPDU(query_response);
	}			/* returned message not too large */
	FREE_TARGET;
    } else {			/* D O C U M E N T    F E T C H */
	HTFormat format_in;
	boolean binary;		/* how to transfer stuff coming over */
	HTStream *target;
	long count;
	any doc_chunk;
	any *docid = &doc_chunk;

	CTRACE((tfp,
		"HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		NonNull(docname), doctype, document_length));

	format_in =
	    !strcmp(doctype, "WSRC") ? HTAtom_for("application/x-wais-source") :
	    !strcmp(doctype, "TEXT") ? HTAtom_for("text/plain") :
	    !strcmp(doctype, "HTML") ? HTAtom_for("text/html") :
	    !strcmp(doctype, "GIF") ? HTAtom_for("image/gif") :
	    HTAtom_for("application/octet-stream");
	binary =
	    0 != strcmp(doctype, "WSRC") &&
	    0 != strcmp(doctype, "TEXT") &&
	    0 != strcmp(doctype, "HTML");

	target = HTStreamStack(format_in, format_out, sink, anAnchor);
	if (!target)
	    return HTLoadError(sink, 500,
			       gettext("Can't convert format of WAIS document"));
	/*
	 * Decode hex or litteral format for document ID.
	 */
	WAIS_from_WWW(docid, docname);

	/*
	 * Loop over slices of the document.
	 */
	for (count = 0;
	     count * CHARS_PER_PAGE < document_length;
	     count++) {
#ifdef VMS
	    char *type = NULL;

	    StrAllocCopy(type, doctype);
#else
	    char *type = s_strdup(doctype);	/* Gets freed I guess */
#endif /* VMS */
	    request_buffer_length = MAX_MESSAGE_LEN;	/* Amount left */
	    CTRACE((tfp, "HTWAIS: Slice number %ld\n", count));

	    if (HTCheckForInterrupt()) {
		HTAlert(TRANSFER_INTERRUPTED);
		(*target->isa->_abort) (target, NULL);
#ifdef VMS
		FREE(type);
#endif /* VMS */
		return_status = HT_NOT_LOADED;
		goto CleanUp;
	    }

	    if (0 ==
		generate_retrieval_apdu(request_message + HEADER_LENGTH,
					&request_buffer_length,
					docid,
					CT_byte,
					count * CHARS_PER_PAGE,
					(((count + 1) * CHARS_PER_PAGE <= document_length)
					 ? (count + 1) * CHARS_PER_PAGE
					 : document_length),
					type,
					wais_database)) {
#ifdef VMS
		HTAlert(gettext("HTWAIS: Request too long."));
		return_status = HT_NOT_LOADED;
		FREE_TARGET;
		FREE(type);
		FREE(docid->bytes);
		goto CleanUp;
#else
		panic("request too long");
#endif /* VMS */
	    }

	    /*
	     * Actually do the transaction given by request_message.
	     */
	    HTProgress(gettext("Fetching WAIS document..."));
	    rv = interpret_message(request_message,
				   MAX_MESSAGE_LEN - request_buffer_length,
				   response_message,
				   MAX_MESSAGE_LEN,
				   connection,
				   false	/* true verbose */
		);
	    if (rv == HT_INTERRUPTED) {
		HTAlert(TRANSFER_INTERRUPTED);
		return_status = HT_INTERRUPTED;
		FREE_TARGET;
		FREE(type);
		FREE(docid->bytes);
		goto CleanUp;
	    } else if (!rv) {
#ifdef VMS
		HTAlert(HTWAIS_MESSAGE_TOO_BIG);
		return_status = HT_NOT_LOADED;
		FREE_TARGET;
		FREE(type);
		FREE(docid->bytes);
		goto CleanUp;
#else
		panic("Returned message too large");
#endif /* VMS */
	    }

	    /*
	     * Parse the result which came back into memory.
	     */
	    readSearchResponseAPDU(&retrieval_response,
				   response_message + HEADER_LENGTH);

	    if (NULL ==
		((WAISSearchResponse *)
		 retrieval_response->DatabaseDiagnosticRecords)->Text) {
		/* display_search_response(target, retrieval_response,
		   wais_database, keywords); */
		PUTS(gettext("No text was returned!\n"));
		/* panic("No text was returned"); */
	    } else {
		output_text_record(target,
				   ((WAISSearchResponse *)
				    retrieval_response->DatabaseDiagnosticRecords)->Text[0],
				   binary);
	    }			/* If text existed */

#ifdef VMS
	    FREE(type);
#endif /* VMS */
	}			/* Loop over slices */

	FREE_TARGET;
	FREE(docid->bytes);

	freeWAISSearchResponse(retrieval_response->DatabaseDiagnosticRecords);
	freeSearchResponseAPDU(retrieval_response);

    }				/* If document rather than search */

  CleanUp:
    /*
     * (This postponed until later, after a timeout:)
     */
#ifdef VMS
    if (connection)
	NETCLOSE((int) connection);
#else
    if (connection)
	fclose(connection);
#endif /* VMS */
    FREE(wais_database);
#ifdef VMS
    FREE(request_message);
    FREE(response_message);
#else
    s_free(request_message);
    s_free(response_message);
#endif /* VMS */
    FREE(names);
    return (return_status);
}

#ifdef GLOBALDEF_IS_MACRO
#define _HTWAIS_C_1_INIT { "wais", HTLoadWAIS, NULL }
GLOBALDEF(HTProtocol, HTWAIS, _HTWAIS_C_1_INIT);
#else
GLOBALDEF HTProtocol HTWAIS =
{"wais", HTLoadWAIS, NULL};
#endif /* GLOBALDEF_IS_MACRO */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTWAIS.c,v 1.31 2008/09/06 15:47:08 tom Exp $
d62 4
d73 2
a117 5
struct _HTStream {
    const HTStreamClass *isa;
    /* ... */
};

d130 1
a130 1
    HTSprintf0(&dummy, "%s//%s:%d/", STR_WAIS_URL, host_name, port);
d241 2
a242 2
    strncat(result, file, end - file);
    colon = strchr(result + 7, ':');	/* Expect colon after host */
d270 1
a270 1
	char *p;
d273 3
a275 3
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
		fprintf(tfp, "%c", *p);
d277 1
a277 1
		fprintf(tfp, "<%x>", (unsigned) *p);
d288 1
a288 1
	    unsigned int i = (unsigned) *p++;
d290 3
a292 3
	    if (i > 99) {
		*q++ = (i / 100) + '0';
		i = i % 100;
d294 3
a296 3
	    if (i > 9) {
		*q++ = (i / 10) + '0';
		i = i % 10;
d298 1
a298 1
	    *q++ = i + '0';	/* Record type */
d303 1
a303 1
	    if (!acceptable[*p]) {
d363 1
a363 5
/*	  *z++ = *p++ - '0';
	q = strchr(p , '=');
	if (!q) return 0;
*/
	s = strchr(q, ';');	/* (Check only) */
d389 1
a389 1
	char *p;
d392 3
a394 3
	for (p = docid->bytes; p < docid->bytes + docid->size; p++) {
	    if ((*p >= ' ') && (*p <= '~'))	/* Assume ASCII! */
		fprintf(tfp, "%c", *p);
d396 1
a396 1
		fprintf(tfp, "<%x>", (unsigned) *p);
a408 1
			       boolean quote_string_quotes,
d411 1
a411 1
    long count;
d451 1
a451 1
				    char *database,
d457 1
a457 1
    BOOL archie = strstr(database, "archie") != 0;	/* Special handling */
d462 1
a462 1
    PUTS(database);
d524 1
a524 1
			    char *dbname = HTEscape(database, URL_XPALPHAS);
d573 1
a573 1
				   info->Text[k++], false, false);
d619 1
a619 1
    char *server_name;
d625 2
a626 2
    long document_length;
    char *docname;
d648 1
a648 1
    key = strchr(names, '?');
d660 4
a663 4
	server_name = names + 1;
	if ((as_gate = (*server_name == '/')) != 0)
	    server_name++;	/* Accept one or two */
	www_database = strchr(server_name, '/');
d666 1
a666 1
	    doctype = strchr(www_database, '/');
d671 1
a671 1
		doclength = strchr(doctype, '/');
d676 1
a676 1
			docname = strchr(doclength, '/');
d696 1
a696 1
    service = strchr(names, ':');
d702 1
a702 1
    if (server_name[0] == 0) {
d713 1
a713 1
	status = mosaic_connect_to_server(server_name,
d790 1
a790 1
		   server_name, service, www_database);
d817 2
a818 2
	strncpy(keywords, key, MAX_KEYWORDS_LENGTH);
	while ((p = strchr(keywords, '+')) != 0)
d914 1
a914 1
		docname, doctype, document_length));
d1033 1
a1033 1
				   false, binary);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*	WorldWideWeb - Wide Area Informaion Server Access	HTWAIS.c
d442 1
a442 1
	} else if (HTCJK != NOCJK || ch == '\t' || isprint(ch)) {
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 42
a43 42
**	==================================================
**
**	This module allows a WWW server or client to read data from a
**	remote	WAIS
**  server, and provide that data to a WWW client in hypertext form.
**  Source files, once retrieved, are stored and used to provide
**  information about the index when that is acessed.
**
**  Authors
**	BK	Brewster Kahle, Thinking Machines, <Brewster@@think.com>
**	TBL	Tim Berners-Lee, CERN <timbl@@info.cern.ch>
**	FM	Foteos Macrides, WFEB <macrides@@sci.wfeb.edu>
**
**  History
**	   Sep 91	TBL adapted shell-ui.c (BK) with HTRetrieve.c from WWW.
**	   Feb 91	TBL Generated HTML cleaned up a bit (quotes, escaping)
**			    Refers to lists of sources.
**	   Mar 93	TBL Lib 2.0 compatible module made.
**	   May 94	FM  Added DIRECT_WAIS support for VMS.
**
**  Bugs
**	Uses C stream i/o to read and write sockets, which won't work
**	on VMS TCP systems.
**
**	Should cache connections.
**
**	ANSI C only as written
**
**  Bugs fixed
**	NT Nathan Torkington (Nathan.Torkington@@vuw.ac.nz)
**
**  WAIS comments:
**
**	1.	Separate directories for different system's .o would help
**	2.	Document ids are rather long!
**
** W WW Address mapping convention:
**
**	/servername/database/type/length/document-id
**
**	/servername/database?word+word+word
*/
d61 2
a62 2
**			---------
*/
d71 1
a71 1
#define CHARS_PER_PAGE 10000 /* number of chars retrieved in each request */
d76 2
a77 2
**			--------
*/
d84 1
a84 1
#define BIG 1024	/* identifier size limit  @@@@@@@@@@ */
d90 3
a92 1
PRIVATE BOOL	as_gate;	/* Client is using us as gateway */
a93 1
PRIVATE char	line[2048];	/* For building strings to display */
d105 2
a106 2
	CONST HTStructuredClass *	isa;
	/* ... */
d110 2
a111 2
	CONST HTStreamClass *	isa;
	/* ... */
d118 3
a120 4
PRIVATE int fd_mosaic_connect_to_server ARGS3(
	char *,		host_name,
	long,		port,
	long *,		fd)
d128 1
a128 1
    status = HTDoConnect (dummy, "WAIS", 210, (int *)fd);
d142 3
a144 4
PRIVATE int mosaic_connect_to_server ARGS3(
	char *,		host_name,
	long,		port,
	long *,		fdp)
d146 4
a149 5
PRIVATE int mosaic_connect_to_server ARGS3(
	char *,		host_name,
	long,		port,
	FILE **,	fp)
#endif /* VMS */
d152 1
a152 1
    FILE* file;
d157 1
a157 1
    rv = fd_mosaic_connect_to_server (host_name, port, &fd);
d159 1
a159 1
	HTAlert (gettext("Could not connect to WAIS server."));
d162 1
a162 1
	HTAlert (CONNECTION_INTERRUPTED);
a164 1

d166 2
a167 2
    if ((file = fdopen(fd,"r+")) == NULL) {
	HTAlert (gettext("Could not open WAIS connection for reading."));
d183 1
a183 3
PRIVATE void showDiags ARGS2(
	HTStream *,		target,
	diagnosticRecord **,	d)
d199 2
a200 2
**	-----------------------------------------
*/
d202 2
a203 2
PRIVATE BOOL acceptable[256];
PRIVATE BOOL acceptable_inited = NO;
d205 1
a205 1
PRIVATE void init_acceptable NOARGS
d208 7
a214 4
    char * good =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
    for(i=0; i<256; i++) acceptable[i] = NO;
    for(;*good; good++) acceptable[(unsigned int)*good] = YES;
d219 8
a226 9
**	------------------------------------------
**
**
** On exit,
**	returns		nil if error
**			pointer to malloced string (must be freed) if ok
*/
PRIVATE char * WWW_from_archie ARGS1(
	char *,		file)
d228 8
a235 6
    char * end;
    char * result;
    char * colon;
    for(end=file; *end > ' '; end++);	/* assumes ASCII encoding*/
    result = (char *)malloc(10 + (end-file));
    if (!result) return result;		/* Malloc error */
d237 2
a238 2
    strncat(result, file, end-file);
    colon = strchr(result+7, ':');	/* Expect colon after host */
d240 1
a240 1
	for(; colon[0]; colon[0]=colon[1], colon++);	/* move down */
d243 1
a243 1
} /* WWW_from_archie */
d246 10
a255 10
**	--------------------------------------
**
**  Bugs: A static buffer of finite size is used!
**	The format of the docid MUST be good!
**
**  On exit,
**	returns		nil if error
**			pointer to malloced string (must be freed) if ok
*/
PRIVATE char hex [17] = "0123456789ABCDEF";
d257 1
a257 2
PRIVATE char * WWW_from_WAIS ARGS1(
	any *,		docid)
d260 3
a262 3
    char * q = buf;
    char * p = (docid->bytes);
    char * result = NULL;
d267 4
a270 3
	fprintf(tfp, "WAIS id (%d bytes) is ", (int)docid->size);
	for (p = docid->bytes; p < docid->bytes+docid->size; p++) {
	    if ((*p >= ' ') && (*p<= '~')) /* Assume ASCII! */
d273 1
a273 1
		fprintf(tfp, "<%x>", (unsigned)*p);
d278 1
a278 1
	 (p < docid->bytes+docid->size) && (q < &buf[BIG]);) {
d283 1
a283 2
	}
	{	/* Bug fix -- allow any byte value 15 Apr 93 */
d287 1
a287 1
		*q++ = (i/100) + '0';
d291 1
a291 1
		*q++ = (i/10) + '0';
d298 1
a298 1
	for (i = 0; i < l; i++, p++){
d303 2
a304 2
	    }
	    else *q++ = *p;
d306 1
a306 1
	*q++= ';';		/* Terminate field */
d312 1
a312 1
} /* WWW_from_WAIS */
d315 10
a324 12
**	-------------------------------------------
**
**  On entry,
**	docname		points to valid name produced originally by
**			WWW_from_WAIS
**  On exit,
**	docid->size	is valid
**	docid->bytes	is malloced and must later be freed.
*/
PRIVATE any * WAIS_from_WWW ARGS2(
	any *,		docid,
	char *,		docname)
d326 6
a331 6
    char *z;	/* Output pointer */
    char *sor;	/* Start of record - points to size field. */
    char *p;	/* Input pointer */
    char *q;	/* Poisition of "=" */
    char *s;	/* Position of semicolon */
    int n;	/* size */
d334 1
a334 1
    for (n = 0, p = docname; *p; p++) { /* Count sizes of strings */
d339 1
a339 1
	    n = n-2;		/* Save two bytes */
d343 2
a344 2
    if (!(docid->bytes = (char *) malloc(docid->size))) /* result record */
	    outofmem(__FILE__, "WAIS_from_WWW");
d347 2
a348 2
    for (p = docname; *p; ) {	/* Convert of strings */
				/* Record type */
d352 1
a352 1
	    *z = *z*10 + (*p++ - '0');	/* Decode decimal record type */
d367 3
a369 3
	z++;			/* Skip record size for now	*/
	for (p = q+1; *p != ';';) {
	   if (*p == HEX_ESCAPE) {
d372 1
d375 1
a375 1
		b =   from_hex(c);
d379 1
a379 1
		*z++ = (b<<4) + from_hex(c);
d384 1
a384 1
	*sor = (z-sor-1);	/* Fill in size -- not counting size itself */
d390 4
a393 3
	fprintf(tfp, "WAIS id (%d bytes) is ", (int)docid->size);
	for (p = docid->bytes; p < docid->bytes+docid->size; p++) {
	    if ((*p >= ' ') && (*p<= '~')) /* Assume ASCII! */
d396 1
a396 1
		fprintf(tfp, "<%x>", (unsigned)*p);
d402 1
a402 1
} /* WAIS_from_WWW */
d405 6
a410 7
**	--------------------------------------
*/
PRIVATE void output_text_record ARGS4(
    HTStream *,			target,
    WAISDocumentText *,		record,
    boolean,			quote_string_quotes,
    boolean,			binary)
d412 5
a416 4
  long count;
  /* printf(" Text\n");
     print_any("     DocumentID:  ", record->DocumentID);
     printf("	  VersionNumber:  %d\n", record->VersionNumber);
d419 11
a429 10
  if (binary) {
    (*target->isa->put_block)(target,
			      record->DocumentText->bytes,
			      record->DocumentText->size);
    return;
  }

  for (count = 0; count < record->DocumentText->size; count++){
    long ch = (unsigned char)record->DocumentText->bytes[count];
    if (ch == 27) {	/* What is this in for?  Tim */
d434 4
a437 3
	    count += 1;		    /* it is a term marker */
	    else count += 4;		/* it is a paragraph marker */
    } else if (ch == '\n' || ch == '\r') {
d439 1
a439 1
    } else if (HTCJK != NOCJK || ch == '\t' || isprint(ch)){
d441 1
d443 1
a443 2
  }
} /* output text record */
d446 2
a447 2
**	---------------------------------------
*/
d451 3
a453 5
PRIVATE void display_search_response ARGS4(
    HTStructured *,		target,
    SearchResponseAPDU *,	response,
    char *,			database,
    char *,			keywords)
d455 1
a455 1
    WAISSearchResponse	*info;
d458 1
a458 1
    BOOL archie =  strstr(database, "archie")!=0;	/* Special handling */
d466 2
a467 2
	    (int)(response->NumberOfRecordsReturned),
	    response->NumberOfRecordsReturned ==1 ? "" : "s");
d481 2
a482 2
	info = (WAISSearchResponse *)response->DatabaseDiagnosticRecords;
	i =0;
d485 1
a485 1
	    showDiags((HTStream*)target, info->Diagnostics);
d488 5
a492 5
	    for (k = 0; info->DocHeaders[k] != 0; k++ ) {
		WAISDocumentHeader* head = info->DocHeaders[k];
		char * headline = trim_junk(head->Headline);
		any * docid = head->DocumentID;
		char * docname;		/* printable version of docid */
d496 2
a497 2
		**  Make a printable string out of the document id.
		*/
d499 4
a502 4
			    i,
			    (long int)(info->DocHeaders[k]->Score),
			    (long int)(info->DocHeaders[k]->Lines),
			    headline));
d507 2
a508 1
		    char * www_name = WWW_from_archie(headline);
d518 2
a519 2
		} else { /* Not archie */
		    docname =  WWW_from_WAIS(docid);
d522 1
a522 1
			   (!strcmp(head->Types[0], "URL"))) {
d524 4
a527 3
			} else{
			    char * dbname = HTEscape(database, URL_XPALPHAS);
			    char * w3_address = NULL;
d529 5
a533 5
					"/%s/%s/%d/%s",
					dbname,
					head->Types ? head->Types[0] : "TEXT",
					(int)(head->DocumentLength),
					docname);
d549 1
a549 1
		PUTS( line);
d551 3
a553 3
	    } /* next document header */
	} /* if there were any document headers */

d558 1
a558 1
		PUTS( gettext("(Short Header record, can't display)"));
d565 1
a565 1
		PUTS( gettext("\nLong Header record, can't display\n"));
d572 2
a573 2
		PUTS( gettext("\nText record\n"));
		output_text_record((HTStream*)target,
d581 1
a581 1
		PUTS( gettext("\nHeadline record, can't display\n"));
d589 1
a589 1
		PUTS( gettext("\nCode record, can't display\n"));
d593 1
a593 1
    }	/* Loop: display user info */
d599 8
a606 10
**		============
**
**  This renders any object or search as required.
*/
PUBLIC int HTLoadWAIS ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)

d614 5
a618 5
    char * key;			  /* pointer to keywords in URL */
    char* request_message = NULL; /* arbitrary message limit */
    char* response_message = NULL; /* arbitrary message limit */
    long request_buffer_length; /* how of the request is left */
    SearchResponseAPDU	*retrieval_response = 0;
d621 2
a622 2
    char *wais_database = NULL;		/* name of current database */
    char *www_database;			/* Same name escaped */
d628 1
d631 1
d635 1
a635 1
    char * names;		/* Copy of arg to be hacked up */
d643 5
a647 5
    /*	Decipher and check syntax of WWW address:
    **	----------------------------------------
    **
    **	First we remove the "wais:" if it was specified.  920110
    */
d652 6
a657 3
	char * p;
	*key++ = 0;	/* Split off keywords */
	for (p=key; *p; p++) if (*p == '+') *p = ' ';
d661 2
a662 2
	server_name = names+1;
	if ((as_gate =(*server_name == '/')) != 0)
d664 1
a664 1
	www_database = strchr(server_name,'/');
d666 1
a666 1
	    *www_database++ = 0;		/* Separate database name */
d668 4
a671 3
	    if (key) ok = YES;	/* Don't need doc details */
	    else if (doctype) { /* If not search parse doc details */
		*doctype++ = 0; /* Separate rest of doc address */
d681 4
a684 4
			} /* if docname */
		    } /* if document_length valid */
		} /* if doclength */
	    } else { /* no doctype?  Assume index required */
d688 2
a689 2
	    } /* if doctype */
	} /* if database */
d712 1
d728 1
a728 1
    StrAllocCopy(wais_database,www_database);
d732 2
a733 2
    **	This below fixed size stuff is terrible.
    */
d736 1
a736 1
	outofmem(__FILE__, "HTLoadWAIS");
d738 2
a739 1
	outofmem(__FILE__, "HTLoadWAIS");
d741 2
a742 2
    request_message = (char*)s_malloc((size_t)MAX_MESSAGE_LEN * sizeof(char));
    response_message = (char*)s_malloc((size_t)MAX_MESSAGE_LEN * sizeof(char));
d746 5
a750 5
    **	If keyword search is performed but there are no keywords,
    **	the user has followed a link to the index itself.  It would be
    **	appropriate at this point to send him the .SRC file - how?
    */
    if (key && !*key) {				/* I N D E X */
d752 2
a753 2
	char * filename = NULL;
	FILE * fp;
d755 1
a755 1
	HTStructured * target = HTML_new(anAnchor, format_out, sink);
d759 1
a759 1
	HTStartIsIndex(target, HTWAIS_SOLICIT_QUERY , NULL);
d786 2
a787 2
	**  If we have seen a source file for this database, use that.
	*/
d790 2
a791 2
		CACHE_FILE_PREFIX,
		server_name, service, www_database);
d795 2
a796 2
		    filename,
		    fp ? "exists already" : "does NOT exist!"));
d800 2
a801 1
	    START(HTML_PRE);		/* Preformatted description */
d803 2
a804 1
	    while((c=getc(fp))!=EOF) PUTC(c);	/* Transfer file */
d814 1
a814 1
    } else if (key) {					/* S E A R C H */
d816 1
a816 1
	HTStructured * target;
d823 2
a824 2
	**  Send advance title to get something fast to the other end.
	*/
d853 1
a853 1
	request_buffer_length = MAX_MESSAGE_LEN; /* Amount left */
d855 5
a859 5
		    keywords, wais_database));
	if(NULL ==
	generate_search_apdu(request_message + HEADER_LENGTH,
				&request_buffer_length,
				keywords, wais_database, NULL, MAXDOCS)) {
d861 1
a861 1
	    HTAlert (gettext("HTWAIS: Request too large."));
d871 7
a877 7
	rv = interpret_message (request_message,
				MAX_MESSAGE_LEN - request_buffer_length,
				response_message,
				MAX_MESSAGE_LEN,
				connection,
				false	/* true verbose */
			       );
d880 1
a880 1
	    HTAlert (gettext("Search interrupted."));
d886 1
a886 1
	    HTAlert (HTWAIS_MESSAGE_TOO_BIG);
d893 3
a895 2
	} else {	/* returned message ok */
	    SearchResponseAPDU	*query_response = 0;
d897 1
a897 1
		response_message + HEADER_LENGTH);
d899 1
a899 1
		query_response, wais_database, keywords);
d901 3
a903 4
		freeWAISSearchResponse(
			query_response->DatabaseDiagnosticRecords);
	    freeSearchResponseAPDU( query_response);
	}	/* returned message not too large */
d907 2
a908 2
	boolean binary;     /* how to transfer stuff coming over */
	HTStream * target;
d910 2
a911 2
	any   doc_chunk;
	any * docid = &doc_chunk;
d913 3
a915 2
	CTRACE((tfp, "HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		    docname, doctype, document_length));
d918 5
a922 5
	  !strcmp(doctype, "WSRC") ? HTAtom_for("application/x-wais-source") :
	  !strcmp(doctype, "TEXT") ? HTAtom_for("text/plain") :
	  !strcmp(doctype, "HTML") ? HTAtom_for("text/html") :
	  !strcmp(doctype, "GIF")  ? HTAtom_for("image/gif") :
				     HTAtom_for("application/octet-stream");
d924 3
a926 3
	  0 != strcmp(doctype, "WSRC") &&
	  0 != strcmp(doctype, "TEXT") &&
	  0 != strcmp(doctype, "HTML") ;
d933 2
a934 2
	**  Decode hex or litteral format for document ID.
	*/
d938 2
a939 2
	**  Loop over slices of the document.
	*/
d950 1
a950 1
	    request_buffer_length = MAX_MESSAGE_LEN; /* Amount left */
d954 2
a955 2
		HTAlert (TRANSFER_INTERRUPTED);
		(*target->isa->_abort)(target, NULL);
d969 3
a971 3
		    ((count + 1) * CHARS_PER_PAGE <= document_length ?
					(count + 1) * CHARS_PER_PAGE :
					document_length),
d975 1
a975 1
		HTAlert (gettext("HTWAIS: Request too long."));
d987 2
a988 2
	    **	Actually do the transaction given by request_message.
	    */
d995 2
a996 2
				   false /* true verbose */
				  );
d998 1
a998 1
		HTAlert (TRANSFER_INTERRUPTED);
d1006 1
a1006 1
		HTAlert (HTWAIS_MESSAGE_TOO_BIG);
d1018 2
a1019 2
	    **	Parse the result which came back into memory.
	    */
d1027 1
a1027 1
					wais_database, keywords); */
d1033 1
a1033 1
		    retrieval_response->DatabaseDiagnosticRecords)->Text[0],
d1035 1
a1035 1
	    } /* If text existed */
d1040 1
a1040 1
	}	/* Loop over slices */
d1045 2
a1046 2
	freeWAISSearchResponse( retrieval_response->DatabaseDiagnosticRecords);
	freeSearchResponseAPDU( retrieval_response);
d1048 1
a1048 1
    } /* If document rather than search */
d1050 1
a1050 1
CleanUp:
d1052 2
a1053 2
    **	(This postponed until later,  after a timeout:)
    */
d1056 1
a1056 1
	NETCLOSE((int)connection);
d1077 2
a1078 1
GLOBALDEF PUBLIC HTProtocol HTWAIS = { "wais", HTLoadWAIS, NULL };
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d126 1
a126 1
    HTSprintf0(&dummy, "wais://%s:%d/", host_name, port);
a638 2

    extern FILE * connect_to_server();
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d78 1
a89 5
extern HTCJKlang HTCJK;

extern int WWW_TraceFlag;	/* Control diagnostic output */
extern FILE * logfile;		/* Log file output */

d118 1
a118 1
	char *, 	host_name,
d120 1
a120 1
	long *, 	fd)
d122 1
a122 4
    /*
    **	New version.
    */
    char dummy[256];
d124 1
d126 1
a126 1
    sprintf (dummy, "wais://%s:%d/", host_name, port);
d130 5
a134 1
	return -1;
d136 2
a137 3
    if (status < 0)
	return 0;
    return 1;
d143 1
a143 1
	char *, 	host_name,
d145 1
a145 1
	long *, 	fdp)
d148 1
a148 1
	char *, 	host_name,
d225 1
a225 1
**	returns 	nil if error
d229 1
a229 1
	char *, 	file)
d236 1
a236 1
    if (!result) return result; 	/* Malloc error */
d253 1
a253 1
**	returns 	nil if error
d264 1
d266 1
d280 1
a280 1
	CTRACE(tfp, "    Record type %d, length %d\n", p[0], p[1]);
d282 1
a282 1
	    CTRACE(tfp, "Eh?  DOCID record type of %d!\n", *p);
d302 1
a302 1
		*q++ = HEX_ESCAPE;	/* Means hex commming */
d311 3
a313 8
    CTRACE(tfp, "WWW form of id: %s\n", buf);
    {
	char * result = (char *)malloc(strlen(buf)+1);
	if (!result)
	    outofmem(__FILE__, "WWW_from_WAIS");
	strcpy(result, buf);
	return result;
    }
d320 1
a320 1
**	docname 	points to valid name produced originally by
d328 1
a328 1
	char *, 	docname)
d337 1
a337 1
    CTRACE(tfp, "WWW id (to become WAIS id): %s\n", docname);
d354 1
a354 1
	*z = 0; 		/* Initialize record type */
d410 2
a411 2
    HTStream *, 		target,
    WAISDocumentText *, 	record,
d435 1
a435 1
	    count += 1; 	    /* it is a term marker */
d445 1
a445 1
/*	Format A Search response for the client 	display_search_response
d460 1
a460 1
    BOOL archie =  strstr(database, "archie")!=0;	/* Specical handling */
d462 1
a462 1
    CTRACE(tfp, "HTWAIS: Displaying search response\n");
d494 1
a494 1
		char * docname; 	/* printable version of docid */
d500 1
a500 1
		CTRACE(tfp, "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
d504 1
a504 1
			    headline);
d522 16
a537 12
			char * dbname = HTEscape(database, URL_XPALPHAS);
			sprintf(line,
				"/%s/%s/%d/%s", 	/* W3 address */
				dbname,
				head->Types ? head->Types[0] : "TEXT",
				(int)(head->DocumentLength),
				docname);
			HTStartAnchor(target, NULL,
				      ((head->Types) &&
				       (!strcmp(head->Types[0], "URL")))
						?
				       headline : line); /* NT, Sep 93 */
a539 1
			FREE(dbname);
d616 1
a616 3
    static CONST char * error_header =
"<h1>Access error</h1>\nThe following error occured in accesing a WAIS server:<P>\n";
    char * key; 		  /* pointer to keywords in URL */
d623 2
a624 2
    char *wais_database = NULL; 	/* name of current database */
    char *www_database; 		/* Same name escaped */
d648 1
a648 1
    **	First we remove the "wais:" if it was spcified.  920110
d661 1
a661 1
	if (as_gate =(*server_name == '/'))
d693 1
a693 1
    CTRACE(tfp, "HTWAIS: Parsed OK\n");
d710 1
a710 1
	CTRACE (tfp, "===WAIS=== calling mosaic_connect_to_server\n");
d715 1
a715 1
	    CTRACE (tfp, "===WAIS=== connection failed\n");
d719 1
a719 1
	    CTRACE (tfp, "===WAIS=== connection interrupted\n");
d732 1
a732 2
    if (!(request_message =
	  (char*)calloc((size_t)MAX_MESSAGE_LEN*sizeof(char),1)))
d734 1
a734 2
    if (!(response_message =
	  (char*)calloc((size_t)MAX_MESSAGE_LEN*sizeof(char),1)))
d746 1
a746 1
    if (key && !*key) { 			/* I N D E X */
d748 1
a748 1
	char filename[256];
d785 1
a785 1
	sprintf(filename, "%sWSRC-%s:%s:%.100s.txt",
d790 1
a790 1
	CTRACE(tfp, "HTWAIS: Description of server %s %s.\n",
d792 1
a792 1
		    fp ? "exists already" : "does NOT exist!");
d802 1
d813 2
a814 1
	while(p=strchr(keywords, '+')) *p = ' ';
d848 2
a849 2
	CTRACE(tfp, "HTWAIS: Search for `%s' in `%s'\n",
		    keywords, wais_database);
d907 2
a908 2
	CTRACE(tfp, "HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		    docname, doctype, document_length);
d944 1
a944 1
	    CTRACE(tfp, "HTWAIS: Slice number %ld\n", count);
@


1.1
log
@Initial revision
@
text
@d51 8
a58 9
#include "HTUtils.h"
#include "tcp.h"
#include "HTParse.h"
#include "HTAccess.h"		/* We implement a protocol */
#include "HTML.h"		/* The object we will generate */
#include "HTWSRC.h"
#include "HTTCP.h"
#include "HTCJK.h"
#include "HTAlert.h"
d64 2
a65 2
#include "HTVMS_WaisUI.h"
#include "HTVMS_WaisProt.h"
d78 1
a78 5
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

extern int HTCheckForInterrupt NOPARAMS;
d164 1
a164 1
	HTAlert ("Could not connect to WAIS server.");
d167 1
a167 1
	HTAlert ("Connection interrupted.");
d173 1
a173 1
	HTAlert ("Could not open WAIS connection for reading.");
d197 1
a197 1
	    PUTS("Diagnostic code is ");
d201 1
a201 1
	    PUTC('\n'); ;
d270 1
a270 1
	fprintf(stderr, "WAIS id (%d bytes) is ", (int)docid->size);
d273 1
a273 1
		fprintf(stderr, "%c", *p);
d275 1
a275 1
		fprintf(stderr, "<%x>", (unsigned)*p);
d277 1
a277 1
	fprintf(stderr, "\n");
d281 1
a281 2
	if (TRACE)
	    fprintf(stderr, "    Record type %d, length %d\n", p[0], p[1]);
d283 1
a283 2
	    if (TRACE)
		fprintf(stderr, "Eh? DOCID record type of %d!\n", *p);
d312 1
a312 2
    if (TRACE)
	fprintf(stderr, "WWW form of id: %s\n", buf);
d342 2
a343 2
    if (TRACE)
	fprintf(stderr, "WWW id (to become WAIS id): %s\n", docname);
d399 1
a399 1
	fprintf(stderr, "WAIS id (%d bytes) is ", (int)docid->size);
d402 1
a402 1
		fprintf(stderr, "%c", *p);
d404 1
a404 1
		fprintf(stderr, "<%x>", (unsigned)*p);
d406 1
a406 1
	fprintf(stderr, "\n");
d436 1
a436 1
    if (ch == 27) {	/* What is this in for? Tim */
d468 2
a469 3
    if (TRACE)
	fprintf(stderr, "HTWAIS: Displaying search response\n");
    PUTS("Index ");
d473 1
a473 1
    sprintf(line, " contains the following %d item%s relevant to \"",
d481 2
a482 2
    PUTS("The first figure after each entry is its relative score, ");
    PUTS("the second is the number of lines in the item.");
d485 1
a485 1
    PUTS("\n");
d506 1
a506 3
		if (TRACE)
		    fprintf(stderr,
			    "HTWAIS:  %2ld: Score: %4ld, lines:%4ld '%s'\n",
d523 1
a523 1
			PUTS(" (bad file name)");
d545 1
a545 1
			PUTS("(bad doc id)");
d561 1
a561 1
		PUTS( "(Short Header record, can't display)");
d568 1
a568 1
		PUTS( "\nLong Header record, can't display\n");
d575 1
a575 1
		PUTS( "\nText record\n");
d584 1
a584 1
		PUTS( "\nHeadline record, can't display\n");
d592 1
a592 1
		PUTS( "\nCode record, can't display\n");
d598 1
a598 1
    PUTC('\n'); ;
d696 1
a696 1
	return HTLoadError(sink, 500, "Syntax error in WAIS URL");
d698 1
a698 2
    if (TRACE)
	fprintf(stderr, "HTWAIS: Parsed OK\n");
d715 1
a715 2
	if (TRACE)
	fprintf (stderr, "===WAIS=== calling mosaic_connect_to_server\n");
d720 1
a720 2
	    if (TRACE)
		fprintf (stderr, "===WAIS=== connection failed\n");
d724 1
a724 2
	    if (TRACE)
		fprintf (stderr, "===WAIS=== connection interrupted\n");
d750 1
a750 1
    **	the user has followed a link to the index itself. It would be
d761 3
a763 3
	PUTS("\n");
	HTStartIsIndex(target, "Enter WAIS query: ", NULL);
	PUTS("\n");
d768 1
a768 1
	    PUTS(" (WAIS Index)");
d770 1
a770 1
	    PUTS("\n");
d772 1
a772 1
	    PUTS("\n");
d775 1
a775 1
	    PUTS("WAIS Index: ");
d780 2
a781 2
	    PUTS("\n");
	    PUTS("This is a link for searching the ");
d785 1
a785 1
	    PUTS(" WAIS Index.\n");
d797 3
a799 4
	if (TRACE) fprintf(stderr,
		"HTWAIS: Description of server %s %s.\n",
		filename,
		fp ? "exists already" : "does NOT exist!");
d804 1
a804 1
	    PUTS("\n");
d808 1
d811 1
a811 1
	PUTS("\nEnter the 's'earch command and then specify search words.\n");
d827 3
a829 3
	PUTS("\n");
	HTStartIsIndex(target, "Enter WAIS query: ", NULL);
	PUTS("\n");
d832 1
a832 1
	PUTS(" (in ");
d834 1
a834 1
	PUTS(")");
d836 1
a836 1
	PUTS("\n");
d838 1
a838 1
	PUTS("\n");
d841 1
a841 1
	PUTS("WAIS Search of \"");
d845 1
a845 1
	PUTS("\" in: ");
d850 1
a850 1
	PUTS("\n");
d853 2
a854 2
	if (TRACE) fprintf(stderr, "HTWAIS: Search for `%s' in `%s'\n",
		keywords, wais_database);
d860 1
a860 1
	    HTAlert ("HTWAIS: Request too large.");
d869 1
a869 1
	HTProgress("Searching WAIS database...");
d879 1
a879 1
	    HTAlert ("Search interrupted.");
d885 1
a885 1
	    HTAlert ("HTWAIS: Return message too large.");
d912 2
a913 3
	if (TRACE) fprintf(stderr,
		"HTWAIS: Retrieve document id `%s' type `%s' length %ld\n",
		docname, doctype, document_length);
d929 1
a929 1
			       "Can't convert format of WAIS document");
d949 1
a949 2
	    if (TRACE)
		fprintf(stderr, "HTWAIS: Slice number %ld\n", count);
d952 1
a952 1
		HTAlert ("Data transfer interrupted.");
d973 1
a973 1
		HTAlert ("HTWAIS: Request too long.");
d987 1
a987 1
	    HTProgress("Fetching WAIS document...");
d996 1
a996 1
		HTAlert ("Data transfer interrupted.");
d1004 1
a1004 1
		HTAlert ("HTWAIS: Return message too large.");
d1026 1
a1026 1
		PUTS("No text was returned!\n");
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
