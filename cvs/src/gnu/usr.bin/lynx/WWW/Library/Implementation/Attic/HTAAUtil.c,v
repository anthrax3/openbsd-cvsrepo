head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.21.18.53.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAAUtil.c,v 1.35 2013/05/03 20:32:37 tom Exp $
 *
 * MODULE							HTAAUtil.c
 *		COMMON PARTS OF ACCESS AUTHORIZATION MODULE
 *			FOR BOTH SERVER AND BROWSER
 *
 * IMPORTANT:
 *	Routines in this module use dynamic allocation, but free
 *	automatically all the memory reserved by them.
 *
 *	Therefore the caller never has to (and never should)
 *	free() any object returned by these functions.
 *
 *	Therefore also all the strings returned by this package
 *	are only valid until the next call to the same function
 *	is made.  This approach is selected, because of the nature
 *	of access authorization: no string returned by the package
 *	needs to be valid longer than until the next call.
 *
 *	This also makes it easy to plug the AA package in:
 *	you don't have to ponder whether to free() something
 *	here or is it done somewhere else (because it is always
 *	done somewhere else).
 *
 *	The strings that the package needs to store are copied
 *	so the original strings given as parameters to AA
 *	functions may be freed or modified with no side effects.
 *
 *	The AA package does not free() anything else than what
 *	it has itself allocated.
 *
 *	AA (Access Authorization) package means modules which
 *	names start with HTAA.
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	 8 Nov 93  MD	(VMS only) Added case insensitive comparison in HTAA_templateCaseMatch
 *
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>

#include <HTAAUtil.h>		/* Implemented here     */
#include <HTAssoc.h>		/* Assoc list           */
#include <HTTCP.h>
#include <HTTP.h>

#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

/* PUBLIC						HTAAScheme_enum()
 *		TRANSLATE SCHEME NAME INTO
 *		A SCHEME ENUMERATION
 *
 * ON ENTRY:
 *	name		is a string representing the scheme name.
 *
 * ON EXIT:
 *	returns		the enumerated constant for that scheme.
 */
HTAAScheme HTAAScheme_enum(const char *name)
{
    char *upcased = NULL;

    if (!name)
	return HTAA_UNKNOWN;

    StrAllocCopy(upcased, name);
    LYUpperCase(upcased);

    if (!StrNCmp(upcased, "NONE", 4)) {
	FREE(upcased);
	return HTAA_NONE;
    } else if (!StrNCmp(upcased, "BASIC", 5)) {
	FREE(upcased);
	return HTAA_BASIC;
    } else if (!StrNCmp(upcased, "PUBKEY", 6)) {
	FREE(upcased);
	return HTAA_PUBKEY;
    } else if (!StrNCmp(upcased, "KERBEROSV4", 10)) {
	FREE(upcased);
	return HTAA_KERBEROS_V4;
    } else if (!StrNCmp(upcased, "KERBEROSV5", 10)) {
	FREE(upcased);
	return HTAA_KERBEROS_V5;
    } else {
	FREE(upcased);
	return HTAA_UNKNOWN;
    }
}

/* PUBLIC						HTAAScheme_name()
 *			GET THE NAME OF A GIVEN SCHEME
 * ON ENTRY:
 *	scheme		is one of the scheme enum values:
 *			HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"None", "Basic", "Pubkey", ...
 */
const char *HTAAScheme_name(HTAAScheme scheme)
{
    switch (scheme) {
    case HTAA_NONE:
	return "None";
    case HTAA_BASIC:
	return "Basic";
    case HTAA_PUBKEY:
	return "Pubkey";
    case HTAA_KERBEROS_V4:
	return "KerberosV4";
    case HTAA_KERBEROS_V5:
	return "KerberosV5";
    case HTAA_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
    }
}

/* PUBLIC						    HTAAMethod_enum()
 *		TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
 * ON ENTRY:
 *	name		is the method name to translate.
 *
 * ON EXIT:
 *	returns		HTAAMethod enumerated value corresponding
 *			to the given name.
 */
HTAAMethod HTAAMethod_enum(const char *name)
{
    if (!name)
	return METHOD_UNKNOWN;

    if (0 == strcasecomp(name, "GET"))
	return METHOD_GET;
    else if (0 == strcasecomp(name, "PUT"))
	return METHOD_PUT;
    else
	return METHOD_UNKNOWN;
}

/* PUBLIC						HTAAMethod_name()
 *			GET THE NAME OF A GIVEN METHOD
 * ON ENTRY:
 *	method		is one of the method enum values:
 *			METHOD_GET, METHOD_PUT, ...
 *
 * ON EXIT:
 *	returns		the name of the scheme, i.e.
 *			"GET", "PUT", ...
 */
const char *HTAAMethod_name(HTAAMethod method)
{
    switch (method) {
    case METHOD_GET:
	return "GET";
    case METHOD_PUT:
	return "PUT";
    case METHOD_UNKNOWN:
	return "UNKNOWN";
    default:
	return "THIS-IS-A-BUG";
    }
}

/* PUBLIC						HTAAMethod_inList()
 *		IS A METHOD IN A LIST OF METHOD NAMES
 * ON ENTRY:
 *	method		is the method to look for.
 *	list		is a list of method names.
 *
 * ON EXIT:
 *	returns		YES, if method was found.
 *			NO, if not found.
 */
BOOL HTAAMethod_inList(HTAAMethod method, HTList *list)
{
    HTList *cur = list;
    char *item;

    while (NULL != (item = (char *) HTList_nextObject(cur))) {
	CTRACE((tfp, " %s", item));
	if (method == HTAAMethod_enum(item))
	    return YES;
    }

    return NO;			/* Not found */
}

/* PUBLIC						HTAA_templateMatch()
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE
 * NOTE:
 *	This is essentially the same code as in HTRules.c, but it
 *	cannot be used because it is embedded in between other code.
 *	(In fact, HTRules.c should use this routine, but then this
 *	 routine would have to be more sophisticated... why is life
 *	 sometimes so hard...)
 *
 * ON ENTRY:
 *	ctemplate	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateMatch(const char *ctemplate,
			const char *filename)
{
    const char *p = ctemplate;
    const char *q = filename;
    int m;

    for (; *p && *q && *p == *q; p++, q++)	/* Find first mismatch */
	;			/* do nothing else */

    if (!*p && !*q)
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
	m = (int) (strlen(q) - strlen(p));	/* Amount to match to wildcard */
	if (m < 0)
	    return NO;		/* No match, filename too short */
	else {			/* Skip the matched characters and compare */
	    if (strcmp(p, q + m))
		return NO;	/* Tail mismatch */
	    else
		return YES;	/* Tail match */
	}
	/* if wildcard */
    } else
	return NO;		/* Length or character mismatch */
}

/* PUBLIC						HTAA_templateCaseMatch()
 *		STRING COMPARISON FUNCTION FOR FILE NAMES
 *		   WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
 * NOTE:
 *	This is essentially the same code as in HTAA_templateMatch, but
 *	it compares case insensitive (for VMS). Reason for this routine
 *	is that HTAA_templateMatch gets called from several places, also
 *	there where a case sensitive match is needed, so one cannot just
 *	change the HTAA_templateMatch routine for VMS.
 *
 * ON ENTRY:
 *	template	is a template string to match the file name
 *			against, may contain a single wildcard
 *			character * which matches zero or more
 *			arbitrary characters.
 *	filename	is the filename (or pathname) to be matched
 *			against the template.
 *
 * ON EXIT:
 *	returns		YES, if filename matches the template.
 *			NO, otherwise.
 */
BOOL HTAA_templateCaseMatch(const char *ctemplate,
			    const char *filename)
{
    const char *p = ctemplate;
    const char *q = filename;
    int m;

    /* Find first mismatch */
    for (; *p && *q && TOUPPER(*p) == TOUPPER(*q); p++, q++) ;	/* do nothing else */

    if (!*p && !*q)
	return YES;		/* Equally long equal strings */
    else if ('*' == *p) {	/* Wildcard */
	p++;			/* Skip wildcard character */
	m = (int) (strlen(q) - strlen(p));	/* Amount to match to wildcard */
	if (m < 0)
	    return NO;		/* No match, filename too short */
	else {			/* Skip the matched characters and compare */
	    if (strcasecomp(p, q + m))
		return NO;	/* Tail mismatch */
	    else
		return YES;	/* Tail match */
	}
	/* if wildcard */
    } else
	return NO;		/* Length or character mismatch */
}

/* PUBLIC					HTAA_makeProtectionTemplate()
 *		CREATE A PROTECTION TEMPLATE FOR THE FILES
 *		IN THE SAME DIRECTORY AS THE GIVEN FILE
 *		(Used by server if there is no fancier way for
 *		it to tell the client, and by browser if server
 *		didn't send WWW-ProtectionTemplate: field)
 * ON ENTRY:
 *	docname is the document pathname (from URL).
 *
 * ON EXIT:
 *	returns a template matching docname, and other files
 *		files in that directory.
 *
 *		E.g.  /foo/bar/x.html  =>  /foo/bar/ *
 *						    ^
 *				Space only to prevent it from
 *				being a comment marker here,
 *				there really isn't any space.
 */
char *HTAA_makeProtectionTemplate(const char *docname)
{
    char *ctemplate = NULL;
    char *slash = NULL;

    if (docname) {
	StrAllocCopy(ctemplate, docname);
	slash = strrchr(ctemplate, '/');
	if (slash)
	    slash++;
	else
	    slash = ctemplate;
	*slash = '\0';
	StrAllocCat(ctemplate, "*");
    } else
	StrAllocCopy(ctemplate, "*");

    CTRACE((tfp, "make_template: made template `%s' for file `%s'\n",
	    ctemplate, docname));

    return ctemplate;
}

/*
 * Skip leading whitespace from *s forward
 */
#define SKIPWS(s) while (*s==' ' || *s=='\t') s++;

/*
 * Kill trailing whitespace starting from *(s-1) backwards
 */
#define KILLWS(s) {char *c=s-1; while (*c==' ' || *c=='\t') *(c--)='\0';}

/* PUBLIC						HTAA_parseArgList()
 *		PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
 * ON ENTRY:
 *	str	is a comma-separated list:
 *
 *			item, item, item
 *		where
 *			item ::= value
 *			       | name=value
 *			       | name="value"
 *
 *		Leading and trailing whitespace is ignored
 *		everywhere except inside quotes, so the following
 *		examples are equal:
 *
 *			name=value,foo=bar
 *			 name="value",foo="bar"
 *			  name = value ,  foo = bar
 *			   name = "value" ,  foo = "bar"
 *
 * ON EXIT:
 *	returns a list of name-value pairs (actually HTAssocList*).
 *		For items with no name, just value, the name is
 *		the number of order number of that item. E.g.
 *		"1" for the first, etc.
 */
HTAssocList *HTAA_parseArgList(char *str)
{
    HTAssocList *assoc_list = HTAssocList_new();
    char *cur = NULL;
    char *name = NULL;
    int n = 0;

    if (!str)
	return assoc_list;

    while (*str) {
	SKIPWS(str);		/* Skip leading whitespace */
	cur = str;
	n++;

	while (*cur && *cur != '=' && *cur != ',')
	    cur++;		/* Find end of name (or lonely value without a name) */
	KILLWS(cur);		/* Kill trailing whitespace */

	if (*cur == '=') {	/* Name followed by a value */
	    *(cur++) = '\0';	/* Terminate name */
	    StrAllocCopy(name, str);
	    SKIPWS(cur);	/* Skip WS leading the value */
	    str = cur;
	    if (*str == '"') {	/* Quoted value */
		str++;
		cur = str;
		while (*cur && *cur != '"')
		    cur++;
		if (*cur == '"')
		    *(cur++) = '\0';	/* Terminate value */
		/* else it is lacking terminating quote */
		SKIPWS(cur);	/* Skip WS leading comma */
		if (*cur == ',')
		    cur++;	/* Skip separating colon */
	    } else {		/* Unquoted value */
		while (*cur && *cur != ',')
		    cur++;
		KILLWS(cur);	/* Kill trailing whitespace */
		if (*cur == ',')
		    *(cur++) = '\0';
		/* else *cur already NULL */
	    }
	} else {		/* No name, just a value */
	    if (*cur == ',')
		*(cur++) = '\0';	/* Terminate value */
	    /* else last value on line (already terminated by NULL) */
	    HTSprintf0(&name, "%d", n);		/* Item order number for name */
	}
	HTAssocList_add(assoc_list, name, str);
	str = cur;
    }				/* while *str */

    FREE(name);
    return assoc_list;
}

/************** HEADER LINE READER -- DOES UNFOLDING *************************/

#define BUFFER_SIZE	1024

static size_t buffer_length;
static char *buffer = 0;
static char *start_pointer;
static char *end_pointer;
static int in_soc = -1;

#ifdef LY_FIND_LEAKS
static void FreeHTAAUtil(void)
{
    FREE(buffer);
}
#endif /* LY_FIND_LEAKS */

/* PUBLIC						HTAA_setupReader()
 *		SET UP HEADER LINE READER, i.e., give
 *		the already-read-but-not-yet-processed
 *		buffer of text to be read before more
 *		is read from the socket.
 * ON ENTRY:
 *	start_of_headers is a pointer to a buffer containing
 *			the beginning of the header lines
 *			(rest will be read from a socket).
 *	length		is the number of valid characters in
 *			'start_of_headers' buffer.
 *	soc		is the socket to use when start_of_headers
 *			buffer is used up.
 * ON EXIT:
 *	returns		nothing.
 *			Subsequent calls to HTAA_getUnfoldedLine()
 *			will use this buffer first and then
 *			proceed to read from socket.
 */
void HTAA_setupReader(char *start_of_headers,
		      size_t length,
		      int soc)
{
    if (!start_of_headers)
	length = 0;		/* initialize length (is this reached at all?) */
    if (buffer == NULL) {	/* first call? */
	buffer_length = length;
	if (buffer_length < BUFFER_SIZE)	/* would fall below BUFFER_SIZE? */
	    buffer_length = BUFFER_SIZE;
	buffer = (char *) malloc((size_t) (sizeof(char) * (buffer_length + 1)));
    } else if (length > buffer_length) {	/* need more space? */
	buffer_length = length;
	buffer = (char *) realloc((char *) buffer,
				  (size_t) (sizeof(char) * (buffer_length + 1)));
    }
    if (buffer == NULL)
	outofmem(__FILE__, "HTAA_setupReader");

    assert(buffer != NULL);

#ifdef LY_FIND_LEAKS
    atexit(FreeHTAAUtil);
#endif
    start_pointer = buffer;
    if (start_of_headers) {
	LYStrNCpy(buffer, start_of_headers, length);
	end_pointer = buffer + length;
    } else {
	*start_pointer = '\0';
	end_pointer = start_pointer;
    }
    in_soc = soc;
}

/* PUBLIC						HTAA_getUnfoldedLine()
 *		READ AN UNFOLDED HEADER LINE FROM SOCKET
 * ON ENTRY:
 *	HTAA_setupReader must absolutely be called before
 *	this function to set up internal buffer.
 *
 * ON EXIT:
 *	returns a newly-allocated character string representing
 *		the read line.	The line is unfolded, i.e.
 *		lines that begin with whitespace are appended
 *		to current line.  E.g.
 *
 *			Field-Name: Blaa-Blaa
 *			 This-Is-A-Continuation-Line
 *			 Here-Is_Another
 *
 *		is seen by the caller as:
 *
 *	Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
 *
 */
char *HTAA_getUnfoldedLine(void)
{
    char *line = NULL;
    char *cur;
    int count;
    BOOL peek_for_folding = NO;

    if (in_soc < 0) {
	CTRACE((tfp, "%s %s\n",
		"HTAA_getUnfoldedLine: buffer not initialized",
		"with function HTAA_setupReader()"));
	return NULL;
    }

    for (;;) {

	/* Reading from socket */

	if (start_pointer >= end_pointer) {	/*Read the next block and continue */
#ifdef USE_SSL
	    if (SSL_handle)
		count = SSL_read(SSL_handle, buffer, BUFFER_SIZE);
	    else
		count = NETREAD(in_soc, buffer, BUFFER_SIZE);
#else
	    count = NETREAD(in_soc, buffer, BUFFER_SIZE);
#endif /* USE_SSL */
	    if (count <= 0) {
		in_soc = -1;
		return line;
	    }
	    if (count > (int) buffer_length)
		count = (int) buffer_length;
	    start_pointer = buffer;
	    end_pointer = buffer + count;
	    *end_pointer = '\0';
#ifdef NOT_ASCII
	    cur = start_pointer;
	    while (cur < end_pointer) {
		*cur = TOASCII(*cur);
		cur++;
	    }
#endif /*NOT_ASCII */
	}
	cur = start_pointer;

	/* Unfolding */

	if (peek_for_folding) {
	    if (*cur != ' ' && *cur != '\t')
		return line;	/* Ok, no continuation line */
	    else		/* So this is a continuation line, continue */
		peek_for_folding = NO;
	}

	/* Finding end-of-line */

	while (cur < end_pointer && *cur != '\n')	/* Find the end-of-line */
	    cur++;		/* (or end-of-buffer).  */

	/* Terminating line */

	if (cur < end_pointer) {	/* So *cur==LF, terminate line */
	    *cur = '\0';	/* Overwrite LF */
	    if (*(cur - 1) == '\r')
		*(cur - 1) = '\0';	/* Overwrite CR */
	    peek_for_folding = YES;	/* Check for a continuation line */
	}

	/* Copying the result */

	if (line)
	    StrAllocCat(line, start_pointer);	/* Append */
	else
	    StrAllocCopy(line, start_pointer);	/* A new line */

	start_pointer = cur + 1;	/* Skip the read line */

    }				/* forever */
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTAAUtil.c,v 1.27 2008/12/31 22:04:39 tom Exp $
d80 1
a80 1
    if (!strncmp(upcased, "NONE", 4)) {
d83 1
a83 1
    } else if (!strncmp(upcased, "BASIC", 5)) {
d86 1
a86 1
    } else if (!strncmp(upcased, "PUBKEY", 6)) {
d89 1
a89 1
    } else if (!strncmp(upcased, "KERBEROSV4", 10)) {
d92 1
a92 1
    } else if (!strncmp(upcased, "KERBEROSV5", 10)) {
d237 1
a237 1
	m = strlen(q) - strlen(p);	/* Amount to match to wildcard */
d287 1
a287 1
	m = strlen(q) - strlen(p);	/* Amount to match to wildcard */
d473 1
a473 1
		      int length,
d483 1
a483 1
    } else if (length > (int) buffer_length) {	/* need more space? */
d490 3
d498 1
a498 2
	strncpy(buffer, start_of_headers, length);
	buffer[length] = '\0';
d559 2
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/* MODULE							HTAAUtil.c
d57 1
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 43
a44 43
**		COMMON PARTS OF ACCESS AUTHORIZATION MODULE
**			FOR BOTH SERVER AND BROWSER
**
** IMPORTANT:
**	Routines in this module use dynamic allocation, but free
**	automatically all the memory reserved by them.
**
**	Therefore the caller never has to (and never should)
**	free() any object returned by these functions.
**
**	Therefore also all the strings returned by this package
**	are only valid until the next call to the same function
**	is made.  This approach is selected, because of the nature
**	of access authorization: no string returned by the package
**	needs to be valid longer than until the next call.
**
**	This also makes it easy to plug the AA package in:
**	you don't have to ponder whether to free() something
**	here or is it done somewhere else (because it is always
**	done somewhere else).
**
**	The strings that the package needs to store are copied
**	so the original strings given as parameters to AA
**	functions may be freed or modified with no side effects.
**
**	The AA package does not free() anything else than what
**	it has itself allocated.
**
**	AA (Access Authorization) package means modules which
**	names start with HTAA.
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
**
** HISTORY:
**	 8 Nov 93  MD	(VMS only) Added case insensitive comparison in HTAA_templateCaseMatch
**
**
** BUGS:
**
**
*/
d48 2
a49 2
#include <HTAAUtil.h>	/* Implemented here	*/
#include <HTAssoc.h>	/* Assoc list		*/
d57 10
a66 10
**		TRANSLATE SCHEME NAME INTO
**		A SCHEME ENUMERATION
**
** ON ENTRY:
**	name		is a string representing the scheme name.
**
** ON EXIT:
**	returns		the enumerated constant for that scheme.
*/
PUBLIC HTAAScheme HTAAScheme_enum ARGS1(CONST char*, name)
a96 1

d98 10
a107 10
**			GET THE NAME OF A GIVEN SCHEME
** ON ENTRY:
**	scheme		is one of the scheme enum values:
**			HTAA_NONE, HTAA_BASIC, HTAA_PUBKEY, ...
**
** ON EXIT:
**	returns		the name of the scheme, i.e.
**			"None", "Basic", "Pubkey", ...
*/
PUBLIC char *HTAAScheme_name ARGS1(HTAAScheme, scheme)
d110 14
a123 14
	case HTAA_NONE:
	    return "None";
	case HTAA_BASIC:
	    return "Basic";
	case HTAA_PUBKEY:
	    return "Pubkey";
	case HTAA_KERBEROS_V4:
	    return "KerberosV4";
	case HTAA_KERBEROS_V5:
	    return "KerberosV5";
	case HTAA_UNKNOWN:
	    return "UNKNOWN";
	default:
	    return "THIS-IS-A-BUG";
a126 1

d128 9
a136 9
**		TRANSLATE METHOD NAME INTO AN ENUMERATED VALUE
** ON ENTRY:
**	name		is the method name to translate.
**
** ON EXIT:
**	returns		HTAAMethod enumerated value corresponding
**			to the given name.
*/
PUBLIC HTAAMethod HTAAMethod_enum ARGS1(CONST char *, name)
d141 1
a141 1
    if (0==strcasecomp(name, "GET"))
d143 1
a143 1
    else if (0==strcasecomp(name, "PUT"))
a148 1

d150 10
a159 10
**			GET THE NAME OF A GIVEN METHOD
** ON ENTRY:
**	method		is one of the method enum values:
**			METHOD_GET, METHOD_PUT, ...
**
** ON EXIT:
**	returns		the name of the scheme, i.e.
**			"GET", "PUT", ...
*/
PUBLIC char *HTAAMethod_name ARGS1(HTAAMethod, method)
d162 8
a169 8
      case METHOD_GET:
	  return "GET";
      case METHOD_PUT:
	  return "PUT";
      case METHOD_UNKNOWN:
	  return "UNKNOWN";
      default:
	  return "THIS-IS-A-BUG";
a172 1

d174 10
a183 11
**		IS A METHOD IN A LIST OF METHOD NAMES
** ON ENTRY:
**	method		is the method to look for.
**	list		is a list of method names.
**
** ON EXIT:
**	returns		YES, if method was found.
**			NO, if not found.
*/
PUBLIC BOOL HTAAMethod_inList ARGS2(HTAAMethod, method,
				    HTList *,	list)
d188 1
a188 1
    while (NULL != (item = (char*)HTList_nextObject(cur))) {
d194 1
a194 1
    return NO;	/* Not found */
a196 1

d198 23
a220 23
**		STRING COMPARISON FUNCTION FOR FILE NAMES
**		   WITH ONE WILDCARD * IN THE TEMPLATE
** NOTE:
**	This is essentially the same code as in HTRules.c, but it
**	cannot be used because it is embedded in between other code.
**	(In fact, HTRules.c should use this routine, but then this
**	 routine would have to be more sophisticated... why is life
**	 sometimes so hard...)
**
** ON ENTRY:
**	template	is a template string to match the file name
**			against, may contain a single wildcard
**			character * which matches zero or more
**			arbitrary characters.
**	filename	is the filename (or pathname) to be matched
**			against the template.
**
** ON EXIT:
**	returns		YES, if filename matches the template.
**			NO, otherwise.
*/
PUBLIC BOOL HTAA_templateMatch ARGS2(CONST char *, template,
				     CONST char *, filename)
d222 2
a223 2
    CONST char *p = template;
    CONST char *q = filename;
d226 2
a227 2
    for (; *p  &&  *q  &&  *p == *q; p++, q++)	/* Find first mismatch */
	; /* do nothing else */
d230 3
a232 3
	return YES;			/* Equally long equal strings */
    else if ('*' == *p) {		/* Wildcard */
	p++;				/* Skip wildcard character */
d235 1
a235 1
	    return NO;			/* No match, filename too short */
d237 1
a237 1
	    if (strcmp(p, q+m))
d242 2
a243 2
    }	/* if wildcard */
    else
a246 1

d248 23
a270 23
**		STRING COMPARISON FUNCTION FOR FILE NAMES
**		   WITH ONE WILDCARD * IN THE TEMPLATE (Case Insensitive)
** NOTE:
**	This is essentially the same code as in HTAA_templateMatch, but
**	it compares case insensitive (for VMS). Reason for this routine
**	is that HTAA_templateMatch gets called from several places, also
**	there where a case sensitive match is needed, so one cannot just
**	change the HTAA_templateMatch routine for VMS.
**
** ON ENTRY:
**	template	is a template string to match the file name
**			against, may contain a single wildcard
**			character * which matches zero or more
**			arbitrary characters.
**	filename	is the filename (or pathname) to be matched
**			against the template.
**
** ON EXIT:
**	returns		YES, if filename matches the template.
**			NO, otherwise.
*/
PUBLIC BOOL HTAA_templateCaseMatch ARGS2(CONST char *, template,
					 CONST char *, filename)
d272 2
a273 2
    CONST char *p = template;
    CONST char *q = filename;
d277 1
a277 2
    for (; *p  &&  *q  &&  TOUPPER(*p) == TOUPPER(*q); p++, q++)
	; /* do nothing else */
d280 3
a282 3
	return YES;			/* Equally long equal strings */
    else if ('*' == *p) {		/* Wildcard */
	p++;				/* Skip wildcard character */
d285 1
a285 1
	    return NO;			/* No match, filename too short */
d287 1
a287 1
	    if (strcasecomp(p, q+m))
d292 2
a293 2
    }	/* if wildcard */
    else
a296 1

d298 19
a316 19
**		CREATE A PROTECTION TEMPLATE FOR THE FILES
**		IN THE SAME DIRECTORY AS THE GIVEN FILE
**		(Used by server if there is no fancier way for
**		it to tell the client, and by browser if server
**		didn't send WWW-ProtectionTemplate: field)
** ON ENTRY:
**	docname is the document pathname (from URL).
**
** ON EXIT:
**	returns a template matching docname, and other files
**		files in that directory.
**
**		E.g.  /foo/bar/x.html  =>  /foo/bar/ *
**						    ^
**				Space only to prevent it from
**				being a comment marker here,
**				there really isn't any space.
*/
PUBLIC char *HTAA_makeProtectionTemplate ARGS1(CONST char *, docname)
d318 1
a318 1
    char *template = NULL;
d322 2
a323 2
	StrAllocCopy(template, docname);
	slash = strrchr(template, '/');
d327 1
a327 1
	    slash = template;
d329 3
a331 4
	StrAllocCat(template, "*");
    }
    else
	StrAllocCopy(template, "*");
d334 1
a334 1
		template, docname));
d336 1
a336 1
    return template;
a338 1

d340 2
a341 2
** Skip leading whitespace from *s forward
*/
d345 2
a346 2
** Kill trailing whitespace starting from *(s-1) backwards
*/
a348 1

d350 26
a375 26
**		PARSE AN ARGUMENT LIST GIVEN IN A HEADER FIELD
** ON ENTRY:
**	str	is a comma-separated list:
**
**			item, item, item
**		where
**			item ::= value
**			       | name=value
**			       | name="value"
**
**		Leading and trailing whitespace is ignored
**		everywhere except inside quotes, so the following
**		examples are equal:
**
**			name=value,foo=bar
**			 name="value",foo="bar"
**			  name = value ,  foo = bar
**			   name = "value" ,  foo = "bar"
**
** ON EXIT:
**	returns a list of name-value pairs (actually HTAssocList*).
**		For items with no name, just value, the name is
**		the number of order number of that item. E.g.
**		"1" for the first, etc.
*/
PUBLIC HTAssocList *HTAA_parseArgList ARGS1(char *, str)
d386 1
a386 1
	SKIPWS(str);				/* Skip leading whitespace */
d390 3
a392 3
	while (*cur  &&  *cur != '='  &&  *cur != ',')
	    cur++;	/* Find end of name (or lonely value without a name) */
	KILLWS(cur);	/* Kill trailing whitespace */
d394 2
a395 2
	if (*cur == '=') {			/* Name followed by a value */
	    *(cur++) = '\0';			/* Terminate name */
d397 1
a397 1
	    SKIPWS(cur);			/* Skip WS leading the value */
d399 1
a399 1
	    if (*str == '"') {			/* Quoted value */
d402 1
a402 1
		while (*cur  &&  *cur != '"')
d405 1
a405 1
		    *(cur++) = '\0';		/* Terminate value */
d407 1
a407 1
		SKIPWS(cur);			/* Skip WS leading comma */
d409 3
a411 4
		    cur++;			/* Skip separating colon */
	    }
	    else {				/* Unquoted value */
		while (*cur  &&  *cur != ',')
d413 1
a413 1
		KILLWS(cur);			/* Kill trailing whitespace */
d418 1
a418 2
	}
	else {	/* No name, just a value */
d420 1
a420 1
		*(cur++) = '\0';		/* Terminate value */
d426 1
a426 1
    } /* while *str */
a431 1

d436 5
a440 5
PRIVATE size_t buffer_length;
PRIVATE char *buffer = 0;
PRIVATE char *start_pointer;
PRIVATE char *end_pointer;
PRIVATE int in_soc = -1;
d443 1
a443 1
PRIVATE void FreeHTAAUtil NOARGS
d450 21
a470 21
**		SET UP HEADER LINE READER, i.e., give
**		the already-read-but-not-yet-processed
**		buffer of text to be read before more
**		is read from the socket.
** ON ENTRY:
**	start_of_headers is a pointer to a buffer containing
**			the beginning of the header lines
**			(rest will be read from a socket).
**	length		is the number of valid characters in
**			'start_of_headers' buffer.
**	soc		is the socket to use when start_of_headers
**			buffer is used up.
** ON EXIT:
**	returns		nothing.
**			Subsequent calls to HTAA_getUnfoldedLine()
**			will use this buffer first and then
**			proceed to read from socket.
*/
PUBLIC void HTAA_setupReader ARGS3(char *,	start_of_headers,
				   int,		length,
				   int,		soc)
d473 2
a474 2
	length = 0;	       /* initialize length (is this reached at all?) */
    if (buffer == NULL) {				       /* first call? */
d476 1
a476 1
	if (buffer_length < BUFFER_SIZE)     /* would fall below BUFFER_SIZE? */
d478 2
a479 3
	buffer = (char*)malloc((size_t)(sizeof(char)*(buffer_length + 1)));
    }
    else if (length > (int)buffer_length) {		  /* need more space? */
d481 2
a482 2
	buffer = (char*)realloc((char*)buffer,
				(size_t)(sizeof(char)*(buffer_length + 1)));
d484 2
a485 1
    if (buffer == NULL) outofmem(__FILE__, "HTAA_setupReader");
d494 1
a494 2
    }
    else {
a500 1

d502 21
a522 21
**		READ AN UNFOLDED HEADER LINE FROM SOCKET
** ON ENTRY:
**	HTAA_setupReader must absolutely be called before
**	this function to set up internal buffer.
**
** ON EXIT:
**	returns a newly-allocated character string representing
**		the read line.	The line is unfolded, i.e.
**		lines that begin with whitespace are appended
**		to current line.  E.g.
**
**			Field-Name: Blaa-Blaa
**			 This-Is-A-Continuation-Line
**			 Here-Is_Another
**
**		is seen by the caller as:
**
**	Field-Name: Blaa-Blaa This-Is-A-Continuation-Line Here-Is_Another
**
*/
PUBLIC char *HTAA_getUnfoldedLine NOARGS
d531 2
a532 2
		    "HTAA_getUnfoldedLine: buffer not initialized",
		    "with function HTAA_setupReader()"));
d536 1
a536 1
    for(;;) {
d540 1
a540 1
	if (start_pointer >= end_pointer) {/*Read the next block and continue*/
d562 1
a562 1
#endif /*NOT_ASCII*/
a565 1

d569 1
a569 1
	    if (*cur != ' '  &&  *cur != '\t')
a574 1

d577 2
a578 3
	while (cur < end_pointer && *cur != '\n') /* Find the end-of-line */
	    cur++;				  /* (or end-of-buffer).  */

d583 3
a585 3
	    *cur = '\0';		/* Overwrite LF */
	    if (*(cur-1) == '\r')
		*(cur-1) = '\0';	/* Overwrite CR */
a588 1

d596 1
a596 1
	start_pointer = cur+1;	/* Skip the read line */
d598 1
a598 1
    } /* forever */
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a52 4
#ifdef USE_SSL
PRIVATE SSL * Handle = NULL;	/* The SSL Handle	*/
#endif /* USE_SSL */

d559 2
a560 2
	    if (Handle)
		count = SSL_read(Handle, buffer, BUFFER_SIZE);
@


1.3
log
@a little bit of glue to call openssl; mark@@moxienet.com
@
text
@d51 1
a53 3
#define free_func free__func
#include <openssl/ssl.h>
#undef free_func
d198 1
a198 1
	CTRACE(tfp, " %s", item);
d347 2
a348 2
    CTRACE(tfp, "make_template: made template `%s' for file `%s'\n",
		template, docname);
d551 1
a551 1
	CTRACE(tfp, "%s %s\n",
d553 1
a553 1
		    "with function HTAA_setupReader()");
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d52 7
d564 6
d571 1
@


1.1
log
@Initial revision
@
text
@a0 1

d14 1
a14 1
**	is made. This approach is selected, because of the nature
d46 5
a50 7
#include "HTUtils.h"
#include "tcp.h"	/* NETREAD() etc.	*/
#include <string.h>
#include "HTAAUtil.h"	/* Implemented here	*/
#include "HTAssoc.h"	/* Assoc list		*/
#include "HTTCP.h"
#include "HTAlert.h"
d52 2
a53 1
#include "LYLeaks.h"
d63 1
a63 1
**	returns 	the enumerated constant for that scheme.
a67 1
    char *cur;
d73 1
a73 5
    cur = upcased;
    while (*cur) {
	*cur = TOUPPER(*cur);
	cur++;
    }
d104 1
a104 1
**	returns 	the name of the scheme, i.e.
a111 1
	    break;
a113 1
	    break;
a115 1
	    break;
a117 1
	    break;
a119 1
	    break;
a121 1
	    break;
d134 1
a134 1
**	returns 	HTAAMethod enumerated value corresponding
a138 4
    char tmp[MAX_METHODNAME_LEN+1];
    CONST char *src = name;
    char *dest = tmp;

d142 1
a142 8
    while (*src) {
	*dest = TOUPPER(*src);
	dest++;
	src++;
    }
    *dest = 0;

    if (0==strcmp(tmp, "GET"))
d144 1
a144 1
    else if (0==strcmp(tmp, "PUT"))
d158 1
a158 1
**	returns 	the name of the scheme, i.e.
a165 1
	  break;
a167 1
	  break;
a169 1
	  break;
d183 1
a183 1
**	returns 	YES, if method was found.
d193 1
a193 2
	if (TRACE)
	    fprintf(stderr, " %s", item);
d214 1
a214 1
**			agaist, may contain a single wildcard
d218 1
a218 1
**			agaist the template.
d221 1
a221 1
**	returns 	YES, if filename matches the template.
d265 1
a265 1
**			agaist, may contain a single wildcard
d269 1
a269 1
**			agaist the template.
d272 1
a272 1
**	returns 	YES, if filename matches the template.
d342 2
a343 3
    if (TRACE)
	fprintf(stderr, "make_template: made template `%s' for file `%s'\n",
			template, docname);
d355 1
a355 1
** Kill trailing whitespace starting from *(s-1) backwords
d435 1
a435 2
	    StrAllocCopy(name, "nnn");	/* Room for item order number */
	    sprintf(name, "%d", n);	/* Item order number for name */
d450 4
a453 3
PRIVATE char buffer[BUFFER_SIZE + 1];
PRIVATE char *start_pointer = buffer;
PRIVATE char *end_pointer = buffer;
d456 7
d464 1
a464 1
**		SET UP HEADER LINE READER, i.e. give
d477 1
a477 1
**	returns 	nothing.
d482 21
a502 5
PUBLIC void HTAA_setupReader ARGS4(char *,	start_of_headers,
				   int, 	length,
				   void *,	handle,
				   int, 	soc)
{
d546 3
a548 4
	if (TRACE)
	    fprintf(stderr, "%s %s\n",
			    "HTAA_getUnfoldedLine: buffer not initialized",
			    "with function HTAA_setupReader()");
a612 2


@


1.1.1.1
log
@Lynx 2.8
@
text
@@
