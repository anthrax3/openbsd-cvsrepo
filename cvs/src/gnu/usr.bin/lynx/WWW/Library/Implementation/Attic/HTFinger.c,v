head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.46;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.41;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.41;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTFinger.c,v 1.31 2013/11/28 11:27:50 tom Exp $
 *
 *			FINGER ACCESS				HTFinger.c
 *			=============
 * Authors:
 *  ARB  Andrew Brooks
 *
 * History:
 *	21 Apr 94   First version (ARB, from HTNews.c by TBL)
 *	12 Mar 96   Made the URL and command buffering secure from
 *		     stack modifications, beautified the HTLoadFinger()
 *		     and response() functions, and added support for the
 *		     following URL formats for sending a "", "/w",
 *		     "username[@@host]", or "/w username[@@host]" command
 *		     to the server:
 *			finger://host
 *			finger://host/
 *			finger://host/%2fw
 *			finger://host/%2fw%20username[@@host]
 *			finger://host/w/username[@@host]
 *			finger://host/username[@@host]
 *			finger://host/username[@@host]/w
 *			finger://username@@host
 *			finger://username@@host/
 *			finger://username@@host/w
 *	15 Mar 96   Added support for port 79 gtype 0 gopher URLs
 *		     relayed from HTLoadGopher. - FM
 */

#include <HTUtils.h>

#ifndef DISABLE_FINGER

#include <HTAlert.h>
#include <HTML.h>
#include <HTParse.h>
#include <HTFormat.h>
#include <HTTCP.h>
#include <HTString.h>
#include <HTFinger.h>

#include <LYUtils.h>
#include <LYLeaks.h>

#define FINGER_PORT 79		/* See rfc742 */
#define BIG 1024		/* Bug */

#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)
#define NEXT_CHAR HTGetCharacter()

/*	Module-wide variables
*/
static int finger_fd;		/* Socket for FingerHost */

struct _HTStructured {
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
};

static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */

/*	Initialisation for this module
 *	------------------------------
 */
static BOOL initialized = NO;
static BOOL initialize(void)
{
    finger_fd = -1;		/* Disconnected */
    return YES;
}

/*	Start anchor element
 *	--------------------
 */
static void start_anchor(const char *href)
{
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];

    {
	int i;

	for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	    present[i] = (BOOL) (i == HTML_A_HREF);
    }
    ((const char **) value)[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);

}

/*	Send Finger Command line to remote host & Check Response
 *	--------------------------------------------------------
 *
 * On entry,
 *	command	points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is a Finger status.
 */

static int response(char *command,
		    char *sitename,
		    HTParentAnchor *anAnchor,
		    HTFormat format_out,
		    HTStream *sink)
{
    int status;
    int length = (int) strlen(command);
    int ch, i;
    char line[BIG], *l, *cmd = NULL;
    char *p = line, *href = NULL;

    if (length == 0)
	return (-1);

    /* Set up buffering.
     */
    HTInitInput(finger_fd);

    /* Send the command.
     */
    CTRACE((tfp, "HTFinger command to be sent: %s", command));
    status = (int) NETWRITE(finger_fd, (char *) command, (unsigned) length);
    if (status < 0) {
	CTRACE((tfp, "HTFinger: Unable to send command. Disconnecting.\n"));
	NETCLOSE(finger_fd);
	finger_fd = -1;
	return status;
    }
    /* if bad status */
    /* Make a hypertext object with an anchor list.
     */
    target = HTML_new(anAnchor, format_out, sink);
    targetClass = *target->isa;	/* Copy routine entry points */

    /* Create the results report.
     */
    CTRACE((tfp, "HTFinger: Reading finger information\n"));
    START(HTML_HTML);
    PUTC('\n');
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    PUTS("Finger server on ");
    PUTS(sitename);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_BODY);
    PUTC('\n');
    START(HTML_H1);
    PUTS("Finger server on ");
    START(HTML_EM);
    PUTS(sitename);
    END(HTML_EM);
    PUTS(": ");
    StrAllocCopy(cmd, command);
    for (i = ((int) strlen(cmd) - 1); i >= 0; i--) {
	if (cmd[i] == LF || cmd[i] == CR) {
	    cmd[i] = '\0';
	} else {
	    break;
	}
    }
    PUTS(cmd);
    FREE(cmd);
    END(HTML_H1);
    PUTC('\n');
    START(HTML_PRE);

    while ((ch = NEXT_CHAR) != EOF) {

	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    goto end_html;
	}

	if (ch != LF) {
	    *p = (char) ch;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
		p++;
	    }
	} else {
	    *p = '\0';		/* Terminate line */
	    /*
	     * OK we now have a line.
	     * Load it as 'l' and parse it.
	     */
	    p = l = line;
	    while (*l) {
		if (StrNCmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
		    StrNCmp(l, "snews://", 8) &&
		    StrNCmp(l, "nntp://", 7) &&
		    StrNCmp(l, "snewspost:", 10) &&
		    StrNCmp(l, "snewsreply:", 11) &&
		    StrNCmp(l, "newspost:", 9) &&
		    StrNCmp(l, "newsreply:", 10) &&
		    StrNCmp(l, "ftp://", 6) &&
		    StrNCmp(l, "file:/", 6) &&
		    StrNCmp(l, "finger://", 9) &&
		    StrNCmp(l, "http://", 7) &&
		    StrNCmp(l, "https://", 8) &&
		    StrNCmp(l, "wais://", 7) &&
		    StrNCmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
		    StrNCmp(l, "cso://", 6) &&
		    StrNCmp(l, "gopher://", 9))
		    PUTC(*l++);
		else {
		    StrAllocCopy(href, l);
		    start_anchor(strtok(href, " \r\n\t,>)\""));
		    while (*l && !StrChr(" \r\n\t,>)\"", *l))
			PUTC(*l++);
		    END(HTML_A);
		    FREE(href);
		}
	    }
	    PUTC('\n');
	}
    }
    NETCLOSE(finger_fd);
    finger_fd = -1;

  end_html:
    END(HTML_PRE);
    PUTC('\n');
    END(HTML_BODY);
    PUTC('\n');
    END(HTML_HTML);
    PUTC('\n');
    FREE_TARGET;
    return (0);
}

/*		Load by name					HTLoadFinger
 *		============
 */
int HTLoadFinger(const char *arg,
		 HTParentAnchor *anAnchor,
		 HTFormat format_out,
		 HTStream *stream)
{
    static char empty[1];

    char *username, *sitename;	/* Fields extracted from URL */
    char *slash, *at_sign;	/* Fields extracted from URL */
    char *command, *str, *param;	/* Buffers */
    int port;			/* Port number from URL */
    int status;			/* tcp return */
    int result = HT_LOADED;
    BOOL IsGopherURL = FALSE;
    const char *p1 = arg;

    CTRACE((tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL")));

    if (!(arg && *arg)) {
	HTAlert(COULD_NOT_LOAD_DATA);
	return HT_NOT_LOADED;	/* Ignore if no name */
    }

    if (!initialized)
	initialized = initialize();
    if (!initialized) {
	HTAlert(gettext("Could not set up finger connection."));
	return HT_NOT_LOADED;	/* FAIL */
    }

    /*  Set up the host and command fields.
     */
    if (!strncasecomp(arg, "finger://", 9)) {
	p1 = arg + 9;		/* Skip "finger://" prefix */
    } else if (!strncasecomp(arg, "gopher://", 9)) {
	p1 = arg + 9;		/* Skip "gopher://" prefix */
	IsGopherURL = TRUE;
    }

    param = 0;
    sitename = StrAllocCopy(param, p1);
    if (param == 0) {
	HTAlert(COULD_NOT_LOAD_DATA);
	return HT_NOT_LOADED;
    } else if ((slash = StrChr(sitename, '/')) != NULL) {
	*slash++ = '\0';
	HTUnEscape(slash);
	if (IsGopherURL) {
	    if (*slash != '0') {
		HTAlert(COULD_NOT_LOAD_DATA);
		return HT_NOT_LOADED;	/* FAIL */
	    }
	    *slash++ = '\0';
	}
    }

    if ((at_sign = StrChr(sitename, '@@')) != NULL) {
	if (IsGopherURL) {
	    HTAlert(COULD_NOT_LOAD_DATA);
	    return HT_NOT_LOADED;	/* FAIL */
	} else {
	    *at_sign++ = '\0';
	    username = sitename;
	    sitename = at_sign;
	    HTUnEscape(username);
	}
    } else if (slash) {
	username = slash;
    } else {
	username = empty;
    }

    if (*sitename == '\0') {
	HTAlert(gettext("Could not load data (no sitename in finger URL)"));
	result = HT_NOT_LOADED;	/* Ignore if no name */
    } else if (HTParsePort(sitename, &port) != NULL) {
	if (port != 79) {
	    HTAlert(gettext("Invalid port number - will only use port 79!"));
	    result = HT_NOT_LOADED;	/* Ignore if wrong port */
	}
    }

    if (result == HT_LOADED) {
	/* Load the string for making a connection/
	 */
	str = 0;
	HTSprintf0(&str, "lose://%s/", sitename);

	/* Load the command for the finger server.
	 */
	command = 0;
	if (at_sign && slash) {
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
	} else if (at_sign) {
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	} else if (*username == '/') {
	    if ((slash = StrChr((username + 1), '/')) != NULL) {
		*slash = ' ';
	    }
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username + 1) == '/') {
	    if (*username + 2 != '\0') {
		*(username + 1) = ' ';
	    } else {
		*(username + 1) = '\0';
	    }
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((*username == 'w' || *username == 'W') &&
		   *(username + 1) == '\0') {
	    HTSprintf0(&command, "/%s%c%c", username, CR, LF);
	} else if ((slash = StrChr(username, '/')) != NULL) {
	    *slash++ = '\0';
	    if (*slash == 'w' || *slash == 'W') {
		HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	    } else {
		HTSprintf0(&command, "%s%c%c", username, CR, LF);
	    }
	} else {
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
	}

	/* Now, let's get a stream setup up from the FingerHost:
	 * CONNECTING to finger host
	 */
	CTRACE((tfp, "HTFinger: doing HTDoConnect on '%s'\n", str));
	status = HTDoConnect(str, "finger", FINGER_PORT, &finger_fd);
	CTRACE((tfp, "HTFinger: Done DoConnect; status %d\n", status));

	if (status == HT_INTERRUPTED) {
	    /* Interrupt cleanly */
	    CTRACE((tfp,
		    "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress(CONNECTION_INTERRUPTED);
	    result = HT_NOT_LOADED;
	} else if (status < 0) {
	    NETCLOSE(finger_fd);
	    finger_fd = -1;
	    CTRACE((tfp, "HTFinger: Unable to connect to finger host.\n"));
	    HTAlert(gettext("Could not access finger host."));
	    result = HT_NOT_LOADED;	/* FAIL */
	} else {
	    CTRACE((tfp, "HTFinger: Connected to finger host '%s'.\n", str));

	    /* Send the command, and process response if successful.
	     */
	    if (response(command, sitename, anAnchor, format_out, stream) != 0) {
		HTAlert(gettext("No response from finger server."));
		result = HT_NOT_LOADED;
	    }
	}
	FREE(str);
	FREE(command);
    }
    FREE(param);
    return result;
}

#ifdef GLOBALDEF_IS_MACRO
#define _HTFINGER_C_1_INIT { "finger", HTLoadFinger, NULL }
GLOBALDEF(HTProtocol, HTFinger, _HTFINGER_C_1_INIT);
#else
GLOBALDEF HTProtocol HTFinger =
{"finger", HTLoadFinger, NULL};
#endif /* GLOBALDEF_IS_MACRO */

#endif /* not DISABLE_FINGER */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTFinger.c,v 1.25 2009/01/03 02:02:18 tom Exp $
d131 1
a131 1
    status = NETWRITE(finger_fd, (char *) command, (unsigned) length);
d166 1
a166 5
    if (command) {
	StrAllocCopy(cmd, command);
    } else {
	StrAllocCopy(cmd, "");
    }
d202 16
a217 16
		if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
		    strncmp(l, "snews://", 8) &&
		    strncmp(l, "nntp://", 7) &&
		    strncmp(l, "snewspost:", 10) &&
		    strncmp(l, "snewsreply:", 11) &&
		    strncmp(l, "newspost:", 9) &&
		    strncmp(l, "newsreply:", 10) &&
		    strncmp(l, "ftp://", 6) &&
		    strncmp(l, "file:/", 6) &&
		    strncmp(l, "finger://", 9) &&
		    strncmp(l, "http://", 7) &&
		    strncmp(l, "https://", 8) &&
		    strncmp(l, "wais://", 7) &&
		    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
		    strncmp(l, "cso://", 6) &&
		    strncmp(l, "gopher://", 9))
d222 1
a222 1
		    while (*l && !strchr(" \r\n\t,>)\"", *l))
d253 3
a255 1
    char *username, *sitename, *colon;	/* Fields extracted from URL */
d292 1
a292 1
    } else if ((slash = strchr(sitename, '/')) != NULL) {
d304 1
a304 1
    if ((at_sign = strchr(sitename, '@@')) != NULL) {
d317 1
a317 1
	username = "";
d323 1
a323 3
    } else if ((colon = strchr(sitename, ':')) != NULL) {
	*colon++ = '\0';
	port = atoi(colon);
d348 1
a348 1
	    if ((slash = strchr((username + 1), '/')) != NULL) {
d363 1
a363 1
	} else if ((slash = strchr(username, '/')) != NULL) {
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			FINGER ACCESS				HTFinger.c
d116 1
a116 1
    int length = strlen(command);
d131 1
a131 1
    status = NETWRITE(finger_fd, (char *) command, length);
d171 1
a171 1
    for (i = (strlen(cmd) - 1); i >= 0; i--) {
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 25
a26 25
**			=============
** Authors:
**  ARB  Andrew Brooks
**
** History:
**	21 Apr 94   First version (ARB, from HTNews.c by TBL)
**	12 Mar 96   Made the URL and command buffering secure from
**		     stack modifications, beautified the HTLoadFinger()
**		     and response() functions, and added support for the
**		     following URL formats for sending a "", "/w",
**		     "username[@@host]", or "/w username[@@host]" command
**		     to the server:
**			finger://host
**			finger://host/
**			finger://host/%2fw
**			finger://host/%2fw%20username[@@host]
**			finger://host/w/username[@@host]
**			finger://host/username[@@host]
**			finger://host/username[@@host]/w
**			finger://username@@host
**			finger://username@@host/
**			finger://username@@host/w
**	15 Mar 96   Added support for port 79 gtype 0 gopher URLs
**		     relayed from HTLoadGopher. - FM
*/
a52 1

d55 1
a55 1
PRIVATE int finger_fd;				/* Socket for FingerHost */
d58 2
a59 2
	CONST HTStructuredClass * isa;		/* For gopher streams */
	/* ... */
d62 2
a63 2
PRIVATE HTStructured * target;			/* The output sink */
PRIVATE HTStructuredClass targetClass;		/* Copy of fn addresses */
d66 4
a69 4
**	------------------------------
*/
PRIVATE BOOL initialized = NO;
PRIVATE BOOL initialize NOARGS
d71 2
a72 2
  finger_fd = -1;		/* Disconnected */
  return YES;
a74 2


d76 3
a78 3
**	--------------------
*/
PRIVATE void start_anchor ARGS1(CONST char *,  href)
d80 2
a81 2
    BOOL		present[HTML_A_ATTRIBUTES];
    CONST char*		value[HTML_A_ATTRIBUTES];
d85 3
a87 2
	for(i=0; i<HTML_A_ATTRIBUTES; i++)
	    present[i] = (BOOL) (i==HTML_A_HREF);
d89 3
a91 3
    ((CONST char **)value)[HTML_A_HREF] = href;
    (*targetClass.start_element)(target, HTML_A, present,
				 (CONST char **)value, -1, 0);
d96 15
a110 17
**	--------------------------------------------------------
**
** On entry,
**	command	points to the command to be sent, including CRLF, or is null
**		pointer if no command to be sent.
** On exit,
**	Negative status indicates transmission error, socket closed.
**	Positive status is a Finger status.
*/


PRIVATE int response ARGS5(
	char *,			command,
	char *,			sitename,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d115 2
a116 2
    char line[BIG], *l, *cmd=NULL;
    char *p = line, *href=NULL;
d119 1
a119 1
	return(-1);
d122 1
a122 1
    */
d126 1
a126 1
    */
d128 1
a128 1
    status = NETWRITE(finger_fd, (char *)command, length);
d134 2
a135 2
    } /* if bad status */

d137 1
a137 1
    */
d142 2
a143 2
    */
    CTRACE((tfp,"HTFinger: Reading finger information\n"));
d181 1
a181 1
    while ((ch=NEXT_CHAR) != EOF) {
d184 3
a186 2
	    CTRACE((tfp, "HTFinger: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress (CONNECTION_INTERRUPTED);
d191 2
a192 2
	    *p = (char) ch;      /* Put character in line */
	    if (p < &line[BIG-1]) {
d235 1
a235 1
end_html:
d243 1
a243 1
    return(0);
a245 1

d247 6
a252 7
**		============
*/
PUBLIC int HTLoadFinger ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		stream)
d255 1
a255 1
    char *slash, *at_sign;		/* Fields extracted from URL */
d257 2
a258 2
    int port;				/* Port number from URL */
    int status;				/* tcp return */
d261 1
a261 1
    CONST char * p1 = arg;
d267 1
a267 1
	return HT_NOT_LOADED;			/* Ignore if no name */
d273 1
a273 1
	HTAlert (gettext("Could not set up finger connection."));
d278 1
a278 1
    */
d280 1
a280 1
	p1 = arg + 9;  /* Skip "finger://" prefix */
d282 1
a282 1
	p1 = arg + 9;  /* Skip "gopher://" prefix */
d321 1
a321 1
	result = HT_NOT_LOADED;		/* Ignore if no name */
d333 1
a333 1
	*/
d338 1
a338 1
	*/
d349 1
a349 1
	    if ((slash = strchr((username+1), '/')) != NULL) {
d354 3
a356 3
		   *(username+1) == '/') {
	    if (*username+2 != '\0') {
		*(username+1) = ' ';
d358 1
a358 1
		*(username+1) = '\0';
d362 1
a362 1
		   *(username+1) == '\0') {
d376 2
a377 2
	** CONNECTING to finger host
	*/
d384 3
a386 2
	    CTRACE((tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	    HTProgress (CONNECTION_INTERRUPTED);
d398 1
a398 1
	    */
d413 1
a413 1
GLOBALDEF (HTProtocol, HTFinger, _HTFINGER_C_1_INIT);
d415 2
a416 1
GLOBALDEF PUBLIC HTProtocol HTFinger = { "finger", HTLoadFinger, NULL };
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d56 1
a56 1
PRIVATE int s;					/* Socket for FingerHost */
d72 1
a72 1
  s = -1;		/* Disconnected */
d127 1
a127 1
    HTInitInput(s);
d132 1
a132 1
    status = NETWRITE(s, (char *)command, length);
d135 2
a136 2
	NETCLOSE(s);
	s = -1;
d206 1
a206 1
		if (strncmp(l, "news:", 5) &&
d219 1
a219 1
		    strncmp(l, "mailto:", 7) &&
d235 2
a236 2
    NETCLOSE(s);
    s = -1;
d261 1
a261 1
    char *command, *str;		/* Buffers */
d264 3
a281 4
  {
    CONST char * p1=arg;
    BOOL IsGopherURL = FALSE;

a289 1
    sitename = (char *)p1;
d291 6
a296 1
    if ((slash = strchr(sitename, '/')) != NULL) {
d307 1
d312 5
a317 4
	*at_sign++ = '\0';
	username = sitename;
	sitename = at_sign;
	HTUnEscape(username);
d326 2
a327 4
	return HT_NOT_LOADED;		/* Ignore if no name */
    }

    if ((colon = strchr(sitename, ':')) != NULL) {
d332 1
a332 1
	    return HT_NOT_LOADED;	/* Ignore if wrong port */
d336 40
a375 11
    /* Load the string for making a connection/
    */
    str = 0;
    HTSprintf0(&str, "lose://%s/", sitename);

    /* Load the command for the finger server.
    */
    command = 0;
    if (at_sign && slash) {
	if (*slash == 'w' || *slash == 'W') {
	    HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
d379 19
a397 11
    } else if (at_sign) {
	HTSprintf0(&command, "%s%c%c", username, CR, LF);
    } else if (*username == '/') {
	if ((slash = strchr((username+1), '/')) != NULL) {
	    *slash = ' ';
	}
	HTSprintf0(&command, "%s%c%c", username, CR, LF);
    } else if ((*username == 'w' || *username == 'W') &&
	       *(username+1) == '/') {
	if (*username+2 != '\0') {
	    *(username+1) = ' ';
d399 8
a406 12
	    *(username+1) = '\0';
	}
	HTSprintf0(&command, "/%s%c%c", username, CR, LF);
    } else if ((*username == 'w' || *username == 'W') &&
	       *(username+1) == '\0') {
	HTSprintf0(&command, "/%s%c%c", username, CR, LF);
    } else if ((slash = strchr(username, '/')) != NULL) {
	*slash++ = '\0';
	if (*slash == 'w' || *slash == 'W') {
	    HTSprintf0(&command, "/w %s%c%c", username, CR, LF);
	} else {
	    HTSprintf0(&command, "%s%c%c", username, CR, LF);
a407 16
    } else {
	HTSprintf0(&command, "%s%c%c", username, CR, LF);
    }
  } /* scope of p1 */

    /* Now, let's get a stream setup up from the FingerHost:
    ** CONNECTING to finger host
    */
    CTRACE((tfp, "HTFinger: doing HTDoConnect on '%s'\n", str));
    status = HTDoConnect(str, "finger", FINGER_PORT, &s);
    CTRACE((tfp, "HTFinger: Done DoConnect; status %d\n", status));

    if (status == HT_INTERRUPTED) {
	/* Interrupt cleanly */
	CTRACE((tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n"));
	HTProgress (CONNECTION_INTERRUPTED);
a409 1
	return HT_NOT_LOADED;
d411 2
a412 22
    if (status < 0) {
	NETCLOSE(s);
	s = -1;
	CTRACE((tfp, "HTFinger: Unable to connect to finger host.\n"));
	HTAlert(gettext("Could not access finger host."));
	FREE(str);
	FREE(command);
	return HT_NOT_LOADED;	/* FAIL */
    }
    CTRACE((tfp, "HTFinger: Connected to finger host '%s'.\n", str));
    FREE(str);

    /* Send the command, and process response if successful.
    */
    if (response(command, sitename, anAnchor, format_out, stream) != 0) {
	HTAlert(gettext("No response from finger server."));
	FREE(command);
	return HT_NOT_LOADED;
    }

    FREE(command);
    return HT_LOADED;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d89 1
a89 1
	    present[i] = (i==HTML_A_HREF);
d110 1
a110 1
	CONST char *,		command,
d131 1
a131 1
    CTRACE(tfp, "HTFinger command to be sent: %s", command);
d134 1
a134 1
	CTRACE(tfp, "HTFinger: Unable to send command. Disconnecting.\n");
d147 1
a147 1
    CTRACE(tfp,"HTFinger: Reading finger information\n");
d188 1
a188 1
	    CTRACE(tfp, "HTFinger: Interrupted in HTGetCharacter, apparently.\n");
d194 1
a194 1
	    *p = ch;		/* Put character in line */
d265 1
a265 1
    CTRACE(tfp, "HTFinger: Looking for %s\n", (arg ? arg : "NULL"));
d380 1
a380 1
    CTRACE(tfp, "HTFinger: doing HTDoConnect on '%s'\n", str);
d382 1
a382 1
    CTRACE(tfp, "HTFinger: Done DoConnect; status %d\n", status);
d386 1
a386 1
	CTRACE(tfp, "HTFinger: Interrupted on connect; recovering cleanly.\n");
d395 1
a395 1
	CTRACE(tfp, "HTFinger: Unable to connect to finger host.\n");
d401 1
a401 1
    CTRACE(tfp, "HTFinger: Connected to finger host '%s'.\n", str);
@


1.1
log
@Initial revision
@
text
@d28 1
a28 9
#include "HTUtils.h"
#include "tcp.h"
#include "HTAlert.h"
#include "HTML.h"
#include "HTParse.h"
#include "HTFormat.h"
#include "HTTCP.h"
#include "HTString.h"
#include "HTFinger.h"
d30 1
a30 1
#include "LYLeaks.h"
d32 10
a41 1
/* #define TRACE 1 */
a45 2
#define FREE(x) if (x) {free(x); x = NULL;}

d51 1
a51 1
#define NEXT_CHAR HTGetCharacter() 
d85 1
a85 1
    
d87 2
a88 2
    	int i;
    	for(i=0; i<HTML_A_ATTRIBUTES; i++)
d93 1
a93 1
    				 (CONST char **)value, -1, 0);
d123 1
a123 1
        return(-1);
d131 1
a131 2
    if (TRACE) 
        fprintf(stderr, "HTFinger command to be sent: %s", command);
d134 4
a137 6
        if (TRACE)
	    fprintf(stderr,
                    "HTFinger: Unable to send command. Disconnecting.\n");
        NETCLOSE(s);
        s = -1;
        return status;
d139 1
a139 1
  
d147 1
a147 2
    if (TRACE)
	fprintf(stderr,"HTFinger: Reading finger information\n");
d149 1
a149 1
    PUTS("\n");
d151 1
a151 1
    PUTS("\n");
d156 1
a156 1
    PUTS("\n");
d158 1
a158 1
    PUTS("\n");
d160 1
a160 1
    PUTS("\n");
d168 1
a168 1
        StrAllocCopy(cmd, command);
d170 1
a170 1
        StrAllocCopy(cmd, "");
d173 1
a173 1
        if (cmd[i] == LF || cmd[i] == CR) {
d182 1
a182 1
    PUTS("\n");
d185 1
a185 1
    while ((ch=NEXT_CHAR) != (char)EOF) {
d188 2
a189 5
	    if (TRACE) {
	        fprintf(stderr,
		  "HTFinger: Interrupted in HTGetCharacter, apparently.\n");
	    }
	    _HTProgress ("Connection interrupted.");
d191 1
a191 1
        }
d196 1
a196 1
	        p++;
d221 1
a221 1
		    strncmp(l, "gopher://", 9)) 
d227 1
a227 1
		        PUTC(*l++);
d240 1
a240 1
    PUTS("\n");
d242 1
a242 1
    PUTS("\n");
d244 1
a244 1
    PUTS("\n");
d264 3
a266 5
  
    if (TRACE) {
        fprintf(stderr, "HTFinger: Looking for %s\n", (arg ? arg : "NULL"));
    }
  
d268 1
a268 1
        HTAlert("Could not load data.");
d271 3
a273 3
  
    if (!initialized) 
        initialized = initialize();
d275 1
a275 1
        HTAlert ("Could not set up finger connection.");
d278 1
a278 1
    
d282 1
a282 1
    
d284 1
a284 1
    */        
d286 1
a286 1
        p1 = arg + 9;  /* Skip "finger://" prefix */
d288 1
a288 1
        p1 = arg + 9;  /* Skip "gopher://" prefix */
d294 1
a294 1
        *slash++ = '\0';
d298 1
a298 1
	        HTAlert("Could not load data.");
d305 2
a306 2
        if (IsGopherURL) {
            HTAlert("Could not load data.");
d309 2
a310 2
        *at_sign++ = '\0';
        username = sitename;
d314 1
a314 1
        username = slash;
d316 1
a316 1
        username = "";
d318 1
a318 1
    
d320 1
a320 1
        HTAlert("Could not load data (no sitename in finger URL)");
d325 1
a325 1
        *colon++ = '\0';
d328 1
a328 1
	    HTAlert("Invalid port number - will only use port 79!");
d335 3
a337 5
    str = (char *)calloc(1, (strlen(sitename) + 10));
    if (str == NULL)
        outofmem(__FILE__, "HTLoadFinger");
    sprintf(str, "lose://%s/", sitename);
    
d340 1
a340 3
    command = (char *)calloc(1, (strlen(username) + 10));
    if (command == NULL)
        outofmem(__FILE__, "HTLoadFinger");
d342 2
a343 2
        if (*slash == 'w' || *slash == 'W') {
	    sprintf(command, "/w %s%c%c", username, CR, LF);
d345 1
a345 1
	    sprintf(command, "%s%c%c", username, CR, LF);
d348 1
a348 1
	sprintf(command, "%s%c%c", username, CR, LF);
d350 1
a350 1
        if ((slash = strchr((username+1), '/')) != NULL) {
d353 1
a353 1
	sprintf(command, "%s%c%c", username, CR, LF);
d355 1
a355 1
    	       *(username+1) == '/') {
d361 1
a361 1
	sprintf(command, "/%s%c%c", username, CR, LF);
d363 2
a364 2
    	       *(username+1) == '\0') {
	sprintf(command, "/%s%c%c", username, CR, LF);
d368 1
a368 1
	    sprintf(command, "/w %s%c%c", username, CR, LF);
d370 1
a370 1
	    sprintf(command, "%s%c%c", username, CR, LF);
d373 1
a373 1
	sprintf(command, "%s%c%c", username, CR, LF);
d376 1
a376 1
  
d380 1
a380 2
    if (TRACE)
        fprintf(stderr, "HTFinger: doing HTDoConnect on '%s'\n", str);
d382 1
a382 2
    if (TRACE)
        fprintf(stderr, "HTFinger: Done DoConnect; status %d\n", status);
d385 3
a387 5
        /* Interrupt cleanly */
	if (TRACE)
	    fprintf(stderr,
	    	  "HTFinger: Interrupted on connect; recovering cleanly.\n");
	HTProgress ("Connection interrupted.");
d393 1
a393 1
        NETCLOSE(s);
d395 2
a396 3
	if (TRACE) 
	    fprintf(stderr, "HTFinger: Unable to connect to finger host.\n");
        HTAlert("Could not access finger host.");
d401 1
a401 2
    if (TRACE)
        fprintf(stderr, "HTFinger: Connected to finger host '%s'.\n", str);
d407 1
a407 1
        HTAlert("No response from finger server.");
d422 2
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
