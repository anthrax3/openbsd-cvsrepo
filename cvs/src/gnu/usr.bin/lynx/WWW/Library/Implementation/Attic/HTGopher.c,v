head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.12
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.10
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.8
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.02.02.37.40;	author pirofti;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.30.14.38.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.04.24.03;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.47;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTGopher.c,v 1.61 2013/11/28 11:12:32 tom Exp $
 *
 *			GOPHER ACCESS				HTGopher.c
 *			=============
 *
 *  History:
 *	26 Sep 90	Adapted from other accesses (News, HTTP) TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 *	10 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Added a
 *			  form-based CSO/PH gateway.  Can be invoked via a
 *			  "cso://host[:port]/" or "gopher://host:105/2"
 *			  URL.	If a gopher URL is used with a query token
 *			  ('?'), the old ISINDEX procedure will be used
 *			  instead of the form-based gateway.
 *	15 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Pass
 *			  port 79, gtype 0 gopher URLs to the finger
 *			  gateway.
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>		/* Coding convention macros */
#include <HTFile.h>		/* For HTFileFormat() */

#ifndef DISABLE_GOPHER
#include <HTAlert.h>
#include <HTParse.h>
#include <HTTCP.h>
#include <HTFinger.h>

/*
 *  Implements.
 */
#include <HTGopher.h>

#define GOPHER_PORT 70		/* See protocol spec */
#define CSO_PORT 105		/* See protocol spec */
#define BIG 1024		/* Bug */
#define LINE_LENGTH 256		/* Bug */

/*
 *  Gopher entity types.
 */
#define GOPHER_TEXT		'0'
#define GOPHER_MENU		'1'
#define GOPHER_CSO		'2'
#define GOPHER_ERROR		'3'
#define GOPHER_MACBINHEX	'4'
#define GOPHER_PCBINARY		'5'
#define GOPHER_UUENCODED	'6'
#define GOPHER_INDEX		'7'
#define GOPHER_TELNET		'8'
#define GOPHER_BINARY		'9'
#define GOPHER_GIF		'g'
#define GOPHER_HTML		'h'	/* HTML */
#define GOPHER_CHTML		'H'	/* HTML */
#define GOPHER_SOUND		's'
#define GOPHER_WWW		'w'	/* W3 address */
#define GOPHER_IMAGE		'I'
#define GOPHER_TN3270		'T'
#define GOPHER_INFO		'i'
#define GOPHER_DUPLICATE	'+'
#define GOPHER_PLUS_IMAGE	':'	/* Addition from Gopher Plus */
#define GOPHER_PLUS_MOVIE	';'
#define GOPHER_PLUS_SOUND	'<'
#define GOPHER_PLUS_PDF		'P'

#include <HTFormat.h>

/*
 *  Hypertext object building machinery.
 */
#include <HTML.h>

#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)

#define NEXT_CHAR HTGetCharacter()

/*
 *  Module-wide variables.
 */
static int s;			/* Socket for gopher or CSO host */

struct _HTStructured {
    const HTStructuredClass *isa;	/* For gopher streams */
    /* ... */
};

static HTStructured *target;	/* the new gopher hypertext */
static HTStructuredClass targetClass;	/* Its action routines */

struct _HTStream {
    HTStreamClass *isa;		/* For form-based CSO  gateway - FM */
};

typedef struct _CSOfield_info {	/* For form-based CSO gateway - FM */
    struct _CSOfield_info *next;
    char *name;
    char *attributes;
    char *description;
    int id;
    int lookup;
    int indexed;
    int url;
    int max_size;
    int defreturn;
    int explicit_return;
    int reserved;
    int gpublic;
    char name_buf[16];		/* Avoid malloc if we can */
    char desc_buf[32];		/* Avoid malloc if we can */
    char attr_buf[80];		/* Avoid malloc if we can */
} CSOfield_info;

static CSOfield_info *CSOfields = NULL;		/* For form-based CSO gateway - FM */

typedef struct _CSOformgen_context {	/* For form-based CSO gateway - FM */
    const char *host;
    const char *seek;
    CSOfield_info *fld;
    int port;
    int cur_line;
    int cur_off;
    int rep_line;
    int rep_off;
    int public_override;
    int field_select;
} CSOformgen_context;

/*	Matrix of allowed characters in filenames
 *	=========================================
 */
static BOOL acceptable[256];
static BOOL acceptable_inited = NO;

static void init_acceptable(void)
{
    unsigned int i;
    const char *good =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";

    for (i = 0; i < 256; i++)
	acceptable[i] = NO;
    for (; *good; good++)
	acceptable[(unsigned int) *good] = YES;
    acceptable_inited = YES;
}

/*	Decode one hex character
 *	========================
 */
static const char hex[17] = "0123456789abcdef";

static char from_hex(int c)
{
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
}

/*	Paste in an Anchor
 *	==================
 *
 *	The title of the destination is set, as there is no way
 *	of knowing what the title is when we arrive.
 *
 * On entry,
 *	HT	is in append mode.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext refernce address 0 terminated.
 */
BOOLEAN HT_Is_Gopher_URL = FALSE;

static void write_anchor(const char *text, const char *addr)
{
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];

    int i;

    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = 0;
    present[HTML_A_HREF] = YES;
    ((const char **) value)[HTML_A_HREF] = addr;
    present[HTML_A_TITLE] = YES;
    ((const char **) value)[HTML_A_TITLE] = text;

    CTRACE((tfp, "HTGopher: adding URL: %s\n", addr));

    HT_Is_Gopher_URL = TRUE;	/* tell HTML.c that this is a Gopher URL */
    (*targetClass.start_element) (target, HTML_A, present,
				  (const char **) value, -1, 0);

    PUTS(text);
    END(HTML_A);
}

/*	Parse a Gopher Menu document
 *	============================
 */
static void parse_menu(const char *arg GCC_UNUSED,
		       HTParentAnchor *anAnchor)
{
    char gtype;
    int ich;
    char line[BIG];
    char *name = NULL, *selector = NULL;	/* Gopher menu fields */
    char *host = NULL;
    char *port;
    char *p = line;
    const char *title;
    int bytes = 0;
    int BytesReported = 0;
    char buffer[128];

#define TAB		'\t'
#define HEX_ESCAPE	'%'

    START(HTML_HTML);
    PUTC('\n');
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_MENU_TITLE);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');

    START(HTML_BODY);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_MENU_TITLE);
    END(HTML_H1);
    PUTC('\n');
    START(HTML_PRE);
    PUTC('\n');			/* newline after HTML_PRE forces split-line */
    while ((ich = NEXT_CHAR) != EOF) {

	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
	    goto end_html;
	}

	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;

	} else {
	    *p++ = '\0';	/* Terminate line */
	    bytes += (int) (p - line);	/* add size */
	    p = line;		/* Scan it to parse it */
	    port = 0;		/* Flag "not parsed" */
	    CTRACE((tfp, "HTGopher: Menu item: %s\n", line));
	    gtype = *p++;

	    if (bytes > BytesReported + 1024) {
		sprintf(buffer, TRANSFERRED_X_BYTES, bytes);
		HTProgress(buffer);
		BytesReported = bytes;
	    }

	    /* Break on line with a dot by itself */
	    if ((gtype == '.') && ((*p == '\r') || (*p == 0)))
		break;

	    if (gtype && *p) {
		name = p;
		selector = StrChr(name, TAB);
		if (selector) {
		    *selector++ = '\0';		/* Terminate name */
		    /*
		     * Gopher+ Type=0+ objects can be binary, and will
		     * have 9 or 5 beginning their selector.  Make sure
		     * we don't trash the terminal by treating them as
		     * text. - FM
		     */
		    if (gtype == GOPHER_TEXT && (*selector == GOPHER_BINARY ||
						 *selector == GOPHER_PCBINARY))
			gtype = *selector;
		    host = StrChr(selector, TAB);
		    if (host) {
			*host++ = '\0';		/* Terminate selector */
			port = StrChr(host, TAB);
			if (port) {
			    char *junk;

			    port[0] = ':';	/* delimit host a la W3 */
			    junk = StrChr(port, TAB);
			    if (junk)
				*junk = '\0';	/* Chop port */
			    if ((port[1] == '0') && (!port[2]))
				port[0] = '\0';		/* 0 means none */
			}	/* no port */
		    }		/* host ok */
		}		/* selector ok */
	    }
	    /* gtype and name ok */
	    /* Nameless files are a separator line */
	    if (name != NULL && gtype == GOPHER_TEXT) {
		int i = (int) strlen(name) - 1;

		while (name[i] == ' ' && i >= 0)
		    name[i--] = '\0';
		if (i < 0)
		    gtype = GOPHER_INFO;
	    }

	    if (gtype == GOPHER_WWW) {	/* Gopher pointer to W3 */
		PUTS("(HTML) ");
		write_anchor(name, selector);

	    } else if (gtype == GOPHER_INFO) {
		/* Information or separator line */
		PUTS("       ");
		PUTS(name);

	    } else if (port) {	/* Other types need port */
		char *address = 0;
		const char *format = *selector ? "%s//%s@@%s/" : "%s//%s/";

		if (gtype == GOPHER_TELNET) {
		    PUTS(" (TEL) ");
		    HTSprintf0(&address, format, STR_TELNET_URL, selector, host);
		} else if (gtype == GOPHER_TN3270) {
		    PUTS("(3270) ");
		    HTSprintf0(&address, format, STR_TN3270_URL, selector, host);
		} else {	/* If parsed ok */
		    char *r;

		    switch (gtype) {
		    case GOPHER_TEXT:
			PUTS("(FILE) ");
			break;
		    case GOPHER_MENU:
			PUTS(" (DIR) ");
			break;
		    case GOPHER_CSO:
			PUTS(" (CSO) ");
			break;
		    case GOPHER_PCBINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_UUENCODED:
			PUTS(" (UUE) ");
			break;
		    case GOPHER_INDEX:
			PUTS("  (?)  ");
			break;
		    case GOPHER_BINARY:
			PUTS(" (BIN) ");
			break;
		    case GOPHER_GIF:
		    case GOPHER_IMAGE:
		    case GOPHER_PLUS_IMAGE:
			PUTS(" (IMG) ");
			break;
		    case GOPHER_SOUND:
		    case GOPHER_PLUS_SOUND:
			PUTS(" (SND) ");
			break;
		    case GOPHER_MACBINHEX:
			PUTS(" (HQX) ");
			break;
		    case GOPHER_HTML:
		    case GOPHER_CHTML:
			PUTS("(HTML) ");
			break;
		    case 'm':
			PUTS("(MIME) ");
			break;
		    case GOPHER_PLUS_MOVIE:
			PUTS(" (MOV) ");
			break;
		    case GOPHER_PLUS_PDF:
			PUTS(" (PDF) ");
			break;
		    default:
			PUTS("(UNKN) ");
			break;
		    }

		    HTSprintf0(&address, "//%s/%c", host, gtype);

		    for (r = selector; *r; r++) {	/* Encode selector string */
			if (acceptable[UCH(*r)]) {
			    HTSprintf(&address, "%c", *r);
			} else {
			    HTSprintf(&address, "%c%c%c",
				      HEX_ESCAPE,	/* Means hex coming */
				      hex[(TOASCII(*r)) >> 4],
				      hex[(TOASCII(*r)) & 15]);
			}
		    }
		}
		/* Error response from Gopher doesn't deserve to
		   be a hyperlink. */
		if (strcmp(address, "gopher://error.host:1/0"))
		    write_anchor(name, address);
		else
		    PUTS(name);
		FREE(address);
	    } else {		/* parse error */
		CTRACE((tfp, "HTGopher: Bad menu item.\n"));
		PUTS(line);

	    }			/* parse error */

	    PUTC('\n');
	    p = line;		/* Start again at beginning of line */

	}			/* if end of line */

    }				/* Loop over characters */

  end_html:
    END(HTML_PRE);
    PUTC('\n');
    END(HTML_BODY);
    PUTC('\n');
    END(HTML_HTML);
    PUTC('\n');
    FREE_TARGET;

    return;
}

/*	Parse a Gopher CSO document from an ISINDEX query.
 *	==================================================
 *
 *   Accepts an open socket to a CSO server waiting to send us
 *   data and puts it on the screen in a reasonable manner.
 *
 *   Perhaps this data can be automatically linked to some
 *   other source as well???
 *
 *  Taken from hacking by Lou Montulli@@ukanaix.cc.ukans.edu
 *  on XMosaic-1.1, and put on libwww 2.11 by Arthur Secret,
 *  secret@@dxcern.cern.ch .
 */
static void parse_cso(const char *arg,
		      HTParentAnchor *anAnchor)
{
    int ich;
    char line[BIG];
    char *p = line;
    char *first_colon, *second_colon, last_char = '\0';
    const char *title;

    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_CSO_SEARCH_RESULTS);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else {
	PUTS(arg);
	PUTS(GOPHER_SEARCH_RESULTS);
    }
    END(HTML_H1);
    PUTC('\n');
    START(HTML_PRE);

    /*
     * Start grabbing chars from the network.
     */
    while ((ich = NEXT_CHAR) != EOF) {
	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1])
		p++;
	} else {
	    *p = '\0';		/* Terminate line */
	    p = line;		/* Scan it to parse it */
	    /*
	     * OK we now have a line in 'p'.  Lets parse it and print it.
	     */

	    /*
	     * Break on line that begins with a 2.  It's the end of data.
	     */
	    if (*p == '2')
		break;

	    /*
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
	    if (*p == '5') {
		START(HTML_H2);
		PUTS(p + 4);
		END(HTML_H2);
		break;
	    }

	    if (*p == '-') {
		/*
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 * Find the second colon and check the digit to the left of it
		 * to see if they are diferent.  If they are then a different
		 * person is starting.  Make this line an <h2>.
		 */

		/*
		 * Find the second_colon.
		 */
		second_colon = NULL;
		first_colon = StrChr(p, ':');
		if (first_colon != NULL) {
		    second_colon = StrChr(first_colon + 1, ':');
		}

		if (second_colon != NULL) {	/* error check */

		    if (*(second_colon - 1) != last_char)
			/* print seperator */
		    {
			END(HTML_PRE);
			START(HTML_H2);
		    }

		    /*
		     * Right now the record appears with the alias (first line)
		     * as the header and the rest as <pre> text.
		     *
		     * It might look better with the name as the header and the
		     * rest as a <ul> with <li> tags.  I'm not sure whether the
		     * name field comes in any special order or if its even
		     * required in a record, so for now the first line is the
		     * header no matter what it is (it's almost always the
		     * alias).
		     *
		     * A <dl> with the first line as the <DT> and the rest as
		     * some form of <DD> might good also?
		     */

		    /*
		     * Print data.
		     */
		    PUTS(second_colon + 1);
		    PUTC('\n');

		    if (*(second_colon - 1) != last_char)
			/* end seperator */
		    {
			END(HTML_H2);
			START(HTML_PRE);
		    }

		    /*
		     * Save the char before the second colon for comparison on
		     * the next pass.
		     */
		    last_char = *(second_colon - 1);

		}		/* end if second_colon */
	    }			/* end if *p == '-' */
	}			/* if end of line */

    }				/* Loop over characters */

    /* end the text block */
    PUTC('\n');
    END(HTML_PRE);
    PUTC('\n');
    FREE_TARGET;

    return;			/* all done */
}				/* end of procedure */

/*	Display a Gopher CSO ISINDEX cover page.
 *	========================================
 */
static void display_cso(const char *arg,
			HTParentAnchor *anAnchor)
{
    const char *title;

    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_CSO_INDEX);
    END(HTML_TITLE);
    PUTC('\n');
    START(HTML_ISINDEX);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else {
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
    }
    END(HTML_H1);
    PUTS(GOPHER_CSO_INDEX_SUBTITLE);
    START(HTML_P);
    PUTS(GOPHER_CSO_SOLICIT_KEYWORDS);
    START(HTML_P);
    PUTS(SEGMENT_KEYWORDS_WILL);
    PUTS(SEGMENT_PERSONS_DB_NAME);

    if (!HTAnchor_title(anAnchor))
	HTAnchor_setTitle(anAnchor, arg);

    FREE_TARGET;
    return;
}

/*	Display a Gopher Index document.
 *	================================
 */
static void display_index(const char *arg,
			  HTParentAnchor *anAnchor)
{
    const char *title;

    START(HTML_HEAD);
    PUTC('\n');
    PUTC('\n');
    START(HTML_TITLE);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else
	PUTS(GOPHER_INDEX_TITLE);
    END(HTML_TITLE);
    PUTC('\n');
    START(HTML_ISINDEX);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    if ((title = HTAnchor_title(anAnchor)))
	PUTS(title);
    else {
	PUTS(arg);
	PUTS(INDEX_SEGMENT);
    }
    END(HTML_H1);
    PUTS(GOPHER_INDEX_SUBTITLE);
    START(HTML_P);
    PUTS(GOPHER_SOLICIT_KEYWORDS);

    if (!HTAnchor_title(anAnchor))
	HTAnchor_setTitle(anAnchor, arg);

    FREE_TARGET;
    return;
}

/*	De-escape a selector into a command.
 *	====================================
 *
 *	The % hex escapes are converted. Otheriwse, the string is copied.
 */
static void de_escape(char *command, const char *selector)
{
    const char *p = selector;
    char *q;

    if (command == NULL)
	outofmem(__FILE__, "HTLoadGopher");

    assert(command != NULL);

    q = command;
    while (*p) {		/* Decode hex */
	if (*p == HEX_ESCAPE) {
	    char c;
	    unsigned int b;

	    p++;
	    c = *p++;
	    b = UCH(from_hex(c));
	    c = *p++;
	    if (!c)
		break;		/* Odd number of chars! */
	    *q++ = (char) FROMASCII((b << 4) + UCH(from_hex(c)));
	} else {
	    *q++ = *p++;	/* Record */
	}
    }
    *q = '\0';			/* Terminate command */
}

/*	Free the CSOfields structures. - FM
 *	===================================
 */
static void free_CSOfields(void)
{
    CSOfield_info *cur = CSOfields;
    CSOfield_info *prev;

    while (cur) {
	if (cur->name != cur->name_buf)
	    FREE(cur->name);
	if (cur->attributes != cur->attr_buf)
	    FREE(cur->attributes);
	if (cur->description != cur->desc_buf)
	    FREE(cur->description);
	prev = cur;
	cur = cur->next;
	FREE(prev);
    }

    return;
}

/*	Interpret CSO/PH form template keys. - FM
 *	=========================================
 */
static void interpret_cso_key(const char *key,
			      char *buf,
			      size_t bufsize,
			      int *length,
			      CSOformgen_context * ctx,
			      HTStream *Target)
{
    CSOfield_info *fld;

    if ((fld = ctx->fld) != 0) {
	/*
	 * Most substitutions only recognized inside of loops.
	 */
	int error = 0;

	if (0 == StrNCmp(key, "$(FID)", 6)) {
	    sprintf(buf, "%d", fld->id);
	} else if (0 == StrNCmp(key, "$(FDESC)", 8)) {
	    sprintf(buf, "%.2046s", fld->description);
	} else if (0 == StrNCmp(key, "$(FDEF)", 7)) {
	    strcpy(buf, fld->defreturn ? " checked" : "");
	} else if (0 == StrNCmp(key, "$(FNDX)", 7)) {
	    strcpy(buf, fld->indexed ? "*" : "");
	} else if (0 == StrNCmp(key, "$(FSIZE)", 8)) {
	    sprintf(buf, " size=%d maxlength=%d",
		    fld->max_size > 55 ? 55 : fld->max_size,
		    fld->max_size);
	} else if (0 == StrNCmp(key, "$(FSIZE2)", 9)) {
	    sprintf(buf, " maxlength=%d", fld->max_size);
	} else {
	    error = 1;
	}
	if (!error) {
	    *length = (int) strlen(buf);
	    return;
	}
    }
    buf[0] = '\0';
    if (0 == StrNCmp(key, "$(NEXTFLD)", 10)) {
	if (!ctx->fld)
	    fld = CSOfields;
	else
	    fld = ctx->fld->next;
	switch (ctx->field_select) {
	case 0:
	    /*
	     * 'Query' fields, public and lookup attributes.
	     */
	    for (; fld; fld = fld->next)
		if (fld->gpublic && (fld->lookup == 1))
		    break;
	    break;
	case 1:
	    /*
	     * 'Query' fields, accept lookup attribute.
	     */
	    for (; fld; fld = fld->next)
		if (fld->lookup == 1)
		    break;
	    break;
	case 2:
	    /*
	     * 'Return' fields, public only.
	     */
	    for (; fld; fld = fld->next)
		if (fld->gpublic)
		    break;
	    break;
	case 3:
	    /*
	     * All fields.
	     */
	    break;
	}
	if (fld) {
	    ctx->cur_line = ctx->rep_line;
	    ctx->cur_off = ctx->rep_off;
	}
	ctx->fld = fld;

    } else if ((0 == StrNCmp(key, "$(QFIELDS)", 10)) ||
	       (0 == StrNCmp(key, "$(RFIELDS)", 10))) {
	/*
	 * Begin iteration sequence.
	 */
	ctx->rep_line = ctx->cur_line;
	ctx->rep_off = ctx->cur_off;
	ctx->fld = (CSOfield_info *) 0;
	ctx->seek = "$(NEXTFLD)";
	ctx->field_select = (key[2] == 'Q') ? 0 : 2;
	if (ctx->public_override)
	    ctx->field_select++;

    } else if (0 == StrNCmp(key, "$(NAMEFLD)", 10)) {
	/*
	 * Special, locate name field.  Flag lookup so QFIELDS will skip it.
	 */
	for (fld = CSOfields; fld; fld = fld->next)
	    if (strcmp(fld->name, "name") == 0 ||
		strcmp(fld->name, "Name") == 0) {
		if (fld->lookup)
		    fld->lookup = 2;
		break;
	    }
	ctx->fld = fld;
    } else if (0 == StrNCmp(key, "$(HOST)", 7)) {
	strcpy(buf, ctx->host);
    } else if (0 == StrNCmp(key, "$(PORT)", 7)) {
	sprintf(buf, "%d", ctx->port);
    } else {
	/*
	 * No match, dump key to buffer so client sees it for debugging.
	 */
	size_t out = 0;

	while (*key && (*key != ')')) {
	    buf[out++] = (*key++);
	    if (out > bufsize - 2) {
		buf[out] = '\0';
		(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		out = 0;
	    }
	}
	buf[out++] = ')';
	buf[out] = '\0';
    }
    *length = (int) strlen(buf);
    return;
}

/*	Parse the elements in a CSO/PH fields structure. - FM
 *	=====================================================
 */
static int parse_cso_field_info(CSOfield_info *blk)
{
    char *info, *max_spec;

    /*
     * Initialize all fields to default values.
     */
    blk->indexed = blk->lookup = blk->reserved = blk->max_size = blk->url = 0;
    blk->defreturn = blk->explicit_return = blk->gpublic = 0;

    /*
     * Search for keywords in info string and set values.  Attributes are
     * converted to all lower-case for comparison.
     */
    info = blk->attributes;
    LYLowerCase(info);
    if (strstr(info, "indexed "))
	blk->indexed = 1;
    if (strstr(info, "default "))
	blk->defreturn = 1;
    if (strstr(info, "public "))
	blk->gpublic = 1;
    if (strstr(info, "lookup "))
	blk->lookup = 1;
    if (strstr(info, "url ")) {
	blk->url = 1;
	blk->defreturn = 1;
    }
    max_spec = strstr(info, "max ");
    if (max_spec) {
	sscanf(&max_spec[4], "%d", &blk->max_size);
    } else {
	blk->max_size = 32;
    }

    return 0;
}

/*	Parse a reply from a CSO/PH fields request. - FM
 *	================================================
 */
static int parse_cso_fields(char *buf,
			    size_t size)
{
    int ich;
    char *p = buf;
    int i, code = 0, prev_code;
    size_t alen;
    char *indx, *name;
    CSOfield_info *last, *newf;

    last = CSOfields = (CSOfield_info *) 0;
    prev_code = -2555;
    buf[0] = '\0';

    /*
     * Start grabbing chars from the network.
     */
    while ((ich = NEXT_CHAR) != EOF) {
	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    free_CSOfields();
	    buf[0] = '\0';
	    return HT_INTERRUPTED;
	}

	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in buffer */
	    if (p < &buf[size - 1]) {
		p++;
	    }
	} else {
	    *p = '\0';		/* Terminate line */
	    p = buf;		/* Scan it to parse it */

	    /* OK we now have a line in 'p' lets parse it.
	     */

	    /*
	     * Break on line that begins with a 2.  It's the end of data.
	     */
	    if (*p == '2')
		break;

	    /*
	     * Lines beginning with 5 are errors.  Print them and quit.
	     */
	    if (*p == '5') {
		strcpy(buf, p);
		return 5;
	    }

	    if (*p == '-') {
		/*
		 * Data lines look like -200:#:
		 * where # is the search result number and can be multiple
		 * digits (infinite?).
		 */

		/*
		 * Check status, ignore any non-success.
		 */
		if (p[1] != '2')
		    continue;

		/*
		 * Parse fields within returned line into status, ndx, name,
		 * data.
		 */
		indx = NULL;
		name = NULL;
		for (i = 0; p[i]; i++) {
		    if (p[i] == ':') {
			p[i] = '\0';
			if (!indx) {
			    indx = (char *) &p[i + 1];
			    code = atoi(indx);
			} else if (!name) {
			    name = (char *) &p[i + 1];
			} else {
			    i++;
			    break;
			}
		    }
		}
		/*
		 * Add data to field structure.
		 */
		if (name) {
		    if (code == prev_code) {
			/*
			 * Remaining data are description.  Save in current
			 * info block.
			 */
			if (last != NULL) {
			    alen = strlen((char *) &p[i]) + 1;
			    if (alen > sizeof(last->desc_buf)) {
				if (last->description != last->desc_buf)
				    FREE(last->description);
				if (!(last->description = (char *) malloc(alen))) {
				    outofmem(__FILE__, "HTLoadCSO");
				}
			    }
			    strcpy(last->description, (char *) &p[i]);
			}
		    } else {
			/*
			 * Initialize new block, append to end of list to
			 * preserve order.
			 */
			newf = typecalloc(CSOfield_info);

			if (!newf) {
			    outofmem(__FILE__, "HTLoadCSO");
			}

			assert(newf != NULL);

			if (last)
			    last->next = newf;
			else
			    CSOfields = newf;
			last = newf;

			newf->next = (CSOfield_info *) 0;
			newf->name = newf->name_buf;
			alen = strlen(name) + 1;
			if (alen > sizeof(newf->name_buf)) {
			    if (!(newf->name = (char *) malloc(alen))) {
				outofmem(__FILE__, "HTLoadCSO");
			    }
			}
			strcpy(newf->name, name);

			newf->attributes = newf->attr_buf;
			alen = strlen((char *) &p[i]) + 2;
			if (alen > sizeof(newf->attr_buf)) {
			    if (!(newf->attributes = (char *) malloc(alen))) {
				outofmem(__FILE__, "HTLoadCSO");
			    }
			}
			strcpy(newf->attributes, (char *) &p[i]);
			strcpy((char *) &newf->attributes[alen - 2], " ");
			newf->description = newf->desc_buf;
			newf->desc_buf[0] = '\0';
			newf->id = atoi(indx);
			/*
			 * Scan for keywords.
			 */
			parse_cso_field_info(newf);
		    }
		    prev_code = code;
		} else
		    break;
	    }			/* end if *p == '-' */
	}			/* if end of line */

    }				/* Loop over characters */

    /* end the text block */

    if (buf[0] == '\0') {
	return -1;		/* no response */
    }
    buf[0] = '\0';
    return 0;			/* all done */
}				/* end of procedure */

/*	Generate a form for submitting CSO/PH searches. - FM
 *	====================================================
 */
static int generate_cso_form(char *host,
			     int port,
			     char *buf,
			     size_t bufsize,
			     HTStream *Target)
{
    int i, j, length;
    size_t out;
    int full_flag = 1;
    const char *key;
    const char *line;
    CSOformgen_context ctx;
    static const char *ctemplate[] =
    {
	"<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
	"<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
	"To search the database for a name, fill in one or more of the fields",
	"in the form below and activate the 'Submit query' button.  At least",
	"one of the entered fields must be flagged as indexed.",
	"<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
	"[ <input type=\"submit\" value=\"Submit query\"> | ",
	"<input type=\"reset\" value=\"Clear fields\"> ]",
	"<P><DL>",
	"   <DT>Search parameters (* indicates indexed field):",
	"   <DD>",
	"$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
	"    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
	"$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
	"    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
	"    </DL>",
	"   </DL>\n<P><DL>",
	"   <DT>Output format:",
	"   <DD>Returned data option: <select name=\"return\">",
	"    <option>default<option selected>all<option>selected</select><BR>",
	"$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
	"$(NEXTFLD)    ",
	"   </DL></FORM><HR>\n</BODY>\n</HTML>",
	(char *) 0
    };

    memset(&ctx, 0, sizeof(ctx));
    ctx.host = host;
    ctx.seek = (char *) 0;
    ctx.port = port;
    ctx.fld = (CSOfield_info *) 0;
    ctx.public_override = full_flag;
    /*
     * Parse the strings in the template array to produce HTML document to send
     * to client.  First line is skipped for 'full' lists.
     */
    out = 0;
    buf[out] = '\0';
    for (i = 0; ctemplate[i]; i++) {
	/*
	 * Search the current string for substitution, flagged by $(
	 */
	for (line = ctemplate[i], j = 0; line[j]; j++) {
	    if ((line[j] == '$') && (line[j + 1] == '(')) {
		/*
		 * Command detected, flush output buffer and find closing ')'
		 * that delimits the command.
		 */
		buf[out] = '\0';
		if (out > 0)
		    (*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		for (key = &line[j]; line[j + 1] && (line[j] != ')'); j++) {
		    ;
		}
		/*
		 * Save context, interpet command and restore updated context.
		 */
		ctx.cur_line = i;
		ctx.cur_off = j;
		interpret_cso_key(key, buf, bufsize, &length, &ctx, Target);
		i = ctx.cur_line;
		j = ctx.cur_off;
		line = ctemplate[i];
		out = (size_t) length;

		if (ctx.seek) {
		    /*
		     * Command wants us to skip (forward) to indicated token. 
		     * Start at current position.
		     */
		    size_t slen = strlen(ctx.seek);

		    for (; ctemplate[i]; i++) {
			for (line = ctemplate[i]; line[j]; j++) {
			    if (line[j] == '$')
				if (0 == StrNCmp(ctx.seek, &line[j], slen)) {
				    if (j == 0)
					j = (int) strlen(ctemplate[--i]) - 1;
				    else
					--j;
				    line = ctemplate[i];
				    ctx.seek = (char *) 0;
				    break;
				}
			}
			if (!ctx.seek)
			    break;
			j = 0;
		    }
		    if (ctx.seek) {
			char *temp = 0;

			HTSprintf0(&temp, GOPHER_CSO_SEEK_FAILED, ctx.seek);
			(*Target->isa->put_block) (Target, temp, (int) strlen(temp));
			FREE(temp);
		    }
		}
	    } else {
		/*
		 * Non-command text, add to output buffer.
		 */
		buf[out++] = line[j];
		if (out > (bufsize - 3)) {
		    buf[out] = '\0';
		    (*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    out = 0;
		}
	    }
	}
	buf[out++] = '\n';
	buf[out] = '\0';
    }
    if (out > 0)
	(*Target->isa->put_block) (Target, buf, (int) strlen(buf));

    return 0;
}

/*	Generate a results report for CSO/PH form-based searches. - FM
 *	==============================================================
 */
static int generate_cso_report(HTStream *Target)
{
    int ich;
    char line[BIG];
    char *buf = 0;
    char *p = line, *href = NULL;
    int len, i, prev_ndx, ndx;
    char *rcode, *ndx_str, *fname, *fvalue, *l;
    CSOfield_info *fld;
    BOOL stop = FALSE;

    /*
     * Read lines until non-negative status.
     */
    prev_ndx = -100;
    /*
     * Start grabbing chars from the network.
     */
    while (!stop && (ich = NEXT_CHAR) != EOF) {
	if (interrupted_in_htgetcharacter) {
	    CTRACE((tfp,
		    "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    goto end_CSOreport;
	}

	if ((char) ich != LF) {
	    *p = (char) ich;	/* Put character in line */
	    if (p < &line[BIG - 1]) {
		p++;
	    }
	} else {
	    *p = '\0';		/* Terminate line */
	    /*
	     * OK we now have a line.  Load it as 'p' and parse it.
	     */
	    p = line;
	    if (p[0] != '-' && p[0] != '1') {
		stop = TRUE;
	    }
	    rcode = (p[0] == '-') ? &p[1] : p;
	    ndx_str = fname = NULL;
	    len = (int) strlen(p);
	    for (i = 0; i < len; i++) {
		if (p[i] == ':') {
		    p[i] = '\0';
		    if (!ndx_str) {
			fname = ndx_str = &p[i + 1];
		    } else {
			fname = &p[i + 1];
			break;
		    }
		}
	    }
	    if (ndx_str) {
		ndx = atoi(ndx_str);
		if (prev_ndx != ndx) {
		    if (prev_ndx != -100) {
			HTSprintf0(&buf, "</DL></DL>\n");
			(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    }
		    if (ndx == 0) {
			HTSprintf0(&buf,
				   "<HR><DL><DT>Information/status<DD><DL><DT>\n");
			(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    } else {
			HTSprintf0(&buf,
				   "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
			(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    }
		    prev_ndx = ndx;
		}
	    } else {
		HTSprintf0(&buf, "<DD>%s\n", rcode);
		(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		continue;
	    }
	    if ((*rcode >= '2') && (*rcode <= '5') && (fname != ndx_str)) {
		while (*fname == ' ') {
		    fname++;	/* trim leading spaces */
		}
		for (fvalue = fname; *fvalue; fvalue++) {
		    if (*fvalue == ':') {
			*fvalue++ = '\0';
			i = (int) strlen(fname) - 1;
			while (i >= 0 && fname[i] == ' ') {
			    fname[i--] = '\0';	/* trim trailing */
			}
			break;
		    }
		}
		if (fvalue) {
		    while (*fvalue == ' ') {
			fvalue++;	/* trim leading spaces */
		    }
		}
		if (*fname) {
		    for (fld = CSOfields; fld; fld = fld->next) {
			if (!strcmp(fld->name, fname)) {
			    if (fld->description) {
				fname = fld->description;
			    }
			    break;
			}
		    }
		    if (fld && fld->url) {
			HTSprintf0(&buf,
				   "<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",
				   fname, fvalue, fvalue);
			(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    } else {
			HTSprintf0(&buf, "<DT><I>%s</I><DD>", fname);
			(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
			buf[0] = '\0';
			l = fvalue;
			while (*l) {
			    if (*l == '<') {
				StrAllocCat(buf, "&lt;");
				l++;
			    } else if (*l == '>') {
				StrAllocCat(buf, "&gt;");
				l++;
			    } else if (StrNCmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				       StrNCmp(l, "snews://", 8) &&
				       StrNCmp(l, "nntp://", 7) &&
				       StrNCmp(l, "snewspost:", 10) &&
				       StrNCmp(l, "snewsreply:", 11) &&
				       StrNCmp(l, "newspost:", 9) &&
				       StrNCmp(l, "newsreply:", 10) &&
				       StrNCmp(l, "ftp://", 6) &&
				       StrNCmp(l, "file:/", 6) &&
				       StrNCmp(l, "finger://", 9) &&
				       StrNCmp(l, "http://", 7) &&
				       StrNCmp(l, "https://", 8) &&
				       StrNCmp(l, "wais://", 7) &&
				       StrNCmp(l, STR_MAILTO_URL,
					       LEN_MAILTO_URL) &&
				       StrNCmp(l, "cso://", 6) &&
				       StrNCmp(l, "gopher://", 9)) {
				HTSprintf(&buf, "%c", *l++);
			    } else {
				StrAllocCat(buf, "<a href=\"");
				StrAllocCopy(href, l);
				StrAllocCat(buf, strtok(href, " \r\n\t,>)\""));
				StrAllocCat(buf, "\">");
				while (*l && !StrChr(" \r\n\t,>)\"", *l)) {
				    HTSprintf(&buf, "%c", *l++);
				}
				StrAllocCat(buf, "</a>");
				FREE(href);
			    }
			}
			StrAllocCat(buf, "\n");
			(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    }
		} else {
		    HTSprintf0(&buf, "<DD>");
		    (*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		    buf[0] = '\0';
		    l = fvalue;
		    while (*l) {
			if (*l == '<') {
			    StrAllocCat(buf, "&lt;");
			    l++;
			} else if (*l == '>') {
			    StrAllocCat(buf, "&gt;");
			    l++;
			} else if (StrNCmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				   StrNCmp(l, "snews://", 8) &&
				   StrNCmp(l, "nntp://", 7) &&
				   StrNCmp(l, "snewspost:", 10) &&
				   StrNCmp(l, "snewsreply:", 11) &&
				   StrNCmp(l, "newspost:", 9) &&
				   StrNCmp(l, "newsreply:", 10) &&
				   StrNCmp(l, "ftp://", 6) &&
				   StrNCmp(l, "file:/", 6) &&
				   StrNCmp(l, "finger://", 9) &&
				   StrNCmp(l, "http://", 7) &&
				   StrNCmp(l, "https://", 8) &&
				   StrNCmp(l, "wais://", 7) &&
				   StrNCmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
				   StrNCmp(l, "cso://", 6) &&
				   StrNCmp(l, "gopher://", 9)) {
			    HTSprintf(&buf, "%c", *l++);
			} else {
			    StrAllocCat(buf, "<a href=\"");
			    StrAllocCopy(href, l);
			    StrAllocCat(buf, strtok(href, " \r\n\t,>)\""));
			    StrAllocCat(buf, "\">");
			    while (*l && !StrChr(" \r\n\t,>)\"", *l)) {
				HTSprintf(&buf, "%c", *l++);
			    }
			    StrAllocCat(buf, "</a>");
			    FREE(href);
			}
		    }
		    StrAllocCat(buf, "\n");
		    (*Target->isa->put_block) (Target, buf, (int) strlen(buf));
		}
	    } else {
		HTSprintf0(&buf, "<DD>%s\n", fname);
		(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
	    }
	}
    }
  end_CSOreport:
    if (prev_ndx != -100) {
	HTSprintf0(&buf, "</DL></DL>\n");
	(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
    }
    FREE(buf);
    return 0;
}

/*	CSO/PH form-based search gateway - FM			HTLoadCSO
 *	=====================================
 */
static int HTLoadCSO(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
{
    static const char end_form[] = "</BODY>\n</HTML>\n";
    char *host, *cp, *data;
    int port = CSO_PORT;
    int status;			/* tcp return */
    bstring *command = NULL;
    bstring *content = NULL;
    int len, i, j, start, finish, flen, ndx;
    int return_type, has_indexed;
    CSOfield_info *fld;
    char buf[2048];
    HTFormat format_in = WWW_HTML;
    HTStream *Target = NULL;

    if (!acceptable_inited)
	init_acceptable();

    if (!arg)
	return -3;		/* Bad if no name sepcified     */
    if (!*arg)
	return -2;		/* Bad if name had zero length  */
    CTRACE((tfp, "HTLoadCSO: Looking for %s\n", arg));

    /*
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "cso", CSO_PORT, &s);
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp,
		"HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	return HT_NOT_LOADED;
    }
    if (status < 0) {
	CTRACE((tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		arg));
	return HTInetStatus("connect");
    }

    HTInitInput(s);		/* Set up input buffering */

    HTBprintf(&command, "fields%c%c", CR, LF);
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Connected, writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    _HTProgress(GOPHER_SENDING_CSO_REQUEST);
    status = (int) NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
    if (status < 0) {
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
	return HTInetStatus("send");
    }
    _HTProgress(GOPHER_SENT_CSO_REQUEST);

    /*
     * Now read the data from the socket.
     */
    status = parse_cso_fields(buf, sizeof(buf));
    if (status) {
	NETCLOSE(s);
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	} else if (buf[0] != '\0') {
	    HTAlert(buf);
	} else {
	    HTAlert(FAILED_NO_RESPONSE);
	}
	return HT_NOT_LOADED;
    }
    Target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);
    if (!Target || Target == NULL) {
	char *temp = 0;

	HTSprintf0(&temp, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(temp);
	FREE(temp);
	NETCLOSE(s);
	return HT_NOT_LOADED;
    }
    host = HTParse(arg, "", PARSE_HOST);
    if ((cp = HTParsePort(host, &port)) != NULL) {
	if (port == CSO_PORT) {
	    *cp = '\0';
	}
    }
    anAnchor->safe = TRUE;
    if (isBEmpty(anAnchor->post_data)) {
	generate_cso_form(host, port, buf, sizeof(buf), Target);
	(*Target->isa->_free) (Target);
	FREE(host);
	NETCLOSE(s);
	free_CSOfields();
	return HT_LOADED;
    }

    HTBprintf(&command,
	      "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
	      host);
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
    BStrFree(command);
    FREE(host);

    BStrCopy(content, anAnchor->post_data);
    assert(content != NULL);

    if (BStrData(content)[BStrLen(content) - 1] != '&')
	BStrCat0(content, "&");

    data = BStrData(content);
    len = BStrLen(content);
    for (i = 0; i < len; i++) {
	if (data[i] == '+') {
	    data[i] = ' ';
	}
    }

    data = BStrData(content);
    HTUnEscape(data);		/* FIXME: could it have embedded null? */
    len = BStrLen(content);

    return_type = 0;
    has_indexed = 0;
    start = 0;
    for (i = 0; i < len; i++) {
	if (!data[i] || data[i] == '&') {
	    /*
	     * Value parsed.  Unescape characters and look for first '=' to
	     * delimit field name from value.
	     */
	    flen = i - start;
	    finish = start + flen;
	    data[finish] = '\0';
	    for (j = start; j < finish; j++) {
		if (data[j] == '=') {
		    /*
		     * data[start..j-1] is field name,
		     * [j+1..finish-1] is value.
		     */
		    if ((data[start + 1] == '_') &&
			((data[start] == 'r') || (data[start] == 'q'))) {
			/*
			 * Decode fields number and lookup field info.
			 */
			sscanf(&data[start + 2], "%d=", &ndx);
			for (fld = CSOfields; fld; fld = fld->next) {
			    if (ndx == fld->id) {
				if ((j + 1) >= finish)
				    break;	/* ignore nulls */
				if (data[start] == 'q') {
				    /*
				     * Append field to query line.
				     */
				    if (fld->lookup) {
					if (fld->indexed)
					    has_indexed = 1;
					if (isBEmpty(command)) {
					    BStrCopy0(command, "query ");
					} else {
					    BStrCat0(command, " ");
					}
					HTBprintf(&command, "%s=\"%s\"",
						  fld->name, &data[j + 1]);
				    } else {
					strcpy(buf,
					       "Warning: non-lookup field ignored<BR>\n");
					(*Target->isa->put_block) (Target,
								   buf,
								   (int)
								   strlen(buf));
				    }
				} else if (data[start] == 'r') {
				    fld->explicit_return = 1;
				}
				break;
			    }
			}
		    } else if (!StrNCmp(&data[start], "return=", 7)) {
			if (!strcmp(&data[start + 7], "all")) {
			    return_type = 1;
			} else if (!strcmp(&data[start + 7], "selected")) {
			    return_type = 2;
			}
		    }
		}
	    }
	    start = i + 1;
	}
    }
    BStrFree(content);
    if (isBEmpty(command) || !has_indexed) {
	NETCLOSE(s);
	strcpy(buf,
	       "<EM>Error:</EM> At least one indexed field value must be specified!\n");
	(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
	strcpy(buf, "</BODY>\n</HTML>\n");
	(*Target->isa->put_block) (Target, buf, (int) strlen(buf));
	(*Target->isa->_free) (Target);
	free_CSOfields();
	return HT_LOADED;
    }
    /*
     * Append return fields.
     */
    if (return_type == 1) {
	BStrCat0(command, " return all");
    } else if (return_type == 2) {
	BStrCat0(command, " return");
	for (fld = CSOfields; fld; fld = fld->next) {
	    if (fld->explicit_return) {
		HTBprintf(&command, " %s", fld->name);
	    }
	}
    }
    HTBprintf(&command, "%c%c", CR, LF);
    strcpy(buf, "<H2>\n<EM>CSO/PH command:</EM> ");
    (*Target->isa->put_block) (Target, buf, (int) strlen(buf));
    (*Target->isa->put_block) (Target, BStrData(command), BStrLen(command));
    strcpy(buf, "</H2>\n");
    (*Target->isa->put_block) (Target, buf, (int) strlen(buf));
    if (TRACE) {
	CTRACE((tfp, "HTLoadCSO: Writing command `"));
	trace_bstring(command);
	CTRACE((tfp, "' to socket %d\n", s));
    }
    status = (int) NETWRITE(s, BStrData(command), BStrLen(command));
    BStrFree(command);
    if (status < 0) {
	CTRACE((tfp, "HTLoadCSO: Unable to send command.\n"));
	free_CSOfields();
	return HTInetStatus("send");
    }
    generate_cso_report(Target);
    NETCLOSE(s);
    (*Target->isa->put_block) (Target, end_form, (int) sizeof(end_form) - 1);
    (*Target->isa->_free) (Target);
    FREE(host);
    free_CSOfields();
    return HT_LOADED;
}

/*	Load by name.						HTLoadGopher
 *	=============
 *
 */
static int HTLoadGopher(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    char *command;		/* The whole command */
    int status;			/* tcp return */
    char gtype;			/* Gopher Node type */
    char *selector;		/* Selector string */

    if (!acceptable_inited)
	init_acceptable();

    if (!arg)
	return -3;		/* Bad if no name sepcified     */
    if (!*arg)
	return -2;		/* Bad if name had zero length  */
    CTRACE((tfp, "HTGopher: Looking for %s\n", arg));

    /*
     * If it's a port 105 GOPHER_CSO gtype with no ISINDEX token ('?'), use the
     * form-based CSO gateway (otherwise, return an ISINDEX cover page or do
     * the ISINDEX search).  - FM
     */
    {
	size_t len;

	if ((len = strlen(arg)) > 5) {
	    if (0 == strcmp((const char *) &arg[len - 6], ":105/2")) {
		/* Use CSO gateway. */
		CTRACE((tfp, "HTGopher: Passing to CSO/PH gateway.\n"));
		return HTLoadCSO(arg, anAnchor, format_out, sink);
	    }
	}
    }

    /*
     * If it's a port 79/0[/...] URL, use the finger gateway.  - FM
     */
    if (strstr(arg, ":79/0") != NULL) {
#ifndef DISABLE_FINGER
	CTRACE((tfp, "HTGopher: Passing to finger gateway.\n"));
	return HTLoadFinger(arg, anAnchor, format_out, sink);
#else /* finger is disabled */
	HTAlert(COULD_NOT_ACCESS_DOCUMENT);
	return HT_NOT_LOADED;
#endif /* DISABLE_FINGER */
    }

    /*
     * Get entity type, and selector string.
     */
    {
	char *p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);

	gtype = '1';		/* Default = menu */
	selector = p1;
	if ((*selector++ == '/') && (*selector)) {	/* Skip first slash */
	    gtype = *selector++;	/* Pick up gtype */
	}
	if (gtype == GOPHER_INDEX) {
	    char *query;

	    /*
	     * Search is allowed.
	     */
	    HTAnchor_setIndex(anAnchor, anAnchor->address);
	    query = StrChr(selector, '?');	/* Look for search string */
	    if (!query || !query[1]) {	/* No search required */
		target = HTML_new(anAnchor, format_out, sink);
		targetClass = *target->isa;
		display_index(arg, anAnchor);	/* Display "cover page" */
		return HT_LOADED;	/* Local function only */
	    }
	    *query++ = '\0';	/* Skip '?'     */
	    command =
		(char *) malloc(strlen(selector) + 1 + strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");

	    assert(command != NULL);

	    de_escape(command, selector);	/* Bug fix TBL 921208 */

	    strcat(command, "\t");

	    {			/* Remove plus signs 921006 */
		char *p;

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
		}
	    }

	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */
	} else if (gtype == GOPHER_CSO) {
	    char *query;

	    /*
	     * Search is allowed.
	     */
	    query = StrChr(selector, '?');	/* Look for search string */
	    if (!query || !query[1]) {	/* No search required */
		target = HTML_new(anAnchor, format_out, sink);
		targetClass = *target->isa;
		display_cso(arg, anAnchor);	/* Display "cover page" */
		return HT_LOADED;	/* Local function only */
	    }
	    HTAnchor_setIndex(anAnchor, anAnchor->address);
	    *query++ = '\0';	/* Skip '?'     */
	    command = (char *) malloc(strlen("query") + 1 +
				      strlen(query) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");

	    assert(command != NULL);

	    de_escape(command, selector);	/* Bug fix TBL 921208 */

	    strcpy(command, "query ");

	    {			/* Remove plus signs 921006 */
		char *p;

		for (p = query; *p; p++) {
		    if (*p == '+')
			*p = ' ';
		}
	    }
	    de_escape(&command[strlen(command)], query);	/* bug fix LJM 940415 */

	} else {		/* Not index */
	    command = (char *) malloc(strlen(selector) + 2 + 1);
	    if (command == NULL)
		outofmem(__FILE__, "HTLoadGopher");

	    assert(command != NULL);

	    de_escape(command, selector);
	}
	FREE(p1);
    }

    {
	char *p = command + strlen(command);

	*p++ = CR;		/* Macros to be correct on Mac */
	*p++ = LF;
	*p = '\0';
    }

    /*
     * Set up a socket to the server for the data.
     */
    status = HTDoConnect(arg, "gopher", GOPHER_PORT, &s);
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	FREE(command);
	return HT_NOT_LOADED;
    }
    if (status < 0) {
	CTRACE((tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		arg));
	FREE(command);
	return HTInetStatus("connect");
    }

    HTInitInput(s);		/* Set up input buffering */

    CTRACE((tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
	    command, s));

#ifdef NOT_ASCII
    {
	char *p;

	for (p = command; *p; p++) {
	    *p = TOASCII(*p);
	}
    }
#endif

    _HTProgress(GOPHER_SENDING_REQUEST);

    status = (int) NETWRITE(s, command, (int) strlen(command));
    FREE(command);
    if (status < 0) {
	CTRACE((tfp, "HTGopher: Unable to send command.\n"));
	return HTInetStatus("send");
    }

    _HTProgress(GOPHER_SENT_REQUEST);

    /*
     * Now read the data from the socket.
     */
    switch (gtype) {

    case GOPHER_TEXT:
	HTParseSocket(WWW_PLAINTEXT, format_out, anAnchor, s, sink);
	break;

    case GOPHER_HTML:
    case GOPHER_CHTML:
	HTParseSocket(WWW_HTML, format_out, anAnchor, s, sink);
	break;

    case GOPHER_GIF:
    case GOPHER_IMAGE:
    case GOPHER_PLUS_IMAGE:
	HTParseSocket(HTAtom_for("image/gif"),
		      format_out, anAnchor, s, sink);
	break;

    case GOPHER_MENU:
    case GOPHER_INDEX:
	target = HTML_new(anAnchor, format_out, sink);
	targetClass = *target->isa;
	parse_menu(arg, anAnchor);
	break;

    case GOPHER_CSO:
	target = HTML_new(anAnchor, format_out, sink);
	targetClass = *target->isa;
	parse_cso(arg, anAnchor);
	break;

    case GOPHER_SOUND:
    case GOPHER_PLUS_SOUND:
	HTParseSocket(WWW_AUDIO, format_out, anAnchor, s, sink);
	break;

    case GOPHER_PLUS_MOVIE:
	HTParseSocket(HTAtom_for("video/mpeg"), format_out, anAnchor, s, sink);
	break;

    case GOPHER_PLUS_PDF:
	HTParseSocket(HTAtom_for("application/pdf"), format_out, anAnchor,
		      s, sink);
	break;

    default:
	{
	    HTAtom *encoding = 0;
	    const char *desc = 0;
	    HTFormat format = HTFileFormat(arg, &encoding, &desc);

	    /*
	     * Ignore WWW_BINARY (since that is returned by HTFileFormat when
	     * it does not have a representation), but otherwise use the
	     * result.
	     */
	    if (format != WWW_BINARY) {
		HTParseSocket(format, format_out, anAnchor, s, sink);
		break;
	    }
	}
	/* FALL-THRU */

    case GOPHER_MACBINHEX:
    case GOPHER_PCBINARY:
    case GOPHER_UUENCODED:
    case GOPHER_BINARY:
	/*
	 * Specifying WWW_UNKNOWN forces dump to local disk.
	 */
	HTParseSocket(WWW_UNKNOWN, format_out, anAnchor, s, sink);
	break;

    }				/* switch(gtype) */

    NETCLOSE(s);
    return HT_LOADED;
}

#ifdef GLOBALDEF_IS_MACRO
#define _HTGOPHER_C_1_INIT { "gopher", HTLoadGopher, NULL }
GLOBALDEF(HTProtocol, HTGopher, _HTGOPHER_C_1_INIT);
#define _HTCSO_C_1_INIT { "cso", HTLoadCSO, NULL }
GLOBALDEF(HTProtocol, HTCSO, _HTCSO_C_1_INIT);
#else
GLOBALDEF HTProtocol HTGopher =
{"gopher", HTLoadGopher, NULL};
GLOBALDEF HTProtocol HTCSO =
{"cso", HTLoadCSO, NULL};
#endif /* GLOBALDEF_IS_MACRO */

#endif /* not DISABLE_GOPHER */
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTGopher.c,v 1.43 2008/03/17 00:03:23 tom Exp $
d21 2
d24 1
d127 2
a128 2
    char *host;
    char *seek;
d163 1
a163 1
static char from_hex(char c)
d269 1
a269 1
	    bytes += p - line;	/* add size */
d287 1
a287 1
		selector = strchr(name, TAB);
d299 1
a299 1
		    host = strchr(selector, TAB);
d302 1
a302 1
			port = strchr(host, TAB);
d307 1
a307 1
			    junk = strchr(port, TAB);
d309 1
a309 1
				*junk++ = '\0';		/* Chop port */
d318 2
a319 2
	    if (gtype == GOPHER_TEXT) {
		int i = strlen(name) - 1;
d535 1
a535 1
		first_colon = strchr(p, ':');
d537 1
a537 1
		    second_colon = strchr(first_colon + 1, ':');
d690 1
a690 1
    char *q = command;
d694 4
d705 1
a705 1
	    b = from_hex(c);
d709 1
a709 1
	    *q++ = (char) FROMASCII((b << 4) + from_hex(c));
d714 1
a714 1
    *q++ = '\0';		/* Terminate command */
d745 1
d758 1
a758 1
	if (0 == strncmp(key, "$(FID)", 6)) {
d760 1
a760 1
	} else if (0 == strncmp(key, "$(FDESC)", 8)) {
d762 1
a762 1
	} else if (0 == strncmp(key, "$(FDEF)", 7)) {
d764 1
a764 1
	} else if (0 == strncmp(key, "$(FNDX)", 7)) {
d766 1
a766 1
	} else if (0 == strncmp(key, "$(FSIZE)", 8)) {
d770 1
a770 1
	} else if (0 == strncmp(key, "$(FSIZE2)", 9)) {
d776 1
a776 1
	    *length = strlen(buf);
d781 1
a781 1
    if (0 == strncmp(key, "$(NEXTFLD)", 10)) {
d823 2
a824 2
    } else if ((0 == strncmp(key, "$(QFIELDS)", 10)) ||
	       (0 == strncmp(key, "$(RFIELDS)", 10))) {
d836 1
a836 1
    } else if (0 == strncmp(key, "$(NAMEFLD)", 10)) {
d848 1
a848 1
    } else if (0 == strncmp(key, "$(HOST)", 7)) {
d850 1
a850 1
    } else if (0 == strncmp(key, "$(PORT)", 7)) {
d860 1
a860 1
	    if (out > sizeof(buf) - 2) {
d862 1
a862 1
		(*Target->isa->put_block) (Target, buf, strlen(buf));
a867 2
	*length = strlen(buf);
	return;
d869 1
a869 1
    *length = strlen(buf);
d918 1
a918 1
			    int size)
d1011 8
a1018 6
			alen = strlen((char *) &p[i]) + 1;
			if (alen > sizeof(last->desc_buf)) {
			    if (last->description != last->desc_buf)
				FREE(last->description);
			    if (!(last->description = (char *) malloc(alen))) {
				outofmem(__FILE__, "HTLoadCSO");
d1020 1
a1021 1
			strcpy(last->description, (char *) &p[i]);
d1032 3
d1091 1
a1128 1
    out = 0;
d1141 1
a1141 3
    for (i = full_flag ? /***1***/ 0 : 0;
	 ctemplate[i];
	 i++) {
d1153 4
a1156 3
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
		out = 0;
		for (key = &line[j]; line[j + 1] && (line[j] != ')'); j++) ;
d1162 1
a1162 1
		interpret_cso_key(key, buf, &length, &ctx, Target);
d1166 1
a1166 1
		out = length;
d1173 1
a1173 1
		    int slen = strlen(ctx.seek);
d1178 1
a1178 1
				if (0 == strncmp(ctx.seek, &line[j], slen)) {
d1180 1
a1180 1
					j = strlen(ctemplate[--i]) - 1;
d1196 1
a1196 1
			(*Target->isa->put_block) (Target, temp, strlen(temp));
d1205 1
a1205 1
		if (out > (sizeof(buf) - 3)) {
d1207 1
a1207 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1216 1
a1216 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1266 1
a1266 1
	    len = strlen(p);
d1283 1
a1283 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1288 1
a1288 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1292 1
a1292 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1298 1
a1298 1
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d1308 1
a1308 1
			i = strlen(fname) - 1;
d1333 1
a1333 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1336 1
a1336 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1346 14
a1359 14
			    } else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				       strncmp(l, "snews://", 8) &&
				       strncmp(l, "nntp://", 7) &&
				       strncmp(l, "snewspost:", 10) &&
				       strncmp(l, "snewsreply:", 11) &&
				       strncmp(l, "newspost:", 9) &&
				       strncmp(l, "newsreply:", 10) &&
				       strncmp(l, "ftp://", 6) &&
				       strncmp(l, "file:/", 6) &&
				       strncmp(l, "finger://", 9) &&
				       strncmp(l, "http://", 7) &&
				       strncmp(l, "https://", 8) &&
				       strncmp(l, "wais://", 7) &&
				       strncmp(l, STR_MAILTO_URL,
d1361 2
a1362 2
				       strncmp(l, "cso://", 6) &&
				       strncmp(l, "gopher://", 9)) {
d1369 1
a1369 1
				while (*l && !strchr(" \r\n\t,>)\"", *l)) {
d1377 1
a1377 1
			(*Target->isa->put_block) (Target, buf, strlen(buf));
d1381 1
a1381 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1391 16
a1406 16
			} else if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				   strncmp(l, "snews://", 8) &&
				   strncmp(l, "nntp://", 7) &&
				   strncmp(l, "snewspost:", 10) &&
				   strncmp(l, "snewsreply:", 11) &&
				   strncmp(l, "newspost:", 9) &&
				   strncmp(l, "newsreply:", 10) &&
				   strncmp(l, "ftp://", 6) &&
				   strncmp(l, "file:/", 6) &&
				   strncmp(l, "finger://", 9) &&
				   strncmp(l, "http://", 7) &&
				   strncmp(l, "https://", 8) &&
				   strncmp(l, "wais://", 7) &&
				   strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
				   strncmp(l, "cso://", 6) &&
				   strncmp(l, "gopher://", 9)) {
d1413 1
a1413 1
			    while (*l && !strchr(" \r\n\t,>)\"", *l)) {
d1421 1
a1421 1
		    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1424 2
a1425 2
		HTSprintf0(&buf, "<DD>%s\n", fname ? fname : rcode);
		(*Target->isa->put_block) (Target, buf, strlen(buf));
d1432 1
a1432 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1496 1
a1496 1
    status = NETWRITE(s, BStrData(command), BStrLen(command));
d1533 3
a1535 6
    if ((cp = strchr(host, ':')) != NULL) {
	if (cp[1] >= '0' && cp[1] <= '9') {
	    port = atoi((cp + 1));
	    if (port == CSO_PORT) {
		*cp = '\0';
	    }
d1540 1
a1540 1
	generate_cso_form(host, port, buf, Target);
d1556 1
d1575 1
a1575 1
    start = finish = 0;
d1620 1
d1629 1
a1629 1
		    } else if (!strncmp(&data[start], "return=", 7)) {
d1646 1
a1646 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1648 1
a1648 1
	(*Target->isa->put_block) (Target, buf, strlen(buf));
d1668 1
a1668 1
    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1671 1
a1671 1
    (*Target->isa->put_block) (Target, buf, strlen(buf));
d1677 1
a1677 1
    status = NETWRITE(s, BStrData(command), BStrLen(command));
d1686 1
a1686 1
    (*Target->isa->put_block) (Target, end_form, sizeof(end_form) - 1);
a1695 2
 *  Bug:  No decoding of strange data types as yet.
 *
d1722 1
a1722 1
	int len;
d1764 1
a1764 1
	    query = strchr(selector, '?');	/* Look for search string */
d1777 2
d1799 1
a1799 1
	    query = strchr(selector, '?');	/* Look for search string */
d1813 2
d1833 3
d1846 1
a1846 1
	*p++ = '\0';
d1886 1
a1886 1
    status = NETWRITE(s, command, (int) strlen(command));
d1943 18
a1964 1
    default:
@


1.8
log
@reapply from mainline lynx, fix lost after local update. Okay deraadt.

2008-04-27 (2.8.7dev.9)
* pass a newline after the start of PRE-section in HTGopher.c to force
the first newline between records to be seen and cause the lines to
split (report by Ciprian Dorin Craciun) -TD
@
text
@d1 4
a4 1
/*			GOPHER ACCESS				HTGopher.c
d250 1
a250 1
    PUTC('\n');
@


1.7
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d247 1
@


1.6
log
@from mainline lynx; passed to us by bulibuta@@sdf.lonestar.org
2008-04-27 (2.8.7dev.9)
* pass a newline after the start of PRE-section in HTGopher.c to force
the first newline between records to be seen and cause the lines to
split (report by Ciprian Dorin Craciun) -TD
@
text
@d2 15
a16 15
**			=============
**
**  History:
**	26 Sep 90	Adapted from other accesses (News, HTTP) TBL
**	29 Nov 91	Downgraded to C, for portable implementation.
**	10 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Added a
**			  form-based CSO/PH gateway.  Can be invoked via a
**			  "cso://host[:port]/" or "gopher://host:105/2"
**			  URL.	If a gopher URL is used with a query token
**			  ('?'), the old ISINDEX procedure will be used
**			  instead of the form-based gateway.
**	15 Mar 96	Foteos Macrides (macrides@@sci.wfbr.edu).  Pass
**			  port 79, gtype 0 gopher URLs to the finger
**			  gateway.
*/
d27 2
a28 2
**  Implements.
*/
d37 2
a38 2
**  Gopher entity types.
*/
d50 2
a51 2
#define GOPHER_HTML		'h'		/* HTML */
#define GOPHER_CHTML		'H'		/* HTML */
d53 1
a53 1
#define GOPHER_WWW		'w'		/* W3 address */
d58 1
a58 1
#define GOPHER_PLUS_IMAGE	':'		/* Addition from Gopher Plus */
d66 2
a67 2
**  Hypertext object building machinery.
*/
a79 2
#define GOPHER_PROGRESS(foo) HTAlert(foo)

d83 3
a85 3
**  Module-wide variables.
*/
PRIVATE int s;				/* Socket for gopher or CSO host */
d88 2
a89 2
	CONST HTStructuredClass * isa;	/* For gopher streams */
	/* ... */
d92 2
a93 2
PRIVATE HTStructured *target;		/* the new gopher hypertext */
PRIVATE HTStructuredClass targetClass;	/* Its action routines */
d95 2
a96 3
struct _HTStream
{
  HTStreamClass * isa;			/* For form-based CSO  gateway - FM */
d99 17
a115 17
typedef struct _CSOfield_info {		/* For form-based CSO gateway - FM */
    struct _CSOfield_info *	next;
    char *			name;
    char *			attributes;
    char *			description;
    int				id;
    int				lookup;
    int				indexed;
    int				url;
    int				max_size;
    int				defreturn;
    int				explicit_return;
    int				reserved;
    int				public;
    char			name_buf[16];	/* Avoid malloc if we can */
    char			desc_buf[32];	/* Avoid malloc if we can */
    char			attr_buf[80];	/* Avoid malloc if we can */
d118 1
a118 1
PRIVATE CSOfield_info *CSOfields = NULL; /* For form-based CSO gateway - FM */
d120 11
a130 11
typedef struct _CSOformgen_context {	 /* For form-based CSO gateway - FM */
    char *		host;
    char *		seek;
    CSOfield_info *	fld;
    int			port;
    int			cur_line;
    int			cur_off;
    int			rep_line;
    int			rep_off;
    int			public_override;
    int			field_select;
d134 4
a137 4
**	=========================================
*/
PRIVATE BOOL acceptable[256];
PRIVATE BOOL acceptable_inited = NO;
d139 1
a139 1
PRIVATE void init_acceptable NOARGS
d142 4
a145 3
    char * good =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
    for(i = 0; i < 256; i++)
d147 2
a148 2
    for(; *good; good++)
	acceptable[(unsigned int)*good] = YES;
d153 3
a155 3
**	========================
*/
PRIVATE CONST char hex[17] = "0123456789abcdef";
d157 1
a157 1
PRIVATE char from_hex ARGS1(char, c)
d159 4
a162 4
    return (char) (       (c>='0')&&(c<='9') ? c-'0'
			: (c>='A')&&(c<='F') ? c-'A'+10
			: (c>='a')&&(c<='f') ? c-'a'+10
			:		       0);
d166 11
a176 11
**	==================
**
**	The title of the destination is set, as there is no way
**	of knowing what the title is when we arrive.
**
** On entry,
**	HT	is in append mode.
**	text	points to the text to be put into the file, 0 terminated.
**	addr	points to the hypertext refernce address 0 terminated.
*/
PUBLIC BOOLEAN HT_Is_Gopher_URL=FALSE;
d178 1
a178 1
PRIVATE void write_anchor ARGS2(CONST char *,text, CONST char *,addr)
d181 1
a181 1
    CONST char * value[HTML_A_ATTRIBUTES];
d188 1
a188 1
    ((CONST char **)value)[HTML_A_HREF] = addr;
d190 1
a190 1
    ((CONST char **)value)[HTML_A_TITLE] = text;
d192 1
a192 1
    CTRACE((tfp,"HTGopher: adding URL: %s\n",addr));
d194 3
a196 3
    HT_Is_Gopher_URL = TRUE;  /* tell HTML.c that this is a Gopher URL */
    (*targetClass.start_element)(target, HTML_A, present,
				 (CONST char **)value, -1, 0);
d203 4
a206 5
**	============================
*/
PRIVATE void parse_menu ARGS2(
	CONST char *,		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor)
d215 1
a215 1
    CONST char *title;
a222 1

d247 1
a247 2
    PUTC('\n');			/* newline after HTML_PRE forces split-line */
    while ((ich=NEXT_CHAR) != EOF) {
d250 2
a251 1
	    CTRACE((tfp, "HTGopher: Interrupted in HTGetCharacter, apparently.\n"));
d255 4
a258 3
	if ((char)ich != LF) {
	    *p = (char) ich;    /* Put character in line */
	    if (p< &line[BIG-1]) p++;
d262 1
a262 1
	    bytes += p-line;	/* add size */
d275 1
a275 1
	    if ((gtype=='.') && ((*p=='\r') || (*p==0)))
d282 1
a282 1
		    *selector++ = '\0'; /* Terminate name */
d294 1
a294 1
			*host++ = '\0'; /* Terminate selector */
d298 1
d301 9
a309 8
			    if (junk) *junk++ = '\0';	/* Chop port */
			    if ((port[1]=='0') && (!port[2]))
				port[0] = '\0'; /* 0 means none */
			} /* no port */
		    } /* host ok */
		} /* selector ok */
	    } /* gtype and name ok */

d312 2
a313 1
		int i = strlen(name)-1;
d325 1
a325 1
	    /* Information or separator line */
d329 1
a329 1
	    } else if (port) {		/* Other types need port */
d331 1
a331 1
		char *format = *selector ? "%s//%s@@%s/" : "%s//%s/";
d336 1
a336 3
		}
		else if (gtype == GOPHER_TN3270)
		{
d339 1
a339 2
		}
		else {			/* If parsed ok */
d342 50
a391 50
		    switch(gtype) {
			case GOPHER_TEXT:
			    PUTS("(FILE) ");
			    break;
			case GOPHER_MENU:
			    PUTS(" (DIR) ");
			    break;
			case GOPHER_CSO:
			    PUTS(" (CSO) ");
			    break;
			case GOPHER_PCBINARY:
			    PUTS(" (BIN) ");
			    break;
			case GOPHER_UUENCODED:
			    PUTS(" (UUE) ");
			    break;
			case GOPHER_INDEX:
			    PUTS("  (?)  ");
			    break;
			case GOPHER_BINARY:
			    PUTS(" (BIN) ");
			    break;
			case GOPHER_GIF:
			case GOPHER_IMAGE:
			case GOPHER_PLUS_IMAGE:
			    PUTS(" (IMG) ");
			    break;
			case GOPHER_SOUND:
			case GOPHER_PLUS_SOUND:
			    PUTS(" (SND) ");
			    break;
			case GOPHER_MACBINHEX:
			    PUTS(" (HQX) ");
			    break;
			case GOPHER_HTML:
			case GOPHER_CHTML:
			    PUTS("(HTML) ");
			    break;
			case 'm':
			    PUTS("(MIME) ");
			    break;
			case GOPHER_PLUS_MOVIE:
			    PUTS(" (MOV) ");
			    break;
			case GOPHER_PLUS_PDF:
			    PUTS(" (PDF) ");
			    break;
			default:
			    PUTS("(UNKN) ");
			    break;
d396 1
a396 1
		    for(r = selector; *r; r++) { /* Encode selector string */
d401 3
a403 3
				HEX_ESCAPE,	/* Means hex coming */
				hex[(TOASCII(*r)) >> 4],
				hex[(TOASCII(*r)) & 15]);
d409 1
a409 1
		if (strcmp (address, "gopher://error.host:1/0"))
d414 1
a414 1
	    } else { /* parse error */
d418 1
a418 1
	    } /* parse error */
d421 1
a421 1
	    p = line;	/* Start again at beginning of line */
d423 1
a423 1
	} /* if end of line */
d425 1
a425 1
    } /* Loop over characters */
d427 1
a427 1
end_html:
d440 14
a453 15
**	==================================================
**
**   Accepts an open socket to a CSO server waiting to send us
**   data and puts it on the screen in a reasonable manner.
**
**   Perhaps this data can be automatically linked to some
**   other source as well???
**
**  Taken from hacking by Lou Montulli@@ukanaix.cc.ukans.edu
**  on XMosaic-1.1, and put on libwww 2.11 by Arthur Secret,
**  secret@@dxcern.cern.ch .
*/
PRIVATE void parse_cso ARGS2(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor)
d458 2
a459 2
    char *second_colon, last_char='\0';
    CONST char *title;
d484 47
a530 8
    **	Start grabbing chars from the network.
    */
    while ((ich=NEXT_CHAR) != EOF)
	{
	    if ((char)ich != LF)
		{
		    *p = (char) ich;    /* Put character in line */
		    if (p< &line[BIG-1]) p++;
a531 8
	    else
		{
		    *p = '\0';		/* Terminate line */
		    p = line;		/* Scan it to parse it */
		    /*
		    **	OK we now have a line in 'p'.
		    **	Lets parse it and print it.
		    */
d533 1
a533 6
		    /*
		    **	Break on line that begins with a 2.
		    **	It's the end of data.
		    */
		    if (*p == '2')
			break;
d535 4
a538 5
		    /*
		    **	Lines beginning with 5 are errors.
		    **	Print them and quit.
		    */
		    if (*p == '5') {
a539 3
			PUTS(p+4);
			END(HTML_H2);
			break;
d542 14
a555 10
		    if (*p == '-') {
			/*
			**  Data lines look like  -200:#:
			**  where # is the search result number and can be
			**  multiple digits (infinite?).
			**  Find the second colon and check the digit to the
			**  left of it to see if they are diferent.
			**  If they are then a different person is starting.
			**  Make this line an <h2>.
			*/
d557 5
a561 13
			/*
			**  Find the second_colon.
			*/
			second_colon = strchr( strchr(p,':')+1, ':');

			if(second_colon != NULL) {  /* error check */

			    if (*(second_colon-1) != last_char)
				/* print seperator */
			    {
				END(HTML_PRE);
				START(HTML_H2);
			    }
d563 6
d570 5
a574 27
			    /*
			    **	Right now the record appears with the alias
			    **	(first line) as the header and the rest as
			    **	<pre> text.
			    **	It might look better with the name as the
			    **	header and the rest as a <ul> with <li> tags.
			    **	I'm not sure whether the name field comes in
			    **	any special order or if its even required in
			    **	a record, so for now the first line is the
			    **	header no matter what it is (it's almost
			    **	always the alias).
			    **	A <dl> with the first line as the <DT> and
			    **	the rest as some form of <DD> might good also?
			    */

			    /*
			    **	Print data.
			    */
			    PUTS(second_colon+1);
			    PUTC('\n');

			    if (*(second_colon-1) != last_char)
				/* end seperator */
			    {
				END(HTML_H2);
				START(HTML_PRE);
			    }
d576 3
a578 9
			    /*
			    **	Save the char before the second colon
			    **	for comparison on the next pass.
			    */
			    last_char =  *(second_colon-1) ;

			} /* end if second_colon */
		    } /* end if *p == '-' */
		} /* if end of line */
d580 1
a580 1
	} /* Loop over characters */
d588 2
a589 2
    return;  /* all done */
} /* end of procedure */
d592 4
a595 5
**	========================================
*/
PRIVATE void display_cso ARGS2(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor)
d597 1
a597 1
    CONST char * title;
d616 2
a617 2
       PUTS(arg);
       PUTS(INDEX_SEGMENT);
d635 4
a638 5
**	================================
*/
PRIVATE void display_index ARGS2(
				  CONST char *, arg,
				  HTParentAnchor *,anAnchor)
d640 1
a640 1
    CONST char * title;
d660 2
a661 2
       PUTS(arg);
       PUTS(INDEX_SEGMENT);
d676 5
a680 5
**	====================================
**
**	The % hex escapes are converted. Otheriwse, the string is copied.
*/
PRIVATE void de_escape ARGS2(char *, command, CONST char *, selector)
d682 5
a686 4
    CONST char * p = selector;
    char * q = command;
	if (command == NULL)
	    outofmem(__FILE__, "HTLoadGopher");
d691 1
d694 1
a694 1
	    b =   from_hex(c);
d696 3
a698 2
	    if (!c) break;	/* Odd number of chars! */
	    *q++ = (char) FROMASCII((b<<4) + from_hex(c));
d703 1
a703 1
    *q++ = '\0';	/* Terminate command */
a705 1

d707 3
a709 3
**	===================================
*/
PRIVATE void free_CSOfields NOPARAMS
d730 7
a736 8
**	=========================================
*/
PRIVATE void interpret_cso_key ARGS5(
	char *,			key,
	char *,			buf,
	int *,			length,
	CSOformgen_context *,	ctx,
	HTStream *,		Target)
d742 2
a743 2
	**  Most substitutions only recognized inside of loops.
	*/
d745 1
d775 1
a775 1
	  case 0:
d777 2
a778 2
	    **	'Query' fields, public and lookup attributes.
	    */
d780 2
a781 2
		 if (fld->public && (fld->lookup==1))
		     break;
d783 1
a783 1
	  case 1:
d785 2
a786 2
	    **	'Query' fields, accept lookup attribute.
	    */
d791 1
a791 1
	  case 2:
d793 2
a794 2
	    **	'Return' fields, public only.
	    */
d796 1
a796 1
		if (fld->public)
d799 1
a799 1
	  case 3:
d801 2
a802 2
	    **	All fields.
	    */
d814 2
a815 2
	**  Begin iteration sequence.
	*/
d826 2
a827 2
	**  Special, locate name field.  Flag lookup so QFIELDS will skip it.
	*/
d836 3
a838 3
    } else if (0 == strncmp (key, "$(HOST)", 7)) {
	strcpy (buf, ctx->host);
    } else if (0 == strncmp (key, "$(PORT)", 7)) {
d842 2
a843 2
	**  No match, dump key to buffer so client sees it for debugging.
	*/
d845 1
d848 1
a848 1
	    if (out > sizeof(buf)-2) {
d850 1
a850 1
		(*Target->isa->put_block)(Target, buf, strlen(buf));
d864 3
a866 4
**	=====================================================
*/
PRIVATE int parse_cso_field_info ARGS1(
	CSOfield_info *,	blk)
d871 2
a872 2
    ** Initialize all fields to default values.
    */
d874 1
a874 1
    blk->defreturn = blk->explicit_return = blk->public = 0;
d877 3
a879 3
    **	Search for keywords in info string and set values.  Attributes
    **	are converted to all lower-case for comparison.
    */
d887 1
a887 1
	blk->public = 1;
d905 4
a908 5
**	================================================
*/
PRIVATE int parse_cso_fields ARGS2(
	char *,		buf,
	int,		size)
d915 1
a915 1
    CSOfield_info *last, *new;
d922 2
a923 2
    **	Start grabbing chars from the network.
    */
d926 2
a927 1
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
d933 3
a935 3
	if ((char)ich != LF) {
	    *p = (char) ich;    /* Put character in buffer */
	    if (p < &buf[size-1]) {
d946 2
a947 3
	    **	Break on line that begins with a 2.
	    **	It's the end of data.
	    */
d952 2
a953 3
	    **	Lines beginning with 5 are errors.
	    **	Print them and quit.
	    */
d955 1
a955 1
		strcpy (buf, p);
d961 4
a964 4
		**  Data lines look like  -200:#:
		**  where # is the search result number and can be
		**  multiple digits (infinite?).
		*/
d967 3
a969 3
		** Check status, ignore any non-success.
		*/
		if (p[1] != '2' )
d973 3
a975 3
		** Parse fields within returned line into status, ndx, name,
		** data.
		*/
d979 1
a979 1
		    if (p[i] == ':' ) {
d982 2
a983 2
			    indx = (char *)&p[i+1];
			    code = atoi (indx);
d985 1
a985 1
			    name = (char *)&p[i+1];
d993 2
a994 2
		**  Add data to field structure.
		*/
d998 4
a1001 4
			**  Remaining data are description.
			**  Save in current info block.
			*/
			alen = strlen((char *)&p[i]) + 1;
d1005 1
a1005 1
			    if (!(last->description = (char *)malloc(alen))) {
d1009 1
a1009 1
			strcpy(last->description, (char *)&p[i]);
d1012 6
a1017 5
			**  Initialize new block, append to end of list
			**  to preserve order.
			*/
			new = typecalloc(CSOfield_info);
			if (!new) {
d1021 1
a1021 1
			    last->next = new;
d1023 2
a1024 2
			    CSOfields = new;
			last = new;
d1026 2
a1027 2
			new->next = (CSOfield_info *) 0;
			new->name = new->name_buf;
d1029 2
a1030 2
			if (alen > sizeof(new->name_buf)) {
			    if (!(new->name = (char *)malloc(alen))) {
d1034 1
a1034 1
			strcpy (new->name, name);
d1036 4
a1039 4
			new->attributes = new->attr_buf;
			alen = strlen((char *)&p[i]) + 2;
			if (alen > sizeof(new->attr_buf)) {
			    if (!(new->attributes = (char *)malloc(alen))) {
d1043 5
a1047 5
			strcpy(new->attributes, (char *)&p[i]);
			strcpy((char *)&new->attributes[alen-2], " ");
			new->description = new->desc_buf;
			new->desc_buf[0] = '\0';
			new->id = atoi(indx);
d1049 3
a1051 3
			**  Scan for keywords.
			*/
			parse_cso_field_info(new);
d1056 2
a1057 2
	    } /* end if *p == '-' */
	} /* if end of line */
d1059 1
a1059 1
    } /* Loop over characters */
d1064 1
a1064 1
	return -1; /* no response */
d1067 2
a1068 2
    return 0;  /* all done */
} /* end of procedure */
d1071 6
a1076 7
**	====================================================
*/
PRIVATE int generate_cso_form ARGS4(
	char *,		host,
	int,		port,
	char *,		buf,
	HTStream *,	Target)
d1081 2
a1082 1
    char *key, *line;
d1084 27
a1110 25
    static char *template[] = {
   "<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
   "<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
   "To search the database for a name, fill in one or more of the fields",
   "in the form below and activate the 'Submit query' button.  At least",
   "one of the entered fields must be flagged as indexed.",
   "<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
   "[ <input type=\"submit\" value=\"Submit query\"> | ",
   "<input type=\"reset\" value=\"Clear fields\"> ]",
   "<P><DL>",
   "   <DT>Search parameters (* indicates indexed field):",
   "   <DD>", "$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
   "    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
   "    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
   "$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
   "    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
   "    </DL>",
   "   </DL>\n<P><DL>",
   "   <DT>Output format:",
   "   <DD>Returned data option: <select name=\"return\">",
   "    <option>default<option selected>all<option>selected</select><BR>",
   "$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
   "$(NEXTFLD)    ",
   "   </DL></FORM><HR>\n</BODY>\n</HTML>",
   (char *) 0
d1121 3
a1123 3
    **	Parse the strings in the template array to produce HTML document
    **	to send to client.  First line is skipped for 'full' lists.
    */
d1126 3
a1128 1
    for (i = full_flag ? /***1***/ 0 : 0; template[i]; i++) {
d1130 4
a1133 4
	**  Search the current string for substitution, flagged by $(
	*/
	for (line=template[i], j = 0; line[j]; j++) {
	    if ((line[j] == '$') && (line[j+1] == '(')) {
d1135 3
a1137 3
		** Command detected, flush output buffer and find closing ')'
		** that delimits the command.
		*/
d1140 1
a1140 1
		    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1142 1
a1142 2
		for (key = &line[j]; line[j+1] && (line[j] != ')'); j++)
		    ;
d1144 2
a1145 2
		**  Save context, interpet command and restore updated context.
		*/
d1151 1
a1151 1
		line = template[i];
d1156 3
a1158 3
		    **	Command wants us to skip (forward) to indicated token.
		    **	Start at current position.
		    */
d1160 3
a1162 2
		    for (; template[i]; i++) {
			for (line = template[i]; line[j]; j++) {
d1166 1
a1166 1
					j = strlen(template[--i])-1;
d1169 1
a1169 1
				    line = template[i];
d1180 1
d1182 1
a1182 1
			(*Target->isa->put_block)(Target, temp, strlen(temp));
d1188 2
a1189 2
		**  Non-command text, add to output buffer.
		*/
d1191 1
a1191 1
		if (out > (sizeof(buf)-3)) {
d1193 1
a1193 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1202 1
a1202 1
	(*Target->isa->put_block)(Target, buf, strlen(buf));
d1208 3
a1210 4
**	==============================================================
*/
PRIVATE int generate_cso_report ARGS1(
	HTStream *,	Target)
d1222 2
a1223 2
    **	Read lines until non-negative status.
    */
d1226 2
a1227 2
    **	Start grabbing chars from the network.
    */
d1230 3
a1232 2
	    CTRACE((tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n"));
	    _HTProgress (CONNECTION_INTERRUPTED);
d1236 3
a1238 3
	if ((char)ich != LF) {
	    *p = (char) ich;    /* Put character in line */
	    if (p < &line[BIG-1]) {
d1244 2
a1245 3
	    **	OK we now have a line.
	    **	Load it as 'p' and parse it.
	    */
d1257 1
a1257 1
			fname = ndx_str = &p[i+1];
d1259 1
a1259 1
			fname = &p[i+1];
d1269 1
a1269 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1273 2
a1274 2
		  "<HR><DL><DT>Information/status<DD><DL><DT>\n");
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1277 2
a1278 2
	      "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1284 1
a1284 1
		(*Target->isa->put_block)(Target, buf, strlen(buf));
d1296 1
a1296 1
			    fname[i--] = '\0'; /* trim trailing */
d1317 3
a1319 3
				"<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",
				fname, fvalue, fvalue);
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1322 1
a1322 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1345 2
a1346 1
				       strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
d1363 1
a1363 1
			(*Target->isa->put_block)(Target, buf, strlen(buf));
d1367 1
a1367 1
		    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1407 1
a1407 1
		    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1410 2
a1411 2
		HTSprintf0(&buf, "<DD>%s\n", fname ? fname : rcode );
		(*Target->isa->put_block)(Target, buf, strlen(buf));
d1415 1
a1415 1
end_CSOreport:
d1418 1
a1418 1
	(*Target->isa->put_block)(Target, buf, strlen(buf));
d1425 6
a1430 7
**	=====================================
*/
PRIVATE int HTLoadCSO ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1432 1
a1432 1
    static CONST char end_form[] = "</BODY>\n</HTML>\n";
d1435 1
a1435 1
    int status;				/* tcp return */
d1446 1
a1446 1
	 init_acceptable();
d1449 1
a1449 1
	return -3;		/* Bad if no name sepcified	*/
d1451 1
a1451 1
	return -2;		/* Bad if name had zero length	*/
d1455 3
a1457 3
    **	Set up a socket to the server for the data.
    */
    status = HTDoConnect (arg, "cso", CSO_PORT, &s);
d1460 5
a1464 4
	**  Interrupt cleanly.
	*/
	CTRACE((tfp, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress (CONNECTION_INTERRUPTED);
d1469 1
a1469 1
		    arg));
d1481 1
a1481 1
    _HTProgress (GOPHER_SENDING_CSO_REQUEST);
d1488 1
a1488 1
    _HTProgress (GOPHER_SENT_CSO_REQUEST);
d1491 2
a1492 2
    **	Now read the data from the socket.
    */
d1497 1
a1497 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d1510 1
d1521 1
a1521 1
	    port = atoi((cp+1));
d1530 1
a1530 1
	(*Target->isa->_free)(Target);
d1538 3
a1540 3
     "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
	    host);
    (*Target->isa->put_block)(Target, BStrData(command), BStrLen(command));
d1546 1
a1546 1
    if (BStrData(content)[BStrLen(content)-1] != '&')
d1567 3
a1569 3
	    **	Value parsed.  Unescape characters and look for first '='
	    **	to delimit field name from value.
	    */
d1576 4
a1579 4
		    **	data[start..j-1] is field name,
		    **	[j+1..finish-1] is value.
		    */
		    if ((data[start+1] == '_') &&
d1582 3
a1584 3
			**  Decode fields number and lookup field info.
			*/
			sscanf (&data[start+2], "%d=", &ndx);
d1586 2
a1587 2
			    if (ndx==fld->id) {
				if ((j+1) >= finish)
d1602 1
a1602 1
						  fld->name, &data[j+1]);
d1605 4
a1608 4
				"Warning: non-lookup field ignored<BR>\n");
					(*Target->isa->put_block)(Target,
								  buf,
								  strlen(buf));
d1617 1
a1617 1
			if (!strcmp(&data[start+7], "all")) {
d1619 1
a1619 1
			} else if (!strcmp(&data[start+7], "selected")) {
d1632 2
a1633 2
  "<EM>Error:</EM> At least one indexed field value must be specified!\n");
	(*Target->isa->put_block)(Target, buf, strlen(buf));
d1635 2
a1636 2
	(*Target->isa->put_block)(Target, buf, strlen(buf));
	(*Target->isa->_free)(Target);
d1641 2
a1642 2
    **	Append return fields.
    */
d1655 2
a1656 2
    (*Target->isa->put_block)(Target, buf, strlen(buf));
    (*Target->isa->put_block)(Target, BStrData(command), BStrLen(command));
d1658 1
a1658 1
    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1660 1
a1660 1
	CTRACE((tfp, "HTLoadCSO: Writing command `"));  
d1673 2
a1674 2
    (*Target->isa->put_block)(Target, end_form, sizeof(end_form)-1);
    (*Target->isa->_free)(Target);
d1681 9
a1689 10
**	=============
**
**  Bug:  No decoding of strange data types as yet.
**
*/
PRIVATE int HTLoadGopher ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1691 4
a1694 4
    char *command;			/* The whole command */
    int status;				/* tcp return */
    char gtype;				/* Gopher Node type */
    char * selector;			/* Selector string */
d1697 1
a1697 1
	 init_acceptable();
d1700 1
a1700 1
	return -3;		/* Bad if no name sepcified	*/
d1702 1
a1702 1
	return -2;		/* Bad if name had zero length	*/
d1706 4
a1709 4
    **	If it's a port 105 GOPHER_CSO gtype with no ISINDEX token ('?'),
    **	use the form-based CSO gateway (otherwise, return an ISINDEX
    **	cover page or do the ISINDEX search). - FM
    */
d1714 1
a1714 1
	    if (0 == strcmp((CONST char *)&arg[len-6], ":105/2")) {
d1723 2
a1724 2
    **	If it's a port 79/0[/...] URL, use the finger gateway. - FM
    */
d1736 2
a1737 2
    **	Get entity type, and selector string.
    */
d1739 2
a1740 1
	char * p1 = HTParse(arg, "", PARSE_PATH|PARSE_PUNCTUATION);
d1743 2
a1744 2
	if ((*selector++=='/') && (*selector)) {	/* Skip first slash */
	    gtype = *selector++;			/* Pick up gtype */
d1747 2
a1748 1
	    char * query;
d1750 2
a1751 2
	    **	Search is allowed.
	    */
d1754 1
a1754 1
	    if (!query || !query[1]) {		/* No search required */
d1758 1
a1758 1
		return HT_LOADED;		/* Local function only */
d1760 1
a1760 1
	    *query++ = '\0';			/* Skip '?'	*/
d1762 3
a1764 3
		    (char *)malloc(strlen(selector)+ 1 + strlen(query)+ 2 + 1);
	      if (command == NULL)
		  outofmem(__FILE__, "HTLoadGopher");
d1770 1
a1770 1
	    {					/* Remove plus signs 921006 */
d1772 4
a1775 2
		for (p=query; *p; p++) {
		    if (*p == '+') *p = ' ';
d1779 1
a1779 1
	    de_escape(&command[strlen(command)], query);/* bug fix LJM 940415 */
d1781 2
a1782 1
	    char * query;
d1784 2
a1785 2
	    **	Search is allowed.
	    */
d1787 1
a1787 1
	    if (!query || !query[1]) {		/* No search required */
d1791 1
a1791 1
		return HT_LOADED;		/* Local function only */
d1794 5
a1798 4
	    *query++ = '\0';			/* Skip '?'	*/
	    command = (char *)malloc(strlen("query")+1 + strlen(query)+2+1);
	      if (command == NULL)
		  outofmem(__FILE__, "HTLoadGopher");
d1804 1
a1804 1
	    {					/* Remove plus signs 921006 */
d1806 4
a1809 2
		for (p=query; *p; p++) {
		    if (*p == '+') *p = ' ';
d1812 1
a1812 1
	    de_escape(&command[strlen(command)], query);/* bug fix LJM 940415 */
d1814 2
a1815 2
	} else {				/* Not index */
	    command = (char *)malloc(strlen(selector)+2+1);
d1824 2
a1825 1
	char * p = command + strlen(command);
d1832 3
a1834 3
    **	Set up a socket to the server for the data.
    */
    status = HTDoConnect (arg, "gopher", GOPHER_PORT, &s);
d1837 2
a1838 2
	**  Interrupt cleanly.
	*/
d1840 1
a1840 1
	_HTProgress (CONNECTION_INTERRUPTED);
d1846 1
a1846 1
		    arg));
d1854 1
a1854 1
		command, s));
d1858 2
a1859 1
	char * p;
d1866 1
a1866 1
    _HTProgress (GOPHER_SENDING_REQUEST);
d1868 1
a1868 1
    status = NETWRITE(s, command, (int)strlen(command));
d1875 1
a1875 1
    _HTProgress (GOPHER_SENT_REQUEST);
d1878 2
a1879 2
    **	Now read the data from the socket.
    */
d1882 1
a1882 1
    case GOPHER_TEXT :
d1886 2
a1887 2
    case GOPHER_HTML :
    case GOPHER_CHTML :
d1895 1
a1895 1
			   format_out, anAnchor, s, sink);
d1898 2
a1899 2
    case GOPHER_MENU :
    case GOPHER_INDEX :
d1911 2
a1912 2
    case GOPHER_SOUND :
    case GOPHER_PLUS_SOUND :
d1922 1
a1922 1
				  s, sink);
d1931 3
a1933 3
	**  Specifying WWW_UNKNOWN forces dump to local disk.
	*/
	HTParseSocket (WWW_UNKNOWN, format_out, anAnchor, s, sink);
d1936 1
a1936 1
    } /* switch(gtype) */
d1944 1
a1944 1
GLOBALDEF (HTProtocol, HTGopher, _HTGOPHER_C_1_INIT);
d1946 1
a1946 1
GLOBALDEF (HTProtocol, HTCSO, _HTCSO_C_1_INIT);
d1948 4
a1951 2
GLOBALDEF PUBLIC HTProtocol HTGopher = { "gopher", HTLoadGopher, NULL };
GLOBALDEF PUBLIC HTProtocol HTCSO = { "cso", HTLoadCSO, NULL };
@


1.5
log
@update to lynx2.8.5rel.4; fixes CAN-2005-3120 among other things.
prompted by naddy@@, cloder@@ ok.
@
text
@d251 1
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d1120 1
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d330 1
d334 1
a334 5
		    if (*selector)
			HTSprintf0(&address, "telnet://%s@@%s/",
					   selector, host);
		    else
			HTSprintf0(&address, "telnet://%s/", host);
d339 1
a339 5
		    if (*selector)
			HTSprintf0(&address, "tn3270://%s@@%s/",
				selector, host);
		    else
			HTSprintf0(&address, "tn3270://%s/", host);
d1335 1
a1335 1
			    } else if (strncmp(l, "news:", 5) &&
d1348 1
a1348 1
				       strncmp(l, "mailto:", 7) &&
d1379 1
a1379 1
			} else if (strncmp(l, "news:", 5) &&
d1392 1
a1392 1
				   strncmp(l, "mailto:", 7) &&
d1436 1
a1436 1
    char *host, *cp;
d1439 2
a1440 2
    char *command = NULL;
    char *content = NULL;
d1477 6
a1482 3
    HTSprintf0(&command, "fields%c%c", CR, LF);
    CTRACE((tfp, "HTLoadCSO: Connected, writing command `%s' to socket %d\n",
		command, s));
d1484 2
a1485 2
    status = NETWRITE(s, command, (int)strlen(command));
    FREE(command);
d1520 1
a1520 1
    if ((cp=strchr(host, ':')) != NULL) {
d1529 1
a1529 1
    if (!(anAnchor->post_data && *anAnchor->post_data)) {
d1538 1
a1538 1
    HTSprintf0(&command,
d1541 2
a1542 2
    (*Target->isa->put_block)(Target, command, strlen(command));
    FREE(command);
d1545 7
a1551 4
    StrAllocCopy(content, anAnchor->post_data);
    if (content[strlen(content)-1] != '&')
	StrAllocCat(content, "&");
    len = strlen(content);
d1553 2
a1554 2
	if (content[i] == '+') {
	    content[i] = ' ';
d1557 5
a1561 2
    HTUnEscape(content);
    len = strlen(content);
d1566 1
a1566 1
	if (!content[i] || content[i] == '&') {
d1573 1
a1573 1
	    content[finish] = '\0';
d1575 1
a1575 1
		if (content[j] == '=') {
d1577 1
a1577 1
		    **	content[start..j-1] is field name,
d1580 2
a1581 2
		    if ((content[start+1] == '_') &&
			((content[start] == 'r') || (content[start] == 'q'))) {
d1585 1
a1585 1
			sscanf (&content[start+2], "%d=", &ndx);
d1590 1
a1590 1
				if (content[start] == 'q') {
d1597 2
a1598 2
					if (command == 0 || *command == 0) {
					    StrAllocCopy(command, "query ");
d1600 1
a1600 1
					    StrAllocCat(command, " ");
d1602 2
a1603 2
					HTSprintf(&command, "%s=\"%s\"",
						  fld->name, &content[j+1]);
d1611 1
a1611 1
				} else if (content[start] == 'r') {
d1617 2
a1618 2
		    } else if (!strncmp(&content[start],"return=",7)) {
			if (!strcmp(&content[start+7],"all")) {
d1620 1
a1620 1
			} else if (!strcmp(&content[start+7],"selected")) {
d1629 2
a1630 2
    FREE(content);
    if ((command == 0 || *command == 0) || !has_indexed) {
d1645 1
a1645 1
	StrAllocCat(command, " return all");
d1647 1
a1647 1
	StrAllocCat(command, " return");
d1650 1
a1650 1
		HTSprintf(&command, " %s", fld->name);
d1654 1
a1654 1
    HTSprintf(&command, "%c%c", CR, LF);
d1657 1
a1657 1
    (*Target->isa->put_block)(Target, command, strlen(command));
d1660 7
a1666 4
    CTRACE((tfp, "HTLoadCSO: Writing command `%s' to socket %d\n",
		command, s));
    status = NETWRITE(s, command, strlen(command));
    FREE(command);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d161 1
a161 1
    return		  (c>='0')&&(c<='9') ? c-'0'
d164 1
a164 1
			:		       0;
d194 1
a194 1
    CTRACE(tfp,"HTGopher: adding URL: %s\n",addr);
d254 1
a254 1
	    CTRACE(tfp, "HTGopher: Interrupted in HTGetCharacter, apparently.\n");
d259 1
a259 1
	    *p = ich;		/* Put character in line */
d267 1
a267 1
	    CTRACE(tfp, "HTGopher: Menu item: %s\n", line);
d406 1
a406 1
			if (acceptable[(unsigned char)*r]) {
d424 1
a424 1
		CTRACE(tfp, "HTGopher: Bad menu item.\n");
d500 1
a500 1
		    *p = ich;		/* Put character in line */
d711 1
a711 1
	    *q++ = FROMASCII((b<<4) + from_hex(c));
d763 1
a763 3
	    sprintf(buf, "%s%s%s", fld->description,
		    ctx->public_override ? /***" "***/"" : "",
		    ctx->public_override ? /***fld->attributes***/"" : "");
d941 1
a941 1
	    CTRACE(tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
d948 1
a948 1
	    *p = ich;		/* Put character in buffer */
d982 5
a986 5
	    /*
	    **	Check status, ignore any non-success.
	    */
	    if (p[1] != '2' )
		continue;
d988 18
a1005 16
	    /*
	    **	Parse fields within returned line into status, ndx, name, data.
	    */
	    indx = NULL;
	    name = NULL;
	    for (i = 0; p[i]; i++)
		if (p[i] == ':' ) {
		    p[i] = '\0';
		    if (!indx) {
			indx = (char *)&p[i+1];
			code = atoi (indx);
		    } else if (!name) {
			name = (char *)&p[i+1];
		    } else {
		       i++;
		       break;
d1031 1
a1031 1
			new = (CSOfield_info *)calloc(1, sizeof(CSOfield_info));
d1100 1
a1100 1
   "<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
d1240 1
a1240 1
	    CTRACE(tfp, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
d1246 1
a1246 1
	    *p = ich;		/* Put character in line */
d1462 1
a1462 1
    CTRACE(tfp, "HTLoadCSO: Looking for %s\n", arg);
d1472 1
a1472 1
	CTRACE(tfp, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n");
d1477 2
a1478 2
	CTRACE(tfp, "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
		    arg);
d1485 2
a1486 2
    CTRACE(tfp, "HTLoadCSO: Connected, writing command `%s' to socket %d\n",
		command, s);
d1491 1
a1491 1
	CTRACE(tfp, "HTLoadCSO: Unable to send command.\n");
d1658 2
a1659 2
    CTRACE(tfp, "HTLoadCSO: Writing command `%s' to socket %d\n",
		command, s);
d1663 1
a1663 1
	CTRACE(tfp, "HTLoadCSO: Unable to send command.\n");
d1700 1
a1700 1
    CTRACE(tfp, "HTGopher: Looking for %s\n", arg);
d1713 1
a1713 1
		CTRACE(tfp, "HTGopher: Passing to CSO/PH gateway.\n");
d1724 1
a1724 1
	CTRACE(tfp, "HTGopher: Passing to finger gateway.\n");
d1727 1
a1727 1
	HTAlert(gettext("Unable to access document!"));
d1827 1
a1827 1
	CTRACE(tfp, "HTGopher: Interrupted on connect; recovering cleanly.\n");
d1833 2
a1834 2
	CTRACE(tfp, "HTGopher: Unable to connect to remote host for `%s'.\n",
		    arg);
d1841 2
a1842 2
    CTRACE(tfp, "HTGopher: Connected, writing command `%s' to socket %d\n",
		command, s);
d1858 1
a1858 1
	CTRACE(tfp, "HTGopher: Unable to send command.\n");
@


1.1
log
@Initial revision
@
text
@d18 7
a24 6
#include "HTUtils.h"		/* Coding convention macros */
#include "tcp.h"
#include "HTAlert.h"
#include "HTParse.h"
#include "HTTCP.h"
#include "HTFinger.h"
d29 1
a29 3
#include "HTGopher.h"

#define HT_EM_SPACE ((char)2)		/* For now */
d34 1
a34 1
#define LINE_LENGTH 256 	/* Bug */
d44 1
a44 1
#define GOPHER_PCBINARY 	'5'
d61 1
a61 7
#define GOPHER_PLUS_PDF 	'P'

#include <ctype.h>

#include "HTParse.h"
#include "HTFormat.h"
#include "HTTCP.h"
d63 1
a63 1
#define FREE(x) if (x) {free(x); x = NULL;}
d68 1
a68 1
#include "HTML.h"
d70 3
a72 1
#include "LYLeaks.h"
d102 1
a102 1
typedef struct _CSOfield_info { 	/* For form-based CSO gateway - FM */
d107 9
a115 9
    int 			id;
    int 			lookup;
    int 			indexed;
    int 			url;
    int 			max_size;
    int 			defreturn;
    int 			explicit_return;
    int 			reserved;
    int 			public;
d127 7
a133 7
    int 		port;
    int 		cur_line;
    int 		cur_off;
    int 		rep_line;
    int 		rep_off;
    int 		public_override;
    int 		field_select;
d194 1
a194 2
    if(TRACE)
	fprintf(stderr,"HTGopher: adding URL: %s\n",addr);
d212 1
a212 1
    char ch;
a213 1
    char address[BIG];
d228 1
a228 1
    PUTS("\n");
d230 1
a230 1
    PUTS("\n");
d235 1
a235 1
	PUTS("Gopher Menu");
d237 1
a237 1
    PUTS("\n");
d239 1
a239 1
    PUTS("\n");
d242 1
a242 1
    PUTS("\n");
d247 1
a247 1
	PUTS("Gopher Menu");
d249 1
a249 1
    PUTS("\n");
d251 1
a251 1
    while ((ch=NEXT_CHAR) != (char)EOF) {
d254 1
a254 3
	    if (TRACE)
		fprintf(stderr,
		    "HTGopher: Interrupted in HTGetCharacter, apparently.\n");
d258 2
a259 2
	if (ch != LF) {
	    *p = ch;		/* Put character in line */
d267 1
a267 2
	    if (TRACE)
		fprintf(stderr, "HTGopher: Menu item: %s\n", line);
d271 1
a271 1
		sprintf(buffer, "Transferred %d bytes", bytes);
d329 2
d333 2
a334 1
		    if (*selector) sprintf(address, "telnet://%s@@%s/",
d336 2
a337 1
		    else sprintf(address, "telnet://%s/", host);
d343 1
a343 1
			sprintf(address, "tn3270://%s@@%s/",
d346 1
a346 1
			sprintf(address, "tn3270://%s/", host);
a348 1
		    char *q;
d403 1
a403 1
		    sprintf(address, "//%s/%c", host, gtype);
d405 8
a412 7
		    q = address+ strlen(address);
		    for(r=selector; *r; r++) {	/* Encode selector string */
			if (acceptable[(unsigned char)*r]) *q++ = *r;
			else {
			    *q++ = HEX_ESCAPE;	/* Means hex coming */
			    *q++ = hex[(TOASCII(*r)) >> 4];
			    *q++ = hex[(TOASCII(*r)) & 15];
a414 2

		    *q++ = '\0';	/* terminate address */
d422 1
d424 1
a424 2
		if (TRACE)
		    fprintf(stderr, "HTGopher: Bad menu item.\n");
d429 1
a429 1
	    PUTS("\n");
d438 1
a438 1
    PUTS("\n");
d440 1
a440 1
    PUTS("\n");
d442 1
a442 1
    PUTS("\n");
d465 1
a465 1
    char ch;
d472 1
a472 1
    PUTS("\n");
d477 1
a477 1
	PUTS("CSO Search Results");
d479 1
a479 1
    PUTS("\n");
d481 1
a481 1
    PUTS("\n");
d487 1
a487 1
	PUTS(" Search Results");
d490 1
a490 1
    PUTS("\n");
d496 1
a496 1
    while ((ch=NEXT_CHAR) != (char)EOF)
d498 1
a498 1
	    if (ch != LF)
d500 1
a500 1
		    *p = ch;		/* Put character in line */
d575 1
a575 1
			    PUTS("\n");
d597 1
a597 1
    PUTS("\n");
d599 1
a599 1
    PUTS("\n");
d615 1
a615 1
    PUTS("\n");
d620 1
a620 1
	PUTS("CSO index");
d622 1
a622 1
    PUTS("\n");
d624 1
a624 1
    PUTS("\n");
d626 1
a626 1
    PUTS("\n");
d632 1
a632 1
       PUTS(" index");
d635 1
a635 1
    PUTS("\nThis is a searchable index of a CSO database.\n");
d637 1
a637 1
    PUTS("\nPress the 's' key and enter search keywords.\n");
d639 2
a640 2
    PUTS("\nThe keywords that you enter will allow you to search on a");
    PUTS(" person's name in the database.\n");
d659 2
a660 2
    PUTS("\n");
    PUTS("\n");
d665 1
a665 1
	PUTS("Gopher index");
d667 1
a667 1
    PUTS("\n");
d669 1
a669 1
    PUTS("\n");
d671 1
a671 1
    PUTS("\n");
d677 1
a677 1
       PUTS(" index");
d680 1
a680 1
    PUTS("\nThis is a searchable Gopher index.\n");
d682 1
a682 1
    PUTS("\nPlease enter search keywords.\n");
d746 3
a748 3
PRIVATE int interpret_cso_key ARGS5(
	char *, 		key,
	char *, 		buf,
d781 1
a781 1
	    return -1;
d872 1
a872 1
	return -1;
d875 1
a875 1
    return 0;
a883 1
    int i;
d897 1
a897 2
    for (i = 0; info[i]; i++)
	info[i] = TOLOWER(info[i]);
d924 1
a924 1
	char *, 	buf,
d927 1
a927 1
    char ch;
d941 1
a941 1
    while ((ch = NEXT_CHAR) != (char)EOF) {
d943 1
a943 4
	    if (TRACE) {
		fprintf(stderr,
		  "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
	    }
d949 2
a950 2
	if (ch != LF) {
	    *p = ch;		/* Put character in buffer */
d1089 1
a1089 1
	char *, 	host,
d1091 1
a1091 1
	char *, 	buf,
d1189 2
a1190 5
			char *temp = (char *)malloc(strlen(ctx.seek) + 20);
			if (temp) {
			    outofmem(__FILE__, "HTLoadCSO");
			}
			sprintf(temp, "Seek fail on %s\n", ctx.seek);
d1219 1
a1219 2
PRIVATE int generate_cso_report ARGS2(
	char *, 	buf,
d1222 1
a1222 1
    char ch;
d1224 1
d1238 1
a1238 1
    while (!stop && (ch = NEXT_CHAR) != (char)EOF) {
d1240 2
a1241 6
	    buf[0] = '\0';
	    if (TRACE) {
		fprintf(stderr,
		  "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
	    }
	    _HTProgress ("Connection interrupted.");
d1245 2
a1246 2
	if (ch != LF) {
	    *p = ch;		/* Put character in line */
d1278 1
a1278 1
			strcpy(buf, "</DL></DL>\n");
d1282 1
a1282 1
			strcpy(buf,
d1286 1
a1286 1
			sprintf(buf,
d1293 1
a1293 1
		sprintf(buf, "<DD>%s\n", rcode);
d1326 1
a1326 1
			sprintf(buf,
d1331 1
a1331 1
			sprintf(buf, "<DT><I>%s</I><DD>", fname);
d1333 1
a1333 2
			i = 0;
			buf[i] = '\0';
d1337 1
a1337 1
				strcat(buf, "&lt;");
a1338 2
				i += 4;
				buf[i] = '\0';
d1340 1
a1340 1
				strcat(buf, "&gt;");
a1341 2
				i += 4;
				buf[i] = '\0';
d1358 1
a1358 2
				buf[i++] = *l++;
				buf[i] = '\0';
d1360 1
a1360 3
				strcat(buf, "<a href=\"");
				i += 9;
				buf[i] = '\0';
d1362 2
a1363 3
				strcat(buf, strtok(href, " \r\n\t,>)\""));
				strcat(buf, "\">");
				i = strlen(buf);
d1365 1
a1365 1
				    buf[i++] = *l++;
d1367 1
a1367 3
				buf[i] = '\0';
				strcat(buf, "</a>");
				i += 4;
d1371 1
a1371 1
			strcat(buf, "\n");
d1375 1
a1375 1
		    sprintf(buf, "<DD>");
d1377 1
a1377 2
		    i = 0;
		    buf[i] = '\0';
d1381 1
a1381 1
			    strcat(buf, "&lt;");
a1382 2
			    i += 4;
			    buf[i] = '\0';
d1384 1
a1384 1
			    strcat(buf, "&gt;");
a1385 2
			    i += 4;
			    buf[i] = '\0';
d1402 1
a1402 2
			    buf[i++] = *l++;
			    buf[i] = '\0';
d1404 1
a1404 3
			    strcat(buf, "<a href=\"");
			    i += 9;
			    buf[i] = '\0';
d1406 2
a1407 3
			    strcat(buf, strtok(href, " \r\n\t,>)\""));
			    strcat(buf, "\">");
			    i = strlen(buf);
d1409 1
a1409 1
				buf[i++] = *l++;
d1411 1
a1411 3
			    buf[i] = '\0';
			    strcat(buf, "</a>");
			    i += 4;
d1415 1
a1415 1
		    strcat(buf, "\n");
d1419 1
a1419 1
		sprintf(buf, "<DD>%s\n", fname ? fname : rcode );
d1426 1
a1426 1
	sprintf(buf, "</DL></DL>\n");
d1429 1
d1442 1
d1445 1
a1445 1
    int status; 			/* tcp return */
d1448 1
a1448 1
    int len, i, j, start, finish, flen, ndx, clen;
d1462 1
a1462 2
    if (TRACE)
	fprintf(stderr, "HTLoadCSO: Looking for %s\n", arg);
d1472 2
a1473 4
	if (TRACE)
	    fprintf(stderr,
		 "HTLoadCSO: Interrupted on connect; recovering cleanly.\n");
	_HTProgress ("Connection interrupted.");
d1477 1
a1477 3
	if (TRACE)
	    fprintf(stderr,
		    "HTLoadCSO: Unable to connect to remote host for `%s'.\n",
d1484 2
a1485 6
    if ((command = (char *)malloc(12)) == NULL)
	outofmem(__FILE__, "HTLoadCSO");
    sprintf(command, "fields%c%c", CR, LF);
    if (TRACE)
	fprintf(stderr,
		"HTLoadCSO: Connected, writing command `%s' to socket %d\n",
d1487 1
a1487 1
    _HTProgress ("Sending CSO/PH request.");
d1491 1
a1491 2
	if (TRACE)
	    fprintf(stderr, "HTLoadCSO: Unable to send command.\n");
d1494 1
a1494 1
    _HTProgress ("CSO/PH request sent; waiting for response.");
d1503 1
a1503 1
	    _HTProgress ("Connection interrupted.");
d1507 1
a1507 1
	    HTAlert("No response from server!");
d1515 3
a1517 6
	char *temp = (char *)malloc(256);
	if (!temp) {
	    outofmem(__FILE__, "HTLoadCSO");
	}
	sprintf(temp, "Sorry, no known way of converting %s to %s.",
		HTAtom_name(format_in), HTAtom_name(format_out));
d1541 2
a1542 1
    sprintf(buf,
d1545 2
a1546 1
    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1548 1
d1562 1
a1562 1
    start = finish = clen = 0;
d1595 1
a1595 1
					if (clen == 0) {
a1596 1
					    clen = 6;
a1598 1
					    clen++;
d1600 2
a1601 4
					sprintf(buf, "%s=\"%s\"",
						fld->name, &content[j+1]);
					StrAllocCat(command, buf);
					clen += strlen(buf);
d1628 1
a1628 1
    if ((clen == 0) || !has_indexed) {
a1643 1
	clen += 11;
a1645 1
	clen += 7;
d1648 1
a1648 3
		sprintf(buf, " %s", fld->name);
		StrAllocCat(command, buf);
		clen += strlen(buf);
d1652 1
a1652 3
    sprintf(buf, "%c%c", CR, LF);
    StrAllocCat(command, buf);
    clen += strlen(buf);
d1655 1
a1655 1
    (*Target->isa->put_block)(Target, command, clen);
d1658 1
a1658 3
    if (TRACE)
	fprintf(stderr,
		"HTLoadCSO: Writing command `%s' to socket %d\n",
d1660 1
a1660 1
    status = NETWRITE(s, command, clen);
d1663 1
a1663 2
	if (TRACE)
	    fprintf(stderr, "HTLoadCSO: Unable to send command.\n");
d1667 1
a1667 1
    generate_cso_report(buf, Target);
d1669 1
a1669 2
    strcpy(buf, "</BODY>\n</HTML>\n");
    (*Target->isa->put_block)(Target, buf, strlen(buf));
d1689 2
a1690 2
    int status; 			/* tcp return */
    char gtype; 			/* Gopher Node type */
d1700 1
a1700 2
    if (TRACE)
	fprintf(stderr, "HTGopher: Looking for %s\n", arg);
d1713 1
a1713 2
		if (TRACE)
		    fprintf(stderr, "HTGopher: Passing to CSO/PH gateway.\n");
d1723 2
a1724 2
	if (TRACE)
	    fprintf(stderr, "HTGopher: Passing to finger gateway.\n");
d1726 4
d1805 2
d1827 2
a1828 4
	if (TRACE)
	    fprintf(stderr,
		    "HTGopher: Interrupted on connect; recovering cleanly.\n");
	_HTProgress ("Connection interrupted.");
d1833 1
a1833 3
	if (TRACE)
	    fprintf(stderr,
		    "HTGopher: Unable to connect to remote host for `%s'.\n",
d1841 1
a1841 3
    if (TRACE)
	fprintf(stderr,
		"HTGopher: Connected, writing command `%s' to socket %d\n",
d1853 1
a1853 1
    _HTProgress ("Sending Gopher request.");
d1858 1
a1858 2
	if (TRACE)
	    fprintf(stderr, "HTGopher: Unable to send command.\n");
d1862 1
a1862 1
    _HTProgress ("Gopher request sent; waiting for response.");
d1938 2
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
