head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.49;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTVMSUtils.c,v 1.39 2013/11/28 11:15:31 tom Exp $
 *
 * MODULE							HTVMSUtil.c
 *		VMS Utility Routines
 *
 * AUTHORS:
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	14 Nov 93  MD	Written
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>
#ifdef VMS
#include <HTFormat.h>
#include <HTStream.h>
#include <UCDefs.h>
#include <UCMap.h>
#include <UCAux.h>
#include <HTFTP.h>
#include <HTTCP.h>
#include <HTVMSUtils.h>
#include <ssdef.h>
#include <jpidef.h>
#include <prvdef.h>
#include <acldef.h>
#include <chpdef.h>
#include <descrip.h>
#include <lib$routines.h>
#include <starlet.h>
#include <rmsdef.h>

#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYLeaks.h>
#include <LYStrings.h>

BOOL HTVMSFileVersions = FALSE;	/* Include version numbers in listing? */

typedef struct {
    unsigned long BufferLength:16;
    unsigned long ItemCode:16;
    unsigned long BufferAddress:32;
    unsigned long ReturnLengthAddress:32;
} ItemStruct;

/* PUBLIC							HTVMS_authSysPrv()
 *		CHECKS IF THIS PROCESS IS AUTHORIZED TO ENABLE SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	YES if SYSPRV is authorized
 */
BOOL HTVMS_authSysPrv(void)
{
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer[2];

    /* fill Item */
    ItemList[0].BufferLength = sizeof(Buffer);
    ItemList[0].BufferAddress = (unsigned long) Buffer;
    ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
    ItemList[0].ItemCode = JPI$_AUTHPRIV;

    /* terminate list */
    ItemList[1].ItemCode = 0;
    ItemList[1].BufferLength = 0;

    /* call system */
    Result = sys$getjpiw(0, 0, 0, ItemList, 0, 0, 0);

    if (Result != SS$_NORMAL)
	return (NO);

    if (Buffer[0] & PRV$M_SYSPRV)
	return (YES);

    return (NO);
}

/* PUBLIC							HTVMS_enableSysPrv()
 *		ENABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_enableSysPrv(void)
{
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];

    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(1, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
	    CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
	}
    }
}

/* PUBLIC							HTVMS_disableSysPrv()
 *		DISABLES SYSPRV
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *
 */
void HTVMS_disableSysPrv(void)
{
    unsigned long Result;
    unsigned long Prv[2], PreviousPrv[2];

    Prv[0] = PRV$M_SYSPRV;
    Prv[1] = 0;
    Result = sys$setprv(0, &Prv, 0, &PreviousPrv);

    if (Result == SS$_NORMAL) {
	if (PreviousPrv[0] & PRV$M_SYSPRV) {
	    CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
	}
    }
}

/* PUBLIC							HTVMS_checkAccess()
 *		CHECKS ACCESS TO FILE FOR CERTAIN USER
 * ON ENTRY:
 *	FileName	The file to be accessed
 *	UserName	Name of the user to check access for.
 *			User nobody, represented by "" is given NO for an answer
 *	Method		Name of the method to be chceked
 *
 * ON EXIT:
 *	returns YES if access is allowed
 *
 */
BOOL HTVMS_checkAccess(const char *FileName,
		       const char *UserName,
		       const char *Method)
{
    unsigned long Result;
    ItemStruct ItemList[2];
    unsigned long Length;
    unsigned long Buffer;
    unsigned long ObjType;

    char *VmsName;

    struct dsc$descriptor_s FileNameDesc;
    struct dsc$descriptor_s UserNameDesc;

    char *colon;

    /* user nobody should access as from account under which server is running */
    if (0 == strcmp(UserName, ""))
	return (NO);

    /* check Filename and convert */
    colon = StrChr(FileName, ':');
    if (colon)
	VmsName = HTVMS_name("", colon + 1);
    else
	VmsName = HTVMS_name("", FileName);

    /* check for GET */
    if (0 == strcmp(Method, "GET")) {
	/* fill Item */
	ItemList[0].BufferLength = sizeof(Buffer);
	ItemList[0].BufferAddress = (unsigned long) &Buffer;
	ItemList[0].ReturnLengthAddress = (unsigned long) &Length;
	ItemList[0].ItemCode = CHP$_FLAGS;

	/* terminate list */
	ItemList[1].ItemCode = 0;
	ItemList[1].BufferLength = 0;

	/* fill input */
	ObjType = ACL$C_FILE;
	Buffer = CHP$M_READ;
	UserNameDesc.dsc$w_length = strlen(UserName);
	UserNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	UserNameDesc.dsc$b_class = DSC$K_CLASS_S;
	UserNameDesc.dsc$a_pointer = (char *) UserName;
	FileNameDesc.dsc$w_length = strlen(VmsName);
	FileNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
	FileNameDesc.dsc$b_class = DSC$K_CLASS_S;
	FileNameDesc.dsc$a_pointer = VmsName;

	/* call system */
	Result = sys$check_access(&ObjType, &FileNameDesc, &UserNameDesc, ItemList);

	if (Result == SS$_NORMAL)
	    return (YES);
	else
	    return (NO);
    }

    return (NO);
}

/* PUBLIC							HTVMS_wwwName()
 *		CONVERTS VMS Name into WWW Name
 * ON ENTRY:
 *	vmsname		VMS file specification (NO NODE)
 *
 * ON EXIT:
 *	returns		www file specification
 *
 * EXAMPLES:
 *	vmsname				wwwname
 *	DISK$USER			disk$user
 *	DISK$USER:			/disk$user/
 *	DISK$USER:[DUNS]		/disk$user/duns
 *	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
 *	[DUNS]				duns
 *	[DUNS.ECHO]			duns/echo
 *	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
 *	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
 *	[.DUNS]				duns
 *	[.DUNS.ECHO]			duns/echo
 *	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
 *	TEST.COM			test.com
 *
 *
 */
const char *HTVMS_wwwName(const char *vmsname)
{
    static char wwwname[LY_MAXPATH];
    const char *src;
    char *dst;
    int dir;

    dst = wwwname;
    src = vmsname;
    dir = 0;
    if (StrChr(src, ':'))
	*(dst++) = '/';
    for (; *src != '\0'; src++) {
	switch (*src) {
	case ':':
	    *(dst++) = '/';
	    break;
	case '-':
	    if (dir) {
		if ((*(src - 1) == '[' ||
		     *(src - 1) == '.' ||
		     *(src - 1) == '-') &&
		    (*(src + 1) == '.' ||
		     *(src + 1) == '-')) {
		    *(dst++) = '/';
		    *(dst++) = '.';
		    *(dst++) = '.';
		} else
		    *(dst++) = '-';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '-';
	    }
	    break;
	case '.':
	    if (dir) {
		if (*(src - 1) != '[')
		    *(dst++) = '/';
	    } else {
		if (*(src - 1) == ']')
		    *(dst++) = '/';
		*(dst++) = '.';
	    }
	    break;
	case '[':
	    dir = 1;
	    break;
	case ']':
	    dir = 0;
	    break;
	default:
	    if (*(src - 1) == ']')
		*(dst++) = '/';
	    *(dst++) = *src;
	    break;
	}
    }
    *(dst++) = '\0';
    return (wwwname);
}

/*
 *	The code below is for directory browsing by VMS Curses clients.
 *	It is based on the newer WWWLib's HTDirBrw.c. - Foteos Macrides
 */
int HTStat(const char *filename,
	   struct stat *info)
{
    /*
       the following stuff does not work in VMS with a normal stat...
       -->   /disk$user/duns/www if www is a directory
       is statted like:  /disk$user/duns/www.dir
       after a normal stat has failed
       -->   /disk$user/duns     if duns is a toplevel directory
       is statted like:  /disk$user/000000/duns.dir
       -->   /disk$user since disk$user is a device
       is statted like:  /disk$user/000000/000000.dir
       -->   /
       searches all devices, no solution yet...
       -->   /vxcern!/disk$cr/wwwteam/login.com
       is not statted but granted with fake information...
     */
    int Result;
    int Len;
    char *Ptr, *Ptr2;
    static char *Name;

    /* try normal stat... */
    Result = stat((char *) filename, info);
    if (Result == 0)
	return (Result);

    /* make local copy */
    StrAllocCopy(Name, filename);

    /* failed,so do device search in case root is requested */
    if (!strcmp(Name, "/")) {	/* root requested */
	return (-1);
    }

    /* failed so this might be a directory, add '.dir' */
    Len = strlen(Name);
    if (Name[Len - 1] == '/')
	Name[Len - 1] = '\0';

    /* fail in case of device */
    Ptr = StrChr(Name + 1, '/');
    if ((Ptr == NULL) && (Name[0] == '/')) {	/* device only... */
	StrAllocCat(Name, "/000000/000000");
    }

    if (Ptr != NULL) {		/* correct filename in case of toplevel dir */
	Ptr2 = StrChr(Ptr + 1, '/');
	if ((Ptr2 == NULL) && (Name[0] == '/')) {
	    char End[256];

	    LYStrNCpy(End, Ptr, sizeof(End) - 1);
	    *(Ptr + 1) = '\0';
	    StrAllocCat(Name, "000000");
	    StrAllocCat(Name, End);
	}
    }

    /* try in case a file on toplevel directory or .DIR was already specified */
    Result = stat(Name, info);
    if (Result == 0)
	return (Result);

    /* add .DIR and try again */
    StrAllocCat(Name, ".dir");
    Result = stat(Name, info);
    return (Result);
}

#ifndef	_POSIX_SOURCE
#define	d_ino	d_fileno	/* compatability */
#ifndef	NULL
#define	NULL	0
#endif
#endif /* !_POSIX_SOURCE */

typedef struct __dirdesc {
    long context;		/* context descriptor for LIB$FIND_FILE calls */
    char dirname[255 + 1];	/* keeps the directory name, including *.* */
    struct dsc$descriptor_s dirname_desc;	/* descriptor of dirname */
} DIR;

static DIR *HTVMSopendir(char *dirname);
static struct dirent *HTVMSreaddir(DIR *dirp);
static int HTVMSclosedir(DIR *dirp);

/*** #include <sys_dirent.h> ***/
/*** "sys_dirent.h" ***/
struct dirent {
    unsigned long d_fileno;	/* file number of entry */
    unsigned short d_namlen;	/* length of string in d_name */
    char d_name[255 + 1];	/* name (up to MAXNAMLEN + 1) */
};

#ifndef	_POSIX_SOURCE
/*
 * It's unlikely to change, but make sure that sizeof d_name above is
 * at least MAXNAMLEN + 1 (more may be added for padding).
 */
#define	MAXNAMLEN	255
/*
 * The macro DIRSIZ(dp) gives the minimum amount of space required to represent
 * a directory entry.  For any directory entry dp->d_reclen >= DIRSIZ(dp).
 * Specific filesystem types may use this macro to construct the value
 * for d_reclen.
 */
#undef	DIRSIZ
#define	DIRSIZ(dp) \
	(((sizeof(struct dirent) - (MAXNAMLEN+1) + ((dp)->d_namlen+1)) +3) & ~3)

#endif /* !_POSIX_SOURCE */

static DIR *HTVMSopendir(char *dirname)
{
    static DIR dir;
    char *closebracket;
    long status;
    struct dsc$descriptor_s entryname_desc;
    struct dsc$descriptor_s dirname_desc;
    static char *DirEntry;
    char Actual[256];
    char VMSentry[256];
    char UnixEntry[256];
    int index;
    char *dot;

    /* check if directory exists */
    /* dirname can look like /disk$user/duns/www/test/multi    */
    /* or like               /disk$user/duns/www/test/multi/   */
    /* DirEntry should look like     disk$user:[duns.www.test]multi in both cases */
    /* dir.dirname should look like  disk$user:[duns.www.test.multi] */
    sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
    if (UnixEntry[strlen(UnixEntry) - 1] != '/')
	strcat(UnixEntry, "/");

    StrAllocCopy(DirEntry, HTVMS_name("", UnixEntry));
    if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
	return (NULL);
    strcpy(dir.dirname, DirEntry);
    index = strlen(DirEntry) - 1;

    if (DirEntry[index] == ']')
	DirEntry[index] = '\0';

    if ((dot = strrchr(DirEntry, '.')) == NULL) {	/* convert disk$user:[duns] into disk$user:[000000]duns.dir */
	char *openbr = strrchr(DirEntry, '[');

	if (!openbr) {		/* convert disk$user: into disk$user:[000000]000000.dir */
	    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
		return (NULL);
	    sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	    StrAllocCat(DirEntry, "[000000]000000.dir");
	} else {
	    char End[256];

	    strcpy(End, openbr + 1);
	    *(openbr + 1) = '\0';
	    StrAllocCat(DirEntry, "000000]");
	    StrAllocCat(DirEntry, End);
	    StrAllocCat(DirEntry, ".dir");
	}
    } else {
	*dot = ']';
	StrAllocCat(DirEntry, ".dir");
    }
    /* lib$find_file needs a fixed-size buffer */
    LYStrNCpy(Actual, DirEntry, sizeof(Actual) - 1);

    dir.context = 0;
    dirname_desc.dsc$w_length = strlen(Actual);
    dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dirname_desc.dsc$a_pointer = (char *) &(Actual);

    /* look for the directory */
    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirname_desc),
			   &entryname_desc,
			   &(dir.context),
			   0, 0, 0, 0);
    if (!(status & 0x01)) {	/* directory not found */
	return (NULL);
    }

    if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
	return (NULL);
    if (HTVMSFileVersions)
	strcat(dir.dirname, "*.*;*");
    else
	strcat(dir.dirname, "*.*");
    dir.context = 0;
    dir.dirname_desc.dsc$w_length = strlen(dir.dirname);
    dir.dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    dir.dirname_desc.dsc$b_class = DSC$K_CLASS_S;
    dir.dirname_desc.dsc$a_pointer = (char *) &(dir.dirname);
    return (&dir);
}

static struct dirent *HTVMSreaddir(DIR *dirp)
{
    static struct dirent entry;
    long status;
    struct dsc$descriptor_s entryname_desc;
    char *space, *slash;
    char VMSentry[256];
    const char *UnixEntry;

    entryname_desc.dsc$w_length = 255;
    entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    entryname_desc.dsc$b_class = DSC$K_CLASS_S;
    entryname_desc.dsc$a_pointer = VMSentry;

    status = lib$find_file(&(dirp->dirname_desc),
			   &entryname_desc,
			   &(dirp->context),
			   0, 0, 0, 0);
    if (status == RMS$_NMF) {	/* no more files */
	return (NULL);
    } else {			/* ok */
	if (!(status & 0x01))
	    return (0);
	if (HTVMSFileVersions)
	    space = StrChr(VMSentry, ' ');
	else
	    space = StrChr(VMSentry, ';');
	if (space)
	    *space = '\0';

	/* convert to unix style... */
	UnixEntry = HTVMS_wwwName(VMSentry);
	slash = strrchr(UnixEntry, '/') + 1;
	strcpy(entry.d_name, slash);
	entry.d_namlen = strlen(entry.d_name);
	entry.d_fileno = 1;
	return (&entry);
    }
}

static int HTVMSclosedir(DIR *dirp)
{
    long status;

    status = lib$find_file_end(&(dirp->context));
    if (!(status & 0x01))
	exit_immediately(status);
    dirp->context = 0;
    return (0);
}

#include <HTAnchor.h>
#include <HTParse.h>
#include <HTBTree.h>
#include <HTFile.h>		/* For HTFileFormat() */
#include <HTAlert.h>
/*
 *  Hypertext object building machinery.
 */
#include <HTML.h>
#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)
#define ABORT_TARGET (*targetClass._free)(target)
struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

#define STRUCT_DIRENT struct dirent

static char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

typedef struct _VMSEntryInfo {
    char *filename;
    char *type;
    char *date;
    unsigned int size;
    BOOLEAN display;		/* show this entry? */
} VMSEntryInfo;

static void free_VMSEntryInfo_contents(VMSEntryInfo * entry_info)
{
    if (entry_info) {
	FREE(entry_info->filename);
	FREE(entry_info->type);
	FREE(entry_info->date);
    }
    /* dont free the struct */
}

int compare_VMSEntryInfo_structs(VMSEntryInfo * entry1, VMSEntryInfo * entry2)
{
    int i, status;
    char date1[16], date2[16], time1[8], time2[8], month[4];

    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size == entry2->size)
	    return (strcasecomp(entry1->filename,
				entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_DATE:
	if (entry1->date && entry2->date) {
	    /*
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 ||
		strlen(entry2->date) != 12) {
		return (strcasecomp(entry1->filename,
				    entry2->filename));
	    }
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[7] != ' ') {
		strcpy(date1, "9999");
		strcpy(time1, (char *) &entry1->date[7]);
	    } else {
		strcpy(date1, (char *) &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    LYStrNCpy(month, entry1->date, 3);
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    StrNCat(date1, (char *) &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ') {
		date1[6] = '0';
	    }
	    strcat(date1, time1);
	    if (entry2->date[7] != ' ') {
		strcpy(date2, "9999");
		strcpy(time2, (char *) &entry2->date[7]);
	    } else {
		strcpy(date2, (char *) &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    LYStrNCpy(month, entry2->date, 3);
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    StrNCat(date2, (char *) &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ') {
		date2[6] = '0';
	    }
	    strcat(date2, time2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		return (status);
	    /* else fall to filename comparison */
	}
	return (strcasecomp(entry1->filename,
			    entry2->filename));
    case FILE_BY_NAME:
    default:
	return (strcmp(entry1->filename,
		       entry2->filename));
    }
}

/*							HTVMSBrowseDir()
 *
 *	This function generates a directory listing as an HTML-object
 *	for local file URL's.  It assumes the first two elements of
 *	of the path are a device followed by a directory:
 *
 *		file://localhost/device/directory[/[foo]]
 *
 *	Will not accept 000000 as a directory name.
 *	Will offer links to parent through the top directory, unless
 *	a terminal slash was included in the calling URL.
 *
 *	Returns HT_LOADED on success, HTLoadError() messages on error.
 *
 *	Developed for Lynx by Foteos Macrides (macrides@@sci.wfeb.edu).
 */
int HTVMSBrowseDir(const char *address,
		   HTParentAnchor *anchor,
		   HTFormat format_out,
		   HTStream *sink)
{
    HTStructured *target;
    HTStructuredClass targetClass;
    char *pathname = HTParse(address, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *tail = NULL;
    char *title = NULL;
    char *header = NULL;
    char *parent = NULL;
    char *relative = NULL;
    char *cp, *cp1;
    int pathend, len;
    DIR *dp;
    struct stat file_info;
    time_t NowTime;
    static char ThisYear[8];
    VMSEntryInfo *entry_info = 0;
    char string_buffer[64];

    HTUnEscape(pathname);
    CTRACE((tfp, "HTVMSBrowseDir: Browsing `%s\'\n", pathname));

    /*
     * Require at least two elements (presumably a device and directory) and
     * disallow the device root (000000 directory).  Symbolic paths (e.g.,
     * sys$help) should have been translated and expanded (e.g., to
     * /sys$sysroot/syshlp) before calling this routine.
     */
    if (((*pathname != '/') ||
	 (cp = StrChr(pathname + 1, '/')) == NULL ||
	 *(cp + 1) == '\0' ||
	 0 == StrNCmp((cp + 1), "000000", 6)) ||
	(dp = HTVMSopendir(pathname)) == NULL) {
	FREE(pathname);
	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
    }

    /*
     * Set up the output stream.
     */
    _HTProgress(BUILDING_DIR_LIST);
    if (UCLYhndl_HTFile_for_unspec >= 0) {
	HTAnchor_setUCInfoStage(anchor,
				UCLYhndl_HTFile_for_unspec,
				UCT_STAGE_PARSER,
				UCT_SETBY_DEFAULT);
    }
    target = HTML_new(anchor, format_out, sink);
    targetClass = *(target->isa);

    /*
     * Set up the offset string of the anchor reference, and strings for the
     * title and header.
     */
    cp = strrchr(pathname, '/');	/* find lastslash */
    StrAllocCopy(tail, (cp + 1));	/* take slash off the beginning */
    if (*tail != '\0') {
	StrAllocCopy(title, tail);
	*cp = '\0';
	if ((cp1 = strrchr(pathname, '/')) != NULL &&
	    cp1 != pathname &&
	    StrNCmp((cp1 + 1), "000000", 6))
	    StrAllocCopy(parent, (cp1 + 1));
	*cp = '/';
    } else {
	pathname[strlen(pathname) - 1] = '\0';
	cp = strrchr(pathname, '/');
	StrAllocCopy(title, (cp + 1));
	pathname[strlen(pathname)] = '/';
    }
    StrAllocCopy(header, pathname);

    /*
     * Initialize path name for HTStat().
     */
    pathend = strlen(pathname);
    if (*(pathname + pathend - 1) != '/') {
	StrAllocCat(pathname, "/");
	pathend++;
    }

    /*
     * Output the title and header.
     */
    START(HTML_HTML);
    PUTC('\n');
    START(HTML_HEAD);
    PUTC('\n');
    HTUnEscape(title);
    START(HTML_TITLE);
    PUTS(title);
    PUTS(" directory");
    END(HTML_TITLE);
    PUTC('\n');
    FREE(title);
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_BODY);
    PUTC('\n');
    HTUnEscape(header);
    START(HTML_H1);
    PUTS(header);
    END(HTML_H1);
    PUTC('\n');
    if (HTDirReadme == HT_DIR_README_TOP) {
	FILE *fp;

	if (header[strlen(header) - 1] != '/')
	    StrAllocCat(header, "/");
	StrAllocCat(header, HT_DIR_README_FILE);
	if ((fp = fopen(header, "r")) != NULL) {
	    START(HTML_PRE);
	    for (;;) {
		char c = fgetc(fp);

		if (c == (char) EOF)
		    break;
#ifdef NOTDEFINED
		switch (c) {
		case '&':
		case '<':
		case '>':
		    PUTC('&');
		    PUTC('#');
		    PUTC((char) (c / 10));
		    PUTC((char) (c % 10));
		    PUTC(';');
		    break;
		default:
		    PUTC(c);
		}
#else
		PUTC(c);
#endif /* NOTDEFINED */
	    }
	    END(HTML_PRE);
	    fclose(fp);
	}
    }
    FREE(header);
    if (parent) {
	HTSprintf0(&relative, "%s/..", tail);
	HTStartAnchor(target, "", relative);
	PUTS("Up to ");
	HTUnEscape(parent);
	PUTS(parent);
	END(HTML_A);
	START(HTML_P);
	PUTC('\n');
	FREE(relative);
	FREE(parent);
    }

    /*
     * Set up the date comparison.
     */
    NowTime = time(NULL);
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
    ThisYear[4] = '\0';

    /*
     * Now, generate the Btree and put it out to the output stream.
     */
    {
	char dottest = 2;	/* To avoid two strcmp() each time */
	STRUCT_DIRENT *dirbuf;
	HTBTree *bt;

	/* Set up sort key and initialize BTree */
	bt = HTBTree_new((HTComparer) compare_VMSEntryInfo_structs);

	/* Build tree */
	while ((dirbuf = HTVMSreaddir(dp))) {
	    HTAtom *encoding = NULL;
	    HTFormat format;

	    /* Skip if not used */
	    if (!dirbuf->d_ino) {
		continue;
	    }

	    /* Current and parent directories are never shown in list */
	    if (dottest && (!strcmp(dirbuf->d_name, ".") ||
			    !strcmp(dirbuf->d_name, ".."))) {
		dottest--;
		continue;
	    }

	    /* Don't show the selective enabling file
	     * unless version numbers are included */
	    if (!strcasecomp(dirbuf->d_name, HT_DIR_ENABLE_FILE)) {
		continue;
	    }

	    /* Skip files beginning with a dot? */
	    if ((no_dotfiles || !show_dotfiles) && *dirbuf->d_name == '.') {
		continue;
	    }

	    /* OK, make an lstat() and get a key ready. */
	    *(pathname + pathend) = '\0';
	    StrAllocCat(pathname, dirbuf->d_name);
	    if (HTStat(pathname, &file_info)) {
		/* for VMS the failure here means the file is not readable...
		   we however continue to browse through the directory... */
		continue;
	    }
	    entry_info = (VMSEntryInfo *) malloc(sizeof(VMSEntryInfo));
	    if (entry_info == NULL)
		outofmem(__FILE__, "HTVMSBrowseDir");
	    entry_info->type = 0;
	    entry_info->size = 0;
	    entry_info->date = 0;
	    entry_info->filename = 0;
	    entry_info->display = TRUE;

	    /* Get the type */
	    format = HTFileFormat(dirbuf->d_name, &encoding,
				  (const char **) &cp);
	    if (!cp) {
		if (!StrNCmp(HTAtom_name(format), "application", 11)) {
		    cp = HTAtom_name(format) + 12;
		    if (!StrNCmp(cp, "x-", 2))
			cp += 2;
		} else
		    cp = HTAtom_name(format);
	    }
	    StrAllocCopy(entry_info->type, cp);

	    StrAllocCopy(entry_info->filename, dirbuf->d_name);
	    if (S_ISDIR(file_info.st_mode)) {
		/* strip .DIR part... */
		char *dot;

		dot = strstr(entry_info->filename, ".DIR");
		if (dot)
		    *dot = '\0';
		LYLowerCase(entry_info->filename);
		StrAllocCopy(entry_info->type, "Directory");
	    } else {
		if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
		    cp = entry_info->filename;
		} else {
		    cp += 4;
		    if (!StrNCmp(cp, "ME", 2)) {
			cp += 2;
			while (cp && *cp && *cp != '.') {
			    cp++;
			}
		    } else if (!StrNCmp(cp, ".ME", 3)) {
			cp = (entry_info->filename +
			      strlen(entry_info->filename));
		    } else {
			cp = entry_info->filename;
		    }
		}
		LYLowerCase(cp);
		if (((len = strlen(entry_info->filename)) > 2) &&
		    entry_info->filename[len - 1] == 'z') {
		    if (entry_info->filename[len - 2] == '.' ||
			entry_info->filename[len - 2] == '_')
			entry_info->filename[len - 1] = 'Z';
		}
	    }

	    /* Get the date */
	    {
		char *t = (char *) ctime((const time_t *) &file_info.st_ctime);

		*(t + 24) = '\0';

		StrAllocCopy(entry_info->date, (t + 4));
		*((entry_info->date) + 7) = '\0';
		if ((atoi((t + 19))) < atoi(ThisYear))
		    StrAllocCat(entry_info->date, (t + 19));
		else {
		    StrAllocCat(entry_info->date, (t + 11));
		    *((entry_info->date) + 12) = '\0';
		}
	    }

	    /* Get the size */
	    if (!S_ISDIR(file_info.st_mode))
		entry_info->size = (unsigned int) file_info.st_size;
	    else
		entry_info->size = 0;

	    /* Now, update the BTree etc. */
	    if (entry_info->display) {
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    }

	}			/* End while HTVMSreaddir() */

	FREE(pathname);
	HTVMSclosedir(dp);

	START(HTML_PRE);
	/*
	 * Run through the BTree printing out in order
	 */
	{
	    HTBTElement *ele;
	    int i;

	    for (ele = HTBTree_next(bt, NULL);
		 ele != NULL;
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (VMSEntryInfo *) HTBTree_object(ele);

		/* Output the date */
		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else
		    PUTS("     * ");

		/* Output the type */
		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 15; i++)
			PUTC(entry_info->type[i]);
		    for (; i < 17; i++)
			PUTC(' ');

		}

		/* Output the link for the name */
		HTDirEntry(target, tail, entry_info->filename);
		PUTS(entry_info->filename);
		END(HTML_A);

		/* Output the size */
		if (entry_info->size) {
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %d bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %dKb",
				entry_info->size / 1024);
		    PUTS(string_buffer);
		}

		PUTC('\n');	/* end of this entry */

		free_VMSEntryInfo_contents(entry_info);
	    }
	}

	HTBTreeAndObject_free(bt);

    }				/* End of both BTree loops */

    /*
     * Complete the output stream.
     */
    END(HTML_PRE);
    PUTC('\n');
    END(HTML_BODY);
    PUTC('\n');
    END(HTML_HTML);
    PUTC('\n');
    FREE(tail);
    FREE_TARGET;

    return HT_LOADED;

}				/* End of directory reading section */

/*
 * Remove all versions of the given file.  We assume there are no permissions
 * problems, since we do this mainly for removing temporary files.
 */
int HTVMS_remove(char *filename)
{
    int code = remove(filename);	/* return the first status code */

    while (remove(filename) == 0) ;
    return code;
}

/*
 * Remove all older versions of the given file.  We may fail to remove some
 * version due to permissions -- the loop stops either at that point, or when
 * we run out of older versions to remove.
 */
void HTVMS_purge(char *filename)
{
    char *older_file = 0;
    char *oldest_file = 0;
    struct stat sb;

    StrAllocCopy(older_file, filename);
    StrAllocCat(older_file, ";-1");

    while (remove(older_file) == 0) ;
    /*
     * If we do not have any more older versions, it is safe to rename the
     * current file to version #1.
     */
    if (stat(older_file, &sb) != 0) {
	StrAllocCopy(oldest_file, filename);
	StrAllocCat(oldest_file, ";1");
	rename(older_file, oldest_file);
	FREE(oldest_file);
    }

    FREE(older_file);
}
#endif /* VMS */
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 2

/* MODULE							HTVMSUtil.c
d171 1
a171 1
    colon = strchr(FileName, ':');
d248 1
a248 1
    if (strchr(src, ':'))
d345 1
a345 1
    Ptr = strchr(Name + 1, '/');
d351 1
a351 1
	Ptr2 = strchr(Ptr + 1, '/');
d355 1
a355 1
	    LYstrncpy(End, Ptr, sizeof(End) - 1);
d470 1
a470 1
    LYstrncpy(Actual, DirEntry, sizeof(Actual) - 1);
d530 1
a530 1
	    space = strchr(VMSentry, ' ');
d532 1
a532 1
	    space = strchr(VMSentry, ';');
d648 1
a648 2
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
d657 1
a657 1
	    strncat(date1, (char *) &entry1->date[4], 2);
d670 1
a670 2
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
d679 1
a679 1
	    strncat(date2, (char *) &entry2->date[4], 2);
d750 1
a750 1
	 (cp = strchr(pathname + 1, '/')) == NULL ||
d752 1
a752 1
	 0 == strncmp((cp + 1), "000000", 6)) ||
d782 1
a782 1
	    strncmp((cp1 + 1), "000000", 6))
d941 1
a941 1
		if (!strncmp(HTAtom_name(format), "application", 11)) {
d943 1
a943 1
		    if (!strncmp(cp, "x-", 2))
d965 1
a965 1
		    if (!strncmp(cp, "ME", 2)) {
d970 1
a970 1
		    } else if (!strncmp(cp, ".ME", 3)) {
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d3 12
a14 12
**		VMS Utility Routines
**
** AUTHORS:
**	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
**
** HISTORY:
**	14 Nov 93  MD	Written
**
** BUGS:
**
**
*/
d17 1
d41 1
a41 1
PUBLIC BOOL HTVMSFileVersions = FALSE; /* Include version numbers in listing? */
d44 4
a47 4
   unsigned long BufferLength : 16;
   unsigned long ItemCode : 16;
   unsigned long BufferAddress : 32;
   unsigned long ReturnLengthAddress : 32;
d51 8
a58 8
**		CHECKS IF THIS PROCESS IS AUTHORIZED TO ENABLE SYSPRV
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	YES if SYSPRV is authorized
*/
PUBLIC BOOL HTVMS_authSysPrv NOARGS
d60 17
a76 17
unsigned long Result;
ItemStruct ItemList[2];
unsigned long Length;
unsigned long Buffer[2];

  /* fill Item */
  ItemList[0].BufferLength = sizeof(Buffer);
  ItemList[0].BufferAddress = (unsigned long)Buffer;
  ItemList[0].ReturnLengthAddress = (unsigned long)&Length;
  ItemList[0].ItemCode = JPI$_AUTHPRIV;

  /* terminate list */
  ItemList[1].ItemCode = 0;
  ItemList[1].BufferLength = 0;

  /* call system */
  Result = sys$getjpiw(0, 0, 0, ItemList, 0, 0, 0);
d78 2
a79 2
  if (Result != SS$_NORMAL)
     return(NO);
d81 2
a82 2
  if (Buffer[0] & PRV$M_SYSPRV)
     return(YES);
d84 1
a84 1
  return(NO);
a86 2


d88 8
a95 8
**		ENABLES SYSPRV
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**
*/
PUBLIC void HTVMS_enableSysPrv NOARGS
d97 2
a98 2
unsigned long Result;
unsigned long Prv[2], PreviousPrv[2];
d100 9
a108 9
   Prv[0] = PRV$M_SYSPRV;
   Prv[1] = 0;
   Result = sys$setprv(1,&Prv,0,&PreviousPrv);

   if (Result == SS$_NORMAL) {
       if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
	   CTRACE((tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n"));
       }
   }
a110 2


d112 8
a119 8
**		DISABLES SYSPRV
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**
*/
PUBLIC void HTVMS_disableSysPrv NOARGS
d121 2
a122 2
unsigned long Result;
unsigned long Prv[2], PreviousPrv[2];
d124 9
a132 9
   Prv[0] = PRV$M_SYSPRV;
   Prv[1] = 0;
   Result = sys$setprv(0,&Prv,0,&PreviousPrv);

   if (Result == SS$_NORMAL) {
       if (PreviousPrv[0] & PRV$M_SYSPRV) {
	   CTRACE((tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n"));
       }
   }
a134 2


d136 14
a149 15
**		CHECKS ACCESS TO FILE FOR CERTAIN USER
** ON ENTRY:
**	FileName	The file to be accessed
**	UserName	Name of the user to check access for.
**			User nobody, represented by "" is given NO for an answer
**	Method		Name of the method to be chceked
**
** ON EXIT:
**	returns YES if access is allowed
**
*/
PUBLIC BOOL HTVMS_checkAccess ARGS3(
	CONST char *, FileName,
	CONST char *, UserName,
	CONST char *, Method)
d151 56
a206 57
unsigned long Result;
ItemStruct ItemList[2];
unsigned long Length;
unsigned long Buffer;
unsigned long ObjType;

char *VmsName;

struct dsc$descriptor_s FileNameDesc;
struct dsc$descriptor_s UserNameDesc;

char *colon;

   /* user nobody should access as from account under which server is running */
   if (0 == strcmp(UserName,""))
      return(NO);

   /* check Filename and convert */
   colon = strchr(FileName,':');
   if (colon)
      VmsName = HTVMS_name("",colon+1);
   else
      VmsName = HTVMS_name("",FileName);

   /* check for GET */
   if (0 == strcmp(Method,"GET"))
   {
     /* fill Item */
     ItemList[0].BufferLength = sizeof(Buffer);
     ItemList[0].BufferAddress = (unsigned long)&Buffer;
     ItemList[0].ReturnLengthAddress = (unsigned long)&Length;
     ItemList[0].ItemCode = CHP$_FLAGS;

     /* terminate list */
     ItemList[1].ItemCode = 0;
     ItemList[1].BufferLength = 0;

     /* fill input */
     ObjType = ACL$C_FILE;
     Buffer = CHP$M_READ;
     UserNameDesc.dsc$w_length = strlen(UserName);
     UserNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
     UserNameDesc.dsc$b_class = DSC$K_CLASS_S;
     UserNameDesc.dsc$a_pointer = (char *)UserName;
     FileNameDesc.dsc$w_length = strlen(VmsName);
     FileNameDesc.dsc$b_dtype = DSC$K_DTYPE_T;
     FileNameDesc.dsc$b_class = DSC$K_CLASS_S;
     FileNameDesc.dsc$a_pointer = VmsName;

     /* call system */
     Result = sys$check_access(&ObjType,&FileNameDesc,&UserNameDesc,ItemList);

     if (Result == SS$_NORMAL)
	return(YES);
     else
	return(NO);
   }
d208 1
a208 1
   return(NO);
a210 2


d212 25
a236 26
**		CONVERTS VMS Name into WWW Name
** ON ENTRY:
**	vmsname		VMS file specification (NO NODE)
**
** ON EXIT:
**	returns		www file specification
**
** EXAMPLES:
**	vmsname				wwwname
**	DISK$USER			disk$user
**	DISK$USER:			/disk$user/
**	DISK$USER:[DUNS]		/disk$user/duns
**	DISK$USER:[DUNS.ECHO]		/disk$user/duns/echo
**	[DUNS]				duns
**	[DUNS.ECHO]			duns/echo
**	[DUNS.ECHO.-.TRANS]		duns/echo/../trans
**	[DUNS.ECHO.--.TRANS]		duns/echo/../../trans
**	[.DUNS]				duns
**	[.DUNS.ECHO]			duns/echo
**	[.DUNS.ECHO]TEST.COM		duns/echo/test.com
**	TEST.COM			test.com
**
**
*/
PUBLIC char * HTVMS_wwwName ARGS1(
	CONST char *,	vmsname)
d238 58
a295 50
static char wwwname[LY_MAXPATH];
CONST char *src;
char *dst;
int dir;
   dst = wwwname;
   src = vmsname;
   dir = 0;
   if (strchr(src,':')) *(dst++) = '/';
   for ( ; *src != '\0' ; src++)
   {
      switch(*src)
      {
	 case ':':  *(dst++) = '/'; break;
	 case '-': if (dir)
		   {
		      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') &&
			  (*(src+1)=='.' || *(src+1)=='-'))
		      {
			  *(dst++) = '/';
			  *(dst++) = '.';
			  *(dst++) = '.';
		      }
		      else
			  *(dst++) = '-';
		   }
		   else
		   {
		      if (*(src-1) == ']') *(dst++) = '/';
		      *(dst++) = '-';
		   }
		   break;
	 case '.': if (dir)
		   {
		      if (*(src-1) != '[') *(dst++) = '/';
		   }
		   else
		   {
		      if (*(src-1) == ']') *(dst++) = '/';
		      *(dst++) = '.';
		   }
		   break;
	 case '[': dir = 1; break;
	 case ']': dir = 0; break;
	 default:  if (*(src-1) == ']') *(dst++) = '/';
		   *(dst++) = *src;
		   break;
      }
   }
   *(dst++) = '\0';
   return(wwwname);
a297 1

d299 5
a303 6
**	The code below is for directory browsing by VMS Curses clients.
**	It is based on the newer WWWLib's HTDirBrw.c. - Foteos Macrides
*/
PUBLIC int HTStat ARGS2(
	CONST char *, filename,
	struct stat *, info)
d305 64
a368 67
   /*
      the following stuff does not work in VMS with a normal stat...
      -->   /disk$user/duns/www if www is a directory
		is statted like:	/disk$user/duns/www.dir
		after a normal stat has failed
      -->   /disk$user/duns	if duns is a toplevel directory
		is statted like:	/disk$user/000000/duns.dir
      -->   /disk$user since disk$user is a device
		is statted like:	/disk$user/000000/000000.dir
      -->   /
		searches all devices, no solution yet...
      -->   /vxcern!/disk$cr/wwwteam/login.com
		is not statted but granted with fake information...
   */
int Result;
int Len;
char *Ptr, *Ptr2;
static char *Name;

   /* try normal stat... */
   Result = stat((char *)filename,info);
   if (Result == 0)
      return(Result);

   /* make local copy */
   StrAllocCopy(Name,filename);

   /* failed,so do device search in case root is requested */
   if (!strcmp(Name,"/"))
   {  /* root requested */
      return(-1);
   }

   /* failed so this might be a directory, add '.dir' */
   Len = strlen(Name);
   if (Name[Len-1] == '/')
      Name[Len-1] = '\0';

   /* fail in case of device */
   Ptr = strchr(Name+1,'/');
   if ((Ptr == NULL) && (Name[0] == '/'))
   {  /* device only... */
      StrAllocCat(Name, "/000000/000000");
   }

   if (Ptr != NULL)
   {  /* correct filename in case of toplevel dir */
      Ptr2 = strchr(Ptr+1,'/');
      if ((Ptr2 == NULL) && (Name[0] == '/'))
      {
	 char End[256];
	 LYstrncpy(End, Ptr, sizeof(End) - 1);
	 *(Ptr+1) = '\0';
	 StrAllocCat(Name, "000000");
	 StrAllocCat(Name, End);
      }
   }

   /* try in case a file on toplevel directory or .DIR was already specified */
   Result = stat(Name,info);
   if (Result == 0)
      return(Result);

   /* add .DIR and try again */
   StrAllocCat(Name, ".dir");
   Result = stat(Name,info);
   return(Result);
d376 1
a376 1
#endif	/* !_POSIX_SOURCE */
d378 4
a381 4
typedef	struct __dirdesc {
	long	context;	/* context descriptor for LIB$FIND_FILE calls */
	char	dirname[255+1];	/* keeps the directory name, including *.* */
	struct dsc$descriptor_s dirname_desc;	/* descriptor of dirname */
d384 3
a386 3
PRIVATE	DIR *HTVMSopendir(char *dirname);
PRIVATE	struct dirent *HTVMSreaddir(DIR *dirp);
PRIVATE	int HTVMSclosedir(DIR *dirp);
d390 4
a393 4
struct	dirent {
	unsigned long	d_fileno;	/* file number of entry */
	unsigned short	d_namlen;	/* length of string in d_name */
	char		d_name[255+1];	/* name (up to MAXNAMLEN + 1) */
d412 57
a468 1
#endif	/* !_POSIX_SOURCE */
d470 19
d490 12
a501 93
PRIVATE DIR *HTVMSopendir(char *dirname)
{
static DIR dir;
char *closebracket;
long status;
struct dsc$descriptor_s entryname_desc;
struct dsc$descriptor_s dirname_desc;
static char *DirEntry;
char Actual[256];
char VMSentry[256];
char UnixEntry[256];
int index;
char *dot;

   /* check if directory exists */
   /* dirname can look like /disk$user/duns/www/test/multi    */
   /* or like               /disk$user/duns/www/test/multi/   */
   /* DirEntry should look like     disk$user:[duns.www.test]multi in both cases */
   /* dir.dirname should look like  disk$user:[duns.www.test.multi] */
   sprintf(UnixEntry, "%.*s", sizeof(UnixEntry) - 2, dirname);
   if (UnixEntry[strlen(UnixEntry)-1] != '/')
      strcat(UnixEntry,"/");

   StrAllocCopy(DirEntry, HTVMS_name("",UnixEntry));
   if (strlen(DirEntry) > sizeof(dir.dirname) - 1)
      return (NULL);
   strcpy(dir.dirname, DirEntry);
   index = strlen(DirEntry) - 1;

   if (DirEntry[index] == ']')
      DirEntry[index] = '\0';

   if ((dot = strrchr(DirEntry,'.')) == NULL)
   {  /* convert disk$user:[duns] into disk$user:[000000]duns.dir */
      char *openbr = strrchr(DirEntry,'[');
      if (!openbr)
      { /* convert disk$user: into disk$user:[000000]000000.dir */
         if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
            return (NULL);
         sprintf(dir.dirname, "%.*s[000000]", sizeof(dir.dirname) - 9, DirEntry);
	 StrAllocCat(DirEntry,"[000000]000000.dir");
      }
      else
      {
	 char End[256];
	 strcpy(End,openbr+1);
	 *(openbr+1) = '\0';
	 StrAllocCat(DirEntry,"000000]");
	 StrAllocCat(DirEntry,End);
	 StrAllocCat(DirEntry,".dir");
      }
   }
   else
   {
      *dot = ']';
      StrAllocCat(DirEntry,".dir");
   }
   /* lib$find_file needs a fixed-size buffer */
   LYstrncpy(Actual, DirEntry, sizeof(Actual)-1);

   dir.context = 0;
   dirname_desc.dsc$w_length = strlen(Actual);
   dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   dirname_desc.dsc$b_class = DSC$K_CLASS_S;
   dirname_desc.dsc$a_pointer = (char *)&(Actual);

   /* look for the directory */
   entryname_desc.dsc$w_length = 255;
   entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   entryname_desc.dsc$b_class = DSC$K_CLASS_S;
   entryname_desc.dsc$a_pointer = VMSentry;

   status = lib$find_file(&(dirname_desc),
			  &entryname_desc,
			  &(dir.context),
			  0,0,0,0);
   if (!(status & 0x01))
   { /* directory not found */
      return(NULL);
   }

   if (strlen(dir.dirname) > sizeof(dir.dirname) - 10)
       return (NULL);
   if (HTVMSFileVersions)
       strcat(dir.dirname,"*.*;*");
   else
       strcat(dir.dirname,"*.*");
   dir.context = 0;
   dir.dirname_desc.dsc$w_length = strlen(dir.dirname);
   dir.dirname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   dir.dirname_desc.dsc$b_class = DSC$K_CLASS_S;
   dir.dirname_desc.dsc$a_pointer = (char *)&(dir.dirname);
   return(&dir);
d504 1
a504 1
PRIVATE struct dirent *HTVMSreaddir(DIR *dirp)
d506 36
a541 38
static struct dirent entry;
long status;
struct dsc$descriptor_s entryname_desc;
char *space, *slash;
char VMSentry[256];
char *UnixEntry;

   entryname_desc.dsc$w_length = 255;
   entryname_desc.dsc$b_dtype = DSC$K_DTYPE_T;
   entryname_desc.dsc$b_class = DSC$K_CLASS_S;
   entryname_desc.dsc$a_pointer = VMSentry;

   status = lib$find_file(&(dirp->dirname_desc),
			  &entryname_desc,
			  &(dirp->context),
			  0,0,0,0);
   if (status == RMS$_NMF)
   { /* no more files */
      return(NULL);
   }
   else
   { /* ok */
      if (!(status & 0x01)) return(0);
      if (HTVMSFileVersions)
	  space = strchr(VMSentry,' ');
      else
	  space = strchr(VMSentry,';');
      if (space)
	 *space = '\0';

      /* convert to unix style... */
      UnixEntry = HTVMS_wwwName(VMSentry);
      slash = strrchr(UnixEntry,'/') + 1;
      strcpy(entry.d_name,slash);
      entry.d_namlen = strlen(entry.d_name);
      entry.d_fileno = 1;
      return(&entry);
   }
d544 1
a544 1
PRIVATE int HTVMSclosedir(DIR *dirp)
d546 1
a546 1
long status;
d548 5
a552 4
   status = lib$find_file_end(&(dirp->context));
   if (!(status & 0x01)) exit(status);
   dirp->context = 0;
   return(0);
d558 1
a558 1
#include <HTFile.h>	/* For HTFileFormat() */
d561 2
a562 2
**  Hypertext object building machinery.
*/
d571 2
a572 2
	CONST HTStructuredClass *	isa;
	/* ... */
d577 4
a580 2
PRIVATE char * months[12] = {
    "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
d584 3
a586 3
    char *       filename;
    char *       type;
    char *       date;
d588 1
a588 1
    BOOLEAN      display;  /* show this entry? */
d591 1
a591 1
PRIVATE void free_VMSEntryInfo_contents ARGS1(VMSEntryInfo *,entry_info)
d598 1
a598 1
   /* dont free the struct */
d601 1
a601 2
PUBLIC int compare_VMSEntryInfo_structs ARGS2(VMSEntryInfo *,entry1,
					      VMSEntryInfo *,entry2)
d606 94
a699 96
    switch(HTfileSortMethod)
      {
	case FILE_BY_SIZE:
			/* both equal or both 0 */
			if(entry1->size == entry2->size)
			    return(strcasecomp(entry1->filename,
					       entry2->filename));
			else
			    if(entry1->size > entry2->size)
				return(1);
			    else
				return(-1);
	case FILE_BY_TYPE:
			if(entry1->type && entry2->type) {
			    status = strcasecomp(entry1->type, entry2->type);
			    if(status)
				return(status);
			    /* else fall to filename comparison */
			}
			return (strcasecomp(entry1->filename,
					    entry2->filename));
	case FILE_BY_DATE:
			if(entry1->date && entry2->date) {
			    /*
			    ** Make sure we have the correct length. - FM
			    */
			    if (strlen(entry1->date) != 12 ||
				strlen(entry2->date) != 12) {
				return (strcasecomp(entry1->filename,
						    entry2->filename));
			    }
			    /*
			    ** Set up for sorting in reverse
			    ** chronological order. - FM
			    */
			    if (entry1->date[7] != ' ') {
				strcpy(date1, "9999");
				strcpy(time1, (char *)&entry1->date[7]);
			    } else {
				strcpy(date1, (char *)&entry1->date[8]);
				strcpy(time1, "00:00");
			    }
			    strncpy(month, entry1->date, 3);
			    month[3] = '\0';
			    for (i = 0; i < 12; i++) {
				if (!strcasecomp(month, months[i])) {
				    break;
				}
			    }
			    i++;
			    sprintf(month, "%02d", i);
			    strcat(date1, month);
			    strncat(date1, (char *)&entry1->date[4], 2);
			    date1[8] = '\0';
			    if (date1[6] == ' ') {
				date1[6] = '0';
			    }
			    strcat(date1, time1);
			    if (entry2->date[7] != ' ') {
				strcpy(date2, "9999");
				strcpy(time2, (char *)&entry2->date[7]);
			    } else {
				strcpy(date2, (char *)&entry2->date[8]);
				strcpy(time2, "00:00");
			    }
			    strncpy(month, entry2->date, 3);
			    month[3] = '\0';
			    for (i = 0; i < 12; i++) {
				if (!strcasecomp(month, months[i])) {
				    break;
				}
			    }
			    i++;
			    sprintf(month, "%02d", i);
			    strcat(date2, month);
			    strncat(date2, (char *)&entry2->date[4], 2);
			    date2[8] = '\0';
			    if (date2[6] == ' ') {
				date2[6] = '0';
			    }
			    strcat(date2, time2);
			    /*
			    ** Do the comparison. - FM
			    */
			    status = strcasecomp(date2, date1);
			    if(status)
				return(status);
			    /* else fall to filename comparison */
			}
			return (strcasecomp(entry1->filename,
					    entry2->filename));
	case FILE_BY_NAME:
	default:
			return (strcmp(entry1->filename,
					    entry2->filename));
      }
a701 1

d703 19
a721 21
**
**	This function generates a directory listing as an HTML-object
**	for local file URL's.  It assumes the first two elements of
**	of the path are a device followed by a directory:
**
**		file://localhost/device/directory[/[foo]]
**
**	Will not accept 000000 as a directory name.
**	Will offer links to parent through the top directory, unless
**	a terminal slash was included in the calling URL.
**
**	Returns HT_LOADED on success, HTLoadError() messages on error.
**
**	Developed for Lynx by Foteos Macrides (macrides@@sci.wfeb.edu).
*/
PUBLIC int HTVMSBrowseDir ARGS4(
	CONST char *,		address,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink
)
d723 1
a723 1
    HTStructured* target;
d732 1
a732 1
    int  pathend, len;
d741 1
a741 1
    CTRACE((tfp,"HTVMSBrowseDir: Browsing `%s\'\n", pathname));
d744 4
a747 4
     *  Require at least two elements (presumably a device and directory)
     *  and disallow the device root (000000 directory).  Symbolic paths
     *  (e.g., sys$help) should have been translated and expanded (e.g.,
     *  to /sys$sysroot/syshlp) before calling this routine.
d750 1
a750 1
	 (cp = strchr(pathname+1, '/')) == NULL ||
d759 1
a759 1
     *  Set up the output stream.
d761 1
a761 1
    _HTProgress (BUILDING_DIR_LIST);
d772 2
a773 2
     *  Set up the offset string of the anchor reference,
     *  and strings for the title and header.
d775 2
a776 2
    cp = strrchr(pathname, '/');  /* find lastslash */
    StrAllocCopy(tail, (cp+1)); /* take slash off the beginning */
d780 1
a780 1
	if ((cp1=strrchr(pathname, '/')) != NULL &&
d782 2
a783 2
	    strncmp((cp1+1), "000000", 6))
	    StrAllocCopy(parent, (cp1+1));
d786 1
a786 1
	pathname[strlen(pathname)-1] = '\0';
d788 1
a788 1
	StrAllocCopy(title, (cp+1));
d794 1
a794 1
     *  Initialize path name for HTStat().
d797 1
a797 1
    if (*(pathname+pathend-1) != '/') {
d803 1
a803 1
     *  Output the title and header.
d826 3
a828 2
	FILE * fp;
	if (header[strlen(header)-1] != '/')
d831 1
a831 1
	if ((fp = fopen(header,	 "r")) != NULL) {
d833 1
a833 1
	    for(;;) {
d835 2
a836 1
		if (c == (char)EOF)
d840 11
a850 11
		    case '&':
		    case '<':
		    case '>':
			PUTC('&');
			PUTC('#');
			PUTC((char)(c / 10));
			PUTC((char) (c % 10));
			PUTC(';');
			break;
		    default:
			PUTC(c);
d875 1
a875 1
     *  Set up the date comparison.
d878 1
a878 1
    strcpy(ThisYear, (char *)ctime(&NowTime)+20);
d898 1
a898 1
	    if (!dirbuf->d_ino)	{
d921 1
a921 1
	    *(pathname+pathend) = '\0';
d928 1
a928 1
	    entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));
d939 1
a939 1
				  (CONST char **)&cp);
d941 1
a941 2
		if(!strncmp(HTAtom_name(format), "application",11))
		{
d943 1
a943 1
		    if(!strncmp(cp,"x-", 2))
d945 1
a945 2
		}
		else
d954 1
d957 1
a957 1
		   *dot = '\0';
d979 4
a982 4
		    entry_info->filename[len-1] == 'z') {
		    if (entry_info->filename[len-2] == '.' ||
			entry_info->filename[len-2] == '_')
			entry_info->filename[len-1] = 'Z';
d988 1
a988 2
		char *t = (char *)ctime((CONST time_t *)&file_info.st_ctime);
		*(t+24) = '\0';
d990 6
a995 4
		StrAllocCopy(entry_info->date, (t+4));
		*((entry_info->date)+7) = '\0';
		if ((atoi((t+19))) < atoi(ThisYear))
		    StrAllocCat(entry_info->date,  (t+19));
d997 2
a998 2
		    StrAllocCat(entry_info->date, (t+11));
		    *((entry_info->date)+12) = '\0';
d1004 1
a1004 1
		entry_info->size = (unsigned int)file_info.st_size;
d1009 5
a1013 6
	    if(entry_info->display)
	      {
		 CTRACE((tfp,"Adding file to BTree: %s\n",
						      entry_info->filename));
		 HTBTree_add(bt, entry_info);
	      }
d1015 1
a1015 1
	} /* End while HTVMSreaddir() */
d1025 1
a1025 1
	    HTBTElement * ele;
d1027 1
d1030 2
a1031 3
		 ele = HTBTree_next(bt, ele))
	    {
		entry_info = (VMSEntryInfo *)HTBTree_object(ele);
d1034 5
a1038 7
		if(entry_info->date)
		       {
			     PUTS(entry_info->date);
			     PUTS("  ");
		       }
		else
			PUTS("     * ");
d1041 2
a1042 3
		if(entry_info->type)
		  {
		    for(i = 0; entry_info->type[i] != '\0' && i < 15; i++)
d1044 1
a1044 1
		    for(; i < 17; i++)
d1047 1
a1047 1
		  }
d1055 9
a1063 10
		if(entry_info->size)
		  {
			  if(entry_info->size < 1024)
			      sprintf(string_buffer,"  %d bytes",
							entry_info->size);
			  else
			      sprintf(string_buffer,"  %dKb",
							entry_info->size/1024);
			  PUTS(string_buffer);
		  }
d1065 1
a1065 1
		PUTC('\n'); /* end of this entry */
d1073 1
a1073 1
    } /* End of both BTree loops */
d1076 1
a1076 1
     *  Complete the output stream.
d1089 1
a1089 1
} /* End of directory reading section */
d1098 2
a1099 2
    while (remove(filename) == 0)
	;
d1117 1
a1117 2
    while (remove(older_file) == 0)
	;
d1131 1
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d23 1
d35 1
d40 1
a40 1
PUBLIC BOOL HTVMSFileVersions=FALSE; /* Include version numbers in listing? */
a48 2
extern CONST char * HTHostName NOPARAMS;

d755 1
a755 1
    VMSEntryInfo *entry_info=0;
a756 1
    extern BOOLEAN no_dotfiles, show_dotfiles;
d768 4
a771 4
	 (cp=strchr(pathname+1, '/')) == NULL ||
	 *(cp+1) == '\0' ||
	 0==strncmp((cp+1), "000000", 6)) ||
	(dp=HTVMSopendir(pathname)) == NULL) {
d1029 1
a1029 1
		 HTBTree_add(bt, (VMSEntryInfo *)entry_info);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d22 1
d36 1
a36 2

#define INFINITY 512            	/* File name length @@@@ FIXME */
d107 1
a107 1
           CTRACE(tfp, "HTVMS_enableSysPrv: Enabled SYSPRV\n");
d133 1
a133 1
           CTRACE(tfp, "HTVMS_disableSysPrv: Disabled SYSPRV\n");
d210 1
a210 1
        return(YES);
d212 1
a212 1
        return(NO);
d226 1
a226 1
**	returns 	www file specification
d230 12
a241 12
**	DISK$USER 			disk$user
**	DISK$USER: 			/disk$user/
**	DISK$USER:[DUNS] 		/disk$user/duns
**	DISK$USER:[DUNS.ECHO] 		/disk$user/duns/echo
**	[DUNS] 				duns
**	[DUNS.ECHO] 			duns/echo
**	[DUNS.ECHO.-.TRANS] 		duns/echo/../trans
**	[DUNS.ECHO.--.TRANS] 		duns/echo/../../trans
**	[.DUNS] 			duns
**	[.DUNS.ECHO] 			duns/echo
**	[.DUNS.ECHO]TEST.COM 		duns/echo/test.com
**	TEST.COM 			test.com
d246 1
a246 1
	char *, vmsname)
d248 3
a250 2
static char wwwname[256];
char *src, *dst;
d260 5
a264 5
         case ':':  *(dst++) = '/'; break;
         case '-': if (dir)
	 	   {
	 	      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') &&
		          (*(src+1)=='.' || *(src+1)=='-'))
d266 3
a268 3
		          *(dst++) = '/';
                          *(dst++) = '.';
                          *(dst++) = '.';
d271 1
a271 1
		          *(dst++) = '-';
d278 6
a283 6
                   break;
         case '.': if (dir)
                   {
                      if (*(src-1) != '[') *(dst++) = '/';
                   }
                   else
d286 1
a286 1
                      *(dst++) = '.';
d288 6
a293 6
                   break;
         case '[': dir = 1; break;
         case ']': dir = 0; break;
         default:  if (*(src-1) == ']') *(dst++) = '/';
                   *(dst++) = *src;
                   break;
a300 72
/* PUBLIC							HTVMS_name()
**		CONVERTS WWW name into a VMS name
** ON ENTRY:
**	nn		Node Name (optional)
**	fn		WWW file name
**
** ON EXIT:
**	returns 	vms file specification
**
** Bug:	Returns pointer to static -- non-reentrant
*/
PUBLIC char * HTVMS_name ARGS2(
	CONST char *, nn,
	CONST char *, fn)
{

/*	We try converting the filename into Files-11 syntax.  That is, we assume
**	first that the file is, like us, on a VMS node.  We try remote
**	(or local) DECnet access.  Files-11, VMS, VAX and DECnet
**	are trademarks of Digital Equipment Corporation.
**	The node is assumed to be local if the hostname WITHOUT DOMAIN
**	matches the local one. @@@@@@
*/
    static char vmsname[INFINITY];	/* returned */
    char * filename = (char*)malloc(strlen(fn)+1);
    char * nodename = (char*)malloc(strlen(nn)+2+1);	/* Copies to hack */
    char *second;		/* 2nd slash */
    char *last;			/* last slash */

    char * hostname = (char *)HTHostName();

    if (!filename || !nodename) outofmem(__FILE__, "HTVMSname");
    strcpy(filename, fn);
    strcpy(nodename, "");	/* On same node?  Yes if node names match */
    if (strncmp(nn,"localhost",9)) {
        char *p, *q;
        for (p=hostname, q=(char *)nn;
	     *p && *p!='.' && *q && *q!='.'; p++, q++){
	    if (TOUPPER(*p)!=TOUPPER(*q)) {
	        strcpy(nodename, nn);
		q = strchr(nodename, '.');	/* Mismatch */
		if (q) *q=0;			/* Chop domain */
		strcat(nodename, "::");		/* Try decnet anyway */
		break;
	    }
	}
    }

    second = strchr(filename+1, '/');		/* 2nd slash */
    last = strrchr(filename, '/');	/* last slash */

    if (!second) {				/* Only one slash */
	sprintf(vmsname, "%s%s", nodename, filename + 1);
    } else if(second==last) {		/* Exactly two slashes */
	*second = 0;		/* Split filename from disk */
	sprintf(vmsname, "%s%s:%s", nodename, filename+1, second+1);
	*second = '/';	/* restore */
    } else { 				/* More than two slashes */
	char * p;
	*second = 0;		/* Split disk from directories */
	*last = 0;		/* Split dir from filename */
	sprintf(vmsname, "%s%s:[%s]%s",
		nodename, filename+1, second+1, last+1);
	*second = *last = '/';	/* restore filename */
	for (p=strchr(vmsname, '['); *p!=']'; p++)
	    if (*p=='/') *p='.';	/* Convert dir sep.  to dots */
    }
    FREE(nodename);
    FREE(filename);
    return vmsname;
}

d312 1
a312 1
		is statted like: 	/disk$user/duns/www.dir
d326 1
a326 1
char Name[256];
d334 1
a334 26
   strcpy(Name,filename);

#ifdef NOT_USED
   /* if filename contains a node specification (! or ::), we will try to access
      the file via DECNET, but we do not stat it..., just return success
      with some fake information... */
   if (HTVMS_checkDecnet(Name))
   {
      /* set up fake info, only the one we use... */
      info->st_dev = NULL;
      info->st_ino[0] = 0;
      info->st_ino[1] = 0;
      info->st_ino[2] = 0;
      info->st_mode = S_IFREG | S_IREAD;	/* assume it is a regular Readable file */
      info->st_nlink = NULL;
      info->st_uid = 0;
      info->st_gid = 0;
      info->st_rdev = 0;
      info->st_size = 0;
      info->st_atime = time(NULL);
      info->st_mtime = time(NULL);
      info->st_ctime = time(NULL);

      return(0);
   }
#endif /* NOT_USED */
d351 1
a351 1
      strcat(Name,"/000000/000000");
d359 5
a363 5
         char End[256];
         strcpy(End,Ptr);
         *(Ptr+1) = '\0';
         strcat(Name,"000000");
         strcat(Name,End);
d367 1
a367 1
   /* try in case a file on toplevel directory or .DIR was alreadyt specified */
d373 1
a373 1
   strcat(Name,".dir");
d386 1
a386 9
#if 0
	int	dd_fd;		/* file descriptor */
	long	dd_loc;		/* buf offset of entry from last readddir() */
	long	dd_size;	/* amount of valid data in buffer */
	long	dd_bsize;	/* amount of entries read at a time */
	long	dd_off;		/* Current offset in dir (for telldir) */
	char	*dd_buf;	/* directory data buffer */
#endif
	long 	context;	/* context descriptor for LIB$FIND_FILE calls */
a393 11
#if 0
#ifndef	_POSIX_SOURCE
extern	void seekdir(/* DIR *dirp, int loc */);
extern	long telldir(/* DIR *dirp */);
#endif	/* POSIX_SOURCE */
extern	void rewinddir(/* DIR *dirp */);

#ifndef	lint
#define	rewinddir(dirp)	seekdir((dirp), (long)0)
#endif
#endif /* not defined for VMS */
a397 3
#if 0
	off_t		d_off;		/* offset of next disk dir entry */
#endif
a398 3
#if 0
	unsigned short	d_reclen;	/* length of this record */
#endif
d429 2
a430 1
char DirEntry[256];
d441 1
a441 1
   strcpy(UnixEntry,dirname);
d445 3
a447 1
   strcpy(DirEntry, HTVMS_name("",UnixEntry));
d459 4
a462 3
         strcpy(dir.dirname, DirEntry);
         strcat(dir.dirname, "[000000]");
         strcat(DirEntry,"[000000]000000.dir");
d466 6
a471 6
         char End[256];
         strcpy(End,openbr+1);
         *(openbr+1) = '\0';
         strcat(DirEntry,"000000]");
         strcat(DirEntry,End);
         strcat(DirEntry,".dir");
d477 1
a477 1
      strcat(DirEntry,".dir");
d479 2
d483 1
a483 1
   dirname_desc.dsc$w_length = strlen(DirEntry);
d486 1
a486 1
   dirname_desc.dsc$a_pointer = (char *)&(DirEntry);
d495 3
a497 3
                          &entryname_desc,
                          &(dir.context),
                          0,0,0,0);
d503 2
a504 10
#if 0
   /* now correct dirname, which looks like disk$user:[duns.www.test]multi */
   /* and should look like disk$user:[duns.www.test.multi] */
   closebracket = strchr(dir.dirname,']');
   *closebracket = '.';
   closebracket = strstr(dir.dirname,".dir");
   *closebracket = '\0';
   strcat(dir.dirname,"]");
#endif

d532 3
a534 3
                          &entryname_desc,
                          &(dirp->context),
                          0,0,0,0);
d543 1
a543 1
          space = strchr(VMSentry,' ');
d545 1
a545 1
          space = strchr(VMSentry,';');
d547 1
a547 1
         *space = '\0';
a612 6
#define FILE_BY_NAME 0
#define FILE_BY_TYPE 1
#define FILE_BY_SIZE 2
#define FILE_BY_DATE 3
extern BOOLEAN HTfileSortMethod;  /* specifies the method of sorting */

d621 1
a621 1
        case FILE_BY_SIZE:
d623 1
a623 1
                        if(entry1->size == entry2->size)
d631 3
a633 4
                        break;
        case FILE_BY_TYPE:
                        if(entry1->type && entry2->type) {
                            status = strcasecomp(entry1->type, entry2->type);
d638 1
a638 1
                        return (strcasecomp(entry1->filename,
d640 2
a641 3
                        break;
        case FILE_BY_DATE:
                        if(entry1->date && entry2->date) {
d646 1
a646 1
			        strlen(entry2->date) != 12) {
d655 1
a655 1
			        strcpy(date1, "9999");
d659 1
a659 1
			        strcpy(time1, "00:00");
d664 1
a664 1
			        if (!strcasecomp(month, months[i])) {
d669 1
a669 1
			    sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d674 1
a674 1
			        date1[6] = '0';
d678 1
a678 1
			        strcpy(date2, "9999");
d682 1
a682 1
			        strcpy(time2, "00:00");
d687 1
a687 1
			        if (!strcasecomp(month, months[i])) {
d692 1
a692 1
			    sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d697 1
a697 1
			        date2[6] = '0';
d703 1
a703 1
                            status = strcasecomp(date2, date1);
d708 1
a708 1
                        return (strcasecomp(entry1->filename,
d710 3
a712 4
                        break;
        case FILE_BY_NAME:
        default:
                        return (strcmp(entry1->filename,
d718 1
a718 1
/*						    	HTVMSBrowseDir()
d760 1
a760 1
    CTRACE(tfp,"HTVMSBrowseDir: Browsing `%s\'\n", pathname);
d769 1
a769 1
    	 (cp=strchr(pathname+1, '/')) == NULL ||
d772 3
a774 3
        (dp=HTVMSopendir(pathname)) == NULL) {
        FREE(pathname);
    	return HTLoadError(sink, 403, COULD_NOT_ACCESS_DIR);
d797 1
a797 1
        StrAllocCopy(title, tail);
d805 1
a805 1
        pathname[strlen(pathname)-1] = '\0';
d845 1
a845 1
        FILE * fp;
d849 1
a849 1
        if ((fp = fopen(header,  "r")) != NULL) {
d852 2
a853 2
	        char c = fgetc(fp);
	        if (c == (char)EOF)
d856 2
a857 2
	        switch (c) {
	    	    case '&':
d868 1
a868 1
	        }
d875 1
a875 1
        }
d879 1
a879 4
	relative = (char*) malloc(strlen(tail) + 4);
	if (relative == NULL)
		outofmem(__FILE__, "HTVMSBrowseDir");
	sprintf(relative, "%s/..", tail);
d943 1
a943 1
                continue;
d945 1
a945 1
            entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));
d971 5
a975 5
	        /* strip .DIR part... */
                char *dot;
                dot = strstr(entry_info->filename, ".DIR");
                if (dot)
                   *dot = '\0';
d979 2
a980 2
	        if ((cp = strstr(entry_info->filename, "READ")) == NULL) {
	            cp = entry_info->filename;
d984 1
a984 1
		        cp += 2;
d989 1
a989 1
		        cp = (entry_info->filename +
d992 1
a992 1
		        cp = entry_info->filename;
d999 1
a999 1
		        entry_info->filename[len-2] == '_')
d1006 1
a1006 1
	        char *t = (char *)ctime((CONST time_t *)&file_info.st_ctime);
d1009 1
a1009 1
	        StrAllocCopy(entry_info->date, (t+4));
d1021 1
a1021 1
	        entry_info->size = (unsigned int)file_info.st_size;
d1023 1
a1023 1
	        entry_info->size = 0;
d1028 3
a1030 3
		 CTRACE(tfp,"Adding file to BTree: %s\n",
						      entry_info->filename);
	         HTBTree_add(bt, (VMSEntryInfo *)entry_info);
d1054 2
a1055 2
		             PUTS(entry_info->date);
		             PUTS("  ");
d1064 1
a1064 1
		        PUTC(entry_info->type[i]);
d1066 1
a1066 1
		        PUTC(' ');
d1075 1
a1075 1
                /* Output the size */
d1078 1
a1078 1
		          if(entry_info->size < 1024)
@


1.1
log
@Initial revision
@
text
@d16 7
a22 10
#include "HTUtils.h"
#include "tcp.h"
#include "HTFormat.h"
#include "HTStream.h"
#include "UCDefs.h"
#include "UCMap.h"
#include "UCAux.h"
#include "HTVMSUtils.h"
/*#include <stdio.h> included by HTUtils.h -- FM */
/*#include <unixlib.h> included by HTUtils.h -- FM */
d33 2
a34 3
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d78 1
a78 1
     return(NO);  
d83 1
a83 1
  return(NO);  
d94 1
a94 1
**	
d105 4
a108 6
   if (TRACE) {
      if (Result == SS$_NORMAL) {
         if (!(PreviousPrv[0] & PRV$M_SYSPRV)) {
            fprintf(stderr, "HTVMS_enableSysPrv: Enabled SYSPRV\n");
         }
      }
d120 1
a120 1
**	
d131 4
a134 6
   if (TRACE) {
      if (Result == SS$_NORMAL) {
         if (PreviousPrv[0] & PRV$M_SYSPRV) {
            fprintf(stderr, "HTVMS_disableSysPrv: Disabled SYSPRV\n");
         }
      }
d150 1
a150 1
**	
d221 1
a221 1
**		CONVERTS VMS Name into WWW Name 
d240 1
a240 1
**	[.DUNS.ECHO]TEST.COM 		duns/echo/test.com 
d243 1
a243 1
**	
d262 1
a262 1
	 	      if ((*(src-1)=='[' || *(src-1)=='.' || *(src-1)=='-') && 
d266 1
a266 1
                          *(dst++) = '.'; 
d291 1
a291 1
                   *(dst++) = *src; 
d312 1
a312 1
	CONST char *, nn, 
d316 4
a319 4
/*	We try converting the filename into Files-11 syntax. That is, we assume
**	first that the file is, like us, on a VMS node. We try remote
**	(or local) DECnet access. Files-11, VMS, VAX and DECnet
**	are trademarks of Digital Equipment Corporation. 
d328 1
a328 1
    
d333 1
a333 1
    strcpy(nodename, "");	/* On same node? Yes if node names match */
d350 1
a350 1
        
d377 2
a378 2
	CONST char *, filename, 
	stat_t *, info)
d380 1
a380 1
   /* 
d383 1
a383 1
		is statted like: 	/disk$user/duns/www.dir 
d389 1
a389 1
      -->   /			
d409 1
a409 1
      the file via DECNET, but we do not stat it..., just return success 
d437 1
a437 1
   
d442 1
a442 1
   
d449 1
a449 1
   
a473 3
/*** "dirent.h" ***/
/* #include <types.h>	already in tcp.h */

d510 1
a510 1
/*** #include "sys_dirent.h" ***/
d593 1
a593 1
      *dot = ']';   
d609 2
a610 2
   status = lib$find_file(&(dirname_desc), 
                          &entryname_desc, 
d654 2
a655 2
   status = lib$find_file(&(dirp->dirname_desc), 
                          &entryname_desc, 
d692 5
a696 5
#include "HTAnchor.h"
#include "HTParse.h"
#include "HTBTree.h"
#include "HTFile.h"	/* For HTFileFormat() */
#include "HTAlert.h"
d700 1
a700 1
#include "HTML.h"
d726 1
a726 1
PRIVATE void free_VMSEntryInfo_struct_contents ARGS1(VMSEntryInfo *,entry_info)
d736 1
a736 1
#define FILE_BY_NAME 0 
d742 1
a742 1
PUBLIC int compare_VMSEntryInfo_structs ARGS2(VMSEntryInfo *,entry1, 
d753 1
a753 1
			    return(strcasecomp(entry1->filename, 
d768 1
a768 1
                        return (strcasecomp(entry1->filename, 
d778 1
a778 1
				return (strcasecomp(entry1->filename, 
d844 1
a844 1
                        return (strcmp(entry1->filename, 
d892 1
a892 1
    CTRACE(stderr,"HTVMSBrowseDir: Browsing `%s\'\n", pathname);
d906 1
a906 1
    	return HTLoadError(sink, 403, "Could not access directory.");
d912 1
a912 1
    _HTProgress ("Building directory listing...");
d952 1
a952 1
    
d957 1
a957 1
    PUTS("\n");
d959 1
a959 1
    PUTS("\n");
d965 1
a965 1
    PUTS("\n");
d968 1
a968 1
    PUTS("\n");
d970 1
a970 1
    PUTS("\n");
d975 1
a975 1
    PUTS("\n");
d1007 1
a1007 1
        } 
d1021 1
a1021 1
	PUTS("\n");
d1053 1
a1053 1
	    
d1080 1
a1080 1
            entry_info = (VMSEntryInfo *)malloc(sizeof(VMSEntryInfo));    
d1093 1
a1093 1
		if(!strncmp(HTAtom_name(format), "application",11)) 
d1105 1
a1105 1
	    if ((file_info.st_mode & S_IFMT) == S_IFDIR) {
d1111 1
a1111 5
		cp = entry_info->filename;
		while (cp && *cp) {
		    *cp = TOLOWER(*cp);
		    cp++;
		}
d1130 1
a1130 4
		while (cp && *cp) {
		    *cp = TOLOWER(*cp);
		    cp++;
		}
d1155 1
a1155 1
	    if ((file_info.st_mode & S_IFMT) != S_IFDIR)
d1163 1
a1163 1
		 CTRACE(stderr,"Adding file to BTree: %s\n",
d1165 1
a1165 1
	         HTBTree_add(bt, (VMSEntryInfo *)entry_info); 
d1187 1
a1187 1
		if(entry_info->date) 
d1196 1
a1196 1
		if(entry_info->type) 
d1206 1
a1206 1
		HTDirEntry(target, tail, entry_info->filename);  
d1211 1
a1211 1
		if(entry_info->size) 
d1224 1
a1224 1
		free_VMSEntryInfo_struct_contents(entry_info);
d1236 1
a1236 1
    PUTS("\n");
d1238 1
a1238 1
    PUTS("\n");
d1240 1
a1240 1
    PUTS("\n");
d1247 42
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
