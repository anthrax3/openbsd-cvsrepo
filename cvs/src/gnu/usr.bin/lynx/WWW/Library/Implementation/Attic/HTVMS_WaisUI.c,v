head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.50;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.41;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.41;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTVMS_WaisUI.c,v 1.19 2013/05/03 20:51:49 tom Exp $
 *								HTVMS_WAISUI.c
 *
 *	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
 *
 *	30-May-1994 FM	Initial version.
 *
 *----------------------------------------------------------------------*/

/*
 *	Routines originally from UI.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Brewster@@think.com
 */

/*
 * this is a simple ui toolkit for building other ui's on top.
 * -brewster
 *
 * top level functions:
 *   generate_search_apdu
 *   generate_retrieval_apdu
 *   interpret_message
 *
 */

/* to do:
 *   generate multiple queries for long documents.
 *     this will crash if the file being retrieved is larger than 100k.
 *   do log_write()
 *
 */

#include <HTUtils.h>

#ifdef VMS
#include <HTVMS_WaisUI.h>
#include <HTVMS_WaisProt.h>
#include <HTTCP.h>

#undef MAXINT			/* we don't need it here, and www_tcp.h may conflict */
#include <math.h>

#include <LYexit.h>
#include <LYLeaks.h>

void log_write(char *s GCC_UNUSED)
{
    return;
}

/*----------------------------------------------------------------------*/

/* returns a pointer in the buffer of the first free byte.
   if it overflows, then NULL is returned
 */
char *generate_search_apdu(char *buff,	/* buffer to hold the apdu */
			   long *buff_len,	/* length of the buffer changed to reflect new data written */
			   char *seed_words,	/* string of the seed words */
			   char *database_name,
			   DocObj **docobjs,
			   long maxDocsRetrieved)
{
    /* local variables */

    SearchAPDU *search3;
    char *end_ptr;
    static char *database_names[2] =
    {"", 0};
    any refID;
    WAISSearch *query;

    refID.size = 1;
    refID.bytes = "3";

    database_names[0] = database_name;
    query = makeWAISSearch(seed_words,
			   docobjs,	/* DocObjsPtr */
			   0,
			   1,	/* DateFactor */
			   0,	/* BeginDateRange */
			   0,	/* EndDateRange */
			   maxDocsRetrieved
	);

    search3 = makeSearchAPDU(30,
			     5000,	/* should be large */
			     30,
			     1,	/* replace indicator */
			     "",	/* result set name */
			     database_names,	/* database name */
			     QT_RelevanceFeedbackQuery,		/* query_type */
			     0,	/* element name */
			     NULL,	/* reference ID */
			     query);

    end_ptr = writeSearchAPDU(search3, buff, buff_len);

    CSTFreeWAISSearch(query);
    freeSearchAPDU(search3);
    return (end_ptr);
}

/*----------------------------------------------------------------------*/

/* returns a pointer into the buffer of the next free byte.
   if it overflowed, then NULL is returned
 */

char *generate_retrieval_apdu(char *buff,
			      long *buff_len,	/* length of the buffer changed to reflect new data written */
			      any *docID,
			      long chunk_type,
			      long start,
			      long end,
			      char *type,
			      char *database_name)
{
    SearchAPDU *search;
    char *end_ptr;

    static char *database_names[2];
    static char *element_names[3];
    any refID;

    DocObj *DocObjs[2];
    any *query;			/* changed from char* by brewster */

    if (NULL == type)
	type = s_strdup("TEXT");

    database_names[0] = database_name;
    database_names[1] = NULL;

    element_names[0] = " ";
    element_names[1] = ES_DocumentText;
    element_names[2] = NULL;

    refID.size = 1;
    refID.bytes = "3";

    switch (chunk_type) {
    case CT_line:
	DocObjs[0] = makeDocObjUsingLines(docID, type, start, end);
	break;
    case CT_byte:
	DocObjs[0] = makeDocObjUsingBytes(docID, type, start, end);
	break;
    }
    DocObjs[1] = NULL;

    query = makeWAISTextQuery(DocObjs);
    search = makeSearchAPDU(10, 16, 15,
			    1,	/* replace indicator */
			    "FOO",	/* result set name */
			    database_names,	/* database name */
			    QT_TextRetrievalQuery,	/* query_type */
			    element_names,	/* element name */
			    &refID,	/* reference ID */
			    query);
    end_ptr = writeSearchAPDU(search, buff, buff_len);
    CSTFreeWAISTextQuery(query);
    freeSearchAPDU(search);
    return (end_ptr);
}

/*----------------------------------------------------------------------*/

/* this is a safe version of unix 'read' it does all the checking
 * and looping necessary
 * to those trying to modify the transport code to use non-UNIX streams:
 *  This is the function to modify!
 */
static long read_from_stream(int d, char *buf, long nbytes)
{
    long didRead;
    long toRead = nbytes;
    long totalRead = 0;		/* paranoia */

    while (toRead > 0) {
	didRead = NETREAD(d, buf, (int) toRead);
	if (didRead == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
	if (didRead == -1)	/* error */
	    return (-1);
	if (didRead == 0)	/* eof */
	    return (-2);	/* maybe this should return 0? */
	toRead -= didRead;
	buf += didRead;
	totalRead += didRead;
    }
    if (totalRead != nbytes)	/* we overread for some reason */
	return (-totalRead);	/* bad news */
    return (totalRead);
}

/*----------------------------------------------------------------------*/

/* returns the length of the response, 0 if an error */

static long transport_message(long connection,
			      char *request_message,
			      long request_length,
			      char *response_message,
			      long response_buffer_length)
{
    WAISMessage header;
    long response_length;
    int rv;

    /* Write out message.  Read back header.  Figure out response length. */

    if (request_length + HEADER_LENGTH !=
	NETWRITE(connection, request_message,
		 (int) (request_length + HEADER_LENGTH)))
	return 0;

    /* read for the first '0' */

    while (1) {
	rv = read_from_stream(connection, response_message, 1);
	if (rv == HT_INTERRUPTED)
	    return HT_INTERRUPTED;
	if (rv < 0)
	    return 0;
	if ('0' == response_message[0])
	    break;
    }

    rv = read_from_stream(connection, response_message + 1, HEADER_LENGTH - 1);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;

    readWAISPacketHeader(response_message, &header);
    {
	char length_array[11];

	LYStrNCpy(length_array, header.msg_len, 10);
	response_length = atol(length_array);
	/*
	   if(verbose){
	   printf("WAIS header: '%s' length_array: '%s'\n",
	   response_message, length_array);
	   }
	 */
	if (response_length > response_buffer_length) {
	    /* we got a message that is too long, therefore empty the message out,
	       and return 0 */
	    long i;

	    for (i = 0; i < response_length; i++) {
		rv = read_from_stream(connection,
				      response_message + HEADER_LENGTH,
				      1);
		if (rv == HT_INTERRUPTED)
		    return HT_INTERRUPTED;
		if (rv < 0)
		    return 0;
	    }
	    return (0);
	}
    }
    rv = read_from_stream(connection,
			  response_message + HEADER_LENGTH,
			  response_length);
    if (rv == HT_INTERRUPTED)
	return HT_INTERRUPTED;
    if (rv < 0)
	return 0;
    return (response_length);
}

/*----------------------------------------------------------------------*/

/* returns the number of bytes written.  0 if an error */
long interpret_message(char *request_message,
		       long request_length,	/* length of the buffer */
		       char *response_message,
		       long response_buffer_length,
		       long connection,
		       boolean verbose GCC_UNUSED)
{
    long response_length;

    /* ?
       if(verbose){
       printf ("sending");
       if(hostname_internal && strlen(hostname_internal) > 0)
       printf(" to host %s", hostname_internal);
       if(service_name && strlen(service_name) > 0)
       printf(" for service %s", service_name);
       printf("\n");
       twais_dsply_rsp_apdu(request_message + HEADER_LENGTH,
       request_length);
       }

     */

    writeWAISPacketHeader(request_message,
			  request_length,
			  (long) 'z',	/* Z39.50 */
			  "wais      ",		/* server name */
			  (long) NO_COMPRESSION,	/* no compression */
			  (long) NO_ENCODING, (long) HEADER_VERSION);
    if (connection != 0) {
	response_length = transport_message(connection, request_message,
					    request_length,
					    response_message,
					    response_buffer_length);
	if (response_length == HT_INTERRUPTED)
	    return (HT_INTERRUPTED);
    } else
	return (0);

    return (response_length);
}

/*----------------------------------------------------------------------*/

/* modifies the string to exclude all seeker codes. sets length to
   the new length. */
static char *delete_seeker_codes(char *string, long *length)
{
    long original_count;	/* index into the original string */
    long new_count = 0;		/* index into the collapsed string */

    for (original_count = 0; original_count < *length; original_count++) {
	if (27 == string[original_count]) {
	    /* then we have an escape code */
	    /* if the next letter is '(' or ')', then ignore two letters */
	    if ('(' == string[original_count + 1] ||
		')' == string[original_count + 1])
		original_count += 1;	/* it is a term marker */
	    else
		original_count += 4;	/* it is a paragraph marker */
	} else
	    string[new_count++] = string[original_count];
    }
    *length = new_count;
    return (string);
}

/*----------------------------------------------------------------------*/

#if defined(VMS) && defined(__GNUC__)	/* 10-AUG-1995 [pr] */
/*
  Workaround for an obscure bug in gcc's 2.6.[123] and 2.7.0 vax/vms port;
  sometimes global variables will end up not being defined properly,
  causing first gas to assume they're routines, then the linker to complain
  about unresolved symbols, and finally the program to reference the wrong
  objects (provoking ACCVIO).  It's triggered by the specific ordering of
  variable usage in the source code, hence rarely appears.  This bug is
  fixed in gcc 2.7.1, and was not present in 2.6.0 and earlier.

   Make a reference to VAXCRTL's _ctype_[], and also one to this dummy
   variable itself to prevent any "defined but not used" warning.
 */
static __const void *__const ctype_dummy[] =
{&_ctype_, &ctype_dummy};
#endif /* VMS && __GNUC__ */

/* returns a pointer to a string with good stuff */
char *trim_junk(char *headline)
{
    long length = strlen(headline) + 1;		/* include the trailing null */
    size_t i;

    headline = delete_seeker_codes(headline, &length);
    /* delete leading spaces */
    for (i = 0; i < strlen(headline); i++) {
	if (isprint(headline[i])) {
	    break;
	}
    }
    headline = headline + i;
    /* delete trailing stuff */
    for (i = strlen(headline) - 1; i > 0; i--) {
	if (isprint(headline[i])) {
	    break;
	}
	headline[i] = '\0';
    }
    return (headline);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from ZProt.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:`
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */

#define RESERVE_SPACE_FOR_HEADER(spaceLeft)		\
	*spaceLeft -= HEADER_LEN;

#define RELEASE_HEADER_SPACE(spaceLeft)			\
	if (*spaceLeft > 0)				\
	  *spaceLeft += HEADER_LEN;

/*----------------------------------------------------------------------*/

InitResponseAPDU *makeInitResponseAPDU(boolean result,
				       boolean search,
				       boolean present,
				       boolean deleteIt,
				       boolean accessControl,
				       boolean resourceControl,
				       long prefSize,
				       long maxMsgSize,
				       char *auth,
				       char *id,
				       char *name,
				       char *version,
				       any *refID,
				       void *userInfo)
/* build an initResponse APDU with user specified information */
{
    InitResponseAPDU *init = (InitResponseAPDU *) s_malloc((size_t) sizeof(InitResponseAPDU));

    init->PDUType = initResponseAPDU;
    init->Result = result;
    init->willSearch = search;
    init->willPresent = present;
    init->willDelete = deleteIt;
    init->supportAccessControl = accessControl;
    init->supportResourceControl = resourceControl;
    init->PreferredMessageSize = prefSize;
    init->MaximumRecordSize = maxMsgSize;
    init->IDAuthentication = s_strdup(auth);
    init->ImplementationID = s_strdup(id);
    init->ImplementationName = s_strdup(name);
    init->ImplementationVersion = s_strdup(version);
    init->ReferenceID = duplicateAny(refID);
    init->UserInformationField = userInfo;	/* not copied! */

    return (init);
}

/*----------------------------------------------------------------------*/

void freeInitResponseAPDU(InitResponseAPDU *init)
/* free an initAPDU */
{
    s_free(init->IDAuthentication);
    s_free(init->ImplementationID);
    s_free(init->ImplementationName);
    s_free(init->ImplementationVersion);
    freeAny(init->ReferenceID);
    s_free(init);
}

/*----------------------------------------------------------------------*/

char *writeInitResponseAPDU(InitResponseAPDU *init, char *buffer, long *len)
/* write the initResponse to a buffer, adding system information */
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;
    bit_map *optionsBM = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(init->PDUType, buf, len);
    buf = writeBoolean(init->Result, buf, len);
    buf = writeProtocolVersion(buf, len);

    optionsBM = makeBitMap((unsigned long) 5, init->willSearch, init->willPresent,
			   init->willDelete, init->supportAccessControl,
			   init->supportResourceControl);
    buf = writeBitMap(optionsBM, DT_Options, buf, len);
    freeBitMap(optionsBM);

    buf = writeNum(init->PreferredMessageSize,
		   DT_PreferredMessageSize,
		   buf,
		   len);
    buf = writeNum(init->MaximumRecordSize,
		   DT_MaximumRecordSize,
		   buf,
		   len);
    buf = writeString(init->IDAuthentication,
		      DT_IDAuthentication,
		      buf,
		      len);
    buf = writeString(init->ImplementationID,
		      DT_ImplementationID,
		      buf,
		      len);
    buf = writeString(init->ImplementationName,
		      DT_ImplementationName,
		      buf,
		      len);
    buf = writeString(init->ImplementationVersion,
		      DT_ImplementationVersion,
		      buf,
		      len);
    buf = writeAny(init->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (init->UserInformationField != NULL)
	buf = writeInitResponseInfo(init, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readInitResponseAPDU(InitResponseAPDU **init, char *buffer)
{
    char *buf = buffer;
    boolean search, present, delete, accessControl, resourceControl;
    long prefSize, maxMsgSize;
    char *auth, *id, *name, *version;
    long size;
    pdu_type pduType;
    bit_map *versionBM = NULL;
    bit_map *optionsBM = NULL;
    boolean result;
    any *refID = NULL;
    void *userInfo = NULL;

    auth = id = name = version = NULL;
    refID = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBoolean(&result, buf);
    buf = readBitMap(&versionBM, buf);
    buf = readBitMap(&optionsBM, buf);
    buf = readNum(&prefSize, buf);
    buf = readNum(&maxMsgSize, buf);

    /* decode optionsBM */
    search = bitAtPos(0, optionsBM);
    present = bitAtPos(1, optionsBM);
    delete = bitAtPos(2, optionsBM);
    accessControl = bitAtPos(3, optionsBM);
    resourceControl = bitAtPos(4, optionsBM);

    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_IDAuthentication:
	    buf = readString(&auth, buf);
	    break;
	case DT_ImplementationID:
	    buf = readString(&id, buf);
	    break;
	case DT_ImplementationName:
	    buf = readString(&name, buf);
	    break;
	case DT_ImplementationVersion:
	    buf = readString(&version, buf);
	    break;
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
	    break;
	default:
	    freeBitMap(versionBM);
	    freeBitMap(optionsBM);
	    s_free(auth);
	    s_free(id);
	    s_free(name);
	    s_free(version);
	    freeAny(refID);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    buf = readInitResponseInfo(&userInfo, buf);
    if (buf == NULL) {
	freeBitMap(versionBM);
	freeBitMap(optionsBM);
	s_free(auth);
	s_free(id);
	s_free(name);
	s_free(version);
	freeAny(refID);
    }
    RETURN_ON_NULL(buf);

    /* construct the basic init object */
    *init = makeInitResponseAPDU(result,
				 search,
				 present,
				 delete,
				 accessControl,
				 resourceControl,
				 prefSize,
				 maxMsgSize,
				 auth,
				 id,
				 name,
				 version,
				 refID,
				 userInfo);

    freeBitMap(versionBM);
    freeBitMap(optionsBM);
    s_free(auth);
    s_free(id);
    s_free(name);
    s_free(version);
    freeAny(refID);

    return (buf);
}

/*----------------------------------------------------------------------*/

InitResponseAPDU *replyToInitAPDU(InitAPDU * init, boolean result, void *userInfo)
/* respond to an init message in the default way - echoing back
   the init info
 */
{
    InitResponseAPDU *initResp;

    initResp = makeInitResponseAPDU(result,
				    init->willSearch,
				    init->willPresent,
				    init->willDelete,
				    init->supportAccessControl,
				    init->supportResourceControl,
				    init->PreferredMessageSize,
				    init->MaximumRecordSize,
				    init->IDAuthentication,
				    defaultImplementationID(),
				    defaultImplementationName(),
				    defaultImplementationVersion(),
				    init->ReferenceID,
				    userInfo);
    return (initResp);
}

/*----------------------------------------------------------------------*/

SearchAPDU *makeSearchAPDU(long small,
			   long large,
			   long medium,
			   boolean replace,
			   char *name,
			   char **databases,
			   char *type,
			   char **elements,
			   any *refID,
			   void *queryInfo)
{
    char *ptr = NULL;
    long i;
    SearchAPDU *query = (SearchAPDU *) s_malloc((size_t) sizeof(SearchAPDU));

    query->PDUType = searchAPDU;
    query->SmallSetUpperBound = small;
    query->LargeSetLowerBound = large;
    query->MediumSetPresentNumber = medium;
    query->ReplaceIndicator = replace;
    query->ResultSetName = s_strdup(name);
    query->DatabaseNames = NULL;
    if (databases != NULL) {
	for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	    if (query->DatabaseNames == NULL)
		query->DatabaseNames = (char **) s_malloc((size_t) (sizeof(char
									   *)
								    * 2));

	    else
		query->DatabaseNames = (char **) s_realloc((char *) query->DatabaseNames,
							   (size_t) (sizeof(char
									    *) *
								     (i + 2)));

	    query->DatabaseNames[i] = s_strdup(ptr);
	    query->DatabaseNames[i + 1] = NULL;
	}
    }
    query->QueryType = s_strdup(type);
    query->ElementSetNames = NULL;
    if (elements != NULL) {
	for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	    if (query->ElementSetNames == NULL)
		query->ElementSetNames =
		    (char **) s_malloc((size_t) (sizeof(char *) * 2));

	    else
		query->ElementSetNames = (char **) s_realloc((char *) query->ElementSetNames,
							     (size_t) (sizeof(char
									      *) *
								       (i + 2)));

	    query->ElementSetNames[i] = s_strdup(ptr);
	    query->ElementSetNames[i + 1] = NULL;
	}
    }
    query->ReferenceID = duplicateAny(refID);
    query->Query = queryInfo;	/* not copied! */
    return (query);
}

/*----------------------------------------------------------------------*/

void freeSearchAPDU(SearchAPDU *query)
{
    s_free(query->ResultSetName);
    s_free(query->QueryType);
    doList((void **) query->DatabaseNames, fs_free);	/* can't use the macro here ! */
    s_free(query->DatabaseNames);
    doList((void **) query->ElementSetNames, fs_free);	/* can't use the macro here ! */
    s_free(query->ElementSetNames);
    freeAny(query->ReferenceID);
    s_free(query);
}

/*----------------------------------------------------------------------*/

#define DB_DELIMITER	"\037"	/* hex 1F occurs between each database name */
#define ES_DELIMITER_1	"\037"	/* separates database name from element name */
#define ES_DELIMITER_2	"\036"	/* hex 1E separates <db,es> groups from one another */

char *writeSearchAPDU(SearchAPDU *query, char *buffer, long *len)
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size, i;
    char *ptr = NULL;
    char *scratch = NULL;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(query->PDUType, buf, len);
    buf = writeBinaryInteger(query->SmallSetUpperBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->LargeSetLowerBound, (size_t) 3, buf, len);
    buf = writeBinaryInteger(query->MediumSetPresentNumber, (size_t) 3, buf, len);
    buf = writeBoolean(query->ReplaceIndicator, buf, len);
    buf = writeString(query->ResultSetName, DT_ResultSetName, buf, len);
    /* write database names */
    if (query->DatabaseNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL;
	     ptr = query->DatabaseNames[++i]) {
	    if (scratch == NULL)
		scratch = s_strdup(ptr);
	    else {
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) + 2);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, DB_DELIMITER, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_DatabaseNames, buf, len);
	s_free(scratch);
    }
    buf = writeString(query->QueryType, DT_QueryType, buf, len);
    /* write element set names */
    if (query->ElementSetNames != NULL) {
	for (i = 0, scratch = NULL, ptr = query->ElementSetNames[i];
	     ptr != NULL;
	     ptr = query->ElementSetNames[++i]) {
	    if (scratch == NULL) {
		if (query->ElementSetNames[i + 1] == NULL)	/* there is a single element set name */
		{
		    scratch = (char *) s_malloc((size_t) strlen(ptr) + 2);
		    StrNCpy(scratch, ES_DELIMITER_1, 2);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, strlen(ptr) + 2);
		} else {	/* this is the first of a series of element set names */
		    size_t newScratchSize = (size_t) (strlen(ptr) +
						      strlen(query->ElementSetNames[i
										    + 1])
						      + 2);

		    scratch = s_strdup(ptr);	/* the database name */
		    ptr = query->ElementSetNames[++i];	/* the element set name */
		    scratch = (char *) s_realloc(scratch, newScratchSize);
		    s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		    s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
		}
	    } else {
		char *esPtr = query->ElementSetNames[++i];	/* the element set name */
		size_t newScratchSize = (size_t) (strlen(scratch) +
						  strlen(ptr) +
						  strlen(esPtr) +
						  3);

		scratch = (char *) s_realloc(scratch, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_2, 2, newScratchSize);
		s_strncat(scratch, ptr, strlen(ptr) + 1, newScratchSize);
		s_strncat(scratch, ES_DELIMITER_1, 2, newScratchSize);
		s_strncat(scratch, esPtr, strlen(esPtr) + 1, newScratchSize);
	    }
	}
	buf = writeString(scratch, DT_ElementSetNames, buf, len);
	s_free(scratch);
    }
    buf = writeAny(query->ReferenceID, DT_ReferenceID, buf, len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (query->Query != NULL)
	buf = writeSearchInfo(query, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

SearchResponseAPDU *makeSearchResponseAPDU(long result,
					   long count,
					   long recordsReturned,
					   long nextPos,
					   long resultStatus,
					   long presentStatus,
					   any *refID,
					   void *records)
{
    SearchResponseAPDU *query =
    (SearchResponseAPDU *) s_malloc((size_t) sizeof(SearchResponseAPDU));

    query->PDUType = searchResponseAPDU;
    query->SearchStatus = result;
    query->ResultCount = count;
    query->NumberOfRecordsReturned = recordsReturned;
    query->NextResultSetPosition = nextPos;
    query->ResultSetStatus = resultStatus;
    query->PresentStatus = presentStatus;
    query->ReferenceID = duplicateAny(refID);
    query->DatabaseDiagnosticRecords = records;
    return (query);
}

/*----------------------------------------------------------------------*/

void freeSearchResponseAPDU(SearchResponseAPDU *queryResponse)
{
    freeAny(queryResponse->ReferenceID);
    s_free(queryResponse);
}

/*----------------------------------------------------------------------*/

char *writeSearchResponseAPDU(SearchResponseAPDU *queryResponse, char *buffer,
			      long *len)
{
    char *buf = buffer + HEADER_LEN;	/* leave room for the header-length-indicator */
    long size;

    RESERVE_SPACE_FOR_HEADER(len);

    buf = writePDUType(queryResponse->PDUType,
		       buf,
		       len);
    buf = writeBinaryInteger(queryResponse->SearchStatus,
			     (size_t) 1,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->ResultCount,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NumberOfRecordsReturned,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeBinaryInteger(queryResponse->NextResultSetPosition,
			     (size_t) 3,
			     buf,
			     len);
    buf = writeNum(queryResponse->ResultSetStatus,
		   DT_ResultSetStatus,
		   buf,
		   len);
    buf = writeNum(queryResponse->PresentStatus,
		   DT_PresentStatus,
		   buf,
		   len);
    buf = writeAny(queryResponse->ReferenceID,
		   DT_ReferenceID,
		   buf,
		   len);

    /* go back and write the header-length-indicator */
    RELEASE_HEADER_SPACE(len);
    size = buf - buffer - HEADER_LEN;
    writeBinaryInteger(size, HEADER_LEN, buffer, len);

    if (queryResponse->DatabaseDiagnosticRecords != NULL)
	buf = writeSearchResponseInfo(queryResponse, buf, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readSearchResponseAPDU(SearchResponseAPDU **queryResponse, char *buffer)
{
    char *buf = buffer;
    long size;
    pdu_type pduType;
    long result, count, recordsReturned, nextPos;
    long resultStatus, presentStatus;
    any *refID = NULL;
    void *userInfo = NULL;

    /* read required part */
    buf = readBinaryInteger(&size, HEADER_LEN, buf);
    buf = readPDUType(&pduType, buf);
    buf = readBinaryInteger(&result, (size_t) 1, buf);
    buf = readBinaryInteger(&count, (size_t) 3, buf);
    buf = readBinaryInteger(&recordsReturned, (size_t) 3, buf);
    buf = readBinaryInteger(&nextPos, (size_t) 3, buf);

    resultStatus = presentStatus = UNUSED;
    refID = NULL;

    /* read optional part */
    while (buf < (buffer + size + HEADER_LEN)) {
	data_tag tag = peekTag(buf);

	switch (tag) {
	case DT_ResultSetStatus:
	    buf = readNum(&resultStatus, buf);
	    break;
	case DT_PresentStatus:
	    buf = readNum(&presentStatus, buf);
	    break;
	case DT_ReferenceID:
	    buf = readAny(&refID, buf);
	    break;
	default:
	    freeAny(refID);
	    REPORT_READ_ERROR(buf);
	    break;
	}
    }

    buf = readSearchResponseInfo(&userInfo, buf);
    if (buf == NULL)
	freeAny(refID);
    RETURN_ON_NULL(buf);

    /* construct the search object */
    *queryResponse = makeSearchResponseAPDU(result,
					    count,
					    recordsReturned,
					    nextPos,
					    (long) resultStatus,
					    (long) presentStatus,
					    refID,
					    userInfo);

    freeAny(refID);

    return (buf);
}

/*
 *	Routines originally from ZUtil.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 3.30.90  Harry Morris - Changed any->bits to any->bytes
 * 4.11.90  HWM - fixed include file names, changed
 *		- writeCompressedIntegerWithPadding() to
 *		  writeCompressedIntWithPadding()
 *		- generalized conditional includes (see c-dialect.h)
 * 3.7.91   Jonny Goldman.  Replaced "short" in makeBitMap with "int" line 632.
 */

char *readErrorPosition = NULL;	/* pos where buf stoped making sense */

/*----------------------------------------------------------------------*/
/* A note on error handling
   read - these are low level routines, they do not check the type tags
   which (sometimes) preceed the data (this is done by the higher
   level functions which call these functions).  There is no
   attempt made to check that the reading does not exceed the read
   buffer.  Such cases should be very rare and usually will be
   caught by the calling functions. (note - it is unlikely that
   a series of low level reads will go far off the edge without
   triggering a type error.  However, it is possible for a single
   bad read in an array function (eg. readAny) to attempt to read a
   large ammount, possibly causing a segmentation violation or out
   of memory condition.
 */
/*----------------------------------------------------------------------*/

diagnosticRecord *makeDiag(boolean surrogate, char *code, char *addInfo)
{
    diagnosticRecord *diag =
    (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));

    diag->SURROGATE = surrogate;
    MemCpy(diag->DIAG, code, DIAGNOSTIC_CODE_SIZE);
    diag->ADDINFO = s_strdup(addInfo);

    return (diag);
}

/*----------------------------------------------------------------------*/

void freeDiag(diagnosticRecord * diag)
{
    if (diag != NULL) {
	if (diag->ADDINFO != NULL)
	    s_free(diag->ADDINFO);
	s_free(diag);
    }
}

/*----------------------------------------------------------------------*/

#define END_OF_RECORD	0x1D

char *writeDiag(diagnosticRecord * diag, char *buffer, long *len)
/* diagnostics (as per Appendix D) have a very weird format - this changes
   in SR-1
 */
{
    char *buf = buffer;
    long length;

    if (diag == NULL)		/* handle unspecified optional args */
	return (buf);

    buf = writeTag(DT_DatabaseDiagnosticRecords, buf, len);
    CHECK_FOR_SPACE_LEFT(0, len);

    length = 3;
    if (diag->ADDINFO != NULL)
	length += strlen(diag->ADDINFO);

    if (length >= 0xFFFF)	/* make sure the length is reasonable */
    {
	length = 0xFFFF - 1;
	diag->ADDINFO[0xFFFF - 3 - 1] = '\0';
    }

    buf = writeBinaryInteger(length, 2, buf, len);

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[0];
    buf++;

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->DIAG[1];
    buf++;

    if (length > 3) {
	CHECK_FOR_SPACE_LEFT(3, len);
	MemCpy(buf, diag->ADDINFO, length - 3);
	buf += length - 3;
    }

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = diag->SURROGATE;
    buf++;

    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = END_OF_RECORD;
    buf++;

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readDiag(diagnosticRecord ** diag, char *buffer)
{
    char *buf = buffer;
    diagnosticRecord *d = (diagnosticRecord *) s_malloc((size_t) sizeof(diagnosticRecord));
    data_tag tag;
    long len;

    buf = readTag(&tag, buf);

    buf = readBinaryInteger(&len, 2, buf);

    d->DIAG[0] = buf[0];
    d->DIAG[1] = buf[1];
    d->DIAG[2] = '\0';

    if (len > 3) {
	d->ADDINFO = (char *) s_malloc((size_t) (len - 3 + 1));
	MemCpy(d->ADDINFO, (char *) (buf + 2), len - 3);
	d->ADDINFO[len - 3] = '\0';
    } else
	d->ADDINFO = NULL;

    d->SURROGATE = buf[len - 1];

    *diag = d;

    return (buf + len + 1);
}

/*----------------------------------------------------------------------*/

#define continueBit	0x80
#define dataMask	0x7F
#define dataBits	7

char *writeCompressedInteger(unsigned long num, char *buf, long *len)
/* write a binary integer in the format described on p. 40.
   this might be sped up
*/
{
    char byte;
    unsigned long i;
    unsigned long size;

    size = writtenCompressedIntSize(num);
    CHECK_FOR_SPACE_LEFT(size, len);

    for (i = size - 1; i != 0; i--) {
	byte = num & dataMask;
	if (i != (size - 1))	/* turn on continue bit */
	    byte = (char) (byte | continueBit);
	buf[i] = byte;
	num = num >> dataBits;	/* don't and here */
    }

    return (buf + size);
}

/*----------------------------------------------------------------------*/

char *readCompressedInteger(unsigned long *num, char *buf)
/* read a binary integer in the format described on p. 40.
   this might be sped up
*/
{
    long i = 0;
    unsigned char byte;

    *num = 0;

    do {
	byte = buf[i++];
	*num = *num << dataBits;
	*num += (byte & dataMask);
    }
    while (byte & continueBit);

    return (buf + i);
}

/*----------------------------------------------------------------------*/

#define pad	128		/* high bit is set */

char *writeCompressedIntWithPadding(unsigned long num,
				    unsigned long size,
				    char *buffer,
				    long *len)
/* Like writeCompressedInteger, except writes padding (128) to make
   sure that size bytes are used.  This can be read correctly by
   readCompressedInteger()
*/
{
    char *buf = buffer;
    unsigned long needed, padding;
    long i;

    CHECK_FOR_SPACE_LEFT(size, len);

    needed = writtenCompressedIntSize(num);
    padding = size - needed;
    i = padding - 1;

    for (i = padding - 1; i >= 0; i--) {
	buf[i] = pad;
    }

    buf = writeCompressedInteger(num, buf + padding, len);

    return (buf);
}

/*----------------------------------------------------------------------*/

unsigned long writtenCompressedIntSize(unsigned long num)
/* return the number of bytes needed to represnet the value num in
   compressed format.  curently limited to 4 bytes
 */
{
    if (num < CompressedInt1Byte)
	return (1);
    else if (num < CompressedInt2Byte)
	return (2);
    else if (num < CompressedInt3Byte)
	return (3);
    else
	return (4);
}

/*----------------------------------------------------------------------*/

char *writeTag(data_tag tag, char *buf, long *len)
/* write out a data tag */
{
    return (writeCompressedInteger(tag, buf, len));
}

/*----------------------------------------------------------------------*/

char *readTag(data_tag *tag, char *buf)
/* read a data tag */
{
    return (readCompressedInteger(tag, buf));
}

/*----------------------------------------------------------------------*/

unsigned long writtenTagSize(data_tag tag)
{
    return (writtenCompressedIntSize(tag));
}

/*----------------------------------------------------------------------*/

data_tag peekTag(char *buf)
/* read a data tag without advancing the buffer */
{
    data_tag tag;

    readTag(&tag, buf);
    return (tag);
}

/*----------------------------------------------------------------------*/

any *makeAny(unsigned long size, char *data)
{
    any *a = (any *) s_malloc((size_t) sizeof(any));

    a->size = size;
    a->bytes = data;
    return (a);
}

/*----------------------------------------------------------------------*/

void freeAny(any *a)
/* destroy an any and its associated data.  Assumes a->bytes was
   allocated using the s_malloc family of libraries
 */
{
    if (a != NULL) {
	if (a->bytes != NULL)
	    s_free(a->bytes);
	s_free(a);
    }
}

/*----------------------------------------------------------------------*/

any *duplicateAny(any *a)
{
    any *copy = NULL;

    if (a == NULL)
	return (NULL);

    copy = (any *) s_malloc((size_t) sizeof(any));

    copy->size = a->size;
    if (a->bytes == NULL)
	copy->bytes = NULL;
    else {
	copy->bytes = (char *) s_malloc((size_t) copy->size);
	MemCpy(copy->bytes, a->bytes, copy->size);
    }
    return (copy);
}

/*----------------------------------------------------------------------*/

char *writeAny(any *a, data_tag tag, char *buffer, long *len)
/* write an any + tag and size info */
{
    char *buf = buffer;

    if (a == NULL)		/* handle unspecified optional args */
	return (buf);

    /* write the tags */
    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(a->size, buf, len);

    /* write the bytes */
    CHECK_FOR_SPACE_LEFT(a->size, len);
    MemCpy(buf, a->bytes, a->size);

    return (buf + a->size);
}

/*----------------------------------------------------------------------*/

char *readAny(any **anAny, char *buffer)
/* read an any + tag and size info */
{
    char *buf;
    any *a;
    data_tag tag;

    a = (any *) s_malloc((size_t) sizeof(any));

    buf = buffer;

    buf = readTag(&tag, buf);

    buf = readCompressedInteger(&a->size, buf);

    /* now simply copy the bytes */
    a->bytes = (char *) s_malloc((size_t) a->size);
    MemCpy(a->bytes, buf, a->size);
    *anAny = a;

    return (buf + a->size);
}

/*----------------------------------------------------------------------*/

unsigned long writtenAnySize(data_tag tag, any *a)
{
    unsigned long size;

    if (a == NULL)
	return (0);

    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(a->size);
    size += a->size;
    return (size);
}

/*----------------------------------------------------------------------*/

any *stringToAny(char *s)
{
    any *a = NULL;

    if (s == NULL)
	return (NULL);

    a = (any *) s_malloc((size_t) sizeof(any));

    a->size = strlen(s);
    a->bytes = (char *) s_malloc((size_t) a->size);
    MemCpy(a->bytes, s, a->size);
    return (a);
}

/*----------------------------------------------------------------------*/

char *anyToString(any *a)
{
    char *s = NULL;

    if (a == NULL)
	return (NULL);

    s = s_malloc((size_t) (a->size + 1));
    MemCpy(s, a->bytes, a->size);
    s[a->size] = '\0';
    return (s);
}

/*----------------------------------------------------------------------*/

char *writeString(char *s, data_tag tag, char *buffer, long *len)
/* Write a C style string.  The terminating null is not written.
   This function is not part of the Z39.50 spec.  It is provided
   for the convienience of those wishing to pass C strings in
   the place of an any.
 */
{
    char *buf = buffer;
    any *data = NULL;

    if (s == NULL)
	return (buffer);	/* handle unused optional item before making an any */
    data = (any *) s_malloc((size_t) sizeof(any));

    data->size = strlen(s);
    data->bytes = s;		/* save a copy here by not using stringToAny() */
    buf = writeAny(data, tag, buf, len);
    s_free(data);		/* don't use freeAny() since it will free s too */
    return (buf);
}

/*----------------------------------------------------------------------*/

char *readString(char **s, char *buffer)
/* Read an any and convert it into a C style string.
   This function is not part of the Z39.50 spec.  It is provided
   for the convienience of those wishing to pass C strings in
   the place of an any.
 */
{
    any *data = NULL;
    char *buf = readAny(&data, buffer);

    *s = anyToString(data);
    freeAny(data);
    return (buf);
}

/*----------------------------------------------------------------------*/

unsigned long writtenStringSize(data_tag tag, char *s)
{
    unsigned long size;

    if (s == NULL)
	return (0);

    size = writtenTagSize(tag);
    size += writtenCompressedIntSize(size);
    size += strlen(s);
    return (size);
}

/*----------------------------------------------------------------------*/

any *longToAny(long num)
/* a convienience function */
{
    char s[40];

    sprintf(s, "%ld", num);

    return (stringToAny(s));
}

/*----------------------------------------------------------------------*/

long anyToLong(any *a)
/* a convienience function */
{
    long num;
    char *str = NULL;

    str = anyToString(a);
    sscanf(str, "%ld", &num);	/* could check the result and return
				   an error */
    s_free(str);
    return (num);
}

/*----------------------------------------------------------------------*/

#define bitsPerByte	8

bit_map *makeBitMap(unsigned long numBits,...)
/* construct and return a bitmap with numBits elements */
{
    va_list ap;
    unsigned long i, j;
    bit_map *bm = NULL;

    LYva_start(ap, numBits);

    bm = (bit_map *) s_malloc((size_t) sizeof(bit_map));

    bm->size = (unsigned long) (ceil((double) numBits / bitsPerByte));
    bm->bytes = (char *) s_malloc((size_t) bm->size);

    /* fill up the bits */
    for (i = 0; i < bm->size; i++)	/* iterate over bytes */
    {
	char byte = 0;

	for (j = 0; j < bitsPerByte; j++)	/* iterate over bits */
	{
	    if ((i * bitsPerByte + j) < numBits) {
		boolean bit = false;

		bit = (boolean) va_arg(ap, boolean);

		if (bit) {
		    byte = byte | (1 << (bitsPerByte - j - 1));
		}
	    }
	}
	bm->bytes[i] = byte;
    }

    va_end(ap);
    return (bm);
}

/*----------------------------------------------------------------------*/

void freeBitMap(bit_map *bm)
/* destroy a bit map created by makeBitMap() */
{
    s_free(bm->bytes);
    s_free(bm);
}

/*----------------------------------------------------------------------*/

/* use this routine to interpret a bit map.  pos specifies the bit
   number.  bit 0 is the Leftmost bit of the first byte.
   Could do bounds checking.
 */

boolean bitAtPos(unsigned long pos, bit_map *bm)
{
    if (pos > bm->size * bitsPerByte)
	return false;
    else
	return ((bm->bytes[(pos / bitsPerByte)] &
		 (0x80 >> (pos % bitsPerByte))) ?
		true : false);
}

/*----------------------------------------------------------------------*/

char *writeBitMap(bit_map *bm, data_tag tag, char *buffer, long *len)
/* write a bitmap + type and size info */
{
    return (writeAny((any *) bm, tag, buffer, len));
}

/*----------------------------------------------------------------------*/

char *readBitMap(bit_map **bm, char *buffer)
/* read a bitmap + type and size info */
{
    char *c;

    c = readAny((any **) bm, buffer);
    return (c);
}

/*----------------------------------------------------------------------*/

char *writeByte(unsigned long byte, char *buf, long *len)
{
    CHECK_FOR_SPACE_LEFT(1, len);
    buf[0] = byte & 0xFF;	/* we really only want the first byte */
    return (buf + 1);
}

/*----------------------------------------------------------------------*/

char *readByte(unsigned char *byte, char *buf)
{
    *byte = buf[0];
    return (buf + 1);
}

/*----------------------------------------------------------------------*/

char *writeBoolean(boolean flag, char *buf, long *len)
{
    return (writeByte(flag, buf, len));
}

/*----------------------------------------------------------------------*/

char *readBoolean(boolean *flag, char *buffer)
{
    unsigned char byte;
    char *buf = readByte(&byte, buffer);

    *flag = (byte == true) ? true : false;
    return (buf);
}

/*----------------------------------------------------------------------*/

char *writePDUType(pdu_type pduType, char *buf, long *len)
/* PDUType is a single byte */
{
    return (writeBinaryInteger((long) pduType, (unsigned long) 1, buf, len));
}

/*----------------------------------------------------------------------*/

char *readPDUType(pdu_type *pduType, char *buf)
/* PDUType is a single byte */
{
    return (readBinaryInteger((long *) pduType, (unsigned long) 1, buf));
}

/*----------------------------------------------------------------------*/

pdu_type peekPDUType(char *buf)
/* read the next pdu without advancing the buffer, Note that this
   function is to be used on a buffer that is known to contain an
   APDU.  The pdu_type is written HEADER_LEN bytes into the buffer
 */
{
    pdu_type pdu;

    readPDUType(&pdu, buf + HEADER_LEN);
    return (pdu);
}

/*----------------------------------------------------------------------*/

#define BINARY_INTEGER_BYTES	sizeof(long)	/* the number of bytes used by
						   a "binary integer" */
char *writeBinaryInteger(long num, unsigned long size, char *buf, long *len)
/* write out first size bytes of num - no type info
  XXX should this take unsigned longs instead ???  */
{
    long i;
    char byte;

    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (NULL);		/* error */

    CHECK_FOR_SPACE_LEFT(size, len);

    for (i = size - 1; i >= 0; i--) {
	byte = (char) (num & 255);
	buf[i] = byte;
	num = num >> bitsPerByte;	/* don't and here */
    }

    return (buf + size);
}

/*----------------------------------------------------------------------*/

char *readBinaryInteger(long *num, unsigned long size, char *buf)
/* read in first size bytes of num - no type info
  XXX this should take unsigned longs instead !!! */
{
    unsigned long i;
    unsigned char byte;

    if (size < 1 || size > BINARY_INTEGER_BYTES)
	return (buf);		/* error */
    *num = 0;

    for (i = 0; i < size; i++) {
	byte = buf[i];
	*num = *num << bitsPerByte;
	*num += byte;
    }

    return (buf + size);
}

/*----------------------------------------------------------------------*/

unsigned long writtenCompressedBinIntSize(long num)
/* return the number of bytes needed to represent the value num.
   currently limited to max of 4 bytes
   Only compresses for positive nums - negatives get whole 4 bytes
 */
{
    if (num < 0L)
	return (4);
    else if (num < 256L)	/* 2**8 */
	return (1);
    else if (num < 65536L)	/* 2**16 */
	return (2);
    else if (num < 16777216L)	/* 2**24 */
	return (3);
    else
	return (4);
}

/*----------------------------------------------------------------------*/

char *writeNum(long num, data_tag tag, char *buffer, long *len)
/* write a binary integer + size and tag info */
{
    char *buf = buffer;
    long size = writtenCompressedBinIntSize(num);

    if (num == UNUSED)
	return (buffer);

    buf = writeTag(tag, buf, len);
    buf = writeCompressedInteger(size, buf, len);
    buf = writeBinaryInteger(num, (unsigned long) size, buf, len);
    return (buf);
}

/*----------------------------------------------------------------------*/

char *readNum(long *num, char *buffer)
/* read a binary integer + size and tag info */
{
    char *buf = buffer;
    data_tag tag;
    unsigned long size;
    unsigned long val;

    buf = readTag(&tag, buf);
    buf = readCompressedInteger(&val, buf);
    size = (unsigned long) val;
    buf = readBinaryInteger(num, size, buf);
    return (buf);
}

/*----------------------------------------------------------------------*/

unsigned long writtenNumSize(data_tag tag, long num)
{
    long dataSize = writtenCompressedBinIntSize(num);
    long size;

    size = writtenTagSize(tag);	/* space for the tag */
    size += writtenCompressedIntSize(dataSize);		/* space for the size */
    size += dataSize;		/* space for the data */

    return (size);
}

/*----------------------------------------------------------------------*/

typedef void (voidfunc) (void *);

void doList(void **list, voidfunc * func)
/* call func on each element of the NULL terminated list of pointers */
{
    register long i;
    register void *ptr = NULL;

    if (list == NULL)
	return;
    for (i = 0, ptr = list[i]; ptr != NULL; ptr = list[++i])
	(*func) (ptr);
}

/*----------------------------------------------------------------------*/

char *writeProtocolVersion(char *buf, long *len)
/* write a bitmap describing the protocols available */
{
    static bit_map *version = NULL;

    if (version == NULL) {
	version = makeBitMap((unsigned long) 1, true);	/* version 1! */
    }

    return (writeBitMap(version, DT_ProtocolVersion, buf, len));
}

/*----------------------------------------------------------------------*/

char *defaultImplementationID(void)
{
    static char ImplementationID[] = "TMC";

    return (ImplementationID);
}

/*----------------------------------------------------------------------*/

char *defaultImplementationName(void)
{
    static char ImplementationName[] = "Thinking Machines Corporation Z39.50";

    return (ImplementationName);
}

/*----------------------------------------------------------------------*/

char *defaultImplementationVersion(void)
{
    static char ImplementationVersion[] = "2.0A";

    return (ImplementationVersion);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from ZType1.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */
/*----------------------------------------------------------------------*/

query_term *makeAttributeTerm(char *use,
			      char *relation,
			      char *position,
			      char *structure,
			      char *truncation,
			      char *completeness,
			      any *term)
{
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));

    qt->TermType = TT_Attribute;

    /* copy in the attributes */
    LYStrNCpy(qt->Use, use, ATTRIBUTE_SIZE);
    LYStrNCpy(qt->Relation, relation, ATTRIBUTE_SIZE);
    LYStrNCpy(qt->Position, position, ATTRIBUTE_SIZE);
    LYStrNCpy(qt->Structure, structure, ATTRIBUTE_SIZE);
    LYStrNCpy(qt->Truncation, truncation, ATTRIBUTE_SIZE);
    LYStrNCpy(qt->Completeness, completeness, ATTRIBUTE_SIZE);

    qt->Term = duplicateAny(term);

    qt->ResultSetID = NULL;

    return (qt);
}

/*----------------------------------------------------------------------*/

query_term *makeResultSetTerm(any *resultSet)
{
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));

    qt->TermType = TT_ResultSetID;

    qt->ResultSetID = duplicateAny(resultSet);

    qt->Term = NULL;

    return (qt);
}

/*----------------------------------------------------------------------*/

query_term *makeOperatorTerm(char *operatorCode)
{
    query_term *qt = (query_term *) s_malloc((size_t) sizeof(query_term));

    qt->TermType = TT_Operator;

    LYStrNCpy(qt->Operator, operatorCode, OPERATOR_SIZE);

    qt->Term = NULL;
    qt->ResultSetID = NULL;

    return (qt);
}

/*----------------------------------------------------------------------*/

void freeTerm(void *param)
{
    query_term *qt = (query_term *) param;

    switch (qt->TermType) {
    case TT_Attribute:
	freeAny(qt->Term);
	break;
    case TT_ResultSetID:
	freeAny(qt->ResultSetID);
	break;
    case TT_Operator:
	/* do nothing */
	break;
    default:
	panic("Implementation error: Unknown term type %ld",
	      qt->TermType);
	break;
    }
    s_free(qt);
}

/*----------------------------------------------------------------------*/

#define ATTRIBUTE_LIST_SIZE	ATTRIBUTE_SIZE * 6
#define AT_DELIMITER	" "

char *writeQueryTerm(query_term *qt, char *buffer, long *len)
{
    char *buf = buffer;
    char attributes[ATTRIBUTE_LIST_SIZE];

    switch (qt->TermType) {
    case TT_Attribute:
	LYStrNCpy(attributes, qt->Use, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Relation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Position, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Structure, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Truncation, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, AT_DELIMITER, sizeof(AT_DELIMITER) + 1, ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes, qt->Completeness, ATTRIBUTE_SIZE, ATTRIBUTE_LIST_SIZE);
	buf = writeString(attributes, DT_AttributeList, buf, len);
	buf = writeAny(qt->Term, DT_Term, buf, len);
	break;
    case TT_ResultSetID:
	buf = writeAny(qt->ResultSetID, DT_ResultSetID, buf, len);
	break;
    case TT_Operator:
	buf = writeString(qt->Operator, DT_Operator, buf, len);
	break;
    default:
	panic("Implementation error: Unknown term type %ld",
	      qt->TermType);
	break;
    }

    return (buf);
}

/*----------------------------------------------------------------------*/

char *readQueryTerm(query_term **qt, char *buffer)
{
    char *buf = buffer;
    char *attributeList = NULL;
    char *operator = NULL;
    any *term;
    char *use = NULL;
    char *relation = NULL;
    char *position = NULL;
    char *structure = NULL;
    char *truncation = NULL;
    char *completeness;
    any *resultSetID = NULL;
    data_tag tag;

    tag = peekTag(buffer);

    switch (tag) {
    case DT_AttributeList:
	buf = readString(&attributeList, buf);
	buf = readAny(&term, buf);
	use = strtok(attributeList, AT_DELIMITER);
	relation = strtok(NULL, AT_DELIMITER);
	position = strtok(NULL, AT_DELIMITER);
	structure = strtok(NULL, AT_DELIMITER);
	truncation = strtok(NULL, AT_DELIMITER);
	completeness = strtok(NULL, AT_DELIMITER);
	*qt = makeAttributeTerm(use, relation, position, structure,
				truncation, completeness, term);
	s_free(attributeList);
	freeAny(term);
	break;
    case DT_ResultSetID:
	buf = readAny(&resultSetID, buf);
	*qt = makeResultSetTerm(resultSetID);
	freeAny(resultSetID);
	break;
    case DT_Operator:
	buf = readString(&operator, buf);
	*qt = makeOperatorTerm(operator);
	s_free(operator);
	break;
    default:
	REPORT_READ_ERROR(buf);
	break;
    }

    return (buf);
}

/*----------------------------------------------------------------------*/

static unsigned long getQueryTermSize(query_term *qt);

static unsigned long getQueryTermSize(query_term *qt)
/* figure out how many bytes it will take to write this query */
{
    unsigned long size = 0;
    static char attributes[] = "11 22 33 44 55 66";	/* we just need this to

							   calculate its written
							   size */

    switch (qt->TermType) {
    case TT_Attribute:
	size = writtenStringSize(DT_AttributeList, attributes);
	size += writtenAnySize(DT_Term, qt->Term);
	break;
    case TT_ResultSetID:
	size = writtenAnySize(DT_ResultSetID, qt->ResultSetID);
	break;
    case TT_Operator:
	size = writtenStringSize(DT_Operator, qt->Operator);
	break;
    default:
	panic("Implementation error: Unknown term type %ld",
	      qt->TermType);
	break;
    }

    return (size);
}

/*----------------------------------------------------------------------*/

/* A query is simply a null terminated list of query terms.  For
   transmission, a query is written into an any which is sent as
   the user information field. */

any *writeQuery(query_term **terms)
{
    any *info = NULL;
    char *writePos = NULL;
    char *data = NULL;
    unsigned long size = 0;
    long remaining = 0;
    long i;
    query_term *qt = NULL;

    if (terms == NULL)
	return (NULL);

    /* calculate the size of write buffer */
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	size += getQueryTermSize(qt);

    data = (char *) s_malloc((size_t) size);

    /* write the terms */
    writePos = data;
    remaining = size;
    for (i = 0, qt = terms[i]; qt != NULL; qt = terms[++i])
	writePos = writeQueryTerm(qt, writePos, &remaining);

    info = makeAny(size, data);

    return (info);
}

/*----------------------------------------------------------------------*/

query_term **readQuery(any *info)
{
    char *readPos = info->bytes;
    query_term **terms = NULL;
    query_term *qt = NULL;
    long numTerms = 0L;
    char tmp[100];

    sprintf(tmp, "readquery: bytes: %ld", info->size);
    log_write(tmp);

    while (readPos < info->bytes + info->size) {
	readPos = readQueryTerm(&qt, readPos);

	if (terms == NULL) {
	    terms = (query_term **) s_malloc((size_t) (sizeof(query_term *) * 2));
	} else {
	    terms =
		(query_term **) s_realloc((char *) terms,
					  (size_t) (sizeof(query_term *) *
						      (numTerms + 2)));
	}
	if (qt == NULL)
	    log_write("qt = null");
	terms[numTerms++] = qt;
	terms[numTerms] = NULL;
    }

    return (terms);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from panic.c -- FM
 *
 *----------------------------------------------------------------------*/
/* WIDE AREA INFORMATION SERVER SOFTWARE:
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * Morris@@think.com
 */

/* panic is an error system interface.  On the Mac, it will pop
 * up a little window to explain the problem.
 * On a unix box, it will print out the error and call perror()
 */

/*----------------------------------------------------------------------*/

static void exitAction(long error);

static void exitAction(long error GCC_UNUSED)
{
    exit_immediately(EXIT_SUCCESS);
}

/*----------------------------------------------------------------------*/

#define PANIC_HEADER "Fatal Error:  "

void panic(char *format,...)
{
    va_list ap;			/* the variable arguments */

    fprintf(stderr, PANIC_HEADER);
    LYva_start(ap, format);	/* init ap */
    vfprintf(stderr, format, ap);	/* print the contents */
    va_end(ap);			/* free ap */
    fflush(stderr);

    exitAction(0);
}

/*----------------------------------------------------------------------*/

/*
 *	Routines originally from cutil.c -- FM
 *
 *----------------------------------------------------------------------*/
/* Wide AREA INFORMATION SERVER SOFTWARE
 * No guarantees or restrictions.  See the readme file for the full standard
 * disclaimer.
 *
 * 3.26.90	Harry Morris, morris@@think.com
 * 4.11.90  HWM - generalized conditional includes (see c-dialect.h)
 */

/*----------------------------------------------------------------------*/

void fs_checkPtr(void *ptr)
/* If the ptr is NULL, give an error */
{
    if (ptr == NULL)
	panic("checkPtr found a NULL pointer");
}

/*----------------------------------------------------------------------*/

void *fs_malloc(size_t size)
/* does safety checks and optional accounting */
{
    register void *ptr = NULL;

    ptr = (void *) calloc((size_t) size, (size_t) 1);
    s_checkPtr(ptr);

    return (ptr);
}

/*----------------------------------------------------------------------*/

void *fs_realloc(void *ptr, size_t size)
/* does safety checks and optional accounting
   note - we don't know how big ptr's memory is, so we can't ensure
   that any new memory allocated is NULLed!
 */
{
    register void *nptr = NULL;

    if (ptr == NULL)		/* this is really a malloc */
	return (s_malloc(size));

    nptr = (void *) realloc(ptr, size);
    s_checkPtr(ptr);

    return (nptr);
}

/*----------------------------------------------------------------------*/

void fs_free(void *ptr)
/* does safety checks and optional accounting */
{
    if (ptr != NULL)		/* some non-ansi compilers/os's cant handle freeing null */
    {				/* if we knew the size of this block of memory, we could clear it - oh well */
	free(ptr);
	ptr = NULL;
    }
}

/*----------------------------------------------------------------------*/

char *s_strdup(char *s)

/* return a copy of s.  This is identical to the standard library routine
   strdup(), except that it is safe.  If s == NULL or malloc fails,
   appropriate action is taken.
 */
{
    unsigned long len;
    char *copy = NULL;

    if (s == NULL)		/* saftey check to postpone stupid errors */
	return (NULL);

    len = strlen(s);		/* length of string - terminator */
    copy = (char *) s_malloc((size_t) (sizeof(char) * (len + 1)));

    StrNCpy(copy, s, len + 1);
    return (copy);
}

/*----------------------------------------------------------------------*/

char *fs_strncat(char *dst, char *src, size_t maxToAdd, size_t maxTotal)

/* like strncat, except the fourth argument limits the maximum total
   length of the resulting string
 */
{
    size_t dstSize = strlen(dst);
    size_t srcSize = strlen(src);

    if (dstSize + srcSize < maxTotal)	/* use regular old strncat */
	return (StrNCat(dst, src, maxToAdd));
    else {
	size_t truncateTo = maxTotal - dstSize - 1;
	char saveChar = src[truncateTo];
	char *result = NULL;

	src[truncateTo] = '\0';
	result = StrNCat(dst, src, maxToAdd);
	src[truncateTo] = saveChar;
	return (result);
    }
}

/*----------------------------------------------------------------------*/

char char_downcase(unsigned long long_ch)
{
    unsigned char ch = long_ch & 0xFF;	/* just want one byte */

    /* when ansi is the way of the world, this can be tolower */
    return (((ch >= 'A') && (ch <= 'Z')) ? (ch + 'a' - 'A') : ch);
}

char *string_downcase(char *word)
{
    long i = 0;

    while (word[i] != '\0') {
	word[i] = char_downcase((unsigned long) word[i]);
	i++;
    }
    return (word);
}

/*----------------------------------------------------------------------*/
#endif /* VMS */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTVMS_WaisUI.c,v 1.15 2008/12/14 18:06:19 tom Exp $
d246 1
a246 2
	strncpy(length_array, header.msg_len, 10);
	length_array[10] = '\0';
d697 1
a697 1
								       (i + 2)));
d715 1
a715 1
								         (i + 2)));
d789 1
a789 1
		    strncpy(scratch, ES_DELIMITER_1, 2);
d1025 1
a1025 1
    memcpy(diag->DIAG, code, DIAGNOSTIC_CODE_SIZE);
d1082 1
a1082 1
	memcpy(buf, diag->ADDINFO, (size_t) length - 3);
d1116 1
a1116 1
	memcpy(d->ADDINFO, (char *) (buf + 2), (size_t) (len - 3));
d1303 1
a1303 1
	memcpy(copy->bytes, a->bytes, (size_t) copy->size);
d1324 1
a1324 1
    memcpy(buf, a->bytes, (size_t) a->size);
d1348 1
a1348 1
    memcpy(a->bytes, buf, (size_t) a->size);
d1382 1
a1382 1
    memcpy(a->bytes, s, (size_t) a->size);
d1396 1
a1396 1
    memcpy(s, a->bytes, (size_t) a->size);
d1835 6
a1840 6
    strncpy(qt->Use, use, ATTRIBUTE_SIZE);
    strncpy(qt->Relation, relation, ATTRIBUTE_SIZE);
    strncpy(qt->Position, position, ATTRIBUTE_SIZE);
    strncpy(qt->Structure, structure, ATTRIBUTE_SIZE);
    strncpy(qt->Truncation, truncation, ATTRIBUTE_SIZE);
    strncpy(qt->Completeness, completeness, ATTRIBUTE_SIZE);
d1872 1
a1872 1
    strncpy(qt->Operator, operatorCode, OPERATOR_SIZE);
d1916 1
a1916 1
	strncpy(attributes, qt->Use, ATTRIBUTE_LIST_SIZE);
d2228 1
a2228 1
    strncpy(copy, s, len + 1);
d2244 1
a2244 1
	return (strncat(dst, src, maxToAdd));
d2251 1
a2251 1
	result = strncat(dst, src, maxToAdd);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
a3 1
/*							HTVMS_WAISUI.c
d2124 1
a2124 4
    long i;

    for (i = 0; i < 100000; i++) ;
    exit_immediately(0);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 6
a7 6
**
**	Adaptation for Lynx by F.Macrides (macrides@@sci.wfeb.edu)
**
**	30-May-1994 FM	Initial version.
**
**----------------------------------------------------------------------*/
d10 3
a12 3
**	Routines originally from UI.c -- FM
**
**----------------------------------------------------------------------*/
d14 5
a18 5
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   Brewster@@think.com
*/
d39 2
d45 1
a45 1
#undef MAXINT	/* we don't need it here, and www_tcp.h may conflict */
d51 1
a51 2
void
log_write(char *s GCC_UNUSED)
d61 45
a105 45
char *
generate_search_apdu(
char* buff,     /* buffer to hold the apdu */
long *buff_len,    /* length of the buffer changed to reflect new data written */
char *seed_words,    /* string of the seed words */
char *database_name,
DocObj** docobjs,
long maxDocsRetrieved)
{
  /* local variables */

  SearchAPDU *search3;
  char  *end_ptr;
  static char *database_names[2] = {"", 0};
  any refID;
  WAISSearch *query;
  refID.size = 1;
  refID.bytes = "3";

  database_names[0] = database_name;
  query = makeWAISSearch(seed_words,
                         docobjs, /* DocObjsPtr */
                         0,
                         1,     /* DateFactor */
                         0,     /* BeginDateRange */
                         0,     /* EndDateRange */
                         maxDocsRetrieved
                         );

  search3 = makeSearchAPDU(30,
			   5000, /* should be large */
			   30,
                           1,	/* replace indicator */
                           "",	/* result set name */
                           database_names, /* database name */
                           QT_RelevanceFeedbackQuery, /* query_type */
                           0,   /* element name */
                           NULL, /* reference ID */
                           query);

  end_ptr = writeSearchAPDU(search3, buff, buff_len);

  CSTFreeWAISSearch(query);
  freeSearchAPDU(search3);
  return(end_ptr);
d114 55
a168 57
char *
generate_retrieval_apdu(
char *buff,
long *buff_len,    /* length of the buffer changed to reflect new data written */
any *docID,
long chunk_type,
long start,
long end,
char *type,
char *database_name)
{
  SearchAPDU *search;
  char  *end_ptr;

  static char *database_names[2];
  static char *element_names[3];
  any refID;

  DocObj *DocObjs[2];
  any *query;			/* changed from char* by brewster */

  if(NULL == type)
    type = s_strdup("TEXT");

  database_names[0] = database_name;
  database_names[1] = NULL;

  element_names[0] = " ";
  element_names[1] = ES_DocumentText;
  element_names[2] = NULL;

  refID.size = 1;
  refID.bytes = "3";

  switch(chunk_type){
  case CT_line:
    DocObjs[0] = makeDocObjUsingLines(docID, type, start, end);
    break;
  case CT_byte:
    DocObjs[0] = makeDocObjUsingBytes(docID, type, start, end);
    break;
  }
  DocObjs[1] = NULL;

  query = makeWAISTextQuery(DocObjs);
  search = makeSearchAPDU( 10, 16, 15,
			  1,	/* replace indicator */
			  "FOO", /* result set name */
			  database_names, /* database name */
			  QT_TextRetrievalQuery, /* query_type */
			  element_names, /* element name */
			  &refID, /* reference ID */
			  query);
  end_ptr = writeSearchAPDU(search, buff, buff_len);
  CSTFreeWAISTextQuery(query);
  freeSearchAPDU(search);
  return(end_ptr);
d178 1
a178 1
PRIVATE long read_from_stream(int d, char *buf, long nbytes)
d180 19
a198 19
  long didRead;
  long toRead = nbytes;
  long totalRead = 0;		/* paranoia */

  while (toRead > 0){
    didRead = NETREAD (d, buf, (int)toRead);
    if(didRead == HT_INTERRUPTED)
      return(HT_INTERRUPTED);
    if(didRead == -1)		/* error*/
      return(-1);
    if(didRead == 0)		/* eof */
      return(-2);		/* maybe this should return 0? */
    toRead -= didRead;
    buf += didRead;
    totalRead += didRead;
  }
  if(totalRead != nbytes)	/* we overread for some reason */
    return(- totalRead);	/* bad news */
  return(totalRead);
d205 28
a232 19
PRIVATE long
transport_message(
	long connection,
	char *request_message,
	long request_length,
	char *response_message,
	long response_buffer_length)
{
  WAISMessage header;
  long response_length;
  int rv;


  /* Write out message.  Read back header.  Figure out response length. */

  if( request_length + HEADER_LENGTH !=
      NETWRITE(connection,request_message,
		  (int)( request_length +HEADER_LENGTH)) )
    return 0;
d234 5
a238 1
  /* read for the first '0' */
d240 33
a272 2
  while(1){
    rv = read_from_stream(connection, response_message, 1);
d274 1
a274 1
      return HT_INTERRUPTED;
d276 2
a277 47
      return 0;
    if('0' == response_message[0])
      break;
  }

  rv = read_from_stream(connection, response_message + 1, HEADER_LENGTH -1);
  if (rv == HT_INTERRUPTED)
    return HT_INTERRUPTED;
  if (rv < 0)
    return 0;

  readWAISPacketHeader(response_message, &header);
  {
    char length_array[11];
    strncpy(length_array, header.msg_len, 10);
    length_array[10] = '\0';
    response_length = atol(length_array);
    /*
      if(verbose){
      printf("WAIS header: '%s' length_array: '%s'\n",
      response_message, length_array);
      }
      */
    if(response_length > response_buffer_length){
      /* we got a message that is too long, therefore empty the message out,
	 and return 0 */
      long i;
      for(i = 0; i < response_length; i++){
	rv = read_from_stream(connection,
			      response_message + HEADER_LENGTH,
			      1);
	if (rv == HT_INTERRUPTED)
	  return HT_INTERRUPTED;
	if (rv < 0)
	  return 0;
      }
      return(0);
    }
  }
  rv = read_from_stream(connection,
			response_message + HEADER_LENGTH,
			response_length);
  if (rv == HT_INTERRUPTED)
    return HT_INTERRUPTED;
  if (rv < 0)
    return 0;
  return(response_length);
d283 38
a320 41
long
interpret_message(
	char *request_message,
	long request_length, /* length of the buffer */
	char *response_message,
	long response_buffer_length,
	long connection,
	boolean verbose GCC_UNUSED)
{
  long response_length;

  /* ?
  if(verbose){
    printf ("sending");
    if(hostname_internal && strlen(hostname_internal) > 0)
      printf(" to host %s", hostname_internal);
    if(service_name && strlen(service_name) > 0)
      printf(" for service %s", service_name);
    printf("\n");
    twais_dsply_rsp_apdu(request_message + HEADER_LENGTH,
			 request_length);
  }

  */

  writeWAISPacketHeader(request_message,
			request_length,
			(long)'z',	/* Z39.50 */
			"wais      ", /* server name */
			(long)NO_COMPRESSION,	/* no compression */
			(long)NO_ENCODING,(long)HEADER_VERSION);
  if(connection != 0) {
    response_length = transport_message(connection, request_message,
					request_length,
					response_message,
					response_buffer_length);
    if (response_length == HT_INTERRUPTED)
      return(HT_INTERRUPTED);
  }
  else
      return(0);
d322 1
a322 1
  return(response_length);
d329 1
a329 1
PRIVATE char *delete_seeker_codes(char *string, long *length)
d331 14
a344 10
  long original_count; /* index into the original string */
  long new_count = 0; /* index into the collapsed string */
  for(original_count = 0; original_count < *length; original_count++){
    if(27 == string[original_count]){
      /* then we have an escape code */
      /* if the next letter is '(' or ')', then ignore two letters */
      if('(' == string[original_count + 1] ||
    ')' == string[original_count + 1])
     original_count += 1;    /* it is a term marker */
      else original_count += 4; /* it is a paragraph marker */
d346 2
a347 4
    else string[new_count++] = string[original_count];
  }
  *length = new_count;
  return(string);
d352 1
a352 1
#if defined(VMS) && defined(__GNUC__)			/* 10-AUG-1995 [pr] */
d365 2
a366 1
static __const void *__const ctype_dummy[] = { &_ctype_, &ctype_dummy };
d372 19
a390 18
  long length = strlen(headline) + 1; /* include the trailing null */
  size_t i;
  headline = delete_seeker_codes(headline, &length);
  /* delete leading spaces */
  for(i=0; i < strlen(headline); i++){
    if(isprint(headline[i])){
      break;
    }
  }
  headline = headline + i;
  /* delete trailing stuff */
  for(i=strlen(headline) - 1 ; i > 0; i--){
    if(isprint(headline[i])){
      break;
    }
    headline[i] = '\0';
  }
  return(headline);
a394 1

d396 3
a398 3
**	Routines originally from ZProt.c -- FM
**
**----------------------------------------------------------------------*/
d400 7
a406 7
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   3.30.90  Harry Morris - Changed any->bits to any->bytes
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
*/
d417 14
a430 16
InitResponseAPDU*
makeInitResponseAPDU(
boolean result,
boolean search,
boolean present,
boolean deleteIt,
boolean accessControl,
boolean resourceControl,
long prefSize,
long maxMsgSize,
char* auth,
char* id,
char* name,
char* version,
any* refID,
void* userInfo)
d433 1
a433 1
  InitResponseAPDU* init = (InitResponseAPDU*)s_malloc((size_t)sizeof(InitResponseAPDU));
d435 15
a449 15
  init->PDUType = initResponseAPDU;
  init->Result = result;
  init->willSearch = search;
  init->willPresent = present;
  init->willDelete = deleteIt;
  init->supportAccessControl = accessControl;
  init->supportResourceControl = resourceControl;
  init->PreferredMessageSize = prefSize;
  init->MaximumRecordSize = maxMsgSize;
  init->IDAuthentication = s_strdup(auth);
  init->ImplementationID = s_strdup(id);
  init->ImplementationName = s_strdup(name);
  init->ImplementationVersion = s_strdup(version);
  init->ReferenceID = duplicateAny(refID);
  init->UserInformationField = userInfo; /* not copied! */
d451 1
a451 1
  return(init);
d456 1
a456 2
void
freeInitResponseAPDU(InitResponseAPDU* init)
d459 6
a464 6
  s_free(init->IDAuthentication);
  s_free(init->ImplementationID);
  s_free(init->ImplementationName);
  s_free(init->ImplementationVersion);
  freeAny(init->ReferenceID);
  s_free(init);
d469 1
a469 2
char*
writeInitResponseAPDU(InitResponseAPDU* init, char* buffer, long* len)
d472 98
a569 77
  char* buf = buffer + HEADER_LEN; /* leave room for the header-length-indicator */
  long size;
  bit_map* optionsBM = NULL;

  RESERVE_SPACE_FOR_HEADER(len);

  buf = writePDUType(init->PDUType,buf,len);
  buf = writeBoolean(init->Result,buf,len);
  buf = writeProtocolVersion(buf,len);

  optionsBM = makeBitMap((unsigned long)5,init->willSearch,init->willPresent,
                         init->willDelete,init->supportAccessControl,
                         init->supportResourceControl);
  buf = writeBitMap(optionsBM,DT_Options,buf,len);
  freeBitMap(optionsBM);

  buf = writeNum(init->PreferredMessageSize,DT_PreferredMessageSize,buf,len);
  buf = writeNum(init->MaximumRecordSize,DT_MaximumRecordSize,buf,len);
  buf = writeString(init->IDAuthentication,DT_IDAuthentication,buf,len);
  buf = writeString(init->ImplementationID,DT_ImplementationID,buf,len);
  buf = writeString(init->ImplementationName,DT_ImplementationName,buf,len);
  buf = writeString(init->ImplementationVersion,DT_ImplementationVersion,buf,len);
  buf = writeAny(init->ReferenceID,DT_ReferenceID,buf,len);

  /* go back and write the header-length-indicator */
  RELEASE_HEADER_SPACE(len);
  size = buf - buffer - HEADER_LEN;
  writeBinaryInteger(size,HEADER_LEN,buffer,len);

  if (init->UserInformationField != NULL)
    buf = writeInitResponseInfo(init,buf,len);

  return(buf);
}

/*----------------------------------------------------------------------*/

char*
readInitResponseAPDU(InitResponseAPDU** init, char* buffer)
{
  char* buf = buffer;
  boolean search,present,delete,accessControl,resourceControl;
  long prefSize,maxMsgSize;
  char *auth,*id,*name,*version;
  long size;
  pdu_type pduType;
  bit_map* versionBM = NULL;
  bit_map* optionsBM = NULL;
  boolean result;
  any *refID = NULL;
  void* userInfo = NULL;

  auth = id = name = version = NULL;
  refID = NULL;

  /* read required part */
  buf = readBinaryInteger(&size,HEADER_LEN,buf);
  buf = readPDUType(&pduType,buf);
  buf = readBoolean(&result,buf);
  buf = readBitMap(&versionBM,buf);
  buf = readBitMap(&optionsBM,buf);
  buf = readNum(&prefSize,buf);
  buf = readNum(&maxMsgSize,buf);

  /* decode optionsBM */
  search = bitAtPos(0,optionsBM);
  present = bitAtPos(1,optionsBM);
  delete = bitAtPos(2,optionsBM);
  accessControl = bitAtPos(3,optionsBM);
  resourceControl = bitAtPos(4,optionsBM);

  /* read optional part */
  while (buf < (buffer + size + HEADER_LEN))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_IDAuthentication:
	    buf = readString(&auth,buf);
d571 2
a572 2
	  case DT_ImplementationID:
	    buf = readString(&id,buf);
d574 2
a575 2
	  case DT_ImplementationName:
	    buf = readString(&name,buf);
d577 2
a578 2
	  case DT_ImplementationVersion:
	    buf = readString(&version,buf);
d580 2
a581 2
	  case DT_ReferenceID:
	    buf = readAny(&refID,buf);
d583 1
a583 1
	  default:
d593 1
a593 1
	  }
d596 35
a630 11
  buf = readInitResponseInfo(&userInfo,buf);
  if (buf == NULL)
    { freeBitMap(versionBM);
      freeBitMap(optionsBM);
      s_free(auth);
      s_free(id);
      s_free(name);
      s_free(version);
      freeAny(refID);
    }
  RETURN_ON_NULL(buf);
d632 1
a632 14
  /* construct the basic init object */
  *init = makeInitResponseAPDU(result,
			       search,present,delete,accessControl,resourceControl,
			       prefSize,maxMsgSize,auth,id,name,version,refID,userInfo);

  freeBitMap(versionBM);
  freeBitMap(optionsBM);
  s_free(auth);
  s_free(id);
  s_free(name);
  s_free(version);
  freeAny(refID);

  return(buf);
d637 1
a637 2
InitResponseAPDU*
replyToInitAPDU(InitAPDU* init, boolean result, void* userInfo)
d642 17
a658 9
  InitResponseAPDU* initResp;
  initResp = makeInitResponseAPDU(result,
				  init->willSearch,init->willPresent,init->willDelete,
				  init->supportAccessControl,init->supportResourceControl,
				  init->PreferredMessageSize,init->MaximumRecordSize,
				  init->IDAuthentication,defaultImplementationID(),defaultImplementationName(),
				  defaultImplementationVersion(),
				  init->ReferenceID,userInfo);
  return(initResp);
d663 35
a697 30
SearchAPDU*
makeSearchAPDU(
long small,
long large,
long medium,
boolean replace,
char* name,
char** databases,
char* type,
char** elements,
any* refID,
void* queryInfo)
{
  char* ptr = NULL;
  long i;
  SearchAPDU* query = (SearchAPDU*)s_malloc((size_t)sizeof(SearchAPDU));
  query->PDUType = searchAPDU;
  query->SmallSetUpperBound = small;
  query->LargeSetLowerBound = large;
  query->MediumSetPresentNumber = medium;
  query->ReplaceIndicator = replace;
  query->ResultSetName = s_strdup(name);
  query->DatabaseNames = NULL;
  if (databases != NULL) {
    for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i]) {
	if (query->DatabaseNames == NULL)
	    query->DatabaseNames = (char**)s_malloc((size_t)(sizeof(char*) * 2));
        else
          query->DatabaseNames = (char**)s_realloc((char*)query->DatabaseNames,
						   (size_t)(sizeof(char*) * (i + 2)));
d699 1
a699 1
	    query->DatabaseNames[i+1] = NULL;
d702 14
a715 9
  query->QueryType = s_strdup(type);
  query->ElementSetNames = NULL;
  if (elements != NULL) {
    for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i]) {
	if (query->ElementSetNames == NULL)
	    query->ElementSetNames = (char**)s_malloc((size_t)(sizeof(char*) * 2));
        else
          query->ElementSetNames = (char**)s_realloc((char*)query->ElementSetNames,
						     (size_t)(sizeof(char*) * (i + 2)));
d717 6
a722 6
	    query->ElementSetNames[i+1] = NULL;
	  }
      }
  query->ReferenceID = duplicateAny(refID);
  query->Query = queryInfo;	/* not copied! */
  return(query);
d727 10
a736 11
void
freeSearchAPDU(SearchAPDU* query)
{
  s_free(query->ResultSetName);
  s_free(query->QueryType);
  doList((void**)query->DatabaseNames,fs_free); /* can't use the macro here ! */
  s_free(query->DatabaseNames);
  doList((void**)query->ElementSetNames,fs_free); /* can't use the macro here ! */
  s_free(query->ElementSetNames);
  freeAny(query->ReferenceID);
  s_free(query);
d745 1
a745 2
char*
writeSearchAPDU(SearchAPDU* query, char* buffer, long* len)
d747 27
a773 24
  char* buf = buffer + HEADER_LEN; /* leave room for the header-length-indicator */
  long size,i;
  char* ptr = NULL;
  char* scratch = NULL;

  RESERVE_SPACE_FOR_HEADER(len);

  buf = writePDUType(query->PDUType,buf,len);
  buf = writeBinaryInteger(query->SmallSetUpperBound,(size_t)3,buf,len);
  buf = writeBinaryInteger(query->LargeSetLowerBound,(size_t)3,buf,len);
  buf = writeBinaryInteger(query->MediumSetPresentNumber,(size_t)3,buf,len);
  buf = writeBoolean(query->ReplaceIndicator,buf,len);
  buf = writeString(query->ResultSetName,DT_ResultSetName,buf,len);
  /* write database names */
  if (query->DatabaseNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL; ptr = query->DatabaseNames[++i]) {
	if (scratch == NULL)
	    scratch = s_strdup(ptr);
        else
	  { size_t newScratchSize = (size_t)(strlen(scratch) + strlen(ptr) + 2);
	    scratch = (char*)s_realloc(scratch,newScratchSize);
	    s_strncat(scratch,DB_DELIMITER,2,newScratchSize);
	    s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize);
	  }
d775 1
a775 1
	buf = writeString(scratch,DT_DatabaseNames,buf,len);
d777 24
a800 10
      }
  buf = writeString(query->QueryType,DT_QueryType,buf,len);
  /* write element set names */
  if (query->ElementSetNames != NULL) {
    for (i = 0,scratch = NULL, ptr = query->ElementSetNames[i]; ptr != NULL; ptr = query->ElementSetNames[++i]) {
	if (scratch == NULL) {
	    if (query->ElementSetNames[i+1] == NULL) /* there is a single element set name */
		{ scratch = (char*)s_malloc((size_t)strlen(ptr) + 2);
		  strncpy(scratch,ES_DELIMITER_1,2);
		  s_strncat(scratch,ptr,strlen(ptr) + 1,strlen(ptr) + 2);
d802 15
a816 20
	    else		/* this is the first of a series of element set names */
	      { size_t newScratchSize = (size_t)(strlen(ptr) + strlen(query->ElementSetNames[i + 1]) + 2);
		scratch = s_strdup(ptr); /* the database name */
		ptr = query->ElementSetNames[++i]; /* the element set name */
		scratch = (char*)s_realloc(scratch,newScratchSize);
		s_strncat(scratch,ES_DELIMITER_1,2,newScratchSize);
		s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize);
	      }
	  }
        else
	  { char* esPtr = query->ElementSetNames[++i]; /* the element set name */
	    size_t newScratchSize = (size_t)(strlen(scratch) + strlen(ptr) + strlen(esPtr) + 3);
	    scratch = (char*)s_realloc(scratch,newScratchSize);
	    s_strncat(scratch,ES_DELIMITER_2,2,newScratchSize);
	    s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize);
	    s_strncat(scratch,ES_DELIMITER_1,2,newScratchSize);
	    s_strncat(scratch,esPtr,strlen(esPtr) + 1,newScratchSize);
	  }
	  }
	buf = writeString(scratch,DT_ElementSetNames,buf,len);
d818 2
a819 2
      }
  buf = writeAny(query->ReferenceID,DT_ReferenceID,buf,len);
d821 4
a824 4
  /* go back and write the header-length-indicator */
  RELEASE_HEADER_SPACE(len);
  size = buf - buffer - HEADER_LEN;
  writeBinaryInteger(size,HEADER_LEN,buffer,len);
d826 2
a827 2
  if (query->Query != NULL)
    buf = writeSearchInfo(query,buf,len);
d829 1
a829 1
  return(buf);
d834 8
a841 10
SearchResponseAPDU*
makeSearchResponseAPDU(
long result,
long count,
long recordsReturned,
long nextPos,
long resultStatus,
long presentStatus,
any* refID,
void* records)
d843 13
a855 11
  SearchResponseAPDU* query = (SearchResponseAPDU*)s_malloc((size_t)sizeof(SearchResponseAPDU));
  query->PDUType = searchResponseAPDU;
  query->SearchStatus = result;
  query->ResultCount = count;
  query->NumberOfRecordsReturned = recordsReturned;
  query->NextResultSetPosition = nextPos;
  query->ResultSetStatus = resultStatus;
  query->PresentStatus = presentStatus;
  query->ReferenceID = duplicateAny(refID);
  query->DatabaseDiagnosticRecords = records;
  return(query);
d860 1
a860 2
void
freeSearchResponseAPDU(SearchResponseAPDU* queryResponse)
d862 2
a863 2
  freeAny(queryResponse->ReferenceID);
  s_free(queryResponse);
d868 2
a869 2
char*
writeSearchResponseAPDU(SearchResponseAPDU* queryResponse, char* buffer, long* len)
d871 2
a872 2
  char* buf = buffer + HEADER_LEN; /* leave room for the header-length-indicator */
  long size;
d874 1
a874 1
  RESERVE_SPACE_FOR_HEADER(len);
d876 31
a906 8
  buf = writePDUType(queryResponse->PDUType,buf,len);
  buf = writeBinaryInteger(queryResponse->SearchStatus,(size_t)1,buf,len);
  buf = writeBinaryInteger(queryResponse->ResultCount,(size_t)3,buf,len);
  buf = writeBinaryInteger(queryResponse->NumberOfRecordsReturned,(size_t)3,buf,len);
  buf = writeBinaryInteger(queryResponse->NextResultSetPosition,(size_t)3,buf,len);
  buf = writeNum(queryResponse->ResultSetStatus,DT_ResultSetStatus,buf,len);
  buf = writeNum(queryResponse->PresentStatus,DT_PresentStatus,buf,len);
  buf = writeAny(queryResponse->ReferenceID,DT_ReferenceID,buf,len);
d908 4
a911 4
  /* go back and write the header-length-indicator */
  RELEASE_HEADER_SPACE(len);
  size = buf - buffer - HEADER_LEN;
  writeBinaryInteger(size,HEADER_LEN,buffer,len);
d913 2
a914 2
  if (queryResponse->DatabaseDiagnosticRecords != NULL)
    buf = writeSearchResponseInfo(queryResponse,buf,len);
d916 1
a916 1
  return(buf);
d921 1
a921 2
char*
readSearchResponseAPDU(SearchResponseAPDU** queryResponse, char* buffer)
d923 7
a929 7
  char* buf = buffer;
  long size;
  pdu_type pduType;
  long result,count,recordsReturned,nextPos;
  long resultStatus,presentStatus;
  any *refID = NULL;
  void* userInfo = NULL;
d931 7
a937 7
  /* read required part */
  buf = readBinaryInteger(&size,HEADER_LEN,buf);
  buf = readPDUType(&pduType,buf);
  buf = readBinaryInteger(&result,(size_t)1,buf);
  buf = readBinaryInteger(&count,(size_t)3,buf);
  buf = readBinaryInteger(&recordsReturned,(size_t)3,buf);
  buf = readBinaryInteger(&nextPos,(size_t)3,buf);
d939 2
a940 2
  resultStatus = presentStatus = UNUSED;
  refID = NULL;
d942 7
a948 6
  /* read optional part */
  while (buf < (buffer + size + HEADER_LEN))
    { data_tag tag = peekTag(buf);
      switch (tag)
	{ case DT_ResultSetStatus:
	    buf = readNum(&resultStatus,buf);
d950 2
a951 2
	  case DT_PresentStatus:
	    buf = readNum(&presentStatus,buf);
d953 2
a954 2
	  case DT_ReferenceID:
	    buf = readAny(&refID,buf);
d956 1
a956 1
	  default:
d960 1
a960 1
	  }
d963 15
a977 2
  buf = readSearchResponseInfo(&userInfo,buf);
  if (buf == NULL)
a978 5
  RETURN_ON_NULL(buf);

  /* construct the search object */
  *queryResponse = makeSearchResponseAPDU(result,count,recordsReturned,nextPos,
					  (long)resultStatus,(long)presentStatus,refID,userInfo);
d980 1
a980 3
  freeAny(refID);

  return(buf);
a982 1

d984 3
a986 3
**	Routines originally from ZUtil.c -- FM
**
**----------------------------------------------------------------------*/
d988 11
a998 11
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   3.30.90  Harry Morris - Changed any->bits to any->bytes
   4.11.90  HWM - fixed include file names, changed
		- writeCompressedIntegerWithPadding() to
		  writeCompressedIntWithPadding()
		- generalized conditional includes (see c-dialect.h)
   3.7.91   Jonny Goldman.  Replaced "short" in makeBitMap with "int" line 632.
*/
d1000 1
a1000 1
char* readErrorPosition = NULL; /* pos where buf stoped making sense */
d1018 1
a1018 2
diagnosticRecord*
makeDiag(boolean surrogate, char* code, char* addInfo)
d1020 2
a1021 2
  diagnosticRecord* diag =
    (diagnosticRecord*)s_malloc((size_t)sizeof(diagnosticRecord));
d1023 3
a1025 3
  diag->SURROGATE = surrogate;
  memcpy(diag->DIAG,code,DIAGNOSTIC_CODE_SIZE);
  diag->ADDINFO = s_strdup(addInfo);
d1027 1
a1027 1
  return(diag);
d1032 1
a1032 2
void
freeDiag(diagnosticRecord* diag)
d1034 5
a1038 5
  if (diag != NULL) {
    if (diag->ADDINFO != NULL)
	s_free(diag->ADDINFO);
    s_free(diag);
  }
d1045 1
a1045 2
char*
writeDiag(diagnosticRecord* diag, char* buffer, long* len)
d1050 2
a1051 2
  char* buf = buffer;
  long  length;
d1053 2
a1054 2
  if (diag == NULL)		/* handle unspecified optional args */
    return(buf);
d1056 2
a1057 2
  buf = writeTag(DT_DatabaseDiagnosticRecords,buf,len);
  CHECK_FOR_SPACE_LEFT(0,len);
d1059 3
a1061 3
  length = 3;
  if (diag->ADDINFO != NULL)
    length += strlen(diag->ADDINFO);
d1063 4
a1066 3
  if (length >= 0xFFFF )	/* make sure the length is reasonable */
    { length = 0xFFFF - 1;
      diag->ADDINFO[0xFFFF - 3 - 1] = '\0';
d1069 1
a1069 1
  buf = writeBinaryInteger(length,2,buf,len);
d1071 3
a1073 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = diag->DIAG[0];
  buf++;
d1075 3
a1077 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = diag->DIAG[1];
  buf++;
d1079 4
a1082 4
  if (length > 3)
    { CHECK_FOR_SPACE_LEFT(3,len);
      memcpy(buf,diag->ADDINFO,(size_t)length - 3);
      buf += length - 3;
d1085 3
a1087 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = diag->SURROGATE;
  buf++;
d1089 3
a1091 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = END_OF_RECORD;
  buf++;
d1093 1
a1093 1
  return(buf);
d1098 1
a1098 2
char*
readDiag(diagnosticRecord** diag, char* buffer)
d1100 4
a1103 5
  char* buf = buffer;
  diagnosticRecord* d
    = (diagnosticRecord*)s_malloc((size_t)sizeof(diagnosticRecord));
  data_tag tag;
  long len;
d1105 1
a1105 1
  buf = readTag(&tag,buf);
d1107 1
a1107 1
  buf = readBinaryInteger(&len,2,buf);
d1109 3
a1111 3
  d->DIAG[0] = buf[0];
  d->DIAG[1] = buf[1];
  d->DIAG[2] = '\0';
d1113 6
a1118 7
  if (len > 3)
    { d->ADDINFO = (char*)s_malloc((size_t)(len - 3 + 1));
      memcpy(d->ADDINFO,(char*)(buf + 2),(size_t)(len - 3));
      d->ADDINFO[len - 3] = '\0';
    }
  else
    d->ADDINFO = NULL;
d1120 1
a1120 1
  d->SURROGATE = buf[len - 1];
d1122 1
a1122 1
  *diag = d;
d1124 1
a1124 1
  return(buf + len + 1);
d1133 1
a1133 2
char*
writeCompressedInteger(unsigned long num, char* buf, long* len)
d1138 3
a1140 3
  char byte;
  unsigned long i;
  unsigned long size;
d1142 2
a1143 2
  size = writtenCompressedIntSize(num);
  CHECK_FOR_SPACE_LEFT(size,len);
d1145 6
a1150 6
  for (i = size - 1; i != 0; i--)
    { byte = num & dataMask;
      if (i != (size-1))	/* turn on continue bit */
	byte = (char)(byte | continueBit);
      buf[i] = byte;
      num = num >> dataBits;	/* don't and here */
d1153 1
a1153 1
  return(buf + size);
d1158 1
a1158 2
char*
readCompressedInteger(unsigned long *num, char* buf)
d1163 2
a1164 2
  long i = 0;
  unsigned char byte;
d1166 1
a1166 1
  *num = 0;
d1168 4
a1171 4
  do
    { byte = buf[i++];
      *num = *num << dataBits;
      *num += (byte & dataMask);
d1173 1
a1173 1
  while (byte & continueBit);
d1175 1
a1175 1
  return(buf + i);
d1180 1
a1180 1
#define pad	128 /* high bit is set */
d1182 4
a1185 6
char*
writeCompressedIntWithPadding(
unsigned long num,
unsigned long size,
char* buffer,
long* len)
d1191 3
a1193 3
  char* buf = buffer;
  unsigned long needed,padding;
  long i;
d1195 1
a1195 1
  CHECK_FOR_SPACE_LEFT(size,len);
d1197 3
a1199 3
  needed = writtenCompressedIntSize(num);
  padding = size - needed;
  i = padding - 1;
d1201 2
a1202 2
  for (i = padding - 1;i >= 0;i--)
    { buf[i] = pad;
d1205 1
a1205 1
  buf = writeCompressedInteger(num,buf + padding,len);
d1207 1
a1207 1
  return(buf);
d1212 1
a1212 2
unsigned long
writtenCompressedIntSize(unsigned long num)
d1217 8
a1224 8
  if (num < CompressedInt1Byte)
    return(1);
  else if (num < CompressedInt2Byte)
    return(2);
  else if (num < CompressedInt3Byte)
    return(3);
  else
    return(4);
d1229 1
a1229 2
char*
writeTag(data_tag tag, char* buf, long* len)
d1232 1
a1232 1
  return(writeCompressedInteger(tag,buf,len));
d1237 1
a1237 2
char*
readTag(data_tag* tag, char* buf)
d1240 1
a1240 1
  return(readCompressedInteger(tag,buf));
d1245 1
a1245 2
unsigned long
writtenTagSize(data_tag tag)
d1247 1
a1247 1
  return(writtenCompressedIntSize(tag));
d1252 1
a1252 2
data_tag
peekTag(char* buf)
d1255 4
a1258 3
  data_tag tag;
  readTag(&tag,buf);
  return(tag);
d1263 1
a1263 2
any*
makeAny(unsigned long size, char* data)
d1265 5
a1269 4
  any* a = (any*)s_malloc((size_t)sizeof(any));
  a->size = size;
  a->bytes = data;
  return(a);
d1274 1
a1274 2
void
freeAny(any* a)
d1279 4
a1282 4
  if (a != NULL)
    { if (a->bytes != NULL)
	s_free(a->bytes);
      s_free(a);
d1288 1
a1288 2
any*
duplicateAny(any* a)
d1290 1
a1290 1
  any* copy = NULL;
d1292 2
a1293 2
  if (a == NULL)
    return(NULL);
d1295 8
a1302 7
  copy = (any*)s_malloc((size_t)sizeof(any));
  copy->size = a->size;
  if (a->bytes == NULL)
    copy->bytes = NULL;
  else
    { copy->bytes = (char*)s_malloc((size_t)copy->size);
      memcpy(copy->bytes,a->bytes,(size_t)copy->size);
d1304 1
a1304 1
  return(copy);
d1309 1
a1309 2
char*
writeAny(any* a, data_tag tag, char* buffer, long* len)
d1312 1
a1312 1
  char* buf = buffer;
d1314 2
a1315 2
  if (a == NULL)		/* handle unspecified optional args */
    return(buf);
d1317 3
a1319 3
  /* write the tags */
  buf = writeTag(tag,buf,len);
  buf = writeCompressedInteger(a->size,buf,len);
d1321 3
a1323 3
  /* write the bytes */
  CHECK_FOR_SPACE_LEFT(a->size,len);
  memcpy(buf,a->bytes,(size_t)a->size);
d1325 1
a1325 1
  return(buf+a->size);
d1330 1
a1330 2

char *readAny(any** anAny, char* buffer)
d1333 3
a1335 3
  char *buf;
  any* a;
  data_tag tag;
d1337 1
d1339 1
d1341 1
a1341 1
a=(any*)s_malloc((size_t)sizeof(any));
d1343 1
a1343 1
  buf=buffer;
d1345 4
a1348 1
  buf = readTag(&tag,buf);
d1350 1
a1350 8
  buf = readCompressedInteger(&a->size,buf);

  /* now simply copy the bytes */
  a->bytes = (char*)s_malloc((size_t)a->size);
  memcpy(a->bytes,buf,(size_t)a->size);
  *anAny = a;

  return(buf+a->size);
d1355 1
a1355 2
unsigned long
writtenAnySize(data_tag tag, any* a)
d1357 1
a1357 1
  unsigned long size;
d1359 2
a1360 2
  if (a == NULL)
    return(0);
d1362 4
a1365 4
  size = writtenTagSize(tag);
  size += writtenCompressedIntSize(a->size);
  size += a->size;
  return(size);
d1370 1
a1370 2
any*
stringToAny(char* s)
d1372 1
a1372 1
  any* a = NULL;
d1374 2
a1375 2
  if (s == NULL)
    return(NULL);
d1377 6
a1382 5
  a = (any*)s_malloc((size_t)sizeof(any));
  a->size = strlen(s);
  a->bytes = (char*)s_malloc((size_t)a->size);
  memcpy(a->bytes,s,(size_t)a->size);
  return(a);
d1387 1
a1387 2
char*
anyToString(any* a)
d1389 1
a1389 1
  char* s = NULL;
d1391 2
a1392 2
  if (a == NULL)
    return(NULL);
d1394 4
a1397 4
  s = s_malloc((size_t)(a->size + 1));
  memcpy(s,a->bytes,(size_t)a->size);
  s[a->size] = '\0';
  return(s);
d1402 1
a1402 2
char*
writeString(char* s, data_tag tag, char* buffer, long* len)
d1409 12
a1420 10
  char* buf = buffer;
  any* data = NULL;
  if (s == NULL)
    return(buffer);		/* handle unused optional item before making an any */
  data = (any*)s_malloc((size_t)sizeof(any));
  data->size = strlen(s);
  data->bytes = s;		/* save a copy here by not using stringToAny() */
  buf = writeAny(data,tag,buf,len);
  s_free(data);			/* don't use freeAny() since it will free s too */
  return(buf);
d1425 1
a1425 2
char*
readString(char** s, char* buffer)
d1432 6
a1437 5
  any* data = NULL;
  char* buf = readAny(&data,buffer);
  *s = anyToString(data);
  freeAny(data);
  return(buf);
d1442 1
a1442 2
unsigned long
writtenStringSize(data_tag tag, char* s)
d1444 1
a1444 1
  unsigned long size;
d1446 2
a1447 2
  if (s == NULL)
   return(0);
d1449 4
a1452 4
  size = writtenTagSize(tag);
  size += writtenCompressedIntSize(size);
  size += strlen(s);
  return(size);
d1457 1
a1457 2
any*
longToAny(long num)
d1460 1
a1460 1
  char s[40];
d1462 1
a1462 1
  sprintf(s,"%ld",num);
d1464 1
a1464 1
  return(stringToAny(s));
d1469 1
a1469 2
long
anyToLong(any* a)
d1472 5
a1476 4
  long num;
  char* str = NULL;
  str = anyToString(a);
  sscanf(str,"%ld",&num);	/* could check the result and return
d1478 2
a1479 2
  s_free(str);
  return(num);
d1486 1
a1486 2
bit_map*
makeBitMap(unsigned long numBits, ...)
d1489 26
a1514 20
  va_list ap;
  unsigned long i,j;
  bit_map* bm = NULL;

  LYva_start(ap,numBits);

  bm = (bit_map*)s_malloc((size_t)sizeof(bit_map));
  bm->size = (unsigned long)(ceil((double)numBits / bitsPerByte));
  bm->bytes = (char*)s_malloc((size_t)bm->size);

  /* fill up the bits */
  for (i = 0; i < bm->size; i++) /* iterate over bytes */
    { char byte = 0;
      for (j = 0; j < bitsPerByte; j++) /* iterate over bits */
	{ if ((i * bitsPerByte + j) < numBits)
	    { boolean bit = false;
	      bit = (boolean)va_arg(ap,boolean);
	      if (bit)
	        { byte = byte | (1 << (bitsPerByte - j - 1));
	        }
d1516 2
a1517 2
	  }
      bm->bytes[i] = byte;
d1520 2
a1521 2
  va_end(ap);
  return(bm);
a1523 1

d1526 1
a1526 2
void
freeBitMap(bit_map* bm)
d1529 2
a1530 2
  s_free(bm->bytes);
  s_free(bm);
d1540 1
a1540 2
boolean
bitAtPos(unsigned long pos, bit_map* bm)
d1542 6
a1547 6
  if (pos > bm->size*bitsPerByte)
    return false;
  else
    return((bm->bytes[(pos / bitsPerByte)] &
	    (0x80>>(pos % bitsPerByte))) ?
	   true : false);
d1552 1
a1552 2
char*
writeBitMap(bit_map* bm, data_tag tag, char* buffer, long* len)
d1555 1
a1555 1
  return(writeAny((any*)bm,tag,buffer,len));
d1560 1
a1560 2
char*
readBitMap(bit_map** bm, char* buffer)
d1564 3
a1566 2
    c = readAny((any**)bm,buffer);
    return(c);
d1571 1
a1571 2
char*
writeByte(unsigned long byte, char* buf, long* len)
d1573 3
a1575 3
  CHECK_FOR_SPACE_LEFT(1,len);
  buf[0] = byte & 0xFF; /* we really only want the first byte */
  return(buf + 1);
d1580 1
a1580 2
char*
readByte(unsigned char* byte, char* buf)
d1582 2
a1583 2
  *byte = buf[0];
  return(buf + 1);
d1588 1
a1588 2
char*
writeBoolean(boolean flag, char* buf, long* len)
d1590 1
a1590 1
  return(writeByte(flag,buf,len));
d1595 1
a1595 2
char*
readBoolean(boolean* flag, char* buffer)
d1597 5
a1601 4
  unsigned char byte;
  char* buf = readByte(&byte,buffer);
  *flag = (byte == true) ? true : false;
  return(buf);
d1606 1
a1606 2
char*
writePDUType(pdu_type pduType, char* buf, long* len)
d1609 1
a1609 1
  return(writeBinaryInteger((long)pduType,(unsigned long)1,buf,len));
d1614 1
a1614 2
char*
readPDUType(pdu_type* pduType, char* buf)
d1617 1
a1617 1
  return(readBinaryInteger((long*)pduType,(unsigned long)1,buf));
d1622 1
a1622 2
pdu_type
peekPDUType(char* buf)
d1628 4
a1631 3
  pdu_type pdu;
  readPDUType(&pdu,buf + HEADER_LEN);
  return(pdu);
d1636 3
a1638 4
#define BINARY_INTEGER_BYTES	sizeof(long) /* the number of bytes used by
						a "binary integer" */
char*
writeBinaryInteger(long num, unsigned long size, char* buf, long* len)
d1642 2
a1643 2
  long i;
  char byte;
d1645 2
a1646 2
  if (size < 1 || size > BINARY_INTEGER_BYTES)
    return(NULL);		/* error */
d1648 1
a1648 1
  CHECK_FOR_SPACE_LEFT(size,len);
d1650 4
a1653 4
  for (i = size - 1; i >= 0; i--)
    { byte = (char)(num & 255);
      buf[i] = byte;
      num = num >> bitsPerByte; /* don't and here */
d1656 1
a1656 1
  return(buf + size);
d1661 1
a1661 2
char*
readBinaryInteger(long* num, unsigned long size, char* buf)
d1665 2
a1666 2
  unsigned long i;
  unsigned char byte;
d1668 3
a1670 3
  if (size < 1 || size > BINARY_INTEGER_BYTES)
    return(buf);		/* error */
  *num = 0;
d1672 4
a1675 4
  for (i = 0; i < size; i++)
    { byte = buf[i];
      *num = *num << bitsPerByte;
      *num += byte;
d1678 1
a1678 1
  return(buf + size);
d1683 1
a1683 2
unsigned long
writtenCompressedBinIntSize(long num)
d1689 10
a1698 10
  if (num < 0L)
    return(4);
  else if (num < 256L)		/* 2**8 */
    return(1);
  else if (num < 65536L)	/* 2**16 */
    return(2);
  else if (num < 16777216L)	/* 2**24 */
    return(3);
  else
    return(4);
d1703 1
a1703 2
char*
writeNum(long num, data_tag tag, char* buffer, long* len)
d1706 2
a1707 2
  char* buf = buffer;
  long size = writtenCompressedBinIntSize(num);
d1709 2
a1710 2
  if (num == UNUSED)
    return(buffer);
d1712 4
a1715 4
  buf = writeTag(tag,buf,len);
  buf = writeCompressedInteger(size,buf,len);
  buf = writeBinaryInteger(num,(unsigned long)size,buf,len);
  return(buf);
d1720 1
a1720 2
char*
readNum(long* num, char* buffer)
d1723 4
a1726 4
  char* buf = buffer;
  data_tag tag;
  unsigned long size;
  unsigned long val;
d1728 5
a1732 5
  buf = readTag(&tag,buf);
  buf = readCompressedInteger(&val,buf);
  size = (unsigned long)val;
  buf = readBinaryInteger(num,size,buf);
  return(buf);
d1737 1
a1737 2
unsigned long
writtenNumSize(data_tag tag, long num)
d1739 2
a1740 2
  long dataSize = writtenCompressedBinIntSize(num);
  long size;
d1742 3
a1744 3
  size = writtenTagSize(tag); /* space for the tag */
  size += writtenCompressedIntSize(dataSize); /* space for the size */
  size += dataSize; /* space for the data */
d1746 1
a1746 1
  return(size);
d1751 1
a1751 1
typedef void (voidfunc)(void *);
d1753 1
a1753 2
void
doList(void** list, voidfunc *func)
d1756 7
a1762 6
  register long i;
  register void* ptr = NULL;
  if (list == NULL)
    return;
  for (i = 0,ptr = list[i]; ptr != NULL; ptr = list[++i])
    (*func)(ptr);
d1767 1
a1767 2
char*
writeProtocolVersion(char* buf, long* len)
d1770 1
a1770 1
  static bit_map* version = NULL;
d1772 3
a1774 3
  if (version == NULL)
   { version = makeBitMap((unsigned long)1,true); /* version 1! */
   }
d1776 1
a1776 1
  return(writeBitMap(version,DT_ProtocolVersion,buf,len));
d1781 1
a1781 2
char*
defaultImplementationID(void)
d1783 3
a1785 2
  static char	ImplementationID[] = "TMC";
  return(ImplementationID);
d1790 1
a1790 2
char*
defaultImplementationName(void)
d1792 3
a1794 2
  static char ImplementationName[] = "Thinking Machines Corporation Z39.50";
  return(ImplementationName);
d1799 1
a1799 2
char*
defaultImplementationVersion(void)
d1801 3
a1803 2
  static char	ImplementationVersion[] = "2.0A";
  return(ImplementationVersion);
a1807 1

d1809 3
a1811 3
**	Routines originally from ZType1.c -- FM
**
**----------------------------------------------------------------------*/
d1813 6
a1818 6
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
*/
d1821 7
a1827 9
query_term*
makeAttributeTerm(
char* use,
char* relation,
char* position,
char* structure,
char* truncation,
char* completeness,
any* term)
d1829 1
a1829 1
  query_term* qt = (query_term*)s_malloc((size_t)sizeof(query_term));
d1831 1
a1831 1
  qt->TermType = TT_Attribute;
d1833 7
a1839 7
  /* copy in the attributes */
  strncpy(qt->Use,use,ATTRIBUTE_SIZE);
  strncpy(qt->Relation,relation,ATTRIBUTE_SIZE);
  strncpy(qt->Position,position,ATTRIBUTE_SIZE);
  strncpy(qt->Structure,structure,ATTRIBUTE_SIZE);
  strncpy(qt->Truncation,truncation,ATTRIBUTE_SIZE);
  strncpy(qt->Completeness,completeness,ATTRIBUTE_SIZE);
d1841 1
a1841 1
  qt->Term = duplicateAny(term);
d1843 1
a1843 1
  qt->ResultSetID = NULL;
d1845 1
a1845 1
  return(qt);
d1850 1
a1850 2
query_term*
makeResultSetTerm(any* resultSet)
d1852 1
a1852 1
  query_term* qt = (query_term*)s_malloc((size_t)sizeof(query_term));
d1854 1
a1854 1
  qt->TermType = TT_ResultSetID;
d1856 1
a1856 1
  qt->ResultSetID = duplicateAny(resultSet);
d1858 1
a1858 1
  qt->Term = NULL;
d1860 1
a1860 1
  return(qt);
d1865 1
a1865 2
query_term*
makeOperatorTerm(char* operatorCode)
d1867 1
a1867 1
  query_term* qt = (query_term*)s_malloc((size_t)sizeof(query_term));
d1869 1
a1869 1
  qt->TermType = TT_Operator;
d1871 1
a1871 1
  strncpy(qt->Operator,operatorCode,OPERATOR_SIZE);
d1873 2
a1874 2
  qt->Term = NULL;
  qt->ResultSetID = NULL;
d1876 1
a1876 1
  return(qt);
d1881 1
a1881 2
void
freeTerm(void* param)
d1883 4
a1886 3
  query_term* qt = (query_term*)param;
  switch (qt->TermType)
    { case TT_Attribute:
d1889 1
a1889 1
      case TT_ResultSetID:
d1892 1
a1892 1
      case TT_Operator:
d1895 1
a1895 1
      default:
d1899 2
a1900 2
      }
  s_free(qt);
d1908 1
a1908 2
char*
writeQueryTerm(query_term* qt, char* buffer, long* len)
d1910 2
a1911 2
  char* buf = buffer;
  char attributes[ATTRIBUTE_LIST_SIZE];
d1913 15
a1927 15
  switch (qt->TermType)
    { case TT_Attribute:
	strncpy(attributes,qt->Use,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Relation,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Position,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Structure,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Truncation,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,AT_DELIMITER,sizeof(AT_DELIMITER) + 1,ATTRIBUTE_LIST_SIZE);
	s_strncat(attributes,qt->Completeness,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE);
	buf = writeString(attributes,DT_AttributeList,buf,len);
	buf = writeAny(qt->Term,DT_Term,buf,len);
d1929 2
a1930 2
      case TT_ResultSetID:
	buf = writeAny(qt->ResultSetID,DT_ResultSetID,buf,len);
d1932 2
a1933 2
      case TT_Operator:
	buf = writeString(qt->Operator,DT_Operator,buf,len);
d1935 1
a1935 1
      default:
d1939 1
a1939 1
      }
d1941 1
a1941 1
  return(buf);
d1946 29
a1974 31
char*
readQueryTerm(query_term** qt, char* buffer)
{
  char* buf = buffer;
  char  *attributeList = NULL;
  char* operator = NULL;
  any*  term;
  char* use = NULL;
  char* relation = NULL;
  char* position = NULL;
  char* structure = NULL;
  char* truncation = NULL;
  char* completeness;
  any*	resultSetID = NULL;
  data_tag tag;


  tag = peekTag(buffer);

  switch(tag)
    { case DT_AttributeList:
	buf = readString(&attributeList,buf);
	buf = readAny(&term,buf);
	use = strtok(attributeList,AT_DELIMITER);
	relation = strtok(NULL,AT_DELIMITER);
	position = strtok(NULL,AT_DELIMITER);
	structure = strtok(NULL,AT_DELIMITER);
	truncation = strtok(NULL,AT_DELIMITER);
	completeness = strtok(NULL,AT_DELIMITER);
	*qt = makeAttributeTerm(use,relation,position,structure,
				truncation,completeness,term);
d1978 2
a1979 2
      case DT_ResultSetID:
	buf = readAny(&resultSetID,buf);
d1983 2
a1984 2
      case DT_Operator:
	buf = readString(&operator,buf);
d1988 1
a1988 1
      default:
d1991 1
a1991 1
      }
d1993 1
a1993 1
  return(buf);
d1998 1
a1998 1
static unsigned long getQueryTermSize PARAMS((query_term* qt));
d2000 1
a2000 2
static unsigned long
getQueryTermSize(query_term* qt)
d2003 10
a2012 9
  unsigned long size = 0;
  static char attributes[] = "11 22 33 44 55 66"; /* we just need this to
						     calculate its written
						     size */

  switch (qt->TermType)
    { case TT_Attribute:
	size = writtenStringSize(DT_AttributeList,attributes);
	size += writtenAnySize(DT_Term,qt->Term);
d2014 2
a2015 2
      case TT_ResultSetID:
	size = writtenAnySize(DT_ResultSetID,qt->ResultSetID);
d2017 2
a2018 2
      case TT_Operator:
	size = writtenStringSize(DT_Operator,qt->Operator);
d2020 1
a2020 1
      default:
d2024 1
a2024 1
      }
d2026 1
a2026 1
  return(size);
d2035 1
a2035 2
any*
writeQuery(query_term** terms)
d2037 7
a2043 7
  any* info = NULL;
  char* writePos = NULL;
  char* data = NULL;
  unsigned long size = 0;
  long remaining = 0;
  long i;
  query_term* qt = NULL;
d2045 2
a2046 2
  if (terms == NULL)
    return(NULL);
d2048 3
a2050 3
  /* calculate the size of write buffer */
  for (i = 0,qt = terms[i]; qt != NULL; qt = terms[++i])
    size += getQueryTermSize(qt);
d2052 1
a2052 1
  data = (char*)s_malloc((size_t)size);
d2054 5
a2058 5
  /* write the terms */
  writePos = data;
  remaining = size;
  for (i = 0,qt = terms[i]; qt != NULL; qt = terms[++i])
    writePos = writeQueryTerm(qt,writePos,&remaining);
d2060 1
a2060 1
  info = makeAny(size,data);
d2062 1
a2062 1
  return(info);
d2067 1
a2067 2
query_term**
readQuery(any *info)
d2069 5
a2073 5
  char* readPos = info->bytes;
  query_term** terms = NULL;
  query_term* qt = NULL;
  long numTerms = 0L;
  char tmp[100];
d2075 2
a2076 2
  sprintf(tmp,"readquery: bytes: %ld",info->size);
  log_write(tmp);
d2078 2
a2079 2
  while (readPos < info->bytes + info->size)
    { readPos = readQueryTerm(&qt,readPos);
d2081 7
a2087 2
      if (terms == NULL)
	{ terms = (query_term**)s_malloc((size_t)(sizeof(query_term*)*2));
d2089 4
a2092 9
      else
	{ terms =
	    (query_term**)s_realloc((char*)terms,
				    (size_t)(sizeof(query_term*)*(numTerms+2)));
	  }
      if (qt == NULL)
	log_write("qt = null");
      terms[numTerms++] = qt;
      terms[numTerms] = NULL;
d2095 1
a2095 1
  return(terms);
a2099 1

d2101 3
a2103 3
**	Routines originally from panic.c -- FM
**
**----------------------------------------------------------------------*/
d2105 5
a2109 5
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   Morris@@think.com
*/
d2118 1
a2118 1
static void exitAction PARAMS((long error));
d2120 1
a2120 2
static void
exitAction(long error GCC_UNUSED)
d2122 4
a2125 4
  long i;
  for (i = 0; i < 100000; i++)
    ;
  exit(0);
d2132 1
a2132 2
void
panic(char *format, ...)
d2134 1
a2134 1
  va_list ap;			/* the variable arguments */
d2136 5
a2140 5
  fprintf(stderr,PANIC_HEADER);
  LYva_start(ap, format);	/* init ap */
  vfprintf(stderr,format,ap);	/* print the contents */
  va_end(ap);			/* free ap */
  fflush(stderr);
d2142 1
a2142 1
  exitAction(0);
a2146 1

d2148 3
a2150 3
**	Routines originally from cutil.c -- FM
**
**----------------------------------------------------------------------*/
d2152 6
a2157 6
   No guarantees or restrictions.  See the readme file for the full standard
   disclaimer.

   3.26.90	Harry Morris, morris@@think.com
   4.11.90  HWM - generalized conditional includes (see c-dialect.h)
*/
d2161 1
a2161 2
void
fs_checkPtr(void* ptr)
d2164 2
a2165 2
  if (ptr == NULL)
    panic("checkPtr found a NULL pointer");
d2170 1
a2170 2
void*
fs_malloc(size_t size)
d2173 1
a2173 1
  register void* ptr = NULL;
d2175 2
a2176 2
  ptr = (void*)calloc((size_t)size,(size_t)1);
  s_checkPtr(ptr);
d2178 1
a2178 1
  return(ptr);
d2183 1
a2183 2
void*
fs_realloc(void* ptr, size_t size)
d2189 1
a2189 1
  register void* nptr = NULL;
d2191 2
a2192 2
  if (ptr == NULL)		/* this is really a malloc */
    return(s_malloc(size));
d2194 2
a2195 2
  nptr = (void*)realloc(ptr,size);
  s_checkPtr(ptr);
d2197 1
a2197 1
  return(nptr);
d2202 1
a2202 2
void
fs_free(void* ptr)
d2205 1
a2205 1
  if (ptr != NULL)		/* some non-ansi compilers/os's cant handle freeing null */
d2207 2
a2208 2
      free(ptr);
      ptr = NULL;
d2214 1
a2214 2
char*
s_strdup(char* s)
d2221 5
a2225 2
  unsigned long len;
  char* copy = NULL;
d2227 2
a2228 2
  if (s == NULL)		/* saftey check to postpone stupid errors */
    return(NULL);
d2230 2
a2231 4
  len = strlen(s);		/* length of string - terminator */
  copy = (char*)s_malloc((size_t)(sizeof(char)*(len + 1)));
  strncpy(copy,s,len + 1);
  return(copy);
d2236 1
a2236 2
char*
fs_strncat(char* dst, char* src, size_t maxToAdd, size_t maxTotal)
d2242 2
a2243 2
  size_t dstSize = strlen(dst);
  size_t srcSize = strlen(src);
d2245 11
a2255 10
  if (dstSize + srcSize < maxTotal) /* use regular old strncat */
    return(strncat(dst,src,maxToAdd));
  else
    { size_t truncateTo = maxTotal - dstSize - 1;
      char   saveChar = src[truncateTo];
      char*  result = NULL;
      src[truncateTo] = '\0';
      result = strncat(dst,src,maxToAdd);
      src[truncateTo] = saveChar;
      return(result);
d2263 4
a2266 3
  unsigned char ch = long_ch & 0xFF; /* just want one byte */
  /* when ansi is the way of the world, this can be tolower */
  return (((ch >= 'A') && (ch <= 'Z')) ? (ch + 'a' -'A') : ch);
d2271 7
a2277 6
  long i = 0;
  while(word[i] != '\0'){
    word[i] = char_downcase((unsigned long)word[i]);
    i++;
  }
  return(word);
d2281 1
a2281 1

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d699 3
a701 3
#define DB_DELIMITER 	"\037" 	/* hex 1F occurs between each database name */
#define ES_DELIMITER_1 	"\037" 	/* separates database name from element name */
#define ES_DELIMITER_2 	"\036" 	/* hex 1E separates <db,es> groups from one another */
d914 3
a916 3
   				- writeCompressedIntegerWithPadding() to
                  writeCompressedIntWithPadding()
                - generalized conditional includes (see c-dialect.h)
d1910 1
a1910 1
  any* 	term;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d43 1
a43 1
#undef MAXINT	/* we don't need it here, and tcp.h may conflict */
d223 1
a223 1
   		  (int)( request_length +HEADER_LENGTH)) )
d653 3
a655 3
  if (databases != NULL)
    { for (i = 0, ptr = databases[i]; ptr != NULL; ptr = databases[++i])
	{ if (query->DatabaseNames == NULL)
d662 2
a663 2
	  }
      }
d666 3
a668 3
  if (elements != NULL)
    { for (i = 0, ptr = elements[i]; ptr != NULL; ptr = elements[++i])
	{ if (query->ElementSetNames == NULL)
d720 3
a722 3
  if (query->DatabaseNames != NULL)
    { for (i = 0,scratch = NULL, ptr = query->DatabaseNames[i]; ptr != NULL; ptr = query->DatabaseNames[++i])
	{ if (scratch == NULL)
d730 1
a730 1
	  }
d736 4
a739 4
  if (query->ElementSetNames != NULL)
    { for (i = 0,scratch = NULL, ptr = query->ElementSetNames[i]; ptr != NULL; ptr = query->ElementSetNames[++i])
	{ if (scratch == NULL)
	    { if (query->ElementSetNames[i+1] == NULL) /* there is a single element set name */
d752 1
a752 1
	      }
d956 2
a957 2
  if (diag != NULL)
    { if (diag->ADDINFO != NULL)
d959 2
a960 2
	s_free(diag);
      }
d2035 1
a2035 1
char tmp[100];
d2037 2
a2038 2
sprintf(tmp,"readquery: bytes: %ld",info->size);
log_write(tmp);
d2051 1
a2051 1
if(qt==NULL)
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
/* 
d23 1
a23 1
 * 
d35 1
a35 1
 *   
d38 6
a43 8
#include "HTUtils.h"
#include "tcp.h"
#include "HTVMS_WaisUI.h"
#include "HTVMS_WaisProt.h"
#include "HTTCP.h"
/*#include <stdio> included by HTUtils.h -- FM */
#include <string.h>
#include <ctype.h>
a44 1
#include <stdarg.h>
d46 2
a47 2
#include "LYexit.h"
#include "LYLeaks.h"
d50 1
a50 2
log_write(s)
char *s;
d58 1
a58 1
   if it overflows, then NULL is returned 
d61 7
a67 12
generate_search_apdu(buff,
		     buff_len,
		     seed_words,
		     database_name,
		     docobjs,
		     maxDocsRetrieved)
char* buff;     /* buffer to hold the apdu */
long *buff_len;    /* length of the buffer changed to reflect new data written */
char *seed_words;    /* string of the seed words */
char *database_name;
DocObj** docobjs;
long maxDocsRetrieved;
d89 1
a89 1
  search3 = makeSearchAPDU(30, 
d94 1
a94 1
                           database_names, /* database name */   
d114 9
a122 16
generate_retrieval_apdu(buff,
			buff_len,
			docID,
			chunk_type,
			start,
			end,
			type,
			database_name)
char *buff;
long *buff_len;    /* length of the buffer changed to reflect new data written */
any *docID;
long chunk_type;
long start;
long end;
char *type;
char *database_name;
d146 1
a146 1
  
d148 1
a148 1
  case CT_line: 
d157 2
a158 2
  query = makeWAISTextQuery(DocObjs);   
  search = makeSearchAPDU( 10, 16, 15, 
d161 1
a161 1
			  database_names, /* database name */   
d179 1
a179 4
long read_from_stream(d,buf,nbytes)
int d;				/* this is the stream */
char *buf;
long nbytes;
d198 1
a198 1
    return(- totalRead);	/* bad news */    
d206 7
a212 11
long 
transport_message(connection,
		  request_message,
		  request_length,
		  response_message,
		  response_buffer_length)
int connection;
char *request_message;
long request_length;
char *response_message;
long response_buffer_length;
d218 3
a220 3
  
  /* Write out message. Read back header. Figure out response length. */
  
d252 1
a252 1
      printf("WAIS header: '%s' length_array: '%s'\n", 
d261 1
a261 1
	rv = read_from_stream(connection, 
d272 1
a272 1
  rv = read_from_stream(connection, 
d284 1
a284 1
/* returns the number of bytes writen.  0 if an error */
d286 7
a292 11
interpret_message(request_message,request_length,
		  response_message,
		  response_buffer_length,
		  connection,
		  verbose)
char *request_message;
long request_length; /* length of the buffer */
char *response_message;
long response_buffer_length;
int connection;
boolean verbose;
d304 1
a304 1
    twais_dsply_rsp_apdu(request_message + HEADER_LENGTH, 
d334 1
a334 3
char *delete_seeker_codes(string,length)
char *string;
long *length;
d352 1
a352 1
  
d372 1
a372 2
char *trim_junk(headline)
char *headline;
d375 1
a375 1
  long i;
d403 2
a404 2
   disclaimer.	
  
d412 1
a412 1
	
d416 1
a416 1
	
d419 16
a434 29
InitResponseAPDU* 
makeInitResponseAPDU(result,
		     search,
		     present,
		     deleteIt,
		     accessControl,
		     resourceControl,
		     prefSize,
		     maxMsgSize,
		     auth,
		     id,
		     name,
		     version,
		     refID,
		     userInfo)
boolean result;
boolean search;
boolean present;
boolean deleteIt;
boolean accessControl;
boolean resourceControl;
long prefSize;
long maxMsgSize;
char* auth;
char* id;
char* name;
char* version;
any* refID;
void* userInfo;
d436 1
a436 1
{ 
d454 1
a454 1
  
d460 2
a461 3
void 
freeInitResponseAPDU(init)
InitResponseAPDU* init;
d474 2
a475 5
char* 
writeInitResponseAPDU(init,buffer,len)
InitResponseAPDU* init;
char* buffer;
long* len;
d477 1
a477 1
{ 
d483 1
a483 1
  
d487 1
a487 1
  
d501 1
a501 1
  
d504 1
a504 1
  size = buf - buffer - HEADER_LEN; 
d508 2
a509 2
    buf = writeInitResponseInfo(init,buf,len);   
    
d515 2
a516 4
char* 
readInitResponseAPDU(init,buffer)
InitResponseAPDU** init;
char* buffer;
d522 1
a522 1
  long size; 
d529 1
a529 1
  
d532 1
a532 1
  
d534 1
a534 1
  buf = readBinaryInteger(&size,HEADER_LEN,buf); 
d537 1
a537 1
  buf = readBitMap(&versionBM,buf); 
d541 1
a541 1
  
d548 1
a548 1
  
d550 1
a550 1
  while (buf < (buffer + size + HEADER_LEN)) 
d592 1
a592 1
  
d597 1
a597 1
			 	 			        	
d605 1
a605 1
  
d611 2
a612 5
InitResponseAPDU* 
replyToInitAPDU(init,result,userInfo)
InitAPDU* init;
boolean result;
void* userInfo;
d614 1
a614 1
   the init info 
d630 12
a641 21
SearchAPDU* 
makeSearchAPDU(small,
	       large,
	       medium,
	       replace,
	       name,
	       databases,
	       type,
	       elements,
	       refID,
	       queryInfo)
long small;
long large;
long medium;
boolean replace;
char* name;
char** databases;
char* type;
char** elements;
any* refID;
void* queryInfo;
d652 1
a652 1
  query->DatabaseNames = NULL; 
d665 1
a665 1
  query->ElementSetNames = NULL; 
d684 2
a685 3
void 
freeSearchAPDU(query)
SearchAPDU* query;
d703 3
a705 6
char* 
writeSearchAPDU(query,buffer,len)
SearchAPDU* query;
char* buffer;
long* len;
{ 
d712 1
a712 1
  
d750 1
a750 1
		s_strncat(scratch,ptr,strlen(ptr) + 1,newScratchSize); 
d760 1
a760 1
	    s_strncat(scratch,esPtr,strlen(esPtr) + 1,newScratchSize); 
d765 1
a765 1
      }						
d767 1
a767 1
    
d770 1
a770 1
  size = buf - buffer - HEADER_LEN; 
d774 2
a775 2
    buf = writeSearchInfo(query,buf,len);    
    
d781 10
a790 11
SearchResponseAPDU* 
makeSearchResponseAPDU(result,count,recordsReturned,nextPos,resultStatus,
		       presentStatus,refID,records)
long result;
long count;
long recordsReturned;
long nextPos;
long resultStatus;
long presentStatus;
any* refID;
void* records;
d802 1
a802 1
  return(query);  
d807 2
a808 3
void 
freeSearchResponseAPDU(queryResponse)
SearchResponseAPDU* queryResponse;
d816 2
a817 5
char* 
writeSearchResponseAPDU(queryResponse,buffer,len)
SearchResponseAPDU* queryResponse;
char* buffer;
long* len;
d823 1
a823 1
  
d832 1
a832 1
    
d835 1
a835 1
  size = buf - buffer - HEADER_LEN; 
d839 2
a840 2
    buf = writeSearchResponseInfo(queryResponse,buf,len);    
    
d846 2
a847 4
char* 
readSearchResponseAPDU(queryResponse,buffer)
SearchResponseAPDU** queryResponse;
char* buffer;
d856 1
a856 1
  
d858 1
a858 1
  buf = readBinaryInteger(&size,HEADER_LEN,buf); 
d864 1
a864 1
  
d869 1
a869 1
  while (buf < (buffer + size + HEADER_LEN)) 
d887 1
a887 1
  
d892 1
a892 1
  
d898 1
a898 1
  
d909 2
a910 2
   disclaimer.	
  
d913 1
a913 1
   4.11.90  HWM - fixed include file names, changed 
d923 1
a923 1
/* A note on error handling 
d926 1
a926 1
   level functions which call these functions).  There is no 
d928 2
a929 2
   buffer.  Such cases should be very rare and usually will be 
   caught by the calling functions. (note - it is unlikely that 
d932 1
a932 1
   bad read in an array function (eg. readAny) to attempt to read a 
d938 2
a939 5
diagnosticRecord* 
makeDiag(surrogate,code,addInfo)
boolean surrogate;
char* code;
char* addInfo;
d941 1
a941 1
  diagnosticRecord* diag = 
d943 1
a943 1
  
d946 1
a946 1
  diag->ADDINFO = s_strdup(addInfo); 
d953 3
a955 4
void 
freeDiag(diag)
diagnosticRecord* diag;
{ 
d967 2
a968 5
char* 
writeDiag(diag,buffer,len)
diagnosticRecord* diag;
char* buffer;
long* len;
d975 1
a975 1
  
d981 2
a982 2
  
  length = 3; 
d985 1
a985 1
    
d990 1
a990 1
   
d994 1
a994 1
  buf[0] = diag->DIAG[0]; 
d996 1
a996 1
  
d1000 1
a1000 1
  
d1006 1
a1006 1
   
d1010 1
a1010 1
  
d1020 2
a1021 4
char* 
readDiag(diag,buffer)
diagnosticRecord** diag;
char* buffer;
d1024 1
a1024 1
  diagnosticRecord* d 
d1028 1
a1028 1
  
d1030 1
a1030 1
  
d1032 1
a1032 1
  
d1036 1
a1036 1
    
d1044 1
a1044 1
    
d1046 1
a1046 1
  
d1059 1
a1059 4
writeCompressedInteger(num,buf,len)
unsigned long num;
char* buf;
long* len;
d1061 1
a1061 1
   this might be sped up 
d1065 1
a1065 1
  long i;
d1067 1
a1067 1
  
d1070 2
a1071 2
  
  for (i = size - 1; i >= 0; i--)
d1078 1
a1078 1
   
d1080 1
a1080 1
} 
d1085 1
a1085 3
readCompressedInteger(num,buf)
unsigned long *num;
char* buf;
d1087 1
a1087 1
   this might be sped up 
d1094 2
a1095 2
  
  do 
d1103 1
a1103 1
} 
d1110 5
a1114 5
writeCompressedIntWithPadding(num,size,buffer,len)
unsigned long num;
unsigned long size;
char* buffer;
long* len;
d1116 1
a1116 1
   sure that size bytes are used.  This can be read correctly by 
d1123 1
a1123 1
    
d1125 1
a1125 1
  
d1133 1
a1133 1
  
d1135 1
a1135 1
  
d1137 1
a1137 1
} 
d1142 1
a1142 2
writtenCompressedIntSize(num)
unsigned long num;
d1147 1
a1147 1
  if (num < CompressedInt1Byte) 
d1149 1
a1149 1
  else if (num < CompressedInt2Byte) 
d1154 1
a1154 1
    return(4);    
d1160 1
a1160 4
writeTag(tag,buf,len)
data_tag tag;
char* buf;
long* len;
d1162 1
a1162 1
{ 
d1164 1
a1164 1
} 
d1169 1
a1169 3
readTag(tag,buf)
data_tag* tag;
char* buf;
d1171 1
a1171 1
{ 
d1173 1
a1173 1
} 
d1177 3
a1179 4
unsigned long 
writtenTagSize(tag)
data_tag tag;
{ 
d1186 1
a1186 2
peekTag(buf)
char* buf;
d1192 1
a1192 1
} 
d1196 2
a1197 4
any* 
makeAny(size,data)
unsigned long size;
char* data;
d1208 3
a1210 4
freeAny(a)
any* a;
/* destroy an any and its associated data. Assumes a->bytes was
   allocated using the s_malloc family of libraries 
d1222 2
a1223 3
any* 
duplicateAny(a)
any* a;
d1243 2
a1244 6
char* 
writeAny(a,tag,buffer,len)
any* a;
data_tag tag;
char* buffer;
long* len;
d1251 1
a1251 1
  
d1266 1
a1266 3
char *readAny(anAny,buffer)
any** anAny;
char* buffer;
d1278 1
a1278 1
  
d1280 1
a1280 1
  
d1293 2
a1294 4
unsigned long 
writtenAnySize(tag,a)
data_tag tag;
any* a;
d1310 1
a1310 2
stringToAny(s)
char* s;
d1313 1
a1313 1
  
d1316 1
a1316 1
    
d1327 1
a1327 2
anyToString(a)
any* a;
d1330 1
a1330 1
  
d1333 1
a1333 1
    
d1342 3
a1344 7
char* 
writeString(s,tag,buffer,len)
char* s;
data_tag tag;
char* buffer;
long* len;
/* Write a C style string.  The terminating null is not written. 
d1346 1
a1346 1
   for the convienience of those wishing to pass C strings in 
d1354 1
a1354 1
  data = (any*)s_malloc((size_t)sizeof(any)); 
d1364 2
a1365 4
char* 
readString(s ,buffer)
char** s ;
char* buffer;
d1368 2
a1369 2
   for the convienience of those wishing to pass C strings in 
   the place of an any. 
d1381 2
a1382 4
unsigned long 
writtenStringSize(tag,s)
data_tag tag;
char* s;
d1397 2
a1398 3
any* 
longToAny(num)
long num;
d1404 1
a1404 1
  
d1411 1
a1411 2
anyToLong(a)
any* a;
d1422 1
a1422 1
 
d1432 1
a1432 1
  long i,j;
d1435 2
a1436 2
  va_start(ap,numBits);
  
d1438 1
a1438 1
  bm->size = (unsigned long)ceil((double)numBits / bitsPerByte); 
d1440 1
a1440 1
  
d1447 1
a1447 1
	      bit = (boolean)va_arg(ap,boolean); 
d1464 1
a1464 2
freeBitMap(bm)
bit_map* bm;
d1473 2
a1474 2
/* use this routine to interpret a bit map.  pos specifies the bit 
   number.  bit 0 is the Leftmost bit of the first byte.  
d1479 1
a1479 3
bitAtPos(pos,bm)
long pos;
bit_map* bm;
d1484 1
a1484 1
    return((bm->bytes[(pos / bitsPerByte)] & 
d1492 1
a1492 5
writeBitMap(bm,tag,buffer,len)
bit_map* bm;
data_tag tag;
char* buffer;
long* len;
d1494 1
a1494 1
{ 
d1501 1
a1501 3
readBitMap(bm,buffer)
bit_map** bm;
char* buffer;
d1504 3
a1506 7
	char *c;



c=readAny((any**)bm,buffer);

  return(c);
d1511 2
a1512 5
char* 
writeByte(byte,buf,len)
unsigned long byte;
char* buf;
long* len;
d1521 2
a1522 4
char* 
readByte(byte,buf)
unsigned char* byte;
char* buf;
d1530 2
a1531 5
char* 
writeBoolean(flag,buf,len)
boolean flag;
char* buf;
long* len;
d1538 2
a1539 4
char* 
readBoolean(flag,buffer)
boolean* flag;
char* buffer;
d1550 1
a1550 4
writePDUType(pduType,buf,len)
pdu_type pduType;
char* buf;
long* len;
d1554 1
a1554 1
} 
d1559 1
a1559 3
readPDUType(pduType,buf)
pdu_type* pduType;
char* buf;
d1563 1
a1563 1
} 
d1568 2
a1569 3
peekPDUType(buf)
char* buf;
/* read the next pdu without advancing the buffer, Note that this 
d1584 1
a1584 5
writeBinaryInteger(num,size,buf,len)
long num;
unsigned long size;
char* buf;
long* len;
d1608 1
a1608 4
readBinaryInteger(num,size,buf)
long* num;
unsigned long size;
char* buf;
d1612 1
a1612 1
  long i;
d1630 2
a1631 3
unsigned long 
writtenCompressedBinIntSize(num)
long num;
d1633 1
a1633 1
   currently limited to max of 4 bytes 
d1648 1
a1648 1
 
d1652 1
a1652 5
writeNum(num,tag,buffer,len)
long num;
data_tag tag;
char* buffer;
long* len;
d1657 1
a1657 1
  
d1660 1
a1660 1
    
d1662 2
a1663 2
  buf = writeCompressedInteger(size,buf,len); 
  buf = writeBinaryInteger(num,(unsigned long)size,buf,len); 
d1670 1
a1670 3
readNum(num,buffer)
long* num;
char* buffer;
d1677 1
a1677 1
  
d1687 2
a1688 4
unsigned long 
writtenNumSize(tag,num)
data_tag tag;
long num;
d1692 1
a1692 1
  
d1696 1
a1696 1
  
d1702 1
a1702 1
typedef void (voidfunc)();
d1705 1
a1705 3
doList(list,func)
void** list;
voidfunc *func;
d1718 2
a1719 4
char* 
writeProtocolVersion(buf,len)
char* buf;
long* len;
d1727 1
a1727 1
    
d1734 1
a1734 1
defaultImplementationID()
d1743 1
a1743 1
defaultImplementationName()
d1752 1
a1752 1
defaultImplementationVersion()
d1767 2
a1768 2
   disclaimer.	
  
d1775 8
a1782 14
makeAttributeTerm(use,
		  relation,
		  position,
		  structure,
		  truncation,
		  completeness,
		  term)
char* use;
char* relation;
char* position;
char* structure;
char* truncation;
char* completeness;
any* term;
d1806 2
a1807 3
makeResultSetTerm(resultSet)
any* resultSet;
{ 
d1815 1
a1815 1
  
d1821 2
a1822 3
query_term* 
makeOperatorTerm(operatorCode)
char* operatorCode;
d1838 2
a1839 3
void 
freeTerm(qt)
query_term* qt;
d1841 1
d1865 2
a1866 5
char* 
writeQueryTerm(qt,buffer,len)
query_term* qt;
char* buffer;
long* len;
d1873 1
a1873 1
	strncpy(attributes,qt->Use,ATTRIBUTE_LIST_SIZE); 
d1875 1
a1875 1
	s_strncat(attributes,qt->Relation,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE); 
d1877 1
a1877 1
	s_strncat(attributes,qt->Position,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE); 
d1879 1
a1879 1
	s_strncat(attributes,qt->Structure,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE); 
d1881 1
a1881 1
	s_strncat(attributes,qt->Truncation,ATTRIBUTE_SIZE,ATTRIBUTE_LIST_SIZE); 
d1904 2
a1905 4
char* 
readQueryTerm(qt,buffer)
query_term** qt;
char* buffer;
d1920 1
a1920 1
  
d1940 1
a1940 1
	*qt = makeResultSetTerm(resultSetID);	
d1952 1
a1952 1
  
d1958 1
a1958 1
static unsigned long getQueryTermSize _AP((query_term* qt));
d1961 1
a1961 2
getQueryTermSize(qt)
query_term* qt;
d1964 2
a1965 2
  unsigned long size;
  static char attributes[] = "11 22 33 44 55 66"; /* we just need this to 
d1991 1
a1991 1
/* A query is simply a null terminated list of query terms. For 
d1996 1
a1996 2
writeQuery(terms)
query_term** terms;
d2029 1
a2029 2
readQuery(info)
any *info;
d2047 1
a2047 1
	{ terms = 
d2078 1
a2078 1
 
d2081 1
a2081 1
static void exitAction _AP((long error));
d2084 1
a2084 2
exitAction(error)
long error;
d2102 1
a2102 1
  va_start(ap, format);		/* init ap */
d2106 1
a2106 1
  
d2117 1
a2117 1
/* Wide AREA INFORMATION SERVER SOFTWARE	
d2119 2
a2120 2
   disclaimer.  
  
a2124 3
#include <varargs.h>


d2128 1
a2128 2
fs_checkPtr(ptr)
void* ptr;
d2130 1
a2130 1
{ 
d2138 1
a2138 2
fs_malloc(size)
size_t size;
d2140 1
a2140 1
{ 
d2145 1
a2145 1
  
d2152 2
a2153 4
fs_realloc(ptr,size)
void* ptr;
size_t size;
/* does safety checks and optional accounting 
d2157 1
a2157 1
{ 
d2159 1
a2159 1
  
d2162 1
a2162 1
    
d2165 1
a2165 1
   
d2172 1
a2172 2
fs_free(ptr)
void* ptr;
d2185 1
a2185 2
s_strdup(s)
char* s;
d2188 1
a2188 1
   strdup(), except that it is safe.  If s == NULL or malloc fails, 
d2194 1
a2194 1
  
d2197 1
a2197 1
    
d2207 1
a2207 5
fs_strncat(dst,src,maxToAdd,maxTotal)
char* dst;
   char* src;
   size_t maxToAdd;
   size_t maxTotal;
d2209 1
a2209 1
/* like strncat, except the fourth argument limits the maximum total 
d2215 1
a2215 1
  
d2231 1
a2231 2
char char_downcase(long_ch)
unsigned long long_ch;
d2238 1
a2238 2
char *string_downcase(word)
char *word;
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
