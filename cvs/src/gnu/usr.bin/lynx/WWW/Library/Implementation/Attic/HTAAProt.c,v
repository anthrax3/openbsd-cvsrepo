head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.37;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.44;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAAProt.c,v 1.33 2013/11/28 11:11:05 tom Exp $
 *
 * MODULE							HTAAProt.c
 *		PROTECTION FILE PARSING MODULE
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
 *
 * HISTORY:
 *	20 Oct 93  AL	Now finds uid/gid for nobody/nogroup by name
 *			(doesn't use default 65534 right away).
 *			Also understands negative uids/gids.
 *	14 Nov 93  MD	Added VMS compatibility
 *
 * BUGS:
 *
 *
 */

#include <HTUtils.h>

#ifndef VMS
#ifndef NOUSERS
#include <pwd.h>		/* Unix password file routine: getpwnam()       */
#include <grp.h>		/* Unix group file routine: getgrnam()          */
#endif /* NOUSERS */
#endif /* not VMS */

#include <HTAAUtil.h>
#include <HTLex.h>		/* Lexical analysor     */
#include <HTAAProt.h>		/* Implemented here     */

#include <LYUtils.h>
#include <LYLeaks.h>

#define NOBODY    65534		/* -2 in 16-bit environment */
#define NONESUCH  65533		/* -3 in 16-bit environment */

/*
 * Protection setup caching
 */
typedef struct {
    char *prot_filename;
    HTAAProt *prot;
} HTAAProtCache;

static HTList *prot_cache = NULL;	/* Protection setup cache.      */
static HTAAProt *default_prot = NULL;	/* Default protection.          */
static HTAAProt *current_prot = NULL;	/* Current protection mode      */

					/* which is set up by callbacks */
					/* from the rule system when    */
					/* a "protect" rule is matched. */

#ifndef NOUSERS
/* static							isNumber()
 *		DOES A CHARACTER STRING REPRESENT A NUMBER
 */
static BOOL isNumber(const char *s)
{
    const char *cur = s;

    if (isEmpty(s))
	return NO;

    if (*cur == '-')
	cur++;			/* Allow initial minus sign in a number */

    while (*cur) {
	if (*cur < '0' || *cur > '9')
	    return NO;
	cur++;
    }
    return YES;
}

/* PUBLIC							HTAA_getUid()
 *		GET THE USER ID TO CHANGE THE PROCESS UID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setuid() system call.
 *		Default is 65534 (nobody).
 */
int HTAA_getUid(void)
{
    int uid;

    if (current_prot && current_prot->uid_name) {
	if (isNumber(current_prot->uid_name)) {
	    uid = atoi(current_prot->uid_name);
	    if ((*HTAA_UidToName(uid)) != '\0') {
		return uid;
	    }
	} else {		/* User name (not a number) */
	    if ((uid = HTAA_NameToUid(current_prot->uid_name)) != NONESUCH) {
		return uid;
	    }
	}
    }
    /*
     * Ok, then let's get uid for nobody.
     */
    if ((uid = HTAA_NameToUid("nobody")) != NONESUCH) {
	return uid;
    }
    /*
     * Ok, then use default.
     */
    return NOBODY;		/* nobody */
}

/* PUBLIC							HTAA_getGid()
 *		GET THE GROUP ID TO CHANGE THE PROCESS GID TO
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the uid number to give to setgid() system call.
 *		Default is 65534 (nogroup).
 */
int HTAA_getGid(void)
{
    int gid;

    if (current_prot && current_prot->gid_name) {
	if (isNumber(current_prot->gid_name)) {
	    gid = atoi(current_prot->gid_name);
	    if (*HTAA_GidToName(gid) != '\0') {
		return gid;
	    }
	} else {		/* Group name (not number) */
	    if ((gid = HTAA_NameToGid(current_prot->gid_name)) != NONESUCH) {
		return gid;
	    }
	}
    }
    /*
     * Ok, then let's get gid for nogroup.
     */
    if ((gid = HTAA_NameToGid("nogroup")) != NONESUCH) {
	return gid;
    }
    /*
     * Ok, then use default.
     */
    return NOBODY;		/* nogroup */
}
#endif /* !NOUSERS */

/* static							HTAA_setIds()
 *		SET UID AND GID (AS NAMES OR NUMBERS)
 *		TO HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination.
 *	ids		is a string like "james.www" or "1422.69" etc.
 *			giving uid and gid.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_setIds(HTAAProt *prot, const char *ids)
{
    if (ids) {
	char *local_copy = NULL;
	char *point;

	StrAllocCopy(local_copy, ids);
	point = StrChr(local_copy, '.');
	if (point) {
	    *(point++) = (char) 0;
	    StrAllocCopy(prot->gid_name, point);
	} else {
	    StrAllocCopy(prot->gid_name, "nogroup");
	}
	StrAllocCopy(prot->uid_name, local_copy);
	FREE(local_copy);
    } else {
	StrAllocCopy(prot->uid_name, "nobody");
	StrAllocCopy(prot->gid_name, "nogroup");
    }
}

/* static						HTAA_parseProtFile()
 *		PARSE A PROTECTION SETUP FILE AND
 *		PUT THE RESULT IN A HTAAProt STRUCTURE
 * ON ENTRY:
 *	prot		destination structure.
 *	fp		open protection file.
 *
 * ON EXIT:
 *	returns		nothing.
 */
static void HTAA_parseProtFile(HTAAProt *prot, FILE *fp)
{
    if (prot && fp) {
	LexItem lex_item;
	char *fieldname = NULL;

	while (LEX_EOF != (lex_item = lex(fp))) {

	    while (lex_item == LEX_REC_SEP)	/* Ignore empty lines */
		lex_item = lex(fp);

	    if (lex_item == LEX_EOF)	/* End of file */
		break;

	    if (lex_item == LEX_ALPH_STR) {	/* Valid setup record */

		StrAllocCopy(fieldname, HTlex_buffer);

		if (LEX_FIELD_SEP != (lex_item = lex(fp)))
		    unlex(lex_item);	/* If someone wants to use colon */
		/* after field name it's ok, but */
		/* not required. Here we read it. */

		if (0 == strncasecomp(fieldname, "Auth", 4)) {
		    lex_item = lex(fp);
		    while (lex_item == LEX_ALPH_STR) {
			HTAAScheme scheme = HTAAScheme_enum(HTlex_buffer);

			if (scheme != HTAA_UNKNOWN) {
			    if (!prot->valid_schemes)
				prot->valid_schemes = HTList_new();
			    HTList_addObject(prot->valid_schemes, (void *) scheme);
			    CTRACE((tfp, "%s %s `%s'\n",
				    "HTAA_parseProtFile: valid",
				    "authentication scheme:",
				    HTAAScheme_name(scheme)));
			} else {
			    CTRACE((tfp, "%s %s `%s'\n",
				    "HTAA_parseProtFile: unknown",
				    "authentication scheme:",
				    HTlex_buffer));
			}

			if (LEX_ITEM_SEP != (lex_item = lex(fp)))
			    break;
			/*
			 * Here lex_item == LEX_ITEM_SEP; after item separator
			 * it is ok to have one or more newlines (LEX_REC_SEP)
			 * and they are ignored (continuation line).
			 */
			do {
			    lex_item = lex(fp);
			} while (lex_item == LEX_REC_SEP);
		    }		/* while items in list */
		}
		/* if "Authenticate" */
		else if (0 == strncasecomp(fieldname, "mask", 4)) {
		    prot->mask_group = HTAA_parseGroupDef(fp);
		    lex_item = LEX_REC_SEP;	/*groupdef parser read this already */
		    if (TRACE) {
			if (prot->mask_group) {
			    fprintf(tfp,
				    "HTAA_parseProtFile: Mask group:\n");
			    HTAA_printGroupDef(prot->mask_group);
			} else
			    fprintf(tfp,
				    "HTAA_parseProtFile: Mask group syntax error\n");
		    }
		}
		/* if "Mask" */
		else {		/* Just a name-value pair, put it to assoclist */

		    if (LEX_ALPH_STR == (lex_item = lex(fp))) {
			if (!prot->values)
			    prot->values = HTAssocList_new();
			HTAssocList_add(prot->values, fieldname, HTlex_buffer);
			lex_item = lex(fp);	/* Read record separator */
			CTRACE((tfp, "%s `%s' bound to value `%s'\n",
				"HTAA_parseProtFile: Name",
				fieldname, HTlex_buffer));
		    }
		}		/* else name-value pair */

	    }
	    /* if valid field */
	    if (lex_item != LEX_EOF && lex_item != LEX_REC_SEP) {
		CTRACE((tfp, "%s %s %d (that line ignored)\n",
			"HTAA_parseProtFile: Syntax error",
			"in protection setup file at line",
			HTlex_line));
		do {
		    lex_item = lex(fp);
		} while (lex_item != LEX_EOF && lex_item != LEX_REC_SEP);
	    }			/* if syntax error */
	}			/* while not end-of-file */
	FREE(fieldname);
    }				/* if valid parameters */
}

/* static						HTAAProt_new()
 *		ALLOCATE A NEW HTAAProt STRUCTURE AND
 *		INITIALIZE IT FROM PROTECTION SETUP FILE
 * ON ENTRY:
 *	cur_docname	current filename after rule translations.
 *	prot_filename	protection setup file name.
 *			If NULL, not an error.
 *	ids		Uid and gid names or numbers,
 *			examples:
 *				james	( <=> james.nogroup)
 *				.www	( <=> nobody.www)
 *				james.www
 *				james.69
 *				1422.69
 *				1422.www
 *
 *			May be NULL, defaults to nobody.nogroup.
 *			Should be NULL, if prot_file is NULL.
 *
 * ON EXIT:
 *	returns		returns a new and initialized protection
 *			setup structure.
 *			If setup file is already read in (found
 *			in cache), only sets uid_name and gid
 *			fields, and returns that.
 */
static HTAAProt *HTAAProt_new(const char *cur_docname,
			      const char *prot_filename,
			      const char *ids)
{
    HTList *cur = prot_cache;
    HTAAProtCache *cache_item = NULL;
    HTAAProt *prot;
    FILE *fp;

    if (!prot_cache)
	prot_cache = HTList_new();

    while (NULL != (cache_item = (HTAAProtCache *) HTList_nextObject(cur))) {
	if (!strcmp(cache_item->prot_filename, prot_filename))
	    break;
    }
    if (cache_item) {
	prot = cache_item->prot;
	CTRACE((tfp, "%s `%s' already in cache\n",
		"HTAAProt_new: Protection file", prot_filename));
    } else {
	CTRACE((tfp, "HTAAProt_new: Loading protection file `%s'\n",
		prot_filename));

	if ((prot = typecalloc(HTAAProt)) == 0)
	      outofmem(__FILE__, "HTAAProt_new");

	assert(prot != NULL);

	prot->ctemplate = NULL;
	prot->filename = NULL;
	prot->uid_name = NULL;
	prot->gid_name = NULL;
	prot->valid_schemes = HTList_new();
	prot->mask_group = NULL;	/* Masking disabled by defaults */
	prot->values = HTAssocList_new();

	if (prot_filename && NULL != (fp = fopen(prot_filename, TXT_R))) {
	    HTAA_parseProtFile(prot, fp);
	    fclose(fp);
	    if ((cache_item = typecalloc(HTAAProtCache)) == 0)
		outofmem(__FILE__, "HTAAProt_new");

	    assert(cache_item != NULL);

	    cache_item->prot = prot;
	    cache_item->prot_filename = NULL;
	    StrAllocCopy(cache_item->prot_filename, prot_filename);
	    HTList_addObject(prot_cache, (void *) cache_item);
	} else {
	    CTRACE((tfp, "HTAAProt_new: %s `%s'\n",
		    "Unable to open protection setup file",
		    NONNULL(prot_filename)));
	}
    }

    if (cur_docname)
	StrAllocCopy(prot->filename, cur_docname);
    HTAA_setIds(prot, ids);

    return prot;
}

/* PUBLIC					HTAA_setDefaultProtection()
 *		SET THE DEFAULT PROTECTION MODE
 *		(called by rule system when a
 *		"defprot" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "defprot" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "defprot" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable default_prot.
 */
void HTAA_setDefaultProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
{
    default_prot = NULL;	/* Not free()'d because this is in cache */

    if (prot_filename) {
	default_prot = HTAAProt_new(cur_docname, prot_filename, ids);
    } else {
	CTRACE((tfp, "%s %s\n",
		"HTAA_setDefaultProtection: ERROR: Protection file",
		"not specified (obligatory for DefProt rule)!!\n"));
    }
}

/* PUBLIC					HTAA_setCurrentProtection()
 *		SET THE CURRENT PROTECTION MODE
 *		(called by rule system when a
 *		"protect" rule is matched)
 * ON ENTRY:
 *	cur_docname	is the current result of rule translations.
 *	prot_filename	is the protection setup file (second argument
 *			for "protect" rule, optional)
 *	ids		contains user and group names separated by
 *			a dot, corresponding to the uid
 *			gid under which the server should run,
 *			default is "nobody.nogroup" (third argument
 *			for "protect" rule, optional; can be given
 *			only if protection setup file is also given).
 *
 * ON EXIT:
 *	returns		nothing.
 *			Sets the module-wide variable current_prot.
 */
void HTAA_setCurrentProtection(const char *cur_docname,
			       const char *prot_filename,
			       const char *ids)
{
    current_prot = NULL;	/* Not free()'d because this is in cache */

    if (prot_filename) {
	current_prot = HTAAProt_new(cur_docname, prot_filename, ids);
    } else {
	if (default_prot) {
	    current_prot = default_prot;
	    HTAA_setIds(current_prot, ids);
	    CTRACE((tfp, "%s %s %s\n",
		    "HTAA_setCurrentProtection: Protection file",
		    "not specified for Protect rule",
		    "-- using default protection"));
	} else {
	    CTRACE((tfp, "%s %s %s\n",
		    "HTAA_setCurrentProtection: ERROR: Protection",
		    "file not specified for Protect rule, and",
		    "default protection is not set!!"));
	}
    }
}

/* PUBLIC					HTAA_getCurrentProtection()
 *		GET CURRENT PROTECTION SETUP STRUCTURE
 *		(this is set up by callbacks made from
 *		 the rule system when matching "protect"
 *		 (and "defprot") rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		protection setup of the HTTranslate()'d file.
 *		This must not be free()'d.
 */
HTAAProt *HTAA_getCurrentProtection(void)
{
    return current_prot;
}

/* PUBLIC					HTAA_getDefaultProtection()
 *		GET DEFAULT PROTECTION SETUP STRUCTURE
 *		AND SET IT TO CURRENT PROTECTION
 *		(this is set up by callbacks made from
 *		 the rule system when matching "defprot"
 *		 rules)
 * ON ENTRY:
 *	HTTranslate() must have been called before calling
 *	this function.
 *
 * ON EXIT:
 *	returns	a HTAAProt structure representing the
 *		default protection setup of the HTTranslate()'d
 *		file (if HTAA_getCurrentProtection() returned
 *		NULL, i.e., if there is no "protect" rule
 *		but ACL exists, and we need to know default
 *		protection settings).
 *		This must not be free()'d.
 * IMPORTANT:
 *	As a side-effect this tells the protection system that
 *	the file is in fact protected and sets the current
 *	protection mode to default.
 */
HTAAProt *HTAA_getDefaultProtection(void)
{
    if (!current_prot) {
	current_prot = default_prot;
	default_prot = NULL;
    }
    return current_prot;
}

/* SERVER INTERNAL					HTAA_clearProtections()
 *		CLEAR DOCUMENT PROTECTION MODE
 *		(ALSO DEFAULT PROTECTION)
 *		(called by the rule system)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	nothing.
 *		Frees the memory used by protection information.
 */
void HTAA_clearProtections(void)
{
    current_prot = NULL;	/* These are not freed because  */
    default_prot = NULL;	/* they are actually in cache.  */
}

typedef struct {
    char *name;
    int user;
} USER_DATA;

#ifndef NOUSERS
static HTList *known_grp = NULL;
static HTList *known_pwd = NULL;
static BOOL uidgid_cache_inited = NO;
#endif

#ifdef LY_FIND_LEAKS
static void clear_uidgid_cache(void)
{
#ifndef NOUSERS
    USER_DATA *data;

    if (known_grp) {
	while ((data = HTList_removeLastObject(known_grp)) != NULL) {
	    FREE(data->name);
	    FREE(data);
	}
	FREE(known_grp);
    }
    if (known_pwd) {
	while ((data = HTList_removeLastObject(known_pwd)) != NULL) {
	    FREE(data->name);
	    FREE(data);
	}
	FREE(known_pwd);
    }
#endif
}
#endif /* LY_FIND_LEAKS */

#ifndef NOUSERS
static void save_gid_info(const char *name, int user)
{
    USER_DATA *data = typecalloc(USER_DATA);

    if (!data)
	return;
    if (!known_grp) {
	known_grp = HTList_new();
	if (!uidgid_cache_inited) {
#ifdef LY_FIND_LEAKS
	    atexit(clear_uidgid_cache);
#endif
	    uidgid_cache_inited = YES;
	}
    }
    StrAllocCopy(data->name, name);
    data->user = user;
    HTList_addObject(known_grp, data);
}
#endif /* NOUSERS */

#ifndef NOUSERS
static void save_uid_info(const char *name, int user)
{
    USER_DATA *data = typecalloc(USER_DATA);

    if (!data)
	return;
    if (!known_pwd) {
	known_pwd = HTList_new();
	if (!uidgid_cache_inited) {
#ifdef LY_FIND_LEAKS
	    atexit(clear_uidgid_cache);
#endif
	    uidgid_cache_inited = YES;
	}
    }
    StrAllocCopy(data->name, name);
    data->user = user;
    HTList_addObject(known_pwd, data);
}
#endif /* !NOUSERS */

/* PUBLIC							HTAA_UidToName
 *		GET THE USER NAME
 * ON ENTRY:
 *      The user-id
 *
 * ON EXIT:
 *      returns the user name, or an empty string if not found.
 */
const char *HTAA_UidToName(int uid GCC_UNUSED)
{
#ifndef NOUSERS
    struct passwd *pw;
    HTList *me = known_pwd;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (uid == data->user)
	    return data->name;
    }

    if ((pw = getpwuid((uid_t) uid)) != 0
	&& pw->pw_name != 0) {
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
		"HTAA_UidToName: getpwuid",
		uid,
		pw->pw_name, (int) pw->pw_uid));
	save_uid_info(pw->pw_name, (int) pw->pw_uid);
	return pw->pw_name;
    }
#endif
    return "";
}

/* PUBLIC							HTAA_NameToUid
 *		GET THE USER ID
 * ON ENTRY:
 *      The user-name
 *
 * ON EXIT:
 *      returns the user id, or NONESUCH if not found.
 */
int HTAA_NameToUid(const char *name GCC_UNUSED)
{
#ifndef NOUSERS
    struct passwd *pw;
    HTList *me = known_pwd;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (!strcmp(name, data->name))
	    return data->user;
    }

    if ((pw = getpwnam(name)) != 0) {
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
		"HTAA_NameToUid: getpwnam",
		name,
		pw->pw_name, (int) pw->pw_uid));
	save_uid_info(pw->pw_name, (int) pw->pw_uid);
	return (int) pw->pw_uid;
    }
#endif
    return NONESUCH;
}

/* PUBLIC							HTAA_GidToName
 *		GET THE GROUP NAME
 * ON ENTRY:
 *      The group-id
 *
 * ON EXIT:
 *      returns the group name, or an empty string if not found.
 */
const char *HTAA_GidToName(int gid GCC_UNUSED)
{
#ifndef NOUSERS
    struct group *gr;
    HTList *me = known_grp;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (gid == data->user)
	    return data->name;
    }

    if ((gr = getgrgid((gid_t) gid)) != 0
	&& gr->gr_name != 0) {
	CTRACE((tfp, "%s(%d) returned (%s:%d:...)\n",
		"HTAA_GidToName: getgrgid",
		gid,
		gr->gr_name, (int) gr->gr_gid));
	save_gid_info(gr->gr_name, (int) gr->gr_gid);
	return gr->gr_name;
    }
#endif
    return "";
}

/* PUBLIC							HTAA_NameToGid
 *		GET THE GROUP ID
 * ON ENTRY:
 *      The group-name
 *
 * ON EXIT:
 *      returns the group id, or NONESUCH if not found.
 */
int HTAA_NameToGid(const char *name GCC_UNUSED)
{
#ifndef NOUSERS
    struct group *gr;
    HTList *me = known_grp;

    while (HTList_nextObject(me)) {
	USER_DATA *data = (USER_DATA *) (me->object);

	if (!strcmp(name, data->name))
	    return data->user;
    }

    if ((gr = getgrnam(name)) != 0) {
	CTRACE((tfp, "%s(%s) returned (%s:%d:...)\n",
		"HTAA_NameToGid: getgrnam",
		name,
		gr->gr_name, (int) gr->gr_gid));
	save_gid_info(gr->gr_name, (int) gr->gr_gid);
	return (int) gr->gr_gid;
    }
#endif
    return NONESUCH;
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTAAProt.c,v 1.31 2009/03/10 00:27:20 tom Exp $
d172 1
a172 1
	point = strchr(local_copy, '.');
d349 2
d364 3
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 2

/* MODULE							HTAAProt.c
a77 38
#endif /* !NOUSERS */

#if defined (NOUSERS)
/* PUBLIC							HTAA_getUidName()
 *		GET THE USER ID NAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the user name
 *		Default is "" (nobody).
 */
const char *HTAA_getUidName(void)
{
    if (current_prot && current_prot->uid_name
	&& (0 != strcmp(current_prot->uid_name, "nobody")))
	return (current_prot->uid_name);
    else
	return ("");
}

/* PUBLIC							HTAA_getFileName
 *		GET THE FILENAME (VMS ONLY)
 * ON ENTRY:
 *	No arguments.
 *
 * ON EXIT:
 *	returns	the filename
 */
const char *HTAA_getFileName(void)
{
    if (current_prot && current_prot->filename)
	return (current_prot->filename);
    else
	return ("");
}

#else /* not VMS */
d152 1
a152 1
#endif /* not VMS */
d613 1
a613 1
const char *HTAA_UidToName(int uid)
d626 1
a626 1
    if ((pw = getpwuid(uid)) != 0
d647 1
a647 1
int HTAA_NameToUid(const char *name)
d680 1
a680 1
const char *HTAA_GidToName(int gid)
d693 1
a693 1
    if ((gr = getgrgid(gid)) != 0
d714 1
a714 1
int HTAA_NameToGid(const char *name)
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d3 16
a18 16
**		PROTECTION FILE PARSING MODULE
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**	MD	Mark Donszelmann    duns@@vxdeop.cern.ch
**
** HISTORY:
**	20 Oct 93  AL	Now finds uid/gid for nobody/nogroup by name
**			(doesn't use default 65534 right away).
**			Also understands negative uids/gids.
**	14 Nov 93  MD	Added VMS compatibility
**
** BUGS:
**
**
*/
d24 2
a25 2
#include <pwd.h>	/* Unix password file routine: getpwnam()	*/
#include <grp.h>	/* Unix group file routine: getgrnam()		*/
d30 2
a31 2
#include <HTLex.h>	/* Lexical analysor	*/
#include <HTAAProt.h>	/* Implemented here	*/
d36 2
a37 2
#define NOBODY    65534	/* -2 in 16-bit environment */
#define NONESUCH  65533	/* -3 in 16-bit environment */
d40 2
a41 2
** Protection setup caching
*/
d43 2
a44 2
    char *	prot_filename;
    HTAAProt *	prot;
d47 4
a50 3
PRIVATE HTList *  prot_cache	= NULL;	/* Protection setup cache.	*/
PRIVATE HTAAProt *default_prot	= NULL;	/* Default protection.		*/
PRIVATE HTAAProt *current_prot	= NULL;	/* Current protection mode	*/
d52 1
a52 1
					/* from the rule system when	*/
d56 4
a59 4
/* PRIVATE							isNumber()
**		DOES A CHARACTER STRING REPRESENT A NUMBER
*/
PRIVATE BOOL isNumber ARGS1(CONST char *, s)
d61 1
a61 1
    CONST char *cur = s;
d63 2
a64 1
    if (isEmpty(s)) return NO;
d67 1
a67 1
	cur++;		/* Allow initial minus sign in a number */
a77 1

d80 9
a88 9
**		GET THE USER ID NAME (VMS ONLY)
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the user name
**		Default is "" (nobody).
*/
PUBLIC char * HTAA_getUidName NOARGS
d91 2
a92 2
		  && (0 != strcmp(current_prot->uid_name,"nobody")) )
       return(current_prot->uid_name);
d94 1
a94 1
       return("");
d98 8
a105 8
**		GET THE FILENAME (VMS ONLY)
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the filename
*/
PUBLIC char * HTAA_getFileName NOARGS
d108 1
a108 1
       return(current_prot->filename);
d110 1
a110 1
       return("");
d116 9
a124 9
**		GET THE USER ID TO CHANGE THE PROCESS UID TO
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the uid number to give to setuid() system call.
**		Default is 65534 (nobody).
*/
PUBLIC int HTAA_getUid NOARGS
d128 1
a128 1
    if (current_prot  &&  current_prot->uid_name) {
d131 1
a131 1
	    if ((*HTAA_UidToName (uid)) != '\0') {
d134 2
a135 3
	}
	else {	/* User name (not a number) */
	    if ((uid = HTAA_NameToUid (current_prot->uid_name)) != NONESUCH) {
d141 3
a143 3
    ** Ok, then let's get uid for nobody.
    */
    if ((uid = HTAA_NameToUid ("nobody")) != NONESUCH) {
d147 3
a149 3
    ** Ok, then use default.
    */
    return NOBODY;	/* nobody */
a151 1

d153 9
a161 9
**		GET THE GROUP ID TO CHANGE THE PROCESS GID TO
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	the uid number to give to setgid() system call.
**		Default is 65534 (nogroup).
*/
PUBLIC int HTAA_getGid NOARGS
d165 1
a165 1
    if (current_prot  &&  current_prot->gid_name) {
d171 2
a172 3
	}
	else {	/* Group name (not number) */
	    if ((gid = HTAA_NameToGid (current_prot->gid_name)) != NONESUCH) {
d178 3
a180 3
    ** Ok, then let's get gid for nogroup.
    */
    if ((gid = HTAA_NameToGid ("nogroup")) != NONESUCH) {
d184 3
a186 3
    ** Ok, then use default.
    */
    return NOBODY;	/* nogroup */
d190 12
a201 14

/* PRIVATE							HTAA_setIds()
**		SET UID AND GID (AS NAMES OR NUMBERS)
**		TO HTAAProt STRUCTURE
** ON ENTRY:
**	prot		destination.
**	ids		is a string like "james.www" or "1422.69" etc.
**			giving uid and gid.
**
** ON EXIT:
**	returns		nothing.
*/
PRIVATE void HTAA_setIds ARGS2(HTAAProt *,	prot,
			       CONST char *,	ids)
d210 1
a210 1
	    *(point++) = (char)0;
d212 1
a212 2
	}
	else {
d217 1
a217 2
    }
    else {
d223 11
a233 13

/* PRIVATE						HTAA_parseProtFile()
**		PARSE A PROTECTION SETUP FILE AND
**		PUT THE RESULT IN A HTAAProt STRUCTURE
** ON ENTRY:
**	prot		destination structure.
**	fp		open protection file.
**
** ON EXIT:
**	returns		nothing.
*/
PRIVATE void HTAA_parseProtFile ARGS2(HTAAProt *, prot,
				      FILE *,	  fp)
d244 1
a244 1
	    if (lex_item == LEX_EOF)		/* End of file */
d253 2
a254 2
					/* after field name it's ok, but */
					/* not required. Here we read it.*/
d256 1
a256 1
		if (0==strncasecomp(fieldname, "Auth", 4)) {
d260 1
d264 1
a264 1
			    HTList_addObject(prot->valid_schemes,(void*)scheme);
d266 3
a268 3
					"HTAA_parseProtFile: valid",
					"authentication scheme:",
					HTAAScheme_name(scheme)));
d271 3
a273 3
					"HTAA_parseProtFile: unknown",
					"authentication scheme:",
					HTlex_buffer));
d279 4
a282 4
			** Here lex_item == LEX_ITEM_SEP; after item separator
			** it is ok to have one or more newlines (LEX_REC_SEP)
			** and they are ignored (continuation line).
			*/
d286 4
a289 4
		    } /* while items in list */
		} /* if "Authenticate" */

		else if (0==strncasecomp(fieldname, "mask", 4)) {
d291 1
a291 1
		    lex_item=LEX_REC_SEP; /*groupdef parser read this already*/
d297 3
a299 1
			} else fprintf(tfp, "HTAA_parseProtFile: Mask group syntax error\n");
d301 3
a303 3
		} /* if "Mask" */

		else {	/* Just a name-value pair, put it to assoclist */
d309 1
a309 1
			lex_item = lex(fp);  /* Read record separator */
d311 2
a312 2
				    "HTAA_parseProtFile: Name",
				    fieldname, HTlex_buffer));
d314 1
a314 1
		} /* else name-value pair */
d316 3
a318 3
	    } /* if valid field */

	    if (lex_item != LEX_EOF  &&  lex_item != LEX_REC_SEP) {
d320 3
a322 3
			    "HTAA_parseProtFile: Syntax error",
			    "in protection setup file at line",
			    HTlex_line));
d326 2
a327 2
	    } /* if syntax error */
	} /* while not end-of-file */
d329 1
a329 1
    } /* if valid parameters */
d332 29
a360 30

/* PRIVATE						HTAAProt_new()
**		ALLOCATE A NEW HTAAProt STRUCTURE AND
**		INITIALIZE IT FROM PROTECTION SETUP FILE
** ON ENTRY:
**	cur_docname	current filename after rule translations.
**	prot_filename	protection setup file name.
**			If NULL, not an error.
**	ids		Uid and gid names or numbers,
**			examples:
**				james	( <=> james.nogroup)
**				.www	( <=> nobody.www)
**				james.www
**				james.69
**				1422.69
**				1422.www
**
**			May be NULL, defaults to nobody.nogroup.
**			Should be NULL, if prot_file is NULL.
**
** ON EXIT:
**	returns		returns a new and initialized protection
**			setup structure.
**			If setup file is already read in (found
**			in cache), only sets uid_name and gid
**			fields, and returns that.
*/
PRIVATE HTAAProt *HTAAProt_new ARGS3(CONST char *,	cur_docname,
				     CONST char *,	prot_filename,
				     CONST char *,	ids)
d370 1
a370 1
    while (NULL != (cache_item = (HTAAProtCache*)HTList_nextObject(cur))) {
d377 1
a377 1
		    "HTAAProt_new: Protection file", prot_filename));
d380 1
a380 1
		    prot_filename));
d383 1
a383 1
	    outofmem(__FILE__, "HTAAProt_new");
d385 4
a388 4
	prot->template	= NULL;
	prot->filename	= NULL;
	prot->uid_name	= NULL;
	prot->gid_name	= NULL;
d390 2
a391 2
	prot->mask_group= NULL;		/* Masking disabled by defaults */
	prot->values	= HTAssocList_new();
d401 1
a401 1
	    HTList_addObject(prot_cache, (void*)cache_item);
d404 2
a405 2
			"Unable to open protection setup file",
			NONNULL(prot_filename)));
a415 1

d417 21
a437 21
**		SET THE DEFAULT PROTECTION MODE
**		(called by rule system when a
**		"defprot" rule is matched)
** ON ENTRY:
**	cur_docname	is the current result of rule translations.
**	prot_filename	is the protection setup file (second argument
**			for "defprot" rule, optional)
**	ids		contains user and group names separated by
**			a dot, corresponding to the uid
**			gid under which the server should run,
**			default is "nobody.nogroup" (third argument
**			for "defprot" rule, optional; can be given
**			only if protection setup file is also given).
**
** ON EXIT:
**	returns		nothing.
**			Sets the module-wide variable default_prot.
*/
PUBLIC void HTAA_setDefaultProtection ARGS3(CONST char *,	cur_docname,
					    CONST char *,	prot_filename,
					    CONST char *,	ids)
d445 2
a446 2
		    "HTAA_setDefaultProtection: ERROR: Protection file",
		    "not specified (obligatory for DefProt rule)!!\n"));
a449 1

d451 21
a471 21
**		SET THE CURRENT PROTECTION MODE
**		(called by rule system when a
**		"protect" rule is matched)
** ON ENTRY:
**	cur_docname	is the current result of rule translations.
**	prot_filename	is the protection setup file (second argument
**			for "protect" rule, optional)
**	ids		contains user and group names separated by
**			a dot, corresponding to the uid
**			gid under which the server should run,
**			default is "nobody.nogroup" (third argument
**			for "protect" rule, optional; can be given
**			only if protection setup file is also given).
**
** ON EXIT:
**	returns		nothing.
**			Sets the module-wide variable current_prot.
*/
PUBLIC void HTAA_setCurrentProtection ARGS3(CONST char *,	cur_docname,
					    CONST char *,	prot_filename,
					    CONST char *,	ids)
d482 3
a484 3
			"HTAA_setCurrentProtection: Protection file",
			"not specified for Protect rule",
			"-- using default protection"));
d487 3
a489 3
			"HTAA_setCurrentProtection: ERROR: Protection",
			"file not specified for Protect rule, and",
			"default protection is not set!!"));
a493 1

d495 14
a508 14
**		GET CURRENT PROTECTION SETUP STRUCTURE
**		(this is set up by callbacks made from
**		 the rule system when matching "protect"
**		 (and "defprot") rules)
** ON ENTRY:
**	HTTranslate() must have been called before calling
**	this function.
**
** ON EXIT:
**	returns	a HTAAProt structure representing the
**		protection setup of the HTTranslate()'d file.
**		This must not be free()'d.
*/
PUBLIC HTAAProt *HTAA_getCurrentProtection NOARGS
a512 1

d514 23
a536 23
**		GET DEFAULT PROTECTION SETUP STRUCTURE
**		AND SET IT TO CURRENT PROTECTION
**		(this is set up by callbacks made from
**		 the rule system when matching "defprot"
**		 rules)
** ON ENTRY:
**	HTTranslate() must have been called before calling
**	this function.
**
** ON EXIT:
**	returns	a HTAAProt structure representing the
**		default protection setup of the HTTranslate()'d
**		file (if HTAA_getCurrentProtection() returned
**		NULL, i.e., if there is no "protect" rule
**		but ACL exists, and we need to know default
**		protection settings).
**		This must not be free()'d.
** IMPORTANT:
**	As a side-effect this tells the protection system that
**	the file is in fact protected and sets the current
**	protection mode to default.
*/
PUBLIC HTAAProt *HTAA_getDefaultProtection NOARGS
a544 1

d546 11
a556 11
**		CLEAR DOCUMENT PROTECTION MODE
**		(ALSO DEFAULT PROTECTION)
**		(called by the rule system)
** ON ENTRY:
**	No arguments.
**
** ON EXIT:
**	returns	nothing.
**		Frees the memory used by protection information.
*/
PUBLIC void HTAA_clearProtections NOARGS
d558 2
a559 2
    current_prot = NULL;	/* These are not freed because	*/
    default_prot = NULL;	/* they are actually in cache.	*/
d563 3
a565 3
	char *name;
	int user;
	} USER_DATA;
d568 3
a570 3
PRIVATE HTList *known_grp = NULL;
PRIVATE HTList *known_pwd = NULL;
PRIVATE BOOL uidgid_cache_inited = NO;
d574 1
a574 1
PRIVATE void clear_uidgid_cache NOARGS
d578 1
d598 1
a598 1
PRIVATE void save_gid_info ARGS2(char *, name, int, user)
d601 1
d615 1
a615 1
    HTList_addObject (known_grp, data);
d620 1
a620 1
PRIVATE void save_uid_info ARGS2(char *, name, int, user)
d623 1
d637 1
a637 1
    HTList_addObject (known_pwd, data);
d642 8
a649 8
**		GET THE USER NAME
** ON ENTRY:
**      The user-id
**
** ON EXIT:
**      returns the user name, or an empty string if not found.
*/
PUBLIC char * HTAA_UidToName ARGS1(int, uid)
d656 2
a657 1
	USER_DATA *data = (USER_DATA *)(me->object);
d663 1
a663 1
     && pw->pw_name != 0) {
d665 3
a667 3
		    "HTAA_UidToName: getpwuid",
		    uid,
		    pw->pw_name, (int) pw->pw_uid));
d676 8
a683 8
**		GET THE USER ID
** ON ENTRY:
**      The user-name
**
** ON EXIT:
**      returns the user id, or NONESUCH if not found.
*/
PUBLIC int HTAA_NameToUid ARGS1(char *, name)
d690 2
a691 1
	USER_DATA *data = (USER_DATA *)(me->object);
d698 3
a700 3
		    "HTAA_NameToUid: getpwnam",
		    name,
		    pw->pw_name, (int) pw->pw_uid));
d709 8
a716 8
**		GET THE GROUP NAME
** ON ENTRY:
**      The group-id
**
** ON EXIT:
**      returns the group name, or an empty string if not found.
*/
PUBLIC char * HTAA_GidToName ARGS1(int, gid)
d723 2
a724 1
	USER_DATA *data = (USER_DATA *)(me->object);
d730 1
a730 1
     && gr->gr_name != 0) {
d732 3
a734 3
		    "HTAA_GidToName: getgrgid",
		    gid,
		    gr->gr_name, (int) gr->gr_gid));
d743 8
a750 8
**		GET THE GROUP ID
** ON ENTRY:
**      The group-name
**
** ON EXIT:
**      returns the group id, or NONESUCH if not found.
*/
PUBLIC int HTAA_NameToGid ARGS1(char *, name)
d757 2
a758 1
	USER_DATA *data = (USER_DATA *)(me->object);
d765 3
a767 3
		    "HTAA_NameToGid: getgrnam",
		    name,
		    gr->gr_name, (int) gr->gr_gid));
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d62 1
a62 1
    if (!s || !*s) return NO;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d33 1
d50 3
a52 4
                                        /* which is set up by callbacks	*/
                                        /* from the rule system when	*/
                                        /* a "protect" rule is matched.	*/

d54 1
d74 1
d90 1
a90 1
                  && (0 != strcmp(current_prot->uid_name,"nobody")) )
d261 2
a262 2
		                        /* after field name it's ok, but */
		                        /* not required. Here we read it.*/
d272 4
a275 4
			    CTRACE(tfp, "%s %s `%s'\n",
				        "HTAA_parseProtFile: valid",
				        "authentication scheme:",
				        HTAAScheme_name(scheme));
d277 1
a277 1
			    CTRACE(tfp, "%s %s `%s'\n",
d280 1
a280 1
					HTlex_buffer);
d315 1
a315 1
			CTRACE(tfp, "%s `%s' bound to value `%s'\n",
d317 1
a317 1
				    fieldname, HTlex_buffer);
d324 1
a324 1
		CTRACE(tfp, "%s %s %d (that line ignored)\n",
d327 1
a327 1
			    HTlex_line);
d382 2
a383 2
	CTRACE(tfp, "%s `%s' already in cache\n",
		    "HTAAProt_new: Protection file", prot_filename);
d385 2
a386 2
	CTRACE(tfp, "HTAAProt_new: Loading protection file `%s'\n",
		    prot_filename);
d388 1
a388 1
	if (!(prot = (HTAAProt*)calloc(1, sizeof(HTAAProt))))
d399 1
a399 1
	if (prot_filename && NULL != (fp = fopen(prot_filename, "r"))) {
d402 1
a402 2
	    if (!(cache_item =
	    		(HTAAProtCache*)calloc(1, sizeof(HTAAProtCache))))
d409 1
a409 1
	    CTRACE(tfp, "HTAAProt_new: %s `%s'\n",
d411 1
a411 1
			(prot_filename ? prot_filename : "(null)"));
d451 1
a451 1
	CTRACE(tfp, "%s %s\n",
d453 1
a453 1
		    "not specified (obligatory for DefProt rule)!!\n");
d489 4
a492 4
	    CTRACE(tfp, "%s %s %s\n",
		        "HTAA_setCurrentProtection: Protection file",
		        "not specified for Protect rule",
		        "-- using default protection");
d494 4
a497 4
	    CTRACE(tfp, "%s %s %s\n",
		        "HTAA_setCurrentProtection: ERROR: Protection",
		        "file not specified for Protect rule, and",
		        "default protection is not set!!");
d574 1
a574 1
    	char *name;
d576 1
a576 1
    	} USER_DATA;
d578 1
d582 1
d587 1
d603 1
d607 1
d610 1
a610 1
    USER_DATA *data = (USER_DATA *)calloc(1, sizeof(USER_DATA));
d626 1
d628 1
d631 1
a631 1
    USER_DATA *data = (USER_DATA *)calloc(1, sizeof(USER_DATA));
d647 1
d649 2
a650 2
/* PUBLIC                                                       HTAA_UidToName
**              GET THE USER NAME
d671 1
a671 1
	CTRACE(tfp, "%s(%d) returned (%s:%d:...)\n",
d674 1
a674 1
		    pw->pw_name, (int) pw->pw_uid);
d682 2
a683 2
/* PUBLIC                                                       HTAA_NameToUid
**              GET THE USER ID
d703 1
a703 1
	CTRACE(tfp, "%s(%s) returned (%s:%d:...)\n",
d706 1
a706 1
		    pw->pw_name, (int) pw->pw_uid);
d714 2
a715 2
/* PUBLIC                                                       HTAA_GidToName
**              GET THE GROUP NAME
d736 1
a736 1
	CTRACE(tfp, "%s(%d) returned (%s:%d:...)\n",
d739 1
a739 1
		    gr->gr_name, (int) gr->gr_gid);
d747 2
a748 2
/* PUBLIC                                                       HTAA_NameToGid
**              GET THE GROUP ID
d768 1
a768 1
	CTRACE(tfp, "%s(%s) returned (%s:%d:...)\n",
d771 1
a771 1
		    gr->gr_name, (int) gr->gr_gid);
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
#include "HTUtils.h"
a21 1
#include <string.h>
d29 3
a31 5
#include "HTAAUtil.h"
#include "HTAAFile.h"
#include "HTLex.h"	/* Lexical analysor	*/
#include "HTAssoc.h"	/* Association list	*/
#include "HTAAProt.h"	/* Implemented here	*/
d33 4
a36 1
#include "LYLeaks.h"
d75 1
a75 1
#if defined (VMS) || defined (NOUSERS)
d82 1
a82 1
**	returns	the user name 
d87 1
a87 1
    if (current_prot && current_prot->uid_name 
d123 1
a123 1
    struct passwd *pw = NULL;
d127 3
a129 8
	    if (NULL != (pw = getpwuid(atoi(current_prot->uid_name)))) {
		if (TRACE) fprintf(stderr, 
				   "%s(%s) returned (%s:%s:%d:%d:...)\n",
				   "HTAA_getUid: getpwuid",
				   current_prot->uid_name,
				   pw->pw_name, pw->pw_passwd,
				   pw->pw_uid, pw->pw_gid);
		return pw->pw_uid;	
d133 2
a134 7
	    if (NULL != (pw = getpwnam(current_prot->uid_name))) {
		if (TRACE) fprintf(stderr, "%s(\"%s\") %s (%s:%s:%d:%d:...)\n",
				   "HTAA_getUid: getpwnam",
				   current_prot->uid_name, "returned",
				   pw->pw_name, pw->pw_passwd,
				   pw->pw_uid, pw->pw_gid);
		return pw->pw_uid;
d141 2
a142 4
    if (NULL != (pw = getpwnam("nobody"))) {
	if (TRACE) fprintf(stderr, "HTAA_getUid: Uid for `nobody' is %d\n",
			   pw->pw_uid);
	return pw->pw_uid;
d147 1
a147 1
    return 65534;	/* nobody */
d161 3
a163 3
{    
    struct group *gr = NULL;
    
d166 3
a168 9
	    if (NULL != (gr = getgrgid(atoi(current_prot->gid_name)))) {
#ifndef __EMX__	/* no gr_passwd */
		if (TRACE) fprintf(stderr,
				   "%s(%s) returned (%s:%s:%d:...)\n",
				   "HTAA_getGid: getgrgid",
				   current_prot->gid_name,
				   gr->gr_name, gr->gr_passwd, gr->gr_gid);
#endif
		return gr->gr_gid;
d172 2
a173 9
	    if (NULL != (gr = getgrnam(current_prot->gid_name))) {
#ifndef __EMX__	/* no gr_passwd */
		if (TRACE) fprintf(stderr, 
				   "%s(\"%s\") returned (%s:%s:%d:...)\n",
				   "HTAA_getGid: getgrnam",
				   current_prot->gid_name,
				   gr->gr_name, gr->gr_passwd, gr->gr_gid);
#endif
		return gr->gr_gid;
d180 2
a181 4
    if (NULL != (gr = getgrnam("nogroup"))) {
	if (TRACE) fprintf(stderr, "HTAA_getGid: Gid for `nogroup' is %d\n",
			   gr->gr_gid);
	return gr->gr_gid;
d186 1
a186 1
    return 65534;	/* nogroup */
d254 1
a254 1
		
d256 1
a256 1
		
d270 9
a278 4
			    if (TRACE) fprintf(stderr, "%s %s `%s'\n",
					       "HTAA_parseProtFile: valid",
					       "authentication scheme:",
					       HTAAScheme_name(scheme));
d280 1
a280 5
			else if (TRACE) fprintf(stderr, "%s %s `%s'\n",
						"HTAA_parseProtFile: unknown",
						"authentication scheme:",
						HTlex_buffer);
			
d299 1
a299 1
			    fprintf(stderr,
d302 1
a302 2
			} else fprintf(stderr, "HTAA_parseProtFile: %s\n",
				       "Mask group syntax error");
d313 3
a315 4
			if (TRACE) fprintf(stderr, 
					   "%s `%s' bound to value `%s'\n",
					   "HTAA_parseProtFile: Name",
					   fieldname, HTlex_buffer);
d322 4
a325 4
		if (TRACE) fprintf(stderr, "%s %s %d (that line ignored)\n",
				   "HTAA_parseProtFile: Syntax error",
				   "in protection setup file at line",
				   HTlex_line);
d373 1
a373 1
    
d380 2
a381 2
	if (TRACE) fprintf(stderr, "%s `%s' already in cache\n",
			   "HTAAProt_new: Protection file", prot_filename);
d383 2
a384 3
	if (TRACE) fprintf(stderr,
			   "HTAAProt_new: Loading protection file `%s'\n",
			   prot_filename);
d407 4
a411 3
	else if (TRACE) fprintf(stderr, "HTAAProt_new: %s `%s'\n",
				"Unable to open protection setup file",
				(prot_filename ? prot_filename : "(null)"));
d450 3
a452 3
	if (TRACE) fprintf(stderr, "%s %s\n",
			   "HTAA_setDefaultProtection: ERROR: Protection file",
			   "not specified (obligatory for DefProt rule)!!\n");
d488 4
a491 4
	    if (TRACE) fprintf(stderr, "%s %s %s\n",
			       "HTAA_setCurrentProtection: Protection file",
			       "not specified for Protect rule",
			       "-- using default protection");
d493 4
a496 4
	    if (TRACE) fprintf(stderr, "%s %s %s\n",
			       "HTAA_setCurrentProtection: ERROR: Protection",
			       "file not specified for Protect rule, and",
			       "default protection is not set!!");
d536 1
a536 1
**		NULL, i.e. if there is no "protect" rule
d550 1
a550 1
    }	
d570 198
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
