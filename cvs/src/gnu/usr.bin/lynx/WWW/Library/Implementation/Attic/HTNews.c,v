head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.14
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.12
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.10
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.04.04.24.03;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.22.23.21.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.21.18.53.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.48;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTNews.c,v 1.70 2013/11/28 11:13:46 tom Exp $
 *
 *			NEWS ACCESS				HTNews.c
 *			===========
 *
 * History:
 *	26 Sep 90	Written TBL
 *	29 Nov 91	Downgraded to C, for portable implementation.
 */

#include <HTUtils.h>		/* Coding convention macros */

#ifndef DISABLE_NEWS

/* Implements:
*/
#include <HTNews.h>

#include <HTCJK.h>
#include <HTMIME.h>
#include <HTFont.h>
#include <HTFormat.h>
#include <HTTCP.h>
#include <LYUtils.h>
#include <LYStrings.h>

#define NEWS_PORT 119		/* See rfc977 */
#define SNEWS_PORT 563		/* See Lou Montulli */
#define APPEND			/* Use append methods */
int HTNewsChunkSize = 30;	/* Number of articles for quick display */
int HTNewsMaxChunk = 40;	/* Largest number of articles in one window */

#ifndef DEFAULT_NEWS_HOST
#define DEFAULT_NEWS_HOST "news"
#endif /* DEFAULT_NEWS_HOST */

#ifndef NEWS_SERVER_FILE
#define NEWS_SERVER_FILE "/usr/local/lib/rn/server"
#endif /* NEWS_SERVER_FILE */

#ifndef NEWS_AUTH_FILE
#define NEWS_AUTH_FILE ".newsauth"
#endif /* NEWS_AUTH_FILE */

#ifdef USE_SSL
static SSL *Handle = NULL;
static int channel_s = 1;

#define NEWS_NETWRITE(sock, buff, size) \
	(Handle ? SSL_write(Handle, buff, size) : NETWRITE(sock, buff, size))
#define NEWS_NETCLOSE(sock) \
	{ (void)NETCLOSE(sock); if (Handle) { SSL_free(Handle); Handle = NULL; } }
static int HTNewsGetCharacter(void);

#define NEXT_CHAR HTNewsGetCharacter()
#else
#define NEWS_NETWRITE  NETWRITE
#define NEWS_NETCLOSE  NETCLOSE
#define NEXT_CHAR HTGetCharacter()
#endif /* USE_SSL */

#include <HTML.h>
#include <HTAccess.h>
#include <HTParse.h>
#include <HTFormat.h>
#include <HTAlert.h>

#include <LYNews.h>
#include <LYGlobalDefs.h>
#include <LYLeaks.h>

#define SnipIn(d,fmt,len,s)      sprintf(d, fmt,      (int)sizeof(d)-len, s)
#define SnipIn2(d,fmt,tag,len,s) sprintf(d, fmt, tag, (int)sizeof(d)-len, s)

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
#define GROUP_NAME_LENGTH	256	/* Maximum length of group name */

/*
 *  Module-wide variables.
 */
char *HTNewsHost = NULL;	/* Default host */
static char *NewsHost = NULL;	/* Current host */
static char *NewsHREF = NULL;	/* Current HREF prefix */
static int s;			/* Socket for NewsHost */
static int HTCanPost = FALSE;	/* Current POST permission */
static char response_text[LINE_LENGTH + 1];	/* Last response */

static HTStructured *target;	/* The output sink */
static HTStructuredClass targetClass;	/* Copy of fn addresses */
static HTStream *rawtarget = NULL;	/* The output sink for rawtext */
static HTStreamClass rawtargetClass;	/* Copy of fn addresses */
static int diagnostic;		/* level: 0=none 2=source */
static BOOL rawtext = NO;	/* Flag: HEAD or -mime_headers */
static HTList *NNTP_AuthInfo = NULL;	/* AUTHINFO database */
static char *name = NULL;
static char *address = NULL;
static char *dbuf = NULL;	/* dynamic buffer for long messages etc. */

#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define RAW_PUTS(s) (*rawtargetClass.put_string)(rawtarget, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*targetClass.end_element)(target, e, 0)
#define FREE_TARGET if (rawtext) (*rawtargetClass._free)(rawtarget); \
			else (*targetClass._free)(target)
#define ABORT_TARGET if (rawtext) (*rawtargetClass._abort)(rawtarget, NULL); \
			else (*targetClass._abort)(target, NULL)

typedef struct _NNTPAuth {
    char *host;
    char *user;
    char *pass;
} NNTPAuth;

#ifdef LY_FIND_LEAKS
static void free_news_globals(void)
{
    if (s >= 0) {
	NEWS_NETCLOSE(s);
	s = -1;
    }
    FREE(HTNewsHost);
    FREE(NewsHost);
    FREE(NewsHREF);
    FREE(name);
    FREE(address);
    FREE(dbuf);
}
#endif /* LY_FIND_LEAKS */

static void free_NNTP_AuthInfo(void)
{
    HTList *cur = NNTP_AuthInfo;
    NNTPAuth *auth = NULL;

    if (!cur)
	return;

    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
	FREE(auth->host);
	FREE(auth->user);
	FREE(auth->pass);
	FREE(auth);
    }
    HTList_delete(NNTP_AuthInfo);
    NNTP_AuthInfo = NULL;
    return;
}

/*
 * Initialize the authentication list by loading the user's $HOME/.newsauth
 * file.  That file is part of tin's configuration and is used by a few other
 * programs.
 */
static void load_NNTP_AuthInfo(void)
{
    FILE *fp;
    char fname[LY_MAXPATH];
    char buffer[LINE_LENGTH + 1];

    LYAddPathToHome(fname, sizeof(fname), NEWS_AUTH_FILE);

    if ((fp = fopen(fname, "r")) != 0) {
	while (fgets(buffer, (int) sizeof(buffer), fp) != NULL) {
	    char the_host[LINE_LENGTH + 1];
	    char the_pass[LINE_LENGTH + 1];
	    char the_user[LINE_LENGTH + 1];

	    if (sscanf(buffer, "%s%s%s", the_host, the_pass, the_user) == 3
		&& strlen(the_host) != 0
		&& strlen(the_pass) != 0
		&& strlen(the_user) != 0) {
		NNTPAuth *auth = typecalloc(NNTPAuth);

		if (auth == NULL)
		    break;
		StrAllocCopy(auth->host, the_host);
		StrAllocCopy(auth->pass, the_pass);
		StrAllocCopy(auth->user, the_user);

		HTList_appendObject(NNTP_AuthInfo, auth);
	    }
	}
	fclose(fp);
    }
}

const char *HTGetNewsHost(void)
{
    return HTNewsHost;
}

void HTSetNewsHost(const char *value)
{
    StrAllocCopy(HTNewsHost, value);
}

/*	Initialisation for this module
 *	------------------------------
 *
 *	Except on the NeXT, we pick up the NewsHost name from
 *
 *	1.	Environment variable NNTPSERVER
 *	2.	File NEWS_SERVER_FILE
 *	3.	Compilation time macro DEFAULT_NEWS_HOST
 *	4.	Default to "news"
 *
 *	On the NeXT, we pick up the NewsHost name from, in order:
 *
 *	1.	WorldWideWeb default "NewsHost"
 *	2.	Global default "NewsHost"
 *	3.	News default "NewsHost"
 *	4.	Compilation time macro DEFAULT_NEWS_HOST
 *	5.	Default to "news"
 */
static BOOL initialized = NO;
static BOOL initialize(void)
{
#ifdef NeXTStep
    char *cp = NULL;
#endif

    /*
     * Get name of Host.
     */
#ifdef NeXTStep
    if ((cp = NXGetDefaultValue("WorldWideWeb", "NewsHost")) == 0) {
	if ((cp = NXGetDefaultValue("News", "NewsHost")) == 0) {
	    StrAllocCopy(HTNewsHost, DEFAULT_NEWS_HOST);
	}
    }
    if (cp) {
	StrAllocCopy(HTNewsHost, cp);
	cp = NULL;
    }
#else
    if (LYGetEnv("NNTPSERVER")) {
	StrAllocCopy(HTNewsHost, LYGetEnv("NNTPSERVER"));
	CTRACE((tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		HTNewsHost));
    } else {
	FILE *fp = fopen(NEWS_SERVER_FILE, TXT_R);

	if (fp) {
	    char server_name[MAXHOSTNAMELEN + 1];

	    if (fgets(server_name, (int) sizeof server_name, fp) != NULL) {
		char *p = StrChr(server_name, '\n');

		if (p != NULL)
		    *p = '\0';
		StrAllocCopy(HTNewsHost, server_name);
		CTRACE((tfp, "HTNews: File %s defines news host as `%s'\n",
			NEWS_SERVER_FILE, HTNewsHost));
	    }
	    fclose(fp);
	}
    }
    if (!HTNewsHost)
	StrAllocCopy(HTNewsHost, DEFAULT_NEWS_HOST);
#endif /* NeXTStep */

    s = -1;			/* Disconnected */
#ifdef LY_FIND_LEAKS
    atexit(free_news_globals);
#endif
    return YES;
}

/*	Send NNTP Command line to remote host & Check Response
 *	------------------------------------------------------
 *
 * On entry,
 *	command points to the command to be sent, including CRLF, or is null
 *		pointer if no command to be sent.
 * On exit,
 *	Negative status indicates transmission error, socket closed.
 *	Positive status is an NNTP status.
 */
static int response(char *command)
{
    int result;
    char *p = response_text;
    int ich;

    if (command) {
	int status;
	int length = (int) strlen(command);

	CTRACE((tfp, "NNTP command to be sent: %s", command));
#ifdef NOT_ASCII
	{
	    const char *p2;
	    char *q;
	    char ascii[LINE_LENGTH + 1];

	    for (p2 = command, q = ascii; *p2; p2++, q++) {
		*q = TOASCII(*p2);
	    }
	    status = NEWS_NETWRITE(s, ascii, length);
	}
#else
	status = (int) NEWS_NETWRITE(s, (char *) command, length);
#endif /* NOT_ASCII */
	if (status < 0) {
	    CTRACE((tfp, "HTNews: Unable to send command. Disconnecting.\n"));
	    NEWS_NETCLOSE(s);
	    s = -1;
	    return status;
	}			/* if bad status */
    }
    /* if command to be sent */
    for (;;) {
	ich = NEXT_CHAR;
	if (((*p++ = (char) ich) == LF) ||
	    (p == &response_text[LINE_LENGTH])) {
	    *--p = '\0';	/* Terminate the string */
	    CTRACE((tfp, "NNTP Response: %s\n", response_text));
	    sscanf(response_text, "%d", &result);
	    return result;
	}
	/* if end of line */
	if (ich == EOF) {
	    *(p - 1) = '\0';
	    if (interrupted_in_htgetcharacter) {
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
	    } else {
		CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n",
			s));
	    }
	    NEWS_NETCLOSE(s);	/* End of file, close socket */
	    s = -1;
	    if (interrupted_in_htgetcharacter) {
		interrupted_in_htgetcharacter = 0;
		return (HT_INTERRUPTED);
	    }
	    return ((int) EOF);	/* End of file on response */
	}
    }				/* Loop over characters */
}

/*	Case insensitive string comparisons
 *	-----------------------------------
 *
 * On entry,
 *	template must be already in upper case.
 *	unknown may be in upper or lower or mixed case to match.
 */
static BOOL match(const char *unknown, const char *ctemplate)
{
    const char *u = unknown;
    const char *t = ctemplate;

    for (; *u && *t && (TOUPPER(*u) == *t); u++, t++) ;		/* Find mismatch or end */
    return (BOOL) (*t == 0);	/* OK if end of template */
}

typedef enum {
    NNTPAUTH_ERROR = 0,		/* general failure */
    NNTPAUTH_OK = 281,		/* authenticated successfully */
    NNTPAUTH_CLOSE = 502	/* server probably closed connection */
} NNTPAuthResult;

/*
 *  This function handles nntp authentication. - FM
 */
static NNTPAuthResult HTHandleAuthInfo(char *host)
{
    HTList *cur = NULL;
    NNTPAuth *auth = NULL;
    char *UserName = NULL;
    char *PassWord = NULL;
    char *msg = NULL;
    char buffer[512];
    int status, tries;

    /*
     * Make sure we have a host.  - FM
     */
    if (isEmpty(host))
	return NNTPAUTH_ERROR;

    /*
     * Check for an existing authorization entry.  - FM
     */
    if (NNTP_AuthInfo == NULL) {
	NNTP_AuthInfo = HTList_new();
	load_NNTP_AuthInfo();
#ifdef LY_FIND_LEAKS
	atexit(free_NNTP_AuthInfo);
#endif
    }

    cur = NNTP_AuthInfo;
    while (NULL != (auth = (NNTPAuth *) HTList_nextObject(cur))) {
	if (!strcmp(auth->host, host)) {
	    UserName = auth->user;
	    PassWord = auth->pass;
	    break;
	}
    }

    /*
     * Handle the username.  - FM
     */
    buffer[sizeof(buffer) - 1] = '\0';
    tries = 3;

    while (tries) {
	if (UserName == NULL) {
	    HTSprintf0(&msg, gettext("Username for news host '%s':"), host);
	    UserName = HTPrompt(msg, NULL);
	    FREE(msg);
	    if (!(UserName && *UserName)) {
		FREE(UserName);
		return NNTPAUTH_ERROR;
	    }
	}
	sprintf(buffer, "AUTHINFO USER %.*s%c%c",
		(int) sizeof(buffer) - 17, UserName, CR, LF);
	if ((status = response(buffer)) < 0) {
	    if (status == HT_INTERRUPTED)
		_HTProgress(CONNECTION_INTERRUPTED);
	    else
		HTAlert(FAILED_CONNECTION_CLOSED);
	    if (auth) {
		if (auth->user != UserName) {
		    FREE(auth->user);
		    auth->user = UserName;
		}
	    } else {
		FREE(UserName);
	    }
	    return NNTPAUTH_CLOSE;
	}
	if (status == 281) {
	    /*
	     * Username is accepted and no password is required.  - FM
	     */
	    if (auth) {
		if (auth->user != UserName) {
		    FREE(auth->user);
		    auth->user = UserName;
		}
	    } else {
		/*
		 * Store the accepted username and no password.  - FM
		 */
		if ((auth = typecalloc(NNTPAuth)) != NULL) {
		    StrAllocCopy(auth->host, host);
		    auth->user = UserName;
		    HTList_appendObject(NNTP_AuthInfo, auth);
		}
	    }
	    return NNTPAUTH_OK;
	}
	if (status != 381) {
	    /*
	     * Not success, nor a request for the password, so it must be an
	     * error.  - FM
	     */
	    HTAlert(response_text);
	    tries--;
	    if ((tries > 0) && HTConfirm(gettext("Change username?"))) {
		if (!auth || auth->user != UserName) {
		    FREE(UserName);
		}
		if ((UserName = HTPrompt(gettext("Username:"), UserName))
		    != NULL &&
		    *UserName) {
		    continue;
		}
	    }
	    if (auth) {
		if (auth->user != UserName) {
		    FREE(auth->user);
		}
		FREE(auth->pass);
	    }
	    FREE(UserName);
	    return NNTPAUTH_ERROR;
	}
	break;
    }

    if (status == 381) {
	/*
	 * Handle the password.  - FM
	 */
	tries = 3;
	while (tries) {
	    if (PassWord == NULL) {
		HTSprintf0(&msg, gettext("Password for news host '%s':"), host);
		PassWord = HTPromptPassword(msg);
		FREE(msg);
		if (!(PassWord && *PassWord)) {
		    FREE(PassWord);
		    return NNTPAUTH_ERROR;
		}
	    }
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c",
		    (int) sizeof(buffer) - 17, PassWord, CR, LF);
	    if ((status = response(buffer)) < 0) {
		if (status == HT_INTERRUPTED) {
		    _HTProgress(CONNECTION_INTERRUPTED);
		} else {
		    HTAlert(FAILED_CONNECTION_CLOSED);
		}
		if (auth) {
		    if (auth->user != UserName) {
			FREE(auth->user);
			auth->user = UserName;
		    }
		    if (auth->pass != PassWord) {
			FREE(auth->pass);
			auth->pass = PassWord;
		    }
		} else {
		    FREE(UserName);
		    FREE(PassWord);
		}
		return NNTPAUTH_CLOSE;
	    }
	    if (status == 502) {
		/*
		 * That's what INN's nnrpd returns.  It closes the connection
		 * after this.  - kw
		 */
		HTAlert(response_text);
		if (auth) {
		    if (auth->user == UserName)
			UserName = NULL;
		    FREE(auth->user);
		    if (auth->pass == PassWord)
			PassWord = NULL;
		    FREE(auth->pass);
		}
		FREE(UserName);
		FREE(PassWord);
		return NNTPAUTH_CLOSE;
	    }
	    if (status == 281) {
		/*
		 * Password also is accepted, and everything has been stored. 
		 * - FM
		 */
		if (auth) {
		    if (auth->user != UserName) {
			FREE(auth->user);
			auth->user = UserName;
		    }
		    if (auth->pass != PassWord) {
			FREE(auth->pass);
			auth->pass = PassWord;
		    }
		} else {
		    if ((auth = typecalloc(NNTPAuth)) != NULL) {
			StrAllocCopy(auth->host, host);
			auth->user = UserName;
			auth->pass = PassWord;
			HTList_appendObject(NNTP_AuthInfo, auth);
		    }
		}
		return NNTPAUTH_OK;
	    }
	    /*
	     * Not success, so it must be an error.  - FM
	     */
	    HTAlert(response_text);
	    if (!auth || auth->pass != PassWord) {
		FREE(PassWord);
	    } else {
		PassWord = NULL;
	    }
	    tries--;
	    if ((tries > 0) && HTConfirm(gettext("Change password?"))) {
		continue;
	    }
	    if (auth) {
		if (auth->user == UserName)
		    UserName = NULL;
		FREE(auth->user);
		FREE(auth->pass);
	    }
	    FREE(UserName);
	    break;
	}
    }

    return NNTPAUTH_ERROR;
}

/*	Find Author's name in mail address
 *	----------------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "Tim Berners-Lee" if given any of
 *	" Tim Berners-Lee <tim@@online.cern.ch> "
 *  or	" tim@@online.cern.ch ( Tim Berners-Lee ) "
 */
static char *author_name(char *email)
{
    char *p, *e;

    StrAllocCopy(name, email);
    CTRACE((tfp, "Trying to find name in: %s\n", name));

    if ((p = strrchr(name, '(')) && (e = strrchr(name, ')'))) {
	if (e > p) {
	    *e = '\0';		/* Chop off everything after the ')'  */
	    return HTStrip(p + 1);	/* Remove leading and trailing spaces */
	}
    }

    if ((p = strrchr(name, '<')) && (e = strrchr(name, '>'))) {
	if (e++ > p) {
	    while ((*p++ = *e++) != 0)	/* Remove <...> */
		;
	    return HTStrip(name);	/* Remove leading and trailing spaces */
	}
    }

    return HTStrip(name);	/* Default to the whole thing */
}

/*	Find Author's mail address
 *	--------------------------
 *
 * On exit,
 *	Returns allocated string which cannot be freed by the
 *	calling function, and is reallocated on subsequent calls
 *	to this function.
 *
 * For example, returns "montulli@@spaced.out.galaxy.net" if given any of
 *	" Lou Montulli <montulli@@spaced.out.galaxy.net> "
 *  or	" montulli@@spaced.out.galaxy.net ( Lou "The Stud" Montulli ) "
 */
static char *author_address(char *email)
{
    char *p, *at, *e;

    StrAllocCopy(address, email);
    CTRACE((tfp, "Trying to find address in: %s\n", address));

    if ((p = strrchr(address, '<'))) {
	if ((e = strrchr(p, '>')) && (at = strrchr(p, '@@'))) {
	    if (at < e) {
		*e = '\0';	/* Remove > */
		return HTStrip(p + 1);	/* Remove leading and trailing spaces */
	    }
	}
    }

    if ((p = strrchr(address, '(')) &&
	(e = strrchr(address, ')')) && (at = StrChr(address, '@@'))) {
	if (e > p && at < e) {
	    *p = '\0';		/* Chop off everything after the ')'  */
	    return HTStrip(address);	/* Remove leading and trailing spaces */
	}
    }

    if ((at = strrchr(address, '@@')) && at > address) {
	p = (at - 1);
	e = (at + 1);
	while (p > address && !isspace(UCH(*p)))
	    p--;
	while (*e && !isspace(UCH(*e)))
	    e++;
	*e = 0;
	return HTStrip(p);
    }

    /*
     * Default to the first word.
     */
    p = address;
    while (isspace(UCH(*p)))
	p++;			/* find first non-space */
    e = p;
    while (!isspace(UCH(*e)) && *e != '\0')
	e++;			/* find next space or end */
    *e = '\0';			/* terminate space */

    return (p);
}

/*	Start anchor element
 *	--------------------
 */
static void start_anchor(const char *href)
{
    BOOL present[HTML_A_ATTRIBUTES];
    const char *value[HTML_A_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);
    value[HTML_A_HREF] = href;
    (*targetClass.start_element) (target, HTML_A, present, value, -1, 0);
}

/*	Start link element
 *	------------------
 */
static void start_link(const char *href, const char *rev)
{
    BOOL present[HTML_LINK_ATTRIBUTES];
    const char *value[HTML_LINK_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_LINK_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    value[HTML_LINK_HREF] = href;
    value[HTML_LINK_REV] = rev;
    (*targetClass.start_element) (target, HTML_LINK, present, value, -1, 0);
}

/*	Start list element
 *	------------------
 */
static void start_list(int seqnum)
{
    BOOL present[HTML_OL_ATTRIBUTES];
    const char *value[HTML_OL_ATTRIBUTES];
    char SeqNum[20];
    int i;

    for (i = 0; i < HTML_OL_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_OL_SEQNUM || i == HTML_OL_START);
    sprintf(SeqNum, "%d", seqnum);
    value[HTML_OL_SEQNUM] = SeqNum;
    value[HTML_OL_START] = SeqNum;
    (*targetClass.start_element) (target, HTML_OL, present, value, -1, 0);
}

/*	Paste in an Anchor
 *	------------------
 *
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to the text to be put into the file, 0 terminated.
 *	addr	points to the hypertext reference address,
 *		terminated by white space, comma, NULL or '>'
 */
static void write_anchor(const char *text, const char *addr)
{
    char href[LINE_LENGTH + 1];
    const char *p;
    char *q;

    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p != ','); p++) {
	;
    }
    if (strlen(NewsHREF) + (size_t) (p - addr) + 1 < sizeof(href)) {
	q = href;
	strcpy(q, NewsHREF);
	/* Make complete hypertext reference */
	StrNCat(q, addr, (size_t) (p - addr));
    } else {
	q = NULL;
	HTSprintf0(&q, "%s%.*s", NewsHREF, (int) (p - addr), addr);
    }

    start_anchor(q);
    PUTS(text);
    END(HTML_A);

    if (q != href)
	FREE(q);
}

/*	Write list of anchors
 *	---------------------
 *
 *	We take a pointer to a list of objects, and write out each,
 *	generating an anchor for each.
 *
 * On entry,
 *	HT	has a selection of zero length at the end.
 *	text	points to a comma or space separated list of addresses.
 * On exit,
 *	*text	is NOT any more chopped up into substrings.
 */
static void write_anchors(char *text)
{
    char *start = text;
    char *end;
    char c;

    for (;;) {
	for (; *start && (WHITE(*start)); start++) ;	/* Find start */
	if (!*start)
	    return;		/* (Done) */
	for (end = start;
	     *end && (*end != ' ') && (*end != ','); end++) ;	/* Find end */
	if (*end)
	    end++;		/* Include comma or space but not NULL */
	c = *end;
	*end = '\0';
	if (*start == '<')
	    write_anchor(start, start + 1);
	else
	    write_anchor(start, start);
	START(HTML_BR);
	*end = c;
	start = end;		/* Point to next one */
    }
}

/*	Abort the connection					abort_socket
 *	--------------------
 */
static void abort_socket(void)
{
    CTRACE((tfp, "HTNews: EOF on read, closing socket %d\n", s));
    NEWS_NETCLOSE(s);		/* End of file, close socket */
    if (rawtext) {
	RAW_PUTS("Network Error: connection lost\n");
    } else {
	PUTS("Network Error: connection lost");
	PUTC('\n');
    }
    s = -1;			/* End of file on response */
}

/*
 *  Determine if a line is a valid header line.			valid_header
 *  -------------------------------------------
 */
static BOOLEAN valid_header(char *line)
{
    char *colon, *space;

    /*
     * Blank or tab in first position implies this is a continuation header.
     */
    if (line[0] == ' ' || line[0] == '\t')
	return (TRUE);

    /*
     * Just check for initial letter, colon, and space to make sure we discard
     * only invalid headers.
     */
    colon = StrChr(line, ':');
    space = StrChr(line, ' ');
    if (isalpha(UCH(line[0])) && colon && space == colon + 1)
	return (TRUE);

    /*
     * Anything else is a bad header -- it should be ignored.
     */
    return (FALSE);
}

/*	post in an Article					post_article
 *	------------------
 *			(added by FM, modeled on Lynx's previous mini inews)
 *
 *	Note the termination condition of a single dot on a line by itself.
 *
 *  On entry,
 *	s		Global socket number is OK
 *	postfile	file with header and article to post.
 */
static void post_article(char *postfile)
{
    char line[512];
    char buf[512];
    char crlf[3];
    char *cp;
    int status;
    FILE *fd;
    int in_header = 1, seen_header = 0, seen_fromline = 0;
    int blen = 0, llen = 0;

    /*
     * Open the temporary file with the nntp headers and message body.  - FM
     */
    if ((fd = fopen(NonNull(postfile), TXT_R)) == NULL) {
	HTAlert(FAILED_CANNOT_OPEN_POST);
	return;
    }

    /*
     * Read the temporary file and post in maximum 512 byte chunks.  - FM
     */
    buf[0] = '\0';
    sprintf(crlf, "%c%c", CR, LF);
    while (fgets(line, (int) sizeof(line) - 2, fd) != NULL) {
	if ((cp = StrChr(line, '\n')) != NULL)
	    *cp = '\0';
	if (line[0] == '.') {
	    /*
	     * A single '.' means end of transmission for nntp.  Lead dots on
	     * lines normally are trimmed and the EOF is not registered if the
	     * dot was not followed by CRLF.  We prepend an extra dot for any
	     * line beginning with one, to retain the one intended, as well as
	     * avoid a false EOF signal.  We know we have room for it in the
	     * buffer, because we normally send when it would exceed 510.  - FM
	     */
	    strcat(buf, ".");
	    blen++;
	}
	llen = (int) strlen(line);
	if (in_header && !strncasecomp(line, "From:", 5)) {
	    seen_header = 1;
	    seen_fromline = 1;
	}
	if (in_header && line[0] == '\0') {
	    if (seen_header) {
		in_header = 0;
		if (!seen_fromline) {
		    if (blen >= (int) sizeof(buf) - 35) {
			IGNORE_RC(NEWS_NETWRITE(s, buf, blen));
			buf[blen = 0] = 0;
		    }
		    strcat(buf, "From: anonymous@@nowhere.you.know");
		    strcat(buf, crlf);
		    blen += 34;
		}
	    } else {
		continue;
	    }
	} else if (in_header) {
	    if (valid_header(line)) {
		seen_header = 1;
	    } else {
		continue;
	    }
	}
	strcat(line, crlf);
	llen += 2;
	if ((blen + llen) >= (int) sizeof(buf) - 1) {
	    IGNORE_RC(NEWS_NETWRITE(s, buf, blen));
	    buf[blen = 0] = 0;
	}
	strcat(buf, line);
	blen += llen;
    }
    fclose(fd);
    HTSYS_remove(postfile);

    /*
     * Send the nntp EOF and get the server's response.  - FM
     */
    if (blen >= (int) sizeof(buf) - 4) {
	IGNORE_RC(NEWS_NETWRITE(s, buf, blen));
	buf[blen = 0] = 0;
    }
    strcat(buf, ".");
    strcat(buf, crlf);
    blen += 3;
    IGNORE_RC(NEWS_NETWRITE(s, buf, blen));

    status = response(NULL);
    if (status == 240) {
	/*
	 * Successful post.  - FM
	 */
	HTProgress(response_text);
    } else {
	/*
	 * Shucks, something went wrong.  - FM
	 */
	HTAlert(response_text);
    }
}

#ifdef NEWS_DEBUG
/* for DEBUG 1997/11/07 (Fri) 17:20:16 */
void debug_print(unsigned char *p)
{
    while (*p) {
	if (*p == '\0')
	    break;
	if (*p == 0x1b)
	    printf("[ESC]");
	else if (*p == '\n')
	    printf("[NL]");
	else if (*p < ' ' || *p >= 0x80)
	    printf("(%02x)", *p);
	else
	    putchar(*p);
	p++;
    }
    printf("]\n");
}
#endif

static char *decode_mime(char **str)
{
    static char empty[] = "";

#ifdef SH_EX
    if (HTCJK != JAPANESE)
	return *str;
#endif
    HTmmdecode(str, *str);
    return HTrjis(str, *str) ? *str : empty;
}

/*	Read in an Article					read_article
 *	------------------
 *
 *	Note the termination condition of a single dot on a line by itself.
 *	RFC 977 specifies that the line "folding" of RFC850 is not used, so we
 *	do not handle it here.
 *
 * On entry,
 *	s	Global socket number is OK
 *	HT	Global hypertext object is ready for appending text
 */
static int read_article(HTParentAnchor *thisanchor)
{
    char line[LINE_LENGTH + 1];
    char *full_line = NULL;
    char *subject = NULL;	/* Subject string           */
    char *from = NULL;		/* From string              */
    char *replyto = NULL;	/* Reply-to string          */
    char *date = NULL;		/* Date string              */
    char *organization = NULL;	/* Organization string      */
    char *references = NULL;	/* Hrefs for other articles */
    char *newsgroups = NULL;	/* Newsgroups list          */
    char *followupto = NULL;	/* Followup list            */
    char *href = NULL;
    char *p = line;
    char *cp;
    const char *ccp;
    BOOL done = NO;

    /*
     * Read in the HEADer of the article.
     *
     * The header fields are either ignored, or formatted and put into the
     * text.
     */
    if (!diagnostic && !rawtext) {
	while (!done) {
	    int ich = NEXT_CHAR;

	    *p++ = (char) ich;
	    if (ich == EOF) {
		if (interrupted_in_htgetcharacter) {
		    interrupted_in_htgetcharacter = 0;
		    CTRACE((tfp,
			    "HTNews: Interrupted on read, closing socket %d\n",
			    s));
		    NEWS_NETCLOSE(s);
		    s = -1;
		    return (HT_INTERRUPTED);
		}
		abort_socket();	/* End of file, close socket */
		return (HT_LOADED);	/* End of file on response */
	    }
	    if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
		*--p = '\0';	/* Terminate the string */
		CTRACE((tfp, "H %s\n", line));

		if (line[0] == '\t' || line[0] == ' ') {
		    int i = 0;

		    while (line[i]) {
			if (line[i] == '\t')
			    line[i] = ' ';
			i++;
		    }
		    if (full_line == NULL) {
			StrAllocCopy(full_line, line);
		    } else {
			StrAllocCat(full_line, line);
		    }
		} else {
		    StrAllocCopy(full_line, line);
		}

		if (full_line[0] == '.') {
		    /*
		     * End of article?
		     */
		    if (UCH(full_line[1]) < ' ') {
			done = YES;
			break;
		    }
		} else if (UCH(full_line[0]) < ' ') {
		    break;	/* End of Header? */

		} else if (match(full_line, "SUBJECT:")) {
		    StrAllocCopy(subject, HTStrip(StrChr(full_line, ':') + 1));
		    decode_mime(&subject);
		} else if (match(full_line, "DATE:")) {
		    StrAllocCopy(date, HTStrip(StrChr(full_line, ':') + 1));

		} else if (match(full_line, "ORGANIZATION:")) {
		    StrAllocCopy(organization,
				 HTStrip(StrChr(full_line, ':') + 1));
		    decode_mime(&organization);

		} else if (match(full_line, "FROM:")) {
		    StrAllocCopy(from, HTStrip(StrChr(full_line, ':') + 1));
		    decode_mime(&from);

		} else if (match(full_line, "REPLY-TO:")) {
		    StrAllocCopy(replyto, HTStrip(StrChr(full_line, ':') + 1));
		    decode_mime(&replyto);

		} else if (match(full_line, "NEWSGROUPS:")) {
		    StrAllocCopy(newsgroups, HTStrip(StrChr(full_line, ':') + 1));

		} else if (match(full_line, "REFERENCES:")) {
		    StrAllocCopy(references, HTStrip(StrChr(full_line, ':') + 1));

		} else if (match(full_line, "FOLLOWUP-TO:")) {
		    StrAllocCopy(followupto, HTStrip(StrChr(full_line, ':') + 1));

		} else if (match(full_line, "MESSAGE-ID:")) {
		    char *msgid = HTStrip(full_line + 11);

		    if (msgid[0] == '<' && msgid[strlen(msgid) - 1] == '>') {
			msgid[strlen(msgid) - 1] = '\0';	/* Chop > */
			msgid++;	/* Chop < */
			HTAnchor_setMessageID(thisanchor, msgid);
		    }

		}		/* end if match */
		p = line;	/* Restart at beginning */
	    }			/* if end of line */
	}			/* Loop over characters */
	FREE(full_line);

	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	if (subject && *subject != '\0')
	    PUTS(subject);
	else
	    PUTS("No Subject");
	END(HTML_TITLE);
	PUTC('\n');
	/*
	 * Put in the owner as a link rel.
	 */
	if (from || replyto) {
	    char *temp = NULL;

	    StrAllocCopy(temp, author_address(replyto ? replyto : from));
	    StrAllocCopy(href, STR_MAILTO_URL);
	    if (StrChr(temp, '%') || StrChr(temp, '?')) {
		cp = HTEscape(temp, URL_XPALPHAS);
		StrAllocCat(href, cp);
		FREE(cp);
	    } else {
		StrAllocCat(href, temp);
	    }
	    start_link(href, "made");
	    PUTC('\n');
	    FREE(temp);
	}
	END(HTML_HEAD);
	PUTC('\n');

	START(HTML_H1);
	if (subject && *subject != '\0')
	    PUTS(subject);
	else
	    PUTS("No Subject");
	END(HTML_H1);
	PUTC('\n');

	if (subject)
	    FREE(subject);

	START(HTML_DLC);
	PUTC('\n');

	if (from || replyto) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("From:");
	    END(HTML_B);
	    PUTC(' ');
	    if (from)
		PUTS(from);
	    else
		PUTS(replyto);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');

	    if (!replyto)
		StrAllocCopy(replyto, from);
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Reply to:");
	    END(HTML_B);
	    PUTC(' ');
	    start_anchor(href);
	    if (*replyto != '<')
		PUTS(author_name(replyto));
	    else
		PUTS(author_address(replyto));
	    END(HTML_A);
	    START(HTML_BR);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');

	    FREE(from);
	    FREE(replyto);
	}

	if (date) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Date:");
	    END(HTML_B);
	    PUTC(' ');
	    PUTS(date);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    FREE(date);
	}

	if (organization) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Organization:");
	    END(HTML_B);
	    PUTC(' ');
	    PUTS(organization);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    FREE(organization);
	}

	/* sanitize some headers - kw */
	if (newsgroups &&
	    ((cp = StrChr(newsgroups, '/')) ||
	     (cp = StrChr(newsgroups, '(')))) {
	    *cp = '\0';
	}
	if (newsgroups && !*newsgroups) {
	    FREE(newsgroups);
	}
	if (followupto &&
	    ((cp = StrChr(followupto, '/')) ||
	     (cp = StrChr(followupto, '(')))) {
	    *cp = '\0';
	}
	if (followupto && !*followupto) {
	    FREE(followupto);
	}

	if (newsgroups && HTCanPost) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Newsgroups:");
	    END(HTML_B);
	    PUTC('\n');
	    MAYBE_END(HTML_DT);
	    START(HTML_DD);
	    write_anchors(newsgroups);
	    MAYBE_END(HTML_DD);
	    PUTC('\n');
	}

	if (followupto && !strcasecomp(followupto, "poster")) {
	    /*
	     * "Followup-To:  poster" has special meaning.  Don't use it to
	     * construct a newsreply link.  -kw
	     */
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Followup to:");
	    END(HTML_B);
	    PUTC(' ');
	    if (href) {
		start_anchor(href);
		PUTS("poster");
		END(HTML_A);
	    } else {
		PUTS("poster");
	    }
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    FREE(followupto);
	}

	if (newsgroups && HTCanPost) {
	    /*
	     * We have permission to POST to this host, so add a link for
	     * posting followups for this article.  - FM
	     */
	    if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
		StrAllocCopy(href, "snewsreply://");
	    else
		StrAllocCopy(href, "newsreply://");
	    StrAllocCat(href, NewsHost);
	    StrAllocCat(href, "/");
	    StrAllocCat(href, (followupto ? followupto : newsgroups));
	    if (*href == 'n' &&
		(ccp = HTAnchor_messageID(thisanchor)) && *ccp) {
		StrAllocCat(href, ";ref=");
		if (StrChr(ccp, '<') || StrChr(ccp, '&') ||
		    StrChr(ccp, ' ') || StrChr(ccp, ':') ||
		    StrChr(ccp, '/') || StrChr(ccp, '%') ||
		    StrChr(ccp, ';')) {
		    char *cp1 = HTEscape(ccp, URL_XPALPHAS);

		    StrAllocCat(href, cp1);
		    FREE(cp1);
		} else {
		    StrAllocCat(href, ccp);
		}
	    }

	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Followup to:");
	    END(HTML_B);
	    PUTC(' ');
	    start_anchor(href);
	    if (StrChr((followupto ? followupto : newsgroups), ',')) {
		PUTS("newsgroups");
	    } else {
		PUTS("newsgroup");
	    }
	    END(HTML_A);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	}
	FREE(newsgroups);
	FREE(followupto);

	if (references) {
	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("References:");
	    END(HTML_B);
	    MAYBE_END(HTML_DT);
	    PUTC('\n');
	    START(HTML_DD);
	    write_anchors(references);
	    MAYBE_END(HTML_DD);
	    PUTC('\n');
	    FREE(references);
	}

	END(HTML_DLC);
	PUTC('\n');
	FREE(href);
    }

    if (rawtext) {
	/*
	 * No tags, and never do a PUTC.  - kw
	 */
	;
    } else if (diagnostic) {
	/*
	 * Read in the HEAD and BODY of the Article as XMP formatted text.  -
	 * FM
	 */
	START(HTML_XMP);
	PUTC('\n');
    } else {
	/*
	 * Read in the BODY of the Article as PRE formatted text.  - FM
	 */
	START(HTML_PRE);
	PUTC('\n');
    }

    p = line;
    while (!done) {
	int ich = NEXT_CHAR;

	*p++ = (char) ich;
	if (ich == EOF) {
	    if (interrupted_in_htgetcharacter) {
		interrupted_in_htgetcharacter = 0;
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
		NEWS_NETCLOSE(s);
		s = -1;
		return (HT_INTERRUPTED);
	    }
	    abort_socket();	/* End of file, close socket */
	    return (HT_LOADED);	/* End of file on response */
	}
	if (((char) ich == LF) || (p == &line[LINE_LENGTH])) {
	    *p = '\0';		/* Terminate the string */
	    CTRACE((tfp, "B %s", line));
#ifdef NEWS_DEBUG		/* 1997/11/09 (Sun) 15:56:11 */
	    debug_print(line);	/* @@@@@@ */
#endif
	    if (line[0] == '.') {
		/*
		 * End of article?
		 */
		if (UCH(line[1]) < ' ') {
		    break;
		} else {	/* Line starts with dot */
		    if (rawtext) {
			RAW_PUTS(&line[1]);
		    } else {
			PUTS(&line[1]);		/* Ignore first dot */
		    }
		}
	    } else {
		if (rawtext) {
		    RAW_PUTS(line);
		} else if (diagnostic || !scan_for_buried_news_references) {
		    /*
		     * All lines are passed as unmodified source.  - FM
		     */
		    PUTS(line);
		} else {
		    /*
		     * Normal lines are scanned for buried references to other
		     * articles.  Unfortunately, it could pick up mail
		     * addresses as well!  It also can corrupt uuencoded
		     * messages!  So we don't do this when fetching articles as
		     * WWW_SOURCE or when downloading (diagnostic is TRUE) or
		     * if the client has set scan_for_buried_news_references to
		     * FALSE.  Otherwise, we convert all "<...@@...>" strings
		     * preceded by "rticle " to "news:...@@..." links, and any
		     * strings that look like URLs to links.  - FM
		     */
		    char *l = line;
		    char *p2;

		    while ((p2 = strstr(l, "rticle <")) != NULL) {
			char *q = strrchr(p2, '>');
			char *at = strrchr(p2, '@@');

			if (q && at && at < q) {
			    char c = q[1];

			    q[1] = 0;	/* chop up */
			    p2 += 7;
			    *p2 = 0;
			    while (*l) {
				if (StrNCmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				    StrNCmp(l, "snews://", 8) &&
				    StrNCmp(l, "nntp://", 7) &&
				    StrNCmp(l, "snewspost:", 10) &&
				    StrNCmp(l, "snewsreply:", 11) &&
				    StrNCmp(l, "newspost:", 9) &&
				    StrNCmp(l, "newsreply:", 10) &&
				    StrNCmp(l, "ftp://", 6) &&
				    StrNCmp(l, "file:/", 6) &&
				    StrNCmp(l, "finger://", 9) &&
				    StrNCmp(l, "http://", 7) &&
				    StrNCmp(l, "https://", 8) &&
				    StrNCmp(l, "wais://", 7) &&
				    StrNCmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
				    StrNCmp(l, "cso://", 6) &&
				    StrNCmp(l, "gopher://", 9)) {
				    PUTC(*l++);
				} else {
				    StrAllocCopy(href, l);
				    start_anchor(strtok(href, " \r\n\t,>)\""));
				    while (*l && !StrChr(" \r\n\t,>)\"", *l))
					PUTC(*l++);
				    END(HTML_A);
				    FREE(href);
				}
			    }
			    *p2 = '<';	/* again */
			    *q = 0;
			    start_anchor(p2 + 1);
			    *q = '>';	/* again */
			    PUTS(p2);
			    END(HTML_A);
			    q[1] = c;	/* again */
			    l = q + 1;
			} else {
			    break;	/* line has unmatched <> */
			}
		    }
		    while (*l) {	/* Last bit of the line */
			if (StrNCmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
			    StrNCmp(l, "snews://", 8) &&
			    StrNCmp(l, "nntp://", 7) &&
			    StrNCmp(l, "snewspost:", 10) &&
			    StrNCmp(l, "snewsreply:", 11) &&
			    StrNCmp(l, "newspost:", 9) &&
			    StrNCmp(l, "newsreply:", 10) &&
			    StrNCmp(l, "ftp://", 6) &&
			    StrNCmp(l, "file:/", 6) &&
			    StrNCmp(l, "finger://", 9) &&
			    StrNCmp(l, "http://", 7) &&
			    StrNCmp(l, "https://", 8) &&
			    StrNCmp(l, "wais://", 7) &&
			    StrNCmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
			    StrNCmp(l, "cso://", 6) &&
			    StrNCmp(l, "gopher://", 9))
			    PUTC(*l++);
			else {
			    StrAllocCopy(href, l);
			    start_anchor(strtok(href, " \r\n\t,>)\""));
			    while (*l && !StrChr(" \r\n\t,>)\"", *l))
				PUTC(*l++);
			    END(HTML_A);
			    FREE(href);
			}
		    }
		}		/* if diagnostic or not scan_for_buried_news_references */
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */

    if (rawtext)
	return (HT_LOADED);

    if (diagnostic)
	END(HTML_XMP);
    else
	END(HTML_PRE);
    PUTC('\n');
    return (HT_LOADED);
}

/*	Read in a List of Newsgroups
 *	----------------------------
 *
 *  Note the termination condition of a single dot on a line by itself.
 *  RFC 977 specifies that the line "folding" of RFC850 is not used,
 *  so we do not handle it here.
 */
static int read_list(char *arg)
{
    char line[LINE_LENGTH + 1];
    char *p;
    BOOL done = NO;
    BOOL head = NO;
    BOOL tail = NO;
    BOOL skip_this_line = NO;
    BOOL skip_rest_of_line = NO;
    int listing = 0;
    char *pattern = NULL;
    int len = 0;

    /*
     * Support head or tail matches for groups to list.  - FM
     */
    if (arg && strlen(arg) > 1) {
	if (*arg == '*') {
	    tail = YES;
	    StrAllocCopy(pattern, (arg + 1));
	} else if (arg[strlen(arg) - 1] == '*') {
	    head = YES;
	    StrAllocCopy(pattern, arg);
	    pattern[strlen(pattern) - 1] = '\0';
	}
	if (tail || head) {
	    len = (int) strlen(pattern);
	}

    }

    /*
     * Read the server's reply.
     *
     * The lines are scanned for newsgroup names and descriptions.
     */
    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    PUTS("Newsgroups");
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');
    START(HTML_H1);
    PUTS("Newsgroups");
    END(HTML_H1);
    PUTC('\n');
    p = line;
    START(HTML_DLC);
    PUTC('\n');
    while (!done) {
	int ich = NEXT_CHAR;
	char ch = (char) ich;

	if (ich == EOF) {
	    if (interrupted_in_htgetcharacter) {
		interrupted_in_htgetcharacter = 0;
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
		NEWS_NETCLOSE(s);
		s = -1;
		return (HT_INTERRUPTED);
	    }
	    abort_socket();	/* End of file, close socket */
	    FREE(pattern);
	    return (HT_LOADED);	/* End of file on response */
	} else if (skip_this_line) {
	    if (ch == LF) {
		skip_this_line = skip_rest_of_line = NO;
		p = line;
	    }
	    continue;
	} else if (skip_rest_of_line) {
	    if (ch != LF) {
		continue;
	    }
	} else if (p == &line[LINE_LENGTH]) {
	    CTRACE((tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch));
	    *p = '\0';
	    if (ch == LF) {
		;		/* Will be dealt with below */
	    } else if (WHITE(ch)) {
		ch = LF;	/* May treat as line without description */
		skip_this_line = YES;	/* ...and ignore until LF */
	    } else if (StrChr(line, ' ') == NULL &&
		       StrChr(line, '\t') == NULL) {
		/* No separator found */
		CTRACE((tfp, "HTNews..... group name too long, discarding.\n"));
		skip_this_line = YES;	/* ignore whole line */
		continue;
	    } else {
		skip_rest_of_line = YES;	/* skip until ch == LF found */
	    }
	} else {
	    *p++ = ch;
	}
	if (ch == LF) {
	    skip_rest_of_line = NO;	/* done, reset flag */
	    *p = '\0';		/* Terminate the string */
	    CTRACE((tfp, "B %s", line));
	    if (line[0] == '.') {
		/*
		 * End of article?
		 */
		if (UCH(line[1]) < ' ') {
		    break;
		} else {	/* Line starts with dot */
		    START(HTML_DT);
		    PUTS(&line[1]);
		    MAYBE_END(HTML_DT);
		}
	    } else if (line[0] == '#') {	/* Comment? */
		p = line;	/* Restart at beginning */
		continue;
	    } else {
		/*
		 * Normal lines are scanned for references to newsgroups.
		 */
		int i = 0;

		/* find whitespace if it exits */
		for (; line[i] != '\0' && !WHITE(line[i]); i++) ;	/* null body */

		if (line[i] != '\0') {
		    line[i] = '\0';
		    if ((head && strncasecomp(line, pattern, len)) ||
			(tail && (i < len ||
				  strcasecomp((line + (i - len)), pattern)))) {
			p = line;	/* Restart at beginning */
			continue;
		    }
		    START(HTML_DT);
		    write_anchor(line, line);
		    listing++;
		    MAYBE_END(HTML_DT);
		    PUTC('\n');
		    START(HTML_DD);
		    PUTS(&line[i + 1]);		/* put description */
		    MAYBE_END(HTML_DD);
		} else {
		    if ((head && strncasecomp(line, pattern, len)) ||
			(tail && (i < len ||
				  strcasecomp((line + (i - len)), pattern)))) {
			p = line;	/* Restart at beginning */
			continue;
		    }
		    START(HTML_DT);
		    write_anchor(line, line);
		    MAYBE_END(HTML_DT);
		    listing++;
		}
	    }			/* if not dot */
	    p = line;		/* Restart at beginning */
	}			/* if end of line */
    }				/* Loop over characters */
    if (!listing) {
	char *msg = NULL;

	START(HTML_DT);
	HTSprintf0(&msg, gettext("No matches for: %s"), arg);
	PUTS(msg);
	MAYBE_END(HTML_DT);
	FREE(msg);
    }
    END(HTML_DLC);
    PUTC('\n');
    FREE(pattern);
    return (HT_LOADED);
}

/*	Read in a Newsgroup
 *	-------------------
 *
 *  Unfortunately, we have to ask for each article one by one if we
 *  want more than one field.
 *
 */
static int read_group(const char *groupName,
		      int first_required,
		      int last_required)
{
    char line[LINE_LENGTH + 1];
    char *author = NULL;
    char *subject = NULL;
    char *date = NULL;
    int i;
    char *p;
    BOOL done;

    char buffer[LINE_LENGTH + 1];
    char *temp = NULL;
    char *reference = NULL;	/* Href for article */
    int art;			/* Article number WITHIN GROUP */
    int status, count, first, last;	/* Response fields */

    START(HTML_HEAD);
    PUTC('\n');
    START(HTML_TITLE);
    PUTS("Newsgroup ");
    PUTS(groupName);
    END(HTML_TITLE);
    PUTC('\n');
    END(HTML_HEAD);
    PUTC('\n');

    sscanf(response_text, " %d %d %d %d", &status, &count, &first, &last);
    CTRACE((tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
	    status, count, first, last, first_required, last_required));
    if (last == 0) {
	PUTS(gettext("\nNo articles in this group.\n"));
	goto add_post;
    }
#define FAST_THRESHOLD 100	/* Above this, read IDs fast */
#define CHOP_THRESHOLD 50	/* Above this, chop off the rest */

    if (first_required < first)
	first_required = first;	/* clip */
    if ((last_required == 0) || (last_required > last))
	last_required = last;

    if (last_required < first_required) {
	PUTS(gettext("\nNo articles in this range.\n"));
	goto add_post;
    }

    if (last_required - first_required + 1 > HTNewsMaxChunk) {	/* Trim this block */
	first_required = last_required - HTNewsChunkSize + 1;
    }
    CTRACE((tfp, "    Chunk will be (%d-%d)\n",
	    first_required, last_required));

    /*
     * Set window title.
     */
    HTSprintf0(&temp, gettext("%s,  Articles %d-%d"),
	       groupName, first_required, last_required);
    START(HTML_H1);
    PUTS(temp);
    FREE(temp);
    END(HTML_H1);
    PUTC('\n');

    /*
     * Link to earlier articles.
     */
    if (first_required > first) {
	int before;		/* Start of one before */

	if (first_required - HTNewsMaxChunk <= first)
	    before = first;
	else
	    before = first_required - HTNewsChunkSize;
	HTSprintf0(&dbuf, "%s%s/%d-%d", NewsHREF, groupName,
		   before, first_required - 1);
	CTRACE((tfp, "    Block before is %s\n", dbuf));
	PUTC('(');
	start_anchor(dbuf);
	PUTS(gettext("Earlier articles"));
	END(HTML_A);
	PUTS("...)\n");
	START(HTML_P);
	PUTC('\n');
    }

    done = NO;

/*#define USE_XHDR*/
#ifdef USE_XHDR
    if (count > FAST_THRESHOLD) {
	HTSprintf0(&temp,
		   gettext("\nThere are about %d articles currently available in %s, IDs as follows:\n\n"),
		   count, groupName);
	PUTS(temp);
	FREE(temp);
	sprintf(buffer, "XHDR Message-ID %d-%d%c%c", first, last, CR, LF);
	status = response(buffer);
	if (status == 221) {
	    p = line;
	    while (!done) {
		int ich = NEXT_CHAR;

		*p++ = ich;
		if (ich == EOF) {
		    if (interrupted_in_htgetcharacter) {
			interrupted_in_htgetcharacter = 0;
			CTRACE((tfp,
				"HTNews: Interrupted on read, closing socket %d\n",
				s));
			NEWS_NETCLOSE(s);
			s = -1;
			return (HT_INTERRUPTED);
		    }
		    abort_socket();	/* End of file, close socket */
		    return (HT_LOADED);		/* End of file on response */
		}
		if (((char) ich == '\n') || (p == &line[LINE_LENGTH])) {
		    *p = '\0';	/* Terminate the string */
		    CTRACE((tfp, "X %s", line));
		    if (line[0] == '.') {
			/*
			 * End of article?
			 */
			if (UCH(line[1]) < ' ') {
			    done = YES;
			    break;
			} else {	/* Line starts with dot */
			    /* Ignore strange line */
			}
		    } else {
			/*
			 * Normal lines are scanned for references to articles.
			 */
			char *space = StrChr(line, ' ');

			if (space++)
			    write_anchor(space, space);
		    }		/* if not dot */
		    p = line;	/* Restart at beginning */
		}		/* if end of line */
	    }			/* Loop over characters */

	    /* leaving loop with "done" set */
	}			/* Good status */
    }
#endif /* USE_XHDR */

    /*
     * Read newsgroup using individual fields.
     */
    if (!done) {
	START(HTML_B);
	if (first == first_required && last == last_required)
	    PUTS(gettext("All available articles in "));
	else
	    PUTS("Articles in ");
	PUTS(groupName);
	END(HTML_B);
	PUTC('\n');
	if (LYListNewsNumbers)
	    start_list(first_required);
	else
	    START(HTML_UL);
	for (art = first_required; art <= last_required; art++) {
/*#define OVERLAP*/
#ifdef OVERLAP
	    /*
	     * With this code we try to keep the server running flat out by
	     * queuing just one extra command ahead of time.  We assume (1)
	     * that the server won't abort if it gets input during output, and
	     * (2) that TCP buffering is enough for the two commands.  Both
	     * these assumptions seem very reasonable.  However, we HAVE had a
	     * hangup with a loaded server.
	     */
	    if (art == first_required) {
		if (art == last_required) {	/* Only one */
		    sprintf(buffer, "HEAD %d%c%c",
			    art, CR, LF);
		    status = response(buffer);
		} else {	/* First of many */
		    sprintf(buffer, "HEAD %d%c%cHEAD %d%c%c",
			    art, CR, LF, art + 1, CR, LF);
		    status = response(buffer);
		}
	    } else if (art == last_required) {	/* Last of many */
		status = response(NULL);
	    } else {		/* Middle of many */
		sprintf(buffer, "HEAD %d%c%c", art + 1, CR, LF);
		status = response(buffer);
	    }
#else /* Not OVERLAP: */
	    sprintf(buffer, "HEAD %d%c%c", art, CR, LF);
	    status = response(buffer);
#endif /* OVERLAP */
	    /*
	     * Check for a good response (221) for the HEAD request, and if so,
	     * parse it.  Otherwise, indicate the error so that the number of
	     * listings corresponds to what's claimed for the range, and if we
	     * are listing numbers via an ordered list, they stay in synchrony
	     * with the article numbers.  - FM
	     */
	    if (status == 221) {	/* Head follows - parse it: */
		p = line;	/* Write pointer */
		done = NO;
		while (!done) {
		    int ich = NEXT_CHAR;

		    *p++ = (char) ich;
		    if (ich == EOF) {
			if (interrupted_in_htgetcharacter) {
			    interrupted_in_htgetcharacter = 0;
			    CTRACE((tfp,
				    "HTNews: Interrupted on read, closing socket %d\n",
				    s));
			    NEWS_NETCLOSE(s);
			    s = -1;
			    return (HT_INTERRUPTED);
			}
			abort_socket();		/* End of file, close socket */
			return (HT_LOADED);	/* End of file on response */
		    }
		    if (((char) ich == LF) ||
			(p == &line[LINE_LENGTH])) {

			*--p = '\0';	/* Terminate  & chop LF */
			p = line;	/* Restart at beginning */
			CTRACE((tfp, "G %s\n", line));
			switch (line[0]) {

			case '.':
			    /*
			     * End of article?
			     */
			    done = (BOOL) (UCH(line[1]) < ' ');
			    break;

			case 'S':
			case 's':
			    if (match(line, "SUBJECT:")) {
				StrAllocCopy(subject, line + 9);
				decode_mime(&subject);
			    }
			    break;

			case 'M':
			case 'm':
			    if (match(line, "MESSAGE-ID:")) {
				char *addr = HTStrip(line + 11) + 1;	/* Chop < */

				addr[strlen(addr) - 1] = '\0';	/* Chop > */
				StrAllocCopy(reference, addr);
			    }
			    break;

			case 'f':
			case 'F':
			    if (match(line, "FROM:")) {
				char *p2;

				StrAllocCopy(author, StrChr(line, ':') + 1);
				decode_mime(&author);
				p2 = author + strlen(author) - 1;
				if (*p2 == LF)
				    *p2 = '\0';		/* Chop off newline */
			    }
			    break;

			case 'd':
			case 'D':
			    if (LYListNewsDates && match(line, "DATE:")) {
				StrAllocCopy(date,
					     HTStrip(StrChr(line, ':') + 1));
			    }
			    break;

			}	/* end switch on first character */
		    }		/* if end of line */
		}		/* Loop over characters */

		PUTC('\n');
		START(HTML_LI);
		p = decode_mime(&subject);
		HTSprintf0(&temp, "\"%s\"", NonNull(p));
		if (reference) {
		    write_anchor(temp, reference);
		    FREE(reference);
		} else {
		    PUTS(temp);
		}
		FREE(temp);

		if (author != NULL) {
		    PUTS(" - ");
		    if (LYListNewsDates)
			START(HTML_I);
		    PUTS(decode_mime(&author));
		    if (LYListNewsDates)
			END(HTML_I);
		    FREE(author);
		}
		if (date) {
		    if (!diagnostic) {
			for (i = 0; date[i]; i++) {
			    if (date[i] == ' ') {
				date[i] = HT_NON_BREAK_SPACE;
			    }
			}
		    }
		    sprintf(buffer, " [%.*s]", (int) (sizeof(buffer) - 4), date);
		    PUTS(buffer);
		    FREE(date);
		}
		MAYBE_END(HTML_LI);
		/*
		 * Indicate progress!  @@@@@@@@@@@@
		 */
	    } else if (status == HT_INTERRUPTED) {
		interrupted_in_htgetcharacter = 0;
		CTRACE((tfp,
			"HTNews: Interrupted on read, closing socket %d\n",
			s));
		NEWS_NETCLOSE(s);
		s = -1;
		return (HT_INTERRUPTED);
	    } else {
		/*
		 * Use the response text on error.  - FM
		 */
		PUTC('\n');
		START(HTML_LI);
		START(HTML_I);
		if (LYListNewsNumbers)
		    LYStrNCpy(buffer, "Status:", sizeof(buffer) - 1);
		else
		    sprintf(buffer, "Status (ARTICLE %d):", art);
		PUTS(buffer);
		END(HTML_I);
		PUTC(' ');
		PUTS(response_text);
		MAYBE_END(HTML_LI);
	    }			/* Handle response to HEAD request */
	}			/* Loop over article */
	FREE(author);
	FREE(subject);
    }				/* If read headers */
    PUTC('\n');
    if (LYListNewsNumbers)
	END(HTML_OL);
    else
	END(HTML_UL);
    PUTC('\n');

    /*
     * Link to later articles.
     */
    if (last_required < last) {
	int after;		/* End of article after */

	after = last_required + HTNewsChunkSize;
	if (after == last)
	    HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName);	/* original group */
	else
	    HTSprintf0(&dbuf, "%s%s/%d-%d", NewsHREF, groupName,
		       last_required + 1, after);
	CTRACE((tfp, "    Block after is %s\n", dbuf));
	PUTC('(');
	start_anchor(dbuf);
	PUTS(gettext("Later articles"));
	END(HTML_A);
	PUTS("...)\n");
    }

  add_post:
    if (HTCanPost) {
	/*
	 * We have permission to POST to this host, so add a link for posting
	 * messages to this newsgroup.  - FM
	 */
	char *href = NULL;

	START(HTML_HR);
	PUTC('\n');
	if (!strncasecomp(NewsHREF, STR_SNEWS_URL, 6))
	    StrAllocCopy(href, "snewspost://");
	else
	    StrAllocCopy(href, "newspost://");
	StrAllocCat(href, NewsHost);
	StrAllocCat(href, "/");
	StrAllocCat(href, groupName);
	start_anchor(href);
	PUTS(gettext("Post to "));
	PUTS(groupName);
	END(HTML_A);
	FREE(href);
    } else {
	START(HTML_HR);
    }
    PUTC('\n');
    return (HT_LOADED);
}

/*	Load by name.						HTLoadNews
 *	=============
 */
static int HTLoadNews(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *stream)
{
    char command[262];		/* The whole command */
    char proxycmd[260];		/* The proxy command */
    char groupName[GROUP_NAME_LENGTH];	/* Just the group name */
    int status;			/* tcp return */
    int retries;		/* A count of how hard we have tried */
    BOOL normal_url;		/* Flag: "news:" or "nntp:" (physical) URL */
    BOOL group_wanted;		/* Flag: group was asked for, not article */
    BOOL list_wanted;		/* Flag: list was asked for, not article */
    BOOL post_wanted;		/* Flag: new post to group was asked for */
    BOOL reply_wanted;		/* Flag: followup post was asked for */
    BOOL spost_wanted;		/* Flag: new SSL post to group was asked for */
    BOOL sreply_wanted;		/* Flag: followup SSL post was asked for */
    BOOL head_wanted = NO;	/* Flag: want HEAD of single article */
    int first, last;		/* First and last articles asked for */
    char *cp = 0;
    char *ListArg = NULL;
    char *ProxyHost = NULL;
    char *ProxyHREF = NULL;
    char *postfile = NULL;

#ifdef USE_SSL
    char SSLprogress[256];
#endif /* USE_SSL */

    diagnostic = (format_out == WWW_SOURCE ||	/* set global flag */
		  format_out == HTAtom_for("www/download") ||
		  format_out == HTAtom_for("www/dump"));
    rawtext = NO;

    CTRACE((tfp, "HTNews: Looking for %s\n", arg));

    if (!initialized)
	initialized = initialize();
    if (!initialized)
	return -1;		/* FAIL */

    FREE(NewsHREF);
    command[0] = '\0';
    command[sizeof(command) - 1] = '\0';
    proxycmd[0] = '\0';
    proxycmd[sizeof(proxycmd) - 1] = '\0';

    {
	const char *p1;

	/*
	 * We will ask for the document, omitting the host name & anchor.
	 *
	 * Syntax of address is
	 * xxx@@yyy                 Article
	 * <xxx@@yyy>               Same article
	 * xxxxx                   News group (no "@@")
	 * group/n1-n2             Articles n1 to n2 in group
	 */
	normal_url = (BOOL) (!StrNCmp(arg, STR_NEWS_URL, LEN_NEWS_URL) ||
			     !StrNCmp(arg, "nntp:", 5));
	spost_wanted = (BOOL) (!normal_url && strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (BOOL) (!(normal_url || spost_wanted) &&
				strstr(arg, "snewsreply:") != NULL);
	post_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted) &&
			      strstr(arg, "newspost:") != NULL);
	reply_wanted = (BOOL) (!(normal_url || spost_wanted || sreply_wanted ||
				 post_wanted) &&
			       strstr(arg, "newsreply:") != NULL);
	group_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				  post_wanted || reply_wanted) &&
				StrChr(arg, '@@') == NULL) &&
			       (StrChr(arg, '*') == NULL));
	list_wanted = (BOOL) ((!(spost_wanted || sreply_wanted ||
				 post_wanted || reply_wanted ||
				 group_wanted) &&
			       StrChr(arg, '@@') == NULL) &&
			      (StrChr(arg, '*') != NULL));

#ifndef USE_SSL
	if (!strncasecomp(arg, "snewspost:", 10) ||
	    !strncasecomp(arg, "snewsreply:", 11)) {
	    HTAlert(FAILED_CANNOT_POST_SSL);
	    return HT_NOT_LOADED;
	}
#endif /* !USE_SSL */
	if (post_wanted || reply_wanted || spost_wanted || sreply_wanted) {
	    /*
	     * Make sure we have a non-zero path for the newsgroup(s).  - FM
	     */
	    if ((p1 = strrchr(arg, '/')) != NULL) {
		p1++;
	    } else if ((p1 = strrchr(arg, ':')) != NULL) {
		p1++;
	    }
	    if (!(p1 && *p1)) {
		HTAlert(WWW_ILLEGAL_URL_MESSAGE);
		return (HT_NO_DATA);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    HTSprintf0(&NewsHREF, "%s://%.*s/",
		       (post_wanted ?
			"newspost" :
			(reply_wanted ?
			 "newreply" :
			 (spost_wanted ?
			  "snewspost" : "snewsreply"))),
		       (int) sizeof(command) - 15, NewsHost);

	    /*
	     * If the SSL daemon is being used as a proxy, reset p1 to the
	     * start of the proxied URL rather than to the start of the
	     * newsgroup(s).  - FM
	     */
	    if (spost_wanted && strncasecomp(arg, "snewspost:", 10))
		p1 = strstr(arg, "snewspost:");
	    if (sreply_wanted && strncasecomp(arg, "snewsreply:", 11))
		p1 = strstr(arg, "snewsreply:");

	    /* p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION); */
	    /*
	     * Don't use HTParse because news:  access doesn't follow
	     * traditional rules.  For instance, if the article reference
	     * contains a '#', the rest of it is lost -- JFG 10/7/92, from a
	     * bug report
	     */
	} else if (isNNTP_URL(arg)) {
	    if (((*(arg + 5) == '\0') ||
		 (!strcmp((arg + 5), "/") ||
		  !strcmp((arg + 5), "//") ||
		  !strcmp((arg + 5), "///"))) ||
		((!StrNCmp((arg + 5), "//", 2)) &&
		 (!(cp = StrChr((arg + 7), '/')) || *(cp + 1) == '\0'))) {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    } else if (*(arg + 5) != '/') {
		p1 = (arg + 5);
	    } else if (*(arg + 5) == '/' && *(arg + 6) != '/') {
		p1 = (arg + 6);
	    } else {
		p1 = (cp + 1);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    SnipIn2(command, "%s//%.*s/", STR_NNTP_URL, 9, NewsHost);
	    StrAllocCopy(NewsHREF, command);
	} else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
#ifdef USE_SSL
	    if (((*(arg + 6) == '\0') ||
		 (!strcmp((arg + 6), "/") ||
		  !strcmp((arg + 6), "//") ||
		  !strcmp((arg + 6), "///"))) ||
		((!StrNCmp((arg + 6), "//", 2)) &&
		 (!(cp = StrChr((arg + 8), '/')) || *(cp + 1) == '\0'))) {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    } else if (*(arg + 6) != '/') {
		p1 = (arg + 6);
	    } else if (*(arg + 6) == '/' && *(arg + 7) != '/') {
		p1 = (arg + 7);
	    } else {
		p1 = (cp + 1);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    sprintf(command, "%s//%.250s/", STR_SNEWS_URL, NewsHost);
	    StrAllocCopy(NewsHREF, command);
#else
	    HTAlert(gettext("This client does not contain support for SNEWS URLs."));
	    return HT_NOT_LOADED;
#endif /* USE_SSL */
	} else if (!strncasecomp(arg, "news:/", 6)) {
	    if (((*(arg + 6) == '\0') ||
		 !strcmp((arg + 6), "/") ||
		 !strcmp((arg + 6), "//")) ||
		((*(arg + 6) == '/') &&
		 (!(cp = StrChr((arg + 7), '/')) || *(cp + 1) == '\0'))) {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    } else if (*(arg + 6) != '/') {
		p1 = (arg + 6);
	    } else {
		p1 = (cp + 1);
	    }
	    if (!(cp = HTParse(arg, "", PARSE_HOST)) || *cp == '\0') {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, HTNewsHost);
	    } else {
		if (s >= 0 && NewsHost && strcasecomp(NewsHost, cp)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		StrAllocCopy(NewsHost, cp);
	    }
	    FREE(cp);
	    SnipIn(command, "news://%.*s/", 9, NewsHost);
	    StrAllocCopy(NewsHREF, command);
	} else {
	    p1 = (arg + 5);	/* Skip "news:" prefix */
	    if (*p1 == '\0') {
		p1 = "*";
		group_wanted = FALSE;
		list_wanted = TRUE;
	    }
	    if (s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost)) {
		NEWS_NETCLOSE(s);
		s = -1;
	    }
	    StrAllocCopy(NewsHost, HTNewsHost);
	    StrAllocCopy(NewsHREF, STR_NEWS_URL);
	}

	/*
	 * Set up any proxy for snews URLs that returns NNTP responses for Lynx
	 * to convert to HTML, instead of doing the conversion itself, and for
	 * handling posts or followups.  - TZ & FM
	 */
	if (!strncasecomp(p1, STR_SNEWS_URL, 6) ||
	    !strncasecomp(p1, "snewspost:", 10) ||
	    !strncasecomp(p1, "snewsreply:", 11)) {
	    StrAllocCopy(ProxyHost, NewsHost);
	    if ((cp = HTParse(p1, "", PARSE_HOST)) != NULL && *cp != '\0') {
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, cp);
		StrAllocCopy(NewsHost, cp);
	    } else {
		SnipIn2(command, "%s//%.*s", STR_SNEWS_URL, 10, NewsHost);
	    }
	    command[sizeof(command) - 2] = '\0';
	    FREE(cp);
	    sprintf(proxycmd, "GET %.*s%c%c%c%c",
		    (int) sizeof(proxycmd) - 9, command,
		    CR, LF, CR, LF);
	    CTRACE((tfp, "HTNews: Proxy command is '%.*s'\n",
		    (int) (strlen(proxycmd) - 4), proxycmd));
	    strcat(command, "/");
	    StrAllocCopy(ProxyHREF, NewsHREF);
	    StrAllocCopy(NewsHREF, command);
	    if (spost_wanted || sreply_wanted) {
		/*
		 * Reset p1 so that it points to the newsgroup(s).
		 */
		if ((p1 = strrchr(arg, '/')) != NULL) {
		    p1++;
		} else {
		    p1 = (strrchr(arg, ':') + 1);
		}
	    } else {
		/*
		 * Reset p1 so that it points to the newsgroup (or a wildcard),
		 * or the article.
		 */
		if (!(cp = strrchr((p1 + 6), '/')) || *(cp + 1) == '\0') {
		    p1 = "*";
		    group_wanted = FALSE;
		    list_wanted = TRUE;
		} else {
		    p1 = (cp + 1);
		}
	    }
	}

	/*
	 * Set up command for a post, listing, or article request.  - FM
	 */
	if (post_wanted || reply_wanted || spost_wanted || sreply_wanted) {
	    strcpy(command, "POST");
	} else if (list_wanted) {
	    if (strlen(p1) > 249) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    SnipIn(command, "XGTITLE %.*s", 11, p1);
	} else if (group_wanted) {
	    char *slash = StrChr(p1, '/');

	    first = 0;
	    last = 0;
	    if (slash) {
		*slash = '\0';
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYStrNCpy(groupName, p1, sizeof(groupName) - 1);
		*slash = '/';
		(void) sscanf(slash + 1, "%d-%d", &first, &last);
		if ((first > 0) && (isdigit(UCH(*(slash + 1)))) &&
		    (StrChr(slash + 1, '-') == NULL || first == last)) {
		    /*
		     * We got a number greater than 0, which will be loaded as
		     * first, and either no range or the range computes to
		     * zero, so make last negative, as a flag to select the
		     * group and then fetch an article by number (first)
		     * instead of by messageID.  - FM
		     */
		    last = -1;
		}
	    } else {
		if (strlen(p1) >= sizeof(groupName)) {
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    HTAlert(URL_TOO_LONG);
		    return -400;
		}
		LYStrNCpy(groupName, p1, sizeof(groupName) - 1);
	    }
	    SnipIn(command, "GROUP %.*s", 9, groupName);
	} else {
	    size_t add_open = (size_t) (StrChr(p1, '<') == 0);
	    size_t add_close = (size_t) (StrChr(p1, '>') == 0);

	    if (strlen(p1) + add_open + add_close >= 252) {
		FREE(ProxyHost);
		FREE(ProxyHREF);
		HTAlert(URL_TOO_LONG);
		return -400;
	    }
	    sprintf(command, "ARTICLE %s%.*s%s",
		    add_open ? "<" : "",
		    (int) (sizeof(command) - (11 + add_open + add_close)),
		    p1,
		    add_close ? ">" : "");
	}

	{
	    char *p = command + strlen(command);

	    /*
	     * Terminate command with CRLF, as in RFC 977.
	     */
	    *p++ = CR;		/* Macros to be correct on Mac */
	    *p++ = LF;
	    *p = 0;
	}
	StrAllocCopy(ListArg, p1);
    }				/* scope of p1 */

    if (!*arg) {
	FREE(NewsHREF);
	FREE(ProxyHost);
	FREE(ProxyHREF);
	FREE(ListArg);
	return NO;		/* Ignore if no name */
    }

    if (!(post_wanted || reply_wanted || spost_wanted || sreply_wanted ||
	  (group_wanted && last != -1) || list_wanted)) {
	head_wanted = anAnchor->isHEAD;
	if (head_wanted && !StrNCmp(command, "ARTICLE ", 8)) {
	    /* overwrite "ARTICLE" - hack... */
	    strcpy(command, "HEAD ");
	    for (cp = command + 5;; cp++)
		if ((*cp = *(cp + 3)) == '\0')
		    break;
	}
	rawtext = (BOOL) (head_wanted || keep_mime_headers);
    }
    if (rawtext) {
	rawtarget = HTStreamStack(WWW_PLAINTEXT,
				  format_out,
				  stream, anAnchor);
	if (!rawtarget) {
	    FREE(NewsHost);
	    FREE(NewsHREF);
	    FREE(ProxyHost);
	    FREE(ProxyHREF);
	    FREE(ListArg);
	    HTAlert(gettext("No target for raw text!"));
	    return (HT_NOT_LOADED);
	}			/* Copy routine entry points */
	rawtargetClass = *rawtarget->isa;
    } else
	/*
	 * Make a hypertext object with an anchor list.
	 */
    if (!(post_wanted || reply_wanted || spost_wanted || sreply_wanted)) {
	target = HTML_new(anAnchor, format_out, stream);
	targetClass = *target->isa;	/* Copy routine entry points */
    }

    /*
     * Now, let's get a stream setup up from the NewsHost.
     */
    for (retries = 0; retries < 2; retries++) {
	if (s < 0) {
	    /* CONNECTING to news host */
	    char url[260];

	    if (!strcmp(NewsHREF, STR_NEWS_URL)) {
		SnipIn(url, "lose://%.*s/", 9, NewsHost);
	    } else if (ProxyHREF) {
		SnipIn(url, "%.*s", 1, ProxyHREF);
	    } else {
		SnipIn(url, "%.*s", 1, NewsHREF);
	    }
	    CTRACE((tfp, "News: doing HTDoConnect on '%s'\n", url));

	    _HTProgress(gettext("Connecting to NewsHost ..."));

#ifdef USE_SSL
	    if (!using_proxy &&
		(!StrNCmp(arg, STR_SNEWS_URL, 6) ||
		 !StrNCmp(arg, "snewspost:", 10) ||
		 !StrNCmp(arg, "snewsreply:", 11)))
		status = HTDoConnect(url, "NNTPS", SNEWS_PORT, &s);
	    else
		status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
#else
	    status = HTDoConnect(url, "NNTP", NEWS_PORT, &s);
#endif /* USE_SSL */

	    if (status == HT_INTERRUPTED) {
		/*
		 * Interrupt cleanly.
		 */
		CTRACE((tfp,
			"HTNews: Interrupted on connect; recovering cleanly.\n"));
		_HTProgress(CONNECTION_INTERRUPTED);
		if (!(post_wanted || reply_wanted ||
		      spost_wanted || sreply_wanted)) {
		    ABORT_TARGET;
		}
		FREE(NewsHost);
		FREE(NewsHREF);
		FREE(ProxyHost);
		FREE(ProxyHREF);
		FREE(ListArg);
#ifdef USE_SSL
		if (Handle) {
		    SSL_free(Handle);
		    Handle = NULL;
		}
#endif /* USE_SSL */
		if (postfile) {
		    HTSYS_remove(postfile);
		    FREE(postfile);
		}
		return HT_NOT_LOADED;
	    }
	    if (status < 0) {
		NEWS_NETCLOSE(s);
		s = -1;
		CTRACE((tfp, "HTNews: Unable to connect to news host.\n"));
		if (retries < 1)
		    continue;
		if (!(post_wanted || reply_wanted ||
		      spost_wanted || sreply_wanted)) {
		    ABORT_TARGET;
		}
		HTSprintf0(&dbuf, gettext("Could not access %s."), NewsHost);
		FREE(NewsHost);
		FREE(NewsHREF);
		FREE(ProxyHost);
		FREE(ProxyHREF);
		FREE(ListArg);
		if (postfile) {
		    HTSYS_remove(postfile);
		    FREE(postfile);
		}
		return HTLoadError(stream, 500, dbuf);
	    } else {
		CTRACE((tfp, "HTNews: Connected to news host %s.\n",
			NewsHost));
#ifdef USE_SSL
		/*
		 * If this is an snews url, then do the SSL stuff here
		 */
		if (!using_proxy &&
		    (!StrNCmp(url, "snews", 5) ||
		     !StrNCmp(url, "snewspost:", 10) ||
		     !StrNCmp(url, "snewsreply:", 11))) {
		    Handle = HTGetSSLHandle();
		    SSL_set_fd(Handle, s);
		    HTSSLInitPRNG();
		    status = SSL_connect(Handle);

		    if (status <= 0) {
			unsigned long SSLerror;

			CTRACE((tfp,
				"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
				url, status));
			SSL_load_error_strings();
			while ((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp, "HTNews: SSL: %s\n",
				    ERR_error_string(SSLerror, NULL)));
			}
			HTAlert("Unable to make secure connection to remote host.");
			NEWS_NETCLOSE(s);
			s = -1;
			if (!(post_wanted || reply_wanted ||
			      spost_wanted || sreply_wanted))
			    (*targetClass._abort) (target, NULL);
			FREE(NewsHost);
			FREE(NewsHREF);
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			if (postfile) {
#ifdef VMS
			    while (remove(postfile) == 0) ;	/* loop through all versions */
#else
			    remove(postfile);
#endif /* VMS */
			    FREE(postfile);
			}
			return HT_NOT_LOADED;
		    }
		    sprintf(SSLprogress,
			    "Secure %d-bit %s (%s) NNTP connection",
			    SSL_get_cipher_bits(Handle, NULL),
			    SSL_get_cipher_version(Handle),
			    SSL_get_cipher(Handle));
		    _HTProgress(SSLprogress);
		}
#endif /* USE_SSL */
		HTInitInput(s);	/* set up buffering */
		if (proxycmd[0]) {
		    status = (int) NEWS_NETWRITE(s, proxycmd, (int) strlen(proxycmd));
		    CTRACE((tfp,
			    "HTNews: Proxy command returned status '%d'.\n",
			    status));
		}
		if (((status = response(NULL)) / 100) != 2) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		    if (status == HT_INTERRUPTED) {
			_HTProgress(CONNECTION_INTERRUPTED);
			if (!(post_wanted || reply_wanted ||
			      spost_wanted || sreply_wanted)) {
			    ABORT_TARGET;
			}
			FREE(NewsHost);
			FREE(NewsHREF);
			FREE(ProxyHost);
			FREE(ProxyHREF);
			FREE(ListArg);
			if (postfile) {
			    HTSYS_remove(postfile);
			    FREE(postfile);
			}
			return (HT_NOT_LOADED);
		    }
		    if (retries < 1)
			continue;
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		    FREE(ListArg);
		    FREE(postfile);
		    if (!(post_wanted || reply_wanted ||
			  spost_wanted || sreply_wanted)) {
			ABORT_TARGET;
		    }
		    if (response_text[0]) {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info.  News host %.20s responded: %.200s"),
				   NewsHost, response_text);
		    } else {
			HTSprintf0(&dbuf,
				   gettext("Can't read news info, empty response from host %s"),
				   NewsHost);
		    }
		    return HTLoadError(stream, 500, dbuf);
		}
		if (status == 200) {
		    HTCanPost = TRUE;
		} else {
		    HTCanPost = FALSE;
		    if (post_wanted || reply_wanted ||
			spost_wanted || sreply_wanted) {
			HTAlert(CANNOT_POST);
			FREE(NewsHREF);
			if (ProxyHREF) {
			    StrAllocCopy(NewsHost, ProxyHost);
			    FREE(ProxyHost);
			    FREE(ProxyHREF);
			}
			FREE(ListArg);
			if (postfile) {
			    HTSYS_remove(postfile);
			    FREE(postfile);
			}
			return (HT_NOT_LOADED);
		    }
		}
	    }
	}
	/* If needed opening */
	if (post_wanted || reply_wanted ||
	    spost_wanted || sreply_wanted) {
	    if (!HTCanPost) {
		HTAlert(CANNOT_POST);
		FREE(NewsHREF);
		if (ProxyHREF) {
		    StrAllocCopy(NewsHost, ProxyHost);
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		}
		FREE(ListArg);
		if (postfile) {
		    HTSYS_remove(postfile);
		    FREE(postfile);
		}
		return (HT_NOT_LOADED);
	    }
	    if (postfile == NULL) {
		postfile = LYNewsPost(ListArg,
				      (reply_wanted || sreply_wanted));
	    }
	    if (postfile == NULL) {
		HTProgress(CANCELLED);
		FREE(NewsHREF);
		if (ProxyHREF) {
		    StrAllocCopy(NewsHost, ProxyHost);
		    FREE(ProxyHost);
		    FREE(ProxyHREF);
		}
		FREE(ListArg);
		return (HT_NOT_LOADED);
	    }
	} else {
	    /*
	     * Ensure reader mode, but don't bother checking the status for
	     * anything but HT_INTERRUPTED or a 480 Authorization request,
	     * because if the reader mode command is not needed, the server
	     * probably returned a 500, which is irrelevant at this point.  -
	     * FM
	     */
	    char buffer[20];

	    sprintf(buffer, "mode reader%c%c", CR, LF);
	    if ((status = response(buffer)) == HT_INTERRUPTED) {
		_HTProgress(CONNECTION_INTERRUPTED);
		break;
	    }
	    if (status == 480) {
		NNTPAuthResult auth_result = HTHandleAuthInfo(NewsHost);

		if (auth_result == NNTPAUTH_CLOSE) {
		    if (s != -1 && !(ProxyHost || ProxyHREF)) {
			NEWS_NETCLOSE(s);
			s = -1;
		    }
		}
		if (auth_result != NNTPAUTH_OK) {
		    break;
		}
		if (response(buffer) == HT_INTERRUPTED) {
		    _HTProgress(CONNECTION_INTERRUPTED);
		    break;
		}
	    }
	}

      Send_NNTP_command:
#ifdef NEWS_DEB
	if (postfile)
	    printf("postfile = %s, command = %s", postfile, command);
	else
	    printf("command = %s", command);
#endif
	if ((status = response(command)) == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    break;
	}
	if (status < 0) {
	    if (retries < 1) {
		continue;
	    } else {
		break;
	    }
	}
	/*
	 * For some well known error responses which are expected to occur in
	 * normal use, break from the loop without retrying and without closing
	 * the connection.  It is unlikely that these are leftovers from a
	 * timed-out connection (but we do some checks to see whether the
	 * response corresponds to the last command), or that they will give
	 * anything else when automatically retried.  - kw
	 */
	if (status == 411 && group_wanted &&
	    !StrNCmp(command, "GROUP ", 6) &&
	    !strncasecomp(response_text + 3, " No such group ", 15) &&
	    !strcmp(response_text + 18, groupName)) {

	    HTAlert(response_text);
	    break;
	} else if (status == 430 && !group_wanted && !list_wanted &&
		   !StrNCmp(command, "ARTICLE <", 9) &&
		   !strcasecomp(response_text + 3, " No such article")) {

	    HTAlert(response_text);
	    break;
	}
	if ((status / 100) != 2 &&
	    status != 340 &&
	    status != 480) {
	    if (retries) {
		if (list_wanted && !StrNCmp(command, "XGTITLE", 7)) {
		    sprintf(command, "LIST NEWSGROUPS%c%c", CR, LF);
		    goto Send_NNTP_command;
		}
		HTAlert(response_text);
	    } else {
		_HTProgress(response_text);
	    }
	    NEWS_NETCLOSE(s);
	    s = -1;
	    /*
	     * Message might be a leftover "Timeout-disconnected", so try again
	     * if the retries maximum has not been reached.
	     */
	    continue;
	}

	/*
	 * Post or load a group, article, etc
	 */
	if (status == 480) {
	    NNTPAuthResult auth_result;

	    /*
	     * Some servers return 480 for a failed XGTITLE.  - FM
	     */
	    if (list_wanted && !StrNCmp(command, "XGTITLE", 7) &&
		strstr(response_text, "uthenticat") == NULL &&
		strstr(response_text, "uthor") == NULL) {
		sprintf(command, "LIST NEWSGROUPS%c%c", CR, LF);
		goto Send_NNTP_command;
	    }
	    /*
	     * Handle Authorization.  - FM
	     */
	    if ((auth_result = HTHandleAuthInfo(NewsHost)) == NNTPAUTH_OK) {
		goto Send_NNTP_command;
	    } else if (auth_result == NNTPAUTH_CLOSE) {
		if (s != -1 && !(ProxyHost || ProxyHREF)) {
		    NEWS_NETCLOSE(s);
		    s = -1;
		}
		if (retries < 1)
		    continue;
	    }
	    status = HT_NOT_LOADED;
	} else if (post_wanted || reply_wanted ||
		   spost_wanted || sreply_wanted) {
	    /*
	     * Handle posting of an article.  - FM
	     */
	    if (status != 340) {
		HTAlert(CANNOT_POST);
		if (postfile) {
		    HTSYS_remove(postfile);
		}
	    } else {
		post_article(postfile);
	    }
	    FREE(postfile);
	    status = HT_NOT_LOADED;
	} else if (list_wanted) {
	    /*
	     * List available newsgroups.  - FM
	     */
	    _HTProgress(gettext("Reading list of available newsgroups."));
	    status = read_list(ListArg);
	} else if (group_wanted) {
	    /*
	     * List articles in a news group.  - FM
	     */
	    if (last < 0) {
		/*
		 * We got one article number rather than a range following the
		 * slash which followed the group name, or the range was zero,
		 * so now that we have selected that group, load ARTICLE and
		 * the the number (first) as the command and go back to send it
		 * and check the response.  - FM
		 */
		sprintf(command, "%s %d%c%c",
			head_wanted ? "HEAD" : "ARTICLE",
			first, CR, LF);
		group_wanted = FALSE;
		retries = 2;
		goto Send_NNTP_command;
	    }
	    _HTProgress(gettext("Reading list of articles in newsgroup."));
	    status = read_group(groupName, first, last);
	} else {
	    /*
	     * Get an article from a news group.  - FM
	     */
	    _HTProgress(gettext("Reading news article."));
	    status = read_article(anAnchor);
	}
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    status = HT_LOADED;
	}
	if (!(post_wanted || reply_wanted ||
	      spost_wanted || sreply_wanted)) {
	    if (status == HT_NOT_LOADED) {
		ABORT_TARGET;
	    } else {
		FREE_TARGET;
	    }
	}
	FREE(NewsHREF);
	if (ProxyHREF) {
	    StrAllocCopy(NewsHost, ProxyHost);
	    FREE(ProxyHost);
	    FREE(ProxyHREF);
	}
	FREE(ListArg);
	if (postfile) {
	    HTSYS_remove(postfile);
	    FREE(postfile);
	}
	return status;
    }				/* Retry loop */

#if 0
    HTAlert(gettext("Sorry, could not load requested news."));
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL, NULL, NULL, arg);
    /* No -- message earlier wil have covered it */
#endif

    if (!(post_wanted || reply_wanted ||
	  spost_wanted || sreply_wanted)) {
	ABORT_TARGET;
    }
    FREE(NewsHREF);
    if (ProxyHREF) {
	StrAllocCopy(NewsHost, ProxyHost);
	FREE(ProxyHost);
	FREE(ProxyHREF);
    }
    FREE(ListArg);
    if (postfile) {
	HTSYS_remove(postfile);
	FREE(postfile);
    }
    return HT_NOT_LOADED;
}

/*
 *  This function clears all authorization information by
 *  invoking the free_NNTP_AuthInfo() function, which normally
 *  is invoked at exit.  It allows a browser command to do
 *  this at any time, for example, if the user is leaving
 *  the terminal for a period of time, but does not want
 *  to end the current session.  - FM
 */
void HTClearNNTPAuthInfo(void)
{
    /*
     * Need code to check cached documents and do something to ensure that any
     * protected documents no longer can be accessed without a new retrieval. 
     * - FM
     */

    /*
     * Now free all of the authorization info.  - FM
     */
    free_NNTP_AuthInfo();
}

#ifdef USE_SSL
static int HTNewsGetCharacter(void)
{
    if (!Handle)
	return HTGetCharacter();
    else
	return HTGetSSLCharacter((void *) Handle);
}

int HTNewsProxyConnect(int sock,
		       const char *url,
		       HTParentAnchor *anAnchor,
		       HTFormat format_out,
		       HTStream *sink)
{
    int status;
    const char *arg = url;
    char SSLprogress[256];

    s = channel_s = sock;
    Handle = HTGetSSLHandle();
    SSL_set_fd(Handle, s);
    HTSSLInitPRNG();
    status = SSL_connect(Handle);

    if (status <= 0) {
	unsigned long SSLerror;

	channel_s = -1;
	CTRACE((tfp,
		"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		url, status));
	SSL_load_error_strings();
	while ((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp, "HTNews: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	}
	HTAlert("Unable to make secure connection to remote host.");
	NEWS_NETCLOSE(s);
	s = -1;
	return HT_NOT_LOADED;
    }
    sprintf(SSLprogress, "Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle, NULL),
	    SSL_get_cipher_version(Handle),
	    SSL_get_cipher(Handle));
    _HTProgress(SSLprogress);
    status = HTLoadNews(arg, anAnchor, format_out, sink);
    channel_s = -1;
    return status;
}
#endif /* USE_SSL */

#ifdef GLOBALDEF_IS_MACRO
#define _HTNEWS_C_1_INIT { "news", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNews, _HTNEWS_C_1_INIT);
#define _HTNEWS_C_2_INIT { "nntp", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNNTP, _HTNEWS_C_2_INIT);
#define _HTNEWS_C_3_INIT { "newspost", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNewsPost, _HTNEWS_C_3_INIT);
#define _HTNEWS_C_4_INIT { "newsreply", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTNewsReply, _HTNEWS_C_4_INIT);
#define _HTNEWS_C_5_INIT { "snews", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTSNews, _HTNEWS_C_5_INIT);
#define _HTNEWS_C_6_INIT { "snewspost", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTSNewsPost, _HTNEWS_C_6_INIT);
#define _HTNEWS_C_7_INIT { "snewsreply", HTLoadNews, NULL }
GLOBALDEF(HTProtocol, HTSNewsReply, _HTNEWS_C_7_INIT);
#else
GLOBALDEF HTProtocol HTNews =
{"news", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNNTP =
{"nntp", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsPost =
{"newspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTNewsReply =
{"newsreply", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNews =
{"snews", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsPost =
{"snewspost", HTLoadNews, NULL};
GLOBALDEF HTProtocol HTSNewsReply =
{"snewsreply", HTLoadNews, NULL};
#endif /* GLOBALDEF_IS_MACRO */

#endif /* not DISABLE_NEWS */
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTNews.c,v 1.60 2009/05/24 23:11:26 tom Exp $
a79 3
struct _HTStream {
    HTStreamClass *isa;
};
a93 1
/* static HText *	HT;	*//* the new hypertext */
d172 1
a172 1
	while (fgets(buffer, sizeof(buffer), fp) != NULL) {
d255 2
a256 2
	    if (fgets(server_name, sizeof server_name, fp) != NULL) {
		char *p = strchr(server_name, '\n');
d296 1
a296 1
	int length = strlen(command);
d311 1
a311 1
	status = NEWS_NETWRITE(s, (char *) command, length);
d669 1
a669 1
	(e = strrchr(address, ')')) && (at = strchr(address, '@@'))) {
d766 4
a769 2
    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p != ','); p++) ;
    if (strlen(NewsHREF) + (p - addr) + 1 < sizeof(href)) {
d772 2
a773 1
	strncat(q, addr, p - addr);	/* Make complete hypertext reference */
d859 2
a860 2
    colon = strchr(line, ':');
    space = strchr(line, ' ');
d904 2
a905 2
    while (fgets(line, sizeof(line) - 2, fd) != NULL) {
	if ((cp = strchr(line, '\n')) != NULL)
d919 1
a919 1
	llen = strlen(line);
d929 1
a929 1
			NEWS_NETWRITE(s, buf, blen);
d949 1
a949 1
	    NEWS_NETWRITE(s, buf, blen);
d962 1
a962 1
	NEWS_NETWRITE(s, buf, blen);
d968 1
a968 1
    NEWS_NETWRITE(s, buf, blen);
d1103 1
a1103 1
		    StrAllocCopy(subject, HTStrip(strchr(full_line, ':') + 1));
d1106 1
a1106 1
		    StrAllocCopy(date, HTStrip(strchr(full_line, ':') + 1));
d1110 1
a1110 1
				 HTStrip(strchr(full_line, ':') + 1));
d1114 1
a1114 1
		    StrAllocCopy(from, HTStrip(strchr(full_line, ':') + 1));
d1118 1
a1118 1
		    StrAllocCopy(replyto, HTStrip(strchr(full_line, ':') + 1));
d1122 1
a1122 1
		    StrAllocCopy(newsgroups, HTStrip(strchr(full_line, ':') + 1));
d1125 1
a1125 1
		    StrAllocCopy(references, HTStrip(strchr(full_line, ':') + 1));
d1128 1
a1128 1
		    StrAllocCopy(followupto, HTStrip(strchr(full_line, ':') + 1));
d1162 1
a1162 1
	    if (strchr(temp, '%') || strchr(temp, '?')) {
d1250 2
a1251 2
	    ((cp = strchr(newsgroups, '/')) ||
	     (cp = strchr(newsgroups, '(')))) {
d1258 2
a1259 2
	    ((cp = strchr(followupto, '/')) ||
	     (cp = strchr(followupto, '(')))) {
d1316 4
a1319 4
		if (strchr(ccp, '<') || strchr(ccp, '&') ||
		    strchr(ccp, ' ') || strchr(ccp, ':') ||
		    strchr(ccp, '/') || strchr(ccp, '%') ||
		    strchr(ccp, ';')) {
d1335 1
a1335 1
	    if (strchr((followupto ? followupto : newsgroups), ',')) {
d1405 1
a1405 1
	    *p++ = '\0';	/* Terminate the string */
a1414 1
		    done = YES;
d1457 16
a1472 16
				if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
				    strncmp(l, "snews://", 8) &&
				    strncmp(l, "nntp://", 7) &&
				    strncmp(l, "snewspost:", 10) &&
				    strncmp(l, "snewsreply:", 11) &&
				    strncmp(l, "newspost:", 9) &&
				    strncmp(l, "newsreply:", 10) &&
				    strncmp(l, "ftp://", 6) &&
				    strncmp(l, "file:/", 6) &&
				    strncmp(l, "finger://", 9) &&
				    strncmp(l, "http://", 7) &&
				    strncmp(l, "https://", 8) &&
				    strncmp(l, "wais://", 7) &&
				    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
				    strncmp(l, "cso://", 6) &&
				    strncmp(l, "gopher://", 9)) {
d1477 1
a1477 1
				    while (*l && !strchr(" \r\n\t,>)\"", *l))
d1496 16
a1511 16
			if (strncmp(l, STR_NEWS_URL, LEN_NEWS_URL) &&
			    strncmp(l, "snews://", 8) &&
			    strncmp(l, "nntp://", 7) &&
			    strncmp(l, "snewspost:", 10) &&
			    strncmp(l, "snewsreply:", 11) &&
			    strncmp(l, "newspost:", 9) &&
			    strncmp(l, "newsreply:", 10) &&
			    strncmp(l, "ftp://", 6) &&
			    strncmp(l, "file:/", 6) &&
			    strncmp(l, "finger://", 9) &&
			    strncmp(l, "http://", 7) &&
			    strncmp(l, "https://", 8) &&
			    strncmp(l, "wais://", 7) &&
			    strncmp(l, STR_MAILTO_URL, LEN_MAILTO_URL) &&
			    strncmp(l, "cso://", 6) &&
			    strncmp(l, "gopher://", 9))
d1516 1
a1516 1
			    while (*l && !strchr(" \r\n\t,>)\"", *l))
d1572 1
a1572 1
	    len = strlen(pattern);
d1632 2
a1633 2
	    } else if (strchr(line, ' ') == NULL &&
		       strchr(line, '\t') == NULL) {
a1652 1
		    done = YES;
d1860 1
a1860 1
			char *space = strchr(line, ' ');
d1986 1
a1986 1
				StrAllocCopy(author, strchr(line, ':') + 1);
d1998 1
a1998 1
					     HTStrip(strchr(line, ':') + 1));
d2059 1
a2059 1
		    LYstrncpy(buffer, "Status:", sizeof(buffer) - 1);
d2179 1
a2179 1
	const char *p1 = arg;
d2190 2
a2191 2
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) ||
			     !strncmp(arg, "nntp:", 5));
d2202 2
a2203 2
				strchr(arg, '@@') == NULL) &&
			       (strchr(arg, '*') == NULL));
d2207 2
a2208 2
			       strchr(arg, '@@') == NULL) &&
			      (strchr(arg, '*') != NULL));
d2275 2
a2276 2
		((!strncmp((arg + 5), "//", 2)) &&
		 (!(cp = strchr((arg + 7), '/')) || *(cp + 1) == '\0'))) {
d2309 2
a2310 2
		((!strncmp((arg + 6), "//", 2)) &&
		 (!(cp = strchr((arg + 8), '/')) || *(cp + 1) == '\0'))) {
d2346 1
a2346 1
		 (!(cp = strchr((arg + 7), '/')) || *(cp + 1) == '\0'))) {
d2449 1
a2449 1
	    char *slash = strchr(p1, '/');
d2461 1
a2461 1
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2465 1
a2465 1
		    (strchr(slash + 1, '-') == NULL || first == last)) {
d2482 1
a2482 1
		LYstrncpy(groupName, p1, sizeof(groupName) - 1);
d2486 2
a2487 2
	    int add_open = (strchr(p1, '<') == 0);
	    int add_close = (strchr(p1, '>') == 0);
d2510 1
a2510 1
	    *p++ = 0;
d2526 1
a2526 1
	if (head_wanted && !strncmp(command, "ARTICLE ", 8)) {
d2579 3
a2581 3
		(!strncmp(arg, STR_SNEWS_URL, 6) ||
		 !strncmp(arg, "snewspost:", 10) ||
		 !strncmp(arg, "snewsreply:", 11)))
d2646 3
a2648 3
		    (!strncmp(url, "snews", 5) ||
		     !strncmp(url, "snewspost:", 10) ||
		     !strncmp(url, "snewsreply:", 11))) {
d2696 1
a2696 1
		    status = NEWS_NETWRITE(s, proxycmd, strlen(proxycmd));
d2785 1
a2785 1
				      (BOOLEAN) (reply_wanted || sreply_wanted));
d2825 1
a2825 1
		if ((status = response(buffer)) == HT_INTERRUPTED) {
d2859 1
a2859 1
	    !strncmp(command, "GROUP ", 6) &&
d2866 1
a2866 1
		   !strncmp(command, "ARTICLE <", 9) &&
d2876 1
a2876 1
		if (list_wanted && !strncmp(command, "XGTITLE", 7)) {
d2902 1
a2902 1
	    if (list_wanted && !strncmp(command, "XGTITLE", 7) &&
@


1.8
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			NEWS ACCESS				HTNews.c
d54 1
a54 1
static char HTNewsGetCharacter(void);
a101 1
static HTParentAnchor *node_anchor;	/* Its anchor */
d176 1
a176 1
	while (fgets(buffer, sizeof(buffer), fp) != 0) {
d392 1
a392 1
     * Make sure we have an interactive user and a host.  - FM
d394 1
a394 1
    if (dump_output_immediately || !(host && *host))
d1008 2
d1015 1
a1015 1
    return HTrjis(str, *str) ? *str : "";
a2538 1
	node_anchor = anAnchor;
a2556 1
	node_anchor = anAnchor;
d3047 1
a3047 1
static char HTNewsGetCharacter(void)
@


1.7
log
@update to lynx2.8.5rel.4; fixes CAN-2005-3120 among other things.
prompted by naddy@@, cloder@@ ok.
@
text
@d2 6
a7 6
**			===========
**
** History:
**	26 Sep 90	Written TBL
**	29 Nov 91	Downgraded to C, for portable implementation.
*/
d28 2
a29 2
PUBLIC int HTNewsChunkSize = 30;/* Number of articles for quick display */
PUBLIC int HTNewsMaxChunk = 40; /* Largest number of articles in one window */
d34 8
a41 3
#ifndef SERVER_FILE
#define SERVER_FILE "/usr/local/lib/rn/server"
#endif /* SERVER_FILE */
d44 3
a46 3
extern SSL_CTX * ssl_ctx;
PRIVATE SSL * Handle = NULL;
PRIVATE int channel_s = 1;
d50 3
a52 2
	{ (void)NETCLOSE(sock); if (Handle) SSL_free(Handle); Handle = NULL; }
PRIVATE char HTNewsGetCharacter NOPARAMS;
d74 2
a75 2
	CONST HTStructuredClass *	isa;
	/* ... */
d77 2
a78 3
struct _HTStream
{
  HTStreamClass * isa;
d81 1
a81 1
#define LINE_LENGTH 512			/* Maximum length of line of ARTICLE etc */
d85 21
a105 20
**  Module-wide variables.
*/
PUBLIC	char * HTNewsHost = NULL;		/* Default host */
PRIVATE char * NewsHost = NULL;			/* Current host */
PRIVATE char * NewsHREF = NULL;			/* Current HREF prefix */
PRIVATE int s;					/* Socket for NewsHost */
PRIVATE int HTCanPost = FALSE;			/* Current POST permission */
PRIVATE char response_text[LINE_LENGTH+1];	/* Last response */
/* PRIVATE HText *	HT;	*/		/* the new hypertext */
PRIVATE HTStructured * target;			/* The output sink */
PRIVATE HTStructuredClass targetClass;		/* Copy of fn addresses */
PRIVATE HTStream * rawtarget = NULL;		/* The output sink for rawtext */
PRIVATE HTStreamClass rawtargetClass;		/* Copy of fn addresses */
PRIVATE HTParentAnchor *node_anchor;		/* Its anchor */
PRIVATE int	diagnostic;			/* level: 0=none 2=source */
PRIVATE BOOL rawtext = NO;			/* Flag: HEAD or -mime_headers */
PRIVATE HTList *NNTP_AuthInfo = NULL;		/* AUTHINFO database */
PRIVATE char *name = NULL;
PRIVATE char *address = NULL;
PRIVATE char *dbuf = NULL;	/* dynamic buffer for long messages etc. */
d120 3
a122 3
   char * host;
   char * user;
   char * pass;
d126 1
a126 1
PRIVATE void free_news_globals NOARGS
d141 1
a141 1
PRIVATE void free_NNTP_AuthInfo NOARGS
d149 1
a149 1
    while (NULL != (auth = (NNTPAuth *)HTList_nextObject(cur))) {
d160 39
a198 1
PUBLIC CONST char * HTGetNewsHost NOARGS
d200 1
a200 1
	return HTNewsHost;
d203 1
a203 1
PUBLIC void HTSetNewsHost ARGS1(CONST char *, value)
d205 1
a205 1
	StrAllocCopy(HTNewsHost, value);
d209 19
a227 19
**	------------------------------
**
**	Except on the NeXT, we pick up the NewsHost name from
**
**	1.	Environment variable NNTPSERVER
**	2.	File SERVER_FILE
**	3.	Compilation time macro DEFAULT_NEWS_HOST
**	4.	Default to "news"
**
**	On the NeXT, we pick up the NewsHost name from, in order:
**
**	1.	WorldWideWeb default "NewsHost"
**	2.	Global default "NewsHost"
**	3.	News default "NewsHost"
**	4.	Compilation time macro DEFAULT_NEWS_HOST
**	5.	Default to "news"
*/
PRIVATE BOOL initialized = NO;
PRIVATE BOOL initialize NOARGS
d234 2
a235 2
    **	Get name of Host.
    */
d237 2
a238 2
    if ((cp = NXGetDefaultValue("WorldWideWeb","NewsHost"))==0) {
	if ((cp = NXGetDefaultValue("News","NewsHost")) == 0) {
d250 1
a250 1
		    HTNewsHost));
d252 2
a253 1
	FILE* fp = fopen(SERVER_FILE, TXT_R);
d255 2
a256 1
	    char server_name[MAXHOSTNAMELEN+1];
d259 1
d264 1
a264 1
			    SERVER_FILE, HTNewsHost));
d273 1
a273 1
    s = -1;		/* Disconnected */
d281 10
a290 10
**	------------------------------------------------------
**
** On entry,
**	command points to the command to be sent, including CRLF, or is null
**		pointer if no command to be sent.
** On exit,
**	Negative status indicates transmission error, socket closed.
**	Positive status is an NNTP status.
*/
PRIVATE int response ARGS1(char *,command)
d293 1
a293 1
    char * p = response_text;
d299 1
d303 6
a308 5
	    CONST char	* p;
	    char	* q;
	    char ascii[LINE_LENGTH+1];
	    for(p = command, q=ascii; *p; p++, q++) {
		*q = TOASCII(*p);
d313 1
a313 1
	status = NEWS_NETWRITE(s, (char *)command, length);
d315 1
a315 1
	if (status < 0){
d320 3
a322 3
	} /* if bad status */
    } /* if command to be sent */

d327 1
a327 1
	    *--p = '\0';			/* Terminate the string */
d331 2
a332 2
	} /* if end of line */

d334 1
a334 1
	    *(p-1) = '\0';
d336 3
a338 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d341 1
a341 1
			    s));
d347 1
a347 1
		return(HT_INTERRUPTED);
d349 1
a349 1
	    return((int)EOF);	/* End of file on response */
d351 1
a351 1
    } /* Loop over characters */
d355 7
a361 7
**	-----------------------------------
**
** On entry,
**	template must be already un upper case.
**	unknown may be in upper or lower or mixed case to match.
*/
PRIVATE BOOL match ARGS2 (CONST char *,unknown, CONST char *,template)
d363 5
a367 5
    CONST char * u = unknown;
    CONST char * t = template;
    for (; *u && *t && (TOUPPER(*u) == *t); u++, t++)
	; /* Find mismatch or end */
    return (BOOL)(*t == 0);		/* OK if end of template */
d371 3
a373 3
    NNTPAUTH_ERROR =	  0,	/* general failure */
    NNTPAUTH_OK =	281,	/* authenticated successfully */
    NNTPAUTH_CLOSE =	502	/* server probably closed connection */
d375 1
d377 3
a379 4
**  This function handles nntp authentication. - FM
*/
PRIVATE NNTPAuthResult HTHandleAuthInfo ARGS1(
	char *,		host)
d390 2
a391 2
    **	Make sure we have an interactive user and a host. - FM
    */
d396 3
a398 12
    **	Check for an existing authorization entry. - FM
    */
    if (NNTP_AuthInfo != NULL) {
	cur = NNTP_AuthInfo;
	while (NULL != (auth = (NNTPAuth *)HTList_nextObject(cur))) {
	    if (!strcmp(auth->host, host)) {
		UserName = auth->user;
		PassWord = auth->pass;
		break;
	    }
	}
    } else {
d400 1
d406 9
d416 3
a418 3
    **	Handle the username. - FM
    */
    buffer[sizeof(buffer)-1] = '\0';
d432 1
a432 1
		(int) sizeof(buffer)-17, UserName, CR, LF);
d450 2
a451 2
	    **  Username is accepted and no password is required. - FM
	    */
d459 2
a460 2
		**  Store the accepted username and no password. - FM
		*/
d471 3
a473 3
	    **  Not success, nor a request for the password,
	    **  so it must be an error. - FM
	    */
d480 2
a481 1
		if ((UserName = HTPrompt(gettext("Username:"), UserName)) != NULL &&
d500 2
a501 2
	**  Handle the password. - FM
	*/
d514 1
a514 1
		    (int) sizeof(buffer)-17, PassWord, CR, LF);
d538 2
a539 2
		 *  That's what INN's nnrpd returns.
		 *  It closes the connection after this. - kw
d555 4
a558 4
	    /*
	    **	Password also is accepted, and everything
	    **	has been stored. - FM
	    */
d579 2
a580 2
	    **	Not success, so it must be an error. - FM
	    */
d606 12
a617 12
**	----------------------------------
**
** On exit,
**	Returns allocated string which cannot be freed by the
**	calling function, and is reallocated on subsequent calls
**	to this function.
**
** For example, returns "Tim Berners-Lee" if given any of
**	" Tim Berners-Lee <tim@@online.cern.ch> "
**  or	" tim@@online.cern.ch ( Tim Berners-Lee ) "
*/
PRIVATE char * author_name ARGS1 (char *,email)
d622 1
a622 1
    CTRACE((tfp,"Trying to find name in: %s\n",name));
d626 2
a627 2
	    *e = '\0';			/* Chop off everything after the ')'  */
	    return HTStrip(p+1);	/* Remove leading and trailing spaces */
d639 1
a639 1
    return HTStrip(name);		/* Default to the whole thing */
d643 12
a654 12
**	--------------------------
**
** On exit,
**	Returns allocated string which cannot be freed by the
**	calling function, and is reallocated on subsequent calls
**	to this function.
**
** For example, returns "montulli@@spaced.out.galaxy.net" if given any of
**	" Lou Montulli <montulli@@spaced.out.galaxy.net> "
**  or	" montulli@@spaced.out.galaxy.net ( Lou "The Stud" Montulli ) "
*/
PRIVATE char * author_address ARGS1(char *,email)
d659 1
a659 1
    CTRACE((tfp,"Trying to find address in: %s\n",address));
d664 2
a665 2
		*e = '\0';		 /* Remove > */
		return HTStrip(p+1);  /* Remove leading and trailing spaces */
d673 1
a673 1
	    *p = '\0';			/* Chop off everything after the ')'  */
d690 2
a691 2
    **	Default to the first word.
    */
d694 1
a694 1
	p++; /* find first non-space */
d697 2
a698 2
	e++; /* find next space or end */
    *e = '\0'; /* terminate space */
d700 1
a700 1
    return(p);
d704 3
a706 3
**	--------------------
*/
PRIVATE void start_anchor ARGS1(CONST char *,  href)
d708 2
a709 2
    BOOL		present[HTML_A_ATTRIBUTES];
    CONST char*		value[HTML_A_ATTRIBUTES];
d712 1
a712 1
    for(i=0; i < HTML_A_ATTRIBUTES; i++)
d715 1
a715 1
    (*targetClass.start_element)(target, HTML_A, present, value, -1, 0);
d719 3
a721 3
**	------------------
*/
PRIVATE void start_link ARGS2(CONST char *,  href, CONST char *, rev)
d723 2
a724 2
    BOOL		present[HTML_LINK_ATTRIBUTES];
    CONST char*		value[HTML_LINK_ATTRIBUTES];
d727 1
a727 1
    for(i=0; i < HTML_LINK_ATTRIBUTES; i++)
d730 2
a731 2
    value[HTML_LINK_REV]  = rev;
    (*targetClass.start_element)(target, HTML_LINK, present, value, -1, 0);
d735 3
a737 3
**	------------------
*/
PRIVATE void start_list ARGS1(int, seqnum)
d739 2
a740 2
    BOOL		present[HTML_OL_ATTRIBUTES];
    CONST char*		value[HTML_OL_ATTRIBUTES];
d748 2
a749 2
    value[HTML_OL_START]  = SeqNum;
    (*targetClass.start_element)(target, HTML_OL, present, value, -1, 0);
d753 10
a762 10
**	------------------
**
**
** On entry,
**	HT	has a selection of zero length at the end.
**	text	points to the text to be put into the file, 0 terminated.
**	addr	points to the hypertext reference address,
**		terminated by white space, comma, NULL or '>'
*/
PRIVATE void write_anchor ARGS2(CONST char *,text, CONST char *,addr)
d764 2
a765 2
    char href[LINE_LENGTH+1];
    CONST char * p;
d768 1
a768 2
    for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p!=','); p++)
	;
d772 1
a772 1
	strncat(q, addr, p-addr);	/* Make complete hypertext reference */
d775 1
a775 1
	HTSprintf0(&q, "%s%.*s", NewsHREF, p-addr, addr);
d787 12
a798 12
**	---------------------
**
**	We take a pointer to a list of objects, and write out each,
**	generating an anchor for each.
**
** On entry,
**	HT	has a selection of zero length at the end.
**	text	points to a comma or space separated list of addresses.
** On exit,
**	*text	is NOT any more chopped up into substrings.
*/
PRIVATE void write_anchors ARGS1 (char *,text)
d800 2
a801 2
    char * start = text;
    char * end;
d803 1
d805 1
a805 2
	for (; *start && (WHITE(*start)); start++)
	    ;  /* Find start */
d807 1
a807 1
	    return;			/* (Done) */
d809 1
a809 2
	     *end && (*end != ' ') && (*end != ','); end++)
	    ;/* Find end */
d811 1
a811 1
	    end++;	/* Include comma or space but not NULL */
d815 1
a815 1
	    write_anchor(start, start+1);
d820 1
a820 1
	start = end;			/* Point to next one */
d825 3
a827 3
**	--------------------
*/
PRIVATE void abort_socket NOARGS
d830 1
a830 1
    NEWS_NETCLOSE(s);	/* End of file, close socket */
d837 1
a837 1
    s = -1;		/* End of file on response */
d841 4
a844 5
**  Determine if a line is a valid header line.			valid_header
**  -------------------------------------------
*/
PRIVATE BOOLEAN valid_header ARGS1(
	char *,		line)
d849 2
a850 3
    **	Blank or tab in first position implies
    **	this is a continuation header.
    */
d852 1
a852 1
	return(TRUE);
d855 3
a857 3
    **	Just check for initial letter, colon, and space to make
    **	sure we discard only invalid headers.
    */
d861 1
a861 1
	return(TRUE);
d864 3
a866 3
    **	Anything else is a bad header -- it should be ignored.
    */
    return(FALSE);
d870 10
a879 11
**	------------------
**			(added by FM, modeled on Lynx's previous mini inews)
**
**	Note the termination condition of a single dot on a line by itself.
**
**  On entry,
**	s		Global socket number is OK
**	postfile	file with header and article to post.
*/
PRIVATE void post_article ARGS1(
	char *,		postfile)
a889 1

d891 2
a892 3
    **	Open the temporary file with the
    **	nntp headers and message body. - FM
    */
d899 2
a900 3
    **	Read the temporary file and post
    **	in maximum 512 byte chunks. - FM
    */
d903 1
a903 1
    while (fgets(line, sizeof(line)-2, fd) != NULL) {
d908 7
a914 11
	    **	A single '.' means end of transmission
	    **	for nntp.  Lead dots on lines normally
	    **	are trimmed and the EOF is not registered
	    **	if the dot was not followed by CRLF.
	    **	We prepend an extra dot for any line
	    **	beginning with one, to retain the one
	    **	intended, as well as avoid a false EOF
	    **	signal.  We know we have room for it in
	    **	the buffer, because we normally send when
	    **	it would exceed 510. - FM
	    */
d935 1
a935 1
	     } else {
d947 1
a947 1
	if ((blen + llen) >= (int) sizeof(buf)-1) {
d958 3
a960 3
    **	Send the nntp EOF and get the server's response. - FM
    */
    if (blen >= (int) sizeof(buf)-4) {
d972 2
a973 2
	**  Successful post. - FM
	*/
d977 2
a978 2
	**  Shucks, something went wrong. - FM
	*/
d991 1
a991 1
	   printf("[ESC]");
d993 1
a993 1
	   printf("[NL]");
d995 1
a995 1
	   printf("(%02x)", *p);
d997 2
a998 2
	   putchar(*p);
       p++;
d1015 11
a1025 12
**	------------------
**
**	Note the termination condition of a single dot on a line by itself.
**	RFC 977 specifies that the line "folding" of RFC850 is not used, so we
**	do not handle it here.
**
** On entry,
**	s	Global socket number is OK
**	HT	Global hypertext object is ready for appending text
*/
PRIVATE int read_article ARGS1(
	HTParentAnchor *,	thisanchor)
d1027 1
a1027 1
    char line[LINE_LENGTH+1];
d1029 8
a1036 8
    char *subject = NULL;			/* Subject string	    */
    char *from = NULL;				/* From string		    */
    char *replyto = NULL;			/* Reply-to string	    */
    char *date = NULL;				/* Date string		    */
    char *organization = NULL;			/* Organization string	    */
    char *references = NULL;			/* Hrefs for other articles */
    char *newsgroups = NULL;			/* Newsgroups list	    */
    char *followupto = NULL;			/* Followup list	    */
d1040 1
a1040 1
    CONST char *ccp;
d1044 5
a1048 5
    **	Read in the HEADer of the article.
    **
    **	The header fields are either ignored,
    **	or formatted and put into the text.
    */
d1052 1
d1057 3
a1059 2
		    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				s));
d1062 1
a1062 1
		    return(HT_INTERRUPTED);
d1064 2
a1065 2
		abort_socket();		/* End of file, close socket */
		return(HT_LOADED);	/* End of file on response */
d1067 2
a1068 2
	    if (((char)ich == LF) || (p == &line[LINE_LENGTH])) {
		*--p = '\0';			/* Terminate the string */
d1073 1
d1090 2
a1091 2
		    **	End of article?
		    */
d1097 1
a1097 1
		    break;		/* End of Header? */
d1100 1
a1100 1
		    StrAllocCopy(subject, HTStrip(strchr(full_line,':')+1));
d1103 1
a1103 1
		    StrAllocCopy(date, HTStrip(strchr(full_line,':')+1));
d1107 1
a1107 1
				 HTStrip(strchr(full_line,':')+1));
d1111 1
a1111 1
		    StrAllocCopy(from, HTStrip(strchr(full_line,':')+1));
d1115 1
a1115 1
		    StrAllocCopy(replyto, HTStrip(strchr(full_line,':')+1));
d1119 1
a1119 1
		    StrAllocCopy(newsgroups, HTStrip(strchr(full_line,':')+1));
d1122 1
a1122 1
		    StrAllocCopy(references, HTStrip(strchr(full_line,':')+1));
d1125 1
a1125 1
		    StrAllocCopy(followupto, HTStrip(strchr(full_line,':')+1));
d1128 5
a1132 4
		    char * msgid = HTStrip(full_line+11);
		    if (msgid[0] == '<' && msgid[strlen(msgid)-1] == '>') {
			msgid[strlen(msgid)-1] = '\0';	/* Chop > */
			msgid++;			/* Chop < */
d1136 4
a1139 4
		} /* end if match */
		p = line;			/* Restart at beginning */
	    } /* if end of line */
	} /* Loop over characters */
d1152 2
a1153 2
	**  Put in the owner as a link rel.
	*/
d1156 1
d1278 3
a1280 3
	    **	"Followup-To: poster" has special meaning.
	    **  Don't use it to construct a newsreply link. -kw
	    */
d1300 3
a1302 4
	    **	We have permission to POST to this host,
	    **	so add a link for posting followups for
	    **	this article. - FM
	    */
d1304 1
a1304 1
		StrAllocCopy(href,"snewsreply://");
d1306 1
a1306 1
		StrAllocCopy(href,"newsreply://");
d1318 1
d1365 1
a1365 1
	 *  No tags, and never do a PUTC. - kw
d1370 3
a1372 3
	**  Read in the HEAD and BODY of the Article
	**  as XMP formatted text. - FM
	*/
d1377 2
a1378 3
	**  Read in the BODY of the Article
	**  as PRE formatted text. - FM
	*/
d1386 1
d1391 3
a1393 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1396 1
a1396 1
		return(HT_INTERRUPTED);
d1399 1
a1399 1
	    return(HT_LOADED);	/* End of file on response */
d1401 2
a1402 2
	if (((char)ich == LF) || (p == &line[LINE_LENGTH])) {
	    *p++ = '\0';			/* Terminate the string */
d1404 1
a1404 1
#ifdef NEWS_DEBUG	/* 1997/11/09 (Sun) 15:56:11 */
d1409 2
a1410 2
		**  End of article?
		*/
d1414 1
a1414 1
		} else {			/* Line starts with dot */
d1418 1
a1418 1
			PUTS(&line[1]); /* Ignore first dot */
d1426 2
a1427 2
		    **	All lines are passed as unmodified source. - FM
		    */
d1431 10
a1440 11
		    **	Normal lines are scanned for buried references
		    **	to other articles.  Unfortunately, it could pick
		    **	up mail addresses as well!  It also can corrupt
		    **	uuencoded messages!  So we don't do this when
		    **	fetching articles as WWW_SOURCE or when downloading
		    **	(diagnostic is TRUE) or if the client has set
		    **	scan_for_buried_news_references to FALSE.
		    **	Otherwise, we convert all "<...@@...>" strings
		    **	preceded by "rticle " to "news:...@@..." links,
		    **	and any strings that look like URLs to links. - FM
		    */
d1445 1
a1445 1
			char *q  = strrchr(p2,'>');
d1447 2
a1448 1
			if (q && at && at<q) {
d1450 2
a1451 1
			    q[1] = 0;		/* chop up */
d1471 1
a1471 1
				    PUTC (*l++);
d1481 1
a1481 1
			    *p2 = '<';		/* again */
d1483 2
a1484 2
			    start_anchor(p2+1);
			    *q = '>';		/* again */
d1487 1
a1487 1
			    q[1] = c;		/* again */
d1490 1
a1490 1
			    break;		/* line has unmatched <> */
d1493 1
a1493 1
		    while (*l) {		/* Last bit of the line */
d1510 1
a1510 1
			    PUTC (*l++);
d1520 5
a1524 5
		} /* if diagnostic or not scan_for_buried_news_references */
	    } /* if not dot */
	    p = line;				/* Restart at beginning */
	} /* if end of line */
    } /* Loop over characters */
d1527 1
a1527 1
	return(HT_LOADED);
d1534 1
a1534 1
    return(HT_LOADED);
d1538 7
a1544 7
**	----------------------------
**
**  Note the termination condition of a single dot on a line by itself.
**  RFC 977 specifies that the line "folding" of RFC850 is not used,
**  so we do not handle it here.
*/
PRIVATE int read_list ARGS1(char *, arg)
d1546 1
a1546 1
    char line[LINE_LENGTH+1];
d1558 2
a1559 2
    **	Support head or tail matches for groups to list. - FM
    */
d1563 2
a1564 2
	    StrAllocCopy(pattern, (arg+1));
	} else if (arg[strlen(arg)-1] == '*') {
d1567 1
a1567 1
	    pattern[strlen(pattern)-1] = '\0';
d1570 1
a1570 1
	   len = strlen(pattern);
d1576 4
a1579 5
    **	Read the server's reply.
    **
    **	The lines are scanned for newsgroup
    **	names and descriptions.
    */
d1589 1
a1589 1
    PUTS( "Newsgroups");
d1598 1
d1602 3
a1604 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d1607 1
a1607 1
		return(HT_INTERRUPTED);
d1611 1
a1611 1
	    return(HT_LOADED);	/* End of file on response */
d1629 1
a1629 1
		skip_this_line = YES; /* ...and ignore until LF */
d1634 1
a1634 1
		skip_this_line = YES; /* ignore whole line */
d1637 1
a1637 1
		skip_rest_of_line = YES; /* skip until ch == LF found */
d1644 1
a1644 1
	    *p = '\0';			/* Terminate the string */
d1648 2
a1649 2
		**  End of article?
		*/
d1653 1
a1653 1
		} else {			/* Line starts with dot */
d1659 1
a1659 1
		p = line;			/* Restart at beginning */
d1663 2
a1664 2
		**  Normal lines are scanned for references to newsgroups.
		*/
d1668 1
a1668 2
		for (; line[i] != '\0' && !WHITE(line[i]); i++)
		    ;  /* null body */
d1684 1
a1684 1
		    PUTS(&line[i+1]); /* put description */
d1698 4
a1701 4
	    } /* if not dot */
	    p = line;			/* Restart at beginning */
	} /* if end of line */
    } /* Loop over characters */
d1704 1
d1714 1
a1714 1
    return(HT_LOADED);
d1718 9
a1726 10
**	-------------------
**
**  Unfortunately, we have to ask for each article one by one if we
**  want more than one field.
**
*/
PRIVATE int read_group ARGS3(
	CONST char *,	groupName,
	int,		first_required,
	int,		last_required)
d1728 1
a1728 1
    char line[LINE_LENGTH+1];
d1736 1
a1736 1
    char buffer[LINE_LENGTH+1];
d1738 2
a1739 2
    char *reference = NULL;		/* Href for article */
    int art;				/* Article number WITHIN GROUP */
a1740 1
					/* count is only an upper limit */
d1754 1
a1754 1
		status, count, first, last, first_required, last_required));
a1758 1

d1763 1
a1763 1
	first_required = first;		/* clip */
d1772 2
a1773 2
    if (last_required-first_required+1 > HTNewsMaxChunk) { /* Trim this block */
	first_required = last_required-HTNewsChunkSize+1;
d1776 1
a1776 1
		first_required, last_required));
d1779 2
a1780 2
    **	Set window title.
    */
d1782 1
a1782 1
		    groupName, first_required, last_required);
d1790 2
a1791 2
    **	Link to earlier articles.
    */
d1793 3
a1795 2
	int before;			/* Start of one before */
	if (first_required-HTNewsMaxChunk <= first)
d1798 1
a1798 1
	    before = first_required-HTNewsChunkSize;
d1800 1
a1800 1
				      before, first_required-1);
d1815 1
a1815 1
    if (count > FAST_THRESHOLD)  {
d1817 2
a1818 2
 gettext("\nThere are about %d articles currently available in %s, IDs as follows:\n\n"),
		count, groupName);
d1827 1
d1832 3
a1834 2
			CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
				    s));
d1837 1
a1837 1
			return(HT_INTERRUPTED);
d1840 1
a1840 1
		    return(HT_LOADED);	/* End of file on response */
d1842 2
a1843 2
		if (((char)ich == '\n') || (p == &line[LINE_LENGTH])) {
		    *p = '\0';		/* Terminate the string */
d1847 2
a1848 2
			**  End of article?
			*/
d1852 2
a1853 2
			} else {		/* Line starts with dot */
				/* Ignore strange line */
d1857 4
a1860 4
			**  Normal lines are scanned for
			**  references to articles.
			*/
			char * space = strchr(line, ' ');
d1863 4
a1866 4
		    } /* if not dot */
		    p = line;			/* Restart at beginning */
		} /* if end of line */
	    } /* Loop over characters */
d1869 1
a1869 1
	} /* Good status */
d1874 2
a1875 2
    **	Read newsgroup using individual fields.
    */
d1893 7
a1899 7
	    **	With this code we try to keep the server running flat out
	    **	by queuing just one extra command ahead of time.
	    **	We assume (1) that the server won't abort if it gets input
	    **	during output, and (2) that TCP buffering is enough for the
	    **	two commands.  Both these assumptions seem very reasonable.
	    **	However, we HAVE had a hangup with a loaded server.
	    */
d1901 1
a1901 1
		if (art == last_required) {		/* Only one */
d1903 1
a1903 1
				    art, CR, LF);
d1905 1
a1905 1
		} else {				/* First of many */
d1907 2
a1908 2
				    art, CR, LF, art+1, CR, LF);
			status = response(buffer);
d1910 1
a1910 1
	    } else if (art == last_required) {		/* Last of many */
d1912 2
a1913 2
	    } else {					/* Middle of many */
		sprintf(buffer, "HEAD %d%c%c", art+1, CR, LF);
d1916 1
a1916 1
#else	/* Not OVERLAP: */
d1919 1
a1919 1
#endif	/* OVERLAP */
d1921 8
a1928 9
	    **	Check for a good response (221) for the HEAD request,
	    **	and if so, parse it.  Otherwise, indicate the error
	    **	so that the number of listings corresponds to what's
	    **	claimed for the range, and if we are listing numbers
	    **	via an ordered list, they stay in synchrony with the
	    **	article numbers. - FM
	    */
	    if (status == 221) {	/* Head follows - parse it:*/
		p = line;				/* Write pointer */
d1930 1
a1930 1
		while( !done ) {
d1932 1
d1937 3
a1939 2
			    CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
					s));
d1942 1
a1942 1
			    return(HT_INTERRUPTED);
d1945 1
a1945 1
			return(HT_LOADED);	/* End of file on response */
d1947 1
a1947 1
		    if (((char)ich == LF) ||
d1950 2
a1951 2
			*--p = '\0';		/* Terminate  & chop LF*/
			p = line;		/* Restart at beginning */
d1953 1
a1953 1
			switch(line[0]) {
d1957 2
a1958 2
			    **	End of article?
			    */
d1973 3
a1975 2
				char * addr = HTStrip(line+11) +1; /* Chop < */
				addr[strlen(addr)-1] = '\0';	   /* Chop > */
d1983 2
a1984 1
				char * p2;
d1988 2
a1989 2
				if (*p2==LF)
				    *p2 = '\0'; /* Chop off newline */
d1997 1
a1997 1
					     HTStrip(strchr(line,':')+1));
d2001 3
a2003 3
			} /* end switch on first character */
		    } /* if end of line */
		} /* Loop over characters */
d2018 3
a2020 3
		     PUTS(" - ");
		     if (LYListNewsDates)
			 START(HTML_I);
d2022 2
a2023 2
		     if (LYListNewsDates)
			 END(HTML_I);
d2034 1
a2034 1
		    sprintf(buffer, " [%.*s]", (int)(sizeof(buffer) - 4), date);
d2040 2
a2041 2
		**  Indicate progress!	 @@@@@@@@@@@@
		*/
d2044 3
a2046 2
		CTRACE((tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s));
d2049 1
a2049 1
		return(HT_INTERRUPTED);
d2052 2
a2053 2
		**  Use the response text on error. - FM
		*/
d2066 2
a2067 2
	    } /* Handle response to HEAD request */
	} /* Loop over article */
d2070 1
a2070 1
    } /* If read headers */
d2079 2
a2080 2
    **	Link to later articles.
    */
d2082 3
a2084 2
	int after;			/* End of article after */
	after = last_required+HTNewsChunkSize;
d2086 1
a2086 1
	    HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName); /* original group */
d2089 1
a2089 1
					  last_required+1, after);
d2098 1
a2098 1
add_post:
d2101 3
a2103 4
	**  We have permission to POST to this host,
	**  so add a link for posting messages to
	**  this newsgroup. - FM
	*/
d2109 1
a2109 1
	    StrAllocCopy(href,"snewspost://");
d2111 1
a2111 1
	    StrAllocCopy(href,"newspost://");
d2114 1
a2114 1
	StrAllocCat(href,groupName);
d2124 1
a2124 1
    return(HT_LOADED);
d2128 6
a2133 7
**	=============
*/
PRIVATE int HTLoadNews ARGS4(
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		stream)
d2135 2
a2136 2
    char command[262];			/* The whole command */
    char proxycmd[260];			/* The proxy command */
d2138 2
a2139 2
    int status;				/* tcp return */
    int retries;			/* A count of how hard we have tried */
d2154 1
d2169 1
a2169 1
	return -1;	/* FAIL */
d2173 1
a2173 1
    command[sizeof(command)-1] = '\0';
d2175 1
a2175 1
    proxycmd[sizeof(proxycmd)-1] = '\0';
d2178 1
a2178 1
	CONST char * p1 = arg;
d2181 10
a2190 9
	**  We will ask for the document, omitting the host name & anchor.
	**
	**  Syntax of address is
	**	xxx@@yyy			Article
	**	<xxx@@yyy>		Same article
	**	xxxxx			News group (no "@@")
	**	group/n1-n2		Articles n1 to n2 in group
	*/
	normal_url = (BOOL) (!strncmp(arg, STR_NEWS_URL, LEN_NEWS_URL) || !strncmp(arg, "nntp:", 5));
d2193 1
a2193 1
			 strstr(arg, "snewsreply:") != NULL);
d2195 1
a2195 1
			strstr(arg, "newspost:") != NULL);
d2197 2
a2198 2
			  post_wanted) &&
			strstr(arg, "newsreply:") != NULL);
d2200 8
a2207 6
			  post_wanted || reply_wanted) &&
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') == NULL));
	list_wanted  = (BOOL) ((!(spost_wanted || sreply_wanted ||
			  post_wanted || reply_wanted ||
			  group_wanted) &&
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') != NULL));
d2218 2
a2219 2
	    **	Make sure we have a non-zero path for the newsgroup(s). - FM
	    */
d2227 1
a2227 1
		return(HT_NO_DATA);
d2244 7
a2250 7
			     (post_wanted ?
			       "newspost" :
			    (reply_wanted ?
			       "newreply" :
			    (spost_wanted ?
			      "snewspost" : "snewsreply"))),
			    (int) sizeof(command) - 15, NewsHost);
d2253 4
a2256 4
	    **	If the SSL daemon is being used as a proxy,
	    **	reset p1 to the start of the proxied URL
	    **	rather than to the start of the newsgroup(s). - FM
	    */
d2262 7
a2268 6
	/* p1 = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION); */
	/*
	**  Don't use HTParse because news: access doesn't follow traditional
	**  rules.  For instance, if the article reference contains a '#',
	**  the rest of it is lost -- JFG 10/7/92, from a bug report
	*/
d2302 1
a2302 2
	}
	else if (!strncasecomp(arg, STR_SNEWS_URL, 6)) {
d2340 1
a2340 2
	}
	else if (!strncasecomp (arg, "news:/", 6)) {
d2371 1
a2371 1
	    p1 = (arg + 5);  /* Skip "news:" prefix */
d2386 4
a2389 5
	**  Set up any proxy for snews URLs that returns NNTP
	**  responses for Lynx to convert to HTML, instead of
	**  doing the conversion itself, and for handling posts
	**  or followups.  - TZ & FM
	*/
d2400 1
a2400 1
	    command[sizeof(command)-2] = '\0';
d2403 1
a2403 1
		    (int) sizeof(proxycmd)-9, command,
d2406 1
a2406 1
			(int)(strlen(proxycmd) - 4), proxycmd));
d2412 2
a2413 2
		**  Reset p1 so that it points to the newsgroup(s).
		*/
d2421 3
a2423 3
		**  Reset p1 so that it points to the newsgroup
		**  (or a wildcard), or the article.
		*/
d2435 2
a2436 2
	**  Set up command for a post, listing, or article request. - FM
	*/
d2448 2
a2449 1
	    char * slash = strchr(p1, '/');
d2462 3
a2464 3
		(void)sscanf(slash+1, "%d-%d", &first, &last);
		if ((first > 0) && (isdigit(UCH(*(slash+1)))) &&
		    (strchr(slash+1, '-') == NULL || first == last)) {
d2466 6
a2471 7
		    **	We got a number greater than 0, which will be
		    **	loaded as first, and either no range or the
		    **	range computes to zero, so make last negative,
		    **	as a flag to select the group and then fetch
		    **	an article by number (first) instead of by
		    **	messageID. - FM
		    */
d2485 3
a2487 2
	    int add_open=(strchr(p1, '<') == 0);
	    int add_close=(strchr(p1, '>') == 0);
d2502 2
a2503 1
	    char * p = command + strlen(command);
d2505 2
a2506 2
	    **	Terminate command with CRLF, as in RFC 977.
	    */
d2512 1
a2512 1
    } /* scope of p1 */
d2519 1
a2519 1
	return NO;			/* Ignore if no name */
d2528 1
a2528 1
	    for (cp = command + 5; ; cp++)
d2546 2
a2547 2
	    return(HT_NOT_LOADED);
	}	/* Copy routine entry points */
d2550 3
a2552 3
    /*
    **	Make a hypertext object with an anchor list.
    */
d2560 2
a2561 2
    **	Now, let's get a stream setup up from the NewsHost.
    */
d2566 1
d2568 1
a2568 1
		SnipIn (url, "lose://%.*s/", 9, NewsHost);
d2570 1
a2570 1
		SnipIn (url, "%.*s", 1, ProxyHREF);
d2572 1
a2572 1
		SnipIn (url, "%.*s", 1, NewsHREF);
d2583 1
a2583 1
		status = HTDoConnect (url, "NNTPS", SNEWS_PORT, &s);
d2585 1
a2585 1
		status = HTDoConnect (url, "NNTP", NEWS_PORT, &s);
d2587 1
a2587 1
	    status = HTDoConnect (url, "NNTP", NEWS_PORT, &s);
d2592 4
a2595 3
		**  Interrupt cleanly.
		*/
		CTRACE((tfp, "HTNews: Interrupted on connect; recovering cleanly.\n"));
d2641 1
a2641 1
			    NewsHost));
d2644 2
a2645 3
		**  If this is an snews url,
		**  then do the SSL stuff here
		*/
d2657 4
a2660 1
			CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
d2662 3
a2664 2
			while((SSLerror = ERR_get_error()) != 0) {
			    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
d2666 1
a2666 2
			HTAlert(
			    "Unable to make secure connection to remote host.");
d2671 1
a2671 1
			    (*targetClass._abort)(target, NULL);
d2679 1
a2679 2
			    while (remove(postfile) == 0)
			    ; /* loop through all versions */
d2687 5
a2691 1
		    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",SSL_get_cipher_bits(Handle,NULL),SSL_get_cipher_version(Handle),SSL_get_cipher(Handle));
d2695 1
a2695 1
		HTInitInput(s);		/* set up buffering */
d2698 3
a2700 2
		    CTRACE((tfp, "HTNews: Proxy command returned status '%d'.\n",
				status));
d2703 7
a2709 18
			NEWS_NETCLOSE(s);
			s = -1;
			if (status == HT_INTERRUPTED) {
			    _HTProgress(CONNECTION_INTERRUPTED);
			    if (!(post_wanted || reply_wanted ||
				  spost_wanted || sreply_wanted)) {
				ABORT_TARGET;
			    }
			    FREE(NewsHost);
			    FREE(NewsHREF);
			    FREE(ProxyHost);
			    FREE(ProxyHREF);
			    FREE(ListArg);
			    if (postfile) {
				HTSYS_remove(postfile);
				FREE(postfile);
			    }
			    return(HT_NOT_LOADED);
d2711 2
a2712 2
			if (retries < 1)
			    continue;
d2716 3
a2718 4
			FREE(postfile);
			if (!(post_wanted || reply_wanted ||
			      spost_wanted || sreply_wanted)) {
			    ABORT_TARGET;
d2720 22
a2741 10
			if (response_text[0]) {
			    HTSprintf0(&dbuf,
				gettext("Can't read news info.  News host %.20s responded: %.200s"),
				NewsHost, response_text);
			} else {
			    HTSprintf0(&dbuf,
				gettext("Can't read news info, empty response from host %s"),
				NewsHost);
			}
			return HTLoadError(stream, 500, dbuf);
d2761 1
a2761 1
			return(HT_NOT_LOADED);
d2765 2
a2766 2
	} /* If needed opening */

d2768 1
a2768 1
	     spost_wanted || sreply_wanted) {
d2782 1
a2782 1
		return(HT_NOT_LOADED);
d2786 1
a2786 1
				(BOOLEAN)(reply_wanted || sreply_wanted));
d2797 1
a2797 1
		return(HT_NOT_LOADED);
d2801 6
a2806 6
	    **	Ensure reader mode, but don't bother checking the
	    **	status for anything but HT_INTERRUPTED or a 480
	    **	Authorization request, because if the reader mode
	    **	command is not needed, the server probably returned
	    **	a 500, which is irrelevant at this point. - FM
	    */
d2816 1
d2833 1
a2833 1
Send_NNTP_command:
d2852 6
a2857 7
	 *  For some well known error responses which are expected
	 *  to occur in normal use, break from the loop without retrying
	 *  and without closing the connection.  It is unlikely that
	 *  these are leftovers from a timed-out connection (but we do
	 *  some checks to see whether the response corresponds to the
	 *  last command), or that they will give anything else when
	 *  automatically retried.  - kw
d2867 2
a2868 2
	    !strncmp(command, "ARTICLE <", 9) &&
	    !strcasecomp(response_text + 3, " No such article")) {
d2873 1
a2873 1
	if ((status/100) != 2 &&
d2888 3
a2890 4
	    **	Message might be a leftover "Timeout-disconnected",
	    **	so try again if the retries maximum has not been
	    **	reached.
	    */
d2895 2
a2896 2
	**  Post or load a group, article, etc
	*/
d2899 1
d2901 1
a2901 1
	     *	Some servers return 480 for a failed XGTITLE. - FM
d2910 2
a2911 2
	    **	Handle Authorization. - FM
	    */
d2926 2
a2927 2
	    **	Handle posting of an article. - FM
	    */
d2940 2
a2941 2
	    **	List available newsgroups. - FM
	    */
d2946 2
a2947 2
	    **	List articles in a news group. - FM
	    */
d2950 6
a2955 7
		**  We got one article number rather than a range
		**  following the slash which followed the group
		**  name, or the range was zero, so now that we
		**  have selected that group, load ARTICLE and the
		**  the number (first) as the command and go back
		**  to send it and check the response. - FM
		*/
d2967 2
a2968 2
	    **	Get an article from a news group. - FM
	    */
d2996 1
a2996 1
    } /* Retry loop */
d3000 1
a3000 1
    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.", NULL,NULL,NULL, arg);
d3023 14
a3036 15
**  This function clears all authorization information by
**  invoking the free_NNTP_AuthInfo() function, which normally
**  is invoked at exit.  It allows a browser command to do
**  this at any time, for example, if the user is leaving
**  the terminal for a period of time, but does not want
**  to end the current session.  - FM
*/
PUBLIC void HTClearNNTPAuthInfo NOARGS
{
    /*
    **	Need code to check cached documents and do
    **	something to ensure that any protected
    **	documents no longer can be accessed without
    **	a new retrieval. - FM
    */
d3039 2
a3040 2
    **	Now free all of the authorization info. - FM
    */
d3045 1
a3045 1
PRIVATE char HTNewsGetCharacter NOARGS
d3050 1
a3050 1
	return HTGetSSLCharacter((void *)Handle);
d3053 5
a3057 6
PUBLIC int HTNewsProxyConnect ARGS5 (
    int,		sock,
    CONST char *,	url,
    HTParentAnchor *,	anAnchor,
    HTFormat,		format_out,
    HTStream *,		sink)
d3060 1
a3060 1
    CONST char * arg = url;
d3071 1
d3073 3
a3075 1
	CTRACE((tfp,"HTNews: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",url, status));
d3077 2
a3078 2
	while((SSLerror = ERR_get_error()) != 0) {
	    CTRACE((tfp,"HTNews: SSL: %s\n",ERR_error_string(SSLerror,NULL)));
d3085 2
a3086 2
    sprintf(SSLprogress,"Secure %d-bit %s (%s) NNTP connection",
	    SSL_get_cipher_bits(Handle,NULL),
d3098 1
a3098 1
GLOBALDEF (HTProtocol,HTNews,_HTNEWS_C_1_INIT);
d3100 1
a3100 1
GLOBALDEF (HTProtocol,HTNNTP,_HTNEWS_C_2_INIT);
d3102 1
a3102 1
GLOBALDEF (HTProtocol,HTNewsPost,_HTNEWS_C_3_INIT);
d3104 1
a3104 1
GLOBALDEF (HTProtocol,HTNewsReply,_HTNEWS_C_4_INIT);
d3106 1
a3106 1
GLOBALDEF (HTProtocol,HTSNews,_HTNEWS_C_5_INIT);
d3108 1
a3108 1
GLOBALDEF (HTProtocol,HTSNewsPost,_HTNEWS_C_6_INIT);
d3110 1
a3110 1
GLOBALDEF (HTProtocol,HTSNewsReply,_HTNEWS_C_7_INIT);
d3112 14
a3125 7
GLOBALDEF PUBLIC HTProtocol HTNews = { "news", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTNNTP = { "nntp", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTNewsPost = { "newspost", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTNewsReply = { "newsreply", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTSNews = { "snews", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTSNewsPost = { "snewspost", HTLoadNews, NULL };
GLOBALDEF PUBLIC HTProtocol HTSNewsReply = { "snewsreply", HTLoadNews, NULL };
@


1.6
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@a942 1
#ifdef SH_EX	/* for MIME */
d964 1
a964 1
static char *decode_mime(char *str)
d966 1
a966 6
    char temp[LINE_LENGTH];	/* FIXME: what determines the actual size? */
    char *p, *q;

    if (str == NULL)
	return "";

d968 1
a968 15
	return str;

    LYstrncpy(temp, str, sizeof(temp) - 1);
    q = temp;
    while ((p = strchr(q, '=')) != 0) {
	if (p[1] == '?') {
	    HTmmdecode(p, p);
	    q = p + 2;
	} else {
	    q = p + 1;
	}
    }
#ifdef NEWS_DEBUG
    printf("new=[");
    debug_print(temp);
d970 2
a971 11
    HTrjis(temp, temp);
    strcpy(str, temp);

    return str;
}
#else /* !SH_EX */
static char *decode_mime ARGS1(char *, str)
{
    HTmmdecode(str, str);
    HTrjis(str, str);
    return str;
a972 2
#endif

d1059 1
a1059 1
		    decode_mime(subject);
d1066 1
a1066 1
		    decode_mime(organization);
d1070 1
a1070 1
		    decode_mime(from);
d1074 1
a1074 1
		    decode_mime(replyto);
d1683 2
a1684 2
    char author[LINE_LENGTH+1];
    char subject[LINE_LENGTH+1];
a1696 1
    author[0] = '\0';
d1917 2
a1918 2
				LYstrncpy(subject, line+9, sizeof(subject)-1);/* Save subject */
				decode_mime(subject);
d1935 2
a1936 4
				LYstrncpy(author,
					author_name(strchr(line,':')+1),
					sizeof(author)-1);
				decode_mime(author);
d1957 2
a1958 5
#ifdef SH_EX	/* for MIME */
		HTSprintf0(&temp, "\"%s\"", decode_mime(subject));
#else
		HTSprintf0(&temp, "\"%s\"", subject);
#endif
d1967 1
a1967 1
		if (author[0] != '\0') {
d1971 1
a1971 5
#ifdef SH_EX	/* for MIME */
		     PUTS(decode_mime(author));
#else
		     PUTS(author);
#endif
d1974 1
a1974 1
		     author[0] = '\0';
d2017 2
@


1.5
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d20 1
d55 1
d64 2
a65 1
#define SnipIn(d,fmt,len,s) sprintf(d, fmt, (int)sizeof(d)-len, s)
a77 6
extern BOOLEAN scan_for_buried_news_references;
extern BOOLEAN LYListNewsNumbers;
extern BOOLEAN LYListNewsDates;
extern int interrupted_in_htgetcharacter;
extern BOOL keep_mime_headers;	 /* Include mime headers and force raw text */
extern BOOL using_proxy;	/* Are we using an NNTP proxy? */
d203 2
a204 2
    if (getenv("NNTPSERVER")) {
	StrAllocCopy(HTNewsHost, (char *)getenv("NNTPSERVER"));
d848 1
a848 1
    if ((fd = fopen((postfile ? postfile : ""), TXT_R)) == NULL) {
d944 1
a944 2
#define NEWS_DEBUG 0
#if NEWS_DEBUG
d986 1
a986 1
#if NEWS_DEBUG
d1145 1
a1145 1
	    StrAllocCopy(href,"mailto:");
d1291 1
a1291 1
	    if (!strncasecomp(NewsHREF, "snews:", 6))
d1390 1
a1390 1
#if NEWS_DEBUG	/* 1997/11/09 (Sun) 15:56:11 */
d1440 1
a1440 1
				if (strncmp(l, "news:", 5) &&
d1453 1
a1453 1
				    strncmp(l, "mailto:", 7) &&
d1479 1
a1479 1
			if (strncmp(l, "news:", 5) &&
d1492 1
a1492 1
			    strncmp(l, "mailto:", 7) &&
d2096 1
a2096 1
	if (!strncasecomp(NewsHREF, "snews:", 6))
d2177 1
a2177 1
	normal_url = (BOOL) (!strncmp(arg, "news:", 5) || !strncmp(arg, "nntp:", 5));
d2253 1
a2253 1
	} else if (!strncasecomp (arg, "nntp:", 5)) {
d2284 1
a2284 1
	    SnipIn(command, "nntp://%.*s/", 9, NewsHost);
d2287 1
a2287 1
	else if (!strncasecomp(arg, "snews:", 6)) {
d2316 1
a2316 1
	    StrAllocCopy(NewsHost, cp);
d2319 1
a2319 1
	    sprintf(command, "snews://%.250s/", NewsHost);
d2368 1
a2368 1
	    StrAllocCopy(NewsHREF, "news:");
d2377 1
a2377 1
	if (!strncasecomp(p1, "snews:", 6) ||
d2382 1
a2382 1
		SnipIn(command, "snews://%.*s", 10, cp);
d2385 1
a2385 1
		SnipIn(command, "snews://%.*s", 10, NewsHost);
d2551 1
a2551 1
	    if (!strcmp(NewsHREF, "news:")) {
d2564 1
a2564 1
		(!strncmp(arg, "snews:", 6) ||
@


1.4
log
@replace an unbounded fscanf with an fgets
suggested by and ok millert@@
@
text
@d19 1
d22 1
a22 3

/* this define should be in HTFont.h :( */
#define HT_NON_BREAK_SPACE ((char)1)   /* For now */
a37 3
#define free_func free__func
#include <openssl/ssl.h>
#undef free_func
a38 1
extern SSL * HTGetSSLHandle NOPARAMS;
a44 1
extern char HTGetSSLCharacter PARAMS((void *handle));
d62 1
d73 1
a73 1
#define LINE_LENGTH 512 		/* Maximum length of line of ARTICLE etc */
a77 1
extern HTCJKlang HTCJK;
d86 2
a87 2
PRIVATE char * NewsHost = NULL; 		/* Current host */
PRIVATE char * NewsHREF = NULL; 		/* Current HREF prefix */
d208 2
a209 2
	CTRACE(tfp, "HTNews: NNTPSERVER defined as `%s'\n",
		    HTNewsHost);
d211 1
a211 1
	FILE* fp = fopen(SERVER_FILE, "r");
d219 2
a220 2
		CTRACE(tfp, "HTNews: File %s defines news host as `%s'\n",
			    SERVER_FILE, HTNewsHost);
d246 1
a246 1
PRIVATE int response ARGS1(CONST char *,command)
d255 1
a255 1
	CTRACE(tfp, "NNTP command to be sent: %s", command);
d270 1
a270 1
	    CTRACE(tfp, "HTNews: Unable to send command. Disconnecting.\n");
d279 1
a279 1
	if (((*p++ = ich) == LF) ||
d282 1
a282 1
	    CTRACE(tfp, "NNTP Response: %s\n", response_text);
d290 2
a291 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d293 2
a294 2
		CTRACE(tfp, "HTNews: EOF on read, closing socket %d\n",
			    s);
d332 1
a332 1
	char *, 	host)
d370 1
a370 1
    buffer[511] = '\0';
d375 1
a375 4
	    if ((msg = (char *)calloc(1, (strlen(host) + 30))) == NULL) {
		outofmem(__FILE__, "HTHandleAuthInfo");
	    }
	    sprintf(msg, gettext("Username for news host '%s':"), host);
d383 2
a384 1
	sprintf(buffer, "AUTHINFO USER %.*s%c%c", 495, UserName, CR, LF);
d413 1
a413 2
		if ((auth =
		    (NNTPAuth *)calloc(1, sizeof(NNTPAuth))) != NULL) {
d456 1
a456 4
		if ((msg = (char *)calloc(1, (strlen(host) + 30))) == NULL) {
		    outofmem(__FILE__, "HTHandleAuthInfo");
		}
		sprintf(msg, gettext("Password for news host '%s':"), host);
d464 2
a465 1
	    sprintf(buffer, "AUTHINFO PASS %.*s%c%c", 495, PassWord, CR, LF);
d520 1
a520 2
		    if ((auth =
			(NNTPAuth *)calloc(1, sizeof(NNTPAuth))) != NULL) {
d573 1
a573 1
    CTRACE(tfp,"Trying to find name in: %s\n",name);
d575 1
a575 1
    if ((p = strchr(name, '(')) && (e = strchr(name, ')'))) {
d582 4
a585 3
    if ((p = strchr(name, '<')) && (e = strchr(name, '>'))) {
	if (e > p) {
	    strcpy(p, e+1);		/* Remove <...> */
d610 1
a610 1
    CTRACE(tfp,"Trying to find address in: %s\n",address);
d612 2
a613 2
    if ((p = strchr(address, '<'))) {
	if ((e = strchr(p, '>')) && (at = strchr(p, '@@'))) {
d621 2
a622 2
    if ((p = strchr(address, '(')) &&
	(e = strchr(address, ')')) && (at = strchr(address, '@@'))) {
d629 1
a629 1
    if ((at = strchr(address, '@@')) && at > address) {
d632 1
a632 1
	while (p > address && !isspace((unsigned char)*p))
d634 1
a634 1
	while (*e && !isspace((unsigned char)*e))
d644 1
a644 1
    while (isspace((unsigned char)*p))
d647 1
a647 1
    while (!isspace((unsigned char)*e) && *e != '\0')
d660 2
a661 1
    CONST char* 	value[HTML_A_ATTRIBUTES];
d663 4
a666 8
    {
	int i;
	for(i=0; i < HTML_A_ATTRIBUTES; i++)
	    present[i] = (i == HTML_A_HREF);
    }
    ((CONST char **)value)[HTML_A_HREF] = href;
    (*targetClass.start_element)(target, HTML_A , present,
				 (CONST char **)value, -1, 0);
d675 2
a676 1
    CONST char* 	value[HTML_LINK_ATTRIBUTES];
d678 5
a682 9
    {
	int i;
	for(i=0; i < HTML_LINK_ATTRIBUTES; i++)
	    present[i] = (i == HTML_LINK_HREF || i == HTML_LINK_REV);
    }
    ((CONST char **)value)[HTML_LINK_HREF] = href;
    ((CONST char **)value)[HTML_LINK_REV]  = rev;
    (*targetClass.start_element)(target, HTML_LINK, present,
				 (CONST char **)value, -1, 0);
d691 1
a691 1
    CONST char* 	value[HTML_OL_ATTRIBUTES];
d696 1
a696 1
	present[i] = (i == HTML_OL_SEQNUM || i == HTML_OL_START);
d698 3
a700 4
    ((CONST char **)value)[HTML_OL_SEQNUM] = SeqNum;
    ((CONST char **)value)[HTML_OL_START]  = SeqNum;
    (*targetClass.start_element)(target, HTML_OL , present,
				 (CONST char **)value, -1, 0);
d716 2
d719 9
a727 6
    {
	CONST char * p;
	strcpy(href, NewsHREF);
	for (p = addr; *p && (*p != '>') && !WHITE(*p) && (*p!=','); p++)
	    ;
	strncat(href, addr, p-addr);	/* Make complete hypertext reference */
d730 1
a730 1
    start_anchor(href);
d733 3
d782 1
a782 1
    CTRACE(tfp, "HTNews: EOF on read, closing socket %d\n", s);
d784 6
a789 2
    PUTS("Network Error: connection lost");
    PUTC('\n');
d794 1
a794 1
**  Determine if a line is a valid header line. 		valid_header
d798 1
a798 1
	char *, 	line)
d815 1
a815 1
    if (isalpha(line[0]) && colon && space == colon + 1)
d835 1
a835 1
	char *, 	postfile)
d851 1
a851 1
    if ((fd = fopen((postfile ? postfile : ""), "r")) == NULL) {
d862 1
a862 1
    while (fgets(line, sizeof(line), fd) != NULL) {
d890 1
a890 5
		    if (blen < 475) {
			strcat(buf, "From: anonymous@@nowhere.you.know");
			strcat(buf, crlf);
			blen += 34;
		    } else {
d892 1
a892 3
			sprintf(buf,
				"From: anonymous@@nowhere.you.know%s", crlf);
			blen = 34;
d894 3
d910 1
a910 4
	if ((blen + llen) < 511) {
	    strcat(buf, line);
	    blen += llen;
	} else {
d912 1
a912 2
	    strcpy(buf, line);
	    blen = llen;
d914 2
d923 1
a923 9
    if (blen < 508) {
	strcat(buf, ".");
	strcat(buf, crlf);
	blen += 3;
	NEWS_NETWRITE(s, buf, blen);
    } else {
	NEWS_NETWRITE(s, buf, blen);
	sprintf(buf, ".%s", crlf);
	blen = 3;
d925 1
d927 5
d946 63
d1048 1
a1048 1
	    *p++ = ich;
d1052 2
a1053 2
		    CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
				s);
d1058 1
a1058 1
		abort_socket(); 	/* End of file, close socket */
d1063 1
a1063 1
		CTRACE(tfp, "H %s\n", line);
d1085 1
a1085 1
		    if ((unsigned char)full_line[1] < ' ') {
d1089 1
a1089 1
		} else if ((unsigned char)full_line[0] < ' ') {
d1094 1
a1094 8
		    if (HTCJK == JAPANESE) {
			HTmmdecode(subject, subject);
			HTrjis(subject, subject);
		    }
		    if (*subject) {
			HTAnchor_setSubject(thisanchor, subject);
		    }

d1101 1
a1101 4
		    if (HTCJK == JAPANESE) {
			HTmmdecode(organization, organization);
			HTrjis(organization, organization);
		    }
d1105 1
a1105 4
		    if (HTCJK == JAPANESE) {
			HTmmdecode(from, from);
			HTrjis(from, from);
		    }
d1109 1
a1109 4
		    if (HTCJK == JAPANESE) {
			HTmmdecode(replyto, replyto);
			HTrjis(replyto, replyto);
		    }
d1124 1
a1124 1
			msgid++; 			/* Chop < */
d1147 1
a1147 1
	    char *temp=NULL;
d1356 1
a1356 1
	 *  No tags - kw
d1365 1
d1372 1
a1373 1
    PUTC('\n');
d1378 1
a1378 1
	*p++ = ich;
d1382 2
a1383 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d1393 4
a1396 1
	    CTRACE(tfp, "B %s", line);
d1401 1
a1401 1
		if ((unsigned char)line[1] < ' ') {
d1405 1
a1405 1
		    if (rawtext)
d1407 1
a1407 1
		    else
d1409 1
d1436 2
a1437 2
			char *q  = strchr(p2,'>');
			char *at = strchr(p2, '@@');
d1459 1
a1459 1
				    strncmp(l, "gopher://", 9))
d1461 1
a1461 1
				else {
d1477 1
a1477 1
			    l=q+1;
d1587 1
a1587 1
	char ch = ich;
d1591 2
a1592 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d1611 1
a1611 1
	    CTRACE(tfp, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch);
d1621 1
a1621 1
		CTRACE(tfp, "HTNews..... group name too long, discarding.\n");
d1633 1
a1633 1
	    CTRACE(tfp, "B %s", line);
d1638 1
a1638 1
		if ((unsigned char)line[1] < ' ') {
d1692 1
d1694 2
a1695 2
	sprintf(line, gettext("No matches for: %s"), arg);
	PUTS(line);
d1697 1
d1713 3
a1715 3
  CONST char *,groupName,
  int,first_required,
  int,last_required)
d1725 2
a1726 1
    char buffer[LINE_LENGTH];
d1744 2
a1745 2
    CTRACE(tfp, "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
		status, count, first, last, first_required, last_required);
d1755 1
a1755 1
	first_required = first; 	/* clip */
d1767 2
a1768 2
    CTRACE(tfp, "    Chunk will be (%d-%d)\n",
		first_required, last_required);
d1773 1
a1773 1
    sprintf(buffer, gettext("%s,  Articles %d-%d"),
d1776 2
a1777 1
    PUTS(buffer);
d1792 1
a1792 1
	CTRACE(tfp, "    Block before is %s\n", dbuf);
d1807 1
a1807 1
	sprintf(buffer,
d1810 2
a1811 1
	PUTS(buffer);
d1822 2
a1823 2
			CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
				    s);
d1833 1
a1833 1
		    CTRACE(tfp, "X %s", line);
d1838 1
a1838 1
			if ((unsigned char)line[1] < ' ') {
d1922 1
a1922 1
		    *p++ = ich;
d1926 2
a1927 2
			    CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
					s);
d1932 1
a1932 1
			abort_socket(); 	/* End of file, close socket */
d1940 1
a1940 1
			CTRACE(tfp, "G %s\n", line);
d1947 1
a1947 1
			    done = ((unsigned char)line[1] < ' ');
d1953 2
a1954 5
				strcpy(subject, line+9);/* Save subject */
				if (HTCJK == JAPANESE) {
				    HTmmdecode(subject, subject);
				    HTrjis(subject, subject);
				}
d1971 4
a1974 6
				strcpy(author,
					author_name(strchr(line,':')+1));
				if (HTCJK == JAPANESE) {
				    HTmmdecode(author, author);
				    HTrjis(author, author);
				}
d1995 5
a1999 1
		sprintf(buffer, "\"%s\"", subject);
d2001 1
a2001 1
		    write_anchor(buffer, reference);
d2004 1
a2004 1
		    PUTS(buffer);
d2006 2
d2012 3
d2016 1
d2029 1
a2029 1
		    sprintf(buffer, " [%s]", date);
d2039 2
a2040 2
		CTRACE(tfp, "HTNews: Interrupted on read, closing socket %d\n",
			    s);
d2052 1
a2052 1
		    strcpy(buffer, "Status:");
d2081 1
a2081 1
	CTRACE(tfp, "    Block after is %s\n", dbuf);
d2128 2
a2129 2
    char command[260];			/* The whole command */
    char proxycmd[260]; 		/* The proxy command */
d2131 1
a2131 1
    int status; 			/* tcp return */
d2133 1
d2139 1
a2139 1
    BOOL sreply_wanted; 	/* Flag: followup SSL post was asked for */
d2147 3
d2156 1
a2156 1
    CTRACE(tfp, "HTNews: Looking for %s\n", arg);
d2165 1
a2165 1
    command[259] = '\0';
d2167 1
a2167 1
    proxycmd[259] = '\0';
d2176 1
a2176 1
	**	xxx@@yyy 		Article
d2181 3
a2183 2
	spost_wanted = (strstr(arg, "snewspost:") != NULL);
	sreply_wanted = (!(spost_wanted) &&
d2185 1
a2185 1
	post_wanted = (!(spost_wanted || sreply_wanted) &&
d2187 1
a2187 1
	reply_wanted = (!(spost_wanted || sreply_wanted ||
d2190 1
a2190 1
	group_wanted = (!(spost_wanted || sreply_wanted ||
d2192 2
a2193 2
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') == NULL);
	list_wanted  = (!(spost_wanted || sreply_wanted ||
d2196 1
a2196 1
			strchr(arg, '@@') == NULL) && (strchr(arg, '*') != NULL);
d2232 1
a2232 1
	    sprintf(command, "%s://%.245s/",
d2238 2
a2239 2
			      "snewspost" : "snewsreply"))), NewsHost);
	    StrAllocCopy(NewsHREF, command);
d2288 1
a2288 1
	    sprintf(command, "nntp://%.251s/", NewsHost);
d2358 1
a2358 1
	    sprintf(command, "news://%.251s/", NewsHost);
d2386 1
a2386 1
		sprintf(command, "snews://%.250s", cp);
d2389 1
a2389 1
		sprintf(command, "snews://%.250s", NewsHost);
d2391 1
a2391 1
	    command[258] = '\0';
d2393 5
a2397 3
	    sprintf(proxycmd, "GET %.251s%c%c%c%c", command, CR, LF, CR, LF);
	    CTRACE(tfp, "HTNews: Proxy command is '%.*s'\n",
			(int)(strlen(proxycmd) - 4), proxycmd);
d2412 1
a2412 1
		**  Reset p1 so that it points to the newgroup
d2431 7
a2437 1
	    sprintf(command, "XGTITLE %.*s", 249, p1);
a2439 1
	    strcpy(command, "GROUP ");
d2444 7
a2450 1
		strcpy(groupName, p1);
d2453 1
a2453 1
		if ((first > 0) && (isdigit(*(slash+1))) &&
d2466 7
a2472 1
		strcpy(groupName, p1);
d2474 1
a2474 1
	    strcat(command, groupName);
d2476 13
a2488 6
	    strcpy(command, "ARTICLE ");
	    if (strchr(p1, '<') == 0)
		strcat(command,"<");
	    strcat(command, p1);
	    if (strchr(p1, '>') == 0)
		strcat(command,">");
d2514 1
a2514 1
	if (head_wanted && !strncmp(command, "ARTICLE_", 8)) {
d2521 1
a2521 1
	rawtext = (head_wanted || keep_mime_headers);
d2556 1
a2556 1
		sprintf (url, "lose://%.251s/", NewsHost);
d2558 1
a2558 1
		sprintf (url, "%.259s", ProxyHREF);
d2560 1
a2560 1
		sprintf (url, "%.259s", NewsHREF);
d2562 1
a2562 1
	    CTRACE (tfp, "News: doing HTDoConnect on '%s'\n", url);
d2582 1
a2582 1
		CTRACE(tfp, "HTNews: Interrupted on connect; recovering cleanly.\n");
d2608 1
a2608 1
		CTRACE(tfp, "HTNews: Unable to connect to news host.\n");
d2627 2
a2628 2
		CTRACE(tfp, "HTNews: Connected to news host %s.\n",
			    NewsHost);
d2640 1
d2644 6
a2649 3
			CTRACE(tfp,
"HTNews: Unable to complete SSL handshake for remote host '%s' (SSLerror = %d)\n",
			       url, status);
d2673 2
a2674 1
		    _HTProgress(SSL_get_cipher(Handle));
d2677 1
a2677 1
		HTInitInput(s); 	/* set up buffering */
d2680 2
a2681 2
		    CTRACE(tfp, "HTNews: Proxy command returned status '%d'.\n",
				status);
d2705 4
d2713 2
a2714 1
			HTSprintf0(&dbuf,
d2717 5
d2766 2
a2767 1
		postfile = LYNewsPost(ListArg, (reply_wanted || sreply_wanted));
d2814 6
d2836 1
a2836 1
	 *  some checks to see whether the response rorresponds to the
d2980 5
a2984 4
    /* HTAlert(gettext("Sorry, could not load requested news.")); */

/*    NXRunAlertPanel(NULL, "Sorry, could not load `%s'.",
	    NULL,NULL,NULL, arg);No -- message earlier wil have covered it */
d3006 1
a3006 1
**  invoking the free_HTAAGlobals() function, which normally
d3031 1
a3031 1
        return HTGetCharacter();
d3033 1
a3033 1
        return HTGetSSLCharacter((void *)Handle);
d3036 6
a3041 4
PUBLIC int HTNewsProxyConnect ARGS5 (int, sock, CONST char *, url, 
				     HTParentAnchor *, anAnchor,
				     HTFormat, format_out,
				     HTStream *, sink)
d3045 1
d3050 1
d3054 7
a3060 4
        channel_s = -1;
	CTRACE(tfp,
"HTTP: Unable to complete SSL handshake for remote host '%s' (SSLerror = %d)\n",
		   url, status);
d3066 5
a3070 1
    _HTProgress(SSL_get_cipher(Handle));
@


1.3
log
@a little bit of glue to call openssl; mark@@moxienet.com
@
text
@a216 1
	char server_name[256];
d219 5
a223 1
	    if (fscanf(fp, "%s", server_name)==1) {
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d38 16
d57 1
d2141 1
d2147 1
d2235 34
d2271 1
d2483 9
d2493 2
d2510 6
d2546 43
d2920 39
@


1.1
log
@Initial revision
@
text
@d9 3
a11 2
#include "HTUtils.h"		/* Coding convention macros */
#include "tcp.h"
d15 1
a15 5
#include "HTNews.h"

#include "HTCJK.h"
#include "HTMIME.h"
#include "HTTCP.h"
d17 4
a20 1
#define FREE(x) if (x) {free(x); x = NULL;}
d42 8
a49 10
#include <ctype.h>

#include "HTML.h"
#include "HTParse.h"
#include "HTFormat.h"
#include "HTAlert.h"

#include "LYNews.h"
#include "LYGlobalDefs.h"
#include "LYLeaks.h"
a50 1
#define BIG 1024 /* @@@@@@ */
d89 3
d111 1
d121 3
d125 1
d197 2
a198 2
	if (TRACE) fprintf(stderr, "HTNews: NNTPSERVER defined as `%s'\n",
		HTNewsHost);
d205 2
a206 3
		if (TRACE) fprintf(stderr,
		"HTNews: File %s defines news host as `%s'\n",
			SERVER_FILE, HTNewsHost);
d216 1
d218 1
d236 1
a236 1
    char ch;
d241 1
a241 1
	if (TRACE) fprintf(stderr, "NNTP command to be sent: %s", command);
d256 1
a256 2
	    if (TRACE) fprintf(stderr,
		"HTNews: Unable to send command. Disconnecting.\n");
d264 2
a265 1
	if (((*p++ = NEXT_CHAR) == LF) ||
d268 1
a268 2
	    if (TRACE)
		fprintf(stderr, "NNTP Response: %s\n", response_text);
d273 1
a273 1
	if ((ch = *(p-1)) == (char)EOF) {
d275 2
a276 4
	    if (TRACE) {
		if (interrupted_in_htgetcharacter) {
		    fprintf(stderr,
			    "HTNews: Interrupted on read, closing socket %d\n",
d278 2
a279 3
		} else {
		    fprintf(stderr,
			    "HTNews: EOF on read, closing socket %d\n",
a280 1
		}
d348 1
d350 1
d364 1
a364 1
	    sprintf(msg, "Username for news host '%s':", host);
d375 1
a375 1
		_HTProgress("Connection interrupted.");
d377 1
a377 1
		HTAlert("Connection closed ???");
d417 1
a417 1
	    if ((tries > 0) && HTConfirm("Change username?")) {
d421 1
a421 1
		if ((UserName = HTPrompt("Username:", UserName)) != NULL &&
d440 1
a440 1
        **  Handle the password. - FM
d448 1
a448 1
		sprintf(msg, "Password for news host '%s':", host);
d459 1
a459 1
		    _HTProgress("Connection interrupted.");
d461 1
a461 1
		    HTAlert("Connection closed ???");
d531 1
a531 1
	    if ((tries > 0) && HTConfirm("Change password?")) {
a561 1
    static char *name = NULL;
d565 1
a565 2
    if (TRACE)
	fprintf(stderr,"Trying to find name in: %s\n",name);
a597 1
    static char *address = NULL;
d601 1
a601 2
    if (TRACE)
	fprintf(stderr,"Trying to find address in: %s\n",address);
d772 1
a772 3
    if (TRACE)
	fprintf(stderr,
		"HTNews: EOF on read, closing socket %d\n", s);
d838 1
a838 1
	HTAlert("Cannot open temporary file for news POST.");
d909 1
a909 6
#ifdef VMS
    while (remove(postfile) == 0)
	; /* loop through all versions */
#else
    remove(postfile);
#endif /* VMS */
d950 2
a951 1
PRIVATE int read_article NOARGS
d965 2
d977 3
a979 2
	    char ch = *p++ = NEXT_CHAR;
	    if (ch == (char)EOF) {
d982 1
a982 3
		    if (TRACE)
			fprintf(stderr,
			   "HTNews: Interrupted on read, closing socket %d\n",
d991 1
a991 1
	    if ((ch == LF) || (p == &line[LINE_LENGTH])) {
d993 1
a993 2
		if (TRACE)
		    fprintf(stderr, "H %s\n", line);
d1028 3
d1066 8
d1094 1
a1094 1
	    StrAllocCopy(temp, replyto ? replyto : from);
d1096 7
a1102 1
	    StrAllocCat(href, author_address(temp));
d1133 1
a1133 1
		PUTS(from);
d1182 53
d1248 14
a1261 11

	    START(HTML_DT);
	    START(HTML_B);
	    PUTS("Newsgroups:");
	    END(HTML_B);
	    PUTC('\n');
	    MAYBE_END(HTML_DT);
	    START(HTML_DD);
	    write_anchors(newsgroups);
	    MAYBE_END(HTML_DD);
	    PUTC('\n');
d1269 5
a1273 1
	    PUTS("newsgroup(s)");
d1322 3
a1324 2
	char ch = *p++ = NEXT_CHAR;
	if (ch == (char)EOF) {
d1327 1
a1327 3
		if (TRACE)
		    fprintf(stderr,
			  "HTNews: Interrupted on read, closing socket %d\n",
d1336 1
a1336 1
	if ((ch == LF) || (p == &line[LINE_LENGTH])) {
d1338 1
a1338 2
	    if (TRACE)
		fprintf(stderr, "B %s", line);
d1527 3
a1529 2
	char ch = NEXT_CHAR;
	if (ch == (char)EOF) {
d1532 1
a1532 3
		if (TRACE)
		    fprintf(stderr,
			  "HTNews: Interrupted on read, closing socket %d\n",
d1552 1
a1552 3
	    if (TRACE) {
		fprintf(stderr, "b %.*s%c[...]\n", (LINE_LENGTH), line, ch);
	    }
d1562 1
a1562 3
		if (TRACE)
		    fprintf(stderr,
			    "HTNews..... group name too long, discarding.\n");
d1574 1
a1574 2
	    if (TRACE)
		fprintf(stderr, "B %s", line);
d1634 1
a1634 1
	sprintf(line, "No matches for: %s", arg);
d1682 1
a1682 3
    if (TRACE)
	fprintf(stderr,
		"Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
d1685 1
a1685 1
	PUTS("\nNo articles in this group.\n");
d1698 1
a1698 1
	PUTS("\nNo articles in this range.\n");
d1705 2
a1706 3
    if (TRACE)
	fprintf(stderr, "    Chunk will be (%d-%d)\n",
			first_required, last_required);
d1711 1
a1711 1
    sprintf(buffer, "%s,  Articles %d-%d",
d1727 1
a1727 1
	sprintf(buffer, "%s%s/%d-%d", NewsHREF, groupName,
d1729 1
a1729 2
	if (TRACE)
	    fprintf(stderr, "    Block before is %s\n", buffer);
d1731 2
a1732 2
	start_anchor(buffer);
	PUTS("Earlier articles");
d1745 1
a1745 1
 "\nThere are about %d articles currently available in %s, IDs as follows:\n\n",
d1753 3
a1755 2
		char ch = *p++ = NEXT_CHAR;
		if (ch == (char)EOF) {
d1758 1
a1758 3
			if (TRACE)
			    fprintf(stderr,
			   "HTNews: Interrupted on read, closing socket %d\n",
d1767 1
a1767 1
		if ((ch == '\n') || (p == &line[LINE_LENGTH])) {
d1769 1
a1769 2
		    if (TRACE)
			fprintf(stderr, "X %s", line);
d1804 1
a1804 1
	    PUTS("All available articles in ");
d1857 3
a1859 2
		    char ch = *p++ = NEXT_CHAR;
		    if (ch == (char)EOF) {
d1862 1
a1862 3
			    if (TRACE)
				fprintf(stderr,
			   "HTNews: Interrupted on read, closing socket %d\n",
d1871 1
a1871 1
		    if ((ch == LF) ||
d1876 1
a1876 2
			if (TRACE)
			    fprintf(stderr, "G %s\n", line);
d1970 1
a1970 3
		if (TRACE)
		    fprintf(stderr,
			  "HTNews: Interrupted on read, closing socket %d\n",
d2008 1
a2008 1
	    sprintf(buffer, "%s%s", NewsHREF, groupName); /* original group */
d2010 1
a2010 1
	    sprintf(buffer, "%s%s/%d-%d", NewsHREF, groupName,
d2012 1
a2012 2
	if (TRACE)
	    fprintf(stderr, "    Block after is %s\n", buffer);
d2014 2
a2015 2
	start_anchor(buffer);
	PUTS("Later articles");
d2039 1
a2039 1
	PUTS("Post to ");
d2083 1
a2083 1
    if (TRACE) fprintf(stderr, "HTNews: Looking for %s\n", arg);
d2126 1
a2126 2
	    HTAlert(
	"This client does not contain support for posting to news with SSL.");
d2139 1
a2139 1
		HTAlert("Invalid URL!");
d2178 1
a2178 1
	**  rules. For instance, if the article reference contains a '#',
d2216 1
a2216 1
	    HTAlert("This client does not contain support for SNEWS URLs.");
d2283 1
a2283 3
	    if (TRACE)
		fprintf(stderr,
			"HTNews: Proxy command is '%.*s'\n",
d2397 1
a2397 1
	    HTAlert("No target for raw text!");
d2425 1
a2425 2
	    if (TRACE)
		fprintf (stderr, "News: doing HTDoConnect on '%s'\n", url);
d2427 1
a2427 1
	    _HTProgress("Connecting to NewsHost ...");
d2434 2
a2435 4
		if (TRACE)
		    fprintf(stderr,
		     "HTNews: Interrupted on connect; recovering cleanly.\n");
		_HTProgress("Connection interrupted.");
d2446 1
a2446 6
#ifdef VMS
		    while (remove(postfile) == 0)
			; /* loop through all versions */
#else
		    remove(postfile);
#endif /* VMS */
a2451 1
		char message[256];
d2454 1
a2454 3
		if (TRACE)
		    fprintf(stderr,
			    "HTNews: Unable to connect to news host.\n");
d2457 5
a2461 1
		sprintf(message, "Could not access %s.", NewsHost);
d2468 1
a2468 6
#ifdef VMS
		    while (remove(postfile) == 0)
			; /* loop through all versions */
#else
		    remove(postfile);
#endif /* VMS */
d2471 1
a2471 1
		return HTLoadError(stream, 500, message);
d2473 2
a2474 3
		if (TRACE)
		    fprintf(stderr, "HTNews: Connected to news host %s.\n",
				    NewsHost);
d2478 1
a2478 3
		    if (TRACE)
			fprintf(stderr,
			     "HTNews: Proxy command returned status '%d'.\n",
a2481 1
			char message[BIG];
d2485 1
a2485 1
			    _HTProgress("Connection interrupted.");
d2496 1
a2496 6
#ifdef VMS
				while (remove(postfile) == 0)
				    ; /* loop through all versions */
#else
				remove(postfile);
#endif /* VMS */
d2503 6
a2508 2
			sprintf(message,
		  "Can't read news info. News host %.20s responded: %.200s",
d2510 1
a2510 1
			return HTLoadError(stream, 500, message);
d2518 1
a2518 1
			HTAlert("Cannot POST to this host.");
d2527 1
a2527 6
#ifdef VMS
			    while (remove(postfile) == 0)
				; /* loop through all versions */
#else
			    remove(postfile);
#endif /* VMS */
d2539 1
a2539 1
		HTAlert("Cannot POST to this host.");
d2548 1
a2548 6
#ifdef VMS
		    while (remove(postfile) == 0)
			; /* loop through all versions */
#else
		    remove(postfile);
#endif /* VMS */
d2557 1
a2557 1
		HTProgress("Cancelled!");
d2579 1
a2579 1
		_HTProgress("Connection interrupted.");
d2594 1
a2594 1
		    _HTProgress("Connection interrupted.");
d2602 1
a2602 1
	    _HTProgress("Connection interrupted.");
d2691 1
a2691 1
		HTAlert("Cannot POST to this host.");
d2693 1
a2693 6
#ifdef VMS
		    while (remove(postfile) == 0)
			; /* loop through all versions */
#else
		    remove(postfile);
#endif /* VMS */
d2704 1
a2704 1
	    _HTProgress("Reading list of available newsgroups.");
d2726 1
a2726 1
	    _HTProgress("Reading list of articles in newsgroup.");
d2732 2
a2733 2
	    _HTProgress("Reading news article.");
	    status = read_article();
d2736 1
a2736 1
	    _HTProgress("Connection interrupted.");
d2755 1
a2755 6
#ifdef VMS
	    while (remove(postfile) == 0)
		; /* loop through all versions */
#else
	    remove(postfile);
#endif /* VMS */
d2761 1
a2761 1
    /* HTAlert("Sorry, could not load requested news."); */
d2778 1
a2778 6
#ifdef VMS
	while (remove(postfile) == 0)
	    ; /* loop through all versions */
#else
	remove(postfile);
#endif /* VMS */
d2831 2
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
