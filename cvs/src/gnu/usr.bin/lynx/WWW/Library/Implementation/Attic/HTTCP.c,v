head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.12.21.20.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.49;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTTCP.c,v 1.129 2013/12/07 15:36:55 tom Exp $
 *
 *			Generic Communication Code		HTTCP.c
 *			==========================
 *
 *	This code is in common between client and server sides.
 *
 *	16 Jan 92  TBL	Fix strtol() undefined on CMU Mach.
 *	25 Jun 92  JFG	Added DECNET option through TCP socket emulation.
 *	13 Sep 93  MD	Added correct return of vmserrorno for HTInetStatus.
 *			Added decoding of vms error message for MULTINET.
 *	7-DEC-1993 Bjorn S. Nilsson, ALEPH, CERN, VMS UCX ioctl() changes
 *			(done of Mosaic)
 *	19 Feb 94  Danny Mayer	Added Bjorn Fixes to Lynx version
 *	 7 Mar 94  Danny Mayer	Added Fix UCX version for full domain name
 *	20 May 94  Andy Harper	Added support for CMU TCP/IP transport
 *	17 Nov 94  Andy Harper	Added support for SOCKETSHR transport
 *	16 Jul 95  S. Bjorndahl added kluge to deal with LIBCMU bug
 */

#include <HTUtils.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <HTTCP.h>
#include <LYGlobalDefs.h>	/* added for no_suspend */
#include <LYUtils.h>

#ifdef NSL_FORK
#include <signal.h>
#include <www_wait.h>
#endif /* NSL_FORK */

#ifdef HAVE_RESOLV_H
#include <resolv.h>
#endif

#ifdef __DJGPP__
#include <netdb.h>
#endif /* __DJGPP__ */

#define LYNX_ADDRINFO	struct addrinfo
#define LYNX_HOSTENT	struct hostent

#define OK_HOST(p) ((p) != 0 && ((p)->h_length) != 0)

#ifdef SVR4_BSDSELECT
int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout);

#ifdef select
#undef select
#endif /* select */
#define select BSDselect
#ifdef SOCKS
#ifdef Rselect
#undef Rselect
#endif /* Rselect */
#define Rselect BSDselect
#endif /* SOCKS */
#endif /* SVR4_BSDSELECT */

#include <LYLeaks.h>

/*
 *  Module-Wide variables
 */
static char *hostname = NULL;	/* The name of this host */

/*
 *  PUBLIC VARIABLES
 */
#ifdef SOCKS
unsigned long socks_bind_remoteAddr;	/* for long Rbind */
#endif /* SOCKS */

/*	Encode INET status (as in sys/errno.h)			  inet_status()
 *	------------------
 *
 *  On entry,
 *	where		gives a description of what caused the error
 *	global errno	gives the error number in the Unix way.
 *
 *  On return,
 *	returns		a negative status in the Unix way.
 */

#ifdef DECL_SYS_ERRLIST
extern char *sys_errlist[];	/* see man perror on cernvax */
extern int sys_nerr;
#endif /* DECL_SYS_ERRLIST */

#ifdef __DJGPP__
static int ResolveYield(void)
{
    return HTCheckForInterrupt()? 0 : 1;
}
#endif

#if defined(VMS) && defined(UCX)
/*
 *  A routine to mimic the ioctl function for UCX.
 *  Bjorn S. Nilsson, 25-Nov-1993. Based on an example in the UCX manual.
 */
#include <HTioctl.h>

int HTioctl(int d,
	    int request,
	    int *argp)
{
    int sdc, status;
    unsigned short fun, iosb[4];
    char *p5, *p6;
    struct comm {
	int command;
	char *addr;
    } ioctl_comm;
    struct it2 {
	unsigned short len;
	unsigned short opt;
	struct comm *addr;
    } ioctl_desc;

    if ((sdc = vaxc$get_sdc(d)) == 0) {
	set_errno(EBADF);
	return -1;
    }
    ioctl_desc.opt = UCX$C_IOCTL;
    ioctl_desc.len = sizeof(struct comm);

    ioctl_desc.addr = &ioctl_comm;
    if (request & IOC_OUT) {
	fun = IO$_SENSEMODE;
	p5 = 0;
	p6 = (char *) &ioctl_desc;
    } else {
	fun = IO$_SETMODE;
	p5 = (char *) &ioctl_desc;
	p6 = 0;
    }
    ioctl_comm.command = request;
    ioctl_comm.addr = (char *) argp;
    status = sys$qiow(0, sdc, fun, iosb, 0, 0, 0, 0, 0, 0, p5, p6);
    if (!(status & 01)) {
	set_errno(status);
	return -1;
    }
    if (!(iosb[0] & 01)) {
	set_errno(iosb[0]);
	return -1;
    }
    return 0;
}
#endif /* VMS && UCX */

#define MY_FORMAT "TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n"
	   /* third arg is transport/platform specific */

/*	Report Internet Error
 *	---------------------
 */
int HTInetStatus(const char *where)
{
    int status;
    int saved_errno = errno;

#ifdef VMS
#ifdef MULTINET
    SOCKET_ERRNO = vmserrno;
#endif /* MULTINET */
#endif /* VMS */

#ifdef VM
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    "(Error number not translated)"));	/* What Is the VM equiv? */
#define ER_NO_TRANS_DONE
#endif /* VM */

#ifdef VMS
#ifdef MULTINET
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    vms_errno_string()));
#else
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    ((SOCKET_ERRNO > 0 && SOCKET_ERRNO <= 65) ?
	     strerror(SOCKET_ERRNO) : "(Error number not translated)")));
#endif /* MULTINET */
#define ER_NO_TRANS_DONE
#endif /* VMS */

#ifdef HAVE_STRERROR
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    strerror(SOCKET_ERRNO)));
#define ER_NO_TRANS_DONE
#endif /* HAVE_STRERROR */

#ifndef ER_NO_TRANS_DONE
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO, where,
	    (SOCKET_ERRNO < sys_nerr ?
	     sys_errlist[SOCKET_ERRNO] : "Unknown error")));
#endif /* !ER_NO_TRANS_DONE */

#ifdef VMS
#ifndef MULTINET
    CTRACE((tfp,
	    "         Unix error number (SOCKET_ERRNO) = %ld dec\n",
	    SOCKET_ERRNO));
    CTRACE((tfp,
	    "         VMS error (vaxc$errno)    = %lx hex\n",
	    vaxc$errno));
#endif /* MULTINET */
#endif /* VMS */

    set_errno(saved_errno);

#ifdef VMS
    /*
     * uerrno and errno happen to be zero if vmserrno <> 0
     */
#ifdef MULTINET
    status = -vmserrno;
#else
    status = -vaxc$errno;
#endif /* MULTINET */
#else
    status = -SOCKET_ERRNO;
#endif /* VMS */
    return status;
}

/*	Parse a cardinal value				       parse_cardinal()
 *	----------------------
 *
 * On entry,
 *	*pp	    points to first character to be interpreted, terminated by
 *		    non 0:9 character.
 *	*pstatus    points to status already valid
 *	maxvalue    gives the largest allowable value.
 *
 * On exit,
 *	*pp	    points to first unread character
 *	*pstatus    points to status updated iff bad
 */
unsigned int HTCardinal(int *pstatus,
			char **pp,
			unsigned int max_value)
{
    unsigned int n;

    if ((**pp < '0') || (**pp > '9')) {		/* Null string is error */
	*pstatus = -3;		/* No number where one expected */
	return 0;
    }

    n = 0;
    while ((**pp >= '0') && (**pp <= '9'))
	n = n * 10 + (unsigned) (*((*pp)++) - '0');

    if (n > max_value) {
	*pstatus = -4;		/* Cardinal outside range */
	return 0;
    }

    return n;
}

#ifndef DECNET			/* Function only used below for a trace message */
/*	Produce a string for an Internet address
 *	----------------------------------------
 *
 *  On exit,
 *	returns a pointer to a static string which must be copied if
 *		it is to be kept.
 */
const char *HTInetString(SockA * soc_in)
{
#ifdef INET6
    static char hostbuf[MAXHOSTNAMELEN];

    getnameinfo((struct sockaddr *) soc_in,
		SOCKADDR_LEN(soc_in),
		hostbuf, (socklen_t) sizeof(hostbuf),
		NULL, 0,
		NI_NUMERICHOST);
    return hostbuf;
#else
    static char string[20];

    sprintf(string, "%d.%d.%d.%d",
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3));
    return string;
#endif /* INET6 */
}
#endif /* !DECNET */

/*	Check whether string is a valid Internet hostname - kw
 *	-------------------------------------------------
 *
 *  Checks whether
 *  - contains only valid chars for domain names (actually, the
 *    restrictions are somewhat relaxed),
 *  - no leading dots or empty segments,
 *  - no segment starts with '-' or '+' [this protects telnet command],
 *  - max. length of dot-separated segment <= 63 (RFC 1034,1035),
 *  - total length <= 254 (if it ends with dot) or 253 (otherwise)
 *     [an interpretation of RFC 1034,1035, although RFC 1123
 *      suggests 255 as limit - kw].
 *
 *  Note: user (before '@@') and port (after ':') components from
 *      host part of URL should be already stripped (if appropriate)
 *      from the input string.
 *
 *  On exit,
 *	returns 1 if valid, otherwise 0.
 */
BOOL valid_hostname(char *name)
{
    int i = 1, iseg = 0;
    char *cp = name;

    if (!(name && *name))
	return NO;
    for (; (*cp && i <= 253); cp++, i++) {
	if (*cp == '.') {
	    if (iseg == 0) {
		return NO;
	    } else {
		iseg = 0;
		continue;
	    }
	} else if (iseg == 0 && (*cp == '-' || *cp == '+')) {
	    return NO;
	} else if (++iseg > 63) {
	    return NO;
	}
	if (!isalnum(UCH(*cp)) &&
	    *cp != '-' && *cp != '_' &&
	    *cp != '$' && *cp != '+') {
	    return NO;
	}
    }
    return (BOOL) (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
}

/* for transfer of status from child to parent: */
typedef struct _statuses {
    size_t rehostentlen;
    int h_length;
    int child_errno;		/* sometimes useful to pass this on */
    int child_h_errno;
    BOOL h_errno_valid;
} STATUSES;

/*
 *  Function to allow us to be killed with a normal signal (not
 *  SIGKILL), but don't go through normal libc exit() processing, which
 *  would screw up parent's stdio.  -BL
 */
#ifdef NSL_FORK
static void quench(int sig GCC_UNUSED)
{
    _exit(2);
}
#endif

int lynx_nsl_status = HT_OK;

#define DEBUG_HOSTENT		/* disable in case of problems */
#define DEBUG_HOSTENT_CHILD	/* for NSL_FORK, may screw up trace file */

/*
 *  dump_hostent - dumps the contents of a LYNX_HOSTENT to the
 *  trace log or stderr, including all pointer values, strings, and
 *  addresses, in a format inspired by gdb's print format. - kw
 */
static void dump_hostent(const char *msgprefix,
			 void *data)
{
    if (TRACE) {
	int i;
	char **pcnt;
	const LYNX_HOSTENT *phost = data;

	CTRACE((tfp, "%s: %p ", msgprefix, (const void *) phost));
	if (phost) {
	    CTRACE((tfp, "{ h_name = %p", phost->h_name));
	    if (phost->h_name) {
		CTRACE((tfp, " \"%s\",", phost->h_name));
	    } else {
		CTRACE((tfp, ","));
	    }
	    CTRACE((tfp, "\n\t h_aliases = %p", (void *) phost->h_aliases));
	    if (phost->h_aliases) {
		CTRACE((tfp, " {"));
		for (pcnt = phost->h_aliases; *pcnt; pcnt++) {
		    CTRACE((tfp, "%s %p \"%s\"",
			    (pcnt == phost->h_aliases ? " " : ", "),
			    *pcnt, *pcnt));
		}
		CTRACE((tfp, "%s0x0 },\n\t",
			(*phost->h_aliases ? ", " : " ")));
	    } else {
		CTRACE((tfp, ",\n\t"));
	    }
	    CTRACE((tfp, " h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp, " h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp, " h_addr_list = %p", (void *) phost->h_addr_list));
	    if (phost->h_addr_list) {
		CTRACE((tfp, " {"));
		for (pcnt = phost->h_addr_list; *pcnt; pcnt++) {
		    CTRACE((tfp, "%s %p",
			    (pcnt == phost->h_addr_list ? "" : ","),
			    *pcnt));
		    for (i = 0; i < phost->h_length; i++) {
			CTRACE((tfp, "%s%d%s", (i == 0 ? " \"" : "."),
				(int) *((unsigned char *) (*pcnt) + i),
				(i + 1 == phost->h_length ? "\"" : "")));
		    }
		}
		if (*phost->h_addr_list) {
		    CTRACE((tfp, ", 0x0 } }"));
		} else {
		    CTRACE((tfp, " 0x0 } }"));
		}
	    } else {
		CTRACE((tfp, "}"));
	    }
	}
	CTRACE((tfp, "\n"));
	fflush(tfp);
    }
}

#ifdef NSL_FORK

/*
 * Even though it is a small amount, we cannot count on reading the whole
 * struct via a pipe in one read -TD
 */
static unsigned read_bytes(int fd, char *buffer, size_t length)
{
    unsigned result = 0;

    while (length != 0) {
	unsigned got = (unsigned) read(fd, buffer, length);

	if ((int) got > 0) {
	    result += got;
	    buffer += got;
	    length -= got;
	} else {
	    break;
	}
    }
    return result;
}

static unsigned read_hostent(int fd, char *buffer, size_t length)
{
    unsigned have = read_bytes(fd, buffer, length);

    if (have) {
	LYNX_HOSTENT *data = (LYNX_HOSTENT *) (void *) buffer;
	char *next_char = (char *) data + sizeof(*data);
	char **next_ptr = (char **) (void *) next_char;
	long offset = 0;
	int n;
	int num_addrs = 0;
	int num_aliases = 0;

	if (data->h_addr_list) {
	    data->h_addr_list = next_ptr;
	    while (next_ptr[num_addrs] != 0) {
		++num_addrs;
	    }
	    next_ptr += (num_addrs + 1);
	    next_char += (size_t) (num_addrs + 1) * sizeof(data->h_addr_list[0]);
	}

	if (data->h_aliases) {
	    data->h_aliases = next_ptr;
	    while (next_ptr[num_aliases] != 0) {
		++num_aliases;
	    }
	    next_char += (size_t) (num_aliases + 1) * sizeof(data->h_aliases[0]);
	}

	if (data->h_name) {
	    offset = next_char - data->h_name;
	    data->h_name = next_char;
	} else if (data->h_addr_list) {
	    offset = next_char - (char *) data->h_addr_list[0];
	} else if (data->h_aliases) {
	    offset = next_char - (char *) data->h_aliases[0];
	}

	if (data->h_addr_list) {
	    for (n = 0; n < num_addrs; ++n) {
		data->h_addr_list[n] += offset;
	    }
	}

	if (data->h_aliases) {
	    for (n = 0; n < num_aliases; ++n) {
		data->h_aliases[n] += offset;
	    }
	}
    }

    return have;
}
#endif /* NSL_FORK */

/*
 *  fill_rehostent - copies as much as possible relevant content from
 *  the LYNX_HOSTENT pointed to by phost to the char buffer given
 *  by rehostent, subject to maximum output length rehostentsize,
 *  following pointers and building self-contained output which can be
 *  cast to a LYNX_HOSTENT. - kw
 *  See also description of LYGetHostByName.
 */
#if defined(NSL_FORK) || defined(_WINDOWS_NSL)

#define REHOSTENT_SIZE 128	/* not bigger than pipe buffer! */

typedef struct {
    LYNX_HOSTENT h;
    char rest[REHOSTENT_SIZE];
} AlignedHOSTENT;

static size_t fill_rehostent(void **rehostent,
			     const LYNX_HOSTENT *phost)
{
    LYNX_HOSTENT *data = 0;
    int num_addrs = 0;
    int num_aliases = 0;
    char *result = 0;
    char *p_next_char;
    char **p_next_charptr;
    size_t name_len = 0;
    size_t need = sizeof(LYNX_HOSTENT);
    int n;

    if (!phost)
	return 0;

    if (phost->h_name) {
	name_len = strlen(phost->h_name);
	need += name_len + 1;
    }
    if (phost->h_addr_list) {
	while (phost->h_addr_list[num_addrs]) {
	    num_addrs++;
	}
	need += ((size_t) num_addrs + 1) * ((size_t) phost->h_length
					    + sizeof(phost->h_addr_list[0]));
    }
    if (phost->h_aliases) {
	while (phost->h_aliases[num_aliases]) {
	    need += strlen(phost->h_aliases[num_aliases]) + 1;
	    num_aliases++;
	}
	need += ((size_t) num_aliases + 1) * sizeof(phost->h_aliases[0]);
    }

    if ((result = calloc(need, sizeof(char))) == 0)
	  outofmem(__FILE__, "fill_rehostent");

    *rehostent = result;

    data = (LYNX_HOSTENT *) (void *) result;

    data->h_addrtype = phost->h_addrtype;
    data->h_length = phost->h_length;

    p_next_char = result + sizeof(LYNX_HOSTENT);

    p_next_charptr = (char **) (void *) p_next_char;
    if (phost->h_addr_list)
	p_next_char += (size_t) (num_addrs + 1) * sizeof(phost->h_addr_list[0]);
    if (phost->h_aliases)
	p_next_char += (size_t) (num_aliases + 1) * sizeof(phost->h_aliases[0]);

    if (phost->h_name) {
	data->h_name = p_next_char;
	strcpy(p_next_char, phost->h_name);
	p_next_char += name_len + 1;
    }

    if (phost->h_addr_list) {
	data->h_addr_list = p_next_charptr;
	for (n = 0; n < num_addrs; ++n) {
	    MemCpy(p_next_char, phost->h_addr_list[n], phost->h_length);
	    *p_next_charptr++ = p_next_char;
	    p_next_char += phost->h_length;
	}
	++p_next_charptr;
    }

    if (phost->h_aliases) {
	data->h_aliases = p_next_charptr;
	for (n = 0; n < num_aliases; ++n) {
	    strcpy(p_next_char, phost->h_aliases[n]);
	    *p_next_charptr++ = p_next_char;
	    p_next_char += strlen(phost->h_aliases[n]) + 1;;
	}
    }
    return need;
}
#endif /* NSL_FORK */

/*
 * This chunk of code is used in both win32 and cygwin.
 */
#if defined(_WINDOWS_NSL)
static LYNX_HOSTENT *gbl_phost;	/* Pointer to host - See netdb.h */

#if !(defined(__CYGWIN__) && defined(NSL_FORK))
static int donelookup;

static unsigned long __stdcall _fork_func(void *arg)
{
    const char *host = (const char *) arg;
    static AlignedHOSTENT aligned_full_rehostent;
    char *rehostent = (char *) &aligned_full_rehostent;
    size_t rehostentlen = 0;

#ifdef SH_EX
    unsigned long addr;

    addr = (unsigned long) inet_addr(host);
    if (addr != INADDR_NONE)
	gbl_phost = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);
    else
	gbl_phost = gethostbyname(host);
#else
    gbl_phost = gethostbyname(host);
#endif

    if (gbl_phost) {
	rehostentlen = fill_rehostent((void **) &rehostent, gbl_phost);
	if (rehostentlen == 0) {
	    gbl_phost = (LYNX_HOSTENT *) NULL;
	} else {
	    gbl_phost = (LYNX_HOSTENT *) rehostent;
	}
    }

    donelookup = TRUE;
    return (unsigned long) (gbl_phost);
}
#endif /* __CYGWIN__ */
#endif /* _WINDOWS_NSL */

#ifdef NSL_FORK

#ifndef HAVE_H_ERRNO
#undef  h_errno
#define h_errno my_errno
static int my_errno;

#else /* we do HAVE_H_ERRNO: */
#ifndef h_errno			/* there may be a macro as well as the extern data */
extern int h_errno;
#endif
#endif

static BOOL setup_nsl_fork(void (*really) (char *, char *, STATUSES *, void **),
			   unsigned (*readit) (int, char *, size_t),
			   void (*dumpit) (const char *, void *),
			   char *host,
			   char *port,
			   void **rehostent)
{
    STATUSES statuses;

    /*
     * fork-based gethostbyname() with checks for interrupts.
     * - Tom Zerucha (tz@@execpc.com) & FM
     */
    int got_rehostent = 0;

#if HAVE_SIGACTION
    sigset_t old_sigset;
    sigset_t new_sigset;
#endif
    /*
     * Pipe, child pid, status buffers, start time, select() control
     * variables.
     */
    int fpid, waitret;
    int pfd[2], selret;
    unsigned readret;

#ifdef HAVE_TYPE_UNIONWAIT
    union wait waitstat;

#else
    int waitstat = 0;
#endif
    time_t start_time = time((time_t *) 0);
    fd_set readfds;
    struct timeval one_second;
    long dns_patience = 30;	/* how many seconds will we wait for DNS? */
    int child_exited = 0;

    memset(&statuses, 0, sizeof(STATUSES));
    statuses.h_errno_valid = NO;

    /*
     * Reap any children that have terminated since last time through.
     * This might include children that we killed, then waited with WNOHANG
     * before they were actually ready to be reaped.  (Should be max of 1
     * in this state, but the loop is safe if waitpid() is implemented
     * correctly:  returns 0 when children exist but none have exited; -1
     * with errno == ECHILD when no children.) -BL
     */
    do {
	waitret = waitpid(-1, 0, WNOHANG);
    } while (waitret > 0 || (waitret == -1 && errno == EINTR));
    waitret = 0;

    IGNORE_RC(pipe(pfd));

#if HAVE_SIGACTION
    /*
     * Attempt to prevent a rare situation where the child could execute
     * the Lynx signal handlers because it gets killed before it even has a
     * chance to reset its handlers, resulting in bogus 'Exiting via
     * interrupt' message and screen corruption or worse.
     * Should that continue to be reported, for systems without
     * sigprocmask(), we need to find a different solutions for those.  -
     * kw 19990430
     */
    sigemptyset(&new_sigset);
    sigaddset(&new_sigset, SIGTERM);
    sigaddset(&new_sigset, SIGINT);
#ifndef NOSIGHUP
    sigaddset(&new_sigset, SIGHUP);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
    sigaddset(&new_sigset, SIGTSTP);
#endif /* SIGTSTP */
#ifdef SIGWINCH
    sigaddset(&new_sigset, SIGWINCH);
#endif /* SIGWINCH */
    sigprocmask(SIG_BLOCK, &new_sigset, &old_sigset);
#endif /* HAVE_SIGACTION */

    if ((fpid = fork()) == 0) {
	/*
	 * Child - for the long call.
	 *
	 * Make sure parent can kill us at will.  -BL
	 */
	(void) signal(SIGTERM, quench);

	/*
	 * Also make sure the child does not run one of the signal handlers
	 * that may have been installed by Lynx if one of those signals
	 * occurs.  For example we don't want the child to remove temp
	 * files on ^C, let the parent deal with that.  - kw
	 */
	(void) signal(SIGINT, quench);
#ifndef NOSIGHUP
	(void) signal(SIGHUP, quench);
#endif /* NOSIGHUP */
#ifdef SIGTSTP
	if (no_suspend)
	    (void) signal(SIGTSTP, SIG_IGN);
	else
	    (void) signal(SIGTSTP, SIG_DFL);
#endif /* SIGTSTP */
#ifdef SIGWINCH
	(void) signal(SIGWINCH, SIG_IGN);
#endif /* SIGWINCH */
#ifndef __linux__
#ifndef DOSPATH
	signal(SIGBUS, SIG_DFL);
#endif /* DOSPATH */
#endif /* !__linux__ */
	signal(SIGSEGV, SIG_DFL);
	signal(SIGILL, SIG_DFL);

#if HAVE_SIGACTION
	/* Restore signal mask to whatever it was before the fork. -kw */
	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

	/*
	 * Child won't use read side.  -BL
	 */
	close(pfd[0]);
#ifdef HAVE_H_ERRNO
	/* to detect cases when it doesn't get set although it should */
	h_errno = -2;
#endif
	set_errno(0);
	really(host, port, &statuses, rehostent);
	/*
	 * Send variables indicating status of lookup to parent.  That
	 * includes rehostentlen, which the parent will use as the size for
	 * the second read (if > 0).
	 */
	if (!statuses.child_errno)
	    statuses.child_errno = errno;
	IGNORE_RC(write(pfd[1], &statuses, sizeof(statuses)));

	if (statuses.rehostentlen) {
	    /*
	     * Return our resulting rehostent through pipe...
	     */
	    IGNORE_RC(write(pfd[1], *rehostent, statuses.rehostentlen));
	    close(pfd[1]);
	    _exit(0);
	} else {
	    /*
	     * ...  or return error as exit code.
	     */
	    _exit(1);
	}
    }
#if HAVE_SIGACTION
    /*
     * (parent) Restore signal mask to whatever it was before the fork.  -
     * kw
     */
    sigprocmask(SIG_SETMASK, &old_sigset, NULL);
#endif /* HAVE_SIGACTION */

    /*
     * (parent) Wait until lookup finishes, or interrupt, or cycled too
     * many times (just in case) -BL
     */

    close(pfd[1]);		/* parent won't use write side -BL */

    if (fpid < 0) {		/* fork failed */
	close(pfd[0]);
	goto failed;
    }

    while (child_exited || (long) (time((time_t *) 0) - start_time) < dns_patience) {

	FD_ZERO(&readfds);
	/*
	 * This allows us to abort immediately, not after 1-second timeout,
	 * when user hits abort key.  Can't do this when using SLANG (or at
	 * least I don't know how), so SLANG users must live with up-to-1s
	 * timeout.  -BL
	 *
	 * Whoops -- we need to make sure stdin is actually selectable!
	 * /dev/null isn't, on some systems, which makes some useful Lynx
	 * invocations fail.  -BL
	 */
	{
	    int kbd_fd = LYConsoleInputFD(TRUE);

	    if (kbd_fd != INVSOC) {
		FD_SET(kbd_fd, &readfds);
	    }
	}

	one_second.tv_sec = 1;
	one_second.tv_usec = 0;
	FD_SET(pfd[0], &readfds);

	/*
	 * Return when data received, interrupted, or failed.  If nothing
	 * is waiting, we sleep for 1 second in select(), to be nice to the
	 * system.  -BL
	 */
#ifdef SOCKS
	if (socks_flag)
	    selret = Rselect(pfd[0] + 1, &readfds, NULL, NULL, &one_second);
	else
#endif /* SOCKS */
	    selret = select(pfd[0] + 1, &readfds, NULL, NULL, &one_second);

	if ((selret > 0) && FD_ISSET(pfd[0], &readfds)) {
	    /*
	     * First get status, including length of address.  -BL, kw
	     */
	    readret = read_bytes(pfd[0], (char *) &statuses, sizeof(statuses));
	    if (readret == sizeof(statuses)) {
		h_errno = statuses.child_h_errno;
		set_errno(statuses.child_errno);
#ifdef HAVE_H_ERRNO
		if (statuses.h_errno_valid) {
		    lynx_nsl_status = HT_H_ERRNO_VALID;
		    /*
		     * If something went wrong in the child process other
		     * than normal lookup errors, and it appears that we
		     * have enough info to know what went wrong, generate
		     * diagnostic output.  ENOMEM observed on linux in
		     * processes constrained with ulimit.  It would be too
		     * unkind to abort the session, access to local files
		     * or through a proxy may still work.  - kw
		     */
		    if (
#ifdef NETDB_INTERNAL		/* linux glibc: defined in netdb.h */
			   (errno && h_errno == NETDB_INTERNAL) ||
#endif
			   (errno == ENOMEM &&
			    statuses.rehostentlen == 0 &&
		    /* should probably be NETDB_INTERNAL if child
		       memory exhausted, but we may find that
		       h_errno remains unchanged. - kw */
			    h_errno == -2)) {
#ifndef MULTINET
			HTInetStatus("CHILD gethostbyname");
#endif
			HTAlert(LYStrerror(statuses.child_errno));
			if (errno == ENOMEM) {
			    /*
			     * Not much point in continuing, right?  Fake a
			     * 'z', should shorten pointless guessing
			     * cycle.  - kw
			     */
			    LYFakeZap(YES);
			}
		    }
		}
#endif /* HAVE_H_ERRNO */
		if (statuses.rehostentlen != 0) {
		    /*
		     * Then get the full reorganized hostent.  -BL, kw
		     */
		    if ((*rehostent = malloc(statuses.rehostentlen)) == 0)
			outofmem(__FILE__, "setup_nsl_fork");
		    readret = (*readit) (pfd[0], *rehostent, statuses.rehostentlen);
#ifdef DEBUG_HOSTENT
		    dumpit("Read from pipe", *rehostent);
#endif
		    if (readret == statuses.rehostentlen) {
			got_rehostent = 1;
			lynx_nsl_status = HT_OK;
		    } else if (!statuses.h_errno_valid) {
			lynx_nsl_status = HT_INTERNAL;
		    }
		}
	    } else {
		lynx_nsl_status = HT_ERROR;
	    }
	    /*
	     * Make sure child is cleaned up.  -BL
	     */
	    if (!child_exited)
		waitret = waitpid(fpid, &waitstat, WNOHANG);
	    if (!WIFEXITED(waitstat) && !WIFSIGNALED(waitstat)) {
		kill(fpid, SIGTERM);
		waitret = waitpid(fpid, &waitstat, WNOHANG);
	    }
	    break;
	}

	/*
	 * Clean up if child exited before & no data received.  -BL
	 */
	if (child_exited) {
	    waitret = waitpid(fpid, &waitstat, WNOHANG);
	    break;
	}
	/*
	 * If child exited, loop once more looking for data.  -BL
	 */
	if ((waitret = waitpid(fpid, &waitstat, WNOHANG)) > 0) {
	    /*
	     * Data will be arriving right now, so make sure we don't
	     * short-circuit out for too many loops, and skip the interrupt
	     * check.  -BL
	     */
	    child_exited = 1;
	    continue;
	}

	/*
	 * Abort if interrupt key pressed.
	 */
	if (HTCheckForInterrupt()) {
	    CTRACE((tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n"));
	    kill(fpid, SIGTERM);
	    waitpid(fpid, NULL, WNOHANG);
	    close(pfd[0]);
	    lynx_nsl_status = HT_INTERRUPTED;
	    return FALSE;
	}
    }
    close(pfd[0]);
    if (waitret <= 0) {
	kill(fpid, SIGTERM);
	waitret = waitpid(fpid, &waitstat, WNOHANG);
    }
    if (waitret > 0) {
	if (WIFEXITED(waitstat)) {
	    CTRACE((tfp,
		    "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
		    (int) waitret, WEXITSTATUS(waitstat)));
	} else if (WIFSIGNALED(waitstat)) {
	    CTRACE((tfp,
		    "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		    (int) waitret, WTERMSIG(waitstat)));
#ifdef WCOREDUMP
	    if (WCOREDUMP(waitstat)) {
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d dumped core!\n",
			(int) waitret));
	    }
#endif /* WCOREDUMP */
	} else if (WIFSTOPPED(waitstat)) {
	    CTRACE((tfp,
		    "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
		    (int) waitret, WSTOPSIG(waitstat)));
	}
    }
    if (!got_rehostent) {
	goto failed;
    }
    return TRUE;
  failed:
    return FALSE;
}

/*
 * This is called via the child-side of the fork.
 */
static void really_gethostbyname(char *host,
				 char *port GCC_UNUSED,
				 STATUSES * statuses,
				 void **rehostent)
{
    LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */
    LYNX_HOSTENT *result = 0;

    (void) port;

    phost = gethostbyname(host);
    statuses->rehostentlen = 0;
    statuses->child_errno = errno;
    statuses->child_h_errno = h_errno;
#ifdef HAVE_H_ERRNO
    statuses->h_errno_valid = YES;
#endif
#ifdef MVS
    CTRACE((tfp, "really_gethostbyname() returned %d\n", phost));
#endif /* MVS */

#ifdef DEBUG_HOSTENT_CHILD
    dump_hostent("CHILD gethostbyname", phost);
#endif
    if (OK_HOST(phost)) {
	statuses->rehostentlen = fill_rehostent(rehostent, phost);
	result = (LYNX_HOSTENT *) (*rehostent);
#ifdef DEBUG_HOSTENT_CHILD
	dump_hostent("CHILD fill_rehostent", result);
#endif
    }
    if (statuses->rehostentlen <= sizeof(LYNX_HOSTENT) || !OK_HOST(result)) {
	statuses->rehostentlen = 0;
	statuses->h_length = 0;
    } else {
	statuses->h_length = result->h_length;
#ifdef HAVE_H_ERRNO
	if (h_errno == -2)	/* success, but h_errno unchanged? */
	    statuses->h_errno_valid = NO;
#endif
    }
}
#endif /* NSL_FORK */

/*	Resolve an internet hostname, like gethostbyname
 *	------------------------------------------------
 *
 *  On entry,
 *	host	points to the given host name, not numeric address,
 *		without colon or port number.
 *
 *  On exit,
 *	returns a pointer to a LYNX_HOSTENT in static storage,
 *	or NULL in case of error or user interruption.
 *
 *  The interface is intended to be exactly the same as for (Unix)
 *  gethostbyname(), except for the following:
 *
 *  If NSL_FORK is not used, the result of gethostbyname is returned
 *  directly.  Otherwise:
 *  All lists, addresses, and strings referred to by pointers in the
 *  returned struct are located, together with the returned struct
 *  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
 *  some info is omitted, but the function is careful to still return
 *  a valid structure, without truncating strings; it tries to return,
 *  in order of decreasing priority, the first address (h_addr_list[0]), the
 *  official name (h_name), the additional addresses, then alias names.
 *
 *  If NULL is returned, the reason is made available in the global
 *  variable lynx_nsl_status, with one of the following values:
 *	HT_INTERRUPTED		Interrupted by user
 *	HT_NOT_ACCEPTABLE	Hostname detected as invalid
 *				(also sets h_errno)
 *	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
 *				an appropriate value
 *	HT_ERROR		Resolver error, reason not known
 *	HT_INTERNAL		Internal error
 */
LYNX_HOSTENT *LYGetHostByName(char *host)
{

#ifdef NSL_FORK
    /* for transfer of result between from child to parent: */
    LYNX_HOSTENT *rehostent = 0;
#endif /* NSL_FORK */

    LYNX_HOSTENT *result_phost = NULL;

#ifdef __DJGPP__
    _resolve_hook = ResolveYield;
#endif

    if (!host) {
	CTRACE((tfp, "LYGetHostByName: Can't parse `NULL'.\n"));
	lynx_nsl_status = HT_INTERNAL;
	return NULL;
    }
    CTRACE((tfp, "LYGetHostByName: parsing `%s'.\n", host));

    /*  Could disable this if all our callers already check - kw */
    if (HTCheckForInterrupt()) {
	CTRACE((tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", host));
	lynx_nsl_status = HT_INTERRUPTED;
	return NULL;
    }

    if (!valid_hostname(host)) {
	lynx_nsl_status = HT_NOT_ACCEPTABLE;
#ifdef NO_RECOVERY
#ifdef _WINDOWS
	WSASetLastError(NO_RECOVERY);
#else
	h_errno = NO_RECOVERY;
#endif
#endif
	return NULL;
    }
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
    CTRACE((tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host));
#endif /* MVS */

    CTRACE_FLUSH(tfp);		/* so child messages will not mess up parent log */

    lynx_nsl_status = HT_INTERNAL;	/* should be set to something else below */

#ifdef NSL_FORK
    if (!setup_nsl_fork(really_gethostbyname,
			read_hostent,
			dump_hostent,
			host, NULL, (void **) &rehostent)) {
	goto failed;
    }
    result_phost = rehostent;
#else /* Not NSL_FORK: */

#ifdef _WINDOWS_NSL
    {
	HANDLE hThread;
	DWORD dwThreadID;

#ifndef __CYGWIN__
	if (!system_is_NT) {	/* for Windows9x */
	    unsigned long t;

	    t = (unsigned long) inet_addr(host);
	    if (t != INADDR_NONE)
		gbl_phost = gethostbyaddr((char *) &t, sizeof(t), AF_INET);
	    else
		gbl_phost = gethostbyname(host);
	} else {		/* for Windows NT */
#endif /* !__CYGWIN__ */
	    gbl_phost = (LYNX_HOSTENT *) NULL;
	    donelookup = FALSE;

#if defined(__CYGWIN__) || defined(USE_WINSOCK2_H)
	    SetLastError(WSAHOST_NOT_FOUND);
#else
	    WSASetLastError(WSAHOST_NOT_FOUND);
#endif

	    hThread = CreateThread(NULL, 4096UL, _fork_func, host, 0UL,
				   &dwThreadID);
	    if (!hThread)
		MessageBox(NULL, "CreateThread",
			   "CreateThread Failed", 0L);

	    while (!donelookup) {
		if (HTCheckForInterrupt()) {
		    /* Note that host is a character array and is not freed */
		    /* to avoid possible subthread problems: */
		    if (!CloseHandle(hThread)) {
			MessageBox((void *) NULL,
				   "CloseHandle", "CloseHandle Failed", 0L);
		    }
		    lynx_nsl_status = HT_INTERRUPTED;
		    return NULL;
		}
	    }
#ifndef __CYGWIN__
	}
#endif /* !__CYGWIN__ */
	if (gbl_phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = gbl_phost;
	} else {
	    lynx_nsl_status = HT_ERROR;
	    goto failed;
	}
    }

#else /* !NSL_FORK, !_WINDOWS_NSL: */
    {
	LYNX_HOSTENT *phost;

	phost = gethostbyname(host);	/* See netdb.h */
#ifdef MVS
	CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
#endif /* MVS */
	if (phost) {
	    lynx_nsl_status = HT_OK;
	    result_phost = phost;
	} else {
	    lynx_nsl_status = HT_H_ERRNO_VALID;
	    goto failed;
	}
    }
#endif /* !NSL_FORK, !_WINDOWS_NSL */
#endif /* !NSL_FORK */

#ifdef DEBUG_HOSTENT
    dump_hostent("LYGetHostByName", result_phost);
    CTRACE((tfp, "LYGetHostByName: Resolved name to a hostent.\n"));
#endif

    return result_phost;	/* OK */

  failed:
    CTRACE((tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
	    host));
    return NULL;
}

/*	Parse a network node address and port
 *	-------------------------------------
 *
 *  On entry,
 *	str	points to a string with a node name or number,
 *		with optional trailing colon and port number.
 *	soc_in	points to the binary internet or decnet address field.
 *
 *  On exit,
 *	*soc_in is filled in.  If no port is specified in str, that
 *		field is left unchanged in *soc_in.
 */
#ifndef INET6
static int HTParseInet(SockA * soc_in, const char *str)
{
    char *port;
    int dotcount_ip = 0;	/* for dotted decimal IP addr */
    char *strptr;
    char *host = NULL;

    if (!str) {
	CTRACE((tfp, "HTParseInet: Can't parse `NULL'.\n"));
	return -1;
    }
    CTRACE((tfp, "HTParseInet: parsing `%s'.\n", str));
    if (HTCheckForInterrupt()) {
	CTRACE((tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str));
	return -1;
    }
    StrAllocCopy(host, str);	/* Make a copy we can mutilate */
    /*
     * Parse port number if present.
     */
    if ((port = StrChr(host, ':')) != NULL) {
	*port++ = 0;		/* Chop off port */
	strptr = port;
	if (port[0] >= '0' && port[0] <= '9') {
#ifdef UNIX
	    soc_in->sin_port = (PortNumber) htons(strtol(port, &strptr, 10));
#else /* VMS: */
#ifdef DECNET
	    soc_in->sdn_objnum = (unsigned char) (strtol(port, &strptr, 10));
#else
	    soc_in->sin_port = htons((PortNumber) strtol(port, &strptr, 10));
#endif /* Decnet */
#endif /* Unix vs. VMS */
#ifdef SUPPRESS			/* 1. crashes!?!.  2. URL syntax has number not name */
	} else {
	    struct servent *serv = getservbyname(port, (char *) 0);

	    if (serv) {
		soc_in->sin_port = serv->s_port;
	    } else {
		CTRACE((tfp, "TCP: Unknown service %s\n", port));
	    }
#endif /* SUPPRESS */
	}
	if (strptr && *strptr != '\0') {
	    FREE(host);
	    HTAlwaysAlert(NULL, gettext("Address has invalid port"));
	    return -1;
	}
    }
#ifdef DECNET
    /*
     * Read Decnet node name.  @@@@ Should know about DECnet addresses, but it's
     * probably worth waiting until the Phase transition from IV to V.
     */
    soc_in->sdn_nam.n_len = min(DN_MAXNAML, strlen(host));	/* <=6 in phase 4 */
    StrNCpy(soc_in->sdn_nam.n_name, host, soc_in->sdn_nam.n_len + 1);
    CTRACE((tfp,
	    "DECnet: Parsed address as object number %d on host %.6s...\n",
	    soc_in->sdn_objnum, host));
#else /* parse Internet host: */

    if (*host >= '0' && *host <= '9') {		/* Test for numeric node address: */
	strptr = host;
	while (*strptr) {
	    if (*strptr == '.') {
		dotcount_ip++;
	    } else if (!isdigit(UCH(*strptr))) {
		break;
	    }
	    strptr++;
	}
	if (*strptr) {		/* found non-numeric, assume domain name */
	    dotcount_ip = 0;
	}
    }

    /*
     * Parse host number if present.
     */
    if (dotcount_ip == 3)	/* Numeric node address: */
    {
#ifdef DGUX_OLD
	soc_in->sin_addr.s_addr = inet_addr(host).s_addr;	/* See arpa/inet.h */
#else
#ifdef GUSI
	soc_in->sin_addr = inet_addr(host);	/* See netinet/in.h */
#else
#ifdef HAVE_INET_ATON
	if (!inet_aton(host, &(soc_in->sin_addr))) {
	    CTRACE((tfp, "inet_aton(%s) returns error\n", host));
	    FREE(host);
	    return -1;
	}
#else
	soc_in->sin_addr.s_addr = inet_addr(host);	/* See arpa/inet.h */
#endif /* HAVE_INET_ATON */
#endif /* GUSI */
#endif /* DGUX_OLD */
	FREE(host);
    } else {			/* Alphanumeric node name: */

#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
	CTRACE((tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host));
#endif /* MVS */

#ifdef _WINDOWS_NSL
	gbl_phost = LYGetHostByName(host);	/* See above */
	if (!gbl_phost)
	    goto failed;
	MemCpy((void *) &soc_in->sin_addr, gbl_phost->h_addr_list[0], gbl_phost->h_length);
#else /* !_WINDOWS_NSL */
	{
	    LYNX_HOSTENT *phost;

	    phost = LYGetHostByName(host);	/* See above */

	    if (!phost)
		goto failed;
	    if (phost->h_length != sizeof soc_in->sin_addr) {
		HTAlwaysAlert(host, gettext("Address length looks invalid"));
	    }
	    MemCpy((void *) &soc_in->sin_addr, phost->h_addr_list[0], phost->h_length);
	}
#endif /* _WINDOWS_NSL */

	FREE(host);
    }				/* Alphanumeric node name */

    CTRACE((tfp,
	    "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
	    (int) ntohs(soc_in->sin_port),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 0),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 1),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 2),
	    (int) *((unsigned char *) (&soc_in->sin_addr) + 3)));
#endif /* Internet vs. Decnet */

    return 0;			/* OK */

  failed:
    CTRACE((tfp, "HTParseInet: Can't find internet node name `%s'.\n",
	    host));
    FREE(host);
    switch (lynx_nsl_status) {
    case HT_NOT_ACCEPTABLE:
    case HT_INTERRUPTED:
	return lynx_nsl_status;
    default:
	return -1;
    }
}
#endif /* !INET6 */

#ifdef INET6

static void dump_addrinfo(const char *tag, void *data)
{
    LYNX_ADDRINFO *res;
    int count = 0;

    CTRACE((tfp, "dump_addrinfo %s:\n", tag));
    for (res = (LYNX_ADDRINFO *) data; res; res = res->ai_next) {
	char hostbuf[1024], portbuf[1024];

	++count;
	hostbuf[0] = '\0';
	portbuf[0] = '\0';
	getnameinfo(res->ai_addr, res->ai_addrlen,
		    hostbuf, (socklen_t) sizeof(hostbuf),
		    portbuf, (socklen_t) sizeof(portbuf),
		    NI_NUMERICHOST | NI_NUMERICSERV);

	CTRACE((tfp,
		"\t[%d] family %d, socktype %d, protocol %d addr %s port %s\n",
		count,
		res->ai_family,
		res->ai_socktype,
		res->ai_protocol,
		hostbuf,
		portbuf));
    }
}

#if defined(NSL_FORK)

/*
 * Copy the relevant information (on the child-side).
 */
static size_t fill_addrinfo(void **buffer,
			    const LYNX_ADDRINFO *phost)
{
    const LYNX_ADDRINFO *q;
    LYNX_ADDRINFO *actual;
    LYNX_ADDRINFO *result;
    int count = 0;
    int limit = 0;
    size_t need = sizeof(LYNX_ADDRINFO);
    char *heap;

    CTRACE((tfp, "filladdr_info %p\n", (const void *) phost));
    for (q = phost; q != 0; q = q->ai_next) {
	++limit;
	need += phost->ai_addrlen;
	need += sizeof(LYNX_ADDRINFO);
    }
    CTRACE((tfp, "...fill_addrinfo %d:%lu\n", limit, (unsigned long) need));

    if ((result = (LYNX_ADDRINFO *) calloc(1, need)) == 0)
	outofmem(__FILE__, "fill_addrinfo");

    *buffer = actual = result;
    heap = ((char *) actual) + ((size_t) limit * sizeof(LYNX_ADDRINFO));

    for (count = 0; count < limit; ++count) {

	/*
	 * copying the whole structure seems simpler but because it is not
	 * packed, uninitialized gaps make it hard to analyse with valgrind.
	 */
	/* *INDENT-EQLS* */
	actual->ai_flags    = phost->ai_flags;
	actual->ai_family   = phost->ai_family;
	actual->ai_socktype = phost->ai_socktype;
	actual->ai_protocol = phost->ai_protocol;
	actual->ai_addrlen  = phost->ai_addrlen;
	actual->ai_addr     = (struct sockaddr *) (void *) heap;

	MemCpy(heap, phost->ai_addr, phost->ai_addrlen);
	heap += phost->ai_addrlen;

	phost = phost->ai_next;

	actual->ai_next = ((count + 1 < limit)
			   ? (actual + 1)
			   : 0);
	++actual;
    }
    return (size_t) (heap - (char *) result);
}

/*
 * Read data, repair pointers as done in fill_addrinfo().
 */
static unsigned read_addrinfo(int fd, char *buffer, size_t length)
{
    unsigned result = read_bytes(fd, buffer, length);
    LYNX_ADDRINFO *actual = (LYNX_ADDRINFO *) (void *) buffer;
    LYNX_ADDRINFO *res;
    int count = 0;
    int limit;
    char *heap;

    CTRACE((tfp, "read_addrinfo length %lu\n", (unsigned long) length));
    for (limit = 0; actual[limit].ai_next; ++limit) {
    }
    ++limit;
    heap = (char *) (actual + limit);
    CTRACE((tfp, "...read_addrinfo %d items\n", limit));

    for (res = actual, count = 0; count < limit; ++count) {
	res->ai_addr = (struct sockaddr *) (void *) heap;
	heap += res->ai_addrlen;
	if (count < limit - 1) {
	    res->ai_next = (res + 1);
	    ++res;
	} else {
	    res->ai_next = 0;
	}
    }

#ifdef DEBUG_HOSTENT
    dump_addrinfo("read_addrinfo", buffer);
#endif
    return result;
}

/*
 * This is called via the child-side of the fork.
 */
static void really_getaddrinfo(char *host,
			       char *port,
			       STATUSES * statuses,
			       void **result)
{
    LYNX_ADDRINFO hints, *res;
    int error;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	CTRACE((tfp, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port,
		gai_strerror(error)));
    } else {
	statuses->child_errno = errno;
	statuses->child_h_errno = h_errno;
#ifdef HAVE_H_ERRNO
	statuses->h_errno_valid = YES;
#endif

#ifdef DEBUG_HOSTENT_CHILD
	dump_addrinfo("CHILD getaddrinfo", res);
#endif
	statuses->rehostentlen = fill_addrinfo(result, res);
#ifdef DEBUG_HOSTENT_CHILD
	dump_addrinfo("CHILD fill_addrinfo", (LYNX_ADDRINFO *) (*result));
#endif
	if (statuses->rehostentlen <= sizeof(LYNX_ADDRINFO)) {
	    statuses->rehostentlen = 0;
	    statuses->h_length = 0;
	} else {
	    statuses->h_length = (int) (((LYNX_ADDRINFO *) (*result))->ai_addrlen);
	}
    }
}
#endif /* NSL_FORK */

static LYNX_ADDRINFO *HTGetAddrInfo(const char *str,
				    const int defport)
{
#ifdef NSL_FORK
    /* for transfer of result between from child to parent: */
    void *readdrinfo = 0;

#else
    LYNX_ADDRINFO hints;
    int error;
#endif /* NSL_FORK */
    LYNX_ADDRINFO *res;
    char *p;
    char *s = NULL;
    char *host, *port;
    char pbuf[80];

    StrAllocCopy(s, str);

    if (s[0] == '[' && (p = StrChr(s, ']')) != NULL) {
	*p++ = '\0';
	host = s + 1;
    } else {
	p = s;
	host = &s[0];
    }
    port = strrchr(p, ':');
    if (port) {
	*port++ = '\0';
    } else {
	sprintf(pbuf, "%d", defport);
	port = pbuf;
    }

#ifdef NSL_FORK
    if (setup_nsl_fork(really_getaddrinfo,
		       read_addrinfo,
		       dump_addrinfo,
		       host, port, &readdrinfo)) {
	res = readdrinfo;
    } else {
	res = NULL;
    }
#else
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, port, &hints, &res);
    if (error || !res) {
	CTRACE((tfp, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port,
		gai_strerror(error)));
	res = NULL;
    }
#endif

    free(s);
#ifdef DEBUG_HOSTENT
    dump_addrinfo("HTGetAddrInfo", res);
#endif
    return res;
}
#endif /* INET6 */

#ifdef LY_FIND_LEAKS
/*	Free our name for the host on which we are - FM
 *	-------------------------------------------
 *
 */
static void free_HTTCP_hostname(void)
{
    FREE(hostname);
}
#endif /* LY_FIND_LEAKS */

/*	Derive the name of the host on which we are
 *	-------------------------------------------
 *
 */
static void get_host_details(void)
{
    char name[MAXHOSTNAMELEN + 1];	/* The name of this host */

#ifdef UCX
    char *domain_name;		/* The name of this host domain */
#endif /* UCX */
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
#ifdef INET6
    LYNX_ADDRINFO hints, *res;
    int error;

#else
    LYNX_HOSTENT *phost;	/* Pointer to host -- See netdb.h */
#endif /* INET6 */
#endif /* NEED_HOST_ADDRESS */
    size_t namelength = sizeof(name);

    if (hostname)
	return;			/* Already done */
    gethostname(name, namelength);	/* Without domain */
    StrAllocCopy(hostname, name);
#ifdef LY_FIND_LEAKS
    atexit(free_HTTCP_hostname);
#endif
#ifdef UCX
    /*
     * UCX doesn't give the complete domain name.  Get rest from UCX$BIND_DOM
     * logical.
     */
    if (StrChr(hostname, '.') == NULL) {	/* Not full address */
	domain_name = LYGetEnv("UCX$BIND_DOMAIN");
	if (domain_name == NULL)
	    domain_name = LYGetEnv("TCPIP$BIND_DOMAIN");
	if (domain_name != NULL) {
	    StrAllocCat(hostname, ".");
	    StrAllocCat(hostname, domain_name);
	}
    }
#endif /* UCX */
    CTRACE((tfp, "TCP: Local host name is %s\n", hostname));

#ifndef DECNET			/* Decnet ain't got no damn name server 8#OO */
#ifdef NEED_HOST_ADDRESS	/* no -- needs name server! */
#ifdef INET6
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    error = getaddrinfo(name, NULL, &hints, &res);
    if (error || !res || !res->ai_canonname) {
	CTRACE((tfp, "TCP: %s: `%s'\n", gai_strerror(error), name));
	if (res)
	    freeaddrinfo(res);
	return;			/* Fail! */
    }
    StrAllocCopy(hostname, res->ai_canonname);
    MemCpy(&HTHostAddress, res->ai_addr, res->ai_addrlen);
    freeaddrinfo(res);
#else
    phost = gethostbyname(name);	/* See netdb.h */
    if (!OK_HOST(phost)) {
	CTRACE((tfp,
		"TCP: Can't find my own internet node address for `%s'!!\n",
		name));
	return;			/* Fail! */
    }
    StrAllocCopy(hostname, phost->h_name);
    MemCpy(&HTHostAddress, &phost->h_addr_list[0], phost->h_length);
#endif /* INET6 */
    CTRACE((tfp, "     Name server says that I am `%s' = %s\n",
	    hostname, HTInetString(&HTHostAddress)));
#endif /* NEED_HOST_ADDRESS */

#endif /* !DECNET */
}

const char *HTHostName(void)
{
    get_host_details();
    return hostname;
}

#ifdef _WINDOWS
#define SET_EINTR WSASetLastError(EINTR)
#else
#define SET_EINTR SOCKET_ERRNO = EINTR
#endif

static BOOL HTWasInterrupted(int *status)
{
    BOOL result = FALSE;

    if (HTCheckForInterrupt()) {
	result = TRUE;
	*status = HT_INTERRUPTED;
	SET_EINTR;
    }
    return result;
}

#define TRIES_PER_SECOND 10

/*
 * Set the select-timeout to 0.1 seconds.
 */
static void set_timeout(struct timeval *timeoutp)
{
    timeoutp->tv_sec = 0;
    timeoutp->tv_usec = 100000;
}

#ifndef MULTINET		/* SOCKET_ERRNO != errno ? */
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE	/* show errno status after some system calls */
#endif /* UCX && VAXC */
#endif /* MULTINET */
/*
 *  Interruptible connect as implemented for Mosaic by Marc Andreesen
 *  and hacked in for Lynx years ago by Lou Montulli, and further
 *  modified over the years by numerous Lynx lovers. - FM
 */
int HTDoConnect(const char *url,
		const char *protocol,
		int default_port,
		int *s)
{
    int status = 0;
    char *line = NULL;
    char *p1 = NULL;
    char *at_sign = NULL;
    char *host = NULL;

#ifdef INET6
    LYNX_ADDRINFO *res = 0, *res0 = 0;

#else
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;

    /*
     * Set up defaults.
     */
    memset(soc_in, 0, sizeof(*soc_in));
    soc_in->sin_family = AF_INET;
    soc_in->sin_port = htons((PortNumber) default_port);
#endif /* INET6 */

    /*
     * Get node name and optional port number.
     */
    p1 = HTParse(url, "", PARSE_HOST);
    if ((at_sign = StrChr(p1, '@@')) != NULL) {
	/*
	 * If there's an @@ then use the stuff after it as a hostname.
	 */
	StrAllocCopy(host, (at_sign + 1));
    } else {
	StrAllocCopy(host, p1);
    }
    FREE(p1);

    HTSprintf0(&line, "%s%s", WWW_FIND_MESSAGE, host);
    _HTProgress(line);
#ifdef INET6
    /* HTParseInet() is useless! */
    res0 = HTGetAddrInfo(host, default_port);
    if (res0 == NULL) {
	HTSprintf0(&line, gettext("Unable to locate remote host %s."), host);
	_HTProgress(line);
	FREE(host);
	FREE(line);
	return HT_NO_DATA;
    }
#else
    status = HTParseInet(soc_in, host);
    if (status) {
	if (status != HT_INTERRUPTED) {
	    if (status == HT_NOT_ACCEPTABLE) {
		/* Not HTProgress, so warning won't be overwritten immediately;
		 * but not HTAlert, because typically there will be other
		 * alerts from the callers.  - kw
		 */
		HTUserMsg2(gettext("Invalid hostname %s"), host);
	    } else {
		HTSprintf0(&line,
			   gettext("Unable to locate remote host %s."), host);
		_HTProgress(line);
	    }
	    status = HT_NO_DATA;
	}
	FREE(host);
	FREE(line);
	return status;
    }
#endif /* INET6 */

    HTSprintf0(&line, gettext("Making %s connection to %s"), protocol, host);
    _HTProgress(line);
    FREE(host);
    FREE(line);

    /*
     * Now, let's get a socket set up from the server for the data.
     */
#ifndef INET6
    *s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (*s == -1) {
	HTAlert(gettext("socket failed."));
	return HT_NO_DATA;
    }
#else
    for (res = res0; res; res = res->ai_next) {
	*s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (*s == -1) {
	    char hostbuf[1024], portbuf[1024];

	    getnameinfo(res->ai_addr, res->ai_addrlen,
			hostbuf, (socklen_t) sizeof(hostbuf),
			portbuf, (socklen_t) sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    HTSprintf0(&line,
		       gettext("socket failed: family %d addr %s port %s."),
		       res->ai_family, hostbuf, portbuf);
	    _HTProgress(line);
	    FREE(line);
	    continue;
	}
#endif /* INET6 */

#if !defined(DOSPATH) || defined(__DJGPP__)
#if !defined(NO_IOCTL) || defined(USE_FCNTL)
	/*
	 * Make the socket non-blocking, so the connect can be canceled.  This
	 * means that when we issue the connect we should NOT have to wait for
	 * the accept on the other end.
	 */
	{
#ifdef USE_FCNTL
	    int ret = fcntl(*s, F_SETFL, O_NONBLOCK);

#else
	    int val = 1;
	    int ret = IOCTL(*s, FIONBIO, &val);
#endif /* USE_FCNTL */
	    if (ret == -1)
		_HTProgress(gettext("Could not make connection non-blocking."));
	}
#endif /* !NO_IOCTL || USE_FCNTL */
#endif /* !DOSPATH || __DJGPP__ */

	/*
	 * Issue the connect.  Since the server can't do an instantaneous
	 * accept and we are non-blocking, this will almost certainly return a
	 * negative status.
	 */
#ifdef SOCKS
	if (socks_flag) {
#ifdef INET6
	    status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
#else
	    status = Rconnect(*s, (struct sockaddr *) &soc_address,
			      sizeof(soc_address));
#ifndef SHORTENED_RBIND
	    socks_bind_remoteAddr = soc_address.sin_addr.s_addr;
#endif
#endif /* INET6 */
	} else
#endif /* SOCKS */
#ifdef INET6
	    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
	    status = connect(*s, (struct sockaddr *) &soc_address, sizeof(soc_address));
#endif /* INET6 */

	/*
	 * According to the Sun man page for connect:
	 *  EINPROGRESS         The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select(2) for  comple-
	 *                      tion  by  selecting the socket for writ-
	 *                      ing.
	 * According to the Motorola SVR4 man page for connect:
	 *  EAGAIN              The socket is non-blocking and the  con-
	 *                      nection cannot be completed immediately.
	 *                      It is possible to select for  completion
	 *                      by  selecting  the  socket  for writing.
	 *                      However, this is only  possible  if  the
	 *                      socket  STREAMS  module  is  the topmost
	 *                      module on  the  protocol  stack  with  a
	 *                      write  service  procedure.  This will be
	 *                      the normal case.
	 */
	if ((status < 0) &&
	    (SOCKET_ERRNO == EINPROGRESS
#ifdef EAGAIN
	     || SOCKET_ERRNO == EAGAIN
#endif
	    )) {
	    struct timeval select_timeout;
	    int ret;
	    int tries = 0;

#ifdef SOCKET_DEBUG_TRACE
	    HTInetStatus("this socket's first connect");
#endif /* SOCKET_DEBUG_TRACE */
	    ret = 0;
	    while (ret <= 0) {
		fd_set writefds;

		/*
		 * Protect against an infinite loop.
		 */
		if ((tries++ / TRIES_PER_SECOND) >= connect_timeout) {
		    HTAlert(gettext("Connection failed (too many retries)."));
#ifdef INET6
		    FREE(line);
#ifndef NSL_FORK
		    if (res0)
			freeaddrinfo(res0);
#endif
#endif /* INET6 */
		    return HT_NO_DATA;
		}
		set_timeout(&select_timeout);
		FD_ZERO(&writefds);
		FD_SET((unsigned) *s, &writefds);
#ifdef SOCKS
		if (socks_flag)
		    ret = Rselect(*s + 1, NULL,
				  &writefds, NULL, &select_timeout);
		else
#endif /* SOCKS */
		    ret = select(*s + 1,
				 NULL,
				 &writefds,
				 NULL,
				 &select_timeout);

#ifdef SOCKET_DEBUG_TRACE
		if (tries == 1) {
		    HTInetStatus("this socket's first select");
		}
#endif /* SOCKET_DEBUG_TRACE */
		/*
		 * If we suspend, then it is possible that select will be
		 * interrupted.  Allow for this possibility.  - JED
		 */
		if ((ret == -1) && (errno == EINTR))
		    continue;

#ifdef SOCKET_DEBUG_TRACE
		if (ret < 0) {
		    HTInetStatus("failed select");
		}
#endif /* SOCKET_DEBUG_TRACE */
		/*
		 * Again according to the Sun and Motorola man pages for
		 * connect:
		 *  EALREADY    The socket is non-blocking and a  previ-
		 *              ous  connection attempt has not yet been
		 *              completed.
		 * Thus if the SOCKET_ERRNO is NOT EALREADY we have a real
		 * error, and should break out here and return that error.
		 * Otherwise if it is EALREADY keep on trying to complete the
		 * connection.
		 */
		if ((ret < 0) && (SOCKET_ERRNO != EALREADY)) {
		    status = ret;
		    break;
		} else if (ret > 0) {
		    /*
		     * Extra check here for connection success, if we try to
		     * connect again, and get EISCONN, it means we have a
		     * successful connection.  But don't check with SOCKS.
		     */
#ifdef SOCKS
		    if (socks_flag) {
			status = 0;
		    } else {
#endif /* SOCKS */
#ifdef INET6
			status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
			status = connect(*s, (struct sockaddr *) &soc_address,
					 sizeof(soc_address));
#endif /* INET6 */
#ifdef UCX
			/*
			 * A UCX feature:  Instead of returning EISCONN UCX
			 * returns EADDRINUSE.  Test for this status also.
			 */
			if ((status < 0) && ((SOCKET_ERRNO == EISCONN) ||
					     (SOCKET_ERRNO == EADDRINUSE)))
#else
			if ((status < 0) && (SOCKET_ERRNO == EISCONN))
#endif /* UCX */
			{
			    status = 0;
			}

			if (status && (SOCKET_ERRNO == EALREADY))	/* new stuff LJM */
			    ret = 0;	/* keep going */
			else {
#ifdef SOCKET_DEBUG_TRACE
			    if (status < 0) {
				HTInetStatus("confirm-ready connect");
			    }
#endif /* SOCKET_DEBUG_TRACE */
			    break;
			}
#ifdef SOCKS
		    }
#endif /* SOCKS */
		}
#ifdef SOCKS
		else if (!socks_flag)
#else
		else
#endif /* SOCKS */
		{
		    /*
		     * The select says we aren't ready yet.  Try to connect
		     * again to make sure.  If we don't get EALREADY or
		     * EISCONN, something has gone wrong.  Break out and report
		     * it.
		     *
		     * For some reason, SVR4 returns EAGAIN here instead of
		     * EALREADY, even though the man page says it should be
		     * EALREADY.
		     *
		     * For some reason, UCX pre 3 apparently returns errno =
		     * 18242 instead of EALREADY or EISCONN.
		     */
#ifdef INET6
		    status = connect(*s, res->ai_addr, res->ai_addrlen);
#else
		    status = connect(*s, (struct sockaddr *) &soc_address,
				     sizeof(soc_address));
#endif /* INET6 */
		    if ((status < 0) &&
			(SOCKET_ERRNO != EALREADY
#ifdef EAGAIN
			 && SOCKET_ERRNO != EAGAIN
#endif
			) &&
#ifdef UCX
			(SOCKET_ERRNO != 18242) &&
#endif /* UCX */
			(SOCKET_ERRNO != EISCONN)) {
#ifdef SOCKET_DEBUG_TRACE
			HTInetStatus("confirm-not-ready connect");
#endif /* SOCKET_DEBUG_TRACE */
			break;
		    }
		}
		if (HTWasInterrupted(&status)) {
		    CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
		    break;
		}
	    }
	}
#ifdef SOCKET_DEBUG_TRACE
	else if (status < 0) {
	    HTInetStatus("this socket's first and only connect");
	}
#endif /* SOCKET_DEBUG_TRACE */
#ifdef INET6
	if (status < 0) {
	    NETCLOSE(*s);
	    *s = -1;
	    continue;
	}
	break;
    }
#endif /* INET6 */

#ifdef INET6
    if (*s < 0)
#else
    if (status < 0)
#endif /* INET6 */
    {
	/*
	 * The connect attempt failed or was interrupted, so close up the
	 * socket.
	 */
	NETCLOSE(*s);
    }
#if !defined(DOSPATH) || defined(__DJGPP__)
#if !defined(NO_IOCTL) || defined(USE_FCNTL)
    else {
	/*
	 * Make the socket blocking again on good connect.
	 */
#ifdef USE_FCNTL
	int ret = fcntl(*s, F_SETFL, 0);

#else
	int val = 0;
	int ret = IOCTL(*s, FIONBIO, &val);
#endif /* USE_FCNTL */
	if (ret == -1)
	    _HTProgress(gettext("Could not restore socket to blocking."));
    }
#endif /* !NO_IOCTL || USE_FCNTL */
#endif /* !DOSPATH || __DJGPP__ */

#ifdef INET6
    FREE(line);
#ifndef NSL_FORK
    if (res0)
	freeaddrinfo(res0);
#endif
#endif /* INET6 */
    return status;
}

/*
 *  This is so interruptible reads can be implemented cleanly.
 */
int HTDoRead(int fildes,
	     void *buf,
	     unsigned nbyte)
{
    int result;
    BOOL ready;

#if !defined(NO_IOCTL)
    int ret;
    fd_set readfds;
    struct timeval select_timeout;
    int tries = 0;

#ifdef USE_READPROGRESS
    int otries = 0;
    time_t otime = time((time_t *) 0);
    time_t start = otime;
#endif
#endif /* !NO_IOCTL */

#if defined(UNIX) && !defined(__BEOS__)
    if (fildes == 0) {
	/*
	 * 0 can be a valid socket fd, but if it's a tty something must have
	 * gone wrong.  - kw
	 */
	if (isatty(fildes)) {
	    CTRACE((tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n"));
	    return -1;
	}
    } else
#endif
    if (fildes <= 0) {
	CTRACE((tfp, "HTDoRead - no file descriptor!\n"));
	return -1;
    }

    if (HTWasInterrupted(&result)) {
	CTRACE((tfp, "HTDoRead - interrupted before starting!\n"));
	return (result);
    }
#if defined(NO_IOCTL)
    ready = TRUE;
#else
    ready = FALSE;
    while (!ready) {
	/*
	 * Protect against an infinite loop.
	 */
	if ((tries++ / TRIES_PER_SECOND) >= reading_timeout) {
	    HTAlert(gettext("Socket read failed (too many tries)."));
	    SET_EINTR;
	    result = HT_INTERRUPTED;
	    break;
	}
#ifdef USE_READPROGRESS
	if (tries - otries > TRIES_PER_SECOND) {
	    time_t t = time((time_t *) 0);

	    otries = tries;
	    if (t - otime >= 5) {
		otime = t;
		HTReadProgress((off_t) (-1), (off_t) 0);	/* Put "stalled" message */
	    }
	}
#endif

	/*
	 * If we suspend, then it is possible that select will be interrupted.
	 * Allow for this possibility.  - JED
	 */
	do {
	    set_timeout(&select_timeout);
	    FD_ZERO(&readfds);
	    FD_SET((unsigned) fildes, &readfds);
#ifdef SOCKS
	    if (socks_flag)
		ret = Rselect(fildes + 1,
			      &readfds, NULL, NULL, &select_timeout);
	    else
#endif /* SOCKS */
		ret = select(fildes + 1,
			     &readfds, NULL, NULL, &select_timeout);
	} while ((ret == -1) && (errno == EINTR));

	if (ret < 0) {
	    result = -1;
	    break;
	} else if (ret > 0) {
	    ready = TRUE;
	} else if (HTWasInterrupted(&result)) {
	    break;
	}
    }
#endif /* !NO_IOCTL */

    if (ready) {
#if defined(UCX) && defined(VAXC)
	/*
	 * VAXC and UCX problem only.
	 */
	errno = vaxc$errno = 0;
	result = SOCKET_READ(fildes, buf, nbyte);
	CTRACE((tfp,
		"Read - result,errno,vaxc$errno: %d %d %d\n", result, errno, vaxc$errno));
	if ((result <= 0) && TRACE)
	    perror("HTTCP.C:HTDoRead:read");	/* RJF */
	/*
	 * An errno value of EPIPE and result < 0 indicates end-of-file on VAXC.
	 */
	if ((result <= 0) && (errno == EPIPE)) {
	    result = 0;
	    set_errno(0);
	}
#else
#ifdef UNIX
	while ((result = (int) SOCKET_READ(fildes, buf, nbyte)) == -1) {
	    if (errno == EINTR)
		continue;
#ifdef ERESTARTSYS
	    if (errno == ERESTARTSYS)
		continue;
#endif /* ERESTARTSYS */
	    HTInetStatus("read");
	    break;
	}
#else /* UNIX */
	result = SOCKET_READ(fildes, buf, nbyte);
#endif /* !UNIX */
#endif /* UCX && VAXC */
    }
#ifdef USE_READPROGRESS
    CTRACE2(TRACE_TIMING, (tfp, "...HTDoRead returns %d (%" PRI_time_t
			   " seconds)\n",
			   result, CAST_time_t (time((time_t *)0) - start)));
#endif
    return result;
}

#ifdef SVR4_BSDSELECT
/*
 *  This is a fix for the difference between BSD's select() and
 *  SVR4's select().  SVR4's select() can never return a value larger
 *  than the total number of file descriptors being checked.  So, if
 *  you select for read and write on one file descriptor, and both
 *  are true, SVR4 select() will only return 1.  BSD select in the
 *  same situation will return 2.
 *
 *	Additionally, BSD select() on timing out, will zero the masks,
 *	while SVR4 does not.  This is fixed here as well.
 *
 *	Set your tabstops to 4 characters to have this code nicely formatted.
 *
 *	Jerry Whelan, guru@@bradley.edu, June 12th, 1993
 */
#ifdef select
#undef select
#endif /* select */

#ifdef SOCKS
#ifdef Rselect
#undef Rselect
#endif /* Rselect */
#endif /* SOCKS */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/select.h>

int BSDselect(int nfds,
	      fd_set * readfds,
	      fd_set * writefds,
	      fd_set * exceptfds,
	      struct timeval *select_timeout)
{
    int rval, i;

#ifdef SOCKS
    if (socks_flag)
	rval = Rselect(nfds, readfds, writefds, exceptfds, select_timeout);
    else
#endif /* SOCKS */
	rval = select(nfds, readfds, writefds, exceptfds, select_timeout);

    switch (rval) {
    case -1:
	return (rval);

    case 0:
	if (readfds != NULL)
	    FD_ZERO(readfds);
	if (writefds != NULL)
	    FD_ZERO(writefds);
	if (exceptfds != NULL)
	    FD_ZERO(exceptfds);
	return (rval);

    default:
	for (i = 0, rval = 0; i < nfds; i++) {
	    if ((readfds != NULL) && FD_ISSET(i, readfds))
		rval++;
	    if ((writefds != NULL) && FD_ISSET(i, writefds))
		rval++;
	    if ((exceptfds != NULL) && FD_ISSET(i, exceptfds))
		rval++;

	}
	return (rval);
    }
/* Should never get here */
}
#endif /* SVR4_BSDSELECT */
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTTCP.c,v 1.98 2008/12/07 21:10:36 tom Exp $
a79 3
/* PUBLIC SockA HTHostAddress; *//* The internet address of the host */
					/* Valid after call to HTHostName() */

d260 1
a260 1
	n = n * 10 + *((*pp)++) - '0';
d285 3
a287 1
		hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
d351 9
a359 1
#ifdef NSL_FORK
d365 1
d370 1
a370 1
#endif /* NSL_FORK */
a377 2
 *  Two auxiliary functions for name lookup and LYNX_HOSTENT.
 *
d383 1
a383 1
			 const LYNX_HOSTENT *phost)
d388 1
d440 80
d537 1
a537 2
static size_t fill_rehostent(char *rehostent,
			     size_t rehostentsize,
d540 1
a540 1
    AlignedHOSTENT *data = (AlignedHOSTENT *) rehostent;
d543 1
a543 1
    char **pcnt;
d547 2
a548 5
    size_t required_per_addr;
    size_t curlen = sizeof(LYNX_HOSTENT);
    size_t available = rehostentsize - curlen;
    size_t chk_available, mem_this_alias, required_this_alias;
    int i_addr, i_alias;
a551 1
    required_per_addr = phost->h_length + sizeof(char *);
a552 14
    if (phost->h_addr_list)
	available -= sizeof(phost->h_addr_list[0]);
    if (phost->h_aliases)
	available -= sizeof(phost->h_aliases[0]);
    if (phost->h_name)
	available--;
    if (phost->h_addr_list) {
	if (phost->h_addr_list[0]) {
	    if (available >= required_per_addr) {
		num_addrs++;
		available -= required_per_addr;
	    }
	}
    }
d555 1
a555 5
	if (available >= name_len) {
	    available -= name_len;
	} else {
	    name_len = 0;
	}
d557 3
a559 8
    if (num_addrs) {
	for (pcnt = phost->h_addr_list + 1; *pcnt; pcnt++) {
	    if (available >= required_per_addr) {
		num_addrs++;
		available -= required_per_addr;
	    } else {
		break;
	    }
d561 2
a563 1
    chk_available = available;
d565 3
a567 7
	for (pcnt = phost->h_aliases; *pcnt; pcnt++) {
	    required_this_alias = sizeof(phost->h_aliases[0]) +
		strlen(*pcnt) + 1;
	    if (chk_available >= required_this_alias) {
		num_aliases++;
		chk_available -= required_this_alias;
	    }
d569 1
d572 13
a584 4
    data->h.h_addrtype = phost->h_addrtype;
    data->h.h_length = phost->h_length;
    p_next_charptr = (char **) (rehostent + curlen);
    p_next_char = rehostent + curlen;
d586 1
a586 1
	p_next_char += (num_addrs + 1) * sizeof(phost->h_addr_list[0]);
d588 7
a594 1
	p_next_char += (num_aliases + 1) * sizeof(phost->h_aliases[0]);
d597 3
a599 5
	data->h.h_addr_list = p_next_charptr;
	for (pcnt = phost->h_addr_list, i_addr = 0;
	     i_addr < num_addrs;
	     pcnt++, i_addr++) {
	    memcpy(p_next_char, *pcnt, sizeof(phost->h_addr_list[0]));
d601 1
a601 14
	    p_next_char += sizeof(phost->h_addr_list[0]);
	}
	*p_next_charptr++ = NULL;
    } else {
	data->h.h_addr_list = NULL;
    }

    if (phost->h_name) {
	data->h.h_name = p_next_char;
	if (name_len) {
	    strcpy(p_next_char, phost->h_name);
	    p_next_char += name_len + 1;
	} else {
	    *p_next_char++ = '\0';
d603 1
a603 2
    } else {
	data->h.h_name = NULL;
d607 5
a611 15
	data->h.h_aliases = p_next_charptr;
	for (pcnt = phost->h_aliases, i_alias = 0;
	     (*pcnt && i_alias < num_addrs);
	     pcnt++, i_alias++) {
	    mem_this_alias = strlen(*pcnt) + 1;
	    required_this_alias = sizeof(phost->h_aliases[0]) +
		mem_this_alias;
	    if (available >= required_this_alias) {
		i_alias++;
		available -= required_this_alias;
		strcpy(p_next_char, *pcnt);
		*p_next_charptr++ = p_next_char;
		p_next_char += mem_this_alias;
	    }
	    p_next_char += sizeof(phost->h_aliases[0]);
a612 3
	*p_next_charptr++ = NULL;
    } else {
	data->h.h_aliases = NULL;
d614 1
a614 2
    curlen = p_next_char - (char *) rehostent;
    return curlen;
d616 1
d647 1
a647 1
	rehostentlen = fill_rehostent(rehostent, REHOSTENT_SIZE, gbl_phost);
d660 2
a661 1
#endif /* NSL_FORK */
d674 6
a679 59
/*
 * Even though it is a small amount, we cannot count on reading the whole
 * struct via a pipe in one read -TD
 */
#ifdef NSL_FORK
static unsigned readit(int fd, char *buffer, unsigned length)
{
    unsigned result = 0;

    while (length != 0) {
	unsigned got = read(fd, buffer, length);

	if (got != 0) {
	    result += got;
	    buffer += got;
	    length -= got;
	} else {
	    break;
	}
    }
    return result;
}
#endif /* NSL_FORK */

/*	Resolve an internet hostname, like gethostbyname
 *	------------------------------------------------
 *
 *  On entry,
 *	str	points to the given host name, not numeric address,
 *		without colon or port number.
 *
 *  On exit,
 *	returns a pointer to a LYNX_HOSTENT in static storage,
 *	or NULL in case of error or user interruption.
 *
 *  The interface is intended to be exactly the same as for (Unix)
 *  gethostbyname(), except for the following:
 *
 *  If NSL_FORK is not used, the result of gethostbyname is returned
 *  directly.  Otherwise:
 *  All lists, addresses, and strings referred to by pointers in the
 *  returned struct are located, together with the returned struct
 *  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
 *  some info is omitted, but the function is careful to still return
 *  a valid structure, without truncating strings; it tries to return,
 *  in order of decreasing priority, the first address (h_addr_list[0]), the
 *  official name (h_name), the additional addresses, then alias names.
 *
 *  If NULL is returned, the reason is made available in the global
 *  variable lynx_nsl_status, with one of the following values:
 *	HT_INTERRUPTED		Interrupted by user
 *	HT_NOT_ACCEPTABLE	Hostname detected as invalid
 *				(also sets h_errno)
 *	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
 *				an appropriate value
 *	HT_ERROR		Resolver error, reason not known
 *	HT_INTERNAL		Internal error
 */
LYNX_HOSTENT *LYGetHostByName(char *str)
d681 1
a681 5
    char *host = str;

#ifdef NSL_FORK
    /* for transfer of result between from child to parent: */
    static AlignedHOSTENT aligned_full_rehostent;
d684 2
a685 10
     * We could define rehosten directly as a static char
     * rehostent[REHOSTENT_SIZE], but the indirect approach via the above
     * struct should automatically take care of alignment requirements.
     * Note that, in addition,
     * - this must be static, as we shall return a pointer to it which must
     *   remain valid, and
     * - we have to use the same rehostent in the child process as in the
     *   parent (its address in the parent's address space must be the same as
     *   in the child's, otherwise the internal pointers built by the child's
     *   call to fill_rehostent would be invalid when seen by the parent).  -kw
d687 1
a687 1
    char *rehostent = (char *) &aligned_full_rehostent;
d689 3
a691 16
    /* for transfer of status from child to parent: */
    struct _statuses {
	size_t rehostentlen;
	int h_length;
	int child_errno;	/* sometimes useful to pass this on */
	int child_h_errno;
	BOOL h_errno_valid;
    } statuses;

    size_t rehostentlen = 0;
#endif /* NSL_FORK */

    LYNX_HOSTENT *result_phost = NULL;

#ifdef __DJGPP__
    _resolve_hook = ResolveYield;
d693 7
d701 2
a702 13
    if (!str) {
	CTRACE((tfp, "LYGetHostByName: Can't parse `NULL'.\n"));
	lynx_nsl_status = HT_INTERNAL;
	return NULL;
    }
    CTRACE((tfp, "LYGetHostByName: parsing `%s'.\n", str));

    /*  Could disable this if all our callers already check - kw */
    if (HTCheckForInterrupt()) {
	CTRACE((tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str));
	lynx_nsl_status = HT_INTERRUPTED;
	return NULL;
    }
a703 5
    if (!valid_hostname(host)) {
	lynx_nsl_status = HT_NOT_ACCEPTABLE;
#ifdef NO_RECOVERY
#ifdef _WINDOWS
	WSASetLastError(NO_RECOVERY);
d705 1
a705 1
	h_errno = NO_RECOVERY;
d707 5
a711 6
#endif
	return NULL;
    }
#ifdef MVS			/* Outstanding problem with crash in MVS gethostbyname */
    CTRACE((tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host));
#endif /* MVS */
d713 2
a714 3
    CTRACE_FLUSH(tfp);		/* so child messages will not mess up parent log */

    lynx_nsl_status = HT_INTERNAL;	/* should be set to something else below */
a715 2
#ifdef NSL_FORK
    statuses.h_errno_valid = NO;
d717 6
a722 2
     * Start block for fork-based gethostbyname() with checks for interrupts.
     * - Tom Zerucha (tz@@execpc.com) & FM
d724 4
a727 38
    {
	int got_rehostent = 0;

#if HAVE_SIGACTION
	sigset_t old_sigset;
	sigset_t new_sigset;
#endif
	/*
	 * Pipe, child pid, status buffers, start time, select() control
	 * variables.
	 */
	int fpid, waitret;
	int pfd[2], selret, readret;

#ifdef HAVE_TYPE_UNIONWAIT
	union wait waitstat;

#else
	int waitstat = 0;
#endif
	time_t start_time = time((time_t *) 0);
	fd_set readfds;
	struct timeval one_second;
	long dns_patience = 30;	/* how many seconds will we wait for DNS? */
	int child_exited = 0;

	/*
	 * Reap any children that have terminated since last time through.
	 * This might include children that we killed, then waited with WNOHANG
	 * before they were actually ready to be reaped.  (Should be max of 1
	 * in this state, but the loop is safe if waitpid() is implemented
	 * correctly:  returns 0 when children exist but none have exited; -1
	 * with errno == ECHILD when no children.) -BL
	 */
	do {
	    waitret = waitpid(-1, 0, WNOHANG);
	} while (waitret > 0 || (waitret == -1 && errno == EINTR));
	waitret = 0;
d729 1
a729 1
	pipe(pfd);
d732 12
a743 12
	/*
	 * Attempt to prevent a rare situation where the child could execute
	 * the Lynx signal handlers because it gets killed before it even has a
	 * chance to reset its handlers, resulting in bogus 'Exiting via
	 * interrupt' message and screen corruption or worse.
	 * Should that continue to be reported, for systems without
	 * sigprocmask(), we need to find a different solutions for those.  -
	 * kw 19990430
	 */
	sigemptyset(&new_sigset);
	sigaddset(&new_sigset, SIGTERM);
	sigaddset(&new_sigset, SIGINT);
d745 1
a745 1
	sigaddset(&new_sigset, SIGHUP);
d748 1
a748 1
	sigaddset(&new_sigset, SIGTSTP);
d751 1
a751 1
	sigaddset(&new_sigset, SIGWINCH);
d753 1
a753 1
	sigprocmask(SIG_BLOCK, &new_sigset, &old_sigset);
d756 7
a762 2
	if ((fpid = fork()) == 0) {
	    LYNX_HOSTENT *phost;	/* Pointer to host - See netdb.h */
d764 7
a770 14
	    /*
	     * Child - for the long call.
	     *
	     * Make sure parent can kill us at will.  -BL
	     */
	    (void) signal(SIGTERM, quench);

	    /*
	     * Also make sure the child does not run one of the signal handlers
	     * that may have been installed by Lynx if one of those signals
	     * occurs.  For example we don't want the child to remove temp
	     * files on ^C, let the parent deal with that.  - kw
	     */
	    (void) signal(SIGINT, quench);
d772 1
a772 1
	    (void) signal(SIGHUP, quench);
d775 4
a778 4
	    if (no_suspend)
		(void) signal(SIGTSTP, SIG_IGN);
	    else
		(void) signal(SIGTSTP, SIG_DFL);
d781 1
a781 1
	    (void) signal(SIGWINCH, SIG_IGN);
d785 1
a785 1
	    signal(SIGBUS, SIG_DFL);
d788 2
a789 2
	    signal(SIGSEGV, SIG_DFL);
	    signal(SIGILL, SIG_DFL);
d792 2
a793 2
	    /* Restore signal mask to whatever it was before the fork. -kw */
	    sigprocmask(SIG_SETMASK, &old_sigset, NULL);
d796 4
a799 4
	    /*
	     * Child won't use read side.  -BL
	     */
	    close(pfd[0]);
d801 2
a802 2
	    /* to detect cases when it doesn't get set although it should */
	    h_errno = -2;
d804 8
a811 2
	    set_errno(0);
	    phost = gethostbyname(host);
d813 1
a813 7
	    statuses.child_h_errno = h_errno;
#ifdef HAVE_H_ERRNO
	    statuses.h_errno_valid = YES;
#endif
#ifdef MVS
	    CTRACE((tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost));
#endif /* MVS */
d815 8
a822 20
#ifdef DEBUG_HOSTENT_CHILD
	    dump_hostent("CHILD gethostbyname", phost);
#endif
	    if (OK_HOST(phost)) {
		rehostentlen = fill_rehostent(rehostent, REHOSTENT_SIZE, phost);
#ifdef DEBUG_HOSTENT_CHILD
		dump_hostent("CHILD fill_rehostent", (LYNX_HOSTENT *) rehostent);
#endif
	    }
	    if (rehostentlen <= sizeof(LYNX_HOSTENT) ||
		!OK_HOST((LYNX_HOSTENT *) rehostent)) {
		rehostentlen = 0;
		statuses.h_length = 0;
	    } else {
		statuses.h_length = ((LYNX_HOSTENT *) rehostent)->h_length;
#ifdef HAVE_H_ERRNO
		if (h_errno == -2)	/* success, but h_errno unchanged? */
		    statuses.h_errno_valid = NO;
#endif
	    }
d824 1
a824 3
	     * Send variables indicating status of lookup to parent.  That
	     * includes rehostentlen, which the parent will use as the size for
	     * the second read (if > 0).
d826 1
a826 18
	    if (!statuses.child_errno)
		statuses.child_errno = errno;
	    statuses.rehostentlen = rehostentlen;
	    write(pfd[1], &statuses, sizeof(statuses));

	    if (rehostentlen) {
		/*
		 * Return our resulting rehostent through pipe...
		 */
		write(pfd[1], rehostent, rehostentlen);
		close(pfd[1]);
		_exit(0);
	    } else {
		/*
		 * ...  or return error as exit code.
		 */
		_exit(1);
	    }
d828 1
d830 5
a834 5
	/*
	 * (parent) Restore signal mask to whatever it was before the fork.  -
	 * kw
	 */
	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
d837 4
a840 4
	/*
	 * (parent) Wait until lookup finishes, or interrupt, or cycled too
	 * many times (just in case) -BL
	 */
d842 1
a842 1
	close(pfd[1]);		/* parent won't use write side -BL */
d844 4
a847 4
	if (fpid < 0) {		/* fork failed */
	    close(pfd[0]);
	    goto failed;
	}
d849 1
a849 1
	while (child_exited || (long) (time((time_t *) 0) - start_time) < dns_patience) {
d851 13
a863 13
	    FD_ZERO(&readfds);
	    /*
	     * This allows us to abort immediately, not after 1-second timeout,
	     * when user hits abort key.  Can't do this when using SLANG (or at
	     * least I don't know how), so SLANG users must live with up-to-1s
	     * timeout.  -BL
	     *
	     * Whoops -- we need to make sure stdin is actually selectable!
	     * /dev/null isn't, on some systems, which makes some useful Lynx
	     * invocations fail.  -BL
	     */
	    {
		int kbd_fd = LYConsoleInputFD(TRUE);
d865 2
a866 3
		if (kbd_fd != INVSOC) {
		    FD_SET(kbd_fd, &readfds);
		}
d868 1
d870 3
a872 3
	    one_second.tv_sec = 1;
	    one_second.tv_usec = 0;
	    FD_SET(pfd[0], &readfds);
d874 5
a878 5
	    /*
	     * Return when data received, interrupted, or failed.  If nothing
	     * is waiting, we sleep for 1 second in select(), to be nice to the
	     * system.  -BL
	     */
d880 3
a882 3
	    if (socks_flag)
		selret = Rselect(pfd[0] + 1, &readfds, NULL, NULL, &one_second);
	    else
d884 1
a884 1
		selret = select(pfd[0] + 1, &readfds, NULL, NULL, &one_second);
d886 8
a893 8
	    if ((selret > 0) && FD_ISSET(pfd[0], &readfds)) {
		/*
		 * First get status, including length of address.  -BL, kw
		 */
		readret = readit(pfd[0], (char *) &statuses, sizeof(statuses));
		if (readret == sizeof(statuses)) {
		    h_errno = statuses.child_h_errno;
		    set_errno(statuses.child_errno);
d895 12
a906 12
		    if (statuses.h_errno_valid) {
			lynx_nsl_status = HT_H_ERRNO_VALID;
			/*
			 * If something went wrong in the child process other
			 * than normal lookup errors, and it appears that we
			 * have enough info to know what went wrong, generate
			 * diagnostic output.  ENOMEM observed on linux in
			 * processes constrained with ulimit.  It would be too
			 * unkind to abort the session, access to local files
			 * or through a proxy may still work.  - kw
			 */
			if (
d908 1
a908 1
			       (errno && h_errno == NETDB_INTERNAL) ||
d910 6
a915 6
			       (errno == ENOMEM &&
				statuses.rehostentlen == 0 &&
			/* should probably be NETDB_INTERNAL if child
			   memory exhausted, but we may find that
			   h_errno remains unchanged. - kw */
				h_errno == -2)) {
d917 1
a917 1
			    HTInetStatus("CHILD gethostbyname");
d919 8
a926 9
			    HTAlert(LYStrerror(statuses.child_errno));
			    if (errno == ENOMEM) {
				/*
				 * Not much point in continuing, right?  Fake a
				 * 'z', should shorten pointless guessing
				 * cycle.  - kw
				 */
				LYFakeZap(YES);
			    }
d929 1
d931 7
a937 5
		    if (statuses.rehostentlen > sizeof(LYNX_HOSTENT)) {
			/*
			 * Then get the full reorganized hostent.  -BL, kw
			 */
			readret = readit(pfd[0], rehostent, statuses.rehostentlen);
d939 1
a939 1
			dump_hostent("Read from pipe", (LYNX_HOSTENT *) rehostent);
d941 5
a945 7
			if (readret == (int) statuses.rehostentlen) {
			    got_rehostent = 1;
			    result_phost = (LYNX_HOSTENT *) rehostent;
			    lynx_nsl_status = HT_OK;
			} else if (!statuses.h_errno_valid) {
			    lynx_nsl_status = HT_INTERNAL;
			}
a946 2
		} else {
		    lynx_nsl_status = HT_ERROR;
d948 2
a949 10
		/*
		 * Make sure child is cleaned up.  -BL
		 */
		if (!child_exited)
		    waitret = waitpid(fpid, &waitstat, WNOHANG);
		if (!WIFEXITED(waitstat) && !WIFSIGNALED(waitstat)) {
		    kill(fpid, SIGTERM);
		    waitret = waitpid(fpid, &waitstat, WNOHANG);
		}
		break;
a950 1

d952 1
a952 1
	     * Clean up if child exited before & no data received.  -BL
d954 4
a957 1
	    if (child_exited) {
a958 13
		break;
	    }
	    /*
	     * If child exited, loop once more looking for data.  -BL
	     */
	    if ((waitret = waitpid(fpid, &waitstat, WNOHANG)) > 0) {
		/*
		 * Data will be arriving right now, so make sure we don't
		 * short-circuit out for too many loops, and skip the interrupt
		 * check.  -BL
		 */
		child_exited = 1;
		continue;
d960 2
d963 11
d975 3
a977 1
	     * Abort if interrupt key pressed.
d979 2
a980 8
	    if (HTCheckForInterrupt()) {
		CTRACE((tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n"));
		kill(fpid, SIGTERM);
		waitpid(fpid, NULL, WNOHANG);
		close(pfd[0]);
		lynx_nsl_status = HT_INTERRUPTED;
		return NULL;
	    }
d982 6
a987 2
	close(pfd[0]);
	if (waitret <= 0) {
d989 4
a992 1
	    waitret = waitpid(fpid, &waitstat, WNOHANG);
d994 15
a1008 9
	if (waitret > 0) {
	    if (WIFEXITED(waitstat)) {
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int) waitret, WEXITSTATUS(waitstat)));
	    } else if (WIFSIGNALED(waitstat)) {
		CTRACE((tfp,
			"LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
			(int) waitret, WTERMSIG(waitstat)));
d1010 1
a1010 7
		if (WCOREDUMP(waitstat)) {
		    CTRACE((tfp,
			    "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			    (int) waitret));
		}
#endif /* WCOREDUMP */
	    } else if (WIFSTOPPED(waitstat)) {
d1012 2
a1013 2
			"LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int) waitret, WSTOPSIG(waitstat)));
d1015 5
a1019 3
	}
	if (!got_rehostent) {
	    goto failed;
d1022 144
d1243 1
a1243 1
    dump_hostent("End of LYGetHostByName", result_phost);
d1288 1
a1288 1
    if ((port = strchr(host, ':')) != NULL) {
d1324 1
a1324 1
    strncpy(soc_in->sdn_nam.n_name, host, soc_in->sdn_nam.n_len + 1);
d1378 1
a1378 1
	memcpy((void *) &soc_in->sin_addr, gbl_phost->h_addr_list[0], gbl_phost->h_length);
a1386 2
	    if (!phost)
		goto failed;
d1390 1
a1390 1
	    memcpy((void *) &soc_in->sin_addr, phost->h_addr_list[0], phost->h_length);
d1423 164
d1590 6
a1595 1
    LYNX_ADDRINFO hints, *res;
d1597 2
d1606 1
a1606 1
    if (s[0] == '[' && (p = strchr(s, ']')) != NULL) {
d1621 10
d1640 1
d1643 3
d1681 1
a1681 1
    int namelength = sizeof(name);
d1695 1
a1695 1
    if (strchr(hostname, '.') == NULL) {	/* Not full address */
d1722 1
a1722 1
    memcpy(&HTHostAddress, res->ai_addr, res->ai_addrlen);
d1733 1
a1733 1
    memcpy(&HTHostAddress, &phost->h_addr_list[0], phost->h_length);
d1817 1
a1817 1
    if ((at_sign = strchr(p1, '@@')) != NULL) {
d1883 2
a1884 1
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
d1982 1
d1985 1
d1994 1
a1994 1
		    ret = Rselect((unsigned) *s + 1, NULL,
d1998 1
a1998 1
		    ret = select((unsigned) *s + 1,
d2175 1
d2178 1
d2248 1
a2248 1
		HTReadProgress(-1, 0);	/* Put "stalled" message */
d2263 1
a2263 1
		ret = Rselect((unsigned) fildes + 1,
d2267 1
a2267 1
		ret = select((unsigned) fildes + 1,
d2302 1
a2302 1
	while ((result = SOCKET_READ(fildes, buf, nbyte)) == -1) {
d2320 1
a2320 1
			   result, CAST_time_t(time((time_t *) 0) - start)));
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			Generic Communication Code		HTTCP.c
d383 1
a383 1
	CTRACE((tfp, "%s: %p ", msgprefix, phost));
d391 1
a391 1
	    CTRACE((tfp, "\n\t h_aliases = %p", phost->h_aliases));
d406 1
a406 1
	    CTRACE((tfp, " h_addr_list = %p", phost->h_addr_list));
d581 1
a581 1
#ifndef __CYGWIN__
d1154 4
d1159 1
d1533 29
d1762 1
a1762 1
		if ((tries++ / 10) >= connect_timeout) {
d1771 1
a1771 7
#ifdef _WINDOWS_NSL
		select_timeout.tv_sec = connect_timeout;
		select_timeout.tv_usec = 0;
#else
		select_timeout.tv_sec = 0;
		select_timeout.tv_usec = 100000;
#endif /* _WINDOWS_NSL */
d1903 1
a1903 1
		if (HTCheckForInterrupt()) {
a1904 6
		    status = HT_INTERRUPTED;
#ifdef _WINDOWS
		    WSASetLastError(EINTR);
#else
		    SOCKET_ERRNO = EINTR;
#endif
d1970 5
a1974 1
    int ready, ret;
d1982 1
d1984 1
a1984 3
#if defined(UNIX) || defined(UCX)
    int nb;
#endif /* UCX, BSN */
d1998 2
a1999 1
    if (fildes <= 0)
d2001 1
d2003 3
a2005 7
    if (HTCheckForInterrupt()) {
#ifdef _WINDOWS
	WSASetLastError(EINTR);
#else
	SOCKET_ERRNO = EINTR;
#endif
	return (HT_INTERRUPTED);
d2007 2
a2008 2
#if !defined(NO_IOCTL)
    ready = 0;
d2010 1
a2010 2
    ready = 1;
#endif /* bypass for NO_IOCTL */
d2015 5
a2019 8
	if (tries++ >= 180000) {
	    HTAlert(gettext("Socket read failed for 180,000 tries."));
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
	    SOCKET_ERRNO = EINTR;
#endif
	    return HT_INTERRUPTED;
d2022 1
a2022 1
	if (tries - otries > 10) {
d2038 1
a2038 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d2052 2
a2053 1
	    return -1;
d2055 3
a2057 8
	    ready = 1;
	} else if (HTCheckForInterrupt()) {
#ifdef _WINDOWS
	    WSASetLastError(EINTR);
#else
	    SOCKET_ERRNO = EINTR;
#endif
	    return HT_INTERRUPTED;
d2060 1
d2062 19
a2080 1
#if !defined(UCX) || !defined(VAXC)
d2082 3
a2084 3
    while ((nb = SOCKET_READ(fildes, buf, nbyte)) == -1) {
	if (errno == EINTR)
	    continue;
d2086 2
a2087 2
	if (errno == ERESTARTSYS)
	    continue;
d2089 3
a2091 4
	HTInetStatus("read");
	break;
    }
    return nb;
d2093 1
a2093 1
    return SOCKET_READ(fildes, buf, nbyte);
d2095 1
a2095 17

#else /* UCX && VAXC */
    /*
     * VAXC and UCX problem only.
     */
    errno = vaxc$errno = 0;
    nb = SOCKET_READ(fildes, buf, nbyte);
    CTRACE((tfp,
	    "Read - nb,errno,vaxc$errno: %d %d %d\n", nb, errno, vaxc$errno));
    if ((nb <= 0) && TRACE)
	perror("HTTCP.C:HTDoRead:read");	/* RJF */
    /*
     * An errno value of EPIPE and nb < 0 indicates end-of-file on VAXC.
     */
    if ((nb <= 0) && (errno == EPIPE)) {
	nb = 0;
	set_errno(0);
d2097 6
a2102 2
    return nb;
#endif /* UCX, BSN */
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 16
a17 16
**			==========================
**
**	This code is in common between client and server sides.
**
**	16 Jan 92  TBL	Fix strtol() undefined on CMU Mach.
**	25 Jun 92  JFG	Added DECNET option through TCP socket emulation.
**	13 Sep 93  MD	Added correct return of vmserrorno for HTInetStatus.
**			Added decoding of vms error message for MULTINET.
**	7-DEC-1993 Bjorn S. Nilsson, ALEPH, CERN, VMS UCX ioctl() changes
**			(done of Mosaic)
**	19 Feb 94  Danny Mayer	Added Bjorn Fixes to Lynx version
**	 7 Mar 94  Danny Mayer	Added Fix UCX version for full domain name
**	20 May 94  Andy Harper	Added support for CMU TCP/IP transport
**	17 Nov 94  Andy Harper	Added support for SOCKETSHR transport
**	16 Jul 95  S. Bjorndahl added kluge to deal with LIBCMU bug
*/
d39 3
d45 6
a50 6
PUBLIC int BSDselect PARAMS((
	int		 nfds,
	fd_set *	 readfds,
	fd_set *	 writefds,
	fd_set *	 exceptfds,
	struct timeval * select_timeout));
d66 3
a68 3
**  Module-Wide variables
*/
PRIVATE char *hostname = NULL;		/* The name of this host */
d71 2
a72 2
**  PUBLIC VARIABLES
*/
d74 1
a74 1
PUBLIC unsigned long socks_bind_remoteAddr; /* for long Rbind */
d77 1
a77 1
/* PUBLIC SockA HTHostAddress; */	/* The internet address of the host */
d81 9
a89 9
**	------------------
**
**  On entry,
**	where		gives a description of what caused the error
**	global errno	gives the error number in the Unix way.
**
**  On return,
**	returns		a negative status in the Unix way.
*/
d92 1
a92 1
extern char *sys_errlist[];		/* see man perror on cernvax */
d97 1
a97 1
static int ResolveYield (void)
d99 1
a99 1
    return HTCheckForInterrupt() ? 0 : 1;
d103 1
d105 2
a106 1
 * This chunk of code is used in both win32 and cygwin.
a107 27
#if defined(_WINDOWS_NSL)
static char host[512];
static struct hostent *phost; /* Pointer to host - See netdb.h */
static int donelookup;

static unsigned long _fork_func (void *arglist GCC_UNUSED)
{
#ifdef SH_EX
    unsigned long addr;
    addr = (unsigned long)inet_addr(host);
    if ((int)addr != -1)
	phost = gethostbyaddr((char *)&addr, sizeof (addr), AF_INET);
    else
	phost = gethostbyname(host);
#else
    phost = gethostbyname(host);
#endif
    donelookup = TRUE;
    return (unsigned long)(phost);
}
#endif /* _WINDOWS_NSL */

#if defined(VMS) && defined(UCX)
/*
**  A routine to mimic the ioctl function for UCX.
**  Bjorn S. Nilsson, 25-Nov-1993. Based on an example in the UCX manual.
*/
d110 3
a112 4
PUBLIC int HTioctl ARGS3(
	int,		d,
	int,		request,
	int *,		argp)
d127 1
a127 1
    if ((sdc = vaxc$get_sdc (d)) == 0) {
d131 3
a133 2
    ioctl_desc.opt  = UCX$C_IOCTL;
    ioctl_desc.len  = sizeof(struct comm);
d138 1
a138 1
	p6 = (char *)&ioctl_desc;
d141 1
a141 1
	p5 = (char *)&ioctl_desc;
d145 2
a146 2
    ioctl_comm.addr = (char *)argp;
    status = sys$qiow (0, sdc, fun, iosb, 0, 0, 0, 0, 0, 0, p5, p6);
d163 3
a165 4
**	---------------------
*/
PUBLIC int HTInetStatus ARGS1(
	char *,		where)
d169 1
d177 2
a178 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   "(Error number not translated)"));	/* What Is the VM equiv? */
d184 2
a185 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   vms_errno_string()));
d187 3
a189 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   ((SOCKET_ERRNO > 0 && SOCKET_ERRNO <= 65) ?
	    strerror(SOCKET_ERRNO) : "(Error number not translated)")));
d195 2
a196 2
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   strerror(SOCKET_ERRNO)));
d201 3
a203 3
    CTRACE((tfp, MY_FORMAT, SOCKET_ERRNO,  where,
	   (SOCKET_ERRNO < sys_nerr ?
	    sys_errlist[SOCKET_ERRNO] : "Unknown error" )));
d209 2
a210 2
	   "         Unix error number (SOCKET_ERRNO) = %ld dec\n",
	   SOCKET_ERRNO));
d212 2
a213 2
	   "         VMS error (vaxc$errno)    = %lx hex\n",
	   vaxc$errno));
d221 2
a222 2
    **	uerrno and errno happen to be zero if vmserrno <> 0
    */
d235 15
a249 16
**	----------------------
**
** On entry,
**	*pp	    points to first character to be interpreted, terminated by
**		    non 0:9 character.
**	*pstatus    points to status already valid
**	maxvalue    gives the largest allowable value.
**
** On exit,
**	*pp	    points to first unread character
**	*pstatus    points to status updated iff bad
*/
PUBLIC unsigned int HTCardinal ARGS3(
	int *,		pstatus,
	char **,	pp,
	unsigned int,	max_value)
d252 3
a254 2
    if ((**pp<'0') || (**pp>'9')) {	    /* Null string is error */
	*pstatus = -3;	/* No number where one expected */
d260 1
a260 1
	n = n*10 + *((*pp)++) - '0';
d263 1
a263 1
	*pstatus = -4;	/* Cardinal outside range */
d270 1
a270 1
#ifndef DECNET	/* Function only used below for a trace message */
d272 7
a278 8
**	----------------------------------------
**
**  On exit,
**	returns a pointer to a static string which must be copied if
**		it is to be kept.
*/
PUBLIC CONST char * HTInetString ARGS1(
	SockA*,		soc_in)
d282 4
a285 3
    getnameinfo((struct sockaddr *)soc_in,
	    SOCKADDR_LEN(soc_in),
	    hostbuf, sizeof(hostbuf), NULL, 0, NI_NUMERICHOST);
d289 1
d291 4
a294 4
	    (int)*((unsigned char *)(&soc_in->sin_addr)+0),
	    (int)*((unsigned char *)(&soc_in->sin_addr)+1),
	    (int)*((unsigned char *)(&soc_in->sin_addr)+2),
	    (int)*((unsigned char *)(&soc_in->sin_addr)+3));
d301 20
a320 21
**	-------------------------------------------------
**
**  Checks whether
**  - contains only valid chars for domain names (actually, the
**    restrictions are somewhat relaxed),
**  - no leading dots or empty segments,
**  - no segment starts with '-' or '+' [this protects telnet command],
**  - max. length of dot-separated segment <= 63 (RFC 1034,1035),
**  - total length <= 254 (if it ends with dot) or 253 (otherwise)
**     [an interpretation of RFC 1034,1035, although RFC 1123
**      suggests 255 as limit - kw].
**
**  Note: user (before '@@') and port (after ':') components from
**      host part of URL should be already stripped (if appropriate)
**      from the input string.
**
**  On exit,
**	returns 1 if valid, otherwise 0.
*/
PUBLIC BOOL valid_hostname ARGS1(
	char *,	name)
d322 1
a322 1
    int i=1, iseg = 0;
d324 1
d351 5
a355 6
**  Function to allow us to be killed with a normal signal (not
**  SIGKILL), but don't go through normal libc exit() processing, which
**  would screw up parent's stdio.  -BL
*/
PRIVATE void quench ARGS1(
	int,	sig GCC_UNUSED)
d361 1
a361 1
PUBLIC int lynx_nsl_status = HT_OK;
d364 1
a364 1
#define DEBUG_HOSTENT_CHILD  /* for NSL_FORK, may screw up trace file */
d367 8
a374 9
**  Two auxiliary functions for name lookup and struct hostent.
**
**  dump_hostent - dumps the contents of a struct hostent to the
**  trace log or stderr, including all pointer values, strings, and
**  addresses, in a format inspired by gdb's print format. - kw
*/
PRIVATE void dump_hostent ARGS2(
    CONST char *,		msgprefix,
    CONST struct hostent *,	phost)
d379 2
a380 1
	CTRACE((tfp,"%s: %p ", msgprefix, phost));
d382 1
a382 1
	    CTRACE((tfp,"{ h_name = %p", phost->h_name));
d388 1
a388 1
	    CTRACE((tfp,"\n\t h_aliases = %p", phost->h_aliases));
d392 3
a394 3
		    CTRACE((tfp,"%s %p \"%s\"",
			   (pcnt == phost->h_aliases ? " " : ", "),
			   *pcnt, *pcnt));
d397 1
a397 1
		       (*phost->h_aliases ? ", " : " ")));
d401 3
a403 3
	    CTRACE((tfp," h_addrtype = %d,", phost->h_addrtype));
	    CTRACE((tfp," h_length = %d,\n\t", phost->h_length));
	    CTRACE((tfp," h_addr_list = %p", phost->h_addr_list));
d407 3
a409 3
		    CTRACE((tfp,"%s %p",
			   (pcnt == phost->h_addr_list ? "" : ","),
			   *pcnt));
d411 3
a413 3
			CTRACE((tfp, "%s%d%s", (i==0 ? " \"" : "."),
			       (int)*((unsigned char *)(*pcnt)+i),
			       (i+1 == phost->h_length ? "\"" : "")));
d425 1
a425 1
	CTRACE((tfp,"\n"));
d431 8
a438 8
**  fill_rehostent - copies as much as possible relevant content from
**  the struct hostent pointed to by phost to the char buffer given
**  by rehostent, subject to maximum output length rehostentsize,
**  following pointers and building self-contained output which can be
**  cast to a struct hostent. - kw
**  See also description of LYGetHostByName.
*/
#ifdef NSL_FORK
d440 1
a440 1
#define REHOSTENT_SIZE 128		/* not bigger than pipe buffer! */
d443 7
a449 8
	struct hostent	h;
	char		rest[REHOSTENT_SIZE];
    } AlignedHOSTENT;

PRIVATE size_t fill_rehostent ARGS3(
    char *,			rehostent,
    size_t,			rehostentsize,
    CONST struct hostent *,	phost)
d451 1
a451 1
    AlignedHOSTENT *data = (AlignedHOSTENT *)rehostent;
d459 1
a459 1
    size_t curlen = sizeof(struct hostent);
d467 1
d491 1
a491 1
	for (pcnt=phost->h_addr_list+1; *pcnt; pcnt++) {
d502 1
a502 1
	for (pcnt=phost->h_aliases; *pcnt; pcnt++) {
d514 1
a514 1
    p_next_charptr = (char **)(rehostent + curlen);
d517 1
a517 1
	p_next_char += (num_addrs+1) * sizeof(phost->h_addr_list[0]);
d519 1
a519 1
	p_next_char += (num_aliases+1) * sizeof(phost->h_aliases[0]);
d523 1
a523 1
	for (pcnt=phost->h_addr_list, i_addr = 0;
d549 1
a549 1
	for (pcnt=phost->h_aliases, i_alias = 0;
d568 1
a568 1
    curlen = p_next_char - (char *)rehostent;
d571 43
d620 1
d622 1
a622 1
#ifndef h_errno		/* there may be a macro as well as the extern data */
d627 24
d652 34
a685 35
**	------------------------------------------------
**
**  On entry,
**	str	points to the given host name, not numeric address,
**		without colon or port number.
**
**  On exit,
**	returns a pointer to a struct hostent in static storage,
**	or NULL in case of error or user interruption.
**
**  The interface is intended to be exactly the same as for (Unix)
**  gethostbyname(), except for the following:
**
**  If NSL_FORK is not used, the result of gethostbyname is returned
**  directly.  Otherwise:
**  All lists, addresses, and strings referred to by pointers in the
**  returned struct are located, together with the returned struct
**  itself, in a buffer of size REHOSTENT_SIZE.  If not everything fits,
**  some info is omitted, but the function is careful to still return
**  a valid structure, without truncating strings; it tries to return,
**  in order of decreasing priority, the first address (h_addr), the
**  official name (h_name), the additional addresses, then alias names.
**
**  If NULL is returned, the reason is made available in the global
**  variable lynx_nsl_status, with one of the following values:
**	HT_INTERRUPTED		Interrupted by user
**	HT_NOT_ACCEPTABLE	Hostname detected as invalid
**				(also sets h_errno)
**	HT_H_ERRNO_VALID	An error occurred, and h_errno holds
**				an appropriate value
**	HT_ERROR		Resolver error, reason not known
**	HT_INTERNAL		Internal error
*/
PUBLIC struct hostent * LYGetHostByName ARGS1(
	char *,	str)
a686 1
#ifndef _WINDOWS_NSL
a687 1
#endif
d692 1
d694 3
a696 4
     * We could define rehosten directly as a
     * static char rehostent[REHOSTENT_SIZE],
     * but the indirect approach via the above struct
     * should automatically take care of alignment requirements.
d698 6
a703 7
     *  - this must be static, as we shall return a pointer to it
     *    which must remain valid, and
     *  - we have to use the same rehostent in the child process as
     *    in the parent (its address in the parent's address space
     *    must be the same as in the child's, otherwise the internal
     *    pointers built by the child's call to fill_rehostent would
     *    be invalid when seen by the parent). - kw
d705 1
a705 1
    char *rehostent = (char *)&aligned_full_rehostent;
d711 1
a711 1
	int child_errno;  /* sometimes useful to pass this on */
d719 1
a719 1
    struct hostent *result_phost = NULL;
d732 1
a732 1
	/*  Could disable this if all our callers already check - kw */
a738 4
#ifdef _WINDOWS_NSL
    strncpy(host, str, sizeof(host));
#endif /*  _WINDOWS_NSL */

d750 1
a750 2

#ifdef MVS	/* Outstanding problem with crash in MVS gethostbyname */
d754 1
a754 1
    CTRACE_FLUSH(tfp);  /* so child messages will not mess up parent log */
d760 4
a763 4
	/*
	**  Start block for fork-based gethostbyname() with
	**  checks for interrupts. - Tom Zerucha (tz@@execpc.com) & FM
	*/
d766 1
d772 3
a774 3
	**	Pipe, child pid, status buffers, start time, select()
	**	control variables.
	*/
d777 1
d780 1
d784 1
a784 1
	time_t start_time = time((time_t *)0);
d787 1
a787 1
	long dns_patience = 30; /* how many seconds will we wait for DNS? */
d790 8
a797 9
	    /*
	    **  Reap any children that have terminated since last time
	    **  through.  This might include children that we killed,
	    **  then waited with WNOHANG before they were actually ready
	    **  to be reaped.  (Should be max of 1 in this state, but
	    **  the loop is safe if waitpid() is implemented correctly:
	    **  returns 0 when children exist but none have exited; -1
	    **  with errno == ECHILD when no children.)  -BL
	    */
d807 7
a813 8
	 *  Attempt to prevent a rare situation where the child
	 *  could execute the Lynx signal handlers because it gets
	 *  killed before it even has a chance to reset its handlers,
	 *  resulting in bogus 'Exiting via interrupt' message and
	 *  screen corruption or worse.
	 *  Should that continue to be reported, for systems without
	 *  sigprocmask(), we need to find a different solutions for
	 *  those. - kw 19990430
d830 3
a832 2
	if ((fpid = fork()) == 0 ) {
	    struct hostent  *phost;	/* Pointer to host - See netdb.h */
d834 4
a837 4
	    **  Child - for the long call.
	    **
	    **  Make sure parent can kill us at will.  -BL
	    */
d841 5
a845 6
	    **  Also make sure the child does not run one of the
	    **  signal handlers that may have been installed by
	    **  Lynx if one of those signals occurs.  For example
	    **  we don't want the child to remove temp files on
	    **  ^C, let the parent deal with that. - kw
	    */
d873 2
a874 2
	    **  Child won't use read side.  -BL
	    */
d897 1
a897 1
		dump_hostent("CHILD fill_rehostent", (struct hostent *)rehostent);
d900 2
a901 2
	    if (rehostentlen <= sizeof(struct hostent) ||
		!OK_HOST((struct hostent *)rehostent)) {
d905 1
a905 1
		statuses.h_length = ((struct hostent *)rehostent)->h_length;
d907 1
a907 1
		if (h_errno == -2) /* success, but h_errno unchanged? */
d912 4
a915 4
	    **  Send variables indicating status of lookup to parent.
	    **  That includes rehostentlen, which the parent will use
	    **  as the size for the second read (if > 0).
	    */
d917 1
a917 1
	    statuses.child_errno = errno;
a920 1

d923 2
a924 2
		**  Return our resulting rehostent through pipe...
		*/
d926 1
d930 2
a931 2
		**  ... or return error as exit code.
		*/
a934 1

d937 3
a939 3
	**  (parent) Restore signal mask to whatever it was
	**  before the fork. - kw
	*/
d944 3
a946 3
	**	(parent) Wait until lookup finishes, or interrupt,
	**	or cycled too many times (just in case) -BL
	*/
d948 1
a948 1
	close(pfd[1]);      /* parent won't use write side -BL */
d950 3
a952 3
	if (fpid < 0) {     /* fork failed */
		close(pfd[0]);
		goto failed;
d955 1
a955 1
	while (child_exited || (long)(time((time_t *)0) - start_time) < dns_patience) {
d959 9
a967 9
	    **  This allows us to abort immediately, not after 1-second
	    **  timeout, when user hits abort key.  Can't do this when
	    **  using SLANG (or at least I don't know how), so SLANG
	    **  users must live with up-to-1s timeout.  -BL
	    **
	    **  Whoops -- we need to make sure stdin is actually
	    **  selectable!  /dev/null isn't, on some systems, which
	    **  makes some useful Lynx invocations fail.  -BL
	    */
d970 1
d980 5
a984 5
		/*
		**  Return when data received, interrupted, or failed.
		**  If nothing is waiting, we sleep for 1 second in
		**  select(), to be nice to the system.  -BL
		*/
d987 1
a987 1
		selret = Rselect(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d990 1
a990 1
		selret = select(pfd[0] + 1, (void *)&readfds, NULL, NULL, &one_second);
d994 3
a996 3
		**	First get status, including length of address.  -BL, kw
		*/
		readret = read(pfd[0], &statuses, sizeof(statuses));
d1004 7
a1010 8
			 *  If something went wrong in the child process
			 *  other than normal lookup errors, and it appears
			 *  that we have enough info to know what went wrong,
			 *  generate diagnostic output.
			 *  ENOMEM observed on linux in processes constrained
			 *  with ulimit.  It would be too unkind to abort
			 *  the session, access to local files or through a
			 *  proxy may still work. - kw
d1014 1
a1014 1
			    (errno && h_errno == NETDB_INTERNAL) ||
d1016 6
a1021 6
			    (errno == ENOMEM &&
			     statuses.rehostentlen == 0 &&
			     /* should probably be NETDB_INTERNAL if child
				memory exhausted, but we may find that
				h_errno remains unchanged. - kw */
			     h_errno == -2)) {
d1028 3
a1030 3
				 *  Not much point in continuing, right?
				 *  Fake a 'z', should shorten pointless
				 *  guessing cycle. - kw
d1037 1
a1037 1
		    if (statuses.rehostentlen > sizeof(struct hostent)) {
d1039 3
a1041 3
			**  Then get the full reorganized hostent.  -BL, kw
			*/
			readret = read(pfd[0], rehostent, statuses.rehostentlen);
d1043 1
a1043 1
			dump_hostent("Read from pipe", (struct hostent *)rehostent);
d1047 1
a1047 1
			    result_phost = (struct hostent *)rehostent;
d1057 2
a1058 2
		**  Make sure child is cleaned up.  -BL
		*/
d1069 2
a1070 2
	    **  Clean up if child exited before & no data received.  -BL
	    */
d1076 2
a1077 2
	    **  If child exited, loop once more looking for data.  -BL
	    */
d1080 4
a1083 4
		**	Data will be arriving right now, so make sure we
		**	don't short-circuit out for too many loops, and
		**	skip the interrupt check.  -BL
		*/
d1089 2
a1090 2
	    **  Abort if interrupt key pressed.
	    */
d1107 3
a1109 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
			(int)waitret, WEXITSTATUS(waitstat)));
d1111 3
a1113 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		       (int)waitret, WTERMSIG(waitstat)));
d1116 3
a1118 2
		    CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			   (int)waitret));
d1122 3
a1124 2
		CTRACE((tfp, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
			(int)waitret, WSTOPSIG(waitstat)));
d1135 2
a1136 1
	HANDLE hThread, dwThreadID;
d1141 4
a1144 3
	    t = (unsigned long)inet_addr(host);
	    if ((int)t != -1)
		phost = gethostbyaddr((char *)&t, sizeof (t), AF_INET);
d1146 1
a1146 1
		phost = gethostbyname(host);
d1149 1
a1149 1
	    phost = (struct hostent *) NULL;
d1151 4
a1154 3
	    hThread = CreateThread((void *)NULL, 4096UL,
		(LPTHREAD_START_ROUTINE)_fork_func,
		(void *)NULL, 0UL, (unsigned long *)&dwThreadID);
d1156 1
a1156 1
		MessageBox((void *)NULL, "CreateThread",
d1164 2
a1165 2
			MessageBox((void *)NULL,
				   "CloseHandle","CloseHandle Failed", 0L);
d1174 1
a1174 1
	if (phost) {
d1176 1
a1176 1
	    result_phost = phost;
d1185 2
a1186 1
	struct hostent  *phost;
d1209 1
a1209 1
failed:
d1211 1
a1211 1
		host));
a1214 1

d1216 11
a1226 11
**	-------------------------------------
**
**  On entry,
**	str	points to a string with a node name or number,
**		with optional trailing colon and port number.
**	soc_in	points to the binary internet or decnet address field.
**
**  On exit,
**	*soc_in is filled in.  If no port is specified in str, that
**		field is left unchanged in *soc_in.
*/
d1228 1
a1228 3
PRIVATE int HTParseInet ARGS2(
	SockA *,	soc_in,
	CONST char *,	str)
a1232 1
#ifndef _WINDOWS_NSL
a1233 1
#endif /* _WINDOWS_NSL */
a1243 3
#ifdef _WINDOWS_NSL
    strncpy(host, str, sizeof(host));
#else
a1244 1
#endif /*  _WINDOWS_NSL */
d1246 2
a1247 2
    **	Parse port number if present.
    */
d1253 1
a1253 1
	    soc_in->sin_port = (PortNumber)htons(strtol(port, &strptr, 10));
d1256 1
a1256 1
	    soc_in->sdn_objnum = (unsigned char)(strtol(port, &strptr, 10));
d1258 1
a1258 1
	    soc_in->sin_port = htons((PortNumber)strtol(port, &strptr, 10));
d1261 1
a1261 1
#ifdef SUPPRESS		/* 1. crashes!?!.  2. URL syntax has number not name */
d1263 2
a1264 1
	    struct servent * serv = getservbyname(port, (char*)0);
a1272 1
#ifndef _WINDOWS_NSL
a1273 1
#endif /* _WINDOWS_NSL */
a1277 1

d1280 4
a1283 4
    **	Read Decnet node name. @@@@ Should know about DECnet addresses, but
    **	it's probably worth waiting until the Phase transition from IV to V.
    */
    soc_in->sdn_nam.n_len = min(DN_MAXNAML, strlen(host));  /* <=6 in phase 4 */
d1285 4
a1288 3
    CTRACE((tfp, "DECnet: Parsed address as object number %d on host %.6s...\n",
		soc_in->sdn_objnum, host));
#else  /* parse Internet host: */
d1290 1
a1290 1
    if (*host >= '0' && *host <= '9') {   /* Test for numeric node address: */
d1306 3
a1308 3
    **	Parse host number if present.
    */
    if (dotcount_ip == 3)   /* Numeric node address: */
d1311 1
a1311 1
	soc_in->sin_addr.s_addr = inet_addr(host).s_addr; /* See arpa/inet.h */
d1314 1
a1314 1
	soc_in->sin_addr = inet_addr(host);		/* See netinet/in.h */
a1318 1
#ifndef _WINDOWS_NSL
a1319 1
#endif /* _WINDOWS_NSL */
a1326 1
#ifndef _WINDOWS_NSL
d1328 1
a1328 3
#endif /* _WINDOWS_NSL */
    } else
    {			    /* Alphanumeric node name: */
d1330 1
a1330 1
#ifdef MVS	/* Outstanding problem with crash in MVS gethostbyname */
d1335 4
a1338 3
	phost = LYGetHostByName(host);	/* See above */
	if (!phost) goto failed;
	memcpy((void *)&soc_in->sin_addr, phost->h_addr, phost->h_length);
d1341 2
a1342 1
	    struct hostent  *phost;
d1345 4
a1348 13
	    if (!phost) goto failed;
#if defined(VMS) && defined(CMU_TCP)
	    /*
	    **  In LIBCMU, phost->h_length contains not the length of one address
	    **  (four bytes) but the number of bytes in *h_addr, i.e., some multiple
	    **  of four.  Thus we need to hard code the value here, and remember to
	    **  change it if/when IP addresses change in size. :-(	LIBCMU is no
	    **  longer supported, and CMU users are encouraged to obtain and use
	    **  SOCKETSHR/NETLIB instead. - S. Bjorndahl
	    */
	    memcpy((void *)&soc_in->sin_addr, phost->h_addr, 4);
#else
	    if (!phost) goto failed;
d1352 1
a1352 2
	    memcpy((void *)&soc_in->sin_addr, phost->h_addr, phost->h_length);
#endif /* VMS && CMU_TCP */
a1355 1
#ifndef _WINDOWS_NSL
d1357 1
a1357 1
#endif /* _WINDOWS_NSL */
d1359 8
a1366 9
    }	/* Alphanumeric node name */

    CTRACE((tfp, "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
		(int)ntohs(soc_in->sin_port),
		(int)*((unsigned char *)(&soc_in->sin_addr)+0),
		(int)*((unsigned char *)(&soc_in->sin_addr)+1),
		(int)*((unsigned char *)(&soc_in->sin_addr)+2),
		(int)*((unsigned char *)(&soc_in->sin_addr)+3)));
#endif	/* Internet vs. Decnet */
d1368 1
a1368 1
    return 0;	/* OK */
d1370 1
a1370 1
failed:
d1372 1
a1372 2
		host));
#ifndef _WINDOWS_NSL
a1373 1
#endif /* _WINDOWS_NSL */
d1375 4
a1378 4
	case HT_NOT_ACCEPTABLE:
	case HT_INTERRUPTED:
	    return lynx_nsl_status;
	default:
d1385 2
a1386 4
PRIVATE struct addrinfo *
HTGetAddrInfo ARGS2(
    CONST char *, str,
    CONST int, defport)
d1388 1
a1388 1
    struct addrinfo hints, *res;
d1391 1
a1391 1
    char *s;
d1395 1
a1395 1
    s = strdup(str);
d1422 1
d1429 4
a1432 4
**	-------------------------------------------
**
*/
PRIVATE void free_HTTCP_hostname NOARGS
d1439 4
a1442 4
**	-------------------------------------------
**
*/
PRIVATE void get_host_details NOARGS
d1444 2
a1445 1
    char name[MAXHOSTNAMELEN+1];	/* The name of this host */
d1447 1
a1447 1
    char *domain_name;			/* The name of this host domain */
d1449 1
a1449 1
#ifdef NEED_HOST_ADDRESS		/* no -- needs name server! */
d1451 1
a1451 1
    struct addrinfo hints, *res;
d1453 1
d1455 1
a1455 1
    struct hostent * phost;		/* Pointer to host -- See netdb.h */
d1461 1
a1461 1
	return;				/* Already done */
d1469 4
a1472 4
    **	UCX doesn't give the complete domain name.
    **	Get rest from UCX$BIND_DOM logical.
    */
    if (strchr(hostname,'.') == NULL) {		  /* Not full address */
d1480 1
a1480 1
     }
d1484 2
a1485 2
#ifndef DECNET	/* Decnet ain't got no damn name server 8#OO */
#ifdef NEED_HOST_ADDRESS		/* no -- needs name server! */
d1496 1
a1496 1
	return;  /* Fail! */
d1504 4
a1507 3
	CTRACE((tfp, "TCP: Can't find my own internet node address for `%s'!!\n",
		    name));
	return;  /* Fail! */
d1510 1
a1510 1
    memcpy(&HTHostAddress, &phost->h_addr, phost->h_length);
d1513 1
a1513 1
		hostname, HTInetString(&HTHostAddress)));
d1519 1
a1519 1
PUBLIC CONST char * HTHostName NOARGS
d1526 3
a1528 3
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
#define SOCKET_DEBUG_TRACE    /* show errno status after some system calls */
#endif  /* UCX && VAXC */
d1531 8
a1538 9
**  Interruptible connect as implemented for Mosaic by Marc Andreesen
**  and hacked in for Lynx years ago by Lou Montulli, and further
**  modified over the years by numerous Lynx lovers. - FM
*/
PUBLIC int HTDoConnect ARGS4(
	CONST char *,	url,
	char *,		protocol,
	int,		default_port,
	int *,		s)
d1545 1
d1547 2
a1548 1
    struct addrinfo *res = 0, *res0 = 0;
d1554 2
a1555 2
    **	Set up defaults.
    */
d1562 2
a1563 2
    **	Get node name and optional port number.
    */
d1567 2
a1568 2
	**  If there's an @@ then use the stuff after it as a hostname.
	*/
d1575 2
a1576 2
    HTSprintf0 (&line, "%s%s", WWW_FIND_MESSAGE, host);
    _HTProgress (line);
d1581 1
a1581 1
	HTSprintf0 (&line, gettext("Unable to locate remote host %s."), host);
d1592 3
a1594 3
		/*  Not HTProgress, so warning won't be overwritten
		 *  immediately; but not HTAlert, because typically
		 *  there will be other alerts from the callers. - kw
d1598 2
a1599 2
		HTSprintf0 (&line,
			 gettext("Unable to locate remote host %s."), host);
d1610 2
a1611 2
    HTSprintf0 (&line, gettext("Making %s connection to %s"), protocol, host);
    _HTProgress (line);
d1616 9
a1624 3
    **	Now, let's get a socket set up from the server for the data.
    */
#ifdef INET6
d1629 1
d1631 6
a1636 5
		    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
		    NI_NUMERICHOST|NI_NUMERICSERV);
	    HTSprintf0 (&line, gettext("socket failed: family %d addr %s port %s."),
		    res->ai_family, hostbuf, portbuf);
	    _HTProgress (line);
a1639 6
#else
    *s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (*s == -1) {
	HTAlert(gettext("socket failed."));
	return HT_NO_DATA;
    }
d1644 6
a1649 6
    /*
    **	Make the socket non-blocking, so the connect can be canceled.
    **	This means that when we issue the connect we should NOT
    **	have to wait for the accept on the other end.
    */
    {
d1651 2
a1652 1
	int ret = fcntl(*s, F_SETFL, O_NONBLOCK);
d1654 2
a1655 2
	int val = 1;
	int ret = IOCTL(*s, FIONBIO, &val);
d1657 3
a1659 3
	if (ret == -1)
	    _HTProgress(gettext("Could not make connection non-blocking."));
    }
d1663 5
a1667 5
    /*
    **	Issue the connect.  Since the server can't do an instantaneous
    **	accept and we are non-blocking, this will almost certainly return
    **	a negative status.
    */
d1669 1
a1669 1
    if (socks_flag) {
d1671 1
a1671 1
	status = Rconnect(*s, res->ai_addr, res->ai_addrlen);
d1673 5
a1677 2
	status = Rconnect(*s, (struct sockaddr*)&soc_address,
			  sizeof(soc_address));
d1679 1
a1679 5
	/*
	**  For long Rbind.
	*/
	socks_bind_remoteAddr = soc_address.sin_addr.s_addr;
    } else
d1682 1
a1682 1
    status = connect(*s, res->ai_addr, res->ai_addrlen);
d1684 1
a1684 1
    status = connect(*s, (struct sockaddr*)&soc_address, sizeof(soc_address));
d1687 20
a1706 20
    /*
    **	According to the Sun man page for connect:
    **	   EINPROGRESS	       The socket is non-blocking and the  con-
    **			       nection cannot be completed immediately.
    **			       It is possible to select(2) for	comple-
    **			       tion  by  selecting the socket for writ-
    **			       ing.
    **	According to the Motorola SVR4 man page for connect:
    **	   EAGAIN	       The socket is non-blocking and the  con-
    **			       nection cannot be completed immediately.
    **			       It is possible to select for  completion
    **			       by  selecting  the  socket  for writing.
    **			       However, this is only  possible	if  the
    **			       socket  STREAMS	module	is  the topmost
    **			       module on  the  protocol  stack	with  a
    **			       write  service  procedure.  This will be
    **			       the normal case.
    */
    if ((status < 0) &&
	(SOCKET_ERRNO == EINPROGRESS
d1708 1
a1708 1
	 || SOCKET_ERRNO == EAGAIN
d1710 4
a1713 4
	 )) {
	struct timeval select_timeout;
	int ret;
	int tries=0;
d1716 1
a1716 1
	HTInetStatus("this socket's first connect");
d1718 3
a1720 3
	ret = 0;
	while (ret <= 0) {
	    fd_set writefds;
d1722 5
a1726 5
	    /*
	    **	Protect against an infinite loop.
	    */
	    if ((tries++/10) >= connect_timeout) {
		HTAlert(gettext("Connection failed (too many retries)."));
d1728 3
a1730 3
		FREE(line);
		if (res0)
		    freeaddrinfo(res0);
d1732 2
a1733 3
		return HT_NO_DATA;
	    }

d1735 2
a1736 2
	    select_timeout.tv_sec = connect_timeout;
	    select_timeout.tv_usec = 0;
d1738 2
a1739 2
	    select_timeout.tv_sec = 0;
	    select_timeout.tv_usec = 100000;
d1741 2
a1742 2
	    FD_ZERO(&writefds);
	    FD_SET((unsigned) *s, &writefds);
d1744 4
a1747 4
	    if (socks_flag)
		ret = Rselect((unsigned)*s + 1, NULL,
			      (void *)&writefds, NULL, &select_timeout);
	    else
d1749 5
a1753 1
	    ret = select((unsigned)*s + 1, NULL, (void *)&writefds, NULL, &select_timeout);
d1756 3
a1758 3
	    if (tries == 1) {
		HTInetStatus("this socket's first select");
	    }
d1760 6
a1765 6
	    /*
	    **  If we suspend, then it is possible that select will be
	    **  interrupted.  Allow for this possibility. - JED
	    */
	    if ((ret == -1) && (errno == EINTR))
		continue;
d1768 3
a1770 3
	    if (ret < 0) {
		HTInetStatus("failed select");
	    }
a1771 14
	    /*
	    **	Again according to the Sun and Motorola man pages for connect:
	    **	   EALREADY	       The socket is non-blocking and a  previ-
	    **			       ous  connection attempt has not yet been
	    **			       completed.
	    **	Thus if the SOCKET_ERRNO is NOT EALREADY we have a real error,
	    **	and should break out here and return that error.
	    **	Otherwise if it is EALREADY keep on trying to complete the
	    **	connection.
	    */
	    if ((ret < 0) && (SOCKET_ERRNO != EALREADY)) {
		status = ret;
		break;
	    } else if (ret > 0) {
d1773 19
a1791 4
		**  Extra check here for connection success, if we try to
		**  connect again, and get EISCONN, it means we have a
		**  successful connection.  But don't check with SOCKS.
		*/
d1793 3
a1795 3
		if (socks_flag) {
		    status = 0;
		} else {
d1798 1
a1798 1
		status = connect(*s, res->ai_addr, res->ai_addrlen);
d1800 2
a1801 2
		status = connect(*s, (struct sockaddr*)&soc_address,
				 sizeof(soc_address));
d1804 6
a1809 7
		/*
		**  A UCX feature: Instead of returning EISCONN
		**		 UCX returns EADDRINUSE.
		**  Test for this status also.
		*/
		if ((status < 0) && ((SOCKET_ERRNO == EISCONN) ||
				     (SOCKET_ERRNO == EADDRINUSE)))
d1811 1
a1811 1
		if ((status < 0) && (SOCKET_ERRNO == EISCONN))
d1813 3
a1815 3
		{
		    status = 0;
		}
d1817 3
a1819 3
		if (status && (SOCKET_ERRNO == EALREADY)) /* new stuff LJM */
		    ret = 0; /* keep going */
		else {
d1821 3
a1823 3
		    if (status < 0) {
			HTInetStatus("confirm-ready connect");
		    }
d1825 2
a1826 2
		    break;
		}
d1828 2
a1830 2
#endif /* SOCKS */
	    }
d1832 1
a1832 1
	    else if (!socks_flag)
d1834 1
a1834 1
	    else
d1836 14
a1849 13
	    {
		/*
		**  The select says we aren't ready yet.  Try to connect
		**  again to make sure.  If we don't get EALREADY or EISCONN,
		**  something has gone wrong.  Break out and report it.
		**
		**  For some reason, SVR4 returns EAGAIN here instead of
		**  EALREADY, even though the man page says it should be
		**  EALREADY.
		**
		**  For some reason, UCX pre 3 apparently returns
		**  errno = 18242 instead the EALREADY or EISCONN.
		*/
d1851 1
a1851 1
		status = connect(*s, res->ai_addr, res->ai_addrlen);
d1853 2
a1854 2
		status = connect(*s, (struct sockaddr*)&soc_address,
				 sizeof(soc_address));
d1856 2
a1857 2
		if ((status < 0) &&
		    (SOCKET_ERRNO != EALREADY
d1859 1
a1859 1
		    && SOCKET_ERRNO != EAGAIN
d1861 1
a1861 1
		    ) &&
d1863 1
a1863 1
		    (SOCKET_ERRNO != 18242) &&
d1865 1
a1865 1
		    (SOCKET_ERRNO != EISCONN)) {
d1867 1
a1867 1
		    HTInetStatus("confirm-not-ready connect");
d1869 2
a1870 1
		    break;
d1872 3
a1874 4
	    }
	    if (HTCheckForInterrupt()) {
		CTRACE((tfp, "*** INTERRUPTED in middle of connect.\n"));
		status = HT_INTERRUPTED;
d1876 1
a1876 1
		WSASetLastError(EINTR);
d1878 1
a1878 1
		SOCKET_ERRNO = EINTR;
d1880 2
a1881 1
		break;
a1883 1
    }
d1885 3
a1887 3
    else if (status < 0) {
	HTInetStatus("this socket's first and only connect");
    }
d1891 3
a1893 3
		NETCLOSE(*s);
		*s = -1;
		continue;
d1906 3
a1908 3
	**  The connect attempt failed or was interrupted,
	**  so close up the socket.
	*/
d1915 2
a1916 2
	**  Make the socket blocking again on good connect.
	*/
d1919 1
d1939 5
a1943 6
**  This is so interruptible reads can be implemented cleanly.
*/
PUBLIC int HTDoRead ARGS3(
	int,		fildes,
	void *,		buf,
	unsigned,	nbyte)
d1948 2
a1949 1
    int tries=0;
d1952 1
a1952 1
    time_t otime = time((time_t *)0);
d1958 1
a1958 1
#ifdef UNIX
d1961 2
a1962 2
	 *  0 can be a valid socket fd, but if it's a tty something must
	 *  have gone wrong. - kw
a1980 1

d1988 2
a1989 2
	**  Protect against an infinite loop.
	*/
a1998 1

d2001 1
a2001 1
	    time_t t = time((time_t *)0);
d2012 3
a2014 3
	**  If we suspend, then it is possible that select will be
	**  interrupted.  Allow for this possibility. - JED
	*/
d2019 1
a2019 1
	    FD_SET((unsigned)fildes, &readfds);
d2022 2
a2023 2
		ret = Rselect((unsigned)fildes + 1,
			      (void *)&readfds, NULL, NULL, &select_timeout);
d2026 2
a2027 2
		ret = select((unsigned)fildes + 1,
			     (void *)&readfds, NULL, NULL, &select_timeout);
d2046 1
a2046 1
    while ((nb = SOCKET_READ (fildes, buf, nbyte)) == -1) {
d2057 2
a2058 2
#else  /* UNIX */
    return SOCKET_READ (fildes, buf, nbyte);
d2061 1
a2061 1
#else  /* UCX && VAXC */
d2063 2
a2064 2
    **	VAXC and UCX problem only.
    */
d2066 1
a2066 1
    nb = SOCKET_READ (fildes, buf, nbyte);
d2068 1
a2068 1
	   "Read - nb,errno,vaxc$errno: %d %d %d\n", nb,errno,vaxc$errno));
d2070 1
a2070 1
	perror ("HTTCP.C:HTDoRead:read");	   /* RJF */
d2072 2
a2073 2
    **	An errno value of EPIPE and nb < 0 indicates end-of-file on VAXC.
    */
d2084 14
a2097 14
**  This is a fix for the difference between BSD's select() and
**  SVR4's select().  SVR4's select() can never return a value larger
**  than the total number of file descriptors being checked.  So, if
**  you select for read and write on one file descriptor, and both
**  are true, SVR4 select() will only return 1.  BSD select in the
**  same situation will return 2.
**
**	Additionally, BSD select() on timing out, will zero the masks,
**	while SVR4 does not.  This is fixed here as well.
**
**	Set your tabstops to 4 characters to have this code nicely formatted.
**
**	Jerry Whelan, guru@@bradley.edu, June 12th, 1993
*/
d2112 5
a2116 6
PUBLIC int BSDselect ARGS5(
	int,			nfds,
	fd_set *,		readfds,
	fd_set *,		writefds,
	fd_set *,		exceptfds,
	struct timeval *,	select_timeout)
d2118 1
a2118 2
    int rval,
    i;
d2125 1
a2125 1
    rval = select(nfds, readfds, writefds, exceptfds, select_timeout);
d2128 2
a2129 2
	case -1:
	    return(rval);
d2131 17
a2147 17
	case 0:
	    if (readfds != NULL)
		FD_ZERO(readfds);
	    if (writefds != NULL)
		FD_ZERO(writefds);
	    if (exceptfds != NULL)
		FD_ZERO(exceptfds);
	    return(rval);

	default:
	    for (i = 0, rval = 0; i < nfds; i++) {
		if ((readfds != NULL) && FD_ISSET(i, readfds))
		    rval++;
		if ((writefds != NULL) && FD_ISSET(i, writefds))
		    rval++;
		if ((exceptfds != NULL) && FD_ISSET(i, exceptfds))
		    rval++;
d2149 2
a2150 2
	    }
	    return(rval);
@


1.4
log
@Stop the madness, though shalt not pass FD_SETSIZE as the first param to
select(2) needlessly.  deraadt@@ OK
@
text
@d35 1
a35 1
#if defined(__DJGPP__) && defined (WATT32)
a61 8
#ifndef FD_SETSIZE
#if defined(UCX) || defined(SOCKETSHR_TCP) || defined(CMU_TCP)
#define FD_SETSIZE 32
#else
#define FD_SETSIZE 256
#endif /* Limit # sockets to 32 for UCX, BSN - also SOCKETSHR and CMU, AH */
#endif /* FD_SETSIZE */

a70 1
extern BOOLEAN socks_flag;
d93 14
a106 4
#ifdef _WINDOWS_NSL
char host[512];
struct hostent  *phost;	/* Pointer to host - See netdb.h */
int donelookup;
d108 1
a108 1
static unsigned long _fork_func (void *arglist)
a384 2
#if !( defined(__DJGPP__) && !defined(WATT32) )    /* much excluded! */

d645 1
d679 4
d737 1
a737 1
	pid_t fpid, waitret;
d1083 1
a1083 1
			(int)waitret, WEXITSTATUS(waitstat)));
d1096 1
d1105 1
d1127 1
d1129 1
a1169 2
#endif /* from here on DJGPP without WATT32 joins us again. */

a1274 4

#if defined(__DJGPP__) && !defined(WATT32)
	soc_in->sin_addr.s_addr = htonl(aton(host));
#else
a1293 1
#endif /* __DJGPP__ && !WATT32 */
a1303 10
#if defined(__DJGPP__) && !defined(WATT32)
	if (!valid_hostname(host)) {
	    FREE(host);
	    return HT_NOT_ACCEPTABLE; /* only HTDoConnect checks this. */
	}
	soc_in->sin_addr.s_addr = htonl(resolve(host));
	if (soc_in->sin_addr.s_addr == 0) {
	    goto failed;
	}
#else /* !(__DJGPP__ && !WATT32) */
d1308 1
a1308 1
#else /* !(__DJGPP__ && !WATT32) && !_WINDOWS_NSL */
d1333 1
a1333 1
#endif /* __DJGPP__ && !WATT32 */
d1377 1
a1377 1
    char pbuf[10];
d1392 1
a1392 1
	snprintf(pbuf, sizeof(pbuf), "%d", defport);
a1424 4
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN 64		/* Arbitrary limit */
#endif /* MAXHOSTNAMELEN */

d1454 1
a1454 1
	domain_name = getenv("UCX$BIND_DOMAIN");
d1456 1
a1456 1
	    domain_name = getenv("TCPIP$BIND_DOMAIN");
d1527 1
a1527 1
    struct addrinfo *res, *res0;
a1557 1
    _HTProgress(host);
d1619 1
a1619 1
#ifndef DOSPATH
d1637 1
a1637 1
#endif /* !DOSPATH */
d1663 1
a1663 1
#ifndef __DJGPP__
d1706 2
a1707 1
		freeaddrinfo(res0);
d1723 1
a1723 1
		ret = Rselect(*s + 1, NULL,
d1727 1
a1727 1
	    ret = select(*s + 1, NULL, (void *)&writefds, NULL, &select_timeout);
d1871 1
a1871 1
#endif /* !__DJGPP__ */
d1884 1
a1884 1
#ifndef DOSPATH
d1900 1
a1900 1
#endif /* !DOSPATH */
d1904 2
a1905 1
    freeaddrinfo(res0);
d1922 1
a1922 1
#ifdef EXP_READPROGRESS
d1973 1
a1973 1
#ifdef EXP_READPROGRESS
d1996 1
a1996 1
		ret = Rselect(fildes + 1,
d2000 1
a2000 1
		ret = select(fildes + 1,
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d1736 1
a1736 1
		ret = Rselect(FD_SETSIZE, NULL,
d1740 1
a1740 1
	    ret = select(FD_SETSIZE, NULL, (void *)&writefds, NULL, &select_timeout);
d2008 1
a2008 1
		ret = Rselect(FD_SETSIZE,
d2012 1
a2012 1
		ret = select(FD_SETSIZE,
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d28 1
a28 1
#include <sys/wait.h>
d35 4
d47 1
a47 1
	struct timeval * timeout));
d94 1
a94 1
**	returns 	a negative status in the Unix way.
a95 12
#ifndef PCNFS

#ifdef VMS
#include <perror.h>
#ifndef errno
extern int errno;
#endif /* !errno */
#endif /* VMS */

#ifndef VM
#ifndef VMS
#ifndef THINK_C
a101 6
#endif /* !THINK_C */
#endif /* !VMS */
#endif /* !VM */

#endif	/* !PCNFS */

d103 3
a105 3
	 char host[512];
	 struct hostent  *phost;	/* Pointer to host - See netdb.h */
	 int donelookup;
d107 1
a107 1
unsigned long _fork_func (void *arglist)
d109 12
a120 3
	 phost = gethostbyname(host);
	 donelookup = TRUE;
	 return (unsigned long)(phost);
d129 1
a129 3
#include <iodef.h>
#define IOC_OUT (int)0x40000000
extern int vaxc$get_sdc(), sys$qiow();
d150 1
a150 1
	errno = EBADF;
d169 1
a169 1
	errno = status;
d173 1
a173 1
	errno = iosb[0];
d180 3
d187 1
a187 1
	char *, 	where)
d189 2
a196 4
    CTRACE(tfp,
	"TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n",
	   SOCKET_ERRNO,  where,
	   /* third arg is transport/platform specific */
d198 2
a199 1
	   "(Error number not translated)");	/* What Is the VM equiv? */
d205 2
a206 1
	   vms_errno_string());
d208 1
d210 1
a210 1
	    strerror(SOCKET_ERRNO) : "(Error number not translated)"));
d216 2
a217 1
	   strerror(SOCKET_ERRNO));
d222 1
d224 1
a224 1
	    sys_errlist[SOCKET_ERRNO] : "Unknown error" ));
d229 1
a229 1
    CTRACE(tfp,
d231 2
a232 2
	   SOCKET_ERRNO);
    CTRACE(tfp,
d234 1
a234 1
	   vaxc$errno);
d238 2
d245 1
a245 1
    return -vmserrno;
d247 1
a247 1
    return -vaxc$errno;
d250 1
a250 1
    return -SOCKET_ERRNO;
d252 1
d300 1
a300 1
	SockA*, 	soc_in)
d302 8
a309 1
    static char string[16];
d316 1
d327 1
d341 1
a341 1
	CONST char *,	name)
d344 1
a344 1
    CONST char *cp = name;
d355 2
d358 1
a358 1
		return NO;
d360 1
a360 1
	if (!isalnum((unsigned char)*cp) &&
d366 1
a366 1
    return (*cp == '\0' || (*cp == '.' && iseg != 0 && cp[1] == '\0'));
d384 1
a384 1
#ifndef DJGPP			/* much excluded! */
d403 1
a403 1
	CTRACE(tfp,"%s: %p ", msgprefix, phost);
d405 1
a405 1
	    CTRACE(tfp,"{ h_name = %p", phost->h_name);
d407 1
a407 1
		CTRACE(tfp, " \"%s\",", phost->h_name);
d409 1
a409 1
		CTRACE(tfp, ",");
d411 1
a411 1
	    CTRACE(tfp,"\n\t h_aliases = %p", phost->h_aliases);
d413 1
a413 1
		CTRACE(tfp, " {");
d415 1
a415 1
		    CTRACE(tfp,"%s %p \"%s\"",
d417 1
a417 1
			   *pcnt, *pcnt);
d419 2
a420 2
		CTRACE(tfp, "%s0x0 },\n\t",
		       (*phost->h_aliases ? ", " : " "));
d422 1
a422 1
		CTRACE(tfp, ",\n\t");
d424 3
a426 3
	    CTRACE(tfp," h_addrtype = %d,", phost->h_addrtype);
	    CTRACE(tfp," h_length = %d,\n\t", phost->h_length);
	    CTRACE(tfp," h_addr_list = %p", phost->h_addr_list);
d428 1
a428 1
		CTRACE(tfp, " {");
d430 1
a430 1
		    CTRACE(tfp,"%s %p",
d432 1
a432 1
			   *pcnt);
d434 1
a434 1
			CTRACE(tfp, "%s%d%s", (i==0 ? " \"" : "."),
d436 1
a436 1
			       (i+1 == phost->h_length ? "\"" : ""));
d440 1
a440 1
		    CTRACE(tfp, ", 0x0 } }");
d442 1
a442 1
		    CTRACE(tfp, " 0x0 } }");
d445 1
a445 1
		CTRACE(tfp, "}");
d448 1
a448 1
	CTRACE(tfp,"\n");
d461 9
d475 1
d535 2
a536 2
    ((struct hostent *)rehostent)->h_addrtype = phost->h_addrtype;
    ((struct hostent *)rehostent)->h_length = phost->h_length;
d545 1
a545 1
	((struct hostent *)rehostent)->h_addr_list = p_next_charptr;
d555 1
a555 1
	((struct hostent *)rehostent)->h_addr_list = NULL;
d559 1
a559 1
	((struct hostent *)rehostent)->h_name = p_next_char;
d567 1
a567 1
	((struct hostent *)rehostent)->h_name = NULL;
d571 1
a571 1
	((struct hostent *)rehostent)->h_aliases = p_next_charptr;
d589 1
a589 1
	((struct hostent *)rehostent)->h_aliases = NULL;
d594 1
a594 2

#define REHOSTENT_SIZE 128		/* not bigger than pipe buffer! */
d601 1
d604 1
d641 1
a641 1
	CONST char *,	str)
d644 2
a645 2
    CONST char *host = str;
#endif /* _WINDOWS_NSL */
d648 1
a648 4
    static struct {
	struct hostent	h;
	char		rest[REHOSTENT_SIZE];
    } aligned_full_rehostent;
d669 1
a669 1
	int child_errno;  /* maybe not very useful */
d680 1
a680 1
	CTRACE(tfp, "LYGetHostByName: Can't parse `NULL'.\n");
d684 1
a684 1
    CTRACE(tfp, "LYGetHostByName: parsing `%s'.\n", str);
d688 1
a688 1
	CTRACE (tfp, "LYGetHostByName: INTERRUPTED for '%s'.\n", str);
d693 4
d700 3
d705 1
a708 6
#ifdef _WINDOWS_NSL
    strncpy(host, str, (size_t)512);
#else
    host = str;
#endif /*  _WINDOWS_NSL */

d710 1
a710 1
    CTRACE(tfp, "LYGetHostByName: Calling gethostbyname(%s)\n", host);
d713 1
a713 1
    CTRACE_FLUSH(tfp);  /* so child messages will not mess parent log */
d725 4
d734 7
a740 2
	int pfd[2], selret, readret, waitstat = 0;
	time_t start_time = time(NULL);
d742 2
a743 2
	struct timeval timeout;
	int dns_patience = 30; /* how many seconds will we wait for DNS? */
d762 26
d825 5
d834 5
d840 1
d842 1
d844 1
d846 1
a846 1
	    CTRACE(tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost);
d864 4
d874 1
d894 8
d914 1
a914 1
	while (child_exited || time(NULL) - start_time < dns_patience) {
d934 2
a935 2
	    timeout.tv_sec = 1;
	    timeout.tv_usec = 0;
d945 1
a945 1
		selret = Rselect(pfd[0] + 1, (void *)&readfds, NULL, NULL, &timeout);
d948 1
a948 1
		selret = select(pfd[0] + 1, (void *)&readfds, NULL, NULL, &timeout);
d957 3
a959 2
		    errno = statuses.child_errno;
		    if (statuses.h_errno_valid)
d961 35
d1011 1
a1011 1
	    	    }
d1051 1
a1051 1
		CTRACE(tfp, "LYGetHostByName: INTERRUPTED gethostbyname.\n");
d1066 2
a1067 2
		CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",
		       (int)waitret, waitstat);
d1069 2
a1070 2
		CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",
		       (int)waitret, waitstat);
d1073 2
a1074 2
		    CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d dumped core!\n",
			   (int)waitret);
d1078 2
a1079 2
		CTRACE(tfp, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",
		       (int)waitret, waitstat);
d1090 29
a1118 35
#ifdef __BORLANDC__
		HANDLE hThread, dwThreadID;
#else
		unsigned long hThread, dwThreadID;
#endif /* __BORLANDC__ */
		phost = (struct hostent *) NULL;
		hThread = CreateThread((void *)NULL, 4096UL,
#ifdef __BORLANDC__
			 (LPTHREAD_START_ROUTINE)_fork_func,
#else
			 (unsigned long (*)())_fork_func,
#endif /* __BORLANDC__ */
			 (void *)NULL, 0UL, (unsigned long *)&dwThreadID);
		if (!hThread)
			 MessageBox((void *)NULL, "CreateThread",
				"CreateThread Failed", 0L);

		donelookup = FALSE;
		while (!donelookup)
			if (HTCheckForInterrupt())
			 {
			  /* Note that host is a character array and is not freed */
			  /* to avoid possible subthread problems: */
			  if (!CloseHandle(hThread))
				 MessageBox((void *)NULL, "CloseHandle","CloseHandle Failed",
						0L);
			  lynx_nsl_status = HT_INTERRUPTED;
			  return NULL;
			};
		if (phost) {
		    lynx_nsl_status = HT_OK;
		    result_phost = phost;
		} else {
		    lynx_nsl_status = HT_ERROR;
		    goto failed;
d1120 10
a1129 1
    };
d1134 1
a1134 1
	phost = gethostbyname((char *)host);	/* See netdb.h */
d1136 1
a1136 1
	CTRACE(tfp, "LYGetHostByName: gethostbyname() returned %d\n", phost);
d1151 1
a1151 1
    CTRACE(tfp, "LYGetHostByName: Resolved name to a hostent.\n");
d1157 2
a1158 2
    CTRACE(tfp, "LYGetHostByName: Can't find internet node name `%s'.\n",
		host);
d1162 1
a1162 1
#endif /* from here on DJGPP joins us again. */
d1177 2
a1178 1
PUBLIC int HTParseInet ARGS2(
d1184 1
d1190 1
a1190 1
	CTRACE(tfp, "HTParseInet: Can't parse `NULL'.\n");
d1193 1
a1193 1
    CTRACE(tfp, "HTParseInet: parsing `%s'.\n", str);
d1195 1
a1195 1
	CTRACE (tfp, "HTParseInet: INTERRUPTED for '%s'.\n", str);
d1199 1
a1199 1
    strncpy(host, str, (size_t)512);
d1208 1
d1210 2
a1211 2
#ifdef unix
	    soc_in->sin_port = htons(atol(port));
d1214 1
a1214 1
	    soc_in->sdn_objnum = (unsigned char)(strtol(port, (char**)0, 10));
d1216 1
a1216 1
	    soc_in->sin_port = htons((unsigned short)strtol(port,(char**)0,10));
d1219 1
a1219 1
#ifdef SUPPRESS 	/* 1. crashes!?!.  2. Not recommended */
d1225 1
a1225 1
		CTRACE(tfp, "TCP: Unknown service %s\n", port);
d1229 7
d1245 2
a1246 2
    CTRACE(tfp, "DECnet: Parsed address as object number %d on host %.6s...\n",
		soc_in->sdn_objnum, host);
d1250 1
a1250 1
	char *strptr = host;
d1254 1
a1254 1
	    } else if (!isdigit(*strptr)) {
d1267 2
a1268 1
    if (dotcount_ip == 3) {   /* Numeric node address: */
d1270 1
a1270 1
#ifdef DJGPP
d1281 1
a1281 1
	    CTRACE(tfp, "inet_aton(%s) returns error\n", host);
d1292 1
a1292 1
#endif /* DJGPP */
d1296 2
a1297 1
    } else {		    /* Alphanumeric node name: */
d1300 1
a1300 1
	CTRACE(tfp, "HTParseInet: Calling LYGetHostByName(%s)\n", host);
d1303 1
a1303 1
#ifdef DJGPP
d1312 1
a1312 1
#else /* !DJGPP: */
d1317 1
a1317 1
#else /* !DJGPP, !_WINDOWS_NSL: */
d1341 2
a1342 2
#endif /* !DJGPP, !_WINDOWS_NSL */
#endif /* !DJGPP */
d1349 1
a1349 1
    CTRACE(tfp, "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
d1354 1
a1354 1
		(int)*((unsigned char *)(&soc_in->sin_addr)+3));
d1360 2
a1361 2
    CTRACE(tfp, "HTParseInet: Can't find internet node name `%s'.\n",
		host);
d1366 6
a1371 5
    case HT_NOT_ACCEPTABLE:
    case HT_INTERRUPTED:
	return lynx_nsl_status;
    default:
    return -1;
d1373 43
d1417 1
d1445 4
d1450 1
d1455 1
a1455 1
	return; 			/* Already done */
d1466 1
a1466 1
    if (strchr(hostname,'.') == NULL) { 	  /* Not full address */
d1468 2
d1476 1
a1476 1
    CTRACE(tfp, "TCP: Local host name is %s\n", hostname);
d1480 16
d1498 2
a1499 2
	CTRACE(tfp, "TCP: Can't find my own internet node address for `%s'!!\n",
		    name);
d1504 3
a1506 2
    CTRACE(tfp, "     Name server says that I am `%s' = %s\n",
		hostname, HTInetString(&HTHostAddress));
d1518 5
d1524 1
a1524 1
**  Interruptable connect as implemented for Mosaic by Marc Andreesen
d1530 1
a1530 1
	char *, 	protocol,
d1534 1
a1534 3
    struct sockaddr_in soc_address;
    struct sockaddr_in *soc_in = &soc_address;
    int status;
d1539 5
d1550 2
a1551 1
    soc_in->sin_port = htons(default_port);
d1567 1
a1567 1
    HTSprintf0 (&line, gettext("Looking up %s."), host);
d1569 12
d1601 1
d1603 1
a1603 1
    HTSprintf0 (&line, gettext("Making %s connection to %s."), protocol, host);
d1611 15
d1631 1
d1660 3
d1665 1
d1672 3
d1676 2
a1677 1
#ifndef DJGPP
d1697 6
a1702 2
	(SOCKET_ERRNO == EINPROGRESS || SOCKET_ERRNO == EAGAIN)) {
	struct timeval timeout;
d1706 3
d1716 6
a1721 2
	    if (tries++ >= 180000) {
		HTAlert(gettext("Connection failed for 180,000 tries."));
d1726 2
a1727 1
	    timeout.tv_sec = 100;
d1729 2
a1730 1
	    timeout.tv_sec = 0;
a1731 1
	    timeout.tv_usec = 100000;
d1733 1
a1733 1
	    FD_SET(*s, &writefds);
d1737 1
a1737 1
			      (void *)&writefds, NULL, &timeout);
d1740 1
a1740 1
	    ret = select(FD_SETSIZE, NULL, (void *)&writefds, NULL, &timeout);
d1742 11
a1752 6
	   /*
	   **  If we suspend, then it is possible that select will be
	   **  interrupted.  Allow for this possibility. - JED
	   */
	   if ((ret == -1) && (errno == EINTR))
	     continue;
d1754 5
d1783 3
d1788 1
d1806 6
a1811 1
		else
d1813 1
d1836 3
d1841 1
d1843 5
a1847 1
		    (SOCKET_ERRNO != EALREADY && SOCKET_ERRNO != EAGAIN) &&
d1852 3
d1859 1
a1859 1
		CTRACE(tfp, "*** INTERRUPTED in middle of connect.\n");
d1861 3
d1865 1
d1870 21
a1890 2
#endif /* !DJGPP */
    if (status < 0) {
d1915 4
d1927 1
a1927 1
	void *, 	buf,
d1932 1
a1932 1
    struct timeval timeout;
d1934 4
d1949 1
a1949 1
	    CTRACE(tfp, "HTDoRead - refusing to read fd 0 which is a tty!\n");
d1958 3
d1962 1
d1977 3
d1981 1
d1985 12
d2002 2
a2003 2
	    timeout.tv_sec = 0;
	    timeout.tv_usec = 100000;
d2005 1
a2005 1
	    FD_SET(fildes, &readfds);
d2009 1
a2009 1
			      (void *)&readfds, NULL, NULL, &timeout);
d2013 1
a2013 1
			     (void *)&readfds, NULL, NULL, &timeout);
d2021 3
d2025 1
a2032 1
	int saved_errno = errno;
a2039 1
	errno = saved_errno;	/* our caller may check it */
d2053 2
a2054 2
    CTRACE(tfp,
	   "Read - nb,errno,vaxc$errno: %d %d %d\n", nb,errno,vaxc$errno);
d2062 1
a2062 1
	errno = 0;
d2103 1
a2103 1
	struct timeval *,	timeout)
d2110 1
a2110 1
	rval = Rselect(nfds, readfds, writefds, exceptfds, timeout);
d2113 1
a2113 1
    rval = select(nfds, readfds, writefds, exceptfds, timeout);
a2117 1
	    break;
a2126 1
	    break;
@


1.1
log
@Initial revision
@
text
@d19 6
a24 6
#include "HTUtils.h"
#include "tcp.h"		/* Defines SHORT_NAMES if necessary */
#include "HTAccess.h"
#include "HTParse.h"
#include "HTAlert.h"
#include "HTTCP.h"
d31 3
a33 1
#define FREE(x) if (x) {free(x); x = NULL;}
d35 1
a35 1
extern int HTCheckForInterrupt NOPARAMS;
d56 1
a56 7
#include "LYLeaks.h"

#ifdef SHORT_NAMES
#define HTInetStatus		HTInStat
#define HTInetString		HTInStri
#define HTParseInet		HTPaInet
#endif /* SHORT_NAMES */
d116 13
d310 732
d1051 1
a1051 1
**	*soc_in is filled in. If no port is specified in str, that
d1059 2
d1062 1
a1062 2
    int dotcount_ip = 0;	/* for dotted decimal IP addr */
    struct hostent  *phost;	/* Pointer to host - See netdb.h */
d1065 1
a1065 3
	if (TRACE) {
	    fprintf(stderr, "HTParseInet: Can't parse `NULL'.\n");
	}
d1068 1
d1070 1
a1070 3
	if (TRACE) {
	    fprintf (stderr, "HTParseInet: INTERRUPTED for '%s'.\n", str);
	}
d1073 3
d1077 1
a1077 1

d1098 2
a1099 2
	    } else if (TRACE) {
		fprintf(stderr, "TCP: Unknown service %s\n", port);
d1112 1
a1112 3
    if (TRACE) {
	fprintf(stderr,
		"DECnet: Parsed address as object number %d on host %.6s...\n",
a1113 1
    }
d1145 9
d1155 1
d1159 1
d1161 1
d1163 1
d1165 1
a1165 4
	if (TRACE) {
	    fprintf(stderr,
		    "HTParseInet: Calling gethostbyname(%s)\n", host);
	}
d1168 2
a1169 134
#ifdef NSL_FORK
	/*
	**  Start block for fork-based gethostbyname() with
	**  checks for interrupts. - Tom Zerucha (tz@@execpc.com) & FM
	*/
	{
	    /*
	    **	Pipe, child pid, and status buffers.
	    */
	    pid_t fpid, waitret = (pid_t)0;
	    int pfd[2], cstat, cst1 = 0;

	    pipe(pfd);

	    if ((fpid = fork()) == 0 ) {
		/*
		**  Child - for the long call.
		*/
		phost = gethostbyname(host);
		cst1 = 0;
		/*
		**  Return value (or nulls).
		*/
		if (phost != NULL)
		    write(pfd[1], phost->h_addr, phost->h_length);
		else
		    write(pfd[1], &cst1, 4);
		/*
		**  Return an error code.
		*/
		_exit(phost == NULL);
	    }

	    /*
	    **	(parent) Wait until lookup finishes, or interrupt.
	    */
	    cstat = 0;
	    while (cstat <= 0) {
		/*
		**  Exit when data sent.
		*/
		IOCTL(pfd[0], FIONREAD, &cstat);
		if (cstat > 0)
		    break;
		/*
		**  Exit if child exited.
		*/
		if ((waitret = waitpid(fpid, &cst1, WNOHANG)) > 0) {
		    break;
		}
		/*
		**  Abort if interrupt key pressed.
		*/
		if (HTCheckForInterrupt()) {
		    if (TRACE) {
			fprintf(stderr,
				"HTParseInet: INTERRUPTED gethostbyname.\n");
		    }
		    kill(fpid , SIGKILL);
		    waitpid(fpid, NULL, 0);
		    FREE(host);
		    close(pfd[0]);
		    close(pfd[1]);
		    return HT_INTERRUPTED;
		}
		/*
		**  Be nice to the system.
		*/
		sleep(1);
	    }
	    if (waitret <= 0) {
		waitret = waitpid(fpid, &cst1, WNOHANG);
	    }
	    if (TRACE) {
		if (WIFEXITED(cst1)) {
		    fprintf(stderr,
		      "HTParseInet: NSL_FORK child %d exited, status 0x%x.\n",
			    (int)waitret, cst1);
		} else if (WIFSIGNALED(cst1)) {
		    fprintf(stderr,
		  "HTParseInet: NSL_FORK child %d got signal, status 0x%x!\n",
			    (int)waitret, cst1);
#ifdef WCOREDUMP
		    if (WCOREDUMP(cst1)) {
			fprintf(stderr,
			      "HTParseInet: NSL_FORK child %d dumped core!\n",
				(int)waitret);
		    }
#endif /* WCOREDUMP */
		} else if (WIFSTOPPED(cst1)) {
		    fprintf(stderr,
		  "HTParseInet: NSL_FORK child %d is stopped, status 0x%x!\n",
			    (int)waitret, cst1);
		}
	    }
	    /*
	    **	Read as much as we can - should be the address.
	    */
	    IOCTL(pfd[0], FIONREAD, &cstat);
	    if (cstat < 4) {
		if (TRACE) {
		    fprintf(stderr,
		       "HTParseInet: NSL_FORK child returns only %d bytes.\n",
			    cstat);
		    fprintf(stderr,
			"             Trying again without forking.\n");
		}
		phost = gethostbyname(host);	/* See netdb.h */
		if (!phost) {
		    if (TRACE) {
			fprintf(stderr,
			 "HTParseInet: Can't find internet node name `%s'.\n",
				host);
		    }
		    memset((void *)&soc_in->sin_addr, 0, sizeof(soc_in->sin_addr));
		} else {
		    memcpy((void *)&soc_in->sin_addr,
			   phost->h_addr, phost->h_length);
		}
#ifdef NOTDEFINED
		cstat = read(pfd[0], (void *)&soc_in->sin_addr , 4);
#endif /* NOTDEFINED */
	    } else {
		cstat = read(pfd[0], (void *)&soc_in->sin_addr , cstat);
	    }
	    close(pfd[0]);
	    close(pfd[1]);
	}
	if (soc_in->sin_addr.s_addr == 0) {
	    if (TRACE) {
		fprintf(stderr,
			"HTParseInet: Can't find internet node name `%s'.\n",
			host);
	    }
d1171 1
a1171 1
	    return -1;
a1172 10
	FREE(host);
#ifdef MVS
	if (TRACE) {
	    fprintf(stderr,
		    "HTParseInet: gethostbyname() returned %d\n", phost);
	}
#endif /* MVS */

#else /* Not NSL_FORK: */
#ifdef DJGPP
a1173 1
	FREE(host);
d1175 1
a1175 4
		 if (TRACE)
			  fprintf(stderr,
			 "HTTPAccess: Can't find internet node name `%s'.\n",host);
		 return -1;  /* Fail? */
d1177 21
d1199 3
a1201 12
	phost = gethostbyname(host);	/* See netdb.h */
#ifdef MVS
	if (TRACE) {
	    fprintf(stderr,
		    "HTParseInet: gethostbyname() returned %d\n", phost);
	}
#endif /* MVS */
	if (!phost) {
	    if (TRACE) {
		fprintf(stderr,
			"HTParseInet: Can't find internet node name `%s'.\n",
			host);
d1203 2
a1204 2
	    FREE(host);
	    return -1;	/* Fail? */
d1206 3
d1210 3
a1212 16
#if defined(VMS) && defined(CMU_TCP)
	/*
	**  In LIBCMU, phost->h_length contains not the length of one address
	**  (four bytes) but the number of bytes in *h_addr, i.e. some multiple
	**  of four. Thus we need to hard code the value here, and remember to
	**  change it if/when IP addresses change in size. :-(	LIBCMU is no
	**  longer supported, and CMU users are encouraged to obtain and use
	**  SOCKETSHR/NETLIB instead. - S. Bjorndahl
	*/
	memcpy((void *)&soc_in->sin_addr, phost->h_addr, 4);
#else
	memcpy((void *)&soc_in->sin_addr, phost->h_addr, phost->h_length);
#endif /* VMS && CMU_TCP */
#endif /* DJGPP */
#endif /* NSL_FORK */
    }
d1214 1
a1214 3
    if (TRACE) {
	fprintf(stderr,
	   "HTParseInet: Parsed address as port %d, IP address %d.%d.%d.%d\n",
a1219 1
    }
d1223 14
d1239 1
d1248 1
d1273 1
d1275 1
d1294 3
a1296 4
    if (!phost) {
	if (TRACE) fprintf(stderr,
		"TCP: Can't find my own internet node address for `%s'!!\n",
		name);
d1301 2
a1302 2
    if (TRACE) fprintf(stderr, "     Name server says that I am `%s' = %s\n",
	    hostname, HTInetString(&HTHostAddress));
d1336 1
d1354 1
a1354 4
    line = (char *)calloc(1, (strlen(host) + strlen(protocol) + 128));
    if (line == NULL)
	outofmem(__FILE__, "HTDoConnect");
    sprintf (line, "Looking up %s.", host);
d1359 11
a1369 2
	    sprintf (line, "Unable to locate remote host %s.", host);
	    _HTProgress(line);
d1377 1
a1377 1
    sprintf (line, "Making %s connection to %s.", protocol, host);
d1380 1
d1387 1
a1387 2
	HTAlert("socket failed.");
	FREE(line);
d1406 1
a1406 1
	    _HTProgress("Could not make connection non-blocking.");
d1460 1
a1460 2
		HTAlert("Connection failed for 180,000 tries.");
		FREE(line);
d1464 3
d1468 1
d1566 1
a1566 2
		if (TRACE)
		    fprintf(stderr, "*** INTERRUPTED in middle of connect.\n");
d1594 1
a1594 1
	    _HTProgress("Could not restore socket to blocking.");
a1598 1
    FREE(line);
d1614 1
a1614 1
#ifdef UCX
d1618 12
d1648 1
a1648 1
	    HTAlert("Socket read failed for 180,000 tries.");
d1683 15
d1699 3
a1701 1
#else
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
