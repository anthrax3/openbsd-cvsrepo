head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAccess.h,v 1.20 2008/01/03 00:24:16 tom Exp $
 *					HTAccess:  Access manager for libwww
 *			ACCESS MANAGER
 *
 * This module keeps a list of valid protocol (naming scheme) specifiers with
 * associated access code.  It allows documents to be loaded given various
 * combinations of parameters.  New access protocols may be registered at any
 * time.
 *
 * Part of the libwww library .
 *
 */
#ifndef HTACCESS_H
#define HTACCESS_H

/*      Definition uses:
*/
#include <HTAnchor.h>
#include <HTFormat.h>

#ifdef __cplusplus
extern "C" {
#endif
    extern char *use_this_url_instead;

    extern int redirection_attempts;

/*      Return codes from load routines:
 *
 *      These codes may be returned by the protocol modules,
 *      and by the HTLoad routines.
 *      In general, positive codes are OK and negative ones are bad.
 */

/*

Default Addresses

   These control the home page selection.  To mess with these for normal browses is asking
   for user confusion.

 */
#define LOGICAL_DEFAULT "WWW_HOME"	/* Defined to be the home page */

#ifndef PERSONAL_DEFAULT
#define PERSONAL_DEFAULT "WWW/default.html"	/* in home directory */
#endif
#ifndef LOCAL_DEFAULT_FILE
#define LOCAL_DEFAULT_FILE "/usr/local/lib/WWW/default.html"
#endif
/*  If one telnets to a www access point,
    it will look in this file for home page */
#ifndef REMOTE_POINTER
#define REMOTE_POINTER  "/etc/www-remote.url"	/* can't be file */
#endif
/* and if that fails it will use this. */
#ifndef REMOTE_ADDRESS
#define REMOTE_ADDRESS  "http://www.w3.org/remote.html"		/* can't be file */
#endif

/* If run from telnet daemon and no -l specified, use this file:
*/
#ifndef DEFAULT_LOGFILE
#define DEFAULT_LOGFILE "/usr/adm/www-log/www-log"
#endif

/*      If the home page isn't found, use this file:
*/
#ifndef LAST_RESORT
#define LAST_RESORT     "http://www.w3.org/default.html"
#endif

/*

Flags which may be set to control this module

 */
#ifdef NOT
    extern int HTDiag;		/* Flag: load source as plain text */
#endif				/* NOT */
    extern char *HTClientHost;	/* Name or number of telnetting host */
    extern FILE *HTlogfile;	/* File to output one-liners to */
    extern BOOL HTSecure;	/* Disable security holes? */
    extern BOOL HTPermitRedir;	/* Special flag for getfile() */
    extern HTStream *HTOutputStream;	/* For non-interactive, set this */
    extern HTFormat HTOutputFormat;	/* To convert on load, set this */

/*	Check for proxy override.			override_proxy()
 *
 *	Check the no_proxy environment variable to get the list
 *	of hosts for which proxy server is not consulted.
 *
 *	no_proxy is a comma- or space-separated list of machine
 *	or domain names, with optional :port part.  If no :port
 *	part is present, it applies to all ports on that domain.
 *
 *  Example:
 *          no_proxy="cern.ch,some.domain:8001"
 *
 *  Use "*" to override all proxy service:
 *	     no_proxy="*"
 */
    extern BOOL override_proxy(const char *addr);

/*

Load a document from relative name

  ON ENTRY,
  relative_name           The relative address of the file to be accessed.
  here                    The anchor of the object being searched

  ON EXIT,
  returns    YES          Success in opening file
  NO                      Failure

 */
    extern BOOL HTLoadRelative(const char *relative_name,
			       HTParentAnchor *here);

/*

Load a document from absolute name

  ON ENTRY,
  addr                    The absolute address of the document to be accessed.
  filter_it               if YES, treat document as HTML

  ON EXIT,
  returns YES             Success in opening document
  NO                      Failure

 */
    extern BOOL HTLoadAbsolute(const DocAddress *addr);

/*

Load a document from absolute name to a stream

  ON ENTRY,
  addr                    The absolute address of the document to be accessed.
  filter_it               if YES, treat document as HTML

  ON EXIT,
  returns YES             Success in opening document
  NO                      Failure

   Note: This is equivalent to HTLoadDocument

 */
    extern BOOL HTLoadToStream(const char *addr, BOOL filter_it,
			       HTStream *sink);

/*

Load if necessary, and select an anchor

  ON ENTRY,
  destination                The child or parent anchor to be loaded.

  ON EXIT,
  returns YES             Success
  returns NO              Failure

 */
    extern BOOL HTLoadAnchor(HTAnchor * destination);

/*

Make a stream for Saving object back

  ON ENTRY,
  anchor                  is valid anchor which has previously been loaded

  ON EXIT,
  returns                 0 if error else a stream to save the object to.

 */
    extern HTStream *HTSaveStream(HTParentAnchor *anchor);

/*

Search

   Performs a search on word given by the user.  Adds the search words to the end of the
   current address and attempts to open the new address.

  ON ENTRY,
  *keywords               space-separated keyword list or similar search list
  here                    The anchor of the object being searched

 */
    extern BOOL HTSearch(const char *keywords, HTParentAnchor *here);

/*

Search Given Indexname

   Performs a keyword search on word given by the user.  Adds the keyword to  the end of
   the current address and attempts to open the new address.

  ON ENTRY,
  *keywords               space-separated keyword list or similar search list
  *indexname              is name of object search is to be done on.

 */
    extern BOOL HTSearchAbsolute(const char *keywords,
				 char *indexname);

/*

Register an access method

 */

    typedef struct _HTProtocol {
	const char *name;

	int (*load) (const char *full_address,
		     HTParentAnchor *anchor,
		     HTFormat format_out,
		     HTStream *sink);

	HTStream *(*saveStream) (HTParentAnchor *anchor);

    } HTProtocol;

    extern BOOL HTRegisterProtocol(HTProtocol * protocol);

/*

Generate the anchor for the home page

 */

/*

   As it involves file access, this should only be done once when the program first runs.
   This is a default algorithm -- browser don't HAVE to use this.

 */
    extern HTParentAnchor *HTHomeAnchor(void);

/*

Return Host Name

 */
    extern const char *HTHostName(void);

/*

For registering protocols supported by Lynx

*/
    extern void LYRegisterLynxProtocols(void);

    extern void LYUCPushAssumed(HTParentAnchor *anchor);
    extern int LYUCPopAssumed(void);

    extern BOOL using_proxy;	/* Are we using an NNTP proxy? */

#ifdef __cplusplus
}
#endif
#endif				/* HTACCESS_H */
@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 12
a12 9
/*                                                      HTAccess:  Access manager  for libwww
                                      ACCESS MANAGER

   This module keeps a list of valid protocol (naming scheme) specifiers with associated
   access code.  It allows documents to be loaded given various combinations of
   parameters.  New access protocols may be registered at any time.

   Part of the libwww library .

d160 1
a160 1
  destination                The child or parenet anchor to be loaded.
d174 1
a174 1
  anchor                  is valid anchor which has previously beeing loaded
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@a13 4
extern char * use_this_url_instead;

extern int redirection_attempts;

d19 7
d27 5
a31 6
**
**      These codes may be returned by the protocol modules,
**      and by the HTLoad routines.
**      In general, positive codes are OK and negative ones are bad.
*/

d41 1
a41 1
#define LOGICAL_DEFAULT "WWW_HOME"  /* Defined to be the home page */
d44 1
a44 1
#define PERSONAL_DEFAULT "WWW/default.html"     /* in home directory */
d52 1
a52 1
#define REMOTE_POINTER  "/etc/www-remote.url"  /* can't be file */
d56 1
a56 1
#define REMOTE_ADDRESS  "http://www.w3.org/remote.html"  /* can't be file */
a70 1

d77 8
a84 8
extern int HTDiag;                      /* Flag: load source as plain text */
#endif /* NOT */
extern char * HTClientHost;             /* Name or number of telnetting host */
extern FILE * HTlogfile;                /* File to output one-liners to */
extern BOOL HTSecure;                   /* Disable security holes? */
extern BOOL HTPermitRedir;              /* Special flag for getfile() */
extern HTStream* HTOutputStream;        /* For non-interactive, set this */
extern HTFormat HTOutputFormat;         /* To convert on load, set this */
d87 15
a101 16
**
**	Check the no_proxy environment variable to get the list
**	of hosts for which proxy server is not consulted.
**
**	no_proxy is a comma- or space-separated list of machine
**	or domain names, with optional :port part.  If no :port
**	part is present, it applies to all ports on that domain.
**
**  Example:
**          no_proxy="cern.ch,some.domain:8001"
**
**  Use "*" to override all proxy service:
**	     no_proxy="*"
*/
extern BOOL override_proxy PARAMS((
	CONST char *	addr));
d116 2
a117 4
extern  BOOL HTLoadRelative PARAMS((
		CONST char *		relative_name,
		HTParentAnchor *	here));

d132 1
a132 2
extern BOOL HTLoadAbsolute PARAMS((CONST DocAddress * addr));

d149 2
a150 3
extern BOOL HTLoadToStream PARAMS((CONST char * addr, BOOL filter_it,
				HTStream * sink));

d164 1
a164 2
extern BOOL HTLoadAnchor PARAMS((HTAnchor * destination));

d177 1
a177 2
extern HTStream * HTSaveStream PARAMS((HTParentAnchor * anchor));

d191 1
a191 2
extern BOOL HTSearch PARAMS((CONST char * keywords, HTParentAnchor* here));

d205 2
a206 4
extern BOOL HTSearchAbsolute PARAMS((
	CONST char *	keywords,
	char *		indexname));

d214 2
a215 2
typedef struct _HTProtocol {
	char * name;
d217 4
a220 5
	int (*load)PARAMS((
		CONST char *	full_address,
		HTParentAnchor * anchor,
		HTFormat	format_out,
		HTStream*	sink));
d222 1
a222 1
	HTStream* (*saveStream)PARAMS((HTParentAnchor * anchor));
d224 1
a224 3
} HTProtocol;

extern BOOL HTRegisterProtocol PARAMS((HTProtocol * protocol));
d226 1
d240 1
a240 1
extern HTParentAnchor * HTHomeAnchor NOPARAMS;
d247 1
a247 1
extern CONST char * HTHostName NOPARAMS;
d254 1
a254 1
extern void LYRegisterLynxProtocols NOARGS;
d256 2
a257 3
extern void LYUCPushAssumed PARAMS((
    HTParentAnchor *	anchor));
extern int LYUCPopAssumed NOPARAMS;
d259 1
a259 1
extern BOOL using_proxy;	/* Are we using an NNTP proxy? */
d261 4
a264 1
#endif /* HTACCESS_H */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a107 1

a108 1

a111 1

a112 1

d117 2
a118 2
                CONST char *            relative_name,
                HTParentAnchor *        here));
a125 1

a126 1

a128 4
 */

/*

a129 5

 */

/*

a130 1

a141 1

a142 1

a145 1

a146 1

d153 1
a153 1
                                HTStream * sink));
a160 1

a162 4
 */

/*

a163 5

 */

/*

a164 1

a167 3



a175 1

a178 1

a181 2


a192 1

a193 1

a207 1

a208 1

d213 2
a214 2
        CONST char *    keywords,
        char *    	indexname));
d224 1
a224 1
        char * name;
d226 5
a230 5
        int (*load)PARAMS((
                CONST char *    full_address,
                HTParentAnchor * anchor,
                HTFormat        format_out,
                HTStream*       sink));
d232 1
a232 1
        HTStream* (*saveStream)PARAMS((HTParentAnchor * anchor));
d271 2
a273 3
/*

   end of HTAccess  */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d16 2
d81 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
                                             
d6 2
a7 2
   parameters. New access protocols may be registered at any time.
   
d9 1
a9 1
   
d18 2
a19 13
#ifndef HTUTILS_H
#include "HTUtils.h"
#endif /* HTUTILS_H */
#include "tcp.h"
#include "HTAnchor.h"
#include "HTFormat.h"

#ifdef SHORT_NAMES
#define HTClientHost            HTClHost
#define HTSearchAbsolute        HTSeAbso
#define HTOutputStream          HTOuStre
#define HTOutputFormat          HTOuForm
#endif
a27 2
#define HT_NO_DATA -9999        /* return code: OK but no data was loaded */
                                /* Typically, other app started or forked */
d33 1
a33 1
   These control the home page selection. To mess with these for normal browses is asking
d35 1
a35 1
   
d105 1
a105 1
  
d107 1
a107 1
                         
d109 1
a109 1
                         
d111 1
a111 1
  
d113 1
a113 1
                         
d115 1
a115 1
                         
d127 1
a127 1
  
d129 1
a129 1
                         
d131 1
a131 1
                         
d137 1
a137 1
  
d143 1
a143 1
                         
d145 1
a145 1
                         
d155 1
a155 1
  
d157 1
a157 1
                         
d159 1
a159 1
                         
d161 1
a161 1
  
d163 1
a163 1
                         
d165 1
a165 1
                         
d167 1
a167 1
   
d178 1
a178 1
  
d180 1
a180 1
                         
d186 1
a186 1
  
d192 1
a192 1
                         
d194 1
a194 1
                         
d207 1
a207 1
  
d209 1
a209 1
                         
d211 1
a211 1
  
d213 1
a213 1
                         
d224 1
a224 1
   Performs a search on word given by the user. Adds the search words to the end of the
d226 1
a226 1
   
d228 1
a228 1
  
d230 1
a230 1
                         
d232 1
a232 1
                         
d241 1
a241 1
   Performs a keyword search on word given by the user. Adds the keyword to  the end of
d243 1
a243 1
   
d245 1
a245 1
  
d247 1
a247 1
                         
d249 1
a249 1
                         
d253 1
a253 1
        CONST char *    indexname));
d264 1
a264 1
        
d270 1
a270 1
                
d288 1
a288 1
   
d308 1
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
