head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.04.22.36.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAccess.c,v 1.79 2013/11/28 11:11:05 tom Exp $
 *
 *		Access Manager					HTAccess.c
 *		==============
 *
 *  Authors
 *	TBL	Tim Berners-Lee timbl@@info.cern.ch
 *	JFG	Jean-Francois Groff jfg@@dxcern.cern.ch
 *	DD	Denis DeLaRoca (310) 825-4580  <CSP1DWD@@mvs.oac.ucla.edu>
 *	FM	Foteos Macrides macrides@@sci.wfeb.edu
 *	PDM	Danny Mayer mayer@@ljo.dec.com
 *
 *  History
 *	 8 Jun 92 Telnet hopping prohibited as telnet is not secure TBL
 *	26 Jun 92 When over DECnet, suppressed FTP, Gopher and News. JFG
 *	 6 Oct 92 Moved HTClientHost and logfile into here. TBL
 *	17 Dec 92 Tn3270 added, bug fix. DD
 *	 4 Feb 93 Access registration, Search escapes bad chars TBL
 *		  PARAMETERS TO HTSEARCH AND HTLOADRELATIVE CHANGED
 *	28 May 93 WAIS gateway explicit if no WAIS library linked in.
 *	31 May 94 Added DIRECT_WAIS support for VMS. FM
 *	27 Jan 95 Fixed proxy support to use NNTPSERVER for checking
 *		  whether or not to use the proxy server. PDM
 *	27 Jan 95 Ensured that proxy service will be overridden for files
 *		  on the local host (because HTLoadFile() doesn't try ftp
 *		  for those) and will substitute ftp for remote files. FM
 *	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
 *		  for news and wais URL's. FM
 *
 *  Bugs
 *	This module assumes that that the graphic object is hypertext, as it
 *	needs to select it when it has been loaded.  A superclass needs to be
 *	defined which accepts select and select_anchor.
 */

#ifdef VMS
#define DIRECT_WAIS
#endif /* VMS */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTAlert.h>
/*
 *  Implements:
 */
#include <HTAccess.h>

/*
 *  Uses:
 */
#include <HTParse.h>
#include <HTML.h>		/* SCW */

#ifndef NO_RULES
#include <HTRules.h>
#endif

#include <HTList.h>
#include <HText.h>		/* See bugs above */
#include <HTCJK.h>
#include <UCMap.h>
#include <GridText.h>

#include <LYGlobalDefs.h>
#include <LYexit.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

/*
 *  These flags may be set to modify the operation of this module
 */
char *HTClientHost = NULL;	/* Name of remote login host if any */
FILE *HTlogfile = NULL;		/* File to which to output one-liners */
BOOL HTSecure = NO;		/* Disable access for telnet users? */
BOOL HTPermitRedir = NO;	/* Always allow redirection in getfile()? */

BOOL using_proxy = NO;		/* are we using a proxy gateway? */

/*
 *  To generate other things, play with these:
 */
HTFormat HTOutputFormat = NULL;
HTStream *HTOutputStream = NULL;	/* For non-interactive, set this */

static HTList *protocols = NULL;	/* List of registered protocol descriptors */

char *use_this_url_instead = NULL;

static int pushed_assume_LYhndl = -1;	/* see LYUC* functions below - kw */
static char *pushed_assume_MIMEname = NULL;

#ifdef LY_FIND_LEAKS
static void free_protocols(void)
{
    HTList_delete(protocols);
    protocols = NULL;
    FREE(pushed_assume_MIMEname);	/* shouldn't happen, just in case - kw */
}
#endif /* LY_FIND_LEAKS */

/*	Register a Protocol.				HTRegisterProtocol()
 *	--------------------
 */
BOOL HTRegisterProtocol(HTProtocol * protocol)
{
    if (!protocols) {
	protocols = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(free_protocols);
#endif
    }
    HTList_addObject(protocols, protocol);
    return YES;
}

/*	Register all known protocols.			HTAccessInit()
 *	-----------------------------
 *
 *	Add to or subtract from this list if you add or remove protocol
 *	modules.  This routine is called the first time the protocol list
 *	is needed, unless any protocols are already registered, in which
 *	case it is not called.	Therefore the application can override
 *	this list.
 *
 *	Compiling with NO_INIT prevents all known protocols from being
 *	forced in at link time.
 */
#ifndef NO_INIT
#ifdef GLOBALREF_IS_MACRO
extern GLOBALREF (HTProtocol, HTTP);
extern GLOBALREF (HTProtocol, HTTPS);
extern GLOBALREF (HTProtocol, HTFile);
extern GLOBALREF (HTProtocol, HTTelnet);
extern GLOBALREF (HTProtocol, HTTn3270);
extern GLOBALREF (HTProtocol, HTRlogin);

#ifndef DECNET
#ifndef DISABLE_FTP
extern GLOBALREF (HTProtocol, HTFTP);
#endif /* DISABLE_FTP */
#ifndef DISABLE_NEWS
extern GLOBALREF (HTProtocol, HTNews);
extern GLOBALREF (HTProtocol, HTNNTP);
extern GLOBALREF (HTProtocol, HTNewsPost);
extern GLOBALREF (HTProtocol, HTNewsReply);
extern GLOBALREF (HTProtocol, HTSNews);
extern GLOBALREF (HTProtocol, HTSNewsPost);
extern GLOBALREF (HTProtocol, HTSNewsReply);
#endif /* not DISABLE_NEWS */
#ifndef DISABLE_GOPHER
extern GLOBALREF (HTProtocol, HTGopher);
extern GLOBALREF (HTProtocol, HTCSO);
#endif /* not DISABLE_GOPHER */
#ifndef DISABLE_FINGER
extern GLOBALREF (HTProtocol, HTFinger);
#endif /* not DISABLE_FINGER */
#ifdef DIRECT_WAIS
extern GLOBALREF (HTProtocol, HTWAIS);
#endif /* DIRECT_WAIS */
#endif /* !DECNET */
#else
GLOBALREF HTProtocol HTTP, HTTPS, HTFile, HTTelnet, HTTn3270, HTRlogin;

#ifndef DECNET
#ifndef DISABLE_FTP
GLOBALREF HTProtocol HTFTP;
#endif /* DISABLE_FTP */
#ifndef DISABLE_NEWS
GLOBALREF HTProtocol HTNews, HTNNTP, HTNewsPost, HTNewsReply;
GLOBALREF HTProtocol HTSNews, HTSNewsPost, HTSNewsReply;
#endif /* not DISABLE_NEWS */
#ifndef DISABLE_GOPHER
GLOBALREF HTProtocol HTGopher, HTCSO;
#endif /* not DISABLE_GOPHER */
#ifndef DISABLE_FINGER
GLOBALREF HTProtocol HTFinger;
#endif /* not DISABLE_FINGER */
#ifdef DIRECT_WAIS
GLOBALREF HTProtocol HTWAIS;
#endif /* DIRECT_WAIS */
#endif /* !DECNET */
#endif /* GLOBALREF_IS_MACRO */

static void HTAccessInit(void)	/* Call me once */
{
    HTRegisterProtocol(&HTTP);
    HTRegisterProtocol(&HTTPS);
    HTRegisterProtocol(&HTFile);
    HTRegisterProtocol(&HTTelnet);
    HTRegisterProtocol(&HTTn3270);
    HTRegisterProtocol(&HTRlogin);
#ifndef DECNET
#ifndef DISABLE_FTP
    HTRegisterProtocol(&HTFTP);
#endif /* DISABLE_FTP */
#ifndef DISABLE_NEWS
    HTRegisterProtocol(&HTNews);
    HTRegisterProtocol(&HTNNTP);
    HTRegisterProtocol(&HTNewsPost);
    HTRegisterProtocol(&HTNewsReply);
    HTRegisterProtocol(&HTSNews);
    HTRegisterProtocol(&HTSNewsPost);
    HTRegisterProtocol(&HTSNewsReply);
#endif /* not DISABLE_NEWS */
#ifndef DISABLE_GOPHER
    HTRegisterProtocol(&HTGopher);
    HTRegisterProtocol(&HTCSO);
#endif /* not DISABLE_GOPHER */
#ifndef DISABLE_FINGER
    HTRegisterProtocol(&HTFinger);
#endif /* not DISABLE_FINGER */
#ifdef DIRECT_WAIS
    HTRegisterProtocol(&HTWAIS);
#endif /* DIRECT_WAIS */
#endif /* !DECNET */
    LYRegisterLynxProtocols();
}
#endif /* !NO_INIT */

/*	Check for proxy override.			override_proxy()
 *	-------------------------
 *
 *	Check the no_proxy environment variable to get the list
 *	of hosts for which proxy server is not consulted.
 *
 *	no_proxy is a comma- or space-separated list of machine
 *	or domain names, with optional :port part.  If no :port
 *	part is present, it applies to all ports on that domain.
 *
 *  Example:
 *	    no_proxy="cern.ch,some.domain:8001"
 *
 *  Use "*" to override all proxy service:
 *	     no_proxy="*"
 */
BOOL override_proxy(const char *addr)
{
    const char *no_proxy = getenv("no_proxy");
    char *p = NULL;
    char *at = NULL;
    char *host = NULL;
    char *Host = NULL;
    char *acc_method = NULL;
    int port = 0;
    int h_len = 0;

    /*
     * Check for global override.
     */
    if (no_proxy) {
	if (!strcmp(no_proxy, "*"))
	    return YES;
    }

    /*
     * Never proxy file:// URLs if they are on the local host.  HTLoadFile()
     * will not attempt ftp for those if direct access fails.  We'll check that
     * first, in case no_proxy hasn't been defined.  - FM
     */
    if (!addr)
	return NO;
    if (!(host = HTParse(addr, "", PARSE_HOST)))
	return NO;
    if (!*host) {
	FREE(host);
	return NO;
    }
    Host = (((at = StrChr(host, '@@')) != NULL) ? (at + 1) : host);

    if ((acc_method = HTParse(addr, "", PARSE_ACCESS))) {
	if (!strcmp("file", acc_method) &&
	    (LYSameHostname(Host, "localhost") ||
	     LYSameHostname(Host, HTHostName()))) {
	    FREE(host);
	    FREE(acc_method);
	    return YES;
	}
	FREE(acc_method);
    }

    if (!no_proxy) {
	FREE(host);
	return NO;
    }

    if (NULL != (p = HTParsePort(Host, &port))) {	/* Port specified */
	*p = 0;			/* Chop off port */
    } else {			/* Use default port */
	acc_method = HTParse(addr, "", PARSE_ACCESS);
	if (acc_method != NULL) {
	    /* *INDENT-OFF* */
	    if	    (!strcmp(acc_method, "http"))	port = 80;
	    else if (!strcmp(acc_method, "https"))	port = 443;
	    else if (!strcmp(acc_method, "ftp"))	port = 21;
#ifndef DISABLE_GOPHER
	    else if (!strcmp(acc_method, "gopher"))	port = 70;
#endif
	    else if (!strcmp(acc_method, "cso"))	port = 105;
#ifndef DISABLE_NEWS
	    else if (!strcmp(acc_method, "news"))	port = 119;
	    else if (!strcmp(acc_method, "nntp"))	port = 119;
	    else if (!strcmp(acc_method, "newspost"))	port = 119;
	    else if (!strcmp(acc_method, "newsreply"))	port = 119;
	    else if (!strcmp(acc_method, "snews"))	port = 563;
	    else if (!strcmp(acc_method, "snewspost"))	port = 563;
	    else if (!strcmp(acc_method, "snewsreply")) port = 563;
#endif
	    else if (!strcmp(acc_method, "wais"))	port = 210;
#ifndef DISABLE_FINGER
	    else if (!strcmp(acc_method, "finger"))	port = 79;
#endif
	    else if (!strcmp(acc_method, "telnet"))	port = 23;
	    else if (!strcmp(acc_method, "tn3270"))	port = 23;
	    else if (!strcmp(acc_method, "rlogin"))	port = 513;
	    /* *INDENT-ON* */

	    FREE(acc_method);
	}
    }
    if (!port)
	port = 80;		/* Default */
    h_len = (int) strlen(Host);

    while (*no_proxy) {
	const char *end;
	const char *colon = NULL;
	int templ_port = 0;
	int t_len;
	int brackets = 0;

	while (*no_proxy && (WHITE(*no_proxy) || *no_proxy == ','))
	    no_proxy++;		/* Skip whitespace and separators */

	end = no_proxy;
	while (*end && !WHITE(*end) && *end != ',') {	/* Find separator */
	    if (!brackets && (*end == ':'))
		colon = end;	/* Port number given */
	    else if (*end == '[')
		++brackets;
	    else if (*end == ']')
		--brackets;
	    end++;
	}

	if (colon) {
	    /* unlike HTParsePort(), this may be followed by non-digits */
	    templ_port = atoi(colon + 1);
	    t_len = (int) (colon - no_proxy);
	} else {
	    t_len = (int) (end - no_proxy);
	}

	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
	     !strncasecomp(Host + h_len - t_len, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#ifdef CJK_EX			/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port) &&
	    (t_len > 0 && t_len <= h_len &&
	     isdigit(UCH(*no_proxy)) &&
	     !StrNCmp(host, no_proxy, t_len))) {
	    FREE(host);
	    return YES;
	}
#endif /* ASATAKU PROXY HACK */

	if (*end)
	    no_proxy = (end + 1);
	else
	    break;
    }

    FREE(host);
    return NO;
}

/*	Find physical name and access protocol		get_physical()
 *	--------------------------------------
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		HT_NO_ACCESS		Error has occurred.
 *			HT_OK			Success
 */
static int get_physical(const char *addr,
			HTParentAnchor *anchor)
{
    int result;
    char *acc_method = NULL;	/* Name of access method */
    char *physical = NULL;
    char *Server_addr = NULL;
    BOOL override_flag = NO;

    CTRACE((tfp, "get_physical %s\n", addr));

    /*
     * Make sure the using_proxy variable is FALSE.
     */
    using_proxy = NO;

#ifndef NO_RULES
    if ((physical = HTTranslate(addr)) == 0) {
	if (redirecting_url) {
	    return HT_REDIRECTING;
	}
	return HT_FORBIDDEN;
    }
    if (anchor->isISMAPScript == TRUE) {
	StrAllocCat(physical, "?0,0");
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
    }
    if (!StrNCmp(physical, "Proxied=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	using_proxy = YES;
    } else if (!StrNCmp(physical, "NoProxy=", 8)) {
	HTAnchor_setPhysical(anchor, physical + 8);
	override_flag = YES;
    } else {
	HTAnchor_setPhysical(anchor, physical);
    }
    FREE(physical);		/* free our copy */
#else
    if (anchor->isISMAPScript == TRUE) {
	StrAllocCopy(physical, addr);
	StrAllocCat(physical, "?0,0");
	CTRACE((tfp, "HTAccess: Appending '?0,0' coordinate pair.\n"));
	HTAnchor_setPhysical(anchor, physical);
	FREE(physical);		/* free our copy */
    } else {
	HTAnchor_setPhysical(anchor, addr);
    }
#endif /* NO_RULES */

    acc_method = HTParse(HTAnchor_physical(anchor), STR_FILE_URL, PARSE_ACCESS);

    /*
     * Check whether gateway access has been set up for this.
     *
     * This function can be replaced by the rule system above.
     *
     * If the rule system has already determined that we should use a proxy, or
     * that we shouldn't, ignore proxy-related settings, don't use no_proxy
     * either.
     */
#define USE_GATEWAYS
#ifdef USE_GATEWAYS

    if (!override_flag && !using_proxy) {	/* else ignore no_proxy env var */
	char *host = NULL;
	int port;

	if (!strcasecomp(acc_method, "news")) {
	    /*
	     * News is different, so we need to check the name of the server,
	     * as well as the default port for selective exclusions.
	     */
	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (HTParsePort(host, &port) == NULL) {
		    StrAllocCopy(Server_addr, "news://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":119/");
		}
		FREE(host);
	    } else if (LYGetEnv("NNTPSERVER") != NULL) {
		StrAllocCopy(Server_addr, "news://");
		StrAllocCat(Server_addr, LYGetEnv("NNTPSERVER"));
		StrAllocCat(Server_addr, ":119/");
	    }
	} else if (!strcasecomp(acc_method, "wais")) {
	    /*
	     * Wais also needs checking of the default port for selective
	     * exclusions.
	     */
	    if ((host = HTParse(addr, "", PARSE_HOST))) {
		if (!(HTParsePort(host, &port))) {
		    StrAllocCopy(Server_addr, "wais://");
		    StrAllocCat(Server_addr, host);
		    StrAllocCat(Server_addr, ":210/");
		}
		FREE(host);
	    } else
		StrAllocCopy(Server_addr, addr);
	} else {
	    StrAllocCopy(Server_addr, addr);
	}
	override_flag = override_proxy(Server_addr);
    }

    if (!override_flag && !using_proxy) {
	char *gateway_parameter = NULL, *gateway, *proxy;

	/*
	 * Search for gateways.
	 */
	HTSprintf0(&gateway_parameter, "WWW_%s_GATEWAY", acc_method);
	gateway = LYGetEnv(gateway_parameter);	/* coerce for decstation */

	/*
	 * Search for proxy servers.
	 */
	if (!strcmp(acc_method, "file"))
	    /*
	     * If we got to here, a file URL is for ftp on a remote host. - FM
	     */
	    strcpy(gateway_parameter, "ftp_proxy");
	else
	    sprintf(gateway_parameter, "%s_proxy", acc_method);
	proxy = LYGetEnv(gateway_parameter);
	FREE(gateway_parameter);

	if (gateway)
	    CTRACE((tfp, "Gateway found: %s\n", gateway));
	if (proxy)
	    CTRACE((tfp, "proxy server found: %s\n", proxy));

	/*
	 * Proxy servers have precedence over gateway servers.
	 */
	if (proxy) {
	    char *gatewayed = NULL;

	    StrAllocCopy(gatewayed, proxy);
	    if (!StrNCmp(gatewayed, "http", 4)) {
		char *cp = strrchr(gatewayed, '/');

		/* Append a slash to the proxy specification if it doesn't
		 * end in one but otherwise looks normal (starts with "http",
		 * has no '/' other than ones before the hostname). - kw */
		if (cp && (cp - gatewayed) <= 7)
		    LYAddHtmlSep(&gatewayed);
	    }
	    /*
	     * Ensure that the proxy server uses ftp for file URLs. - FM
	     */
	    if (!StrNCmp(addr, "file", 4)) {
		StrAllocCat(gatewayed, "ftp");
		StrAllocCat(gatewayed, (addr + 4));
	    } else
		StrAllocCat(gatewayed, addr);
	    using_proxy = YES;
	    if (anchor->isISMAPScript == TRUE)
		StrAllocCat(gatewayed, "?0,0");
	    HTAnchor_setPhysical(anchor, gatewayed);
	    FREE(gatewayed);
	    FREE(acc_method);

	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);

	} else if (gateway) {
	    char *path = HTParse(addr, "",
				 PARSE_HOST + PARSE_PATH + PARSE_PUNCTUATION);

	    /* Chop leading / off to make host into part of path */
	    char *gatewayed = HTParse(path + 1, gateway, PARSE_ALL);

	    FREE(path);
	    HTAnchor_setPhysical(anchor, gatewayed);
	    FREE(gatewayed);
	    FREE(acc_method);

	    acc_method = HTParse(HTAnchor_physical(anchor),
				 STR_HTTP_URL, PARSE_ACCESS);
	}
    }
    FREE(Server_addr);
#endif /* use gateways */

    /*
     * Search registered protocols to find suitable one.
     */
    result = HT_NO_ACCESS;
    {
	int i, n;

#ifndef NO_INIT
	if (!protocols)
	    HTAccessInit();
#endif
	n = HTList_count(protocols);
	for (i = 0; i < n; i++) {
	    HTProtocol *p = (HTProtocol *) HTList_objectAt(protocols, i);

	    if (!strcmp(p->name, acc_method)) {
		HTAnchor_setProtocol(anchor, p);
		FREE(acc_method);
		result = HT_OK;
		break;
	    }
	}
    }

    FREE(acc_method);
    return result;
}

/*
 * Temporarily set the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec
 * used for charset "assuming" to the values implied by a HTParentAnchor's
 * UCStages, after saving the current values for later restoration.  - kw @@@@@@
 * These functions may not really belong here, but where else?  I want the
 * "pop" to occur as soon as possible after loading has finished.  - kw @@@@@@
 */
void LYUCPushAssumed(HTParentAnchor *anchor)
{
    int anchor_LYhndl = -1;
    LYUCcharset *anchor_UCI = NULL;

    if (anchor) {
	anchor_LYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
	if (anchor_LYhndl >= 0)
	    anchor_UCI = HTAnchor_getUCInfoStage(anchor,
						 UCT_STAGE_PARSER);
	if (anchor_UCI && anchor_UCI->MIMEname) {
	    pushed_assume_MIMEname = UCAssume_MIMEcharset;
	    UCAssume_MIMEcharset = NULL;
	    if (HTCJK == JAPANESE)
		StrAllocCopy(UCAssume_MIMEcharset, pushed_assume_MIMEname);
	    else
		StrAllocCopy(UCAssume_MIMEcharset, anchor_UCI->MIMEname);
	    pushed_assume_LYhndl = anchor_LYhndl;
	    /* some diagnostics */
	    if (UCLYhndl_for_unspec != anchor_LYhndl)
		CTRACE((tfp,
			"LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
			UCLYhndl_for_unspec,
			anchor_LYhndl));
	    UCLYhndl_for_unspec = anchor_LYhndl;
	    return;
	}
    }
    pushed_assume_LYhndl = -1;
    FREE(pushed_assume_MIMEname);
}

/*
 * Restore the int UCLYhndl_for_unspec and string UCLYhndl_for_unspec used for
 * charset "assuming" from the values saved by LYUCPushAssumed, if any.  - kw
 */
int LYUCPopAssumed(void)
{
    if (pushed_assume_LYhndl >= 0) {
	/* some diagnostics */
	if (UCLYhndl_for_unspec != pushed_assume_LYhndl)
	    CTRACE((tfp,
		    "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
		    UCLYhndl_for_unspec,
		    pushed_assume_LYhndl));
	UCLYhndl_for_unspec = pushed_assume_LYhndl;
	pushed_assume_LYhndl = -1;
	FREE(UCAssume_MIMEcharset);
	UCAssume_MIMEcharset = pushed_assume_MIMEname;
	pushed_assume_MIMEname = NULL;
	return UCLYhndl_for_unspec;
    }
    return -1;
}

/*	Load a document					HTLoad()
 *	---------------
 *
 *	This is an internal routine, which has an address AND a matching
 *	anchor.  (The public routines are called with one OR the other.)
 *
 *  On entry,
 *	addr		must point to the fully qualified hypertext reference.
 *	anchor		a parent anchor with whose address is addr
 *
 *  On exit,
 *	returns		<0		Error has occurred.
 *			HT_LOADED	Success
 *			HT_NO_DATA	Success, but no document loaded.
 *					(telnet session started etc)
 */
static int HTLoad(const char *addr,
		  HTParentAnchor *anchor,
		  HTFormat format_out,
		  HTStream *sink)
{
    HTProtocol *p;
    int status = get_physical(addr, anchor);

    if (reloading) {
	FREE(anchor->charset);
	FREE(anchor->UCStages);
    }

    if (status == HT_FORBIDDEN) {
	/* prevent crash if telnet or similar was forbidden by rule. - kw */
	LYFixCursesOn("show alert:");
	status = HTLoadError(sink, 500, gettext("Access forbidden by rule"));
    } else if (status == HT_REDIRECTING) {
	;			/* fake redirection by rule, to redirecting_url */
    } else if (status >= 0) {
	/* prevent crash if telnet or similar mapped or proxied by rule. - kw */
	LYFixCursesOnForAccess(addr, HTAnchor_physical(anchor));
	p = (HTProtocol *) HTAnchor_protocol(anchor);
	anchor->parent->underway = TRUE;	/* Hack to deal with caching */
	status = p->load(HTAnchor_physical(anchor),
			 anchor, format_out, sink);
	anchor->parent->underway = FALSE;
	LYUCPopAssumed();
    }
    return status;
}

/*	Get a save stream for a document		HTSaveStream()
 *	--------------------------------
 */
HTStream *HTSaveStream(HTParentAnchor *anchor)
{
    HTProtocol *p = (HTProtocol *) HTAnchor_protocol(anchor);

    if (!p)
	return NULL;

    return p->saveStream(anchor);
}

int redirection_attempts = 0;	/* counter in HTLoadDocument */

/*	Load a document - with logging etc		HTLoadDocument()
 *	----------------------------------
 *
 *	- Checks or documents already loaded
 *	- Logs the access
 *	- Allows stdin filter option
 *	- Trace output and error messages
 *
 *  On Entry,
 *	  anchor	    is the node_anchor for the document
 *	  full_address	    The address of the document to be accessed.
 *	  filter	    if YES, treat stdin as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
static BOOL HTLoadDocument(const char *full_address,	/* may include #fragment */
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
{
    int status;
    HText *text;
    const char *address_to_load = full_address;
    char *cp;
    BOOL ForcingNoCache = LYforce_no_cache;

    CTRACE((tfp, "HTAccess: loading document %s\n", address_to_load));

    /*
     * Free use_this_url_instead and reset permanent_redirection if not done
     * elsewhere.  - FM
     */
    FREE(use_this_url_instead);
    permanent_redirection = FALSE;

    /*
     * Make sure some yoyo doesn't send us 'round in circles with redirecting
     * URLs that point back to themselves.  We'll set the original Lynx limit
     * of 10 redirections per requested URL from a user, because the HTTP/1.1
     * will no longer specify a restriction to 5, but will leave it up to the
     * browser's discretion, in deference to Microsoft.  - FM
     */
    if (redirection_attempts > 10) {
	redirection_attempts = 0;
	HTAlert(TOO_MANY_REDIRECTIONS);
	return NO;
    }

    /*
     * If this is marked as an internal link but we don't have the document
     * loaded any more, and we haven't explicitly flagged that we want to
     * reload with LYforce_no_cache, then something has disappeared from the
     * cache when we expected it to be still there.  The user probably doesn't
     * expect a new network access.  So if we have POST data and safe is not
     * set in the anchor, ask for confirmation, and fail if not granted.  The
     * exception are LYNXIMGMAP documents, for which we defer to LYLoadIMGmap
     * for prompting if necessary.  - kw
     */
    text = (HText *) HTAnchor_document(anchor);
    if (LYinternal_flag && !text && !LYforce_no_cache &&
	anchor->post_data && !anchor->safe &&
	!isLYNXIMGMAP(full_address) &&
	HTConfirm(gettext("Document with POST content not found in cache.  Resubmit?"))
	!= TRUE) {
	return NO;
    }

    /*
     * If we don't have POST content, check whether this is a previous
     * redirecting URL, and keep re-checking until we get to the final
     * destination or redirection limit.  If we do have POST content, we didn't
     * allow permanent redirection, and an interactive user will be deciding
     * whether to keep redirecting.  - FM
     */
    if (!anchor->post_data) {
	while ((cp = HTAnchor_physical(anchor)) != NULL &&
	       !StrNCmp(cp, "Location=", 9)) {
	    DocAddress NewDoc;

	    CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		    anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp + 9));

	    /*
	     * Don't exceed the redirection_attempts limit.  - FM
	     */
	    if (++redirection_attempts > 10) {
		HTAlert(TOO_MANY_REDIRECTIONS);
		redirection_attempts = 0;
		FREE(use_this_url_instead);
		return NO;
	    }

	    /*
	     * Set up the redirection. - FM
	     */
	    StrAllocCopy(use_this_url_instead, cp + 9);
	    NewDoc.address = use_this_url_instead;
	    NewDoc.post_data = NULL;
	    NewDoc.post_content_type = NULL;
	    NewDoc.bookmark = anchor->bookmark;
	    NewDoc.isHEAD = anchor->isHEAD;
	    NewDoc.safe = anchor->safe;
	    anchor = HTAnchor_findAddress(&NewDoc);
	}
    }
    /*
     * If we had previous redirection, go back and check out that the URL under
     * the current restrictions.  - FM
     */
    if (use_this_url_instead) {
	FREE(redirecting_url);
	return (NO);
    }

    /*
     * See if we can use an already loaded document.
     */
    text = (HText *) HTAnchor_document(anchor);
    if (text && !LYforce_no_cache) {
	/*
	 * We have a cached rendition of the target document.  Check if it's OK
	 * to re-use it.  We consider it OK if:
	 * (1) the anchor does not have the no_cache element set, or
	 * (2) we've overridden it, e.g., because we are acting on a PREV_DOC
	 * command or a link in the History Page and it's not a reply from a
	 * POST with the LYresubmit_posts flag set, or
	 * (3) we are repositioning within the currently loaded document based
	 * on the target anchor's address (URL_Reference).
	 *
	 * If track_internal_links is false, HText_AreDifferent() is
	 * used to determine whether (3) applies.  If the target address
	 * differs from that of the current document only by a fragment and the
	 * target address has an appended fragment, repositioning without
	 * reloading is always assumed.  Note that HText_AreDifferent()
	 * currently always returns TRUE if the target has a LYNXIMGMAP URL, so
	 * that an internally generated pseudo-document will normally not be
	 * re-used unless condition (2) applies.  (Condition (1) cannot apply
	 * since in LYMap.c, no_cache is always set in the anchor object). 
	 * This doesn't guarantee that the resource from which the MAP element
	 * is taken will be read again (reloaded) when the list of links for a
	 * client-side image map is regenerated, when in some cases it should
	 * (e.g., user requested RELOAD, or HTTP response with no-cache header
	 * and we are not overriding).
	 *
	 * If track_internal_links is true, a target address that
	 * points to the same URL as the current document may still result in
	 * reloading, depending on whether the original URL-Reference was given
	 * as an internal link in the context of the previously loaded
	 * document.  HText_AreDifferent() is not used here for testing whether
	 * we are just repositioning.  For an internal link, the potential
	 * callers of this function from mainloop() down will either avoid
	 * making the call (and do the repositioning differently) or set
	 * LYinternal_flag (or LYoverride_no_cache).  Note that (a) LYNXIMGMAP
	 * pseudo-documents and (b) The "List Page" document are treated
	 * logically as being part of the document on which they are based, for
	 * the purpose of whether to treat a link as internal, but the logic
	 * for this (by setting LYinternal_flag as necessary) is implemented
	 * elsewhere.  There is a specific test for LYNXIMGMAP here so that the
	 * generated pseudo-document will not be re-used unless
	 * LYoverride_no_cache is set.  The same caveat as above applies w.r.t. 
	 * reloading of the underlying resource.
	 *
	 * We also should be checking other aspects of cache regulation (e.g.,
	 * based on an If-Modified-Since check, etc.) but the code for doing
	 * those other things isn't available yet.
	 */
	if ((reloading != REAL_RELOAD) &&
	    (LYoverride_no_cache ||
	     ((!track_internal_links &&
	       (!HText_hasNoCacheSet(text) ||
		!HText_AreDifferent(anchor, full_address))) ||
	      (track_internal_links &&
	       (((LYinternal_flag || !HText_hasNoCacheSet(text)) &&
		 !isLYNXIMGMAP(full_address))))))) {
	    CTRACE((tfp, "HTAccess: Document already in memory.\n"));
	    HText_select(text);

#ifdef DIRED_SUPPORT
	    if (HTAnchor_format(anchor) == WWW_DIRED)
		lynx_edit_mode = TRUE;
#endif
	    redirection_attempts = 0;
	    return YES;
	} else {
	    ForcingNoCache = YES;
	    BStrFree(anchor->post_data);
	    CTRACE((tfp, "HTAccess: Auto-reloading document.\n"));
	}
    }

    if (HText_HaveUserChangedForms(text)) {
	/*
	 * Issue a warning.  User forms content will be lost.
	 * Will not restore changed forms, currently.
	 */
	HTAlert(RELOADING_FORM);
    }

    /*
     * Get the document from the net.  If we are auto-reloading, the mutable
     * anchor elements from the previous rendition should be freed in
     * conjunction with loading of the new rendition.  - FM
     */
    LYforce_no_cache = NO;	/* reset after each time through */
    if (ForcingNoCache) {
	FREE(anchor->title);	/* ??? */
    }
    status = HTLoad(address_to_load, anchor, format_out, sink);
    CTRACE((tfp, "HTAccess:  status=%d\n", status));

    /*
     * RECOVERY:  if the loading failed, and we had a cached HText copy, and no
     * new HText created - use a previous copy, issue a warning.
     */
    if (text && status < 0 && (HText *) HTAnchor_document(anchor) == text) {
	HTAlert(gettext("Loading failed, use a previous copy."));
	CTRACE((tfp, "HTAccess: Loading failed, use a previous copy.\n"));
	HText_select(text);

#ifdef DIRED_SUPPORT
	if (HTAnchor_format(anchor) == WWW_DIRED)
	    lynx_edit_mode = TRUE;
#endif
	redirection_attempts = 0;
	return YES;
    }

    /*
     * Log the access if necessary.
     */
    if (HTlogfile) {
	time_t theTime;

	time(&theTime);
	fprintf(HTlogfile, "%24.24s %s %s %s\n",
		ctime(&theTime),
		HTClientHost ? HTClientHost : "local",
		status < 0 ? "FAIL" : "GET",
		full_address);
	fflush(HTlogfile);	/* Actually update it on disk */
	CTRACE((tfp, "Log: %24.24s %s %s %s\n",
		ctime(&theTime),
		HTClientHost ? HTClientHost : "local",
		status < 0 ? "FAIL" : "GET",
		full_address));
    }

    /*
     * Check out what we received from the net.
     */
    if (status == HT_REDIRECTING) {
	/* Exported from HTMIME.c, of all places.  */
	/* NO!! - FM */
	/*
	 * Doing this via HTMIME.c meant that the redirection cover page was
	 * already loaded before we learned that we want a different URL. 
	 * Also, changing anchor->address, as Lynx was doing, meant we could
	 * never again access its hash table entry, creating an insolvable
	 * memory leak.  Instead, if we had a 301 status and set
	 * permanent_redirection, we'll load the new URL in anchor->physical,
	 * preceded by a token, which we can check to make replacements on
	 * subsequent access attempts.  We'll check recursively, and retrieve
	 * the final URL if we had multiple redirections to it.  If we just
	 * went to HTLoad now, as Lou originally had this, we couldn't do
	 * Lynx's security checks and alternate handling of some URL types. 
	 * So, instead, we'll go all the way back to the top of getfile in
	 * LYGetFile.c when the status is HT_REDIRECTING.  This may seem
	 * bizarre, but it works like a charm!  - FM
	 *
	 * Actually, the location header for redirections is now again picked
	 * up in HTMIME.c.  But that's an internal matter between HTTP.c and
	 * HTMIME.c, is still under control of HTLoadHTTP for http URLs, is
	 * done in a way that doesn't load the redirection response's body
	 * (except when wanted as an error fallback), and thus need not concern
	 * us here.  - kw 1999-12-02
	 */
	CTRACE((tfp, "HTAccess: '%s' is a redirection URL.\n",
		address_to_load));
	CTRACE((tfp, "HTAccess: Redirecting to '%s'\n",
		redirecting_url));
	/*
	 * Prevent circular references.
	 */
	if (strcmp(address_to_load, redirecting_url)) {		/* if different */
	    /*
	     * Load token and redirecting url into anchor->physical if we had
	     * 301 Permanent redirection.  HTTP.c does not allow this if we
	     * have POST content.  - FM
	     */
	    if (permanent_redirection) {
		StrAllocCopy(anchor->physical, "Location=");
		StrAllocCat(anchor->physical, redirecting_url);
	    }

	    /*
	     * Set up flags before return to getfile.  - FM
	     */
	    StrAllocCopy(use_this_url_instead, redirecting_url);
	    if (ForcingNoCache)
		LYforce_no_cache = YES;
	    ++redirection_attempts;
	    FREE(redirecting_url);
	    permanent_redirection = FALSE;
	    return (NO);
	}
	++redirection_attempts;
	FREE(redirecting_url);
	permanent_redirection = FALSE;
	return (YES);
    }

    /*
     * We did not receive a redirecting URL.  - FM
     */
    redirection_attempts = 0;
    FREE(redirecting_url);
    permanent_redirection = FALSE;

    if (status == HT_LOADED) {
	CTRACE((tfp, "HTAccess: `%s' has been accessed.\n",
		full_address));
	return YES;
    }
    if (status == HT_PARTIAL_CONTENT) {
	HTAlert(gettext("Loading incomplete."));
	CTRACE((tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		full_address));
	return YES;
    }

    if (status == HT_NO_DATA) {
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		full_address));
	return NO;
    }

    if (status == HT_NOT_LOADED) {
	CTRACE((tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		full_address));
	return NO;
    }

    if (status == HT_INTERRUPTED) {
	CTRACE((tfp,
		"HTAccess: `%s' has been accessed, transfer interrupted.\n",
		full_address));
	return NO;
    }

    if (status > 0) {
	/*
	 * If you get this, then please find which routine is returning a
	 * positive unrecognized error code!
	 */
	fprintf(stderr,
		gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n"));
	fprintf(stderr,
		gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@nongnu.org!\n"));
	fprintf(stderr, gettext("**** HTAccess: Status returned was: %d\n"), status);
	exit_immediately(EXIT_FAILURE);
    }

    /* Failure in accessing a document */
    cp = NULL;
    StrAllocCopy(cp, gettext("Can't Access"));
    StrAllocCat(cp, " `");
    StrAllocCat(cp, full_address);
    StrAllocCat(cp, "'");
    _HTProgress(cp);
    FREE(cp);

    CTRACE((tfp, "HTAccess: Can't access `%s'\n", full_address));
    HTLoadError(sink, 500, gettext("Unable to access document."));
    return NO;
}				/* HTLoadDocument */

/*	Load a document from absolute name.		HTLoadAbsolute()
 *	-----------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  filter   if YES, treat document as HTML
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadAbsolute(const DocAddress *docaddr)
{
    return HTLoadDocument(docaddr->address,
			  HTAnchor_findAddress(docaddr),
			  (HTOutputFormat ? HTOutputFormat : WWW_PRESENT),
			  HTOutputStream);
}

#ifdef NOT_USED_CODE
/*	Load a document from absolute name to stream.	HTLoadToStream()
 *	---------------------------------------------
 *
 *  On Entry,
 *	  addr	   The absolute address of the document to be accessed.
 *	  sink	   if non-NULL, send data down this stream
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadToStream(const char *addr,
		    BOOL filter,
		    HTStream *sink)
{
    return HTLoadDocument(addr,
			  HTAnchor_findSimpleAddress(addr),
			  (HTOutputFormat ? HTOutputFormat : WWW_PRESENT),
			  sink);
}
#endif /* NOT_USED_CODE */

/*	Load a document from relative name.		HTLoadRelative()
 *	-----------------------------------
 *
 *  On Entry,
 *	  relative_name     The relative address of the document
 *			    to be accessed.
 *
 *  On Exit,
 *	  returns    YES     Success in opening document
 *		     NO      Failure
 */
BOOL HTLoadRelative(const char *relative_name,
		    HTParentAnchor *here)
{
    DocAddress full_address;
    BOOL result;
    char *mycopy = NULL;
    char *stripped = NULL;

    full_address.address = NULL;
    full_address.post_data = NULL;
    full_address.post_content_type = NULL;
    full_address.bookmark = NULL;
    full_address.isHEAD = FALSE;
    full_address.safe = FALSE;

    StrAllocCopy(mycopy, relative_name);

    stripped = HTStrip(mycopy);
    full_address.address =
	HTParse(stripped,
		here->address,
		PARSE_ALL_WITHOUT_ANCHOR);
    result = HTLoadAbsolute(&full_address);
    /*
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  - FM
     */
    FREE(full_address.address);
    FREE(mycopy);		/* Memory leak fixed 10/7/92 -- JFG */
    return result;
}

/*	Load if necessary, and select an anchor.	HTLoadAnchor()
 *	----------------------------------------
 *
 *  On Entry,
 *	  destination		    The child or parent anchor to be loaded.
 *
 *  On Exit,
 *	  returns    YES     Success
 *		     NO      Failure
 */
BOOL HTLoadAnchor(HTAnchor * destination)
{
    HTParentAnchor *parent;
    BOOL loaded = NO;

    if (!destination)
	return NO;		/* No link */

    parent = HTAnchor_parent(destination);

    if (HTAnchor_document(parent) == NULL) {	/* If not already loaded */
	/* TBL 921202 */
	BOOL result;

	result = HTLoadDocument(parent->address,
				parent,
				HTOutputFormat ?
				HTOutputFormat : WWW_PRESENT,
				HTOutputStream);
	if (!result)
	    return NO;
	loaded = YES;
    } {
	HText *text = (HText *) HTAnchor_document(parent);

	if ((destination != (HTAnchor *) parent) &&
	    (destination != (HTAnchor *) (parent->parent))) {
	    /* If child anchor */
	    HText_selectAnchor(text,	/* Double display? @@@@ */
			       (HTChildAnchor *) destination);
	} else {
	    if (!loaded)
		HText_select(text);
	}
    }
    return YES;

}				/* HTLoadAnchor */

/*	Search.						HTSearch()
 *	-------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	 *keywords	space-separated keyword list or similar search list
 *	here		is anchor search is to be done on.
 */
static char hex(int i)
{
    const char *hexchars = "0123456789ABCDEF";

    return hexchars[i];
}

BOOL HTSearch(const char *keywords,
	      HTParentAnchor *here)
{
#define acceptable \
"1234567890abcdefghijlkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-_"

    char *q, *u;
    const char *p, *s, *e;	/* Pointers into keywords */
    char *address = NULL;
    BOOL result;
    char *escaped = typecallocn(char, (strlen(keywords) * 3) + 1);
    static const BOOL isAcceptable[96] =
    /* *INDENT-OFF* */
    /*	 0 1 2 3 4 5 6 7 8 9 A B C D E F */
    {	 0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,	/* 2x	!"#$%&'()*+,-./  */
	 1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,	/* 3x  0123456789:;<=>?  */
	 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	/* 4x  @@ABCDEFGHIJKLMNO  */
	 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,	/* 5X  PQRSTUVWXYZ[\]^_  */
	 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	/* 6x  `abcdefghijklmno  */
	 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };	/* 7X  pqrstuvwxyz{\}~	DEL */
    /* *INDENT-ON* */

    if (escaped == NULL)
	outofmem(__FILE__, "HTSearch");

    assert(escaped != NULL);

    StrAllocCopy(address, here->isIndexAction);

    /*
     * Convert spaces to + and hex escape unacceptable characters.
     */
    for (s = keywords; *s && WHITE(*s); s++)	/* Scan */
	;			/* Skip white space */
    for (e = s + strlen(s); e > s && WHITE(*(e - 1)); e--)	/* Scan */
	;			/* Skip trailers */
    for (q = escaped, p = s; p < e; p++) {	/* Scan stripped field */
	unsigned char c = UCH(TOASCII(*p));

	if (WHITE(*p)) {
	    *q++ = '+';
	} else if (IS_CJK_TTY) {
	    *q++ = *p;
	} else if (c >= 32 && c <= UCH(127) && isAcceptable[c - 32]) {
	    *q++ = *p;		/* 930706 TBL for MVS bug */
	} else {
	    *q++ = '%';
	    *q++ = hex((int) (c >> 4));
	    *q++ = hex((int) (c & 15));
	}
    }				/* Loop over string */
    *q = '\0';			/* Terminate escaped string */
    u = StrChr(address, '?');	/* Find old search string */
    if (u != NULL)
	*u = '\0';		/* Chop old search off */

    StrAllocCat(address, "?");
    StrAllocCat(address, escaped);
    FREE(escaped);
    result = HTLoadRelative(address, here);
    FREE(address);

    /*
     * If we got redirection, result will be NO, but use_this_url_instead will
     * be set.  The calling routine should check both and do whatever is
     * appropriate.  Only an http server (not a gopher or wais server) could
     * return redirection.  Lynx will go all the way back to its mainloop() and
     * subject a redirecting URL to all of its security and restrictions
     * checks.  - FM
     */
    return result;
}

/*	Search Given Indexname.			HTSearchAbsolute()
 *	-----------------------
 *
 *	Performs a keyword search on word given by the user.  Adds the
 *	keyword to the end of the current address and attempts to open
 *	the new address.
 *
 *  On Entry,
 *	*keywords	space-separated keyword list or similar search list
 *	*indexname	is name of object search is to be done on.
 */
BOOL HTSearchAbsolute(const char *keywords,
		      char *indexname)
{
    DocAddress abs_doc;
    HTParentAnchor *anchor;

    abs_doc.address = indexname;
    abs_doc.post_data = NULL;
    abs_doc.post_content_type = NULL;
    abs_doc.bookmark = NULL;
    abs_doc.isHEAD = FALSE;
    abs_doc.safe = FALSE;

    anchor = HTAnchor_findAddress(&abs_doc);
    return HTSearch(keywords, anchor);
}

#ifdef NOT_USED_CODE
/*	Generate the anchor for the home page.		HTHomeAnchor()
 *	--------------------------------------
 *
 *	As it involves file access, this should only be done once
 *	when the program first runs.
 *	This is a default algorithm -- browser don't HAVE to use this.
 *	But consistency between browsers is STRONGLY recommended!
 *
 *  Priority order is:
 *		1	WWW_HOME environment variable (logical name, etc)
 *		2	~/WWW/default.html
 *		3	/usr/local/bin/default.html
 *		4	http://www.w3.org/default.html
 */
HTParentAnchor *HTHomeAnchor(void)
{
    char *my_home_document = NULL;
    char *home = LYGetEnv(LOGICAL_DEFAULT);
    char *ref;
    HTParentAnchor *anchor;

    if (home) {
	StrAllocCopy(my_home_document, home);
#define MAX_FILE_NAME 1024	/* @@@@@@ */
    } else if (HTClientHost) {	/* Telnet server */
	/*
	 * Someone telnets in, they get a special home.
	 */
	FILE *fp = fopen(REMOTE_POINTER, "r");
	char *status;

	if (fp) {
	    my_home_document = typecallocn(char, MAX_FILE_NAME);

	    if (my_home_document == NULL)
		outofmem(__FILE__, "HTHomeAnchor");
	    status = fgets(my_home_document, MAX_FILE_NAME, fp);
	    if (!status) {
		FREE(my_home_document);
	    }
	    fclose(fp);
	}
	if (my_home_document == NULL)
	    StrAllocCopy(my_home_document, REMOTE_ADDRESS);
    }
#ifdef UNIX
    if (my_home_document == NULL) {
	FILE *fp = NULL;
	char *home = LYGetEnv("HOME");

	if (home != 0) {
	    HTSprintf0(&my_home_document, "%s/%s", home, PERSONAL_DEFAULT);
	    fp = fopen(my_home_document, "r");
	}

	if (!fp) {
	    StrAllocCopy(my_home_document, LOCAL_DEFAULT_FILE);
	    fp = fopen(my_home_document, "r");
	}
	if (fp) {
	    fclose(fp);
	} else {
	    CTRACE((tfp, "HTBrowse: No local home document ~/%s or %s\n",
		    PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
	    FREE(my_home_document);
	}
    }
#endif /* UNIX */
    ref = HTParse((my_home_document ?
		   my_home_document : (HTClientHost ?
				       REMOTE_ADDRESS : LAST_RESORT)),
		  STR_FILE_URL,
		  PARSE_ALL_WITHOUT_ANCHOR);
    if (my_home_document) {
	CTRACE((tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		my_home_document, ref));
	FREE(my_home_document);
    }
    anchor = HTAnchor_findSimpleAddress(ref);
    FREE(ref);
    return anchor;
}
#endif /* NOT_USED_CODE */
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTAccess.c,v 1.68 2009/01/03 01:31:41 tom Exp $
d270 1
a270 1
    Host = (((at = strchr(host, '@@')) != NULL) ? (at + 1) : host);
d288 2
a289 3
    if (NULL != (p = strrchr(Host, ':'))) {	/* Port specified */
	*p++ = 0;		/* Chop off port */
	port = atoi(p);
d331 1
d338 1
a338 1
	    if (*end == ':')
d340 4
d348 1
d350 1
a350 1
	    t_len = colon - no_proxy;
d352 1
a352 1
	    t_len = end - no_proxy;
d365 1
a365 1
	     !strncmp(host, no_proxy, (unsigned) t_len))) {
d419 1
a419 1
    if (!strncmp(physical, "Proxied=", 8)) {
d422 1
a422 1
    } else if (!strncmp(physical, "NoProxy=", 8)) {
d456 3
a463 2
	    char *host = NULL;

d465 1
a465 1
		if (strchr(host, ':') == NULL) {
a480 2
	    char *host = NULL;

d482 1
a482 1
		if (!(strchr(host, ':'))) {
d530 1
a530 1
	    if (!strncmp(gatewayed, "http", 4)) {
d542 1
a542 1
	    if (!strncmp(addr, "file", 4)) {
d690 5
d807 1
a807 1
	       !strncmp(cp, "Location=", 9)) {
d861 1
a861 1
	 * If DONT_TRACK_INTERNAL_LINKS is defined, HText_AreDifferent() is
d876 1
a876 1
	 * If DONT_TRACK_INTERNAL_LINKS is undefined, a target address that
d898 8
a905 9
	if (LYoverride_no_cache ||
#ifdef DONT_TRACK_INTERNAL_LINKS
	    !HText_hasNoCacheSet(text) ||
	    !HText_AreDifferent(anchor, full_address)
#else
	    ((LYinternal_flag || !HText_hasNoCacheSet(text)) &&
	     !isLYNXIMGMAP(full_address))
#endif /* TRACK_INTERNAL_LINKS */
	    ) {
d1286 2
d1313 1
a1313 1
    u = strchr(address, '?');	/* Find old search string */
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		Access Manager					HTAccess.c
d67 1
d325 1
a325 1
    h_len = strlen(Host);
d359 2
a360 1
	     isdigit(UCH(*no_proxy)) && !strncmp(host, no_proxy, t_len))) {
d689 1
a689 1
	return HTLoadError(sink, 500, gettext("Access forbidden by rule"));
d691 10
a700 1
	return status;		/* fake redirection by rule, to redirecting_url */
a701 11
    if (status < 0)
	return status;		/* Can't resolve or forbidden */

    /* prevent crash if telnet or similar mapped or proxied by rule. - kw */
    LYFixCursesOnForAccess(addr, HTAnchor_physical(anchor));
    p = (HTProtocol *) HTAnchor_protocol(anchor);
    anchor->parent->underway = TRUE;	/* Hack to deal with caching */
    status = p->load(HTAnchor_physical(anchor),
		     anchor, format_out, sink);
    anchor->parent->underway = FALSE;
    LYUCPopAssumed();
d909 1
d914 1
a914 1
    if (text && HText_HaveUserChangedForms(text)) {
d1292 1
a1292 1
	} else if (HTCJK != NOCJK) {
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 31
a32 31
**		==============
**
**  Authors
**	TBL	Tim Berners-Lee timbl@@info.cern.ch
**	JFG	Jean-Francois Groff jfg@@dxcern.cern.ch
**	DD	Denis DeLaRoca (310) 825-4580  <CSP1DWD@@mvs.oac.ucla.edu>
**	FM	Foteos Macrides macrides@@sci.wfeb.edu
**	PDM	Danny Mayer mayer@@ljo.dec.com
**
**  History
**	 8 Jun 92 Telnet hopping prohibited as telnet is not secure TBL
**	26 Jun 92 When over DECnet, suppressed FTP, Gopher and News. JFG
**	 6 Oct 92 Moved HTClientHost and logfile into here. TBL
**	17 Dec 92 Tn3270 added, bug fix. DD
**	 4 Feb 93 Access registration, Search escapes bad chars TBL
**		  PARAMETERS TO HTSEARCH AND HTLOADRELATIVE CHANGED
**	28 May 93 WAIS gateway explicit if no WAIS library linked in.
**	31 May 94 Added DIRECT_WAIS support for VMS. FM
**	27 Jan 95 Fixed proxy support to use NNTPSERVER for checking
**		  whether or not to use the proxy server. PDM
**	27 Jan 95 Ensured that proxy service will be overridden for files
**		  on the local host (because HTLoadFile() doesn't try ftp
**		  for those) and will substitute ftp for remote files. FM
**	28 Jan 95 Tweaked PDM's proxy override mods to handle port info
**		  for news and wais URL's. FM
**
**  Bugs
**	This module assumes that that the graphic object is hypertext, as it
**	needs to select it when it has been loaded.  A superclass needs to be
**	defined which accepts select and select_anchor.
*/
d42 2
a43 2
**  Implements:
*/
d47 2
a48 2
**  Uses:
*/
d57 1
a57 1
#include <HText.h>	/* See bugs above */
d68 6
a73 6
**  These flags may be set to modify the operation of this module
*/
PUBLIC char * HTClientHost = NULL; /* Name of remote login host if any */
PUBLIC FILE * HTlogfile = NULL;    /* File to which to output one-liners */
PUBLIC BOOL HTSecure = NO;	   /* Disable access for telnet users? */
PUBLIC BOOL HTPermitRedir = NO;	   /* Always allow redirection in getfile()? */
d75 1
a75 1
PUBLIC BOOL using_proxy = NO; /* are we using a proxy gateway? */
d78 4
a81 4
**  To generate other things, play with these:
*/
PUBLIC HTFormat HTOutputFormat = NULL;
PUBLIC HTStream* HTOutputStream = NULL; /* For non-interactive, set this */
d83 1
a83 1
PRIVATE HTList * protocols = NULL; /* List of registered protocol descriptors */
d85 1
a85 1
PUBLIC char *use_this_url_instead = NULL;
d87 2
a88 2
PRIVATE int pushed_assume_LYhndl = -1; /* see LYUC* functions below - kw */
PRIVATE char * pushed_assume_MIMEname = NULL;
d91 1
a91 1
PRIVATE void free_protocols NOARGS
d95 1
a95 1
    FREE(pushed_assume_MIMEname); /* shouldn't happen, just in case - kw */
d100 3
a102 4
**	--------------------
*/
PUBLIC BOOL HTRegisterProtocol ARGS1(
	HTProtocol *,	protocol)
a113 1

d115 11
a125 11
**	-----------------------------
**
**	Add to or subtract from this list if you add or remove protocol
**	modules.  This routine is called the first time the protocol list
**	is needed, unless any protocols are already registered, in which
**	case it is not called.	Therefore the application can override
**	this list.
**
**	Compiling with NO_INIT prevents all known protocols from being
**	forced in at link time.
*/
d134 1
d161 1
d177 1
a177 1
GLOBALREF  HTProtocol HTWAIS;
d182 1
a182 1
PRIVATE void HTAccessInit NOARGS			/* Call me once */
d219 16
a234 17
**	-------------------------
**
**	Check the no_proxy environment variable to get the list
**	of hosts for which proxy server is not consulted.
**
**	no_proxy is a comma- or space-separated list of machine
**	or domain names, with optional :port part.  If no :port
**	part is present, it applies to all ports on that domain.
**
**  Example:
**	    no_proxy="cern.ch,some.domain:8001"
**
**  Use "*" to override all proxy service:
**	     no_proxy="*"
*/
PUBLIC BOOL override_proxy ARGS1(
	CONST char *,	addr)
d236 6
a241 6
    CONST char * no_proxy = getenv("no_proxy");
    char * p = NULL;
    char * at = NULL;
    char * host = NULL;
    char * Host = NULL;
    char * acc_method = NULL;
d254 3
a256 4
     *	Never proxy file:// URLs if they are on the local host.
     *	HTLoadFile() will not attempt ftp for those if direct
     *	access fails.  We'll check that first, in case no_proxy
     *	hasn't been defined. - FM
d266 1
a266 1
    Host = (((at = strchr(host, '@@')) != NULL) ? (at+1) : host);
d285 1
a285 1
	*p++ = 0;				/* Chop off port */
d287 1
a287 1
    } else {					/* Use default port */
d290 1
d314 2
d320 1
a320 1
	port = 80;		    /* Default */
d324 2
a325 2
	CONST char * end;
	CONST char * colon = NULL;
d330 1
a330 1
	    no_proxy++;		    /* Skip whitespace and separators */
d334 2
a335 1
	    if (*end == ':') colon = end;		/* Port number given */
d340 1
a340 1
	    templ_port = atoi(colon+1);
d342 1
a342 2
	}
	else {
d346 2
a347 2
	if ((!templ_port || templ_port == port)  &&
	    (t_len > 0	&&  t_len <= h_len  &&
d352 3
a354 3
#ifdef CJK_EX	/* ASATAKU PROXY HACK */
	if ((!templ_port || templ_port == port)	 &&
	    (t_len > 0	&&  t_len <= h_len  &&
d359 1
a359 1
#endif	/* ASATAKU PROXY HACK */
d372 12
a383 13
**	--------------------------------------
**
**  On entry,
**	addr		must point to the fully qualified hypertext reference.
**	anchor		a parent anchor with whose address is addr
**
**  On exit,
**	returns		HT_NO_ACCESS		Error has occurred.
**			HT_OK			Success
*/
PRIVATE int get_physical ARGS2(
	CONST char *,		addr,
	HTParentAnchor *,	anchor)
d386 3
a388 3
    char * acc_method = NULL;	/* Name of access method */
    char * physical = NULL;
    char * Server_addr = NULL;
d394 2
a395 2
    **	Make sure the using_proxy variable is FALSE.
    */
d418 1
a418 1
    FREE(physical);			/* free our copy */
d425 1
a425 1
	FREE(physical);			/* free our copy */
d434 8
a441 8
    **	Check whether gateway access has been set up for this.
    **
    **	This function can be replaced by the rule system above.
    **
    **  If the rule system has already determined that we should
    **  use a proxy, or that we shouldn't, ignore proxy-related
    **  settings, don't use no_proxy either.
    */
d445 1
a445 1
    if (!override_flag && !using_proxy) {   /* else ignore no_proxy env var */
d448 3
a450 3
	    **  News is different, so we need to check the name of the server,
	    **  as well as the default port for selective exclusions.
	    */
d452 1
d467 3
a469 3
	    **  Wais also needs checking of the default port
	    **  for selective exclusions.
	    */
d471 1
d479 1
a479 2
	    }
	    else
d488 1
a488 1
	char * gateway_parameter = NULL, *gateway, *proxy;
d491 2
a492 2
	**  Search for gateways.
	*/
d494 1
a494 1
	gateway = LYGetEnv(gateway_parameter); /* coerce for decstation */
d497 2
a498 2
	**  Search for proxy servers.
	*/
d501 2
a502 2
	    ** If we got to here, a file URL is for ftp on a remote host. - FM
	    */
d515 2
a516 2
	**  Proxy servers have precedence over gateway servers.
	*/
d518 3
a520 2
	    char * gatewayed = NULL;
	    StrAllocCopy(gatewayed,proxy);
d523 1
d531 2
a532 2
	    ** Ensure that the proxy server uses ftp for file URLs. - FM
	    */
d549 6
a554 4
	    char * path = HTParse(addr, "",
		PARSE_HOST + PARSE_PATH + PARSE_PUNCTUATION);
		/* Chop leading / off to make host into part of path */
	    char * gatewayed = HTParse(path+1, gateway, PARSE_ALL);
d568 2
a569 2
    **	Search registered protocols to find suitable one.
    */
d573 1
d575 2
a576 1
	if (!protocols) HTAccessInit();
d580 2
a581 1
	    HTProtocol *p = (HTProtocol *)HTList_objectAt(protocols, i);
d596 5
a600 7
 *  Temporarily set the int UCLYhndl_for_unspec and string
 *  UCLYhndl_for_unspec used for charset "assuming" to the values
 *  implied by a HTParentAnchor's UCStages, after saving the current
 *  values for later restoration. - kw
 *  @@@@@@ These functions may not really belong here, but where else?
 *  I want the "pop" to occur as soon as possible after loading
 *  has finished. - kw @@@@@@
d602 1
a602 2
PUBLIC void LYUCPushAssumed ARGS1(
    HTParentAnchor *,	anchor)
d605 2
a606 1
    LYUCcharset * anchor_UCI = NULL;
d618 1
a618 1
	    StrAllocCopy(UCAssume_MIMEcharset, anchor_UCI->MIMEname);
d622 2
a623 1
	    CTRACE((tfp, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d633 1
d635 2
a636 3
 *  Restore the int UCLYhndl_for_unspec and string
 *  UCLYhndl_for_unspec used for charset "assuming" from the values
 *  saved by LYUCPushAssumed, if any. - kw
d638 1
a638 1
PUBLIC int LYUCPopAssumed NOARGS
a639 1

d643 2
a644 1
	CTRACE((tfp, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d658 19
a676 20
**	---------------
**
**	This is an internal routine, which has an address AND a matching
**	anchor.  (The public routines are called with one OR the other.)
**
**  On entry,
**	addr		must point to the fully qualified hypertext reference.
**	anchor		a parent anchor with whose address is addr
**
**  On exit,
**	returns		<0		Error has occurred.
**			HT_LOADED	Success
**			HT_NO_DATA	Success, but no document loaded.
**					(telnet session started etc)
*/
PRIVATE int HTLoad ARGS4(
	CONST char *,		addr,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
d680 1
d682 1
a682 1
	 /* prevent crash if telnet or similar was forbidden by rule. - kw */
d686 1
a686 1
	return status;	/* fake redirection by rule, to redirecting_url */
d689 1
a689 1
	return status;	/* Can't resolve or forbidden */
d693 4
a696 4
    p = (HTProtocol *)HTAnchor_protocol(anchor);
    anchor->parent->underway = TRUE;		/* Hack to deal with caching */
    status= p->load(HTAnchor_physical(anchor),
			anchor, format_out, sink);
d703 3
a705 4
**	--------------------------------
*/
PUBLIC HTStream *HTSaveStream ARGS1(
	HTParentAnchor *,	anchor)
d707 2
a708 1
    HTProtocol *p = (HTProtocol *)HTAnchor_protocol(anchor);
d715 1
a715 1
PUBLIC int redirection_attempts = 0; /* counter in HTLoadDocument */
d718 20
a737 22
**	----------------------------------
**
**	- Checks or documents already loaded
**	- Logs the access
**	- Allows stdin filter option
**	- Trace output and error messages
**
**  On Entry,
**	  anchor	    is the node_anchor for the document
**	  full_address	    The address of the document to be accessed.
**	  filter	    if YES, treat stdin as HTML
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/

PRIVATE BOOL HTLoadDocument ARGS4(
	CONST char *,		full_address, /* may include #fragment */
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d739 3
a741 3
    int     status;
    HText * text;
    CONST char * address_to_load = full_address;
d748 3
a750 3
    **	Free use_this_url_instead and reset permanent_redirection
    **	if not done elsewhere. - FM
    */
d755 6
a760 8
    **	Make sure some yoyo doesn't send us 'round in circles
    **	with redirecting URLs that point back to themselves.
    **	We'll set the original Lynx limit of 10 redirections
    **	per requested URL from a user, because the HTTP/1.1
    **	will no longer specify a restriction to 5, but will
    **	leave it up to the browser's discretion, in deference
    **	to Microsoft.  - FM
    */
d768 8
a775 9
     *	If this is marked as an internal link but we don't have the
     *	document loaded any more, and we haven't explicitly flagged
     *	that we want to reload with LYforce_no_cache, then something
     *	has disappeared from the cache when we expected it to be still
     *	there.	The user probably doesn't expect a new network access.
     *	So if we have POST data and safe is not set in the anchor,
     *	ask for confirmation, and fail if not granted.	The exception
     *	are LYNXIMGMAP documents, for which we defer to LYLoadIMGmap
     *	for prompting if necessary. - kw
d777 1
a777 1
    text = (HText *)HTAnchor_document(anchor);
d787 6
a792 6
    **	If we don't have POST content, check whether this is a previous
    **	redirecting URL, and keep re-checking until we get to the final
    **	destination or redirection limit.  If we do have POST content,
    **	we didn't allow permanent redirection, and an interactive user
    **	will be deciding whether to keep redirecting. - FM
    */
d799 2
a800 2
			  anchor->address));
	    CTRACE((tfp, "HTAccess: Redirecting to '%s'\n", cp+9));
d803 2
a804 2
	    **	Don't exceed the redirection_attempts limit. - FM
	    */
d813 3
a815 3
	    ** Set up the redirection. - FM
	    **/
	    StrAllocCopy(use_this_url_instead, cp+9);
d826 3
a828 3
    **	If we had previous redirection, go back and check out
    **	that the URL under the current restrictions. - FM
    */
d831 1
a831 1
	return(NO);
d835 3
a837 3
    **	See if we can use an already loaded document.
    */
    text = (HText *)HTAnchor_document(anchor);
d840 46
a885 50
	**  We have a cached rendition of the target document.
	**  Check if it's OK to re-use it.  We consider it OK if:
	**   (1) the anchor does not have the no_cache element set, or
	**   (2) we've overridden it, e.g., because we are acting on
	**	 a PREV_DOC command or a link in the History Page and
	**	 it's not a reply from a POST with the LYresubmit_posts
	**	 flag set, or
	**   (3) we are repositioning within the currently loaded document
	**	 based on the target anchor's address (URL_Reference).
	*
	*    If DONT_TRACK_INTERNAL_LINKS is defined, HText_AreDifferent()
	*    is used to determine whether (3) applies.	If the target address
	*    differs from that of the current document only by a fragment
	*    and the target address has an appended fragment, repositioning
	*    without reloading is always assumed.
	*    Note that HText_AreDifferent() currently always returns TRUE
	*    if the target has a LYNXIMGMAP URL, so that an internally
	*    generated pseudo-document will normally not be re-used unless
	*    condition (2) applies. (Condition (1) cannot apply since in
	*    LYMap.c, no_cache is always set in the anchor object).  This
	*    doesn't guarantee that the resource from which the MAP element
	*    is taken will be read again (reloaded) when the list of links
	*    for a client-side image map is regenerated, when in some cases
	*    it should (e.g., user requested RELOAD, or HTTP response with
	*    no-cache header and we are not overriding).
	*
	*    If DONT_TRACK_INTERNAL_LINKS is undefined, a target address that
	*    points to the same URL as the current document may still result in
	*    reloading, depending on whether the original URL-Reference
	*    was given as an internal link in the context of the previously
	*    loaded document.  HText_AreDifferent() is not used here for
	*    testing whether we are just repositioning.  For an internal
	*    link, the potential callers of this function from mainloop()
	*    down will either avoid making the call (and do the repositioning
	*    differently) or set LYinternal_flag (or LYoverride_no_cache).
	*    Note that (a) LYNXIMGMAP pseudo-documents and (b) The "List Page"
	*    document are treated logically as being part of the document on
	*    which they are based, for the purpose of whether to treat a link
	*    as internal, but the logic for this (by setting LYinternal_flag
	*    as necessary) is implemented elsewhere.  There is a specific
	*    test for LYNXIMGMAP here so that the generated pseudo-document
	*    will not be re-used unless LYoverride_no_cache is set.  The same
	*    caveat as above applies w.r.t. reloading of the underlying
	*    resource.
	*
	**  We also should be checking other aspects of cache
	**  regulation (e.g., based on an If-Modified-Since check,
	**  etc.) but the code for doing those other things isn't
	**  available yet.
	*/
d894 1
a894 1
	) {
d919 5
a923 6
    **	Get the document from the net.	If we are auto-reloading,
    **	the mutable anchor elements from the previous rendition
    **	should be freed in conjunction with loading of the new
    **	rendition. - FM
    */
    LYforce_no_cache = NO;  /* reset after each time through */
d925 1
a925 1
	FREE(anchor->title);  /* ??? */
d931 2
a932 3
     *  RECOVERY:
     *  if the loading failed, and we had a cached HText copy,
     *  and no new HText created - use a previous copy, issue a warning.
d934 1
a934 1
    if (text && status < 0 && (HText *)HTAnchor_document(anchor) == text) {
d948 2
a949 2
    **	Log the access if necessary.
    */
d952 1
d961 4
a964 4
		    ctime(&theTime),
		    HTClientHost ? HTClientHost : "local",
		    status < 0 ? "FAIL" : "GET",
		    full_address));
d968 2
a969 2
    **	Check out what we received from the net.
    */
d971 2
a972 1
	/*  Exported from HTMIME.c, of all places. *//** NO!! - FM **/
d974 22
a995 23
	**  Doing this via HTMIME.c meant that the redirection cover
	**  page was already loaded before we learned that we want a
	**  different URL.  Also, changing anchor->address, as Lynx
	**  was doing, meant we could never again access its hash
	**  table entry, creating an insolvable memory leak.  Instead,
	**  if we had a 301 status and set permanent_redirection,
	**  we'll load the new URL in anchor->physical, preceded by a
	**  token, which we can check to make replacements on subsequent
	**  access attempts.  We'll check recursively, and retrieve the
	**  final URL if we had multiple redirections to it.  If we just
	**  went to HTLoad now, as Lou originally had this, we couldn't do
	**  Lynx's security checks and alternate handling of some URL types.
	**  So, instead, we'll go all the way back to the top of getfile
	**  in LYGetFile.c when the status is HT_REDIRECTING.  This may
	**  seem bizarre, but it works like a charm! - FM
	**
	**  Actually, the location header for redirections is now again
	**  picked up in HTMIME.c.  But that's an internal matter between
	**  HTTP.c and HTMIME.c, is still under control of HTLoadHTTP for
	**  http URLs, is done in a way that doesn't load the redirection
	**  response's body (except when wanted as an error fallback), and
	**  thus need not concern us here. - kw 1999-12-02
	*/
d997 1
a997 1
		    address_to_load));
d999 1
a999 1
		     redirecting_url));
d1001 3
a1003 3
	**  Prevent circular references.
	*/
	if (strcmp(address_to_load, redirecting_url)) { /* if different */
d1005 4
a1008 4
	    **	Load token and redirecting url into anchor->physical
	    **	if we had 301 Permanent redirection.  HTTP.c does not
	    **	allow this if we have POST content. - FM
	    */
d1015 2
a1016 2
	    **	Set up flags before return to getfile. - FM
	    */
d1023 1
a1023 1
	    return(NO);
d1028 1
a1028 1
	return(YES);
d1032 2
a1033 2
    **	We did not receive a redirecting URL. - FM
    */
d1040 1
a1040 1
		    full_address));
d1046 1
a1046 1
		    full_address));
d1052 1
a1052 1
		    full_address));
d1058 1
a1058 1
		    full_address));
d1063 3
a1065 2
	CTRACE((tfp, "HTAccess: `%s' has been accessed, transfer interrupted.\n",
		    full_address));
d1071 3
a1073 3
	**	If you get this, then please find which routine is returning
	**	a positive unrecognized error code!
	*/
d1075 1
a1075 1
 gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n"));
d1077 3
a1079 3
 gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@@sig.net!\n"));
	fprintf(stderr, gettext("**** HTAccess: Status returned was: %d\n"),status);
	exit(EXIT_FAILURE);
d1094 1
a1094 1
} /* HTLoadDocument */
d1097 11
a1107 12
**	-----------------------------------
**
**  On Entry,
**	  addr	   The absolute address of the document to be accessed.
**	  filter   if YES, treat document as HTML
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/
PUBLIC BOOL HTLoadAbsolute ARGS1(
	CONST DocAddress *,	docaddr)
d1117 13
a1129 14
**	---------------------------------------------
**
**  On Entry,
**	  addr	   The absolute address of the document to be accessed.
**	  sink	   if non-NULL, send data down this stream
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/
PUBLIC BOOL HTLoadToStream ARGS3(
	CONST char *,	addr,
	BOOL,		filter,
	HTStream *,	sink)
d1139 12
a1150 13
**	-----------------------------------
**
**  On Entry,
**	  relative_name     The relative address of the document
**			    to be accessed.
**
**  On Exit,
**	  returns    YES     Success in opening document
**		     NO      Failure
*/
PUBLIC BOOL HTLoadRelative ARGS2(
	CONST char *,		relative_name,
	HTParentAnchor *,	here)
d1154 2
a1155 2
    char * mycopy = NULL;
    char * stripped = NULL;
d1168 3
a1170 3
		HTParse(stripped,
			here->address,
			PARSE_ALL_WITHOUT_ANCHOR);
d1173 4
a1176 4
    **	If we got redirection, result will be NO, but use_this_url_instead
    **	will be set.  The calling routine should check both and do whatever
    **	is appropriate. - FM
    */
d1178 1
a1178 1
    FREE(mycopy);  /* Memory leak fixed 10/7/92 -- JFG */
d1183 10
a1192 11
**	----------------------------------------
**
**  On Entry,
**	  destination		    The child or parent anchor to be loaded.
**
**  On Exit,
**	  returns    YES     Success
**		     NO      Failure
*/
PUBLIC BOOL HTLoadAnchor ARGS1(
	HTAnchor *,	destination)
d1194 1
a1194 1
    HTParentAnchor * parent;
d1196 1
d1198 1
a1198 1
	return NO;	/* No link */
d1203 1
a1203 1
						/* TBL 921202 */
d1211 2
a1212 1
	if (!result) return NO;
d1214 2
a1215 4
    }

    {
	HText *text = (HText*)HTAnchor_document(parent);
d1217 5
a1221 5
	if ((destination != (HTAnchor *)parent) &&
	    (destination != (HTAnchor *)(parent->parent))) {
						  /* If child anchor */
	    HText_selectAnchor(text,		  /* Double display? @@@@ */
			       (HTChildAnchor*)destination);
d1229 1
a1229 1
} /* HTLoadAnchor */
d1232 11
a1242 12
**	-------
**
**	Performs a keyword search on word given by the user.  Adds the
**	keyword to the end of the current address and attempts to open
**	the new address.
**
**  On Entry,
**	 *keywords	space-separated keyword list or similar search list
**	here		is anchor search is to be done on.
*/
PRIVATE char hex ARGS1(
    int,		i)
d1244 2
a1245 1
    char * hexchars = "0123456789ABCDEF";
d1249 2
a1250 3
PUBLIC BOOL HTSearch ARGS2(
	CONST char *,		keywords,
	HTParentAnchor *,	here)
d1256 2
a1257 2
    CONST char * p, *s, *e;		/* Pointers into keywords */
    char * address = NULL;
d1259 3
a1261 3
    char * escaped = typecallocn(char, (strlen(keywords)*3) + 1);
    static CONST BOOL isAcceptable[96] =

d1269 1
d1277 6
a1282 6
    **	Convert spaces to + and hex escape unacceptable characters.
    */
    for (s = keywords; *s && WHITE(*s); s++)		 /* Scan */
	;	/* Skip white space */
    for (e = s + strlen(s); e > s && WHITE(*(e-1)); e--) /* Scan */
	;	/* Skip trailers */
d1285 1
d1290 2
a1291 2
	} else if (c>=32 && c<=UCH(127) && isAcceptable[c-32]) {
	    *q++ = *p;				/* 930706 TBL for MVS bug */
d1294 2
a1295 2
	    *q++ = hex((int)(c >> 4));
	    *q++ = hex((int)(c & 15));
d1310 7
a1316 7
    **	If we got redirection, result will be NO, but use_this_url_instead
    **	will be set.  The calling routine should check both and do whatever
    **	is appropriate.  Only an http server (not a gopher or wais server)
    **	could return redirection.  Lynx will go all the way back to its
    **	mainloop() and subject a redirecting URL to all of its security and
    **	restrictions checks. - FM
    */
d1321 12
a1332 13
**	-----------------------
**
**	Performs a keyword search on word given by the user.  Adds the
**	keyword to the end of the current address and attempts to open
**	the new address.
**
**  On Entry,
**	*keywords	space-separated keyword list or similar search list
**	*indexname	is name of object search is to be done on.
*/
PUBLIC BOOL HTSearchAbsolute ARGS2(
	CONST char *,	keywords,
	char *,		indexname)
d1335 2
a1336 1
    HTParentAnchor * anchor;
d1350 14
a1363 14
**	--------------------------------------
**
**	As it involves file access, this should only be done once
**	when the program first runs.
**	This is a default algorithm -- browser don't HAVE to use this.
**	But consistency between browsers is STRONGLY recommended!
**
**  Priority order is:
**		1	WWW_HOME environment variable (logical name, etc)
**		2	~/WWW/default.html
**		3	/usr/local/bin/default.html
**		4	http://www.w3.org/default.html
*/
PUBLIC HTParentAnchor * HTHomeAnchor NOARGS
d1365 4
a1368 4
    char * my_home_document = NULL;
    char * home = LYGetEnv(LOGICAL_DEFAULT);
    char * ref;
    HTParentAnchor * anchor;
d1372 2
a1373 2
#define MAX_FILE_NAME 1024			/* @@@@@@ */
    } else if (HTClientHost) {			/* Telnet server */
d1375 5
a1379 4
	**  Someone telnets in, they get a special home.
	*/
	FILE * fp = fopen(REMOTE_POINTER, "r");
	char * status;
d1382 1
a1393 1

d1396 3
a1398 2
	FILE * fp = NULL;
	char * home = LYGetEnv("HOME");
d1412 1
a1412 1
			PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE));
d1419 1
a1419 1
				     REMOTE_ADDRESS : LAST_RESORT)),
d1424 1
a1424 1
		    my_home_document, ref));
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d25 1
a25 1
**	28 Jan 95 Tweeked PDM's proxy override mods to handle port info
a269 6
#ifdef VMS
#define CompareHostname(a,b) strcasecomp(a, b)
#else
#define CompareHostname(a,b) strcmp(a, b)
#endif /* VMS */

d272 2
a273 2
	    (!strcmp(Host, "localhost") ||
	     !CompareHostname(Host, HTHostName()))) {
d385 1
d391 2
d399 1
a399 2
    physical = HTTranslate(addr);
    if (!physical) {
d431 1
a431 2
    acc_method =  HTParse(HTAnchor_physical(anchor),
		"file:", PARSE_ACCESS);
d459 1
a459 1
	    } else if (getenv("NNTPSERVER") != NULL) {
d461 1
a461 1
		StrAllocCat(Server_addr, (char *)getenv("NNTPSERVER"));
d466 3
a468 3
	**  Wais also needs checking of the default port
	**  for selective exclusions.
	*/
d493 1
a493 1
	gateway = getenv(gateway_parameter); /* coerce for decstation */
d505 1
a505 1
	proxy = getenv(gateway_parameter);
d542 2
a543 2
	    acc_method =  HTParse(HTAnchor_physical(anchor),
		"http:", PARSE_ACCESS);
d555 2
a556 2
	    acc_method =  HTParse(HTAnchor_physical(anchor),
		"http:", PARSE_ACCESS);
d565 1
d577 2
a578 1
		return (HT_OK);
d584 1
a584 1
    return HT_NO_ACCESS;
a595 3

extern char*UCAssume_MIMEcharset;

d687 2
a688 2
    anchor->underway = TRUE;		/* Hack to deal with caching */
    status= (*(p->load))(HTAnchor_physical(anchor),
d690 1
a690 1
    anchor->underway = FALSE;
d705 1
a705 1
    return (*p->saveStream)(anchor);
d729 1
a729 1
	CONST char *,		full_address,
d734 2
a735 2
    int		status;
    HText *	text;
d775 2
a776 1
    if (LYinternal_flag && !LYforce_no_cache &&
d778 1
a778 2
	(text = (HText *)HTAnchor_document(anchor)) == NULL &&
	strncmp(full_address, "LYNXIMGMAP:", 11) &&
d820 1
a820 1
	    anchor = HTAnchor_parent(HTAnchor_findAddress(&NewDoc));
d835 2
a836 1
    if (!LYforce_no_cache && (text = (HText *)HTAnchor_document(anchor))) {
d888 1
d890 2
a891 2
	if (LYoverride_no_cache || !HText_hasNoCacheSet(text) ||
	    !HText_AreDifferent(anchor, full_address))
a892 1
	if (LYoverride_no_cache ||
d894 1
a894 1
	     strncmp(full_address, "LYNXIMGMAP:", 11)))
d896 1
a896 1
	{
d912 8
d928 1
a928 1
	FREE(anchor->title);
d934 18
d1113 1
a1113 1
			  HTAnchor_parent(HTAnchor_findAddress(docaddr)),
d1136 1
a1136 1
			  HTAnchor_parent(HTAnchor_findAddress(addr)),
a1160 1
    char * current_address = HTAnchor_address((HTAnchor*)here);
d1174 2
a1175 2
			current_address,
			PARSE_ACCESS|PARSE_HOST|PARSE_PATH|PARSE_PUNCTUATION);
a1182 1
    FREE(current_address);
a1209 1
	char * address = HTAnchor_address((HTAnchor*) parent);
d1211 1
a1211 1
	result = HTLoadDocument(address,
a1215 1
	FREE(address);
d1223 3
a1225 1
	if (destination != (HTAnchor *)parent) {  /* If child anchor */
d1349 1
a1349 1
    anchor = (HTParentAnchor*)HTAnchor_findAddress(&abs_doc);
d1371 1
a1371 1
    char * home = (char *)getenv(LOGICAL_DEFAULT);
d1401 2
a1402 2
	CONST char * home =  (CONST char*)getenv("HOME");
	if (home != null) {
d1423 2
a1424 2
		  "file:",
		  PARSE_ACCESS|PARSE_HOST|PARSE_PATH|PARSE_PUNCTUATION);
d1430 1
a1430 1
    anchor = (HTParentAnchor*)HTAnchor_findAddress(ref);
@


1.3
log
@spelling
@
text
@a66 2
extern HTCJKlang HTCJK;

d73 1
d270 6
d279 1
a279 6
#ifdef VMS
	     !strcasecomp(Host, HTHostName())
#else
	     !strcmp(Host, HTHostName())
#endif /* VMS */
	)) {
d318 3
d357 9
d394 6
d404 3
d411 10
a420 1
	CTRACE(tfp, "HTAccess: Appending '?0,0' coordinate pair.\n");
a421 1
    HTAnchor_setPhysical(anchor, physical);
d427 1
a427 1
	CTRACE(tfp, "HTAccess: Appending '?0,0' coordinate pair.\n");
d442 4
a448 4
    /*
    **	Make sure the using_proxy variable is FALSE.
    */
    using_proxy = NO;
d450 15
a464 8
    if (!strcasecomp(acc_method, "news")) {
	/*
	**  News is different, so we need to check the name of the server,
	**  as well as the default port for selective exclusions.
	*/
	char *host = NULL;
	if ((host = HTParse(addr, "", PARSE_HOST))) {
	    if (strchr(host, ':') == NULL) {
d466 1
a466 1
		StrAllocCat(Server_addr, host);
d469 2
a470 8
	    FREE(host);
	} else if (getenv("NNTPSERVER") != NULL) {
	    StrAllocCopy(Server_addr, "news://");
	    StrAllocCat(Server_addr, (char *)getenv("NNTPSERVER"));
	    StrAllocCat(Server_addr, ":119/");
	 }
    } else if (!strcasecomp(acc_method, "wais")) {
	/*
d474 8
a481 6
	char *host = NULL;
	if ((host = HTParse(addr, "", PARSE_HOST))) {
	    if (!(strchr(host, ':'))) {
		StrAllocCopy(Server_addr, "wais://");
		StrAllocCat(Server_addr, host);
		StrAllocCat(Server_addr, ":210/");
d483 4
a486 1
	    FREE(host);
d488 1
a488 4
	else
	    StrAllocCopy(Server_addr, addr);
    } else {
	StrAllocCopy(Server_addr, addr);
d491 2
a492 2
    if (!override_proxy(Server_addr)) {
	char * gateway_parameter, *gateway, *proxy;
d497 2
a498 7
	gateway_parameter = (char *)calloc(1, (strlen(acc_method) + 20));
	if (gateway_parameter == NULL)
	    outofmem(__FILE__, "HTLoad");
	strcpy(gateway_parameter, "WWW_");
	strcat(gateway_parameter, acc_method);
	strcat(gateway_parameter, "_GATEWAY");
	gateway = (char *)getenv(gateway_parameter); /* coerce for decstation */
d507 1
a507 1
	    strcpy(gateway_parameter, "ftp");
d509 2
a510 3
	    strcpy(gateway_parameter, acc_method);
	strcat(gateway_parameter, "_proxy");
	proxy = (char *)getenv(gateway_parameter);
d514 1
a514 1
	    CTRACE(tfp, "Gateway found: %s\n", gateway);
d516 1
a516 1
	    CTRACE(tfp, "proxy server found: %s\n", proxy);
d524 8
d615 3
d622 1
a622 1
	    CTRACE(tfp, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d624 1
a624 1
			anchor_LYhndl);
d643 1
a643 1
	CTRACE(tfp, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",
d645 1
a645 1
		    pushed_assume_LYhndl);
d681 2
d684 2
d690 2
d714 2
a744 1
    static int redirection_attempts = 0;
d746 1
a746 1
    CTRACE (tfp, "HTAccess: loading document %s\n", address_to_load);
d802 3
a804 3
	    CTRACE (tfp, "HTAccess: '%s' is a redirection URL.\n",
			  anchor->address);
	    CTRACE (tfp, "HTAccess: Redirecting to '%s'\n", cp+9);
d826 1
a826 1
	    anchor = (HTParentAnchor *)HTAnchor_findAddress(&NewDoc);
d902 1
a902 1
	    CTRACE(tfp, "HTAccess: Document already in memory.\n");
d913 1
a913 1
	    CTRACE(tfp, "HTAccess: Auto-reloading document.\n");
d928 1
a928 1
    CTRACE(tfp, "HTAccess:  status=%d\n", status);
d942 1
a942 1
	CTRACE(tfp, "Log: %24.24s %s %s %s\n",
d946 1
a946 1
		    full_address);
d970 7
d978 4
a981 4
	CTRACE(tfp, "HTAccess: '%s' is a redirection URL.\n",
		    address_to_load);
	CTRACE(tfp, "HTAccess: Redirecting to '%s'\n",
		     redirecting_url);
d1021 2
a1022 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed.\n",
		    full_address);
d1027 2
a1028 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, partial content.\n",
		    full_address);
d1033 2
a1034 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, No data left.\n",
		    full_address);
d1039 2
a1040 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, No data loaded.\n",
		    full_address);
d1045 2
a1046 2
	CTRACE(tfp, "HTAccess: `%s' has been accessed, transfer interrupted.\n",
		    full_address);
d1058 1
a1058 1
 gettext("**** HTAccess: Internal software error.  Please mail lynx_dev@@sig.net!\n"));
d1060 1
a1060 1
	exit(-1);
d1072 1
a1072 1
    CTRACE(tfp, "HTAccess: Can't access `%s'\n", full_address);
d1247 1
a1247 1
    char * escaped = (char *)calloc(1, ((strlen(keywords)*3) + 1));
d1271 1
a1271 1
	unsigned char c = (unsigned char)TOASCII(*p);
d1276 1
a1276 1
	} else if (c>=32 && c<=(unsigned char)127 && isAcceptable[c-32]) {
d1366 1
a1366 1
	    my_home_document = (char*)calloc(1, MAX_FILE_NAME);
d1379 1
a1379 1
#ifdef unix
d1395 2
a1396 2
	    CTRACE(tfp, "HTBrowse: No local home document ~/%s or %s\n",
			PERSONAL_DEFAULT, LOCAL_DEFAULT_FILE);
d1400 1
a1400 1
#endif /* unix */
d1407 2
a1408 2
	CTRACE(tfp, "HTAccess: Using custom home page %s i.e., address %s\n",
		    my_home_document, ref);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d677 1
a677 1
**	- Trace ouput and error messages
@


1.1
log
@Initial revision
@
text
@d38 3
a40 3
#include "HTUtils.h"
#include "HTTP.h"
#include "HTAlert.h"
d44 1
a44 1
#include "HTAccess.h"
d49 2
a50 2
#include "HTParse.h"
#include "HTML.h"		/* SCW */
d53 1
a53 1
#include "HTRules.h"
d56 10
a65 11
#include "HTList.h"
#include "HText.h"	/* See bugs above */
#include "HTAlert.h"
#include "HTCJK.h"
#include "UCMap.h"
#include "GridText.h"

#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d91 1
d98 1
d108 1
d110 1
d121 1
a121 1
**	modules. This routine is called the first time the protocol list
d138 1
d140 2
d149 2
d153 2
d156 1
d164 5
a168 1
GLOBALREF HTProtocol HTFTP, HTNews, HTNNTP, HTNewsPost, HTNewsReply;
d170 7
a176 1
GLOBALREF HTProtocol HTGopher, HTCSO, HTFinger;
d192 1
d194 2
d203 2
d207 2
d210 1
d301 1
d303 1
d305 1
d313 1
d315 1
d317 1
d332 1
a332 1
	    no_proxy++; 	    /* Skip whitespace and separators */
d350 1
a350 1
             !strncasecomp(Host + h_len - t_len, no_proxy, t_len))) {
d369 1
a369 1
**	anchor		a pareent anchor with whose address is addr
d372 1
a372 1
**	returns 	HT_NO_ACCESS		Error has occured.
d390 1
a390 2
	if (TRACE)
	    fprintf(stderr, "HTAccess: Appending '?0,0' coordinate pair.\n");
d398 1
a398 2
	if (TRACE)
	    fprintf(stderr, "HTAccess: Appending '?0,0' coordinate pair.\n");
d400 1
a400 1
	FREE(physical); 		/* free our copy */
d487 4
a490 4
	if (TRACE && gateway)
	    fprintf(stderr, "Gateway found: %s\n", gateway);
	if (TRACE && proxy)
	    fprintf(stderr, "proxy server found: %s\n", proxy);
d583 5
d600 1
a600 1
PRIVATE int LYUCPopAssumed NOARGS
d602 1
d604 5
d619 1
a619 1
/*	Load a document 				HTLoad()
d627 1
a627 1
**	anchor		a pareent anchor with whose address is addr
d630 1
a630 1
**	returns 	<0		Error has occured.
d633 1
a633 1
**					(telnet sesssion started etc)
d644 1
a644 1
	return HTLoadError(sink, 500, "Access forbidden by rule");
a670 2
extern char LYinternal_flag;		       /* from LYMainLoop.c */

a688 10
extern char LYforce_no_cache;				 /* from GridText.c */
extern char LYoverride_no_cache;		       /* from LYMainLoop.c */
extern char * HTLoadedDocumentURL NOPARAMS;		   /* in GridText.c */
extern BOOL HText_hasNoCacheSet PARAMS((HText *text));	   /* in GridText.c */
extern BOOL reloading;
extern BOOL permanent_redirection;
#ifdef DIRED_SUPPORT
extern BOOLEAN lynx_edit_mode;
#endif

d695 1
a695 1
    int 	status;
d702 1
a702 2
    if (TRACE)
	fprintf (stderr, "HTAccess: loading document %s\n", address_to_load);
d722 1
a722 1
	HTAlert("Redirection limit of 10 URL's reached.");
d741 1
a741 1
	HTConfirm("Document with POST content not found in cache.  Resubmit?")
d758 3
a760 5
	    if (TRACE) {
		fprintf (stderr, "HTAccess: '%s' is a redirection URL.\n",
				  anchor->address);
		fprintf (stderr, "HTAccess: Redirecting to '%s'\n", cp+9);
	    }
d766 1
a766 1
		HTAlert("Redirection limit of 10 URL's reached.");
d812 1
a812 1
	*    and the taget address has an appended fragment, repositioning
d817 1
a817 1
	*    condition (2) appplies. (Condition (1) cannot apply since in
d822 1
a822 1
	*    it should (e.g. user requested RELOAD, or HTTP response with
d858 1
a858 2
	    if (TRACE)
		fprintf(stderr, "HTAccess: Document already in memory.\n");
a867 6
#if NOT_USED_CODE
	    /* disabled 1997-10-28 - kw
	       callers already do this when requested
	    */
	    reloading = TRUE;
#endif
d869 1
a869 3
	    if (TRACE) {
		fprintf(stderr, "HTAccess: Auto-reloading document.\n");
	    }
d884 1
a884 3
    if (TRACE) {
	fprintf(stderr, "HTAccess:  status=%d\n", status);
    }
d898 1
a898 2
	if (TRACE)
	    fprintf(stderr, "Log: %24.24s %s %s %s\n",
d927 4
a930 6
	if (TRACE) {
	    fprintf(stderr, "HTAccess: '%s' is a redirection URL.\n",
			    address_to_load);
	    fprintf(stderr, "HTAccess: Redirecting to '%s'\n",
			     redirecting_url);
	}
d970 2
a971 4
	if (TRACE) {
	    fprintf(stderr, "HTAccess: `%s' has been accessed.\n",
	    full_address);
	}
d975 3
a977 5
	HTAlert("Loading incomplete.");
	if (TRACE) {
	    fprintf(stderr, "HTAccess: `%s' has been accessed, partial content.\n",
	    full_address);
	}
d982 2
a983 5
	if (TRACE) {
	    fprintf(stderr,
	    "HTAccess: `%s' has been accessed, No data left.\n",
	    full_address);
	}
d988 2
a989 5
	if (TRACE) {
	    fprintf(stderr,
	    "HTAccess: `%s' has been accessed, No data loaded.\n",
	    full_address);
	}
d994 2
a995 6
	if (TRACE) {
	    fprintf(stderr,
	    "HTAccess: `%s' has been accessed, transfer interrupted.\n",
	    full_address);
	}
/*	_HTProgress("Data transfer interrupted."); */
d999 21
a1019 23
    if (status <= 0) {		/* Failure in accessing a document */
	char *temp = NULL;
	StrAllocCopy(temp, "Can't Access `");
	StrAllocCat(temp, full_address);
	StrAllocCat(temp, "'");
	_HTProgress(temp);
	FREE(temp);
	if (TRACE) fprintf(stderr,
		"HTAccess: Can't access `%s'\n", full_address);
	HTLoadError(sink, 500, "Unable to access document.");
	return NO;
    }

    /*
    **	If you get this, then please find which routine is returning
    **	a positive unrecognised error code!
    */
    fprintf(stderr,
 "**** HTAccess: socket or file number returned by obsolete load routine!\n");
    fprintf(stderr,
 "**** HTAccess: Internal software error. Please mail lynx_dev@@sig.net!\n");
    fprintf(stderr, "**** HTAccess: Status returned was: %d\n",status);
    exit(-1);
d1021 3
d1121 1
a1121 1
**	  destination		    The child or parenet anchor to be loaded.
d1137 1
a1137 1
    if (HTAnchor_document(parent) == NULL) {	/* If not alread loaded */
d1167 1
a1167 1
/*	Search. 					HTSearch()
d1255 1
a1255 1
/*	Search Given Indexname. 		HTSearchAbsolute()
d1263 2
a1264 2
**	 *keywords	space-separated keyword list or similar search list
**	*addres 	is name of object search is to be done on.
d1268 1
a1268 1
	CONST char *,	indexname)
d1272 1
a1272 1
    abs_doc.address = (char *)indexname;
d1290 1
a1290 1
**	But consistency betwen browsers is STRONGLY recommended!
d1333 1
a1333 5
	    my_home_document = (char *)calloc(1,
		(strlen(home) + 1 + strlen(PERSONAL_DEFAULT) + 1));
	    if (my_home_document == NULL)
		outofmem(__FILE__, "HTAnchorHome");
	    sprintf(my_home_document, "%s/%s", home, PERSONAL_DEFAULT);
d1344 1
a1344 3
	    if (TRACE)
		fprintf(stderr,
			"HTBrowse: No local home document ~/%s or %s\n",
d1356 1
a1356 3
	if (TRACE)
	    fprintf(stderr,
		    "HTAccess: Using custom home page %s i.e. address %s\n",
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
