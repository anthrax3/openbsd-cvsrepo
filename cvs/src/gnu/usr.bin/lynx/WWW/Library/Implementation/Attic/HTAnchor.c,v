head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAnchor.c,v 1.76 2013/11/28 11:34:24 tom Exp $
 *
 *	Hypertext "Anchor" Object				HTAnchor.c
 *	==========================
 *
 * An anchor represents a region of a hypertext document which is linked to
 * another anchor in the same or a different document.
 *
 * History
 *
 *	   Nov 1990  Written in Objective-C for the NeXT browser (TBL)
 *	24-Oct-1991 (JFG), written in C, browser-independent
 *	21-Nov-1991 (JFG), first complete version
 *
 *	(c) Copyright CERN 1991 - See Copyright.html
 */

#define HASH_SIZE 1001		/* Arbitrary prime.  Memory/speed tradeoff */

#include <HTUtils.h>
#include <HTAnchor.h>
#include <HTParse.h>
#include <HTString.h>
#include <UCAux.h>
#include <UCMap.h>

#include <GridText.h>
#include <LYUtils.h>
#include <LYCharSets.h>
#include <LYUtils.h>
#include <LYLeaks.h>

#define HASH_TYPE unsigned short

#ifdef NOT_DEFINED
/*
 *	This is the hashing function used to determine which list in the
 *		adult_table a parent anchor should be put in.  This is a
 *		much simpler function than the original used.
 */
#define HASH_FUNCTION(cp_address) \
	( (HASH_TYPE)strlen(cp_address) *\
	  (HASH_TYPE)TOUPPER(*cp_address) % HASH_SIZE )
#endif /* NOT_DEFINED */

/*
 *	This is the original function.	We'll use it again. - FM
 */
static HASH_TYPE HASH_FUNCTION(const char *cp_address)
{
    HASH_TYPE hash;
    const unsigned char *p;

    for (p = (const unsigned char *) cp_address, hash = 0; *p; p++)
	hash = (HASH_TYPE) (hash * 3 + (*(const unsigned char *) p)) % HASH_SIZE;

    return (hash);
}

typedef struct _HyperDoc Hyperdoc;

#ifdef VMS
struct _HyperDoc {
    int junk;			/* VMS cannot handle pointers to undefined structs */
};
#endif /* VMS */

/* Table of lists of all parents */
static HTList adult_table[HASH_SIZE] =
{
    {NULL, NULL}};

/*				Creation Methods
 *				================
 *
 *	Do not use "new" by itself outside this module.  In order to enforce
 *	consistency, we insist that you furnish more information about the
 *	anchor you are creating : use newWithParent or newWithAddress.
 */
static HTParentAnchor0 *HTParentAnchor0_new(const char *address,
					    unsigned hash)
{
    HTParentAnchor0 *newAnchor = typecalloc(HTParentAnchor0);

    if (newAnchor == NULL)
	outofmem(__FILE__, "HTParentAnchor0_new");

    assert(newAnchor != NULL);

    newAnchor->parent = newAnchor;	/* self */
    StrAllocCopy(newAnchor->address, address);
    newAnchor->adult_hash = (HASH_TYPE) hash;

    return (newAnchor);
}

static HTParentAnchor *HTParentAnchor_new(HTParentAnchor0 *parent)
{
    HTParentAnchor *newAnchor = typecalloc(HTParentAnchor);

    if (newAnchor == NULL)
	outofmem(__FILE__, "HTParentAnchor_new");

    assert(newAnchor != NULL);

    newAnchor->parent = parent;	/* cross reference */
    parent->info = newAnchor;	/* cross reference */
    newAnchor->address = parent->address;	/* copy pointer */

    newAnchor->isISMAPScript = FALSE;	/* Lynx appends ?0,0 if TRUE. - FM */
    newAnchor->isHEAD = FALSE;	/* HEAD request if TRUE. - FM */
    newAnchor->safe = FALSE;	/* Safe. - FM */
    newAnchor->no_cache = FALSE;	/* no-cache? - FM */
    newAnchor->inBASE = FALSE;	/* duplicated from HTML.c/h */
    newAnchor->content_length = 0;	/* Content-Length. - FM */
    return (newAnchor);
}

static HTChildAnchor *HTChildAnchor_new(HTParentAnchor0 *parent)
{
    HTChildAnchor *p = typecalloc(HTChildAnchor);

    if (p == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");

    assert(p != NULL);

    p->parent = parent;		/* parent reference */
    return p;
}

static HTChildAnchor *HText_pool_ChildAnchor_new(HTParentAnchor *parent)
{
    HTChildAnchor *p = (HTChildAnchor *) HText_pool_calloc((HText *) (parent->document),
							   (unsigned) sizeof(HTChildAnchor));

    if (p == NULL)
	outofmem(__FILE__, "HText_pool_ChildAnchor_new");

    assert(p != NULL);

    p->parent = parent->parent;	/* parent reference */
    return p;
}

#ifdef CASE_INSENSITIVE_ANCHORS
/* Case insensitive string comparison */
#define HT_EQUIV(a,b) (TOUPPER(a) == TOUPPER(b))
#else
/* Case sensitive string comparison */
#define HT_EQUIV(a,b) ((a) == (b))
#endif

/*	Null-terminated string comparison
 *	---------------------------------
 * On entry,
 *	s	Points to one string, null terminated
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTSEquivalent(const char *s,
			  const char *t)
{
    if (s && t) {		/* Make sure they point to something */
	for (; *s && *t; s++, t++) {
	    if (!HT_EQUIV(*s, *t)) {
		return (NO);
	    }
	}
	return (BOOL) (HT_EQUIV(*s, *t));
    } else {
	return (BOOL) (s == t);	/* Two NULLs are equivalent, aren't they ? */
    }
}

/*	Binary string comparison
 *	------------------------
 * On entry,
 *	s	Points to one bstring
 *	t	points to the other.
 * On exit,
 *	returns YES if the strings are equivalent
 *		NO if they differ.
 */
static BOOL HTBEquivalent(const bstring *s,
			  const bstring *t)
{
    if (s && t && BStrLen(s) == BStrLen(t)) {
	int j;
	int len = BStrLen(s);

	for (j = 0; j < len; ++j) {
	    if (!HT_EQUIV(BStrData(s)[j], BStrData(t)[j])) {
		return (NO);
	    }
	}
	return (YES);
    } else {
	return (BOOL) (s == t);	/* Two NULLs are equivalent, aren't they ? */
    }
}

/*
 * Three-way compare function
 */
static int compare_anchors(void *l,
			   void *r)
{
    const char *a = ((HTChildAnchor *) l)->tag;
    const char *b = ((HTChildAnchor *) r)->tag;

    /* both tags are not NULL */

#ifdef CASE_INSENSITIVE_ANCHORS
    return strcasecomp(a, b);	/* Case insensitive */
#else
    return strcmp(a, b);	/* Case sensitive - FM */
#endif /* CASE_INSENSITIVE_ANCHORS */
}

/*	Create new or find old sub-anchor
 *	---------------------------------
 *
 *	This one is for a named child.
 *	The parent anchor must already exist.
 */
static HTChildAnchor *HTAnchor_findNamedChild(HTParentAnchor0 *parent,
					      const char *tag)
{
    HTChildAnchor *child;

    if (parent && tag && *tag) {	/* TBL */
	if (parent->children) {
	    /*
	     * Parent has children.  Search them.
	     */
	    HTChildAnchor sample;

	    sample.tag = DeConst(tag);	/* for compare_anchors() only */

	    child = (HTChildAnchor *) HTBTree_search(parent->children, &sample);
	    if (child != NULL) {
		CTRACE((tfp,
			"Child anchor %p of parent %p with name `%s' already exists.\n",
			(void *) child, (void *) parent, tag));
		return (child);
	    }
	} else {		/* parent doesn't have any children yet : create family */
	    parent->children = HTBTree_new(compare_anchors);
	}

	child = HTChildAnchor_new(parent);
	CTRACE((tfp, "HTAnchor: New Anchor %p named `%s' is child of %p\n",
		(void *) child,
		NonNull(tag),
		(void *) child->parent));

	StrAllocCopy(child->tag, tag);	/* should be set before HTBTree_add */
	HTBTree_add(parent->children, child);
	return (child);

    } else {
	CTRACE((tfp, "HTAnchor_findNamedChild called with NULL parent.\n"));
	return (NULL);
    }

}

/*
 *	This one is for a new unnamed child being edited into an existing
 *	document.  The parent anchor and the document must already exist.
 *	(Just add new unnamed child).
 */
static HTChildAnchor *HTAnchor_addChild(HTParentAnchor *parent)
{
    HTChildAnchor *child;

    if (!parent) {
	CTRACE((tfp, "HTAnchor_addChild called with NULL parent.\n"));
	return (NULL);
    }

    child = HText_pool_ChildAnchor_new(parent);
    CTRACE((tfp, "HTAnchor: New unnamed Anchor %p is child of %p\n",
	    (void *) child,
	    (void *) child->parent));

    child->tag = 0;
    HTList_linkObject(&parent->children_notag, child, &child->_add_children_notag);

    return (child);
}

static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc);

static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type);

/*	Create or find a child anchor with a possible link
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0   */
					 const char *tag,	/* May be "" or 0 */
					 const char *href,	/* May be "" or 0 */
					 HTLinkType *ltype)	/* May be 0       */
{
    HTChildAnchor *child;

    CTRACE((tfp, "Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	    NonNull(tag),
	    (ltype == HTInternalLink) ? " (internal link)" : "",
	    NonNull(href)));

    if (parent == 0) {
	child = 0;
    } else {
	if (non_empty(tag)) {
	    child = HTAnchor_findNamedChild(parent->parent, tag);
	} else {
	    child = HTAnchor_addChild(parent);
	}

	if (non_empty(href)) {
	    const char *fragment = NULL;
	    HTParentAnchor0 *dest;

	    if (ltype == HTInternalLink && *href == '#') {
		dest = parent->parent;
	    } else {
		const char *relative_to = ((parent->inBASE && *href != '#')
					   ? parent->content_base
					   : parent->address);
		DocAddress parsed_doc;

		parsed_doc.address = HTParse(href, relative_to,
					     PARSE_ALL_WITHOUT_ANCHOR);

		parsed_doc.post_data = NULL;
		parsed_doc.post_content_type = NULL;
		if (ltype && parent->post_data && ltype == HTInternalLink) {
		    /* for internal links, find a destination with the same
		       post data if the source of the link has post data. - kw
		       Example: LYNXIMGMAP: */
		    parsed_doc.post_data = parent->post_data;
		    parsed_doc.post_content_type = parent->post_content_type;
		}
		parsed_doc.bookmark = NULL;
		parsed_doc.isHEAD = FALSE;
		parsed_doc.safe = FALSE;

		dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
		FREE(parsed_doc.address);
	    }

	    /*
	     * [from HTAnchor_findAddress()]
	     * If the address represents a sub-anchor, we load its parent (above),
	     * then we create a named child anchor within that parent.
	     */
	    fragment = (*href == '#') ? href + 1 : HTParseAnchor(href);

	    if (*fragment)
		dest = (HTParentAnchor0 *) HTAnchor_findNamedChild(dest, fragment);

	    if (tag && *tag) {
		if (child->dest) {	/* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
		    CTRACE((tfp,
			    "*** Duplicate ChildAnchor %p named `%s'",
			    (void *) child, tag));
		    if ((HTAnchor *) dest != child->dest || ltype != child->type) {
			CTRACE((tfp,
				", different dest %p or type, creating unnamed child\n",
				(void *) child->dest));
			child = HTAnchor_addChild(parent);
		    }
		}
	    }
	    HTAnchor_link(child, (HTAnchor *) dest, ltype);
	}
    }
    return child;
}

/*	Create new or find old parent anchor
 *	------------------------------------
 *
 *	Me one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
HTParentAnchor *HTAnchor_findAddress(const DocAddress *newdoc)
{
    /* Anchor tag specified ? */
    const char *tag = HTParseAnchor(newdoc->address);

    CTRACE((tfp, "Entered HTAnchor_findAddress\n"));

    /*
     * If the address represents a sub-anchor, we load its parent, then we
     * create a named child anchor within that parent.
     */
    if (*tag) {
	DocAddress parsed_doc;
	HTParentAnchor0 *foundParent;

	parsed_doc.address = HTParse(newdoc->address, "",
				     PARSE_ALL_WITHOUT_ANCHOR);
	parsed_doc.post_data = newdoc->post_data;
	parsed_doc.post_content_type = newdoc->post_content_type;
	parsed_doc.bookmark = newdoc->bookmark;
	parsed_doc.isHEAD = newdoc->isHEAD;
	parsed_doc.safe = newdoc->safe;

	foundParent = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	(void) HTAnchor_findNamedChild(foundParent, tag);
	FREE(parsed_doc.address);
	return HTAnchor_parent((HTAnchor *) foundParent);
    }
    return HTAnchor_parent((HTAnchor *) HTAnchor_findAddress_in_adult_table(newdoc));
}

/*  The address has no anchor tag, for sure.
 */
static HTParentAnchor0 *HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc)
{
    /*
     * Check whether we have this node.
     */
    HASH_TYPE hash;
    HTList *adults;
    HTList *grownups;
    HTParentAnchor0 *foundAnchor;
    BOOL need_extra_info = (BOOL) (newdoc->post_data ||
				   newdoc->post_content_type ||
				   newdoc->bookmark ||
				   newdoc->isHEAD ||
				   newdoc->safe);

    /*
     * We need not free adult_table[] atexit - it should be perfectly empty
     * after free'ing all HText's.  (There is an error if it is not empty at
     * exit).  -LP
     */

    /*
     * Select list from hash table,
     */
    hash = HASH_FUNCTION(newdoc->address);
    adults = &(adult_table[hash]);

    /*
     * Search list for anchor.
     */
    grownups = adults;
    while (NULL != (foundAnchor =
		    (HTParentAnchor0 *) HTList_nextObject(grownups))) {
	if (HTSEquivalent(foundAnchor->address, newdoc->address) &&

	    ((!foundAnchor->info && !need_extra_info) ||
	     (foundAnchor->info &&
	      HTBEquivalent(foundAnchor->info->post_data, newdoc->post_data) &&
	      foundAnchor->info->isHEAD == newdoc->isHEAD))) {
	    CTRACE((tfp, "Anchor %p with address `%s' already exists.\n",
		    (void *) foundAnchor, newdoc->address));
	    return foundAnchor;
	}
    }

    /*
     * Node not found:  create new anchor.
     */
    foundAnchor = HTParentAnchor0_new(newdoc->address, hash);
    CTRACE((tfp, "New anchor %p has hash %d and address `%s'\n",
	    (void *) foundAnchor, hash, newdoc->address));

    if (need_extra_info) {
	/* rare case, create a big structure */
	HTParentAnchor *p = HTParentAnchor_new(foundAnchor);

	if (newdoc->post_data)
	    BStrCopy(p->post_data, newdoc->post_data);
	if (newdoc->post_content_type)
	    StrAllocCopy(p->post_content_type,
			 newdoc->post_content_type);
	if (newdoc->bookmark)
	    StrAllocCopy(p->bookmark, newdoc->bookmark);
	p->isHEAD = newdoc->isHEAD;
	p->safe = newdoc->safe;
    }
    HTList_linkObject(adults, foundAnchor, &foundAnchor->_add_adult);

    return foundAnchor;
}

/*	Create new or find old named anchor - simple form
 *	-------------------------------------------------
 *
 *     Like HTAnchor_findAddress, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
HTParentAnchor *HTAnchor_findSimpleAddress(const char *url)
{
    DocAddress urldoc;

    urldoc.address = DeConst(url);	/* ignore warning, it IS treated like const - kw */
    urldoc.post_data = NULL;
    urldoc.post_content_type = NULL;
    urldoc.bookmark = NULL;
    urldoc.isHEAD = FALSE;
    urldoc.safe = FALSE;
    return HTAnchor_findAddress(&urldoc);
}

/*	Link me Anchor to another given one
 *	-------------------------------------
 */
static BOOL HTAnchor_link(HTChildAnchor *child,
			  HTAnchor * destination,
			  HTLinkType *type)
{
    if (!(child && destination))
	return (NO);		/* Can't link to/from non-existing anchor */

    CTRACE((tfp, "Linking child %p to anchor %p\n", (void *) child, (void *) destination));
    if (child->dest) {
	CTRACE((tfp, "*** child anchor already has destination, exiting!\n"));
	return (NO);
    }

    child->dest = destination;
    child->type = type;

    if (child->parent != destination->parent)
	/* link only foreign children */
	HTList_linkObject(&destination->parent->sources, child, &child->_add_sources);

    return (YES);		/* Success */
}

/*	Delete an anchor and possibly related things (auto garbage collection)
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of theirs targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */

/*
 *	Recursively try to delete destination anchor of this child.
 *	In any event, this will tell destination anchor that we
 *	no longer consider it a destination.
 */
static void deleteLinks(HTChildAnchor *me)
{
    /*
     * Unregister me with our destination anchor's parent.
     */
    if (me->dest) {
	HTParentAnchor0 *parent = me->dest->parent;

	/*
	 * Start.  Set the dest pointer to zero.
	 */
	me->dest = NULL;

	/*
	 * Remove me from the parent's sources so that the parent knows one
	 * less anchor is its dest.
	 */
	if ((me->parent != parent) && !HTList_isEmpty(&parent->sources)) {
	    /*
	     * Really should only need to deregister once.
	     */
	    HTList_unlinkObject(&parent->sources, (void *) me);
	}

	/*
	 * Recursive call.  Test here to avoid calling overhead.  Don't delete
	 * if document is loaded or being loaded.
	 */
	if ((me->parent != parent) &&
	    parent != NULL &&
	    !parent->underway &&
	    (!parent->info || !parent->info->document)) {
	    HTAnchor_delete(parent);
	}

	/*
	 * At this point, we haven't a destination.  Set it to be so.  Leave
	 * the HTAtom pointed to by type up to other code to handle (reusable,
	 * near static).
	 */
	me->type = NULL;
    }
}

static void HTParentAnchor_free(HTParentAnchor *me);

BOOL HTAnchor_delete(HTParentAnchor0 *me)
{
    /*
     * Memory leaks fixed.
     * 05-27-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    HTBTElement *ele;
    HTChildAnchor *child;

    /*
     * Do nothing if nothing to do.
     */
    if (!me) {
	return (NO);
    }

    /*
     * Don't delete if document is loaded or being loaded.
     */
    if (me->underway || (me->info && me->info->document)) {
	return (NO);
    }

    /*
     * Mark ourselves busy, so that recursive calls of this function on this
     * HTParentAnchor0 will not free it from under our feet.  - kw
     */
    me->underway = TRUE;

    {
	/*
	 * Delete all outgoing links from named children.  Do not delete named
	 * children itself (may have incoming links).
	 */
	if (me->children) {
	    ele = HTBTree_next(me->children, NULL);
	    while (ele != NULL) {
		child = (HTChildAnchor *) HTBTree_object(ele);
		if (child->dest)
		    deleteLinks(child);
		ele = HTBTree_next(me->children, ele);
	    }
	}
    }
    me->underway = FALSE;

    /*
     * There are still incoming links to this one (we are the
     * destination of another anchor).
     */
    if (!HTList_isEmpty(&me->sources)) {
	/*
	 * Can't delete parent, still have sources.
	 */
	return (NO);
    }

    /*
     * No more incoming and outgoing links :  kill everything First, delete
     * named children.
     */
    if (me->children) {
	ele = HTBTree_next(me->children, NULL);
	while (ele != NULL) {
	    child = (HTChildAnchor *) HTBTree_object(ele);
	    FREE(child->tag);
	    FREE(child);
	    ele = HTBTree_next(me->children, ele);
	}
	HTBTree_free(me->children);
    }

    /*
     * Delete the ParentAnchor, if any.  (Document was already deleted).
     */
    if (me->info) {
	HTParentAnchor_free(me->info);
	FREE(me->info);
    }

    /*
     * Remove ourselves from the hash table's list.
     */
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *) me);

    /*
     * Free the address.
     */
    FREE(me->address);

    /*
     * Finally, kill the parent anchor passed in.
     */
    FREE(me);

    return (YES);
}

/*
 * Unnamed children (children_notag) have no sence without HText - delete them
 * and their links if we are about to free HText.  Document currently exists. 
 * Called within HText_free().
 */
void HTAnchor_delete_links(HTParentAnchor *me)
{
    HTList *cur;
    HTChildAnchor *child;

    /*
     * Do nothing if nothing to do.
     */
    if (!me || !me->document) {
	return;
    }

    /*
     * Mark ourselves busy, so that recursive calls on this HTParentAnchor0
     * will not free it from under our feet.  - kw
     */
    me->parent->underway = TRUE;

    /*
     * Delete all outgoing links from unnamed children.
     */
    if (!HTList_isEmpty(&me->children_notag)) {
	cur = &me->children_notag;
	while ((child =
		(HTChildAnchor *) HTList_unlinkLastObject(cur)) != 0) {
	    deleteLinks(child);
	    /* child allocated in HText pool, HText_free() will free it later */
	}
    }
    me->parent->underway = FALSE;
}

static void HTParentAnchor_free(HTParentAnchor *me)
{
    /*
     * Delete the methods list.
     */
    if (me->methods) {
	/*
	 * Leave what the methods point to up in memory for other code (near
	 * static stuff).
	 */
	HTList_delete(me->methods);
	me->methods = NULL;
    }

    /*
     * Free up all allocated members.
     */
    FREE(me->charset);
    FREE(me->isIndexAction);
    FREE(me->isIndexPrompt);
    FREE(me->title);
    FREE(me->physical);
    BStrFree(me->post_data);
    FREE(me->post_content_type);
    FREE(me->bookmark);
    FREE(me->owner);
    FREE(me->RevTitle);
    FREE(me->citehost);
#ifdef USE_SOURCE_CACHE
    HTAnchor_clearSourceCache(me);
#endif
    if (me->FileCache) {
	FILE *fd;

	if ((fd = fopen(me->FileCache, "r")) != NULL) {
	    fclose(fd);
	    (void) remove(me->FileCache);
	}
	FREE(me->FileCache);
    }
    FREE(me->SugFname);
    FREE(me->cache_control);
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&(me->http_headers));
#endif
    FREE(me->content_type_params);
    FREE(me->content_type);
    FREE(me->content_language);
    FREE(me->content_encoding);
    FREE(me->content_base);
    FREE(me->content_disposition);
    FREE(me->content_location);
    FREE(me->content_md5);
    FREE(me->message_id);
    FREE(me->subject);
    FREE(me->date);
    FREE(me->expires);

    FREE(me->last_modified);
    FREE(me->ETag);
    FREE(me->server);
#ifdef USE_COLOR_STYLE
    FREE(me->style);
#endif

    /*
     * Original code wanted a way to clean out the HTFormat if no longer needed
     * (ref count?).  I'll leave it alone since those HTAtom objects are a
     * little harder to know where they are being referenced all at one time. 
     * (near static)
     */

    FREE(me->UCStages);
    ImageMapList_free(me->imaps);
}

#ifdef USE_SOURCE_CACHE
void HTAnchor_clearSourceCache(HTParentAnchor *me)
{
    /*
     * Clean up the source cache, if any.
     */
    if (me->source_cache_file) {
	CTRACE((tfp, "SourceCache: Removing file %s\n",
		me->source_cache_file));
	(void) LYRemoveTemp(me->source_cache_file);
	FREE(me->source_cache_file);
    }
    if (me->source_cache_chunk) {
	CTRACE((tfp, "SourceCache: Removing memory chunk %p\n",
		(void *) me->source_cache_chunk));
	HTChunkFree(me->source_cache_chunk);
	me->source_cache_chunk = NULL;
    }
}
#endif /* USE_SOURCE_CACHE */

/*	Data access functions
 *	---------------------
 */
HTParentAnchor *HTAnchor_parent(HTAnchor * me)
{
    if (!me)
	return NULL;

    if (me->parent->info)
	return me->parent->info;

    /* else: create a new structure */
    return HTParentAnchor_new(me->parent);
}

void HTAnchor_setDocument(HTParentAnchor *me,
			  HyperDoc *doc)
{
    if (me)
	me->document = doc;
}

HyperDoc *HTAnchor_document(HTParentAnchor *me)
{
    return (me ? me->document : NULL);
}

char *HTAnchor_address(HTAnchor * me)
{
    char *addr = NULL;

    if (me) {
	if (((HTParentAnchor0 *) me == me->parent) ||
	    ((HTParentAnchor *) me == me->parent->info) ||
	    !((HTChildAnchor *) me)->tag) {	/* it's an adult or no tag */
	    StrAllocCopy(addr, me->parent->address);
	} else {		/* it's a named child */
	    HTSprintf0(&addr, "%s#%s",
		       me->parent->address, ((HTChildAnchor *) me)->tag);
	}
    }
    return (addr);
}

char *HTAnchor_short_address(HTAnchor * me)
{
    const char chop[] = "file://localhost/";
    char *addr = HTAnchor_address(me);

    if (!strncmp(addr, chop, sizeof(chop) - 1)) {
	char *a = addr + 7;
	char *b = addr + sizeof(chop) - 2;

	while ((*a++ = *b++) != '\0') {
	    ;
	}
    }
    return addr;
}

void HTAnchor_setFormat(HTParentAnchor *me,
			HTFormat form)
{
    if (me)
	me->format = form;
}

HTFormat HTAnchor_format(HTParentAnchor *me)
{
    return (me ? me->format : NULL);
}

void HTAnchor_setIndex(HTParentAnchor *me,
		       const char *address)
{
    if (me) {
	me->isIndex = YES;
	StrAllocCopy(me->isIndexAction, address);
    }
}

void HTAnchor_setPrompt(HTParentAnchor *me,
			const char *prompt)
{
    if (me) {
	StrAllocCopy(me->isIndexPrompt, prompt);
    }
}

BOOL HTAnchor_isIndex(HTParentAnchor *me)
{
    return (BOOL) (me
		   ? me->isIndex
		   : NO);
}

/*	Whether Anchor has been designated as an ISMAP link
 *	(normally by presence of an ISMAP attribute on A or IMG) - KW
 */
BOOL HTAnchor_isISMAPScript(HTAnchor * me)
{
    return (BOOL) ((me && me->parent->info)
		   ? me->parent->info->isISMAPScript
		   : NO);
}

#if defined(USE_COLOR_STYLE)
/*	Style handling.
*/
const char *HTAnchor_style(HTParentAnchor *me)
{
    return (me ? me->style : NULL);
}

void HTAnchor_setStyle(HTParentAnchor *me,
		       const char *style)
{
    if (me) {
	StrAllocCopy(me->style, style);
    }
}
#endif

/*	Title handling.
*/
const char *HTAnchor_title(HTParentAnchor *me)
{
    return (me ? me->title : NULL);
}

void HTAnchor_setTitle(HTParentAnchor *me,
		       const char *title)
{
    int i;

    if (me) {
	if (title) {
	    StrAllocCopy(me->title, title);
	    for (i = 0; me->title[i]; i++) {
		if (UCH(me->title[i]) == 1 ||
		    UCH(me->title[i]) == 2) {
		    me->title[i] = ' ';
		}
	    }
	} else {
	    CTRACE((tfp, "HTAnchor_setTitle: New title is NULL! "));
	    if (me->title) {
		CTRACE((tfp, "Old title was \"%s\".\n", me->title));
		FREE(me->title);
	    } else {
		CTRACE((tfp, "Old title was NULL.\n"));
	    }
	}
    }
}

void HTAnchor_appendTitle(HTParentAnchor *me,
			  const char *title)
{
    int i;

    if (me) {
	StrAllocCat(me->title, title);
	for (i = 0; me->title[i]; i++) {
	    if (UCH(me->title[i]) == 1 ||
		UCH(me->title[i]) == 2) {
		me->title[i] = ' ';
	    }
	}
    }
}

/*	Bookmark handling.
*/
const char *HTAnchor_bookmark(HTParentAnchor *me)
{
    return (me ? me->bookmark : NULL);
}

void HTAnchor_setBookmark(HTParentAnchor *me,
			  const char *bookmark)
{
    if (me)
	StrAllocCopy(me->bookmark, bookmark);
}

/*	Owner handling.
*/
const char *HTAnchor_owner(HTParentAnchor *me)
{
    return (me ? me->owner : NULL);
}

void HTAnchor_setOwner(HTParentAnchor *me,
		       const char *owner)
{
    if (me) {
	StrAllocCopy(me->owner, owner);
    }
}

/*	TITLE handling in LINKs with REV="made" or REV="owner". - FM
*/
const char *HTAnchor_RevTitle(HTParentAnchor *me)
{
    return (me ? me->RevTitle : NULL);
}

void HTAnchor_setRevTitle(HTParentAnchor *me,
			  const char *title)
{
    int i;

    if (me) {
	StrAllocCopy(me->RevTitle, title);
	for (i = 0; me->RevTitle[i]; i++) {
	    if (UCH(me->RevTitle[i]) == 1 ||
		UCH(me->RevTitle[i]) == 2) {
		me->RevTitle[i] = ' ';
	    }
	}
    }
}

#ifndef DISABLE_BIBP
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
const char *HTAnchor_citehost(HTParentAnchor *me)
{
    return (me ? me->citehost : NULL);
}

void HTAnchor_setCitehost(HTParentAnchor *me,
			  const char *citehost)
{
    if (me) {
	StrAllocCopy(me->citehost, citehost);
    }
}
#endif /* !DISABLE_BIBP */

/*	Suggested filename handling. - FM
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
const char *HTAnchor_SugFname(HTParentAnchor *me)
{
    return (me ? me->SugFname : NULL);
}

#ifdef EXP_HTTP_HEADERS
/*	HTTP Headers.
*/
const char *HTAnchor_http_headers(HTParentAnchor *me)
{
    return (me ? me->http_headers.data : NULL);
}
#endif

/*	Content-Type handling (parameter list).
*/
const char *HTAnchor_content_type_params(HTParentAnchor *me)
{
    return (me ? me->content_type_params : NULL);
}

/*	Content-Encoding handling. - FM
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
const char *HTAnchor_content_encoding(HTParentAnchor *me)
{
    return (me ? me->content_encoding : NULL);
}

/*	Content-Type handling. - FM
*/
const char *HTAnchor_content_type(HTParentAnchor *me)
{
    return (me ? me->content_type : NULL);
}

/*	Last-Modified header handling. - FM
*/
const char *HTAnchor_last_modified(HTParentAnchor *me)
{
    return (me ? me->last_modified : NULL);
}

/*	Date header handling. - FM
*/
const char *HTAnchor_date(HTParentAnchor *me)
{
    return (me ? me->date : NULL);
}

/*	Server header handling. - FM
*/
const char *HTAnchor_server(HTParentAnchor *me)
{
    return (me ? me->server : NULL);
}

/*	Safe header handling. - FM
*/
BOOL HTAnchor_safe(HTParentAnchor *me)
{
    return (BOOL) (me ? me->safe : FALSE);
}

/*	Content-Base header handling. - FM
*/
const char *HTAnchor_content_base(HTParentAnchor *me)
{
    return (me ? me->content_base : NULL);
}

/*	Content-Location header handling. - FM
*/
const char *HTAnchor_content_location(HTParentAnchor *me)
{
    return (me ? me->content_location : NULL);
}

/*	Message-ID, used for mail replies - kw
*/
const char *HTAnchor_messageID(HTParentAnchor *me)
{
    return (me ? me->message_id : NULL);
}

BOOL HTAnchor_setMessageID(HTParentAnchor *me,
			   const char *messageid)
{
    if (!(me && messageid && *messageid)) {
	return FALSE;
    }
    StrAllocCopy(me->message_id, messageid);
    return TRUE;
}

/*	Subject, used for mail replies - kw
*/
const char *HTAnchor_subject(HTParentAnchor *me)
{
    return (me ? me->subject : NULL);
}

BOOL HTAnchor_setSubject(HTParentAnchor *me,
			 const char *subject)
{
    if (!(me && subject && *subject)) {
	return FALSE;
    }
    StrAllocCopy(me->subject, subject);
    return TRUE;
}

/*	Manipulation of links
 *	---------------------
 */
HTAnchor *HTAnchor_followLink(HTChildAnchor *me)
{
    return (me->dest);
}

HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
				   HTLinkType *type)
{
    if (me->type == type)
	return (me->dest);
    return (NULL);		/* No link of me type */
}

/*	Methods List
 *	------------
 */
HTList *HTAnchor_methods(HTParentAnchor *me)
{
    if (!me->methods) {
	me->methods = HTList_new();
    }
    return (me->methods);
}

/*	Protocol
 *	--------
 */
void *HTAnchor_protocol(HTParentAnchor *me)
{
    return (me->protocol);
}

void HTAnchor_setProtocol(HTParentAnchor *me,
			  void *protocol)
{
    me->protocol = protocol;
}

/*	Physical Address
 *	----------------
 */
char *HTAnchor_physical(HTParentAnchor *me)
{
    return (me->physical);
}

void HTAnchor_setPhysical(HTParentAnchor *me,
			  char *physical)
{
    if (me) {
	StrAllocCopy(me->physical, physical);
    }
}

#ifdef DEBUG
static void show_stages(HTParentAnchor *me, const char *tag, int which_stage)
{
    int j;

    CTRACE((tfp, "Stages %s*%s", NonNull(me->charset), tag));
    for (j = 0; j < UCT_STAGEMAX; j++) {
	CTRACE((tfp, " "));
	if (j == which_stage)
	    CTRACE((tfp, "("));
	CTRACE((tfp, "%d:%d:%s",
		j,
		me->UCStages->s[j].LYhndl,
		NonNull(me->UCStages->s[j].C.MIMEname)));
	if (j == which_stage)
	    CTRACE((tfp, ")"));
    }
    CTRACE((tfp, "\n"));
}
#else
#define show_stages(me,tag,which_stage)		/* nothing */
#endif

/*
 *  We store charset info in the HTParentAnchor object, for several
 *  "stages".  (See UCDefs.h)
 *  A stream method is supposed to know what stage in the model it is.
 *
 *  General model	MIME	 ->  parser  ->  structured  ->  HText
 *  e.g., text/html
 *	from HTTP:	HTMIME.c ->  SGML.c  ->  HTML.c      ->  GridText.c
 *     text/plain
 *	from file:	HTFile.c ->  HTPlain.c		     ->  GridText.c
 *
 *  The lock/set_by is used to lock e.g. a charset set by an explicit
 *  HTTP MIME header against overriding by a HTML META tag - the MIME
 *  header has higher priority.  Defaults (from -assume_.. options etc.)
 *  will not override charset explicitly given by server.
 *
 *  Some advantages of keeping this in the HTAnchor:
 *  - Global variables are bad.
 *  - Can remember a charset given by META tag when toggling to SOURCE view.
 *  - Can remember a charset given by <A CHARSET=...> href in another doc.
 *
 *  We don't modify the HTParentAnchor's charset element
 *  here, that one will only be set when explicitly given.
 */
LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
				     int which_stage)
{
    LYUCcharset *result = NULL;

    if (me) {
	if (!me->UCStages) {
	    int i;
	    int chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	    UCAnchorInfo *stages = typecalloc(UCAnchorInfo);

	    if (stages == NULL)
		outofmem(__FILE__, "HTAnchor_getUCInfoStage");

	    assert(stages != NULL);

	    for (i = 0; i < UCT_STAGEMAX; i++) {
		stages->s[i].C.MIMEname = "";
		stages->s[i].LYhndl = -1;
	    }
	    if (me->charset) {
		chndl = UCGetLYhndl_byMIME(me->charset);
		if (chndl < 0)
		    chndl = UCLYhndl_for_unrec;
		if (chndl < 0)
		    /*
		     * UCLYhndl_for_unrec not defined :-(
		     * fallback to UCLYhndl_for_unspec which always valid.
		     */
		    chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	    }
	    MemCpy(&stages->s[UCT_STAGE_MIME].C, &LYCharSet_UC[chndl],
		   sizeof(LYUCcharset));

	    stages->s[UCT_STAGE_MIME].lock = UCT_SETBY_DEFAULT;
	    stages->s[UCT_STAGE_MIME].LYhndl = chndl;
	    me->UCStages = stages;
	}
	result = (&me->UCStages->s[which_stage].C);
	show_stages(me, "_getUCInfoStage", which_stage);
    }
    return (result);
}

int HTAnchor_getUCLYhndl(HTParentAnchor *me,
			 int which_stage)
{
    if (me) {
	if (!me->UCStages) {
	    /*
	     * This will allocate and initialize, if not yet done.
	     */
	    (void) HTAnchor_getUCInfoStage(me, which_stage);
	}
	if (me->UCStages->s[which_stage].lock > UCT_SETBY_NONE) {
	    return (me->UCStages->s[which_stage].LYhndl);
	}
    }
    return (-1);
}

#ifdef CAN_SWITCH_DISPLAY_CHARSET
static void setup_switch_display_charset(HTParentAnchor *me, int h)
{
    if (!Switch_Display_Charset(h, SWITCH_DISPLAY_CHARSET_MAYBE))
	return;
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME);	/* highest priorty! */
    HTAnchor_setUCInfoStage(me, current_char_set,
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME);	/* highest priorty! */
    CTRACE((tfp,
	    "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
	    LYCharSet_UC[current_char_set].MIMEname));
}
#endif

LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
				     int LYhndl,
				     int which_stage,
				     int set_by)
{
    if (me) {
	/*
	 * This will allocate and initialize, if not yet done.
	 */
	LYUCcharset *p = HTAnchor_getUCInfoStage(me, which_stage);

	/*
	 * Can we override?
	 */
	if (set_by >= me->UCStages->s[which_stage].lock) {
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[which_stage].LYhndl;
#endif
	    me->UCStages->s[which_stage].lock = set_by;
	    me->UCStages->s[which_stage].LYhndl = LYhndl;
	    if (LYhndl >= 0) {
		MemCpy(p, &LYCharSet_UC[LYhndl], sizeof(LYUCcharset));

#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Allow a switch to a more suitable display charset */
		if (LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
		    setup_switch_display_charset(me, LYhndl);
#endif
	    } else {
		p->UChndl = -1;
	    }
	    show_stages(me, "_setUCInfoStage", which_stage);
	    return (p);
	}
    }
    return (NULL);
}

LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
				       int LYhndl,
				       int which_stage,
				       int set_by)
{
    LYUCcharset *result = NULL;
    int ohandle;

    if (me && me->UCStages) {
	me->UCStages->s[which_stage].lock = set_by;
	ohandle = me->UCStages->s[which_stage].LYhndl;
	me->UCStages->s[which_stage].LYhndl = LYhndl;
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	/* Allow a switch to a more suitable display charset */
	if (LYhndl >= 0 && LYhndl != ohandle
	    && which_stage == UCT_STAGE_PARSER)
	    setup_switch_display_charset(me, LYhndl);
#else
	(void) ohandle;
#endif
	show_stages(me, "_resetUCInfoStage", which_stage);
	result = (&me->UCStages->s[which_stage].C);
    }
    return result;
}

/*
 *  A set_by of (-1) means use the lock value from the from_stage.
 */
LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
				      int to_stage,
				      int from_stage,
				      int set_by)
{
    if (me) {
	/*
	 * This will allocate and initialize, if not yet done.
	 */
	LYUCcharset *p_from = HTAnchor_getUCInfoStage(me, from_stage);
	LYUCcharset *p_to = HTAnchor_getUCInfoStage(me, to_stage);

	/*
	 * Can we override?
	 */
	if (set_by == -1)
	    set_by = me->UCStages->s[from_stage].lock;
	if (set_by == UCT_SETBY_NONE)
	    set_by = UCT_SETBY_DEFAULT;
	if (set_by >= me->UCStages->s[to_stage].lock) {
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    int ohandle = me->UCStages->s[to_stage].LYhndl;
#endif
	    me->UCStages->s[to_stage].lock = set_by;
	    me->UCStages->s[to_stage].LYhndl =
		me->UCStages->s[from_stage].LYhndl;
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (me->UCStages->s[to_stage].LYhndl >= 0
		&& me->UCStages->s[to_stage].LYhndl != ohandle
		&& to_stage == UCT_STAGE_PARSER)
		setup_switch_display_charset(me,
					     me->UCStages->s[to_stage].LYhndl);
#endif
	    if (p_to != p_from)
		MemCpy(p_to, p_from, sizeof(LYUCcharset));

	    return (p_to);
	}
    }
    return (NULL);
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTAnchor.c,v 1.63 2009/04/08 19:55:12 tom Exp $
d56 1
a56 1
	hash = (int) (hash * 3 + (*(const unsigned char *) p)) % HASH_SIZE;
d82 1
a82 1
					    HASH_TYPE hash)
d89 2
d93 1
a93 1
    newAnchor->adult_hash = hash;
d105 2
d127 2
d136 1
a136 1
							   sizeof(HTChildAnchor));
d141 2
d173 1
a173 1
	return (HT_EQUIV(*s, *t));
d242 1
a242 1
	    sample.tag = (char *) tag;	/* for compare_anchors() only */
d322 2
a323 2
    if (tag && *tag) {
	child = HTAnchor_findNamedChild(parent->parent, tag);
d325 5
a329 2
	child = HTAnchor_addChild(parent);
    }
d331 3
a333 3
    if (href && *href) {
	const char *fragment = NULL;
	HTParentAnchor0 *dest;
d335 26
a360 19
	if (ltype == HTInternalLink && *href == '#') {
	    dest = parent->parent;
	} else {
	    const char *relative_to = ((parent->inBASE && *href != '#')
				       ? parent->content_base
				       : parent->address);
	    DocAddress parsed_doc;

	    parsed_doc.address = HTParse(href, relative_to,
					 PARSE_ALL_WITHOUT_ANCHOR);

	    parsed_doc.post_data = NULL;
	    parsed_doc.post_content_type = NULL;
	    if (ltype && parent->post_data && ltype == HTInternalLink) {
		/* for internal links, find a destination with the same
		   post data if the source of the link has post data. - kw
		   Example: LYNXIMGMAP: */
		parsed_doc.post_data = parent->post_data;
		parsed_doc.post_content_type = parent->post_content_type;
a361 3
	    parsed_doc.bookmark = NULL;
	    parsed_doc.isHEAD = FALSE;
	    parsed_doc.safe = FALSE;
d363 6
a368 10
	    dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
	    FREE(parsed_doc.address);
	}

	/*
	 * [from HTAnchor_findAddress()]
	 * If the address represents a sub-anchor, we load its parent (above),
	 * then we create a named child anchor within that parent.
	 */
	fragment = (*href == '#') ? href + 1 : HTParseAnchor(href);
d370 2
a371 2
	if (*fragment)
	    dest = (HTParentAnchor0 *) HTAnchor_findNamedChild(dest, fragment);
d373 2
a374 6
	if (tag && *tag) {
	    if (child->dest) {	/* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
		CTRACE((tfp,
			"*** Duplicate ChildAnchor %p named `%s'",
			(void *) child, tag));
		if ((HTAnchor *) dest != child->dest || ltype != child->type) {
d376 8
a383 3
			    ", different dest %p or type, creating unnamed child\n",
			    (void *) child->dest));
		    child = HTAnchor_addChild(parent);
d386 1
a387 1
	HTAnchor_link(child, (HTAnchor *) dest, ltype);
a413 1
	HTChildAnchor *foundAnchor;
d424 1
a424 1
	foundAnchor = HTAnchor_findNamedChild(foundParent, tag);
d514 1
a514 1
    urldoc.address = (char *) url;	/* ignore warning, it IS treated like const - kw */
d592 3
a594 1
	if ((me->parent != parent) && !parent->underway &&
d781 1
a781 1
	    remove(me->FileCache);
d830 1
a830 1
	LYRemoveTemp(me->source_cache_file);
d886 16
d933 3
a935 3
    return (me
	    ? (BOOL) me->isIndex
	    : NO);
d943 3
a945 3
    return ((me && me->parent->info)
	    ? (BOOL) me->parent->info->isISMAPScript
	    : NO);
d1257 23
d1307 2
a1308 29
    if (me && !me->UCStages) {
	int i;
	int chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	UCAnchorInfo *stages = typecalloc(UCAnchorInfo);

	if (stages == NULL)
	    outofmem(__FILE__, "HTAnchor_getUCInfoStage");
	for (i = 0; i < UCT_STAGEMAX; i++) {
	    stages->s[i].C.MIMEname = "";
	    stages->s[i].LYhndl = -1;
	}
	if (me->charset) {
	    chndl = UCGetLYhndl_byMIME(me->charset);
	    if (chndl < 0)
		chndl = UCLYhndl_for_unrec;
	    if (chndl < 0)
		/*
		 * UCLYhndl_for_unrec not defined :-(
		 * fallback to UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	}
	memcpy(&stages->s[UCT_STAGE_MIME].C, &LYCharSet_UC[chndl],
	       sizeof(LYUCcharset));

	stages->s[UCT_STAGE_MIME].lock = UCT_SETBY_DEFAULT;
	stages->s[UCT_STAGE_MIME].LYhndl = chndl;
	me->UCStages = stages;
    }
d1310 34
a1343 1
	return (&me->UCStages->s[which_stage].C);
d1345 1
a1345 1
    return (NULL);
d1401 1
a1401 1
		memcpy(p, &LYCharSet_UC[LYhndl], sizeof(LYUCcharset));
d1411 1
d1423 1
d1426 4
a1429 5
    if (!me || !me->UCStages)
	return (NULL);
    me->UCStages->s[which_stage].lock = set_by;
    ohandle = me->UCStages->s[which_stage].LYhndl;
    me->UCStages->s[which_stage].LYhndl = LYhndl;
d1431 4
a1434 3
    /* Allow a switch to a more suitable display charset */
    if (LYhndl >= 0 && LYhndl != ohandle && which_stage == UCT_STAGE_PARSER)
	setup_switch_display_charset(me, LYhndl);
d1436 1
a1436 1
    (void) ohandle;
d1438 4
a1441 1
    return (&me->UCStages->s[which_stage].C);
d1482 1
a1482 1
		memcpy(p_to, p_from, sizeof(LYUCcharset));
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*	Hypertext "Anchor" Object				HTAnchor.c
d31 1
d34 2
d42 3
a44 2
#define HASH_FUNCTION(cp_address) ((unsigned short int)strlen(cp_address) *\
	(unsigned short int)TOUPPER(*cp_address) % HASH_SIZE)
d46 1
d50 1
a50 1
static int HASH_FUNCTION(const char *cp_address)
d52 1
a52 1
    int hash;
d82 1
a82 1
					    short hash)
d167 1
a167 1
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
d194 1
a194 1
	return (s == t);	/* Two NULLs are equivalent, aren't they ? */
d366 1
a366 1
			child, tag));
d370 1
a370 1
			    child->dest));
d427 1
a427 1
    int hash;
d431 5
a435 2
    BOOL need_extra_info = (newdoc->post_data || newdoc->post_content_type ||
			    newdoc->bookmark || newdoc->isHEAD || newdoc->safe);
d522 1
a522 1
    CTRACE((tfp, "Linking child %p to anchor %p\n", child, destination));
d904 3
a906 1
    return (me ? me->isIndex : NO);
d914 3
a916 1
    return ((me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
d1375 2
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 13
a14 13
**	==========================
**
** An anchor represents a region of a hypertext document which is linked to
** another anchor in the same or a different document.
**
** History
**
**	   Nov 1990  Written in Objective-C for the NeXT browser (TBL)
**	24-Oct-1991 (JFG), written in C, browser-independent
**	21-Nov-1991 (JFG), first complete version
**
**	(c) Copyright CERN 1991 - See Copyright.html
*/
d16 1
a16 1
#define HASH_SIZE 101		/* Arbitrary prime.  Memory/speed tradeoff */
d42 1
a42 2
PRIVATE int HASH_FUNCTION ARGS1(
	CONST char *,	cp_address)
d45 1
a45 1
    CONST unsigned char *p;
d47 2
a48 2
    for (p = (CONST unsigned char *)cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(CONST unsigned char *)p)) % HASH_SIZE;
d50 1
a50 1
    return(hash);
d54 1
d57 1
a57 1
	int junk;	/* VMS cannot handle pointers to undefined structs */
d62 3
a64 2
PRIVATE HTList adult_table[HASH_SIZE] = { {NULL, NULL} };

d67 8
a74 9
**				================
**
**	Do not use "new" by itself outside this module.  In order to enforce
**	consistency, we insist that you furnish more information about the
**	anchor you are creating : use newWithParent or newWithAddress.
*/
PRIVATE HTParentAnchor0 * HTParentAnchor0_new ARGS2(
	CONST char *,	address,
	short,		hash)
d77 1
d85 1
a85 1
    return(newAnchor);
d88 1
a88 2
PRIVATE HTParentAnchor * HTParentAnchor_new ARGS1(
	HTParentAnchor0 *,	parent)
d91 1
d95 3
a97 3
    newAnchor->parent = parent;		/* cross reference */
    parent->info = newAnchor;		/* cross reference */
    newAnchor->address = parent->address;  /* copy pointer */
d100 2
a101 2
    newAnchor->isHEAD = FALSE;		/* HEAD request if TRUE. - FM */
    newAnchor->safe = FALSE;		/* Safe. - FM */
d103 1
a103 1
    newAnchor->inBASE = FALSE;		/* duplicated from HTML.c/h */
d105 1
a105 1
    return(newAnchor);
d108 1
a108 2
PRIVATE HTChildAnchor * HTChildAnchor_new ARGS1(
	HTParentAnchor0 *,	parent)
d111 1
d119 1
a119 2
PRIVATE HTChildAnchor * HText_pool_ChildAnchor_new ARGS1(
	HTParentAnchor *,	parent)
d121 3
a123 2
    HTChildAnchor *p = (HTChildAnchor *)HText_pool_calloc((HText*)(parent->document),
						sizeof(HTChildAnchor));
d140 10
a149 11
**	---------------------------------
** On entry,
**	s	Points to one string, null terminated
**	t	points to the other.
** On exit,
**	returns YES if the strings are equivalent
**		NO if they differ.
*/
PRIVATE BOOL HTSEquivalent ARGS2(
	CONST char *,	s,
	CONST char *,	t)
d151 1
a151 1
    if (s && t) {  /* Make sure they point to something */
d154 1
a154 1
		return(NO);
d157 1
a157 1
	return(HT_EQUIV(*s, *t));
d159 1
a159 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
d164 10
a173 11
**	------------------------
** On entry,
**	s	Points to one bstring
**	t	points to the other.
** On exit,
**	returns YES if the strings are equivalent
**		NO if they differ.
*/
PRIVATE BOOL HTBEquivalent ARGS2(
	CONST bstring *,	s,
	CONST bstring *,	t)
d178 1
d181 1
a181 1
		return(NO);
d184 1
a184 1
	return(YES);
d186 1
a186 1
	return(s == t);		/* Two NULLs are equivalent, aren't they ? */
d191 1
a191 1
 *  Three-way compare function
d193 2
a194 3
PRIVATE int compare_anchors ARGS2(
	void *, l,
	void *, r)
d196 3
a198 2
    CONST char* a = ((HTChildAnchor *)l)->tag;
    CONST char* b = ((HTChildAnchor *)r)->tag;
d202 1
a202 1
	return strcasecomp(a, b); /* Case insensitive */
d204 1
a204 1
	return strcmp(a, b);      /* Case sensitive - FM */
a207 1

d209 7
a215 8
**	---------------------------------
**
**	This one is for a named child.
**	The parent anchor must already exist.
*/
PRIVATE HTChildAnchor * HTAnchor_findNamedChild ARGS2(
	HTParentAnchor0 *,	parent,
	CONST char *,		tag)
d219 1
a219 1
    if (parent && tag && *tag) {  /* TBL */
d222 2
a223 2
	    **  Parent has children.  Search them.
	    */
a224 1
	    sample.tag = (char*)tag;    /* for compare_anchors() only */
d226 3
a228 1
	    child = (HTChildAnchor *)HTBTree_search(parent->children, &sample);
d230 4
a233 3
		CTRACE((tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag));
		return(child);
d235 1
a235 1
	} else {  /* parent doesn't have any children yet : create family */
d241 1
a241 1
		(void *)child,
d243 1
a243 1
		(void *)child->parent));
d245 1
a245 1
	StrAllocCopy(child->tag, tag);   /* should be set before HTBTree_add */
d247 1
a247 1
	return(child);
d251 1
a251 1
	return(NULL);
d257 5
a261 6
**	This one is for a new unnamed child being edited into an existing
**	document.  The parent anchor and the document must already exist.
**	(Just add new unnamed child).
*/
PRIVATE HTChildAnchor * HTAnchor_addChild ARGS1(
	HTParentAnchor *,	parent)
d267 1
a267 1
	return(NULL);
d272 2
a273 2
		(void *)child,
		(void *)child->parent));
d278 1
a278 1
    return(child);
d281 1
d283 3
a285 7
PRIVATE HTParentAnchor0 * HTAnchor_findAddress_in_adult_table PARAMS((
	CONST DocAddress *	newdoc));

PRIVATE BOOL HTAnchor_link PARAMS((
	HTChildAnchor *		child,
	HTAnchor *		destination,
	HTLinkType *		type));
d287 13
d301 4
a304 18
/*	Create or find a child anchor with a possible link
**	--------------------------------------------------
**
**	Create new anchor with a given parent and possibly
**	a name, and possibly a link to a _relatively_ named anchor.
**	(Code originally in ParseHTML.h)
*/
PUBLIC HTChildAnchor * HTAnchor_findChildAndLink ARGS4(
	HTParentAnchor *,	parent, /* May not be 0   */
	CONST char *,		tag,	/* May be "" or 0 */
	CONST char *,		href,	/* May be "" or 0 */
	HTLinkType *,		ltype)	/* May be 0	  */
{
    HTChildAnchor * child;
    CTRACE((tfp,"Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n",
	       NonNull(tag),
	       (ltype == HTInternalLink) ? " (internal link)" : "",
	       NonNull(href) ));
d313 2
a314 2
	CONST char *fragment = NULL;
	HTParentAnchor0 * dest;
d319 3
a321 2
	    CONST char *relative_to = (parent->inBASE && *href != '#') ?
				parent->content_base : parent->address;
d323 1
d345 5
a349 5
	** [from HTAnchor_findAddress()]
	** If the address represents a sub-anchor, we load its parent (above),
	** then we create a named child anchor within that parent.
	*/
	fragment = (*href == '#') ?  href+1 : HTParseAnchor(href);
d352 1
a352 2
	    dest = (HTParentAnchor0 *)HTAnchor_findNamedChild(dest, fragment);

d355 1
a355 1
	    if (child->dest) { /* DUPLICATE_ANCHOR_NAME_WORKAROUND  - kw */
d357 3
a359 3
			   "*** Duplicate ChildAnchor %p named `%s'",
			   child, tag));
		if ((HTAnchor *)dest != child->dest || ltype != child->type) {
d361 2
a362 2
			   ", different dest %p or type, creating unnamed child\n",
			   child->dest));
d367 1
a367 1
	HTAnchor_link(child, (HTAnchor *)dest, ltype);
a371 1

d373 8
a380 9
**	------------------------------------
**
**	Me one is for a reference which is found in a document, and might
**	not be already loaded.
**	Note: You are not guaranteed a new anchor -- you might get an old one,
**	like with fonts.
*/
PUBLIC HTParentAnchor * HTAnchor_findAddress ARGS1(
	CONST DocAddress *,	newdoc)
d383 1
a383 1
    CONST char *tag = HTParseAnchor(newdoc->address);
d385 1
a385 1
    CTRACE((tfp,"Entered HTAnchor_findAddress\n"));
d388 3
a390 3
    **	If the address represents a sub-anchor, we load its parent,
    **	then we create a named child anchor within that parent.
    */
d393 2
a394 2
	HTParentAnchor0 * foundParent;
	HTChildAnchor * foundAnchor;
d405 1
a405 1
	foundAnchor = HTAnchor_findNamedChild (foundParent, tag);
d407 1
a407 1
	return HTAnchor_parent((HTAnchor *)foundParent);
d409 1
a409 1
    return HTAnchor_parent((HTAnchor *)HTAnchor_findAddress_in_adult_table(newdoc));
a411 1

d414 1
a414 2
PRIVATE HTParentAnchor0 * HTAnchor_findAddress_in_adult_table ARGS1(
	CONST DocAddress *,	newdoc)
d417 2
a418 2
    **  Check whether we have this node.
    */
d420 1
a420 1
    HTList * adults;
d422 1
a422 1
    HTParentAnchor0 * foundAnchor;
d424 1
a424 1
		newdoc->bookmark || newdoc->isHEAD || newdoc->safe);
d427 3
a429 3
     *  We need not free adult_table[] atexit -
     *  it should be perfectly empty after free'ing all HText's.
     *  (There is an error if it is not empty at exit). -LP
d433 2
a434 2
    **  Select list from hash table,
    */
d439 2
a440 2
    **  Search list for anchor.
    */
d443 1
a443 1
		    (HTParentAnchor0 *)HTList_nextObject(grownups))) {
d449 1
a449 2
	      foundAnchor->info->isHEAD == newdoc->isHEAD)))
	{
d451 1
a451 1
			(void *)foundAnchor, newdoc->address));
d457 2
a458 2
    **  Node not found: create new anchor.
    */
d461 1
a461 1
		(void *)foundAnchor, hash, newdoc->address));
d471 1
a471 1
		     newdoc->post_content_type);
d483 6
a488 7
**	-------------------------------------------------
**
**     Like HTAnchor_findAddress, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
PUBLIC HTParentAnchor * HTAnchor_findSimpleAddress ARGS1(
	CONST char *,	url)
d492 1
a492 1
    urldoc.address = (char *)url; /* ignore warning, it IS treated like const - kw */
a500 1

d502 5
a506 6
**	-------------------------------------
*/
PRIVATE BOOL HTAnchor_link ARGS3(
	HTChildAnchor *,	child,
	HTAnchor *,		destination,
	HTLinkType *,		type)
d509 1
a509 1
	return(NO);  /* Can't link to/from non-existing anchor */
d514 1
a514 1
	return(NO);
d524 1
a524 1
    return(YES);  /* Success */
a526 1

d528 8
a535 8
**	--------------------------------------------
**
**	The anchor is only deleted if the corresponding document is not loaded.
**	All outgoing links from children are deleted, and children are
**	removed from the sources lists of theirs targets.
**	We also try to delete the targets whose documents are not loaded.
**	If this anchor's sources list is empty, we delete it and its children.
*/
d542 1
a542 2
PRIVATE void deleteLinks ARGS1(
	HTChildAnchor *,	me)
d545 1
a545 1
     *	Unregister me with our destination anchor's parent.
d551 1
a551 1
	 *  Start.  Set the dest pointer to zero.
d553 1
a553 1
	 me->dest = NULL;
d556 2
a557 2
	 *  Remove me from the parent's sources so that the
	 *  parent knows one less anchor is its dest.
d561 1
a561 1
	     *	Really should only need to deregister once.
d563 1
a563 1
	    HTList_unlinkObject(&parent->sources, (void *)me);
d567 2
a568 3
	 *  Recursive call.
	 *  Test here to avoid calling overhead.
	 *  Don't delete if document is loaded or being loaded.
d576 3
a578 4
	 *  At this point, we haven't a destination.  Set it to be
	 *  so.
	 *  Leave the HTAtom pointed to by type up to other code to
	 *  handle (reusable, near static).
d584 1
d586 1
a586 5
PRIVATE void HTParentAnchor_free PARAMS((
	HTParentAnchor *	me));

PUBLIC BOOL HTAnchor_delete ARGS1(
	HTParentAnchor0 *,	me)
d589 1
a589 1
     *	Memory leaks fixed.
d596 1
a596 1
     *	Do nothing if nothing to do.
d599 1
a599 1
	return(NO);
d603 1
a603 1
     *	Don't delete if document is loaded or being loaded.
d606 1
a606 1
	return(NO);
d610 2
a611 2
     *  Mark ourselves busy, so that recursive calls of this function
     *  on this HTParentAnchor0 will not free it from under our feet. - kw
d617 2
a618 2
	 *  Delete all outgoing links from named children.
	 *  Do not delete named children itself (may have incoming links).
d623 1
a623 1
		child = (HTChildAnchor *)HTBTree_object(ele);
a631 1

d638 1
a638 1
	 *  Can't delete parent, still have sources.
d640 1
a640 1
	return(NO);
d644 2
a645 2
     *	No more incoming and outgoing links : kill everything
     *	First, delete named children.
d650 1
a650 1
	    child = (HTChildAnchor *)HTBTree_object(ele);
d659 1
a659 1
     *  Delete the ParentAnchor, if any. (Document was already deleted).
d667 1
a667 1
     *	Remove ourselves from the hash table's list.
d669 1
a669 1
    HTList_unlinkObject(&(adult_table[me->adult_hash]), (void *)me);
d672 1
a672 1
     *	Free the address.
d677 1
a677 1
     *	Finally, kill the parent anchor passed in.
d681 1
a681 1
    return(YES);
d685 3
a687 3
 *  Unnamed children (children_notag) have no sence without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists. Called within HText_free().
d689 1
a689 2
PUBLIC void HTAnchor_delete_links ARGS1(
	HTParentAnchor *,	me)
d695 1
a695 1
     *	Do nothing if nothing to do.
d702 2
a703 2
     *  Mark ourselves busy, so that recursive calls
     *  on this HTParentAnchor0 will not free it from under our feet. - kw
d708 1
a708 1
     *  Delete all outgoing links from unnamed children.
d713 1
a713 1
		(HTChildAnchor *)HTList_unlinkLastObject(cur)) != 0) {
d715 1
a715 1
	    /* child allocated in HText pool, HText_free() will free it later*/
d721 1
a721 3

PRIVATE void HTParentAnchor_free ARGS1(
	HTParentAnchor *,	me)
d724 1
a724 1
     *	Delete the methods list.
d728 2
a729 2
	 *  Leave what the methods point to up in memory for
	 *  other code (near static stuff).
d736 1
a736 1
     *	Free up all allocated members.
d754 1
d763 4
d787 4
a790 4
     *	Original code wanted a way to clean out the HTFormat if no
     *	longer needed (ref count?).  I'll leave it alone since
     *	those HTAtom objects are a little harder to know where
     *	they are being referenced all at one time. (near static)
d798 1
a798 2
PUBLIC void HTAnchor_clearSourceCache ARGS1(
	HTParentAnchor *,	me)
d805 1
a805 1
	       me->source_cache_file));
d811 1
a811 1
	       (void *)me->source_cache_chunk));
d819 3
a821 4
**	---------------------
*/
PUBLIC HTParentAnchor * HTAnchor_parent ARGS1(
	HTAnchor *,	me)
d833 2
a834 3
PUBLIC void HTAnchor_setDocument ARGS2(
	HTParentAnchor *,	me,
	HyperDoc *,		doc)
d840 1
a840 2
PUBLIC HyperDoc * HTAnchor_document ARGS1(
	HTParentAnchor *,	me)
d842 1
a842 1
    return( me ? me->document : NULL);
d845 1
a845 3

PUBLIC char * HTAnchor_address ARGS1(
	HTAnchor *,	me)
d850 3
a852 3
	if (((HTParentAnchor0 *)me == me->parent) ||
	    ((HTParentAnchor *)me == me->parent->info) ||
	    !((HTChildAnchor *)me)->tag) {  /* it's an adult or no tag */
d854 1
a854 1
	} else {  /* it's a named child */
d856 1
a856 1
		       me->parent->address, ((HTChildAnchor *)me)->tag);
d859 1
a859 1
    return(addr);
d862 2
a863 3
PUBLIC void HTAnchor_setFormat ARGS2(
	HTParentAnchor *,	me,
	HTFormat,		form)
d869 1
a869 2
PUBLIC HTFormat HTAnchor_format ARGS1(
	HTParentAnchor *,	me)
d871 1
a871 1
    return( me ? me->format : NULL);
d874 2
a875 3
PUBLIC void HTAnchor_setIndex ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		address)
d883 2
a884 3
PUBLIC void HTAnchor_setPrompt ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		prompt)
d891 1
a891 2
PUBLIC BOOL HTAnchor_isIndex ARGS1(
	HTParentAnchor *,	me)
d893 1
a893 1
    return( me ? me->isIndex : NO);
d897 3
a899 4
**	(normally by presence of an ISMAP attribute on A or IMG) - KW
*/
PUBLIC BOOL HTAnchor_isISMAPScript ARGS1(
	HTAnchor *,	me)
d901 1
a901 1
    return( (me && me->parent->info) ? me->parent->info->isISMAPScript : NO);
d907 1
a907 2
PUBLIC CONST char * HTAnchor_style ARGS1(
	HTParentAnchor *,	me)
d909 1
a909 1
	return( me ? me->style : NULL);
d912 2
a913 3
PUBLIC void HTAnchor_setStyle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		style)
a920 1

d923 1
a923 2
PUBLIC CONST char * HTAnchor_title ARGS1(
	HTParentAnchor *,	me)
d925 1
a925 1
    return( me ? me->title : NULL);
d928 2
a929 3
PUBLIC void HTAnchor_setTitle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		title)
d943 1
a943 1
	    CTRACE((tfp,"HTAnchor_setTitle: New title is NULL! "));
d945 1
a945 1
		CTRACE((tfp,"Old title was \"%s\".\n", me->title));
d948 1
a948 1
		CTRACE((tfp,"Old title was NULL.\n"));
d954 2
a955 3
PUBLIC void HTAnchor_appendTitle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		title)
d972 1
a972 2
PUBLIC CONST char * HTAnchor_bookmark ARGS1(
	HTParentAnchor *,	me)
d974 1
a974 1
    return( me ? me->bookmark : NULL);
d977 2
a978 3
PUBLIC void HTAnchor_setBookmark ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		bookmark)
d986 1
a986 2
PUBLIC CONST char * HTAnchor_owner ARGS1(
	HTParentAnchor *,	me)
d988 1
a988 1
    return( me ? me->owner : NULL);
d991 2
a992 3
PUBLIC void HTAnchor_setOwner ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		owner)
d1001 1
a1001 2
PUBLIC CONST char * HTAnchor_RevTitle ARGS1(
	HTParentAnchor *,	me)
d1003 1
a1003 1
    return( me ? me->RevTitle : NULL);
d1006 2
a1007 3
PUBLIC void HTAnchor_setRevTitle ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		title)
d1025 1
a1025 2
PUBLIC CONST char * HTAnchor_citehost ARGS1(
	HTParentAnchor *,	me)
d1027 1
a1027 1
    return( me ? me->citehost : NULL);
d1030 2
a1031 3
PUBLIC void HTAnchor_setCitehost ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		citehost)
d1040 18
a1057 2
**	(will be loaded if we had a Content-Disposition
**	 header or META element with filename=name.suffix)
d1059 1
a1059 2
PUBLIC CONST char * HTAnchor_SugFname ARGS1(
	HTParentAnchor *,	me)
d1061 1
a1061 1
    return( me ? me->SugFname : NULL);
d1065 4
a1068 5
**	(will be loaded if we had a Content-Encoding
**	 header.)
*/
PUBLIC CONST char * HTAnchor_content_encoding ARGS1(
	HTParentAnchor *,	me)
d1070 1
a1070 1
    return( me ? me->content_encoding : NULL);
d1075 1
a1075 2
PUBLIC CONST char * HTAnchor_content_type ARGS1(
	HTParentAnchor *,	me)
d1077 1
a1077 1
    return( me ? me->content_type : NULL);
d1082 1
a1082 2
PUBLIC CONST char * HTAnchor_last_modified ARGS1(
	HTParentAnchor *,	me)
d1084 1
a1084 1
    return( me ? me->last_modified : NULL);
d1089 1
a1089 2
PUBLIC CONST char * HTAnchor_date ARGS1(
	HTParentAnchor *,	me)
d1091 1
a1091 1
    return( me ? me->date : NULL);
d1096 1
a1096 2
PUBLIC CONST char * HTAnchor_server ARGS1(
	HTParentAnchor *,	me)
d1098 1
a1098 1
    return( me ? me->server : NULL);
d1103 1
a1103 2
PUBLIC BOOL HTAnchor_safe ARGS1(
	HTParentAnchor *,	me)
d1105 1
a1105 1
    return (BOOL) ( me ? me->safe : FALSE);
d1110 1
a1110 2
PUBLIC CONST char * HTAnchor_content_base ARGS1(
	HTParentAnchor *,	me)
d1112 1
a1112 1
    return( me ? me->content_base : NULL);
d1117 1
a1117 2
PUBLIC CONST char * HTAnchor_content_location ARGS1(
	HTParentAnchor *,	me)
d1119 1
a1119 1
    return( me ? me->content_location : NULL);
d1124 1
a1124 2
PUBLIC CONST char * HTAnchor_messageID ARGS1(
	HTParentAnchor *,	me)
d1126 1
a1126 1
    return( me ? me->message_id : NULL);
d1129 2
a1130 3
PUBLIC BOOL HTAnchor_setMessageID ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		messageid)
d1141 1
a1141 2
PUBLIC CONST char * HTAnchor_subject ARGS1(
	HTParentAnchor *,	me)
d1143 1
a1143 1
    return( me ? me->subject : NULL);
d1146 2
a1147 3
PUBLIC BOOL HTAnchor_setSubject ARGS2(
	HTParentAnchor *,	me,
	CONST char *,		subject)
d1157 3
a1159 4
**	---------------------
*/
PUBLIC HTAnchor * HTAnchor_followLink ARGS1(
	HTChildAnchor *,	me)
d1161 1
a1161 1
    return( me->dest);
d1164 2
a1165 3
PUBLIC HTAnchor * HTAnchor_followTypedLink ARGS2(
	HTChildAnchor *,	me,
	HTLinkType *,		type)
d1168 2
a1169 2
	return( me->dest);
    return(NULL);  /* No link of me type */
a1171 1

d1173 3
a1175 4
**	------------
*/
PUBLIC HTList * HTAnchor_methods ARGS1(
	HTParentAnchor *,	me)
d1180 1
a1180 1
    return( me->methods);
d1184 3
a1186 4
**	--------
*/
PUBLIC void * HTAnchor_protocol ARGS1(
	HTParentAnchor *,	me)
d1188 1
a1188 1
    return( me->protocol);
d1191 2
a1192 3
PUBLIC void HTAnchor_setProtocol ARGS2(
	HTParentAnchor *,	me,
	void*,			protocol)
d1198 3
a1200 4
**	----------------
*/
PUBLIC char * HTAnchor_physical ARGS1(
	HTParentAnchor *,	me)
d1202 1
a1202 1
    return( me->physical);
d1205 2
a1206 3
PUBLIC void HTAnchor_setPhysical ARGS2(
	HTParentAnchor *,	me,
	char *,			physical)
d1214 25
a1238 26
**  We store charset info in the HTParentAnchor object, for several
**  "stages".  (See UCDefs.h)
**  A stream method is supposed to know what stage in the model it is.
**
**  General model	MIME	 ->  parser  ->  structured  ->  HText
**  e.g., text/html
**	from HTTP:	HTMIME.c ->  SGML.c  ->  HTML.c      ->  GridText.c
**     text/plain
**	from file:	HTFile.c ->  HTPlain.c		     ->  GridText.c
**
**  The lock/set_by is used to lock e.g. a charset set by an explicit
**  HTTP MIME header against overriding by a HTML META tag - the MIME
**  header has higher priority.  Defaults (from -assume_.. options etc.)
**  will not override charset explicitly given by server.
**
**  Some advantages of keeping this in the HTAnchor:
**  - Global variables are bad.
**  - Can remember a charset given by META tag when toggling to SOURCE view.
**  - Can remember a charset given by <A CHARSET=...> href in another doc.
**
**  We don't modify the HTParentAnchor's charset element
**  here, that one will only be set when explicitly given.
*/
PUBLIC LYUCcharset * HTAnchor_getUCInfoStage ARGS2(
	HTParentAnchor *,	me,
	int,			which_stage)
d1242 3
a1244 2
	int chndl = UCLYhndl_for_unspec;  /* always >= 0 */
	UCAnchorInfo * stages = typecalloc(UCAnchorInfo);
d1257 4
a1260 4
		**  UCLYhndl_for_unrec not defined :-(
		**  fallback to UCLYhndl_for_unspec which always valid.
		*/
		chndl = UCLYhndl_for_unspec;  /* always >= 0 */
d1264 1
d1270 1
a1270 1
	return( &me->UCStages->s[which_stage].C);
d1272 1
a1272 1
    return(NULL);
d1275 2
a1276 3
PUBLIC int HTAnchor_getUCLYhndl ARGS2(
	HTParentAnchor *,	me,
	int,			which_stage)
d1281 1
a1281 1
	     *	This will allocate and initialize, if not yet done.
d1286 1
a1286 1
	    return( me->UCStages->s[which_stage].LYhndl);
d1289 1
a1289 1
    return( -1);
d1293 1
a1293 1
PRIVATE void setup_switch_display_charset ARGS2(HTParentAnchor *, me, int, h)
d1295 1
a1295 1
    if (!Switch_Display_Charset(h,SWITCH_DISPLAY_CHARSET_MAYBE))
d1298 1
a1298 1
			    UCT_STAGE_HTEXT, UCT_SETBY_MIME); /* highest priorty! */
d1300 3
a1302 2
			    UCT_STAGE_STRUCTURED, UCT_SETBY_MIME); /* highest priorty! */
    CTRACE((tfp, "changing UCInfoStage: HTEXT/STRUCTURED stages charset='%s'.\n",
d1307 4
a1310 5
PUBLIC LYUCcharset * HTAnchor_setUCInfoStage ARGS4(
	HTParentAnchor *,	me,
	int,			LYhndl,
	int,			which_stage,
	int,			set_by)
d1314 1
a1314 1
	 *  This will allocate and initialize, if not yet done.
d1316 2
a1317 1
	LYUCcharset * p = HTAnchor_getUCInfoStage(me, which_stage);
d1319 1
a1319 1
	 *  Can we override?
d1329 1
d1332 1
a1332 1
		if ( LYhndl != ohandle && which_stage == UCT_STAGE_PARSER )
d1335 1
a1335 2
	    }
	    else {
d1338 1
a1338 1
	    return(p);
d1341 1
a1341 1
    return(NULL);
d1344 4
a1347 5
PUBLIC LYUCcharset * HTAnchor_resetUCInfoStage ARGS4(
	HTParentAnchor *,	me,
	int,			LYhndl,
	int,			which_stage,
	int,			set_by)
d1352 1
a1352 1
	return(NULL);
d1361 1
a1361 1
    return( &me->UCStages->s[which_stage].C);
d1365 6
a1370 7
**  A set_by of (-1) means use the lock value from the from_stage.
*/
PUBLIC LYUCcharset * HTAnchor_copyUCInfoStage ARGS4(
	HTParentAnchor *,	me,
	int,			to_stage,
	int,			from_stage,
	int,			set_by)
d1374 1
a1374 1
	 *  This will allocate and initialize, if not yet done.
d1376 3
a1378 2
	LYUCcharset * p_from = HTAnchor_getUCInfoStage(me, from_stage);
	LYUCcharset * p_to = HTAnchor_getUCInfoStage(me, to_stage);
d1380 1
a1380 1
	 *  Can we override?
d1395 3
a1397 3
	    if ( me->UCStages->s[to_stage].LYhndl >= 0
		 && me->UCStages->s[to_stage].LYhndl != ohandle
		 && to_stage == UCT_STAGE_PARSER )
d1403 2
a1404 1
	    return(p_to);
d1407 1
a1407 1
    return(NULL);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d21 1
d25 1
d61 3
a63 1
PRIVATE HTList **adult_table = 0;  /* Point to table of lists of all parents */
d72 17
a88 1
PRIVATE HTParentAnchor * HTParentAnchor_new NOARGS
d93 5
a97 2
    newAnchor->parent = newAnchor;
    newAnchor->bookmark = NULL;		/* Bookmark filename. - FM */
a100 9
#ifdef SOURCE_CACHE
    newAnchor->source_cache_file = NULL;
    newAnchor->source_cache_chunk = NULL;
#endif
    newAnchor->FileCache = NULL;	/* Path to a disk-cached copy. - FM */
    newAnchor->SugFname = NULL;		/* Suggested filename. - FM */
    newAnchor->RevTitle = NULL;		/* TITLE for a LINK with REV. - FM */
    newAnchor->citehost = NULL;		/* LINK REL=citehost - RDC */
    newAnchor->cache_control = NULL;	/* Cache-Control. - FM */
d102 1
a102 7
    newAnchor->content_type = NULL;	/* Content-Type. - FM */
    newAnchor->content_language = NULL; /* Content-Language. - FM */
    newAnchor->content_encoding = NULL; /* Compression algorithm. - FM */
    newAnchor->content_base = NULL;	/* Content-Base. - FM */
    newAnchor->content_disposition = NULL; /* Content-Disposition. - FM */
    newAnchor->content_location = NULL; /* Content-Location. - FM */
    newAnchor->content_md5 = NULL;	/* Content-MD5. - FM */
a103 5
    newAnchor->date = NULL;		/* Date. - FM */
    newAnchor->expires = NULL;		/* Expires. - FM */
    newAnchor->last_modified = NULL;	/* Last-Modified. - FM */
    newAnchor->ETag = NULL;		/* ETag (HTTP/1.1 cache validator) */
    newAnchor->server = NULL;		/* Server. - FM */
d107 2
a108 1
PRIVATE HTChildAnchor * HTChildAnchor_new NOARGS
d110 1
a110 3
    HTChildAnchor *p;

    p = typecalloc(HTChildAnchor);
d113 2
d118 11
d131 9
a139 2
/*	Case insensitive string comparison
**	----------------------------------
d144 2
a145 2
**	returns YES if the strings are equivalent ignoring case
**		NO if they differ in more than	their case.
d147 1
a147 1
PRIVATE BOOL HTEquivalent ARGS2(
d153 1
a153 1
	    if (TOUPPER(*s) != TOUPPER(*t)) {
d157 1
a157 1
	return( TOUPPER(*s) == TOUPPER(*t));
d163 2
a164 4
#else

/*	Case sensitive string comparison
**	----------------------------------
d166 1
a166 1
**	s	Points to one string, null terminated
d169 1
a169 1
**	returns YES if the strings are identical or both NULL
d172 9
a180 13
PRIVATE BOOL HTIdentical ARGS2(
	CONST char *,	s,
	CONST char *,	t)
{
    if (s && t) {  /* Make sure they point to something */
#ifdef SH_EX	/* 1998/04/28 (Tue) 22:02:58 */
	if (*s == 'P' || *t == 'P') {
	    if (strcmp(s + 1, "Name") == 0 || strcmp(t + 1, "Name") == 0)
		return NO;
	}
#endif
	for (; *s && *t; s++, t++) {
	    if (*s != *t) {
d184 1
a184 1
	return (BOOL) (*s == *t);
d186 1
a186 1
	return (BOOL) (s == t);  /* Two NULLs are identical, aren't they ? */
d189 16
d206 1
d212 2
a213 2
**	Me one is for a new anchor being edited into an existing
**	document.  The parent anchor must already exist.
d215 2
a216 2
PUBLIC HTChildAnchor * HTAnchor_findChild ARGS2(
	HTParentAnchor *,	parent,
d220 45
a264 1
    HTList *kids;
d267 1
a267 1
	CTRACE((tfp, "HTAnchor_findChild called with NULL parent.\n"));
a269 21
    if ((kids = parent->children) != 0) {
	/*
	**  Parent has children.  Search them.
	*/
	if (tag && *tag) {		/* TBL */
	    while (NULL != (child=(HTChildAnchor *)HTList_nextObject(kids))) {
#ifdef CASE_INSENSITIVE_ANCHORS
		if (HTEquivalent(child->tag, tag)) /* Case insensitive */
#else
		if (HTIdentical(child->tag, tag)) /* Case sensitive - FM */
#endif /* CASE_INSENSITIVE_ANCHORS */
		{
		    CTRACE((tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag));
		    return(child);
		}
	    }
	}  /*  end if tag is void */
    } else {  /* parent doesn't have any children yet : create family */
	parent->children = HTList_new();
    }
d271 2
a272 2
    child = HTChildAnchor_new();
    CTRACE((tfp, "HTAnchor: New Anchor %p named `%s' is child of %p\n",
d274 5
a278 5
		tag ? tag : (CONST char *)"",
		(void *)parent)); /* int for apollo */
    HTList_addObject (parent->children, child);
    child->parent = parent;
    StrAllocCopy(child->tag, tag);
d283 9
d305 5
a309 1
    HTChildAnchor * child = HTAnchor_findChild(parent, tag);
d311 5
a315 1
    CTRACE((tfp,"Entered HTAnchor_findChildAndLink\n"));
d318 11
a328 3
	char *relative_to = HTAnchor_address((HTAnchor *)parent);
	DocAddress parsed_doc;
	HTAnchor * dest;
a329 10
	parsed_doc.address = HTParse(href, relative_to, PARSE_ALL);
#ifndef DONT_TRACK_INTERNAL_LINKS
	if (ltype && parent->post_data && ltype == LINK_INTERNAL) {
	    /* for internal links, find a destination with the same
	       post data if the source of the link has post data. - kw */
	    parsed_doc.post_data = parent->post_data;
	    parsed_doc.post_content_type = parent->post_content_type;
	} else
#endif
	{
d332 13
a345 4
	parsed_doc.bookmark = NULL;
	parsed_doc.isHEAD = FALSE;
	parsed_doc.safe = FALSE;
	dest = HTAnchor_findAddress(&parsed_doc);
d347 10
a356 1
#define DUPLICATE_ANCHOR_NAME_WORKAROUND
a357 1
#ifdef DUPLICATE_ANCHOR_NAME_WORKAROUND
d359 1
a359 5
	    HTAnchor *testdest1;
	    int nlinks;
	    testdest1 = child->mainLink.dest;
	    if (testdest1) {
		nlinks = 1 + HTList_count(child->links);
d361 7
a367 9
		       "*** Duplicate ChildAnchor %p named `%s' with %d links",
		       child, tag, nlinks));
		if (dest == testdest1 && ltype == child->mainLink.type) {
		    CTRACE((tfp,", same dest %p and type, keeping it\n",
			   testdest1));
		} else {
		    CTRACE((tfp,", different dest %p, creating unnamed child\n",
			   testdest1));
		    child = HTAnchor_findChild(parent, 0);
d371 1
a371 4
#endif
	HTAnchor_link((HTAnchor *)child, dest, ltype);
	FREE(parsed_doc.address);
	FREE(relative_to);
d373 1
a373 1
    return(child);
a375 38
#ifdef LY_FIND_LEAKS
/*
**  Function for freeing the adult hash table. - FM
*/
PRIVATE void free_adult_table NOARGS
{
    int i_counter;
    HTList * HTAp_freeme;
    HTParentAnchor * parent;
    /*
     *	Loop through all lists.
     */
    for (i_counter = 0; i_counter < HASH_SIZE; i_counter++) {
	/*
	**  Loop through the list.
	*/
	while (adult_table[i_counter] != NULL) {
	    /*
	    **	Free off items - FM
	    */
	    HTAp_freeme = adult_table[i_counter];
	    adult_table[i_counter] = HTAp_freeme->next;
	    if (HTAp_freeme->object) {
		parent = (HTParentAnchor *)HTAp_freeme->object;
		CTRACE((tfp, "delete anchor:%d/%d,%d,%d %s\n",
		       i_counter, HTList_count(HTAp_freeme) + 1,
		       (parent->physical ? 1 : 0),
		       (int)parent->underway,
		       (parent->address ? parent->address : "(no address)")));
		parent->underway = FALSE;
		HTAnchor_delete(parent);
	    }
	    FREE(HTAp_freeme);
	}
    }
    FREE(adult_table);
}
#endif /* LY_FIND_LEAKS */
d377 2
a378 2
/*	Create new or find old named anchor
**	-----------------------------------
d385 1
a385 1
PUBLIC HTAnchor * HTAnchor_findAddress ARGS1(
d389 1
a389 1
    char *tag = HTParse(newdoc->address, "", PARSE_ANCHOR);
d394 2
a395 2
    **	If the address represents a sub-anchor, we recursively load its
    **	parent, then we create a child anchor within that document.
d399 1
a399 1
	HTParentAnchor * foundParent;
d403 1
a403 1
		PARSE_ACCESS | PARSE_HOST | PARSE_PATH | PARSE_PUNCTUATION);
d410 2
a411 2
	foundParent = (HTParentAnchor *)HTAnchor_findAddress(&parsed_doc);
	foundAnchor = HTAnchor_findChild (foundParent, tag);
d413 26
a438 11
	FREE(tag);
	return (HTAnchor *)foundAnchor;
    } else {
	/*
	**  If the address has no anchor tag,
	**  check whether we have this node.
	*/
	int hash;
	HTList * adults;
	HTList *grownups;
	HTParentAnchor * foundAnchor;
d440 5
a444 1
	FREE(tag);
d446 16
a461 11
	/*
	**  Select list from hash table,
	*/
	hash = HASH_FUNCTION(newdoc->address);
	if (!adult_table) {
	    adult_table = typecallocn(HTList *, HASH_SIZE);
	    if (!adult_table)
		outofmem(__FILE__, "HTAnchor_findAddress");
#ifdef LY_FIND_LEAKS
	    atexit(free_adult_table);
#endif
d463 1
a463 3
	if (!adult_table[hash])
	    adult_table[hash] = HTList_new();
	adults = adult_table[hash];
d465 10
a474 21
	/*
	**  Search list for anchor.
	*/
	grownups = adults;
	while (NULL != (foundAnchor =
			(HTParentAnchor *)HTList_nextObject(grownups))) {
#ifdef CASE_INSENSITIVE_ANCHORS
	    if (HTEquivalent(foundAnchor->address, newdoc->address) &&
		HTEquivalent(foundAnchor->post_data, newdoc->post_data) &&
		foundAnchor->isHEAD == newdoc->isHEAD)
#else
	    if (HTIdentical(foundAnchor->address, newdoc->address) &&
		HTIdentical(foundAnchor->post_data, newdoc->post_data) &&
		foundAnchor->isHEAD == newdoc->isHEAD)
#endif /* CASE_INSENSITIVE_ANCHORS */
	    {
		CTRACE((tfp, "Anchor %p with address `%s' already exists.\n",
			    (void *)foundAnchor, newdoc->address));
		 return (HTAnchor *)foundAnchor;
	     }
	}
a475 7
	/*
	**  Node not found: create new anchor.
	*/
	foundAnchor = HTParentAnchor_new();
	CTRACE((tfp, "New anchor %p has hash %d and address `%s'\n",
		    (void *)foundAnchor, hash, newdoc->address));
	StrAllocCopy(foundAnchor->address, newdoc->address);
d477 1
a477 1
	    StrAllocCopy(foundAnchor->post_data, newdoc->post_data);
d479 2
a480 2
	    StrAllocCopy(foundAnchor->post_content_type,
			 newdoc->post_content_type);
d482 3
a484 5
	    StrAllocCopy(foundAnchor->bookmark, newdoc->bookmark);
	foundAnchor->isHEAD = newdoc->isHEAD;
	foundAnchor->safe = newdoc->safe;
	HTList_addObject (adults, foundAnchor);
	return (HTAnchor *)foundAnchor;
d486 3
d490 1
d494 1
a494 1
**	Like the previous one, but simpler to use for simple cases.
d497 1
a497 1
PUBLIC HTAnchor * HTAnchor_findSimpleAddress ARGS1(
d511 29
d544 2
a545 2
**	All outgoing links from parent and children are deleted, and this anchor
**	is removed from the sources list of all its targets.
d547 1
a547 1
**	If this anchor's source list is empty, we delete it and its children.
d549 6
d556 1
a556 1
	HTAnchor *,	me)
d559 1
a559 13
     *	Memory leaks fixed.
     *	05-27-94 Lynx 2-3-1 Garrett Arch Blythe
     */

    /*
     *	Anchor is NULL, do nothing.
     */
    if (!me) {
	return;
    }

    /*
     *	Unregister me with our mainLink destination anchor's parent.
d561 2
a562 2
    if (me->mainLink.dest) {
	HTParentAnchor *parent = me->mainLink.dest->parent;
d565 1
a565 4
	 *  Set the mainLink pointer to zero NOW.  If we don't,
	 *  and we get somehow called recursively again for this
	 *  same old me during the HTAnchor_delete below, weird
	 *  things can occasionally happen. - kw
d567 1
a567 1
	 me->mainLink.dest = NULL;
d571 1
a571 1
	 *  parent knows one less anchor is it's dest.
d573 1
a573 1
	if (!HTList_isEmpty(parent->sources)) {
d577 1
a577 1
	    HTList_removeObject(parent->sources, (void *)me);
d581 1
d583 1
a583 6
	 *  If the parent has no loaded document, then we should
	 *  tell it to attempt to delete itself.
	 *  Don't do this jazz if the anchor passed in is the same
	 *  as the anchor to delete.
	 *  Also, don't do this if the destination parent is our
	 *  parent.
d585 2
a586 3
	if (!parent->document &&
	    parent != (HTParentAnchor *)me &&
	    me->parent != parent) {
d591 1
a591 1
	 *  At this point, we haven't a mainLink.  Set it to be
d596 1
a596 1
	me->mainLink.type = NULL;
d598 1
a599 54
    /*
     *	Check for extra destinations in our links list.
     */
    if (!HTList_isEmpty(me->links)) {
	HTLink *target;
	HTParentAnchor *parent;

	/*
	 *  Take out our extra non mainLinks one by one, calling
	 *  their parents to know that they are no longer
	 *  the destination of me's anchor.
	 */
	while ((target = (HTLink *)HTList_removeLastObject(me->links)) != 0) {
	    parent = target->dest->parent;
	    if (!HTList_isEmpty(parent->sources)) {
		/*
		 *  Only need to tell destination parent
		 *  anchor once.
		 */
		HTList_removeObject(parent->sources, (void *)me);
	    }

	    /*
	     *	Avoid calling overhead.
	     *	If the parent hasn't a loaded document, then
	     *	   we will attempt to have the parent
	     *	   delete itself.
	     *	Don't call twice if this is the same anchor
	     *	   that we are trying to delete.
	     *	Also, don't do this if we are trying to delete
	     *	   our parent.
	     */
	    if (!parent->document &&
		(HTParentAnchor *)me != parent &&
		me->parent != parent) {
		HTAnchor_delete(parent);
	    }
	    /*
	     *	The link structure has to be deleted, too!
	     *	That was missing, but this code probably never
	     *	got exercised by Lynx.	- KW
	     */
	    FREE(target);
	}

	/*
	 *  At this point, me no longer has any destination in
	 *  the links list.  Get rid of it.
	 */
	if (me->links) {
	    HTList_delete(me->links);
	    me->links = NULL;
	}
    }
d601 2
a602 30
    /*
     *	Catch in case links list exists but nothing in it.
     */
    if (me->links) {
	HTList_delete(me->links);
	me->links = NULL;
    }
}

#ifdef SOURCE_CACHE
PUBLIC void HTAnchor_clearSourceCache ARGS1(
	HTParentAnchor *,	me)
{
    /*
     * Clean up the source cache, if any.
     */
    if (me->source_cache_file) {
	CTRACE((tfp, "SourceCache: Removing file %s\n",
	       me->source_cache_file));
	LYRemoveTemp(me->source_cache_file);
	FREE(me->source_cache_file);
    }
    if (me->source_cache_chunk) {
	CTRACE((tfp, "SourceCache: Removing memory chunk %p\n",
	       (void *)me->source_cache_chunk));
	HTChunkFree(me->source_cache_chunk);
	me->source_cache_chunk = NULL;
    }
}
#endif /* SOURCE_CACHE */
d605 1
a605 1
	HTParentAnchor *,	me)
d611 1
a611 1
    HTList *cur;
d624 1
a624 1
    if (me->document || me->underway) {
d630 1
a630 1
     *  on this HTParentAnchor will not free it from under our feet. - kw
d634 1
a634 14
    /*
     *	Recursively try to delete destination anchors of this parent.
     *	In any event, this will tell all destination anchors that we
     *	no longer consider them a destination.
     */
    deleteLinks((HTAnchor *)me);

    /*
     *	There are still incoming links to this one (we are the
     *	destination of another anchor).
     *	Don't actually delete this anchor, but children are OK to
     *	delete their links.
     */
    if (!HTList_isEmpty(me->sources)) {
d636 2
a637 2
	 *  Delete all outgoing links from children, do not
	 *  delete the children, though.
d639 7
a645 6
	if (!HTList_isEmpty(me->children)) {
	    cur = me->children;
	    while ((child = (HTChildAnchor *)HTList_nextObject(cur)) != 0) {
		if (child != NULL) {
		    deleteLinks((HTAnchor *)child);
		}
d648 3
a650 1
	me->underway = FALSE;
d652 5
d664 2
a665 2
     *	No more incoming links : kill everything
     *	First, recursively delete children and their links.
d667 7
a673 10
    if (!HTList_isEmpty(me->children)) {
	while ((child = (HTChildAnchor *)HTList_removeLastObject(
							me->children)) != 0) {
	    if (child) {
		deleteLinks((HTAnchor *)child);
		if (child->tag) {
		    FREE(child->tag);
		}
		FREE(child);
	    }
d675 1
a676 1
    me->underway = FALSE;
d679 38
a716 1
     *	Delete our empty list of children.
d718 2
a719 3
    if (me->children) {
	HTList_delete(me->children);
	me->children = NULL;
d723 7
a729 1
     * Delete our empty list of sources.
d731 7
a737 3
    if (me->sources) {
	HTList_delete(me->sources);
	me->sources = NULL;
d739 3
d743 3
d766 1
a766 1
    FREE(me->post_data);
d772 1
a772 1
#ifdef SOURCE_CACHE
d796 1
a804 11
     *	Remove ourselves from the hash table's list.
     */
    if (adult_table) {
	unsigned short usi_hash = (unsigned short) HASH_FUNCTION(me->address);

	if (adult_table[usi_hash])  {
	    HTList_removeObject(adult_table[usi_hash], (void *)me);
	}
    }

    /*
d811 1
a811 6
    /*
     *	Free the address.
     */
    FREE(me->address);

    FREE (me->UCStages);
d813 1
d815 4
a818 1

d820 1
a820 1
     *	Finally, kill the parent anchor passed in.
d822 11
a832 19
    FREE(me);

    return(YES);
}


/*		Move an anchor to the head of the list of its siblings
**		------------------------------------------------------
**
**	This is to ensure that an anchor which might have already existed
**	is put in the correct order as we load the document.
*/
PUBLIC void HTAnchor_makeLastChild ARGS1(
	HTChildAnchor *,	me)
{
    if (me->parent != (HTParentAnchor *)me) {  /* Make sure it's a child */
	HTList * siblings = me->parent->children;
	HTList_removeObject (siblings, me);
	HTList_addObject (siblings, me);
d835 1
d843 8
a850 1
    return( me ? me->parent : NULL);
d874 2
a875 1
	if (((HTParentAnchor *)me == me->parent) ||
d902 1
a902 1
	char *,			address)
d912 1
a912 1
	char *,			prompt)
d931 1
a931 7
    return( me ? me->parent->isISMAPScript : NO);
}

PUBLIC BOOL HTAnchor_hasChildren ARGS1(
	HTParentAnchor *,	me)
{
    return (BOOL) ( me ? ! HTList_isEmpty(me->children) : NO);
a1196 31
/*	Link me Anchor to another given one
**	-------------------------------------
*/
PUBLIC BOOL HTAnchor_link ARGS3(
	HTAnchor *,	source,
	HTAnchor *,	destination,
	HTLinkType *,	type)
{
    if (!(source && destination))
	return(NO);  /* Can't link to/from non-existing anchor */
    CTRACE((tfp, "Linking anchor %p to anchor %p\n", source, destination));
    if (!source->mainLink.dest) {
	source->mainLink.dest = destination;
	source->mainLink.type = type;
    } else {
	HTLink * newLink = typecalloc(HTLink);
	if (newLink == NULL)
	    outofmem(__FILE__, "HTAnchor_link");
	newLink->dest = destination;
	newLink->type = type;
	if (!source->links)
	    source->links = HTList_new();
	HTList_addObject (source->links, newLink);
    }
    if (!destination->parent->sources)
	destination->parent->sources = HTList_new();
    HTList_addObject (destination->parent->sources, source);
    return(YES);  /* Success */
}


d1200 2
a1201 2
PUBLIC HTAnchor * HTAnchor_followMainLink ARGS1(
	HTAnchor *,	me)
d1203 1
a1203 1
    return( me->mainLink.dest);
d1207 2
a1208 2
	HTAnchor *,	me,
	HTLinkType *,	type)
d1210 2
a1211 11
    if (me->mainLink.type == type)
	return( me->mainLink.dest);
    if (me->links) {
	HTList *links = me->links;
	HTLink *the_link;
	while (NULL != (the_link=(HTLink *)HTList_nextObject(links))) {
	    if (the_link->type == type) {
		return( the_link->dest);
	    }
	}
    }
a1212 27
}


/*	Make main link
*/
PUBLIC BOOL HTAnchor_makeMainLink ARGS2(
	HTAnchor *,	me,
	HTLink *,	movingLink)
{
    /* Check that everything's OK */
    if (!(me && HTList_removeObject (me->links, movingLink))) {
	return(NO);  /* link not found or NULL anchor */
    } else {
	/* First push current main link onto top of links list */
	HTLink *newLink = typecalloc(HTLink);
	if (newLink == NULL)
	    outofmem(__FILE__, "HTAnchor_makeMainLink");
	memcpy((void *)newLink,
	       (CONST char *)&me->mainLink, sizeof (HTLink));
	HTList_addObject (me->links, newLink);

	/* Now make movingLink the new main link, and free it */
	memcpy((void *)&me->mainLink,
	       (CONST void *)movingLink, sizeof (HTLink));
	FREE(movingLink);
	return(YES);
    }
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d24 1
d70 1
a70 2
    HTParentAnchor *newAnchor =
       (HTParentAnchor *)calloc(1, sizeof(HTParentAnchor));  /* zero-filled */
d74 1
a74 1
    newAnchor->bookmark = NULL; 	/* Bookmark filename. - FM */
d78 4
d83 3
a85 2
    newAnchor->SugFname = NULL; 	/* Suggested filename. - FM */
    newAnchor->RevTitle = NULL; 	/* TITLE for a LINK with REV. - FM */
d106 6
a111 1
    return (HTChildAnchor *)calloc(1, sizeof(HTChildAnchor)); /* zero-filled */
d137 1
a137 1
	return(s == t); 	/* Two NULLs are equivalent, aren't they ? */
d157 6
d168 1
a168 1
	return(*s == *t);
d170 1
a170 1
	return(s == t); 	/* Two NULLs are identical, aren't they ? */
d190 1
a190 1
	CTRACE(tfp, "HTAnchor_findChild called with NULL parent.\n");
d205 2
a206 2
		    CTRACE(tfp, "Child anchor %p of parent %p with name `%s' already exists.\n",
				(void *)child, (void *)parent, tag);
d216 1
a216 3
    if (child == NULL)
	outofmem(__FILE__, "HTChildAnchor_new");
    CTRACE(tfp, "new Anchor %p named `%s' is child of %p\n",
d219 1
a219 1
		(void *)parent); /* int for apollo */
d242 1
a242 1
    CTRACE(tfp,"Entered HTAnchor_findChildAndLink\n");
d276 1
a276 1
		CTRACE(tfp,
d278 1
a278 1
		       child, tag, nlinks);
d280 2
a281 2
		    CTRACE(tfp,", same dest %p and type, keeping it\n",
			   testdest1);
d283 2
a284 2
		    CTRACE(tfp,", different dest %p, creating unnamed child\n",
			   testdest1);
d321 1
a321 1
		CTRACE(tfp, "delete anchor:%d/%d,%d,%d %s\n",
d325 1
a325 1
		       (parent->address ? parent->address : "(no address)"));
d350 1
a350 1
    CTRACE(tfp,"Entered HTAnchor_findAddress\n");
d391 1
a391 1
	    adult_table = (HTList **)calloc(HASH_SIZE, sizeof(HTList *));
d418 2
a419 2
		CTRACE(tfp, "Anchor %p with address `%s' already exists.\n",
			    (void *)foundAnchor, newdoc->address);
d428 2
a429 2
	CTRACE(tfp, "New anchor %p has hash %d and address `%s'\n",
		    (void *)foundAnchor, hash, newdoc->address);
d444 10
d455 8
d601 22
d746 4
d774 1
a774 1
#ifdef USE_HASH
d782 1
a782 1
	unsigned short int usi_hash = HASH_FUNCTION(me->address);
d864 2
a865 7
	    addr = malloc(2 +
			  strlen(me->parent->address) +
			  strlen(((HTChildAnchor *)me)->tag));
	    if (addr == NULL)
		outofmem(__FILE__, "HTAnchor_address");
	    sprintf(addr, "%s#%s",
			   me->parent->address, ((HTChildAnchor *)me)->tag);
d887 1
a887 1
	char *, 		address)
d897 1
a897 1
	char *, 		prompt)
d922 1
a922 1
    return( me ? ! HTList_isEmpty(me->children) : NO);
d925 1
a925 1
#if defined(USE_HASH)
d963 2
a964 2
		if ((unsigned char)me->title[i] == 1 ||
		    (unsigned char)me->title[i] == 2) {
d969 1
a969 1
	    CTRACE(tfp,"HTAnchor_setTitle: New title is NULL! ");
d971 1
a971 1
		CTRACE(tfp,"Old title was \"%s\".\n", me->title);
d974 1
a974 1
		CTRACE(tfp,"Old title was NULL.\n");
d989 2
a990 2
	    if ((unsigned char)me->title[i] == 1 ||
		(unsigned char)me->title[i] == 2) {
d1047 2
a1048 2
	    if ((unsigned char)me->RevTitle[i] == 1 ||
		(unsigned char)me->RevTitle[i] == 2) {
d1055 19
d1131 1
a1131 1
    return( me ? me->safe : FALSE);
d1198 1
a1198 1
    CTRACE(tfp, "Linking anchor %p to anchor %p\n", source, destination);
d1203 1
a1203 1
	HTLink * newLink = (HTLink *)calloc (1, sizeof (HTLink));
d1258 1
a1258 1
	HTLink *newLink = (HTLink *)calloc (1, sizeof (HTLink));
d1313 1
a1313 1
	char *, 		physical)
d1351 1
a1351 2
	UCAnchorInfo * stages = (UCAnchorInfo*)calloc(1,
						      sizeof(UCAnchorInfo));
d1399 14
d1428 3
d1435 5
d1456 2
d1461 1
d1463 5
d1494 3
d1500 8
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
**	24-Oct-1991 (JFG), written in C, browser-independant
d16 1
a16 1
#define HASH_SIZE 101		/* Arbitrary prime. Memory/speed tradeoff */
d18 5
a22 7
#include "HTUtils.h"
#include "tcp.h"
#include <ctype.h>
#include "HTAnchor.h"
#include "HTParse.h"
#include "UCAux.h"
#include "UCMap.h"
d24 2
a25 4
#include "LYCharSets.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d43 1
a43 1
    unsigned char *p;
d45 2
a46 2
    for (p = (unsigned char *)cp_address, hash = 0; *p; p++)
	hash = (int) (hash * 3 + (*(unsigned char *)p)) % HASH_SIZE;
d48 1
a48 1
    return hash;
d63 1
a63 1
**	Do not use "new" by itself outside this module. In order to enforce
d71 2
d85 1
a85 1
    newAnchor->content_encoding = NULL; /* Compression algorith. - FM */
d94 1
d96 1
a96 1
    return newAnchor;
d122 1
a122 1
		return NO;
d125 1
a125 1
	return TOUPPER(*s) == TOUPPER(*t);
d127 1
a127 1
	return s == t;	/* Two NULLs are equivalent, aren't they ? */
d149 1
a149 1
		return NO;
d152 1
a152 1
	return *s == *t;
d154 1
a154 1
	return s == t;	/* Two NULLs are identical, aren't they ? */
d164 1
a164 1
**	document. The parent anchor must already exist.
d174 2
a175 3
	if (TRACE)
	    fprintf(stderr, "HTAnchor_findChild called with NULL parent.\n");
	return NULL;
d184 1
a184 1
		if (HTEquivalent(child->tag, tag)) { /* Case insensitive */
d186 1
a186 1
		if (HTIdentical(child->tag, tag)) {  /* Case sensitive - FM */
d188 2
a189 3
		    if (TRACE)
			fprintf(stderr,
	      "Child anchor %p of parent %p with name `%s' already exists.\n",
d191 1
a191 1
		    return child;
d200 3
a202 3
    if (TRACE)
	fprintf(stderr,
		"new Anchor %p named `%s' is child of %p\n",
d209 1
a209 1
    return child;
d228 1
a228 2
    if (TRACE)
	fprintf(stderr,"Entered HTAnchor_findChildAndLink\n");
d253 23
d280 1
a280 1
    return child;
d283 1
d307 6
d320 1
d336 1
a336 2
    if (TRACE)
	fprintf(stderr,"Entered HTAnchor_findAddress\n");
d378 3
d382 1
d404 1
a404 3
		if (TRACE)
		    fprintf(stderr,
			    "Anchor %p with address `%s' already exists.\n",
d414 1
a414 3
	if (TRACE)
	    fprintf(stderr,
		    "New anchor %p has hash %d and address `%s'\n",
d463 8
d485 1
a485 1
	 *  Don't do this jass if the anchor passed in is the same
a501 1
	me->mainLink.dest = NULL;
d594 6
d625 1
d649 1
d709 2
d714 1
d778 1
a778 1
    return me ? me->parent : NULL;
d792 1
a792 1
    return me ? me->document : NULL;
a795 10
/*  We don't want code to change an address after anchor creation... yet ?
PUBLIC void HTAnchor_setAddress ARGS2(
	HTAnchor *,	me,
	char *, 	addr)
{
    if (me)
	StrAllocCopy (me->parent->address, addr);
}
*/

d815 1
a815 1
    return addr;
d829 1
a829 1
    return me ? me->format : NULL;
d854 1
a854 1
    return me ? me->isIndex : NO;
d863 1
a863 1
    return me ? me->parent->isISMAPScript : NO;
d869 1
a869 1
    return me ? ! HTList_isEmpty(me->children) : NO;
d878 1
a878 1
	return me ? me->style : NULL;
d897 1
a897 1
    return me ? me->title : NULL;
d907 15
a921 5
	StrAllocCopy(me->title, title);
	for (i = 0; me->title[i]; i++) {
	    if ((unsigned char)me->title[i] == 1 ||
		(unsigned char)me->title[i] == 2) {
		me->title[i] = ' ';
d949 1
a949 1
    return me ? me->bookmark : NULL;
d965 1
a965 1
    return (me ? me->owner : NULL);
d982 1
a982 1
    return (me ? me->RevTitle : NULL);
d1009 1
a1009 1
    return me ? me->SugFname : NULL;
d1019 1
a1019 1
    return me ? me->content_encoding : NULL;
d1027 1
a1027 1
    return me ? me->content_type : NULL;
d1035 1
a1035 1
    return me ? me->last_modified : NULL;
d1043 1
a1043 1
    return me ? me->date : NULL;
d1051 1
a1051 1
    return me ? me->server : NULL;
d1059 1
a1059 1
    return me ? me->safe : FALSE;
d1067 1
a1067 1
    return me ? me->content_base : NULL;
d1075 39
a1113 1
    return me ? me->content_location : NULL;
d1125 2
a1126 4
	return NO;  /* Can't link to/from non-existing anchor */
    if (TRACE)
	fprintf(stderr,
		"Linking anchor %p to anchor %p\n", source, destination);
d1143 1
a1143 1
    return YES;  /* Success */
d1153 1
a1153 1
    return me->mainLink.dest;
d1161 1
a1161 1
	return me->mainLink.dest;
d1167 1
a1167 1
		return the_link->dest;
d1171 1
a1171 1
    return NULL;  /* No link of me type */
d1183 1
a1183 1
	return NO;  /* link not found or NULL anchor */
d1197 1
a1197 1
	return YES;
d1211 1
a1211 1
    return me->methods;
d1220 1
a1220 1
    return me->protocol;
d1236 1
a1236 1
    return me->physical;
d1278 1
a1278 1
	int chndl = UCLYhndl_for_unspec;
d1289 1
a1289 1
	    if (chndl < 0) {
d1291 10
a1300 13
	    }
	}
	if (chndl >= 0) {
	    memcpy(&stages->s[UCT_STAGE_MIME].C, &LYCharSet_UC[chndl],
		   sizeof(LYUCcharset));
	    stages->s[UCT_STAGE_MIME].lock = UCT_SETBY_DEFAULT;
	} else {
	    /*
	     *	Should not happen...
	     */
	    stages->s[UCT_STAGE_MIME].C.UChndl = -1;
	    stages->s[UCT_STAGE_MIME].lock = UCT_SETBY_NONE;
	}
d1305 1
a1305 1
	return &me->UCStages->s[which_stage].C;
d1307 1
a1307 1
    return NULL;
d1322 1
a1322 1
	    return me->UCStages->s[which_stage].LYhndl;
d1325 1
a1325 1
    return -1;
d1351 1
a1351 1
	    return p;
d1354 1
a1354 1
    return NULL;
d1364 1
a1364 1
	return NULL;
d1367 1
a1367 1
    return &me->UCStages->s[which_stage].C;
d1398 1
a1398 1
	    return p_to;
d1401 1
a1401 1
    return NULL;
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
