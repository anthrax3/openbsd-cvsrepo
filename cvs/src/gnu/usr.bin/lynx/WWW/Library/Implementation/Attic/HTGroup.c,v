head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.47;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* MODULE							HTGroup.c
 *		GROUP FILE ROUTINES
 *
 *	Contains group file parser and routines to match IP
 *	address templates and to find out group membership.
 *
 *
 * AUTHORS:
 *	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
 *
 * HISTORY:
 *
 *
 * BUGS:
 *
 *
 *
 * GROUP DEFINITION GRAMMAR:
 *
 *	string = "sequence of alphanumeric characters"
 *	user_name ::= string
 *	group_name ::= string
 *	group_ref ::= group_name
 *	user_def ::= user_name | group_ref
 *	user_def_list ::= user_def { ',' user_def }
 *	user_part = user_def | '(' user_def_list ')'
 *
 *	templ = "sequence of alphanumeric characters and '*'s"
 *	ip_number_mask ::= templ '.' templ '.' templ '.' templ
 *	domain_name_mask ::= templ { '.' templ }
 *	address ::= ip_number_mask | domain_name_mask
 *	address_def ::= address
 *	address_def_list ::= address_def { ',' address_def }
 *	address_part = address_def | '(' address_def_list ')'
 *
 *	item ::= [user_part] ['@@' address_part]
 *	item_list ::= item { ',' item }
 *	group_def ::= item_list
 *	group_decl ::= group_name ':' group_def
 *
 */

#include <HTUtils.h>

#include <HTAAUtil.h>
#include <HTLex.h>		/* Lexical analysor     */
#include <HTGroup.h>		/* Implemented here     */

#include <LYUtils.h>
#include <LYLeaks.h>

/*
 * Group file parser
 */

typedef HTList UserDefList;
typedef HTList AddressDefList;

typedef struct {
    UserDefList *user_def_list;
    AddressDefList *address_def_list;
} Item;

typedef struct {
    char *name;
    GroupDef *translation;
} Ref;

static void syntax_error(FILE *fp, const char *msg,
			 LexItem lex_item)
{
    char buffer[41];
    int cnt = 0;
    int ch;

    while ((ch = getc(fp)) != EOF && ch != '\n')
	if (cnt < 40)
	    buffer[cnt++] = (char) ch;
    buffer[cnt] = (char) 0;

    CTRACE((tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
	    "HTGroup.c: Syntax error in rule file at line",
	    HTlex_line, buffer, msg, lex_verbose(lex_item)));
    HTlex_line++;
}

static AddressDefList *parse_address_part(FILE *fp)
{
    AddressDefList *address_def_list = NULL;
    LexItem lex_item;
    BOOL only_one = NO;

    lex_item = lex(fp);
    if (lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR)
	only_one = YES;
    else if (lex_item != LEX_OPEN_PAREN ||
	     ((lex_item = lex(fp)) != LEX_ALPH_STR &&
	      lex_item != LEX_TMPL_STR)) {
	syntax_error(fp, "Expecting a single address or '(' beginning list",
		     lex_item);
	return NULL;
    }
    address_def_list = HTList_new();

    for (;;) {
	Ref *ref = typecalloc(Ref);

	if (ref == NULL)
	    outofmem(__FILE__, "parse_address_part");

	assert(ref != NULL);

	ref->name = NULL;
	ref->translation = NULL;
	StrAllocCopy(ref->name, HTlex_buffer);

	HTList_addObject(address_def_list, (void *) ref);

	if (only_one || (lex_item = lex(fp)) != LEX_ITEM_SEP)
	    break;
	/*
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
	do {
	    lex_item = lex(fp);
	} while (lex_item == LEX_REC_SEP);

	if (lex_item != LEX_ALPH_STR && lex_item != LEX_TMPL_STR) {
	    syntax_error(fp, "Expecting an address template", lex_item);
	    HTList_delete(address_def_list);
	    address_def_list = NULL;
	    return NULL;
	}
    }

    if (!only_one && lex_item != LEX_CLOSE_PAREN) {
	HTList_delete(address_def_list);
	address_def_list = NULL;
	syntax_error(fp, "Expecting ')' closing address list", lex_item);
	return NULL;
    }
    return address_def_list;
}

static UserDefList *parse_user_part(FILE *fp)
{
    UserDefList *user_def_list = NULL;
    LexItem lex_item;
    BOOL only_one = NO;

    lex_item = lex(fp);
    if (lex_item == LEX_ALPH_STR)
	only_one = YES;
    else if (lex_item != LEX_OPEN_PAREN ||
	     (lex_item = lex(fp)) != LEX_ALPH_STR) {
	syntax_error(fp, "Expecting a single name or '(' beginning list",
		     lex_item);
	return NULL;
    }
    user_def_list = HTList_new();

    for (;;) {
	Ref *ref = typecalloc(Ref);

	if (ref == NULL)
	    outofmem(__FILE__, "parse_user_part");

	assert(ref != NULL);

	ref->name = NULL;
	ref->translation = NULL;
	StrAllocCopy(ref->name, HTlex_buffer);

	HTList_addObject(user_def_list, (void *) ref);

	if (only_one || (lex_item = lex(fp)) != LEX_ITEM_SEP)
	    break;
	/*
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
	do {
	    lex_item = lex(fp);
	} while (lex_item == LEX_REC_SEP);

	if (lex_item != LEX_ALPH_STR) {
	    syntax_error(fp, "Expecting user or group name", lex_item);
	    HTList_delete(user_def_list);
	    user_def_list = NULL;
	    return NULL;
	}
    }

    if (!only_one && lex_item != LEX_CLOSE_PAREN) {
	HTList_delete(user_def_list);
	user_def_list = NULL;
	syntax_error(fp, "Expecting ')' closing user/group list", lex_item);
	return NULL;
    }
    return user_def_list;
}

static Item *parse_item(FILE *fp)
{
    Item *item = NULL;
    UserDefList *user_def_list = NULL;
    AddressDefList *address_def_list = NULL;
    LexItem lex_item;

    lex_item = lex(fp);
    if (lex_item == LEX_ALPH_STR || lex_item == LEX_OPEN_PAREN) {
	unlex(lex_item);
	user_def_list = parse_user_part(fp);
	lex_item = lex(fp);
    }

    if (lex_item == LEX_AT_SIGN) {
	lex_item = lex(fp);
	if (lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR ||
	    lex_item == LEX_OPEN_PAREN) {
	    unlex(lex_item);
	    address_def_list = parse_address_part(fp);
	} else {
	    if (user_def_list) {
		HTList_delete(user_def_list);	/* @@@@@@@@ */
		user_def_list = NULL;
	    }
	    syntax_error(fp, "Expected address part (single address or list)",
			 lex_item);
	    return NULL;
	}
    } else
	unlex(lex_item);

    if (!user_def_list && !address_def_list) {
	syntax_error(fp, "Empty item not allowed", lex_item);
	return NULL;
    }
    item = typecalloc(Item);
    if (item == NULL)
	outofmem(__FILE__, "parse_item");

    assert(item != NULL);

    item->user_def_list = user_def_list;
    item->address_def_list = address_def_list;
    return item;
}

static ItemList *parse_item_list(FILE *fp)
{
    ItemList *item_list = HTList_new();
    Item *item;
    LexItem lex_item;

    for (;;) {
	if (!(item = parse_item(fp))) {
	    HTList_delete(item_list);	/* @@@@@@@@ */
	    item_list = NULL;
	    return NULL;
	}
	HTList_addObject(item_list, (void *) item);
	lex_item = lex(fp);
	if (lex_item != LEX_ITEM_SEP) {
	    unlex(lex_item);
	    return item_list;
	}
	/*
	 * Here lex_item == LEX_ITEM_SEP; after item separator it
	 * is ok to have one or more newlines (LEX_REC_SEP) and
	 * they are ignored (continuation line).
	 */
	do {
	    lex_item = lex(fp);
	} while (lex_item == LEX_REC_SEP);
	unlex(lex_item);
    }
}

GroupDef *HTAA_parseGroupDef(FILE *fp)
{
    ItemList *item_list = NULL;
    GroupDef *group_def = NULL;
    LexItem lex_item;

    if (!(item_list = parse_item_list(fp))) {
	return NULL;
    }
    group_def = typecalloc(GroupDef);
    if (group_def == NULL)
	outofmem(__FILE__, "HTAA_parseGroupDef");

    assert(group_def != NULL);

    group_def->group_name = NULL;
    group_def->item_list = item_list;

    if ((lex_item = lex(fp)) != LEX_REC_SEP) {
	syntax_error(fp, "Garbage after group definition", lex_item);
    }

    return group_def;
}

#if 0
static GroupDef *parse_group_decl(FILE *fp)
{
    char *group_name = NULL;
    GroupDef *group_def = NULL;
    LexItem lex_item;

    do {
	lex_item = lex(fp);
    } while (lex_item == LEX_REC_SEP);	/* Ignore empty lines */

    if (lex_item != LEX_ALPH_STR) {
	if (lex_item != LEX_EOF)
	    syntax_error(fp, "Expecting group name", lex_item);
	return NULL;
    }
    StrAllocCopy(group_name, HTlex_buffer);

    if (LEX_FIELD_SEP != (lex_item = lex(fp))) {
	syntax_error(fp, "Expecting field separator", lex_item);
	FREE(group_name);
	return NULL;
    }

    if (!(group_def = HTAA_parseGroupDef(fp))) {
	FREE(group_name);
	return NULL;
    }
    group_def->group_name = group_name;

    return group_def;
}

/*
 * Group manipulation routines
 */

static GroupDef *find_group_def(GroupDefList *group_list,
				const char *group_name)
{
    if (group_list && group_name) {
	GroupDefList *cur = group_list;
	GroupDef *group_def;

	while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur))) {
	    if (!strcmp(group_name, group_def->group_name)) {
		return group_def;
	    }
	}
    }
    return NULL;
}

void HTAA_resolveGroupReferences(GroupDef *group_def,
				 GroupDefList *group_def_list)
{
    if (group_def && group_def->item_list && group_def_list) {
	ItemList *cur1 = group_def->item_list;
	Item *item;

	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
	    UserDefList *cur2 = item->user_def_list;
	    Ref *ref;

	    while (NULL != (ref = (Ref *) HTList_nextObject(cur2)))
		ref->translation = find_group_def(group_def_list, ref->name);

	    /* Does NOT translate address_def_list */
	}
    }
}

static void add_group_def(GroupDefList *group_def_list,
			  GroupDef *group_def)
{
    HTAA_resolveGroupReferences(group_def, group_def_list);
    HTList_addObject(group_def_list, (void *) group_def);
}

static GroupDefList *parse_group_file(FILE *fp)
{
    GroupDefList *group_def_list = HTList_new();
    GroupDef *group_def;

    while (NULL != (group_def = parse_group_decl(fp)))
	add_group_def(group_def_list, group_def);

    return group_def_list;
}
#endif

/*
 * Trace functions
 */

static void print_item(Item *item)
{
    if (!item)
	fprintf(tfp, "\tNULL-ITEM\n");
    else {
	UserDefList *cur1 = item->user_def_list;
	AddressDefList *cur2 = item->address_def_list;
	Ref *user_ref = (Ref *) HTList_nextObject(cur1);
	Ref *addr_ref = (Ref *) HTList_nextObject(cur2);

	if (user_ref) {
	    fprintf(tfp, "\t[%s%s", user_ref->name,
		    (user_ref->translation ? "*REF*" : ""));
	    while (NULL != (user_ref = (Ref *) HTList_nextObject(cur1)))
		fprintf(tfp, "; %s%s", user_ref->name,
			(user_ref->translation ? "*REF*" : ""));
	    fprintf(tfp, "] ");
	} else
	    fprintf(tfp, "\tANYBODY ");

	if (addr_ref) {
	    fprintf(tfp, "@@ [%s", addr_ref->name);
	    while (NULL != (addr_ref = (Ref *) HTList_nextObject(cur2)))
		fprintf(tfp, "; %s", addr_ref->name);
	    fprintf(tfp, "]\n");
	} else
	    fprintf(tfp, "@@ ANYADDRESS\n");
    }
}

static void print_item_list(ItemList *item_list)
{
    ItemList *cur = item_list;
    Item *item;

    if (!item_list)
	fprintf(tfp, "EMPTY");
    else
	while (NULL != (item = (Item *) HTList_nextObject(cur)))
	    print_item(item);
}

void HTAA_printGroupDef(GroupDef *group_def)
{
    if (!group_def) {
	fprintf(tfp, "\nNULL RECORD\n");
	return;
    }

    fprintf(tfp, "\nGroup %s:\n",
	    (group_def->group_name ? group_def->group_name : "NULL"));

    print_item_list(group_def->item_list);
    fprintf(tfp, "\n");
}

#if 0
static void print_group_def_list(GroupDefList *group_list)
{
    GroupDefList *cur = group_list;
    GroupDef *group_def;

    while (NULL != (group_def = (GroupDef *) HTList_nextObject(cur)))
	HTAA_printGroupDef(group_def);
}

/*
 * IP address template matching
 */

/* static						part_match()
 *		MATCH ONE PART OF INET ADDRESS AGAIST
 *		A PART OF MASK (inet address has 4 parts)
 * ON ENTRY:
 *	tcur	pointer to the beginning of template part.
 *	icur	pointer to the beginning of actual inet
 *		number part.
 *
 * ON EXIT:
 *	returns	YES, if match.
 */
static BOOL part_match(const char *tcur,
		       const char *icur)
{
    char required[4];
    char actual[4];
    const char *cur;
    int cnt;
    BOOL status;

    if (!tcur || !icur)
	return NO;

    cur = tcur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
	required[cnt++] = *(cur++);
    required[cnt] = (char) 0;

    cur = icur;
    cnt = 0;
    while (cnt < 3 && *cur && *cur != '.')
	actual[cnt++] = *(cur++);
    actual[cnt] = (char) 0;

    status = HTAA_templateMatch(required, actual);
    CTRACE((tfp, "part_match: req: '%s' act: '%s' match: %s\n",
	    required, actual, (status ? "yes" : "no")));

    return status;
}

/* static						ip_number_match()
 *		MATCH INET NUMBER AGAINST AN INET NUMBER MASK
 * ON ENTRY:
 *	template	mask to match agaist, e.g., 128.141.*.*
 *	the_inet_addr	actual inet address, e.g., 128.141.201.74
 *
 * ON EXIT:
 *	returns		YES, if match;  NO, if not.
 */
static BOOL ip_number_match(const char *ctemplate,
			    const char *the_inet_addr)
{
    const char *tcur = ctemplate;
    const char *icur = the_inet_addr;
    int cnt;

    for (cnt = 0; cnt < 4; cnt++) {
	if (!tcur || !icur || !part_match(tcur, icur))
	    return NO;
	if (NULL != (tcur = StrChr(tcur, '.')))
	    tcur++;
	if (NULL != (icur = StrChr(icur, '.')))
	    icur++;
    }
    return YES;
}

/* static						is_domain_mask()
 *		DETERMINE IF A GIVEN MASK IS A
 *		DOMAIN NAME MASK OR AN INET NUMBER MASK
 * ON ENTRY:
 *	mask	either a domain name mask,
 *		e.g.
 *			*.cern.ch
 *
 *		or an inet number mask,
 *		e.g.
 *			128.141.*.*
 *
 * ON EXIT:
 *	returns	YES, if mask is a domain name mask.
 *		NO, if it is an inet number mask.
 */
static BOOL is_domain_mask(const char *mask)
{
    const char *cur = mask;

    if (!mask)
	return NO;

    while (*cur) {
	if (*cur != '.' && *cur != '*' && (*cur < '0' || *cur > '9'))
	    return YES;		/* Even one non-digit makes it a domain name mask */
	cur++;
    }
    return NO;			/* All digits and dots, so it is an inet number mask */
}

/* static							ip_mask_match()
 *		MATCH AN IP NUMBER MASK OR IP NAME MASK
 *		AGAINST ACTUAL IP NUMBER OR IP NAME
 *
 * ON ENTRY:
 *	mask		mask.  Mask may be either an inet number
 *			mask or a domain name mask,
 *			e.g.
 *				128.141.*.*
 *			or
 *				*.cern.ch
 *
 *	ip_number	IP number of connecting host.
 *	ip_name		IP name of the connecting host.
 *
 * ON EXIT:
 *	returns		YES, if hostname/internet number
 *			matches the mask.
 *			NO, if no match (no fire).
 */
static BOOL ip_mask_match(const char *mask,
			  const char *ip_number,
			  const char *ip_name)
{
    if (mask && (ip_number || ip_name)) {
	if (is_domain_mask(mask)) {
	    if (HTAA_templateMatch(mask, ip_name))
		return YES;
	} else {
	    if (ip_number_match(mask, ip_number))
		return YES;
	}
    }
    return NO;
}

static BOOL ip_in_def_list(AddressDefList *address_def_list,
			   char *ip_number,
			   char *ip_name)
{
    if (address_def_list && (ip_number || ip_name)) {
	AddressDefList *cur = address_def_list;
	Ref *ref;

	while (NULL != (ref = (Ref *) HTList_nextObject(cur))) {
	    /* Value of ref->translation is ignored, i.e., */
	    /* no recursion for ip address tamplates.     */
	    if (ip_mask_match(ref->name, ip_number, ip_name))
		return YES;
	}
    }
    return NO;
}

/*
 * Group file cached reading
 */

typedef struct {
    char *group_filename;
    GroupDefList *group_list;
} GroupCache;

typedef HTList GroupCacheList;

static GroupCacheList *group_cache_list = NULL;

GroupDefList *HTAA_readGroupFile(const char *filename)
{
    FILE *fp;
    GroupCache *group_cache;

    if (isEmpty(filename))
	return NULL;

    if (!group_cache_list)
	group_cache_list = HTList_new();
    else {
	GroupCacheList *cur = group_cache_list;

	while (NULL != (group_cache = (GroupCache *) HTList_nextObject(cur))) {
	    if (!strcmp(filename, group_cache->group_filename)) {
		CTRACE((tfp, "%s '%s' %s\n",
			"HTAA_readGroupFile: group file",
			filename, "already found in cache"));
		return group_cache->group_list;
	    }			/* if cache match */
	}			/* while cached files remain */
    }				/* cache exists */

    CTRACE((tfp, "HTAA_readGroupFile: reading group file `%s'\n",
	    filename));

    if (!(fp = fopen(filename, TXT_R))) {
	CTRACE((tfp, "%s '%s'\n",
		"HTAA_readGroupFile: unable to open group file",
		filename));
	return NULL;
    }

    if ((group_cache = typecalloc(GroupCache)) == 0)
	outofmem(__FILE__, "HTAA_readGroupFile");

    group_cache->group_filename = NULL;
    StrAllocCopy(group_cache->group_filename, filename);
    group_cache->group_list = parse_group_file(fp);
    HTList_addObject(group_cache_list, (void *) group_cache);
    fclose(fp);

    CTRACE((tfp, "Read group file '%s', results follow:\n", filename));
    if (TRACE)
	print_group_def_list(group_cache->group_list);

    return group_cache->group_list;
}

/* PUBLIC					HTAA_userAndInetInGroup()
 *		CHECK IF USER BELONGS TO TO A GIVEN GROUP
 *		AND THAT THE CONNECTION COMES FROM AN
 *		ADDRESS THAT IS ALLOWED BY THAT GROUP
 * ON ENTRY:
 *	group		the group definition structure.
 *	username	connecting user.
 *	ip_number	browser host IP number, optional.
 *	ip_name		browser host IP name, optional.
 *			However, one of ip_number or ip_name
 *			must be given.
 * ON EXIT:
 *	returns		HTAA_IP_MASK, if IP address mask was
 *			reason for failing.
 *			HTAA_NOT_MEMBER, if user does not belong
 *			to the group.
 *			HTAA_OK if both IP address and user are ok.
 */
HTAAFailReasonType HTAA_userAndInetInGroup(GroupDef *group,
					   char *username,
					   char *ip_number,
					   char *ip_name)
{
    HTAAFailReasonType reason = HTAA_NOT_MEMBER;

    if (group && username) {
	ItemList *cur1 = group->item_list;
	Item *item;

	while (NULL != (item = (Item *) HTList_nextObject(cur1))) {
	    if (!item->address_def_list ||	/* Any address allowed */
		ip_in_def_list(item->address_def_list, ip_number, ip_name)) {

		if (!item->user_def_list)	/* Any user allowed */
		    return HTAA_OK;
		else {
		    UserDefList *cur2 = item->user_def_list;
		    Ref *ref;

		    while (NULL != (ref = (Ref *) HTList_nextObject(cur2))) {

			if (ref->translation) {		/* Group, check recursively */
			    reason = HTAA_userAndInetInGroup(ref->translation,
							     username,
							     ip_number, ip_name);
			    if (reason == HTAA_OK)
				return HTAA_OK;
			} else {	/* Username, check directly */
			    if (username && *username &&
				0 == strcmp(ref->name, username))
				return HTAA_OK;
			}
			/* Every user/group name in this group */
		    }
		    /* search for username */
		}
		/* IP address ok */
	    } else {
		reason = HTAA_IP_MASK;
	    }
	}			/* while items in group */
    }
    /* valid parameters */
    return reason;		/* No match, or invalid parameters */
}

void GroupDef_delete(GroupDef *group_def)
{
    if (group_def) {
	FREE(group_def->group_name);
	if (group_def->item_list) {
	    HTList_delete(group_def->item_list);	/* @@@@@@@@ */
	    group_def->item_list = NULL;
	}
	FREE(group_def);
    }
}
#endif
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d110 3
d169 3
d245 3
d295 3
d534 1
a534 1
	if (NULL != (tcur = strchr(tcur, '.')))
d536 1
a536 1
	if (NULL != (icur = strchr(icur, '.')))
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@a0 1

d2 40
a41 41
**		GROUP FILE ROUTINES
**
**	Contains group file parser and routines to match IP
**	address templates and to find out group membership.
**
**
** AUTHORS:
**	AL	Ari Luotonen	luotonen@@dxcern.cern.ch
**
** HISTORY:
**
**
** BUGS:
**
**
**
** GROUP DEFINITION GRAMMAR:
**
**	string = "sequence of alphanumeric characters"
**	user_name ::= string
**	group_name ::= string
**	group_ref ::= group_name
**	user_def ::= user_name | group_ref
**	user_def_list ::= user_def { ',' user_def }
**	user_part = user_def | '(' user_def_list ')'
**
**	templ = "sequence of alphanumeric characters and '*'s"
**	ip_number_mask ::= templ '.' templ '.' templ '.' templ
**	domain_name_mask ::= templ { '.' templ }
**	address ::= ip_number_mask | domain_name_mask
**	address_def ::= address
**	address_def_list ::= address_def { ',' address_def }
**	address_part = address_def | '(' address_def_list ')'
**
**	item ::= [user_part] ['@@' address_part]
**	item_list ::= item { ',' item }
**	group_def ::= item_list
**	group_decl ::= group_name ':' group_def
**
*/

d46 2
a47 2
#include <HTLex.h>	/* Lexical analysor	*/
#include <HTGroup.h>	/* Implemented here	*/
d53 2
a54 2
** Group file parser
*/
d60 2
a61 2
    UserDefList *	user_def_list;
    AddressDefList *	address_def_list;
d65 2
a66 2
    char *	name;
    GroupDef *	translation;
d69 2
a70 5


PRIVATE void syntax_error ARGS3(FILE *,	 fp,
				char *,	 msg,
				LexItem, lex_item)
d76 4
a79 3
    while ((ch = getc(fp)) != EOF  &&  ch != '\n')
	if (cnt < 40) buffer[cnt++] = (char) ch;
    buffer[cnt] = (char)0;
d82 2
a83 2
		"HTGroup.c: Syntax error in rule file at line",
		HTlex_line, buffer, msg, lex_verbose(lex_item)));
d87 1
a87 2

PRIVATE AddressDefList *parse_address_part ARGS1(FILE *, fp)
d96 1
a96 1
    else if (lex_item != LEX_OPEN_PAREN  ||
d105 1
a105 1
    for(;;) {
d107 1
d114 1
a114 1
	HTList_addObject(address_def_list, (void*)ref);
d119 4
a122 4
	** Here lex_item == LEX_ITEM_SEP; after item separator it
	** is ok to have one or more newlines (LEX_REC_SEP) and
	** they are ignored (continuation line).
	*/
d144 1
a144 2

PRIVATE UserDefList *parse_user_part ARGS1(FILE *, fp)
d153 1
a153 1
    else if (lex_item != LEX_OPEN_PAREN  ||
d163 1
d170 1
a170 1
	HTList_addObject(user_def_list, (void*)ref);
d175 4
a178 4
	** Here lex_item == LEX_ITEM_SEP; after item separator it
	** is ok to have one or more newlines (LEX_REC_SEP) and
	** they are ignored (continuation line).
	*/
d200 1
a200 2

PRIVATE Item *parse_item ARGS1(FILE *, fp)
d220 1
a220 2
	}
	else {
d229 2
a230 2
    }
    else unlex(lex_item);
d244 1
a244 2

PRIVATE ItemList *parse_item_list ARGS1(FILE *, fp)
d250 1
a250 1
    for(;;) {
d256 1
a256 1
	HTList_addObject(item_list, (void*)item);
d263 4
a266 4
	** Here lex_item == LEX_ITEM_SEP; after item separator it
	** is ok to have one or more newlines (LEX_REC_SEP) and
	** they are ignored (continuation line).
	*/
d274 1
a274 2

PUBLIC GroupDef *HTAA_parseGroupDef ARGS1(FILE *, fp)
d296 2
a297 2

PRIVATE GroupDef *parse_group_decl ARGS1(FILE *, fp)
a328 2


d330 2
a331 2
** Group manipulation routines
*/
d333 2
a334 2
PRIVATE GroupDef *find_group_def ARGS2(GroupDefList *,	group_list,
				       CONST char *,	group_name)
d340 1
a340 1
	while (NULL != (group_def = (GroupDef*)HTList_nextObject(cur))) {
d349 2
a350 3

PUBLIC void HTAA_resolveGroupReferences ARGS2(GroupDef *,	group_def,
					      GroupDefList *,	group_def_list)
d356 1
a356 1
	while (NULL != (item = (Item*)HTList_nextObject(cur1))) {
d360 1
a360 1
	    while (NULL != (ref = (Ref*)HTList_nextObject(cur2)))
d368 2
a369 3

PRIVATE void add_group_def ARGS2(GroupDefList *, group_def_list,
				 GroupDef *,	 group_def)
d372 1
a372 1
    HTList_addObject(group_def_list, (void*)group_def);
d375 1
a375 2

PRIVATE GroupDefList *parse_group_file ARGS1(FILE *, fp)
d385 1
a385 1

d388 2
a389 2
** Trace functions
*/
d391 1
a391 1
PRIVATE void print_item ARGS1(Item *, item)
d398 2
a399 2
	Ref *user_ref = (Ref*)HTList_nextObject(cur1);
	Ref *addr_ref = (Ref*)HTList_nextObject(cur2);
d404 1
a404 1
	    while (NULL != (user_ref = (Ref*)HTList_nextObject(cur1)))
d408 2
a409 1
	} else fprintf(tfp, "\tANYBODY ");
d413 1
a413 1
	    while (NULL != (addr_ref = (Ref*)HTList_nextObject(cur2)))
d416 2
a417 1
	} else fprintf(tfp, "@@ ANYADDRESS\n");
d421 1
a421 2

PRIVATE void print_item_list ARGS1(ItemList *, item_list)
d428 3
a430 2
    else while (NULL != (item = (Item*)HTList_nextObject(cur)))
	print_item(item);
d433 1
a433 2

PUBLIC void HTAA_printGroupDef ARGS1(GroupDef *, group_def)
d447 2
a448 2

PRIVATE void print_group_def_list ARGS1(GroupDefList *, group_list)
d453 1
a453 1
    while (NULL != (group_def = (GroupDef*)HTList_nextObject(cur)))
a456 2


d458 2
a459 2
** IP address template matching
*/
d461 13
a473 13
/* PRIVATE						part_match()
**		MATCH ONE PART OF INET ADDRESS AGAIST
**		A PART OF MASK (inet address has 4 parts)
** ON ENTRY:
**	tcur	pointer to the beginning of template part.
**	icur	pointer to the beginning of actual inet
**		number part.
**
** ON EXIT:
**	returns	YES, if match.
*/
PRIVATE BOOL part_match ARGS2(CONST char *, tcur,
			      CONST char *, icur)
d477 1
a477 1
    CONST char *cur;
d481 2
a482 1
    if (!tcur || !icur) return NO;
d484 3
a486 3
    cur=tcur;
    cnt=0;
    while (cnt < 3  &&  *cur && *cur != '.')
d488 1
a488 1
    required[cnt] = (char)0;
d490 3
a492 3
    cur=icur;
    cnt=0;
    while (cnt < 3  &&  *cur && *cur != '.')
d494 1
a494 1
    actual[cnt] = (char)0;
d498 1
a498 1
		required, actual, (status ? "yes" : "no")));
d503 11
a513 13


/* PRIVATE						ip_number_match()
**		MATCH INET NUMBER AGAINST AN INET NUMBER MASK
** ON ENTRY:
**	template	mask to match agaist, e.g., 128.141.*.*
**	the_inet_addr	actual inet address, e.g., 128.141.201.74
**
** ON EXIT:
**	returns		YES, if match;  NO, if not.
*/
PRIVATE BOOL ip_number_match ARGS2(CONST char *,	template,
				   CONST char *,	the_inet_addr)
d515 2
a516 2
    CONST char *tcur = template;
    CONST char *icur = the_inet_addr;
d519 1
a519 1
    for (cnt=0; cnt<4; cnt++) {
d522 4
a525 2
	if (NULL != (tcur = strchr(tcur, '.'))) tcur++;
	if (NULL != (icur = strchr(icur, '.'))) icur++;
d530 17
a546 19


/* PRIVATE						is_domain_mask()
**		DETERMINE IF A GIVEN MASK IS A
**		DOMAIN NAME MASK OR AN INET NUMBER MASK
** ON ENTRY:
**	mask	either a domain name mask,
**		e.g.
**			*.cern.ch
**
**		or an inet number mask,
**		e.g.
**			128.141.*.*
**
** ON EXIT:
**	returns	YES, if mask is a domain name mask.
**		NO, if it is an inet number mask.
*/
PRIVATE BOOL is_domain_mask ARGS1(CONST char *,	mask)
d548 1
a548 1
    CONST char *cur = mask;
d550 2
a551 1
    if (!mask) return NO;
d554 2
a555 2
	if (*cur != '.'  &&  *cur != '*'  &&  (*cur < '0' || *cur > '9'))
	    return YES;	/* Even one non-digit makes it a domain name mask */
d558 1
a558 1
    return NO;	/* All digits and dots, so it is an inet number mask */
d561 23
a583 25


/* PRIVATE							ip_mask_match()
**		MATCH AN IP NUMBER MASK OR IP NAME MASK
**		AGAINST ACTUAL IP NUMBER OR IP NAME
**
** ON ENTRY:
**	mask		mask.  Mask may be either an inet number
**			mask or a domain name mask,
**			e.g.
**				128.141.*.*
**			or
**				*.cern.ch
**
**	ip_number	IP number of connecting host.
**	ip_name		IP name of the connecting host.
**
** ON EXIT:
**	returns		YES, if hostname/internet number
**			matches the mask.
**			NO, if no match (no fire).
*/
PRIVATE BOOL ip_mask_match ARGS3(CONST char *,	mask,
				 CONST char *,	ip_number,
				 CONST char *,	ip_name)
d589 1
a589 2
	}
	else {
d597 3
a599 6



PRIVATE BOOL ip_in_def_list ARGS3(AddressDefList *,	address_def_list,
				  char *,		ip_number,
				  char *,		ip_name)
d605 1
a605 1
	while (NULL != (ref = (Ref*)HTList_nextObject(cur))) {
d607 1
a607 1
	    /* no recursion for ip address tamplates.	  */
a614 1

d616 2
a617 2
** Group file cached reading
*/
d620 2
a621 2
    char *	   group_filename;
    GroupDefList * group_list;
d626 1
a626 2
PRIVATE GroupCacheList *group_cache_list = NULL;

d628 1
a628 1
PUBLIC GroupDefList *HTAA_readGroupFile ARGS1(CONST char *, filename)
d633 2
a634 1
    if (isEmpty(filename)) return NULL;
d641 1
a641 1
	while (NULL != (group_cache = (GroupCache*)HTList_nextObject(cur))) {
d644 2
a645 2
			    "HTAA_readGroupFile: group file",
			    filename, "already found in cache"));
d647 3
a649 3
	    } /* if cache match */
	} /* while cached files remain */
    } /* cache exists */
d652 1
a652 1
		filename));
d656 2
a657 2
		    "HTAA_readGroupFile: unable to open group file",
		    filename));
d667 1
a667 1
    HTList_addObject(group_cache_list, (void*)group_cache);
a676 1

d678 21
a698 21
**		CHECK IF USER BELONGS TO TO A GIVEN GROUP
**		AND THAT THE CONNECTION COMES FROM AN
**		ADDRESS THAT IS ALLOWED BY THAT GROUP
** ON ENTRY:
**	group		the group definition structure.
**	username	connecting user.
**	ip_number	browser host IP number, optional.
**	ip_name		browser host IP name, optional.
**			However, one of ip_number or ip_name
**			must be given.
** ON EXIT:
**	returns		HTAA_IP_MASK, if IP address mask was
**			reason for failing.
**			HTAA_NOT_MEMBER, if user does not belong
**			to the group.
**			HTAA_OK if both IP address and user are ok.
*/
PUBLIC HTAAFailReasonType HTAA_userAndInetInGroup ARGS4(GroupDef *, group,
							char *,	    username,
							char *,	    ip_number,
							char *,	    ip_name)
d706 1
a706 1
	while (NULL != (item = (Item*)HTList_nextObject(cur1))) {
d716 1
a716 1
		    while (NULL != (ref = (Ref*)HTList_nextObject(cur2))) {
d718 1
a718 1
			if (ref->translation) {	/* Group, check recursively */
d721 1
a721 1
							     ip_number,ip_name);
d724 1
a724 2
			}
			else {	/* Username, check directly */
d726 1
a726 1
				0==strcmp(ref->name, username))
d729 6
a734 4
		    } /* Every user/group name in this group */
		} /* search for username */
	    } /* IP address ok */
	    else {
d737 3
a739 3
	} /* while items in group */
    } /* valid parameters */

d743 1
a743 2

PUBLIC void GroupDef_delete ARGS1(GroupDef *, group_def)
d754 1
a754 1

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d655 1
a655 1
    if (!filename || !*filename) return NULL;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d51 1
d82 1
a82 1
	if (cnt < 40) buffer[cnt++] = ch;
d85 1
a85 1
    CTRACE(tfp, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
d87 1
a87 1
		HTlex_line, buffer, msg, lex_verbose(lex_item));
d111 1
a111 1
	Ref *ref = (Ref*)calloc(1, sizeof(Ref));
d167 1
a167 1
	Ref *ref = (Ref*)calloc(1, sizeof(Ref));
d242 1
a242 1
    item = (Item*)calloc(1, sizeof(Item));
d291 1
a291 1
    group_def = (GroupDef*)calloc(1, sizeof(GroupDef));
d510 2
a511 2
    CTRACE(tfp, "part_match: req: '%s' act: '%s' match: %s\n",
		required, actual, (status ? "yes" : "no"));
d664 1
a664 1
		CTRACE(tfp, "%s '%s' %s\n",
d666 1
a666 1
			    filename, "already found in cache");
d672 2
a673 2
    CTRACE(tfp, "HTAA_readGroupFile: reading group file `%s'\n",
		filename);
d675 2
a676 2
    if (!(fp = fopen(filename, "r"))) {
	CTRACE(tfp, "%s '%s'\n",
d678 1
a678 1
		    filename);
d682 1
a682 1
    if (!(group_cache = (GroupCache*)calloc(1, sizeof(GroupCache))))
d691 1
a691 1
    CTRACE(tfp, "Read group file '%s', results follow:\n", filename);
@


1.1
log
@Initial revision
@
text
@d45 1
d47 3
a49 5
#include "HTUtils.h"
#include <string.h>
#include "HTAAUtil.h"
#include "HTLex.h"	/* Lexical analysor	*/
#include "HTGroup.h"	/* Implemented here	*/
d51 1
a51 1
#include "LYLeaks.h"
d70 1
a70 1
	
d84 1
a84 2
    if (TRACE)
	fprintf(stderr, "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
d111 2
d116 1
a116 1
	
d167 2
d174 1
a174 1
	
d227 1
a227 1
	        HTList_delete(user_def_list);	/* @@@@@@@@ */
d242 2
d291 2
d299 1
a299 1
    
d301 1
a301 1
}    
d335 1
a335 1
	
d352 2
a353 2
            }
        }
d391 1
a391 1
    
d394 1
a394 1
    
d406 1
a406 1
	fprintf(stderr, "\tNULL-ITEM\n");
d414 1
a414 1
	    fprintf(stderr, "\t[%s%s", user_ref->name,
d417 1
a417 1
		fprintf(stderr, "; %s%s", user_ref->name,
d419 2
a420 2
	    fprintf(stderr, "] ");
	} else fprintf(stderr, "\tANYBODY ");
d423 1
a423 1
	    fprintf(stderr, "@@ [%s", addr_ref->name);
d425 3
a427 3
		fprintf(stderr, "; %s", addr_ref->name);
	    fprintf(stderr, "]\n");
	} else fprintf(stderr, "@@ ANYADDRESS\n");
d438 1
a438 1
	fprintf(stderr, "EMPTY");
d447 1
a447 1
	fprintf(stderr, "\nNULL RECORD\n");
d451 1
a451 1
    fprintf(stderr, "\nGroup %s:\n",
d455 1
a455 1
    fprintf(stderr, "\n");
d463 1
a463 1
    
d492 1
d508 2
a509 3
    if (TRACE) {
	BOOL status = HTAA_templateMatch(required, actual);
	fprintf(stderr, "part_match: req: '%s' act: '%s' match: %s\n",
a510 2
	return status;
    }
d512 1
a512 1
    return HTAA_templateMatch(required, actual);
d520 2
a521 2
**	template	mask to match agaist, e.g. 128.141.*.*
**	the_inet_addr	actual inet address, e.g. 128.141.201.74
d532 1
a532 1
    
d579 1
a579 1
**		
d581 1
a581 1
**	mask		mask. Mask may be either an inet number
d625 1
a625 1
	    /* Value of ref->translation is ignored, i.e. */
d663 3
a665 3
		if (TRACE) fprintf(stderr, "%s '%s' %s\n",
				   "HTAA_readGroupFile: group file",
				   filename, "already found in cache");
d671 2
a672 2
    if (TRACE) fprintf(stderr, "HTAA_readGroupFile: reading group file `%s'\n",
		       filename);
d675 3
a677 3
	if (TRACE) fprintf(stderr, "%s '%s'\n",
			   "HTAA_readGroupFile: unable to open group file",
			   filename);
d690 2
a691 2
    if (TRACE) {
	fprintf(stderr, "Read group file '%s', results follow:\n", filename);
a692 1
    }
d730 1
a730 1
		    
d738 1
a738 1
			
d759 1
a759 1
    
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
