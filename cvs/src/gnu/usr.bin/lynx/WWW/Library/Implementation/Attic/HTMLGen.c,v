head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.14
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.10
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.8
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.8
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.48;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTMLGen.c,v 1.40 2013/11/28 11:13:46 tom Exp $
 *
 *		HTML Generator
 *		==============
 *
 *	This version of the HTML object sends HTML markup to the output stream.
 *
 * Bugs:	Line wrapping is not done at all.
 *		All data handled as PCDATA.
 *		Should convert old XMP, LISTING and PLAINTEXT to PRE.
 *
 *	It is not obvious to me right now whether the HEAD should be generated
 *	from the incomming data or the anchor.	Currently it is from the former
 *	which is cleanest.
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>

#define BUFFER_SIZE    200	/* Line buffer attempts to make neat breaks */
#define MAX_CLEANNESS	20

/* Implements:
*/
#include <HTMLGen.h>

#include <HTMLDTD.h>
#include <HTStream.h>
#include <SGML.h>
#include <HTFormat.h>

#ifdef USE_COLOR_STYLE
#include <LYCharUtils.h>
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>
#endif

#include <LYGlobalDefs.h>
#include <LYCurses.h>
#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
char class_string[TEMPSTRINGSIZE + 1];

static char *Style_className = NULL;
static int hcode;
#endif

/*		HTML Object
 *		-----------
 */
struct _HTStream {
    const HTStreamClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */
};

struct _HTStructured {
    const HTStructuredClass *isa;
    HTStream *target;
    HTStreamClass targetClass;	/* COPY for speed */

    char buffer[BUFFER_SIZE + 1];	/* 1for NL */
    int buffer_maxchars;
    char *write_pointer;
    char *line_break[MAX_CLEANNESS + 1];
    int cleanness;
    BOOL overflowed;
    BOOL delete_line_break_char[MAX_CLEANNESS + 1];
    BOOL preformatted;
    BOOL escape_specials;
    BOOL in_attrval;
#ifdef USE_COLOR_STYLE
    HText *text;
#endif
};

/*	Flush Buffer
 *	------------
 */

static void flush_breaks(HTStructured * me)
{
    int i;

    for (i = 0; i <= MAX_CLEANNESS; i++) {
	me->line_break[i] = NULL;
    }
}

static void HTMLGen_flush(HTStructured * me)
{
    (*me->targetClass.put_block) (me->target,
				  me->buffer,
				  (int) (me->write_pointer - me->buffer));
    me->write_pointer = me->buffer;
    flush_breaks(me);
    me->cleanness = 0;
    me->delete_line_break_char[0] = NO;
}

#ifdef USE_COLOR_STYLE
/*
 * We need to flush our buffer each time before we effect a color style change,
 * this also relies on the subsequent stage not doing any buffering - this is
 * currently true, in cases where it matters the target stream should be the
 * HTPlain converter.  The flushing currently prevents reasonable line breaking
 * in lines with tags.  Since color styles help visual scanning of displayed
 * source lines, and long lines are wrapped in GridText anyway, this is
 * probably acceptable (or even A Good Thing - more to see in one screenful). 
 * The pointer to the HText structure is initialized here before we effect the
 * first style change.  Getting it from the global HTMainText variable isn't
 * very clean, since it relies on the fact that HText_new() has already been
 * called for the current stream stack's document by the time we start
 * processing the first element; we rely on HTMLGenerator's callers
 * (HTMLParsedPresent in particular) to guarantee this when it matters. 
 * Normally the target stream will have been setup by HTPlainPresent, which
 * does what we need in this respect.  (A check whether we have the right
 * output stream could be done by checking that targetClass.name is
 * "PlainPresenter" or similar.)
 *
 * All special color style handling is only done if LYPreparsedSource is set. 
 * We could always do it for displaying source generated by an internal
 * gateway, but this makes the rule more simple for the user:  color styles are
 * applied to html source only with the -preparsed flag.  - kw
 */
static void do_cstyle_flush(HTStructured * me)
{
    if (!me->text && LYPreparsedSource) {
	me->text = HTMainText;
    }
    if (me->text) {
	HTMLGen_flush(me);
    }
}
#endif /* COLOR_STYLE */

/*	Weighted optional line break
 *
 *	We keep track of all the breaks for when we chop the line
 */

static void allow_break(HTStructured * me, int new_cleanness, int dlbc)
{
    if (dlbc && me->write_pointer == me->buffer)
	dlbc = NO;
    me->line_break[new_cleanness] =
	dlbc ? me->write_pointer - 1	/* Point to space */
	: me->write_pointer;	/* point to gap */
    me->delete_line_break_char[new_cleanness] = (BOOLEAN) dlbc;
    if (new_cleanness >= me->cleanness &&
	(me->overflowed || me->line_break[new_cleanness] > me->buffer))
	me->cleanness = new_cleanness;
}

/*	Character handling
 *	------------------
 *
 *	The tricky bits are the line break handling.  This attempts
 *	to synchrononise line breaks on sentence or phrase ends.  This
 *	is important if one stores SGML files in a line-oriented code
 *	repository, so that if a small change is made, line ends don't
 *	shift in a ripple-through to apparently change a large part of the
 *	file.  We give extra "cleanness" to spaces appearing directly
 *	after periods (full stops), [semi]colons and commas.
 *	   This should make the source files easier to read and modify
 *	by hand, too, though this is not a primary design consideration. TBL
 */
static void HTMLGen_put_character(HTStructured * me, int c)
{
    if (me->escape_specials && UCH(c) < 32) {
	if (c == HT_NON_BREAK_SPACE || c == HT_EN_SPACE ||
	    c == LY_SOFT_HYPHEN) {	/* recursion... */
	    HTMLGen_put_character(me, '&');
	    HTMLGen_put_character(me, '#');
	    HTMLGen_put_character(me, 'x');
	    switch (c) {
	    case HT_NON_BREAK_SPACE:	/* &#xA0; */
		HTMLGen_put_character(me, 'A');
		HTMLGen_put_character(me, '0');
		break;
	    case HT_EN_SPACE:	/* &#x2002; */
		HTMLGen_put_character(me, '2');
		HTMLGen_put_character(me, '0');
		HTMLGen_put_character(me, '0');
		HTMLGen_put_character(me, '2');
		break;
	    case LY_SOFT_HYPHEN:	/* &#xAD; */
		HTMLGen_put_character(me, 'A');
		HTMLGen_put_character(me, 'D');
		break;
	    }
	    c = ';';
	}
    }

    *me->write_pointer++ = (char) c;

    if (c == '\n') {
	HTMLGen_flush(me);
	return;
    }

    /* Figure our whether we can break at this point
     */
    if ((!me->preformatted && (c == ' ' || c == '\t'))) {
	int new_cleanness = 3;

	if (me->write_pointer > (me->buffer + 1)) {
	    char delims[5];
	    char *p;

	    strcpy(delims, ",;:.");	/* @@@@ english bias */
	    p = StrChr(delims, me->write_pointer[-2]);
	    if (p)
		new_cleanness = (int) (p - delims + 6);
	    if (!me->in_attrval)
		new_cleanness += 10;
	}
	allow_break(me, new_cleanness, YES);
    }

    /*
     * Flush buffer out when full, or whenever the line is over the nominal
     * maximum and we can break at all
     */
    if (me->write_pointer >= me->buffer + me->buffer_maxchars ||
	(me->overflowed && me->cleanness)) {
	if (me->cleanness) {
	    char line_break_char = me->line_break[me->cleanness][0];
	    char *saved = me->line_break[me->cleanness];

	    if (me->delete_line_break_char[me->cleanness])
		saved++;
	    me->line_break[me->cleanness][0] = '\n';
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  (int) (me->line_break[me->cleanness] -
						 me->buffer + 1));
	    me->line_break[me->cleanness][0] = line_break_char;
	    {			/* move next line in */
		char *p = saved;
		char *q;

		for (q = me->buffer; p < me->write_pointer;)
		    *q++ = *p++;
	    }
	    me->cleanness = 0;
	    /* Now we have to check whether ther are any perfectly good breaks
	     * which weren't good enough for the last line but may be good
	     * enough for the next
	     */
	    {
		int i;

		for (i = 0; i <= MAX_CLEANNESS; i++) {
		    if (me->line_break[i] != NULL &&
			me->line_break[i] > saved) {
			me->line_break[i] = me->line_break[i] -
			    (saved - me->buffer);
			me->cleanness = i;
		    } else {
			me->line_break[i] = NULL;
		    }
		}
	    }

	    me->delete_line_break_char[0] = 0;
	    me->write_pointer = me->write_pointer - (saved - me->buffer);
	    me->overflowed = NO;

	} else {
	    (*me->targetClass.put_block) (me->target,
					  me->buffer,
					  me->buffer_maxchars);
	    me->write_pointer = me->buffer;
	    flush_breaks(me);
	    me->overflowed = YES;
	}
    }
}

/*	String handling
 *	---------------
 */
static void HTMLGen_put_string(HTStructured * me, const char *s)
{
    const char *p;

    for (p = s; *p; p++)
	HTMLGen_put_character(me, *p);
}

static void HTMLGen_write(HTStructured * me, const char *s,
			  int l)
{
    const char *p;

    for (p = s; p < (s + l); p++)
	HTMLGen_put_character(me, *p);
}

/*	Start Element
 *	-------------
 *
 * Within the opening tag, there may be spaces and the line may be broken at
 * these spaces.
 */
static int HTMLGen_start_element(HTStructured * me, int element_number,
				 const BOOL *present,
				 STRING2PTR value,
				 int charset GCC_UNUSED,
				 char **insert GCC_UNUSED)
{
    int i;
    BOOL was_preformatted = me->preformatted;
    HTTag *tag = &HTML_dtd.tags[element_number];

#if defined(USE_COLOR_STYLE)
    char *title = NULL;
    char *title_tmp = NULL;

    if (LYPreparsedSource) {
	char *myHash = NULL;

	/*
	 * Same logic as in HTML_start_element, copied from there.  - kw
	 */
	HTSprintf(&Style_className, ";%s", HTML_dtd.tags[element_number].name);
	StrAllocCopy(myHash, HTML_dtd.tags[element_number].name);
	if (class_string[0]) {
	    StrAllocCat(myHash, ".");
	    StrAllocCat(myHash, class_string);
	    HTSprintf(&Style_className, ".%s", class_string);
	}
	class_string[0] = '\0';
	strtolower(myHash);
	hcode = hash_code(myHash);
	strtolower(Style_className);

	if (TRACE_STYLE) {
	    fprintf(tfp, "CSSTRIM:%s -> %d", myHash, hcode);
	    if (hashStyles[hcode].code != hcode) {
		char *rp = strrchr(myHash, '.');

		fprintf(tfp, " (undefined) %s\n", myHash);
		if (rp) {
		    int hcd;

		    *rp = '\0';	/* trim the class */
		    hcd = hash_code(myHash);
		    fprintf(tfp, "CSS:%s -> %d", myHash, hcd);
		    if (hashStyles[hcd].code != hcd)
			fprintf(tfp, " (undefined) %s\n", myHash);
		    else
			fprintf(tfp, " ca=%d\n", hashStyles[hcd].color);
		}
	    } else
		fprintf(tfp, " ca=%d\n", hashStyles[hcode].color);
	}

	if (displayStyles[element_number + STARTAT].color > -2) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSSTRIM: start_element: top <%s>\n",
		     HTML_dtd.tags[element_number].name));
	    do_cstyle_flush(me);
	    HText_characterStyle(me->text, hcode, 1);
	}
	FREE(myHash);
    }
#endif /* USE_COLOR_STYLE */
    me->preformatted = YES;	/* free text within tags */
    HTMLGen_put_character(me, '<');
    HTMLGen_put_string(me, tag->name);
    if (present) {
	BOOL had_attr = NO;

	for (i = 0; i < tag->number_of_attributes; i++) {
	    if (present[i]) {
		had_attr = YES;
		HTMLGen_put_character(me, ' ');
		allow_break(me, 11, YES);
#ifdef USE_COLOR_STYLE
		/*
		 * Try to mimic HTML_start_element's special handling for
		 * HTML_LINK.  If applicable, color the displayed attribute /
		 * value pairs differently.  - kw
		 */
		if (LYPreparsedSource &&
		    element_number == HTML_LINK && !title &&
		    present[HTML_LINK_CLASS] && *value[HTML_LINK_CLASS] &&
		    !present[HTML_LINK_REV] &&
		    (present[HTML_LINK_REL] || present[HTML_LINK_HREF])) {
		    if (present[HTML_LINK_TITLE] && *value[HTML_LINK_TITLE]) {
			StrAllocCopy(title, value[HTML_LINK_TITLE]);
			LYTrimHead(title);
			LYTrimTail(title);
		    }
		    if ((!title || *title == '\0') && present[HTML_LINK_REL]) {
			StrAllocCopy(title, value[HTML_LINK_REL]);
		    }
		    if (title && *title) {
			HTSprintf0(&title_tmp, "link.%s.%s",
				   value[HTML_LINK_CLASS], title);
			CTRACE2(TRACE_STYLE,
				(tfp, "CSSTRIM:link=%s\n", title_tmp));

			do_cstyle_flush(me);
			HText_characterStyle(me->text, hash_code(title_tmp), 1);
		    }
		}
#endif
		HTMLGen_put_string(me, tag->attributes[i].name);
		if (value[i]) {
		    me->preformatted = was_preformatted;
		    me->in_attrval = YES;
		    if (StrChr(value[i], '"') == NULL) {
			HTMLGen_put_string(me, "=\"");
			HTMLGen_put_string(me, value[i]);
			HTMLGen_put_character(me, '"');
		    } else if (StrChr(value[i], '\'') == NULL) {
			HTMLGen_put_string(me, "='");
			HTMLGen_put_string(me, value[i]);
			HTMLGen_put_character(me, '\'');
		    } else {	/* attribute value has both kinds of quotes */
			const char *p;

			HTMLGen_put_string(me, "=\"");
			for (p = value[i]; *p; p++) {
			    if (*p != '"') {
				HTMLGen_put_character(me, *p);
			    } else {
				HTMLGen_put_string(me, "&#34;");
			    }
			}
			HTMLGen_put_character(me, '"');
		    }
		    me->preformatted = YES;
		    me->in_attrval = NO;
		}
	    }
	}
#ifdef USE_COLOR_STYLE
	if (had_attr && LYPreparsedSource && element_number == HTML_LINK) {
	    /*
	     * Clean up after special HTML_LINK handling - kw
	     */
	    if (title && *title) {
		do_cstyle_flush(me);
		HText_characterStyle(me->text, hash_code(title_tmp), 0);
		FREE(title_tmp);
	    }
	    FREE(title);
	}
#endif
	if (had_attr)
	    allow_break(me, 12, NO);
    }
    HTMLGen_put_string(me, ">");	/* got rid of \n LJM */

    /*
     * Make very specific HTML assumption that PRE can't be nested!
     */
    me->preformatted = (BOOL) ((element_number == HTML_PRE)
			       ? YES
			       : was_preformatted);

    /*
     * Can break after element start.
     */
    if (!me->preformatted && tag->contents != SGML_EMPTY) {
	if (HTML_dtd.tags[element_number].contents == SGML_ELEMENT)
	    allow_break(me, 15, NO);
	else
	    allow_break(me, 2, NO);
    }
#if defined(USE_COLOR_STYLE)
    /*
     * Same logic as in HTML_start_element, copied from there.  - kw
     */

    /* end really empty tags straight away */
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:begin_element:ending EMPTY element style\n"));
	do_cstyle_flush(me);
	HText_characterStyle(me->text, hcode, STACK_OFF);
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
    }
#endif /* USE_COLOR_STYLE */
    if (element_number == HTML_OBJECT && tag->contents == SGML_LITTERAL) {
	/*
	 * These conditions only approximate the ones used in HTML.c.  Let our
	 * SGML parser know that further content is to be parsed normally not
	 * literally.  - kw
	 */
	if (!present) {
	    return HT_PARSER_OTHER_CONTENT;
	} else if (!present[HTML_OBJECT_DECLARE] &&
		   !(present[HTML_OBJECT_NAME] &&
		     value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME])) {
	    if (present[HTML_OBJECT_SHAPES] ||
		!(present[HTML_OBJECT_USEMAP] &&
		  value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]))
		return HT_PARSER_OTHER_CONTENT;
	}
    }
    return HT_OK;
}

/*		End Element
 *		-----------
 *
 * When we end an element, the style must be returned to that in effect before
 * that element.  Note that anchors (etc?) don't have an associated style, so
 * that we must scan down the stack for an element with a defined style.  (In
 * fact, the styles should be linked to the whole stack not just the top one.)
 * TBL 921119
 */
static int HTMLGen_end_element(HTStructured * me, int element_number,
			       char **insert GCC_UNUSED)
{
    if (!me->preformatted &&
	HTML_dtd.tags[element_number].contents != SGML_EMPTY) {
	/*
	 * Can break before element end.
	 */
	if (HTML_dtd.tags[element_number].contents == SGML_ELEMENT)
	    allow_break(me, 14, NO);
	else
	    allow_break(me, 1, NO);
    }
    HTMLGen_put_string(me, "</");
    HTMLGen_put_string(me, HTML_dtd.tags[element_number].name);
    HTMLGen_put_character(me, '>');
    if (element_number == HTML_PRE) {
	me->preformatted = NO;
    }
#ifdef USE_COLOR_STYLE
    /*
     * Same logic as in HTML_end_element, copied from there.  - kw
     */
    TrimColorClass(HTML_dtd.tags[element_number].name,
		   Style_className, &hcode);

    if (LYPreparsedSource && !ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE:end_element: ending non-EMPTY style\n"));
	do_cstyle_flush(me);
	HText_characterStyle(me->text, hcode, STACK_OFF);
    }
#endif /* USE_COLOR_STYLE */
    return HT_OK;
}

/*		Expanding entities
 *		------------------
 *
 */
static int HTMLGen_put_entity(HTStructured * me, int entity_number)
{
    int nent = (int) HTML_dtd.number_of_entities;

    HTMLGen_put_character(me, '&');
    if (entity_number < nent) {
	HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
    }
    HTMLGen_put_character(me, ';');
    return HT_OK;
}

/*	Free an HTML object
 *	-------------------
 *
 */
static void HTMLGen_free(HTStructured * me)
{
    (*me->targetClass.put_character) (me->target, '\n');
    HTMLGen_flush(me);
    (*me->targetClass._free) (me->target);	/* ripple through */
#ifdef USE_COLOR_STYLE
    FREE(Style_className);
#endif
    FREE(me);
}

static void PlainToHTML_free(HTStructured * me)
{
    HTMLGen_end_element(me, HTML_PRE, 0);
    HTMLGen_free(me);
}

static void HTMLGen_abort(HTStructured * me, HTError e GCC_UNUSED)
{
    HTMLGen_free(me);
#ifdef USE_COLOR_STYLE
    FREE(Style_className);
#endif
}

static void PlainToHTML_abort(HTStructured * me, HTError e GCC_UNUSED)
{
    PlainToHTML_free(me);
}

/*	Structured Object Class
 *	-----------------------
 */
static const HTStructuredClass HTMLGeneration =		/* As opposed to print etc */
{
    "HTMLGen",
    HTMLGen_free,
    HTMLGen_abort,
    HTMLGen_put_character, HTMLGen_put_string, HTMLGen_write,
    HTMLGen_start_element, HTMLGen_end_element,
    HTMLGen_put_entity
};

/*	Subclass-specific Methods
 *	-------------------------
 */
HTStructured *HTMLGenerator(HTStream *output)
{
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

    if (me == NULL)
	outofmem(__FILE__, "HTMLGenerator");

    assert(me != NULL);

    me->isa = &HTMLGeneration;

    me->target = output;
    me->targetClass = *me->target->isa;		/* Copy pointers to routines for speed */

    me->write_pointer = me->buffer;
    flush_breaks(me);
    me->line_break[0] = me->buffer;
    me->cleanness = 0;
    me->overflowed = NO;
    me->delete_line_break_char[0] = NO;
    me->preformatted = NO;
    me->in_attrval = NO;

    /*
     * For what line length should we attempt to wrap ?  - kw
     */
    if (!LYPreparsedSource) {
	me->buffer_maxchars = 80;	/* work as before - kw */
    } else if (dump_output_width > 1) {
	me->buffer_maxchars = dump_output_width;	/* try to honor -width - kw */
    } else if (dump_output_immediately) {
	me->buffer_maxchars = 80;	/* try to honor -width - kw */
    } else {
	me->buffer_maxchars = (LYcolLimit - 1);
	if (me->buffer_maxchars < 38)	/* too narrow, let GridText deal */
	    me->buffer_maxchars = 40;
    }
    if (me->buffer_maxchars > 900)	/* likely not true - kw */
	me->buffer_maxchars = 78;
    if (me->buffer_maxchars > BUFFER_SIZE)	/* must not be larger! */
	me->buffer_maxchars = BUFFER_SIZE - 2;

    /*
     * If dump_output_immediately is set, there likely isn't anything after
     * this stream to interpret the Lynx special chars.  Also if they get
     * displayed via HTPlain, that will probably make non-breaking space chars
     * etc.  invisible.  So let's translate them to numerical character
     * references.  For debugging purposes we'll use the new hex format.
     */
    me->escape_specials = LYPreparsedSource;

#ifdef USE_COLOR_STYLE
    me->text = NULL;		/* Will be initialized when first needed. - kw */
    FREE(Style_className);
    class_string[0] = '\0';
#endif /* COLOR_STYLE */

    return me;
}

/*	Stream Object Class
 *	-------------------
 *
 *	This object just converts a plain text stream into HTML
 *	It is officially a structured strem but only the stream bits exist.
 *	This is just the easiest way of typecasting all the routines.
 */
static const HTStructuredClass PlainToHTMLConversion =
{
    "plaintexttoHTML",
    HTMLGen_free,
    PlainToHTML_abort,
    HTMLGen_put_character,
    HTMLGen_put_string,
    HTMLGen_write,
    NULL,			/* Structured stuff */
    NULL,
    NULL
};

/*	HTConverter from plain text to HTML Stream
 *	------------------------------------------
 */
HTStream *HTPlainToHTML(HTPresentation *pres GCC_UNUSED,
			HTParentAnchor *anchor GCC_UNUSED,
			HTStream *sink)
{
    HTStructured *me = (HTStructured *) malloc(sizeof(*me));

    if (me == NULL)
	outofmem(__FILE__, "PlainToHTML");

    assert(me != NULL);

    me->isa = (const HTStructuredClass *) &PlainToHTMLConversion;

    /*
     * Copy pointers to routines for speed.
     */
    me->target = sink;
    me->targetClass = *me->target->isa;
    me->write_pointer = me->buffer;
    flush_breaks(me);
    me->cleanness = 0;
    me->overflowed = NO;
    me->delete_line_break_char[0] = NO;
    /* try to honor -width - kw */
    me->buffer_maxchars = (dump_output_width > 1 ?
			   dump_output_width : 80);

    HTMLGen_put_string(me, "<HTML>\n<BODY>\n<PRE>\n");
    me->preformatted = YES;
    me->escape_specials = NO;
    me->in_attrval = NO;
    return (HTStream *) me;
}
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTMLGen.c,v 1.28 2009/01/03 01:27:53 tom Exp $
d18 2
a44 4
#define PUTC(c) (*me->targetClass.put_character)(me->target, c)
/* #define PUTS(s) (*me->targetClass.put_string)(me->target, s) */
#define PUTB(s,l) (*me->targetClass.put_block)(me->target, s, l)

d46 1
a46 1
char class_string[TEMPSTRINGSIZE];
a48 1
static char myHash[128];
d98 1
a98 1
				  me->write_pointer - me->buffer);
d146 1
a146 2
static void allow_break(HTStructured * me, int new_cleanness,
			BOOL dlbc)
d153 1
a153 1
    me->delete_line_break_char[new_cleanness] = dlbc;
d172 1
a172 1
static void HTMLGen_put_character(HTStructured * me, char c)
d200 1
a200 1
    *me->write_pointer++ = c;
d217 1
a217 1
	    p = strchr(delims, me->write_pointer[-2]);
d219 1
a219 1
		new_cleanness = p - delims + 6;
d241 2
a242 2
					  me->line_break[me->cleanness] -
					  me->buffer + 1);
d314 1
a314 1
				 const char **value,
d327 2
d333 1
a333 1
	strcpy(myHash, HTML_dtd.tags[element_number].name);
d335 2
a336 3
	    int len = (int) strlen(myHash);

	    sprintf(myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
d372 1
d394 1
a394 2
		    present[HTML_LINK_CLASS] &&
		    value && *value[HTML_LINK_CLASS] != '\0' &&
d420 1
a420 1
		    if (strchr(value[i], '"') == NULL) {
d424 1
a424 1
		    } else if (strchr(value[i], '\'') == NULL) {
d632 3
d717 3
@


1.4
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		HTML Generator
d337 1
a337 1
	    int len = strlen(myHash);
d470 3
a472 1
    me->preformatted = (element_number == HTML_PRE) ? YES : was_preformatted;
d569 1
a569 1
    int nent = HTML_dtd.number_of_entities;
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d2 12
a13 12
**		==============
**
**	This version of the HTML object sends HTML markup to the output stream.
**
** Bugs:	Line wrapping is not done at all.
**		All data handled as PCDATA.
**		Should convert old XMP, LISTING and PLAINTEXT to PRE.
**
**	It is not obvious to me right now whether the HEAD should be generated
**	from the incomming data or the anchor.	Currently it is from the former
**	which is cleanest.
*/
d37 1
d45 1
a45 1
PUBLIC char class_string[TEMPSTRINGSIZE];
d53 2
a54 2
**		-----------
*/
d56 3
a58 3
	CONST HTStreamClass *		isa;
	HTStream *			target;
	HTStreamClass			targetClass;	/* COPY for speed */
d62 14
a75 14
	CONST HTStructuredClass *	isa;
	HTStream *			target;
	HTStreamClass			targetClass;	/* COPY for speed */

	char				buffer[BUFFER_SIZE+1]; /* 1for NL */
	int				buffer_maxchars;
	char *				write_pointer;
	char *				line_break [MAX_CLEANNESS+1];
	int				cleanness;
	BOOL				overflowed;
	BOOL				delete_line_break_char[MAX_CLEANNESS+1];
	BOOL				preformatted;
	BOOL				escape_specials;
	BOOL				in_attrval;
d77 1
a77 1
	HText *				text;
d82 2
a83 2
**	------------
*/
d85 1
a85 2
PRIVATE void flush_breaks ARGS1(
	HTStructured *,		me)
d88 2
a89 1
    for (i=0; i<= MAX_CLEANNESS; i++) {
d94 1
a94 2
PRIVATE void HTMLGen_flush ARGS1(
	HTStructured *,		me)
d96 3
a98 3
    (*me->targetClass.put_block)(me->target,
				 me->buffer,
				 me->write_pointer - me->buffer);
d107 22
a128 25
 *  We need to flush our buffer each time before we effect a color style
 *  change, this also relies on the subsequent stage not doing any
 *  buffering - this is currently true, in cases where it matters the
 *  target stream should be the HTPlain converter.
 *  The flushing currently prevents reasonable line breaking in lines
 *  with tags.  Since color styles help visual scanning of displayed
 *  source lines, and long lines are wrapped in GridText anyway, this
 *  is probably acceptable (or even A Good Thing - more to see in one
 *  screenful).
 *  The pointer to the HText structure is initialized here before
 *  we effect the first style change.  Getting it from the global
 *  HTMainText variable isn't very clean, since it relies on the fact
 *  that HText_new() has already been called for the current stream
 *  stack's document by the time we start processing the first element;
 *  we rely on HTMLGenerator's callers (HTMLParsedPresent in particular)
 *  to guarantee this when it matters.  Normally the target stream will
 *  have been setup by HTPlainPresent, which does what we need in this
 *  respect.  (A check whether we have the right output stream could be
 *  done by checking that targetClass.name is "PlainPresenter" or similar.)
 *
 *  All special color style handling is only done if LYPreparsedSource
 *  is set.  We could always do it for displaying source generated by
 *  an internal gateway, but this makes the rule more simple for the
 *  user: color styles are applied to html source only with the
 *  -preparsed flag. - kw
d130 1
a130 2
PRIVATE void do_cstyle_flush ARGS1(
	HTStructured *,		me)
d142 3
a144 3
**
**	We keep track of all the breaks for when we chop the line
*/
d146 2
a147 4
PRIVATE void allow_break ARGS3(
	HTStructured *, me,
	int,		new_cleanness,
	BOOL,		dlbc)
d149 2
a150 1
    if (dlbc && me->write_pointer == me->buffer) dlbc = NO;
d152 2
a153 2
			 dlbc ? me->write_pointer - 1 /* Point to space */
			      : me->write_pointer ;   /* point to gap */
d161 13
a173 15
**	------------------
**
**	The tricky bits are the line break handling.  This attempts
**	to synchrononise line breaks on sentence or phrase ends.  This
**	is important if one stores SGML files in a line-oriented code
**	repository, so that if a small change is made, line ends don't
**	shift in a ripple-through to apparently change a large part of the
**	file.  We give extra "cleanness" to spaces appearing directly
**	after periods (full stops), [semi]colons and commas.
**	   This should make the source files easier to read and modify
**	by hand, too, though this is not a primary design consideration. TBL
*/
PRIVATE void HTMLGen_put_character ARGS2(
	HTStructured *,		me,
	char,			c)
d177 1
a177 1
	    c == LY_SOFT_HYPHEN) { /* recursion... */
d181 2
a182 2
	    switch(c) {
	    case HT_NON_BREAK_SPACE: /* &#xA0; */
d186 1
a186 1
	    case HT_EN_SPACE: /* &#x2002; */
d192 1
a192 1
	    case LY_SOFT_HYPHEN: /* &#xAD; */
d209 1
a209 1
    */
d212 1
d215 3
a217 2
	    char * p;
	    strcpy(delims, ",;:.");		/* @@@@ english bias */
d219 4
a222 2
	    if (p) new_cleanness = p - delims + 6;
	    if (!me->in_attrval) new_cleanness += 10;
d228 2
a229 2
     *	Flush buffer out when full, or whenever the line is over
     *	the nominal maximum and we can break at all
d235 1
a235 1
	    char * saved = me->line_break[me->cleanness];
d237 2
a238 1
	    if (me->delete_line_break_char[me->cleanness]) saved++;
d240 4
a243 3
	    (*me->targetClass.put_block)(me->target,
					 me->buffer,
			       me->line_break[me->cleanness] - me->buffer + 1);
d245 2
a246 2
	    {  /* move next line in */
		char * p = saved;
d248 2
a249 1
		for (q = me->buffer; p < me->write_pointer; )
d254 3
a256 3
	    ** which weren't good enough for the last line but may be
	    **	good enough for the next
	    */
d259 2
a260 1
		for(i=0; i <= MAX_CLEANNESS; i++) {
d264 1
a264 1
						(saved-me->buffer);
d273 1
a273 1
	    me->write_pointer = me->write_pointer - (saved-me->buffer);
d277 3
a279 3
	    (*me->targetClass.put_block)(me->target,
					 me->buffer,
					 me->buffer_maxchars);
d288 3
a290 5
**	---------------
*/
PRIVATE void HTMLGen_put_string ARGS2(
	HTStructured *,		me,
	CONST char *,		s)
d292 1
a292 1
    CONST char * p;
d298 2
a299 4
PRIVATE void HTMLGen_write ARGS3(
	HTStructured *,		me,
	CONST char *,		s,
	int,			l)
d301 1
a301 1
    CONST char * p;
d308 10
a317 12
**	-------------
**
**	Within the opening tag, there may be spaces
**	and the line may be broken at these spaces.
*/
PRIVATE int HTMLGen_start_element ARGS6(
	HTStructured *,		me,
	int,			element_number,
	CONST BOOL*,		present,
	CONST char **,		value,
	int,			charset GCC_UNUSED,
	char **,		insert GCC_UNUSED)
d321 1
a321 1
    HTTag * tag = &HTML_dtd.tags[element_number];
d329 1
a329 1
	 *  Same logic as in HTML_start_element, copied from there. - kw
d331 3
a333 4
	HTSprintf (&Style_className, ";%s", HTML_dtd.tags[element_number].name);
	strcpy (myHash, HTML_dtd.tags[element_number].name);
	if (class_string[0])
	{
d335 3
a337 2
	    sprintf (myHash + len, ".%.*s", (int) sizeof(myHash) - len - 2, class_string);
	    HTSprintf (&Style_className, ".%s", class_string);
d344 1
a344 2
	if (TRACE_STYLE)
	{
d346 1
a346 2
	    if (hashStyles[hcode].code!=hcode)
	    {
d348 1
d350 1
a350 2
		if (rp)
		{
d352 2
a353 1
		    *rp = '\0'; /* trim the class */
d356 1
a356 1
		    if (hashStyles[hcd].code!=hcd)
d361 1
a361 2
	    }
	    else
d365 1
a365 2
	if (displayStyles[element_number + STARTAT].color > -2) /* actually set */
	{
d368 1
a368 1
			  HTML_dtd.tags[element_number].name));
d379 1
d387 3
a389 3
		 *  Try to mimic HTML_start_element's special handling
		 *  for HTML_LINK.  If applicable, color the displayed
		 *  attribute / value pairs differently. - kw
d394 1
a394 1
		    value && *value[HTML_LINK_CLASS]!='\0' &&
d402 1
a402 1
		    if ((!title || *title=='\0') && present[HTML_LINK_REL]) {
d428 3
a430 2
		    } else {  /* attribute value has both kinds of quotes */
			CONST char *p;
d449 1
a449 1
	     *  Clean up after special HTML_LINK handling - kw
d462 1
a462 1
    HTMLGen_put_string(me, ">"); /* got rid of \n LJM */
d465 1
a465 1
     *	Make very specific HTML assumption that PRE can't be nested!
d467 1
a467 1
    me->preformatted = (element_number == HTML_PRE)  ? YES : was_preformatted;
d470 1
a470 1
     *	Can break after element start.
a477 1

d480 1
a480 1
     *  Same logic as in HTML_start_element, copied from there. - kw
d484 1
a484 2
    if (LYPreparsedSource && ReallyEmptyTagNum(element_number))
    {
d495 3
a497 3
	 *  These conditions only approximate the ones used in HTML.c.
	 *  Let our SGML parser know that further content is to be parsed
	 *  normally not literally. - kw
d502 1
a502 1
		   !(present[HTML_OBJECT_NAME]  &&
d514 10
a523 14
**		-----------
**
*/
/*	When we end an element, the style must be returned to that
**	in effect before that element.	Note that anchors (etc?)
**	don't have an associated style, so that we must scan down the
**	stack for an element with a defined style. (In fact, the styles
**	should be linked to the whole stack not just the top one.)
**	TBL 921119
*/
PRIVATE int HTMLGen_end_element ARGS3(
	HTStructured *,		me,
	int,			element_number,
	char **,		insert GCC_UNUSED)
d528 1
a528 1
	 *  Can break before element end.
d543 1
a543 1
     *  Same logic as in HTML_end_element, copied from there. - kw
d559 4
a562 6
**		------------------
**
*/
PRIVATE int HTMLGen_put_entity ARGS2(
	HTStructured *,		me,
	int,			entity_number)
d568 1
a568 1
      HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
d575 4
a578 5
**	-------------------
**
*/
PRIVATE void HTMLGen_free ARGS1(
	HTStructured *,		me)
d580 1
a580 1
    (*me->targetClass.put_character)(me->target, '\n');
d582 1
a582 1
    (*me->targetClass._free)(me->target);	/* ripple through */
d589 1
a589 2
PRIVATE void PlainToHTML_free ARGS1(
	HTStructured *,		me)
d595 1
a595 3
PRIVATE void HTMLGen_abort ARGS2(
	HTStructured *,		me,
	HTError,		e GCC_UNUSED)
d603 1
a603 3
PRIVATE void PlainToHTML_abort ARGS2(
	HTStructured *,		me,
	HTError,		e GCC_UNUSED)
d609 3
a611 3
**	-----------------------
*/
PRIVATE CONST HTStructuredClass HTMLGeneration = /* As opposed to print etc */
d613 6
a618 6
	"HTMLGen",
	HTMLGen_free,
	HTMLGen_abort,
	HTMLGen_put_character,	HTMLGen_put_string, HTMLGen_write,
	HTMLGen_start_element,	HTMLGen_end_element,
	HTMLGen_put_entity
d622 5
a626 3
**	-------------------------
*/
extern int LYcols;			/* LYCurses.h, set in LYMain.c	*/
a627 4
PUBLIC HTStructured * HTMLGenerator ARGS1(
	HTStream *,		output)
{
    HTStructured* me = (HTStructured*)malloc(sizeof(*me));
d633 1
a633 1
    me->targetClass = *me->target->isa; /* Copy pointers to routines for speed*/
d638 1
a638 1
    me->cleanness =	0;
d641 1
a641 1
    me->preformatted =	NO;
d645 1
a645 1
     *	For what line length should we attempt to wrap ? - kw
d648 1
a648 1
	me->buffer_maxchars = 80; /* work as before - kw */
d650 1
a650 1
	me->buffer_maxchars = dump_output_width; /* try to honor -width - kw */
d652 1
a652 1
	me->buffer_maxchars = 80; /* try to honor -width - kw */
d654 2
a655 2
	me->buffer_maxchars = LYcols - 2;
	if (me->buffer_maxchars < 38) /* too narrow, let GridText deal */
d658 1
a658 1
    if (me->buffer_maxchars > 900) /* likely not true - kw */
d660 1
a660 1
    if (me->buffer_maxchars > BUFFER_SIZE) /* must not be larger! */
d664 5
a668 6
     *	If dump_output_immediately is set, there likely isn't anything
     *	after this stream to interpret the Lynx special chars.	Also
     *	if they get displayed via HTPlain, that will probably make
     *	non-breaking space chars etc. invisible.  So let's translate
     *	them to numerical character references.  For debugging
     *	purposes we'll use the new hex format.
d673 1
a673 1
    me->text = NULL;	/* Will be initialized when first needed. - kw */
d682 7
a688 7
**	-------------------
**
**	This object just converts a plain text stream into HTML
**	It is officially a structured strem but only the stream bits exist.
**	This is just the easiest way of typecasting all the routines.
*/
PRIVATE CONST HTStructuredClass PlainToHTMLConversion =
d690 9
a698 9
	"plaintexttoHTML",
	HTMLGen_free,
	PlainToHTML_abort,
	HTMLGen_put_character,
	HTMLGen_put_string,
	HTMLGen_write,
	NULL,		/* Structured stuff */
	NULL,
	NULL
d702 5
a706 6
**	------------------------------------------
*/
PUBLIC HTStream* HTPlainToHTML ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor GCC_UNUSED,
	HTStream *,		sink)
d708 2
a709 1
    HTStructured *me = (HTStructured *)malloc(sizeof(*me));
d712 1
a712 1
    me->isa = (CONST HTStructuredClass *)&PlainToHTMLConversion;
d715 1
a715 1
     *	Copy pointers to routines for speed.
d721 1
a721 1
    me->cleanness =	0;
d732 1
a732 1
    return (HTStream*) me;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d36 1
a38 2
extern BOOLEAN LYPreparsedSource;	/* Show source as preparsed?	*/

d85 1
a85 1
	HTStructured *, 	me)
d94 1
a94 1
	HTStructured *, 	me)
d134 1
a134 1
	HTStructured *, 	me)
d179 1
a179 1
	HTStructured *, 	me,
d182 1
a182 1
    if (me->escape_specials && (unsigned char)c < 32) {
d290 1
a290 1
	HTStructured *, 	me,
d300 1
a300 1
	HTStructured *, 	me,
d316 2
a317 2
PRIVATE void HTMLGen_start_element ARGS6(
	HTStructured *, 	me,
d340 2
a342 2
	    strcat (myHash, ".");
	    strcat (myHash, class_string);
d349 1
a349 1
	if (TRACE)
d354 1
a354 1
		char *rp=strrchr(myHash, '.');
d359 1
a359 1
		    *rp='\0'; /* trim the class */
d374 3
a376 2
	    CTRACE(tfp, "CSSTRIM: start_element: top <%s>\n",
		   HTML_dtd.tags[element_number].name);
d415 2
a416 1
			CTRACE(tfp, "CSSTRIM:link=%s\n", title_tmp);
d490 2
a491 5
/* end really empty tags straight away */
#define REALLY_EMPTY(e) ((HTML_dtd.tags[e].contents == SGML_EMPTY) && \
			 !(HTML_dtd.tags[e].flags & Tgf_nreie))

    if (LYPreparsedSource && REALLY_EMPTY(element_number))
d493 2
a494 1
	CTRACE(tfp, "STYLE:begin_element:ending EMPTY element style\n");
a495 3
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
a496 1
#endif /* USE_HASH */
d501 18
d532 2
a533 2
PRIVATE void HTMLGen_end_element ARGS3(
	HTStructured *, 	me,
d560 3
a562 3
    if (LYPreparsedSource && !REALLY_EMPTY(element_number))
    {
	CTRACE(tfp, "STYLE:end_element: ending non-EMPTY style\n");
a563 3
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
a564 1
#endif /* USE_HASH */
d567 1
d575 1
a575 1
	HTStructured *, 	me,
d593 1
a593 1
	HTStructured *, 	me)
d605 1
a605 1
	HTStructured *, 	me)
d612 1
a612 1
	HTStructured *, 	me,
d622 1
a622 1
	HTStructured *, 	me,
a644 2
extern BOOL dump_output_immediately;	/* TRUE if no interactive user	*/
extern int dump_output_width;		/* -width instead of 80 	*/
@


1.1
log
@Initial revision
@
text
@d15 1
a15 2
#include "HTUtils.h"
#include "tcp.h"
d22 1
a22 1
#include "HTMLGen.h"
d24 11
a34 5
#include <stdio.h>
#include "HTMLDTD.h"
#include "HTStream.h"
#include "SGML.h"
#include "HTFormat.h"
d36 1
a36 1
#include "LYLeaks.h"
d38 1
a38 1
#define FREE(x) if (x) {free(x); x = NULL;}
d44 8
d76 3
d106 40
d170 1
a170 1
**	to synchrononise line breaks on sentence or phrase ends. This
d174 1
a174 1
**	file. We give extra "cleanness" to spaces appearing directly
d184 1
a184 1
	if (c == HT_NON_BREAK_SPACE || c == HT_EM_SPACE ||
d194 1
a194 1
	    case HT_EM_SPACE: /* &#x2003; */
d198 1
a198 1
		HTMLGen_put_character(me, '3');
d329 53
d392 30
d451 13
d483 23
d540 18
d588 3
d606 3
a636 1
extern BOOLEAN LYPreparsedSource;	/* Show source as preparsed?	*/
d686 6
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
