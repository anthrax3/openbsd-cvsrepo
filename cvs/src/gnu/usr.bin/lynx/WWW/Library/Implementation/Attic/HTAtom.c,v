head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAtom.c,v 1.19 2013/11/28 11:11:05 tom Exp $
 *
 *			Atoms: Names to numbers			HTAtom.c
 *			=======================
 *
 *	Atoms are names which are given representative pointer values
 *	so that they can be stored more efficiently, and comparisons
 *	for equality done more efficiently.
 *
 *	Atoms are kept in a hash table consisting of an array of linked lists.
 *
 * Authors:
 *	TBL	Tim Berners-Lee, WorldWideWeb project, CERN
 *	(c) Copyright CERN 1991 - See Copyright.html
 *
 */

#include <HTUtils.h>

#define HASH_SIZE	101	/* Tunable */
#include <HTAtom.h>

#include <HTList.h>

#include <LYexit.h>
#include <LYLeaks.h>

static HTAtom *hash_table[HASH_SIZE];
static BOOL initialised = NO;

/*
 *	To free off all atoms.
 */
#ifdef LY_FIND_LEAKS
static void free_atoms(void);
#endif

/*
 *	Alternate hashing function.
 */
#define HASH_FUNCTION(cp_hash) ((strlen(cp_hash) * UCH(*cp_hash)) % HASH_SIZE)

HTAtom *HTAtom_for(const char *string)
{
    size_t hash;
    HTAtom *a;

    /* First time around, clear hash table
     */
    /*
     * Memory leak fixed.
     * 05-29-94 Lynx 2-3-1 Garrett Arch Blythe
     */
    if (!initialised) {
	int i;

	for (i = 0; i < HASH_SIZE; i++)
	    hash_table[i] = (HTAtom *) 0;
	initialised = YES;
#ifdef LY_FIND_LEAKS
	atexit(free_atoms);
#endif
    }

    /*          Generate hash function
     */
    hash = HASH_FUNCTION(string);

    /*          Search for the string in the list
     */
    for (a = hash_table[hash]; a; a = a->next) {
	if (0 == strcasecomp(a->name, string)) {
	    /* CTRACE((tfp, "HTAtom: Old atom %p for `%s'\n", a, string)); */
	    return a;		/* Found: return it */
	}
    }

    /*          Generate a new entry
     */
    a = (HTAtom *) malloc(sizeof(*a));
    if (a == NULL)
	outofmem(__FILE__, "HTAtom_for");

    assert(a != NULL);

    a->name = (char *) malloc(strlen(string) + 1);
    if (a->name == NULL)
	outofmem(__FILE__, "HTAtom_for");

    assert(a->name != NULL);

    strcpy(a->name, string);
    a->next = hash_table[hash];	/* Put onto the head of list */
    hash_table[hash] = a;
#ifdef NOT_DEFINED
    CTRACE((tfp, "HTAtom: New atom %p for `%s'\n", a, string));
#endif /* NOT_DEFINED */
    return a;
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free off all atoms.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		To be used at program exit.
 *	Revision History:
 *		05-29-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_atoms(void)
{
    auto int i_counter;
    HTAtom *HTAp_freeme;

    /*
     * Loop through all lists of atoms.
     */
    for (i_counter = 0; i_counter < HASH_SIZE; i_counter++) {
	/*
	 * Loop through the list.
	 */
	while (hash_table[i_counter] != NULL) {
	    /*
	     * Free off atoms and any members.
	     */
	    HTAp_freeme = hash_table[i_counter];
	    hash_table[i_counter] = HTAp_freeme->next;
	    FREE(HTAp_freeme->name);
	    FREE(HTAp_freeme);
	}
    }
}
#endif /* LY_FIND_LEAKS */

static BOOL mime_match(const char *name,
		       const char *templ)
{
    if (name && templ) {
	static char *n1 = NULL;
	static char *t1 = NULL;
	char *n2;
	char *t2;

	StrAllocCopy(n1, name);	/* These also free the ones */
	StrAllocCopy(t1, templ);	/* from previous call.  */

	if (!(n2 = StrChr(n1, '/')) || !(t2 = StrChr(t1, '/')))
	    return NO;

	*(n2++) = (char) 0;
	*(t2++) = (char) 0;

	if ((0 == strcmp(t1, "*") || 0 == strcmp(t1, n1)) &&
	    (0 == strcmp(t2, "*") || 0 == strcmp(t2, n2)))
	    return YES;
    }
    return NO;
}

HTList *HTAtom_templateMatches(const char *templ)
{
    HTList *matches = HTList_new();

    if (initialised && templ) {
	int i;
	HTAtom *cur;

	for (i = 0; i < HASH_SIZE; i++) {
	    for (cur = hash_table[i]; cur; cur = cur->next) {
		if (mime_match(cur->name, templ))
		    HTList_addObject(matches, (void *) cur);
	    }
	}
    }
    return matches;
}
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			Atoms: Names to numbers			HTAtom.c
d46 1
a46 1
    int hash;
d84 3
d90 3
d149 1
a149 1
	if (!(n2 = strchr(n1, '/')) || !(t2 = strchr(t1, '/')))
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 13
a14 13
**			=======================
**
**	Atoms are names which are given representative pointer values
**	so that they can be stored more efficiently, and comparisons
**	for equality done more efficiently.
**
**	Atoms are kept in a hash table consisting of an array of linked lists.
**
** Authors:
**	TBL	Tim Berners-Lee, WorldWideWeb project, CERN
**	(c) Copyright CERN 1991 - See Copyright.html
**
*/
d18 1
a18 1
#define HASH_SIZE	101		/* Tunable */
d26 2
a27 2
PRIVATE HTAtom * hash_table[HASH_SIZE];
PRIVATE BOOL initialised = NO;
d33 1
a33 1
PRIVATE void free_atoms NOPARAMS;
d41 1
a41 1
PUBLIC HTAtom * HTAtom_for ARGS1(CONST char *, string)
d44 1
a44 1
    HTAtom * a;
d46 2
a47 2
    /*		First time around, clear hash table
    */
d49 2
a50 2
     *	Memory leak fixed.
     *  05-29-94 Lynx 2-3-1 Garrett Arch Blythe
d54 1
d63 2
a64 2
    /*		Generate hash function
    */
d67 2
a68 2
    /*		Search for the string in the list
    */
d72 1
a72 1
	    return a;				/* Found: return it */
d76 3
a78 3
    /*		Generate a new entry
    */
    a = (HTAtom *)malloc(sizeof(*a));
d81 1
a81 1
    a->name = (char *)malloc(strlen(string)+1);
d85 1
a85 1
    a->next = hash_table[hash];		/* Put onto the head of list */
d103 1
a103 1
PRIVATE void free_atoms NOARGS
d105 7
a111 2
	auto int i_counter;
	HTAtom *HTAp_freeme;
d113 1
a113 1
	 *	Loop through all lists of atoms.
d115 8
a122 13
	for (i_counter = 0; i_counter < HASH_SIZE; i_counter++)	{
		/*
		 *	Loop through the list.
		 */
		while (hash_table[i_counter] != NULL)	{
			/*
			 *	Free off atoms and any members.
			 */
			HTAp_freeme = hash_table[i_counter];
			hash_table[i_counter] = HTAp_freeme->next;
			FREE(HTAp_freeme->name);
			FREE(HTAp_freeme);
		}
d124 1
d128 2
a129 2
PRIVATE BOOL mime_match ARGS2(CONST char *, name,
			      CONST char *, templ)
d137 2
a138 2
	StrAllocCopy(n1, name);		/* These also free the ones	*/
	StrAllocCopy(t1, templ);	/* from previous call.		*/
d140 1
a140 1
	if (!(n2 = strchr(n1, '/'))  ||  !(t2 = strchr(t1, '/')))
d143 2
a144 2
	*(n2++) = (char)0;
	*(t2++) = (char)0;
d153 1
a153 2

PUBLIC HTList *HTAtom_templateMatches ARGS1(CONST char *, templ)
d162 1
a162 1
	    for (cur = hash_table[i];  cur;  cur = cur->next) {
d164 1
a164 1
		    HTList_addObject(matches, (void*)cur);
a169 1

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d53 1
a53 1
        int i;
d70 1
a70 1
    	    /* CTRACE((tfp, "HTAtom: Old atom %p for `%s'\n", a, string)); */
d79 1
a79 1
        outofmem(__FILE__, "HTAtom_for");
d82 1
a82 1
        outofmem(__FILE__, "HTAtom_for");
d115 1
a115 1
		 	 *	Free off atoms and any members.
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d39 1
a39 1
#define HASH_FUNCTION(cp_hash) ((strlen(cp_hash) * (unsigned char)*cp_hash) % HASH_SIZE)
d70 1
a70 1
    	    /* CTRACE(tfp, "HTAtom: Old atom %p for `%s'\n", a, string); */
d87 1
a87 1
    CTRACE(tfp, "HTAtom: New atom %p for `%s'\n", a, string);
@


1.1
log
@Initial revision
@
text
@d15 2
a16 1
#include "HTUtils.h"
d19 1
a19 4
#include "HTAtom.h"

/*#include <stdio.h> included by HTUtils.h -- FM *//* joe@@athena, TBL 921019 */
#include <string.h>
d21 1
a21 1
#include "HTList.h"
d23 2
a24 4
#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d32 1
d34 1
d45 1
a45 1
    
d57 1
d59 1
d61 1
a61 1
    
d65 1
a65 1
    
d70 1
a70 2
    	    /* if (TRACE) fprintf(stderr,
	    	"HTAtom: Old atom %p for `%s'\n", a, string); */
d74 1
a74 1
    
d87 1
a87 2
    if (TRACE)
	fprintf(stderr, "HTAtom: New atom %p for `%s'\n", a, string);
d92 1
d124 1
d150 1
a150 1
	
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
