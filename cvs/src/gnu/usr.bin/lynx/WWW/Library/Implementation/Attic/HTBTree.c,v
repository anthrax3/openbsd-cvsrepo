head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*                  Binary Tree for sorting things
 *                  ==============================
 *                      Author: Arthur Secret
 *
 *       4 March 94: Bug fixed in the balancing procedure
 *
 */

#include <HTUtils.h>
#include <HTBTree.h>

#define MAXIMUM(a,b) ((a)>(b)?(a):(b))

#include <LYLeaks.h>

/*********************************************************
 * This function returns an HTBTree with memory allocated
 * for it when given a mean to compare things
 */
HTBTree *HTBTree_new(HTComparer comp)
{
    HTBTree *tree = typeMalloc(HTBTree);

    if (tree == NULL)
	outofmem(__FILE__, "HTBTree_new");

    assert(tree != NULL);

    tree->compare = comp;
    tree->top = NULL;

    return tree;
}

/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElement_free(HTBTElement *element)
{
    if (element) {
	if (element->left != NULL)
	    HTBTElement_free(element->left);
	if (element->right != NULL)
	    HTBTElement_free(element->right);
	FREE(element);
    }
}

/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTree_free(HTBTree *tree)
{
    HTBTElement_free(tree->top);
    FREE(tree);
}

/*********************************************************
 * This void will free the memory allocated for one element
 */
static void HTBTElementAndObject_free(HTBTElement *element)
{
    if (element) {		/* Just in case nothing was in the tree anyway */
	if (element->left != NULL)
	    HTBTElementAndObject_free(element->left);
	if (element->right != NULL)
	    HTBTElementAndObject_free(element->right);
	FREE(element->object);
	FREE(element);
    }
}

/*************************************************************
 * This void will free the memory allocated for the whole tree
 */
void HTBTreeAndObject_free(HTBTree *tree)
{
    HTBTElementAndObject_free(tree->top);
    FREE(tree);
}

/*********************************************************************
 * Returns a pointer to equivalent object in a tree or NULL if none.
 */
void *HTBTree_search(HTBTree *tree,
		     void *object)
{
    HTBTElement *cur = tree->top;
    int res;

    while (cur != NULL) {
	res = tree->compare(object, cur->object);

	if (res == 0)
	    return cur->object;
	else if (res < 0)
	    cur = cur->left;
	else if (res > 0)
	    cur = cur->right;
    }
    return NULL;
}

/*********************************************************************
 * This void is the core of HTBTree.c . It will
 *       1/ add a new element to the tree at the right place
 *		so that the tree remains sorted
 *       2/ balance the tree to be as fast as possible when reading it
 */
void HTBTree_add(HTBTree *tree,
		 void *object)
{
    HTBTElement *father_of_element;
    HTBTElement *added_element;
    HTBTElement *forefather_of_element;
    HTBTElement *father_of_forefather;
    BOOL father_found, top_found;
    int depth, depth2, corrections;

    /* father_of_element is a pointer to the structure that is the father of
     * the new object "object".  added_element is a pointer to the structure
     * that contains or will contain the new object "object". 
     * father_of_forefather and forefather_of_element are pointers that are
     * used to modify the depths of upper elements, when needed.
     *
     * father_found indicates by a value NO when the future father of "object"
     * is found.  top_found indicates by a value NO when, in case of a
     * difference of depths < 2, the top of the tree is encountered and forbids
     * any further try to balance the tree.  corrections is an integer used to
     * avoid infinite loops in cases such as:
     *
     *             3                        3
     *          4                              4
     *           5                            5
     *
     * 3 is used here to show that it need not be the top of the tree.
     */

    /*
     * 1/ Adding of the element to the binary tree
     */

    if (tree->top == NULL) {
	tree->top = typeMalloc(HTBTElement);

	if (tree->top == NULL)
	    outofmem(__FILE__, "HTBTree_add");

	assert(tree->top != NULL);

	tree->top->up = NULL;
	tree->top->object = object;
	tree->top->left = NULL;
	tree->top->left_depth = 0;
	tree->top->right = NULL;
	tree->top->right_depth = 0;
    } else {
	father_found = YES;
	father_of_element = tree->top;
	added_element = NULL;
	father_of_forefather = NULL;
	forefather_of_element = NULL;
	while (father_found) {
	    int res = tree->compare(object, father_of_element->object);

	    if (res < 0) {
		if (father_of_element->left != NULL)
		    father_of_element = father_of_element->left;
		else {
		    father_found = NO;
		    father_of_element->left = typeMalloc(HTBTElement);

		    if (father_of_element->left == NULL)
			outofmem(__FILE__, "HTBTree_add");

		    assert(father_of_element->left != NULL);

		    added_element = father_of_element->left;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    } else {		/* res >= 0 */
		if (father_of_element->right != NULL) {
		    father_of_element = father_of_element->right;
		} else {
		    father_found = NO;
		    father_of_element->right = typeMalloc(HTBTElement);

		    if (father_of_element->right == NULL)
			outofmem(__FILE__, "HTBTree_add");
		    assert(father_of_element->right != NULL);

		    added_element = father_of_element->right;
		    added_element->up = father_of_element;
		    added_element->object = object;
		    added_element->left = NULL;
		    added_element->left_depth = 0;
		    added_element->right = NULL;
		    added_element->right_depth = 0;
		}
	    }
	}

	/*
	 * Changing of all depths that need to be changed
	 */
	father_of_forefather = father_of_element;
	forefather_of_element = added_element;
	do {
	    if (father_of_forefather->left == forefather_of_element) {
		depth = father_of_forefather->left_depth;
		father_of_forefather->left_depth = 1
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
		depth2 = father_of_forefather->left_depth;
	    } else {
		depth = father_of_forefather->right_depth;
		father_of_forefather->right_depth = 1
		    + MAXIMUM(forefather_of_element->right_depth,
			      forefather_of_element->left_depth);
		depth2 = father_of_forefather->right_depth;
	    }
	    forefather_of_element = father_of_forefather;
	    father_of_forefather = father_of_forefather->up;
	} while ((depth != depth2) && (father_of_forefather != NULL));

	/*
	 * 2/ Balancing the binary tree, if necessary
	 */
	top_found = YES;
	corrections = 0;
	while ((top_found) && (corrections < 7)) {
	    if ((abs(father_of_element->left_depth
		     - father_of_element->right_depth)) < 2) {
		if (father_of_element->up != NULL)
		    father_of_element = father_of_element->up;
		else
		    top_found = NO;
	    } else {		/* We start the process of balancing */

		corrections = corrections + 1;
		/*
		 * corrections is an integer used to avoid infinite
		 * loops in cases such as:
		 *
		 *             3                        3
		 *          4                              4
		 *           5                            5
		 *
		 * 3 is used to show that it need not be the top of the tree
		 * But let's avoid these two exceptions anyhow
		 * with the two following conditions (4 March 94 - AS)
		 */

		if (father_of_element->left == NULL) {
		    if ((father_of_element->right != NULL)
			&& (father_of_element->right->right == NULL)
			&& (father_of_element->right->left != NULL)
			&& (father_of_element->right->left->left == NULL)
			&& (father_of_element->right->left->right == NULL)) {
			corrections = 7;
		    }
		} else {
		    if ((father_of_element->right == NULL)
			&& (father_of_element->left->left == NULL)
			&& (father_of_element->left->right != NULL)
			&& (father_of_element->left->right->right == NULL)
			&& (father_of_element->left->right->left == NULL)) {
			corrections = 7;
		    }
		}

		if ((father_of_element->left != NULL)
		    && (father_of_element->left_depth > father_of_element->right_depth)) {
		    added_element = father_of_element->left;
		    father_of_element->left_depth = added_element->right_depth;
		    added_element->right_depth = 1
			+ MAXIMUM(father_of_element->right_depth,
				  father_of_element->left_depth);
		    if (father_of_element->up != NULL) {
			/* Bug fixed in March 94  -  AS */
			BOOL first_time;

			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
			first_time = YES;
			do {
			    if (father_of_forefather->left
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);

				depth2 = father_of_forefather->left_depth;
			    } else {
				depth = father_of_forefather->right_depth;
				if (first_time) {
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->right_depth;
			    }
			    forefather_of_element = forefather_of_element->up;
			    father_of_forefather = father_of_forefather->up;
			} while ((depth != depth2) &&
				 (father_of_forefather != NULL));
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element) {
			    /*
			     *                   3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
			    father_of_forefather->left = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			if (father_of_forefather->right == father_of_element) {
			    /*
			     *          3                       3
			     *               4                       5
			     * When tree   5   6        becomes    7    4
			     *            7 8                          8 6
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
			    father_of_forefather->right = added_element;
			    father_of_element->left = added_element->right;
			    added_element->right = father_of_element;
			}
			added_element->up = father_of_forefather;
		    } else {
			/*

			 *               1                       2
			 * When tree   2   3        becomes    4    1
			 *            4 5                          5 3
			 *
			 * 1 is used to show that it is the top of the tree
			 */
			added_element->up = NULL;
			father_of_element->left = added_element->right;
			added_element->right = father_of_element;
		    }
		    father_of_element->up = added_element;
		    if (father_of_element->left != NULL)
			father_of_element->left->up = father_of_element;
		} else if (father_of_element->right != NULL) {
		    added_element = father_of_element->right;
		    father_of_element->right_depth = added_element->left_depth;
		    added_element->left_depth = 1 +
			MAXIMUM(father_of_element->right_depth,
				father_of_element->left_depth);
		    if (father_of_element->up != NULL)
			/* Bug fixed in March 94  -  AS */
		    {
			BOOL first_time;

			father_of_forefather = father_of_element->up;
			forefather_of_element = added_element;
			first_time = YES;
			do {
			    if (father_of_forefather->left
				== forefather_of_element->up) {
				depth = father_of_forefather->left_depth;
				if (first_time) {
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->left_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->left_depth;
			    } else {
				depth = father_of_forefather->right_depth;
				if (first_time) {
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->left_depth,
						  forefather_of_element->right_depth);
				    first_time = NO;
				} else
				    father_of_forefather->right_depth = 1
					+ MAXIMUM(forefather_of_element->up->left_depth,
						  forefather_of_element->up->right_depth);
				depth2 = father_of_forefather->right_depth;
			    }
			    father_of_forefather = father_of_forefather->up;
			    forefather_of_element = forefather_of_element->up;
			} while ((depth != depth2) &&
				 (father_of_forefather != NULL));
			father_of_forefather = father_of_element->up;
			if (father_of_forefather->left == father_of_element) {
			    /*
			     *                    3                       3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree.
			     */
			    father_of_forefather->left = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			if (father_of_forefather->right == father_of_element) {
			    /*
			     *           3                      3
			     *               4                       6
			     * When tree   5   6        becomes    4    8
			     *                7 8                 5 7
			     *
			     * 3 is used to show that it may not be the top of the
			     * tree
			     */
			    father_of_forefather->right = added_element;
			    father_of_element->right = added_element->left;
			    added_element->left = father_of_element;
			}
			added_element->up = father_of_forefather;
		    } else {
			/*

			 *               1                       3
			 * When tree   2   3        becomes    1    5
			 *                4 5                 2 4
			 *
			 * 1 is used to show that it is the top of the tree.
			 */
			added_element->up = NULL;
			father_of_element->right = added_element->left;
			added_element->left = father_of_element;
		    }
		    father_of_element->up = added_element;
		    if (father_of_element->right != NULL)
			father_of_element->right->up = father_of_element;
		}
	    }
	}
	while (father_of_element->up != NULL) {
	    father_of_element = father_of_element->up;
	}
	tree->top = father_of_element;
    }
}

/*************************************************************************
 * this function returns a pointer to the leftmost element if ele is NULL,
 * and to the next object to the right otherwise.
 * If no elements left, returns a pointer to NULL.
 */
HTBTElement *HTBTree_next(HTBTree *tree,
			  HTBTElement *ele)
{
    HTBTElement *father_of_element;
    HTBTElement *father_of_forefather;

    if (ele == NULL) {
	father_of_element = tree->top;
	if (father_of_element != NULL)
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
    } else {
	father_of_element = ele;
	if (father_of_element->right != NULL) {
	    father_of_element = father_of_element->right;
	    while (father_of_element->left != NULL)
		father_of_element = father_of_element->left;
	} else {
	    father_of_forefather = father_of_element->up;
	    while (father_of_forefather &&
		   (father_of_forefather->right == father_of_element)) {
		father_of_element = father_of_forefather;
		father_of_forefather = father_of_element->up;
	    }
	    father_of_element = father_of_forefather;
	}
    }
#ifdef BTREE_TRACE
    /* The option -DBTREE_TRACE will give much more information
     * about the way the process is running, for debugging matters
     */
    if (father_of_element != NULL) {
	printf("\nObject = %s\t", (char *) father_of_element->object);
	if (father_of_element->up != NULL)
	    printf("Objet du pere = %s\n",
		   (char *) father_of_element->up->object);
	else
	    printf("Pas de Pere\n");
	if (father_of_element->left != NULL)
	    printf("Objet du fils gauche = %s\t",
		   (char *) father_of_element->left->object);
	else
	    printf("Pas de fils gauche\t");
	if (father_of_element->right != NULL)
	    printf("Objet du fils droit = %s\n",
		   (char *) father_of_element->right->object);
	else
	    printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t", father_of_element->left_depth);
	printf("Profondeur droite = %d\n", father_of_element->right_depth);
	printf("      **************\n");
    }
#endif
    return father_of_element;
}

#ifdef TEST
/*****************************************************
 * This is just a test to show how to handle HTBTree.c
 */
main()
{
    HTBTree *tree;
    HTBTElement *next_element;

    tree = HTBTree_new((HTComparer) strcasecomp);
    HTBTree_add(tree, "hypertext");
    HTBTree_add(tree, "Addressing");
    HTBTree_add(tree, "X11");
    HTBTree_add(tree, "Tools");
    HTBTree_add(tree, "Proposal.wn");
    HTBTree_add(tree, "Protocols");
    HTBTree_add(tree, "NeXT");
    HTBTree_add(tree, "Daemon");
    HTBTree_add(tree, "Test");
    HTBTree_add(tree, "Administration");
    HTBTree_add(tree, "LineMode");
    HTBTree_add(tree, "DesignIssues");
    HTBTree_add(tree, "MarkUp");
    HTBTree_add(tree, "Macintosh");
    HTBTree_add(tree, "Proposal.rtf.wn");
    HTBTree_add(tree, "FIND");
    HTBTree_add(tree, "Paper");
    HTBTree_add(tree, "Tcl");
    HTBTree_add(tree, "Talks");
    HTBTree_add(tree, "Architecture");
    HTBTree_add(tree, "VMSHelp");
    HTBTree_add(tree, "Provider");
    HTBTree_add(tree, "Archive");
    HTBTree_add(tree, "SLAC");
    HTBTree_add(tree, "Project");
    HTBTree_add(tree, "News");
    HTBTree_add(tree, "Viola");
    HTBTree_add(tree, "Users");
    HTBTree_add(tree, "FAQ");
    HTBTree_add(tree, "WorkingNotes");
    HTBTree_add(tree, "Windows");
    HTBTree_add(tree, "FineWWW");
    HTBTree_add(tree, "Frame");
    HTBTree_add(tree, "XMosaic");
    HTBTree_add(tree, "People");
    HTBTree_add(tree, "All");
    HTBTree_add(tree, "Curses");
    HTBTree_add(tree, "Erwise");
    HTBTree_add(tree, "Carl");
    HTBTree_add(tree, "MidasWWW");
    HTBTree_add(tree, "XPM");
    HTBTree_add(tree, "MailRobot");
    HTBTree_add(tree, "Illustrations");
    HTBTree_add(tree, "VMClient");
    HTBTree_add(tree, "XPA");
    HTBTree_add(tree, "Clients.html");
    HTBTree_add(tree, "Library");
    HTBTree_add(tree, "CERNLIB_Distribution");
    HTBTree_add(tree, "libHTML");
    HTBTree_add(tree, "WindowsPC");
    HTBTree_add(tree, "tkWWW");
    HTBTree_add(tree, "tk2.3");
    HTBTree_add(tree, "CVS-RCS");
    HTBTree_add(tree, "DecnetSockets");
    HTBTree_add(tree, "SGMLStream");
    HTBTree_add(tree, "NextStep");
    HTBTree_add(tree, "CVSRepository_old");
    HTBTree_add(tree, "ArthurSecret");
    HTBTree_add(tree, "CVSROOT");
    HTBTree_add(tree, "HytelnetGate");
    HTBTree_add(tree, "cern.www.new.src");
    HTBTree_add(tree, "Conditions");
    HTBTree_add(tree, "HTMLGate");
    HTBTree_add(tree, "Makefile");
    HTBTree_add(tree, "Newsgroups.html");
    HTBTree_add(tree, "People.html");
    HTBTree_add(tree, "Bugs.html");
    HTBTree_add(tree, "Summary.html");
    HTBTree_add(tree, "zDesignIssues.wn");
    HTBTree_add(tree, "HT.draw");
    HTBTree_add(tree, "HTandCERN.wn");
    HTBTree_add(tree, "Ideas.wn");
    HTBTree_add(tree, "MarkUp.wn");
    HTBTree_add(tree, "Proposal.html");
    HTBTree_add(tree, "SearchPanel.draw");
    HTBTree_add(tree, "Comments.wn");
    HTBTree_add(tree, "Xanadu.html");
    HTBTree_add(tree, "Storinglinks.html");
    HTBTree_add(tree, "TheW3Book.html");
    HTBTree_add(tree, "Talk_Feb-91.html");
    HTBTree_add(tree, "JFosterEntry.txt");
    HTBTree_add(tree, "Summary.txt");
    HTBTree_add(tree, "Bibliography.html");
    HTBTree_add(tree, "HTandCern.txt");
    HTBTree_add(tree, "Talk.draw");
    HTBTree_add(tree, "zDesignNotes.html");
    HTBTree_add(tree, "Link.html");
    HTBTree_add(tree, "Status.html");
    HTBTree_add(tree, "http.txt");
    HTBTree_add(tree, "People.html~");
    HTBTree_add(tree, "TAGS");
    HTBTree_add(tree, "summary.txt");
    HTBTree_add(tree, "Technical.html");
    HTBTree_add(tree, "Terms.html");
    HTBTree_add(tree, "JANETAccess.html");
    HTBTree_add(tree, "People.txt");
    HTBTree_add(tree, "README.txt");
    HTBTree_add(tree, "CodingStandards.html");
    HTBTree_add(tree, "Copyright.txt");
    HTBTree_add(tree, "Status_old.html");
    HTBTree_add(tree, "patches~");
    HTBTree_add(tree, "RelatedProducts.html");
    HTBTree_add(tree, "Implementation");
    HTBTree_add(tree, "History.html");
    HTBTree_add(tree, "Makefile.bak");
    HTBTree_add(tree, "Makefile.old");
    HTBTree_add(tree, "Policy.html");
    HTBTree_add(tree, "WhatIs.html");
    HTBTree_add(tree, "TheProject.html");
    HTBTree_add(tree, "Notation.html");
    HTBTree_add(tree, "Helping.html");
    HTBTree_add(tree, "Cyber-WWW.sit.Hqx");
    HTBTree_add(tree, "Glossary.html");
    HTBTree_add(tree, "maketags.html");
    HTBTree_add(tree, "IntroCS.html");
    HTBTree_add(tree, "Contrib");
    HTBTree_add(tree, "Help.html");
    HTBTree_add(tree, "CodeManagExec");
    HTBTree_add(tree, "HT-0.1draz");
    HTBTree_add(tree, "Cello");
    HTBTree_add(tree, "TOPUB");
    HTBTree_add(tree, "BUILD");
    HTBTree_add(tree, "BUILDALL");
    HTBTree_add(tree, "Lynx");
    HTBTree_add(tree, "ArthurLibrary");
    HTBTree_add(tree, "RashtyClient");
    HTBTree_add(tree, "#History.html#");
    HTBTree_add(tree, "PerlServers");
    HTBTree_add(tree, "modules");
    HTBTree_add(tree, "NCSA_httpd");
    HTBTree_add(tree, "MAIL2HTML");
    HTBTree_add(tree, "core");
    HTBTree_add(tree, "EmacsWWW");
#ifdef BTREE_TRACE
    printf("\nTreeTopObject=%s\n\n", tree->top->object);
#endif
    next_element = HTBTree_next(tree, NULL);
    while (next_element != NULL) {
#ifndef BTREE_TRACE
	printf("The next element is %s\n", next_element->object);
#endif
	next_element = HTBTree_next(tree, next_element);
    }
    HTBTree_free(tree);
}

#endif
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d27 2
d148 3
d175 3
d187 1
a187 1
		if (father_of_element->right != NULL)
d189 1
a189 1
		else {
d195 2
d259 17
a275 11
		if ((father_of_element->left == NULL)
		    && (father_of_element->right->right == NULL)
		    && (father_of_element->right->left->left == NULL)
		    && (father_of_element->right->left->right == NULL))
		    corrections = 7;

		if ((father_of_element->right == NULL)
		    && (father_of_element->left->left == NULL)
		    && (father_of_element->left->right->right == NULL)
		    && (father_of_element->left->right->left == NULL))
		    corrections = 7;
d277 2
a278 1
		if (father_of_element->left_depth > father_of_element->right_depth) {
d369 1
a369 1
		} else {
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 6
a7 7
**                  ==============================
**                      Author: Arthur Secret
**
**       4 March 94: Bug fixed in the balancing procedure
**
*/

d16 5
a20 5
PUBLIC HTBTree * HTBTree_new ARGS1(HTComparer, comp)
    /*********************************************************
    ** This function returns an HTBTree with memory allocated
    ** for it when given a mean to compare things
    */
d22 4
a25 2
    HTBTree * tree = typeMalloc(HTBTree);
    if (tree==NULL) outofmem(__FILE__, "HTBTree_new");
d33 4
a36 7



PRIVATE void HTBTElement_free ARGS1(HTBTElement*, element)
    /**********************************************************
    ** This void will free the memory allocated for one element
    */
d47 4
a50 4
PUBLIC void HTBTree_free ARGS1(HTBTree*, tree)
    /**************************************************************
    ** This void will free the memory allocated for the whole tree
    */
d56 4
a59 7



PRIVATE void HTBTElementAndObject_free ARGS1(HTBTElement*, element)
    /**********************************************************
    ** This void will free the memory allocated for one element
    */
d61 1
a61 1
    if (element) {     /* Just in case nothing was in the tree anyway */
d71 4
a74 4
PUBLIC void HTBTreeAndObject_free ARGS1(HTBTree*, tree)
    /**************************************************************
    ** This void will free the memory allocated for the whole tree
    */
d80 5
a84 7

PUBLIC void * HTBTree_search ARGS2(
		   HTBTree*,  tree,
		   void*,     object)
    /**********************************************************************
    ** Returns a pointer to equivalent object in a tree or NULL if none.
    */
d86 1
a86 1
    HTBTElement * cur = tree->top;
d89 1
a89 2
    while (cur != NULL)
    {
d102 8
a109 11


PUBLIC void HTBTree_add ARGS2(
		    HTBTree*,  tree,
		    void*,     object)
    /**********************************************************************
    ** This void is the core of HTBTree.c . It will
    **       1/ add a new element to the tree at the right place
    **		so that the tree remains sorted
    **       2/ balance the tree to be as fast as possible when reading it
    */
d111 25
a135 27
    HTBTElement * father_of_element;
    HTBTElement * added_element;
    HTBTElement * forefather_of_element;
    HTBTElement * father_of_forefather;
    BOOL father_found,top_found;
    int depth,depth2,corrections;
	/* father_of_element is a pointer to the structure that is the father of the
	** new object "object".
	** added_element is a pointer to the structure that contains or will contain
	** the new object "object".
	** father_of_forefather and forefather_of_element are pointers that are used
	** to modify the depths of upper elements, when needed.
	**
	** father_found indicates by a value NO when the future father of "object"
	** is found.
	** top_found indicates by a value NO when, in case of a difference of depths
	**  < 2, the top of the tree is encountered and forbids any further try to
	** balance the tree.
	** corrections is an integer used to avoid infinite loops in cases
	** such as:
	**
	**             3                        3
	**          4                              4
	**           5                            5
	**
	** 3 is used here to show that it need not be the top of the tree.
	*/
d138 2
a139 2
    ** 1/ Adding of the element to the binary tree
    */
d141 1
a141 2
    if (tree->top == NULL)
    {
d143 3
a145 1
	if (tree->top == NULL) outofmem(__FILE__, "HTBTree_add");
d152 1
a152 3
    }
    else
    {
d158 4
a161 5
	while (father_found)
	{
	    int res = tree->compare(object,father_of_element->object);
	    if (res < 0)
	    {
d164 1
a164 2
		else
		{
d167 2
a168 1
		    if (father_of_element->left==NULL)
d178 1
a178 3
	    }
	    else /* res >= 0 */
	   {
d181 1
a181 2
		else
		{
d184 2
a185 1
		    if (father_of_element->right==NULL)
d199 2
a200 2
	** Changing of all depths that need to be changed
	*/
d203 2
a204 4
	do
	{
	    if (father_of_forefather->left == forefather_of_element)
	    {
d207 2
a208 2
			    + MAXIMUM(forefather_of_element->right_depth,
				  forefather_of_element->left_depth);
d210 1
a210 3
	    }
	    else
	    {
d213 2
a214 2
			    + MAXIMUM(forefather_of_element->right_depth,
				  forefather_of_element->left_depth);
d221 3
a223 5


	    /*
	    ** 2/ Balancing the binary tree, if necessary
	    */
d226 1
a226 2
	while ((top_found) && (corrections < 7))
	{
d228 1
a228 2
		      - father_of_element->right_depth)) < 2)
	    {
d231 3
a233 4
		else top_found = NO;
	    }
	    else
	    {		     /* We start the process of balancing */
d236 12
a247 12
		   /*
		   ** corrections is an integer used to avoid infinite
		   ** loops in cases such as:
		   **
		   **             3                        3
		   **          4                              4
		   **           5                            5
		   **
		   ** 3 is used to show that it need not be the top of the tree
		   ** But let's avoid these two exceptions anyhow
		   ** with the two following conditions (4 March 94 - AS)
		   */
d261 1
a261 3

		if (father_of_element->left_depth > father_of_element->right_depth)
		{
d265 3
a267 4
				    + MAXIMUM(father_of_element->right_depth,
					  father_of_element->left_depth);
		    if (father_of_element->up != NULL)
		    {
d274 1
a274 2
			do
			{
d276 5
a280 7
				 == forefather_of_element->up)
			      {
				  depth = father_of_forefather->left_depth;
				  if (first_time)
				  {
				      father_of_forefather->left_depth = 1
					  + MAXIMUM(forefather_of_element->left_depth,
d282 5
a286 6
					first_time = NO;
				   }
				   else
				       father_of_forefather->left_depth = 1
					   + MAXIMUM(forefather_of_element->up->left_depth,
					      forefather_of_element->up->right_depth);
d289 1
a289 3
			    }
			    else
			    {
d291 1
a291 2
				if (first_time)
				{
d293 2
a294 2
				      + MAXIMUM(forefather_of_element->left_depth,
					       forefather_of_element->right_depth);
d296 1
a296 2
				}
				else
d298 2
a299 2
				      + MAXIMUM(forefather_of_element->up->left_depth,
					   forefather_of_element->up->right_depth);
d307 1
a307 2
			if (father_of_forefather->left == father_of_element)
			{
d309 8
a316 8
			    **                   3                       3
			    **               4                       5
			    ** When tree   5   6        becomes    7    4
			    **            7 8                          8 6
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree.
			    */
d321 1
a321 2
			if (father_of_forefather->right == father_of_element)
			{
d323 8
a330 8
			    **          3                       3
			    **               4                       5
			    ** When tree   5   6        becomes    7    4
			    **            7 8                          8 6
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree
			    */
d336 1
a336 3
		    }
		    else
		    {
d338 7
a344 7
			**
			**               1                       2
			** When tree   2   3        becomes    4    1
			**            4 5                          5 3
			**
			** 1 is used to show that it is the top of the tree
			*/
d352 1
a352 3
		}
		else
		{
d356 1
a356 1
			    MAXIMUM(father_of_element->right_depth,
d366 1
a366 2
			do
			{
d368 1
a368 2
				== forefather_of_element->up)
			    {
d370 1
a370 2
				if (first_time)
				{
d372 2
a373 2
				       + MAXIMUM(forefather_of_element->left_depth,
					       forefather_of_element->right_depth);
d375 1
a375 2
				}
				else
d377 2
a378 2
				      + MAXIMUM(forefather_of_element->up->left_depth,
					  forefather_of_element->up->right_depth);
d380 1
a380 3
			    }
			    else
			    {
d382 1
a382 2
				if (first_time)
				{
d384 2
a385 2
				       + MAXIMUM(forefather_of_element->left_depth,
					       forefather_of_element->right_depth);
d387 1
a387 2
				}
				else
d389 2
a390 2
				      + MAXIMUM(forefather_of_element->up->left_depth,
					   forefather_of_element->up->right_depth);
d398 1
a398 2
			if (father_of_forefather->left == father_of_element)
			{
d400 8
a407 8
			    **                    3                       3
			    **               4                       6
			    ** When tree   5   6        becomes    4    8
			    **                7 8                 5 7
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree.
			    */
d412 1
a412 2
			if (father_of_forefather->right == father_of_element)
			{
d414 8
a421 8
			    **           3                      3
			    **               4                       6
			    ** When tree   5   6        becomes    4    8
			    **                7 8                 5 7
			    **
			    ** 3 is used to show that it may not be the top of the
			    ** tree
			    */
d427 1
a427 3
		    }
		    else
		    {
d429 7
a435 7
			**
			**               1                       3
			** When tree   2   3        becomes    1    5
			**                4 5                 2 4
			**
			** 1 is used to show that it is the top of the tree.
			*/
d446 1
a446 2
	while (father_of_element->up != NULL)
	{
d453 7
a459 10


PUBLIC HTBTElement * HTBTree_next ARGS2(
			       HTBTree*,       tree,
			       HTBTElement*,   ele)
    /**************************************************************************
    ** this function returns a pointer to the leftmost element if ele is NULL,
    ** and to the next object to the right otherwise.
    ** If no elements left, returns a pointer to NULL.
    */
d461 2
a462 2
    HTBTElement * father_of_element;
    HTBTElement * father_of_forefather;
d464 1
a464 2
    if (ele == NULL)
    {
d469 1
a469 3
    }
    else
    {
d471 1
a471 2
	if (father_of_element->right != NULL)
	{
d475 1
a475 3
	}
	else
	{
d477 5
a481 6
		while (father_of_forefather &&
		       (father_of_forefather->right == father_of_element))
		{
		    father_of_element = father_of_forefather;
		    father_of_forefather = father_of_element->up;
		}
d487 4
a490 5
    ** about the way the process is running, for debugging matters
    */
    if (father_of_element != NULL)
    {
	printf("\nObject = %s\t",(char *)father_of_element->object);
d493 3
a495 2
		   (char *)father_of_element->up->object);
	else printf("Pas de Pere\n");
d498 3
a500 2
		   (char *)father_of_element->left->object);
	else printf("Pas de fils gauche\t");
d503 5
a507 4
		   (char *)father_of_element->right->object);
	else printf("Pas de fils droit\n");
	printf("Profondeur gauche = %d\t",father_of_element->left_depth);
	printf("Profondeur droite = %d\n",father_of_element->right_depth);
a513 1

d515 4
a518 4
main ()
    /******************************************************
    ** This is just a test to show how to handle HTBTree.c
    */
d520 2
a521 2
    HTBTree * tree;
    HTBTElement * next_element;
d523 134
a656 134
    tree = HTBTree_new((HTComparer)strcasecomp);
    HTBTree_add(tree,"hypertext");
    HTBTree_add(tree,"Addressing");
    HTBTree_add(tree,"X11");
    HTBTree_add(tree,"Tools");
    HTBTree_add(tree,"Proposal.wn");
    HTBTree_add(tree,"Protocols");
    HTBTree_add(tree,"NeXT");
    HTBTree_add(tree,"Daemon");
    HTBTree_add(tree,"Test");
    HTBTree_add(tree,"Administration");
    HTBTree_add(tree,"LineMode");
    HTBTree_add(tree,"DesignIssues");
    HTBTree_add(tree,"MarkUp");
    HTBTree_add(tree,"Macintosh");
    HTBTree_add(tree,"Proposal.rtf.wn");
    HTBTree_add(tree,"FIND");
    HTBTree_add(tree,"Paper");
    HTBTree_add(tree,"Tcl");
    HTBTree_add(tree,"Talks");
    HTBTree_add(tree,"Architecture");
    HTBTree_add(tree,"VMSHelp");
    HTBTree_add(tree,"Provider");
    HTBTree_add(tree,"Archive");
    HTBTree_add(tree,"SLAC");
    HTBTree_add(tree,"Project");
    HTBTree_add(tree,"News");
    HTBTree_add(tree,"Viola");
    HTBTree_add(tree,"Users");
    HTBTree_add(tree,"FAQ");
    HTBTree_add(tree,"WorkingNotes");
    HTBTree_add(tree,"Windows");
    HTBTree_add(tree,"FineWWW");
    HTBTree_add(tree,"Frame");
    HTBTree_add(tree,"XMosaic");
    HTBTree_add(tree,"People");
    HTBTree_add(tree,"All");
    HTBTree_add(tree,"Curses");
    HTBTree_add(tree,"Erwise");
    HTBTree_add(tree,"Carl");
    HTBTree_add(tree,"MidasWWW");
    HTBTree_add(tree,"XPM");
    HTBTree_add(tree,"MailRobot");
    HTBTree_add(tree,"Illustrations");
    HTBTree_add(tree,"VMClient");
    HTBTree_add(tree,"XPA");
    HTBTree_add(tree,"Clients.html");
    HTBTree_add(tree,"Library");
    HTBTree_add(tree,"CERNLIB_Distribution");
    HTBTree_add(tree,"libHTML");
    HTBTree_add(tree,"WindowsPC");
    HTBTree_add(tree,"tkWWW");
    HTBTree_add(tree,"tk2.3");
    HTBTree_add(tree,"CVS-RCS");
    HTBTree_add(tree,"DecnetSockets");
    HTBTree_add(tree,"SGMLStream");
    HTBTree_add(tree,"NextStep");
    HTBTree_add(tree,"CVSRepository_old");
    HTBTree_add(tree,"ArthurSecret");
    HTBTree_add(tree,"CVSROOT");
    HTBTree_add(tree,"HytelnetGate");
    HTBTree_add(tree,"cern.www.new.src");
    HTBTree_add(tree,"Conditions");
    HTBTree_add(tree,"HTMLGate");
    HTBTree_add(tree,"Makefile");
    HTBTree_add(tree,"Newsgroups.html");
    HTBTree_add(tree,"People.html");
    HTBTree_add(tree,"Bugs.html");
    HTBTree_add(tree,"Summary.html");
    HTBTree_add(tree,"zDesignIssues.wn");
    HTBTree_add(tree,"HT.draw");
    HTBTree_add(tree,"HTandCERN.wn");
    HTBTree_add(tree,"Ideas.wn");
    HTBTree_add(tree,"MarkUp.wn");
    HTBTree_add(tree,"Proposal.html");
    HTBTree_add(tree,"SearchPanel.draw");
    HTBTree_add(tree,"Comments.wn");
    HTBTree_add(tree,"Xanadu.html");
    HTBTree_add(tree,"Storinglinks.html");
    HTBTree_add(tree,"TheW3Book.html");
    HTBTree_add(tree,"Talk_Feb-91.html");
    HTBTree_add(tree,"JFosterEntry.txt");
    HTBTree_add(tree,"Summary.txt");
    HTBTree_add(tree,"Bibliography.html");
    HTBTree_add(tree,"HTandCern.txt");
    HTBTree_add(tree,"Talk.draw");
    HTBTree_add(tree,"zDesignNotes.html");
    HTBTree_add(tree,"Link.html");
    HTBTree_add(tree,"Status.html");
    HTBTree_add(tree,"http.txt");
    HTBTree_add(tree,"People.html~");
    HTBTree_add(tree,"TAGS");
    HTBTree_add(tree,"summary.txt");
    HTBTree_add(tree,"Technical.html");
    HTBTree_add(tree,"Terms.html");
    HTBTree_add(tree,"JANETAccess.html");
    HTBTree_add(tree,"People.txt");
    HTBTree_add(tree,"README.txt");
    HTBTree_add(tree,"CodingStandards.html");
    HTBTree_add(tree,"Copyright.txt");
    HTBTree_add(tree,"Status_old.html");
    HTBTree_add(tree,"patches~");
    HTBTree_add(tree,"RelatedProducts.html");
    HTBTree_add(tree,"Implementation");
    HTBTree_add(tree,"History.html");
    HTBTree_add(tree,"Makefile.bak");
    HTBTree_add(tree,"Makefile.old");
    HTBTree_add(tree,"Policy.html");
    HTBTree_add(tree,"WhatIs.html");
    HTBTree_add(tree,"TheProject.html");
    HTBTree_add(tree,"Notation.html");
    HTBTree_add(tree,"Helping.html");
    HTBTree_add(tree,"Cyber-WWW.sit.Hqx");
    HTBTree_add(tree,"Glossary.html");
    HTBTree_add(tree,"maketags.html");
    HTBTree_add(tree,"IntroCS.html");
    HTBTree_add(tree,"Contrib");
    HTBTree_add(tree,"Help.html");
    HTBTree_add(tree,"CodeManagExec");
    HTBTree_add(tree,"HT-0.1draz");
    HTBTree_add(tree,"Cello");
    HTBTree_add(tree,"TOPUB");
    HTBTree_add(tree,"BUILD");
    HTBTree_add(tree,"BUILDALL");
    HTBTree_add(tree,"Lynx");
    HTBTree_add(tree,"ArthurLibrary");
    HTBTree_add(tree,"RashtyClient");
    HTBTree_add(tree,"#History.html#");
    HTBTree_add(tree,"PerlServers");
    HTBTree_add(tree,"modules");
    HTBTree_add(tree,"NCSA_httpd");
    HTBTree_add(tree,"MAIL2HTML");
    HTBTree_add(tree,"core");
    HTBTree_add(tree,"EmacsWWW");
d658 1
a658 1
    printf("\nTreeTopObject=%s\n\n",tree->top->object);
d660 2
a661 3
    next_element = HTBTree_next(tree,NULL);
    while (next_element != NULL)
    {
d663 1
a663 1
	printf("The next element is %s\n",next_element->object);
d665 1
a665 1
	next_element = HTBTree_next(tree,next_element);
a668 1

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d23 1
a23 1
    HTBTree * tree = (HTBTree *)malloc(sizeof(HTBTree));
d41 1
a41 1
        if (element->left != NULL)
d67 1
a67 1
        if (element->left != NULL)
d86 24
d118 1
a118 1
    **          so that the tree remains sorted
d128 21
a148 21
        /* father_of_element is a pointer to the structure that is the father of the
        ** new object "object".
        ** added_element is a pointer to the structure that contains or will contain
        ** the new object "object".
        ** father_of_forefather and forefather_of_element are pointers that are used
        ** to modify the depths of upper elements, when needed.
        **
        ** father_found indicates by a value NO when the future father of "object"
        ** is found.
        ** top_found indicates by a value NO when, in case of a difference of depths
        **  < 2, the top of the tree is encountered and forbids any further try to
        ** balance the tree.
        ** corrections is an integer used to avoid infinite loops in cases
        ** such as:
        **
        **             3                        3
        **          4                              4
        **           5                            5
        **
        ** 3 is used here to show that it need not be the top of the tree.
        */
d156 8
a163 8
        tree->top = (HTBTElement *)malloc(sizeof(HTBTElement));
        if (tree->top == NULL) outofmem(__FILE__, "HTBTree_add");
        tree->top->up = NULL;
        tree->top->object = object;
        tree->top->left = NULL;
        tree->top->left_depth = 0;
        tree->top->right = NULL;
        tree->top->right_depth = 0;
d167 9
a175 8
        father_found = YES;
        father_of_element = tree->top;
        added_element = NULL;
        father_of_forefather = NULL;
        forefather_of_element = NULL;
        while (father_found)
        {
            if (tree->compare(object,father_of_element->object)<0)
d177 36
a212 38
                if (father_of_element->left != NULL)
                    father_of_element = father_of_element->left;
                else
	        {
                    father_found = NO;
                    father_of_element->left =
                        (HTBTElement *)malloc(sizeof(HTBTElement));
                    if (father_of_element->left==NULL)
                        outofmem(__FILE__, "HTBTree_add");
                    added_element = father_of_element->left;
                    added_element->up = father_of_element;
                    added_element->object = object;
                    added_element->left = NULL;
                    added_element->left_depth = 0;
                    added_element->right = NULL;
                    added_element->right_depth = 0;
                }
   	    }
            if (tree->compare(object,father_of_element->object)>=0)
            {
                if (father_of_element->right != NULL)
                    father_of_element = father_of_element->right;
                else
                {
                    father_found = NO;
                    father_of_element->right =
                        (HTBTElement *)malloc(sizeof(HTBTElement));
                    if (father_of_element->right==NULL)
                        outofmem(__FILE__, "HTBTree_add");
                    added_element = father_of_element->right;
                    added_element->up = father_of_element;
                    added_element->object = object;
                    added_element->left = NULL;
                    added_element->left_depth = 0;
                    added_element->right = NULL;
                    added_element->right_depth = 0;
    	        }
            }
d214 17
a230 16
            /*
            ** Changing of all depths that need to be changed
            */
        father_of_forefather = father_of_element;
        forefather_of_element = added_element;
        do
        {
            if (father_of_forefather->left == forefather_of_element)
            {
                depth = father_of_forefather->left_depth;
                father_of_forefather->left_depth = 1
                            + MAXIMUM(forefather_of_element->right_depth,
                                  forefather_of_element->left_depth);
                depth2 = father_of_forefather->left_depth;
            }
            else
d232 9
a240 9
                depth = father_of_forefather->right_depth;
                father_of_forefather->right_depth = 1
                            + MAXIMUM(forefather_of_element->right_depth,
                                  forefather_of_element->left_depth);
                depth2 = father_of_forefather->right_depth;
            }
            forefather_of_element = father_of_forefather;
            father_of_forefather = father_of_forefather->up;
        } while ((depth != depth2) && (father_of_forefather != NULL));
d244 9
a252 9
            /*
            ** 2/ Balancing the binary tree, if necessary
            */
        top_found = YES;
        corrections = 0;
        while ((top_found) && (corrections < 7))
        {
            if ((abs(father_of_element->left_depth
                      - father_of_element->right_depth)) < 2)
d254 3
a256 3
                if (father_of_element->up != NULL)
                    father_of_element = father_of_element->up;
                else top_found = NO;
d258 2
a259 2
            else
 	    {                /* We start the process of balancing */
d261 13
a273 13
                corrections = corrections + 1;
                    /*
                    ** corrections is an integer used to avoid infinite
                    ** loops in cases such as:
                    **
                    **             3                        3
                    **          4                              4
                    **           5                            5
                    **
                    ** 3 is used to show that it need not be the top of the tree
		    ** But let's avoid these two exceptions anyhow
		    ** with the two following conditions (4 March 94 - AS)
                    */
d288 8
a295 8
                if (father_of_element->left_depth > father_of_element->right_depth)
	        {
                    added_element = father_of_element->left;
                    father_of_element->left_depth = added_element->right_depth;
                    added_element->right_depth = 1
                                    + MAXIMUM(father_of_element->right_depth,
                                          father_of_element->left_depth);
                    if (father_of_element->up != NULL)
d300 2
a301 2
                        father_of_forefather = father_of_element->up;
                        forefather_of_element = added_element;
d303 5
a307 5
                        do
                        {
                            if (father_of_forefather->left
                                 == forefather_of_element->up)
                              {
d321 1
a321 1
                                depth2 = father_of_forefather->left_depth;
d323 1
a323 1
                            else
d325 1
a325 1
                                depth = father_of_forefather->right_depth;
d337 1
a337 1
                                depth2 = father_of_forefather->right_depth;
d339 2
a340 2
                            forefather_of_element = forefather_of_element->up;
                            father_of_forefather = father_of_forefather->up;
d343 32
a374 32
                        father_of_forefather = father_of_element->up;
                        if (father_of_forefather->left == father_of_element)
	                {
                            /*
                            **                   3                       3
                            **               4                       5
                            ** When tree   5   6        becomes    7    4
                            **            7 8                          8 6
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree.
                            */
                            father_of_forefather->left = added_element;
                            father_of_element->left = added_element->right;
                            added_element->right = father_of_element;
                        }
                        if (father_of_forefather->right == father_of_element)
		        {
                            /*
                            **          3                       3
                            **               4                       5
                            ** When tree   5   6        becomes    7    4
                            **            7 8                          8 6
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree
                            */
                            father_of_forefather->right = added_element;
                            father_of_element->left = added_element->right;
                            added_element->right = father_of_element;
                        }
                        added_element->up = father_of_forefather;
d376 1
a376 1
                    else
d378 11
a388 11
                        /*
                        **
                        **               1                       2
                        ** When tree   2   3        becomes    4    1
                        **            4 5                          5 3
                        **
                        ** 1 is used to show that it is the top of the tree
                        */
                        added_element->up = NULL;
                        father_of_element->left = added_element->right;
                        added_element->right = father_of_element;
d390 12
a401 12
                    father_of_element->up = added_element;
                    if (father_of_element->left != NULL)
                        father_of_element->left->up = father_of_element;
	        }
                else
	        {
                    added_element = father_of_element->right;
                    father_of_element->right_depth = added_element->left_depth;
                    added_element->left_depth = 1 +
                            MAXIMUM(father_of_element->right_depth,
                                father_of_element->left_depth);
                    if (father_of_element->up != NULL)
d406 2
a407 2
                        father_of_forefather = father_of_element->up;
                        forefather_of_element = added_element;
d409 3
a411 3
                        do
                        {
                            if (father_of_forefather->left
d413 3
a415 3
                            {
                                depth = father_of_forefather->left_depth;
                                if (first_time)
d422 1
a422 1
                                else
d425 1
a425 1
				       	  forefather_of_element->up->right_depth);
d428 1
a428 1
                            else
d430 1
a430 1
                                depth = father_of_forefather->right_depth;
d442 1
a442 1
                                depth2 = father_of_forefather->right_depth;
d444 2
a445 2
                            father_of_forefather = father_of_forefather->up;
                            forefather_of_element = forefather_of_element->up;
d448 32
a479 32
                        father_of_forefather = father_of_element->up;
                        if (father_of_forefather->left == father_of_element)
		        {
                            /*
                            **                    3                       3
                            **               4                       6
                            ** When tree   5   6        becomes    4    8
                            **                7 8                 5 7
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree.
                            */
                            father_of_forefather->left = added_element;
                            father_of_element->right = added_element->left;
                            added_element->left = father_of_element;
                        }
                        if (father_of_forefather->right == father_of_element)
		        {
                            /*
                            **           3                      3
                            **               4                       6
                            ** When tree   5   6        becomes    4    8
                            **                7 8                 5 7
                            **
                            ** 3 is used to show that it may not be the top of the
                            ** tree
                            */
                            father_of_forefather->right = added_element;
                            father_of_element->right = added_element->left;
                            added_element->left = father_of_element;
                        }
                        added_element->up = father_of_forefather;
d481 13
a493 13
                    else
                    {
                        /*
                        **
                        **               1                       3
                        ** When tree   2   3        becomes    1    5
                        **                4 5                 2 4
                        **
                        ** 1 is used to show that it is the top of the tree.
                        */
                        added_element->up = NULL;
                        father_of_element->right = added_element->left;
                        added_element->left = father_of_element;
d495 3
a497 3
                    father_of_element->up = added_element;
                    if (father_of_element->right != NULL)
		        father_of_element->right->up = father_of_element;
d500 2
a501 2
        }
        while (father_of_element->up != NULL)
d503 3
a505 3
            father_of_element = father_of_element->up;
        }
        tree->top = father_of_element;
d512 2
a513 2
                               HTBTree*,       tree,
                               HTBTElement*,   ele)
d525 4
a528 4
        father_of_element = tree->top;
        if (father_of_element != NULL)
            while (father_of_element->left != NULL)
                father_of_element = father_of_element->left;
d532 2
a533 2
        father_of_element = ele;
        if (father_of_element->right != NULL)
d535 3
a537 3
            father_of_element = father_of_element->right;
            while (father_of_element->left != NULL)
                father_of_element = father_of_element->left;
d539 1
a539 1
        else
d541 2
a542 2
            father_of_forefather = father_of_element->up;
	        while (father_of_forefather &&
d544 2
a545 2
      	        {
                    father_of_element = father_of_forefather;
d548 1
a548 1
            father_of_element = father_of_forefather;
d557 3
a559 3
        printf("\nObject = %s\t",(char *)father_of_element->object);
        if (father_of_element->up != NULL)
            printf("Objet du pere = %s\n",
d561 3
a563 3
        else printf("Pas de Pere\n");
        if (father_of_element->left != NULL)
            printf("Objet du fils gauche = %s\t",
d565 3
a567 3
        else printf("Pas de fils gauche\t");
        if (father_of_element->right != NULL)
            printf("Objet du fils droit = %s\n",
d569 4
a572 4
        else printf("Pas de fils droit\n");
        printf("Profondeur gauche = %d\t",father_of_element->left_depth);
        printf("Profondeur droite = %d\n",father_of_element->right_depth);
        printf("      **************\n");
d729 1
a729 1
        printf("The next element is %s\n",next_element->object);
d731 1
a731 1
        next_element = HTBTree_next(tree,next_element);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a11 3
#ifndef __STRICT_BSD__
#include <stdlib.h>
#endif
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
#include "HTUtils.h"
#include "HTBTree.h"
a14 1
#include <string.h>
d18 1
a18 4
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

d22 1
a22 1
    ** This function returns an HTBTree with memory allocated 
d72 1
a72 1
	if (element->right != NULL)    
d109 1
a109 1
        ** added_element is a pointer to the structure that contains or will contain 
d114 1
a114 1
        ** father_found indicates by a value NO when the future father of "object" 
d145 1
a145 1
    {   
d150 1
a150 1
        forefather_of_element = NULL;      
d157 1
a157 1
                else 
d160 1
a160 1
                    father_of_element->left = 
d162 1
a162 1
                    if (father_of_element->left==NULL) 
d175 1
a175 1
                if (father_of_element->right != NULL) 
d177 2
a178 2
                else 
                {  
d180 1
a180 1
                    father_of_element->right = 
d182 1
a182 1
                    if (father_of_element->right==NULL) 
d190 1
a190 1
                    added_element->right_depth = 0;       
d204 1
a204 1
                father_of_forefather->left_depth = 1 
d220 1
a220 1
        
d233 1
a233 1
                if (father_of_element->up != NULL) 
d241 2
a242 2
                    /* 
                    ** corrections is an integer used to avoid infinite 
d250 1
a250 1
		    ** But let's avoid these two exceptions anyhow 
d254 4
a257 4
		if ((father_of_element->left == NULL) 
		    && (father_of_element->right->right == NULL) 
		    && (father_of_element->right->left->left == NULL) 
		    && (father_of_element->right->left->right == NULL)) 
d260 3
a262 3
		if ((father_of_element->right == NULL) 
		    && (father_of_element->left->left == NULL) 
		    && (father_of_element->left->right->right == NULL) 
d265 1
a265 1
 
d282 1
a282 1
                        do 
d311 1
a311 1
				}				
d320 1
a320 1
			} while ((depth != depth2) && 
d333 1
a333 1
                            */ 
d363 1
a363 1
                        ** 1 is used to show that it is the top of the tree    
d377 1
a377 1
                    added_element->left_depth = 1 + 
d388 1
a388 1
                        do 
d390 1
a390 1
                            if (father_of_forefather->left 
d425 1
a425 1
			} while ((depth != depth2) && 
d495 1
a495 1
    ** and to the next object to the right otherways.
d521 1
a521 1
	        while (father_of_forefather && 
d543 1
a543 1
		   (char *)father_of_element->left->object); 
d566 1
a566 1
    
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
