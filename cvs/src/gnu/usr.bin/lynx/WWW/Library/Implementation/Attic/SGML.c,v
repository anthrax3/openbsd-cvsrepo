head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.50;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: SGML.c,v 1.148 2012/02/10 18:32:26 tom Exp $
 *
 *			General SGML Parser code		SGML.c
 *			========================
 *
 *	This module implements an HTStream object.  To parse an
 *	SGML file, create this object which is a parser.  The object
 *	is (currently) created by being passed a DTD structure,
 *	and a target HTStructured object at which to throw the parsed stuff.
 *
 *	 6 Feb 93  Binary searches used. Interface modified.
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>

#include <SGML.h>
#include <HTMLDTD.h>
#include <HTAccess.h>
#include <HTCJK.h>		/* FIXME: this doesn't belong in SGML.c */
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <HTChunk.h>
#include <HTUtils.h>

#include <LYCharSets.h>
#include <LYCharVals.h>		/* S/390 -- gil -- 0635 */
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYLeaks.h>
#include <LYUtils.h>

#ifdef USE_COLOR_STYLE
# include <LYStyle.h>
#endif
#ifdef USE_PRETTYSRC
# include <LYPrettySrc.h>
#endif

#define AssumeCP1252(context) \
	(((context)->inUCLYhndl == LATIN1 \
	  || (context)->inUCLYhndl == US_ASCII) \
	 && html5_charsets)

#define INVALID (-1)

static int sgml_offset;

#ifdef USE_PRETTYSRC

static char *entity_string;	/* this is used for printing entity name.

				   Unconditionally added since redundant assigments don't hurt much */

static void fake_put_character(void *p GCC_UNUSED,
			       char c GCC_UNUSED)
{
}

#define START TRUE
#define STOP FALSE

#define PUTS_TR(x) psrc_convert_string = TRUE; PUTS(x)

#endif

/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
#define my_casecomp(a,b)  ((TOUPPER(*a) == TOUPPER(*b)) ? \
			AS_casecomp(a,b) : \
			(TOASCII(TOUPPER(*a)) - TOASCII(TOUPPER(*b))))

 /* will use partially inlined version */
#define orig_HTChunkPutUtf8Char HTChunkPutUtf8Char
#undef HTChunkPutUtf8Char

/* ...used for comments and attributes value like href... */
#define HTChunkPutUtf8Char(ch,x) \
    { \
    if ((TOASCII(x) < 128)  && (ch->size < ch->allocated)) \
	ch->data[ch->size++] = (char)x; \
    else \
	orig_HTChunkPutUtf8Char(ch,x); \
    }

#define PUTS(str) ((*context->actions->put_string)(context->target, str))
#define PUTC(ch)  ((*context->actions->put_character)(context->target, (char) ch))
#define PUTUTF8(code) (UCPutUtf8_charstring((HTStream *)context->target, \
		      (putc_func_t*)(context->actions->put_character), code))

#ifdef USE_PRETTYSRC
#define PRETTYSRC_PUTC(c) if (psrc_view) PUTC(c)
#else
#define PRETTYSRC_PUTC(c)	/* nothing */
#endif

/*the following macros are used for pretty source view. */
#define IS_C(attr) (attr.type == HTMLA_CLASS)

HTCJKlang HTCJK = NOCJK;	/* CJK enum value.              */
BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.    */
BOOL HTPassEightBitNum = FALSE;	/* Pass ^ numeric entities raw. */
BOOL HTPassHighCtrlRaw = FALSE;	/* Pass 127-160,173,&#127; raw. */
BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.      */

/*	The State (context) of the parser
 *
 *	This is passed with each call to make the parser reentrant
 *
 */

#define MAX_ATTRIBUTES 36	/* Max number of attributes per element */

/*		Element Stack
 *		-------------
 *	This allows us to return down the stack reselecting styles.
 *	As we return, attribute values will be garbage in general.
 */
typedef struct _HTElement HTElement;
struct _HTElement {
    HTElement *next;		/* Previously nested element or 0 */
    HTTag *tag;			/* The tag at this level  */
};

typedef enum {
    S_text = 0
    ,S_attr
    ,S_attr_gap
    ,S_comment
    ,S_cro
    ,S_doctype
    ,S_dollar
    ,S_dollar_dq
    ,S_dollar_paren
    ,S_dollar_paren_dq
    ,S_dollar_paren_sq
    ,S_dollar_sq
    ,S_dquoted
    ,S_end
    ,S_entity
    ,S_equals
    ,S_ero
    ,S_esc
    ,S_esc_dq
    ,S_esc_sq
    ,S_exclamation
    ,S_in_kanji
    ,S_incro
    ,S_junk_tag
    ,S_litteral
    ,S_marked
    ,S_nonascii_text
    ,S_nonascii_text_dq
    ,S_nonascii_text_sq
    ,S_paren
    ,S_paren_dq
    ,S_paren_sq
    ,S_pcdata
    ,S_pi
    ,S_script
    ,S_sgmlatt
    ,S_sgmlele
    ,S_sgmlent
    ,S_squoted
    ,S_tag
    ,S_tag_gap
    ,S_tagname_slash
    ,S_value
} sgml_state;

/*	Internal Context Data Structure
 *	-------------------------------
 */
struct _HTStream {

    const HTStreamClass *isa;	/* inherited from HTStream */

    const SGML_dtd *dtd;
    const HTStructuredClass *actions;	/* target class  */
    HTStructured *target;	/* target object */

    HTTag *current_tag;
    HTTag *slashedtag;
    const HTTag *unknown_tag;
    BOOL extended_html;		/* xhtml */
    BOOL strict_xml;		/* xml */
    BOOL inSELECT;
    BOOL no_lynx_specialcodes;
    int current_attribute_number;
    HTChunk *string;
    int leading_spaces;
    int trailing_spaces;
    HTElement *element_stack;
    sgml_state state;
    unsigned char kanji_buf;
#ifdef CALLERDATA
    void *callerData;
#endif				/* CALLERDATA */
    BOOL present[MAX_ATTRIBUTES];	/* Flags: attribute is present? */
    char *value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */

    BOOL lead_exclamation;
    BOOL first_dash;
    BOOL end_comment;
    BOOL doctype_bracket;
    BOOL first_bracket;
    BOOL second_bracket;
    BOOL isHex;

    HTParentAnchor *node_anchor;
    LYUCcharset *inUCI;		/* pointer to anchor UCInfo */
    int inUCLYhndl;		/* charset we are fed       */
    LYUCcharset *outUCI;	/* anchor UCInfo for target */
    int outUCLYhndl;		/* charset for target       */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
    UCTransParams T;
    int current_tag_charset;	/* charset to pass attributes */

    char *recover;
    int recover_index;
    char *include;
    char *active_include;
    int include_index;
    char *url;
    char *csi;
    int csi_index;
#ifdef USE_PRETTYSRC
    BOOL cur_attr_is_href;
    BOOL cur_attr_is_name;
#endif
};

#ifdef NO_LYNX_TRACE
#define state_name(n) "state"
#else
static const char *state_name(sgml_state n)
{
    const char *result = "?";
    /* *INDENT-OFF* */
    switch (n) {
    case S_attr:                result = "S_attr";              break;
    case S_attr_gap:            result = "S_attr_gap";          break;
    case S_comment:             result = "S_comment";           break;
    case S_cro:                 result = "S_cro";               break;
    case S_doctype:             result = "S_doctype";           break;
    case S_dollar:              result = "S_dollar";            break;
    case S_dollar_dq:           result = "S_dollar_dq";         break;
    case S_dollar_paren:        result = "S_dollar_paren";      break;
    case S_dollar_paren_dq:     result = "S_dollar_paren_dq";   break;
    case S_dollar_paren_sq:     result = "S_dollar_paren_sq";   break;
    case S_dollar_sq:           result = "S_dollar_sq";         break;
    case S_dquoted:             result = "S_dquoted";           break;
    case S_end:                 result = "S_end";               break;
    case S_entity:              result = "S_entity";            break;
    case S_equals:              result = "S_equals";            break;
    case S_ero:                 result = "S_ero";               break;
    case S_esc:                 result = "S_esc";               break;
    case S_esc_dq:              result = "S_esc_dq";            break;
    case S_esc_sq:              result = "S_esc_sq";            break;
    case S_exclamation:         result = "S_exclamation";       break;
    case S_in_kanji:            result = "S_in_kanji";          break;
    case S_incro:               result = "S_incro";             break;
    case S_pi:                  result = "S_pi";                break;
    case S_junk_tag:            result = "S_junk_tag";          break;
    case S_litteral:            result = "S_litteral";          break;
    case S_marked:              result = "S_marked";            break;
    case S_nonascii_text:       result = "S_nonascii_text";     break;
    case S_nonascii_text_dq:    result = "S_nonascii_text_dq";  break;
    case S_nonascii_text_sq:    result = "S_nonascii_text_sq";  break;
    case S_paren:               result = "S_paren";             break;
    case S_paren_dq:            result = "S_paren_dq";          break;
    case S_paren_sq:            result = "S_paren_sq";          break;
    case S_pcdata:              result = "S_pcdata";            break;
    case S_script:              result = "S_script";            break;
    case S_sgmlatt:             result = "S_sgmlatt";           break;
    case S_sgmlele:             result = "S_sgmlele";           break;
    case S_sgmlent:             result = "S_sgmlent";           break;
    case S_squoted:             result = "S_squoted";           break;
    case S_tag:                 result = "S_tag";               break;
    case S_tag_gap:             result = "S_tag_gap";           break;
    case S_tagname_slash:       result = "S_tagname_slash";     break;
    case S_text:                result = "S_text";              break;
    case S_value:               result = "S_value";             break;
    }
    /* *INDENT-ON* */

    return result;
}
#endif

/* storage for Element Stack */
#define DEPTH 10
static HTElement pool[DEPTH];
static int depth = 0;

static HTElement *pool_alloc(void)
{
    depth++;
    if (depth > DEPTH)
	return (HTElement *) malloc(sizeof(HTElement));
    return (pool + depth - 1);
}

static void pool_free(HTElement * e)
{
    if (depth > DEPTH)
	FREE(e);
    depth--;
    return;
}

#ifdef USE_PRETTYSRC

static void HTMLSRC_apply_markup(HTStream *context,
				 HTlexeme lexeme,
				 int start)
{
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);

    while (ts) {
#ifdef USE_COLOR_STYLE
	if (ts->start) {
	    current_tag_style = ts->style;
	    force_current_tag_style = TRUE;
	    forced_classname = ts->class_name;
	    force_classname = TRUE;
	}
#endif
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
	if (ts->start)
	    (*context->actions->start_element) (context->target,
						(int) ts->element,
						ts->present,
						(STRING2PTR) ts->value,
						context->current_tag_charset,
						&context->include);
	else
	    (*context->actions->end_element) (context->target,
					      (int) ts->element,
					      &context->include);
	ts = ts->next;
    }
}

#define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_##x,START)
#define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)

#define attr_is_href context->cur_attr_is_href
#define attr_is_name context->cur_attr_is_name
#endif

static void set_chartrans_handling(HTStream *context,
				   HTParentAnchor *anchor,
				   int chndl)
{
    if (chndl < 0) {
	/*
	 * Nothing was set for the parser in earlier stages, so the HTML
	 * parser's UCLYhndl should still be its default.  - FM
	 */
	chndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_STRUCTURED);
	if (chndl < 0)
	    /*
	     * That wasn't set either, so seek the HText default.  - FM
	     */
	    chndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
	if (chndl < 0)
	    /*
	     * That wasn't set either, so assume the current display character
	     * set.  - FM
	     */
	    chndl = current_char_set;
	/*
	 * Try to set the HText and HTML stages' chartrans info with the
	 * default lock level (will not be changed if it was set previously
	 * with a higher lock level).  - FM
	 */
	HTAnchor_setUCInfoStage(anchor, chndl,
				UCT_STAGE_HTEXT,
				UCT_SETBY_DEFAULT);
	HTAnchor_setUCInfoStage(anchor, chndl,
				UCT_STAGE_STRUCTURED,
				UCT_SETBY_DEFAULT);
	/*
	 * Get the chartrans info for output to the HTML parser.  - FM
	 */
	context->outUCI = HTAnchor_getUCInfoStage(anchor,
						  UCT_STAGE_STRUCTURED);
	context->outUCLYhndl = HTAnchor_getUCLYhndl(context->node_anchor,
						    UCT_STAGE_STRUCTURED);
    }
    /*
     * Set the in->out transformation parameters.  - FM
     */
    UCSetTransParams(&context->T,
		     context->inUCLYhndl, context->inUCI,
		     context->outUCLYhndl, context->outUCI);
    /*
     * This is intended for passing the SGML parser's input charset as an
     * argument in each call to the HTML parser's start tag function, but it
     * would be better to call a Lynx_HTML_parser function to set an element in
     * its HTStructured object, itself, if this were needed.  - FM
     */
#ifndef EXP_JAPANESEUTF8_SUPPORT
    if (IS_CJK_TTY) {
	context->current_tag_charset = -1;
    } else
#endif
    if (context->T.transp) {
	context->current_tag_charset = context->inUCLYhndl;
    } else if (context->T.decode_utf8) {
	context->current_tag_charset = context->inUCLYhndl;
    } else if (context->T.do_8bitraw ||
	       context->T.use_raw_char_in) {
	context->current_tag_charset = context->inUCLYhndl;
    } else if (context->T.output_utf8 ||
	       context->T.trans_from_uni) {
	context->current_tag_charset = UCGetLYhndl_byMIME("utf-8");
    } else {
	context->current_tag_charset = LATIN1;
    }
}

static void change_chartrans_handling(HTStream *context)
{
    int new_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor,
					  UCT_STAGE_PARSER);

    if (new_LYhndl != context->inUCLYhndl &&
	new_LYhndl >= 0) {
	/*
	 * Something changed.  but ignore if a META wants an unknown charset.
	 */
	LYUCcharset *new_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
						       UCT_STAGE_PARSER);

	if (new_UCI) {
	    LYUCcharset *next_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
							    UCT_STAGE_STRUCTURED);
	    int next_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor, UCT_STAGE_STRUCTURED);

	    context->inUCI = new_UCI;
	    context->inUCLYhndl = new_LYhndl;
	    context->outUCI = next_UCI;
	    context->outUCLYhndl = next_LYhndl;
	    set_chartrans_handling(context,
				   context->node_anchor, next_LYhndl);
	}
    }
}

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
static int current_is_class = 0;
#endif

/*	Handle Attribute
 *	----------------
 */
/* PUBLIC const char * SGML_default = "";   ?? */

static void handle_attribute_name(HTStream *context, const char *s)
{
    HTTag *tag = context->current_tag;
    const attr *attributes = tag->attributes;
    int high, low, i, diff;

#ifdef USE_PRETTYSRC
    if (psrc_view) {
	attr_is_href = FALSE;
	attr_is_name = FALSE;
    }
#endif
    /*
     * Ignore unknown tag.  - KW
     */
    if (tag == context->unknown_tag) {
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    context->current_attribute_number = 1;	/* anything !=INVALID */
#endif
	return;
    }

    /*
     * Binary search for attribute name.
     */
    for (low = 0, high = tag->number_of_attributes;
	 high > low;
	 diff < 0 ? (low = i + 1) : (high = i)) {
	i = (low + (high - low) / 2);
	diff = my_casecomp(attributes[i].name, s);
	if (diff == 0) {	/* success: found it */
	    context->current_attribute_number = i;
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		attr_is_name = (BOOL) (attributes[i].type == HTMLA_ANAME);
		attr_is_href = (BOOL) (attributes[i].type == HTMLA_HREF);
	    } else
#endif
	    {
		context->present[i] = YES;
		Clear_extra(context->value[i]);
#ifdef USE_COLOR_STYLE
#   ifdef USE_PRETTYSRC
		current_is_class = IS_C(attributes[i]);
#   else
		current_is_class = (!strcasecomp("class", s));
#   endif
		CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
#endif
	    }
	    return;
	}
	/* if */
    }				/* for */

    CTRACE((tfp, "SGML: Unknown attribute %s for tag %s\n",
	    s, NonNull(context->current_tag->name)));
    context->current_attribute_number = INVALID;	/* Invalid */
}

/*	Handle attribute value
 *	----------------------
 */
static void handle_attribute_value(HTStream *context, const char *s)
{
    if (context->current_attribute_number != INVALID) {
	StrAllocCopy_extra(context->value[context->current_attribute_number], s);
#ifdef USE_COLOR_STYLE
	if (current_is_class) {
	    StrNCpy(class_string, s, TEMPSTRINGSIZE);
	    CTRACE((tfp, "SGML: class is '%s'\n", s));
	} else {
	    CTRACE((tfp, "SGML: attribute value is '%s'\n", s));
	}
#endif
    } else {
	CTRACE((tfp, "SGML: Attribute value %s ***ignored\n", s));
    }
    context->current_attribute_number = INVALID;	/* can't have two assignments! */
}

/*
 *  Translate some Unicodes to Lynx special codes and output them.
 *  Special codes - ones those output depend on parsing.
 *
 *  Additional issue, like handling bidirectional text if necessary
 *  may be called from here:  zwnj (8204), zwj (8205), lrm (8206), rlm (8207)
 *  - currently they are ignored in SGML.c and LYCharUtils.c
 *  but also in UCdomap.c because they are non printable...
 *
 */
static BOOL put_special_unicodes(HTStream *context, UCode_t code)
{
    /* (Tgf_nolyspcl) */
    if (context->no_lynx_specialcodes) {
	/*
	 * We were asked by a "DTD" flag to not generate lynx specials.  - kw
	 */
	return NO;
    }

    if (code == CH_NBSP) {	/* S/390 -- gil -- 0657 */
	/*
	 * Use Lynx special character for nbsp.
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view)
#endif
	    PUTC(HT_NON_BREAK_SPACE);
    } else if (code == CH_SHY) {
	/*
	 * Use Lynx special character for shy.
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view)
#endif
	    PUTC(LY_SOFT_HYPHEN);
    } else if (code == 8194 || code == 8201) {
	/*
	 * Use Lynx special character for ensp or thinsp.
	 *
	 * Originally, Lynx use space '32' as word delimiter and omits this
	 * space at end of line if word is wrapped to the next line.  There are
	 * several other spaces in the Unicode repertoire and we should teach
	 * Lynx to understand them, not only as regular characters but in the
	 * context of line wrapping.  Unfortunately, if we use HT_EN_SPACE we
	 * override the chartrans tables for those spaces with a single '32'
	 * for all (but do line wrapping more fancy).
	 *
	 * We may treat emsp as one or two ensp (below).
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view)
#endif
	    PUTC(HT_EN_SPACE);
    } else if (code == 8195) {
	/*
	 * Use Lynx special character for emsp.
	 */
#ifdef USE_PRETTYSRC
	if (!psrc_view) {
#endif
	    /* PUTC(HT_EN_SPACE);  let's stay with a single space :) */
	    PUTC(HT_EN_SPACE);
#ifdef USE_PRETTYSRC
	}
#endif
    } else {
	/*
	 * Return NO if nothing done.
	 */
	return NO;
    }
    /*
     * We have handled it.
     */
    return YES;
}

#ifdef USE_PRETTYSRC
static void put_pretty_entity(HTStream *context, int term)
{
    PSRCSTART(entity);
    PUTC('&');
    PUTS(entity_string);
    if (term)
	PUTC((char) term);
    PSRCSTOP(entity);
}

static void put_pretty_number(HTStream *context)
{
    PSRCSTART(entity);
    PUTS((context->isHex ? "&#x" : "&#"));
    PUTS(entity_string);
    PUTC(';');
    PSRCSTOP(entity);
}
#endif /* USE_PRETTYSRC */

/*	Handle entity
 *	-------------
 *
 * On entry,
 *	s	contains the entity name zero terminated
 * Bugs:
 *	If the entity name is unknown, the terminator is treated as
 *	a printable non-special character in all cases, even if it is '<'
 * Bug-fix:
 *	Modified SGML_character() so we only come here with terminator
 *	as '\0' and check a FoundEntity flag. -- Foteos Macrides
 *
 * Modified more (for use with Lynx character translation code):
 */
static char replace_buf[64];	/* buffer for replacement strings */
static BOOL FoundEntity = FALSE;

static void handle_entity(HTStream *context, int term)
{
    UCode_t code;
    long uck = -1;
    const char *s = context->string->data;

    /*
     * Handle all entities normally.  - FM
     */
    FoundEntity = FALSE;
    if ((code = HTMLGetEntityUCValue(s)) != 0) {
	/*
	 * We got a Unicode value for the entity name.  Check for special
	 * Unicodes.  - FM
	 */
	if (put_special_unicodes(context, code)) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }
#endif
	    FoundEntity = TRUE;
	    return;
	}
	/*
	 * Seek a translation from the chartrans tables.
	 */
	if ((uck = UCTransUniChar(code, context->outUCLYhndl)) >= 32 &&
/* =============== work in ASCII below here ===============  S/390 -- gil -- 0672 */
	    uck < 256 &&
	    (uck < 127 ||
	     uck >= LYlowest_eightbit[context->outUCLYhndl])) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    } else
#endif
		PUTC(FROMASCII((char) uck));
	    FoundEntity = TRUE;
	    return;
	} else if ((uck == -4 ||
		    (context->T.repl_translated_C0 &&
		     uck > 0 && uck < 32)) &&
	    /*
	     * Not found; look for replacement string.
	     */
		   (uck = UCTransUniCharStr(replace_buf, 60, code,
					    context->outUCLYhndl, 0) >= 0)) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    } else
#endif
		PUTS(replace_buf);
	    FoundEntity = TRUE;
	    return;
	}
	/*
	 * If we're displaying UTF-8, try that now.  - FM
	 */
#ifndef USE_PRETTYSRC
	if (context->T.output_utf8 && PUTUTF8(code)) {
	    FoundEntity = TRUE;
	    return;
	}
#else
	if (context->T.output_utf8 && (psrc_view
				       ? (UCPutUtf8_charstring((HTStream *) context->target,
							       (putc_func_t *) (fake_put_character),
							       code))
				       : PUTUTF8(code))) {

	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }

	    FoundEntity = TRUE;
	    return;
	}
#endif
	/*
	 * If it's safe ASCII, use it.  - FM
	 */
	if (code >= 32 && code < 127) {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    } else
#endif

		PUTC(FROMASCII((char) code));
	    FoundEntity = TRUE;
	    return;
	}
/* =============== work in ASCII above here ===============  S/390 -- gil -- 0682 */
	/*
	 * Ignore zwnj (8204) and zwj (8205), if we get to here.  Note that
	 * zwnj may have been handled as <WBR> by the calling function.  - FM
	 */
	if (!strcmp(s, "zwnj") ||
	    !strcmp(s, "zwj")) {
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }
#endif
	    FoundEntity = TRUE;
	    return;
	}
	/*
	 * Ignore lrm (8206), and rln (8207), if we get to here.  - FM
	 */
	if (!strcmp(s, "lrm") ||
	    !strcmp(s, "rlm")) {
	    CTRACE((tfp, "handle_entity: Ignoring '%s'.\n", s));
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		put_pretty_entity(context, term);
	    }
#endif
	    FoundEntity = TRUE;
	    return;
	}
    }

    /*
     * If entity string not found, display as text.
     */
#ifdef USE_PRETTYSRC
    if (psrc_view)
	PSRCSTART(badseq);
#endif
    CTRACE((tfp, "SGML: Unknown entity '%s' %" PRI_UCode_t " %ld\n", s, code, uck));	/* S/390 -- gil -- 0695 */
    PUTC('&');
    PUTS(s);
    if (term != '\0')
	PUTC(term);
#ifdef USE_PRETTYSRC
    if (psrc_view)
	PSRCSTOP(badseq);
#endif
}

/*	Handle comment
 *	--------------
 */
static void handle_comment(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Comment:\n<%s>\n", s));

    if (context->csi == NULL &&
	StrNCmp(s, "!--#", 4) == 0 &&
	LYCheckForCSI(context->node_anchor, &context->url) == TRUE) {
	LYDoCSI(context->url, s, &context->csi);
    } else {
	LYCommentHacks(context->node_anchor, context->string->data);
    }

    return;
}

/*	Handle identifier
 *	-----------------
 */
static void handle_identifier(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Identifier:\n<%s>\n", s));

    return;
}

/*	Handle doctype
 *	--------------
 */
static void handle_doctype(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Doctype:\n<%s>\n", s));
    if (strstr(s, "DTD XHTML ") != 0) {
	CTRACE((tfp, "...processing extended HTML\n"));
	context->extended_html = TRUE;
    }

    return;
}

/*	Handle marked
 *	-------------
 */
static void handle_marked(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Marked Section:\n<%s>\n", s));

    if (!StrNCmp(context->string->data, "![INCLUDE[", 10)) {
	context->string->data[context->string->size - 3] = '\0';
	StrAllocCat(context->include, context->string->data + 10);
	/* @@@@@@ This needs to take charset into account! @@@@@@
	   the wrong assumptions will be made about the data's
	   charset once it is in include - kw */

    } else if (!StrNCmp(context->string->data, "![CDATA[", 8)) {
	(*context->actions->put_block) (context->target,
					context->string->data + 8,
					context->string->size - 11);

    }
    return;
}

/*	Handle processing instruction
 *	-----------------------------
 */
static void handle_processing_instruction(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Processing instruction:\n<%s>\n", s));

    if (!StrNCmp(s, "?xml ", 5)) {
	int flag = context->T.decode_utf8;

	context->strict_xml = TRUE;
	/*
	 * Switch to UTF-8 if the encoding is explicitly "utf-8".
	 */
	if (!flag) {
	    char *t = strstr(s, "encoding=");

	    if (t != 0) {
		t += 9;
		if (*t == '"')
		    ++t;
		flag = !StrNCmp(t, "utf-8", 5);
	    }
	    if (flag) {
		CTRACE((tfp, "...Use UTF-8 for XML\n"));
		context->T.decode_utf8 = TRUE;
	    }
	}
    }

    return;
}

/*	Handle sgmlent
 *	--------------
 */
static void handle_sgmlent(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Entity Declaration:\n<%s>\n", s));

    return;
}

/*	Handle sgmlent
 *	--------------
 */
static void handle_sgmlele(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Element Declaration:\n<%s>\n", s));

    return;
}

/*	Handle sgmlatt
 *	--------------
 */
static void handle_sgmlatt(HTStream *context)
{
    const char *s = context->string->data;

    CTRACE((tfp, "SGML Attribute Declaration:\n<%s>\n", s));

    return;
}

/*
 * Convenience macros - tags (elements) are identified sometimes by an int or
 * enum value ('TAGNUM'), sometimes by a pointer to HTTag ('TAGP').  - kw
 */
#define TAGNUM_OF_TAGP(t) (HTMLElement) (t - context->dtd->tags)
#define TAGP_OF_TAGNUM(e) (context->dtd->tags + e)

/*
 * The following implement special knowledge about OBJECT.  As long as
 * HTML_OBJECT is the only tag for which an alternative variant exist, they can
 * be simple macros.  - kw
 */
/* does 'TAGNUM' e have an alternative (variant) parsing mode? */
#define HAS_ALT_TAGNUM(e) (e == HTML_OBJECT)

/* return 'TAGNUM' of the alternative mode for 'TAGNUM' e, if any. */
#define ALT_TAGNUM(e) ((e == HTML_OBJECT) ? HTML_ALT_OBJECT : e)

/* return 'TAGNUM' of the normal mode for 'TAGNUM' e which may be alt. */
#define NORMAL_TAGNUM(e) (((int)(e) >= HTML_ELEMENTS) ? HTML_OBJECT : (HTMLElement)e)

/* More convenience stuff. - kw */
#define ALT_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(ALT_TAGNUM(e))
#define NORMAL_TAGP_OF_TAGNUM(e) TAGP_OF_TAGNUM(NORMAL_TAGNUM(e))

#define ALT_TAGP(t) ALT_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))
#define NORMAL_TAGP(t) NORMAL_TAGP_OF_TAGNUM(TAGNUM_OF_TAGP(t))

static BOOL element_valid_within(HTTag * new_tag, HTTag * stacked_tag, int direct)
{
    BOOL result = YES;
    TagClass usecontains, usecontained;

    if (stacked_tag && new_tag) {
	usecontains = (direct ? stacked_tag->contains : stacked_tag->icontains);
	usecontained = (direct ? new_tag->contained : new_tag->icontained);
	if (new_tag == stacked_tag) {
	    result = (BOOL) ((Tgc_same & usecontains) &&
			     (Tgc_same & usecontained));
	} else {
	    result = (BOOL) ((new_tag->tagclass & usecontains) &&
			     (stacked_tag->tagclass & usecontained));
	}
    }
    return result;
}

typedef enum {
    close_NO = 0,
    close_error = 1,
    close_valid = 2
} canclose_t;

static canclose_t can_close(HTTag * new_tag, HTTag * stacked_tag)
{
    canclose_t result;

    if (!stacked_tag) {
	result = close_NO;
    } else if (stacked_tag->flags & Tgf_endO) {
	result = close_valid;
    } else if (new_tag == stacked_tag) {
	result = ((Tgc_same & new_tag->canclose)
		  ? close_error
		  : close_NO);
    } else {
	result = ((stacked_tag->tagclass & new_tag->canclose)
		  ? close_error
		  : close_NO);
    }
    return result;
}

static void do_close_stacked(HTStream *context)
{
    HTElement *stacked = context->element_stack;
    HTMLElement e;

    if (!stacked)
	return;			/* stack was empty */
    if (context->inSELECT && !strcasecomp(stacked->tag->name, "SELECT")) {
	context->inSELECT = FALSE;
    }
    e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(stacked->tag));
#ifdef USE_PRETTYSRC
    if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
#endif
	(*context->actions->end_element) (context->target,
					  (int) e,
					  &context->include);
    context->element_stack = stacked->next;
    pool_free(stacked);
    context->no_lynx_specialcodes =
	(BOOL) (context->element_stack
		? (context->element_stack->tag->flags & Tgf_nolyspcl)
		: NO);
}

static int is_on_stack(HTStream *context, HTTag * old_tag)
{
    HTElement *stacked = context->element_stack;
    int i = 1;

    for (; stacked; stacked = stacked->next, i++) {
	if (stacked->tag == old_tag ||
	    stacked->tag == ALT_TAGP(old_tag))
	    return i;
    }
    return 0;
}

/*	End element
 *	-----------
 */
static void end_element(HTStream *context, HTTag * old_tag)
{
    BOOL extra_action_taken = NO;
    canclose_t canclose_check = close_valid;
    int stackpos = is_on_stack(context, old_tag);

    if (!Old_DTD) {
	while (canclose_check != close_NO &&
	       context->element_stack &&
	       (stackpos > 1 || (!extra_action_taken && stackpos == 0))) {
	    if (stackpos == 0 && (old_tag->flags & Tgf_startO) &&
		element_valid_within(old_tag, context->element_stack->tag, YES)) {
		CTRACE((tfp, "SGML: </%s> ignored\n", old_tag->name));
		return;
	    }
	    canclose_check = can_close(old_tag, context->element_stack->tag);
	    if (canclose_check != close_NO) {
		CTRACE((tfp, "SGML: End </%s> \t<- %s end </%s>\n",
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			old_tag->name));
		do_close_stacked(context);
		extra_action_taken = YES;
		stackpos = is_on_stack(context, old_tag);
	    }
	}

	if (stackpos == 0 && old_tag->contents != SGML_EMPTY) {
	    CTRACE((tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
		    context->element_stack ?
		    context->element_stack->tag->name : "none",
		    old_tag->name,
		    old_tag->name));
	    return;
	}
	if (stackpos > 1) {
	    CTRACE((tfp,
		    "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
		    old_tag->name,
		    context->element_stack ?
		    context->element_stack->tag->name : "none",
		    old_tag->name));
	    return;
	}
    }
    /* Now let the non-extended code deal with the rest. - kw */

    /*
     * If we are in a SELECT block, ignore anything but a SELECT end tag.  - FM
     */
    if (context->inSELECT) {
	if (!strcasecomp(old_tag->name, "SELECT")) {
	    /*
	     * Turn off the inSELECT flag and fall through.  - FM
	     */
	    context->inSELECT = FALSE;
	} else {
	    /*
	     * Ignore the end tag.  - FM
	     */
	    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
		    old_tag->name));
	    return;
	}
    }
    /*
     * Handle the end tag.  - FM
     */
    CTRACE((tfp, "SGML: End </%s>\n", old_tag->name));
    if (old_tag->contents == SGML_EMPTY) {
	CTRACE((tfp, "SGML: ***Illegal end tag </%s> found.\n",
		old_tag->name));
	return;
    }
#ifdef WIND_DOWN_STACK
    while (context->element_stack)	/* Loop is error path only */
#else
    if (context->element_stack)	/* Substitute and remove one stack element */
#endif /* WIND_DOWN_STACK */
    {
	int status = HT_OK;
	HTMLElement e;
	HTElement *N = context->element_stack;
	HTTag *t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;

	if (old_tag != t) {	/* Mismatch: syntax error */
	    if (context->element_stack->next) {		/* This is not the last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			old_tag->name, t->name, t->name));
	    } else {		/* last level */
		CTRACE((tfp,
			"SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			old_tag->name, t->name, old_tag->name));
		return;		/* Ignore */
	    }
	}

	e = NORMAL_TAGNUM(TAGNUM_OF_TAGP(t));
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", (void *) t, (int) e));
#ifdef USE_PRETTYSRC
	if (!psrc_view)		/* Don't actually pass call on if viewing psrc - kw */
#endif
	    status = (*context->actions->end_element) (context->target,
						       (int) e,
						       &context->include);
	if (status == HT_PARSER_REOPEN_ELT) {
	    CTRACE((tfp, "SGML: Restart <%s>\n", t->name));
	    (*context->actions->start_element) (context->target,
						(int) e,
						NULL,
						NULL,
						context->current_tag_charset,
						&context->include);
	} else if (status == HT_PARSER_OTHER_CONTENT) {
	    CTRACE((tfp, "SGML: Continue with other content model for <%s>\n", t->name));
	    context->element_stack->tag = ALT_TAGP_OF_TAGNUM(e);
	} else {
	    context->element_stack = N->next;	/* Remove from stack */
	    pool_free(N);
	}
	context->no_lynx_specialcodes =
	    (BOOL) (context->element_stack
		    ? (context->element_stack->tag->flags & Tgf_nolyspcl)
		    : NO);
#ifdef WIND_DOWN_STACK
	if (old_tag == t)
	    return;		/* Correct sequence */
#else
	return;
#endif /* WIND_DOWN_STACK */

	/* Syntax error path only */

    }
    CTRACE((tfp, "SGML: Extra end tag </%s> found and ignored.\n",
	    old_tag->name));
}

/*	Start a element
*/
static void start_element(HTStream *context)
{
    int status;
    HTTag *new_tag = context->current_tag;
    HTMLElement e = TAGNUM_OF_TAGP(new_tag);
    BOOL ok = FALSE;

    BOOL valid = YES;
    BOOL direct_container = YES;
    BOOL extra_action_taken = NO;
    canclose_t canclose_check = close_valid;

    if (!Old_DTD) {
	while (context->element_stack &&
	       (canclose_check == close_valid ||
		(canclose_check == close_error &&
		 new_tag == context->element_stack->tag)) &&
	       !(valid = element_valid_within(new_tag,
					      context->element_stack->tag,
					      direct_container))) {
	    canclose_check = can_close(new_tag, context->element_stack->tag);
	    if (canclose_check != close_NO) {
		CTRACE((tfp, "SGML: End </%s> \t<- %s start <%s>\n",
			context->element_stack->tag->name,
			((canclose_check == close_valid)
			 ? "supplied,"
			 : "***forced by"),
			new_tag->name));
		do_close_stacked(context);
		extra_action_taken = YES;
		if (canclose_check == close_error)
		    direct_container = NO;
	    } else {
		CTRACE((tfp,
			"SGML: Still open %s \t<- ***invalid start <%s>\n",
			context->element_stack->tag->name,
			new_tag->name));
	    }
	}
	if (context->element_stack && !valid &&
	    (context->element_stack->tag->flags & Tgf_strict) &&
	    !(valid = element_valid_within(new_tag,
					   context->element_stack->tag,
					   direct_container))) {
	    CTRACE((tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
		    context->element_stack->tag->name,
		    new_tag->name));
	    return;
	}

	if (context->element_stack &&
	    !extra_action_taken &&
	    (canclose_check == close_NO) &&
	    !valid && (new_tag->flags & Tgf_mafse)) {
	    BOOL has_attributes = NO;
	    int i = 0;

	    for (; i < new_tag->number_of_attributes && !has_attributes; i++)
		has_attributes = context->present[i];
	    if (!has_attributes) {
		CTRACE((tfp,
			"SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
			context->element_stack->tag->name,
			new_tag->name,
			new_tag->name));
		end_element(context, new_tag);
		return;
	    }
	}

	if (context->element_stack &&
	    (canclose_check == close_error) &&
	    !element_valid_within(new_tag,
				  context->element_stack->tag,
				  direct_container)) {
	    CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
		    context->element_stack->tag->name,
		    new_tag->name));
	}
    }
    /* Fall through to the non-extended code - kw */

    /*
     * If we are not in a SELECT block, check if this is a SELECT start tag. 
     * Otherwise (i.e., we are in a SELECT block) accept only OPTION as valid,
     * terminate the SELECT block if it is any other form-related element, and
     * otherwise ignore it.  - FM
     */
    if (!context->inSELECT) {
	/*
	 * We are not in a SELECT block, so check if this starts one.  - FM
	 * (frequent case!)
	 */
	/* my_casecomp() - optimized by the first character */
	if (!my_casecomp(new_tag->name, "SELECT")) {
	    /*
	     * Set the inSELECT flag and fall through.  - FM
	     */
	    context->inSELECT = TRUE;
	}
    } else {
	/*
	 * We are in a SELECT block.  - FM
	 */
	if (strcasecomp(new_tag->name, "OPTION")) {
	    /*
	     * Ugh, it is not an OPTION.  - FM
	     */
	    switch (e) {
	    case HTML_INPUT:
	    case HTML_TEXTAREA:
	    case HTML_SELECT:
	    case HTML_BUTTON:
	    case HTML_FIELDSET:
	    case HTML_LABEL:
	    case HTML_LEGEND:
	    case HTML_FORM:
		ok = TRUE;
		break;
	    default:
		break;
	    }
	    if (ok) {
		/*
		 * It is another form-related start tag, so terminate the
		 * current SELECT block and fall through.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			new_tag->name));
		end_element(context, SGMLFindTag(context->dtd, "SELECT"));
	    } else {
		/*
		 * Ignore the start tag.  - FM
		 */
		CTRACE((tfp,
			"SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			new_tag->name));
		return;
	    }
	}
    }
    /*
     * Handle the start tag.  - FM
     */
    CTRACE((tfp, "SGML: Start <%s>\n", new_tag->name));
    status = (*context->actions->start_element) (context->target,
						 (int) TAGNUM_OF_TAGP(new_tag),
						 context->present,
						 (STRING2PTR) context->value,	/* coerce type for think c */
						 context->current_tag_charset,
						 &context->include);
    if (status == HT_PARSER_OTHER_CONTENT)
	new_tag = ALT_TAGP(new_tag);	/* this is only returned for OBJECT */
    if (new_tag->contents != SGML_EMPTY) {	/* i.e., tag not empty */
	HTElement *N = pool_alloc();

	if (N == NULL)
	    outofmem(__FILE__, "start_element");

	assert(N != NULL);

	N->next = context->element_stack;
	N->tag = new_tag;
	context->element_stack = N;
	context->no_lynx_specialcodes = (BOOLEAN) (new_tag->flags & Tgf_nolyspcl);

    } else if (e == HTML_META) {
	/*
	 * Check for result of META tag.  - KW & FM
	 */
	change_chartrans_handling(context);
    }
}

/*		Find Tag in DTD tag list
 *		------------------------
 *
 * On entry,
 *	dtd	points to dtd structure including valid tag list
 *	string	points to name of tag in question
 *
 * On exit,
 *	returns:
 *		NULL		tag not found
 *		else		address of tag structure in dtd
 */
HTTag *SGMLFindTag(const SGML_dtd * dtd,
		   const char *s)
{
    int high, low, i, diff;
    static HTTag *last[64] =
    {NULL};			/*optimize using the previous results */
    HTTag **res = last + (UCH(*s) % 64);	/*pointer arithmetic */

    if (*res) {
	if ((*res)->name == NULL)
	    return NULL;
	if (!strcasecomp((*res)->name, s))
	    return *res;
    }

    for (low = 0, high = dtd->number_of_tags;
	 high > low;
	 diff < 0 ? (low = i + 1) : (high = i)) {	/* Binary search */
	i = (low + (high - low) / 2);
	/* my_casecomp() - optimized by the first character, NOT_ASCII ok */
	diff = my_casecomp(dtd->tags[i].name, s);	/* Case insensitive */
	if (diff == 0) {	/* success: found it */
	    *res = &dtd->tags[i];
	    return *res;
	}
    }
    if (IsNmStart(*s)) {
	/*
	 * Unrecognized, but may be valid.  - KW
	 */
	return &HTTag_unrecognized;
    }
    return NULL;
}

/*________________________________________________________________________
 *			Public Methods
 */

/*	Could check that we are back to bottom of stack! @@@@  */
/*	Do check! - FM					     */
/*							     */
static void SGML_free(HTStream *context)
{
    int i;
    HTElement *cur;
    HTTag *t;

    /*
     * Free the buffers.  - FM
     */
    FREE(context->recover);
    FREE(context->url);
    FREE(context->csi);
    FREE(context->include);
    FREE(context->active_include);

    /*
     * Wind down stack if any elements are open.  - FM
     */
    while (context->element_stack) {
	cur = context->element_stack;
	t = cur->tag;
	context->element_stack = cur->next;	/* Remove from stack */
	pool_free(cur);
#ifdef USE_PRETTYSRC
	if (!psrc_view)		/* Don't actually call on target if viewing psrc - kw */
#endif
	    (*context->actions->end_element)
		(context->target,
		 (int) NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
		 &context->include);
	FREE(context->include);
    }

    /*
     * Finish off the target.  - FM
     */
    (*context->actions->_free) (context->target);

    /*
     * Free the strings and context structure.  - FM
     */
    HTChunkFree(context->string);
    for (i = 0; i < MAX_ATTRIBUTES; i++)
	FREE_extra(context->value[i]);
    FREE(context);

#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
#endif
}

static void SGML_abort(HTStream *context, HTError e)
{
    int i;
    HTElement *cur;

    /*
     * Abort the target.  - FM
     */
    (*context->actions->_abort) (context->target, e);

    /*
     * Free the buffers.  - FM
     */
    FREE(context->recover);
    FREE(context->include);
    FREE(context->active_include);
    FREE(context->url);
    FREE(context->csi);

    /*
     * Free stack memory if any elements were left open.  - KW
     */
    while (context->element_stack) {
	cur = context->element_stack;
	context->element_stack = cur->next;	/* Remove from stack */
	pool_free(cur);
    }

    /*
     * Free the strings and context structure.  - FM
     */
    HTChunkFree(context->string);
    for (i = 0; i < MAX_ATTRIBUTES; i++)
	FREE_extra(context->value[i]);
    FREE(context);

#ifdef USE_PRETTYSRC
    sgml_in_psrc_was_initialized = FALSE;
#endif
}

/*	Read and write user callback handle
 *	-----------------------------------
 *
 *   The callbacks from the SGML parser have an SGML context parameter.
 *   These calls allow the caller to associate his own context with a
 *   particular SGML context.
 */

#ifdef CALLERDATA
void *SGML_callerData(HTStream *context)
{
    return context->callerData;
}

void SGML_setCallerData(HTStream *context, void *data)
{
    context->callerData = data;
}
#endif /* CALLERDATA */

#ifdef USE_PRETTYSRC
static void transform_tag(HTStream *context, HTChunk *string)
{
    if (!context->strict_xml) {
	if (tagname_transform != 1) {
	    if (tagname_transform == 0)
		LYLowerCase(string->data);
	    else
		LYUpperCase(string->data);
	}
    }
}
#endif /* USE_PRETTYSRC */

static BOOL ignore_when_empty(HTTag * tag)
{
    BOOL result = FALSE;

    if (!LYPreparsedSource
	&& LYxhtml_parsing
	&& tag->name != 0
	&& !(tag->flags & Tgf_mafse)
	&& tag->contents != SGML_EMPTY
	&& tag->tagclass != Tgc_Plike
	&& (tag->tagclass == Tgc_SELECTlike
	    || (tag->contains && tag->icontains))) {
	result = TRUE;
    }
    CTRACE((tfp, "SGML Do%s ignore_when_empty:%s\n",
	    result ? "" : " not",
	    NonNull(tag->name)));
    return result;
}

static void discard_empty(HTStream *context)
{
    static HTTag empty_tag;

    CTRACE((tfp, "SGML discarding empty %s\n",
	    NonNull(context->current_tag->name)));
    CTRACE_FLUSH(tfp);

    memset(&empty_tag, 0, sizeof(empty_tag));
    context->current_tag = &empty_tag;
    context->string->size = 0;

    /* do not call end_element() if start_element() was not called */
}

#ifdef USE_PRETTYSRC
static BOOL end_if_prettysrc(HTStream *context, HTChunk *string, int end_ch)
{
    BOOL result = psrc_view;

    if (psrc_view) {
	if (attr_is_name) {
	    HTStartAnchor(context->target, string->data, NULL);
	    (*context->actions->end_element) (context->target,
					      HTML_A,
					      &context->include);
	} else if (attr_is_href) {
	    PSRCSTART(href);
	    HTStartAnchor(context->target, NULL, string->data);
	}
	PUTS_TR(string->data);
	if (attr_is_href) {
	    (*context->actions->end_element) (context->target,
					      HTML_A,
					      &context->include);
	    PSRCSTOP(href);
	}
	if (end_ch)
	    PUTC(end_ch);
	PSRCSTOP(attrval);
    }
    return result;
}
#endif

static void SGML_character(HTStream *context, int c_in)
{
    const SGML_dtd *dtd = context->dtd;
    HTChunk *string = context->string;
    const char *EntityName;
    HTTag *testtag = NULL;
    BOOLEAN chk;		/* Helps (?) walk through all the else ifs... */
    UCode_t clong, uck = 0;	/* Enough bits for UCS4 ... */
    int testlast;

    unsigned char c;
    unsigned char saved_char_in = '\0';

    ++sgml_offset;

    /*
     * Now some fun with the preprocessor.  Use copies for c and unsign_c ==
     * clong, so that we can revert back to the unchanged c_in.  - KW
     */
#define unsign_c clong

    c = UCH(c_in);
    clong = UCH(c);		/* a.k.a. unsign_c */

    if (context->T.decode_utf8) {
	/*
	 * Combine UTF-8 into Unicode.  Incomplete characters silently ignored. 
	 * From Linux kernel's console.c.  - KW
	 */
	if (TOASCII(UCH(c)) > 127) {	/* S/390 -- gil -- 0710 */
	    /*
	     * We have an octet from a multibyte character.  - FM
	     */
	    if (context->utf_count > 0 && (TOASCII(c) & 0xc0) == 0x80) {
		context->utf_char = (context->utf_char << 6) | (TOASCII(c) & 0x3f);
		context->utf_count--;
		*(context->utf_buf_p) = (char) c;
		(context->utf_buf_p)++;
		if (context->utf_count == 0) {
		    /*
		     * We have all of the bytes, so terminate the buffer and
		     * set 'clong' to the UCode_t value.  - FM
		     */
		    *(context->utf_buf_p) = '\0';
		    clong = context->utf_char;
		    if (clong < 256) {
			c = UCH(clong & 0xff);
		    }
		    /* lynx does not use left-to-right */
		    if (clong == 0x200e)
			return;
		    goto top1;
		} else {
		    /*
		     * Wait for more.  - KW
		     */
		    return;
		}
	    } else {
		/*
		 * Start handling a new multibyte character.  - FM
		 */
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = (char) c;
		(context->utf_buf_p)++;
		if ((c & 0xe0) == 0xc0) {
		    context->utf_count = 1;
		    context->utf_char = (c & 0x1f);
		} else if ((c & 0xf0) == 0xe0) {
		    context->utf_count = 2;
		    context->utf_char = (c & 0x0f);
		} else if ((c & 0xf8) == 0xf0) {
		    context->utf_count = 3;
		    context->utf_char = (c & 0x07);
		} else if ((c & 0xfc) == 0xf8) {
		    context->utf_count = 4;
		    context->utf_char = (c & 0x03);
		} else if ((c & 0xfe) == 0xfc) {
		    context->utf_count = 5;
		    context->utf_char = (c & 0x01);
		} else {
		    /*
		     * Garbage.  - KW
		     */
		    context->utf_count = 0;
		    context->utf_buf_p = context->utf_buf;
		    *(context->utf_buf_p) = '\0';
		}
		/*
		 * Wait for more.  - KW
		 */
		return;
	    }
	} else {
	    /*
	     * Got an ASCII char.  - KW
	     */
	    context->utf_count = 0;
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	    /*  goto top;  */
	}
    }
    /* end of context->T.decode_utf8      S/390 -- gil -- 0726 */
#ifdef NOTDEFINED
    /*
     * If we have a koi8-r input and do not have koi8-r as the output, save the
     * raw input in saved_char_in before we potentially convert it to Unicode. 
     * - FM
     */
    if (context->T.strip_raw_char_in)
	saved_char_in = c;
#endif /* NOTDEFINED */

    /*
     * If we want the raw input converted to Unicode, try that now.  - FM
     */
    if (context->T.trans_to_uni &&
#ifdef EXP_JAPANESEUTF8_SUPPORT
	((strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname, "euc-jp") == 0) ||
	 (strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname, "shift_jis") == 0))) {
	if (strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname, "shift_jis") == 0) {
	    if (context->utf_count == 0) {
		if (IS_SJIS_HI1((unsigned char) c) ||
		    IS_SJIS_HI2((unsigned char) c)) {
		    context->utf_buf[0] = (char) c;
		    context->utf_count = 1;
		    clong = -11;
		}
	    } else {
		if (IS_SJIS_LO((unsigned char) c)) {
		    context->utf_buf[1] = (char) c;
		    clong = UCTransJPToUni(context->utf_buf, 2, context->inUCLYhndl);
		}
		context->utf_count = 0;
	    }
	} else {
	    if (context->utf_count == 0) {
		if (IS_EUC_HI((unsigned char) c)) {
		    context->utf_buf[0] = (char) c;
		    context->utf_count = 1;
		    clong = -11;
		}
	    } else {
		if (IS_EUC_LOX((unsigned char) c)) {
		    context->utf_buf[1] = (char) c;
		    clong = UCTransJPToUni(context->utf_buf, 2, context->inUCLYhndl);
		}
		context->utf_count = 0;
	    }
	}
	goto top1;
    } else if (context->T.trans_to_uni &&
#endif
	       ((TOASCII(unsign_c) >= LYlowest_eightbit[context->inUCLYhndl]) ||	/* S/390 -- gil -- 0744 */
		(unsign_c < ' ' && unsign_c != 0 &&
		 context->T.trans_C0_to_uni))) {
	/*
	 * Convert the octet to Unicode.  - FM
	 */
	clong = UCTransToUni((char) c, context->inUCLYhndl);
	if (clong > 0) {
	    saved_char_in = c;
	    if (clong < 256) {
		c = FROMASCII(UCH(clong));
	    }
	}
	goto top1;
    } else if (unsign_c < ' ' && unsign_c != 0 &&	/* S/390 -- gil -- 0768 */
	       context->T.trans_C0_to_uni) {
	/*
	 * This else if may be too ugly to keep.  - KW
	 */
	if (context->T.trans_from_uni &&
	    (((clong = UCTransToUni((char) c, context->inUCLYhndl)) >= ' ') ||
	     (context->T.transp &&
	      (clong = UCTransToUni((char) c, context->inUCLYhndl)) > 0))) {
	    saved_char_in = c;
	    if (clong < 256) {
		c = FROMASCII(UCH(clong));
	    }
	    goto top1;
	} else {
	    uck = -1;
	    if (context->T.transp) {
		uck = UCTransCharStr(replace_buf, 60, (char) c,
				     context->inUCLYhndl,
				     context->inUCLYhndl, NO);
	    }
	    if (!context->T.transp || uck < 0) {
		uck = UCTransCharStr(replace_buf, 60, (char) c,
				     context->inUCLYhndl,
				     context->outUCLYhndl, YES);
	    }
	    if (uck == 0) {
		return;
	    } else if (uck < 0) {
		goto top0a;
	    }
	    c = UCH(replace_buf[0]);
	    if (c && replace_buf[1]) {
		if (context->state == S_text) {
		    PUTS(replace_buf);
		    return;
		}
		StrAllocCat(context->recover, replace_buf + 1);
	    }
	    goto top0a;
	}			/*  Next line end of ugly stuff for C0. - KW */
    } else {			/* end of context->T.trans_to_uni  S/390 -- gil -- 0791 */
	goto top0a;
    }

    /*
     * At this point we have either unsign_c a.k.a.  clong in Unicode (and c in
     * latin1 if clong is in the latin1 range), or unsign_c and c will have to
     * be passed raw.  - KW
     */
/*
 *  We jump up to here from below if we have
 *  stuff in the recover, insert, or csi buffers
 *  to process.	 We zero saved_char_in, in effect
 *  as a flag that the octet is not that of the
 *  actual call to this function.  This may be OK
 *  for now, for the stuff this function adds to
 *  its recover buffer, but it might not be for
 *  stuff other functions added to the insert or
 *  csi buffer, so bear that in mind. - FM
 *  Stuff from the recover buffer is now handled
 *  as UTF-8 if we can expect that's what it is,
 *  and in that case we don't come back up here. - kw
 */
  top:
    saved_char_in = '\0';
/*
 *  We jump to here from above when we don't have
 *  UTF-8 input, haven't converted to Unicode, and
 *  want clong set to the input octet (unsigned)
 *  without zeroing its saved_char_in copy (which
 *  is signed). - FM
 */
  top0a:
    *(context->utf_buf) = '\0';
    clong = UCH(c);
/*
 *  We jump to here from above if we have converted
 *  the input, or a multibyte sequence across calls,
 *  to a Unicode value and loaded it into clong (to
 *  which unsign_c has been defined), and from below
 *  when we are recycling a character (e.g., because
 *  it terminated an entity but is not the standard
 *  semi-colon).  The character will already have
 *  been put through the Unicode conversions. - FM
 */
  top1:
    /*
     * Ignore low ISO 646 7-bit control characters if HTCJK is not set.  - FM
     */
    /*
     * Works for both ASCII and EBCDIC. -- gil
     * S/390 -- gil -- 0811
     */
    if (TOASCII(unsign_c) < 32 &&
	c != '\t' && c != '\n' && c != '\r' &&
	!IS_CJK_TTY)
	goto after_switch;

    /*
     * Ignore 127 if we don't have HTPassHighCtrlRaw or HTCJK set.  - FM
     */
#define PASSHICTRL (context->T.transp || \
		    unsign_c >= LYlowest_eightbit[context->inUCLYhndl])
    if (TOASCII(c) == 127 &&	/* S/390 -- gil -- 0830 */
	!(PASSHICTRL || IS_CJK_TTY))
	goto after_switch;

    /*
     * Ignore 8-bit control characters 128 - 159 if neither HTPassHighCtrlRaw
     * nor HTCJK is set.  - FM
     */
    if (TOASCII(unsign_c) > 127 && TOASCII(unsign_c) < 160 &&	/* S/390 -- gil -- 0847 */
	!(PASSHICTRL || IS_CJK_TTY)) {
	/*
	 * If we happen to be reading from an "ISO-8859-1" or "US-ASCII"
	 * document, allow the cp-1252 codes, to accommodate the HTML5 draft
	 * recommendation for replacement encoding:
	 *
	 * http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#character-encodings-0
	 */
	if (AssumeCP1252(context)) {
	    clong = LYcp1252ToUnicode((UCode_t) c);
	    goto top1;
	}
	goto after_switch;
    }

    /* Almost all CJK characters are double byte but only Japanese
     * JIS X0201 Kana is single byte. To prevent to fail SGML parsing
     * we have to take care of them here. -- TH
     */
    if ((HTCJK == JAPANESE) && (context->state == S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& !context->T.decode_utf8
#endif
	) {
#ifdef CONV_JISX0201KANA_JISX0208KANA
	if (IS_SJIS_X0201KANA(context->kanji_buf)) {
	    unsigned char sjis_hi, sjis_lo;

	    JISx0201TO0208_SJIS(context->kanji_buf, &sjis_hi, &sjis_lo);
	    PUTC(sjis_hi);
	    PUTC(sjis_lo);
	} else
#endif
	    PUTC(context->kanji_buf);
	context->state = S_text;
    }

    /*
     * Handle character based on context->state.
     */
    CTRACE2(TRACE_SGML, (tfp, "SGML before %s|%.*s|%c|\n",
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));
    switch (context->state) {

    case S_in_kanji:
	/*
	 * Note that if we don't have a CJK input, then this is not the second
	 * byte of a CJK di-byte, and we're trashing the input.  That's why
	 * 8-bit characters followed by, for example, '<' can cause the tag to
	 * be treated as text, not markup.  We could try to deal with it by
	 * holding each first byte and then checking byte pairs, but that
	 * doesn't seem worth the overhead (see below).  - FM
	 */
	context->state = S_text;
	PUTC(context->kanji_buf);
	PUTC(c);
	break;

    case S_tagname_slash:
	/*
	 * We had something link "<name/" so far, set state to S_text but keep
	 * context->slashedtag as a flag; except if we get '>' directly
	 * after the "<name/", and really have a tag for that name in
	 * context->slashedtag, in which case keep state as is and let code
	 * below deal with it.  - kw
	 */
	if (!(c == '>' && context->slashedtag && TOASCII(unsign_c) < 127)) {
	    context->state = S_text;
	}
	/* fall through in any case! */
    case S_text:
	if (IS_CJK_TTY && ((TOASCII(c) & 0200) != 0)
#ifdef EXP_JAPANESEUTF8_SUPPORT
	    && !context->T.decode_utf8
#endif
	    ) {			/* S/390 -- gil -- 0864 */
	    /*
	     * Setting up for Kanji multibyte handling (based on Takuya ASADA's
	     * (asada@@three-a.co.jp) CJK Lynx).  Note that if the input is not
	     * in fact CJK, the next byte also will be mishandled, as explained
	     * above.  Toggle raw mode off in such cases, or select the "7 bit
	     * approximations" display character set, which is largely
	     * equivalent to having raw mode off with CJK.  - FM
	     */
	    context->state = S_in_kanji;
	    context->kanji_buf = c;
	    break;
	} else if (IS_CJK_TTY && TOASCII(c) == '\033') {	/* S/390 -- gil -- 0881 */
	    /*
	     * Setting up for CJK escape sequence handling (based on Takuya
	     * ASADA's (asada@@three-a.co.jp) CJK Lynx).  - FM
	     */
	    context->state = S_esc;
	    PUTC(c);
	    break;
	}

	if (c == '&' || c == '<') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {	/*there is nothing useful in the element_stack */
		testtag = context->current_tag;
	    } else
#endif
	    {
		testtag = context->element_stack ?
		    context->element_stack->tag : NULL;
	    }
	}

	if (c == '&' && TOASCII(unsign_c) < 127 &&	/* S/390 -- gil -- 0898 */
	    (!testtag ||
	     (testtag->contents == SGML_MIXED ||
	      testtag->contents == SGML_ELEMENT ||
	      testtag->contents == SGML_PCDATA ||
#ifdef USE_PRETTYSRC
	      testtag->contents == SGML_EMPTY ||
#endif
	      testtag->contents == SGML_RCDATA))) {
	    /*
	     * Setting up for possible entity, without the leading '&'.  - FM
	     */
	    string->size = 0;
	    context->state = S_ero;
	} else if (c == '<' && TOASCII(unsign_c) < 127) {	/* S/390 -- gil -- 0915 */
	    /*
	     * Setting up for possible tag.  - FM
	     */
	    string->size = 0;
	    if (testtag && testtag->contents == SGML_PCDATA) {
		context->state = S_pcdata;
	    } else if (testtag && (testtag->contents == SGML_LITTERAL
				   || testtag->contents == SGML_CDATA)) {
		context->state = S_litteral;
	    } else if (testtag && (testtag->contents == SGML_SCRIPT)) {
		context->state = S_script;
	    } else {
		context->state = S_tag;
	    }
	    context->slashedtag = NULL;
	} else if (context->slashedtag &&
		   context->slashedtag->name &&
		   (c == '/' ||
		    (c == '>' && context->state == S_tagname_slash)) &&
		   TOASCII(unsign_c) < 127) {
	    /*
	     * We got either the second slash of a pending "<NAME/blah blah/"
	     * shortref construct, or the '>' of a mere "<NAME/>".  In both
	     * cases generate a "</NAME>" end tag in the recover buffer for
	     * reparsing unless NAME is really an empty element.  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC(c);
		PSRCSTOP(abracket);
	    } else
#endif
		if (context->slashedtag != context->unknown_tag &&
		    !ReallyEmptyTag(context->slashedtag)) {
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, "</");
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, "</");
		}
		StrAllocCat(context->recover, context->slashedtag->name);
		StrAllocCat(context->recover, ">");
	    }
	    context->slashedtag = NULL;

	} else if (context->element_stack &&
		   (context->element_stack->tag->flags & Tgf_frecyc)) {
	    /*
	     * The element stack says we are within the contents of an element
	     * that the next stage (HTML.c) may want to feed us back again (via
	     * the *include string).  So try to output text in UTF-8 if
	     * possible, using the same logic as for attribute values (which
	     * should be in line with what context->current_tag_charset
	     * indicates).  - kw
	     */
	    if (context->T.decode_utf8 &&
		*context->utf_buf) {
		PUTS(context->utf_buf);
		context->utf_buf_p = context->utf_buf;
		*(context->utf_buf_p) = '\0';
	    } else if (!IS_CJK_TTY &&
		       (context->T.output_utf8 ||
			context->T.trans_from_uni)) {
		if (LYIsASCII(clong)) {
		    PUTC(c);
		} else if (clong == 0xfffd && saved_char_in &&
			   HTPassEightBitRaw &&
			   saved_char_in >=
			   LYlowest_eightbit[context->outUCLYhndl]) {
		    PUTUTF8((UCode_t) (0xf000 | saved_char_in));
		} else {
		    PUTUTF8(clong);
		}
	    } else if (saved_char_in && context->T.use_raw_char_in) {
		PUTC(saved_char_in);
	    } else {
		PUTC(c);
	    }

#define PASS8859SPECL context->T.pass_160_173_raw
	    /*
	     * Convert 160 (nbsp) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_NBSP &&	/* S/390 -- gil -- 0932 */
		   !context->no_lynx_specialcodes &&
		   !(PASS8859SPECL || IS_CJK_TTY)) {
	    PUTC(HT_NON_BREAK_SPACE);
	    /*
	     * Convert 173 (shy) to Lynx special character if neither
	     * HTPassHighCtrlRaw nor HTCJK is set.  - FM
	     */
	} else if (unsign_c == CH_SHY &&	/* S/390 -- gil -- 0949 */
		   !context->no_lynx_specialcodes &&
		   !(PASS8859SPECL || IS_CJK_TTY)) {
	    PUTC(LY_SOFT_HYPHEN);
	    /*
	     * Handle the case in which we think we have a character which
	     * doesn't need further processing (e.g., a koi8-r input for a
	     * koi8-r output).  - FM
	     */
	} else if (context->T.use_raw_char_in && saved_char_in) {
	    /*
	     * Only if the original character is still in saved_char_in,
	     * otherwise we may be iterating from a goto top.  - KW
	     */
	    PUTC(saved_char_in);
/******************************************************************
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
 ******************************************************************/
	} else if ((chk = (BOOL) (context->T.trans_from_uni &&
				  TOASCII(unsign_c) >= 160)) &&		/* S/390 -- gil -- 0968 */
		   (uck = UCTransUniChar(unsign_c,
					 context->outUCLYhndl)) >= ' ' &&
		   uck < 256) {
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2" PRI_UCode_t
		    ":'%c'.\n",
		    uck, FROMASCII((char)uck)));
	    /*
	     * We got one octet from the conversions, so use it.  - FM
	     */
	    PUTC(FROMASCII((char) uck));
	} else if ((chk &&
		    (uck == -4 ||
		     (context->T.repl_translated_C0 &&
		      uck > 0 && uck < 32))) &&
	    /*
	     * Not found; look for replacement string.  - KW
	     */
		   (uck = UCTransUniCharStr(replace_buf, 60, clong,
					    context->outUCLYhndl,
					    0) >= 0)) {
	    /*
	     * Got a replacement string.  No further tests for validity -
	     * assume that whoever defined replacement strings knew what she
	     * was doing.  - KW
	     */
	    PUTS(replace_buf);
	    /*
	     * If we're displaying UTF-8, try that now.  - FM
	     */
	} else if (context->T.output_utf8 && PUTUTF8(clong)) {
	    ;			/* do nothing more */
	    /*
	     * If it's any other (> 160) 8-bit character, and we have not set
	     * HTPassEightBitRaw nor HTCJK, nor have the "ISO Latin 1"
	     * character set selected, back translate for our character set.  -
	     * FM
	     */
#define IncludesLatin1Enc \
		(context->outUCLYhndl == LATIN1 || \
		 (context->outUCI && \
		  (context->outUCI->enc & (UCT_CP_SUPERSETOF_LAT1))))

#define PASSHI8BIT (HTPassEightBitRaw || \
		    (context->T.do_8bitraw && !context->T.trans_from_uni))

	} else if (unsign_c > 160 && unsign_c < 256 &&
		   !(PASSHI8BIT || IS_CJK_TTY) &&
		   !IncludesLatin1Enc) {
#ifdef USE_PRETTYSRC
	    int psrc_view_backup = 0;
#endif

	    string->size = 0;
	    EntityName = HTMLGetEntityName((UCode_t) (unsign_c - 160));
	    HTChunkPuts(string, EntityName);
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    /* we need to disable it temporarily */
	    if (psrc_view) {
		psrc_view_backup = 1;
		psrc_view = 0;
	    }
#endif
	    handle_entity(context, '\0');
#ifdef USE_PRETTYSRC
	    /* we need to disable it temporarily */
	    if (psrc_view_backup)
		psrc_view = TRUE;
#endif

	    string->size = 0;
	    if (!FoundEntity)
		PUTC(';');
	    /*
	     * If we get to here and have an ASCII char, pass the character.  -
	     * KW
	     */
	} else if (TOASCII(unsign_c) < 127 && unsign_c > 0) {	/* S/390 -- gil -- 0987 */
	    PUTC(c);
	    /*
	     * If we get to here, and should have translated, translation has
	     * failed so far.  - KW
	     *
	     * We should have sent UTF-8 output to the parser already, but what
	     * the heck, try again.  - FM
	     */
	} else if (context->T.output_utf8 && *context->utf_buf) {
	    PUTS(context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
#ifdef NOTDEFINED
	    /*
	     * Check for a strippable koi8-r 8-bit character.  - FM
	     */
	} else if (context->T.strip_raw_char_in && saved_char_in &&
		   (saved_char_in >= 0xc0) &&
		   (saved_char_in < 255)) {
	    /*
	     * KOI8 special:  strip high bit, gives (somewhat) readable ASCII
	     * or KOI7 - it was constructed that way!  - KW
	     */
	    PUTC((saved_char_in & 0x7f));
	    saved_char_in = '\0';
#endif /* NOTDEFINED */
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if (TOASCII(UCH(c)) <	/* S/390 -- gil -- 0997 */
		   LYlowest_eightbit[context->outUCLYhndl] ||
		   (context->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	     * If we get to here, pass the character.  - FM
	     */
	} else {
	    PUTC(c);
	}
	break;

	/*
	 * Found '<' in SGML_PCDATA content; treat this mode nearly like
	 * S_litteral, but recognize '<!' and '<?' to filter out comments and
	 * processing instructions.  - kw
	 */
    case S_pcdata:
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
		/*
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    } else if (c == '?') {	/* <? - ignore as a PI until '>' - kw */
		CTRACE((tfp,
			"SGML: Found PI in PCDATA, junking it until '>'\n"));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("<?");
		    PSRCSTOP(abracket);
		}
#endif
		context->state = S_pi;
		break;
	    }
	}
	goto case_S_litteral;

	/*
	 * Found '<' in SGML_SCRIPT content; treat this mode nearly like
	 * S_litteral, but recognize '<!' to allow the content to be treated as
	 * a comment by lynx.
	 */
    case S_script:
	if (!string->size && TOASCII(unsign_c) < 127) {		/* first after '<' */
	    if (c == '!') {	/* <! */
		/*
		 * Terminate and set up for possible comment, identifier,
		 * declaration, or marked section as under S_tag.  - kw
		 */
		context->state = S_exclamation;
		context->lead_exclamation = TRUE;
		context->doctype_bracket = FALSE;
		context->first_bracket = FALSE;
		HTChunkPutc(string, c);
		break;
	    }
	}
	goto case_S_litteral;

	/*
	 * In litteral mode, waits only for specific end tag (for compatibility
	 * with old servers, and for Lynx).  - FM
	 */
      case_S_litteral:
    case S_litteral:
	/*PSRC:this case not understood completely by HV, not done */
	HTChunkPutc(string, c);
#ifdef USE_PRETTYSRC
	if (psrc_view) {
	    /* there is nothing useful in the element_stack */
	    testtag = context->current_tag;
	} else
#endif
	    testtag = (context->element_stack
		       ? context->element_stack->tag
		       : NULL);

	if (testtag == NULL || testtag->name == NULL) {
	    string->size--;
	    context->state = S_text;
	    goto top1;
	}

	/*
	 * Normally when we get the closing ">",
	 *      testtag contains something like "TITLE"
	 *      string contains something like "/title>"
	 * so we decrement by 2 to compare the final character of each.
	 */
	testlast = string->size - 2 - context->trailing_spaces - context->leading_spaces;

	if (TOUPPER(c) != ((testlast < 0)
			   ? '/'
			   : testtag->name[testlast])) {
	    int i;

	    /*
	     * If complete match, end litteral.
	     */
	    if ((c == '>') &&
		testlast >= 0 && !testtag->name[testlast]) {
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    char *trailing = NULL;

		    if (context->trailing_spaces) {
			StrAllocCopy(trailing,
				     string->data
				     + string->size
				     - 1
				     - context->trailing_spaces);
			trailing[context->trailing_spaces] = '\0';
		    }

		    PSRCSTART(abracket);
		    PUTS("</");
		    PSRCSTOP(abracket);
		    PSRCSTART(tag);

		    strcpy(string->data, context->current_tag->name);
		    transform_tag(context, string);
		    PUTS(string->data);

		    if (trailing) {
			PUTS(trailing);
			FREE(trailing);
		    }

		    PSRCSTOP(tag);
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);

		    context->current_tag = NULL;
		} else
#endif
		    end_element(context, context->element_stack->tag);

		string->size = 0;
		context->current_attribute_number = INVALID;
		context->state = S_text;
		context->leading_spaces = 0;
		context->trailing_spaces = 0;
		break;
	    }

	    /*
	     * Allow whitespace between the "<" or ">" and the keyword, for
	     * error-recovery.
	     */
	    if (isspace(UCH(c))) {
		if (testlast == -1) {
		    context->leading_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "leading spaces: %d\n", context->leading_spaces));
		    break;
		} else if (testlast > 0) {
		    context->trailing_spaces += 1;
		    CTRACE2(TRACE_SGML, (tfp, "trailing spaces: %d\n", context->trailing_spaces));
		    break;
		}
	    }

	    /*
	     * Mismatch - recover.
	     */
	    context->leading_spaces = 0;
	    context->trailing_spaces = 0;
	    if (((testtag->contents != SGML_LITTERAL &&
		  (testtag->flags & Tgf_strict)) ||
		 (context->state == S_pcdata &&
		  (testtag->flags & (Tgf_strict | Tgf_endO)))) &&
		(testlast > -1 &&
		 (c == '>' || testlast > 0 || IsNmStart(c)))) {
		context->state = S_end;
		string->size--;
		for (i = 0; i < string->size; i++)	/* remove '/' */
		    string->data[i] = string->data[i + 1];
		if ((string->size == 1) ? IsNmStart(c) : IsNmChar(c))
		    break;
		string->size--;
		goto top1;
	    }
	    if (context->state == S_pcdata &&
		(testtag->flags & (Tgf_strict | Tgf_endO)) &&
		(testlast < 0 && IsNmStart(c))) {
		context->state = S_tag;
		break;
	    }
	    /*
	     * If Mismatch:  recover string literally.
	     */
	    PUTC('<');
	    for (i = 0; i < string->size - 1; i++)	/* recover, except last c */
		PUTC(string->data[i]);
	    string->size = 0;
	    context->state = S_text;
	    goto top1;		/* to recover last c */
	}
	break;

	/*
	 * Character reference (numeric entity) or named entity.
	 */
    case S_ero:
	if (c == '#') {
	    /*
	     * Setting up for possible numeric entity.
	     */
	    context->state = S_cro;	/* &# is Char Ref Open */
	    break;
	}
	context->state = S_entity;	/* Fall through! */

	/*
	 * Handle possible named entity.
	 */
    case S_entity:
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1029 */
					isalnum(UCH(c)) : isalpha(UCH(c)))) {
	    /* Should probably use IsNmStart/IsNmChar above (is that right?),
	       but the world is not ready for that - there's &nbsp: (note
	       colon!) and stuff around. */
	    /*
	     * Accept valid ASCII character.  - FM
	     */
	    HTChunkPutc(string, c);
	} else if (string->size == 0) {
	    /*
	     * It was an ampersand that's just text, so output the ampersand
	     * and recycle this character.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTC('&');
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    context->state = S_text;
	    goto top1;
	} else {
	    /*
	     * Terminate entity name and try to handle it.  - FM
	     */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    entity_string = string->data;
#endif
	    /* S/390 -- gil -- 1039 */
	    /* CTRACE((tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data)); */
	    if (!strcmp(string->data, "zwnj") &&
		(!context->element_stack ||
		 (context->element_stack->tag &&
		  context->element_stack->tag->contents == SGML_MIXED))) {
		/*
		 * Handle zwnj (8204) as <WBR>.  - FM
		 */
		char temp[8];

		CTRACE((tfp,
			"SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));

		if (c != ';') {
		    sprintf(temp, "<WBR>%c", c);
		} else {
		    sprintf(temp, "<WBR>");
		}
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, temp);
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, temp);
		}
		string->size = 0;
		context->state = S_text;
		break;
	    } else {
		handle_entity(context, '\0');
	    }
	    string->size = 0;
	    context->state = S_text;
	    /*
	     * Don't eat the terminator if we didn't find the entity name and
	     * therefore sent the raw string via handle_entity(), or if the
	     * terminator is not the "standard" semi-colon for HTML.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view && FoundEntity && c == ';') {
		PSRCSTART(entity);
		PUTC(c);
		PSRCSTOP(entity);
	    }
#endif
	    if (!FoundEntity || c != ';')
		goto top1;
	}
	break;

	/*
	 * Check for a numeric entity.
	 */
    case S_cro:
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {	/* S/390 -- gil -- 1060 */
	    context->isHex = TRUE;
	    context->state = S_incro;
	} else if (TOASCII(unsign_c) < 127 && isdigit(UCH(c))) {
	    /*
	     * Accept only valid ASCII digits.  - FM
	     */
	    HTChunkPutc(string, c);	/* accumulate a character NUMBER */
	    context->isHex = FALSE;
	    context->state = S_incro;
	} else if (string->size == 0) {
	    /*
	     * No 'x' or digit following the "&#" so recover them and recycle
	     * the character.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTC('&');
	    PUTC('#');
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    context->state = S_text;
	    goto top1;
	}
	break;

	/*
	 * Handle a numeric entity.
	 */
    case S_incro:
	/* S/390 -- gil -- 1075 */
	if ((TOASCII(unsign_c) < 127) &&
	    (context->isHex
	     ? isxdigit(UCH(c))
	     : isdigit(UCH(c)))) {
	    /*
	     * Accept only valid hex or ASCII digits.  - FM
	     */
	    HTChunkPutc(string, c);	/* accumulate a character NUMBER */
	} else if (string->size == 0) {
	    /*
	     * No hex digit following the "&#x" so recover them and recycle the
	     * character.  - FM
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTS("&#x");
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    context->isHex = FALSE;
	    context->state = S_text;
	    goto top1;
	} else {
	    /*
	     * Terminate the numeric entity and try to handle it.  - FM
	     */
	    UCode_t code;
	    int i;

	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    entity_string = string->data;
#endif
	    if (UCScanCode(&code, string->data, context->isHex)) {

/* =============== work in ASCII below here ===============  S/390 -- gil -- 1092 */
		if (AssumeCP1252(context)) {
		    code = LYcp1252ToUnicode(code);
		}
		/*
		 * Check for special values.  - FM
		 */
		if ((code == 8204) &&
		    (!context->element_stack ||
		     (context->element_stack->tag &&
		      context->element_stack->tag->contents == SGML_MIXED))) {
		    /*
		     * Handle zwnj (8204) as <WBR>.  - FM
		     */
		    char temp[8];

		    CTRACE((tfp,
			    "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));

		    /*
		     * Include the terminator if it is not the standard
		     * semi-colon.  - FM
		     */
		    if (c != ';') {
			sprintf(temp, "<WBR>%c", c);
		    } else {
			sprintf(temp, "<WBR>");
		    }
		    /*
		     * Add the replacement string to the recover buffer for
		     * processing.  - FM
		     */
		    if (context->recover == NULL) {
			StrAllocCopy(context->recover, temp);
			context->recover_index = 0;
		    } else {
			StrAllocCat(context->recover, temp);
		    }
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    break;
		} else if (put_special_unicodes(context, code)) {
		    /*
		     * We handled the value as a special character, so recycle
		     * the terminator or break.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(entity);
			PUTS((context->isHex ? "&#x" : "&#"));
			PUTS(entity_string);
			if (c == ';')
			    PUTC(';');
			PSRCSTOP(entity);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    if (c != ';')
			goto top1;
		    break;
		}
		/*
		 * Seek a translation from the chartrans tables.
		 */
		if ((uck = UCTransUniChar(code,
					  context->outUCLYhndl)) >= 32 &&
		    uck < 256 &&
		    (uck < 127 ||
		     uck >= LYlowest_eightbit[context->outUCLYhndl])) {
#ifdef USE_PRETTYSRC
		    if (!psrc_view) {
#endif
			PUTC(FROMASCII((char) uck));
#ifdef USE_PRETTYSRC
		    } else {
			put_pretty_number(context);
		    }
#endif
		} else if ((uck == -4 ||
			    (context->T.repl_translated_C0 &&
			     uck > 0 && uck < 32)) &&
		    /*
		     * Not found; look for replacement string.
		     */
			   (uck = UCTransUniCharStr(replace_buf, 60, code,
						    context->outUCLYhndl,
						    0) >= 0)) {
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			put_pretty_number(context);
		    } else
#endif
			PUTS(replace_buf);
		    /*
		     * If we're displaying UTF-8, try that now.  - FM
		     */
		} else if (context->T.output_utf8 && PUTUTF8(code)) {
		    ;		/* do nothing more */
		    /*
		     * Ignore 8205 (zwj), 8206 (lrm), and 8207 (rln), if we get
		     * to here.  - FM
		     */
		} else if (code == 8205 ||
			   code == 8206 ||
			   code == 8207) {
		    if (TRACE) {
			string->size--;
			LYStrNCpy(replace_buf,
				  string->data,
				  (string->size < 64 ? string->size : 63));
			fprintf(tfp,
				"SGML_character: Ignoring '%s%s'.\n",
				(context->isHex ? "&#x" : "&#"),
				replace_buf);
		    }
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(badseq);
			PUTS((context->isHex ? "&#x" : "&#"));
			PUTS(entity_string);
			if (c == ';')
			    PUTC(';');
			PSRCSTOP(badseq);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    if (c != ';')
			goto top1;
		    break;
		    /*
		     * Show the numeric entity if we get to here and the value:
		     * (1) Is greater than 255 (but use ASCII characters for
		     * spaces or dashes).
		     * (2) Is less than 32, and not valid or we don't have
		     * HTCJK set.
		     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK
		     * set.
		     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum
		     * set.
		     * - FM
		     */
		} else if ((code > 255) ||
			   (code < ' ' &&	/* S/390 -- gil -- 1140 */
			    code != '\t' && code != '\n' && code != '\r' &&
			    !IS_CJK_TTY) ||
			   (TOASCII(code) == 127 &&
			    !(HTPassHighCtrlRaw || IS_CJK_TTY)) ||
			   (TOASCII(code) > 127 && code < 160 &&
			    !HTPassHighCtrlNum)) {
		    /*
		     * Unhandled or illegal value.  Recover the "&#" or "&#x"
		     * and digit(s), and recycle the terminator.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(badseq);
		    }
#endif
		    if (context->isHex) {
			PUTS("&#x");
			context->isHex = FALSE;
		    } else {
			PUTS("&#");
		    }
		    string->size--;
		    for (i = 0; i < string->size; i++)	/* recover */
			PUTC(string->data[i]);
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTOP(badseq);
		    }
#endif
		    string->size = 0;
		    context->isHex = FALSE;
		    context->state = S_text;
		    goto top1;
		} else if (TOASCII(code) < 161 ||	/* S/390 -- gil -- 1162 */
			   HTPassEightBitNum ||
			   IncludesLatin1Enc) {
		    /*
		     * No conversion needed.  - FM
		     */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			put_pretty_number(context);
		    } else
#endif
			PUTC(FROMASCII((char) code));
		} else {
		    /*
		     * Handle as named entity.  - FM
		     */
		    code -= 160;
		    EntityName = HTMLGetEntityName(code);
		    if (EntityName && EntityName[0] != '\0') {
			string->size = 0;
			HTChunkPuts(string, EntityName);
			HTChunkTerminate(string);
			handle_entity(context, '\0');
			/*
			 * Add a semi-colon if something went wrong and
			 * handle_entity() sent the string.  - FM
			 */
			if (!FoundEntity) {
			    PUTC(';');
			}
		    } else {
			/*
			 * Our conversion failed, so recover the "&#" and
			 * digit(s), and recycle the terminator.  - FM
			 */
#ifdef USE_PRETTYSRC
			if (psrc_view)
			    PSRCSTART(badseq);
#endif
			if (context->isHex) {
			    PUTS("&#x");
			    context->isHex = FALSE;
			} else {
			    PUTS("&#");
			}
			string->size--;
			for (i = 0; i < string->size; i++)	/* recover */
			    PUTC(string->data[i]);
#ifdef USE_PRETTYSRC
			if (psrc_view)
			    PSRCSTOP(badseq);
#endif
			string->size = 0;
			context->isHex = FALSE;
			context->state = S_text;
			goto top1;
		    }
		}
		/*
		 * If we get to here, we succeeded.  Hoorah!!!  - FM
		 */
		string->size = 0;
		context->isHex = FALSE;
		context->state = S_text;
		/*
		 * Don't eat the terminator if it's not the "standard"
		 * semi-colon for HTML.  - FM
		 */
		if (c != ';') {
		    goto top1;
		}
	    } else {
		/*
		 * Not an entity, and don't know why not, so add the terminator
		 * to the string, output the "&#" or "&#x", and process the
		 * string via the recover element.  - FM
		 */
		string->size--;
		HTChunkPutc(string, c);
		HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTART(badseq);
#endif
		if (context->isHex) {
		    PUTS("&#x");
		    context->isHex = FALSE;
		} else {
		    PUTS("&#");
		}
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTOP(badseq);
#endif
		if (context->recover == NULL) {
		    StrAllocCopy(context->recover, string->data);
		    context->recover_index = 0;
		} else {
		    StrAllocCat(context->recover, string->data);
		}
		string->size = 0;
		context->isHex = FALSE;
		context->state = S_text;
		break;
	    }
	}
	break;

	/*
	 * Tag
	 */
    case S_tag:		/* new tag */
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1179 */
					IsNmChar(c) : IsNmStart(c))) {
	    /*
	     * Add valid ASCII character.  - FM
	     */
	    HTChunkPutc(string, c);
	} else if (c == '!' && !string->size) {		/* <! */
	    /*
	     * Terminate and set up for possible comment, identifier,
	     * declaration, or marked section.  - FM
	     */
	    context->state = S_exclamation;
	    context->lead_exclamation = TRUE;
	    context->doctype_bracket = FALSE;
	    context->first_bracket = FALSE;
	    HTChunkPutc(string, c);
	    break;
	} else if (!string->size &&
		   (TOASCII(unsign_c) <= 160 &&		/* S/390 -- gil -- 1196 */
		    (c != '/' && c != '?' && c != '_' && c != ':'))) {
	    /*
	     * '<' must be followed by an ASCII letter to be a valid start tag. 
	     * Here it isn't, nor do we have a '/' for an end tag, nor one of
	     * some other characters with a special meaning for SGML or which
	     * are likely to be legal Name Start characters in XML or some
	     * other extension.  So recover the '<' and following character as
	     * data.  - FM & KW
	     */
	    context->state = S_text;
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTART(badseq);
#endif
	    PUTC('<');
#ifdef USE_PRETTYSRC
	    if (psrc_view)
		PSRCSTOP(badseq);
#endif
	    goto top1;
	} else {		/* End of tag name */
	    /*
	     * Try to handle tag.  - FM
	     */
	    HTTag *t;

	    if (c == '/') {
		if (string->size == 0) {
		    context->state = S_end;
		    break;
		}
		CTRACE((tfp, "SGML: `<%.*s/' found!\n", string->size, string->data));
	    }
	    HTChunkTerminate(string);

	    t = SGMLFindTag(dtd, string->data);
	    if (t == context->unknown_tag &&
		((c == ':' &&
		  string->size == 4 && 0 == strcasecomp(string->data, "URL")) ||
		 (string->size > 4 && 0 == strncasecomp(string->data, "URL:", 4)))) {
		/*
		 * Treat <URL:  as text rather than a junk tag, so we display
		 * it and the URL (Lynxism 8-).  - FM
		 */
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTART(badseq);
#endif
		PUTC('<');
		PUTS(string->data);	/* recover */
		PUTC(c);
#ifdef USE_PRETTYSRC
		if (psrc_view)
		    PSRCSTOP(badseq);
#endif
		CTRACE((tfp, "SGML: Treating <%s%c as text\n",
			string->data, c));
		string->size = 0;
		context->state = S_text;
		break;
	    }
	    if (c == '/' && t) {
		/*
		 * Element name was ended by '/'.  Remember the tag that ended
		 * thusly, we'll interpret this as either an indication of an
		 * empty element (if '>' follows directly) or do some
		 * SGMLshortref-ish treatment.  - kw
		 */
		context->slashedtag = t;
	    }
	    if (!t) {
		if (c == '?' && string->size <= 1) {
		    CTRACE((tfp, "SGML: Found PI, looking for '>'\n"));
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(abracket);
			PUTS("<?");
			PSRCSTOP(abracket);
		    }
#endif
		    string->size = 0;
		    context->state = S_pi;
		    HTChunkPutc(string, c);
		    break;
		}
		CTRACE((tfp, "SGML: *** Invalid element %s\n",
			string->data));

#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTC('<');
		    PSRCSTOP(abracket);
		    PSRCSTART(badtag);
		    transform_tag(context, string);
		    PUTS(string->data);
		    if (c == '>') {
			PSRCSTOP(badtag);
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    } else {
			PUTC(c);
		    }
		}
#endif
		context->state = (c == '>') ? S_text : S_junk_tag;
		break;
	    } else if (t == context->unknown_tag) {
		CTRACE((tfp, "SGML: *** Unknown element \"%s\"\n",
			string->data));
		/*
		 * Fall through and treat like valid tag for attribute parsing. 
		 * - KW
		 */

	    }
	    context->current_tag = t;

#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC('<');
		PSRCSTOP(abracket);
		if (t != context->unknown_tag)
		    PSRCSTART(tag);
		else
		    PSRCSTART(badtag);
		transform_tag(context, string);
		PUTS(string->data);
		if (t != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
	    }
	    if (!psrc_view)	/*don't waste time */
#endif
	    {
		/*
		 * Clear out attributes.
		 */
		memset((void *) context->present, 0, sizeof(BOOL) *
		         (unsigned) (context->current_tag->number_of_attributes));
	    }

	    string->size = 0;
	    context->current_attribute_number = INVALID;
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		    if (c != '<') {
			PSRCSTART(abracket);
			PUTC(c);
			PSRCSTOP(abracket);
			context->state = (c == '>') ? S_text : S_tagname_slash;
		    } else {
			context->state = S_tag;
		    }
		} else {
		    if (!WHITE(c))
			PUTC(c);
		    context->state = S_tag_gap;
		}
	    } else
#endif
	    if (c == '>' || c == '<' || (c == '/' && context->slashedtag)) {
		if (context->current_tag->name)
		    start_element(context);
		context->state = (c == '>') ? S_text :
		    (c == '<') ? S_tag : S_tagname_slash;
	    } else {
		context->state = S_tag_gap;
	    }
	}
	break;

    case S_exclamation:
	if (context->lead_exclamation && c == '-') {
	    /*
	     * Set up for possible comment.  - FM
	     */
	    context->lead_exclamation = FALSE;
	    context->first_dash = TRUE;
	    HTChunkPutc(string, c);
	    break;
	}
	if (context->lead_exclamation && c == '[') {
	    /*
	     * Set up for possible marked section.  - FM
	     */
	    context->lead_exclamation = FALSE;
	    context->first_bracket = TRUE;
	    context->second_bracket = FALSE;
	    HTChunkPutc(string, c);
	    context->state = S_marked;
	    break;
	}
	if (context->first_dash && c == '-') {
	    /*
	     * Set up to handle comment.  - FM
	     */
	    context->lead_exclamation = FALSE;
	    context->first_dash = FALSE;
	    context->end_comment = FALSE;
	    HTChunkPutc(string, c);
	    context->state = S_comment;
	    break;
	}
	context->lead_exclamation = FALSE;
	context->first_dash = FALSE;
	if (c == '>') {
	    /*
	     * Try to handle identifier.  - FM
	     */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_identifier(context);
	    string->size = 0;
	    context->state = S_text;
	    break;
	}
	if (WHITE(c)) {
	    if (string->size == 8 &&
		!strncasecomp(string->data, "!DOCTYPE", 8)) {
		/*
		 * Set up for DOCTYPE declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->doctype_bracket = FALSE;
		context->state = S_doctype;
		break;
	    }
	    if (string->size == 7 &&
		!strncasecomp(string->data, "!ENTITY", 7)) {
		/*
		 * Set up for ENTITY declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->first_dash = FALSE;
		context->end_comment = TRUE;
		context->state = S_sgmlent;
		break;
	    }
	    if (string->size == 8 &&
		!strncasecomp(string->data, "!ELEMENT", 8)) {
		/*
		 * Set up for ELEMENT declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->first_dash = FALSE;
		context->end_comment = TRUE;
		context->state = S_sgmlele;
		break;
	    }
	    if (string->size == 8 &&
		!strncasecomp(string->data, "!ATTLIST", 8)) {
		/*
		 * Set up for ATTLIST declaration.  - FM
		 */
		HTChunkPutc(string, c);
		context->first_dash = FALSE;
		context->end_comment = TRUE;
		context->state = S_sgmlatt;
		break;
	    }
	}
	HTChunkPutc(string, c);
	break;

    case S_comment:		/* Expecting comment. - FM */
	if (historical_comments) {
	    /*
	     * Any '>' terminates.  - FM
	     */
	    if (c == '>') {
		HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(comm);
		    PUTC('<');
		    PUTS_TR(string->data);
		    PUTC('>');
		    PSRCSTOP(comm);
		} else
#endif
		    handle_comment(context);
		string->size = 0;
		context->end_comment = FALSE;
		context->first_dash = FALSE;
		context->state = S_text;
		break;
	    }
	    goto S_comment_put_c;
	}
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else if (!minimal_comments)
		/*
		 * Validly treat '--' pairs as successive comments (for
		 * minimal, any "--WHITE>" terminates).  - FM
		 */
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    /*
	     * Terminate and handle the comment.  - FM
	     */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(comm);
		PUTC('<');
		PUTS_TR(string->data);
		PUTC('>');
		PSRCSTOP(comm);
	    } else
#endif
		handle_comment(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	if (context->end_comment && !isspace(UCH(c)))
	    context->end_comment = FALSE;

      S_comment_put_c:
	if (context->T.decode_utf8 &&
	    *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (!IS_CJK_TTY &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		saved_char_in >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (UCode_t) (0xf000 | saved_char_in));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_doctype:		/* Expecting DOCTYPE. - FM */
	if (context->doctype_bracket) {
	    HTChunkPutc(string, c);
	    if (c == ']')
		context->doctype_bracket = FALSE;
	    break;
	}
	if (c == '[' && WHITE(string->data[string->size - 1])) {
	    HTChunkPutc(string, c);
	    context->doctype_bracket = TRUE;
	    break;
	}
	if (c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_doctype(context);
	    string->size = 0;
	    context->state = S_text;
	    break;
	}
	HTChunkPutc(string, c);
	break;

    case S_marked:		/* Expecting marked section. - FM */
	if (context->first_bracket && c == '[') {
	    HTChunkPutc(string, c);
	    context->first_bracket = FALSE;
	    context->second_bracket = TRUE;
	    break;
	}
	if (context->second_bracket && c == ']' &&
	    string->data[string->size - 1] == ']') {
	    HTChunkPutc(string, c);
	    context->second_bracket = FALSE;
	    break;
	}
	if (!context->second_bracket && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_marked(context);
	    string->size = 0;
	    context->state = S_text;
	    break;
	}
	HTChunkPutc(string, c);
	break;

    case S_sgmlent:		/* Expecting ENTITY. - FM */
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_sgmlent(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	HTChunkPutc(string, c);
	break;

    case S_sgmlele:		/* Expecting ELEMENT. - FM */
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_sgmlele(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	HTChunkPutc(string, c);
	break;

    case S_sgmlatt:		/* Expecting ATTLIST. - FM */
	if (!context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = TRUE;
	    break;
	}
	if (context->first_dash && c == '-') {
	    HTChunkPutc(string, c);
	    context->first_dash = FALSE;
	    if (!context->end_comment)
		context->end_comment = TRUE;
	    else
		context->end_comment = FALSE;
	    break;
	}
	if (context->end_comment && c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(sgmlspecial);
		PUTC('<');
		PUTS(string->data);
		PUTC('>');
		PSRCSTOP(sgmlspecial);
	    } else
#endif
		handle_sgmlatt(context);
	    string->size = 0;
	    context->end_comment = FALSE;
	    context->first_dash = FALSE;
	    context->state = S_text;
	    break;
	}
	context->first_dash = FALSE;
	HTChunkPutc(string, c);
	break;

    case S_tag_gap:		/* Expecting attribute or '>' */
	if (WHITE(c)) {
	    /* PUTC(c); - no, done as special case */
	    break;		/* Gap between attributes */
	}
	if (c == '>') {		/* End of tag */
#ifdef USE_PRETTYSRC
	    if (!psrc_view)
#endif
		if (context->current_tag->name)
		    start_element(context);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    }
#endif
	    context->state = S_text;
	    break;
	}
	HTChunkPutc(string, c);
	context->state = S_attr;	/* Get attribute */
	break;

	/* accumulating value */
    case S_attr:
	if (WHITE(c) || (c == '>') || (c == '=')) {	/* End of word */
	    if ((c == '>')
		&& (string->size == 1)
		&& (string->data[0] == '/')) {
		if (context->extended_html
		    && ignore_when_empty(context->current_tag)) {
		    discard_empty(context);
		}
	    } else {
		HTChunkTerminate(string);
		handle_attribute_name(context, string->data);
	    }
#ifdef USE_PRETTYSRC
	    if (!psrc_view) {
#endif
		string->size = 0;
		if (c == '>') {	/* End of tag */
		    if (context->current_tag->name)
			start_element(context);
		    context->state = S_text;
		    break;
		}
#ifdef USE_PRETTYSRC
	    } else {
		PUTC(' ');
		if (context->current_attribute_number == INVALID)
		    PSRCSTART(badattr);
		else
		    PSRCSTART(attrib);
		if (attrname_transform != 1) {
		    if (attrname_transform == 0)
			LYLowerCase(string->data);
		    else
			LYUpperCase(string->data);
		}
		PUTS(string->data);
		if (c == '=' || WHITE(c))
		    PUTC(c);
		if (c == '=' || c == '>') {
		    if (context->current_attribute_number == INVALID) {
			PSRCSTOP(badattr);
		    } else {
			PSRCSTOP(attrib);
		    }
		}
		if (c == '>') {
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		    context->state = S_text;
		    break;
		}
		string->size = 0;
	    }
#endif
	    context->state = (c == '=' ? S_equals : S_attr_gap);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_attr_gap:		/* Expecting attribute or '=' or '>' */
	if (WHITE(c)) {
	    PRETTYSRC_PUTC(c);
	    break;		/* Gap after attribute */
	}
	if (c == '>') {		/* End of tag */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		if (context->current_attribute_number == INVALID) {
		    PSRCSTOP(badattr);
		} else {
		    PSRCSTOP(attrib);
		}
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    } else
#endif
	    if (context->current_tag->name)
		start_element(context);
	    context->state = S_text;
	    break;
	} else if (c == '=') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PUTC('=');
		if (context->current_attribute_number == INVALID) {
		    PSRCSTOP(badattr);
		} else {
		    PSRCSTOP(attrib);
		}
	    }
#endif
	    context->state = S_equals;
	    break;
	}
	HTChunkPutc(string, c);
	context->state = S_attr;	/* Get next attribute */
	break;

    case S_equals:		/* After attr = */
	if (WHITE(c)) {
	    PRETTYSRC_PUTC(c);
	    break;		/* Before attribute value */
	}
	if (c == '>') {		/* End of tag */
	    CTRACE((tfp, "SGML: found = but no value\n"));
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    } else
#endif
	    if (context->current_tag->name)
		start_element(context);
	    context->state = S_text;
	    break;

	} else if (c == '\'') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(attrval);
		PUTC(c);
	    }
#endif
	    context->state = S_squoted;
	    break;

	} else if (c == '"') {
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PSRCSTART(attrval);
		PUTC(c);
	    }
#endif
	    context->state = S_dquoted;
	    break;
	}
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    PSRCSTART(attrval);
#endif
	context->state = S_value;
	/*  no break!  fall through to S_value and process current `c`   */

    case S_value:
	if (WHITE(c) || (c == '>')) {	/* End of word */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (!end_if_prettysrc(context, string, 0))
#endif
	    {
#ifdef CJK_EX			/* Quick hack. - JH7AYN */
		if (IS_CJK_TTY) {
		    if (string->data[0] == '$') {
			if (string->data[1] == 'B' || string->data[1] == '@@') {
			    char *jis_buf = 0;

			    HTSprintf0(&jis_buf, "\033%s", string->data);
			    TO_EUC((const unsigned char *) jis_buf,
				   (unsigned char *) string->data);
			    FREE(jis_buf);
			}
		    }
		}
#endif
		handle_attribute_value(context, string->data);
	    }
	    string->size = 0;
	    if (c == '>') {	/* End of tag */
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		} else
#endif
		if (context->current_tag->name)
		    start_element(context);
		context->state = S_text;
		break;
	    } else
		context->state = S_tag_gap;
	} else if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (!IS_CJK_TTY &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		saved_char_in >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (UCode_t) (0xf000 | saved_char_in));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_squoted:		/* Quoted attribute value */
	if (c == '\'') {	/* End of attribute value */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (!end_if_prettysrc(context, string, '\''))
#endif
		handle_attribute_value(context, string->data);
	    string->size = 0;
	    context->state = S_tag_gap;
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1213 */
	    /*
	     * Setting up for possible single quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
	    context->state = S_esc_sq;
	    HTChunkPutc(string, c);
	} else if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (!IS_CJK_TTY &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		saved_char_in >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (UCode_t) (0xf000 | saved_char_in));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_dquoted:		/* Quoted attribute value */
	if (c == '"' ||		/* Valid end of attribute value */
	    (soft_dquotes &&	/*  If emulating old Netscape bug, treat '>' */
	     c == '>')) {	/*  as a co-terminator of dquoted and tag    */
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (!end_if_prettysrc(context, string, (char) c))
#endif
		handle_attribute_value(context, string->data);
	    string->size = 0;
	    context->state = S_tag_gap;
	    if (c == '>')	/* We emulated the Netscape bug, so we go  */
		goto top1;	/* back and treat it as the tag terminator */
	} else if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1230 */
	    /*
	     * Setting up for possible double quotes in CJK escape sequences. 
	     * - Takuya ASADA (asada@@three-a.co.jp)
	     */
	    context->state = S_esc_dq;
	    HTChunkPutc(string, c);
	} else if (context->T.decode_utf8 &&
		   *context->utf_buf) {
	    HTChunkPuts(string, context->utf_buf);
	    context->utf_buf_p = context->utf_buf;
	    *(context->utf_buf_p) = '\0';
	} else if (!IS_CJK_TTY &&
		   (context->T.output_utf8 ||
		    context->T.trans_from_uni)) {
	    if (clong == 0xfffd && saved_char_in &&
		HTPassEightBitRaw &&
		saved_char_in >=
		LYlowest_eightbit[context->outUCLYhndl]) {
		HTChunkPutUtf8Char(string,
				   (UCode_t) (0xf000 | saved_char_in));
	    } else {
		HTChunkPutUtf8Char(string, clong);
	    }
	} else if (saved_char_in && context->T.use_raw_char_in) {
	    HTChunkPutc(string, saved_char_in);
	} else {
	    HTChunkPutc(string, c);
	}
	break;

    case S_end:		/* </ */
	if (TOASCII(unsign_c) < 127 && (string->size ?	/* S/390 -- gil -- 1247 */
					IsNmChar(c) : IsNmStart(c))) {
	    HTChunkPutc(string, c);
	} else {		/* End of end tag name */
	    HTTag *t = 0;

#ifdef USE_PRETTYSRC
	    BOOL psrc_tagname_processed = FALSE;
#endif

	    HTChunkTerminate(string);
	    if (!*string->data) {	/* Empty end tag */
		if (context->element_stack)
		    t = context->element_stack->tag;
	    } else {
		t = SGMLFindTag(dtd, string->data);
	    }
	    if (!t || t == context->unknown_tag) {
		CTRACE((tfp, "Unknown end tag </%s>\n", string->data));
#ifdef USE_PRETTYSRC
		if (psrc_view) {
		    PSRCSTART(abracket);
		    PUTS("</");
		    PSRCSTOP(abracket);
		    PSRCSTART(badtag);
		    transform_tag(context, string);
		    PUTS(string->data);
		    if (c != '>') {
			PUTC(c);
		    } else {
			PSRCSTOP(badtag);
			PSRCSTART(abracket);
			PUTC('>');
			PSRCSTOP(abracket);
		    }
		    psrc_tagname_processed = TRUE;
		}
	    } else if (psrc_view) {
#endif
	    } else {
		BOOL tag_OK = (BOOL) (c == '>' || WHITE(c));
		HTMLElement e = TAGNUM_OF_TAGP(t);
		int branch = 2;	/* it can be 0,1,2 */

		context->current_tag = t;
		if (HAS_ALT_TAGNUM(TAGNUM_OF_TAGP(t)) &&
		    context->element_stack &&
		    ALT_TAGP(t) == context->element_stack->tag)
		    context->element_stack->tag = NORMAL_TAGP(context->element_stack->tag);

		if (tag_OK && Old_DTD) {
		    switch (e) {
		    case HTML_DD:
		    case HTML_DT:
		    case HTML_LI:
		    case HTML_LH:
		    case HTML_TD:
		    case HTML_TH:
		    case HTML_TR:
		    case HTML_THEAD:
		    case HTML_TFOOT:
		    case HTML_TBODY:
		    case HTML_COLGROUP:
			branch = 0;
			break;

		    case HTML_A:
		    case HTML_B:
		    case HTML_BLINK:
		    case HTML_CITE:
		    case HTML_EM:
		    case HTML_FONT:
		    case HTML_FORM:
		    case HTML_I:
		    case HTML_P:
		    case HTML_STRONG:
		    case HTML_TT:
		    case HTML_U:
			branch = 1;
			break;
		    default:
			break;
		    }
		}

		/*
		 * Just handle ALL end tags normally :-) - kw
		 */
		if (!Old_DTD) {
		    end_element(context, context->current_tag);
		} else if (tag_OK && (branch == 0)) {
		    /*
		     * Don't treat these end tags as invalid, nor act on them. 
		     * - FM
		     */
		    CTRACE((tfp, "SGML: `</%s%c' found!  Ignoring it.\n",
			    string->data, c));
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    if (c != '>') {
			context->state = S_junk_tag;
		    } else {
			context->current_tag = NULL;
			context->state = S_text;
		    }
		    break;
		} else if (tag_OK && (branch == 1)) {
		    /*
		     * Handle end tags for container elements declared as
		     * SGML_EMPTY to prevent "expected tag substitution" but
		     * still processed via HTML_end_element() in HTML.c with
		     * checks there to avoid throwing the HTML.c stack out of
		     * whack (Ugh, what a hack!  8-).  - FM
		     */
		    if (context->inSELECT) {
			/*
			 * We are in a SELECT block.  - FM
			 */
			if (strcasecomp(string->data, "FORM")) {
			    /*
			     * It is not at FORM end tag, so ignore it.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
				    string->data));
			} else {
			    /*
			     * End the SELECT block and then handle the FORM
			     * end tag.  - FM
			     */
			    CTRACE((tfp,
				    "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
				    string->data));
			    end_element(context,
					SGMLFindTag(context->dtd, "SELECT"));
			    CTRACE((tfp, "SGML: End </%s>\n", string->data));

#ifdef USE_PRETTYSRC
			    if (!psrc_view)	/* Don't actually call if viewing psrc - kw */
#endif
				(*context->actions->end_element)
				    (context->target,
				     (int) TAGNUM_OF_TAGP(context->current_tag),
				     &context->include);
			}
		    } else if (!strcasecomp(string->data, "P")) {
			/*
			 * Treat a P end tag like a P start tag (Ugh, what a
			 * hack!  8-).  - FM
			 */
			CTRACE((tfp,
				"SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				string->data, c, string->data, c));
			{
			    int i;

			    for (i = 0;
				 i < context->current_tag->number_of_attributes;
				 i++) {
				context->present[i] = NO;
			    }
			}
			if (context->current_tag->name)
			    start_element(context);
		    } else {
			CTRACE((tfp, "SGML: End </%s>\n", string->data));

#ifdef USE_PRETTYSRC
			if (!psrc_view)		/* Don't actually call if viewing psrc - kw */
#endif
			    (*context->actions->end_element)
				(context->target,
				 (int) TAGNUM_OF_TAGP(context->current_tag),
				 &context->include);
		    }
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    if (c != '>') {
			context->state = S_junk_tag;
		    } else {
			context->current_tag = NULL;
			context->state = S_text;
		    }
		    break;
		} else {
		    /*
		     * Handle all other end tags normally.  - FM
		     */
		    end_element(context, context->current_tag);
		}
	    }

#ifdef USE_PRETTYSRC
	    if (psrc_view && !psrc_tagname_processed) {
		PSRCSTART(abracket);
		PUTS("</");
		PSRCSTOP(abracket);
		PSRCSTART(tag);
		if (tagname_transform != 1) {
		    if (tagname_transform == 0)
			LYLowerCase(string->data);
		    else
			LYUpperCase(string->data);
		}
		PUTS(string->data);
		PSRCSTOP(tag);
		if (c != '>') {
		    PSRCSTART(badtag);
		    PUTC(c);
		} else {
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		}
	    }
#endif

	    string->size = 0;
	    context->current_attribute_number = INVALID;
	    if (c != '>') {
		if (!WHITE(c))
		    CTRACE((tfp, "SGML: `</%s%c' found!\n", string->data, c));
		context->state = S_junk_tag;
	    } else {
		context->current_tag = NULL;
		context->state = S_text;
	    }
	}
	break;

    case S_esc:		/* Expecting '$'or '(' following CJK ESC. */
	if (c == '$') {
	    context->state = S_dollar;
	} else if (c == '(') {
	    context->state = S_paren;
	} else {
	    context->state = S_text;
	}
	PUTC(c);
	break;

    case S_dollar:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
	if (c == '@@' || c == 'B' || c == 'A') {
	    context->state = S_nonascii_text;
	} else if (c == '(') {
	    context->state = S_dollar_paren;
	}
	PUTC(c);
	break;

    case S_dollar_paren:	/* Expecting 'C' after CJK "ESC$(". */
	if (c == 'C') {
	    context->state = S_nonascii_text;
	} else {
	    context->state = S_text;
	}
	PUTC(c);
	break;

    case S_paren:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
	if (c == 'B' || c == 'J' || c == 'T') {
	    context->state = S_text;
	} else if (c == 'I') {
	    context->state = S_nonascii_text;
	} else {
	    context->state = S_text;
	}
	PUTC(c);
	break;

    case S_nonascii_text:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1264 */
	    context->state = S_esc;
	}
	PUTC(c);
	if (c < 32)
	    context->state = S_text;
	break;

    case S_esc_sq:		/* Expecting '$'or '(' following CJK ESC. */
	if (c == '$') {
	    context->state = S_dollar_sq;
	} else if (c == '(') {
	    context->state = S_paren_sq;
	} else {
	    context->state = S_squoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_sq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
	if (c == '@@' || c == 'B' || c == 'A') {
	    context->state = S_nonascii_text_sq;
	} else if (c == '(') {
	    context->state = S_dollar_paren_sq;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_paren_sq:	/* Expecting 'C' after CJK "ESC$(". */
	if (c == 'C') {
	    context->state = S_nonascii_text_sq;
	} else {
	    context->state = S_squoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_paren_sq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
	if (c == 'B' || c == 'J' || c == 'T') {
	    context->state = S_squoted;
	} else if (c == 'I') {
	    context->state = S_nonascii_text_sq;
	} else {
	    context->state = S_squoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_nonascii_text_sq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1281 */
	    context->state = S_esc_sq;
	}
	HTChunkPutc(string, c);
	break;

    case S_esc_dq:		/* Expecting '$'or '(' following CJK ESC. */
	if (c == '$') {
	    context->state = S_dollar_dq;
	} else if (c == '(') {
	    context->state = S_paren_dq;
	} else {
	    context->state = S_dquoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_dq:		/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
	if (c == '@@' || c == 'B' || c == 'A') {
	    context->state = S_nonascii_text_dq;
	} else if (c == '(') {
	    context->state = S_dollar_paren_dq;
	}
	HTChunkPutc(string, c);
	break;

    case S_dollar_paren_dq:	/* Expecting 'C' after CJK "ESC$(". */
	if (c == 'C') {
	    context->state = S_nonascii_text_dq;
	} else {
	    context->state = S_dquoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_paren_dq:		/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
	if (c == 'B' || c == 'J' || c == 'T') {
	    context->state = S_dquoted;
	} else if (c == 'I') {
	    context->state = S_nonascii_text_dq;
	} else {
	    context->state = S_dquoted;
	}
	HTChunkPutc(string, c);
	break;

    case S_nonascii_text_dq:	/* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {	/* S/390 -- gil -- 1298 */
	    context->state = S_esc_dq;
	}
	HTChunkPutc(string, c);
	break;

    case S_junk_tag:
    case S_pi:
	if (c == '>') {
	    HTChunkTerminate(string);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		if (context->state == S_junk_tag) {
		    PSRCSTOP(badtag);
		}
		PSRCSTART(abracket);
		PUTC('>');
		PSRCSTOP(abracket);
	    }
#endif
	    if (context->state == S_pi)
		handle_processing_instruction(context);
	    string->size = 0;
	    context->current_tag = NULL;
	    context->state = S_text;
	} else {
	    HTChunkPutc(string, c);
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		PUTC(c);
	    }
#endif
	}

    }				/* switch on context->state */
    CTRACE2(TRACE_SGML, (tfp, "SGML after  %s|%.*s|%c|\n",
			 state_name(context->state),
			 string->size,
			 NonNull(string->data),
			 UCH(c)));

  after_switch:
    /*
     * Check whether an external function has added anything to the include
     * buffer.  If so, move the new stuff to the beginning of active_include. 
     * - kw
     */
    if (context->include != NULL) {
	if (context->include[0] == '\0') {
	    FREE(context->include);
	} else {
	    if (context->active_include &&
		context->active_include[context->include_index] != '\0')
		StrAllocCat(context->include,
			    context->active_include + context->include_index);
	    FREE(context->active_include);
	    context->active_include = context->include;
	    context->include_index = 0;
	    context->include = NULL;
	}
    }

    /*
     * Check whether we've added anything to the recover buffer.  - FM
     */
    if (context->recover != NULL) {
	if (context->recover[context->recover_index] == '\0') {
	    FREE(context->recover);
	    context->recover_index = 0;
	} else {
	    c = UCH(context->recover[context->recover_index]);
	    context->recover_index++;
	    goto top;
	}
    }

    /*
     * Check whether an external function had added anything to the include
     * buffer; it should now be in active_include.  - FM / kw
     */
    if (context->active_include != NULL) {
	if (context->active_include[context->include_index] == '\0') {
	    FREE(context->active_include);
	    context->include_index = 0;
	} else {
	    if (context->current_tag_charset == UTF8_handle ||
		context->T.trans_from_uni) {
		/*
		 * If it looks like we would have fed UTF-8 to the next
		 * processing stage, assume that whatever we were fed back is
		 * in UTF-8 form, too.  This won't be always true for all uses
		 * of the include buffer, but it's a start.  - kw
		 */
		char *puni = context->active_include + context->include_index;

		c = UCH(*puni);
		clong = UCGetUniFromUtf8String(&puni);
		if (clong < 256 && clong >= 0) {
		    c = UCH((clong & 0xff));
		}
		saved_char_in = '\0';
		context->include_index = (int) (puni
						- context->active_include
						+ 1);
		goto top1;
	    } else {
		/*
		 * Otherwise assume no UTF-8 - do charset-naive processing and
		 * hope for the best.  - kw
		 */
		c = UCH(context->active_include[context->include_index]);
		context->include_index++;
		goto top;
	    }
	}
    }

    /*
     * Check whether an external function has added anything to the csi buffer. 
     * - FM
     */
    if (context->csi != NULL) {
	if (context->csi[context->csi_index] == '\0') {
	    FREE(context->csi);
	    context->csi_index = 0;
	} else {
	    c = UCH(context->csi[context->csi_index]);
	    context->csi_index++;
	    goto top;
	}
    }
}				/* SGML_character */

static void InferUtfFromBom(HTStream *context, int chndl)
{
    HTAnchor_setUCInfoStage(context->node_anchor, chndl,
			    UCT_STAGE_PARSER,
			    UCT_SETBY_PARSER);
    change_chartrans_handling(context);
}

/*
 * Avoid rewrite of SGML_character() to handle hypothetical case of UTF-16
 * webpages, by pretending that the data is UTF-8.
 */
static void SGML_widechar(HTStream *context, int ch)
{
    if (!UCPutUtf8_charstring(context, SGML_character, (UCode_t) ch)) {
	SGML_character(context, ch);
    }
}

static void SGML_write(HTStream *context, const char *str, int l)
{
    const char *p;
    const char *e = str + l;

    if (sgml_offset == 0) {
	if (l > 3
	    && !MemCmp(str, "\357\273\277", 3)) {
	    CTRACE((tfp, "SGML_write found UTF-8 BOM\n"));
	    InferUtfFromBom(context, UTF8_handle);
	    str += 3;
	} else if (l > 2) {
	    if (!MemCmp(str, "\377\376", 2)) {
		CTRACE((tfp, "SGML_write found UCS-2 LE BOM\n"));
		InferUtfFromBom(context, UTF8_handle);
		str += 2;
		context->T.ucs_mode = -1;
	    } else if (!MemCmp(str, "\376\377", 2)) {
		CTRACE((tfp, "SGML_write found UCS-2 BE BOM\n"));
		InferUtfFromBom(context, UTF8_handle);
		str += 2;
		context->T.ucs_mode = 1;
	    }
	}
    }
    switch (context->T.ucs_mode) {
    case -1:
	for (p = str; p < e; p += 2)
	    SGML_widechar(context, (UCH(p[1]) << 8) | UCH(p[0]));
	break;
    case 1:
	for (p = str; p < e; p += 2)
	    SGML_widechar(context, (UCH(p[0]) << 8) | UCH(p[1]));
	break;
    default:
	for (p = str; p < e; p++)
	    SGML_character(context, *p);
	break;
    }
}

static void SGML_string(HTStream *context, const char *str)
{
    SGML_write(context, str, (int) strlen(str));
}

/*_______________________________________________________________________
*/

/*	Structured Object Class
 *	-----------------------
 */
const HTStreamClass SGMLParser =
{
    "SGMLParser",
    SGML_free,
    SGML_abort,
    SGML_character,
    SGML_string,
    SGML_write,
};

/*	Create SGML Engine
 *	------------------
 *
 * On entry,
 *	dtd		represents the DTD, along with
 *	actions		is the sink for the data as a set of routines.
 *
 */

HTStream *SGML_new(const SGML_dtd * dtd,
		   HTParentAnchor *anchor,
		   HTStructured * target)
{
    HTStream *context = typecalloc(struct _HTStream);

    if (!context)
	outofmem(__FILE__, "SGML_begin");

    assert(context != NULL);

    context->isa = &SGMLParser;
    context->string = HTChunkCreate(128);	/* Grow by this much */
    context->dtd = dtd;
    context->target = target;
    context->actions = (const HTStructuredClass *) (((HTStream *) target)->isa);
    /* Ugh: no OO */
    context->unknown_tag = &HTTag_unrecognized;
    context->current_tag = context->slashedtag = NULL;
    context->state = S_text;
#ifdef CALLERDATA
    context->callerData = (void *) callerData;
#endif /* CALLERDATA */

    context->node_anchor = anchor;	/* Could be NULL? */
    context->utf_buf_p = context->utf_buf;
    UCTransParams_clear(&context->T);
    context->inUCLYhndl = HTAnchor_getUCLYhndl(anchor,
					       UCT_STAGE_PARSER);
    if (context->inUCLYhndl < 0) {
	HTAnchor_copyUCInfoStage(anchor,
				 UCT_STAGE_PARSER,
				 UCT_STAGE_MIME,
				 -1);
	context->inUCLYhndl = HTAnchor_getUCLYhndl(anchor,
						   UCT_STAGE_PARSER);
    }
#ifdef CAN_SWITCH_DISPLAY_CHARSET	/* Allow a switch to a more suitable display charset */
    else if (anchor->UCStages
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl >= 0
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set) {
	int o = anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl;

	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1;	/* Force reset */
	HTAnchor_resetUCInfoStage(anchor, o, UCT_STAGE_PARSER,
	/* Preserve change this: */
				  anchor->UCStages->s[UCT_STAGE_PARSER].lock);
    }
#endif

    context->inUCI = HTAnchor_getUCInfoStage(anchor,
					     UCT_STAGE_PARSER);
    set_chartrans_handling(context, anchor, -1);

    context->recover = NULL;
    context->recover_index = 0;
    context->include = NULL;
    context->active_include = NULL;
    context->include_index = 0;
    context->url = NULL;
    context->csi = NULL;
    context->csi_index = 0;

#ifdef USE_PRETTYSRC
    if (psrc_view) {
	psrc_view = FALSE;
	mark_htext_as_source = TRUE;
	SGML_string(context,
		    "<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
	psrc_view = TRUE;
	psrc_convert_string = FALSE;
	sgml_in_psrc_was_initialized = TRUE;
    }
#endif

    sgml_offset = 0;
    return context;
}

/*
 * Return the offset within the document where we're parsing.  This is used
 * to help identify anchors which shift around while reparsing.
 */
int SGML_offset(void)
{
    int result = sgml_offset;

#ifdef USE_PRETTYSRC
    result += psrc_view;
#endif
    return result;
}

/*		Asian character conversion functions
 *		====================================
 *
 *	Added 24-Mar-96 by FM, based on:
 *
 ////////////////////////////////////////////////////////////////////////
Copyright (c) 1993 Electrotechnical Laboratory (ETL)

Permission to use, copy, modify, and distribute this material
for any purpose and without fee is hereby granted, provided
that the above copyright notice and this permission notice
appear in all copies, and that the name of ETL not be
used in advertising or publicity pertaining to this
material without the specific, prior written permission
of an authorized representative of ETL.
ETL MAKES NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY
OF THIS MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS",
WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.
/////////////////////////////////////////////////////////////////////////
Content-Type:	program/C; charset=US-ASCII
Program:	SJIS.c
Author:		Yutaka Sato <ysato@@etl.go.jp>
Description:
History:
	930923	extracted from codeconv.c of cosmos
///////////////////////////////////////////////////////////////////////
*/

static int TREAT_SJIS = 1;

void JISx0201TO0208_EUC(unsigned IHI,
			unsigned ILO,
			unsigned char *OHI,
			unsigned char *OLO)
{
    static const char *table[] =
    {
	"\241\243",		/* A1,A3 */
	"\241\326",		/* A1,D6 */
	"\241\327",		/* A1,D7 */
	"\241\242",		/* A1,A2 */
	"\241\246",		/* A1,A6 */
	"\245\362",		/* A5,F2 */
	"\245\241",		/* A5,A1 */
	"\245\243",		/* A5,A3 */
	"\245\245",		/* A5,A5 */
	"\245\247",		/* A5,A7 */
	"\245\251",		/* A5,A9 */
	"\245\343",		/* A5,E3 */
	"\245\345",		/* A5,E5 */
	"\245\347",		/* A5,E7 */
	"\245\303",		/* A5,C3 */
	"\241\274",		/* A1,BC */
	"\245\242",		/* A5,A2 */
	"\245\244",		/* A5,A4 */
	"\245\246",		/* A5,A6 */
	"\245\250",		/* A5,A8 */
	"\245\252",		/* A5,AA */
	"\245\253",		/* A5,AB */
	"\245\255",		/* A5,AD */
	"\245\257",		/* A5,AF */
	"\245\261",		/* A5,B1 */
	"\245\263",		/* A5,B3 */
	"\245\265",		/* A5,B5 */
	"\245\267",		/* A5,B7 */
	"\245\271",		/* A5,B9 */
	"\245\273",		/* A5,BB */
	"\245\275",		/* A5,BD */
	"\245\277",		/* A5,BF */
	"\245\301",		/* A5,C1 */
	"\245\304",		/* A5,C4 */
	"\245\306",		/* A5,C6 */
	"\245\310",		/* A5,C8 */
	"\245\312",		/* A5,CA */
	"\245\313",		/* A5,CB */
	"\245\314",		/* A5,CC */
	"\245\315",		/* A5,CD */
	"\245\316",		/* A5,CE */
	"\245\317",		/* A5,CF */
	"\245\322",		/* A5,D2 */
	"\245\325",		/* A5,D5 */
	"\245\330",		/* A5,D8 */
	"\245\333",		/* A5,DB */
	"\245\336",		/* A5,DE */
	"\245\337",		/* A5,DF */
	"\245\340",		/* A5,E0 */
	"\245\341",		/* A5,E1 */
	"\245\342",		/* A5,E2 */
	"\245\344",		/* A5,E4 */
	"\245\346",		/* A5,E6 */
	"\245\350",		/* A5,E8 */
	"\245\351",		/* A5,E9 */
	"\245\352",		/* A5,EA */
	"\245\353",		/* A5,EB */
	"\245\354",		/* A5,EC */
	"\245\355",		/* A5,ED */
	"\245\357",		/* A5,EF */
	"\245\363",		/* A5,F3 */
	"\241\253",		/* A1,AB */
	"\241\254"		/* A1,AC */
    };

    if ((IHI == 0x8E) && (ILO >= 0xA1) && (ILO <= 0xDF)) {
	*OHI = UCH(table[ILO - 0xA1][0]);
	*OLO = UCH(table[ILO - 0xA1][1]);
    } else {
	*OHI = UCH(IHI);
	*OLO = UCH(ILO);
    }
}

static int IS_SJIS_STR(const unsigned char *str)
{
    const unsigned char *s;
    unsigned char ch;
    int is_sjis = 0;

    s = str;
    while ((ch = *s++) != '\0') {
	if (ch & 0x80)
	    if (IS_SJIS(ch, *s, is_sjis))
		return 1;
    }
    return 0;
}

unsigned char *SJIS_TO_JIS1(unsigned HI,
			    unsigned LO,
			    unsigned char *JCODE)
{
    HI = UCH(HI - (unsigned) UCH((HI <= 0x9F) ? 0x71 : 0xB1));
    HI = UCH((HI << 1) + 1);
    if (0x7F < LO)
	LO--;
    if (0x9E <= LO) {
	LO = UCH(LO - UCH(0x7D));
	HI++;
    } else {
	LO = UCH(LO - UCH(0x1F));
    }
    JCODE[0] = UCH(HI);
    JCODE[1] = UCH(LO);
    return JCODE;
}

unsigned char *JIS_TO_SJIS1(unsigned HI,
			    unsigned LO,
			    unsigned char *SJCODE)
{
    if (HI & 1)
	LO = UCH(LO + UCH(0x1F));
    else
	LO = UCH(LO + UCH(0x7D));
    if (0x7F <= LO)
	LO++;

    HI = UCH(((HI - 0x21) >> 1) + 0x81);
    if (0x9F < HI)
	HI = UCH(HI + UCH(0x40));
    SJCODE[0] = UCH(HI);
    SJCODE[1] = UCH(LO);
    return SJCODE;
}

unsigned char *EUC_TO_SJIS1(unsigned HI,
			    unsigned LO,
			    unsigned char *SJCODE)
{
    if (HI == 0x8E) {
	unsigned char HI_data[2];
	unsigned char LO_data[2];

	HI_data[0] = UCH(HI);
	LO_data[0] = UCH(LO);
	JISx0201TO0208_EUC(HI, LO, HI_data, LO_data);
    }
    JIS_TO_SJIS1(UCH(HI & 0x7F), UCH(LO & 0x7F), SJCODE);
    return SJCODE;
}

void JISx0201TO0208_SJIS(unsigned I,
			 unsigned char *OHI,
			 unsigned char *OLO)
{
    unsigned char SJCODE[2];

    JISx0201TO0208_EUC(0x8E, I, OHI, OLO);
    JIS_TO_SJIS1(UCH(*OHI & 0x7F), UCH(*OLO & 0x7F), SJCODE);
    *OHI = SJCODE[0];
    *OLO = SJCODE[1];
}

unsigned char *SJIS_TO_EUC1(unsigned HI,
			    unsigned LO,
			    unsigned char *data)
{
    SJIS_TO_JIS1(HI, LO, data);
    data[0] |= 0x80;
    data[1] |= 0x80;
    return data;
}

unsigned char *SJIS_TO_EUC(unsigned char *src,
			   unsigned char *dst)
{
    unsigned char hi, lo, *sp, *dp;
    int in_sjis = 0;

    in_sjis = IS_SJIS_STR(src);
    for (sp = src, dp = dst; (hi = sp[0]) != '\0';) {
	lo = sp[1];
	if (TREAT_SJIS && IS_SJIS(hi, lo, in_sjis)) {
	    SJIS_TO_JIS1(hi, lo, dp);
	    dp[0] |= 0x80;
	    dp[1] |= 0x80;
	    dp += 2;
	    sp += 2;
	} else
	    *dp++ = *sp++;
    }
    *dp = 0;
    return dst;
}

unsigned char *EUC_TO_SJIS(unsigned char *src,
			   unsigned char *dst)
{
    unsigned char *sp, *dp;

    for (sp = src, dp = dst; *sp;) {
	if (*sp & 0x80) {
	    if (sp[1] && (sp[1] & 0x80)) {
		JIS_TO_SJIS1(UCH(sp[0] & 0x7F), UCH(sp[1] & 0x7F), dp);
		dp += 2;
		sp += 2;
	    } else {
		sp++;
	    }
	} else {
	    *dp++ = *sp++;
	}
    }
    *dp = 0;
    return dst;
}

#define Strcpy(a,b)	(strcpy((char*)a,(const char*)b),&a[strlen((const char*)a)])

unsigned char *EUC_TO_JIS(unsigned char *src,
			  unsigned char *dst,
			  const char *toK,
			  const char *toA)
{
    unsigned char kana_mode = 0;
    unsigned char cch;
    unsigned char *sp = src;
    unsigned char *dp = dst;
    int is_JIS = 0;

    while ((cch = *sp++) != '\0') {
	if (cch & 0x80) {
	    if (!IS_EUC(cch, *sp)) {
		if (cch == 0xA0 && is_JIS)	/* ignore NBSP */
		    continue;
		is_JIS++;
		*dp++ = cch;
		continue;
	    }
	    if (!kana_mode) {
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toK);
	    }
	    if (*sp & 0x80) {
		*dp++ = UCH(cch & ~0x80);
		*dp++ = UCH(*sp++ & ~0x80);
	    }
	} else {
	    if (kana_mode) {
		kana_mode = UCH(~kana_mode);
		dp = Strcpy(dp, toA);
	    }
	    *dp++ = cch;
	}
    }
    if (kana_mode)
	dp = Strcpy(dp, toA);

    if (dp)
	*dp = 0;
    return dst;
}

#define	IS_JIS7(c1,c2)	(0x20<(c1)&&(c1)<0x7F && 0x20<(c2)&&(c2)<0x7F)
#define SO		('N'-0x40)
#define SI		('O'-0x40)

static int repair_JIS = 0;

static const unsigned char *repairJIStoEUC(const unsigned char *src,
					   unsigned char **dstp)
{
    const unsigned char *s;
    unsigned char *d, ch1, ch2;

    d = *dstp;
    s = src;
    while ((ch1 = s[0]) && (ch2 = s[1])) {
	s += 2;
	if (ch1 == '(')
	    if (ch2 == 'B' || ch2 == 'J') {
		*dstp = d;
		return s;
	    }
	if (!IS_JIS7(ch1, ch2))
	    return 0;

	*d++ = UCH(0x80 | ch1);
	*d++ = UCH(0x80 | ch2);
    }
    return 0;
}

unsigned char *TO_EUC(const unsigned char *jis,
		      unsigned char *euc)
{
    const unsigned char *s;
    unsigned char c, jis_stat;
    unsigned char *d;
    int to1B, to2B;
    int in_sjis = 0;
    static int nje;
    int n8bits;
    int is_JIS;

    nje++;
    n8bits = 0;
    s = jis;
    d = euc;
    jis_stat = 0;
    to2B = TO_2BCODE;
    to1B = TO_1BCODE;
    in_sjis = IS_SJIS_STR(jis);
    is_JIS = 0;

    while ((c = *s++) != '\0') {
	if (c == 0x80)
	    continue;		/* ignore it */
	if (c == 0xA0 && is_JIS)
	    continue;		/* ignore Non-breaking space */

	if (c == to2B && jis_stat == 0 && repair_JIS) {
	    if (*s == 'B' || *s == '@@') {
		const unsigned char *ts;

		if ((ts = repairJIStoEUC(s + 1, &d)) != NULL) {
		    s = ts;
		    continue;
		}
	    }
	}
	if (c == CH_ESC) {
	    if (*s == to2B) {
		if ((s[1] == 'B') || (s[1] == '@@')) {
		    jis_stat = 0x80;
		    s += 2;
		    is_JIS++;
		    continue;
		}
		jis_stat = 0;
	    } else if (*s == to1B) {
		jis_stat = 0;
		if ((s[1] == 'B') || (s[1] == 'J') || (s[1] == 'H')) {
		    s += 2;
		    continue;
		}
	    } else if (*s == ',') {	/* MULE */
		jis_stat = 0;
	    }
	}
	if (c & 0x80)
	    n8bits++;

	if (IS_SJIS(c, *s, in_sjis)) {
	    SJIS_TO_EUC1(c, *s, d);
	    d += 2;
	    s++;
	    is_JIS++;
	} else if (jis_stat) {
	    if (c <= 0x20 || 0x7F <= c) {
		*d++ = c;
		if (c == '\n')
		    jis_stat = 0;
	    } else {
		if (IS_JIS7(c, *s)) {
		    *d++ = jis_stat | c;
		    *d++ = jis_stat | *s++;
		} else
		    *d++ = c;
	    }
	} else {
	    if (n8bits == 0 && (c == SI || c == SO)) {
	    } else {
		*d++ = c;
	    }
	}
    }
    *d = 0;
    return euc;
}

#define non94(ch) ((ch) <= 0x20 || (ch) == 0x7F)

static int is_EUC_JP(unsigned char *euc)
{
    unsigned char *cp;
    int ch1, ch2;

    for (cp = euc; (ch1 = *cp) != '\0'; cp++) {
	if (ch1 & 0x80) {
	    ch2 = cp[1] & 0xFF;
	    if ((ch2 & 0x80) == 0) {
		/* sv1log("NOT_EUC1[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    if (non94(ch1 & 0x7F) || non94(ch2 & 0x7F)) {
		/* sv1log("NOT_EUC2[%x][%x]\n",ch1,ch2); */
		return 0;
	    }
	    cp++;
	}
    }
    return 1;
}

void TO_SJIS(const unsigned char *arg,
	     unsigned char *sjis)
{
    unsigned char *euc;

    euc = typeMallocn(unsigned char, strlen((const char *) arg) + 1);

#ifdef CJK_EX
    if (!euc)
	outofmem(__FILE__, "TO_SJIS");
#endif
    TO_EUC(arg, euc);
    if (is_EUC_JP(euc))
	EUC_TO_SJIS(euc, sjis);
    else
	strcpy((char *) sjis, (const char *) arg);
    free(euc);
}

void TO_JIS(const unsigned char *arg,
	    unsigned char *jis)
{
    unsigned char *euc;

    if (arg[0] == 0) {
	jis[0] = 0;
	return;
    }
    euc = typeMallocn(unsigned char, strlen((const char *)arg) + 1);
#ifdef CJK_EX
    if (!euc)
	outofmem(__FILE__, "TO_JIS");
#endif
    TO_EUC(arg, euc);
    is_EUC_JP(euc);
    EUC_TO_JIS(euc, jis, TO_KANJI, TO_ASCII);

    free(euc);
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: SGML.c,v 1.131 2009/05/30 11:21:28 tom Exp $
d15 2
d44 5
d322 1
a322 1
				 BOOL start)
d338 1
a338 1
						ts->element,
d340 1
a340 1
						(const char **) ts->value,
d345 1
a345 1
					      ts->element,
d538 1
a538 1
	    strncpy(class_string, s, TEMPSTRINGSIZE);
d666 1
a666 1
static void handle_entity(HTStream *context, char term)
d820 1
a820 1
	strncmp(s, "!--#", 4) == 0 &&
d867 1
a867 1
    if (!strncmp(context->string->data, "![INCLUDE[", 10)) {
d874 1
a874 1
    } else if (!strncmp(context->string->data, "![CDATA[", 8)) {
d892 1
a892 1
    if (!strncmp(s, "?xml ", 5)) {
d906 1
a906 1
		flag = !strncmp(t, "utf-8", 5);
d982 1
a982 1
static BOOL element_valid_within(HTTag * new_tag, HTTag * stacked_tag, BOOL direct)
d1042 1
a1042 1
					  e,
d1109 2
a1110 1
		    context->element_stack->tag->name,
d1174 2
a1175 1
						       e, &context->include);
d1179 1
a1179 1
						e,
d1283 3
a1285 3
	    !(valid = element_valid_within(new_tag,
					   context->element_stack->tag,
					   direct_container))) {
d1358 1
a1358 1
						 TAGNUM_OF_TAGP(new_tag),
d1360 1
a1360 1
						 (const char **) context->value,	/* coerce type for think c */
d1370 3
d1466 4
a1469 3
	    (*context->actions->end_element) (context->target,
					      NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
					      &context->include);
d1602 1
a1602 1
static BOOL end_if_prettysrc(HTStream *context, HTChunk *string, char end_ch)
d1631 1
a1631 1
static void SGML_character(HTStream *context, char c_in)
a1640 1
#ifdef CJK_EX
d1642 1
a1642 5

#else
    char c;
#endif
    char saved_char_in = '\0';
d1652 1
a1652 1
    c = c_in;
d1667 1
a1667 1
		*(context->utf_buf_p) = c;
d1677 1
a1677 1
			c = ((char) (clong & 0xff));
d1679 3
d1694 1
a1694 1
		*(context->utf_buf_p) = c;
d1756 1
a1756 1
		    context->utf_buf[0] = c;
d1762 1
a1762 1
		    context->utf_buf[1] = c;
d1770 1
a1770 1
		    context->utf_buf[0] = c;
d1776 1
a1776 1
		    context->utf_buf[1] = c;
d1791 1
a1791 1
	clong = UCTransToUni(c, context->inUCLYhndl);
d1795 1
a1795 1
		c = FROMASCII((char) clong);
d1805 1
a1805 1
	    (((clong = UCTransToUni(c, context->inUCLYhndl)) >= ' ') ||
d1807 1
a1807 1
	      (clong = UCTransToUni(c, context->inUCLYhndl)) > 0))) {
d1810 1
a1810 1
		c = FROMASCII((char) clong);
d1816 1
a1816 1
		uck = UCTransCharStr(replace_buf, 60, c,
d1821 1
a1821 1
		uck = UCTransCharStr(replace_buf, 60, c,
d1830 1
a1830 1
	    c = replace_buf[0];
d1920 2
a1921 3
	if (context->inUCLYhndl == LATIN1
	    || context->inUCLYhndl == US_ASCII) {
	    clong = LYcp1252ToUnicode(c);
d2108 1
a2108 1
			   UCH(saved_char_in) >=
d2110 1
a2110 1
		    PUTUTF8((0xf000 | UCH(saved_char_in)));
a2147 1
	    saved_char_in = '\0';
d2156 3
a2158 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
		    uck, FROMASCII((char) uck)));
d2206 1
a2206 1
	    EntityName = HTMLGetEntityName((int) (unsign_c - 160));
d2248 2
a2249 2
		   (UCH(saved_char_in) >= 0xc0) &&
		   (UCH(saved_char_in) < 255)) {
d2254 1
a2254 1
	    PUTC(((char) (saved_char_in & 0x7f)));
d2637 1
a2637 1
	    unsigned long code;
d2644 2
a2645 2
	    if ((context->isHex ? sscanf(string->data, "%lx", &code) :
		 sscanf(string->data, "%lu", &code)) == 1) {
d2647 3
a2649 1
		code = LYcp1252ToUnicode(code);
d2756 1
a2756 1
			LYstrncpy(replace_buf,
d3100 1
a3100 1
		       context->current_tag->number_of_attributes);
d3314 1
a3314 1
		UCH(saved_char_in) >=
d3317 1
a3317 1
				   (0xf000 | UCH(saved_char_in)));
d3724 1
a3724 1
		UCH(saved_char_in) >=
d3727 1
a3727 1
				   (0xf000 | UCH(saved_char_in)));
d3764 1
a3764 1
		UCH(saved_char_in) >=
d3767 1
a3767 1
				   (0xf000 | UCH(saved_char_in)));
d3784 1
a3784 1
	    if (!end_if_prettysrc(context, string, c))
d3808 1
a3808 1
		UCH(saved_char_in) >=
d3811 1
a3811 1
				   (0xf000 | UCH(saved_char_in)));
d3965 1
a3965 1
				     TAGNUM_OF_TAGP(context->current_tag),
d3995 1
a3995 1
				 TAGNUM_OF_TAGP(context->current_tag),
d4260 1
a4260 1
	    c = context->recover[context->recover_index];
d4285 1
a4285 1
		c = *puni;
d4288 1
a4288 1
		    c = ((char) (clong & 0xff));
d4291 3
a4293 1
		context->include_index = puni - context->active_include + 1;
d4300 1
a4300 1
		c = context->active_include[context->include_index];
d4316 1
a4316 1
	    c = context->csi[context->csi_index];
d4335 1
a4335 1
static void SGML_widechar(HTStream *context, long ch)
d4337 2
a4338 2
    if (!UCPutUtf8_charstring(context, SGML_character, ch)) {
	SGML_character(context, UCH(ch));
d4349 1
a4349 1
	    && !memcmp(str, "\357\273\277", 3)) {
d4354 1
a4354 1
	    if (!memcmp(str, "\377\376", 2)) {
d4359 1
a4359 1
	    } else if (!memcmp(str, "\376\377", 2)) {
d4385 1
a4385 1
    SGML_write(context, str, strlen(str));
d4422 2
d4536 2
a4537 2
void JISx0201TO0208_EUC(unsigned char IHI,
			unsigned char ILO,
d4609 2
a4610 2
	*OHI = table[ILO - 0xA1][0];
	*OLO = table[ILO - 0xA1][1];
d4612 2
a4613 2
	*OHI = IHI;
	*OLO = ILO;
d4632 3
a4634 3
unsigned char *SJIS_TO_JIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *JCODE)
d4636 1
a4636 1
    HI -= UCH((HI <= 0x9F) ? 0x71 : 0xB1);
d4641 1
a4641 1
	LO -= UCH(0x7D);
d4644 1
a4644 1
	LO -= UCH(0x1F);
d4646 2
a4647 2
    JCODE[0] = HI;
    JCODE[1] = LO;
d4651 3
a4653 3
unsigned char *JIS_TO_SJIS1(register unsigned char HI,
			    register unsigned char LO,
			    register unsigned char *SJCODE)
d4656 1
a4656 1
	LO += UCH(0x1F);
d4658 1
a4658 1
	LO += UCH(0x7D);
d4664 3
a4666 3
	HI += UCH(0x40);
    SJCODE[0] = HI;
    SJCODE[1] = LO;
d4670 12
a4681 6
unsigned char *EUC_TO_SJIS1(unsigned char HI,
			    unsigned char LO,
			    register unsigned char *SJCODE)
{
    if (HI == 0x8E)
	JISx0201TO0208_EUC(HI, LO, &HI, &LO);
d4686 3
a4688 3
void JISx0201TO0208_SJIS(register unsigned char I,
			 register unsigned char *OHI,
			 register unsigned char *OLO)
d4698 2
a4699 2
unsigned char *SJIS_TO_EUC1(unsigned char HI,
			    unsigned char LO,
d4711 2
a4712 2
    register unsigned char hi, lo, *sp, *dp;
    register int in_sjis = 0;
d4733 1
a4733 1
    register unsigned char *sp, *dp;
d4759 4
a4762 4
    register unsigned char kana_mode = 0;
    register unsigned char cch;
    register unsigned char *sp = src;
    register unsigned char *dp = dst;
d4831 2
a4832 2
    register const unsigned char *s;
    register unsigned char c, jis_stat;
d4834 2
a4835 2
    register int to1B, to2B;
    register int in_sjis = 0;
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			General SGML Parser code		SGML.c
a16 7
/* Remove the following to disable the experimental HTML DTD parsing.
   Currently only used in this source file. - kw */

#ifndef NO_EXTENDED_HTMLDTD
#define EXTENDED_HTMLDTD
#endif

d83 1
a83 1
#define PUTC(ch)  ((*context->actions->put_character)(context->target, ch))
d87 5
a91 1
#define OPT 1
a144 1
    ,S_junk_pi
d155 1
d181 2
a228 1
    BOOL seen_nonwhite_in_junk_tag;
d262 1
a262 1
    case S_junk_pi:             result = "S_junk_pi";           break;
d313 3
a315 1
static void HTMLSRC_apply_markup(HTStream *context, HTlexeme lexeme, BOOL start)
d351 2
a352 1
static void set_chartrans_handling(HTStream *context, HTParentAnchor *anchor,
d404 1
a404 1
    if (HTCJK != NOCJK) {
d464 1
a464 1
    attr *attributes = tag->attributes;
d518 1
a518 1
	    s, context->current_tag->name));
d792 1
a792 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long) code, uck));	/* S/390 -- gil -- 0695 */
d843 4
a850 3
static void SGML_write(HTStream *me, const char *s,
		       int l);

d876 35
a974 2
#ifdef EXTENDED_HTMLDTD

d977 1
d980 12
a991 10
    if (!stacked_tag || !new_tag)
	return YES;
    usecontains = (direct ? stacked_tag->contains : stacked_tag->icontains);
    usecontained = (direct ? new_tag->contained : new_tag->icontained);
    if (new_tag == stacked_tag)
	return (BOOL) ((Tgc_same & usecontains) &&
		       (Tgc_same & usecontained));
    else
	return (BOOL) ((new_tag->tagclass & usecontains) &&
		       (stacked_tag->tagclass & usecontained));
d1002 16
a1017 9
    if (!stacked_tag)
	return close_NO;
    if (stacked_tag->flags & Tgf_endO)
	return close_valid;
    else if (new_tag == stacked_tag)
	return ((Tgc_same & new_tag->canclose) ? close_error : close_NO);
    else
	return ((stacked_tag->tagclass & new_tag->canclose) ?
		close_error : close_NO);
d1039 4
a1042 2
    context->no_lynx_specialcodes = context->element_stack ?
	(context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
a1056 1
#endif /* EXTENDED_HTMLDTD */
a1062 2
#ifdef EXTENDED_HTMLDTD

a1108 2
#endif /* EXTENDED_HTMLDTD */

d1161 1
a1161 1
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, (int) e));
d1182 4
a1185 2
	context->no_lynx_specialcodes = context->element_stack ?
	    (context->element_stack->tag->flags & Tgf_nolyspcl) : NO;
a1208 2
#ifdef EXTENDED_HTMLDTD

d1219 2
a1220 1
	       !(valid = element_valid_within(new_tag, context->element_stack->tag,
d1243 2
a1244 1
	    !(valid = element_valid_within(new_tag, context->element_stack->tag,
a1283 2
#endif /* EXTENDED_HTMLDTD */

d1364 1
a1364 1
	context->no_lynx_specialcodes = (new_tag->flags & Tgf_nolyspcl);
d1394 6
a1399 2
    if (*res && !strcasecomp((*res)->name, s))
	return *res;
d1539 79
d1842 1
a1842 1
 *  as a flag that the octet in not that of the
d1880 2
a1881 1
 *//* S/390 -- gil -- 0811 */
d1884 1
a1884 1
	HTCJK == NOCJK)
d1893 1
a1893 1
	!(PASSHICTRL || HTCJK != NOCJK))
d1901 13
a1913 1
	!(PASSHICTRL || HTCJK != NOCJK))
d1915 1
d1919 1
a1919 1
     * we have to care them here. -- TH
d1967 1
a1967 1
	 * context->slashedtag as as a flag; except if we get '>' directly
d1977 1
a1977 1
	if ((HTCJK != NOCJK) && ((TOASCII(c) & 0200) != 0)
d1993 1
a1993 1
	} else if (HTCJK != NOCJK && TOASCII(c) == '\033') {	/* S/390 -- gil -- 0881 */
d2046 1
d2091 1
a2091 1
	    } else if (HTCJK == NOCJK &&
d2117 1
a2117 1
		   !(PASS8859SPECL || HTCJK != NOCJK)) {
d2125 1
a2125 1
		   !(PASS8859SPECL || HTCJK != NOCJK)) {
d2189 1
a2189 1
		   !(PASSHI8BIT || HTCJK != NOCJK) &&
d2200 1
a2200 1
	    /* we need to disable it temporary */
d2208 1
a2208 1
	    /* we need to disable it temporary */
a2287 1
		    context->seen_nonwhite_in_junk_tag = TRUE;	/* show all */
d2290 1
a2290 1
		context->state = S_junk_pi;
d2323 2
a2324 1
    case S_litteral:		/*PSRC:this case not understood completely by HV, not done */
d2327 2
a2328 1
	if (psrc_view) {	/*there is nothing useful in the element_stack */
d2332 3
a2334 2
	    testtag = context->element_stack ?
		context->element_stack->tag : NULL;
d2336 1
a2336 1
	if (testtag == NULL) {
d2362 11
d2377 1
d2379 6
a2384 5
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
d2386 1
a2386 1
		    PUTS(string->data);
d2597 1
a2597 2
/* S/390 -- gil -- 1075 *//* CTRACE((tfp, "%s: %d: numeric %d %d\n",
   __FILE__, __LINE__, unsign_c, c)); */
d2599 3
a2601 2
	    (context->isHex ? isxdigit(UCH(c)) :
	     isdigit(UCH(c)))) {
d2627 1
a2627 1
	    UCode_t code;
d2635 1
a2635 1
		 sscanf(string->data, "%ld", &code)) == 1) {
d2637 1
a2637 132
		if ((code == 1) ||
		    (code > 127 && code < 156)) {
		    /*
		     * Assume these are Microsoft code points, inflicted on us
		     * by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159 range
		     * and doesn't follow Unicode standards for this area. 
		     * Windows-1252 codepoints are assumed here.
		     */
		    switch (code) {
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
		    }
		}
d2783 1
a2783 1
			    HTCJK == NOCJK) ||
d2785 1
a2785 1
			    !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
d3018 1
a3018 1
		    CTRACE((tfp, "SGML: Found PI, junking it until '>'\n"));
a3023 1
			context->seen_nonwhite_in_junk_tag = TRUE;	/*show all */
d3026 3
a3028 1
		    context->state = S_junk_pi;
d3040 1
a3040 6
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
d3055 1
a3055 1
		CTRACE((tfp, "SGML: *** Unknown element %s\n",
d3074 1
a3074 6
		if (tagname_transform != 1) {
		    if (tagname_transform == 0)
			LYLowerCase(string->data);
		    else
			LYUpperCase(string->data);
		}
d3297 1
a3297 1
	} else if (HTCJK == NOCJK &&
d3491 2
a3492 1
	if (WHITE(c))
d3494 1
d3518 11
a3528 2
	    HTChunkTerminate(string);
	    handle_attribute_name(context, string->data);
d3553 2
a3554 2
		if (c == '=')
		    PUTC('=');
d3556 1
a3556 1
		    if (context->current_attribute_number == INVALID)
d3558 1
a3558 1
		    else
d3560 1
d3579 2
a3580 1
	if (WHITE(c))
d3582 1
d3619 2
a3620 1
	if (WHITE(c))
d3622 1
d3668 1
a3668 20
	    if (psrc_view) {
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
		    PSRCSTART(href);
		    HTStartAnchor(context->target, NULL, string->data);
		}
		PUTS_TR(string->data);
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		    PSRCSTOP(href);
		}
		PSRCSTOP(attrval);
	    } else
d3670 1
d3672 10
a3681 9
	    {
		char jis_buf[512];

		if (string->data[0] == '$') {
		    if (string->data[1] == 'B' || string->data[1] == '@@') {
			jis_buf[0] = '\033';
			strcpy(jis_buf + 1, string->data);
			TO_EUC((const unsigned char *) jis_buf,
			       (unsigned char *) string->data);
d3684 2
a3686 2
#endif
	    handle_attribute_value(context, string->data);
d3707 1
a3707 1
	} else if (HTCJK == NOCJK &&
d3730 1
a3730 21
	    if (psrc_view) {
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
		    PSRCSTART(href);
		    HTStartAnchor(context->target, NULL, string->data);
		}
		PUTS_TR(string->data);
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		    PSRCSTOP(href);
		}
		PUTC('\'');
		PSRCSTOP(attrval);
	    } else
d3747 1
a3747 1
	} else if (HTCJK == NOCJK &&
d3772 1
a3772 21
	    if (psrc_view) {
		/*PSRCSTART(attrval); */
		if (attr_is_name) {
		    HTStartAnchor(context->target, string->data, NULL);
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		} else if (attr_is_href) {
		    PSRCSTART(href);
		    HTStartAnchor(context->target, NULL, string->data);
		}
		PUTS_TR(string->data);
		if (attr_is_href) {
		    (*context->actions->end_element) (context->target,
						      HTML_A,
						      &context->include);
		    PSRCSTOP(href);
		}
		PUTC(c);
		PSRCSTOP(attrval);
	    } else
a3773 1

d3791 1
a3791 1
	} else if (HTCJK == NOCJK &&
d3836 1
a3836 6
		    if (tagname_transform != 1) {
			if (tagname_transform == 0)
			    LYLowerCase(string->data);
			else
			    LYUpperCase(string->data);
		    }
a3851 2

#if OPT
d3854 1
a3854 1
#endif
d3860 2
a3861 6
#if OPT
		if (tag_OK
#ifdef EXTENDED_HTMLDTD
		    && Old_DTD
#endif
		    ) {
a3894 1
#endif
a3895 1
#ifdef EXTENDED_HTMLDTD
d3901 1
a3901 20
		} else
#endif /* EXTENDED_HTMLDTD */

		    if (tag_OK &&
#if OPT
			(branch == 0)
#else
			(!strcasecomp(string->data, "DD") ||
			 !strcasecomp(string->data, "DT") ||
			 !strcasecomp(string->data, "LI") ||
			 !strcasecomp(string->data, "LH") ||
			 !strcasecomp(string->data, "TD") ||
			 !strcasecomp(string->data, "TH") ||
			 !strcasecomp(string->data, "TR") ||
			 !strcasecomp(string->data, "THEAD") ||
			 !strcasecomp(string->data, "TFOOT") ||
			 !strcasecomp(string->data, "TBODY") ||
			 !strcasecomp(string->data, "COLGROUP"))
#endif
		    ) {
d3917 1
a3917 18
		} else if (tag_OK &&
#if OPT
			   (branch == 1)
#else
			   (!strcasecomp(string->data, "A") ||
			    !strcasecomp(string->data, "B") ||
			    !strcasecomp(string->data, "BLINK") ||
			    !strcasecomp(string->data, "CITE") ||
			    !strcasecomp(string->data, "EM") ||
			    !strcasecomp(string->data, "FONT") ||
			    !strcasecomp(string->data, "FORM") ||
			    !strcasecomp(string->data, "I") ||
			    !strcasecomp(string->data, "P") ||
			    !strcasecomp(string->data, "STRONG") ||
			    !strcasecomp(string->data, "TT") ||
			    !strcasecomp(string->data, "U"))
#endif
		    ) {
d4185 1
a4185 1
    case S_junk_pi:
d4187 1
a4195 1
		context->seen_nonwhite_in_junk_tag = FALSE;
d4198 3
d4203 2
a4204 1
	}
d4206 1
a4206 8
	else if (psrc_view) {
	    /*pack spaces until first non-space is seen */
	    if (!context->seen_nonwhite_in_junk_tag) {
		if (!WHITE(c)) {
		    context->seen_nonwhite_in_junk_tag = TRUE;
		    PUTC(c);
		}
	    } else
d4208 2
a4210 1
#endif
d4309 1
a4309 1
static void SGML_string(HTStream *context, const char *str)
d4311 5
a4315 1
    const char *p;
d4317 9
a4325 2
    for (p = str; *p; p++)
	SGML_character(context, *p);
d4328 1
a4328 2
static void SGML_write(HTStream *context, const char *str,
		       int l)
d4333 39
a4371 2
    for (p = str; p < e; p++)
	SGML_character(context, *p);
d4403 1
a4403 2
    int i;
    HTStream *context = (HTStream *) malloc(sizeof(*context));
a4409 2
    context->leading_spaces = 0;
    context->trailing_spaces = 0;
a4416 4
    context->kanji_buf = '\0';
    context->element_stack = 0;	/* empty */
    context->inSELECT = FALSE;
    context->no_lynx_specialcodes = NO;		/* special codes normally generated */
a4419 10
    for (i = 0; i < MAX_ATTRIBUTES; i++)
	context->value[i] = 0;

    context->lead_exclamation = FALSE;
    context->first_dash = FALSE;
    context->end_comment = FALSE;
    context->doctype_bracket = FALSE;
    context->first_bracket = FALSE;
    context->second_bracket = FALSE;
    context->isHex = FALSE;
a4421 3
    context->utf_count = 0;
    context->utf_char = 0;
    context->utf_buf[0] = context->utf_buf[6] = '\0';
a4468 1
	context->seen_nonwhite_in_junk_tag = FALSE;
d4482 2
d4485 1
a4485 3
    return sgml_offset + psrc_view;
#else
    return sgml_offset;
d4487 1
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 9
a10 9
**			========================
**
**	This module implements an HTStream object.  To parse an
**	SGML file, create this object which is a parser.  The object
**	is (currently) created by being passed a DTD structure,
**	and a target HTStructured object at which to throw the parsed stuff.
**
**	 6 Feb 93  Binary searches used. Interface modified.
*/
d23 2
a24 1
#include <HTCJK.h>
d30 1
d33 1
a33 1
#include <LYCharVals.h>	 /* S/390 -- gil -- 0635 */
d37 1
d48 2
d52 1
a52 2
char* entity_string; /* this is used for printing entity name.
    Unconditionally added since redundant assigments don't hurt much*/
d54 4
a57 3
PRIVATE void fake_put_character ARGS2(
		    void*, p GCC_UNUSED,
		    char,  c GCC_UNUSED)
a72 1
#if ANSI_PREPRO
a85 19
#if 0
#define orig_HTChunkPutc HTChunkPutc
#undef HTChunkPutc

#define HTChunkPutc(ch,x) \
    { \
    if (ch->size < ch->allocated) \
	ch->data[ch->size++] = x; \
    else \
	orig_HTChunkPutc(ch,x); \
    }

#undef HTChunkTerminate

#define HTChunkTerminate(ch) \
    HTChunkPutc(ch, (char)0)
#endif /* */
#endif	/* ANSI_PREPRO */

a92 1

d96 5
a100 5
PUBLIC HTCJKlang HTCJK = NOCJK;		/* CJK enum value.		*/
PUBLIC BOOL HTPassEightBitRaw = FALSE;	/* Pass 161-172,174-255 raw.	*/
PUBLIC BOOL HTPassEightBitNum = FALSE;	/* Pass ^ numeric entities raw. */
PUBLIC BOOL HTPassHighCtrlRaw = FALSE;	/* Pass 127-160,173,&#127; raw. */
PUBLIC BOOL HTPassHighCtrlNum = FALSE;	/* Pass &#128;-&#159; raw.	*/
d103 4
a106 4
**
**	This is passed with each call to make the parser reentrant
**
*/
a109 1

d111 4
a114 4
**		-------------
**	This allows us to return down the stack reselecting styles.
**	As we return, attribute values will be garbage in general.
*/
d117 2
a118 2
	HTElement *	next;	/* Previously nested element or 0 */
	HTTag*		tag;	/* The tag at this level  */
d168 2
a169 2
**	-------------------------------
*/
d172 1
a172 1
    CONST HTStreamClass *	isa;		/* inherited from HTStream */
d174 15
a188 15
    CONST SGML_dtd		*dtd;
    CONST HTStructuredClass	*actions;	/* target class	 */
    HTStructured		*target;	/* target object */

    HTTag			*current_tag;
    HTTag			*slashedtag;
    CONST HTTag			*unknown_tag;
    BOOL			inSELECT;
    BOOL			no_lynx_specialcodes;
    int				current_attribute_number;
    HTChunk			*string;
    int				leading_spaces;
    int				trailing_spaces;
    HTElement			*element_stack;
    sgml_state			state;
d191 2
a192 2
    void *			callerData;
#endif /* CALLERDATA */
d194 1
a194 1
    char * value[MAX_ATTRIBUTES];	/* NULL, or strings alloc'd with StrAllocCopy_extra() */
d196 32
a227 32
    BOOL			lead_exclamation;
    BOOL			first_dash;
    BOOL			end_comment;
    BOOL			doctype_bracket;
    BOOL			first_bracket;
    BOOL			second_bracket;
    BOOL			isHex;

    HTParentAnchor *		node_anchor;
    LYUCcharset *		inUCI;		/* pointer to anchor UCInfo */
    int				inUCLYhndl;	/* charset we are fed	    */
    LYUCcharset *		outUCI;		/* anchor UCInfo for target */
    int				outUCLYhndl;	/* charset for target	    */
    char			utf_count;
    UCode_t			utf_char;
    char			utf_buf[8];
    char *			utf_buf_p;
    UCTransParams		T;
    int				current_tag_charset; /* charset to pass attributes */

    char *			recover;
    int				recover_index;
    char *			include;
    char *			active_include;
    int				include_index;
    char *			url;
    char *			csi;
    int				csi_index;
#ifdef USE_PRETTYSRC
    BOOL			cur_attr_is_href;
    BOOL			cur_attr_is_name;
    BOOL			seen_nonwhite_in_junk_tag;
d231 4
a234 2
#ifndef NO_LYNX_TRACE
PRIVATE char *state_name ARGS1(sgml_state, n)
d236 2
a237 1
    char *result = "?";
d283 2
d294 1
a294 1
PRIVATE HTElement* pool_alloc NOARGS
d298 1
a298 1
	return (HTElement*) malloc(sizeof(HTElement));
d302 1
a302 1
PRIVATE void pool_free ARGS1(HTElement*, e)
d312 1
a312 4
PRIVATE void HTMLSRC_apply_markup ARGS3(
	    HTStream *,	      context,
	    HTlexeme,	      lexeme,
	    BOOL,	      start)
d314 1
a314 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d325 1
a325 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
d327 6
a332 7
	    (*context->actions->start_element)(
		context->target,
		ts->element,
		ts->present,
		(CONST char **)ts->value,
		context->current_tag_charset,
		(char **)&context->include);
d334 3
a336 4
	    (*context->actions->end_element)(
		context->target,
		ts->element,
		(char **)&context->include);
d341 2
a342 7
#if ANSI_PREPRO
#  define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_##x,START)
#  define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_##x,STOP)
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(context,HTL_/**/x,START)
#  define PSRCSTOP(x)   HTMLSRC_apply_markup(context,HTL_/**/x,STOP)
#endif
d348 2
a349 4
PRIVATE void set_chartrans_handling ARGS3(
	HTStream *,		context,
	HTParentAnchor *,	anchor,
	int,			chndl)
d353 3
a355 4
	**  Nothing was set for the parser in earlier stages,
	**  so the HTML parser's UCLYhndl should still be its
	**  default. - FM
	*/
d359 2
a360 2
	    **	That wasn't set either, so seek the HText default. - FM
	    */
d364 3
a366 3
	    **	That wasn't set either, so assume the current display
	    **	character set. - FM
	    */
d369 4
a372 4
	**  Try to set the HText and HTML stages' chartrans info
	**  with the default lock level (will not be changed if
	**  it was set previously with a higher lock level). - FM
	*/
d380 2
a381 2
	**  Get the chartrans info for output to the HTML parser. - FM
	*/
d388 2
a389 2
    **	Set the in->out transformation parameters. - FM
    */
d394 6
a399 7
    **	This is intended for passing the SGML parser's input
    **	charset as an argument in each call to the HTML
    **	parser's start tag function, but it would be better
    **	to call a Lynx_HTML_parser function to set an element
    **	in its HTStructured object, itself, if this were
    **	needed. - FM
    */
d402 3
a404 1
    } else if (context->T.transp) {
d419 1
a419 2
PRIVATE void change_chartrans_handling ARGS1(
	HTStream *,		context)
d423 1
d427 1
a427 1
	 *  Something changed. but ignore if a META wants an unknown charset.
d429 3
a431 2
	LYUCcharset * new_UCI = HTAnchor_getUCInfoStage(context->node_anchor,
							UCT_STAGE_PARSER);
d433 4
a436 6
	    LYUCcharset * next_UCI = HTAnchor_getUCInfoStage(
				    context->node_anchor, UCT_STAGE_STRUCTURED
							    );
	    int next_LYhndl = HTAnchor_getUCLYhndl(
				    context->node_anchor, UCT_STAGE_STRUCTURED
						  );
d453 3
a455 3
**	----------------
*/
/* PUBLIC CONST char * SGML_default = "";   ?? */
d457 1
a457 3
PRIVATE void handle_attribute_name ARGS2(
	HTStream *,	context,
	CONST char *,	s)
d459 2
a460 2
    HTTag * tag = context->current_tag;
    attr * attributes = tag->attributes;
d470 2
a471 2
    **	Ignore unknown tag. - KW
    */
d475 1
a475 1
	    context->current_attribute_number = 1; /* anything !=INVALID */
d481 2
a482 2
    **	Binary search for attribute name.
    */
d485 2
a486 2
	 diff < 0 ? (low = i+1) : (high = i)) {
	i = (low + (high-low)/2);
d488 1
a488 1
	if (diff == 0) {		/* success: found it */
d497 2
a498 2
	    context->present[i] = YES;
	    Clear_extra(context->value[i]);
d501 1
a501 1
	    current_is_class = IS_C(attributes[i]);
d503 1
a503 1
	    current_is_class = (!strcasecomp("class", s));
d505 1
a505 1
	    CTRACE((tfp, "SGML: found attribute %s, %d\n", s, current_is_class));
d509 3
a511 3
	} /* if */

    } /* for */
d514 1
a514 1
		s, context->current_tag->name));
a517 1

d519 3
a521 5
**	----------------------
*/
PRIVATE void handle_attribute_value ARGS2(
	HTStream *,	context,
	CONST char *,	s)
d526 2
a527 3
	if (current_is_class)
	{
	    strncpy (class_string, s, TEMPSTRINGSIZE);
d529 1
a529 3
	}
	else
	{
d536 1
a536 1
    context->current_attribute_number = INVALID; /* can't have two assignments! */
a538 1

d540 10
a549 12
**  Translate some Unicodes to Lynx special codes and output them.
**  Special codes - ones those output depend on parsing.
**
**  Additional issue, like handling bidirectional text if necessary
**  may be called from here:  zwnj (8204), zwj (8205), lrm (8206), rlm (8207)
**  - currently they are ignored in SGML.c and LYCharUtils.c
**  but also in UCdomap.c because they are non printable...
**
*/
PRIVATE BOOL put_special_unicodes ARGS2(
	HTStream *,	context,
	UCode_t,	code)
d554 2
a555 2
	**  We were asked by a "DTD" flag to not generate lynx specials. - kw
	*/
d559 1
a559 1
    if (code == CH_NBSP) {  /* S/390 -- gil -- 0657 */
d561 2
a562 2
	**  Use Lynx special character for nbsp.
	*/
d566 2
a567 2
	PUTC(HT_NON_BREAK_SPACE);
    } else  if (code == CH_SHY) {
d569 2
a570 2
	**  Use Lynx special character for shy.
	*/
d574 1
a574 1
	PUTC(LY_SOFT_HYPHEN);
d577 12
a588 12
	**  Use Lynx special character for ensp or thinsp.
	**
	**  Originally, Lynx use space '32' as word delimiter and omits this
	**  space at end of line if word is wrapped to the next line.  There
	**  are several other spaces in the Unicode repertoire and we should
	**  teach Lynx to understand them, not only as regular characters but
	**  in the context of line wrapping.  Unfortunately, if we use
	**  HT_EN_SPACE we override the chartrans tables for those spaces
	**  with a single '32' for all (but do line wrapping more fancy).
	**
	**  We may treat emsp as one or two ensp (below).
	*/
d592 1
a592 1
	PUTC(HT_EN_SPACE);
d595 2
a596 2
	**  Use Lynx special character for emsp.
	*/
d600 2
a601 2
	/* PUTC(HT_EN_SPACE);  let's stay with a single space :) */
	PUTC(HT_EN_SPACE);
d607 2
a608 2
	**  Return NO if nothing done.
	*/
d612 2
a613 2
    **	We have handled it.
    */
d618 1
a618 1
PRIVATE void put_pretty_entity ARGS2(HTStream *, context, int, term)
d624 1
a624 1
	PUTC((char)term);
d628 1
a628 1
PRIVATE void put_pretty_number ARGS1(HTStream *, context)
d631 1
a631 1
    PUTS( (context->isHex ? "&#x" : "&#") );
d639 15
a653 15
**	-------------
**
** On entry,
**	s	contains the entity name zero terminated
** Bugs:
**	If the entity name is unknown, the terminator is treated as
**	a printable non-special character in all cases, even if it is '<'
** Bug-fix:
**	Modified SGML_character() so we only come here with terminator
**	as '\0' and check a FoundEntity flag. -- Foteos Macrides
**
** Modified more (for use with Lynx character translation code):
*/
PRIVATE char replace_buf [64];	      /* buffer for replacement strings */
PRIVATE BOOL FoundEntity = FALSE;
d655 1
a655 3
PRIVATE void handle_entity ARGS2(
	HTStream *,	context,
	char,		term)
d659 1
a659 1
    CONST char *s = context->string->data;
d662 2
a663 2
    **	Handle all entities normally. - FM
    */
d667 3
a669 3
	**  We got a Unicode value for the entity name.
	**  Check for special Unicodes. - FM
	*/
d680 2
a681 2
	**  Seek a translation from the chartrans tables.
	*/
d692 1
a692 1
	    PUTC(FROMASCII((char)uck));
d698 3
a700 3
		   /*
		   **  Not found; look for replacement string.
		   */
d708 1
a708 1
	    PUTS(replace_buf);
d713 2
a714 2
	**  If we're displaying UTF-8, try that now. - FM
	*/
d721 5
a725 3
	if (context->T.output_utf8 && (psrc_view ?
	      (UCPutUtf8_charstring((HTStream *)context->target,
	      (putc_func_t*)(fake_put_character), code)): PUTUTF8(code) ) ) {
d736 2
a737 2
	**  If it's safe ASCII, use it. - FM
	*/
d745 1
a745 1
	    PUTC(FROMASCII((char)code));
d751 3
a753 4
	**  Ignore zwnj (8204) and zwj (8205), if we get to here.
	**  Note that zwnj may have been handled as <WBR>
	**  by the calling function. - FM
	*/
d766 2
a767 2
	**  Ignore lrm (8206), and rln (8207), if we get to here. - FM
	*/
d782 2
a783 2
    **	If entity string not found, display as text.
    */
d788 1
a788 1
    CTRACE((tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long)code, uck)); /* S/390 -- gil -- 0695 */
a798 1

d800 3
a802 4
**	--------------
*/
PRIVATE void handle_comment ARGS1(
	HTStream *,		context)
d804 1
a804 1
    CONST char *s = context->string->data;
d810 2
a811 2
	LYCheckForCSI(context->node_anchor, (char **)&context->url) == TRUE) {
	LYDoCSI(context->url, s, (char **)&context->csi);
a818 1

d820 3
a822 4
**	-----------------
*/
PRIVATE void handle_identifier ARGS1(
	HTStream *,		context)
d824 1
a824 1
    CONST char *s = context->string->data;
a830 1

d832 3
a834 4
**	--------------
*/
PRIVATE void handle_doctype ARGS1(
	HTStream *,		context)
d836 1
a836 1
    CONST char *s = context->string->data;
d843 2
a844 4
PRIVATE void SGML_write PARAMS((
	HTStream *		me,
	CONST char *		s,
	int			l));
d847 3
a849 4
**	-------------
*/
PRIVATE void handle_marked ARGS1(
	HTStream *,		context)
d851 1
a851 1
    CONST char *s = context->string->data;
d863 3
a865 3
	(*context->actions->_write)(context->target,
		   context->string->data + 8,
		   context->string->size - 11);
a870 1

d872 3
a874 4
**	--------------
*/
PRIVATE void handle_sgmlent ARGS1(
	HTStream *,		context)
d876 1
a876 1
    CONST char *s = context->string->data;
a882 1

d884 3
a886 4
**	--------------
*/
PRIVATE void handle_sgmlele ARGS1(
	HTStream *,		context)
d888 1
a888 1
    CONST char *s = context->string->data;
a894 1

d896 3
a898 4
**	--------------
*/
PRIVATE void handle_sgmlatt ARGS1(
	HTStream *,		context)
d900 1
a900 1
    CONST char *s = context->string->data;
d908 2
a909 3
 *  Convenience macros - tags (elements) are identified sometimes
 *  by an int or enum value ('TAGNUM'), sometimes
 *  by a pointer to HTTag ('TAGP'). - kw
d911 1
a911 1
#define TAGNUM_OF_TAGP(t) (t - context->dtd->tags)
d915 3
a917 3
 *  The following implement special knowledge about OBJECT.
 *  As long as HTML_OBJECT is the only tag for which an alternative
 *  variant exist, they can be simple macros. - kw
d926 1
a926 1
#define NORMAL_TAGNUM(e) ((e >= HTML_ELEMENTS) ? HTML_OBJECT : e)
a934 1

d937 1
a937 4
PRIVATE BOOL element_valid_within ARGS3(
    HTTag *,	new_tag,
    HTTag *,	stacked_tag,
    BOOL,	direct)
d940 1
d947 1
a947 1
		(Tgc_same & usecontained));
d950 1
a950 1
		(stacked_tag->tagclass & usecontained));
d954 1
a954 1
    close_NO	= 0,
d959 1
a959 3
PRIVATE canclose_t can_close ARGS2(
    HTTag *,	new_tag,
    HTTag *,	stacked_tag)
d972 1
a972 2
PRIVATE void do_close_stacked ARGS1(
    HTStream *, context)
d974 1
a974 1
    HTElement * stacked = context->element_stack;
d976 1
d984 1
a984 1
    if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
d986 3
a988 4
    (*context->actions->end_element)(
	context->target,
	e,
	(char **)&context->include);
d995 1
a995 3
PRIVATE int is_on_stack ARGS2(
	HTStream *,	context,
	HTTag *,	old_tag)
d997 1
a997 1
   HTElement * stacked = context->element_stack;
d999 1
d1010 3
a1012 5
**	-----------
*/
PRIVATE void end_element ARGS2(
	HTStream *,	context,
	HTTag *,	old_tag)
d1032 5
a1036 3
			    context->element_stack->tag->name,
			    canclose_check == close_valid ? "supplied," : "***forced by",
			    old_tag->name));
d1045 4
a1048 4
			context->element_stack ?
			context->element_stack->tag->name : "none",
			old_tag->name,
			old_tag->name));
d1052 5
a1056 4
	    CTRACE((tfp, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
			old_tag->name,
			context->element_stack->tag->name,
			old_tag->name));
d1065 2
a1066 3
    **	If we are in a SELECT block, ignore anything
    **	but a SELECT end tag. - FM
    */
d1070 2
a1071 2
	    **	Turn off the inSELECT flag and fall through. - FM
	    */
d1075 2
a1076 2
	    **	Ignore the end tag. - FM
	    */
d1078 1
a1078 1
			old_tag->name));
d1083 2
a1084 2
    **	Handle the end tag. - FM
    */
d1088 1
a1088 1
		    old_tag->name));
d1092 1
a1092 1
    while (context->element_stack) /* Loop is error path only */
d1094 1
a1094 1
    if (context->element_stack) /* Substitute and remove one stack element */
d1099 2
a1100 2
	HTElement * N = context->element_stack;
	HTTag * t = (N->tag != old_tag) ? NORMAL_TAGP(N->tag) : N->tag;
d1102 10
a1111 8
	if (old_tag != t) {		/* Mismatch: syntax error */
	    if (context->element_stack->next) { /* This is not the last level */
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			     old_tag->name, t->name, t->name));
	    } else {			/* last level */
		CTRACE((tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			    old_tag->name, t->name, old_tag->name));
		return;			/* Ignore */
d1116 1
a1116 1
	CTRACE2(TRACE_SGML, (tfp, "tagnum(%p) = %d\n", t, e));
d1118 1
a1118 1
	if (!psrc_view) /* Don't actually pass call on if viewing psrc - kw */
d1120 2
a1121 2
	    status = (*context->actions->end_element)(context->target,
						e, (char **)&context->include);
d1124 6
a1129 7
	    (*context->actions->start_element)(
		context->target,
		e,
		NULL,
		NULL,
		context->current_tag_charset,
		(char **)&context->include);
d1134 1
a1134 1
	    context->element_stack = N->next;		/* Remove from stack */
d1141 1
a1141 1
	    return;  /* Correct sequence */
d1150 1
a1150 1
		old_tag->name));
a1152 1

d1155 1
a1155 2
PRIVATE void start_element ARGS1(
	HTStream *,	context)
d1158 1
a1158 1
    HTTag * new_tag = context->current_tag;
d1179 5
a1183 3
			    context->element_stack->tag->name,
			    canclose_check == close_valid ? "supplied," : "***forced by",
			    new_tag->name));
d1186 1
a1186 1
		if (canclose_check  == close_error)
d1189 4
a1192 3
		CTRACE((tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
			    context->element_stack->tag->name,
			    new_tag->name));
d1200 2
a1201 2
			context->element_stack->tag->name,
			new_tag->name));
d1205 4
a1208 2
	if (context->element_stack && !extra_action_taken &&
	    canclose_check == close_NO && !valid && (new_tag->flags & Tgf_mafse)) {
d1211 2
a1212 1
	    for (; i< new_tag->number_of_attributes && !has_attributes; i++)
d1215 5
a1219 4
		CTRACE((tfp, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
			    context->element_stack->tag->name,
			    new_tag->name,
			    new_tag->name));
d1226 4
a1229 5
	    canclose_check == close_error && !(valid =
					       element_valid_within(
						   new_tag,
						   context->element_stack->tag,
						   direct_container))) {
d1231 2
a1232 2
			context->element_stack->tag->name,
			new_tag->name));
d1240 5
a1244 6
    **	If we are not in a SELECT block, check if this is
    **	a SELECT start tag.  Otherwise (i.e., we are in a
    **	SELECT block) accept only OPTION as valid, terminate
    **	the SELECT block if it is any other form-related
    **	element, and otherwise ignore it. - FM
    */
d1247 3
a1249 3
	**  We are not in a SELECT block, so check if this starts one. - FM
	**  (frequent case!)
	*/
d1253 2
a1254 2
	    **	Set the inSELECT flag and fall through. - FM
	    */
d1259 2
a1260 2
	**  We are in a SELECT block. - FM
	*/
d1263 2
a1264 2
	    **	Ugh, it is not an OPTION. - FM
	    */
d1266 12
a1277 7
		case HTML_INPUT:  case HTML_TEXTAREA: case HTML_SELECT:
		case HTML_BUTTON: case HTML_FIELDSET: case HTML_LABEL:
		case HTML_LEGEND: case HTML_FORM:
		    ok = TRUE;
		    break;
		default:
		    break;
d1279 1
a1279 2
	    if (ok)
	    {
d1281 6
a1286 5
		**  It is another form-related start tag, so terminate
		**  the current SELECT block and fall through. - FM
		*/
		CTRACE((tfp, "SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			    new_tag->name));
d1290 5
a1294 4
		**  Ignore the start tag. - FM
		*/
		CTRACE((tfp, "SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			    new_tag->name));
d1300 2
a1301 2
    **	Handle the start tag. - FM
    */
d1303 6
a1308 7
    status = (*context->actions->start_element)(
	context->target,
	TAGNUM_OF_TAGP(new_tag),
	context->present,
	(CONST char**) context->value,	/* coerce type for think c */
	context->current_tag_charset,
	(char **)&context->include);
d1311 3
a1313 2
    if (new_tag->contents != SGML_EMPTY) {		/* i.e., tag not empty */
	HTElement * N = pool_alloc();
d1321 1
a1321 1
    } else if (e == HTML_META ) {
d1323 2
a1324 2
	**  Check for result of META tag. - KW & FM
	*/
a1328 1

d1330 13
a1342 14
**		------------------------
**
** On entry,
**	dtd	points to dtd structure including valid tag list
**	string	points to name of tag in question
**
** On exit,
**	returns:
**		NULL		tag not found
**		else		address of tag structure in dtd
*/
PUBLIC HTTag * SGMLFindTag ARGS2(
	CONST SGML_dtd*,	dtd,
	CONST char *,		s)
d1345 3
a1347 2
    static HTTag* last[64] = {NULL};  /*optimize using the previous results*/
    HTTag** res = last + (UCH(*s) % 64);     /*pointer arithmetic*/
d1352 4
a1355 4
    for (low = 0, high=dtd->number_of_tags;
	  high > low;
	  diff < 0 ? (low = i+1) : (high = i)) {	/* Binary search */
	i = (low + (high-low)/2);
d1358 1
a1358 1
	if (diff == 0) {		/* success: found it */
d1365 2
a1366 2
	**  Unrecognized, but may be valid. - KW
	*/
d1373 2
a1374 3
**			Public Methods
*/

d1379 1
a1379 2
PRIVATE void SGML_free ARGS1(
	HTStream *,	context)
d1382 2
a1383 2
    HTElement * cur;
    HTTag * t;
d1386 2
a1387 2
    **	Free the buffers. - FM
    */
d1395 2
a1396 2
    **	Wind down stack if any elements are open. - FM
    */
d1403 1
a1403 1
	if (!psrc_view) /* Don't actually call on target if viewing psrc - kw */
d1405 3
a1407 3
	    (*context->actions->end_element)(context->target,
		    NORMAL_TAGNUM(TAGNUM_OF_TAGP(t)),
		    (char **)&context->include);
d1412 3
a1414 3
    **	Finish off the target. - FM
    */
    (*context->actions->_free)(context->target);
d1417 2
a1418 2
    **	Free the strings and context structure. - FM
    */
d1429 1
a1429 3
PRIVATE void SGML_abort ARGS2(
	HTStream *,	context,
	HTError,	e)
d1432 1
a1432 1
    HTElement * cur;
d1435 3
a1437 3
    **	Abort the target. - FM
    */
    (*context->actions->_abort)(context->target, e);
d1440 2
a1441 2
    **	Free the buffers. - FM
    */
d1449 2
a1450 2
    **	Free stack memory if any elements were left open. - KW
    */
d1458 2
a1459 2
    **	Free the strings and context structure. - FM
    */
a1469 1

d1471 6
a1476 6
**	-----------------------------------
**
**   The callbacks from the SGML parser have an SGML context parameter.
**   These calls allow the caller to associate his own context with a
**   particular SGML context.
*/
d1479 1
a1479 2
PUBLIC void* SGML_callerData ARGS1(
	HTStream *,	context)
d1484 1
a1484 3
PUBLIC void SGML_setCallerData ARGS2(
	HTStream *,	context,
	void*,		data)
d1490 8
a1497 10
PRIVATE void SGML_character ARGS2(
	HTStream *,	context,
	char,		c_in)
{
    CONST SGML_dtd *dtd =	context->dtd;
    HTChunk	*string =	context->string;
    CONST char * EntityName;
    HTTag * testtag = NULL;
    BOOLEAN chk;	/* Helps (?) walk through all the else ifs... */
    UCode_t clong, uck = 0; /* Enough bits for UCS4 ... */
d1499 1
d1502 1
d1508 2
d1511 3
a1513 4
    **	Now some fun with the preprocessor.
    **	Use copies for c and unsign_c == clong, so that
    **	we can revert back to the unchanged c_in. - KW
    */
d1517 1
a1517 1
    clong = UCH(c);	/* a.k.a. unsign_c */
d1521 4
a1524 5
	**  Combine UTF-8 into Unicode.
	**  Incomplete characters silently ignored.
	**  From Linux kernel's console.c. - KW
	*/
	if (TOASCII(UCH(c)) > 127) { /* S/390 -- gil -- 0710 */
d1526 2
a1527 2
	    **	We have an octet from a multibyte character. - FM
	    */
d1535 3
a1537 4
		    **	We have all of the bytes, so terminate
		    **	the buffer and set 'clong' to the UCode_t
		    **	value. - FM
		    */
d1541 1
a1541 1
			c = ((char)(clong & 0xff));
d1546 2
a1547 2
		    **	Wait for more. - KW
		    */
d1552 2
a1553 2
		**  Start handling a new multibyte character. - FM
		*/
d1574 2
a1575 2
		    **	Garbage. - KW
		    */
d1581 2
a1582 2
		**  Wait for more. - KW
		*/
d1587 2
a1588 2
	    **	Got an ASCII char. - KW
	    */
d1592 1
a1592 1
		    /*	goto top;  */
d1594 2
a1595 2
    } /* end of context->T.decode_utf8	S/390 -- gil -- 0726 */

d1598 4
a1601 5
    **	If we have a koi8-r input and do not have
    **	koi8-r as the output, save the raw input
    **	in saved_char_in before we potentially
    **	convert it to Unicode. - FM
    */
d1607 2
a1608 3
    **	If we want the raw input converted
    **	to Unicode, try that now. - FM
    */
d1610 39
a1648 3
	((TOASCII(unsign_c) >= LYlowest_eightbit[context->inUCLYhndl]) ||  /* S/390 -- gil -- 0744 */
	 (unsign_c < ' ' && unsign_c != 0 &&
	  context->T.trans_C0_to_uni))) {
d1650 2
a1651 2
	**  Convert the octet to Unicode. - FM
	*/
d1656 1
a1656 1
		c = FROMASCII((char)clong);
d1660 1
a1660 1
    } else if (unsign_c < ' ' && unsign_c != 0 &&  /* S/390 -- gil -- 0768 */
d1663 2
a1664 2
	**  This else if may be too ugly to keep. - KW
	*/
d1671 1
a1671 1
		c = FROMASCII((char)clong);
d1700 2
a1701 2
	} /*  Next line end of ugly stuff for C0. - KW */
    } else {  /* end of context->T.trans_to_uni	 S/390 -- gil -- 0791 */
d1706 4
a1709 4
    **	At this point we have either unsign_c a.k.a. clong in
    **	Unicode (and c in latin1 if clong is in the latin1 range),
    **	or unsign_c and c will have to be passed raw. - KW
    */
d1711 14
a1724 14
**  We jump up to here from below if we have
**  stuff in the recover, insert, or csi buffers
**  to process.	 We zero saved_char_in, in effect
**  as a flag that the octet in not that of the
**  actual call to this function.  This may be OK
**  for now, for the stuff this function adds to
**  its recover buffer, but it might not be for
**  stuff other functions added to the insert or
**  csi buffer, so bear that in mind. - FM
**  Stuff from the recover buffer is now handled
**  as UTF-8 if we can expect that's what it is,
**  and in that case we don't come back up here. - kw
*/
top:
d1727 7
a1733 7
**  We jump to here from above when we don't have
**  UTF-8 input, haven't converted to Unicode, and
**  want clong set to the input octet (unsigned)
**  without zeroing its saved_char_in copy (which
**  is signed). - FM
*/
top0a:
d1737 10
a1746 10
**  We jump to here from above if we have converted
**  the input, or a multibyte sequence across calls,
**  to a Unicode value and loaded it into clong (to
**  which unsign_c has been defined), and from below
**  when we are recycling a character (e.g., because
**  it terminated an entity but is not the standard
**  semi-colon).  The character will already have
**  been put through the Unicode conversions. - FM
*/
top1:
d1748 2
a1749 3
    **	Ignore low ISO 646 7-bit control characters
    **	if HTCJK is not set. - FM
    */
d1751 2
a1752 2
    ** Works for both ASCII and EBCDIC. -- gil
    */	/* S/390 -- gil -- 0811 */
d1759 2
a1760 3
    **	Ignore 127 if we don't have HTPassHighCtrlRaw
    **	or HTCJK set. - FM
    */
d1763 1
a1763 1
    if (TOASCII(c) == 127 &&  /* S/390 -- gil -- 0830 */
d1768 4
a1771 4
    **	Ignore 8-bit control characters 128 - 159 if
    **	neither HTPassHighCtrlRaw nor HTCJK is set. - FM
    */
    if (TOASCII(unsign_c) > 127 && TOASCII(unsign_c) < 160 &&  /* S/390 -- gil -- 0847 */
d1779 6
a1784 2
    if ((HTCJK==JAPANESE) && (context->state==S_in_kanji) &&
	!IS_JAPANESE_2BYTE(context->kanji_buf, UCH(c))) {
d1788 1
d1792 1
a1792 2
	}
	else
d1799 2
a1800 2
    **	Handle character based on context->state.
    */
d1802 5
a1806 5
	    state_name(context->state),
	    string->size,
	    NonNull(string->data),
	    UCH(c)));
    switch(context->state) {
d1810 7
a1816 9
	**  Note that if we don't have a CJK input, then this
	**  is not the second byte of a CJK di-byte, and we're
	**  trashing the input.	 That's why 8-bit characters
	**  followed by, for example, '<' can cause the tag to
	**  be treated as text, not markup.  We could try to deal
	**  with it by holding each first byte and then checking
	**  byte pairs, but that doesn't seem worth the overhead
	**  (see below). - FM
	*/
d1824 5
a1828 5
	 *  We had something link "<name/" so far, set state to S_text
	 *  but keep context->slashedtag as as a flag; except if we get
	 *  '>' directly after the "<name/", and really have a tag for
	 *  that name in context->slashedtag, in which case keep state as
	 *  is and let code below deal with it. - kw
d1832 2
a1833 2
	} /* fall through in any case! */

d1835 13
a1847 11
	if (HTCJK != NOCJK && (TOASCII(c) & 0200) != 0) {  /* S/390 -- gil -- 0864 */
	    /*
	    **	Setting up for Kanji multibyte handling (based on
	    **	Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx).
	    **	Note that if the input is not in fact CJK, the
	    **	next byte also will be mishandled, as explained
	    **	above.	Toggle raw mode off in such cases, or
	    **	select the "7 bit approximations" display
	    **	character set, which is largely equivalent
	    **	to having raw mode off with CJK. - FM
	    */
d1851 1
a1851 1
	} else if (HTCJK != NOCJK && TOASCII(c) == '\033') {  /* S/390 -- gil -- 0881 */
d1853 3
a1855 3
	    **	Setting up for CJK escape sequence handling (based on
	    **	Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). - FM
	    */
d1863 1
a1863 1
	    if (psrc_view) { /*there is nothing useful in the element_stack*/
d1869 1
a1869 1
		     context->element_stack->tag : NULL;
d1873 1
a1873 1
	if (c == '&' && TOASCII(unsign_c) < 127	 &&  /* S/390 -- gil -- 0898 */
d1883 2
a1884 2
	    **	Setting up for possible entity, without the leading '&'. - FM
	    */
d1887 1
a1887 1
	} else if (c == '<' && TOASCII(unsign_c) < 127) {  /* S/390 -- gil -- 0915 */
d1889 2
a1890 2
	    **	Setting up for possible tag. - FM
	    */
d1895 1
a1895 1
				|| testtag->contents == SGML_CDATA)) {
d1908 5
a1912 5
	    **	We got either the second slash of a pending "<NAME/blah blah/"
	    **  shortref construct, or the '>' of a mere "<NAME/>".  In both
	    **  cases generate a "</NAME>" end tag in the recover buffer for
	    **  reparsing unless NAME is really an empty element. - kw
	    */
d1920 2
a1921 2
	    if (context->slashedtag != context->unknown_tag &&
		!ReallyEmptyTag(context->slashedtag)) {
d1936 6
a1941 6
	     *  The element stack says we are within the contents of an
	     *  element that the next stage (HTML.c) may want to feed
	     *  us back again (via the *include string).  So try to output
	     *  text in UTF-8 if possible, using the same logic as for
	     *  attribute values (which should be in line with what
	     *  context->current_tag_charset indicates). - kw
d1954 3
a1956 3
		    HTPassEightBitRaw &&
		    UCH(saved_char_in) >=
		    LYlowest_eightbit[context->outUCLYhndl]) {
d1968 5
a1972 5
	/*
	**  Convert 160 (nbsp) to Lynx special character if
	**  neither HTPassHighCtrlRaw nor HTCJK is set. - FM
	*/
	} else if (unsign_c == CH_NBSP &&  /* S/390 -- gil -- 0932 */
d1976 5
a1980 5
	/*
	**  Convert 173 (shy) to Lynx special character if
	**  neither HTPassHighCtrlRaw nor HTCJK is set. - FM
	*/
	} else if (unsign_c == CH_SHY &&  /* S/390 -- gil -- 0949 */
d1984 5
a1988 5
	/*
	**  Handle the case in which we think we have a character
	**  which doesn't need further processing (e.g., a koi8-r
	**  input for a koi8-r output). - FM
	*/
d1991 3
a1993 3
	    **	Only if the original character is still in saved_char_in,
	    **	otherwise we may be iterating from a goto top. - KW
	    */
d1997 1
a1997 1
 *   I. LATIN-1 OR UCS2	 TO  DISPLAY CHARSET
d1999 2
a2000 1
	} else if ((chk = (BOOL) (context->T.trans_from_uni && TOASCII(unsign_c) >= 160)) &&  /* S/390 -- gil -- 0968 */
d2005 1
a2005 1
			uck, FROMASCII((char)uck)));
d2007 3
a2009 3
	    **	We got one octet from the conversions, so use it. - FM
	    */
	    PUTC(FROMASCII((char)uck));
d2011 6
a2016 6
		   (uck == -4 ||
		    (context->T.repl_translated_C0 &&
		     uck > 0 && uck < 32))) &&
		   /*
		   **  Not found; look for replacement string. - KW
		   */
d2021 4
a2024 4
	    **	Got a replacement string.
	    **	No further tests for validity - assume that whoever
	    **	defined replacement strings knew what she was doing. - KW
	    */
d2026 3
a2028 3
	/*
	**  If we're displaying UTF-8, try that now. - FM
	*/
d2030 7
a2036 7
	    ; /* do nothing more */
	/*
	**  If it's any other (> 160) 8-bit character, and
	**  we have not set HTPassEightBitRaw nor HTCJK, nor
	**  have the "ISO Latin 1" character set selected,
	**  back translate for our character set. - FM
	*/
d2053 1
a2053 1
	    EntityName = HTMLGetEntityName((int)(unsign_c - 160));
d2057 1
a2057 1
	    /* we need to disable it temporary*/
d2059 2
a2060 1
		psrc_view_backup =1; psrc_view =0;
d2065 1
a2065 1
	    /* we need to disable it temporary*/
d2073 5
a2077 5
	/*
	**  If we get to here and have an ASCII char,
	**  pass the character. - KW
	*/
	} else if (TOASCII(unsign_c) < 127 && unsign_c > 0) {  /* S/390 -- gil -- 0987 */
d2079 7
a2085 7
	/*
	**  If we get to here, and should have translated,
	**  translation has failed so far. - KW
	**
	**  We should have sent UTF-8 output to the parser
	**  already, but what the heck, try again. - FM
	*/
d2091 3
a2093 3
	/*
	**  Check for a strippable koi8-r 8-bit character. - FM
	*/
d2098 4
a2101 4
	    **	KOI8 special: strip high bit, gives (somewhat) readable
	    **	ASCII or KOI7 - it was constructed that way! - KW
	    */
	    PUTC(((char)(saved_char_in & 0x7f)));
d2104 6
a2109 6
	/*
	**  If we don't actually want the character,
	**  make it safe and output that now. - FM
	*/
	} else if (TOASCII(UCH(c)) <	 /* S/390 -- gil -- 0997 */
			LYlowest_eightbit[context->outUCLYhndl] ||
d2111 3
a2113 3
	/*
	**  If we get to here, pass the character. - FM
	*/
d2119 5
a2123 5
    /*
    **	Found '<' in SGML_PCDATA content; treat this mode nearly like
    **  S_litteral, but recognize '<!' and '<?' to filter out comments
    **  and processing instructions. - kw
    */
d2125 2
a2126 2
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
d2128 3
a2130 4
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
d2137 1
a2137 1
	    } else if (c == '?') { /* <? - ignore as a PI until '>' - kw */
d2145 1
a2145 1
		    context->seen_nonwhite_in_junk_tag = TRUE; /* show all */
d2154 5
a2158 5
    /*
    **  Found '<' in SGML_SCRIPT content; treat this mode nearly like
    **  S_litteral, but recognize '<!' to allow the content to be treated
    **  as a comment by lynx.
    */
d2160 2
a2161 2
	if (!string->size && TOASCII(unsign_c) < 127) { /* first after '<' */
	    if (c == '!') { /* <! */
d2163 3
a2165 4
		**	Terminate and set up for possible comment,
		**	identifier, declaration, or marked section
		**  as under S_tag. - kw
		*/
d2176 6
a2181 6
    /*
    **	In litteral mode, waits only for specific end tag (for
    **	compatibility with old servers, and for Lynx). - FM
    */
    case_S_litteral:
    case S_litteral: /*PSRC:this case not understood completely by HV, not done*/
d2184 1
a2184 1
	if (psrc_view) { /*there is nothing useful in the element_stack*/
d2199 2
a2200 2
	 *	testtag contains something like "TITLE"
	 *	string contains something like "/title>"
d2206 2
a2207 2
			    ? '/'
			    : testtag->name[testlast])) {
d2211 2
a2212 2
	    **	If complete match, end litteral.
	    */
d2221 1
a2221 1
		    strcpy(string->data,context->current_tag->name);
d2271 1
a2271 1
		  (testtag->flags & (Tgf_strict|Tgf_endO)))) &&
d2276 2
a2277 2
		for (i = 0; i < string->size; i++)  /* remove '/' */
		    string->data[i] = string->data[i+1];
d2284 1
a2284 1
		(testtag->flags & (Tgf_strict|Tgf_endO)) &&
d2290 2
a2291 2
	    **	If Mismatch: recover string literally.
	    */
d2293 2
a2294 2
	    for (i = 0; i < string->size-1; i++)  /* recover, except last c */
	       PUTC(string->data[i]);
d2301 3
a2303 3
    /*
    **	Character reference (numeric entity) or named entity.
    */
d2307 3
a2309 3
	    **	Setting up for possible numeric entity.
	    */
	    context->state = S_cro;  /* &# is Char Ref Open */
d2312 1
a2312 1
	context->state = S_entity;   /* Fall through! */
d2314 3
a2316 3
    /*
    **	Handle possible named entity.
    */
d2319 1
a2319 1
		  isalnum(UCH(c)) : isalpha(UCH(c)))) {
d2324 2
a2325 2
	    **	Accept valid ASCII character. - FM
	    */
d2329 3
a2331 3
	    **	It was an ampersand that's just text, so output
	    **	the ampersand and recycle this character. - FM
	    */
d2345 2
a2346 2
	    **	Terminate entity name and try to handle it. - FM
	    */
d2355 1
a2355 1
		 (context->element_stack->tag  &&
d2358 2
a2359 2
		**  Handle zwnj (8204) as <WBR>. - FM
		*/
d2362 2
a2363 1
		CTRACE((tfp, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n"));
d2385 4
a2388 5
	    **	Don't eat the terminator if we didn't find the
	    **	entity name and therefore sent the raw string
	    **	via handle_entity(), or if the terminator is
	    **	not the "standard" semi-colon for HTML. - FM
	    */
d2401 3
a2403 3
    /*
    **	Check for a numeric entity.
    */
d2405 1
a2405 1
	if (TOASCII(unsign_c) < 127 && TOLOWER(UCH(c)) == 'x') {  /* S/390 -- gil -- 1060 */
d2410 2
a2411 2
	    **	Accept only valid ASCII digits. - FM
	    */
d2417 3
a2419 3
	    **	No 'x' or digit following the "&#" so recover
	    **	them and recycle the character. - FM
	    */
d2435 3
a2437 3
    /*
    **	Handle a numeric entity.
    */
d2439 2
a2440 2
	/* S/390 -- gil -- 1075 */ /* CTRACE((tfp, "%s: %d: numeric %d %d\n",
			    __FILE__, __LINE__, unsign_c, c)); */
d2443 1
a2443 1
			      isdigit(UCH(c)))) {
d2445 2
a2446 2
	    **	Accept only valid hex or ASCII digits. - FM
	    */
d2450 3
a2452 3
	    **	No hex digit following the "&#x" so recover
	    **	them and recycle the character. - FM
	    */
d2467 2
a2468 2
	    **	Terminate the numeric entity and try to handle it. - FM
	    */
d2471 1
d2477 1
a2477 1
				  sscanf(string->data, "%ld", &code)) == 1) {
d2482 7
a2488 7
		    **	Assume these are Microsoft code points,
		    **	inflicted on us by FrontPage. - FM
		    **
		    **	MS FrontPage uses syntax like &#153; in 128-159 range
		    **	and doesn't follow Unicode standards for this area.
		    **	Windows-1252 codepoints are assumed here.
		    */
d2490 119
a2608 122
			case 1:
			    /*
			    **	WHITE SMILING FACE
			    */
			    code = 0x263a;
			    break;
			case 128:
			    /*
			    **	EURO currency sign
			    */
			    code = 0x20ac;
			    break;
			case 130:
			    /*
			    **	SINGLE LOW-9 QUOTATION MARK (sbquo)
			    */
			    code = 0x201a;
			    break;
			case 132:
			    /*
			    **	DOUBLE LOW-9 QUOTATION MARK (bdquo)
			    */
			    code = 0x201e;
			    break;
			case 133:
			    /*
			    **	HORIZONTAL ELLIPSIS (hellip)
			    */
			    code = 0x2026;
			    break;
			case 134:
			    /*
			    **	DAGGER (dagger)
			    */
			    code = 0x2020;
			    break;
			case 135:
			    /*
			    **	DOUBLE DAGGER (Dagger)
			    */
			    code = 0x2021;
			    break;
			case 137:
			    /*
			    **	PER MILLE SIGN (permil)
			    */
			    code = 0x2030;
			    break;
			case 139:
			    /*
			    **	SINGLE LEFT-POINTING ANGLE QUOTATION MARK
			    **	(lsaquo)
			    */
			    code = 0x2039;
			    break;
			case 145:
			    /*
			    **	LEFT SINGLE QUOTATION MARK (lsquo)
			    */
			    code = 0x2018;
			    break;
			case 146:
			    /*
			    **	RIGHT SINGLE QUOTATION MARK (rsquo)
			    */
			    code = 0x2019;
			    break;
			case 147:
			    /*
			    **	LEFT DOUBLE QUOTATION MARK (ldquo)
			    */
			    code = 0x201c;
			    break;
			case 148:
			    /*
			    **	RIGHT DOUBLE QUOTATION MARK (rdquo)
			    */
			    code = 0x201d;
			    break;
			case 149:
			    /*
			    **	BULLET (bull)
			    */
			    code = 0x2022;
			    break;
			case 150:
			    /*
			    **	EN DASH (ndash)
			    */
			    code = 0x2013;
			    break;
			case 151:
			    /*
			    **	EM DASH (mdash)
			    */
			    code = 0x2014;
			    break;
			case 152:
			    /*
			    **	SMALL TILDE (tilde)
			    */
			    code = 0x02dc;
			    break;
			case 153:
			    /*
			    **	TRADE MARK SIGN (trade)
			    */
			    code = 0x2122;
			    break;
			case 155:
			    /*
			    **	SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
			    **	(rsaquo)
			    */
			    code = 0x203a;
			    break;
			default:
			    /*
			    **	Do not attempt a conversion
			    **	to valid Unicode values.
			    */
			    break;
d2612 2
a2613 2
		**  Check for special values. - FM
		*/
d2616 1
a2616 1
		     (context->element_stack->tag  &&
d2619 2
a2620 2
		    **	Handle zwnj (8204) as <WBR>. - FM
		    */
d2623 2
a2624 1
		    CTRACE((tfp, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n"));
d2627 3
a2629 3
		    **	Include the terminator if it is not
		    **	the standard semi-colon. - FM
		    */
d2636 3
a2638 3
		    **	Add the replacement string to the
		    **	recover buffer for processing. - FM
		    */
d2651 3
a2653 3
		    **	We handled the value as a special character,
		    **	so recycle the terminator or break. - FM
		    */
d2657 1
a2657 1
			PUTS( (context->isHex ? "&#x" : "&#") );
d2672 2
a2673 2
		**  Seek a translation from the chartrans tables.
		*/
d2682 1
a2682 1
		    PUTC(FROMASCII((char)uck));
d2691 3
a2693 3
			   /*
			   **  Not found; look for replacement string.
			   */
d2702 4
a2705 4
		    PUTS(replace_buf);
		/*
		**  If we're displaying UTF-8, try that now. - FM
		*/
d2707 5
a2711 5
		    ;  /* do nothing more */
		/*
		**  Ignore 8205 (zwj),
		**  8206 (lrm), and 8207 (rln), if we get to here. - FM
		*/
d2728 1
a2728 1
			PUTS( (context->isHex ? "&#x" : "&#") );
d2741 12
a2752 13
		/*
		**  Show the numeric entity if we get to here
		**  and the value:
		**   (1) Is greater than 255 (but use ASCII characters
		**	 for spaces or dashes).
		**   (2) Is less than 32, and not valid or we don't
		**	 have HTCJK set.
		**   (3) Is 127 and we don't have HTPassHighCtrlRaw or
		**	 HTCJK set.
		**   (4) Is 128 - 159 and we don't have HTPassHighCtrlNum
		**	 set.
		**  - FM
		*/
d2754 1
a2754 1
			   (code < ' ' &&  /* S/390 -- gil -- 1140 */
d2761 4
a2764 5
			/*
			**  Unhandled or illegal value.	 Recover the
			**  "&#" or "&#x" and digit(s), and recycle
			**  the terminator. - FM
			*/
d2766 3
a2768 3
			if (psrc_view) {
			    PSRCSTART(badseq);
			}
d2770 9
a2778 9
			if (context->isHex) {
			    PUTS("&#x");
			    context->isHex = FALSE;
			} else {
			    PUTS("&#");
			}
			string->size--;
			for (i = 0; i < string->size; i++)	/* recover */
			    PUTC(string->data[i]);
d2780 3
a2782 3
			if (psrc_view) {
			    PSRCSTOP(badseq);
			}
d2784 5
a2788 5
			string->size = 0;
			context->isHex = FALSE;
			context->state = S_text;
			goto top1;
		} else if (TOASCII(code) < 161 ||  /* S/390 -- gil -- 1162 */
d2792 2
a2793 2
		    **	No conversion needed. - FM
		    */
d2799 1
a2799 1
		    PUTC(FROMASCII((char)code));
d2802 2
a2803 2
		    **	Handle as named entity. - FM
		    */
d2812 3
a2814 3
			**  Add a semi-colon if something went wrong
			**  and handle_entity() sent the string. - FM
			*/
d2820 3
a2822 3
			**  Our conversion failed, so recover the "&#"
			**  and digit(s), and recycle the terminator. - FM
			*/
d2847 2
a2848 2
		**  If we get to here, we succeeded.  Hoorah!!! - FM
		*/
d2853 3
a2855 3
		**  Don't eat the terminator if it's not
		**  the "standard" semi-colon for HTML. - FM
		*/
d2861 4
a2864 5
		**  Not an entity, and don't know why not, so add
		**  the terminator to the string, output the "&#"
		**  or "&#x", and process the string via the recover
		**  element. - FM
		*/
d2896 4
a2899 4
    /*
    **	Tag
    */
    case S_tag:					/* new tag */
d2901 1
a2901 1
		  IsNmChar(c) : IsNmStart(c))) {
d2903 2
a2904 2
	    **	Add valid ASCII character. - FM
	    */
d2906 1
a2906 1
	} else if (c == '!' && !string->size) { /* <! */
d2908 3
a2910 3
	    **	Terminate and set up for possible comment,
	    **	identifier, declaration, or marked section. - FM
	    */
d2918 1
a2918 1
		   (TOASCII(unsign_c) <= 160 &&	 /* S/390 -- gil -- 1196 */
d2921 7
a2927 7
	    **	'<' must be followed by an ASCII letter to be a valid
	    **	start tag.  Here it isn't, nor do we have a '/' for an
	    **	end tag, nor one of some other characters with a
	    **	special meaning for SGML or which are likely to be legal
	    **	Name Start characters in XML or some other extension.
	    **	So recover the '<' and following character as data. - FM & KW
	    */
d2939 1
a2939 1
	} else {				/* End of tag name */
d2941 4
a2944 3
	    **	Try to handle tag. - FM
	    */
	    HTTag * t;
d2950 1
a2950 1
		CTRACE((tfp,"SGML: `<%.*s/' found!\n", string->size, string->data));
d2952 1
a2952 1
	    HTChunkTerminate(string) ;
d2960 3
a2962 3
		**  Treat <URL: as text rather than a junk tag,
		**  so we display it and the URL (Lynxism 8-). - FM
		*/
d2968 1
a2968 1
		PUTS(string->data); /* recover */
d2975 1
a2975 1
			    string->data, c));
d2982 4
a2985 4
		 *  Element name was ended by '/'.  Remember the tag that
		 *  ended thusly, we'll interpret this as either an indication
		 *  of an empty element (if '>' follows directly) or do
		 *  some SGMLshortref-ish treatment. - kw
d2997 1
a2997 1
			context->seen_nonwhite_in_junk_tag = TRUE; /*show all*/
d3004 1
a3004 1
			    string->data));
d3019 1
a3019 1
		    if (c == '>' ) {
d3033 1
a3033 1
			    string->data));
d3035 3
a3037 3
		**  Fall through and treat like valid
		**  tag for attribute parsing. - KW
		*/
d3063 1
a3063 1
	    if (!psrc_view) /*don't waste time */
d3066 5
a3070 5
	    /*
	    **	Clear out attributes.
	    */
		memset( (void*)context->present, 0 , sizeof(BOOL)*
				context->current_tag->number_of_attributes);
d3107 2
a3108 2
	    **	Set up for possible comment. - FM
	    */
d3116 2
a3117 2
	    **	Set up for possible marked section. - FM
	    */
d3127 2
a3128 2
	    **	Set up to handle comment. - FM
	    */
d3140 2
a3141 2
	    **	Try to handle identifier. - FM
	    */
d3152 1
a3152 1
	    handle_identifier(context);
d3161 2
a3162 2
		**  Set up for DOCTYPE declaration. - FM
		*/
d3171 2
a3172 2
		**  Set up for ENTITY declaration. - FM
		*/
d3182 2
a3183 2
		**  Set up for ELEMENT declaration. - FM
		*/
d3193 2
a3194 2
		**  Set up for ATTLIST declaration. - FM
		*/
d3208 2
a3209 2
	    **	Any '>' terminates. - FM
	    */
d3221 1
a3221 1
		handle_comment(context);
d3242 3
a3244 3
		**  Validly treat '--' pairs as successive comments
		**  (for minimal, any "--WHITE>" terminates). - FM
		*/
d3250 2
a3251 2
	    **	Terminate and handle the comment. - FM
	    */
d3273 1
a3273 1
    S_comment_put_c:
d3275 1
a3275 1
		   *context->utf_buf) {
d3321 1
a3321 1
	    handle_doctype(context);
d3353 1
a3353 1
	    handle_marked(context);
d3387 1
a3387 1
	    handle_sgmlent(context);
d3424 1
a3424 1
	    handle_sgmlele(context);
d3461 1
a3461 1
	    handle_sgmlatt(context);
d3479 2
a3480 2
	    if (context->current_tag->name)
		start_element(context);
d3492 1
a3492 1
	context->state = S_attr; /* Get attribute */
d3495 1
a3495 1
				/* accumulating value */
d3503 7
a3509 7
	    string->size = 0;
	    if (c == '>') {				/* End of tag */
		if (context->current_tag->name)
		    start_element(context);
		context->state = S_text;
		break;
	    }
d3524 2
a3525 1
		if (c == '=' ) PUTC('=');
d3542 1
a3542 1
	    context->state = (c == '=' ?  S_equals: S_attr_gap);
d3583 1
a3583 1
	context->state = S_attr; /* Get next attribute */
d3628 1
a3628 1
	/*  no break!  fall through to S_value and process current `c`	 */
d3631 2
a3632 2
	if (WHITE(c) || (c == '>')) {		/* End of word */
	    HTChunkTerminate(string) ;
d3635 1
a3635 1
		/*PSRCSTART(attrval);*/
d3638 3
a3640 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3643 1
a3643 1
		    HTStartAnchor(context->target,NULL,string->data);
d3647 3
a3649 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3655 4
a3658 2
#ifdef CJK_EX	/* Quick hack. - JH7AYN */
	    {   char jis_buf[512];
d3660 6
a3665 5
		  if (string->data[1] == 'B' || string->data[1] == '@@') {
		    jis_buf[0] = '\033';
		    strcpy(jis_buf + 1, string->data);
		    TO_EUC((CONST unsigned char *)jis_buf, (unsigned char *)string->data);
		  }
d3671 1
a3671 1
	    if (c == '>') {		/* End of tag */
d3683 2
a3684 2
	    }
	    else context->state = S_tag_gap;
d3711 1
a3711 1
	    HTChunkTerminate(string) ;
d3714 1
a3714 1
		/*PSRCSTART(attrval);*/
d3716 4
a3719 5
		    HTStartAnchor(context->target,string->data, NULL);
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3722 1
a3722 1
		    HTStartAnchor(context->target,NULL,string->data);
d3726 3
a3728 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3735 1
a3735 1
	    handle_attribute_value(context, string->data);
d3738 1
a3738 1
	} else if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1213 */
d3740 3
a3742 3
	    **	Setting up for possible single quotes in CJK escape
	    **	sequences. - Takuya ASADA (asada@@three-a.co.jp)
	    */
d3773 1
a3773 1
	    HTChunkTerminate(string) ;
d3776 1
a3776 1
		/*PSRCSTART(attrval);*/
d3778 4
a3781 5
		    HTStartAnchor(context->target,string->data, NULL);
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3784 1
a3784 1
		    HTStartAnchor(context->target,NULL,string->data);
d3788 3
a3790 4
		    (*context->actions->end_element)(
			context->target,
			HTML_A,
			(char **)&context->include);
d3798 1
a3798 1
	    handle_attribute_value(context, string->data);
d3803 1
a3803 1
	} else if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1230 */
d3805 3
a3807 3
	    **	Setting up for possible double quotes in CJK escape
	    **	sequences. - Takuya ASADA (asada@@three-a.co.jp)
	    */
d3834 1
a3834 1
    case S_end:					/* </ */
d3836 1
a3836 1
		  IsNmChar(c) : IsNmStart(c))) {
d3838 3
a3840 2
	} else {				/* End of end tag name */
	    HTTag * t = 0;
d3875 1
a3875 1
		    psrc_tagname_processed=TRUE;
d3881 1
d3884 1
a3884 1
		int branch = 2; /* it can be 0,1,2*/
d3894 1
a3894 1
		 && Old_DTD
d3896 13
a3908 5
		 ) {
		   switch (e) {
		     case HTML_DD: case HTML_DT: case HTML_LI: case HTML_LH :
		     case HTML_TD: case HTML_TH: case HTML_TR: case HTML_THEAD:
		     case HTML_TFOOT : case HTML_TBODY : case HTML_COLGROUP:
d3912 12
a3923 3
		     case HTML_A:  case HTML_B: case HTML_BLINK: case HTML_CITE:
		     case HTML_EM: case HTML_FONT: case HTML_FORM: case HTML_I:
		     case HTML_P:  case HTML_STRONG: case HTML_TT: case HTML_U:
d3934 2
a3935 2
		**  Just handle ALL end tags normally :-) - kw
		*/
d3937 1
a3937 1
		    end_element( context, context->current_tag);
d3941 1
a3941 1
		if (tag_OK &&
d3943 1
a3943 1
		    (branch == 0)
d3945 11
a3955 11
		    (!strcasecomp(string->data, "DD") ||
		     !strcasecomp(string->data, "DT") ||
		     !strcasecomp(string->data, "LI") ||
		     !strcasecomp(string->data, "LH") ||
		     !strcasecomp(string->data, "TD") ||
		     !strcasecomp(string->data, "TH") ||
		     !strcasecomp(string->data, "TR") ||
		     !strcasecomp(string->data, "THEAD") ||
		     !strcasecomp(string->data, "TFOOT") ||
		     !strcasecomp(string->data, "TBODY") ||
		     !strcasecomp(string->data, "COLGROUP"))
d3957 1
a3957 1
		 ) {
d3959 3
a3961 3
		    **	Don't treat these end tags as invalid,
		    **	nor act on them. - FM
		    */
d3963 1
a3963 1
				string->data, c));
d3990 1
a3990 1
		) {
d3992 6
a3997 6
		    **	Handle end tags for container elements declared
		    **	as SGML_EMPTY to prevent "expected tag substitution"
		    **	but still processed via HTML_end_element() in HTML.c
		    **	with checks there to avoid throwing the HTML.c stack
		    **	out of whack (Ugh, what a hack! 8-). - FM
		    */
d4000 2
a4001 2
			**  We are in a SELECT block. - FM
			*/
d4004 5
a4008 4
			    **	It is not at FORM end tag, so ignore it. - FM
			    */
			    CTRACE((tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
					string->data));
d4011 6
a4016 5
			    **	End the SELECT block and then
			    **	handle the FORM end tag. - FM
			    */
			    CTRACE((tfp, "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
					string->data));
d4022 1
a4022 1
			    if (!psrc_view) /* Don't actually call if viewing psrc - kw */
d4024 4
a4027 4
			    (*context->actions->end_element)
				(context->target,
				 TAGNUM_OF_TAGP(context->current_tag),
				 (char **)&context->include);
d4031 6
a4036 5
			**  Treat a P end tag like a P start tag (Ugh,
			**  what a hack! 8-). - FM
			*/
			CTRACE((tfp, "SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
				    string->data, c, string->data, c));
d4039 1
d4052 1
a4052 1
			if (!psrc_view) /* Don't actually call if viewing psrc - kw */
d4054 4
a4057 4
			(*context->actions->end_element)
			    (context->target,
			     TAGNUM_OF_TAGP(context->current_tag),
			     (char **)&context->include);
d4070 3
a4072 3
		    **	Handle all other end tags normally. - FM
		    */
		    end_element( context, context->current_tag);
d4090 1
a4090 1
		if ( c != '>' ) {
d4105 1
a4105 1
		    CTRACE((tfp,"SGML: `</%s%c' found!\n", string->data, c));
a4113 1

d4125 1
a4125 1
    case S_dollar:	/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4134 1
a4134 1
    case S_dollar_paren: /* Expecting 'C' after CJK "ESC$(". */
d4143 1
a4143 1
    case S_paren:	/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4154 2
a4155 2
    case S_nonascii_text: /* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1264 */
d4163 1
a4163 1
    case S_esc_sq:	/* Expecting '$'or '(' following CJK ESC. */
d4174 1
a4174 1
    case S_dollar_sq:	/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4183 1
a4183 1
    case S_dollar_paren_sq: /* Expecting 'C' after CJK "ESC$(". */
d4192 1
a4192 1
    case S_paren_sq:	/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4203 2
a4204 2
    case S_nonascii_text_sq: /* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1281 */
d4221 1
a4221 1
    case S_dollar_dq:	/* Expecting '@@', 'B', 'A' or '(' after CJK "ESC$". */
d4230 1
a4230 1
    case S_dollar_paren_dq: /* Expecting 'C' after CJK "ESC$(". */
d4239 1
a4239 1
    case S_paren_dq:	/* Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(". */
d4250 2
a4251 2
    case S_nonascii_text_dq: /* Expecting CJK ESC after non-ASCII text. */
	if (TOASCII(c) == '\033') {  /* S/390 -- gil -- 1298 */
d4276 1
a4276 1
	    /*pack spaces until first non-space is seen*/
d4287 1
a4287 1
    } /* switch on context->state */
d4289 4
a4292 4
	    state_name(context->state),
	    string->size,
	    NonNull(string->data),
	    UCH(c)));
d4294 1
a4294 1
after_switch:
d4296 4
a4299 4
    **	Check whether an external function has added
    **	anything to the include buffer.  If so, move the
    **	new stuff to the beginning of active_include. - kw
    */
d4316 2
a4317 2
    **	Check whether we've added anything to the recover buffer. - FM
    */
d4330 3
a4332 4
    **	Check whether an external function had added
    **	anything to the include buffer; it should now be
    **  in active_include. - FM / kw
    */
d4341 4
a4344 5
		 *  If it looks like we would have fed UTF-8 to the
		 *  next processing stage, assume that whatever we were
		 *  fed back is in UTF-8 form, too.  This won't be always
		 *  true for all uses of the include buffer, but it's a
		 *  start. - kw
d4347 1
d4351 1
a4351 1
			c = ((char)(clong & 0xff));
d4358 2
a4359 2
		 *  Otherwise assume no UTF-8 - do charset-naive processing
		 *  and hope for the best. - kw
d4369 3
a4371 3
    **	Check whether an external function has added
    **	anything to the csi buffer. - FM
    */
d4382 1
a4382 1
}  /* SGML_character */
d4384 3
a4387 5
PRIVATE void SGML_string ARGS2(
	HTStream *,	context,
	CONST char*,	str)
{
    CONST char *p;
d4392 5
a4397 7
PRIVATE void SGML_write ARGS3(
	HTStream *,	context,
	CONST char*,	str,
	int,		l)
{
    CONST char *p;
    CONST char *e = str+l;
d4406 3
a4408 3
**	-----------------------
*/
PUBLIC CONST HTStreamClass SGMLParser =
d4410 6
a4415 6
	"SGMLParser",
	SGML_free,
	SGML_abort,
	SGML_character,
	SGML_string,
	SGML_write,
d4419 7
a4425 7
**	------------------
**
** On entry,
**	dtd		represents the DTD, along with
**	actions		is the sink for the data as a set of routines.
**
*/
d4427 3
a4429 4
PUBLIC HTStream* SGML_new  ARGS3(
	CONST SGML_dtd *,	dtd,
	HTParentAnchor *,	anchor,
	HTStructured *,		target)
d4432 2
a4433 1
    HTStream* context = (HTStream *) malloc(sizeof(*context));
d4443 2
a4444 2
    context->actions = (CONST HTStructuredClass*)(((HTStream*)target)->isa);
					/* Ugh: no OO */
d4449 1
a4449 1
    context->element_stack = 0;			/* empty */
d4451 1
a4451 1
    context->no_lynx_specialcodes = NO;	/* special codes normally generated */
d4453 1
a4453 1
    context->callerData = (void*) callerData;
d4466 1
a4466 1
    context->node_anchor = anchor; /* Could be NULL? */
d4482 1
a4482 1
#ifdef CAN_SWITCH_DISPLAY_CHARSET /* Allow a switch to a more suitable display charset */
d4485 1
a4485 1
	     && anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl != current_char_set ) {
d4488 1
a4488 1
	anchor->UCStages->s[UCT_STAGE_PARSER].LYhndl = -1; /* Force reset */
d4490 1
a4490 1
				  /* Preserve change this: */
d4521 1
d4525 13
d4539 5
a4543 5
**		====================================
**
**	Added 24-Mar-96 by FM, based on:
**
////////////////////////////////////////////////////////////////////////
d4566 1
a4566 1
PUBLIC int TREAT_SJIS = 1;
d4568 70
a4637 70
PUBLIC void JISx0201TO0208_EUC ARGS4(
	register unsigned char,		IHI,
	register unsigned char,		ILO,
	register unsigned char *,	OHI,
	register unsigned char *,	OLO)
{
    static char *table[] = {
	"\241\243",	/* A1,A3 */
	"\241\326",	/* A1,D6 */
	"\241\327",	/* A1,D7 */
	"\241\242",	/* A1,A2 */
	"\241\246",	/* A1,A6 */
	"\245\362",	/* A5,F2 */
	"\245\241",	/* A5,A1 */
	"\245\243",	/* A5,A3 */
	"\245\245",	/* A5,A5 */
	"\245\247",	/* A5,A7 */
	"\245\251",	/* A5,A9 */
	"\245\343",	/* A5,E3 */
	"\245\345",	/* A5,E5 */
	"\245\347",	/* A5,E7 */
	"\245\303",	/* A5,C3 */
	"\241\274",	/* A1,BC */
	"\245\242",	/* A5,A2 */
	"\245\244",	/* A5,A4 */
	"\245\246",	/* A5,A6 */
	"\245\250",	/* A5,A8 */
	"\245\252",	/* A5,AA */
	"\245\253",	/* A5,AB */
	"\245\255",	/* A5,AD */
	"\245\257",	/* A5,AF */
	"\245\261",	/* A5,B1 */
	"\245\263",	/* A5,B3 */
	"\245\265",	/* A5,B5 */
	"\245\267",	/* A5,B7 */
	"\245\271",	/* A5,B9 */
	"\245\273",	/* A5,BB */
	"\245\275",	/* A5,BD */
	"\245\277",	/* A5,BF */
	"\245\301",	/* A5,C1 */
	"\245\304",	/* A5,C4 */
	"\245\306",	/* A5,C6 */
	"\245\310",	/* A5,C8 */
	"\245\312",	/* A5,CA */
	"\245\313",	/* A5,CB */
	"\245\314",	/* A5,CC */
	"\245\315",	/* A5,CD */
	"\245\316",	/* A5,CE */
	"\245\317",	/* A5,CF */
	"\245\322",	/* A5,D2 */
	"\245\325",	/* A5,D5 */
	"\245\330",	/* A5,D8 */
	"\245\333",	/* A5,DB */
	"\245\336",	/* A5,DE */
	"\245\337",	/* A5,DF */
	"\245\340",	/* A5,E0 */
	"\245\341",	/* A5,E1 */
	"\245\342",	/* A5,E2 */
	"\245\344",	/* A5,E4 */
	"\245\346",	/* A5,E6 */
	"\245\350",	/* A5,E8 */
	"\245\351",	/* A5,E9 */
	"\245\352",	/* A5,EA */
	"\245\353",	/* A5,EB */
	"\245\354",	/* A5,EC */
	"\245\355",	/* A5,ED */
	"\245\357",	/* A5,EF */
	"\245\363",	/* A5,F3 */
	"\241\253",	/* A1,AB */
	"\241\254"	/* A1,AC */
d4649 1
a4649 1
PRIVATE int IS_SJIS_STR ARGS1(CONST unsigned char *, str)
d4651 1
a4651 1
    CONST unsigned char *s;
d4664 3
a4666 4
PUBLIC unsigned char * SJIS_TO_JIS1 ARGS3(
	register unsigned char,		HI,
	register unsigned char,		LO,
	register unsigned char *,	JCODE)
d4683 3
a4685 4
PUBLIC unsigned char * JIS_TO_SJIS1 ARGS3(
	register unsigned char,		HI,
	register unsigned char,		LO,
	register unsigned char *,	SJCODE)
d4702 3
a4704 4
PUBLIC unsigned char * EUC_TO_SJIS1 ARGS3(
	unsigned char,			HI,
	unsigned char,			LO,
	register unsigned char *,	SJCODE)
d4712 3
a4714 4
PUBLIC void JISx0201TO0208_SJIS ARGS3(
	register unsigned char,		I,
	register unsigned char *,	OHI,
	register unsigned char *,	OLO)
d4724 3
a4726 4
PUBLIC unsigned char * SJIS_TO_EUC1 ARGS3(
	unsigned char,		HI,
	unsigned char,		LO,
	unsigned char *,	data)
d4734 2
a4735 3
PUBLIC unsigned char * SJIS_TO_EUC ARGS2(
	unsigned char *,	src,
	unsigned char *,	dst)
d4756 2
a4757 3
PUBLIC unsigned char * EUC_TO_SJIS ARGS2(
	unsigned char *,	src,
	unsigned char *,	dst)
d4778 1
a4778 1
#define Strcpy(a,b)	(strcpy((char*)a,(CONST char*)b),&a[strlen((CONST char*)a)])
d4780 4
a4783 5
PUBLIC unsigned char *EUC_TO_JIS ARGS4(
	unsigned char *,	src,
	unsigned char *,	dst,
	CONST char *,		toK,
	CONST char *,		toA)
d4828 1
a4828 1
PUBLIC int repair_JIS = 0;
d4830 2
a4831 3
PRIVATE CONST unsigned char *repairJIStoEUC ARGS2(
	CONST unsigned char *,	src,
	unsigned char **,	dstp)
d4833 1
a4833 1
    CONST unsigned char *s;
d4854 2
a4855 3
PUBLIC unsigned char *TO_EUC ARGS2(
	CONST unsigned char *,	jis,
	unsigned char *,	euc)
d4857 1
a4857 1
    register CONST unsigned char *s;
d4884 2
a4885 1
		CONST unsigned char *ts;
d4892 1
a4892 1
	if (c == ESC) {
d4944 1
a4944 1
PRIVATE int is_EUC_JP ARGS1(unsigned char *, euc)
d4966 2
a4967 3
PUBLIC void TO_SJIS ARGS2(
	CONST unsigned char *,	any,
	unsigned char *,	sjis)
d4971 2
a4972 1
    euc = malloc(strlen((CONST char *) any) + 1);
d4977 1
a4977 1
    TO_EUC(any, euc);
d4981 1
a4981 1
	strcpy((char *) sjis, (CONST char *) any);
d4985 2
a4986 3
PUBLIC void TO_JIS ARGS2(
	CONST unsigned char *,	any,
	unsigned char *,	jis)
d4990 1
a4990 1
    if (any[0] == 0) {
d4994 1
a4994 1
    euc = malloc(strlen((CONST char *) any) + 1);
d4999 1
a4999 1
    TO_EUC(any, euc);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d32 1
a46 5
#  define PSRC(x) if (psrc_view) { x };
#  define NPSRC(x) if (!psrc_view) { x };
#  define IFDEFPSRC(x) x
#  define IFNDEFPSRC(x)

a60 5
#else
#  define PSRC(x)
#  define NPSRC(x)
#  define IFDEFPSRC(x)
#  define IFNDEFPSRC(x) x
d63 21
a83 2
 /* will use an inlined version */
#ifdef USE_INLINE_PUTC
d85 15
a99 10
#define HTChunkPutc(ch,c)\
    if (ch->size >= ch->allocated) {\
	ch->allocated = ch->allocated + ch->growby;\
	ch->data = ch->data ? (char *)realloc(ch->data, ch->allocated)\
			    : typecallocn(char, ch->allocated);\
      if (!ch->data)\
	  outofmem(__FILE__, "HTChunkPutc");\
    }\
    ch->data[ch->size++] = c;
#endif
d102 3
a104 1

a117 2
/*  extern int LYlowest_eightbit[];  for completeness here  */

d202 2
d211 1
a211 1
    char * value[MAX_ATTRIBUTES];	/* malloc'd strings or NULL if none */
d301 21
d360 1
a360 1
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(context,HTL_##x,STOP)
d363 1
a363 1
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(context,HTL_/**/x,STOP)
a471 8
#define PUTC(ch) ((*context->actions->put_character)(context->target, ch))
#define PUTUTF8(code) (UCPutUtf8_charstring((HTStream *)context->target, \
		      (putc_func_t*)(context->actions->put_character), code))

extern BOOL historical_comments;
extern BOOL minimal_comments;
extern BOOL soft_dquotes;

d474 1
a474 1
static int current_is_class=0;
a485 1

d514 1
a514 1
	diff = strcasecomp(attributes[i].name, s);
d518 4
a521 1
	    if (!psrc_view) {
d523 1
d525 1
a525 1
	    FREE(context->value[i]);
d527 1
a527 1
#  ifdef USE_PRETTYSRC
a533 5

#ifdef USE_PRETTYSRC
	    } else {
		 attr_is_name = (BOOL) (attributes[i].type == HTMLA_ANAME);
		 attr_is_href = (BOOL) (attributes[i].type == HTMLA_HREF);
a534 1
#endif
d554 1
a554 1
	StrAllocCopy(context->value[context->current_attribute_number], s);
d653 21
a696 1
    CONST char *p;
a698 1

d711 1
a711 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d727 1
a727 3
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&'); PUTS(entity_string); if (term) PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d743 1
a743 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d746 1
a746 2
	    for (p = replace_buf; *p; p++)
		PUTC(*p);
d764 1
a764 3
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&'); PUTS(entity_string); if (term) PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d777 1
a777 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d796 1
a796 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d810 1
a810 6
		HTMLSRC_apply_markup(context,HTL_entity,START);
		PUTC('&');
		PUTS(entity_string);
		if (term)
		    PUTC(term);
		HTMLSRC_apply_markup(context,HTL_entity,STOP);
d827 1
a827 3
    for (p = s; *p; p++) {
	PUTC(*p);
    }
a1008 2
extern BOOL Old_DTD;

d1049 1
a1049 1
    FREE(stacked);
d1194 1
a1194 1
	    FREE(N);
d1304 1
d1306 2
a1307 1
	if (!strcasecomp(new_tag->name, "SELECT")) {
d1363 1
a1363 1
	HTElement * N = (HTElement *)malloc(sizeof(HTElement));
d1394 1
a1394 1
	CONST char *,		string)
d1397 5
d1404 2
a1405 2
	 high > low;
	 diff < 0 ? (low = i+1) : (high = i)) {	 /* Binary search */
d1407 2
a1408 1
	diff = AS_casecomp(dtd->tags[i].name, string);	/* Case insensitive */
d1410 2
a1411 1
	    return &dtd->tags[i];
d1414 1
a1414 1
    if (IsNmStart(string[0])) {
d1454 1
a1454 1
	FREE(cur);
d1474 1
a1474 1
	FREE(context->value[i]);
d1478 1
a1478 1
    sgml_in_psrc_was_initialized =FALSE;
d1509 1
a1509 1
	FREE(cur);
d1517 1
a1517 1
	FREE(context->value[i]);
d1521 1
a1521 1
    sgml_in_psrc_was_initialized =FALSE;
a1522 1

a1555 1
    char * p;
d1559 1
d1720 1
a1720 2
		    for (p = replace_buf; *p; p++)
			PUTC(*p);
d1825 1
a1825 1
    CTRACE2(TRACE_SGML, (tfp, "SGML before %s|%.*s|%c\n",
d1828 2
a1829 1
	    string->data != NULL ? string->data : "", UCH(c)));
d1919 1
a1919 1
	    			|| testtag->contents == SGML_CDATA)) {
d2048 1
a2048 2
	    for (p = replace_buf; *p; p++)
		PUTC(*p);
a2070 1
	    int i;
d2077 1
a2077 2
	    for (i = 0; EntityName[i]; i++)
		HTChunkPutc(string, EntityName[i]);
d2109 1
a2109 2
	    for (p = context->utf_buf; *p; p++)
		PUTC(*p);
a2132 41
#ifdef NOTUSED_FOTEMODS
	    /*
	    **	If we do not have the "7-bit approximations" as our
	    **	output character set (in which case we did it already)
	    **	seek a translation for that.  Otherwise, or if the
	    **	translation fails, use UHHH notation. - FM
	    */
	    if ((chk = (context->outUCLYhndl !=
			UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(unsign_c,
				      UCGetLYhndl_byMIME("us-ascii")))
				      >= ' ' && TOASCII(uck) < 127) {  /* S/390 -- gil -- 1008 */
		/*
		**  Got an ASCII character (yippey). - FM
		*/
		PUTC(((char)FROMASCII(TOASCII(uck) & 0xff)));
	    } else if ((chk && uck == -4) &&
		       (uck = UCTransUniCharStr(replace_buf,
						60, clong,
						UCGetLYhndl_byMIME("us-ascii"),
						0) >= 0)) {
		/*
		**  Got a replacement string (yippey). - FM
		*/
		for (p = replace_buf; *p; p++)
		    PUTC(*p);
	    } else {
#endif /* NOTUSED_FOTEMODS */
		/*
		**  Out of luck, so use the UHHH notation (ugh). - FM
		*/
			/* S/390 -- gil -- 1018 */
			/* do not print UHHH for now
		sprintf(replace_buf, "U%.2lX", TOASCII(unsign_c));
		for (p = replace_buf; *p; p++) {
		    PUTC(*p);
		}
			 */
#ifdef NOTUSED_FOTEMODS
	    }
#endif /* NOTUSED_FOTEMODS */
d2165 3
a2167 1
		    PSRCSTART(abracket);PUTS("<?");PSRCSTOP(abracket);
d2215 17
a2231 3
	if (TOUPPER(c) != ((string->size == 1) ?
					   '/' :
			   testtag->name[string->size-2])) {
d2237 2
a2238 2
	    if ((c == '>') && testtag &&
		string->size > 1 && !testtag->name[string->size-2]) {
d2241 3
a2243 1
		    PSRCSTART(abracket);PUTC('<');PUTC('/');PSRCSTOP(abracket);
d2254 3
a2256 1
		    PSRCSTART(abracket);PUTC('>');PSRCSTOP(abracket);
d2259 1
a2259 5
		    string->size = 0;
		    context->current_attribute_number = INVALID;
		    context->state = S_text;
		    break;
		}
d2261 2
a2262 1
		end_element(context, context->element_stack->tag);
d2266 2
d2271 21
d2296 2
a2297 2
		(string->size > 1 &&
		 (c == '>' || string->size > 2 || IsNmStart(c)))) {
d2309 1
a2309 1
		(string->size == 1 && IsNmStart(c))) {
d2415 1
a2415 1
		HTMLSRC_apply_markup(context,HTL_entity, START);
d2417 1
a2417 1
		HTMLSRC_apply_markup(context,HTL_entity, STOP);
d2481 1
a2481 3
	    PUTC('&');
	    PUTC('#');
	    PUTC('x');
d2710 1
a2710 5
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
d2724 1
a2724 5
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
d2727 1
a2727 3
		    for (p = replace_buf; *p; p++) {
			PUTC(*p);
		    }
a2732 47
#ifdef NOTUSED_FOTEMODS
		/*
		**  If the value is greater than 255 and we do not
		**  have the "7-bit approximations" as our output
		**  character set (in which case we did it already)
		**  seek a translation for that. - FM
		*/
		} else if ((chk = ((code > 255) &&
				   context->outUCLYhndl !=
				   UCGetLYhndl_byMIME("us-ascii"))) &&
			   (uck = UCTransUniChar(code,
				   UCGetLYhndl_byMIME("us-ascii")))
				  >= ' ' && uck < 127) {
		    /*
		    **	Got an ASCII character (yippey). - FM
		    */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
		    } else
#endif
		    PUTC(((char)FROMASCII(uck & 0xff)));
/* =============== work in ASCII above here ===============  S/390 -- gil -- 1118 */
		} else if ((chk && uck == -4) &&
			   (uck = UCTransUniCharStr(replace_buf,
						    60, code,
						UCGetLYhndl_byMIME("us-ascii"),
						    0) >= 0)) {
		    /*
		    **	Got a replacement string (yippey). - FM
		    */
#ifdef USE_PRETTYSRC
		    if (psrc_view) {
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
		    } else
#endif
		    for (p = replace_buf; *p; p++)
			PUTC(*p);
#endif /* NOTUSED_FOTEMODS */
a2796 2
			PUTC('&');
			PUTC('#');
d2798 1
a2798 1
			    PUTC('x');
d2800 2
d2823 1
a2823 5
			PSRCSTART(entity);
			PUTS( (context->isHex ? "&#x" : "&#") );
			PUTS(entity_string);
			PUTC(';');
			PSRCSTOP(entity);
d2835 1
a2835 2
			for (i = 0; EntityName[i]; i++)
			    HTChunkPutc(string, EntityName[i]);
a2853 2
			PUTC('&');
			PUTC('#');
d2855 1
a2855 1
			    PUTC('x');
d2857 2
d2900 6
a2905 2
		PUTC('&');
		PUTC('#');
a2909 4
		if (context->isHex) {
		    PUTC('x');
		    context->isHex = FALSE;
		}
d3021 3
a3023 1
			PSRCSTART(abracket);PUTS("<?");PSRCSTOP(abracket);
d3035 3
a3037 1
		    PSRCSTART(abracket);PUTC('<');PSRCSTOP(abracket);
d3048 3
a3050 1
			PSRCSTART(abracket);PUTC('>');PSRCSTOP(abracket);
d3071 3
a3073 1
		PSRCSTART(abracket);PUTC('<');PSRCSTOP(abracket);
d3552 6
a3557 4
		if (context->current_attribute_number == INVALID)
		    PSRCSTOP(badattr);
		else
		    PSRCSTOP(attrib);
d3741 1
a3741 1
		    HTStartAnchor(context->target,string->data,NULL);
d3805 1
a3805 1
		    HTStartAnchor(context->target,string->data,NULL);
d3885 1
a3885 2
		    PUTC('<');
		    PUTC('/');
d3899 3
a3901 1
			PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
d4085 1
a4085 2
		PUTC('<');
		PUTC('/');
d4094 2
a4095 1
		PUTS(string->data); PSRCSTOP(tag);
d4295 1
a4295 1
    CTRACE2(TRACE_SGML, (tfp, "SGML after  %s|%.*s|%c\n",
d4298 2
a4299 1
	    string->data != NULL ? string->data : "", UCH(c)));
d4346 1
a4346 1
	    if (context->current_tag_charset == UTF8 ||
d4451 2
a4457 1
/*    context->extra_tags = dtd->tags + dtd->number_of_tags; */
d4494 13
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d38 1
a38 1
#ifdef USE_PSRC
d44 1
a44 1
#ifdef USE_PSRC
d79 1
a79 1
			    : (char *)calloc(1, ch->allocated);\
d89 2
a90 3
#define OPT 0 /* don't make it 1 otherwise something wrong will be with
 TagSoup parser mode - I was unable to undestand why it works incorrectly -HV*/
#define OPT1 1 /* set to 1 for several optimizations */
d123 45
d181 1
d184 1
d188 2
a189 13
    enum sgml_state { S_text, S_litteral,
		S_tag, S_tag_gap, S_attr, S_attr_gap, S_equals, S_value,
		S_ero, S_cro, S_incro,
		S_exclamation, S_comment, S_doctype, S_marked,
		S_sgmlent, S_sgmlele, S_sgmlatt,
		S_squoted, S_dquoted, S_end, S_entity,
		S_esc,	  S_dollar,    S_paren,	   S_nonascii_text,
		S_dollar_paren,
		S_esc_sq, S_dollar_sq, S_paren_sq, S_nonascii_text_sq,
		S_dollar_paren_sq,
		S_esc_dq, S_dollar_dq, S_paren_dq, S_nonascii_text_dq,
		S_dollar_paren_dq,
		S_in_kanji, S_junk_tag} state;
d219 1
d224 59
a282 1
} ;
d284 1
a284 2
#ifdef USE_PSRC
static BOOL seen_letter_in_junk_tag;
d288 1
a288 1
	    HTlexem,	      lexem,
d291 1
a291 1
    HT_tagspec* ts = *( ( start ? lexem_start : lexem_end ) + lexem);
d302 1
a302 1
	CTRACE(tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexem);
d320 1
d323 4
d328 2
a329 2
PRIVATE BOOL cur_attr_is_href;
PRIVATE BOOL cur_attr_is_name;
d340 1
a340 1
	**  so the HTML parser's UCLYhndl should still be it's
d461 1
a461 1
#ifdef USE_PSRC
d463 2
a464 2
	cur_attr_is_href = FALSE;
	cur_attr_is_name = FALSE;
d471 1
a471 1
#ifdef USE_PSRC
d488 1
a488 1
#ifdef USE_PSRC
d494 1
a494 4
#  ifdef USE_PSRC
#       if !OPT1
	    current_is_class = (!strcasecomp("class", s));
#       else
a495 1
#       endif
d499 1
a499 1
	    CTRACE(tfp, "SGML: found attribute %s, %d\n", s, current_is_class);
d502 1
a502 1
#ifdef USE_PSRC
d504 2
a505 2
		 cur_attr_is_name = (attributes[i].type == HTMLA_ANAME);
		 cur_attr_is_href = (attributes[i].type == HTMLA_HREF);
d513 2
a514 2
    CTRACE(tfp, "SGML: Unknown attribute %s for tag %s\n",
		s, context->current_tag->name);
d532 1
a532 1
	    CTRACE(tfp, "SGML: class is '%s'\n", s);
d536 1
a536 1
	    CTRACE(tfp, "SGML: attribute value is '%s'\n", s);
d540 1
a540 1
	CTRACE(tfp, "SGML: Attribute value %s ***ignored\n", s);
d560 8
d572 1
a572 1
#ifdef USE_PSRC
d580 1
a580 1
#ifdef USE_PSRC
d595 2
a596 1
	**  Assume emsp as two ensp (below).
d598 1
a598 1
#ifdef USE_PSRC
d606 1
a606 1
#ifdef USE_PSRC
d611 1
a611 1
#ifdef USE_PSRC
d663 1
a663 1
#ifdef USE_PSRC
d684 1
a684 1
#ifdef USE_PSRC
d702 1
a702 1
#ifdef USE_PSRC
d720 1
a720 1
#ifndef USE_PSRC
d728 1
a728 1
	      (putc_func_t*)(&fake_put_character), code)): PUTUTF8(code) ) ) {
d744 1
a744 1
#ifdef USE_PSRC
d767 2
a768 2
	    CTRACE(tfp, "handle_entity: Ignoring '%s'.\n", s);
#ifdef USE_PSRC
d786 2
a787 2
	    CTRACE(tfp, "handle_entity: Ignoring '%s'.\n", s);
#ifdef USE_PSRC
d805 1
a805 1
#ifdef USE_PSRC
d809 1
a809 1
    CTRACE(tfp, "SGML: Unknown entity '%s' %ld %ld\n", s, (long)code, uck); /* S/390 -- gil -- 0695 */
d816 1
a816 1
#ifdef USE_PSRC
d831 1
a831 1
    CTRACE(tfp, "SGML Comment:\n<%s>\n", s);
d853 1
a853 1
    CTRACE(tfp, "SGML Identifier:\n<%s>\n", s);
d867 1
a867 1
    CTRACE(tfp, "SGML Doctype:\n<%s>\n", s);
d872 4
d885 1
a885 1
    CTRACE(tfp, "SGML Marked Section:\n<%s>\n", s);
d887 13
d912 1
a912 1
    CTRACE(tfp, "SGML Entity Declaration:\n<%s>\n", s);
d926 1
a926 1
    CTRACE(tfp, "SGML Element Declaration:\n<%s>\n", s);
d940 1
a940 1
    CTRACE(tfp, "SGML Attribute Declaration:\n<%s>\n", s);
d945 30
d988 1
a988 1
	return ((Tgc_same & usecontains) &&
d991 1
a991 1
	return ((new_tag->tagclass & usecontains) &&
d1022 1
d1028 4
d1034 1
a1034 1
	stacked->tag - context->dtd->tags,
d1038 2
d1049 2
a1050 1
	if (stacked->tag == old_tag)
d1074 5
d1081 1
a1081 1
		CTRACE(tfp, "SGML: End </%s> \t<- %s end </%s>\n",
d1084 1
a1084 1
			    old_tag->name);
a1087 5
	    } else {
		CTRACE(tfp, "SGML: Still open %s \t<- ***invalid end </%s>\n",
			    context->element_stack->tag->name,
			    old_tag->name);
		return;
d1092 1
a1092 1
	    CTRACE(tfp, "SGML: Still open %s, ***no open %s for </%s>\n",
d1096 1
a1096 1
			old_tag->name);
d1100 1
a1100 1
	    CTRACE(tfp, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",
d1103 1
a1103 1
			old_tag->name);
d1125 2
a1126 2
	    CTRACE(tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
			old_tag->name);
d1133 1
a1133 1
    CTRACE(tfp, "SGML: End </%s>\n", old_tag->name);
d1135 2
a1136 2
	CTRACE(tfp, "SGML: ***Illegal end tag </%s> found.\n",
		    old_tag->name);
d1145 2
d1148 1
a1148 1
	HTTag * t = N->tag;
d1152 2
a1153 2
		CTRACE(tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",
			     old_tag->name, t->name, t->name);
d1155 2
a1156 2
		CTRACE(tfp, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",
			    old_tag->name, t->name, old_tag->name);
d1161 25
a1185 4
	context->element_stack = N->next;		/* Remove from stack */
	FREE(N);
	(*context->actions->end_element)(context->target,
		 t - context->dtd->tags, (char **)&context->include);
d1196 2
a1197 2
    CTRACE(tfp, "SGML: Extra end tag </%s> found and ignored.\n",
		old_tag->name);
d1206 1
d1208 1
a1208 2
#if OPT1
    HTMLElement e = new_tag - context->dtd->tags;
a1209 1
#endif
d1227 1
a1227 1
		CTRACE(tfp, "SGML: End </%s> \t<- %s start <%s>\n",
d1230 1
a1230 1
			    new_tag->name);
d1236 1
a1236 1
		CTRACE(tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1238 1
a1238 1
			    new_tag->name);
d1245 1
a1245 1
	    CTRACE(tfp, "SGML: Still open %s \t<- ***ignoring start <%s>\n",
d1247 1
a1247 1
			new_tag->name);
d1258 1
a1258 1
		CTRACE(tfp, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n",
d1261 1
a1261 1
			    new_tag->name);
d1273 1
a1273 1
	    CTRACE(tfp, "SGML: Still open %s \t<- ***invalid start <%s>\n",
d1275 1
a1275 1
			new_tag->name);
a1306 10
#if !OPT1
	    if (!strcasecomp(new_tag->name, "INPUT") ||
		!strcasecomp(new_tag->name, "TEXTAREA") ||
		!strcasecomp(new_tag->name, "SELECT") ||
		!strcasecomp(new_tag->name, "BUTTON") ||
		!strcasecomp(new_tag->name, "FIELDSET") ||
		!strcasecomp(new_tag->name, "LABEL") ||
		!strcasecomp(new_tag->name, "LEGEND") ||
		!strcasecomp(new_tag->name, "FORM")) {
#else
d1316 2
a1317 2
	    if (ok) {
#endif
d1322 2
a1323 2
		CTRACE(tfp, "SGML: ***Faking SELECT end tag before <%s> start tag.\n",
			    new_tag->name);
d1329 2
a1330 2
		CTRACE(tfp, "SGML: ***Ignoring start tag <%s> in SELECT block.\n",
			    new_tag->name);
d1338 2
a1339 2
    CTRACE(tfp, "SGML: Start <%s>\n", new_tag->name);
    (*context->actions->start_element)(
d1341 1
a1341 1
	new_tag - context->dtd->tags,
d1346 2
d1355 2
a1356 3
#if !OPT
    } else if (!strcasecomp(new_tag->name, "META")) {
#else
a1357 1
#endif
d1393 1
a1393 1
    if (isalpha((unsigned char)string[0])) {
d1424 1
d1434 6
a1439 2
	(*context->actions->end_element)(context->target,
		 t - context->dtd->tags, (char **)&context->include);
d1456 1
a1456 1
#ifdef USE_PSRC
d1478 1
d1499 1
a1499 1
#ifdef USE_PSRC
d1537 1
d1540 3
d1544 1
d1555 1
a1555 1
    clong = (unsigned char)c;	/* a.k.a. unsign_c */
d1563 1
a1563 1
	if (TOASCII((unsigned char)c) > 127) { /* S/390 -- gil -- 0710 */
d1727 3
d1742 1
a1742 1
    clong = (unsigned char)c;
d1764 1
a1764 1
	return;
d1774 1
a1774 1
	return;
d1782 20
a1801 1
	return;
d1806 4
d1824 1
d1828 12
d1853 1
a1853 1
	    PUTC(c);
d1864 13
d1878 8
a1885 6
	    (!context->element_stack ||
	     (context->element_stack->tag  &&
	      (context->element_stack->tag->contents == SGML_MIXED ||
	       context->element_stack->tag->contents == SGML_ELEMENT ||
	       context->element_stack->tag->contents == SGML_PCDATA ||
	       context->element_stack->tag->contents == SGML_RCDATA)))) {
d1896 75
a1970 5
	    context->state = (context->element_stack &&
			context->element_stack->tag  &&
			context->element_stack->tag->contents == SGML_LITTERAL)
					 ?
			      S_litteral : S_tag;
d1977 1
d1985 1
d2003 1
a2003 1
	} else if ((chk = (context->T.trans_from_uni && TOASCII(unsign_c) >= 160)) &&  /* S/390 -- gil -- 0968 */
d2007 2
a2008 2
	    CTRACE(tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck));
d2053 1
a2053 1
#ifdef USE_PSRC
d2062 1
a2062 1
#ifdef USE_PSRC
d2069 1
a2069 1
#ifdef USE_PSRC
d2101 2
a2102 2
		   ((unsigned char)saved_char_in >= 0xc0) &&
		   ((unsigned char)saved_char_in < 255)) {
d2114 1
a2114 1
	} else if (TOASCII((unsigned char)c) <	 /* S/390 -- gil -- 0997 */
d2167 57
d2227 1
d2230 8
d2240 1
a2240 1
			context->element_stack->tag->name[string->size-2])) {
d2246 24
a2269 2
	    if ((c == '>') &&
		(!context->element_stack->tag->name[string->size-2])) {
d2276 22
d2299 1
a2299 1
	    **	If Mismatch: recover string.
d2328 4
a2331 1
		  isalnum((unsigned char)c) : isalpha((unsigned char)c))) {
d2341 1
a2341 1
#ifdef USE_PSRC
d2346 1
a2346 1
#ifdef USE_PSRC
d2357 1
a2357 1
#ifdef USE_PSRC
d2361 1
a2361 1
	    /* CTRACE(tfp, "%s: %d: %s\n", __FILE__, __LINE__, string->data); */
d2371 1
a2371 1
		CTRACE(tfp, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n");
d2398 1
a2398 1
#ifdef USE_PSRC
d2414 1
a2414 1
	if (TOASCII(unsign_c) < 127 && TOLOWER((unsigned char)c) == 'x') {  /* S/390 -- gil -- 1060 */
d2417 1
a2417 1
	} else if (TOASCII(unsign_c) < 127 && isdigit((unsigned char)c)) {
d2429 1
a2429 1
#ifdef USE_PSRC
d2435 1
a2435 1
#ifdef USE_PSRC
d2448 2
a2449 2
	/* S/390 -- gil -- 1075 */ /* CTRACE(tfp, "%s: %d: numeric %d %d\n",
			    __FILE__, __LINE__, unsign_c, c); */
d2451 2
a2452 2
	    (context->isHex ? isxdigit((unsigned char)c) :
			      isdigit((unsigned char)c))) {
d2462 1
a2462 1
#ifdef USE_PSRC
d2469 1
a2469 1
#ifdef USE_PSRC
d2483 1
a2483 1
#ifdef USE_PSRC
d2636 1
a2636 1
		    CTRACE(tfp, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n");
d2666 1
a2666 1
#ifdef USE_PSRC
d2691 1
a2691 1
#ifdef USE_PSRC
d2695 1
a2695 1
#ifdef USE_PSRC
d2713 1
a2713 1
#ifdef USE_PSRC
d2746 1
a2746 1
#ifdef USE_PSRC
d2765 1
a2765 1
#ifdef USE_PSRC
d2794 1
a2794 1
#ifdef USE_PSRC
d2836 1
a2836 1
#ifdef USE_PSRC
d2850 1
a2850 1
#ifdef USE_PSRC
d2865 1
a2865 1
#ifdef USE_PSRC
d2899 1
a2899 1
#ifdef USE_PSRC
d2912 1
a2912 1
#ifdef USE_PSRC
d2945 1
a2945 1
#ifdef USE_PSRC
d2951 1
a2951 1
#ifdef USE_PSRC
d2978 1
a2978 1
		  isalnum((unsigned char)c) : isalpha((unsigned char)c))) {
d3006 1
a3006 1
#ifdef USE_PSRC
d3011 1
a3011 1
#ifdef USE_PSRC
d3022 5
a3026 4
		if (string->size != 0)
		    CTRACE(tfp,"SGML: `<%s/' found!\n", string->data);
		context->state = S_end;
		break;
d3031 4
a3034 2
	    if (t == context->unknown_tag && c == ':' &&
		0 == strcasecomp(string->data, "URL")) {
d3039 1
a3039 2
		int i;
#ifdef USE_PSRC
d3044 1
a3044 2
		for (i = 0; i < 3; i++) /* recover */
		    PUTC(string->data[i]);
d3046 1
a3046 1
#ifdef USE_PSRC
d3050 2
a3051 2
		CTRACE(tfp, "SGML: Treating <%s%c as text\n",
			    string->data, c);
d3055 24
a3078 3
	    } else if (!t) {
		CTRACE(tfp, "SGML: *** Invalid element %s\n",
			    string->data);
d3080 1
a3080 1
#ifdef USE_PSRC
a3090 1

d3094 2
d3102 2
a3103 2
		CTRACE(tfp, "SGML: *** Unknown element %s\n",
			    string->data);
d3112 1
a3112 4
	    /*
	    **	Clear out attributes.
	    */
#ifdef USE_PSRC
d3126 4
d3134 3
a3136 5
#if !OPT1
		int i;
		for (i = 0; i < context->current_tag->number_of_attributes; i++)
		    context->present[i] = NO;
#else
a3138 1
#endif
d3143 1
a3143 1
#ifdef USE_PSRC
d3145 9
a3153 9
		if (c == '>') {
		    if (t != context->unknown_tag)
			PSRCSTOP(tag);
		    else
			PSRCSTOP(badtag);
		    PSRCSTART(abracket);
		    PUTC('>');
		    PSRCSTOP(abracket);
		    context->state = S_text;
d3155 2
d3161 1
a3161 1
	    if (c == '>') {
d3164 2
a3165 1
		context->state = S_text;
d3211 1
a3211 1
#ifdef USE_PSRC
d3280 1
a3280 1
#ifdef USE_PSRC
d3284 1
a3284 1
		    PUTS(string->data);
d3296 1
a3296 2
	    HTChunkPutc(string, c);
	    break;
d3321 8
a3328 8
#ifdef USE_PSRC
		if (psrc_view) {
		    PSRCSTART(comm);
		    PUTC('<');
		    PUTS(string->data);
		    PUTC('>');
		    PSRCSTOP(comm);
		} else
d3330 1
a3330 1
	    handle_comment(context);
d3338 1
a3338 1
	if (context->end_comment && !isspace(c))
d3340 24
a3363 1
	HTChunkPutc(string, c);
d3380 1
a3380 1
#ifdef USE_PSRC
d3412 1
a3412 1
#ifdef USE_PSRC
d3446 1
a3446 1
#ifdef USE_PSRC
d3483 1
a3483 1
#ifdef USE_PSRC
d3520 1
a3520 1
#ifdef USE_PSRC
d3544 1
a3544 1
#ifdef USE_PSRC
d3549 1
a3549 1
#ifdef USE_PSRC
a3550 4
		if (context->current_tag != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d3568 1
a3568 1
#ifdef USE_PSRC
d3578 2
a3579 2
#ifdef USE_PSRC
	    }  else {
d3592 5
a3596 7
		if (c == '=' || c == '>') {
		    if (c == '=' ) PUTC('=');
		    if (context->current_attribute_number == INVALID)
			PSRCSTOP(badattr);
		    else
			PSRCSTOP(attrib);
		}
a3597 4
		    if (context->current_tag != context->unknown_tag)
			PSRCSTOP(tag);
		    else
			PSRCSTOP(badtag);
d3617 1
a3617 1
#ifdef USE_PSRC
d3619 1
a3619 1
		if (context->current_attribute_number == INVALID)
d3621 1
a3621 1
		else
d3623 1
a3623 4
		if (context->current_tag != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d3627 1
a3627 1
	} else
d3634 1
a3634 1
#ifdef USE_PSRC
d3637 1
a3637 1
		if (context->current_attribute_number == INVALID)
d3639 1
a3639 1
		else
d3641 1
a3646 7
#ifdef USE_PSRC
	/* we are here because this char seemed the beginning of attrname */
	if (psrc_view && context->current_attribute_number == INVALID) {
	    PSRCSTOP(badattr);
	    PUTC(' ');
	}
#endif
d3655 2
a3656 2
	    CTRACE(tfp, "SGML: found = but no value\n");
#ifdef USE_PSRC
a3657 4
		if (context->current_tag != context->unknown_tag)
		    PSRCSTOP(tag);
		else
		    PSRCSTOP(badtag);
d3669 1
a3669 1
#ifdef USE_PSRC
d3679 1
a3679 1
#ifdef USE_PSRC
d3688 1
a3688 1
#ifdef USE_PSRC
d3693 1
a3693 1
	/*  no break!  fall through to S_value and proccess current `c`	 */
d3698 1
a3698 1
#ifdef USE_PSRC
d3701 1
a3701 1
		if (cur_attr_is_name) {
d3707 1
a3707 1
		} else if (cur_attr_is_href) {
d3712 1
a3712 1
		if (cur_attr_is_href) {
d3722 11
d3736 1
a3736 1
#ifdef USE_PSRC
a3737 4
		    if (context->current_tag != context->unknown_tag)
			PSRCSTOP(tag);
		    else
			PSRCSTOP(badtag);
d3759 1
a3759 1
		(unsigned char)saved_char_in >=
d3762 1
a3762 1
				   (0xf000 | (unsigned char)saved_char_in));
d3776 1
a3776 1
#ifdef USE_PSRC
d3779 1
a3779 1
		if (cur_attr_is_name) {
d3785 1
a3785 1
		} else if (cur_attr_is_href) {
d3790 1
a3790 1
		if (cur_attr_is_href) {
d3821 1
a3821 1
		(unsigned char)saved_char_in >=
d3824 1
a3824 1
				   (0xf000 | (unsigned char)saved_char_in));
d3840 1
a3840 1
#ifdef USE_PSRC
d3843 1
a3843 1
		if (cur_attr_is_name) {
d3849 1
a3849 1
		} else if (cur_attr_is_href) {
d3854 1
a3854 1
		if (cur_attr_is_href) {
d3888 1
a3888 1
		(unsigned char)saved_char_in >=
d3891 1
a3891 1
				   (0xf000 | (unsigned char)saved_char_in));
d3903 2
a3904 1
	if (TOASCII(unsign_c) < 127 && isalnum((unsigned char)c)) {  /* S/390 -- gil -- 1247 */
d3908 1
a3908 1
#ifdef USE_PSRC
d3920 2
a3921 2
		CTRACE(tfp, "Unknown end tag </%s>\n", string->data);
#ifdef USE_PSRC
d3934 7
a3940 2
		    PUTS(string->data); PSRCSTOP(badtag);
		    PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
d3946 1
a3946 1
		BOOL tag_OK = (c == '>' || WHITE(c));
d3948 1
a3948 1
		HTMLElement e = context->current_tag - context->dtd->tags;
d3952 4
d3957 1
d3959 1
a3959 3
		if (tag_OK && Old_DTD) {
#else
		if (tag_OK) {
d3961 1
d3974 2
a3988 2

#if !OPT
d3990 3
d4003 1
a4003 3
		     !strcasecomp(string->data, "COLGROUP"))) {
#else
		if (tag_OK && branch == 0) {
d4005 1
d4010 2
a4011 2
		    CTRACE(tfp, "SGML: `</%s%c' found!  ***Ignoring it.\n",
				string->data, c);
d4017 1
a4020 1
#if !OPT
d4022 3
d4036 1
a4036 3
			    !strcasecomp(string->data, "U"))) {
#else
		} else if (tag_OK && branch == 1) {
d4038 1
d4054 2
a4055 2
			    CTRACE(tfp, "SGML: ***Ignoring end tag </%s> in SELECT block.\n",
					string->data);
d4061 2
a4062 2
			    CTRACE(tfp, "SGML: ***Faking SELECT end tag before </%s> end tag.\n",
					string->data);
d4065 1
a4065 1
			    CTRACE(tfp, "SGML: End </%s>\n", string->data);
d4067 3
d4072 1
a4072 1
				 (context->current_tag - context->dtd->tags),
d4080 2
a4081 2
			CTRACE(tfp, "SGML: `</%s%c' found!  ***Treating as '<%s%c'.\n",
				    string->data, c, string->data, c);
d4093 1
a4093 1
			CTRACE(tfp, "SGML: End </%s>\n", string->data);
d4095 3
d4100 1
a4100 1
			     (context->current_tag - context->dtd->tags),
d4108 1
d4120 1
a4120 1
#ifdef USE_PSRC
d4134 1
a4134 1
		if ( c != '>' )
d4136 2
a4137 1
		else {
d4149 1
a4149 1
		    CTRACE(tfp,"SGML: `</%s%c' found!\n", string->data, c);
d4152 1
d4204 2
d4303 1
d4305 1
a4305 1
#ifdef USE_PSRC
d4307 3
a4309 1
		PSRCSTOP(badtag);
d4313 1
a4313 1
		seen_letter_in_junk_tag = FALSE;
d4316 1
d4319 1
a4319 1
#ifdef USE_PSRC
d4322 1
a4322 1
	    if (!seen_letter_in_junk_tag) {
d4324 1
a4324 1
		    seen_letter_in_junk_tag = TRUE;
d4326 1
a4326 1
		};
d4329 1
a4329 1
	};
d4333 25
d4374 3
a4376 2
    **	Check whether an external function has added
    **	anything to the include buffer. - FM
d4378 3
a4380 3
    if (context->include != NULL) {
	if (context->include[context->include_index] == '\0') {
	    FREE(context->include);
d4383 27
a4409 3
	    c = context->include[context->include_index];
	    context->include_index++;
	    goto top;
d4493 2
d4496 1
d4499 1
d4537 1
d4543 1
a4543 1
#ifdef USE_PSRC
d4546 3
a4548 2
	SGML_string(context, "<HTML><HEAD><TITLE>source</TITLE></HEAD>"
			     "<BODY><PRE>") ;
d4552 1
a4552 1
	seen_letter_in_junk_tag = FALSE;
d4670 15
d4690 2
a4691 2
    HI -= (HI <= 0x9F) ? 0x71 : 0xB1;
    HI = (HI << 1) + 1;
d4695 1
a4695 1
	LO -= 0x7D;
d4698 1
a4698 1
	LO -= 0x1F;
d4711 1
a4711 1
	LO += 0x1F;
d4713 1
a4713 1
	LO += 0x7D;
d4717 1
a4717 1
    HI = ((HI - 0x21) >> 1) + 0x81;
d4719 1
a4719 1
	HI += 0x40;
d4730 3
a4732 2
    if (HI == 0x8E) JISx0201TO0208_EUC(HI, LO, &HI, &LO);
    JIS_TO_SJIS1(HI&0x7F, LO&0x7F, SJCODE);
d4743 2
a4744 2
    JISx0201TO0208_EUC(216, I, OHI, OLO);
    JIS_TO_SJIS1(*OHI&0x7F, *OLO&0x7F, SJCODE);
d4767 2
a4768 1
    for (sp = src, dp = dst; (0 != (hi = sp[0]));) {
d4771 1
a4771 1
	    SJIS_TO_JIS1(hi,lo,dp);
d4776 1
a4776 1
	} else {
a4777 1
	}
d4792 1
a4792 1
		JIS_TO_SJIS1(sp[0]&0x7F, sp[1]&0x7F, dp);
d4806 3
a4808 1
PUBLIC unsigned char * EUC_TO_JIS ARGS4(
d4818 1
a4818 1
    register int i;
d4820 1
a4820 1
    while (0 != (cch = *sp++)) {
d4822 7
d4830 2
a4831 4
		kana_mode = ~kana_mode;
		for (i = 0; toK[i]; i++) {
		    *dp++ = (unsigned char)toK[i];
		}
d4834 2
a4835 2
		*dp++ = cch & ~0x80;
		*dp++ = *sp++ & ~0x80;
d4839 2
a4840 5
		kana_mode = ~kana_mode;
		for (i = 0; toA[i]; i++) {
		    *dp++ = (unsigned char)toA[i];
		    *dp = '\0';
		}
d4845 2
a4846 5
    if (kana_mode) {
	for (i = 0; toA[i]; i++) {
	    *dp++ = (unsigned char)toA[i];
	}
    }
d4853 32
a4884 1
PUBLIC unsigned char * TO_EUC ARGS2(
d4889 2
a4890 1
    register unsigned char *d, c, jis_stat;
d4893 3
d4897 2
d4904 2
d4907 15
a4921 1
    while (0 != (c = *s++)) {
d4924 1
a4924 1
		if ((s[1] == 'B') || (s[1] == '@@') || (s[1] == 'A')) {
d4927 1
d4929 6
a4934 3
		} else if ((s[1] == '(') && s[2] && (s[2] == 'C')) {
		    jis_stat = 0x80;
		    s += 3;
d4937 2
a4938 9
	    } else {
		if (*s == to1B) {
		    if ((s[1]=='B') || (s[1]=='J') ||
			(s[1]=='H') || (s[1]=='T')) {
			jis_stat = 0;
			s += 2;
			continue;
		    }
		}
d4941 4
a4944 1
	if (IS_SJIS(c,*s,in_sjis)) {
d4948 13
d4962 1
a4962 2
	    if (jis_stat && (0x20 < c)) {
		*d++ = jis_stat | c;
d4972 24
d5002 3
a5004 5
    if (!any || !sjis)
	return;

    euc = (unsigned char*)malloc(strlen((CONST char *)any)+1);
    if (euc == NULL)
d5006 1
a5006 1

d5008 5
a5012 2
    EUC_TO_SJIS(euc, sjis);
    FREE(euc);
d5021 2
a5022 1
    if (!any || !jis)
d5024 4
a5027 3

    euc = (unsigned char*)malloc(strlen((CONST char *)any)+1);
    if (euc == NULL)
d5029 1
a5029 1

d5031 1
d5033 2
a5034 1
    FREE(euc);
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
**	This module implements an HTStream object. To parse an
**	SGML file, create this object which is a parser. The object
d7 1
a7 1
**	and a target HTStructured oject at which to throw the parsed stuff.
d9 1
a9 1
**	 6 Feb 93  Binary seraches used. Intreface modified.
d12 1
a12 2
#include "HTUtils.h"
#include "tcp.h"		/* For FROMASCII */
d21 13
a33 10
#include "SGML.h"
#include "HTMLDTD.h"
#include "HTCJK.h"
#include "UCMap.h"
#include "UCDefs.h"
#include "UCAux.h"

#include <ctype.h>
/*#include <stdio.h> included in HTUtils.h -- FM */
#include "HTChunk.h"
d35 6
a40 2
#include "LYCharSets.h"
#include "LYLeaks.h"
d44 20
a63 1
#define FREE(x) if (x) {free(x); x = NULL;}
d65 32
a96 1
PUBLIC HTCJKlang HTCJK = NOCJK; 	/* CJK enum value.		*/
d102 1
a102 1
extern int LYlowest_eightbit[];
d115 1
a115 1
**	This allows us to return down the stack reselcting styles.
d133 1
a133 1
    HTStructuredClass		*actions;	/* target class  */
d137 1
a137 1
    CONST HTTag 		*unknown_tag;
d139 1
a139 1
    int 			current_attribute_number;
d148 1
a148 1
		S_esc,	  S_dollar,    S_paren,    S_nonascii_text,
d171 3
a173 3
    int 			inUCLYhndl;	/* charset we are fed	    */
    LYUCcharset *		outUCI; 	/* anchor UCInfo for target */
    int 			outUCLYhndl;	/* charset for target	    */
d179 1
a179 1
    int 			current_tag_charset; /* charset to pass attributes */
d182 1
a182 1
    int 			recover_index;
d184 1
a184 1
    int 			include_index;
d187 1
a187 1
    int 			csi_index;
d190 44
d272 1
a272 1
						   UCT_STAGE_STRUCTURED);
d274 1
a274 1
						      UCT_STAGE_STRUCTURED);
d303 1
a303 1
	context->current_tag_charset = 0;
d345 2
a346 3
#include "AttrList.h"
extern char class_string[TEMPSTRINGSIZE];
int current_is_class=0;
d363 6
d373 4
d390 3
d396 17
a412 3
	    current_is_class=(!strcasecomp("class", s));
	    if (TRACE)
		fprintf(stderr, "SGML: found attribute %s, %d\n", s, current_is_class);
d419 2
a420 3
    if (TRACE)
	fprintf(stderr, "SGML: Unknown attribute %s for tag %s\n",
	    s, context->current_tag->name);
d438 1
a438 2
	    if (TRACE)
		fprintf(stderr, "SGML: class is '%s'\n", s);
d442 1
a442 2
	    if (TRACE)
		fprintf(stderr, "SGML: attribute value is '%s'\n", s);
d446 1
a446 2
	if (TRACE)
	    fprintf(stderr, "SGML: Attribute value %s ignored\n", s);
d456 1
a456 1
**  Additional issue, like handling bidirectional text if nesseccery
d458 2
a459 1
**  - currently they are passed to def7_uni.tbl as regular characters.
d466 1
a466 1
    if (code == 160) {
d470 3
d474 1
a474 1
    } else  if (code == 173) {
d478 3
d482 1
a482 1
    } else if (code == 8194 || code == 8195 || code == 8201) {
d484 1
a484 1
	**  Use Lynx special character for ensp, emsp or thinsp.
d491 3
a493 6
	**  HT_EM_SPACE we override the chartrans tables for those spaces
	**  (e.g., emsp= double space) with a single '32' for all (but do line
	**  wrapping more fancy).  In the future we need HT_SPACE with a
	**  transferred parameter (Unicode number) which falls back to
	**  chartrans if line wrapping is not the case.
	**
d495 5
a499 3
	PUTC(HT_EM_SPACE);
#ifdef NOTUSED_FOTEMODS
    } else if (code == 8211 || code == 8212) {
d501 1
a501 1
	**  Use ASCII hyphen for ndash/endash or mdash/emdash.
d503 7
a509 1
	PUTC('-');
a539 5
#define IncludesLatin1Enc \
		(context->outUCLYhndl == 0 || \
		 (context->outUCI && \
		  (context->outUCI->enc & (UCT_CP_SUPERSETOF_LAT1))))

d545 1
a545 1
    long uck;
a547 3
#ifdef NOTUSED_FOTEMODS
    int high, low, i, diff;
#endif
d560 10
d577 1
d581 7
d599 10
d617 1
d622 15
d641 11
d656 1
a656 1
#ifdef NOTUSED_FOTEMODS
d658 3
a660 4
	**  If the value is greater than 255 and we do not
	**  have the "7-bit approximations" as our output
	**  character set (in which case we did it already)
	**  seek a translation for that. - FM
d662 13
a674 22
	if ((chk = ((code > 255) &&
		    context->outUCLYhndl !=
				   UCGetLYhndl_byMIME("us-ascii"))) &&
	    (uck = UCTransUniChar(code,
				   UCGetLYhndl_byMIME("us-ascii")))>= 32 &&
	    uck < 127) {
	    /*
	    **	Got an ASCII character (yippey). - FM
	    */
	    PUTC(((char)(uck & 0xff)));
	    FoundEntity = TRUE;
	    return;
	} else if ((chk && uck == -4) &&
		   (uck = UCTransUniCharStr(replace_buf,
					    60, code,
					    UCGetLYhndl_byMIME("us-ascii"),
					    0) >= 0)) {
	    /*
	    **	Got a replacement string (yippey). - FM
	    */
	    for (p = replace_buf; *p; p++)
		PUTC(*p);
d678 14
a691 39
    }
    /*
    **	Ignore zwnj (8204) and zwj (8205), if we get to here.
    **	Note that zwnj may have been handled as <WBR>
    **	by the calling function. - FM
    */
    if (!strcmp(s, "zwnj") ||
	!strcmp(s, "zwj")) {
	if (TRACE) {
	    fprintf(stderr, "handle_entity: Ignoring '%s'.\n", s);
	}
	FoundEntity = TRUE;
	return;
    }

    /*
    **	Ignore lrm (8206), and rln (8207), if we get to here. - FM
    */
    if (!strcmp(s, "lrm") ||
	!strcmp(s, "rlm")) {
	if (TRACE) {
	    fprintf(stderr, "handle_entity: Ignoring '%s'.\n", s);
	}
	FoundEntity = TRUE;
	return;
    }

    /*
    **	We haven't succeeded yet, so try the old LYCharSets
    **	arrays for translation strings. - FM
    */
    for (low = 0, high = context->dtd->number_of_entities;
	 high > low;
	 diff < 0 ? (low = i+1) : (high = i)) {  /* Binary search */
	i = (low + (high-low)/2);
	diff = strcmp(entities[i], s);	/* Case sensitive! */
	if (diff == 0) {		/* success: found it */
	    for (p = LYCharSets[context->outUCLYhndl][i]; *p; p++) {
		PUTC(*p);
d693 1
a696 1
#endif
d702 5
a706 2
    if (TRACE)
	fprintf(stderr, "SGML: Unknown entity '%s'\n", s);
d713 4
d728 1
a728 2
    if (TRACE)
	fprintf(stderr, "SGML Comment:\n<%s>\n", s);
d734 2
d750 1
a750 2
    if (TRACE)
	fprintf(stderr, "SGML Identifier\n<%s>\n", s);
d764 1
a764 2
    if (TRACE)
	fprintf(stderr, "SGML Doctype\n<%s>\n", s);
d778 1
a778 2
    if (TRACE)
	fprintf(stderr, "SGML Marked Section:\n<%s>\n", s);
d792 1
a792 2
    if (TRACE)
	fprintf(stderr, "SGML Entity Declaration:\n<%s>\n", s);
d806 1
a806 2
    if (TRACE)
	fprintf(stderr, "SGML Element Declaration:\n<%s>\n", s);
d820 1
a820 2
    if (TRACE)
	fprintf(stderr, "SGML Attribute Declaration:\n<%s>\n", s);
d845 1
a845 1
extern BOOL New_DTD;
d867 1
d873 1
a873 1
	return; 		/* stack was empty */
d884 1
d912 1
a912 1
    if (New_DTD) {
d918 1
a918 2
		if (TRACE)
		    fprintf(stderr, "SGML: End </%s> \t<- %s end </%s>\n",
d920 1
a920 1
			    canclose_check == close_valid ? "supplied," : "forced by",
d926 1
a926 2
		if (TRACE)
		    fprintf(stderr, "SGML: Still open %s \t<- invalid end </%s>\n",
d934 1
a934 2
	    if (TRACE)
		fprintf(stderr, "SGML: Still open %s, no open %s for </%s>\n",
d942 1
a942 2
	    if (TRACE)
		fprintf(stderr, "SGML: Nesting <%s>...<%s> \t<- invalid end </%s>\n",
d967 1
a967 3
	    if (TRACE) {
		fprintf(stderr,
			"SGML: Ignoring end tag </%s> in SELECT block.\n",
a968 1
	    }
d975 1
a975 2
    if (TRACE)
	fprintf(stderr, "SGML: End </%s>\n", old_tag->name);
d977 2
a978 3
	if (TRACE)
	    fprintf(stderr, "SGML: Illegal end tag </%s> found.\n",
			    old_tag->name);
d982 1
a982 1
    while (context->element_stack) { /* Loop is error path only */
d984 1
a984 1
    if (context->element_stack) { /* Substitute and remove one stack element */
d986 1
d992 2
a993 3
		if (TRACE) fprintf(stderr,
		"SGML: Found </%s> when expecting </%s>. </%s> assumed.\n",
		    old_tag->name, t->name, t->name);
d995 3
a997 4
		if (TRACE) fprintf(stderr,
		    "SGML: Found </%s> when expecting </%s>. </%s> Ignored.\n",
		    old_tag->name, t->name, old_tag->name);
		return; 		/* Ignore */
d1015 2
a1016 3
    if (TRACE)
	fprintf(stderr, "SGML: Extra end tag </%s> found and ignored.\n",
			old_tag->name);
d1026 4
d1038 1
a1038 1
    if (New_DTD) {
d1047 1
a1047 2
		if (TRACE)
		    fprintf(stderr, "SGML: End </%s> \t<- %s start <%s>\n",
d1049 1
a1049 1
			    canclose_check == close_valid ? "supplied," : "forced by",
d1056 1
a1056 2
		if (TRACE)
		    fprintf(stderr, "SGML: Still open %s \t<- invalid start <%s>\n",
d1065 1
a1065 2
	    if (TRACE)
		fprintf(stderr, "SGML: Still open %s \t<- ignoring start <%s>\n",
d1078 1
a1078 2
		if (TRACE)
		    fprintf(stderr, "SGML: Still open %s, converting invalid <%s> to </%s>\n",
d1093 1
a1093 2
	    if (TRACE)
		fprintf(stderr, "SGML: Still open %s \t<- invalid start <%s>\n",
d1127 1
d1136 12
d1152 1
a1152 3
		if (TRACE)
		    fprintf(stderr,
		       "SGML: Faking SELECT end tag before <%s> start tag.\n",
d1159 1
a1159 3
		if (TRACE)
		    fprintf(stderr,
			  "SGML: Ignoring start tag <%s> in SELECT block.\n",
d1168 1
a1168 2
    if (TRACE)
	fprintf(stderr, "SGML: Start <%s>\n", new_tag->name);
d1176 1
a1176 1
    if (new_tag->contents != SGML_EMPTY) {		/* i.e. tag not empty */
d1183 1
d1185 3
d1200 1
a1200 1
**	dtd	points to dtd structire including valid tag list
d1213 1
d1216 1
a1216 1
	 diff < 0 ? (low = i+1) : (high = i)) {  /* Binary search */
d1218 1
a1218 1
	diff = strcasecomp(dtd->tags[i].name, string);	/* Case insensitive */
d1227 1
a1227 1
	return (HTTag *)&HTTag_unrecognized;
d1280 4
d1322 5
d1362 1
a1362 1
    UCode_t clong, uck; /* Enough bits for UCS4 ... */
d1382 1
a1382 1
	if ((unsigned char)c > 127) {
d1386 2
a1387 2
	    if (context->utf_count > 0 && (c & 0xc0) == 0x80) {
		context->utf_char = (context->utf_char << 6) | (c & 0x3f);
d1453 1
a1453 1
    }
d1471 2
a1472 2
	((unsign_c >= 127) ||
	 (unsign_c < 32 && unsign_c != 0 &&
d1485 1
a1485 1
    } else if (unsign_c < 32 && unsign_c != 0 &&
d1491 1
a1491 1
	    (((clong = UCTransToUni(c, context->inUCLYhndl)) >= 32) ||
d1527 1
a1527 1
    } else {
d1539 1
a1539 1
**  to process.  We zero saved_char_in, in effect
d1566 1
a1566 1
**  semi-colon).  The chararcter will already have
d1574 5
a1578 2
    if (unsign_c < 32 &&
	c != 9 && c != 10 && c != 13 &&
d1588 1
a1588 1
    if (c == 127 &&
d1596 1
a1596 1
    if (unsign_c > 127 && unsign_c < 160 &&
d1609 1
a1609 1
	**  trashing the input.  That's why 8-bit characters
d1621 1
a1621 1
	if (HTCJK != NOCJK && (c & 0200) != 0) {
d1635 1
a1635 1
	} else if (HTCJK != NOCJK && c == '\033') {
d1644 1
a1644 1
	if (c == '&' && unsign_c < 127	&&
d1648 1
d1656 1
a1656 1
	} else if (c == '<' && unsign_c < 127) {
d1671 1
a1671 1
	} else if (unsign_c == 160 &&
d1678 1
a1678 1
	} else if (unsign_c == 173 &&
d1694 1
a1694 1
 *   I. LATIN-1 OR UCS2  TO  DISPLAY CHARSET
d1696 1
a1696 1
	} else if ((chk = (context->T.trans_from_uni && unsign_c >= 160)) &&
d1698 1
a1698 1
					 context->outUCLYhndl)) >= 32 &&
d1700 1
a1700 3
	    if (TRACE) {
		fprintf(stderr,
			"UCTransUniChar returned 0x%.2lX:'%c'.\n",
a1701 1
	    }
d1718 1
a1718 1
	    **	No further tests for valididy - assume that whoever
d1729 1
a1729 1
	**  If it's any other (> 160) 8-bit chararcter, and
d1734 5
d1741 1
d1746 3
d1755 6
d1762 6
d1775 1
a1775 1
	} else if (unsign_c < 127 && unsign_c > 0) {
d1807 1
a1807 1
	} else if ((unsigned char)c <
d1821 1
a1821 1
				      >= 32 && uck < 127) {
d1825 1
a1825 1
		PUTC(((char)(uck & 0xff)));
d1837 1
d1841 3
a1843 2
#endif /* NOTUSED_FOTEMODS */
		sprintf(replace_buf, "U%.2lX", unsign_c);
d1847 1
d1863 1
a1863 1
    case S_litteral:
d1885 1
a1885 1
	    for (i = 0; i < string->size; i++)	/* recover */
d1889 1
d1910 1
a1910 1
	if (unsign_c < 127 && (string->size ?
d1921 4
d1926 4
d1937 5
d1951 2
a1952 4
		if (TRACE) {
		    fprintf(stderr,
		"SGML_character: Handling 'zwnj' entity as 'WBR' element.\n");
		}
d1978 7
d1994 1
a1994 1
	if (unsign_c < 127 && TOLOWER((unsigned char)c) == 'x') {
d1997 1
a1997 1
	} else if (unsign_c < 127 && isdigit((unsigned char)c)) {
d2009 4
d2015 4
d2028 3
a2030 1
	if ((unsign_c < 127) &&
d2042 4
d2049 4
d2063 3
d2068 1
d2070 1
a2070 1
		    (code > 129 && code < 156)) {
d2086 6
d2216 2
a2217 4
		    if (TRACE) {
			fprintf(stderr,
      "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n");
		    }
d2246 10
d2271 3
d2275 9
d2293 9
d2322 1
a2322 1
				  >= 32 && uck < 127) {
d2326 11
a2336 1
		    PUTC(((char)(uck & 0xff)));
d2345 9
d2356 1
d2369 1
a2369 1
			fprintf(stderr,
d2374 10
a2389 1
#endif /* NOTUSED_FOTEMODS */
d2404 2
a2405 2
			   (code < 32 &&
			    code != 9 && code != 10 && code != 13 &&
d2407 1
a2407 1
			   (code == 127 &&
d2409 1
a2409 1
			   (code > 127 && code < 160 &&
d2412 1
a2412 1
			**  Unhandled or illegal value.  Recover the
d2416 5
d2430 5
d2439 1
a2439 1
		} else if (code < 161 ||
d2445 9
d2479 4
d2492 4
d2525 4
d2531 4
d2556 2
a2557 2
    case S_tag: 				/* new tag */
	if (unsign_c < 127 && (string->size ?
d2575 1
a2575 1
		   (unsign_c <= 160 &&
d2586 4
d2591 4
d2602 2
a2603 3
		if (TRACE)
		    if (string->size!=0)
			fprintf(stderr,"SGML: `<%s/' found!\n", string->data);
d2617 4
d2625 5
a2629 2
		if (TRACE)
		    fprintf(stderr, "SGML: Treating <%s%c as text\n",
d2635 1
a2635 2
		if (TRACE)
		    fprintf(stderr, "SGML: *** Invalid element %s\n",
d2637 19
d2659 1
a2659 2
		if (TRACE)
		    fprintf(stderr, "SGML: *** Unknown element %s\n",
d2665 1
d2672 17
d2690 1
d2694 4
d2699 1
d2702 16
a2717 1

d2767 9
d2836 9
d2878 9
d2914 9
d2946 9
d2980 9
d3017 9
d3054 9
d3077 4
a3080 1
	if (c == '>') { 	/* End of tag */
d3083 11
d3106 3
d3116 35
d3160 16
a3175 1
	if (c == '>') { 	/* End of tag */
d3181 9
d3193 7
d3201 1
a3201 1
	context->state = S_attr;		/* Get next attribute */
d3207 13
a3219 3
	if (c == '>') { 	/* End of tag */
	    if (TRACE)
		fprintf(stderr, "SGML: found = but no value\n");
d3226 6
d3236 6
d3245 4
a3248 1
	HTChunkPutc(string, c);
d3250 1
a3250 1
	break;
d3255 24
d3282 11
d3326 25
d3354 1
a3354 1
	} else if (c == '\033') {
d3386 1
a3386 1
	if (c == '"' || 	/* Valid end of attribute value */
d3390 26
d3421 1
a3421 1
	} else if (c == '\033') {
d3452 2
a3453 2
    case S_end: 				/* </ */
	if (unsign_c < 127 && isalnum((unsigned char)c)) {
d3457 3
d3469 20
a3488 2
		if (TRACE)
		    fprintf(stderr, "Unknown end tag </%s>\n", string->data);
d3491 4
d3496 22
d3522 1
a3522 1
		if (New_DTD) {
d3526 3
d3541 3
d3548 1
a3548 3
		    if (TRACE)
			fprintf(stderr,
				"SGML: `</%s%c' found!  Ignoring it.\n",
d3558 1
d3572 3
d3590 1
a3590 3
			    if (TRACE) {
				fprintf(stderr,
			    "SGML: Ignoring end tag </%s> in SELECT block.\n",
a3591 1
			    }
d3597 1
a3597 3
			    if (TRACE) {
				fprintf(stderr,
			"SGML: Faking SELECT end tag before </%s> end tag.\n",
a3598 1
			    }
d3601 2
a3602 4
			    if (TRACE) {
				fprintf(stderr,
					"SGML: End </%s>\n", string->data);
			    }
d3613 1
a3613 3
			if (TRACE)
			    fprintf(stderr,
				    "SGML: `</%s%c' found!  Treating as '<%s%c'.\n",
d3626 2
a3627 4
			if (TRACE) {
			    fprintf(stderr,
				    "SGML: End </%s>\n", string->data);
			}
d3649 24
d3676 2
a3677 2
		if (TRACE && !WHITE(c))
		    fprintf(stderr,"SGML: `</%s%c' found!\n", string->data, c);
d3686 1
a3686 1
    case S_esc: 	/* Expecting '$'or '(' following CJK ESC. */
d3727 1
a3727 1
	if (c == '\033') {
d3774 1
a3774 1
	if (c == '\033') {
d3821 1
a3821 1
	if (c == '\033') {
d3829 9
d3840 13
d3943 1
a3943 1
**	actions 	is the sink for the data as a set of routines.
d3950 1
a3950 1
	HTStructured *, 	target)
d3961 1
a3961 1
    context->actions = (HTStructuredClass*)(((HTStream*)target)->isa);
d3965 1
a3965 1
    context->element_stack = 0; 		/* empty */
d4009 12
d4030 1
a4030 1
Copyright (c) 1993 Electrotechnical Laboratry (ETL)
d4045 1
a4045 1
Author: 	Yutaka Sato <ysato@@etl.go.jp>
d4055 2
a4056 2
	register unsigned char, 	IHI,
	register unsigned char, 	ILO,
d4061 63
a4123 13
	"\xA1\xA3", "\xA1\xD6", "\xA1\xD7", "\xA1\xA2", "\xA1\xA6", "\xA5\xF2",
	"\xA5\xA1", "\xA5\xA3", "\xA5\xA5", "\xA5\xA7", "\xA5\xA9",
	"\xA5\xE3", "\xA5\xE5", "\xA5\xE7", "\xA5\xC3", "\xA1\xBC",
	"\xA5\xA2", "\xA5\xA4", "\xA5\xA6", "\xA5\xA8", "\xA5\xAA",
	"\xA5\xAB", "\xA5\xAD", "\xA5\xAF", "\xA5\xB1", "\xA5\xB3",
	"\xA5\xB5", "\xA5\xB7", "\xA5\xB9", "\xA5\xBB", "\xA5\xBD",
	"\xA5\xBF", "\xA5\xC1", "\xA5\xC4", "\xA5\xC6", "\xA5\xC8",
	"\xA5\xCA", "\xA5\xCB", "\xA5\xCC", "\xA5\xCD", "\xA5\xCE",
	"\xA5\xCF", "\xA5\xD2", "\xA5\xD5", "\xA5\xD8", "\xA5\xDB",
	"\xA5\xDE", "\xA5\xDF", "\xA5\xE0", "\xA5\xE1", "\xA5\xE2",
	"\xA5\xE4", "\xA5\xE6", "\xA5\xE8", "\xA5\xE9", "\xA5\xEA",
	"\xA5\xEB", "\xA5\xEC", "\xA5\xED", "\xA5\xEF", "\xA5\xF3",
	"\xA1\xAB", "\xA1\xAC"
d4136 2
a4137 2
	register unsigned char, 	HI,
	register unsigned char, 	LO,
d4156 2
a4157 2
	register unsigned char, 	HI,
	register unsigned char, 	LO,
d4186 1
a4186 1
	register unsigned char, 	I,
d4192 1
a4192 1
    JISx0201TO0208_EUC('\x8E', I, OHI, OLO);
d4302 1
a4302 1
	unsigned char *,	jis,
d4305 2
a4306 1
    register unsigned char *s, *d, c, jis_stat;
d4356 1
a4356 1
	unsigned char *,	any,
d4362 1
a4362 1
       return;
d4374 1
a4374 1
	unsigned char *,	any,
d4380 1
a4380 1
       return;
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
