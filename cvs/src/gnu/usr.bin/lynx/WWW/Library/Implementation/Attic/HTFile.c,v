head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.08.21.04.17;	author vincent;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.07.00.04.58;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.05.16.44.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.46;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTFile.c,v 1.142 2014/02/13 18:30:01 tom Exp $
 *
 *			File Access				HTFile.c
 *			===========
 *
 *	This is unix-specific code in general, with some VMS bits.
 *	These are routines for file access used by browsers.
 *	Development of this module for Unix DIRED_SUPPORT in Lynx
 *	 regrettably has has been conducted in a manner with now
 *	 creates a major impediment for hopes of adapting Lynx to
 *	 a newer version of the library.
 *
 *  History:
 *	   Feb 91	Written Tim Berners-Lee CERN/CN
 *	   Apr 91	vms-vms access included using DECnet syntax
 *	26 Jun 92 (JFG) When running over DECnet, suppressed FTP.
 *			Fixed access bug for relative names on VMS.
 *	   Sep 93 (MD)	Access to VMS files allows sharing.
 *	15 Nov 93 (MD)	Moved HTVMSname to HTVMSUTILS.C
 *	27 Dec 93 (FM)	FTP now works with VMS hosts.
 *			FTP path must be Unix-style and cannot include
 *			the device or top directory.
 */

#include <HTUtils.h>

#ifndef VMS
#if defined(DOSPATH)
#undef LONG_LIST
#define LONG_LIST		/* Define this for long style unix listings (ls -l),
				   the actual style is configurable from lynx.cfg */
#endif
/* #define NO_PARENT_DIR_REFERENCE */
/* Define this for no parent links */
#endif /* !VMS */

#if defined(DOSPATH)
#define HAVE_READDIR 1
#define USE_DIRENT
#endif

#if defined(USE_DOS_DRIVES)
#include <HTDOS.h>
#endif

#include <HTFile.h>		/* Implemented here */

#ifdef VMS
#include <stat.h>
#endif /* VMS */

#if defined (USE_ZLIB) || defined (USE_BZLIB)
#include <GridText.h>
#endif

#define MULTI_SUFFIX ".multi"	/* Extension for scanning formats */

#include <HTParse.h>
#include <HTTCP.h>
#ifndef DECNET
#include <HTFTP.h>
#endif /* !DECNET */
#include <HTAnchor.h>
#include <HTAtom.h>
#include <HTAAProt.h>
#include <HTFWriter.h>
#include <HTInit.h>
#include <HTBTree.h>
#include <HTAlert.h>
#include <HTCJK.h>
#include <UCDefs.h>
#include <UCMap.h>
#include <UCAux.h>

#include <LYexit.h>
#include <LYCharSets.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYUtils.h>

#ifdef USE_PRETTYSRC
# include <LYPrettySrc.h>
#endif

#include <LYLeaks.h>

typedef struct _HTSuffix {
    char *suffix;
    HTAtom *rep;
    HTAtom *encoding;
    char *desc;
    float quality;
} HTSuffix;

typedef struct {
    struct stat file_info;
    char sort_tags;
    char file_name[1];		/* on the end of the struct, since its length varies */
} DIRED;

#ifndef NGROUPS
#ifdef NGROUPS_MAX
#define NGROUPS NGROUPS_MAX
#else
#define NGROUPS 32
#endif /* NGROUPS_MAX */
#endif /* NGROUPS */

#ifndef GETGROUPS_T
#define GETGROUPS_T int
#endif

#include <HTML.h>		/* For directory object building */

#define PUTC(c)      (*target->isa->put_character)(target, c)
#define PUTS(s)      (*target->isa->put_string)(target, s)
#define START(e)     (*target->isa->start_element)(target, e, 0, 0, -1, 0)
#define END(e)       (*target->isa->end_element)(target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*target->isa->end_element)(target, e, 0)
#define FREE_TARGET  (*target->isa->_free)(target)
#define ABORT_TARGET (*targetClass._abort)(target, NULL);

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

/*
 *  Controlling globals.
 */
int HTDirAccess = HT_DIR_OK;

#ifdef DIRED_SUPPORT
int HTDirReadme = HT_DIR_README_NONE;

#else
int HTDirReadme = HT_DIR_README_TOP;
#endif /* DIRED_SUPPORT */

static const char *HTMountRoot = "/Net/";	/* Where to find mounts */

#ifdef VMS
static const char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */

#else
static const char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
#endif /* VMS */

static char s_no_suffix[] = "*";
static char s_unknown_suffix[] = "*.*";

/*
 *  Suffix registration.
 */
static HTList *HTSuffixes = 0;

static HTSuffix no_suffix =
{
    s_no_suffix, NULL, NULL, NULL, 1.0
};

static HTSuffix unknown_suffix =
{
    s_unknown_suffix, NULL, NULL, NULL, 1.0
};

/*	To free up the suffixes at program exit.
 *	----------------------------------------
 */
#ifdef LY_FIND_LEAKS
static void free_suffixes(void);
#endif

static char *FindSearch(const char *filename)
{
    char *result = 0;

    if ((result = strchr(filename, '?')) == 0) {
	result = strstr(filename, "%3F");
    }
    return result;
}

#ifdef LONG_LIST
static char *FormatStr(char **bufp,
		       char *start,
		       const char *entry)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*ss", (int) sizeof(fmt) - 3, start);
	HTSprintf0(bufp, fmt, entry);
    } else if (*bufp && !(entry && *entry)) {
	**bufp = '\0';
    } else if (entry) {
	StrAllocCopy(*bufp, entry);
    }
    return *bufp;
}

static char *FormatSize(char **bufp,
			char *start,
			off_t entry)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*s" PRI_off_t, (int) sizeof(fmt) - 3, start);

	HTSprintf0(bufp, fmt, entry);
    } else {
	sprintf(fmt, "%" PRI_off_t, entry);

	StrAllocCopy(*bufp, fmt);
    }
    return *bufp;
}

static char *FormatNum(char **bufp,
		       char *start,
		       int entry)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*sd", (int) sizeof(fmt) - 3, start);
	HTSprintf0(bufp, fmt, entry);
    } else {
	sprintf(fmt, "%d", entry);
	StrAllocCopy(*bufp, fmt);
    }
    return *bufp;
}

static void LYListFmtParse(const char *fmtstr,
			   DIRED * data,
			   char *file,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    char tmp[LY_MAXPATH];
    char type;

#ifndef NOUSERS
    const char *name;
#endif
    time_t now;
    char *datestr;

#ifdef S_IFLNK
    int len;
#endif
#define SEC_PER_YEAR	(60 * 60 * 24 * 365)

#ifdef _WINDOWS			/* 1998/01/06 (Tue) 21:20:53 */
    static const char *pbits[] =
    {
	"---", "--x", "-w-", "-wx",
	"r--", "r-x", "rw-", "rwx",
	0};

#define PBIT(a, n, s)  pbits[((a) >> (n)) & 0x7]

#else
    static const char *pbits[] =
    {"---", "--x", "-w-", "-wx",
     "r--", "r-x", "rw-", "rwx", 0};
    static const char *psbits[] =
    {"--S", "--s", "-wS", "-ws",
     "r-S", "r-s", "rwS", "rws", 0};

#define PBIT(a, n, s)  (s) ? psbits[((a) >> (n)) & 0x7] : \
	pbits[((a) >> (n)) & 0x7]
#endif
#if defined(S_ISVTX) && !defined(_WINDOWS)
    static const char *ptbits[] =
    {"--T", "--t", "-wT", "-wt",
     "r-T", "r-t", "rwT", "rwt", 0};

#define PTBIT(a, s)  (s) ? ptbits[(a) & 0x7] : pbits[(a) & 0x7]
#else
#define PTBIT(a, s)  PBIT(a, 0, 0)
#endif

    if (data->file_info.st_mode == 0)
	fmtstr = "    %a";	/* can't stat so just do anchor */

    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    while (*s) {
	start = s;
	while (*s) {
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    PUTS(start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    PUTS(start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    HTDirEntry(target, tail, data->file_name);
	    FormatStr(&buf, start, data->file_name);
	    PUTS(buf);
	    END(HTML_A);
	    *buf = '\0';
#ifdef S_IFLNK
	    if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
		(len = (int) readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
		PUTS(" -> ");
		tmp[len] = '\0';
		PUTS(tmp);
	    }
#endif
	    break;

	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (S_ISDIR(data->file_info.st_mode)) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;

		format = HTFileFormat(file, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!StrNCmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!StrNCmp(cp2, "x-", 2))
				cp2 += 2;
			} else {
			    cp2 = HTAtom_name(format);
			}
		    }
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;

	case 'd':		/* date */
	    now = time(0);
	    datestr = ctime(&data->file_info.st_mtime);
	    if ((now - data->file_info.st_mtime) < SEC_PER_YEAR / 2)
		/*
		 * MMM DD HH:MM
		 */
		sprintf(tmp, "%.12s", datestr + 4);
	    else
		/*
		 * MMM DD YYYY
		 */
		sprintf(tmp, "%.7s %.4s ", datestr + 4,
			datestr + 20);
	    FormatStr(&buf, start, tmp);
	    break;

	case 's':		/* size in bytes */
	    FormatSize(&buf, start, data->file_info.st_size);
	    break;

	case 'K':		/* size in Kilobytes but not for directories */
	    if (S_ISDIR(data->file_info.st_mode)) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    FormatSize(&buf, start, ((data->file_info.st_size + 1023) / 1024));
	    StrAllocCat(buf, "K");
	    break;

	case 'p':		/* unix-style permission bits */
	    switch (data->file_info.st_mode & S_IFMT) {
#if defined(_MSC_VER) && defined(_S_IFIFO)
	    case _S_IFIFO:
		type = 'p';
		break;
#else
	    case S_IFIFO:
		type = 'p';
		break;
#endif
	    case S_IFCHR:
		type = 'c';
		break;
	    case S_IFDIR:
		type = 'd';
		break;
	    case S_IFREG:
		type = '-';
		break;
#ifdef S_IFBLK
	    case S_IFBLK:
		type = 'b';
		break;
#endif
#ifdef S_IFLNK
	    case S_IFLNK:
		type = 'l';
		break;
#endif
#ifdef S_IFSOCK
# ifdef S_IFIFO			/* some older machines (e.g., apollo) have a conflict */
#  if S_IFIFO != S_IFSOCK
	    case S_IFSOCK:
		type = 's';
		break;
#  endif
# else
	    case S_IFSOCK:
		type = 's';
		break;
# endif
#endif /* S_IFSOCK */
	    default:
		type = '?';
		break;
	    }
#ifdef _WINDOWS
	    sprintf(tmp, "%c%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
#else
	    sprintf(tmp, "%c%s%s%s", type,
		    PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
		    PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
		    PTBIT(data->file_info.st_mode, data->file_info.st_mode & S_ISVTX));
#endif
	    FormatStr(&buf, start, tmp);
	    break;

	case 'o':		/* owner */
#ifndef NOUSERS
	    name = HTAA_UidToName((int) data->file_info.st_uid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_uid);
	    }
#endif
	    break;

	case 'g':		/* group */
#ifndef NOUSERS
	    name = HTAA_GidToName((int) data->file_info.st_gid);
	    if (*name) {
		FormatStr(&buf, start, name);
	    } else {
		FormatNum(&buf, start, (int) data->file_info.st_gid);
	    }
#endif
	    break;

	case 'l':		/* link count */
	    FormatNum(&buf, start, (int) data->file_info.st_nlink);
	    break;

	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;

	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
	}
	if (buf)
	    PUTS(buf);

	s++;
    }
    FREE(buf);
    PUTC('\n');
    FREE(str);
}
#endif /* LONG_LIST */

/*	Define the representation associated with a file suffix.
 *	--------------------------------------------------------
 *
 *	Calling this with suffix set to "*" will set the default
 *	representation.
 *	Calling this with suffix set to "*.*" will set the default
 *	representation for unknown suffix files which contain a ".".
 *
 *	The encoding parameter can give a trivial (8bit, 7bit, binary)
 *	or real (gzip, compress) encoding.
 *
 *	If filename suffix is already defined with the same encoding
 *	its previous definition is overridden.
 */
void HTSetSuffix5(const char *suffix,
		  const char *representation,
		  const char *encoding,
		  const char *desc,
		  double value)
{
    HTSuffix *suff;
    BOOL trivial_enc = (BOOL) IsUnityEncStr(encoding);

    if (strcmp(suffix, s_no_suffix) == 0)
	suff = &no_suffix;
    else if (strcmp(suffix, s_unknown_suffix) == 0)
	suff = &unknown_suffix;
    else {
	HTList *cur = HTSuffixes;

	while (NULL != (suff = (HTSuffix *) HTList_nextObject(cur))) {
	    if (suff->suffix && 0 == strcmp(suff->suffix, suffix) &&
		((trivial_enc && IsUnityEnc(suff->encoding)) ||
		 (!trivial_enc && !IsUnityEnc(suff->encoding) &&
		  strcmp(encoding, HTAtom_name(suff->encoding)) == 0)))
		break;
	}
	if (!suff) {		/* Not found -- create a new node */
	    suff = typecalloc(HTSuffix);
	    if (suff == NULL)
		outofmem(__FILE__, "HTSetSuffix");

	    assert(suff != NULL);

	    if (!HTSuffixes) {
		HTSuffixes = HTList_new();
#ifdef LY_FIND_LEAKS
		atexit(free_suffixes);
#endif
	    }

	    HTList_addObject(HTSuffixes, suff);

	    StrAllocCopy(suff->suffix, suffix);
	}
    }

    if (representation)
	suff->rep = HTAtom_for(representation);

    /*
     * Memory leak fixed.
     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     * Invariant code removed.
     */
    suff->encoding = HTAtom_for(encoding);

    StrAllocCopy(suff->desc, desc);

    suff->quality = (float) value;
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free all added suffixes.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		To be used at program exit.
 *	Revision History:
 *		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_suffixes(void)
{
    HTSuffix *suff = NULL;

    /*
     * Loop through all suffixes.
     */
    while (!HTList_isEmpty(HTSuffixes)) {
	/*
	 * Free off each item and its members if need be.
	 */
	suff = (HTSuffix *) HTList_removeLastObject(HTSuffixes);
	FREE(suff->suffix);
	FREE(suff->desc);
	FREE(suff);
    }
    /*
     * Free off the list itself.
     */
    HTList_delete(HTSuffixes);
    HTSuffixes = NULL;
}
#endif /* LY_FIND_LEAKS */

/*	Make the cache file name for a W3 document.
 *	-------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	/tmp/WWW_Cache_news/1234@@cernvax.cern.ch
 *		/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTCacheFileName(const char *name)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *result = NULL;

    HTSprintf0(&result, "%s/WWW/%s/%s%s", HTCacheRoot, acc_method, host, path);

    FREE(path);
    FREE(acc_method);
    FREE(host);
    return result;
}

/*	Open a file for write, creating the path.
 *	-----------------------------------------
 */
#ifdef NOT_IMPLEMENTED
static int HTCreatePath(const char *path)
{
    return -1;
}
#endif /* NOT_IMPLEMENTED */

/*	Convert filename from URL-path syntax to local path format
 *	----------------------------------------------------------
 *	Input name is assumed to be the URL-path of a local file
 *      URL, i.e. what comes after the "file://localhost".
 *      '#'-fragments to be treated as such must already be stripped.
 *      If expand_all is FALSE, unescape only escaped '/'. - kw
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
char *HTURLPath_toFile(const char *name,
		       int expand_all,
		       int is_remote GCC_UNUSED)
{
    char *path = NULL;
    char *result = NULL;

    StrAllocCopy(path, name);
    if (expand_all)
	HTUnEscape(path);	/* Interpret all % signs */
    else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    CTRACE((tfp, "URLPath `%s' means path `%s'\n", name, path));
#if defined(USE_DOS_DRIVES)
    StrAllocCopy(result, is_remote ? path : HTDOS_name(path));
#else
    StrAllocCopy(result, path);
#endif

    FREE(path);

    return result;
}
/*	Convert filenames between local and WWW formats.
 *	------------------------------------------------
 *	Make up a suitable name for saving the node in
 *
 *	E.g.	$(HOME)/WWW/news/1234@@cernvax.cern.ch
 *		$(HOME)/WWW/http/crnvmc/FIND/xx.xxx.xx
 *
 *  On exit:
 *	Returns a malloc'ed string which must be freed by the caller.
 */
/* NOTE: Don't use this function if you know that the input is a URL path
	 rather than a full URL, use HTURLPath_toFile instead.  Otherwise
	 this function will return the wrong thing for some unusual
	 paths (like ones containing "//", possibly escaped). - kw
*/
char *HTnameOfFile_WWW(const char *name,
		       int WWW_prefix,
		       int expand_all)
{
    char *acc_method = HTParse(name, "", PARSE_ACCESS);
    char *host = HTParse(name, "", PARSE_HOST);
    char *path = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
    const char *home;
    char *result = NULL;

    if (expand_all) {
	HTUnEscape(path);	/* Interpret all % signs */
    } else
	HTUnEscapeSome(path, "/");	/* Interpret % signs for path delims */

    if (0 == strcmp(acc_method, "file")		/* local file */
	||!*acc_method) {	/* implicitly local? */
	if ((0 == strcasecomp(host, HTHostName())) ||
	    (0 == strcasecomp(host, "localhost")) || !*host) {
	    CTRACE((tfp, "Node `%s' means path `%s'\n", name, path));
	    StrAllocCopy(result, HTSYS_name(path));
	} else if (WWW_prefix) {
	    HTSprintf0(&result, "%s%s%s", "/Net/", host, path);
	    CTRACE((tfp, "Node `%s' means file `%s'\n", name, result));
	} else {
	    StrAllocCopy(result, path);
	}
    } else if (WWW_prefix) {	/* other access */
#ifdef VMS
	if ((home = LYGetEnv("HOME")) == NULL)
	    home = HTCacheRoot;
	else
	    home = HTVMS_wwwName(home);
#else
#if defined(_WINDOWS)		/* 1997/10/16 (Thu) 20:42:51 */
	home = Home_Dir();
#else
	home = LYGetEnv("HOME");
#endif
	if (home == NULL)
	    home = "/tmp";
#endif /* VMS */
	HTSprintf0(&result, "%s/WWW/%s/%s%s", home, acc_method, host, path);
    } else {
	StrAllocCopy(result, path);
    }

    FREE(host);
    FREE(path);
    FREE(acc_method);

    CTRACE((tfp, "HTnameOfFile_WWW(%s,%d,%d) = %s\n",
	    name, WWW_prefix, expand_all, result));

    return result;
}

/*	Make a WWW name from a full local path name.
 *	--------------------------------------------
 *
 *  Bugs:
 *	At present, only the names of two network root nodes are hand-coded
 *	in and valid for the NeXT only.  This should be configurable in
 *	the general case.
 */
char *WWW_nameOfFile(const char *name)
{
    char *result = NULL;

#ifdef NeXT
    if (0 == StrNCmp("/private/Net/", name, 13)) {
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 13);
    } else
#endif /* NeXT */
    if (0 == StrNCmp(HTMountRoot, name, 5)) {
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name + 5);
    } else {
	HTSprintf0(&result, "%s//%s%s", STR_FILE_URL, HTHostName(), name);
    }
    CTRACE((tfp, "File `%s'\n\tmeans node `%s'\n", name, result));
    return result;
}

/*	Determine a suitable suffix, given the representation.
 *	------------------------------------------------------
 *
 *  On entry,
 *	rep	is the atomized MIME style representation
 *	enc	is an encoding, trivial (8bit, binary, etc.) or gzip etc.
 *
 *  On exit:
 *	Returns a pointer to a suitable suffix string if one has been
 *	found, else "".
 */
const char *HTFileSuffix(HTAtom *rep,
			 const char *enc)
{
    HTSuffix *suff;

#ifdef FNAMES_8_3
    HTSuffix *first_found = NULL;
#endif
    BOOL trivial_enc;
    int n;
    int i;

#define NO_INIT			/* don't init anymore since I do it in Lynx at startup */
#ifndef NO_INIT
    if (!HTSuffixes)
	HTFileInit();
#endif /* !NO_INIT */

    trivial_enc = (BOOL) IsUnityEncStr(enc);
    n = HTList_count(HTSuffixes);
    for (i = 0; i < n; i++) {
	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
	if (suff->rep == rep &&
#if defined(VMS) || defined(FNAMES_8_3)
	/*  Don't return a suffix whose first char is a dot, and which
	   has more dots or asterisks after that, for
	   these systems - kw */
	    (!suff->suffix || !suff->suffix[0] || suff->suffix[0] != '.' ||
	     (StrChr(suff->suffix + 1, '.') == NULL &&
	      StrChr(suff->suffix + 1, '*') == NULL)) &&
#endif
	    ((trivial_enc && IsUnityEnc(suff->encoding)) ||
	     (!trivial_enc && !IsUnityEnc(suff->encoding) &&
	      strcmp(enc, HTAtom_name(suff->encoding)) == 0))) {
#ifdef FNAMES_8_3
	    if (suff->suffix && (strlen(suff->suffix) <= 4)) {
		/*
		 * If length of suffix (including dot) is 4 or smaller, return
		 * this one even if we found a longer one earlier - kw
		 */
		return suff->suffix;
	    } else if (!first_found) {
		first_found = suff;	/* remember this one */
	    }
#else
	    return suff->suffix;	/* OK -- found */
#endif
	}
    }
#ifdef FNAMES_8_3
    if (first_found)
	return first_found->suffix;
#endif
    return "";			/* Dunno */
}

/*
 * Trim version from VMS filenames to avoid confusing comparisons.
 */
#ifdef VMS
static const char *VMS_trim_version(const char *filename)
{
    const char *result = filename;
    const char *version = StrChr(filename, ';');

    if (version != 0) {
	static char *stripped;

	StrAllocCopy(stripped, filename);
	stripped[version - filename] = '\0';
	result = (const char *) stripped;
    }
    return result;
}
#define VMS_DEL_VERSION(name) name = VMS_trim_version(name)
#else
#define VMS_DEL_VERSION(name)	/* nothing */
#endif

/*	Determine file format from file name.
 *	-------------------------------------
 *
 *	This version will return the representation and also set
 *	a variable for the encoding.
 *
 *	Encoding may be a unity encoding (binary, 8bit, etc.) or
 *	a content-coding like gzip, compress.
 *
 *	It will handle for example  x.txt, x.txt,Z, x.Z
 */
HTFormat HTFileFormat(const char *filename,
		      HTAtom **pencoding,
		      const char **pdesc)
{
    HTSuffix *suff;
    int n;
    int i;
    int lf;
    char *search;

    VMS_DEL_VERSION(filename);

    if ((search = FindSearch(filename)) != 0) {
	char *newname = NULL;
	HTFormat result;

	StrAllocCopy(newname, filename);
	*(FindSearch(newname)) = '\0';
	result = HTFileFormat(newname, pencoding, pdesc);
	free(newname);
	return result;
    }

    if (pencoding)
	*pencoding = NULL;
    if (pdesc)
	*pdesc = NULL;
    if (LYforce_HTML_mode) {
	if (pencoding)
	    *pencoding = WWW_ENC_8BIT;
	return WWW_HTML;
    }
#ifndef NO_INIT
    if (!HTSuffixes)
	HTFileInit();
#endif /* !NO_INIT */
    lf = (int) strlen(filename);
    n = HTList_count(HTSuffixes);
    for (i = 0; i < n; i++) {
	int ls;

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
	ls = (int) strlen(suff->suffix);
	if ((ls <= lf) && 0 == strcasecomp(suff->suffix, filename + lf - ls)) {
	    int j;

	    if (pencoding)
		*pencoding = suff->encoding;
	    if (pdesc)
		*pdesc = suff->desc;
	    if (suff->rep) {
		return suff->rep;	/* OK -- found */
	    }
	    for (j = 0; j < n; j++) {	/* Got encoding, need representation */
		int ls2;

		suff = (HTSuffix *) HTList_objectAt(HTSuffixes, j);
		ls2 = (int) strlen(suff->suffix);
		if ((ls + ls2 <= lf) &&
		    !strncasecomp(suff->suffix,
				  filename + lf - ls - ls2, ls2)) {
		    if (suff->rep) {
			if (pdesc && !(*pdesc))
			    *pdesc = suff->desc;
			if (pencoding && IsUnityEnc(*pencoding) &&
			    *pencoding != WWW_ENC_7BIT &&
			    !IsUnityEnc(suff->encoding))
			    *pencoding = suff->encoding;
			return suff->rep;
		    }
		}
	    }

	}
    }

    /* defaults tree */

    suff = (StrChr(filename, '.')
	    ? (unknown_suffix.rep
	       ? &unknown_suffix
	       : &no_suffix)
	    : &no_suffix);

    /*
     * Set default encoding unless found with suffix already.
     */
    if (pencoding && !*pencoding) {
	*pencoding = (suff->encoding
		      ? suff->encoding
		      : HTAtom_for("binary"));
    }
    return suff->rep ? suff->rep : WWW_BINARY;
}

/*	Revise the file format in relation to the Lynx charset. - FM
 *	-------------------------------------------------------
 *
 *	This checks the format associated with an anchor for
 *	an extended MIME Content-Type, and if a charset is
 *	indicated, sets Lynx up for proper handling in relation
 *	to the currently selected character set. - FM
 */
HTFormat HTCharsetFormat(HTFormat format,
			 HTParentAnchor *anchor,
			 int default_LYhndl)
{
    char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;
    BOOL chartrans_ok = FALSE;
    int chndl = -1;

    FREE(anchor->charset);
    StrAllocCopy(cp, format->name);
    LYLowerCase(cp);
    if (((cp1 = StrChr(cp, ';')) != NULL) &&
	(cp2 = strstr(cp1, "charset")) != NULL) {
	CTRACE((tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		format->name));
	cp2 += 7;
	while (*cp2 == ' ' || *cp2 == '=')
	    cp2++;
	StrAllocCopy(cp3, cp2);	/* copy to mutilate more */
	for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
			 *cp4 != ';' && *cp4 != ':' &&
			 !WHITE(*cp4)); cp4++) {
	    ;			/* do nothing */
	}
	*cp4 = '\0';
	cp4 = cp3;
	chndl = UCGetLYhndl_byMIME(cp3);
	if (UCCanTranslateFromTo(chndl, current_char_set)) {
	    chartrans_ok = YES;
	    *cp1 = '\0';
	    format = HTAtom_for(cp);
	    StrAllocCopy(anchor->charset, cp4);
	    HTAnchor_setUCInfoStage(anchor, chndl,
				    UCT_STAGE_MIME,
				    UCT_SETBY_MIME);
	} else if (chndl < 0) {
	    /*
	     * Got something but we don't recognize it.
	     */
	    chndl = UCLYhndl_for_unrec;
	    if (chndl < 0)
		/*
		 * UCLYhndl_for_unrec not defined :-( fallback to
		 * UCLYhndl_for_unspec which always valid.
		 */
		chndl = UCLYhndl_for_unspec;	/* always >= 0 */
	    if (UCCanTranslateFromTo(chndl, current_char_set)) {
		chartrans_ok = YES;
		HTAnchor_setUCInfoStage(anchor, chndl,
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
	    }
	}
	if (chartrans_ok) {
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(anchor,
							UCT_STAGE_MIME);
	    LYUCcharset *p_out = HTAnchor_setUCInfoStage(anchor,
							 current_char_set,
							 UCT_STAGE_HTEXT,
							 UCT_SETBY_DEFAULT);

	    if (!p_out) {
		/*
		 * Try again.
		 */
		p_out = HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT);
	    }
	    if (!strcmp(p_in->MIMEname, "x-transparent")) {
		HTPassEightBitRaw = TRUE;
		HTAnchor_setUCInfoStage(anchor,
					HTAnchor_getUCLYhndl(anchor,
							     UCT_STAGE_HTEXT),
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
	    }
	    if (!strcmp(p_out->MIMEname, "x-transparent")) {
		HTPassEightBitRaw = TRUE;
		HTAnchor_setUCInfoStage(anchor,
					HTAnchor_getUCLYhndl(anchor,
							     UCT_STAGE_MIME),
					UCT_STAGE_HTEXT,
					UCT_SETBY_DEFAULT);
	    }
	    if (p_in->enc != UCT_ENC_CJK) {
		HTCJK = NOCJK;
		if (!(p_in->codepoints &
		      UCT_CP_SUBSETOF_LAT1) &&
		    chndl == current_char_set) {
		    HTPassEightBitRaw = TRUE;
		}
	    } else if (p_out->enc == UCT_ENC_CJK) {
		Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
	    }
	} else {
	    /*
	     * Cannot translate.  If according to some heuristic the given
	     * charset and the current display character both are likely to be
	     * like ISO-8859 in structure, pretend we have some kind of match.
	     */
	    BOOL given_is_8859 = (BOOL) (!StrNCmp(cp4, "iso-8859-", 9) &&
					 isdigit(UCH(cp4[9])));
	    BOOL given_is_8859like = (BOOL) (given_is_8859 ||
					     !StrNCmp(cp4, "windows-", 8) ||
					     !StrNCmp(cp4, "cp12", 4) ||
					     !StrNCmp(cp4, "cp-12", 5));
	    BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
						      (strstr(LYchar_set_names[current_char_set],
							      "ISO-8859") ||
						       strstr(LYchar_set_names[current_char_set],
							      "windows-")));

	    if (given_and_display_8859like) {
		*cp1 = '\0';
		format = HTAtom_for(cp);
	    }
	    if (given_is_8859) {
		cp1 = &cp4[10];
		while (*cp1 &&
		       isdigit(UCH(*cp1)))
		    cp1++;
		*cp1 = '\0';
	    }
	    if (given_and_display_8859like) {
		StrAllocCopy(anchor->charset, cp4);
		HTPassEightBitRaw = TRUE;
	    }
	    HTAlert(*cp4 ? cp4 : anchor->charset);
	}
	FREE(cp3);
    } else if (cp1 != NULL) {
	/*
	 * No charset parameter is present.  Ignore all other parameters, as we
	 * do when charset is present.  - FM
	 */
	*cp1 = '\0';
	format = HTAtom_for(cp);
    }
    FREE(cp);

    /*
     * Set up defaults, if needed.  - FM
     */
    if (!chartrans_ok && !anchor->charset && default_LYhndl >= 0) {
	HTAnchor_setUCInfoStage(anchor, default_LYhndl,
				UCT_STAGE_MIME,
				UCT_SETBY_DEFAULT);
    }
    HTAnchor_copyUCInfoStage(anchor,
			     UCT_STAGE_PARSER,
			     UCT_STAGE_MIME,
			     -1);

    return format;
}

/*	Get various pieces of meta info from file name.
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
void LYGetFileInfo(const char *filename,
		   HTParentAnchor **pfile_anchor,
		   HTFormat *pformat,
		   HTAtom **pencoding,
		   const char **pdesc,
		   const char **pcharset,
		   int *pfile_cs)
{
    char *Afn;
    char *Aname = NULL;
    HTFormat format;
    HTAtom *myEnc = NULL;
    HTParentAnchor *file_anchor;
    const char *file_csname;
    int file_cs;

    /*
     * Convert filename to URL.  Note that it is always supposed to be a
     * filename, not maybe-filename-maybe-URL, so we don't use
     * LYFillLocalFileURL and LYEnsureAbsoluteURL.  - kw
     */
    Afn = HTEscape(filename, URL_PATH);
    LYLocalFileToURL(&Aname, Afn);
    file_anchor = HTAnchor_findSimpleAddress(Aname);

    format = HTFileFormat(filename, &myEnc, pdesc);
    format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
    file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
    file_csname = file_anchor->charset;
    if (!file_csname) {
	if (file_cs >= 0)
	    file_csname = LYCharSet_UC[file_cs].MIMEname;
	else
	    file_csname = "display character set";
    }
    CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	    filename,
	    ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
	     *HTAtom_name(format) == 'a' ? "n" : ""),
	    myEnc ? HTAtom_name(myEnc) : "",
	    HTAtom_name(format),
	    file_csname,
	    file_cs));
    FREE(Afn);
    FREE(Aname);
    if (pfile_anchor)
	*pfile_anchor = file_anchor;
    if (pformat)
	*pformat = format;
    if (pencoding)
	*pencoding = myEnc;
    if (pcharset)
	*pcharset = file_csname;
    if (pfile_cs)
	*pfile_cs = file_cs;
}

/*	Determine value from file name.
 *	-------------------------------
 *
 */
float HTFileValue(const char *filename)
{
    HTSuffix *suff;
    int n;
    int i;
    int lf = (int) strlen(filename);

#ifndef NO_INIT
    if (!HTSuffixes)
	HTFileInit();
#endif /* !NO_INIT */
    n = HTList_count(HTSuffixes);
    for (i = 0; i < n; i++) {
	int ls;

	suff = (HTSuffix *) HTList_objectAt(HTSuffixes, i);
	ls = (int) strlen(suff->suffix);
	if ((ls <= lf) && 0 == strcmp(suff->suffix, filename + lf - ls)) {
	    CTRACE((tfp, "File: Value of %s is %.3f\n",
		    filename, suff->quality));
	    return suff->quality;	/* OK -- found */
	}
    }
    return (float) 0.3;		/* Dunno! */
}

/*
 *  Determine compression type from file name, by looking at its suffix.
 *  Sets as side-effect a pointer to the "dot" that begins the suffix.
 */
CompressFileType HTCompressFileType(const char *filename,
				    const char *dots,
				    int *rootlen)
{
    CompressFileType result = cftNone;
    char *search;

    if ((search = FindSearch(filename)) != 0) {
	char *newname = NULL;

	StrAllocCopy(newname, filename);
	newname[((const char *) search) - filename] = '\0';
	result = HTCompressFileType(newname, dots, rootlen);
	free(newname);
    } else {
	size_t len;
	const char *ftype;

	VMS_DEL_VERSION(filename);
	len = strlen(filename);
	ftype = filename + len;

	if ((len > 4)
	    && !strcasecomp((ftype - 3), "bz2")
	    && StrChr(dots, ftype[-4]) != 0) {
	    result = cftBzip2;
	    ftype -= 4;
	} else if ((len > 3)
		   && !strcasecomp((ftype - 2), "gz")
		   && StrChr(dots, ftype[-3]) != 0) {
	    result = cftGzip;
	    ftype -= 3;
	} else if ((len > 3)
		   && !strcasecomp((ftype - 2), "zz")
		   && StrChr(dots, ftype[-3]) != 0) {
	    result = cftDeflate;
	    ftype -= 3;
	} else if ((len > 2)
		   && !strcmp((ftype - 1), "Z")
		   && StrChr(dots, ftype[-2]) != 0) {
	    result = cftCompress;
	    ftype -= 2;
	}

	*rootlen = (int) (ftype - filename);

	CTRACE((tfp, "HTCompressFileType(%s) returns %d:%s\n",
		filename, (int) result, filename + *rootlen));
    }
    return result;
}

/*
 *  Determine expected file-suffix from the compression method.
 */
const char *HTCompressTypeToSuffix(CompressFileType method)
{
    const char *result = "";

    switch (method) {
    default:
    case cftNone:
	result = "";
	break;
    case cftGzip:
	result = ".gz";
	break;
    case cftCompress:
	result = ".Z";
	break;
    case cftBzip2:
	result = ".bz2";
	break;
    case cftDeflate:
	result = ".zz";
	break;
    }
    return result;
}

/*
 *  Determine compression encoding from the compression method.
 */
const char *HTCompressTypeToEncoding(CompressFileType method)
{
    const char *result = NULL;

    switch (method) {
    default:
    case cftNone:
	result = NULL;
	break;
    case cftGzip:
	result = "gzip";
	break;
    case cftCompress:
	result = "compress";
	break;
    case cftBzip2:
	result = "bzip2";
	break;
    case cftDeflate:
	result = "deflate";
	break;
    }
    return result;
}

/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.  RFC 2068 (and cut/paste into RFC 2616) lists these:
 *	gzip
 *	compress
 *	deflate
 * as well as "identity" (but that does nothing).
 */
CompressFileType HTEncodingToCompressType(const char *coding)
{
    CompressFileType result = cftNone;

    if (coding == NULL) {
	result = cftNone;
    } else if (!strcasecomp(coding, "gzip") ||
	       !strcasecomp(coding, "x-gzip")) {
	result = cftGzip;
    } else if (!strcasecomp(coding, "compress") ||
	       !strcasecomp(coding, "x-compress")) {
	result = cftCompress;
    } else if (!strcasecomp(coding, "bzip2") ||
	       !strcasecomp(coding, "x-bzip2")) {
	result = cftBzip2;
    } else if (!strcasecomp(coding, "deflate") ||
	       !strcasecomp(coding, "x-deflate")) {
	result = cftDeflate;
    }
    return result;
}

CompressFileType HTContentTypeToCompressType(const char *ct)
{
    CompressFileType method = cftNone;

    if (ct == NULL) {
	method = cftNone;
    } else if (!strncasecomp(ct, "application/gzip", 16) ||
	       !strncasecomp(ct, "application/x-gzip", 18)) {
	method = cftGzip;
    } else if (!strncasecomp(ct, "application/compress", 20) ||
	       !strncasecomp(ct, "application/x-compress", 22)) {
	method = cftCompress;
    } else if (!strncasecomp(ct, "application/bzip2", 17) ||
	       !strncasecomp(ct, "application/x-bzip2", 19)) {
	method = cftBzip2;
    }
    return method;
}

/*
 * Check the anchor's content_type and content_encoding elements for a gzip or
 * Unix compressed file -FM, TD
 */
CompressFileType HTContentToCompressType(HTParentAnchor *anchor)
{
    CompressFileType method = cftNone;
    const char *ct = HTAnchor_content_type(anchor);
    const char *ce = HTAnchor_content_encoding(anchor);

    if (ce == NULL && ct != 0) {
	method = HTContentTypeToCompressType(ct);
    } else if (ce != 0) {
	method = HTEncodingToCompressType(ce);
    }
    return method;
}

/*	Determine write access to a file.
 *	---------------------------------
 *
 *  On exit:
 *	Returns YES if file can be accessed and can be written to.
 *
 *  Bugs:
 *	1.	No code for non-unix systems.
 *	2.	Isn't there a quicker way?
 */
BOOL HTEditable(const char *filename GCC_UNUSED)
{
#ifndef NO_GROUPS
    GETGROUPS_T groups[NGROUPS];
    uid_t myUid;
    int ngroups;		/* The number of groups  */
    struct stat fileStatus;
    int i;

    if (stat(filename, &fileStatus))	/* Get details of filename */
	return NO;		/* Can't even access file! */

    ngroups = getgroups(NGROUPS, groups);	/* Groups to which I belong  */
    myUid = geteuid();		/* Get my user identifier */

    if (TRACE) {
	int i2;

	fprintf(tfp,
		"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",
		(unsigned int) fileStatus.st_mode,
		(int) fileStatus.st_uid,
		(int) fileStatus.st_gid,
		(int) myUid,
		(int) ngroups);
	for (i2 = 0; i2 < ngroups; i2++)
	    fprintf(tfp, " %d", (int) groups[i2]);
	fprintf(tfp, ")\n");
    }

    if (fileStatus.st_mode & 0002)	/* I can write anyway? */
	return YES;

    if ((fileStatus.st_mode & 0200)	/* I can write my own file? */
	&&(fileStatus.st_uid == myUid))
	return YES;

    if (fileStatus.st_mode & 0020)	/* Group I am in can write? */
    {
	for (i = 0; i < ngroups; i++) {
	    if (groups[i] == fileStatus.st_gid)
		return YES;
	}
    }
    CTRACE((tfp, "\tFile is not editable.\n"));
#endif /* NO_GROUPS */
    return NO;			/* If no excuse, can't do */
}

/*	Make a save stream.
 *	-------------------
 *
 *	The stream must be used for writing back the file.
 *	@@@@@@ no backup done
 */
HTStream *HTFileSaveStream(HTParentAnchor *anchor)
{
    const char *addr = anchor->address;
    char *localname = HTLocalName(addr);
    FILE *fp = fopen(localname, BIN_W);

    FREE(localname);
    if (!fp)
	return NULL;

    return HTFWriter_new(fp);
}

/*	Output one directory entry.
 *	---------------------------
 */
void HTDirEntry(HTStructured * target, const char *tail,
		const char *entry)
{
    char *relative = NULL;
    char *stripped = NULL;
    char *escaped = NULL;
    int len;

    StrAllocCopy(escaped, entry);
    LYTrimPathSep(escaped);
    if (strcmp(escaped, "..") != 0) {
	stripped = escaped;
	escaped = HTEscape(stripped, URL_XPALPHAS);
	if (((len = (int) strlen(escaped)) > 2) &&
	    escaped[(len - 3)] == '%' &&
	    escaped[(len - 2)] == '2' &&
	    TOUPPER(escaped[(len - 1)]) == 'F') {
	    escaped[(len - 3)] = '\0';
	}
    }

    if (isEmpty(tail)) {
	/*
	 * Handle extra slash at end of path.
	 */
	HTStartAnchor(target, NULL, (escaped[0] != '\0' ? escaped : "/"));
    } else {
	/*
	 * If empty tail, gives absolute ref below.
	 */
	relative = 0;
	HTSprintf0(&relative, "%s%s%s",
		   tail,
		   (*escaped != '\0' ? "/" : ""),
		   escaped);
	HTStartAnchor(target, NULL, relative);
	FREE(relative);
    }
    FREE(stripped);
    FREE(escaped);
}

static BOOL view_structured(HTFormat format_out)
{
    BOOL result = FALSE;

#ifdef USE_PRETTYSRC
    if (psrc_view
	|| (format_out == HTAtom_for("www/dump")))
	result = TRUE;
#else
    if (format_out == WWW_SOURCE)
	result = TRUE;
#endif
    return result;
}

/*
 * Write a DOCTYPE to the given stream if we happen to want to see the
 * source view, or are dumping source.  This is not needed when the source
 * is not visible, since the document is rendered from a HTStructured object.
 */
void HTStructured_doctype(HTStructured * target, HTFormat format_out)
{
    if (view_structured(format_out))
	PUTS("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
}

void HTStructured_meta(HTStructured * target, HTFormat format_out)
{
    if (view_structured(format_out))
	PUTS("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n");
}
/*	Output parent directory entry.
 *	------------------------------
 *
 *    This gives the TITLE and H1 header, and also a link
 *    to the parent directory if appropriate.
 *
 *  On exit:
 *	Returns TRUE if an "Up to <parent>" link was not created
 *	for a readable local directory because LONG_LIST is defined
 *	and NO_PARENT_DIR_REFERENCE is not defined, so that the
 *	calling function should use LYListFmtParse() to create a link
 *	to the parent directory.  Otherwise, it returns FALSE. - FM
 */
BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
		 HTFormat format_out,
		 int tildeIsTop)
{
    const char *logical = anchor->address;
    char *path = HTParse(logical, "", PARSE_PATH + PARSE_PUNCTUATION);
    char *current;
    char *cp = NULL;
    BOOL need_parent_link = FALSE;
    int i;

#if defined(USE_DOS_DRIVES)
    BOOL local_link = (strlen(logical) > 18
		       && !strncasecomp(logical, "file://localhost/", 17)
		       && LYIsDosDrive(logical + 17));
    BOOL is_remote = !local_link;

#else
#define is_remote TRUE
#endif

    /*
     * Check tildeIsTop for treating home directory as Welcome (assume the
     * tilde is not followed by a username).  - FM
     */
    if (tildeIsTop && !StrNCmp(path, "/~", 2)) {
	if (path[2] == '\0') {
	    path[1] = '\0';
	} else {
	    for (i = 0; path[(i + 2)]; i++) {
		path[i] = path[(i + 2)];
	    }
	    path[i] = '\0';
	}
    }

    /*
     * Trim out the ;type= parameter, if present.  - FM
     */
    if ((cp = strrchr(path, ';')) != NULL) {
	if (!strncasecomp((cp + 1), "type=", 5)) {
	    if (TOUPPER(*(cp + 6)) == 'D' ||
		TOUPPER(*(cp + 6)) == 'A' ||
		TOUPPER(*(cp + 6)) == 'I')
		*cp = '\0';
	}
	cp = NULL;
    }
    current = LYPathLeaf(path);	/* last part or "" */

    {
	char *printable = NULL;

#ifdef DIRED_SUPPORT
	printable = HTURLPath_toFile(((!strncasecomp(path, "/%2F", 4))	/* "//" ? */
				      ? (path + 1)
				      : path),
				     TRUE,
				     is_remote);
	if (0 == strncasecomp(printable, "/vmsysu:", 8) ||
	    0 == strncasecomp(printable, "/anonymou.", 10)) {
	    StrAllocCopy(cp, (printable + 1));
	    StrAllocCopy(printable, cp);
	    FREE(cp);
	}
#else
	StrAllocCopy(printable, current);
	HTUnEscape(printable);
#endif /* DIRED_SUPPORT */

	HTStructured_doctype(target, format_out);

	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(*printable ? printable : WELCOME_MSG);
	PUTS(SEGMENT_DIRECTORY);
	END(HTML_TITLE);
	PUTC('\n');
	HTStructured_meta(target, format_out);
	END(HTML_HEAD);
	PUTC('\n');

	START(HTML_BODY);
	PUTC('\n');

#ifdef DIRED_SUPPORT
	START(HTML_H2);
	PUTS(*printable ? SEGMENT_CURRENT_DIR : "");
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H2);
	PUTC('\n');
#else
	START(HTML_H1);
	PUTS(*printable ? printable : WELCOME_MSG);
	END(HTML_H1);
	PUTC('\n');
#endif /* DIRED_SUPPORT */
	if (((0 == strncasecomp(printable, "vmsysu:", 7)) &&
	     (cp = StrChr(printable, '.')) != NULL &&
	     StrChr(cp, '/') == NULL) ||
	    (0 == strncasecomp(printable, "anonymou.", 9) &&
	     StrChr(printable, '/') == NULL)) {
	    FREE(printable);
	    FREE(path);
	    return (need_parent_link);
	}
	FREE(printable);
    }

#ifndef NO_PARENT_DIR_REFERENCE
    /*
     * Make link back to parent directory.
     */
    if (current - path > 0
	&& LYIsPathSep(current[-1])
	&& current[0] != '\0') {	/* was a slash AND something else too */
	char *parent = NULL;
	char *relative = NULL;

	current[-1] = '\0';
	parent = strrchr(path, '/');	/* penultimate slash */

	if ((parent &&
	     (!strcmp(parent, "/..") ||
	      !strncasecomp(parent, "/%2F", 4))) ||
	    !strncasecomp(current, "%2F", 3)) {
	    FREE(path);
	    return (need_parent_link);
	}

	relative = 0;
	HTSprintf0(&relative, "%s/..", current);

#if defined(DOSPATH) || defined(__EMX__)
	if (local_link) {
	    if (parent != 0 && strlen(parent) == 3) {
		StrAllocCat(relative, "/.");
	    }
	} else
#endif

#if !defined (VMS)
	{
	    /*
	     * On Unix, if it's not ftp and the directory cannot be read, don't
	     * put out a link.
	     *
	     * On VMS, this problem is dealt with internally by
	     * HTVMSBrowseDir().
	     */
	    DIR *dp = NULL;

	    if (LYisLocalFile(logical)) {
		/*
		 * We need an absolute file path for the opendir.  We also need
		 * to unescape for this test.  Don't worry about %2F now, they
		 * presumably have been dealt with above, and shouldn't appear
		 * for local files anyway...  Assume OS / filesystem will just
		 * ignore superfluous slashes.  - KW
		 */
		char *fullparentpath = NULL;

		/*
		 * Path has been shortened above.
		 */
		StrAllocCopy(fullparentpath, *path ? path : "/");

		/*
		 * Guard against weirdness.
		 */
		if (0 == strcmp(current, "..")) {
		    StrAllocCat(fullparentpath, "/../..");
		} else if (0 == strcmp(current, ".")) {
		    StrAllocCat(fullparentpath, "/..");
		}

		HTUnEscape(fullparentpath);
		if ((dp = opendir(fullparentpath)) == NULL) {
		    FREE(fullparentpath);
		    FREE(relative);
		    FREE(path);
		    return (need_parent_link);
		}
		closedir(dp);
		FREE(fullparentpath);
#ifdef LONG_LIST
		need_parent_link = TRUE;
		FREE(path);
		FREE(relative);
		return (need_parent_link);
#endif /* LONG_LIST */
	    }
	}
#endif /* !VMS */
	HTStartAnchor(target, "", relative);
	FREE(relative);

	PUTS(SEGMENT_UP_TO);
	if (parent) {
	    if ((0 == strcmp(current, ".")) ||
		(0 == strcmp(current, ".."))) {
		/*
		 * Should not happen, but if it does, at least avoid giving
		 * misleading info.  - KW
		 */
		PUTS("..");
	    } else {
		char *printable = NULL;

		StrAllocCopy(printable, parent + 1);
		HTUnEscape(printable);
		PUTS(printable);
		FREE(printable);
	    }
	} else {
	    PUTC('/');
	}
	END(HTML_A);
	PUTC('\n');
    }
#endif /* !NO_PARENT_DIR_REFERENCE */

    FREE(path);
    return (need_parent_link);
}

#if defined HAVE_READDIR
/*	Send README file.
 *	-----------------
 *
 *  If a README file exists, then it is inserted into the document here.
 */
static void do_readme(HTStructured * target, const char *localname)
{
    FILE *fp;
    char *readme_file_name = NULL;
    int ch;

    HTSprintf0(&readme_file_name, "%s/%s", localname, HT_DIR_README_FILE);

    fp = fopen(readme_file_name, "r");

    if (fp) {
	START(HTML_PRE);
	while ((ch = fgetc(fp)) != EOF) {
	    PUTC((char) ch);
	}
	END(HTML_PRE);
	HTDisplayPartial();
	fclose(fp);
    }
    FREE(readme_file_name);
}

#define DIRED_BLOK(obj) (((DIRED *)(obj))->sort_tags)
#define DIRED_NAME(obj) (((DIRED *)(obj))->file_name)

#define NM_cmp(a,b) ((a) < (b) ? -1 : ((a) > (b) ? 1 : 0))

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
static const char *file_type(const char *path)
{
    const char *type;

    while (*path == '.')
	++path;
    type = StrChr(path, '.');
    if (type == NULL)
	type = "";
    return type;
}
#endif /* LONG_LIST && DIRED_SUPPORT */

static int dired_cmp(void *a, void *b)
{
    DIRED *p = (DIRED *) a;
    DIRED *q = (DIRED *) b;
    int code = p->sort_tags - q->sort_tags;

#if defined(LONG_LIST) && defined(DIRED_SUPPORT)
    if (code == 0) {
	switch (dir_list_order) {
	case ORDER_BY_SIZE:
	    code = -NM_cmp(p->file_info.st_size, q->file_info.st_size);
	    break;
	case ORDER_BY_DATE:
	    code = -NM_cmp(p->file_info.st_mtime, q->file_info.st_mtime);
	    break;
	case ORDER_BY_MODE:
	    code = NM_cmp(p->file_info.st_mode, q->file_info.st_mode);
	    break;
	case ORDER_BY_USER:
	    code = NM_cmp(p->file_info.st_uid, q->file_info.st_uid);
	    break;
	case ORDER_BY_GROUP:
	    code = NM_cmp(p->file_info.st_gid, q->file_info.st_gid);
	    break;
	case ORDER_BY_TYPE:
	    code = AS_cmp(file_type(p->file_name), file_type(q->file_name));
	    break;
	default:
	    code = 0;
	    break;
	}
    }
#endif /* LONG_LIST && DIRED_SUPPORT */
    if (code == 0)
	code = AS_cmp(p->file_name, q->file_name);
#if 0
    CTRACE((tfp, "dired_cmp(%d) ->%d\n\t%c:%s (%s)\n\t%c:%s (%s)\n",
	    dir_list_order,
	    code,
	    p->sort_tags, p->file_name, file_type(p->file_name),
	    q->sort_tags, q->file_name, file_type(q->file_name)));
#endif
    return code;
}

static int print_local_dir(DIR *dp, char *localname,
			   HTParentAnchor *anchor,
			   HTFormat format_out,
			   HTStream *sink)
{
    HTStructured *target;	/* HTML object */
    HTBTree *bt;
    HTStructuredClass targetClass;
    STRUCT_DIRENT *dirbuf;
    char *pathname = NULL;
    char *tail = NULL;
    const char *p;
    char *tmpfilename = NULL;
    BOOL need_parent_link = FALSE;
    BOOL preformatted = FALSE;
    int status;
    struct stat *actual_info;

#ifdef DISP_PARTIAL
    int num_of_entries = 0;	/* lines counter */
#endif

#ifdef S_IFLNK
    struct stat link_info;
#endif

    CTRACE((tfp, "print_local_dir() started\n"));

    pathname = HTParse(anchor->address, "",
		       PARSE_PATH + PARSE_PUNCTUATION);

    if ((p = strrchr(pathname, '/')) == NULL)
	p = "/";
    StrAllocCopy(tail, (p + 1));
    FREE(pathname);

    if (UCLYhndl_HTFile_for_unspec >= 0) {
	HTAnchor_setUCInfoStage(anchor,
				UCLYhndl_HTFile_for_unspec,
				UCT_STAGE_PARSER,
				UCT_SETBY_DEFAULT);
    }

    target = HTML_new(anchor, format_out, sink);
    targetClass = *target->isa;	/* Copy routine entry points */

    /*
     * The need_parent_link flag will be set if an "Up to <parent>" link was
     * not created for a readable parent in HTDirTitles() because LONG_LIST is
     * defined and NO_PARENT_DIR_REFERENCE is not defined so that need we to
     * create the link via an LYListFmtParse() call.  - FM
     */
    need_parent_link = HTDirTitles(target, anchor, format_out, FALSE);

#ifdef DIRED_SUPPORT
    if (!isLYNXCGI(anchor->address)) {
	HTAnchor_setFormat(anchor, WWW_DIRED);
	lynx_edit_mode = TRUE;
    }
#endif /* DIRED_SUPPORT */
    if (HTDirReadme == HT_DIR_README_TOP)
	do_readme(target, localname);

    bt = HTBTree_new(dired_cmp);

    _HTProgress(READING_DIRECTORY);
    status = HT_LOADED;		/* assume we don't get interrupted */
    while ((dirbuf = readdir(dp)) != NULL) {
	/*
	 * While there are directory entries to be read...
	 */
	DIRED *data = NULL;

#ifdef STRUCT_DIRENT__D_INO
	if (dirbuf->d_ino == 0)
	    /*
	     * If the entry is not being used, skip it.
	     */
	    continue;
#endif
	/*
	 * Skip self, parent if handled in HTDirTitles() or if
	 * NO_PARENT_DIR_REFERENCE is not defined, and any dot files if
	 * no_dotfiles is set or show_dotfiles is not set.  - FM
	 */
	if (!strcmp(dirbuf->d_name, ".") /* self       */ ||
	    (!strcmp(dirbuf->d_name, "..") /* parent */ &&
	     need_parent_link == FALSE) ||
	    ((strcmp(dirbuf->d_name, "..")) &&
	     (dirbuf->d_name[0] == '.' &&
	      (no_dotfiles || !show_dotfiles))))
	    continue;

	StrAllocCopy(tmpfilename, localname);
	/*
	 * If filename is not root directory, add trailing separator.
	 */
	LYAddPathSep(&tmpfilename);

	StrAllocCat(tmpfilename, dirbuf->d_name);
	data = (DIRED *) malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
	if (data == NULL) {
	    status = HT_PARTIAL_CONTENT;
	    break;
	}
	LYTrimPathSep(tmpfilename);

	actual_info = &(data->file_info);
#ifdef S_IFLNK
	if (lstat(tmpfilename, actual_info) < 0) {
	    actual_info->st_mode = 0;
	} else {
	    if (S_ISLNK(actual_info->st_mode)) {
		actual_info = &link_info;
		if (stat(tmpfilename, actual_info) < 0)
		    actual_info->st_mode = 0;
	    }
	}
#else
	if (stat(tmpfilename, actual_info) < 0)
	    actual_info->st_mode = 0;
#endif

	strcpy(data->file_name, dirbuf->d_name);
#ifndef DIRED_SUPPORT
	if (S_ISDIR(actual_info->st_mode)) {
	    data->sort_tags = 'D';
	} else {
	    data->sort_tags = 'F';
	    /* D & F to have first directories, then files */
	}
#else
	if (S_ISDIR(actual_info->st_mode)) {
	    if (dir_list_style == MIXED_STYLE) {
		data->sort_tags = ' ';
		LYAddPathSep0(data->file_name);
	    } else if (!strcmp(dirbuf->d_name, "..")) {
		data->sort_tags = 'A';
	    } else {
		data->sort_tags = 'D';
	    }
	} else if (dir_list_style == MIXED_STYLE) {
	    data->sort_tags = ' ';
	} else if (dir_list_style == FILES_FIRST) {
	    data->sort_tags = 'C';
	    /* C & D to have first files, then directories */
	} else {
	    data->sort_tags = 'F';
	}
#endif /* !DIRED_SUPPORT */
	/*
	 * Sort dirname in the tree bt.
	 */
	HTBTree_add(bt, data);

#ifdef DISP_PARTIAL
	/* optimize for expensive operation: */
	if (num_of_entries % (partial_threshold > 0 ?
			      partial_threshold : display_lines) == 0) {
	    if (HTCheckForInterrupt()) {
		status = HT_PARTIAL_CONTENT;
		break;
	    }
	}
	num_of_entries++;
#endif /* DISP_PARTIAL */

    }				/* end while directory entries left to read */

    if (status != HT_PARTIAL_CONTENT)
	_HTProgress(OPERATION_OK);
    else
	CTRACE((tfp, "Reading the directory interrupted by user\n"));

    /*
     * Run through tree printing out in order.
     */
    {
	HTBTElement *next_element = HTBTree_next(bt, NULL);

	/* pick up the first element of the list */
	int num_of_entries_output = 0;	/* lines counter */

	char state;

	/* I for initial (.. file),
	   D for directory file,
	   F for file */

#ifdef DIRED_SUPPORT
	char test;
#endif /* DIRED_SUPPORT */
	state = 'I';

	while (next_element != NULL) {
	    DIRED *entry;

#ifndef DISP_PARTIAL
	    if (num_of_entries_output % HTMAX(display_lines, 10) == 0) {
		if (HTCheckForInterrupt()) {
		    _HTProgress(TRANSFER_INTERRUPTED);
		    status = HT_PARTIAL_CONTENT;
		    break;
		}
	    }
#endif
	    StrAllocCopy(tmpfilename, localname);
	    /*
	     * If filename is not root directory.
	     */
	    LYAddPathSep(&tmpfilename);

	    entry = (DIRED *) (HTBTree_object(next_element));
	    /*
	     * Append the current entry's filename to the path.
	     */
	    StrAllocCat(tmpfilename, entry->file_name);
	    HTSimplify(tmpfilename);
	    /*
	     * Output the directory entry.
	     */
	    if (strcmp(DIRED_NAME(HTBTree_object(next_element)), "..")) {
#ifdef DIRED_SUPPORT
		test =
		    (char) (DIRED_BLOK(HTBTree_object(next_element))
			    == 'D' ? 'D' : 'F');
		if (state != test) {
#ifndef LONG_LIST
		    if (dir_list_style == FILES_FIRST) {
			if (state == 'F') {
			    END(HTML_DIR);
			    PUTC('\n');
			}
		    } else if (dir_list_style != MIXED_STYLE)
			if (state == 'D') {
			    END(HTML_DIR);
			    PUTC('\n');
			}
#endif /* !LONG_LIST */
		    state =
			(char) (DIRED_BLOK(HTBTree_object(next_element))
				== 'D' ? 'D' : 'F');
		    if (preformatted) {
			END(HTML_PRE);
			PUTC('\n');
			preformatted = FALSE;
		    }
		    START(HTML_H2);
		    if (dir_list_style != MIXED_STYLE) {
			START(HTML_EM);
			PUTS(state == 'D'
			     ? LABEL_SUBDIRECTORIES
			     : LABEL_FILES);
			END(HTML_EM);
		    }
		    END(HTML_H2);
		    PUTC('\n');
#ifndef LONG_LIST
		    START(HTML_DIR);
		    PUTC('\n');
#endif /* !LONG_LIST */
		}
#else
		if (state != DIRED_BLOK(HTBTree_object(next_element))) {
#ifndef LONG_LIST
		    if (state == 'D') {
			END(HTML_DIR);
			PUTC('\n');
		    }
#endif /* !LONG_LIST */
		    state =
			(char) (DIRED_BLOK(HTBTree_object(next_element))
				== 'D' ? 'D' : 'F');
		    if (preformatted) {
			END(HTML_PRE);
			PUTC('\n');
			preformatted = FALSE;
		    }
		    START(HTML_H2);
		    START(HTML_EM);
		    PUTS(state == 'D'
			 ? LABEL_SUBDIRECTORIES
			 : LABEL_FILES);
		    END(HTML_EM);
		    END(HTML_H2);
		    PUTC('\n');
#ifndef LONG_LIST
		    START(HTML_DIR);
		    PUTC('\n');
#endif /* !LONG_LIST */
		}
#endif /* DIRED_SUPPORT */
#ifndef LONG_LIST
		START(HTML_LI);
#endif /* !LONG_LIST */
	    }
	    if (!preformatted) {
		START(HTML_PRE);
		PUTC('\n');
		preformatted = TRUE;
	    }
#ifdef LONG_LIST
	    LYListFmtParse(list_format, entry, tmpfilename, target, tail);
#else
	    HTDirEntry(target, tail, entry->file_name);
	    PUTS(entry->file_name);
	    END(HTML_A);
	    MAYBE_END(HTML_LI);
	    PUTC('\n');
#endif /* LONG_LIST */

	    next_element = HTBTree_next(bt, next_element);
	    /* pick up the next element of the list;
	       if none, return NULL */

	    /* optimize for expensive operation: */
#ifdef DISP_PARTIAL
	    if (num_of_entries_output %
		((partial_threshold > 0)
		 ? partial_threshold
		 : display_lines) == 0) {
		/* num_of_entries, num_of_entries_output... */
		HTDisplayPartial();

		if (HTCheckForInterrupt()) {
		    _HTProgress(TRANSFER_INTERRUPTED);
		    status = HT_PARTIAL_CONTENT;
		    break;
		}
	    }
	    num_of_entries_output++;
#endif /* DISP_PARTIAL */

	}			/* end while next_element */

	if (status == HT_LOADED) {
	    if (state == 'I') {
		START(HTML_P);
		PUTS("Empty Directory");
	    }
#ifndef LONG_LIST
	    else
		END(HTML_DIR);
#endif /* !LONG_LIST */
	}
    }				/* end printing out the tree in order */
    if (preformatted) {
	END(HTML_PRE);
	PUTC('\n');
    }
    END(HTML_BODY);
    PUTC('\n');

    FREE(tmpfilename);
    FREE(tail);
    HTBTreeAndObject_free(bt);

    if (status == HT_LOADED) {
	if (HTDirReadme == HT_DIR_README_BOTTOM)
	    do_readme(target, localname);
	FREE_TARGET;
    } else {
	ABORT_TARGET;
    }
    HTFinishDisplayPartial();
    return status;		/* document loaded, maybe partial */
}
#endif /* HAVE_READDIR */

#ifndef VMS
int HTStat(const char *filename,
	   struct stat *data)
{
    int result = -1;
    size_t len = strlen(filename);

    if (len != 0 && LYIsPathSep(filename[len - 1])) {
	char *temp_name = NULL;

	HTSprintf0(&temp_name, "%s.", filename);
	result = HTStat(temp_name, data);
	FREE(temp_name);
    } else {
	result = stat(filename, data);
#ifdef _WINDOWS
	/*
	 * Someone claims that stat() doesn't give the proper result for a
	 * directory on Windows.
	 */
	if (result == -1
	    && access(filename, 0) == 0) {
	    data->st_mode = S_IFDIR;
	    result = 0;
	}
#endif
    }
    return result;
}
#endif

#if defined(USE_ZLIB) || defined(USE_BZLIB)
static BOOL sniffStream(FILE *fp, char *buffer, size_t needed)
{
    long offset = ftell(fp);
    BOOL result = FALSE;

    if (offset >= 0) {
	if (fread(buffer, sizeof(char), needed, fp) == needed) {
	    result = TRUE;
	}
	if (fseek(fp, offset, SEEK_SET) < 0) {
	    CTRACE((tfp, "error seeking in stream\n"));
	    result = FALSE;
	}
    }
    return result;
}
#endif

#ifdef USE_ZLIB
static BOOL isGzipStream(FILE *fp)
{
    char buffer[3];
    BOOL result;

    if (sniffStream(fp, buffer, sizeof(buffer))
	&& !MemCmp(buffer, "\037\213", sizeof(buffer) - 1)) {
	result = TRUE;
    } else {
	CTRACE((tfp, "not a gzip-stream\n"));
	result = FALSE;
    }
    return result;
}

/*
 * Strictly speaking, DEFLATE has no header bytes.  But decode what we can,
 * (to eliminate the one "reserved" pattern) and provide a trace.  See RFC-1951
 * discussion of BFINAL and BTYPE.
 */
static BOOL isDeflateStream(FILE *fp)
{
    char buffer[3];
    BOOL result = FALSE;

    if (sniffStream(fp, buffer, sizeof(buffer))) {
	int bit1 = ((buffer[0] >> 0) & 1);
	int bit2 = ((buffer[0] >> 1) & 1);
	int bit3 = ((buffer[0] >> 2) & 1);
	int btype = ((bit3 << 1) + bit2);

	if (!MemCmp(buffer, "\170\234", sizeof(buffer) - 1)) {
	    result = TRUE;
	    CTRACE((tfp, "isDeflate: assume zlib-wrapped deflate\n"));
	} else if (btype == 3) {
	    CTRACE((tfp, "isDeflate: not a deflate-stream\n"));
	} else {
	    CTRACE((tfp, "isDeflate: %send block, %s compression\n",
		    (bit1 ? "" : "non-"),
		    (btype == 0
		     ? "no"
		     : (btype == 1
			? "static Huffman"
			: "dynamic Huffman"))));
	    result = TRUE;
	}
    }
    return result;
}
#endif

#ifdef USE_BZLIB
static BOOL isBzip2Stream(FILE *fp)
{
    char buffer[6];
    BOOL result;

    if (sniffStream(fp, buffer, sizeof(buffer))
	&& !MemCmp(buffer, "BZh", 3)
	&& isdigit(UCH(buffer[3]))
	&& isdigit(UCH(buffer[4]))) {
	result = TRUE;
    } else {
	CTRACE((tfp, "not a bzip2-stream\n"));
	result = FALSE;
    }
    return result;
}
#endif

#ifdef VMS
#define FOPEN_MODE(bin) "r", "shr=put", "shr=upd"
#define DOT_STRING "._-"	/* FIXME: should we check if suffix is after ']' or ':' ? */
#else
#define FOPEN_MODE(bin) (bin ? BIN_R : "r")
#define DOT_STRING "."
#endif

static int decompressAndParse(HTParentAnchor *anchor,
			      HTFormat format_out,
			      HTStream *sink,
			      char *nodename GCC_UNUSED,
			      char *filename,
			      HTAtom *myEncoding,
			      HTFormat format,
			      int *statusp)
{
    HTAtom *encoding = 0;

#ifdef USE_ZLIB
    FILE *zzfp = 0;
    gzFile gzfp = 0;
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
    BZFILE *bzfp = 0;
#endif /* USE_ZLIB */
#if defined(USE_ZLIB) || defined(USE_BZLIB)
    CompressFileType internal_decompress = cftNone;
    BOOL failed_decompress = NO;
#endif
    int rootlen = 0;
    char *localname = filename;
    int bin;
    FILE *fp;
    int result = FALSE;

#ifdef VMS
    /*
     * Assume that the file is in Unix-style syntax if it contains a '/' after
     * the leading one.  @@@@
     */
    localname = (StrChr(localname + 1, '/')
		 ? HTVMS_name(nodename, localname)
		 : localname + 1);
#endif /* VMS */

    bin = HTCompressFileType(filename, ".", &rootlen) != cftNone;
    fp = fopen(localname, FOPEN_MODE(bin));

#ifdef VMS
    /*
     * If the file wasn't VMS syntax, then perhaps it is Ultrix.
     */
    if (!fp) {
	char *ultrixname = 0;

	CTRACE((tfp, "HTLoadFile: Can't open as %s\n", localname));
	HTSprintf0(&ultrixname, "%s::\"%s\"", nodename, filename);
	fp = fopen(ultrixname, FOPEN_MODE(bin));
	if (!fp) {
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", ultrixname));
	}
	FREE(ultrixname);
    }
#endif /* VMS */
    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n", localname, (void *) fp));
    if (fp) {			/* Good! */
	if (HTEditable(localname)) {
	    HTAtom *put = HTAtom_for("PUT");
	    HTList *methods = HTAnchor_methods(anchor);

	    if (HTList_indexOf(methods, put) == (-1)) {
		HTList_addObject(methods, put);
	    }
	}
	/*
	 * Fake a Content-Encoding for compressed files.  - FM
	 */
	if (!IsUnityEnc(myEncoding)) {
	    /*
	     * We already know from the call to HTFileFormat that
	     * this is a compressed file, no need to look at the filename
	     * again.  - kw
	     */
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	    CompressFileType method = HTEncodingToCompressType(HTAtom_name(myEncoding));
#endif

#define isDOWNLOAD(m) (strcmp(format_out->name, "www/download") && (method == m))
#ifdef USE_ZLIB
	    if (isDOWNLOAD(cftGzip)) {
		if (isGzipStream(fp)) {
		    fclose(fp);
		    fp = 0;
		    gzfp = gzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			    localname, gzfp));
		}
		internal_decompress = cftGzip;
	    } else if (isDOWNLOAD(cftDeflate)) {
		if (isDeflateStream(fp)) {
		    zzfp = fp;
		    fp = 0;

		    CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			    localname, (void *) zzfp));
		}
		internal_decompress = cftDeflate;
	    } else
#endif /* USE_ZLIB */
#ifdef USE_BZLIB
	    if (isDOWNLOAD(cftBzip2)) {
		if (isBzip2Stream(fp)) {
		    fclose(fp);
		    fp = 0;
		    bzfp = BZ2_bzopen(localname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			    localname, bzfp));
		}
		internal_decompress = cftBzip2;
	    } else
#endif /* USE_BZLIB */
	    {
		StrAllocCopy(anchor->content_type, format->name);
		StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
		format = HTAtom_for("www/compressed");
	    }
	} else {
	    CompressFileType cft = HTCompressFileType(localname, DOT_STRING, &rootlen);

	    if (cft != cftNone) {
		char *cp = NULL;

		StrAllocCopy(cp, localname);
		cp[rootlen] = '\0';
		format = HTFileFormat(cp, &encoding, NULL);
		FREE(cp);
		format = HTCharsetFormat(format, anchor,
					 UCLYhndl_HTFile_for_unspec);
		StrAllocCopy(anchor->content_type, format->name);
	    }

	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		format = HTAtom_for("www/compressed");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    if (isDeflateStream(fp)) {
			zzfp = fp;
			fp = 0;

			CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
				localname, (void *) zzfp));
		    }
		    internal_decompress = cftDeflate;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    if (isGzipStream(fp)) {
			fclose(fp);
			fp = 0;
			gzfp = gzopen(localname, BIN_R);

			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				localname, gzfp));
		    }
		    internal_decompress = cftGzip;
		}
#else /* USE_ZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_ZLIB */
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
#ifdef USE_BZLIB
		if (strcmp(format_out->name, "www/download") != 0) {
		    if (isBzip2Stream(fp)) {
			fclose(fp);
			fp = 0;
			bzfp = BZ2_bzopen(localname, BIN_R);

			CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				localname, bzfp));
		    }
		    internal_decompress = cftBzip2;
		}
#else /* USE_BZLIB */
		format = HTAtom_for("www/compressed");
#endif /* USE_BZLIB */
		break;
	    case cftNone:
		break;
	    }
	}
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	if (internal_decompress != cftNone) {
	    switch (internal_decompress) {
#ifdef USE_ZLIB
	    case cftDeflate:
		failed_decompress = (BOOLEAN) (zzfp == NULL);
		break;
	    case cftCompress:
	    case cftGzip:
		failed_decompress = (BOOLEAN) (gzfp == NULL);
		break;
#endif
#ifdef USE_BZLIB
	    case cftBzip2:
		failed_decompress = (BOOLEAN) (bzfp == NULL);
		break;
#endif
	    default:
		failed_decompress = YES;
		break;
	    }
	    if (failed_decompress) {
		*statusp = HTLoadError(NULL,
				       -(HT_ERROR),
				       FAILED_OPEN_COMPRESSED_FILE);
	    } else {
		char *sugfname = NULL;

		if (anchor->SugFname) {
		    StrAllocCopy(sugfname, anchor->SugFname);
		} else {
		    char *anchor_path = HTParse(anchor->address, "",
						PARSE_PATH + PARSE_PUNCTUATION);
		    char *lastslash;

		    HTUnEscape(anchor_path);
		    lastslash = strrchr(anchor_path, '/');
		    if (lastslash)
			StrAllocCopy(sugfname, lastslash + 1);
		    FREE(anchor_path);
		}
		FREE(anchor->content_encoding);
		if (sugfname && *sugfname)
		    HTCheckFnameForCompression(&sugfname, anchor,
					       TRUE);
		if (sugfname && *sugfname)
		    StrAllocCopy(anchor->SugFname, sugfname);
		FREE(sugfname);
#ifdef USE_BZLIB
		if (bzfp)
		    *statusp = HTParseBzFile(format, format_out,
					     anchor,
					     bzfp, sink);
#endif
#ifdef USE_ZLIB
		if (gzfp)
		    *statusp = HTParseGzFile(format, format_out,
					     anchor,
					     gzfp, sink);
		else if (zzfp)
		    *statusp = HTParseZzFile(format, format_out,
					     anchor,
					     zzfp, sink);
#endif
	    }
	} else
#endif /* USE_ZLIB || USE_BZLIB */
	{
	    *statusp = HTParseFile(format, format_out, anchor, fp, sink);
	}
	if (fp != 0) {
	    fclose(fp);
	    fp = 0;
	}
	result = TRUE;
    }				/* If successful open */
    return result;
}

/*	Load a document.
 *	----------------
 *
 *  On entry:
 *	addr		must point to the fully qualified hypertext reference.
 *			This is the physical address of the file
 *
 *  On exit:
 *	returns		<0		Error has occurred.
 *			HTLOADED	OK
 *
 */
int HTLoadFile(const char *addr,
	       HTParentAnchor *anchor,
	       HTFormat format_out,
	       HTStream *sink)
{
    char *filename = NULL;
    char *acc_method = NULL;
    HTFormat format;
    char *nodename = NULL;
    char *newname = NULL;	/* Simplified name of file */
    HTAtom *myEncoding = NULL;	/* enc of this file, may be gzip etc. */
    int status = -1;

#ifndef DISABLE_FTP
    char *ftp_newhost;
#endif

#ifdef VMS
    struct stat stat_info;
#endif /* VMS */

    /*
     * Reduce the filename to a basic form (hopefully unique!).
     */
    StrAllocCopy(newname, addr);
    filename = HTParse(newname, "", PARSE_PATH | PARSE_PUNCTUATION);
    nodename = HTParse(newname, "", PARSE_HOST);

    /*
     * If access is ftp, or file is on another host, invoke ftp now.
     */
    acc_method = HTParse(newname, "", PARSE_ACCESS);
    if (strcmp("ftp", acc_method) == 0 ||
	(!LYSameHostname("localhost", nodename) &&
	 !LYSameHostname(nodename, HTHostName()))) {
	status = -1;
	FREE(newname);
	FREE(filename);
	FREE(nodename);
	FREE(acc_method);
#ifndef DISABLE_FTP
	ftp_newhost = HTParse(addr, "", PARSE_HOST);
	if (strcmp(ftp_lasthost, ftp_newhost))
	    ftp_local_passive = ftp_passive;

	status = HTFTPLoad(addr, anchor, format_out, sink);

	if (ftp_passive == ftp_local_passive) {
	    if ((status >= 400) || (status < 0)) {
		ftp_local_passive = (BOOLEAN) !ftp_passive;
		status = HTFTPLoad(addr, anchor, format_out, sink);
	    }
	}

	free(ftp_lasthost);
	ftp_lasthost = ftp_newhost;
#endif /* DISABLE_FTP */
	return status;
    } else {
	FREE(newname);
	FREE(acc_method);
    }
#if defined(VMS) || defined(USE_DOS_DRIVES)
    HTUnEscape(filename);
#endif /* VMS */

    /*
     * Determine the format and encoding mapped to any suffix.
     */
    if (anchor->content_type && anchor->content_encoding) {
	/*
	 * If content_type and content_encoding are BOTH already set in the
	 * anchor object, we believe it and don't try to derive format and
	 * encoding from the filename.  - kw
	 */
	format = HTAtom_for(anchor->content_type);
	myEncoding = HTAtom_for(anchor->content_encoding);
    } else {
	int default_UCLYhndl = UCLYhndl_HTFile_for_unspec;

	if (force_old_UCLYhndl_on_reload) {
	    force_old_UCLYhndl_on_reload = FALSE;
	    default_UCLYhndl = forced_UCLYhdnl;
	}

	format = HTFileFormat(filename, &myEncoding, NULL);

	/*
	 * Check the format for an extended MIME charset value, and act on it
	 * if present.  Otherwise, assume what is indicated by the last
	 * parameter (fallback will effectively be UCLYhndl_for_unspec, by
	 * default ISO-8859-1).  - kw
	 */
	format = HTCharsetFormat(format, anchor, default_UCLYhndl);
    }

#ifdef VMS
    /*
     * Check to see if the 'filename' is in fact a directory.  If it is create
     * a new hypertext object containing a list of files and subdirectories
     * contained in the directory.  All of these are links to the directories
     * or files listed.
     */
    if (HTStat(filename, &stat_info) == -1) {
	CTRACE((tfp, "HTLoadFile: Can't stat %s\n", filename));
    } else {
	if (S_ISDIR(stat_info.st_mode)) {
	    if (HTDirAccess == HT_DIR_FORBID) {
		FREE(filename);
		FREE(nodename);
		return HTLoadError(sink, 403, DISALLOWED_DIR_SCAN);
	    }

	    if (HTDirAccess == HT_DIR_SELECTIVE) {
		char *enable_file_name = NULL;

		HTSprintf0(&enable_file_name, "%s/%s", filename, HT_DIR_ENABLE_FILE);
		if (HTStat(enable_file_name, &stat_info) == -1) {
		    FREE(filename);
		    FREE(nodename);
		    FREE(enable_file_name);
		    return HTLoadError(sink, 403, DISALLOWED_SELECTIVE_ACCESS);
		}
	    }

	    FREE(filename);
	    FREE(nodename);
	    return HTVMSBrowseDir(addr, anchor, format_out, sink);
	}
    }

    if (decompressAndParse(anchor,
			   format_out,
			   sink,
			   nodename,
			   filename,
			   myEncoding,
			   format,
			   &status)) {
	FREE(nodename);
	FREE(filename);
	return status;
    }
    FREE(filename);

#else /* not VMS: */

    FREE(filename);

    /*
     * For unix, we try to translate the name into the name of a transparently
     * mounted file.
     *
     * Not allowed in secure (HTClientHost) situations.  TBL 921019
     */
#ifndef NO_UNIX_IO
    /*  Need protection here for telnet server but not httpd server. */

    if (!HTSecure) {		/* try local file system */
	char *localname = HTLocalName(addr);
	struct stat dir_info;

#ifdef HAVE_READDIR
	/*
	 * Multiformat handling.
	 *
	 * If needed, scan directory to find a good file.  Bug:  We don't stat
	 * the file to find the length.
	 */
	if ((strlen(localname) > strlen(MULTI_SUFFIX)) &&
	    (0 == strcmp(localname + strlen(localname) - strlen(MULTI_SUFFIX),
			 MULTI_SUFFIX))) {
	    DIR *dp = 0;
	    BOOL forget_multi = NO;

	    STRUCT_DIRENT *dirbuf;
	    float best = (float) NO_VALUE_FOUND;	/* So far best is bad */
	    HTFormat best_rep = NULL;	/* Set when rep found */
	    HTAtom *best_enc = NULL;
	    char *best_name = NULL;	/* Best dir entry so far */

	    char *base = strrchr(localname, '/');
	    size_t baselen = 0;

	    if (!base || base == localname) {
		forget_multi = YES;
	    } else {
		*base++ = '\0';	/* Just got directory name */
		baselen = strlen(base) - strlen(MULTI_SUFFIX);
		base[baselen] = '\0';	/* Chop off suffix */

		dp = opendir(localname);
	    }
	    if (forget_multi || !dp) {
		FREE(localname);
		FREE(nodename);
		return HTLoadError(sink, 500, FAILED_DIR_SCAN);
	    }

	    while ((dirbuf = readdir(dp)) != NULL) {
		/*
		 * While there are directory entries to be read...
		 */
#ifdef STRUCT_DIRENT__D_INO
		if (dirbuf->d_ino == 0)
		    continue;	/* if the entry is not being used, skip it */
#endif
		if (strlen(dirbuf->d_name) > baselen &&		/* Match? */
		    !StrNCmp(dirbuf->d_name, base, baselen)) {
		    HTAtom *enc;
		    HTFormat rep = HTFileFormat(dirbuf->d_name, &enc, NULL);
		    float filevalue = HTFileValue(dirbuf->d_name);
		    float value = HTStackValue(rep, format_out,
					       filevalue,
					       0L /* @@@@@@@@@@@@ */ );

		    if (value <= 0.0) {
			int rootlen = 0;
			const char *atomname = NULL;
			CompressFileType cft =
			HTCompressFileType(dirbuf->d_name, ".", &rootlen);
			char *cp = NULL;

			enc = NULL;
			if (cft != cftNone) {
			    StrAllocCopy(cp, dirbuf->d_name);
			    cp[rootlen] = '\0';
			    format = HTFileFormat(cp, NULL, NULL);
			    FREE(cp);
			    value = HTStackValue(format, format_out,
						 filevalue, 0L);
			}
			switch (cft) {
			case cftCompress:
			    atomname = "application/x-compressed";
			    break;
			case cftGzip:
			    atomname = "application/x-gzip";
			    break;
			case cftDeflate:
			    atomname = "application/x-deflate";
			    break;
			case cftBzip2:
			    atomname = "application/x-bzip2";
			    break;
			case cftNone:
			    break;
			}

			if (atomname != NULL) {
			    value = HTStackValue(format, format_out,
						 filevalue, 0L);
			    if (value <= 0.0) {
				format = HTAtom_for(atomname);
				value = HTStackValue(format, format_out,
						     filevalue, 0L);
			    }
			    if (value <= 0.0) {
				format = HTAtom_for("www/compressed");
				value = HTStackValue(format, format_out,
						     filevalue, 0L);
			    }
			}
		    }
		    if (value < NO_VALUE_FOUND) {
			CTRACE((tfp,
				"HTLoadFile: value of presenting %s is %f\n",
				HTAtom_name(rep), value));
			if (value > best) {
			    best_rep = rep;
			    best_enc = enc;
			    best = value;
			    StrAllocCopy(best_name, dirbuf->d_name);
			}
		    }		/* if best so far */
		}
		/* if match */
	    }			/* end while directory entries left to read */
	    closedir(dp);

	    if (best_rep) {
		format = best_rep;
		myEncoding = best_enc;
		base[-1] = '/';	/* Restore directory name */
		base[0] = '\0';
		StrAllocCat(localname, best_name);
		FREE(best_name);
	    } else {		/* If not found suitable file */
		FREE(localname);
		FREE(nodename);
		return HTLoadError(sink, 403, FAILED_NO_REPRESENTATION);
	    }
	    /*NOTREACHED */
	}
	/* if multi suffix */
	/*
	 * Check to see if the 'localname' is in fact a directory.  If it is
	 * create a new hypertext object containing a list of files and
	 * subdirectories contained in the directory.  All of these are links
	 * to the directories or files listed.  NB This assumes the existence
	 * of a type 'STRUCT_DIRENT', which will hold the directory entry, and
	 * a type 'DIR' which is used to point to the current directory being
	 * read.
	 */
#if defined(USE_DOS_DRIVES)
	if (strlen(localname) == 2 && LYIsDosDrive(localname))
	    LYAddPathSep(&localname);
#endif
	if (HTStat(localname, &dir_info) == -1)		/* get file information */
	{
	    /* if can't read file information */
	    CTRACE((tfp, "HTLoadFile: can't stat %s\n", localname));

	} else {		/* Stat was OK */

	    if (S_ISDIR(dir_info.st_mode)) {
		/*
		 * If localname is a directory.
		 */
		DIR *dp;
		struct stat file_info;

		CTRACE((tfp, "%s is a directory\n", localname));

		/*
		 * Check directory access.  Selective access means only those
		 * directories containing a marker file can be browsed.
		 */
		if (HTDirAccess == HT_DIR_FORBID) {
		    FREE(localname);
		    FREE(nodename);
		    return HTLoadError(sink, 403, DISALLOWED_DIR_SCAN);
		}

		if (HTDirAccess == HT_DIR_SELECTIVE) {
		    char *enable_file_name = NULL;

		    HTSprintf0(&enable_file_name, "%s/%s", localname, HT_DIR_ENABLE_FILE);
		    if (stat(enable_file_name, &file_info) != 0) {
			FREE(localname);
			FREE(nodename);
			FREE(enable_file_name);
			return HTLoadError(sink, 403, DISALLOWED_SELECTIVE_ACCESS);
		    }
		}

		CTRACE((tfp, "Opening directory %s\n", localname));
		dp = opendir(localname);
		if (!dp) {
		    FREE(localname);
		    FREE(nodename);
		    return HTLoadError(sink, 403, FAILED_DIR_UNREADABLE);
		}

		/*
		 * Directory access is allowed and possible.
		 */

		status = print_local_dir(dp, localname,
					 anchor, format_out, sink);
		closedir(dp);
		FREE(localname);
		FREE(nodename);
		return status;	/* document loaded, maybe partial */

	    }
	    /* end if localname is a directory */
	    if (S_ISREG(dir_info.st_mode)) {
#ifdef LONG_MAX
		if (dir_info.st_size <= LONG_MAX)
#endif
		    anchor->content_length = (long) dir_info.st_size;
	    }

	}			/* end if file stat worked */

/* End of directory reading section
*/
#endif /* HAVE_READDIR */
	if (decompressAndParse(anchor,
			       format_out,
			       sink,
			       nodename,
			       localname,
			       myEncoding,
			       format,
			       &status)) {
	    FREE(nodename);
	    FREE(localname);
	    return status;
	}
	FREE(localname);
    }				/* local unix file system */
#endif /* !NO_UNIX_IO */
#endif /* VMS */

#ifndef DECNET
    /*
     * Now, as transparently mounted access has failed, we try FTP.
     */
    {
	/*
	 * Deal with case-sensitivity differences on VMS versus Unix.
	 */
#ifdef VMS
	if (strcasecomp(nodename, HTHostName()) != 0)
#else
	if (strcmp(nodename, HTHostName()) != 0)
#endif /* VMS */
	{
	    status = -1;
	    FREE(nodename);
	    if (StrNCmp(addr, "file://localhost", 16)) {
		/* never go to ftp site when URL
		 * is file://localhost
		 */
#ifndef DISABLE_FTP
		status = HTFTPLoad(addr, anchor, format_out, sink);
#endif /* DISABLE_FTP */
	    }
	    return status;
	}
	FREE(nodename);
    }
#endif /* !DECNET */

    /*
     * All attempts have failed.
     */
    {
	CTRACE((tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO));

	return HTLoadError(sink, 403, FAILED_FILE_UNREADABLE);
    }
}

static const char *program_paths[pp_Last];

/*
 * Given a program number, return its path
 */
const char *HTGetProgramPath(ProgramPaths code)
{
    const char *result = NULL;

    if (code > ppUnknown && code < pp_Last)
	result = program_paths[code];
    return result;
}

/*
 * Store a program's path.  The caller must allocate the string used for 'path',
 * since HTInitProgramPaths() may free it.
 */
void HTSetProgramPath(ProgramPaths code, const char *path)
{
    if (code > ppUnknown && code < pp_Last) {
	program_paths[code] = isEmpty(path) ? 0 : path;
    }
}

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
void HTInitProgramPaths(BOOL init)
{
    ProgramPaths code;
    int n;
    const char *path;
    const char *test;

    for (n = (int) ppUnknown + 1; n < (int) pp_Last; ++n) {
	switch (code = (ProgramPaths) n) {
#ifdef BZIP2_PATH
	case ppBZIP2:
	    path = BZIP2_PATH;
	    break;
#endif
#ifdef CHMOD_PATH
	case ppCHMOD:
	    path = CHMOD_PATH;
	    break;
#endif
#ifdef COMPRESS_PATH
	case ppCOMPRESS:
	    path = COMPRESS_PATH;
	    break;
#endif
#ifdef COPY_PATH
	case ppCOPY:
	    path = COPY_PATH;
	    break;
#endif
#ifdef CSWING_PATH
	case ppCSWING:
	    path = CSWING_PATH;
	    break;
#endif
#ifdef GZIP_PATH
	case ppGZIP:
	    path = GZIP_PATH;
	    break;
#endif
#ifdef INFLATE_PATH
	case ppINFLATE:
	    path = INFLATE_PATH;
	    break;
#endif
#ifdef INSTALL_PATH
	case ppINSTALL:
	    path = INSTALL_PATH;
	    break;
#endif
#ifdef MKDIR_PATH
	case ppMKDIR:
	    path = MKDIR_PATH;
	    break;
#endif
#ifdef MV_PATH
	case ppMV:
	    path = MV_PATH;
	    break;
#endif
#ifdef RLOGIN_PATH
	case ppRLOGIN:
	    path = RLOGIN_PATH;
	    break;
#endif
#ifdef RM_PATH
	case ppRM:
	    path = RM_PATH;
	    break;
#endif
#ifdef RMDIR_PATH
	case ppRMDIR:
	    path = RMDIR_PATH;
	    break;
#endif
#ifdef SETFONT_PATH
	case ppSETFONT:
	    path = SETFONT_PATH;
	    break;
#endif
#ifdef TAR_PATH
	case ppTAR:
	    path = TAR_PATH;
	    break;
#endif
#ifdef TELNET_PATH
	case ppTELNET:
	    path = TELNET_PATH;
	    break;
#endif
#ifdef TN3270_PATH
	case ppTN3270:
	    path = TN3270_PATH;
	    break;
#endif
#ifdef TOUCH_PATH
	case ppTOUCH:
	    path = TOUCH_PATH;
	    break;
#endif
#ifdef UNCOMPRESS_PATH
	case ppUNCOMPRESS:
	    path = UNCOMPRESS_PATH;
	    break;
#endif
#ifdef UNZIP_PATH
	case ppUNZIP:
	    path = UNZIP_PATH;
	    break;
#endif
#ifdef UUDECODE_PATH
	case ppUUDECODE:
	    path = UUDECODE_PATH;
	    break;
#endif
#ifdef ZCAT_PATH
	case ppZCAT:
	    path = ZCAT_PATH;
	    break;
#endif
#ifdef ZIP_PATH
	case ppZIP:
	    path = ZIP_PATH;
	    break;
#endif
	default:
	    path = NULL;
	    break;
	}
	test = HTGetProgramPath(code);
	if (test != NULL && test != path) {
	    free(DeConst(test));
	}
	if (init) {
	    HTSetProgramPath(code, path);
	}
    }
}

/*
 *	Protocol descriptors
 */
#ifdef GLOBALDEF_IS_MACRO
#define _HTFILE_C_1_INIT { "ftp", HTLoadFile, 0 }
GLOBALDEF(HTProtocol, HTFTP, _HTFILE_C_1_INIT);
#define _HTFILE_C_2_INIT { "file", HTLoadFile, HTFileSaveStream }
GLOBALDEF(HTProtocol, HTFile, _HTFILE_C_2_INIT);
#else
GLOBALDEF HTProtocol HTFTP =
{"ftp", HTLoadFile, 0};
GLOBALDEF HTProtocol HTFile =
{"file", HTLoadFile, HTFileSaveStream};
#endif /* GLOBALDEF_IS_MACRO */
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTFile.c,v 1.120 2009/04/08 19:44:19 tom Exp $
d34 2
a35 1
/* #define NO_PARENT_DIR_REFERENCE *//* Define this for no parent links */
d151 2
a152 2
#define NO_SUFFIX      "*"
#define UNKNOWN_SUFFIX "*.*"
d161 1
a161 1
    NO_SUFFIX, NULL, NULL, NULL, 1.0
d166 1
a166 1
    UNKNOWN_SUFFIX, NULL, NULL, NULL, 1.0
d176 10
d204 18
d339 1
a339 1
		(len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
d363 1
a363 1
			if (!strncmp(HTAtom_name(format),
d366 1
a366 1
			    if (!strncmp(cp2, "x-", 2))
d397 1
a397 1
	    FormatNum(&buf, start, (int) data->file_info.st_size);
d408 1
a408 1
	    FormatNum(&buf, start, (int) ((data->file_info.st_size + 1023) / 1024));
d473 1
a473 1
	    name = HTAA_UidToName(data->file_info.st_uid);
d484 1
a484 1
	    name = HTAA_GidToName(data->file_info.st_gid);
d540 1
a540 1
    if (strcmp(suffix, NO_SUFFIX) == 0)
d542 1
a542 1
    else if (strcmp(suffix, UNKNOWN_SUFFIX) == 0)
d559 2
a560 4
	    /*
	     * Memory leak fixed.
	     * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	     */
d669 2
a670 2
		       BOOL expand_all,
		       BOOL is_remote GCC_UNUSED)
d708 2
a709 2
		       BOOL WWW_prefix,
		       BOOL expand_all)
d777 1
a777 1
    if (0 == strncmp("/private/Net/", name, 13)) {
d781 1
a781 1
    if (0 == strncmp(HTMountRoot, name, 5)) {
d829 2
a830 2
	     (strchr(suff->suffix + 1, '.') == NULL &&
	      strchr(suff->suffix + 1, '*') == NULL)) &&
d864 1
a864 1
    const char *version = strchr(filename, ';');
d899 1
d903 11
d927 1
a927 1
    lf = strlen(filename);
d933 1
a933 1
	ls = strlen(suff->suffix);
d948 1
a948 1
		ls2 = strlen(suff->suffix);
d969 1
a969 1
    suff = (strchr(filename, '.')
d1005 1
a1005 1
    if (((cp1 = strchr(cp, ';')) != NULL) &&
d1093 1
a1093 1
	    BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
d1096 3
a1098 3
					     !strncmp(cp4, "windows-", 8) ||
					     !strncmp(cp4, "cp12", 4) ||
					     !strncmp(cp4, "cp-12", 5));
a1193 1
    file_csname = file_anchor->charset;
d1197 1
d1235 1
a1235 1
    int lf = strlen(filename);
d1246 1
a1246 1
	ls = strlen(suff->suffix);
d1265 4
a1268 2
    size_t len = strlen(filename);
    const char *ftype = filename + len;
d1270 7
a1276 1
    VMS_DEL_VERSION(filename);
d1278 25
a1302 21
    if ((len > 4)
	&& !strcasecomp((ftype - 3), "bz2")
	&& strchr(dots, ftype[-4]) != 0) {
	result = cftBzip2;
	ftype -= 4;
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "gz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftGzip;
	ftype -= 3;
    } else if ((len > 3)
	       && !strcasecomp((ftype - 2), "zz")
	       && strchr(dots, ftype[-3]) != 0) {
	result = cftDeflate;
	ftype -= 3;
    } else if ((len > 2)
	       && !strcmp((ftype - 1), "Z")
	       && strchr(dots, ftype[-2]) != 0) {
	result = cftCompress;
	ftype -= 2;
    }
d1304 1
a1304 1
    *rootlen = (ftype - filename);
d1306 3
a1308 2
    CTRACE((tfp, "HTCompressFileType(%s) returns %d:%s\n",
	    filename, (int) result, filename + *rootlen));
d1529 1
a1529 1
	if (((len = strlen(escaped)) > 2) &&
d1604 1
a1604 1
		 BOOL tildeIsTop)
d1627 1
a1627 1
    if (tildeIsTop && !strncmp(path, "/~", 2)) {
d1701 2
a1702 2
	     (cp = strchr(printable, '.')) != NULL &&
	     strchr(cp, '/') == NULL) ||
d1704 1
a1704 1
	     strchr(printable, '/') == NULL)) {
d1869 1
a1869 1
    type = strchr(path, '.');
d1932 1
a1932 1
    char *p;
d2144 3
a2146 2
		test = (DIRED_BLOK(HTBTree_object(next_element))
			== 'D' ? 'D' : 'F');
d2321 90
d2445 1
d2452 1
a2452 1
    localname = (strchr(localname + 1, '/')
d2502 4
a2505 2
		fclose(fp);
		gzfp = gzopen(localname, BIN_R);
d2507 3
a2509 2
		CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			localname, gzfp));
d2512 3
a2514 2
		zzfp = fp;
		fp = 0;
d2516 3
a2518 2
		CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			localname, (void *) zzfp));
d2524 4
a2527 2
		fclose(fp);
		bzfp = BZ2_bzopen(localname, BIN_R);
d2529 3
a2531 2
		CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			localname, bzfp));
d2564 3
a2566 2
		    zzfp = fp;
		    fp = 0;
d2568 3
a2570 2
		    CTRACE((tfp, "HTLoadFile: zzopen of `%s' gives %p\n",
			    localname, (void *) zzfp));
d2581 4
a2584 2
		    fclose(fp);
		    gzfp = gzopen(localname, BIN_R);
d2586 3
a2588 2
		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
			    localname, gzfp));
d2599 4
a2602 2
		    fclose(fp);
		    bzfp = BZ2_bzopen(localname, BIN_R);
d2604 3
a2606 2
		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
			    localname, bzfp));
d2686 2
d2689 1
d2691 1
a2691 1
	return TRUE;
d2693 1
a2693 1
    return FALSE;
d2890 1
a2890 1
	    unsigned baselen = 0;
d2916 1
a2916 1
		    !strncmp(dirbuf->d_name, base, baselen)) {
d2938 17
a2954 17
						 filevalue, 0);
			    switch (cft) {
			    case cftCompress:
				atomname = "application/x-compressed";
				break;
			    case cftGzip:
				atomname = "application/x-gzip";
				break;
			    case cftDeflate:
				atomname = "application/x-deflate";
				break;
			    case cftBzip2:
				atomname = "application/x-bzip2";
				break;
			    case cftNone:
				break;
			    }
d2959 1
a2959 1
						 filevalue, 0);
d2963 1
a2963 1
						     filevalue, 0);
d2968 1
a2968 1
						     filevalue, 0);
d3120 1
a3120 1
	    if (strncmp(addr, "file://localhost", 16)) {
d3172 1
a3172 1
void HTInitProgramPaths(void)
d3302 4
a3305 1
	    free((char *) test);
a3306 1
	HTSetProgramPath(code, path);
@


1.8
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			File Access				HTFile.c
d115 4
a118 4
#define PUTC(c) (*target->isa->put_character)(target, c)
#define PUTS(s) (*target->isa->put_string)(target, s)
#define START(e) (*target->isa->start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*target->isa->end_element)(target, e, 0)
d121 1
a121 1
#define FREE_TARGET (*target->isa->_free)(target)
d150 3
d157 1
d159 4
a162 1
{"*", NULL, NULL, NULL, 1.0};
d164 3
a166 1
{"*.*", NULL, NULL, NULL, 1.0};
d255 1
a255 1
#ifdef S_ISVTX
d511 1
a511 1
    if (strcmp(suffix, "*") == 0)
d513 1
a513 1
    else if (strcmp(suffix, "*.*") == 0)
d709 1
a709 1
	if ((home = LYGetEnv("HOME")) == 0)
d719 1
a719 1
	if (home == 0)
d930 5
a934 3
    suff = strchr(filename, '.') ?	/* Unknown suffix */
	(unknown_suffix.rep ? &unknown_suffix : &no_suffix)
	: &no_suffix;
d1261 56
d1328 1
a1328 1
    if (coding == 0) {
d1346 37
d1393 1
a1393 1
BOOL HTEditable(const char *filename)
a1793 3
	HTStructuredClass targetClass;

	targetClass = *target->isa;	/* (Can't init agregate in K&R) */
a1880 1
    BOOL present[HTML_A_ATTRIBUTES];
a1884 1
    int i;
d1900 1
a1900 1
    if ((p = strrchr(pathname, '/')) == 0)
a1914 3
    for (i = 0; i < HTML_A_ATTRIBUTES; i++)
	present[i] = (BOOL) (i == HTML_A_HREF);

d2027 1
a2027 2
			      partial_threshold : display_lines)
	    == 0) {
d2186 3
a2188 2
		(partial_threshold > 0 ? partial_threshold : display_lines)
		== 0) {
a2189 1
		/* HTReadProgress...(bytes, 0); */
d2332 1
a2332 1
    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n", localname, fp));
d2351 1
d2353 1
d2369 1
a2369 1
			localname, zzfp));
d2416 1
a2416 1
			    localname, zzfp));
d2462 1
a2462 1
		failed_decompress = (zzfp == 0);
d2466 1
a2466 1
		failed_decompress = (gzfp == 0);
d2471 1
a2471 1
		failed_decompress = (bzfp == 0);
d2594 1
a2594 1
		ftp_local_passive = !ftp_passive;
d2727 1
a2727 1
	    int baselen = 0;
d2752 1
a2752 1
		if ((int) strlen(dirbuf->d_name) > baselen &&	/* Match? */
d2809 1
a2809 1
		    if (value != NO_VALUE_FOUND) {
d2913 2
a2914 2
#ifdef INT_MAX
		if (dir_info.st_size <= INT_MAX)
d2916 1
a2916 1
		    anchor->content_length = dir_info.st_size;
@


1.7
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 20
a21 20
**			===========
**
**	This is unix-specific code in general, with some VMS bits.
**	These are routines for file access used by browsers.
**	Development of this module for Unix DIRED_SUPPORT in Lynx
**	 regrettably has has been conducted in a manner with now
**	 creates a major impediment for hopes of adapting Lynx to
**	 a newer version of the library.
**
**  History:
**	   Feb 91	Written Tim Berners-Lee CERN/CN
**	   Apr 91	vms-vms access included using DECnet syntax
**	26 Jun 92 (JFG) When running over DECnet, suppressed FTP.
**			Fixed access bug for relative names on VMS.
**	   Sep 93 (MD)	Access to VMS files allows sharing.
**	15 Nov 93 (MD)	Moved HTVMSname to HTVMSUTILS.C
**	27 Dec 93 (FM)	FTP now works with VMS hosts.
**			FTP path must be Unix-style and cannot include
**			the device or top directory.
*/
d28 2
a29 2
#define LONG_LIST  /* Define this for long style unix listings (ls -l),
		     the actual style is configurable from lynx.cfg */
d31 1
a31 1
/* #define NO_PARENT_DIR_REFERENCE */ /* Define this for no parent links */
d77 5
d85 5
a89 5
	char *		suffix;
	HTAtom *	rep;
	HTAtom *	encoding;
	char *		desc;
	float		quality;
d95 1
a95 1
    char file_name[1];	/* on the end of the struct, since its length varies */
d122 2
a123 2
	CONST HTStructuredClass *	isa;
	/* ... */
d127 3
a129 3
**  Controlling globals.
*/
PUBLIC int HTDirAccess = HT_DIR_OK;
d132 2
a133 1
PUBLIC int HTDirReadme = HT_DIR_README_NONE;
d135 1
a135 1
PUBLIC int HTDirReadme = HT_DIR_README_TOP;
d138 2
a139 1
PRIVATE char *HTMountRoot = "/Net/";		/* Where to find mounts */
d141 2
a142 1
PRIVATE char *HTCacheRoot = "/WWW$SCRATCH";	/* Where to cache things */
d144 1
a144 1
PRIVATE char *HTCacheRoot = "/tmp/W3_Cache_";	/* Where to cache things */
d148 7
a154 6
**  Suffix registration.
*/
PRIVATE HTList * HTSuffixes = 0;
PRIVATE HTSuffix no_suffix = { "*", NULL, NULL, NULL, 1.0 };
PRIVATE HTSuffix unknown_suffix = { "*.*", NULL, NULL, NULL, 1.0};

d157 2
a158 2
**	----------------------------------------
*/
d160 1
a160 1
PRIVATE void free_suffixes NOPARAMS;
d164 3
a166 4
PRIVATE char *FormatStr ARGS3(
    char **,	bufp,
    char *,	start,
    CONST char *,	entry)
d169 1
d181 3
a183 4
PRIVATE char *FormatNum ARGS3(
    char **,	bufp,
    char *,	start,
    int,	entry)
d186 1
d197 15
a211 15
PRIVATE void LYListFmtParse ARGS5(
	char *,		fmtstr,
	DIRED *,	data,
	char *,		file,
	HTStructured *, target,
	char *,		tail)
{
	char c;
	char *s;
	char *end;
	char *start;
	char *str = NULL;
	char *buf = NULL;
	char tmp[LY_MAXPATH];
	char type;
d213 1
a213 1
	char *name;
d215 3
a217 2
	time_t now;
	char *datestr;
d219 1
a219 1
	int len;
d223 7
a229 5
#ifdef _WINDOWS	/* 1998/01/06 (Tue) 21:20:53 */
	static char *pbits[] = {
		"---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx",
		0 };
d233 7
a239 4
	static char *pbits[] = { "---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx", 0 };
	static char *psbits[] = { "--S", "--s", "-wS", "-ws",
		"r-S", "r-s", "rwS", "rws", 0 };
d244 4
a247 2
	static char *ptbits[] = { "--T", "--t", "-wT", "-wt",
		"r-T", "r-t", "rwT", "rwt", 0 };
d253 2
a254 2
	if (data->file_info.st_mode == 0)
		fmtstr = "    %a";	/* can't stat so just do anchor */
d256 5
a260 4
	StrAllocCopy(str, fmtstr);
	s = str;
	end = str + strlen(str);
	START(HTML_PRE);
d262 34
a295 36
		start = s;
		while (*s) {
			if (*s == '%') {
				if (*(s+1) == '%') /* literal % */
					s++;
				else
					break;
			}
			s++;
		}
		/* s is positioned either at a % or at \0 */
		*s = '\0';
		if (s > start) {	/* some literal chars. */
			PUTS(start);
		}
		if (s == end)
			break;
		start = ++s;
		while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
		    *s == '#' || *s == '+' || *s == '\'')
			s++;
		c = *s;		/* the format char. or \0 */
		*s = '\0';

		switch (c) {
		case '\0':
			PUTS(start);
			continue;

		case 'A':
		case 'a':	/* anchor */
			HTDirEntry(target, tail, data->file_name);
			FormatStr(&buf, start, data->file_name);
			PUTS(buf);
			END(HTML_A);
			*buf = '\0';
d297 6
a302 6
			if (c != 'A' && S_ISLNK(data->file_info.st_mode) &&
			    (len = readlink(file, tmp, sizeof(tmp) - 1)) >= 0) {
				PUTS(" -> ");
				tmp[len] = '\0';
				PUTS(tmp);
			}
d304 13
a316 1
			break;
d318 9
a326 25
		case 'T':	/* MIME type */
		case 't':	/* MIME type description */
		    if (S_ISDIR(data->file_info.st_mode)) {
			if (c != 'T') {
			    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
			} else {
			    FormatStr(&buf, start, "");
			}
		    } else {
			CONST char *cp2;
			HTFormat format;
			format = HTFileFormat(file, NULL, &cp2);

			if (c != 'T') {
			    if (cp2 == NULL) {
				if (!strncmp(HTAtom_name(format),
					     "application",11)) {
				    cp2 = HTAtom_name(format) + 12;
				    if (!strncmp(cp2,"x-",2))
					cp2 += 2;
				} else {
				    cp2 = HTAtom_name(format);
				}
			    }
			    FormatStr(&buf, start, cp2);
d328 1
a328 1
			    FormatStr(&buf, start, HTAtom_name(format));
d331 27
a357 1
		    break;
d359 11
a369 32
		case 'd':	/* date */
			now = time(0);
			datestr = ctime(&data->file_info.st_mtime);
			if ((now - data->file_info.st_mtime) < SEC_PER_YEAR/2)
				/*
				**  MMM DD HH:MM
				*/
				sprintf(tmp, "%.12s", datestr + 4);
			else
				/*
				**  MMM DD  YYYY
				*/
				sprintf(tmp, "%.7s %.4s ", datestr + 4,
					datestr + 20);
			FormatStr(&buf, start, tmp);
			break;

		case 's':	/* size in bytes */
			FormatNum(&buf, start, (int) data->file_info.st_size);
			break;

		case 'K':	/* size in Kilobytes but not for directories */
			if (S_ISDIR(data->file_info.st_mode)) {
				FormatStr(&buf, start, "");
				StrAllocCat(buf, " ");
				break;
			}
			/* FALL THROUGH */
		case 'k':	/* size in Kilobytes */
			FormatNum(&buf, start, (int)((data->file_info.st_size+1023)/1024));
			StrAllocCat(buf, "K");
			break;
d371 2
a372 2
		case 'p':	/* unix-style permission bits */
			switch(data->file_info.st_mode & S_IFMT) {
d374 3
a376 1
			case _S_IFIFO: type = 'p'; break;
d378 3
a380 1
			case S_IFIFO: type = 'p'; break;
d382 9
a390 3
			case S_IFCHR: type = 'c'; break;
			case S_IFDIR: type = 'd'; break;
			case S_IFREG: type = '-'; break;
d392 3
a394 1
			case S_IFBLK: type = 'b'; break;
d397 3
a399 1
			case S_IFLNK: type = 'l'; break;
d402 1
a402 1
# ifdef S_IFIFO		/* some older machines (e.g., apollo) have a conflict */
d404 3
a406 1
			case S_IFSOCK: type = 's'; break;
d409 3
a411 1
			case S_IFSOCK: type = 's'; break;
d414 4
a417 2
			default: type = '?'; break;
			}
d419 2
a420 2
			sprintf(tmp, "%c%s", type,
				PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_IRWXU));
d422 4
a425 4
			sprintf(tmp, "%c%s%s%s", type,
				PBIT(data->file_info.st_mode, 6, data->file_info.st_mode & S_ISUID),
				PBIT(data->file_info.st_mode, 3, data->file_info.st_mode & S_ISGID),
				PTBIT(data->file_info.st_mode,   data->file_info.st_mode & S_ISVTX));
d427 2
a428 2
			FormatStr(&buf, start, tmp);
			break;
d430 1
a430 1
		case 'o':	/* owner */
d432 6
a437 6
			name = HTAA_UidToName (data->file_info.st_uid);
			if (*name) {
				FormatStr(&buf, start, name);
			} else {
				FormatNum(&buf, start, (int) data->file_info.st_uid);
			}
d439 1
a439 1
			break;
d441 1
a441 1
		case 'g':	/* group */
d443 6
a448 6
			name = HTAA_GidToName(data->file_info.st_gid);
			if (*name) {
				FormatStr(&buf, start, name);
			} else {
				FormatNum(&buf, start, (int) data->file_info.st_gid);
			}
d450 5
a454 1
			break;
d456 3
a458 15
		case 'l':	/* link count */
			FormatNum(&buf, start, (int) data->file_info.st_nlink);
			break;

		case '%':	/* literal % with flags/width */
			FormatStr(&buf, start, "%");
			break;

		default:
			fprintf(stderr,
			"Unknown format character `%c' in list format\n", c);
			break;
		}
		if (buf)
		    PUTS(buf);
d460 4
a463 1
		s++;
d465 8
a472 4
	FREE(buf);
	END(HTML_PRE);
	PUTC('\n');
	FREE(str);
d477 18
a494 19
**	--------------------------------------------------------
**
**	Calling this with suffix set to "*" will set the default
**	representation.
**	Calling this with suffix set to "*.*" will set the default
**	representation for unknown suffix files which contain a ".".
**
**	The encoding parameter can give a trivial (8bit, 7bit, binary)
**	or real (gzip, compress) encoding.
**
**	If filename suffix is already defined with the same encoding
**	its previous definition is overridden.
*/
PUBLIC void HTSetSuffix5 ARGS5(
	CONST char *,	suffix,
	CONST char *,	representation,
	CONST char *,	encoding,
	CONST char *,	desc,
	double,		value)
d496 1
a496 1
    HTSuffix * suff;
d506 1
a506 1
	while (NULL != (suff = (HTSuffix*)HTList_nextObject(cur))) {
d510 1
a510 1
		     strcmp(encoding, HTAtom_name(suff->encoding)) == 0)))
d513 1
a513 1
	if (!suff) { /* Not found -- create a new node */
d519 4
a522 4
	    **	Memory leak fixed.
	    **	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	    */
	    if (!HTSuffixes)	{
d539 4
a542 4
    **	Memory leak fixed.
    **	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
    **	Invariant code removed.
    */
d552 9
a560 9
**	Purpose:	Free all added suffixes.
**	Arguments:	void
**	Return Value:	void
**	Remarks/Portability/Dependencies/Restrictions:
**		To be used at program exit.
**	Revision History:
**		05-28-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void free_suffixes NOARGS
d562 1
a562 1
    HTSuffix * suff = NULL;
d565 2
a566 2
    **	Loop through all suffixes.
    */
d569 3
a571 3
	**  Free off each item and its members if need be.
	*/
	suff = (HTSuffix *)HTList_removeLastObject(HTSuffixes);
d577 2
a578 2
    **	Free off the list itself.
    */
a583 1

d585 10
a594 11
**	-------------------------------------------
**	Make up a suitable name for saving the node in
**
**	E.g.	/tmp/WWW_Cache_news/1234@@cernvax.cern.ch
**		/tmp/WWW_Cache_http/crnvmc/FIND/xx.xxx.xx
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
PUBLIC char * HTCacheFileName ARGS1(
	CONST char *,	name)
d596 4
a599 4
    char * acc_method = HTParse(name, "", PARSE_ACCESS);
    char * host = HTParse(name, "", PARSE_HOST);
    char * path = HTParse(name, "", PARSE_PATH+PARSE_PUNCTUATION);
    char * result = NULL;
d610 2
a611 2
**	-----------------------------------------
*/
d613 1
a613 1
PRIVATE int HTCreatePath ARGS1(CONST char *,path)
d620 12
a631 13
**	----------------------------------------------------------
**	Input name is assumed to be the URL-path of a local file
**      URL, i.e. what comes after the "file://localhost".
**      '#'-fragments to be treated as such must already be stripped.
**      If expand_all is FALSE, unescape only escaped '/'. - kw
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
PUBLIC char * HTURLPath_toFile ARGS3(
	CONST char *,	name,
	BOOL,		expand_all,
	BOOL,		is_remote GCC_UNUSED)
d633 2
a634 2
    char * path = NULL;
    char * result = NULL;
d638 1
a638 1
	HTUnEscape(path);		/* Interpret all % signs */
d654 9
a662 9
**	------------------------------------------------
**	Make up a suitable name for saving the node in
**
**	E.g.	$(HOME)/WWW/news/1234@@cernvax.cern.ch
**		$(HOME)/WWW/http/crnvmc/FIND/xx.xxx.xx
**
**  On exit:
**	Returns a malloc'ed string which must be freed by the caller.
*/
d668 9
a676 10
PUBLIC char * HTnameOfFile_WWW ARGS3(
	CONST char *,	name,
	BOOL,		WWW_prefix,
	BOOL,		expand_all)
{
    char * acc_method = HTParse(name, "", PARSE_ACCESS);
    char * host = HTParse(name, "", PARSE_HOST);
    char * path = HTParse(name, "", PARSE_PATH+PARSE_PUNCTUATION);
    char * home;
    char * result = NULL;
d679 1
a679 1
	HTUnEscape(path);		/* Interpret all % signs */
d683 2
a684 2
    if (0 == strcmp(acc_method, "file")	/* local file */
     || !*acc_method) {			/* implicitly local? */
d695 1
a695 1
    } else if (WWW_prefix) {  /* other access */
d702 2
a703 2
#if defined(_WINDOWS)	/* 1997/10/16 (Thu) 20:42:51 */
	home =  (char *)Home_Dir();
d726 8
a733 9
**	--------------------------------------------
**
**  Bugs:
**	At present, only the names of two network root nodes are hand-coded
**	in and valid for the NeXT only.  This should be configurable in
**	the general case.
*/
PUBLIC char * WWW_nameOfFile ARGS1(
	CONST char *,	name)
d735 2
a736 1
    char * result = NULL;
d739 1
a739 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name+13);
d743 1
a743 1
	HTSprintf0(&result, "%s//%s", STR_FILE_URL, name+5);
d752 12
a763 13
**	------------------------------------------------------
**
**  On entry,
**	rep	is the atomized MIME style representation
**	enc	is an encoding, trivial (8bit, binary, etc.) or gzip etc.
**
**  On exit:
**	Returns a pointer to a suitable suffix string if one has been
**	found, else "".
*/
PUBLIC CONST char * HTFileSuffix ARGS2(
	HTAtom*,	rep,
	CONST char *,	enc)
d765 2
a766 1
    HTSuffix * suff;
d768 1
a768 1
    HTSuffix * first_found = NULL;
d774 1
a774 1
#define NO_INIT  /* don't init anymore since I do it in Lynx at startup */
d783 1
a783 1
	suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
d786 3
a788 3
	    /*	Don't return a suffix whose first char is a dot, and which
		has more dots or asterisks after that, for
		these systems - kw */
d799 2
a800 3
		 *  If length of suffix (including dot) is 4 or smaller,
		 *  return this one even if we found a longer one
		 *  earlier - kw
d804 1
a804 1
		first_found = suff;		/* remember this one */
d807 1
a807 1
	    return suff->suffix;		/* OK -- found */
d815 20
a834 1
    return "";		/* Dunno */
d836 4
d842 13
a854 14
**	-------------------------------------
**
**	This version will return the representation and also set
**	a variable for the encoding.
**
**	Encoding may be a unity encoding (binary, 8bit, etc.) or
**	a content-coding like gzip, compress.
**
**	It will handle for example  x.txt, x.txt,Z, x.Z
*/
PUBLIC HTFormat HTFileFormat ARGS3(
	CONST char *,	filename,
	HTAtom **,	pencoding,
	CONST char**,	pdesc)
d856 1
a856 1
    HTSuffix * suff;
d860 2
a861 3
#ifdef VMS
    char *semicolon = NULL;
#endif /* VMS */
a871 11

#ifdef VMS
    /*
    **	Trim at semicolon if a version number was
    **	included, so it doesn't interfere with the
    **	code for getting the MIME type. - FM
    */
    if ((semicolon = strchr(filename, ';')) != NULL)
	*semicolon = '\0';
#endif /* VMS */

d876 1
a876 1
    lf	= strlen(filename);
d880 2
a881 1
	suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
d885 1
d891 1
a891 5
#ifdef VMS
		if (semicolon != NULL)
		    *semicolon = ';';
#endif /* VMS */
		return suff->rep;		/* OK -- found */
d893 1
a893 1
	    for (j = 0; j < n; j++) {  /* Got encoding, need representation */
d895 2
a896 1
		suff = (HTSuffix *)HTList_objectAt(HTSuffixes, j);
d898 3
a900 2
		if ((ls + ls2 <= lf) && 0 == strncasecomp(
			suff->suffix, filename + lf - ls -ls2, ls2)) {
a907 4
#ifdef VMS
			if (semicolon != NULL)
			    *semicolon = ';';
#endif /* VMS */
d919 2
a920 2
	 ( unknown_suffix.rep ? &unknown_suffix : &no_suffix)
	 : &no_suffix;
d923 7
a929 9
    **	Set default encoding unless found with suffix already.
    */
    if (pencoding && !*pencoding)
	*pencoding = suff->encoding ? suff->encoding
				    : HTAtom_for("binary");
#ifdef VMS
    if (semicolon != NULL)
	*semicolon = ';';
#endif /* VMS */
d934 10
a943 11
**	-------------------------------------------------------
**
**	This checks the format associated with an anchor for
**	an extended MIME Content-Type, and if a charset is
**	indicated, sets Lynx up for proper handling in relation
**	to the currently selected character set. - FM
*/
PUBLIC HTFormat HTCharsetFormat ARGS3(
	HTFormat,		format,
	HTParentAnchor *,	anchor,
	int,			default_LYhndl)
d955 1
a955 1
		    format->name));
d959 1
a959 1
	StrAllocCopy(cp3, cp2); /* copy to mutilate more */
d961 1
a961 1
			 *cp4 != ';'  && *cp4 != ':' &&
d963 1
a963 1
	    ; /* do nothing */
d978 2
a979 2
	    **	Got something but we don't recognize it.
	    */
d982 5
a986 5
	    /*
	    **  UCLYhndl_for_unrec not defined :-(
	    **  fallback to UCLYhndl_for_unspec which always valid.
	    */
	    chndl = UCLYhndl_for_unspec;  /* always >= 0 */
d1001 1
d1004 2
a1005 2
		**  Try again.
		*/
d1036 15
a1050 21
	    **  Cannot translate.
	    **  If according to some heuristic the given
	    **  charset and the current display character
	    **  both are likely to be like ISO-8859 in
	    **  structure, pretend we have some kind
	    **  of match.
	    */
	    BOOL given_is_8859
		= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit(UCH(cp4[9])));
	    BOOL given_is_8859like
		= (BOOL) (given_is_8859 ||
		   !strncmp(cp4, "windows-", 8) ||
		   !strncmp(cp4, "cp12", 4) ||
		   !strncmp(cp4, "cp-12", 5));
	    BOOL given_and_display_8859like
		= (BOOL) (given_is_8859like &&
		   (strstr(LYchar_set_names[current_char_set],
			   "ISO-8859") ||
		    strstr(LYchar_set_names[current_char_set],
			   "windows-")));
d1072 3
a1074 4
	**  No charset parameter is present.
	**  Ignore all other parameters, as
	**  we do when charset is present. - FM
	*/
d1081 2
a1082 2
    **	Set up defaults, if needed. - FM
    */
d1089 3
a1091 3
			    UCT_STAGE_PARSER,
			    UCT_STAGE_MIME,
			    -1);
a1095 2


d1097 34
a1130 35
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
PUBLIC void LYGetFileInfo ARGS7(
	CONST char *,		filename,
	HTParentAnchor **,	pfile_anchor,
	HTFormat *,		pformat,
	HTAtom **,		pencoding,
	CONST char**,		pdesc,
	CONST char**,		pcharset,
	int *,			pfile_cs)
{
	char *Afn;
	char *Aname = NULL;
	HTFormat format;
	HTAtom * myEnc = NULL;
	HTParentAnchor *file_anchor;
	CONST char *file_csname;
	int file_cs;
d1132 18
a1149 38
	/*
	 *  Convert filename to URL.  Note that it is always supposed to
	 *  be a filename, not maybe-filename-maybe-URL, so we don't
	 *  use LYFillLocalFileURL and LYEnsureAbsoluteURL. - kw
	 */
	Afn = HTEscape(filename, URL_PATH);
	LYLocalFileToURL(&Aname, Afn);
	file_anchor = HTAnchor_findSimpleAddress(Aname);

	file_csname = file_anchor->charset;
	format = HTFileFormat(filename, &myEnc, pdesc);
	format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
	file_cs = HTAnchor_getUCLYhndl(file_anchor, UCT_STAGE_MIME);
	if (!file_csname) {
	    if (file_cs >= 0)
		file_csname = LYCharSet_UC[file_cs].MIMEname;
	    else file_csname = "display character set";
	}
	CTRACE((tfp, "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
	       filename,
	       ((myEnc && *HTAtom_name(myEnc) == '8') ? "n" : myEnc ? "" :
		*HTAtom_name(format) == 'a' ? "n" : ""),
	       myEnc ? HTAtom_name(myEnc) : "",
	       HTAtom_name(format),
	       file_csname,
	       file_cs));
	FREE(Afn);
	FREE(Aname);
	if (pfile_anchor)
	    *pfile_anchor = file_anchor;
	if (pformat)
	    *pformat = format;
	if (pencoding)
	    *pencoding = myEnc;
	if (pcharset)
	    *pcharset = file_csname;
	if (pfile_cs)
	    *pfile_cs = file_cs;
d1151 21
d1174 4
a1177 5
**	-------------------------------
**
*/
PUBLIC float HTFileValue ARGS1(
	CONST char *,	filename)
d1179 1
a1179 1
    HTSuffix * suff;
d1191 2
a1192 1
	suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
d1194 1
a1194 1
	if ((ls <= lf) && 0==strcmp(suff->suffix, filename + lf - ls)) {
d1196 2
a1197 2
			filename, suff->quality));
	    return suff->quality;		/* OK -- found */
d1200 1
a1200 1
    return (float)0.3;		/* Dunno! */
d1204 6
a1209 7
**  Determine compression type from file name, by looking at its suffix.
**  Sets as side-effect a pointer to the "dot" that begins the suffix.
*/
PUBLIC CompressFileType HTCompressFileType ARGS3(
	char *,		filename,
	char *,		dots,
	char **,	suffix)
d1213 3
a1215 1
    char *ftype = filename + len;
d1218 2
a1219 2
     && !strcasecomp((ftype - 3), "bz2")
     && strchr(dots, ftype[-4]) != 0) {
d1223 2
a1224 2
     && !strcasecomp((ftype - 2), "gz")
     && strchr(dots, ftype[-3]) != 0) {
d1227 5
d1233 2
a1234 2
     && !strcmp((ftype - 1), "Z")
     && strchr(dots, ftype[-2]) != 0) {
d1239 2
a1240 1
    *suffix = ftype;
d1242 31
a1272 1
		 filename, result, *suffix));
d1277 10
a1286 11
**	---------------------------------
**
**  On exit:
**	Returns YES if file can be accessed and can be written to.
**
**  Bugs:
**	1.	No code for non-unix systems.
**	2.	Isn't there a quicker way?
*/
PUBLIC BOOL HTEditable ARGS1(
	CONST char *,	filename)
d1290 2
a1291 2
    uid_t	myUid;
    int		ngroups;			/* The number of groups	 */
d1293 1
a1293 1
    int		i;
d1295 2
a1296 2
    if (stat(filename, &fileStatus))		/* Get details of filename */
	return NO;				/* Can't even access file! */
d1299 1
a1299 1
    myUid = geteuid();				/* Get my user identifier */
d1303 1
d1305 6
a1310 6
	    "File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",
	    (unsigned int) fileStatus.st_mode,
	    (int) fileStatus.st_uid,
	    (int) fileStatus.st_gid,
	    (int) myUid,
	    (int) ngroups);
d1316 1
a1316 1
    if (fileStatus.st_mode & 0002)		/* I can write anyway? */
d1319 2
a1320 2
    if ((fileStatus.st_mode & 0200)		/* I can write my own file? */
     && (fileStatus.st_uid == myUid))
d1323 1
a1323 1
    if (fileStatus.st_mode & 0020)		/* Group I am in can write? */
d1332 1
a1332 1
    return NO;					/* If no excuse, can't do */
d1336 6
a1341 7
**	-------------------
**
**	The stream must be used for writing back the file.
**	@@@@@@ no backup done
*/
PUBLIC HTStream * HTFileSaveStream ARGS1(
	HTParentAnchor *,	anchor)
d1343 3
a1345 3
    CONST char * addr = anchor->address;
    char * localname = HTLocalName(addr);
    FILE * fp = fopen(localname, BIN_W);
d1355 8
a1362 10
**	---------------------------
*/
PUBLIC void HTDirEntry ARGS3(
	HTStructured *, target,
	CONST char *,	tail,
	CONST char *,	entry)
{
    char * relative = NULL;
    char * stripped = NULL;
    char * escaped = NULL;
d1378 1
a1378 1
    if (tail == NULL || *tail == '\0') {
d1380 2
a1381 2
	**  Handle extra slash at end of path.
	*/
d1385 2
a1386 2
	**  If empty tail, gives absolute ref below.
	*/
d1389 3
a1391 3
			   tail,
			   (*escaped != '\0' ? "/" : ""),
			   escaped);
d1399 31
d1431 20
a1450 21
**	------------------------------
**
**    This gives the TITLE and H1 header, and also a link
**    to the parent directory if appropriate.
**
**  On exit:
**	Returns TRUE if an "Up to <parent>" link was not created
**	for a readable local directory because LONG_LIST is defined
**	and NO_PARENT_DIR_REFERENCE is not defined, so that the
**	calling function should use LYListFmtParse() to create a link
**	to the parent directory.  Otherwise, it returns FALSE. - FM
*/
PUBLIC BOOL HTDirTitles ARGS3(
	HTStructured *, target,
	HTParentAnchor *, anchor,
	BOOL,		tildeIsTop)
{
    CONST char * logical = anchor->address;
    char * path = HTParse(logical, "", PARSE_PATH + PARSE_PUNCTUATION);
    char * current;
    char * cp = NULL;
d1453 1
d1456 2
a1457 2
		     && !strncasecomp(logical, "file://localhost/", 17)
		     && LYIsDosDrive(logical + 17));
d1459 1
d1465 3
a1467 3
    **	Check tildeIsTop for treating home directory as Welcome
    **	(assume the tilde is not followed by a username). - FM
    */
d1480 2
a1481 2
    **	Trim out the ;type= parameter, if present. - FM
    */
d1483 4
a1486 4
	if (!strncasecomp((cp+1), "type=", 5)) {
	    if (TOUPPER(*(cp+6)) == 'D' ||
		TOUPPER(*(cp+6)) == 'A' ||
		TOUPPER(*(cp+6)) == 'I')
d1491 1
a1491 1
    current = LYPathLeaf (path);	/* last part or "" */
d1494 1
a1494 1
      char * printable = NULL;
d1497 11
a1507 12
      printable = HTURLPath_toFile(
	    (0 == strncasecomp(path, "/%2F", 4))	/* "//" ? */
	    ? (path+1)
	    : path,
	    TRUE,
	    is_remote);
      if (0 == strncasecomp(printable, "/vmsysu:", 8) ||
	  0 == strncasecomp(printable, "/anonymou.", 10)) {
	  StrAllocCopy(cp, (printable+1));
	  StrAllocCopy(printable, cp);
	  FREE(cp);
      }
d1509 2
a1510 2
      StrAllocCopy(printable, current);
      HTUnEscape(printable);
d1513 15
a1527 9
      START(HTML_HEAD);
      PUTC('\n');
      START(HTML_TITLE);
      PUTS(*printable ? printable : WELCOME_MSG);
      PUTS(SEGMENT_DIRECTORY);
      END(HTML_TITLE);
      PUTC('\n');
      END(HTML_HEAD);
      PUTC('\n');
d1530 10
a1539 10
      START(HTML_H2);
      PUTS(*printable ? SEGMENT_CURRENT_DIR : "");
      PUTS(*printable ? printable : WELCOME_MSG);
      END(HTML_H2);
      PUTC('\n');
#else
      START(HTML_H1);
      PUTS(*printable ? printable : WELCOME_MSG);
      END(HTML_H1);
      PUTC('\n');
d1541 10
a1550 10
      if (((0 == strncasecomp(printable, "vmsysu:", 7)) &&
	   (cp = strchr(printable, '.')) != NULL &&
	   strchr(cp, '/') == NULL) ||
	  (0 == strncasecomp(printable, "anonymou.", 9) &&
	   strchr(printable, '/') == NULL)) {
	  FREE(printable);
	  FREE(path);
	  return(need_parent_link);
      }
      FREE(printable);
d1555 2
a1556 2
    **	Make link back to parent directory.
    */
d1558 4
a1561 4
      && LYIsPathSep(current[-1])
      && current[0] != '\0') {	/* was a slash AND something else too */
	char * parent = NULL;
	char * relative = NULL;
d1564 1
a1564 1
	parent = strrchr(path, '/');  /* penultimate slash */
d1571 1
a1571 1
	    return(need_parent_link);
d1579 1
a1579 1
	    if (parent != 0 && strlen(parent) == 3 ) {
d1582 1
a1582 2
	}
	else
d1588 7
a1594 7
	    **	On Unix, if it's not ftp and the directory cannot
	    **	be read, don't put out a link.
	    **
	    **	On VMS, this problem is dealt with internally by
	    **	HTVMSBrowseDir().
	    */
	    DIR  * dp = NULL;
d1598 7
a1604 8
		**  We need an absolute file path for the opendir.
		**  We also need to unescape for this test.
		**  Don't worry about %2F now, they presumably have been
		**  dealt with above, and shouldn't appear for local
		**  files anyway...  Assume OS / filesystem will just
		**  ignore superfluous slashes. - KW
		*/
		char * fullparentpath = NULL;
d1607 2
a1608 2
		**  Path has been shortened above.
		*/
d1612 6
a1617 6
		**  Guard against weirdness.
		*/
		if (0 == strcmp(current,"..")) {
		    StrAllocCat(fullparentpath,"/../..");
		} else if (0 == strcmp(current,".")) {
		    StrAllocCat(fullparentpath,"/..");
d1625 1
a1625 1
		    return(need_parent_link);
d1633 1
a1633 1
		return(need_parent_link);
d1643 2
a1644 2
	    if ((0 == strcmp(current,".")) ||
		(0 == strcmp(current,".."))) {
d1646 3
a1648 3
		**  Should not happen, but if it does,
		**  at least avoid giving misleading info. - KW
		*/
d1651 2
a1652 1
		char * printable = NULL;
d1667 1
a1667 1
    return(need_parent_link);
d1672 5
a1676 5
**	-----------------
**
**  If a README file exists, then it is inserted into the document here.
*/
PRIVATE void do_readme ARGS2(HTStructured *, target, CONST char *, localname)
d1678 2
a1679 2
    FILE * fp;
    char * readme_file_name = NULL;
d1689 1
a1689 1
	targetClass =  *target->isa;	/* (Can't init agregate in K&R) */
d1692 1
a1692 1
	    PUTC((char)ch);
d1707 1
a1707 1
PRIVATE char *file_type ARGS1(char *, path)
d1709 2
a1710 1
    char *type;
d1720 1
a1720 1
PRIVATE int dired_cmp ARGS2(void *, a, void *, b)
d1722 2
a1723 2
    DIRED *p = (DIRED *)a;
    DIRED *q = (DIRED *)b;
d1725 1
d1765 4
a1768 6
PRIVATE int print_local_dir ARGS5(
	DIR  *,			dp,
	char *,			localname,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
d1771 1
d1773 1
a1773 1
    STRUCT_DIRENT * dirbuf;
d1776 1
d1778 1
a1778 1
    char * tmpfilename = NULL;
d1780 1
d1783 9
d1798 3
a1800 21
    if (!strcmp(pathname,"/")) {
	/*
	**  Root path.
	*/
	StrAllocCopy (tail, "/foo/..");
    } else {
	char *p = strrchr(pathname, '/');  /* find last slash */

	if (!p) {
	    /*
	    **	This probably should not happen,
	    **	but be prepared if it does. - KW
	    */
	    StrAllocCopy (tail, "/foo/..");
	} else {
	    /*
	    **	Take slash off the beginning.
	    */
	    StrAllocCopy(tail, (p + 1));
	}
    }
d1811 1
a1811 1
    targetClass = *target->isa;	    /* Copy routine entry points */
d1817 6
a1822 8
    **	The need_parent_link flag will be set if an
    **	"Up to <parent>" link was not created for a
    **	readable parent in HTDirTitles() because
    **	LONG_LIST is defined and NO_PARENT_DIR_REFERENCE
    **	is not defined so that need we to create the
    **	link via an LYListFmtParse() call. - FM
    */
    need_parent_link = HTDirTitles(target, anchor, FALSE);
d1833 9
a1841 3
    {
	HTBTree * bt = HTBTree_new(dired_cmp);
	int num_of_entries = 0;	    /* lines counter */
d1843 2
a1844 3
	_HTProgress (READING_DIRECTORY);
	status = HT_LOADED; /* assume we don't get interrupted */
	while ((dirbuf = readdir(dp)) != NULL) {
d1846 16
a1861 3
	    **	While there are directory entries to be read...
	    */
	    DIRED *data = NULL;
d1863 5
a1867 20
#if !(defined(DOSPATH) || defined(__EMX__))
	    if (dirbuf->d_ino == 0)
		/*
		**  If the entry is not being used, skip it.
		*/
		continue;
#endif
	    /*
	    **	Skip self, parent if handled in HTDirTitles()
	    **	or if NO_PARENT_DIR_REFERENCE is not defined,
	    **	and any dot files if no_dotfiles is set or
	    **	show_dotfiles is not set. - FM
	    */
	    if (!strcmp(dirbuf->d_name, ".")   /* self	 */ ||
		(!strcmp(dirbuf->d_name, "..") /* parent */ &&
		 need_parent_link == FALSE) ||
		((strcmp(dirbuf->d_name, "..")) &&
		 (dirbuf->d_name[0] == '.' &&
		  (no_dotfiles || !show_dotfiles))))
		continue;
d1869 7
a1875 5
	    StrAllocCopy(tmpfilename, localname);
	    /*
	    **  If filename is not root directory, add trailing separator.
	    */
	    LYAddPathSep(&tmpfilename);
d1877 15
a1891 8
	    StrAllocCat(tmpfilename, dirbuf->d_name);
	    data = (DIRED *)malloc(sizeof(DIRED) + strlen(dirbuf->d_name) + 4);
	    if (data == NULL) {
		/* FIXME */
	    }
	    LYTrimPathSep (tmpfilename);
	    if (lstat(tmpfilename, &(data->file_info)) < 0)
		data->file_info.st_mode = 0;
d1893 1
a1893 1
	    strcpy(data->file_name, dirbuf->d_name);
d1895 6
a1900 6
	    if (S_ISDIR(data->file_info.st_mode)) {
		data->sort_tags = 'D';
	    } else {
		data->sort_tags = 'F';
		/* D & F to have first directories, then files */
	    }
d1902 2
a1903 10
	    if (S_ISDIR(data->file_info.st_mode)) {
		if (dir_list_style == MIXED_STYLE) {
		    data->sort_tags = ' ';
		    LYAddPathSep0(data->file_name);
		} else if (!strcmp(dirbuf->d_name, "..")) {
		    data->sort_tags = 'A';
		} else {
		    data->sort_tags = 'D';
		}
	    } else if (dir_list_style == MIXED_STYLE) {
d1905 3
a1907 3
	    } else if (dir_list_style == FILES_FIRST) {
		data->sort_tags = 'C';
		/* C & D to have first files, then directories */
d1909 1
a1909 1
		data->sort_tags = 'F';
d1911 8
d1920 4
a1923 4
	    /*
	    **	Sort dirname in the tree bt.
	    */
	    HTBTree_add(bt, data);
d1926 7
a1932 8
	    /* optimize for expensive operation: */
	    if (num_of_entries % (partial_threshold > 0  ?
				  partial_threshold : display_lines)
			       == 0) {
		if (HTCheckForInterrupt()) {
		    status = HT_PARTIAL_CONTENT;
		    break;
		}
d1934 2
a1935 1
	    num_of_entries++;
d1938 12
a1949 1
	}   /* end while directory entries left to read */
d1951 2
a1952 4
	if (status != HT_PARTIAL_CONTENT)
	    _HTProgress (OPERATION_OK);
	else
	    CTRACE((tfp, "Reading the directory interrupted by user\n"));
d1954 1
d1956 3
a1958 12
	/*
	**  Run through tree printing out in order.
	*/
	{
	    HTBTElement * next_element = HTBTree_next(bt,NULL);
		/* pick up the first element of the list */
	    int num_of_entries_output = 0; /* lines counter */

	    char state;
		/* I for initial (.. file),
		   D for directory file,
		   F for file */
d1961 1
a1961 1
	    char test;
d1963 1
a1963 1
	    state = 'I';
d1965 2
a1966 2
	    while (next_element != NULL) {
		DIRED *entry;
d1969 5
a1973 6
		if (num_of_entries_output % HTMAX(display_lines,10) == 0) {
		    if (HTCheckForInterrupt()) {
			_HTProgress (TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
d1975 1
d1977 5
a1981 5
		StrAllocCopy(tmpfilename, localname);
		/*
		**	If filename is not root directory.
		*/
		LYAddPathSep(&tmpfilename);
d1983 10
a1992 11
		entry = (DIRED *)(HTBTree_object(next_element));
		/*
		**  Append the current entry's filename
		**  to the path.
		*/
		StrAllocCat(tmpfilename, entry->file_name);
		HTSimplify(tmpfilename);
		/*
		**  Output the directory entry.
		*/
		if (strcmp(DIRED_NAME(HTBTree_object(next_element)), "..")) {
d1994 3
a1996 3
		    test = (DIRED_BLOK(HTBTree_object(next_element))
			    == 'D' ? 'D' : 'F');
		    if (state != test) {
d1998 4
a2001 21
			if (dir_list_style == FILES_FIRST) {
			    if (state == 'F') {
				END(HTML_DIR);
				PUTC('\n');
			    }
			} else if (dir_list_style != MIXED_STYLE)
			    if (state == 'D') {
				END(HTML_DIR);
				PUTC('\n');
			    }
#endif /* !LONG_LIST */
			state =
			   (char) (DIRED_BLOK(HTBTree_object(next_element))
			    == 'D' ? 'D' : 'F');
			START(HTML_H2);
			if (dir_list_style != MIXED_STYLE) {
			   START(HTML_EM);
			   PUTS(state == 'D'
			      ? LABEL_SUBDIRECTORIES
			      : LABEL_FILES);
			   END(HTML_EM);
d2003 1
a2003 10
			END(HTML_H2);
			PUTC('\n');
#ifndef LONG_LIST
			START(HTML_DIR);
			PUTC('\n');
#endif /* !LONG_LIST */
		    }
#else
		    if (state != DIRED_BLOK(HTBTree_object(next_element))) {
#ifndef LONG_LIST
d2009 10
a2018 4
			state =
			  (char) (DIRED_BLOK(HTBTree_object(next_element))
			   == 'D' ? 'D' : 'F');
			START(HTML_H2);
d2021 2
a2022 2
			    ? LABEL_SUBDIRECTORIES
			    : LABEL_FILES);
d2024 10
a2033 2
			END(HTML_H2);
			PUTC('\n');
d2035 2
a2036 1
			START(HTML_DIR);
d2038 1
d2040 7
d2048 13
d2063 1
a2063 1
		    START(HTML_LI);
d2065 6
a2070 2
		}

d2072 1
a2072 1
		LYListFmtParse(list_format, entry, tmpfilename, target, tail);
d2074 5
a2078 5
		HTDirEntry(target, tail, entry->file_name);
		PUTS(entry->file_name);
		END(HTML_A);
		MAYBE_END(HTML_LI);
		PUTC('\n');
d2081 3
a2083 3
		next_element = HTBTree_next(bt, next_element);
		    /* pick up the next element of the list;
		     if none, return NULL*/
d2085 1
a2085 1
		/* optimize for expensive operation: */
d2087 11
a2097 12
		if (num_of_entries_output %
		    (partial_threshold > 0 ? partial_threshold : display_lines)
		    == 0) {
		    /* num_of_entries, num_of_entries_output... */
		    /* HTReadProgress...(bytes, 0); */
		    HTDisplayPartial();

		    if (HTCheckForInterrupt()) {
			_HTProgress (TRANSFER_INTERRUPTED);
			status = HT_PARTIAL_CONTENT;
			break;
		    }
d2099 2
a2100 1
		num_of_entries_output++;
d2103 1
a2103 1
	    } /* end while next_element */
d2105 5
a2109 5
	    if (status == HT_LOADED) {
		if (state == 'I') {
		    START(HTML_P);
		    PUTS("Empty Directory");
		}
d2111 2
a2112 2
		else
		    END(HTML_DIR);
d2114 8
a2121 2
	    }
	} /* end printing out the tree in order */
d2123 10
a2132 11
	FREE(tmpfilename);
	FREE(tail);
	HTBTreeAndObject_free(bt);

	if (status == HT_LOADED) {
	    if (HTDirReadme == HT_DIR_README_BOTTOM)
		do_readme(target, localname);
	    FREE_TARGET;
	} else {
	    ABORT_TARGET;
	}
d2135 1
a2135 1
    return status;  /* document loaded, maybe partial */
a2138 1

d2140 2
a2141 3
PUBLIC int HTStat ARGS2(
	CONST char *,	filename,
	struct stat *,	data)
d2146 1
a2146 1
    if (len != 0 && LYIsPathSep(filename[len-1])) {
d2148 1
d2160 1
a2160 1
	 && access(filename, 0) == 0) {
a2169 28
/*	Load a document.
**	----------------
**
**  On entry:
**	addr		must point to the fully qualified hypertext reference.
**			This is the physical address of the file
**
**  On exit:
**	returns		<0		Error has occurred.
**			HTLOADED	OK
**
*/
PUBLIC int HTLoadFile ARGS4(
	CONST char *,		addr,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
{
    char * filename = NULL;
    char * acc_method = NULL;
    char * ftp_newhost;
    HTFormat format;
    char * nodename = NULL;
    char * newname = NULL;	/* Simplified name of file */
    HTAtom * encoding;		/* @@@@ not used yet */
    HTAtom * myEncoding = NULL; /* enc of this file, may be gzip etc. */
    int status = -1;
    char *dot;
d2171 18
a2188 2
    struct stat stat_info;
#endif /* VMS */
d2190 1
d2200 14
d2215 4
d2220 249
a2468 2
    **	Reduce the filename to a basic form (hopefully unique!).
    */
d2470 2
a2471 2
    filename=HTParse(newname, "", PARSE_PATH|PARSE_PUNCTUATION);
    nodename=HTParse(newname, "", PARSE_HOST);
d2474 2
a2475 2
    **	If access is ftp, or file is on another host, invoke ftp now.
    */
d2478 2
a2479 2
       (!LYSameHostname("localhost", nodename) &&
	!LYSameHostname(nodename, HTHostName()))) {
d2492 2
a2493 2
	if ( ftp_passive == ftp_local_passive ) {
	    if (( status >= 400 ) || ( status < 0 )) {
d2512 2
a2513 2
    **	Determine the format and encoding mapped to any suffix.
    */
d2516 3
a2518 3
	 *  If content_type and content_encoding are BOTH already set
	 *  in the anchor object, we believe it and don't try to
	 *  derive format and encoding from the filename. - kw
d2532 7
a2538 7
    /*
    **	Check the format for an extended MIME charset value, and
    **	act on it if present.  Otherwise, assume what is indicated
    **	by the last parameter (fallback will effectively be
    **	UCLYhndl_for_unspec, by default ISO-8859-1). - kw
    */
	format = HTCharsetFormat(format, anchor, default_UCLYhndl );
d2543 5
a2547 5
    **	Check to see if the 'filename' is in fact a directory.	If it is
    **	create a new hypertext object containing a list of files and
    **	subdirectories contained in the directory.  All of these are links
    **	to the directories or files listed.
    */
d2559 1
a2559 1
		char * enable_file_name = NULL;
d2576 9
a2584 210
    /*
    **	Assume that the file is in Unix-style syntax if it contains a '/'
    **	after the leading one. @@@@
    */
    {
	FILE * fp;
	char * vmsname = strchr(filename + 1, '/') ?
		    HTVMS_name(nodename, filename) : filename + 1;
	fp = fopen(vmsname, "r", "shr=put", "shr=upd");

	/*
	**  If the file wasn't VMS syntax, then perhaps it is Ultrix.
	*/
	if (!fp) {
	    char * ultrixname = 0;
	    CTRACE((tfp, "HTLoadFile: Can't open as %s\n", vmsname));
	    HTSprintf0(&ultrixname, "%s::\"%s\"", nodename, filename);
	    fp = fopen(ultrixname, "r", "shr=put", "shr=upd");
	    if (!fp) {
		CTRACE((tfp, "HTLoadFile: Can't open as %s\n",
			    ultrixname));
	    }
	    FREE(ultrixname);
	}
	if (fp) {
	    char *semicolon = NULL;

	    if (HTEditable(vmsname)) {
		HTAtom * put = HTAtom_for("PUT");
		HTList * methods = HTAnchor_methods(anchor);
		if (HTList_indexOf(methods, put) == (-1)) {
		    HTList_addObject(methods, put);
		}
	    }
	    /*
	    **	Trim vmsname at semicolon if a version number was
	    **	included, so it doesn't interfere with the check
	    **	for a compressed file. - FM
	    */
	    if ((semicolon = strchr(vmsname, ';')) != NULL)
		*semicolon = '\0';
	    /*
	    **	Fake a Content-Encoding for compressed files. - FM
	    */
	    if (!IsUnityEnc(myEncoding)) {
		/*
		 *  We already know from the call to HTFileFormat above
		 *  that this is a compressed file, no need to look at
		 *  the filename again. - kw
		 */
#ifdef USE_ZLIB
		if (strcmp(format_out->name, "www/download") != 0 &&
		    (!strcmp(HTAtom_name(myEncoding), "gzip") ||
		     !strcmp(HTAtom_name(myEncoding), "x-gzip"))) {
		    fclose(fp);
		    if (semicolon != NULL)
			*semicolon = ';';
		    gzfp = gzopen(vmsname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				vmsname, (void*)gzfp));
		    internal_decompress = cftGzip;
		} else
#endif	/* USE_ZLIB */
#ifdef USE_BZLIB
		if (strcmp(format_out->name, "www/download") != 0 &&
		    (!strcmp(HTAtom_name(myEncoding), "bzip2") ||
		     !strcmp(HTAtom_name(myEncoding), "x-bzip2"))) {
		    fclose(fp);
		    if (semicolon != NULL)
			*semicolon = ';';
		    bzfp = BZ2_bzopen(vmsname, BIN_R);

		    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				vmsname, (void*)bzfp));
		    use_zread = YES;
		} else
#endif	/* USE_BZLIB */
		{
		    StrAllocCopy(anchor->content_type, format->name);
		    StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
		    format = HTAtom_for("www/compressed");
		}
	    } else {
		/* FIXME: should we check if suffix is after ']' or ':' ? */
		CompressFileType cft = HTCompressFileType(vmsname, "._-", &dot);

		if (cft != cftNone) {
		    char *cp = NULL;

		    StrAllocCopy(cp, vmsname);
		    cp[dot - vmsname] = '\0';
		    format = HTFileFormat(cp, &encoding, NULL);
		    FREE(cp);
		    format = HTCharsetFormat(format, anchor,
					     UCLYhndl_HTFile_for_unspec);
		    StrAllocCopy(anchor->content_type, format->name);
		}

		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    format = HTAtom_for("www/compressed");
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
		    if (strcmp(format_out->name, "www/download") != 0) {
			fclose(fp);
			if (semicolon != NULL)
			    *semicolon = ';';
			gzfp = gzopen(vmsname, BIN_R);

			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    vmsname, (void*)gzfp));
			internal_decompress = cftGzip;
		    }
#else  /* USE_ZLIB */
		    format = HTAtom_for("www/compressed");
#endif	/* USE_ZLIB */
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
#ifdef USE_BZLIB
		    if (strcmp(format_out->name, "www/download") != 0) {
			fclose(fp);
			if (semicolon != NULL)
			    *semicolon = ';';
			bzfp = BZ2_bzopen(vmsname, BIN_R);

			CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				    vmsname, (void*)bzfp));
			internal_decompress = cfgBzip2;
		    }
#else  /* USE_BZLIB */
		    format = HTAtom_for("www/compressed");
#endif	/* USE_BZLIB */
		    break;
		case cftNone:
		    break;
		}
	    }
	    if (semicolon != NULL)
		*semicolon = ';';
	    FREE(filename);
	    FREE(nodename);
#if defined(USE_ZLIB) || defined(USE_BZLIB)
	    if (internal_decompress != cftNone) {
		switch (internal_decompress) {
#ifdef USE_ZLIB
		case cftCompress:
		case cftGzip:
		    failed_decompress = (gzfp == 0);
		    break;
#endif
#ifdef USE_BZLIB
		case cftBzip2:
		    failed_decompress = (bzfp == 0);
		    break;
#endif
		default:
		    failed_decompress = YES;
		    break;
		}
		if (failed_decompress) {
		    status = HTLoadError(NULL,
					 -(HT_ERROR),
					 FAILED_OPEN_COMPRESSED_FILE);
		} else {
		    char * sugfname = NULL;
		    if (anchor->SugFname) {
			StrAllocCopy(sugfname, anchor->SugFname);
		    } else {
			char * anchor_path = HTParse(anchor->address, "",
						     PARSE_PATH + PARSE_PUNCTUATION);
			char * lastslash;
			HTUnEscape(anchor_path);
			lastslash = strrchr(anchor_path, '/');
			if (lastslash)
			    StrAllocCopy(sugfname, lastslash + 1);
			FREE(anchor_path);
		    }
		    FREE(anchor->content_encoding);
		    if (sugfname && *sugfname)
			HTCheckFnameForCompression(&sugfname, anchor,
						   TRUE);
		    if (sugfname && *sugfname)
			StrAllocCopy(anchor->SugFname, sugfname);
		    FREE(sugfname);
#ifdef USE_BZLIB
		    if (bzfp)
			status = HTParseBzFile(format, format_out,
					       anchor,
					       bzfp, sink);
#endif
#ifdef USE_ZLIB
		    if (gzfp)
			status = HTParseGzFile(format, format_out,
					       anchor,
					       gzfp, sink);
#endif
		}
	    } else
#endif /* USE_ZLIB || USE_BZLIB */
	    {
		status = HTParseFile(format, format_out, anchor, fp, sink);
		fclose(fp);
	    }
	    return status;
	}  /* If successful open */
d2586 1
d2588 1
d2595 5
a2599 5
    **	For unix, we try to translate the name into the name of a
    **	transparently mounted file.
    **
    **	Not allowed in secure (HTClientHost) situations. TBL 921019
    */
d2601 1
a2601 1
    /*	Need protection here for telnet server but not httpd server. */
d2604 1
a2604 1
	char * localname = HTLocalName(addr);
d2609 5
a2613 5
	**  Multiformat handling.
	**
	**  If needed, scan directory to find a good file.
	**  Bug:  We don't stat the file to find the length.
	*/
d2620 2
a2621 2
	    STRUCT_DIRENT * dirbuf;
	    float best = (float) NO_VALUE_FOUND; /* So far best is bad */
d2623 2
a2624 2
	    HTAtom * best_enc = NULL;
	    char * best_name = NULL;	/* Best dir entry so far */
d2632 2
a2633 2
		*base++ = '\0';		/* Just got directory name */
		baselen = strlen(base)- strlen(MULTI_SUFFIX);
d2646 3
a2648 3
		**  While there are directory entries to be read...
		*/
#if !(defined(DOSPATH) || defined(__EMX__))
d2652 1
a2652 1
		if ((int)strlen(dirbuf->d_name) > baselen &&	 /* Match? */
d2654 1
a2654 1
		    HTAtom * enc;
d2658 3
a2660 2
						filevalue,
						0L  /* @@@@@@@@@@@@ */);
d2662 5
a2666 3
			char *atomname = NULL;
			CompressFileType cft = HTCompressFileType(dirbuf->d_name, ".", &dot);
			char * cp = NULL;
d2671 1
a2671 1
			    cp[dot - dirbuf->d_name] = '\0';
d2683 3
d2710 4
a2713 3
			CTRACE((tfp, "HTLoadFile: value of presenting %s is %f\n",
				    HTAtom_name(rep), value));
			if  (value > best) {
d2719 4
a2722 4
		    }	/* if best so far */
		 } /* if match */

	    } /* end while directory entries left to read */
d2728 1
a2728 1
		base[-1] = '/';		/* Restore directory name */
d2732 1
a2732 1
	    } else {			/* If not found suitable file */
d2737 3
a2739 3
	    /*NOTREACHED*/
	} /* if multi suffix */

d2741 8
a2748 8
	**  Check to see if the 'localname' is in fact a directory.  If it
	**  is create a new hypertext object containing a list of files and
	**  subdirectories contained in the directory.	All of these are
	**  links to the directories or files listed.
	**  NB This assumes the existence of a type 'STRUCT_DIRENT', which
	**  will hold the directory entry, and a type 'DIR' which is used
	**  to point to the current directory being read.
	*/
d2753 1
a2753 1
	if (HTStat(localname,&dir_info) == -1)	   /* get file information */
d2755 1
a2755 1
				/* if can't read file information */
d2758 1
a2758 1
	}  else {		/* Stat was OK */
d2762 2
a2763 2
		**  If localname is a directory.
		*/
d2770 3
a2772 4
		**  Check directory access.
		**  Selective access means only those directories containing
		**  a marker file can be browsed.
		*/
d2780 1
a2780 1
		    char * enable_file_name = NULL;
d2800 2
a2801 2
		**  Directory access is allowed and possible.
		*/
d2804 1
a2804 1
					anchor, format_out, sink);
d2810 2
a2811 2
	    } /* end if localname is a directory */

d2819 1
a2819 1
	} /* end if file stat worked */
d2824 9
a2832 171
	{
	    int bin = HTCompressFileType(localname, ".", &dot) != cftNone;
	    FILE * fp = fopen(localname, (bin ? BIN_R : "r"));

	    CTRACE((tfp, "HTLoadFile: Opening `%s' gives %p\n",
				 localname, (void*)fp));
	    if (fp) {		/* Good! */
		if (HTEditable(localname)) {
		    HTAtom * put = HTAtom_for("PUT");
		    HTList * methods = HTAnchor_methods(anchor);
		    if (HTList_indexOf(methods, put) == (-1)) {
			HTList_addObject(methods, put);
		    }
		}
		/*
		**  Fake a Content-Encoding for compressed files. - FM
		*/
		if (!IsUnityEnc(myEncoding)) {
		    /*
		     *	We already know from the call to HTFileFormat above
		     *	that this is a compressed file, no need to look at
		     *	the filename again. - kw
		     */
#ifdef USE_ZLIB
		    if (strcmp(format_out->name, "www/download") != 0 &&
			(!strcmp(HTAtom_name(myEncoding), "gzip") ||
			 !strcmp(HTAtom_name(myEncoding), "x-gzip"))) {
			fclose(fp);
			gzfp = gzopen(localname, BIN_R);

			CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void*)gzfp));
			internal_decompress = cftGzip;
		    } else
#endif	/* USE_ZLIB */
#ifdef USE_BZLIB
		    if (strcmp(format_out->name, "www/download") != 0 &&
			(!strcmp(HTAtom_name(myEncoding), "bzip2") ||
			 !strcmp(HTAtom_name(myEncoding), "x-bzip2"))) {
			fclose(fp);
			bzfp = BZ2_bzopen(localname, BIN_R);

			CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
				    localname, (void*)bzfp));
			internal_decompress = cftBzip2;
		    } else
#endif	/* USE_BZLIB */
		    {
			StrAllocCopy(anchor->content_type, format->name);
			StrAllocCopy(anchor->content_encoding, HTAtom_name(myEncoding));
			format = HTAtom_for("www/compressed");
		    }
		} else {
		    CompressFileType cft = HTCompressFileType(localname, ".", &dot);

		    if (cft != cftNone) {
			char *cp = NULL;

			StrAllocCopy(cp, localname);
			cp[dot - localname] = '\0';
			format = HTFileFormat(cp, &encoding, NULL);
			FREE(cp);
			format = HTCharsetFormat(format, anchor,
						 UCLYhndl_HTFile_for_unspec);
			StrAllocCopy(anchor->content_type, format->name);
		    }

		    switch (cft) {
		    case cftCompress:
			StrAllocCopy(anchor->content_encoding, "x-compress");
			format = HTAtom_for("www/compressed");
			break;
		    case cftGzip:
			StrAllocCopy(anchor->content_encoding, "x-gzip");
#ifdef USE_ZLIB
			if (strcmp(format_out->name, "www/download") != 0) {
			    fclose(fp);
			    gzfp = gzopen(localname, BIN_R);

			    CTRACE((tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					localname, (void*)gzfp));
			    internal_decompress = cftGzip;
			}
#else  /* USE_ZLIB */
			format = HTAtom_for("www/compressed");
#endif	/* USE_ZLIB */
			break;
		    case cftBzip2:
			StrAllocCopy(anchor->content_encoding, "x-bzip2");
#ifdef USE_BZLIB
			if (strcmp(format_out->name, "www/download") != 0) {
			    fclose(fp);
			    bzfp = BZ2_bzopen(localname, BIN_R);

			    CTRACE((tfp, "HTLoadFile: bzopen of `%s' gives %p\n",
					localname, (void*)bzfp));
			    internal_decompress = cftBzip2;
			}
#else  /* USE_BZLIB */
			format = HTAtom_for("www/compressed");
#endif	/* USE_BZLIB */
			break;
		    case cftNone:
			break;
		    }
		}
		FREE(localname);
		FREE(nodename);
#if defined(USE_ZLIB) || defined(USE_BZLIB)
		if (internal_decompress != cftNone) {
		    switch (internal_decompress) {
#ifdef USE_ZLIB
		    case cftGzip:
			failed_decompress = (gzfp == 0);
			break;
#endif
#ifdef USE_BZLIB
		    case cftBzip2:
			failed_decompress = (bzfp == 0);
			break;
#endif
		    default:
			failed_decompress = YES;
			break;
		    }
		    if (failed_decompress) {
			status = HTLoadError(NULL,
					     -(HT_ERROR),
					     FAILED_OPEN_COMPRESSED_FILE);
		    } else {
			char * sugfname = NULL;
			if (anchor->SugFname) {
			    StrAllocCopy(sugfname, anchor->SugFname);
			} else {
			    char * anchor_path = HTParse(anchor->address, "",
							 PARSE_PATH + PARSE_PUNCTUATION);
			    char * lastslash;
			    HTUnEscape(anchor_path);
			    lastslash = strrchr(anchor_path, '/');
			    if (lastslash)
				StrAllocCopy(sugfname, lastslash + 1);
			    FREE(anchor_path);
			}
			FREE(anchor->content_encoding);
			if (sugfname && *sugfname)
			    HTCheckFnameForCompression(&sugfname, anchor,
						       TRUE);
			if (sugfname && *sugfname)
			    StrAllocCopy(anchor->SugFname, sugfname);
			FREE(sugfname);
#ifdef USE_BZLIB
			if (bzfp)
			    status = HTParseBzFile(format, format_out,
						   anchor,
						   bzfp, sink);
#endif
#ifdef USE_ZLIB
			if (gzfp)
			    status = HTParseGzFile(format, format_out,
						   anchor,
						   gzfp, sink);
#endif
		    }
		} else
#endif /* USE_ZLIB */
		{
		    status = HTParseFile(format, format_out, anchor, fp, sink);
		    fclose(fp);
		}
		return status;
	    }  /* If successful open */
d2834 4
a2837 2
	}  /* scope of fp */
    }  /* local unix file system */
d2843 2
a2844 2
    **	Now, as transparently mounted access has failed, we try FTP.
    */
d2847 2
a2848 2
	**  Deal with case-sensitivity differences on VMS versus Unix.
	*/
d2872 2
a2873 2
    **	All attempts have failed.
    */
d2881 1
a2881 1
static CONST char *program_paths[pp_Last];
d2886 1
a2886 2
PUBLIC CONST char * HTGetProgramPath ARGS1(
	ProgramPaths,	code)
d2888 2
a2889 1
    CONST char *result = NULL;
d2899 1
a2899 3
PUBLIC void HTSetProgramPath ARGS2(
	ProgramPaths,	code,
	CONST char *,	path)
d2909 1
a2909 1
PUBLIC void HTInitProgramPaths NOARGS
d2911 4
a2914 3
    int code;
    CONST char *path;
    CONST char *test;
d2916 2
a2917 2
    for (code = (int) ppUnknown + 1; code < (int) pp_Last; ++code) {
	switch (code) {
d2948 5
d2983 5
d3039 1
a3039 1
	    free((char *)test);
d3046 2
a3047 2
**	Protocol descriptors
*/
d3050 1
a3050 1
GLOBALDEF (HTProtocol,HTFTP,_HTFILE_C_1_INIT);
d3052 1
a3052 1
GLOBALDEF (HTProtocol,HTFile,_HTFILE_C_2_INIT);
d3054 4
a3057 2
GLOBALDEF PUBLIC HTProtocol HTFTP  = { "ftp", HTLoadFile, 0 };
GLOBALDEF PUBLIC HTProtocol HTFile = { "file", HTLoadFile, HTFileSaveStream };
@


1.6
log
@multiple readlink() calls that forgot the -1...

ok millert
@
text
@d26 1
a26 1
#ifdef DOSPATH
d34 1
a34 1
#ifdef DOSPATH
d37 3
d41 1
a41 1
#endif /* DOSPATH */
d44 1
d49 1
a49 1
#ifdef USE_ZLIB
d87 6
a131 2
extern BOOL HTPassEightBitRaw;

a138 2
/*PRIVATE char *HTSaveRoot  = "$(HOME)/WWW/";*/ /* Where to save things */

d190 1
a192 1
	char *,		entry,
a199 1
	struct stat st;
d203 1
a203 1
#ifndef _WINDOWS
d236 1
a236 1
	if (lstat(file, &st) < 0)
d275 2
a276 2
			HTDirEntry(target, tail, entry);
			FormatStr(&buf, start, entry);
d281 1
a281 1
			if (c != 'A' && S_ISLNK(st.st_mode) &&
d292 1
a292 1
		    if (S_ISDIR(st.st_mode)) {
d323 2
a324 2
			datestr = ctime(&st.st_mtime);
			if ((now - st.st_mtime) < SEC_PER_YEAR/2)
d339 1
a339 1
			FormatNum(&buf, start, (int) st.st_size);
d343 1
a343 1
			if (S_ISDIR(st.st_mode)) {
d345 1
d350 1
a350 1
			FormatNum(&buf, start, (int)((st.st_size+1023)/1024));
d355 1
a355 1
			switch(st.st_mode & S_IFMT) {
d383 1
a383 1
				PBIT(st.st_mode, 6, st.st_mode & S_IRWXU));
d386 3
a388 3
				PBIT(st.st_mode, 6, st.st_mode & S_ISUID),
				PBIT(st.st_mode, 3, st.st_mode & S_ISGID),
				PTBIT(st.st_mode,   st.st_mode & S_ISVTX));
a392 1
#ifdef _WINDOWS
d394 2
a395 5
		case 'g':	/* group */
			break;
#else
		case 'o':	/* owner */
			name = HTAA_UidToName (st.st_uid);
d399 1
a399 1
				FormatNum(&buf, start, (int) st.st_uid);
d401 1
d405 2
a406 1
			name = HTAA_GidToName(st.st_gid);
d410 1
a410 1
				FormatNum(&buf, start, (int) st.st_gid);
d412 1
a413 1
#endif
d416 1
a416 1
			FormatNum(&buf, start, (int) st.st_nlink);
d596 1
a596 1
PUBLIC char * HTURLPath_toFile ARGS2(
d598 2
a599 1
	BOOL,		expand_all)
d611 2
a612 11
#ifdef DOSPATH
    StrAllocCopy(result, HTDOS_name(path));
#else
#ifdef __EMX__
    if (path[0] == '/'
	&& isalpha(path[1])
	&& path[2] == ':') /* pesky leading slash */
	StrAllocCopy(result, path+1);
    else
	StrAllocCopy(result, path);
    CTRACE((tfp, "EMX hack changed `%s' to `%s'\n", path, result));
d615 1
a615 2
#endif /* __EMX__ */
#endif /* DOSPATH */
d657 1
a657 15
#ifdef DOSPATH
	    StrAllocCopy(result, HTDOS_name(path));
#else
#ifdef __EMX__
	    if (path[0] == '/'
	     && isalpha(path[1])
	     && path[2] == ':') /* pesky leading slash */
		StrAllocCopy(result, path+1);
	    else
		StrAllocCopy(result, path);
	    CTRACE((tfp, "EMX hack changed `%s' to `%s'\n", path, result));
#else
	    StrAllocCopy(result, path);
#endif /* __EMX__ */
#endif /* DOSPATH */
d666 1
a666 1
	if ((home = getenv("HOME")) == 0)
d674 1
a674 1
	home = getenv("HOME");
d708 1
a708 1
	HTSprintf0(&result, "file://%s", name+13);
d712 1
a712 1
	HTSprintf0(&result, "file://%s", name+5);
d714 1
a714 1
	HTSprintf0(&result, "file://%s%s", HTHostName(), name);
d1115 1
a1115 1
	file_anchor = HTAnchor_parent(HTAnchor_findSimpleAddress(Aname));
d1282 3
a1284 2
    CONST char * addr = HTAnchor_address((HTAnchor*)anchor);
    char *  localname = HTLocalName(addr);
d1286 1
a1286 1
    FILE* fp = fopen(localname, BIN_W);
d1302 1
d1306 5
a1310 7
    if (0 == strcmp(entry,"../")) {
	/*
	**  Undo slash appending for anchor creation.
	*/
	StrAllocCopy(escaped,"..");
    } else {
	escaped = HTEscape(entry, URL_XPALPHAS);
d1336 1
d1355 1
a1355 1
	HTAnchor *,	anchor,
d1358 1
a1358 1
    char * logical = HTAnchor_address(anchor);
d1364 8
a1372 4
#ifdef DOSPATH
    BOOL local_link = FALSE;
    if (strlen(logical) > 18 && logical[18] == ':') local_link = TRUE;
#endif
d1400 1
a1400 1
    current = strrchr(path, '/');	/* last part or "" */
d1410 2
a1411 1
	    TRUE);
d1419 1
a1419 1
      StrAllocCopy(printable, (current ? current + 1 : ""));
a1450 1
	  FREE(logical);
d1461 3
a1463 4
#ifdef DOSPATH
    if (current != path)	/* leave "/c:" alone */
#endif
    if (current && current[1]) {   /* was a slash AND something else too */
d1467 1
a1467 1
	*current++ = '\0';
a1473 1
	    FREE(logical);
d1481 1
a1481 1
#ifdef DOSPATH
a1528 1
		    FREE(logical);
a1536 1
		FREE(logical);
a1570 1
    FREE(logical);
d1585 1
d1596 2
a1597 23
	for (;;){
	    int c = fgetc(fp);
	    if (c == EOF) break;
#ifdef NOTDEFINED
	    switch (c) {
		case '&':
		case '<':
		case '>':
			PUTC('&');
			PUTC('#');
			PUTC((char)(c / 10));
			PUTC((char) (c % 10));
			PUTC(';');
			break;
/*		case '\n':
			PUTC('\r');
Bug removed thanks to joe@@athena.mit.edu */
		default:
			PUTC((char)c);
	    }
#else
	    PUTC((char)c);
#endif /* NOTDEFINED */
d1606 62
a1677 1
    char *logical = NULL;
a1682 1
    struct stat file_info;
d1688 1
a1688 2
    logical = HTAnchor_address((HTAnchor*)anchor);
    pathname = HTParse(logical, "",
d1735 1
a1735 2
    need_parent_link = HTDirTitles(target,
				   (HTAnchor *)anchor, FALSE);
d1738 2
a1739 2
    if (strncmp(anchor->address, "lynxcgi:", 8)) {
	HTAnchor_setFormat((HTParentAnchor *) anchor, WWW_DIRED);
a1745 1

d1747 1
a1747 1
	HTBTree * bt = HTBTree_new((HTComparer)AS_cmp);
d1756 1
a1756 1
	    char * dirname = NULL;
d1758 1
a1758 1
#ifndef DOSPATH
d1780 4
a1783 5
	    if (strcmp(localname, "/"))
		/*
		**  If filename is not root directory.
		*/
		StrAllocCat(tmpfilename, "/");
d1786 9
a1794 1
	    stat(tmpfilename, &file_info);
d1796 4
a1799 4
	    if (S_ISDIR(file_info.st_mode))
		HTSprintf0(&dirname, "D%s",dirbuf->d_name);
	    else
		HTSprintf0(&dirname, "F%s",dirbuf->d_name);
d1801 1
d1803 16
a1818 8
	    if (S_ISDIR(file_info.st_mode))
	    {
		if (dir_list_style == MIXED_STYLE)
		    HTSprintf0(&dirname, " %s/", dirbuf->d_name);
		else if (!strcmp(dirbuf->d_name, ".."))
		    HTSprintf0(&dirname, "A%s", dirbuf->d_name);
		else
		    HTSprintf0(&dirname, "D%s", dirbuf->d_name);
a1819 7
	    else if (dir_list_style == MIXED_STYLE)
		HTSprintf0(&dirname, " %s", dirbuf->d_name);
	    else if (dir_list_style == FILES_FIRST)
		HTSprintf0(&dirname, "C%s", dirbuf->d_name);
		/* C & D to have first files, then directories */
	    else
		HTSprintf0(&dirname, "F%s", dirbuf->d_name);
d1824 1
a1824 1
	    HTBTree_add(bt, dirname);
d1866 1
a1866 1
		char *entry, *file_extra;
d1877 5
a1881 6
		StrAllocCopy(tmpfilename,localname);
		if (strcmp(localname, "/"))
		    /*
		    **	If filename is not root directory.
		    */
		    LYAddHtmlSep(&tmpfilename);
d1883 1
a1883 1
		entry = (char*)HTBTree_object(next_element)+1;
d1888 1
a1888 1
		StrAllocCat(tmpfilename, entry);
d1893 1
a1893 5
		if (strcmp((char *)
			   (HTBTree_object(next_element)), "D..") &&
		    strcmp((char *)
			   (HTBTree_object(next_element)), "A.."))
		{
d1895 1
a1895 1
		    test = (*(char *)(HTBTree_object(next_element))
d1911 1
a1911 1
			   (char) (*(char *)(HTBTree_object(next_element))
d1929 1
a1929 2
		    if (state != *(char *)(HTBTree_object(
					     next_element))) {
d1937 1
a1937 1
			  (char) (*(char *)(HTBTree_object(next_element))
a1956 1
		file_extra = NULL;
d1959 1
a1959 2
		LYListFmtParse(list_format, tmpfilename, target,
		    entry, tail);
d1961 2
a1962 2
		HTDirEntry(target, tail, entry);
		PUTS(entry);
a1963 4
		if (file_extra) {
		    PUTS(file_extra);
		    FREE(file_extra);
		}
a2003 1
	FREE(logical);
a2027 1
    char *temp_name = NULL;
d2031 1
d2033 2
d2036 1
a2036 2
	temp_name = (char *)filename;
    }
d2038 6
a2043 6
    /*
     * Someone claims that stat() doesn't give the proper result for a
     * directory on Windows.
     */
    if (access(temp_name, 0) == 0) {
	if (stat(temp_name, data) == -1)
d2045 2
a2046 4
	result = 0;
    }
#else
    result = stat(temp_name, data);
a2047 3

    if (temp_name != filename) {
	FREE(temp_name);
d2079 1
a2079 1
    int status;
a2085 1
    BOOL use_gzread = NO;
d2087 7
d2107 2
a2108 7
       (strcmp("localhost", nodename) != 0 &&
#ifdef VMS
	strcasecomp(nodename, HTHostName()) != 0
#else
	strcmp(nodename, HTHostName()) != 0
#endif /* VMS */
    )) {
d2117 1
a2117 1
		ftp_local_passive = ftp_passive;
d2122 4
a2125 4
		if (( status >= 400 ) || ( status < 0 )) {
			ftp_local_passive = !ftp_passive;
			status = HTFTPLoad(addr, anchor, format_out, sink);
		}
d2127 1
a2127 1
	
d2136 1
a2136 1
#if defined(VMS) || defined(DOSPATH)
d2266 1
a2266 1
		    use_gzread = YES;
d2269 14
d2320 1
a2320 1
			use_gzread = YES;
d2328 12
d2341 1
d2351 3
d2355 19
a2373 2
	    if (use_gzread) {
		if (gzfp) {
d2394 12
a2405 7
		    status = HTParseGzFile(format, format_out,
					   anchor,
					   gzfp, sink);
		} else {
		    status = HTLoadError(NULL,
					 -(HT_ERROR),
					 FAILED_OPEN_COMPRESSED_FILE);
d2408 1
a2408 1
#endif /* USE_ZLIB */
d2426 1
a2426 1
    **	Not allowed in secure (HTClienntHost) situations. TBL 921019
d2476 1
a2476 1
#ifndef DOSPATH
d2570 4
d2678 1
a2678 1
			use_gzread = YES;
d2681 12
d2727 1
a2727 1
			    use_gzread = YES;
d2735 10
d2746 1
d2754 3
d2758 18
a2775 2
		if (use_gzread) {
		    if (gzfp) {
d2796 12
a2807 7
			status = HTParseGzFile(format, format_out,
					       anchor,
					       gzfp, sink);
		    } else {
			status = HTLoadError(NULL,
					     -(HT_ERROR),
					     FAILED_OPEN_COMPRESSED_FILE);
d2860 155
@


1.5
log
@Re-include a patch missed in the recent upgrade:
When passive FTP fails, switch to active FTP and try again

Submitted by Andrew Basterfield <bob@@cemetery.homeunix.org>
@
text
@d277 1
a277 1
			    (len = readlink(file, tmp, sizeof(tmp))) >= 0) {
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d2063 1
d2104 4
d2109 10
@


1.3
log
@default to passive, upgrade to active as needed; Andrew Basterfield
list@@lostgeneration.freeserve.co.uk
@
text
@d27 1
a29 1
#define lstat stat
a48 1
#define INFINITY 512		/* file name length @@@@ FIXME */
a122 1
extern HTCJKlang HTCJK;
a140 8
#ifdef _WINDOWS
int exists(char *filename)
{
 return (access(filename,0)==0);
}
#endif


d158 4
a161 2
    } else {
	HTSprintf0(bufp, "%s", entry);
d177 1
a177 1
	StrAllocCat(*bufp, fmt);
d198 1
d200 1
d203 1
d205 1
d207 9
d222 1
d257 1
a257 1
		while (isdigit(*s) || *s == '.' || *s == '-' || *s == ' ' ||
d350 3
d354 1
d375 4
d383 1
d387 5
d409 1
d455 1
a455 1
	float,		value)
d458 1
a458 1
    BOOL trivial_enc = IsUnityEncStr(encoding);
d475 1
a475 1
	    suff = (HTSuffix *) calloc(1, sizeof(HTSuffix));
d508 1
a508 1
    suff->quality = value;
d582 44
d636 5
d652 1
a652 1
    if (expand_all)
d654 1
a654 1
    else
d661 1
a661 1
	    CTRACE(tfp, "Node `%s' means path `%s'\n", name, path);
d672 1
a672 1
	    CTRACE(tfp, "EMX hack changed `%s' to `%s'\n", path, result);
d679 1
a679 1
	    CTRACE(tfp, "Node `%s' means file `%s'\n", name, result);
d690 6
a695 1
	if ((home = getenv("HOME")) == 0)
d707 3
d735 1
a735 1
    CTRACE(tfp, "File `%s'\n\tmeans node `%s'\n", name, result);
d768 1
a768 1
    trivial_enc = IsUnityEncStr(enc);
d883 4
d940 2
a941 2
	CTRACE(tfp, "HTCharsetFormat: Extended MIME Content-Type is %s\n",
		    format->name);
d1029 2
a1030 2
		= (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit((unsigned char)cp4[9]));
d1032 1
a1032 1
		= (given_is_8859 ||
d1037 1
a1037 1
		= (given_is_8859like &&
d1050 1
a1050 1
		       isdigit((unsigned char)(*cp1)))
d1088 79
d1189 2
a1190 2
	    CTRACE(tfp, "File: Value of %s is %.3f\n",
			filename, suff->quality);
d1194 37
a1230 1
    return 0.3;		/* Dunno! */
a1242 24

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif /* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif /* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif /* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif /* PCNFS */

#endif	/* HAVE_CONFIG_H */

d1246 1
a1246 3
#ifdef NO_GROUPS
    return NO;		/* Safe answer till we find the correct algorithm */
#else
d1287 2
a1288 1
    CTRACE(tfp, "\tFile is not editable.\n");
a1289 1
#endif /* NO_GROUPS */
d1304 1
a1304 1
    FILE* fp = fopen(localname, "w");
d1367 3
a1369 3
**	and NO_PARENT_DIR_REFERENCE is not defined, such that the
**	calling function use LYListFmtParse() to create a link to
**	the parent directory.  Otherwise, it returns FALSE. - FM
d1385 1
a1385 1
    if (logical[18] == ':') local_link = TRUE;
d1420 1
a1420 1
      printable = HTfullURL_toFile(
d1423 2
a1424 1
	    : path);
d1475 3
d1498 2
a1499 2
	if (local_link)
	    if (strlen(parent) == 3 )
d1501 3
a1506 3
#ifdef DOSPATH
	if(!local_link)
#endif
d1603 3
a1605 7
    char * readme_file_name =
	malloc(strlen(localname)+ 1 + strlen(HT_DIR_README_FILE) + 1);
    if (readme_file_name == NULL)
	outofmem(__FILE__, "do_readme");
    strcpy(readme_file_name, localname);
    strcat(readme_file_name, "/");
    strcat(readme_file_name, HT_DIR_README_FILE);
d1607 1
a1607 1
    fp = fopen(readme_file_name,  "r");
d1615 2
a1616 2
	    char c = fgetc(fp);
	    if (c == (char)EOF) break;
d1632 1
a1632 1
			PUTC(c);
d1635 1
a1635 1
	    PUTC(c);
d1663 1
d1665 1
a1665 1
    CTRACE(tfp, "print_local_dir() started\n");
d1704 2
a1705 4
    { int i;
	   for (i = 0; i < HTML_A_ATTRIBUTES; i++)
		   present[i] = (i == HTML_A_HREF);
    }
d1732 1
a1732 1
	_HTProgress (gettext("Reading directory..."));
d1770 1
a1771 1
#ifndef DIRED_SUPPORT
d1777 1
d1815 1
a1815 1
	    _HTProgress (gettext("OK"));
d1817 1
a1817 1
	    CTRACE(tfp, "Reading the directory interrupred by user\n");
d1826 1
a1826 1
	    int num_of_entries_partial = 0; /* lines counter */
d1841 9
d1855 1
a1855 1
		    StrAllocCat(tmpfilename, "/");
d1857 1
a1857 2
		StrAllocCat(tmpfilename,
			    (char *)HTBTree_object(next_element)+1);
d1862 1
d1889 1
a1889 1
			   (*(char *)(HTBTree_object(next_element))
d1916 1
a1916 1
			  (*(char *)(HTBTree_object(next_element))
a1935 1
		entry = (char*)HTBTree_object(next_element)+1;
d1959 1
a1959 1
		if (num_of_entries_partial %
d1962 1
a1962 1
		    /* num_of_entries, num_of_entries_partial... */
d1972 1
a1972 1
		num_of_entries_partial++;
a1988 1
	closedir(dp);
d2008 34
a2062 1
    char * ftp_newhost;
d2069 1
d2097 1
a2102 4
	ftp_newhost = HTParse(addr, "", PARSE_HOST);	/* HTParse mallocs */
	if (strcmp(ftp_lasthost, ftp_newhost))
		ftp_local_passive = ftp_passive;	/* set to default */

d2104 1
a2104 9

	if ( ftp_passive == ftp_local_passive ) {
		if (( status <= -4 ) || ( status == -1 )) {
			ftp_local_passive = !ftp_passive;
			status = HTFTPLoad(addr, anchor, format_out, sink);
		}
	}
	free(ftp_lasthost);
	ftp_lasthost = ftp_newhost;
a2105 3
#else
	return -1;
#endif /* DISABLE_FTP */
d2110 1
a2110 1
#ifdef VMS
d2152 1
a2152 1
	CTRACE(tfp, "HTLoadFile: Can't stat %s\n", filename);
d2162 3
a2164 8
		char * enable_file_name =
		    malloc(strlen(filename)+ 1 +
		    strlen(HT_DIR_ENABLE_FILE) + 1);
		if (enable_file_name == NULL)
		    outofmem(__FILE__, "HTLoadFile");
		strcpy(enable_file_name, filename);
		strcat(enable_file_name, "/");
		strcat(enable_file_name, HT_DIR_ENABLE_FILE);
d2194 1
a2194 1
	    CTRACE(tfp, "HTLoadFile: Can't open as %s\n", vmsname);
d2198 2
a2199 2
		CTRACE(tfp, "HTLoadFile: Can't open as %s\n",
			    ultrixname);
a2203 2
	    int len;
	    char *cp = NULL;
d2236 1
a2236 1
		    gzfp = gzopen(vmsname, "rb");
d2238 2
a2239 2
		    CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				vmsname, (void*)gzfp);
d2248 7
a2254 7
	    } else if ((len = strlen(vmsname)) > 2) {
		if ((vmsname[len - 1] == 'Z') &&
		    (vmsname[len - 2] == '.' ||
		     vmsname[len - 2] == '-' ||
		     vmsname[len - 2] == '_') &&
		    vmsname[len - 3] != ']' &&
		    vmsname[len - 3] != ':') {
d2256 1
a2256 1
		    cp[len - 2] = '\0';
d2262 4
d2268 3
a2270 13
		} else if ((len > 3) &&
			   !strcasecomp((char *)&vmsname[len - 2], "gz")) {
		    if (vmsname[len - 3] == '.' ||
			vmsname[len - 3] == '-' ||
			vmsname[len - 3] == '_') {
			StrAllocCopy(cp, vmsname);
			cp[len - 3] = '\0';
			format = HTFileFormat(cp, &encoding, NULL);
			FREE(cp);
			format = HTCharsetFormat(format, anchor,
						 UCLYhndl_HTFile_for_unspec);
			StrAllocCopy(anchor->content_type, format->name);
			StrAllocCopy(anchor->content_encoding, "x-gzip");
d2272 5
a2276 5
			if (strcmp(format_out->name, "www/download") != 0) {
			    fclose(fp);
			    if (semicolon != NULL)
				*semicolon = ';';
			    gzfp = gzopen(vmsname, "rb");
d2278 4
a2281 4
			    CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					vmsname, (void*)gzfp);
			    use_gzread = YES;
			}
d2283 1
a2283 1
			format = HTAtom_for("www/compressed");
d2285 7
a2291 1
		    }
d2340 1
a2340 1
#else /* Unix: */
d2371 1
a2371 1
	    float best = NO_VALUE_FOUND;	/* So far best is bad */
d2411 2
d2414 1
a2414 1
			int len = strlen(dirbuf->d_name);
d2416 1
a2416 3
			if (len > 2 &&
			    dirbuf->d_name[len - 1] == 'Z' &&
			    dirbuf->d_name[len - 2] == '.') {
d2418 1
a2418 1
			    cp[len - 2] = '\0';
d2423 12
a2434 4
			    if (value <= 0.0) {
				format = HTAtom_for("application/x-compressed");
				value = HTStackValue(format, format_out,
						     filevalue, 0);
d2436 3
a2438 13
			    if (value <= 0.0) {
				format = HTAtom_for("www/compressed");
				value = HTStackValue(format, format_out,
						     filevalue, 0);
			    }
			} else if ((len > 3) &&
				   !strcasecomp((char *)&dirbuf->d_name[len - 2],
						"gz") &&
				   dirbuf->d_name[len - 3] == '.') {
			    StrAllocCopy(cp, dirbuf->d_name);
			    cp[len - 3] = '\0';
			    format = HTFileFormat(cp, NULL, NULL);
			    FREE(cp);
d2442 1
a2442 1
				format = HTAtom_for("application/x-gzip");
d2454 2
a2455 2
			CTRACE(tfp, "HTLoadFile: value of presenting %s is %f\n",
				    HTAtom_name(rep), value);
d2492 1
a2492 5
#ifdef _WINDOWS
	if (!exists(localname))
#else
	if (stat(localname,&dir_info) == -1)	   /* get file information */
#endif
d2495 1
a2495 1
	    CTRACE(tfp, "HTLoadFile: can't stat %s\n", localname);
a2498 4
#ifdef _WINDOWS
	    if (stat(localname,&dir_info) == -1) dir_info.st_mode = S_IFDIR;
#endif

d2506 1
a2506 1
		CTRACE(tfp, "%s is a directory\n", localname);
d2519 2
d2522 1
a2522 9
		if (HTDirAccess == HT_DIR_SELECTIVE) {
		    char * enable_file_name =
			malloc(strlen(localname)+ 1 +
				      strlen(HT_DIR_ENABLE_FILE) + 1);
		    if (enable_file_name == NULL)
			outofmem(__FILE__, "HTLoadFile");
		    strcpy(enable_file_name, localname);
		    strcat(enable_file_name, "/");
		    strcat(enable_file_name, HT_DIR_ENABLE_FILE);
d2531 1
d2545 1
d2550 8
a2557 1
	   } /* end if localname is a directory */
d2565 2
a2566 7
#  ifdef __EMX__
	    int len = strlen(localname);
	    int bin = ((len > 3) && !strcasecomp(localname + len - 3, ".gz"));
	    FILE * fp = fopen(localname, (bin ? "rb" : "r"));
#  else	/* !( defined __EMX__ ) */
	    FILE * fp = fopen(localname, "r");
#  endif
d2568 2
a2569 2
	    CTRACE (tfp, "HTLoadFile: Opening `%s' gives %p\n",
				 localname, (void*)fp);
a2570 3
		int len;
		char *cp = NULL;

d2592 1
a2592 1
			gzfp = gzopen(localname, "rb");
d2594 2
a2595 2
			CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
				    localname, (void*)gzfp);
d2604 6
a2609 3
		} else if ((len = strlen(localname)) > 2) {
		    if (localname[len - 1] == 'Z' &&
			localname[len - 2] == '.') {
d2611 1
a2611 1
			cp[len - 2] = '\0';
d2617 4
d2623 2
a2624 11
		    } else if ((len > 3) &&
			       !strcasecomp((char *)&localname[len - 2],
					    "gz") &&
			       localname[len - 3] == '.') {
			StrAllocCopy(cp, localname);
			cp[len - 3] = '\0';
			format = HTFileFormat(cp, &encoding, NULL);
			FREE(cp);
			format = HTCharsetFormat(format, anchor,
						 UCLYhndl_HTFile_for_unspec);
			StrAllocCopy(anchor->content_type, format->name);
d2629 1
a2629 1
			    gzfp = gzopen(localname, "rb");
d2631 2
a2632 2
			    CTRACE(tfp, "HTLoadFile: gzopen of `%s' gives %p\n",
					localname, (void*)gzfp);
d2638 7
d2708 1
d2710 4
a2713 5
	    if (!strncmp(addr, "file://localhost", 16)) {
		return -1;  /* never go to ftp site when URL
			     * is file://localhost
			     */
	    } else {
d2715 1
a2715 3
		return HTFTPLoad(addr, anchor, format_out, sink);
#else
		return -1;
d2718 1
d2728 1
a2728 1
	CTRACE(tfp, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d1851 1
d1890 15
a1904 1
	return HTFTPLoad(addr, anchor, format_out, sink);
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
**			 the device or top directory.
d23 2
d26 5
a30 1
/* #define LONG_LIST */ /* Define this for long style unix listings (ls -l) */
a35 1
#include <dirent.h>
d37 1
a37 1
#include "HTDOS.h"
d40 1
a40 3
#include "HTUtils.h"
#include "tcp.h"
#include "HTFile.h"		/* Implemented here */
a44 7
#ifndef VMS
#ifdef LONG_LIST
#include <pwd.h>
#include <grp.h>
#endif /* LONG_LIST */
#endif /* !VMS */

d52 2
a53 10
#define HT_EM_SPACE ((char)2)

#define FREE(x) if (x) {free(x); x = NULL;}

#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */

#include "HTParse.h"
#include "HTTCP.h"
d55 1
a55 1
#include "HTFTP.h"
d57 18
a74 17
#include "HTAnchor.h"
#include "HTAtom.h"
#include "HTWriter.h"
#include "HTFWriter.h"
#include "HTInit.h"
#include "HTBTree.h"
#include "HTAlert.h"
#include "HTCJK.h"
#include "UCDefs.h"
#include "UCMap.h"
#include "UCAux.h"

#include "LYexit.h"
#include "LYCharSets.h"
#include "LYGlobalDefs.h"
#include "LYUtils.h"
#include "LYLeaks.h"
d92 5
a96 1
#include "HTML.h"		/* For directory object building */
d105 2
a118 4
#define FILES_FIRST 1
#define MIXED_STYLE 2
extern BOOLEAN lynx_edit_mode;
extern BOOLEAN dir_list_style;
a122 1
extern BOOLEAN LYRawMode;
d154 1
d156 1
d159 31
d191 2
a192 2
	char *, 	fmtstr,
	char *, 	file,
d194 2
a195 2
	char *, 	entry,
	char *, 	tail)
d203 2
a204 2
	char buf[512];
	char fmt[512];
d206 1
a206 2
	struct passwd *p;
	struct group *g;
d217 7
d226 1
a226 1
		fmtstr = "%a";	/* can't stat so just do anchor */
d251 2
a252 1
		while (isdigit(*s) || *s == '.' || *s == '-')
d254 1
a254 1
		c = *s; 	/* the format char. or \0 */
d259 2
a260 1
			break;
d265 1
a265 2
			sprintf(fmt, "%%%ss", start);
			sprintf(buf, fmt, entry);
d268 1
d270 2
a271 2
			if (c != 'A' && (st.st_mode & S_IFMT) == S_IFLNK &&
			    (len = readlink(file, buf, sizeof(buf))) >= 0) {
d273 2
a274 2
				buf[len] = '\0';
				PUTS(buf);
a276 1
			*buf = '\0';
d279 31
d317 1
a317 1
				sprintf(buf, "%.12s", datestr + 4);
d322 3
a324 4
				sprintf(buf, "%.7s %.4s ", datestr + 4,
				  datestr + 20);
			sprintf(fmt, "%%%ss", start);
			sprintf(buf, fmt, buf);
d328 1
a328 2
			sprintf(fmt, "%%%sd", start);
			sprintf(buf, fmt, st.st_size);
d332 2
a333 3
			if ((st.st_mode & S_IFMT) == S_IFDIR) {
				sprintf(fmt, "%%%ss ", start);
				sprintf(buf, fmt, "");
d338 2
a339 2
			sprintf(fmt, "%%%sdK", start);
			sprintf(buf, fmt, (st.st_size+1023)/1024);
d355 1
a355 1
# ifdef S_IFIFO 	/* some older machines (e.g., apollo) have a conflict */
d365 5
a369 6
			sprintf(buf, "%c%s%s%s", type,
			  PBIT(st.st_mode, 6, st.st_mode & S_ISUID),
			  PBIT(st.st_mode, 3, st.st_mode & S_ISGID),
			  PBIT(st.st_mode, 0, 0));
			sprintf(fmt, "%%%ss", start);
			sprintf(buf, fmt, buf);
d373 3
a375 5
			sprintf(fmt, "%%%ss", start);
			p = getpwuid(st.st_uid);
			if (p) {
				sprintf(fmt, "%%%ss", start);
				sprintf(buf, fmt, p->pw_name);
d377 1
a377 3

				sprintf(fmt, "%%%sd", start);
				sprintf(buf, fmt, st.st_uid);
d382 3
a384 4
			g = getgrgid(st.st_gid);
			if (g) {
				sprintf(fmt, "%%%ss", start);
				sprintf(buf, fmt, g->gr_name);
d386 1
a386 2
				sprintf(fmt, "%%%sd", start);
				sprintf(buf, fmt, st.st_gid);
d391 5
a395 2
			sprintf(fmt, "%%%sd", start);
			sprintf(buf, fmt, st.st_nlink);
d403 2
a404 1
		PUTS(buf);
d408 1
d410 1
a410 1
	PUTS("\n");
d464 1
d466 1
d490 1
d522 1
a523 53
/*	Send README file.
**	-----------------
**
**  If a README file exists, then it is inserted into the document here.
*/
#ifdef HAVE_READDIR
PRIVATE void do_readme ARGS2(HTStructured *, target, CONST char *, localname)
{
    FILE * fp;
    char * readme_file_name =
	malloc(strlen(localname)+ 1 + strlen(HT_DIR_README_FILE) + 1);
    if (readme_file_name == NULL)
	outofmem(__FILE__, "do_readme");
    strcpy(readme_file_name, localname);
    strcat(readme_file_name, "/");
    strcat(readme_file_name, HT_DIR_README_FILE);

    fp = fopen(readme_file_name,  "r");

    if (fp) {
	HTStructuredClass targetClass;

	targetClass =  *target->isa;	/* (Can't init agregate in K&R) */
	START(HTML_PRE);
	for (;;){
	    char c = fgetc(fp);
	    if (c == (char)EOF) break;
#ifdef NOTDEFINED
	    switch (c) {
		case '&':
		case '<':
		case '>':
			PUTC('&');
			PUTC('#');
			PUTC((char)(c / 10));
			PUTC((char) (c % 10));
			PUTC(';');
			break;
/*		case '\n':
			PUTC('\r');
Bug removed thanks to joe@@athena.mit.edu */
		default:
			PUTC(c);
	    }
#else
	    PUTC(c);
#endif /* NOTDEFINED */
	}
	END(HTML_PRE);
	fclose(fp);
    }
}
#endif /* HAVE_READDIR */
d541 3
a544 7
    char * result;
    result = (char *)malloc(
	    strlen(HTCacheRoot)+strlen(acc_method)
	    +strlen(host)+strlen(path)+6+1);
    if (result == NULL)
	outofmem(__FILE__, "HTCacheFileName");
    sprintf(result, "%s/WWW/%s/%s%s", HTCacheRoot, acc_method, host, path);
d571 4
a574 2
PUBLIC char * HTLocalName ARGS1(
	CONST char *,	name)
d579 2
d582 4
a585 1
    HTUnEscape(path);	/* Interpret % signs */
d587 2
a588 2
    if (0 == strcmp(acc_method, "file")) { /* local file */
	FREE(acc_method);
d591 1
a591 3
	    FREE(host);
	    if (TRACE)
		fprintf(stderr, "Node `%s' means path `%s'\n", name, path);
d593 10
a602 10
	    {
		char *ret_path = NULL;
		StrAllocCopy(ret_path, HTDOS_name(path));
		if (TRACE) {
		    fprintf(stderr, "HTDOS_name changed `%s' to `%s'\n",
			    path, ret_path);
		}
		FREE(path);
		return(ret_path);
	    }
d604 2
a605 1
	    return(path);
d607 3
d611 1
a611 10
	    char * result = (char *)malloc(
				strlen("/Net/")+strlen(host)+strlen(path)+1);
	      if (result == NULL)
		  outofmem(__FILE__, "HTLocalName");
	    sprintf(result, "%s%s%s", "/Net/", host, path);
	    FREE(host);
	    FREE(path);
	    if (TRACE)
		fprintf(stderr, "Node `%s' means file `%s'\n", name, result);
	    return result;
d613 1
a613 2
    } else {  /* other access */
	char * result;
d615 1
a615 2
	char * home =  getenv("HOME");
	if (!home)
d620 1
a620 2
	CONST char * home =  (CONST char*)getenv("HOME");
	if (!home)
d623 3
a625 9
	result = (char *)malloc(
		strlen(home)+strlen(acc_method)+strlen(host)+strlen(path)+6+1);
	if (result == NULL)
	    outofmem(__FILE__, "HTLocalName");
	sprintf(result, "%s/WWW/%s/%s%s", home, acc_method, host, path);
	FREE(path);
	FREE(acc_method);
	FREE(host);
	return result;
d627 6
d640 1
a640 1
**	in and valid for the NeXT only. This should be configurable in
d646 1
a646 1
    char * result;
d649 1
a649 4
	result = (char *)malloc(7+strlen(name+13)+1);
	if (result == NULL)
	    outofmem(__FILE__, "WWW_nameOfFile");
	sprintf(result, "file://%s", name+13);
d653 1
a653 4
	result = (char *)malloc(7+strlen(name+5)+1);
	if (result == NULL)
	    outofmem(__FILE__, "WWW_nameOfFile");
	sprintf(result, "file://%s", name+5);
d655 1
a655 4
	result = (char *)malloc(7+strlen(HTHostName())+strlen(name)+1);
	if (result == NULL)
	    outofmem(__FILE__, "WWW_nameOfFile");
	sprintf(result, "file://%s%s", HTHostName(), name);
d657 1
a657 2
    if (TRACE)
	fprintf(stderr, "File `%s'\n\tmeans node `%s'\n", name, result);
a851 1
    int i;
d855 1
a855 2
    for (i = 0; cp[i]; i++)
	cp[i] = TOLOWER(cp[i]);
d858 1
a858 3
	if (TRACE)
	    fprintf(stderr,
		    "HTCharsetFormat: Extended MIME Content-Type is %s\n",
d885 6
d935 1
a935 21
		if (LYRawMode) {
		    if ((!strcmp(p_in->MIMEname, "euc-jp") ||
			 !strcmp(p_in->MIMEname, "shift_jis")) &&
			(!strcmp(p_out->MIMEname, "euc-jp") ||
			 !strcmp(p_out->MIMEname, "shift_jis"))) {
			HTCJK = JAPANESE;
		    } else if (!strcmp(p_in->MIMEname, "euc-cn") &&
			       !strcmp(p_out->MIMEname, "euc-cn")) {
			HTCJK = CHINESE;
		    } else if (!strcmp(p_in->MIMEname, "big-5") &&
			       !strcmp(p_out->MIMEname, "big-5")) {
			HTCJK = TAIPEI;
		    } else if (!strcmp(p_in->MIMEname, "euc-kr") &&
			       !strcmp(p_out->MIMEname, "euc-kr")) {
			HTCJK = KOREAN;
		    } else {
			HTCJK = NOCJK;
		    }
		} else {
		    HTCJK = NOCJK;
		}
d937 1
a937 7
	/*
	**  Check for an iso-8859-# we don't know. - FM
	*/
	} else if (!strncmp(cp4, "iso-8859-", 9) &&
		   isdigit((unsigned char)cp4[9]) &&
		   !strncmp(LYchar_set_names[current_char_set],
			    "Other ISO Latin", 15)) {
d939 6
a944 1
	    **	Hope it's a match, for now. - FM
d946 31
a976 10
	    *cp1 = '\0';
	    format = HTAtom_for(cp);
	    cp1 = &cp4[10];
	    while (*cp1 &&
		   isdigit((unsigned char)(*cp1)))
		cp1++;
	    *cp1 = '\0';
	    StrAllocCopy(anchor->charset, cp4);
	    HTPassEightBitRaw = TRUE;
	    HTAlert(anchor->charset);
d1028 2
a1029 3
	    if (TRACE)
		fprintf(stderr, "File: Value of %s is %.3f\n",
				filename, suff->quality);
d1033 1
a1033 1
    return 0.3; 	/* Dunno! */
d1076 1
a1076 5
#ifdef NeXT
    int 	groups[NGROUPS];
#else
    gid_t	groups[NGROUPS];
#endif /* NeXT */
d1078 1
a1078 1
    int 	ngroups;			/* The number of groups  */
d1080 1
a1080 1
    int 	i;
d1090 1
a1090 1
	fprintf(stderr,
d1092 5
a1096 3
	    (unsigned int) fileStatus.st_mode, fileStatus.st_uid,
	    fileStatus.st_gid,
	    myUid, ngroups);
d1098 2
a1099 2
	    fprintf(stderr, " %d", groups[i2]);
	fprintf(stderr, ")\n");
d1116 1
a1116 2
    if (TRACE)
	fprintf(stderr, "\tFile is not editable.\n");
d1176 2
a1177 4
	relative = (char*)malloc(strlen(tail) + strlen(escaped)+2);
	if (relative == NULL)
	    outofmem(__FILE__, "HTDirEntry");
	sprintf(relative, "%s%s%s",
d1249 5
a1253 5
      if (0 == strncasecomp(path, "/%2F", 4))
	  StrAllocCopy(printable, (path+1));
      else
	  StrAllocCopy(printable, path);
      if (0 == strncasecomp(printable, "/vmsysu%2b", 10) ||
d1261 1
d1265 1
a1265 2
      PUTS("\n");
      HTUnEscape(printable);
d1267 2
a1268 2
      PUTS(*printable ? printable : "Welcome");
      PUTS(" directory");
d1270 1
a1270 1
      PUTS("\n");
d1272 1
a1272 1
      PUTS("\n");
d1276 2
a1277 2
      PUTS(*printable ? "Current directory is " : "");
      PUTS(*printable ? printable : "Welcome");
d1279 1
a1279 1
      PUTS("\n");
d1282 1
a1282 1
      PUTS(*printable ? printable : "Welcome");
d1284 1
a1284 1
      PUTS("\n");
d1319 2
a1320 4
	relative = (char*) malloc(strlen(current) + 4);
	if (relative == NULL)
	    outofmem(__FILE__, "HTDirTitles");
	sprintf(relative, "%s/..", current);
d1390 1
a1390 1
	PUTS("Up to ");
d1407 1
a1407 1
	    PUTS("/");
d1410 1
d1419 412
d1839 1
a1839 1
**	returns 	<0		Error has occurred.
d1888 1
d1890 3
d1913 7
d1928 1
a1928 1
	format = HTCharsetFormat(format, anchor, UCLYhndl_HTFile_for_unspec);
d1939 1
a1939 2
	if (TRACE)
	    fprintf(stderr, "HTLoadFile: Can't stat %s\n", filename);
d1941 1
a1941 1
	if (((stat_info.st_mode) & S_IFMT) == S_IFDIR) {
d1945 1
a1945 2
		return HTLoadError(sink, 403,
		"Directory browsing is not allowed.");
d1960 2
a1961 2
		    return HTLoadError(sink, 403,
		    "Selective access is not enabled for this directory");
d1985 3
a1987 4
	    char ultrixname[INFINITY];
	    if (TRACE)
		fprintf(stderr, "HTLoadFile: Can't open as %s\n", vmsname);
	    sprintf(ultrixname, "%s::\"%s\"", nodename, filename);
d1990 2
a1991 3
		if (TRACE)
		    fprintf(stderr, "HTLoadFile: Can't open as %s\n",
				    ultrixname);
d1993 1
d2032 1
a2032 3
		    if (TRACE)
			fprintf(stderr,
				"HTLoadFile: gzopen of `%s' gives %p\n",
d2078 1
a2078 3
			    if (TRACE)
				fprintf(stderr,
				       "HTLoadFile: gzopen of `%s' gives %p\n",
d2121 1
a2121 1
					 "Could not open file for decompression!");
d2161 1
a2161 1
	    DIR *dp;
d2176 1
a2176 1
		*base++ = '\0'; 	/* Just got directory name */
d2185 1
a2185 2
		return HTLoadError(sink, 500,
			"Multiformat: directory scan failed.");
d2250 1
a2250 3
			if (TRACE)
			    fprintf(stderr,
				 "HTLoadFile: value of presenting %s is %f\n",
d2257 1
a2257 1
		       }
d2267 1
a2267 1
		base[-1] = '/'; 	/* Restore directory name */
d2274 1
a2274 2
		return HTLoadError(sink, 403,	/* List formats? */
		   "Could not find suitable representation for transmission.");
d2294 2
a2295 3
				       /* if can't read file information */
	    if (TRACE)
		fprintf(stderr, "HTLoadFile: can't stat %s\n", localname);
d2303 1
a2303 1
	    if (((dir_info.st_mode) & S_IFMT) == S_IFDIR) {
a2306 2
		HTStructured *target;		/* HTML object */
		HTStructuredClass targetClass;
a2307 7
		STRUCT_DIRENT * dirbuf;
		char *logical = NULL;
		char *pathname = NULL;
		char *tail = NULL;
		BOOL present[HTML_A_ATTRIBUTES];
		char * tmpfilename = NULL;
		BOOL need_parent_link = FALSE;
d2310 1
a2310 2
		if (TRACE)
		    fprintf(stderr, "%s is a directory\n", localname);
d2320 1
a2320 2
		    return HTLoadError(sink, 403,
		    "Directory browsing is not allowed.");
d2336 2
a2337 2
			return HTLoadError(sink, 403,
			"Selective access is not enabled for this directory");
d2345 1
a2345 2
		    return HTLoadError(sink, 403,
				       "This directory is not readable.");
a2350 3
		logical = HTAnchor_address((HTAnchor*)anchor);
		pathname = HTParse(logical, "",
					PARSE_PATH + PARSE_PUNCTUATION);
d2352 5
a2356 29
		if (!strcmp(pathname,"/")) {
		    /*
		    **	Root path.
		    */
		    StrAllocCopy (tail, "/foo/..");
		} else {
		    char *p = strrchr(pathname, '/');  /* find last slash */

		    if (!p) {
			/*
			**  This probably should not happen,
			**  but be prepared if it does. - KW
			*/
			StrAllocCopy (tail, "/foo/..");
		    } else {
			/*
			**  Take slash off the beginning.
			*/
			StrAllocCopy(tail, (p + 1));
		    }
		}
		FREE(pathname);

		if (UCLYhndl_HTFile_for_unspec >= 0) {
		    HTAnchor_setUCInfoStage(anchor,
					    UCLYhndl_HTFile_for_unspec,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_DEFAULT);
		}
d2358 1
a2358 238
		target = HTML_new(anchor, format_out, sink);
		targetClass = *target->isa;	/* Copy routine entry points */

		{ int i;
			for (i = 0; i < HTML_A_ATTRIBUTES; i++)
				present[i] = (i == HTML_A_HREF);
		}

		/*
		**  The need_parent_link flag will be set if an
		**  "Up to <parent>" link was not created for a
		**  readable parent in HTDirTitles() because
		**  LONG_LIST is defined and NO_PARENT_DIR_REFERENCE
		**  is not defined so that need we to create the
		**  link via an LYListFmtParse() call. - FM
		*/
		need_parent_link = HTDirTitles(target,
					       (HTAnchor *)anchor, FALSE);

#ifdef DIRED_SUPPORT
		if (strncmp(anchor->address, "lynxcgi:", 8)) {
		    HTAnchor_setFormat((HTParentAnchor *) anchor, WWW_DIRED);
		    lynx_edit_mode = TRUE;
		}
#endif /* DIRED_SUPPORT */
		if (HTDirReadme == HT_DIR_README_TOP)
		    do_readme(target, localname);
		{
		    HTBTree * bt = HTBTree_new((HTComparer)strcmp);

		    while ((dirbuf = readdir(dp)) != NULL) {
			/*
			**  While there are directory entries to be read...
			*/
			char * dirname = NULL;

#ifndef DOSPATH
			if (dirbuf->d_ino == 0)
			    /*
			    **	If the entry is not being used, skip it.
			    */
			    continue;
#endif
			/*
			**  Skip self, parent if handled in HTDirTitles()
			**  or if NO_PARENT_DIR_REFERENCE is not defined,
			**  and any dot files if no_dotfiles is set or
			**  show_dotfiles is not set. - FM
			*/
			if (!strcmp(dirbuf->d_name, ".")   /* self   */ ||
			    (!strcmp(dirbuf->d_name, "..") /* parent */ &&
			     need_parent_link == FALSE) ||
			    ((strcmp(dirbuf->d_name, "..")) &&
			     (dirbuf->d_name[0] == '.' &&
			      (no_dotfiles || !show_dotfiles))))
			    continue;

			dirname = (char *)malloc(strlen(dirbuf->d_name) + 4);
			if (dirname == NULL)
			    outofmem(__FILE__, "HTLoadFile");
			StrAllocCopy(tmpfilename, localname);
			if (strcmp(localname, "/"))
			    /*
			    **	If filename is not root directory.
			    */
			    StrAllocCat(tmpfilename, "/");

			StrAllocCat(tmpfilename, dirbuf->d_name);
			stat(tmpfilename, &file_info);
			if (((file_info.st_mode) & S_IFMT) == S_IFDIR)
#ifndef DIRED_SUPPORT
			    sprintf((char *)dirname, "D%s",dirbuf->d_name);
			else
			    sprintf((char *)dirname, "F%s",dirbuf->d_name);
			    /* D & F to have first directories, then files */
#else
			    if (dir_list_style == MIXED_STYLE)
				sprintf((char *)dirname,
					" %s/", dirbuf->d_name);
			    else if (!strcmp(dirbuf->d_name, ".."))
				sprintf((char *)dirname,
					"A%s", dirbuf->d_name);
			    else
				sprintf((char *)dirname,
					"D%s", dirbuf->d_name);
			else if (dir_list_style == MIXED_STYLE)
			    sprintf((char *)dirname, " %s", dirbuf->d_name);
			else if (dir_list_style == FILES_FIRST)
			    sprintf((char *)dirname, "C%s", dirbuf->d_name);
			    /* C & D to have first files, then directories */
			else
			    sprintf((char *)dirname, "F%s", dirbuf->d_name);
#endif /* !DIRED_SUPPORT */
			/*
			**  Sort dirname in the tree bt.
			*/
			HTBTree_add(bt, dirname);
		    }

		    /*
		    **	Run through tree printing out in order.
		    */
		    {
			HTBTElement * next_element = HTBTree_next(bt,NULL);
			    /* pick up the first element of the list */
			char state;
			    /* I for initial (.. file),
			       D for directory file,
			       F for file */

#ifdef DIRED_SUPPORT
			char test;
#endif /* DIRED_SUPPORT */
			state = 'I';

			while (next_element != NULL) {
			    char *entry, *file_extra;

			    StrAllocCopy(tmpfilename,localname);
			    if (strcmp(localname, "/"))
				/*
				**  If filename is not root directory.
				*/
				StrAllocCat(tmpfilename, "/");

			    StrAllocCat(tmpfilename,
					(char *)HTBTree_object(next_element)+1);
			    /*
			    **	Append the current entry's filename
			    **	to the path.
			    */
			    HTSimplify(tmpfilename);
			    /*
			    **	Output the directory entry.
			    */
			    if (strcmp((char *)
				       (HTBTree_object(next_element)), "D..") &&
				strcmp((char *)
				       (HTBTree_object(next_element)), "A.."))
			    {
#ifdef DIRED_SUPPORT
				test = (*(char *)(HTBTree_object(next_element))
					== 'D' ? 'D' : 'F');
				if (state != test) {
#ifndef LONG_LIST
				    if (dir_list_style == FILES_FIRST) {
				       if (state == 'F')
					  END(HTML_DIR);
				    } else if (dir_list_style != MIXED_STYLE)
				       if (state == 'D')
					  END(HTML_DIR);
#endif /* !LONG_LIST */
				    state =
				       (*(char *)(HTBTree_object(next_element))
					== 'D' ? 'D' : 'F');
				    START(HTML_H2);
				    if (dir_list_style != MIXED_STYLE) {
				       START(HTML_EM);
				       PUTS(state == 'D' ?
					  "Subdirectories:" : "Files:");
				       END(HTML_EM);
				    }
				    END(HTML_H2);
#ifndef LONG_LIST
				    START(HTML_DIR);
#endif /* !LONG_LIST */
				}
#else
				if (state != *(char *)(HTBTree_object(
							 next_element))) {
#ifndef LONG_LIST
				    if (state == 'D')
					END(HTML_DIR);
#endif /* !LONG_LIST */
				    state =
				      (*(char *)(HTBTree_object(next_element))
				       == 'D' ? 'D' : 'F');
				    START(HTML_H2);
				    START(HTML_EM);
				    PUTS(state == 'D' ?
				    "Subdirectories:" : "Files:");
				    END(HTML_EM);
				    END(HTML_H2);
#ifndef LONG_LIST
				    START(HTML_DIR);
#endif /* !LONG_LIST */
				}
#endif /* DIRED_SUPPORT */
#ifndef LONG_LIST
				START(HTML_LI);
#endif /* !LONG_LIST */
			    }
			    entry = (char*)HTBTree_object(next_element)+1;
			    file_extra = NULL;

#ifdef LONG_LIST
			    LYListFmtParse(list_format, tmpfilename, target,
				entry, tail);
#else
			    HTDirEntry(target, tail, entry);
			    PUTS(entry);
			    END(HTML_A);
			    if (file_extra) {
				PUTS(file_extra);
				FREE(file_extra);
			    }
			    MAYBE_END(HTML_LI);
#endif /* LONG_LIST */

			    next_element = HTBTree_next(bt, next_element);
				/* pick up the next element of the list;
				 if none, return NULL*/
			}
			if (state == 'I') {
			    START(HTML_P);
			    PUTS("Empty Directory");
			}
#ifndef LONG_LIST
			else
			    END(HTML_DIR);
#endif /* !LONG_LIST */
		    }
			/* end while directory entries left to read */
		    closedir(dp);
		    FREE(logical);
		    FREE(tmpfilename);
		    FREE(tail);
		    HTBTreeAndObject_free(bt);

		    if (HTDirReadme == HT_DIR_README_BOTTOM)
			  do_readme(target, localname);
		    FREE_TARGET;
		    FREE(localname);
		    FREE(nodename);
		    return HT_LOADED;	/* document loaded */
		}

	    } /* end if localname is directory */
d2366 5
d2372 1
d2374 1
a2374 2
	    if (TRACE)
		fprintf (stderr, "HTLoadFile: Opening `%s' gives %p\n",
d2403 1
a2403 3
			if (TRACE)
			    fprintf(stderr,
				    "HTLoadFile: gzopen of `%s' gives %p\n",
d2442 1
a2442 3
			    if (TRACE)
				fprintf(stderr,
				       "HTLoadFile: gzopen of `%s' gives %p\n",
d2482 1
a2482 1
				     "Could not open file for decompression!");
d2518 1
d2520 3
d2533 1
a2533 2
	if (TRACE)
	    fprintf(stderr, "Can't open `%s', errno=%d\n", addr, SOCKET_ERRNO);
d2535 1
a2535 1
	return HTLoadError(sink, 403, "Can't access requested file.");
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
