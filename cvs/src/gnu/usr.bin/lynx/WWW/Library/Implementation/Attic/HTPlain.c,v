head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.48;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTPlain.c,v 1.51 2013/05/02 11:09:30 tom Exp $
 *
 *		Plain text object		HTWrite.c
 *		=================
 *
 *	This version of the stream object just writes to a socket.
 *	The socket is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>
#include <LYCharVals.h>		/* S/390 -- gil -- 0288 */

#include <HTPlain.h>

#include <HTChunk.h>
#include <HText.h>
#include <HTStyle.h>
#define Lynx_HTML_Handler
#include <HTML.h>		/* styles[] */

#define BUFFER_SIZE 4096;	/* Tradeoff */

#include <HTMLDTD.h>
#include <HTCJK.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYCharSets.h>
#include <LYStrings.h>
#include <LYLeaks.h>

static int HTPlain_lastraw = -1;
static int HTPlain_bs_pending = 0;	/* 1:bs 2:underline 3:underline+bs - kw */

/*		HTML Object
 *		-----------
 */
struct _HTStream {
    const HTStreamClass *isa;
    HText *text;
    /*
     * The node_anchor UCInfo and handle for the input (PARSER) stage.  - FM
     */
    LYUCcharset *inUCI;
    int inUCLYhndl;
    /*
     * The node_anchor UCInfo and handle for the output (HTEXT) stage.  - FM
     */
    LYUCcharset *outUCI;
    int outUCLYhndl;
    /*
     * Counter, value, buffer and pointer for UTF-8 handling.  - FM
     */
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char *utf_buf_p;
    /*
     * The charset transformation structure.  - FM
     */
    UCTransParams T;
};

static char replace_buf[64];	/* buffer for replacement strings */

static void HTPlain_getChartransInfo(HTStream *me, HTParentAnchor *anchor)
{
    if (me->inUCLYhndl < 0) {
	HTAnchor_copyUCInfoStage(anchor, UCT_STAGE_PARSER, UCT_STAGE_MIME,
				 UCT_SETBY_PARSER);
	me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
    }
    if (me->outUCLYhndl < 0) {
	int chndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);

	if (chndl < 0) {
	    chndl = current_char_set;
	    HTAnchor_setUCInfoStage(anchor, chndl,
				    UCT_STAGE_HTEXT, UCT_SETBY_DEFAULT);
	}
	HTAnchor_setUCInfoStage(anchor, chndl,
				UCT_STAGE_HTEXT, UCT_SETBY_DEFAULT);
	me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
    }
    me->inUCI = HTAnchor_getUCInfoStage(anchor, UCT_STAGE_PARSER);
    me->outUCI = HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT);
}

/*	Write the buffer out to the socket
 *	----------------------------------
 */

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */

static void HTPlain_write(HTStream *me, const char *s,
			  int l);

/*	Character handling
 *	------------------
 */
static void HTPlain_put_character(HTStream *me, int c)
{
#ifdef REMOVE_CR_ONLY
    /*
     * Throw away \r's.
     */
    if (c != '\r') {
	HText_appendCharacter(me->text, c);
    }
#else
    /*
     * See HTPlain_write() for explanations of the following code (we've been
     * called via HTPlain_put_string() to do for each character of a terminated
     * string what HTPlain_write() does via a while loop for each character in
     * a stream of given length).  - FM
     */
    if ((HTPlain_lastraw == '\r') && c == '\n') {
	HTPlain_lastraw = -1;
	return;
    }
    if (c == '\b' || c == '_' || HTPlain_bs_pending) {
	char temp[1];

	temp[0] = (char) c;
	HTPlain_write(me, temp, 1);
	return;
    }
    HTPlain_lastraw = UCH(c);
    if (c == '\r') {
	HText_appendCharacter(me->text, '\n');
    } else if (TOASCII(UCH(c)) >= 127) {	/* S/390 -- gil -- 0305 */
	char temp[1];

	temp[0] = (char) c;
	/*
	 * For now, don't repeat everything here that has been done below - KW
	 */
	HTPlain_write(me, temp, 1);
    } else if (IS_CJK_TTY) {
	HText_appendCharacter(me->text, c);
    } else if (TOASCII(UCH(c)) >= 127 && TOASCII(UCH(c)) < 161 &&
	       HTPassHighCtrlRaw) {
	HText_appendCharacter(me->text, c);
#if CH_NBSP < 127
    } else if (UCH(c) == CH_NBSP) {	/* S/390 -- gil -- 0341 */
	HText_appendCharacter(me->text, ' ');
#endif
#if CH_SHY < 127
    } else if (UCH(c) == CH_SHY) {
	return;
#endif
    } else if ((UCH(c) >= ' ' && TOASCII(UCH(c)) < 127) ||
	       c == '\n' || c == '\t') {
	HText_appendCharacter(me->text, c);
    }
#endif /* REMOVE_CR_ONLY */
}

/*	String handling
 *	---------------
 *
 */
static void HTPlain_put_string(HTStream *me, const char *s)
{
#ifdef REMOVE_CR_ONLY
    HText_appendText(me->text, s);
#else
    const char *p;

    if (s == NULL)
	return;
    for (p = s; *p; p++) {
	HTPlain_put_character(me, *p);
    }
#endif /* REMOVE_CR_ONLY */
}

/*
 *	Entry function for displayed text/plain and WWW_SOURCE strings. - FM
 *	---------------------------------------------------------------
 */
static void HTPlain_write(HTStream *me, const char *s, int l)
{
    const char *p;
    const char *e = s + l;
    char c;
    unsigned c_unsign;
    BOOL chk;
    UCode_t code, uck = -1;
    char saved_char_in = '\0';

    for (p = s; p < e; p++) {
#ifdef REMOVE_CR_ONLY
	/*
	 * Append the whole string, but remove any \r's.  - FM
	 */
	if (*p != '\r') {
	    HText_appendCharacter(me->text, *p);
	}
#else
	if (*p == '\b') {
	    if (HTPlain_lastraw >= UCH(' ') &&
		HTPlain_lastraw != '\r' && HTPlain_lastraw != '\n') {
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 1;
		    continue;
		} else if (HTPlain_bs_pending == 2) {
		    HTPlain_bs_pending = 3;
		    continue;
		}
	    }
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (*p == '_') {
	    if (!HTPlain_bs_pending) {
		HTPlain_bs_pending = 2;
		HTPlain_lastraw = UCH(*p);
		continue;
#if 0
	    } else if (HTPlain_bs_pending != 2) {
		HTPlain_bs_pending--;	/* 1 -> 0, 3 -> 2 */
		HTPlain_lastraw = UCH(*p);
		continue;
#endif
	    }
	}

	/*
	 * Try to handle lone LFs, CRLFs and lone CRs as newline, and to deal
	 * with control, ASCII, and 8-bit characters based on best guesses of
	 * what's appropriate.  - FM
	 */
	if ((HTPlain_lastraw == '\r') && *p == '\n') {
	    HTPlain_lastraw = -1;
	    continue;
	}

	if (HTPlain_bs_pending &&
	    !(UCH(*p) >= ' ' && *p != '\r' && *p != '\n' &&
	      (HTPlain_lastraw == UCH(*p) ||
	       HTPlain_lastraw == UCH('_') ||
	       *p == '_'))) {
	    if (HTPlain_bs_pending >= 2)
		HText_appendCharacter(me->text, '_');
	    HTPlain_bs_pending = 0;
	} else if (HTPlain_bs_pending == 1) {
	    HTPlain_bs_pending = 0;
	    continue;		/* ignore last two of "X\bX" or "X\b_" - kw */
	} else if (HTPlain_bs_pending == 3) {
	    if (*p == '_') {
		HTPlain_bs_pending = 2;
		continue;	/* ignore last two of "_\b_" - kw */
	    } else {
		HTPlain_bs_pending = 0;
		/* ignore first two of "_\bX" - kw */
	    }
	} else if (HTPlain_bs_pending == 2) {
	    HText_appendCharacter(me->text, '_');
	    if (*p == '_')
		continue;	/* keep second of "__" pending - kw */
	    HTPlain_bs_pending = 0;
	} else {
	    HTPlain_bs_pending = 0;
	}
	HTPlain_lastraw = UCH(*p);
	if (*p == '\r') {
	    HText_appendCharacter(me->text, '\n');
	    continue;
	}
	/*
	 * Make sure the character is handled as Unicode whenever that's
	 * appropriate.  - FM
	 */
	c = *p;
	c_unsign = UCH(c);
	code = (UCode_t) c_unsign;
	saved_char_in = '\0';
	/*
	 * Combine any UTF-8 multibytes into Unicode to check for special
	 * characters.  - FM
	 */
	if (me->T.decode_utf8) {
	    /*
	     * Combine UTF-8 into Unicode.  Incomplete characters silently
	     * ignored.  from Linux kernel's console.c - KW
	     */
	    if (TOASCII(c_unsign) > 127) {	/* S/390 -- gil -- 0371 */
		/*
		 * We have an octet from a multibyte character.  - FM
		 */
		if (me->utf_count > 0 && (c & 0xc0) == 0x80) {
		    /*
		     * Adjust the UCode_t value, add the octet to the buffer,
		     * and decrement the byte count.  - FM
		     */
		    me->utf_char = (me->utf_char << 6) | (c & 0x3f);
		    me->utf_count--;
		    *(me->utf_buf_p) = c;
		    (me->utf_buf_p)++;
		    if (me->utf_count == 0) {
			/*
			 * Got a complete multibyte character.
			 */
			*(me->utf_buf_p) = '\0';
			code = me->utf_char;
			if (code > 0 && code < 256) {
			    c = FROMASCII((char) code);
			    c_unsign = UCH(c);
			}
		    } else {
			/*
			 * Get the next byte.  - FM
			 */
			continue;
		    }
		} else {
		    /*
		     * Start handling a new multibyte character.  - FM
		     */
		    me->utf_buf_p[0] = c;
		    me->utf_buf_p = &me->utf_buf[1];
		    if ((*p & 0xe0) == 0xc0) {
			me->utf_count = 1;
			me->utf_char = (c & 0x1f);
		    } else if ((*p & 0xf0) == 0xe0) {
			me->utf_count = 2;
			me->utf_char = (c & 0x0f);
		    } else if ((*p & 0xf8) == 0xf0) {
			me->utf_count = 3;
			me->utf_char = (c & 0x07);
		    } else if ((*p & 0xfc) == 0xf8) {
			me->utf_count = 4;
			me->utf_char = (c & 0x03);
		    } else if ((*p & 0xfe) == 0xfc) {
			me->utf_count = 5;
			me->utf_char = (c & 0x01);
		    } else {
			/*
			 * We got garbage, so ignore it.  - FM
			 */
			me->utf_count = 0;
			me->utf_buf_p[0] = '\0';
			me->utf_buf_p = me->utf_buf;
		    }
		    /*
		     * Get the next byte.  - FM
		     */
		    continue;
		}
	    } else if (me->utf_count > 0) {
		/*
		 * Got an ASCII character when expecting UTF-8 multibytes, so
		 * ignore the buffered multibye characters and fall through
		 * with the current ASCII character.  - FM
		 */
		me->utf_count = 0;
		me->utf_buf[0] = '\0';
		me->utf_buf_p = me->utf_buf;
		code = (UCode_t) c_unsign;
	    } else {
		/*
		 * Got a valid ASCII character, so fall through with it.  - FM
		 */
		code = (UCode_t) c_unsign;
	    }
	}
	/*
	 * Convert characters from non-UTF-8 charsets to Unicode (if
	 * appropriate).  - FM
	 */
	if (!(me->T.decode_utf8 &&
	      UCH(*p) > 127)) {
#ifdef NOTDEFINED
	    if (me->T.strip_raw_char_in)
		saved_char_in = c;
#endif /* NOTDEFINED */
	    if (me->T.trans_to_uni &&
		(TOASCII(code) >= LYlowest_eightbit[me->inUCLYhndl] ||	/* S/390 -- gil -- 0389 */
		 (code < ' ' && code != 0 &&
		  me->T.trans_C0_to_uni))) {
		/*
		 * Convert the octet to Unicode.  - FM
		 */
		code = (UCode_t) UCTransToUni(c, me->inUCLYhndl);
		if (code > 0) {
		    saved_char_in = c;
		    if (code < 256) {
			c = FROMASCII((char) code);
			c_unsign = UCH(c);
		    }
		}
	    } else if (code < 32 && code != 0 &&
		       me->T.trans_C0_to_uni) {
		/*
		 * Quote from SGML.c:
		 * "This else if may be too ugly to keep.  - KW"
		 */
		if (me->T.trans_from_uni &&
		    (((code = UCTransToUni(c, me->inUCLYhndl)) >= 32) ||
		     (me->T.transp &&
		      (code = UCTransToUni(c, me->inUCLYhndl)) > 0))) {
		    saved_char_in = c;
		    if (code < 256) {
			c = FROMASCII((char) code);
			c_unsign = UCH(c);
		    }
		} else {
		    uck = -1;
		    if (me->T.transp) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->inUCLYhndl, NO);
		    }
		    if (!me->T.transp || uck < 0) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->outUCLYhndl, YES);
		    }
		    if (uck == 0) {
			continue;
		    } else if (uck < 0) {
			me->utf_buf[0] = '\0';
		    } else {
			c = replace_buf[0];
			if (c && replace_buf[1]) {
			    HText_appendText(me->text, replace_buf);
			    continue;
			}
		    }
		    me->utf_buf[0] = '\0';
		    code = UCH(c);
		}		/*  Next line end of ugly stuff for C0. - KW */
	    } else {
		me->utf_buf[0] = '\0';
		code = UCH(c);
	    }
	}
	/*
	 * At this point we have either code in Unicode (and c in latin1 if
	 * code is in the latin1 range), or code and c will have to be passed
	 * raw.
	 */

	/*
	 * If CJK mode is on, we'll assume the document matches the user's
	 * display character set, and if not, the user should toggle off
	 * raw/CJK mode to reload.  - FM
	 */
	if (IS_CJK_TTY) {
	    HText_appendCharacter(me->text, c);

#define PASSHICTRL (me->T.transp || \
		    code >= LYlowest_eightbit[me->inUCLYhndl])
#define PASS8859SPECL me->T.pass_160_173_raw
#define PASSHI8BIT (HTPassEightBitRaw || \
		    (me->T.do_8bitraw && !me->T.trans_from_uni))
	    /*
	     * If HTPassHighCtrlRaw is set (e.g., for KOI8-R) assume the
	     * document matches and pass 127-160 8-bit characters.  If it
	     * doesn't match, the user should toggle raw/CJK mode off.  - FM
	     */
	} else if (TOASCII(code) >= 127 && TOASCII(code) < 161 &&	/* S/390 -- gil -- 0427 */
		   PASSHICTRL && PASS8859SPECL) {
	    HText_appendCharacter(me->text, c);
	} else if (code == CH_SHY && PASS8859SPECL) {
	    HText_appendCharacter(me->text, c);
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * treat 160 (nbsp) as an ASCII space (32).  - FM
	     */
	} else if (code == CH_NBSP) {
	    HText_appendCharacter(me->text, ' ');
	    /*
	     * If neither HTPassHighCtrlRaw nor CJK is set, play it safe and
	     * ignore 173 (shy).  - FM
	     * Now only ignore it for color style, which doesn't handle it
	     * anyway.  Otherwise pass it on as LY_SOFT_HYPHEN and let HText
	     * deal with it.  It should be either ignored, or displayed as a
	     * hyphen if it was indeed at the end of a line.  Well it should. 
	     * - kw
	     */
	} else if (code == CH_SHY) {
#ifndef USE_COLOR_STYLE
	    HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
#endif
	    continue;
	    /*
	     * If we get to here, pass the displayable ASCII characters.  - FM
	     */
	} else if ((code >= ' ' && TOASCII(code) < 127) ||
		   (PASSHI8BIT &&
		    c >= LYlowest_eightbit[me->outUCLYhndl]) ||
		   *p == '\n' || *p == '\t') {
	    HText_appendCharacter(me->text, c);
	    /*
	     * Use an ASCII space (32) for ensp, emsp or thinsp.  - FM
	     */
	} else if (code == 8194 || code == 8195 || code == 8201) {
	    HText_appendCharacter(me->text, ' ');
	    /*
	     * If we want the raw character, pass it now.  - FM
	     */
	} else if (me->T.use_raw_char_in && saved_char_in) {
	    HText_appendCharacter(me->text, saved_char_in);
/******************************************************************
 * I.  LATIN-1 OR UCS2 TO DISPLAY CHARSET
 ******************************************************************/
	} else if ((chk = (BOOL) (me->T.trans_from_uni && code >= 160)) &&
		   (uck = UCTransUniChar(code,
					 me->outUCLYhndl)) >= ' ' &&	/* S/390 -- gil -- 0464 */
		   uck < 256) {
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2" PRI_UCode_t
		    ":'%c'.\n",
		    uck, FROMASCII(UCH(uck))));
	    HText_appendCharacter(me->text, ((char) (uck & 0xff)));
	} else if (chk &&
		   (uck == -4 ||
		    (me->T.repl_translated_C0 && uck > 0 && uck < ' ')) &&	/* S/390 -- gil -- 0481 */
	    /*
	     * Not found; look for replacement string.
	     */
		   (uck = UCTransUniCharStr(replace_buf, 60, code,
					    me->outUCLYhndl, 0) >= 0)) {
	    /*
	     * No further tests for valididy - assume that whoever defined
	     * replacement strings knew what she was doing.
	     */
	    HText_appendText(me->text, replace_buf);
	    /*
	     * If we get to here, and should have translated, translation has
	     * failed so far.
	     */
	} else if (chk && TOASCII(code) > 127 && me->T.output_utf8) {	/* S/390 -- gil -- 0498 */
	    /*
	     * We want UTF-8 output, so do it now.  - FM
	     */
	    if (*me->utf_buf) {
		HText_appendText(me->text, me->utf_buf);
		me->utf_buf[0] = '\0';
		me->utf_buf_p = me->utf_buf;
	    } else if (UCConvertUniToUtf8(code, replace_buf)) {
		HText_appendText(me->text, replace_buf);
	    } else {
		/*
		 * Out of luck, so use the UHHH notation (ugh).  - gil
		 */
		/* S/390 -- gil -- 0517 */
		sprintf(replace_buf, "U%.2lX", (unsigned long) TOASCII(code));
		HText_appendText(me->text, replace_buf);
	    }
#ifdef NOTDEFINED
	} else if (me->T.strip_raw_char_in &&
		   UCH(*p) >= 192 &&
		   UCH(*p) < 255) {
	    /*
	     * KOI special:  strip high bit, gives (somewhat) readable ASCII.
	     */
	    HText_appendCharacter(me->text, (char) (*p & 0x7f));
#endif /* NOTDEFINED */
	    /*
	     * If we don't actually want the character, make it safe and output
	     * that now.  - FM
	     */
	} else if ((c_unsign > 0 &&
		    (int) c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
		   (me->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	     * If we do not have the "7-bit approximations" as our output
	     * character set (in which case we did it already) seek a
	     * translation for that.  Otherwise, or if the translation fails,
	     * use UHHH notation.  - FM
	     */
	    if ((chk = (BOOL) (me->outUCLYhndl !=
			       UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(code,
				      UCGetLYhndl_byMIME("us-ascii")))
		>= ' ' && TOASCII(uck) < 127) {		/* S/390 -- gil -- 0535 */
		/*
		 * Got an ASCII character (yippey).  - FM
		 */
		c = FROMASCII((char) uck);
		HText_appendCharacter(me->text, c);
	    } else if ((chk && uck == -4) &&
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						UCGetLYhndl_byMIME("us-ascii"),
						0) >= 0)) {
		/*
		 * Got a repacement string (yippey).  - FM
		 */
		HText_appendText(me->text, replace_buf);
	    } else if (code == 8204 || code == 8205) {
		/*
		 * Ignore 8204 (zwnj) or 8205 (zwj), if we get to here.  - FM
		 */
		CTRACE((tfp, "HTPlain_write: Ignoring '%" PRI_UCode_t "'.\n", code));
	    } else if (code == 8206 || code == 8207) {
		/*
		 * Ignore 8206 (lrm) or 8207 (rlm), if we get to here.  - FM
		 */
		CTRACE((tfp, "HTPlain_write: Ignoring '%" PRI_UCode_t "'.\n", code));
	    } else {
		/*
		 * Out of luck, so use the UHHH notation (ugh).  - FM
		 */
		/* do not print UHHH for now
		   sprintf(replace_buf, "U%.2lX", code);
		   HText_appendText(me->text, replace_buf);
		 */
	    }
	    /*
	     * If we get to here and have a monobyte character, pass it.  - FM
	     */
	} else if (c_unsign != 0 && c_unsign < 256) {
	    HText_appendCharacter(me->text, c);
	}
#endif /* REMOVE_CR_ONLY */
    }
}

/*	Free an HTML object
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created object is
 *	not, as it takes on an existence of its own unless explicitly freed.
 */
static void HTPlain_free(HTStream *me)
{
    if (HTPlain_bs_pending >= 2)
	HText_appendCharacter(me->text, '_');
    FREE(me);
}

/*	End writing
*/
static void HTPlain_abort(HTStream *me, HTError e GCC_UNUSED)
{
    HTPlain_free(me);
}

/*		Structured Object Class
 *		-----------------------
 */
static const HTStreamClass HTPlain =
{
    "PlainPresenter",
    HTPlain_free,
    HTPlain_abort,
    HTPlain_put_character, HTPlain_put_string, HTPlain_write,
};

/*		New object
 *		----------
 */
HTStream *HTPlainPresent(HTPresentation *pres GCC_UNUSED, HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
{

    HTStream *me = (HTStream *) malloc(sizeof(*me));

    if (me == NULL)
	outofmem(__FILE__, "HTPlain_new");

    assert(me != NULL);

    me->isa = &HTPlain;

    HTPlain_lastraw = -1;

    me->utf_count = 0;
    me->utf_char = 0;
    me->utf_buf[0] = me->utf_buf[6] = me->utf_buf[7] = '\0';
    me->utf_buf_p = me->utf_buf;
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
    HTPlain_getChartransInfo(me, anchor);
    UCSetTransParams(&me->T,
		     me->inUCLYhndl, me->inUCI,
		     me->outUCLYhndl,
		     HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));

    me->text = HText_new(anchor);
    HText_setStyle(me->text, LYstyles(HTML_XMP));
    HText_beginAppend(me->text);

    return (HTStream *) me;
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTPlain.c,v 1.44 2009/01/03 01:23:21 tom Exp $
d14 2
d111 1
a111 1
static void HTPlain_put_character(HTStream *me, char c)
d132 4
a135 1
	HTPlain_write(me, &c, 1);
d142 3
d148 1
a148 1
	HTPlain_write(me, &c, 1);
d154 1
d157 2
d161 1
a164 28
    } else if (TOASCII(UCH(c)) > 160) {
	if (!HTPassEightBitRaw &&
	    !((me->outUCLYhndl == LATIN1) ||
	      (me->outUCI->enc & (UCT_CP_SUPERSETOF_LAT1)))) {
	    int len, high, low, i, diff = 1;
	    const char *name;
	    UCode_t value = (UCode_t) FROMASCII((TOASCII(UCH(c)) - 160));

	    name = HTMLGetEntityName(value);
	    len = (int) strlen(name);
	    for (low = 0, high = (int) HTML_dtd.number_of_entities;
		 high > low;
		 diff < 0 ? (low = i + 1) : (high = i)) {
		/* Binary search */
		i = (low + (high - low) / 2);
		diff = AS_ncmp(HTML_dtd.entity_names[i], name, (unsigned) len);
		if (diff == 0) {
		    HText_appendText(me->text,
				     LYCharSets[me->outUCLYhndl][i]);
		    break;
		}
	    }
	    if (diff) {
		HText_appendCharacter(me->text, c);
	    }
	} else {
	    HText_appendCharacter(me->text, c);
	}
a433 1
			code = UCH(c);
d523 3
a525 2
	    CTRACE((tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
		    uck, FROMASCII((char) uck)));
d674 3
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		Plain text object		HTWrite.c
d34 1
d141 1
a141 1
    } else if (HTCJK != NOCJK) {
d162 2
a163 2
	    len = strlen(name);
	    for (low = 0, high = HTML_dtd.number_of_entities;
d168 1
a168 1
		diff = AS_ncmp(HTML_dtd.entity_names[i], name, len);
d477 1
a477 1
	if (HTCJK != NOCJK) {
d575 1
a575 1
		sprintf(replace_buf, "U%.2lX", TOASCII(code));
d623 1
a623 1
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
d628 1
a628 1
		CTRACE((tfp, "HTPlain_write: Ignoring '%ld'.\n", code));
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 8
a9 8
**		=================
**
**	This version of the stream object just writes to a socket.
**	The socket is assumed open and left open.
**
**	Bugs:
**		strings written must be less than buffer size.
*/
d12 1
a12 1
#include <LYCharVals.h>  /* S/390 -- gil -- 0288 */
d33 2
a34 2
PUBLIC int HTPlain_lastraw = -1;
PRIVATE int HTPlain_bs_pending = 0; /* 1:bs 2:underline 3:underline+bs - kw */
d37 2
a38 2
**		-----------
*/
d40 2
a41 2
    CONST HTStreamClass *	isa;
    HText *			text;
d43 4
a46 4
    **	The node_anchor UCInfo and handle for the input (PARSER) stage. - FM
    */
    LYUCcharset		*	inUCI;
    int				inUCLYhndl;
d48 3
a50 3
    **	The node_anchor UCInfo and handle for the output (HTEXT) stage. - FM
    */
    LYUCcharset	*		outUCI;
d53 6
a58 6
    **	Counter, value, buffer and pointer for UTF-8 handling. - FM
    */
    char			utf_count;
    UCode_t			utf_char;
    char			utf_buf[8];
    char *			utf_buf_p;
d60 3
a62 3
    **	The charset transformation structure. - FM
    */
    UCTransParams		T;
d65 1
a65 1
PRIVATE char replace_buf [64];	      /* buffer for replacement strings */
d67 1
a67 3
PRIVATE void HTPlain_getChartransInfo ARGS2(
	HTStream *,		me,
	HTParentAnchor *,	anchor)
d71 1
a71 1
					 UCT_SETBY_PARSER);
d76 1
d91 2
a92 2
**	----------------------------------
*/
d95 3
a97 3
**
**			A C T I O N	R O U T I N E S
*/
d99 2
a100 4
PRIVATE void HTPlain_write PARAMS((
	HTStream *		me,
	CONST char *		s,
	int			l));
d103 3
a105 5
**	------------------
*/
PRIVATE void HTPlain_put_character ARGS2(
	HTStream *,		me,
	char,			c)
d109 2
a110 2
    **	Throw away \r's.
    */
d112 1
a112 1
       HText_appendCharacter(me->text, c);
d116 5
a120 6
    **	See HTPlain_write() for explanations of the following code
    **	(we've been called via HTPlain_put_string() to do for each
    **	character of a terminated string what HTPlain_write() does
    **	via a while loop for each character in a stream of given
    **	length). - FM
    */
d132 1
a132 1
    } else if (TOASCII(UCH(c)) >= 127) {  /* S/390 -- gil -- 0305 */
d134 2
a135 3
	**  For now, don't repeat everything here
	**  that has been done below - KW
	*/
d142 1
a142 1
    } else if (UCH(c) == CH_NBSP) { /* S/390 -- gil -- 0341 */
d154 2
a155 2
	    CONST char * name;
	    UCode_t value = (UCode_t)FROMASCII((TOASCII(UCH(c)) - 160));
d158 1
a158 1
	    len =  strlen(name);
d160 2
a161 2
		high > low;
		diff < 0 ? (low = i+1) : (high = i)) {
d163 1
a163 1
		i = (low + (high-low)/2);
a180 1

d182 4
a185 4
**	---------------
**
*/
PRIVATE void HTPlain_put_string ARGS2(HTStream *, me, CONST char*, s)
d190 1
a190 1
    CONST char * p;
a199 1

d201 4
a204 4
**	Entry function for displayed text/plain and WWW_SOURCE strings. - FM
**	---------------------------------------------------------------
*/
PRIVATE void HTPlain_write ARGS3(HTStream *, me, CONST char*, s, int, l)
d206 2
a207 2
    CONST char * p;
    CONST char * e = s+l;
d217 2
a218 2
	**  Append the whole string, but remove any \r's. - FM
	*/
d238 4
a241 4
		if (!HTPlain_bs_pending) {
		    HTPlain_bs_pending = 2;
		    HTPlain_lastraw = UCH(*p);
		    continue;
d243 4
a246 4
		} else if (HTPlain_bs_pending != 2) {
		    HTPlain_bs_pending--; /* 1 -> 0, 3 -> 2 */
		    HTPlain_lastraw = UCH(*p);
		    continue;
d248 1
a248 1
		}
d252 4
a255 5
	**  Try to handle lone LFs, CRLFs and lone CRs
	**  as newline, and to deal with control, ASCII,
	**  and 8-bit characters based on best guesses
	**  of what's appropriate. - FM
	*/
d271 1
a271 1
	    continue;	/* ignore last two of "X\bX" or "X\b_" - kw */
d278 1
a278 1
				/* ignore first two of "_\bX" - kw */
d294 3
a296 3
	**  Make sure the character is handled as Unicode
	**  whenever that's appropriate.  - FM
	*/
d299 1
a299 1
	code = (UCode_t)c_unsign;
d302 3
a304 3
	**  Combine any UTF-8 multibytes into Unicode
	**  to check for special characters. - FM
	*/
d307 4
a310 5
	    **	Combine UTF-8 into Unicode.
	    **	Incomplete characters silently ignored.
	    **	from Linux kernel's console.c - KW
	    */
	    if (TOASCII(c_unsign) > 127) {  /* S/390 -- gil -- 0371 */
d312 2
a313 2
		**  We have an octet from a multibyte character. - FM
		*/
d316 3
a318 4
		    **	Adjust the UCode_t value, add the octet
		    **	to the buffer, and decrement the byte
		    **	count. - FM
		    */
d325 2
a326 2
			**  Got a complete multibyte character.
			*/
d330 1
a330 1
			    c = FROMASCII((char)code);
d335 2
a336 2
			**  Get the next byte. - FM
			*/
d341 2
a342 2
		    **	Start handling a new multibyte character. - FM
		    */
d362 1
a362 1
			 *  We got garbage, so ignore it. - FM
d369 2
a370 2
		    **	Get the next byte. - FM
		    */
d375 4
a378 5
		**  Got an ASCII character when expecting
		**  UTF-8 multibytes, so ignore the buffered
		**  multibye characters and fall through with
		**  the current ASCII character. - FM
		*/
d382 1
a382 1
		code = (UCode_t)c_unsign;
d385 3
a387 4
		**  Got a valid ASCII character, so fall
		**  through with it. - FM
		*/
		code = (UCode_t)c_unsign;
d391 3
a393 3
	**  Convert characters from non-UTF-8 charsets
	**  to Unicode (if appropriate). - FM
	*/
d400 9
a408 9
	if (me->T.trans_to_uni &&
	    (TOASCII(code) >= LYlowest_eightbit[me->inUCLYhndl] ||  /* S/390 -- gil -- 0389 */
	     (code < ' ' && code != 0 &&
	     me->T.trans_C0_to_uni))) {
		/*
		**  Convert the octet to Unicode. - FM
		*/
	    code = (UCode_t)UCTransToUni(c, me->inUCLYhndl);
	    if (code > 0) {
d410 2
a411 2
		if (code < 256) {
			c = FROMASCII((char)code);
d413 1
a414 1
	    }
d418 3
a420 3
		**  Quote from SGML.c:
		**	"This else if may be too ugly to keep. - KW"
		*/
d427 1
a427 1
			c = FROMASCII((char)code);
d456 1
a456 1
		} /*  Next line end of ugly stuff for C0. - KW */
d463 4
a466 4
	**  At this point we have either code in Unicode
	**  (and c in latin1 if code is in the latin1 range),
	**  or code and c will have to be passed raw.
	*/
d469 4
a472 4
	**  If CJK mode is on, we'll assume the document matches
	**  the user's display character set, and if not, the
	**  user should toggle off raw/CJK mode to reload. - FM
	*/
d481 6
a486 6
	/*
	**  If HTPassHighCtrlRaw is set (e.g., for KOI8-R) assume the
	**  document matches and pass 127-160 8-bit characters.  If it
	**  doesn't match, the user should toggle raw/CJK mode off. - FM
	*/
	} else if (TOASCII(code) >= 127 && TOASCII(code) < 161 &&  /* S/390 -- gil -- 0427 */
d491 4
a494 4
	/*
	**  If neither HTPassHighCtrlRaw nor CJK is set, play it safe
	**  and treat 160 (nbsp) as an ASCII space (32). - FM
	*/
d497 9
a505 8
	/*
	**  If neither HTPassHighCtrlRaw nor CJK is set, play it safe
	**  and ignore 173 (shy). - FM
	**  Now only ignore it for color style, which doesn't handle it anyway.
	**  Otherwise pass it on as LY_SOFT_HYPHEN and let HText deal with it.
	**  It should be either ignored, or displayed as a hyphen if it was
	**  indeed at the end of a line.  Well it should. - kw
	*/
d511 3
a513 3
	/*
	**  If we get to here, pass the displayable ASCII characters. - FM
	*/
d519 3
a521 3
	/*
	**  Use an ASCII space (32) for ensp, emsp or thinsp. - FM
	*/
d524 3
a526 3
	/*
	**  If we want the raw character, pass it now. - FM
	*/
d530 1
a530 1
 *   I. LATIN-1 OR UCS2  TO  DISPLAY CHARSET
d534 1
a534 1
					 me->outUCLYhndl)) >= ' ' &&  /* S/390 -- gil -- 0464 */
d537 2
a538 2
			uck, FROMASCII((char)uck)));
	    HText_appendCharacter(me->text, ((char)(uck & 0xff)));
d541 4
a544 4
		    (me->T.repl_translated_C0 && uck > 0 && uck < ' ')) &&  /* S/390 -- gil -- 0481 */
		   /*
		   **  Not found; look for replacement string.
		   */
d548 3
a550 3
	    **	No further tests for valididy - assume that whoever
	    **	defined replacement strings knew what she was doing.
	    */
a551 5
	/*
	**  If we get to here, and should have translated,
	**  translation has failed so far.
	*/
	} else if (chk && TOASCII(code) > 127 && me->T.output_utf8) {  /* S/390 -- gil -- 0498 */
d553 7
a559 2
	    **	We want UTF-8 output, so do it now. - FM
	    */
d568 3
a570 2
		**  Out of luck, so use the UHHH notation (ugh). - gil
		*/  /* S/390 -- gil -- 0517 */
d579 3
a581 4
	    **	KOI special: strip high bit, gives
	    **	(somewhat) readable ASCII.
	    */
	    HText_appendCharacter(me->text, (char)(*p & 0x7f));
d584 3
a586 3
	    **  If we don't actually want the character,
	    **  make it safe and output that now. - FM
	    */
d588 2
a589 2
		      (int) c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
		      (me->T.trans_from_uni && !HTPassEightBitRaw)) {
d591 5
a595 5
	    **	If we do not have the "7-bit approximations" as our
	    **	output character set (in which case we did it already)
	    **	seek a translation for that.  Otherwise, or if the
	    **	translation fails, use UHHH notation. - FM
	    */
d597 8
a604 8
			UCGetLYhndl_byMIME("us-ascii"))) &&
		   (uck = UCTransUniChar(code,
					 UCGetLYhndl_byMIME("us-ascii")))
				      >= ' ' && TOASCII(uck) < 127) {  /* S/390 -- gil -- 0535 */
		/*
		**  Got an ASCII character (yippey). - FM
		*/
		c = FROMASCII((char)uck);
d612 2
a613 2
		**  Got a repacement string (yippey). - FM
		*/
d617 2
a618 2
		**	Ignore 8204 (zwnj) or 8205 (zwj), if we get to here. - FM
		*/
d622 2
a623 2
		**	Ignore 8206 (lrm) or 8207 (rlm), if we get to here. - FM
		*/
d627 10
a636 11
		**  Out of luck, so use the UHHH notation (ugh). - FM
		*/
			/* do not print UHHH for now
			sprintf(replace_buf, "U%.2lX", code);
			HText_appendText(me->text, replace_buf);
			*/
		}
		/*
		**  If we get to here and have a monobyte character,
		**  pass it. - FM
		*/
d645 6
a650 7
**	-------------------
**
**	Note that the SGML parsing context is freed, but the created object is
**	not, as it takes on an existence of its own unless explicitly freed.
*/
PRIVATE void HTPlain_free ARGS1(
	HTStream *,	me)
d659 1
a659 3
PRIVATE void HTPlain_abort ARGS2(
	HTStream *,	me,
	HTError,	e GCC_UNUSED)
d665 3
a667 3
**		-----------------------
*/
PUBLIC CONST HTStreamClass HTPlain =
d669 4
a672 4
	"PlainPresenter",
	HTPlain_free,
	HTPlain_abort,
	HTPlain_put_character,	HTPlain_put_string, HTPlain_write,
d676 4
a679 6
**		----------
*/
PUBLIC HTStream* HTPlainPresent ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink GCC_UNUSED)
d682 2
a683 1
    HTStream* me = (HTStream*)malloc(sizeof(*me));
d692 1
a692 1
    me->utf_buf[0] = me->utf_buf[6] =me->utf_buf[7] = '\0';
d694 2
a695 2
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_HTEXT);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_PARSER);
d700 1
a700 1
		     HTAnchor_getUCInfoStage(anchor,UCT_STAGE_HTEXT));
d703 1
a703 1
    HText_setStyle(me->text, LYstyles(HTML_XMP) );
d706 1
a706 1
    return (HTStream*) me;
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a32 3
extern BOOL HTPassEightBitRaw;
extern BOOL HTPassHighCtrlRaw;

d433 1
a433 1
		**  	"This else if may be too ugly to keep. - KW"
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a34 1
extern HTCJKlang HTCJK;
d37 1
d48 2
a49 2
    LYUCcharset 	*	inUCI;
    int 			inUCLYhndl;
d134 5
a138 1
    HTPlain_lastraw = c;
d141 1
a141 1
    } else if (TOASCII((unsigned char)c) >= 127) {  /* S/390 -- gil -- 0305 */
d149 1
a149 1
    } else if (TOASCII((unsigned char)c) >= 127 && TOASCII((unsigned char)c) < 161 &&
d152 1
a152 1
    } else if ((unsigned char)c == CH_NBSP) { /* S/390 -- gil -- 0341 */
d154 1
a154 1
    } else if ((unsigned char)c == CH_SHY) {
d156 1
a156 1
    } else if (((unsigned char)c >= ' ' && TOASCII((unsigned char)c) < 127) ||
d159 1
a159 1
    } else if (TOASCII((unsigned char)c) > 160) {
d165 1
a165 1
	    UCode_t value = (UCode_t)FROMASCII((TOASCII((unsigned char)c) - 160));
d235 28
d273 29
a301 1
	HTPlain_lastraw = *p;
d311 1
a311 1
	c_unsign = (unsigned char)c;
d346 1
a346 1
			    c_unsign = (unsigned char)c;
d412 1
a412 1
	      (unsigned char)(*p) > 127)) {
d429 1
a429 1
			c_unsign = (unsigned char)c;
d445 1
a445 1
			c_unsign = (unsigned char)c;
d463 1
a463 1
			code = (unsigned char)c;
d472 1
a472 1
		    code = (unsigned char)c;
d476 1
a476 1
		code = (unsigned char)c;
d517 4
d523 3
d548 1
a548 1
	} else if ((chk = (me->T.trans_from_uni && code >= 160)) &&
d552 2
a553 2
	    CTRACE(tfp, "UCTransUniChar returned 0x%.2lX:'%c'.\n",
			uck, FROMASCII((char)uck));
d591 2
a592 2
		   (unsigned char)*p >= 192 &&
		   (unsigned char)*p < 255) {
d599 5
a603 5
	   /*
	   **  If we don't actually want the character,
	   **  make it safe and output that now. - FM
	   */
	   } else if ((c_unsign > 0 &&
d612 1
a612 1
	    if ((chk = (me->outUCLYhndl !=
d620 3
a622 3
	    c = FROMASCII((char)uck);
	    HText_appendCharacter(me->text, c);
	} else if ((chk && uck == -4) &&
d635 1
a635 1
		CTRACE(tfp, "HTPlain_write: Ignoring '%ld'.\n", code);
d640 1
a640 1
		CTRACE(tfp, "HTPlain_write: Ignoring '%ld'.\n", code);
d655 2
a656 2
		HText_appendCharacter(me->text, c);
	    }
d670 2
@


1.1
log
@Initial revision
@
text
@a9 2
#include "HTUtils.h"
#include "tcp.h"
d11 2
a12 1
#include "HTPlain.h"
d14 5
a18 3
#include "HTChunk.h"
#include "HText.h"
#include "HTStyle.h"
d20 1
a20 1
#include "HTML.h"		/* styles[] */
d24 5
a28 10
#include "HText.h"
#include "HTStyle.h"
#include "HTMLDTD.h"
#include "HTCJK.h"
#include "UCMap.h"
#include "UCDefs.h"
#include "UCAux.h"

#include "LYCharSets.h"
#include "LYLeaks.h"
d30 2
a31 1
#define FREE(x) if (x) {free(x); x = NULL;}
a32 1
extern BOOLEAN LYRawMode;
d53 1
d91 1
d137 1
a137 3
    } else if (HTCJK != NOCJK) {
	HText_appendCharacter(me->text, c);
    } else if ((unsigned char)c >= 127) {
d143 3
a145 1
    } else if ((unsigned char)c >= 127 && (unsigned char)c < 161 &&
d148 1
a148 1
    } else if ((unsigned char)c == 160) {
d150 1
a150 1
    } else if ((unsigned char)c == 173) {
d152 1
a152 1
    } else if (((unsigned char)c >= 32 && (unsigned char)c < 127) ||
d155 1
a155 1
    } else if ((unsigned char)c > 160) {
d157 3
a159 3
	    current_char_set != 0) {
	    size_t len, high, low, i;
	    int diff = 1;
d161 1
a161 1
	    UCode_t value = (UCode_t)((unsigned char)c - 160);
d170 1
a170 1
		diff = strncmp(HTML_dtd.entity_names[i], name, len);
d173 1
a173 1
				     LYCharSets[current_char_set][i]);
d217 1
a217 1
    unsigned char c_unsign;
d219 2
a220 2
    UCode_t code;
    long uck = 0;
d253 1
d264 1
a264 1
	    if (c_unsign > 127) {
d284 1
a284 1
			if (code < 256) {
d286 1
a297 1
		    me->utf_buf_p = me->utf_buf;
d299 1
a299 1
		    (me->utf_buf_p)++;
d320 1
a321 1
			me->utf_buf_p[0] = '\0';
d328 1
a328 1
	    } else {
d330 4
a333 1
		**  Got an ASCII character.
d338 7
d347 10
a356 1

d358 2
a359 2
	    (code >= 127 ||
	     (code < 32 && code != 0 &&
d366 1
d368 2
a369 1
		    c = FROMASCII((char)code);
d372 46
d427 1
a427 1
	**  the user's selected character set, and if not, the
d443 1
a443 1
	} else if (code >= 127 && code < 161 &&
d446 1
a446 1
	} else if (code == 173 && PASS8859SPECL) {
d452 1
a452 1
	} else if (code == 160) {
d458 1
a458 1
	} else if (code == 173) {
d463 1
a463 1
	} else if ((code >= 32 && code < 127) ||
a467 4

	} else if (me->T.use_raw_char_in) {
	    HText_appendCharacter(me->text, *p);
#ifdef NOTDEFINED
d473 5
a477 2
#endif /* NOTDEFINED */

d483 1
a483 1
					 me->outUCLYhndl)) >= 32 &&
d485 1
a485 3
	    if (TRACE) {
		fprintf(stderr,
			"UCTransUniChar returned 0x%.2lX:'%c'.\n",
a486 1
	    }
d490 1
a490 1
		    (me->T.repl_translated_C0 && uck > 0 && uck < 32)) &&
d505 1
a505 1
	} else if (chk && code > 127 && me->T.output_utf8) {
d516 4
a519 1
		sprintf(replace_buf, "U%.2lX", code);
d531 8
d545 2
a546 4
	} else if (chk &&
		   (chk = (!HTPassEightBitRaw &&
			   (me->outUCLYhndl !=
			    UCGetLYhndl_byMIME("us-ascii")))) &&
d549 1
a549 1
				      >= 32 && uck < 127) {
d553 1
a553 1
	    c = ((char)(uck & 0xff));
d563 11
a573 22
	    HText_appendText(me->text, replace_buf);
	} else if (code == 8204 || code == 8205) {
	    /*
	    **	Ignore 8204 (zwnj) or 8205 (zwj), if we get to here. - FM
	    */
	    if (TRACE) {
		fprintf(stderr,
			"HTPlain_write: Ignoring '%ld'.\n", code);
	    }
	} else if (code == 8206 || code == 8207) {
	    /*
	    **	Ignore 8206 (lrm) or 8207 (rlm), if we get to here. - FM
	    */
	    if (TRACE) {
		fprintf(stderr,
			"HTPlain_write: Ignoring '%ld'.\n", code);
	    }
#endif /* NOTDEFINED */
	} else if (me->T.trans_from_uni && code > 255) {
	    if (PASSHI8BIT && PASSHICTRL && LYRawMode &&
		(unsigned char)*p >= LYlowest_eightbit[me->outUCLYhndl]) {
		HText_appendCharacter(me->text, *p);
a574 12
		sprintf(replace_buf, "U%.2lX", code);
		HText_appendText(me->text, replace_buf);
	    }
	/*
	**  If we get to here and HTPassEightBitRaw or the
	**  selected character set is not "ISO Latin 1",
	**  use the translation tables for 161-255 8-bit
	**  characters (173 was handled above). - FM
	*/
	} else if (code > 160) {
	    if (!HTPassEightBitRaw && code <= 255 &&
		me->outUCLYhndl != 0) {
d578 1
a578 34
		size_t len, high, low, i;
		int diff = 1;
		CONST char * name;
		int value = (int)(code - 160);

		name = HTMLGetEntityName(value);
		len =  strlen(name);
		for(low = 0, high = HTML_dtd.number_of_entities;
		    high > low;
		    diff < 0 ? (low = i+1) : (high = i)) {
		    /* Binary search */
		    i = (low + (high-low)/2);
		    diff = strncmp(HTML_dtd.entity_names[i], name, len);
		    if (diff == 0) {
			HText_appendText(me->text,
					 LYCharSets[me->outUCLYhndl][i]);
			break;
		    }
		}
		if (diff) {
		    /*
		    **	Something went wrong in the translation, so
		    **	either output as UTF8 or a hex representation or
		    **	pass the raw character and hope it's OK.
		    */
		    if (!PASSHI8BIT)
			c = FROMASCII((char)code);
		    if (me->T.output_utf8 &&
			*me->utf_buf) {
			HText_appendText(me->text, me->utf_buf);
			me->utf_buf_p = me->utf_buf;
			*(me->utf_buf_p) = '\0';

		    } else if (me->T.trans_from_uni) {
d581 1
a581 2
		    } else
			HText_appendCharacter(me->text, c);
a582 1
	    } else {
d584 2
a585 1
		**  Didn't attempt a translation. - FM
d587 1
a587 20
		/*  Either output as UTF8 or a hex representation or
		**  pass the raw character and hope it's OK.
		*/
		if (code <= 255 && !PASSHI8BIT)
		    c = FROMASCII((char)code);
		if (code > 127 && me->T.output_utf8 && *me->utf_buf) {
		    HText_appendText(me->text, me->utf_buf);
		    me->utf_buf_p = me->utf_buf;
		    *(me->utf_buf_p) = '\0';

		} else if (LYRawMode &&
			   me->inUCLYhndl != me->outUCLYhndl &&
			   (PASSHI8BIT || PASSHICTRL) &&
			   (unsigned char)c >=
				     LYlowest_eightbit[me->outUCLYhndl]) {
		    HText_appendCharacter(me->text, c);
		} else if (me->T.trans_from_uni && code >= 127) {
		    sprintf(replace_buf, "U%.2lX", code);
		    HText_appendText(me->text, replace_buf);
		} else
a589 1
	}
d655 1
a655 1
    HText_setStyle(me->text, styles[HTML_XMP] );
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
