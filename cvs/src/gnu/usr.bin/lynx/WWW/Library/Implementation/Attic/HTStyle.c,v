head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.48;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTStyle.c,v 1.16 2009/11/27 13:01:48 tom Exp $
 *
 *	Style Implementation for Hypertext			HTStyle.c
 *	==================================
 *
 *	Styles allow the translation between a logical property
 *	of a piece of text and its physical representation.
 *
 *	A StyleSheet is a collection of styles, defining the
 *	translation necessary to
 *	represent a document.  It is a linked list of styles.
 */

#include <HTUtils.h>
#include <HTStyle.h>

#include <LYLeaks.h>

/*	Create a new style
*/
HTStyle *HTStyleNew(void)
{
    HTStyle *self = typecalloc(HTStyle);

    if (self == NULL)
	outofmem(__FILE__, "HTStyleNew");
    return self;
}

/*	Create a new style with a name
*/
HTStyle *HTStyleNewNamed(const char *name)
{
    HTStyle *self = HTStyleNew();

    StrAllocCopy(self->w_name, name);
    self->id = -1;		/* <0 */
    return self;
}

/*	Free a style
*/
HTStyle *HTStyleFree(HTStyle *self)
{
    FREE(self->w_name);
    FREE(self->w_SGMLTag);
    FREE(self);
    return NULL;
}

#ifdef SUPPRESS			/* Only on the NeXT */
/*	Read a style from a stream	(without its name)
 *	--------------------------
 *
 *	Reads a style with paragraph information from a stream.
 *	The style name is not read or written by these routines.
 */
#define NONE_STRING "(None)"
#define HTStream NXStream

HTStyle *HTStyleRead(HTStyle *style, HTStream *stream)
{
    char myTag[STYLE_NAME_LENGTH];
    char fontName[STYLE_NAME_LENGTH];
    NXTextStyle *p;
    int tab;
    int gotpara;		/* flag: have we got a paragraph definition? */

    NXScanf(stream, "%s%s%f%d",
	    myTag,
	    fontName,
	    &style->fontSize,
	    &gotpara);
    if (gotpara) {
	if (!style->paragraph) {
	    style->paragraph = malloc(sizeof(*(style->paragraph)));
	    if (!style->paragraph)
		outofmem(__FILE__, "HTStyleRead");
	    style->paragraph->tabs = 0;
	}
	p = style->paragraph;
	NXScanf(stream, "%f%f%f%f%hd%f%f%hd",
		&p->indent1st,
		&p->indent2nd,
		&p->lineHt,
		&p->descentLine,
		&p->alignment,
		&style->spaceBefore,
		&style->spaceAfter,
		&p->numTabs);
	FREE(p->tabs);
	p->tabs = malloc(p->numTabs * sizeof(p->tabs[0]));
	if (!p->tabs)
	    outofmem(__FILE__, "HTStyleRead");
	for (tab = 0; tab < p->numTabs; tab++) {
	    NXScanf(stream, "%hd%f",
		    &p->tabs[tab].kind,
		    &p->tabs[tab].x);
	}
    } else {			/* No paragraph */
	FREE(style->paragraph);
    }				/* if no paragraph */
    StrAllocCopy(style->SGMLTag, myTag);
    if (strcmp(fontName, NONE_STRING) == 0)
	style->font = 0;
    else
      style->font =[Font newFont: fontName size:style->fontSize];
    return NULL;
}

/*	Write a style to a stream in a compatible way
*/
HTStyle *HTStyleWrite(HTStyle *style, NXStream * stream)
{
    int tab;
    NXTextStyle *p = style->paragraph;

    NXPrintf(stream, "%s %s %f %d\n",
	     style->SGMLTag,
	     style->font ?[style->font name] : NONE_STRING,
	     style->fontSize,
	     p != 0);

    if (p) {
	NXPrintf(stream, "\t%f %f %f %f %d %f %f\t%d\n",
		 p->indent1st,
		 p->indent2nd,
		 p->lineHt,
		 p->descentLine,
		 p->alignment,
		 style->spaceBefore,
		 style->spaceAfter,
		 p->numTabs);

	for (tab = 0; tab < p->numTabs; tab++)
	    NXPrintf(stream, "\t%d %f\n",
		     p->tabs[tab].kind,
		     p->tabs[tab].x);
    }
    return style;
}

/*	Write a style to stdout for diagnostics
*/
HTStyle *HTStyleDump(HTStyle *style)
{
    int tab;
    NXTextStyle *p = style->paragraph;

    printf(STYLE_DUMP_FONT,
	   style,
	   style->name,
	   style->SGMLTag,
	   [style->font name],
	   style->fontSize);
    if (p) {
	printf(STYLE_DUMP_IDENT,
	       p->indent1st,
	       p->indent2nd,
	       p->lineHt,
	       p->descentLine);
	printf(STYLE_DUMP_ALIGN,
	       p->alignment,
	       p->numTabs,
	       style->spaceBefore,
	       style->spaceAfter);

	for (tab = 0; tab < p->numTabs; tab++) {
	    printf(STYLE_DUMP_TAB,
		   p->tabs[tab].kind,
		   p->tabs[tab].x);
	}
	printf("\n");
    }				/* if paragraph */
    return style;
}
#endif /* SUPPRESS */

/*			StyleSheet Functions
 *			====================
 */

/*	Searching for styles:
*/
HTStyle *HTStyleNamed(HTStyleSheet *self, const char *name)
{
    HTStyle *scan;

    for (scan = self->styles; scan; scan = scan->next)
	if (0 == strcmp(GetHTStyleName(scan), name))
	    return scan;
    CTRACE((tfp, "StyleSheet: No style named `%s'\n", name));
    return NULL;
}

#ifdef NEXT_SUPRESS		/* Not in general common code */

HTStyle *HTStyleMatching(HTStyleSheet *self, HTStyle *style)
{
    HTStyle *scan;

    for (scan = self->styles; scan; scan = scan->next)
	if (scan->paragraph == para)
	    return scan;
    return NULL;
}

/*	Find the style which best fits a given run
 *	------------------------------------------
 *
 *	This heuristic is used for guessing the style for a run of
 *	text which has been pasted in.  In order, we try:
 *
 *	A style whose paragraph structure is actually used by the run.
 *	A style matching in font
 *	A style matching in paragraph style exactly
 *	A style matching in paragraph to a degree
 */

HTStyle *HTStyleForRun(HTStyleSheet *self, NXRun * run)
{
    HTStyle *scan;
    HTStyle *best = 0;
    int bestMatch = 0;
    NXTextStyle *rp = run->paraStyle;

    for (scan = self->styles; scan; scan = scan->next)
	if (scan->paragraph == run->paraStyle)
	    return scan;	/* Exact */

    for (scan = self->styles; scan; scan = scan->next) {
	NXTextStyle *sp = scan->paragraph;

	if (sp) {
	    int match = 0;

	    if (sp->indent1st == rp->indent1st)
		match = match + 1;
	    if (sp->indent2nd == rp->indent2nd)
		match = match + 2;
	    if (sp->lineHt == rp->lineHt)
		match = match + 1;
	    if (sp->numTabs == rp->numTabs)
		match = match + 1;
	    if (sp->alignment == rp->alignment)
		match = match + 3;
	    if (scan->font == run->font)
		match = match + 10;
	    if (match > bestMatch) {
		best = scan;
		bestMatch = match;
	    }
	}
    }
    CTRACE((tfp, "HTStyleForRun: Best match for style is %d out of 18\n",
	    bestMatch));
    return best;
}
#endif /* NEXT_SUPRESS */

/*	Add a style to a sheet
 *	----------------------
 */
HTStyleSheet *HTStyleSheetAddStyle(HTStyleSheet *self, HTStyle *style)
{
    style->next = 0;		/* The style will go on the end */
    if (!self->styles) {
	self->styles = style;
    } else {
	HTStyle *scan;

	for (scan = self->styles; scan->next; scan = scan->next) ;	/* Find end */
	scan->next = style;
    }
    return self;
}

/*	Remove the given object from a style sheet if it exists
*/
HTStyleSheet *HTStyleSheetRemoveStyle(HTStyleSheet *self, HTStyle *style)
{
    if (self->styles == style) {
	self->styles = style->next;
	return self;
    } else {
	HTStyle *scan;

	for (scan = self->styles; scan; scan = scan->next) {
	    if (scan->next == style) {
		scan->next = style->next;
		return self;
	    }
	}
    }
    return NULL;
}

/*	Create new style sheet
*/

HTStyleSheet *HTStyleSheetNew(void)
{
    HTStyleSheet *self = typecalloc(HTStyleSheet);

    if (self == NULL)
	outofmem(__FILE__, "HTStyleSheetNew");
    return self;
}

/*	Free off a style sheet pointer
*/
HTStyleSheet *HTStyleSheetFree(HTStyleSheet *self)
{
    HTStyle *style;

    while ((style = self->styles) != 0) {
	self->styles = style->next;
	HTStyleFree(style);
    }
    FREE(self);
    return NULL;
}

/*	Read a stylesheet from a typed stream
 *	-------------------------------------
 *
 *	Reads a style sheet from a stream.  If new styles have the same names
 *	as existing styles, they replace the old ones without changing the ids.
 */

#ifdef NEXT_SUPRESS		/* Only on the NeXT */
HTStyleSheet *HTStyleSheetRead(HTStyleSheet *self, NXStream * stream)
{
    int numStyles;
    int i;
    HTStyle *style;
    char styleName[80];

    NXScanf(stream, " %d ", &numStyles);
    CTRACE((tfp, "Stylesheet: Reading %d styles\n", numStyles));
    for (i = 0; i < numStyles; i++) {
	NXScanf(stream, "%s", styleName);
	style = HTStyleNamed(self, styleName);
	if (!style) {
	    style = HTStyleNewNamed(styleName);
	    (void) HTStyleSheetAddStyle(self, style);
	}
	(void) HTStyleRead(style, stream);
	if (TRACE)
	    HTStyleDump(style);
    }
    return self;
}

/*	Write a stylesheet to a typed stream
 *	------------------------------------
 *
 *	Writes a style sheet to a stream.
 */

HTStyleSheet *HTStyleSheetWrite(HTStyleSheet *self, NXStream * stream)
{
    int numStyles = 0;
    HTStyle *style;

    for (style = self->styles; style; style = style->next)
	numStyles++;
    NXPrintf(stream, "%d\n", numStyles);

    CTRACE((tfp, "StyleSheet: Writing %d styles\n", numStyles));
    for (style = self->styles; style; style = style->next) {
	NXPrintf(stream, "%s ", style->name);
	(void) HTStyleWrite(style, stream);
    }
    return self;
}
#endif /* NEXT_SUPRESS */
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*	Style Implementation for Hypertext			HTStyle.c
d37 1
a37 1
    StrAllocCopy(self->name, name);
d46 2
a47 2
    FREE(self->name);
    FREE(self->SGMLTag);
d191 1
a191 1
	if (0 == strcmp(scan->name, name))
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 9
a10 9
**	==================================
**
**	Styles allow the translation between a logical property
**	of a piece of text and its physical representation.
**
**	A StyleSheet is a collection of styles, defining the
**	translation necessary to
**	represent a document.  It is a linked list of styles.
*/
d19 1
a19 1
PUBLIC HTStyle* HTStyleNew NOARGS
d21 2
a22 1
    HTStyle * self = typecalloc(HTStyle);
d30 1
a30 1
PUBLIC HTStyle* HTStyleNewNamed ARGS1 (CONST char *,name)
d32 2
a33 1
    HTStyle * self = HTStyleNew();
d35 1
a35 1
    self->id = -1; /* <0 */
a38 1

d41 1
a41 1
PUBLIC HTStyle * HTStyleFree ARGS1 (HTStyle *,self)
d49 1
a49 2

#ifdef SUPPRESS  /* Only on the NeXT */
d51 5
a55 5
**	--------------------------
**
**	Reads a style with paragraph information from a stream.
**	The style name is not read or written by these routines.
*/
d59 1
a59 1
HTStyle * HTStyleRead (HTStyle * style, HTStream * stream)
d68 4
a71 4
	myTag,
	fontName,
	&style->fontSize,
	&gotpara);
d81 8
a88 8
	    &p->indent1st,
	    &p->indent2nd,
	    &p->lineHt,
	    &p->descentLine,
	    &p->alignment,
	    &style->spaceBefore,
	    &style->spaceAfter,
	    &p->numTabs);
d93 1
a93 1
	for (tab=0; tab < p->numTabs; tab++) {
d98 1
a98 1
    } else { /* No paragraph */
d100 1
a100 1
    } /* if no paragraph */
d102 1
a102 1
    if (strcmp(fontName, NONE_STRING)==0)
d105 1
a105 1
	style->font = [Font newFont:fontName size:style->fontSize];
a108 1

d111 1
a111 1
HTStyle * HTStyleWrite (HTStyle * style, NXStream * stream)
d115 1
d117 4
a120 4
	style->SGMLTag,
	style->font ? [style->font name] : NONE_STRING,
	style->fontSize,
	p!=0);
d124 8
a131 8
	    p->indent1st,
	    p->indent2nd,
	    p->lineHt,
	    p->descentLine,
	    p->alignment,
	    style->spaceBefore,
	    style->spaceAfter,
	    p->numTabs);
d133 1
a133 1
	for (tab=0; tab < p->numTabs; tab++)
d135 3
a137 3
		    p->tabs[tab].kind,
		    p->tabs[tab].x);
	}
a140 1

d143 1
a143 1
HTStyle * HTStyleDump (HTStyle * style)
d147 1
d149 5
a153 5
	style,
	style->name,
	style->SGMLTag,
	[style->font name],
	style->fontSize);
d156 4
a159 4
	    p->indent1st,
	    p->indent2nd,
	    p->lineHt,
	    p->descentLine);
d161 4
a164 4
	    p->alignment,
	    p->numTabs,
	    style->spaceBefore,
	    style->spaceAfter);
d166 1
a166 1
	for (tab=0; tab < p->numTabs; tab++) {
d168 2
a169 2
		    p->tabs[tab].kind,
		    p->tabs[tab].x);
d172 1
a172 1
    } /* if paragraph */
a176 1

d178 2
a179 2
**			====================
*/
d183 1
a183 1
HTStyle * HTStyleNamed ARGS2 (HTStyleSheet *,self, CONST char *,name)
d185 5
a189 3
    HTStyle * scan;
    for (scan=self->styles; scan; scan=scan->next)
	if (0==strcmp(scan->name, name)) return scan;
d196 1
a196 1
HTStyle * HTStyleMatching (HTStyleSheet * self, HTStyle *style)
d198 5
a202 3
    HTStyle * scan;
    for (scan=self->styles; scan; scan=scan->next)
	if (scan->paragraph == para) return scan;
d207 10
a216 10
**	------------------------------------------
**
**	This heuristic is used for guessing the style for a run of
**	text which has been pasted in.  In order, we try:
**
**	A style whose paragraph structure is actually used by the run.
**	A style matching in font
**	A style matching in paragraph style exactly
**	A style matching in paragraph to a degree
*/
d218 1
a218 1
HTStyle * HTStyleForRun (HTStyleSheet *self, NXRun *run)
d220 2
a221 2
    HTStyle * scan;
    HTStyle * best = 0;
d223 8
a230 3
    NXTextStyle * rp = run->paraStyle;
    for (scan=self->styles; scan; scan=scan->next)
	if (scan->paragraph == run->paraStyle) return scan;	/* Exact */
a231 2
    for (scan=self->styles; scan; scan=scan->next){
	NXTextStyle * sp = scan->paragraph;
d234 16
a249 9
	    if (sp->indent1st ==	rp->indent1st)	match = match+1;
	    if (sp->indent2nd ==	rp->indent2nd)	match = match+2;
	    if (sp->lineHt ==		rp->lineHt)	match = match+1;
	    if (sp->numTabs ==		rp->numTabs)	match = match+1;
	    if (sp->alignment ==	rp->alignment)	match = match+3;
	    if (scan->font ==		run->font)	match = match+10;
	    if (match>bestMatch) {
		    best=scan;
		    bestMatch=match;
d254 1
a254 1
		 bestMatch));
a258 1

d260 3
a262 4
**	----------------------
*/
HTStyleSheet * HTStyleSheetAddStyle ARGS2
  (HTStyleSheet *,self, HTStyle *,style)
d268 4
a271 3
	HTStyle * scan;
	for(scan=self->styles; scan->next; scan=scan->next); /* Find end */
	scan->next=style;
a275 1

d278 1
a278 2
HTStyleSheet * HTStyleSheetRemoveStyle ARGS2
  (HTStyleSheet *,self, HTStyle *,style)
d284 3
a286 2
	HTStyle * scan;
	for(scan = self->styles; scan; scan = scan->next) {
d299 1
a299 1
HTStyleSheet * HTStyleSheetNew NOARGS
d301 2
a302 1
    HTStyleSheet * self = typecalloc(HTStyleSheet);
a307 1

d310 1
a310 1
HTStyleSheet * HTStyleSheetFree ARGS1 (HTStyleSheet *,self)
d312 3
a314 2
    HTStyle * style;
    while((style=self->styles)!=0) {
a321 1

d323 5
a327 5
**	-------------------------------------
**
**	Reads a style sheet from a stream.  If new styles have the same names
**	as existing styles, they replace the old ones without changing the ids.
*/
d329 2
a330 2
#ifdef NEXT_SUPRESS  /* Only on the NeXT */
HTStyleSheet * HTStyleSheetRead(HTStyleSheet * self, NXStream * stream)
d334 1
a334 1
    HTStyle * style;
d336 1
d339 1
a339 1
    for (i=0; i<numStyles; i++) {
d347 2
a348 1
	if (TRACE) HTStyleDump(style);
d354 4
a357 4
**	------------------------------------
**
**	Writes a style sheet to a stream.
*/
d359 1
a359 1
HTStyleSheet * HTStyleSheetWrite(HTStyleSheet * self, NXStream * stream)
d362 1
a362 1
    HTStyle * style;
d364 2
a365 1
    for(style=self->styles; style; style=style->next) numStyles++;
d369 1
a369 1
    for (style=self->styles; style; style=style->next) {
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d21 1
a21 1
    HTStyle * self = (HTStyle *)malloc(sizeof(*self));
a23 1
    memset((void *)self, 0, sizeof(*self));
d33 1
d290 1
a290 1
    HTStyleSheet * self = (HTStyleSheet *)malloc(sizeof(*self));
a292 6

    memset((void*)self, 0, sizeof(*self));	/* ANSI */
/* Harbison c ref man says (char*)self
   but k&r ansii and abc books and Think_C say (void*) */

/*    bzero(self, sizeof(*self)); */		/* BSD */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d189 1
a189 1
    CTRACE(tfp, "StyleSheet: No style named `%s'\n", name);
d240 2
a241 2
    CTRACE(tfp, "HTStyleForRun: Best match for style is %d out of 18\n",
		 bestMatch);
d332 1
a332 1
    CTRACE(tfp, "Stylesheet: Reading %d styles\n", numStyles);
d360 1
a360 1
    CTRACE(tfp, "StyleSheet: Writing %d styles\n", numStyles);
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
**	represent a document. It is a linked list of styles.
a10 2
#include "HTUtils.h"
#include "HTStyle.h"
d12 2
a13 1
#include "LYLeaks.h"
d15 1
a15 1
#define FREE(x) if (x) {free(x); x = NULL;}
d22 2
a24 2
    self->font = (HTFont) 0;
    self->color = 0;
d75 2
d91 2
d148 1
a148 1
    printf("Style %d `%s' SGML:%s. Font %s %.1f point.\n",
d155 1
a155 3
	printf(
	"\tIndents: first=%.0f others=%.0f, Height=%.1f Desc=%.1f\n"
	"\tAlign=%d, %d tabs. (%.0f before, %.0f after)\n",
d159 2
a160 1
	    p->descentLine,
d167 1
a167 1
	    printf("\t\tTab kind=%d at %.0f\n",
d189 1
a189 1
    if (TRACE) fprintf(stderr, "StyleSheet: No style named `%s'\n", name);
d207 1
a207 1
**	text which has been pasted in. In order, we try:
d240 2
a241 2
    if (TRACE) fprintf(stderr, "HTStyleForRun: Best match for style is %d out of 18\n",
			 bestMatch);
d291 2
d332 1
a332 1
    if (TRACE) fprintf(stderr, "Stylesheet: Reading %d styles\n", numStyles);
d360 1
a360 1
    if (TRACE) fprintf(stderr, "StyleSheet: Writing %d styles\n", numStyles);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
