head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.07.00.04.58;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.05.16.44.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.07.00.36.04;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.46;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTFTP.c,v 1.125 2013/11/28 11:11:05 tom Exp $
 *
 *			File Transfer Protocol (FTP) Client
 *			for a WorldWideWeb browser
 *			===================================
 *
 *	A cache of control connections is kept.
 *
 * Note: Port allocation
 *
 *	It is essential that the port is allocated by the system, rather
 *	than chosen in rotation by us (POLL_PORTS), or the following
 *	problem occurs.
 *
 *	It seems that an attempt by the server to connect to a port which has
 *	been used recently by a listen on the same socket, or by another
 *	socket this or another process causes a hangup of (almost exactly)
 *	one minute.  Therefore, we have to use a rotating port number.
 *	The problem remains that if the application is run twice in quick
 *	succession, it will hang for what remains of a minute.
 *
 * Authors
 *	TBL	Tim Berners-lee <timbl@@info.cern.ch>
 *	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
 *	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
 *	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
 * History:
 *	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
 *	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
 *	10 Feb 92	Retry if cached connection times out or breaks
 *	 8 Dec 92	Bug fix 921208 TBL after DD
 *	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
 *			fails on princeton.edu!
 *	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
 *			must be Unix-style and cannot include the device
 *			or top directory.
 *	?? ??? ?? (LM)	Added code to prompt and send passwords for non
 *			anonymous FTP
 *	25 Mar 94 (LM)	Added code to recognize different ftp server types
 *			and code to parse dates and sizes on most hosts.
 *	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
 *
 * Notes:
 *			Portions Copyright 1994 Trustees of Dartmouth College
 *			Code for recognizing different FTP servers and
 *			parsing "ls -l" output taken from Macintosh Fetch
 *			program with permission from Jim Matthews,
 *			Dartmouth Software Development Team.
 */

/*
 * BUGS:	@@@@@@	Limit connection cache size!
 * 		Error reporting to user.
 * 		400 & 500 errors are ack'ed by user with windows.
 * 		Use configuration file for user names
 * 
 *		Note for portability this version does not use select() and
 *		so does not watch the control and data channels at the
 *		same time.
 */

#include <HTUtils.h>

#include <HTAlert.h>

#include <HTFTP.h>		/* Implemented here */
#include <HTTCP.h>
#include <HTTP.h>
#include <HTFont.h>

#define REPEAT_PORT		/* Give the port number for each file */
#define REPEAT_LISTEN		/* Close each listen socket and open a new one */

/* define POLL_PORTS		 If allocation does not work, poll ourselves.*/
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP) */

#define FIRST_TCP_PORT	1024	/* Region to try for a listening port */
#define LAST_TCP_PORT	5999

#define LINE_LENGTH 256

#include <HTParse.h>
#include <HTAnchor.h>
#include <HTFile.h>		/* For HTFileFormat() */
#include <HTBTree.h>
#include <HTChunk.h>
#ifndef IPPORT_FTP
#define IPPORT_FTP	21
#endif /* !IPORT_FTP */

#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYLeaks.h>

typedef struct _connection {
    struct _connection *next;	/* Link on list         */
    int socket;			/* Socket number for communication */
    BOOL is_binary;		/* Binary mode? */
} connection;

/*		Hypertext object building machinery
*/
#include <HTML.h>

/*
 * socklen_t is the standard, but there are many pre-standard variants.
 * This ifdef works around a few of those cases.
 *
 * Information was obtained from header files on these platforms:
 *	AIX 4.3.2, 5.1
 *	HPUX 10.20, 11.00, 11.11
 *	IRIX64 6.5
 *	Tru64 4.0G, 4.0D, 5.1
 */
#if defined(SYS_IRIX64)
	/* IRIX64 6.5 socket.h may use socklen_t if SGI_SOURCE is not defined */
#  if _NO_XOPEN4 && _NO_XOPEN5
#    define LY_SOCKLEN socklen_t
#  elif _ABIAPI
#    define LY_SOCKLEN int
#  elif _XOPEN5
#    if (_MIPS_SIM != _ABIO32)
#      define LY_SOCKLEN socklen_t
#    else
#      define LY_SOCKLEN int
#    endif
#  else
#    define LY_SOCKLEN size_t
#  endif
#elif defined(SYS_HPUX)
#  if defined(_XOPEN_SOURCE_EXTENDED) && defined(SO_PROTOTYPE)
#    define LY_SOCKLEN socklen_t
#  else	/* HPUX 10.20, etc. */
#    define LY_SOCKLEN int
#  endif
#elif defined(SYS_TRU64)
#  if defined(_POSIX_PII_SOCKET)
#    define LY_SOCKLEN socklen_t
#  elif defined(_XOPEN_SOURCE_EXTENDED)
#    define LY_SOCKLEN size_t
#  else
#    define LY_SOCKLEN int
#  endif
#else
#  define LY_SOCKLEN socklen_t
#endif

#define PUTC(c)      (*target->isa->put_character) (target, c)
#define PUTS(s)      (*target->isa->put_string)    (target, s)
#define START(e)     (*target->isa->start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*target->isa->end_element)   (target, e, 0)
#define FREE_TARGET  (*target->isa->_free)         (target)
#define ABORT_TARGET (*target->isa->_free)         (target)

#define TRACE_ENTRY(tag, entry_info) \
    CTRACE((tfp, "HTFTP: %s filename: %s  date: %s  size: %" PRI_off_t "\n", \
	    tag, \
	    entry_info->filename, \
	    NonNull(entry_info->date), \
	    entry_info->size))

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

/*	Global Variables
 *	---------------------
 */
int HTfileSortMethod = FILE_BY_NAME;

#ifndef DISABLE_FTP		/*This disables everything to end-of-file */
static char ThisYear[8];
static char LastYear[8];
static int TheDate;
static BOOLEAN HaveYears = FALSE;

/*	Module-Wide Variables
 *	---------------------
 */
static connection *connections = NULL;	/* Linked list of connections */
static char response_text[LINE_LENGTH + 1];	/* Last response from ftp host */
static connection *control = NULL;	/* Current connection */
static int data_soc = -1;	/* Socket for data transfer =invalid */
static char *user_entered_password = NULL;
static char *last_username_and_host = NULL;

/*
 * Some ftp servers are known to have a broken implementation of RETR.  If
 * asked to retrieve a directory, they get confused and fail subsequent
 * commands such as CWD and LIST.
 */
static int Broken_RETR = FALSE;

/*
 * Some ftp servers are known to have a broken implementation of EPSV.  The
 * server will hang for a long time when we attempt to connect after issuing
 * this command.
 */
#ifdef INET6
static int Broken_EPSV = FALSE;
#endif

typedef enum {
    GENERIC_SERVER
    ,MACHTEN_SERVER
    ,UNIX_SERVER
    ,VMS_SERVER
    ,CMS_SERVER
    ,DCTS_SERVER
    ,TCPC_SERVER
    ,PETER_LEWIS_SERVER
    ,NCSA_SERVER
    ,WINDOWS_NT_SERVER
    ,WINDOWS_2K_SERVER
    ,MS_WINDOWS_SERVER
    ,MSDOS_SERVER
    ,APPLESHARE_SERVER
    ,NETPRESENZ_SERVER
    ,DLS_SERVER
} eServerType;

static eServerType server_type = GENERIC_SERVER;	/* the type of ftp host */
static int unsure_type = FALSE;	/* sure about the type? */
static BOOLEAN use_list = FALSE;	/* use the LIST command? */

static int interrupted_in_next_data_char = FALSE;

#ifdef POLL_PORTS
static PortNumber port_number = FIRST_TCP_PORT;
#endif /* POLL_PORTS */

static BOOL have_socket = FALSE;	/* true if master_socket is valid */
static unsigned master_socket;	/* Listening socket = invalid */

static char port_command[255];	/* Command for setting the port */
static fd_set open_sockets;	/* Mask of active channels */
static unsigned num_sockets;	/* Number of sockets to scan */
static PortNumber passive_port;	/* Port server specified for data */

#define NEXT_CHAR HTGetCharacter()	/* Use function in HTFormat.c */

#define DATA_BUFFER_SIZE 2048
static char data_buffer[DATA_BUFFER_SIZE];	/* Input data buffer */
static char *data_read_pointer;
static char *data_write_pointer;

#define NEXT_DATA_CHAR next_data_char()
static int close_connection(connection * con);

#ifndef HAVE_ATOLL
off_t LYatoll(const char *value)
{
    off_t result = 0;

    while (*value != '\0') {
	result = (result * 10) + (off_t) (*value++ - '0');
    }
    return result;
}
#endif

#ifdef LY_FIND_LEAKS
/*
 *  This function frees module globals. - FM
 */
static void free_FTPGlobals(void)
{
    FREE(user_entered_password);
    FREE(last_username_and_host);
    if (control) {
	if (control->socket != -1)
	    close_connection(control);
	FREE(control);
    }
}
#endif /* LY_FIND_LEAKS */

/* PUBLIC						HTVMS_name()
 *		CONVERTS WWW name into a VMS name
 * ON ENTRY:
 *	nn		Node Name (optional)
 *	fn		WWW file name
 *
 * ON EXIT:
 *	returns		vms file specification
 *
 * Bug: Returns pointer to static -- non-reentrant
 */
char *HTVMS_name(const char *nn,
		 const char *fn)
{
    /* We try converting the filename into Files-11 syntax.  That is, we assume
     * first that the file is, like us, on a VMS node.  We try remote (or
     * local) DECnet access.  Files-11, VMS, VAX and DECnet are trademarks of
     * Digital Equipment Corporation.  The node is assumed to be local if the
     * hostname WITHOUT DOMAIN matches the local one.  @@@@@@
     */
    static char *vmsname;
    char *filename = (char *) malloc(strlen(fn) + 1);
    char *nodename = (char *) malloc(strlen(nn) + 2 + 1);	/* Copies to hack */
    char *second;		/* 2nd slash */
    char *last;			/* last slash */

    const char *hostname = HTHostName();

    if (!filename || !nodename)
	outofmem(__FILE__, "HTVMSname");

    assert(filename != NULL);
    assert(nodename != NULL);

    strcpy(filename, fn);
    strcpy(nodename, "");	/* On same node?  Yes if node names match */
    if (StrNCmp(nn, "localhost", 9)) {
	const char *p;
	const char *q;

	for (p = hostname, q = nn;
	     *p && *p != '.' && *q && *q != '.'; p++, q++) {
	    if (TOUPPER(*p) != TOUPPER(*q)) {
		char *r;

		strcpy(nodename, nn);
		r = StrChr(nodename, '.');	/* Mismatch */
		if (r)
		    *r = '\0';	/* Chop domain */
		strcat(nodename, "::");		/* Try decnet anyway */
		break;
	    }
	}
    }

    second = StrChr(filename + 1, '/');		/* 2nd slash */
    last = strrchr(filename, '/');	/* last slash */

    if (!second) {		/* Only one slash */
	HTSprintf0(&vmsname, "%s%s", nodename, filename + 1);
    } else if (second == last) {	/* Exactly two slashes */
	*second = '\0';		/* Split filename from disk */
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename + 1, second + 1);
	*second = '/';		/* restore */
    } else {			/* More than two slashes */
	char *p;

	*second = '\0';		/* Split disk from directories */
	*last = '\0';		/* Split dir from filename */
	HTSprintf0(&vmsname, "%s%s:[%s]%s",
		   nodename, filename + 1, second + 1, last + 1);
	*second = *last = '/';	/* restore filename */
	if ((p = StrChr(vmsname, '[')) != 0) {
	    while (*p != '\0' && *p != ']') {
		if (*p == '/')
		    *p = '.';	/* Convert dir sep.  to dots */
		++p;
	    }
	}
    }
    FREE(nodename);
    FREE(filename);
    return vmsname;
}

/*	Procedure: Read a character from the data connection
 *	----------------------------------------------------
 */
static int next_data_char(void)
{
    int status;

    if (data_read_pointer >= data_write_pointer) {
	status = NETREAD(data_soc, data_buffer, DATA_BUFFER_SIZE);
	if (status == HT_INTERRUPTED)
	    interrupted_in_next_data_char = 1;
	if (status <= 0)
	    return EOF;
	data_write_pointer = data_buffer + status;
	data_read_pointer = data_buffer;
    }
#ifdef NOT_ASCII
    {
	char c = *data_read_pointer++;

	return FROMASCII(c);
    }
#else
    return UCH(*data_read_pointer++);
#endif /* NOT_ASCII */
}

/*	Close an individual connection
 *
 */
static int close_connection(connection * con)
{
    connection *scan;
    int status;

    CTRACE((tfp, "HTFTP: Closing control socket %d\n", con->socket));
    status = NETCLOSE(con->socket);
    if (TRACE && status != 0) {
#ifdef UNIX
	CTRACE((tfp, "HTFTP:close_connection: %s", LYStrerror(errno)));
#else
	if (con->socket != INVSOC)
	    HTInetStatus("HTFTP:close_connection");
#endif
    }
    con->socket = -1;
    if (connections == con) {
	connections = con->next;
	return status;
    }
    for (scan = connections; scan; scan = scan->next) {
	if (scan->next == con) {
	    scan->next = con->next;	/* Unlink */
	    if (control == con)
		control = (connection *) 0;
	    return status;
	}			/*if */
    }				/* for */
    return -1;			/* very strange -- was not on list. */
}

static char *help_message_buffer = NULL;	/* global :( */

static void init_help_message_cache(void)
{
    FREE(help_message_buffer);
}

static void help_message_cache_add(char *string)
{
    if (help_message_buffer)
	StrAllocCat(help_message_buffer, string);
    else
	StrAllocCopy(help_message_buffer, string);

    CTRACE((tfp, "Adding message to help cache: %s\n", string));
}

static char *help_message_cache_non_empty(void)
{
    return (help_message_buffer);
}

static char *help_message_cache_contents(void)
{
    return (help_message_buffer);
}

/*	Send One Command
 *	----------------
 *
 *	This function checks whether we have a control connection, and sends
 *	one command if given.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command should already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  1 for success,
 *		  or negative for communication failure (in which case
 *		  the control connection will be closed).
 */
static int write_cmd(const char *cmd)
{
    int status;

    if (!control) {
	CTRACE((tfp, "HTFTP: No control connection set up!!\n"));
	return HT_NO_CONNECTION;
    }

    if (cmd) {
	CTRACE((tfp, "  Tx: %s", cmd));
#ifdef NOT_ASCII
	{
	    char *p;

	    for (p = cmd; *p; p++) {
		*p = TOASCII(*p);
	    }
	}
#endif /* NOT_ASCII */
	status = (int) NETWRITE(control->socket, cmd, (unsigned) strlen(cmd));
	if (status < 0) {
	    CTRACE((tfp,
		    "HTFTP: Error %d sending command: closing socket %d\n",
		    status, control->socket));
	    close_connection(control);
	    return status;
	}
    }
    return 1;
}

/*
 * For each string in the list, check if it is found in the response text.
 * If so, return TRUE.
 */
static BOOL find_response(HTList *list)
{
    BOOL result = FALSE;
    HTList *p = list;
    char *value;

    while ((value = (char *) HTList_nextObject(p)) != NULL) {
	if (LYstrstr(response_text, value)) {
	    result = TRUE;
	    break;
	}
    }
    return result;
}

/*	Execute Command and get Response
 *	--------------------------------
 *
 *	See the state machine illustrated in RFC959, p57. This implements
 *	one command/reply sequence.  It also interprets lines which are to
 *	be continued, which are marked with a "-" immediately after the
 *	status code.
 *
 *	Continuation then goes on until a line with a matching reply code
 *	an a space after it.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command must already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  The first digit of the reply type,
 *		  or negative for communication failure.
 */
static int response(const char *cmd)
{
    int result;			/* Three-digit decimal code */
    int continuation_response = -1;
    int status;

    if ((status = write_cmd(cmd)) < 0)
	return status;

    do {
	char *p = response_text;

	for (;;) {
	    int ich = NEXT_CHAR;

	    if (((*p++ = (char) ich) == LF)
		|| (p == &response_text[LINE_LENGTH])) {

		char continuation;

		if (interrupted_in_htgetcharacter) {
		    CTRACE((tfp,
			    "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return HT_INTERRUPTED;
		}

		*p = '\0';	/* Terminate the string */
		CTRACE((tfp, "    Rx: %s", response_text));

		/* Check for login or help messages */
		if (!StrNCmp(response_text, "230-", 4) ||
		    !StrNCmp(response_text, "250-", 4) ||
		    !StrNCmp(response_text, "220-", 4))
		    help_message_cache_add(response_text + 4);

		sscanf(response_text, "%d%c", &result, &continuation);
		if (continuation_response == -1) {
		    if (continuation == '-')	/* start continuation */
			continuation_response = result;
		} else {	/* continuing */
		    if (continuation_response == result &&
			continuation == ' ')
			continuation_response = -1;	/* ended */
		}
		if (result == 220 && find_response(broken_ftp_retr)) {
		    Broken_RETR = TRUE;
		    CTRACE((tfp, "This server is broken (RETR)\n"));
		}
#ifdef INET6
		if (result == 220 && find_response(broken_ftp_epsv)) {
		    Broken_EPSV = TRUE;
		    CTRACE((tfp, "This server is broken (EPSV)\n"));
		}
#endif
		break;
	    }
	    /* if end of line */
	    if (interrupted_in_htgetcharacter) {
		CTRACE((tfp,
			"HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE(control->socket);
		control->socket = -1;
		return HT_INTERRUPTED;
	    }

	    if (ich == EOF) {
		CTRACE((tfp, "Error on rx: closing socket %d\n",
			control->socket));
		strcpy(response_text, "000 *** TCP read error on response\n");
		close_connection(control);
		return -1;	/* End of file on response */
	    }
	}			/* Loop over characters */

    } while (continuation_response != -1);

    if (result == 421) {
	CTRACE((tfp, "HTFTP: They close so we close socket %d\n",
		control->socket));
	close_connection(control);
	return -1;
    }
    if ((result == 255 && server_type == CMS_SERVER) &&
	(0 == strncasecomp(cmd, "CWD", 3) ||
	 0 == strcasecomp(cmd, "CDUP"))) {
	/*
	 * Alas, CMS returns 255 on failure to CWD to parent of root.  - PG
	 */
	result = 555;
    }
    return result / 100;
}

static int send_cmd_1(const char *verb)
{
    char command[80];

    sprintf(command, "%.*s%c%c", (int) sizeof(command) - 4, verb, CR, LF);
    return response(command);
}

static int send_cmd_2(const char *verb, const char *param)
{
    char *command = 0;
    int status;

    HTSprintf0(&command, "%s %s%c%c", verb, param, CR, LF);
    status = response(command);
    FREE(command);

    return status;
}

#define send_cwd(path) send_cmd_2("CWD", path)

/*
 * This function should try to set the macintosh server into binary mode.  Some
 * servers need an additional letter after the MACB command.
 */
static int set_mac_binary(eServerType ServerType)
{
    /* try to set mac binary mode */
    if (ServerType == APPLESHARE_SERVER ||
	ServerType == NETPRESENZ_SERVER) {
	/*
	 * Presumably E means "Enable".  - KW
	 */
	return (2 == response("MACB E\r\n"));
    } else {
	return (2 == response("MACB\r\n"));
    }
}

/* This function gets the current working directory to help
 * determine what kind of host it is
 */

static void get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* get the working directory (to see what it looks like) */
    int status = response("PWD\r\n");

    if (status < 0) {
	return;
    } else {
	cp = StrChr(response_text + 5, '"');
	if (cp)
	    *cp = '\0';
	if (*ServerType == TCPC_SERVER) {
	    *ServerType = ((response_text[5] == '/') ?
			   NCSA_SERVER : TCPC_SERVER);
	    CTRACE((tfp, "HTFTP: Treating as %s server.\n",
		    ((*ServerType == NCSA_SERVER) ?
		     "NCSA" : "TCPC")));
	} else if (response_text[5] == '/') {
	    /* path names beginning with / imply Unix,
	     * right?
	     */
	    if (set_mac_binary(*ServerType)) {
		*ServerType = NCSA_SERVER;
		CTRACE((tfp, "HTFTP: Treating as NCSA server.\n"));
	    } else {
		*ServerType = UNIX_SERVER;
		*UseList = TRUE;
		CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
	    }
	    return;
	} else if (response_text[strlen(response_text) - 1] == ']') {
	    /* path names ending with ] imply VMS, right? */
	    *ServerType = VMS_SERVER;
	    *UseList = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	} else {
	    *ServerType = GENERIC_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Generic server.\n"));
	}

	if ((*ServerType == NCSA_SERVER) ||
	    (*ServerType == TCPC_SERVER) ||
	    (*ServerType == PETER_LEWIS_SERVER) ||
	    (*ServerType == NETPRESENZ_SERVER))
	    set_mac_binary(*ServerType);
    }
}

/* This function turns MSDOS-like directory output off for
 * Windows NT servers.
 */

static void set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* This is a toggle.  It seems we have to toggle in order to see
     * the current state (after toggling), so we may end up toggling
     * twice.  - kw
     */
    int status = response("SITE DIRSTYLE\r\n");

    if (status != 2) {
	*ServerType = GENERIC_SERVER;
	CTRACE((tfp, "HTFTP: DIRSTYLE failed, treating as Generic server.\n"));
	return;
    } else {
	*UseList = TRUE;
	/* Expecting one of:
	 * 200 MSDOS-like directory output is off
	 * 200 MSDOS-like directory output is on
	 * The following code doesn't look for the full exact string -
	 * who knows how the wording may change in some future version.
	 * If the first response isn't recognized, we toggle again
	 * anyway, under the assumption that it's more likely that
	 * the MSDOS setting was "off" originally. - kw
	 */
	cp = strstr(response_text + 4, "MSDOS");
	if (cp && strstr(cp, " off")) {
	    return;		/* already off now. */
	} else {
	    response("SITE DIRSTYLE\r\n");
	}
    }
}

#define CheckForInterrupt(msg) \
	if (status == HT_INTERRUPTED) { \
	    CTRACE((tfp, "HTFTP: Interrupted %s.\n", msg)); \
	    _HTProgress(CONNECTION_INTERRUPTED); \
	    NETCLOSE(control->socket); \
	    control->socket = -1; \
	    return HT_INTERRUPTED; \
	}

/*	Get a valid connection to the host
 *	----------------------------------
 *
 * On entry,
 *	arg	points to the name of the host in a hypertext address
 * On exit,
 *	returns <0 if error
 *		socket number if success
 *
 *	This routine takes care of managing timed-out connections, and
 *	limiting the number of connections in use at any one time.
 *
 *	It ensures that all connections are logged in if they exist.
 *	It ensures they have the port number transferred.
 */
static int get_connection(const char *arg,
			  HTParentAnchor *anchor)
{
    int status;
    char *command = 0;
    connection *con;
    char *username = NULL;
    char *password = NULL;
    static BOOLEAN firstuse = TRUE;

    if (firstuse) {
	/*
	 * Set up freeing at exit.  - FM
	 */
#ifdef LY_FIND_LEAKS
	atexit(free_FTPGlobals);
#endif
	firstuse = FALSE;
    }

    if (control != 0) {
	connection *next = control->next;

	if (control->socket != -1) {
	    NETCLOSE(control->socket);
	}
	memset(con = control, 0, sizeof(*con));
	con->next = next;
    } else {
	con = typecalloc(connection);
	if (con == NULL)
	    outofmem(__FILE__, "get_connection");

	assert(con != NULL);
    }
    con->socket = -1;

    if (isEmpty(arg)) {
	free(con);
	return -1;		/* Bad if no name specified     */
    }

    /* Get node name:
     */
    CTRACE((tfp, "get_connection(%s)\n", arg));
    {
	char *p1 = HTParse(arg, "", PARSE_HOST);
	char *p2 = strrchr(p1, '@@');	/* user? */
	char *pw = NULL;

	if (p2 != NULL) {
	    username = p1;
	    *p2 = '\0';		/* terminate */
	    p1 = p2 + 1;	/* point to host */
	    pw = StrChr(username, ':');
	    if (pw != NULL) {
		*pw++ = '\0';
		password = HTUnEscape(pw);
	    }
	    if (*username)
		HTUnEscape(username);

	    /*
	     * If the password doesn't exist then we are going to have to ask
	     * the user for it.  The only problem is that we don't want to ask
	     * for it every time, so we will store away in a primitive fashion.
	     */
	    if (!password) {
		char *tmp = NULL;

		HTSprintf0(&tmp, "%s@@%s", username, p1);
		/*
		 * If the user@@host is not equal to the last time through or
		 * user_entered_password has no data then we need to ask the
		 * user for the password.
		 */
		if (!last_username_and_host ||
		    strcmp(tmp, last_username_and_host) ||
		    !user_entered_password) {

		    StrAllocCopy(last_username_and_host, tmp);
		    HTSprintf0(&tmp, gettext("Enter password for user %s@@%s:"),
			       username, p1);
		    FREE(user_entered_password);
		    user_entered_password = HTPromptPassword(tmp);

		}		/* else we already know the password */
		password = user_entered_password;
		FREE(tmp);
	    }
	}

	if (!username)
	    FREE(p1);
    }				/* scope of p1 */

    status = HTDoConnect(arg, "FTP", IPPORT_FTP, (int *) &con->socket);

    if (status < 0) {
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted on connect\n"));
	} else {
	    CTRACE((tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
		    arg));
	}
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    status = HT_NOT_LOADED;
	} else {
	    HTAlert(gettext("Unable to connect to FTP host."));
	}
	if (con->socket != -1) {
	    NETCLOSE(con->socket);
	}

	FREE(username);
	if (control == con)
	    control = NULL;
	FREE(con);
	return status;		/* Bad return */
    }

    CTRACE((tfp, "FTP connected, socket %d  control %p\n",
	    con->socket, (void *) con));
    control = con;		/* Current control connection */

    /* Initialise buffering for control connection */
    HTInitInput(control->socket);
    init_help_message_cache();	/* Clear the login message buffer. */

    /*  Now we log in           Look up username, prompt for pw.
     */
    status = response((char *) 0);	/* Get greeting */
    CheckForInterrupt("at beginning of login");

    server_type = GENERIC_SERVER;	/* reset */
    if (status == 2) {		/* Send username */
	char *cp;		/* look at greeting text */

	/* don't gettext() this -- incoming text: */
	if (strlen(response_text) > 4) {
	    if ((cp = strstr(response_text, " awaits your command")) ||
		(cp = strstr(response_text, " ready."))) {
		*cp = '\0';
	    }
	    cp = response_text + 4;
	    if (!strncasecomp(cp, "NetPresenz", 10))
		server_type = NETPRESENZ_SERVER;
	} else {
	    cp = response_text;
	}
	StrAllocCopy(anchor->server, cp);

	status = send_cmd_2("USER", (username && *username)
			    ? username
			    : "anonymous");

	CheckForInterrupt("while sending username");
    }
    if (status == 3) {		/* Send password */
	if (non_empty(password)) {
	    HTSprintf0(&command, "PASS %s%c%c", password, CR, LF);
	} else {
	    /*
	     * No password was given; use mail-address.
	     */
	    const char *the_address;
	    char *user = NULL;
	    const char *host = NULL;
	    char *cp;

	    the_address = anonftp_password;
	    if (isEmpty(the_address))
		the_address = personal_mail_address;
	    if (isEmpty(the_address))
		the_address = LYGetEnv("USER");
	    if (isEmpty(the_address))
		the_address = "WWWuser";

	    StrAllocCopy(user, the_address);
	    if ((cp = StrChr(user, '@@')) != NULL) {
		*cp++ = '\0';
		if (*cp == '\0')
		    host = HTHostName();
		else
		    host = cp;
	    } else {
		host = HTHostName();
	    }

	    /*
	     * If host is not fully qualified, suppress it
	     * as ftp.uu.net prefers a blank to a bad name
	     */
	    if (!(host) || StrChr(host, '.') == NULL)
		host = "";

	    HTSprintf0(&command, "PASS %s@@%s%c%c", user, host, CR, LF);
	    FREE(user);
	}
	status = response(command);
	FREE(command);
	CheckForInterrupt("while sending password");
    }
    FREE(username);

    if (status == 3) {
	status = send_cmd_1("ACCT noaccount");
	CheckForInterrupt("while sending password");
    }
    if (status != 2) {
	CTRACE((tfp, "HTFTP: Login fail: %s", response_text));
	/* if (control->socket > 0) close_connection(control->socket); */
	return -1;		/* Bad return */
    }
    CTRACE((tfp, "HTFTP: Logged in.\n"));

    /* Check for host type */
    if (server_type != NETPRESENZ_SERVER)
	server_type = GENERIC_SERVER;	/* reset */
    use_list = FALSE;		/* reset */
    if (response("SYST\r\n") == 2) {
	/* we got a line -- what kind of server are we talking to? */
	if (StrNCmp(response_text + 4,
		    "UNIX Type: L8 MAC-OS MachTen", 28) == 0) {
	    server_type = MACHTEN_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MachTen server.\n"));

	} else if (strstr(response_text + 4, "UNIX") != NULL ||
		   strstr(response_text + 4, "Unix") != NULL) {
	    server_type = UNIX_SERVER;
	    unsure_type = FALSE;	/* to the best of out knowledge... */
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));

	} else if (strstr(response_text + 4, "MSDOS") != NULL) {
	    server_type = MSDOS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n"));

	} else if (StrNCmp(response_text + 4, "VMS", 3) == 0) {
	    char *tilde = strstr(arg, "/~");

	    use_list = TRUE;
	    if (tilde != 0
		&& tilde[2] != 0
		&& strstr(response_text + 4, "MadGoat") != 0) {
		server_type = UNIX_SERVER;
		CTRACE((tfp, "HTFTP: Treating VMS as UNIX server.\n"));
	    } else {
		server_type = VMS_SERVER;
		CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	    }

	} else if ((StrNCmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (StrNCmp(response_text + 4, "VM ", 3) == 0)) {
	    server_type = CMS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as CMS server.\n"));

	} else if (StrNCmp(response_text + 4, "DCTS", 4) == 0) {
	    server_type = DCTS_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as DCTS server.\n"));

	} else if (strstr(response_text + 4, "MAC-OS TCP/Connect II") != NULL) {
	    server_type = TCPC_SERVER;
	    CTRACE((tfp, "HTFTP: Looks like a TCPC server.\n"));
	    get_ftp_pwd(&server_type, &use_list);
	    unsure_type = TRUE;

	} else if (server_type == NETPRESENZ_SERVER) {	/* already set above */
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n"));

	} else if (StrNCmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
	    server_type = PETER_LEWIS_SERVER;
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n"));

	} else if (StrNCmp(response_text + 4, "Windows_NT", 10) == 0) {
	    server_type = WINDOWS_NT_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_NT server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (StrNCmp(response_text + 4, "Windows2000", 11) == 0) {
	    server_type = WINDOWS_2K_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_2K server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (StrNCmp(response_text + 4, "MS Windows", 10) == 0) {
	    server_type = MS_WINDOWS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MS Windows server.\n"));

	} else if (StrNCmp(response_text + 4,
			   "MACOS AppleShare IP FTP Server", 30) == 0) {
	    server_type = APPLESHARE_SERVER;
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as AppleShare server.\n"));

	} else {
	    server_type = GENERIC_SERVER;
	    CTRACE((tfp, "HTFTP: Ugh!  A Generic server.\n"));
	    get_ftp_pwd(&server_type, &use_list);
	    unsure_type = TRUE;
	}
    } else {
	/* SYST fails :(  try to get the type from the PWD command */
	get_ftp_pwd(&server_type, &use_list);
    }

    return con->socket;		/* Good return */
}

static void reset_master_socket(void)
{
    have_socket = FALSE;
}

static void set_master_socket(int value)
{
    have_socket = (BOOLEAN) (value >= 0);
    if (have_socket)
	master_socket = (unsigned) value;
}

/*	Close Master (listening) socket
 *	-------------------------------
 *
 *
 */
static int close_master_socket(void)
{
    int status;

    if (have_socket)
	FD_CLR(master_socket, &open_sockets);

    status = NETCLOSE((int) master_socket);
    CTRACE((tfp, "HTFTP: Closed master socket %u\n", master_socket));

    reset_master_socket();

    if (status < 0)
	return HTInetStatus(gettext("close master socket"));
    else
	return status;
}

/*	Open a master socket for listening on
 *	-------------------------------------
 *
 *	When data is transferred, we open a port, and wait for the server to
 *	connect with the data.
 *
 * On entry,
 *	have_socket	Must be false, if master_socket is not setup already
 *	master_socket	Must be negative if not set up already.
 * On exit,
 *	Returns		socket number if good
 *			less than zero if error.
 *	master_socket	is socket number if good, else negative.
 *	port_number	is valid if good.
 */
static int get_listen_socket(void)
{
#ifdef INET6
    struct sockaddr_storage soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = (struct sockaddr_in *) &soc_address;
    int af;
    LY_SOCKLEN slen;

#else
    struct sockaddr_in soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = &soc_address;
#endif /* INET6 */
    int new_socket;		/* Will be master_socket */

    FD_ZERO(&open_sockets);	/* Clear our record of open sockets */
    num_sockets = 0;

#ifndef REPEAT_LISTEN
    if (have_socket)
	return master_socket;	/* Done already */
#endif /* !REPEAT_LISTEN */

#ifdef INET6
    /* query address family of control connection */
    slen = (LY_SOCKLEN) sizeof(soc_address);
    if (getsockname(control->socket, (struct sockaddr *) &soc_address,
		    &slen) < 0) {
	return HTInetStatus("getsockname failed");
    }
    af = ((struct sockaddr *) &soc_address)->sa_family;
    memset(&soc_address, 0, sizeof(soc_address));
#endif /* INET6 */

/*  Create internet socket
*/
#ifdef INET6
    new_socket = socket(af, SOCK_STREAM, IPPROTO_TCP);
#else
    new_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
#endif /* INET6 */

    if (new_socket < 0)
	return HTInetStatus(gettext("socket for master socket"));

    CTRACE((tfp, "HTFTP: Opened master socket number %d\n", new_socket));

/*  Search for a free port.
*/
#ifdef INET6
    memset(&soc_address, 0, sizeof(soc_address));
    ((struct sockaddr *) &soc_address)->sa_family = af;
    switch (af) {
    case AF_INET:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in);
#endif /* SIN6_LEN */
	break;
    case AF_INET6:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in6);
#endif /* SIN6_LEN */
	break;
    default:
	HTInetStatus("AF");
    }
#else
    soc_in->sin_family = AF_INET;	/* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;	/* Any peer address */
#endif /* INET6 */
#ifdef POLL_PORTS
    {
	PortNumber old_port_number = port_number;

	for (port_number = (old_port_number + 1);; port_number++) {
	    int status;

	    if (port_number > LAST_TCP_PORT)
		port_number = FIRST_TCP_PORT;
	    if (port_number == old_port_number) {
		return HTInetStatus("bind");
	    }
#ifdef INET6
	    soc_in->sin_port = htons(port_number);
#else
	    soc_address.sin_port = htons(port_number);
#endif /* INET6 */
#ifdef SOCKS
	    if (socks_flag)
		if ((status = Rbind(new_socket,
				    (struct sockaddr *) &soc_address,
		/* Cast to generic sockaddr */
				    SOCKADDR_LEN(soc_address)
#ifndef SHORTENED_RBIND
				    ,socks_bind_remoteAddr
#endif /* !SHORTENED_RBIND */
		     )) == 0) {
		    break;
		} else
#endif /* SOCKS */
		    if ((status = bind(new_socket,
				       (struct sockaddr *) &soc_address,
		    /* Cast to generic sockaddr */
				       SOCKADDR_LEN(soc_address)
			 )) == 0) {
		    break;
		}
	    CTRACE((tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		    port_number, status, SOCKET_ERRNO));
	}			/* for */
    }
#else
    {
	int status;
	LY_SOCKLEN address_length = (LY_SOCKLEN) sizeof(soc_address);

#ifdef SOCKS
	if (socks_flag)
	    status = Rgetsockname(control->socket,
				  (struct sockaddr *) &soc_address,
				  &address_length);
	else
#endif /* SOCKS */
	    status = getsockname(control->socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0) {
	    close(new_socket);
	    return HTInetStatus("getsockname");
	}
#ifdef INET6
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString((void *) soc_in)));

	soc_in->sin_port = 0;	/* Unspecified: please allocate */
#else
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString(soc_in)));

	soc_address.sin_port = 0;	/* Unspecified: please allocate */
#endif /* INET6 */
#ifdef SOCKS
	if (socks_flag)
	    status = Rbind(new_socket,
			   (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			   sizeof(soc_address)
#ifndef SHORTENED_RBIND
			   ,socks_bind_remoteAddr
#endif /* !SHORTENED_RBIND */
		);
	else
#endif /* SOCKS */
	    status = bind(new_socket,
			  (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			  SOCKADDR_LEN(soc_address)
		);
	if (status < 0) {
	    close(new_socket);
	    return HTInetStatus("bind");
	}

	address_length = sizeof(soc_address);
#ifdef SOCKS
	if (socks_flag)
	    status = Rgetsockname(new_socket,
				  (struct sockaddr *) &soc_address,
				  &address_length);
	else
#endif /* SOCKS */
	    status = getsockname(new_socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0) {
	    close(new_socket);
	    return HTInetStatus("getsockname");
	}
    }
#endif /* POLL_PORTS */

#ifdef INET6
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString((void *) soc_in)));
#else
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString(soc_in)));
#endif /* INET6 */

#ifdef REPEAT_LISTEN
    if (have_socket)
	(void) close_master_socket();
#endif /* REPEAT_LISTEN */

    set_master_socket(new_socket);

/*	Now we must find out who we are to tell the other guy
*/
    (void) HTHostName();	/* Make address valid - doesn't work */
#ifdef INET6
    switch (((struct sockaddr *) &soc_address)->sa_family) {
    case AF_INET:
#endif /* INET6 */
	sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
		(int) *((unsigned char *) (&soc_in->sin_addr) + 0),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 1),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 2),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 3),
		(int) *((unsigned char *) (&soc_in->sin_port) + 0),
		(int) *((unsigned char *) (&soc_in->sin_port) + 1),
		CR, LF);

#ifdef INET6
	break;

    case AF_INET6:
	{
	    char hostbuf[MAXHOSTNAMELEN];
	    char portbuf[MAXHOSTNAMELEN];

	    getnameinfo((struct sockaddr *) &soc_address,
			SOCKADDR_LEN(soc_address),
			hostbuf,
			(socklen_t) sizeof(hostbuf),
			portbuf,
			(socklen_t) sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		    CR, LF);
	    break;
	}
    default:
	sprintf(port_command, "JUNK%c%c", CR, LF);
	break;
    }
#endif /* INET6 */

    /*  Inform TCP that we will accept connections
     */
    {
	int status;

#ifdef SOCKS
	if (socks_flag)
	    status = Rlisten((int) master_socket, 1);
	else
#endif /* SOCKS */
	    status = listen((int) master_socket, 1);
	if (status < 0) {
	    reset_master_socket();
	    return HTInetStatus("listen");
	}
    }
    CTRACE((tfp, "TCP: Master socket(), bind() and listen() all OK\n"));
    FD_SET(master_socket, &open_sockets);
    if ((master_socket + 1) > num_sockets)
	num_sockets = master_socket + 1;

    return (int) master_socket;	/* Good */

}				/* get_listen_socket */

static const char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

/*	Procedure: Set the current and last year strings and date integer
 *	-----------------------------------------------------------------
 *
 *	Bug:
 *		This code is for sorting listings by date, if that option
 *		is selected in Lynx, and doesn't take into account time
 *		zones or ensure resetting at midnight, so the sort may not
 *		be perfect, but the actual date isn't changed in the display,
 *		i.e., the date is still correct. - FM
 */
static void set_years_and_date(void)
{
    char day[8], month[8], date[12];
    time_t NowTime;
    int i;
    char *printable;

    NowTime = time(NULL);
    printable = ctime(&NowTime);
    LYStrNCpy(day, printable + 8, 2);
    if (day[0] == ' ') {
	day[0] = '0';
    }
    LYStrNCpy(month, printable + 4, 3);
    for (i = 0; i < 12; i++) {
	if (!strcasecomp(month, months[i])) {
	    break;
	}
    }
    i++;
    sprintf(date, "9999%02d%.2s", i, day);
    TheDate = atoi(date);
    LYStrNCpy(ThisYear, printable + 20, 4);
    sprintf(LastYear, "%d", (atoi(ThisYear) - 1));
    HaveYears = TRUE;
}

typedef struct _EntryInfo {
    char *filename;
    char *linkname;		/* symbolic link, if any */
    char *type;
    char *date;
    off_t size;
    BOOLEAN display;		/* show this entry? */
#ifdef LONG_LIST
    unsigned long file_links;
    char *file_mode;
    char *file_user;
    char *file_group;
#endif
} EntryInfo;

static void free_entryinfo_struct_contents(EntryInfo *entry_info)
{
    if (entry_info) {
	FREE(entry_info->filename);
	FREE(entry_info->linkname);
	FREE(entry_info->type);
	FREE(entry_info->date);
    }
    /* dont free the struct */
}

/*
 * is_ls_date() --
 *	Return TRUE if s points to a string of the form:
 *		"Sep  1  1990 " or
 *		"Sep 11 11:59 " or
 *		"Dec 12 1989  " or
 *		"FCv 23 1990  " ...
 */
static BOOLEAN is_ls_date(char *s)
{
    /* must start with three alpha characters */
    if (!isalpha(UCH(*s++)) || !isalpha(UCH(*s++)) || !isalpha(UCH(*s++)))
	return FALSE;

    /* space or HT_NON_BREAK_SPACE */
    if (!(*s == ' ' || *s == HT_NON_BREAK_SPACE)) {
	return FALSE;
    }
    s++;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* space */
    if (*s++ != ' ')
	return FALSE;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* colon or digit */
    if (!(*s == ':' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* space */
    if (*s != ' ')
	return FALSE;

    return TRUE;
}				/* is_ls_date() */

/*
 * Extract the name, size, and date from an EPLF line.  - 08-06-96 DJB
 */
static void parse_eplf_line(char *line,
			    EntryInfo *info)
{
    char *cp = line;
    char ct[26];
    off_t size;
    time_t secs;
    static time_t base;		/* time() value on this OS in 1970 */
    static int flagbase = 0;

    if (!flagbase) {
	struct tm t;

	t.tm_year = 70;
	t.tm_mon = 0;
	t.tm_mday = 0;
	t.tm_hour = 0;
	t.tm_min = 0;
	t.tm_sec = 0;
	t.tm_isdst = -1;
	base = mktime(&t);	/* could return -1 */
	flagbase = 1;
    }

    while (*cp) {
	switch (*cp) {
	case '\t':
	    StrAllocCopy(info->filename, cp + 1);
	    return;
	case 's':
	    size = 0;
	    while (*(++cp) && (*cp != ','))
		size = (size * 10) + (off_t) (*cp - '0');
	    info->size = size;
	    break;
	case 'm':
	    secs = 0;
	    while (*(++cp) && (*cp != ','))
		secs = (secs * 10) + (*cp - '0');
	    secs += base;	/* assumes that time_t is #seconds */
	    LYStrNCpy(ct, ctime(&secs), 24);
	    StrAllocCopy(info->date, ct);
	    break;
	case '/':
	    StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
	    /* FALLTHRU */
	default:
	    while (*cp) {
		if (*cp++ == ',')
		    break;
	    }
	    break;
	}
    }
}				/* parse_eplf_line */

/*
 * Extract the name, size, and date from an ls -l line.
 */
static void parse_ls_line(char *line,
			  EntryInfo *entry)
{
#ifdef LONG_LIST
    char *next;
    char *cp;
#endif
    int i, j;
    off_t base = 1;
    off_t size_num = 0;

    for (i = (int) strlen(line) - 1;
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i - 12]));
	 i--) {
	;			/* null body */
    }
    line[i] = '\0';
    if (i > 13) {
	StrAllocCopy(entry->date, &line[i - 12]);
	/* replace the 4th location with nbsp if it is a space or zero */
	if (entry->date[4] == ' ' || entry->date[4] == '0')
	    entry->date[4] = HT_NON_BREAK_SPACE;
	/* make sure year or time is flush right */
	if (entry->date[11] == ' ') {
	    for (j = 11; j > 6; j--) {
		entry->date[j] = entry->date[j - 1];
	    }
	}
    }
    j = i - 14;
    while (isdigit(UCH(line[j]))) {
	size_num += ((off_t) (line[j] - '0') * base);
	base *= 10;
	j--;
    }
    entry->size = size_num;
    StrAllocCopy(entry->filename, &line[i + 1]);

#ifdef LONG_LIST
    line[j] = '\0';

    /*
     * Extract the file-permissions, as a string.
     */
    if ((cp = StrChr(line, ' ')) != 0) {
	if ((cp - line) == 10) {
	    *cp = '\0';
	    StrAllocCopy(entry->file_mode, line);
	    *cp = ' ';
	}

	/*
	 * Next is the link-count.
	 */
	next = 0;
	entry->file_links = (unsigned long) strtol(cp, &next, 10);
	if (next == 0 || *next != ' ') {
	    entry->file_links = 0;
	    next = cp;
	} else {
	    cp = next;
	}
	/*
	 * Next is the user-name.
	 */
	while (isspace(UCH(*cp)))
	    ++cp;
	if ((next = StrChr(cp, ' ')) != 0)
	    *next = '\0';
	if (*cp != '\0')
	    StrAllocCopy(entry->file_user, cp);
	/*
	 * Next is the group-name (perhaps).
	 */
	if (next != NULL) {
	    cp = (next + 1);
	    while (isspace(UCH(*cp)))
		++cp;
	    if ((next = StrChr(cp, ' ')) != 0)
		*next = '\0';
	    if (*cp != '\0')
		StrAllocCopy(entry->file_group, cp);
	}
    }
#endif
}

/*
 * Extract the name and size info and whether it refers to a directory from a
 * LIST line in "dls" format.
 */
static void parse_dls_line(char *line,
			   EntryInfo *entry_info,
			   char **pspilledname)
{
    short j;
    int base = 1;
    off_t size_num = 0;
    int len;
    char *cps = NULL;

    /* README              763  Information about this server\0
       bin/                  -  \0
       etc/                  =  \0
       ls-lR                 0  \0
       ls-lR.Z               3  \0
       pub/                  =  Public area\0
       usr/                  -  \0
       morgan               14  -> ../real/morgan\0
       TIMIT.mostlikely.Z\0
       79215    \0
     */

    len = (int) strlen(line);
    if (len == 0) {
	FREE(*pspilledname);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(line);
    if (*cps == '\0') {		/* only a filename, save it and return. */
	StrAllocCopy(*pspilledname, line);
	entry_info->display = FALSE;
	return;
    }
    if (len < 24 || line[23] != ' ' ||
	(isspace(UCH(line[0])) && !*pspilledname)) {
	/* this isn't the expected "dls" format! */
	if (!isspace(UCH(line[0])))
	    *cps = '\0';
	if (*pspilledname && !*line) {
	    entry_info->filename = *pspilledname;
	    *pspilledname = NULL;
	    if (entry_info->filename[strlen(entry_info->filename) - 1] == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	} else {
	    StrAllocCopy(entry_info->filename, line);
	    if (cps != line && *(cps - 1) == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	    FREE(*pspilledname);
	}
	return;
    }

    j = 22;
    if (line[j] == '=' || line[j] == '-') {
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    } else {
	while (isdigit(UCH(line[j]))) {
	    size_num += (line[j] - '0') * base;
	    base *= 10;
	    j--;
	}
    }
    entry_info->size = size_num;

    cps = LYSkipBlanks(&line[23]);
    if (!StrNCmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, ENTRY_IS_SYMBOLIC_LINK);
	StrAllocCopy(entry_info->linkname, LYSkipBlanks(cps + 3));
	entry_info->size = 0;	/* don't display size */
    }

    if (j > 0)
	line[j] = '\0';

    LYTrimTrailing(line);

    len = (int) strlen(line);
    if (len == 0 && *pspilledname && **pspilledname) {
	line = *pspilledname;
	len = (int) strlen(*pspilledname);
    }
    if (len > 0 && line[len - 1] == '/') {
	/*
	 * It's a dir, remove / and mark it as such.
	 */
	if (len > 1)
	    line[len - 1] = '\0';
	if (!entry_info->type)
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    }

    StrAllocCopy(entry_info->filename, line);
    FREE(*pspilledname);
}				/* parse_dls_line() */

/*
 * parse_vms_dir_entry()
 *	Format the name, date, and size from a VMS LIST line
 *	into the EntryInfo structure - FM
 */
static void parse_vms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    int i, j;
    off_t ialloc;
    char *cp, *cpd, *cps, date[16];
    const char *sp = " ";

    /* Get rid of blank lines, and information lines.  Valid lines have the ';'
     * version number token.
     */
    if (!strlen(line) || (cp = StrChr(line, ';')) == NULL) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name at VMS version number. */
    *cp++ = '\0';
    StrAllocCopy(entry_info->filename, line);

    /* Cast VMS non-README file and directory names to lowercase. */
    if (strstr(entry_info->filename, "READ") == NULL) {
	LYLowerCase(entry_info->filename);
	i = (int) strlen(entry_info->filename);
    } else {
	i = (int) ((strstr(entry_info->filename, "READ")
		    - entry_info->filename)
		   + 4);
	if (!StrNCmp(&entry_info->filename[i], "ME", 2)) {
	    i += 2;
	    while (entry_info->filename[i] && entry_info->filename[i] != '.') {
		i++;
	    }
	} else if (!StrNCmp(&entry_info->filename[i], ".ME", 3)) {
	    i = (int) strlen(entry_info->filename);
	} else {
	    i = 0;
	}
	LYLowerCase(entry_info->filename + i);
    }

    /* Uppercase terminal .z's or _z's. */
    if ((--i > 2) &&
	entry_info->filename[i] == 'z' &&
	(entry_info->filename[i - 1] == '.' ||
	 entry_info->filename[i - 1] == '_'))
	entry_info->filename[i] = 'Z';

    /* Convert any tabs in rest of line to spaces. */
    cps = cp - 1;
    while ((cps = StrChr(cps + 1, '\t')) != NULL)
	*cps = ' ';

    /* Collapse serial spaces. */
    i = 0;
    j = 1;
    cps = cp;
    while (cps[j] != '\0') {
	if (cps[i] == ' ' && cps[j] == ' ')
	    j++;
	else
	    cps[++i] = cps[j++];
    }
    cps[++i] = '\0';

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    if ((cpd = StrChr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd - 1))) &&
	isalpha(UCH(*(cpd + 1))) && *(cpd + 4) == '-') {

	/* Month */
	*(cpd + 2) = (char) TOLOWER(*(cpd + 2));
	*(cpd + 3) = (char) TOLOWER(*(cpd + 3));
	sprintf(date, "%.3s ", cpd + 1);

	/* Day */
	if (isdigit(UCH(*(cpd - 2))))
	    sprintf(date + 4, "%.2s ", cpd - 2);
	else
	    sprintf(date + 4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd - 1);

	/* Time or Year */
	if (!StrNCmp(ThisYear, cpd + 5, 4) &&
	    strlen(cpd) > 15 && *(cpd + 12) == ':') {
	    sprintf(date + 7, "%.5s", cpd + 10);
	} else {
	    sprintf(date + 7, " %.4s", cpd + 5);
	}

	StrAllocCopy(entry_info->date, date);
    }

    /* Track down the size */
    if ((cpd = StrChr(cp, '/')) != NULL) {
	/* Appears be in used/allocated format */
	cps = cpd;
	while (isdigit(UCH(*(cps - 1))))
	    cps--;
	if (cps < cpd)
	    *cpd = '\0';
	entry_info->size = LYatoll(cps);
	cps = cpd + 1;
	while (isdigit(UCH(*cps)))
	    cps++;
	*cps = '\0';
	ialloc = LYatoll(cpd + 1);
	/* Check if used is in blocks or bytes */
	if (entry_info->size <= ialloc)
	    entry_info->size *= 512;

    } else if (strtok(cp, sp) != NULL) {
	/* We just initialized on the version number */
	/* Now let's hunt for a lone, size number    */
	while ((cps = strtok(NULL, sp)) != NULL) {
	    cpd = cps;
	    while (isdigit(UCH(*cpd)))
		cpd++;
	    if (*cpd == '\0') {
		/* Assume it's blocks */
		entry_info->size = (LYatoll(cps) * 512);
		break;
	    }
	}
    }

    TRACE_ENTRY("VMS", entry_info);
    return;
}				/* parse_vms_dir_entry() */

/*
 * parse_ms_windows_dir_entry() --
 *	Format the name, date, and size from an MS_WINDOWS LIST line into
 *	the EntryInfo structure (assumes Chameleon NEWT format). - FM
 */
static void parse_ms_windows_dir_entry(char *line,
				       EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    cpd = cps;
    StrAllocCopy(entry_info->filename, cp);

    /* Track down the size */
    if (cps < end) {
	cps = LYSkipBlanks(cps);
	cpd = LYSkipNonBlanks(cps);
	*cpd++ = '\0';
	if (isdigit(UCH(*cps))) {
	    entry_info->size = LYatoll(cps);
	} else {
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	}
    } else {
	StrAllocCopy(entry_info->type, "");
    }

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    if (cpd < end) {
	cpd = LYSkipBlanks(cpd);
	if (strlen(cpd) > 17) {
	    *(cpd + 6) = '\0';	/* Month and Day */
	    *(cpd + 11) = '\0';	/* Year */
	    *(cpd + 17) = '\0';	/* Time */
	    if (strcmp(ThisYear, cpd + 7))
		/* Not this year, so show the year */
		sprintf(date, "%.6s  %.4s", cpd, (cpd + 7));
	    else
		/* Is this year, so show the time */
		sprintf(date, "%.6s %.5s", cpd, (cpd + 12));
	    StrAllocCopy(entry_info->date, date);
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
		entry_info->date[4] = HT_NON_BREAK_SPACE;
	    }
	}
    }

    TRACE_ENTRY("MS Windows", entry_info);
    return;
}				/* parse_ms_windows_dir_entry */

/*
 * parse_windows_nt_dir_entry() --
 *	Format the name, date, and size from a WINDOWS_NT LIST line into
 *	the EntryInfo structure (assumes Chameleon NEWT format). - FM
 */
#ifdef NOTDEFINED
static void parse_windows_nt_dir_entry(char *line,
				       EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);
    int i;

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cpd = cp;
    cps = LYSkipNonBlanks(end - 1);
    cp = (cps + 1);
    if (!strcmp(cp, ".") || !strcmp(cp, "..")) {
	entry_info->display = FALSE;
	return;
    }
    StrAllocCopy(entry_info->filename, cp);
    if (cps < cpd)
	return;
    *cp = '\0';
    end = cp;

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Cut out the date. */
    cp = cps = cpd;
    cps = LYSkipNonBlanks(cps);
    *cps++ = '\0';
    if (cps > end) {
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipBlanks(cps);
    cpd = LYSkipNonBlanks(cps);
    *cps++ = '\0';
    if (cps > end || cpd == cps || strlen(cpd) < 7) {
	entry_info->display = FALSE;
	return;
    }
    if (strlen(cp) == 8 &&
	isdigit(*cp) && isdigit(*(cp + 1)) && *(cp + 2) == '-' &&
	isdigit(*(cp + 3)) && isdigit(*(cp + 4)) && *(cp + 5) == '-') {
	*(cp + 2) = '\0';	/* Month */
	i = atoi(cp) - 1;
	*(cp + 5) = '\0';	/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp + 3));
	if (date[4] == '0')
	    date[4] = ' ';
	cp += 6;		/* Year */
	if (strcmp((ThisYear + 2), cp)) {
	    /* Not this year, so show the year */
	    if (atoi(cp) < 70) {
		sprintf(&date[6], "  20%.2s", cp);
	    } else {
		sprintf(&date[6], "  19%.2s", cp);
	    }
	} else {
	    /* Is this year, so show the time */
	    *(cpd + 2) = '\0';	/* Hour */
	    i = atoi(cpd);
	    if (*(cpd + 5) == 'P' || *(cpd + 5) == 'p')
		i += 12;
	    sprintf(&date[6], " %02d:%.2s", i, (cpd + 3));
	}
	StrAllocCopy(entry_info->date, date);
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
	    entry_info->date[4] = HT_NON_BREAK_SPACE;
	}
    }

    /* Track down the size */
    if (cps < end) {
	cps = LYSkipBlanks(cps);
	cpd = LYSkipNonBlanks(cps);
	*cpd = '\0';
	if (isdigit(*cps)) {
	    entry_info->size = LYatoll(cps);
	} else {
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	}
    } else {
	StrAllocCopy(entry_info->type, "");
    }

    /* Wrap it up */
    CTRACE((tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
    return;
}				/* parse_windows_nt_dir_entry */
#endif /* NOTDEFINED */

/*
 * parse_cms_dir_entry() --
 *	Format the name, date, and size from a VM/CMS line into
 *	the EntryInfo structure. - FM
 */
static void parse_cms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);
    int RecordLength = 0;
    int Records = 0;
    int i;

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    StrAllocCopy(entry_info->filename, cp);
    if (StrChr(entry_info->filename, '.') != NULL)
	/* If we already have a dot, we did an NLST. */
	return;
    cp = LYSkipBlanks(cps);
    if (!(*cp)) {
	/* If we don't have more, we've misparsed. */
	FREE(entry_info->filename);
	FREE(entry_info->type);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    if ((0 == strcasecomp(cp, "DIR")) && (cp - line) > 17) {
	/* It's an SFS directory. */
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	entry_info->size = 0;
    } else {
	/* It's a file. */
	cp--;
	*cp = '.';
	StrAllocCat(entry_info->filename, cp);

	/* Track down the VM/CMS RECFM or type. */
	cp = cps;
	if (cp < end) {
	    cp = LYSkipBlanks(cp);
	    cps = LYSkipNonBlanks(cp);
	    *cps++ = '\0';
	    /* Check cp here, if it's relevant someday. */
	}
    }

    /* Track down the record length or dash. */
    cp = cps;
    if (cp < end) {
	cp = LYSkipBlanks(cp);
	cps = LYSkipNonBlanks(cp);
	*cps++ = '\0';
	if (isdigit(UCH(*cp))) {
	    RecordLength = atoi(cp);
	}
    }

    /* Track down the number of records or the dash. */
    cp = cps;
    if (cps < end) {
	cp = LYSkipBlanks(cp);
	cps = LYSkipNonBlanks(cp);
	*cps++ = '\0';
	if (isdigit(UCH(*cp))) {
	    Records = atoi(cp);
	}
	if (Records > 0 && RecordLength > 0) {
	    /* Compute an approximate size. */
	    entry_info->size = ((off_t) Records * (off_t) RecordLength);
	}
    }

    /* Set the years and date, if we don't have them yet. */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    cpd = cps;
    if (((cps < end) &&
	 (cps = StrChr(cpd, ':')) != NULL) &&
	(cps < (end - 3) &&
	 isdigit(UCH(*(cps + 1))) && isdigit(UCH(*(cps + 2))) && *(cps + 3) == ':')) {
	cps += 3;
	*cps = '\0';
	if ((cps - cpd) >= 14) {
	    cpd = (cps - 14);
	    *(cpd + 2) = '\0';	/* Month */
	    *(cpd + 5) = '\0';	/* Day */
	    *(cpd + 8) = '\0';	/* Year */
	    cps -= 5;		/* Time */
	    if (*cpd == ' ')
		*cpd = '0';
	    i = atoi(cpd) - 1;
	    sprintf(date, "%.3s %.2s", months[i], (cpd + 3));
	    if (date[4] == '0')
		date[4] = ' ';
	    cpd += 6;		/* Year */
	    if (strcmp((ThisYear + 2), cpd)) {
		/* Not this year, so show the year. */
		if (atoi(cpd) < 70) {
		    sprintf(&date[6], "  20%.2s", cpd);
		} else {
		    sprintf(&date[6], "  19%.2s", cpd);
		}
	    } else {
		/* Is this year, so show the time. */
		*(cps + 2) = '\0';	/* Hour */
		i = atoi(cps);
		sprintf(&date[6], " %02d:%.2s", i, (cps + 3));
	    }
	    StrAllocCopy(entry_info->date, date);
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
		entry_info->date[4] = HT_NON_BREAK_SPACE;
	    }
	}
    }

    TRACE_ENTRY("VM/CMS", entry_info);
    return;
}				/* parse_cms_dir_entry */

/*
 * Given a line of LIST/NLST output in entry, return results and a file/dir
 * name in entry_info struct
 *
 * If first is true, this is the first name in a directory.
 */
static EntryInfo *parse_dir_entry(char *entry,
				  BOOLEAN *first,
				  char **pspilledname)
{
    EntryInfo *entry_info;
    int i;
    int len;
    BOOLEAN remove_size = FALSE;
    char *cp;

    entry_info = typecalloc(EntryInfo);

    if (entry_info == NULL)
	outofmem(__FILE__, "parse_dir_entry");

    assert(entry_info != NULL);

    entry_info->display = TRUE;

    switch (server_type) {
    case DLS_SERVER:

	/*
	 * Interpret and edit LIST output from a Unix server in "dls" format. 
	 * This one must have claimed to be Unix in order to get here; if the
	 * first line looks fishy, we revert to Unix and hope that fits better
	 * (this recovery is untested).  - kw
	 */

	if (*first) {
	    len = (int) strlen(entry);
	    if (!len || entry[0] == ' ' ||
		(len >= 24 && entry[23] != ' ') ||
		(len < 24 && StrChr(entry, ' '))) {
		server_type = UNIX_SERVER;
		CTRACE((tfp,
			"HTFTP: Falling back to treating as Unix server.\n"));
	    } else {
		*first = FALSE;
	    }
	}

	if (server_type == DLS_SERVER) {
	    /* if still unchanged... */
	    parse_dls_line(entry, entry_info, pspilledname);

	    if (isEmpty(entry_info->filename)) {
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    if (!strcmp(entry_info->filename, "..") ||
		!strcmp(entry_info->filename, "."))
		entry_info->display = FALSE;
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}
	/* fall through if server_type changed for *first == TRUE ! */
    case UNIX_SERVER:
    case PETER_LEWIS_SERVER:
    case MACHTEN_SERVER:
    case MSDOS_SERVER:
    case WINDOWS_NT_SERVER:
    case WINDOWS_2K_SERVER:
    case APPLESHARE_SERVER:
    case NETPRESENZ_SERVER:
	/*
	 * Check for EPLF output (local times).
	 */
	if (*entry == '+') {
	    parse_eplf_line(entry, entry_info);
	    break;
	}

	/*
	 * Interpret and edit LIST output from Unix server.
	 */
	len = (int) strlen(entry);
	if (*first) {
	    /* don't gettext() this -- incoming text: */
	    if (!strcmp(entry, "can not access directory .")) {
		/*
		 * Don't reset *first, nothing real will follow.  - KW
		 */
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    *first = FALSE;
	    if (!StrNCmp(entry, "total ", 6) ||
		strstr(entry, "not available") != NULL) {
		entry_info->display = FALSE;
		return (entry_info);
	    } else if (unsure_type) {
		/* this isn't really a unix server! */
		server_type = GENERIC_SERVER;
		entry_info->display = FALSE;
		return (entry_info);
	    }
	}

	/*
	 * Check first character of ls -l output.
	 */
	if (TOUPPER(entry[0]) == 'D') {
	    /*
	     * It's a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	} else if (entry[0] == 'l') {
	    /*
	     * It's a symbolic link, does the user care about knowing if it is
	     * symbolic?  I think so since it might be a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_SYMBOLIC_LINK);
	    remove_size = TRUE;	/* size is not useful */

	    /*
	     * Strip off " -> pathname".
	     */
	    for (i = len - 1; (i > 3) &&
		 (!isspace(UCH(entry[i])) ||
		  (entry[i - 1] != '>') ||
		  (entry[i - 2] != '-') ||
		  (entry[i - 3] != ' ')); i--) ;	/* null body */
	    if (i > 3) {
		entry[i - 3] = '\0';
		StrAllocCopy(entry_info->linkname, LYSkipBlanks(entry + i));
	    }
	}
	/* link */
	parse_ls_line(entry, entry_info);

	if (!strcmp(entry_info->filename, "..") ||
	    !strcmp(entry_info->filename, "."))
	    entry_info->display = FALSE;
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case VMS_SERVER:
	/*
	 * Interpret and edit LIST output from VMS server and convert
	 * information lines to zero length.
	 */
	parse_vms_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);

	/*
	 * Trim off VMS directory extensions.
	 */
	len = (int) strlen(entry_info->filename);
	if ((len > 4) && !strcmp(&entry_info->filename[len - 4], ".dir")) {
	    entry_info->filename[len - 4] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case MS_WINDOWS_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_ms_windows_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

#ifdef NOTDEFINED
    case WINDOWS_NT_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_windows_nt_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
#endif /* NOTDEFINED */

    case CMS_SERVER:
	{
	    /*
	     * Interpret and edit LIST output from VM/CMS server and convert
	     * any information lines to zero length.
	     */
	    parse_cms_dir_entry(entry, entry_info);

	    /*
	     * Get rid of any junk lines.
	     */
	    if (!entry_info->display)
		return (entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}

    case NCSA_SERVER:
    case TCPC_SERVER:
	/*
	 * Directories identified by trailing "/" characters.
	 */
	StrAllocCopy(entry_info->filename, entry);
	len = (int) strlen(entry);
	if (entry[len - 1] == '/') {
	    /*
	     * It's a dir, remove / and mark it as such.
	     */
	    entry[len - 1] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    default:
	/*
	 * We can't tell if it is a directory since we only did an NLST :( List
	 * bad file types anyways?  NOT!
	 */
	StrAllocCopy(entry_info->filename, entry);
	return (entry_info);	/* mostly empty info */

    }				/* switch (server_type) */

#ifdef LONG_LIST
    (void) remove_size;
#else
    if (remove_size && entry_info->size) {
	entry_info->size = 0;
    }
#endif

    if (isEmpty(entry_info->filename)) {
	entry_info->display = FALSE;
	return (entry_info);
    }
    if (strlen(entry_info->filename) > 3) {
	if (((cp = strrchr(entry_info->filename, '.')) != NULL &&
	     0 == strncasecomp(cp, ".me", 3)) &&
	    (cp[3] == '\0' || cp[3] == ';')) {
	    /*
	     * Don't treat this as application/x-Troff-me if it's a Unix server
	     * but has the string "read.me", or if it's not a Unix server.  -
	     * FM
	     */
	    if ((server_type != UNIX_SERVER) ||
		(cp > (entry_info->filename + 3) &&
		 0 == strncasecomp((cp - 4), "read.me", 7))) {
		StrAllocCopy(entry_info->type, "text/plain");
	    }
	}
    }

    /*
     * Get real types eventually.
     */
    if (!entry_info->type) {
	const char *cp2;
	HTFormat format;
	HTAtom *encoding;	/* @@@@ not used at all */

	format = HTFileFormat(entry_info->filename, &encoding, &cp2);

	if (cp2 == NULL) {
	    if (!StrNCmp(HTAtom_name(format), "application", 11)) {
		cp2 = HTAtom_name(format) + 12;
		if (!StrNCmp(cp2, "x-", 2))
		    cp2 += 2;
	    } else {
		cp2 = HTAtom_name(format);
	    }
	}

	StrAllocCopy(entry_info->type, cp2);
    }

    return (entry_info);
}

static void formatDate(char target[16], EntryInfo *entry)
{
    char temp[8], month[4];
    int i;

    /*
     * Set up for sorting in reverse chronological order. - FM
     */
    if (entry->date[9] == ':') {
	strcpy(target, "9999");
	LYStrNCpy(temp, &entry->date[7], 5);
	if (temp[0] == ' ') {
	    temp[0] = '0';
	}
    } else {
	LYStrNCpy(target, &entry->date[8], 4);
	strcpy(temp, "00:00");
    }
    LYStrNCpy(month, entry->date, 3);
    for (i = 0; i < 12; i++) {
	if (!strcasecomp(month, months[i])) {
	    break;
	}
    }
    i++;
    sprintf(month, "%02d", i);
    strcat(target, month);
    StrNCat(target, &entry->date[4], 2);
    if (target[6] == ' ' || target[6] == HT_NON_BREAK_SPACE) {
	target[6] = '0';
    }

    /* If no year given, assume last year if it would otherwise be in the
     * future by more than one day.  The one day tolerance is to account for a
     * possible timezone difference. - kw
     */
    if (target[0] == '9' && atoi(target) > TheDate + 1) {
	for (i = 0; i < 4; i++) {
	    target[i] = LastYear[i];
	}
    }
    strcat(target, temp);
}

static int compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2)
{
    int status;
    char date1[16], date2[16];
    int result = strcmp(entry1->filename, entry2->filename);

    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size > entry2->size)
	    result = 1;
	else if (entry1->size < entry2->size)
	    result = -1;
	break;

    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		result = status;
	}
	break;

    case FILE_BY_DATE:
	if (entry1->date && entry2->date &&
	    strlen(entry1->date) == 12 &&
	    strlen(entry2->date) == 12) {
	    /*
	     * Set the years and date, if we don't have them yet.
	     */
	    if (!HaveYears) {
		set_years_and_date();
	    }
	    formatDate(date1, entry1);
	    formatDate(date2, entry2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		result = status;
	}
	break;

    case FILE_BY_NAME:
    default:
	break;
    }
    return result;
}

#ifdef LONG_LIST
static char *FormatStr(char **bufp,
		       char *start,
		       const char *value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*ss", (int) sizeof(fmt) - 3, start);
	HTSprintf(bufp, fmt, value);
    } else if (*bufp && !(value && *value)) {
	;
    } else if (value) {
	StrAllocCat(*bufp, value);
    }
    return *bufp;
}

static char *FormatSize(char **bufp,
			char *start,
			off_t value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*s" PRI_off_t, (int) sizeof(fmt) - 3, start);

	HTSprintf(bufp, fmt, value);
    } else {
	sprintf(fmt, "%" PRI_off_t, value);

	StrAllocCat(*bufp, fmt);
    }
    return *bufp;
}

static char *FormatNum(char **bufp,
		       char *start,
		       unsigned long value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*sld", (int) sizeof(fmt) - 3, start);
	HTSprintf(bufp, fmt, value);
    } else {
	sprintf(fmt, "%lu", value);
	StrAllocCat(*bufp, fmt);
    }
    return *bufp;
}

static void FlushParse(HTStructured * target, char **buf)
{
    if (*buf && **buf) {
	PUTS(*buf);
	**buf = '\0';
    }
}

static void LYListFmtParse(const char *fmtstr,
			   EntryInfo *data,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    BOOL is_directory = (BOOL) (data->file_mode != 0 &&
				(TOUPPER(data->file_mode[0]) == 'D'));
    BOOL is_symlinked = (BOOL) (data->file_mode != 0 &&
				(TOUPPER(data->file_mode[0]) == 'L'));
    BOOL remove_size = (BOOL) (is_directory || is_symlinked);

    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    while (*s) {
	start = s;
	while (*s) {
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    StrAllocCat(buf, start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    StrAllocCat(buf, start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    FlushParse(target, &buf);
	    HTDirEntry(target, tail, data->filename);
	    FormatStr(&buf, start, data->filename);
	    PUTS(buf);
	    END(HTML_A);
	    if (buf != 0)
		*buf = '\0';
	    if (c != 'A' && data->linkname != 0) {
		PUTS(" -> ");
		PUTS(data->linkname);
	    }
	    break;

	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (is_directory) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else if (is_symlinked) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_SYMBOLIC_LINK);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;

		format = HTFileFormat(data->filename, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!StrNCmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!StrNCmp(cp2, "x-", 2))
				cp2 += 2;
			} else {
			    cp2 = HTAtom_name(format);
			}
		    }
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;

	case 'd':		/* date */
	    if (data->date) {
		FormatStr(&buf, start, data->date);
	    } else {
		FormatStr(&buf, start, " * ");
	    }
	    break;

	case 's':		/* size in bytes */
	    FormatSize(&buf, start, data->size);
	    break;

	case 'K':		/* size in Kilobytes but not for directories */
	    if (remove_size) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    /* FIXME - this is inconsistent with HTFile.c, but historical */
	    if (data->size < 1024) {
		FormatSize(&buf, start, data->size);
		StrAllocCat(buf, " bytes");
	    } else {
		FormatSize(&buf, start, data->size / 1024);
		StrAllocCat(buf, "Kb");
	    }
	    break;

#ifdef LONG_LIST
	case 'p':		/* unix-style permission bits */
	    FormatStr(&buf, start, NonNull(data->file_mode));
	    break;

	case 'o':		/* owner */
	    FormatStr(&buf, start, NonNull(data->file_user));
	    break;

	case 'g':		/* group */
	    FormatStr(&buf, start, NonNull(data->file_group));
	    break;

	case 'l':		/* link count */
	    FormatNum(&buf, start, data->file_links);
	    break;
#endif

	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;

	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
	}

	s++;
    }
    if (buf) {
	LYTrimTrailing(buf);
	FlushParse(target, &buf);
	FREE(buf);
    }
    PUTC('\n');
    FREE(str);
}
#endif /* LONG_LIST */

/*	Read a directory into an hypertext object from the data socket
 *	--------------------------------------------------------------
 *
 * On entry,
 *	anchor		Parent anchor to link the this node to
 *	address		Address of the directory
 * On exit,
 *	returns		HT_LOADED if OK
 *			<0 if error.
 */
static int read_directory(HTParentAnchor *parent,
			  const char *address,
			  HTFormat format_out,
			  HTStream *sink)
{
    int status;
    BOOLEAN WasInterrupted = FALSE;
    HTStructured *target = HTML_new(parent, format_out, sink);
    char *filename = HTParse(address, "", PARSE_PATH + PARSE_PUNCTUATION);
    EntryInfo *entry_info;
    BOOLEAN first = TRUE;
    char *lastpath = NULL;	/* prefix for link, either "" (for root) or xxx  */
    BOOL tildeIsTop = FALSE;

#ifndef LONG_LIST
    char string_buffer[64];
#endif

    _HTProgress(gettext("Receiving FTP directory."));

    /*
     * Force the current Date and Year (TheDate, ThisYear, and LastYear) to be
     * recalculated for each directory request.  Otherwise we have a problem
     * with long-running sessions assuming the wrong date for today.  - kw
     */
    HaveYears = FALSE;
    /*
     * Check whether we always want the home directory treated as Welcome.  -
     * FM
     */
    if (server_type == VMS_SERVER)
	tildeIsTop = TRUE;

    /*
     * This should always come back FALSE, since the flag is set only for local
     * directory listings if LONG_LIST was defined on compilation, but we could
     * someday set up an equivalent listing for Unix ftp servers.  - FM
     */
    (void) HTDirTitles(target, parent, format_out, tildeIsTop);

    data_read_pointer = data_write_pointer = data_buffer;

    if (*filename == '\0') {	/* Empty filename: use root. */
	StrAllocCopy(lastpath, "/");
    } else if (!strcmp(filename, "/")) {	/* Root path. */
	StrAllocCopy(lastpath, "/foo/..");
    } else {
	char *p = strrchr(filename, '/');	/* Find the lastslash. */
	char *cp;

	if (server_type == CMS_SERVER) {
	    StrAllocCopy(lastpath, filename);	/* Use absolute path for CMS. */
	} else {
	    StrAllocCopy(lastpath, p + 1);	/* Take slash off the beginning. */
	}
	if ((cp = strrchr(lastpath, ';')) != NULL) {	/* Trim type= param. */
	    if (!strncasecomp((cp + 1), "type=", 5)) {
		if (TOUPPER(*(cp + 6)) == 'D' ||
		    TOUPPER(*(cp + 6)) == 'A' ||
		    TOUPPER(*(cp + 6)) == 'I')
		    *cp = '\0';
	    }
	}
    }
    FREE(filename);

    {
	HTBTree *bt = HTBTree_new((HTComparer) compare_EntryInfo_structs);
	int ic;
	HTChunk *chunk = HTChunkCreate(128);
	int BytesReceived = 0;
	int BytesReported = 0;
	char NumBytes[64];
	char *spilledname = NULL;

	PUTC('\n');		/* prettier LJM */
	for (ic = 0; ic != EOF;) {	/* For each entry in the directory */
	    HTChunkClear(chunk);

	    if (HTCheckForInterrupt()) {
		CTRACE((tfp,
			"read_directory: interrupted after %d bytes\n",
			BytesReceived));
		WasInterrupted = TRUE;
		if (BytesReceived) {
		    goto unload_btree;	/* unload btree */
		} else {
		    ABORT_TARGET;
		    HTBTreeAndObject_free(bt);
		    FREE(spilledname);
		    HTChunkFree(chunk);
		    return HT_INTERRUPTED;
		}
	    }

	    /*   read directory entry
	     */
	    interrupted_in_next_data_char = FALSE;
	    for (;;) {		/* Read in one line as filename */
		ic = NEXT_DATA_CHAR;
	      AgainForMultiNet:
		if (interrupted_in_next_data_char) {
		    CTRACE((tfp,
			    "read_directory: interrupted_in_next_data_char after %d bytes\n",
			    BytesReceived));
		    WasInterrupted = TRUE;
		    if (BytesReceived) {
			goto unload_btree;	/* unload btree */
		    } else {
			ABORT_TARGET;
			HTBTreeAndObject_free(bt);
			FREE(spilledname);
			HTChunkFree(chunk);
			return HT_INTERRUPTED;
		    }
		} else if ((char) ic == CR || (char) ic == LF) {	/* Terminator? */
		    if (chunk->size != 0) {	/* got some text */
			/* Deal with MultiNet's wrapping of long lines */
			if (server_type == VMS_SERVER) {
			    /* Deal with MultiNet's wrapping of long lines - F.M. */
			    if (data_read_pointer < data_write_pointer &&
				*(data_read_pointer + 1) == ' ')
				data_read_pointer++;
			    else if (data_read_pointer >= data_write_pointer) {
				status = NETREAD(data_soc, data_buffer,
						 DATA_BUFFER_SIZE);
				if (status == HT_INTERRUPTED) {
				    interrupted_in_next_data_char = 1;
				    goto AgainForMultiNet;
				}
				if (status <= 0) {
				    ic = EOF;
				    break;
				}
				data_write_pointer = data_buffer + status;
				data_read_pointer = data_buffer;
				if (*data_read_pointer == ' ')
				    data_read_pointer++;
				else
				    break;
			    } else
				break;
			} else
			    break;	/* finish getting one entry */
		    }
		} else if (ic == EOF) {
		    break;	/* End of file */
		} else {
		    HTChunkPutc(chunk, UCH(ic));
		}
	    }
	    HTChunkTerminate(chunk);

	    BytesReceived += chunk->size;
	    if (BytesReceived > BytesReported + 1024) {
#ifdef _WINDOWS
		sprintf(NumBytes, gettext("Transferred %d bytes (%5d)"),
			BytesReceived, ws_read_per_sec);
#else
		sprintf(NumBytes, TRANSFERRED_X_BYTES, BytesReceived);
#endif
		HTProgress(NumBytes);
		BytesReported = BytesReceived;
	    }

	    if (ic == EOF && chunk->size == 1)
		/* 1 means empty: includes terminating 0 */
		break;
	    CTRACE((tfp, "HTFTP: Line in %s is %s\n",
		    lastpath, chunk->data));

	    entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
	    if (entry_info->display) {
		FREE(spilledname);
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    } else {
		free_entryinfo_struct_contents(entry_info);
		FREE(entry_info);
	    }

	}			/* next entry */

      unload_btree:

	HTChunkFree(chunk);
	FREE(spilledname);

	/* print out the handy help message if it exists :) */
	if (help_message_cache_non_empty()) {
	    START(HTML_PRE);
	    START(HTML_HR);
	    PUTC('\n');
	    PUTS(help_message_cache_contents());
	    init_help_message_cache();	/* to free memory */
	    START(HTML_HR);
	    PUTC('\n');
	} else {
	    START(HTML_PRE);
	    PUTC('\n');
	}

	/* Run through tree printing out in order
	 */
	{
#ifndef LONG_LIST
#ifdef SH_EX			/* 1997/10/18 (Sat) 14:14:28 */
	    char *p, name_buff[256];
	    int name_len, dot_len;

#define	FNAME_WIDTH	30
#define	FILE_GAP	1

#endif
	    int i;
#endif
	    HTBTElement *ele;

	    for (ele = HTBTree_next(bt, NULL);
		 ele != NULL;
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (EntryInfo *) HTBTree_object(ele);

#ifdef LONG_LIST
		LYListFmtParse(ftp_format,
			       entry_info,
			       target,
			       lastpath);
#else
		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else {
		    PUTS("     * ");
		}

		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 16; i++)
			PUTC(entry_info->type[i]);
		    for (; i < 17; i++)
			PUTC(' ');
		}
		/* start the anchor */
		HTDirEntry(target, lastpath, entry_info->filename);
#ifdef SH_EX			/* 1997/10/18 (Sat) 16:00 */
		name_len = strlen(entry_info->filename);

		sprintf(name_buff, "%-*s", FNAME_WIDTH, entry_info->filename);

		if (name_len < FNAME_WIDTH) {
		    dot_len = FNAME_WIDTH - FILE_GAP - name_len;
		    if (dot_len > 0) {
			p = name_buff + name_len + 1;
			while (dot_len-- > 0)
			    *p++ = '.';
		    }
		} else {
		    name_buff[FNAME_WIDTH] = '\0';
		}

		PUTS(name_buff);
#else
		PUTS(entry_info->filename);
#endif
		END(HTML_A);

		if (entry_info->size) {
#ifdef SH_EX			/* 1998/02/02 (Mon) 16:34:52 */
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "%6ld bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "%6ld Kb",
				entry_info->size / 1024);
#else
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %lu bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %luKb",
				entry_info->size / 1024);
#endif
		    PUTS(string_buffer);
		} else if (entry_info->linkname != 0) {
		    PUTS(" -> ");
		    PUTS(entry_info->linkname);
		}

		PUTC('\n');	/* end of this entry */
#endif

		free_entryinfo_struct_contents(entry_info);
	    }
	}
	END(HTML_PRE);
	END(HTML_BODY);
	FREE_TARGET;
	HTBTreeAndObject_free(bt);
    }

    FREE(lastpath);

    if (WasInterrupted || data_soc != -1) {	/* should always be true */
	/*
	 * Without closing the data socket first, the response(0) later may
	 * hang.  Some servers expect the client to fin/ack the close of the
	 * data connection before proceeding with the conversation on the
	 * control connection.  - kw
	 */
	CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	status = NETCLOSE(data_soc);
	if (status == -1)
	    HTInetStatus("close");	/* Comment only */
	data_soc = -1;
    }

    if (WasInterrupted || HTCheckForInterrupt()) {
	_HTProgress(TRANSFER_INTERRUPTED);
    }
    return HT_LOADED;
}

/*
 * Setup an FTP connection.
 */
static int setup_connection(const char *name,
			    HTParentAnchor *anchor)
{
    int retry;			/* How many times tried? */
    int status = HT_NO_CONNECTION;

    CTRACE((tfp, "setup_connection(%s)\n", name));

    /* set use_list to NOT since we don't know what kind of server
     * this is yet.  And set the type to GENERIC
     */
    use_list = FALSE;
    server_type = GENERIC_SERVER;
    Broken_RETR = FALSE;

#ifdef INET6
    Broken_EPSV = FALSE;
#endif

    for (retry = 0; retry < 2; retry++) {	/* For timed out/broken connections */
	status = get_connection(name, anchor);
	if (status < 0) {
	    break;
	}

	if (!ftp_local_passive) {
	    status = get_listen_socket();
	    if (status < 0) {
		NETCLOSE(control->socket);
		control->socket = -1;
#ifdef INET6
		if (have_socket)
		    (void) close_master_socket();
#else
		close_master_socket();
#endif /* INET6 */
		/* HT_INTERRUPTED would fall through, if we could interrupt
		   somehow in the middle of it, which we currently can't. */
		break;
	    }
#ifdef REPEAT_PORT
	    /*  Inform the server of the port number we will listen on
	     */
	    status = response(port_command);
	    if (status == HT_INTERRUPTED) {
		CTRACE((tfp, "HTFTP: Interrupted in response (port_command)\n"));
		_HTProgress(CONNECTION_INTERRUPTED);
		NETCLOSE(control->socket);
		control->socket = -1;
		close_master_socket();
		status = HT_INTERRUPTED;
		break;
	    }
	    if (status != 2) {	/* Could have timed out */
		if (status < 0)
		    continue;	/* try again - net error */
		status = -status;	/* bad reply */
		break;
	    }
	    CTRACE((tfp, "HTFTP: Port defined.\n"));
#endif /* REPEAT_PORT */
	} else {		/* Tell the server to be passive */
	    char *command = NULL;
	    const char *p = "?";
	    int h0, h1, h2, h3, p0, p1;		/* Parts of reply */

#ifdef INET6
	    char dst[LINE_LENGTH + 1];
#endif

	    data_soc = status;

#ifdef INET6
	    /* see RFC 2428 */
	    if (Broken_EPSV)
		status = 1;
	    else
		status = send_cmd_1(p = "EPSV");
	    if (status < 0)	/* retry or Bad return */
		continue;
	    else if (status != 2) {
		status = send_cmd_1(p = "PASV");
		if (status < 0) {	/* retry or Bad return */
		    continue;
		} else if (status != 2) {
		    status = -status;	/* bad reply */
		    break;
		}
	    }

	    if (strcmp(p, "PASV") == 0) {
		for (p = response_text; *p && *p != ','; p++) {
		    ;		/* null body */
		}

		while (--p > response_text && '0' <= *p && *p <= '9') {
		    ;		/* null body */
		}
		status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
				&h0, &h1, &h2, &h3, &p0, &p1);
		if (status < 4) {
		    fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = (PortNumber) ((p0 << 8) + p1);
		sprintf(dst, "%d.%d.%d.%d", h0, h1, h2, h3);
	    } else if (strcmp(p, "EPSV") == 0) {
		char c0, c1, c2, c3;
		struct sockaddr_storage ss;
		LY_SOCKLEN sslen;

		/*
		 * EPSV bla (|||port|)
		 */
		for (p = response_text; *p && !isspace(UCH(*p)); p++) {
		    ;		/* null body */
		}
		for ( /*nothing */ ;
		     *p && *p != '(';
		     p++) {	/*) */
		    ;		/* null body */
		}
		status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
		if (status != 5) {
		    fprintf(tfp, "HTFTP: EPSV reply has invalid format!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = (PortNumber) p0;

		sslen = (LY_SOCKLEN) sizeof(ss);
		if (getpeername(control->socket, (struct sockaddr *) &ss,
				&sslen) < 0) {
		    fprintf(tfp, "HTFTP: getpeername(control) failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		if (getnameinfo((struct sockaddr *) &ss,
				sslen,
				dst,
				(socklen_t) sizeof(dst),
				NULL, 0, NI_NUMERICHOST)) {
		    fprintf(tfp, "HTFTP: getnameinfo failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
	    }
#else
	    status = send_cmd_1("PASV");
	    if (status != 2) {
		if (status < 0)
		    continue;	/* retry or Bad return */
		status = -status;	/* bad reply */
		break;
	    }
	    for (p = response_text; *p && *p != ','; p++) {
		;		/* null body */
	    }

	    while (--p > response_text && '0' <= *p && *p <= '9') {
		;		/* null body */
	    }

	    status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
			    &h0, &h1, &h2, &h3, &p0, &p1);
	    if (status < 4) {
		fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		status = HT_NO_CONNECTION;
		break;
	    }
	    passive_port = (PortNumber) ((p0 << 8) + p1);
#endif /* INET6 */
	    CTRACE((tfp, "HTFTP: Server is listening on port %d\n",
		    passive_port));

	    /* Open connection for data:  */

#ifdef INET6
	    HTSprintf0(&command, "%s//%s:%d/", STR_FTP_URL, dst, passive_port);
#else
	    HTSprintf0(&command, "%s//%d.%d.%d.%d:%d/",
		       STR_FTP_URL, h0, h1, h2, h3, passive_port);
#endif
	    status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
	    FREE(command);

	    if (status < 0) {
		(void) HTInetStatus(gettext("connect for data"));
		NETCLOSE(data_soc);
		break;
	    }

	    CTRACE((tfp, "FTP data connected, socket %d\n", data_soc));
	}
	status = 0;
	break;			/* No more retries */

    }				/* for retries */
    CTRACE((tfp, "setup_connection returns %d\n", status));
    return status;
}

/*	Retrieve File from Server
 *	-------------------------
 *
 * On entry,
 *	name		WWW address of a file: document, including hostname
 * On exit,
 *	returns		Socket number for file if good.
 *			<0 if bad.
 */
int HTFTPLoad(const char *name,
	      HTParentAnchor *anchor,
	      HTFormat format_out,
	      HTStream *sink)
{
    BOOL isDirectory = NO;
    HTAtom *encoding = NULL;
    int status, final_status;
    int outstanding = 1;	/* outstanding control connection responses

				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;

    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n",
	    name,
	    (ftp_local_passive
	     ? "passive"
	     : "normal")));

    HTReadProgress((off_t) 0, (off_t) 0);

    status = setup_connection(name, anchor);
    if (status < 0)
	return status;		/* Failed with this code */

    /*  Ask for the file:
     */
    {
	char *filename = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
	char *fname = filename;	/* Save for subsequent free() */
	char *vmsname = NULL;
	BOOL binary;
	const char *type = NULL;
	char *types = NULL;
	char *cp;

	if (server_type == CMS_SERVER) {
	    /* If the unescaped path has a %2f, reject it as illegal. - FM */
	    if (((cp = strstr(filename, "%2")) != NULL) &&
		TOUPPER(cp[2]) == 'F') {
		FREE(fname);
		init_help_message_cache();	/* to free memory */
		NETCLOSE(control->socket);
		control->socket = -1;
		CTRACE((tfp,
			"HTFTP: Rejecting path due to illegal escaped slash.\n"));
		return -1;
	    }
	}

	if (!*filename) {
	    StrAllocCopy(filename, "/");
	    type = "D";
	} else if ((type = types = strrchr(filename, ';')) != NULL) {
	    /*
	     * Check and trim the type= parameter.  - FM
	     */
	    if (!strncasecomp((type + 1), "type=", 5)) {
		switch (TOUPPER(*(type + 6))) {
		case 'D':
		    *types = '\0';
		    type = "D";
		    break;
		case 'A':
		    *types = '\0';
		    type = "A";
		    break;
		case 'I':
		    *types = '\0';
		    type = "I";
		    break;
		default:
		    type = "";
		    break;
		}
		if (!*filename) {
		    *filename = '/';
		    *(filename + 1) = '\0';
		}
	    }
	    if (*type != '\0') {
		CTRACE((tfp, "HTFTP: type=%s\n", type));
	    }
	}
	HTUnEscape(filename);
	CTRACE((tfp, "HTFTP: UnEscaped %s\n", filename));
	if (filename[1] == '~') {
	    /*
	     * Check if translation of HOME as tilde is supported,
	     * and adjust filename if so. - FM
	     */
	    char *cp2 = NULL;
	    char *fn = NULL;

	    if ((cp2 = StrChr((filename + 1), '/')) != NULL) {
		*cp2 = '\0';
	    }
	    status = send_cmd_1("PWD");
	    if (status == 2 && response_text[5] == '/') {
		status = send_cwd(filename + 1);
		if (status == 2) {
		    StrAllocCopy(fn, (filename + 1));
		    if (cp2) {
			*cp2 = '/';
			if (fn[strlen(fn) - 1] != '/') {
			    StrAllocCat(fn, cp2);
			} else {
			    StrAllocCat(fn, (cp2 + 1));
			}
			cp2 = NULL;
		    }
		    FREE(fname);
		    fname = filename = fn;
		}
	    }
	    if (cp2) {
		*cp2 = '/';
	    }
	}
	if (strlen(filename) > 3) {
	    char *cp2;

	    if (((cp2 = strrchr(filename, '.')) != NULL &&
		 0 == strncasecomp(cp2, ".me", 3)) &&
		(cp2[3] == '\0' || cp2[3] == ';')) {
		/*
		 * Don't treat this as application/x-Troff-me if it's a Unix
		 * server but has the string "read.me", or if it's not a Unix
		 * server.  - FM
		 */
		if ((server_type != UNIX_SERVER) ||
		    (cp2 > (filename + 3) &&
		     0 == strncasecomp((cp2 - 4), "read.me", 7))) {
		    *cp2 = '\0';
		    format = HTFileFormat(filename, &encoding, NULL);
		    *cp2 = '.';
		} else {
		    format = HTFileFormat(filename, &encoding, NULL);
		}
	    } else {
		format = HTFileFormat(filename, &encoding, NULL);
	    }
	} else {
	    format = HTFileFormat(filename, &encoding, NULL);
	}
	format = HTCharsetFormat(format, anchor, -1);
	binary = (BOOL) (encoding != HTAtom_for("8bit") &&
			 encoding != HTAtom_for("7bit"));
	if (!binary &&
	/*
	 * Force binary if we're in source, download or dump mode and this is
	 * not a VM/CMS server, so we don't get CRLF instead of LF (or CR) for
	 * newlines in text files.  Can't do this for VM/CMS or we'll get raw
	 * EBCDIC.  - FM
	 */
	    (format_out == WWW_SOURCE ||
	     format_out == HTAtom_for("www/download") ||
	     format_out == HTAtom_for("www/dump")) &&
	    (server_type != CMS_SERVER))
	    binary = TRUE;
	if (!binary && type && *type == 'I') {
	    /*
	     * Force binary if we had ;type=I - FM
	     */
	    binary = TRUE;
	} else if (binary && type && *type == 'A') {
	    /*
	     * Force ASCII if we had ;type=A - FM
	     */
	    binary = FALSE;
	}
	if (binary != control->is_binary) {
	    /*
	     * Act on our setting if not already set.  - FM
	     */
	    const char *mode = binary ? "I" : "A";

	    status = send_cmd_2("TYPE", mode);
	    if (status != 2) {
		init_help_message_cache();	/* to free memory */
		return ((status < 0) ? status : -status);
	    }
	    control->is_binary = binary;
	}
	switch (server_type) {
	    /*
	     * Handle what for Lynx are special case servers, e.g., for which
	     * we respect RFC 1738, or which have known conflicts in suffix
	     * mappings.  - FM
	     */
	case VMS_SERVER:
	    {
		char *cp1, *cp2;
		BOOL included_device = FALSE;
		BOOL found_tilde = FALSE;

		/* Accept only Unix-style filename */
		if (StrChr(filename, ':') != NULL ||
		    StrChr(filename, '[') != NULL) {
		    FREE(fname);
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    CTRACE((tfp,
			    "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		    return -1;
		}
		/* Handle any unescaped "/%2F" path */
		if (!StrNCmp(filename, "//", 2)) {
		    int i;

		    included_device = TRUE;
		    for (i = 0; filename[(i + 1)]; i++)
			filename[i] = filename[(i + 1)];
		    filename[i] = '\0';
		    CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		    cp = HTVMS_name("", filename);
		    CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		    if ((cp1 = strrchr(cp, ']')) != NULL) {
			strcpy(filename, ++cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			*cp1 = '\0';
			status = send_cwd(cp);
			if (status != 2) {
			    char *dotslash = 0;

			    if ((cp1 = StrChr(cp, '[')) != NULL) {
				*cp1++ = '\0';
				status = send_cwd(cp);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
				HTSprintf0(&dotslash, "[.%s", cp1);
				status = send_cwd(dotslash);
				FREE(dotslash);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    } else {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
		    } else if ((cp1 = StrChr(cp, ':')) != NULL &&
			       StrChr(cp, '[') == NULL &&
			       StrChr(cp, ']') == NULL) {
			cp1++;
			if (*cp1 != '\0') {
			    int cplen = (int) (cp1 - cp);

			    strcpy(filename, cp1);
			    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			    HTSprintf0(&vmsname, "%.*s[%s]", cplen, cp, filename);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				HTSprintf(&vmsname, "%.*s[000000]", cplen, cp);
				status = send_cwd(vmsname);
				if (status != 2) {
				    HTSprintf(&vmsname, "%.*s", cplen, cp);
				    status = send_cwd(vmsname);
				    if (status != 2) {
					FREE(fname);
					init_help_message_cache();
					NETCLOSE(control->socket);
					control->socket = -1;
					return ((status < 0) ? status : -status);
				    }
				}
			    } else {
				HTSprintf0(&vmsname, "000000");
				filename = vmsname;
			    }
			}
		    } else if (0 == strcmp(cp, (filename + 1))) {
			status = send_cwd(cp);
			if (status != 2) {
			    HTSprintf0(&vmsname, "%s:", cp);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
			HTSprintf0(&vmsname, "000000");
			filename = vmsname;
		    }
		}
		/* Trim trailing slash if filename is not the top directory */
		if (strlen(filename) > 1 && filename[strlen(filename) - 1] == '/')
		    filename[strlen(filename) - 1] = '\0';

#ifdef MAINTAIN_CONNECTION	/* Don't need this if always new connection - F.M. */
		if (!included_device) {
		    /* Get the current default VMS device:[directory] */
		    status = send_cmd_1("PWD");
		    if (status != 2) {
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Go to the VMS account's top directory */
		    if ((cp = StrChr(response_text, '[')) != NULL &&
			(cp1 = strrchr(response_text, ']')) != NULL) {
			char *tmp = 0;
			unsigned len = 4;

			StrAllocCopy(tmp, cp);
			if ((cp2 = StrChr(cp, '.')) != NULL && cp2 < cp1) {
			    len += (cp2 - cp);
			} else {
			    len += (cp1 - cp);
			}
			tmp[len] = 0;
			StrAllocCat(tmp, "]");

			status = send_cwd(tmp);
			FREE(tmp);

			if (status != 2) {
			    FREE(fname);
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		}
#endif /* MAINTAIN_CONNECTION */

		/* If we want the VMS account's top directory, list it now */
		if (!(strcmp(filename, "/~")) ||
		    (included_device && 0 == strcmp(filename, "000000")) ||
		    (strlen(filename) == 1 && *filename == '/')) {
		    isDirectory = YES;
		    status = send_cmd_1("LIST");
		    FREE(fname);
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
		}
		/* Otherwise, go to appropriate directory and doctor filename */
		if (!StrNCmp(filename, "/~", 2)) {
		    filename += 2;
		    found_tilde = TRUE;
		}
		CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
		if (!included_device &&
		    (cp = StrChr(filename, '/')) != NULL &&
		    (cp1 = strrchr(cp, '/')) != NULL &&
		    (cp1 - cp) > 1) {
		    char *tmp = 0;

		    HTSprintf0(&tmp, "[.%.*s]", (int) (cp1 - cp - 1), cp + 1);

		    CTRACE((tfp, "change path '%s'\n", tmp));
		    while ((cp2 = strrchr(tmp, '/')) != NULL)
			*cp2 = '.';
		    CTRACE((tfp, "...to  path '%s'\n", tmp));

		    status = send_cwd(tmp);
		    FREE(tmp);

		    if (status != 2) {
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    filename = cp1 + 1;
		} else {
		    if (!included_device && !found_tilde) {
			filename += 1;
		    }
		}
		break;
	    }
	case CMS_SERVER:
	    {
		/*
		 * If we want the CMS account's top directory, or a base SFS or
		 * anonymous directory path (i.e., without a slash), list it
		 * now.  FM
		 */
		if ((strlen(filename) == 1 && *filename == '/') ||
		    ((0 == strncasecomp((filename + 1), "vmsysu:", 7)) &&
		     (cp = StrChr((filename + 1), '.')) != NULL &&
		     StrChr(cp, '/') == NULL) ||
		    (0 == strncasecomp(filename + 1, "anonymou.", 9) &&
		     StrChr(filename + 1, '/') == NULL)) {
		    if (filename[1] != '\0') {
			status = send_cwd(filename + 1);
			if (status != 2) {
			    /* Action not started */
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		    isDirectory = YES;
		    if (use_list)
			status = send_cmd_1("LIST");
		    else
			status = send_cmd_1("NLST");
		    FREE(fname);
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
		}
		filename++;

		/* Otherwise, go to appropriate directory and adjust filename */
		while ((cp = StrChr(filename, '/')) != NULL) {
		    *cp++ = '\0';
		    status = send_cwd(filename);
		    if (status == 2) {
			if (*cp == '\0') {
			    isDirectory = YES;
			    if (use_list)
				status = send_cmd_1("LIST");
			    else
				status = send_cmd_1("NLST");
			    FREE(fname);
			    if (status != 1) {
				/* Action not started */
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			    /* Clear any messages from the login directory */
			    init_help_message_cache();
			    /* Big goto! */
			    goto listen;
			}
			filename = cp;
		    }
		}
		break;
	    }
	default:
	    /* Shift for any unescaped "/%2F" path */
	    if (!StrNCmp(filename, "//", 2))
		filename++;
	    break;
	}
	/*
	 * Act on a file or listing request, or try to figure out which we're
	 * dealing with if we don't know yet.  - FM
	 */
	if (!(type) || (type && *type != 'D')) {
	    /*
	     * If we are retrieving a file we will (except for CMS) use
	     * binary mode, which lets us use the size command supported by
	     * ftp servers which implement RFC 3659.  Knowing the size lets
	     * us in turn display ETA in the progress message -TD
	     */
	    if (control->is_binary) {
		int code;
		off_t size;

		status = send_cmd_2("SIZE", filename);
		if (status == 2 &&
		    sscanf(response_text, "%d %" PRI_off_t, &code, &size) == 2) {
		    anchor->content_length = size;
		}
	    }
	    status = send_cmd_2("RETR", filename);
	    if (status >= 5) {
		int check;

		if (Broken_RETR) {
		    CTRACE((tfp, "{{reconnecting...\n"));
		    close_connection(control);
		    check = setup_connection(name, anchor);
		    CTRACE((tfp, "...done }}reconnecting\n"));
		    if (check < 0)
			return check;
		}
	    }
	} else {
	    status = 5;		/* Failed status set as flag. - FM */
	}
	if (status != 1) {	/* Failed : try to CWD to it */
	    /* Clear any login messages if this isn't the login directory */
	    if (strcmp(filename, "/"))
		init_help_message_cache();

	    status = send_cwd(filename);
	    if (status == 2) {	/* Succeeded : let's NAME LIST it */
		isDirectory = YES;
		if (use_list)
		    status = send_cmd_1("LIST");
		else
		    status = send_cmd_1("NLST");
	    }
	}
	FREE(fname);
	FREE(vmsname);
	if (status != 1) {
	    init_help_message_cache();	/* to free memory */
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    if (status < 0)
		return status;
	    else
		return -status;
	}
    }

  listen:
    if (!ftp_local_passive) {
	/* Wait for the connection */
#ifdef INET6
	struct sockaddr_storage soc_address;

#else
	struct sockaddr_in soc_address;
#endif /* INET6 */
	LY_SOCKLEN soc_addrlen = (LY_SOCKLEN) sizeof(soc_address);

#ifdef SOCKS
	if (socks_flag)
	    status = Raccept((int) master_socket,
			     (struct sockaddr *) &soc_address,
			     &soc_addrlen);
	else
#endif /* SOCKS */
	    status = accept((int) master_socket,
			    (struct sockaddr *) &soc_address,
			    &soc_addrlen);
	if (status < 0) {
	    init_help_message_cache();	/* to free memory */
	    return HTInetStatus("accept");
	}
	CTRACE((tfp, "TCP: Accepted new socket %d\n", status));
	data_soc = status;
    }

    if (isDirectory) {
	if (server_type == UNIX_SERVER && !unsure_type &&
	    !strcmp(response_text,
		    "150 Opening ASCII mode data connection for /bin/dl.\n")) {
	    CTRACE((tfp, "HTFTP: Treating as \"dls\" server.\n"));
	    server_type = DLS_SERVER;
	}
	final_status = read_directory(anchor, name, format_out, sink);
	if (final_status > 0) {
	    if (server_type != CMS_SERVER)
		if (outstanding-- > 0) {
		    status = response(0);
		    if (status < 0 ||
			(status == 2 && !StrNCmp(response_text, "221", 3)))
			outstanding = 0;
		}
	} else {		/* HT_INTERRUPTED */
	    /* User may have pressed 'z' to give up because no
	       packets got through, so let's not make them wait
	       any longer - kw */
	    outstanding = 0;
	}

	if (data_soc != -1) {	/* normally done in read_directory */
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	    if (status == -1)
		HTInetStatus("close");	/* Comment only */
	}
	status = final_status;
    } else {
	int rv;
	char *FileName = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);

	/* Clear any login messages */
	init_help_message_cache();

	/* Fake a Content-Encoding for compressed files. - FM */
	HTUnEscape(FileName);
	if (!IsUnityEnc(encoding)) {
	    /*
	     * We already know from the call to HTFileFormat above that this is
	     * a compressed file, no need to look at the filename again.  - kw
	     */
	    StrAllocCopy(anchor->content_type, format->name);
	    StrAllocCopy(anchor->content_encoding, HTAtom_name(encoding));
	    format = HTAtom_for("www/compressed");

	} else {
	    int rootlen;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &rootlen);

	    if (cft != cftNone) {
		FileName[rootlen] = '\0';
		format = HTFileFormat(FileName, &encoding, NULL);
		format = HTCharsetFormat(format, anchor, -1);
		StrAllocCopy(anchor->content_type, format->name);
		format = HTAtom_for("www/compressed");
	    }

	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
		break;
	    case cftNone:
		break;
	    }
	}
	FREE(FileName);

	_HTProgress(gettext("Receiving FTP file."));
	rv = HTParseSocket(format, format_out, anchor, data_soc, sink);

	HTInitInput(control->socket);
	/* Reset buffering to control connection DD 921208 */

	if (rv < 0) {
	    if (rv == -2)	/* weird error, don't expect much response */
		outstanding--;
	    else if (rv == HT_INTERRUPTED || rv == -1)
		/* User may have pressed 'z' to give up because no
		   packets got through, so let's not make them wait
		   longer - kw */
		outstanding = 0;
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	} else {
	    status = 2;		/* data_soc already closed in HTCopy - kw */
	}

	if (status < 0 && rv != HT_INTERRUPTED && rv != -1) {
	    (void) HTInetStatus("close");	/* Comment only */
	} else {
	    if (rv != HT_LOADED && outstanding--) {
		status = response(0);	/* Pick up final reply */
		if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		    data_soc = -1;	/* invalidate it */
		    init_help_message_cache();	/* to free memory */
		    return HTLoadError(sink, 500, response_text);
		} else if (status == 2 && !StrNCmp(response_text, "221", 3)) {
		    outstanding = 0;
		}
	    }
	}
	final_status = HT_LOADED;
    }
    while (outstanding-- > 0 &&
	   (status > 0)) {
	status = response(0);
	if (status == 2 && !StrNCmp(response_text, "221", 3))
	    break;
    }
    data_soc = -1;		/* invalidate it */
    CTRACE((tfp, "HTFTPLoad: normal end; "));
    if (control->socket < 0) {
	CTRACE((tfp, "control socket is %d\n", control->socket));
    } else {
	CTRACE((tfp, "closing control socket %d\n", control->socket));
	status = NETCLOSE(control->socket);
	if (status == -1)
	    HTInetStatus("control connection close");	/* Comment only */
    }
    control->socket = -1;
    init_help_message_cache();	/* to free memory */
    /* returns HT_LOADED (always for file if we get here) or error */
    return final_status;
}				/* open_file_read */

/*
 *  This function frees any user entered password, so that
 *  it must be entered again for a future request. - FM
 */
void HTClearFTPPassword(void)
{
    /*
     * Need code to check cached documents from non-anonymous ftp accounts and
     * do something to ensure that they no longer can be accessed without a new
     * retrieval.  - FM
     */

    /*
     * Now free the current user entered password, if any.  - FM
     */
    FREE(user_entered_password);
}

#endif /* ifndef DISABLE_FTP */
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.89 2009/02/01 12:49:00 tom Exp $
a98 1
    unsigned long addr;		/* IP address           */
d100 1
a100 1
    BOOL binary;		/* Binary mode? */
d135 1
a135 1
#  else				/* HPUX 10.20, etc. */
d157 7
d253 12
d311 4
d317 1
a317 1
    if (strncmp(nn, "localhost", 9)) {
d327 1
a327 1
		r = strchr(nodename, '.');	/* Mismatch */
d336 1
a336 1
    second = strchr(filename + 1, '/');		/* 2nd slash */
d353 7
a359 3
	for (p = strchr(vmsname, '['); *p != ']'; p++)
	    if (*p == '/')
		*p = '.';	/* Convert dir sep.  to dots */
d491 1
a491 1
	status = NETWRITE(control->socket, cmd, (unsigned) strlen(cmd));
d575 3
a577 3
		if (!strncmp(response_text, "230-", 4) ||
		    !strncmp(response_text, "250-", 4) ||
		    !strncmp(response_text, "220-", 4))
d692 1
a692 1
	cp = strchr(response_text + 5, '"');
d770 9
d814 3
a816 4
    if (control) {
	/*
	 * Reuse this object - KW, DW & FM
	 */
d820 2
a821 3
	con = control;
	con->addr = 0;
	con->binary = FALSE;
a822 3
	/*
	 * Allocate and init control struct.
	 */
d826 2
d831 2
a832 1
    if (!arg)
d834 1
a834 2
    if (!*arg)
	return -1;		/* Bad if name had zero length  */
d836 2
a837 2
/* Get node name:
*/
d848 1
a848 1
	    pw = strchr(username, ':');
d924 2
a925 2
/*	Now we log in		Look up username, prompt for pw.
*/
d927 1
a928 7
    if (status == HT_INTERRUPTED) {
	CTRACE((tfp, "HTFTP: Interrupted at beginning of login.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	NETCLOSE(control->socket);
	control->socket = -1;
	return HT_INTERRUPTED;
    }
d951 1
a951 7
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending username.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}
d954 1
a954 4
	if (password) {
	    /*
	     * We have non-zero length password, so send it. - FM
	     */
d958 1
a958 1
	     * Create and send a mail address as the password. - FM
d960 1
a960 1
	    char *the_address;
d974 1
a974 1
	    if ((cp = strchr(user, '@@')) != NULL) {
d988 1
a988 1
	    if (!(host) || strchr(host, '.') == NULL)
d996 1
a996 7
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}
d1002 1
a1002 8
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}

d1015 1
a1015 1
    if ((status = response("SYST\r\n")) == 2) {
d1017 1
a1017 1
	if (strncmp(response_text + 4,
d1035 1
a1035 1
	} else if (strncmp(response_text + 4, "VMS", 3) == 0) {
d1049 2
a1050 2
	} else if ((strncmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text + 4, "VM ", 3) == 0)) {
d1055 1
a1055 1
	} else if (strncmp(response_text + 4, "DCTS", 4) == 0) {
d1070 1
a1070 1
	} else if (strncmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
d1076 1
a1076 1
	} else if (strncmp(response_text + 4, "Windows_NT", 10) == 0) {
d1081 1
a1081 1
	} else if (strncmp(response_text + 4, "Windows2000", 11) == 0) {
d1086 1
a1086 1
	} else if (strncmp(response_text + 4, "MS Windows", 10) == 0) {
d1091 1
a1091 1
	} else if (strncmp(response_text + 4,
a1108 14
/*  Now we inform the server of the port number we will listen on
*/
#ifdef NOTREPEAT_PORT
    {
	int status = response(port_command);

	if (status != 2) {
	    if (control->socket)
		close_connection(control->socket);
	    return -status;	/* Bad return */
	}
	CTRACE((tfp, "HTFTP: Port defined.\n"));
    }
#endif /* NOTREPEAT_PORT */
d1186 1
a1186 1
    slen = sizeof(soc_address);
d1275 1
a1275 1
	LY_SOCKLEN address_length = sizeof(soc_address);
d1287 2
a1288 1
	if (status < 0)
d1290 1
d1293 1
a1293 1
		HTInetString((SockA *) soc_in)));
d1319 2
a1320 1
	if (status < 0)
d1322 1
d1335 2
a1336 1
	if (status < 0)
d1338 1
d1345 1
a1345 1
	    HTInetString((SockA *) soc_in)));
d1385 4
a1388 1
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
d1446 1
d1449 2
a1450 2
    strncpy(day, (char *) ctime(&NowTime) + 8, 2);
    day[2] = '\0';
d1454 1
a1454 2
    strncpy(month, (char *) ctime(&NowTime) + 4, 3);
    month[3] = '\0';
d1463 1
a1463 2
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
    ThisYear[4] = '\0';
d1473 1
a1473 1
    unsigned long size;
a1509 1
	s++;
a1515 1
	s++;
a1529 1
	s++;
a1539 1
	s++;
a1549 1
	s++;
d1555 1
a1555 1
    if (*s++ != ' ')
d1569 1
a1569 1
    unsigned long size;
d1596 1
a1596 1
		size = (size * 10) + (unsigned long) (*cp - '0');
d1604 1
a1604 2
	    strcpy(ct, ctime(&secs));
	    ct[24] = 0;
d1626 1
d1629 1
d1631 2
a1632 2
    unsigned long base = 1;
    unsigned long size_num = 0;
d1654 1
a1654 1
	size_num += ((unsigned long) (line[j] - '0') * base);
d1667 6
a1672 6
    if ((cp = strchr(line, ' ')) != 0
	&& (cp - line) == 10) {
	*cp = '\0';
	StrAllocCopy(entry->file_mode, line);
	*cp = ' ';
    }
d1674 14
a1687 25
    /*
     * Next is the link-count.
     */
    next = 0;
    entry->file_links = (unsigned long) strtol(cp, &next, 10);
    if (next == 0 || *next != ' ') {
	entry->file_links = 0;
	next = cp;
    } else {
	cp = next;
    }
    /*
     * Next is the user-name.
     */
    while (isspace(UCH(*cp)))
	++cp;
    if ((next = strchr(cp, ' ')) != 0)
	*next = '\0';
    if (*cp != '\0')
	StrAllocCopy(entry->file_user, cp);
    /*
     * Next is the group-name (perhaps).
     */
    if (next != NULL) {
	cp = (next + 1);
d1690 1
a1690 1
	if ((next = strchr(cp, ' ')) != 0)
d1693 13
a1705 1
	    StrAllocCopy(entry->file_group, cp);
d1720 1
a1720 1
    int size_num = 0;
d1762 1
a1762 1
	    if (cps && cps != line && *(cps - 1) == '/')
d1781 1
a1781 1
    entry_info->size = (unsigned long) size_num;
d1784 1
a1784 1
    if (!strncmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
d1823 1
a1823 1
    unsigned int ialloc;
d1830 1
a1830 1
    if (!strlen(line) || (cp = strchr(line, ';')) == NULL) {
d1844 4
a1847 2
	i = ((strstr(entry_info->filename, "READ") - entry_info->filename) + 4);
	if (!strncmp(&entry_info->filename[i], "ME", 2)) {
d1852 1
a1852 1
	} else if (!strncmp(&entry_info->filename[i], ".ME", 3)) {
d1869 1
a1869 1
    while ((cps = strchr(cps + 1, '\t')) != NULL)
d1890 1
a1890 1
    if ((cpd = strchr(cp, '-')) != NULL &&
d1906 1
a1906 1
	if (!strncmp(ThisYear, cpd + 5, 4) &&
d1917 1
a1917 1
    if ((cpd = strchr(cp, '/')) != NULL) {
d1924 1
a1924 1
	entry_info->size = (unsigned long) atol(cps);
d1929 1
a1929 1
	ialloc = (unsigned) atoi(cpd + 1);
d1934 1
a1934 1
    } else if ((cps = strtok(cp, sp)) != NULL) {
d1943 1
a1943 1
		entry_info->size = ((unsigned long) atol(cps) * 512);
d1949 1
a1949 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %lu\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d1984 1
a1984 1
	    entry_info->size = (unsigned long) atol(cps);
d2017 1
a2017 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %lu\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d2113 1
a2113 1
	    entry_info->size = atol(cps);
d2156 1
a2156 1
    if (strchr(entry_info->filename, '.') != NULL)
d2211 1
a2211 1
	    entry_info->size = ((unsigned long) Records * (unsigned long) RecordLength);
d2223 1
a2223 1
	 (cps = strchr(cpd, ':')) != NULL) &&
d2261 1
a2261 5
    /* Wrap it up. */
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %lu\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d2285 3
d2304 1
a2304 1
		(len < 24 && strchr(entry, ' '))) {
d2317 1
a2317 1
	    if (!entry_info->filename || *entry_info->filename == '\0') {
d2364 1
a2364 1
	    if (!strncmp(entry, "total ", 6) ||
a2402 1
		len = i - 3;
d2549 5
a2553 1
    if (entry_info->filename && strlen(entry_info->filename) > 3) {
d2581 1
a2581 1
	    if (!strncmp(HTAtom_name(format), "application", 11)) {
d2583 1
a2583 1
		if (!strncmp(cp2, "x-", 2))
d2596 44
d2642 3
a2644 2
    int i, status;
    char date1[16], date2[16], time1[8], time2[8], month[4];
d2649 5
a2653 6
	if (entry1->size == entry2->size)
	    return (strcmp(entry1->filename, entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
d2659 1
a2659 2
		return (status);
	    /* else fall to filename comparison */
d2661 1
a2661 1
	return (strcmp(entry1->filename, entry2->filename));
d2664 3
a2666 1
	if (entry1->date && entry2->date) {
d2668 1
a2668 8
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		return (strcmp(entry1->filename, entry2->filename));
	    }
	    /*
	     * Set the years and date,
	     * if we don't have them yet.
d2673 2
a2674 74
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[9] == ':') {
		strcpy(date1, "9999");
		strcpy(time1, &entry1->date[7]);
		if (time1[0] == ' ') {
		    time1[0] = '0';
		}
	    } else {
		strcpy(date1, &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    strncpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    strncat(date1, &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		date1[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date1[i] = LastYear[i];
		}
	    }
	    strcat(date1, time1);
	    if (entry2->date[9] == ':') {
		strcpy(date2, "9999");
		strcpy(time2, &entry2->date[7]);
		if (time2[0] == ' ') {
		    time2[0] = '0';
		}
	    } else {
		strcpy(date2, &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    strncpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    strncat(date2, &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		date2[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date2[i] = LastYear[i];
		}
	    }
	    strcat(date2, time2);
d2680 1
a2680 2
		return (status);
	    /* else fall to filename comparison */
d2682 1
a2682 1
	return (strcmp(entry1->filename, entry2->filename));
d2686 1
a2686 1
	return (strcmp(entry1->filename, entry2->filename));
d2688 1
d2709 18
d2808 2
a2809 1
	    *buf = '\0';
d2838 1
a2838 1
			if (!strncmp(HTAtom_name(format),
d2841 1
a2841 1
			    if (!strncmp(cp2, "x-", 2))
d2863 1
a2863 1
	    FormatNum(&buf, start, data->size);
d2876 1
a2876 1
		FormatNum(&buf, start, data->size);
d2879 1
a2879 1
		FormatNum(&buf, start, data->size / 1024);
d2923 1
a2945 1
    BOOL need_parent_link = FALSE;
d2972 1
a2972 1
    need_parent_link = HTDirTitles(target, parent, format_out, tildeIsTop);
d3024 1
d3046 1
d3082 1
a3082 1
		    HTChunkPutc(chunk, (char) ic);
d3375 1
a3375 1
		for (p = response_text; *p && !isspace(*p); p++) {
d3379 1
a3379 1
		     *p && *p && *p != '(';
d3391 1
a3391 1
		sslen = sizeof(ss);
d3398 5
a3402 2
		if (getnameinfo((struct sockaddr *) &ss, sslen, dst,
				sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
d3492 1
a3492 1
    HTReadProgress(0, 0);
d3567 1
a3567 1
	    if ((cp2 = strchr((filename + 1), '/')) != NULL) {
d3644 1
a3644 1
	if (binary != control->binary) {
d3655 1
a3655 1
	    control->binary = binary;
d3670 2
a3671 2
		if (strchr(filename, ':') != NULL ||
		    strchr(filename, '[') != NULL) {
d3681 1
a3681 1
		if (!strncmp(filename, "//", 2)) {
d3699 1
a3699 1
			    if ((cp1 = strchr(cp, '[')) != NULL) {
d3727 3
a3729 3
		    } else if ((cp1 = strchr(cp, ':')) != NULL &&
			       strchr(cp, '[') == NULL &&
			       strchr(cp, ']') == NULL) {
d3790 1
a3790 1
		    if ((cp = strchr(response_text, '[')) != NULL &&
d3796 1
a3796 1
			if ((cp2 = strchr(cp, '.')) != NULL && cp2 < cp1) {
d3836 1
a3836 1
		if (!strncmp(filename, "/~", 2)) {
d3842 1
a3842 1
		    (cp = strchr(filename, '/')) != NULL &&
d3881 2
a3882 2
		     (cp = strchr((filename + 1), '.')) != NULL &&
		     strchr(cp, '/') == NULL) ||
d3884 1
a3884 1
		     strchr(filename + 1, '/') == NULL)) {
d3914 1
a3914 1
		while ((cp = strchr(filename, '/')) != NULL) {
d3944 1
a3944 1
	    if (!strncmp(filename, "//", 2))
d3953 16
d4021 1
a4021 1
	LY_SOCKLEN soc_addrlen = sizeof(soc_address);
a4039 5
    /* !ftp_local_passive */
#if 0				/* no - this makes the data connection go away too soon (2.8.3dev.22) */
    if ((status = send_cmd_nowait("QUIT")) == 1)
	outstanding++;
#endif
d4054 1
a4054 1
			(status == 2 && !strncmp(response_text, "221", 3)))
d4099 1
d4101 15
a4115 16
		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
		    break;
		case cftDeflate:
		    StrAllocCopy(anchor->content_encoding, "x-deflate");
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    break;
		case cftNone:
		    break;
		}
a4126 7
#if 0				/* any known servers where ABOR would work this way? */
	    if (rv == HT_INTERRUPTED || rv == -501)
		if (send_cmd_nowait("ABOR") == 1) {
		    outstanding++;
		    CTRACE((tfp, "HTFTP: outstanding responses: %d\n", outstanding));
		}
#endif
d4136 1
a4136 1
	} else
d4138 1
d4149 1
a4149 3
		} else if (status <= 0) {
		    outstanding = 0;
		} else if (status == 2 && !strncmp(response_text, "221", 3))
d4151 1
d4159 1
a4159 1
	if (status == 2 && !strncmp(response_text, "221", 3))
@


1.8
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			File Transfer Protocol (FTP) Client
d151 6
a156 6
#define PUTC(c)      (*targetClass.put_character) (target, c)
#define PUTS(s)      (*targetClass.put_string)    (target, s)
#define START(e)     (*targetClass.start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*targetClass.end_element)   (target, e, 0)
#define FREE_TARGET  (*targetClass._free)         (target)
#define ABORT_TARGET (*targetClass._free)         (target)
d185 3
a187 4
 * ProFTPD 1.2.5rc1 is known to have a broken implementation of RETR.  If asked
 * to retrieve a directory, it gets confused and fails subsequent commands such
 * as CWD and LIST.  Since this is an unusual bug, we should remove this ifdef
 * at some point - TD 2004/1/1.
d189 1
a189 2
#define BROKEN_PROFTPD 1
static int ProFTPD_bugs = FALSE;
d192 1
a192 1
 * wu-ftpd 2.6.2(12) is known to have a broken implementation of EPSV.  The
d194 1
a194 1
 * this command - TD 2004/12/28
d196 3
a198 2
#define BROKEN_WUFTPD 1
static int WU_FTPD_bugs = FALSE;
d229 3
a231 1
static int master_socket = -1;	/* Listening socket = invalid   */
d234 1
a234 1
static int num_sockets;		/* Number of sockets to scan */
d352 1
a352 1
	    return -1;
d465 1
a465 1
	status = NETWRITE(control->socket, cmd, (int) strlen(cmd));
d477 19
d563 2
a564 3
#ifdef BROKEN_PROFTPD
		if (result == 220 && LYstrstr(response_text, "ProFTPD 1.2.5")) {
		    ProFTPD_bugs = TRUE;
d567 3
a569 5
#endif
#ifdef BROKEN_WUFTPD
		if (result == 220 && LYstrstr(response_text,
					      "(Version wu-2.6.2-12)")) {
		    WU_FTPD_bugs = TRUE;
d885 1
a885 1
	    con->socket, con));
d1122 12
d1143 1
a1143 1
    if (master_socket != -1)
d1145 6
a1150 3
    status = NETCLOSE(master_socket);
    CTRACE((tfp, "HTFTP: Closed master socket %d\n", master_socket));
    master_socket = -1;
d1164 1
d1190 1
a1190 1
    if (master_socket >= 0)
d1357 1
a1357 1
    if (master_socket >= 0)
d1361 1
a1361 1
    master_socket = new_socket;
d1408 1
a1408 1
	    status = Rlisten(master_socket, 1);
d1411 1
a1411 1
	    status = listen(master_socket, 1);
d1413 1
a1413 1
	    master_socket = -1;
d1422 1
a1422 1
    return master_socket;	/* Good */
d1472 1
a1472 1
    char *linkname;
d1475 1
a1475 1
    unsigned int size;
d1477 6
d1603 1
a1603 1
		size = (size * 10) + (*cp - '0');
d1632 1
a1632 1
			  EntryInfo *entry_info)
d1634 2
d1637 2
a1638 2
    int base = 1;
    int size_num = 0;
d1640 1
a1640 1
    for (i = strlen(line) - 1;
d1642 3
a1644 1
	 i--) ;			/* null body */
d1647 1
a1647 1
	StrAllocCopy(entry_info->date, &line[i - 12]);
d1649 2
a1650 2
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0')
	    entry_info->date[4] = HT_NON_BREAK_SPACE;
d1652 1
a1652 1
	if (entry_info->date[11] == ' ') {
d1654 1
a1654 1
		entry_info->date[j] = entry_info->date[j - 1];
d1660 1
a1660 1
	size_num += (line[j] - '0') * base;
d1664 50
a1713 3
    entry_info->size = size_num;
    StrAllocCopy(entry_info->filename, &line[i + 1]);
}				/* parse_ls_line() */
d1741 1
a1741 1
    len = strlen(line);
d1786 1
a1786 1
    entry_info->size = size_num;
d1790 1
a1790 1
	StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
d1800 1
a1800 1
    len = strlen(line);
d1803 1
a1803 1
	len = strlen(*pspilledname);
d1847 1
a1847 1
	i = strlen(entry_info->filename);
d1856 1
a1856 1
	    i = strlen(entry_info->filename);
d1927 1
a1927 1
	entry_info->size = atoi(cps);
d1932 1
a1932 1
	ialloc = atoi(cpd + 1);
d1946 1
a1946 1
		entry_info->size = atoi(cps) * 512;
d1953 1
a1953 1
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %u\n",
d1991 1
a1991 1
	    entry_info->size = atoi(cps);
d2025 1
a2025 1
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %u\n",
d2124 1
a2124 1
	    entry_info->size = atoi(cps);
d2222 1
a2222 1
	    entry_info->size = (Records * RecordLength);
d2273 1
a2273 1
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %u\n",
d2296 1
a2296 1
    entry_info = (EntryInfo *) malloc(sizeof(EntryInfo));
a2299 5
    entry_info->filename = NULL;
    entry_info->linkname = NULL;
    entry_info->type = NULL;
    entry_info->date = NULL;
    entry_info->size = 0;
d2313 1
a2313 1
	    len = strlen(entry);
d2365 1
a2365 1
	len = strlen(entry);
d2402 1
a2402 1
	    StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
d2446 1
a2446 1
	len = strlen(entry_info->filename);
d2530 1
a2530 1
	len = strlen(entry);
d2554 3
d2560 1
d2603 1
a2603 1
}				/* parse_dir_entry */
d2734 213
a2964 1
    HTStructuredClass targetClass;
a2967 1
    char string_buffer[64];
d2972 3
a2974 1
    targetClass = *(target->isa);
a3158 5
	/* Put up header
	 */
	/* PUTS("    Date        Type             Size     Filename\n");
	 */

d3162 1
d3171 2
a3173 1
	    int i;
d3180 6
a3198 1

d3226 1
a3226 1
			sprintf(string_buffer, "%6d bytes",
d3229 1
a3229 1
			sprintf(string_buffer, "%6d Kb",
d3233 1
a3233 1
			sprintf(string_buffer, "  %u bytes",
d3236 1
a3236 1
			sprintf(string_buffer, "  %uKb",
d3246 1
d3295 5
a3299 2
    ProFTPD_bugs = FALSE;
    WU_FTPD_bugs = FALSE;
d3313 1
a3313 1
		if (master_socket >= 0)
d3356 1
a3356 1
	    if (WU_FTPD_bugs)
d3387 1
a3387 1
		passive_port = (p0 << 8) + p1;
d3402 1
a3402 1
		     p++)	/*) */
d3404 1
d3411 1
a3411 1
		passive_port = p0;
a3972 4
#ifdef BROKEN_PROFTPD
	    /*
	     * ProFTPD 1.2.5rc1 gets confused when asked to RETR a directory.
	     */
d3976 1
a3976 1
		if (ProFTPD_bugs) {
a3984 1
#endif
d4028 1
a4028 1
	    status = Raccept(master_socket,
d4033 1
a4033 1
	    status = accept(master_socket,
@


1.7
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 46
a47 46
**			for a WorldWideWeb browser
**			===================================
**
**	A cache of control connections is kept.
**
** Note: Port allocation
**
**	It is essential that the port is allocated by the system, rather
**	than chosen in rotation by us (POLL_PORTS), or the following
**	problem occurs.
**
**	It seems that an attempt by the server to connect to a port which has
**	been used recently by a listen on the same socket, or by another
**	socket this or another process causes a hangup of (almost exactly)
**	one minute.  Therefore, we have to use a rotating port number.
**	The problem remains that if the application is run twice in quick
**	succession, it will hang for what remains of a minute.
**
** Authors
**	TBL	Tim Berners-lee <timbl@@info.cern.ch>
**	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
**	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
**	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
** History:
**	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
**	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
**	10 Feb 92	Retry if cached connection times out or breaks
**	 8 Dec 92	Bug fix 921208 TBL after DD
**	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
**			fails on princeton.edu!
**	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
**			must be Unix-style and cannot include the device
**			or top directory.
**	?? ??? ?? (LM)	Added code to prompt and send passwords for non
**			anonymous FTP
**	25 Mar 94 (LM)	Added code to recognize different ftp server types
**			and code to parse dates and sizes on most hosts.
**	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
**
** Notes:
**			Portions Copyright 1994 Trustees of Dartmouth College
**			Code for recognizing different FTP servers and
**			parsing "ls -l" output taken from Macintosh Fetch
**			program with permission from Jim Matthews,
**			Dartmouth Software Development Team.
*/
d50 9
a58 9
BUGS:	@@@@@@	Limit connection cache size!
		Error reporting to user.
		400 & 500 errors are ack'ed by user with windows.
		Use configuration file for user names

**		Note for portability this version does not use select() and
**		so does not watch the control and data channels at the
**		same time.
*/
d64 1
a64 1
#include <HTFTP.h>	/* Implemented here */
d69 2
a70 2
#define REPEAT_PORT	/* Give the port number for each file */
#define REPEAT_LISTEN	/* Close each listen socket and open a new one */
d73 1
a73 1
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP)*/
d82 1
a82 1
#include <HTFile.h>	/* For HTFileFormat() */
d95 4
a98 4
    struct _connection *	next;	/* Link on list		*/
    unsigned long		addr;	/* IP address		*/
    int				socket; /* Socket number for communication */
    BOOL			binary; /* Binary mode? */
d105 43
d156 2
a157 2
	CONST HTStructuredClass *	isa;
	/* ... */
d161 3
a163 3
**	---------------------
*/
PUBLIC int HTfileSortMethod = FILE_BY_NAME;
d165 5
a169 5
#ifndef DISABLE_FTP /*This disables everything to end-of-file */
PRIVATE char ThisYear[8];
PRIVATE char LastYear[8];
PRIVATE int TheDate;
PRIVATE BOOLEAN HaveYears = FALSE;
d172 8
a179 8
**	---------------------
*/
PRIVATE connection * connections = NULL;/* Linked list of connections */
PRIVATE char response_text[LINE_LENGTH+1];/* Last response from ftp host */
PRIVATE connection * control = NULL;	/* Current connection */
PRIVATE int data_soc = -1;		/* Socket for data transfer =invalid */
PRIVATE char *user_entered_password = NULL;
PRIVATE char *last_username_and_host = NULL;
d188 9
a196 1
PRIVATE int ProFTPD_bugs = FALSE;
d199 16
a214 16
	GENERIC_SERVER
	, MACHTEN_SERVER
	, UNIX_SERVER
	, VMS_SERVER
	, CMS_SERVER
	, DCTS_SERVER
	, TCPC_SERVER
	, PETER_LEWIS_SERVER
	, NCSA_SERVER
	, WINDOWS_NT_SERVER
	, WINDOWS_2K_SERVER
	, MS_WINDOWS_SERVER
	, MSDOS_SERVER
	, APPLESHARE_SERVER
	, NETPRESENZ_SERVER
	, DLS_SERVER
d217 3
a219 3
PRIVATE eServerType server_type = GENERIC_SERVER; /* the type of ftp host */
PRIVATE int	unsure_type = FALSE;		/* sure about the type? */
PRIVATE BOOLEAN use_list = FALSE;		/* use the LIST command? */
d221 1
a221 1
PRIVATE int	interrupted_in_next_data_char = FALSE;
d224 1
a224 1
PRIVATE PortNumber	port_number = FIRST_TCP_PORT;
d227 5
a231 6
PRIVATE int	master_socket = -1;	/* Listening socket = invalid	*/
PRIVATE char	port_command[255];	/* Command for setting the port */
PRIVATE fd_set	open_sockets;		/* Mask of active channels */
PRIVATE int	num_sockets;		/* Number of sockets to scan */
PRIVATE PortNumber	passive_port;	/* Port server specified for data */

d236 4
a239 3
PRIVATE char data_buffer[DATA_BUFFER_SIZE];		/* Input data buffer */
PRIVATE char * data_read_pointer;
PRIVATE char * data_write_pointer;
d241 1
a241 3
PRIVATE int close_connection PARAMS((
	connection *	con));

d245 3
a247 3
**  This function frees module globals. - FM
*/
PRIVATE void free_FTPGlobals NOARGS
d260 12
a271 13
**		CONVERTS WWW name into a VMS name
** ON ENTRY:
**	nn		Node Name (optional)
**	fn		WWW file name
**
** ON EXIT:
**	returns		vms file specification
**
** Bug: Returns pointer to static -- non-reentrant
*/
PUBLIC char * HTVMS_name ARGS2(
	CONST char *,	nn,
	CONST char *,	fn)
d273 6
a278 8

/*	We try converting the filename into Files-11 syntax.  That is, we assume
**	first that the file is, like us, on a VMS node.  We try remote
**	(or local) DECnet access.  Files-11, VMS, VAX and DECnet
**	are trademarks of Digital Equipment Corporation.
**	The node is assumed to be local if the hostname WITHOUT DOMAIN
**	matches the local one. @@@@@@
*/
d280 2
a281 2
    char * filename = (char*)malloc(strlen(fn)+1);
    char * nodename = (char*)malloc(strlen(nn)+2+1);	/* Copies to hack */
d285 1
a285 1
    CONST char * hostname = HTHostName();
d292 3
a294 2
	CONST char *p;
	CONST char *q;
d296 1
a296 1
	     *p && *p != '.' && *q && *q != '.'; p++, q++){
d299 1
d303 1
a303 1
		    *r = '\0';			/* Chop domain */
d310 1
a310 1
    second = strchr(filename+1, '/');		/* 2nd slash */
d313 1
a313 1
    if (!second) {				/* Only one slash */
d315 1
a315 1
    } else if (second == last) {		/* Exactly two slashes */
d317 5
a321 4
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename+1, second+1);
	*second = '/';	/* restore */
    } else {				/* More than two slashes */
	char * p;
d325 1
a325 1
		nodename, filename+1, second+1, last+1);
d327 1
a327 1
	for (p = strchr(vmsname, '['); *p!=']'; p++)
d329 1
a329 1
		*p = '.';		/* Convert dir sep.  to dots */
d337 3
a339 3
**	----------------------------------------------------
*/
PRIVATE int next_data_char NOARGS
d342 1
d345 6
a350 6
      if (status == HT_INTERRUPTED)
	interrupted_in_next_data_char = 1;
      if (status <= 0)
	return -1;
      data_write_pointer = data_buffer + status;
      data_read_pointer = data_buffer;
d355 1
a362 1

d364 3
a366 4
**
*/
PRIVATE int close_connection ARGS1(
	connection *,	con)
d368 1
a368 1
    connection * scan;
d370 1
d390 1
a390 1
		control = (connection*)0;
d392 3
a394 3
	} /*if */
    } /* for */
    return -1;		/* very strange -- was not on list. */
d397 1
a397 1
PRIVATE char *help_message_buffer = NULL;  /* global :( */
d399 1
a399 1
PRIVATE void init_help_message_cache NOARGS
d404 1
a404 2
PRIVATE void help_message_cache_add ARGS1(
	char *,		string)
d411 1
a411 1
    CTRACE((tfp,"Adding message to help cache: %s\n",string));
d414 1
a414 1
PRIVATE char *help_message_cache_non_empty NOARGS
d416 1
a416 1
  return(help_message_buffer);
d419 1
a419 1
PRIVATE char *help_message_cache_contents NOARGS
d421 1
a421 1
   return(help_message_buffer);
d425 17
a441 18
**	----------------
**
**	This function checks whether we have a control connection, and sends
**	one command if given.
**
** On entry,
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
**
**	The command should already be terminated with the CRLF pair.
**
** On exit,
**	returns:  1 for success,
**		  or negative for communication failure (in which case
**		  the control connection will be closed).
*/
PRIVATE int write_cmd ARGS1(
	char *,		cmd)
d447 1
a447 1
	return -99;
d454 2
a455 1
	    char * p;
d461 1
a461 1
	status = NETWRITE(control->socket, cmd, (int)strlen(cmd));
d463 3
a465 2
	    CTRACE((tfp, "HTFTP: Error %d sending command: closing socket %d\n",
			status, control->socket));
d474 21
a494 22
**	--------------------------------
**
**	See the state machine illustrated in RFC959, p57. This implements
**	one command/reply sequence.  It also interprets lines which are to
**	be continued, which are marked with a "-" immediately after the
**	status code.
**
**	Continuation then goes on until a line with a matching reply code
**	an a space after it.
**
** On entry,
**	control	points to the connection which is established.
**	cmd	points to a command, or is zero to just get the response.
**
**	The command must already be terminated with the CRLF pair.
**
** On exit,
**	returns:  The first digit of the reply type,
**		  or negative for communication failure.
*/
PRIVATE int response ARGS1(
	char *,		cmd)
d496 1
a496 1
    int result;				/* Three-digit decimal code */
d505 1
d508 1
d510 1
a510 1
			|| (p == &response_text[LINE_LENGTH])) {
d515 3
a517 2
		    CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE (control->socket);
d522 1
a522 1
		*p = '\0';			/* Terminate the string */
d526 4
a529 4
		if (!strncmp(response_text,"230-",4) ||
		    !strncmp(response_text,"250-",4) ||
		    !strncmp(response_text,"220-",4))
		    help_message_cache_add(response_text+4);
d532 3
a534 3
		if  (continuation_response == -1) {
			if (continuation == '-')  /* start continuation */
			    continuation_response = result;
d536 3
a538 3
			if (continuation_response == result &&
			    continuation == ' ')
			    continuation_response = -1; /* ended */
d546 7
d554 2
a555 2
	    } /* if end of line */

d557 3
a559 2
		CTRACE((tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE (control->socket);
d566 1
a566 1
			    control->socket));
d571 1
a571 1
	} /* Loop over characters */
d577 1
a577 1
		    control->socket));
d585 2
a586 2
	**  Alas, CMS returns 255 on failure to CWD to parent of root. - PG
	*/
d589 1
a589 1
    return result/100;
d592 1
a592 1
PRIVATE int send_cmd_1 ARGS1(char *, verb)
d596 2
a597 2
    sprintf(command, "%.*s%c%c", (int) sizeof(command)-4, verb, CR, LF);
    return response (command);
d600 1
a600 1
PRIVATE int send_cmd_2 ARGS2(char *, verb, char *, param)
d606 1
a606 1
    status = response (command);
d615 2
a616 2
 *  This function should try to set the macintosh server into binary mode.
 *  Some servers need an additional letter after the MACB command.
d618 1
a618 2
PRIVATE int set_mac_binary ARGS1(
	eServerType,	ServerType)
d624 1
a624 1
	 *  Presumably E means "Enable".  - KW
d626 1
a626 1
	return(2 == response("MACB E\r\n"));
d628 1
a628 1
	return(2 == response("MACB\r\n"));
d636 1
a636 3
PRIVATE void get_ftp_pwd ARGS2(
	eServerType *,	ServerType,
	BOOLEAN *,	UseList)
d638 1
a639 1
    char *cp;
d642 1
d646 1
a646 1
	cp = strchr(response_text+5,'"');
d651 1
a651 1
					  NCSA_SERVER : TCPC_SERVER);
d653 2
a654 2
			 ((*ServerType == NCSA_SERVER) ?
						 "NCSA" : "TCPC")));
d663 3
a665 3
		 *ServerType = UNIX_SERVER;
		 *UseList = TRUE;
		 CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
d668 1
a668 1
	} else if (response_text[strlen(response_text)-1] == ']') {
d690 1
a690 3
PRIVATE void set_unix_dirstyle ARGS2(
	eServerType *,	ServerType,
	BOOLEAN *,	UseList)
d692 1
a693 1
    char *cp;
d699 1
d715 1
a715 1
	cp = strstr(response_text+4, "MSDOS");
d725 16
a740 17
**	----------------------------------
**
** On entry,
**	arg	points to the name of the host in a hypertext address
** On exit,
**	returns <0 if error
**		socket number if success
**
**	This routine takes care of managing timed-out connections, and
**	limiting the number of connections in use at any one time.
**
**	It ensures that all connections are logged in if they exist.
**	It ensures they have the port number transferred.
*/
PRIVATE int get_connection ARGS2(
	CONST char *,		arg,
	HTParentAnchor *,	anchor)
d743 4
a746 4
    char * command = 0;
    connection * con;
    char * username = NULL;
    char * password = NULL;
d751 2
a752 2
	**  Set up freeing at exit. - FM
	*/
d761 2
a762 2
	**  Reuse this object - KW, DW & FM
	*/
d771 2
a772 2
	**  Allocate and init control struct.
	*/
d779 4
a782 2
    if (!arg) return -1;		/* Bad if no name specified	*/
    if (!*arg) return -1;		/* Bad if name had zero length	*/
d790 1
a790 1
	char * pw = NULL;
d794 2
a795 2
	    *p2 = '\0';			/* terminate */
	    p1 = p2+1;			/* point to host */
d805 3
a807 4
	     *	If the password doesn't exist then we are going to have
	     *	to ask the user for it.  The only problem is that we
	     *	don't want to ask for it every time, so we will store
	     *	away in a primitive fashion.
d814 3
a816 3
		 *  If the user@@host is not equal to the last time through
		 *  or user_entered_password has no data then we need
		 *  to ask the user for the password.
d824 1
a824 1
				     username, p1);
d828 1
a828 1
		} /* else we already know the password */
d836 1
a836 1
    } /* scope of p1 */
d838 1
a838 1
    status = HTDoConnect (arg, "FTP", IPPORT_FTP, (int *)&con->socket);
d845 1
a845 1
			arg));
d848 1
a848 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d853 2
a854 3
	if (con->socket != -1)
	{
	  NETCLOSE(con->socket);
d861 1
a861 1
	return status;			/* Bad return */
d865 1
a865 1
		con->socket, con));
a871 1

d874 1
a874 1
    status = response((char *)0);	/* Get greeting */
d878 1
a878 1
	_HTProgress (CONNECTION_INTERRUPTED);
d907 1
a907 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d923 1
d925 10
a934 2
	    CONST char *host = NULL;
	    char * cp;
d936 6
a941 8
	    if (personal_mail_address && *personal_mail_address) {
		/*
		 * We have a non-zero length personal
		 * mail address, so use that. - FM
		 */
		StrAllocCopy(user, personal_mail_address);
		if ((cp=strchr(user, '@@')) != NULL) {
		    *cp++ = '\0';
a942 3
		} else {
		    host = HTHostName();
		}
a943 7
		/*
		 * Use an environment variable and the host global. - FM
		 */
		if ((cp=LYGetEnv("USER")) != NULL)
		    StrAllocCopy(user, cp);
		else
		    StrAllocCopy(user, "WWWuser");
d961 1
a961 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d973 1
a973 1
	    _HTProgress (CONNECTION_INTERRUPTED);
d987 1
a987 1
    /** Check for host type **/
d990 2
a991 2
    use_list = FALSE;			/* reset */
    if ((status=response("SYST\r\n")) == 2) {
d993 1
a993 1
	if (strncmp(response_text+4,
d999 2
a1000 2
	} else if (strstr(response_text+4, "UNIX") != NULL ||
		   strstr(response_text+4, "Unix") != NULL) {
d1002 1
a1002 1
	    unsure_type = FALSE; /* to the best of out knowledge... */
d1006 1
a1006 1
	} else if (strstr(response_text+4, "MSDOS") != NULL) {
d1011 1
a1011 1
	} else if (strncmp(response_text+4, "VMS", 3) == 0) {
d1013 1
d1016 2
a1017 2
	     && tilde[2] != 0
	     && strstr(response_text+4, "MadGoat") != 0) {
d1025 2
a1026 2
	} else if ((strncmp(response_text+4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text+4, "VM ", 3) == 0)) {
d1031 1
a1031 1
	} else if (strncmp(response_text+4, "DCTS", 4) == 0) {
d1035 1
a1035 1
	} else if (strstr(response_text+4, "MAC-OS TCP/Connect II") != NULL) {
d1041 1
a1041 1
	} else if (server_type == NETPRESENZ_SERVER) { /* already set above */
d1046 1
a1046 1
	} else if (strncmp(response_text+4, "MACOS Peter's Server", 20) == 0) {
d1052 1
a1052 1
	} else if (strncmp(response_text+4, "Windows_NT", 10) == 0) {
d1057 1
a1057 1
	} else if (strncmp(response_text+4, "Windows2000", 11) == 0) {
d1062 1
a1062 1
	} else if (strncmp(response_text+4, "MS Windows", 10) == 0) {
d1067 1
a1067 1
	} else if (strncmp(response_text+4,
d1074 1
a1074 1
	} else	{
d1079 1
a1079 1
	 }
d1082 1
a1082 1
	 get_ftp_pwd(&server_type, &use_list);
d1090 1
d1094 1
a1094 1
	    return -status;		/* Bad return */
d1099 1
a1099 1
    return con->socket;			/* Good return */
a1101 1

d1103 5
a1107 5
**	-------------------------------
**
**
*/
PRIVATE int close_master_socket NOARGS
a1121 1

d1123 14
a1136 14
**	-------------------------------------
**
**	When data is transferred, we open a port, and wait for the server to
**	connect with the data.
**
** On entry,
**	master_socket	Must be negative if not set up already.
** On exit,
**	Returns		socket number if good
**			less than zero if error.
**	master_socket	is socket number if good, else negative.
**	port_number	is valid if good.
*/
PRIVATE int get_listen_socket NOARGS
d1140 1
a1140 1
    struct sockaddr_in* soc_in = (struct sockaddr_in *)&soc_address;
d1142 2
a1143 1
    int slen;
d1146 1
a1146 1
    struct sockaddr_in* soc_in = &soc_address;
d1148 1
a1148 2
    int new_socket;			/* Will be master_socket */

d1155 1
a1155 1
	return master_socket;  /* Done already */
d1161 2
a1162 2
    if (getsockname(control->socket, (struct sockaddr *)&soc_address,
		&slen) < 0) {
d1165 1
a1165 1
    af = ((struct sockaddr *)&soc_address)->sa_family;
d1186 1
a1186 1
    ((struct sockaddr *)&soc_address)->sa_family = af;
d1190 1
a1190 1
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in);
d1195 1
a1195 1
	((struct sockaddr *)&soc_address)->sa_len = sizeof(struct sockaddr_in6);
d1202 2
a1203 2
    soc_in->sin_family = AF_INET;	    /* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;   /* Any peer address */
d1208 2
a1209 1
	for (port_number = (old_port_number+1); ; port_number++) {
d1211 1
d1224 4
a1227 4
		if ((status=Rbind(new_socket,
			(struct sockaddr*)&soc_address,
			    /* Cast to generic sockaddr */
			SOCKADDR_LEN(soc_address)
d1229 1
a1229 1
			,socks_bind_remoteAddr
d1231 1
a1231 1
						)) == 0) {
d1235 7
a1241 7
	    if ((status=bind(new_socket,
		    (struct sockaddr*)&soc_address,
			    /* Cast to generic sockaddr */
		    SOCKADDR_LEN(soc_address)
		    )) == 0) {
		break;
	    }
d1243 2
a1244 2
		port_number, status, SOCKET_ERRNO));
	} /* for */
d1249 2
a1250 1
	int address_length = sizeof(soc_address);
d1254 2
a1255 2
				  (struct sockaddr *)&soc_address,
				  (void *)&address_length);
d1258 5
a1262 4
	status = getsockname(control->socket,
			     (struct sockaddr *)&soc_address,
			     (void *)&address_length);
	if (status<0) return HTInetStatus("getsockname");
d1265 1
a1265 1
	    HTInetString((SockA *)soc_in)));
d1270 1
a1270 1
	    HTInetString(soc_in)));
d1276 4
a1279 4
	    status=Rbind(new_socket,
			 (struct sockaddr*)&soc_address,
			 /* Cast to generic sockaddr */
			 sizeof(soc_address)
d1281 1
a1281 5
#ifdef INET6
			socks_bind_remoteAddr
#else
			,socks_bind_remoteAddr
#endif /* INET6 */
d1283 1
a1283 1
						);
d1286 7
a1292 6
	status=bind(new_socket,
		    (struct sockaddr*)&soc_address,
		    /* Cast to generic sockaddr */
		    SOCKADDR_LEN(soc_address)
		    );
	if (status<0) return HTInetStatus("bind");
d1298 2
a1299 2
				  (struct sockaddr*)&soc_address,
				  (void *)&address_length);
d1302 5
a1306 4
	status = getsockname(new_socket,
			     (struct sockaddr*)&soc_address,
			     (void *)&address_length);
	if (status<0) return HTInetStatus("getsockname");
d1312 2
a1313 2
		(int)ntohs(soc_in->sin_port),
		HTInetString((SockA *)soc_in)));
d1316 2
a1317 2
		(int)ntohs(soc_in->sin_port),
		HTInetString(soc_in)));
d1329 1
a1329 1
    (void)HTHostName();		/* Make address valid - doesn't work*/
d1331 1
a1331 1
    switch (((struct sockaddr *)&soc_address)->sa_family) {
d1335 7
a1341 7
		    (int)*((unsigned char *)(&soc_in->sin_addr)+0),
		    (int)*((unsigned char *)(&soc_in->sin_addr)+1),
		    (int)*((unsigned char *)(&soc_in->sin_addr)+2),
		    (int)*((unsigned char *)(&soc_in->sin_addr)+3),
		    (int)*((unsigned char *)(&soc_in->sin_port)+0),
		    (int)*((unsigned char *)(&soc_in->sin_port)+1),
		    CR, LF);
d1347 12
a1358 11
      {
	char hostbuf[MAXHOSTNAMELEN];
	char portbuf[MAXHOSTNAMELEN];
	getnameinfo((struct sockaddr *)&soc_address,
	    SOCKADDR_LEN(soc_address),
	    hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
	    NI_NUMERICHOST | NI_NUMERICSERV);
	sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		CR, LF);
	break;
      }
d1365 2
a1366 2
    /*	Inform TCP that we will accept connections
    */
d1369 1
d1383 2
a1384 2
    if ((master_socket+1) > num_sockets)
	num_sockets = master_socket+1;
d1386 1
a1386 1
    return master_socket;		/* Good */
d1388 1
a1388 1
} /* get_listen_socket */
d1390 4
a1393 2
PRIVATE char * months[12] = {
    "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
d1397 10
a1406 10
**	-----------------------------------------------------------------
**
**	Bug:
**		This code is for sorting listings by date, if that option
**		is selected in Lynx, and doesn't take into account time
**		zones or ensure resetting at midnight, so the sort may not
**		be perfect, but the actual date isn't changed in the display,
**		i.e., the date is still correct. - FM
*/
PRIVATE void set_years_and_date NOARGS
d1413 1
a1413 1
    strncpy(day, (char *)ctime(&NowTime)+8, 2);
d1418 1
a1418 1
    strncpy(month, (char *)ctime(&NowTime)+4, 3);
d1428 1
a1428 1
    strcpy(ThisYear, (char *)ctime(&NowTime)+20);
d1435 4
a1438 3
    char *	 filename;
    char *	 type;
    char *	 date;
d1440 1
a1440 1
    BOOLEAN	 display;  /* show this entry? */
d1443 1
a1443 2
PRIVATE void free_entryinfo_struct_contents ARGS1(
	EntryInfo *,	entry_info)
d1447 1
d1451 1
a1451 1
   /* dont free the struct */
d1462 1
a1462 2
PRIVATE BOOLEAN is_ls_date ARGS1(
	char *,		s)
d1524 1
a1524 1
} /* is_ls_date() */
d1527 1
a1527 2
 *  parse_eplf_line() --
 *	Extract the name, size, and date from an EPLF line. - 08-06-96 DJB
d1529 2
a1530 3
PRIVATE void parse_eplf_line ARGS2(
	char *,		line,
	EntryInfo *,	info)
d1536 1
a1536 1
    static time_t base; /* time() value on this OS in 1970 */
d1541 7
a1547 2
	t.tm_year = 70; t.tm_mon = 0; t.tm_mday = 0;
	t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0;
d1549 1
a1549 1
	base = mktime(&t); /* could return -1 */
d1554 28
a1581 28
	switch(*cp) {
	    case '\t':
		StrAllocCopy(info->filename, cp + 1);
		return;
	    case 's':
		size = 0;
		while (*(++cp) && (*cp != ','))
		    size = (size * 10) + (*cp - '0');
		info->size = size;
		break;
	    case 'm':
		secs = 0;
		while (*(++cp) && (*cp != ','))
		    secs = (secs * 10) + (*cp - '0');
		secs += base; /* assumes that time_t is #seconds */
		strcpy(ct, ctime(&secs));
		ct[24] = 0;
		StrAllocCopy(info->date, ct);
		break;
	    case '/':
		StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
		/* FALLTHRU */
	    default:
		while (*cp) {
		    if (*cp++ == ',')
		      break;
		}
		break;
d1584 1
a1584 1
} /* parse_eplf_line */
d1587 1
a1587 2
 * parse_ls_line() --
 *	Extract the name, size, and date from an ls -l line.
d1589 6
a1594 7
PRIVATE void parse_ls_line ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
{
    int    i, j;
    int    base=1;
    int    size_num=0;
d1597 2
a1598 2
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i-12])); i--)
	; /* null body */
d1601 1
a1601 1
	StrAllocCopy(entry_info->date, &line[i-12]);
d1608 1
a1608 1
		entry_info->date[j] = entry_info->date[j-1];
d1620 1
a1620 1
} /* parse_ls_line() */
d1623 11
a1633 13
 * parse_dls_line() --
 *	Extract the name and size info and whether it refers to a
 *      directory from a LIST line in "dls" format.
 */
PRIVATE void parse_dls_line ARGS3(
	char *,		line,
	EntryInfo *,	entry_info,
	char **,	pspilledname)
{
    short  j;
    int    base=1;
    int    size_num=0;
    int    len;
d1636 8
a1643 8
    /* README		   763	Information about this server\0
       bin/		     -	\0
       etc/		     =	\0
       ls-lR		     0	\0
       ls-lR.Z		     3	\0
       pub/		     =	Public area\0
       usr/		     -	\0
       morgan		    14	-> ../real/morgan\0
d1645 2
a1646 2
			 79215	\0
	*/
d1668 1
a1668 1
	    if (entry_info->filename[strlen(entry_info->filename)-1] == '/')
d1674 1
a1674 1
	    if (cps && cps != line && *(cps-1) == '/')
d1698 1
d1712 4
a1715 4
    if (len > 0 && line[len-1] == '/') {
		/*
		**  It's a dir, remove / and mark it as such.
		*/
d1717 1
a1717 1
	    line[len-1] = '\0';
d1724 1
a1724 1
} /* parse_dls_line() */
d1731 2
a1732 3
PRIVATE void parse_vms_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d1736 2
a1737 1
    char *cp, *cpd, *cps, date[16], *sp = " ";
d1739 3
a1741 2
    /**  Get rid of blank lines, and information lines.  **/
    /**  Valid lines have the ';' version number token.  **/
d1747 3
a1749 3
    /** Cut out file or directory name at VMS version number. **/
    *cp++ ='\0';
    StrAllocCopy(entry_info->filename,line);
d1751 1
a1751 1
    /** Cast VMS non-README file and directory names to lowercase. **/
d1770 1
a1770 1
    /** Uppercase terminal .z's or _z's. **/
d1773 2
a1774 2
	(entry_info->filename[i-1] == '.' ||
	 entry_info->filename[i-1] == '_'))
d1777 3
a1779 3
    /** Convert any tabs in rest of line to spaces. **/
    cps = cp-1;
    while ((cps=strchr(cps+1, '\t')) != NULL)
d1782 3
a1784 2
    /** Collapse serial spaces. **/
    i = 0; j = 1;
d1794 1
a1794 1
    /* Set the years and date, if we don't have them yet. **/
d1799 13
a1811 13
    /** Track down the date. **/
    if ((cpd=strchr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd-1))) &&
	isalpha(UCH(*(cpd+1))) && *(cpd+4) == '-') {

	/** Month **/
	*(cpd+2) = (char) TOLOWER(*(cpd+2));
	*(cpd+3) = (char) TOLOWER(*(cpd+3));
	sprintf(date, "%.3s ", cpd+1);

	/** Day **/
	if (isdigit(UCH(*(cpd-2))))
	    sprintf(date+4, "%.2s ", cpd-2);
d1813 1
a1813 1
	    sprintf(date+4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd-1);
d1815 4
a1818 4
	/** Time or Year **/
	if (!strncmp(ThisYear, cpd+5, 4) &&
	    strlen(cpd) > 15 && *(cpd+12) == ':') {
	    sprintf(date+7, "%.5s", cpd+10);
d1820 1
a1820 1
	    sprintf(date+7, " %.4s", cpd+5);
d1826 2
a1827 2
    /** Track down the size **/
    if ((cpd=strchr(cp, '/')) != NULL) {
d1830 1
a1830 1
	while (isdigit(UCH(*(cps-1))))
d1835 1
a1835 1
	cps = cpd+1;
d1839 1
a1839 1
	ialloc = atoi(cpd+1);
d1844 1
a1844 1
    } else if ((cps=strtok(cp, sp)) != NULL) {
d1847 1
a1847 1
	while ((cps=strtok(NULL, sp)) != NULL) {
d1859 5
a1863 5
    /** Wrap it up **/
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d1865 1
a1865 1
} /* parse_vms_dir_entry() */
d1872 2
a1873 3
PRIVATE void parse_ms_windows_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d1879 1
a1879 1
    /**  Get rid of blank or junk lines.  **/
d1886 1
a1886 1
    /** Cut out file or directory name. **/
d1888 1
a1888 1
    *cps++ ='\0';
d1892 1
a1892 1
    /** Track down the size **/
d1906 1
a1906 1
    /* Set the years and date, if we don't have them yet. **/
d1911 1
a1911 1
    /** Track down the date. **/
d1915 4
a1918 4
	    *(cpd+6)  = '\0';  /* Month and Day */
	    *(cpd+11) = '\0';  /* Year */
	    *(cpd+17) = '\0';  /* Time */
	    if (strcmp(ThisYear, cpd+7))
d1920 1
a1920 1
		sprintf(date, "%.6s  %.4s", cpd, (cpd+7));
d1923 1
a1923 1
		sprintf(date, "%.6s %.5s", cpd, (cpd+12));
d1925 1
a1925 1
	    if (entry_info->date[4] == ' '|| entry_info->date[4] == '0') {
d1931 5
a1935 5
    /** Wrap it up **/
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d1937 1
a1937 1
} /* parse_ms_windows_dir_entry */
d1945 2
a1946 3
PRIVATE void parse_windows_nt_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d1953 1
a1953 1
    /**  Get rid of blank or junk lines.  **/
d1960 1
a1960 1
    /** Cut out file or directory name. **/
d1962 2
a1963 2
    cps = LYSkipNonBlanks(end-1);
    cp = (cps+1);
d1974 1
a1974 1
    /* Set the years and date, if we don't have them yet. **/
d1979 1
a1979 1
    /** Cut out the date. **/
d1982 1
a1982 1
    *cps++ ='\0';
d1989 1
a1989 1
    *cps++ ='\0';
d1995 3
a1997 3
	isdigit(*cp) && isdigit(*(cp+1)) && *(cp+2) == '-' &&
	isdigit(*(cp+3)) && isdigit(*(cp+4)) && *(cp+5) == '-') {
	*(cp+2)  = '\0';	/* Month */
d1999 2
a2000 2
	*(cp+5) = '\0';		/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp+3));
d2003 2
a2004 2
	cp += 6;			/* Year */
	if (strcmp((ThisYear+2), cp)) {
d2013 1
a2013 1
	    *(cpd+2) = '\0';	/* Hour */
d2015 1
a2015 1
	    if (*(cpd+5) == 'P' || *(cpd+5) == 'p')
d2017 1
a2017 1
	    sprintf(&date[6], " %02d:%.2s", i, (cpd+3));
d2020 1
a2020 1
	if (entry_info->date[4] == ' '|| entry_info->date[4] == '0') {
d2025 1
a2025 1
    /** Track down the size **/
d2039 1
a2039 1
    /** Wrap it up **/
d2041 3
a2043 3
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d2045 1
a2045 1
} /* parse_windows_nt_dir_entry */
d2053 2
a2054 3
PRIVATE void parse_cms_dir_entry ARGS2(
	char *,		line,
	EntryInfo *,	entry_info)
d2063 1
a2063 1
    /**  Get rid of blank or junk lines.  **/
d2070 1
a2070 1
    /** Cut out file or directory name. **/
d2072 1
a2072 1
    *cps++ ='\0';
d2075 1
a2075 1
	/** If we already have a dot, we did an NLST. **/
d2079 1
a2079 1
	/** If we don't have more, we've misparsed. **/
d2086 1
a2086 1
    *cps++ ='\0';
d2088 1
a2088 1
	/** It's an SFS directory. **/
d2092 1
a2092 1
	/** It's a file. **/
d2097 1
a2097 1
	/** Track down the VM/CMS RECFM or type. **/
d2103 1
a2103 1
	    /** Check cp here, if it's relevant someday. **/
d2107 1
a2107 1
    /** Track down the record length or dash. **/
d2118 1
a2118 1
    /** Track down the number of records or the dash. **/
d2128 1
a2128 1
	    /** Compute an approximate size. **/
d2133 1
a2133 1
    /** Set the years and date, if we don't have them yet. **/
d2138 1
a2138 1
    /** Track down the date. **/
d2143 1
a2143 1
	 isdigit(UCH(*(cps+1))) && isdigit(UCH(*(cps+2))) && *(cps+3) == ':')) {
d2148 3
a2150 3
	    *(cpd+2) = '\0';	/* Month */
	    *(cpd+5) = '\0';	/* Day */
	    *(cpd+8) = '\0';	/* Year */
d2155 1
a2155 1
	    sprintf(date, "%.3s %.2s", months[i], (cpd+3));
d2159 1
a2159 1
	    if (strcmp((ThisYear+2), cpd)) {
d2168 1
a2168 1
		*(cps+2) = '\0';	/* Hour */
d2170 1
a2170 1
		sprintf(&date[6], " %02d:%.2s", i, (cps+3));
d2173 1
a2173 1
	    if (entry_info->date[4] == ' '|| entry_info->date[4] == '0') {
d2179 5
a2183 5
    /** Wrap it up. **/
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
		entry_info->filename,
		NonNull(entry_info->date),
		entry_info->size));
d2185 1
a2185 1
} /* parse_cms_dir_entry */
d2188 2
a2189 3
 *     parse_dir_entry()
 *	Given a line of LIST/NLST output in entry, return results
 *	and a file/dir name in entry_info struct
d2191 1
a2191 1
 *	If first is true, this is the first name in a directory.
d2193 3
a2195 5

PRIVATE EntryInfo * parse_dir_entry ARGS3(
	char *,		entry,
	BOOLEAN *,	first,
	char **,	pspilledname)
d2198 3
a2200 3
    int  i;
    int  len;
    BOOLEAN remove_size=FALSE;
d2203 2
a2204 1
    entry_info = (EntryInfo *)malloc(sizeof(EntryInfo));
d2208 1
d2215 1
a2215 1
	case DLS_SERVER:
d2217 6
a2222 58
	    /*
	    **	Interpret and edit LIST output from a Unix server
	    **  in "dls" format.
	    **  This one must have claimed to be Unix in order to
	    **  get here; if the first line looks fishy, we revert
	    **  to Unix and hope that fits better (this recovery is
	    **  untested). - kw
	    */

	    if (*first) {
		len = strlen(entry);
		if (!len || entry[0] == ' ' ||
		    (len >= 24 && entry[23] != ' ') ||
		    (len < 24 && strchr(entry, ' '))) {
		    server_type = UNIX_SERVER;
		    CTRACE((tfp,
			   "HTFTP: Falling back to treating as Unix server.\n"));
		} else {
		    *first = FALSE;
		}
	    }

	    if (server_type == DLS_SERVER) {
		/* if still unchanged... */
		parse_dls_line(entry, entry_info, pspilledname);

		if (!entry_info->filename || *entry_info->filename == '\0') {
		    entry_info->display = FALSE;
		    return(entry_info);
		}
		if (!strcmp(entry_info->filename,"..") ||
		    !strcmp(entry_info->filename,"."))
		    entry_info->display = FALSE;
		if (entry_info->type && *entry_info->type == '\0') {
		    FREE(entry_info->type);
		    return(entry_info);
		}
		/*
		**	Goto the bottom and get real type.
		*/
		break;
	    } /* fall through if server_type changed for *first == TRUE ! */

	case UNIX_SERVER:
	case PETER_LEWIS_SERVER:
	case MACHTEN_SERVER:
	case MSDOS_SERVER:
	case WINDOWS_NT_SERVER:
	case WINDOWS_2K_SERVER:
	case APPLESHARE_SERVER:
	case NETPRESENZ_SERVER:
	    /*
	    **	Check for EPLF output (local times).
	    */
	    if (*entry == '+') {
		parse_eplf_line(entry, entry_info);
		break;
	    }
d2224 1
a2224 3
	    /*
	    **	Interpret and edit LIST output from Unix server.
	    */
d2226 7
a2232 9
	    if (*first) {
		/* don't gettext() this -- incoming text: */
		if (!strcmp(entry, "can not access directory .")) {
		    /*
		     *	Don't reset *first, nothing real will follow. - KW
		     */
		    entry_info->display = FALSE;
		    return(entry_info);
		}
a2233 10
		if (!strncmp(entry, "total ", 6) ||
		    strstr(entry, "not available") != NULL) {
		    entry_info->display = FALSE;
		    return(entry_info);
		} else if (unsure_type) {
		    /* this isn't really a unix server! */
		    server_type = GENERIC_SERVER;
		    entry_info->display = FALSE;
		    return(entry_info);
		}
d2235 1
d2237 3
a2239 17
	    /*
	    **	Check first character of ls -l output.
	    */
	    if (TOUPPER(entry[0]) == 'D')  {
		/*
		**  It's a directory.
		*/
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
		remove_size=TRUE; /* size is not useful */
	    } else if (entry[0] == 'l') {
		/*
		**  It's a symbolic link, does the user care about
		**  knowing if it is symbolic?	I think so since
		**  it might be a directory.
		*/
		StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
		remove_size=TRUE; /* size is not useful */
d2241 6
a2246 19
		/*
		**  Strip off " -> pathname".
		*/
		for (i = len - 1; (i > 3) &&
				  (!isspace(UCH(entry[i])) ||
				   (entry[i-1] != '>')	||
				   (entry[i-2] != '-') ||
				   (entry[i-3] != ' ')); i--)
		    ; /* null body */
		if (i > 3) {
		    entry[i-3] = '\0';
		    len = i - 3;
		}
	    } /* link */

	    parse_ls_line(entry, entry_info);

	    if (!strcmp(entry_info->filename,"..") ||
		!strcmp(entry_info->filename,"."))
d2248 4
d2253 18
a2270 2
	    **	Goto the bottom and get real type.
	    */
d2272 1
d2274 25
a2298 6
	case VMS_SERVER:
	    /*
	    **	Interpret and edit LIST output from VMS server
	    **	and convert information lines to zero length.
	    */
	    parse_vms_dir_entry(entry, entry_info);
d2300 4
d2305 5
a2309 5
	    **	Get rid of any junk lines.
	    */
	    if (!entry_info->display)
		return(entry_info);

d2311 5
a2315 12
	    **	Trim off VMS directory extensions.
	    */
	    len = strlen(entry_info->filename);
	    if ((len > 4) && !strcmp(&entry_info->filename[len-4], ".dir")) {
		entry_info->filename[len-4] = '\0';
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
		remove_size=TRUE; /* size is not useful */
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
a2316 1
	case MS_WINDOWS_SERVER:
d2318 23
a2340 4
	    **	Interpret and edit LIST output from MS_WINDOWS server
	    **	and convert information lines to zero length.
	    */
	    parse_ms_windows_dir_entry(entry, entry_info);
d2342 47
a2388 13
	    /*
	    **	Get rid of any junk lines.
	    */
	    if (!entry_info->display)
		return(entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return(entry_info);
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2391 6
a2396 6
	case WINDOWS_NT_SERVER:
	    /*
	    **	Interpret and edit LIST output from MS_WINDOWS server
	    **	and convert information lines to zero length.
	    */
	    parse_windows_nt_dir_entry(entry, entry_info);
d2398 13
a2410 13
	    /*
	    **	Get rid of any junk lines.
	    */
	    if (!entry_info->display)
		return(entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return(entry_info);
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2413 2
a2414 2
	case CMS_SERVER:
	  {
d2416 3
a2418 3
	    **	Interpret and edit LIST output from VM/CMS server
	    **	and convert any information lines to zero length.
	    */
d2422 2
a2423 2
	    **	Get rid of any junk lines.
	    */
d2425 1
a2425 1
		return(entry_info);
d2428 1
a2428 1
		return(entry_info);
d2431 2
a2432 2
	    **	Goto the bottom and get real type.
	    */
d2434 1
a2434 1
	  }
d2436 8
a2443 2
	case NCSA_SERVER:
	case TCPC_SERVER:
d2445 10
a2454 16
	    **	Directories identified by trailing "/" characters.
	    */
	    StrAllocCopy(entry_info->filename, entry);
	    len = strlen(entry);
	    if (entry[len-1] == '/') {
		/*
		**  It's a dir, remove / and mark it as such.
		*/
		entry[len-1] = '\0';
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
		remove_size=TRUE; /* size is not useful */
	    }
	    /*
	    **	Goto the bottom and get real type.
	    */
	    break;
d2456 7
a2462 7
	default:
	    /*
	    **	We can't tell if it is a directory since we only
	    **	did an NLST :(	List bad file types anyways?  NOT!
	    */
	    StrAllocCopy(entry_info->filename, entry);
	    return(entry_info); /* mostly empty info */
d2464 1
a2464 1
    } /* switch (server_type) */
d2471 1
a2471 1
	if (((cp=strrchr(entry_info->filename, '.')) != NULL &&
d2475 4
a2478 4
	    **	Don't treat this as application/x-Troff-me
	    **	if it's a Unix server but has the string
	    **	"read.me", or if it's not a Unix server. - FM
	    */
d2488 2
a2489 2
    **	Get real types eventually.
    */
d2491 1
a2491 1
	CONST char *cp2;
d2493 2
a2494 1
	HTAtom * encoding;  /* @@@@ not used at all */
d2498 1
a2498 1
	    if (!strncmp(HTAtom_name(format), "application",11)) {
d2500 1
a2500 1
		if (!strncmp(cp2,"x-",2))
d2510 2
a2511 2
    return(entry_info);
} /* parse_dir_entry */
d2513 1
a2513 3
PRIVATE int compare_EntryInfo_structs ARGS2(
	EntryInfo *,	entry1,
	EntryInfo *,	entry2)
d2518 18
a2535 10
    switch(HTfileSortMethod) {
	case FILE_BY_SIZE:
	    /* both equal or both 0 */
	    if (entry1->size == entry2->size)
		return(strcmp(entry1->filename, entry2->filename));
	    else
		if (entry1->size > entry2->size)
		    return(1);
		else
		    return(-1);
d2537 14
a2550 6
	case FILE_BY_TYPE:
	    if (entry1->type && entry2->type) {
		status = strcasecomp(entry1->type, entry2->type);
		if (status)
		    return(status);
		/* else fall to filename comparison */
d2552 9
a2560 9
	    return (strcmp(entry1->filename, entry2->filename));

	case FILE_BY_DATE:
	    if (entry1->date && entry2->date) {
		/*
		** Make sure we have the correct length. - FM
		*/
		if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		    return(strcmp(entry1->filename, entry2->filename));
d2562 9
a2570 6
		/*
		** Set the years and date,
		** if we don't have them yet.
		*/
		if (!HaveYears) {
		    set_years_and_date();
d2572 16
a2587 13
		/*
		** Set up for sorting in reverse
		** chronological order. - FM
		*/
		if (entry1->date[9] == ':') {
		    strcpy(date1, "9999");
		    strcpy(time1, &entry1->date[7]);
		    if (time1[0] == ' ') {
			 time1[0] = '0';
		    }
		} else {
		    strcpy(date1, &entry1->date[8]);
		    strcpy(time1, "00:00");
d2589 7
a2595 6
		strncpy(month, entry1->date, 3);
		month[3] = '\0';
		for (i = 0; i < 12; i++) {
		    if (!strcasecomp(month, months[i])) {
			break;
		    }
d2597 9
a2605 16
		i++;
		sprintf(month, "%02d", i);
		strcat(date1, month);
		strncat(date1, &entry1->date[4], 2);
		date1[8] = '\0';
		if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		    date1[6] = '0';
		}
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		    for (i = 0; i < 4; i++) {
			date1[i] = LastYear[i];
		    }
d2607 16
a2622 17
		strcat(date1, time1);
		if (entry2->date[9] == ':') {
		    strcpy(date2, "9999");
		    strcpy(time2, &entry2->date[7]);
		    if (time2[0] == ' ') {
			time2[0] = '0';
		    }
		} else {
		    strcpy(date2, &entry2->date[8]);
		    strcpy(time2, "00:00");
		}
		strncpy(month, entry2->date, 3);
		month[3] = '\0';
		for (i = 0; i < 12; i++) {
		    if (!strcasecomp(month, months[i])) {
			break;
		    }
a2623 25
		i++;
		sprintf(month, "%02d", i);
		strcat(date2, month);
		strncat(date2, &entry2->date[4], 2);
		date2[8] = '\0';
		if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		    date2[6] = '0';
		}
		/*  If no year given, assume last year if it would otherwise
		 *  be in the future by more than one day.  The one day
		 *  tolerance is to account for a possible timezone
		 *  difference. - kw */
		if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		    for (i = 0; i < 4; i++) {
			date2[i] = LastYear[i];
		    }
		}
		strcat(date2, time2);
		/*
		** Do the comparison. - FM
		*/
		status = strcasecomp(date2, date1);
		if (status)
		    return(status);
		/* else fall to filename comparison */
d2625 10
a2634 1
	    return (strcmp(entry1->filename, entry2->filename));
d2636 3
a2638 3
	case FILE_BY_NAME:
	default:
	    return (strcmp(entry1->filename, entry2->filename));
a2641 1

d2643 13
a2655 14
**	--------------------------------------------------------------
**
** On entry,
**	anchor		Parent anchor to link the this node to
**	address		Address of the directory
** On exit,
**	returns		HT_LOADED if OK
**			<0 if error.
*/
PRIVATE int read_directory ARGS4(
	HTParentAnchor *,	parent,
	CONST char *,		address,
	HTFormat,		format_out,
	HTStream *,		sink)
d2659 1
a2659 1
    HTStructured* target = HTML_new(parent, format_out, sink);
d2665 1
a2665 1
    char *lastpath = NULL;/* prefix for link, either "" (for root) or xxx  */
d2671 1
a2671 1
    _HTProgress (gettext("Receiving FTP directory."));
d2674 3
a2676 4
     *  Force the current Date and Year (TheDate, ThisYear, and LastYear)
     *  to be recalculated for each directory request.  Otherwise we have
     *  a problem with long-running sessions assuming the wrong date for
     *  today. - kw
d2680 3
a2682 3
    **	Check whether we always want the home
    **	directory treated as Welcome. - FM
    */
d2687 5
a2691 7
    **	This should always come back FALSE, since the
    **	flag is set only for local directory listings
    **	if LONG_LIST was defined on compilation, but
    **	we could someday set up an equivalent listing
    **	for Unix ftp servers. - FM
    */
    need_parent_link = HTDirTitles(target, parent, tildeIsTop);
d2695 4
a2698 4
    if (*filename == '\0') {		  /* Empty filename: use root. */
	StrAllocCopy (lastpath, "/");
    } else if (!strcmp(filename,"/")) {   /* Root path. */
	StrAllocCopy (lastpath, "/foo/..");
d2700 1
a2700 1
	char * p = strrchr(filename, '/');	     /* Find the lastslash. */
d2704 1
a2704 1
	    StrAllocCopy(lastpath, filename); /* Use absolute path for CMS. */
d2706 1
a2706 1
	    StrAllocCopy(lastpath, p+1);   /* Take slash off the beginning. */
d2708 5
a2712 5
	if ((cp = strrchr(lastpath, ';')) != NULL) {   /* Trim type= param. */
	    if (!strncasecomp((cp+1), "type=", 5)) {
		if (TOUPPER(*(cp+6)) == 'D' ||
		    TOUPPER(*(cp+6)) == 'A' ||
		    TOUPPER(*(cp+6)) == 'I')
d2717 1
a2717 1
    FREE (filename);
d2720 1
a2720 1
	HTBTree * bt = HTBTree_new((HTComparer)compare_EntryInfo_structs);
d2722 1
a2722 1
	HTChunk * chunk = HTChunkCreate(128);
d2727 2
a2728 1
	PUTC('\n');  /* prettier LJM */
d2734 2
a2735 2
		       "read_directory: interrupted after %d bytes\n",
		       BytesReceived));
d2747 1
a2747 1
	    /*	 read directory entry
d2750 1
a2750 1
	    for (;;) {			/* Read in one line as filename */
d2752 1
a2752 1
AgainForMultiNet:
d2755 2
a2756 2
			   "read_directory: interrupted_in_next_data_char after %d bytes\n",
			   BytesReceived));
d2759 1
a2759 1
			goto unload_btree;  /* unload btree */
d2766 2
a2767 2
		} else if ((char)ic == CR || (char)ic == LF) {    /* Terminator? */
		    if (chunk->size != 0) {  /* got some text */
d2770 1
a2770 1
			/* Deal with MultiNet's wrapping of long lines - F.M. */
d2772 1
a2772 1
				*(data_read_pointer+1) == ' ')
d2791 1
a2791 2
			    }
			    else
d2793 1
a2793 2
			}
			else
d2797 1
a2797 1
		    break;		/* End of file */
d2799 1
a2799 1
		    HTChunkPutc(chunk, (char)ic);
d2807 2
a2808 2
		sprintf(NumBytes,gettext("Transferred %d bytes (%5d)"),
				BytesReceived, ws_read_per_sec);
d2817 1
a2817 1
	    /* 1 means empty: includes terminating 0 */
d2820 1
a2820 1
			lastpath, chunk->data));
d2826 1
a2826 1
			    entry_info->filename));
d2833 1
a2833 1
	}  /* next entry */
d2835 1
a2835 1
unload_btree:
d2840 1
a2840 1
	/* print out the handy help message if it exits :) */
d2856 1
a2856 1
	/* PUTS("    Date	 Type		  Size	   Filename\n");
d2862 1
a2862 1
#ifdef SH_EX	/* 1997/10/18 (Sat) 14:14:28 */
d2864 1
a2864 1
	    int  name_len, dot_len;
d2867 1
a2867 1
#define	FILE_GAP	2
d2870 1
a2870 1
	    HTBTElement * ele;
d2872 1
d2876 1
a2876 1
		entry_info = (EntryInfo *)HTBTree_object(ele);
d2894 1
a2894 1
#ifdef SH_EX	/* 1997/10/18 (Sat) 16:00 */
d2897 1
a2897 1
		sprintf(name_buff, "%-30s", entry_info->filename);
d2903 1
a2903 1
			while (dot_len--)
d2917 1
a2917 1
#ifdef SH_EX	/* 1998/02/02 (Mon) 16:34:52 */
d2920 1
a2920 1
					       entry_info->size);
d2923 1
a2923 1
						entry_info->size/1024);
d2926 2
a2927 2
			sprintf(string_buffer, "  %d bytes",
					       entry_info->size);
d2929 2
a2930 2
			sprintf(string_buffer, "  %dKb",
						entry_info->size/1024);
d2933 3
d2938 1
a2938 1
		PUTC('\n'); /* end of this entry */
d2944 1
d2951 1
a2951 1
    if (WasInterrupted || data_soc != -1) { /* should always be true */
d2953 4
a2956 5
	 *  Without closing the data socket first,
	 *  the response(0) later may hang.
	 *  Some servers expect the client to fin/ack the close
	 *  of the data connection before proceeding with the
	 *  conversation on the control connection. - kw
d2974 2
a2975 3
PRIVATE int setup_connection ARGS2(
	CONST char *,		name,
	HTParentAnchor *,	anchor)
d2978 3
a2980 1
    int status;
d2988 1
d2990 1
a2990 1
    for (retry = 0; retry < 2; retry++) { /* For timed out/broken connections */
d2992 3
a2994 2
	if (status < 0)
	    return status;
d2999 1
a2999 1
		NETCLOSE (control->socket);
d3003 1
a3003 1
		    (void)close_master_socket ();
d3005 1
a3005 1
		close_master_socket ();
d3009 1
a3009 1
		return status;
a3010 1

d3012 2
a3013 2
	    /*	Inform the server of the port number we will listen on
	    */
d3017 2
a3018 2
		_HTProgress (CONNECTION_INTERRUPTED);
		NETCLOSE (control->socket);
d3020 3
a3022 2
		close_master_socket ();
		return HT_INTERRUPTED;
d3024 1
a3024 1
	    if (status != 2) {		/* Could have timed out */
d3026 3
a3028 2
		    continue;		/* try again - net error*/
		return -status;		/* bad reply */
d3034 3
a3036 2
	    char *p;
	    int h0, h1, h2, h3, p0, p1;	/* Parts of reply */
d3038 1
a3038 1
	    char dst[LINE_LENGTH+1];
d3044 5
a3048 1
	    status = send_cmd_1(p = "EPSV");
d3053 1
a3053 1
		if (status < 0)	/* retry or Bad return */
d3055 3
a3057 2
		else if (status != 2) {
		    return -status;	/* bad reply */
d3062 3
a3064 2
		for (p = response_text; *p && *p != ','; p++)
		    ; /* null body */
d3066 5
a3070 4
		while (--p > response_text && '0' <= *p && *p <= '9')
		    ; /* null body */
		status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
		       &h0, &h1, &h2, &h3, &p0, &p1);
d3073 2
a3074 1
		    return -99;
d3076 1
a3076 1
		passive_port = (p0<<8) + p1;
d3079 1
a3079 1
		unsigned char c0, c1, c2, c3;
d3081 1
a3081 1
		int sslen;
d3086 7
a3092 4
		for (p = response_text; *p && !isspace(*p); p++)
		    ; /* null body */
		for (/*nothing*/; *p && *p && *p != '('; p++)	/*)*/
		    ; /* null body */
d3096 2
a3097 1
		    return -99;
d3102 2
a3103 2
		if (getpeername(control->socket, (struct sockaddr *)&ss,
		    &sslen) < 0) {
d3105 2
a3106 1
		    return -99;
d3108 2
a3109 2
		if (getnameinfo((struct sockaddr *)&ss, sslen, dst,
		    sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
d3111 2
a3112 1
		    return -99;
d3119 6
a3124 2
		    continue;		/* retry or Bad return */
		return -status;		/* bad reply */
a3125 2
	    for (p = response_text; *p && *p != ','; p++)
		; /* null body */
d3127 3
a3129 2
	    while (--p > response_text && '0' <= *p && *p <= '9')
		; /* null body */
d3131 1
a3131 1
	    status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
d3135 2
a3136 1
		return -99;
d3138 1
a3138 1
	    passive_port = (PortNumber)((p0<<8) + p1);
d3141 1
a3141 1
			 passive_port));
d3149 1
a3149 1
		    STR_FTP_URL, h0, h1, h2, h3, passive_port);
d3157 1
a3157 1
		return status;			/* Bad return */
d3163 1
a3163 1
	break;	/* No more retries */
d3165 2
a3166 1
    } /* for retries */
d3171 12
a3182 13
**	-------------------------
**
** On entry,
**	name		WWW address of a file: document, including hostname
** On exit,
**	returns		Socket number for file if good.
**			<0 if bad.
*/
PUBLIC int HTFTPLoad ARGS4(
	CONST char *,		name,
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
d3185 1
a3185 1
    HTAtom * encoding = NULL;
d3188 1
d3193 5
a3197 1
    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n", name, ftp_local_passive ? "passive" : "normal"));
d3199 1
a3199 1
    HTReadProgress(0,0);
d3205 2
a3206 2
/*	Ask for the file:
*/
d3209 1
a3209 1
	char *fname = filename; /** Save for subsequent free() **/
d3212 2
a3213 1
	char *type = NULL;
d3217 1
a3217 1
	    /** If the unescaped path has a %2f, reject it as illegal. - FM **/
d3221 1
a3221 1
		init_help_message_cache();  /* to free memory */
d3224 2
a3225 1
		CTRACE((tfp, "HTFTP: Rejecting path due to illegal escaped slash.\n"));
d3233 1
a3233 1
	} else if ((type = strrchr(filename, ';')) != NULL) {
d3235 4
a3238 4
	    **	Check and trim the type= parameter. - FM
	    */
	    if (!strncasecomp((type+1), "type=", 5)) {
		switch(TOUPPER(*(type+6))) {
d3240 1
a3240 1
		    *type = '\0';
d3244 1
a3244 1
		    *type = '\0';
d3248 1
a3248 1
		    *type = '\0';
d3257 1
a3257 1
		    *(filename+1) = '\0';
d3268 3
a3270 3
	    ** Check if translation of HOME as tilde is supported,
	    ** and adjust filename if so. - FM
	    */
d3274 1
a3274 1
	    if ((cp2 = strchr((filename+1), '/')) != NULL) {
d3279 1
a3279 1
		status = send_cwd(filename+1);
d3281 1
a3281 1
		    StrAllocCopy(fn, (filename+1));
d3284 1
a3284 1
			if (fn[strlen(fn)-1] != '/') {
d3287 1
a3287 1
			    StrAllocCat(fn, (cp2+1));
d3301 2
a3302 1
	    if (((cp2=strrchr(filename, '.')) != NULL &&
d3306 4
a3309 4
		**  Don't treat this as application/x-Troff-me
		**  if it's a Unix server but has the string
		**  "read.me", or if it's not a Unix server. - FM
		*/
d3327 1
a3327 1
		  encoding != HTAtom_for("7bit"));
d3329 6
a3334 7
	    /*
	    **	Force binary if we're in source, download or dump
	    **	mode and this is not a VM/CMS server, so we don't
	    **	get CRLF instead of LF (or CR) for newlines in text
	    **	files.	Can't do this for VM/CMS or we'll get
	    **	raw EBCDIC.  - FM
	    */
d3342 2
a3343 2
	    **	Force binary if we had ;type=I - FM
	    */
d3347 2
a3348 2
	    **	Force ASCII if we had ;type=A - FM
	    */
d3353 4
a3356 3
	    **	Act on our setting if not already set. - FM
	    */
	    char * mode = binary ? "I" : "A";
d3359 1
a3359 1
		init_help_message_cache();  /* to free memory */
d3365 5
a3369 5
	/*
	**  Handle what for Lynx are special case servers, e.g.,
	**  for which we respect RFC 1738, or which have known
	**  conflicts in suffix mappings. - FM
	*/
d3371 56
a3426 35
	  {
	    char *cp1, *cp2;
	    BOOL included_device = FALSE;
	    BOOL found_tilde = FALSE;
	    /** Accept only Unix-style filename **/
	    if (strchr(filename, ':') != NULL ||
		strchr(filename, '[') != NULL) {
		FREE(fname);
		init_help_message_cache();  /* to free memory */
		NETCLOSE(control->socket);
		control->socket = -1;
		CTRACE((tfp, "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		return -1;
	    }
	    /** Handle any unescaped "/%2F" path **/
	    if (!strncmp(filename, "//", 2)) {
		int i;
		included_device = TRUE;
		for (i = 0; filename[(i+1)]; i++)
		    filename[i] = filename[(i+1)];
		filename[i] = '\0';
		CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		cp = HTVMS_name("", filename);
		CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		if ((cp1=strrchr(cp, ']')) != NULL) {
		    strcpy(filename, ++cp1);
		    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
		    *cp1 = '\0';
		    status = send_cwd(cp);
		    if (status != 2) {
			char *dotslash = 0;
			if ((cp1=strchr(cp, '[')) != NULL) {
			    *cp1++ = '\0';
			    status = send_cwd(cp);
			    if (status != 2) {
d3428 1
a3428 1
				init_help_message_cache(); /* to free memory */
d3433 36
a3468 3
			    HTSprintf0(&dotslash, "[.%s", cp1);
			    status = send_cwd(dotslash);
			    FREE(dotslash);
d3471 1
a3471 1
				init_help_message_cache(); /* to free memory */
a3475 6
			} else {
			    FREE(fname);
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
d3477 2
d3480 25
a3504 23
		} else if ((cp1=strchr(cp, ':')) != NULL &&
			   strchr(cp, '[') == NULL &&
			   strchr(cp, ']') == NULL) {
		    cp1++;
		    if (*cp1 != '\0') {
			strcpy(filename, cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			HTSprintf0(&vmsname, "%.*s[%s]", cp1-cp, cp, filename);
			status = send_cwd(vmsname);
			if (status != 2) {
			    HTSprintf(&vmsname, "%.*s[000000]", cp1-cp, cp);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				HTSprintf(&vmsname, "%.*s", cp1-cp, cp);
				status = send_cwd(vmsname);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    }
d3506 1
a3506 2
			    HTSprintf0(&vmsname, "000000");
			    filename = vmsname;
d3508 6
a3513 6
		    }
		} else if (0==strcmp(cp, (filename+1))) {
		    status = send_cwd(cp);
		    if (status != 2) {
			HTSprintf0(&vmsname, "%s:", cp);
			status = send_cwd(vmsname);
a3521 2
		    HTSprintf0(&vmsname, "000000");
		    filename = vmsname;
d3523 8
a3530 10
	    }
	    /** Trim trailing slash if filename is not the top directory **/
	    if (strlen(filename) > 1 && filename[strlen(filename)-1] == '/')
		filename[strlen(filename)-1] = '\0';

#ifdef MAINTAIN_CONNECTION /* Don't need this if always new connection - F.M. */
	    if (!included_device) {
		/** Get the current default VMS device:[directory] **/
		status = send_cmd_1("PWD");
		if (status != 2) {
d3532 9
a3540 4
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
d3542 10
a3551 3
		/** Go to the VMS account's top directory **/
		if ((cp=strchr(response_text, '[')) != NULL &&
		    (cp1=strrchr(response_text, ']')) != NULL) {
a3552 1
		    unsigned len = 4;
d3554 6
a3559 8
		    StrAllocCopy(tmp, cp);
		    if ((cp2=strchr(cp, '.')) != NULL && cp2 < cp1) {
			len += (cp2 - cp);
		    } else {
			len += (cp1 - cp);
		    }
		    tmp[len] = 0;
		    StrAllocCat(tmp, "]");
d3566 1
a3566 1
			init_help_message_cache();  /* to free memory */
d3571 5
d3577 1
d3579 28
a3606 42
#endif /* MAINTAIN_CONNECTION */

	    /** If we want the VMS account's top directory, list it now **/
	    if (!(strcmp(filename, "/~")) ||
		(included_device && 0==strcmp(filename, "000000")) ||
		(strlen(filename) == 1 && *filename == '/')) {
		isDirectory = YES;
		status = send_cmd_1("LIST");
		FREE(fname);
		if (status != 1) {
		    /* Action not started */
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
		}
		/** Big goto! **/
		goto listen;
	    }
	    /** Otherwise, go to appropriate directory and doctor filename **/
	    if (!strncmp(filename, "/~", 2)) {
		filename += 2;
		found_tilde = TRUE;
	    }
	    CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
	    if (!included_device &&
		(cp = strchr(filename, '/')) != NULL &&
		(cp1 = strrchr(cp, '/')) != NULL &&
		(cp1 - cp) > 1) {
		char *tmp = 0;

		HTSprintf0(&tmp, "[.%.*s]", cp1-cp-1, cp+1);

		CTRACE((tfp, "change path '%s'\n", tmp));
		while ((cp2 = strrchr(tmp, '/')) != NULL)
		    *cp2 = '.';
		CTRACE((tfp, "...to  path '%s'\n", tmp));

		status = send_cwd(tmp);
		FREE(tmp);

		if (status != 2) {
d3608 1
a3608 29
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
		}
		filename = cp1+1;
	    } else {
		if (!included_device && !found_tilde) {
		    filename += 1;
		}
	    }
	    break;
	  }
	case CMS_SERVER:
	  {
	    /*
	    **	If we want the CMS account's top directory, or a base
	    **	SFS or anonymous directory path (i.e., without a slash),
	    **	list it now. FM
	    */
	    if ((strlen(filename) == 1 && *filename == '/') ||
		((0 == strncasecomp((filename+1), "vmsysu:", 7)) &&
		 (cp = strchr((filename+1), '.')) != NULL &&
		 strchr(cp, '/') == NULL) ||
		(0 == strncasecomp(filename+1, "anonymou.", 9) &&
		 strchr(filename+1, '/') == NULL)) {
		if (filename[1] != '\0') {
		    status = send_cwd(filename+1);
		    if (status != 2) {
d3610 1
a3610 1
			init_help_message_cache();  /* to free memory */
d3615 2
d3618 1
a3618 17
		isDirectory = YES;
		if (use_list)
		    status = send_cmd_1("LIST");
		else
		    status = send_cmd_1("NLST");
		FREE(fname);
		if (status != 1) {
		    /* Action not started */
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return ((status < 0) ? status : -status);
		}
		/** Big goto! **/
		goto listen;
	    }
	    filename++;
d3620 23
a3642 18
	    /** Otherwise, go to appropriate directory and adjust filename **/
	    while ((cp = strchr(filename, '/')) != NULL) {
		*cp++ = '\0';
		status = send_cwd(filename);
		if (status == 2) {
		    if (*cp == '\0') {
			isDirectory = YES;
			if (use_list)
			    status = send_cmd_1("LIST");
			else
			    status = send_cmd_1("NLST");
			FREE(fname);
			if (status != 1) {
			    /** Action not started **/
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
d3644 1
a3644 4
			/** Clear any messages from the login directory **/
			init_help_message_cache();
			/** Big goto! **/
			goto listen;
a3645 1
		    filename = cp;
d3647 1
a3648 2
	    break;
	  }
d3650 1
a3650 1
	    /** Shift for any unescaped "/%2F" path **/
d3656 3
a3658 3
	**  Act on a file or listing request, or try to figure out
	**  which we're dealing with if we don't know yet. - FM
	*/
d3682 1
a3682 1
	    /** Clear any login messages if this isn't the login directory **/
d3708 2
a3709 2
listen:
    if(!ftp_local_passive) {
d3713 1
d3717 2
a3718 1
	int	soc_addrlen=sizeof(soc_address);
d3722 2
a3723 2
			     (struct sockaddr *)&soc_address,
			     (void *)&soc_addrlen);
d3726 3
a3728 3
	status = accept(master_socket,
			(struct sockaddr *)&soc_address,
			(void *)&soc_addrlen);
d3735 3
a3737 3
    } /* !ftp_local_passive */

#if 0	/* no - this makes the data connection go away too soon (2.8.3dev.22) */
d3749 1
a3749 1
	final_status = read_directory (anchor, name, format_out, sink);
d3765 1
a3765 1
	if (data_soc != -1) { /* normally done in read_directory */
d3776 1
a3776 1
	/** Clear any login messages **/
d3779 1
a3779 1
	/** Fake a Content-Encoding for compressed files. - FM **/
d3783 2
a3784 3
	     *	We already know from the call to HTFileFormat above that
	     *	this is a compressed file, no need to look at the filename
	     *	again. - kw
d3791 2
a3792 2
	    char *dot;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &dot);
d3795 1
a3795 1
		*dot = '\0';
d3808 3
d3814 1
a3814 1
		default:
d3821 1
a3821 1
	_HTProgress (gettext("Receiving FTP file."));
d3828 1
a3828 1
#if 0	/* any known servers where ABOR would work this way? */
d3845 1
a3845 1
	    status = 2;	/* data_soc already closed in HTCopy - kw */
d3851 1
a3851 1
		status = response(0);		/* Pick up final reply */
d3853 2
a3854 2
		    data_soc = -1;		/* invalidate it */
		    init_help_message_cache();  /* to free memory */
d3870 1
a3870 1
    data_soc = -1;			/* invalidate it */
d3881 2
a3882 2
    init_help_message_cache();  /* to free memory */
      /* returns HT_LOADED (always for file if we get here) or error */
d3884 1
a3884 1
} /* open_file_read */
d3887 4
a3890 4
**  This function frees any user entered password, so that
**  it must be entered again for a future request. - FM
*/
PUBLIC void HTClearFTPPassword NOARGS
d3893 4
a3896 5
    **	Need code to check cached documents from
    **	non-anonymous ftp accounts and do something
    **	to ensure that they no longer can be accessed
    **	without a new retrieval. - FM
    */
d3899 2
a3900 3
    **	Now free the current user entered password,
    **	if any. - FM
    */
@


1.6
log
@Re-include a patch missed in the recent upgrade:
When passive FTP fails, switch to active FTP and try again

Submitted by Andrew Basterfield <bob@@cemetery.homeunix.org>
@
text
@a59 4
#if defined(DJGPP) && !defined(WATT32)
#define u_long unsigned long
#endif

d66 1
d96 1
a96 1
    u_long			addr;	/* IP address		*/
d105 7
a111 6
#define PUTC(c) (*targetClass.put_character)(target, c)
#define PUTS(s) (*targetClass.put_string)(target, s)
#define START(e) (*targetClass.start_element)(target, e, 0, 0, -1, 0)
#define END(e) (*targetClass.end_element)(target, e, 0)
#define FREE_TARGET (*targetClass._free)(target)
#define ABORT_TARGET (*targetClass._free)(target)
d121 1
a126 5
#ifdef SOCKS
extern BOOLEAN socks_flag;
extern unsigned long socks_bind_remoteAddr;
#endif /* SOCKS */
extern char *personal_mail_address;
d138 9
d369 1
d488 6
d808 2
a809 2
    CTRACE((tfp, "FTP connected, socket %d  control %ld\n",
		con->socket, (long)con));
d888 1
a888 1
		if ((cp=getenv("USER")) != NULL)
d1802 1
a1802 1
		entry_info->date ? entry_info->date : "",
d1875 1
a1875 1
		entry_info->date ? entry_info->date : "",
d1984 1
a1984 1
		entry_info->date ? entry_info->date : "",
d2125 1
a2125 1
		entry_info->date ? entry_info->date : "",
d2645 1
a2645 1
    need_parent_link = HTDirTitles(target, (HTAnchor*)parent, tildeIsTop);
a2672 1

a2761 2
		extern int ws_read_per_sec;

d2782 1
a2782 1
		HTBTree_add(bt, (EntryInfo *)entry_info);
d2922 4
a2925 10
/*	Retrieve File from Server
**	-------------------------
**
** On entry,
**	name		WWW address of a file: document, including hostname
** On exit,
**	returns		Socket number for file if good.
**			<0 if bad.
*/
PUBLIC int HTFTPLoad ARGS4(
d2927 1
a2927 3
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream *,		sink)
a2928 3
    BOOL isDirectory = NO;
    HTAtom * encoding = NULL;
    int status, final_status;
d2930 1
a2930 4
    int outstanding = 1;	/* outstanding control connection responses
				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;
d2937 1
a2937 1
    HTReadProgress(0,0);
d3015 1
a3015 1
		snprintf(dst, sizeof(dst), "%d.%d.%d.%d", h0, h1, h2, h3);
d3074 1
a3074 1
	    HTSprintf0(&command, "ftp://%s:%d/", dst, passive_port);
d3076 2
a3077 2
	    HTSprintf0(&command, "ftp://%d.%d.%d.%d:%d/",
		    h0, h1, h2, h3, passive_port);
d3094 31
d3575 17
@


1.5
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d2951 1
a2951 1
	if (!ftp_passive) {
d3582 1
a3582 1
    if(!ftp_passive) {
d3606 1
a3606 1
    } /* !ftp_passive */
@


1.4
log
@default to passive, upgrade to active as needed; Andrew Basterfield
list@@lostgeneration.freeserve.co.uk
@
text
@d60 1
a60 1
#ifdef DJGPP
d69 2
a70 3

/* this define should be in HTFont.h :( */
#define HT_NON_BREAK_SPACE ((char)1)   /* For now */
a81 3
#define COMMAND_LENGTH 256

#define INFINITY 512
a83 1
#include <HTTCP.h>
a103 4
#ifndef NIL
#define NIL 0
#endif /* !NIL */

d144 18
a161 14
#define GENERIC_SERVER	   0
#define MACHTEN_SERVER	   1
#define UNIX_SERVER	   2
#define VMS_SERVER	   3
#define CMS_SERVER	   4
#define DCTS_SERVER	   5
#define TCPC_SERVER	   6
#define PETER_LEWIS_SERVER 7
#define NCSA_SERVER	   8
#define WINDOWS_NT_SERVER  9
#define MS_WINDOWS_SERVER 10
#define MSDOS_SERVER	  11
#define APPLESHARE_SERVER 12
#define NETPRESENZ_SERVER 13
d163 1
a163 1
PRIVATE int	server_type = GENERIC_SERVER;	/* the type of ftp host */
d170 1
a170 1
PRIVATE unsigned short	port_number = FIRST_TCP_PORT;
d177 1
a177 1
PRIVATE unsigned short	passive_port;	/* Port server specified for data */
d207 1
a207 1
/* PUBLIC						HTMake_VMS_name()
d218 1
a218 1
PUBLIC char * HTMake_VMS_name ARGS2(
d230 1
a230 1
    static char vmsname[INFINITY];	/* returned */
d263 1
a263 1
	sprintf(vmsname, "%s%s", nodename, filename + 1);
d266 1
a266 1
	sprintf(vmsname, "%s%s:%s", nodename, filename+1, second+1);
d272 1
a272 1
	sprintf(vmsname, "%s%s:[%s]%s",
d305 1
a305 1
    return (unsigned char)(*data_read_pointer++);
d317 4
a320 3
    int status = NETCLOSE(con->socket);
    if (TRACE) {
	CTRACE(tfp, "HTFTP: Closing control socket %d\n", con->socket);
d322 4
a325 2
	if (status != 0)
	    perror("HTFTP:close_connection");
d359 1
a359 1
    CTRACE(tfp,"Adding message to help cache: %s\n",string);
d371 2
a372 7
/*	Execute Command and get Response
**	--------------------------------
**
**	See the state machine illustrated in RFC959, p57. This implements
**	one command/reply sequence.  It also interprets lines which are to
**	be continued, which are marked with a "-" immediately after the
**	status code.
d374 2
a375 2
**	Continuation then goes on until a line with a matching reply code
**	an a space after it.
d378 2
a379 2
**	con	points to the connection which is established.
**	cmd	points to a command, or is NIL to just get the response.
d381 1
a381 1
**	The command is terminated with the CRLF pair.
d384 3
a386 2
**	returns:  The first digit of the reply type,
**		  or negative for communication failure.
d388 1
a388 1
PRIVATE int response ARGS1(
a390 2
    int result;				/* Three-digit decimal code */
    int continuation_response = -1;
d394 1
a394 1
	CTRACE(tfp, "HTFTP: No control connection set up!!\n");
d399 1
a399 1
	CTRACE(tfp, "  Tx: %s", cmd);
d410 2
a411 2
	    CTRACE(tfp, "HTFTP: Error %d sending command: closing socket %d\n",
			status, control->socket);
d416 33
d454 1
a454 1
	    if (((*p++ = ich) == LF)
d460 1
a460 1
		    CTRACE (tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
d467 1
a467 1
		CTRACE(tfp, "    Rx: %s", response_text);
d488 1
a488 1
		CTRACE (tfp, "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
d495 2
a496 2
		CTRACE(tfp, "Error on rx: closing socket %d\n",
			    control->socket);
d506 2
a507 2
	CTRACE(tfp, "HTFTP: They close so we close socket %d\n",
		    control->socket);
d549 1
a549 1
	int,		ServerType)
d568 1
a568 1
	int *,		ServerType,
d584 1
a584 1
	    CTRACE(tfp, "HTFTP: Treating as %s server.\n",
d586 1
a586 1
						 "NCSA" : "TCPC"));
d593 1
a593 1
		CTRACE(tfp, "HTFTP: Treating as NCSA server.\n");
d597 1
a597 1
		 CTRACE(tfp, "HTFTP: Treating as Unix server.\n");
d604 1
a604 1
	    CTRACE(tfp, "HTFTP: Treating as VMS server.\n");
d607 1
a607 1
	    CTRACE(tfp, "HTFTP: Treating as Generic server.\n");
d618 39
d707 1
a707 1
	con = (connection *)calloc(1, sizeof(connection));
d718 1
d775 1
a775 1
	    CTRACE (tfp, "HTFTP: Interrupted on connect\n");
d777 2
a778 2
	    CTRACE(tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
			arg);
d798 2
a799 2
    CTRACE(tfp, "FTP connected, socket %d  control %ld\n",
		con->socket, (long)con);
d812 1
a812 1
	CTRACE (tfp, "HTFTP: Interrupted at beginning of login.\n");
d841 1
a841 1
	    CTRACE (tfp, "HTFTP: Interrupted while sending username.\n");
d898 1
a898 2
	    CTRACE (tfp,
		       "HTFTP: Interrupted while sending password.\n");
d910 1
a910 1
	    CTRACE (tfp, "HTFTP: Interrupted while sending password.\n");
d919 1
a919 1
	CTRACE(tfp, "HTFTP: Login fail: %s", response_text);
d923 1
a923 1
    CTRACE(tfp, "HTFTP: Logged in.\n");
d935 1
a935 1
	    CTRACE(tfp, "HTFTP: Treating as MachTen server.\n");
d940 1
d942 1
a942 1
	    CTRACE(tfp, "HTFTP: Treating as Unix server.\n");
d947 1
a947 1
	    CTRACE(tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n");
d950 1
a950 1
	    server_type = VMS_SERVER;
d952 9
a960 1
	    CTRACE(tfp, "HTFTP: Treating as VMS server.\n");
d966 1
a966 1
	    CTRACE(tfp, "HTFTP: Treating as CMS server.\n");
d970 1
a970 1
	    CTRACE(tfp, "HTFTP: Treating as DCTS server.\n");
d974 1
a974 1
	    CTRACE(tfp, "HTFTP: Looks like a TCPC server.\n");
d981 1
a981 1
	    CTRACE(tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n");
d987 1
a987 1
	    CTRACE(tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n");
d991 7
a997 2
	    use_list = TRUE;
	    CTRACE(tfp, "HTFTP: Treating as Window_NT server.\n");
d1002 1
a1002 1
	    CTRACE(tfp, "HTFTP: Treating as MS Windows server.\n");
d1009 1
a1009 1
	    CTRACE(tfp, "HTFTP: Treating as AppleShare server.\n");
d1013 1
a1013 1
	    CTRACE(tfp, "HTFTP: Ugh!  A Generic server.\n");
d1032 1
a1032 1
	CTRACE(tfp, "HTFTP: Port defined.\n");
d1051 1
a1051 1
    CTRACE(tfp, "HTFTP: Closed master socket %d\n", master_socket);
d1076 6
d1084 1
d1096 11
d1109 3
d1113 1
d1118 1
a1118 1
    CTRACE(tfp, "HTFTP: Opened master socket number %d\n", new_socket);
d1122 18
d1142 1
d1145 1
a1145 1
	unsigned short old_port_number = port_number;
d1153 3
d1157 1
d1163 1
a1163 1
			sizeof(soc_address)
d1167 1
a1167 1
						)) == 0)
d1169 1
a1169 1
	    else
d1174 2
a1175 1
		    sizeof(soc_address))) == 0)
d1177 3
a1179 2
	    CTRACE(tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		port_number, status, SOCKET_ERRNO);
d1197 8
a1204 2
	CTRACE(tfp, "HTFTP: This host is %s\n",
	    HTInetString(soc_in));
d1207 1
d1215 3
d1219 1
d1227 2
a1228 1
		    sizeof(soc_address));
d1246 2
a1247 1
    CTRACE(tfp, "HTFTP: bound to port %d on %s\n",
d1249 6
a1254 1
		HTInetString(soc_in));
d1259 1
a1259 1
#endif /* REPEAD_LISTEN */
d1266 5
a1270 1
    sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
d1279 20
d1300 4
a1303 4
/*	Inform TCP that we will accept connections
*/
  {
    int status;
d1305 3
a1307 3
    if (socks_flag)
	status = Rlisten(master_socket, 1);
    else
d1309 5
a1313 4
    status = listen(master_socket, 1);
    if (status < 0) {
	master_socket = -1;
	return HTInetStatus("listen");
d1315 1
a1315 2
  }
    CTRACE(tfp, "TCP: Master socket(), bind() and listen() all OK\n");
a1350 1
    strncpy(month, (char *)ctime(&NowTime)+4, 3);
d1358 1
a1358 2
    sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
    sprintf(date, "9999%.2s%.2s", month, day);
d1397 1
a1397 1
    if (!isalpha(*s++) || !isalpha(*s++) || !isalpha(*s++))
d1408 1
a1408 1
    if (!(*s == ' ' || isdigit(*s))) {
d1415 1
a1415 1
    if (!isdigit(*s++))
d1423 1
a1423 1
    if (!(*s == ' ' || isdigit(*s))) {
d1430 1
a1430 1
    if (!isdigit(*s++))
d1434 1
a1434 1
    if (!(*s == ':' || isdigit(*s))) {
d1441 1
a1441 1
    if (!isdigit(*s++))
d1445 1
a1445 1
    if (!(*s == ' ' || isdigit(*s))) {
d1504 1
d1523 1
a1523 1
    short  i, j;
d1528 1
a1528 1
	 (i > 13) && (!isspace(line[i]) || !is_ls_date(&line[i-12])); i--)
d1544 1
a1544 1
    while (isdigit(line[j])) {
d1554 105
d1731 2
a1732 2
	strlen(cpd) > 9 && isdigit(*(cpd-1)) &&
	isalpha(*(cpd+1)) && *(cpd+4) == '-') {
d1735 3
a1737 5
	*(cpd+4) = '\0';
	*(cpd+2) = TOLOWER(*(cpd+2));
	*(cpd+3) = TOLOWER(*(cpd+3));
	sprintf(date, "%s ", cpd+1);
	*(cpd+4) = '-';
d1740 2
a1741 3
	*cpd = '\0';
	if (isdigit(*(cpd-2)))
	    sprintf(date+4, "%s ", cpd-2);
d1743 1
a1743 2
	    sprintf(date+4, "%c%s ", HT_NON_BREAK_SPACE, cpd-1);
	*cpd = '-';
d1748 1
a1748 3
	    *(cpd+15) = '\0';
	    sprintf(date+7, "%s", cpd+10);
	    *(cpd+15) = ' ';
d1750 1
a1750 3
	    *(cpd+9) = '\0';
	    sprintf(date+7, " %s", cpd+5);
	    *(cpd+9) = ' ';
d1760 1
a1760 1
	while (isdigit(*(cps-1)))
d1766 1
a1766 1
	while (isdigit(*cps))
d1779 1
a1779 1
	    while (isdigit(*cpd))
d1790 1
a1790 1
    CTRACE(tfp, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
d1793 1
a1793 1
		entry_info->size);
d1828 1
a1828 1
	if (isdigit(*cps)) {
d1851 1
a1851 1
		sprintf(date, "%s  %s", cpd, (cpd+7));
d1854 1
a1854 1
		sprintf(date, "%s %s", cpd, (cpd+12));
d1863 1
a1863 1
    CTRACE(tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
d1866 1
a1866 1
		entry_info->size);
d1932 1
a1932 1
	sprintf(date, "%s %s", months[i], (cp+3));
d1939 1
a1939 1
		sprintf(&date[6], "  20%s", cp);
d1941 1
a1941 1
		sprintf(&date[6], "  19%s", cp);
d1949 1
a1949 3
	    *(cpd+5) = '\0';
	    sprintf(&date[6], " %s%d:%s",
				     (i < 10 ? "0" : ""), i, (cpd+3));
d1972 1
a1972 1
    CTRACE(tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
d1975 1
a1975 1
		entry_info->size);
d2046 1
a2046 1
	if (isdigit(*cp)) {
d2057 1
a2057 1
	if (isdigit(*cp)) {
d2076 1
a2076 1
	 isdigit(*(cps+1)) && isdigit(*(cps+2)) && *(cps+3) == ':')) {
d2088 1
a2088 1
	    sprintf(date, "%s %s", months[i], (cpd+3));
d2095 1
a2095 1
		    sprintf(&date[6], "  20%s", cpd);
d2097 1
a2097 1
		    sprintf(&date[6], "  19%s", cpd);
d2103 1
a2103 2
		sprintf(&date[6], " %s%d:%s",
				     (i < 10 ? "0" : ""), i, (cps+3));
d2113 1
a2113 1
    CTRACE(tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
d2116 1
a2116 1
		entry_info->size);
d2128 1
a2128 1
PRIVATE EntryInfo * parse_dir_entry ARGS2(
d2130 2
a2131 1
	BOOLEAN *,	first)
d2149 45
d2199 1
d2258 1
a2258 1
				  (!isspace(entry[i]) ||
d2513 1
a2513 1
		sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d2520 5
a2524 1
		if (date1[0] == '9' && atoi(date1) > TheDate) {
d2530 5
a2534 9
		    if (entry2->date[9] == ':') {
			strcpy(date2, "9999");
			strcpy(time2, &entry2->date[7]);
			if (time2[0] == ' ') {
			    time2[0] = '0';
			}
		    } else {
			strcpy(date2, &entry2->date[8]);
			strcpy(time2, "00:00");
d2536 4
d2548 1
a2548 1
		sprintf(month, "%s%d", (i < 10 ? "0" : ""), i);
d2555 5
a2559 1
		if (date2[0] == '9' && atoi(date2) > TheDate) {
d2615 7
d2671 1
d2677 3
d2686 1
d2693 1
d2698 3
d2707 1
d2752 6
d2759 1
d2767 2
a2768 2
	    CTRACE(tfp, "HTFTP: Line in %s is %s\n",
			lastpath, chunk->data);
d2770 1
a2770 1
	    entry_info = parse_dir_entry(chunk->data, &first);
d2772 3
a2774 2
		CTRACE(tfp, "Adding file to BTree: %s\n",
			    entry_info->filename);
d2786 1
d2810 8
d2833 1
a2833 1
		    for (i = 0; entry_info->type[i] != '\0' && i < 15; i++)
d2841 18
d2860 1
d2864 8
d2878 1
d2894 1
a2894 2
    if (server_type == APPLESHARE_SERVER ||
	server_type == NETPRESENZ_SERVER) {
d2897 4
a2900 1
	 *  the response(NIL) below hangs. - KW
d2902 5
a2906 1
	NETCLOSE(data_soc);
a2909 2
	if (server_type != CMS_SERVER)
	    response(NIL);
a2910 1
	return HT_LOADED;
a2911 2
    if (server_type != CMS_SERVER)
	response(NIL);
a2912 3
#ifdef NOTDEFINED
    return response(NIL) == 2 ? HT_LOADED : -1;
#endif /* NOTDEFINED */
d2932 1
a2932 1
    int status;
d2934 3
a2938 1

d2944 1
d2951 1
a2951 1
	if (!ftp_local_passive) {
d2956 4
d2961 1
d2968 1
a2968 1
	    /* Inform the server of the port number we will listen on
d2972 1
a2972 1
		CTRACE (tfp, "HTFTP: Interrupted in response (port_command)\n");
d2984 1
a2984 1
	    CTRACE(tfp, "HTFTP: Port defined.\n");
d2987 1
a2987 1
	    char command[LINE_LENGTH+1];
d2989 4
a2992 1
	    int reply, h0, h1, h2, h3, p0, p1;	/* Parts of reply */
d2996 59
d3067 21
a3087 16
	   status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
		   &h0, &h1, &h2, &h3, &p0, &p1);
	   if (status < 4) {
	       fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
	       return -99;
	   }
	   passive_port = (p0<<8) + p1;
	   CTRACE(tfp, "HTFTP: Server is listening on port %d\n",
			passive_port);


/*	Open connection for data:
*/
	    sprintf(command,
		    "ftp://%d.%d.%d.%d:%d/",h0,h1,h2,h3,passive_port);
	    status = HTDoConnect(name, "FTP", passive_port, &data_soc);
d3095 1
a3095 1
	    CTRACE(tfp, "FTP data connected, socket %d\n", data_soc);
d3109 1
d3122 1
a3122 1
		CTRACE(tfp, "HTFTP: Rejecting path due to illegal escaped slash.\n");
d3158 1
a3158 1
		CTRACE(tfp, "HTFTP: type=%s\n", type);
d3162 1
a3162 1
	CTRACE(tfp, "HTFTP: UnEscaped %s\n", filename);
d3222 1
a3222 1
	binary = (encoding != HTAtom_for("8bit") &&
d3270 1
d3278 1
a3278 1
		CTRACE(tfp, "HTFTP: Rejecting path due to non-Unix-style syntax.\n");
d3288 3
a3290 3
		CTRACE(tfp, "HTFTP: Trimmed '%s'\n", filename);
		cp = HTMake_VMS_name("", filename);
		CTRACE(tfp, "HTFTP: VMSized '%s'\n", cp);
d3292 2
a3293 5
		    cp1++;
		    for (i = 0; cp1[i]; i++)
			filename[i] = cp1[i];
		    filename[i] = '\0';
		    CTRACE(tfp, "HTFTP: Filename '%s'\n", filename);
d3331 4
a3334 9
			for (i = 0; cp1[i]; i++)
			    filename[i] = cp1[i];
			filename[i] = '\0';
			CTRACE(tfp, "HTFTP: Filename '%s'\n", filename);
			*cp1 = '\0';
			strcat(cp, "[");
			strcat(cp, filename);
			strcat(cp, "]");
			status = send_cwd(cp);
d3336 2
a3337 3
			    *cp1 = '\0';
			    strcat(cp, "[000000]");
			    status = send_cwd(cp);
d3339 2
a3340 2
				*cp1 = '\0';
				status = send_cwd(cp);
d3350 2
a3351 2
			    strcpy(cp, "000000");
			    filename = cp;
d3357 2
a3358 2
			strcat(cp, ":");
			status = send_cwd(cp);
d3367 2
a3368 2
		    strcpy(cp, "000000");
		    filename = cp;
d3433 1
a3433 1
	    if (!strncmp(filename, "/~", 2))
d3435 3
a3437 1
	    CTRACE(tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename);
d3446 1
a3446 1
		CTRACE(tfp, "change path '%s'\n", tmp);
d3449 1
a3449 1
		CTRACE(tfp, "...to  path '%s'\n", tmp);
d3463 1
a3463 1
		if (!included_device) {
d3569 1
d3582 1
a3582 1
    if (!ftp_local_passive) {
d3584 3
d3588 1
d3604 1
a3604 1
	CTRACE(tfp, "TCP: Accepted new socket %d\n", status);
d3606 6
a3611 1
    } /* !ftp_local_passive */
d3614 29
a3642 7
	status = read_directory (anchor, name, format_out, sink);
	NETCLOSE(data_soc);
	NETCLOSE(control->socket);
	control->socket = -1;
	init_help_message_cache();  /* to free memory */
	return status;
      /* returns HT_LOADED or error */
a3644 1
	int len;
d3662 3
a3664 5
	} else if ((len = strlen(FileName)) > 2) {
	    if ((FileName[len - 1] == 'Z') &&
		(FileName[len - 2] == '.' ||
		 FileName[len - 2] == '-' ||
		 FileName[len - 2] == '_')) {
d3666 2
a3667 1
		FileName[len - 2] = '\0';
a3670 1
		StrAllocCopy(anchor->content_encoding, "x-compress");
d3672 6
a3677 9
	    } else if ((len > 3) &&
		       !strcasecomp((char *)&FileName[len - 2], "gz")) {
		if (FileName[len - 3] == '.' ||
		    FileName[len - 3] == '-' ||
		    FileName[len - 3] == '_') {
		    FileName[len - 3] = '\0';
		    format = HTFileFormat(FileName, &encoding, NULL);
		    format = HTCharsetFormat(format, anchor, -1);
		    StrAllocCopy(anchor->content_type, format->name);
d3679 6
a3684 1
		    format = HTAtom_for("www/compressed");
a3692 3
	if (rv == HT_INTERRUPTED)
	     _HTProgress(TRANSFER_INTERRUPTED);

d3696 20
a3715 2
	status = NETCLOSE(data_soc);
	CTRACE(tfp, "HTFTP: Closing data socket %d\n", data_soc);
a3717 1
	    data_soc = -1;			/* invalidate it */
d3719 19
a3737 12
	    data_soc = -1;			/* invalidate it */
	    status = response(NIL);		/* Pick up final reply */
	    if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		init_help_message_cache();  /* to free memory */
		return HTLoadError(sink, 500, response_text);
	    }
	}

	NETCLOSE(control->socket);
	control->socket = -1;
	init_help_message_cache();  /* to free memory */
	return HT_LOADED;
d3739 14
@


1.3
log
@Passive ftp support from newer lynx sources. To enable it, see
FTP_PASSIVE in lynx.cfg.
@
text
@d2573 1
a2573 1
	if (!ftp_passive) {
d3136 1
a3136 1
    if (!ftp_passive) {
d3156 1
a3156 1
    } /* !ftp_passive */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a40 5
** Options:
**	LISTEN		We listen, the other guy connects for data.
**			Otherwise, other way round, but problem finding our
**			internet address!
**
a49 9
** If LISTEN is not defined, PASV is used instead of PORT, and not
** all FTP servers support PASV, so define it unless there is no
** alternative for your system.
*/
#ifndef NOPORT
#define LISTEN	 /* @@@@@@@@ Test LJM */
#endif /* !NOPORT */

/*
d98 1
a177 1
#ifdef LISTEN
a181 1
#else
a182 1
#endif /* LISTEN */
a960 2
#ifdef LISTEN

a1155 1
#endif /* LISTEN */
d2573 10
a2582 10
#ifdef LISTEN
	status = get_listen_socket();
	if (status < 0) {
	    NETCLOSE (control->socket);
	    control->socket = -1;
	    close_master_socket ();
	    /* HT_INTERRUPTED would fall through, if we could interrupt
	       somehow in the middle of it, which we currently can't. */
	    return status;
	}
d2585 2
a2586 3
/*	Inform the server of the port number we will listen on
*/
	{
a2601 1
	}
d2603 1
a2603 4
#else	/* Use PASV */
/*	Tell the server to be passive
*/
	{
d2607 1
a2607 1
	    int status;
a2646 1
#endif /* use PASV */
d3136 2
a3137 4
#ifdef LISTEN
/*	Wait for the connection
*/
    {
d3156 2
a3157 4
    }
#else
/* @@@@ */
#endif /* LISTEN */
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
**	one minute. Therefore, we have to use a rotating port number.
d23 2
a24 2
**      LM      Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
**      FM      Foteos Macrides <macrides@@sci.wfeb.edu>
d32 1
a32 1
**	27 Dec 93 (FM)  Fixed up so FTP now works with VMS hosts.  Path
d35 1
a35 1
**      ?? ??? ?? (LM)  Added code to prompt and send passwords for non
d37 3
a39 3
**      25 Mar 94 (LM)  Added code to recognize different ftp server types
**                      and code to parse dates and sizes on most hosts.
**	27 Mar 93 (FM)  Added code for getting dates and sizes on VMS hosts.
d47 2
a48 2
**     			Portions Copyright 1994 Trustees of Dartmouth College
** 			Code for recognizing different FTP servers and
d64 1
a64 1
BUGS:	@@@@@@  	Limit connection cache size!
d66 1
a66 1
		400 & 500 errors are acked by user with windows.
d69 1
a69 1
**		Note for portablility this version does not use select() and
d78 1
a78 2
#include "HTUtils.h"
#include "tcp.h"
d80 1
a80 1
#include "HTAlert.h"
d82 1
a82 1
#include "HTFTP.h"	/* Implemented here */
d101 6
a106 7
#include "HTParse.h"
#include "HTTCP.h"
#include "HTAnchor.h"
#include "HTFile.h"	/* For HTFileFormat() */
#include "HTBTree.h"
#include "HTChunk.h"
#include "HTAlert.h"
d111 3
a113 1
#include "LYLeaks.h"
d116 1
a116 1
    struct _connection *	next;	/* Link on list 	*/
d118 1
a118 1
    int				socket;	/* Socket number for communication */
d128 1
a128 1
#include "HTML.h"
a140 5
#define FREE(x) if (x) {free(x); x = NULL;}

extern int HTCheckForInterrupt NOPARAMS;


d144 2
a145 1
PUBLIC BOOLEAN HTfileSortMethod = FILE_BY_NAME;
d167 5
a171 5
#define MACHTEN_SERVER 	   1
#define UNIX_SERVER 	   2
#define VMS_SERVER 	   3
#define CMS_SERVER 	   4
#define DCTS_SERVER    	   5
d177 1
a177 1
#define MSDOS_SERVER      11
d181 2
a182 2
PRIVATE int     server_type = GENERIC_SERVER;   /* the type of ftp host */
PRIVATE int     unsure_type = FALSE;            /* sure about the type? */
d188 1
a188 1
PRIVATE	unsigned short	port_number = FIRST_TCP_PORT;
d192 1
a192 1
PRIVATE int     master_socket = -1;	/* Listening socket = invalid	*/
d194 2
a195 2
PRIVATE fd_set	open_sockets; 		/* Mask of active channels */
PRIVATE int	num_sockets;  		/* Number of sockets to scan */
d197 1
a197 1
PRIVATE	unsigned short	passive_port;	/* Port server specified for data */
d212 1
d226 1
d235 1
a235 1
**	returns 	vms file specification
d237 1
a237 1
** Bug:	Returns pointer to static -- non-reentrant
d244 3
a246 3
/*	We try converting the filename into Files-11 syntax. That is, we assume
**	first that the file is, like us, on a VMS node. We try remote
**	(or local) DECnet access. Files-11, VMS, VAX and DECnet
d260 1
a260 1
        outofmem(__FILE__, "HTVMSname");
d262 1
a262 1
    strcpy(nodename, "");	/* On same node? Yes if node names match */
d264 3
a266 3
        CONST char *p;
	char *q;
        for (p = hostname, q = (char *)nn;
d269 5
a273 4
	        strcpy(nodename, nn);
		q = strchr(nodename, '.');	/* Mismatch */
		if (q)
		    *q = '\0';			/* Chop domain */
d289 1
a289 1
    } else { 				/* More than two slashes */
d298 1
a298 1
	        *p = '.';		/* Convert dir sep.  to dots */
d308 1
a308 1
PRIVATE char next_data_char NOARGS
d314 1
a314 1
        interrupted_in_next_data_char = 1;
d316 1
a316 1
        return (char)-1;
d322 1
a322 1
        char c = *data_read_pointer++;
d326 1
a326 1
    return *data_read_pointer++;
d340 1
a340 1
        fprintf(stderr, "HTFTP: Closing control socket %d\n", con->socket);
d348 1
a348 1
        connections = con->next;
d352 1
a352 1
        if (scan->next == con) {
d355 1
a355 1
	        control = (connection*)0;
d373 1
a373 1
        StrAllocCat(help_message_buffer, string);
d375 1
a375 1
        StrAllocCopy(help_message_buffer, string);
d377 1
a377 2
    if (TRACE)
	fprintf(stderr,"Adding message to help cache: %s\n",string);
d414 1
a414 1
    int	continuation_response = -1;
d418 2
a419 3
          if (TRACE)
	      fprintf(stderr, "HTFTP: No control connection set up!!\n");
	  return -99;
d423 1
a423 2
	if (TRACE)
	    fprintf(stderr, "  Tx: %s", cmd);
d428 1
a428 1
	        *p = TOASCII(*p);
d434 1
a434 3
	    if (TRACE)
	        fprintf(stderr,
	    		"HTFTP: Error %d sending command: closing socket %d\n",
d444 2
a445 1
	    if (((*p++ = NEXT_CHAR) == LF)
d450 6
a455 9
	        if (interrupted_in_htgetcharacter)
                  {
                    if (TRACE)
                      fprintf (stderr,
		        "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
                    NETCLOSE (control->socket);
                    control->socket = -1;
                    return HT_INTERRUPTED;
                  }
d458 1
a458 2
		if (TRACE)
		    fprintf(stderr, "    Rx: %s", response_text);
d460 1
a460 1
                /* Check for login or help messages */
d470 1
a470 1
		} else { 	/* continuing */
d473 1
a473 1
			    continuation_response = -1;	/* ended */
d478 10
a487 14
	    if (interrupted_in_htgetcharacter)
               {
                    if (TRACE)
                      fprintf (stderr,
		        "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
                    NETCLOSE (control->socket);
                    control->socket = -1;
                    return HT_INTERRUPTED;
               }

	    if (*(p-1) == (char) EOF) {
		if (TRACE)
		    fprintf(stderr, "Error on rx: closing socket %d\n",
		    	    control->socket);
d489 2
a490 2
	        close_connection(control);
	    	return -1;	/* End of file on response */
d497 2
a498 3
	if (TRACE)
	    fprintf(stderr, "HTFTP: They close so we close socket %d\n",
	    	    control->socket);
d503 1
a503 1
        (0 == strncasecomp(cmd, "CWD", 3) ||
d505 1
a505 1
        /*
d513 22
d540 1
a540 1
        int,		ServerType)
d567 1
a567 1
        return;
d572 8
a579 9
        if (*ServerType == TCPC_SERVER) {
            *ServerType = ((response_text[5] == '/') ?
	    				  NCSA_SERVER : TCPC_SERVER);
	     if (TRACE)
	         fprintf(stderr, "HTFTP: Treating as %s server.\n",
		 	 ((*ServerType == NCSA_SERVER) ?
			 			 "NCSA" : "TCPC"));
        } else if (response_text[5] == '/') {
            /* path names beginning with / imply Unix,
d584 1
a584 2
		if (TRACE)
	            fprintf(stderr, "HTFTP: Treating as NCSA server.\n");
d586 3
a588 4
                 *ServerType = UNIX_SERVER;
                 *UseList = TRUE;
		 if (TRACE)
	             fprintf(stderr, "HTFTP: Treating as Unix server.\n");
d591 3
a593 3
        } else if (response_text[strlen(response_text)-1] == ']') {
            /* path names ending with ] imply VMS, right? */
            *ServerType = VMS_SERVER;
d595 4
a598 6
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as VMS server.\n");
        } else {
            *ServerType = GENERIC_SERVER;
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as Generic server.\n");
d601 5
a605 5
        if ((*ServerType == NCSA_SERVER) ||
            (*ServerType == TCPC_SERVER) ||
            (*ServerType == PETER_LEWIS_SERVER) ||
            (*ServerType == NETPRESENZ_SERVER))
            set_mac_binary(*ServerType);
d615 1
a615 1
**	returns	<0 if error
d629 1
a629 1
    char * command;
d639 1
d641 1
d688 4
a691 4
	     *  If the password doesn't exist then we are going to have
	     *  to ask the user for it.  The only problem is that we
	     *  don't want to ask for it every time, so we will store
	     *  away in a primitive fashion.
d694 1
a694 1
		char tmp[256];
d696 1
a696 1
		sprintf(tmp, "%s@@%s", username, p1);
d707 2
a708 2
		    sprintf(tmp, "Enter password for user %s@@%s:",
		    		  username, p1);
d710 1
a710 1
		    user_entered_password = (char *)HTPromptPassword(tmp);
d714 1
d722 19
a740 1
  status = HTDoConnect (arg, "FTP", IPPORT_FTP, (int *)&con->socket);
d742 5
a746 28
  if (status < 0)
    {
      if (TRACE)
        {
          if (status == HT_INTERRUPTED)
            fprintf (stderr,
                     "HTFTP: Interrupted on connect\n");
          else
            fprintf(stderr,
                    "HTFTP: Unable to connect to remote host for `%s'.\n",
                    arg);
        }
      if (status == HT_INTERRUPTED) {
        _HTProgress ("Connection interrupted.");
	status = HT_NOT_LOADED;
      } else {
        HTAlert("Unable to connect to FTP host.");
      }
      if (con->socket != -1)
        {
          NETCLOSE(con->socket);
        }

      FREE(username);
      if (control == con)
	  control = NULL;
      FREE(con);
      return status;                    /* Bad return */
d749 2
a750 4
    if (TRACE) {
 	fprintf(stderr, "FTP connected, socket %d  control %ld\n",
			con->socket, (long)con);
    }
d755 1
a755 1
    init_help_message_cache();  /* Clear the login message buffer. */
d762 7
a768 10
    if (status == HT_INTERRUPTED)
      {
        if (TRACE)
          fprintf (stderr,
                   "HTFTP: Interrupted at beginning of login.\n");
        _HTProgress ("Connection interrupted.");
        NETCLOSE(control->socket);
        control->socket = -1;
        return HT_INTERRUPTED;
      }
d773 1
d787 11
a797 23
	if (username && *username) {
	    command = (char*)malloc(10+strlen(username)+2+1);
	    if (command == NULL)
	        outofmem(__FILE__, "get_connection");
	    sprintf(command, "USER %s%c%c", username, CR, LF);
	} else {
	    command = (char*)malloc(24);
	    if (command == NULL)
	        outofmem(__FILE__, "get_connection");
	    sprintf(command, "USER anonymous%c%c", CR, LF);
        }
	status = response(command);
	FREE(command);
        if (status == HT_INTERRUPTED)
          {
            if (TRACE)
              fprintf (stderr,
                       "HTFTP: Interrupted while sending username.\n");
            _HTProgress ("Connection interrupted.");
            NETCLOSE(control->socket);
            control->socket = -1;
            return HT_INTERRUPTED;
          }
d804 1
a804 4
	    command = (char*)malloc(10+strlen(password)+2+1);
	    if (command == NULL)
	        outofmem(__FILE__, "get_connection");
	    sprintf(command, "PASS %s%c%c", password, CR, LF);
d814 1
a814 1
	        /*
d818 1
a818 1
	        StrAllocCopy(user, personal_mail_address);
d826 1
a826 1
	        /*
d841 1
a841 1
	    	host = "";
d843 1
a843 4
	    command = (char*)malloc(10+strlen(user)+1+strlen(host)+2+1);
	    if (command == NULL)
	        outofmem(__FILE__, "get_connection");
	    sprintf(command, "PASS %s@@%s%c%c", user, host, CR, LF);
d845 1
a845 1
        }
d848 8
a855 10
        if (status == HT_INTERRUPTED)
          {
            if (TRACE)
              fprintf (stderr,
                       "HTFTP: Interrupted while sending password.\n");
            _HTProgress ("Connection interrupted.");
            NETCLOSE(control->socket);
            control->socket = -1;
            return HT_INTERRUPTED;
          }
d860 8
a867 13
        char temp[80];
	sprintf(temp, "ACCT noaccount%c%c", CR, LF);
	status = response(temp);
	if (status == HT_INTERRUPTED)
          {
            if (TRACE)
              fprintf (stderr,
                       "HTFTP: Interrupted while sending password.\n");
            _HTProgress ("Connection interrupted.");
            NETCLOSE(control->socket);
            control->socket = -1;
            return HT_INTERRUPTED;
          }
d871 3
a873 4
        if (TRACE)
	    fprintf(stderr, "HTFTP: Login fail: %s", response_text);
    	/* if (control->socket > 0) close_connection(control->socket); */
        return -1;		/* Bad return */
d875 1
a875 1
    if (TRACE) fprintf(stderr, "HTFTP: Logged in.\n");
d880 1
a880 1
    use_list = FALSE; 			/* reset */
d882 4
a885 4
        /* we got a line -- what kind of server are we talking to? */
        if (strncmp(response_text+4,
	 	    "UNIX Type: L8 MAC-OS MachTen", 28) == 0) {
            server_type = MACHTEN_SERVER;
d887 1
a887 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as MachTen server.\n");
d889 1
a889 1
        } else if (strstr(response_text+4, "UNIX") != NULL ||
d891 1
a891 1
            server_type = UNIX_SERVER;
d893 1
a893 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as Unix server.\n");
d895 2
a896 2
        } else if (strstr(response_text+4, "MSDOS") != NULL) {
            server_type = MSDOS_SERVER;
d898 1
a898 3
	    if (TRACE)
	        fprintf(stderr,
	 	 	"HTFTP: Treating as MSDOS (Unix emulation) server.\n");
d900 2
a901 2
        } else if (strncmp(response_text+4, "VMS", 3) == 0) {
            server_type = VMS_SERVER;
d903 1
a903 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as VMS server.\n");
d906 2
a907 2
	 	   (strncmp(response_text+4, "VM ", 3) == 0)) {
            server_type = CMS_SERVER;
d909 1
a909 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as CMS server.\n");
d912 2
a913 3
            server_type = DCTS_SERVER;
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as DCTS server.\n");
d916 3
a918 4
            server_type = TCPC_SERVER;
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Looks like a TCPC server.\n");
            get_ftp_pwd(&server_type, &use_list);
d921 10
a930 14
        } else if (server_type == NETPRESENZ_SERVER) { /* already set above */
            use_list = TRUE;
            set_mac_binary(server_type);
	    if (TRACE)
	        fprintf(stderr,
	 	 	"HTFTP: Treating as NetPresenz (MACOS) server.\n");

        } else if (strncmp(response_text+4, "MACOS Peter's Server", 20) == 0) {
            server_type = PETER_LEWIS_SERVER;
            use_list = TRUE;
            set_mac_binary(server_type);
	    if (TRACE)
	        fprintf(stderr,
	 	 	"HTFTP: Treating as Peter Lewis (MACOS) server.\n");
d932 1
a932 1
        } else if (strncmp(response_text+4, "Windows_NT", 10) == 0) {
d935 1
a935 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as Window_NT server.\n");
d940 1
a940 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Treating as MS Windows server.\n");
d942 1
a942 1
        } else if (strncmp(response_text+4,
d944 4
a947 6
            server_type = APPLESHARE_SERVER;
            use_list = TRUE;
            set_mac_binary(server_type);
	    if (TRACE)
	        fprintf(stderr,
	 	 	"HTFTP: Treating as AppleShare server.\n");
d949 1
a949 1
	} else  {
d951 2
a952 3
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Ugh!  A Generic server.\n");
            get_ftp_pwd(&server_type, &use_list);
d957 1
a957 1
         get_ftp_pwd(&server_type, &use_list);
d967 1
a967 1
	        close_connection(control->socket);
d970 1
a970 2
	if (TRACE)
	    fprintf(stderr, "HTFTP: Port defined.\n");
d987 3
a989 1
    FD_CLR(master_socket, &open_sockets);
d991 1
a991 2
    if (TRACE)
        fprintf(stderr, "HTFTP: Closed master socket %d\n", master_socket);
d994 1
a994 1
        return HTInetStatus("close master socket");
d996 1
a996 1
        return status;
d1026 1
a1026 1
        return master_socket;  /* Done already */
d1034 1
a1034 1
	return HTInetStatus("socket for master socket");
d1036 1
a1036 2
    if (TRACE)
        fprintf(stderr, "HTFTP: Opened master socket number %d\n", new_socket);
d1044 1
a1044 1
        unsigned short old_port_number = port_number;
d1055 1
a1055 1
	        if ((status=Rbind(new_socket,
d1071 1
a1071 3
	    if (TRACE)
	        fprintf(stderr,
	    		"TCP bind attempt to port %d yields %d, errno=%d\n",
d1077 1
a1077 1
        int status;
d1083 1
a1083 1
			 	  (void *)&address_length);
d1128 1
a1128 1
    		(int)ntohs(soc_in->sin_port),
d1133 1
a1133 1
        (void) close_master_socket();
d1140 1
a1140 1
    (void)HTHostName(); 	/* Make address valid - doesn't work*/
d1157 1
a1157 1
        status = Rlisten(master_socket, 1);
d1169 1
a1169 1
        num_sockets = master_socket+1;
d1200 1
a1200 1
        day[0] = '0';
d1206 1
a1206 1
        if (!strcasecomp(month, months[i])) {
d1212 1
a1212 1
    sprintf(date, "9999%s%s", month, day);
d1221 3
a1223 3
    char *       filename;
    char *       type;
    char *       date;
d1225 1
a1225 1
    BOOLEAN      display;  /* show this entry? */
d1232 3
a1234 3
        FREE(entry_info->filename);
        FREE(entry_info->type);
        FREE(entry_info->date);
d1241 5
a1245 5
 *      Return TRUE if s points to a string of the form:
 *              "Sep  1  1990 " or
 *              "Sep 11 11:59 " or
 *              "Dec 12 1989  " or
 *              "FCv 23 1990  " ...
d1252 1
a1252 1
        return FALSE;
d1270 1
a1270 1
        return FALSE;
d1274 1
a1274 1
        return FALSE;
d1285 1
a1285 1
        return FALSE;
d1296 1
a1296 1
        return FALSE;
d1307 1
a1307 1
        return FALSE;
d1314 1
a1314 1
 *      Extract the name, size, and date from an EPLF line. - 08-06-96 DJB
d1337 1
a1337 1
    	switch(*cp) {
d1339 1
a1339 1
	        StrAllocCopy(info->filename, cp + 1);
d1342 1
a1342 1
	        size = 0;
d1357 1
a1357 1
		StrAllocCopy(info->type, "Directory");
d1370 1
a1370 1
 *      Extract the name, size, and date from an ls -l line.
d1381 2
a1382 2
         (i > 13) && (!isspace(line[i]) || !is_ls_date(&line[i-12])); i--)
        ; /* null body */
d1385 1
a1385 1
        StrAllocCopy(entry_info->date, &line[i-12]);
d1392 1
a1392 1
	        entry_info->date[j] = entry_info->date[j-1];
d1398 3
a1400 3
        size_num += (line[j] - '0') * base;
        base *= 10;
        j--;
d1408 2
a1409 2
 *      Format the name, date, and size from a VMS LIST line
 *      into the EntryInfo structure - FM
d1415 2
a1416 1
    int i, j, ialloc;
d1421 3
a1423 3
    if (!strlen(line) || (cp=strchr(line, ';')) == NULL) {
        entry_info->display = FALSE;
        return;
d1432 2
a1433 2
        for (i = 0; entry_info->filename[i]; i++)
	    entry_info->filename[i] = TOLOWER(entry_info->filename[i]);
d1435 2
a1436 2
        i = ((strstr(entry_info->filename, "READ") - entry_info->filename) + 4);
	if (!strncmp((char *)&entry_info->filename[i], "ME", 2)) {
d1439 1
a1439 1
	        i++;
d1441 1
a1441 1
	} else if (!strncmp((char *)&entry_info->filename[i], ".ME", 3)) {
d1446 1
a1446 2
        for (; entry_info->filename[i]; i++)
	    entry_info->filename[i] = TOLOWER(entry_info->filename[i]);
d1451 4
a1454 4
        entry_info->filename[i] == 'z' &&
        (entry_info->filename[i-1] == '.' ||
         entry_info->filename[i-1] == '_'))
        entry_info->filename[i] = 'Z';
d1459 1
a1459 1
        *cps = ' ';
d1465 4
a1468 4
        if (cps[i] == ' ' && cps[j] == ' ')
            j++;
        else
            cps[++i] = cps[j++];
d1474 1
a1474 1
        set_years_and_date();
d1479 2
a1480 2
        strlen(cpd) > 9 && isdigit(*(cpd-1)) &&
        isalpha(*(cpd+1)) && *(cpd+4) == '-') {
d1482 4
a1485 4
        /** Month **/
        *(cpd+4) = '\0';
        *(cpd+2) = TOLOWER(*(cpd+2));
        *(cpd+3) = TOLOWER(*(cpd+3));
d1509 1
a1509 1
        StrAllocCopy(entry_info->date, date);
d1514 15
a1528 15
        /* Appears be in used/allocated format */
        cps = cpd;
        while (isdigit(*(cps-1)))
            cps--;
        if (cps < cpd)
            *cpd = '\0';
        entry_info->size = atoi(cps);
        cps = cpd+1;
        while (isdigit(*cps))
            cps++;
        *cps = '\0';
        ialloc = atoi(cpd+1);
        /* Check if used is in blocks or bytes */
        if (entry_info->size <= ialloc)
            entry_info->size *= 512;
d1531 12
a1542 12
        /* We just initialized on the version number */
        /* Now let's hunt for a lone, size number    */
        while ((cps=strtok(NULL, sp)) != NULL) {
           cpd = cps;
           while (isdigit(*cpd))
               cpd++;
           if (*cpd == '\0') {
               /* Assume it's blocks */
               entry_info->size = atoi(cps) * 512;
               break;
           }
       }
d1546 4
a1549 5
    if (TRACE)
	fprintf(stderr, "HTFTP: VMS filename: %s  date: %s  size: %d\n",
			entry_info->filename,
			entry_info->date ? entry_info->date : "",
			entry_info->size);
d1555 2
a1556 2
 *      Format the name, date, and size from an MS_WINDOWS LIST line into
 *      the EntryInfo structure (assumes Chameleon NEWT format). - FM
d1567 1
a1567 2
    while (*cp && isspace(*cp))
	cp++;
d1569 2
a1570 2
        entry_info->display = FALSE;
        return;
d1574 1
a1574 3
    cps = cp;
    while (*cps && !isspace(*cps))
	cps++;
d1581 2
a1582 5
	while (*cps && isspace(*cps))
	    cps++;
	cpd = cps;
	while (*cpd && !isspace(*cpd))
	    cpd++;
d1587 1
a1587 1
	    StrAllocCopy(entry_info->type, "Directory");
d1600 1
a1600 2
	while (*cpd && isspace(*cpd))
            cpd++;
d1606 2
a1607 2
	        /* Not this year, so show the year */
	        sprintf(date, "%s  %s", cpd, (cpd+7));
d1609 3
a1611 3
	        /* Is this year, so show the time */
	        sprintf(date, "%s %s", cpd, (cpd+12));
            StrAllocCopy(entry_info->date, date);
d1619 4
a1622 5
    if (TRACE)
	fprintf(stderr, "HTFTP: MS Windows filename: %s  date: %s  size: %d\n",
			entry_info->filename,
			entry_info->date ? entry_info->date : "",
			entry_info->size);
d1628 2
a1629 2
 *      Format the name, date, and size from a WINDOWS_NT LIST line into
 *      the EntryInfo structure (assumes Chameleon NEWT format). - FM
d1642 1
a1642 2
    while (*cp && isspace(*cp))
	cp++;
d1644 2
a1645 2
        entry_info->display = FALSE;
        return;
d1650 1
a1650 3
    cps = (end-1);
    while (cps >= cpd && !isspace(*cps))
	cps--;
d1653 2
a1654 2
        entry_info->display = FALSE;
        return;
d1669 1
a1669 2
    while (*cps && !isspace(*cps))
	cps++;
d1672 2
a1673 2
        entry_info->display = FALSE;
        return;
d1675 2
a1676 5
    while (*cps && isspace(*cps))
	cps++;
    cpd = cps;
    while (*cps && !isspace(*cps))
	cps++;
d1679 2
a1680 2
        entry_info->display = FALSE;
        return;
d1695 1
a1695 1
		sprintf((char *)&date[6], "  20%s", cp);
d1697 1
a1697 1
		sprintf((char *)&date[6], "  19%s", cp);
d1706 1
a1706 1
	    sprintf((char*)&date[6], " %s%d:%s",
d1709 1
a1709 1
        StrAllocCopy(entry_info->date, date);
d1717 2
a1718 5
	while (*cps && isspace(*cps))
	    cps++;
	cpd = cps;
	while (*cpd && !isspace(*cpd))
	    cpd++;
d1723 1
a1723 1
	    StrAllocCopy(entry_info->type, "Directory");
d1730 4
a1733 5
    if (TRACE)
	fprintf(stderr, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
			entry_info->filename,
			entry_info->date ? entry_info->date : "",
			entry_info->size);
d1740 2
a1741 2
 *      Format the name, date, and size from a VM/CMS line into
 *      the EntryInfo structure. - FM
d1755 1
a1755 2
    while (*cp && isspace(*cp))
	cp++;
d1757 2
a1758 2
        entry_info->display = FALSE;
        return;
d1762 1
a1762 3
    cps = cp;
    while (*cps && !isspace(*cps))
	cps++;
d1767 2
a1768 4
        return;
    cp = cps;
    while (*cp && isspace(*cp))
	cp++;
d1770 5
a1774 5
        /** If we don't have more, we've misparsed. **/
        FREE(entry_info->filename);
        FREE(entry_info->type);
        entry_info->display = FALSE;
        return;
d1776 1
a1776 3
    cps = cp;
    while (*cps && !isspace(*cps))
	cps++;
d1779 3
a1781 3
        /** It's an SFS directory. **/
        StrAllocCopy(entry_info->type, "Directory");
        entry_info->size = 0;
d1783 2
a1784 2
        /** It's a file. **/
        cp--;
d1788 1
a1788 1
        /** Track down the VM/CMS RECFM or type. **/
d1791 2
a1792 5
	    while (*cp && isspace(*cp))
	        cp++;
	    cps = cp;
	    while (*cps && !isspace(*cps))
	        cps++;
d1801 2
a1802 5
	while (*cp && isspace(*cp))
	    cp++;
	cps = cp;
	while (*cps && !isspace(*cps))
	    cps++;
d1812 2
a1813 5
	while (*cp && isspace(*cp))
	    cp++;
	cps = cp;
	while (*cps && !isspace(*cps))
	    cps++;
d1832 2
a1833 2
         (cps = strchr(cpd, ':')) != NULL) &&
        (cps < (end - 3) &&
d1844 1
a1844 1
	       *cpd = '0';
d1851 1
a1851 1
	        /* Not this year, so show the year. */
d1853 1
a1853 1
		    sprintf((char *)&date[6], "  20%s", cpd);
d1855 1
a1855 1
		    sprintf((char *)&date[6], "  19%s", cpd);
d1858 1
a1858 1
	        /* Is this year, so show the time. */
d1861 1
a1861 1
		sprintf((char*)&date[6], " %s%d:%s",
d1872 4
a1875 5
    if (TRACE)
	fprintf(stderr, "HTFTP: VM/CMS filename: %s  date: %s  size: %d\n",
			entry_info->filename,
			entry_info->date ? entry_info->date : "",
			entry_info->size);
d1881 2
a1882 2
 *      Given a line of LIST/NLST output in entry, return results
 *      and a file/dir name in entry_info struct
d1884 1
a1884 1
 *      If first is true, this is the first name in a directory.
d1898 2
d1907 3
a1909 3
        case UNIX_SERVER:
        case PETER_LEWIS_SERVER:
        case MACHTEN_SERVER:
d1911 3
a1913 3
        case WINDOWS_NT_SERVER:
        case APPLESHARE_SERVER:
        case NETPRESENZ_SERVER:
d1915 1
a1915 1
	    **  Check for EPLF output (local times).
d1922 2
a1923 2
            /*
	    **  Interpret and edit LIST output from Unix server.
d1925 1
a1925 1
            len = strlen(entry);
d1927 1
d1930 1
a1930 1
		     *  Don't reset *first, nothing real will follow. - KW
d1935 4
a1938 4
	        *first = FALSE;
                if (!strncmp(entry, "total ", 6) ||
                    strstr(entry, "not available") != NULL) {
		    entry_info->display=FALSE;
d1941 3
a1943 3
                    /* this isn't really a unix server! */
                    server_type = GENERIC_SERVER;
		    entry_info->display=FALSE;
d1948 2
a1949 2
            /*
	    **  Check first character of ls -l output.
d1951 2
a1952 2
            if (TOUPPER(entry[0]) == 'D')  {
                /*
d1955 2
a1956 2
                StrAllocCopy(entry_info->type, "Directory");
	        remove_size=TRUE; /* size is not useful */
d1958 1
a1958 1
                /*
d1960 1
a1960 1
		**  knowing if it is symbolic?  I think so since
d1963 1
a1963 1
                StrAllocCopy(entry_info->type, "Symbolic Link");
d1966 1
a1966 1
                /*
d1969 3
a1971 3
                for (i = len - 1; (i > 3) &&
		                  (!isspace(entry[i]) ||
				   (entry[i-1] != '>')  ||
d1974 6
a1979 6
                    ; /* null body */
                if (i > 3) {
                    entry[i-3] = '\0';
                    len = i - 3;
                }
            } /* link */
d1984 2
a1985 2
	        !strcmp(entry_info->filename,"."))
		entry_info->display=FALSE;
d1987 1
a1987 1
	    **  Goto the bottom and get real type.
d1989 1
a1989 1
            break;
d1991 4
a1994 4
        case VMS_SERVER:
            /*
	    **  Interpret and edit LIST output from VMS server
	    **  and convert information lines to zero length.
d1998 2
a1999 2
            /*
	    **  Get rid of any junk lines.
d2005 1
a2005 1
	    **  Trim off VMS directory extensions.
d2008 1
a2008 1
            if ((len > 4) && !strcmp(&entry_info->filename[len-4], ".dir")) {
d2010 1
a2010 1
                StrAllocCopy(entry_info->type, "Directory");
d2014 1
a2014 1
	    **  Goto the bottom and get real type.
d2016 1
a2016 1
            break;
d2018 4
a2021 4
        case MS_WINDOWS_SERVER:
            /*
	    **  Interpret and edit LIST output from MS_WINDOWS server
	    **  and convert information lines to zero length.
d2025 2
a2026 2
            /*
	    **  Get rid of any junk lines.
d2035 1
a2035 1
	    **  Goto the bottom and get real type.
d2040 4
a2043 4
        case WINDOWS_NT_SERVER:
            /*
	    **  Interpret and edit LIST output from MS_WINDOWS server
	    **  and convert information lines to zero length.
d2047 2
a2048 2
            /*
	    **  Get rid of any junk lines.
d2057 1
a2057 1
	    **  Goto the bottom and get real type.
d2062 1
a2062 1
        case CMS_SERVER:
d2064 3
a2066 3
            /*
	    **  Interpret and edit LIST output from VM/CMS server
	    **  and convert any information lines to zero length.
d2070 2
a2071 2
            /*
	    **  Get rid of any junk lines.
d2080 1
a2080 1
	    **  Goto the bottom and get real type.
d2085 4
a2088 4
        case NCSA_SERVER:
        case TCPC_SERVER:
            /*
	    **  Directories identified by trailing "/" characters.
d2091 3
a2093 3
            len = strlen(entry);
            if (entry[len-1] == '/') {
                /*
d2096 2
a2097 2
                entry[len-1] = '\0';
                StrAllocCopy(entry_info->type, "Directory");
d2099 1
a2099 1
            }
d2101 1
a2101 1
	    **  Goto the bottom and get real type.
d2103 1
a2103 1
            break;
d2107 2
a2108 2
	    **  We can't tell if it is a directory since we only
	    **  did an NLST :(  List bad file types anyways? NOT!
a2111 1
	    break; /* not needed */
d2124 3
a2126 3
	    **  Don't treat this as application/x-Troff-me
	    **  if it's a Unix server but has the string
	    **  "read.me", or if it's not a Unix server. - FM
d2137 1
a2137 1
    **  Get real types eventually.
d2141 3
a2143 3
        HTFormat format;
        HTAtom * encoding;  /* @@@@ not used at all */
        format = HTFileFormat(entry_info->filename, &encoding, &cp2);
d2155 1
a2155 1
        StrAllocCopy(entry_info->type, cp2);
d2169 1
a2169 1
        case FILE_BY_SIZE:
d2171 1
a2171 1
            if (entry1->size == entry2->size)
a2177 1
            break;
d2179 3
a2181 3
        case FILE_BY_TYPE:
            if (entry1->type && entry2->type) {
                status = strcasecomp(entry1->type, entry2->type);
d2186 1
a2186 2
            return (strcmp(entry1->filename, entry2->filename));
            break;
d2188 2
a2189 2
        case FILE_BY_DATE:
            if (entry1->date && entry2->date) {
d2209 1
a2209 1
		    strcpy(time1, (char *)&entry1->date[7]);
d2214 1
a2214 1
		    strcpy(date1, (char *)&entry1->date[8]);
d2221 1
a2221 1
		        break;
d2223 1
a2223 1
	        }
d2227 1
a2227 1
		strncat(date1, (char *)&entry1->date[4], 2);
d2239 2
a2240 2
		        strcpy(date2, "9999");
			strcpy(time2, (char *)&entry2->date[7]);
d2245 2
a2246 2
			strcpy(date2, (char *)&entry2->date[8]);
		        strcpy(time2, "00:00");
d2252 1
a2252 1
		        break;
d2258 1
a2258 1
		strncat(date2, (char *)&entry2->date[4], 2);
d2272 1
a2272 1
                status = strcasecomp(date2, date1);
d2277 1
a2277 2
            return (strcmp(entry1->filename, entry2->filename));
            break;
d2279 3
a2281 3
        case FILE_BY_NAME:
        default:
            return (strcmp(entry1->filename, entry2->filename));
d2316 1
a2316 1
    _HTProgress ("Receiving FTP directory.");
d2319 2
a2320 2
    **  Check whether we always want the home
    **  directory treated as Welcome. - FM
d2323 1
a2323 1
        tildeIsTop = TRUE;
d2326 5
a2330 5
    **  This should always come back FALSE, since the
    **  flag is set only for local directory listings
    **  if LONG_LIST was defined on compilation, but
    **  we could someday set up an equivalent listing
    **  for Unix ftp servers. - FM
d2337 3
a2339 3
        StrAllocCopy (lastpath, "/");
    } else if (!strcmp(filename,"/")) {	  /* Root path. */
        StrAllocCopy (lastpath, "/foo/..");
d2341 1
a2341 1
        char * p = strrchr(filename, '/');	     /* Find the lastslash. */
d2351 1
a2351 1
	        if (TOUPPER(*(cp+6)) == 'D' ||
d2362 2
a2363 2
        HTBTree * bt = HTBTree_new((HTComparer)compare_EntryInfo_structs);
        char c;
d2368 2
a2369 2
	PUTS("\n");  /* prettier LJM */
	for (c = 0; c != (char)EOF;) {  /* For each entry in the directory */
d2373 1
a2373 1
	    	WasInterrupted = TRUE;
d2375 1
a2375 1
		    goto unload_btree;  /* unload btree */
d2383 1
a2383 1
	    /*   read directory entry
d2385 2
a2386 2
	    for (;;) {                 /* Read in one line as filename */
		c = NEXT_DATA_CHAR;
d2389 1
a2389 1
	    	    WasInterrupted = TRUE;
d2391 7
a2397 7
		        goto unload_btree;  /* unload btree */
                    } else {
                        ABORT_TARGET;
                        HTBTreeAndObject_free(bt);
                        return HT_INTERRUPTED;
                    }
		} else if (c == CR || c == LF) {    /* Terminator? */
d2399 27
a2425 27
		        /* Deal with MultiNet's wrapping of long lines */
                        if (server_type == VMS_SERVER) {
                        /* Deal with MultiNet's wrapping of long lines - F.M. */
                            if (data_read_pointer < data_write_pointer &&
                                *(data_read_pointer+1) == ' ')
                                data_read_pointer++;
                            else if (data_read_pointer >= data_write_pointer) {
                                status = NETREAD(data_soc, data_buffer,
                                                 DATA_BUFFER_SIZE);
                                if (status == HT_INTERRUPTED) {
                                    interrupted_in_next_data_char = 1;
                                    goto AgainForMultiNet;
                                }
                                if (status <= 0) {
                                    c = (char)EOF;
                                    break;
                                }
                                data_write_pointer = data_buffer + status;
                                data_read_pointer = data_buffer;
                                if (*data_read_pointer == ' ')
                                    data_read_pointer++;
                                else
                                    break;
                            }
                            else
                                break;
                        }
d2427 1
a2427 1
		            break;            /* finish getting one entry */
d2429 2
a2430 2
		} else if (c == (char)EOF) {
		    break;             /* End of file */
d2432 1
a2432 1
		    HTChunkPutc(chunk, c);
d2434 1
a2434 1
            }
d2439 1
a2439 1
	        sprintf(NumBytes,"Transferred %d bytes",BytesReceived);
d2444 1
a2444 1
	    if (c == (char) EOF && chunk->size == 1)
d2446 3
a2448 4
	        break;
            if (TRACE)
	        fprintf(stderr, "HTFTP: Line in %s is %s\n",
	    			lastpath, chunk->data);
d2452 3
a2454 4
		if (TRACE)
		    fprintf(stderr, "Adding file to BTree: %s\n",
		     		    entry_info->filename);
	        HTBTree_add(bt, (EntryInfo *)entry_info);
d2456 1
d2464 1
a2464 1
        HTChunkFree(chunk);
d2470 1
d2472 1
a2472 1
	    init_help_message_cache();  /* to free memory */
d2474 1
d2477 1
a2477 1
	    PUTS("\n");
d2482 1
a2482 1
	/* PUTS("    Date        Type             Size     Filename\n");
d2504 1
a2504 1
		        PUTC(entry_info->type[i]);
d2506 1
a2506 1
		        PUTC(' ');
d2520 2
a2521 2
					        entry_info->size/1024);
			  PUTS(string_buffer);
d2546 3
a2548 3
        if (server_type != CMS_SERVER)
            response(NIL);
	_HTProgress("Data transfer interrupted.");
d2552 1
a2552 1
        response(NIL);
a2578 1
    char command[LINE_LENGTH+1];
d2596 4
a2599 4
            control->socket = -1;
            close_master_socket ();
            /* HT_INTERRUPTED would fall through, if we could interrupt
               somehow in the middle of it, which we currently can't. */
d2609 7
a2615 9
              if (TRACE)
                fprintf (stderr,
			 "HTFTP: Interrupted in response (port_command)\n");
              _HTProgress ("Connection interrupted.");
              NETCLOSE (control->socket);
              control->socket = -1;
              close_master_socket ();
              return HT_INTERRUPTED;
            }
d2621 1
a2621 2
	    if (TRACE)
	        fprintf(stderr, "HTFTP: Port defined.\n");
d2628 1
d2634 1
a2634 2
	    sprintf(command, "PASV%c%c", CR, LF);
	    status = response(command);
d2646 9
a2654 10
           status = sscanf(p+1, "%d,%d,%d,%d,%d,%d",
                   &h0, &h1, &h2, &h3, &p0, &p1);
           if (status < 4) {
               fprintf(stderr, "HTFTP: PASV reply has no inet address!\n");
               return -99;
           }
           passive_port = (p0<<8) + p1;
	   if (TRACE)
               fprintf(stderr, "HTFTP: Server is listening on port %d\n",
				passive_port);
d2660 2
a2661 2
            "ftp://%d.%d.%d.%d:%d/",h0,h1,h2,h3,passive_port);
            status = HTDoConnect(name, "FTP", passive_port, &data_soc);
d2664 1
a2664 1
		(void) HTInetStatus("connect for data");
d2669 1
a2669 2
	    if (TRACE)
	        fprintf(stderr, "FTP data connected, socket %d\n", data_soc);
d2673 1
a2673 1
        break;	/* No more retries */
d2677 1
a2677 1
        return status;		/* Failed with this code */
d2682 2
a2683 2
        char *filename = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
	char *fname = filename;	/** Save for subsequent free() **/
d2691 1
a2691 1
	        TOUPPER(cp[2]) == 'F') {
d2696 1
a2696 4
		if (TRACE) {
		    fprintf(stderr,
		     "HTFTP: Rejecting path due to illegal escaped slash.\n");
		}
d2706 1
a2706 1
	    **  Check and trim the type= parameter. - FM
d2709 1
a2709 1
	        switch(TOUPPER(*(type+6))) {
d2731 2
a2732 2
	    if (TRACE && *type != '\0') {
	        fprintf(stderr, "HTFTP: type=%s\n", type);
d2736 1
a2736 2
	if (TRACE)
	    fprintf(stderr, "HTFTP: UnEscaped %s\n", filename);
d2748 1
a2748 2
	    sprintf(command, "PWD%c%c", CR, LF);
	    status = response(command);
d2750 1
a2750 2
		sprintf(command, "CWD %s%c%c", (filename+1), CR, LF);
		status = response(command);
d2767 1
a2767 1
	        *cp2 = '/';
d2773 1
a2773 1
	         0 == strncasecomp(cp2, ".me", 3)) &&
d2780 1
a2780 1
	        if ((server_type != UNIX_SERVER) ||
d2782 1
a2782 1
	             0 == strncasecomp((cp2 - 4), "read.me", 7))) {
d2790 1
a2790 1
	        format = HTFileFormat(filename, &encoding, NULL);
d2800 5
a2804 5
	    **  Force binary if we're in source, download or dump
	    **  mode and this is not a VM/CMS server, so we don't
	    **  get CRLF instead of LF (or CR) for newlines in text
	    **  files.  Can't do this for VM/CMS or we'll get
	    **  raw EBCDIC.  - FM
d2807 1
a2807 1
    	     format_out == HTAtom_for("www/download") ||
d2813 1
a2813 1
	    **  Force binary if we had ;type=I - FM
d2818 1
a2818 1
	    **  Force ASCII if we had ;type=A - FM
d2822 1
a2822 1
        if (binary != control->binary) {
d2824 1
a2824 1
	    **  Act on our setting if not alread set. - FM
d2827 1
a2827 2
	    sprintf(command, "TYPE %s%c%c", mode, CR, LF);
	    status = response(command);
d2830 1
a2830 1
	        return ((status < 0) ? status : -status);
d2846 1
a2846 1
	        strchr(filename, '[') != NULL) {
d2851 1
a2851 4
		if (TRACE) {
		    fprintf(stderr,
		     "HTFTP: Rejecting path due to non-Unix-style syntax.\n");
		}
d2856 1
a2856 1
	        int i;
d2861 1
a2861 3
		if (TRACE) {
		    fprintf(stderr, "HTFTP: Trimmed '%s'\n", filename);
		}
d2863 1
a2863 3
		if (TRACE) {
		    fprintf(stderr, "HTFTP: VMSized '%s'\n", cp);
		}
d2867 1
a2867 1
		        filename[i] = cp1[i];
d2869 1
a2869 3
		    if (TRACE) {
		        fprintf(stderr, "HTFTP: Filename '%s'\n", filename);
		    }
d2871 1
a2871 2
		    sprintf(command, "CWD %s%c%c", cp, CR, LF);
		    status = response (command);
d2873 2
a2874 1
		        if ((cp1=strchr(cp, '[')) != NULL) {
d2876 1
a2876 2
			    sprintf(command, "CWD %s%c%c", cp, CR, LF);
			    status = response (command);
d2878 1
a2878 1
			        FREE(fname);
d2884 3
a2886 2
			    sprintf(command, "CWD [.%s%c%c", cp1, CR, LF);
			    status = response (command);
d2888 1
a2888 1
			        FREE(fname);
d2895 2
a2896 2
		            FREE(fname);
			    init_help_message_cache();  /* to free memory */
d2910 2
a2911 4
			if (TRACE) {
			    fprintf(stderr, "HTFTP: Filename '%s'\n", filename);
			}
		        *cp1 = '\0';
d2915 1
a2915 2
			sprintf(command, "CWD %s%c%c", cp, CR, LF);
			status = response (command);
d2919 1
a2919 2
			    sprintf(command, "CWD %s%c%c", cp, CR, LF);
			    status = response (command);
d2921 2
a2922 3
			        *cp1 = '\0';
				sprintf(command, "CWD %s%c%c", cp, CR, LF);
				status = response (command);
d2924 1
a2924 1
			            FREE(fname);
d2928 1
a2928 1
			            return ((status < 0) ? status : -status);
d2937 1
a2937 2
		    sprintf(command, "CWD %s%c%c", cp, CR, LF);
		    status = response (command);
d2940 1
a2940 2
			sprintf(command, "CWD %s%c%c", cp, CR, LF);
			status = response (command);
d2943 1
a2943 1
			    init_help_message_cache();  /* to free memory */
d2955 1
a2955 1
	        filename[strlen(filename)-1] = '\0';
d2959 5
a2963 6
	        /** Get the current default VMS device:[directory] **/
	        sprintf(command, "PWD%c%c", CR, LF);
	        status = response (command);
	        if (status != 2) {
	            FREE(fname);
		    init_help_message_cache();  /* to free memory */
d2967 19
a2985 10
	        }
	        /** Go to the VMS account's top directory **/
	        if ((cp=strchr(response_text, '[')) != NULL &&
	            (cp1=strrchr(response_text, ']')) != NULL) {
		    sprintf(command, "CWD %s", cp);
		    if ((cp2=strchr(cp, '.')) != NULL && cp2 < cp1)
		        sprintf(command+(cp2-cp)+4, "]%c%c", CR, LF);
		    else
		        sprintf(command+(cp1-cp)+4, "]%c%c", CR, LF);
		    status = response (command);
d2987 1
a2987 1
		        FREE(fname);
d2991 1
a2991 1
		        return ((status < 0) ? status : -status);
d2999 2
a3000 2
	        (included_device && 0==strcmp(filename, "000000")) ||
	        (strlen(filename) == 1 && *filename == '/')) {
d3002 1
a3002 2
		sprintf(command, "LIST%c%c", CR, LF);
		status = response (command);
d3006 1
a3006 1
		    init_help_message_cache();  /* to free memory */
d3016 2
a3017 1
	        filename += 2;
d3019 9
a3027 5
	        (cp = strchr(filename, '/')) != NULL &&
	        (cp1 = strrchr(cp, '/')) != NULL && cp != cp1) {
		sprintf(command, "CWD [.%s", cp+1);
		sprintf(command+(cp1-cp)+5, "]%c%c", CR, LF);
		while ((cp2 = strrchr(command, '/')) != NULL)
d3029 5
a3033 1
		status = response(command);
d3036 1
a3036 1
		    init_help_message_cache();  /* to free memory */
d3043 2
a3044 2
	        if (!included_device) {
	            filename += 1;
d3052 3
a3054 3
	    **  If we want the CMS account's top directory, or a base
	    **  SFS or anonymous directory path (i.e., without a slash),
	    **  list it now. FM
d3057 1
a3057 1
	        ((0 == strncasecomp((filename+1), "vmsysu:", 7)) &&
d3063 1
a3063 2
		    sprintf(command, "CWD %s%c%c", (filename+1), CR, LF);
		    status = response(command);
d3065 1
a3065 1
		        /* Action not started */
d3074 1
a3074 1
		    sprintf(command, "LIST%c%c", CR, LF);
d3076 1
a3076 2
		    sprintf(command, "NLST%c%c", CR, LF);
		status = response (command);
d3080 1
a3080 1
		    init_help_message_cache();  /* to free memory */
d3092 2
a3093 3
	        *cp++ = '\0';
		sprintf(command, "CWD %s%c%c", filename, CR, LF);
		status = response(command);
d3098 1
a3098 1
			    sprintf(command, "LIST%c%c", CR, LF);
d3100 1
a3100 2
			    sprintf(command, "NLST%c%c", CR, LF);
			status = response (command);
d3104 1
a3104 1
			    init_help_message_cache();  /* to free memory */
d3122 1
a3122 1
	        filename++;
d3130 1
a3130 2
	    sprintf(command, "RETR %s%c%c", filename, CR, LF);
	    status = response(command);
d3137 1
a3137 1
	        init_help_message_cache();
d3139 7
a3145 10
	    sprintf(command, "CWD %s%c%c", filename, CR, LF);
	    status = response(command);

	    if (status == 2) {  /* Successed : let's NAME LIST it */
	        isDirectory = YES;
	    if (use_list)
	        sprintf(command, "LIST%c%c", CR, LF);
	    else
	        sprintf(command, "NLST%c%c", CR, LF);
	    status = response (command);
d3150 1
a3150 1
	    init_help_message_cache();  /* to free memory */
d3154 1
a3154 1
	        return status;
d3156 1
a3156 1
	        return -status;
d3166 1
a3166 1
        int	soc_addrlen=sizeof(soc_address);
d3178 1
a3178 1
	    init_help_message_cache();  /* to free memory */
d3188 2
a3189 2
        status = read_directory (anchor, name, format_out, sink);
        NETCLOSE(data_soc);
d3193 1
a3193 1
        return status;
d3196 1
a3196 1
        int rv;
d3207 3
a3209 3
	     *  We already know from the call to HTFileFormat above that
	     *  this is a compressed file, no need to look at the filename
	     *  again. - kw
d3217 1
a3217 1
	        (FileName[len - 2] == '.' ||
d3228 1
a3228 1
	    	       !strcasecomp((char *)&FileName[len - 2], "gz")) {
d3243 1
a3243 1
	_HTProgress ("Receiving FTP file.");
d3247 1
a3247 1
	     _HTProgress("Data transfer interrupted.");
d3253 1
a3253 2
	if (TRACE)
	    fprintf(stderr, "HTFTP: Closing data socket %d\n", data_soc);
d3262 1
a3262 1
	        return HTLoadError(sink, 500, response_text);
d3280 4
a3283 4
    **  Need code to check cached documents from
    **  non-anonymous ftp accounts and do something
    **  to ensure that they no longer can be accessed
    **  without a new retrieval. - FM
d3287 2
a3288 2
    **  Now free the current user entered password,
    **  if any. - FM
d3292 2
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
