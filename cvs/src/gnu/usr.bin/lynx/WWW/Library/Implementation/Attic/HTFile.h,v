head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.46;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTFile.h,v 1.33 2012/02/10 00:59:15 tom Exp $
 *							File access in libwww
 *				FILE ACCESS
 *
 *  These are routines for local file access used by WWW browsers and servers.
 *  Implemented by HTFile.c.
 *
 *  If the file is not a local file, then we pass it on to HTFTP in case it
 *  can be reached by FTP.
 */
#ifndef HTFILE_H
#define HTFILE_H

#include <HTFormat.h>
#include <HTAccess.h>

#ifndef HTML_H
#include <HTML.h>		/* SCW */
#endif /* HTML_H */

#ifdef __cplusplus
extern "C" {
#endif
/*
 *  Controlling globals
 *
 *  These flags control how directories and files are represented as
 *  hypertext, and are typically set by the application from command
 *  line options, etc.
				 */ extern int HTDirAccess;
    /* Directory access level */

#define HT_DIR_FORBID           0	/* Altogether forbidden */
#define HT_DIR_SELECTIVE        1	/* If HT_DIR_ENABLE_FILE exists */
#define HT_DIR_OK               2	/* Any accesible directory */

#define HT_DIR_ENABLE_FILE      ".www_browsable"	/* If exists, can browse */

    extern int HTDirReadme;	/* Include readme files in listing? */

    /* Values: */
#define HT_DIR_README_NONE      0	/* No */
#define HT_DIR_README_TOP       1	/* Yes, first */
#define HT_DIR_README_BOTTOM    2	/* Yes, at the end */

#define HT_DIR_README_FILE              "README"

/*
 *  Convert filenames between local and WWW formats
 */
    extern char *HTURLPath_toFile(const char *name, int expand_all, int is_remote);
    extern char *HTnameOfFile_WWW(const char *name, int WWW_prefix, int expand_all);

#define HTLocalName(name)      HTnameOfFile_WWW(name,TRUE,TRUE)
#define HTfullURL_toFile(name) HTnameOfFile_WWW(name,FALSE,TRUE)
#define HTpartURL_toFile(name) HTnameOfFile_WWW(name,FALSE,FALSE)

/*
 *  Make a WWW name from a full local path name
 */
    extern char *WWW_nameOfFile(const char *name);

/*
 *  Generate the name of a cache file
 */
    extern char *HTCacheFileName(const char *name);

/*
 *  Generate fragments of HTML for source-view:
 */
    extern void HTStructured_doctype(HTStructured * target, HTFormat format_out);

    extern void HTStructured_meta(HTStructured * target, HTFormat format_out);
/*
 *  Output directory titles
 *
 * This is (like the next one) used by HTFTP. It is common code to generate
 * the title and heading 1 and the parent directory link for any anchor.
 *
 * changed to return TRUE if parent directory link was generated,
 * FALSE otherwise - KW
 */
    extern BOOL HTDirTitles(HTStructured * target, HTParentAnchor *anchor,
			    HTFormat format_out,
			    int tildeIsTop);

/*
 *	Check existence.
 */
    extern int HTStat(const char *filename,
		      struct stat *data);

/*	Load a document.
 *	----------------
 */
    extern int HTLoadFile(const char *addr,
			  HTParentAnchor *anchor,
			  HTFormat format_out,
			  HTStream *sink);

/*
 *  Output a directory entry
 *
 * This is used by HTFTP.c for example -- it is a common routine for
 *  generating a linked directory entry.
 */
    extern void HTDirEntry(HTStructured * target, /* in which to put the linked text */ const char *tail,	/* last part of directory name */
			   const char *entry);	/* name of this entry */

/*
 *  HTSetSuffix: Define the representation for a file suffix
 *
 *  This defines a mapping between local file suffixes and file content
 *  types and encodings.
 *
 *  ON ENTRY,
 *
 *  suffix		includes the "." if that is important (normally, yes!)
 *
 *  representation	is MIME-style content-type
 *
 *  encoding		is MIME-style content-transfer-encoding
 *			(8bit, 7bit, etc) or HTTP-style content-encoding
 *			(gzip, compress etc.)
 *
 *  quality		an a priori judgement of the quality of such files
 *			(0.0..1.0)
 *
 *  HTSetSuffix5 has one more parameter for a short description of the type
 *  which is otherwise derived from the representation:
 *
 *  desc		is a short textual description, or NULL
 *
 *  Examples:   HTSetSuffix(".ps", "application/postscript", "8bit", 1.0);
 *  Examples:   HTSetSuffix(".psz", "application/postscript", "gzip", 1.0);
 *  A MIME type could also indicate a non-trivial encoding on its own
 *  ("application/x-compressed-tar"), but in that case don't use enconding
 *  to also indicate it but use "binary" etc.
 */
    extern void HTSetSuffix5(const char *suffix,
			     const char *representation,
			     const char *encoding,
			     const char *desc,
			     double quality);

#define HTSetSuffix(suff,rep,enc,q) HTSetSuffix5(suff, rep, enc, NULL, q)

/*
 *  HTFileFormat: Get Representation and Encoding from file name.
 *
 *  ON EXIT,
 *
 *  return		The represntation it imagines the file is in.
 *
 *  *pEncoding		The encoding (binary, 7bit, etc). See HTSetSuffix.
 */
    extern HTFormat HTFileFormat(const char *filename,
				 HTAtom **pEncoding,
				 const char **pDesc);

/*
 *  HTCharsetFormat: Revise the file format in relation to the Lynx charset.
 *
 *  This checks the format associated with an anchor for
 *  for an extended MIME Content-Type, and if a charset is
 *  indicated, sets Lynx up for proper handling in relation
 *  to the currently selected character set. - FM
 */
    extern HTFormat HTCharsetFormat(HTFormat format,
				    HTParentAnchor *anchor,
				    int default_LYhndl);

/*	Get various pieces of meta info from file name.
 *	-----------------------------------------------
 *
 *  LYGetFileInfo fills in information that can be determined without
 *  an actual (new) access to the filesystem, based on current suffix
 *  and character set configuration.  If the file has been loaded and
 *  parsed before  (with the same URL generated here!) and the anchor
 *  is still around, some results may be influenced by that (in
 *  particular, charset info from a META tag - this is not actually
 *  tested!).
 *  The caller should not keep pointers to the returned objects around
 *  for too long, the valid lifetimes vary. In particular, the returned
 *  charset string should be copied if necessary.  If return of the
 *  file_anchor is requested, that one can be used to retrieve
 *  additional bits of info that are stored in the anchor object and
 *  are not covered here; as usual, don't keep pointers to the
 *  file_anchor longer than necessary since the object may disappear
 *  through HTuncache_current_document or at the next document load.
 *  - kw
 */
    extern void LYGetFileInfo(const char *filename,
			      HTParentAnchor **pfile_anchor,
			      HTFormat *pformat,
			      HTAtom **pencoding,
			      const char **pdesc,
			      const char **pcharset,
			      int *pfile_cs);

/*
 *  Determine file value from file name.
 */
    extern float HTFileValue(const char *filename);

/*
 *  Known compression types.
 */
    typedef enum {
	cftNone
	,cftCompress
	,cftGzip
	,cftBzip2
	,cftDeflate
    } CompressFileType;

/*
 *  Determine compression type from file name, by looking at its suffix.
 */
    extern CompressFileType HTCompressFileType(const char *filename,
					       const char *dots,
					       int *rootlen);

/*
 *  Determine compression type from the content-encoding.
 */
    extern CompressFileType HTEncodingToCompressType(const char *encoding);
/*
 *  Determine compression type from the content-encoding.
 */
    extern CompressFileType HTContentTypeToCompressType(const char *ct);
/*
 *  Determine compression type from the content-type and/or content-encoding.
 */
    extern CompressFileType HTContentToCompressType(HTParentAnchor *anchor);
/*
 *  Determine compression encoding from the compression method.
 */
    extern const char *HTCompressTypeToEncoding(CompressFileType method);
/*
 *  Determine expected file-suffix from the compression method.
 */
    extern const char *HTCompressTypeToSuffix(CompressFileType method);
/*
 *  Determine write access to a file.
 *
 *  ON EXIT,
 *
 *  return value	YES if file can be accessed and can be written to.
 *
 *  BUGS
 *
 *   Isn't there a quicker way?
 */

#if defined(HAVE_CONFIG_H)

#ifndef HAVE_GETGROUPS
#define NO_GROUPS
#endif

#else

#ifdef VMS
#define NO_GROUPS
#endif				/* VMS */
#ifdef NO_UNIX_IO
#define NO_GROUPS
#endif				/* NO_UNIX_IO */
#ifdef PCNFS
#define NO_GROUPS
#endif				/* PCNFS */
#ifdef NOUSERS
#define NO_GROUPS
#endif				/* PCNFS */

#endif				/* HAVE_CONFIG_H */

    extern BOOL HTEditable(const char *filename);

/*	Make a save stream.
 *	-------------------
 */
    extern HTStream *HTFileSaveStream(HTParentAnchor *anchor);

/*
 * Determine a suitable suffix, given the representation.
 *
 *  ON ENTRY,
 *
 *  rep			is the atomized MIME style representation
 *  enc			is an encoding (8bit, binary, gzip, compress,..)
 *
 *  ON EXIT,
 *
 *  returns		a pointer to a suitable suffix string if one has
 *			been found, else NULL.
 */
    extern const char *HTFileSuffix(HTAtom *rep,
				    const char *enc);

/*
 * Enumerate external programs that lynx may assume exists.  Unlike those
 * given in download scripts, etc., lynx would really like to know their
 * absolute paths, for better security.
 */
    typedef enum {
	ppUnknown = 0
	,ppBZIP2
	,ppCHMOD
	,ppCOMPRESS
	,ppCOPY
	,ppCSWING
	,ppGZIP
	,ppINFLATE
	,ppINSTALL
	,ppMKDIR
	,ppMV
	,ppRLOGIN
	,ppRM
	,ppRMDIR
	,ppSETFONT
	,ppTAR
	,ppTELNET
	,ppTN3270
	,ppTOUCH
	,ppUNCOMPRESS
	,ppUNZIP
	,ppUUDECODE
	,ppZCAT
	,ppZIP
	,pp_Last
    } ProgramPaths;

/*
 * Given a program number, return its path
 */
    extern const char *HTGetProgramPath(ProgramPaths code);

/*
 * Store a program's path 
 */
    extern void HTSetProgramPath(ProgramPaths code,
				 const char *path);

/*
 * Reset the list of known program paths to the ones that are compiled-in
 */
    extern void HTInitProgramPaths(BOOL init);

/*
 *  The Protocols
 */
#ifdef GLOBALREF_IS_MACRO
    extern GLOBALREF (HTProtocol, HTFTP);
    extern GLOBALREF (HTProtocol, HTFile);

#else
    GLOBALREF HTProtocol HTFTP, HTFile;
#endif				/* GLOBALREF_IS_MACRO */

#ifdef __cplusplus
}
#endif
#endif				/* HTFILE_H */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTFile.h,v 1.31 2008/12/07 18:49:53 tom Exp $
d52 2
a53 2
    extern char *HTURLPath_toFile(const char *name, BOOL expand_all, BOOL is_remote);
    extern char *HTnameOfFile_WWW(const char *name, BOOL WWW_prefix, BOOL expand_all);
d86 1
a86 1
			    BOOL tildeIsTop);
d350 1
a350 1
    extern void HTInitProgramPaths(void);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
a3 1
/*							File access in libwww
d226 1
a226 1
 *  Determine compression type from the content-type.
d228 1
a228 2
    extern CompressFileType HTContentToCompressType(const char *encoding);

d232 13
a244 2
    extern CompressFileType HTEncodingToCompressType(const char *encoding);

@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 8
a9 8
**				FILE ACCESS
**
**  These are routines for local file access used by WWW browsers and servers.
**  Implemented by HTFile.c.
**
**  If the file is not a local file, then we pass it on to HTFTP in case it
**  can be reached by FTP.
*/
d15 1
d17 1
a17 1
#include <HTML.h>               /* SCW */
d20 3
d24 20
a43 19
**  Controlling globals
**
**  These flags control how directories and files are represented as
**  hypertext, and are typically set by the application from command
**  line options, etc.
*/
extern int HTDirAccess;         /* Directory access level */

#define HT_DIR_FORBID           0       /* Altogether forbidden */
#define HT_DIR_SELECTIVE        1       /* If HT_DIR_ENABLE_FILE exists */
#define HT_DIR_OK               2       /* Any accesible directory */

#define HT_DIR_ENABLE_FILE      ".www_browsable" /* If exists, can browse */

extern int HTDirReadme;         /* Include readme files in listing? */
                                        /* Values: */
#define HT_DIR_README_NONE      0       /* No */
#define HT_DIR_README_TOP       1       /* Yes, first */
#define HT_DIR_README_BOTTOM    2       /* Yes, at the end */
d48 5
a52 4
**  Convert filenames between local and WWW formats
*/
extern char * HTURLPath_toFile PARAMS((CONST char * name, BOOL expand_all, BOOL is_remote));
extern char * HTnameOfFile_WWW PARAMS((CONST char * name, BOOL WWW_prefix, BOOL expand_all));
d58 33
a90 29
**  Make a WWW name from a full local path name
*/
extern char * WWW_nameOfFile PARAMS((CONST char * name));

/*
**  Generate the name of a cache file
*/
extern char * HTCacheFileName PARAMS((CONST char * name));

/*
**  Output directory titles
**
** This is (like the next one) used by HTFTP. It is common code to generate
** the title and heading 1 and the parent directory link for any anchor.
**
** changed to return TRUE if parent directory link was generated,
** FALSE otherwise - KW
*/
extern BOOL HTDirTitles PARAMS((
        HTStructured *  target,
        HTParentAnchor* anchor,
	BOOL		tildeIsTop));

/*
**	Check existence.
*/
extern int HTStat PARAMS((
	CONST char *	filename,
	struct stat *	data));
d93 51
a143 55
**	----------------
*/
extern int HTLoadFile PARAMS((
	CONST char *		addr,
	HTParentAnchor *	anchor,
	HTFormat		format_out,
	HTStream *		sink));

/*
**  Output a directory entry
**
** This is used by HTFTP.c for example -- it is a common routine for
**  generating a linked directory entry.
*/
extern void HTDirEntry PARAMS((
        HTStructured *  target,         /* in which to put the linked text */
        CONST char *    tail,           /* last part of directory name */
        CONST char *    entry));        /* name of this entry */

/*
**  HTSetSuffix: Define the representation for a file suffix
**
**  This defines a mapping between local file suffixes and file content
**  types and encodings.
**
**  ON ENTRY,
**
**  suffix		includes the "." if that is important (normally, yes!)
**
**  representation	is MIME-style content-type
**
**  encoding		is MIME-style content-transfer-encoding
**			(8bit, 7bit, etc) or HTTP-style content-encoding
**			(gzip, compress etc.)
**
**  quality		an a priori judgement of the quality of such files
**			(0.0..1.0)
**
**  HTSetSuffix5 has one more parameter for a short description of the type
**  which is otherwise derived from the representation:
**
**  desc		is a short textual description, or NULL
**
**  Examples:   HTSetSuffix(".ps", "application/postscript", "8bit", 1.0);
**  Examples:   HTSetSuffix(".psz", "application/postscript", "gzip", 1.0);
**  A MIME type could also indicate a non-trivial encoding on its own
**  ("application/x-compressed-tar"), but in that case don't use enconding
**  to also indicate it but use "binary" etc.
*/
extern void HTSetSuffix5 PARAMS((
        CONST char *    suffix,
        CONST char *    representation,
        CONST char *    encoding,
        CONST char *    desc,
        double          quality));
d148 23
a170 25
**  HTFileFormat: Get Representation and Encoding from file name.
**
**  ON EXIT,
**
**  return		The represntation it imagines the file is in.
**
**  *pEncoding		The encoding (binary, 7bit, etc). See HTSetSuffix.
*/
extern HTFormat HTFileFormat PARAMS((
	CONST char *		filename,
	HTAtom **		pEncoding,
	CONST char **		pDesc));

/*
**  HTCharsetFormat: Revise the file format in relation to the Lynx charset.
**
**  This checks the format associated with an anchor for
**  for an extended MIME Content-Type, and if a charset is
**  indicated, sets Lynx up for proper handling in relation
**  to the currently selected character set. - FM
*/
extern HTFormat HTCharsetFormat PARAMS((
	HTFormat		format,
	HTParentAnchor *	anchor,
	int			default_LYhndl));
d173 71
a243 60
**	-----------------------------------------------
**
**  LYGetFileInfo fills in information that can be determined without
**  an actual (new) access to the filesystem, based on current suffix
**  and character set configuration.  If the file has been loaded and
**  parsed before  (with the same URL generated here!) and the anchor
**  is still around, some results may be influenced by that (in
**  particular, charset info from a META tag - this is not actually
**  tested!).
**  The caller should not keep pointers to the returned objects around
**  for too long, the valid lifetimes vary. In particular, the returned
**  charset string should be copied if necessary.  If return of the
**  file_anchor is requested, that one can be used to retrieve
**  additional bits of info that are stored in the anchor object and
**  are not covered here; as usual, don't keep pointers to the
**  file_anchor longer than necessary since the object may disappear
**  through HTuncache_current_document or at the next document load.
**  - kw
*/
extern void LYGetFileInfo PARAMS((
	CONST char *		filename,
	HTParentAnchor **	pfile_anchor,
	HTFormat *		pformat,
	HTAtom **		pencoding,
	CONST char**		pdesc,
	CONST char**		pcharset,
	int *			pfile_cs));

/*
**  Determine file value from file name.
*/
extern float HTFileValue PARAMS((
	CONST char *	filename));

/*
**  Determine compression type from file name, by looking at its suffix.
*/
typedef enum {
    cftNone
    , cftCompress
    , cftGzip
    , cftBzip2
} CompressFileType;

extern CompressFileType HTCompressFileType PARAMS((
	char *			filename,
	char *			dots,
	char **			suffix));

/*
**  Determine write access to a file.
**
**  ON EXIT,
**
**  return value	YES if file can be accessed and can be written to.
**
**  BUGS
**
**   Isn't there a quicker way?
*/
d255 1
a255 1
#endif /* VMS */
d258 1
a258 1
#endif /* NO_UNIX_IO */
d261 1
a261 1
#endif /* PCNFS */
d264 1
a264 1
#endif /* PCNFS */
d266 1
a266 1
#endif /* HAVE_CONFIG_H */
d268 1
a268 1
extern BOOL HTEditable PARAMS((CONST char * filename));
d271 19
a289 21
**	-------------------
*/
extern HTStream * HTFileSaveStream PARAMS((
	HTParentAnchor *	anchor));

/*
** Determine a suitable suffix, given the representation.
**
**  ON ENTRY,
**
**  rep			is the atomized MIME style representation
**  enc			is an encoding (8bit, binary, gzip, compress,..)
**
**  ON EXIT,
**
**  returns		a pointer to a suitable suffix string if one has
**			been found, else NULL.
*/
extern CONST char * HTFileSuffix PARAMS((
                HTAtom* rep,
                CONST char* enc));
d296 27
a322 25
typedef enum {
    ppUnknown = 0
    ,ppBZIP2
    ,ppCHMOD
    ,ppCOMPRESS
    ,ppCOPY
    ,ppCSWING
    ,ppGZIP
    ,ppINSTALL
    ,ppMKDIR
    ,ppMV
    ,ppRLOGIN
    ,ppRM
    ,ppRMDIR
    ,ppTAR
    ,ppTELNET
    ,ppTN3270
    ,ppTOUCH
    ,ppUNCOMPRESS
    ,ppUNZIP
    ,ppUUDECODE
    ,ppZCAT
    ,ppZIP
    ,pp_Last
} ProgramPaths;
d327 1
a327 2
extern CONST char * HTGetProgramPath PARAMS((
		ProgramPaths code));
d332 2
a333 3
extern void HTSetProgramPath PARAMS((
		ProgramPaths code,
		CONST char *path));
d338 1
a338 1
extern void HTInitProgramPaths NOPARAMS;
d341 2
a342 2
**  The Protocols
*/
d344 3
a346 2
extern GLOBALREF (HTProtocol,HTFTP);
extern GLOBALREF (HTProtocol,HTFile);
d348 2
a349 2
GLOBALREF HTProtocol HTFTP, HTFile;
#endif /* GLOBALREF_IS_MACRO */
d351 4
a354 1
#endif /* HTFILE_H */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d45 1
a45 1
extern char * HTURLPath_toFile PARAMS((CONST char * name, BOOL expand_all));
d72 1
a72 1
        HTAnchor *      anchor,
d279 49
d336 1
a337 2

/* end of HTFile */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d45 1
d75 7
d137 1
a137 1
        float           quality));
d168 29
d204 15
d229 24
@


1.1
log
@Initial revision
@
text
@d13 2
a14 2
#include "HTFormat.h"
#include "HTAccess.h"
d16 1
a16 1
#include "HTML.h"               /* SCW */
d45 4
a48 1
extern char * HTLocalName PARAMS((CONST char * name));
d53 1
a53 1
extern char * WWW_nameOfFile PARAMS((const char * name));
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
