head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.14
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.12
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.10
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.8
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.04.24.03;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.47;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.45;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTMIME.c,v 1.88 2013/11/28 11:12:52 tom Exp $
 *
 *			MIME Message Parse			HTMIME.c
 *			==================
 *
 *	This is RFC 1341-specific code.
 *	The input stream pushed into this parser is assumed to be
 *	stripped on CRs, ie lines end with LF, not CR LF.
 *	(It is easy to change this except for the body part where
 *	conversion can be slow.)
 *
 * History:
 *	   Feb 92	Written Tim Berners-Lee, CERN
 *
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>
#include <HTMIME.h>		/* Implemented here */
#include <HTTP.h>		/* for redirecting_url */
#include <HTAlert.h>
#include <HTFile.h>
#include <HTCJK.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYCookie.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYLeaks.h>

/*		MIME Object
 *		-----------
 */

typedef enum {
    MIME_TRANSPARENT,		/* put straight through to target ASAP! */
    /* states for "Transfer-Encoding: chunked" */
    MIME_CHUNKED,
    mcCHUNKED_COUNT_DIGIT,
    mcCHUNKED_COUNT_CR,
    mcCHUNKED_COUNT_LF,
    mcCHUNKED_EXTENSION,
    mcCHUNKED_DATA,
    mcCHUNKED_DATA_CR,
    mcCHUNKED_DATA_LF,
    /* character state-machine */
    miBEGINNING_OF_LINE,	/* first character and not a continuation */
    miA,
    miACCEPT_RANGES,
    miAGE,
    miAL,
    miALLOW,
    miALTERNATES,
    miC,
    miCACHE_CONTROL,
    miCO,
    miCOOKIE,
    miCON,
    miCONNECTION,
    miCONTENT_,
    miCONTENT_BASE,
    miCONTENT_DISPOSITION,
    miCONTENT_ENCODING,
    miCONTENT_FEATURES,
    miCONTENT_L,
    miCONTENT_LANGUAGE,
    miCONTENT_LENGTH,
    miCONTENT_LOCATION,
    miCONTENT_MD5,
    miCONTENT_RANGE,
    miCONTENT_T,
    miCONTENT_TRANSFER_ENCODING,
    miCONTENT_TYPE,
    miDATE,
    miE,
    miETAG,
    miEXPIRES,
    miKEEP_ALIVE,
    miL,
    miLAST_MODIFIED,
    miLINK,
    miLOCATION,
    miP,
    miPR,
    miPRAGMA,
    miPROXY_AUTHENTICATE,
    miPUBLIC,
    miR,
    miRE,
    miREFRESH,
    miRETRY_AFTER,
    miS,
    miSAFE,
    miSE,
    miSERVER,
    miSET_COOKIE,
    miSET_COOKIE1,
    miSET_COOKIE2,
    miT,
    miTITLE,
    miTRANSFER_ENCODING,
    miU,
    miUPGRADE,
    miURI,
    miV,
    miVARY,
    miVIA,
    miW,
    miWARNING,
    miWWW_AUTHENTICATE,
    miSKIP_GET_VALUE,		/* Skip space then get value */
    miGET_VALUE,		/* Get value till white space */
    miJUNK_LINE,		/* Ignore the rest of this folded line */
    miNEWLINE,			/* Just found a LF .. maybe continuation */
    miCHECK,			/* check against check_pointer */
    MIME_NET_ASCII,		/* Translate from net ascii */
    MIME_IGNORE			/* Ignore entire file */
    /* TRANSPARENT and IGNORE are defined as stg else in _WINDOWS */
} MIME_state;

#define VALUE_SIZE 5120		/* @@@@@@@@@@@@@@ Arbitrary? */
struct _HTStream {
    const HTStreamClass *isa;

    BOOL net_ascii;		/* Is input net ascii? */
    MIME_state state;		/* current state */
    MIME_state if_ok;		/* got this state if match */
    MIME_state field;		/* remember which field */
    MIME_state fold_state;	/* state on a fold */
    BOOL head_only;		/* only parsing header */
    BOOL pickup_redirection;	/* parsing for location */
    BOOL no_streamstack;	/* use sink directly */
    const char *check_pointer;	/* checking input */

    char *value_pointer;	/* storing values */
    char value[VALUE_SIZE];

    HTParentAnchor *anchor;	/* Given on creation */
    HTStream *sink;		/* Given on creation */

    char *boundary;		/* For multipart */
    char *set_cookie;		/* Set-Cookie */
    char *set_cookie2;		/* Set-Cookie2 */
    char *location;		/* Location */

    char *refresh_url;		/* "Refresh:" URL */

    HTFormat c_t_encoding;	/* Content-Transfer-Encoding */
    char *compression_encoding;

    BOOL chunked_encoding;	/* Transfer-Encoding: chunked */
    long chunked_size;		/* ...counter for "chunked" */

    HTFormat format;		/* Content-Type */
    HTStream *target;		/* While writing out */
    HTStreamClass targetClass;

    HTAtom *targetRep;		/* Converting into? */
};

/*
 *  This function is for trimming off any paired
 *  open- and close-double quotes from header values.
 *  It does not parse the string for embedded quotes,
 *  and will not modify the string unless both the
 *  first and last characters are double-quotes. - FM
 */
void HTMIME_TrimDoubleQuotes(char *value)
{
    size_t i;
    char *cp = value;

    if (isEmpty(cp) || *cp != '"')
	return;

    i = strlen(cp);
    if (cp[(i - 1)] != '"')
	return;
    else
	cp[(i - 1)] = '\0';

    for (i = 0; value[i]; i++)
	value[i] = cp[(i + 1)];
}

/*
 * Check if the token from "Content-Encoding" corresponds to a compression
 * type.
 */
static BOOL content_is_compressed(HTStream *me)
{
    char *encoding = me->anchor->content_encoding;
    BOOL result = (BOOL) (HTEncodingToCompressType(encoding) != cftNone);

    CTRACE((tfp, "content is%s compressed\n", result ? "" : " NOT"));
    return result;
}

/*
 * Strip quotes from a refresh-URL.
 */
static void dequote(char *url)
{
    size_t len;

    len = strlen(url);
    if (*url == '\'' && len > 1 && url[len - 1] == url[0]) {
	url[len - 1] = '\0';
	while ((url[0] = url[1]) != '\0') {
	    ++url;
	}
    }
}

/*
 * Strip off any compression-suffix from the address and check if the result
 * looks like one of the presentable suffixes.  If so, return the corresponding
 * MIME type.
 */
static const char *UncompressedContentType(HTStream *me, CompressFileType method)
{
    const char *result = 0;
    char *address = me->anchor->address;
    const char *expected = HTCompressTypeToSuffix(method);
    const char *actual = strrchr(address, '.');

    /*
     * We have to ensure the suffix is consistent, to use HTFileFormat().
     */
    if (actual != 0 && !strcasecomp(actual, expected)) {
	HTFormat format;
	HTAtom *pencoding = 0;
	const char *description = 0;

	format = HTFileFormat(address, &pencoding, &description);
	result = HTAtom_name(format);
    }

    return result;
}

static int pumpData(HTStream *me)
{
    CompressFileType method;
    const char *new_encoding;
    const char *new_content;

    CTRACE((tfp, "Begin pumpData\n"));
    /*
     * If the content-type says it is compressed, and there is no
     * content-encoding, check further and see if the address (omitting the
     * suffix for a compressed type) looks like a type we can present.  If so,
     * rearrange things so we'll present the StreamStack code with the
     * presentable type, already marked as compressed.
     */
    CTRACE((tfp, "...address{%s}\n", me->anchor->address));
    method = HTContentTypeToCompressType(me->anchor->content_type_params);
    if ((method != cftNone)
	&& isEmpty(me->anchor->content_encoding)
	&& (new_content = UncompressedContentType(me, method)) != 0) {

	new_encoding = HTCompressTypeToEncoding(method);
	CTRACE((tfp, "reinterpreting as content-type:%s, encoding:%s\n",
		new_content, new_encoding));

	StrAllocCopy(me->anchor->content_encoding, new_encoding);
	FREE(me->compression_encoding);
	StrAllocCopy(me->compression_encoding, new_encoding);

	LYStrNCpy(me->value, new_content, VALUE_SIZE - 1);
	StrAllocCopy(me->anchor->content_type_params, me->value);
	me->format = HTAtom_for(me->value);
    }

    if (StrChr(HTAtom_name(me->format), ';') != NULL) {
	char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

	CTRACE((tfp, "HTMIME: Extended MIME Content-Type is %s\n",
		HTAtom_name(me->format)));
	StrAllocCopy(cp, HTAtom_name(me->format));
	/*
	 * Note that the Content-Type value was converted
	 * to lower case when we loaded into me->format,
	 * but there may have been a mixed or upper-case
	 * atom, so we'll force lower-casing again.  We
	 * also stripped spaces and double-quotes, but
	 * we'll make sure they're still gone from any
	 * charset parameter we check.  - FM
	 */
	LYLowerCase(cp);
	if ((cp1 = StrChr(cp, ';')) != NULL) {
	    BOOL chartrans_ok = NO;

	    if ((cp2 = strstr(cp1, "charset")) != NULL) {
		int chndl;

		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
		    cp2++;
		StrAllocCopy(cp3, cp2);		/* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
				 *cp4 != ';' && *cp4 != ':' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
		*cp4 = '\0';
		cp4 = cp3;
		chndl = UCGetLYhndl_byMIME(cp3);
		if (UCCanTranslateFromTo(chndl,
					 current_char_set)) {
		    chartrans_ok = YES;
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		} else if (chndl < 0) {		/* got something but we don't
						   recognize it */
		    chndl = UCLYhndl_for_unrec;
		    if (chndl < 0)
			/*
			 * UCLYhndl_for_unrec not defined :-( fallback to
			 * UCLYhndl_for_unspec which always valid.
			 */
			chndl = UCLYhndl_for_unspec;	/* always >= 0 */
		    if (UCCanTranslateFromTo(chndl,
					     current_char_set)) {
			chartrans_ok = YES;
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
			HTAnchor_setUCInfoStage(me->anchor, chndl,
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		} else {
		    /*
		     * Something like 'big5' - we cannot translate it, but
		     * the user may still be able to navigate the links.
		     */
		    *cp1 = '\0';
		    me->format = HTAtom_for(cp);
		    StrAllocCopy(me->anchor->charset, cp4);
		    HTAnchor_setUCInfoStage(me->anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_MIME);
		}
		if (chartrans_ok) {
		    LYUCcharset *p_in =
		    HTAnchor_getUCInfoStage(me->anchor,
					    UCT_STAGE_MIME);
		    LYUCcharset *p_out =
		    HTAnchor_setUCInfoStage(me->anchor,
					    current_char_set,
					    UCT_STAGE_HTEXT,
					    UCT_SETBY_DEFAULT);

		    if (!p_out)
			/*
			 * Try again.
			 */
			p_out =
			    HTAnchor_getUCInfoStage(me->anchor,
						    UCT_STAGE_HTEXT);

		    if (!strcmp(p_in->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_HTEXT),
						UCT_STAGE_MIME,
						UCT_SETBY_DEFAULT);
		    }
		    if (!strcmp(p_out->MIMEname,
				"x-transparent")) {
			HTPassEightBitRaw = TRUE;
			HTAnchor_setUCInfoStage(me->anchor,
						HTAnchor_getUCLYhndl(me->anchor,
								     UCT_STAGE_MIME),
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		    }
		    if ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
			&& ((p_in->enc != UCT_ENC_UTF8)
			    || (p_out->enc != UCT_ENC_CJK))
#endif
			) {
			HTCJK = NOCJK;
			if (!(p_in->codepoints &
			      UCT_CP_SUBSETOF_LAT1) &&
			    chndl == current_char_set) {
			    HTPassEightBitRaw = TRUE;
			}
		    } else if (p_out->enc == UCT_ENC_CJK) {
			Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		    }
		} else {
		    /*
		     * Cannot translate.  If according to some heuristic the
		     * given charset and the current display character both are
		     * likely to be like ISO-8859 in structure, pretend we have
		     * some kind of match.
		     */
		    BOOL given_is_8859 =
		    (BOOL) (!StrNCmp(cp4, "iso-8859-", 9) &&
			    isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like =
		    (BOOL) (given_is_8859 ||
			    !StrNCmp(cp4, "windows-", 8) ||
			    !StrNCmp(cp4, "cp12", 4) ||
			    !StrNCmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like =
		    (BOOL) (given_is_8859like &&
			    (strstr(LYchar_set_names[current_char_set],
				    "ISO-8859") ||
			     strstr(LYchar_set_names[current_char_set],
				    "windows-")));

		    if (given_and_display_8859like) {
			*cp1 = '\0';
			me->format = HTAtom_for(cp);
		    }
		    if (given_is_8859) {
			cp1 = &cp4[10];
			while (*cp1 &&
			       isdigit(UCH(*cp1)))
			    cp1++;
			*cp1 = '\0';
		    }
		    if (given_and_display_8859like) {
			StrAllocCopy(me->anchor->charset, cp4);
			HTPassEightBitRaw = TRUE;
		    }
		    HTAlert(*cp4 ? cp4 : me->anchor->charset);
		}
		FREE(cp3);
	    } else {
		/*
		 * No charset parameter is present.  Ignore all other
		 * parameters, as we do when charset is present.  - FM
		 */
		*cp1 = '\0';
		me->format = HTAtom_for(cp);
	    }
	}
	FREE(cp);
    }
    /*
     * If we have an Expires header and haven't already set the no_cache
     * element for the anchor, check if we should set it based on that header. 
     * - FM
     */
    if (me->anchor->no_cache == FALSE &&
	me->anchor->expires != NULL) {
	if (!strcmp(me->anchor->expires, "0")) {
	    /*
	     * The value is zero, which we treat as an absolute no-cache
	     * directive.  - FM
	     */
	    me->anchor->no_cache = TRUE;
	} else if (me->anchor->date != NULL) {
	    /*
	     * We have a Date header, so check if the value is less than or
	     * equal to that.  - FM
	     */
	    if (LYmktime(me->anchor->expires, TRUE) <=
		LYmktime(me->anchor->date, TRUE)) {
		me->anchor->no_cache = TRUE;
	    }
	} else if (LYmktime(me->anchor->expires, FALSE) == 0) {
	    /*
	     * We don't have a Date header, and the value is in past for us.  -
	     * FM
	     */
	    me->anchor->no_cache = TRUE;
	}
    }
    StrAllocCopy(me->anchor->content_type,
		 HTAtom_name(me->format));

    if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
	LYSetCookie(me->set_cookie,
		    me->set_cookie2,
		    me->anchor->address);
	FREE(me->set_cookie);
	FREE(me->set_cookie2);
    }
    if (me->pickup_redirection) {
	if (me->location && *me->location) {
	    redirecting_url = me->location;
	    me->location = NULL;
	    if (me->targetRep != WWW_DEBUG || me->sink)
		me->head_only = YES;

	} else {
	    permanent_redirection = FALSE;
	    if (me->location) {
		CTRACE((tfp, "HTTP: 'Location:' is zero-length!\n"));
		HTAlert(REDIRECTION_WITH_BAD_LOCATION);
	    }
	    CTRACE((tfp, "HTTP: Failed to pick up location.\n"));
	    if (me->location) {
		FREE(me->location);
	    } else {
		HTAlert(REDIRECTION_WITH_NO_LOCATION);
	    }
	}
    }
    CTRACE((tfp, "...pumpData finished reading header\n"));
    if (me->head_only) {
	/* We are done! - kw */
	me->state = MIME_IGNORE;
    } else {

	if (me->no_streamstack) {
	    me->target = me->sink;
	} else {
	    if (!me->compression_encoding) {
		CTRACE((tfp,
			"HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
			HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	    } else {
		/*
		 * Change the format to that for "www/compressed" and set up a
		 * stream to deal with it.  - FM
		 */
		CTRACE((tfp, "HTMIME: MIME Content-Type is '%s',\n",
			HTAtom_name(me->format)));
		me->format = HTAtom_for("www/compressed");
		CTRACE((tfp, "        Treating as '%s'.  Converting to '%s'\n",
			HTAtom_name(me->format), HTAtom_name(me->targetRep)));
		FREE(me->compression_encoding);
	    }
	    me->target = HTStreamStack(me->format, me->targetRep,
				       me->sink, me->anchor);
	    if (!me->target) {
		CTRACE((tfp, "HTMIME: Can't translate! ** \n"));
		me->target = me->sink;	/* Cheat */
	    }
	}
	if (me->target) {
	    me->targetClass = *me->target->isa;
	    /*
	     * Pump rest of data right through, according to the transfer encoding.
	     */
	    me->state = (me->chunked_encoding
			 ? MIME_CHUNKED
			 : MIME_TRANSPARENT);
	} else {
	    me->state = MIME_IGNORE;	/* What else to do? */
	}
	if (me->refresh_url != NULL && !content_is_compressed(me)) {
	    char *url = NULL;
	    char *num = NULL;
	    char *txt = NULL;
	    const char *base = "";	/* FIXME: refresh_url may be relative to doc */

	    LYParseRefreshURL(me->refresh_url, &num, &url);
	    if (url != NULL && me->format == WWW_HTML) {
		CTRACE((tfp,
			"Formatting refresh-url as first line of result\n"));
		HTSprintf0(&txt, gettext("Refresh: "));
		HTSprintf(&txt, gettext("%s seconds "), num);
		dequote(url);
		HTSprintf(&txt, "<a href=\"%s%s\">%s</a><br>", base, url, url);
		CTRACE((tfp, "URL %s%s\n", base, url));
		(me->isa->put_string) (me, txt);
		free(txt);
	    }
	    FREE(num);
	    FREE(url);
	}
    }
    CTRACE((tfp, "...end of pumpData, copied %"
	    PRI_off_t " vs %"
	    PRI_off_t "\n",
	    me->anchor->actual_length,
	    me->anchor->content_length));
    me->anchor->actual_length = 0;
    return HT_OK;
}

static int dispatchField(HTStream *me)
{
    int i, j;
    char *cp;

    *me->value_pointer = '\0';

    cp = me->value_pointer;
    while ((cp > me->value) && *(--cp) == ' ')	/* S/390 -- gil -- 0146 */
	/*
	 * Trim trailing spaces.
	 */
	*cp = '\0';

    switch (me->field) {
    case miACCEPT_RANGES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
		me->value));
	break;
    case miAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Age: '%s'\n",
		me->value));
	break;
    case miALLOW:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Allow: '%s'\n",
		me->value));
	break;
    case miALTERNATES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
		me->value));
	break;
    case miCACHE_CONTROL:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->cache_control, me->value);
	/*
	 * Check whether to set no_cache for the anchor.  - FM
	 */
	{
	    char *cp1, *cp0 = me->value;

	    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
		cp1 += 8;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '\0' || *cp1 == ';') {
		    me->anchor->no_cache = TRUE;
		    break;
		}
		cp0 = cp1;
	    }
	    if (me->anchor->no_cache == TRUE)
		break;
	    cp0 = me->value;
	    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
		cp1 += 7;
		while (*cp1 != '\0' && WHITE(*cp1))
		    cp1++;
		if (*cp1 == '=') {
		    cp1++;
		    while (*cp1 != '\0' && WHITE(*cp1))
			cp1++;
		    if (isdigit(UCH(*cp1))) {
			cp0 = cp1;
			while (isdigit(UCH(*cp1)))
			    cp1++;
			if (*cp0 == '0' && cp1 == (cp0 + 1)) {
			    me->anchor->no_cache = TRUE;
			    break;
			}
		    }
		}
		cp0 = cp1;
	    }
	}
	break;
    case miCOOKIE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
		me->value));
	break;
    case miCONNECTION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Connection: '%s'\n",
		me->value));
	break;
    case miCONTENT_BASE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_base, me->value);
	break;
    case miCONTENT_DISPOSITION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_disposition, me->value);
	/*
	 * It's not clear yet from existing RFCs and IDs whether we should be
	 * looking for file;, attachment;, and/or inline; before the
	 * filename=value, so we'll just search for "filename" followed by '='
	 * and just hope we get the intended value.  It is purely a suggested
	 * name, anyway.  - FM
	 */
	cp = me->anchor->content_disposition;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp == '\0')
	    break;
	cp += 8;
	while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
	    cp++;
	if (*cp == '\0')
	    break;
	while (*cp != '\0' && WHITE(*cp))
	    cp++;
	if (*cp == '\0')
	    break;
	StrAllocCopy(me->anchor->SugFname, cp);
	if (*me->anchor->SugFname == '"') {
	    if ((cp = StrChr((me->anchor->SugFname + 1),
			     '"')) != NULL) {
		*(cp + 1) = '\0';
		HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
	    } else {
		FREE(me->anchor->SugFname);
		break;
	    }
	}
	cp = me->anchor->SugFname;
	while (*cp != '\0' && !WHITE(*cp))
	    cp++;
	*cp = '\0';
	if (*me->anchor->SugFname == '\0')
	    FREE(me->anchor->SugFname);
	break;
    case miCONTENT_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
		me->value));
	if (me->value[0] == '\0' ||
	    !strcasecomp(me->value, "identity"))
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_encoding, me->value);
	FREE(me->compression_encoding);
	if (content_is_compressed(me)) {
	    /*
	     * Save it to use as a flag for setting up a "www/compressed"
	     * target.  - FM
	     */
	    StrAllocCopy(me->compression_encoding, me->value);
	} else {
	    /*
	     * Some server indicated "8bit", "7bit" or "binary"
	     * inappropriately.  We'll ignore it.  - FM
	     */
	    CTRACE((tfp, "                Ignoring it!\n"));
	}
	break;
    case miCONTENT_FEATURES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
		me->value));
	break;
    case miCONTENT_LANGUAGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Convert to lowercase and indicate in anchor.  - FM
	 */
	LYLowerCase(me->value);
	StrAllocCopy(me->anchor->content_language, me->value);
	break;
    case miCONTENT_LENGTH:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Convert to integer and indicate in anchor.  - FM
	 */
	me->anchor->content_length = LYatoll(me->value);
	if (me->anchor->content_length < 0)
	    me->anchor->content_length = 0;
	CTRACE((tfp, "        Converted to integer: '%" PRI_off_t "'\n",
		me->anchor->content_length));
	break;
    case miCONTENT_LOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_location, me->value);
	break;
    case miCONTENT_MD5:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->content_md5, me->value);
	break;
    case miCONTENT_RANGE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
		me->value));
	break;
    case miCONTENT_TRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Force the Content-Transfer-Encoding value to all lower case.  - FM
	 */
	LYLowerCase(me->value);
	me->c_t_encoding = HTAtom_for(me->value);
	break;
    case miCONTENT_TYPE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Force the Content-Type value to all lower case and strip spaces and
	 * double-quotes.  - FM
	 */
	for (i = 0, j = 0; me->value[i]; i++) {
	    if (me->value[i] != ' ' && me->value[i] != '"') {
		me->value[j++] = (char) TOLOWER(me->value[i]);
	    }
	}
	me->value[j] = '\0';
	me->format = HTAtom_for(me->value);
	StrAllocCopy(me->anchor->content_type_params, me->value);
	break;
    case miDATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Date: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->date, me->value);
	break;
    case miETAG:
	/* Do not trim double quotes:  an entity tag consists of an opaque
	 * quoted string, possibly prefixed by a weakness indicator.
	 */
	CTRACE((tfp, "HTMIME: PICKED UP ETag: %s\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->ETag, me->value);
	break;
    case miEXPIRES:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Expires: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->expires, me->value);
	break;
    case miKEEP_ALIVE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
		me->value));
	break;
    case miLAST_MODIFIED:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->last_modified, me->value);
	break;
    case miLINK:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Link: '%s'\n",
		me->value));
	break;
    case miLOCATION:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Location: '%s'\n",
		me->value));
	if (me->pickup_redirection && !me->location) {
	    StrAllocCopy(me->location, me->value);
	} else {
	    CTRACE((tfp, "HTMIME: *** Ignoring Location!\n"));
	}
	break;
    case miPRAGMA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Check whether to set no_cache for the anchor.  - FM
	 */
	if (!strcmp(me->value, "no-cache"))
	    me->anchor->no_cache = TRUE;
	break;
    case miPROXY_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
		me->value));
	break;
    case miPUBLIC:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Public: '%s'\n",
		me->value));
	break;
    case miREFRESH:		/* nonstandard: Netscape */
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Refresh: '%s'\n",
		me->value));
	StrAllocCopy(me->refresh_url, me->value);
	break;
    case miRETRY_AFTER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
		me->value));
	break;
    case miSAFE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Safe: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor if "YES" or "TRUE".  - FM
	 */
	if (!strcasecomp(me->value, "YES") ||
	    !strcasecomp(me->value, "TRUE")) {
	    me->anchor->safe = TRUE;
	} else if (!strcasecomp(me->value, "NO") ||
		   !strcasecomp(me->value, "FALSE")) {
	    /*
	     * If server explicitly tells us that it has changed its mind,
	     * reset flag in anchor.  - kw
	     */
	    me->anchor->safe = FALSE;
	}
	break;
    case miSERVER:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Server: '%s'\n",
		me->value));
	if (me->value[0] == '\0')
	    break;
	/*
	 * Indicate in anchor.  - FM
	 */
	StrAllocCopy(me->anchor->server, me->value);
	break;
    case miSET_COOKIE1:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
		me->value));
	if (me->set_cookie == NULL) {
	    StrAllocCopy(me->set_cookie, me->value);
	} else {
	    StrAllocCat(me->set_cookie, ", ");
	    StrAllocCat(me->set_cookie, me->value);
	}
	break;
    case miSET_COOKIE2:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
		me->value));
	if (me->set_cookie2 == NULL) {
	    StrAllocCopy(me->set_cookie2, me->value);
	} else {
	    StrAllocCat(me->set_cookie2, ", ");
	    StrAllocCat(me->set_cookie2, me->value);
	}
	break;
    case miTITLE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Title: '%s'\n",
		me->value));
	break;
    case miTRANSFER_ENCODING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
		me->value));
	if (!strcmp(me->value, "chunked"))
	    me->chunked_encoding = YES;
	break;
    case miUPGRADE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
		me->value));
	break;
    case miURI:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP URI: '%s'\n",
		me->value));
	break;
    case miVARY:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Vary: '%s'\n",
		me->value));
	break;
    case miVIA:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Via: '%s'\n",
		me->value));
	break;
    case miWARNING:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP Warning: '%s'\n",
		me->value));
	break;
    case miWWW_AUTHENTICATE:
	HTMIME_TrimDoubleQuotes(me->value);
	CTRACE((tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
		me->value));
	break;
    default:			/* Should never get here */
	return HT_ERROR;
    }
    return HT_OK;
}

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */

/*	Character handling
 *	------------------
 *
 *	This is a FSM parser. It ignores field names it does not understand.
 *	Folded header fields are recognized.  Lines without a fieldname at
 *	the beginning (that are not folded continuation lines) are ignored
 *	as unknown field names.  Fields with empty values are not picked up.
 */
static void HTMIME_put_character(HTStream *me, int c)
{
    /* MUST BE FAST */
    switch (me->state) {
      begin_transparent:
    case MIME_TRANSPARENT:
	me->anchor->actual_length += 1;
	if (me->anchor->content_length == 0 ||
	    (me->anchor->content_length >= me->anchor->actual_length)) {
	    (me->targetClass.put_character) (me->target, c);
	} else {
	    (me->targetClass.put_character) (me->target, c);
	}
	return;

	/* RFC-2616 describes chunked transfer coding */
    case mcCHUNKED_DATA:
	(*me->targetClass.put_character) (me->target, c);
	me->chunked_size--;
	if (me->chunked_size <= 0)
	    me->state = mcCHUNKED_DATA_CR;
	return;

    case mcCHUNKED_DATA_CR:
	me->state = mcCHUNKED_DATA_LF;
	if (c == CR) {
	    return;
	}
	/* FALLTHRU */

    case mcCHUNKED_DATA_LF:
	me->state = MIME_CHUNKED;
	if (c == LF) {
	    return;
	}

	CTRACE((tfp, "HTIME_put_character expected LF in chunked data\n"));
	me->state = MIME_TRANSPARENT;
	goto begin_transparent;

	/* FALLTHRU */
      begin_chunked:
    case MIME_CHUNKED:
	me->chunked_size = 0;
	me->state = mcCHUNKED_COUNT_DIGIT;

	/* FALLTHRU */
    case mcCHUNKED_COUNT_DIGIT:
	if (isxdigit(UCH(c))) {
	    me->chunked_size <<= 4;
	    if (isdigit(UCH(c)))
		me->chunked_size += UCH(c) - '0';
	    else
		me->chunked_size += TOUPPER(UCH(c)) - 'A' + 10;
	    return;
	}
	if (c == ';')
	    me->state = mcCHUNKED_EXTENSION;

	/* FALLTHRU */
    case mcCHUNKED_EXTENSION:
	if (c != CR && c != LF) {
	    return;
	}
	me->state = mcCHUNKED_COUNT_CR;

	/* FALLTHRU */
    case mcCHUNKED_COUNT_CR:
	me->state = mcCHUNKED_COUNT_LF;
	if (c == CR) {
	    return;
	}

	/* FALLTHRU */
    case mcCHUNKED_COUNT_LF:
	me->state = ((me->chunked_size != 0)
		     ? mcCHUNKED_DATA
		     : MIME_CHUNKED);
	if (c == LF) {
	    return;
	}
	goto begin_chunked;

    default:
	break;
    }

    /*
     * This slightly simple conversion just strips CR and turns LF to newline. 
     * On unix LF is \n but on Mac \n is CR for example.  See NetToText for an
     * implementation which preserves single CR or LF.
     */
    if (me->net_ascii) {
	/*
	 * <sigh> This is evidence that at one time, this code supported
	 * local character sets other than ASCII.  But there is so much
	 * code in HTTP.c that depends on line_buffer's having been
	 * translated to local character set that I needed to put the
	 * FROMASCII translation there, leaving this translation purely
	 * destructive.  -- gil
	 */
	/* S/390 -- gil -- 0118 */
#ifndef   NOT_ASCII
	c = FROMASCII(c);
#endif /* NOT_ASCII */
	if (c == CR)
	    return;
	else if (c == LF)
	    c = '\n';
    }

    switch (me->state) {

    case MIME_IGNORE:
	return;

    case MIME_TRANSPARENT:	/* Not reached see above */
    case MIME_CHUNKED:
    case mcCHUNKED_COUNT_DIGIT:
    case mcCHUNKED_COUNT_CR:
    case mcCHUNKED_COUNT_LF:
    case mcCHUNKED_EXTENSION:
    case mcCHUNKED_DATA:
    case mcCHUNKED_DATA_CR:
    case mcCHUNKED_DATA_LF:
	return;

    case MIME_NET_ASCII:
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
	return;

    case miNEWLINE:
	if (c != '\n' && WHITE(c)) {	/* Folded line */
	    me->state = me->fold_state;		/* pop state before newline */
	    if (me->state == miGET_VALUE &&
		me->value_pointer && me->value_pointer != me->value &&
		!WHITE(*(me->value_pointer - 1))) {
		c = ' ';
		goto GET_VALUE;	/* will add space to value if it fits - kw */
	    }
	    break;
	} else if (me->fold_state == miGET_VALUE) {
	    /* Got a field, and now we know it's complete - so
	     * act on it. - kw */
	    dispatchField(me);
	}
	/* FALLTHRU */

    case miBEGINNING_OF_LINE:
	me->net_ascii = YES;
	switch (c) {
	case 'a':
	case 'A':
	    me->state = miA;
	    CTRACE((tfp, "HTMIME: Got 'A' at beginning of line, state now A\n"));
	    break;

	case 'c':
	case 'C':
	    me->state = miC;
	    CTRACE((tfp, "HTMIME: Got 'C' at beginning of line, state now C\n"));
	    break;

	case 'd':
	case 'D':
	    me->check_pointer = "ate:";
	    me->if_ok = miDATE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->state = miE;
	    CTRACE((tfp, "HTMIME: Got 'E' at beginning of line, state now E\n"));
	    break;

	case 'k':
	case 'K':
	    me->check_pointer = "eep-alive:";
	    me->if_ok = miKEEP_ALIVE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
	    break;

	case 'l':
	case 'L':
	    me->state = miL;
	    CTRACE((tfp, "HTMIME: Got 'L' at beginning of line, state now L\n"));
	    break;

	case 'p':
	case 'P':
	    me->state = miP;
	    CTRACE((tfp, "HTMIME: Got 'P' at beginning of line, state now P\n"));
	    break;

	case 'r':
	case 'R':
	    me->state = miR;
	    CTRACE((tfp, "HTMIME: Got 'R' at beginning of line, state now R\n"));
	    break;

	case 's':
	case 'S':
	    me->state = miS;
	    CTRACE((tfp, "HTMIME: Got 'S' at beginning of line, state now S\n"));
	    break;

	case 't':
	case 'T':
	    me->state = miT;
	    CTRACE((tfp, "HTMIME: Got 'T' at beginning of line, state now T\n"));
	    break;

	case 'u':
	case 'U':
	    me->state = miU;
	    CTRACE((tfp, "HTMIME: Got 'U' at beginning of line, state now U\n"));
	    break;

	case 'v':
	case 'V':
	    me->state = miV;
	    CTRACE((tfp, "HTMIME: Got 'V' at beginning of line, state now V\n"));
	    break;

	case 'w':
	case 'W':
	    me->state = miW;
	    CTRACE((tfp, "HTMIME: Got 'W' at beginning of line, state now W\n"));
	    break;

	case '\n':		/* Blank line: End of Header! */
	    {
		me->net_ascii = NO;
		pumpData(me);
	    }
	    break;

	default:
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miA:			/* Check for 'c','g' or 'l' */
	switch (c) {
	case 'c':
	case 'C':
	    me->check_pointer = "cept-ranges:";
	    me->if_ok = miACCEPT_RANGES;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
	    break;

	case 'g':
	case 'G':
	    me->check_pointer = "e:";
	    me->if_ok = miAGE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was A, found G, checking for 'e:'\n"));
	    break;

	case 'l':
	case 'L':
	    me->state = miAL;
	    CTRACE((tfp, "HTMIME: Was A, found L, state now AL'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'g' or 'l'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miAL:			/* Check for 'l' or 't' */
	switch (c) {
	case 'l':
	case 'L':
	    me->check_pointer = "ow:";
	    me->if_ok = miALLOW;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n"));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ernates:";
	    me->if_ok = miALTERNATES;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'l' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miC:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "che-control:";
	    me->if_ok = miCACHE_CONTROL;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was C, found A, checking for 'che-control:'\n"));
	    break;

	case 'o':
	case 'O':
	    me->state = miCO;
	    CTRACE((tfp, "HTMIME: Was C, found O, state now CO'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCO:			/* Check for 'n' or 'o' */
	switch (c) {
	case 'n':
	case 'N':
	    me->state = miCON;
	    CTRACE((tfp, "HTMIME: Was CO, found N, state now CON\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "kie:";
	    me->if_ok = miCOOKIE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCON:		/* Check for 'n' or 't' */
	switch (c) {
	case 'n':
	case 'N':
	    me->check_pointer = "ection:";
	    me->if_ok = miCONNECTION;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n"));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ent-";
	    me->if_ok = miCONTENT_;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'n' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miE:			/* Check for 't' or 'x' */
	switch (c) {
	case 't':
	case 'T':
	    me->check_pointer = "ag:";
	    me->if_ok = miETAG;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was E, found T, checking for 'ag:'\n"));
	    break;

	case 'x':
	case 'X':
	    me->check_pointer = "pires:";
	    me->if_ok = miEXPIRES;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was E, found X, checking for 'pires:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'t' or 'x'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miL:			/* Check for 'a', 'i' or 'o' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "st-modified:";
	    me->if_ok = miLAST_MODIFIED;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
	    break;

	case 'i':
	case 'I':
	    me->check_pointer = "nk:";
	    me->if_ok = miLINK;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was L, found I, checking for 'nk:'\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "cation:";
	    me->if_ok = miLOCATION;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was L, found O, checking for 'cation:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a', 'i' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miP:			/* Check for 'r' or 'u' */
	switch (c) {
	case 'r':
	case 'R':
	    me->state = miPR;
	    CTRACE((tfp, "HTMIME: Was P, found R, state now PR'\n"));
	    break;

	case 'u':
	case 'U':
	    me->check_pointer = "blic:";
	    me->if_ok = miPUBLIC;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was P, found U, checking for 'blic:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 'u'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miPR:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "gma:";
	    me->if_ok = miPRAGMA;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was PR, found A, checking for 'gma'\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "xy-authenticate:";
	    me->if_ok = miPROXY_AUTHENTICATE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'o'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miR:			/* Check for 'e' */
	switch (c) {
	case 'e':
	case 'E':
	    me->state = miRE;
	    CTRACE((tfp, "HTMIME: Was R, found E\n"));
	    break;
	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'e'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miRE:			/* Check for 'a' or 'o' */
	switch (c) {
	case 'f':
	case 'F':		/* nonstandard: Netscape */
	    me->check_pointer = "resh:";
	    me->if_ok = miREFRESH;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found F, checking for '%s'\n", me->check_pointer));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "ry-after:";
	    me->if_ok = miRETRY_AFTER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was RE, found T, checking for '%s'\n", me->check_pointer));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'f' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miS:			/* Check for 'a' or 'e' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "fe:";
	    me->if_ok = miSAFE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was S, found A, checking for 'fe:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->state = miSE;
	    CTRACE((tfp, "HTMIME: Was S, found E, state now SE'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'e'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miSE:			/* Check for 'r' or 't' */
	switch (c) {
	case 'r':
	case 'R':
	    me->check_pointer = "ver:";
	    me->if_ok = miSERVER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was SE, found R, checking for 'ver'\n"));
	    break;

	case 't':
	case 'T':
	    me->check_pointer = "-cookie";
	    me->if_ok = miSET_COOKIE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'r' or 't'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miSET_COOKIE:		/* Check for ':' or '2' */
	switch (c) {
	case ':':
	    me->field = miSET_COOKIE1;	/* remember it */
	    me->state = miSKIP_GET_VALUE;
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found :, processing\n"));
	    break;

	case '2':
	    me->check_pointer = ":";
	    me->if_ok = miSET_COOKIE2;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "':' or '2'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miT:			/* Check for 'i' or 'r' */
	switch (c) {
	case 'i':
	case 'I':
	    me->check_pointer = "tle:";
	    me->if_ok = miTITLE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was T, found I, checking for 'tle:'\n"));
	    break;

	case 'r':
	case 'R':
	    me->check_pointer = "ansfer-encoding:";
	    me->if_ok = miTRANSFER_ENCODING;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'i' or 'r'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miU:			/* Check for 'p' or 'r' */
	switch (c) {
	case 'p':
	case 'P':
	    me->check_pointer = "grade:";
	    me->if_ok = miUPGRADE;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was U, found P, checking for 'grade:'\n"));
	    break;

	case 'r':
	case 'R':
	    me->check_pointer = "i:";
	    me->if_ok = miURI;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was U, found R, checking for 'i:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'p' or 'r'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miV:			/* Check for 'a' or 'i' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "ry:";
	    me->if_ok = miVARY;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was V, found A, checking for 'ry:'\n"));
	    break;

	case 'i':
	case 'I':
	    me->check_pointer = "a:";
	    me->if_ok = miVIA;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was V, found I, checking for 'a:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'i'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miW:			/* Check for 'a' or 'w' */
	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "rning:";
	    me->if_ok = miWARNING;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was W, found A, checking for 'rning:'\n"));
	    break;

	case 'w':
	case 'W':
	    me->check_pointer = "w-authenticate:";
	    me->if_ok = miWWW_AUTHENTICATE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
	    break;

	default:
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, "'a' or 'w'"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCHECK:		/* Check against string */
	if (TOLOWER(c) == *(me->check_pointer)++) {
	    if (!*me->check_pointer)
		me->state = me->if_ok;
	} else {		/* Error */
	    CTRACE((tfp,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		    c, me->check_pointer - 1));
	    goto bad_field_name;
	}
	break;

    case miCONTENT_:
	CTRACE((tfp, "HTMIME: in case CONTENT_\n"));

	switch (c) {
	case 'b':
	case 'B':
	    me->check_pointer = "ase:";
	    me->if_ok = miCONTENT_BASE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
	    break;

	case 'd':
	case 'D':
	    me->check_pointer = "isposition:";
	    me->if_ok = miCONTENT_DISPOSITION;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->check_pointer = "ncoding:";
	    me->if_ok = miCONTENT_ENCODING;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
	    break;

	case 'f':
	case 'F':
	    me->check_pointer = "eatures:";
	    me->if_ok = miCONTENT_FEATURES;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
	    break;

	case 'l':
	case 'L':
	    me->state = miCONTENT_L;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
	    break;

	case 'm':
	case 'M':
	    me->check_pointer = "d5:";
	    me->if_ok = miCONTENT_MD5;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n"));
	    break;

	case 'r':
	case 'R':
	    me->check_pointer = "ange:";
	    me->if_ok = miCONTENT_RANGE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
	    break;

	case 't':
	case 'T':
	    me->state = miCONTENT_T;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCONTENT_L:
	CTRACE((tfp, "HTMIME: in case CONTENT_L\n"));

	switch (c) {
	case 'a':
	case 'A':
	    me->check_pointer = "nguage:";
	    me->if_ok = miCONTENT_LANGUAGE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
	    break;

	case 'e':
	case 'E':
	    me->check_pointer = "ngth:";
	    me->if_ok = miCONTENT_LENGTH;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
	    break;

	case 'o':
	case 'O':
	    me->check_pointer = "cation:";
	    me->if_ok = miCONTENT_LOCATION;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miCONTENT_T:
	CTRACE((tfp, "HTMIME: in case CONTENT_T\n"));

	switch (c) {
	case 'r':
	case 'R':
	    me->check_pointer = "ansfer-encoding:";
	    me->if_ok = miCONTENT_TRANSFER_ENCODING;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
	    break;

	case 'y':
	case 'Y':
	    me->check_pointer = "pe:";
	    me->if_ok = miCONTENT_TYPE;
	    me->state = miCHECK;
	    CTRACE((tfp,
		    "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
	    break;

	default:
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n"));
	    goto bad_field_name;

	}			/* switch on character */
	break;

    case miACCEPT_RANGES:
    case miAGE:
    case miALLOW:
    case miALTERNATES:
    case miCACHE_CONTROL:
    case miCOOKIE:
    case miCONNECTION:
    case miCONTENT_BASE:
    case miCONTENT_DISPOSITION:
    case miCONTENT_ENCODING:
    case miCONTENT_FEATURES:
    case miCONTENT_LANGUAGE:
    case miCONTENT_LENGTH:
    case miCONTENT_LOCATION:
    case miCONTENT_MD5:
    case miCONTENT_RANGE:
    case miCONTENT_TRANSFER_ENCODING:
    case miCONTENT_TYPE:
    case miDATE:
    case miETAG:
    case miEXPIRES:
    case miKEEP_ALIVE:
    case miLAST_MODIFIED:
    case miLINK:
    case miLOCATION:
    case miPRAGMA:
    case miPROXY_AUTHENTICATE:
    case miPUBLIC:
    case miREFRESH:
    case miRETRY_AFTER:
    case miSAFE:
    case miSERVER:
    case miSET_COOKIE1:
    case miSET_COOKIE2:
    case miTITLE:
    case miTRANSFER_ENCODING:
    case miUPGRADE:
    case miURI:
    case miVARY:
    case miVIA:
    case miWARNING:
    case miWWW_AUTHENTICATE:
	me->field = me->state;	/* remember it */
	me->state = miSKIP_GET_VALUE;
	/* Fall through! */

    case miSKIP_GET_VALUE:
	if (c == '\n') {
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	    break;
	}
	if (WHITE(c))
	    /*
	     * Skip white space.
	     */
	    break;

	me->value_pointer = me->value;
	me->state = miGET_VALUE;
	/* Fall through to store first character */

    case miGET_VALUE:
      GET_VALUE:
	if (c != '\n') {	/* Not end of line */
	    if (me->value_pointer < me->value + VALUE_SIZE - 1) {
		*me->value_pointer++ = (char) c;
		break;
	    } else {
		goto value_too_long;
	    }
	}
	/* Fall through (if end of line) */

    case miJUNK_LINE:
	if (c == '\n') {
	    me->fold_state = me->state;
	    me->state = miNEWLINE;
	}
	break;

    }				/* switch on state */

#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, UCH(c));
    if (me->state == MIME_TRANSPARENT) {
	HTChunkTerminate(&me->anchor->http_headers);
	CTRACE((tfp, "Server Headers:\n%.*s\n",
		me->anchor->http_headers.size,
		me->anchor->http_headers.data));
	CTRACE((tfp, "Server Content-Type:%s\n",
		me->anchor->content_type_params));
    }
#endif
    return;

  value_too_long:
    CTRACE((tfp, "HTMIME: *** Syntax error. (string too long)\n"));

  bad_field_name:		/* Ignore it */
    me->state = miJUNK_LINE;

#ifdef EXP_HTTP_HEADERS
    HTChunkPutc(&me->anchor->http_headers, UCH(c));
#endif

    return;

}

/*	String handling
 *	---------------
 *
 *	Strings must be smaller than this buffer size.
 */
static void HTMIME_put_string(HTStream *me,
			      const char *s)
{
    const char *p;

    if (me->state == MIME_TRANSPARENT) {	/* Optimisation */
	(*me->targetClass.put_string) (me->target, s);

    } else if (me->state != MIME_IGNORE) {
	CTRACE((tfp, "HTMIME:  %s\n", s));

	for (p = s; *p; p++)
	    HTMIME_put_character(me, *p);
    }
}

/*	Buffer write.  Buffers can (and should!) be big.
 *	------------
 */
static void HTMIME_write(HTStream *me,
			 const char *s,
			 int l)
{
    const char *p;

    if (me->state == MIME_TRANSPARENT) {	/* Optimisation */
	(*me->targetClass.put_block) (me->target, s, l);

    } else {
	CTRACE((tfp, "HTMIME:  %.*s\n", l, s));

	for (p = s; p < s + l; p++)
	    HTMIME_put_character(me, *p);
    }
}

/*	Free an HTML object
 *	-------------------
 *
 */
static void HTMIME_free(HTStream *me)
{
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._free) (me->target);
	FREE(me);
    }
}

/*	End writing
*/
static void HTMIME_abort(HTStream *me,
			 HTError e)
{
    if (me) {
	FREE(me->location);
	FREE(me->compression_encoding);
	if (me->target)
	    (*me->targetClass._abort) (me->target, e);
	FREE(me);
    }
}

/*	Structured Object Class
 *	-----------------------
 */
static const HTStreamClass HTMIME =
{
    "MIMEParser",
    HTMIME_free,
    HTMIME_abort,
    HTMIME_put_character,
    HTMIME_put_string,
    HTMIME_write
};

/*	Subclass-specific Methods
 *	-------------------------
 */
HTStream *HTMIMEConvert(HTPresentation *pres,
			HTParentAnchor *anchor,
			HTStream *sink)
{
    HTStream *me;

    me = typecalloc(HTStream);

    if (me == NULL)
	outofmem(__FILE__, "HTMIMEConvert");

    assert(me != NULL);

    me->isa = &HTMIME;
    me->sink = sink;
    me->anchor = anchor;
    me->anchor->safe = FALSE;
    me->anchor->no_cache = FALSE;
    FREE(me->anchor->cache_control);
    FREE(me->anchor->SugFname);
    FREE(me->anchor->charset);
#ifdef EXP_HTTP_HEADERS
    HTChunkClear(&me->anchor->http_headers);
    HTChunkInit(&me->anchor->http_headers, 128);
#endif
    FREE(me->anchor->content_type_params);
    FREE(me->anchor->content_language);
    FREE(me->anchor->content_encoding);
    FREE(me->anchor->content_base);
    FREE(me->anchor->content_disposition);
    FREE(me->anchor->content_location);
    FREE(me->anchor->content_md5);
    me->anchor->content_length = 0;
    FREE(me->anchor->date);
    FREE(me->anchor->expires);
    FREE(me->anchor->last_modified);
    FREE(me->anchor->ETag);
    FREE(me->anchor->server);
    me->target = NULL;
    me->state = miBEGINNING_OF_LINE;
    /*
     * Sadly enough, change this to always default to WWW_HTML to parse all
     * text as HTML for the users.
     * GAB 06-30-94
     * Thanks to Robert Rowland robert@@cyclops.pei.edu
     *
     * After discussion of the correct handline, should be application/octet-
     * stream or unknown; causing servers to send a correct content type.
     *
     * The consequence of using WWW_UNKNOWN is that you end up downloading as a
     * binary file what 99.9% of the time is an HTML file, which should have
     * been rendered or displayed.  So sadly enough, I'm changing it back to
     * WWW_HTML, and it will handle the situation like Mosaic does, and as
     * Robert Rowland suggested, because being functionally correct 99.9% of
     * the time is better than being technically correct but functionally
     * nonsensical.  - FM
     */
    /***
    me->format	  =	WWW_UNKNOWN;
    ***/
    me->format = WWW_HTML;
    me->targetRep = pres->rep_out;
    me->boundary = NULL;	/* Not set yet */
    me->set_cookie = NULL;	/* Not set yet */
    me->set_cookie2 = NULL;	/* Not set yet */
    me->refresh_url = NULL;	/* Not set yet */
    me->c_t_encoding = 0;	/* Not set yet */
    me->compression_encoding = NULL;	/* Not set yet */
    me->net_ascii = NO;		/* Local character set */
    HTAnchor_setUCInfoStage(me->anchor, current_char_set,
			    UCT_STAGE_STRUCTURED,
			    UCT_SETBY_DEFAULT);
    HTAnchor_setUCInfoStage(me->anchor, current_char_set,
			    UCT_STAGE_HTEXT,
			    UCT_SETBY_DEFAULT);
    return me;
}

HTStream *HTNetMIME(HTPresentation *pres,
		    HTParentAnchor *anchor,
		    HTStream *sink)
{
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

    if (!me)
	return NULL;

    me->net_ascii = YES;
    return me;
}

HTStream *HTMIMERedirect(HTPresentation *pres,
			 HTParentAnchor *anchor,
			 HTStream *sink)
{
    HTStream *me = HTMIMEConvert(pres, anchor, sink);

    if (!me)
	return NULL;

    me->pickup_redirection = YES;
    if (me->targetRep == WWW_DEBUG && sink)
	me->no_streamstack = YES;
    return me;
}

/*		Japanese header handling functions
 *		==================================
 *
 *	K&Rized and added 07-Jun-96 by FM, based on:
 *
////////////////////////////////////////////////////////////////////////
 *
 *	ISO-2022-JP handling routines
 *			&
 *	MIME decode routines (quick hack just for ISO-2022-JP)
 *
 *		Thu Jan 25 10:11:42 JST 1996
 *
 *  Copyright (C) 1994, 1995, 1996
 *  Shuichi Ichikawa (ichikawa@@nuee.nagoya-u.ac.jp)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either versions 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with SKK, see the file COPYING.  If not, write to the Free
 *  Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *  MIME decoding routines
 *
 *	Written by S. Ichikawa,
 *	partially inspired by encdec.c of <jh@@efd.lth.se>.
 *	Caller's buffers decode to no longer than the input strings.
 */
#include <LYCharVals.h>		/* S/390 -- gil -- 0163 */

static char HTmm64[] =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static char HTmmquote[] = "0123456789ABCDEF";
static int HTmmcont = 0;

static void HTmmdec_base64(char **t,
			   char *s)
{
    int d, count, j, val;
    char *buf, *bp, nw[4], *p;

    if ((buf = typeMallocn(char, strlen(s) * 3 + 1)) == 0)
	  outofmem(__FILE__, "HTmmdec_base64");

    assert(buf != NULL);

    for (bp = buf; *s; s += 4) {
	val = 0;
	if (s[2] == '=')
	    count = 1;
	else if (s[3] == '=')
	    count = 2;
	else
	    count = 3;

	for (j = 0; j <= count; j++) {
	    if (!(p = StrChr(HTmm64, s[j]))) {
		FREE(buf);
		return;
	    }
	    d = (int) (p - HTmm64);
	    d <<= (3 - j) * 6;
	    val += d;
	}
	for (j = 2; j >= 0; j--) {
	    nw[j] = (char) (val & 255);
	    val >>= 8;
	}
	if (count--)
	    *bp++ = nw[0];
	if (count--)
	    *bp++ = nw[1];
	if (count)
	    *bp++ = nw[2];
    }
    *bp = '\0';
    StrAllocCopy(*t, buf);
    FREE(buf);
}

static void HTmmdec_quote(char **t,
			  char *s)
{
    char *buf, cval, *bp, *p;

    if ((buf = typeMallocn(char, strlen(s) + 1)) == 0)
	  outofmem(__FILE__, "HTmmdec_quote");

    assert(buf != NULL);

    for (bp = buf; *s;) {
	if (*s == '=') {
	    cval = 0;
	    if (s[1] && (p = StrChr(HTmmquote, s[1]))) {
		cval = (char) (cval + (char) (p - HTmmquote));
	    } else {
		*bp++ = *s++;
		continue;
	    }
	    if (s[2] && (p = StrChr(HTmmquote, s[2]))) {
		cval = (char) (cval << 4);
		cval = (char) (cval + (p - HTmmquote));
		*bp++ = cval;
		s += 3;
	    } else {
		*bp++ = *s++;
	    }
	} else if (*s == '_') {
	    *bp++ = 0x20;
	    s++;
	} else {
	    *bp++ = *s++;
	}
    }
    *bp = '\0';
    StrAllocCopy(*t, buf);
    FREE(buf);
}

/*
 *	HTmmdecode for ISO-2022-JP - FM
 */
void HTmmdecode(char **target,
		char *source)
{
    char *buf;
    char *mmbuf = NULL;
    char *m2buf = NULL;
    char *s, *t, *u;
    int base64, quote;

    if ((buf = typeMallocn(char, strlen(source) + 1)) == 0)
	  outofmem(__FILE__, "HTmmdecode");

    assert(buf != NULL);

    for (s = source, u = buf; *s;) {
	if (!strncasecomp(s, "=?ISO-2022-JP?B?", 16)) {
	    base64 = 1;
	} else {
	    base64 = 0;
	}
	if (!strncasecomp(s, "=?ISO-2022-JP?Q?", 16)) {
	    quote = 1;
	} else {
	    quote = 0;
	}
	if (base64 || quote) {
	    if (HTmmcont) {
		for (t = s - 1;
		     t >= source && (*t == ' ' || *t == '\t'); t--) {
		    u--;
		}
	    }
	    if (mmbuf == 0)	/* allocate buffer big enough for source */
		StrAllocCopy(mmbuf, source);
	    for (s += 16, t = mmbuf; *s;) {
		if (s[0] == '?' && s[1] == '=') {
		    break;
		} else {
		    *t++ = *s++;
		    *t = '\0';
		}
	    }
	    if (s[0] != '?' || s[1] != '=') {
		goto end;
	    } else {
		s += 2;
		*t = '\0';
	    }
	    if (base64)
		HTmmdec_base64(&m2buf, mmbuf);
	    else
		HTmmdec_quote(&m2buf, mmbuf);
	    for (t = m2buf; *t;)
		*u++ = *t++;
	    HTmmcont = 1;
	} else {
	    if (*s != ' ' && *s != '\t')
		HTmmcont = 0;
	    *u++ = *s++;
	}
    }
    *u = '\0';
  end:
    StrAllocCopy(*target, buf);
    FREE(m2buf);
    FREE(mmbuf);
    FREE(buf);
}

/*
 *  Insert ESC where it seems lost.
 *  (The author of this function "rjis" is S. Ichikawa.)
 */
int HTrjis(char **t,
	   char *s)
{
    char *p;
    char *buf = NULL;
    int kanji = 0;

    if (StrChr(s, CH_ESC) || !StrChr(s, '$')) {
	if (s != *t)
	    StrAllocCopy(*t, s);
	return 1;
    }

    if ((buf = typeMallocn(char, strlen(s) * 2 + 1)) == 0)
	  outofmem(__FILE__, "HTrjis");

    assert(buf != NULL);

    for (p = buf; *s;) {
	if (!kanji && s[0] == '$' && (s[1] == '@@' || s[1] == 'B')) {
	    if (HTmaybekanji((int) s[2], (int) s[3])) {
		kanji = 1;
		*p++ = CH_ESC;
		*p++ = *s++;
		*p++ = *s++;
		*p++ = *s++;
		*p++ = *s++;
		continue;
	    }
	    *p++ = *s++;
	    continue;
	}
	if (kanji && s[0] == '(' && (s[1] == 'J' || s[1] == 'B')) {
	    kanji = 0;
	    *p++ = CH_ESC;
	    *p++ = *s++;
	    *p++ = *s++;
	    continue;
	}
	*p++ = *s++;
    }
    *p = *s;			/* terminate string */

    StrAllocCopy(*t, buf);
    FREE(buf);
    return 0;
}

/*
 *  The following function "maybekanji" is derived from
 *  RJIS-1.0 by Mr. Hironobu Takahashi.
 *  Maybekanji() is included here under the courtesy of the author.
 *  The original comment of rjis.c is also included here.
 */
/*
 * RJIS ( Recover JIS code from broken file )
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.8 2014/07/09 04:11:34 daniel Exp $
 * Copyright (C) 1992 1994
 * Hironobu Takahashi (takahasi@@tiny.or.jp)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either versions 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SKK, see the file COPYING.  If not, write to the Free
 * Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

int HTmaybekanji(int c1,
		 int c2)
{

    if ((c2 < 33) || (c2 > 126))
	return 0;
    if ((c1 < 33) || ((40 < c1) && (c1 < 48)) || (116 < c1))
	return 0;
    c2 -= 32;
    switch (c1 - 32) {
    case 2:
	if ((14 < c2) && (c2 < 26))
	    return 0;
	if ((33 < c2) && (c2 < 42))
	    return 0;
	if ((48 < c2) && (c2 < 60))
	    return 0;
	if ((74 < c2) && (c2 < 82))
	    return 0;
	if ((89 < c2) && (c2 < 94))
	    return 0;
	break;
    case 3:
	if (c2 < 16)
	    return 0;
	if ((25 < c2) && (c2 < 33))
	    return 0;
	if ((58 < c2) && (c2 < 65))
	    return 0;
	if (90 < c2)
	    return 0;
	break;
    case 4:
	if (83 < c2)
	    return 0;
	break;
    case 5:
	if (86 < c2)
	    return 0;
	break;
    case 6:
	if ((24 < c2) && (c2 < 33))
	    return 0;
	if (56 < c2)
	    return 0;
	break;
    case 7:
	if ((33 < c2) && (c2 < 49))
	    return 0;
	if (81 < c2)
	    return 0;
	break;
    case 8:
	if (32 < c2)
	    return 0;
	break;
    case 47:
	if (51 < c2)
	    return 0;
	break;
    case 84:
	if (6 < c2)
	    return 0;
	break;
    }
    return 1;
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@d2529 1
a2529 1
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.7 2011/07/22 14:10:38 avsm Exp $
@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTMIME.c,v 1.70 2009/04/08 19:55:32 tom Exp $
d17 3
d176 1
a176 1
    int i;
d179 1
a179 1
    if (!(cp && *cp) || *cp != '"')
d210 1
a210 1
    int len;
d276 1
a276 1
	strcpy(me->value, new_content);
d281 1
a281 1
    if (strchr(HTAtom_name(me->format), ';') != NULL) {
d297 1
a297 1
	if ((cp1 = strchr(cp, ';')) != NULL) {
d411 1
a411 1
		    (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
d415 3
a417 3
			    !strncmp(cp4, "windows-", 8) ||
			    !strncmp(cp4, "cp12", 4) ||
			    !strncmp(cp4, "cp-12", 5));
d580 6
a585 1
    CTRACE((tfp, "...end of pumpData\n"));
d628 1
a628 1
	if (!(me->value && *me->value))
d690 1
a690 1
	if (!(me->value && *me->value))
d701 1
a701 1
	if (!(me->value && *me->value))
d730 1
a730 1
	    if ((cp = strchr((me->anchor->SugFname + 1),
d750 1
a750 1
	if (!(me->value && *me->value) ||
d782 1
a782 1
	if (!(me->value && *me->value))
d794 1
a794 1
	if (!(me->value && *me->value))
d799 1
a799 1
	me->anchor->content_length = atoi(me->value);
d802 1
a802 1
	CTRACE((tfp, "        Converted to integer: '%ld'\n",
d809 1
a809 1
	if (!(me->value && *me->value))
d820 1
a820 1
	if (!(me->value && *me->value))
d836 1
a836 1
	if (!(me->value && *me->value))
d848 1
a848 1
	if (!(me->value && *me->value))
d867 1
a867 1
	if (!(me->value && *me->value))
d880 1
a880 1
	if (!(me->value && *me->value))
d891 1
a891 1
	if (!(me->value && *me->value))
d907 1
a907 1
	if (!(me->value && *me->value))
d933 1
a933 1
	if (!(me->value && *me->value))
d966 1
a966 1
	if (!(me->value && *me->value))
d987 1
a987 1
	if (!(me->value && *me->value))
d1077 1
a1077 2
static void HTMIME_put_character(HTStream *me,
				 char c)
d1083 7
a1089 1
	(*me->targetClass.put_character) (me->target, c);
d2032 1
a2032 1
		*me->value_pointer++ = c;
d2050 1
a2050 1
    HTChunkPutc(&me->anchor->http_headers, c);
d2069 1
a2069 1
    HTChunkPutc(&me->anchor->http_headers, c);
d2172 3
d2322 2
d2334 2
a2335 1
	    if (!(p = strchr(HTmm64, s[j]))) {
d2338 1
a2338 1
	    d = p - HTmm64;
d2366 2
d2371 2
a2372 2
	    if (s[1] && (p = strchr(HTmmquote, s[1]))) {
		cval += (char) (p - HTmmquote);
d2377 3
a2379 3
	    if (s[2] && (p = strchr(HTmmquote, s[2]))) {
		cval <<= 4;
		cval += (char) (p - HTmmquote);
d2412 2
d2450 1
a2450 1
	    if (quote)
d2480 1
a2480 1
    if (strchr(s, CH_ESC) || !strchr(s, '$')) {
d2489 2
d2529 1
a2529 1
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.6 2009/05/31 09:16:51 avsm Exp $
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			MIME Message Parse			HTMIME.c
d40 10
d151 1
a151 1
    HTFormat encoding;		/* Content-Transfer-Encoding */
d153 4
d196 1
a196 1
    BOOL result = (HTEncodingToCompressType(encoding) != cftNone);
d218 27
d247 31
d512 1
d516 1
a516 2
	return HT_OK;
    }
d518 2
a519 7
    if (me->no_streamstack) {
	me->target = me->sink;
    } else {
	if (!me->compression_encoding) {
	    CTRACE((tfp,
		    "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
d521 25
d547 1
a547 2
	     * Change the format to that for "www/compressed" and set up a
	     * stream to deal with it.  - FM
d549 5
a553 11
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format)));
	    me->format = HTAtom_for("www/compressed");
	    CTRACE((tfp, "        Treating as '%s'.  Converting to '%s'\n",
		    HTAtom_name(me->format), HTAtom_name(me->targetRep)));
	    FREE(me->compression_encoding);
	}
	me->target = HTStreamStack(me->format, me->targetRep,
				   me->sink, me->anchor);
	if (!me->target) {
	    CTRACE((tfp, "HTMIME: Can't translate! ** \n"));
	    me->target = me->sink;	/* Cheat */
d555 20
a574 27
    }
    if (me->target) {
	me->targetClass = *me->target->isa;
	/*
	 * Check for encoding and select state from there, someday, but until
	 * we have the relevant code, from now push straight through.  - FM
	 */
	me->state = MIME_TRANSPARENT;	/* Pump rest of data right through */
    } else {
	me->state = MIME_IGNORE;	/* What else to do? */
    }
    if (me->refresh_url != NULL && !content_is_compressed(me)) {
	char *url = NULL;
	char *num = NULL;
	char *txt = NULL;
	const char *base = "";	/* FIXME: refresh_url may be relative to doc */

	LYParseRefreshURL(me->refresh_url, &num, &url);
	if (url != NULL && me->format == WWW_HTML) {
	    CTRACE((tfp, "Formatting refresh-url as first line of result\n"));
	    HTSprintf0(&txt, gettext("Refresh: "));
	    HTSprintf(&txt, gettext("%s seconds "), num);
	    dequote(url);
	    HTSprintf(&txt, "<a href=\"%s%s\">%s</a><br>", base, url, url);
	    CTRACE((tfp, "URL %s%s\n", base, url));
	    (me->isa->put_string) (me, txt);
	    free(txt);
a575 2
	FREE(num);
	FREE(url);
d577 1
d794 1
a794 1
	CTRACE((tfp, "        Converted to integer: '%d'\n",
d834 1
a834 1
	me->encoding = HTAtom_for(me->value);
d1017 2
d1072 13
a1084 2
    if (me->state == MIME_TRANSPARENT) {
	(*me->targetClass.put_character) (me->target, c);	/* MUST BE FAST */
d1086 63
d1181 8
a1188 1
	(*me->targetClass.put_character) (me->target, c);
d2212 1
a2212 1
    me->encoding = 0;		/* Not set yet */
d2303 2
a2304 2
    if ((buf = malloc(strlen(s) * 3 + 1)) == 0)
	outofmem(__FILE__, "HTmmdec_base64");
d2344 2
a2345 2
    if ((buf = malloc(strlen(s) + 1)) == 0)
	outofmem(__FILE__, "HTmmdec_quote");
d2388 2
a2389 2
    if ((buf = malloc(strlen(source) + 1)) == 0)
	outofmem(__FILE__, "HTmmdecode");
d2463 2
a2464 2
    if ((buf = malloc(strlen(s) * 2 + 1)) == 0)
	outofmem(__FILE__, "HTrjis");
d2504 1
a2504 1
 * $Header: rjis.c,v 0.2 92/09/04 takahasi Exp $
@


1.5
log
@update to lynx2.8.5rel.4; fixes CAN-2005-3120 among other things.
prompted by naddy@@, cloder@@ ok.
@
text
@d2 12
a13 12
**			==================
**
**	This is RFC 1341-specific code.
**	The input stream pushed into this parser is assumed to be
**	stripped on CRs, ie lines end with LF, not CR LF.
**	(It is easy to change this except for the body part where
**	conversion can be slow.)
**
** History:
**	   Feb 92	Written Tim Berners-Lee, CERN
**
*/
d18 1
d32 2
a33 2
**		-----------
*/
d36 73
a108 73
	MIME_TRANSPARENT,	/* put straight through to target ASAP! */
	miBEGINNING_OF_LINE,	/* first character and not a continuation */
	miA,
	miACCEPT_RANGES,
	miAGE,
	miAL,
	miALLOW,
	miALTERNATES,
	miC,
	miCACHE_CONTROL,
	miCO,
	miCOOKIE,
	miCON,
	miCONNECTION,
	miCONTENT_,
	miCONTENT_BASE,
	miCONTENT_DISPOSITION,
	miCONTENT_ENCODING,
	miCONTENT_FEATURES,
	miCONTENT_L,
	miCONTENT_LANGUAGE,
	miCONTENT_LENGTH,
	miCONTENT_LOCATION,
	miCONTENT_MD5,
	miCONTENT_RANGE,
	miCONTENT_T,
	miCONTENT_TRANSFER_ENCODING,
	miCONTENT_TYPE,
	miDATE,
	miE,
	miETAG,
	miEXPIRES,
	miKEEP_ALIVE,
	miL,
	miLAST_MODIFIED,
	miLINK,
	miLOCATION,
	miP,
	miPR,
	miPRAGMA,
	miPROXY_AUTHENTICATE,
	miPUBLIC,
	miR,
	miRE,
	miREFRESH,
	miRETRY_AFTER,
	miS,
	miSAFE,
	miSE,
	miSERVER,
	miSET_COOKIE,
	miSET_COOKIE1,
	miSET_COOKIE2,
	miT,
	miTITLE,
	miTRANSFER_ENCODING,
	miU,
	miUPGRADE,
	miURI,
	miV,
	miVARY,
	miVIA,
	miW,
	miWARNING,
	miWWW_AUTHENTICATE,
	miSKIP_GET_VALUE,	/* Skip space then get value */
	miGET_VALUE,		/* Get value till white space */
	miJUNK_LINE,		/* Ignore the rest of this folded line */
	miNEWLINE,		/* Just found a LF .. maybe continuation */
	miCHECK,		/* check against check_pointer */
	MIME_NET_ASCII,		/* Translate from net ascii */
	MIME_IGNORE		/* Ignore entire file */
	/* TRANSPARENT and IGNORE are defined as stg else in _WINDOWS */
d113 1
a113 1
	CONST HTStreamClass *	isa;
d115 28
a142 28
	BOOL			net_ascii;	/* Is input net ascii? */
	MIME_state		state;		/* current state */
	MIME_state		if_ok;		/* got this state if match */
	MIME_state		field;		/* remember which field */
	MIME_state		fold_state;	/* state on a fold */
	BOOL			head_only;	/* only parsing header */
	BOOL			pickup_redirection; /* parsing for location */
	BOOL			no_streamstack; /* use sink directly */
	CONST char *		check_pointer;	/* checking input */

	char *			value_pointer;	/* storing values */
	char			value[VALUE_SIZE];

	HTParentAnchor *	anchor;		/* Given on creation */
	HTStream *		sink;		/* Given on creation */

	char *			boundary;	/* For multipart */
	char *			set_cookie;	/* Set-Cookie */
	char *			set_cookie2;	/* Set-Cookie2 */
	char *			location;	/* Location */

	char *			refresh_url;	/* "Refresh:" URL */

	HTFormat		encoding;	/* Content-Transfer-Encoding */
	char *			compression_encoding;
	HTFormat		format;		/* Content-Type */
	HTStream *		target;		/* While writing out */
	HTStreamClass		targetClass;
d144 1
a144 1
	HTAtom *		targetRep;	/* Converting into? */
d148 7
a154 8
**  This function is for trimming off any paired
**  open- and close-double quotes from header values.
**  It does not parse the string for embedded quotes,
**  and will not modify the string unless both the
**  first and last characters are double-quotes. - FM
*/
PUBLIC void HTMIME_TrimDoubleQuotes ARGS1(
	char *,		value)
d159 1
a159 1
    if (!(cp && *cp) || *cp != '\"')
d163 1
a163 1
    if (cp[(i - 1)] != '\"')
d169 1
a169 1
	value[i] = cp[(i +1)];
d172 5
a176 1
PRIVATE BOOL content_is_compressed ARGS1(HTStream *, me)
d179 1
d181 2
a182 4
    return encoding != 0
        && strcmp(encoding, "8bit") != 0
	&& strcmp(encoding, "7bit") != 0
	&& strcmp(encoding, "binary") != 0;
d188 1
a188 1
PRIVATE void dequote ARGS1(char *, url)
d193 2
a194 2
    if (*url == '\'' && len > 1 && url[len-1] == url[0]) {
	url[len-1] = '\0';
d201 1
a201 1
PRIVATE int pumpData ARGS1(HTStream *, me)
d210 8
a217 8
	** Note that the Content-Type value was converted
	** to lower case when we loaded into me->format,
	** but there may have been a mixed or upper-case
	** atom, so we'll force lower-casing again.  We
	** also stripped spaces and double-quotes, but
	** we'll make sure they're still gone from any
	** charset parameter we check.  - FM
	*/
d221 1
d226 1
a226 1
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
d228 4
a231 5
		StrAllocCopy(cp3, cp2); /* copy to mutilate more */
		for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  && *cp4 != ':' &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
d244 2
a245 3
		}
		else if (chndl < 0) {/* got something but we don't
					recognize it */
d249 4
a252 5
			**  UCLYhndl_for_unrec not defined :-(
			**  fallback to UCLYhndl_for_unspec
			**  which always valid.
			*/
			chndl = UCLYhndl_for_unspec;  /* always >= 0 */
d262 11
d275 9
a283 8
		    LYUCcharset * p_in =
			HTAnchor_getUCInfoStage(me->anchor,
						UCT_STAGE_MIME);
		    LYUCcharset * p_out =
			HTAnchor_setUCInfoStage(me->anchor,
						current_char_set,
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
d286 2
a287 2
			**	Try again.
			*/
d310 6
a315 1
		    if (p_in->enc != UCT_ENC_CJK) {
d327 19
a345 21
		    **  Cannot translate.
		    **  If according to some heuristic the given
		    **  charset and the current display character
		    **  both are likely to be like ISO-8859 in
		    **  structure, pretend we have some kind
		    **  of match.
		    */
		    BOOL given_is_8859
			= (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
				  isdigit(UCH(cp4[9])));
		    BOOL given_is_8859like
			= (BOOL) (given_is_8859 ||
				  !strncmp(cp4, "windows-", 8) ||
				  !strncmp(cp4, "cp12", 4) ||
				  !strncmp(cp4, "cp-12", 5));
		    BOOL given_and_display_8859like
			= (BOOL) (given_is_8859like &&
				  (strstr(LYchar_set_names[current_char_set],
					  "ISO-8859") ||
				   strstr(LYchar_set_names[current_char_set],
					  "windows-")));
d367 3
a369 4
		**	No charset parameter is present.
		**	Ignore all other parameters, as
		**	we do when charset is present. - FM
		*/
d377 4
a380 5
    **  If we have an Expires header and haven't
    **  already set the no_cache element for the
    **  anchor, check if we should set it based
    **  on that header. - FM
    */
d385 2
a386 2
	     *  The value is zero, which we treat as
	     *  an absolute no-cache directive. - FM
d391 3
a393 4
	    **  We have a Date header, so check if
	    **  the value is less than or equal to
	    **  that. - FM
	    */
d400 3
a402 3
	    **  We don't have a Date header, and
	    **  the value is in past for us. - FM
	    */
d447 2
a448 1
	    CTRACE((tfp, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
d452 3
a454 3
	    **	Change the format to that for "www/compressed"
	    **	and set up a stream to deal with it. - FM
	    */
d462 1
a462 1
				   me->sink , me->anchor);
d471 3
a473 4
	**	Check for encoding and select state from there,
	**	someday, but until we have the relevant code,
	**	from now push straight through. - FM
	*/
d482 1
a482 1
	char *base = "";	/* FIXME: refresh_url may be relative to doc */
d492 1
a492 1
	    (me->isa->put_string)(me, txt);
d501 1
a501 1
PRIVATE int dispatchField ARGS1(HTStream *, me)
d507 1
d509 1
a509 1
    while ((cp > me->value) && *(--cp) == ' ')  /* S/390 -- gil -- 0146 */
d511 2
a512 2
	**  Trim trailing spaces.
	*/
d543 2
a544 2
	**  Convert to lowercase and indicate in anchor. - FM
	*/
d548 2
a549 2
	**  Check whether to set no_cache for the anchor. - FM
	*/
d605 2
a606 2
	**  Indicate in anchor. - FM
	*/
d616 2
a617 2
	**  Indicate in anchor. - FM
	*/
d620 6
a625 7
	**  It's not clear yet from existing RFCs and IDs
	**  whether we should be looking for file;, attachment;,
	**  and/or inline; before the filename=value, so we'll
	**  just search for "filename" followed by '=' and just
	**  hope we get the intended value.  It is purely a
	**  suggested name, anyway. - FM
	*/
d641 1
a641 1
	if (*me->anchor->SugFname == '\"') {
d643 1
a643 1
			     '\"')) != NULL) {
d666 2
a667 2
	**  Convert to lowercase and indicate in anchor. - FM
	*/
d673 3
a675 3
	    **	Save it to use as a flag for setting
	    **	up a "www/compressed" target. - FM
	    */
d679 3
a681 3
	    **	Some server indicated "8bit", "7bit" or "binary"
	    **	inappropriately.  We'll ignore it. - FM
	    */
d697 2
a698 2
	**  Convert to lowercase and indicate in anchor. - FM
	*/
d709 2
a710 2
	**  Convert to integer and indicate in anchor. - FM
	*/
d724 2
a725 2
	**  Indicate in anchor. - FM
	*/
d735 2
a736 2
	**  Indicate in anchor. - FM
	*/
d751 2
a752 3
	**  Force the Content-Transfer-Encoding value
	**  to all lower case. - FM
	*/
d763 3
a765 3
	**  Force the Content-Type value to all lower case
	**  and strip spaces and double-quotes. - FM
	*/
d767 1
a767 1
	    if (me->value[i] != ' ' && me->value[i] != '\"') {
d773 1
d782 2
a783 2
	**  Indicate in anchor. - FM
	*/
d787 2
a788 3
	/*  Do not trim double quotes:
	 *  an entity tag consists of an opaque quoted string,
	 *  possibly prefixed by a weakness indicator.
d795 2
a796 2
	**  Indicate in anchor. - FM
	*/
d806 2
a807 2
	**  Indicate in anchor. - FM
	*/
d822 2
a823 2
	**  Indicate in anchor. - FM
	*/
d848 2
a849 2
	**  Check whether to set no_cache for the anchor. - FM
	*/
d881 2
a882 2
	**  Indicate in anchor if "YES" or "TRUE". - FM
	*/
d889 3
a891 3
	    **  If server explicitly tells us that it has changed
	    **  its mind, reset flag in anchor. - kw
	    */
d902 2
a903 2
	**  Indicate in anchor. - FM
	*/
d968 1
a968 1
    default:		/* Should never get here */
a973 1

d975 3
a977 3
**
**			A C T I O N	R O U T I N E S
*/
d980 9
a988 10
**	------------------
**
**	This is a FSM parser. It ignores field names it does not understand.
**	Folded header fields are recognized.  Lines without a fieldname at
**	the beginning (that are not folded continuation lines) are ignored
**	as unknown field names.  Fields with empty values are not picked up.
*/
PRIVATE void HTMIME_put_character ARGS2(
	HTStream *,	me,
	char,		c)
d991 1
a991 1
	(*me->targetClass.put_character)(me->target, c);/* MUST BE FAST */
d996 4
a999 4
    **	This slightly simple conversion just strips CR and turns LF to
    **	newline.  On unix LF is \n but on Mac \n is CR for example.
    **	See NetToText for an implementation which preserves single CR or LF.
    */
d1002 8
a1009 7
	** <sigh> This is evidence that at one time, this code supported
	** local character sets other than ASCII.  But there is so much
	** code in HTTP.c that depends on line_buffer's having been
	** translated to local character set that I needed to put the
	** FROMASCII translation there, leaving this translation purely
	** destructive.  -- gil
	*/  /* S/390 -- gil -- 0118 */
d1019 1
a1019 1
    switch(me->state) {
d1024 2
a1025 2
    case MIME_TRANSPARENT:		/* Not reached see above */
	(*me->targetClass.put_character)(me->target, c);
d1029 1
a1029 1
	(*me->targetClass.put_character)(me->target, c); /* MUST BE FAST */
d1033 2
a1034 2
	if (c != '\n' && WHITE(c)) {		/* Folded line */
	    me->state = me->fold_state; /* pop state before newline */
d1037 1
a1037 1
		!WHITE(*(me->value_pointer-1))) {
d1069 2
a1070 1
	    CTRACE((tfp, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n"));
d1084 2
a1085 1
	    CTRACE((tfp, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n"));
d1136 1
a1136 1
	case '\n':			/* Blank line: End of Header! */
d1144 1
a1144 1
	   goto bad_field_name;
d1146 1
a1146 1
	} /* switch on character */
d1149 1
a1149 1
    case miA:				/* Check for 'c','g' or 'l' */
d1156 2
a1157 1
	    CTRACE((tfp, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n"));
d1175 3
a1177 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'g' or 'l'"));
d1180 1
a1180 1
	} /* switch on character */
d1183 1
a1183 1
    case miAL:				/* Check for 'l' or 't' */
d1202 3
a1204 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'l' or 't'"));
d1207 1
a1207 1
	} /* switch on character */
d1210 1
a1210 1
    case miC:				/* Check for 'a' or 'o' */
d1217 2
a1218 1
	    CTRACE((tfp, "HTMIME: Was C, found A, checking for 'che-control:'\n"));
d1228 3
a1230 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d1233 1
a1233 1
	} /* switch on character */
d1236 1
a1236 1
    case miCO:				/* Check for 'n' or 'o' */
d1253 3
a1255 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 'o'"));
d1258 1
a1258 1
	} /* switch on character */
d1261 1
a1261 1
    case miCON:				/* Check for 'n' or 't' */
d1280 3
a1282 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 't'"));
d1285 1
a1285 1
	} /* switch on character */
d1288 1
a1288 1
    case miE:				/* Check for 't' or 'x' */
d1307 3
a1309 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'t' or 'x'"));
d1312 1
a1312 1
	} /* switch on character */
d1315 1
a1315 1
    case miL:				/* Check for 'a', 'i' or 'o' */
d1322 2
a1323 1
	    CTRACE((tfp, "HTMIME: Was L, found A, checking for 'st-modified:'\n"));
d1343 3
a1345 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a', 'i' or 'o'"));
d1348 1
a1348 1
	} /* switch on character */
d1351 1
a1351 1
    case miP:				/* Check for 'r' or 'u' */
d1368 3
a1370 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 'u'"));
d1373 1
a1373 1
	} /* switch on character */
d1376 1
a1376 1
    case miPR:				/* Check for 'a' or 'o' */
d1391 2
a1392 1
	    CTRACE((tfp, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n"));
d1396 3
a1398 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'"));
d1401 1
a1401 1
	} /* switch on character */
d1404 1
a1404 1
    case miR:				/* Check for 'e' */
d1412 3
a1414 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'e'"));
d1417 1
a1417 1
	} /* switch on character */
d1420 1
a1420 1
    case miRE:				/* Check for 'a' or 'o' */
d1423 1
a1423 1
	case 'F':			/* nonstandard: Netscape */
d1439 3
a1441 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'f' or 't'"));
d1444 1
a1444 1
	} /* switch on character */
d1447 1
a1447 1
    case miS:				/* Check for 'a' or 'e' */
d1464 3
a1466 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'e'"));
d1469 1
a1469 1
	} /* switch on character */
d1472 1
a1472 1
    case miSE:				/* Check for 'r' or 't' */
d1491 3
a1493 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 't'"));
d1496 1
a1496 1
	} /* switch on character */
d1499 1
a1499 1
    case miSET_COOKIE:			/* Check for ':' or '2' */
d1502 1
a1502 1
	    me->field = miSET_COOKIE1;		/* remember it */
d1515 3
a1517 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "':' or '2'"));
d1520 1
a1520 1
	} /* switch on character */
d1523 1
a1523 1
    case miT:				/* Check for 'i' or 'r' */
d1538 2
a1539 1
	    CTRACE((tfp, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n"));
d1543 3
a1545 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'i' or 'r'"));
d1548 1
a1548 1
	} /* switch on character */
d1551 1
a1551 1
    case miU:				/* Check for 'p' or 'r' */
d1570 3
a1572 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'p' or 'r'"));
d1575 1
a1575 1
	} /* switch on character */
d1578 1
a1578 1
    case miV:				/* Check for 'a' or 'i' */
d1597 3
a1599 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'i'"));
d1602 1
a1602 1
	} /* switch on character */
d1605 1
a1605 1
    case miW:				/* Check for 'a' or 'w' */
d1620 2
a1621 1
	    CTRACE((tfp, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n"));
d1625 3
a1627 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'w'"));
d1630 1
a1630 1
	} /* switch on character */
d1633 1
a1633 1
    case miCHECK:			/* Check against string */
d1638 3
a1640 2
	    CTRACE((tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, me->check_pointer - 1));
d1648 1
a1648 1
	switch(c) {
d1654 2
a1655 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n"));
d1663 2
a1664 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n"));
d1672 2
a1673 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n"));
d1681 2
a1682 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n"));
d1688 2
a1689 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n"));
d1705 2
a1706 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n"));
d1712 2
a1713 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n"));
d1720 1
a1720 1
	} /* switch on character */
d1726 1
a1726 1
      switch(c) {
d1732 2
a1733 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n"));
d1741 2
a1742 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n"));
d1750 2
a1751 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n"));
d1758 1
a1758 1
	} /* switch on character */
d1764 1
a1764 1
      switch(c) {
d1770 2
a1771 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n"));
d1779 2
a1780 1
	    CTRACE((tfp, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n"));
d1787 1
a1787 1
	} /* switch on character */
d1832 1
a1832 1
	me->field = me->state;		/* remember it */
d1844 2
a1845 2
	    **	Skip white space.
	    */
d1853 2
a1854 2
    GET_VALUE:
	if (c != '\n') {			/* Not end of line */
d1871 1
d1873 11
a1883 2
    } /* switch on state*/

d1886 1
a1886 1
value_too_long:
d1889 1
a1889 1
bad_field_name:				/* Ignore it */
d1891 5
a1899 2


d1901 6
a1906 7
**	---------------
**
**	Strings must be smaller than this buffer size.
*/
PRIVATE void HTMIME_put_string ARGS2(
	HTStream *,	me,
	CONST char *,	s)
d1908 1
a1908 1
    CONST char * p;
d1911 1
a1911 1
	(*me->targetClass.put_string)(me->target,s);
d1916 1
a1916 1
	for (p=s; *p; p++)
a1920 1

d1922 5
a1926 6
**	------------
*/
PRIVATE void HTMIME_write ARGS3(
	HTStream *,	me,
	CONST char *,	s,
	int,		l)
d1928 1
a1928 1
    CONST char * p;
d1931 1
a1931 1
	(*me->targetClass.put_block)(me->target, s, l);
d1936 1
a1936 1
	for (p = s; p < s+l; p++)
a1940 1

d1942 4
a1945 5
**	-------------------
**
*/
PRIVATE void HTMIME_free ARGS1(
	HTStream *,	me)
d1951 1
a1951 1
	    (*me->targetClass._free)(me->target);
d1958 2
a1959 3
PRIVATE void HTMIME_abort ARGS2(
	HTStream *,	me,
	HTError,	e)
d1965 1
a1965 1
	    (*me->targetClass._abort)(me->target, e);
a1969 1

d1971 3
a1973 3
**	-----------------------
*/
PRIVATE CONST HTStreamClass HTMIME =
d1975 6
a1980 6
	"MIMEParser",
	HTMIME_free,
	HTMIME_abort,
	HTMIME_put_character,
	HTMIME_put_string,
	HTMIME_write
a1982 1

d1984 5
a1988 6
**	-------------------------
*/
PUBLIC HTStream* HTMIMEConvert ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d1990 1
a1990 1
    HTStream* me;
d1993 1
d1996 3
a1998 3
    me->isa	=	&HTMIME;
    me->sink	=	sink;
    me->anchor	=	anchor;
d2004 5
d2021 2
a2022 2
    me->target	=	NULL;
    me->state	=	miBEGINNING_OF_LINE;
d2024 4
a2027 4
     *	Sadly enough, change this to always default to WWW_HTML
     *	to parse all text as HTML for the users.
     *	GAB 06-30-94
     *	Thanks to Robert Rowland robert@@cyclops.pei.edu
d2029 2
a2030 3
     *	After discussion of the correct handline, should be application/octet-
     *		stream or unknown; causing servers to send a correct content
     *		type.
d2032 9
a2040 8
     *	The consequence of using WWW_UNKNOWN is that you end up downloading
     *	as a binary file what 99.9% of the time is an HTML file, which should
     *	have been rendered or displayed.  So sadly enough, I'm changing it
     *	back to WWW_HTML, and it will handle the situation like Mosaic does,
     *	and as Robert Rowland suggested, because being functionally correct
     *	99.9% of the time is better than being technically correct but
     *	functionally nonsensical. - FM
     *//***
d2042 8
a2049 8
	***/
    me->format	  =	WWW_HTML;
    me->targetRep =	pres->rep_out;
    me->boundary  =	NULL;		/* Not set yet */
    me->set_cookie =	NULL;		/* Not set yet */
    me->set_cookie2 =	NULL;		/* Not set yet */
    me->refresh_url =	NULL;		/* Not set yet */
    me->encoding  =	0;		/* Not set yet */
d2051 1
a2051 1
    me->net_ascii =	NO;		/* Local character set */
d2061 3
a2063 4
PUBLIC HTStream* HTNetMIME ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d2065 2
a2066 1
    HTStream* me = HTMIMEConvert(pres,anchor, sink);
d2074 3
a2076 4
PUBLIC HTStream* HTMIMERedirect ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d2078 2
a2079 1
    HTStream* me = HTMIMEConvert(pres,anchor, sink);
d2090 4
a2093 4
**		==================================
**
**	K&Rized and added 07-Jun-96 by FM, based on:
**
d2095 24
a2118 24
**
**	ISO-2022-JP handling routines
**			&
**	MIME decode routines (quick hack just for ISO-2022-JP)
**
**		Thu Jan 25 10:11:42 JST 1996
**
**  Copyright (C) 1994, 1995, 1996
**  Shuichi Ichikawa (ichikawa@@nuee.nagoya-u.ac.jp)
**
**  This program is free software; you can redistribute it and/or modify
**  it under the terms of the GNU General Public License as published by
**  the Free Software Foundation; either versions 2, or (at your option)
**  any later version.
**
**  This program is distributed in the hope that it will be useful
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**  GNU General Public License for more details.
**
**  You should have received a copy of the GNU General Public License
**  along with SKK, see the file COPYING.  If not, write to the Free
**  Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
d2121 12
a2132 6
**  MIME decoding routines
**
**	Written by S. Ichikawa,
**	partially inspired by encdec.c of <jh@@efd.lth.se>.
*/
#include <LYCharVals.h>  /* S/390 -- gil -- 0163 */
d2134 2
a2135 8
PRIVATE char HTmm64[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" ;
PRIVATE char HTmmquote[] = "0123456789ABCDEF";
PRIVATE int HTmmcont = 0;

PRIVATE void HTmmdec_base64 ARGS2(
	char **,	t,
	char *,		s)
d2137 1
a2137 1
    int   d, count, j, val;
d2153 6
a2158 6
		if (!(p = strchr(HTmm64, s[j]))) {
			return;
		}
		d = p - HTmm64;
		d <<= (3-j)*6;
		val += d;
d2161 2
a2162 2
		nw[j] = (char) (val & 255);
		val >>= 8;
d2176 2
a2177 3
PRIVATE void HTmmdec_quote ARGS2(
	char **,	t,
	char *,		s)
d2184 1
a2184 1
    for (bp = buf; *s; ) {
d2214 4
a2217 5
**	HTmmdecode for ISO-2022-JP - FM
*/
PUBLIC void HTmmdecode ARGS2(
	char **,	target,
	char *,		source)
d2223 1
a2223 1
    int  base64, quote;
d2227 1
a2227 1
  
d2242 2
a2243 2
		    t >= source && (*t == ' ' || *t == '\t'); t--) {
			u--;
d2248 1
a2248 1
	    for (s += 16, t = mmbuf; *s; ) {
d2266 1
a2266 1
	    for (t = m2buf; *t; )
d2276 1
a2276 1
end:
d2284 5
a2288 6
**  Insert ESC where it seems lost.
**  (The author of this function "rjis" is S. Ichikawa.)
*/
PUBLIC int HTrjis ARGS2(
	char **,	t,
	char *,		s)
d2303 1
a2303 1
    for (p = buf; *s; ) {
d2305 1
a2305 1
	    if (HTmaybekanji((int)s[2], (int)s[3])) {
d2326 1
a2326 1
    *p = *s;	/* terminate string */
d2334 5
a2338 5
**  The following function "maybekanji" is derived from
**  RJIS-1.0 by Mr. Hironobu Takahashi.
**  Maybekanji() is included here under the courtesy of the author.
**  The original comment of rjis.c is also included here.
*/
d2341 1
a2341 1
 * $Header: /cvs/src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTMIME.c,v 1.4 2004/06/22 04:01:42 avsm Exp $
d2360 2
a2361 3
PUBLIC int HTmaybekanji ARGS2(
	int,		c1,
	int,		c2)
d2369 3
a2371 3
    switch(c1-32) {
      case 2:
	if ((14 < c2) && ( c2 < 26))
d2373 1
a2373 1
	if ((33 < c2) && ( c2 < 42))
d2375 1
a2375 1
	if ((48 < c2) && ( c2 < 60))
d2377 1
a2377 1
	if ((74 < c2) && ( c2 < 82))
d2379 1
a2379 1
	if ((89 < c2) && ( c2 < 94))
d2382 1
a2382 1
      case 3:
d2385 1
a2385 1
	if ((25 < c2) && ( c2 < 33))
d2387 1
a2387 1
	if ((58 < c2) && ( c2 < 65))
d2392 1
a2392 1
      case 4:
d2396 1
a2396 1
      case 5:
d2400 2
a2401 2
      case 6:
	if ((24 < c2) && ( c2 < 33))
d2406 2
a2407 2
      case 7:
	if ((33 < c2) && ( c2 < 49))
d2412 1
a2412 1
      case 8:
d2416 1
a2416 1
      case 47:
d2420 1
a2420 1
      case 84:
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@a2064 2
**	Assume caller's buffer is LINE_LENGTH bytes, these decode to
**	no longer than the input strings.
a2065 4
#define LINE_LENGTH 512		/* Maximum length of line of ARTICLE etc */
#ifdef ESC
#undef ESC
#endif /* ESC */
a2066 1
#define ESC	CH_ESC
d2073 2
a2074 2
PUBLIC void HTmmdec_base64 ARGS2(
	char *,		t,
d2078 4
a2081 1
    char  buf[LINE_LENGTH], *bp, nw[4], *p;
d2112 2
a2113 1
    strcpy(t, buf);
d2116 2
a2117 2
PUBLIC void HTmmdec_quote ARGS2(
	char *,		t,
d2120 4
a2123 1
    char  buf[LINE_LENGTH], cval, *bp, *p;
d2150 2
a2151 1
    strcpy(t, buf);
d2158 2
a2159 2
	char *,		trg,
	char *,		str)
d2161 3
a2163 1
    char buf[LINE_LENGTH], mmbuf[LINE_LENGTH];
d2167 4
a2170 3
    buf[0] = '\0';

    for (s = str, u = buf; *s; ) {
d2184 1
a2184 1
		    t >= str && (*t == ' ' || *t == '\t'); t--) {
d2188 2
d2195 1
d2205 1
a2205 1
		HTmmdec_base64(mmbuf, mmbuf);
d2207 2
a2208 2
		HTmmdec_quote(mmbuf, mmbuf);
	    for (t = mmbuf; *t; )
a2210 2
	    /* if (*s == ' ' || *s == '\t') *u++ = *s; */
	    /* for ( ; *s == ' ' || *s == '\t'; s++) ; */
d2219 4
a2222 1
    strcpy(trg, buf);
d2230 1
a2230 1
	char *,		t,
d2233 2
a2234 1
    char *p, buf[LINE_LENGTH];
d2237 3
a2239 3
    if (strchr(s, ESC) || !strchr(s, '$')) {
	if (s != t)
	    strcpy(t, s);
d2242 4
d2250 1
a2250 1
		*p++ = ESC;
d2262 1
a2262 1
	    *p++ = ESC;
d2271 2
a2272 1
    strcpy(t, buf);
d2284 1
a2284 1
 * $Header: rjis.c,v 0.2 92/09/04 takahasi Exp $
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d25 1
a29 2
extern BOOL HTPassEightBitRaw;

d77 3
d135 2
d172 26
d207 7
a213 7
	**	Note that the Content-Type value was converted
	**	to lower case when we loaded into me->format,
	**	but there may have been a mixed or upper-case
	**	atom, so we'll force lower-casing again.  We
	**	also stripped spaces and double-quotes, but
	**	we'll make sure they're still gone from any
	**	charset parameter we check. - FM
d385 1
a385 1
	} else if (LYmktime(me->anchor->expires, FALSE) <= 0) {
d465 20
d658 7
a664 3
	if (!strcmp(me->value, "8bit") ||
	    !strcmp(me->value, "7bit") ||
	    !strcmp(me->value, "binary")) {
a669 6
	} else {
	    /*
	    **	Save it to use as a flag for setting
	    **	up a "www/compressed" target. - FM
	    */
	    StrAllocCopy(me->compression_encoding, me->value);
d851 6
d1089 2
a1090 4
	    me->check_pointer = "etry-after:";
	    me->if_ok = miRETRY_AFTER;
	    me->state = miCHECK;
	    CTRACE((tfp, "HTMIME: Got 'R' at beginning of line, checking for 'etry-after'\n"));
d1378 41
d1768 1
d1986 3
a1988 2
    me->set_cookie  =	NULL;		/* Not set yet */
    me->set_cookie2  =	NULL;		/* Not set yet */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d16 1
a29 1
extern HTCJKlang HTCJK;
d35 1
a35 1
typedef enum _MIME_state {
d103 1
a103 1
	MIME_NET_ASCII, 	/* Translate from net ascii */
d108 1
a108 1
#define VALUE_SIZE 5120 	/* @@@@@@@@@@@@@@ Arbitrary? */
d117 3
d125 1
a125 1
	HTParentAnchor *	anchor; 	/* Given on creation */
d131 1
d135 2
a136 2
	HTFormat		format; 	/* Content-Type */
	HTStream *		target; 	/* While writing out */
d150 1
a150 1
	char *, 	value)
d168 741
d917 4
a920 3
**	This is a FSM parser which is tolerant as it can be of all
**	syntax errors.	It ignores field names it does not understand,
**	and resynchronises on line beginnings.
a925 2
    int i, j;

d970 6
d977 4
d982 1
a982 2

	/*	else Falls through */
d990 1
a990 1
	    CTRACE(tfp, "HTMIME: Got 'A' at beginning of line, state now A\n");
d996 1
a996 1
	    CTRACE (tfp, "HTMIME: Got 'C' at beginning of line, state now C\n");
d1004 1
a1004 1
	    CTRACE (tfp, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n");
d1010 1
a1010 1
	    CTRACE (tfp, "HTMIME: Got 'E' at beginning of line, state now E\n");
d1018 1
a1018 1
	    CTRACE(tfp, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n");
d1024 1
a1024 1
	    CTRACE (tfp, "HTMIME: Got 'L' at beginning of line, state now L\n");
d1030 1
a1030 1
	    CTRACE (tfp, "HTMIME: Got 'P' at beginning of line, state now P\n");
d1038 1
a1038 1
	    CTRACE(tfp, "HTMIME: Got 'R' at beginning of line, checking for 'etry-after'\n");
d1044 1
a1044 1
	    CTRACE (tfp, "HTMIME: Got 'S' at beginning of line, state now S\n");
d1050 1
a1050 1
	    CTRACE (tfp, "HTMIME: Got 'T' at beginning of line, state now T\n");
d1056 1
a1056 1
	    CTRACE (tfp, "HTMIME: Got 'U' at beginning of line, state now U\n");
d1062 1
a1062 1
	    CTRACE (tfp, "HTMIME: Got 'V' at beginning of line, state now V\n");
d1068 1
a1068 1
	    CTRACE (tfp, "HTMIME: Got 'W' at beginning of line, state now W\n");
d1074 1
a1074 233
		if (strchr(HTAtom_name(me->format), ';') != NULL) {
		    char *cp = NULL, *cp1, *cp2, *cp3 = NULL, *cp4;

		    CTRACE(tfp, "HTMIME: Extended MIME Content-Type is %s\n",
				HTAtom_name(me->format));
		    StrAllocCopy(cp, HTAtom_name(me->format));
		    /*
		    **	Note that the Content-Type value was converted
		    **	to lower case when we loaded into me->format,
		    **	but there may have been a mixed or upper-case
		    **	atom, so we'll force lower-casing again.  We
		    **	also stripped spaces and double-quotes, but
		    **	we'll make sure they're still gone from any
		    **	charset parameter we check. - FM
		    */
		    LYLowerCase(cp);
		    if ((cp1 = strchr(cp, ';')) != NULL) {
			BOOL chartrans_ok = NO;
			if ((cp2 = strstr(cp1, "charset")) != NULL) {
			    int chndl;

			    cp2 += 7;
			    while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
				cp2++;
			    StrAllocCopy(cp3, cp2); /* copy to mutilate more */
			    for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '\"' &&
					     *cp4 != ';'  && *cp4 != ':' &&
					     !WHITE(*cp4));	cp4++)
				; /* do nothing */
			    *cp4 = '\0';
			    cp4 = cp3;
			    chndl = UCGetLYhndl_byMIME(cp3);
			    if (UCCanTranslateFromTo(chndl,
						     current_char_set)) {
				chartrans_ok = YES;
				*cp1 = '\0';
				me->format = HTAtom_for(cp);
				StrAllocCopy(me->anchor->charset, cp4);
				HTAnchor_setUCInfoStage(me->anchor, chndl,
							UCT_STAGE_MIME,
							UCT_SETBY_MIME);
			    }
			    else if (chndl < 0) {/* got something but we don't
						 recognize it */
				chndl = UCLYhndl_for_unrec;
				if (chndl < 0)
				/*
				 **  UCLYhndl_for_unrec not defined :-(
				 **  fallback to UCLYhndl_for_unspec
				 **  which always valid.
				 */
				chndl = UCLYhndl_for_unspec;  /* always >= 0 */
				if (UCCanTranslateFromTo(chndl,
							 current_char_set)) {
				    chartrans_ok = YES;
				    *cp1 = '\0';
				    me->format = HTAtom_for(cp);
				    HTAnchor_setUCInfoStage(me->anchor, chndl,
							    UCT_STAGE_MIME,
							    UCT_SETBY_DEFAULT);
				}
			    }
			    if (chartrans_ok) {
				LYUCcharset * p_in =
				    HTAnchor_getUCInfoStage(me->anchor,
							    UCT_STAGE_MIME);
				LYUCcharset * p_out =
				    HTAnchor_setUCInfoStage(me->anchor,
							    current_char_set,
							    UCT_STAGE_HTEXT,
							    UCT_SETBY_DEFAULT);
				if (!p_out)
				    /*
				    **	Try again.
				    */
				    p_out =
				      HTAnchor_getUCInfoStage(me->anchor,
							      UCT_STAGE_HTEXT);

				if (!strcmp(p_in->MIMEname,
					    "x-transparent")) {
				    HTPassEightBitRaw = TRUE;
				    HTAnchor_setUCInfoStage(me->anchor,
				       HTAnchor_getUCLYhndl(me->anchor,
							    UCT_STAGE_HTEXT),
							    UCT_STAGE_MIME,
							    UCT_SETBY_DEFAULT);
				}
				if (!strcmp(p_out->MIMEname,
					    "x-transparent")) {
				    HTPassEightBitRaw = TRUE;
				    HTAnchor_setUCInfoStage(me->anchor,
					 HTAnchor_getUCLYhndl(me->anchor,
							      UCT_STAGE_MIME),
							    UCT_STAGE_HTEXT,
							    UCT_SETBY_DEFAULT);
				}
				if (p_in->enc != UCT_ENC_CJK) {
				    HTCJK = NOCJK;
				    if (!(p_in->codepoints &
					  UCT_CP_SUBSETOF_LAT1) &&
					chndl == current_char_set) {
					HTPassEightBitRaw = TRUE;
				    }
				} else if (p_out->enc == UCT_ENC_CJK) {
				    Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
				}
			    } else {
				/*
				**  Cannot translate.
				**  If according to some heuristic the given
				**  charset and the current display character
				**  both are likely to be like ISO-8859 in
				**  structure, pretend we have some kind
				**  of match.
				*/
				BOOL given_is_8859
				    = (!strncmp(cp4, "iso-8859-", 9) &&
				       isdigit((unsigned char)cp4[9]));
				BOOL given_is_8859like
				    = (given_is_8859 ||
				       !strncmp(cp4, "windows-", 8) ||
				       !strncmp(cp4, "cp12", 4) ||
				       !strncmp(cp4, "cp-12", 5));
				BOOL given_and_display_8859like
				    = (given_is_8859like &&
				       (strstr(LYchar_set_names[current_char_set],
					       "ISO-8859") ||
					strstr(LYchar_set_names[current_char_set],
					       "windows-")));

				if (given_and_display_8859like) {
				    *cp1 = '\0';
				    me->format = HTAtom_for(cp);
				}
				if (given_is_8859) {
				    cp1 = &cp4[10];
				    while (*cp1 &&
					   isdigit((unsigned char)(*cp1)))
					cp1++;
				    *cp1 = '\0';
				}
				if (given_and_display_8859like) {
				    StrAllocCopy(me->anchor->charset, cp4);
				    HTPassEightBitRaw = TRUE;
				}
				HTAlert(*cp4 ? cp4 : me->anchor->charset);
			    }
			    FREE(cp3);
			} else {
			    /*
			    **	No charset parameter is present.
			    **	Ignore all other parameters, as
			    **	we do when charset is present. - FM
			    */
			    *cp1 = '\0';
			    me->format = HTAtom_for(cp);
			}
		    }
		    FREE(cp);
		}
		/*
		**  If we have an Expires header and haven't
		**  already set the no_cache element for the
		**  anchor, check if we should set it based
		**  on that header. - FM
		*/
		if (me->anchor->no_cache == FALSE &&
		    me->anchor->expires != NULL) {
		    if (!strcmp(me->anchor->expires, "0")) {
			/*
			 *  The value is zero, which we treat as
			 *  an absolute no-cache directive. - FM
			 */
			me->anchor->no_cache = TRUE;
		    } else if (me->anchor->date != NULL) {
			/*
			**  We have a Date header, so check if
			**  the value is less than or equal to
			**  that. - FM
			*/
			if (LYmktime(me->anchor->expires, TRUE) <=
			    LYmktime(me->anchor->date, TRUE)) {
			    me->anchor->no_cache = TRUE;
			}
		    } else if (LYmktime(me->anchor->expires, FALSE) <= 0) {
			/*
			**  We don't have a Date header, and
			**  the value is in past for us. - FM
			*/
			me->anchor->no_cache = TRUE;
		    }
		}
		StrAllocCopy(me->anchor->content_type,
			     HTAtom_name(me->format));
		if (!me->compression_encoding) {
		    CTRACE(tfp, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
				HTAtom_name(me->format), HTAtom_name(me->targetRep));
		} else {
		    /*
		    **	Change the format to that for "www/compressed"
		    **	and set up a stream to deal with it. - FM
		    */
		    CTRACE(tfp, "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format));
		    me->format = HTAtom_for("www/compressed");
		    CTRACE(tfp, "        Treating as '%s'.  Converting to '%s'\n",
				HTAtom_name(me->format), HTAtom_name(me->targetRep));
		}
		if (me->set_cookie != NULL || me->set_cookie2 != NULL) {
		    LYSetCookie(me->set_cookie,
				me->set_cookie2,
				me->anchor->address);
		    FREE(me->set_cookie);
		    FREE(me->set_cookie2);
		}
		me->target = HTStreamStack(me->format, me->targetRep,
					   me->sink , me->anchor);
		if (!me->target) {
		    CTRACE(tfp, "HTMIME: Can't translate! ** \n");
		    me->target = me->sink;	/* Cheat */
		}
		if (me->target) {
		    me->targetClass = *me->target->isa;
		    /*
		    **	Check for encoding and select state from there,
		    **	someday, but until we have the relevant code,
		    **	from now push straight through. - FM
		    */
		    me->state = MIME_TRANSPARENT;
		} else {
		    me->state = MIME_IGNORE;	/* What else to do? */
		}
		FREE(me->compression_encoding);
d1091 1
a1091 1
	    CTRACE(tfp, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n");
d1099 1
a1099 1
	    CTRACE(tfp, "HTMIME: Was A, found G, checking for 'e:'\n");
d1105 1
a1105 1
	    CTRACE(tfp, "HTMIME: Was A, found L, state now AL'\n");
d1109 2
a1110 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'g' or 'l'");
d1123 1
a1123 1
	    CTRACE(tfp, "HTMIME: Was AL, found L, checking for 'ow:'\n");
d1131 1
a1131 1
	    CTRACE(tfp, "HTMIME: Was AL, found T, checking for 'ernates:'\n");
d1135 2
a1136 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'l' or 't'");
d1149 1
a1149 1
	    CTRACE(tfp, "HTMIME: Was C, found A, checking for 'che-control:'\n");
d1155 1
a1155 1
	    CTRACE(tfp, "HTMIME: Was C, found O, state now CO'\n");
d1159 2
a1160 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'");
d1171 1
a1171 1
	    CTRACE(tfp, "HTMIME: Was CO, found N, state now CON\n");
d1179 1
a1179 1
	    CTRACE(tfp, "HTMIME: Was CO, found O, checking for 'kie:'\n");
d1183 2
a1184 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 'o'");
d1190 1
a1190 1
    case miCON: 			/* Check for 'n' or 't' */
d1197 1
a1197 1
	    CTRACE(tfp, "HTMIME: Was CON, found N, checking for 'ection:'\n");
d1205 1
a1205 1
	    CTRACE(tfp, "HTMIME: Was CON, found T, checking for 'ent-'\n");
d1209 2
a1210 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'n' or 't'");
d1223 1
a1223 1
	    CTRACE(tfp, "HTMIME: Was E, found T, checking for 'ag:'\n");
d1231 1
a1231 1
	    CTRACE(tfp, "HTMIME: Was E, found X, checking for 'pires:'\n");
d1235 2
a1236 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'t' or 'x'");
d1249 1
a1249 1
	    CTRACE(tfp, "HTMIME: Was L, found A, checking for 'st-modified:'\n");
d1257 1
a1257 1
	    CTRACE(tfp, "HTMIME: Was L, found I, checking for 'nk:'\n");
d1265 1
a1265 1
	    CTRACE(tfp, "HTMIME: Was L, found O, checking for 'cation:'\n");
d1269 2
a1270 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a', 'i' or 'o'");
d1281 1
a1281 1
	    CTRACE(tfp, "HTMIME: Was P, found R, state now PR'\n");
d1289 1
a1289 1
	    CTRACE(tfp, "HTMIME: Was P, found U, checking for 'blic:'\n");
d1293 2
a1294 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 'u'");
d1307 1
a1307 1
	    CTRACE(tfp, "HTMIME: Was PR, found A, checking for 'gma'\n");
d1315 1
a1315 1
	    CTRACE(tfp, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n");
d1319 2
a1320 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'o'");
d1333 1
a1333 1
	    CTRACE(tfp, "HTMIME: Was S, found A, checking for 'fe:'\n");
d1339 1
a1339 1
	    CTRACE(tfp, "HTMIME: Was S, found E, state now SE'\n");
d1343 2
a1344 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'e'");
d1357 1
a1357 1
	    CTRACE(tfp, "HTMIME: Was SE, found R, checking for 'ver'\n");
d1365 1
a1365 1
	    CTRACE(tfp, "HTMIME: Was SE, found T, checking for '-cookie'\n");
d1369 2
a1370 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'r' or 't'");
d1381 1
a1381 1
	    CTRACE(tfp, "HTMIME: Was SET_COOKIE, found :, processing\n");
d1388 1
a1388 1
	    CTRACE(tfp, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n");
d1392 2
a1393 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "':' or '2'");
d1406 1
a1406 1
	    CTRACE(tfp, "HTMIME: Was T, found I, checking for 'tle:'\n");
d1414 1
a1414 1
	    CTRACE(tfp, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n");
d1418 2
a1419 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'i' or 'r'");
d1432 1
a1432 1
	    CTRACE(tfp, "HTMIME: Was U, found P, checking for 'grade:'\n");
d1440 1
a1440 1
	    CTRACE(tfp, "HTMIME: Was U, found R, checking for 'i:'\n");
d1444 2
a1445 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'p' or 'r'");
d1458 1
a1458 1
	    CTRACE(tfp, "HTMIME: Was V, found A, checking for 'ry:'\n");
d1466 1
a1466 1
	    CTRACE(tfp, "HTMIME: Was V, found I, checking for 'a:'\n");
d1470 2
a1471 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'i'");
d1484 1
a1484 1
	    CTRACE(tfp, "HTMIME: Was W, found A, checking for 'rning:'\n");
d1492 1
a1492 1
	    CTRACE(tfp, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n");
d1496 2
a1497 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, "'a' or 'w'");
d1508 2
a1509 2
	    CTRACE(tfp, "HTMIME: Bad character `%c' found where `%s' expected\n",
			c, me->check_pointer - 1);
d1515 1
a1515 1
	CTRACE (tfp, "HTMIME: in case CONTENT_\n");
d1523 1
a1523 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n");
d1531 1
a1531 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n");
d1539 1
a1539 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n");
d1547 1
a1547 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n");
d1553 1
a1553 1
	    CTRACE (tfp, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n");
d1561 1
a1561 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n");
d1569 1
a1569 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n");
d1575 1
a1575 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n");
d1579 1
a1579 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_, found nothing; bleah\n");
d1586 1
a1586 1
	CTRACE (tfp, "HTMIME: in case CONTENT_L\n");
d1594 1
a1594 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n");
d1602 1
a1602 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n");
d1610 1
a1610 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n");
d1614 1
a1614 1
	    CTRACE (tfp, "HTMIME: Was CONTENT_L, found nothing; bleah\n");
d1621 1
a1621 1
	CTRACE (tfp, "HTMIME: in case CONTENT_T\n");
d1629 1
a1629 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n");
d1637 1
a1637 1
	    CTRACE(tfp, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n");
d1641 1
a1641 1
	    CTRACE (tfp, "HTMIME: Was CONTENT_T, found nothing; bleah\n");
d1694 3
a1696 3
	   me->fold_state = me->state;
	   me->state = miNEWLINE;
	   break;
d1709 2
a1710 452
    	if (WHITE(c) && c != ' ') {			/* End of field */
	    char *cp;
	    *me->value_pointer = '\0';
	    cp = (me->value_pointer - 1);
	    while ((cp >= me->value) && *cp == ' ')  /* S/390 -- gil -- 0146 */
		/*
		**  Trim trailing spaces.
		*/
		*cp = '\0';
	    switch (me->field) {
	    case miACCEPT_RANGES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
			    me->value);
		break;
	    case miAGE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Age: '%s'\n",
			    me->value);
		break;
	    case miALLOW:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Allow: '%s'\n",
			    me->value);
		break;
	    case miALTERNATES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Alternates: '%s'\n",
			    me->value);
		break;
	    case miCACHE_CONTROL:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Cache-Control: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Convert to lowercase and indicate in anchor. - FM
		*/
		LYLowerCase(me->value);
		StrAllocCopy(me->anchor->cache_control, me->value);
		/*
		**  Check whether to set no_cache for the anchor. - FM
		*/
		{
		    char *cp1, *cp0 = me->value;

		    while ((cp1 = strstr(cp0, "no-cache")) != NULL) {
			cp1 += 8;
			while (*cp1 != '\0' && WHITE(*cp1))
			    cp1++;
			if (*cp1 == '\0' || *cp1 == ';') {
			    me->anchor->no_cache = TRUE;
			    break;
			}
			cp0 = cp1;
		    }
		    if (me->anchor->no_cache == TRUE)
			break;
		    cp0 = me->value;
		    while ((cp1 = strstr(cp0, "max-age")) != NULL) {
			cp1 += 7;
			while (*cp1 != '\0' && WHITE(*cp1))
			    cp1++;
			if (*cp1 == '=') {
			    cp1++;
			    while (*cp1 != '\0' && WHITE(*cp1))
				cp1++;
			    if (isdigit((unsigned char)*cp1)) {
				cp0 = cp1;
				while (isdigit((unsigned char)*cp1))
				    cp1++;
				if (*cp0 == '0' && cp1 == (cp0 + 1)) {
				    me->anchor->no_cache = TRUE;
				    break;
				}
			    }
			}
			cp0 = cp1;
		    }
		}
		break;
	    case miCOOKIE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Cookie: '%s'\n",
			    me->value);
		break;
	    case miCONNECTION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Connection: '%s'\n",
			    me->value);
		break;
	    case miCONTENT_BASE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Base: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_base, me->value);
		break;
	    case miCONTENT_DISPOSITION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Disposition: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_disposition, me->value);
		/*
		**  It's not clear yet from existing RFCs and IDs
		**  whether we should be looking for file;, attachment;,
		**  and/or inline; before the filename=value, so we'll
		**  just search for "filename" followed by '=' and just
		**  hope we get the intended value.  It is purely a
		**  suggested name, anyway. - FM
		*/
		cp = me->anchor->content_disposition;
		while (*cp != '\0' && strncasecomp(cp, "filename", 8))
		    cp++;
		if (*cp == '\0')
		    break;
		cp += 8;
		while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
		    cp++;
		if (*cp == '\0')
		    break;
		while (*cp != '\0' && WHITE(*cp))
		    cp++;
		if (*cp == '\0')
		    break;
		StrAllocCopy(me->anchor->SugFname, cp);
		if (*me->anchor->SugFname == '\"') {
		    if ((cp = strchr((me->anchor->SugFname + 1),
				     '\"')) != NULL) {
			*(cp + 1) = '\0';
			HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
		    } else {
			FREE(me->anchor->SugFname);
			break;
		    }
		}
		cp = me->anchor->SugFname;
		while (*cp != '\0' && !WHITE(*cp))
		    cp++;
		*cp = '\0';
		if (*me->anchor->SugFname == '\0')
		    FREE(me->anchor->SugFname);
		break;
	    case miCONTENT_ENCODING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Encoding: '%s'\n",
			    me->value);
		if (!(me->value && *me->value) ||
		    !strcasecomp(me->value, "identity"))
		    break;
		/*
		**  Convert to lowercase and indicate in anchor. - FM
		*/
		LYLowerCase(me->value);
		StrAllocCopy(me->anchor->content_encoding, me->value);
		FREE(me->compression_encoding);
		if (!strcmp(me->value, "8bit") ||
		    !strcmp(me->value, "7bit") ||
		    !strcmp(me->value, "binary")) {
		    /*
		    **	Some server indicated "8bit", "7bit" or "binary"
		    **	inappropriately.  We'll ignore it. - FM
		    */
		    CTRACE(tfp, "                Ignoring it!\n");
		} else {
		    /*
		    **	Save it to use as a flag for setting
		    **	up a "www/compressed" target. - FM
		    */
		    StrAllocCopy(me->compression_encoding, me->value);
		}
		break;
	    case miCONTENT_FEATURES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Features: '%s'\n",
			    me->value);
		break;
	    case miCONTENT_LANGUAGE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Language: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Convert to lowercase and indicate in anchor. - FM
		*/
		LYLowerCase(me->value);
		StrAllocCopy(me->anchor->content_language, me->value);
		break;
	    case miCONTENT_LENGTH:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Length: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Convert to integer and indicate in anchor. - FM
		*/
		me->anchor->content_length = atoi(me->value);
		if (me->anchor->content_length < 0)
		    me->anchor->content_length = 0;
		CTRACE(tfp, "        Converted to integer: '%d'\n",
			    me->anchor->content_length);
		break;
	    case miCONTENT_LOCATION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Location: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_location, me->value);
		break;
	    case miCONTENT_MD5:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-MD5: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->content_md5, me->value);
		break;
	    case miCONTENT_RANGE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Range: '%s'\n",
			    me->value);
		break;
	    case miCONTENT_TRANSFER_ENCODING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Force the Content-Transfer-Encoding value
		**  to all lower case. - FM
		*/
		LYLowerCase(me->value);
		me->encoding = HTAtom_for(me->value);
		break;
	    case miCONTENT_TYPE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Content-Type: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Force the Content-Type value to all lower case
		**  and strip spaces and double-quotes. - FM
		*/
		for (i = 0, j = 0; me->value[i]; i++) {
		    if (me->value[i] != ' ' && me->value[i] != '\"') {
			me->value[j++] = TOLOWER(me->value[i]);
		    }
		}
		me->value[j] = '\0';
		me->format = HTAtom_for(me->value);
		break;
	    case miDATE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Date: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->date, me->value);
		break;
	    case miETAG:
		/*  Do not trim double quotes:
		 *  an entity tag consists of an opaque quoted string,
		 *  possibly prefixed by a weakness indicator.
		 */
		CTRACE(tfp, "HTMIME: PICKED UP ETag: %s\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->ETag, me->value);
		break;
	    case miEXPIRES:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Expires: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->expires, me->value);
		break;
	    case miKEEP_ALIVE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Keep-Alive: '%s'\n",
			    me->value);
		break;
	    case miLAST_MODIFIED:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Last-Modified: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->last_modified, me->value);
		break;
	    case miLINK:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Link: '%s'\n",
			    me->value);
		break;
	    case miLOCATION:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Location: '%s'\n",
			    me->value);
		break;
	    case miPRAGMA:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Pragma: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Check whether to set no_cache for the anchor. - FM
		*/
		if (!strcmp(me->value, "no-cache"))
		    me->anchor->no_cache = TRUE;
		break;
	    case miPROXY_AUTHENTICATE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
			    me->value);
		break;
	    case miPUBLIC:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Public: '%s'\n",
			    me->value);
		break;
	    case miRETRY_AFTER:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Retry-After: '%s'\n",
			    me->value);
		break;
	    case miSAFE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Safe: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor if "YES" or "TRUE". - FM
		*/
		if (!strcasecomp(me->value, "YES") ||
		    !strcasecomp(me->value, "TRUE")) {
		    me->anchor->safe = TRUE;
		}
		break;
	    case miSERVER:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Server: '%s'\n",
			    me->value);
		if (!(me->value && *me->value))
		    break;
		/*
		**  Indicate in anchor. - FM
		*/
		StrAllocCopy(me->anchor->server, me->value);
		break;
	    case miSET_COOKIE1:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Set-Cookie: '%s'\n",
			    me->value);
		if (me->set_cookie == NULL) {
		    StrAllocCopy(me->set_cookie, me->value);
		} else {
		    StrAllocCat(me->set_cookie, ", ");
		    StrAllocCat(me->set_cookie, me->value);
		}
		break;
	    case miSET_COOKIE2:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
			    me->value);
		if (me->set_cookie2 == NULL) {
		    StrAllocCopy(me->set_cookie2, me->value);
		} else {
		    StrAllocCat(me->set_cookie2, ", ");
		    StrAllocCat(me->set_cookie2, me->value);
		}
		break;
	    case miTITLE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Title: '%s'\n",
			    me->value);
		break;
	    case miTRANSFER_ENCODING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
			    me->value);
		break;
	    case miUPGRADE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Upgrade: '%s'\n",
			    me->value);
		break;
	    case miURI:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP URI: '%s'\n",
			    me->value);
		break;
	    case miVARY:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Vary: '%s'\n",
			    me->value);
		break;
	    case miVIA:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Via: '%s'\n",
			    me->value);
		break;
	    case miWARNING:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP Warning: '%s'\n",
			    me->value);
		break;
	    case miWWW_AUTHENTICATE:
		HTMIME_TrimDoubleQuotes(me->value);
		CTRACE(tfp, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
			    me->value);
		break;
	    default:		/* Should never get here */
		break;
	    }
	} else {
d1718 1
a1718 1
	/* Fall through */
d1722 1
a1723 1
	    me->fold_state = me->state;
d1733 1
a1733 1
    CTRACE(tfp, "HTMIME: *** Syntax error. (string too long)\n");
d1735 1
a1735 1
bad_field_name: 			/* Ignore it */
d1758 1
a1758 1
	CTRACE(tfp, "HTMIME:  %s\n", s);
d1780 1
a1780 1
	CTRACE(tfp, "HTMIME:  %.*s\n", l, s);
d1795 7
a1801 3
    if (me->target)
	(*me->targetClass._free)(me->target);
    FREE(me);
d1810 7
a1816 3
    if (me->target)
	(*me->targetClass._abort)(me->target, e);
    FREE(me);
d1844 1
a1844 1
    me = (HTStream *)calloc(1, sizeof(*me));
d1919 15
d1970 2
d1973 1
a1973 1
#define BUFLEN	1024
d1986 2
a1987 2
	char *, 	t,
	char *, 	s)
d1990 1
a1990 1
    char  buf[BUFLEN], *bp, nw[4], *p;
d2010 1
a2010 1
		nw[j] = val & 255;
d2025 2
a2026 2
	char *, 	t,
	char *, 	s)
d2028 1
a2028 1
    char  buf[BUFLEN], cval, *bp, *p;
d2034 1
a2034 1
		cval += (p - HTmmquote);
d2041 1
a2041 1
		cval += (p - HTmmquote);
a2057 96
#ifdef NOTDEFINED
/*
**	Generalized HTmmdecode for chartrans - K. Weide 1997-03-06
*/
PUBLIC void HTmmdecode ARGS2(
	char *, 	trg,
	char *, 	str)
{
    char buf[BUFLEN], mmbuf[BUFLEN];
    char *s, *t, *u, *qm2;
    int  base64, quote;

    buf[0] = '\0';

    /*
    **	Encoded-words look like
    **		=?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
    */
    for (s = str, u = buf; *s; ) {
	base64 = quote = 0;
	if (*s == '=' && s[1] == '?' &&
	    (s == str || *(s-1) == '(' || WHITE(*(s-1))))
	{ /* must be beginning of word */
	    qm2 = strchr(s+2, '?'); /* 2nd question mark */
	    if (qm2 &&
		(qm2[1] == 'B' || qm2[1] == 'b' || qm2[1] == 'Q' ||
		 qm2[1] == 'q') &&
		qm2[2] == '?') { /* 3rd question mark */
		char * qm4 = strchr(qm2 + 3, '?'); /* 4th question mark */
		if (qm4 && qm4 - s < 74 &&  /* RFC 2047 length restriction */
		    qm4[1] == '=') {
		    char *p;
		    BOOL invalid = NO;
		    for (p = s+2; p < qm4; p++)
			if (WHITE(*p)) {
			    invalid = YES;
			    break;
			}
		    if (!invalid) {
			int LYhndl;

			*qm2 = '\0';
			invalid = ((LYhndl = UCGetLYhndl_byMIME(s+2)) < 0 ||
				   UCCanTranslateFromTo(LYhndl,
						 current_char_set));
			*qm2 = '?';
		    }
		    if (!invalid) {
			if (qm2[1] == 'B' || qm2[1] == 'b')
			    base64 = 1;
			else if (qm2[1] == 'Q' || qm2[1] == 'q')
			    quote = 1;
		    }
		}
	    }
	}
	if (base64 || quote) {
	    if (HTmmcont) {
		for (t = s - 1;
		    t >= str && (*t == ' ' || *t == '\t'); t--) {
			u--;
		}
	    }
	    for (s = qm2 + 3, t = mmbuf; *s; ) {
		if (s[0] == '?' && s[1] == '=') {
		    break;
		} else {
		    *t++ = *s++;
		}
	    }
	    if (s[0] != '?' || s[1] != '=') {
		goto end;
	    } else {
		s += 2;
		*t = '\0';
	    }
	    if (base64)
		HTmmdec_base64(mmbuf, mmbuf);
	    if (quote)
		HTmmdec_quote(mmbuf, mmbuf);
	    for (t = mmbuf; *t; )
		*u++ = *t++;
	    HTmmcont = 1;
	    /* if (*s == ' ' || *s == '\t') *u++ = *s; */
	    /* for ( ; *s == ' ' || *s == '\t'; s++) ; */
	} else {
	    if (*s != ' ' && *s != '\t')
		HTmmcont = 0;
	    *u++ = *s++;
	}
    }
    *u = '\0';
end:
    strcpy(trg, buf);
}
#else
d2062 2
a2063 2
	char *, 	trg,
	char *, 	str)
d2065 1
a2065 1
    char buf[BUFLEN], mmbuf[BUFLEN];
a2120 1
#endif /* NOTDEFINED */
d2127 2
a2128 2
	char *, 	t,
	char *, 	s)
d2130 1
a2130 1
    char *p, buf[BUFLEN];
@


1.1
log
@Initial revision
@
text
@d14 13
a26 7
#include "HTUtils.h"
#include "HTMIME.h"		/* Implemented here */
#include "HTAlert.h"
#include "HTCJK.h"
#include "UCMap.h"
#include "UCDefs.h"
#include "UCAux.h"
a27 7
#include "LYCharSets.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

extern CONST char *LYchar_set_names[];
extern BOOLEAN LYRawMode;
a30 7
extern void LYSetCookie PARAMS((
	CONST char *	SetCookie,
	CONST char *	SetCookie2,
	CONST char *	address));
extern time_t LYmktime PARAMS((char *string, BOOL absolute));


d108 1
a108 1
#define VALUE_SIZE 1024 	/* @@@@@@@@@@@@@@ Arbitrary? */
d193 9
d203 1
d237 1
a237 3
	    if (TRACE)
		fprintf(stderr,
		       "HTMIME: Got 'A' at beginning of line, state now A\n");
d243 1
a243 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'C' at beginning of line, state now C\n");
d251 1
a251 3
	    if (TRACE)
		fprintf (stderr,
	      "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n");
d257 1
a257 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'E' at beginning of line, state now E\n");
d265 1
a265 3
	    if (TRACE)
		fprintf(stderr,
	 "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n");
d271 1
a271 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'L' at beginning of line, state now L\n");
d277 1
a277 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'P' at beginning of line, state now P\n");
d285 1
a285 3
	    if (TRACE)
		fprintf(stderr,
	 "HTMIME: Got 'R' at beginning of line, checking for 'etry-after'\n");
d291 1
a291 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'S' at beginning of line, state now S\n");
d297 1
a297 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'T' at beginning of line, state now T\n");
d303 1
a303 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'U' at beginning of line, state now U\n");
d309 1
a309 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'V' at beginning of line, state now V\n");
d315 1
a315 3
	    if (TRACE)
		fprintf (stderr,
		       "HTMIME: Got 'W' at beginning of line, state now W\n");
d324 1
a324 3
		    if (TRACE)
			fprintf(stderr,
				"HTMIME: Extended MIME Content-Type is %s\n",
d336 1
a336 2
		    for (i = 0; cp[i]; i++)
			cp[i] = TOLOWER(cp[i]);
d366 7
a382 1
			    FREE(cp3);
d426 1
a426 31
				    if (LYRawMode) {
					if ((!strcmp(p_in->MIMEname,
						     "euc-jp") ||
					     !strcmp(p_in->MIMEname,
						     "shift_jis")) &&
					    (!strcmp(p_out->MIMEname,
						     "euc-jp") ||
					     !strcmp(p_out->MIMEname,
						     "shift_jis"))) {
					    HTCJK = JAPANESE;
					} else if (!strcmp(p_in->MIMEname,
							   "euc-cn") &&
						   !strcmp(p_out->MIMEname,
							   "euc-cn")) {
					    HTCJK = CHINESE;
					} else if (!strcmp(p_in->MIMEname,
							   "big-5") &&
						   !strcmp(p_out->MIMEname,
							   "big-5")) {
					    HTCJK = TAIPEI;
					} else if (!strcmp(p_in->MIMEname,
							   "euc-kr") &&
						   !strcmp(p_out->MIMEname,
							   "euc-kr")) {
					    HTCJK = KOREAN;
					} else {
					    HTCJK = NOCJK;
					}
				    } else {
					HTCJK = NOCJK;
				    }
d428 1
a428 8
			    /*
			    **  Check for an iso-8859-# we don't know. - FM
			    */
			    } else if
			       (!strncmp(cp4, "iso-8859-", 9) &&
				isdigit((unsigned char)cp4[9]) &&
				!strncmp(LYchar_set_names[current_char_set],
					 "Other ISO Latin", 15)) {
d430 6
a435 1
				**  Hope it's a match, for now. - FM
d437 31
a467 10
				*cp1 = '\0';
				me->format = HTAtom_for(cp);
				cp1 = &cp4[10];
				while (*cp1 &&
				       isdigit((unsigned char)(*cp1)))
				    cp1++;
				*cp1 = '\0';
				StrAllocCopy(me->anchor->charset, cp4);
				HTPassEightBitRaw = TRUE;
				HTAlert(me->anchor->charset);
d517 2
a518 5
		    if (TRACE) {
			fprintf(stderr,
		    "HTMIME: MIME Content-Type is '%s', converting to '%s'\n",
			 HTAtom_name(me->format), HTAtom_name(me->targetRep));
		    }
d524 1
a524 4
		    if (TRACE) {
			fprintf(stderr,
	     "HTMIME: MIME Content-Type is '%s',\n", HTAtom_name(me->format));
		    }
d526 2
a527 5
		    if (TRACE) {
			fprintf(stderr,
			 "        Treating as '%s'.  Converting to '%s'\n",
			 HTAtom_name(me->format), HTAtom_name(me->targetRep));
		    }
d539 1
a539 2
		    if (TRACE)
			fprintf(stderr, "HTMIME: Can't translate! ** \n");
a558 1
	   break;
d570 1
a570 3
	    if (TRACE)
		fprintf(stderr,
		    "HTMIME: Was A, found C, checking for 'cept-ranges:'\n");
d578 1
a578 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was A, found G, checking for 'e:'\n");
d584 1
a584 2
	    if (TRACE)
		fprintf(stderr, "HTMIME: Was A, found L, state now AL'\n");
d588 2
a589 4
	   if (TRACE)
	       fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
		       c, "'g' or 'l'");
a590 1
	    break;
d602 1
a602 3
	    if (TRACE)
		fprintf(stderr,
		      "HTMIME: Was AL, found L, checking for 'ow:'\n");
d610 1
a610 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was AL, found T, checking for 'ernates:'\n");
d614 1
a614 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a616 1
	    break;
d628 1
a628 3
	    if (TRACE)
		fprintf(stderr,
		     "HTMIME: Was C, found A, checking for 'che-control:'\n");
d634 1
a634 2
	    if (TRACE)
		fprintf(stderr, "HTMIME: Was C, found O, state now CO'\n");
d638 2
a639 4
	   if (TRACE)
	       fprintf(stderr,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
		       c, "'a' or 'o'");
a640 1
	    break;
d650 1
a650 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was CO, found N, state now CON\n");
d658 1
a658 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was CO, found O, checking for 'kie:'\n");
d662 1
a662 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a664 1
	    break;
d676 1
a676 3
	    if (TRACE)
		fprintf(stderr,
		      "HTMIME: Was CON, found N, checking for 'ection:'\n");
d684 1
a684 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was CON, found T, checking for 'ent-'\n");
d688 1
a688 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a690 1
	    break;
d702 1
a702 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was E, found T, checking for 'ag:'\n");
d710 1
a710 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was E, found X, checking for 'pires:'\n");
d714 1
a714 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a716 1
	    break;
d728 1
a728 3
	    if (TRACE)
		fprintf(stderr,
		     "HTMIME: Was L, found A, checking for 'st-modified:'\n");
d736 1
a736 3
	    if (TRACE)
		fprintf(stderr,
		     "HTMIME: Was L, found I, checking for 'nk:'\n");
d744 1
a744 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was L, found O, checking for 'cation:'\n");
d748 1
a748 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a750 1
	    break;
d760 1
a760 2
	    if (TRACE)
		fprintf(stderr, "HTMIME: Was P, found R, state now PR'\n");
d768 1
a768 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was P, found U, checking for 'blic:'\n");
d772 1
a772 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a774 1
	    break;
d786 1
a786 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was PR, found A, checking for 'gma'\n");
d794 1
a794 3
	    if (TRACE)
		fprintf(stderr,
		 "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n");
d798 1
a798 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a800 1
	    break;
d812 1
a812 2
	    if (TRACE)
		fprintf(stderr, "HTMIME: Was S, found A, checking for 'fe:'\n");
d818 1
a818 2
	    if (TRACE)
		fprintf(stderr, "HTMIME: Was S, found E, state now SE'\n");
d822 1
a822 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a824 1
	    break;
d836 1
a836 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was SE, found R, checking for 'ver'\n");
d844 1
a844 3
	    if (TRACE)
		fprintf(stderr,
		 "HTMIME: Was SE, found T, checking for '-cookie'\n");
d848 1
a848 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a850 1
	    break;
d860 1
a860 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was SET_COOKIE, found :, processing\n");
d867 1
a867 3
	    if (TRACE)
		fprintf(stderr,
		 "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n");
d871 1
a871 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a873 1
	    break;
d885 1
a885 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was T, found I, checking for 'tle:'\n");
d893 1
a893 3
	    if (TRACE)
		fprintf(stderr,
		 "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n");
d897 1
a897 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a899 1
	    break;
d911 1
a911 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was U, found P, checking for 'grade:'\n");
d919 1
a919 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was U, found R, checking for 'i:'\n");
d923 1
a923 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a925 1
	    break;
d937 1
a937 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was V, found A, checking for 'ry:'\n");
d945 1
a945 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was V, found I, checking for 'a:'\n");
d949 1
a949 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a951 1
	    break;
d963 1
a963 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was W, found A, checking for 'rning:'\n");
d971 1
a971 3
	    if (TRACE)
		fprintf(stderr,
		  "HTMIME: Was W, found W, checking for 'w-authenticate:'\n");
d975 1
a975 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Bad character `%c' found where `%s' expected\n",
a977 1
	    break;
d987 1
a987 3
	    if (TRACE)
		fprintf(stderr,
		    "HTMIME: Bad character `%c' found where `%s' expected\n",
d994 2
a995 3
	if (TRACE)
	   fprintf (stderr,
		 "HTMIME: in case CONTENT_\n");
d1002 1
a1002 3
	    if (TRACE)
		fprintf(stderr,
		      "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n");
d1010 1
a1010 3
	    if (TRACE)
		fprintf(stderr,
		"HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n");
d1018 1
a1018 3
	    if (TRACE)
		fprintf(stderr,
		  "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n");
d1026 1
a1026 3
	    if (TRACE)
		fprintf(stderr,
		  "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n");
d1032 1
a1032 3
	    if (TRACE)
		fprintf (stderr,
		     "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n");
d1040 1
a1040 3
	    if (TRACE)
		fprintf(stderr,
		      "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n");
d1048 1
a1048 3
	    if (TRACE)
		fprintf(stderr,
		    "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n");
d1054 1
a1054 3
	    if (TRACE)
		fprintf(stderr,
		    "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n");
d1058 1
a1058 3
	    if (TRACE)
		fprintf(stderr,
			"HTMIME: Was CONTENT_, found nothing; bleah\n");
a1059 1
	    break;
d1065 2
a1066 3
      if (TRACE)
	fprintf (stderr,
		 "HTMIME: in case CONTENT_L\n");
d1073 1
a1073 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n");
d1081 1
a1081 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n");
d1089 1
a1089 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n");
d1093 1
a1093 3
	  if (TRACE)
	    fprintf (stderr,
		     "HTMIME: Was CONTENT_L, found nothing; bleah\n");
a1094 1
	    break;
d1100 2
a1101 3
      if (TRACE)
	fprintf (stderr,
		 "HTMIME: in case CONTENT_T\n");
d1108 1
a1108 3
	    if (TRACE)
		fprintf(stderr,
	 "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n");
d1116 1
a1116 3
	    if (TRACE)
		fprintf(stderr,
		   "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n");
d1120 1
a1120 3
	  if (TRACE)
	    fprintf (stderr,
		     "HTMIME: Was CONTENT_T, found nothing; bleah\n");
a1121 1
	    break;
d1188 1
a1188 1
	if (WHITE(c) && c != 32) {			/* End of field */
d1192 1
a1192 1
	    while ((cp >= me->value) && *cp == 32)
d1200 1
a1200 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Accept-Ranges: '%s'\n",
d1205 1
a1205 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Age: '%s'\n",
d1210 1
a1210 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Allow: '%s'\n",
d1215 1
a1215 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Alternates: '%s'\n",
d1220 1
a1220 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Cache-Control: '%s'\n",
d1227 1
a1227 2
		for (i = 0; me->value[i]; i++)
		    me->value[i] = TOLOWER(me->value[i]);
d1272 1
a1272 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Cookie: '%s'\n",
d1277 1
a1277 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Connection: '%s'\n",
d1282 1
a1282 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Base: '%s'\n",
d1293 1
a1293 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Disposition: '%s'\n",
d1343 1
a1343 3
		if (TRACE)
		    fprintf(stderr,
		       "HTMIME: PICKED UP Content-Encoding: '%s'\n",
d1351 1
a1351 2
		for (i = 0; me->value[i]; i++)
		    me->value[i] = TOLOWER(me->value[i]);
d1361 1
a1361 3
		    if (TRACE)
			fprintf(stderr,
				"                Ignoring it!\n");
d1372 1
a1372 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Features: '%s'\n",
d1377 1
a1377 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Language: '%s'\n",
d1384 1
a1384 2
		for (i = 0; me->value[i]; i++)
		    me->value[i] = TOLOWER(me->value[i]);
d1389 1
a1389 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Length: '%s'\n",
d1399 1
a1399 3
		if (TRACE)
		    fprintf(stderr,
			    "        Converted to integer: '%d'\n",
d1404 1
a1404 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Location: '%s'\n",
d1415 1
a1415 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-MD5: '%s'\n",
d1426 1
a1426 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Range: '%s'\n",
d1431 1
a1431 3
		if (TRACE)
		    fprintf(stderr,
			"HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n",
d1439 1
a1439 2
		for (i = 0; me->value[i]; i++)
		    me->value[i] = TOLOWER(me->value[i]);
d1444 1
a1444 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Content-Type: '%s'\n",
d1462 1
a1462 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Date: '%s'\n",
d1472 5
a1476 4
		HTMIME_TrimDoubleQuotes(me->value);
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP ETag: '%s'\n",
d1478 6
d1487 1
a1487 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Expires: '%s'\n",
d1498 1
a1498 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Keep-Alive: '%s'\n",
d1503 1
a1503 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Last-Modified: '%s'\n",
d1514 1
a1514 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Link: '%s'\n",
d1519 1
a1519 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Location: '%s'\n",
d1524 1
a1524 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Pragma: '%s'\n",
d1536 1
a1536 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n",
d1541 1
a1541 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Public: '%s'\n",
d1546 1
a1546 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Retry-After: '%s'\n",
d1551 1
a1551 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Safe: '%s'\n",
d1565 1
a1565 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Server: '%s'\n",
d1576 1
a1576 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Set-Cookie: '%s'\n",
d1587 1
a1587 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Set-Cookie2: '%s'\n",
d1598 1
a1598 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Title: '%s'\n",
d1603 1
a1603 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Transfer-Encoding: '%s'\n",
d1608 1
a1608 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Upgrade: '%s'\n",
d1613 1
a1613 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP URI: '%s'\n",
d1618 1
a1618 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Vary: '%s'\n",
d1623 1
a1623 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Via: '%s'\n",
d1628 1
a1628 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP Warning: '%s'\n",
d1633 1
a1633 3
		if (TRACE)
		    fprintf(stderr,
			    "HTMIME: PICKED UP WWW-Authenticate: '%s'\n",
d1662 1
a1662 2
    if (TRACE)
	fprintf(stderr, "HTMIME: *** Syntax error. (string too long)\n");
d1687 1
a1687 2
	if (TRACE)
	    fprintf(stderr, "HTMIME:  %s\n", s);
d1709 1
a1709 2
	if (TRACE)
	    fprintf(stderr, "HTMIME:  %.*s\n", l, s);
d1786 1
a1870 3
/* #include <stdio.h> */	/* Included via previous headers. - FM */
/* #include <string.h> */	/* Included via previous headers. - FM */

d1881 2
a1882 1
#define ESC	'\033'
a2003 2
			for (p = s+2; *p; p++)
			    *p = TOLOWER(*p);
a2123 55
**  Modified for Lynx-jp by Takuya ASADA (and K&Rized by FM).
*/
#if NOTDEFINED
PUBLIC int main ARGS2(
	int,		ac,
	char **,	av)
{
    FILE *fp;
    char buf[BUFLEN];
    char header = 1, body = 0, r_jis = 0;
    int  i, c;

    for (i = 1; i < ac; i++) {
	if (strcmp(av[i], "-B") == NULL)
	    body = 1;
	else if (strcmp(av[i], "-r") == NULL)
	    r_jis = 1;
	else
	    break;
    }

    if (i >= ac) {
	fp = stdin;
    } else {
	if ((fp = fopen(av[i], "r")) == NULL) {
	    fprintf(stderr, "%s: cannot open %s\n", av[0], av[i]);
	    exit(1);
	}
    }

    while (fgets(buf, BUFLEN, fp)) {
	if (buf[0] == '\n' && buf[1] == '\0')
	    header = 0;
	if (header) {
	    c = fgetc(fp);
	    if (c == ' ' || c == '\t') {
		buf[strlen(buf)-1] = '\0';
		ungetc(c, fp);
	    } else {
		ungetc(c, fp);
	    }
	}
	if (header || body)
	    HTmmdecode(buf, buf);
	if (r_jis)
	    HTrjis(buf, buf);
	fprintf(stdout, "%s", buf);
    }

    close(fp);
    exit(0);
}
#endif /* NOTDEFINED */

/*
a2262 1

@


1.1.1.1
log
@Lynx 2.8
@
text
@@
