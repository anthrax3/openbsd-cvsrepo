head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.48;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTRules.c,v 1.45 2013/11/28 11:14:29 tom Exp $
 *
 *	Configuration manager for Hypertext Daemon		HTRules.c
 *	==========================================
 *
 *
 * History:
 *	 3 Jun 91	Written TBL
 *	10 Aug 91	Authorisation added after Daniel Martin (pass, fail)
 *			Rule order in file changed
 *			Comments allowed with # on 1st char of rule line
 *	17 Jun 92	Bug fix: pass and fail failed if didn't contain '*' TBL
 *	 1 Sep 93	Bug fix: no memory check - Nathan Torkington
 *			BYTE_ADDRESSING removed - Arthur Secret
 *	11 Sep 93  MD	Changed %i into %d in debug printf.
 *			VMS does not recognize %i.
 *			Bug Fix: in case of PASS, only one parameter to printf.
 *	19 Sep 93  AL	Added Access Authorization stuff.
 *	 1 Nov 93  AL	Added htbin.
 *	25 May 99  KW	Added redirect for lynx.
 *
 */

#include <HTUtils.h>

/* (c) CERN WorldWideWeb project 1990,91. See Copyright.html for details */
#include <HTRules.h>

#include <HTFile.h>
#include <LYLeaks.h>
#include <HTAAProt.h>

#define LINE_LENGTH 256

typedef struct _rule {
    struct _rule *next;
    HTRuleOp op;
    char *pattern;
    char *equiv;
    char *condition_op;		/* as strings - may be inefficient, */
    char *condition;		/* but this is not for a server - kw */
} rule;

#ifndef NO_RULES

#include <HTTP.h>		/* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h>	/* for LYUserSpecifiedURL - kw */
#include <LYStrings.h>		/* for LYscanFloat */
#include <LYUtils.h>		/* for LYFixCursesOn - kw */
#include <HTAlert.h>

/*	Global variables
 *	----------------
 */
char *HTBinDir = NULL;		/* Physical /htbin directory path.      */

				/* In future this should not be global. */
char *HTSearchScript = NULL;	/* Search script name.          */

/*	Module-wide variables
 *	---------------------
 */

static rule *rules = 0;		/* Pointer to first on list */

#ifndef PUT_ON_HEAD
static rule *rule_tail = 0;	/* Pointer to last on list */
#endif

/*	Add rule to the list					HTAddRule()
 *	--------------------
 *
 *  On entry,
 *	pattern		points to 0-terminated string containing a single "*"
 *	equiv		points to the equivalent string with * for the
 *			place where the text matched by * goes.
 *  On exit,
 *	returns		0 if success, -1 if error.
 */

int HTAddRule(HTRuleOp op, const char *pattern,
	      const char *equiv,
	      const char *cond_op,
	      const char *cond)
{				/* BYTE_ADDRESSING removed and memory check - AS - 1 Sep 93 */
    rule *temp;
    char *pPattern = NULL;

    temp = typecalloc(rule);
    if (temp == NULL)
	outofmem(__FILE__, "HTAddRule");

    assert(temp != NULL);

    if (equiv) {		/* Two operands */
	char *pEquiv = NULL;

	StrAllocCopy(pEquiv, equiv);
	temp->equiv = pEquiv;
    } else {
	temp->equiv = 0;
    }
    if (cond_op) {
	StrAllocCopy(temp->condition_op, cond_op);
	StrAllocCopy(temp->condition, cond);
    }
    StrAllocCopy(pPattern, pattern);
    temp->pattern = pPattern;
    temp->op = op;

    if (equiv) {
	CTRACE((tfp, "Rule: For `%s' op %d `%s'", pattern, (int) op, equiv));
    } else {
	CTRACE((tfp, "Rule: For `%s' op %d", pattern, (int) op));
    }
    if (cond_op) {
	CTRACE((tfp, "\t%s %s\n", cond_op, NONNULL(cond)));
    } else {
	CTRACE((tfp, "\n"));
    }

    if (!rules) {
#ifdef LY_FIND_LEAKS
	atexit(HTClearRules);
#endif
    }
#ifdef PUT_ON_HEAD
    temp->next = rules;
    rules = temp;
#else
    temp->next = 0;
    if (rule_tail)
	rule_tail->next = temp;
    else
	rules = temp;
    rule_tail = temp;
#endif

    return 0;
}

/*	Clear all rules						HTClearRules()
 *	---------------
 *
 * On exit,
 *	There are no rules
 *
 * See also
 *	HTAddRule()
 */
void HTClearRules(void)
{
    while (rules) {
	rule *temp = rules;

	rules = temp->next;
	FREE(temp->pattern);
	FREE(temp->equiv);
	FREE(temp->condition_op);
	FREE(temp->condition);
	FREE(temp);
    }
#ifndef PUT_ON_HEAD
    rule_tail = 0;
#endif
}

static BOOL rule_cond_ok(rule * r)
{
    BOOL result;

    if (!r->condition_op)
	return YES;
    if (strcmp(r->condition_op, "if") && strcmp(r->condition_op, "unless")) {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s'!\n",
		r->condition_op));
	return NO;
    }
    if (!strcmp(r->condition, "redirected"))
	result = (BOOL) (redirection_attempts > 0);
    else if (!strcmp(r->condition, "userspec"))
	result = LYUserSpecifiedURL;
    else {
	CTRACE((tfp, "....... rule ignored, unrecognized `%s %s'!\n",
		r->condition_op, NONNULL(r->condition)));
	return NO;
    }
    if (!strcmp(r->condition_op, "if"))
	return result;
    else
	return (BOOL) (!result);

}

/*	Translate by rules					HTTranslate()
 *	------------------
 *
 *	The most recently defined rules are applied first.
 *
 * On entry,
 *	required	points to a string whose equivalent value is needed
 * On exit,
 *	returns		the address of the equivalent string allocated from
 *			the heap which the CALLER MUST FREE. If no translation
 *			occurred, then it is a copy of the original.
 * NEW FEATURES:
 *			When a "protect" or "defprot" rule is matched,
 *			a call to HTAA_setCurrentProtection() or
 *			HTAA_setDefaultProtection() is made to notify
 *			the Access Authorization module that the file is
 *			protected, and so it knows how to handle it.
 *								-- AL
 */
char *HTTranslate(const char *required)
{
    rule *r;
    char *current = NULL;
    char *msgtmp = NULL;
    const char *pMsg;
    int proxy_none_flag = 0;
    int permitredir_flag = 0;

    StrAllocCopy(current, required);

    HTAA_clearProtections();	/* Reset from previous call -- AL */

    for (r = rules; r; r = r->next) {
	char *p = r->pattern;
	int m = 0;		/* Number of characters matched against wildcard */
	const char *q = current;

	for (; *p && *q; p++, q++) {	/* Find first mismatch */
	    if (*p != *q)
		break;
	}

	if (*p == '*') {	/* Match up to wildcard */
	    m = (int) strlen(q) - (int) strlen(p + 1);	/* Amount to match to wildcard */
	    if (m < 0)
		continue;	/* tail is too short to match */
	    if (0 != strcmp(q + m, p + 1))
		continue;	/* Tail mismatch */
	} else
	    /* Not wildcard */ if (*p != *q)
	    continue;		/* plain mismatch: go to next rule */

	if (!rule_cond_ok(r))	/* check condition, next rule if false - kw */
	    continue;

	switch (r->op) {	/* Perform operation */

	case HT_DefProt:
	case HT_Protect:
#ifdef ACCESS_AUTH
	    {
		char *local_copy = NULL;
		char *p2;
		char *eff_ids = NULL;
		char *prot_file = NULL;

		CTRACE((tfp, "HTRule: `%s' matched %s %s: `%s'\n",
			current,
			(r->op == HT_Protect ? "Protect" : "DefProt"),
			"rule, setup",
			(r->equiv ? r->equiv :
			 (r->op == HT_Protect ? "DEFAULT" : "NULL!!"))));

		if (r->equiv) {
		    StrAllocCopy(local_copy, r->equiv);
		    p2 = local_copy;
		    prot_file = HTNextField(&p2);
		    eff_ids = HTNextField(&p2);
		}

		if (r->op == HT_Protect)
		    HTAA_setCurrentProtection(current, prot_file, eff_ids);
		else
		    HTAA_setDefaultProtection(current, prot_file, eff_ids);

		FREE(local_copy);

		/* continue translating rules */
	    }
#endif /* ACCESS_AUTH */
	    break;

	case HT_UserMsg:	/* Produce message immediately */
	    LYFixCursesOn("show rule message:");
	    HTUserMsg2((r->equiv ? r->equiv : "Rule: %s"), current);
	    break;
	case HT_InfoMsg:	/* Produce messages immediately */
	case HT_Progress:
	case HT_Alert:
	    LYFixCursesOn("show rule message:");	/* and fall through */
	case HT_AlwaysAlert:
	    pMsg = r->equiv ? r->equiv :
		(r->op == HT_AlwaysAlert) ? "%s" : "Rule: %s";
	    if (StrChr(pMsg, '%')) {
		HTSprintf0(&msgtmp, pMsg, current);
		pMsg = msgtmp;
	    }
	    switch (r->op) {	/* Actually produce message */
	    case HT_InfoMsg:
		HTInfoMsg(pMsg);
		break;
	    case HT_Progress:
		HTProgress(pMsg);
		break;
	    case HT_Alert:
		HTAlert(pMsg);
		break;
	    case HT_AlwaysAlert:
		HTAlwaysAlert("Rule alert:", pMsg);
		break;
	    default:
		break;
	    }
	    FREE(msgtmp);
	    break;

	case HT_PermitRedir:	/* Set special flag */
	    permitredir_flag = 1;
	    CTRACE((tfp, "HTRule: Mark for redirection permitted\n"));
	    break;

	case HT_Pass:		/* Authorised */
	    if (!r->equiv) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
		}
		CTRACE((tfp, "HTRule: Pass `%s'\n", current));
		return current;
	    }
	    /* Else fall through ...to map and pass */

	case HT_Map:
	case HT_Redirect:
	case HT_RedirectPerm:
	    if (*p == *q) {	/* End of both strings, no wildcard */
		CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
		StrAllocCopy(current, r->equiv);	/* use entire translation */
	    } else {
		char *ins = StrChr(r->equiv, '*');	/* Insertion point */

		if (ins) {	/* Consistent rule!!! */
		    char *temp = NULL;

		    HTSprintf0(&temp, "%.*s%.*s%s",
			       (int) (ins - r->equiv),
			       r->equiv,
			       m,
			       q,
			       ins + 1);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */

		} else {	/* No insertion point */
		    char *temp = NULL;

		    StrAllocCopy(temp, r->equiv);
		    CTRACE((tfp, "For `%s' using `%s'\n",
			    current, temp));
		    FREE(current);
		    current = temp;	/* Use this */
		}		/* If no insertion point exists */
	    }
	    if (r->op == HT_Pass) {
		if (proxy_none_flag) {
		    char *temp = NULL;

		    StrAllocCopy(temp, "NoProxy=");
		    StrAllocCat(temp, current);
		    FREE(current);
		    current = temp;
		}
		CTRACE((tfp, "HTRule: ...and pass `%s'\n",
			current));
		return current;
	    } else if (r->op == HT_Redirect) {
		CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
			current));
		redirecting_url = current;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    } else if (r->op == HT_RedirectPerm) {
		CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
			current));
		redirecting_url = current;
		permanent_redirection = TRUE;
		HTPermitRedir = (BOOL) (permitredir_flag == 1);
		return (char *) 0;
	    }
	    break;

	case HT_UseProxy:
	    if (r->equiv && 0 == strcasecomp(r->equiv, "none")) {
		CTRACE((tfp, "For `%s' will not use proxy\n", current));
		proxy_none_flag = 1;
	    } else if (proxy_none_flag) {
		CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			current,
			NONNULL(r->equiv)));
	    } else {
		char *temp = NULL;

		StrAllocCopy(temp, "Proxied=");
		StrAllocCat(temp, r->equiv);
		StrAllocCat(temp, current);
		CTRACE((tfp, "HTRule: proxy server found: %s\n",
			NONNULL(r->equiv)));
		FREE(current);
		return temp;
	    }
	    break;

	case HT_Invalid:
	case HT_Fail:		/* Unauthorised */
	    CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
	    FREE(current);
	    return (char *) 0;
	}			/* if tail matches ... switch operation */

    }				/* loop over rules */

    if (proxy_none_flag) {
	char *temp = NULL;

	StrAllocCopy(temp, "NoProxy=");
	StrAllocCat(temp, current);
	FREE(current);
	return temp;
    }

    return current;
}

/*	Load one line of configuration
 *	------------------------------
 *
 *	Call this, for example, to load a X resource with config info.
 *
 * returns	0 OK, < 0 syntax error.
 */
int HTSetConfiguration(char *config)
{
    HTRuleOp op;
    char *line = NULL;
    char *pointer = NULL;
    char *word1;
    const char *word2;
    const char *word3;
    const char *cond_op = NULL;
    const char *cond = NULL;
    float quality, secs, secs_per_byte;
    long maxbytes;
    int status;

    StrAllocCopy(line, config);
    if (line != NULL) {
	char *p = line;

	/* Chop off comments */
	while ((p = StrChr(p, '#'))) {
	    if (p == line || isspace(UCH(*(p - 1)))) {
		*p = 0;
		break;
	    } else {
		p++;
	    }
	}
    }
    pointer = line;
    word1 = HTNextField(&pointer);
    if (!word1) {
	FREE(line);
	return 0;
    };				/* Comment only or blank */

    word2 = HTNextField(&pointer);

    if (0 == strcasecomp(word1, "defprot") ||
	0 == strcasecomp(word1, "protect"))
	word3 = pointer;	/* The rest of the line to be parsed by AA module */
    else
	word3 = HTNextField(&pointer);	/* Just the next word */

    if (!word2) {
	fprintf(stderr, "HTRule: %s %s\n", RULE_NEEDS_DATA, line);
	FREE(line);
	return -2;		/*syntax error */
    }

    if (0 == strcasecomp(word1, "suffix")) {
	char *encoding = HTNextField(&pointer);

	status = 0;
	if (pointer)
	    status = LYscanFloat(pointer, &quality);

	HTSetSuffix(word2, word3,
		    encoding ? encoding : "binary",
		    status >= 1 ? quality : (float) 1.0);

    } else if (0 == strcasecomp(word1, "presentation")) {
	status = 0;
	if (pointer) {
	    const char *temp = pointer;

	    if (LYscanFloat2(&temp, &quality)) {
		status = 1;
		if (LYscanFloat2(&temp, &secs)) {
		    status = 2;
		    if (LYscanFloat2(&temp, &secs_per_byte)) {
			status = 3;
			if (sscanf(temp, "%ld", &maxbytes)) {
			    status = 4;
			}
		    }
		}
	    }
	}

	HTSetPresentation(word2, word3, NULL,
			  status >= 1 ? quality : 1.0,
			  status >= 2 ? secs : 0.0,
			  status >= 3 ? secs_per_byte : 0.0,
			  status >= 4 ? maxbytes : 0,
			  mediaCFG);

    } else if (0 == strncasecomp(word1, "htbin", 5) ||
	       0 == strncasecomp(word1, "bindir", 6)) {
	StrAllocCopy(HTBinDir, word2);	/* Physical /htbin location */

    } else if (0 == strncasecomp(word1, "search", 6)) {
	StrAllocCopy(HTSearchScript, word2);	/* Search script name */

    } else {
	op = 0 == strcasecomp(word1, "map") ? HT_Map
	    : 0 == strcasecomp(word1, "pass") ? HT_Pass
	    : 0 == strcasecomp(word1, "fail") ? HT_Fail
	    : 0 == strcasecomp(word1, "redirect") ? HT_Redirect
	    : 0 == strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    : 0 == strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    : 0 == strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    : 0 == strcasecomp(word1, "useproxy") ? HT_UseProxy
	    : 0 == strcasecomp(word1, "alert") ? HT_Alert
	    : 0 == strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    : 0 == strcasecomp(word1, "progress") ? HT_Progress
	    : 0 == strcasecomp(word1, "usermsg") ? HT_UserMsg
	    : 0 == strcasecomp(word1, "infomsg") ? HT_InfoMsg
	    : 0 == strcasecomp(word1, "defprot") ? HT_DefProt
	    : 0 == strcasecomp(word1, "protect") ? HT_Protect
	    : HT_Invalid;
	if (op == HT_Invalid) {
	    fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
	} else {
	    switch (op) {
	    case HT_Fail:	/* never a or other 2nd parameter */
	    case HT_PermitRedir:
		cond_op = word3;
		if (cond_op && *cond_op) {
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		}
		break;

	    case HT_Pass:	/* possibly a URL2 */
		if (word3 && (!strcasecomp(word3, "if") ||
			      !strcasecomp(word3, "unless"))) {
		    cond_op = word3;
		    word3 = NULL;
		    cond = HTNextField(&pointer);
		    break;
		}
		/* else fall through */
	    case HT_Map:	/* always a URL2 (or other 2nd parameter) */
	    case HT_Redirect:
	    case HT_RedirectPerm:
	    case HT_UseProxy:
		cond_op = HTNextField(&pointer);
		/* check for extra status word in "Redirect" */
		if (op == HT_Redirect && 0 == strcasecomp(word1, "redirect") &&
		    cond_op &&
		    strcasecomp(cond_op, "if") &&
		    strcasecomp(cond_op, "unless")) {
		    if (0 == strcmp(word2, "301") ||
			0 == strcasecomp(word2, "permanent")) {
			op = HT_RedirectPerm;
		    } else if (!(0 == strcmp(word2, "302") ||
				 0 == strcmp(word2, "303") ||
				 0 == strcasecomp(word2, "temp") ||
				 0 == strcasecomp(word2, "seeother"))) {
			CTRACE((tfp, "Rule: Ignoring `%s' in Redirect\n", word2));
		    }
		    word2 = word3;
		    word3 = cond_op;	/* cond_op isn't condition op after all */
		    cond_op = HTNextField(&pointer);
		}
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		break;

	    case HT_Progress:
	    case HT_InfoMsg:
	    case HT_UserMsg:
	    case HT_Alert:
	    case HT_AlwaysAlert:
		cond_op = HTNextField(&pointer);
		if (cond_op && *cond_op)
		    cond = HTNextField(&pointer);
		if (word3) {	/* Fix string with too may %s - kw */
		    const char *cp = word3;
		    char *cp1, *cp2;

		    while ((cp1 = StrChr(cp, '%'))) {
			if (cp1[1] == '\0') {
			    *cp1 = '\0';
			    break;
			} else if (cp1[1] == '%') {
			    cp = cp1 + 2;
			    continue;
			} else
			    while ((cp2 = StrChr(cp1 + 2, '%'))) {
				if (cp2[1] == '\0') {
				    *cp2 = '\0';
				    break;
				} else if (cp2[1] == '%') {
				    cp1 = cp2;
				} else {
				    *cp2 = '?';		/* replace bad % */
				    cp1 = cp2;
				}
			    }
			break;
		    }
		}
		break;

	    default:
		break;
	    }
	    if (cond_op && cond && *cond && !strcasecomp(cond_op, "unless")) {
		cond_op = "unless";
	    } else if (cond_op && cond && *cond &&
		       !strcasecomp(cond_op, "if")) {
		cond_op = "if";
	    } else if (cond_op || cond) {
		fprintf(stderr, "HTRule: %s '%s'\n", RULE_INCORRECT, config);
		FREE(line);	/* syntax error, condition is a mess - kw */
		return -2;	/* NB unrecognized cond passes here - kw */
	    }
	    if (cond && !strncasecomp(cond, "redirected", (int) strlen(cond))) {
		cond = "redirected";	/* recognized, canonical case - kw */
	    } else if (cond && strlen(cond) >= 8 &&
		       !strncasecomp(cond, "userspecified", (int) strlen(cond))) {
		cond = "userspec";	/* also allow abbreviation - kw */
	    }
	    HTAddRule(op, word2, word3, cond_op, cond);
	}
    }
    FREE(line);
    return 0;
}

/*	Load the rules from a file				HTLoadRules()
 *	--------------------------
 *
 * On entry,
 *	Rules can be in any state
 * On exit,
 *	Any existing rules will have been kept.
 *	Any new rules will have been loaded.
 *	Returns		0 if no error, 0 if error!
 *
 * Bugs:
 *	The strings may not contain spaces.
 */

int HTLoadRules(const char *filename)
{
    FILE *fp = fopen(filename, TXT_R);
    char line[LINE_LENGTH + 1];

    if (!fp) {
	CTRACE((tfp, "HTRules: Can't open rules file %s\n", filename));
	return -1;		/* File open error */
    }
    for (;;) {
	if (!fgets(line, LINE_LENGTH + 1, fp))
	    break;		/* EOF or error */
	(void) HTSetConfiguration(line);
    }
    fclose(fp);
    return 0;			/* No error or syntax errors ignored */
}

#endif /* NO_RULES */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTRules.c,v 1.38 2009/02/01 21:19:02 tom Exp $
d93 3
d239 1
a239 1
	    m = strlen(q) - strlen(p + 1);	/* Amount to match to wildcard */
a252 1
#ifdef ACCESS_AUTH
d255 1
d285 1
a286 1
#endif /* ACCESS_AUTH */
d299 1
a299 1
	    if (strchr(pMsg, '%')) {
d349 1
a349 1
		char *ins = strchr(r->equiv, '*');	/* Insertion point */
d456 1
a456 1
    char *pointer = line;
d467 2
a468 2
    {
	char *p = strchr(line, '#');	/* Chop off comments */
d470 9
a478 2
	if (p)
	    *p = 0;
d623 1
a623 1
		    while ((cp1 = strchr(cp, '%'))) {
d631 1
a631 1
			    while ((cp2 = strchr(cp1 + 2, '%'))) {
d660 1
a660 1
	    if (cond && !strncasecomp(cond, "redirected", strlen(cond))) {
d663 1
a663 1
		       !strncasecomp(cond, "userspecified", strlen(cond))) {
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*	Configuration manager for Hypertext Daemon		HTRules.c
d49 1
d110 1
a110 1
	CTRACE((tfp, "Rule: For `%s' op %d `%s'", pattern, op, equiv));
d112 1
a112 1
	CTRACE((tfp, "Rule: For `%s' op %d", pattern, op));
d460 1
a460 1
    int maxbytes;
d494 1
d496 2
a497 3
	    status = sscanf(pointer, "%f", &quality);
	else
	    status = 0;
d503 18
a520 5
	if (pointer)
	    status = sscanf(pointer, "%f%f%f%d",
			    &quality, &secs, &secs_per_byte, &maxbytes);
	else
	    status = 0;
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 19
a20 19
**	==========================================
**
**
** History:
**	 3 Jun 91	Written TBL
**	10 Aug 91	Authorisation added after Daniel Martin (pass, fail)
**			Rule order in file changed
**			Comments allowed with # on 1st char of rule line
**	17 Jun 92	Bug fix: pass and fail failed if didn't contain '*' TBL
**	 1 Sep 93	Bug fix: no memory check - Nathan Torkington
**			BYTE_ADDRESSING removed - Arthur Secret
**	11 Sep 93  MD	Changed %i into %d in debug printf.
**			VMS does not recognize %i.
**			Bug Fix: in case of PASS, only one parameter to printf.
**	19 Sep 93  AL	Added Access Authorization stuff.
**	 1 Nov 93  AL	Added htbin.
**	25 May 99  KW	Added redirect for lynx.
**
*/
a32 1

d34 6
a39 6
	struct _rule *	next;
	HTRuleOp	op;
	char *		pattern;
	char *		equiv;
	char *		condition_op; /* as strings - may be inefficient, */
	char *		condition;    /* but this is not for a server - kw */
d44 2
a45 2
#include <HTTP.h> /* for redirecting_url, indirectly HTPermitRedir - kw */
#include <LYGlobalDefs.h> /* for LYUserSpecifiedURL - kw */
d50 4
a53 3
**	----------------
*/
PUBLIC char *HTBinDir = NULL;	/* Physical /htbin directory path.	*/
d55 1
a55 1
PUBLIC char *HTSearchScript = NULL;	/* Search script name.		*/
d57 3
d61 1
a61 3
/*	Module-wide variables
**	---------------------
*/
a62 1
PRIVATE rule * rules = 0;	/* Pointer to first on list */
d64 1
a64 1
PRIVATE rule * rule_tail = 0;	/* Pointer to last on list */
a66 1

d68 17
a84 19
**	--------------------
**
**  On entry,
**	pattern		points to 0-terminated string containing a single "*"
**	equiv		points to the equivalent string with * for the
**			place where the text matched by * goes.
**  On exit,
**	returns		0 if success, -1 if error.
*/

PUBLIC int HTAddRule ARGS5(
    HTRuleOp,		op,
    CONST char *,	pattern,
    CONST char *,	equiv,
    CONST char *,	cond_op,
    CONST char *,	cond)
{ /* BYTE_ADDRESSING removed and memory check - AS - 1 Sep 93 */
    rule *	temp;
    char *	pPattern = NULL;
d87 1
a87 1
    if (temp==NULL)
d90 2
a91 1
	char *	pEquiv = NULL;
d126 4
a129 2
    if (rule_tail) rule_tail->next = temp;
    else rules = temp;
a132 1

a135 1

d137 9
a145 9
**	---------------
**
** On exit,
**	There are no rules
**
** See also
**	HTAddRule()
*/
void HTClearRules NOARGS
d148 2
a149 1
	rule * temp = rules;
d162 1
a162 2
PRIVATE BOOL rule_cond_ok ARGS1(
    rule *,	 r)
d165 1
d170 1
a170 1
	       r->condition_op));
d179 1
a179 1
	       r->condition_op, NONNULL(r->condition)));
d188 1
d190 19
a208 20
**	------------------
**
**	The most recently defined rules are applied first.
**
** On entry,
**	required	points to a string whose equivalent value is needed
** On exit,
**	returns		the address of the equivalent string allocated from
**			the heap which the CALLER MUST FREE. If no translation
**			occurred, then it is a copy of the original.
** NEW FEATURES:
**			When a "protect" or "defprot" rule is matched,
**			a call to HTAA_setCurrentProtection() or
**			HTAA_setDefaultProtection() is made to notify
**			the Access Authorization module that the file is
**			protected, and so it knows how to handle it.
**								-- AL
*/
char * HTTranslate ARGS1(
    CONST char *,	required)
d210 1
a210 1
    rule * r;
d212 2
a213 1
    char *msgtmp = NULL, *pMsg;
d221 8
a228 6
    for(r = rules; r; r = r->next) {
	char * p = r->pattern;
	int m=0;   /* Number of characters matched against wildcard */
	CONST char * q = current;
	for(;*p && *q; p++, q++) {   /* Find first mismatch */
	    if (*p!=*q) break;
d231 9
a239 6
	if (*p == '*') {		/* Match up to wildcard */
	    m = strlen(q) - strlen(p+1); /* Amount to match to wildcard */
	    if(m<0) continue;		/* tail is too short to match */
	    if (0!=strcmp(q+m, p+1)) continue;	/* Tail mismatch */
	} else				/* Not wildcard */
	    if (*p != *q) continue;	/* plain mismatch: go to next rule */
d244 1
a244 1
	switch (r->op) {		/* Perform operation */
d256 5
a260 5
			    current,
			    (r->op==HT_Protect ? "Protect" : "DefProt"),
			    "rule, setup",
			    (r->equiv ? r->equiv :
			     (r->op==HT_Protect ?"DEFAULT" :"NULL!!"))));
d281 1
a281 1
	case HT_UserMsg:		/* Produce message immediately */
d285 1
a285 1
	case HT_InfoMsg:		/* Produce messages immediately */
d288 1
a288 1
	    LYFixCursesOn("show rule message:"); /* and fall through */
d291 1
a291 1
		(r->op==HT_AlwaysAlert) ? "%s" : "Rule: %s";
d296 15
a310 6
	    switch (r->op) {		/* Actually produce message */
	    case HT_InfoMsg:	HTInfoMsg(pMsg);	break;
	    case HT_Progress:	HTProgress(pMsg);	break;
	    case HT_Alert:	HTAlert(pMsg);		break;
	    case HT_AlwaysAlert: HTAlwaysAlert("Rule alert:", pMsg);	break;
	    default: break;
d315 1
a315 1
	case HT_PermitRedir:			/* Set special flag */
d320 1
a320 1
	case HT_Pass:				/* Authorised */
d323 2
a324 1
		    char * temp = NULL;
d338 3
a340 3
	    if (*p == *q) { /* End of both strings, no wildcard */
		  CTRACE((tfp, "For `%s' using `%s'\n", current, r->equiv));
		  StrAllocCopy(current, r->equiv); /* use entire translation */
d342 29
a370 51
		  char * ins = strchr(r->equiv, '*');	/* Insertion point */
		  if (ins) {	/* Consistent rule!!! */
			char * temp = NULL;

			HTSprintf0(&temp, "%.*s%.*s%s",
				   ins - r->equiv,
				   r->equiv,
				   m,
				   q,
				   ins + 1);
			CTRACE((tfp, "For `%s' using `%s'\n",
				    current, temp));
			FREE(current);
			current = temp;			/* Use this */

		    } else {	/* No insertion point */
			char * temp = NULL;

			StrAllocCopy(temp, r->equiv);
			CTRACE((tfp, "For `%s' using `%s'\n",
						current, temp));
			FREE(current);
			current = temp;			/* Use this */
		    } /* If no insertion point exists */
		}
		if (r->op == HT_Pass) {
		    if (proxy_none_flag) {
			char * temp = NULL;
			StrAllocCopy(temp, "NoProxy=");
			StrAllocCat(temp, current);
			FREE(current);
			current = temp;
		    }
		    CTRACE((tfp, "HTRule: ...and pass `%s'\n",
				current));
		    return current;
		} else if (r->op == HT_Redirect) {
		    CTRACE((tfp, "HTRule: ...and redirect to `%s'\n",
				current));
		    redirecting_url = current;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		} else if (r->op == HT_RedirectPerm) {
		    CTRACE((tfp, "HTRule: ...and redirect like 301 to `%s'\n",
				current));
		    redirecting_url = current;
		    permanent_redirection = TRUE;
		    HTPermitRedir = (BOOL) (permitredir_flag == 1);
		    return (char *)0;
		}
		break;
d372 1
a372 12
	case HT_UseProxy:
		if (r->equiv && 0==strcasecomp(r->equiv, "none")) {
		    CTRACE((tfp, "For `%s' will not use proxy\n", current));
		    proxy_none_flag = 1;
		} else if (proxy_none_flag) {
		    CTRACE((tfp, "For `%s' proxy server ignored: %s\n",
			   current,
			   NONNULL(r->equiv)));
		} else {
		    char * temp = NULL;
		    StrAllocCopy(temp, "Proxied=");
		    StrAllocCat(temp, r->equiv);
a373 2
		    CTRACE((tfp, "HTRule: proxy server found: %s\n",
			   NONNULL(r->equiv)));
d375 1
a375 1
		    return temp;
d377 39
a415 1
		break;
d418 5
a422 5
	case HT_Fail:				/* Unauthorised */
		CTRACE((tfp, "HTRule: *** FAIL `%s'\n", current));
		FREE(current);
		return (char *)0;
	} /* if tail matches ... switch operation */
d424 1
a424 1
    } /* loop over rules */
d427 2
a428 1
	char * temp = NULL;
d439 7
a445 8
**	------------------------------
**
**	Call this, for example, to load a X resource with config info.
**
** returns	0 OK, < 0 syntax error.
*/
PUBLIC int  HTSetConfiguration ARGS1(
    char *,		config)
d448 7
a454 4
    char * line = NULL;
    char * pointer = line;
    char *word1, *word2, *word3;
    char *cond_op=NULL, *cond=NULL;
d461 4
a464 2
	char * p = strchr(line, '#');	/* Chop off comments */
	if (p) *p = 0;
d471 1
a471 1
    } ; /* Comment only or blank */
d475 3
a477 3
    if (0==strcasecomp(word1, "defprot") ||
	0==strcasecomp(word1, "protect"))
	word3 = pointer;  /* The rest of the line to be parsed by AA module */
d484 1
a484 1
	return -2;	/*syntax error */
d487 2
a488 7
    if (0==strcasecomp(word1, "suffix")) {
	char * encoding = HTNextField(&pointer);
	if (pointer) status = sscanf(pointer, "%f", &quality);
	else status = 0;
	HTSetSuffix(word2,	word3,
				encoding ? encoding : "binary",
				status >= 1? quality : (float) 1.0);
d490 11
a500 2
    } else if (0==strcasecomp(word1, "presentation")) {
	if (pointer) status = sscanf(pointer, "%f%f%f%d",
d502 8
a509 6
	else status = 0;
	HTSetPresentation(word2, word3,
		    status >= 1 ? quality		: 1.0,
		    status >= 2 ? secs			: 0.0,
		    status >= 3 ? secs_per_byte		: 0.0,
		    status >= 4 ? maxbytes		: 0 );
d511 2
a512 2
    } else if (0==strncasecomp(word1, "htbin", 5) ||
	       0==strncasecomp(word1, "bindir", 6)) {
d515 1
a515 1
    } else if (0==strncasecomp(word1, "search", 6)) {
d519 17
a535 17
	op =	0==strcasecomp(word1, "map")  ? HT_Map
	    :	0==strcasecomp(word1, "pass") ? HT_Pass
	    :	0==strcasecomp(word1, "fail") ? HT_Fail
	    :	0==strcasecomp(word1, "redirect") ? HT_Redirect
	    :	0==strncasecomp(word1, "redirectperm", 12) ? HT_RedirectPerm
	    :	0==strcasecomp(word1, "redirecttemp") ? HT_Redirect
	    :	0==strcasecomp(word1, "permitredirection") ? HT_PermitRedir
	    :	0==strcasecomp(word1, "useproxy") ? HT_UseProxy
	    :	0==strcasecomp(word1, "alert") ? HT_Alert
	    :	0==strcasecomp(word1, "alwaysalert") ? HT_AlwaysAlert
	    :	0==strcasecomp(word1, "progress") ? HT_Progress
	    :	0==strcasecomp(word1, "usermsg") ? HT_UserMsg
	    :	0==strcasecomp(word1, "infomsg") ? HT_InfoMsg
	    :	0==strcasecomp(word1, "defprot") ? HT_DefProt
	    :	0==strcasecomp(word1, "protect") ? HT_Protect
	    :						HT_Invalid;
	if (op==HT_Invalid) {
d555 2
a556 2
		} /* else fall through */

d563 1
a563 1
		if (op==HT_Redirect && 0==strcasecomp(word1, "redirect") &&
d567 2
a568 2
		    if (0==strcmp(word2, "301") ||
			0==strcasecomp(word2, "permanent")) {
d570 4
a573 4
		    } else if (!(0==strcmp(word2, "302") ||
				 0==strcmp(word2, "303") ||
				 0==strcasecomp(word2, "temp") ||
				 0==strcasecomp(word2, "seeother"))) {
d577 1
a577 1
		    word3 = cond_op; /* cond_op isn't condition op after all */
d593 4
a596 2
		    char *cp = word3, *cp1, *cp2;
		    while ((cp1=strchr(cp, '%'))) {
d603 11
a613 9
			} else while ((cp2=strchr(cp1+2, '%'))) {
			    if (cp2[1] == '\0') {
				*cp2 = '\0';
				break;
			    } else if (cp2[1] == '%') {
				cp1 = cp2;
			    } else {
				*cp2 = '?'; /* replace bad % */
				cp1 = cp2;
a614 1
			}
d620 1
a620 1
		default:
d634 1
a634 1
		cond = "redirected"; /* recognized, canonical case - kw */
d636 2
a637 2
		!strncasecomp(cond, "userspecified", strlen(cond))) {
		cond = "userspec"; /* also allow abbreviation - kw */
a645 1

d647 12
a658 12
**	--------------------------
**
** On entry,
**	Rules can be in any state
** On exit,
**	Any existing rules will have been kept.
**	Any new rules will have been loaded.
**	Returns		0 if no error, 0 if error!
**
** Bugs:
**	The strings may not contain spaces.
*/
d660 1
a660 2
int HTLoadRules ARGS1(
    CONST char *,	filename)
d662 2
a663 2
    FILE * fp = fopen(filename, TXT_R);
    char line[LINE_LENGTH+1];
d667 1
a667 1
	return -1; /* File open error */
d669 3
a671 2
    for(;;) {
	if (!fgets(line, LINE_LENGTH+1, fp)) break;	/* EOF or error */
d675 1
a675 1
    return 0;		/* No error or syntax errors ignored */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d195 1
a195 1
**	required	points to a string whose equivalent value is neeed
d199 1
a199 1
**			occured, then it is a copy of te original.
d201 1
a201 1
**			When a "protect" or "defprot" rule is mathed,
d216 1
d401 1
a401 2
		CTRACE((tfp, "HTRule: *** FAIL `%s'\n",
			    current));
d412 1
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d18 1
d39 2
d45 5
d72 1
a72 1
**	pattern 	points to 0-terminated string containing a single "*"
d76 1
a76 1
**	returns 	0 if success, -1 if error.
d79 1
a79 1
PUBLIC int HTAddRule ARGS3(
d82 3
a84 1
    CONST char *,	equiv)
d87 1
a87 1
    char *	pPattern;
d89 1
a89 1
    temp = (rule *)malloc(sizeof(*temp));
a91 3
    pPattern = (char *)malloc(strlen(pattern)+1);
    if (pPattern==NULL)
	outofmem(__FILE__, "HTAddRule");
d93 2
a94 3
	char *	pEquiv = (char *)malloc(strlen(equiv)+1);
	if (pEquiv==NULL)
	    outofmem(__FILE__, "HTAddRule");
a95 1
	strcpy(pEquiv, equiv);
d99 5
a106 1
    strcpy(pPattern, pattern);
d108 6
a113 1
	CTRACE(tfp, "Rule: For `%s' op %d `%s'\n", pattern, op, equiv);
d115 1
a115 1
	CTRACE(tfp, "Rule: For `%s' op %d\n", pattern, op);
d138 1
a138 1
/*	Clear all rules 					HTClearRules()
d154 2
d163 24
d188 1
d197 1
a197 1
**	returns 	the address of the equivalent string allocated from
d213 3
d235 3
d249 1
a249 1
		CTRACE(tfp, "HTRule: `%s' matched %s %s: `%s'\n",
d254 1
a254 1
			     (r->op==HT_Protect ?"DEFAULT" :"NULL!!")));
d275 30
d306 7
a312 3
		if (!r->equiv) {
		    CTRACE(tfp, "HTRule: Pass `%s'\n", current);
		    return current;
d314 4
a317 1
		/* Else fall through ...to map and pass */
d320 2
d323 1
a323 1
		  CTRACE(tfp, "For `%s' using `%s'\n", current, r->equiv);
d328 10
a337 10
			char * temp = (char *)malloc(
				strlen(r->equiv)-1 + m + 1);
			if (temp==NULL)
			    outofmem(__FILE__, "HTTranslate"); /* NT & AS */
			strncpy(temp,	r->equiv, ins-r->equiv);
			/* Note: temp may be unterminated now! */
			strncpy(temp+(ins-r->equiv), q, m);  /* Matched bit */
			strcpy (temp+(ins-r->equiv)+m, ins+1);	/* Last bit */
			CTRACE(tfp, "For `%s' using `%s'\n",
				    current, temp);
d339 1
a339 1
			current = temp; 		/* Use this */
d342 5
a346 6
			char * temp = (char *)malloc(strlen(r->equiv)+1);
			if (temp==NULL)
			    outofmem(__FILE__, "HTTranslate"); /* NT & AS */
			strcpy(temp, r->equiv);
			CTRACE(tfp, "For `%s' using `%s'\n",
						current, temp);
d348 1
a348 1
			current = temp; 		/* Use this */
d352 9
a360 2
		    CTRACE(tfp, "HTRule: ...and pass `%s'\n",
				current);
d362 33
d400 2
a401 2
		CTRACE(tfp, "HTRule: *** FAIL `%s'\n",
			    current);
d408 6
d432 1
d469 1
a469 1
				status >= 1? quality : 1.0);
d476 1
a476 1
		    status >= 1? quality		: 1.0,
d478 1
a478 1
		    status >= 3 ? secs_per_byte 	: 0.0,
d492 10
d508 99
a606 1
	    HTAddRule(op, word2, word3);
d622 1
a622 1
**	Returns 	0 if no error, 0 if error!
d631 1
a631 1
    FILE * fp = fopen(filename, "r");
d635 1
a635 1
	CTRACE(tfp, "HTRules: Can't open rules file %s\n", filename);
@


1.1
log
@Initial revision
@
text
@d10 4
a13 4
**      17 Jun 92       Bug fix: pass and fail failed if didn't contain '*' TBL
**       1 Sep 93       Bug fix: no memory check - Nathan Torkington
**                      BYTE_ADDRESSING removed - Arthur Secret
**	11 Sep 93  MD	Changed %i into %d in debug printf. 
d21 2
d24 1
a24 7
#include "HTRules.h"

#include "HTUtils.h"
#include "tcp.h"
/*#include <stdio.h> included by HTUtils.h -- FM */
#include "HTFile.h"
#include "HTAAServ.h"	/* Access Authorization */
d26 3
a28 1
#include "LYLeaks.h"
d40 2
d46 1
a46 1
                                /* In future this should not be global.	*/
d64 1
a64 1
**	pattern		points to 0-terminated string containing a single "*"
d68 1
a68 1
**	returns		0 if success, -1 if error.
d71 4
a74 8
#ifdef __STDC__
PUBLIC int HTAddRule (HTRuleOp op, const char * pattern, const char * equiv)
#else
int HTAddRule(op, pattern, equiv)
    HTRuleOp	op;
    char *	pattern;
    char *	equiv;
#endif
d76 2
a77 2
    rule *      temp;
    char *      pPattern;
d80 2
a81 2
    if (temp==NULL) 
	outofmem(__FILE__, "HTAddRule"); 
d83 2
a84 2
    if (pPattern==NULL) 
	outofmem(__FILE__, "HTAddRule"); 
d87 4
a90 4
	if (pEquiv==NULL) 
	    outofmem(__FILE__, "HTAddRule"); 
        temp->equiv = pEquiv;
        strcpy(pEquiv, equiv);
d92 1
a92 1
        temp->equiv = 0;
d98 4
a101 5
    if (TRACE) {
       if (equiv)
          fprintf(stderr, "Rule: For `%s' op %d `%s'\n", pattern, op, equiv);
       else
          fprintf(stderr, "Rule: For `%s' op %d\n", pattern, op);
d104 5
d119 1
a119 1
        
d124 1
a124 1
/*	Clear all rules						HTClearRules()
a128 1
**	returns		0 if success, -1 if error.
d133 1
a133 5
#ifdef __STDC__
int HTClearRules(void)
#else
int HTClearRules()
#endif
d136 1
a136 1
    	rule * temp = rules;
a144 2

    return 0;
d156 1
a156 1
**	returns		the address of the equivalent string allocated from
d167 2
a168 6
#ifdef __STDC__
char * HTTranslate(const char * required)
#else
char * HTTranslate(required)
	char * required;
#endif
d177 1
a177 1
        char * p = r->pattern;
d186 1
a186 1
	    if(m<0) continue;           /* tail is too short to match */
d188 1
a188 1
	} else 				/* Not wildcard */
d202 6
a207 7
		if (TRACE) fprintf(stderr,
				   "HTRule: `%s' matched %s %s: `%s'\n",
				   current,
				   (r->op==HT_Protect ? "Protect" : "DefProt"),
				   "rule, setup",
				   (r->equiv ? r->equiv :
				    (r->op==HT_Protect ?"DEFAULT" :"NULL!!")));
d229 2
a230 2
    		if (!r->equiv) {
		    if (TRACE) fprintf(stderr, "HTRule: Pass `%s'\n", current);
d232 1
a232 1
	        }
d234 1
a234 1
		
d237 2
a238 3
    	          if (TRACE) fprintf(stderr,
			       "For `%s' using `%s'\n", current, r->equiv);  
	          StrAllocCopy(current, r->equiv); /* use entire translation */
d241 1
a241 1
	          if (ins) {	/* Consistent rule!!! */
d244 1
a244 1
			if (temp==NULL) 
d246 1
a246 1
			strncpy(temp, 	r->equiv, ins-r->equiv);
d250 2
a251 2
    			if (TRACE) fprintf(stderr, "For `%s' using `%s'\n",
						current, temp);
d253 1
a253 1
			current = temp;			/* Use this */
d257 1
a257 1
			if (temp==NULL) 
d260 1
a260 1
    			if (TRACE) fprintf(stderr, "For `%s' using `%s'\n",
d263 1
a263 1
			current = temp;			/* Use this */
d267 2
a268 2
		    if (TRACE) fprintf(stderr, "HTRule: ...and pass `%s'\n",
		    		       current);
d275 4
a278 4
    		    if (TRACE) fprintf(stderr, "HTRule: *** FAIL `%s'\n",
		    		       current);
		    return (char *)0;
		    		    
d294 2
a295 1
PUBLIC int  HTSetConfiguration ARGS1(CONST char *, config)
d304 1
a304 1
    
d313 1
a313 1
    	FREE(line);
d315 1
a315 1
    } ;	/* Comment only or blank */
d326 1
a326 1
	fprintf(stderr, "HTRule: Insufficient operands: %s\n", line);
d332 1
a332 1
        char * encoding = HTNextField(&pointer);
d340 1
a340 1
        if (pointer) status = sscanf(pointer, "%f%f%f%d",
d342 1
a342 1
        else status = 0;
d344 2
a345 2
		    status >= 1? quality 		: 1.0,
		    status >= 2 ? secs 			: 0.0,
d357 4
a360 4
	op =	0==strcasecomp(word1, "map")  ?	HT_Map
	    :	0==strcasecomp(word1, "pass") ?	HT_Pass
	    :	0==strcasecomp(word1, "fail") ?	HT_Fail
	    :   0==strcasecomp(word1, "defprot") ? HT_DefProt
d364 2
a365 2
	    fprintf(stderr, "HTRule: Bad rule `%s'\n", config);
	} else {  
d367 1
a367 1
	} 
d382 1
a382 1
**	Returns		0 if no error, 0 if error!
d388 2
a389 1
int HTLoadRules ARGS1(CONST char *, filename)
d393 1
a393 1
    
d395 1
a395 2
        if (TRACE) fprintf(stderr,
			   "HTRules: Can't open rules file %s\n", filename);
d406 1
a406 1

@


1.1.1.1
log
@Lynx 2.8
@
text
@@
