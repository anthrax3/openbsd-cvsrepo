head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.43;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.37;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.50;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.47;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTWSRC.c,v 1.29 2013/05/01 22:32:59 tom Exp $
 *
 *			Parse WAIS Source file			HTWSRC.c
 *			======================
 *
 *	This module parses a stream with WAIS source file
 *	format information on it and creates a structured stream.
 *	That structured stream is then converted into whatever.
 *
 *	3 June 93	Bug fix: Won't crash if no description
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>

#include <HTWSRC.h>
#include <LYUtils.h>

#include <HTML.h>
#include <HTParse.h>

#include <LYLeaks.h>

#define BIG 10000		/* Arbitrary limit to value length */
#define PARAM_MAX BIG
#define CACHE_PERIOD (7*86400)	/* Time to keep .src file in seconds */

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

#define PUTC(c) (*me->target->isa->put_character)(me->target, c)
#define PUTS(s) (*me->target->isa->put_string)(me->target, s)
#define START(e) (*me->target->isa->start_element)(me->target, e, 0, 0, -1, 0)
#define END(e) (*me->target->isa->end_element)(me->target, e, 0)
#define MAYBE_END(e) if (HTML_dtd.tags[e].contents != SGML_EMPTY) \
			(*me->target->isa->end_element)(me->target, e, 0)

/*	Here are the parameters which can be specified in a  source file
*/
static const char *par_name[] =
{
    "version",
    "ip-address",
#define PAR_IP_NAME 2
    "ip-name",
#define PAR_TCP_PORT 3
    "tcp-port",
#define PAR_DATABASE_NAME 4
    "database-name",
#define PAR_COST 5
    "cost",
#define PAR_COST_UNIT 6
    "cost-unit",
#define PAR_FREE 7
    "free",
#define PAR_MAINTAINER 8
    "maintainer",
#define PAR_DESCRIPTION 9
    "description",
    "keyword-list",
    "source",
    "window-geometry",
    "configuration",
    "script",
    "update-time",
    "contact-at",
    "last-contacted",
    "confidence",
    "num-docs-to-request",
    "font",
    "font-size",
#define PAR_UNKNOWN 22
    "unknown",
    0,				/* Terminate list */
#define PAR_COUNT 23
};

enum tokenstate {
    beginning,
    before_tag,
    colon,
    before_value,
    value,
    bracketed_value,
    quoted_value,
    escape_in_quoted,
    done
};

/*		Stream Object
 *		------------
 *
 *	The target is the structured stream down which the
 *	parsed results will go.
 *
 *	all the static stuff below should go in here to make it reentrant
 */

struct _HTStream {
    const HTStreamClass *isa;
    HTStructured *target;
    char *par_value[PAR_COUNT];
    enum tokenstate state;
    char param[BIG + 1];
    int param_number;
    int param_count;
};

/*	Decode one hex character
*/
char from_hex(char c)
{
    return (char) ((c >= '0') && (c <= '9') ? c - '0'
		   : (c >= 'A') && (c <= 'F') ? c - 'A' + 10
		   : (c >= 'a') && (c <= 'f') ? c - 'a' + 10
		   : 0);
}

/*			State machine
 *			-------------
 *
 * On entry,
 *	me->state	is a valid state (see WSRC_init)
 *	c		is the next character
 * On exit,
 *	returns 1	Done with file
 *		0	Continue. me->state is updated if necessary.
 *		-1	Syntax error error
 */

/*		Treat One Character
 *		-------------------
 */
static void WSRCParser_put_character(HTStream *me, int c)
{
    switch (me->state) {
    case beginning:
	if (c == '(')
	    me->state = before_tag;
	break;

    case before_tag:
	if (c == ')') {
	    me->state = done;
	    return;		/* Done with input file */
	} else if (c == ':') {
	    me->param_count = 0;
	    me->state = colon;
	}			/* Ignore other text */
	break;

    case colon:
	if (WHITE(c)) {
	    me->param[me->param_count++] = 0;	/* Terminate */
	    for (me->param_number = 0;
		 par_name[me->param_number];
		 me->param_number++) {
		if (0 == strcmp(par_name[me->param_number], me->param)) {
		    break;
		}
	    }
	    if (!par_name[me->param_number]) {	/* Unknown field */
		CTRACE((tfp, "HTWSRC: Unknown field `%s' in source file\n",
			me->param));
		me->param_number = PAR_UNKNOWN;
		me->state = before_value;	/* Could be better ignore */
		return;
	    }
	    me->state = before_value;
	} else {
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = (char) c;
	}
	break;

    case before_value:
	if (c == ')') {
	    me->state = done;
	    return;		/* Done with input file */
	}
	if (WHITE(c))
	    return;		/* Skip white space */
	me->param_count = 0;
	if (c == '"') {
	    me->state = quoted_value;
	} else {
	    me->state = ((c == '(')
			 ? bracketed_value
			 : value);
	    me->param[me->param_count++] = (char) c;	/* Don't miss first character */
	}
	break;

    case value:
	if (WHITE(c)) {
	    me->param[me->param_count] = 0;
	    StrAllocCopy(me->par_value[me->param_number], me->param);
	    me->state = before_tag;
	} else {
	    if (me->param_count < PARAM_MAX)
		me->param[me->param_count++] = (char) c;
	}
	break;

    case bracketed_value:
	if (c == ')') {
	    me->param[me->param_count] = 0;
	    StrAllocCopy(me->par_value[me->param_number], me->param);
	    me->state = before_tag;
	    break;
	}
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = (char) c;
	break;

    case quoted_value:
	if (c == '"') {
	    me->param[me->param_count] = 0;
	    StrAllocCopy(me->par_value[me->param_number], me->param);
	    me->state = before_tag;
	    break;
	}

	if (c == '\\') {	/* Ignore escape but switch state */
	    me->state = escape_in_quoted;
	    break;
	}
	/* Fall through! */

    case escape_in_quoted:
	if (me->param_count < PARAM_MAX)
	    me->param[me->param_count++] = (char) c;
	me->state = quoted_value;
	break;

    case done:			/* Ignore anything after EOF */
	return;

    }				/* switch me->state */
}

/*			Open Cache file
 *			===============
 *
 *   Bugs: Maybe for filesystem-challenged platforms (MSDOS for example) we
 *   should make a hash code for the filename.
 */

#ifdef CACHE_FILE_PREFIX
static BOOL write_cache(HTStream *me)
{
    FILE *fp;
    char *cache_file_name = NULL;
    char *www_database;
    int result = NO;

    if (!me->par_value[PAR_DATABASE_NAME]
	|| !me->par_value[PAR_IP_NAME]
	)
	return NO;

    www_database = HTEscape(me->par_value[PAR_DATABASE_NAME], URL_XALPHAS);
    HTSprintf0(&cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
	       CACHE_FILE_PREFIX,
	       me->par_value[PAR_IP_NAME],
	       (me->par_value[PAR_TCP_PORT]
		? me->par_value[PAR_TCP_PORT]
		: "210"),
	       www_database);

    if ((fp = fopen(cache_file_name, TXT_W)) != 0) {
	result = YES;
	if (me->par_value[PAR_DESCRIPTION])
	    fputs(me->par_value[PAR_DESCRIPTION], fp);
	else
	    fputs("Description not available\n", fp);
	fclose(fp);
    }
    FREE(www_database);
    FREE(cache_file_name);
    return result;
}
#endif

/*			Output equivalent HTML
 *			----------------------
 *
 */

static void give_parameter(HTStream *me, int p)
{
    PUTS(par_name[p]);
    if (me->par_value[p]) {
	PUTS(": ");
	PUTS(me->par_value[p]);
	PUTS("; ");
    } else {
	PUTS(gettext(" NOT GIVEN in source file; "));
    }
}

/*			Generate Outout
 *			===============
 */
static void WSRC_gen_html(HTStream *me, int source_file)
{
    if (me->par_value[PAR_DATABASE_NAME]) {
	char *shortname = 0;
	int l;

	StrAllocCopy(shortname, me->par_value[PAR_DATABASE_NAME]);
	l = (int) strlen(shortname);
	if (l > 4 && !strcasecomp(shortname + l - 4, ".src")) {
	    shortname[l - 4] = 0;	/* Chop of .src -- boring! */
	}

	START(HTML_HEAD);
	PUTC('\n');
	START(HTML_TITLE);
	PUTS(shortname);
	PUTS(source_file ? gettext(" WAIS source file") : INDEX_SEGMENT);
	END(HTML_TITLE);
	PUTC('\n');
	END(HTML_HEAD);

	START(HTML_H1);
	PUTS(shortname);
	PUTS(source_file ? gettext(" description") : INDEX_SEGMENT);
	END(HTML_H1);
	PUTC('\n');
	FREE(shortname);
    }

    START(HTML_DL);		/* Definition list of details */

    if (source_file) {
	START(HTML_DT);
	PUTS(gettext("Access links"));
	MAYBE_END(HTML_DT);
	START(HTML_DD);
	if (me->par_value[PAR_IP_NAME] &&
	    me->par_value[PAR_DATABASE_NAME]) {

	    char *WSRC_address = NULL;
	    char *www_database;

	    www_database = HTEscape(me->par_value[PAR_DATABASE_NAME],
				    URL_XALPHAS);
	    HTSprintf0(&WSRC_address, "%s//%s%s%s/%s",
		       STR_WAIS_URL,
		       me->par_value[PAR_IP_NAME],
		       me->par_value[PAR_TCP_PORT] ? ":" : "",
		       (me->par_value[PAR_TCP_PORT]
			? me->par_value[PAR_TCP_PORT]
			: ""),
		       www_database);

	    HTStartAnchor(me->target, NULL, WSRC_address);
	    PUTS(gettext("Direct access"));
	    END(HTML_A);
	    /** Proxy will be used if defined, so let user know that - FM **/
	    PUTS(gettext(" (or via proxy server, if defined)"));

	    FREE(www_database);
	    FREE(WSRC_address);

	} else {
	    give_parameter(me, PAR_IP_NAME);
	    give_parameter(me, PAR_DATABASE_NAME);
	}
	MAYBE_END(HTML_DD);

    }
    /* end if source_file */
    if (me->par_value[PAR_MAINTAINER]) {
	START(HTML_DT);
	PUTS(gettext("Maintainer"));
	MAYBE_END(HTML_DT);
	START(HTML_DD);
	PUTS(me->par_value[PAR_MAINTAINER]);
	MAYBE_END(HTML_DD);
    }
    if (me->par_value[PAR_IP_NAME]) {
	START(HTML_DT);
	PUTS(gettext("Host"));
	MAYBE_END(HTML_DT);
	START(HTML_DD);
	PUTS(me->par_value[PAR_IP_NAME]);
	MAYBE_END(HTML_DD);
    }

    END(HTML_DL);

    if (me->par_value[PAR_DESCRIPTION]) {
	START(HTML_PRE);	/* Preformatted description */
	PUTS(me->par_value[PAR_DESCRIPTION]);
	END(HTML_PRE);
    }

    (*me->target->isa->_free) (me->target);

    return;
}				/* generate html */

static void WSRCParser_put_string(HTStream *context, const char *str)
{
    const char *p;

    for (p = str; *p; p++)
	WSRCParser_put_character(context, *p);
}

static void WSRCParser_write(HTStream *context, const char *str,
			     int l)
{
    const char *p;
    const char *e = str + l;

    for (p = str; p < e; p++)
	WSRCParser_put_character(context, *p);
}

static void WSRCParser_free(HTStream *me)
{
    WSRC_gen_html(me, YES);
#ifdef CACHE_FILE_PREFIX
    write_cache(me);
#endif
    {
	int p;

	for (p = 0; par_name[p]; p++) {		/* Clear out old values */
	    FREE(me->par_value[p]);
	}
    }
    FREE(me);
}

static void WSRCParser_abort(HTStream *me, HTError e GCC_UNUSED)
{
    WSRCParser_free(me);
}

/*		Stream subclass		-- method routines
 *		---------------
 */

static HTStreamClass WSRCParserClass =
{
    "WSRCParser",
    WSRCParser_free,
    WSRCParser_abort,
    WSRCParser_put_character,
    WSRCParser_put_string,
    WSRCParser_write
};

/*		Converter from WAIS Source to whatever
 *		--------------------------------------
 */
HTStream *HTWSRCConvert(HTPresentation *pres, HTParentAnchor *anchor,
			HTStream *sink)
{
    HTStream *me = (HTStream *) malloc(sizeof(*me));

    if (!me)
	outofmem(__FILE__, "HTWSRCConvert");

    assert(me != NULL);

    me->isa = &WSRCParserClass;
    me->target = HTML_new(anchor, pres->rep_out, sink);

    {
	int p;

	for (p = 0; p < PAR_COUNT; p++) {	/* Clear out parameter values */
	    me->par_value[p] = 0;
	}
    }
    me->state = beginning;

    return me;
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTWSRC.c,v 1.24 2009/01/03 02:01:01 tom Exp $
d14 2
d138 1
a138 1
static void WSRCParser_put_character(HTStream *me, char c)
d176 1
a176 1
		me->param[me->param_count++] = c;
d190 5
a194 1
	    break;
a195 3
	me->state = (c == '"') ? quoted_value :
	    (c == '(') ? bracketed_value : value;
	me->param[me->param_count++] = c;	/* Don't miss first character */
d205 1
a205 1
		me->param[me->param_count++] = c;
d217 1
a217 1
	    me->param[me->param_count++] = c;
d236 1
a236 1
	    me->param[me->param_count++] = c;
d309 1
a309 1
static void WSRC_gen_html(HTStream *me, BOOL source_file)
d472 2
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*			Parse WAIS Source file			HTWSRC.c
d313 1
a313 1
	l = strlen(shortname);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 8
a9 8
**			======================
**
**	This module parses a stream with WAIS source file
**	format information on it and creates a structured stream.
**	That structured stream is then converted into whatever.
**
**	3 June 93	Bug fix: Won't crash if no description
*/
d26 2
a27 2
	CONST HTStructuredClass *	isa;
	/* ... */
a36 1

d39 4
a42 3
PRIVATE CONST char* par_name[] = {
	"version",
	"ip-address",
d44 1
a44 1
	"ip-name",
d46 1
a46 1
	"tcp-port",
d48 1
a48 1
	"database-name",
d50 1
a50 1
	"cost",
d52 1
a52 1
	"cost-unit",
d54 1
a54 1
	"free",
d56 1
a56 1
	"maintainer",
d58 13
a70 13
	"description",
	"keyword-list",
	"source",
	"window-geometry",
	"configuration",
	"script",
	"update-time",
	"contact-at",
	"last-contacted",
	"confidence",
	"num-docs-to-request",
	"font",
	"font-size",
d72 2
a73 2
	"unknown",
	0,				/* Terminate list */
d75 1
a75 5
} ;


enum tokenstate { beginning, before_tag, colon, before_value,
		value, bracketed_value, quoted_value, escape_in_quoted, done };
d77 11
d90 7
a96 7
**		------------
**
**	The target is the structured stream down which the
**	parsed results will go.
**
**	all the static stuff below should go in here to make it reentrant
*/
d99 7
a105 7
	CONST HTStreamClass *	isa;
	HTStructured *		target;
	char *			par_value[PAR_COUNT];
	enum tokenstate		state;
	char			param[BIG+1];
	int			param_number;
	int			param_count;
a107 5



PUBLIC CONST char * hex = "0123456789ABCDEF";

d110 1
a110 2

PUBLIC char from_hex ARGS1(char, c)
d112 4
a115 4
    return  (char) (      (c>='0')&&(c<='9') ? c-'0'
			: (c>='A')&&(c<='F') ? c-'A'+10
			: (c>='a')&&(c<='f') ? c-'a'+10
			:		       0);
a117 1

d119 10
a128 11
**			-------------
**
** On entry,
**	me->state	is a valid state (see WSRC_init)
**	c		is the next character
** On exit,
**	returns 1	Done with file
**		0	Continue. me->state is updated if necessary.
**		-1	Syntax error error
*/

d131 3
a133 3
**		-------------------
*/
PRIVATE void WSRCParser_put_character ARGS2(HTStream*, me, char, c)
d137 2
a138 1
	if (c=='(') me->state = before_tag;
d142 1
a142 1
	if (c==')') {
d144 2
a145 2
	    return;			/* Done with input file */
	} else if (c==':') {
d148 1
a148 1
	}				/* Ignore other text */
d154 4
a157 2
	    for(me->param_number = 0; par_name[me->param_number]; me->param_number++) {
		if (0==strcmp(par_name[me->param_number], me->param)) {
d163 1
a163 1
			    me->param));
d170 2
a171 1
	    if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d176 1
a176 1
	if (c==')') {
d178 1
a178 1
	    return;			/* Done with input file */
d180 2
a181 1
	if (WHITE(c)) return;		/* Skip white space */
d183 1
a183 1
	if (c=='"') {
d187 2
a188 2
	me->state = (c=='"') ? quoted_value :
		    (c=='(') ? bracketed_value : value;
d198 2
a199 1
	    if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d204 1
a204 1
	if (c==')') {
d210 2
a211 1
	if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d215 1
a215 1
	if (c=='"') {
d222 1
a222 1
	if (c=='\\') {		/* Ignore escape but switch state */
d229 2
a230 1
	if (me->param_count < PARAM_MAX)  me->param[me->param_count++] = c;
d234 1
a234 1
    case done:				/* Ignore anything after EOF */
d237 1
a237 1
    } /* switch me->state */
a239 1

d241 5
a245 5
**			===============
**
**   Bugs: Maybe for filesystem-challenged platforms (MSDOS for example) we
**   should make a hash code for the filename.
*/
d248 1
a248 1
PRIVATE BOOL write_cache ARGS1(HTStream *, me)
d250 3
a252 3
    FILE * fp;
    char * cache_file_name = NULL;
    char * www_database;
d257 2
a258 1
	) return NO;
d262 6
a267 4
	CACHE_FILE_PREFIX,
	me->par_value[PAR_IP_NAME],
	me->par_value[PAR_TCP_PORT] ? me->par_value[PAR_TCP_PORT] : "210",
	www_database);
d284 3
a286 3
**			----------------------
**
*/
d288 1
a288 1
PRIVATE void give_parameter ARGS2(HTStream *, me, int, p)
a299 1

d301 3
a303 4
**			===============
*/
PRIVATE void WSRC_gen_html ARGS2(HTStream *, me, BOOL, source_file)

d306 1
a306 1
	char * shortname = 0;
d308 1
d311 2
a312 2
	if ( l > 4 && !strcasecomp(shortname + l -4, ".src")) {
	    shortname[l-4] = 0; /* Chop of .src -- boring! */
d342 3
a344 2
	    char * WSRC_address = NULL;
	    char * www_database;
d346 1
a346 1
		URL_XALPHAS);
d348 7
a354 5
		STR_WAIS_URL,
		me->par_value[PAR_IP_NAME],
		me->par_value[PAR_TCP_PORT] ? ":" : "",
		me->par_value[PAR_TCP_PORT] ? me->par_value[PAR_TCP_PORT] :"",
		www_database);
d371 2
a372 2
    } /* end if source_file */

d393 1
a393 1
	START(HTML_PRE);		/* Preformatted description */
d398 1
a398 1
    (*me->target->isa->_free)(me->target);
d401 1
a401 1
} /* generate html */
d403 3
d407 1
a407 4
PRIVATE void WSRCParser_put_string ARGS2(HTStream *, context, CONST char*, str)
{
    CONST char *p;
    for(p=str; *p; p++)
d411 5
d417 1
a417 8
PRIVATE void WSRCParser_write ARGS3(
		HTStream *,	context,
		CONST char*,	str,
		int,		l)
{
    CONST char *p;
    CONST char *e = str+l;
    for(p=str; p<e; p++)
d421 1
a421 2

PRIVATE void WSRCParser_free ARGS1(HTStream *, me)
d429 2
a430 1
	for (p = 0; par_name[p]; p++) { /* Clear out old values */
d437 1
a437 1
PRIVATE void WSRCParser_abort ARGS2(HTStream *, me, HTError, e GCC_UNUSED)
a441 1

d443 2
a444 10
**		---------------
*/

HTStreamClass WSRCParserClass = {
	"WSRCParser",
	WSRCParser_free,
	WSRCParser_abort,
	WSRCParser_put_character,
	WSRCParser_put_string,
	WSRCParser_write
d446 8
a455 1

d457 4
a460 6
**		--------------------------------------
*/
PUBLIC HTStream* HTWSRCConvert ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d462 4
a465 2
    HTStream * me = (HTStream*) malloc(sizeof(*me));
    if (!me) outofmem(__FILE__, "HTWSRCConvert");
d472 2
a473 1
	for(p=0; p < PAR_COUNT; p++) {	/* Clear out parameter values */
a480 1

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d14 1
a14 1

d95 1
a95 1
	enum tokenstate 	state;
d338 2
a339 1
	    HTSprintf0(&WSRC_address, "wais://%s%s%s/%s",
d434 1
a434 1
/*		Stream subclass 	-- method routines
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a24 2
#define HEX_ESCAPE '%'

d111 1
a111 1
    return		  (c>='0')&&(c<='9') ? c-'0'
d114 1
a114 1
			:		       0;
d160 2
a161 2
		CTRACE(tfp, "HTWSRC: Unknown field `%s' in source file\n",
			    me->param);
d245 1
a245 1
    char cache_file_name[256];
d247 2
d254 1
a254 1
    sprintf(cache_file_name, "%sWSRC-%s:%s:%.100s.txt",
d259 9
d269 2
a270 9
    fp = fopen(cache_file_name, "w");
    if (!fp) return NO;

    if (me->par_value[PAR_DESCRIPTION])
	fputs(me->par_value[PAR_DESCRIPTION], fp);
    else
	fputs("Description not available\n", fp);
    fclose(fp);
    return YES;
d334 1
a334 1
	    char WSRC_address[256];
d338 1
a338 1
	    sprintf(WSRC_address, "wais://%s%s%s/%s",
d351 1
@


1.1
log
@Initial revision
@
text
@d11 1
a11 2
#include "HTUtils.h"
#include "tcp.h"
d13 1
a13 1
#include "HTWSRC.h"
d16 2
a17 2
#include "HTML.h"
#include "HTParse.h"
d19 1
a19 3
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d162 2
a163 3
		if (TRACE) fprintf(stderr,
		    "HTWSRC: Unknown field `%s' in source file\n",
		    me->param);
d285 1
a285 1
	PUTS(" NOT GIVEN in source file; ");
d306 1
a306 1
	PUTS("\n");
d309 1
a309 1
	PUTS(source_file ? " WAIS source file" : " index");
d311 1
a311 1
	PUTS("\n");
d316 1
a316 1
	PUTS(source_file ? " description" : " index");
d318 1
a318 1
	PUTS("\n");
d326 1
a326 1
	PUTS("Access links");
d343 1
a343 1
	    PUTS("Direct access");
d346 1
a346 1
	    PUTS(" (or via proxy server, if defined)");
d360 1
a360 1
	PUTS("Maintainer");
d368 1
a368 1
	PUTS("Host");
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
