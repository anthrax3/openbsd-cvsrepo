head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.47;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.46;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTList.c,v 1.19 2013/01/04 00:31:27 tom Exp $
 *
 *	A small List class					      HTList.c
 *	==================
 *
 *	A list is represented as a sequence of linked nodes of type HTList.
 *	The first node is a header which contains no object.
 *	New nodes are inserted between the header and the rest of the list.
 */

#include <HTUtils.h>
#include <HTList.h>

#include <LYLeaks.h>

/*	Create list.
*/
HTList *HTList_new(void)
{
    HTList *newList;

    if ((newList = typeMalloc(HTList)) == NULL)
	  outofmem(__FILE__, "HTList_new");

    assert(newList != NULL);

    newList->object = NULL;
    newList->next = NULL;

    return newList;
}

/*	Delete list.
*/
void HTList_delete(HTList *me)
{
    HTList *current;

    while ((current = me)) {
	me = me->next;
	FREE(current);
    }

    return;
}

/*	Reverse order of elements in list.
 */
HTList *HTList_reverse(HTList *start)
{
    HTList *cur, *succ;

    if (!(start && start->next && (cur = start->next->next)))
	return start;
    start->next->next = NULL;
    while (cur) {
	succ = cur->next;
	cur->next = start->next;
	start->next = cur;
	cur = succ;
    }
    return start;
}

/*	Append a list to another.
 *
 *	If successful, the second list will become empty but not freed.
 */
HTList *HTList_appendList(HTList *start,
			  HTList *tail)
{
    HTList *temp = start;

    if (!start) {
	CTRACE((tfp,
		"HTList: Trying to append list %p to a nonexisting list\n",
		(void *) tail));
	return NULL;
    }
    if (!(tail && tail->next))
	return start;

    while (temp->next)
	temp = temp->next;

    temp->next = tail->next;
    tail->next = NULL;		/* tail is now an empty list */
    return start;
}

/*	Link object to START of list (so it is pointed to by the head).
 *
 *	Unlike HTList_addObject(), it does not malloc memory for HTList entry,
 *	it use already allocated memory which should not be free'd by any
 *	list operations (optimization).
 */
void HTList_linkObject(HTList *me, void *newObject,
		       HTList *newNode)
{
    if (me) {
	if (newNode->object == NULL && newNode->next == NULL) {
	    /*  It is safe: */
	    newNode->object = newObject;
	    newNode->next = me->next;
	    me->next = newNode;

	} else {
	    /*
	     * This node is already linked to some list (probably this one), so
	     * refuse changing node pointers to keep the list valid!!!
	     */
	    CTRACE((tfp, "*** HTList: Refuse linking already linked obj "));
	    CTRACE((tfp, "%p, node %p, list %p\n",
		    (void *) newObject, (void *) newNode, (void *) me));
	}

    } else {
	CTRACE((tfp,
		"HTList: Trying to link object %p to a nonexisting list\n",
		newObject));
    }

    return;
}

/*      Add object to START of list (so it is pointed to by the head).
*/
void HTList_addObject(HTList *me, void *newObject)
{
    HTList *newNode;

    if (me) {
	if ((newNode = typeMalloc(HTList)) == NULL)
	      outofmem(__FILE__, "HTList_addObject");

	assert(newNode != NULL);

	newNode->object = newObject;
	newNode->next = me->next;
	me->next = newNode;

    } else {
	CTRACE((tfp, "HTList: Trying to add object %p to a nonexisting list\n",
		newObject));
    }

    return;
}

/*      Append object to END of list (furthest from the head).
*/
void HTList_appendObject(HTList *me, void *newObject)
{
    HTList *temp = me;

    if (temp && newObject) {
	while (temp->next)
	    temp = temp->next;
	HTList_addObject(temp, newObject);
    }

    return;
}

/*	Insert an object into the list at a specified position.
 *      If position is 0, this places the object at the head of the list
 *      and is equivalent to HTList_addObject().
 */
void HTList_insertObjectAt(HTList *me, void *newObject,
			   int pos)
{
    HTList *newNode;
    HTList *temp = me;
    HTList *prevNode;
    int Pos = pos;

    if (!temp) {
	CTRACE((tfp, "HTList: Trying to add object %p to a nonexisting list\n",
		newObject));
	return;
    }
    if (Pos < 0) {
	Pos = 0;
	CTRACE((tfp, "HTList: Treating negative object position %d as %d.\n",
		pos, Pos));
    }

    prevNode = temp;
    while ((temp = temp->next)) {
	if (Pos == 0) {
	    if ((newNode = typeMalloc(HTList)) == NULL)
		  outofmem(__FILE__, "HTList_addObjectAt");

	    assert(newNode != NULL);

	    newNode->object = newObject;
	    newNode->next = temp;
	    if (prevNode)
		prevNode->next = newNode;
	    return;
	}
	prevNode = temp;
	Pos--;
    }
    if (Pos >= 0)
	HTList_addObject(prevNode, newObject);

    return;
}

/*	Unlink specified object from list.
 *	It does not free memory.
 */
BOOL HTList_unlinkObject(HTList *me, void *oldObject)
{
    HTList *temp = me;
    HTList *prevNode;

    if (temp && oldObject) {
	while (temp->next) {
	    prevNode = temp;
	    temp = temp->next;
	    if (temp->object == oldObject) {
		prevNode->next = temp->next;
		temp->next = NULL;
		temp->object = NULL;
		return YES;	/* Success */
	    }
	}
    }
    return NO;			/* object not found or NULL list */
}

/*	Remove specified object from list.
*/
BOOL HTList_removeObject(HTList *me, void *oldObject)
{
    HTList *temp = me;
    HTList *prevNode;

    if (temp && oldObject) {
	while (temp->next) {
	    prevNode = temp;
	    temp = temp->next;
	    if (temp->object == oldObject) {
		prevNode->next = temp->next;
		FREE(temp);
		return YES;	/* Success */
	    }
	}
    }
    return NO;			/* object not found or NULL list */
}

/*	Remove object at a given position in the list, where 0 is the
 *	object pointed to by the head (returns a pointer to the element
 *	(->object) for the object, and NULL if the list is empty, or
 *	if it doesn't exist - Yuk!).
 */
void *HTList_removeObjectAt(HTList *me, int position)
{
    HTList *temp = me;
    HTList *prevNode;
    int pos = position;
    void *result = NULL;

    if (temp != NULL && pos >= 0) {
	prevNode = temp;
	while ((temp = temp->next) != NULL) {
	    if (pos == 0) {
		prevNode->next = temp->next;
		result = temp->object;
		FREE(temp);
		break;
	    }
	    prevNode = temp;
	    pos--;
	}
    }

    return result;
}

/*	Unlink object from START of list (the Last one inserted
 *	via HTList_linkObject(), and pointed to by the head).
 *	It does not free memory.
 */
void *HTList_unlinkLastObject(HTList *me)
{
    HTList *lastNode;
    void *lastObject;

    if (me && me->next) {
	lastNode = me->next;
	lastObject = lastNode->object;
	me->next = lastNode->next;
	lastNode->next = NULL;
	lastNode->object = NULL;
	return lastObject;

    } else {			/* Empty list */
	return NULL;
    }
}

/*	Remove object from START of list (the Last one inserted
 *	via HTList_addObject(), and pointed to by the head).
 */
void *HTList_removeLastObject(HTList *me)
{
    HTList *lastNode;
    void *lastObject;

    if (me && me->next) {
	lastNode = me->next;
	lastObject = lastNode->object;
	me->next = lastNode->next;
	FREE(lastNode);
	return lastObject;

    } else {			/* Empty list */
	return NULL;
    }
}

/*	Remove object from END of list (the First one inserted
 *	via HTList_addObject(), and furthest from the head).
 */
void *HTList_removeFirstObject(HTList *me)
{
    HTList *temp = me;
    HTList *prevNode;
    void *firstObject;

    if (!temp)
	return NULL;

    prevNode = temp;
    if (temp->next) {
	while (temp->next) {
	    prevNode = temp;
	    temp = temp->next;
	}
	firstObject = temp->object;
	prevNode->next = NULL;
	FREE(temp);
	return firstObject;

    } else {			/* Empty list */
	return NULL;
    }
}

/*	Determine total number of objects in the list,
 *	not counting the head.
 */
int HTList_count(HTList *me)
{
    HTList *temp = me;
    int count = 0;

    if (temp)
	while ((temp = temp->next))
	    count++;

    return count;
}

/*	Determine position of an object in the list (a value of 0
 *	means it is pointed to by the head; returns -1 if not found).
 */
int HTList_indexOf(HTList *me, void *object)
{
    HTList *temp = me;
    int position = 0;

    if (temp) {
	while ((temp = temp->next)) {
	    if (temp->object == object)
		return position;
	    position++;
	}
    }

    return -1;			/* Object not in the list */
}

/*	Return pointer to the object at a specified position in the list,
 *	where 0 is the object pointed to by the head (returns NULL if
 *	the list is empty, or if it doesn't exist - Yuk!).
 */
void *HTList_objectAt(HTList *me, int position)
{
    HTList *temp = me;
    int pos = position;

    if (!temp || pos < 0)
	return NULL;

    while ((temp = temp->next)) {
	if (pos == 0)
	    return temp->object;
	pos--;
    }

    return NULL;		/* Reached the end of the list */
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTList.c,v 1.17 2008/09/18 21:36:59 tom Exp $
d26 2
d137 2
d195 2
d266 1
d268 9
a276 7
    if (!temp || pos < 0)
	return NULL;

    prevNode = temp;
    while ((temp = temp->next)) {
	if (pos == 0) {
	    prevNode->next = temp->next;
d278 1
a278 2
	    FREE(temp);
	    return prevNode->object;
a279 2
	prevNode = temp;
	pos--;
d282 1
a282 1
    return NULL;		/* Reached the end of the list */
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*	A small List class					      HTList.c
d76 1
a76 1
		tail));
d113 1
a113 1
		    newObject, newNode, me));
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 6
a7 6
**	==================
**
**	A list is represented as a sequence of linked nodes of type HTList.
**	The first node is a header which contains no object.
**	New nodes are inserted between the header and the rest of the list.
*/
d16 1
a16 1
PUBLIC HTList * HTList_new NOARGS
d21 1
a21 1
	outofmem(__FILE__, "HTList_new");
a28 1

d31 1
a31 2
PUBLIC void HTList_delete ARGS1(
	HTList *,	me)
d36 2
a37 2
      me = me->next;
      FREE (current);
d45 1
a45 2
PUBLIC HTList * HTList_reverse ARGS1(
    HTList *,		start)
d48 1
d65 2
a66 3
PUBLIC HTList * HTList_appendList ARGS2(
    HTList *,		start,
    HTList *,		tail)
d68 1
a68 1
    HTList * temp = start;
d71 3
a73 2
	CTRACE((tfp, "HTList: Trying to append list %p to a nonexisting list\n",
		    tail));
a86 1

d93 2
a94 4
PUBLIC void HTList_linkObject ARGS3(
	HTList *,	me,
	void *,		newObject,
	HTList *,	newNode)
d105 2
a106 2
	     *  This node is already linked to some list (probably this one),
	     *  so refuse changing node pointers to keep the list valid!!!
d110 1
a110 1
			newObject, newNode, me));
d114 3
a116 2
	CTRACE((tfp, "HTList: Trying to link object %p to a nonexisting list\n",
		    newObject));
a121 1

d124 1
a124 3
PUBLIC void HTList_addObject ARGS2(
	HTList *,	me,
	void *,		newObject)
d130 2
a131 1
	    outofmem(__FILE__, "HTList_addObject");
d138 1
a138 1
		    newObject));
a143 1

d146 1
a146 3
PUBLIC void HTList_appendObject ARGS2(
	HTList *,	me,
	void *,		newObject)
a158 1

d160 9
a168 11
**      If position is 0, this places the object at the head of the list
**      and is equivalent to HTList_addObject().
*/
PUBLIC void HTList_insertObjectAt ARGS3(
	HTList *,	me,
	void *,		newObject,
	int,		pos)
{
    HTList * newNode;
    HTList * temp = me;
    HTList * prevNode;
d173 1
a173 1
		    newObject));
d179 1
a179 1
		    pos, Pos));
d186 2
a187 1
		outofmem(__FILE__, "HTList_addObjectAt");
a202 1

d206 1
a206 3
PUBLIC BOOL HTList_unlinkObject ARGS2(
	HTList *,	me,
	void *,		oldObject)
d219 1
a219 1
		return YES;  /* Success */
d223 1
a223 1
    return NO;  /* object not found or NULL list */
a225 1

d228 1
a228 3
PUBLIC BOOL HTList_removeObject ARGS2(
	HTList *,	me,
	void *,		oldObject)
d239 2
a240 2
		FREE (temp);
		return YES;  /* Success */
d244 1
a244 1
    return NO;  /* object not found or NULL list */
a246 1

d248 5
a252 7
**	object pointed to by the head (returns a pointer to the element
**	(->object) for the object, and NULL if the list is empty, or
**	if it doesn't exist - Yuk!).
*/
PUBLIC void * HTList_removeObjectAt  ARGS2(
	HTList *,	me,
	int,		position)
d254 2
a255 2
    HTList * temp = me;
    HTList * prevNode;
d273 1
a273 1
    return NULL;  /* Reached the end of the list */
d280 1
a280 2
PUBLIC void * HTList_unlinkLastObject ARGS1(
	HTList *,	me)
d282 2
a283 2
    HTList * lastNode;
    void * lastObject;
d293 1
a293 1
    } else {  /* Empty list */
a297 1

d299 3
a301 4
**	via HTList_addObject(), and pointed to by the head).
*/
PUBLIC void * HTList_removeLastObject ARGS1(
	HTList *,	me)
d303 2
a304 2
    HTList * lastNode;
    void * lastObject;
d310 1
a310 1
	FREE (lastNode);
d313 1
a313 1
    } else {  /* Empty list */
a317 1

d319 3
a321 4
**	via HTList_addObject(), and furthest from the head).
*/
PUBLIC void * HTList_removeFirstObject ARGS1(
	HTList *,	me)
d323 2
a324 2
    HTList * temp = me;
    HTList * prevNode;
d338 1
a338 1
	FREE (temp);
d341 1
a341 1
    } else {  /* Empty list */
a345 1

d347 3
a349 4
**	not counting the head.
*/
PUBLIC int HTList_count ARGS1(
	HTList *,	me)
d351 1
a351 1
    HTList * temp = me;
a360 1

d362 3
a364 5
**	means it is pointed to by the head; returns -1 if not found).
*/
PUBLIC int HTList_indexOf ARGS2(
	HTList *,	me,
	void *,		object)
d366 1
a366 1
    HTList * temp = me;
d377 1
a377 1
    return -1;	/* Object not in the list */
a379 1

d381 4
a384 6
**	where 0 is the object pointed to by the head (returns NULL if
**	the list is empty, or if it doesn't exist - Yuk!).
*/
PUBLIC void * HTList_objectAt ARGS2(
	HTList *,	me,
	int,		position)
d386 1
a386 1
    HTList * temp = me;
d398 1
a398 1
    return NULL;	/* Reached the end of the list */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d20 1
a20 1
    if ((newList = typecalloc(HTList)) == NULL)
d90 37
d136 1
a136 1
	if ((newNode = typecalloc(HTList)) == NULL)
d197 1
a197 1
	    if ((newNode = typecalloc(HTList)) == NULL)
d215 26
d294 23
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d20 2
a21 2
    if ((newList = (HTList *)calloc(1, sizeof(HTList))) == NULL)
        outofmem(__FILE__, "HTList_new");
d74 3
a76 3
        CTRACE(tfp, "HTList: Trying to append list %p to a nonexisting list\n",
		    tail);
        return NULL;
d99 1
a99 1
        if ((newNode = (HTList *)calloc(1, sizeof(HTList))) == NULL)
d106 2
a107 2
        CTRACE(tfp, "HTList: Trying to add object %p to a nonexisting list\n",
		    newObject);
d147 2
a148 2
	CTRACE(tfp, "HTList: Trying to add object %p to a nonexisting list\n",
		    newObject);
d153 2
a154 2
	CTRACE(tfp, "HTList: Treating negative object position %d as %d.\n",
		    pos, Pos);
d160 2
a161 2
	    if ((newNode = (HTList *)calloc(1, sizeof(HTList))) == NULL)
	        outofmem(__FILE__, "HTList_addObjectAt");
d165 1
a165 1
	        prevNode->next = newNode;
d172 1
a172 1
        HTList_addObject(prevNode, newObject);
d192 1
a192 1
	        prevNode->next = temp->next;
d244 1
a244 1
        lastNode = me->next;
d251 1
a251 1
        return NULL;
d267 1
a267 1
        return NULL;
d281 1
a281 1
        return NULL;
d296 1
a296 1
        while ((temp = temp->next))
d316 1
a316 1
	        return position;
@


1.1
log
@Initial revision
@
text
@d9 2
a10 8
#include "HTUtils.h"
#include "HTList.h"

/*#include <stdio.h> included by HTUtils.h -- FM *//* joe@@athena, TBL 921019 */

#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d12 1
d45 44
d105 3
a107 4
    } else if (TRACE) {
        fprintf(stderr,
		"HTList: Trying to add object %p to a nonexisting list\n",
		newObject);
d147 1
a147 3
	if (TRACE) {
	    fprintf(stderr,
		    "HTList: Trying to add object %p to a nonexisting list\n",
a148 1
	}
d153 1
a153 3
	if (TRACE) {
	    fprintf(stderr,
		    "HTList: Treating negative object position %d as %d.\n",
a154 1
	}
d168 1
a168 1
	prevNode = temp; 
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
