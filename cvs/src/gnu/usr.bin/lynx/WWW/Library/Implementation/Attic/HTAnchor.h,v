head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.38;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.45;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.44;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.44;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTAnchor.h,v 1.37 2013/10/02 23:21:55 tom Exp $
 *
 *	Hypertext "Anchor" Object				     HTAnchor.h
 *	==========================
 *
 *	An anchor represents a region of a hypertext document which is linked
 *	to another anchor in the same or a different document.
 */

#ifndef HTANCHOR_H
#define HTANCHOR_H

/* Version 0 (TBL) written in Objective-C for the NeXT browser */
/* Version 1 of 24-Oct-1991 (JFG), written in C, browser-independent */

#include <HTList.h>
#include <HTBTree.h>
#include <HTChunk.h>
#include <HTAtom.h>
#include <UCDefs.h>

typedef struct _HyperDoc HyperDoc;	/* Ready for forward references */
typedef struct _HTAnchor HTAnchor;
typedef struct _HTParentAnchor HTParentAnchor;
typedef struct _HTParentAnchor0 HTParentAnchor0;

#include <HTFormat.h>

#ifdef __cplusplus
extern "C" {
#endif
    struct _HTAnchor {
	/* Generic anchor */
	HTParentAnchor0 *parent;	/* Parent of this anchor (self for adults) */
    };

#define HASH_TYPE unsigned short

    struct _HTParentAnchor0 {	/* One for adult_table,
				 * generally not used outside HTAnchor.c */
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* (self) */

	/* ParentAnchor0-specific information */
	char *address;		/* Absolute address of this node */
	HTParentAnchor *info;	/* additional info, allocated on demand */

	HTBTree *children;	/* Subanchors <a name="tag">, sorted by tag */
	HTList sources;		/* List of anchors pointing to this, if any */

	HTList _add_adult;	/* - just a memory for list entry:) */
	HASH_TYPE adult_hash;	/* adult list number */
	BOOL underway;		/* Document about to be attached to it */
    };

    /*
     *  Separated from the above to save memory:  allocated on demand,
     *  it is nearly 1:1 to HText (well, sometimes without HText...),
     *  available for SGML, HTML, and HText stages.
     *  [being precise, we currently allocate it before HTLoadDocument(),
     *  in HTAnchor_findAddress() and HTAnchor_parent()].
     */
    struct _HTParentAnchor {
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* Parent of this anchor */

	/* ParentAnchor-specific information */
	HTList children_notag;	/* Subanchors <a href=...>, tag is NULL */
	HyperDoc *document;	/* The document within which this is an anchor */

	char *address;		/* parent->address, a pointer */
	bstring *post_data;	/* Posting data */
	char *post_content_type;	/* Type of post data */
	char *bookmark;		/* Bookmark filename */
	HTFormat format;	/* Pointer to node format descriptor */
	char *charset;		/* Pointer to character set (kludge, for now */
	BOOL isIndex;		/* Acceptance of a keyword search */
	char *isIndexAction;	/* URL of isIndex server */
	char *isIndexPrompt;	/* Prompt for isIndex query */
	char *title;		/* Title of document */
	char *owner;		/* Owner of document */
	char *RevTitle;		/* TITLE in REV="made" or REV="owner" LINK */
	char *citehost;		/* Citehost from REL="citehost" LINK */
#ifdef USE_COLOR_STYLE
	char *style;
#endif

	HTList *methods;	/* Methods available as HTAtoms */
	void *protocol;		/* Protocol object */
	char *physical;		/* Physical address */
	BOOL isISMAPScript;	/* Script for clickable image map */
	BOOL isHEAD;		/* Document is headers from a HEAD request */
	BOOL safe;		/* Safe */
#ifdef USE_SOURCE_CACHE
	char *source_cache_file;
	HTChunk *source_cache_chunk;
#endif
	char *FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
	char *SugFname;		/* Suggested filename */
	char *cache_control;	/* Cache-Control */
	BOOL no_cache;		/* Cache-Control, Pragma or META "no-cache"? */
	BOOL inBASE;		/* duplicated from HTStructured (HTML.c/h) */
#ifdef EXP_HTTP_HEADERS
	HTChunk http_headers;
#endif
	char *content_type_params;	/* Content-Type (with parameters if any) */
	char *content_type;	/* Content-Type */
	char *content_language;	/* Content-Language */
	char *content_encoding;	/* Compression algorithm */
	char *content_base;	/* Content-Base */
	char *content_disposition;	/* Content-Disposition */
	char *content_location;	/* Content-Location */
	char *content_md5;	/* Content-MD5 */
	char *message_id;	/* Message-ID */
	char *subject;		/* Subject */
	off_t content_length;	/* Content-Length */
	off_t actual_length;	/* actual length may differ */
	char *date;		/* Date */
	char *expires;		/* Expires */
	char *last_modified;	/* Last-Modified */
	char *ETag;		/* ETag (HTTP1.1 cache validator) */
	char *server;		/* Server */
	UCAnchorInfo *UCStages;	/* chartrans stages */
	HTList *imaps;		/* client side image maps */
    };

    typedef HTAtom HTLinkType;

    typedef struct {
	/* Common part from the generic anchor structure */
	HTParentAnchor0 *parent;	/* Parent of this anchor */

	/* ChildAnchor-specific information */
	char *tag;		/* #fragment,  relative to the parent */

	HTAnchor *dest;		/* The anchor to which this leads */
	HTLinkType *type;	/* Semantics of this link */

	HTList _add_children_notag;	/* - just a memory for list entry:) */
	HTList _add_sources;	/* - just a memory for list entry:) */
    } HTChildAnchor;

    /*
     *  DocAddress structure is used for loading an absolute anchor with all
     *  needed information including posting data and post content type.
     */
    typedef struct _DocAddress {
	char *address;
	bstring *post_data;
	char *post_content_type;
	char *bookmark;
	BOOL isHEAD;
	BOOL safe;
    } DocAddress;

    /* "internal" means "within the same document, with certainty". */
    extern HTLinkType *HTInternalLink;

    /* Create or find a child anchor with a possible link
     * --------------------------------------------------
     *
     * Create new anchor with a given parent and possibly
     * a name, and possibly a link to a _relatively_ named anchor.
     * (Code originally in ParseHTML.h)
     */
    extern HTChildAnchor *HTAnchor_findChildAndLink(HTParentAnchor *parent,	/* May not be 0 */
						    const char *tag,	/* May be "" or 0 */
						    const char *href,	/* May be "" or 0 */
						    HTLinkType *ltype);		/* May be 0 */

    /* Create new or find old parent anchor
     * ------------------------------------
     *
     * This one is for a reference which is found in a document, and might
     * not be already loaded.
     * Note: You are not guaranteed a new anchor -- you might get an old one,
     * like with fonts.
     */
    extern HTParentAnchor *HTAnchor_findAddress(const DocAddress *address);

    /* Create new or find old named anchor - simple form
     * -------------------------------------------------
     *
     * Like the previous one, but simpler to use for simple cases.
     * No post data etc.  can be supplied.  - kw
     */
    extern HTParentAnchor *HTAnchor_findSimpleAddress(const char *url);

    /* Delete an anchor and possibly related things (auto garbage collection)
     * --------------------------------------------
     *
     * The anchor is only deleted if the corresponding document is not loaded.
     * All outgoing links from children are deleted, and children are
     * removed from the sources lists of their targets.
     * We also try to delete the targets whose documents are not loaded.
     * If this anchor's sources list is empty, we delete it and its children.
     */
    extern BOOL HTAnchor_delete(HTParentAnchor0 *me);

    /*
     * Unnamed children (children_notag) have no sense without HText -
     * delete them and their links if we are about to free HText.
     * Document currently exists.  Called within HText_free().
     */
    extern void HTAnchor_delete_links(HTParentAnchor *me);

#ifdef USE_SOURCE_CACHE
    extern void HTAnchor_clearSourceCache(HTParentAnchor *me);
#endif

    /* Data access functions
     * ---------------------
     */
    extern HTParentAnchor *HTAnchor_parent(HTAnchor * me);

    extern void HTAnchor_setDocument(HTParentAnchor *me,
				     HyperDoc *doc);

    extern HyperDoc *HTAnchor_document(HTParentAnchor *me);

    /* Returns the full URI of the anchor, child or parent
     * as a malloc'd string to be freed by the caller.
     */
    extern char *HTAnchor_address(HTAnchor * me);

    extern char *HTAnchor_short_address(HTAnchor * me);

    extern void HTAnchor_setFormat(HTParentAnchor *me,
				   HTFormat form);

    extern HTFormat HTAnchor_format(HTParentAnchor *me);

    extern void HTAnchor_setIndex(HTParentAnchor *me,
				  const char *address);

    extern void HTAnchor_setPrompt(HTParentAnchor *me,
				   const char *prompt);

    extern BOOL HTAnchor_isIndex(HTParentAnchor *me);

    extern BOOL HTAnchor_isISMAPScript(HTAnchor * me);

#if defined(USE_COLOR_STYLE)
    extern const char *HTAnchor_style(HTParentAnchor *me);

    extern void HTAnchor_setStyle(HTParentAnchor *me,
				  const char *style);
#endif

    /* Title handling.
     */
    extern const char *HTAnchor_title(HTParentAnchor *me);

    extern void HTAnchor_setTitle(HTParentAnchor *me,
				  const char *title);

    extern void HTAnchor_appendTitle(HTParentAnchor *me,
				     const char *title);

    /* Bookmark handling.
     */
    extern const char *HTAnchor_bookmark(HTParentAnchor *me);

    extern void HTAnchor_setBookmark(HTParentAnchor *me,
				     const char *bookmark);

    /* Owner handling.
     */
    extern const char *HTAnchor_owner(HTParentAnchor *me);

    extern void HTAnchor_setOwner(HTParentAnchor *me,
				  const char *owner);

    /* TITLE handling in LINKs with REV="made" or REV="owner".  - FM
     */
    extern const char *HTAnchor_RevTitle(HTParentAnchor *me);

    extern void HTAnchor_setRevTitle(HTParentAnchor *me,
				     const char *title);

    /* Citehost for bibp links from LINKs with REL="citehost".  - RDC
     */
    extern const char *HTAnchor_citehost(HTParentAnchor *me);

    extern void HTAnchor_setCitehost(HTParentAnchor *me,
				     const char *citehost);

    /* Suggested filename handling.  - FM
     * (will be loaded if we had a Content-Disposition
     * header or META element with filename=name.suffix)
     */
    extern const char *HTAnchor_SugFname(HTParentAnchor *me);

    /* HTTP Headers.
     */
    extern const char *HTAnchor_http_headers(HTParentAnchor *me);

    /* Content-Type handling (parameter list).
     */
    extern const char *HTAnchor_content_type_params(HTParentAnchor *me);

    /* Content-Type handling.  - FM
     */
    extern const char *HTAnchor_content_type(HTParentAnchor *me);

    /* Content-Encoding handling.  - FM
     * (will be loaded if we had a Content-Encoding
     * header.)
     */
    extern const char *HTAnchor_content_encoding(HTParentAnchor *me);

    /* Last-Modified header handling.  - FM
     */
    extern const char *HTAnchor_last_modified(HTParentAnchor *me);

    /* Date header handling.  - FM
     */
    extern const char *HTAnchor_date(HTParentAnchor *me);

    /* Server header handling.  - FM
     */
    extern const char *HTAnchor_server(HTParentAnchor *me);

    /* Safe header handling.  - FM
     */
    extern BOOL HTAnchor_safe(HTParentAnchor *me);

    /* Content-Base header handling.  - FM
     */
    extern const char *HTAnchor_content_base(HTParentAnchor *me);

    /* Content-Location header handling.  - FM
     */
    extern const char *HTAnchor_content_location(HTParentAnchor *me);

    /* Message-ID, used for mail replies - kw
     */
    extern const char *HTAnchor_messageID(HTParentAnchor *me);

    extern BOOL HTAnchor_setMessageID(HTParentAnchor *me,
				      const char *messageid);

    /* Subject, used for mail replies - kw
     */
    extern const char *HTAnchor_subject(HTParentAnchor *me);

    extern BOOL HTAnchor_setSubject(HTParentAnchor *me,
				    const char *subject);

    /* Manipulation of links
     * ---------------------
     */
    extern HTAnchor *HTAnchor_followLink(HTChildAnchor *me);

    extern HTAnchor *HTAnchor_followTypedLink(HTChildAnchor *me,
					      HTLinkType *type);

    /* Read and write methods
     * ----------------------
     */
    extern HTList *HTAnchor_methods(HTParentAnchor *me);

    /* Protocol
     * --------
     */
    extern void *HTAnchor_protocol(HTParentAnchor *me);

    extern void HTAnchor_setProtocol(HTParentAnchor *me,
				     void *protocol);

    /* Physical address
     * ----------------
     */
    extern char *HTAnchor_physical(HTParentAnchor *me);

    extern void HTAnchor_setPhysical(HTParentAnchor *me,
				     char *protocol);

    extern LYUCcharset *HTAnchor_getUCInfoStage(HTParentAnchor *me,
						int which_stage);

    extern int HTAnchor_getUCLYhndl(HTParentAnchor *me,
				    int which_stage);

    extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
						int LYhndl,
						int which_stage,
						int set_by);

    extern LYUCcharset *HTAnchor_setUCInfoStage(HTParentAnchor *me,
						int LYhndl,
						int which_stage,
						int set_by);

    extern LYUCcharset *HTAnchor_resetUCInfoStage(HTParentAnchor *me,
						  int LYhndl,
						  int which_stage,
						  int set_by);

    extern LYUCcharset *HTAnchor_copyUCInfoStage(HTParentAnchor *me,
						 int to_stage,
						 int from_stage,
						 int set_by);

    extern void ImageMapList_free(HTList *list);

#ifdef __cplusplus
}
#endif
#endif				/* HTANCHOR_H */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTAnchor.h,v 1.33 2009/01/01 16:47:33 tom Exp $
d38 2
d53 1
a53 1
	short adult_hash;	/* adult list number */
d117 2
a118 1
	long content_length;	/* Content-Length */
d226 2
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 4
/*		   /Net/dxcern/userd/timbl/hypertext/WWW/Library/Implementation/HTAnchor.html
 */

/*	Hypertext "Anchor" Object				     HTAnchor.h
d33 1
a33 3
/*			Main definition of anchor
 *			=========================
 */ struct _HTAnchor {
d55 7
a61 7
/*
 *  Separated from the above to save memory:  allocated on demand,
 *  it is nearly 1:1 to HText (well, sometimes without HText...),
 *  available for SGML, HTML, and HText stages.
 *  [being precise, we currently allocate it before HTLoadDocument(),
 *  in HTAnchor_findAddress() and HTAnchor_parent()].
 */
d115 1
a115 1
	int content_length;	/* Content-Length */
d141 4
a144 4
/*
 *  DocAddress structure is used for loading an absolute anchor with all
 *  needed information including posting data and post content type.
 */
d154 1
a154 1
/* "internal" means "within the same document, with certainty". */
d157 7
a163 7
/*	Create or find a child anchor with a possible link
 *	--------------------------------------------------
 *
 *	Create new anchor with a given parent and possibly
 *	a name, and possibly a link to a _relatively_ named anchor.
 *	(Code originally in ParseHTML.h)
 */
d169 8
a176 8
/*	Create new or find old parent anchor
 *	------------------------------------
 *
 *	This one is for a reference which is found in a document, and might
 *	not be already loaded.
 *	Note: You are not guaranteed a new anchor -- you might get an old one,
 *	like with fonts.
 */
d179 6
a184 6
/*	Create new or find old named anchor - simple form
 *	-------------------------------------------------
 *
 *	Like the previous one, but simpler to use for simple cases.
 *	No post data etc. can be supplied. - kw
 */
d187 9
a195 9
/*	Delete an anchor and possibly related things (auto garbage collection)
 *	--------------------------------------------
 *
 *	The anchor is only deleted if the corresponding document is not loaded.
 *	All outgoing links from children are deleted, and children are
 *	removed from the sources lists of their targets.
 *	We also try to delete the targets whose documents are not loaded.
 *	If this anchor's sources list is empty, we delete it and its children.
 */
d198 5
a202 5
/*
 *  Unnamed children (children_notag) have no sense without HText -
 *  delete them and their links if we are about to free HText.
 *  Document currently exists.  Called within HText_free().
 */
d209 3
a211 3
/*	Data access functions
 *	---------------------
 */
d219 3
a221 3
/*	Returns the full URI of the anchor, child or parent
 *	as a malloc'd string to be freed by the caller.
 */
d246 2
a247 2
/*	Title handling.
*/
d256 2
a257 2
/*	Bookmark handling.
*/
d263 2
a264 2
/*	Owner handling.
*/
d270 2
a271 2
/*	TITLE handling in LINKs with REV="made" or REV="owner". - FM
*/
d277 2
a278 2
/*	Citehost for bibp links from LINKs with REL="citehost". - RDC
*/
d284 4
a287 4
/*	Suggested filename handling. - FM
 *	(will be loaded if we had a Content-Disposition
 *	 header or META element with filename=name.suffix)
 */
d290 2
a291 2
/*	HTTP Headers.
*/
d294 2
a295 2
/*	Content-Type handling (parameter list).
*/
d298 2
a299 2
/*	Content-Type handling. - FM
*/
d302 4
a305 4
/*	Content-Encoding handling. - FM
 *	(will be loaded if we had a Content-Encoding
 *	 header.)
 */
d308 2
a309 2
/*	Last-Modified header handling. - FM
*/
d312 2
a313 2
/*	Date header handling. - FM
*/
d316 2
a317 2
/*	Server header handling. - FM
*/
d320 2
a321 2
/*	Safe header handling. - FM
*/
d324 2
a325 2
/*	Content-Base header handling. - FM
*/
d328 2
a329 2
/*	Content-Location header handling. - FM
*/
d332 2
a333 2
/*	Message-ID, used for mail replies - kw
*/
d339 2
a340 2
/*	Subject, used for mail replies - kw
*/
d346 3
a348 3
/*	Manipulation of links
 *	---------------------
 */
d354 3
a356 3
/*	Read and write methods
 *	----------------------
 */
d359 3
a361 3
/*	Protocol
 *	--------
 */
d367 3
a369 3
/*	Physical address
 *	----------------
 */
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d5 5
a9 5
**	==========================
**
**	An anchor represents a region of a hypertext document which is linked
**	to another anchor in the same or a different document.
*/
d23 1
a23 5
/*			Main definition of anchor
**			=========================
*/

typedef struct _HyperDoc HyperDoc;  /* Ready for forward references */
a27 1
/*	After definition of HTFormat: */
d30 9
d40 1
a40 5
struct _HTAnchor {		/* Generic anchor */
  HTParentAnchor0 * parent;	/* Parent of this anchor (self for adults) */
};

struct _HTParentAnchor0 {	/* One for adult_table,
d42 2
a43 2
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* (self) */
d45 11
a55 11
  /* ParentAnchor0-specific information */
  char		  * address;	/* Absolute address of this node */
  HTParentAnchor  * info;	/* additional info, allocated on demand */

  HTBTree *	children;	/* Subanchors <a name="tag">, sorted by tag */
  HTList	sources;	/* List of anchors pointing to this, if any */

  HTList	_add_adult;	/* - just a memory for list entry:) */
  short		adult_hash;	/* adult list number */
  BOOL		underway;	/* Document about to be attached to it */
};
d64 21
a84 21
struct _HTParentAnchor {
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* Parent of this anchor */

  /* ParentAnchor-specific information */
  HTList	children_notag;	/* Subanchors <a href=...>, tag is NULL */
  HyperDoc *	document;	/* The document within which this is an anchor*/

  char *	address;	/* parent->address, a pointer */
  bstring *	post_data;	/* Posting data */
  char *	post_content_type;  /* Type of post data */
  char *	bookmark;	/* Bookmark filename */
  HTFormat	format;		/* Pointer to node format descriptor */
  char *	charset;	/* Pointer to character set (kludge, for now */
  BOOL		isIndex;	/* Acceptance of a keyword search */
  char *	isIndexAction;	/* URL of isIndex server */
  char *	isIndexPrompt;	/* Prompt for isIndex query */
  char *	title;		/* Title of document */
  char *	owner;		/* Owner of document */
  char *	RevTitle;	/* TITLE in REV="made" or REV="owner" LINK */
  char *	citehost;	/* Citehost from REL="citehost" LINK */
d86 1
a86 1
  char *	style;
d89 6
a94 6
  HTList*	methods;	/* Methods available as HTAtoms */
  void *	protocol;	/* Protocol object */
  char *	physical;	/* Physical address */
  BOOL		isISMAPScript;	/* Script for clickable image map */
  BOOL		isHEAD;		/* Document is headers from a HEAD request */
  BOOL		safe;			/* Safe */
d96 10
a105 2
  char *	source_cache_file;
  HTChunk *	source_cache_chunk;
d107 35
a141 39
  char *	FileCache;	/* Path to a disk-cached copy (see src/HTFWriter.c) */
  char *	SugFname;	/* Suggested filename */
  char *	cache_control;	/* Cache-Control */
  BOOL		no_cache;	/* Cache-Control, Pragma or META "no-cache"? */
  BOOL		inBASE;		/* duplicated from HTStructured (HTML.c/h) */
  char *	content_type;		/* Content-Type */
  char *	content_language;	/* Content-Language */
  char *	content_encoding;	/* Compression algorithm */
  char *	content_base;		/* Content-Base */
  char *	content_disposition;	/* Content-Disposition */
  char *	content_location;	/* Content-Location */
  char *	content_md5;		/* Content-MD5 */
  char *	message_id;		/* Message-ID */
  char *	subject;		/* Subject */
  int		content_length;		/* Content-Length */
  char *	date;			/* Date */
  char *	expires;		/* Expires */
  char *	last_modified;		/* Last-Modified */
  char *	ETag;			/* ETag (HTTP1.1 cache validator) */
  char *	server;			/* Server */
  UCAnchorInfo *UCStages;		/* chartrans stages */
  HTList *	imaps;			/* client side image maps */
};

typedef HTAtom HTLinkType;

typedef struct {
  /* Common part from the generic anchor structure */
  HTParentAnchor0 * parent;	/* Parent of this anchor */

  /* ChildAnchor-specific information */
  char *	tag;		/* #fragment,  relative to the parent */

  HTAnchor *	dest;		/* The anchor to which this leads */
  HTLinkType *	type;		/* Semantics of this link */

  HTList	_add_children_notag;	/* - just a memory for list entry:) */
  HTList	_add_sources;		/* - just a memory for list entry:) */
} HTChildAnchor;
d144 11
a154 11
**  DocAddress structure is used for loading an absolute anchor with all
**  needed information including posting data and post content type.
*/
typedef struct _DocAddress {
    char *	address;
    bstring *	post_data;
    char *	post_content_type;
    char *	bookmark;
    BOOL	isHEAD;
    BOOL	safe;
} DocAddress;
d157 1
a157 1
extern HTLinkType * HTInternalLink;
d160 10
a169 11
**	--------------------------------------------------
**
**	Create new anchor with a given parent and possibly
**	a name, and possibly a link to a _relatively_ named anchor.
**	(Code originally in ParseHTML.h)
*/
extern HTChildAnchor * HTAnchor_findChildAndLink PARAMS((
	HTParentAnchor * parent,	/* May not be 0 */
	CONST char * tag,		/* May be "" or 0 */
	CONST char * href,		/* May be "" or 0 */
	HTLinkType * ltype));		/* May be 0 */
d172 8
a179 9
**	------------------------------------
**
**	This one is for a reference which is found in a document, and might
**	not be already loaded.
**	Note: You are not guaranteed a new anchor -- you might get an old one,
**	like with fonts.
*/
extern HTParentAnchor * HTAnchor_findAddress PARAMS((
	CONST DocAddress *	address));
d182 6
a187 7
**	-------------------------------------------------
**
**	Like the previous one, but simpler to use for simple cases.
**	No post data etc. can be supplied. - kw
*/
extern HTParentAnchor * HTAnchor_findSimpleAddress PARAMS((
	CONST char *	url));
d190 9
a198 10
**	--------------------------------------------
**
**	The anchor is only deleted if the corresponding document is not loaded.
**	All outgoing links from children are deleted, and children are
**	removed from the sources lists of their targets.
**	We also try to delete the targets whose documents are not loaded.
**	If this anchor's sources list is empty, we delete it and its children.
*/
extern BOOL HTAnchor_delete PARAMS((
	HTParentAnchor0 *	me));
d205 1
a205 2
extern void HTAnchor_delete_links PARAMS((
	HTParentAnchor *	me));
d208 1
a208 2
extern void HTAnchor_clearSourceCache PARAMS((
	HTParentAnchor *	me));
d212 3
a214 4
**	---------------------
*/
extern HTParentAnchor * HTAnchor_parent PARAMS((
	HTAnchor *		me));
d216 2
a217 3
extern void HTAnchor_setDocument PARAMS((
	HTParentAnchor *	me,
	HyperDoc *		doc));
d219 1
a219 2
extern HyperDoc * HTAnchor_document PARAMS((
	HTParentAnchor *	me));
d222 3
a224 4
**	as a malloc'd string to be freed by the caller.
*/
extern char * HTAnchor_address PARAMS((
	HTAnchor *		me));
d226 2
a227 3
extern void HTAnchor_setFormat PARAMS((
	HTParentAnchor *	me,
	HTFormat		form));
d229 1
a229 2
extern HTFormat HTAnchor_format PARAMS((
	HTParentAnchor *	me));
d231 2
a232 3
extern void HTAnchor_setIndex PARAMS((
	HTParentAnchor *	me,
	CONST char *		address));
d234 2
a235 3
extern void HTAnchor_setPrompt PARAMS((
	HTParentAnchor *	me,
	CONST char *		prompt));
d237 1
a237 2
extern BOOL HTAnchor_isIndex PARAMS((
	HTParentAnchor *	me));
d239 1
a239 2
extern BOOL HTAnchor_isISMAPScript PARAMS((
	HTAnchor *		me));
d242 1
a242 2
extern CONST char * HTAnchor_style PARAMS((
	HTParentAnchor *	me));
d244 2
a245 3
extern void HTAnchor_setStyle PARAMS((
	HTParentAnchor *	me,
	CONST char *		style));
d250 1
a250 2
extern CONST char * HTAnchor_title PARAMS((
	HTParentAnchor *	me));
d252 5
a256 7
extern void HTAnchor_setTitle PARAMS((
	HTParentAnchor *	me,
	CONST char *		title));

extern void HTAnchor_appendTitle PARAMS((
	HTParentAnchor *	me,
	CONST char *		title));
d260 1
a260 2
extern CONST char * HTAnchor_bookmark PARAMS((
	HTParentAnchor *	me));
d262 2
a263 3
extern void HTAnchor_setBookmark PARAMS((
	HTParentAnchor *	me,
	CONST char *		bookmark));
d267 1
a267 2
extern CONST char * HTAnchor_owner PARAMS((
	HTParentAnchor *	me));
d269 2
a270 3
extern void HTAnchor_setOwner PARAMS((
	HTParentAnchor *	me,
	CONST char *		owner));
d274 1
a274 2
extern CONST char * HTAnchor_RevTitle PARAMS((
	HTParentAnchor *	me));
d276 2
a277 3
extern void HTAnchor_setRevTitle PARAMS((
	HTParentAnchor *	me,
	CONST char *		title));
d281 1
a281 2
extern CONST char * HTAnchor_citehost PARAMS((
	HTParentAnchor *	me));
d283 2
a284 3
extern void HTAnchor_setCitehost PARAMS((
	HTParentAnchor *	me,
	CONST char *		citehost));
d287 6
a292 2
**	(will be loaded if we had a Content-Disposition
**	 header or META element with filename=name.suffix)
d294 5
a298 2
extern CONST char * HTAnchor_SugFname PARAMS((
	HTParentAnchor *	me));
d302 1
a302 2
extern CONST char * HTAnchor_content_type PARAMS((
	HTParentAnchor *	me));
d305 4
a308 5
**	(will be loaded if we had a Content-Encoding
**	 header.)
*/
extern CONST char * HTAnchor_content_encoding PARAMS((
	HTParentAnchor *	me));
d312 1
a312 2
extern CONST char * HTAnchor_last_modified PARAMS((
	HTParentAnchor *	me));
d316 1
a316 2
extern CONST char * HTAnchor_date PARAMS((
	HTParentAnchor *	me));
d320 1
a320 2
extern CONST char * HTAnchor_server PARAMS((
	HTParentAnchor *	me));
d324 1
a324 2
extern BOOL HTAnchor_safe PARAMS((
	HTParentAnchor *	me));
d328 1
a328 2
extern CONST char * HTAnchor_content_base PARAMS((
	HTParentAnchor *	me));
d332 1
a332 2
extern CONST char * HTAnchor_content_location PARAMS((
	HTParentAnchor *	me));
d336 1
a336 2
extern CONST char * HTAnchor_messageID PARAMS((
	HTParentAnchor *	me));
d338 2
a339 3
extern BOOL HTAnchor_setMessageID PARAMS((
	HTParentAnchor *	me,
	CONST char *		messageid));
d343 1
a343 2
extern CONST char * HTAnchor_subject PARAMS((
	HTParentAnchor *	me));
d345 2
a346 3
extern BOOL HTAnchor_setSubject PARAMS((
	HTParentAnchor *	me,
	CONST char *		subject));
d349 3
a351 4
**	---------------------
*/
extern HTAnchor * HTAnchor_followLink PARAMS((
	HTChildAnchor *		me));
d353 2
a354 3
extern HTAnchor * HTAnchor_followTypedLink PARAMS((
	HTChildAnchor *		me,
	HTLinkType *		type));
d357 3
a359 4
**	----------------------
*/
extern HTList * HTAnchor_methods PARAMS((
	HTParentAnchor *	me));
d362 3
a364 4
**	--------
*/
extern void * HTAnchor_protocol PARAMS((
	HTParentAnchor *	me));
d366 2
a367 3
extern void HTAnchor_setProtocol PARAMS((
	HTParentAnchor *	me,
	void *			protocol));
d370 27
a396 4
**	----------------
*/
extern char * HTAnchor_physical PARAMS((
	HTParentAnchor *	me));
d398 4
a401 35
extern void HTAnchor_setPhysical PARAMS((
	HTParentAnchor *	me,
	char *			protocol));

extern LYUCcharset * HTAnchor_getUCInfoStage PARAMS((
	HTParentAnchor *	me,
	int			which_stage));

extern int HTAnchor_getUCLYhndl PARAMS((
	HTParentAnchor *	me,
	int			which_stage));

extern LYUCcharset * HTAnchor_setUCInfoStage PARAMS((
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by));

extern LYUCcharset * HTAnchor_setUCInfoStage PARAMS((
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by));

extern LYUCcharset * HTAnchor_resetUCInfoStage PARAMS((
	HTParentAnchor *	me,
	int			LYhndl,
	int			which_stage,
	int			set_by));

extern LYUCcharset * HTAnchor_copyUCInfoStage PARAMS((
	HTParentAnchor *	me,
	int			to_stage,
	int			from_stage,
	int			set_by));
d403 1
a403 1
extern void ImageMapList_free PARAMS((HTList * list));
d405 4
a408 1
#endif /* HTANCHOR_H */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d18 1
d30 1
a34 1
typedef HTAtom HTLinkType;
d36 15
a50 4
typedef struct {
  HTAnchor *	dest;		/* The anchor to which this leads */
  HTLinkType *	type;		/* Semantics of this link */
} HTLink;
d52 3
a54 6
struct _HTAnchor {		/* Generic anchor : just links */
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;		/* List of extra links from this, if any */
  /* We separate the first link from the others to avoid too many small mallocs
     involved by a list creation.  Most anchors only point to one place. */
  HTParentAnchor * parent;	/* Parent of this anchor (self for adults) */
d57 7
d66 1
a66 3
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;		/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor (self) */
d69 5
a73 5
  HTList *	children;	/* Subanchors of this, if any */
  HTList *	sources;	/* List of anchors pointing to this, if any */
  HyperDoc *	document;	/* The document within which this is an anchor */
  char *	address;	/* Absolute address of this node */
  char *	post_data;	/* Posting data */
a91 1
  BOOL		underway;	/* Document about to be attached to it */
d95 1
a95 1
#ifdef SOURCE_CACHE
d103 1
d123 2
d127 1
a127 3
  HTLink	mainLink;	/* Main (or default) destination of this */
  HTList *	links;		/* List of extra links from this, if any */
  HTParentAnchor * parent;	/* Parent of this anchor */
d130 7
a136 1
  char *	tag;		/* Address of this anchor relative to parent */
d144 6
a149 6
    char * address;
    char * post_data;
    char * post_content_type;
    char * bookmark;
    BOOL   isHEAD;
    BOOL   safe;
d152 2
a153 15
/* "internal" means "within the same document, with certainty".
   It includes a space so it cannot conflict with any (valid) "TYPE"
   attributes on A elements. [According to which DTD, anyway??] - kw */

#define LINK_INTERNAL HTAtom_for("internal link")

/*	Create new or find old sub-anchor
**	---------------------------------
**
**	This one is for a new anchor being edited into an existing
**	document.  The parent anchor must already exist.
*/
extern HTChildAnchor * HTAnchor_findChild PARAMS((
	HTParentAnchor *	parent,
	CONST char *		tag));
d168 2
a169 2
/*	Create new or find old named anchor
**	-----------------------------------
d176 1
a176 1
extern HTAnchor * HTAnchor_findAddress PARAMS((
d185 1
a185 1
extern HTAnchor * HTAnchor_findSimpleAddress PARAMS((
d192 2
a193 2
**	All outgoing links from parent and children are deleted, and this anchor
**	is removed from the sources list of all its targets.
d195 1
a195 1
**	If this anchor's source list is empty, we delete it and its children.
d198 8
d208 1
a208 1
#ifdef SOURCE_CACHE
a212 9
/*		Move an anchor to the head of the list of its siblings
**		------------------------------------------------------
**
**	This is to ensure that an anchor which might have already existed
**	is put in the correct order as we load the document.
*/
extern void HTAnchor_makeLastChild PARAMS((
	HTChildAnchor *		me));

d241 1
a241 1
	char *		address));
d245 1
a245 1
	char *			prompt));
a252 3
extern BOOL HTAnchor_hasChildren PARAMS((
	HTParentAnchor *	me));

a377 8
/*	Link this Anchor to another given one
**	-------------------------------------
*/
extern BOOL HTAnchor_link PARAMS((
	HTAnchor *		source,
	HTAnchor *		destination,
	HTLinkType *		type));

d381 2
a382 2
extern HTAnchor * HTAnchor_followMainLink PARAMS((
	HTAnchor *		me));
d385 1
a385 1
	HTAnchor *		me,
a387 4
extern BOOL HTAnchor_makeMainLink PARAMS((
	HTAnchor *		me,
	HTLink *		movingLink));

a448 4

/*

    */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d18 1
d70 2
a71 1
#ifdef USE_HASH
d82 5
a86 1
  char *	FileCache;	/* Path to a disk-cached copy */
d172 9
d193 5
d250 1
a250 1
#if defined(USE_HASH)
d298 9
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
/* Version 1 of 24-Oct-1991 (JFG), written in C, browser-independant */
d17 3
a19 33
#include "HTList.h"
#include "HTAtom.h"
#include "UCDefs.h"

#ifdef SHORT_NAMES
#define HTAnchor_findChild			HTAnFiCh
#define HTAnchor_findChildAndLink		HTAnFiLi
#define HTAnchor_findAddress			HTAnFiAd
#define HTAnchor_delete 			HTAnDele
#define HTAnchor_makeLastChild			HTAnMaLa
#define HTAnchor_parent 			HTAnPare
#define HTAnchor_setDocument			HTAnSeDo
#define HTAnchor_document			HTAnDocu
#define HTAnchor_setFormat			HTAnSeFo
#define HTAnchor_format 			HTAnForm
#define HTAnchor_setIndex			HTAnSeIn
#define HTAnchor_setPrompt			HTAnSePr
#define HTAnchor_isIndex			HTAnIsIn
#define HTAnchor_address			HTAnAddr
#define HTAnchor_hasChildren			HTAnHaCh
#define HTAnchor_title				HTAnTitl
#define HTAnchor_setTitle			HTAnSeTi
#define HTAnchor_appendTitle			HTAnApTi
#define HTAnchor_link				HTAnLink
#define HTAnchor_followMainLink 		HTAnFoMa
#define HTAnchor_followTypedLink		HTAnFoTy
#define HTAnchor_makeMainLink			HTAnMaMa
#define HTAnchor_setProtocol			HTAnSePr
#define HTAnchor_protocol			HTAnProt
#define HTAnchor_physical			HTAnPhys
#define HTAnchor_setPhysical			HTAnSePh
#define HTAnchor_methods			HtAnMeth
#endif /* SHORT_NAMES */
d30 1
a30 1
#include "HTFormat.h"
d43 1
a43 1
     involved by a list creation. Most anchors only point to one place. */
d60 2
a61 2
  char *	bookmark;	/* Bookmark filname */
  HTFormat	format; 	/* Pointer to node format descriptor */
d78 1
a78 1
  BOOL		isHEAD; 	/* Document is headers from a HEAD request */
d88 1
a88 1
  char *	content_disposition;	/* Content-Dispositon */
d91 3
a93 1
  int		content_length; 	/* Content-Length */
d97 2
a98 1
  char *	server; 		/* Server */
d136 1
a136 1
**	document. The parent anchor must already exist.
d150 4
a153 4
      HTParentAnchor * parent,	/* May not be 0 */
      CONST char * tag, 	/* May be "" or 0 */
      CONST char * href,	/* May be "" or 0 */
      HTLinkType * ltype));	/* May be 0 */
d185 1
a185 1
	HTChildAnchor * 	me));
a199 6
/* We don't want code to change an address after anchor creation... yet ?
extern void HTAnchor_setAddress PARAMS((
	HTAnchor *		me,
	char *			addr));
*/

d327 18
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
