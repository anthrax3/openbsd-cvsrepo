head	1.7;
access;
symbols
	OPENBSD_5_5:1.5.0.22
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.18
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.16
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.14
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.12
	OPENBSD_5_0:1.5.0.10
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.23.19.13.24;	author deraadt;	state dead;
branches;
next	1.6;
commitid	EcR8E7r0stjLUV4p;

1.6
date	2014.07.09.04.11.34;	author daniel;	state Exp;
branches;
next	1.5;
commitid	lGGuvDWEniklWrQe;

1.5
date	2009.05.31.09.16.51;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.42;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.36;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.16.46;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.44;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.44;	author maja;	state Exp;
branches;
next	;


desc
@@


1.7
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTChunk.h,v 1.20 2010/09/24 08:37:39 tom Exp $
 *
 *				     HTChunk: Flexible array handling for libwww
 *					CHUNK HANDLING:
 *					FLEXIBLE ARRAYS
 *
 * This module implements a flexible array.  It is a general utility module.  A
 * chunk is a structure which may be extended.	These routines create and
 * append data to chunks, automatically reallocating them as necessary.
 *
 */
#ifndef HTCHUNK_H
#define HTCHUNK_H 1

#ifndef HTUTILS_H
#include <HTUtils.h>
#endif

#include <UCMap.h>

#ifdef __cplusplus
extern "C" {
#endif
    typedef struct _HTChunk HTChunk;

    struct _HTChunk {
	int size;		/* In bytes                     */
	int growby;		/* Allocation unit in bytes     */
	int allocated;		/* Current size of *data        */
	char *data;		/* Pointer to malloc'd area or 0 */
	int failok;		/* allowed to fail without exiting program? */
	HTChunk *next;		/* pointer to the next chunk */
    };

/*
 * Initialize a chunk's allocation data and allocation-increment.
 */
    extern void HTChunkInit(HTChunk *ch, int grow);

/*
 *
 * Create new chunk
 *
 *   ON ENTRY,
 *
 *   growby		The number of bytes to allocate at a time when the chunk
 *			is later extended.  Arbitrary but normally a trade-off
 *			of time vs memory.
 *
 *   ON EXIT,
 *
 *   returns		A chunk pointer to the new chunk,
 *
 */

    extern HTChunk *HTChunkCreate(int growby);

/*
 *  Create a chunk for which an allocation error is not a fatal application
 *  error if failok != 0, but merely resets the chunk.  When using a chunk
 *  created this way, the caller should always check whether the contents
 *  are ok each time after data have been appended.
 *  The create call may also fail and will reurn NULL in that case. - kw
 */
    extern HTChunk *HTChunkCreateMayFail(int growby, int failok);

/*
 *  Like HTChunkCreate but with initial allocation - kw
 *
 */
    extern HTChunk *HTChunkCreate2(int growby, size_t needed);

/*
 *
 * Free a chunk
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   ON EXIT,
 *
 *   ch			is invalid and may not be used.
 *
 */

    extern void HTChunkFree(HTChunk *ch);

/*
 *
 * Clear a chunk
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   ON EXIT,
 *
 *   *ch		The size of the chunk is zero.
 *
 */

    extern void HTChunkClear(HTChunk *ch);

/*
 *
 * Realloc a chunk
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   growby		growby
 *
 *   ON EXIT,
 *
 *   *ch		Expanded by growby
 *
 */

    extern BOOL HTChunkRealloc(HTChunk *ch, int growby);

/*
 *
 * Ensure a chunk has a certain space in
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   s			The size required
 *
 *   ON EXIT,
 *
 *   *ch		Has size at least s
 *
 */

    extern void HTChunkEnsure(HTChunk *ch, int s);

/*
 *
 * Append a character to a  chunk
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   c			The character to be appended
 *
 *   ON EXIT,
 *
 *   *ch		Is one character bigger
 *
 */
    extern void HTChunkPutc(HTChunk *ch, unsigned c);

    extern void HTChunkPutb(HTChunk *ch, const char *b, int l);

    extern void HTChunkPutUtf8Char(HTChunk *ch, UCode_t code);

/*
 * Append a string to a  chunk
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   str		Points to a zero-terminated string to be appended
 *
 *   ON EXIT,
 *
 *   *ch		Is bigger by strlen(str)
 *
 */

    extern void HTChunkPuts(HTChunk *ch, const char *str);

/*
 *
 * Append a zero character to a  chunk
 *
 */

/*
 *
 *   ON ENTRY,
 *
 *   ch			A valid chunk pointer made by HTChunkCreate()
 *
 *   ON EXIT,
 *
 *   *ch		Is one character bigger
 *
 */

    extern void HTChunkTerminate(HTChunk *ch);

/* like the above but no realloc: extend to another chunk if necessary */
/*
 *
 * Append a character (string, data) to a chunk
 *
 *   ON ENTRY,
 *
 *   ch                        A valid chunk pointer made by HTChunkCreate()
 *
 *   c                 The character to be appended
 *
 *   ON EXIT,
 *
 *   returns           original chunk or a pointer to the new chunk
 *                     (orginal chunk is referenced to the new one
 *                     by the field 'next')
 *
 */
    extern HTChunk *HTChunkPutc2(HTChunk *ch, int c);
    extern HTChunk *HTChunkPuts2(HTChunk *ch, const char *str);
    extern HTChunk *HTChunkPutb2(HTChunk *ch, const char *b, int l);

/* New pool infrastructure: UNlike the above, store data using alignment */
    extern HTChunk *HTChunkPutb0(HTChunk *ch, const char *b, int l);

#ifdef __cplusplus
}
#endif
#endif				/* HTCHUNK_H */
@


1.6
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*						  HTChunk: Flexible array handling for libwww
d157 1
a157 1
    extern void HTChunkPutc(HTChunk *ch, char c);
d218 1
a218 1
    extern HTChunk *HTChunkPutc2(HTChunk *ch, char c);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d19 13
a31 8
typedef struct {
	int	size;		/* In bytes			*/
	int	growby;		/* Allocation unit in bytes	*/
	int	allocated;	/* Current size of *data	*/
	char *	data;		/* Pointer to malloced area or 0 */
	int	failok;		/* allowed to fail without exiting program? */
} HTChunk;

d36 1
a36 1
extern void HTChunkInit PARAMS((HTChunk * ch, int grow));
d54 1
a54 1
extern HTChunk * HTChunkCreate PARAMS((int growby));
d63 1
a63 1
extern HTChunk * HTChunkCreateMayFail PARAMS((int growby, int failok));
d69 1
a69 2
extern HTChunk * HTChunkCreate2 PARAMS((int growby, size_t needed));

d85 1
a85 2
extern void HTChunkFree PARAMS((HTChunk * ch));

d101 1
a101 2
extern void HTChunkClear PARAMS((HTChunk * ch));

d119 1
a119 2
extern BOOL HTChunkRealloc PARAMS((HTChunk * ch, int growby));

d137 1
a137 2
extern void HTChunkEnsure PARAMS((HTChunk * ch, int s));

d154 1
a154 1
extern void HTChunkPutc PARAMS((HTChunk * ch, char c));
d156 1
a156 1
extern void HTChunkPutb PARAMS((HTChunk * ch, CONST char *b, int l));
d158 1
a158 1
extern void HTChunkPutUtf8Char PARAMS((HTChunk * ch, UCode_t code));
d175 1
a175 3

extern void HTChunkPuts PARAMS((HTChunk * ch, CONST char *str));

d195 23
d219 2
a220 1
extern void HTChunkTerminate PARAMS((HTChunk * ch));
d222 4
a225 1
#endif /* HTCHUNK_H */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d16 1
a16 1
 
d21 1
a21 1
	int	growby; 	/* Allocation unit in bytes	*/
d73 1
a73 1
 *   ch 		A valid chunk pointer made by HTChunkCreate()
d77 1
a77 1
 *   ch 		is invalid and may not be used.
d90 1
a90 1
 *   ch 		A valid chunk pointer made by HTChunkCreate()
d103 19
d126 1
a126 1
 *   ch 		A valid chunk pointer made by HTChunkCreate()
d145 1
a145 1
 *   ch 		A valid chunk pointer made by HTChunkCreate()
d165 1
a165 1
 *   ch 		A valid chunk pointer made by HTChunkCreate()
d167 1
a167 1
 *   str		Tpoints to a zero-terminated string to be appended
d189 1
a189 1
 *   ch 		A valid chunk pointer made by HTChunkCreate()
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d24 1
d29 5
d50 9
@


1.1
log
@Initial revision
@
text
@d1 8
a8 8
/*                                                HTChunk: Flexible array handling for libwww
                                     CHUNK HANDLING:
                                     FLEXIBLE ARRAYS
                                             
   This module implements a flexible array. It is a general utility module. A chunk is a
   structure which may be extended.  These routines create and append data to chunks,
   automatically reallocating them as necessary.
   
d10 8
a17 1
#include "UCMap.h"
d20 4
a23 4
        int     size;           /* In bytes                     */
        int     growby;         /* Allocation unit in bytes     */
        int     allocated;      /* Current size of *data        */
        char *  data;           /* Pointer to malloced area or 0 */
a26 10
#ifdef SHORT_NAMES
#define HTChunkClear            HTChClea
#define HTChunkPutc             HTChPutc
#define HTChunkPuts             HTChPuts
#define HTChunkCreate           HTChCrea
#define HTChunkTerminate        HTChTerm
#define HTChunkEnsure           HtChEnsu
#endif


d28 13
a40 13

Create new chunk

  ON ENTRY,
  
  growby                  The number of bytes to allocate at a time when the chunk is
                         later extended. Arbitrary but normally a trade-off time vs.
                         memory
                         
  ON EXIT,
  
  returns                 A chunk pointer to the new chunk,
                         
d53 11
a63 11

Free a chunk

  ON ENTRY,
  
  ch                      A valid chunk pointer made by HTChunkCreate()
                         
  ON EXIT,
  
  ch                      is invalid and may not be used.
                         
d70 11
a80 11

Clear a chunk

  ON ENTRY,
  
  ch                      A valid chunk pointer made by HTChunkCreate()
                         
  ON EXIT,
  
  *ch                     The size of the chunk is zero.
                         
d87 13
a99 13

Ensure a chunk has a certain space in

  ON ENTRY,
  
  ch                      A valid chunk pointer made by HTChunkCreate()
                         
  s                       The size required
                         
  ON EXIT,
  
  *ch                     Has size at least s
                         
d106 13
a118 13

Append a character to a  chunk

  ON ENTRY,
  
  ch                      A valid chunk pointer made by HTChunkCreate()
                         
  c                       The character to be appended
                         
  ON EXIT,
  
  *ch                     Is one character bigger
                         
d127 12
a138 12
Append a string to a  chunk

  ON ENTRY,
  
  ch                      A valid chunk pointer made by HTChunkCreate()
                         
  str                     Tpoints to a zero-terminated string to be appended
                         
  ON EXIT,
  
  *ch                     Is bigger by strlen(str)
                         
d142 1
a142 1
extern void HTChunkPuts PARAMS((HTChunk * ch, const char *str));
d146 3
a148 3

Append a zero character to a  chunk

d152 9
a160 9

  ON ENTRY,
  
  ch                      A valid chunk pointer made by HTChunkCreate()
                         
  ON EXIT,
  
  *ch                     Is one character bigger
                         
d166 1
a166 3
/*

   end */
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
