head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.12;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYStyle.c,v 1.96 2014/01/09 21:01:22 tom Exp $
 *
 * character level styles for Lynx
 * (c) 1996 Rob Partington -- donated to the Lyncei (if they want it :-)
 */
#include <HTUtils.h>
#include <HTML.h>
#include <LYGlobalDefs.h>

#include <LYStructs.h>
#include <LYReadCFG.h>
#include <LYCurses.h>
#include <LYCharUtils.h>
#include <LYUtils.h>		/* defines TABLESIZE */
#include <AttrList.h>
#include <SGML.h>
#include <HTMLDTD.h>

/* Hash table definitions */
#include <LYHash.h>
#include <LYStyle.h>

#include <LYOptions.h>
#include <LYPrettySrc.h>

#include <LYexit.h>
#include <LYLeaks.h>
#include <LYStrings.h>
#include <LYHash.h>

#define CTRACE1(p) CTRACE2(TRACE_CFG || TRACE_STYLE, p)

#ifdef USE_COLOR_STYLE

static HTList *list_of_lss_files;

/* because curses isn't started when we parse the config file, we
 * need to remember the STYLE: lines we encounter and parse them
 * after curses has started
 */
static HTList *lss_styles = NULL;

#define CACHEW 128
#define CACHEH 64

static unsigned *cached_styles_ptr = NULL;
static int cached_styles_rows = 0;
static int cached_styles_cols = 0;

/* stack of attributes during page rendering */
int last_styles[MAX_LAST_STYLES + 1] =
{0};
int last_colorattr_ptr = 0;

bucket hashStyles[CSHASHSIZE];

int cached_tag_styles[HTML_ELEMENTS];
int current_tag_style;
BOOL force_current_tag_style = FALSE;
char *forced_classname;
BOOL force_classname;

/* Remember the hash codes for common elements */
int s_a = NOSTYLE;
int s_aedit = NOSTYLE;
int s_aedit_arr = NOSTYLE;
int s_aedit_pad = NOSTYLE;
int s_aedit_sel = NOSTYLE;
int s_alert = NOSTYLE;
int s_alink = NOSTYLE;
int s_curedit = NOSTYLE;
int s_forw_backw = NOSTYLE;
int s_hot_paste = NOSTYLE;
int s_menu_active = NOSTYLE;
int s_menu_bg = NOSTYLE;
int s_menu_entry = NOSTYLE;
int s_menu_frame = NOSTYLE;
int s_menu_number = NOSTYLE;
int s_menu_sb = NOSTYLE;
int s_normal = NOSTYLE;
int s_prompt_edit = NOSTYLE;
int s_prompt_edit_arr = NOSTYLE;
int s_prompt_edit_pad = NOSTYLE;
int s_prompt_sel = NOSTYLE;
int s_status = NOSTYLE;
int s_title = NOSTYLE;
int s_whereis = NOSTYLE;

#ifdef USE_SCROLLBAR
int s_sb_aa = NOSTYLE;
int s_sb_bar = NOSTYLE;
int s_sb_bg = NOSTYLE;
int s_sb_naa = NOSTYLE;
#endif

/* start somewhere safe */
#define MAX_COLOR 16
static int colorPairs = 0;

#ifdef USE_BLINK
#  define MAX_BLINK	2
#  define M_BLINK	A_BLINK
#else
#  define MAX_BLINK	1
#  define M_BLINK	0
#endif

#define MAX_PAIR 255		/* because our_pairs[] type is unsigned-char */
static unsigned char our_pairs[2]
[MAX_BLINK]
[MAX_COLOR + 1]
[MAX_COLOR + 1];

static void style_initialiseHashTable(void);

static bucket *new_bucket(const char *name)
{
    bucket *result = typecalloc(bucket);

    if (!result)
	outofmem(__FILE__, "new_bucket");
    StrAllocCopy(result->name, name);
    return result;
}

#if OMIT_SCN_KEEPING
bucket *special_bucket(void)
{
    return new_bucket("<special>");
}
#endif

bucket *nostyle_bucket(void)
{
    return new_bucket("<NOSTYLE>");
}

static char *TrimLowercase(char *buffer)
{
    LYRemoveBlanks(buffer);
    strtolower(buffer);
    return buffer;
}

/*
 * Parse a string containing a combination of video attributes and color.
 */
static void parse_either(const char *attrs,
			 int dft_color,
			 int *monop,
			 int *colorp)
{
    int value;
    char *temp_attrs = NULL;

    if (StrAllocCopy(temp_attrs, attrs) != NULL) {
	char *to_free = temp_attrs;

	while (*temp_attrs != '\0') {
	    char *next = StrChr(temp_attrs, '+');
	    char save = (char) ((next != NULL) ? *next : '\0');

	    if (next == NULL)
		next = temp_attrs + strlen(temp_attrs);

	    if (save != 0)
		*next = '\0';
	    if ((value = string_to_attr(temp_attrs)) != 0)
		*monop |= value;
	    else if (colorp != 0
		     && (value = check_color(temp_attrs, dft_color)) != ERR_COLOR)
		*colorp = value;

	    temp_attrs = next;
	    if (save != '\0')
		*temp_attrs++ = save;
	}
	FREE(to_free);
    }
}

/* icky parsing of the style options */
static void parse_attributes(const char *mono,
			     const char *fg,
			     const char *bg,
			     int style,
			     const char *element)
{
    int mA = A_NORMAL;
    int fA = default_fg;
    int bA = default_bg;
    int cA = A_NORMAL;
    int newstyle = hash_code(element);
    int colored_attr;

    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n",
			  style, newstyle, element));

    parse_either(mono, ERR_COLOR, &mA, (int *) 0);
    parse_either(bg, default_bg, &cA, &bA);
    parse_either(fg, default_fg, &cA, &fA);

    if (style == -1) {		/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n",
			      fA, bA));
	default_fg = fA;
	default_bg = bA;
	default_color_reset = TRUE;
	return;
    }
    if (fA == NO_COLOR) {
	bA = NO_COLOR;
    } else if (COLORS) {
#ifdef USE_BLINK
	if (term_blink_is_boldbg) {
	    if (fA >= COLORS)
		cA = A_BOLD;
	    if (bA >= COLORS)
		cA |= M_BLINK;
	} else
#endif
	if (fA >= COLORS || bA >= COLORS)
	    cA = A_BOLD;
	if (fA >= COLORS)
	    fA %= COLORS;
	if (bA >= COLORS)
	    bA %= COLORS;
    } else {
	cA = A_BOLD;
	fA = NO_COLOR;
	bA = NO_COLOR;
    }

    /*
     * If we have colour, and space to create a new colour attribute,
     * and we have a valid colour description, then add this style
     */
    if (lynx_has_color && colorPairs < COLOR_PAIRS - 1 && fA != NO_COLOR) {
	int curPair = 0;
	int iFg = (1 + (fA >= 0 ? fA : 0));
	int iBg = (1 + (bA >= 0 ? bA : 0));
	int iBold = !!((unsigned) cA & A_BOLD);
	int iBlink = !!((unsigned) cA & M_BLINK);

	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n",
			      fA, default_fg, bA, default_bg, cA));
	if (fA < MAX_COLOR
	    && bA < MAX_COLOR
#ifdef USE_CURSES_PAIR_0
	    && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
#endif
	    && curPair < MAX_PAIR) {
	    if (our_pairs[iBold][iBlink][iFg][iBg] != 0) {
		curPair = our_pairs[iBold][iBlink][iFg][iBg];
	    } else {
		curPair = ++colorPairs;
		init_pair((short) curPair, (short) fA, (short) bA);
		our_pairs[iBold][iBlink][iFg][iBg] = UCH(curPair);
	    }
	}
	CTRACE2(TRACE_STYLE, (tfp, "CSS(CURPAIR):%d\n", curPair));
	colored_attr = ((int) COLOR_PAIR(curPair)) | ((int) cA);
	if (style < DSTYLE_ELEMENTS)
	    setStyle(style, colored_attr, cA, mA);
	setHashStyle(newstyle, colored_attr, cA, mA, element);
    } else {
	if (lynx_has_color && fA != NO_COLOR) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n",
		     COLOR_PAIRS - 1));
	}
	/* only mono is set */
	if (style < DSTYLE_ELEMENTS)
	    setStyle(style, -1, -1, mA);
	setHashStyle(newstyle, -1, -1, mA, element);
    }
}

/* parse a style option of the format
 * STYLE:<OBJECT>:FG:BG
 */
static void parse_style(char *param)
{
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	int style;
	int *set_hash;
    } table[] = {
	{ "default",		-1,			0 }, /* default fg/bg */
	{ "alink",		DSTYLE_ALINK,		0 }, /* active link */
	{ "a",			DSTYLE_LINK,		0 }, /* normal link */
	{ "a",			HTML_A,			0 }, /* normal link */
	{ "status",		DSTYLE_STATUS,		0 }, /* status bar */
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]'s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]'s */
	{ "normal",		DSTYLE_NORMAL,		0 },
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]'s */
	{ "whereis",		DSTYLE_WHEREIS,		&s_whereis },
	{ "edit.active.pad",	DSTYLE_ELEMENTS,	&s_aedit_pad },
	{ "edit.active.arrow",	DSTYLE_ELEMENTS,	&s_aedit_arr },
	{ "edit.active.marked",	DSTYLE_ELEMENTS,	&s_aedit_sel },
	{ "edit.active",	DSTYLE_ELEMENTS,	&s_aedit },
	{ "edit.current",	DSTYLE_ELEMENTS,	&s_curedit },
	{ "edit.prompt.pad",	DSTYLE_ELEMENTS,	&s_prompt_edit_pad },
	{ "edit.prompt.arrow",	DSTYLE_ELEMENTS,	&s_prompt_edit_arr },
	{ "edit.prompt.marked",	DSTYLE_ELEMENTS,	&s_prompt_sel },
	{ "edit.prompt",	DSTYLE_ELEMENTS,	&s_prompt_edit },
	{ "forwbackw.arrow",	DSTYLE_ELEMENTS,	&s_forw_backw },
	{ "hot.paste",		DSTYLE_ELEMENTS,	&s_hot_paste },
	{ "menu.frame",		DSTYLE_ELEMENTS,	&s_menu_frame },
	{ "menu.bg",		DSTYLE_ELEMENTS,	&s_menu_bg },
	{ "menu.n",		DSTYLE_ELEMENTS,	&s_menu_number },
	{ "menu.entry",		DSTYLE_ELEMENTS,	&s_menu_entry },
	{ "menu.active",	DSTYLE_ELEMENTS,	&s_menu_active },
	{ "menu.sb",		DSTYLE_ELEMENTS,	&s_menu_sb },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOL found = FALSE;

    char *buffer = 0;
    char *tmp = 0;
    char *element, *mono;
    const char *fg, *bg;

    if (param == 0)
	return;
    CTRACE2(TRACE_STYLE, (tfp, "parse_style(%s)\n", param));
    StrAllocCopy(buffer, param);
    if (buffer == 0)
	return;

    TrimLowercase(buffer);
    if ((tmp = StrChr(buffer, ':')) == 0) {
	fprintf(stderr, gettext("\
Syntax Error parsing style in lss file:\n\
[%s]\n\
The line must be of the form:\n\
OBJECT:MONO:COLOR (ie em:bold:brightblue:white)\n\
where OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n\n"), buffer);
	exit_immediately(EXIT_FAILURE);
    }
    *tmp = '\0';
    element = buffer;

    mono = tmp + 1;
    tmp = StrChr(mono, ':');

    if (!tmp) {
	fg = "nocolor";
	bg = "nocolor";
    } else {
	*tmp = '\0';
	fg = tmp + 1;
	tmp = StrChr(fg, ':');
	if (!tmp)
	    bg = "default";
	else {
	    *tmp = '\0';
	    bg = tmp + 1;
	}
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSSPARSE:%s => %d %s\n",
			  element, hash_code(element),
			  (hashStyles[hash_code(element)].name ? "used" : "")));

    /*
     * We use some pseudo-elements, so catch these first
     */
    for (n = 0; n < TABLESIZE(table); n++) {
	if (!strcasecomp(element, table[n].name)) {
	    parse_attributes(mono, fg, bg, table[n].style, table[n].name);
	    if (table[n].set_hash != 0)
		*(table[n].set_hash) = hash_code(table[n].name);
	    found = TRUE;
	    break;
	}
    }

    if (found) {
	if (!strcasecomp(element, "normal")) {
	    /* added - kw */
	    parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	    s_normal = hash_code("html");	/* rather bizarre... - kw */

	    LYnormalColor();
	}
    } else {
	/* It must be a HTML element, so look through the list until we find it. */
	int element_number = -1;
	HTTag *t = SGMLFindTag(&HTML_dtd, element);

	if (t && t->name) {
	    element_number = (int) (t - HTML_dtd.tags);
	}
	if (element_number >= HTML_A &&
	    element_number < HTML_ELEMENTS) {
	    parse_attributes(mono, fg, bg, element_number + STARTAT, element);
	} else {
	    parse_attributes(mono, fg, bg, DSTYLE_ELEMENTS, element);
	}
    }
    FREE(buffer);
}

static void style_deleteStyleList(void)
{
    LYFreeStringList(lss_styles);
    lss_styles = NULL;
}

#ifdef LY_FIND_LEAKS
static void free_colorstyle_leaks(void)
{
    LSS_NAMES *obj;

    while ((obj = HTList_objectAt(list_of_lss_files, 0)) != 0) {
	if (HTList_unlinkObject(list_of_lss_files, obj)) {
	    FREE(obj->given);
	    FREE(obj->actual);
	    FREE(obj);
	} else {
	    break;
	}
    }
    HTList_delete(list_of_lss_files);
}
#endif

static void free_colorstylestuff(void)
{
    style_initialiseHashTable();
    style_deleteStyleList();
    memset(our_pairs, 0, sizeof(our_pairs));
    FreeCachedStyles();
}

/* Set all the buckets in the hash table to be empty */
static void style_initialiseHashTable(void)
{
    int i;
    static int firsttime = 1;

    for (i = 0; i < CSHASHSIZE; i++) {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono = 0;
    }
    if (firsttime) {
	firsttime = 0;
#ifdef LY_FIND_LEAKS
	atexit(free_colorstylestuff);
	atexit(free_colorstyle_leaks);
#endif
    }
    s_alink = hash_code("alink");
    s_a = hash_code("a");
    s_status = hash_code("status");
    s_alert = hash_code("alert");
    s_title = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg = hash_code("scroll.back");
    s_sb_aa = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
#endif
}

/*
 * Initialise the default style sheet to match the vanilla-curses lynx.
 */
static void initialise_default_stylesheet(void)
{
    /* Use the data setup in USE_COLOR_TABLE */
    /* *INDENT-OFF* */
    static const struct {
	int		color;	/* index into lynx_color_pairs[] */
	const char	*type;
    } table2[] = {
	/*
	 * non-color-style colors encode bold/reverse/underline as a 0-7
	 * index like this:
	 *  b,r,u 0
	 *  b,r,U 1
	 *  b,R,u 2
	 *  b,R,U 3
	 *  B,r,u 4
	 *  B,r,U 5
	 *  B,R,u 6
	 *  B,R,U 7
	 */
	{ 0,	"normal" },
	{ 1,	"a" },
	{ 2,	"status" },
	{ 4,	"b" },
	{ 4,	"blink" },
	{ 4,	"cite" },
	{ 4,	"del" },
	{ 4,	"em" },
	{ 4,	"i" },
	{ 4,	"ins" },
	{ 4,	"strike" },
	{ 4,	"strong" },
	{ 4,	"u" },
	{ 5,	"input" },
	{ 6,	"alink" },
	{ 7,	"whereis" },
#ifdef USE_PRETTYSRC
	/* FIXME: HTL_tagspecs_defaults[] has similar info */
	{ 4,	"span.htmlsrc_comment" },
	{ 4,	"span.htmlsrc_tag" },
	{ 4,	"span.htmlsrc_attrib" },
	{ 4,	"span.htmlsrc_attrval" },
	{ 4,	"span.htmlsrc_abracket" },
	{ 4,	"span.htmlsrc_entity" },
	{ 4,	"span.htmlsrc_href" },
	{ 4,	"span.htmlsrc_entire" },
	{ 4,	"span.htmlsrc_badseq" },
	{ 4,	"span.htmlsrc_badtag" },
	{ 4,	"span.htmlsrc_badattr" },
	{ 4,	"span.htmlsrc_sgmlspecial" },
#endif
    };
    /* *INDENT-ON* */

    unsigned n;
    char *normal = LYgetTableString(0);
    char *strong = LYgetTableString(4);

    CTRACE1((tfp, "initialise_default_stylesheet\n"));

    /*
     * For debugging this function, create hash codes for all of the tags.
     * That makes it simpler to find the cases that are overlooked in the
     * table.
     */
    for (n = 0; n < (unsigned) HTML_dtd.number_of_tags; ++n) {
	char *name = 0;

	HTSprintf0(&name, "%s:%s", HTML_dtd.tags[n].name, normal);
	parse_style(name);
	FREE(name);
    }

    for (n = 0; n < TABLESIZE(table2); ++n) {
	int code = table2[n].color;
	char *name = 0;
	char *value = 0;

	switch (code) {
	case 0:
	    value = normal;
	    break;
	case 4:
	    value = strong;
	    break;
	default:
	    value = LYgetTableString(code);
	    break;
	}
	HTSprintf0(&name, "%s:%s", table2[n].type, value);
	parse_style(name);
	FREE(name);
	if (value != normal && value != strong && value != 0)
	    free(value);
    }
    FREE(normal);
    FREE(strong);
}

void parse_userstyles(void)
{
    char *name;
    HTList *cur = LYuse_color_style ? lss_styles : 0;

    colorPairs = 0;
    style_initialiseHashTable();

    if (HTList_isEmpty(cur)) {
	initialise_default_stylesheet();
    } else {
	while ((name = (char *) HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n",
				  (name
				   ? name
				   : "!?! empty !?!")));
	    if (name != NULL)
		parse_style(name);
	}
    }

#define dft_style(a,b) if (a == NOSTYLE) a = b
    /* *INDENT-OFF* */
    dft_style(s_prompt_edit,		s_normal);
    dft_style(s_prompt_edit_arr,	s_prompt_edit);
    dft_style(s_prompt_edit_pad,	s_prompt_edit);
    dft_style(s_prompt_sel,		s_prompt_edit);
    dft_style(s_aedit,			s_alink);
    dft_style(s_aedit_arr,		s_aedit);
    dft_style(s_aedit_pad,		s_aedit);
    dft_style(s_curedit,		s_aedit);
    dft_style(s_aedit_sel,		s_aedit);
    dft_style(s_menu_bg,		s_normal);
    dft_style(s_menu_entry,		s_menu_bg);
    dft_style(s_menu_frame,		s_menu_bg);
    dft_style(s_menu_number,		s_menu_bg);
    dft_style(s_menu_active,		s_alink);
    /* *INDENT-ON* */

}

/* Add a STYLE: option line to our list.  Process "default:" early
 * for it to have the same semantic as other lines: works at any place
 * of the style file, the first line overrides the later ones.
 */
static void HStyle_addStyle(char *buffer)
{
    char *name = NULL;

    CTRACE1((tfp, "HStyle_addStyle(%s)\n", buffer));

    StrAllocCopy(name, buffer);
    TrimLowercase(name);

    if (lss_styles == NULL)
	lss_styles = HTList_new();

    if (!strncasecomp(name, "default:", 8)) {
	/* default fg/bg */
	CTRACE2(TRACE_STYLE, (tfp, "READCSS.default%s:%s\n",
			      (default_color_reset ? ".ignore" : ""),
			      name ? name : "!?! empty !?!"));
	if (!default_color_reset)
	    parse_style(name);
	FREE(name);
	return;			/* do not need to process it again */
    }
    CTRACE2(TRACE_STYLE, (tfp, "READCSS:%s\n", name ? name : "!?! empty !?!"));
    HTList_addObject(lss_styles, name);
}

static int style_readFromFileREC(char *lss_filename,
				 char *parent_filename)
{
    FILE *fh;
    char *buffer = NULL;

    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n",
			  lss_filename ? lss_filename : "?!? empty ?!?"));
    if (isEmpty(lss_filename))
	return -1;
    if ((fh = LYOpenCFG(lss_filename, parent_filename, LYNX_LSS_FILE)) == 0) {
	/* this should probably be an alert or something */
	CTRACE2(TRACE_STYLE, (tfp,
			      "CSS:Can't open style file '%s', using defaults\n", lss_filename));
	return -1;
    }

    if (parent_filename == 0) {
	free_colorstylestuff();
    }

    while (LYSafeGets(&buffer, fh) != NULL) {
	LYTrimTrailing(buffer);
	LYTrimTail(buffer);
	LYTrimHead(buffer);
	if (!strncasecomp(buffer, "include:", 8))
	    style_readFromFileREC(LYSkipBlanks(buffer + 8), lss_filename);
	else if (buffer[0] != '#' && strlen(buffer) != 0)
	    HStyle_addStyle(buffer);
    }

    LYCloseInput(fh);
    if ((parent_filename == 0) && LYCursesON)
	parse_userstyles();
    return 0;
}

int style_readFromFile(char *filename)
{
    return style_readFromFileREC(filename, (char *) 0);
}

/* Used in HTStructured methods: - kw */

void TrimColorClass(const char *tagname,
		    char *styleclassname,
		    int *phcode)
{
    char *end, *start = NULL, *lookfrom;
    char tmp[64];

    sprintf(tmp, ";%.*s", (int) sizeof(tmp) - 3, tagname);
    TrimLowercase(tmp);

    if ((lookfrom = styleclassname) != 0) {
	do {
	    end = start;
	    start = strstr(lookfrom, tmp);
	    if (start)
		lookfrom = start + 1;
	}
	while (start);
	/* trim the last matching element off the end
	 * - should match classes here as well (rp)
	 */
	if (end)
	    *end = '\0';
    }
    *phcode = hash_code(lookfrom && *lookfrom ? lookfrom : &tmp[1]);
}

/* This function is designed as faster analog to TrimColorClass.
 * It assumes that tag_name is present in stylename! -HV
 */
void FastTrimColorClass(const char *tag_name,
			unsigned name_len,
			char *stylename,
			char **pstylename_end,	/*will be modified */
			int *phcode)	/*will be modified */
{
    char *tag_start = *pstylename_end;
    BOOLEAN found = FALSE;

    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.fast-trim: [%s] from [%s]: ",
	     tag_name, stylename));
    while (tag_start >= stylename) {
	for (; (tag_start >= stylename) && (*tag_start != ';'); --tag_start) ;
	if (!strncasecomp(tag_start + 1, tag_name, (int) name_len)) {
	    found = TRUE;
	    break;
	}
	--tag_start;
    }
    if (found) {
	*tag_start = '\0';
	*pstylename_end = tag_start;
    }
    CTRACE2(TRACE_STYLE, (tfp, found ? "success.\n" : "failed.\n"));
    *phcode = hash_code(tag_start + 1);
}

/* This is called each time lss styles are read. It will fill
 * each element of 'cached_tag_styles' -HV
 */
void cache_tag_styles(void)
{
    char buf[200];
    int i;

    for (i = 0; i < HTML_ELEMENTS; ++i) {
	LYStrNCpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
	LYLowerCase(buf);
	cached_tag_styles[i] = hash_code(buf);
    }
}

#define SIZEOF_CACHED_STYLES (unsigned) (cached_styles_rows * cached_styles_cols)

static unsigned *RefCachedStyle(int y, int x)
{
    unsigned *result = 0;

    if (cached_styles_ptr == 0) {
	cached_styles_rows = display_lines;
	cached_styles_cols = LYcols;
	cached_styles_ptr = typecallocn(unsigned, SIZEOF_CACHED_STYLES);
    }
    if (y >= 0 &&
	x >= 0 &&
	y < cached_styles_rows &&
	x < cached_styles_cols) {
	result = cached_styles_ptr + (y * cached_styles_cols) + x;
    }
    return result;
}

BOOL ValidCachedStyle(int y, int x)
{
    return (BOOL) (RefCachedStyle(y, x) != 0);
}

unsigned GetCachedStyle(int y, int x)
{
    unsigned value = 0;
    unsigned *cache = RefCachedStyle(y, x);

    if (cache != 0) {
	value = *cache;
    }
    return value;
}

void SetCachedStyle(int y, int x, unsigned value)
{
    unsigned *cache = RefCachedStyle(y, x);

    if (cache != 0) {
	*cache = value;
    }
}

void ResetCachedStyles(void)
{
    if (cached_styles_ptr != NULL) {
	memset(cached_styles_ptr, 0, sizeof(unsigned) * SIZEOF_CACHED_STYLES);
    }
}

void FreeCachedStyles(void)
{
    if (cached_styles_ptr != NULL) {
	FREE(cached_styles_ptr);
	cached_styles_rows = 0;
	cached_styles_cols = 0;
    }
}

/*
 * Recompute the pairs associated with the color style.
 */
void update_color_style(void)
{
    CTRACE((tfp, "update_color_style %p\n", (void *) lss_styles));
    memset(our_pairs, 0, sizeof(our_pairs));
    parse_userstyles();
}

static char *find_lss_file(const char *nominal)
{
    return LYFindConfigFile(nominal, LYNX_LSS_FILE);
}

/*
 * Add an entry to the lss-list, and cache the resolved filename if known.
 */
void add_to_lss_list(const char *source, const char *resolved)
{
    LSS_NAMES *obj;
    LSS_NAMES *chk;
    BOOLEAN found = FALSE;
    int position = 0;

#ifdef LY_FIND_LEAKS
    atexit(free_colorstyle_leaks);
#endif

    CTRACE((tfp, "add_to_lss_list(\"%s\", \"%s\")\n",
	    NonNull(source),
	    NonNull(resolved)));

    if (list_of_lss_files == 0) {
	list_of_lss_files = HTList_new();
    }

    while ((chk = HTList_objectAt(list_of_lss_files, position++)) != 0) {
	if (!strcmp(source, chk->given)) {
	    found = TRUE;
	    if (resolved && !chk->actual) {
		StrAllocCopy(chk->actual, resolved);
	    }
	    break;
	}
    }

    if (!found) {
	obj = typecalloc(LSS_NAMES);
	if (obj == NULL)
	    outofmem(__FILE__, "add_to_lss_list");

	StrAllocCopy(obj->given, source);
	StrAllocCopy(obj->actual, resolved);
	HTList_appendObject(list_of_lss_files, obj);
    }
}

/*
 * This is called after reading lynx.cfg, to set the initial value for the
 * lss-file, and read its data.
 */
void init_color_styles(char **from_cmdline, const char *default_styles)
{
    char *cp;

    /*
     * If we read no COLOR_STYLE data from lynx.cfg, build a default list now.
     */
    if (list_of_lss_files == 0) {
	char *source = 0;
	char *config;

	StrAllocCopy(source, default_styles);
	config = source;
	while ((cp = LYstrsep(&config, ";")) != 0) {
	    char *target;

	    target = find_lss_file(LYPathLeaf(cp));
	    if (target != 0)
		add_to_lss_list(cp, target);
	}
	FREE(source);
    }

    /*
     * A command-line "-lss" always overrides the config-file, even if it is
     * an empty string such as -lss="".
     */
    if (*from_cmdline != 0) {
	FREE(lynx_lss_file);
	lynx_lss_file = find_lss_file(cp = *from_cmdline);
	*from_cmdline = 0;
    } else if (((cp = LYGetEnv("LYNX_LSS")) != NULL) ||
	       (cp = LYGetEnv("lynx_lss")) != NULL) {
	lynx_lss_file = find_lss_file(cp);
    } else {
	lynx_lss_file = find_lss_file(cp = DeConst(LYNX_LSS_FILE));
    }
    CTRACE1((tfp, "init_color_styles(%s)\n", NonNull(lynx_lss_file)));

    /*
     * If the lynx-style file is not available, inform the user and exit.
     */
    if (isEmpty(lynx_lss_file) || !LYCanReadFile(lynx_lss_file)) {
	fprintf(stderr, gettext("\nLynx file \"%s\" is not available.\n\n"),
		NonNull(cp));
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Otherwise, load the initial lss-file and add it to the list for the
     * options menu.
     */
    style_readFromFile(lynx_lss_file);
    add_to_lss_list(LYPathLeaf(lynx_lss_file), lynx_lss_file);
#ifndef NO_OPTION_FORMS
    build_lss_enum(list_of_lss_files);
#endif
}

void reinit_color_styles(void)
{
    int cs;

    for (cs = 0; cs < CSHASHSIZE; ++cs) {
	bucket *style = &hashStyles[cs];

	while (style != 0) {
	    bucket *next = style->next;

	    if (next != 0) {
		hashStyles[cs] = *next;
		free(next);
	    }
	    style = hashStyles[cs].next;
	}
    }
#ifdef USE_PRETTYSRC
    for (cs = 0; cs < HTL_num_lexemes; ++cs) {
	html_src_clean_item((HTlexeme) cs);
    }
#endif
    free_colorstylestuff();
    style_readFromFile(lynx_lss_file);
}

#endif /* USE_COLOR_STYLE */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 4
a4 1
/* character level styles for Lynx
a5 1
 * $Id: LYStyle.c,v 1.5 2009/05/31 09:16:52 avsm Exp $
d24 3
d36 1
a36 1
static void style_initialiseHashTable(void);
a56 10
bucket special_bucket =
{
    "<special>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
};
bucket nostyle_bucket =
{
    "<NOSTYLE>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
};
d115 24
d149 1
a149 1
static void parse_either(char *attrs,
d155 4
d160 20
a179 18
    while (*attrs != '\0') {
	char *next = strchr(attrs, '+');
	char save = (char) ((next != NULL) ? *next : '\0');

	if (next == NULL)
	    next = attrs + strlen(attrs);

	if (save != 0)		/* attrs might be a constant string */
	    *next = '\0';
	if ((value = string_to_attr(attrs)) != 0)
	    *monop |= value;
	else if (colorp != 0
		 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
	    *colorp = value;

	attrs = next;
	if (save != '\0')
	    *attrs++ = save;
d184 3
a186 3
static void parse_attributes(char *mono,
			     char *fg,
			     char *bg,
d188 1
a188 1
			     char *element)
d195 1
d243 2
a244 2
	int iBold = !!(cA & A_BOLD);
	int iBlink = !!(cA & M_BLINK);
d263 1
d265 2
a266 2
	    setStyle(style, COLOR_PAIR(curPair) | cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair) | cA, cA, mA, element);
d287 1
a287 1
	char *name;
d326 2
a327 1
    char *element, *mono, *fg, *bg;
d337 1
a337 1
    if ((tmp = strchr(buffer, ':')) == 0) {
d350 1
a350 1
    tmp = strchr(mono, ':');
d358 1
a358 1
	tmp = strchr(fg, ':');
d398 1
a398 1
	    element_number = t - HTML_dtd.tags;
d416 18
d442 35
d513 1
a513 5
#if 0
	{ 5,	"a.b" },
	{ 5,	"b.a" },
	{ 5,	"var.a" },
#endif
a515 4
#if 0
	{ 0,	"h2.link" },
	{ 0,	"link.h2" },
#endif
a578 34
/* Set all the buckets in the hash table to be empty */
static void style_initialiseHashTable(void)
{
    int i;
    static int firsttime = 1;

    for (i = 0; i < CSHASHSIZE; i++) {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono = 0;
    }
    if (firsttime) {
	firsttime = 0;
#ifdef LY_FIND_LEAKS
	atexit(free_colorstylestuff);
#endif
    }
    s_alink = hash_code("alink");
    s_a = hash_code("a");
    s_status = hash_code("status");
    s_alert = hash_code("alert");
    s_title = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg = hash_code("scroll.back");
    s_sb_aa = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
#endif
}

d582 1
a582 1
    HTList *cur = lss_styles;
d643 1
a654 1
    int len;
d677 1
a677 1
	else if (buffer[0] != '#' && (len = (int) strlen(buffer)) > 0)
d761 1
a761 1
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
d826 147
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.63 Mon, 02 Oct 2006 12:56:53 -0700 dickey $
d25 3
d39 7
d47 1
a47 1
int last_styles[MAX_LAST_STYLES] =
d139 1
a139 1
	char save = (next != NULL) ? *next : '\0';
d233 1
a233 1
		our_pairs[iBold][iBlink][iFg][iBg] = curPair;
d393 1
d465 1
a465 1
    CTRACE((tfp, "initialise_default_stylesheet\n"));
d589 1
a589 1
    CTRACE((tfp, "HStyle_addStyle(%s)\n", buffer));
d638 1
a638 1
	else if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
d686 1
a686 1
			int name_len,
d699 1
a699 1
	if (!strncasecomp(tag_start + 1, tag_name, name_len)) {
d713 3
a715 3
 /* This is called each time lss styles are read. It will fill
  * each elt of 'cached_tag_styles' -HV
  */
d725 61
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.54 Mon, 19 Jan 2004 04:16:02 -0800 dickey $
d28 7
a34 1
PRIVATE void style_initialiseHashTable NOPARAMS;
d37 3
a39 2
PUBLIC int last_styles[128] = { 0 };
PUBLIC int last_colorattr_ptr = 0;
d41 2
a42 2
PUBLIC bucket hashStyles[CSHASHSIZE];
PUBLIC bucket special_bucket =
d44 1
a44 1
    "<special>", /* in order something to be in trace. */
d47 1
a47 1
PUBLIC bucket nostyle_bucket =
d49 1
a49 1
    "<NOSTYLE>", /* in order something to be in trace. */
d53 5
a57 5
PUBLIC int cached_tag_styles[HTML_ELEMENTS];
PUBLIC int current_tag_style;
PUBLIC BOOL force_current_tag_style = FALSE;
PUBLIC char* forced_classname;
PUBLIC BOOL force_classname;
d60 24
a83 24
PUBLIC int s_a			= NOSTYLE;
PUBLIC int s_aedit		= NOSTYLE;
PUBLIC int s_aedit_arr		= NOSTYLE;
PUBLIC int s_aedit_pad		= NOSTYLE;
PUBLIC int s_aedit_sel		= NOSTYLE;
PUBLIC int s_alert		= NOSTYLE;
PUBLIC int s_alink		= NOSTYLE;
PUBLIC int s_curedit		= NOSTYLE;
PUBLIC int s_forw_backw		= NOSTYLE;
PUBLIC int s_hot_paste		= NOSTYLE;
PUBLIC int s_menu_active	= NOSTYLE;
PUBLIC int s_menu_bg		= NOSTYLE;
PUBLIC int s_menu_entry		= NOSTYLE;
PUBLIC int s_menu_frame		= NOSTYLE;
PUBLIC int s_menu_number	= NOSTYLE;
PUBLIC int s_menu_sb		= NOSTYLE;
PUBLIC int s_normal		= NOSTYLE;
PUBLIC int s_prompt_edit	= NOSTYLE;
PUBLIC int s_prompt_edit_arr	= NOSTYLE;
PUBLIC int s_prompt_edit_pad	= NOSTYLE;
PUBLIC int s_prompt_sel		= NOSTYLE;
PUBLIC int s_status		= NOSTYLE;
PUBLIC int s_title		= NOSTYLE;
PUBLIC int s_whereis		= NOSTYLE;
d86 4
a89 4
PUBLIC int s_sb_aa		= NOSTYLE;
PUBLIC int s_sb_bar		= NOSTYLE;
PUBLIC int s_sb_bg		= NOSTYLE;
PUBLIC int s_sb_naa		= NOSTYLE;
d94 1
a94 1
PRIVATE int colorPairs = 0;
d104 12
a115 4
PRIVATE unsigned char our_pairs[2]
				[MAX_BLINK]
				[MAX_COLOR + 1]
				[MAX_COLOR + 1];
d120 4
a123 5
PRIVATE void parse_either ARGS4(
    char *,	attrs,
    int,	dft_color,
    int *,	monop,
    int *,	colorp)
d130 1
d134 1
a134 1
	if (save != 0)	/* attrs might be a constant string */
d139 1
a139 1
	 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
d149 5
a153 6
PRIVATE void parse_attributes ARGS5(
    char *,	mono,
    char *,	fg,
    char *,	bg,
    int,	style,
    char *,	element)
d161 2
a162 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle, element));
d164 1
a164 1
    parse_either(mono, ERR_COLOR, &mA, (int *)0);
d168 3
a170 2
    if (style == -1) {			/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n", fA, bA));
d203 1
a203 1
    if (lynx_has_color && colorPairs < COLOR_PAIRS-1 && fA != NO_COLOR) {
d210 2
a211 1
	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n", fA, default_fg, bA, default_bg, cA));
d213 1
a213 1
	 && bA < MAX_COLOR
d215 1
a215 1
	 && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
d217 1
a217 1
	 && curPair < 255) {
d222 1
a222 1
		init_pair((short)curPair, (short)fA, (short)bA);
d228 2
a229 2
	    setStyle(style, COLOR_PAIR(curPair)|cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair)|cA, cA, mA, element);
d232 3
a234 1
	    CTRACE2(TRACE_STYLE, (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n", COLOR_PAIRS - 1));
d246 1
a246 1
PRIVATE void parse_style ARGS1(char*, param)
d248 1
a260 1
	{ "high",		DSTYLE_HIGH,		0 }, /* [INLINE]'s */
d282 2
d298 1
d300 1
a300 1
	fprintf (stderr, gettext("\
d306 1
a306 4
	if (!dump_output_immediately) {
	    exit_immediately(EXIT_FAILURE);
	}
	exit(1);
a307 1
    strtolower(buffer);
d314 1
a314 2
    if (!tmp)
    {
d317 1
a317 3
    }
    else
    {
d319 1
a319 1
	fg = tmp+1;
d323 1
a323 2
	else
	{
d330 2
a331 4
		element, hash_code(element),
		(hashStyles[hash_code(element)].name ? "used" : "")));

    strtolower(element);
d334 2
a335 2
    * We use some pseudo-elements, so catch these first
    */
d347 9
a355 12
	;
    }
    else if (!strcasecomp(element, "normal")) /* added - kw */
    {
	parse_attributes(mono,fg,bg,DSTYLE_NORMAL,"html");
	s_normal  = hash_code("html"); /* rather bizarre... - kw */
    }
    /* Ok, it must be a HTML element, so look through the list until we
    * find it
    */
    else
    {
d357 2
a358 1
	HTTag * t = SGMLFindTag(&HTML_dtd, element);
d363 5
a367 4
	    element_number < HTML_ELEMENTS)
	    parse_attributes(mono,fg,bg, element_number+STARTAT,element);
	else
	    parse_attributes(mono,fg,bg, DSTYLE_ELEMENTS,element);
d372 7
a378 2
#ifdef LY_FIND_LEAKS
PRIVATE void free_colorstylestuff NOARGS
d382 1
a383 1
#endif
d386 1
a386 2
 * initialise the default style sheet
 * This should be able to be read from a file in CSS format :-)
d388 1
a388 1
PRIVATE void initialise_default_stylesheet NOARGS
d390 57
a446 8
    static CONST char *table[] = {
	"a:bold:green",
	"alert:bold:yellow:red",
	"alink:reverse:yellow:black",
	"label:normal:magenta",
	"status:reverse:yellow:blue",
	"title:normal:magenta",
	"whereis:reverse+underline:magenta:cyan"
d448 2
d451 39
a489 4
    char temp[80];
    CTRACE((tfp, "initialize_default_stylesheet\n"));
    for (n = 0; n < TABLESIZE(table); n++) {
	parse_style(strcpy(temp, table[n]));
d491 2
d496 1
a496 1
PRIVATE void style_initialiseHashTable NOARGS
d501 1
a501 2
    for (i = 0; i <CSHASHSIZE; i++)
    {
d508 1
a508 1
	hashStyles[i].mono  = 0;
d516 2
a517 2
    s_alink  = hash_code("alink");
    s_a      = hash_code("a");
d519 2
a520 2
    s_alert  = hash_code("alert");
    s_title  = hash_code("title");
d523 2
a524 2
    s_sb_bg  = hash_code("scroll.back");
    s_sb_aa  = hash_code("scroll.arrow");
d529 1
a529 7
/* because curses isn't started when we parse the config file, we
 * need to remember the STYLE: lines we encounter and parse them
 * after curses has started
 */
PRIVATE HTList *lss_styles = NULL;

PUBLIC void parse_userstyles NOARGS
a536 1
    /* set our styles to be the same as vanilla-curses-lynx */
d540 5
a544 2
	while ((name = HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n", name ? name : "!?! empty !?!"));
d551 1
a551 1

d566 2
a569 1

d571 4
a574 3
   for it to have the same semantic as other lines: works at any place
   of the style file, the first line overrides the later ones. */
PRIVATE void HStyle_addStyle ARGS1(char*, buffer)
d579 1
d581 2
d585 3
a587 3
    strtolower(name);
    if (!strncasecomp(name, "default:", 8)) /* default fg/bg */
    {
d589 2
a590 2
		 (default_color_reset ? ".ignore" : ""),
		 name ? name : "!?! empty !?!"));
d593 1
a593 1
	return;				/* do not need to process it again */
d596 1
a596 1
    HTList_addObject (lss_styles, name);
d599 2
a600 12
PUBLIC void style_deleteStyleList NOARGS
{
    char *name;
    while ((name = HTList_removeLastObject(lss_styles)) != NULL)
	FREE(name);
    HTList_delete (lss_styles);
    lss_styles = NULL;
}

PRIVATE int style_readFromFileREC ARGS2(
    char *,	lss_filename,
    char *,	parent_filename)
d606 2
a607 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n", lss_filename ? lss_filename : "?!? empty ?!?"));
d612 2
a613 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS:Can't open style file '%s', using defaults\n", lss_filename));
d618 1
a618 2
	style_initialiseHashTable();
	style_deleteStyleList();
d625 2
a626 2
	if (!strncasecomp(buffer,"include:",8))
	    style_readFromFileREC(buffer+8, lss_filename);
d631 1
a631 1
    LYCloseInput (fh);
d637 1
a637 1
PUBLIC int style_readFromFile ARGS1(char*, filename)
d639 1
a639 1
    return style_readFromFileREC(filename, (char *)0);
d644 3
a646 4
PUBLIC void TrimColorClass ARGS3(
    CONST char *,	tagname,
    char *,		styleclassname,
    int *,		phcode)
d648 1
a648 1
    char *end, *start=NULL, *lookfrom;
d652 1
a652 1
    strtolower(tmp);
d663 2
a664 2
	** - should match classes here as well (rp)
	*/
d666 1
a666 1
	    *end='\0';
d672 7
a678 8
   It assumes that tag_name is present in stylename! -HV
*/
PUBLIC void FastTrimColorClass ARGS5 (
	    CONST char*,	 tag_name,
	    int,		 name_len,
	    char*,		 stylename,
	    char**,		 pstylename_end,/*will be modified*/
	    int*,		 phcode)	/*will be modified*/
d680 1
a680 1
    char* tag_start = *pstylename_end;
d685 4
a688 6
		  tag_name, stylename));
    while (tag_start >= stylename)
    {
	for (; (tag_start >= stylename) && (*tag_start != ';') ; --tag_start)
	    ;
	if ( !strncasecomp(tag_start+1, tag_name, name_len) ) {
d699 1
a699 1
    *phcode = hash_code(tag_start+1);
d703 3
a705 3
    each elt of 'cached_tag_styles' -HV
 */
PUBLIC void cache_tag_styles NOARGS
d710 2
a711 3
    for (i = 0; i < HTML_ELEMENTS; ++i)
    {
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf)-1);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.46 Sat, 07 Jul 2001 18:30:13 -0700 dickey $
d31 1
a31 1
PUBLIC int last_styles[128];
d62 7
a76 6
PUBLIC int s_menu_frame		= NOSTYLE;
PUBLIC int s_menu_bg		= NOSTYLE;
PUBLIC int s_menu_number	= NOSTYLE;
PUBLIC int s_menu_entry		= NOSTYLE;
PUBLIC int s_menu_active	= NOSTYLE;
PUBLIC int s_menu_sb		= NOSTYLE;
d97 4
a100 1
PRIVATE unsigned char our_pairs[2][MAX_BLINK][MAX_COLOR][MAX_COLOR];
d187 6
a192 3
    if (lynx_has_color && colorPairs < COLOR_PAIRS-1 && fA != NO_COLOR)
    {
	int curPair;
d194 1
d197 11
a207 9
	 && our_pairs[!!(cA & A_BOLD)][!!(cA & A_BLINK)][fA][bA])
	    curPair = our_pairs[!!(cA & A_BOLD)][!!(cA & M_BLINK)][fA][bA] - 1;
	else {
	    curPair = ++colorPairs;
	    init_pair((short)curPair, (short)fA, (short)bA);
	    if (fA < MAX_COLOR
	     && bA < MAX_COLOR
	     && curPair < 255)
		our_pairs[!!(cA & A_BOLD)][!!(cA & M_BLINK)][fA][bA] = curPair + 1;
d213 1
a213 3
    }
    else
    {
d255 1
d266 2
a267 2
    char *buffer = strdup(param);
    char *tmp = strchr(buffer, ':');
d270 8
a277 2
    if(!tmp)
    {
a434 1
    static BOOL first = TRUE;
d514 1
a514 1
    if (lss_filename == NULL || *lss_filename == '\0')
d622 1
a622 1
	strcpy(buf, HTML_dtd.tags[i].name);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.28 Fri, 28 May 1999 08:04:01 -0600 dickey $
d28 2
d32 1
a32 1
PUBLIC int last_colorattr_ptr=0;
d37 2
a38 1
 "<special>" /* in order something to be in trace. */
d42 2
a43 1
 "<NOSTYLE>" /* in order something to be in trace. */
d48 1
a48 1
PUBLIC BOOL force_current_tag_style=FALSE;
a51 14
/* definitions for the mono attributes we can use */
static int ncursesMono[7] = {
 A_NORMAL, A_BOLD, A_REVERSE, A_UNDERLINE, A_STANDOUT, A_BLINK, A_DIM
};

/*
 * If these strings don't match the meanings of the above attributes,
 * you'll confuse the hell out of people, so make them the same. - RP
 */
static char *Mono_Strings[7] =
{
 "normal", "bold", "reverse", "underline", "standout", "blink", "dim"
};

d53 30
a82 4
PUBLIC int	s_alink  = NOSTYLE, s_a     = NOSTYLE, s_status = NOSTYLE,
		s_label  = NOSTYLE, s_value = NOSTYLE, s_high   = NOSTYLE,
		s_normal = NOSTYLE, s_alert = NOSTYLE, s_title  = NOSTYLE,
		s_whereis= NOSTYLE;
d85 1
d87 41
a127 1
PRIVATE int last_fA = COLOR_WHITE, last_bA = COLOR_BLACK;
d130 11
a140 4
PRIVATE void parse_attributes ARGS5(char*,mono,char*,fg,char*,bg,int,style,char*,element)
{
    int i;
    int mA = 0, fA = default_fg, bA = default_bg, cA = A_NORMAL;
d143 1
a143 1
    CTRACE(tfp, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle,element);
d145 10
a154 6
    for (i = 0; i < (int)TABLESIZE(Mono_Strings); i++)
    {
	if (!strcasecomp(Mono_Strings[i], mono))
	{
	    mA = ncursesMono[i];
	}
a155 32
    if (!mA) {
	/*
	 *  Not found directly yet, see whether we have a combination
	 *  of several mono attributes separated by '+' - kw
	 */
	char *cp0 = mono;
	char csep = '+';
	char *cp = strchr(mono, csep);
	while (cp) {
	    *cp = '\0';
	    for (i = 0; i < (int)TABLESIZE(Mono_Strings); i++)
	    {
		if (!strcasecomp(Mono_Strings[i], cp0))
		{
		    mA |= ncursesMono[i];
		}
	    }
	    if (!csep)
		break;
	    *cp = csep;
	    cp0 = cp + 1;
	    cp = strchr(cp0, csep);
	    if (!cp) {
		cp = cp0 + strlen(cp0);
		csep = '\0';
	    }
	}
    }
    CTRACE(tfp, "CSS(CP):%d\n", colorPairs);

    fA = check_color(fg, default_fg);
    bA = check_color(bg, default_bg);
d159 8
d171 1
a171 1
	if (bA > COLORS)
d185 13
a197 5
	if (colorPairs <= 0 || fA != last_fA || bA != last_bA) {
	    colorPairs++;
	    init_pair(colorPairs, fA, bA);
	    last_fA = fA;
	    last_bA = bA;
d199 1
d201 2
a202 2
	    setStyle(style, COLOR_PAIR(colorPairs)|cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(colorPairs)|cA, cA, mA, element);
d206 4
a209 1
    /* only mono is set */
d219 1
a219 1
PRIVATE void parse_style ARGS1(char*,buffer)
d221 37
d270 1
a270 1
	    exit_immediately(-1);
d274 1
a274 5
    {
	char *i;
	for (i = buffer; *i; i++)
	    *i = tolower(*i);
    }
d300 1
a300 1
    CTRACE(tfp, "CSSPARSE:%s => %d %s\n",
d302 1
a302 1
		(hashStyles[hash_code(element)].name ? "used" : ""));
d309 8
a316 3
    if (!strncasecomp(element, "alink", 5)) /* active link */
    {
	parse_attributes(mono,fg,bg,DSTYLE_ALINK,"alink");
d318 3
a320 20
    else if (!strcasecomp(element, "a")) /* normal link */
    {
	parse_attributes(mono,fg,bg, DSTYLE_LINK,"a");
	parse_attributes(mono,fg,bg, HTML_A,"a");
    }
    else if (!strncasecomp(element, "status", 4)) /* status bar */
    {
	parse_attributes(mono,fg,bg, DSTYLE_STATUS,"status");
    }
    else if (!strncasecomp(element, "label", 6)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_OPTION,"label");
    }
    else if (!strncasecomp(element, "value", 5)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_VALUE,"value");
    }
    else if (!strncasecomp(element, "high", 4)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_HIGH,"high");
a326 11
    /* this may vanish */
    else if (!strncasecomp(element, "candy", 5)) /* [INLINE]'s */
    {
	parse_attributes(mono,fg,bg,DSTYLE_CANDY,"candy");
    }
    /* added for whereis search target - kw */
    else if (!strncasecomp(element, "whereis", 7))
    {
	parse_attributes(mono,fg,bg,DSTYLE_WHEREIS,"whereis");
	s_whereis  = hash_code("whereis");
    }
a331 12
#if !defined(USE_HASH)
	int i;
	for (i = 0; i <HTML_ELEMENTS; i++)
	{
	    if (!strcasecomp (HTML_dtd.tags[i].name, element))
	    {
		CTRACE(tfp, "PARSECSS:applying style <%s,%s,%s> for HTML_%s\n",mono,fg,bg,HTML_dtd.tags[i].name);
			parse_attributes(mono,fg,bg,i+STARTAT,element);
		break;
	    }
	}
#else
a341 1
#endif
d343 1
d360 15
d378 1
a378 1
PUBLIC void style_initialiseHashTable NOARGS
d380 2
a381 2
	int i;
	static int firsttime = 1;
d383 12
a394 12
	for (i = 0; i <CSHASHSIZE; i++)
	{
	    if (firsttime)
		hashStyles[i].name = NULL;
	    else
		FREE(hashStyles[i].name);
	    hashStyles[i].color = -1;
	    hashStyles[i].cattr = -1;
	    hashStyles[i].mono  = -1;
	}
	if (firsttime) {
	    firsttime = 0;
d396 13
a408 1
	    atexit(free_colorstylestuff);
a409 9
	}
	s_high   = hash_code("high");
	s_alink  = hash_code("alink");
	s_value  = hash_code("value");
	s_label  = hash_code("label");
	s_a      = hash_code("a");
	s_status = hash_code("status");
	s_alert  = hash_code("alert");
	s_title  = hash_code("title");
d416 1
a416 1
HTList *lss_styles = NULL;
d420 6
a425 4
	char *name;
	HTList *cur = lss_styles;
	colorPairs = 0;
	style_initialiseHashTable();
d427 2
a428 1
	/* set our styles to be the same as vanilla-curses-lynx */
d430 7
d438 16
a453 6
	while ((name = HTList_nextObject(cur)) != NULL)
	{
		CTRACE(tfp, "LSS:%s\n", name ? name : "!?! empty !?!");
		if (name != NULL)
		    parse_style(name);
	}
d457 23
a479 10
/* Add a STYLE: option line to our list */
PUBLIC void HStyle_addStyle ARGS1(char*,buffer)
{
	char *name = NULL;
	StrAllocCopy(name, buffer);
	if (lss_styles == NULL)
		lss_styles = HTList_new();
	strtolower(name);
	CTRACE(tfp, "READCSS:%s\n", name ? name : "!?! empty !?!");
	HTList_addObject (lss_styles, name);
d491 3
a493 13
char* default_stylesheet[] = {
	"a:bold", "em:bold", "strong:bold", "b:bold", "i:bold",
	"alink:reverse", "status:reverse", NULL
};

PUBLIC void style_defaultStyleSheet NOARGS
{
	int i;
	for (i = 0; default_stylesheet[i]; i++)
		HStyle_addStyle(default_stylesheet[i]);
}

PUBLIC int style_readFromFile ARGS1(char*, file)
d499 2
a500 2
    CTRACE(tfp, "CSS:Reading styles from file: %s\n", file ? file : "?!? empty ?!?");
    if (file == NULL || *file == '\0')
d502 1
a502 3
    fh = fopen(file, "r");
    if (!fh)
    {
d504 1
a504 1
	CTRACE(tfp, "CSS:Can't open style file %s, using defaults\n", file);
d508 4
a511 2
    style_initialiseHashTable();
    style_deleteStyleList();
d513 1
a513 2
    while (LYSafeGets(&buffer, fh) != NULL)
    {
d517 3
a519 1
	if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
a521 4
    /* the default styles are added after the user styles in order
    ** that they come before them  <grin>  RP
    */
    /*	style_defaultStyleSheet(); */
d523 2
a524 2
    fclose (fh);
    if (LYCursesON)
d529 5
a561 2
    CTRACE(tfp, "CSS:%s (trimmed %s)\n",
	   (styleclassname ? styleclassname : "<null>"), tmp);
d577 3
d594 1
d610 1
a610 1
	cached_tag_styles[i] =hash_code(buf);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.16 Fri, 27 Feb 1998 11:25:07 -0700 dickey $
d5 12
a16 13
#include "HTUtils.h"
#include "HTML.h"
#include "tcp.h"
#include "LYSignal.h"
#include "LYGlobalDefs.h"

#include "LYStructs.h"
#include "LYReadCFG.h"
#include "LYCurses.h"
#include "LYCharUtils.h"
#include "AttrList.h"
#include "SGML.h"
#include "HTMLDTD.h"
d19 2
a20 2
#include "LYHash.h"
#include "LYStyle.h"
d22 3
a24 2
#include "LYexit.h"
#include "LYLeaks.h"
d28 4
d33 14
d65 2
a66 1
		s_normal = NOSTYLE, s_alert = NOSTYLE, s_title  = NOSTYLE;
a71 3

#define FREE(x) if (x) {free(x); x = NULL;}

d79 1
a79 2
    if (TRACE)
	fprintf(stderr, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle,element);
d81 1
a81 1
    for (i = 0; i <7; i++)
d88 29
a116 2
    if (TRACE)
	fprintf(stderr, "CSS(CP):%d\n", colorPairs);
d122 1
a122 1
    } else {
d129 4
d170 1
a170 1
	fprintf (stderr, "\
d175 1
a175 1
where OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n\n", buffer);
d177 1
a177 12
#ifndef NOSIGHUP
	    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	    if (no_suspend)
		(void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	    exit(-1);
d183 2
a184 2
	for (i = buffer; *i; *i++ = tolower(*i))
	    ;
d211 3
a213 7
    if (TRACE)
    {
	int bkt = hash_code(element);
	fprintf(stderr, "CSSPARSE:%s => %d %s\n",
	    element, bkt,
	    (hashStyles[bkt].name ? "used" : ""));
    }
d248 1
d255 6
d272 1
a272 2
		if (TRACE)
		    fprintf(stderr, "PARSECSS:applying style <%s,%s,%s> for HTML_%s\n",mono,fg,bg,HTML_dtd.tags[i].name);
d292 1
d298 1
d326 1
d328 1
d358 1
a358 2
		if (TRACE)
			fprintf(stderr, "LSS:%s\n", name ? name : "!?! empty !?!");
d373 1
a373 2
	if (TRACE)
		fprintf(stderr, "READCSS:%s\n", name ? name : "!?! empty !?!");
d401 1
a401 1
    char buffer[1024];
d404 1
a404 2
    if (TRACE)
	fprintf(stderr, "CSS:Reading styles from file: %s\n", file ? file : "?!? empty ?!?");
d411 1
a411 2
	if (TRACE)
	    fprintf(stderr, "CSS:Can't open style file %s, using defaults\n", file);
d418 1
a418 2
    while (!feof(fh)
    && fgets(buffer, sizeof(buffer)-1, fh) != NULL)
d420 1
a420 7
	len = strlen(buffer);
	if (len > 0) {
	    if (buffer[len-1] == '\n' || buffer[len-1] == '\r')
		buffer[len-1] = '\0'; /* hack */
	    else
		buffer[sizeof(buffer)-1] = '\0'; /* hack */
	}
d436 79
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
