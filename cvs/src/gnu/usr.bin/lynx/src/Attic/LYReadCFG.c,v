head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.10
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.07.00.36.04;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.11;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYReadCFG.c,v 1.184 2014/02/12 23:59:11 tom Exp $
 */
#ifndef NO_RULES
#include <HTRules.h>
#else
#include <HTUtils.h>
#endif
#include <HTTP.h>		/* 'reloading' flag */
#include <HTFile.h>
#include <HTInit.h>
#include <UCMap.h>

#include <LYUtils.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYStructs.h>
#include <LYGlobalDefs.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYKeymap.h>
#include <LYJump.h>
#include <LYGetFile.h>
#include <LYCgi.h>
#include <LYCurses.h>
#include <LYBookmark.h>
#include <LYCookie.h>
#include <LYReadCFG.h>
#include <HTAlert.h>
#include <LYHistory.h>
#include <LYPrettySrc.h>
#include <LYrcFile.h>

#ifdef DIRED_SUPPORT
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */

#include <LYexit.h>
#include <LYLeaks.h>

#ifndef DISABLE_NEWS
#include <HTNews.h>
#endif

BOOLEAN have_read_cfg = FALSE;
BOOLEAN LYUseNoviceLineTwo = TRUE;

/*
 * Translate a TRUE/FALSE field in a string buffer.
 */
static BOOL is_true(const char *string)
{
    if (!strcasecomp(string, "TRUE") || !strcasecomp(string, "ON"))
	return (TRUE);
    else
	return (FALSE);
}

/*
 * Find an unescaped colon in a string buffer.
 */
static const char *find_colon(const char *buffer)
{
    char ch;
    const char *buf = buffer;

    if (buf == NULL)
	return NULL;

    while ((ch = *buf) != 0) {
	if (ch == ':')
	    return buf;
	if (ch == '\\') {
	    buf++;
	    if (*buf == 0)
		break;
	}
	buf++;
    }
    return NULL;
}

static void free_item_list_item(lynx_list_item_type **list,
				lynx_list_item_type *ptr)
{
    lynx_list_item_type *prev;
    lynx_list_item_type *cur;

    for (cur = *list, prev = 0; cur != 0; prev = cur, cur = cur->next) {
	if (cur == ptr) {

	    if (prev != 0)
		prev->next = cur->next;
	    else
		*list = cur->next;

	    FREE(cur->name);
	    FREE(cur->menu_name);
	    FREE(cur->command);
	    FREE(cur);
	    break;
	}
    }
}

static void free_item_list(lynx_list_item_type **ptr)
{
    while (*ptr != 0) {
	free_item_list_item(ptr, *ptr);
    }
}

/*
 * Function for freeing the DOWNLOADER and UPLOADER menus list.  - FM
 */
static void free_all_item_lists(void)
{
    free_item_list(&printers);
    free_item_list(&downloaders);
#ifdef DIRED_SUPPORT
    free_item_list(&uploaders);
#endif /* DIRED_SUPPORT */

#ifdef USE_EXTERNALS
    free_item_list(&externals);
#endif /* USE_EXTERNALS */

    return;
}

static const char *parse_list_bool(BOOL *target, const char *source)
{
    const char *result;

    source = LYSkipCBlanks(source);
    result = find_colon(source);

    if (*source != '\0') {
	char temp[20];
	size_t len = ((result != 0)
		      ? (size_t) (result - source)
		      : strlen(source));

	if (len > sizeof(temp))
	    len = (sizeof(temp) - 1);
	LYStrNCpy(temp, source, len);
	*target = is_true(temp);
	CTRACE2(TRACE_CFG, (tfp, "parse_list_bool(%s) '%d'\n", source, *target));
    }
    return result;
}

static const char *parse_list_int(int *target, const char *source)
{
    const char *result;

    source = LYSkipCBlanks(source);
    result = find_colon(source);

    if (*source != '\0') {
	*target = atoi(source);
	CTRACE2(TRACE_CFG, (tfp, "parse_list_int(%s) '%d'\n", source, *target));
    }
    return result;
}

static const char *parse_list_string(char **target, const char *source)
{
    const char *result;

    source = LYSkipCBlanks(source);
    result = find_colon(source);

    if (*source != '\0') {
	const char *next = ((result == 0)
			    ? (source + strlen(source))
			    : result);

	*target = typecallocn(char, (size_t) (next - source + 1));

	if (*target == NULL)
	    outofmem(__FILE__, "read_cfg");
	LYStrNCpy(*target, source, (next - source));
	remove_backslashes(*target);

	CTRACE2(TRACE_CFG, (tfp, "parse_list_string(%s) '%s'\n", source, *target));
    }
    return result;
}

/*
 * Process string buffer fields for DOWNLOADER or UPLOADER
 *                               or PRINTERS   or EXTERNALS menus
 */
static void add_item_to_list(char *buffer,
			     lynx_list_item_type **list_ptr,
			     int special,
			     int menu_name)
{
    const char *colon, *last_colon;
    lynx_list_item_type *cur_item, *prev_item;

    /*
     * Check if the XWINDOWS or NON_XWINDOWS keyword is present in the last
     * field, and act properly when found depending if external environment
     * $DISPLAY variable is set.
     */
    if ((colon = find_colon(buffer)) == 0) {
	return;
    }
    for (last_colon = colon;
	 (colon = find_colon(last_colon + 1)) != 0;
	 last_colon = colon) {
	;
    }

    /*
     * If colon equals XWINDOWS then only continue
     * if there is a $DISPLAY variable
     */
    if (!strcasecomp(last_colon + 1, "XWINDOWS")) {
	if (LYgetXDisplay() == NULL)
	    return;
    }
    /*
     * If colon equals NON_XWINDOWS then only continue
     * if there is no $DISPLAY variable
     */
    else if (!strcasecomp(last_colon + 1, "NON_XWINDOWS")) {
	if (LYgetXDisplay() != NULL)
	    return;
    }

    /*
     * Make a linked list
     */
    if (*list_ptr == NULL) {
	/*
	 * First item.
	 */
	cur_item = typecalloc(lynx_list_item_type);

	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");

	assert(cur_item != NULL);

	*list_ptr = cur_item;
#ifdef LY_FIND_LEAKS
	atexit(free_all_item_lists);
#endif
    } else {
	/*
	 * Find the last item.
	 */
	for (prev_item = *list_ptr;
	     prev_item->next != NULL;
	     prev_item = prev_item->next) ;	/* null body */
	cur_item = typecalloc(lynx_list_item_type);

	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	else
	    prev_item->next = cur_item;

	assert(cur_item != NULL);
    }
    /* fill-in nonzero default values */
    cur_item->pagelen = 66;

    /*
     * Find first unescaped colon and process fields
     */
    if (find_colon(buffer) != NULL) {
	colon = parse_list_string(&(cur_item->name), buffer);

	if (colon && menu_name) {
	    colon = parse_list_string(&(cur_item->menu_name), colon + 1);
	}
	if (colon) {
	    colon = parse_list_string(&(cur_item->command), colon + 1);
	}
	if (colon) {
	    colon = parse_list_bool(&(cur_item->always_enabled), colon + 1);
	}
	if (colon) {
	    if (special) {
		(void) parse_list_int(&(cur_item->pagelen), colon + 1);
	    } else {
		(void) parse_list_bool(&(cur_item->override_action), colon + 1);
	    }
	}
    }

    /* ignore empty data */
    if (cur_item->name == NULL
	|| cur_item->command == NULL) {
	CTRACE2(TRACE_CFG, (tfp, "ignoring incomplete list_item '%s'\n", buffer));
	free_item_list_item(list_ptr, cur_item);
    } else if (cur_item->menu_name == NULL) {
	StrAllocCopy(cur_item->menu_name, cur_item->command);
    }
}

lynx_list_item_type *find_item_by_number(lynx_list_item_type *list_ptr,
					 char *number)
{
    int value = atoi(number);

    while (value-- >= 0 && list_ptr != 0) {
	list_ptr = list_ptr->next;
    }
    return list_ptr;
}

int match_item_by_name(lynx_list_item_type *ptr,
		       const char *name,
		       int only_overriders)
{
    return
	(ptr->command != 0
	 && !strncasecomp(ptr->name, name, (int) strlen(ptr->name))
	 && (only_overriders ? ptr->override_action : 1));
}

#if defined(USE_COLOR_STYLE) || defined(USE_COLOR_TABLE)

#ifndef COLOR_WHITE
#define COLOR_WHITE 7
#endif

#ifndef COLOR_BLACK
#define COLOR_BLACK 0
#endif

#ifdef USE_DEFAULT_COLORS
int default_fg = DEFAULT_COLOR;
int default_bg = DEFAULT_COLOR;

#else
int default_fg = COLOR_WHITE;
int default_bg = COLOR_BLACK;
#endif

static const char *Color_Strings[16] =
{
    "black",
    "red",
    "green",
    "brown",
    "blue",
    "magenta",
    "cyan",
    "lightgray",
    "gray",
    "brightred",
    "brightgreen",
    "yellow",
    "brightblue",
    "brightmagenta",
    "brightcyan",
    "white"
};

#if defined(PDCURSES) && !defined(XCURSES)
/*
 * PDCurses (and possibly some other implementations) use a non-ANSI set of
 * codes for colors.
 */
static int ColorCode(int color)
{
    /* *INDENT-OFF* */
    static int map[] =
    {
	0,  4,  2,  6,  1,  5,  3,  7,
	8, 12, 10, 14,  9, 13, 11, 15
    };
    /* *INDENT-ON* */

    return map[color];
}
#else
#define ColorCode(color) (color)
#endif

BOOL default_color_reset = FALSE;

/*
 * Validator for COLOR fields.
 */
int check_color(const char *color,
		int the_default)
{
    int i;

    CTRACE2(TRACE_STYLE, (tfp, "check_color(%s,%d)\n", color, the_default));
    if (!strcasecomp(color, "default")) {
#ifdef USE_DEFAULT_COLORS
	if (LYuse_default_colors && !default_color_reset)
	    the_default = DEFAULT_COLOR;
#endif /* USE_DEFAULT_COLORS */
	CTRACE2(TRACE_STYLE, (tfp, "=> default %d\n", the_default));
	return the_default;
    }
    if (!strcasecomp(color, "nocolor"))
	return NO_COLOR;

    for (i = 0; i < 16; i++) {
	if (!strcasecomp(color, Color_Strings[i])) {
	    int c = ColorCode(i);

	    CTRACE2(TRACE_STYLE, (tfp, "=> %d\n", c));
	    return c;
	}
    }
    CTRACE2(TRACE_STYLE, (tfp, "=> ERR_COLOR\n"));
    return ERR_COLOR;
}

const char *lookup_color(int code)
{
    unsigned n;

    for (n = 0; n < 16; n++) {
	if ((int) ColorCode(n) == code)
	    return Color_Strings[n];
    }
    return "default";
}
#endif /* USE_COLOR_STYLE || USE_COLOR_TABLE */

#if defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR)

/*
 * Exit routine for failed COLOR parsing.
 */
static void exit_with_color_syntax(char *error_line)
{
    unsigned int i;

    fprintf(stderr, gettext("\
Syntax Error parsing COLOR in configuration file:\n\
The line must be of the form:\n\
COLOR:INTEGER:FOREGROUND:BACKGROUND\n\
\n\
Here FOREGROUND and BACKGROUND must be one of:\n\
The special strings 'nocolor' or 'default', or\n")
	);
    for (i = 0; i < 16; i += 4) {
	fprintf(stderr, "%16s %16s %16s %16s\n",
		Color_Strings[i], Color_Strings[i + 1],
		Color_Strings[i + 2], Color_Strings[i + 3]);
    }
    fprintf(stderr, "%s\nCOLOR:%s\n", gettext("Offending line:"), error_line);
    exit_immediately(EXIT_FAILURE);
}
#endif /* defined(USE_COLOR_TABLE) || defined(EXP_ASSUMED_COLOR) */

#if defined(USE_COLOR_TABLE)
/*
 * Process string buffer fields for COLOR setting.
 */
static void parse_color(char *buffer)
{
    int color;
    const char *fg, *bg;
    char *temp_fg = 0;

    /*
     * We are expecting a line of the form:
     *    INTEGER:FOREGROUND:BACKGROUND
     */
    color = atoi(buffer);
    if (NULL == (fg = find_colon(buffer)))
	exit_with_color_syntax(buffer);

    assert(fg != NULL);

    if (NULL == (bg = find_colon(++fg)))
	exit_with_color_syntax(buffer);

    assert(bg != NULL);

    StrAllocCopy(temp_fg, fg);
    temp_fg[bg++ - fg] = '\0';

#if defined(USE_SLANG)
    if ((check_color(temp_fg, default_fg) == ERR_COLOR) ||
	(check_color(bg, default_bg) == ERR_COLOR))
	exit_with_color_syntax(buffer);

    SLtt_set_color(color, NULL, temp_fg, bg);
#else
    if (lynx_chg_color(color,
		       check_color(temp_fg, default_fg),
		       check_color(bg, default_bg)) < 0)
	exit_with_color_syntax(buffer);
#endif
    FREE(temp_fg);
}
#endif /* USE_COLOR_TABLE */
/* *INDENT-OFF* */
#ifdef USE_SOURCE_CACHE
static Config_Enum tbl_source_cache[] = {
    { "FILE",	SOURCE_CACHE_FILE },
    { "MEMORY",	SOURCE_CACHE_MEMORY },
    { "NONE",	SOURCE_CACHE_NONE },
    { NULL,		-1 },
};

static Config_Enum tbl_abort_source_cache[] = {
    { "KEEP",	SOURCE_CACHE_FOR_ABORTED_KEEP },
    { "DROP",	SOURCE_CACHE_FOR_ABORTED_DROP },
    { NULL,		-1 },
};
#endif
/* *INDENT-ON* */

#define PARSE_ADD(n,v)   {n, CONF_ADD_ITEM,    UNION_ADD(v), 0}
#define PARSE_SET(n,v)   {n, CONF_BOOL,        UNION_SET(v), 0}
#define PARSE_ENU(n,v,t) {n, CONF_ENUM,        UNION_INT(v), t}
#define PARSE_INT(n,v)   {n, CONF_INT,         UNION_INT(v), 0}
#define PARSE_TIM(n,v)   {n, CONF_TIME,        UNION_INT(v), 0}
#define PARSE_STR(n,v)   {n, CONF_STR,         UNION_STR(v), 0}
#define PARSE_PRG(n,v)   {n, CONF_PRG,         UNION_DEF(v), 0}
#define PARSE_Env(n,v)   {n, CONF_ENV,         UNION_ENV(v), 0}
#define PARSE_ENV(n,v)   {n, CONF_ENV2,        UNION_ENV(v), 0}
#define PARSE_FUN(n,v)   {n, CONF_FUN,         UNION_FUN(v), 0}
#define PARSE_REQ(n,v)   {n, CONF_INCLUDE,     UNION_FUN(v), 0}
#define PARSE_LST(n,v)   {n, CONF_ADD_STRING,  UNION_LST(v), 0}
#define PARSE_DEF(n,v)   {n, CONF_ADD_TRUSTED, UNION_DEF(v), 0}
#define PARSE_NIL        {NULL, CONF_NIL,      UNION_DEF(0), 0}

typedef enum {
    CONF_NIL = 0
    ,CONF_BOOL			/* BOOLEAN type */
    ,CONF_FUN
    ,CONF_TIME
    ,CONF_ENUM
    ,CONF_INT
    ,CONF_STR
    ,CONF_PRG
    ,CONF_ENV			/* from environment variable */
    ,CONF_ENV2			/* from environment VARIABLE */
    ,CONF_INCLUDE		/* include file-- handle special */
    ,CONF_ADD_ITEM
    ,CONF_ADD_STRING
    ,CONF_ADD_TRUSTED
} Conf_Types;

typedef struct {
    const char *name;
    Conf_Types type;
      ParseData;
    Config_Enum *table;
} Config_Type;

static int assume_charset_fun(char *value)
{
    assumed_charset = TRUE;
    UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(value);
    StrAllocCopy(UCAssume_MIMEcharset,
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
    CTRACE((tfp, "assume_charset_fun %s ->%d ->%s\n",
	    NonNull(value),
	    UCLYhndl_for_unspec,
	    UCAssume_MIMEcharset));
    return 0;
}

static int assume_local_charset_fun(char *value)
{
    UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(value);
    return 0;
}

static int assume_unrec_charset_fun(char *value)
{
    UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(value);
    return 0;
}

static int character_set_fun(char *value)
{
    int i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */

    if (i < 0) {
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
	if (auto_display_charset >= 0
	    && (!strncasecomp(value, "AutoDetect ", 11)
		|| !strncasecomp(value, "AutoDetect-2 ", 13)))
	    current_char_set = auto_display_charset;
#endif
	/* do nothing here: so fallback to userdefs.h */
    } else {
	current_char_set = i;
    }

    return 0;
}

static int outgoing_mail_charset_fun(char *value)
{
    outgoing_mail_charset = UCGetLYhndl_byMIME(value);
    /* -1 if NULL or not recognized value: no translation (compatibility) */

    return 0;
}

#ifdef EXP_ASSUMED_COLOR
/*
 * Process string buffer fields for ASSUMED_COLOR setting.
 */
static int assumed_color_fun(char *buffer)
{
    const char *fg = buffer, *bg;
    char *temp_fg = 0;

    if (LYuse_default_colors) {

	/*
	 * We are expecting a line of the form:
	 *    FOREGROUND:BACKGROUND
	 */
	if (NULL == (bg = find_colon(fg)))
	    exit_with_color_syntax(buffer);

	assert(bg != NULL);

	StrAllocCopy(temp_fg, fg);
	temp_fg[bg++ - fg] = '\0';

	default_fg = check_color(temp_fg, default_fg);
	default_bg = check_color(bg, default_bg);

	if (default_fg == ERR_COLOR
	    || default_bg == ERR_COLOR)
	    exit_with_color_syntax(buffer);
	FREE(temp_fg);
    } else {
	CTRACE((tfp, "...ignored since DEFAULT_COLORS:off\n"));
    }
    return 0;
}
#endif /* EXP_ASSUMED_COLOR */

#ifdef USE_COLOR_TABLE
static int color_fun(char *value)
{
    parse_color(value);
    return 0;
}
#endif

#ifdef USE_COLOR_STYLE
static int lynx_lss_file_fun(char *value)
{
    add_to_lss_list(value, NULL);
    return 0;
}
#endif

#ifdef USE_DEFAULT_COLORS
void update_default_colors(void)
{
    int old_fg = default_fg;
    int old_bg = default_bg;

    default_color_reset = !LYuse_default_colors;
    if (LYuse_default_colors) {
	default_color_reset = FALSE;
	default_fg = DEFAULT_COLOR;
	default_bg = DEFAULT_COLOR;
    } else {
	default_color_reset = TRUE;
	default_fg = COLOR_WHITE;
	default_bg = COLOR_BLACK;
    }
    if (old_fg != default_fg || old_bg != default_bg) {
	lynx_setup_colors();
#ifdef USE_COLOR_STYLE
	update_color_style();
#endif
    }
}

static int default_colors_fun(char *value)
{
    LYuse_default_colors = is_true(value);
    update_default_colors();
    return 0;
}
#endif

static int default_bookmark_file_fun(char *value)
{
    set_default_bookmark_page(value);
    return 0;
}

static int default_cache_size_fun(char *value)
{
    HTCacheSize = atoi(value);
    if (HTCacheSize < 2)
	HTCacheSize = 2;
    return 0;
}

static int default_editor_fun(char *value)
{
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
}

static int numbers_as_arrows_fun(char *value)
{
    if (is_true(value))
	keypad_mode = NUMBERS_AS_ARROWS;
    else
	keypad_mode = LINKS_ARE_NUMBERED;

    return 0;
}

#ifdef DIRED_SUPPORT
static int dired_menu_fun(char *value)
{
    add_menu_item(value);
    return 0;
}
#endif

static int jumpfile_fun(char *value)
{
    char *buffer = NULL;

    HTSprintf0(&buffer, "JUMPFILE:%s", value);
    if (!LYJumpInit(buffer))
	CTRACE((tfp, "Failed to register %s\n", buffer));
    FREE(buffer);

    return 0;
}

#ifdef EXP_KEYBOARD_LAYOUT
static int keyboard_layout_fun(char *key)
{
    if (!LYSetKbLayout(key))
	CTRACE((tfp, "Failed to set keyboard layout %s\n", key));
    return 0;
}
#endif /* EXP_KEYBOARD_LAYOUT */

static int keymap_fun(char *key)
{
    char *func, *efunc;

    if ((func = StrChr(key, ':')) != NULL) {
	*func++ = '\0';
	efunc = StrChr(func, ':');
	/* Allow comments on the ends of key remapping lines. - DT */
	/* Allow third field for line-editor action. - kw */
	if (efunc == func) {	/* have 3rd field, but 2nd field empty */
	    func = NULL;
	} else if (efunc && strncasecomp(efunc + 1, "DIRED", 5) == 0) {
	    if (!remap(key, strtok(func, " \t\n:#"), TRUE)) {
		fprintf(stderr,
			gettext("key remapping of %s to %s for %s failed\n"),
			key, func, efunc + 1);
	    } else if (!strcmp("TOGGLE_HELP", func)) {
		LYUseNoviceLineTwo = FALSE;
	    }
	    return 0;
	} else if (!remap(key, strtok(func, " \t\n:#"), FALSE)) {
	    fprintf(stderr, gettext("key remapping of %s to %s failed\n"),
		    key, func);
	} else {
	    if (!strcmp("TOGGLE_HELP", func))
		LYUseNoviceLineTwo = FALSE;
	}
	if (efunc) {
	    efunc++;
	    if (efunc == strtok((func ? NULL : efunc), " \t\n:#") && *efunc) {
		BOOLEAN success = FALSE;
		int lkc = lkcstring_to_lkc(key);
		int lec = -1;
		int select_edi = 0;
		char *sselect_edi = strtok(NULL, " \t\n:#");
		char **endp = &sselect_edi;

		if (sselect_edi) {
		    if (*sselect_edi)
			select_edi = (int) strtol(sselect_edi, endp, 10);
		    if (**endp != '\0') {
			fprintf(stderr,
				gettext("invalid line-editor selection %s for key %s, selecting all\n"),
				sselect_edi, key);
			select_edi = 0;
		    }
		}
		/*
		 * PASS!  tries to enter the key into the LYLineEditors
		 * bindings in a different way from PASS, namely as binding
		 * that maps to the specific lynx actioncode (rather than to
		 * LYE_FORM_PASS).  That only works for lynx keycodes with
		 * modifier bit set, and we have no documented/official way to
		 * specify this in the KEYMAP directive, although it can be
		 * made to work e.g. by specifying a hex value that has the
		 * modifier bit set.  But knowledge about the bit pattern of
		 * modifiers should remain in internal matter subject to
		 * change...  At any rate, if PASS!  fails try it the same way
		 * as for PASS.  - kw
		 */
		if (!success && strcasecomp(efunc, "PASS!") == 0) {
		    if (func) {
			lec = LYE_FORM_LAC | lacname_to_lac(func);
			success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		    }
		    if (!success)
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    else
			return 0;
		}
		if (!success) {
		    lec = lecname_to_lec(efunc);
		    success = (BOOL) LYRemapEditBinding(lkc, lec, select_edi);
		}
		if (!success) {
		    if (lec != -1) {
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
				key, lkc, lec, efunc);
		    } else {
			fprintf(stderr,
				gettext("setting of line-editor binding for key %s (0x%x) for %s failed\n"),
				key, lkc, efunc);
		    }
		}
	    }
	}
    }
    return 0;
}

static int localhost_alias_fun(char *value)
{
    LYAddLocalhostAlias(value);
    return 0;
}

#ifdef LYNXCGI_LINKS
static int lynxcgi_environment_fun(char *value)
{
    add_lynxcgi_environment(value);
    return 0;
}
#endif

static int lynx_sig_file_fun(char *value)
{
    char temp[LY_MAXPATH];

    LYStrNCpy(temp, value, sizeof(temp) - 1);
    if (LYPathOffHomeOK(temp, sizeof(temp))) {
	StrAllocCopy(LynxSigFile, temp);
	LYAddPathToHome(temp, sizeof(temp), LynxSigFile);
	StrAllocCopy(LynxSigFile, temp);
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
    } else {
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
    }
    return 0;
}

#ifndef DISABLE_NEWS
static int news_chunk_size_fun(char *value)
{
    HTNewsChunkSize = atoi(value);
    /*
     * If the new HTNewsChunkSize exceeds the maximum,
     * increase HTNewsMaxChunk to this size. - FM
     */
    if (HTNewsChunkSize > HTNewsMaxChunk)
	HTNewsMaxChunk = HTNewsChunkSize;
    return 0;
}

static int news_max_chunk_fun(char *value)
{
    HTNewsMaxChunk = atoi(value);
    /*
     * If HTNewsChunkSize exceeds the new maximum,
     * reduce HTNewsChunkSize to this maximum. - FM
     */
    if (HTNewsChunkSize > HTNewsMaxChunk)
	HTNewsChunkSize = HTNewsMaxChunk;
    return 0;
}

static int news_posting_fun(char *value)
{
    LYNewsPosting = is_true(value);
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
    return 0;
}
#endif /* DISABLE_NEWS */

#ifndef NO_RULES
static int cern_rulesfile_fun(char *value)
{
    char *rulesfile1 = NULL;
    char *rulesfile2 = NULL;

    if (HTLoadRules(value) >= 0) {
	return 0;
    }
    StrAllocCopy(rulesfile1, value);
    LYTrimLeading(value);
    LYTrimTrailing(value);

    StrAllocCopy(rulesfile2, value);
    LYTildeExpand(&rulesfile2, FALSE);

    if (strcmp(rulesfile1, rulesfile2) &&
	HTLoadRules(rulesfile2) >= 0) {
	FREE(rulesfile1);
	FREE(rulesfile2);
	return 0;
    }
    fprintf(stderr,
	    gettext("Lynx: cannot start, CERN rules file %s is not available\n"),
	    non_empty(rulesfile2) ? rulesfile2 : gettext("(no name)"));
    exit_immediately(EXIT_FAILURE);
    return 0;			/* though redundant, for compiler-warnings */
}
#endif /* NO_RULES */

static int referer_with_query_fun(char *value)
{
    if (!strncasecomp(value, "SEND", 4))
	LYRefererWithQuery = 'S';
    else if (!strncasecomp(value, "PARTIAL", 7))
	LYRefererWithQuery = 'P';
    else
	LYRefererWithQuery = 'D';
    return 0;
}

static int status_buffer_size_fun(char *value)
{
    status_buf_size = atoi(value);
    if (status_buf_size < 2)
	status_buf_size = 2;
    return 0;
}

static int startfile_fun(char *value)
{
    StrAllocCopy(startfile, value);

#ifdef USE_PROGRAM_DIR
    if (is_url(startfile) == 0) {
	char *tmp = NULL;

	HTSprintf0(&tmp, "%s\\%s", program_dir, startfile);
	FREE(startfile);
	LYLocalFileToURL(&startfile, tmp);
	FREE(tmp);
    }
#endif
    return 0;
}

static int suffix_fun(char *value)
{
    char *mime_type, *p, *parsed;
    const char *encoding = NULL;
    char *sq = NULL;
    char *description = NULL;
    double q = 1.0;

    if ((strlen(value) < 3)
	|| (NULL == (mime_type = StrChr(value, ':')))) {
	CTRACE((tfp, "Invalid SUFFIX:%s ignored.\n", value));
	return 0;
    }

    *mime_type++ = '\0';
    if (*mime_type) {
	if ((parsed = StrChr(mime_type, ':')) != NULL) {
	    *parsed++ = '\0';
	    if ((sq = StrChr(parsed, ':')) != NULL) {
		*sq++ = '\0';
		if ((description = StrChr(sq, ':')) != NULL) {
		    *description++ = '\0';
		    if ((p = StrChr(sq, ':')) != NULL)
			*p = '\0';
		    LYTrimTail(description);
		}
		LYRemoveBlanks(sq);
		if (!*sq)
		    sq = NULL;
	    }
	    LYRemoveBlanks(parsed);
	    LYLowerCase(parsed);
	    if (!*parsed)
		parsed = NULL;
	}
	encoding = parsed;
    }

    LYRemoveBlanks(mime_type);
    /*
     * mime-type is not converted to lowercase on input, to make it possible to
     * reproduce the equivalent of some of the HTInit.c defaults that use mixed
     * case, although that is not recomended.  - kw
     */
    if (!*mime_type) {		/* that's ok now, with an encoding!  */
	CTRACE((tfp, "SUFFIX:%s without MIME type for %s\n", value,
		encoding ? encoding : "what?"));
	mime_type = NULL;	/* that's ok now, with an encoding!  */
	if (!encoding)
	    return 0;
    }

    if (!encoding) {
	if (strstr(mime_type, "tex") != NULL ||
	    strstr(mime_type, "postscript") != NULL ||
	    strstr(mime_type, "sh") != NULL ||
	    strstr(mime_type, "troff") != NULL ||
	    strstr(mime_type, "rtf") != NULL)
	    encoding = "8bit";
	else
	    encoding = "binary";
    }
    if (!sq) {
	q = 1.0;
    } else {
	double df = strtod(sq, &p);

	if (p == sq && df <= 0.0) {
	    CTRACE((tfp, "Invalid q=%s for SUFFIX:%s, using -1.0\n",
		    sq, value));
	    q = -1.0;
	} else {
	    q = df;
	}
    }
    HTSetSuffix5(value, mime_type, encoding, description, q);

    return 0;
}

static int suffix_order_fun(char *value)
{
    char *p = value;
    char *optn;
    BOOLEAN want_file_init_now = FALSE;

    LYUseBuiltinSuffixes = TRUE;
    while ((optn = HTNextTok(&p, ", ", "", NULL)) != NULL) {
	if (!strcasecomp(optn, "NO_BUILTIN")) {
	    LYUseBuiltinSuffixes = FALSE;
	} else if (!strcasecomp(optn, "PRECEDENCE_HERE")) {
	    want_file_init_now = TRUE;
	} else if (!strcasecomp(optn, "PRECEDENCE_OTHER")) {
	    want_file_init_now = FALSE;
	} else {
	    CTRACE((tfp, "Invalid SUFFIX_ORDER:%s\n", optn));
	    break;
	}
    }

    if (want_file_init_now && !FileInitAlreadyDone) {
	HTFileInit();
	FileInitAlreadyDone = TRUE;
    }
    return 0;
}

static int system_editor_fun(char *value)
{
    StrAllocCopy(editor, value);
    system_editor = TRUE;
    return 0;
}

#define SetViewer(mime_type, viewer) \
    HTSetPresentation(mime_type, viewer, 0, 1.0, 3.0, 0.0, 0L, mediaCFG)

static int viewer_fun(char *value)
{
    char *mime_type;
    char *viewer;
    char *environment;

    mime_type = value;

    if ((strlen(value) < 3)
	|| (NULL == (viewer = StrChr(mime_type, ':'))))
	return 0;

    *viewer++ = '\0';

    LYRemoveBlanks(mime_type);
    LYLowerCase(mime_type);

    environment = strrchr(viewer, ':');
    if ((environment != NULL) &&
	(strlen(viewer) > 1) && *(environment - 1) != '\\') {
	*environment++ = '\0';
	remove_backslashes(viewer);
	/*
	 * If environment equals xwindows then only assign the presentation if
	 * there is a $DISPLAY variable.
	 */
	if (!strcasecomp(environment, "XWINDOWS")) {
	    if (LYgetXDisplay() != NULL)
		SetViewer(mime_type, viewer);
	} else if (!strcasecomp(environment, "NON_XWINDOWS")) {
	    if (LYgetXDisplay() == NULL)
		SetViewer(mime_type, viewer);
	} else {
	    SetViewer(mime_type, viewer);
	}
    } else {
	remove_backslashes(viewer);
	SetViewer(mime_type, viewer);
    }

    return 0;
}

static int nonrest_sigwinch_fun(char *value)
{
    if (!strncasecomp(value, "XWINDOWS", 8)) {
	LYNonRestartingSIGWINCH = (BOOL) (LYgetXDisplay() != NULL);
    } else {
	LYNonRestartingSIGWINCH = is_true(value);
    }
    return 0;
}

#ifdef USE_CHARSET_CHOICE
static void matched_charset_choice(int display_charset,
				   int i)
{
    int j;

    if (display_charset && !custom_display_charset) {
	for (custom_display_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_display = TRUE;
    } else if (!display_charset && !custom_assumed_doc_charset) {
	for (custom_assumed_doc_charset = TRUE, j = 0; j < LYNumCharsets; ++j)
	    charset_subsets[j].hide_assumed = TRUE;
    }
    if (display_charset)
	charset_subsets[i].hide_display = FALSE;
    else
	charset_subsets[i].hide_assumed = FALSE;
}

static int parse_charset_choice(char *p,
				int display_charset)	/*if FALSE, then assumed doc charset */
{
    int len, i;
    int matches = 0;

    /*only one charset choice is allowed per line! */
    LYTrimHead(p);
    LYTrimTail(p);
    CTRACE((tfp, "parsing charset choice for %s:\"%s\"",
	    (display_charset ? "display charset" : "assumed doc charset"), p));
    len = (int) strlen(p);
    if (!len) {
	CTRACE((tfp, " - EMPTY STRING\n"));
	return 1;
    }
    if (*p == '*' && len == 1) {
	if (display_charset)
	    for (custom_display_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_display = FALSE;
	else
	    for (custom_assumed_doc_charset = TRUE, i = 0; i < LYNumCharsets; ++i)
		charset_subsets[i].hide_assumed = FALSE;
	CTRACE((tfp, " - all unhidden\n"));
	return 0;
    }
    if (p[len - 1] == '*') {
	--len;
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strncasecomp(p, LYchar_set_names[i], len)) ||
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len))) {
		++matches;
		matched_charset_choice(display_charset, i);
	    }
	}
	CTRACE((tfp, " - %d matches\n", matches));
	return 0;
    } else {
	for (i = 0; i < LYNumCharsets; ++i) {
	    if ((!strcasecomp(p, LYchar_set_names[i])) ||
		(!strcasecomp(p, LYCharSet_UC[i].MIMEname))) {
		matched_charset_choice(display_charset, i);
		++matches;
		CTRACE((tfp, " - OK, %d matches\n", matches));
		return 0;
	    }
	}
	CTRACE((tfp, " - NOT recognised\n"));
	return 1;
    }
}

static int parse_display_charset_choice(char *p)
{
    return parse_charset_choice(p, 1);
}

static int parse_assumed_doc_charset_choice(char *p)
{
    return parse_charset_choice(p, 0);
}

#endif /* USE_CHARSET_CHOICE */

#ifdef USE_EXTERNALS
/*
 * EXTERNAL and EXTERNAL_MENU share the same list.  EXTERNAL_MENU allows
 * setting a different name than the command string.
 */
static int external_fun(char *str)
{
    add_item_to_list(str, &externals, FALSE, TRUE);
    return 0;
}
#endif

#ifdef USE_PRETTYSRC
static void html_src_bad_syntax(char *value,
				char *option_name)
{
    char *buf = 0;

    HTSprintf0(&buf, "HTMLSRC_%s", option_name);
    LYUpperCase(buf);
    fprintf(stderr, "Bad syntax in TAGSPEC %s:%s\n", buf, value);
    exit_immediately(EXIT_FAILURE);
}

static int parse_html_src_spec(HTlexeme lexeme_code, char *value,
			       char *option_name)
{
    /* Now checking the value for being correct.  Since HTML_dtd is not
     * initialized completely (member tags points to non-initiailized data), we
     * use tags_old.  If the syntax is incorrect, then lynx will exit with error
     * message.
     */
    char *ts2;

    if (isEmpty(value))
	return 0;		/* silently ignoring */

#define BS() html_src_bad_syntax(value,option_name)

    ts2 = StrChr(value, ':');
    if (!ts2)
	BS();

    assert(ts2 != NULL);

    *ts2 = '\0';

    CTRACE2(TRACE_CFG, (tfp,
			"LYReadCFG - parsing tagspec '%s:%s' for option '%s'\n",
			value, ts2, option_name));
    html_src_clean_item(lexeme_code);
    if (!html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| !html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE)) {
	*ts2 = ':';
	BS();
    }

    *ts2 = ':';
    StrAllocCopy(HTL_tagspecs[lexeme_code], value);
#undef BS
    return 0;
}

static int psrcspec_fun(char *s)
{
    char *e;
    /* *INDENT-OFF* */
    static Config_Enum lexemnames[] =
    {
	{ "comm",	HTL_comm	},
	{ "tag",	HTL_tag		},
	{ "attrib",	HTL_attrib	},
	{ "attrval",	HTL_attrval	},
	{ "abracket",	HTL_abracket	},
	{ "entity",	HTL_entity	},
	{ "href",	HTL_href	},
	{ "entire",	HTL_entire	},
	{ "badseq",	HTL_badseq	},
	{ "badtag",	HTL_badtag	},
	{ "badattr",	HTL_badattr	},
	{ "sgmlspecial", HTL_sgmlspecial },
	{ NULL,		-1		}
    };
    /* *INDENT-ON* */

    int found;

    e = StrChr(s, ':');
    if (!e) {
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",
		s));
	return 0;
    }
    *e = '\0';
    if (!LYgetEnum(lexemnames, s, &found)) {
	CTRACE((tfp,
		"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",
		s, e + 1));
	return 0;
    }
    parse_html_src_spec((HTlexeme) found, e + 1, s);
    return 0;
}

static int read_htmlsrc_attrname_xform(char *str)
{
    int val;

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
	} else
	    attrname_transform = val;
    } else {
	CTRACE((tfp, "bad value for htmlsrc_attrname_xform (ignored): %s\n",
		str));
    }
    return 0;
}

static int read_htmlsrc_tagname_xform(char *str)
{
    int val;

    if (1 == sscanf(str, "%d", &val)) {
	if (val < 0 || val > 2) {
	    CTRACE((tfp,
		    "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n",
		    val));
	} else
	    tagname_transform = val;
    } else {
	CTRACE((tfp, "bad value for htmlsrc_tagname_xform (ignored): %s\n",
		str));
    }
    return 0;
}
#endif

#ifdef USE_SESSIONS
static int session_limit_fun(char *value)
{
    session_limit = (short) atoi(value);
    if (session_limit < 1)
	session_limit = 1;
    else if (session_limit > MAX_SESSIONS)
	session_limit = MAX_SESSIONS;
    return 0;
}
#endif /* USE_SESSIONS */

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
static int screen_size_fun(char *value)
{
    char *cp;

    if ((cp = StrChr(value, ',')) != 0) {
	*cp++ = '\0';		/* Terminate ID */
	scrsize_x = atoi(value);
	scrsize_y = atoi(cp);
	if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
	    scrsize_x = scrsize_y = 0;
	}
	if ((scrsize_x > 0) && (scrsize_x < 80)) {
	    scrsize_x = 80;
	}
	if ((scrsize_y > 0) && (scrsize_y < 4)) {
	    scrsize_y = 4;
	}
	CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
    }
    return 0;
}
#endif

#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
static int message_language_fun(char *value)
{
    char *tmp = NULL;

    HTSprintf0(&tmp, "LANG=%s", value);
    putenv(tmp);

    LYSetTextDomain();

    return 0;
}
#endif

/* This table is searched ignoring case */
/* *INDENT-OFF* */
static Config_Type Config_Table [] =
{
     PARSE_SET(RC_ACCEPT_ALL_COOKIES,   LYAcceptAllCookies),
     PARSE_TIM(RC_ALERTSECS,            AlertSecs),
#if USE_BLAT_MAILER
     PARSE_SET(RC_ALT_BLAT_MAIL,        mail_is_altblat),
#endif
     PARSE_SET(RC_ALWAYS_RESUBMIT_POSTS, LYresubmit_posts),
#ifdef EXEC_LINKS
     PARSE_DEF(RC_ALWAYS_TRUSTED_EXEC,  ALWAYS_EXEC_PATH),
#endif
     PARSE_FUN(RC_ASSUME_CHARSET,       assume_charset_fun),
     PARSE_FUN(RC_ASSUME_LOCAL_CHARSET, assume_local_charset_fun),
     PARSE_FUN(RC_ASSUME_UNREC_CHARSET, assume_unrec_charset_fun),
#ifdef EXP_ASSUMED_COLOR
     PARSE_FUN(RC_ASSUMED_COLOR,        assumed_color_fun),
#endif
#ifdef USE_CHARSET_CHOICE
     PARSE_FUN(RC_ASSUMED_DOC_CHARSET_CHOICE, parse_assumed_doc_charset_choice),
#endif
#ifdef DIRED_SUPPORT
     PARSE_INT(RC_AUTO_UNCACHE_DIRLISTS, LYAutoUncacheDirLists),
#endif
#ifndef DISABLE_BIBP
     PARSE_STR(RC_BIBP_BIBHOST,         BibP_bibhost),
     PARSE_STR(RC_BIBP_GLOBALSERVER,    BibP_globalserver),
#endif
#if USE_BLAT_MAILER
     PARSE_SET(RC_BLAT_MAIL,            mail_is_blat),
#endif
     PARSE_SET(RC_BLOCK_MULTI_BOOKMARKS, LYMBMBlocked),
     PARSE_SET(RC_BOLD_H1,              bold_H1),
     PARSE_SET(RC_BOLD_HEADERS,         bold_headers),
     PARSE_SET(RC_BOLD_NAME_ANCHORS,    bold_name_anchors),
#ifndef DISABLE_FTP
     PARSE_LST(RC_BROKEN_FTP_EPSV,      broken_ftp_epsv),
     PARSE_LST(RC_BROKEN_FTP_RETR,      broken_ftp_retr),
#endif
     PARSE_PRG(RC_BZIP2_PATH,           ppBZIP2),
     PARSE_SET(RC_CASE_SENSITIVE_ALWAYS_ON, LYcase_sensitive),
     PARSE_FUN(RC_CHARACTER_SET,        character_set_fun),
#ifdef CAN_SWITCH_DISPLAY_CHARSET
     PARSE_STR(RC_CHARSET_SWITCH_RULES, charset_switch_rules),
     PARSE_STR(RC_CHARSETS_DIRECTORY,   charsets_directory),
#endif
     PARSE_SET(RC_CHECKMAIL,            check_mail),
     PARSE_PRG(RC_CHMOD_PATH,           ppCHMOD),
     PARSE_SET(RC_COLLAPSE_BR_TAGS,     LYCollapseBRs),
#ifdef USE_COLOR_TABLE
     PARSE_FUN(RC_COLOR,                color_fun),
#endif
#ifdef USE_COLOR_STYLE
     PARSE_FUN(RC_COLOR_STYLE,          lynx_lss_file_fun),
#endif
     PARSE_PRG(RC_COMPRESS_PATH,        ppCOMPRESS),
     PARSE_PRG(RC_COPY_PATH,            ppCOPY),
     PARSE_INT(RC_CONNECT_TIMEOUT,      connect_timeout),
     PARSE_SET(RC_CONV_JISX0201KANA,    conv_jisx0201kana),
     PARSE_STR(RC_COOKIE_ACCEPT_DOMAINS, LYCookieSAcceptDomains),
#ifdef USE_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_FILE,          LYCookieFile),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieSLooseCheckDomains),
     PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieSQueryCheckDomains),
     PARSE_STR(RC_COOKIE_REJECT_DOMAINS, LYCookieSRejectDomains),
#ifdef USE_PERSISTENT_COOKIES
     PARSE_STR(RC_COOKIE_SAVE_FILE,     LYCookieSaveFile),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieSStrictCheckDomains),
     PARSE_Env(RC_CSO_PROXY,            0),
#ifdef VMS
     PARSE_PRG(RC_CSWING_PATH,          ppCSWING),
#endif
     PARSE_TIM(RC_DELAYSECS,            DelaySecs),
     PARSE_FUN(RC_DEFAULT_BOOKMARK_FILE, default_bookmark_file_fun),
     PARSE_FUN(RC_DEFAULT_CACHE_SIZE,   default_cache_size_fun),
#ifdef USE_DEFAULT_COLORS
     PARSE_FUN(RC_DEFAULT_COLORS,       default_colors_fun),
#endif
     PARSE_FUN(RC_DEFAULT_EDITOR,       default_editor_fun),
     PARSE_STR(RC_DEFAULT_INDEX_FILE,   indexfile),
     PARSE_ENU(RC_DEFAULT_KEYPAD_MODE,  keypad_mode, tbl_keypad_mode),
     PARSE_FUN(RC_DEFAULT_KEYPAD_MODE_NUMARO, numbers_as_arrows_fun),
     PARSE_ENU(RC_DEFAULT_USER_MODE,    user_mode, tbl_user_mode),
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
     PARSE_INT(RC_DEFAULT_VIRTUAL_MEMORY_SIZE, HTVirtualMemorySize),
#endif
#ifdef DIRED_SUPPORT
     PARSE_FUN(RC_DIRED_MENU,           dired_menu_fun),
#endif
#ifdef USE_CHARSET_CHOICE
     PARSE_FUN(RC_DISPLAY_CHARSET_CHOICE, parse_display_charset_choice),
#endif
     PARSE_SET(RC_DONT_WRAP_PRE,        dont_wrap_pre),
     PARSE_ADD(RC_DOWNLOADER,           downloaders),
     PARSE_SET(RC_EMACS_KEYS_ALWAYS_ON, emacs_keys),
     PARSE_FUN(RC_ENABLE_LYNXRC,        enable_lynxrc),
     PARSE_SET(RC_ENABLE_SCROLLBACK,    enable_scrollback),
#ifdef USE_EXTERNALS
     PARSE_ADD(RC_EXTERNAL,             externals),
     PARSE_FUN(RC_EXTERNAL_MENU,        external_fun),
#endif
     PARSE_Env(RC_FINGER_PROXY,         0),
#if defined(_WINDOWS)	/* 1998/10/05 (Mon) 17:34:15 */
     PARSE_SET(RC_FOCUS_WINDOW,         focus_window),
#endif
     PARSE_SET(RC_FORCE_8BIT_TOUPPER,   UCForce8bitTOUPPER),
     PARSE_ENU(RC_FORCE_COOKIE_PROMPT,  cookie_noprompt, tbl_force_prompt),
     PARSE_SET(RC_FORCE_EMPTY_HREFLESS_A, force_empty_hrefless_a),
     PARSE_SET(RC_FORCE_HTML,           LYforce_HTML_mode),
     PARSE_SET(RC_FORCE_SSL_COOKIES_SECURE, LYForceSSLCookiesSecure),
#ifdef USE_SSL
     PARSE_ENU(RC_FORCE_SSL_PROMPT,     ssl_noprompt, tbl_force_prompt),
#endif
#if !defined(NO_OPTION_FORMS) && !defined(NO_OPTION_MENU)
     PARSE_SET(RC_FORMS_OPTIONS,        LYUseFormsOptions),
#endif
     PARSE_STR(RC_FTP_FORMAT,           ftp_format),
#ifndef DISABLE_FTP
     PARSE_SET(RC_FTP_PASSIVE,          ftp_passive),
#endif
     PARSE_Env(RC_FTP_PROXY,            0),
     PARSE_STR(RC_GLOBAL_EXTENSION_MAP, global_extension_map),
     PARSE_STR(RC_GLOBAL_MAILCAP,       global_type_map),
     PARSE_Env(RC_GOPHER_PROXY,         0),
     PARSE_SET(RC_GOTOBUFFER,           goto_buffer),
     PARSE_PRG(RC_GZIP_PATH,            ppGZIP),
     PARSE_STR(RC_HELPFILE,             helpfile),
     PARSE_FUN(RC_HIDDENLINKS,          hiddenlinks_fun),
#ifdef MARK_HIDDEN_LINKS
     PARSE_STR(RC_HIDDEN_LINK_MARKER,   hidden_link_marker),
#endif
     PARSE_SET(RC_HISTORICAL_COMMENTS,  historical_comments),
     PARSE_SET(RC_HTML5_CHARSETS,       html5_charsets),
#ifdef USE_PRETTYSRC
     PARSE_FUN(RC_HTMLSRC_ATTRNAME_XFORM, read_htmlsrc_attrname_xform),
     PARSE_FUN(RC_HTMLSRC_TAGNAME_XFORM, read_htmlsrc_tagname_xform),
#endif
     PARSE_Env(RC_HTTP_PROXY,           0),
     PARSE_Env(RC_HTTPS_PROXY,          0),
     PARSE_REQ(RC_INCLUDE,              0),
     PARSE_PRG(RC_INFLATE_PATH,         ppINFLATE),
     PARSE_TIM(RC_INFOSECS,             InfoSecs),
     PARSE_PRG(RC_INSTALL_PATH,         ppINSTALL),
     PARSE_STR(RC_JUMP_PROMPT,          jumpprompt),
     PARSE_SET(RC_JUMPBUFFER,           jump_buffer),
     PARSE_FUN(RC_JUMPFILE,             jumpfile_fun),
#ifdef USE_JUSTIFY_ELTS
     PARSE_SET(RC_JUSTIFY,              ok_justify),
     PARSE_INT(RC_JUSTIFY_MAX_VOID_PERCENT, justify_max_void_percent),
#endif
#ifdef EXP_KEYBOARD_LAYOUT
     PARSE_FUN(RC_KEYBOARD_LAYOUT,      keyboard_layout_fun),
#endif
     PARSE_FUN(RC_KEYMAP,               keymap_fun),
     PARSE_SET(RC_LEFTARROW_IN_TEXTFLD_PROMPT, textfield_prompt_at_left_edge),
     PARSE_SET(RC_LISTONLY,             dump_links_only),
#ifndef VMS
     PARSE_STR(RC_LIST_FORMAT,          list_format),
#endif
     PARSE_SET(RC_LIST_INLINE,          dump_links_inline),
#ifndef DISABLE_NEWS
     PARSE_SET(RC_LIST_NEWS_DATES,      LYListNewsDates),
     PARSE_SET(RC_LIST_NEWS_NUMBERS,    LYListNewsNumbers),
#endif
#ifdef USE_LOCALE_CHARSET
     PARSE_SET(RC_LOCALE_CHARSET,       LYLocaleCharset),
#endif
     PARSE_STR(RC_LOCAL_DOMAIN,         LYLocalDomain),
     PARSE_SET(RC_LOCALHOST,            local_host_only),
     PARSE_FUN(RC_LOCALHOST_ALIAS,      localhost_alias_fun),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_ALWAYS, local_exec),
     PARSE_SET(RC_LOCAL_EXECUTION_LINKS_LOCAL, local_exec_on_local_files),
#endif
     PARSE_STR(RC_LYNX_HOST_NAME,       LYHostName),
     PARSE_FUN(RC_LYNX_SIG_FILE,        lynx_sig_file_fun),
#ifdef LYNXCGI_LINKS
#ifndef VMS
     PARSE_STR(RC_LYNXCGI_DOCUMENT_ROOT, LYCgiDocumentRoot),
#endif
     PARSE_FUN(RC_LYNXCGI_ENVIRONMENT,  lynxcgi_environment_fun),
#endif
#if USE_VMS_MAILER
     PARSE_STR(RC_MAIL_ADRS,            mail_adrs),
#endif
     PARSE_SET(RC_MAIL_SYSTEM_ERROR_LOGGING, error_logging),
     PARSE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images),
     PARSE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts),
     PARSE_INT(RC_MAX_COOKIES_BUFFER,   max_cookies_buffer),
     PARSE_INT(RC_MAX_COOKIES_DOMAIN,   max_cookies_domain),
     PARSE_INT(RC_MAX_COOKIES_GLOBAL,   max_cookies_global),
     PARSE_INT(RC_MAX_URI_SIZE,         max_uri_size),
     PARSE_TIM(RC_MESSAGESECS,          MessageSecs),
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
     PARSE_FUN(RC_MESSAGE_LANGUAGE,     message_language_fun),
#endif
     PARSE_SET(RC_MINIMAL_COMMENTS,     minimal_comments),
     PARSE_PRG(RC_MKDIR_PATH,           ppMKDIR),
     PARSE_ENU(RC_MULTI_BOOKMARK_SUPPORT, LYMultiBookmarks, tbl_multi_bookmarks),
     PARSE_PRG(RC_MV_PATH,              ppMV),
     PARSE_SET(RC_NCR_IN_BOOKMARKS,     UCSaveBookmarksInUnicode),
#ifdef EXP_NESTED_TABLES
     PARSE_SET(RC_NESTED_TABLES,        nested_tables),
#endif
#ifndef DISABLE_NEWS
     PARSE_FUN(RC_NEWS_CHUNK_SIZE,      news_chunk_size_fun),
     PARSE_FUN(RC_NEWS_MAX_CHUNK,       news_max_chunk_fun),
     PARSE_FUN(RC_NEWS_POSTING,         news_posting_fun),
     PARSE_Env(RC_NEWS_PROXY,           0),
     PARSE_Env(RC_NEWSPOST_PROXY,       0),
     PARSE_Env(RC_NEWSREPLY_PROXY,      0),
     PARSE_Env(RC_NNTP_PROXY,           0),
     PARSE_ENV(RC_NNTPSERVER,           0), /* actually NNTPSERVER */
#endif
     PARSE_SET(RC_NUMBER_FIELDS_ON_LEFT,number_fields_on_left),
     PARSE_SET(RC_NUMBER_LINKS_ON_LEFT, number_links_on_left),
     PARSE_SET(RC_NO_DOT_FILES,         no_dotfiles),
     PARSE_SET(RC_NO_FILE_REFERER,      no_filereferer),
#ifndef VMS
     PARSE_SET(RC_NO_FORCED_CORE_DUMP,  LYNoCore),
#endif
     PARSE_SET(RC_NO_FROM_HEADER,       LYNoFromHeader),
     PARSE_SET(RC_NO_ISMAP_IF_USEMAP,   LYNoISMAPifUSEMAP),
     PARSE_SET(RC_NO_MARGINS,           no_margins),
     PARSE_SET(RC_NO_PAUSE,             no_pause),
     PARSE_Env(RC_NO_PROXY,             0),
     PARSE_SET(RC_NO_REFERER_HEADER,    LYNoRefererHeader),
     PARSE_SET(RC_NO_TABLE_CENTER,      no_table_center),
     PARSE_SET(RC_NO_TITLE,             no_title),
     PARSE_FUN(RC_NONRESTARTING_SIGWINCH, nonrest_sigwinch_fun),
     PARSE_FUN(RC_OUTGOING_MAIL_CHARSET, outgoing_mail_charset_fun),
#ifdef DISP_PARTIAL
     PARSE_SET(RC_PARTIAL,              display_partial_flag),
     PARSE_INT(RC_PARTIAL_THRES,        partial_threshold),
#endif
#ifdef USE_PERSISTENT_COOKIES
     PARSE_SET(RC_PERSISTENT_COOKIES,   persistent_cookies),
#endif /* USE_PERSISTENT_COOKIES */
     PARSE_STR(RC_PERSONAL_EXTENSION_MAP, personal_extension_map),
     PARSE_STR(RC_PERSONAL_MAILCAP,     personal_type_map),
     PARSE_LST(RC_POSITIONABLE_EDITOR,  positionable_editor),
     PARSE_STR(RC_PREFERRED_CHARSET,    pref_charset),
     PARSE_ENU(RC_PREFERRED_ENCODING,   LYAcceptEncoding, tbl_preferred_encoding),
     PARSE_STR(RC_PREFERRED_LANGUAGE,   language),
     PARSE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia, tbl_preferred_media),
     PARSE_SET(RC_PREPEND_BASE_TO_SOURCE, LYPrependBaseToSource),
     PARSE_SET(RC_PREPEND_CHARSET_TO_SOURCE, LYPrependCharsetToSource),
#ifdef USE_PRETTYSRC
     PARSE_SET(RC_PRETTYSRC,            LYpsrc),
     PARSE_FUN(RC_PRETTYSRC_SPEC,       psrcspec_fun),
     PARSE_SET(RC_PRETTYSRC_VIEW_NO_ANCHOR_NUM, psrcview_no_anchor_numbering),
#endif
     PARSE_ADD(RC_PRINTER,              printers),
     PARSE_SET(RC_QUIT_DEFAULT_YES,     LYQuitDefaultYes),
     PARSE_INT(RC_READ_TIMEOUT,         reading_timeout),
     PARSE_FUN(RC_REFERER_WITH_QUERY,   referer_with_query_fun),
#ifdef USE_CMD_LOGGING
     PARSE_TIM(RC_REPLAYSECS,           ReplaySecs),
#endif
     PARSE_SET(RC_REUSE_TEMPFILES,      LYReuseTempfiles),
     PARSE_PRG(RC_RLOGIN_PATH,          ppRLOGIN),
     PARSE_PRG(RC_RMDIR_PATH,           ppRMDIR),
     PARSE_PRG(RC_RM_PATH,              ppRM),
#ifndef NO_RULES
     PARSE_FUN(RC_RULE,                 HTSetConfiguration),
     PARSE_FUN(RC_RULESFILE,            cern_rulesfile_fun),
#endif /* NO_RULES */
     PARSE_STR(RC_SAVE_SPACE,           lynx_save_space),
     PARSE_SET(RC_SCAN_FOR_BURIED_NEWS_REFS, scan_for_buried_news_references),
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
     PARSE_FUN(RC_SCREEN_SIZE,          screen_size_fun),
#endif
#ifdef USE_SCROLLBAR
     PARSE_SET(RC_SCROLLBAR,            LYShowScrollbar),
     PARSE_SET(RC_SCROLLBAR_ARROW,      LYsb_arrow),
#endif
     PARSE_SET(RC_SEEK_FRAG_AREA_IN_CUR, LYSeekFragAREAinCur),
     PARSE_SET(RC_SEEK_FRAG_MAP_IN_CUR, LYSeekFragMAPinCur),
#ifdef USE_SESSIONS
     PARSE_SET(RC_AUTO_SESSION,         LYAutoSession),
     PARSE_STR(RC_SESSION_FILE,         LYSessionFile),
     PARSE_FUN(RC_SESSION_LIMIT,        session_limit_fun),
#endif
     PARSE_SET(RC_SET_COOKIES,          LYSetCookies),
     PARSE_SET(RC_SHORT_URL,            long_url_ok),
     PARSE_SET(RC_SHOW_CURSOR,          LYShowCursor),
     PARSE_STR(RC_SHOW_KB_NAME,         LYTransferName),
     PARSE_ENU(RC_SHOW_KB_RATE,         LYTransferRate, tbl_transfer_rate),
     PARSE_Env(RC_SNEWS_PROXY,          0),
     PARSE_Env(RC_SNEWSPOST_PROXY,      0),
     PARSE_Env(RC_SNEWSREPLY_PROXY,     0),
     PARSE_SET(RC_SOFT_DQUOTES,         soft_dquotes),
#ifdef USE_SOURCE_CACHE
     PARSE_ENU(RC_SOURCE_CACHE,         LYCacheSource, tbl_source_cache),
     PARSE_ENU(RC_SOURCE_CACHE_FOR_ABORTED, LYCacheSourceForAborted, tbl_abort_source_cache),
#endif
     PARSE_STR(RC_SSL_CERT_FILE,        SSL_cert_file),
     PARSE_FUN(RC_STARTFILE,            startfile_fun),
     PARSE_FUN(RC_STATUS_BUFFER_SIZE,   status_buffer_size_fun),
     PARSE_SET(RC_STRIP_DOTDOT_URLS,    LYStripDotDotURLs),
     PARSE_SET(RC_SUBSTITUTE_UNDERSCORES, use_underscore),
     PARSE_FUN(RC_SUFFIX,               suffix_fun),
     PARSE_FUN(RC_SUFFIX_ORDER,         suffix_order_fun),
#ifdef SYSLOG_REQUESTED_URLS
     PARSE_SET(RC_SYSLOG_REQUESTED_URLS, syslog_requested_urls),
     PARSE_STR(RC_SYSLOG_TEXT,          syslog_txt),
#endif
     PARSE_FUN(RC_SYSTEM_EDITOR,        system_editor_fun),
     PARSE_STR(RC_SYSTEM_MAIL,          system_mail),
     PARSE_STR(RC_SYSTEM_MAIL_FLAGS,    system_mail_flags),
     PARSE_FUN(RC_TAGSOUP,              get_tagsoup),
     PARSE_PRG(RC_TAR_PATH,             ppTAR),
     PARSE_PRG(RC_TELNET_PATH,          ppTELNET),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
     PARSE_SET(RC_TEXTFIELDS_NEED_ACTIVATION, textfields_activation_option),
#endif
     PARSE_PRG(RC_TN3270_PATH,          ppTN3270),
#if defined(_WINDOWS)
     PARSE_INT(RC_TIMEOUT,              lynx_timeout),
#endif
     PARSE_PRG(RC_TOUCH_PATH,           ppTOUCH),
     PARSE_SET(RC_TRACK_INTERNAL_LINKS, track_internal_links),
     PARSE_SET(RC_TRIM_INPUT_FIELDS,    LYtrimInputFields),
#ifdef EXEC_LINKS
     PARSE_DEF(RC_TRUSTED_EXEC,         EXEC_PATH),
#endif
#ifdef LYNXCGI_LINKS
     PARSE_DEF(RC_TRUSTED_LYNXCGI,      CGI_PATH),
#endif
     PARSE_PRG(RC_UNCOMPRESS_PATH,      ppUNCOMPRESS),
     PARSE_SET(RC_UNDERLINE_LINKS,      LYUnderlineLinks),
     PARSE_SET(RC_UNIQUE_URLS,          unique_urls),
     PARSE_PRG(RC_UNZIP_PATH,           ppUNZIP),
#ifdef DIRED_SUPPORT
     PARSE_ADD(RC_UPLOADER,             uploaders),
#endif
     PARSE_STR(RC_URL_DOMAIN_PREFIXES,  URLDomainPrefixes),
     PARSE_STR(RC_URL_DOMAIN_SUFFIXES,  URLDomainSuffixes),
#ifdef VMS
     PARSE_SET(RC_USE_FIXED_RECORDS,    UseFixedRecords),
#endif
#if defined(USE_MOUSE)
     PARSE_SET(RC_USE_MOUSE,            LYUseMouse),
#endif
     PARSE_SET(RC_USE_SELECT_POPUPS,    LYSelectPopups),
     PARSE_PRG(RC_UUDECODE_PATH,        ppUUDECODE),
     PARSE_SET(RC_VERBOSE_IMAGES,       verbose_img),
     PARSE_SET(RC_VI_KEYS_ALWAYS_ON,    vi_keys),
     PARSE_FUN(RC_VIEWER,               viewer_fun),
     PARSE_Env(RC_WAIS_PROXY,           0),
     PARSE_SET(RC_WAIT_VIEWER_TERMINATION, wait_viewer_termination),
     PARSE_SET(RC_WITH_BACKSPACES,      with_backspaces),
     PARSE_STR(RC_XLOADIMAGE_COMMAND,   XLoadImageCommand),
     PARSE_SET(RC_XHTML_PARSING,        LYxhtml_parsing),
     PARSE_PRG(RC_ZCAT_PATH,            ppZCAT),
     PARSE_PRG(RC_ZIP_PATH,             ppZIP),

     PARSE_NIL
};
/* *INDENT-ON* */

static char *lynxcfginfo_url = NULL;	/* static */

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
static char *configinfo_url = NULL;	/* static */
#endif

/*
 * Free memory allocated in 'read_cfg()'
 */
void free_lynx_cfg(void)
{
    Config_Type *tbl;

    for (tbl = Config_Table; tbl->name != 0; tbl++) {
	ParseUnionPtr q = ParseUnionOf(tbl);

	switch (tbl->type) {
	case CONF_ENV:
	    if (q->str_value != 0) {
		char *name = *(q->str_value);
		char *eqls = StrChr(name, '=');

		if (eqls != 0) {
		    *eqls = 0;
#ifdef VMS
		    Define_VMSLogical(name, NULL);
#else
# ifdef HAVE_PUTENV
		    if (putenv(name))
			break;
# else
		    unsetenv(name);
# endif
#endif
		}
		FREE(*(q->str_value));
		FREE(q->str_value);
		/* is it enough for reload_read_cfg() to clean up
		 * the result of putenv()?  No for certain platforms.
		 */
	    }
	    break;
	default:
	    break;
	}
    }
    free_all_item_lists();
#ifdef DIRED_SUPPORT
    reset_dired_menu();		/* frees and resets dired menu items - kw */
#endif
    FREE(lynxcfginfo_url);
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
    FREE(configinfo_url);
#endif
}

static Config_Type *lookup_config(const char *name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	char ch1 = tbl->name[0];

	if ((ch == TOUPPER(ch1))
	    && (0 == strcasecomp(name, tbl->name)))
	    break;

	tbl++;
    }
    return tbl;
}

/*
 * If the given value is an absolute path (by syntax), or we can read it, use
 * the value as given.  Otherwise, assume it must be in the same place we read
 * the parent configuration file from.
 *
 * Note:  only read files from the current directory if there's no parent
 * filename, otherwise it leads to user surprise.
 */
static char *actual_filename(const char *cfg_filename,
			     const char *parent_filename,
			     const char *dft_filename)
{
    char *my_filename = NULL;

    if (!LYisAbsPath(cfg_filename)
	&& !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
	if (LYIsTilde(cfg_filename[0]) && LYIsPathSep(cfg_filename[1])) {
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename + 1);
	} else {
	    if (parent_filename != 0) {
		StrAllocCopy(my_filename, parent_filename);
		*LYPathLeaf(my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
	    }
	    if (my_filename == 0 || !LYCanReadFile(my_filename)) {
		StrAllocCopy(my_filename, dft_filename);
		*LYPathLeaf(my_filename) = '\0';
		StrAllocCat(my_filename, cfg_filename);
		if (!LYCanReadFile(my_filename)) {
		    StrAllocCopy(my_filename,
				 LYFindConfigFile(cfg_filename,
						  dft_filename));
		}
	    }
	}
    } else {
	StrAllocCopy(my_filename, cfg_filename);
    }
    return my_filename;
}

FILE *LYOpenCFG(const char *cfg_filename,
		const char *parent_filename,
		const char *dft_filename)
{
    char *my_file = actual_filename(cfg_filename, parent_filename, dft_filename);
    FILE *result;

    CTRACE((tfp, "opening config file %s\n", my_file));
    result = fopen(my_file, TXT_R);
    FREE(my_file);

    return result;
}

#define NOPTS_ ( TABLESIZE(Config_Table) - 1 )
typedef BOOL (optidx_set_t)[NOPTS_];

 /* if element is FALSE, then it's allowed in the current file */

#define optidx_set_AND(r,a,b) \
    {\
	unsigned i1;\
	for (i1 = 0; i1 < NOPTS_; ++i1) \
	    (r)[i1]= (BOOLEAN) ((a)[i1] || (b)[i1]); \
    }

/*
 * For simple (boolean, string, integer, time) values, set the corresponding
 * configuration variable.
 */
BOOL LYSetConfigValue(const char *name,
		      const char *param)
{
    BOOL changed = TRUE;
    char *value = NULL;
    Config_Type *tbl = lookup_config(name);
    ParseUnionPtr q = ParseUnionOf(tbl);
    char *temp_name = 0;
    char *temp_value = 0;

    StrAllocCopy(value, param);
    switch (tbl->type) {
    case CONF_BOOL:
	if (q->set_value != 0)
	    *(q->set_value) = is_true(value);
	break;

    case CONF_FUN:
	if (q->fun_value != 0)
	    (*(q->fun_value)) (value);
	break;

    case CONF_TIME:
	if (q->int_value != 0) {
	    float ival;

	    if (1 == LYscanFloat(value, &ival)) {
		*(q->int_value) = (int) SECS2Secs(ival);
	    }
	}
	break;

    case CONF_ENUM:
	if (tbl->table != 0)
	    LYgetEnum(tbl->table, value, q->int_value);
	break;

    case CONF_INT:
	if (q->int_value != 0) {
	    int ival;

	    if (1 == sscanf(value, "%d", &ival))
		*(q->int_value) = ival;
	}
	break;

    case CONF_STR:
	if (q->str_value != 0)
	    StrAllocCopy(*(q->str_value), value);
	break;

    case CONF_ENV:
    case CONF_ENV2:

	if (StrAllocCopy(temp_name, name)) {
	    if (tbl->type == CONF_ENV)
		LYLowerCase(temp_name);
	    else
		LYUpperCase(temp_name);

	    if (LYGetEnv(temp_name) == 0) {
#ifdef VMS
		Define_VMSLogical(temp_name, value);
#else
		if (q->str_value == 0) {
		    q->str_value = typecalloc(char *);

		    if (q->str_value == 0)
			outofmem(__FILE__, "LYSetConfigValue");
		}

		HTSprintf0(q->str_value, "%s=%s", temp_name, value);
		putenv(*(q->str_value));
#endif
	    }
	    FREE(temp_name);
	}
	break;
    case CONF_ADD_ITEM:
	if (q->add_value != 0)
	    add_item_to_list(value,
			     q->add_value,
			     (q->add_value == &printers),
			     FALSE);
	break;

    case CONF_ADD_STRING:
	if (*(q->lst_value) == NULL) {
	    *(q->lst_value) = HTList_new();
	}
	temp_value = NULL;
	StrAllocCopy(temp_value, value);
	HTList_appendObject(*(q->lst_value), temp_value);
	temp_value = NULL;
	break;

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)
    case CONF_ADD_TRUSTED:
	add_trusted(value, (int) q->def_value);
	break;
#endif

    case CONF_PRG:
	if (isEmpty(value)) {
	    HTSetProgramPath((ProgramPaths) (q->def_value), NULL);
	} else if (StrAllocCopy(temp_value, value)) {
	    HTSetProgramPath((ProgramPaths) (q->def_value), temp_value);
	}
	break;

    default:
	changed = FALSE;
	break;
    }
    FREE(value);

    return changed;
}

/*
 * Process the configuration file (lynx.cfg).
 *
 * 'allowed' is a pointer to HTList of allowed options.  Since the included
 * file can also include other files with a list of acceptable options, these
 * lists are ANDed.
 */
static void do_read_cfg(const char *cfg_filename,
			const char *parent_filename,
			int nesting_level,
			FILE *fp0,
			optidx_set_t *allowed)
{
    FILE *fp;
    char *buffer = 0;

    CTRACE((tfp, "Loading cfg file '%s'.\n", cfg_filename));

    /*
     * Don't get hung up by an include file loop.  Arbitrary max depth
     * of 10.  - BL
     */
    if (nesting_level > 10) {
	fprintf(stderr,
		gettext("More than %d nested lynx.cfg includes -- perhaps there is a loop?!?\n"),
		nesting_level - 1);
	fprintf(stderr, gettext("Last attempted include was '%s',\n"), cfg_filename);
	fprintf(stderr, gettext("included from '%s'.\n"), parent_filename);
	exit_immediately(EXIT_FAILURE);
    }
    /*
     * Locate and open the file.
     */
    if (!cfg_filename || strlen(cfg_filename) == 0) {
	CTRACE((tfp, "No filename following -cfg switch!\n"));
	return;
    }
    if ((fp = LYOpenCFG(cfg_filename, parent_filename, LYNX_CFG_FILE)) == 0) {
	CTRACE((tfp, "lynx.cfg file not found as '%s'\n", cfg_filename));
	return;
    }
    have_read_cfg = TRUE;

    /*
     * Process each line in the file.
     */
    if (show_cfg) {
	time_t t;

	time(&t);
	printf("### %s %s, at %s", LYNX_NAME, LYNX_VERSION, ctime(&t));
    }
    while (LYSafeGets(&buffer, fp) != 0) {
	char *name, *value;
	char *cp;
	Config_Type *tbl;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	name = LYSkipBlanks(buffer);

	if (ispunct(UCH(*name)))
	    continue;

	LYTrimTrailing(name);

	if (*name == 0)
	    continue;

	/* Significant lines are of the form KEYWORD:WHATEVER */
	if ((value = StrChr(name, ':')) == 0) {
	    /* fprintf (stderr, "Bad line-- no :\n"); */
	    CTRACE((tfp, "LYReadCFG: missing ':' %s\n", name));
	    continue;
	}

	/* skip past colon, but replace ':' with 0 to make name meaningful */
	*value++ = 0;

	/*
	 * Trim off any trailing comments.
	 *
	 * (Apparently, the original code considers a trailing comment valid
	 * only if preceded by a space character but is not followed by a
	 * colon.  -- JED)
	 */
	if ((cp = strrchr(value, ':')) == 0)
	    cp = value;
	if ((cp = StrChr(cp, '#')) != 0) {
	    cp--;
	    if (isspace(UCH(*cp)))
		*cp = 0;
	}

	CTRACE2(TRACE_CFG, (tfp, "LYReadCFG %s:%s\n", name, value));
	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    /* lynx ignores unknown keywords */
	    CTRACE((tfp, "LYReadCFG: ignored %s:%s\n", name, value));
	    continue;
	}
	if (show_cfg)
	    printf("%s:%s\n", name, value);

	if (allowed && (*allowed)[tbl - Config_Table]) {
	    if (fp0 == NULL)
		fprintf(stderr, "%s is not allowed in the %s\n",
			name, cfg_filename);
	    /*FIXME: we can do something wiser if we are generating
	       the html representation of lynx.cfg - say include this line
	       in bold, or something... */

	    continue;
	}

	(void) ParseUnionOf(tbl);
	switch ((fp0 != 0 && tbl->type != CONF_INCLUDE)
		? CONF_NIL
		: tbl->type) {
	case CONF_BOOL:
	case CONF_FUN:
	case CONF_TIME:
	case CONF_ENUM:
	case CONF_INT:
	case CONF_STR:
	case CONF_ENV:
	case CONF_ENV2:
	case CONF_PRG:
	case CONF_ADD_ITEM:
	case CONF_ADD_STRING:
	case CONF_ADD_TRUSTED:
	    LYSetConfigValue(name, value);
	    break;

	case CONF_INCLUDE:{
		/* include another file */
		optidx_set_t cur_set, anded_set;
		optidx_set_t *resultant_set = NULL;
		char *p1, *p2, savechar;
		BOOL any_optname_found = FALSE;

		char *url = NULL;
		char *cp1 = NULL;
		const char *sep = NULL;

		if ((p1 = strstr(value, sep = " for ")) != 0
#if defined(UNIX) && !defined(USE_DOS_DRIVES)
		    || (p1 = strstr(value, sep = ":")) != 0
#endif
		    ) {
		    *p1 = '\0';
		    p1 += strlen(sep);
		}
#ifndef NO_CONFIG_INFO
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);

		    LYLocalFileToURL(&url, my_file);
		    FREE(my_file);
		    StrAllocCopy(cp1, value);
		    if (StrChr(value, '&') || StrChr(value, '<')) {
			LYEntify(&cp1, TRUE);
		    }

		    fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
		    fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
		}
#endif

		if (p1) {
		    while (*(p1 = LYSkipBlanks(p1)) != 0) {
			Config_Type *tbl2;

			p2 = LYSkipNonBlanks(p1);
			savechar = *p2;
			*p2 = 0;

			tbl2 = lookup_config(p1);
			if (tbl2->name == 0) {
			    if (fp0 == NULL)
				fprintf(stderr,
					"unknown option name %s in %s\n",
					p1, cfg_filename);
			} else {
			    unsigned i;

			    if (!any_optname_found) {
				any_optname_found = TRUE;
				for (i = 0; i < NOPTS_; ++i)
				    cur_set[i] = TRUE;
			    }
			    cur_set[tbl2 - Config_Table] = FALSE;
			}
			if (savechar && p2[1])
			    p1 = p2 + 1;
			else
			    break;
		    }
		}
		if (!allowed) {
		    if (!any_optname_found)
			resultant_set = NULL;
		    else
			resultant_set = &cur_set;
		} else {
		    if (!any_optname_found)
			resultant_set = allowed;
		    else {
			optidx_set_AND(anded_set, *allowed, cur_set);
			resultant_set = &anded_set;
		    }
		}

#ifndef NO_CONFIG_INFO
		/*
		 * Now list the opts that are allowed in included file.  If all
		 * opts are allowed, then emit nothing, else emit an effective set
		 * of allowed options in <ul>.  Option names will be uppercased.
		 * FIXME:  uppercasing option names can be considered redundant.
		 */
		if (fp0 != 0 && !no_lynxcfg_xinfo && resultant_set) {
		    char *buf = NULL;
		    unsigned i;

		    fprintf(fp0, "     Options allowed in this file:\n");
		    for (i = 0; i < NOPTS_; ++i) {
			if ((*resultant_set)[i])
			    continue;
			StrAllocCopy(buf, Config_Table[i].name);
			LYUpperCase(buf);
			fprintf(fp0, "         * %s\n", buf);
		    }
		    FREE(buf);
		}
#endif
		do_read_cfg(value, cfg_filename, nesting_level + 1, fp0, resultant_set);

#ifndef NO_CONFIG_INFO
		if (fp0 != 0 && !no_lynxcfg_xinfo) {
		    fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
		    FREE(url);
		    FREE(cp1);
		}
#endif
	    }
	    break;

	default:
	    if (fp0 != 0) {
		if (StrChr(value, '&') || StrChr(value, '<')) {
		    char *cp1 = NULL;

		    StrAllocCopy(cp1, value);
		    LYEntify(&cp1, TRUE);
		    fprintf(fp0, "%s:%s\n", name, cp1);
		    FREE(cp1);
		} else {
		    fprintf(fp0, "%s:%s\n", name, value);
		}
	    }
	    break;
	}
    }

    LYCloseInput(fp);

    /*
     * If any DOWNLOADER:  commands have always_enabled set (:TRUE), make
     * override_no_download TRUE, so that other restriction settings will not
     * block presentation of a download menu with those always_enabled options
     * still available.  - FM
     */
    if (downloaders != 0) {
	lynx_list_item_type *cur_download;

	cur_download = downloaders;
	while (cur_download != 0) {
	    if (cur_download->always_enabled) {
		override_no_download = TRUE;
		break;
	    }
	    cur_download = cur_download->next;
	}
    }

    /*
     * If any COOKIE_{ACCEPT,REJECT}_DOMAINS have been defined,
     * process them.  These are comma delimited lists of
     * domains. - BJP
     *
     * And for query/strict/loose invalid cookie checking. - BJP
     */
    LYConfigCookies();
}

/* this is a public interface to do_read_cfg */
void read_cfg(const char *cfg_filename,
	      const char *parent_filename,
	      int nesting_level,
	      FILE *fp0)
{
    HTInitProgramPaths(TRUE);
    do_read_cfg(cfg_filename, parent_filename, nesting_level, fp0, NULL);
}

#ifndef NO_CONFIG_INFO
static void extra_cfg_link(FILE *fp, const char *href,
			   const char *name)
{
    fprintf(fp, "<a href=\"%s\">%s</a>",
	    href, name);
}
#endif /* NO_CONFIG_INFO */

/*
 * Show rendered lynx.cfg data without comments, LYNXCFG:/ internal page. 
 * Called from getfile() cycle:  we create and load the page just in place and
 * return to mainloop().
 */
int lynx_cfg_infopage(DocInfo *newdoc)
{
    static char tempfile[LY_MAXPATH] = "\0";
    DocAddress WWWDoc;		/* need on exit */
    char *temp = 0;
    char *cp1 = NULL;
    FILE *fp0;

#ifndef NO_CONFIG_INFO
    /*-------------------------------------------------
     * kludge a link from LYNXCFG:/, the URL was:
     * "  <a href=\"LYNXCFG://reload\">RELOAD THE CHANGES</a>\n"
     *--------------------------------------------------*/

    if (!no_lynxcfg_xinfo && (strstr(newdoc->address, "LYNXCFG://reload"))) {
	/*
	 * Some stuff to reload read_cfg(), but also load options menu items
	 * and command-line options to make things consistent.  Implemented in
	 * LYMain.c
	 */
	reload_read_cfg();

	/*
	 * now pop-up and return to updated LYNXCFG:/ page, remind
	 * postoptions() but much simpler:
	 */
	/*
	 * But check whether the top history document is really the expected
	 * LYNXCFG:  page.  - kw
	 */
	if (HTMainText && nhist > 0 &&
	    !strcmp(HTLoadedDocumentTitle(), LYNXCFG_TITLE) &&
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist - 1).address) &&
	    LYIsUIPage(HDOC(nhist - 1).address, UIP_LYNXCFG) &&
	    (!lynxcfginfo_url ||
	     strcmp(HTLoadedDocumentURL(), lynxcfginfo_url))) {
	    /*  the page was pushed, so pop-up. */
	    LYpop(newdoc);
	    WWWDoc.address = newdoc->address;
	    WWWDoc.post_data = newdoc->post_data;
	    WWWDoc.post_content_type = newdoc->post_content_type;
	    WWWDoc.bookmark = newdoc->bookmark;
	    WWWDoc.isHEAD = newdoc->isHEAD;
	    WWWDoc.safe = newdoc->safe;
	    LYforce_no_cache = FALSE;	/* ! */
	    LYoverride_no_cache = TRUE;		/* ! */

	    /*
	     * Working out of getfile() cycle we reset *no_cache manually here
	     * so HTLoadAbsolute() will return "Document already in memory": 
	     * it was forced reloading obsolete file again without this
	     * (overhead).
	     *
	     * Probably *no_cache was set in a wrong position because of the
	     * internal page...
	     */
	    if (!HTLoadAbsolute(&WWWDoc))
		return (NOT_FOUND);

	    HTuncache_current_document();	/* will never use again */
	    LYUnRegisterUIPage(UIP_LYNXCFG);
	}

	/*  now set up the flag and fall down to create a new LYNXCFG:/ page */
	FREE(lynxcfginfo_url);	/* see below */
    }
#endif /* !NO_CONFIG_INFO */

    /*
     * We regenerate the file if reloading has been requested (with LYK_NOCACHE
     * key).  If we did not regenerate, there would be no way to recover in a
     * session from a situation where the file is corrupted (for example
     * truncated because the file system was full when it was first created -
     * lynx doesn't check for write errors below), short of manual complete
     * removal or perhaps forcing regeneration with LYNXCFG://reload. 
     * Similarly, there would be no simple way to get a different page if
     * user_mode has changed to Advanced after the file was first generated in
     * a non-Advanced mode (the difference being in whether the page includes
     * the link to LYNXCFG://reload or not).
     *
     * We also try to regenerate the file if lynxcfginfo_url is set, indicating
     * that tempfile is valid, but the file has disappeared anyway.  This can
     * happen to a long-lived lynx process if for example some system script
     * periodically cleans up old files in the temp file space.  - kw
     */

    if (LYforce_no_cache && reloading) {
	FREE(lynxcfginfo_url);	/* flag to code below to regenerate - kw */
    } else if (lynxcfginfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(lynxcfginfo_url);	/* flag to code below to try again - kw */
	}
    }
    if (lynxcfginfo_url == 0) {

	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return (NOT_FOUND);

	LYLocalFileToURL(&lynxcfginfo_url, tempfile);

	LYforce_no_cache = TRUE;	/* don't cache this doc */

	BeginInternalPage(fp0, LYNXCFG_TITLE, NULL);
	fprintf(fp0, "<pre>\n");

#ifndef NO_CONFIG_INFO
	if (!no_lynxcfg_xinfo) {
#if defined(HAVE_CONFIG_H) || defined(VMS)
	    if (strcmp(lynx_cfg_file, LYNX_CFG_FILE)) {
		fprintf(fp0, "<em>%s\n%s",
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
		LYLocalFileToURL(&temp, LYNX_CFG_FILE);
		fprintf(fp0, " <a href=\"%s\">lynx.cfg</a> ",
			temp);
		FREE(temp);
		fprintf(fp0, "%s</em>\n\n",
			gettext("for more comments."));
	    } else
#endif /* HAVE_CONFIG_H */
	    {
		/* no absolute path... for lynx.cfg on DOS/Win32 */
		fprintf(fp0, "<em>%s\n%s",
			gettext("The following is read from your lynx.cfg file."),
			gettext("Please read the distribution"));
		fprintf(fp0, " </em>lynx.cfg<em> ");
		fprintf(fp0, "%s</em>\n",
			gettext("for more comments."));
	    }

#ifndef NO_CONFIG_INFO
#if defined(HAVE_CONFIG_H) && defined(USE_COLOR_STYLE)
	    if (!no_compileopts_info && !no_lynxcfg_xinfo) {
		fprintf(fp0, "%s</pre><ul><li>", SEE_ALSO);
		extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);

		fprintf(fp0, "<li>");
		LYLocalFileToURL(&temp, lynx_lss_file);
		extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		fprintf(fp0, "</ul><pre>\n");
	    } else
#endif
	    {
		fprintf(fp0, "%s ", SEE_ALSO);
#if defined(HAVE_CONFIG_H)
		if (!no_compileopts_info) {
		    extra_cfg_link(fp0, STR_LYNXCFLAGS, COMPILE_OPT_SEGMENT);
		}
#endif
#if defined(USE_COLOR_STYLE)
		if (!no_lynxcfg_xinfo) {
		    LYLocalFileToURL(&temp, lynx_lss_file);
		    extra_cfg_link(fp0, temp, COLOR_STYLE_SEGMENT);
		}
#endif
		fprintf(fp0, "\n\n");
	    }
#endif /* NO_CONFIG_INFO */

	    /** a new experimental link ... **/
	    if (user_mode == ADVANCED_MODE)
		fprintf(fp0, "  <a href=\"%s//reload\">%s</a>\n",
			STR_LYNXCFG,
			gettext("RELOAD THE CHANGES"));

	    LYLocalFileToURL(&temp, lynx_cfg_file);
	    StrAllocCopy(cp1, lynx_cfg_file);
	    if (StrChr(lynx_cfg_file, '&') || StrChr(lynx_cfg_file, '<')) {
		LYEntify(&cp1, TRUE);
	    }
	    fprintf(fp0, "\n    #<em>%s <a href=\"%s\">%s</a></em>\n",
		    gettext("Your primary configuration"),
		    temp,
		    cp1);
	    FREE(temp);
	    FREE(cp1);

	} else
#endif /* !NO_CONFIG_INFO */

	    fprintf(fp0, "<em>%s</em>\n\n",
		    gettext("The following is read from your lynx.cfg file."));

	/*
	 * Process the configuration file.
	 */
	read_cfg(lynx_cfg_file, "main program", 1, fp0);

	fprintf(fp0, "</pre>\n");
	EndInternalPage(fp0);
	LYCloseTempFP(fp0);
	LYRegisterUIPage(lynxcfginfo_url, UIP_LYNXCFG);
    }

    /* return to getfile() cycle */
    StrAllocCopy(newdoc->address, lynxcfginfo_url);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;

    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
    return (NORMAL);
}

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
/*
 * Compile-time definitions info, LYNXCOMPILEOPTS:/ internal page, from
 * getfile() cycle.
 */
int lynx_compile_opts(DocInfo *newdoc)
{
    static char tempfile[LY_MAXPATH] = "\0";

#define PutDefs(table, N) fprintf(fp0, "%-35s %s\n", table[N].name, table[N].value)
#include <cfg_defs.h>
    unsigned n;
    DocAddress WWWDoc;		/* need on exit */
    FILE *fp0;

    /* In general, create the page only once - compile-time data will not
     * change...  But we will regenerate the file anyway, in a few situations:
     *
     * (a) configinfo_url has been FREEd - this can happen if free_lynx_cfg()
     * was called as part of a LYNXCFG://reload action.
     *
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did not
     * regenerate, there would be no way to recover in a session from a
     * situation where the file is corrupted (for example truncated because the
     * file system was full when it was first created - lynx doesn't check for
     * write errors below), short of manual complete removal or forcing
     * regeneration with LYNXCFG://reload.
     *
     * (c) configinfo_url is set, indicating that tempfile is valid, but the
     * file has disappeared anyway.  This can happen to a long-lived lynx
     * process if for example some system script periodically cleans up old
     * files in the temp file space.  - kw
     */

    if (LYforce_no_cache && reloading) {
	FREE(configinfo_url);	/* flag to code below to regenerate - kw */
    } else if (configinfo_url != NULL) {
	if (!LYCanReadFile(tempfile)) {		/* check existence */
	    FREE(configinfo_url);	/* flag to code below to try again - kw */
	}
    }
    if (configinfo_url == NULL) {
	if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	    return (NOT_FOUND);

	LYLocalFileToURL(&configinfo_url, tempfile);

	BeginInternalPage(fp0, CONFIG_DEF_TITLE, NULL);
	fprintf(fp0, "<pre>\n");

	fprintf(fp0, "\n%s<br>\n<em>config.cache</em>\n", AUTOCONF_CONFIG_CACHE);
	for (n = 0; n < TABLESIZE(config_cache); n++) {
	    PutDefs(config_cache, n);
	}
	fprintf(fp0, "\n%s<br>\n<em>lynx_cfg.h</em>\n", AUTOCONF_LYNXCFG_H);
	for (n = 0; n < TABLESIZE(config_defines); n++) {
	    PutDefs(config_defines, n);
	}
	fprintf(fp0, "</pre>\n");
	EndInternalPage(fp0);
	LYCloseTempFP(fp0);
	LYRegisterUIPage(configinfo_url, UIP_CONFIG_DEF);
    }

    /* exit to getfile() cycle */
    StrAllocCopy(newdoc->address, configinfo_url);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;

    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);
#ifdef DIRED_SUPPORT
    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
    return (NORMAL);
}
#endif /* !NO_CONFIG_INFO */
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYReadCFG.c,v 1.139 2009/06/07 16:57:29 tom Exp $
d51 1
a51 1
static BOOL is_true(char *string)
d62 1
a62 1
static char *find_colon(char *buffer)
d64 2
a65 1
    char ch, *buf = buffer;
d83 23
d108 2
a109 9
    lynx_list_item_type *cur = *ptr;
    lynx_list_item_type *next;

    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
a110 1
    *ptr = NULL;
d131 60
d197 2
a198 1
			     int special)
d200 1
a200 1
    char *colon, *next_colon, *last_colon;
d208 24
a231 18
    if ((last_colon = strrchr(buffer, ':')) != NULL && *(last_colon - 1) != '\\') {
	*last_colon++ = '\0';
	/*
	 * If last_colon equals XWINDOWS then only continue
	 * if there is a $DISPLAY variable
	 */
	if (!strcasecomp(last_colon, "XWINDOWS")) {
	    if (LYgetXDisplay() == NULL)
		return;
	}
	/*
	 * If last_colon equals NON_XWINDOWS then only continue
	 * if there is no $DISPLAY variable
	 */
	else if (!strcasecomp(last_colon, "NON_XWINDOWS")) {
	    if (LYgetXDisplay() != NULL)
		return;
	}
d245 3
d265 2
d268 1
a268 5
    cur_item->next = NULL;
    cur_item->name = NULL;
    cur_item->command = NULL;
    cur_item->always_enabled = FALSE;
    cur_item->override_primary_action = FALSE;
d274 2
a275 5
    if ((colon = find_colon(buffer)) != NULL) {
	/*
	 * Process name field
	 */
	cur_item->name = typecallocn(char, (unsigned) (colon - buffer + 1));
d277 5
a281 13
	if (cur_item->name == NULL)
	    outofmem(__FILE__, "read_cfg");
	LYstrncpy(cur_item->name, buffer, (int) (colon - buffer));
	remove_backslashes(cur_item->name);

	/*
	 * Find end of command string and beginning of TRUE/FALSE option field. 
	 * If we do not find a colon that ends the command string, leave the
	 * always_enabled option flag as FALSE.  In any case, we want the
	 * command string.
	 */
	if ((next_colon = find_colon(colon + 1)) == NULL) {
	    next_colon = colon + strlen(colon);
d283 8
a290 21
	if (next_colon - (colon + 1) > 0) {
	    cur_item->command = typecallocn(char, (unsigned) (next_colon - colon));

	    if (cur_item->command == NULL)
		outofmem(__FILE__, "read_cfg");
	    LYstrncpy(cur_item->command,
		      colon + 1,
		      (int) (next_colon - (colon + 1)));
	    remove_backslashes(cur_item->command);
	}
	if (*next_colon++) {
	    colon = next_colon;
	    if ((next_colon = strchr(colon, ':')) != 0)
		*next_colon++ = '\0';
	    cur_item->always_enabled = is_true(colon);
	    if (next_colon) {
		if (special) {
		    cur_item->pagelen = atoi(next_colon);
		} else {
		    cur_item->override_primary_action = is_true(next_colon);
		}
d294 9
d316 3
a318 2
int match_item_by_name(lynx_list_item_type *ptr, char *name,
		       BOOLEAN only_overriders)
d323 1
a323 1
	 && (only_overriders ? ptr->override_primary_action : 1));
d391 1
a391 1
int check_color(char *color,
d466 2
a467 4
    char *fg, *bg;
    char *temp = 0;

    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */
d475 1
a475 2
	exit_with_color_syntax(temp);
    *fg++ = '\0';
d477 9
a485 3
    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';
d488 1
a488 1
    if ((check_color(fg, default_fg) == ERR_COLOR) ||
d490 1
a490 1
	exit_with_color_syntax(temp);
d492 1
a492 1
    SLtt_set_color(color, NULL, fg, bg);
d495 1
a495 1
		       check_color(fg, default_fg),
d497 1
a497 1
	exit_with_color_syntax(temp);
d499 1
a499 1
    FREE(temp);
d560 1
d564 4
a567 4
/*    this may be a memory for bogus typo -
    StrAllocCopy(UCAssume_MIMEcharset, value);
    LYLowerCase(UCAssume_MIMEcharset);    */

d590 2
a591 2
	    && (!strnicmp(value, "AutoDetect ", 11)
		|| !strnicmp(value, "AutoDetect-2 ", 13)))
d595 1
a595 1
    } else
d597 1
d616 2
a617 2
    char *fg = buffer, *bg;
    char *temp = 0;
a619 1
	StrAllocCopy(temp, buffer);	/* save a copy, for error messages */
d626 6
a631 2
	    exit_with_color_syntax(temp);
	*bg++ = '\0';
d633 1
a633 1
	default_fg = check_color(fg, default_fg);
d638 2
a639 12
	    exit_with_color_syntax(temp);
#ifdef USE_SLANG
	/*
	 * Sorry - the order of initialization of slang precludes setting the
	 * default colors from the lynx.cfg file, since slang is already
	 * initialized before the file is read, and there is no interface
	 * defined for setting it from the application (that's one of the
	 * problems with using environment variables rather than a programmable
	 * interface) -TD
	 */
#endif
	FREE(temp);
d655 8
d664 1
a664 1
static int default_colors_fun(char *value)
d666 4
a669 1
    LYuse_default_colors = is_true(value);
d671 1
d676 8
a683 6
	if (default_fg == DEFAULT_COLOR ||
	    default_bg == DEFAULT_COLOR) {
	    default_fg = COLOR_WHITE;
	    default_bg = COLOR_BLACK;
	    lynx_setup_colors();
	}
d685 6
d759 1
a759 1
    if ((func = strchr(key, ':')) != NULL) {
d761 1
a761 1
	efunc = strchr(func, ':');
d771 1
a771 1
	    } else if (func && !strcmp("TOGGLE_HELP", func)) {
d779 1
a779 1
	    if (func && !strcmp("TOGGLE_HELP", func))
d794 1
a794 1
			select_edi = strtol(sselect_edi, endp, 10);
d866 1
a866 1
    LYstrncpy(temp, value, sizeof(temp) - 1);
d960 17
d979 2
a980 2
    char *mime_type, *p;
    char *encoding = NULL;
d986 1
a986 1
	|| (NULL == (mime_type = strchr(value, ':')))) {
d993 3
a995 3
	if ((encoding = strchr(mime_type, ':')) != NULL) {
	    *encoding++ = '\0';
	    if ((sq = strchr(encoding, ':')) != NULL) {
d997 1
a997 1
		if ((description = strchr(sq, ':')) != NULL) {
d999 1
a999 1
		    if ((p = strchr(sq, ':')) != NULL)
d1007 4
a1010 4
	    LYRemoveBlanks(encoding);
	    LYLowerCase(encoding);
	    if (!*encoding)
		encoding = NULL;
d1012 1
d1092 1
a1092 1
    HTSetPresentation(mime_type, viewer, 0, 1.0, 3.0, 0.0, 0, mediaCFG)
d1103 1
a1103 1
	|| (NULL == (viewer = strchr(mime_type, ':'))))
d1147 2
a1148 2
#ifdef EXP_CHARSET_CHOICE
static void matched_charset_choice(BOOL display_charset,
d1167 1
a1167 1
				BOOL display_charset)	/*if FALSE, then assumed doc charset */
a1207 1
		CTRACE((tfp, " - OK\n"));
d1209 1
d1228 13
a1240 1
#endif /* EXP_CHARSET_CHOICE */
d1269 1
a1269 1
    ts2 = strchr(value, ':');
d1272 3
d1317 1
a1317 1
    e = strchr(s, ':');
d1389 1
a1389 1
    if ((cp = strchr(value, ',')) != 0) {
d1408 14
d1428 3
d1441 1
a1441 1
#ifdef EXP_CHARSET_CHOICE
d1451 3
d1463 1
a1463 1
     PARSE_SET(RC_CASE_SENSITIVE_ALWAYS_ON, case_sensitive),
d1476 1
a1476 1
     PARSE_STR(RC_COLOR_STYLE,          lynx_lss_file),
d1481 1
d1497 1
a1497 1
     PARSE_TIM(RC_DELAYSECS,            DebugSecs),
d1514 1
a1514 1
#ifdef EXP_CHARSET_CHOICE
d1517 1
d1524 1
d1533 1
d1552 1
d1557 1
d1571 1
a1571 1
#ifdef EXP_JUSTIFY_ELTS
d1580 1
d1584 1
d1593 1
d1616 1
d1618 3
d1665 1
a1665 1
     PARSE_LST(RC_POSITIONABLE_EDITOR,	positionable_editor),
d1681 1
a1681 1
#ifdef EXP_CMD_LOGGING
d1686 1
d1709 1
d1722 1
a1722 1
     PARSE_STR(RC_STARTFILE,            startfile),
d1746 1
d1756 1
d1775 2
d1806 1
a1806 1
		char *eqls = strchr(name, '=');
d1842 1
a1842 1
static Config_Type *lookup_config(char *name)
d1888 3
a1890 1
		    StrAllocCopy(my_filename, cfg_filename);
d1930 2
a1931 2
void LYSetConfigValue(char *name,
		      char *value)
d1933 2
d1937 2
a1938 1
    char *temp = 0;
d1940 1
d1984 5
a1988 4
	if (tbl->type == CONF_ENV)
	    LYLowerCase(name);
	else
	    LYUpperCase(name);
d1990 1
a1990 1
	if (LYGetEnv(name) == 0) {
d1992 1
a1992 1
	    Define_VMSLogical(name, value);
d1994 6
a1999 2
	    if (q->str_value == 0)
		q->str_value = typecalloc(char *);
d2001 2
a2002 2
	    HTSprintf0(q->str_value, "%s=%s", name, value);
	    putenv(*(q->str_value));
d2004 2
d2010 4
a2013 1
	    add_item_to_list(value, q->add_value, (q->add_value == &printers));
d2020 4
a2023 6
	if (q->lst_value != 0) {
	    char *my_value = NULL;

	    StrAllocCopy(my_value, value);
	    HTList_appendObject(*(q->lst_value), my_value);
	}
d2028 1
a2028 1
	add_trusted(value, q->def_value);
d2033 5
a2037 2
	if (StrAllocCopy(temp, value))
	    HTSetProgramPath((ProgramPaths) (q->def_value), temp);
d2041 1
d2044 3
d2060 1
a2060 1
			optidx_set_t * allowed)
a2104 1
	ParseUnionPtr q;
d2120 1
a2120 1
	if ((value = strchr(name, ':')) == 0) {
d2138 1
a2138 1
	if ((cp = strchr(cp, '#')) != 0) {
d2165 1
a2165 1
	q = ParseUnionOf(tbl);
d2210 1
a2210 1
		    if (strchr(value, '&') || strchr(value, '<')) {
d2299 1
a2299 1
		if (strchr(value, '&') || strchr(value, '<')) {
d2351 1
a2351 1
    HTInitProgramPaths();
d2536 1
a2536 1
	    if (strchr(lynx_cfg_file, '&') || strchr(lynx_cfg_file, '<')) {
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d116 2
a117 1
 * Process string buffer fields for DOWNLOADER or UPLOADER menus.
d123 1
a123 1
    char *colon, *next_colon;
d127 25
d194 1
a194 1
	cur_item->name = typecallocn(char, colon - buffer + 1);
d211 1
a211 1
	    cur_item->command = typecallocn(char, next_colon - colon);
d252 1
a252 1
	 && !strncasecomp(ptr->name, name, strlen(ptr->name))
d384 1
a384 1
    fprintf(stderr, "%s\n%s\n", gettext("Offending line:"), error_line);
d457 1
d474 1
d835 4
a838 6
    if (!strncmp(value, "~/", 2)) {
	StrAllocCopy(rulesfile2, Home_Dir());
	StrAllocCat(rulesfile2, value + 1);
    } else {
	StrAllocCopy(rulesfile2, value);
    }
a852 6
static int printer_fun(char *value)
{
    add_item_to_list(value, &printers, TRUE);
    return 0;
}

d864 8
d938 1
a938 1
	if (p == sq && df == 0.0) {
d1071 1
a1071 1
    len = strlen(p);
d1156 3
a1158 2
    CTRACE((tfp, "ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",
	    value, ts2, option_name));
d1251 12
d1317 4
d1396 2
d1399 1
d1440 1
a1440 1
#ifdef EXP_LOCALE_CHARSET
d1495 1
d1511 1
d1523 1
a1523 1
     PARSE_FUN(RC_PRINTER,              printer_fun),
d1525 1
d1548 5
d1565 1
d1567 1
d1574 1
a1574 1
     PARSE_SET(RC_SYSLOG_TEXT,          syslog_txt),
d1618 1
d1653 1
a1653 3
# ifdef HAVE_UNSETENV
		    unsetenv(name);
# else
d1656 2
d1715 1
a1715 1
	if (!strncmp(cfg_filename, "~/", 2)) {
d1761 1
a1761 1
	    (r)[i1]= (a)[i1] || (b)[i1]; \
d1790 1
a1790 1
	    if (1 == sscanf(value, "%f", &ival)) {
d1837 13
a1849 1
	    add_item_to_list(value, q->add_value, FALSE);
a1913 1
#ifdef SH_EX
a1919 1
#endif
a1970 1
#ifdef SH_EX
a1972 1
#endif
d1999 1
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d6 1
a6 1
#include <HTTP.h>  /* 'reloading' flag */
d42 2
a43 2
PUBLIC BOOLEAN have_read_cfg = FALSE;
PUBLIC BOOLEAN LYUseNoviceLineTwo = TRUE;
d46 1
a46 1
 *  Translate a TRUE/FALSE field in a string buffer.
d48 1
a48 2
PRIVATE BOOL is_true ARGS1(
	char *, string)
d50 2
a51 2
    if (!strncasecomp(string,"TRUE",4))
	return(TRUE);
d53 1
a53 1
	return(FALSE);
d57 1
a57 1
 *  Find an unescaped colon in a string buffer.
d59 1
a59 2
PRIVATE char *find_colon ARGS1(
	char *, buffer)
d79 1
a79 2
PRIVATE void free_item_list ARGS1(
    lynx_list_item_type **,	ptr)
d95 1
a95 1
 *  Function for freeing the DOWNLOADER and UPLOADER menus list. - FM
d97 1
a97 1
PRIVATE void free_all_item_lists NOARGS
d113 1
a113 1
 *  Process string buffer fields for DOWNLOADER or UPLOADER menus.
d115 3
a117 4
PRIVATE void add_item_to_list ARGS3(
	char *,			buffer,
	lynx_list_item_type **, list_ptr,
	int,			special)
d123 1
a123 1
     *	Make a linked list
d127 1
a127 1
	 *  First item.
d130 1
d139 1
a139 1
	 *  Find the last item.
d143 1
a143 2
	     prev_item = prev_item->next)
	    ;  /* null body */
d145 1
d159 1
a159 1
     *	Find first unescaped colon and process fields
d163 1
a163 1
	 *  Process name field
d165 2
a166 1
	cur_item->name = typecallocn(char, colon-buffer+1);
d169 1
a169 1
	LYstrncpy(cur_item->name, buffer, (int)(colon-buffer));
d173 4
a176 4
	 *  Find end of command string and beginning of TRUE/FALSE option
	 *  field.  If we do not find a colon that ends the command string,
	 *  leave the always_enabled option flag as FALSE.  In any case,
	 *  we want the command string.
d178 1
a178 1
	if ((next_colon = find_colon(colon+1)) == NULL) {
d181 3
a183 2
	if (next_colon - (colon+1) > 0) {
	    cur_item->command = typecallocn(char,next_colon-colon);
d186 3
a188 1
	    LYstrncpy(cur_item->command, colon+1, (int)(next_colon-(colon+1)));
d207 2
a208 3
PUBLIC lynx_list_item_type *find_item_by_number ARGS2(
	lynx_list_item_type *,	list_ptr,
	char *,			number)
d211 1
d218 2
a219 4
PUBLIC int match_item_by_name ARGS3(
    lynx_list_item_type *,	ptr,
    char *,			name,
    BOOLEAN,			only_overriders)
d223 2
a224 2
	&& !strncasecomp(ptr->name, name, strlen(ptr->name))
	&& (only_overriders ? ptr->override_primary_action : 1));
d240 1
d246 1
a246 1
PRIVATE CONST char *Color_Strings[16] =
d271 1
a271 2
PRIVATE int ColorCode ARGS1(
	int,	color)
d273 9
a281 4
	static int map[] = {
		0,  4,	2,  6, 1,  5,  3,  7,
		8, 12, 10, 14, 9, 13, 11, 15 };
	return map[color];
d290 1
a290 1
 *  Validator for COLOR fields.
d292 2
a293 3
PUBLIC int check_color ARGS2(
	char *, color,
	int,	the_default)
d300 1
a300 1
	if (!default_color_reset)
d302 1
a302 1
#endif	/* USE_DEFAULT_COLORS */
d321 1
a321 2
PUBLIC CONST char *lookup_color ARGS1(
    int,	code)
d324 1
d336 1
a336 1
 *  Exit routine for failed COLOR parsing.
d338 1
a338 2
PRIVATE void exit_with_color_syntax ARGS1(
	char *,		error_line)
d341 2
a342 1
    fprintf (stderr, gettext("\
d349 1
a349 1
	    );
d355 1
a355 1
    fprintf (stderr, "%s\n%s\n", gettext("Offending line:"), error_line);
d362 1
a362 1
 *  Process string buffer fields for COLOR setting.
d364 1
a364 2
PRIVATE void parse_color ARGS1(
	char *, buffer)
d373 2
a374 2
     *	We are expecting a line of the form:
     *	  INTEGER:FOREGROUND:BACKGROUND
d393 2
a394 2
	check_color(fg, default_fg),
	check_color(bg, default_bg)) < 0)
d400 1
a400 1

d415 1
d429 1
a429 1
#define PARSE_NIL        {NULL,0,              UNION_DEF(0), 0}
d432 1
a432 1
    CONF_UNSPECIFIED = 0
d447 6
a452 8
typedef struct
{
   CONST char *name;
   Conf_Types type;
   ParseData;
   Config_Enum *table;
}
Config_Type;
d454 1
a454 2
PRIVATE int assume_charset_fun ARGS1(
	char *,		value)
d458 1
a458 1
			LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d466 1
a466 2
PRIVATE int assume_local_charset_fun ARGS1(
	char *,		value)
d472 1
a472 2
PRIVATE int assume_unrec_charset_fun ARGS1(
	char *,		value)
d478 1
a478 2
PRIVATE int character_set_fun ARGS1(
	char *,		value)
d480 1
a480 1
    int i = UCGetLYhndl_byAnyName(value); /* by MIME or full name */
d485 2
a486 2
	    && (!strnicmp(value,"AutoDetect ",11)
		|| !strnicmp(value,"AutoDetect-2 ",13)))
d490 1
a490 2
    }
    else
d496 1
a496 2
PRIVATE int outgoing_mail_charset_fun ARGS1(
	char *,		value)
d506 1
a506 1
 *  Process string buffer fields for ASSUMED_COLOR setting.
d508 1
a508 2
PRIVATE int assumed_color_fun ARGS1(
	char *, buffer)
d513 2
a514 1
    StrAllocCopy(temp, buffer);	/* save a copy, for error messages */
d516 14
a529 14
    /*
     *	We are expecting a line of the form:
     *	  FOREGROUND:BACKGROUND
     */
    if (NULL == (bg = find_colon(fg)))
	exit_with_color_syntax(temp);
    *bg++ = '\0';

    default_fg = check_color(fg, default_fg);
    default_bg = check_color(bg, default_bg);

    if (default_fg == ERR_COLOR
     || default_bg == ERR_COLOR)
	exit_with_color_syntax(temp);
d531 8
a538 7
    /*
     * Sorry - the order of initialization of slang precludes setting the
     * default colors from the lynx.cfg file, since slang is already
     * initialized before the file is read, and there is no interface defined
     * for setting it from the application (that's one of the problems with
     * using environment variables rather than a programmable interface) -TD
     */
d540 4
a543 1
    FREE(temp);
d549 1
a549 2
PRIVATE int color_fun ARGS1(
	char *,		value)
d551 1
a551 1
    parse_color (value);
d556 21
a576 2
PRIVATE int default_bookmark_file_fun ARGS1(
	char *,		value)
d582 1
a582 2
PRIVATE int default_cache_size_fun ARGS1(
	char *,		value)
d585 2
a586 1
    if (HTCacheSize < 2) HTCacheSize = 2;
d590 1
a590 2
PRIVATE int default_editor_fun ARGS1(
	char *,		value)
d592 2
a593 1
    if (!system_editor) StrAllocCopy(editor, value);
d597 1
a597 2
PRIVATE int numbers_as_arrows_fun ARGS1(
	char *,		value)
d608 1
a608 2
PRIVATE int dired_menu_fun ARGS1(
	char *,		value)
d615 1
a615 2
PRIVATE int jumpfile_fun ARGS1(
	char *,		value)
d619 1
a619 1
    HTSprintf0 (&buffer, "JUMPFILE:%s", value);
d628 1
a628 2
PRIVATE int keyboard_layout_fun ARGS1(
	char *,		key)
d636 1
a636 2
PRIVATE int keymap_fun ARGS1(
	char *,		key)
d672 1
d678 1
a678 2
				gettext(
	"invalid line-editor selection %s for key %s, selecting all\n"),
d684 11
a694 12
		 *  PASS! tries to enter the key into the LYLineEditors
		 *  bindings in a different way from PASS, namely as
		 *  binding that maps to the specific lynx actioncode
		 *  (rather than to LYE_FORM_PASS).  That only works
		 *  for lynx keycodes with modifier bit set, and we
		 *  have no documented/official way to specify this
		 *  in the KEYMAP directive, although it can be made
		 *  to work e.g. by specifying a hex value that has the
		 *  modifier bit set.  But knowledge about the bit
		 *  pattern of modifiers should remain in internal
		 *  matter subject to change...  At any rate, if
		 *  PASS! fails try it the same way as for PASS. - kw
d698 1
a698 1
			lec = LYE_FORM_LAC|lacname_to_lac(func);
d703 1
a703 2
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
d715 1
a715 2
				gettext(
   "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"),
d719 1
a719 2
				gettext(
	   "setting of line-editor binding for key %s (0x%x) for %s failed\n"),
d729 1
a729 2
PRIVATE int localhost_alias_fun ARGS1(
	char *,		value)
d736 1
a736 2
PRIVATE int lynxcgi_environment_fun ARGS1(
	char *,		value)
d743 1
a743 2
PRIVATE int lynx_sig_file_fun ARGS1(
	char *,		value)
d746 2
a747 1
    LYstrncpy(temp, value, sizeof(temp)-1);
d760 1
a760 2
PRIVATE int news_chunk_size_fun ARGS1(
	char *,		value)
d772 1
a772 2
PRIVATE int news_max_chunk_fun ARGS1(
	char *,		value)
d784 1
a784 2
PRIVATE int news_posting_fun ARGS1(
	char *,		value)
d793 1
a793 2
PRIVATE int cern_rulesfile_fun ARGS1(
	char *,		value)
d797 1
d806 2
a807 3
	StrAllocCat(rulesfile2, value+1);
    }
    else {
d817 2
a818 4
	    gettext(
		"Lynx: cannot start, CERN rules file %s is not available\n"
		),
	    (rulesfile2 && *rulesfile2) ? rulesfile2 : gettext("(no name)"));
d824 1
a824 2
PRIVATE int printer_fun ARGS1(
	char *,		value)
d830 1
a830 2
PRIVATE int referer_with_query_fun ARGS1(
	char *,		value)
d841 1
a841 2
PRIVATE int suffix_fun ARGS1(
	char *,		value)
d844 3
a846 1
    char *encoding = NULL, *sq = NULL, *description = NULL;
d849 2
a850 2
    if ((strlen (value) < 3)
    || (NULL == (mime_type = strchr (value, ':')))) {
d880 5
a884 6
     *  Not converted to lowercase on input, to make it possible to
     *  reproduce the equivalent of some of the HTInit.c defaults
     *  that use mixed case, although that is not recomended. - kw
     */ /*LYLowerCase(mime_type);*/

    if (!*mime_type) { /* that's ok now, with an encoding!  */
d886 2
a887 2
	       encoding ? encoding : "what?"));
	mime_type = NULL; /* that's ok now, with an encoding!  */
d906 1
d909 1
a909 1
		   sq, value));
d920 1
a920 2
PRIVATE int suffix_order_fun ARGS1(
	char *,		value)
d947 1
a947 2
PRIVATE int system_editor_fun ARGS1(
	char *,		value)
d954 4
a957 2
PRIVATE int viewer_fun ARGS1(
	char *,		value)
d965 2
a966 2
    if ((strlen (value) < 3)
    || (NULL == (viewer = strchr (mime_type, ':'))))
d976 1
a976 1
	(strlen(viewer) > 1) && *(environment-1) != '\\') {
d983 1
a983 1
	if (!strcasecomp(environment,"XWINDOWS")) {
d985 2
a986 2
		HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
	} else if (!strcasecomp(environment,"NON_XWINDOWS")) {
d988 1
a988 1
		HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
d990 1
a990 1
	    HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
d994 1
a994 1
	HTSetPresentation(mime_type, viewer, 1.0, 3.0, 0.0, 0);
d1000 1
a1000 2
PRIVATE int nonrest_sigwinch_fun ARGS1(
	char *,		value)
d1011 2
a1012 3
PRIVATE void matched_charset_choice ARGS2(
	BOOL,	display_charset,
	int,	i)
d1029 2
a1030 3
PRIVATE int parse_charset_choice ARGS2(
	char *,	p,
	BOOL,	display_charset) /*if FALSE, then assumed doc charset*/
d1035 1
a1035 1
    /*only one charset choice is allowed per line!*/
d1039 1
a1039 1
	(display_charset ? "display charset" : "assumed doc charset"), p));
d1042 1
a1042 1
	CTRACE((tfp," - EMPTY STRING\n"));
d1047 1
a1047 1
	    for (custom_display_charset = TRUE, i = 0 ;i < LYNumCharsets; ++i)
d1052 1
a1052 1
	CTRACE((tfp," - all unhidden\n"));
d1055 1
a1055 1
    if (p[len-1] == '*') {
d1057 1
a1057 1
	for (i = 0 ;i < LYNumCharsets; ++i) {
d1059 1
a1059 1
		(!strncasecomp(p, LYCharSet_UC[i].MIMEname, len)) ) {
d1064 1
a1064 1
	CTRACE((tfp," - %d matches\n", matches));
d1068 2
a1069 2
	    if ((!strcasecomp(p,LYchar_set_names[i])) ||
		(!strcasecomp(p,LYCharSet_UC[i].MIMEname)) ) {
d1071 1
a1071 1
		CTRACE((tfp," - OK\n"));
d1076 1
a1076 1
	CTRACE((tfp," - NOT recognised\n"));
d1081 1
a1081 1
PRIVATE int parse_display_charset_choice ARGS1(char*,p)
d1083 1
a1083 1
    return parse_charset_choice(p,1);
d1086 1
a1086 1
PRIVATE int parse_assumed_doc_charset_choice ARGS1(char*,p)
d1088 1
a1088 1
    return parse_charset_choice(p,0);
d1094 2
a1095 3
PRIVATE void html_src_bad_syntax ARGS2(
	    char*, value,
	    char*, option_name)
d1099 1
a1099 1
    HTSprintf0(&buf,"HTMLSRC_%s", option_name);
d1101 1
a1101 1
    fprintf(stderr,"Bad syntax in TAGSPEC %s:%s\n", buf, value);
d1105 12
a1116 12
PRIVATE int parse_html_src_spec ARGS3(
	    HTlexeme, lexeme_code,
	    char*, value,
	    char*, option_name)
{
   /* Now checking the value for being correct.  Since HTML_dtd is not
    * initialized completely (member tags points to non-initiailized data), we
    * use tags_old.  If the syntax is incorrect, then lynx will exit with error
    * message.
    */
    char* ts2;
    if (isEmpty(value)) return 0; /* silently ignoring*/
d1120 1
a1120 1
    ts2 = strchr(value,':');
d1125 2
a1126 1
    CTRACE((tfp,"ReadCFG - parsing tagspec '%s:%s' for option '%s'\n",value,ts2,option_name));
d1128 2
a1129 3
    if ( html_src_parse_tagspec(value, lexeme_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexeme_code, TRUE, TRUE) )
    {
d1135 1
a1135 1
    StrAllocCopy(HTL_tagspecs[lexeme_code],value);
d1140 1
a1140 1
PRIVATE int psrcspec_fun ARGS1(char*,s)
d1142 2
a1143 1
    char* e;
d1160 2
d1166 3
a1168 1
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",s));
d1173 3
a1175 1
	CTRACE((tfp,"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",s,e+1));
d1178 1
a1178 1
    parse_html_src_spec(found, e+1, s);
d1182 1
a1182 1
PRIVATE int read_htmlsrc_attrname_xform ARGS1( char*,str)
d1185 6
a1190 3
    if ( 1 == sscanf(str, "%d", &val) ) {
	if (val<0 || val >2) {
	    CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", val));
d1194 2
a1195 2
	CTRACE((tfp,"bad value for htmlsrc_attrname_xform (ignored): %s\n",
		    str));
d1200 1
a1200 1
PRIVATE int read_htmlsrc_tagname_xform ARGS1( char*,str)
d1203 6
a1208 3
    if ( 1 == sscanf(str,"%d",&val) ) {
	if (val<0 || val >2) {
	    CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", val));
d1212 2
a1213 2
	CTRACE((tfp,"bad value for htmlsrc_tagname_xform (ignored): %s\n",
		    str));
d1220 1
a1220 2
PRIVATE int screen_size_fun ARGS1(
	char *,		value)
d1225 1
a1225 1
	*cp++ = '\0';       /* Terminate ID */
d1244 2
a1245 1
PRIVATE Config_Type Config_Table [] =
d1286 3
d1303 1
a1303 1
     PARSE_Env(RC_CSO_PROXY,		0),
d1310 3
d1367 1
d1412 3
d1421 3
d1443 1
d1447 1
d1460 1
d1462 1
d1511 4
d1562 3
a1565 1
PRIVATE char *lynxcfginfo_url = NULL;	/* static */
d1567 1
a1567 1
PRIVATE char *configinfo_url = NULL;	/* static */
d1573 1
a1573 1
PUBLIC void free_lynx_cfg NOARGS
d1585 1
d1620 1
a1620 2
PRIVATE Config_Type *lookup_config ARGS1(
	char *,		name)
d1629 1
a1629 1
	    && (0 == strcasecomp (name, tbl->name)))
d1645 3
a1647 4
PRIVATE char *actual_filename ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
d1652 1
a1652 1
     && !(parent_filename == 0 && LYCanReadFile(cfg_filename))) {
d1654 1
a1654 1
	    HTSprintf0(&my_filename, "%s%s", Home_Dir(), cfg_filename+1);
d1658 1
a1658 1
		*LYPathLeaf (my_filename) = '\0';
d1663 1
a1663 1
		*LYPathLeaf (my_filename) = '\0';
d1676 3
a1678 4
PUBLIC FILE *LYOpenCFG ARGS3(
    char *,	cfg_filename,
    char *,	parent_filename,
    char *,	dft_filename)
d1691 3
a1693 2
typedef BOOL (optidx_set_t) [ NOPTS_ ];
 /* if element is FALSE, then it's allowed in the current file*/
d1706 2
a1707 3
PUBLIC void LYSetConfigValue ARGS2(
    char *,	name,
    char *,	value)
d1711 1
a1711 1
    char *temp;
d1716 1
a1716 1
	    *(q->set_value) = is_true (value);
d1727 2
a1728 1
	    if (1 == sscanf (value, "%f", &ival)) {
d1742 2
a1743 1
	    if (1 == sscanf (value, "%d", &ival))
d1761 1
a1761 1
	if (LYGetEnv (name) == 0) {
d1767 3
a1769 2
	    HTSprintf0 (q->str_value, "%s=%s", name, value);
	    putenv (*(q->str_value));
d1775 1
a1775 1
	    add_item_to_list (value, q->add_value, FALSE);
d1780 1
a1780 1
	add_trusted (value, q->def_value);
d1786 1
a1786 1
	    HTSetProgramPath(q->def_value, temp);
d1801 5
a1805 6
PRIVATE void do_read_cfg ARGS5(
	char *, cfg_filename,
	char *, parent_filename,
	int,	nesting_level,
	FILE *,	fp0,
	optidx_set_t*, allowed)
d1813 2
a1814 2
     *	Don't get hung up by an include file loop.  Arbitrary max depth
     *	of 10.	- BL
d1820 3
a1822 3
	fprintf(stderr,gettext("Last attempted include was '%s',\n"), cfg_filename);
	fprintf(stderr,gettext("included from '%s'.\n"), parent_filename);
	exit(EXIT_FAILURE);
d1825 1
a1825 1
     *	Locate and open the file.
d1828 1
a1828 1
	CTRACE((tfp,"No filename following -cfg switch!\n"));
d1838 1
a1838 1
     *	Process each line in the file.
d1843 1
d1864 2
a1865 1
	if (*name == 0) continue;
d1868 1
a1868 1
	if ((value = strchr (name, ':')) == 0) {
d1878 1
a1878 1
	 *  Trim off any trailing comments.
d1880 3
a1882 3
	 *  (Apparently, the original code considers a trailing comment
	 *   valid only if preceded by a space character but is not followed
	 *   by a colon.  -- JED)
d1884 1
a1884 1
	if ((cp = strrchr (value, ':')) == 0)
d1886 1
a1886 1
	if ((cp = strchr (cp, '#')) != 0) {
d1904 1
a1904 1
	if ( allowed && (*allowed)[ tbl-Config_Table ] ) {
d1906 2
a1907 2
		fprintf (stderr, "%s is not allowed in the %s\n",
		    name,cfg_filename);
d1909 2
a1910 2
	    the html representation of lynx.cfg - say include this line
	    in bold, or something...*/
d1917 1
a1917 1
		? CONF_UNSPECIFIED
d1927 1
d1933 10
a1942 10
	case CONF_INCLUDE: {
	    /* include another file */
	    optidx_set_t cur_set, anded_set;
	    optidx_set_t* resultant_set = NULL;
	    char* p1, *p2, savechar;
	    BOOL any_optname_found = FALSE;

	    char *url = NULL;
	    char *cp1 = NULL;
	    char *sep = NULL;
d1944 1
a1944 1
	    if ( (p1 = strstr(value, sep = " for ")) != 0
d1946 1
a1946 1
		|| (p1 = strstr(value, sep = ":")) != 0
d1948 7
a1954 4
	    ) {
		*p1 = '\0';
		p1 += strlen(sep);
	    }
d1956 6
a1961 3
#ifndef NO_CONFIG_INFO
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
		char *my_file = actual_filename(value, cfg_filename, LYNX_CFG_FILE);
d1963 2
a1964 5
		LYLocalFileToURL(&url, my_file);
		FREE(my_file);
		StrAllocCopy(cp1, value);
		if (strchr(value, '&') || strchr(value, '<')) {
		    LYEntify(&cp1, TRUE);
a1965 4

		fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
		fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
	    }
d1968 23
a1990 19
	    if (p1) {
		while (*(p1 = LYSkipBlanks(p1)) != 0) {
		    Config_Type *tbl2;

		    p2 = LYSkipNonBlanks(p1);
		    savechar = *p2;
		    *p2 = 0;

		    tbl2 = lookup_config(p1);
		    if (tbl2->name == 0) {
			if (fp0 == NULL)
			    fprintf (stderr, "unknown option name %s in %s\n",
				     p1, cfg_filename);
		    } else {
			unsigned i;
			if (!any_optname_found) {
			    any_optname_found = TRUE;
			    for (i = 0; i < NOPTS_; ++i)
				cur_set[i] = TRUE;
d1992 4
a1995 1
			cur_set[tbl2 - Config_Table] = FALSE;
d1997 4
a2000 2
		    if (savechar && p2[1])
			p1 = p2 + 1;
d2002 8
a2009 14
			break;
		}
	    }
	    if (!allowed) {
		if (!any_optname_found)
		    resultant_set = NULL;
		else
		    resultant_set = &cur_set;
	    } else {
		if (!any_optname_found)
		    resultant_set = allowed;
		else {
		    optidx_set_AND(anded_set, *allowed, cur_set);
		    resultant_set = &anded_set;
a2010 1
	    }
d2013 19
a2031 17
	    /*
	     * Now list the opts that are allowed in included file.  If all
	     * opts are allowed, then emit nothing, else emit an effective set
	     * of allowed options in <ul>.  Option names will be uppercased.
	     * FIXME:  uppercasing option names can be considered redundant.
	     */
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo && resultant_set) {
		char *buf = NULL;
		unsigned i;

		fprintf(fp0,"     Options allowed in this file:\n");
		for (i = 0; i < NOPTS_; ++i) {
		    if ((*resultant_set)[i])
			continue;
		    StrAllocCopy(buf, Config_Table[i].name);
		    LYUpperCase(buf);
		    fprintf(fp0,"         * %s\n", buf);
a2032 2
		FREE(buf);
	    }
d2034 1
a2034 1
	    do_read_cfg (value, cfg_filename, nesting_level + 1, fp0,resultant_set);
d2037 5
a2041 5
	    if (fp0 != 0  &&  !no_lynxcfg_xinfo) {
		fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
		FREE(url);
		FREE(cp1);
	    }
d2050 1
d2063 1
a2063 1
    LYCloseInput (fp);
d2066 4
a2069 4
     *	If any DOWNLOADER: commands have always_enabled set (:TRUE),
     *	make override_no_download TRUE, so that other restriction
     *	settings will not block presentation of a download menu
     *	with those always_enabled options still available. - FM
d2095 4
a2098 5
PUBLIC void read_cfg ARGS4(
	char *, cfg_filename,
	char *, parent_filename,
	int,	nesting_level,
	FILE *,	fp0)
d2105 2
a2106 4
PRIVATE void extra_cfg_link ARGS3(
	FILE *,	fp,
	char *,	href,
	char *,	name)
d2114 3
a2116 3
 *  Show rendered lynx.cfg data without comments, LYNXCFG:/ internal page.
 *  Called from getfile() cycle:
 *  we create and load the page just in place and return to mainloop().
d2118 1
a2118 2
PUBLIC int lynx_cfg_infopage ARGS1(
    DocInfo *,		       newdoc)
d2121 1
a2121 1
    DocAddress WWWDoc;  /* need on exit */
a2125 1

d2134 3
a2136 3
	 *  Some stuff to reload read_cfg(),
	 *  but also load options menu items and command-line options
	 *  to make things consistent.	Implemented in LYMain.c
d2141 2
a2142 2
	 *  now pop-up and return to updated LYNXCFG:/ page,
	 *  remind postoptions() but much simpler:
d2145 2
a2146 2
	 *  But check whether the top history document is really
	 *  the expected LYNXCFG: page. - kw
d2150 2
a2151 2
	    !strcmp(HTLoadedDocumentURL(), HDOC(nhist-1).address) &&
	    LYIsUIPage(HDOC(nhist-1).address, UIP_LYNXCFG) &&
d2162 2
a2163 2
	    LYforce_no_cache = FALSE;   /* ! */
	    LYoverride_no_cache = TRUE; /* ! */
d2166 4
a2169 3
	     * Working out of getfile() cycle we reset *no_cache manually here so
	     * HTLoadAbsolute() will return "Document already in memory":  it was
	     * forced reloading obsolete file again without this (overhead).
d2171 2
a2172 2
	     * Probably *no_cache was set in a wrong position because of
	     * the internal page...
d2175 1
a2175 1
		return(NOT_FOUND);
d2177 1
a2177 1
	    HTuncache_current_document();  /* will never use again */
d2187 15
a2201 15
     * We regenerate the file if reloading has been requested (with
     * LYK_NOCACHE key).  If we did not regenerate, there would be no
     * way to recover in a session from a situation where the file is
     * corrupted (for example truncated because the file system was full
     * when it was first created - lynx doesn't check for write errors
     * below), short of manual complete removal or perhaps forcing
     * regeneration with LYNXCFG://reload.  Similarly, there would be no
     * simple way to get a different page if user_mode has changed to
     * Advanced after the file was first generated in a non-Advanced mode
     * (the difference being in whether the page includes the link to
     * LYNXCFG://reload or not).
     * We also try to regenerate the file if lynxcfginfo_url is set,
     * indicating that tempfile is valid, but the file has disappeared anyway.
     * This can happen to a long-lived lynx process if for example some system
     * script periodically cleans up old files in the temp file space. - kw
d2205 1
a2205 1
	FREE(lynxcfginfo_url); /* flag to code below to regenerate - kw */
d2207 2
a2208 2
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(lynxcfginfo_url); /* flag to code below to try again - kw */
d2214 1
a2214 1
	    return(NOT_FOUND);
d2218 1
a2218 1
	LYforce_no_cache = TRUE;  /* don't cache this doc */
d2220 1
a2220 1
	BeginInternalPage (fp0, LYNXCFG_TITLE, NULL);
d2228 2
a2229 2
			     gettext("The following is read from your lynx.cfg file."),
			     gettext("Please read the distribution"));
d2232 1
a2232 1
			     temp);
d2235 1
a2235 1
			     gettext("for more comments."));
d2239 1
a2239 1
	    /* no absolute path... for lynx.cfg on DOS/Win32 */
d2241 2
a2242 2
			     gettext("The following is read from your lynx.cfg file."),
			     gettext("Please read the distribution"));
d2245 1
a2245 1
			     gettext("for more comments."));
d2280 2
a2281 3
			     STR_LYNXCFG,
			     gettext("RELOAD THE CHANGES"));

d2289 3
a2291 3
			gettext("Your primary configuration"),
			temp,
			cp1);
d2298 2
a2299 1
	fprintf(fp0, "<em>%s</em>\n\n", gettext("The following is read from your lynx.cfg file."));
d2302 1
a2302 1
	 *  Process the configuration file.
d2322 1
a2322 1
	return(NOT_FOUND);
d2326 1
a2326 1
    return(NORMAL);
a2328 1

d2331 2
a2332 2
 *  Compile-time definitions info, LYNXCOMPILEOPTS:/ internal page,
 *  from getfile() cycle.
d2334 1
a2334 2
PUBLIC int lynx_compile_opts ARGS1(
    DocInfo *,		       newdoc)
d2337 1
d2341 1
a2341 1
    DocAddress WWWDoc;  /* need on exit */
d2345 2
a2346 1
     * change...  But we will regenerate the file anyway, in two situations:
d2349 10
a2358 8
     * (b) reloading has been requested (with LYK_NOCACHE key).  If we did
     * not regenerate, there would be no way to recover in a session from
     * a situation where the file is corrupted (for example truncated because
     * the file system was full when it was first created - lynx doesn't
     * check for write errors below), short of manual complete removal or
     * forcing regeneration with LYNXCFG://reload.
     * (c) configinfo_url is set, indicating that tempfile is valid, but
     * the file has disappeared anyway.  This can happen to a long-lived lynx
d2360 1
a2360 1
     * files in the temp file space. - kw
d2364 1
a2364 1
	FREE(configinfo_url); /* flag to code below to regenerate - kw */
d2366 2
a2367 2
	if (!LYCanReadFile(tempfile)) { /* check existence */
	    FREE(configinfo_url); /* flag to code below to try again - kw */
d2372 1
a2372 1
	    return(NOT_FOUND);
d2376 1
a2376 1
	BeginInternalPage (fp0, CONFIG_DEF_TITLE, NULL);
d2403 1
a2403 1
	return(NOT_FOUND);
d2407 1
a2407 1
    return(NORMAL);
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d39 1
a39 2
extern int HTNewsMaxChunk;  /* Max news articles before chunking (HTNews.c) */
extern int HTNewsChunkSize; /* Number of news articles per chunk (HTNews.c) */
d192 1
a192 1
	    if ((next_colon = strchr(colon,':')) != 0)
d238 1
a238 1
#if USE_DEFAULT_COLORS
d296 1
a296 1
#if USE_DEFAULT_COLORS
d330 1
a330 1
#if defined(USE_COLOR_TABLE)
d355 1
d357 1
d399 1
a399 1
#ifdef SOURCE_CACHE
d420 1
d436 1
a452 25
PRIVATE BOOLEAN LYgetEnum ARGS3(
    Config_Enum *,	table,
    CONST char *,	name,
    int *,		result)
{
    Config_Enum *found = 0;
    unsigned len = strlen(name);

    if (len != 0) {
	while (table->name != 0) {
	    if (!strncasecomp(table->name, name, len)) {
		if (found != 0)
		    return FALSE; /* ambiguous, don't use this */
		found = table;
	    }
	    table++;
	}
	if (found != 0) {
	    *result = found->value;
	    return TRUE;
	}
    }
    return FALSE;		/* no match */
}

d535 1
a535 1
#if USE_SLANG
d1121 1
a1121 1
    if ( !value || !*value) return 0; /* silently ignoring*/
d1166 1
a1166 1
    e = strchr(s,':');
d1211 25
d1238 4
a1241 4
{ 
     PARSE_SET("accept_all_cookies",   LYAcceptAllCookies),
     PARSE_TIM("alertsecs",            AlertSecs),
     PARSE_SET("always_resubmit_posts", LYresubmit_posts),
d1243 1
a1243 1
     PARSE_DEF("always_trusted_exec",  ALWAYS_EXEC_PATH),
d1245 3
a1247 3
     PARSE_FUN("assume_charset",       assume_charset_fun),
     PARSE_FUN("assume_local_charset", assume_local_charset_fun),
     PARSE_FUN("assume_unrec_charset", assume_unrec_charset_fun),
d1249 1
a1249 1
     PARSE_FUN("assumed_color",        assumed_color_fun),
d1252 1
a1252 1
     PARSE_FUN("assumed_doc_charset_choice", parse_assumed_doc_charset_choice),
d1255 1
a1255 1
     PARSE_INT("auto_uncache_dirlists", LYAutoUncacheDirLists),
d1258 2
a1259 2
     PARSE_STR("bibp_bibhost",         BibP_bibhost),
     PARSE_STR("bibp_globalserver",    BibP_globalserver),
d1261 7
a1267 6
     PARSE_SET("block_multi_bookmarks", LYMBMBlocked),
     PARSE_SET("bold_h1",              bold_H1),
     PARSE_SET("bold_headers",         bold_headers),
     PARSE_SET("bold_name_anchors",    bold_name_anchors),
     PARSE_SET("case_sensitive_always_on", case_sensitive),
     PARSE_FUN("character_set",        character_set_fun),
d1269 2
a1270 2
     PARSE_STR("charset_switch_rules", charset_switch_rules),
     PARSE_STR("charsets_directory",   charsets_directory),
d1272 3
a1274 2
     PARSE_SET("checkmail",            check_mail),
     PARSE_SET("collapse_br_tags",     LYCollapseBRs),
d1276 1
a1276 4
     PARSE_FUN("color",                color_fun),
#endif
#ifndef __DJGPP__
     PARSE_INT("connect_timeout",      connect_timeout),
d1278 15
a1292 12
     PARSE_STR("cookie_accept_domains", LYCookieSAcceptDomains),
#ifdef EXP_PERSISTENT_COOKIES
     PARSE_STR("cookie_file",          LYCookieFile),
#endif /* EXP_PERSISTENT_COOKIES */
     PARSE_STR("cookie_loose_invalid_domains", LYCookieSLooseCheckDomains),
     PARSE_STR("cookie_query_invalid_domains", LYCookieSQueryCheckDomains),
     PARSE_STR("cookie_reject_domains", LYCookieSRejectDomains),
#ifdef EXP_PERSISTENT_COOKIES
     PARSE_STR("cookie_save_file",     LYCookieSaveFile),
#endif /* EXP_PERSISTENT_COOKIES */
     PARSE_STR("cookie_strict_invalid_domains", LYCookieSStrictCheckDomains),
     PARSE_Env("cso_proxy", 0 ),
d1294 1
a1294 1
     PARSE_STR("cswing_path",          LYCSwingPath),
d1296 8
a1303 7
     PARSE_FUN("default_bookmark_file", default_bookmark_file_fun),
     PARSE_FUN("default_cache_size",   default_cache_size_fun),
     PARSE_FUN("default_editor",       default_editor_fun),
     PARSE_STR("default_index_file",   indexfile),
     PARSE_ENU("default_keypad_mode",  keypad_mode, tbl_keypad_mode),
     PARSE_FUN("default_keypad_mode_is_numbers_as_arrows", numbers_as_arrows_fun),
     PARSE_ENU("default_user_mode",    user_mode, tbl_user_mode),
d1305 1
a1305 1
     PARSE_INT("default_virtual_memory_size", HTVirtualMemorySize),
d1308 1
a1308 1
     PARSE_FUN("dired_menu",           dired_menu_fun),
d1311 1
a1311 1
     PARSE_FUN("display_charset_choice", parse_display_charset_choice),
d1313 4
a1316 4
     PARSE_ADD("downloader",           downloaders),
     PARSE_SET("emacs_keys_always_on", emacs_keys),
     PARSE_FUN("enable_lynxrc",        enable_lynxrc),
     PARSE_SET("enable_scrollback",    enable_scrollback),
d1318 1
a1318 1
     PARSE_ADD("external",             externals),
d1320 1
a1320 1
     PARSE_Env("finger_proxy",         0 ),
d1322 8
a1329 1
     PARSE_SET("focus_window",         focus_window),
a1330 3
     PARSE_SET("force_8bit_toupper",   UCForce8bitTOUPPER),
     PARSE_SET("force_empty_hrefless_a", force_empty_hrefless_a),
     PARSE_SET("force_ssl_cookies_secure", LYForceSSLCookiesSecure),
d1332 1
a1332 1
     PARSE_SET("forms_options",        LYUseFormsOptions),
d1334 8
a1341 7
     PARSE_SET("ftp_passive",          ftp_passive),
     PARSE_Env("ftp_proxy",            0 ),
     PARSE_STR("global_extension_map", global_extension_map),
     PARSE_STR("global_mailcap",       global_type_map),
     PARSE_Env("gopher_proxy",         0 ),
     PARSE_SET("gotobuffer",           goto_buffer),
     PARSE_STR("helpfile",             helpfile),
d1343 1
a1343 1
     PARSE_STR("hidden_link_marker",   hidden_link_marker),
d1345 1
a1345 1
     PARSE_SET("historical_comments",  historical_comments),
d1347 2
a1348 2
     PARSE_FUN("htmlsrc_attrname_xform", read_htmlsrc_attrname_xform),
     PARSE_FUN("htmlsrc_tagname_xform", read_htmlsrc_tagname_xform),
d1350 8
a1357 7
     PARSE_Env("http_proxy",           0 ),
     PARSE_Env("https_proxy",          0 ),
     PARSE_REQ("include",              0),
     PARSE_TIM("infosecs",             InfoSecs),
     PARSE_STR("jump_prompt",          jumpprompt),
     PARSE_SET("jumpbuffer",           jump_buffer),
     PARSE_FUN("jumpfile",             jumpfile_fun),
d1359 2
a1360 2
     PARSE_SET("justify",              ok_justify),
     PARSE_INT("justify_max_void_percent", justify_max_void_percent),
d1363 1
a1363 1
     PARSE_FUN("keyboard_layout",      keyboard_layout_fun),
d1365 2
a1366 2
     PARSE_FUN("keymap",               keymap_fun),
     PARSE_SET("leftarrow_in_textfield_prompt", textfield_prompt_at_left_edge),
d1368 1
a1368 1
     PARSE_STR("list_format",          list_format),
d1371 2
a1372 2
     PARSE_SET("list_news_dates",      LYListNewsDates),
     PARSE_SET("list_news_numbers",    LYListNewsNumbers),
d1374 5
a1378 1
     PARSE_STR("local_domain",         LYLocalDomain),
d1380 2
a1381 2
     PARSE_SET("local_execution_links_always_on", local_exec),
     PARSE_SET("local_execution_links_on_but_not_remote", local_exec_on_local_files),
d1383 2
a1384 3
     PARSE_FUN("localhost_alias",      localhost_alias_fun),
     PARSE_STR("lynx_host_name",       LYHostName),
     PARSE_FUN("lynx_sig_file",        lynx_sig_file_fun),
d1387 1
a1387 1
     PARSE_STR("lynxcgi_document_root", LYCgiDocumentRoot),
d1389 1
a1389 1
     PARSE_FUN("lynxcgi_environment",  lynxcgi_environment_fun),
d1392 1
a1392 1
     PARSE_STR("mail_adrs",            mail_adrs),
d1394 9
a1402 7
     PARSE_SET("mail_system_error_logging", error_logging),
     PARSE_SET("make_links_for_all_images", clickable_images),
     PARSE_SET("make_pseudo_alts_for_inlines", pseudo_inline_alts),
     PARSE_TIM("messagesecs",          MessageSecs),
     PARSE_SET("minimal_comments",     minimal_comments),
     PARSE_ENU("multi_bookmark_support", LYMultiBookmarks, tbl_multi_bookmarks),
     PARSE_SET("ncr_in_bookmarks",     UCSaveBookmarksInUnicode),
d1404 13
a1416 11
     PARSE_FUN("news_chunk_size",      news_chunk_size_fun),
     PARSE_FUN("news_max_chunk",       news_max_chunk_fun),
     PARSE_FUN("news_posting",         news_posting_fun),
     PARSE_Env("news_proxy",           0),
     PARSE_Env("newspost_proxy",       0),
     PARSE_Env("newsreply_proxy",      0),
     PARSE_Env("nntp_proxy",           0),
     PARSE_ENV("nntpserver",           0), /* actually NNTPSERVER */
#endif
     PARSE_SET("no_dot_files",         no_dotfiles),
     PARSE_SET("no_file_referer",      no_filereferer),
d1418 1
a1418 1
     PARSE_SET("no_forced_core_dump",  LYNoCore),
d1420 7
a1426 9
     PARSE_SET("no_from_header",       LYNoFromHeader),
     PARSE_SET("no_ismap_if_usemap",   LYNoISMAPifUSEMAP),
     PARSE_Env("no_proxy",             0 ),
     PARSE_SET("no_referer_header",    LYNoRefererHeader),
#ifdef SH_EX
     PARSE_SET("no_table_center",      no_table_center),
#endif
     PARSE_FUN("nonrestarting_sigwinch", nonrest_sigwinch_fun),
     PARSE_FUN("outgoing_mail_charset", outgoing_mail_charset_fun),
d1428 2
a1429 2
     PARSE_SET("partial",              display_partial_flag),
     PARSE_INT("partial_thres",        partial_threshold),
d1431 9
a1439 9
#ifdef EXP_PERSISTENT_COOKIES
     PARSE_SET("persistent_cookies",   persistent_cookies),
#endif /* EXP_PERSISTENT_COOKIES */
     PARSE_STR("personal_extension_map", personal_extension_map),
     PARSE_STR("personal_mailcap",     personal_type_map),
     PARSE_STR("preferred_charset",    pref_charset),
     PARSE_STR("preferred_language",   language),
     PARSE_SET("prepend_base_to_source", LYPrependBaseToSource),
     PARSE_SET("prepend_charset_to_source", LYPrependCharsetToSource),
d1441 13
a1453 8
     PARSE_SET("prettysrc",            LYpsrc),
     PARSE_FUN("prettysrc_spec",       psrcspec_fun),
     PARSE_SET("prettysrc_view_no_anchor_numbering", psrcview_no_anchor_numbering),
#endif
     PARSE_FUN("printer",              printer_fun),
     PARSE_SET("quit_default_yes",     LYQuitDefaultYes),
     PARSE_FUN("referer_with_query",   referer_with_query_fun),
     PARSE_SET("reuse_tempfiles",      LYReuseTempfiles),
d1455 2
a1456 2
     PARSE_FUN("rule",                 HTSetConfiguration),
     PARSE_FUN("rulesfile",            cern_rulesfile_fun),
d1458 5
a1462 2
     PARSE_STR("save_space",           lynx_save_space),
     PARSE_SET("scan_for_buried_news_refs", scan_for_buried_news_references),
d1464 2
a1465 2
     PARSE_SET("scrollbar",            LYsb),
     PARSE_SET("scrollbar_arrow",      LYsb_arrow),
d1467 25
a1491 22
     PARSE_SET("seek_frag_area_in_cur", LYSeekFragAREAinCur),
     PARSE_SET("seek_frag_map_in_cur", LYSeekFragMAPinCur),
     PARSE_SET("set_cookies",          LYSetCookies),
     PARSE_SET("show_cursor",          LYShowCursor),
     PARSE_ENU("show_kb_rate",         LYTransferRate, tbl_transfer_rate),
     PARSE_Env("snews_proxy",          0 ),
     PARSE_Env("snewspost_proxy",      0 ),
     PARSE_Env("snewsreply_proxy",     0 ),
     PARSE_SET("soft_dquotes",         soft_dquotes),
#ifdef SOURCE_CACHE
     PARSE_ENU("source_cache",         LYCacheSource, tbl_source_cache),
     PARSE_ENU("source_cache_for_aborted", LYCacheSourceForAborted, tbl_abort_source_cache),
#endif
     PARSE_STR("startfile",            startfile),
     PARSE_SET("strip_dotdot_urls",    LYStripDotDotURLs),
     PARSE_SET("substitute_underscores", use_underscore),
     PARSE_FUN("suffix",               suffix_fun),
     PARSE_FUN("suffix_order",         suffix_order_fun),
     PARSE_FUN("system_editor",        system_editor_fun),
     PARSE_STR("system_mail",          system_mail),
     PARSE_STR("system_mail_flags",    system_mail_flags),
     PARSE_ENU("tagsoup",              Old_DTD, tbl_DTD_recovery),
d1493 1
a1493 1
     PARSE_SET("textfields_need_activation", textfields_activation_option),
d1495 1
d1497 1
a1497 1
     PARSE_INT("timeout",              lynx_timeout),
d1499 2
a1500 1
     PARSE_SET("trim_input_fields",  LYtrimInputFields),
d1502 1
a1502 1
     PARSE_DEF("trusted_exec",         EXEC_PATH),
d1505 1
a1505 1
     PARSE_DEF("trusted_lynxcgi",      CGI_PATH),
d1507 3
d1511 1
a1511 1
     PARSE_ADD("uploader",             uploaders),
d1513 2
a1514 2
     PARSE_STR("url_domain_prefixes",  URLDomainPrefixes),
     PARSE_STR("url_domain_suffixes",  URLDomainSuffixes),
d1516 1
a1516 1
     PARSE_SET("use_fixed_records",    UseFixedRecords),
d1519 1
a1519 1
     PARSE_SET("use_mouse",            LYUseMouse),
d1521 9
a1529 6
     PARSE_SET("use_select_popups",    LYSelectPopups),
     PARSE_SET("verbose_images",       verbose_img),
     PARSE_SET("vi_keys_always_on",    vi_keys),
     PARSE_FUN("viewer",               viewer_fun),
     PARSE_Env("wais_proxy",           0 ),
     PARSE_STR("xloadimage_command",   XLoadImageCommand),
d1619 1
a1619 1
    static char *my_filename;
a1620 3
    if (my_filename != 0) {
	FREE(my_filename);
    }
a1624 1
	    cfg_filename = my_filename;
d1631 1
a1631 3
	    if (my_filename != 0 && LYCanReadFile(my_filename)) {
		cfg_filename = my_filename;
	    } else {
d1635 2
a1636 2
		if (LYCanReadFile(my_filename)) {
		    cfg_filename = my_filename;
d1640 2
d1643 1
a1643 1
    return cfg_filename;
d1651 8
a1658 3
    cfg_filename = actual_filename(cfg_filename, parent_filename, dft_filename);
    CTRACE((tfp, "opening config file %s\n", cfg_filename));
    return fopen(cfg_filename, TXT_R);
d1672 89
d1837 1
d1859 1
d1863 1
a1886 4
	    if (q->set_value != 0)
		*(q->set_value) = is_true (value);
	    break;

a1887 4
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

a1888 11
	    if (q->int_value != 0) {
		float ival;
		if (1 == sscanf (value, "%f", &ival)) {
#ifdef HAVE_NAPMS
		    ival *= 1000;
#endif
		    *(q->int_value) = (int) ival;
		}
	    }
	    break;

a1889 4
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

a1890 7
	    if (q->int_value != 0) {
		int ival;
		if (1 == sscanf (value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;

a1891 4
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

d1894 3
a1896 16

	    if (tbl->type == CONF_ENV)
		LYLowerCase(name);
	    else
		LYUpperCase(name);

	    if (getenv (name) == 0) {
#ifdef VMS
		Define_VMSLogical(name, value);
#else
		if (q->str_value == 0)
			q->str_value = typecalloc(char *);
		HTSprintf0 (q->str_value, "%s=%s", name, value);
		putenv (*(q->str_value));
#endif
	    }
d1910 3
a1912 3
	    if ( (p1 = strstr(value, sep=" for ")) != 0
#if defined(UNIX) && !defined(__EMX__)
		|| (p1 = strstr(value, sep=":")) != 0
d1921 4
a1924 1
		LYLocalFileToURL(&url, actual_filename(value, cfg_filename, LYNX_CFG_FILE));
a2010 10
	case CONF_ADD_ITEM:
	    if (q->add_value != 0)
		add_item_to_list (value, q->add_value, FALSE);
	    break;

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)
	case CONF_ADD_TRUSTED:
	    add_trusted (value, q->def_value);
	    break;
#endif
d2065 1
d2069 10
d2086 1
a2086 1
    document *,		       newdoc)
d2119 2
a2120 2
	    !strcmp(HTLoadedDocumentURL(), history[nhist-1].address) &&
	    LYIsUIPage(history[nhist-1].address, UIP_LYNXCFG) &&
d2181 1
a2181 9
	if (LYReuseTempfiles) {
	    fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
	} else {
	    if (tempfile[0])
		LYRemoveTemp(tempfile);
	    fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
	}
	if (fp0 == NULL) {
	    HTAlert(CANNOT_OPEN_TEMP);
d2183 1
a2183 1
	}
a2190 1

d2216 26
a2241 5
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	    if (!no_compileopts_info) {
		fprintf(fp0, "%s <a href=\"LYNXCOMPILEOPTS:\">%s</a>\n\n",
			SEE_ALSO,
			COMPILE_OPT_SEGMENT);
d2243 1
a2243 1
#endif
d2247 2
a2248 1
		fprintf(fp0, "  <a href=\"LYNXCFG://reload\">%s</a>\n",
d2304 1
a2304 1
    document *,		       newdoc)
d2337 1
a2337 8
	if (LYReuseTempfiles) {
	    fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
	} else {
	    LYRemoveTemp(tempfile);
	    fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
	}
	if (fp0 == NULL) {
	    HTAlert(CANNOT_OPEN_TEMP);
d2339 1
a2339 1
	}
@


1.3
log
@Passive ftp support from newer lynx sources. To enable it, see
FTP_PASSIVE in lynx.cfg.
@
text
@d6 1
d8 1
d29 1
d49 1
a49 1
PRIVATE int is_true ARGS1(
d82 2
a83 4
/*
 *  Function for freeing the DOWNLOADER and UPLOADER menus list. - FM
 */
PRIVATE void free_item_list NOARGS
d85 2
a86 2
    lynx_html_item_type *cur;
    lynx_html_item_type *next;
a87 1
    cur = downloaders;
d95 2
a96 1
    downloaders = NULL;
d98 7
d106 1
a106 9
    cur = uploaders;
    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    uploaders = NULL;
d110 1
a110 9
    cur = externals;
    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    externals = NULL;
d119 1
a119 1
PRIVATE void add_item_to_list ARGS2(
d121 2
a122 1
	lynx_html_item_type **, list_ptr)
d125 1
a125 1
    lynx_html_item_type *cur_item, *prev_item;
d134 1
a134 1
	cur_item = (lynx_html_item_type *)calloc(sizeof(lynx_html_item_type),1);
d139 1
a139 1
	atexit(free_item_list);
d149 1
a149 1
	cur_item = (lynx_html_item_type *)calloc(sizeof(lynx_html_item_type),1);
d159 2
d169 1
a169 1
	cur_item->name = (char *)calloc((colon-buffer+1),sizeof(char));
d176 4
a179 2
	 *  Process TRUE/FALSE field.  If we do not find one, assume it is
	 *  true.  In any case, we want the command string.
d185 1
a185 1
	    cur_item->command = (char *)calloc(next_colon-colon, sizeof(char));
a189 1
	    cur_item->always_enabled = TRUE;
d192 11
a202 1
	    cur_item->always_enabled = is_true(next_colon);
d207 20
a226 19

/*
 *  Function for freeing the PRINTER menus list. - FM
 */
PRIVATE void free_printer_item_list NOARGS
{
    lynx_printer_item_type *cur = printers;
    lynx_printer_item_type *next;

    while (cur) {
	next = cur->next;
	FREE(cur->name);
	FREE(cur->command);
	FREE(cur);
	cur = next;
    }
    printers = NULL;

    return;
d229 1
a229 9
/*
 *  Process string buffer fields for PRINTER menus.
 */
PRIVATE void add_printer_to_list ARGS2(
	char *,				buffer,
	lynx_printer_item_type **,	list_ptr)
{
    char *colon, *next_colon;
    lynx_printer_item_type *cur_item, *prev_item;
d231 2
a232 13
    /*
     *	Make a linked list.
     */
    if (*list_ptr == NULL) {
	/*
	 *  First item.
	 */
	cur_item = (lynx_printer_item_type *)calloc(sizeof(lynx_printer_item_type),1);
	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	*list_ptr = cur_item;
#ifdef LY_FIND_LEAKS
	atexit(free_printer_item_list);
a233 57
    } else {
	/*
	 *  Find the last item.
	 */
	for (prev_item = *list_ptr;
	     prev_item->next != NULL;
	     prev_item = prev_item->next)
	    ;  /* null body */

	cur_item = (lynx_printer_item_type *)calloc(sizeof(lynx_printer_item_type),1);
	if (cur_item == NULL)
	    outofmem(__FILE__, "read_cfg");
	else
	    prev_item->next = cur_item;
    }
    cur_item->next = NULL;
    cur_item->name = NULL;
    cur_item->command = NULL;
    cur_item->always_enabled = FALSE;

    /*
     *	Find first unescaped colon and process fields.
     */
    if ((colon = find_colon(buffer)) != NULL) {
	/*
	 *  Process name field.
	 */
	cur_item->name = (char *)calloc((colon-buffer+1), sizeof(char));
	if (cur_item->name == NULL)
	    outofmem(__FILE__, "read_cfg");
	LYstrncpy(cur_item->name, buffer, (int)(colon-buffer));
	remove_backslashes(cur_item->name);

	/*
	 *  Process TRUE/FALSE field.
	 */
	if ((next_colon = find_colon(colon+1)) != NULL) {
	    cur_item->command = (char *)calloc(next_colon-colon, sizeof(char));
	    if (cur_item->command == NULL)
		outofmem(__FILE__, "read_cfg");
	    LYstrncpy(cur_item->command, colon+1, (int)(next_colon-(colon+1)));
	    remove_backslashes(cur_item->command);
	    cur_item->always_enabled = is_true(next_colon+1);
	}

	/*
	 *  Process pagelen field.
	 */
	if (next_colon != NULL
	 && (next_colon = find_colon(next_colon+1)) != NULL) {
	    cur_item->pagelen = atoi(next_colon+1);
	} else {
	    /* default to 66 lines */
	    cur_item->pagelen = 66;
	}
    }
}
d235 1
a235 4
#if defined(USE_COLOR_STYLE) || defined(USE_COLOR_TABLE)

#ifdef USE_SLANG
#define COLOR_WHITE 7
d239 4
d245 1
d247 1
a247 1
static CONST char *Color_Strings[16] =
d267 1
a267 1
#ifdef DOSPATH
d284 2
d295 7
a301 1
    if (!strcasecomp(color, "default"))
d303 1
d308 6
a313 2
	if (!strcasecomp(color, Color_Strings[i]))
	    return ColorCode(i);
d315 1
d318 11
d354 1
a354 1
    exit_immediately(-1);
d383 2
a384 2
    if ((check_color(fg, default_fg) < 0) ||
	(check_color(bg, default_bg) < 0))
d398 7
a404 1
typedef int (*ParseFunc) PARAMS((char *));
d406 5
a410 33
typedef union {
	lynx_html_item_type ** add_value;
	BOOLEAN * set_value;
	int *	  int_value;
	char **   str_value;
	ParseFunc fun_value;
	long	  def_value;
} ConfigUnion;

#ifdef	PARSE_DEBUG
#define ParseData \
	lynx_html_item_type** add_value; \
	BOOLEAN *set_value; \
	int *int_value; \
	char **str_value; \
	ParseFunc fun_value; \
	long def_value
#define PARSE_ADD(n,t,v) {n,t,	 &v,  0,  0,  0,  0,  0}
#define PARSE_SET(n,t,v) {n,t,	  0,  v,  0,  0,  0,  0}
#define PARSE_INT(n,t,v) {n,t,	  0,  0,  v,  0,  0,  0}
#define PARSE_STR(n,t,v) {n,t,	  0,  0,  0,  v,  0,  0}
#define PARSE_ENV(n,t,v) {n,t,	  0,  0,  0,  v,  0,  0}
#define PARSE_FUN(n,t,v) {n,t,	  0,  0,  0,  0,  v,  0}
#define PARSE_DEF(n,t,v) {n,t,	  0,  0,  0,  0,  0,  v}
#else
#define ParseData long value
#define PARSE_ADD(n,t,v) {n,t,	 (long)&(v)}
#define PARSE_SET(n,t,v) {n,t,	 (long) (v)}
#define PARSE_INT(n,t,v) {n,t,	 (long) (v)}
#define PARSE_STR(n,t,v) {n,t,	 (long) (v)}
#define PARSE_ENV(n,t,v) {n,t,	 (long) (v)}
#define PARSE_FUN(n,t,v) {n,t,	 (long) (v)}
#define PARSE_DEF(n,t,v) {n,t,	 (long) (v)}
d413 28
d444 1
a444 12
   int type;
#define CONF_UNSPECIFIED	0
#define CONF_BOOL		1      /* BOOLEAN type */
#define CONF_FUN		2
#define CONF_INT		3
#define CONF_STR		4
#define CONF_ENV		5      /* from environment variable */
#define CONF_ENV2		6      /* from environment VARIABLE */
#define CONF_INCLUDE		7      /* include file-- handle special */
#define CONF_ADD_ITEM		8
#define CONF_ADD_TRUSTED	9

d446 1
d450 26
a475 1
static int assume_charset_fun ARGS1(
d488 1
a488 1
static int assume_local_charset_fun ARGS1(
d495 1
a495 1
static int assume_unrec_charset_fun ARGS1(
d502 1
a502 1
static int character_set_fun ARGS1(
d506 10
a515 2
    if (i < 0)
	; /* do nothing here: so fallback to userdefs.h */
d522 1
a522 1
static int outgoing_mail_charset_fun ARGS1(
d531 39
d572 1
a572 1
static int color_fun ARGS1(
d580 1
a580 1
static int default_bookmark_file_fun ARGS1(
d583 1
a583 4
    StrAllocCopy(bookmark_page, value);
    StrAllocCopy(BookmarkPage, bookmark_page);
    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
    StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
d587 1
a587 1
static int default_cache_size_fun ARGS1(
d595 1
a595 1
static int default_editor_fun ARGS1(
d602 1
a602 1
static int numbers_as_arrows_fun ARGS1(
a612 13
static int default_user_mode_fun ARGS1(
	char *,		value)
{
    if (!strncasecomp(value, "NOVICE", 6))
	user_mode = NOVICE_MODE;
    else if (!strncasecomp(value, "INTER", 5))
	user_mode = INTERMEDIATE_MODE;
    else if (!strncasecomp(value, "ADVANCE", 7))
	user_mode = ADVANCED_MODE;

   return 0;
}

d614 1
a614 1
static int dired_menu_fun ARGS1(
d622 1
a622 1
static int jumpfile_fun ARGS1(
d629 1
a629 1
	CTRACE(tfp, "Failed to register %s\n", buffer);
d636 1
a636 1
static int keyboard_layout_fun ARGS1(
d640 1
a640 1
	CTRACE(tfp, "Failed to set keyboard layout %s\n", key);
d645 1
a645 1
static int keymap_fun ARGS1(
d648 1
a648 1
    char *func;
d650 1
a650 1
    if ((func = strchr(key, ':')) != NULL)	{
d652 1
d654 85
a738 7
	if (!remap(key, strtok(func, " \t\n#")))
	    fprintf(stderr, "%s%s%s%s%s\n",
		    gettext("key remapping of "),
		    key, TO_SEGMENT, func,
		    gettext(" failed"));
	else if (!strcmp("TOGGLE_HELP", strtok(func, " \t\n#")))
	    LYUseNoviceLineTwo = FALSE;
d743 1
a743 1
static int localhost_alias_fun ARGS1(
d751 1
a751 1
static int lynxcgi_environment_fun ARGS1(
d759 1
a759 1
static int lynx_sig_file_fun ARGS1(
d768 1
a768 1
	CTRACE(tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile);
d770 1
a770 1
	CTRACE(tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE);
d776 1
a776 1
static int news_chunk_size_fun ARGS1(
d789 1
a789 1
static int news_max_chunk_fun ARGS1(
d802 1
a802 1
static int news_posting_fun ARGS1(
d806 1
a806 1
    no_newspost = (LYNewsPosting == FALSE);
d812 1
a812 1
static int cern_rulesfile_fun ARGS1(
d841 1
a841 1
    exit_immediately(69);	/* EX_UNAVAILABLE in sysexits.h */
d846 1
a846 1
static int printer_fun ARGS1(
d849 1
a849 1
    add_printer_to_list(value, &printers);
d853 1
a853 2
#ifdef SOURCE_CACHE
static int source_cache_fun ARGS1(
d856 6
a861 7
    if (!strncasecomp(value, "FILE", 4))
	LYCacheSource = SOURCE_CACHE_FILE;
    else if (!strncasecomp(value, "MEM", 3))
	LYCacheSource = SOURCE_CACHE_MEMORY;
    else if (!strncasecomp(value, "NONE", 4))
	LYCacheSource = SOURCE_CACHE_NONE;

a863 1
#endif
d865 1
a865 1
static int suffix_fun ARGS1(
d868 3
a870 1
    char *mime_type;
d873 2
a874 1
    || (NULL == (mime_type = strchr (value, ':'))))
d876 1
d879 21
d902 47
a948 1
    LYLowerCase(mime_type);
d950 13
a962 8
    if (strstr(mime_type, "tex") != NULL ||
	strstr(mime_type, "postscript") != NULL ||
	strstr(mime_type, "sh") != NULL ||
	strstr(mime_type, "troff") != NULL ||
	strstr(mime_type, "rtf") != NULL)
	HTSetSuffix(value, mime_type, "8bit", 1.0);
    else
	HTSetSuffix(value, mime_type, "binary", 1.0);
d964 4
d971 1
a971 1
static int system_editor_fun ARGS1(
d979 1
a979 1
static int viewer_fun ARGS1(
d1023 30
d1054 52
a1105 1
#ifdef USE_PSRC
d1107 14
a1120 1
static void html_src_bad_syntax ARGS2(
d1129 1
a1129 1
    exit_immediately(-1);
d1132 2
a1133 3

static int parse_html_src_spec ARGS3(
	    HTlexem, lexem_code,
d1152 4
a1155 2
    if ( html_src_parse_tagspec(value, lexem_code, TRUE, TRUE)
	|| html_src_parse_tagspec(ts2, lexem_code, TRUE, TRUE) )
d1162 1
a1162 2
    HTL_tagspecs[lexem_code] = NULL;
    StrAllocCopy(HTL_tagspecs[lexem_code],value);
d1167 34
a1200 15
#define defHTSRC_parse_fun(x) static int html_src_set_##x ARGS1( char*,str) \
 { parse_html_src_spec(HTL_##x,str,#x); return 0; }

defHTSRC_parse_fun(comm)
defHTSRC_parse_fun(tag)
defHTSRC_parse_fun(attrib)
defHTSRC_parse_fun(attrval)
defHTSRC_parse_fun(abracket)
defHTSRC_parse_fun(entity)
defHTSRC_parse_fun(href)
defHTSRC_parse_fun(entire)
defHTSRC_parse_fun(badseq)
defHTSRC_parse_fun(badtag)
defHTSRC_parse_fun(badattr)
defHTSRC_parse_fun(sgmlspecial)
d1202 1
a1202 3
#undef defHTSRC_parse_fun

static int read_htmlsrc_attrname_xform ARGS1( char*,str)
d1207 1
a1207 1
	    CTRACE(tfp,"bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", val);
d1211 2
a1212 2
	CTRACE(tfp,"bad value for htmlsrc_attrname_xform (ignored): %s\n",
		    str);
d1217 1
a1217 1
static int read_htmlsrc_tagname_xform ARGS1( char*,str)
d1222 1
a1222 1
	    CTRACE(tfp,"bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", val);
d1226 2
a1227 2
	CTRACE(tfp,"bad value for htmlsrc_tagname_xform (ignored): %s\n",
		    str);
a1230 5


#define defHTSRC_option(x) \
    PARSE_FUN( "htmlsrc_" #x ,CONF_FUN, html_src_set_##x),

d1233 6
a1238 7

/* This table should be sorted alphabetically */
static Config_Type Config_Table [] =
{
     PARSE_SET("accept_all_cookies", CONF_BOOL, &LYAcceptAllCookies),
     PARSE_INT("alertsecs", CONF_INT, &AlertSecs),
     PARSE_SET("always_resubmit_posts", CONF_BOOL, &LYresubmit_posts),
d1240 27
a1266 1
     PARSE_DEF("always_trusted_exec", CONF_ADD_TRUSTED, ALWAYS_EXEC_PATH),
d1268 2
a1269 11
     PARSE_FUN("assume_charset", CONF_FUN, assume_charset_fun),
     PARSE_FUN("assume_local_charset", CONF_FUN, assume_local_charset_fun),
     PARSE_FUN("assume_unrec_charset", CONF_FUN, assume_unrec_charset_fun),
     PARSE_SET("block_multi_bookmarks", CONF_BOOL, &LYMBMBlocked),
     PARSE_SET("bold_h1", CONF_BOOL, &bold_H1),
     PARSE_SET("bold_headers", CONF_BOOL, &bold_headers),
     PARSE_SET("bold_name_anchors", CONF_BOOL, &bold_name_anchors),
     PARSE_SET("case_sensitive_always_on", CONF_BOOL, &case_sensitive),
     PARSE_FUN("character_set", CONF_FUN, character_set_fun),
     PARSE_SET("checkmail", CONF_BOOL, &check_mail),
     PARSE_SET("collapse_br_tags", CONF_BOOL, &LYCollapseBRs),
d1271 1
a1271 1
     PARSE_FUN("color", CONF_FUN, color_fun),
d1273 10
a1282 1
     PARSE_STR("cookie_accept_domains", CONF_STR, &LYCookieSAcceptDomains),
d1284 1
a1284 1
     PARSE_STR("cookie_file", CONF_STR, &LYCookieFile),
d1286 2
a1287 5
     PARSE_STR("cookie_loose_invalid_domains", CONF_STR, &LYCookieSLooseCheckDomains),
     PARSE_STR("cookie_query_invalid_domains", CONF_STR, &LYCookieSQueryCheckDomains),
     PARSE_STR("cookie_reject_domains", CONF_STR, &LYCookieSRejectDomains),
     PARSE_STR("cookie_strict_invalid_domains", CONF_STR, &LYCookieSStrictCheckDomains),
     PARSE_ENV("cso_proxy", CONF_ENV, 0 ),
d1289 1
a1289 1
     PARSE_STR("CSWING_PATH", CONF_STR, &LYCSwingPath),
d1291 7
a1297 6
     PARSE_FUN("default_bookmark_file", CONF_FUN, default_bookmark_file_fun),
     PARSE_FUN("default_cache_size", CONF_FUN, default_cache_size_fun),
     PARSE_FUN("default_editor", CONF_FUN, default_editor_fun),
     PARSE_STR("default_index_file", CONF_STR, &indexfile),
     PARSE_FUN("default_keypad_mode_is_numbers_as_arrows", CONF_FUN, numbers_as_arrows_fun),
     PARSE_FUN("default_user_mode", CONF_FUN, default_user_mode_fun),
d1299 1
a1299 1
     PARSE_INT("default_virtual_memory_size", CONF_INT, &HTVirtualMemorySize),
d1302 1
a1302 1
     PARSE_FUN("dired_menu", CONF_FUN, dired_menu_fun),
d1304 7
a1310 3
     PARSE_ADD("downloader", CONF_ADD_ITEM, downloaders),
     PARSE_SET("emacs_keys_always_on", CONF_BOOL, &emacs_keys),
     PARSE_SET("enable_scrollback", CONF_BOOL, &enable_scrollback),
d1312 1
a1312 1
     PARSE_ADD("external", CONF_ADD_ITEM, externals),
d1314 7
a1320 3
     PARSE_ENV("finger_proxy", CONF_ENV, 0 ),
     PARSE_SET("force_8bit_toupper", CONF_BOOL, &UCForce8bitTOUPPER),
     PARSE_SET("force_ssl_cookies_secure", CONF_BOOL, &LYForceSSLCookiesSecure),
d1322 27
a1348 1
     PARSE_SET("forms_options", CONF_BOOL, &LYUseFormsOptions),
a1349 40
     PARSE_SET("ftp_passive", CONF_BOOL, &ftp_passive),
     PARSE_ENV("ftp_proxy", CONF_ENV, 0 ),
     PARSE_STR("global_extension_map", CONF_STR, &global_extension_map),
     PARSE_STR("global_mailcap", CONF_STR, &global_type_map),
     PARSE_ENV("gopher_proxy", CONF_ENV, 0 ),
     PARSE_SET("gotobuffer", CONF_BOOL, &goto_buffer),
     PARSE_STR("helpfile", CONF_STR, &helpfile),
     PARSE_SET("historical_comments", CONF_BOOL, &historical_comments),

#ifdef USE_PSRC

     defHTSRC_option(abracket)
     defHTSRC_option(attrib)

     PARSE_FUN("htmlsrc_attrname_xform", CONF_FUN, read_htmlsrc_attrname_xform),

     defHTSRC_option(attrval)
     defHTSRC_option(badattr)
     defHTSRC_option(badseq)
     defHTSRC_option(badtag)
     defHTSRC_option(comm)
     defHTSRC_option(entire)
     defHTSRC_option(entity)
     defHTSRC_option(href)
     defHTSRC_option(sgmlspecial)
     defHTSRC_option(tag)

     PARSE_FUN("htmlsrc_tagname_xform", CONF_FUN, read_htmlsrc_tagname_xform),


# undef defHTSRC_option
#endif

     PARSE_ENV("http_proxy", CONF_ENV, 0 ),
     PARSE_ENV("https_proxy", CONF_ENV, 0 ),
     PARSE_FUN("include", CONF_INCLUDE, 0),
     PARSE_INT("infosecs", CONF_INT, &InfoSecs),
     PARSE_STR("jump_prompt", CONF_STR, &jumpprompt),
     PARSE_SET("jumpbuffer", CONF_BOOL, &jump_buffer),
     PARSE_FUN("jumpfile", CONF_FUN, jumpfile_fun),
d1351 6
a1356 1
     PARSE_FUN("keyboard_layout", CONF_FUN, keyboard_layout_fun),
a1357 1
     PARSE_FUN("keymap", CONF_FUN, keymap_fun),
d1359 2
a1360 5
     PARSE_SET("list_news_numbers", CONF_BOOL, &LYListNewsNumbers),
     PARSE_SET("list_news_dates", CONF_BOOL, &LYListNewsDates),
#endif
#ifndef VMS
     PARSE_STR("list_format", CONF_STR, &list_format),
d1362 1
a1362 2
     PARSE_FUN("localhost_alias", CONF_FUN, localhost_alias_fun),
     PARSE_STR("local_domain", CONF_STR, &LYLocalDomain),
d1364 2
a1365 2
     PARSE_SET("local_execution_links_always_on", CONF_BOOL, &local_exec),
     PARSE_SET("local_execution_links_on_but_not_remote", CONF_BOOL, &local_exec_on_local_files),
d1367 3
a1370 1
     PARSE_FUN("lynxcgi_environment", CONF_FUN, lynxcgi_environment_fun),
d1372 1
a1372 1
     PARSE_STR("lynxcgi_document_root", CONF_STR, &LYCgiDocumentRoot),
d1374 1
d1376 2
a1377 5
     PARSE_STR("lynx_host_name", CONF_STR, &LYHostName),
     PARSE_FUN("lynx_sig_file", CONF_FUN, lynx_sig_file_fun),
     PARSE_SET("mail_system_error_logging", CONF_BOOL, &error_logging),
#ifdef VMS
     PARSE_STR("mail_adrs", CONF_STR, &mail_adrs),
d1379 7
a1385 6
     PARSE_SET("make_links_for_all_images", CONF_BOOL, &clickable_images),
     PARSE_SET("make_pseudo_alts_for_inlines", CONF_BOOL, &pseudo_inline_alts),
     PARSE_INT("messagesecs", CONF_INT, &MessageSecs),
     PARSE_SET("minimal_comments", CONF_BOOL, &minimal_comments),
     PARSE_SET("multi_bookmark_support", CONF_BOOL, &LYMultiBookmarks),
     PARSE_SET("ncr_in_bookmarks", CONF_BOOL, &UCSaveBookmarksInUnicode),
d1387 8
a1394 8
     PARSE_FUN("news_chunk_size", CONF_FUN, news_chunk_size_fun),
     PARSE_FUN("news_max_chunk", CONF_FUN, news_max_chunk_fun),
     PARSE_FUN("news_posting", CONF_FUN, news_posting_fun),
     PARSE_ENV("news_proxy", CONF_ENV, 0),
     PARSE_ENV("newspost_proxy", CONF_ENV, 0),
     PARSE_ENV("newsreply_proxy", CONF_ENV, 0),
     PARSE_ENV("nntp_proxy", CONF_ENV, 0),
     PARSE_ENV("nntpserver", CONF_ENV2, 0), /* actually NNTPSERVER */
d1396 2
a1397 2
     PARSE_SET("no_dot_files", CONF_BOOL, &no_dotfiles),
     PARSE_SET("no_file_referer", CONF_BOOL, &no_filereferer),
d1399 8
a1406 1
     PARSE_SET("no_forced_core_dump", CONF_BOOL, &LYNoCore),
d1408 2
a1409 5
     PARSE_SET("no_from_header", CONF_BOOL, &LYNoFromHeader),
     PARSE_SET("no_ismap_if_usemap", CONF_BOOL, &LYNoISMAPifUSEMAP),
     PARSE_ENV("no_proxy", CONF_ENV, 0 ),
     PARSE_SET("no_referer_header", CONF_BOOL, &LYNoRefererHeader),
     PARSE_FUN("outgoing_mail_charset", CONF_FUN, outgoing_mail_charset_fun),
d1411 2
a1412 2
     PARSE_SET("partial", CONF_BOOL, &display_partial_flag),
     PARSE_INT("partial_thres", CONF_INT, &partial_threshold),
d1415 1
a1415 1
     PARSE_SET("persistent_cookies", CONF_BOOL, &persistent_cookies),
d1417 15
a1431 8
     PARSE_STR("personal_mailcap", CONF_STR, &personal_type_map),
     PARSE_STR("personal_extension_map", CONF_STR, &personal_extension_map),
     PARSE_STR("preferred_charset", CONF_STR, &pref_charset),
     PARSE_STR("preferred_language", CONF_STR, &language),
     PARSE_SET("prepend_base_to_source", CONF_BOOL, &LYPrependBaseToSource),
     PARSE_SET("prepend_charset_to_source", CONF_BOOL, &LYPrependCharsetToSource),
     PARSE_FUN("printer", CONF_FUN, printer_fun),
     PARSE_SET("quit_default_yes", CONF_BOOL, &LYQuitDefaultYes),
d1433 2
a1434 2
     PARSE_FUN("rule", CONF_FUN, HTSetConfiguration),
     PARSE_FUN("rulesfile", CONF_FUN, cern_rulesfile_fun),
d1436 15
a1450 11
     PARSE_STR("save_space", CONF_STR, &lynx_save_space),
     PARSE_SET("scan_for_buried_news_refs", CONF_BOOL, &scan_for_buried_news_references),
     PARSE_SET("seek_frag_area_in_cur", CONF_BOOL, &LYSeekFragAREAinCur),
     PARSE_SET("seek_frag_map_in_cur", CONF_BOOL, &LYSeekFragMAPinCur),
     PARSE_SET("set_cookies", CONF_BOOL, &LYSetCookies),
     PARSE_SET("show_cursor", CONF_BOOL, &LYShowCursor),
     PARSE_SET("show_kb_rate", CONF_BOOL, &LYshow_kb_rate),
     PARSE_ENV("snews_proxy", CONF_ENV, 0 ),
     PARSE_ENV("snewspost_proxy", CONF_ENV, 0 ),
     PARSE_ENV("snewsreply_proxy", CONF_ENV, 0 ),
     PARSE_SET("soft_dquotes", CONF_BOOL, &soft_dquotes),
d1452 2
a1453 1
     PARSE_SET("source_cache", CONF_FUN, source_cache_fun),
d1455 16
a1470 8
     PARSE_STR("startfile", CONF_STR, &startfile),
     PARSE_SET("strip_dotdot_urls", CONF_BOOL, &LYStripDotDotURLs),
     PARSE_SET("substitute_underscores", CONF_BOOL, &use_underscore),
     PARSE_FUN("suffix", CONF_FUN, suffix_fun),
     PARSE_FUN("system_editor", CONF_FUN, system_editor_fun),
     PARSE_STR("system_mail", CONF_STR, &system_mail),
     PARSE_STR("system_mail_flags", CONF_STR, &system_mail_flags),
     PARSE_SET("tagsoup", CONF_BOOL, &Old_DTD),
d1472 1
a1472 1
     PARSE_DEF("trusted_exec", CONF_ADD_TRUSTED, EXEC_PATH),
d1475 1
a1475 1
     PARSE_DEF("trusted_lynxcgi", CONF_ADD_TRUSTED, CGI_PATH),
a1476 2
     PARSE_STR("url_domain_prefixes", CONF_STR, &URLDomainPrefixes),
     PARSE_STR("url_domain_suffixes", CONF_STR, &URLDomainSuffixes),
d1478 1
a1478 1
     PARSE_ADD("uploader", CONF_ADD_ITEM, uploaders),
d1480 2
d1483 1
a1483 1
     PARSE_SET("use_fixed_records", CONF_BOOL, &UseFixedRecords),
d1485 2
a1486 2
#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
     PARSE_SET("use_mouse", CONF_BOOL, &LYUseMouse),
d1488 6
a1493 6
     PARSE_SET("use_select_popups", CONF_BOOL, &LYSelectPopups),
     PARSE_SET("verbose_images", CONF_BOOL, &verbose_img),
     PARSE_SET("vi_keys_always_on", CONF_BOOL, &vi_keys),
     PARSE_FUN("viewer", CONF_FUN, viewer_fun),
     PARSE_ENV("wais_proxy", CONF_ENV, 0 ),
     PARSE_STR("xloadimage_command", CONF_STR, &XLoadImageCommand),
d1495 1
a1495 1
     {0, 0, 0}
d1498 5
d1511 2
a1512 5
#ifdef PARSE_DEBUG
	Config_Type *q = tbl;
#else
	ConfigUnion *q = (ConfigUnion *)(&(tbl->value));
#endif
d1527 1
a1527 1
		    	break;
d1542 8
a1549 2
    free_item_list();
    free_printer_item_list();
d1556 1
a1556 1
    char ch = TOUPPER(*name);
d1570 55
a1624 1
#define NOPTS_ ( (sizeof Config_Table)/(sizeof Config_Table[0]) - 1 )
a1650 1
    char mypath[LY_MAXPATH];
d1653 1
a1653 1
    CTRACE(tfp, "Loading cfg file '%s'.\n", cfg_filename);
d1665 1
a1665 1
	exit(-1);
d1671 1
a1671 1
	CTRACE(tfp,"No filename following -cfg switch!\n");
d1674 2
a1675 7
    if (!strncmp(cfg_filename, "~/", 2)) {
	strcpy(mypath, Home_Dir());
	strcat(mypath, cfg_filename+1);
	cfg_filename = mypath;
    }
    if ((fp = fopen(cfg_filename,"r")) == 0) {
	CTRACE(tfp,"lynx.cfg file not found as %s\n",cfg_filename);
d1683 7
d1694 1
a1694 5
#ifdef PARSE_DEBUG
	Config_Type *q;
#else
	ConfigUnion *q;
#endif
d1701 1
a1701 1
	if (*name == '#')
d1728 1
a1728 1
	    if (isspace ((unsigned char) *cp))
d1737 4
d1753 1
a1753 5
#ifdef PARSE_DEBUG
	q = tbl;
#else
	q = (ConfigUnion *)(&(tbl->value));
#endif
d1767 17
a1786 4
		/* Apparently, if an integer value is not present, then the
		 * value is not changed.  So, use the sscanf function to make
		 * this determination.
		 */
d1810 1
a1810 1
			q->str_value = calloc(1, sizeof(char *));
d1819 1
a1819 1
	    optidx_set_t cur_set,anded_set;
d1838 2
a1839 2
	    if (fp0 != 0  &&  !LYRestricted) {
		LYLocalFileToURL(&url, value);
d1893 1
a1893 1
	    /* 
d1896 1
a1896 1
	     * of allowed options in <ul>.  Option names will be uppercased. 
d1899 1
a1899 1
	    if (fp0 != 0  &&  !LYRestricted && resultant_set) {
d1917 1
a1917 1
	    if (fp0 != 0  &&  !LYRestricted) {
d1928 1
a1928 1
		add_item_to_list (value, q->add_value);
d1952 1
a1952 1
    fclose (fp);
d1961 1
a1961 1
	lynx_html_item_type *cur_download;
d1980 2
a1982 46
    if (LYCookieSAcceptDomains != NULL) {
	cookie_domain_flag_set(LYCookieSAcceptDomains, FLAG_ACCEPT_ALWAYS);
	FREE(LYCookieSAcceptDomains);
    }

    if (LYCookieSRejectDomains != NULL) {
	cookie_domain_flag_set(LYCookieSRejectDomains, FLAG_REJECT_ALWAYS);
	FREE(LYCookieSRejectDomains);
    }

    if (LYCookieSStrictCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieSStrictCheckDomains, FLAG_INVCHECK_STRICT);
	FREE(LYCookieSStrictCheckDomains);
    }

    if (LYCookieSLooseCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieSLooseCheckDomains, FLAG_INVCHECK_LOOSE);
	FREE(LYCookieSLooseCheckDomains);
    }

    if (LYCookieSQueryCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieSQueryCheckDomains, FLAG_INVCHECK_QUERY);
	FREE(LYCookieSQueryCheckDomains);
    }

    if (LYCookieAcceptDomains != NULL) {
	cookie_domain_flag_set(LYCookieAcceptDomains, FLAG_ACCEPT_ALWAYS);
    }

    if (LYCookieRejectDomains != NULL) {
	cookie_domain_flag_set(LYCookieRejectDomains, FLAG_REJECT_ALWAYS);
    }

    if (LYCookieStrictCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieStrictCheckDomains, FLAG_INVCHECK_STRICT);
    }

    if (LYCookieLooseCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieLooseCheckDomains, FLAG_INVCHECK_LOOSE);
    }

    if (LYCookieQueryCheckDomains != NULL) {
	cookie_domain_flag_set(LYCookieQueryCheckDomains, FLAG_INVCHECK_QUERY);
    }

}
d1990 1
a1990 2
    do_read_cfg(cfg_filename,parent_filename,nesting_level,fp0,
	NULL);
d1996 1
a1996 1
 *  Called from getfile() cyrcle:
d2002 1
a2002 2
    static char tempfile[LY_MAXPATH];
    static char *local_url;  /* static! */
d2015 1
a2015 1
    if ((strstr(newdoc->address, "LYNXCFG://reload")) && !LYRestricted) {
d2017 1
a2017 1
	 *  Some staff to reload read_cfg(),
a2026 12

	/*  the page was pushed, so pop-up. */
	LYpop(newdoc);
	WWWDoc.address = newdoc->address;
	WWWDoc.post_data = newdoc->post_data;
	WWWDoc.post_content_type = newdoc->post_content_type;
	WWWDoc.bookmark = newdoc->bookmark;
	WWWDoc.isHEAD = newdoc->isHEAD;
	WWWDoc.safe = newdoc->safe;
	LYforce_no_cache = FALSE;   /* ! */
	LYoverride_no_cache = TRUE; /* ! */

d2028 2
a2029 6
	 * Working out of getfile() cycle we reset *no_cache manually here so
	 * HTLoadAbsolute() will return "Document already in memory":  it was
	 * forced reloading obsolete file again without this (overhead).
	 *
	 * Probably *no_cache was set in a wrong position because of
	 * the internal page...
d2031 27
a2057 2
	if (!HTLoadAbsolute(&WWWDoc))
	    return(NOT_FOUND);
d2059 3
a2061 1
	HTuncache_current_document();  /* will never use again */
d2064 1
a2064 1
	local_url = 0;	/* see below */
d2068 17
d2086 8
a2093 1
    if (local_url == 0) {
d2095 8
a2102 2
	LYRemoveTemp(tempfile);
	if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
d2106 1
a2106 1
	LYLocalFileToURL(&local_url, tempfile);
d2115 1
a2115 1
	if (!LYRestricted) {
d2139 9
a2147 1
    /** a new experimental link ... **/
d2178 1
d2181 2
a2182 2
    /* return to getfile() cyrcle */
    StrAllocCopy(newdoc->address, local_url);
d2192 3
d2202 1
a2202 1
 *  from getfile() cyrcle.
d2207 1
a2207 1
    char tempfile[LY_MAXPATH];
a2210 1
    static char *info_url;  /* static! */
d2214 15
a2228 1
    /* create the page only once - compile-time data will not change... */
d2230 15
a2244 2
    if (info_url == 0) {
	if ((fp0 = LYOpenTemp (tempfile, HTML_SUFFIX, "w")) == 0) {
d2248 1
a2248 1
	LYLocalFileToURL(&info_url, tempfile);
a2252 5
	fprintf(fp0, "%s %s<a href=\"LYNXCFG:\"> lynx.cfg</a> %s\n\n",
		     SEE_ALSO,
		     YOUR_SEGMENT,
		     RUNTIME_OPT_SEGMENT);

d2264 1
d2267 2
a2268 2
    /* exit to getfile() cyrcle */
    StrAllocCopy(newdoc->address, info_url);
d2278 3
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d1021 1
@


1.1
log
@Initial revision
@
text
@d1 26
a26 18
#include "HTUtils.h"
#include "tcp.h"
#include "HTFile.h"
#include "UCMap.h"

#include "LYUtils.h"
#include "LYStrings.h"
#include "LYStructs.h"
#include "LYGlobalDefs.h"
#include "LYCharSets.h"
#include "LYKeymap.h"
#include "LYJump.h"
#include "LYGetFile.h"
#include "LYCgi.h"
#include "LYCurses.h"
#include "LYSignal.h"
#include "LYBookmark.h"
#include "LYReadCFG.h"
d29 1
a29 1
#include "LYLocal.h"
d32 2
a33 4
#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d35 1
d38 1
d40 2
a41 8
PUBLIC BOOLEAN have_read_cfg=FALSE;
PUBLIC BOOLEAN LYUseNoviceLineTwo=TRUE;

#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */
d128 1
a128 1
	char *, 		buffer,
d143 1
a143 1
	    perror("Out of memory in read_cfg");
d145 1
d147 1
d158 1
a158 1
	    perror("Out of memory in read_cfg");
d176 1
a176 1
	    perror("Out of memory in read_cfg");
d181 2
a182 1
	 *  Process TRUE/FALSE field
d184 4
a187 1
	if ((next_colon = find_colon(colon+1)) != NULL) {
d190 1
a190 1
		perror("Out of memory in read_cfg");
d193 4
a196 1
	    cur_item->always_enabled = is_true(next_colon+1);
d226 1
a226 1
	char *, 			buffer,
d241 1
a241 1
	    perror("Out of memory in read_cfg");
d243 1
d245 1
d257 1
a257 1
	    perror("Out of memory in read_cfg");
d275 1
a275 1
	    perror("Out of memory in read_cfg");
d285 1
a285 1
		perror("Out of memory in read_cfg");
d294 2
a295 1
	if ((next_colon = find_colon(next_colon+1)) != NULL) {
d314 1
a314 1
static char *Color_Strings[16] =
d379 1
a379 1
	char *, 	error_line)
d382 1
a382 1
    fprintf (stderr, "\
d388 1
a388 1
The special strings 'nocolor' or 'default', or\n"
d395 2
a396 14
    fprintf (stderr, "Offending line:\n%s\n",error_line);

#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
    if (no_suspend)
	(void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
    exit(-1);
d407 1
a407 1
    char temp[501];
d409 1
a409 4
    if (strlen(buffer) < sizeof(temp))
	strcpy(temp, buffer);
    else
	strcpy(temp, "Color config line too long");
d436 1
d440 38
a477 5
/*
 * Process the configuration file (lynx.cfg).
 */
PUBLIC void read_cfg ARGS1(
	char *, cfg_filename)
d479 16
a494 5
    FILE *fp;
    char buffer[501];
    char temp[501];
    char *cp, *cp1;
    int i, j, len;
d496 9
a504 14
    /*
     *	Locate and open the file.
     */
    if (!cfg_filename || strlen(cfg_filename) == 0) {
	if (TRACE)
	    fprintf(stderr,"No filename following -cfg switch!\n");
	return;
    }
    if ((fp = fopen(cfg_filename,"r")) == NULL) {
	if (TRACE)
	    fprintf(stderr,"lynx.cfg file not found as %s\n",cfg_filename);
	return;
    }
    have_read_cfg=TRUE;
d506 2
a507 9
    /*
     *	Process each line in the file.
     */
    while (fgets(buffer, 500, fp) != NULL) {
	/*
	 *  Strip off \n at the end.
	 */
	if ((cp = (char *)strchr(buffer, '\n')) != NULL)
	    *cp = '\0';
d509 6
a514 11
	/*
	 *  Trim off any trailing comments.
	 */
	if ((cp = (char *)strrchr(buffer, ':')) != NULL) {
	    if ((cp1 = (char *)strchr(cp, '#')) != NULL) {
		cp1--;
		if (isspace((unsigned char)*cp1)) {
		    *cp1 = '\0';
		}
	    }
	}
d516 6
a521 8
	/*
	 *  Strip off trailing white space.
	 */
	len = strlen(buffer);
	while (len && isspace(buffer[len-1])) {
	    len--;
	    buffer[len] = '\0';
	}
d523 8
a530 5
	/*
	 *  Skip any blank or purely comment lines.
	 */
	if (buffer[0] == '\0' || buffer[0] == '#')
	    continue;
d532 2
a533 4
	/*
	 * Process the string buffer.
	 */
	switch (TOUPPER(buffer[0])) {
d535 5
a539 11
	case 'A':
	if (!strncasecomp(buffer, "ALERTSECS:", 10)) {
	    strcpy(temp, buffer+10);
	    for (i = 0; temp[i]; i++) {
		if (!isdigit(temp[i])) {
		    temp[i] = '\0';
		    break;
		}
	    }
	    if (temp[0])
		AlertSecs = atoi(temp);
d541 2
a542 2
	} else if (!strncasecomp(buffer, "ALWAYS_RESUBMIT_POSTS:", 22)) {
	    LYresubmit_posts = is_true(buffer+22);
a543 29
#ifdef EXEC_LINKS
	} else if (!strncasecomp(buffer, "ALWAYS_TRUSTED_EXEC:", 20)) {
	    add_trusted(&buffer[20], ALWAYS_EXEC_PATH); /* Add exec path */
#endif /* EXEC_LINKS */

	} else if (!strncasecomp(buffer, "ASSUME_CHARSET:", 15)) {
	    StrAllocCopy(UCAssume_MIMEcharset, buffer+15);
	    for (i = 0; UCAssume_MIMEcharset[i]; i++)
		UCAssume_MIMEcharset[i] = TOLOWER(UCAssume_MIMEcharset[i]);
	    UCLYhndl_for_unspec =
		UCGetLYhndl_byMIME(UCAssume_MIMEcharset);

	} else if (!strncasecomp(buffer, "ASSUME_LOCAL_CHARSET:", 21)) {
	    StrAllocCopy(UCAssume_localMIMEcharset, buffer+21);
	    for (i = 0; UCAssume_localMIMEcharset[i]; i++)
		UCAssume_localMIMEcharset[i] =
			TOLOWER(UCAssume_localMIMEcharset[i]);
	    UCLYhndl_HTFile_for_unspec =
		UCGetLYhndl_byMIME(UCAssume_localMIMEcharset);

	} else if (!strncasecomp(buffer, "ASSUME_UNREC_CHARSET:", 21)) {
	    StrAllocCopy(UCAssume_unrecMIMEcharset, buffer+21);
	    for (i = 0; UCAssume_unrecMIMEcharset[i]; i++)
		UCAssume_unrecMIMEcharset[i] =
			TOLOWER(UCAssume_unrecMIMEcharset[i]);
	    UCLYhndl_for_unrec =
		UCGetLYhndl_byMIME(UCAssume_unrecMIMEcharset);
	}
	break;
d545 8
a552 3
	case 'B':
	if (!strncasecomp(buffer, "BLOCK_MULTI_BOOKMARKS:", 22)) {
	    LYMBMBlocked = is_true(buffer+22);
d554 9
a562 2
	} else if (!strncasecomp(buffer, "BOLD_H1:", 8)) {
	    bold_H1 = is_true(buffer+8);
d564 7
a570 2
	} else if (!strncasecomp(buffer, "BOLD_HEADERS:", 13)) {
	    bold_headers = is_true(buffer+13);
d572 6
a577 4
	} else if (!strncasecomp(buffer, "BOLD_NAME_ANCHORS:", 18)) {
	    bold_name_anchors = is_true(buffer+18);
	}
	break;
d579 7
a585 13
	case 'C':
	if (!strncasecomp(buffer, "CASE_SENSITIVE_ALWAYS_ON:", 25)) {
	     case_sensitive = is_true(buffer+25);

	} else if (!strncasecomp(buffer, "CHARACTER_SET:", 14)) {
	    for (i = 0; LYchar_set_names[i]; i++) {
		if (!strncmp(buffer+14,
			     LYchar_set_names[i], strlen(buffer+14))) {
		    current_char_set=i;
		    HTMLSetRawModeDefault(i);
		    break;
		}
	    }
d587 2
a588 2
	} else if (!strncasecomp(buffer, "CHECKMAIL:", 10)) {
	    check_mail = is_true(buffer+10);
d590 9
a598 2
	} else if (!strncasecomp(buffer, "COLLAPSE_BR_TAGS:", 17)) {
		LYCollapseBRs = is_true(buffer+17);
d600 2
a601 4
#if USE_COLOR_TABLE
	} else if (!strncasecomp(buffer, "COLOR:", 6)) {
		parse_color(buffer + 6);
#endif /* USE_COLOR_TABLE */
d603 8
a610 12
	} else if (!strncasecomp(buffer, "cso_proxy:", 10)) {
	    if (getenv("cso_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "cso_proxy");
		Define_VMSLogical(temp, (char *)&buffer[10]);
#else
		strcpy(temp, "cso_proxy=");
		StrAllocCopy(cso_proxy_putenv_cmd, temp);
		StrAllocCat(cso_proxy_putenv_cmd, (char *)&buffer[10]);
		putenv(cso_proxy_putenv_cmd);
#endif /* VMS */
	    }
d612 4
a615 6
#ifdef VMS
	} else if (!strncasecomp(buffer, "CSWING_PATH:", 12)) {
	    StrAllocCopy(LYCSwingPath, buffer+12);
#endif /* VMS */
	}
	break;
d617 4
a620 23
	case 'D':
	if (!strncasecomp(buffer, "DEFAULT_BOOKMARK_FILE:", 22)) {
	    StrAllocCopy(bookmark_page, buffer+22);
	    StrAllocCopy(BookmarkPage, bookmark_page);
	    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	    StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);

	} else if (!strncasecomp(buffer, "DEFAULT_CACHE_SIZE:", 19)) {
		HTCacheSize = atoi(buffer+19);

	} else if (!system_editor &&
		   !strncasecomp(buffer, "DEFAULT_EDITOR:", 15)) {
	    StrAllocCopy(editor, buffer+15);

	} else if (!strncasecomp(buffer, "DEFAULT_INDEX_FILE:", 19)) {
	    StrAllocCopy(indexfile, buffer+19);

	} else if (!strncasecomp(buffer,
			"DEFAULT_KEYPAD_MODE_IS_NUMBERS_AS_ARROWS:", 41)) {
	    if (is_true(buffer+41))
		keypad_mode = NUMBERS_AS_ARROWS;
	    else
		keypad_mode = LINKS_ARE_NUMBERED;
d622 2
a623 7
	} else if (!strncasecomp(buffer, "DEFAULT_USER_MODE:", 18)) {
	    if (!strncasecomp(buffer+18, "NOVICE", 6))
		user_mode = NOVICE_MODE;
	    else if (!strncasecomp(buffer+18, "INTER", 5))
		user_mode = INTERMEDIATE_MODE;
	    else if (!strncasecomp(buffer+18, "ADVANCE", 7))
		user_mode = ADVANCED_MODE;
d625 9
a633 5
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
	} else if (!strncasecomp(buffer,
				 "DEFAULT_VIRTUAL_MEMORY_SIZE:", 28)) {
		HTVirtualMemorySize = atoi(buffer+28);
#endif /* VMS && VAXC && !__DECC */
d635 4
a638 4
#ifdef DIRED_SUPPORT
	} else if (!strncasecomp(buffer, "DIRED_MENU:", 11)) {
	    add_menu_item(&buffer[11]);
#endif /* DIRED_SUPPORT */
d640 13
a652 4
	} else if (!strncasecomp(buffer, "DOWNLOADER:", 11)) {
	    add_item_to_list(&buffer[11], &downloaders);
	}
	break;
d654 6
a659 3
	case 'E':
	if (!strncasecomp(buffer, "EMACS_KEYS_ALWAYS_ON:", 21)) {
	    emacs_keys = is_true(buffer+21);
d661 7
a667 7
	} else if (!strncasecomp(buffer, "ENABLE_SCROLLBACK:", 18)) {
	    enable_scrollback = is_true(buffer+18);
	}
#ifdef USE_EXTERNALS
	else if(!strncasecomp(buffer,"EXTERNAL:",9)) {
	    add_item_to_list(&buffer[9],&externals);
	}
a668 1
	break;
d670 15
a684 13
	case 'F':
	if (!strncasecomp(buffer, "finger_proxy:", 13)) {
	    if (getenv("finger_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "finger_proxy");
		Define_VMSLogical(temp, (char *)&buffer[13]);
#else
		strcpy(temp, "finger_proxy=");
		StrAllocCopy(finger_proxy_putenv_cmd, temp);
		StrAllocCat(finger_proxy_putenv_cmd, (char *)&buffer[13]);
		putenv(finger_proxy_putenv_cmd);
#endif /* VMS */
	    }
d686 13
a698 2
	} else if (!strncasecomp(buffer, "FORCE_SSL_COOKIES_SECURE:", 25)) {
	    LYForceSSLCookiesSecure = is_true(buffer+25);
d700 12
a711 14
	} else if (!strncasecomp(buffer, "ftp_proxy:", 10)) {
	    if (getenv("ftp_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "ftp_proxy");
		Define_VMSLogical(temp, (char *)&buffer[10]);
#else
		strcpy(temp, "ftp_proxy=");
		StrAllocCopy(ftp_proxy_putenv_cmd, temp);
		StrAllocCat(ftp_proxy_putenv_cmd, (char *)&buffer[10]);
		putenv(ftp_proxy_putenv_cmd);
#endif /* VMS */
	    }
	}
	break;
d713 8
a720 3
	case 'G':
	if (!strncasecomp(buffer, "GLOBAL_EXTENSION_MAP:", 21)) {
	    StrAllocCopy(global_extension_map, buffer+21);
d722 34
a755 2
	} else if (!strncasecomp(buffer, "GLOBAL_MAILCAP:", 15)) {
	    StrAllocCopy(global_type_map, buffer+15);
d757 6
a762 12
	} else if (!strncasecomp(buffer, "gopher_proxy:", 13)) {
	    if (getenv("gopher_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "gopher_proxy");
		Define_VMSLogical(temp, (char *)&buffer[13]);
#else
		strcpy(temp, "gopher_proxy=");
		StrAllocCopy(gopher_proxy_putenv_cmd, temp);
		StrAllocCat(gopher_proxy_putenv_cmd, (char *)&buffer[13]);
		putenv(gopher_proxy_putenv_cmd);
#endif /* VMS */
	    }
d764 10
a773 4
	} else if (!strncasecomp(buffer, "GOTOBUFFER:", 11)) {
	    goto_buffer = is_true(buffer+11);
	}
	break;
d775 3
a777 3
	case 'H':
	if (!strncasecomp(buffer, "HELPFILE:", 9)) {
	    StrAllocCopy(helpfile, buffer+9);
d779 4
a782 2
	} else if (!strncasecomp(buffer, "HISTORICAL_COMMENTS:", 20)) {
	    historical_comments = is_true(buffer+20);
d784 20
a803 12
	} else if (!strncasecomp(buffer, "http_proxy:", 11)) {
	    if (getenv("http_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "http_proxy");
		Define_VMSLogical(temp, (char *)&buffer[11]);
#else
		strcpy(temp, "http_proxy=");
		StrAllocCopy(http_proxy_putenv_cmd, temp);
		StrAllocCat(http_proxy_putenv_cmd, (char *)&buffer[11]);
		putenv(http_proxy_putenv_cmd);
#endif /* VMS */
	    }
d805 7
a811 14
	} else if (!strncasecomp(buffer, "https_proxy:", 12)) {
	    if (getenv("https_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "https_proxy");
		Define_VMSLogical(temp, (char *)&buffer[12]);
#else
		strcpy(temp, "https_proxy=");
		StrAllocCopy(https_proxy_putenv_cmd, temp);
		StrAllocCat(https_proxy_putenv_cmd, (char *)&buffer[12]);
		putenv(https_proxy_putenv_cmd);
#endif /* VMS */
	    }
	}
	break;
d813 35
a847 11
	case 'I':
	if (!strncasecomp(buffer, "INFOSECS:", 9)) {
	    strcpy(temp, buffer+9);
	    for (i = 0; temp[i]; i++) {
		if (!isdigit(temp[i])) {
		    temp[i] = '\0';
		    break;
		}
	    }
	    if (temp[0])
		InfoSecs = atoi(temp);
d849 4
a852 1
	break;
d854 2
a855 14
	case 'J':
	if (!strncasecomp(buffer, "JUMP_PROMPT:", 12)) {
	    StrAllocCopy(jumpprompt, buffer+12);

	} else if (!strncasecomp(buffer, "JUMPBUFFER:", 11)) {
	    jump_buffer = is_true(buffer+11);

	} else if (!strncasecomp(buffer, "JUMPFILE:", 9)) {
	    if (!LYJumpInit(buffer)) {
		if (TRACE)
		    fprintf(stderr, "Failed to register %s\n", buffer);
	    }
	}
	break;
a856 17
	case 'K':
	if (!strncasecomp(buffer, "KEYMAP:", 7)) {
	    char *key;
	    char *func;

	    key = buffer + 7;
	    if ((func = strchr(key, ':')) != NULL)	{
		*func++ = '\0';
		/* Allow comments on the ends of key remapping lines. - DT */
		if (!remap(key, strtok(func, " \t\n#")))
		    fprintf(stderr,
			    "key remapping of %s to %s failed\n",key,func);
		else if (!strcmp("TOGGLE_HELP", strtok(func, " \t\n#")))
		    LYUseNoviceLineTwo = FALSE;
	    }
	}
	break;
d858 1
a858 3
	case 'L':
	if (!strncasecomp(buffer, "LIST_NEWS_NUMBERS:", 18)) {
		LYListNewsNumbers = is_true(buffer+18);
d860 5
a864 2
	} else if (!strncasecomp(buffer, "LIST_NEWS_DATES:", 16)) {
		LYListNewsDates = is_true(buffer+16);
d866 5
a870 4
#ifndef VMS
	} else if (!strncasecomp(buffer, "LIST_FORMAT:", 12)) {
	    StrAllocCopy(list_format, buffer+12);
#endif /* !VMS */
a871 2
	} else if (!strncasecomp(buffer, "LOCALHOST_ALIAS:", 16)) {
	    LYAddLocalhostAlias(buffer+16);
d873 26
a898 2
	} else if (!strncasecomp(buffer, "LOCAL_DOMAIN:", 13)) {
	    StrAllocCopy(LYLocalDomain, buffer+13);
d900 6
a905 9
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
	} else if (!strncasecomp(buffer,
			 "LOCAL_EXECUTION_LINKS_ALWAYS_ON:", 32)) {
	    local_exec = is_true(buffer+32);

	} else if (!strncasecomp(buffer,
			 "LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE:", 40)) {
	    local_exec_on_local_files = is_true(buffer+40);
#endif /* defined(EXEC_LINKS) || defined(EXEC_SCRIPTS) */
d907 2
a908 3
#ifdef LYNXCGI_LINKS
	} else if (!strncasecomp(buffer, "LYNXCGI_ENVIRONMENT:", 20)) {
	    add_lynxcgi_environment(buffer+20);
d910 12
a921 26
#ifndef VMS
	/* WebSter Mods - Next 2 Lines -jkt */
	} else if (!strncasecomp(buffer, "LYNXCGI_DOCUMENT_ROOT:", 22)) {
	    StrAllocCopy(LYCgiDocumentRoot, buffer+22);
#endif /* !VMS */
#endif /* LYNXCGI_LINKS */

	} else if (!strncasecomp(buffer, "LYNX_HOST_NAME:", 15)) {
	    StrAllocCopy(LYHostName, buffer+15);

	} else if (!strncasecomp(buffer, "LYNX_SIG_FILE:", 14)) {
	    strcpy(temp, (buffer+14));
	    if (LYPathOffHomeOK(temp, 256)) {
		StrAllocCopy(LynxSigFile, temp);
		LYAddPathToHome(temp, 256, LynxSigFile);
		StrAllocCopy(LynxSigFile, temp);
		if (TRACE)
		    fprintf(stderr,
			    "LYNX_SIG_FILE set to '%s'\n", LynxSigFile);
	    } else {
		if (TRACE)
		    fprintf(stderr, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n",
				    LYNX_SIG_FILE);
	    }
	}
	break;
d923 1
a923 3
	case 'M':
	if (!strncasecomp(buffer, "MAIL_SYSTEM_ERROR_LOGGING:", 26)) {
	    error_logging = is_true(buffer+26);
d925 14
a938 22
#ifdef VMS
	} else if (!strncasecomp(buffer, "MAIL_ADRS:", 10)) {
	    StrAllocCopy(mail_adrs, buffer+10);
#endif /* VMS */

	} else if (!strncasecomp(buffer, "MAKE_LINKS_FOR_ALL_IMAGES:", 26)) {
	    clickable_images = is_true(buffer+26);

	} else if (!strncasecomp(buffer,
				 "MAKE_PSEUDO_ALTS_FOR_INLINES:", 29)) {
	    pseudo_inline_alts = is_true(buffer+29);

	} else if (!strncasecomp(buffer, "MESSAGESECS:", 12)) {
	    strcpy(temp, buffer+12);
	    for (i = 0; temp[i]; i++) {
		if (!isdigit(temp[i])) {
		    temp[i] = '\0';
		    break;
		}
	    }
	    if (temp[0])
		MessageSecs = atoi(temp);
d940 14
a953 2
	} else if (!strncasecomp(buffer, "MINIMAL_COMMENTS:", 17)) {
	    minimal_comments = is_true(buffer+17);
a954 4
	} else if (!strncasecomp(buffer, "MULTI_BOOKMARK_SUPPORT:", 23)) {
	    LYMultiBookmarks = is_true(buffer+23);
	}
	break;
d956 2
a957 10
	case 'N':
	if (!strncasecomp(buffer, "NEWS_CHUNK_SIZE:", 16)) {
		HTNewsChunkSize = atoi(buffer+16);
		/*
		 * If the new HTNewsChunkSize exceeds the maximum,
		 * increase HTNewsMaxChunk to this size. - FM
		 */
		if (HTNewsChunkSize > HTNewsMaxChunk) {
		    HTNewsMaxChunk = HTNewsChunkSize;
		}
d959 1
a959 9
	} else if (!strncasecomp(buffer, "NEWS_MAX_CHUNK:", 15)) {
		HTNewsMaxChunk = atoi(buffer+15);
		/*
		 * If HTNewsChunkSize exceeds the new maximum,
		 * reduce HTNewsChunkSize to this maximum. - FM
		 */
		if (HTNewsChunkSize > HTNewsMaxChunk) {
		    HTNewsChunkSize = HTNewsMaxChunk;
		}
a960 3
	} else if (!strncasecomp(buffer, "NEWS_POSTING:", 13)) {
	    LYNewsPosting = is_true(buffer+13);
	    no_newspost = (LYNewsPosting == FALSE);
d962 32
a993 2
	} else if (!strncasecomp(buffer, "news_proxy:", 11)) {
	    if (getenv("news_proxy") == NULL) {
d995 57
a1051 9
		strcpy(temp, "news_proxy");
		Define_VMSLogical(temp, (char *)&buffer[11]);
#else
		strcpy(temp, "news_proxy=");
		StrAllocCopy(news_proxy_putenv_cmd, temp);
		StrAllocCat(news_proxy_putenv_cmd, (char *)&buffer[11]);
		putenv(news_proxy_putenv_cmd);
#endif /* VMS */
	    }
d1053 33
a1085 2
	} else if (!strncasecomp(buffer, "newspost_proxy:", 15)) {
	    if (getenv("newspost_proxy") == NULL) {
d1087 95
a1181 9
		strcpy(temp, "newspost_proxy");
		Define_VMSLogical(temp, (char *)&buffer[15]);
#else
		strcpy(temp, "newspost_proxy=");
		StrAllocCopy(newspost_proxy_putenv_cmd, temp);
		StrAllocCat(newspost_proxy_putenv_cmd, (char *)&buffer[15]);
		putenv(newspost_proxy_putenv_cmd);
#endif /* VMS */
	    }
d1183 6
a1188 12
	} else if (!strncasecomp(buffer, "newsreply_proxy:", 16)) {
	    if (getenv("newsreply_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "newsreply_proxy");
		Define_VMSLogical(temp, (char *)&buffer[16]);
#else
		strcpy(temp, "newsreply_proxy=");
		StrAllocCopy(newsreply_proxy_putenv_cmd, temp);
		StrAllocCat(newsreply_proxy_putenv_cmd, (char *)&buffer[16]);
		putenv(newsreply_proxy_putenv_cmd);
#endif /* VMS */
	    }
d1190 3
a1192 5
	} else if (!strncasecomp(buffer, "nntp_proxy:", 11)) {
	    if (getenv("nntp_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "nntp_proxy");
		Define_VMSLogical(temp, (char *)&buffer[11]);
d1194 9
a1202 9
		strcpy(temp, "nntp_proxy=");
		StrAllocCopy(nntp_proxy_putenv_cmd, temp);
		StrAllocCat(nntp_proxy_putenv_cmd, (char *)&buffer[11]);
		putenv(nntp_proxy_putenv_cmd);
#endif /* VMS */
	    }

	} else if (!strncasecomp(buffer, "NNTPSERVER:", 11)) {
	    if (getenv("NNTPSERVER") == NULL) {
d1204 1
a1204 2
		strcpy(temp, "NNTPSERVER");
		Define_VMSLogical(temp, (char *)&buffer[11]);
d1206 13
a1218 5
		strcpy(temp, "NNTPSERVER=");
		StrAllocCopy(NNTPSERVER_putenv_cmd, temp);
		StrAllocCat(NNTPSERVER_putenv_cmd, (char *)&buffer[11]);
		putenv(NNTPSERVER_putenv_cmd);
#endif /* VMS */
d1220 8
d1229 5
a1233 2
	} else if (!strncasecomp(buffer, "NO_DOT_FILES:", 13)) {
	    no_dotfiles = is_true(buffer+13);
d1235 2
a1236 2
	} else if (!strncasecomp(buffer, "NO_FILE_REFERER:", 16)) {
	    no_filereferer = is_true(buffer+16);
d1238 3
a1240 4
#ifndef VMS
	} else if (!strncasecomp(buffer, "NO_FORCED_CORE_DUMP:", 20)) {
	    LYNoCore = is_true(buffer+20);
#endif /* !VMS */
d1242 4
a1245 2
	} else if (!strncasecomp(buffer, "NO_FROM_HEADER:", 15)) {
	    LYNoFromHeader = is_true(buffer+15);
d1247 10
a1256 2
	} else if (!strncasecomp(buffer, "NO_ISMAP_IF_USEMAP:", 19)) {
	    LYNoISMAPifUSEMAP = is_true(buffer+19);
a1257 12
	} else if (!strncasecomp(buffer, "no_proxy:", 9)) {
	    if (getenv("no_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "no_proxy");
		Define_VMSLogical(temp, (char *)&buffer[9]);
#else
		strcpy(temp, "no_proxy=");
		StrAllocCopy(no_proxy_putenv_cmd, temp);
		StrAllocCat(no_proxy_putenv_cmd, (char *)&buffer[9]);
		putenv(no_proxy_putenv_cmd);
#endif /* VMS */
	    }
d1259 17
a1275 4
	} else if (!strncasecomp(buffer, "NO_REFERER_HEADER:", 18)) {
	    LYNoRefererHeader = is_true(buffer+18);
	}
	break;
d1277 1
a1277 3
	case 'P':
	if (!strncasecomp(buffer, "PERSONAL_MAILCAP:", 17)) {
	    StrAllocCopy(personal_type_map, buffer+17);
d1279 29
a1307 2
	} else if (!strncasecomp(buffer, "PERSONAL_EXTENSION_MAP:", 23)) {
	    StrAllocCopy(personal_extension_map, buffer+23);
d1309 12
a1320 2
	} else if (!strncasecomp(buffer, "PREFERRED_CHARSET:", 18)) {
	    StrAllocCopy(pref_charset, buffer+18);
d1322 4
a1325 2
	} else if (!strncasecomp(buffer, "PREFERRED_LANGUAGE:", 19)) {
	    StrAllocCopy(language, buffer+19);
d1327 2
a1328 2
	} else if (!strncasecomp(buffer, "PREPEND_BASE_TO_SOURCE:", 23)) {
	    LYPrependBaseToSource = is_true(buffer+23);
d1330 1
a1330 2
	} else if (!strncasecomp(buffer, "PREPEND_CHARSET_TO_SOURCE:", 26)) {
	    LYPrependCharsetToSource = is_true(buffer+26);
d1332 6
a1337 2
	} else if (!strncasecomp(buffer, "PRINTER:", 8)) {
	    add_printer_to_list(&buffer[8], &printers);
a1338 1
	break;
d1340 16
a1355 4
#ifdef RAWDOSKEYHACK
	case 'R':
	if (!strncasecomp(buffer, "RAW_DOS_KEY_HACK:", 17)) {
	    raw_dos_key_hack = is_true(buffer+17);
a1356 2
	break;
#endif /* RAWDOSKEYHACK */
d1358 4
a1361 3
	case 'Q':
	if (!strncasecomp(buffer, "QUIT_DEFAULT_YES:", 17)) {
	    LYQuitDefaultYes = is_true(buffer+17);
a1362 1
	break;
d1364 7
a1370 3
	case 'S':
	if (!strncasecomp(buffer, "SAVE_SPACE:", 11)) {
	    StrAllocCopy(lynx_save_space, buffer+11);
d1372 2
a1373 2
	} else if (!strncasecomp(buffer, "SCAN_FOR_BURIED_NEWS_REFS:", 26)) {
	    scan_for_buried_news_references = is_true(buffer+26);
d1375 29
a1403 2
	} else if (!strncasecomp(buffer, "SEEK_FRAG_AREA_IN_CUR:", 22)) {
	    LYSeekFragAREAinCur = is_true(buffer+22);
d1405 4
a1408 2
	} else if (!strncasecomp(buffer, "SEEK_FRAG_MAP_IN_CUR:", 21)) {
	    LYSeekFragMAPinCur = is_true(buffer+21);
d1410 2
a1411 2
	} else if (!strncasecomp(buffer, "SET_COOKIES:", 12)) {
	    LYSetCookies = is_true(buffer+12);
d1413 4
a1416 2
	} else if (!strncasecomp(buffer, "SHOW_CURSOR:", 12)) {
	    LYShowCursor = is_true(buffer+12);
d1418 1
a1418 2
	} else if (!strncasecomp(buffer, "snews_proxy:", 12)) {
	    if (getenv("snews_proxy") == NULL) {
d1420 1
a1420 2
		strcpy(temp, "snews_proxy");
		Define_VMSLogical(temp, (char *)&buffer[12]);
d1422 5
a1426 5
		strcpy(temp, "snews_proxy=");
		StrAllocCopy(snews_proxy_putenv_cmd, temp);
		StrAllocCat(snews_proxy_putenv_cmd, (char *)&buffer[12]);
		putenv(snews_proxy_putenv_cmd);
#endif /* VMS */
d1428 1
d1430 18
a1447 11
	} else if (!strncasecomp(buffer, "snewspost_proxy:", 16)) {
	    if (getenv("snewspost_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "snewspost_proxy");
		Define_VMSLogical(temp, (char *)&buffer[16]);
#else
		strcpy(temp, "snewspost_proxy=");
		StrAllocCopy(snewspost_proxy_putenv_cmd, temp);
		StrAllocCat(snewspost_proxy_putenv_cmd, (char *)&buffer[16]);
		putenv(snewspost_proxy_putenv_cmd);
#endif /* VMS */
d1450 10
a1459 11
	} else if (!strncasecomp(buffer, "snewsreply_proxy:", 17)) {
	    if (getenv("snewsreply_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "snewsreply_proxy");
		Define_VMSLogical(temp, (char *)&buffer[17]);
#else
		strcpy(temp, "snewsreply_proxy=");
		StrAllocCopy(snewsreply_proxy_putenv_cmd, temp);
		StrAllocCat(snewsreply_proxy_putenv_cmd, (char *)&buffer[17]);
		putenv(snewsreply_proxy_putenv_cmd);
#endif /* VMS */
d1461 1
d1463 19
a1481 23
	} else if (!strncasecomp(buffer, "SOFT_DQUOTES:", 13)) {
	    soft_dquotes = is_true(buffer+13);

	} else if (!strncasecomp(buffer, "STARTFILE:", 10)) {
	    StrAllocCopy(startfile, buffer+10);

	} else if (!strncasecomp(buffer, "STRIP_DOTDOT_URLS:", 18)) {
	    LYStripDotDotURLs = is_true(buffer+18);

	} else if (!strncasecomp(buffer, "SUBSTITUTE_UNDERSCORES:", 23)) {
	    use_underscore = is_true(buffer+23);

	} else if (!strncasecomp(buffer, "SUFFIX:", 7)) {
	    char *extention;
	    char *mime_type;

	    if (strlen(buffer) > 9) {
		extention = buffer + 7;
		if ((mime_type = strchr(extention, ':')) != NULL) {
		    *mime_type++ = '\0';
		    for (i = 0, j = 0; mime_type[i]; i++) {
			if (mime_type[i] != ' ') {
			    mime_type[j++] = TOLOWER(mime_type[i]);
d1483 1
d1485 2
a1486 7
		    mime_type[j] = '\0';
		    if (strstr(mime_type, "tex") != NULL ||
			strstr(mime_type, "postscript") != NULL ||
			strstr(mime_type, "sh") != NULL ||
			strstr(mime_type, "troff") != NULL ||
			strstr(mime_type, "rtf") != NULL)
			HTSetSuffix(extention, mime_type, "8bit", 1.0);
d1488 14
a1501 1
			HTSetSuffix(extention, mime_type, "binary", 1.0);
d1505 23
a1527 3
	} else if (!strncasecomp(buffer, "SYSTEM_EDITOR:", 14)) {
	    StrAllocCopy(editor, buffer+14);
	    system_editor = TRUE;
d1529 9
a1537 14
	} else if (!strncasecomp(buffer, "SYSTEM_MAIL:", 12)) {
	    StrAllocCopy(system_mail, buffer+12);

	} else if (!strncasecomp(buffer, "SYSTEM_MAIL_FLAGS:", 18)) {
	    StrAllocCopy(system_mail_flags, buffer+18);
	}
	break;

	case 'T':
#ifdef EXEC_LINKS
	if (!strncasecomp(buffer, "TRUSTED_EXEC:", 13)) {
	    add_trusted(&buffer[13], EXEC_PATH); /* Add exec path */
	}
#endif /* EXEC_LINKS */
d1539 9
a1547 27
#ifdef LYNXCGI_LINKS
	if (!strncasecomp(buffer, "TRUSTED_LYNXCGI:", 16)) {
	    add_trusted(&buffer[16], CGI_PATH); /* Add CGI path */
	}
#endif /* LYNXCGI_LINKS */
	break;

	case 'U':
	if (!strncasecomp(buffer, "URL_DOMAIN_PREFIXES:", 20)) {
	    StrAllocCopy(URLDomainPrefixes, buffer+20);

	} else if (!strncasecomp(buffer, "URL_DOMAIN_SUFFIXES:", 20)) {
	    StrAllocCopy(URLDomainSuffixes, buffer+20);

#ifdef DIRED_SUPPORT
	} else if (!strncasecomp(buffer, "UPLOADER:", 9)) {
	    add_item_to_list(&buffer[9], &uploaders);
#endif /* DIRED_SUPPORT */

#ifdef VMS
	} else if (!strncasecomp(buffer, "USE_FIXED_RECORDS:", 18)) {
	    UseFixedRecords = is_true(buffer+18);
#endif /* VMS */

#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
	} else if(!strncasecomp(buffer, "USE_MOUSE:",10)) {
		LYUseMouse = is_true(buffer+10);
d1549 10
a1558 54

	} else if (!strncasecomp(buffer, "USE_SELECT_POPUPS:", 18)) {
	    LYSelectPopups = is_true(buffer+18);
	}
	break;

	case 'V':
	if (!strncasecomp(buffer, "VI_KEYS_ALWAYS_ON:", 18)) {
	    vi_keys = is_true(buffer+18);

	} else if (!strncasecomp(buffer, "VIEWER:", 7)) {
	    char *mime_type;
	    char *viewer;
	    char *environment;

	    if (strlen(buffer) > 9) {
		mime_type = buffer + 7;
		if ((viewer = strchr(mime_type, ':')) != NULL) {
		    *viewer++ = '\0';
		    for (i = 0, j = 0; mime_type[i]; i++) {
			if (mime_type[i] != ' ') {
			    mime_type[j++] = TOLOWER(mime_type[i]);
			}
		    }
		    mime_type[j] = '\0';
		    environment = strrchr(viewer, ':');
		    if ((environment != NULL) &&
			(strlen(viewer) > 1) && *(environment-1) != '\\') {
			*environment++ = '\0';
			remove_backslashes(viewer);
			/*
			 *  If environment equals xwindows then only
			 *  assign the presentation if there is a display
			 *  variable.
			 */
			if (!strcasecomp(environment,"XWINDOWS")) {
			    if ((cp = getenv(DISPLAY)) != NULL &&
				*cp != '\0')
				HTSetPresentation(mime_type, viewer,
						  1.0, 3.0, 0.0, 0);
			} else if (!strcasecomp(environment,"NON_XWINDOWS")) {
			    if ((cp = getenv(DISPLAY)) == NULL ||
				*cp == '\0')
				HTSetPresentation(mime_type, viewer,
						  1.0, 3.0, 0.0, 0);
			} else {
			    HTSetPresentation(mime_type, viewer,
						  1.0, 3.0, 0.0, 0);
			}
		    } else {
			remove_backslashes(viewer);
			HTSetPresentation(mime_type, viewer,
						  1.0, 3.0, 0.0, 0);
		    }
d1561 1
d1563 1
a1563 1
	break;
d1565 1
a1565 28
	case 'W':
	if (!strncasecomp(buffer, "wais_proxy:", 11)) {
	    if (getenv("wais_proxy") == NULL) {
#ifdef VMS
		strcpy(temp, "wais_proxy");
		Define_VMSLogical(temp, (char *)&buffer[11]);
#else
		strcpy(temp, "wais_proxy=");
		StrAllocCopy(wais_proxy_putenv_cmd, temp);
		StrAllocCat(wais_proxy_putenv_cmd, (char *)&buffer[11]);
		putenv(wais_proxy_putenv_cmd);
#endif /* VMS */
	    }
	}
	break;

	case 'X':
	if (!strncasecomp(buffer, "XLOADIMAGE_COMMAND:", 19)) {
	    StrAllocCopy(XLoadImageCommand, (char *)&buffer[19]);
	}
	break;

	default:
	break;

	}  /* end of Huge switch */
    } /* end of while */
    fclose(fp);
d1573 1
a1573 2
    if (downloaders != NULL) {
	int count;
d1576 2
a1577 3
	for (count = 0, cur_download = downloaders;
	     cur_download != NULL;
	     cur_download = cur_download->next, count++) {
d1582 1
d1585 278
d1864 1
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
