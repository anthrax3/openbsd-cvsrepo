head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.09;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.53;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.53;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYList.c,v 1.53 2013/10/03 07:46:14 tom Exp $
 *
 *			Lynx Document Reference List Support	      LYList.c
 *			====================================
 *
 *	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
 *
 */

#include <HTUtils.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <GridText.h>
#include <HTParse.h>
#include <LYList.h>
#include <LYMap.h>
#include <LYClean.h>
#include <LYGlobalDefs.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>
#include <LYStrings.h>
#include <LYHistory.h>

#ifdef DIRED_SUPPORT
#include <LYUpload.h>
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */

#include <LYexit.h>
#include <LYLeaks.h>

/*	showlist - F.Macrides (macrides@@sci.wfeb.edu)
 *	--------
 *	Create a temporary text/html file with a list of links to
 *	HyperText References in the current document.
 *
 *  On entry
 *	titles		Set:	if we want titles where available
 *			Clear:	we only get addresses.
 */

int showlist(DocInfo *newdoc, int titles)
{
    int cnt;
    int refs, hidden_links;
    int result;
    static char tempfile[LY_MAXPATH];
    static BOOLEAN last_titles = TRUE;
    FILE *fp0;
    char *Address = NULL, *Title = NULL, *cp = NULL;
    char *LinkTitle = NULL;	/* Rel stored as property of link, not of dest */
    BOOLEAN intern_w_post = FALSE;
    const char *desc = "unknown field or link";
    void *helper;

    refs = HText_sourceAnchors(HTMainText);
    hidden_links = HText_HiddenLinkCount(HTMainText);
    if (refs <= 0 && hidden_links > 0 &&
	LYHiddenLinks != HIDDENLINKS_SEPARATE) {
	HTUserMsg(NO_VISIBLE_REFS_FROM_DOC);
	return (-1);
    }
    if (refs <= 0 && hidden_links <= 0) {
	HTUserMsg(NO_REFS_FROM_DOC);
	return (-1);
    }

    if ((fp0 = InternalPageFP(tempfile, titles == last_titles)) == 0)
	return (-1);

    LYLocalFileToURL(&(newdoc->address), tempfile);

    LYRegisterUIPage(newdoc->address,
		     titles ? UIP_LIST_PAGE : UIP_ADDRLIST_PAGE);
    last_titles = (BOOLEAN) titles;
    LYforce_HTML_mode = TRUE;	/* force this file to be HTML */
    LYforce_no_cache = TRUE;	/* force this file to be new */

#ifdef USE_ADDRLIST_PAGE
    if (titles != TRUE)
	BeginInternalPage(fp0, ADDRLIST_PAGE_TITLE, LIST_PAGE_HELP);
    else
#endif
	BeginInternalPage(fp0, LIST_PAGE_TITLE, LIST_PAGE_HELP);

    StrAllocCopy(Address, HTLoadedDocumentURL());
    LYEntify(&Address, FALSE);
    fprintf(fp0, "%s%s<p>\n", gettext("References in "),
	    (non_empty(Address)
	     ? Address
	     : gettext("this document:")));
    FREE(Address);
    if (refs > 0) {
	fprintf(fp0, "<%s compact>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
					"ol" : "ul"));
	if (hidden_links > 0)
	    fprintf(fp0, "<lh><em>%s</em>\n", gettext("Visible links:"));
    }
    if (hidden_links > 0) {
	if (LYHiddenLinks == HIDDENLINKS_IGNORE)
	    hidden_links = 0;
    }
    helper = NULL;		/* init */
    result = 1;
    for (cnt = 1; cnt <= refs; cnt++) {
	HTChildAnchor *child = HText_childNextNumber(cnt, &helper);
	int value = HText_findAnchorNumber(helper);
	HTAnchor *dest_intl = NULL;
	HTAnchor *dest;
	HTParentAnchor *parent;
	char *address;
	const char *title;

	if (child == 0) {
	    /*
	     * child should not be 0 unless form field numbering is on and cnt
	     * is the number of a form input field.  HText_FormDescNumber()
	     * will set desc to a description of what type of input field this
	     * is.  We'll list it to ensure that the link numbers on the list
	     * page match the numbering in the original document, but won't
	     * create a forward link to the form.  - FM && LE
	     *
	     * Changed to create a fake hidden link, to get the numbering right
	     * in connection with always treating this file as
	     * HIDDENLINKS_MERGE in GridText.c - kw
	     */
	    if (fields_are_numbered()) {
		HText_FormDescNumber(cnt, &desc);
		fprintf(fp0,
			"<li><a id=%d href=\"#%d\">form field</a> = <em>%s</em>\n",
			cnt, cnt, desc);
	    }
	} else if (value >= result) {
	    if (track_internal_links)
		dest_intl = HTAnchor_followTypedLink(child, HTInternalLink);
	    dest = (dest_intl
		    ? dest_intl
		    : HTAnchor_followLink(child));
	    parent = HTAnchor_parent(dest);
	    if (!intern_w_post && dest_intl &&
		HTMainAnchor &&
		HTMainAnchor->post_data &&
		parent->post_data &&
		BINEQ(HTMainAnchor->post_data, parent->post_data)) {
		/*
		 * Set flag to note that we had at least one internal link, if
		 * the document from which we are generating the list has
		 * associated POST data; after an extra check that the link
		 * destination really has the same POST data so that we can
		 * believe it is an internal link.
		 */
		intern_w_post = TRUE;
	    }
	    address = HTAnchor_address(dest);
	    title = titles ? HTAnchor_title(parent) : NULL;
	    if (dest_intl) {
		HTSprintf0(&LinkTitle, "(internal)");
	    } else if (titles && child->type &&
		       dest == child->dest &&
		       !StrNCmp(HTAtom_name(child->type),
				"RelTitle: ", 10)) {
		HTSprintf0(&LinkTitle, "(%s)", HTAtom_name(child->type) + 10);
	    } else {
		FREE(LinkTitle);
	    }
	    StrAllocCopy(Address, address);
	    FREE(address);
	    LYEntify(&Address, TRUE);
	    if (non_empty(title)) {
		LYformTitle(&Title, title);
		LYEntify(&Title, TRUE);
		if (*Title) {
		    cp = findPoundSelector(Address);
		} else {
		    FREE(Title);
		}
	    }

	    fprintf(fp0, "<li><a href=\"%s\"%s>%s%s%s%s%s</a>\n", Address,
		    dest_intl ? " TYPE=\"internal link\"" : "",
		    NonNull(LinkTitle),
		    ((HTAnchor *) parent != dest) && Title ? "in " : "",
		    (char *) (Title ? Title : Address),
		    (Title && cp) ? " - " : "",
		    (Title && cp) ? (cp + 1) : "");

	    FREE(Address);
	    FREE(Title);
	}
	result = value + 1;
    }
    FREE(LinkTitle);

    if (hidden_links > 0) {
	if (refs > 0)
	    fprintf(fp0, "\n</%s>\n\n<p>\n",
		    ((keypad_mode == NUMBERS_AS_ARROWS) ?
		     "ol" : "ul"));
	fprintf(fp0, "<%s compact>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
					"ol continue" : "ul"));
	fprintf(fp0, "<lh><em>%s</em>\n", gettext("Hidden links:"));
    }

    for (cnt = 0; cnt < hidden_links; cnt++) {
	StrAllocCopy(Address, HText_HiddenLinkAt(HTMainText, cnt));
	LYEntify(&Address, FALSE);
	if (isEmpty(Address)) {
	    FREE(Address);
	    continue;
	}
	fprintf(fp0, "<li><a href=\"%s\">%s</a>\n", Address, Address);

	FREE(Address);
    }

    fprintf(fp0, "\n</%s>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
			       "ol" : "ul"));
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);

    /*
     * Make necessary changes to newdoc before returning to caller.  If the
     * intern_w_post flag is set, we keep the POST data in newdoc that have
     * been passed in.  They should be the same as in the loaded document for
     * which we generated the list.  In that case the file we have written will
     * be associated with the same POST data when it is loaded after we are
     * done here, so that following one of the links we have marked as
     * "internal link" can lead back to the underlying document with the right
     * address+post_data combination.  - kw
     */
    if (intern_w_post) {
	newdoc->internal_link = TRUE;
    } else {
	LYFreePostData(newdoc);
	newdoc->internal_link = FALSE;
    }
    newdoc->isHEAD = FALSE;
    newdoc->safe = FALSE;
    return (0);
}

static int print_refs(FILE *fp, int titles, int refs)
{
    int result = 0;
    int cnt;
    int value;
    char *address = NULL;
    const char *desc = gettext("unknown field or link");
    void *helper = NULL;	/* init */

    for (cnt = 1; cnt <= refs; cnt++) {
	HTChildAnchor *child = HText_childNextNumber(cnt, &helper);
	HTAnchor *dest;
	HTParentAnchor *parent;
	const char *title;
	int counter = result + 1;

	if (child == 0) {
	    /*
	     * child should not be 0 unless form field numbering is on and
	     * cnt is the number of a form input field. 
	     * HText_FormDescNumber() will set desc to a description of
	     * what type of input field this is.  We'll create a
	     * within-document link to ensure that the link numbers on the
	     * list page match the numbering in the original document, but
	     * won't create a forward link to the form.  - FM && LE
	     */
	    if (fields_are_numbered()) {
		HText_FormDescNumber(cnt, &desc);
		fprintf(fp, "%4d. form field = %s\n", counter, desc);
	    }
	} else {
	    dest = HTAnchor_followLink(child);
	    /*
	     * Ignore if child anchor points to itself, i.e., we had something
	     * like <A NAME=xyz HREF="#xyz"> and it is not treated as a hidden
	     * link.  Useful if someone 'P'rints the List Page (which isn't a
	     * very useful action to do, but anyway...) - kw
	     */
	    if (dest != (HTAnchor *) child) {
		parent = HTAnchor_parent(dest);
		title = titles ? HTAnchor_title(parent) : NULL;
		if (links_are_numbered()) {
		    value = HText_findAnchorNumber(helper);
		    if (value <= result)
			continue;
		    fprintf(fp, "%4d. ", value);
		}
		if (((HTAnchor *) parent != dest) && title) {
		    fprintf(fp, "in ");
		}
		if (title) {
		    fprintf(fp, "%s\n", title);
		} else {
		    address = HTAnchor_short_address(dest);
		    if (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
			(void) HTUnEscape(address);
		    }
		    fprintf(fp, "%s\n", address);
		    FREE(address);
		}
	    }
	}
	if (counter > result)
	    result = counter;
#ifdef VMS
	if (HadVMSInterrupt)
	    break;
#endif /* VMS */
    }
    return result;
}

static void print_hidden_refs(FILE *fp, int refs, int hidden_links)
{
    int cnt;
    char *address = NULL;

    fprintf(fp, "%s   %s\n", ((refs > 0) ? "\n" : ""),
	    gettext("Hidden links:"));
    for (cnt = 0; cnt < hidden_links; cnt++) {
	StrAllocCopy(address, HText_HiddenLinkAt(HTMainText, cnt));
	if (isEmpty(address)) {
	    FREE(address);
	    continue;
	}

	if (links_are_numbered())
	    fprintf(fp, "%4d. ", ((cnt + 1) + refs));
	fprintf(fp, "%s\n", address);
	FREE(address);
#ifdef VMS
	if (HadVMSInterrupt)
	    break;
#endif /* VMS */
    }
}

/*	printlist - F.Macrides (macrides@@sci.wfeb.edu)
 *	---------
 *	Print a text/plain list of HyperText References
 *	in the current document.
 *
 *  On entry
 *	titles		Set:	if we want titles where available
 *			Clear:	we only get addresses.
 */
void printlist(FILE *fp, int titles)
{
    int refs, hidden_links;

    refs = HText_sourceAnchors(HTMainText);
    if (refs > 0 || LYHiddenLinks == HIDDENLINKS_SEPARATE) {
	hidden_links = HText_HiddenLinkCount(HTMainText);
	if (refs > 0 || hidden_links > 0) {
	    if (links_are_numbered() || fields_are_numbered())
		fprintf(fp, "\n%s\n\n", gettext("References"));
	    if (LYHiddenLinks == HIDDENLINKS_IGNORE)
		hidden_links = 0;
	    if (hidden_links > 0) {
		fprintf(fp, "   %s\n", gettext("Visible links"));
	    }
	    refs = print_refs(fp, titles, refs) + 1;

	    if (hidden_links > 0) {
		print_hidden_refs(fp, refs, hidden_links);
	    }
	}
    }
    LYPrintImgMaps(fp);
    return;
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 4
a4 1
/*			Lynx Document Reference List Support	      LYList.c
d15 1
d43 1
a43 1
int showlist(DocInfo *newdoc, BOOLEAN titles)
d47 1
d76 1
a76 1
    last_titles = titles;
d80 1
a80 1
#ifdef EXP_ADDRLIST_PAGE
d105 1
d108 1
d134 30
a163 42
	    continue;
	}
#ifndef DONT_TRACK_INTERNAL_LINKS
	dest_intl = HTAnchor_followTypedLink(child, HTInternalLink);
#endif
	dest = dest_intl ?
	    dest_intl : HTAnchor_followLink(child);
	parent = HTAnchor_parent(dest);
	if (!intern_w_post && dest_intl &&
	    HTMainAnchor &&
	    HTMainAnchor->post_data &&
	    parent->post_data &&
	    BINEQ(HTMainAnchor->post_data, parent->post_data)) {
	    /*
	     * Set flag to note that we had at least one internal link, if the
	     * document from which we are generating the list has associated
	     * POST data; after an extra check that the link destination really
	     * has the same POST data so that we can believe it is an internal
	     * link.
	     */
	    intern_w_post = TRUE;
	}
	address = HTAnchor_address(dest);
	title = titles ? HTAnchor_title(parent) : NULL;
	if (dest_intl) {
	    HTSprintf0(&LinkTitle, "(internal)");
	} else if (titles && child->type &&
		   dest == child->dest &&
		   !strncmp(HTAtom_name(child->type),
			    "RelTitle: ", 10)) {
	    HTSprintf0(&LinkTitle, "(%s)", HTAtom_name(child->type) + 10);
	} else {
	    FREE(LinkTitle);
	}
	StrAllocCopy(Address, address);
	FREE(address);
	LYEntify(&Address, TRUE);
	if (non_empty(title)) {
	    LYformTitle(&Title, title);
	    LYEntify(&Title, TRUE);
	    if (*Title) {
		cp = findPoundSelector(Address);
d165 13
a177 1
		FREE(Title);
a178 1
	}
d180 7
a186 7
	fprintf(fp0, "<li><a href=\"%s\"%s>%s%s%s%s%s</a>\n", Address,
		dest_intl ? " TYPE=\"internal link\"" : "",
		NonNull(LinkTitle),
		((HTAnchor *) parent != dest) && Title ? "in " : "",
		(char *) (Title ? Title : Address),
		(Title && cp) ? " - " : "",
		(Title && cp) ? (cp + 1) : "");
d188 4
a191 2
	FREE(Address);
	FREE(Title);
d243 1
a243 1
static void print_refs(FILE *fp, BOOLEAN titles, int refs)
d245 1
d247 1
d257 1
d271 32
a302 1
		fprintf(fp, "%4d. form field = %s\n", cnt, desc);
a303 1
	    continue;
d305 2
a306 18
	dest = HTAnchor_followLink(child);
	/*
	 * Ignore if child anchor points to itself, i.e., we had something
	 * like <A NAME=xyz HREF="#xyz"> and it is not treated as a hidden
	 * link.  Useful if someone 'P'rints the List Page (which isn't a
	 * very useful action to do, but anyway...) - kw
	 */
	if (dest == (HTAnchor *) child)
	    continue;
	parent = HTAnchor_parent(dest);
	title = titles ? HTAnchor_title(parent) : NULL;
	address = HTAnchor_address(dest);
	if (links_are_numbered())
	    fprintf(fp, "%4d. ", cnt);
	fprintf(fp, "%s%s\n",
		((HTAnchor *) parent != dest) && title ? "in " : "",
		(title ? title : address));
	FREE(address);
d312 1
d349 1
a349 1
void printlist(FILE *fp, BOOLEAN titles)
d364 1
a364 1
	    print_refs(fp, titles, refs);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d276 3
a278 1
	fprintf(fp, "%4d. %s%s\n", cnt,
d302 4
a305 1
	fprintf(fp, "%4d. %s\n", ((cnt + 1) + refs), address);
d331 2
a332 1
	    fprintf(fp, "\n%s\n\n", gettext("References"));
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 5
a6 5
**			====================================
**
**	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
**
*/
d13 1
d18 1
d30 8
a37 8
**	--------
**	Create a temporary text/html file with a list of links to
**	HyperText References in the current document.
**
**  On entry
**	titles		Set:	if we want titles where available
**			Clear:	we only get addresses.
*/
d39 1
a39 4

PUBLIC int showlist ARGS2(
	DocInfo *,	newdoc,
	BOOLEAN,	titles)
d47 1
a47 1
    char *LinkTitle = NULL;  /* Rel stored as property of link, not of dest */
d49 2
a50 2
    char *desc = "unknown field or link";
    void* helper;
d57 1
a57 1
	return(-1);
d61 1
a61 1
	return(-1);
d65 1
a65 1
	return(-1);
d80 1
a80 1
    BeginInternalPage(fp0, LIST_PAGE_TITLE, LIST_PAGE_HELP);
d85 3
a87 1
	((Address != NULL && *Address != '\0') ? Address : gettext("this document:")));
d91 1
a91 1
				       "ol" : "ul"));
d99 1
a99 1
    helper = NULL; /* init */
d106 1
a106 1
	CONST char *title;
d110 6
a115 7
	     *	child should not be 0 unless form field numbering is on
	     *	and cnt is the number of a form input field.
	     *	HText_FormDescNumber() will set desc to a description
	     *	of what type of input field this is.  We'll list it to
	     *	ensure that the link numbers on the list page match the
	     *	numbering in the original document, but won't create a
	     *	forward link to the form. - FM && LE
d117 3
a119 3
	     *	Changed to create a fake hidden link, to get the numbering
	     *	right in connection with always treating this file as
	     *	HIDDENLINKS_MERGE in GridText.c - kw
d122 1
a122 1
		HText_FormDescNumber(cnt, (char **)&desc);
d124 1
a124 1
		"<li><a id=%d href=\"#%d\">form field</a> = <em>%s</em>\n",
d141 5
a145 5
	     *	Set flag to note that we had at least one internal link,
	     *	if the document from which we are generating the list
	     *	has associated POST data; after an extra check that the
	     *	link destination really has the same POST data so that
	     *	we can believe it is an internal link.
d149 1
a149 1
	address =  HTAnchor_address(dest);
d157 1
a157 1
	    HTSprintf0(&LinkTitle, "(%s)", HTAtom_name(child->type)+10);
d164 1
a164 1
	if (title && *title) {
d175 6
a180 6
			dest_intl ? " TYPE=\"internal link\"" : "",
			NonNull(LinkTitle),
			((HTAnchor*)parent != dest) && Title ? "in " : "",
			(char *)(Title ? Title : Address),
			(Title && cp) ? " - " : "",
			(Title && cp) ? (cp+1) : "");
d190 2
a191 2
			 ((keypad_mode == NUMBERS_AS_ARROWS) ?
							"ol" : "ul"));
d200 1
a200 1
	if (!(Address && *Address)) {
d209 2
a210 2
    fprintf(fp0,"\n</%s>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
			     "ol" : "ul"));
d215 8
a222 9
     *	Make necessary changes to newdoc before returning to caller.
     *	If the intern_w_post flag is set, we keep the POST data in
     *	newdoc that have been passed in.  They should be the same as
     *	in the loaded document for which we generated the list.
     *	In that case the file we have written will be associated with
     *	the same POST data when it is loaded after we are done here,
     *	so that following one of the links we have marked as "internal
     *	link" can lead back to the underlying document with the right
     *	address+post_data combination. - kw
d232 1
a232 1
    return(0);
d235 1
a235 12
/*	printlist - F.Macrides (macrides@@sci.wfeb.edu)
**	---------
**	Print a text/plain list of HyperText References
**	in the current document.
**
**  On entry
**	titles		Set:	if we want titles where available
**			Clear:	we only get addresses.
*/
PUBLIC void printlist ARGS2(
	FILE *, 	fp,
	BOOLEAN,	titles)
a237 1
    int refs, hidden_links;
d239 2
a240 2
    char *desc = gettext("unknown field or link");
    void* helper;
d242 7
a248 37
    refs = HText_sourceAnchors(HTMainText);
    if (refs <= 0 && LYHiddenLinks != HIDDENLINKS_SEPARATE)
	return;
    hidden_links = HText_HiddenLinkCount(HTMainText);
    if (refs <= 0 && hidden_links <= 0) {
	return;
    } else {
	fprintf(fp, "\n%s\n\n", gettext("References"));
	if (hidden_links > 0) {
	    fprintf(fp, "   %s\n", gettext("Visible links"));
	    if (LYHiddenLinks == HIDDENLINKS_IGNORE)
		hidden_links = 0;
	}
       helper = NULL; /* init */
	for (cnt = 1; cnt <= refs; cnt++) {
	    HTChildAnchor *child = HText_childNextNumber(cnt, &helper);
	    HTAnchor *dest;
	    HTParentAnchor *parent;
	    CONST char *title;

	    if (child == 0) {
		/*
		 *  child should not be 0 unless form field numbering is on
		 *  and cnt is the number of a form input field.
		 *  HText_FormDescNumber() will set desc to a description
		 *  of what type of input field this is.  We'll create a
		 *  within-document link to ensure that the link numbers on
		 *  the list page match the numbering in the original document,
		 *  but won't create a forward link to the form. - FM && LE
		 */
		if (fields_are_numbered()) {
		    HText_FormDescNumber(cnt, (char **)&desc);
		    fprintf(fp, "%4d. form field = %s\n", cnt, desc);
		}
		continue;
	    }
	    dest = HTAnchor_followLink(child);
d250 7
a256 5
	     *	Ignore if child anchor points to itself, i.e., we had
	     *	something like <A NAME=xyz HREF="#xyz"> and it is not
	     *	treated as a hidden link.  Useful if someone 'P'rints
	     *	the List Page (which isn't a very useful action to do,
	     *	but anyway...) - kw
d258 22
a279 9
	    if (dest == (HTAnchor *)child)
		continue;
	    parent = HTAnchor_parent(dest);
	    title = titles ? HTAnchor_title(parent) : NULL;
	    address =  HTAnchor_address(dest);
	    fprintf(fp, "%4d. %s%s\n", cnt,
		    ((HTAnchor*)parent != dest) && title ? "in " : "",
		    (title ? title : address));
	    FREE(address);
d281 2
a282 2
	    if (HadVMSInterrupt)
		break;
d284 7
a290 1
	}
d292 5
a296 9
	if (hidden_links > 0)
	    fprintf(fp, "%s   %s\n", ((refs > 0) ? "\n" : ""), gettext("Hidden links:"));
	for (cnt = 0; cnt < hidden_links; cnt++) {
	    StrAllocCopy(address, HText_HiddenLinkAt(HTMainText, cnt));
	    if (!(address && *address)) {
		FREE(address);
		continue;
	    }
	    fprintf(fp, "%4d. %s\n", ((cnt + 1) + refs), address);
d298 4
d303 2
a304 2
	    if (HadVMSInterrupt)
		break;
d306 31
d339 1
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d17 1
d39 1
a39 1
	document *,	newdoc,
d51 1
d65 1
a65 8
    if (LYReuseTempfiles && titles == last_titles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
	HTUserMsg(CANNOT_OPEN_TEMP);
a66 1
    }
d98 1
d100 1
a100 1
	HTChildAnchor *child = HText_childNumber(cnt);
d121 1
a121 1
	    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d130 1
a130 2
	dest_intl = HTAnchor_followTypedLink((HTAnchor *)child,
						       LINK_INTERNAL);
d133 1
a133 1
	    dest_intl : HTAnchor_followMainLink((HTAnchor *)child);
d136 2
a137 1
	    HTMainAnchor && HTMainAnchor->post_data &&
d139 1
a139 1
	    !strcmp(HTMainAnchor->post_data, parent->post_data)) {
d153 3
a155 3
	} else if (titles && child->mainLink.type &&
		   dest == child->mainLink.dest &&
		   !strncmp(HTAtom_name(child->mainLink.type),
d157 1
a157 1
	    HTSprintf0(&LinkTitle, "(%s)", HTAtom_name(child->mainLink.type)+10);
d168 1
a168 1
		cp = strchr(Address, '#');
d176 1
a176 1
			LinkTitle ? LinkTitle : "",
d228 1
a228 2
	FREE(newdoc->post_data);
	FREE(newdoc->post_content_type);
d253 1
d268 1
d270 1
a270 1
	    HTChildAnchor *child = HText_childNumber(cnt);
d285 1
a285 1
		if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d291 1
a291 1
	    dest = HTAnchor_followMainLink((HTAnchor *)child);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d16 1
a35 11
static char *list_filename = 0;

/*
 *  Returns the name of the file used for the List Page, if one has
 *  been created, as a full URL; otherwise, returns an empty string.
 * - kw
 */
PUBLIC char * LYlist_temp_url NOARGS
{
    return list_filename ? list_filename : "";
}
d44 1
d63 7
a69 2
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
d74 1
a74 1
    LYLocalFileToURL(&list_filename, tempfile);
d76 3
a78 1
    StrAllocCopy(newdoc->address, list_filename);
d126 1
a126 1
	    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d170 1
a170 1
	    StrAllocCopy(Title, title);
d289 1
a289 1
		if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
@


1.1
log
@Initial revision
@
text
@d8 8
a15 8
#include "HTUtils.h"
#include "tcp.h"
#include "LYUtils.h"
#include "GridText.h"
#include "LYList.h"
#include "LYSignal.h"
#include "LYGlobalDefs.h"
#include "LYCharUtils.h"
d18 2
a19 2
#include "LYUpload.h"
#include "LYLocal.h"
d22 2
a23 4
#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d35 1
a35 1
static char list_filename[256] = "\0";
d44 1
a44 1
    return list_filename;
d53 1
a53 2
    static char tempfile[256];
    static BOOLEAN first = TRUE;
d56 1
d64 1
a64 2
	_statusline(NO_VISIBLE_REFS_FROM_DOC);
	sleep(MessageSecs);
d68 1
a68 2
	_statusline(NO_REFS_FROM_DOC);
	sleep(MessageSecs);
d72 4
a75 15
    if (first) {
	tempname(tempfile, NEW_FILE);
	/*
	 *  Make the file a URL now.
	 */
#if defined (VMS) || defined (DOSPATH)
	sprintf(list_filename, "file://localhost/%s", tempfile);
#else
	sprintf(list_filename, "file://localhost%s", tempfile);
#endif /* VMS */
	first = FALSE;
#ifdef VMS
    } else {
	remove(tempfile);  /* Remove duplicates on VMS. */
#endif /* VMS */
d78 1
a78 5
    if ((fp0 = LYNewTxtFile(tempfile)) == NULL) {
	_statusline(CANNOT_OPEN_TEMP);
	sleep(MessageSecs);
	return(-1);
    }
d84 6
a90 17
    fprintf(fp0, "<head>\n");
    LYAddMETAcharsetToFD(fp0, -1);
    if (strchr(HTLoadedDocumentURL(), '"') == NULL) {
	/*
	 *  Insert a BASE tag so there is some way to relate the List Page
	 *  file to its underlying document after we are done.	It won't
	 *  be actually used for resolving relative URLs. - kw
	 */
	StrAllocCopy(Address, HTLoadedDocumentURL());
	LYEntify(&Address, FALSE);
	fprintf(fp0, "<base href=\"%s\">\n", Address);
	FREE(Address);
    }
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n",
		 LIST_PAGE_TITLE);
    fprintf(fp0, "<h1>You have reached the List Page</h1>\n");
    fprintf(fp0, "<h2>%s Version %s</h2>\n", LYNX_NAME, LYNX_VERSION);
d93 2
a94 4
    fprintf(fp0,
	    "  References in %s<p>\n",
	    ((Address != NULL && *Address != '\0') ?
					   Address : "this document:"));
d100 1
a100 1
	    fprintf(fp0, "<lh><em>Visible links:</em>\n");
d150 2
a151 2
	     *	has assosiated POST data; after an extra check that the
	     *	link destination really has hthe same POST data so that
d158 10
d183 1
a183 1
			dest_intl ? "(internal) " : "",
d192 1
d201 1
a201 1
	fprintf(fp0, "<lh><em>Hidden links:</em>\n");
d216 4
a219 2
    fprintf(fp0,"\n</%s>\n</body>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
				       "ol" : "ul"));
d225 1
a225 1
     *	in the loaded locument for which we generated the list.
a240 1
    fclose(fp0);
a256 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;
#endif /* VMS */
d260 1
a260 1
    char *desc = "unknown field or link";
d269 1
a269 1
	fprintf(fp, "\n%s\n\n", "References");
d271 1
a271 1
	    fprintf(fp, "   Visible links:\n");
d284 1
a284 1
		 *  and cnt is the number of a form intput field.
d299 1
a299 1
	     *	Ignore if child anchor points to itself, i.e. we had
d321 1
a321 1
	    fprintf(fp, "%s   Hidden links:\n", ((refs > 0) ? "\n" : ""));
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
