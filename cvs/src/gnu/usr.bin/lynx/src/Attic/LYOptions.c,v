head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.14
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.12
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.10
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.8
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.04.24.03;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.11;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYOptions.c,v 1.164 2013/10/25 01:10:17 tom Exp $ */
#include <HTUtils.h>
#include <HTFTP.h>
#include <HTTP.h>		/* 'reloading' flag */
#include <HTML.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYGlobalDefs.h>
#include <LYHistory.h>
#include <LYOptions.h>
#include <LYSignal.h>
#include <LYClean.h>
#include <LYCharSets.h>
#include <UCMap.h>
#include <UCAux.h>
#include <LYKeymap.h>
#include <LYrcFile.h>
#include <HTAlert.h>
#include <LYBookmark.h>
#include <GridText.h>
#include <LYGetFile.h>
#include <LYReadCFG.h>
#include <LYPrettySrc.h>
#include <HTFile.h>
#include <LYCharUtils.h>

#ifdef USE_COLOR_STYLE
#include <LYStyle.h>
#endif

#include <LYLeaks.h>

BOOLEAN term_options;

#define TOP_LINK  "/"
#define MBM_LINK  "//MBM_MENU"

#define MARGIN_STR (no_margins ? "" : "&nbsp;&nbsp;")
#define MARGIN_LEN (no_margins ?  0 : 2)

static void terminate_options(int sig);

#define COL_OPTION_VALUES 36	/* display column where option values start */

#if defined(USE_SLANG) || defined(COLOR_CURSES)
static BOOLEAN can_do_colors = FALSE;
#endif

static int LYChosenShowColor = SHOW_COLOR_UNKNOWN;	/* whether to show and save */

BOOLEAN LYCheckUserAgent(void)
{
    if (non_empty(LYUserAgent)) {
	if (strstr(LYUserAgent, "Lynx") == 0
	    && strstr(LYUserAgent, "lynx") == 0
	    && strstr(LYUserAgent, "L_y_n_x") == 0
	    && strstr(LYUserAgent, "l_y_n_x") == 0) {
	    return FALSE;
	}
    }
    return TRUE;
}

static void validate_x_display(void)
{
    char *cp;

    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }
}

static void summarize_x_display(char *display_option)
{
    if ((x_display == NULL && *display_option == '\0') ||
	(x_display != NULL && !strcmp(x_display, display_option))) {
	if (x_display == NULL && LYisConfiguredForX == TRUE) {
	    _statusline(VALUE_ACCEPTED_WARNING_X);
	} else if (x_display != NULL && LYisConfiguredForX == FALSE) {
	    _statusline(VALUE_ACCEPTED_WARNING_NONX);
	} else {
	    _statusline(VALUE_ACCEPTED);
	}
    } else {
	if (*display_option) {
	    _statusline(FAILED_TO_SET_DISPLAY);
	} else {
	    _statusline(FAILED_CLEAR_SET_DISPLAY);
	}
    }
}

static void SetupChosenShowColor(void)
{
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = TRUE;
#if defined(COLOR_CURSES)
    if (LYCursesON)		/* could crash if called before initialization */
	can_do_colors = (has_colors()
			 ? TRUE
			 : FALSE);
#endif
    if (!no_option_save) {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
		    SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
		    SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */
}

#ifndef NO_OPTION_MENU
static int boolean_choice(int status,
			  int line,
			  int column,
			  STRING2PTR choices);

#define LYChooseBoolean(status, line, column, choices) \
	(BOOLEAN) boolean_choice(status, line, column, (const char *const*)choices)

#define LYChooseEnum(status, line, column, choices) \
	boolean_choice(status, line, column, (const char *const*)choices)

#define MAXCHOICES 10

/*
 * Values for the options menu.  - FM
 *
 * L_foo values are the Y coordinates for the menu item.
 * B_foo values are the X coordinates for the item's prompt string.
 * C_foo values are the X coordinates for the item's value string.
 */
#define L_EDITOR	 2
#define L_DISPLAY	 3

#define L_HOME		 4
#define C_MULTI		24
#define B_BOOK		34
#define C_DEFAULT	50

#define L_FTPSTYPE	 5
#define L_MAIL_ADDRESS	 6
#define L_SSEARCH	 7
#define L_LANGUAGE	 8
#define L_PREF_CHARSET	 9
#define L_ASSUME_CHARSET (L_PREF_CHARSET + 1)
#define L_CHARSET	10
#define L_RAWMODE	11

#define L_COLOR		L_RAWMODE
#define B_COLOR		44
#define C_COLOR		62

#define L_BOOL_A	12
#define B_VIKEYS	5
#define C_VIKEYS	15
#define B_EMACSKEYS	22
#define C_EMACSKEYS	36
#define B_SHOW_DOTFILES	44
#define C_SHOW_DOTFILES	62

#define L_BOOL_B	13
#define B_SELECT_POPUPS	5
#define C_SELECT_POPUPS	36
#define B_SHOW_CURSOR	44
#define C_SHOW_CURSOR	62

#define L_KEYPAD	14
#define L_LINEED	15
#define L_LAYOUT	16

#ifdef DIRED_SUPPORT
#define L_DIRED		17
#define L_USER_MODE	18
#define L_USER_AGENT	19
#define L_EXEC		20
#else
#define L_USER_MODE	17
#define L_USER_AGENT	18
#define L_EXEC		19
#endif /* DIRED_SUPPORT */

#define L_VERBOSE_IMAGES L_USER_MODE
#define B_VERBOSE_IMAGES 50
#define C_VERBOSE_IMAGES (B_VERBOSE_IMAGES + 21)

/* a kludge to add assume_charset only in ADVANCED mode... */
#define L_Bool_A     (use_assume_charset ? L_BOOL_A     + 1 : L_BOOL_A)
#define L_Bool_B     (use_assume_charset ? L_BOOL_B     + 1 : L_BOOL_B)
#define L_Exec       (use_assume_charset ? L_EXEC       + 1 : L_EXEC)
#define L_Rawmode    (use_assume_charset ? L_RAWMODE    + 1 : L_RAWMODE)
#define L_Charset    (use_assume_charset ? L_CHARSET    + 1 : L_CHARSET)
#define L_Color      (use_assume_charset ? L_COLOR      + 1 : L_COLOR)
#define L_Keypad     (use_assume_charset ? L_KEYPAD     + 1 : L_KEYPAD)
#define L_Lineed     (use_assume_charset ? L_LINEED     + 1 : L_LINEED)
#define L_Layout     (use_assume_charset ? L_LAYOUT     + 1 : L_LAYOUT)
#define L_Dired      (use_assume_charset ? L_DIRED      + 1 : L_DIRED)
#define L_User_Mode  (use_assume_charset ? L_USER_MODE  + 1 : L_USER_MODE)
#define L_User_Agent (use_assume_charset ? L_USER_AGENT + 1 : L_USER_AGENT)

#define LPAREN '('
#define RPAREN ')'

static int add_it(char *text, int len)
{
    if (len) {
	text[len] = '\0';
	LYaddstr(text);
    }
    return 0;
}

/*
 * addlbl() is used instead of plain LYaddstr() in old-style options menu
 * to show hot keys in bold.
 */
static void addlbl(const char *text)
{
    char actual[80];
    int s, d;
    BOOL b = FALSE;

    for (s = d = 0; text[s]; s++) {
	actual[d++] = text[s];
	if (text[s] == LPAREN) {
	    d = add_it(actual, d - 1);
	    lynx_start_bold();
	    b = TRUE;
	    actual[d++] = text[s];
	} else if (text[s] == RPAREN) {
	    d = add_it(actual, d);
	    lynx_stop_bold();
	    b = FALSE;
	}
    }
    add_it(actual, d);
    if (b)
	lynx_stop_bold();
}

#if !defined(VMS) || defined(USE_SLANG)
#define HANDLE_LYOPTIONS \
		    if (term_options) { \
			term_options = FALSE; \
		    } else { \
			AddValueAccepted = TRUE; \
		    } \
		    goto draw_options
#else
#define HANDLE_LYOPTIONS \
		    term_options = FALSE; \
		    if (use_assume_charset != old_use_assume_charset) \
			goto draw_options
#endif /* !VMS || USE_SLANG */

void LYoptions(void)
{
#define ShowBool(value) LYaddstr((value) ? "ON " : "OFF")
    static const char *bool_choices[] =
    {
	"OFF",
	"ON",
	NULL
    };
    static const char *const caseless_choices[] =
    {
	"CASE INSENSITIVE",
	"CASE SENSITIVE",
	NULL
    };

#ifdef DIRED_SUPPORT
    static const char *dirList_choices[] =
    {
	"Directories first",
	"Files first",
	"Mixed style",
	NULL
    };
#endif

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    static const char *exec_choices[] =
    {
	"ALWAYS OFF",
	"FOR LOCAL FILES ONLY",
#ifndef NEVER_ALLOW_REMOTE_EXEC
	"ALWAYS ON",
#endif				/* !NEVER_ALLOW_REMOTE_EXEC */
	NULL
    };
#endif
    static const char *fileSort_choices[] =
    {
	"By Filename",
	"By Type",
	"By Size",
	"By Date",
	NULL
    };
    static const char *keypad_choices[] =
    {
	"Numbers act as arrows",
	"Links are numbered",
	"Links and form fields are numbered",
	NULL
    };
    static const char *mbm_choices[] =
    {
	"OFF     ",
	"STANDARD",
	"ADVANCED",
	NULL
    };
    static const char *userMode_choices[] =
    {
	"Novice",
	"Intermediate",
	"Advanced",
	NULL
    };

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    int itmp;
#endif /* ENABLE_OPTS_CHANGE_EXEC */
    int response, ch;

    /*
     * If the user changes the display we need memory to put it in.
     */
    bstring *my_data = NULL;
    char *choices[MAXCHOICES];
    int CurrentCharSet = current_char_set;
    int CurrentAssumeCharSet = UCLYhndl_for_unspec;
    int CurrentShowColor = LYShowColor;
    BOOLEAN CurrentRawMode = LYRawMode;
    BOOLEAN AddValueAccepted = FALSE;
    BOOL use_assume_charset;

#if defined(VMS) || defined(USE_SLANG)
    BOOL old_use_assume_charset;
#endif

#ifdef DIRED_SUPPORT
#ifdef ENABLE_OPTS_CHANGE_EXEC
    if (LYlines < 24) {
	HTAlert(OPTION_SCREEN_NEEDS_24);
	return;
    }
#else
    if (LYlines < 23) {
	HTAlert(OPTION_SCREEN_NEEDS_23);
	return;
    }
#endif /* ENABLE_OPTS_CHANGE_EXEC */
#else
#ifdef ENABLE_OPTS_CHANGE_EXEC
    if (LYlines < 23) {
	HTAlert(OPTION_SCREEN_NEEDS_23);
	return;
    }
#else
    if (LYlines < 22) {
	HTAlert(OPTION_SCREEN_NEEDS_22);
	return;
    }
#endif /* ENABLE_OPTS_CHANGE_EXEC */
#endif /* DIRED_SUPPORT */

    term_options = FALSE;
    LYStatusLine = (LYlines - 1);	/* screen is otherwise too crowded */
    signal(SIGINT, terminate_options);
    if (no_option_save) {
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    } else {
	SetupChosenShowColor();
#endif /* USE_SLANG || COLOR_CURSES */
    }

    use_assume_charset = (BOOLEAN) (user_mode == ADVANCED_MODE);

  draw_options:

#if defined(VMS) || defined(USE_SLANG)
    old_use_assume_charset = use_assume_charset;
#endif
    /*
     * NOTE that printw() should be avoided for strings that might have
     * non-ASCII or multibyte/CJK characters.  - FM
     */
#if defined(FANCY_CURSES) || defined (USE_SLANG)
    if (enable_scrollback) {
	LYclear();
    } else {
	LYerase();
    }
#else
    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
    LYmove(0, 5);

    lynx_start_h1_color();
    LYaddstr("         Options Menu (");
    LYaddstr(LYNX_NAME);
    LYaddstr(" Version ");
    LYaddstr(LYNX_VERSION);
    LYaddch(')');
    lynx_stop_h1_color();
    LYmove(L_EDITOR, 5);
    addlbl("(E)ditor                     : ");
    LYaddstr(non_empty(editor) ? editor : "NONE");

    LYmove(L_DISPLAY, 5);
    addlbl("(D)ISPLAY variable           : ");
    LYaddstr(non_empty(x_display) ? x_display : "NONE");

    LYmove(L_HOME, 5);
    addlbl("mu(L)ti-bookmarks: ");
    LYaddstr(mbm_choices[LYMultiBookmarks]);
    LYmove(L_HOME, B_BOOK);
    if (LYMultiBookmarks != MBM_OFF) {
	addlbl("review/edit (B)ookmarks files");
    } else {
	addlbl("(B)ookmark file: ");
	LYaddstr(non_empty(bookmark_page) ? bookmark_page : "NONE");
    }

    LYmove(L_FTPSTYPE, 5);
    addlbl("(F)TP sort criteria          : ");
    LYaddstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
	      (HTfileSortMethod == FILE_BY_SIZE ? "By Size    " :
	       (HTfileSortMethod == FILE_BY_TYPE ? "By Type    " :
		"By Date    "))));

    LYmove(L_MAIL_ADDRESS, 5);
    addlbl("(P)ersonal mail address      : ");
    LYaddstr(non_empty(personal_mail_address) ?
	     personal_mail_address : "NONE");

    LYmove(L_SSEARCH, 5);
    addlbl("(S)earching type             : ");
    LYaddstr(LYcase_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");

    LYmove(L_Charset, 5);
    addlbl("display (C)haracter set      : ");
    LYaddstr(LYchar_set_names[current_char_set]);

    LYmove(L_LANGUAGE, 5);
    addlbl("preferred document lan(G)uage: ");
    LYaddstr(non_empty(language) ? language : "NONE");

    LYmove(L_PREF_CHARSET, 5);
    addlbl("preferred document c(H)arset : ");
    LYaddstr(non_empty(pref_charset) ? pref_charset : "NONE");

    if (use_assume_charset) {
	LYmove(L_ASSUME_CHARSET, 5);
	addlbl("(^A)ssume charset if unknown : ");
	if (UCAssume_MIMEcharset)
	    LYaddstr(UCAssume_MIMEcharset);
	else
	    LYaddstr((UCLYhndl_for_unspec >= 0) ?
		     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
		     : "NONE");
    }

    LYmove(L_Rawmode, 5);
    addlbl("Raw 8-bit or CJK m(O)de      : ");
    ShowBool(LYRawMode);

#if defined(USE_SLANG) || defined(COLOR_CURSES)
    LYmove(L_Color, B_COLOR);
    addlbl("show color (&)  : ");
    if (no_option_save) {
	ShowBool(LYShowColor == SHOW_COLOR_OFF);
    } else {
	switch (LYChosenShowColor) {
	case SHOW_COLOR_NEVER:
	    LYaddstr("NEVER     ");
	    break;
	case SHOW_COLOR_OFF:
	    LYaddstr("OFF");
	    break;
	case SHOW_COLOR_ON:
	    LYaddstr("ON ");
	    break;
	case SHOW_COLOR_ALWAYS:
#if defined(COLOR_CURSES)
	    if (!has_colors())
		LYaddstr("Always try");
	    else
#endif
		LYaddstr("ALWAYS    ");
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */

    LYmove(L_Bool_A, B_VIKEYS);
    addlbl("(V)I keys: ");
    ShowBool(vi_keys);

    LYmove(L_Bool_A, B_EMACSKEYS);
    addlbl("e(M)acs keys: ");
    ShowBool(emacs_keys);

    LYmove(L_Bool_A, B_SHOW_DOTFILES);
    addlbl("sho(W) dot files: ");
    ShowBool(!no_dotfiles && show_dotfiles);

    LYmove(L_Bool_B, B_SELECT_POPUPS);
    addlbl("popups for selec(T) fields   : ");
    ShowBool(LYSelectPopups);

    LYmove(L_Bool_B, B_SHOW_CURSOR);
    addlbl("show cursor (@@) : ");
    ShowBool(LYShowCursor);

    LYmove(L_Keypad, 5);
    addlbl("(K)eypad mode                : ");
    LYaddstr((fields_are_numbered() && links_are_numbered())
	     ? "Links and form fields are numbered"
	     : (links_are_numbered()
		? "Links are numbered                "
		: (fields_are_numbered()
		   ? "Form fields are numbered          "
		   : "Numbers act as arrows             ")));

    LYmove(L_Lineed, 5);
    addlbl("li(N)e edit style            : ");
    LYaddstr(LYEditorNames[current_lineedit]);

#ifdef EXP_KEYBOARD_LAYOUT
    LYmove(L_Layout, 5);
    addlbl("Ke(Y)board layout            : ");
    LYaddstr(LYKbLayoutNames[current_layout]);
#endif

#ifdef DIRED_SUPPORT
    LYmove(L_Dired, 5);
    addlbl("l(I)st directory style       : ");
    LYaddstr((dir_list_style == FILES_FIRST) ? "Files first      " :
	     ((dir_list_style == MIXED_STYLE) ? "Mixed style      " :
	      "Directories first"));
#endif /* DIRED_SUPPORT */

    LYmove(L_User_Mode, 5);
    addlbl("(U)ser mode                  : ");
    LYaddstr((user_mode == NOVICE_MODE) ? "Novice      " :
	     ((user_mode == INTERMEDIATE_MODE) ? "Intermediate" :
	      "Advanced    "));

    addlbl("  verbose images (!) : ");
    ShowBool(verbose_img);

    LYmove(L_User_Agent, 5);
    addlbl("user (A)gent                 : ");
    LYaddstr(non_empty(LYUserAgent) ? LYUserAgent : "NONE");

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    LYmove(L_Exec, 5);
    addlbl("local e(X)ecution links      : ");
#ifndef NEVER_ALLOW_REMOTE_EXEC
    LYaddstr(local_exec ? "ALWAYS ON           " :
	     (local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	      "ALWAYS OFF          "));
#else
    LYaddstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
	     "ALWAYS OFF          ");
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
#endif /* ENABLE_OPTS_CHANGE_EXEC */

    LYmove(LYlines - 3, 2);
    LYaddstr(SELECT_SEGMENT);
    lynx_start_bold();
    LYaddstr(CAP_LETT_SEGMENT);
    lynx_stop_bold();
    LYaddstr(OF_OPT_LINE_SEGMENT);
    if (!no_option_save) {
	LYaddstr(" '");
	lynx_start_bold();
	LYaddstr(">");
	lynx_stop_bold();
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
    }
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
    lynx_start_bold();
    LYaddstr("r");
    lynx_stop_bold();
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);

    response = 0;
    while (response != 'R' &&
	   !LYisNonAlnumKeyname(response, LYK_PREV_DOC) &&
	   response != '>' && !term_options &&
	   !LYCharIsINTERRUPT_NO_letter(response)) {
	if (AddValueAccepted == TRUE) {
	    _statusline(VALUE_ACCEPTED);
	    AddValueAccepted = FALSE;
	}
	LYmove((LYlines - 2), 0);
	lynx_start_prompt_color();
	LYaddstr(COMMAND_PROMPT);
	lynx_stop_prompt_color();

	LYrefresh();
	response = LYgetch_single();
	if (term_options || LYCharIsINTERRUPT_NO_letter(response))
	    response = 'R';
	if (LYisNonAlnumKeyname(response, LYK_REFRESH)) {
	    lynx_force_repaint();
	    goto draw_options;
	}
	switch (response) {
	case 'E':		/* Change the editor. */
	    if (no_editor) {
		_statusline(EDIT_DISABLED);
	    } else if (system_editor) {
		_statusline(EDITOR_LOCKED);
	    } else {
		if (non_empty(editor)) {
		    BStrCopy0(my_data, editor);
		} else {	/* clear the NONE */
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    BStrCopy0(my_data, "");
		}
		_statusline(ACCEPT_DATA);
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		lynx_start_bold();
		ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
		lynx_stop_bold();
		LYmove(L_EDITOR, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr(non_empty(editor) ?
			     editor : "NONE");
		} else if (isBEmpty(my_data)) {
		    FREE(editor);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(editor, my_data->str);
		    LYaddstr(editor);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    }
	    response = ' ';
	    break;

	case 'D':		/* Change the display. */
	    if (non_empty(x_display)) {
		BStrCopy0(my_data, x_display);
	    } else {		/* clear the NONE */
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
		LYaddstr("    ");
		BStrCopy0(my_data, "");
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
	    lynx_stop_bold();
	    LYmove(L_DISPLAY, COL_OPTION_VALUES);

#ifdef VMS
#define CompareEnvVars(a,b) strcasecomp(a, b)
#else
#define CompareEnvVars(a,b) strcmp(a, b)
#endif /* VMS */

	    if ((term_options || ch == -1) ||
		(x_display != NULL &&
		 !CompareEnvVars(x_display, my_data->str))) {
		/*
		 * Cancelled, or a non-NULL display string wasn't changed.  -
		 * FM
		 */
		LYaddstr(non_empty(x_display) ? x_display : "NONE");
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
		response = ' ';
		break;
	    } else if (isBEmpty(my_data)) {
		if ((x_display == NULL) ||
		    (x_display != NULL && *x_display == '\0')) {
		    /*
		     * NULL or zero-length display string wasn't changed.  - FM
		     */
		    LYaddstr("NONE");
		    LYclrtoeol();
		    _statusline(VALUE_ACCEPTED);
		    response = ' ';
		    break;
		}
	    }
	    /*
	     * Set the new DISPLAY variable.  - FM
	     */
	    LYsetXDisplay(my_data->str);
	    validate_x_display();
	    LYaddstr(x_display ? x_display : "NONE");
	    LYclrtoeol();
	    summarize_x_display(my_data->str);
	    response = ' ';
	    break;

	case 'L':		/* Change multibookmarks option. */
	    if (LYMBMBlocked) {
		_statusline(MULTIBOOKMARKS_DISALLOWED);
		response = ' ';
		break;
	    }
	    if (!LYSelectPopups) {
		LYMultiBookmarks = LYChooseEnum(LYMultiBookmarks,
						L_HOME, C_MULTI,
						mbm_choices);
	    } else {
		LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
						 L_HOME, (C_MULTI - 1),
						 mbm_choices,
						 3, FALSE, FALSE);
	    }
#if defined(VMS) || defined(USE_SLANG)
	    if (LYSelectPopups) {
		LYmove(L_HOME, C_MULTI);
		LYclrtoeol();
		LYaddstr(mbm_choices[LYMultiBookmarks]);
	    }
#endif /* VMS || USE_SLANG */
#if !defined(VMS) && !defined(USE_SLANG)
	    if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
	    {
		LYmove(L_HOME, B_BOOK);
		LYclrtoeol();
		if (LYMultiBookmarks != MBM_OFF) {
		    LYaddstr(gettext("review/edit B)ookmarks files"));
		} else {
		    LYaddstr(gettext("B)ookmark file: "));
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		}
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'B':		/* Change the bookmark page location. */
	    /*
	     * Anonymous users should not be allowed to change the bookmark
	     * page.
	     */
	    if (!no_bookmark) {
		if (LYMultiBookmarks != MBM_OFF) {
		    edit_bookmarks();
		    signal(SIGINT, terminate_options);
		    goto draw_options;
		}
		if (non_empty(bookmark_page)) {
		    BStrCopy0(my_data, bookmark_page);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, C_DEFAULT);
		    LYclrtoeol();
		    BStrCopy0(my_data, "");
		}
		_statusline(ACCEPT_DATA);
		LYmove(L_HOME, C_DEFAULT);
		lynx_start_bold();
		ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
		lynx_stop_bold();
		LYmove(L_HOME, C_DEFAULT);
		BStrAlloc(my_data, my_data->len + LY_MAXPATH);	/* lengthen */
		if (term_options ||
		    ch == -1 || isBEmpty(my_data)) {
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		} else if (!LYPathOffHomeOK(my_data->str, (size_t) my_data->len)) {
		    LYaddstr(non_empty(bookmark_page) ?
			     bookmark_page : "NONE");
		    LYclrtoeol();
		    _statusline(USE_PATH_OFF_HOME);
		    response = ' ';
		    break;
		} else {
		    StrAllocCopy(bookmark_page, my_data->str);
		    StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
		    LYaddstr(bookmark_page);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    } else {		/* anonymous */
		_statusline(BOOKMARK_CHANGE_DISALLOWED);
	    }
	    response = ' ';
	    break;

	case 'F':		/* Change ftp directory sorting. */
	    if (!LYSelectPopups) {
		HTfileSortMethod = LYChooseEnum(HTfileSortMethod,
						L_FTPSTYPE, -1,
						fileSort_choices);
	    } else {
		HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
						 L_FTPSTYPE, -1,
						 fileSort_choices,
						 4, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(fileSort_choices[HTfileSortMethod]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'P':		/* Change personal mail address for From headers. */
	    if (non_empty(personal_mail_address)) {
		BStrCopy0(my_data, personal_mail_address);
	    } else {		/* clear the NONE */
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		LYaddstr("    ");
		BStrCopy0(my_data, "");
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
	    lynx_stop_bold();
	    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr((personal_mail_address &&
			  *personal_mail_address) ?
			 personal_mail_address : "NONE");
	    } else if (isBEmpty(my_data)) {
		FREE(personal_mail_address);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(personal_mail_address, my_data->str);
		LYaddstr(personal_mail_address);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'S':		/* Change case sensitivity for searches. */
	    LYcase_sensitive = LYChooseBoolean(LYcase_sensitive,
					       L_SSEARCH, -1,
					       caseless_choices);
	    response = ' ';
	    break;

	case '\001':		/* Change assume_charset setting. */
	    if (use_assume_charset) {
		int i, curval;
		const char **assume_list;
		assume_list = typecallocn(const char *, (unsigned)
					    (LYNumCharsets + 1));

		if (!assume_list) {
		    outofmem(__FILE__, "options");
		}
		for (i = 0; i < LYNumCharsets; i++) {
		    assume_list[i] = LYCharSet_UC[i].MIMEname;
		}
		curval = UCLYhndl_for_unspec;
		if (curval == current_char_set && UCAssume_MIMEcharset) {
		    curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
		}
		if (curval < 0)
		    curval = LYRawMode ? current_char_set : 0;
		if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChooseEnum(charset_subsets[curval].assumed_idx,
							      L_ASSUME_CHARSET, -1,
							      assumed_charset_choices)
						 ? 1
						 : 0)];
#else
		    UCLYhndl_for_unspec =
			LYChooseEnum(curval,
				     L_ASSUME_CHARSET, -1,
				     assume_list);
#endif
		} else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		    UCLYhndl_for_unspec =
			assumed_doc_charset_map[(LYChoosePopup(charset_subsets[curval].assumed_idx,
							       L_ASSUME_CHARSET, -1,
							       assumed_charset_choices,
							       0,
							       FALSE,
							       FALSE)
						 ? 1
						 : 0)];
#else
		    UCLYhndl_for_unspec =
			LYChoosePopup(curval,
				      L_ASSUME_CHARSET, -1,
				      assume_list,
				      0, FALSE, FALSE);
#endif
#if defined(VMS) || defined(USE_SLANG)
		    LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
		    LYclrtoeol();
		    if (UCLYhndl_for_unspec >= 0)
			LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
#endif /* VMS || USE_SLANG */
		}

		/*
		 * Set the raw 8-bit or CJK mode defaults and character set if
		 * changed.  - FM
		 */
		if (CurrentAssumeCharSet != UCLYhndl_for_unspec ||
		    UCLYhndl_for_unspec != curval) {
		    if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
			StrAllocCopy(UCAssume_MIMEcharset,
				     LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
		    }
		    if (HTCJK != JAPANESE)
			LYRawMode = (BOOLEAN) (UCLYhndl_for_unspec == current_char_set);
		    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		    HTMLSetCharacterHandling(current_char_set);
		    CurrentAssumeCharSet = UCLYhndl_for_unspec;
		    CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
		    if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
		    {
			LYmove(L_Rawmode, COL_OPTION_VALUES);
			LYclrtoeol();
			ShowBool(LYRawMode);
		    }
		}
		FREE(assume_list);
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
	    } else {
		_statusline(NEED_ADVANCED_USER_MODE);
		AddValueAccepted = FALSE;
	    }
	    break;

	case 'C':		/* Change display charset setting. */
	    if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChooseEnum(displayed_display_charset_idx,
							     L_Charset, -1,
							     display_charset_choices);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChooseEnum(current_char_set,
						L_Charset, -1,
						LYchar_set_names);
#endif
	    } else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
		displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
							      L_Charset, -1,
							      display_charset_choices,
							      0, FALSE, FALSE);
		current_char_set = display_charset_map[displayed_display_charset_idx];
#else
		current_char_set = LYChoosePopup(current_char_set,
						 L_Charset, -1,
						 LYchar_set_names,
						 0, FALSE, FALSE);
#endif

#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Charset, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYchar_set_names[current_char_set]);
#endif /* VMS || USE_SLANG */
	    }
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    if (CurrentCharSet != current_char_set) {
		LYUseDefaultRawMode = TRUE;
		HTMLUseCharacterSet(current_char_set);
		CurrentCharSet = current_char_set;
		CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
		if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
		{
		    LYmove(L_Rawmode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    ShowBool(LYRawMode);
		}
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		/* Deduce whether the user wants autoswitch: */
		switch_display_charsets =
		    (current_char_set == auto_display_charset
		     || current_char_set == auto_other_display_charset);
#endif
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'O':		/* Change raw mode setting. */
	    LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    if (CurrentRawMode != LYRawMode) {
		HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		HTMLSetCharacterHandling(current_char_set);
		CurrentRawMode = LYRawMode;
	    }
	    response = ' ';
	    break;

	case 'G':		/* Change language preference. */
	    if (non_empty(language)) {
		BStrCopy0(my_data, language);
	    } else {		/* clear the NONE */
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		LYaddstr("    ");
		BStrCopy0(my_data, "");
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
	    lynx_stop_bold();
	    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr(non_empty(language) ?
			 language : "NONE");
	    } else if (isBEmpty(my_data)) {
		FREE(language);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(language, my_data->str);
		LYaddstr(language);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'H':		/* Change charset preference. */
	    if (non_empty(pref_charset)) {
		BStrCopy0(my_data, pref_charset);
	    } else {		/* clear the NONE */
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		LYaddstr("    ");
		BStrCopy0(my_data, "");
	    }
	    _statusline(ACCEPT_DATA);
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    lynx_start_bold();
	    ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
	    lynx_stop_bold();
	    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
	    if (term_options || ch == -1) {
		LYaddstr(non_empty(pref_charset) ?
			 pref_charset : "NONE");
	    } else if (isBEmpty(my_data)) {
		FREE(pref_charset);
		LYaddstr("NONE");
	    } else {
		StrAllocCopy(pref_charset, my_data->str);
		LYaddstr(pref_charset);
	    }
	    LYclrtoeol();
	    if (ch == -1) {
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    response = ' ';
	    break;

	case 'V':		/* Change VI keys setting. */
	    vi_keys = LYChooseBoolean(vi_keys,
				      L_Bool_A, C_VIKEYS,
				      bool_choices);
	    if (vi_keys) {
		set_vi_keys();
	    } else {
		reset_vi_keys();
	    }
	    response = ' ';
	    break;

	case 'M':		/* Change emacs keys setting. */
	    emacs_keys = LYChooseBoolean(emacs_keys,
					 L_Bool_A, C_EMACSKEYS,
					 bool_choices);
	    if (emacs_keys) {
		set_emacs_keys();
	    } else {
		reset_emacs_keys();
	    }
	    response = ' ';
	    break;

	case 'W':		/* Change show dotfiles setting. */
	    if (no_dotfiles) {
		_statusline(DOTFILE_ACCESS_DISABLED);
	    } else {
		show_dotfiles = LYChooseBoolean(show_dotfiles,
						L_Bool_A,
						C_SHOW_DOTFILES,
						bool_choices);
	    }
	    response = ' ';
	    break;

	case 'T':		/* Change select popups setting. */
	    LYSelectPopups = LYChooseBoolean(LYSelectPopups,
					     L_Bool_B,
					     C_SELECT_POPUPS,
					     bool_choices);
	    response = ' ';
	    break;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
	case '&':		/* Change show color setting. */
	    if (no_option_save) {
#if defined(COLOR_CURSES)
		if (!has_colors()) {
		    char *terminal = LYGetEnv("TERM");

		    if (terminal)
			HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				   terminal);
		    else
			HTUserMsg(COLOR_TOGGLE_DISABLED);
		    break;
		}
#endif
		LYShowColor = LYChooseEnum((LYShowColor - 1),
					   L_Color,
					   C_COLOR,
					   bool_choices);
		if (LYShowColor == 0) {
		    LYShowColor = SHOW_COLOR_OFF;
		} else {
		    LYShowColor = SHOW_COLOR_ON;
		}
	    } else {		/* !no_option_save */
		BOOLEAN again = FALSE;
		int chosen;

		/*
		 * Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "NEVER     ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "OFF       ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "ON        ");
		choices[3] = NULL;
#if defined(COLOR_CURSES)
		if (!has_colors())
		    StrAllocCopy(choices[3], "Always try");
		else
#endif
		    StrAllocCopy(choices[3], "ALWAYS    ");
		choices[4] = NULL;
		do {
		    if (!LYSelectPopups) {
			chosen = LYChooseEnum(LYChosenShowColor,
					      L_Color,
					      C_COLOR,
					      choices);
		    } else {
			chosen = LYChoosePopup(LYChosenShowColor,
					       L_Color,
					       C_COLOR,
					       choices, 4, FALSE, FALSE);
		    }
#if defined(COLOR_CURSES)
		    again = (BOOLEAN) (chosen == SHOW_COLOR_ON && !has_colors());
		    if (again) {
			char *terminal = LYGetEnv("TERM");

			if (terminal)
			    HTUserMsg2(COLOR_TOGGLE_DISABLED_FOR_TERM,
				       terminal);
			else
			    HTUserMsg(COLOR_TOGGLE_DISABLED);
		    }
#endif
		} while (again);
		LYChosenShowColor = chosen;
#if defined(VMS)
		if (LYSelectPopups) {
		    LYmove(L_Color, C_COLOR);
		    LYclrtoeol();
		    LYaddstr(choices[LYChosenShowColor]);
		}
#endif /* VMS */
#if defined(COLOR_CURSES)
		if (has_colors())
#endif
		    LYShowColor = chosen;
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
		FREE(choices[3]);
	    }
	    if (CurrentShowColor != LYShowColor) {
		lynx_force_repaint();
	    }
	    CurrentShowColor = LYShowColor;
#ifdef USE_SLANG
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
#endif
	    response = ' ';
	    if (LYSelectPopups && !no_option_save) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* USE_SLANG or COLOR_CURSES */

	case '@@':		/* Change show cursor setting. */
	    LYShowCursor = LYChooseBoolean(LYShowCursor,
					   L_Bool_B,
					   C_SHOW_CURSOR,
					   bool_choices);
	    response = ' ';
	    break;

	case 'K':		/* Change keypad mode. */
	    if (!LYSelectPopups) {
		keypad_mode = LYChooseEnum(keypad_mode,
					   L_Keypad, -1,
					   keypad_choices);
	    } else {
		keypad_mode = LYChoosePopup(keypad_mode,
					    L_Keypad, -1,
					    keypad_choices,
					    3, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Keypad, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(keypad_choices[keypad_mode]);
#endif /* VMS || USE_SLANG */
	    }
	    if (keypad_mode == NUMBERS_AS_ARROWS) {
		set_numbers_as_arrows();
	    } else {
		reset_numbers_as_arrows();
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'N':		/* Change line editor key bindings. */
	    if (!LYSelectPopups) {
		current_lineedit = LYChooseEnum(current_lineedit,
						L_Lineed, -1,
						LYEditorNames);
	    } else {
		current_lineedit = LYChoosePopup(current_lineedit,
						 L_Lineed, -1,
						 LYEditorNames,
						 0, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Lineed, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYEditorNames[current_lineedit]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

#ifdef EXP_KEYBOARD_LAYOUT
	case 'Y':		/* Change keyboard layout */
	    if (!LYSelectPopups) {
		current_layout = LYChooseEnum(current_layout,
					      L_Layout, -1,
					      LYKbLayoutNames);
	    } else {
		current_layout = LYChoosePopup(current_layout,
					       L_Layout, -1,
					       LYKbLayoutNames,
					       0, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Layout, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(LYKbLayoutNames[current_layout]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* EXP_KEYBOARD_LAYOUT */

#ifdef DIRED_SUPPORT
	case 'I':		/* Change local directory sorting. */
	    if (!LYSelectPopups) {
		dir_list_style = LYChooseEnum(dir_list_style,
					      L_Dired, -1,
					      dirList_choices);
	    } else {
		dir_list_style = LYChoosePopup(dir_list_style,
					       L_Dired, -1,
					       dirList_choices,
					       3, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Dired, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(dirList_choices[dir_list_style]);
#endif /* VMS || USE_SLANG */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* DIRED_SUPPORT */

	case 'U':		/* Change user mode. */
	    if (!LYSelectPopups) {
		user_mode = LYChooseEnum(user_mode,
					 L_User_Mode, -1,
					 userMode_choices);
		use_assume_charset = (BOOLEAN) (user_mode >= 2);
	    } else {
		user_mode = LYChoosePopup(user_mode,
					  L_User_Mode, -1,
					  userMode_choices,
					  3, FALSE, FALSE);
		use_assume_charset = (BOOLEAN) (user_mode >= 2);
#if defined(VMS) || defined(USE_SLANG)
		if (use_assume_charset == old_use_assume_charset) {
		    LYmove(L_User_Mode, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(userMode_choices[user_mode]);
		}
#endif /* VMS || USE_SLANG */
	    }
	    LYSetDisplayLines();
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case '!':
	    if (!LYSelectPopups) {
		verbose_img = LYChooseBoolean(verbose_img,
					      L_VERBOSE_IMAGES,
					      C_VERBOSE_IMAGES,
					      bool_choices);
	    } else {
		verbose_img = (BOOLEAN) LYChoosePopup(verbose_img,
						      L_VERBOSE_IMAGES,
						      C_VERBOSE_IMAGES,
						      bool_choices,
						      2, FALSE, FALSE);
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;

	case 'A':		/* Change user agent string. */
	    if (!no_useragent) {
		if (non_empty(LYUserAgent)) {
		    BStrCopy0(my_data, LYUserAgent);
		} else {	/* clear the NONE */
		    LYmove(L_HOME, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    BStrCopy0(my_data, "");
		}
		_statusline(ACCEPT_DATA_OR_DEFAULT);
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		lynx_start_bold();
		ch = LYgetBString(&my_data, FALSE, 0, NORECALL);
		lynx_stop_bold();
		LYmove(L_User_Agent, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
		} else if (isBEmpty(my_data)) {
		    StrAllocCopy(LYUserAgent, LYUserAgentDefault);
		    LYaddstr((LYUserAgent &&
			      *LYUserAgent) ?
			     LYUserAgent : "NONE");
		} else {
		    StrAllocCopy(LYUserAgent, my_data->str);
		    LYaddstr(LYUserAgent);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else if (!LYCheckUserAgent()) {
		    _statusline(UA_PLEASE_USE_LYNX);
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
	    } else {		/* disallowed */
		_statusline(UA_CHANGE_DISABLED);
	    }
	    response = ' ';
	    break;

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	case 'X':		/* Change local exec restriction. */
	    if (exec_frozen && !LYSelectPopups) {
		_statusline(CHANGE_OF_SETTING_DISALLOWED);
		response = ' ';
		break;
	    }
#ifndef NEVER_ALLOW_REMOTE_EXEC
	    if (local_exec) {
		itmp = 2;
	    } else
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
	    {
		if (local_exec_on_local_files) {
		    itmp = 1;
		} else {
		    itmp = 0;
		}
	    }
	    if (!LYSelectPopups) {
		itmp = LYChooseEnum(itmp,
				    L_Exec, -1,
				    exec_choices);
	    } else {
		itmp = LYChoosePopup(itmp,
				     L_Exec, -1,
				     exec_choices,
				     0, (exec_frozen ? TRUE : FALSE),
				     FALSE);
#if defined(VMS) || defined(USE_SLANG)
		LYmove(L_Exec, COL_OPTION_VALUES);
		LYclrtoeol();
		LYaddstr(exec_choices[itmp]);
#endif /* VMS || USE_SLANG */
	    }
	    if (!exec_frozen) {
		switch (itmp) {
		case 0:
		    local_exec = FALSE;
		    local_exec_on_local_files = FALSE;
		    break;
		case 1:
		    local_exec = FALSE;
		    local_exec_on_local_files = TRUE;
		    break;
#ifndef NEVER_ALLOW_REMOTE_EXEC
		case 2:
		    local_exec = TRUE;
		    local_exec_on_local_files = FALSE;
		    break;
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
		}		/* end switch */
	    }
	    response = ' ';
	    if (LYSelectPopups) {
		HANDLE_LYOPTIONS;
	    }
	    break;
#endif /* ENABLE_OPTS_CHANGE_EXEC */

	case '>':		/* Save current options to RC file. */
	    if (!no_option_save) {
		HTInfoMsg(SAVING_OPTIONS);
		LYrcShowColor = LYChosenShowColor;
		if (save_rc(NULL)) {
		    HTInfoMsg(OPTIONS_SAVED);
		} else {
		    HTAlert(OPTIONS_NOT_SAVED);
		}
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
		/*
		 * Change response so that we don't exit the options menu.
		 */
		response = ' ';
	    }
	    break;

	case 'R':		/* Return to document (quit options menu). */
	    break;

	default:
	    if (!no_option_save) {
		HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
	    }
	}			/* end switch */
    }				/* end while */

    term_options = FALSE;
    LYStatusLine = -1;		/* let user_mode have some of the screen */
    signal(SIGINT, cleanup_sig);
    BStrFree(my_data);
    return;
}

static int widest_choice(STRING2PTR choices)
{
    int n, width = 0;

    for (n = 0; choices[n] != NULL; ++n) {
	int len = (int) strlen(choices[n]);

	if (width < len)
	    width = len;
    }
    return width;
}

static void show_choice(const char *choice,
			int width)
{
    int len = (int) strlen(choice);

    LYaddstr(choice);
    while (len++ < width)
	LYaddch(' ');
}

/*
 * Take a status code, prompt the user for a new status, and return it.
 */
static int boolean_choice(int cur_choice,
			  int line,
			  int column,
			  STRING2PTR choices)
{
    int response = 0;
    int cmd = 0;
    int number = 0;
    int col = (column >= 0 ? column : COL_OPTION_VALUES);
    int orig_choice = cur_choice;
    int width = widest_choice(choices);

    /*
     * Get the number of choices and then make number zero-based.
     */
    for (number = 0; choices[number] != NULL; number++) ;	/* empty loop body */
    number--;

    /*
     * Update the statusline.
     */
    _statusline(ANY_KEY_CHANGE_RET_ACCEPT);

    /*
     * Highlight the current choice.
     */
    LYmove(line, col);
    lynx_start_reverse();
    show_choice(choices[cur_choice], width);
    if (LYShowCursor)
	LYmove(line, (col - 1));
    LYrefresh();

    /*
     * Get the keyboard entry, and leave the cursor at the choice, to indicate
     * that it can be changed, until the user accepts the current choice.
     */
    term_options = FALSE;
    while (1) {
	LYmove(line, col);
	if (term_options == FALSE) {
	    response = LYgetch_single();
	}
	if (term_options || LYCharIsINTERRUPT_NO_letter(response)) {
	    /*
	     * Control-C or Control-G.
	     */
	    response = '\n';
	    term_options = TRUE;
	    cur_choice = orig_choice;
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    response = '\n';
	    term_options = TRUE;
	    cur_choice = orig_choice;
	}
#endif /* VMS */
	if ((response != '\n' && response != '\r') &&
	    (cmd = LKC_TO_LAC(keymap, response)) != LYK_ACTIVATE) {
	    switch (cmd) {
	    case LYK_HOME:
		cur_choice = 0;
		break;

	    case LYK_END:
		cur_choice = number;
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;

	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_choice = orig_choice;
		term_options = TRUE;
		break;

	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:
	    case LYK_LEFT_LINK:
		if (cur_choice == 0)
		    cur_choice = number;	/* go back to end */
		else
		    cur_choice--;
		break;

	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		if ((cmd - LYK_1 + 1) <= number) {
		    cur_choice = cmd - LYK_1 + 1;
		    break;
		}		/* else fall through! */
	    default:
		if (cur_choice == number)
		    cur_choice = 0;	/* go over the top and around */
		else
		    cur_choice++;
	    }			/* end of switch */
	    show_choice(choices[cur_choice], width);
	    if (LYShowCursor)
		LYmove(line, (col - 1));
	    LYrefresh();
	} else {
	    /*
	     * Unhighlight choice.
	     */
	    LYmove(line, col);
	    lynx_stop_reverse();
	    show_choice(choices[cur_choice], width);

	    if (term_options) {
		term_options = FALSE;
		HTInfoMsg(CANCELLED);
		HTInfoMsg("");
	    } else {
		_statusline(VALUE_ACCEPTED);
	    }
	    return cur_choice;
	}
    }
}
#endif /* !NO_OPTION_MENU */

static void terminate_options(int sig GCC_UNUSED)
{
    term_options = TRUE;
    /*
     * Reassert the AST.
     */
    signal(SIGINT, terminate_options);
#ifdef VMS
    /*
     * Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}

/*
 * Multi-Bookmark On-Line editing support.  - FMG & FM
 */
void edit_bookmarks(void)
{
    int response = 0, def_response = 0;
    int MBM_current = 1;

#define MULTI_OFFSET 8
    int a;			/* misc counter */
    bstring *my_data = NULL;

    /*
     * We need (MBM_V_MAXFILES + MULTI_OFFSET) lines to display the whole list
     * at once.  Otherwise break it up into two segments.  We know it won't be
     * less than that because 'o'ptions needs 23-24 at LEAST.
     */
    term_options = FALSE;
    signal(SIGINT, terminate_options);

  draw_bookmark_list:
    /*
     * Display menu of bookmarks.  NOTE that we avoid printw()'s to increase
     * the chances that any non-ASCII or multibyte/CJK characters will be
     * handled properly.  - FM
     */
#if defined(FANCY_CURSES) || defined (USE_SLANG)
    if (enable_scrollback) {
	LYclear();
    } else {
	LYerase();
    }
#else
    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
    LYmove(0, 5);
    lynx_start_h1_color();
    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	char *ehead_buffer = 0;

	HTSprintf0(&ehead_buffer, MULTIBOOKMARKS_EHEAD_MASK, MBM_current);
	LYaddstr(ehead_buffer);
	FREE(ehead_buffer);
    } else {
	LYaddstr(MULTIBOOKMARKS_EHEAD);
    }
    lynx_stop_h1_color();

    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	for (a = ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1));
	     a <= (MBM_current * MBM_V_MAXFILES / 2); a++) {
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[a])
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove((3 + a) - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)), 35);
	    LYaddstr("| ");
	    if (MBM_A_subbookmark[a]) {
		LYaddstr(MBM_A_subbookmark[a]);
	    }
	}
    } else {
	for (a = 0; a <= MBM_V_MAXFILES; a++) {
	    LYmove(3 + a, 5);
	    LYaddch(UCH(LYindex2MBM(a)));
	    LYaddstr(" : ");
	    if (MBM_A_subdescript[a])
		LYaddstr(MBM_A_subdescript[a]);
	    LYmove(3 + a, 35);
	    LYaddstr("| ");
	    if (MBM_A_subbookmark[a]) {
		LYaddstr(MBM_A_subbookmark[a]);
	    }
	}
    }

    /*
     * Only needed when we have 2 screens.
     */
    if (LYlines < MBM_V_MAXFILES + MULTI_OFFSET) {
	LYmove((LYlines - 4), 0);
	LYaddstr("'");
	lynx_start_bold();
	LYaddstr("[");
	lynx_stop_bold();
	LYaddstr("' ");
	LYaddstr(PREVIOUS);
	LYaddstr(", '");
	lynx_start_bold();
	LYaddstr("]");
	lynx_stop_bold();
	LYaddstr("' ");
	LYaddstr(NEXT_SCREEN);
    }

    LYmove((LYlines - 3), 0);
    if (!no_option_save) {
	LYaddstr("'");
	lynx_start_bold();
	LYaddstr(">");
	lynx_stop_bold();
	LYaddstr("'");
	LYaddstr(TO_SAVE_SEGMENT);
    }
    LYaddstr(OR_SEGMENT);
    LYaddstr("'");
    lynx_start_bold();
    LYaddstr("^G");
    lynx_stop_bold();
    LYaddstr("'");
    LYaddstr(TO_RETURN_SEGMENT);

    while (!term_options &&
	   !LYisNonAlnumKeyname(response, LYK_PREV_DOC) &&
	   !LYCharIsINTERRUPT_NO_letter(response) && response != '>') {

	LYmove((LYlines - 2), 0);
	lynx_start_prompt_color();
	LYaddstr(MULTIBOOKMARKS_LETTER);
	lynx_stop_prompt_color();

	LYrefresh();
	response = (def_response ? def_response : LYgetch_single());
	def_response = 0;

	/*
	 * Check for a cancel.
	 */
	if (term_options || LYCharIsINTERRUPT_NO_letter(response) ||
	    LYisNonAlnumKeyname(response, LYK_PREV_DOC))
	    continue;

	/*
	 * Check for a save.
	 */
	if (response == '>') {
	    if (!no_option_save) {
		HTInfoMsg(SAVING_OPTIONS);
		if (save_rc(NULL))
		    HTInfoMsg(OPTIONS_SAVED);
		else
		    HTAlert(OPTIONS_NOT_SAVED);
	    } else {
		HTInfoMsg(R_TO_RETURN_TO_LYNX);
		/*
		 * Change response so that we don't exit the options menu.
		 */
		response = ' ';
	    }
	    continue;
	}

	/*
	 * Check for a refresh.
	 */
	if (LYisNonAlnumKeyname(response, LYK_REFRESH)) {
	    lynx_force_repaint();
	    continue;
	}

	/*
	 * Move between the screens - if we can't show it all at once.
	 */
	if ((response == ']' ||
	     LYisNonAlnumKeyname(response, LYK_NEXT_PAGE)) &&
	    LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	    MBM_current++;
	    if (MBM_current >= 3)
		MBM_current = 1;
	    goto draw_bookmark_list;
	}
	if ((response == '[' ||
	     LYisNonAlnumKeyname(response, LYK_PREV_PAGE)) &&
	    LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
	    MBM_current--;
	    if (MBM_current <= 0)
		MBM_current = 2;
	    goto draw_bookmark_list;
	}

	/*
	 * Instead of using 26 case statements, we set up a scan through the
	 * letters and edit the lines that way.
	 */
	for (a = 0; a <= MBM_V_MAXFILES; a++) {
	    if (LYMBM2index(response) == a) {
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET)) {
		    if (MBM_current == 1 && a > (MBM_V_MAXFILES / 2)) {
			MBM_current = 2;
			def_response = response;
			goto draw_bookmark_list;
		    }
		    if (MBM_current == 2 && a < (MBM_V_MAXFILES / 2)) {
			MBM_current = 1;
			def_response = response;
			goto draw_bookmark_list;
		    }
		}
		_statusline(ACCEPT_DATA);

		if (a > 0) {
		    lynx_start_bold();
		    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1) * (MBM_current - 1)),
			       9);
		    else
			LYmove((3 + a), 9);
		    BStrCopy0(my_data,
			      (!MBM_A_subdescript[a] ?
			       "" : MBM_A_subdescript[a]));
		    (void) LYgetBString(&my_data, FALSE, 0, NORECALL);
		    lynx_stop_bold();

		    if (isBEmpty(my_data)) {
			FREE(MBM_A_subdescript[a]);
		    } else {
			StrAllocCopy(MBM_A_subdescript[a], my_data->str);
		    }
		    if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
			LYmove((3 + a)
			       - ((MBM_V_MAXFILES / 2 + 1)
				  * (MBM_current - 1)),
			       5);
		    else
			LYmove((3 + a), 5);
		    LYaddch(UCH(LYindex2MBM(a)));
		    LYaddstr(" : ");
		    if (MBM_A_subdescript[a])
			LYaddstr(MBM_A_subdescript[a]);
		    LYclrtoeol();
		    LYrefresh();
		}

		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
		else
		    LYmove((3 + a), 35);
		LYaddstr("| ");

		lynx_start_bold();
		BStrCopy0(my_data, NonNull(MBM_A_subbookmark[a]));
		(void) LYgetBString(&my_data, FALSE, 0, NORECALL);
		lynx_stop_bold();

		if (isBEmpty(my_data)) {
		    if (a == 0)
			StrAllocCopy(MBM_A_subbookmark[a], bookmark_page);
		    else
			FREE(MBM_A_subbookmark[a]);
		} else {
		    BStrAlloc(my_data, my_data->len + LY_MAXPATH);
		    if (!LYPathOffHomeOK(my_data->str, (size_t) my_data->len)) {
			LYMBM_statusline(USE_PATH_OFF_HOME);
			LYSleepAlert();
		    } else {
			StrAllocCopy(MBM_A_subbookmark[a], my_data->str);
			if (a == 0) {
			    StrAllocCopy(bookmark_page, MBM_A_subbookmark[a]);
			}
		    }
		}
		if (LYlines < (MBM_V_MAXFILES + MULTI_OFFSET))
		    LYmove((3 + a)
			   - ((MBM_V_MAXFILES / 2 + 1)
			      * (MBM_current - 1)),
			   35);
		else
		    LYmove((3 + a), 35);
		LYaddstr("| ");
		if (MBM_A_subbookmark[a])
		    LYaddstr(MBM_A_subbookmark[a]);
		LYclrtoeol();
		LYParkCursor();
		break;
	    }
	}			/* end for */
    }				/* end while */

    BStrFree(my_data);
    term_options = FALSE;
    signal(SIGINT, cleanup_sig);
}

#if defined(USE_CURSES_PADS) || !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))

/*
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
 *
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
 */
int popup_choice(int cur_choice,
		 int line,
		 int column,
		 STRING2PTR choices,
		 int i_length,
		 int disabled,
		 int for_mouse)
{
    if (column < 0)
	column = (COL_OPTION_VALUES - 1);

    term_options = FALSE;
    cur_choice = LYhandlePopupList(cur_choice,
				   line,
				   column,
				   (STRING2PTR) choices,
				   -1,
				   i_length,
				   disabled,
				   for_mouse);
    switch (cur_choice) {
    case LYK_QUIT:
    case LYK_ABORT:
    case LYK_PREV_DOC:
	term_options = TRUE;
	if (!for_mouse) {
	    HTUserMsg(CANCELLED);
	}
	break;
    }

    if (disabled || term_options) {
	_statusline("");
    } else if (!for_mouse) {
	_statusline(VALUE_ACCEPTED);
    }
    return (cur_choice);
}

#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS

/*
 * I'm paranoid about mistyping strings.  Also, this way they get combined
 * so we don't have to worry about the intelligence of the compiler.
 * We don't need to burn memory like it's cheap.  We're better than that.
 */
#define SELECTED(flag) (flag) ? selected_string : ""
#define DISABLED(flag) (flag) ? disabled_string : ""

typedef struct {
    int value;
    const char *LongName;
    const char *HtmlName;
} OptValues;

typedef struct {
    char *tag;
    char *value;
} PostPair;

static const char selected_string[] = "selected";
static const char disabled_string[] = "disabled";
static const char on_string[] = N_("ON");
static const char off_string[] = N_("OFF");
static const char never_string[] = N_("NEVER");
static const char always_string[] = N_("ALWAYS");
static OptValues bool_values[] =
{
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("ON"), "ON"},
    {0, 0, 0}
};

static const char *secure_string = "secure";
static char *secure_value = NULL;
static const char *save_options_string = "save_options";

/*
 * Personal Preferences
 */
static const char *cookies_string = RC_SET_COOKIES;
static const char *cookies_ignore_all_string = N_("ignore");
static const char *cookies_up_to_user_string = N_("ask user");
static const char *cookies_accept_all_string = N_("accept all");
static const char *x_display_string = RC_DISPLAY;
static const char *editor_string = RC_FILE_EDITOR;
static const char *emacs_keys_string = RC_EMACS_KEYS;

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
#define EXEC_ALWAYS 2
#define EXEC_LOCAL  1
#define EXEC_NEVER  0
static const char *exec_links_string = RC_RUN_ALL_EXECUTION_LINKS;
static OptValues exec_links_values[] =
{
    {EXEC_NEVER, N_("ALWAYS OFF"), "ALWAYS OFF"},
    {EXEC_LOCAL, N_("FOR LOCAL FILES ONLY"), "FOR LOCAL FILES ONLY"},
#ifndef NEVER_ALLOW_REMOTE_EXEC
    {EXEC_ALWAYS, N_("ALWAYS ON"), "ALWAYS ON"},
#endif
    {0, 0, 0}
};
#endif /* ENABLE_OPTS_CHANGE_EXEC */

#ifdef EXP_KEYBOARD_LAYOUT
static const char *kblayout_string = RC_KBLAYOUT;
#endif
static const char *keypad_mode_string = RC_KEYPAD_MODE;
static OptValues keypad_mode_values[] =
{
    {NUMBERS_AS_ARROWS, N_("Numbers act as arrows"),
     "number_arrows"},
    {LINKS_ARE_NUMBERED, N_("Links are numbered"),
     "links_numbered"},
    {LINKS_AND_FIELDS_ARE_NUMBERED,
     N_("Links and form fields are numbered"),
     "links_and_forms"},
    {FIELDS_ARE_NUMBERED,
     N_("Form fields are numbered"),
     "forms_numbered"},
    {0, 0, 0}
};
static const char *lineedit_mode_string = RC_LINEEDIT_MODE;
static const char *mail_address_string = RC_PERSONAL_MAIL_ADDRESS;
static const char *personal_name_string = RC_PERSONAL_MAIL_NAME;
static const char *search_type_string = RC_CASE_SENSITIVE_SEARCHING;

#ifndef DISABLE_FTP
static const char *anonftp_password_string = RC_ANONFTP_PASSWORD;
#endif

static OptValues search_type_values[] =
{
    {FALSE, N_("Case insensitive"), "case_insensitive"},
    {TRUE, N_("Case sensitive"), "case_sensitive"},
    {0, 0, 0}
};

#if defined(USE_SLANG) || defined(COLOR_CURSES)
static const char *show_color_string = RC_SHOW_COLOR;
static OptValues show_color_values[] =
{
    {SHOW_COLOR_NEVER, never_string, never_string},
    {SHOW_COLOR_OFF, off_string, off_string},
    {SHOW_COLOR_ON, on_string, on_string},
    {SHOW_COLOR_ALWAYS, always_string, always_string},
    {0, 0, 0}
};
#endif

#ifdef USE_COLOR_STYLE
static const char *color_style_string = RC_COLOR_STYLE;
static OptValues *color_style_values;
static HTList *color_style_list;
#endif

#ifdef USE_DEFAULT_COLORS
static const char *default_colors_string = RC_DEFAULT_COLORS;
#endif

static const char *show_cursor_string = RC_SHOW_CURSOR;

static const char *underline_links_string = RC_UNDERLINE_LINKS;

#ifdef USE_SCROLLBAR
static const char *show_scrollbar_string = RC_SCROLLBAR;
#endif

static const char prompt_dft_string[] = N_("prompt normally");
static const char prompt_yes_string[] = N_("force yes-response");
static const char prompt_no_string[] = N_("force no-response");
static OptValues prompt_values[] =
{
    {FORCE_PROMPT_DFT, prompt_dft_string, prompt_dft_string},
    {FORCE_PROMPT_YES, prompt_yes_string, prompt_yes_string},
    {FORCE_PROMPT_NO, prompt_no_string, prompt_no_string},
    {0, 0, 0}
};

static const char *cookie_prompt_string = RC_FORCE_COOKIE_PROMPT;

#ifdef USE_SSL
static const char *ssl_prompt_string = RC_FORCE_SSL_PROMPT;
#endif

static const char *user_mode_string = RC_USER_MODE;
static OptValues user_mode_values[] =
{
    {NOVICE_MODE, N_("Novice"), "Novice"},
    {INTERMEDIATE_MODE, N_("Intermediate"), "Intermediate"},
    {ADVANCED_MODE, N_("Advanced"), "Advanced"},
    {0, 0, 0}
};

static const char *vi_keys_string = RC_VI_KEYS;

static const char *visited_links_string = RC_VISITED_LINKS;
static OptValues visited_links_values[] =
{
    {VISITED_LINKS_AS_FIRST_V, N_("By First Visit"), "first_visited"},
    {VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
     N_("By First Visit Reversed"), "first_visited_reversed"},
    {VISITED_LINKS_AS_TREE, N_("As Visit Tree"), "visit_tree"},
    {VISITED_LINKS_AS_LATEST, N_("By Last Visit"), "last_visited"},
    {VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
     N_("By Last Visit Reversed"), "last_visited_reversed"},
    {0, 0, 0}
};

/*
 * Document Layout
 */
static const char *DTD_recovery_string = RC_TAGSOUP;
static OptValues DTD_type_values[] =
{
	/* Old_DTD variable */
    {TRUE, N_("relaxed (TagSoup mode)"), "tagsoup"},
    {FALSE, N_("strict (SortaSGML mode)"), "sortasgml"},
    {0, 0, 0}
};

static const char *bad_html_string = RC_BAD_HTML;
static OptValues bad_html_values[] =
{
    {BAD_HTML_IGNORE, N_("Ignore"), "ignore"},
    {BAD_HTML_TRACE, N_("Add to trace-file"), "trace"},
    {BAD_HTML_MESSAGE, N_("Add to LYNXMESSAGES"), "message"},
    {BAD_HTML_WARN, N_("Warn, point to trace-file"), "warn"},
    {0, 0, 0}
};

static const char *select_popups_string = RC_SELECT_POPUPS;
static const char *images_string = "images";
static const char *images_ignore_all_string = N_("ignore");
static const char *images_use_label_string = N_("as labels");
static const char *images_use_links_string = N_("as links");

static const char *verbose_images_string = RC_VERBOSE_IMAGES;
static OptValues verbose_images_type_values[] =
{
	/* verbose_img variable */
    {FALSE, N_("OFF"), "OFF"},
    {TRUE, N_("show filename"), "ON"},
    {0, 0, 0}
};

/*
 * Bookmark Options
 */
static const char *mbm_string = RC_MULTI_BOOKMARK;
static OptValues mbm_values[] =
{
    {MBM_OFF, N_("OFF"), "OFF"},
    {MBM_STANDARD, N_("STANDARD"), "STANDARD"},
    {MBM_ADVANCED, N_("ADVANCED"), "ADVANCED"},
    {0, 0, 0}
};

static const char *single_bookmark_string = RC_BOOKMARK_FILE;

#ifdef USE_SESSIONS
static const char *auto_session_string = RC_AUTO_SESSION;
static const char *single_session_string = RC_SESSION_FILE;
#endif

/*
 * Character Set Options
 */
static const char *assume_char_set_string = RC_ASSUME_CHARSET;
static const char *display_char_set_string = RC_CHARACTER_SET;
static const char *raw_mode_string = RC_RAW_MODE;

#ifdef USE_LOCALE_CHARSET
static const char *locale_charset_string = RC_LOCALE_CHARSET;
#endif

static const char *html5_charsets_string = RC_HTML5_CHARSETS;

/*
 * File Management Options
 */
static const char *show_dotfiles_string = RC_SHOW_DOTFILES;
static const char *no_pause_string = RC_NO_PAUSE;

#ifdef DIRED_SUPPORT
static const char *dired_list_string = RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] =
{
    {DIRS_FIRST, N_("Directories first"), "dired_dir"},
    {FILES_FIRST, N_("Files first"), "dired_files"},
    {MIXED_STYLE, N_("Mixed style"), "dired_mixed"},
    {0, 0, 0}
};

#ifdef LONG_LIST
static const char *dired_sort_string = RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] =
{
    {ORDER_BY_NAME, N_("By Name"), "dired_by_name"},
    {ORDER_BY_TYPE, N_("By Type"), "dired_by_type"},
    {ORDER_BY_SIZE, N_("By Size"), "dired_by_size"},
    {ORDER_BY_DATE, N_("By Date"), "dired_by_date"},
    {ORDER_BY_MODE, N_("By Mode"), "dired_by_mode"},
#ifndef NO_GROUPS
    {ORDER_BY_USER, N_("By User"), "dired_by_user"},
    {ORDER_BY_GROUP, N_("By Group"), "dired_by_group"},
#endif
    {0, 0, 0}
};
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

#ifndef DISABLE_FTP
static const char *passive_ftp_string = RC_FTP_PASSIVE;

static const char *ftp_sort_string = RC_FILE_SORTING_METHOD;
static OptValues ftp_sort_values[] =
{
    {FILE_BY_NAME, N_("By Name"), "ftp_by_name"},
    {FILE_BY_TYPE, N_("By Type"), "ftp_by_type"},
    {FILE_BY_SIZE, N_("By Size"), "ftp_by_size"},
    {FILE_BY_DATE, N_("By Date"), "ftp_by_date"},
    {0, 0, 0}
};
#endif

#ifdef USE_READPROGRESS
static const char *show_rate_string = RC_SHOW_KB_RATE;
static OptValues rate_values[] =
{
    {rateOFF, N_("Do not show rate"), "rate_off"},
    {rateBYTES, N_("Show %s/sec rate"), "rate_bytes"},
    {rateKB, N_("Show %s/sec rate"), "rate_kb"},
#ifdef USE_READPROGRESS
    {rateEtaBYTES, N_("Show %s/sec, ETA"), "rate_eta_bytes"},
    {rateEtaKB, N_("Show %s/sec, ETA"), "rate_eta_kb"},
    {rateEtaBYTES2, N_("Show %s/sec (2-digits), ETA"), "rate_eta_bytes2"},
    {rateEtaKB2, N_("Show %s/sec (2-digits), ETA"), "rate_eta_kb2"},
#endif
#ifdef USE_PROGRESSBAR
    {rateBAR, N_("Show progressbar"), "rate_bar"},
#endif
    {0, 0, 0}
};
#endif /* USE_READPROGRESS */

/*
 * Presentation (MIME) types used in "Accept".
 */
static const char *preferred_media_string = RC_PREFERRED_MEDIA_TYPES;
static OptValues media_values[] =
{
    {mediaOpt1, N_("Accept lynx's internal types"), "media_opt1"},
    {mediaOpt2, N_("Also accept lynx.cfg's types"), "media_opt2"},
    {mediaOpt3, N_("Also accept user's types"), "media_opt3"},
    {mediaOpt4, N_("Also accept system's types"), "media_opt4"},
    {mediaALL, N_("Accept all types"), "media_all"},
    {0, 0, 0}
};

static const char *preferred_encoding_string = RC_PREFERRED_ENCODING;
static OptValues encoding_values[] =
{
    {encodingNONE, N_("None"), "encoding_none"},
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    {encodingGZIP, N_("gzip"), "encoding_gzip"},
    {encodingDEFLATE, N_("deflate"), "encoding_deflate"},
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    {encodingCOMPRESS, N_("compress"), "encoding_compress"},
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    {encodingBZIP2, N_("bzip2"), "encoding_bzip2"},
#endif
    {encodingALL, N_("All"), "encoding_all"},
    {0, 0, 0}
};

/*
 * Headers transferred to remote server
 */
static const char *preferred_doc_char_string = RC_PREFERRED_CHARSET;
static const char *preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static const char *send_user_agent_string = RC_SEND_USERAGENT;
static const char *user_agent_string = RC_USERAGENT;

#define PutHeader(fp, Name) \
	fprintf(fp, "\n%s<em>%s</em>\n", MARGIN_STR, LYEntifyTitle(&buffer, Name));

#define PutCheckBox(fp, Name, Value, disable) \
	fprintf(fp,\
	"<input type=\"checkbox\" name=\"%s\" %s %s>\n",\
		Name, Value ? "checked" : "", disable_all?disabled_string:disable)

#define PutTextInput(fp, Name, Value, Size, disable) \
	fprintf(fp,\
	"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",\
		(int) Size, Name, Value, disable_all?disabled_string:disable)

#define PutOption(fp, flag, html, name) \
	fprintf(fp,"<option value=\"%s\" %s>%s\n", html, SELECTED(flag), gettext(name))

#define BeginSelect(fp, text) \
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:"")

#define MaybeSelect(fp, flag, text) \
	fprintf(fp,"<select name=\"%s\" %s>\n", text, disable_all?disabled_string:DISABLED(flag))

#define EndSelect(fp)\
	fprintf(fp,"</select>\n")

static void PutOptValues(FILE *fp, int value,
			 OptValues * table)
{
    while (table->LongName != 0) {
	if (table->HtmlName) {
	    PutOption(fp,
		      value == table->value,
		      table->HtmlName,
		      table->LongName);
	}
	table++;
    }
}

static BOOLEAN GetOptValues(OptValues * table, char *value,
			    int *result)
{
    while (table->LongName != 0) {
	if (table->HtmlName && !strcmp(value, table->HtmlName)) {
	    *result = table->value;
	    return TRUE;
	}
	table++;
    }
    return FALSE;
}

#ifdef USE_COLOR_STYLE
#ifdef LY_FIND_LEAKS
static void free_colorstyle_leaks(void)
{
    FREE(color_style_values);
}
#endif

void build_lss_enum(HTList *list)
{
    int count = HTList_count(list);

#ifdef LY_FIND_LEAKS
    atexit(free_colorstyle_leaks);
#endif

    FREE(color_style_values);
    if (count != 0) {
	LSS_NAMES *obj;
	int position = 0;

	color_style_values = typecallocn(OptValues, count + 2);

	if (color_style_values == NULL)
	    outofmem(__FILE__, "build_lss_enum");

	color_style_values[position++] = bool_values[0];
	while ((obj = HTList_objectAt(list, position - 1)) != 0) {
	    color_style_values[position].value = position;
	    color_style_values[position].LongName = obj->given;
	    color_style_values[position].HtmlName = obj->given;
	    position++;
	}
    }
    color_style_list = list;
}

/*
 * Find the current lss-file in the list, to get the default value for the
 * form.
 */
static int get_color_style_value(void)
{
    int result = 0;

    if (LYuse_color_style && non_empty(lynx_lss_file)) {
	LSS_NAMES *obj;
	int position = 1;

	while ((obj = HTList_objectAt(color_style_list, position - 1)) != 0) {
	    if (obj->actual != 0 && !strcmp(obj->actual, lynx_lss_file)) {
		result = position;
		break;
	    } else if (!strcmp(obj->given, lynx_lss_file)) {
		result = position;
		break;
	    }
	    ++position;
	}
    }
    return result;
}

/*
 * Return the pathname found in the given list-item.
 */
static char *get_color_style_config(int code)
{
    char *result = 0;

    if (LYuse_color_style) {
	LSS_NAMES *obj;

	if ((obj = HTList_objectAt(color_style_list, code - 1)) != 0) {
	    result = obj->actual;
	}
    }
    return result;
}
#endif

/*
 * Break cgi line into array of pairs of pointers.  Don't bother trying to
 * be efficient.  We're not called all that often.
 * We come in with a string looking like:
 * tag1=value1&tag2=value2&...&tagN=valueN
 * We leave with an array of post_pairs.  The last element in the array
 * will have a tag pointing to NULL.
 * Not pretty, but works.  Hey, if strings can be null terminate arrays...
 */
static PostPair *break_data(bstring *data)
{
    char *p;
    PostPair *q = NULL;
    int count = 0;

    if (isBEmpty(data))
	return NULL;

    p = BStrData(data);
    CTRACE((tfp, "break_data %s\n", p));

    q = typecalloc(PostPair);
    if (q == NULL)
	outofmem(__FILE__, "break_data(calloc)");

    assert(q != NULL);

    do {
	/*
	 * First, break up on '&', sliding 'p' on down the line.
	 */
	q[count].value = LYstrsep(&p, "&");
	/*
	 * Then break up on '=', sliding value down, and setting tag.
	 */
	q[count].tag = LYstrsep(&(q[count].value), "=");

	/*
	 * Clean them up a bit, in case user entered a funky string.
	 */
	HTUnEscape(q[count].tag);

	/* In the value field we have '+' instead of ' '. So do a simple
	 * find&replace on the value field before UnEscaping() - SKY
	 */
	{
	    size_t i, len;

	    len = strlen(q[count].value);
	    for (i = 0; i < len; i++) {
		if (q[count].value[i] == '+') {
#ifdef UNIX
		    /*
		     * Allow for special case of options which begin with a "+" on
		     * Unix - TD
		     */
		    if (i > 0
			&& q[count].value[i + 1] == '+'
			&& isalnum(UCH(q[count].value[i + 2]))) {
			q[count].value[i++] = ' ';
			i++;
			continue;
		    }
#endif
		    q[count].value[i] = ' ';
		}
	    }
	}
	HTUnEscape(q[count].value);
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n",
		count, q[count].tag, q[count].value));

	count++;
	/*
	 * Like I said, screw efficiency.  Sides, realloc is fast on
	 * Linux ;->
	 */
	q = typeRealloc(PostPair, q, (unsigned) (count + 1));
	if (q == NULL)
	    outofmem(__FILE__, "break_data(realloc)");

	assert(q != NULL);

	q[count].tag = NULL;
    } while (p != NULL && p[0] != '\0');
    return q;
}

static BOOL isLynxOptionsPage(const char *address, const char *portion)
{
    BOOL result = FALSE;

    if (!strncasecomp(address, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
	unsigned len = (unsigned) strlen(portion);

	address += LEN_LYNXOPTIONS;
	if (!strncasecomp(address, portion, (int) len)
	    && (address[len] == '\0' || LYIsHtmlSep(address[len]))) {
	    result = TRUE;
	}
    }
    return result;
}

static int gen_options(char **newfile);

/*
 * Handle options from the pseudo-post.  I think we really only need
 * post_data here, but bring along everything just in case.  It's only a
 * pointer.  MRC
 *
 * Options are processed in order according to gen_options(), we should not
 * depend on it and add boolean flags where the order is essential (save,
 * character sets...)
 *
 * Security:  some options are disabled in gen_options() under certain
 * conditions.  We *should* duplicate the same conditions here in postoptions()
 * to prevent user with a limited access from editing HTML options code
 * manually (e.g., doing 'e'dit in 'o'ptions) and submit it to access the
 * restricted items.  Prevent spoofing attempts from index overrun. - LP
 *
 * Exit status: NULLFILE (reload) or NORMAL (use HText cache).
 *
 * On exit, got the document which was current before the Options menu:
 *
 *   (from cache) nothing changed or no visual effect supposed:
 *             editor name, e-mail, etc.
 *
 *   (reload locally) to see the effect of certain changes:
 *             display_char_set, assume_charset, etc.
 *             (use 'need_reload' flag where necessary).
 *
 *   (reload from remote server and uncache on a proxy)
 *             few options changes should be transferred to remote server:
 *             preferred language, fake browser name, etc.
 *             (use 'need_end_reload' flag).
 */

int postoptions(DocInfo *newdoc)
{
    PostPair *data = 0;
    DocAddress WWWDoc;		/* need on exit */
    int i;
    int code = 0;
    BOOLEAN save_all = FALSE;
    int display_char_set_old = current_char_set;
    int old_media_value = LYAcceptMedia;
    BOOLEAN raw_mode_old = LYRawMode;
    BOOLEAN assume_char_set_changed = FALSE;
    BOOLEAN need_reload = FALSE;
    BOOLEAN need_end_reload = FALSE;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
    int CurrentShowColor = LYShowColor;
#endif
#ifdef USE_DEFAULT_COLORS
    BOOLEAN current_default_colors = LYuse_default_colors;
#endif

    /*-------------------------------------------------
     * kludge a link from mbm_menu, the URL was:
     * "<a href=\"" LYNXOPTIONS_PAGE(MBM_MENU) "\">Goto multi-bookmark menu</a>\n"
     *--------------------------------------------------*/

    if (isLynxOptionsPage(newdoc->address, MBM_LINK)) {
	FREE(newdoc->post_data);
	if (no_bookmark) {
	    HTAlert(BOOKMARK_CHANGE_DISALLOWED);	/* anonymous */
	    return (NULLFILE);
	} else if (dump_output_immediately) {
	    return (NOT_FOUND);
	} else {
	    edit_bookmarks();
	    return (NULLFILE);
	}
    } else if (!isLynxOptionsPage(newdoc->address, "/")) {
	HTAlert(RANDOM_URL_DISALLOWED);
	return NULLFILE;
    }

    data = break_data(newdoc->post_data);

    if (!data) {
	int status;

	/*-------------------------------------------------
	 * kludge gen_options() call:
	 *--------------------------------------------------*/
	status = gen_options(&newdoc->address);
	if (status != NORMAL) {
	    HTAlwaysAlert("Unexpected way of accessing", newdoc->address);
	    FREE(newdoc->address);
	    return (status);
	}

	/* exit to getfile() cycle */
	WWWDoc.address = newdoc->address;
	WWWDoc.post_data = newdoc->post_data;
	WWWDoc.post_content_type = newdoc->post_content_type;
	WWWDoc.bookmark = newdoc->bookmark;
	WWWDoc.isHEAD = newdoc->isHEAD;
	WWWDoc.safe = newdoc->safe;

	if (!HTLoadAbsolute(&WWWDoc))
	    return (NOT_FOUND);
	LYRegisterUIPage(newdoc->address, UIP_OPTIONS_MENU);
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	return (NORMAL);
    }

    if (!LYIsUIPage3(HTLoadedDocumentURL(), UIP_OPTIONS_MENU, 0) &&
	!LYIsUIPage3(HTLoadedDocumentURL(), UIP_VLINKS, 0)) {
	char *buf = NULL;

	/*  We may have been spoofed? */
	HTSprintf0(&buf,
		   gettext("Use %s to invoke the Options menu!"),
		   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
	HTAlert(buf);
	FREE(buf);
	FREE(data);
	return (NOT_FOUND);
    }

    /*
     * Checkbox will be missing from data if unchecked.
     */
    LYSendUserAgent = FALSE;

    for (i = 0; data[i].tag != NULL; i++) {
	/*
	 * This isn't really for security, but rather for avoiding that the
	 * user may revisit an older instance from the history stack and submit
	 * stuff which accidentally undoes changes that had been done from a
	 * newer instance.  - kw
	 */
	if (!strcmp(data[i].tag, secure_string)) {
	    if (!secure_value || strcmp(data[i].value, secure_value)) {
		char *buf = NULL;

		/*
		 * We probably came from an older instance of the Options
		 * page that had been on the history stack. - kw
		 */
		HTSprintf0(&buf,
			   gettext("Use %s to invoke the Options menu!"),
			   key_for_func_ext(LYK_OPTIONS, FOR_PANEL));
		HTAlert(buf);
		FREE(data);
		return (NULLFILE);
	    }
	    FREE(secure_value);
	}

	/* Save options */
	if (!strcmp(data[i].tag, save_options_string) && (!no_option_save)) {
	    save_all = TRUE;
	}

	/* Cookies: SELECT */
	if (!strcmp(data[i].tag, cookies_string)) {
	    if (!strcmp(data[i].value, cookies_ignore_all_string)) {
		LYSetCookies = FALSE;
	    } else if (!strcmp(data[i].value, cookies_up_to_user_string)) {
		LYSetCookies = TRUE;
		LYAcceptAllCookies = FALSE;
	    } else if (!strcmp(data[i].value, cookies_accept_all_string)) {
		LYSetCookies = TRUE;
		LYAcceptAllCookies = TRUE;
	    }
	}

	/* X Display: INPUT */
	if (!strcmp(data[i].tag, x_display_string)) {
	    LYsetXDisplay(data[i].value);
	    validate_x_display();
	    summarize_x_display(data[i].value);
	}

	/* Editor: INPUT */
	if (!strcmp(data[i].tag, editor_string)) {
	    FREE(editor);
	    StrAllocCopy(editor, data[i].value);
	}

	/* Emacs keys: ON/OFF */
	if (!strcmp(data[i].tag, emacs_keys_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    if ((emacs_keys = (BOOLEAN) code) != FALSE) {
		set_emacs_keys();
	    } else {
		reset_emacs_keys();
	    }
	}

	/* Execution links: SELECT */
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	if (!strcmp(data[i].tag, exec_links_string)
	    && GetOptValues(exec_links_values, data[i].value, &code)) {
#ifndef NEVER_ALLOW_REMOTE_EXEC
	    local_exec = (BOOLEAN) (code == EXEC_ALWAYS);
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
	    local_exec_on_local_files = (BOOLEAN) (code == EXEC_LOCAL);
	}
#endif /* ENABLE_OPTS_CHANGE_EXEC */

	/* Keypad Mode: SELECT */
	if (!strcmp(data[i].tag, keypad_mode_string)) {
	    int newval = 0;

	    if (GetOptValues(keypad_mode_values, data[i].value, &newval)
		&& keypad_mode != newval) {
		keypad_mode = newval;
		need_reload = TRUE;
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
	    }
	}

	/* Line edit style: SELECT */
	if (!strcmp(data[i].tag, lineedit_mode_string)) {
	    int newval = atoi(data[i].value);
	    int j;

	    /* prevent spoofing attempt */
	    for (j = 0; LYEditorNames[j]; j++) {
		if (j == newval)
		    current_lineedit = newval;
	    }
	}
#ifdef EXP_KEYBOARD_LAYOUT
	/* Keyboard layout: SELECT */
	if (!strcmp(data[i].tag, kblayout_string)) {
	    int newval = atoi(data[i].value);
	    int j;

	    /* prevent spoofing attempt */
	    for (j = 0; LYKbLayoutNames[j]; j++) {
		if (j == newval)
		    current_layout = newval;
	    }
	}
#endif /* EXP_KEYBOARD_LAYOUT */

	/* Mail Address: INPUT */
	if (!strcmp(data[i].tag, mail_address_string)) {
	    FREE(personal_mail_address);
	    StrAllocCopy(personal_mail_address, data[i].value);
	}
#ifndef NO_ANONYMOUS_EMAIL
	/* Personal Name: INPUT */
	if (!strcmp(data[i].tag, personal_name_string)) {
	    FREE(personal_mail_name);
	    StrAllocCopy(personal_mail_name, data[i].value);
	}
#endif

	/* Anonymous FTP Password: INPUT */
#ifndef DISABLE_FTP
	if (!strcmp(data[i].tag, anonftp_password_string)) {
	    FREE(anonftp_password);
	    StrAllocCopy(anonftp_password, data[i].value);
	}
#endif

	/* Search Type: SELECT */
	if (!strcmp(data[i].tag, search_type_string)
	    && GetOptValues(search_type_values, data[i].value, &code)) {
	    LYcase_sensitive = (BOOLEAN) code;
	}

	/* HTML error tolerance: SELECT */
	if (!strcmp(data[i].tag, DTD_recovery_string)
	    && GetOptValues(DTD_type_values, data[i].value, &code)) {
	    if (Old_DTD != code) {
		Old_DTD = code;
		HTSwitchDTD(!Old_DTD);
		need_reload = TRUE;
	    }
	}

	/* Bad HTML warnings: SELECT */
	if (!strcmp(data[i].tag, bad_html_string)
	    && GetOptValues(bad_html_values, data[i].value, &code)) {
	    cfg_bad_html = code;
	}

	/* Select Popups: ON/OFF */
	if (!strcmp(data[i].tag, select_popups_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYSelectPopups = (BOOLEAN) code;
	}
#if defined(USE_SLANG) || defined(COLOR_CURSES)
	/* Show Color: SELECT */
	if (!strcmp(data[i].tag, show_color_string)
	    && GetOptValues(show_color_values, data[i].value,
			    &LYChosenShowColor)) {
	    if (can_do_colors)
		LYShowColor = LYChosenShowColor;
	    if (CurrentShowColor != LYShowColor) {
		lynx_force_repaint();
	    }
#ifdef USE_SLANG
	    SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
#endif
	}
#endif /* USE_SLANG || COLOR_CURSES */

#ifdef USE_COLOR_STYLE
	/* Color Style: ON/OFF */
	if (!strcmp(data[i].tag, color_style_string)
	    && GetOptValues(color_style_values, data[i].value, &code)) {
	    if (code) {
		LYuse_color_style = TRUE;
		StrAllocCopy(lynx_lss_file, get_color_style_config(code));
		reinit_color_styles();
	    } else {
		LYuse_color_style = FALSE;
	    }
	    update_color_style();
	    lynx_force_repaint();
	}
#endif

#ifdef USE_DEFAULT_COLORS
	/* Default Colors: ON/OFF */
	if (!strcmp(data[i].tag, default_colors_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYuse_default_colors = (BOOLEAN) code;
	    if (current_default_colors != LYuse_default_colors) {
		CTRACE((tfp, "default_colors changed, updating colors...\n"));
		if (has_colors()) {
		    if (LYuse_default_colors) {
			use_default_colors();
		    } else {
			restart_curses();
		    }
		    update_default_colors();
		    lynx_force_repaint();
		}
	    }
	}
#endif

	/* Show Cursor: ON/OFF */
	if (!strcmp(data[i].tag, show_cursor_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowCursor = (BOOLEAN) code;
	}

	/* Underline links: ON/OFF */
	if (!strcmp(data[i].tag, underline_links_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYUnderlineLinks = (BOOLEAN) code;
	}
#ifdef USE_SCROLLBAR
	/* Show Scrollbar: ON/OFF */
	if (!strcmp(data[i].tag, show_scrollbar_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYShowScrollbar = (BOOLEAN) code;
	    need_reload = TRUE;
	}
#endif

	/* Cookie Prompting: SELECT */
	if (!strcmp(data[i].tag, cookie_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &cookie_noprompt);

#ifdef USE_SSL
	/* SSL Prompting: SELECT */
	if (!strcmp(data[i].tag, ssl_prompt_string))
	    GetOptValues(prompt_values, data[i].value, &ssl_noprompt);
#endif

	/* User Mode: SELECT */
	if (!strcmp(data[i].tag, user_mode_string)
	    && GetOptValues(user_mode_values, data[i].value, &user_mode)) {
	    LYSetDisplayLines();
	}

	/* Type of visited pages page: SELECT */
	if (!strcmp(data[i].tag, visited_links_string))
	    GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);

	/* Show Images: SELECT */
	if (!strcmp(data[i].tag, images_string)) {
	    if (!strcmp(data[i].value, images_ignore_all_string)
		&& !(pseudo_inline_alts == FALSE && clickable_images == FALSE)) {
		pseudo_inline_alts = FALSE;
		clickable_images = FALSE;
		need_reload = TRUE;
	    } else if (!strcmp(data[i].value, images_use_label_string)
		       && !(pseudo_inline_alts == TRUE && clickable_images == FALSE)) {
		pseudo_inline_alts = TRUE;
		clickable_images = FALSE;
		need_reload = TRUE;
	    } else if (!strcmp(data[i].value, images_use_links_string)
		       && !(clickable_images == TRUE)) {
		clickable_images = TRUE;
		need_reload = TRUE;
	    }
	}

	/* Verbose Images: ON/OFF */
	if (!strcmp(data[i].tag, verbose_images_string)
	    && GetOptValues(verbose_images_type_values, data[i].value, &code)) {
	    if (verbose_img != code) {
		verbose_img = (BOOLEAN) code;
		need_reload = TRUE;
	    }
	}

	/* VI Keys: ON/OFF */
	if (!strcmp(data[i].tag, vi_keys_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    if ((vi_keys = (BOOLEAN) code) != FALSE) {
		set_vi_keys();
	    } else {
		reset_vi_keys();
	    }
	}

	/* Bookmarks File Menu: SELECT */
	if (!strcmp(data[i].tag, mbm_string) && (!LYMBMBlocked)) {
	    GetOptValues(mbm_values, data[i].value, &LYMultiBookmarks);
	}

	/* Default Bookmarks filename: INPUT */
	if (!strcmp(data[i].tag, single_bookmark_string) && (!no_bookmark)) {
	    if (strcmp(data[i].value, "")) {
		FREE(bookmark_page);
		StrAllocCopy(bookmark_page, data[i].value);
	    }
	}
#ifdef USE_SESSIONS
	/* Auto Session: ON/OFF */
	if (!strcmp(data[i].tag, auto_session_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYAutoSession = (BOOLEAN) code;
	}

	/* Default Session filename: INPUT */
	if (!strcmp(data[i].tag, single_session_string)) {
	    if (strcmp(data[i].value, "")) {
		FREE(LYSessionFile);
		StrAllocCopy(LYSessionFile, data[i].value);
	    }
	}
#endif

	/* Assume Character Set: SELECT */
	if (!strcmp(data[i].tag, assume_char_set_string)) {
	    int newval = UCGetLYhndl_byMIME(data[i].value);

	    if (newval >= 0
		&& ((raw_mode_old &&
		     newval != safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset))
		    || (!raw_mode_old &&
			newval != UCLYhndl_for_unspec)
		)) {

		UCLYhndl_for_unspec = newval;
		StrAllocCopy(UCAssume_MIMEcharset, data[i].value);
		assume_char_set_changed = TRUE;
	    }
	}
#ifdef USE_LOCALE_CHARSET
	/* Use locale-based character set: ON/OFF */
	if (!strcmp(data[i].tag, locale_charset_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYLocaleCharset = (BOOLEAN) code;
	}
#endif
	/* Use HTML5 charset replacements: ON/OFF */
	if (!strcmp(data[i].tag, html5_charsets_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    html5_charsets = (BOOLEAN) code;
	    assume_char_set_changed = TRUE;
	}

	/* Display Character Set: SELECT */
	if (!strcmp(data[i].tag, display_char_set_string)) {
	    int newval = atoi(data[i].value);
	    int j;

	    /* prevent spoofing attempt */
	    for (j = 0; LYchar_set_names[j]; j++) {
		if (j == newval)
		    current_char_set = newval;
	    }
	}

	/* Raw Mode: ON/OFF */
	if (!strcmp(data[i].tag, raw_mode_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    LYRawMode = (BOOLEAN) code;
	}
#ifndef DISABLE_FTP
	/*
	 * passive ftp: ON/OFF
	 */
	if (!strcmp(data[i].tag, passive_ftp_string)) {
	    ftp_passive = (BOOLEAN) code;
	}

	/*
	 * ftp sort: SELECT
	 */
	if (!strcmp(data[i].tag, ftp_sort_string)) {
	    GetOptValues(ftp_sort_values, data[i].value, &HTfileSortMethod);
	}
#endif /* DISABLE_FTP */

#ifdef DIRED_SUPPORT
	/* Local Directory Style: SELECT */
	if (!strcmp(data[i].tag, dired_list_string)) {
	    GetOptValues(dired_list_values, data[i].value, &dir_list_style);
	}
#ifdef LONG_LIST
	/* Local Directory Order: SELECT */
	if (!strcmp(data[i].tag, dired_sort_string)) {
	    GetOptValues(dired_sort_values, data[i].value, &dir_list_order);
	}
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

	/* Show dot files: ON/OFF */
	if (!strcmp(data[i].tag, show_dotfiles_string) && (!no_dotfiles)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    show_dotfiles = (BOOLEAN) code;
	}

	/* Pause when showing messages: ON/OFF */
	if (!strcmp(data[i].tag, no_pause_string)
	    && GetOptValues(bool_values, data[i].value, &code)) {
	    no_pause = (BOOLEAN) !code;
	}
#ifdef USE_READPROGRESS
	/* Show Transfer Rate: enumerated value */
	if (!strcmp(data[i].tag, show_rate_string)
	    && GetOptValues(rate_values, data[i].value, &code)) {
	    LYTransferRate = code;
	}
#endif /* USE_READPROGRESS */

	/* Preferred Media Type: SELECT */
	if (!strcmp(data[i].tag, preferred_media_string)) {
	    GetOptValues(media_values, data[i].value, &LYAcceptMedia);
	}

	/* Preferred Encoding: SELECT */
	if (!strcmp(data[i].tag, preferred_encoding_string)) {
	    GetOptValues(encoding_values, data[i].value, &LYAcceptEncoding);
	}

	/* Preferred Document Character Set: INPUT */
	if (!strcmp(data[i].tag, preferred_doc_char_string)) {
	    if (strcmp(pref_charset, data[i].value)) {
		FREE(pref_charset);
		StrAllocCopy(pref_charset, data[i].value);
		need_end_reload = TRUE;
	    }
	}

	/* Preferred Document Language: INPUT */
	if (!strcmp(data[i].tag, preferred_doc_lang_string)) {
	    if (strcmp(language, data[i].value)) {
		FREE(language);
		StrAllocCopy(language, data[i].value);
		need_end_reload = TRUE;
	    }
	}

	/* Send User Agent: INPUT */
	if (!strcmp(data[i].tag, send_user_agent_string)) {
	    LYSendUserAgent = (BOOLEAN) !strcasecomp(data[i].value, "ON");
	}

	/* User Agent: INPUT */
	if (!strcmp(data[i].tag, user_agent_string) && (!no_useragent)) {
	    if (strcmp(LYUserAgent, data[i].value)) {
		need_end_reload = TRUE;
		FREE(LYUserAgent);
		/* ignore Copyright warning ? */
		StrAllocCopy(LYUserAgent,
			     *(data[i].value)
			     ? data[i].value
			     : LYUserAgentDefault);
		if (!LYCheckUserAgent()) {
		    HTAlert(UA_PLEASE_USE_LYNX);
		}
	    }
	}
    }				/* end of loop */

    /*
     * Process the flags:
     */
#ifdef USE_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif

    if (old_media_value != LYAcceptMedia)
	HTFilterPresentations();

    if (display_char_set_old != current_char_set ||
	raw_mode_old != LYRawMode ||
	assume_char_set_changed) {
	/*
	 * charset settings: the order is essential here.
	 */
	if (display_char_set_old != current_char_set) {
	    /*
	     * Set the LYUseDefaultRawMode value and character handling if
	     * LYRawMode was changed.  - FM
	     */
	    LYUseDefaultRawMode = TRUE;
	    HTMLUseCharacterSet(current_char_set);
#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Deduce whether the user wants autoswitch: */
	    switch_display_charsets =
		(current_char_set == auto_display_charset
		 || current_char_set == auto_other_display_charset);
#endif
	}
	if (assume_char_set_changed && HTCJK != JAPANESE) {
	    LYRawMode = (BOOLEAN) (UCLYhndl_for_unspec == current_char_set);
	}
	if (raw_mode_old != LYRawMode || assume_char_set_changed) {
	    /*
	     * Set the raw 8-bit or CJK mode defaults and character set if
	     * changed.  - FM
	     */
	    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
	    HTMLSetCharacterHandling(current_char_set);
	}
	need_reload = TRUE;
    }
    /* end of charset settings */
    /*
     * FIXME: Golly gee, we need to write all of this out now, don't we?
     */
    BStrFree(newdoc->post_data);
    FREE(data);
    if (save_all) {
	HTInfoMsg(SAVING_OPTIONS);
	LYrcShowColor = LYChosenShowColor;
	if (save_rc(NULL)) {
	    HTInfoMsg(OPTIONS_SAVED);
	} else {
	    HTAlert(OPTIONS_NOT_SAVED);
	}
    }

    /*
     * Exit:  working around the previous document.  Being out of
     * mainloop()/getfile() cycle, do things manually.
     */
    CTRACE((tfp, "\nLYOptions.c/postoptions(): exiting...\n"));
    CTRACE((tfp, "                            need_reload = %s\n",
	    need_reload ? "TRUE" : "FALSE"));
    CTRACE((tfp, "                            need_end_reload = %s\n",
	    need_end_reload ? "TRUE" : "FALSE"));

    /*  Options menu was pushed before postoptions(), so pop-up. */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    LYforce_no_cache = FALSE;	/* ! */
    LYoverride_no_cache = TRUE;	/* ! */
    /*
     * Working out of getfile() cycle we reset *no_cache manually here so
     * HTLoadAbsolute() will return "Document already in memory":  it was
     * forced reloading Options Menu again without this (overhead).
     *
     * Probably *no_cache was set in a wrong position because of
     * the internal page...
     */
    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);

    HTuncache_current_document();	/* will never use again */

    /*
     * Return to previous doc, not to options menu!  Reload the document we had
     * before the options menu but uncache only when necessary (Hurrah, user!):
     */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    LYforce_no_cache = FALSE;	/* see below */
    LYoverride_no_cache = TRUE;	/* see below */
    /*
     * Re-setting of *no_cache is probably not required here but this is a
     * guarantee against _double_ reloading over the net in case prev document
     * has its own "no cache" attribute and options menu set "need_reload"
     * also.  Force this HTLoadAbsolute() to return "Document already in
     * memory".
     */
    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);

    /*
     * Now most interesting part: reload document when necessary.
     * **********************************************************
     */

    reloading = FALSE;		/* set manually */
    /* force end-to-end reload from remote server if change LYUserAgent or
     * language or pref_charset (marked by need_end_reload flag above), from
     * old-style LYK_OPTIONS (mainloop):
     */
    if ((need_end_reload == TRUE &&
	 (StrNCmp(newdoc->address, "http", 4) == 0 ||
	  isLYNXCGI(newdoc->address) == 0))) {
	/*
	 * An option has changed which may influence content negotiation, and
	 * the resource is from a http or https or lynxcgi URL (the only
	 * protocols which currently do anything with this information).  Set
	 * reloading = TRUE so that proxy caches will be flushed, which is
	 * necessary until the time when all proxies understand HTTP 1.1 Vary: 
	 * and all Servers properly use it...  Treat like case LYK_RELOAD (see
	 * comments there).  - KW
	 */
	reloading = TRUE;	/* global flag */
	need_reload = TRUE;	/* this was probably already TRUE, don't worry */
    }

    if (need_reload == FALSE) {
	/*  no uncache, already loaded */
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
	return (NORMAL);
    } else {
	/*  update HText cache */

	/*
	 * see LYK_RELOAD & LYK_OPTIONS in mainloop for details...
	 */
	if (HTisDocumentSource()) {
	    srcmode_for_next_retrieval(1);
	}
#ifdef USE_SOURCE_CACHE
	if (reloading == FALSE) {
	    /* one more attempt to be smart enough: */
	    if (HTcan_reparse_document()) {
		if (!HTreparse_document())
		    srcmode_for_next_retrieval(0);
		CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
		return (NORMAL);
	    }
	}
#endif
	if (newdoc->post_data != NULL && !newdoc->safe &&
	    confirm_post_resub(newdoc->address, newdoc->title, 2, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    if (HTisDocumentSource()) {
		srcmode_for_next_retrieval(0);
	    }
	    return (NORMAL);
	}

	HEAD_request = HTLoadedDocumentIsHEAD();
	/*  uncache and load again */
	HTuncache_current_document();
	LYpush(newdoc, FALSE);
	CTRACE((tfp, "LYOptions.c/postoptions(): now really exit.\n\n"));
	return (NULLFILE);
    }

    /******** Done! **************************************************/
}

static char *NewSecureValue(void)
{
    static char oops[] = "?";

    FREE(secure_value);
    if ((secure_value = typeMallocn(char, 80)) != 0) {
#if defined(RAND_MAX)
	long key = lynx_rand();

#else
	long key = (long) secure_value + (long) time(0);
#endif
	sprintf(secure_value, "%ld", key);
	return secure_value;
    }
    return oops;
}

#define LABEL_LEN 33

/*
 * Note: the 'value' we are passing here is a local copy of the "same" string
 * as is used in LYrcFile.c to index the savable options.
 */
static void PutLabel(FILE *fp, const char *name,
		     const char *value)
{
    int have = (int) strlen(name);
    int want = LABEL_LEN;
    int need = LYstrExtent(name, have, want);
    char *buffer = NULL;

    fprintf(fp, "%s%s", MARGIN_STR, LYEntifyTitle(&buffer, name));

    if (will_save_rc(value) && !no_option_save) {
	while (need++ < want)
	    fprintf(fp, "&nbsp;");
    } else {
	want -= 3;
	if (need < want) {
	    fprintf(fp, "&nbsp;");
	    ++need;
	}
	fprintf(fp, "(!)");
	while (need++ < want) {
	    fprintf(fp, "&nbsp;");
	}
    }
    fprintf(fp, ": ");
    FREE(buffer);
}

/*
 * For given a list of the .lynxrc names for boolean flags that make up a
 * composite setting, check if any are not writable for the .lynxrc file.  If
 * so, return that name, so the subsequence will_save_rc() check in PutLabel()
 * will flag the composite as not-saved.
 */
static const char *check_if_write_lynxrc(STRING2PTR table)
{
    int n;
    const char *result = NULL;

    for (n = 0; table[n] != 0; ++n) {
	result = table[n];
	if (!will_save_rc(result))
	    break;
    }
    return result;
}

/*
 * The options menu treats "Cookies" as a single enumeration, but it is read
 * from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any are
 * not writable to .lynxrc, so we can show the user. 
 */
static const char *will_save_cookies(void)
{
    static const char *table[] =
    {
	RC_SET_COOKIES,		/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,	/* LYAcceptAllCookies */
	NULL
    };

    return check_if_write_lynxrc(table);
}

/*
 * The options menu treats "Show images" as a single enumeration, but it is
 * read from lynx.cfg (and perhaps .lynxrc) as a set of booleans.  Check if any
 * are not writable to .lynxrc, so we can show the user. 
 */
static const char *will_save_images(void)
{
    static const char *table[] =
    {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES,	/* pseudo_inline_alts */
	RC_MAKE_LINKS_FOR_ALL_IMAGES,	/* clickable_images */
	NULL
    };

    return check_if_write_lynxrc(table);
}

/*
 * The visited-links menu is used from the visited-links page as well as the
 * options page.
 */
void LYMenuVisitedLinks(FILE *fp0, int disable_all)
{
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);
}

/*
 * Okay, someone wants to change options.  So, let's gen up a form for them
 * and pass it around.  Gor, this is ugly.  Be a lot easier in Bourne with
 * "here" documents.  :->
 * Basic Strategy:  For each option, throw up the appropriate type of
 * control, giving defaults as appropriate.  If nothing else, we're
 * probably going to test every control there is.  MRC
 *
 * This function is synchronized with postoptions().  Read the comments in
 * postoptions() header if you change something in gen_options().
 */
static int gen_options(char **newfile)
{
    static char tempfile[LY_MAXPATH] = "\0";

    int i;
    char *buffer = NULL;
    BOOLEAN disable_all = FALSE;
    FILE *fp0;
    size_t cset_len = 0;
    size_t text_len = (size_t) ((LYcolLimit > 45)
				? LYcolLimit - (LABEL_LEN + 2 + MARGIN_LEN)
				: 7);	/* cf: PutLabel */

    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (NOT_FOUND);

    LYLocalFileToURL(newfile, tempfile);

    /* This should not be needed if we regenerate the temp file every time with
     * a new name, which just happened above in the case
     * LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code at the
     * end of postoptions() may remove an older cached version from memory if
     * that version of the page was left by submitting changes.  - kw
     * 1999-11-27
     * If access to the actual file via getfile() later fails (maybe because of
     * some restrictions), mainloop may leave this flag on after popping the
     * previous doc which is then unnecessarily reloaded.  But I changed
     * mainloop to reset the flag.  - kw 1999-05-24
     */
    LYforce_no_cache = TRUE;

    /*
     * Without LYUseFormsOptions set we should maybe not even get here.
     * However, it's possible we do; disable the form in that case. - kw
     */
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions)
	disable_all = TRUE;
#endif

    BeginInternalPage(fp0, OPTIONS_TITLE, NULL);	/* help link below */

    /*
     * I do C, not HTML.  Feel free to pretty this up.
     */
    fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", STR_LYNXOPTIONS);
    /*
     * use following with some sort of one shot secret key akin to NCSA
     * (or was it CUTE?) telnet one shot password to allow ftp to self.
     * to prevent spoofing.
     */
    fprintf(fp0, "<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
	    secure_string, NewSecureValue());

    /*
     * visible text begins here
     */

    /* Submit/Reset/Help */
    fprintf(fp0, "<p align=center>\n");
    if (!disable_all) {
	fprintf(fp0,
		"<input type=\"submit\" value=\"%s\"> - \n",
		LYEntifyValue(&buffer, ACCEPT_CHANGES));
	fprintf(fp0,
		"<input type=\"reset\" value=\"%s\"> - \n",
		LYEntifyValue(&buffer, RESET_CHANGES));
	fprintf(fp0,
		"%s - \n",
		LYEntifyTitle(&buffer, CANCEL_CHANGES));
    }
    fprintf(fp0, "<a href=\"%s%s\">%s</a>\n",
	    helpfilepath, LYEntifyTitle(&buffer, OPTIONS_HELP), TO_HELP);

    /* Save options */
    if (!no_option_save) {
	if (!disable_all) {
	    fprintf(fp0, "<p align=center>%s: ", LYEntifyTitle(&buffer, SAVE_OPTIONS));
	    fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
		    save_options_string);
	}
	fprintf(fp0, "<br>%s\n",
		LYEntifyTitle(&buffer,
			      gettext("(options marked with (!) will not be saved)")));
    }

    /*
     * preformatted text follows
     */
    fprintf(fp0, "<pre>\n");

    PutHeader(fp0, gettext("General Preferences"));
    /*****************************************************************/

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"), user_mode_string);
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"), editor_string);
    PutTextInput(fp0, editor_string, NonNull(editor), text_len,
		 DISABLED(no_editor || system_editor));

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Type of Search"), search_type_string);
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, LYcase_sensitive, search_type_values);
    EndSelect(fp0);

    PutHeader(fp0, gettext("Security and Privacy"));
    /*****************************************************************/

    /* Cookies: SELECT */
    PutLabel(fp0, gettext("Cookies"), will_save_cookies());
    BeginSelect(fp0, cookies_string);
    PutOption(fp0, !LYSetCookies,
	      cookies_ignore_all_string,
	      cookies_ignore_all_string);
    PutOption(fp0, LYSetCookies && !LYAcceptAllCookies,
	      cookies_up_to_user_string,
	      cookies_up_to_user_string);
    PutOption(fp0, LYSetCookies && LYAcceptAllCookies,
	      cookies_accept_all_string,
	      cookies_accept_all_string);
    EndSelect(fp0);

    /* Cookie Prompting: SELECT */
    PutLabel(fp0, gettext("Invalid-Cookie Prompting"), cookie_prompt_string);
    BeginSelect(fp0, cookie_prompt_string);
    PutOptValues(fp0, cookie_noprompt, prompt_values);
    EndSelect(fp0);

#ifdef USE_SSL
    /* SSL Prompting: SELECT */
    PutLabel(fp0, gettext("SSL Prompting"), ssl_prompt_string);
    BeginSelect(fp0, ssl_prompt_string);
    PutOptValues(fp0, ssl_noprompt, prompt_values);
    EndSelect(fp0);
#endif

    PutHeader(fp0, gettext("Keyboard Input"));
    /*****************************************************************/

    /* Keypad Mode: SELECT */
    PutLabel(fp0, gettext("Keypad mode"), keypad_mode_string);
    BeginSelect(fp0, keypad_mode_string);
    PutOptValues(fp0, keypad_mode, keypad_mode_values);
    EndSelect(fp0);

    /* Emacs keys: ON/OFF */
    PutLabel(fp0, gettext("Emacs keys"), emacs_keys_string);
    BeginSelect(fp0, emacs_keys_string);
    PutOptValues(fp0, emacs_keys, bool_values);
    EndSelect(fp0);

    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"), vi_keys_string);
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
    EndSelect(fp0);

    /* Line edit style: SELECT */
    if (LYEditorNames[1]) {	/* well, at least 2 line edit styles available */
	PutLabel(fp0, gettext("Line edit style"), lineedit_mode_string);
	BeginSelect(fp0, lineedit_mode_string);
	for (i = 0; LYEditorNames[i]; i++) {
	    char temp[16];

	    sprintf(temp, "%d", i);
	    PutOption(fp0, i == current_lineedit, temp, LYEditorNames[i]);
	}
	EndSelect(fp0);
    }
#ifdef EXP_KEYBOARD_LAYOUT
    /* Keyboard layout: SELECT */
    PutLabel(fp0, gettext("Keyboard layout"), kblayout_string);
    BeginSelect(fp0, kblayout_string);
    for (i = 0; LYKbLayoutNames[i]; i++) {
	char temp[16];

	sprintf(temp, "%d", i);
	PutOption(fp0, i == current_layout, temp, LYKbLayoutNames[i]);
    }
    EndSelect(fp0);
#endif /* EXP_KEYBOARD_LAYOUT */

    /*
     * Display and Character Set
     */
    PutHeader(fp0, gettext("Display and Character Set"));
    /*****************************************************************/

#ifdef USE_LOCALE_CHARSET
    /* Use locale-based character set: ON/OFF */
    PutLabel(fp0, gettext("Use locale-based character set"), locale_charset_string);
    BeginSelect(fp0, locale_charset_string);
    PutOptValues(fp0, LYLocaleCharset, bool_values);
    EndSelect(fp0);
#else
#define LYLocaleCharset FALSE
#endif
    PutLabel(fp0, gettext("Use HTML5 charset replacements"), html5_charsets_string);
    BeginSelect(fp0, html5_charsets_string);
    PutOptValues(fp0, html5_charsets, bool_values);
    EndSelect(fp0);

    /* Display Character Set: SELECT */
    PutLabel(fp0, gettext("Display character set"), display_char_set_string);
    MaybeSelect(fp0, LYLocaleCharset, display_char_set_string);
    for (i = 0; LYchar_set_names[i]; i++) {
	char temp[10];
	size_t len = strlen(LYchar_set_names[i]);

	if (len > cset_len)
	    cset_len = len;
	sprintf(temp, "%d", i);
#ifdef USE_CHARSET_CHOICE
	if (!charset_subsets[i].hide_display)
#endif
	    PutOption(fp0, i == current_char_set, temp, LYchar_set_names[i]);
    }
    EndSelect(fp0);

    /* Assume Character Set: SELECT */
    {
	int curval;

	curval = UCLYhndl_for_unspec;

	/*
	 * FIXME: If bogus value in lynx.cfg, then in old way, that is the
	 * string that was displayed.  Now, user will never see that.  Good
	 * or bad?  I don't know.  MRC
	 */
	if (curval == current_char_set) {
	    /* ok, LYRawMode, so use UCAssume_MIMEcharset */
	    curval = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
	}
	PutLabel(fp0, gettext("Assumed document character set"), assume_char_set_string);
	BeginSelect(fp0, assume_char_set_string);
	for (i = 0; i < LYNumCharsets; i++) {
#ifdef USE_CHARSET_CHOICE
	    if (!charset_subsets[i].hide_assumed)
#endif
		PutOption(fp0, i == curval,
			  LYCharSet_UC[i].MIMEname,
			  LYCharSet_UC[i].MIMEname);
	}
	EndSelect(fp0);
    }

    /* Raw Mode: ON/OFF */
    if (LYHaveCJKCharacterSet) {
	/*
	 * Since CJK people hardly mixed with other world
	 * we split the header to make it more readable:
	 * "CJK mode" for CJK display charsets, and "Raw 8-bit" for others.
	 */
	PutLabel(fp0, gettext("CJK mode"), raw_mode_string);
    } else {
	PutLabel(fp0, gettext("Raw 8-bit"), raw_mode_string);
    }

    BeginSelect(fp0, raw_mode_string);
    PutOptValues(fp0, LYRawMode, bool_values);
    EndSelect(fp0);

    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"), x_display_string);
    PutTextInput(fp0, x_display_string, NonNull(x_display), text_len, "");

    /*
     * Document Appearance
     */
    PutHeader(fp0, gettext("Document Appearance"));
    /*****************************************************************/

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    SetupChosenShowColor();
    PutLabel(fp0, gettext("Show color"), show_color_string);
    if (no_option_save) {
	MaybeSelect(fp0, !can_do_colors, show_color_string);
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor - SHOW_COLOR_OFF, bool_values);
    } else {
	BeginSelect(fp0, show_color_string);
	if (can_do_colors) {
	    show_color_values[2].HtmlName = on_string;
	    show_color_values[3].LongName = always_string;
	} else {
	    show_color_values[2].HtmlName = NULL;	/* suppress "ON" - kw */
	    show_color_values[3].LongName = "Always try";
	}
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

#ifdef USE_COLOR_STYLE
    /* Color style: ON/OFF */
    PutLabel(fp0, gettext("Color style"), color_style_string);
    BeginSelect(fp0, color_style_string);
    PutOptValues(fp0, get_color_style_value(), color_style_values);
    EndSelect(fp0);
#endif

#ifdef USE_DEFAULT_COLORS
    /* Default colors: ON/OFF */
    if (has_colors()) {
	PutLabel(fp0, gettext("Default colors"), default_colors_string);
	BeginSelect(fp0, default_colors_string);
	PutOptValues(fp0, LYuse_default_colors, bool_values);
	EndSelect(fp0);
    }
#endif

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"), show_cursor_string);
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
    EndSelect(fp0);

    /* Underline links: ON/OFF */
    PutLabel(fp0, gettext("Underline links"), underline_links_string);
    BeginSelect(fp0, underline_links_string);
    PutOptValues(fp0, LYUnderlineLinks, bool_values);
    EndSelect(fp0);

#ifdef USE_SCROLLBAR
    /* Show scrollbar: ON/OFF */
    PutLabel(fp0, gettext("Show scrollbar"), show_scrollbar_string);
    BeginSelect(fp0, show_scrollbar_string);
    PutOptValues(fp0, LYShowScrollbar, bool_values);
    EndSelect(fp0);
#endif

    /* Select Popups: ON/OFF */
    PutLabel(fp0, gettext("Popups for select fields"), select_popups_string);
    BeginSelect(fp0, select_popups_string);
    PutOptValues(fp0, LYSelectPopups, bool_values);
    EndSelect(fp0);

    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"), DTD_recovery_string);
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
    EndSelect(fp0);

    /* Bad HTML messages: SELECT */
    PutLabel(fp0, gettext("Bad HTML messages"), bad_html_string);
    BeginSelect(fp0, bad_html_string);
    PutOptValues(fp0, cfg_bad_html, bad_html_values);
    EndSelect(fp0);

    /* Show Images: SELECT */
    PutLabel(fp0, gettext("Show images"), will_save_images());
    BeginSelect(fp0, images_string);
    PutOption(fp0, !pseudo_inline_alts && !clickable_images,
	      images_ignore_all_string,
	      images_ignore_all_string);
    PutOption(fp0, pseudo_inline_alts && !clickable_images,
	      images_use_label_string,
	      images_use_label_string);
    PutOption(fp0, clickable_images,
	      images_use_links_string,
	      images_use_links_string);
    EndSelect(fp0);

    /* Verbose Images: ON/OFF */
    PutLabel(fp0, gettext("Verbose images"), verbose_images_string);
    BeginSelect(fp0, verbose_images_string);
    PutOptValues(fp0, verbose_img, verbose_images_type_values);
    EndSelect(fp0);

    /*
     * Headers Transferred to Remote Servers
     */
    PutHeader(fp0, gettext("Headers Transferred to Remote Servers"));
    /*****************************************************************/

    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"), mail_address_string);
    PutTextInput(fp0, mail_address_string,
		 NonNull(personal_mail_address), text_len, "");

#ifndef NO_ANONYMOUS_EMAIL
    PutLabel(fp0, gettext("Personal name for mail"), personal_name_string);
    PutTextInput(fp0, personal_name_string,
		 NonNull(personal_mail_name), text_len, "");
#endif

    /* Anonymous FTP Address: INPUT */
#ifndef DISABLE_FTP
    PutLabel(fp0, gettext("Password for anonymous ftp"), anonftp_password_string);
    PutTextInput(fp0, anonftp_password_string,
		 NonNull(anonftp_password), text_len, "");
#endif

    /* Preferred media type: SELECT */
    PutLabel(fp0, gettext("Preferred media type"), preferred_media_string);
    BeginSelect(fp0, preferred_media_string);
    PutOptValues(fp0, LYAcceptMedia, media_values);
    EndSelect(fp0);

    /* Preferred encoding: SELECT */
    PutLabel(fp0, gettext("Preferred encoding"), preferred_encoding_string);
    BeginSelect(fp0, preferred_encoding_string);
    PutOptValues(fp0, LYAcceptEncoding, encoding_values);
    EndSelect(fp0);

    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"), preferred_doc_char_string);
    PutTextInput(fp0, preferred_doc_char_string,
		 NonNull(pref_charset), cset_len + 2, "");

    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"), preferred_doc_lang_string);
    PutTextInput(fp0, preferred_doc_lang_string,
		 NonNull(language), cset_len + 2, "");

    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("Send User-Agent header"), send_user_agent_string);
	PutCheckBox(fp0, send_user_agent_string, LYSendUserAgent, "");
	PutLabel(fp0, gettext("User-Agent header"), user_agent_string);
	PutTextInput(fp0, user_agent_string,
		     NonNull(LYUserAgent), text_len, "");
    }

    /*
     * Listing and Accessing Files
     */
    PutHeader(fp0, gettext("Listing and Accessing Files"));
    /*****************************************************************/

#ifndef DISABLE_FTP
    /* FTP sort: SELECT */
    PutLabel(fp0, gettext("Use Passive FTP"), passive_ftp_string);
    BeginSelect(fp0, passive_ftp_string);
    PutOptValues(fp0, ftp_passive, bool_values);
    EndSelect(fp0);

    /* FTP sort: SELECT */
    PutLabel(fp0, gettext("FTP sort criteria"), ftp_sort_string);
    BeginSelect(fp0, ftp_sort_string);
    PutOptValues(fp0, HTfileSortMethod, ftp_sort_values);
    EndSelect(fp0);
#endif /* DISABLE_FTP */

#ifdef DIRED_SUPPORT
    /* Local Directory Sort: SELECT */
    PutLabel(fp0, gettext("Local directory sort criteria"), dired_list_string);
    BeginSelect(fp0, dired_list_string);
    PutOptValues(fp0, dir_list_style, dired_list_values);
    EndSelect(fp0);
#ifdef LONG_LIST
    /* Local Directory Order: SELECT */
    PutLabel(fp0, gettext("Local directory sort order"), dired_sort_string);
    BeginSelect(fp0, dired_sort_string);
    PutOptValues(fp0, dir_list_order, dired_sort_values);
    EndSelect(fp0);
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

    /* Show dot files: ON/OFF */
    if (!no_dotfiles) {
	PutLabel(fp0, gettext("Show dot files"), show_dotfiles_string);
	BeginSelect(fp0, show_dotfiles_string);
	PutOptValues(fp0, show_dotfiles, bool_values);
	EndSelect(fp0);
    }

    /* Execution links: SELECT */
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PutLabel(fp0, gettext("Execution links"), exec_links_string);
    BeginSelect(fp0, exec_links_string);
#ifndef NEVER_ALLOW_REMOTE_EXEC
    PutOptValues(fp0, local_exec
		 ? EXEC_ALWAYS
		 : (local_exec_on_local_files
		    ? EXEC_LOCAL
		    : EXEC_NEVER),
		 exec_links_values);
#else
    PutOptValues(fp0, local_exec_on_local_files
		 ? EXEC_LOCAL
		 : EXEC_NEVER,
		 exec_links_values);
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
    EndSelect(fp0);
#endif /* ENABLE_OPTS_CHANGE_EXEC */

    PutLabel(fp0, gettext("Pause when showing message"), no_pause_string);
    BeginSelect(fp0, no_pause_string);
    PutOptValues(fp0, !no_pause, bool_values);
    EndSelect(fp0);

#ifdef USE_READPROGRESS
    /* Show transfer rate: SELECT */
    PutLabel(fp0, gettext("Show transfer rate"), show_rate_string);
    BeginSelect(fp0, show_rate_string);
    for (i = 0; rate_values[i].LongName != 0; ++i) {
	char *message = NULL;

	HTSprintf0(&message,
		   rate_values[i].LongName,
		   HTProgressUnits(rate_values[i].value));
	PutOption(fp0,
		  LYTransferRate == rate_values[i].value,
		  rate_values[i].HtmlName,
		  message);
	FREE(message);
    }
    EndSelect(fp0);
#endif /* USE_READPROGRESS */

    /*
     * Special Files and Screens
     */
    PutHeader(fp0, gettext("Special Files and Screens"));
    /*****************************************************************/

    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
	PutLabel(fp0, gettext("Multi-bookmarks"), mbm_string);
	BeginSelect(fp0, mbm_string);
	PutOptValues(fp0, LYMultiBookmarks, mbm_values);
	EndSelect(fp0);
    }

    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
	PutLabel(fp0, gettext("Review/edit Bookmarks files"), mbm_string);
	fprintf(fp0, "<a href=\"%s\">%s</a>\n",
		LYNXOPTIONS_PAGE(MBM_LINK),
		LYEntifyTitle(&buffer, gettext("Goto multi-bookmark menu")));
    } else {
	PutLabel(fp0, gettext("Bookmarks file"), single_bookmark_string);
	PutTextInput(fp0, single_bookmark_string,
		     NonNull(bookmark_page), text_len, "");
    }

#ifdef USE_SESSIONS
    /* Auto Session: ON/OFF */
    PutLabel(fp0, gettext("Auto Session"), auto_session_string);
    BeginSelect(fp0, auto_session_string);
    PutOptValues(fp0, LYAutoSession, bool_values);
    EndSelect(fp0);

    /* Session File Menu: INPUT */
    PutLabel(fp0, gettext("Session file"), single_session_string);
    PutTextInput(fp0, single_session_string,
		 NonNull(LYSessionFile), text_len, "");
#endif

    /* Visited Pages: SELECT */
    PutLabel(fp0, gettext("Visited Pages"), visited_links_string);
    LYMenuVisitedLinks(fp0, disable_all);

    if (!no_lynxcfg_info) {
	fprintf(fp0, "\n  %s<a href=\"%s\">lynx.cfg</a>.\n",
		LYEntifyTitle(&buffer, gettext("View the file ")),
		STR_LYNXCFG);
    }

    fprintf(fp0, "\n</pre>\n");

    /* Submit/Reset */
    if (!disable_all) {
	fprintf(fp0, "<p align=center>\n");
	fprintf(fp0,
		"<input type=\"submit\" value=\"%s\"> - \n",
		LYEntifyValue(&buffer, ACCEPT_CHANGES));
	fprintf(fp0,
		"<input type=\"reset\" value=\"%s\"> - \n",
		LYEntifyValue(&buffer, RESET_CHANGES));
	fprintf(fp0, "%s\n", LYEntifyTitle(&buffer, CANCEL_CHANGES));
    }

    /*
     * close HTML
     */
    fprintf(fp0, "</form>\n");
    EndInternalPage(fp0);

    FREE(buffer);

    LYCloseTempFP(fp0);
    return (NORMAL);
}

#endif /* !NO_OPTION_FORMS */
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYOptions.c,v 1.133 2009/06/07 18:24:50 tom Exp $ */
d28 4
d136 1
a136 1
			  const char **choices);
d139 1
a139 1
	(BOOLEAN) boolean_choice(status, line, column, (const char **)choices)
d142 1
a142 1
	boolean_choice(status, line, column, (const char **)choices)
d285 1
a285 1
    static const char *caseless_choices[] =
d351 1
a351 1
    char display_option[MAX_LINE];
d358 5
a362 2
    char *cp = NULL;
    BOOL use_assume_charset, old_use_assume_charset;
d405 1
a405 2
    old_use_assume_charset =
	use_assume_charset = (BOOLEAN) (user_mode == ADVANCED_MODE);
d409 1
d411 1
d467 1
a467 1
    LYaddstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");
d555 1
a555 1
    LYaddstr(LYLineeditNames[current_lineedit]);
d648 3
a650 3
		if (non_empty(editor))
		    LYstrncpy(display_option, editor, sizeof(display_option) - 1);
		else {		/* clear the NONE */
d653 1
a653 1
		    *display_option = '\0';
d658 1
a658 2
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
d664 1
a664 1
		} else if (*display_option == '\0') {
d668 2
a669 2
		    StrAllocCopy(editor, display_option);
		    LYaddstr(display_option);
d684 1
a684 1
		LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
d688 1
a688 1
		*display_option = '\0';
d693 1
a693 2
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
d705 1
a705 1
		 !CompareEnvVars(x_display, display_option))) {
d720 1
a720 1
	    } else if (*display_option == '\0') {
d736 1
a736 1
	    LYsetXDisplay(display_option);
a737 1
	    cp = NULL;
d740 1
a740 1
	    summarize_x_display(display_option);
d799 1
a799 3
		    LYstrncpy(display_option,
			      bookmark_page,
			      sizeof(display_option) - 1);
d803 1
a803 1
		    *display_option = '\0';
d808 1
a808 2
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
d811 1
d813 1
a813 1
		    ch == -1 || *display_option == '\0') {
d816 1
a816 2
		} else if (!LYPathOffHomeOK(display_option,
					    sizeof(display_option))) {
d824 1
a824 1
		    StrAllocCopy(bookmark_page, display_option);
d865 1
a865 3
		LYstrncpy(display_option,
			  personal_mail_address,
			  sizeof(display_option) - 1);
d869 1
a869 1
		*display_option = '\0';
d874 1
a874 2
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
d881 1
a881 1
	    } else if (*display_option == '\0') {
d885 2
a886 2
		StrAllocCopy(personal_mail_address, display_option);
		LYaddstr(display_option);
d899 3
a901 3
	    case_sensitive = LYChooseBoolean(case_sensitive,
					     L_SSEARCH, -1,
					     caseless_choices);
d1078 1
a1078 1
		LYstrncpy(display_option, language, sizeof(display_option) - 1);
d1082 1
a1082 1
		*display_option = '\0';
d1087 1
a1087 2
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
d1093 1
a1093 1
	    } else if (*display_option == '\0') {
d1097 2
a1098 2
		StrAllocCopy(language, display_option);
		LYaddstr(display_option);
d1112 1
a1112 3
		LYstrncpy(display_option,
			  pref_charset,
			  sizeof(display_option) - 1);
d1116 1
a1116 1
		*display_option = '\0';
d1121 1
a1121 2
	    ch = LYgetstr(display_option, VISIBLE,
			  sizeof(display_option), NORECALL);
d1127 1
a1127 1
	    } else if (*display_option == '\0') {
d1131 2
a1132 2
		StrAllocCopy(pref_charset, display_option);
		LYaddstr(display_option);
d1328 1
a1328 1
						LYLineeditNames);
d1332 1
a1332 1
						 LYLineeditNames,
d1337 1
a1337 1
		LYaddstr(LYLineeditNames[current_lineedit]);
d1443 1
a1443 3
		    LYstrncpy(display_option,
			      LYUserAgent,
			      sizeof(display_option) - 1);
d1447 1
a1447 1
		    *display_option = '\0';
d1452 1
a1452 2
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
d1459 1
a1459 1
		} else if (*display_option == '\0') {
d1465 2
a1466 2
		    StrAllocCopy(LYUserAgent, display_option);
		    LYaddstr(display_option);
d1576 2
d1580 1
a1580 1
static int widest_choice(const char **choices)
d1609 1
a1609 1
			  const char **choices)
d1769 1
a1769 1
    int response = 0, def_response = 0, ch;
d1774 1
a1774 1
    char MBM_tmp_line[LY_MAXPATH];	/* buffer for LYgetstr */
d1973 1
a1973 1
		    LYstrncpy(MBM_tmp_line,
d1975 2
a1976 4
			       "" : MBM_A_subdescript[a]),
			      sizeof(MBM_tmp_line) - 1);
		    ch = LYgetstr(MBM_tmp_line, VISIBLE,
				  sizeof(MBM_tmp_line), NORECALL);
d1979 1
a1979 1
		    if (strlen(MBM_tmp_line) < 1) {
d1982 1
a1982 1
			StrAllocCopy(MBM_A_subdescript[a], MBM_tmp_line);
d2009 2
a2010 5
		LYstrncpy(MBM_tmp_line,
			  NonNull(MBM_A_subbookmark[a]),
			  sizeof(MBM_tmp_line) - 1);
		ch = LYgetstr(MBM_tmp_line, VISIBLE,
			      sizeof(MBM_tmp_line), NORECALL);
d2013 1
a2013 1
		if (*MBM_tmp_line == '\0') {
a2017 4
		} else if (!LYPathOffHomeOK(MBM_tmp_line,
					    sizeof(MBM_tmp_line))) {
		    LYMBM_statusline(USE_PATH_OFF_HOME);
		    LYSleepAlert();
d2019 9
a2027 3
		    StrAllocCopy(MBM_A_subbookmark[a], MBM_tmp_line);
		    if (a == 0) {
			StrAllocCopy(bookmark_page, MBM_A_subbookmark[a]);
d2041 1
a2041 2
		LYmove(LYlines - 1, 0);
		LYclrtoeol();
d2047 1
d2063 1
a2063 1
		 const char **choices,
d2066 1
a2066 1
		 BOOLEAN for_mouse)
d2075 1
a2075 1
				   (const char **) choices,
d2185 1
d2211 10
d2337 2
d2397 2
d2499 81
d2605 2
d2660 3
d2673 1
a2673 1
	unsigned len = strlen(portion);
d2735 3
d2910 1
a2910 1
	    for (j = 0; LYLineeditNames[j]; j++) {
d2934 7
d2953 1
a2953 1
	    case_sensitive = (BOOLEAN) code;
a2986 1
	    CurrentShowColor = LYShowColor;
d2993 36
d3158 6
d3260 1
a3260 1
	    LYSendUserAgent = !strcasecomp(data[i].value, "ON");
d3406 1
a3406 1
	 (strncmp(newdoc->address, "http", 4) == 0 ||
d3523 1
a3523 1
static const char *check_if_write_lynxrc(const char **table)
d3700 1
a3700 1
    PutOptValues(fp0, case_sensitive, search_type_values);
d3756 1
a3756 1
    if (LYLineeditNames[1]) {	/* well, at least 2 line edit styles available */
d3759 1
a3759 1
	for (i = 0; LYLineeditNames[i]; i++) {
d3763 1
a3763 1
	    PutOption(fp0, i == current_lineedit, temp, LYLineeditNames[i]);
d3795 4
d3810 1
a3810 1
#ifdef EXP_CHARSET_CHOICE
d3835 1
a3835 1
#ifdef EXP_CHARSET_CHOICE
d3897 18
d3984 6
d3992 1
a3992 1
    PutLabel(fp0, gettext("Password for anonymous ftp"), mail_address_string);
d4189 1
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d26 1
d135 3
d287 2
d296 1
d347 1
a347 1
    char display_option[256];
d399 1
a399 1
	use_assume_charset = (BOOL) (user_mode == ADVANCED_MODE);
d537 1
a537 1
    LYaddstr(fields_are_numbered() && links_are_numbered()
d539 5
a543 5
	     : links_are_numbered()
	     ? "Links are numbered                "
	     : fields_are_numbered()
	     ? "Form fields are numbered          "
	     : "Numbers act as arrows             ");
d746 3
a748 3
		LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
						   L_HOME, C_MULTI,
						   mbm_choices);
d841 3
a843 3
		HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
						   L_FTPSTYPE, -1,
						   fileSort_choices);
d910 2
a911 1
		assume_list = typecallocn(const char *, (LYNumCharsets + 1));
d928 3
a930 3
			assumed_doc_charset_map[(LYChooseBoolean(charset_subsets[curval].assumed_idx,
								 L_ASSUME_CHARSET, -1,
								 assumed_charset_choices)
d935 3
a937 3
			LYChooseBoolean(curval,
					L_ASSUME_CHARSET, -1,
					assume_list);
d976 1
a976 1
			LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
d1004 3
a1006 3
		displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
								L_Charset, -1,
								display_charset_choices);
d1009 3
a1011 3
		current_char_set = LYChooseBoolean(current_char_set,
						   L_Charset, -1,
						   LYchar_set_names);
d1208 4
a1211 4
		LYShowColor = LYChooseBoolean((LYShowColor - 1),
					      L_Color,
					      C_COLOR,
					      bool_choices);
d1240 4
a1243 4
			chosen = LYChooseBoolean(LYChosenShowColor,
						 L_Color,
						 C_COLOR,
						 choices);
d1251 1
a1251 1
		    again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
d1304 3
a1306 3
		keypad_mode = LYChooseBoolean(keypad_mode,
					      L_Keypad, -1,
					      keypad_choices);
d1331 3
a1333 3
		current_lineedit = LYChooseBoolean(current_lineedit,
						   L_Lineed, -1,
						   LYLineeditNames);
d1354 3
a1356 3
		current_layout = LYChooseBoolean(current_layout,
						 L_Layout, -1,
						 LYKbLayoutNames);
d1378 3
a1380 3
		dir_list_style = LYChooseBoolean(dir_list_style,
						 L_Dired, -1,
						 dirList_choices);
d1401 4
a1404 4
		user_mode = LYChooseBoolean(user_mode,
					    L_User_Mode, -1,
					    userMode_choices);
		use_assume_charset = (BOOL) (user_mode >= 2);
d1410 1
a1410 1
		use_assume_charset = (BOOL) (user_mode >= 2);
d1419 1
a1419 5
	    if (user_mode == NOVICE_MODE) {
		display_lines = (LYlines - 4);
	    } else {
		display_lines = LYlines - 2;
	    }
d1433 5
a1437 5
		verbose_img = LYChoosePopup(verbose_img,
					    L_VERBOSE_IMAGES,
					    C_VERBOSE_IMAGES,
					    bool_choices,
					    2, FALSE, FALSE);
d1511 3
a1513 3
		itmp = LYChooseBoolean(itmp,
				       L_Exec, -1,
				       exec_choices);
d1591 1
a1591 1
	int len = strlen(choices[n]);
d1602 1
a1602 1
    int len = strlen(choice);
d1780 1
a1780 2
    char MBM_tmp_line[256];	/* buffer for LYgetstr */
    char ehead_buffer[265];
d1808 3
a1810 1
	sprintf(ehead_buffer, MULTIBOOKMARKS_EHEAD_MASK, MBM_current);
d1812 1
d2088 1
a2088 2
				   for_mouse,
				   TRUE);
d2194 3
d2198 2
a2199 1
static const char *search_type_string = RC_CASE_SENSITIVE_SEARCHING;
d2280 10
d2319 5
d2331 1
a2331 1
#ifdef EXP_LOCALE_CHARSET
d2339 1
d2369 3
d2381 1
d2394 3
d2438 1
d2442 6
a2447 1
	fprintf(fp, "\n%s<em>%s</em>\n", MARGIN_STR, Name);
d2568 1
a2568 1
	q = typeRealloc(PostPair, q, count + 1);
d2584 1
a2584 1
	if (!strncasecomp(address, portion, len)
d2711 5
d2775 1
a2775 1
	    if ((emacs_keys = (BOOL) code) != FALSE) {
d2787 1
a2787 1
	    local_exec = (code == EXEC_ALWAYS);
d2789 1
a2789 1
	    local_exec_on_local_files = (code == EXEC_LOCAL);
d2841 1
d2846 1
d2851 1
a2851 1
	    case_sensitive = (BOOL) code;
d2864 6
d2873 1
a2873 1
	    LYSelectPopups = (BOOL) code;
d2895 1
a2895 1
	    LYShowCursor = (BOOL) code;
d2901 1
a2901 1
	    LYUnderlineLinks = (BOOL) code;
d2907 1
a2907 1
	    LYShowScrollbar = (BOOL) code;
d2925 1
a2925 5
	    if (user_mode == NOVICE_MODE) {
		display_lines = (LYlines - 4);
	    } else {
		display_lines = LYlines - 2;
	    }
d2955 1
a2955 1
		verbose_img = (BOOL) code;
d2963 1
a2963 1
	    if ((vi_keys = (BOOL) code) != FALSE) {
d2982 15
d3014 1
a3014 1
#ifdef EXP_LOCALE_CHARSET
d3018 1
a3018 1
	    LYLocaleCharset = (BOOL) code;
d3037 8
a3044 1
	    LYRawMode = (BOOL) code;
d3053 2
d3071 7
a3077 1
	    show_dotfiles = (BOOL) code;
d3115 5
d3140 1
a3140 1
#ifdef EXP_LOCALE_CHARSET
d3168 1
a3168 1
	    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
d3349 1
a3349 1
    int have = strlen(name);
d3352 1
d3354 1
a3354 1
    fprintf(fp, "%s%s", MARGIN_STR, name);
d3371 1
d3451 2
d3454 1
a3454 1
    static char tempfile[LY_MAXPATH] = "\0";
d3458 3
a3460 3
    size_t text_len = ((LYcolLimit > 45)
		       ? LYcolLimit - (LABEL_LEN + 2 + MARGIN_LEN)
		       : 7);	/* cf: PutLabel */
d3510 9
a3518 3
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s - \n", CANCEL_CHANGES);
d3521 1
a3521 1
	    helpfilepath, OPTIONS_HELP, TO_HELP);
d3526 1
a3526 1
	    fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
d3531 2
a3532 1
		gettext("(options marked with (!) will not be saved)"));
d3643 1
a3643 1
#ifdef EXP_LOCALE_CHARSET
d3782 6
d3819 2
a3820 1
    /* Mail Address: INPUT */
d3824 1
d3850 2
d3863 7
d3875 1
d3920 5
d3962 2
a3963 1
		LYNXOPTIONS_PAGE(MBM_LINK), gettext("Goto multi-bookmark menu"));
d3970 13
d3989 1
a3989 1
		gettext("View the file "),
d3998 7
a4004 3
	fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0, "%s\n", CANCEL_CHANGES);
d4012 2
@


1.5
log
@update to lynx2.8.5rel.4; fixes CAN-2005-3120 among other things.
prompted by naddy@@, cloder@@ ok.
@
text
@d3 1
a3 1
#include <HTTP.h>  /* 'reloading' flag */
d30 2
a31 1
PRIVATE int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */
d33 2
a34 1
PRIVATE void terminate_options	PARAMS((int sig));
d36 3
a38 3
#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
#define COL_OPTION_VALUES 36  /* display column where option values start */
#endif
d41 1
a41 1
PRIVATE BOOLEAN can_do_colors = FALSE;
d44 3
a46 1
PUBLIC BOOLEAN LYCheckUserAgent NOARGS
d48 1
a48 1
    if (LYUserAgent && *LYUserAgent) {
d50 3
a52 3
	 && strstr(LYUserAgent, "lynx") == 0
	 && strstr(LYUserAgent, "L_y_n_x") == 0
	 && strstr(LYUserAgent, "l_y_n_x") == 0) {
d59 1
a59 1
PRIVATE void SetupChosenShowColor NOARGS
d61 1
a61 31
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = TRUE;
#if defined(COLOR_CURSES)
    if (LYCursesON)	/* could crash if called before initialization */
	can_do_colors = (BOOL) has_colors();
#endif
    if (!no_option_save) {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
    }
#endif /* USE_SLANG || COLOR_CURSES */
}
a62 3
PRIVATE void validate_x_display NOPARAMS
{
    char *cp;
d70 1
a70 2
PRIVATE void summarize_x_display ARGS1(
    char *,	display_option)
d90 35
d127 5
a131 5
PRIVATE int boolean_choice PARAMS((
	int		status,
	int		line,
	int		column,
	CONST char **	choices));
d133 1
a133 1
	boolean_choice(status, line, column, (CONST char **)choices)
d138 1
a138 1
 *  Values for the options menu. - FM
d140 3
a142 3
 *  L_foo values are the Y coordinates for the menu item.
 *  B_foo values are the X coordinates for the item's prompt string.
 *  C_foo values are the X coordinates for the item's value string.
d215 1
a215 1
PRIVATE int add_it ARGS2(char *, text, int, len)
d228 1
a228 1
PRIVATE void addlbl ARGS1(CONST char *, text)
d237 1
a237 1
	    d = add_it(actual, d-1);
d267 1
a267 1
PUBLIC void LYoptions NOARGS
d270 2
a271 1
    static char *bool_choices[] = {
d276 2
a277 1
    static char *caseless_choices[] = {
d282 2
a283 1
    static char *dirList_choices[] = {
d289 1
d291 2
a292 1
    static char *exec_choices[] = {
d297 1
a297 1
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
d301 2
a302 1
    static char *fileSort_choices[] = {
d309 2
a310 1
    static char *keypad_choices[] = {
d316 2
a317 1
    static char *mbm_choices[] = {
d323 2
a324 1
    static char *userMode_choices[] = {
d330 1
d335 1
d337 1
a337 1
     *	If the user changes the display we need memory to put it in.
d393 1
a393 1
draw_options:
d397 2
a398 2
     *	NOTE that printw() should be avoided for strings that
     *	might have non-ASCII or multibyte/CJK characters. - FM
d411 1
a411 1
    lynx_start_h1_color ();
d417 1
a417 1
    lynx_stop_h1_color ();
d420 1
a420 1
    LYaddstr((editor && *editor) ? editor : "NONE");
d424 1
a424 1
    LYaddstr((x_display && *x_display) ? x_display : "NONE");
d434 1
a434 1
	LYaddstr((bookmark_page && *bookmark_page) ? bookmark_page : "NONE");
d440 3
a442 3
	   (HTfileSortMethod == FILE_BY_SIZE ? "By Size    " :
	   (HTfileSortMethod == FILE_BY_TYPE ? "By Type    " :
					       "By Date    "))));
d446 2
a447 2
    LYaddstr((personal_mail_address && *personal_mail_address) ?
				       personal_mail_address : "NONE");
d459 1
a459 1
    LYaddstr((language && *language) ? language : "NONE");
d463 1
a463 1
    LYaddstr((pref_charset && *pref_charset) ? pref_charset : "NONE");
d473 1
a473 1
					      : "NONE");
d488 2
a489 2
		LYaddstr("NEVER     ");
		break;
d491 2
a492 2
		LYaddstr("OFF");
		break;
d494 2
a495 2
		LYaddstr("ON ");
		break;
d498 3
a500 3
		if (!has_colors())
		    LYaddstr("Always try");
		else
d502 1
a502 1
		    LYaddstr("ALWAYS    ");
d530 6
a535 6
		? "Links and form fields are numbered"
		: links_are_numbered()
		? "Links are numbered                "
		: fields_are_numbered()
		? "Form fields are numbered          "
		: "Numbers act as arrows             ");
d551 2
a552 2
	  ((dir_list_style == MIXED_STYLE) ? "Mixed style      " :
					     "Directories first"));
d557 3
a559 3
    LYaddstr(  (user_mode == NOVICE_MODE) ? "Novice      " :
      ((user_mode == INTERMEDIATE_MODE) ? "Intermediate" :
					  "Advanced    "));
d562 1
a562 1
    ShowBool( verbose_img);
d566 1
a566 1
    LYaddstr((LYUserAgent && *LYUserAgent) ? LYUserAgent : "NONE");
d572 3
a574 3
    LYaddstr(               local_exec ? "ALWAYS ON           " :
	  (local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
				       "ALWAYS OFF          "));
d577 1
a577 1
				       "ALWAYS OFF          ");
d581 1
a581 1
    LYmove(LYlines-3, 2);
d613 1
a613 1
	lynx_start_prompt_color ();
d615 1
a615 1
	lynx_stop_prompt_color ();
d626 9
a634 14
	    case 'E':	/* Change the editor. */
		if (no_editor) {
		    _statusline(EDIT_DISABLED);
		} else if (system_editor ) {
		    _statusline(EDITOR_LOCKED);
		} else {
		    if (editor && *editor)
			LYstrncpy(display_option, editor, sizeof(display_option) - 1);
		    else {  /* clear the NONE */
			LYmove(L_EDITOR, COL_OPTION_VALUES);
			LYaddstr("    ");
			*display_option = '\0';
		    }
		    _statusline(ACCEPT_DATA);
a635 31
		    lynx_start_bold();
		    ch = LYgetstr(display_option, VISIBLE,
				  sizeof(display_option), NORECALL);
		    lynx_stop_bold();
		    LYmove(L_EDITOR, COL_OPTION_VALUES);
		    if (term_options || ch == -1) {
			LYaddstr((editor && *editor) ?
					    editor : "NONE");
		    } else if (*display_option == '\0') {
			FREE(editor);
			LYaddstr("NONE");
		    } else {
			StrAllocCopy(editor, display_option);
			LYaddstr(display_option);
		    }
		    LYclrtoeol();
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		}
		response = ' ';
		break;

	    case 'D':	/* Change the display. */
		if (x_display && *x_display) {
		    LYstrncpy(display_option, x_display, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_DISPLAY, COL_OPTION_VALUES);
d640 1
a640 1
		LYmove(L_DISPLAY, COL_OPTION_VALUES);
d645 26
d672 10
d689 20
a708 3
		if ((term_options || ch == -1) ||
		    (x_display != NULL &&
		     !CompareEnvVars(x_display, display_option))) {
d710 1
a710 2
		     *	Cancelled, or a non-NULL display string
		     *	wasn't changed. - FM
d712 1
a712 1
		    LYaddstr((x_display && *x_display) ? x_display : "NONE");
d714 1
a714 6
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
a716 13
		} else if (*display_option == '\0') {
		    if ((x_display == NULL) ||
			(x_display != NULL && *x_display == '\0')) {
			/*
			 *  NULL or zero-length display string
			 *  wasn't changed. - FM
			 */
			LYaddstr("NONE");
			LYclrtoeol();
			_statusline(VALUE_ACCEPTED);
			response = ' ';
			break;
		    }
d718 16
a733 9
		/*
		 *  Set the new DISPLAY variable. - FM
		 */
		LYsetXDisplay(display_option);
		validate_x_display();
		cp = NULL;
		LYaddstr(x_display ? x_display : "NONE");
		LYclrtoeol();
		summarize_x_display(display_option);
d736 11
a746 17

	    case 'L':	/* Change multibookmarks option. */
		if (LYMBMBlocked) {
		    _statusline(MULTIBOOKMARKS_DISALLOWED);
		    response = ' ';
		    break;
		}
		if (!LYSelectPopups) {
		    LYMultiBookmarks = LYChooseBoolean(LYMultiBookmarks,
						      L_HOME, C_MULTI,
						      mbm_choices);
		} else {
		    LYMultiBookmarks = LYChoosePopup(LYMultiBookmarks,
						    L_HOME, (C_MULTI - 1),
						    mbm_choices,
						    3, FALSE, FALSE);
		}
d748 5
a752 5
		if (LYSelectPopups) {
		    LYmove(L_HOME, C_MULTI);
		    LYclrtoeol();
		    LYaddstr(mbm_choices[LYMultiBookmarks]);
		}
d755 1
a755 1
		if (!LYSelectPopups)
d757 9
a765 10
		{
		    LYmove(L_HOME, B_BOOK);
		    LYclrtoeol();
		    if (LYMultiBookmarks != MBM_OFF) {
			LYaddstr(gettext("review/edit B)ookmarks files"));
		    } else {
			LYaddstr(gettext("B)ookmark file: "));
			LYaddstr((bookmark_page && *bookmark_page) ?
						   bookmark_page : "NONE");
		    }
d767 6
a772 5
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d774 16
a789 24
	    case 'B':	/* Change the bookmark page location. */
		/*
		 *  Anonymous users should not be allowed to
		 *  change the bookmark page.
		 */
		if (!no_bookmark) {
		    if (LYMultiBookmarks != MBM_OFF) {
			edit_bookmarks();
			signal(SIGINT, terminate_options);
			goto draw_options;
		    }
		    if (bookmark_page && *bookmark_page) {
			LYstrncpy(display_option, bookmark_page, sizeof(display_option) - 1);
		    } else {  /* clear the NONE */
			LYmove(L_HOME, C_DEFAULT);
			LYclrtoeol();
			*display_option = '\0';
		    }
		    _statusline(ACCEPT_DATA);
		    LYmove(L_HOME, C_DEFAULT);
		    lynx_start_bold();
		    ch = LYgetstr(display_option, VISIBLE,
				  sizeof(display_option), NORECALL);
		    lynx_stop_bold();
a790 17
		    if (term_options ||
			ch == -1 || *display_option == '\0') {
			LYaddstr((bookmark_page && *bookmark_page) ?
						   bookmark_page : "NONE");
		    } else if (!LYPathOffHomeOK(display_option,
						sizeof(display_option))) {
			LYaddstr((bookmark_page && *bookmark_page) ?
						   bookmark_page : "NONE");
			LYclrtoeol();
			_statusline(USE_PATH_OFF_HOME);
			response = ' ';
			break;
		    } else {
			StrAllocCopy(bookmark_page, display_option);
			StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
			LYaddstr(bookmark_page);
		    }
a791 40
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		} else { /* anonymous */
		    _statusline(BOOKMARK_CHANGE_DISALLOWED);
		}
		response = ' ';
		break;

	    case 'F':	/* Change ftp directory sorting. */
		if (!LYSelectPopups) {
		    HTfileSortMethod = LYChooseBoolean(HTfileSortMethod,
						      L_FTPSTYPE, -1,
						      fileSort_choices);
		} else {
		    HTfileSortMethod = LYChoosePopup(HTfileSortMethod,
						    L_FTPSTYPE, -1,
						    fileSort_choices,
						    4, FALSE, FALSE);
#if defined(VMS) || defined(USE_SLANG)
		    LYmove(L_FTPSTYPE, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(fileSort_choices[HTfileSortMethod]);
#endif /* VMS || USE_SLANG */
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;

	    case 'P': /* Change personal mail address for From headers. */
		if (personal_mail_address && *personal_mail_address) {
		    LYstrncpy(display_option, personal_mail_address, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		    LYaddstr("    ");
d795 1
a795 1
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d800 13
a812 8
		LYmove(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((personal_mail_address &&
			    *personal_mail_address) ?
			      personal_mail_address : "NONE");
		} else if (*display_option == '\0') {
		    FREE(personal_mail_address);
		    LYaddstr("NONE");
d814 3
a816 2
		    StrAllocCopy(personal_mail_address, display_option);
		    LYaddstr(display_option);
d825 5
a829 2
		response = ' ';
		break;
d831 10
a840 52
	    case 'S':	/* Change case sensitivity for searches. */
		case_sensitive = LYChooseBoolean(case_sensitive,
						 L_SSEARCH, -1,
						 caseless_choices);
		response = ' ';
		break;

	    case '\001':	/* Change assume_charset setting. */
		if (use_assume_charset) {
		    int i, curval;
		    CONST char ** assume_list;
		    assume_list = typecallocn(CONST char *,(LYNumCharsets + 1));
		    if (!assume_list) {
			outofmem(__FILE__, "options");
		    }
		    for (i = 0; i < LYNumCharsets; i++) {
			assume_list[i] = LYCharSet_UC[i].MIMEname;
		    }
		    curval = UCLYhndl_for_unspec;
		    if (curval == current_char_set && UCAssume_MIMEcharset) {
			curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
		    }
		    if (curval < 0)
			curval = LYRawMode ? current_char_set : 0;
		    if (!LYSelectPopups) {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChooseBoolean(charset_subsets[curval].assumed_idx,
					    L_ASSUME_CHARSET, -1,
					    assumed_charset_choices)
					    ? 1
					    : 0];
#else
			UCLYhndl_for_unspec = LYChooseBoolean(curval,
							     L_ASSUME_CHARSET, -1,
							     assume_list);
#endif
		    } else {
#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
			UCLYhndl_for_unspec = assumed_doc_charset_map[
			    LYChoosePopup(charset_subsets[curval].assumed_idx,
					  L_ASSUME_CHARSET, -1,
					  assumed_charset_choices,
					  0, FALSE, FALSE)
					  ? 1
					  : 0];
#else
			UCLYhndl_for_unspec = LYChoosePopup(curval,
							   L_ASSUME_CHARSET, -1,
							   assume_list,
							   0, FALSE, FALSE);
#endif
d842 3
a844 4
			LYmove(L_ASSUME_CHARSET, COL_OPTION_VALUES);
			LYclrtoeol();
			if (UCLYhndl_for_unspec >= 0)
			    LYaddstr(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d846 51
a896 1
		    }
d898 15
a912 33
		    /*
		     *	Set the raw 8-bit or CJK mode defaults and
		     *	character set if changed. - FM
		     */
		    if (CurrentAssumeCharSet != UCLYhndl_for_unspec ||
			UCLYhndl_for_unspec != curval) {
			if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
			    StrAllocCopy(UCAssume_MIMEcharset,
					 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
			}
			if (HTCJK != JAPANESE)
			    LYRawMode = (BOOL) (UCLYhndl_for_unspec == current_char_set);
			HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
			HTMLSetCharacterHandling(current_char_set);
			CurrentAssumeCharSet = UCLYhndl_for_unspec;
			CurrentRawMode = LYRawMode;
#if !defined(VMS) && !defined(USE_SLANG)
			if (!LYSelectPopups)
#endif /* !VMS && !USE_SLANG */
			{
			    LYmove(L_Rawmode, COL_OPTION_VALUES);
			    LYclrtoeol();
			    ShowBool(LYRawMode);
			}
		    }
		    FREE(assume_list);
		    response = ' ';
		    if (LYSelectPopups) {
			HANDLE_LYOPTIONS;
		    }
		} else {
		    _statusline(NEED_ADVANCED_USER_MODE);
		    AddValueAccepted = FALSE;
d914 2
a915 3
		break;

	    case 'C':	/* Change display charset setting. */
d918 6
a923 4
		    displayed_display_charset_idx = LYChooseBoolean(displayed_display_charset_idx,
						      L_Charset, -1,
						      display_charset_choices);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
d925 4
a928 3
		    current_char_set = LYChooseBoolean(current_char_set,
						      L_Charset, -1,
						      LYchar_set_names);
d932 9
a940 5
		    displayed_display_charset_idx = LYChoosePopup(displayed_display_charset_idx,
						    L_Charset, -1,
						    display_charset_choices,
						    0, FALSE, FALSE);
		    current_char_set = display_charset_map[displayed_display_charset_idx];
d942 5
a946 4
		    current_char_set = LYChoosePopup(current_char_set,
						    L_Charset, -1,
						    LYchar_set_names,
						    0, FALSE, FALSE);
a947 1

d949 1
a949 1
		    LYmove(L_Charset, COL_OPTION_VALUES);
d951 2
a952 1
		    LYaddstr(LYchar_set_names[current_char_set]);
d955 1
d957 2
a958 2
		 *  Set the raw 8-bit or CJK mode defaults and
		 *  character set if changed. - FM
d960 11
a970 4
		if (CurrentCharSet != current_char_set) {
		    LYUseDefaultRawMode = TRUE;
		    HTMLUseCharacterSet(current_char_set);
		    CurrentCharSet = current_char_set;
a979 6
#ifdef CAN_SWITCH_DISPLAY_CHARSET
		    /* Deduce whether the user wants autoswitch: */
		    switch_display_charsets =
			(current_char_set == auto_display_charset
			    || current_char_set == auto_other_display_charset);
#endif
d981 1
d986 31
a1016 1
		break;
d1018 22
a1039 10
	    case 'O':	/* Change raw mode setting. */
		LYRawMode = LYChooseBoolean(LYRawMode, L_Rawmode, -1, bool_choices);
		/*
		 *  Set the LYUseDefaultRawMode value and character
		 *  handling if LYRawMode was changed. - FM
		 */
		if (CurrentRawMode != LYRawMode) {
		    HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		    HTMLSetCharacterHandling(current_char_set);
		    CurrentRawMode = LYRawMode;
d1041 26
a1066 2
		response = ' ';
		break;
d1068 4
a1071 9
	    case 'G':	/* Change language preference. */
		if (language && *language) {
		    LYstrncpy(display_option, language, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA);
d1073 29
a1101 24
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_LANGUAGE, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((language && *language) ?
					  language : "NONE");
		} else if (*display_option == '\0') {
		    FREE(language);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(language, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
		response = ' ';
		break;
d1103 6
a1108 9
	    case 'H':	/* Change charset preference. */
		if (pref_charset && *pref_charset) {
		    LYstrncpy(display_option, pref_charset, sizeof(display_option) - 1);
		} else {  /* clear the NONE */
		    LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		    LYaddstr("    ");
		    *display_option = '\0';
		}
		_statusline(ACCEPT_DATA);
d1110 41
a1150 24
		lynx_start_bold();
		ch = LYgetstr(display_option, VISIBLE,
			      sizeof(display_option), NORECALL);
		lynx_stop_bold();
		LYmove(L_PREF_CHARSET, COL_OPTION_VALUES);
		if (term_options || ch == -1) {
		    LYaddstr((pref_charset && *pref_charset) ?
			   pref_charset : "NONE");
		} else if (*display_option == '\0') {
		    FREE(pref_charset);
		    LYaddstr("NONE");
		} else {
		    StrAllocCopy(pref_charset, display_option);
		    LYaddstr(display_option);
		}
		LYclrtoeol();
		if (ch == -1) {
		    HTInfoMsg(CANCELLED);
		    HTInfoMsg("");
		} else {
		    _statusline(VALUE_ACCEPTED);
		}
		response = ' ';
		break;
d1152 3
a1154 3
	    case 'V':	/* Change VI keys setting. */
		vi_keys = LYChooseBoolean(vi_keys,
					 L_Bool_A, C_VIKEYS,
d1156 34
a1189 7
		if (vi_keys) {
		    set_vi_keys();
		} else {
		    reset_vi_keys();
		}
		response = ' ';
		break;
d1191 6
a1196 8
	    case 'M':	/* Change emacs keys setting. */
		emacs_keys = LYChooseBoolean(emacs_keys,
					    L_Bool_A, C_EMACSKEYS,
					    bool_choices);
		if (emacs_keys) {
		    set_emacs_keys();
		} else {
		    reset_emacs_keys();
d1198 7
a1204 6
		response = ' ';
		break;

	    case 'W':	/* Change show dotfiles setting. */
		if (no_dotfiles) {
		    _statusline(DOTFILE_ACCESS_DISABLED);
d1206 1
a1206 4
		    show_dotfiles = LYChooseBoolean(show_dotfiles,
						   L_Bool_A,
						   C_SHOW_DOTFILES,
						   bool_choices);
d1208 3
a1210 2
		response = ' ';
		break;
d1212 10
a1221 11
	    case 'T':	/* Change select popups setting. */
		LYSelectPopups = LYChooseBoolean(LYSelectPopups,
						L_Bool_B,
						C_SELECT_POPUPS,
						bool_choices);
		response = ' ';
		break;

#if defined(USE_SLANG) || defined(COLOR_CURSES)
	    case '&':	/* Change show color setting. */
		if (no_option_save) {
d1223 3
a1225 10
		    if (!has_colors()) {
			char * terminal = LYGetEnv("TERM");
			if (terminal)
			    HTUserMsg2(
				COLOR_TOGGLE_DISABLED_FOR_TERM,
				terminal);
			else
			    HTUserMsg(COLOR_TOGGLE_DISABLED);
			break;
		    }
d1227 5
a1231 1
		    LYShowColor = LYChooseBoolean((LYShowColor - 1),
d1234 1
a1234 3
						 bool_choices);
		    if (LYShowColor == 0) {
			LYShowColor = SHOW_COLOR_OFF;
d1236 4
a1239 1
			LYShowColor = SHOW_COLOR_ON;
a1240 13
		} else {		/* !no_option_save */
		    BOOLEAN again = FALSE;
		    int chosen;
		    /*
		     *  Copy strings into choice array.
		     */
		    choices[0] = NULL;
		    StrAllocCopy(choices[0], "NEVER     ");
		    choices[1] = NULL;
		    StrAllocCopy(choices[1], "OFF       ");
		    choices[2] = NULL;
		    StrAllocCopy(choices[2], "ON        ");
		    choices[3] = NULL;
d1242 10
a1251 29
		    if (!has_colors())
			StrAllocCopy(choices[3], "Always try");
		    else
#endif
			StrAllocCopy(choices[3], "ALWAYS    ");
		    choices[4] = NULL;
		    do {
			if (!LYSelectPopups) {
			    chosen = LYChooseBoolean(LYChosenShowColor,
						    L_Color,
						    C_COLOR,
						    choices);
			} else {
			    chosen = LYChoosePopup(LYChosenShowColor,
						  L_Color,
						  C_COLOR,
						  choices, 4, FALSE, FALSE);
			}
#if defined(COLOR_CURSES)
			again = (BOOL) (chosen == SHOW_COLOR_ON && !has_colors());
			if (again) {
			    char * terminal = LYGetEnv("TERM");
			    if (terminal)
				HTUserMsg2(
				    COLOR_TOGGLE_DISABLED_FOR_TERM,
				    terminal);
			    else
				HTUserMsg(COLOR_TOGGLE_DISABLED);
			}
d1253 2
a1254 2
		    } while (again);
		    LYChosenShowColor = chosen;
d1256 5
a1260 5
		    if (LYSelectPopups) {
			LYmove(L_Color, C_COLOR);
			LYclrtoeol();
			LYaddstr(choices[LYChosenShowColor]);
		    }
d1263 1
a1263 1
		    if (has_colors())
d1265 10
a1274 10
			LYShowColor = chosen;
		    FREE(choices[0]);
		    FREE(choices[1]);
		    FREE(choices[2]);
		    FREE(choices[3]);
		}
		if (CurrentShowColor != LYShowColor) {
		    lynx_force_repaint();
		}
		CurrentShowColor = LYShowColor;
d1276 1
a1276 1
		SLtt_Use_Ansi_Colors = (LYShowColor > SHOW_COLOR_OFF ? TRUE : FALSE);
d1278 5
a1282 5
		response = ' ';
		if (LYSelectPopups && !no_option_save) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1285 7
a1291 7
	    case '@@':	/* Change show cursor setting. */
		LYShowCursor = LYChooseBoolean(LYShowCursor,
					      L_Bool_B,
					      C_SHOW_CURSOR,
					      bool_choices);
		response = ' ';
		break;
d1293 10
a1302 10
	    case 'K':	/* Change keypad mode. */
		if (!LYSelectPopups) {
		    keypad_mode = LYChooseBoolean(keypad_mode,
						 L_Keypad, -1,
						 keypad_choices);
		} else {
		    keypad_mode = LYChoosePopup(keypad_mode,
						L_Keypad, -1,
						keypad_choices,
						3, FALSE, FALSE);
d1304 3
a1306 3
		    LYmove(L_Keypad, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(keypad_choices[keypad_mode]);
d1308 11
a1318 11
		}
		if (keypad_mode == NUMBERS_AS_ARROWS) {
		    set_numbers_as_arrows();
		} else {
		    reset_numbers_as_arrows();
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1320 10
a1329 10
	    case 'N':	/* Change line editor key bindings. */
		if (!LYSelectPopups) {
		    current_lineedit = LYChooseBoolean(current_lineedit,
						      L_Lineed, -1,
						      LYLineeditNames);
		} else {
		    current_lineedit = LYChoosePopup(current_lineedit,
						    L_Lineed, -1,
						    LYLineeditNames,
						    0, FALSE, FALSE);
d1331 3
a1333 3
		    LYmove(L_Lineed, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYLineeditNames[current_lineedit]);
d1335 6
a1340 6
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1343 10
a1352 10
	    case 'Y':	/* Change keyboard layout */
		if (!LYSelectPopups) {
		    current_layout = LYChooseBoolean(current_layout,
						      L_Layout, -1,
						      LYKbLayoutNames);
		} else {
		    current_layout = LYChoosePopup(current_layout,
						    L_Layout, -1,
						    LYKbLayoutNames,
						    0, FALSE, FALSE);
d1354 3
a1356 3
		    LYmove(L_Layout, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(LYKbLayoutNames[current_layout]);
d1358 6
a1363 6
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1367 10
a1376 10
	    case 'I':	/* Change local directory sorting. */
		if (!LYSelectPopups) {
		    dir_list_style = LYChooseBoolean(dir_list_style,
						    L_Dired, -1,
						    dirList_choices);
		} else {
		    dir_list_style = LYChoosePopup(dir_list_style,
						  L_Dired, -1,
						  dirList_choices,
						  3, FALSE, FALSE);
d1378 3
a1380 3
		    LYmove(L_Dired, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(dirList_choices[dir_list_style]);
d1382 6
a1387 6
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1390 12
a1401 12
	    case 'U':	/* Change user mode. */
		if (!LYSelectPopups) {
		    user_mode = LYChooseBoolean(user_mode,
						L_User_Mode, -1,
						userMode_choices);
		    use_assume_charset = (BOOL) (user_mode >= 2);
		} else {
		    user_mode = LYChoosePopup(user_mode,
					      L_User_Mode, -1,
					      userMode_choices,
					      3, FALSE, FALSE);
		    use_assume_charset = (BOOL) (user_mode >= 2);
d1403 5
a1407 5
		    if (use_assume_charset == old_use_assume_charset) {
			LYmove(L_User_Mode, COL_OPTION_VALUES);
			LYclrtoeol();
			LYaddstr(userMode_choices[user_mode]);
		    }
d1409 41
d1451 16
a1466 2
		if (user_mode == NOVICE_MODE) {
		    display_lines = (LYlines - 4);
d1468 2
a1469 1
		    display_lines = LYlines-2;
d1471 6
a1476 12
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;

	    case '!':
		if (!LYSelectPopups) {
		    verbose_img = LYChooseBoolean(verbose_img,
						L_VERBOSE_IMAGES,
						C_VERBOSE_IMAGES,
						bool_choices);
d1478 1
a1478 5
		    verbose_img = LYChoosePopup(verbose_img,
					     L_VERBOSE_IMAGES,
					     C_VERBOSE_IMAGES,
					     bool_choices,
					     2, FALSE, FALSE);
d1480 5
a1484 5
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1486 4
a1489 41
	    case 'A':	/* Change user agent string. */
		if (!no_useragent) {
		    if (LYUserAgent && *LYUserAgent) {
			LYstrncpy(display_option, LYUserAgent, sizeof(display_option) - 1);
		    } else {  /* clear the NONE */
			LYmove(L_HOME, COL_OPTION_VALUES);
			LYaddstr("    ");
			*display_option = '\0';
		    }
		    _statusline(ACCEPT_DATA_OR_DEFAULT);
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
		    lynx_start_bold();
		    ch = LYgetstr(display_option, VISIBLE,
				  sizeof(display_option), NORECALL);
		    lynx_stop_bold();
		    LYmove(L_User_Agent, COL_OPTION_VALUES);
		    if (term_options || ch == -1) {
			LYaddstr((LYUserAgent &&
				*LYUserAgent) ?
				  LYUserAgent : "NONE");
		    } else if (*display_option == '\0') {
			StrAllocCopy(LYUserAgent, LYUserAgentDefault);
			LYaddstr((LYUserAgent &&
				*LYUserAgent) ?
				  LYUserAgent : "NONE");
		    } else {
			StrAllocCopy(LYUserAgent, display_option);
			LYaddstr(display_option);
		    }
		    LYclrtoeol();
		    if (ch == -1) {
			HTInfoMsg(CANCELLED);
			HTInfoMsg("");
		    } else if (!LYCheckUserAgent()) {
			_statusline(UA_PLEASE_USE_LYNX);
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		} else { /* disallowed */
		    _statusline(UA_CHANGE_DISABLED);
		}
d1492 1
a1492 8

#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
	    case 'X':	/* Change local exec restriction. */
		if (exec_frozen && !LYSelectPopups) {
		    _statusline(CHANGE_OF_SETTING_DISALLOWED);
		    response = ' ';
		    break;
		}
d1494 3
a1496 3
		if (local_exec) {
		    itmp = 2;
		} else
d1498 5
a1502 6
		{
		    if (local_exec_on_local_files) {
			itmp= 1;
		    } else {
			itmp = 0;
		    }
d1504 11
a1514 10
		if (!LYSelectPopups) {
		    itmp = LYChooseBoolean(itmp,
					  L_Exec, -1,
					  exec_choices);
		} else {
		    itmp = LYChoosePopup(itmp,
					L_Exec, -1,
					exec_choices,
					0, (exec_frozen ? TRUE : FALSE),
					FALSE);
d1516 3
a1518 3
		    LYmove(L_Exec, COL_OPTION_VALUES);
		    LYclrtoeol();
		    LYaddstr(exec_choices[itmp]);
d1520 11
a1530 11
		}
		if (!exec_frozen) {
		    switch (itmp) {
			case 0:
			    local_exec = FALSE;
			    local_exec_on_local_files = FALSE;
			    break;
			case 1:
			    local_exec = FALSE;
			    local_exec_on_local_files = TRUE;
			    break;
d1532 4
a1535 4
			case 2:
			    local_exec = TRUE;
			    local_exec_on_local_files = FALSE;
			    break;
d1537 7
a1543 7
		    } /* end switch */
		}
		response = ' ';
		if (LYSelectPopups) {
		    HANDLE_LYOPTIONS;
		}
		break;
d1546 6
a1551 9
	    case '>':	/* Save current options to RC file. */
		if (!no_option_save) {
		    HTInfoMsg(SAVING_OPTIONS);
		    LYrcShowColor = LYChosenShowColor;
		    if (save_rc(NULL)) {
			HTInfoMsg(OPTIONS_SAVED);
		    } else {
			HTAlert(OPTIONS_NOT_SAVED);
		    }
d1553 1
a1553 6
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
		    /*
		     *	Change response so that we don't exit
		     *	the options menu.
		     */
		    response = ' ';
d1555 8
a1562 1
		break;
d1564 2
a1565 2
	    case 'R':	/* Return to document (quit options menu). */
		break;
d1567 8
a1574 8
	    default:
		if (!no_option_save) {
		    HTInfoMsg(SAVE_OR_R_TO_RETURN_TO_LYNX);
		} else {
		    HTInfoMsg(R_TO_RETURN_TO_LYNX);
		}
	}  /* end switch */
    }  /* end while */
d1581 1
a1581 2
PRIVATE int widest_choice ARGS1(
	CONST char **,	choices)
d1584 1
d1587 1
d1594 2
a1595 3
PRIVATE void show_choice ARGS2(
	CONST char *,	choice,
	int,		width)
d1598 1
d1605 1
a1605 1
 *  Take a status code, prompt the user for a new status, and return it.
d1607 4
a1610 5
PRIVATE int boolean_choice ARGS4(
	int,		cur_choice,
	int,		line,
	int,		column,
	CONST char **,	choices)
d1620 1
a1620 2
     *	Get the number of choices and then make
     *	number zero-based.
d1622 1
a1622 2
    for (number = 0; choices[number] != NULL; number++)
	;  /* empty loop body */
d1626 1
a1626 1
     *	Update the statusline.
d1631 1
a1631 1
     *	Highlight the current choice.
d1641 2
a1642 4
     *	Get the keyboard entry, and leave the
     *	cursor at the choice, to indicate that
     *	it can be changed, until the user accepts
     *	the current choice.
d1651 3
a1653 3
	     /*
	      *  Control-C or Control-G.
	      */
d1667 1
a1667 1
	    (cmd = LKC_TO_LAC(keymap,response)) != LYK_ACTIVATE) {
d1669 3
a1671 3
		case LYK_HOME:
		    cur_choice = 0;
		    break;
d1673 3
a1675 3
		case LYK_END:
		    cur_choice = number;
		    break;
d1677 4
a1680 4
		case LYK_REFRESH:
		    lynx_force_repaint();
		    LYrefresh();
		    break;
d1682 20
a1701 6
		case LYK_QUIT:
		case LYK_ABORT:
		case LYK_PREV_DOC:
		    cur_choice = orig_choice;
		    term_options = TRUE;
		    break;
d1703 11
a1713 12
		case LYK_PREV_PAGE:
		case LYK_UP_HALF:
		case LYK_UP_TWO:
		case LYK_PREV_LINK:
		case LYK_LPOS_PREV_LINK:
		case LYK_FASTBACKW_LINK:
		case LYK_UP_LINK:
		case LYK_LEFT_LINK:
		    if (cur_choice == 0)
			cur_choice = number;  /* go back to end */
		    else
			cur_choice--;
d1715 7
a1721 20

		case LYK_1:
		case LYK_2:
		case LYK_3:
		case LYK_4:
		case LYK_5:
		case LYK_6:
		case LYK_7:
		case LYK_8:
		case LYK_9:
		    if((cmd - LYK_1 + 1) <= number) {
			cur_choice = cmd -LYK_1 + 1;
			break;
		    }  /* else fall through! */
		default:
		    if (cur_choice == number)
			cur_choice = 0;  /* go over the top and around */
		    else
			cur_choice++;
	    }  /* end of switch */
d1728 1
a1728 1
	     *	Unhighlight choice.
d1747 1
a1747 2
PRIVATE void terminate_options ARGS1(
	int,		sig GCC_UNUSED)
d1751 1
a1751 1
     *	Reassert the AST.
d1756 1
a1756 1
     *	Refresh the screen to get rid of the "interrupt" message.
d1766 1
a1766 1
 *  Multi-Bookmark On-Line editing support. - FMG & FM
d1768 1
a1768 1
PUBLIC void edit_bookmarks NOARGS
d1772 1
d1774 2
a1775 2
    int a; /* misc counter */
    char MBM_tmp_line[256]; /* buffer for LYgetstr */
d1779 3
a1781 4
     *	We need (MBM_V_MAXFILES + MULTI_OFFSET) lines to display
     *	the whole list at once.  Otherwise break it up into two
     *	segments.  We know it won't be less than that because
     *	'o'ptions needs 23-24 at LEAST.
d1786 1
a1786 1
draw_bookmark_list:
d1788 3
a1790 3
     *	Display menu of bookmarks.  NOTE that we avoid printw()'s
     *	to increase the chances that any non-ASCII or multibyte/CJK
     *	characters will be handled properly. - FM
d1802 1
a1802 1
    lynx_start_h1_color ();
d1809 1
a1809 1
    lynx_stop_h1_color ();
d1812 3
a1814 3
	for (a = ((MBM_V_MAXFILES/2 + 1) * (MBM_current - 1));
		      a <= (MBM_current * MBM_V_MAXFILES/2 ); a++) {
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 5);
d1819 1
a1819 1
	    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 35);
d1841 1
a1841 1
     *	Only needed when we have 2 screens.
d1881 1
a1881 1
	lynx_start_prompt_color ();
d1883 1
a1883 1
	lynx_stop_prompt_color ();
d1890 1
a1890 1
	 *  Check for a cancel.
d1897 1
a1897 1
	 *  Check for a save.
d1909 1
a1909 2
		 *  Change response so that we don't exit
		 *  the options menu.
d1917 1
a1917 1
	 *  Check for a refresh.
d1925 1
a1925 1
	 *  Move between the screens - if we can't show it all at once.
d1945 2
a1946 3
	 *  Instead of using 26 case statements, we set up
	 *  a scan through the letters and edit the lines
	 *  that way.
d1951 1
a1951 1
		    if (MBM_current == 1 && a > (MBM_V_MAXFILES/2)) {
d1956 1
a1956 1
		    if (MBM_current == 2 && a < (MBM_V_MAXFILES/2)) {
d1967 3
a1969 3
			LYmove(
			 (3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
			     9);
d1973 2
a1974 2
			   (!MBM_A_subdescript[a] ?
					       "" : MBM_A_subdescript[a]),
d1986 4
a1989 3
			LYmove(
			 (3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
			     5);
d2001 4
a2004 2
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
			 35);
d2024 2
a2025 2
			LYMBM_statusline(USE_PATH_OFF_HOME);
			LYSleepAlert();
d2033 4
a2036 2
		    LYmove((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current-1)),
			 35);
d2043 1
a2043 1
		LYmove(LYlines-1, 0);
d2047 2
a2048 2
	}  /* end for */
    } /* end while */
d2054 1
a2054 1
#if !defined(NO_OPTION_MENU) || (defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES)))
d2057 2
a2058 3
 *  This function offers the choices for values of an
 *  option via a popup window which functions like
 *  that for selection of options in a form. - FM
d2060 1
a2060 2
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
d2062 7
a2068 8
PUBLIC int popup_choice ARGS7(
	int,		cur_choice,
	int,		line,
	int,		column,
	CONST char **,	choices,
	int,		i_length,
	int,		disabled,
	BOOLEAN,	for_mouse)
d2077 1
a2077 1
				   (CONST char **)choices,
d2099 1
a2099 1
    return(cur_choice);
d2115 2
a2116 2
    CONST char *LongName;
    CONST char *HtmlName;
d2120 2
a2121 2
    char * tag;
    char * value;
d2124 16
a2139 14
static CONST char selected_string[] = "selected";
static CONST char disabled_string[] = "disabled";
static CONST char on_string[]	    = N_("ON");
static CONST char off_string[]	    = N_("OFF");
static CONST char never_string[]    = N_("NEVER");
static CONST char always_string[]   = N_("ALWAYS");
static OptValues bool_values[] = {
	{ FALSE,	     N_("OFF"),		  "OFF"		},
	{ TRUE,		     N_("ON"),		  "ON"		},
	{ 0, 0, 0 }};

static char * secure_string		= "secure";
static char * secure_value		= NULL;
static char * save_options_string	= "save_options";
d2144 7
a2150 7
static char * cookies_string		= RC_SET_COOKIES;
static char * cookies_ignore_all_string = N_("ignore");
static char * cookies_up_to_user_string = N_("ask user");
static char * cookies_accept_all_string = N_("accept all");
static char * x_display_string		= RC_DISPLAY;
static char * editor_string		= RC_FILE_EDITOR;
static char * emacs_keys_string		= RC_EMACS_KEYS;
d2156 5
a2160 4
static char * exec_links_string		= RC_RUN_ALL_EXECUTION_LINKS;
static OptValues exec_links_values[]	= {
	{ EXEC_NEVER,	N_("ALWAYS OFF"),		"ALWAYS OFF" },
	{ EXEC_LOCAL,	N_("FOR LOCAL FILES ONLY"),	"FOR LOCAL FILES ONLY" },
d2162 1
a2162 1
	{ EXEC_ALWAYS,	N_("ALWAYS ON"),		"ALWAYS ON" },
d2164 2
a2165 1
	{ 0, 0, 0 }};
d2169 1
a2169 1
static char * kblayout_string		= RC_KBLAYOUT;
d2171 25
a2195 20
static char * keypad_mode_string	= RC_KEYPAD_MODE;
static OptValues keypad_mode_values[]	= {
	{ NUMBERS_AS_ARROWS,  N_("Numbers act as arrows"),
			      "number_arrows" },
	{ LINKS_ARE_NUMBERED, N_("Links are numbered"),
			      "links_numbered" },
	{ LINKS_AND_FIELDS_ARE_NUMBERED,
			      N_("Links and form fields are numbered"),
			      "links_and_forms" },
	{ FIELDS_ARE_NUMBERED,
			      N_("Form fields are numbered"),
			      "forms_numbered" },
	{ 0, 0, 0 }};
static char * lineedit_mode_string	= RC_LINEEDIT_MODE;
static char * mail_address_string	= RC_PERSONAL_MAIL_ADDRESS;
static char * search_type_string	= RC_CASE_SENSITIVE_SEARCHING;
static OptValues search_type_values[] = {
	{ FALSE,	    N_("Case insensitive"),  "case_insensitive" },
	{ TRUE,		    N_("Case sensitive"),	 "case_sensitive" },
	{ 0, 0, 0 }};
d2198 9
a2206 7
static char * show_color_string		= RC_SHOW_COLOR;
static OptValues show_color_values[] = {
	{ SHOW_COLOR_NEVER,	never_string,	never_string },
	{ SHOW_COLOR_OFF,	off_string,	off_string },
	{ SHOW_COLOR_ON,	on_string,	on_string },
	{ SHOW_COLOR_ALWAYS,	always_string,	always_string },
	{ 0, 0, 0 }};
d2209 1
a2209 1
static char * show_cursor_string	= RC_SHOW_CURSOR;
d2211 1
a2211 1
static char * underline_links_string	= RC_UNDERLINE_LINKS;
d2214 1
a2214 1
static char * show_scrollbar_string	= RC_SCROLLBAR;
d2217 10
a2226 8
static CONST char prompt_dft_string[]	= N_("prompt normally");
static CONST char prompt_yes_string[]	= N_("force yes-response");
static CONST char prompt_no_string[]	= N_("force no-response");
static OptValues prompt_values[] = {
	{ FORCE_PROMPT_DFT,	prompt_dft_string, prompt_dft_string },
	{ FORCE_PROMPT_YES,	prompt_yes_string, prompt_yes_string },
	{ FORCE_PROMPT_NO,	prompt_no_string,  prompt_no_string },
	{ 0, 0, 0 }};
d2228 1
a2228 1
static char * cookie_prompt_string	= RC_FORCE_COOKIE_PROMPT;
d2231 1
a2231 1
static char * ssl_prompt_string		= RC_FORCE_SSL_PROMPT;
d2234 23
a2256 19
static char * user_mode_string		= RC_USER_MODE;
static OptValues user_mode_values[] = {
	{ NOVICE_MODE,		N_("Novice"),			"Novice" },
	{ INTERMEDIATE_MODE,	N_("Intermediate"),		"Intermediate" },
	{ ADVANCED_MODE,	N_("Advanced"),			"Advanced" },
	{ 0, 0, 0 }};

static char * vi_keys_string		= RC_VI_KEYS;

static char * visited_links_string	= RC_VISITED_LINKS;
static OptValues visited_links_values[] = {
	{ VISITED_LINKS_AS_FIRST_V, N_("By First Visit"),	"first_visited" },
	{ VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE,
		    N_("By First Visit Reversed"),		"first_visited_reversed" },
	{ VISITED_LINKS_AS_TREE,    N_("As Visit Tree"),	"visit_tree" },
	{ VISITED_LINKS_AS_LATEST,  N_("By Last Visit"),	"last_visited" },
	{ VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE,
		    N_("By Last Visit Reversed"),		"last_visited_reversed" },
	{ 0, 0, 0 }};
d2261 3
a2263 2
static char * DTD_recovery_string      = RC_TAGSOUP;
static OptValues DTD_type_values[] = {
d2265 10
a2274 9
	{ TRUE,		    N_("relaxed (TagSoup mode)"),	 "tagsoup" },
	{ FALSE,	    N_("strict (SortaSGML mode)"),	 "sortasgml" },
	{ 0, 0, 0 }};

static char * select_popups_string     = RC_SELECT_POPUPS;
static char * images_string            = "images";
static char * images_ignore_all_string = N_("ignore");
static char * images_use_label_string  = N_("as labels");
static char * images_use_links_string  = N_("as links");
d2276 3
a2278 2
static char * verbose_images_string    = RC_VERBOSE_IMAGES;
static OptValues verbose_images_type_values[] = {
d2280 4
a2283 3
	{ FALSE,	    N_("OFF"),		 	"OFF" },
	{ TRUE,		    N_("show filename"),	 "ON" },
	{ 0, 0, 0 }};
d2288 8
a2295 6
static char * mbm_string		= RC_MULTI_BOOKMARK;
static OptValues mbm_values[] = {
	{ MBM_OFF,		N_("OFF"),		"OFF" },
	{ MBM_STANDARD,		N_("STANDARD"),		"STANDARD" },
	{ MBM_ADVANCED,		N_("ADVANCED"),		"ADVANCED" },
	{ 0, 0, 0 }};
d2297 1
a2297 1
static char * single_bookmark_string	= RC_BOOKMARK_FILE;
d2302 3
a2304 3
static char * assume_char_set_string	= RC_ASSUME_CHARSET;
static char * display_char_set_string	= RC_CHARACTER_SET;
static char * raw_mode_string		= RC_RAW_MODE;
d2307 1
a2307 1
static char * locale_charset_string	= RC_LOCALE_CHARSET;
d2313 1
a2313 1
static char * show_dotfiles_string	= RC_SHOW_DOTFILES;
d2316 9
a2324 6
static char * dired_list_string		= RC_DIR_LIST_STYLE;
static OptValues dired_list_values[] = {
	{ DIRS_FIRST,		N_("Directories first"),	"dired_dir" },
	{ FILES_FIRST,		N_("Files first"),		"dired_files" },
	{ MIXED_STYLE,		N_("Mixed style"),		"dired_mixed" },
	{ 0, 0, 0 }};
d2326 8
a2333 7
static char * dired_sort_string		= RC_DIR_LIST_ORDER;
static OptValues dired_sort_values[] = {
	{ ORDER_BY_NAME,	N_("By Name"),		"dired_by_name" },
	{ ORDER_BY_TYPE,	N_("By Type"),		"dired_by_type" },
	{ ORDER_BY_SIZE,	N_("By Size"),		"dired_by_size" },
	{ ORDER_BY_DATE,	N_("By Date"),		"dired_by_date" },
	{ ORDER_BY_MODE,	N_("By Mode"),		"dired_by_mode" },
d2335 2
a2336 2
	{ ORDER_BY_USER,	N_("By User"),		"dired_by_user" },
	{ ORDER_BY_GROUP,	N_("By Group"),		"dired_by_group" },
d2338 2
a2339 1
	{ 0, 0, 0 }};
d2343 9
a2351 7
static char * ftp_sort_string		= RC_FILE_SORTING_METHOD;
static OptValues ftp_sort_values[] = {
	{ FILE_BY_NAME,		N_("By Name"),		"ftp_by_name" },
	{ FILE_BY_TYPE,		N_("By Type"),		"ftp_by_type" },
	{ FILE_BY_SIZE,		N_("By Size"),		"ftp_by_size" },
	{ FILE_BY_DATE,		N_("By Date"),		"ftp_by_date" },
	{ 0, 0, 0 }};
d2354 6
a2359 5
static char * show_rate_string		= RC_SHOW_KB_RATE;
static OptValues rate_values[] = {
	{ rateOFF,		N_("Do not show rate"),	"rate_off" },
	{ rateBYTES,		N_("Show %s/sec rate"),	"rate_bytes" },
	{ rateKB,		N_("Show %s/sec rate"), "rate_kb" },
d2361 2
a2362 2
	{ rateEtaBYTES,		N_("Show %s/sec, ETA"),	"rate_eta_bytes" },
	{ rateEtaKB,		N_("Show %s/sec, ETA"), "rate_eta_kb" },
d2364 2
a2365 1
	{ 0, 0, 0 }};
d2369 32
d2403 6
a2408 3
static char * preferred_doc_char_string = RC_PREFERRED_CHARSET;
static char * preferred_doc_lang_string = RC_PREFERRED_LANGUAGE;
static char * user_agent_string		= RC_USERAGENT;
d2427 2
a2428 4
PRIVATE void PutOptValues ARGS3(
	FILE *,		fp,
	int,		value,
	OptValues *,	table)
d2441 2
a2442 4
PRIVATE BOOLEAN GetOptValues ARGS3(
	OptValues *,	table,
	char *,		value,
	int *,		result)
d2463 1
a2463 3

PRIVATE PostPair * break_data ARGS1(
    bstring *,	data)
d2465 2
a2466 2
    char * p;
    PostPair * q = NULL;
d2498 4
a2501 3
	   size_t i, len;
	   len = strlen(q[count].value);
	   for (i = 0; i < len; i++) {
d2509 2
a2510 2
		    && q[count].value[i+1] == '+'
		    && isalnum(UCH(q[count].value[i+2]))) {
d2518 1
a2518 1
	   }
d2521 2
a2522 1
	CTRACE((tfp, "...item[%d] tag=%s, value=%s\n", count, q[count].tag, q[count].value));
d2529 1
a2529 1
	q = realloc(q, sizeof(PostPair)*(count+1));
d2537 17
a2553 1
PRIVATE int gen_options PARAMS((char **newfile));
d2587 1
a2587 2
PUBLIC int postoptions ARGS1(
    DocInfo *,		newdoc)
d2590 1
a2590 1
    DocAddress WWWDoc;  /* need on exit */
d2595 1
d2600 1
d2607 1
a2607 1
     * "<a href=\"LYNXOPTIONS://MBM_MENU\">Goto multi-bookmark menu</a>\n"
d2610 1
a2610 1
    if (strstr(newdoc->address, "LYNXOPTIONS://MBM_MENU")) {
d2613 2
a2614 2
	   HTAlert(BOOKMARK_CHANGE_DISALLOWED); /* anonymous */
	   return(NULLFILE);
d2616 1
a2616 1
	    return(NOT_FOUND);
d2618 2
a2619 2
	   edit_bookmarks();
	   return(NULLFILE);
d2621 3
d2638 1
a2638 1
	    return(status);
d2650 1
a2650 1
	    return(NOT_FOUND);
d2655 1
a2655 1
	return(NORMAL);
d2669 1
a2669 1
	return(NOT_FOUND);
d2674 4
a2677 4
	 *  This isn't really for security, but rather for avoiding that
	 *  the user may revisit an older instance from the history stack
	 *  and submit stuff which accidentally undoes changes that had
	 *  been done from a newer instance. - kw
d2692 1
a2692 1
		return(NULLFILE);
d2730 1
a2730 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2741 1
a2741 1
	 && GetOptValues(exec_links_values, data[i].value, &code)) {
d2752 1
d2754 1
a2754 1
		 && keypad_mode != newval) {
d2769 1
d2772 2
a2773 1
		if (j==newval)	current_lineedit = newval;
a2775 1

d2781 1
d2784 2
a2785 1
		if (j==newval)	current_layout = newval;
d2796 6
d2804 1
a2804 1
	 && GetOptValues(search_type_values, data[i].value, &code)) {
d2810 1
a2810 1
	 && GetOptValues(DTD_type_values, data[i].value, &code)) {
d2820 1
a2820 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
a2822 1

d2826 2
a2827 2
	 && GetOptValues(show_color_values, data[i].value,
			 &LYChosenShowColor)) {
d2842 1
a2842 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2848 1
a2848 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
a2850 1

d2854 1
a2854 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2856 1
d2872 1
a2872 1
	 && GetOptValues(user_mode_values, data[i].value, &user_mode)) {
d2876 1
a2876 1
		display_lines = LYlines-2;
d2882 1
a2882 1
	   GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);
d2887 1
a2887 1
			&& !(pseudo_inline_alts == FALSE && clickable_images == FALSE)) {
d2892 1
a2892 1
			&& !(pseudo_inline_alts == TRUE && clickable_images == FALSE)) {
d2897 1
a2897 1
			&& !(clickable_images == TRUE)) {
d2905 1
a2905 1
	 && GetOptValues(verbose_images_type_values, data[i].value, &code)) {
d2914 1
a2914 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2940 1
a2940 1
	     && ((raw_mode_old &&
d2942 2
a2943 2
	      || (!raw_mode_old &&
		     newval != UCLYhndl_for_unspec)
a2950 1

d2954 1
a2954 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
d2963 1
d2966 2
a2967 1
		if (j==newval)	current_char_set = newval;
d2973 1
a2973 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
a2982 1

d2998 1
a2998 1
	 && GetOptValues(bool_values, data[i].value, &code)) {
a3000 1

d3004 1
a3004 1
	 && GetOptValues(rate_values, data[i].value, &code)) {
d3009 10
d3025 1
a3025 1
	   }
d3044 3
a3046 3
		   *(data[i].value)
		   ? data[i].value
		   : LYUserAgentDefault);
d3052 1
a3052 1
    } /* end of loop */
d3060 7
a3066 3
    if ( display_char_set_old != current_char_set ||
	 raw_mode_old != LYRawMode ||
	 assume_char_set_changed ) {
d3072 2
a3073 2
	     *  Set the LYUseDefaultRawMode value and character
	     *  handling if LYRawMode was changed. - FM
d3080 2
a3081 2
		 (current_char_set == auto_display_charset
		  || current_char_set == auto_other_display_charset);
d3089 2
a3090 2
	     *  Set the raw 8-bit or CJK mode defaults and
	     *  character set if changed. - FM
d3096 2
a3097 2
    } /* end of charset settings */

d3114 2
a3115 2
     *  Exit: working around the previous document.
     *  Being out of mainloop()/getfile() cycle, do things manually.
d3119 1
a3119 1
		    need_reload ? "TRUE" : "FALSE"));
d3121 1
a3121 1
		    need_end_reload ? "TRUE" : "FALSE"));
d3131 2
a3132 2
    LYforce_no_cache = FALSE;   /* ! */
    LYoverride_no_cache = TRUE; /* ! */
d3142 1
a3142 1
	return(NOT_FOUND);
d3144 1
a3144 1
    HTuncache_current_document(); /* will never use again */
d3147 2
a3148 3
     *  Return to previous doc, not to options menu!
     *  Reload the document we had before the options menu
     *  but uncache only when necessary (Hurrah, user!):
d3157 2
a3158 2
    LYforce_no_cache = FALSE;   /* see below */
    LYoverride_no_cache = TRUE; /* see below */
d3167 1
a3167 1
	return(NOT_FOUND);
d3174 4
a3177 4
    reloading = FALSE;  /* set manually */
    /*  force end-to-end reload from remote server if change LYUserAgent
     *  or language or pref_charset (marked by need_end_reload flag above),
     *  from old-style LYK_OPTIONS (mainloop):
d3183 7
a3189 9
	 *  An option has changed which may influence
	 *  content negotiation, and the resource is from
	 *  a http or https or lynxcgi URL (the only protocols
	 *  which currently do anything with this information).
	 *  Set reloading = TRUE so that proxy caches will be
	 *  flushed, which is necessary until the time when
	 *  all proxies understand HTTP 1.1 Vary: and all
	 *  Servers properly use it...  Treat like
	 *  case LYK_RELOAD (see comments there). - KW
d3191 2
a3192 2
	reloading = TRUE;  /* global flag */
	need_reload = TRUE;  /* this was probably already TRUE, don't worry */
d3198 1
a3198 1
	return(NORMAL);
d3203 1
a3203 1
	 *  see LYK_RELOAD & LYK_OPTIONS in mainloop for details...
d3215 1
a3215 1
		return(NORMAL);
d3225 1
a3225 1
	    return(NORMAL);
d3233 1
a3233 1
	return(NULLFILE);
d3239 1
a3239 1
PRIVATE char *NewSecureValue NOARGS
d3241 2
d3244 1
a3244 1
    if ((secure_value = malloc(80)) != 0) {
d3247 1
d3249 1
a3249 1
	long key = (long)secure_value + (long)time(0);
d3254 1
a3254 1
    return "?";
d3263 2
a3264 4
PRIVATE void PutLabel ARGS3(
	FILE *,		fp,
	char *,		name,
	char *,		value)
d3266 6
d3273 2
a3274 1
	fprintf(fp, "  %-*s: ", LABEL_LEN, name);
d3276 9
a3284 5
	int l = strlen(name);
	fprintf(fp, "  %s", name);
	fprintf(fp, "%s%-*s: ",
		(l < (LABEL_LEN-3)) ? " " : "",
		(l < (LABEL_LEN-3)) ? (LABEL_LEN-1) - l : 3, "(!)");
d3286 1
d3295 1
a3295 1
PRIVATE char *check_if_write_lynxrc ARGS1(char **, table)
d3298 1
a3298 1
    char *result = NULL;
d3313 1
a3313 1
PRIVATE char *will_save_cookies NOARGS
d3315 4
a3318 3
    static char *table[] = {
	RC_SET_COOKIES,			/* LYSetCookies */
	RC_ACCEPT_ALL_COOKIES,		/* LYAcceptAllCookies */
d3321 1
d3330 1
a3330 1
PRIVATE char *will_save_images NOARGS
d3332 3
a3334 2
    static char *table[] = {
	RC_MAKE_PSEUDO_ALTS_FOR_INLINES, /* pseudo_inline_alts */
d3338 1
d3346 1
a3346 3
PUBLIC void LYMenuVisitedLinks ARGS2(
	FILE *,		fp0,
	int,		disable_all)
d3364 1
a3364 2
PRIVATE int gen_options ARGS1(
	char **,	newfile)
d3371 3
a3373 1
    size_t text_len = LYscreenWidth() > 45 ? LYscreenWidth() - 38 : 7;	/* cf: PutLabel */
d3376 1
a3376 1
	return(NOT_FOUND);
d3380 11
a3390 11
    /* This should not be needed if we regenerate the temp file every
       time with a new name, which just happened above in the case
       LYReuseTempfiles==FALSE.  Even for LYReuseTempfiles=TRUE, code
       at the end of postoptions() may remove an older cached version
       from memory if that version of the page was left by submitting
       changes. - kw 1999-11-27
       If access to the actual file via getfile() later fails
       (maybe because of some restrictions), mainloop may leave
       this flag on after popping the previous doc which is then
       unnecessarily reloaded.  But I changed mainloop to reset
       the flag. - kw 1999-05-24 */
d3402 1
a3402 1
    BeginInternalPage(fp0, OPTIONS_TITLE, NULL); /* help link below */
d3414 1
a3414 1
		 secure_string, NewSecureValue());
d3421 1
a3421 1
    fprintf(fp0,"<p align=center>\n");
d3423 3
a3425 3
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0,"%s - \n", CANCEL_CHANGES);
d3428 1
a3428 1
		 helpfilepath, OPTIONS_HELP, TO_HELP);
d3435 1
a3435 1
			 save_options_string);
d3438 1
a3438 1
			gettext("(options marked with (!) will not be saved)"));
d3444 1
a3444 1
    fprintf(fp0,"<pre>\n");
d3446 1
a3446 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("General Preferences"));
d3458 1
a3458 1
		      DISABLED(no_editor || system_editor));
d3466 1
a3466 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Security and Privacy"));
d3473 2
a3474 2
		   cookies_ignore_all_string,
		   cookies_ignore_all_string);
d3476 2
a3477 2
		   cookies_up_to_user_string,
		   cookies_up_to_user_string);
d3479 2
a3480 2
		   cookies_accept_all_string,
		   cookies_accept_all_string);
d3497 1
a3497 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Keyboard Input"));
d3519 1
a3519 1
    if (LYLineeditNames[1]) { /* well, at least 2 line edit styles available */
d3524 1
d3526 1
a3526 1
	    PutOption(fp0, i==current_lineedit, temp, LYLineeditNames[i]);
a3529 1

d3536 1
d3546 1
a3546 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Display and Character Set"));
d3565 1
d3572 1
a3572 1
	PutOption(fp0, i==current_char_set, temp, LYchar_set_names[i]);
d3579 1
d3588 1
a3588 1
		/* ok, LYRawMode, so use UCAssume_MIMEcharset */
d3597 3
a3599 3
	    PutOption(fp0, i == curval,
			   LYCharSet_UC[i].MIMEname,
			   LYCharSet_UC[i].MIMEname);
d3621 1
a3621 1
    PutLabel(fp0, gettext("X Display"),	x_display_string);
d3627 1
a3627 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Document Appearance"));
d3637 1
a3637 1
	   LYShowColor = SHOW_COLOR_OFF;
d3639 1
a3639 1
	   LYShowColor = SHOW_COLOR_ON;
d3645 2
a3646 2
	   show_color_values[2].HtmlName = on_string;
	   show_color_values[3].LongName = always_string;
d3648 2
a3649 2
	   show_color_values[2].HtmlName = NULL; /* suppress "ON" - kw */
	   show_color_values[3].LongName = "Always try";
d3692 2
a3693 2
		   images_ignore_all_string,
		   images_ignore_all_string);
d3695 2
a3696 2
		   images_use_label_string,
		   images_use_label_string);
d3698 2
a3699 2
		   images_use_links_string,
		   images_use_links_string);
d3711 1
a3711 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Headers Transferred to Remote Servers"));
d3717 18
a3734 1
		      NonNull(personal_mail_address), text_len, "");
d3739 1
a3739 1
		      NonNull(pref_charset), cset_len+2, "");
d3744 1
a3744 1
		      NonNull(language), cset_len+2, "");
d3750 1
a3750 1
			  NonNull(LYUserAgent), text_len, "");
d3756 1
a3756 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Listing and Accessing Files"));
d3760 1
a3760 1
    PutLabel(fp0, gettext("FTP sort criteria"),	ftp_sort_string);
d3794 5
a3798 5
		      ? EXEC_ALWAYS
		      : (local_exec_on_local_files
			  ? EXEC_LOCAL
			  : EXEC_NEVER),
		      exec_links_values);
d3801 3
a3803 3
		      ? EXEC_LOCAL
		      : EXEC_NEVER,
		      exec_links_values);
d3814 1
d3822 1
a3822 1
        FREE(message);
d3830 1
a3830 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Special Files and Screens"));
d3844 2
a3845 2
	fprintf(fp0, "<a href=\"%s//MBM_MENU\">%s</a>\n",
		    STR_LYNXOPTIONS, gettext("Goto multi-bookmark menu"));
d3849 1
a3849 1
			 NonNull(bookmark_page), text_len, "");
d3858 2
a3859 2
		     gettext("View the file "),
		     STR_LYNXCFG);
d3862 1
a3862 1
    fprintf(fp0,"\n</pre>\n");
d3866 4
a3869 4
	fprintf(fp0,"<p align=center>\n");
	fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\"> - \n", RESET_CHANGES);
	fprintf(fp0,"%s\n", CANCEL_CHANGES);
d3875 1
a3875 1
    fprintf(fp0,"</form>\n");
d3879 1
a3879 1
    return(NORMAL);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2491 1
a2491 1
    int code;
d2645 1
a2645 1
	    int newval;
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d24 1
d39 1
a39 1
PRIVATE BOOLEAN can_do_colors = 0;
d58 1
a58 1
    can_do_colors = 1;
d233 1
a233 1
	    start_bold();
d238 1
a238 1
	    stop_bold();
d244 1
a244 1
	stop_bold();
d513 7
a519 5
    LYaddstr((keypad_mode == NUMBERS_AS_ARROWS) ?
				"Numbers act as arrows             " :
	 ((keypad_mode == LINKS_ARE_NUMBERED) ?
				"Links are numbered                " :
				"Links and form fields are numbered"));
d567 1
a567 1
    start_bold();
d569 1
a569 1
    stop_bold();
d573 1
a573 1
	start_bold();
d575 1
a575 1
	stop_bold();
d581 1
a581 1
    start_bold();
d583 1
a583 1
    stop_bold();
d625 1
a625 1
		    start_bold();
d628 1
a628 1
		    stop_bold();
d661 1
a661 1
		start_bold();
d664 1
a664 1
		stop_bold();
d779 1
a779 1
		    start_bold();
d782 1
a782 1
		    stop_bold();
d846 1
a846 1
		start_bold();
d849 1
a849 1
		stop_bold();
d1054 1
a1054 1
		start_bold();
d1057 1
a1057 1
		stop_bold();
d1089 1
a1089 1
		start_bold();
d1092 1
a1092 1
		stop_bold();
d1163 1
a1163 1
			char * terminal = getenv("TERM");
d1215 1
a1215 1
			again = (BOOL) (chosen == 2 && !has_colors());
d1217 1
a1217 1
			    char * terminal = getenv("TERM");
d1249 1
a1249 1
		SLtt_Use_Ansi_Colors = (LYShowColor > 1 ? 1 : 0);
d1424 1
a1424 1
		    start_bold();
d1427 1
a1427 1
		    stop_bold();
d1608 1
a1608 1
    start_reverse();
d1707 1
a1707 1
	    stop_reverse();
d1823 1
a1823 1
	start_bold();
d1825 1
a1825 1
	stop_bold();
d1829 1
a1829 1
	start_bold();
d1831 1
a1831 1
	stop_bold();
d1839 1
a1839 1
	start_bold();
d1841 1
a1841 1
	stop_bold();
d1847 1
a1847 1
    start_bold();
d1849 1
a1849 1
    stop_bold();
d1944 1
a1944 1
		    start_bold();
d1957 1
a1957 1
		    stop_bold();
d1985 1
a1985 1
		start_bold();
d1987 1
a1987 1
			  (!MBM_A_subbookmark[a] ? "" : MBM_A_subbookmark[a]),
d1991 1
a1991 1
		stop_bold();
a2088 1
#define NOTEMPTY(text) (text && text[0]) ? text : ""
d2103 4
a2106 4
static CONST char on_string[]	    = "ON";
static CONST char off_string[]	    = "OFF";
static CONST char never_string[]    = "NEVER";
static CONST char always_string[]   = "ALWAYS";
d2108 2
a2109 2
	{ FALSE,	     "OFF",		  "OFF"		},
	{ TRUE,		     "ON",		  "ON"		},
d2119 7
a2125 7
static char * cookies_string		= "set_cookies";
static char * cookies_ignore_all_string = "ignore";
static char * cookies_up_to_user_string = "ask user";
static char * cookies_accept_all_string = "accept all";
static char * x_display_string		= "display";
static char * editor_string		= "file_editor";
static char * emacs_keys_string		= "emacs_keys";
d2131 1
a2131 1
static char * exec_links_string		= "exec_options";
d2133 2
a2134 2
	{ EXEC_NEVER,	"ALWAYS OFF",		"ALWAYS OFF" },
	{ EXEC_LOCAL,	"FOR LOCAL FILES ONLY",	"FOR LOCAL FILES ONLY" },
d2136 1
a2136 1
	{ EXEC_ALWAYS,	"ALWAYS ON",		"ALWAYS ON" },
d2142 1
a2142 1
static char * kblayout_string		= "kblayout";
d2144 1
a2144 1
static char * keypad_mode_string	= "keypad_mode";
d2146 4
a2149 2
	{ NUMBERS_AS_ARROWS,  "Numbers act as arrows", "number_arrows" },
	{ LINKS_ARE_NUMBERED, "Links are numbered",    "links_numbered" },
d2151 1
a2151 1
			      "Links and form fields are numbered",
d2153 3
d2157 3
a2159 3
static char * lineedit_mode_string	= "lineedit_mode";
static char * mail_address_string	= "personal_mail_address";
static char * search_type_string	= "case_sensitive_searching";
d2161 2
a2162 2
	{ FALSE,	    "Case insensitive",  "case_insensitive" },
	{ TRUE,		    "Case sensitive",	 "case_sensitive" },
d2164 1
d2166 1
a2166 1
static char * show_color_string		= "show_color";
d2174 25
a2198 2
static char * show_cursor_string	= "show_cursor";
static char * user_mode_string		= "user_mode";
d2200 3
a2202 3
	{ NOVICE_MODE,		"Novice",	"Novice" },
	{ INTERMEDIATE_MODE,	"Intermediate", "Intermediate" },
	{ ADVANCED_MODE,	"Advanced",	"Advanced" },
d2205 1
a2205 1
static char * vi_keys_string		= "vi_keys";
d2207 1
a2207 1
static char * visited_links_string	= "visited_links";
d2209 1
a2209 1
	{ VISITED_LINKS_AS_FIRST_V, "By First Visit",	"first_visited" },
d2211 3
a2213 3
		    "By First Visit Reversed",	"first_visited_reversed" },
	{ VISITED_LINKS_AS_TREE,    "As Visit Tree",	"visit_tree" },
	{ VISITED_LINKS_AS_LATEST,  "By Last Visit",	"last_visited" },
d2215 1
a2215 1
		    "By Last Visit Reversed",	"last_visited_reversed" },
d2221 1
a2221 2
#ifndef SH_EX	/* 1999/01/19 (Tue) */
static char * DTD_recovery_string      = "DTD_recovery";
d2224 2
a2225 2
	{ TRUE,		    "relaxed (TagSoup mode)",	 "tagsoup" },
	{ FALSE,	    "strict (SortaSGML mode)",	 "sortasgml" },
a2226 1
#endif
d2228 1
a2228 1
static char * select_popups_string     = "select_popups";
d2230 5
a2234 4
static char * images_ignore_all_string  = "ignore";
static char * images_use_label_string   = "as labels";
static char * images_use_links_string   = "as links";
static char * verbose_images_string    = "verbose_images";
d2237 2
a2238 2
	{ FALSE,	    "OFF",		 "OFF" },
	{ TRUE,		    "show filename",	 "ON" },
d2244 1
a2244 1
static char * mbm_string		= "multi_bookmark";
d2246 3
a2248 3
	{ MBM_OFF,		"OFF",			"OFF" },
	{ MBM_STANDARD,		"STANDARD",		"STANDARD" },
	{ MBM_ADVANCED,		"ADVANCED",		"ADVANCED" },
d2251 1
a2251 1
static char * single_bookmark_string	= "single_bookmark_name";
d2256 7
a2262 3
static char * assume_char_set_string	= "assume_char_set";
static char * display_char_set_string	= "character_set";
static char * raw_mode_string		= "raw_mode";
d2267 1
a2267 1
static char * show_dotfiles_string	= "show_dotfiles";
d2270 18
a2287 5
static char * dired_sort_string		= "dir_list_style";
static OptValues dired_values[] = {
	{ 0,			"Directories first",	"dired_dir" },
	{ FILES_FIRST,		"Files first",		"dired_files" },
	{ MIXED_STYLE,		"Mixed style",		"dired_mixed" },
d2289 1
d2292 1
a2292 1
static char * ftp_sort_string		= "file_sorting_method";
d2294 4
a2297 4
	{ FILE_BY_NAME,		"By Name",		"ftp_by_name" },
	{ FILE_BY_TYPE,		"By Type",		"ftp_by_type" },
	{ FILE_BY_SIZE,		"By Size",		"ftp_by_size" },
	{ FILE_BY_DATE,		"By Date",		"ftp_by_date" },
d2300 2
a2301 1
static char * show_rate_string		= "show_rate";
d2303 6
a2308 6
	{ rateOFF,		"Do not show rate",	"rate_off" },
	{ rateBYTES,		"Show Bytes/sec rate",	"rate_bytes" },
	{ rateKB,		"Show KB/sec rate",	"rate_kb" },
#ifdef EXP_READPROGRESS
	{ rateEtaBYTES,		"Show Bytes/sec, ETA",	"rate_eta_bytes" },
	{ rateEtaKB,		"Show KB/sec, ETA",	"rate_eta_kb" },
d2311 1
d2316 3
a2318 3
static char * preferred_doc_char_string = "preferred_charset";
static char * preferred_doc_lang_string = "preferred_language";
static char * user_agent_string		= "user_agent";
d2326 1
a2326 1
	fprintf(fp,"<option value=\"%s\" %s>%s\n", html, SELECTED(flag), name)
d2379 1
a2379 1
    char *,	data)
d2381 1
a2381 1
    char * p = data;
d2385 1
a2385 1
    if (p==NULL || p[0]=='\0')
d2388 2
a2389 1
    CTRACE((tfp, "break_data %s\n", data));
d2392 1
a2392 1
    if (q==NULL)
d2444 1
a2444 1
	if (q==NULL)
d2446 2
a2447 2
	q[count].tag=NULL;
    } while (p!=NULL && p[0]!='\0');
d2486 1
a2486 1
    document *,		newdoc)
a2691 1
#ifndef SH_EX	/* 1999/01/19 (Tue) */
a2700 1
#endif
d2720 1
a2720 1
	    SLtt_Use_Ansi_Colors = (LYShowColor > 1 ? 1 : 0);
d2731 24
d2837 8
d2869 6
a2874 1
	/* Local Directory Sort: SELECT */
d2876 1
a2876 1
	    GetOptValues(dired_values, data[i].value, &dir_list_style);
d2878 1
d2887 1
d2893 1
d2933 6
a2938 3
     if ( display_char_set_old != current_char_set ||
	       raw_mode_old != LYRawMode ||
	       assume_char_set_changed ) {
d2968 1
a2968 2
     } /* end of charset settings */

d2973 1
a2973 1
    FREE(newdoc->post_data);
d3016 1
a3016 2
    /* comment out to avoid warning when removing forms content... */
    /* HTuncache_current_document(); */ /* will never use again */
d3054 1
a3054 1
	  strncmp(newdoc->address, "lynxcgi:", 8) == 0))) {
d3083 1
a3083 1
#ifdef SOURCE_CACHE
d3129 2
d3141 1
a3141 1
	fprintf(fp, "  %-33s: ", name);
d3146 2
a3147 2
		(l < 30) ? " " : "",
		(l < 30) ? 32 - l : 3, "(!)");
d3178 2
a3179 2
	"set_cookies",			/* LYSetCookies */
	"accept_all_cookies",		/* LYAcceptAllCookies */
d3193 2
a3194 2
	"make_pseudo_alts_for_inlines",	/* pseudo_inline_alts */
	"make_links_for_all_images",	/* clickable_images */
d3201 13
d3234 1
a3234 8
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
	HTAlert(UNABLE_TO_OPEN_TEMPFILE);
a3235 1
    }
d3244 1
a3244 2
       changes. (But that code doesn't do that - HTuncache_current_document
       is currently commented out.) - kw 1999-11-27
d3266 1
a3266 1
    fprintf(fp0, "<form action=\"LYNXOPTIONS:\" method=\"post\">\n");
d3283 2
a3284 2
	fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
	fprintf(fp0,"%s\n", CANCEL_CHANGES);
d3296 2
a3297 1
	fprintf(fp0, "<br>(options marked with (!) will not be saved)\n");
d3316 1
a3316 1
    PutTextInput(fp0, editor_string, NOTEMPTY(editor), text_len,
d3325 3
d3342 13
d3407 10
d3419 1
a3419 1
    BeginSelect(fp0, display_char_set_string);
d3478 1
a3478 1
    PutTextInput(fp0, x_display_string, NOTEMPTY(x_display), text_len, "");
d3518 14
a3537 1
#ifndef SH_EX  /* 1999/01/19 (Tue) */
a3542 1
#endif
d3573 1
a3573 1
		      NOTEMPTY(personal_mail_address), text_len, "");
d3578 1
a3578 1
		      NOTEMPTY(pref_charset), cset_len+2, "");
d3583 1
a3583 1
		      NOTEMPTY(language), cset_len+2, "");
d3589 1
a3589 1
			  NOTEMPTY(LYUserAgent), text_len, "");
d3606 7
a3612 1
    PutLabel(fp0, gettext("Local directory sort criteria"), dired_sort_string);
d3614 1
a3614 1
    PutOptValues(fp0, dir_list_style, dired_values);
d3616 1
d3647 2
a3648 2
#ifdef EXP_READPROGRESS
    /* Local Directory Sort: SELECT */
d3651 11
a3661 1
    PutOptValues(fp0, LYTransferRate, rate_values);
d3663 1
a3663 1
#endif /* EXP_READPROGRESS */
d3682 2
a3683 2
	fprintf(fp0, "<a href=\"LYNXOPTIONS://MBM_MENU\">%s</a>\n",
		    gettext("Goto multi-bookmark menu"));
d3687 1
a3687 1
			 NOTEMPTY(bookmark_page), text_len, "");
d3692 1
a3692 3
    BeginSelect(fp0, visited_links_string);
    PutOptValues(fp0, Visited_Links_As, visited_links_values);
    EndSelect(fp0);
d3695 3
a3697 1
	fprintf(fp0, "\n  Check your <a href=\"LYNXCFG:\">lynx.cfg</a> here\n");
d3705 2
a3706 2
	fprintf(fp0,"<input type=\"submit\" value=\"%s\">\n - ", ACCEPT_CHANGES);
	fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d29 2
d33 1
a33 1
#if !defined(NO_OPTION_MENU) || defined(NCURSES_MOUSE_VERSION)
d37 83
d125 3
a127 1
	char **		choices));
d193 11
a203 11
#define L_Bool_A (use_assume_charset ? L_BOOL_A + 1 : L_BOOL_A)
#define L_Bool_B (use_assume_charset ? L_BOOL_B + 1 : L_BOOL_B)
#define L_Exec (use_assume_charset ? L_EXEC + 1 : L_EXEC)
#define L_Rawmode (use_assume_charset ? L_RAWMODE + 1 : L_RAWMODE)
#define L_Charset (use_assume_charset ? L_CHARSET + 1 : L_CHARSET)
#define L_Color (use_assume_charset ? L_COLOR + 1 : L_COLOR)
#define L_Keypad (use_assume_charset ? L_KEYPAD + 1 : L_KEYPAD)
#define L_Lineed (use_assume_charset ? L_LINEED + 1 : L_LINEED)
#define L_Layout (use_assume_charset ? L_LAYOUT + 1 : L_LAYOUT)
#define L_Dired (use_assume_charset ? L_DIRED + 1 : L_DIRED)
#define L_User_Mode (use_assume_charset ? L_USER_MODE + 1 : L_USER_MODE)
d213 1
a213 1
	addstr(text);
d219 1
a219 1
 * addlbl() is used instead of plain addstr() in old-style options menu
d246 15
d263 53
a315 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d317 1
a317 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d333 1
a333 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d343 1
a343 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d345 1
a345 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d355 1
a355 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d369 1
a369 26
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
				     SHOW_COLOR_ON :
				     SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
#if defined(COLOR_CURSES)
		if (!has_colors())
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
#endif
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				     SHOW_COLOR_ALWAYS :
				     SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
				     SHOW_COLOR_ON :
				     SHOW_COLOR_OFF;
	    }
	}
d374 1
a374 1
	use_assume_charset = (user_mode == ADVANCED_MODE);
a382 1
    response = 0;
d385 1
a385 1
	clear();
d387 1
a387 1
	erase();
d390 1
a390 1
    clear();
d392 1
a392 1
    move(0, 5);
d395 5
a399 5
    addstr("         Options Menu (");
    addstr(LYNX_NAME);
    addstr(" Version ");
    addstr(LYNX_VERSION);
    addch(')');
d401 1
a401 1
    move(L_EDITOR, 5);
d403 1
a403 1
    addstr((editor && *editor) ? editor : "NONE");
d405 1
a405 1
    move(L_DISPLAY, 5);
d407 1
a407 1
    addstr((x_display && *x_display) ? x_display : "NONE");
d409 1
a409 1
    move(L_HOME, 5);
d411 3
a413 6
    addstr((LYMultiBookmarks ?
	      (LYMBMAdvanced ? "ADVANCED"
			     : "STANDARD")
			     : "OFF     "));
    move(L_HOME, B_BOOK);
    if (LYMultiBookmarks) {
d417 1
a417 1
	addstr((bookmark_page && *bookmark_page) ? bookmark_page : "NONE");
d420 1
a420 1
    move(L_FTPSTYPE, 5);
d422 1
a422 1
    addstr((HTfileSortMethod == FILE_BY_NAME ? "By Filename" :
d427 1
a427 1
    move(L_MAIL_ADDRESS, 5);
d429 1
a429 1
    addstr((personal_mail_address && *personal_mail_address) ?
d432 1
a432 1
    move(L_SSEARCH, 5);
d434 1
a434 1
    addstr(case_sensitive ? "CASE SENSITIVE  " : "CASE INSENSITIVE");
d436 1
a436 1
    move(L_Charset, 5);
d438 1
a438 1
    addstr((char *)LYchar_set_names[current_char_set]);
d440 1
a440 1
    move(L_LANGUAGE, 5);
d442 1
a442 1
    addstr((language && *language) ? language : "NONE");
d444 1
a444 1
    move(L_PREF_CHARSET, 5);
d446 1
a446 1
    addstr((pref_charset && *pref_charset) ? pref_charset : "NONE");
d449 1
a449 1
	move(L_ASSUME_CHARSET, 5);
d452 1
a452 1
	    addstr(UCAssume_MIMEcharset);
d454 2
a455 2
	    addstr((UCLYhndl_for_unspec >= 0) ?
		   (char *)LYCharSet_UC[UCLYhndl_for_unspec].MIMEname
d459 1
a459 1
    move(L_Rawmode, 5);
d461 1
a461 1
    addstr(LYRawMode ? "ON " : "OFF");
d464 1
a464 1
    move(L_Color, B_COLOR);
d467 1
a467 2
	addstr((LYShowColor == SHOW_COLOR_OFF ? "OFF" :
						"ON "));
d471 1
a471 1
		addstr("NEVER     ");
d474 1
a474 1
		addstr("OFF");
d477 1
a477 1
		addstr("ON ");
d482 1
a482 1
		    addstr("Always try");
d485 1
a485 1
		    addstr("ALWAYS    ");
d490 1
a490 1
    move(L_Bool_A, B_VIKEYS);
d492 1
a492 1
    addstr(vi_keys ? "ON " : "OFF");
d494 1
a494 1
    move(L_Bool_A, B_EMACSKEYS);
d496 1
a496 1
    addstr(emacs_keys ? "ON " : "OFF");
d498 1
a498 1
    move(L_Bool_A, B_SHOW_DOTFILES);
d500 1
a500 1
    addstr((!no_dotfiles && show_dotfiles) ? "ON " : "OFF");
d502 1
a502 1
    move(L_Bool_B, B_SELECT_POPUPS);
d504 1
a504 1
    addstr(LYSelectPopups ? "ON " : "OFF");
d506 1
a506 1
    move(L_Bool_B, B_SHOW_CURSOR);
d508 1
a508 1
    addstr(LYShowCursor ? "ON " : "OFF");
d510 1
a510 1
    move(L_Keypad, 5);
d512 1
a512 1
    addstr((keypad_mode == NUMBERS_AS_ARROWS) ?
d518 1
a518 1
    move(L_Lineed, 5);
d520 1
a520 1
    addstr(LYLineeditNames[current_lineedit]);
d523 1
a523 1
    move(L_Layout, 5);
d525 1
a525 1
    addstr(LYKbLayoutNames[current_layout]);
d529 1
a529 1
    move(L_Dired, 5);
d531 1
a531 1
    addstr((dir_list_style == FILES_FIRST) ? "Files first      " :
d536 1
a536 1
    move(L_User_Mode, 5);
d538 1
a538 1
    addstr(  (user_mode == NOVICE_MODE) ? "Novice      " :
d543 1
a543 1
    addstr( verbose_img ? "ON " : "OFF" );
d545 1
a545 1
    move(L_User_Agent, 5);
d547 1
a547 1
    addstr((LYUserAgent && *LYUserAgent) ? LYUserAgent : "NONE");
d549 2
a550 2
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
    move(L_Exec, 5);
d553 1
a553 1
    addstr(               local_exec ? "ALWAYS ON           " :
d557 1
a557 1
    addstr(local_exec_on_local_files ? "FOR LOCAL FILES ONLY" :
d560 1
a560 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d562 2
a563 2
    move(LYlines-3, 2);
    addstr(SELECT_SEGMENT);
d565 1
a565 1
    addstr(CAP_LETT_SEGMENT);
d567 1
a567 1
    addstr(OF_OPT_LINE_SEGMENT);
d569 1
a569 1
	addstr(" '");
d571 1
a571 1
	addstr(">");
d573 2
a574 2
	addstr("'");
	addstr(TO_SAVE_SEGMENT);
d576 2
a577 2
    addstr(OR_SEGMENT);
    addstr("'");
d579 1
a579 1
    addstr("r");
d581 2
a582 2
    addstr("'");
    addstr(TO_RETURN_SEGMENT);
d584 2
a585 1
    while (TOUPPER(response) != 'R' &&
d588 1
a588 1
	   response != 7 &&  response != 3) {
d593 1
a593 1
	move((LYlines - 2), 0);
d595 1
a595 1
	addstr(COMMAND_PROMPT);
d598 3
a600 3
	refresh();
	response = LYgetch();
	if (term_options || response == 7 || response == 3)
d607 1
a607 2
	    case 'e':	/* Change the editor. */
	    case 'E':
d614 1
a614 1
			strcpy(display_option, editor);
d616 2
a617 2
			move(L_EDITOR, COL_OPTION_VALUES);
			addstr("    ");
d621 1
a621 1
		    move(L_EDITOR, COL_OPTION_VALUES);
d626 1
a626 1
		    move(L_EDITOR, COL_OPTION_VALUES);
d628 1
a628 1
			addstr((editor && *editor) ?
d632 1
a632 1
			addstr("NONE");
d635 1
a635 1
			addstr(display_option);
d637 1
a637 1
		    clrtoeol();
d648 1
a648 2
	    case 'd':	/* Change the display. */
	    case 'D':
d650 1
a650 1
		    strcpy(display_option, x_display);
d652 2
a653 2
		    move(L_DISPLAY, COL_OPTION_VALUES);
		    addstr("    ");
d657 1
a657 1
		move(L_DISPLAY, COL_OPTION_VALUES);
d662 2
a663 3
		move(L_DISPLAY, COL_OPTION_VALUES);
		if ((term_options || ch == -1) ||
		    (x_display != NULL &&
d665 1
a665 1
		     !strcasecomp(x_display, display_option)))
d667 1
a667 1
		     !strcmp(x_display, display_option)))
d669 4
a672 1
		{
d677 2
a678 2
		    addstr((x_display && *x_display) ? x_display : "NONE");
		    clrtoeol();
d694 2
a695 2
			addstr("NONE");
			clrtoeol();
d705 1
a705 5
		if ((cp = LYgetXDisplay()) != NULL) {
		    StrAllocCopy(x_display, cp);
		} else {
		    FREE(x_display);
		}
d707 3
a709 21
		addstr(x_display ? x_display : "NONE");
		clrtoeol();
		if ((x_display == NULL && *display_option == '\0') ||
		    (x_display != NULL &&
		     !strcmp(x_display, display_option))) {
		    if (x_display == NULL &&
			LYisConfiguredForX == TRUE) {
			_statusline(VALUE_ACCEPTED_WARNING_X);
		    } else if (x_display != NULL &&
			LYisConfiguredForX == FALSE) {
			_statusline(VALUE_ACCEPTED_WARNING_NONX);
		    } else {
			_statusline(VALUE_ACCEPTED);
		    }
		} else {
		    if (*display_option) {
			_statusline(FAILED_TO_SET_DISPLAY);
		    } else {
			_statusline(FAILED_CLEAR_SET_DISPLAY);
		    }
		}
d713 1
a713 2
	    case 'l':	/* Change multibookmarks option. */
	    case 'L':
a718 7
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF     ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "STANDARD");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "ADVANCED");
		choices[3] = NULL;
d720 1
a720 2
		    LYMultiBookmarks = boolean_choice((LYMultiBookmarks *
						       (1 + LYMBMAdvanced)),
d722 1
a722 1
						      choices);
d724 1
a724 2
		    LYMultiBookmarks = popup_choice((LYMultiBookmarks *
						     (1 + LYMBMAdvanced)),
d726 2
a727 8
						    choices,
						    3, FALSE);
		}
		if (LYMultiBookmarks == 2) {
		    LYMultiBookmarks = TRUE;
		    LYMBMAdvanced = TRUE;
		} else {
		    LYMBMAdvanced = FALSE;
d731 3
a733 3
		    move(L_HOME, C_MULTI);
		    clrtoeol();
		    addstr(choices[(LYMultiBookmarks * (1 + LYMBMAdvanced))]);
a735 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d740 4
a743 4
		    move(L_HOME, B_BOOK);
		    clrtoeol();
		    if (LYMultiBookmarks) {
			addstr(gettext("review/edit B)ookmarks files"));
d745 2
a746 2
			addstr(gettext("B)ookmark file: "));
			addstr((bookmark_page && *bookmark_page) ?
d752 1
a752 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d756 1
a756 2
	    case 'b':	/* Change the bookmark page location. */
	    case 'B':
d762 1
a762 1
		    if (LYMultiBookmarks) {
d768 1
a768 1
			strcpy(display_option, bookmark_page);
d770 2
a771 2
			move(L_HOME, C_DEFAULT);
			clrtoeol();
d775 1
a775 1
		    move(L_HOME, C_DEFAULT);
d780 1
a780 1
		    move(L_HOME, C_DEFAULT);
d783 1
a783 1
			addstr((bookmark_page && *bookmark_page) ?
d787 1
a787 1
			addstr((bookmark_page && *bookmark_page) ?
d789 1
a789 1
			clrtoeol();
d795 2
a796 3
			StrAllocCopy(MBM_A_subbookmark[0],
				     bookmark_page);
			addstr(bookmark_page);
d798 1
a798 1
		    clrtoeol();
d811 1
a811 14
	    case 'f':	/* Change ftp directory sorting. */
	    case 'F':	/*  (also local for non-DIRED)	 */
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "By Filename");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "By Type    ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "By Size    ");
		choices[3] = NULL;
		StrAllocCopy(choices[3], "By Date    ");
		choices[4] = NULL;
d813 1
a813 1
		    HTfileSortMethod = boolean_choice(HTfileSortMethod,
d815 1
a815 1
						      choices);
d817 1
a817 1
		    HTfileSortMethod = popup_choice(HTfileSortMethod,
d819 2
a820 2
						    choices,
						    4, FALSE);
d822 3
a824 3
		    move(L_FTPSTYPE, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[HTfileSortMethod]);
a826 4
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
		FREE(choices[3]);
d829 1
a829 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d833 1
a833 2
	    case 'p': /* Change personal mail address for From headers. */
	    case 'P':
d835 1
a835 1
		    strcpy(display_option, personal_mail_address);
d837 2
a838 2
		    move(L_MAIL_ADDRESS, COL_OPTION_VALUES);
		    addstr("    ");
d842 1
a842 1
		move(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d847 1
a847 1
		move(L_MAIL_ADDRESS, COL_OPTION_VALUES);
d849 1
a849 1
		    addstr((personal_mail_address &&
d854 1
a854 1
		    addstr("NONE");
d857 1
a857 1
		    addstr(display_option);
d859 1
a859 1
		clrtoeol();
d869 4
a872 14
	    case 's':	/* Change case sensitivity for searches. */
	    case 'S':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "CASE INSENSITIVE");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "CASE SENSITIVE  ");
		choices[2] = NULL;
		case_sensitive = boolean_choice(case_sensitive,
						L_SSEARCH, -1, choices);
		FREE(choices[0]);
		FREE(choices[1]);
d879 2
a880 2
		    char ** assume_list;
		    assume_list = (char **)calloc(LYNumCharsets + 1, sizeof(char *));
d885 1
a885 1
			assume_list[i] = (char *)LYCharSet_UC[i].MIMEname;
d894 9
a902 1
			UCLYhndl_for_unspec = boolean_choice(curval,
d905 1
d907 10
a916 1
			UCLYhndl_for_unspec = popup_choice(curval,
d919 2
a920 1
							   0, FALSE);
d922 2
a923 2
			move(L_ASSUME_CHARSET, COL_OPTION_VALUES);
			clrtoeol();
d925 1
a925 2
			    addstr((char *)
				   LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d939 2
a940 1
			LYRawMode = (UCLYhndl_for_unspec == current_char_set);
d949 3
a951 3
			    move(L_Rawmode, COL_OPTION_VALUES);
			    clrtoeol();
			    addstr(LYRawMode ? "ON " : "OFF");
d957 1
a957 10
#if !defined(VMS) || defined(USE_SLANG)
			if (term_options) {
			    term_options = FALSE;
			} else {
			    AddValueAccepted = TRUE;
			}
			goto draw_options;
#else
			term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d965 1
a965 2
	    case 'c':	/* Change display charset setting. */
	    case 'C':
d967 7
a973 1
		    current_char_set = boolean_choice(current_char_set,
d975 2
a976 1
						      (char **)LYchar_set_names);
d978 2
a979 1
		    current_char_set = popup_choice(current_char_set,
d981 10
a990 2
						    (char **)LYchar_set_names,
						    0, FALSE);
d992 3
a994 3
		    move(L_Charset, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr((char *)LYchar_set_names[current_char_set]);
d1010 10
a1019 4
			move(L_Rawmode, COL_OPTION_VALUES);
			clrtoeol();
			addstr(LYRawMode ? "ON " : "OFF");
		    }
d1023 1
a1023 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1027 2
a1028 11
	    case 'o':	/* Change raw mode setting. */
	    case 'O':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		LYRawMode = boolean_choice(LYRawMode, L_Rawmode, -1, choices);
a1037 2
		FREE(choices[0]);
		FREE(choices[1]);
d1041 1
a1041 2
	    case 'g':	/* Change language preference. */
	    case 'G':
d1043 1
a1043 1
		    strcpy(display_option, language);
d1045 2
a1046 2
		    move(L_LANGUAGE, COL_OPTION_VALUES);
		    addstr("    ");
d1050 1
a1050 1
		move(L_LANGUAGE, COL_OPTION_VALUES);
d1055 1
a1055 1
		move(L_LANGUAGE, COL_OPTION_VALUES);
d1057 1
a1057 1
		    addstr((language && *language) ?
d1061 1
a1061 1
		    addstr("NONE");
d1064 1
a1064 1
		    addstr(display_option);
d1066 1
a1066 1
		clrtoeol();
d1076 1
a1076 2
	    case 'h':	/* Change charset preference. */
	    case 'H':
d1078 1
a1078 1
		    strcpy(display_option, pref_charset);
d1080 2
a1081 2
		    move(L_PREF_CHARSET, COL_OPTION_VALUES);
		    addstr("    ");
d1085 1
a1085 1
		move(L_PREF_CHARSET, COL_OPTION_VALUES);
d1090 1
a1090 1
		move(L_PREF_CHARSET, COL_OPTION_VALUES);
d1092 1
a1092 1
		    addstr((pref_charset && *pref_charset) ?
d1096 1
a1096 1
		    addstr("NONE");
d1099 1
a1099 1
		    addstr(display_option);
d1101 1
a1101 1
		clrtoeol();
d1111 2
a1112 11
	    case 'v':	/* Change VI keys setting. */
	    case 'V':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		vi_keys = boolean_choice(vi_keys,
d1114 1
a1114 1
					 choices);
a1119 2
		FREE(choices[0]);
		FREE(choices[1]);
d1124 1
a1124 10
	    case 'm':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		emacs_keys = boolean_choice(emacs_keys,
d1126 1
a1126 1
					    choices);
a1131 2
		FREE(choices[0]);
		FREE(choices[1]);
a1135 1
	    case 'w':
d1139 1
a1139 9
		    /*
		     *	Copy strings into choice array.
		     */
		    choices[0] = NULL;
		    StrAllocCopy(choices[0], "OFF");
		    choices[1] = NULL;
		    StrAllocCopy(choices[1], "ON ");
		    choices[2] = NULL;
		    show_dotfiles = boolean_choice(show_dotfiles,
d1142 1
a1142 3
						   choices);
		    FREE(choices[0]);
		    FREE(choices[1]);
d1147 2
a1148 11
	    case 't':	/* Change select popups setting. */
	    case 'T':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		LYSelectPopups = boolean_choice(LYSelectPopups,
d1151 1
a1151 3
						choices);
		FREE(choices[0]);
		FREE(choices[1]);
d1167 1
d1170 1
a1170 9
		/*
		 *  Copy strings into choice array.
		 */
		    choices[0] = NULL;
		    StrAllocCopy(choices[0], "OFF");
		    choices[1] = NULL;
		    StrAllocCopy(choices[1], "ON ");
		    choices[2] = NULL;
		    LYShowColor = boolean_choice((LYShowColor - 1),
d1173 1
a1173 1
						 choices);
d1182 3
a1184 3
		/*
		 *  Copy strings into choice array.
		 */
d1201 1
a1201 1
			    chosen = boolean_choice(LYChosenShowColor,
d1206 1
a1206 1
			    chosen = popup_choice(LYChosenShowColor,
d1209 1
a1209 1
						  choices, 4, FALSE);
d1212 1
a1212 1
			again = (chosen == 2 && !has_colors());
d1227 3
a1229 3
			move(L_Color, C_COLOR);
			clrtoeol();
			addstr(choices[LYChosenShowColor]);
d1236 2
a1240 2
		FREE(choices[0]);
		FREE(choices[1]);
d1250 1
a1250 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1256 1
a1256 9
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
		LYShowCursor = boolean_choice(LYShowCursor,
d1259 1
a1259 3
					      choices);
		FREE(choices[0]);
		FREE(choices[1]);
d1263 1
a1263 15
	    case 'k':	/* Change keypad mode. */
	    case 'K':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0],
			     "Numbers act as arrows             ");
		choices[1] = NULL;
		StrAllocCopy(choices[1],
			     "Links are numbered                ");
		choices[2] = NULL;
		StrAllocCopy(choices[2],
			     "Links and form fields are numbered");
		choices[3] = NULL;
d1265 1
a1265 1
		    keypad_mode = boolean_choice(keypad_mode,
d1267 1
a1267 1
						 choices);
d1269 4
a1272 4
		    keypad_mode = popup_choice(keypad_mode,
					       L_Keypad, -1,
					       choices,
					       3, FALSE);
d1274 3
a1276 3
		    move(L_Keypad, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[keypad_mode]);
a1283 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d1286 1
a1286 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1290 1
a1290 2
	    case 'n':	/* Change line editor key bindings. */
	    case 'N':
d1292 1
a1292 1
		    current_lineedit = boolean_choice(current_lineedit,
d1296 1
a1296 1
		    current_lineedit = popup_choice(current_lineedit,
d1299 1
a1299 1
						    0, FALSE);
d1301 3
a1303 3
		    move(L_Lineed, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(LYLineeditNames[current_lineedit]);
d1308 1
a1308 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1313 1
a1313 2
	    case 'y':	/* Change keyboard layout */
	    case 'Y':
d1315 1
a1315 1
		    current_layout = boolean_choice(current_layout,
d1319 1
a1319 1
		    current_layout = popup_choice(current_layout,
d1322 1
a1322 1
						    0, FALSE);
d1324 3
a1326 3
		    move(L_Layout, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(LYKbLayoutNames[current_layout]);
d1331 1
a1331 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1337 1
a1337 12
	    case 'i':	/* Change local directory sorting. */
	    case 'I':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "Directories first");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "Files first      ");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "Mixed style      ");
		choices[3] = NULL;
d1339 1
a1339 1
		    dir_list_style = boolean_choice(dir_list_style,
d1341 1
a1341 1
						    choices);
d1343 1
a1343 1
		    dir_list_style = popup_choice(dir_list_style,
d1345 2
a1346 2
						  choices,
						  3, FALSE);
d1348 3
a1350 3
		    move(L_Dired, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[dir_list_style]);
a1352 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d1355 1
a1355 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1360 1
a1360 12
	    case 'u':	/* Change user mode. */
	    case 'U':
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "Novice      ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "Intermediate");
		choices[2] = NULL;
		StrAllocCopy(choices[2], "Advanced    ");
		choices[3] = NULL;
d1362 10
a1371 10
		    user_mode = boolean_choice(user_mode,
					       L_User_Mode, -1,
					       choices);
		    use_assume_charset = (user_mode >= 2);
		} else {
		    user_mode = popup_choice(user_mode,
					     L_User_Mode, -1,
					     choices,
					     3, FALSE);
		    use_assume_charset = (user_mode >= 2);
d1374 3
a1376 3
			move(L_User_Mode, COL_OPTION_VALUES);
			clrtoeol();
			addstr(choices[user_mode]);
a1379 3
		FREE(choices[0]);
		FREE(choices[1]);
		FREE(choices[2]);
d1387 1
a1387 12
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
		    if (use_assume_charset != old_use_assume_charset)
			goto draw_options;
#endif /* !VMS || USE_SLANG */
a1391 8
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "OFF");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "ON ");
		choices[2] = NULL;
d1393 1
a1393 1
		    verbose_img = boolean_choice(verbose_img,
d1396 1
a1396 1
						choices);
d1398 1
a1398 1
		    verbose_img = popup_choice(verbose_img,
d1401 2
a1402 2
					     choices,
					     2, FALSE);
a1403 2
		FREE(choices[0]);
		FREE(choices[1]);
d1406 1
a1406 12
#if !defined(VMS) || defined(USE_SLANG)
		    if (term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
		    if (use_assume_charset != old_use_assume_charset)
			goto draw_options;
#endif /* !VMS || USE_SLANG */
d1410 1
a1410 2
	    case 'a':	/* Change user agent string. */
	    case 'A':
d1413 1
a1413 1
			strcpy(display_option, LYUserAgent);
d1415 2
a1416 2
			move(L_HOME, COL_OPTION_VALUES);
			addstr("    ");
d1420 1
a1420 1
		    move(L_User_Agent, COL_OPTION_VALUES);
d1425 1
a1425 1
		    move(L_User_Agent, COL_OPTION_VALUES);
d1427 1
a1427 1
			addstr((LYUserAgent &&
d1432 1
a1432 1
			addstr((LYUserAgent &&
d1437 1
a1437 1
			addstr(display_option);
d1439 1
a1439 1
		    clrtoeol();
d1443 2
a1444 4
		    } else if (LYUserAgent && *LYUserAgent &&
			!strstr(LYUserAgent, "Lynx") &&
			!strstr(LYUserAgent, "lynx")) {
			_statusline(UA_COPYRIGHT_WARNING);
d1449 1
a1449 1
		    _statusline(UA_COPYRIGHT_WARNING);
d1454 2
a1455 3
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
	    case 'x':	/* Change local exec restriction. */
	    case 'X':
a1472 12
		/*
		 *  Copy strings into choice array.
		 */
		choices[0] = NULL;
		StrAllocCopy(choices[0], "ALWAYS OFF          ");
		choices[1] = NULL;
		StrAllocCopy(choices[1], "FOR LOCAL FILES ONLY");
		choices[2] = NULL;
#ifndef NEVER_ALLOW_REMOTE_EXEC
		StrAllocCopy(choices[2], "ALWAYS ON           ");
		choices[3] = NULL;
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
d1474 1
a1474 1
		    itmp = boolean_choice(itmp,
d1476 1
a1476 1
					  choices);
d1478 1
a1478 1
		    itmp = popup_choice(itmp,
d1480 3
a1482 2
					choices,
					0, (exec_frozen ? TRUE : FALSE));
d1484 3
a1486 3
		    move(L_Exec, COL_OPTION_VALUES);
		    clrtoeol();
		    addstr(choices[itmp]);
a1488 5
		FREE(choices[0]);
		FREE(choices[1]);
#ifndef NEVER_ALLOW_REMOTE_EXEC
		FREE(choices[2]);
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
d1509 1
a1509 10
#if !defined(VMS) || defined(USE_SLANG)
		    if (exec_frozen || term_options) {
			term_options = FALSE;
		    } else {
			AddValueAccepted = TRUE;
		    }
		    goto draw_options;
#else
		    term_options = FALSE;
#endif /* !VMS || USE_SLANG */
d1512 1
a1512 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d1516 4
a1519 4
		    _statusline(SAVING_OPTIONS);
		    if (save_rc()) {
			LYrcShowColor = LYChosenShowColor;
			_statusline(OPTIONS_SAVED);
d1524 1
a1524 1
		    _statusline(R_TO_RETURN_TO_LYNX);
d1533 1
a1533 2
	    case 'r':	/* Return to document (quit options menu). */
	    case 'R':
d1538 1
a1538 1
		    _statusline(SAVE_OR_R_TO_RETURN_TO_LYNX);
d1540 1
a1540 1
		    _statusline(R_TO_RETURN_TO_LYNX);
d1550 22
d1573 1
a1573 2
 *  Take a boolean status,prompt the user for a new status,
 *  and return it.
d1579 1
a1579 1
	char **,	choices)
d1586 1
d1604 1
a1604 1
    move(line, col);
d1606 1
a1606 1
    addstr(choices[cur_choice]);
d1608 2
a1609 2
	move(line, (col - 1));
    refresh();
d1619 1
a1619 1
	move(line, col);
d1621 1
a1621 1
	    response = LYgetch();
d1623 1
a1623 1
	if (term_options || response == 7 || response == 3) {
d1640 1
a1640 1
	    (cmd = keymap[response+1]) != LYK_ACTIVATE) {
d1652 1
a1652 1
		    refresh();
d1666 1
d1695 1
a1695 1
	    addstr(choices[cur_choice]);
d1697 2
a1698 2
		move(line, (col - 1));
	    refresh();
d1703 1
a1703 1
	    move(line, col);
d1705 1
a1705 1
	    addstr(choices[cur_choice]);
d1714 1
a1714 1
	    return(cur_choice);
d1734 1
a1734 1
	refresh();
d1768 1
a1768 1
	clear();
d1770 1
a1770 1
	erase();
d1773 1
a1773 1
    clear();
d1775 1
a1775 1
    move(0, 5);
d1779 1
a1779 1
	addstr(ehead_buffer);
d1781 1
a1781 1
	addstr(MULTIBOOKMARKS_EHEAD);
d1788 3
a1790 3
	    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 5);
	    addch((unsigned char)(a + 'A'));
	    addstr(" : ");
d1792 3
a1794 3
		addstr(MBM_A_subdescript[a]);
	    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)), 35);
	    addstr("| ");
d1796 1
a1796 1
		addstr(MBM_A_subbookmark[a]);
d1801 3
a1803 3
	    move(3 + a, 5);
	    addch((unsigned char)(a + 'A'));
	    addstr(" : ");
d1805 3
a1807 3
		addstr(MBM_A_subdescript[a]);
	    move(3 + a, 35);
	    addstr("| ");
d1809 1
a1809 1
		addstr(MBM_A_subbookmark[a]);
d1818 2
a1819 2
	move((LYlines - 4), 0);
	addstr("'");
d1821 1
a1821 1
	addstr("[");
d1823 3
a1825 3
	addstr("' ");
	addstr(PREVIOUS);
	addstr(", '");
d1827 1
a1827 1
	addstr("]");
d1829 2
a1830 2
	addstr("' ");
	addstr(NEXT_SCREEN);
d1833 1
a1833 1
    move((LYlines - 3), 0);
d1835 1
a1835 1
	addstr("'");
d1837 1
a1837 1
	addstr(">");
d1839 2
a1840 2
	addstr("'");
	addstr(TO_SAVE_SEGMENT);
d1842 2
a1843 2
    addstr(OR_SEGMENT);
    addstr("'");
d1845 1
a1845 1
    addstr("^G");
d1847 2
a1848 2
    addstr("'");
    addstr(TO_RETURN_SEGMENT);
d1852 1
a1852 2
	   response != 7 && response != 3 &&
	   response != '>') {
d1854 1
a1854 1
	move((LYlines - 2), 0);
d1856 1
a1856 1
	addstr(MULTIBOOKMARKS_LETTER);
d1859 2
a1860 2
	refresh();
	response = (def_response ? def_response : LYgetch());
d1866 1
a1866 2
	if (term_options ||
	    response == 7 || response == 3 ||
d1875 3
a1877 3
		_statusline(SAVING_OPTIONS);
		if (save_rc())
		    _statusline(OPTIONS_SAVED);
d1881 1
a1881 1
		_statusline(R_TO_RETURN_TO_LYNX);
d1925 1
a1925 1
	    if ((TOUPPER(response) - 'A') == a) {
d1943 1
a1943 1
			move(
d1947 2
a1948 2
			move((3 + a), 9);
		    strcpy(MBM_tmp_line,
d1950 2
a1951 1
					       "" : MBM_A_subdescript[a]));
d1962 1
a1962 1
			move(
d1966 3
a1968 3
			move((3 + a), 5);
		    addch((unsigned char)(a + 'A'));
		    addstr(" : ");
d1970 3
a1972 3
			addstr(MBM_A_subdescript[a]);
		    clrtoeol();
		    refresh();
d1976 1
a1976 1
		    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current - 1)),
d1979 2
a1980 2
		    move((3 + a), 35);
		addstr("| ");
d1983 3
a1985 2
		strcpy(MBM_tmp_line,
		       (!MBM_A_subbookmark[a] ? "" : MBM_A_subbookmark[a]));
d1998 1
a1998 1
			sleep(AlertSecs);
d2006 1
a2006 1
		    move((3 + a) - ((MBM_V_MAXFILES/2 + 1)*(MBM_current-1)),
d2009 2
a2010 2
		    move((3 + a), 35);
		addstr("| ");
d2012 4
a2015 4
		    addstr(MBM_A_subbookmark[a]);
		clrtoeol();
		move(LYlines-1, 0);
		clrtoeol();
d2025 1
a2025 42
#if !defined(NO_OPTION_MENU) || defined(NCURSES_MOUSE_VERSION)
/*
**  This function prompts for a choice or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM
*/
PRIVATE int get_popup_choice_number ARGS1(
	int *,		c)
{
    char temp[120];

    /*
     *	Load the c argument into the prompt buffer.
     */
    temp[0] = *c;
    temp[1] = '\0';
    _statusline(OPTION_CHOICE_NUMBER);

    /*
     *	Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 ||
	*temp == 0 || term_options) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	term_options = FALSE;
	return(0);
    }

    /*
     *	If we had a 'g' or 'p' suffix, load it into c.
     *	Otherwise, zero c.  Then return the number.
     */
    if (strchr(temp, 'g') != NULL || strchr(temp, 'G') != NULL) {
	*c = 'g';
    } else if (strchr(temp, 'p') != NULL || strchr(temp, 'P') != NULL) {
	*c = 'p';
    } else {
	*c = '\0';
    }
    return(atoi(temp));
}
d2031 3
d2035 1
a2035 1
PUBLIC int popup_choice ARGS6(
d2039 1
a2039 1
	char **,	choices,
d2041 2
a2042 1
	int,		disabled)
d2044 2
a2045 26
    int ly = line;
    int lx = (column >= 0 ? column : (COL_OPTION_VALUES - 1));
    int c = 0, cmd = 0, i = 0, j = 0;
    int orig_choice = cur_choice;
#ifndef USE_SLANG
    WINDOW * form_window;
#endif /* !USE_SLANG */
    int num_choices = 0, top, bottom, length = -1;
    unsigned width = 0;
    char ** Cptr = choices;
    int window_offset = 0;
    int DisplayLines = (LYlines - 2);
    char Cnum[64];
    int Lnum;
    int npages;
    static char prev_target[512];		/* Search string buffer */
    static char prev_target_buffer[512];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0, recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[512];
d2047 17
a2063 23
    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
    QueryNum = QueryTotal;

    /*
     *	Count the number of choices to be displayed, where
     *	num_choices ranges from 0 to n, and set width to the
     *	longest choice string length.  Also set Lnum to the
     *	length for the highest choice number, then decrement
     *	num_choices so as to be zero-based.  The window width
     *	will be based on the sum of width and Lnum. - FM
     */
    for (num_choices = 0; Cptr[num_choices] != NULL; num_choices++) {
	if (strlen(Cptr[num_choices]) > width) {
	    width = strlen(Cptr[num_choices]);
d2065 1
a2066 917
    sprintf(Cnum, "%d: ", num_choices);
    Lnum = strlen(Cnum);
    num_choices--;

    /*
     *	Let's assume for the sake of sanity that ly is the number
     *	 corresponding to the line the option is on.
     *	Let's also assume that cur_choice is the number of the
     *	 choice that should be initially selected, with 0 being
     *	 the first choice.
     *	So what we have, is the top equal to the current screen line
     *	 subtracting the cur_choice + 1 (the one must be for the top
     *	 line we will draw in a box).  If the top goes under 0, then
     *	 consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     *	Check and see if we need to put the i_length parameter up to
     *	the number of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 *  Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     *	The bottom is the value of the top plus the number of choices
     *	to view plus 3 (one for the top line, one for the bottom line,
     *	and one to offset the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     *	Hmm...	If the bottom goes beyond the number of lines available,
     */
    if (bottom > DisplayLines) {
	/*
	 *  Position the window at the top if we have more
	 *  choices than will fit in the window.
	 */
	if ((i_length + 3) > DisplayLines) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > DisplayLines)
		bottom = (DisplayLines + 1);
	} else {
	    /*
	     *	Try to position the window so that the selected choice will
	     *	  appear where the choice box currently is positioned.
	     *	It could end up too high, at this point, but we'll move it
	     *	  down latter, if that has happened.
	     */
	    top = (DisplayLines + 1) - (i_length + 3);
	    bottom = (DisplayLines + 1);
	}
    }

    /*
     *	This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;

    /*
     *	Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > DisplayLines + 1)
	    bottom = DisplayLines + 1;
	top = bottom - length - 2;
    }

    /*
     *	Set up the overall window, including the boxing characters ('*'),
     *	if it all fits.  Otherwise, set up the widest window possible. - FM
     */
#ifdef USE_SLANG
    SLsmg_fill_region(top, lx - 1, bottom - top, (Lnum + width + 4), ' ');
#else
    if (!(form_window = newwin(bottom - top, (Lnum + width + 4),
			       top, (lx - 1))) &&
	!(form_window = newwin(bottom - top, 0, top, 0))) {
	HTAlert(POPUP_FAILED);
	return(orig_choice);
    }
    scrollok(form_window, TRUE);
#ifdef PDCURSES
    keypad(form_window, TRUE);
#endif /* PDCURSES */
#ifdef NCURSES
    LYsubwindow(form_window);
#endif
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
    wbkgd(form_window, getbkgd(stdscr));
    wbkgdset(form_window, getbkgd(stdscr));
#endif
#endif /* USE_SLANG */

    /*
     *	Clear the command line and write
     *	the popup statusline. - FM
     */
    move((LYlines - 2), 0);
    clrtoeol();
    if (disabled) {
	_statusline(CHOICE_LIST_UNM_MSG);
    } else {
	_statusline(CHOICE_LIST_MESSAGE);
    }

    /*
     *	Set up the window_offset for choices.
     *	 cur_choice ranges from 0...n
     *	 length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     *	Compute the number of popup window pages. - FM
     */
    npages = ((num_choices + 1) > length) ?
		(((num_choices + 1) + (length - 1))/(length))
					  : 1;
/*
 *  OH!  I LOVE GOTOs! hack hack hack
 */
redraw:
    Cptr = choices;

    /*
     *	Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    sprintf(Cnum, "%s%d: ",
			   ((num_choices > 8 && i < 9) ?
						   " " : ""),
			   (i + 1));
#ifdef USE_SLANG
	    SLsmg_gotorc(top + ((i + 1) - window_offset), (lx - 1 + 2));
	    addstr(Cnum);
	    SLsmg_write_nstring(Cptr[i], width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    wclrtoeol(form_window);
	    waddstr(form_window, Cnum);
	    waddstr(form_window, Cptr[i]);
#endif /* USE_SLANG */
	}
    }
#ifdef USE_SLANG
    SLsmg_draw_box(top, (lx - 1), (bottom - top), (Lnum + width + 4));
#else
#ifdef VMS
    VMSbox(form_window, (bottom - top), (Lnum + width + 4));
#else
    LYbox(form_window, FALSE);
#endif /* VMS */
    wrefresh(form_window);
#endif /* USE_SLANG */
    Cptr = NULL;

    /*
     *	Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	/*
	 *  Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    sprintf(Cnum, "%s%d: ",
			  ((num_choices > 8 && i < 9) ?
						  " " : ""),
			  (i + 1));
#ifdef USE_SLANG
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	    addstr(Cnum);
	    SLsmg_write_nstring(Cptr[i], width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    waddstr(form_window, Cnum);
	    waddstr(form_window, Cptr[i]);
#endif /* USE_SLANG */
	}
	Cptr = choices;
	i = cur_choice;
	sprintf(Cnum, "%s%d: ",
		      ((num_choices > 8 && i < 9) ?
					      " " : ""),
		      (i + 1));
#ifdef USE_SLANG
	SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	addstr(Cnum);
	SLsmg_set_color(2);
	SLsmg_write_nstring(Cptr[i], width);
	SLsmg_set_color(0);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current choice, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each choice is made current.  Otherwise, move it to
	 *  the bottom, right column of the screen, to "hide"
	 *  the cursor as for the main document, and let sighted
	 *  users rely on the current choice's highlighting or
	 *  color without the distraction of a blinking cursor
	 *  in the window. - FM
	 */
	if (LYShowCursor)
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 1));
	else
	    SLsmg_gotorc((LYlines - 1), (LYcols - 1));
	SLsmg_refresh();
#else
	wmove(form_window, ((i + 1) - window_offset), 2);
	waddstr(form_window, Cnum);
	wstart_reverse(form_window);
	waddstr(form_window, Cptr[i]);
	wstop_reverse(form_window);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current choice, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each choice is made current.  Otherwise, leave it to
	 *  the right of the current choice, since we can't move
	 *  it out of the window, and let sighted users rely on
	 *  the highlighting of the current choice without the
	 *  distraction of a blinking cursor preceding it. - FM
	 */
	if (LYShowCursor)
	    wmove(form_window, ((i + 1) - window_offset), 1);
	wrefresh(form_window);
#endif /* USE_SLANG  */

	term_options = FALSE;
	c = LYgetch_for(FOR_CHOICE);
	if (term_options || c == 3 || c == 7) {
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, i + 1 + window_offset, &cur_choice)) < 0)
		goto redraw;
	    if  (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = keymap[c+1];
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_choice_number((int *)&c);

		/*
		 *  Check for a 'p' suffix. - FM
		 */
		if (c == 'p') {
		    /*
		     *	Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_CHOICE_BEGIN);
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = 0;
			cur_choice = 0;
			if (disabled) {
			    _statusline(CHOICE_LIST_UNM_MSG);
			} else {
			    _statusline(CHOICE_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *	Treat a number equal to or greater than the
		     *	number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_choices - length) + 1)) {
			    HTUserMsg(ALREADY_AT_CHOICE_END);
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_choices - length)) {
			    window_offset = (num_choices - length + 1);
			}
			if (cur_choice < window_offset)
			    cur_choice = window_offset;
			if (disabled) {
			    _statusline(CHOICE_LIST_UNM_MSG);
			} else {
			    _statusline(CHOICE_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *	We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			sprintf(buffer, ALREADY_AT_CHOICE_PAGE, number);
			HTUserMsg(buffer);
			if (disabled) {
			    _statusline(CHOICE_LIST_UNM_MSG);
			} else {
			    _statusline(CHOICE_LIST_MESSAGE);
			}
			break;
		    }
		    cur_choice = window_offset = ((number - 1) * length);
		    if (disabled) {
			_statusline(CHOICE_LIST_UNM_MSG);
		    } else {
			_statusline(CHOICE_LIST_MESSAGE);
		    }
		    goto redraw;

		}

		/*
		 *  Check for a positive number, which signifies
		 *  that a choice should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *	Decrement the number so as to correspond
		     *	with our cur_choice values. - FM
		     */
		    number--;

		    /*
		     *	If the number is in range and had no legal
		     *	suffix, select the indicated choice. - FM
		     */
		    if (number <= num_choices && c == '\0') {
			cur_choice = number;
			cmd = LYK_ACTIVATE;
			break;
		    }

		    /*
		     *	Verify that we had a 'g' suffix,
		     *	and act on the number. - FM
		     */
		    if (c == 'g') {
			if (cur_choice == number) {
			    /*
			     *	The choice already is current. - FM
			     */
			    sprintf(buffer,
				    CHOICE_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(buffer);
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    break;
			}

			if (number <= num_choices) {
			    /*
			     *	The number is in range and had a 'g'
			     *	suffix, so make it the current choice,
			     *	scrolling if needed. - FM
			     */
			    j = (number - cur_choice);
			    cur_choice = number;
			    if ((j > 0) &&
				(cur_choice - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_choices - length + 1))
				    window_offset = (num_choices - length + 1);
			    } else if ((cur_choice - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    if (disabled) {
				_statusline(CHOICE_LIST_UNM_MSG);
			    } else {
				_statusline(CHOICE_LIST_MESSAGE);
			    }
			    goto redraw;
			}

			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_CHOICE_NUM_ENTERED);
		    }
		}

		/*
		 *  Restore the popup statusline. - FM
		 */
		if (disabled) {
		    _statusline(CHOICE_LIST_UNM_MSG);
		} else {
		    _statusline(CHOICE_LIST_MESSAGE);
		}
		break;

	    case LYK_PREV_LINK:
	    case LYK_UP_LINK:

		if (cur_choice > 0)
		    cur_choice--;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_DOWN_LINK:
		if (cur_choice < num_choices)
		    cur_choice++;

		/*
		 *  Scroll the window down if necessary
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_PAGE:
		/*
		 *  Okay, are we on the last page of the choices list?
		 *  If not then,
		 */
		if (window_offset != (num_choices - length + 1)) {
		    /*
		     *	Modify the current choice to not be a
		     *	coordinate in the list, but a coordinate
		     *	on the item selected in the window.
		     */
		    cur_choice -= window_offset;

		    /*
		     *	Page down the proper length for the list.
		     *	If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }

		    /*
		     *	Readjust the current choice to be a choice
		     *	list coordinate rather than window.
		     *	Redraw this thing.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		}
		else if (cur_choice < num_choices) {
		    /*
		     *	Already on last page of the choice list so
		     *	just redraw it with the last item selected.
		     */
		    cur_choice = num_choices;
		}
		break;

	    case LYK_PREV_PAGE:
		/*
		 *  Are we on the first page of the choice list?
		 *  If not then,
		 */
		if (window_offset != 0) {
		    /*
		     *	Modify the current choice to not be a choice
		     *	list coordinate, but a window coordinate.
		     */
		    cur_choice -= window_offset;

		    /*
		     *	Page up the proper length.
		     *	If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }

		    /*
		     *	Readjust the current choice.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		} else if (cur_choice > 0) {
		    /*
		     *	Already on the first page so just
		     *	back up to the first item.
		     */
		    cur_choice = 0;
		}
		break;

	    case LYK_HOME:
		cur_choice = 0;
		if (window_offset > 0) {
		    window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_END:
		cur_choice = num_choices;
		if (window_offset != (num_choices - length + 1)) {
		    window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_DOWN_TWO:
		cur_choice += 2;
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_TWO:
		cur_choice -= 2;
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_DOWN_HALF:
		cur_choice += (length/2);
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_HALF:
		cur_choice -= (length/2);
		if (cur_choice < 0)
		    cur_choice = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		refresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
		    /*
		     *	We got a 'n'ext command with no prior query
		     *	specified within the popup window.  See if
		     *	one was entered when the popup was retracted,
		     *	and if so, assume that's what's wanted.  Note
		     *	that it will become the default within popups,
		     *	unless another is entered within a popup.  If
		     *	the within popup default is to be changed at
		     *	that point, use WHEREIS ('/') and enter it,
		     *	or the up- or down-arrow keys to seek any of
		     *	the previously entered queries, regardless of
		     *	whether they were entered within or outside
		     *	of a popup window. - FM
		     */
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			strcpy(prev_target_buffer, cp);
			QueryNum = 0;
			FirstRecall = FALSE;
		    }
		}
		strcpy(prev_target, prev_target_buffer);
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		}

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
		    /*
		     *	No entry.  Simply break.   - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
			    }
			} else {
			    QueryNum = 0;
			}
		    } else {
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
		    }
		    if (QueryNum >= QueryTotal)
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *	User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
		    /*
		     *	Use the current string or
		     *	first query in the list. - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				!strcmp(prev_target_buffer, cp)) {
				    break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     *	Advance to the next query in the list. - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0)
		    /*
		     *	Roll around to the first query in the list. - FM
		     */
		    QueryNum = (QueryTotal - 1);
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		}
		/*
		 *  Replace the search string buffer with the new target. - FM
		 */
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

		/*
		 *  Start search at the next choice. - FM
		 */
		for (j = 1; Cptr[i+j] != NULL; j++) {
		    sprintf(buffer, "%s%d: %s",
				    ((num_choices > 8 && (j + i) < 9) ?
								  " " : ""),
				    (i + j + 1),
				    Cptr[i+j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (Cptr[i+j] != NULL) {
		    /*
		     *	We have a hit, so make that choice the current. - FM
		     */
		    cur_choice += j;
		    /*
		     *	Scroll the window down if necessary.
		     */
		    if ((cur_choice - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_choices - length + 1))
			    window_offset = (num_choices - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  If we started at the beginning, it can't be present. - FM
		 */
		if (cur_choice == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}

		/*
		 *  Search from the beginning to the current choice. - FM
		 */
		for (j = 0; j < cur_choice; j++) {
		    sprintf(buffer, "%s%d: %s",
				    ((num_choices > 8 && j < 9) ?
							    " " : ""),
				    (j + 1),
				    Cptr[j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_choice) {
		    /*
		     *	We have a hit, so make that choice the current. - FM
		     */
		    j = (cur_choice - j);
		    cur_choice -= j;
		    /*
		     *	Scroll the window up if necessary.
		     */
		    if ((cur_choice - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  Didn't find it in the preceding choices either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);

restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		if (disabled)
		    _statusline(CHOICE_LIST_UNM_MSG);
		else
		    _statusline(CHOICE_LIST_MESSAGE);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
		}
		break;

	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_choice = orig_choice;
		term_options = TRUE;
		HTUserMsg(CANCELLED);
		cmd = LYK_ACTIVATE; /* to exit */
		break;
	}
    }
#ifndef USE_SLANG
    delwin(form_window);
#ifdef NCURSES
    LYsubwindow(0);
#endif
#endif /* !USE_SLANG */
d2070 1
a2070 2
	return(orig_choice);
    } else {
a2071 1
	return(cur_choice);
d2073 1
a2076 1

d2117 1
a2117 1
static char * cookies_string		= "cookies";
d2122 1
a2122 1
static char * editor_string		= "editor";
d2125 1
a2125 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d2137 1
a2137 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d2146 1
a2146 1
	{ LINKS_AND_FORM_FIELDS_ARE_NUMBERED,
d2150 3
a2152 3
static char * lineedit_style_string	= "lineedit_style";
static char * mail_address_string	= "mail_address";
static char * search_type_string	= "search_type";
d2173 1
d2176 11
d2190 2
a2191 1
static char * DTD_recovery_string      = "DTD";
d2197 2
d2214 7
a2220 4
static char * mbm_advanced_string	= "ADVANCED";
static char * mbm_off_string		= "OFF";
static char * mbm_standard_string	= "STANDARD";
static char * mbm_string		= "multi_bookmarks_mode";
d2227 1
a2227 1
static char * display_char_set_string	= "display_char_set";
d2234 1
d2236 1
a2236 1
static char * dired_sort_string		= "dired_sort";
d2243 2
a2244 1
static char * ftp_sort_string = "ftp_sort";
d2252 11
d2266 2
a2267 2
static char * preferred_doc_char_string = "preferred_doc_char";
static char * preferred_doc_lang_string = "preferred_doc_lang";
a2269 3
#define PutLabel(fp, text) \
	fprintf(fp,"  %-33s: ", text)

d2273 1
a2273 1
		(int) Size, Name, Value, disable)
d2279 1
a2279 1
	fprintf(fp,"<select name=\"%s\">\n", text)
d2282 1
a2282 1
	fprintf(fp,"<select name=\"%s\" %s>\n", text, DISABLED(flag))
d2293 6
a2298 4
	PutOption(fp,
	    value == table->value,
	    table->HtmlName,
	    table->LongName);
d2309 1
a2309 1
	if (!strcmp(value, table->HtmlName)) {
d2338 3
a2340 1
    q = calloc(sizeof(PostPair), 1);
d2374 1
a2374 1
		    && isalnum(q[count].value[i+2])) {
a2378 1

d2385 1
d2401 1
d2458 6
a2463 1
	if (!no_bookmark)
d2465 2
a2466 3
	else /* anonymous */
	   HTAlert(BOOKMARK_CHANGE_DISALLOWED);
	return(NULLFILE);
d2469 1
d2471 2
a2472 3
    /*-------------------------------------------------
     * kludge gen_options() call:
     *--------------------------------------------------*/
d2474 9
a2482 4
    if (strstr(newdoc->address, "LYNXOPTIONS:/") && !newdoc->post_data) {
	int status = gen_options(&newdoc->address);
	if (status == NOT_FOUND)
	    return(NOT_FOUND);
d2484 1
a2484 1
	/* exit to getfile() cyrcle */
d2494 4
d2501 13
a2513 2

    data = break_data(newdoc->post_data);
d2517 4
a2520 1
	 * Paranoid security.
d2524 2
d2527 2
a2528 1
		 * FIXME: We've been spoofed message here.
d2530 4
d2561 2
d2574 1
a2574 1
	    if ((emacs_keys = code) != FALSE) {
d2582 1
a2582 1
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
d2590 1
a2590 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d2599 5
d2608 1
a2608 1
	if (!strcmp(data[i].tag, lineedit_style_string)) {
d2613 1
a2613 1
	       if (j==newval)  current_lineedit = newval;
d2624 1
a2624 1
	       if (j==newval)  current_layout = newval;
d2638 1
a2638 1
	    case_sensitive = code;
d2641 1
d2651 1
d2656 1
a2656 1
	    LYSelectPopups = code;
d2662 4
a2665 2
	 && GetOptValues(show_color_values, data[i].value, &LYShowColor)) {
	    LYChosenShowColor = LYShowColor;
d2679 1
a2679 1
	    LYShowCursor = code;
d2692 4
d2700 2
a2701 2
		 pseudo_inline_alts = FALSE;
		 clickable_images = FALSE;
d2705 2
a2706 2
		 pseudo_inline_alts = TRUE;
		 clickable_images = FALSE;
d2719 1
a2719 1
		verbose_img = code;
d2727 1
a2727 1
	    if ((vi_keys = code) != FALSE) {
d2736 1
a2736 9
	    if (!strcmp(data[i].value, mbm_off_string)) {
		LYMultiBookmarks = FALSE;
	    } else if (!strcmp(data[i].value, mbm_standard_string)) {
		LYMultiBookmarks = TRUE;
		LYMBMAdvanced = FALSE;
	    } else if (!strcmp(data[i].value, mbm_advanced_string)) {
		LYMultiBookmarks = TRUE;
		LYMBMAdvanced = TRUE;
	    }
d2777 1
a2777 1
	    LYRawMode = code;
d2797 7
a2803 1
	    show_dotfiles = code;
d2834 2
a2835 4
		if (LYUserAgent && *LYUserAgent &&
		   !strstr(LYUserAgent, "Lynx") &&
		   !strstr(LYUserAgent, "lynx")) {
		    HTAlert(UA_COPYRIGHT_WARNING);
d2850 25
a2874 19
       if (display_char_set_old != current_char_set) {
		/*
		 *  Set the LYUseDefaultRawMode value and character
		 *  handling if LYRawMode was changed. - FM
		 */
		LYUseDefaultRawMode = TRUE;
		HTMLUseCharacterSet(current_char_set);
	    }
	if (assume_char_set_changed) {
		LYRawMode = (UCLYhndl_for_unspec == current_char_set);
	    }
       if (raw_mode_old != LYRawMode || assume_char_set_changed) {
		/*
		 *  Set the raw 8-bit or CJK mode defaults and
		 *  character set if changed. - FM
		 */
		HTMLSetUseDefaultRawMode(current_char_set, LYRawMode);
		HTMLSetCharacterHandling(current_char_set);
	    }
d2885 4
a2888 3
	_statusline(SAVING_OPTIONS);
	if (save_rc()) {
	    _statusline(OPTIONS_SAVED);
d2898 5
a2902 5
    CTRACE(tfp, "\nLYOptions.c/postoptions(): exiting...\n");
    CTRACE(tfp, "                            need_reload = %s\n",
                    need_reload ? "TRUE" : "FALSE");
    CTRACE(tfp, "                            need_end_reload = %s\n",
                    need_end_reload ? "TRUE" : "FALSE");
d2950 1
a2950 1
       return(NOT_FOUND);
d2982 1
a2982 1
	CTRACE(tfp, "LYOptions.c/postoptions(): now really exit.\n\n");
d2991 1
a2991 8
#ifndef USE_PSRC
	    HTOutputFormat = WWW_SOURCE;
#else
	    if (LYpsrc)
		psrc_view = TRUE;
	    else
		HTOutputFormat = WWW_SOURCE;
#endif
d2996 4
a2999 2
	    if (HTreparse_document()) {
		CTRACE(tfp, "LYOptions.c/postoptions(): now really exit.\n\n");
d3004 9
d3017 1
a3017 1
	CTRACE(tfp, "LYOptions.c/postoptions(): now really exit.\n\n");
d3028 6
a3033 1
	sprintf(secure_value, "%ld", (long)secure_value + (long)time(0));
d3040 70
a3109 1
 * Okay, someone wants to change options.  So, lets gen up a form for them
d3123 2
a3124 4
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    BOOLEAN can_do_colors;
#endif
    static char tempfile[LY_MAXPATH];
d3127 1
a3127 1
    size_t text_len = COLS - 38;	/* cf: PutLabel */
d3129 6
a3134 2
    LYRemoveTemp(tempfile);
    fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
d3142 12
d3156 9
d3170 1
a3170 1
    fprintf(fp0,"<form action=\"LYNXOPTIONS:\" method=\"post\">\n");
d3176 2
a3177 2
    fprintf(fp0,"<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",
	    secure_string, NewSecureValue());
d3185 5
a3189 3
    fprintf(fp0,"<input type=\"submit\" value=\"%s\"> - \n", ACCEPT_CHANGES);
    fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
    fprintf(fp0,"%s\n", CANCEL_CHANGES);
d3195 6
a3200 3
	fprintf(fp0, "<p align=center>%s: ", SAVE_OPTIONS);
	fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n",
		save_options_string);
d3207 20
a3226 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Personal Preferences"));
d3229 1
a3229 1
    PutLabel(fp0, gettext("Cookies"));
d3232 2
a3233 2
	      cookies_ignore_all_string,
	      cookies_ignore_all_string);
d3235 2
a3236 2
	      cookies_up_to_user_string,
	      cookies_up_to_user_string);
d3238 2
a3239 2
	      cookies_accept_all_string,
	      cookies_accept_all_string);
d3242 9
a3250 4
    /* Editor: INPUT */
    PutLabel(fp0, gettext("Editor"));
    PutTextInput(fp0, editor_string, NOTEMPTY(editor), text_len,
		DISABLED(no_editor || system_editor));
d3253 1
a3253 1
    PutLabel(fp0, gettext("Emacs keys"));
d3258 4
a3261 4
    /* Keypad Mode: SELECT */
    PutLabel(fp0, gettext("Keypad mode"));
    BeginSelect(fp0, keypad_mode_string);
    PutOptValues(fp0, keypad_mode, keypad_mode_values);
d3266 2
a3267 2
	PutLabel(fp0, "Line edit style");
	BeginSelect(fp0, lineedit_style_string);
d3278 1
a3278 1
    PutLabel(fp0, "Keyboard layout");
d3283 1
a3283 1
	PutOption(fp0, i==current_layout, temp, LYKbLayoutNames[i]);
d3288 5
a3292 72
    /* Mail Address: INPUT */
    PutLabel(fp0, gettext("Personal mail address"));
    PutTextInput(fp0, mail_address_string,
		NOTEMPTY(personal_mail_address), text_len, "");

    /* Search Type: SELECT */
    PutLabel(fp0, gettext("Searching type"));
    BeginSelect(fp0, search_type_string);
    PutOptValues(fp0, case_sensitive, search_type_values);
    EndSelect(fp0);

    /* Show Color: SELECT */
#if defined(USE_SLANG) || defined(COLOR_CURSES)
    can_do_colors = 1;
#if defined(COLOR_CURSES)
    can_do_colors = has_colors();
#endif
    PutLabel(fp0, gettext("Show color"));
    MaybeSelect(fp0, !can_do_colors, show_color_string);
    if (no_option_save) {
	if (LYShowColor == SHOW_COLOR_NEVER) {
	    LYShowColor = SHOW_COLOR_OFF;
	} else if (LYShowColor == SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
	PutOptValues(fp0, LYShowColor, bool_values);
    } else {
	if (LYChosenShowColor == SHOW_COLOR_UNKNOWN) {
	    switch (LYrcShowColor) {
	    case SHOW_COLOR_NEVER:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_NEVER;
		break;
	    case SHOW_COLOR_ALWAYS:
		if (!can_do_colors)
		    LYChosenShowColor = SHOW_COLOR_ALWAYS;
		else
		    LYChosenShowColor =
			(LYShowColor >= SHOW_COLOR_ON) ?
				SHOW_COLOR_ALWAYS : SHOW_COLOR_OFF;
		break;
	    default:
		LYChosenShowColor =
		    (LYShowColor >= SHOW_COLOR_ON) ?
			SHOW_COLOR_ON : SHOW_COLOR_OFF;
	    }
	}
	show_color_values[3].LongName = (can_do_colors) ? always_string
							: "Always try";
	PutOptValues(fp0, LYChosenShowColor, show_color_values);
    }
    EndSelect(fp0);
#endif /* USE_SLANG || COLOR_CURSES */

    /* Show cursor: ON/OFF */
    PutLabel(fp0, gettext("Show cursor"));
    BeginSelect(fp0, show_cursor_string);
    PutOptValues(fp0, LYShowCursor, bool_values);
    EndSelect(fp0);

    /* User Mode: SELECT */
    PutLabel(fp0, gettext("User mode"));
    BeginSelect(fp0, user_mode_string);
    PutOptValues(fp0, user_mode, user_mode_values);
    EndSelect(fp0);

    /* VI Keys: ON/OFF */
    PutLabel(fp0, gettext("VI keys"));
    BeginSelect(fp0, vi_keys_string);
    PutOptValues(fp0, vi_keys, bool_values);
    EndSelect(fp0);
d3295 1
a3295 1
    PutLabel(fp0, gettext("Display character set"));
d3301 1
a3301 1
	   cset_len = len;
d3303 3
a3309 9
    /* X Display: INPUT */
    PutLabel(fp0, gettext("X Display"));
    PutTextInput(fp0, x_display_string, NOTEMPTY(x_display), text_len, "");

    /*
     * Document Layout
     */
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Document Layout"));

a3310 1
    /* if (user_mode==ADVANCED_MODE) */
d3321 1
a3321 1
	    /* ok, LYRawMode, so use UCAssume_MIMEcharset */
d3324 1
a3324 1
	PutLabel(fp0, gettext("Assumed document character set"));
d3327 6
a3332 3
	    PutOption(fp0, i==curval,
		      LYCharSet_UC[i].MIMEname,
		      LYCharSet_UC[i].MIMEname);
d3338 1
a3338 1
    if (LYHaveCJKCharacterSet)
d3344 4
a3347 3
	PutLabel(fp0, gettext("CJK mode"));
    else
	PutLabel(fp0, gettext("Raw 8-bit"));
d3353 40
a3392 4
    /* HTML error recovery: SELECT */
    PutLabel(fp0, gettext("HTML error recovery"));
    BeginSelect(fp0, DTD_recovery_string);
    PutOptValues(fp0, Old_DTD, DTD_type_values);
d3396 1
a3396 1
    PutLabel(fp0, gettext("Popups for select fields"));
d3401 8
d3410 1
a3410 1
    PutLabel(fp0, gettext("Show images"));
d3413 2
a3414 2
       images_ignore_all_string,
       images_ignore_all_string);
d3416 2
a3417 2
       images_use_label_string,
       images_use_label_string);
d3419 2
a3420 2
       images_use_links_string,
       images_use_links_string);
d3424 1
a3424 1
    PutLabel(fp0, gettext("Verbose images"));
d3430 1
a3430 1
     * Bookmark Options
d3432 2
a3433 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Bookmark Options"));
d3435 4
a3438 15
    /* Multi-Bookmark Mode: SELECT */
    if (!LYMBMBlocked) {
       PutLabel(fp0, gettext("Multi-bookmarks"));
       BeginSelect(fp0, mbm_string);
       PutOption(fp0, !LYMultiBookmarks,
	   mbm_off_string,
	   mbm_off_string);
       PutOption(fp0, LYMultiBookmarks && !LYMBMAdvanced,
	   mbm_standard_string,
	   mbm_standard_string);
       PutOption(fp0, LYMultiBookmarks && LYMBMAdvanced,
	   mbm_advanced_string,
	   mbm_advanced_string);
       EndSelect(fp0);
    }
d3440 4
a3443 2
    /* Bookmarks File Menu: LINK/INPUT */
    if (LYMultiBookmarks) {
d3445 4
a3448 3
	PutLabel(fp0, gettext("Review/edit Bookmarks files"));
	fprintf(fp0, "<a href=\"LYNXOPTIONS://MBM_MENU\">%s</a>\n",
		gettext("Goto multi-bookmark menu"));
d3450 5
a3454 4
    } else {
	PutLabel(fp0, gettext("Bookmarks file"));
	PutTextInput(fp0, single_bookmark_string,
		NOTEMPTY(bookmark_page), text_len, "");
d3458 1
a3458 1
     * File Management Options
d3460 2
a3461 1
    fprintf(fp0,"\n  <em>%s</em>\n", DIRED_MENU_TITLE);
d3464 1
a3464 1
    PutLabel(fp0, gettext("FTP sort criteria"));
d3471 1
a3471 1
    PutLabel(fp0, gettext("Local directory sort criteria"));
d3479 1
a3479 1
	PutLabel(fp0, gettext("Show dot files"));
d3486 2
a3487 2
#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
    PutLabel(fp0, gettext("Execution links"));
d3495 1
a3495 1
	       exec_links_values);
d3500 1
a3500 1
	       exec_links_values);
d3503 9
a3511 1
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */
d3514 1
a3514 1
     * Headers transferred to remote server
d3516 2
a3517 1
    fprintf(fp0,"\n  <em>%s</em>\n", gettext("Headers transferred to remote server"));
d3519 7
a3525 4
    /* Preferred Document Character Set: INPUT */
    PutLabel(fp0, gettext("Preferred document character set"));
    PutTextInput(fp0, preferred_doc_char_string,
	    NOTEMPTY(pref_charset), cset_len+2, "");
d3527 10
a3536 4
    /* Preferred Document Language: INPUT */
    PutLabel(fp0, gettext("Preferred document language"));
    PutTextInput(fp0, preferred_doc_lang_string,
	    NOTEMPTY(language), cset_len+2, "");
d3538 5
a3542 6
    /* User Agent: INPUT */
    if (!no_useragent) {
	PutLabel(fp0, gettext("User-Agent header"));
	PutTextInput(fp0, user_agent_string,
		     NOTEMPTY(LYUserAgent), text_len, "");
    }
d3544 2
a3545 3
    if (!LYRestricted) {
	fprintf(fp0,
		"\n  Check your <a href=\"LYNXCFG:\">lynx.cfg</a> here\n");
d3551 6
a3556 4
    fprintf(fp0,"<p align=center>\n");
    fprintf(fp0,"<input type=\"submit\" value=\"%s\">\n - ", ACCEPT_CHANGES);
    fprintf(fp0,"<input type=\"reset\" value=\"%s\">\n", RESET_CHANGES);
    fprintf(fp0,"%s\n", CANCEL_CHANGES);
@


1.1
log
@Initial revision
@
text
@d1 23
a23 20
#include "HTUtils.h"
#include "tcp.h"
#include "HTFTP.h"
#include "HTML.h"
#include "LYCurses.h"
#include "LYUtils.h"
#include "LYStrings.h"
#include "LYGlobalDefs.h"
#include "LYOptions.h"
#include "LYSignal.h"
#include "LYClean.h"
#include "LYCharSets.h"
#include "LYCharUtils.h"
#include "UCMap.h"
#include "UCAux.h"
#include "LYKeymap.h"
#include "LYrcFile.h"
#include "HTAlert.h"
#include "LYBookmark.h"
#include "GridText.h"
d25 1
a25 1
#include "LYLeaks.h"
d27 1
a27 1
#define FREE(x) if (x) {free(x); x = NULL;}
d29 1
a29 5
#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */
d31 1
d33 1
d35 1
a35 2
BOOLEAN term_options;
PRIVATE void terminate_options	PARAMS((int sig));
d40 1
a40 8
	char ** 	choices));
PRIVATE int popup_choice PARAMS((
	int		cur_choice,
	int		line,
	int		column,
	char ** 	choices,
	int		i_length,
	int		disabled));
d44 62
d114 1
d119 4
a122 2
PRIVATE void option_statusline ARGS1(
	CONST char *,		text)
d124 5
a128 18
    /*
     *	Make sure we have a pointer to a string.
     */
    if (text == NULL)
	return;

    /*
     *	Don't print statusline messages if dumping to stdout.
     */
    if (dump_output_immediately)
	return;

    /*
     *	Use _statusline() set to output on the bottom line. - FM
     */
    LYStatusLine = (LYlines - 1);
    _statusline(text);
    LYStatusLine = -1;
d131 5
a135 3
PRIVATE void option_user_message ARGS2(
	CONST char *,		message,
	char *, 		argument)
d137 20
a156 18
    /*
     *	Make sure we have a pointer to a string.
     */
    if (message == NULL || argument == NULL)
	return;

    /*
     *	Don't print statusline messages if dumping to stdout.
     */
    if (dump_output_immediately)
	return;

    /*
     *	Use _user_message() set to output on the bottom line.
     */
    LYStatusLine = (LYlines - 1);
    _user_message(message, argument);
    LYStatusLine = -1;
d159 1
a159 1
PUBLIC void options NOARGS
a168 3
#ifndef VMS
    static char putenv_command[142];
#endif /* !VMS */
d171 1
a172 1
    int CurrentAssumeCharSet = UCLYhndl_for_unspec;
d193 1
a193 2
	HTAlert(
	"Screen height must be at least 23 lines for the Options menu!");
d205 1
d274 1
a274 1
    addstr("E)ditor                      : ");
d278 2
a279 2
    addstr("D)ISPLAY variable            : ");
    addstr((display && *display) ? display : "NONE");
d282 1
a282 1
    addstr("mu(L)ti-bookmarks: ");
d289 1
a289 1
	addstr("review/edit B)ookmarks files");
d291 1
a291 1
	addstr("B)ookmark file: ");
d296 1
a296 1
    addstr("F)TP sort criteria           : ");
d303 1
a303 1
    addstr("P)ersonal mail address       : ");
d308 1
a308 1
    addstr("S)earching type              : ");
d312 1
a312 1
    addstr("display (C)haracter set      : ");
d316 1
a316 1
    addstr("preferred document lan(G)uage: ");
d320 1
a320 1
    addstr("preferred document c(H)arset : ");
d325 1
a325 1
	addstr("^A)ssume charset if unknown  : ");
d335 1
a335 1
    addstr("Raw 8-bit or CJK m(O)de      : ");
d340 1
a340 1
    addstr("show color (&)  : ");
d347 1
a347 1
                addstr("NEVER     ");
d367 1
a367 1
    addstr("V)I keys: ");
d371 1
a371 1
    addstr("e(M)acs keys: ");
d375 1
a375 1
    addstr("sho(W) dot files: ");
d379 1
a379 1
    addstr("popups for selec(T) fields   : ");
d383 1
a383 1
    addstr("show cursor (@@) : ");
d387 1
a387 1
    addstr("K)eypad mode                 : ");
d395 1
a395 1
    addstr("li(N)e edit style            : ");
d398 6
d406 1
a406 1
    addstr("l(I)st directory style       : ");
d413 1
a413 1
    addstr("U)ser mode                   : ");
d418 3
d422 1
a422 1
    addstr("user (A)gent                 : ");
d427 1
a427 1
    addstr("local e(X)ecution links      : ");
d465 1
a465 1
	    option_statusline(VALUE_ACCEPTED);
d485 1
a485 1
		    option_statusline(EDIT_DISABLED);
d487 1
a487 1
		    option_statusline(EDITOR_LOCKED);
d496 1
a496 1
		    option_statusline(ACCEPT_DATA);
d515 2
a516 3
			option_statusline(CANCELLED);
			sleep(InfoSecs);
			option_statusline("");
d518 1
a518 1
			option_statusline(VALUE_ACCEPTED);
d526 2
a527 2
		if (display && *display) {
		    strcpy(display_option, display);
d533 1
a533 1
		option_statusline(ACCEPT_DATA);
d541 1
a541 1
		    (display != NULL &&
d543 1
a543 1
		     !strcasecomp(display, display_option)))
d545 1
a545 1
		     !strcmp(display, display_option)))
d552 1
a552 1
		    addstr((display && *display) ? display : "NONE");
d555 2
a556 3
			option_statusline(CANCELLED);
			sleep(InfoSecs);
			option_statusline("");
d558 1
a558 1
			option_statusline(VALUE_ACCEPTED);
d563 2
a564 2
		    if ((display == NULL) ||
			(display != NULL && *display == '\0')) {
d571 1
a571 1
			option_statusline(VALUE_ACCEPTED);
d579 3
a581 13
#ifdef VMS
		{
		    int i;
		    for (i = 0; display_option[i]; i++)
			display_option[i] = TOUPPER(display_option[i]);
		    Define_VMSLogical(DISPLAY, display_option);
		}
#else
		sprintf(putenv_command, "DISPLAY=%s", display_option);
		putenv(putenv_command);
#endif /* VMS */
		if ((cp = getenv(DISPLAY)) != NULL && *cp != '\0') {
		    StrAllocCopy(display, cp);
d583 1
a583 1
		    FREE(display);
d586 1
a586 1
		addstr(display ? display : "NONE");
d588 4
a591 4
		if ((display == NULL && *display_option == '\0') ||
		    (display != NULL &&
		     !strcmp(display, display_option))) {
		    if (display == NULL &&
d593 2
a594 2
			option_statusline(VALUE_ACCEPTED_WARNING_X);
		    } else if (display != NULL &&
d596 1
a596 1
			option_statusline(VALUE_ACCEPTED_WARNING_NONX);
d598 1
a598 1
			option_statusline(VALUE_ACCEPTED);
d602 1
a602 1
			option_statusline(FAILED_TO_SET_DISPLAY);
d604 1
a604 1
			option_statusline(FAILED_CLEAR_SET_DISPLAY);
d613 1
a613 1
		    option_statusline(MULTIBOOKMARKS_DISALLOWED);
d659 1
a659 1
			addstr("review/edit B)ookmarks files");
d661 1
a661 1
			addstr("B)ookmark file: ");
d700 1
a700 1
		    option_statusline(ACCEPT_DATA);
d716 1
a716 1
			option_statusline(USE_PATH_OFF_HOME);
d727 2
a728 3
			option_statusline(CANCELLED);
			sleep(InfoSecs);
			option_statusline("");
d730 1
a730 1
			option_statusline(VALUE_ACCEPTED);
d733 1
a733 1
		    option_statusline(BOOKMARK_CHANGE_DISALLOWED);
d795 1
a795 1
		option_statusline(ACCEPT_DATA);
d815 2
a816 3
		    option_statusline(CANCELLED);
		    sleep(InfoSecs);
		    option_statusline("");
d818 1
a818 1
		    option_statusline(VALUE_ACCEPTED);
d823 1
a823 1
	    case 's':	/* Change case sentitivity for searches. */
d876 3
a878 3
		 *  Set the raw 8-bit or CJK mode defaults and
		 *  character set if changed. - FM
		 */
d887 1
a887 1
			HTMLUseCharacterSet(current_char_set);
d914 1
a914 1
		    option_statusline(NEED_ADVANCED_USER_MODE);
d919 1
a919 1
	    case 'c':	/* Change charset setting. */
a940 1
		    HTMLSetRawModeDefault(current_char_set);
d1003 1
a1003 1
		option_statusline(ACCEPT_DATA);
d1022 2
a1023 3
		    option_statusline(CANCELLED);
		    sleep(InfoSecs);
		    option_statusline("");
d1025 1
a1025 1
		    option_statusline(VALUE_ACCEPTED);
d1039 1
a1039 1
		option_statusline(ACCEPT_DATA);
d1058 2
a1059 3
		    option_statusline(CANCELLED);
		    sleep(InfoSecs);
		    option_statusline("");
d1061 1
a1061 1
		    option_statusline(VALUE_ACCEPTED);
d1115 1
a1115 1
		    option_statusline(DOTFILE_ACCESS_DISABLED);
d1161 1
a1161 1
			    option_user_message(
d1165 1
a1165 2
			    option_statusline(COLOR_TOGGLE_DISABLED);
			sleep(AlertSecs);
d1222 1
a1222 1
				option_user_message(
d1226 1
a1226 2
				option_statusline(COLOR_TOGGLE_DISABLED);
			    sleep(AlertSecs);
d1373 34
d1510 40
d1560 1
a1560 1
		    option_statusline(ACCEPT_DATA_OR_DEFAULT);
d1582 2
a1583 3
			option_statusline(CANCELLED);
			sleep(InfoSecs);
			option_statusline("");
d1587 1
a1587 1
			option_statusline(UA_COPYRIGHT_WARNING);
d1589 1
a1589 1
			option_statusline(VALUE_ACCEPTED);
d1592 1
a1592 1
		    option_statusline(UA_COPYRIGHT_WARNING);
d1601 1
a1601 1
		    option_statusline(CHANGE_OF_SETTING_DISALLOWED);
d1685 1
a1685 1
		    option_statusline(SAVING_OPTIONS);
d1688 1
a1688 1
			option_statusline(OPTIONS_SAVED);
d1693 1
a1693 1
		    option_statusline(R_TO_RETURN_TO_LYNX);
d1708 1
a1708 1
		    option_statusline(SAVE_OR_R_TO_RETURN_TO_LYNX);
d1710 1
a1710 1
		    option_statusline(R_TO_RETURN_TO_LYNX);
d1716 1
a1734 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt; /* Flag from cleanup_sig() AST */
#endif /* VMS */
d1747 1
a1747 1
    option_statusline(ANY_KEY_CHANGE_RET_ACCEPT);
d1814 1
d1856 2
a1857 3
		option_statusline(CANCELLED);
		sleep(InfoSecs);
		option_statusline("");
d1859 1
a1859 1
		option_statusline(VALUE_ACCEPTED);
d1865 1
d1934 1
a1934 1
		      a <= ((float)MBM_V_MAXFILES/2 * MBM_current); a++) {
d2024 1
a2024 1
		option_statusline(SAVING_OPTIONS);
d2026 1
a2026 1
		    option_statusline(OPTIONS_SAVED);
d2030 1
a2030 1
		option_statusline(R_TO_RETURN_TO_LYNX);
d2087 1
a2087 1
		option_statusline(ACCEPT_DATA);
d2172 1
d2188 1
a2188 1
    option_statusline(OPTION_CHOICE_NUMBER);
d2195 1
a2195 2
	option_statusline(CANCELLED);
	sleep(InfoSecs);
d2220 1
a2220 1
PRIVATE int popup_choice ARGS6(
d2235 2
a2236 1
    int num_choices = 0, top, bottom, length = -1, width = 0;
a2242 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt; /* Flag from cleanup_sig() AST */
#endif /* VMS */
d2369 1
a2369 1
	option_statusline(POPUP_FAILED);
d2392 1
a2392 1
	option_statusline(CHOICE_LIST_UNM_MSG);
d2394 1
a2394 1
	option_statusline(CHOICE_LIST_MESSAGE);
d2525 1
a2525 1
	c = LYgetch();
a2526 3
	     /*
	      *  Control-C or Control-G
	      */
d2528 7
d2573 1
a2573 2
			    option_statusline(ALREADY_AT_CHOICE_BEGIN);
			    sleep(MessageSecs);
d2575 1
a2575 1
				option_statusline(CHOICE_LIST_UNM_MSG);
d2577 1
a2577 1
				option_statusline(CHOICE_LIST_MESSAGE);
d2584 1
a2584 1
			    option_statusline(CHOICE_LIST_UNM_MSG);
d2586 1
a2586 1
			    option_statusline(CHOICE_LIST_MESSAGE);
d2597 1
a2597 2
			    option_statusline(ALREADY_AT_CHOICE_END);
			    sleep(MessageSecs);
d2599 1
a2599 1
				option_statusline(CHOICE_LIST_UNM_MSG);
d2601 1
a2601 1
				option_statusline(CHOICE_LIST_MESSAGE);
d2612 1
a2612 1
			    option_statusline(CHOICE_LIST_UNM_MSG);
d2614 1
a2614 1
			    option_statusline(CHOICE_LIST_MESSAGE);
d2624 1
a2624 2
			option_statusline(buffer);
			sleep(MessageSecs);
d2626 1
a2626 1
			    option_statusline(CHOICE_LIST_UNM_MSG);
d2628 1
a2628 1
			    option_statusline(CHOICE_LIST_MESSAGE);
d2634 1
a2634 1
			option_statusline(CHOICE_LIST_UNM_MSG);
d2636 1
a2636 1
			option_statusline(CHOICE_LIST_MESSAGE);
d2674 1
a2674 2
			    option_statusline(buffer);
			    sleep(MessageSecs);
d2676 1
a2676 1
				option_statusline(CHOICE_LIST_UNM_MSG);
d2678 1
a2678 1
				option_statusline(CHOICE_LIST_MESSAGE);
d2702 1
a2702 1
				option_statusline(CHOICE_LIST_UNM_MSG);
d2704 1
a2704 1
				option_statusline(CHOICE_LIST_MESSAGE);
d2712 1
a2712 2
			option_statusline(BAD_CHOICE_NUM_ENTERED);
			sleep(MessageSecs);
d2720 1
a2720 1
		    option_statusline(CHOICE_LIST_UNM_MSG);
d2722 1
a2722 1
		    option_statusline(CHOICE_LIST_MESSAGE);
d2940 1
a2940 1
		    option_statusline(ENTER_WHEREIS_QUERY);
d2947 1
a2947 2
			option_statusline(CANCELLED);
			sleep(InfoSecs);
d2958 1
a2958 2
		    option_statusline(CANCELLED);
		    sleep(InfoSecs);
d2998 1
a2998 1
			    option_statusline(EDIT_CURRENT_QUERY);
d3002 1
a3002 1
			    option_statusline(EDIT_THE_PREV_QUERY);
d3004 1
a3004 1
			    option_statusline(EDIT_A_PREV_QUERY);
d3011 1
a3011 2
			    option_statusline(CANCELLED);
			    sleep(InfoSecs);
d3052 1
a3052 1
			    option_statusline(EDIT_CURRENT_QUERY);
d3057 1
a3057 1
			    option_statusline(EDIT_THE_PREV_QUERY);
d3059 1
a3059 1
			    option_statusline(EDIT_A_PREV_QUERY);
d3067 1
a3067 2
			    option_statusline(CANCELLED);
			    sleep(InfoSecs);
d3117 1
a3117 2
		    option_user_message(STRING_NOT_FOUND, prev_target_buffer);
		    sleep(MessageSecs);
d3159 1
a3159 2
		option_user_message(STRING_NOT_FOUND, prev_target_buffer);
		sleep(MessageSecs);
d3167 1
a3167 1
		    option_statusline(CHOICE_LIST_UNM_MSG);
d3169 1
a3169 1
		    option_statusline(CHOICE_LIST_MESSAGE);
d3186 1
a3186 2
		option_statusline(CANCELLED);
		sleep(MessageSecs);
d3199 1
a3199 1
	option_statusline("");
d3202 1
a3202 1
	option_statusline(VALUE_ACCEPTED);
d3206 1292
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
