head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.07;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYCharUtils.c,v 1.127 2013/11/28 11:17:59 tom Exp $
 *
 *  Functions associated with LYCharSets.c and the Lynx version of HTML.c - FM
 *  ==========================================================================
 */
#include <HTUtils.h>
#include <SGML.h>

#define Lynx_HTML_Handler
#include <HTChunk.h>
#include <HText.h>
#include <HTStyle.h>
#include <HTMIME.h>
#include <HTML.h>

#include <HTCJK.h>
#include <HTAtom.h>
#include <HTMLGen.h>
#include <HTParse.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYGlobalDefs.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>

#include <HTAlert.h>
#include <HTForms.h>
#include <HTNestedList.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <LYBookmark.h>
#include <LYCurses.h>
#include <LYCookie.h>

#include <LYexit.h>
#include <LYLeaks.h>

/*
 * Used for nested lists.  - FM
 */
int OL_CONTINUE = -29999;	/* flag for whether CONTINUE is set */
int OL_VOID = -29998;		/* flag for whether a count is set */

static size_t count_char(const char *value, int ch)
{
    const char *found;
    size_t result = 0;

    while ((*value != '\0') && (found = StrChr(value, ch)) != NULL) {
	++result;
	value = (found + 1);
    }
    return result;
}

/*
 * This function converts any ampersands in a pre-allocated string to "&amp;". 
 * If brackets is TRUE, it also converts any angle-brackets to "&lt;" or "&gt;".
 */
void LYEntify(char **in_out,
	      int brackets)
{
    char *source = *in_out;
    char *target;
    char *result = NULL;
    size_t count_AMPs = 0;
    size_t count_LTs = 0;
    size_t count_GTs = 0;

#ifdef CJK_EX
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren
    } state = S_text;
    int in_sjis = 0;
#endif

    if (non_empty(source)) {
	count_AMPs = count_char(*in_out, '&');
	if (brackets) {
	    count_LTs = count_char(*in_out, '<');
	    count_GTs = count_char(*in_out, '>');
	}

	if (count_AMPs != 0 || count_LTs != 0 || count_GTs != 0) {

	    target = typecallocn(char,
				   (strlen(*in_out)
				    + (4 * count_AMPs)
				    + (3 * count_LTs)
				    + (3 * count_GTs) + 1));

	    if ((result = target) == NULL)
		outofmem(__FILE__, "LYEntify");

	    for (source = *in_out; *source; source++) {
#ifdef CJK_EX
		if (IS_CJK_TTY) {
		    switch (state) {
		    case S_text:
			if (*source == '\033') {
			    state = S_esc;
			    *target++ = *source;
			    continue;
			}
			break;

		    case S_esc:
			if (*source == '$') {
			    state = S_dollar;
			} else if (*source == '(') {
			    state = S_paren;
			} else {
			    state = S_text;
			}
			*target++ = *source;
			continue;

		    case S_dollar:
			if (*source == '@@' || *source == 'B' || *source == 'A') {
			    state = S_nonascii_text;
			} else if (*source == '(') {
			    state = S_dollar_paren;
			} else {
			    state = S_text;
			}
			*target++ = *source;
			continue;

		    case S_dollar_paren:
			if (*source == 'C') {
			    state = S_nonascii_text;
			} else {
			    state = S_text;
			}
			*target++ = *source;
			continue;

		    case S_paren:
			if (*source == 'B' || *source == 'J' || *source == 'T') {
			    state = S_text;
			} else if (*source == 'I') {
			    state = S_nonascii_text;
			} else if (*source == '\033') {
			    state = S_esc;
			}
			*target++ = *source;
			continue;

		    case S_nonascii_text:
			if (*source == '\033')
			    state = S_esc;
			*target++ = *source;
			continue;

		    default:
			break;
		    }
		    if (*(source + 1) != '\0' &&
			(IS_EUC(UCH(*source), UCH(*(source + 1))) ||
			 IS_SJIS(UCH(*source), UCH(*(source + 1)), in_sjis) ||
			 IS_BIG5(UCH(*source), UCH(*(source + 1))))) {
			*target++ = *source++;
			*target++ = *source;
			continue;
		    }
		}
#endif
		switch (*source) {
		case '&':
		    *target++ = '&';
		    *target++ = 'a';
		    *target++ = 'm';
		    *target++ = 'p';
		    *target++ = ';';
		    break;
		case '<':
		    if (brackets) {
			*target++ = '&';
			*target++ = 'l';
			*target++ = 't';
			*target++ = ';';
			break;
		    }
		    /* FALLTHRU */
		case '>':
		    if (brackets) {
			*target++ = '&';
			*target++ = 'g';
			*target++ = 't';
			*target++ = ';';
			break;
		    }
		    /* FALLTHRU */
		default:
		    *target++ = *source;
		    break;
		}
	    }
	    *target = '\0';
	    FREE(*in_out);
	    *in_out = result;
	}
    }
}

/*
 * Callers to LYEntifyTitle/LYEntifyValue do not look at the 'target' param.
 * Optimize things a little by avoiding the memory allocation if not needed,
 * as is usually the case.
 */
static BOOL MustEntify(const char *source)
{
    BOOL result;

#ifdef CJK_EX
    if (IS_CJK_TTY && StrChr(source, '\033') != 0) {
	result = TRUE;
    } else
#endif
    {
	size_t length = strlen(source);
	size_t reject = strcspn(source, "<&>");

	result = (BOOL) (length != reject);
    }

    return result;
}

/*
 * Wrappers for LYEntify() which do not assume that the source was allocated,
 * e.g., output from gettext().
 */
const char *LYEntifyTitle(char **target, const char *source)
{
    const char *result = 0;

    if (MustEntify(source)) {
	StrAllocCopy(*target, source);
	LYEntify(target, TRUE);
	result = *target;
    } else {
	result = source;
    }
    return result;
}

const char *LYEntifyValue(char **target, const char *source)
{
    const char *result = 0;

    if (MustEntify(source)) {
	StrAllocCopy(*target, source);
	LYEntify(target, FALSE);
	result = *target;
    } else {
	result = source;
    }
    return result;
}

/*
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1) and HT_EN_SPACE (2),
 *  but not ESC, from the heads of strings. - FM
 */
void LYTrimHead(char *str)
{
    const char *s = str;

    if (isEmpty(s))
	return;

    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))	/* S/390 -- gil -- 1669 */
	s++;
    if (s > str) {
	char *ns = str;

	while (*s) {
	    *ns++ = *s++;
	}
	*ns = '\0';
    }
}

/*
 *  This function trims characters <= that of a space (32),
 *  including HT_NON_BREAK_SPACE (1), HT_EN_SPACE (2), and
 *  ESC from the tails of strings. - FM
 */
void LYTrimTail(char *str)
{
    int i;

    if (isEmpty(str))
	return;

    i = (int) strlen(str) - 1;
    while (i >= 0) {
	if (WHITE(str[i]))
	    str[i] = '\0';
	else
	    break;
	i--;
    }
}

/*
 * This function should receive a pointer to the start
 * of a comment.  It returns a pointer to the end ('>')
 * character of comment, or it's best guess if the comment
 * is invalid. - FM
 */
char *LYFindEndOfComment(char *str)
{
    char *cp, *cp1;
    enum comment_state {
	start1,
	start2,
	end1,
	end2
    } state;

    if (str == NULL)
	/*
	 * We got NULL, so return NULL.  - FM
	 */
	return NULL;

    if (StrNCmp(str, "<!--", 4))
	/*
	 * We don't have the start of a comment, so return the beginning of the
	 * string.  - FM
	 */
	return str;

    cp = (str + 4);
    if (*cp == '>')
	/*
	 * It's an invalid comment, so
	 * return this end character. - FM
	 */
	return cp;

    if ((cp1 = StrChr(cp, '>')) == NULL)
	/*
	 * We don't have an end character, so return the beginning of the
	 * string.  - FM
	 */
	return str;

    if (*cp == '-')
	/*
	 * Ugh, it's a "decorative" series of dashes, so return the next end
	 * character.  - FM
	 */
	return cp1;

    /*
     * OK, we're ready to start parsing.  - FM
     */
    state = start2;
    while (*cp != '\0') {
	switch (state) {
	case start1:
	    if (*cp == '-')
		state = start2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;

	case start2:
	    if (*cp == '-')
		state = end1;
	    break;

	case end1:
	    if (*cp == '-')
		state = end2;
	    else
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    break;

	case end2:
	    if (*cp == '>')
		/*
		 * Valid comment, so return the end character.  - FM
		 */
		return cp;
	    if (*cp == '-') {
		state = start1;
	    } else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {	/* S/390 -- gil -- 1686 */
		/*
		 * Invalid comment, so return the first '>' from the start of
		 * the string.  - FM
		 */
		return cp1;
	    }
	    break;

	default:
	    break;
	}
	cp++;
    }

    /*
     * Invalid comment, so return the first '>' from the start of the string. 
     * - FM
     */
    return cp1;
}

/*
 *  If an HREF, itself or if resolved against a base,
 *  represents a file URL, and the host is defaulted,
 *  force in "//localhost".  We need this until
 *  all the other Lynx code which performs security
 *  checks based on the "localhost" string is changed
 *  to assume "//localhost" when a host field is not
 *  present in file URLs - FM
 */
void LYFillLocalFileURL(char **href,
			const char *base)
{
    char *temp = NULL;

    if (isEmpty(*href))
	return;

    if (!strcmp(*href, "//") || !StrNCmp(*href, "///", 3)) {
	if (base != NULL && isFILE_URL(base)) {
	    StrAllocCopy(temp, STR_FILE_URL);
	    StrAllocCat(temp, *href);
	    StrAllocCopy(*href, temp);
	}
    }
    if (isFILE_URL(*href)) {
	if (*(*href + 5) == '\0') {
	    StrAllocCat(*href, "//localhost");
	} else if (!strcmp(*href, "file://")) {
	    StrAllocCat(*href, "localhost");
	} else if (!StrNCmp(*href, "file:///", 8)) {
	    StrAllocCopy(temp, (*href + 7));
	    LYLocalFileToURL(href, temp);
	} else if (!StrNCmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href + 6))) {
	    StrAllocCopy(temp, (*href + 5));
	    LYLocalFileToURL(href, temp);
	}
    }
#if defined(USE_DOS_DRIVES)
    if (LYIsDosDrive(*href)) {
	/*
	 * If it's a local DOS path beginning with drive letter,
	 * add file://localhost/ prefix and go ahead.
	 */
	StrAllocCopy(temp, *href);
	LYLocalFileToURL(href, temp);
    }

    /* use below: strlen("file://localhost/") = 17 */
    if (!StrNCmp(*href, "file://localhost/", 17)
	&& (strlen(*href) == 19)
	&& LYIsDosDrive(*href + 17)) {
	/*
	 * Terminate DOS drive letter with a slash to surf root successfully.
	 * Here seems a proper place to do so.
	 */
	LYAddPathSep(href);
    }
#endif /* USE_DOS_DRIVES */

    /*
     * No path in a file://localhost URL means a
     * directory listing for the current default. - FM
     */
    if (!strcmp(*href, "file://localhost")) {
	const char *temp2;

#ifdef VMS
	temp2 = HTVMS_wwwName(LYGetEnv("PATH"));
#else
	char curdir[LY_MAXPATH];

	temp2 = wwwName(Current_Dir(curdir));
#endif /* VMS */
	if (!LYIsHtmlSep(*temp2))
	    LYAddHtmlSep(href);
	/*
	 * Check for pathological cases - current dir has chars which MUST BE
	 * URL-escaped - kw
	 */
	if (StrChr(temp2, '%') != NULL || StrChr(temp2, '#') != NULL) {
	    FREE(temp);
	    temp = HTEscape(temp2, URL_PATH);
	    StrAllocCat(*href, temp);
	} else {
	    StrAllocCat(*href, temp2);
	}
    }
#ifdef VMS
    /*
     * On VMS, a file://localhost/ URL means
     * a listing for the login directory. - FM
     */
    if (!strcmp(*href, "file://localhost/"))
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir()) + 1));
#endif /* VMS */

    FREE(temp);
    return;
}

void LYAddMETAcharsetToStream(HTStream *target, int disp_chndl)
{
    char *buf = 0;

    if (disp_chndl == -1)
	/*
	 * -1 means use current_char_set.
	 */
	disp_chndl = current_char_set;

    if (target != 0 && disp_chndl >= 0) {
	HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
		   "http-equiv=\"content-type\"",
		   LYCharSet_UC[disp_chndl].MIMEname);
	(*target->isa->put_string) (target, buf);
	FREE(buf);
    }
}

/*
 *  This function writes a line with a META tag to an open file,
 *  which will specify a charset parameter to use when the file is
 *  read back in.  It is meant for temporary HTML files used by the
 *  various special pages which may show titles of documents.  When those
 *  files are created, the title strings normally have been translated and
 *  expanded to the display character set, so we have to make sure they
 *  don't get translated again.
 *  If the user has changed the display character set during the lifetime
 *  of the Lynx session (or, more exactly, during the time the title
 *  strings to be written were generated), they may now have different
 *  character encodings and there is currently no way to get it all right.
 *  To change this, we would have to add a variable for each string which
 *  keeps track of its character encoding.
 *  But at least we can try to ensure that reading the file after future
 *  display character set changes will give reasonable output.
 *
 *  The META tag is not written if the display character set (passed as
 *  disp_chndl) already corresponds to the charset assumption that
 *  would be made when the file is read. - KW
 *
 *  Currently this function is used for temporary files like "Lynx Info Page"
 *  and for one permanent - bookmarks (so it may be a problem if you change
 *  the display charset later: new bookmark entries may be mistranslated).
 *								 - LP
 */
void LYAddMETAcharsetToFD(FILE *fd, int disp_chndl)
{
    if (disp_chndl == -1)
	/*
	 * -1 means use current_char_set.
	 */
	disp_chndl = current_char_set;

    if (fd == NULL || disp_chndl < 0)
	/*
	 * Should not happen.
	 */
	return;

    if (UCLYhndl_HTFile_for_unspec == disp_chndl)
	/*
	 * Not need to do, so we don't.
	 */
	return;

    if (LYCharSet_UC[disp_chndl].enc == UCT_ENC_7BIT)
	/*
	 * There shouldn't be any 8-bit characters in this case.
	 */
	return;

    /*
     * In other cases we don't know because UCLYhndl_for_unspec may change
     * during the lifetime of the file (by toggling raw mode or changing the
     * display character set), so proceed.
     */
    fprintf(fd, "<META %s content=\"text/html;charset=%s\">\n",
	    "http-equiv=\"content-type\"",
	    LYCharSet_UC[disp_chndl].MIMEname);
}

/*
 * This function returns OL TYPE="A" strings in
 * the range of " A." (1) to "ZZZ." (18278). - FM
 */
char *LYUppercaseA_OL_String(int seqnum)
{
    static char OLstring[8];

    if (seqnum <= 1) {
	strcpy(OLstring, " A.");
	return OLstring;
    }
    if (seqnum < 27) {
	sprintf(OLstring, " %c.", (seqnum + 64));
	return OLstring;
    }
    if (seqnum < 703) {
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
	return OLstring;
    }
    if (seqnum < 18279) {
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 64),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 64),
		(seqnum - ((seqnum - 1) / 26) * 26 + 64));
	return OLstring;
    }
    strcpy(OLstring, "ZZZ.");
    return OLstring;
}

/*
 * This function returns OL TYPE="a" strings in
 * the range of " a." (1) to "zzz." (18278). - FM
 */
char *LYLowercaseA_OL_String(int seqnum)
{
    static char OLstring[8];

    if (seqnum <= 1) {
	strcpy(OLstring, " a.");
	return OLstring;
    }
    if (seqnum < 27) {
	sprintf(OLstring, " %c.", (seqnum + 96));
	return OLstring;
    }
    if (seqnum < 703) {
	sprintf(OLstring, "%c%c.", ((seqnum - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
	return OLstring;
    }
    if (seqnum < 18279) {
	sprintf(OLstring, "%c%c%c.", ((seqnum - 27) / 676 + 96),
		(((seqnum - ((seqnum - 27) / 676) * 676) - 1) / 26 + 96),
		(seqnum - ((seqnum - 1) / 26) * 26 + 96));
	return OLstring;
    }
    strcpy(OLstring, "zzz.");
    return OLstring;
}

/*
 * This function returns OL TYPE="I" strings in the
 * range of " I." (1) to "MMM." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYUppercaseI_OL_String(int seqnum)
{
    static char OLstring[20];
    int Arabic = seqnum;

    if (Arabic >= 3000) {
	strcpy(OLstring, "MMM.");
	return OLstring;
    }

    switch (Arabic) {
    case 1:
	strcpy(OLstring, " I.");
	return OLstring;
    case 5:
	strcpy(OLstring, " V.");
	return OLstring;
    case 10:
	strcpy(OLstring, " X.");
	return OLstring;
    case 50:
	strcpy(OLstring, " L.");
	return OLstring;
    case 100:
	strcpy(OLstring, " C.");
	return OLstring;
    case 500:
	strcpy(OLstring, " D.");
	return OLstring;
    case 1000:
	strcpy(OLstring, " M.");
	return OLstring;
    default:
	OLstring[0] = '\0';
	break;
    }

    while (Arabic >= 1000) {
	strcat(OLstring, "M");
	Arabic -= 1000;
    }

    if (Arabic >= 900) {
	strcat(OLstring, "CM");
	Arabic -= 900;
    }

    if (Arabic >= 500) {
	strcat(OLstring, "D");
	Arabic -= 500;
    }

    if (Arabic >= 400) {
	strcat(OLstring, "CD");
	Arabic -= 400;
    }

    while (Arabic >= 100) {
	strcat(OLstring, "C");
	Arabic -= 100;
    }

    if (Arabic >= 90) {
	strcat(OLstring, "XC");
	Arabic -= 90;
    }

    if (Arabic >= 50) {
	strcat(OLstring, "L");
	Arabic -= 50;
    }

    if (Arabic >= 40) {
	strcat(OLstring, "XL");
	Arabic -= 40;
    }

    while (Arabic > 10) {
	strcat(OLstring, "X");
	Arabic -= 10;
    }

    switch (Arabic) {
    case 1:
	strcat(OLstring, "I.");
	break;
    case 2:
	strcat(OLstring, "II.");
	break;
    case 3:
	strcat(OLstring, "III.");
	break;
    case 4:
	strcat(OLstring, "IV.");
	break;
    case 5:
	strcat(OLstring, "V.");
	break;
    case 6:
	strcat(OLstring, "VI.");
	break;
    case 7:
	strcat(OLstring, "VII.");
	break;
    case 8:
	strcat(OLstring, "VIII.");
	break;
    case 9:
	strcat(OLstring, "IX.");
	break;
    case 10:
	strcat(OLstring, "X.");
	break;
    default:
	strcat(OLstring, ".");
	break;
    }

    return OLstring;
}

/*
 * This function returns OL TYPE="i" strings in
 * range of " i." (1) to "mmm." (3000).- FM
 * Maximum length: 16 -TD
 */
char *LYLowercaseI_OL_String(int seqnum)
{
    static char OLstring[20];
    int Arabic = seqnum;

    if (Arabic >= 3000) {
	strcpy(OLstring, "mmm.");
	return OLstring;
    }

    switch (Arabic) {
    case 1:
	strcpy(OLstring, " i.");
	return OLstring;
    case 5:
	strcpy(OLstring, " v.");
	return OLstring;
    case 10:
	strcpy(OLstring, " x.");
	return OLstring;
    case 50:
	strcpy(OLstring, " l.");
	return OLstring;
    case 100:
	strcpy(OLstring, " c.");
	return OLstring;
    case 500:
	strcpy(OLstring, " d.");
	return OLstring;
    case 1000:
	strcpy(OLstring, " m.");
	return OLstring;
    default:
	OLstring[0] = '\0';
	break;
    }

    while (Arabic >= 1000) {
	strcat(OLstring, "m");
	Arabic -= 1000;
    }

    if (Arabic >= 900) {
	strcat(OLstring, "cm");
	Arabic -= 900;
    }

    if (Arabic >= 500) {
	strcat(OLstring, "d");
	Arabic -= 500;
    }

    if (Arabic >= 400) {
	strcat(OLstring, "cd");
	Arabic -= 400;
    }

    while (Arabic >= 100) {
	strcat(OLstring, "c");
	Arabic -= 100;
    }

    if (Arabic >= 90) {
	strcat(OLstring, "xc");
	Arabic -= 90;
    }

    if (Arabic >= 50) {
	strcat(OLstring, "l");
	Arabic -= 50;
    }

    if (Arabic >= 40) {
	strcat(OLstring, "xl");
	Arabic -= 40;
    }

    while (Arabic > 10) {
	strcat(OLstring, "x");
	Arabic -= 10;
    }

    switch (Arabic) {
    case 1:
	strcat(OLstring, "i.");
	break;
    case 2:
	strcat(OLstring, "ii.");
	break;
    case 3:
	strcat(OLstring, "iii.");
	break;
    case 4:
	strcat(OLstring, "iv.");
	break;
    case 5:
	strcat(OLstring, "v.");
	break;
    case 6:
	strcat(OLstring, "vi.");
	break;
    case 7:
	strcat(OLstring, "vii.");
	break;
    case 8:
	strcat(OLstring, "viii.");
	break;
    case 9:
	strcat(OLstring, "ix.");
	break;
    case 10:
	strcat(OLstring, "x.");
	break;
    default:
	strcat(OLstring, ".");
	break;
    }

    return OLstring;
}

/*
 *  This function initializes the Ordered List counter. - FM
 */
void LYZero_OL_Counter(HTStructured * me)
{
    int i;

    if (!me)
	return;

    for (i = 0; i < 12; i++) {
	me->OL_Counter[i] = OL_VOID;
	me->OL_Type[i] = '1';
    }

    me->Last_OL_Count = 0;
    me->Last_OL_Type = '1';

    return;
}

/*
 *  This function is used by the HTML Structured object. - KW
 */
void LYGetChartransInfo(HTStructured * me)
{
    me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					UCT_STAGE_STRUCTURED);
    if (me->UCLYhndl < 0) {
	int chndl = HTAnchor_getUCLYhndl(me->node_anchor, UCT_STAGE_HTEXT);

	if (chndl < 0) {
	    chndl = current_char_set;
	    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
				    UCT_STAGE_HTEXT,
				    UCT_SETBY_STRUCTURED);
	}
	HTAnchor_setUCInfoStage(me->node_anchor, chndl,
				UCT_STAGE_STRUCTURED,
				UCT_SETBY_STRUCTURED);
	me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					    UCT_STAGE_STRUCTURED);
    }
    me->UCI = HTAnchor_getUCInfoStage(me->node_anchor,
				      UCT_STAGE_STRUCTURED);
}

	/* as in HTParse.c, saves some calls - kw */
static const char *hex = "0123456789ABCDEF";

/*
 *	  Any raw 8-bit or multibyte characters already have been
 *	  handled in relation to the display character set
 *	  in SGML_character(), including named and numeric entities.
 *
 *  This function used for translations HTML special fields inside tags
 *  (ALT=, VALUE=, etc.) from charset `cs_from' to charset `cs_to'.
 *  It also unescapes non-ASCII characters from URL (#fragments !)
 *  if st_URL is active.
 *
 *  If `do_ent' is YES, it converts named entities
 *  and numeric character references (NCRs) to their `cs_to' replacements.
 *
 *  Named entities converted to unicodes.  NCRs (unicodes) converted
 *  by UCdomap.c chartrans functions.
 *  ???NCRs with values in the ISO-8859-1 range 160-255 may be converted
 *  to their HTML entity names (via old-style entities) and then translated
 *  according to the LYCharSets.c array for `cs_out'???.
 *
 *  Some characters (see descriptions in `put_special_unicodes' from SGML.c)
 *  translated in relation with the state of boolean variables
 *  `use_lynx_specials', `plain_space' and `hidden'.  It is not clear yet:
 *
 *  If plain_space is TRUE, nbsp (160) will be treated as an ASCII
 *  space (32).  If hidden is TRUE, entities will be translated
 *  (if `do_ent' is YES) but escape sequences will be passed unaltered.
 *  If `hidden' is FALSE, some characters are converted to Lynx special
 *  codes (see `put_special_unicodes') or ASCII space if `plain_space'
 *  applies).  @@@@ is `use_lynx_specials' needed, does it have any effect? @@@@
 *  If `use_lynx_specials' is YES, translate byte values 160 and 173
 *  meaning U+00A0 and U+00AD given as or converted from raw char input
 *  are converted to HT_NON_BREAK_SPACE and LY_SOFT_HYPHEN, respectively
 *  (unless input and output charset are both iso-8859-1, for compatibility
 *  with previous usage in HTML.c) even if `hidden' or `plain_space' is set.
 *
 *  If `Back' is YES, the reverse is done instead i.e., Lynx special codes
 *  in the input are translated back to character values.
 *
 *  If `Back' is YES, an attempt is made to use UCReverseTransChar() for
 *  back translation which may be more efficient. (?)
 *
 *  If `stype' is st_URL, non-ASCII characters are URL-encoded instead.
 *  The sequence of bytes being URL-encoded is the raw input character if
 *  we couldn't translate it from `cs_in' (CJK etc.); otherwise it is the
 *  UTF-8 representation if either `cs_to' requires this or if the
 *  character's Unicode value is > 255, otherwise it should be the iso-8859-1
 *  representation.
 *  No general URL-encoding occurs for displayable ASCII characters and
 *  spaces and some C0 controls valid in HTML (LF, TAB), it is expected
 *  that other functions will take care of that as appropriate.
 *
 *  Escape characters (0x1B, '\033') are
 *  - URL-encoded	if `stype'  is st_URL,	 otherwise
 *  - dropped		if `stype'  is st_other, otherwise (i.e., st_HTML)
 *  - passed		if `hidden' is TRUE or HTCJK is set, otherwise
 *  - dropped.
 *
 *  (If `stype' is st_URL or st_other most of the parameters really predefined:
 *  cs_from=cs_to, use_lynx_specials=plain_space=NO, and hidden=YES)
 *
 *
 *  Returns pointer to the char** passed in
 *		 if string translated or translation unnecessary,
 *	    NULL otherwise
 *		 (in which case something probably went wrong.)
 *
 *
 *  In general, this somehow ugly function (KW)
 *  cover three functions from v.2.7.2 (FM):
 *		    extern void LYExpandString (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeEntities (
 *		       HTStructured *	       me,
 *		       char **		       str);
 *		    extern void LYUnEscapeToLatinOne (
 *		       HTStructured *	       me,
 *		       char **		       str,
 *		       BOOLEAN		       isURL);
 */

char **LYUCFullyTranslateString(char **str,
				int cs_from,
				int cs_to,
				int do_ent,
				int use_lynx_specials,
				int plain_space,
				int hidden,
				int Back,
				CharUtil_st stype)
{
    char *p;
    char *q, *qs;
    HTChunk *chunk = NULL;
    char *cp = 0;
    char cpe = 0;
    char *esc = NULL;
    char replace_buf[64];
    int uck;
    int lowest_8;
    UCode_t code = 0;
    BOOL output_utf8 = 0, repl_translated_C0 = 0;
    size_t len;
    const char *name = NULL;
    BOOLEAN no_bytetrans;
    UCTransParams T;
    BOOL from_is_utf8 = FALSE;
    char *puni;
    enum _state {
	S_text,
	S_esc,
	S_dollar,
	S_paren,
	S_nonascii_text,
	S_dollar_paren,
	S_trans_byte,
	S_check_ent,
	S_ncr,
	S_check_uni,
	S_named,
	S_check_name,
	S_recover,
	S_got_oututf8,
	S_got_outstring,
	S_put_urlstring,
	S_got_outchar,
	S_put_urlchar,
	S_next_char,
	S_done
    } state = S_text;
    enum _parsing_what {
	P_text,
	P_utf8,
	P_hex,
	P_decimal,
	P_named
    } what = P_text;

#ifdef KANJI_CODE_OVERRIDE
    static unsigned char sjis_1st = '\0';

    unsigned char sjis_str[3];
#endif

    /*
     * Make sure we have a non-empty string.  - FM
     */
    if (isEmpty(*str))
	return str;

    /*
     * FIXME: something's wrong with the limit checks here (clearing the
     * buffer helps).
     */
    memset(replace_buf, 0, sizeof(replace_buf));

    /*
     * Don't do byte translation if original AND target character sets are both
     * iso-8859-1 (and we are not called to back-translate), or if we are in
     * CJK mode.
     */
    if (IS_CJK_TTY
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& (strcmp(LYCharSet_UC[cs_from].MIMEname, "utf-8") != 0)
	&& (strcmp(LYCharSet_UC[cs_to].MIMEname, "utf-8") != 0)
#endif
	) {
	no_bytetrans = TRUE;
    } else if (cs_to <= 0 && cs_from == cs_to && (!Back || cs_to < 0)) {
	no_bytetrans = TRUE;
    } else {
	/* No need to translate or examine the string any further */
	no_bytetrans = (BOOL) (!use_lynx_specials && !Back &&
			       UCNeedNotTranslate(cs_from, cs_to));
    }
    /*
     * Save malloc/calloc overhead in simple case - kw
     */
    if (do_ent && hidden && (stype != st_URL) && (StrChr(*str, '&') == NULL))
	do_ent = FALSE;

    /* Can't do, caller should figure out what to do... */
    if (!UCCanTranslateFromTo(cs_from, cs_to)) {
	if (cs_to < 0)
	    return NULL;
	if (!do_ent && no_bytetrans)
	    return NULL;
	no_bytetrans = TRUE;
    } else if (cs_to < 0) {
	do_ent = FALSE;
    }

    if (!do_ent && no_bytetrans)
	return str;
    p = *str;

    if (!no_bytetrans) {
	UCTransParams_clear(&T);
	UCSetTransParams(&T, cs_from, &LYCharSet_UC[cs_from],
			 cs_to, &LYCharSet_UC[cs_to]);
	from_is_utf8 = (BOOL) (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
	output_utf8 = T.output_utf8;
	repl_translated_C0 = T.repl_translated_C0;
	puni = p;
    } else if (do_ent) {
	output_utf8 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
			      HText_hasUTF8OutputSet(HTMainText));
	repl_translated_C0 = (BOOL) (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
    }

    lowest_8 = LYlowest_eightbit[cs_to];

    /*
     * Create a buffer string seven times the length of the original, so we
     * have plenty of room for expansions.  - FM
     */
    len = strlen(p) + 16;
    q = p;

    qs = q;

/*  Create the HTChunk only if we need it */
#define CHUNK (chunk ? chunk : (chunk = HTChunkCreate2(128, len+1)))

#define REPLACE_STRING(s) \
		if (q != qs) HTChunkPutb(CHUNK, qs, (int) (q - qs)); \
		HTChunkPuts(CHUNK, s); \
		qs = q = *str

#define REPLACE_CHAR(c) if (q > p) { \
		HTChunkPutb(CHUNK, qs, (int) (q - qs)); \
		qs = q = *str; \
		*q++ = c; \
	    } else \
		*q++ = c

    /*
     * Loop through string, making conversions as needed.
     *
     * The while() checks for a non-'\0' char only for the normal text states
     * since other states may temporarily modify p or *p (which should be
     * restored before S_done!) - kw
     */
    while (*p || (state != S_text && state != S_nonascii_text)) {
	switch (state) {
	case S_text:
	    code = UCH(*p);
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE && last_kcode == SJIS) {
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code) || IS_SJIS_HI2(code))) {
		    sjis_1st = UCH(code);
		} else if (sjis_1st && IS_SJIS_LO(code)) {
		    sjis_1st = '\0';
		} else {
		    if (conv_jisx0201kana && 0xA1 <= code && code <= 0xDF) {
			sjis_str[2] = '\0';
			JISx0201TO0208_SJIS(UCH(code),
					    sjis_str, sjis_str + 1);
			REPLACE_STRING(sjis_str);
			p++;
			continue;
		    }
		}
	    }
#endif
	    if (*p == '\033') {
		if ((IS_CJK_TTY && !hidden) || stype != st_HTML) {
		    state = S_esc;
		    if (stype == st_URL) {
			REPLACE_STRING("%1B");
			p++;
			continue;
		    } else if (stype != st_HTML) {
			p++;
			continue;
		    } else {
			*q++ = *p++;
			continue;
		    }
		} else if (!hidden) {
		    /*
		     * CJK handling not on, and not a hidden INPUT, so block
		     * escape.  - FM
		     */
		    state = S_next_char;
		} else {
		    state = S_trans_byte;
		}
	    } else {
		state = (do_ent ? S_check_ent : S_trans_byte);
	    }
	    break;

	case S_esc:
	    if (*p == '$') {
		state = S_dollar;
		*q++ = *p++;
		continue;
	    } else if (*p == '(') {
		state = S_paren;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_dollar:
	    if (*p == '@@' || *p == 'B' || *p == 'A') {
		state = S_nonascii_text;
		*q++ = *p++;
		continue;
	    } else if (*p == '(') {
		state = S_dollar_paren;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_dollar_paren:
	    if (*p == 'C') {
		state = S_nonascii_text;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_paren:
	    if (*p == 'B' || *p == 'J' || *p == 'T') {
		state = S_text;
		*q++ = *p++;
		continue;
	    } else if (*p == 'I') {
		state = S_nonascii_text;
		*q++ = *p++;
		continue;
	    } else {
		state = S_text;
	    }
	    break;

	case S_nonascii_text:
	    if (*p == '\033') {
		if ((IS_CJK_TTY && !hidden) || stype != st_HTML) {
		    state = S_esc;
		    if (stype == st_URL) {
			REPLACE_STRING("%1B");
			p++;
			continue;
		    } else if (stype != st_HTML) {
			p++;
			continue;
		    }
		}
	    }
	    *q++ = *p++;
	    continue;

	case S_trans_byte:
	    /* character translation goes here */
	    /*
	     * Don't do anything if we have no string, or if original AND
	     * target character sets are both iso-8859-1, or if we are in CJK
	     * mode.
	     */
	    if (*p == '\0' || no_bytetrans) {
		state = S_got_outchar;
		break;
	    }

	    if (Back) {
		int rev_c;

		if ((*p) == HT_NON_BREAK_SPACE ||
		    (*p) == HT_EN_SPACE) {
		    if (plain_space) {
			code = *p = ' ';
			state = S_got_outchar;
			break;
		    } else {
			code = 160;
			if (LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			    (LYCharSet_UC[cs_to].like8859 & UCT_R_8859SPECL)) {
			    state = S_got_outchar;
			    break;
			} else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
				     || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			    state = S_check_uni;
			    break;
			} else {
			    *(unsigned char *) p = UCH(160);
			}
		    }
		} else if ((*p) == LY_SOFT_HYPHEN) {
		    code = 173;
		    if (LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			(LYCharSet_UC[cs_to].like8859 & UCT_R_8859SPECL)) {
			state = S_got_outchar;
			break;
		    } else if (!(LYCharSet_UC[cs_from].enc == UCT_ENC_8859
				 || (LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
			state = S_check_uni;
			break;
		    } else {
			*(unsigned char *) p = UCH(173);
		    }
#ifdef EXP_JAPANESEUTF8_SUPPORT
		} else if (output_utf8) {
		    if ((!strcmp(LYCharSet_UC[cs_from].MIMEname, "euc-jp") &&
			 (IS_EUC((unsigned char) (*p),
				 (unsigned char) (*(p + 1))))) ||
			(!strcmp(LYCharSet_UC[cs_from].MIMEname, "shift_jis") &&
			 (IS_SJIS_2BYTE((unsigned char) (*p),
					(unsigned char) (*(p + 1)))))) {
			code = UCTransJPToUni(p, 2, cs_from);
			p++;
			state = S_check_uni;
			break;
		    }
#endif
		} else if (code < 127 || T.transp) {
		    state = S_got_outchar;
		    break;
		}
		rev_c = UCReverseTransChar(*p, cs_to, cs_from);
		if (rev_c > 127) {
		    *p = (char) rev_c;
		    code = rev_c;
		    state = S_got_outchar;
		    break;
		}
	    } else if (code < 127) {
		state = S_got_outchar;
		break;
	    }

	    if (from_is_utf8) {
		if (((*p) & 0xc0) == 0xc0) {
		    puni = p;
		    code = UCGetUniFromUtf8String(&puni);
		    if (code <= 0) {
			code = UCH(*p);
		    } else {
			what = P_utf8;
		    }
		}
	    } else if (use_lynx_specials && !Back &&
		       (code == 160 || code == 173) &&
		       (LYCharSet_UC[cs_from].enc == UCT_ENC_8859 ||
			(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
		if (code == 160)
		    code = *p = HT_NON_BREAK_SPACE;
		else if (code == 173)
		    code = *p = LY_SOFT_HYPHEN;
		state = S_got_outchar;
		break;
	    } else if (T.trans_to_uni) {
		code = UCTransToUni(*p, cs_from);
		if (code <= 0) {
		    /* What else can we do? */
		    code = UCH(*p);
		}
	    } else if (!T.trans_from_uni) {
		state = S_got_outchar;
		break;
	    }
	    /*
	     * Substitute Lynx special character for 160 (nbsp) if
	     * use_lynx_specials is set.
	     */
	    if (use_lynx_specials && !Back &&
		(code == 160 || code == 173)) {
		code = ((code == 160 ? HT_NON_BREAK_SPACE : LY_SOFT_HYPHEN));
		state = S_got_outchar;
		break;
	    }

	    state = S_check_uni;
	    break;

	case S_check_ent:
	    if (*p == '&') {
		char *pp = p + 1;

		len = strlen(pp);
		/*
		 * Check for a numeric entity.  - FM
		 */
		if (*pp == '#' && len > 2 &&
		    (*(pp + 1) == 'x' || *(pp + 1) == 'X') &&
		    UCH(*(pp + 2)) < 127 &&
		    isxdigit(UCH(*(pp + 2)))) {
		    what = P_hex;
		    state = S_ncr;
		} else if (*pp == '#' && len > 2 &&
			   UCH(*(pp + 1)) < 127 &&
			   isdigit(UCH(*(pp + 1)))) {
		    what = P_decimal;
		    state = S_ncr;
		} else if (UCH(*pp) < 127 &&
			   isalpha(UCH(*pp))) {
		    what = P_named;
		    state = S_named;
		} else {
		    state = S_trans_byte;
		}
	    } else {
		state = S_trans_byte;
	    }
	    break;

	case S_ncr:
	    if (what == P_hex) {
		p += 3;
	    } else {		/* P_decimal */
		p += 2;
	    }
	    cp = p;
	    while (*p && UCH(*p) < 127 &&
		   (what == P_hex ? isxdigit(UCH(*p)) :
		    isdigit(UCH(*p)))) {
		p++;
	    }
	    /*
	     * Save the terminator and isolate the digit(s).  - FM
	     */
	    cpe = *p;
	    if (*p)
		*p++ = '\0';
	    /*
	     * Show the numeric entity if the value:
	     * (1) Is greater than 255 and unhandled Unicode.
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if (UCScanCode(&code, cp, (BOOL) (what == P_hex))) {
		code = LYcp1252ToUnicode(code);
		state = S_check_uni;
	    } else {
		state = S_recover;
		break;
	    }
	    break;

	case S_check_uni:
	    /*
	     * Show the numeric entity if the value:
	     * (2) Is less than 32, and not valid and we don't have HTCJK set.
	     * (3) Is 127 and we don't have HTPassHighCtrlRaw or HTCJK set.
	     * (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
	     */
	    if ((code < 32 &&
		 code != 9 && code != 10 && code != 13 &&
		 !IS_CJK_TTY) ||
		(code == 127 &&
		 !(HTPassHighCtrlRaw || IS_CJK_TTY)) ||
		(code > 127 && code < 160 &&
		 !HTPassHighCtrlNum)) {
		state = S_recover;
		break;
	    }
	    /*
	     * Convert the value as an unsigned char, hex escaped if isURL is
	     * set and it's 8-bit, and then recycle the terminator if it is not
	     * a semicolon.  - FM
	     */
	    if (code > 159 && stype == st_URL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 160 (nbsp), use that value if it's a hidden INPUT, otherwise
	     * use an ASCII space (32) if plain_space is TRUE, otherwise use
	     * the Lynx special character.  - FM
	     */
	    if (code == 160) {
		if (plain_space) {
		    code = ' ';
		    state = S_got_outchar;
		    break;
		} else if (use_lynx_specials) {
		    code = HT_NON_BREAK_SPACE;
		    state = S_got_outchar;
		    break;
		} else if ((hidden && !Back)
			   || (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1)
			   || LYCharSet_UC[cs_to].enc == UCT_ENC_8859
			   || (LYCharSet_UC[cs_to].like8859 &
			       UCT_R_8859SPECL)) {
		    state = S_got_outchar;
		    break;
		} else if (
			      (LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
		    ;		/* nothing, may be translated later */
		} else {
		    code = ' ';
		    state = S_got_outchar;
		    break;
		}
	    }
	    /*
	     * For 173 (shy), use that value if it's a hidden INPUT, otherwise
	     * ignore it if plain_space is TRUE, otherwise use the Lynx special
	     * character.  - FM
	     */
	    if (code == 173) {
		if (plain_space) {
		    replace_buf[0] = '\0';
		    state = S_got_outstring;
		    break;
		} else if (Back &&
			   !(LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			     (LYCharSet_UC[cs_to].like8859 &
			      UCT_R_8859SPECL))) {
		    ;		/* nothing, may be translated later */
		} else if (hidden || Back) {
		    state = S_got_outchar;
		    break;
		} else if (use_lynx_specials) {
		    code = LY_SOFT_HYPHEN;
		    state = S_got_outchar;
		    break;
		}
	    }
	    /*
	     * Seek a translation from the chartrans tables.
	     */
	    if ((uck = UCTransUniChar(code,
				      cs_to)) >= 32 &&
		uck < 256 &&
		(uck < 127 || uck >= lowest_8)) {
		code = uck;
		state = S_got_outchar;
		break;
	    } else if ((uck == -4 ||
			(repl_translated_C0 &&
			 uck > 0 && uck < 32)) &&
		/*
		 * Not found; look for replacement string.
		 */
		       UCTransUniCharStr(replace_buf,
					 60, code,
					 cs_to,
					 0) >= 0) {
		state = S_got_outstring;
		break;
	    }
	    if (output_utf8 &&
		code > 127 && code < 0x7fffffffL) {
		state = S_got_oututf8;
		break;
	    }
	    /*
	     * For 8194 (ensp), 8195 (emsp), or 8201 (thinsp), use the
	     * character reference if it's a hidden INPUT, otherwise use an
	     * ASCII space (32) if plain_space is TRUE, otherwise use the Lynx
	     * special character.  - FM
	     */
	    if (code == 8194 || code == 8195 || code == 8201) {
		if (hidden) {
		    state = S_recover;
		} else if (plain_space) {
		    code = ' ';
		    state = S_got_outchar;
		} else {
		    code = HT_EN_SPACE;
		    state = S_got_outchar;
		}
		break;
		/*
		 * Ignore 8204 (zwnj), 8205 (zwj) 8206 (lrm), and 8207 (rlm),
		 * for now, if we got this far without finding a representation
		 * for them.
		 */
	    } else if (code == 8204 || code == 8205 ||
		       code == 8206 || code == 8207) {
		CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%"
			PRI_UCode_t "'.\n", code));
		replace_buf[0] = '\0';
		state = S_got_outstring;
		break;
		/*
		 * Show the numeric entity if the value:  (1) Is greater than
		 * 255 and unhandled Unicode.
		 */
	    } else if (code > 255) {
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		state = S_recover;
		break;
		/*
		 * If it's ASCII, or is 8-bit but HTPassEightBitNum is set or
		 * the character set is "ISO Latin 1", use it's value.  - FM
		 */
	    } else if (code < 161 ||
		       (code < 256 &&
			(HTPassEightBitNum || cs_to == LATIN1))) {
		/*
		 * No conversion needed.
		 */
		state = S_got_outchar;
		break;

		/* The following disabled section doesn't make sense any more. 
		 * It used to make sense in the past, when S_check_named would
		 * look in "old style" tables in addition to what it does now. 
		 * Disabling of going to S_check_name here prevents endless
		 * looping between S_check_uni and S_check_names states, which
		 * could occur here for Latin 1 codes for some cs_to if they
		 * had no translation in that cs_to.  Normally all cs_to
		 * *should* now have valid translations via UCTransUniChar or
		 * UCTransUniCharStr for all Latin 1 codes, so that we would
		 * not get here anyway, and no loop could occur.  Still, if we
		 * *do* get here, FALL THROUGH to case S_recover now.  - kw
		 */
#if 0
		/*
		 * If we get to here, convert and handle the character as a
		 * named entity.  - FM
		 */
	    } else {
		name = HTMLGetEntityName(code - 160);
		state = S_check_name;
		break;
#endif
	    }

	case S_recover:
	    if (what == P_decimal || what == P_hex) {
		/*
		 * Illegal or not yet handled value.  Return "&#" verbatim and
		 * continue from there.  - FM
		 */
		*q++ = '&';
		*q++ = '#';
		if (what == P_hex)
		    *q++ = 'x';
		if (cpe != '\0')
		    *(p - 1) = cpe;
		p = cp;
		state = S_done;
	    } else if (what == P_named) {
		*cp = cpe;
		*q++ = '&';
		state = S_done;
	    } else if (!T.output_utf8 && stype == st_HTML && !hidden &&
		       !(HTPassEightBitRaw &&
			 UCH(*p) >= lowest_8)) {
		sprintf(replace_buf, "U%.2" PRI_UCode_t "", code);

		state = S_got_outstring;
	    } else {
		puni = p;
		code = UCH(*p);
		state = S_got_outchar;
	    }
	    break;

	case S_named:
	    cp = ++p;
	    while (*cp && UCH(*cp) < 127 &&
		   isalnum(UCH(*cp)))
		cp++;
	    cpe = *cp;
	    *cp = '\0';
	    name = p;
	    state = S_check_name;
	    break;

	case S_check_name:
	    /*
	     * Seek the Unicode value for the named entity.
	     *
	     * !!!!  We manually recover the case of '=' terminator which is
	     * commonly found on query to CGI-scripts enclosed as href= URLs
	     * like "somepath/?x=1&yz=2" Without this dirty fix, submission of
	     * such URLs was broken if &yz string happened to be a recognized
	     * entity name.  - LP
	     */
	    if (((code = HTMLGetEntityUCValue(name)) > 0) &&
		!((cpe == '=') && (stype == st_URL))) {
		state = S_check_uni;
		break;
	    }
	    /*
	     * Didn't find the entity.  Return verbatim.
	     */
	    state = S_recover;
	    break;

	    /* * * O U T P U T   S T A T E S * * */

	case S_got_oututf8:
	    if (code > 255 ||
		(code >= 128 && LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8)) {
		UCConvertUniToUtf8(code, replace_buf);
		state = S_got_outstring;
	    } else {
		state = S_got_outchar;
	    }
	    break;
	case S_got_outstring:
	    if (what == P_decimal || what == P_hex) {
		if (cpe != ';' && cpe != '\0')
		    *(--p) = cpe;
		p--;
	    } else if (what == P_named) {
		*cp = cpe;
		p = (*cp != ';') ? (cp - 1) : cp;
	    } else if (what == P_utf8) {
		p = puni;
	    }
	    if (replace_buf[0] == '\0') {
		state = S_next_char;
		break;
	    }
	    if (stype == st_URL) {
		code = replace_buf[0];	/* assume string OK if first char is */
		if (code >= 127 ||
		    (code < 32 && (code != 9 && code != 10 && code != 0))) {
		    state = S_put_urlstring;
		    break;
		}
	    }
	    REPLACE_STRING(replace_buf);
	    state = S_next_char;
	    break;
	case S_put_urlstring:
	    esc = HTEscape(replace_buf, URL_XALPHAS);
	    REPLACE_STRING(esc);
	    FREE(esc);
	    state = S_next_char;
	    break;
	case S_got_outchar:
	    if (what == P_decimal || what == P_hex) {
		if (cpe != ';' && cpe != '\0')
		    *(--p) = cpe;
		p--;
	    } else if (what == P_named) {
		*cp = cpe;
		p = (*cp != ';') ? (cp - 1) : cp;
	    } else if (what == P_utf8) {
		p = puni;
	    }
	    if (stype == st_URL &&
	    /*  Not a full HTEscape, only for 8bit and ctrl chars */
		(TOASCII(code) >= 127 ||	/* S/390 -- gil -- 1925 */
		 (code < ' ' && (code != '\t' && code != '\n')))) {
		state = S_put_urlchar;
		break;
	    } else if (!hidden && code == 10 && *p == 10
		       && q != qs && *(q - 1) == 13) {
		/*
		 * If this is not a hidden string, and the current char is the
		 * LF ('\n') of a CRLF pair, drop the CR ('\r').  - KW
		 */
		*(q - 1) = *p++;
		state = S_done;
		break;
	    }
	    *q++ = (char) code;
	    state = S_next_char;
	    break;
	case S_put_urlchar:
	    *q++ = '%';
	    REPLACE_CHAR(hex[(TOASCII(code) >> 4) & 15]);	/* S/390 -- gil -- 1944 */
	    REPLACE_CHAR(hex[(TOASCII(code) & 15)]);
	    /* fall through */
	case S_next_char:
	    p++;		/* fall through */
	case S_done:
	    state = S_text;
	    what = P_text;
	    /* for next round */
	}
    }

    *q = '\0';
    if (chunk) {
	HTChunkPutb(CHUNK, qs, (int) (q - qs + 1));	/* also terminates */
	if (stype == st_URL || stype == st_other) {
	    LYTrimHead(chunk->data);
	    LYTrimTail(chunk->data);
	}
	StrAllocCopy(*str, chunk->data);
	HTChunkFree(chunk);
    } else {
	if (stype == st_URL || stype == st_other) {
	    LYTrimHead(qs);
	    LYTrimTail(qs);
	}
    }
    return str;
}

#undef REPLACE_CHAR
#undef REPLACE_STRING

BOOL LYUCTranslateHTMLString(char **str,
			     int cs_from,
			     int cs_to,
			     int use_lynx_specials,
			     int plain_space,
			     int hidden,
			     CharUtil_st stype)
{
    BOOL ret = YES;

    /* May reallocate *str even if cs_to == 0 */
    if (!LYUCFullyTranslateString(str, cs_from, cs_to, TRUE,
				  use_lynx_specials, plain_space, hidden,
				  NO, stype)) {
	ret = NO;
    }
    return ret;
}

BOOL LYUCTranslateBackFormData(char **str,
			       int cs_from,
			       int cs_to,
			       int plain_space)
{
    char **ret;

    /* May reallocate *str */
    ret = (LYUCFullyTranslateString(str, cs_from, cs_to, FALSE,
				    NO, plain_space, YES,
				    YES, st_HTML));
    return (BOOL) (ret != NULL);
}

/*
 * Parse a parameter from an HTML META tag, i.e., the CONTENT.
 */
char *LYParseTagParam(char *from,
		      const char *name)
{
    size_t len = strlen(name);
    char *result = NULL;
    char *string = from;

    do {
	if ((string = StrChr(string, ';')) == NULL)
	    return NULL;
	while (*string != '\0' && (*string == ';' || isspace(UCH(*string)))) {
	    string++;
	}
	if (strlen(string) < len)
	    return NULL;
    } while (strncasecomp(string, name, (int) len) != 0);
    string += len;
    while (*string != '\0' && (isspace(UCH(*string)) || *string == '=')) {
	string++;
    }

    StrAllocCopy(result, string);
    len = 0;
    while (isprint(UCH(string[len])) && !isspace(UCH(string[len]))) {
	len++;
    }
    result[len] = '\0';

    /*
     * Strip single quotes, just in case.
     */
    if (len > 2 && result[0] == '\'' && result[len - 1] == result[0]) {
	result[len - 1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string) ;
    }
    return result;
}

/*
 * Given a refresh-URL content string, parses the delay time and the URL
 * string.  Ignore the remainder of the content.
 */
void LYParseRefreshURL(char *content,
		       char **p_seconds,
		       char **p_address)
{
    char *cp;
    char *cp1 = NULL;
    char *Seconds = NULL;

    /*
     * Look for the Seconds field.  - FM
     */
    cp = LYSkipBlanks(content);
    if (*cp && isdigit(UCH(*cp))) {
	cp1 = cp;
	while (*cp1 && isdigit(UCH(*cp1)))
	    cp1++;
	StrnAllocCopy(Seconds, cp, (size_t) (cp1 - cp));
    }
    *p_seconds = Seconds;
    *p_address = LYParseTagParam(content, "URL");

    CTRACE((tfp,
	    "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	    content, NonNull(*p_seconds), NonNull(*p_address)));
}

/*
 *  This function processes META tags in HTML streams. - FM
 */
void LYHandleMETA(HTStructured * me, const BOOL *present,
		  STRING2PTR value,
		  char **include GCC_UNUSED)
{
    char *http_equiv = NULL, *name = NULL, *content = NULL, *charset = NULL;
    char *href = NULL, *id_string = NULL, *temp = NULL;
    char *cp, *cp0, *cp1 = NULL;
    int url_type = 0;

    if (!me || !present)
	return;

    /*
     * Load the attributes for possible use by Lynx.  - FM
     */
    if (present[HTML_META_HTTP_EQUIV] &&
	non_empty(value[HTML_META_HTTP_EQUIV])) {
	StrAllocCopy(http_equiv, value[HTML_META_HTTP_EQUIV]);
	convert_to_spaces(http_equiv, TRUE);
	LYUCTranslateHTMLString(&http_equiv, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (*http_equiv == '\0') {
	    FREE(http_equiv);
	}
    }
    if (present[HTML_META_NAME] &&
	non_empty(value[HTML_META_NAME])) {
	StrAllocCopy(name, value[HTML_META_NAME]);
	convert_to_spaces(name, TRUE);
	LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (*name == '\0') {
	    FREE(name);
	}
    }
    if (present[HTML_META_CONTENT] &&
	non_empty(value[HTML_META_CONTENT])) {
	/*
	 * Technically, we should be creating a comma-separated list, but META
	 * tags come one at a time, and we'll handle (or ignore) them as each
	 * is received.  Also, at this point, we only trim leading and trailing
	 * blanks from the CONTENT value, without translating any named
	 * entities or numeric character references, because how we should do
	 * that depends on what type of information it contains, and whether or
	 * not any of it might be sent to the screen.  - FM
	 */
	StrAllocCopy(content, value[HTML_META_CONTENT]);
	convert_to_spaces(content, FALSE);
	LYTrimHead(content);
	LYTrimTail(content);
	if (*content == '\0') {
	    FREE(content);
	}
    }
    if (present[HTML_META_CHARSET] &&
	non_empty(value[HTML_META_CHARSET])) {
	StrAllocCopy(charset, value[HTML_META_CHARSET]);
	convert_to_spaces(charset, TRUE);
	LYUCTranslateHTMLString(&charset, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (*charset == '\0') {
	    FREE(charset);
	}
    }
    CTRACE((tfp,
	    "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\" CHARSET=\"%s\"\n",
	    NONNULL(http_equiv),
	    NONNULL(name),
	    NONNULL(content),
	    NONNULL(charset)));

    /*
     * Check for a text/html Content-Type with a charset directive, if we
     * didn't already set the charset via a server's header.  - AAC & FM
     */
    if (isEmpty(me->node_anchor->charset) &&
	(charset ||
	 (!strcasecomp(NonNull(http_equiv), "Content-Type") && content))) {
	LYUCcharset *p_in = NULL;
	LYUCcharset *p_out = NULL;

	if (charset) {
	    LYLowerCase(charset);
	} else {
	    LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				    NO, NO, YES, st_other);
	    LYLowerCase(content);
	}

	if ((cp1 = charset) != NULL ||
	    (cp1 = strstr(content, "charset")) != NULL) {
	    BOOL chartrans_ok = NO;
	    char *cp3 = NULL, *cp4;
	    int chndl;

	    if (!charset)
		cp1 += 7;
	    while (*cp1 == ' ' || *cp1 == '=' || *cp1 == '"')
		cp1++;

	    StrAllocCopy(cp3, cp1);	/* copy to mutilate more */
	    for (cp4 = cp3; (*cp4 != '\0' && *cp4 != '"' &&
			     *cp4 != ';' && *cp4 != ':' &&
			     !WHITE(*cp4)); cp4++) {
		;		/* do nothing */
	    }
	    *cp4 = '\0';
	    cp4 = cp3;
	    chndl = UCGetLYhndl_byMIME(cp3);

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	    /* Allow a switch to a more suitable display charset */
	    if (Switch_Display_Charset(chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
		/* UCT_STAGE_STRUCTURED and UCT_STAGE_HTEXT
		   should have the same setting for UCInfoStage. */
		HTAnchor_getUCInfoStage(me->node_anchor, UCT_STAGE_STRUCTURED);

		me->outUCLYhndl = current_char_set;
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_HTEXT,
					UCT_SETBY_MIME);	/* highest priorty! */
		HTAnchor_setUCInfoStage(me->node_anchor,
					current_char_set,
					UCT_STAGE_STRUCTURED,
					UCT_SETBY_MIME);	/* highest priorty! */
		me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
						     UCT_STAGE_HTEXT);
		/* The SGML stage will be reset in change_chartrans_handling */
	    }
#endif

	    if (UCCanTranslateFromTo(chndl, current_char_set)) {
		chartrans_ok = YES;
		StrAllocCopy(me->node_anchor->charset, cp4);
		HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					UCT_STAGE_PARSER,
					UCT_SETBY_STRUCTURED);
	    } else if (chndl < 0) {
		/*
		 * Got something but we don't recognize it.
		 */
		chndl = UCLYhndl_for_unrec;
		if (chndl < 0)	/* UCLYhndl_for_unrec not defined :-( */
		    chndl = UCLYhndl_for_unspec;	/* always >= 0 */
		if (UCCanTranslateFromTo(chndl, current_char_set)) {
		    chartrans_ok = YES;
		    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_STRUCTURED);
		}
	    }
	    if (chartrans_ok) {
		p_in = HTAnchor_getUCInfoStage(me->node_anchor,
					       UCT_STAGE_PARSER);
		p_out = HTAnchor_setUCInfoStage(me->node_anchor,
						current_char_set,
						UCT_STAGE_HTEXT,
						UCT_SETBY_DEFAULT);
		if (!p_out) {
		    /*
		     * Try again.
		     */
		    p_out = HTAnchor_getUCInfoStage(me->node_anchor,
						    UCT_STAGE_HTEXT);
		}
		if (!strcmp(p_in->MIMEname, "x-transparent")) {
		    HTPassEightBitRaw = TRUE;
		    HTAnchor_setUCInfoStage(me->node_anchor,
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_HTEXT),
					    UCT_STAGE_PARSER,
					    UCT_SETBY_DEFAULT);
		}
		if (!strcmp(p_out->MIMEname, "x-transparent")) {
		    HTPassEightBitRaw = TRUE;
		    HTAnchor_setUCInfoStage(me->node_anchor,
					    HTAnchor_getUCLYhndl(me->node_anchor,
								 UCT_STAGE_PARSER),
					    UCT_STAGE_HTEXT,
					    UCT_SETBY_DEFAULT);
		}
		if ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
		    && (p_in->enc != UCT_ENC_UTF8)
#endif
		    ) {
		    HTCJK = NOCJK;
		    if (!(p_in->codepoints &
			  UCT_CP_SUBSETOF_LAT1) &&
			chndl == current_char_set) {
			HTPassEightBitRaw = TRUE;
		    }
		} else if (p_out->enc == UCT_ENC_CJK) {
		    Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
		}
		LYGetChartransInfo(me);
		/*
		 * Update the chartrans info homologously to a Content-Type
		 * MIME header with a charset parameter.  - FM
		 */
		if (me->UCLYhndl != chndl) {
		    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					    UCT_STAGE_MIME,
					    UCT_SETBY_STRUCTURED);
		    HTAnchor_setUCInfoStage(me->node_anchor, chndl,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_STRUCTURED);
		    me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
							  UCT_STAGE_PARSER);
		    me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor,
							UCT_STAGE_PARSER);
		}
		UCSetTransParams(&me->T,
				 me->inUCLYhndl, me->inUCI,
				 me->outUCLYhndl, me->outUCI);
	    } else {
		/*
		 * Cannot translate.  If according to some heuristic the given
		 * charset and the current display character both are likely to
		 * be like ISO-8859 in structure, pretend we have some kind of
		 * match.
		 */
		BOOL given_is_8859 = (BOOL) (!StrNCmp(cp4, "iso-8859-", 9) &&
					     isdigit(UCH(cp4[9])));
		BOOL given_is_8859like = (BOOL) (given_is_8859
						 || !StrNCmp(cp4, "windows-", 8)
						 || !StrNCmp(cp4, "cp12", 4)
						 || !StrNCmp(cp4, "cp-12", 5));
		BOOL given_and_display_8859like = (BOOL) (given_is_8859like &&
							  (strstr(LYchar_set_names[current_char_set],
								  "ISO-8859") ||
							   strstr(LYchar_set_names[current_char_set],
								  "windows-")));

		if (given_is_8859) {
		    cp1 = &cp4[10];
		    while (*cp1 &&
			   isdigit(UCH((*cp1))))
			cp1++;
		    *cp1 = '\0';
		}
		if (given_and_display_8859like) {
		    StrAllocCopy(me->node_anchor->charset, cp4);
		    HTPassEightBitRaw = TRUE;
		}
		HTAlert(*cp4 ? cp4 : me->node_anchor->charset);

	    }
	    FREE(cp3);

	    if (me->node_anchor->charset) {
		CTRACE((tfp,
			"LYHandleMETA: New charset: %s\n",
			me->node_anchor->charset));
	    }
	}
	/*
	 * Set the kcode element based on the charset.  - FM
	 */
	HText_setKcode(me->text, me->node_anchor->charset, p_in);
    }

    /*
     * Make sure we have META name/value pairs to handle.  - FM
     */
    if (!(http_equiv || name) || !content)
	goto free_META_copies;

    /*
     * Check for a no-cache Pragma
     * or Cache-Control directive. - FM
     */
    if (!strcasecomp(NonNull(http_equiv), "Pragma") ||
	!strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (!strcasecomp(content, "no-cache")) {
	    me->node_anchor->no_cache = TRUE;
	    HText_setNoCache(me->text);
	}

	/*
	 * If we didn't get a Cache-Control MIME header, and the META has one,
	 * convert to lowercase, store it in the anchor element, and if we
	 * haven't yet set no_cache, check whether we should.  - FM
	 */
	if ((!me->node_anchor->cache_control) &&
	    !strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	    LYLowerCase(content);
	    StrAllocCopy(me->node_anchor->cache_control, content);
	    if (me->node_anchor->no_cache == FALSE) {
		cp0 = content;
		while ((cp = strstr(cp0, "no-cache")) != NULL) {
		    cp += 8;
		    while (*cp != '\0' && WHITE(*cp))
			cp++;
		    if (*cp == '\0' || *cp == ';') {
			me->node_anchor->no_cache = TRUE;
			HText_setNoCache(me->text);
			break;
		    }
		    cp0 = cp;
		}
		if (me->node_anchor->no_cache == TRUE)
		    goto free_META_copies;
		cp0 = content;
		while ((cp = strstr(cp0, "max-age")) != NULL) {
		    cp += 7;
		    while (*cp != '\0' && WHITE(*cp))
			cp++;
		    if (*cp == '=') {
			cp++;
			while (*cp != '\0' && WHITE(*cp))
			    cp++;
			if (isdigit(UCH(*cp))) {
			    cp0 = cp;
			    while (isdigit(UCH(*cp)))
				cp++;
			    if (*cp0 == '0' && cp == (cp0 + 1)) {
				me->node_anchor->no_cache = TRUE;
				HText_setNoCache(me->text);
				break;
			    }
			}
		    }
		    cp0 = cp;
		}
	    }
	}

	/*
	 * Check for an Expires directive. - FM
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Expires")) {
	/*
	 * If we didn't get an Expires MIME header, store it in the anchor
	 * element, and if we haven't yet set no_cache, check whether we
	 * should.  Note that we don't accept a Date header via META tags,
	 * because it's likely to be untrustworthy, but do check for a Date
	 * header from a server when making the comparison.  - FM
	 */
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	StrAllocCopy(me->node_anchor->expires, content);
	if (me->node_anchor->no_cache == FALSE) {
	    if (!strcmp(content, "0")) {
		/*
		 * The value is zero, which we treat as an absolute no-cache
		 * directive.  - FM
		 */
		me->node_anchor->no_cache = TRUE;
		HText_setNoCache(me->text);
	    } else if (me->node_anchor->date != NULL) {
		/*
		 * We have a Date header, so check if the value is less than or
		 * equal to that.  - FM
		 */
		if (LYmktime(content, TRUE) <=
		    LYmktime(me->node_anchor->date, TRUE)) {
		    me->node_anchor->no_cache = TRUE;
		    HText_setNoCache(me->text);
		}
	    } else if (LYmktime(content, FALSE) == 0) {
		/*
		 * We don't have a Date header, and the value is in past for
		 * us.  - FM
		 */
		me->node_anchor->no_cache = TRUE;
		HText_setNoCache(me->text);
	    }
	}

	/*
	 * Check for a Refresh directive.  - FM
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Refresh")) {
	char *Seconds = NULL;

	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	LYParseRefreshURL(content, &Seconds, &href);

	if (Seconds) {
	    if (href) {
		/*
		 * We found a URL field, so check it out.  - FM
		 */
		if (!LYLegitimizeHREF(me, &href, TRUE, FALSE)) {
		    /*
		     * The specs require a complete URL, but this is a
		     * Netscapism, so don't expect the author to know that.  -
		     * FM
		     */
		    HTUserMsg(REFRESH_URL_NOT_ABSOLUTE);
		    /*
		     * Use the document's address as the base.  - FM
		     */
		    if (*href != '\0') {
			temp = HTParse(href,
				       me->node_anchor->address, PARSE_ALL);
			StrAllocCopy(href, temp);
			FREE(temp);
		    } else {
			StrAllocCopy(href, me->node_anchor->address);
			HText_setNoCache(me->text);
		    }

		} else {
		    /*
		     * Check whether to fill in localhost.  - FM
		     */
		    LYFillLocalFileURL(&href,
				       (me->inBASE ?
					me->base_href : me->node_anchor->address));
		}

		/*
		 * Set the no_cache flag if the Refresh URL is the same as the
		 * document's address.  - FM
		 */
		if (!strcmp(href, me->node_anchor->address)) {
		    HText_setNoCache(me->text);
		}
	    } else {
		/*
		 * We didn't find a URL field, so use the document's own
		 * address and set the no_cache flag.  - FM
		 */
		StrAllocCopy(href, me->node_anchor->address);
		HText_setNoCache(me->text);
	    }
	    /*
	     * Check for an anchor in http or https URLs.  - FM
	     */
	    cp = NULL;
	    /* id_string seems to be used wrong below if given.
	       not that it matters much.  avoid setting it here. - kw */
	    if (track_internal_links &&
		(StrNCmp(href, "http", 4) == 0) &&
		(cp = StrChr(href, '#')) != NULL) {
		StrAllocCopy(id_string, cp);
		*cp = '\0';
	    }
	    if (me->inA) {
		/*
		 * Ugh!  The META tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
		 */
		if (me->inBoldA == TRUE && me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->inA = FALSE;
		me->CurrentANum = 0;
	    }
	    me->CurrentA = HTAnchor_findChildAndLink
		(
		    me->node_anchor,	/* Parent */
		    id_string,	/* Tag */
		    href,	/* Addresss */
		    (HTLinkType *) 0);	/* Type */
	    if (id_string)
		*cp = '#';
	    FREE(id_string);
	    LYEnsureSingleSpace(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "REFRESH(");
	    HTML_put_string(me, Seconds);
	    HTML_put_string(me, " sec):");
	    FREE(Seconds);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');
	    me->in_word = NO;
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, href);
	    FREE(href);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	    LYEnsureSingleSpace(me);
	}

	/*
	 * Check for a suggested filename via a Content-Disposition with a
	 * filename=name.suffix in it, if we don't already have it via a server
	 * header.  - FM
	 */
    } else if (isEmpty(me->node_anchor->SugFname) &&
	       !strcasecomp((http_equiv ?
			     http_equiv : ""), "Content-Disposition")) {
	cp = content;
	while (*cp != '\0' && strncasecomp(cp, "filename", 8))
	    cp++;
	if (*cp != '\0') {
	    cp = LYSkipBlanks(cp + 8);
	    if (*cp == '=')
		cp++;
	    cp = LYSkipBlanks(cp);
	    if (*cp != '\0') {
		StrAllocCopy(me->node_anchor->SugFname, cp);
		if (*me->node_anchor->SugFname == '"') {
		    if ((cp = StrChr((me->node_anchor->SugFname + 1),
				     '"')) != NULL) {
			*(cp + 1) = '\0';
			HTMIME_TrimDoubleQuotes(me->node_anchor->SugFname);
			if (isEmpty(me->node_anchor->SugFname)) {
			    FREE(me->node_anchor->SugFname);
			}
		    } else {
			FREE(me->node_anchor->SugFname);
		    }
		}
#if defined(UNIX) && !defined(DOSPATH)
		/*
		 * If blanks are not legal for local filenames, replace them
		 * with underscores.
		 */
		if ((cp = me->node_anchor->SugFname) != NULL) {
		    while (*cp != '\0') {
			if (isspace(UCH(*cp)))
			    *cp = '_';
			++cp;
		    }
		}
#endif
	    }
	}
	/*
	 * Check for a Set-Cookie directive.  - AK
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Set-Cookie")) {
	/*
	 * This will need to be updated when Set-Cookie/Set-Cookie2 handling is
	 * finalized.  For now, we'll still assume "historical" cookies in META
	 * directives.  - FM
	 */
	url_type = is_url(me->inBASE ?
			  me->base_href : me->node_anchor->address);
	if (url_type == HTTP_URL_TYPE || url_type == HTTPS_URL_TYPE) {
	    LYSetCookie(content,
			NULL,
			(me->inBASE ?
			 me->base_href : me->node_anchor->address));
	}
    }

    /*
     * Free the copies.  - FM
     */
  free_META_copies:
    FREE(http_equiv);
    FREE(name);
    FREE(content);
    FREE(charset);
}

/*
 *  This function handles P elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if
 *  FALSE, an end tag.	We presently handle start
 *  and end tags identically, but this can lead to
 *  a different number of blank lines between the
 *  current paragraph and subsequent text when a P
 *  end tag is present or not in the markup. - FM
 */
void LYHandlePlike(HTStructured * me, const BOOL *present,
		   STRING2PTR value,
		   char **include GCC_UNUSED,
		   int align_idx,
		   int start)
{
    /*
     * FIG content should be a true block, which like P inherits the current
     * style.  APPLET is like character elements or an ALT attribute, unless
     * its content contains a block element.  If we encounter a P in either's
     * content, we set flags to treat the content as a block - FM
     */
    if (start) {
	if (me->inFIG)
	    me->inFIGwithP = TRUE;

	if (me->inAPPLET)
	    me->inAPPLETwithP = TRUE;
    }

    UPDATE_STYLE;
    if (me->List_Nesting_Level >= 0) {
	/*
	 * We're in a list.  Treat P as an instruction to create one blank
	 * line, if not already present, then fall through to handle
	 * attributes, with the "second line" margins - FM
	 */
	if (me->inP) {
	    if (me->inFIG || me->inAPPLET ||
		me->inCAPTION || me->inCREDIT ||
		me->sp->style->spaceAfter > 0 ||
		(start && me->sp->style->spaceBefore > 0)) {
		LYEnsureDoubleSpace(me);
	    } else {
		LYEnsureSingleSpace(me);
	    }
	}
    } else if (me->sp[0].tag_number == HTML_ADDRESS) {
	/*
	 * We're in an ADDRESS.  Treat P as an instruction to start a newline,
	 * if needed, then fall through to handle attributes - FM
	 */
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
	    HText_appendCharacter(me->text, '\r');
	}
    } else {
	if (start) {
	    if (!(me->inLABEL && !me->inP)) {
		HText_appendParagraph(me->text);
	    }
	} else if (me->sp->style->spaceAfter > 0) {
	    LYEnsureDoubleSpace(me);
	} else {
	    LYEnsureSingleSpace(me);
	}
	me->inLABEL = FALSE;
    }
    me->in_word = NO;

    if (LYoverride_default_alignment(me)) {
	me->sp->style->alignment = LYstyles(me->sp[0].tag_number)->alignment;
    } else if ((me->List_Nesting_Level >= 0 &&
		(me->sp->style->id == ST_DivCenter ||
		 me->sp->style->id == ST_DivLeft ||
		 me->sp->style->id == ST_DivRight)) ||
	       ((me->Division_Level < 0) &&
		(me->sp->style->id == ST_Normal ||
		 me->sp->style->id == ST_Preformatted))) {
	me->sp->style->alignment = HT_LEFT;
    } else {
	me->sp->style->alignment = (short) me->current_default_alignment;
    }

    if (start && align_idx >= 0) {
	if (present && present[align_idx] && value[align_idx]) {
	    if (!strcasecomp(value[align_idx], "center") &&
		!(me->List_Nesting_Level >= 0 && !me->inP))
		me->sp->style->alignment = HT_CENTER;
	    else if (!strcasecomp(value[align_idx], "right") &&
		     !(me->List_Nesting_Level >= 0 && !me->inP))
		me->sp->style->alignment = HT_RIGHT;
	    else if (!strcasecomp(value[align_idx], "left") ||
		     !strcasecomp(value[align_idx], "justify"))
		me->sp->style->alignment = HT_LEFT;
	}

    }

    /*
     * Mark that we are starting a new paragraph and don't have any of its
     * text yet - FM
     */
    me->inP = FALSE;

    return;
}

/*
 *  This function handles SELECT elements in HTML streams.
 *  If start is TRUE it handles a start tag, and if FALSE,
 *  an end tag. - FM
 */
void LYHandleSELECT(HTStructured * me, const BOOL *present,
		    STRING2PTR value,
		    char **include GCC_UNUSED,
		    int start)
{
    int i;

    if (start == TRUE) {
	char *name = NULL;
	BOOLEAN multiple = NO;
	char *size = NULL;

	/*
	 * Initialize the disable attribute.
	 */
	me->select_disabled = FALSE;

	/*
	 * Check for unclosed TEXTAREA.
	 */
	if (me->inTEXTAREA) {
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: Missing TEXTAREA end tag\n");
	    }
	}

	/*
	 * Set to know we are in a select tag.
	 */
	me->inSELECT = TRUE;

	if (!(present && present[HTML_SELECT_NAME] &&
	      non_empty(value[HTML_SELECT_NAME]))) {
	    StrAllocCopy(name, "");
	} else if (StrChr(value[HTML_SELECT_NAME], '&') == NULL) {
	    StrAllocCopy(name, value[HTML_SELECT_NAME]);
	} else {
	    StrAllocCopy(name, value[HTML_SELECT_NAME]);
	    UNESCAPE_FIELDNAME_TO_STD(&name);
	}
	if (present && present[HTML_SELECT_MULTIPLE])
	    multiple = YES;
	if (present && present[HTML_SELECT_DISABLED])
	    me->select_disabled = TRUE;
	if (present && present[HTML_SELECT_SIZE] &&
	    non_empty(value[HTML_SELECT_SIZE])) {
	    /*
	     * Let the size be determined by the number of OPTIONs.  - FM
	     */
	    CTRACE((tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
		    value[HTML_SELECT_SIZE]));
	}

	if (me->inBoldH == TRUE &&
	    (multiple == NO || LYSelectPopups == FALSE)) {
	    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    me->inBoldH = FALSE;
	    me->needBoldH = TRUE;
	}
	if (me->inUnderline == TRUE &&
	    (multiple == NO || LYSelectPopups == FALSE)) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	}

	if ((multiple == NO && LYSelectPopups == TRUE) &&
	    (me->sp[0].tag_number == HTML_PRE || me->inPRE == TRUE ||
	     !me->sp->style->freeFormat) &&
	    HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 7)) {
	    /*
	     * Force a newline when we're using a popup in a PRE block and are
	     * within 7 columns from the right margin.  This will allow for the
	     * '[' popup designator and help avoid a wrap in the underscore
	     * placeholder for the retracted popup entry in the HText
	     * structure.  - FM
	     */
	    HTML_put_character(me, '\n');
	    me->in_word = NO;
	}

	LYCheckForID(me, present, value, (int) HTML_SELECT_ID);

	HText_beginSelect(name, ATTR_CS_IN, multiple, size);
	FREE(name);
	FREE(size);

	me->first_option = TRUE;
    } else {
	/*
	 * Handle end tag.
	 */
	char *ptr;

	/*
	 * Make sure we had a select start tag.
	 */
	if (!me->inSELECT) {
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: Unmatched SELECT end tag\n");
	    }
	    return;
	}

	/*
	 * Set to know that we are no longer in a select tag.
	 */
	me->inSELECT = FALSE;

	/*
	 * Clear the disable attribute.
	 */
	me->select_disabled = FALSE;

	/*
	 * Finish the data off.
	 */
	HTChunkTerminate(&me->option);
	/*
	 * Finish the previous option.
	 */
	ptr = HText_setLastOptionValue(me->text,
				       me->option.data,
				       me->LastOptionValue,
				       LAST_ORDER,
				       me->LastOptionChecked,
				       me->UCLYhndl,
				       ATTR_CS_IN);
	FREE(me->LastOptionValue);

	me->LastOptionChecked = FALSE;

	if (HTCurSelectGroupType == F_CHECKBOX_TYPE ||
	    LYSelectPopups == FALSE) {
	    /*
	     * Start a newline after the last checkbox/button option.
	     */
	    LYEnsureSingleSpace(me);
	} else {
	    /*
	     * Output popup box with the default option to screen, but use
	     * non-breaking spaces for output.
	     */
	    if (ptr &&
		me->sp[0].tag_number == HTML_PRE && strlen(ptr) > 6) {
		/*
		 * The code inadequately handles OPTION fields in PRE tags. 
		 * We'll put up a minimum of 6 characters, and if any more
		 * would exceed the wrap column, we'll ignore them.
		 */
		for (i = 0; i < 6; i++) {
		    if (*ptr == ' ')
			HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		    else
			HText_appendCharacter(me->text, *ptr);
		    ptr++;
		}
	    }
	    for (; non_empty(ptr); ptr++) {
		if (*ptr == ' ')
		    HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		else
		    HText_appendCharacter(me->text, *ptr);
	    }
	    /*
	     * Add end option character.
	     */
	    if (!me->first_option) {
		HText_appendCharacter(me->text, ']');
		HText_setLastChar(me->text, ']');
		me->in_word = YES;
	    }
	}
	HTChunkClear(&me->option);

	if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	}
	if (me->needBoldH == TRUE && me->inBoldH == FALSE) {
	    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    me->inBoldH = TRUE;
	    me->needBoldH = FALSE;
	}
    }
}

/*
 *  This function strips white characters and
 *  generally fixes up attribute values that
 *  were received from the SGML parser and
 *  are to be treated as partial or absolute
 *  URLs. - FM
 */
int LYLegitimizeHREF(HTStructured * me, char **href,
		     int force_slash,
		     int strip_dots)
{
    int url_type = 0;
    char *p = NULL;
    char *pound = NULL;
    const char *Base = NULL;

    if (!me || !href || isEmpty(*href))
	return (url_type);

    if (!LYTrimStartfile(*href)) {
	/*
	 * Collapse spaces in the actual URL, but just protect against tabs or
	 * newlines in the fragment, if present.  This seeks to cope with
	 * atrocities inflicted on the Web by authoring tools such as
	 * Frontpage.  - FM
	 */

	/*  Before working on spaces check if we have any, usually none. */
	p = LYSkipNonBlanks(*href);

	if (*p) {		/* p == first space character */
	    /* no reallocs below, all converted in place */

	    pound = findPoundSelector(*href);

	    if (pound != NULL && pound < p) {
		convert_to_spaces(p, FALSE);	/* done */

	    } else {
		if (pound != NULL)
		    *pound = '\0';	/* mark */

		/*
		 * No blanks really belong in the HREF,
		 * but if it refers to an actual file,
		 * it may actually have blanks in the name.
		 * Try to accommodate. See also HTParse().
		 */
		if (LYRemoveNewlines(p) || StrChr(p, '\t') != 0) {
		    LYRemoveBlanks(p);	/* a compromise... */
		}

		if (pound != NULL) {
		    p = StrChr(p, '\0');
		    *pound = '#';	/* restore */
		    convert_to_spaces(pound, FALSE);
		    if (p < pound)
			strcpy(p, pound);
		}
	    }
	}
    }
    if (**href == '\0')
	return (url_type);

    TRANSLATE_AND_UNESCAPE_TO_STD(href);

    Base = me->inBASE ?
	me->base_href : me->node_anchor->address;

    url_type = is_url(*href);
    if (!url_type && force_slash && **href == '.' &&
	(!strcmp(*href, ".") || !strcmp(*href, "..")) &&
	!isFILE_URL(Base)) {
	/*
	 * The Fielding RFC/ID for resolving partial HREFs says that a slash
	 * should be on the end of the preceding symbolic element for "." and
	 * "..", but all tested browsers only do that for an explicit "./" or
	 * "../", so we'll respect the RFC/ID only if force_slash was TRUE and
	 * it's not a file URL.  - FM
	 */
	StrAllocCat(*href, "/");
    }
    if ((!url_type && LYStripDotDotURLs && strip_dots && **href == '.') &&
	!strncasecomp(Base, "http", 4)) {
	/*
	 * We will be resolving a partial reference versus an http or https
	 * URL, and it has lead dots, which may be retained when resolving via
	 * HTParse(), but the request would fail if the first element of the
	 * resultant path is two dots, because no http or https server accepts
	 * such paths, and the current URL draft, likely to become an RFC, says
	 * that it's optional for the UA to strip them as a form of error
	 * recovery.  So we will, recursively, for http/https URLs, like the
	 * "major market browsers" which made this problem so common on the
	 * Web, but we'll also issue a message about it, such that the bad
	 * partial reference might get corrected by the document provider.  -
	 * FM
	 */
	char *temp = NULL, *path = NULL, *cp;
	const char *str = "";

	temp = HTParse(*href, Base, PARSE_ALL);
	path = HTParse(temp, "", PARSE_PATH + PARSE_PUNCTUATION);
	if (!StrNCmp(path, "/..", 3)) {
	    cp = (path + 3);
	    if (LYIsHtmlSep(*cp) || *cp == '\0') {
		if (Base[4] == 's') {
		    str = "s";
		}
		CTRACE((tfp,
			"LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			*href, str));
		CTRACE((tfp, "                  Stripping lead dots.\n"));
		if (!me->inBadHREF) {
		    HTUserMsg(BAD_PARTIAL_REFERENCE);
		    me->inBadHREF = TRUE;
		}
	    }
	    if (*cp == '\0') {
		StrAllocCopy(*href, "/");
	    } else if (LYIsHtmlSep(*cp)) {
		while (!StrNCmp(cp, "/..", 3)) {
		    if (*(cp + 3) == '/') {
			cp += 3;
			continue;
		    } else if (*(cp + 3) == '\0') {
			*(cp + 1) = '\0';
			*(cp + 2) = '\0';
		    }
		    break;
		}
		StrAllocCopy(*href, cp);
	    }
	}
	FREE(temp);
	FREE(path);
    }
    return (url_type);
}

/*
 *  This function checks for a Content-Base header,
 *  and if not present, a Content-Location header
 *  which is an absolute URL, and sets the BASE
 *  accordingly.  If set, it will be replaced by
 *  any BASE tag in the HTML stream, itself. - FM
 */
void LYCheckForContentBase(HTStructured * me)
{
    char *cp = NULL;
    BOOL present[HTML_BASE_ATTRIBUTES];
    const char *value[HTML_BASE_ATTRIBUTES];
    int i;

    if (!(me && me->node_anchor))
	return;

    if (me->node_anchor->content_base != NULL) {
	/*
	 * We have a Content-Base value.  Use it if it's non-zero length.  - FM
	 */
	if (*me->node_anchor->content_base == '\0')
	    return;
	StrAllocCopy(cp, me->node_anchor->content_base);
	LYRemoveBlanks(cp);
    } else if (me->node_anchor->content_location != NULL) {
	/*
	 * We didn't have a Content-Base value, but do have a Content-Location
	 * value.  Use it if it's an absolute URL.  - FM
	 */
	if (*me->node_anchor->content_location == '\0')
	    return;
	StrAllocCopy(cp, me->node_anchor->content_location);
	LYRemoveBlanks(cp);
	if (!is_url(cp)) {
	    FREE(cp);
	    return;
	}
    } else {
	/*
	 * We had neither a Content-Base nor Content-Location value.  - FM
	 */
	return;
    }

    /*
     * If we collapsed to a zero-length value, ignore it.  - FM
     */
    if (*cp == '\0') {
	FREE(cp);
	return;
    }

    /*
     * Pass the value to HTML_start_element as the HREF of a BASE tag.  - FM
     */
    for (i = 0; i < HTML_BASE_ATTRIBUTES; i++)
	present[i] = NO;
    present[HTML_BASE_HREF] = YES;
    value[HTML_BASE_HREF] = (const char *) cp;
    (*me->isa->start_element) (me, HTML_BASE, present, value,
			       0, 0);
    FREE(cp);
}

/*
 *  This function creates NAMEd Anchors if a non-zero-length NAME
 *  or ID attribute was present in the tag. - FM
 */
void LYCheckForID(HTStructured * me, const BOOL *present,
		  STRING2PTR value,
		  int attribute)
{
    HTChildAnchor *ID_A = NULL;
    char *temp = NULL;

    if (!(me && me->text))
	return;

    if (present && present[attribute]
	&& non_empty(value[attribute])) {
	/*
	 * Translate any named or numeric character references.  - FM
	 */
	StrAllocCopy(temp, value[attribute]);
	LYUCTranslateHTMLString(&temp, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_URL);

	/*
	 * Create the link if we still have a non-zero-length string.  - FM
	 */
	if ((temp[0] != '\0') &&
	    (ID_A = HTAnchor_findChildAndLink
	     (
		 me->node_anchor,	/* Parent */
		 temp,		/* Tag */
		 NULL,		/* Addresss */
		 (HTLinkType *) 0))) {	/* Type */
	    HText_beginAnchor(me->text, me->inUnderline, ID_A);
	    HText_endAnchor(me->text, 0);
	}
	FREE(temp);
    }
}

/*
 *  This function creates a NAMEd Anchor for the ID string
 *  passed to it directly as an argument.  It assumes the
 *  does not need checking for character references. - FM
 */
void LYHandleID(HTStructured * me, const char *id)
{
    HTChildAnchor *ID_A = NULL;

    if (!(me && me->text) ||
	isEmpty(id))
	return;

    /*
     * Create the link if we still have a non-zero-length string.  - FM
     */
    if ((ID_A = HTAnchor_findChildAndLink
	 (
	     me->node_anchor,	/* Parent */
	     id,		/* Tag */
	     NULL,		/* Addresss */
	     (HTLinkType *) 0)) != NULL) {	/* Type */
	HText_beginAnchor(me->text, me->inUnderline, ID_A);
	HText_endAnchor(me->text, 0);
    }
}

/*
 *  This function checks whether we want to override
 *  the current default alignment for paragraphs and
 *  instead use that specified in the element's style
 *  sheet. - FM
 */
BOOLEAN LYoverride_default_alignment(HTStructured * me)
{
    if (!me)
	return NO;

    switch (me->sp[0].tag_number) {
    case HTML_BLOCKQUOTE:
    case HTML_BQ:
    case HTML_NOTE:
    case HTML_FN:
    case HTML_ADDRESS:
	me->sp->style->alignment = HT_LEFT;
	return YES;

    default:
	break;
    }
    return NO;
}

/*
 *  This function inserts newlines if needed to create double spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureDoubleSpace(HTStructured * me)
{
    if (!me || !me->text)
	return;

    if (!HText_LastLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	HText_appendCharacter(me->text, '\r');
	HText_appendCharacter(me->text, '\r');
    } else if (!HText_PreviousLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	HText_appendCharacter(me->text, '\r');
    } else if (me->List_Nesting_Level >= 0) {
	HText_NegateLineOne(me->text);
    }
    me->in_word = NO;
    return;
}

/*
 *  This function inserts a newline if needed to create single spacing,
 *  and sets the left margin for subsequent text to the second line
 *  indentation of the current style. - FM
 */
void LYEnsureSingleSpace(HTStructured * me)
{
    if (!me || !me->text)
	return;

    if (!HText_LastLineEmpty(me->text, FALSE)) {
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	HText_appendCharacter(me->text, '\r');
    } else if (me->List_Nesting_Level >= 0) {
	HText_NegateLineOne(me->text);
    }
    me->in_word = NO;
    return;
}

/*
 *  This function resets paragraph alignments for block
 *  elements which do not have a defined style sheet. - FM
 */
void LYResetParagraphAlignment(HTStructured * me)
{
    if (!me)
	return;

    if (me->List_Nesting_Level >= 0 ||
	((me->Division_Level < 0) &&
	 (me->sp->style->id == ST_Normal ||
	  me->sp->style->id == ST_Preformatted))) {
	me->sp->style->alignment = HT_LEFT;
    } else {
	me->sp->style->alignment = (short) me->current_default_alignment;
    }
    return;
}

/*
 *  This example function checks whether the given anchor has
 *  an address with a file scheme, and if so, loads it into the
 *  the SGML parser's context->url element, which was passed as
 *  the second argument.  The handle_comment() calling function in
 *  SGML.c then calls LYDoCSI() in LYUtils.c to insert HTML markup
 *  into the corresponding stream, homologously to an SSI by an
 *  HTTP server. - FM
 *
 *  For functions similar to this but which depend on details of
 *  the HTML handler's internal data, the calling interface should
 *  be changed, and functions in SGML.c would have to make sure not
 *  to call such functions inappropriately (e.g., calling a function
 *  specific to the Lynx_HTML_Handler when SGML.c output goes to
 *  some other HTStructured object like in HTMLGen.c), or the new
 *  functions could be added to the SGML.h interface.
 */
BOOLEAN LYCheckForCSI(HTParentAnchor *anchor,
		      char **url)
{
    if (!(anchor && anchor->address))
	return FALSE;

    if (!isFILE_URL(anchor->address))
	return FALSE;

    if (!LYisLocalHost(anchor->address))
	return FALSE;

    StrAllocCopy(*url, anchor->address);
    return TRUE;
}

/*
 *  This function is called from the SGML parser to look at comments
 *  and see whether we should collect some info from them.  Currently
 *  it only looks for comments with Message-Id and Subject info, in the
 *  exact form generated by MHonArc for archived mailing list.  If found,
 *  the info is stored in the document's HTParentAnchor.  It can later be
 *  used for generating a mail response.
 *
 *  We are extra picky here because there isn't any official definition
 *  for these kinds of comments - we might (and still can) misinterpret
 *  arbitrary comments as something they aren't.
 *
 *  If something doesn't look right, for example invalid characters, the
 *  strings are not stored.  Mail responses will use something else as
 *  the subject, probably the document URL, and will not have an
 *  In-Reply-To header.
 *
 *  All this is a hack - to do this the right way, mailing list archivers
 *  would have to agree on some better mechanism to make this kind of info
 *  from original mail headers available, for example using LINK.  - kw
 */
BOOLEAN LYCommentHacks(HTParentAnchor *anchor,
		       const char *comment)
{
    const char *cp;
    size_t len;

    if (comment == NULL)
	return FALSE;

    if (!(anchor && anchor->address))
	return FALSE;

    if (StrNCmp(comment, "!--X-Message-Id: ", 17) == 0) {
	char *messageid = NULL;
	char *p;

	for (cp = comment + 17; *cp; cp++) {
	    if (UCH(*cp) >= 127 || !isgraph(UCH(*cp))) {
		break;
	    }
	}
	if (strcmp(cp, " --")) {
	    return FALSE;
	}
	cp = comment + 17;
	StrAllocCopy(messageid, cp);
	/* This should be ok - message-id should only contain 7-bit ASCII */
	if (!LYUCTranslateHTMLString(&messageid, 0, 0, NO, NO, YES, st_URL))
	    return FALSE;
	for (p = messageid; *p; p++) {
	    if (UCH(*p) >= 127 || !isgraph(UCH(*p))) {
		break;
	    }
	}
	if (strcmp(p, " --")) {
	    FREE(messageid);
	    return FALSE;
	}
	if ((p = StrChr(messageid, '@@')) == NULL || p[1] == '\0') {
	    FREE(messageid);
	    return FALSE;
	}
	p = messageid;
	if ((len = strlen(p)) >= 8 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
	} else {
	    FREE(messageid);
	    return FALSE;
	}
	if (HTAnchor_setMessageID(anchor, messageid)) {
	    FREE(messageid);
	    return TRUE;
	} else {
	    FREE(messageid);
	    return FALSE;
	}
    }
    if (StrNCmp(comment, "!--X-Subject: ", 14) == 0) {
	char *subject = NULL;
	char *p;

	for (cp = comment + 14; *cp; cp++) {
	    if (UCH(*cp) >= 127 || !isprint(UCH(*cp))) {
		return FALSE;
	    }
	}
	cp = comment + 14;
	StrAllocCopy(subject, cp);
	/* @@@@@@
	 * This may not be the right thing for the subject - but mail
	 * subjects shouldn't contain 8-bit characters in raw form anyway.
	 * We have to unescape character entities, since that's what MHonArc
	 * seems to generate.  But if after that there are 8-bit characters
	 * the string is rejected.  We would probably not know correctly
	 * what charset to assume anyway - the mail sender's can differ from
	 * the archive's.  And the code for sending mail cannot deal well
	 * with 8-bit characters - we should not put them in the Subject
	 * header in raw form, but don't have MIME encoding implemented.
	 * Someone may want to do more about this...  - kw
	 */
	if (!LYUCTranslateHTMLString(&subject, 0, 0, NO, YES, NO, st_HTML))
	    return FALSE;
	for (p = subject; *p; p++) {
	    if (UCH(*p) >= 127 || !isprint(UCH(*p))) {
		FREE(subject);
		return FALSE;
	    }
	}
	p = subject;
	if ((len = strlen(p)) >= 4 && !strcmp(&p[len - 3], " --")) {
	    p[len - 3] = '\0';
	} else {
	    FREE(subject);
	    return FALSE;
	}
	if (HTAnchor_setSubject(anchor, subject)) {
	    FREE(subject);
	    return TRUE;
	} else {
	    FREE(subject);
	    return FALSE;
	}
    }

    return FALSE;
}

    /*
     * Create the Title with any left-angle-brackets converted to &lt; entities
     * and any ampersands converted to &amp; entities.  - FM
     *
     * Convert 8-bit letters to &#xUUUU to avoid dependencies from display
     * character set which may need changing.  Do NOT convert any 8-bit chars
     * if we have CJK display.  - LP
     */
void LYformTitle(char **dst,
		 const char *src)
{
    if (HTCJK == JAPANESE) {
	char *tmp_buffer = NULL;

	if ((tmp_buffer = (char *) malloc(strlen(src) + 1)) == 0)
	    outofmem(__FILE__, "LYformTitle");

	assert(tmp_buffer != NULL);

	switch (kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
	case EUC:
	    TO_EUC((const unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	case SJIS:
	    TO_SJIS((const unsigned char *) src, (unsigned char *) tmp_buffer);
	    break;
	default:
	    CTRACE((tfp, "\nLYformTitle: kanji_code is an unexpected value."));
	    strcpy(tmp_buffer, src);
	    break;
	}
	StrAllocCopy(*dst, tmp_buffer);
	FREE(tmp_buffer);
    } else {
	StrAllocCopy(*dst, src);
    }
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYCharUtils.c,v 1.102 2009/06/23 19:44:06 tom Exp $
d49 12
d62 12
a73 10
 *  This function converts any ampersands in allocated
 *  strings to "&amp;".  If isTITLE is TRUE, it also
 *  converts any angle-brackets to "&lt;" or "&gt;". - FM
 */
void LYEntify(char **str,
	      BOOLEAN isTITLE)
{
    char *p = *str;
    char *q = NULL, *cp = NULL;
    int amps = 0, lts = 0, gts = 0;
d87 6
a92 2
    if (isEmpty(p))
	return;
d94 1
a94 7
    /*
     * Count the ampersands.  - FM
     */
    while ((*p != '\0') && (q = strchr(p, '&')) != NULL) {
	amps++;
	p = (q + 1);
    }
d96 5
a100 10
    /*
     * Count the left-angle-brackets, if needed.  - FM
     */
    if (isTITLE == TRUE) {
	p = *str;
	while ((*p != '\0') && (q = strchr(p, '<')) != NULL) {
	    lts++;
	    p = (q + 1);
	}
    }
d102 2
a103 10
    /*
     * Count the right-angle-brackets, if needed.  - FM
     */
    if (isTITLE == TRUE) {
	p = *str;
	while ((*p != '\0') && (q = strchr(p, '>')) != NULL) {
	    gts++;
	    p = (q + 1);
	}
    }
d105 11
a115 5
    /*
     * Check whether we need to convert anything.  - FM
     */
    if (amps == 0 && lts == 0 && gts == 0)
	return;
d117 10
a126 21
    /*
     * Allocate space and convert.  - FM
     */
    q = typecallocn(char,
		    (strlen(*str)
		     + (unsigned)(4 * amps)
		     + (unsigned)(3 * lts)
		     + (unsigned)(3 * gts) + 1));
    if ((cp = q) == NULL)
	outofmem(__FILE__, "LYEntify");
    for (p = *str; *p; p++) {
#ifdef CJK_EX
	if (IS_CJK_TTY) {
	    switch (state) {
	    case S_text:
		if (*p == '\033') {
		    state = S_esc;
		    *q++ = *p;
		    continue;
		}
		break;
d128 10
a137 14
	    case S_esc:
		if (*p == '$') {
		    state = S_dollar;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}
d139 8
a146 14
	    case S_dollar:
		if (*p == '@@' || *p == 'B' || *p == 'A') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else if (*p == '(') {
		    state = S_dollar_paren;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}
d148 10
a157 22
	    case S_dollar_paren:
		if (*p == 'C') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		} else {
		    state = S_text;
		    *q++ = *p;
		    continue;
		}

	    case S_paren:
		if (*p == 'B' || *p == 'J' || *p == 'T') {
		    state = S_text;
		    *q++ = *p;
		    continue;
		} else if (*p == 'I') {
		    state = S_nonascii_text;
		    *q++ = *p;
		    continue;
		}
		/* FALLTHRU */
d159 5
a163 5
	    case S_nonascii_text:
		if (*p == '\033')
		    state = S_esc;
		*q++ = *p;
		continue;
d165 43
a207 10
	    default:
		break;
	    }
	    if (*(p + 1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p + 1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p + 1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p + 1))))) {
		*q++ = *p++;
		*q++ = *p;
		continue;
d209 3
a211 20
	}
#endif
	if (*p == '&') {
	    *q++ = '&';
	    *q++ = 'a';
	    *q++ = 'm';
	    *q++ = 'p';
	    *q++ = ';';
	} else if (isTITLE && *p == '<') {
	    *q++ = '&';
	    *q++ = 'l';
	    *q++ = 't';
	    *q++ = ';';
	} else if (isTITLE && *p == '>') {
	    *q++ = '&';
	    *q++ = 'g';
	    *q++ = 't';
	    *q++ = ';';
	} else {
	    *q++ = *p;
a213 3
    *q = '\0';
    FREE(*str);
    *str = cp;
d226 1
a226 1
    if (IS_CJK_TTY && strchr(source, '\033') != 0) {
d340 1
a340 1
    if (strncmp(str, "<!--", 4))
d355 1
a355 1
    if ((cp1 = strchr(cp, '>')) == NULL)
d449 1
a449 1
    if (!strcmp(*href, "//") || !strncmp(*href, "///", 3)) {
d461 1
a461 1
	} else if (!strncmp(*href, "file:///", 8)) {
d464 1
a464 1
	} else if (!strncmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href + 6))) {
d480 1
a480 1
    if (!strncmp(*href, "file://localhost/", 17)
d511 1
a511 1
	if (strchr(temp2, '%') != NULL || strchr(temp2, '#') != NULL) {
d532 19
a729 4
	while (Arabic >= 500) {
	    strcat(OLstring, "C");
	    Arabic -= 10;
	}
a749 4
	while (Arabic >= 50) {
	    strcat(OLstring, "X");
	    Arabic -= 10;
	}
a855 4
	while (Arabic >= 500) {
	    strcat(OLstring, "c");
	    Arabic -= 10;
	}
a875 4
	while (Arabic >= 50) {
	    strcat(OLstring, "x");
	    Arabic -= 10;
	}
a973 53
/*
 * Given an UCS character code, will fill buffer passed in as q with the code's
 * UTF-8 encoding.
 * If terminate = YES, terminates string on success and returns pointer
 *		       to beginning.
 * If terminate = NO,	does not terminate string, and returns pointer
 *		       next char after the UTF-8 put into buffer.
 * On failure, including invalid code or 7-bit code, returns NULL.
 */
static char *UCPutUtf8ToBuffer(char *q, UCode_t code, BOOL terminate)
{
    char *q_in = q;

    if (!q)
	return NULL;
    if (code > 127 && code < 0x7fffffffL) {
	if (code < 0x800L) {
	    *q++ = (char) (0xc0 | (code >> 6));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else if (code < 0x10000L) {
	    *q++ = (char) (0xe0 | (code >> 12));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else if (code < 0x200000L) {
	    *q++ = (char) (0xf0 | (code >> 18));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else if (code < 0x4000000L) {
	    *q++ = (char) (0xf8 | (code >> 24));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	} else {
	    *q++ = (char) (0xfc | (code >> 30));
	    *q++ = (char) (0x80 | (0x3f & (code >> 24)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 18)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 12)));
	    *q++ = (char) (0x80 | (0x3f & (code >> 6)));
	    *q++ = (char) (0x80 | (0x3f & (code)));
	}
    } else {
	return NULL;
    }
    if (terminate) {
	*q = '\0';
	return q_in;
    } else {
	return q;
    }
}

d1061 5
a1065 5
				BOOLEAN do_ent,
				BOOL use_lynx_specials,
				BOOLEAN plain_space,
				BOOLEAN hidden,
				BOOL Back,
a1077 1
    unsigned long lcode;
a1117 1
#ifdef CONV_JISX0201KANA_JISX0208KANA
a1119 1
#endif
d1124 1
a1124 1
    if (!str || isEmpty(*str))
d1155 1
a1155 1
    if (do_ent && hidden && (stype != st_URL) && (strchr(*str, '&') == NULL))
d1202 1
a1202 1
		if (q != qs) HTChunkPutb(CHUNK, qs, q-qs); \
d1207 1
a1207 1
		HTChunkPutb(CHUNK, qs, q-qs); \
d1231 1
a1231 2
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    if (0xA1 <= code && code <= 0xDF) {
a1238 1
#endif
d1517 4
a1520 4
	    if ((((what == P_hex)
		  ? sscanf(cp, "%lx", &lcode)
		  : sscanf(cp, "%lu", &lcode)) != 1) ||
		lcode > 0x7fffffffL) {
a1522 3
	    } else {
		code = LYcp1252ToUnicode(lcode);
		state = S_check_uni;
d1622 4
a1625 4
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						cs_to,
						0) >= 0)) {
d1658 2
a1659 1
		CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
d1732 2
a1733 1
		sprintf(replace_buf, "U%.2lX", code);
d1779 1
a1779 1
		UCPutUtf8ToBuffer(replace_buf, code, YES);
d1863 1
a1863 1
	HTChunkPutb(CHUNK, qs, q - qs + 1);	/* also terminates */
d1885 3
a1887 3
			     BOOL use_lynx_specials,
			     BOOLEAN plain_space,
			     BOOLEAN hidden,
d1904 1
a1904 1
			       BOOLEAN plain_space)
d1926 1
a1926 1
	if ((string = strchr(string, ';')) == NULL)
d1976 1
a1976 1
	StrnAllocCopy(Seconds, cp, cp1 - cp);
d1990 1
a1990 1
		  const char **value,
d1993 1
a1993 1
    char *http_equiv = NULL, *name = NULL, *content = NULL;
d2043 10
d2054 1
a2054 1
	    "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
d2057 2
a2058 1
	    NONNULL(content)));
d2061 2
a2062 1
     * Make sure we have META name/value pairs to handle.  - FM
d2064 5
a2068 2
    if (!(http_equiv || name) || !content)
	goto free_META_copies;
d2070 5
a2074 20
    /*
     * Check for a no-cache Pragma
     * or Cache-Control directive. - FM
     */
    if (!strcasecomp(NonNull(http_equiv), "Pragma") ||
	!strcasecomp(NonNull(http_equiv), "Cache-Control")) {
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	if (!strcasecomp(content, "no-cache")) {
	    me->node_anchor->no_cache = TRUE;
	    HText_setNoCache(me->text);
	}

	/*
	 * If we didn't get a Cache-Control MIME header, and the META has one,
	 * convert to lowercase, store it in the anchor element, and if we
	 * haven't yet set no_cache, check whether we should.  - FM
	 */
	if ((!me->node_anchor->cache_control) &&
	    !strcasecomp(NonNull(http_equiv), "Cache-Control")) {
a2075 39
	    StrAllocCopy(me->node_anchor->cache_control, content);
	    if (me->node_anchor->no_cache == FALSE) {
		cp0 = content;
		while ((cp = strstr(cp0, "no-cache")) != NULL) {
		    cp += 8;
		    while (*cp != '\0' && WHITE(*cp))
			cp++;
		    if (*cp == '\0' || *cp == ';') {
			me->node_anchor->no_cache = TRUE;
			HText_setNoCache(me->text);
			break;
		    }
		    cp0 = cp;
		}
		if (me->node_anchor->no_cache == TRUE)
		    goto free_META_copies;
		cp0 = content;
		while ((cp = strstr(cp0, "max-age")) != NULL) {
		    cp += 7;
		    while (*cp != '\0' && WHITE(*cp))
			cp++;
		    if (*cp == '=') {
			cp++;
			while (*cp != '\0' && WHITE(*cp))
			    cp++;
			if (isdigit(UCH(*cp))) {
			    cp0 = cp;
			    while (isdigit(UCH(*cp)))
				cp++;
			    if (*cp0 == '0' && cp == (cp0 + 1)) {
				me->node_anchor->no_cache = TRUE;
				HText_setNoCache(me->text);
				break;
			    }
			}
		    }
		    cp0 = cp;
		}
	    }
d2078 2
a2079 56
	/*
	 * Check for an Expires directive. - FM
	 */
    } else if (!strcasecomp(NonNull(http_equiv), "Expires")) {
	/*
	 * If we didn't get an Expires MIME header, store it in the anchor
	 * element, and if we haven't yet set no_cache, check whether we
	 * should.  Note that we don't accept a Date header via META tags,
	 * because it's likely to be untrustworthy, but do check for a Date
	 * header from a server when making the comparison.  - FM
	 */
	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	StrAllocCopy(me->node_anchor->expires, content);
	if (me->node_anchor->no_cache == FALSE) {
	    if (!strcmp(content, "0")) {
		/*
		 * The value is zero, which we treat as an absolute no-cache
		 * directive.  - FM
		 */
		me->node_anchor->no_cache = TRUE;
		HText_setNoCache(me->text);
	    } else if (me->node_anchor->date != NULL) {
		/*
		 * We have a Date header, so check if the value is less than or
		 * equal to that.  - FM
		 */
		if (LYmktime(content, TRUE) <=
		    LYmktime(me->node_anchor->date, TRUE)) {
		    me->node_anchor->no_cache = TRUE;
		    HText_setNoCache(me->text);
		}
	    } else if (LYmktime(content, FALSE) == 0) {
		/*
		 * We don't have a Date header, and the value is in past for
		 * us.  - FM
		 */
		me->node_anchor->no_cache = TRUE;
		HText_setNoCache(me->text);
	    }
	}

	/*
	 * Check for a text/html Content-Type with a charset directive, if we
	 * didn't already set the charset via a server's header.  - AAC & FM
	 */
    } else if (isEmpty(me->node_anchor->charset) &&
	       !strcasecomp(NonNull(http_equiv), "Content-Type")) {
	LYUCcharset *p_in = NULL;
	LYUCcharset *p_out = NULL;

	LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset,
				NO, NO, YES, st_other);
	LYLowerCase(content);

	if ((cp1 = strstr(content, "charset")) != NULL) {
d2084 2
a2085 1
	    cp1 += 7;
d2212 1
a2212 1
		BOOL given_is_8859 = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
d2215 3
a2217 3
						 || !strncmp(cp4, "windows-", 8)
						 || !strncmp(cp4, "cp12", 4)
						 || !strncmp(cp4, "cp-12", 5));
d2250 111
d2377 1
a2377 1
		if (!(url_type = LYLegitimizeHREF(me, &href, TRUE, FALSE))) {
a2424 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d2427 3
a2429 2
	    if ((strncmp(href, "http", 4) == 0) &&
		(cp = strchr(href, '#')) != NULL) {
a2432 1
#endif
d2496 1
a2496 1
		    if ((cp = strchr((me->node_anchor->SugFname + 1),
d2548 1
d2561 1
a2561 1
		   const char **value,
d2564 1
a2564 1
		   BOOL start)
d2566 16
a2581 1
    if (TRUE) {
d2583 3
a2585 5
	 * FIG content should be a true block, which like P inherits the
	 * current style.  APPLET is like character elements or an ALT
	 * attribute, unless it content contains a block element.  If we
	 * encounter a P in either's content, we set flags to treat the content
	 * as a block.  - FM
d2587 5
a2591 41
	if (start) {
	    if (me->inFIG)
		me->inFIGwithP = TRUE;

	    if (me->inAPPLET)
		me->inAPPLETwithP = TRUE;
	}

	UPDATE_STYLE;
	if (me->List_Nesting_Level >= 0) {
	    /*
	     * We're in a list.  Treat P as an instruction to create one blank
	     * line, if not already present, then fall through to handle
	     * attributes, with the "second line" margins.  - FM
	     */
	    if (me->inP) {
		if (me->inFIG || me->inAPPLET ||
		    me->inCAPTION || me->inCREDIT ||
		    me->sp->style->spaceAfter > 0 ||
		    (start && me->sp->style->spaceBefore > 0)) {
		    LYEnsureDoubleSpace(me);
		} else {
		    LYEnsureSingleSpace(me);
		}
	    }
	} else if (me->sp[0].tag_number == HTML_ADDRESS) {
	    /*
	     * We're in an ADDRESS.  Treat P as an instruction to start a
	     * newline, if needed, then fall through to handle attributes.  -
	     * FM
	     */
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_appendCharacter(me->text, '\r');
	    }
	} else {
	    if (start) {
		if (!(me->inLABEL && !me->inP)) {
		    HText_appendParagraph(me->text);
		}
	    } else if (me->sp->style->spaceAfter > 0) {
a2595 1
	    me->inLABEL = FALSE;
d2597 16
a2612 12
	me->in_word = NO;

	if (LYoverride_default_alignment(me)) {
	    me->sp->style->alignment = LYstyles(me->sp[0].tag_number)->alignment;
	} else if ((me->List_Nesting_Level >= 0 &&
		    (me->sp->style->id == ST_DivCenter ||
		     me->sp->style->id == ST_DivLeft ||
		     me->sp->style->id == ST_DivRight)) ||
		   ((me->Division_Level < 0) &&
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
d2614 1
a2614 1
	    me->sp->style->alignment = (short) me->current_default_alignment;
d2616 3
d2620 13
a2632 12
	if (start) {
	    if (present && present[align_idx] && value[align_idx]) {
		if (!strcasecomp(value[align_idx], "center") &&
		    !(me->List_Nesting_Level >= 0 && !me->inP))
		    me->sp->style->alignment = HT_CENTER;
		else if (!strcasecomp(value[align_idx], "right") &&
			 !(me->List_Nesting_Level >= 0 && !me->inP))
		    me->sp->style->alignment = HT_RIGHT;
		else if (!strcasecomp(value[align_idx], "left") ||
			 !strcasecomp(value[align_idx], "justify"))
		    me->sp->style->alignment = HT_LEFT;
	    }
d2634 11
a2646 5
	/*
	 * Mark that we are starting a new paragraph and don't have any of it's
	 * text yet.  - FM
	 */
	me->inP = FALSE;
d2649 6
d2664 1
a2664 1
		    const char **value,
d2666 1
a2666 1
		    BOOL start)
d2697 1
a2697 1
	} else if (strchr(value[HTML_SELECT_NAME], '&') == NULL) {
d2857 2
a2858 2
		     BOOL force_slash,
		     BOOL strip_dots)
d2897 1
a2897 1
		if (LYRemoveNewlines(p) || strchr(p, '\t') != 0) {
d2902 1
a2902 1
		    p = strchr(p, '\0');
d2952 1
a2952 1
	if (!strncmp(path, "/..", 3)) {
d2970 1
a2970 1
		while (!strncmp(cp, "/..", 3)) {
d3059 1
a3059 1
		  const char **value,
d3268 1
a3268 1
    const char *cp = comment;
d3277 1
a3277 1
    if (strncmp(comment, "!--X-Message-Id: ", 17) == 0) {
d3303 1
a3303 1
	if ((p = strchr(messageid, '@@')) == NULL || p[1] == '\0') {
d3322 1
a3322 1
    if (strncmp(comment, "!--X-Subject: ", 14) == 0) {
d3388 3
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d116 4
a119 1
		    (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
d124 1
a124 1
	if (HTCJK != NOCJK) {
d232 56
d323 1
a323 1
    i = strlen(str) - 1;
d1143 1
a1143 1
    long int lcode;
d1206 1
a1206 1
    if ((HTCJK != NOCJK)
d1313 1
a1313 1
		if ((HTCJK != NOCJK && !hidden) || stype != st_HTML) {
d1394 1
a1394 1
		if ((HTCJK != NOCJK && !hidden) || stype != st_HTML) {
d1587 4
a1590 3
	    if ((((what == P_hex) ? sscanf(cp, "%lx", &lcode) :
		  sscanf(cp, "%ld", &lcode)) != 1) ||
		lcode > 0x7fffffffL || lcode < 0) {
d1594 1
a1594 133
		code = lcode;
		if ((code == 1) ||
		    (code > 127 && code < 156)) {
		    /*
		     * Assume these are Microsoft code points, inflicted on
		     * us by FrontPage.  - FM
		     *
		     * MS FrontPage uses syntax like &#153; in 128-159
		     * range and doesn't follow Unicode standards for this
		     * area.  Windows-1252 codepoints are assumed here.
		     */
		    switch (code) {
		    case 1:
			/*
			 * WHITE SMILING FACE
			 */
			code = 0x263a;
			break;
		    case 128:
			/*
			 * EURO currency sign
			 */
			code = 0x20ac;
			break;
		    case 130:
			/*
			 * SINGLE LOW-9 QUOTATION MARK (sbquo)
			 */
			code = 0x201a;
			break;
		    case 132:
			/*
			 * DOUBLE LOW-9 QUOTATION MARK (bdquo)
			 */
			code = 0x201e;
			break;
		    case 133:
			/*
			 * HORIZONTAL ELLIPSIS (hellip)
			 */
			code = 0x2026;
			break;
		    case 134:
			/*
			 * DAGGER (dagger)
			 */
			code = 0x2020;
			break;
		    case 135:
			/*
			 * DOUBLE DAGGER (Dagger)
			 */
			code = 0x2021;
			break;
		    case 137:
			/*
			 * PER MILLE SIGN (permil)
			 */
			code = 0x2030;
			break;
		    case 139:
			/*
			 * SINGLE LEFT-POINTING ANGLE QUOTATION MARK (lsaquo)
			 */
			code = 0x2039;
			break;
		    case 145:
			/*
			 * LEFT SINGLE QUOTATION MARK (lsquo)
			 */
			code = 0x2018;
			break;
		    case 146:
			/*
			 * RIGHT SINGLE QUOTATION MARK (rsquo)
			 */
			code = 0x2019;
			break;
		    case 147:
			/*
			 * LEFT DOUBLE QUOTATION MARK (ldquo)
			 */
			code = 0x201c;
			break;
		    case 148:
			/*
			 * RIGHT DOUBLE QUOTATION MARK (rdquo)
			 */
			code = 0x201d;
			break;
		    case 149:
			/*
			 * BULLET (bull)
			 */
			code = 0x2022;
			break;
		    case 150:
			/*
			 * EN DASH (ndash)
			 */
			code = 0x2013;
			break;
		    case 151:
			/*
			 * EM DASH (mdash)
			 */
			code = 0x2014;
			break;
		    case 152:
			/*
			 * SMALL TILDE (tilde)
			 */
			code = 0x02dc;
			break;
		    case 153:
			/*
			 * TRADE MARK SIGN (trade)
			 */
			code = 0x2122;
			break;
		    case 155:
			/*
			 * SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (rsaquo)
			 */
			code = 0x203a;
			break;
		    default:
			/*
			 * Do not attempt a conversion to valid Unicode values.
			 */
			break;
		    }
		}
d1608 1
a1608 1
		 HTCJK == NOCJK) ||
d1610 1
a1610 1
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
d2004 1
a2004 1
    } while (strncasecomp(string, name, len) != 0);
d2006 1
a2006 1
    while (*string != '\0' && (UCH(isspace(*string)) || *string == '=')) {
d2116 3
a2118 3
	    (http_equiv ? http_equiv : "NULL"),
	    (name ? name : "NULL"),
	    (content ? content : "NULL")));
d2420 2
a2736 20
	 * Make sure we're in a form.
	 */
	if (!me->inFORM) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n"));

	    /*
	     * We should have covered all crash possibilities with the current
	     * TagSoup parser, so we'll allow it because some people with other
	     * browsers use SELECT for "information" popups, outside of FORM
	     * blocks, though no Lynx user would do anything that awful, right? 
	     * - FM
	     */
	       /***
	    return;
		***/
	}

	/*
d2740 3
a2742 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d2816 3
a2818 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag\n"));
a2874 1
		HText_setIgnoreExcess(me->text, TRUE);
a2889 1
	    HText_setIgnoreExcess(me->text, FALSE);
d2933 1
a2933 1
	for (p = *href; (*p && !isspace(*p)); p++) ;
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 3
a4 3
**  Functions associated with LYCharSets.c and the Lynx version of HTML.c - FM
**  ==========================================================================
*/
d42 1
a42 1
 *  Used for nested lists. - FM
d44 2
a45 3
PUBLIC int OL_CONTINUE = -29999;     /* flag for whether CONTINUE is set */
PUBLIC int OL_VOID = -29998;	     /* flag for whether a count is set */

d48 6
a53 7
**  This function converts any ampersands in allocated
**  strings to "&amp;".  If isTITLE is TRUE, it also
**  converts any angle-brackets to "&lt;" or "&gt;". - FM
*/
PUBLIC void LYEntify ARGS2(
	char **,	str,
	BOOLEAN,	isTITLE)
d58 1
d60 8
a67 3
    enum _state
	{ S_text, S_esc, S_dollar, S_paren,
	  S_nonascii_text, S_dollar_paren } state = S_text;
d75 1
a75 1
     *	Count the ampersands. - FM
d83 1
a83 1
     *	Count the left-angle-brackets, if needed. - FM
d94 1
a94 1
     *	Count the right-angle-brackets, if needed. - FM
d105 1
a105 1
     *	Check whether we need to convert anything. - FM
d111 1
a111 1
     *	Allocate space and convert. - FM
d120 8
a127 8
	    switch(state) {
		case S_text:
		    if (*p == '\033') {
			state = S_esc;
			*q++ = *p;
			continue;
		    }
		    break;
d129 14
a142 14
		case S_esc:
		    if (*p == '$') {
			state = S_dollar;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }
d144 14
a157 14
		case S_dollar:
		    if (*p == '@@' || *p == 'B' || *p == 'A') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else if (*p == '(') {
			state = S_dollar_paren;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }
d159 10
a168 10
		case S_dollar_paren:
		    if (*p == 'C') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    } else {
			state = S_text;
			*q++ = *p;
			continue;
		    }
d170 7
a176 15
		case S_paren:
		    if (*p == 'B' || *p == 'J' || *p =='T') {
			state = S_text;
			*q++ = *p;
			continue;
		    } else if (*p == 'I') {
			state = S_nonascii_text;
			*q++ = *p;
			continue;
		    }
		    /* FALLTHRU */

		case S_nonascii_text:
		    if (*p == '\033')
			state = S_esc;
d179 2
d182 8
a189 2
		default:
		    break;
d191 4
a194 4
	    if (*(p+1) != '\0' &&
		(IS_EUC(UCH(*p), UCH(*(p+1))) ||
		 IS_SJIS(UCH(*p), UCH(*(p+1)), in_sjis) ||
		 IS_BIG5(UCH(*p), UCH(*(p+1))))) {
d227 5
a231 6
**  This function trims characters <= that of a space (32),
**  including HT_NON_BREAK_SPACE (1) and HT_EN_SPACE (2),
**  but not ESC, from the heads of strings. - FM
*/
PUBLIC void LYTrimHead ARGS1(
	char *, str)
d233 1
a233 1
    CONST char *s = str;
d238 1
a238 1
    while (*s && WHITE(*s) && UCH(*s) != UCH(CH_ESC))   /* S/390 -- gil -- 1669 */
d242 1
d251 5
a255 6
**  This function trims characters <= that of a space (32),
**  including HT_NON_BREAK_SPACE (1), HT_EN_SPACE (2), and
**  ESC from the tails of strings. - FM
*/
PUBLIC void LYTrimTail ARGS1(
	char *, str)
d273 6
a278 7
** This function should receive a pointer to the start
** of a comment.  It returns a pointer to the end ('>')
** character of comment, or it's best guess if the comment
** is invalid. - FM
*/
PUBLIC char *LYFindEndOfComment ARGS1(
	char *, str)
d281 6
a286 1
    enum comment_state { start1, start2, end1, end2 } state;
d290 1
a290 1
	 *  We got NULL, so return NULL. - FM
d296 2
a297 2
	 *  We don't have the start of a comment, so
	 *  return the beginning of the string. - FM
d302 1
a302 1
    if (*cp =='>')
d311 2
a312 2
	 *  We don't have an end character, so
	 *  return the beginning of the string. - FM
d318 2
a319 2
	 *  Ugh, it's a "decorative" series of dashes,
	 *  so return the next end character. - FM
d324 1
a324 1
     *	OK, we're ready to start parsing. - FM
d329 10
a338 10
	    case start1:
		if (*cp == '-')
		    state = start2;
		else
		    /*
		     *	Invalid comment, so return the first
		     *	'>' from the start of the string. - FM
		     */
		    return cp1;
		break;
d340 4
a343 4
	    case start2:
		if (*cp == '-')
		    state = end1;
		break;
d345 10
a354 10
	    case end1:
		if (*cp == '-')
		    state = end2;
		else
		    /*
		     *	Invalid comment, so return the first
		     *	'>' from the start of the string. - FM
		     */
		    return cp1;
		break;
d356 16
a371 16
	    case end2:
		if (*cp == '>')
		    /*
		     *	Valid comment, so return the end character. - FM
		     */
		    return cp;
		if (*cp == '-') {
		    state = start1;
		} else if (!(WHITE(*cp) && UCH(*cp) != UCH(CH_ESC))) {  /* S/390 -- gil -- 1686 */
		    /*
		     *	Invalid comment, so return the first
		     *	'>' from the start of the string. - FM
		     */
		    return cp1;
		 }
		break;
d373 2
a374 2
	    default:
		break;
d380 2
a381 2
     *	Invalid comment, so return the first
     *	'>' from the start of the string. - FM
d387 10
a396 11
**  If an HREF, itself or if resolved against a base,
**  represents a file URL, and the host is defaulted,
**  force in "//localhost".  We need this until
**  all the other Lynx code which performs security
**  checks based on the "localhost" string is changed
**  to assume "//localhost" when a host field is not
**  present in file URLs - FM
*/
PUBLIC void LYFillLocalFileURL ARGS2(
	char **,	href,
	CONST char *,	base)
d398 1
a398 1
    char * temp = NULL;
d411 1
a411 1
	if (*(*href+5) == '\0') {
d416 5
a420 5
	    StrAllocCopy(temp, (*href+7));
	    LYLocalFileToURL (href, temp);
	} else if (!strncmp(*href, "file:/", 6) && !LYIsHtmlSep(*(*href+6))) {
	    StrAllocCopy(temp, (*href+5));
	    LYLocalFileToURL (href, temp);
a422 1

d424 1
a424 1
    if (LYIsDosDrive(*href))  {
d430 1
a430 1
	LYLocalFileToURL (href, temp);
d435 2
a436 2
	  && (strlen(*href) == 19)
	  && LYIsDosDrive(*href+17)) {
d450 2
a451 1
	CONST char *temp2;
d456 1
d462 2
a463 2
	 *  Check for pathological cases - current dir has chars which
	 *  MUST BE URL-escaped - kw
a472 1

d479 1
a479 1
	StrAllocCat(*href, (HTVMS_wwwName(Home_Dir())+1));
d487 26
a512 28
**  This function writes a line with a META tag to an open file,
**  which will specify a charset parameter to use when the file is
**  read back in.  It is meant for temporary HTML files used by the
**  various special pages which may show titles of documents.  When those
**  files are created, the title strings normally have been translated and
**  expanded to the display character set, so we have to make sure they
**  don't get translated again.
**  If the user has changed the display character set during the lifetime
**  of the Lynx session (or, more exactly, during the time the title
**  strings to be written were generated), they may now have different
**  character encodings and there is currently no way to get it all right.
**  To change this, we would have to add a variable for each string which
**  keeps track of its character encoding.
**  But at least we can try to ensure that reading the file after future
**  display character set changes will give reasonable output.
**
**  The META tag is not written if the display character set (passed as
**  disp_chndl) already corresponds to the charset assumption that
**  would be made when the file is read. - KW
**
**  Currently this function is used for temporary files like "Lynx Info Page"
**  and for one permanent - bookmarks (so it may be a problem if you change
**  the display charset later: new bookmark entries may be mistranslated).
**								 - LP
*/
PUBLIC void LYAddMETAcharsetToFD ARGS2(
	FILE *,		fd,
	int,		disp_chndl)
d516 1
a516 1
	 *  -1 means use current_char_set.
d522 1
a522 1
	 *  Should not happen.
d528 1
a528 1
	 *  Not need to do, so we don't.
d534 1
a534 1
	 *  There shouldn't be any 8-bit characters in this case.
d539 3
a541 3
     *	In other cases we don't know because UCLYhndl_for_unspec may
     *	change during the lifetime of the file (by toggling raw mode
     *	or changing the display character set), so proceed.
d544 2
a545 2
		"http-equiv=\"content-type\"",
		LYCharSet_UC[disp_chndl].MIMEname);
d549 4
a552 5
** This function returns OL TYPE="A" strings in
** the range of " A." (1) to "ZZZ." (18278). - FM
*/
PUBLIC char *LYUppercaseA_OL_String ARGS1(
	int, seqnum)
d556 1
a556 1
    if (seqnum <= 1 ) {
d565 2
a566 2
	sprintf(OLstring, "%c%c.", ((seqnum-1)/26 + 64),
		(seqnum - ((seqnum-1)/26)*26 + 64));
d570 3
a572 3
	sprintf(OLstring, "%c%c%c.", ((seqnum-27)/676 + 64),
		(((seqnum - ((seqnum-27)/676)*676)-1)/26 + 64),
		(seqnum - ((seqnum-1)/26)*26 + 64));
d580 4
a583 5
** This function returns OL TYPE="a" strings in
** the range of " a." (1) to "zzz." (18278). - FM
*/
PUBLIC char *LYLowercaseA_OL_String ARGS1(
	int, seqnum)
d587 1
a587 1
    if (seqnum <= 1 ) {
d596 2
a597 2
	sprintf(OLstring, "%c%c.", ((seqnum-1)/26 + 96),
		(seqnum - ((seqnum-1)/26)*26 + 96));
d601 3
a603 3
	sprintf(OLstring, "%c%c%c.", ((seqnum-27)/676 + 96),
		(((seqnum - ((seqnum-27)/676)*676)-1)/26 + 96),
		(seqnum - ((seqnum-1)/26)*26 + 96));
d611 5
a615 6
** This function returns OL TYPE="I" strings in the
** range of " I." (1) to "MMM." (3000).- FM
** Maximum length: 16 -TD
*/
PUBLIC char *LYUppercaseI_OL_String ARGS1(
	int, seqnum)
d625 1
a625 1
    switch(Arabic) {
d745 5
a749 6
** This function returns OL TYPE="i" strings in
** range of " i." (1) to "mmm." (3000).- FM
** Maximum length: 16 -TD
*/
PUBLIC char *LYLowercaseI_OL_String ARGS1(
	int, seqnum)
d759 1
a759 1
    switch(Arabic) {
d879 3
a881 4
**  This function initializes the Ordered List counter. - FM
*/
PUBLIC void LYZero_OL_Counter ARGS1(
	HTStructured *,		me)
d900 3
a902 4
**  This function is used by the HTML Structured object. - KW
*/
PUBLIC void LYGetChartransInfo ARGS1(
	HTStructured *,		me)
d926 7
a932 7
 *  Given an UCS character code, will fill buffer passed in as q with
 *  the code's UTF-8 encoding.
 *  If terminate = YES, terminates string on success and returns pointer
 *			to beginning.
 *  If terminate = NO,	does not terminate string, and returns pointer
 *			next char after the UTF-8 put into buffer.
 *  On failure, including invalid code or 7-bit code, returns NULL.
d934 1
a934 1
PRIVATE char * UCPutUtf8ToBuffer ARGS3(char *, q, UCode_t, code, BOOL, terminate)
d937 1
d939 1
a939 1
    return NULL;
d942 2
a943 2
	    *q++ = (char)(0xc0 | (code>>6));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d945 3
a947 3
	    *q++ = (char)(0xe0 | (code>>12));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d949 4
a952 4
	    *q++ = (char)(0xf0 | (code>>18));
	    *q++ = (char)(0x80 | (0x3f & (code>>12)));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d954 5
a958 5
	    *q++ = (char)(0xf8 | (code>>24));
	    *q++ = (char)(0x80 | (0x3f & (code>>18)));
	    *q++ = (char)(0x80 | (0x3f & (code>>12)));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d960 6
a965 6
	    *q++ = (char)(0xfc | (code>>30));
	    *q++ = (char)(0x80 | (0x3f & (code>>24)));
	    *q++ = (char)(0x80 | (0x3f & (code>>18)));
	    *q++ = (char)(0x80 | (0x3f & (code>>12)));
	    *q++ = (char)(0x80 | (0x3f & (code>>6)));
	    *q++ = (char)(0x80 | (0x3f & (code)));
d979 1
a979 1
PRIVATE CONST char *hex = "0123456789ABCDEF";
d986 85
a1070 86
**  This function used for translations HTML special fields inside tags
**  (ALT=, VALUE=, etc.) from charset `cs_from' to charset `cs_to'.
**  It also unescapes non-ASCII characters from URL (#fragments !)
**  if st_URL is active.
**
**  If `do_ent' is YES, it converts named entities
**  and numeric character references (NCRs) to their `cs_to' replacements.
**
**  Named entities converted to unicodes.  NCRs (unicodes) converted
**  by UCdomap.c chartrans functions.
**  ???NCRs with values in the ISO-8859-1 range 160-255 may be converted
**  to their HTML entity names (via old-style entities) and then translated
**  according to the LYCharSets.c array for `cs_out'???.
**
**  Some characters (see descriptions in `put_special_unicodes' from SGML.c)
**  translated in relation with the state of boolean variables
**  `use_lynx_specials', `plain_space' and `hidden'.  It is not clear yet:
**
**  If plain_space is TRUE, nbsp (160) will be treated as an ASCII
**  space (32).  If hidden is TRUE, entities will be translated
**  (if `do_ent' is YES) but escape sequences will be passed unaltered.
**  If `hidden' is FALSE, some characters are converted to Lynx special
**  codes (see `put_special_unicodes') or ASCII space if `plain_space'
**  applies).  @@@@ is `use_lynx_specials' needed, does it have any effect? @@@@
**  If `use_lynx_specials' is YES, translate byte values 160 and 173
**  meaning U+00A0 and U+00AD given as or converted from raw char input
**  are converted to HT_NON_BREAK_SPACE and LY_SOFT_HYPHEN, respectively
**  (unless input and output charset are both iso-8859-1, for compatibility
**  with previous usage in HTML.c) even if `hidden' or `plain_space' is set.
**
**  If `Back' is YES, the reverse is done instead i.e., Lynx special codes
**  in the input are translated back to character values.
**
**  If `Back' is YES, an attempt is made to use UCReverseTransChar() for
**  back translation which may be more efficient. (?)
**
**  If `stype' is st_URL, non-ASCII characters are URL-encoded instead.
**  The sequence of bytes being URL-encoded is the raw input character if
**  we couldn't translate it from `cs_in' (CJK etc.); otherwise it is the
**  UTF-8 representation if either `cs_to' requires this or if the
**  character's Unicode value is > 255, otherwise it should be the iso-8859-1
**  representation.
**  No general URL-encoding occurs for displayable ASCII characters and
**  spaces and some C0 controls valid in HTML (LF, TAB), it is expected
**  that other functions will take care of that as appropriate.
**
**  Escape characters (0x1B, '\033') are
**  - URL-encoded	if `stype'  is st_URL,	 otherwise
**  - dropped		if `stype'  is st_other, otherwise (i.e., st_HTML)
**  - passed		if `hidden' is TRUE or HTCJK is set, otherwise
**  - dropped.
**
**  (If `stype' is st_URL or st_other most of the parameters really predefined:
**  cs_from=cs_to, use_lynx_specials=plain_space=NO, and hidden=YES)
**
**
**  Returns pointer to the char** passed in
**		 if string translated or translation unnecessary,
**	    NULL otherwise
**		 (in which case something probably went wrong.)
**
**
**  In general, this somehow ugly function (KW)
**  cover three functions from v.2.7.2 (FM):
**		    extern void LYExpandString PARAMS((
**		       HTStructured *	       me,
**		       char **		       str));
**		    extern void LYUnEscapeEntities PARAMS((
**		       HTStructured *	       me,
**		       char **		       str));
**		    extern void LYUnEscapeToLatinOne PARAMS((
**		       HTStructured *	       me,
**		       char **		       str,
**		       BOOLEAN		       isURL));
*/

PUBLIC char ** LYUCFullyTranslateString ARGS9(
	char **,	str,
	int,		cs_from,
	int,		cs_to,
	BOOLEAN,	do_ent,
	BOOL,		use_lynx_specials,
	BOOLEAN,	plain_space,
	BOOLEAN,	hidden,
	BOOL,		Back,
	CharUtil_st,	stype)
d1072 1
a1072 1
    char * p;
d1075 1
a1075 1
    char * cp = 0;
d1078 1
a1078 1
    char replace_buf [64];
d1085 1
a1085 1
    CONST char * name = NULL;
d1089 14
a1102 4
    char * puni;
    enum _state
	{ S_text, S_esc, S_dollar, S_paren, S_nonascii_text, S_dollar_paren,
	S_trans_byte, S_check_ent, S_ncr, S_check_uni, S_named, S_check_name,
d1104 16
a1119 5
	S_got_oututf8, S_got_outstring, S_put_urlstring,
	S_got_outchar, S_put_urlchar, S_next_char, S_done} state = S_text;
    enum _parsing_what
	{ P_text, P_utf8, P_hex, P_decimal, P_named
	} what = P_text;
d1122 1
d1129 2
a1130 2
    **	Make sure we have a non-empty string. - FM
    */
d1141 10
a1150 6
    **	Don't do byte translation
    **	if original AND target character sets
    **	are both iso-8859-1 (and we are not called to back-translate),
    **	or if we are in CJK mode.
    */
    if (HTCJK != NOCJK) {
d1155 1
a1155 1
    /* No need to translate or examine the string any further */
d1160 2
a1161 2
    **	Save malloc/calloc overhead in simple case - kw
    */
d1190 1
a1190 1
		       HText_hasUTF8OutputSet(HTMainText));
d1197 3
a1199 3
    **	Create a buffer string seven times the length of the original,
    **	so we have plenty of room for expansions. - FM
    */
d1221 6
a1226 7
    *  Loop through string, making conversions as needed.
    *
    *  The while() checks for a non-'\0' char only for the normal
    *  text states since other states may temporarily modify p or *p
    *  (which should be restored before S_done!) - kw
    */

d1228 1
a1228 1
	switch(state) {
d1233 1
a1233 1
		if (sjis_1st == '\0' && (IS_SJIS_HI1(code)||IS_SJIS_HI2(code))){
d1242 1
a1242 1
						sjis_str, sjis_str + 1);
d1267 3
a1269 3
		    **	CJK handling not on, and not a hidden INPUT,
		    **	so block escape. - FM
		    */
d1318 1
a1318 1
	    if (*p == 'B' || *p == 'J' || *p == 'T')  {
d1349 1
a1349 1
	    /*	character translation goes here  */
d1351 4
a1354 5
	    **	Don't do anything if we have no string,
	    **	or if original AND target character sets
	    **	are both iso-8859-1,
	    **	or if we are in CJK mode.
	    */
d1362 1
d1376 1
a1376 1
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
d1380 1
a1380 1
			    *(unsigned char *)p = UCH(160);
d1390 1
a1390 1
			||(LYCharSet_UC[cs_from].like8859 & UCT_R_8859SPECL))) {
d1394 1
a1394 1
			*(unsigned char *)p = UCH(173);
d1396 14
d1427 1
a1427 1
		if (((*p)&0xc0)==0xc0) {
d1457 3
a1459 3
	    **	Substitute Lynx special character for
	    **	160 (nbsp) if use_lynx_specials is set.
	    */
d1462 1
a1462 1
		code = ((code==160 ? HT_NON_BREAK_SPACE : LY_SOFT_HYPHEN));
d1472 2
a1473 1
		char * pp = p + 1;
d1476 2
a1477 2
		**  Check for a numeric entity. - FM
		*/
d1479 3
a1481 3
		    (*(pp+1) == 'x' || *(pp+1) == 'X') &&
		    UCH(*(pp+2)) < 127 &&
		    isxdigit(UCH(*(pp+2)))) {
d1485 2
a1486 2
			   UCH(*(pp+1)) < 127 &&
			   isdigit(UCH(*(pp+1)))) {
d1502 28
a1529 170
		if (what == P_hex) {
		    p += 3;
		} else {	/* P_decimal */
		    p += 2;
		}
		cp = p;
		while (*p && UCH(*p) < 127 &&
		       (what == P_hex ? isxdigit(UCH(*p)) :
					isdigit(UCH(*p)))) {
		    p++;
		}
		/*
		**  Save the terminator and isolate the digit(s). - FM
		*/
		cpe = *p;
		if (*p)
		    *p++ = '\0';
		/*
		** Show the numeric entity if the value:
		**  (1) Is greater than 255 and unhandled Unicode.
		**  (2) Is less than 32, and not valid and we don't
		**	have HTCJK set.
		**  (3) Is 127 and we don't have HTPassHighCtrlRaw
		**	or HTCJK set.
		**  (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
		*/
		if ((((what == P_hex) ? sscanf(cp, "%lx", &lcode) :
					sscanf(cp, "%ld", &lcode)) != 1) ||
		    lcode > 0x7fffffffL || lcode < 0) {
		    state = S_recover;
		    break;
		} else {
		    code = lcode;
		    if ((code == 1) ||
		       (code > 127 && code < 156)) {
			/*
			** Assume these are Microsoft code points, inflicted on
			** us by FrontPage.  - FM
			**
			** MS FrontPage uses syntax like &#153; in 128-159
			** range and doesn't follow Unicode standards for this
			** area.  Windows-1252 codepoints are assumed here.
			*/
			switch (code) {
			case 1:
			    /*
			    **	WHITE SMILING FACE
			    */
			    code = 0x263a;
			    break;
			case 128:
			    /*
			    **	EURO currency sign
			    */
			    code = 0x20ac;
			    break;
			case 130:
			    /*
			    **	SINGLE LOW-9 QUOTATION MARK (sbquo)
			    */
			    code = 0x201a;
			    break;
			case 132:
			    /*
			    **	DOUBLE LOW-9 QUOTATION MARK (bdquo)
			    */
			    code = 0x201e;
			    break;
			case 133:
			    /*
			    **	HORIZONTAL ELLIPSIS (hellip)
			    */
			    code = 0x2026;
			    break;
			case 134:
			    /*
			    **	DAGGER (dagger)
			    */
			    code = 0x2020;
			    break;
			case 135:
			    /*
			    **	DOUBLE DAGGER (Dagger)
			    */
			    code = 0x2021;
			    break;
			case 137:
			    /*
			    **	PER MILLE SIGN (permil)
			    */
			    code = 0x2030;
			    break;
			case 139:
			    /*
			    **	SINGLE LEFT-POINTING ANGLE QUOTATION MARK
			    **	(lsaquo)
			    */
			    code = 0x2039;
			    break;
			case 145:
			    /*
			    **	LEFT SINGLE QUOTATION MARK (lsquo)
			    */
			    code = 0x2018;
			    break;
			case 146:
			    /*
			    **	RIGHT SINGLE QUOTATION MARK (rsquo)
			    */
			    code = 0x2019;
			    break;
			case 147:
			    /*
			    **	LEFT DOUBLE QUOTATION MARK (ldquo)
			    */
			    code = 0x201c;
			    break;
			case 148:
			    /*
			    **	RIGHT DOUBLE QUOTATION MARK (rdquo)
			    */
			    code = 0x201d;
			    break;
			case 149:
			    /*
			    **	BULLET (bull)
			    */
			    code = 0x2022;
			    break;
			case 150:
			    /*
			    **	EN DASH (ndash)
			    */
			    code = 0x2013;
			    break;
			case 151:
			    /*
			    **	EM DASH (mdash)
			    */
			    code = 0x2014;
			    break;
			case 152:
			    /*
			    **	SMALL TILDE (tilde)
			    */
			    code = 0x02dc;
			    break;
			case 153:
			    /*
			    **	TRADE MARK SIGN (trade)
			    */
			    code = 0x2122;
			    break;
			case 155:
			    /*
			    **	SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
			    **	(rsaquo)
			    */
			    code = 0x203a;
			    break;
			default:
			    /*
			    **	Do not attempt a conversion
			    **	to valid Unicode values.
			    */
			    break;
		       }
		    }
		    state = S_check_uni;
		}
d1531 4
a1534 30

	case S_check_uni:
		/*
		** Show the numeric entity if the value:
		**  (2) Is less than 32, and not valid and we don't
		**	have HTCJK set.
		**  (3) Is 127 and we don't have HTPassHighCtrlRaw
		**	or HTCJK set.
		**  (4) Is 128 - 159 and we don't have HTPassHighCtrlNum set.
		*/
		 if ((code < 32 &&
		     code != 9 && code != 10 && code != 13 &&
		     HTCJK == NOCJK) ||
		    (code == 127 &&
		     !(HTPassHighCtrlRaw || HTCJK != NOCJK)) ||
		    (code > 127 && code < 160 &&
		     !HTPassHighCtrlNum)) {
		     state = S_recover;
		     break;
		 }
		/*
		**  Convert the value as an unsigned char,
		**  hex escaped if isURL is set and it's
		**  8-bit, and then recycle the terminator
		**  if it is not a semicolon. - FM
		*/
		if (code > 159 && stype == st_URL) {
		    state = S_got_oututf8;
		    break;
		}
d1536 91
a1626 9
		    **	For 160 (nbsp), use that value if it's
		    **	a hidden INPUT, otherwise use an ASCII
		    **	space (32) if plain_space is TRUE,
		    **	otherwise use the Lynx special character. - FM
		    */
		if (code == 160) {
		    if (plain_space) {
			code = ' ';
			state = S_got_outchar;
d1628 5
a1632 3
		    } else if (use_lynx_specials) {
			code = HT_NON_BREAK_SPACE;
			state = S_got_outchar;
d1634 5
a1638 6
		    } else if ((hidden && !Back) ||
			       (LYCharSet_UC[cs_to].codepoints & UCT_CP_SUPERSETOF_LAT1) ||
			       LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
			       (LYCharSet_UC[cs_to].like8859 &
						UCT_R_8859SPECL)) {
			state = S_got_outchar;
d1640 5
a1644 6
		    } else if (
			(LYCharSet_UC[cs_to].repertoire & UCT_REP_SUPERSETOF_LAT1)) {
			;	/* nothing, may be translated later */
		    } else {
			code = ' ';
			state = S_got_outchar;
d1646 5
a1650 12
		    }
		}
		/*
		    **	For 173 (shy), use that value if it's
		    **	a hidden INPUT, otherwise ignore it
		    **	if plain_space is TRUE, otherwise use
		    **	the Lynx special character. - FM
		    */
		if (code == 173) {
		    if (plain_space) {
			replace_buf[0] = '\0';
			state = S_got_outstring;
d1652 5
a1656 7
		    } else if (Back &&
			       !(LYCharSet_UC[cs_to].enc == UCT_ENC_8859 ||
				 (LYCharSet_UC[cs_to].like8859 &
					       UCT_R_8859SPECL))) {
			;	/* nothing, may be translated later */
		    } else if (hidden || Back) {
			state = S_got_outchar;
d1658 4
a1661 3
		    } else if (use_lynx_specials) {
			code = LY_SOFT_HYPHEN;
			state = S_got_outchar;
d1665 42
a1706 8
		/*
		**  Seek a translation from the chartrans tables.
		*/
		if ((uck = UCTransUniChar(code,
					  cs_to)) >= 32 &&
		    uck < 256 &&
		    (uck < 127 || uck >= lowest_8)) {
		    code = uck;
d1709 6
a1714 11
		} else if ((uck == -4 ||
			    (repl_translated_C0 &&
			     uck > 0 && uck < 32)) &&
			   /*
			   **  Not found; look for replacement string.
			   */
			   (uck = UCTransUniCharStr(replace_buf,
						    60, code,
						    cs_to,
						    0) >= 0)) {
		    state = S_got_outstring;
d1716 6
a1721 4
		}
		if (output_utf8 &&
		    code > 127 && code < 0x7fffffffL) {
		    state = S_got_oututf8;
d1724 8
a1731 26
		/*
		**  For 8194 (ensp), 8195 (emsp), or 8201 (thinsp),
		**  use the character reference if it's a hidden INPUT,
		**  otherwise use an ASCII space (32) if plain_space is
		**  TRUE, otherwise use the Lynx special character. - FM
		*/
		if (code == 8194 || code == 8195 || code == 8201) {
		    if (hidden) {
			state = S_recover;
		    } else if (plain_space) {
			code = ' ';
			state = S_got_outchar;
		    } else {
			code = HT_EN_SPACE;
			state = S_got_outchar;
		    }
		    break;
		    /*
		    **	Ignore 8204 (zwnj), 8205 (zwj)
		    **	8206 (lrm), and 8207 (rlm),
		    **	for now, if we got this far without
		    **	finding a representation for them.
		    */
		} else if (code == 8204 || code == 8205 ||
			   code == 8206 || code == 8207) {
		    CTRACE((tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code));
d1735 11
a1745 11
		    /*
		    **	Show the numeric entity if the value:
		    **	(1) Is greater than 255 and unhandled Unicode.
		    */
		} else if (code > 255) {
		    /*
			**  Illegal or not yet handled value.
			**  Return "&#" verbatim and continue
			**  from there. - FM
			*/
		    state = S_recover;
d1747 15
d1763 28
a1790 10
		**  If it's ASCII, or is 8-bit but HTPassEightBitNum
		**  is set or the character set is "ISO Latin 1",
		**  use it's value. - FM
		*/
		} else if (code < 161 ||
			   (code < 256 &&
			    (HTPassEightBitNum || cs_to == LATIN1))) {
		    /*
		    **	No conversion needed.
		    */
d1792 36
a1827 1
		    break;
d1829 12
a1840 14
		    /* The following disabled section doesn't make sense
		    ** any more.  It used to make sense in the past, when
		    ** S_check_named would look in "old style" tables
		    ** in addition to what it does now.
		    ** Disabling of going to S_check_name here prevents
		    ** endless looping between S_check_uni and S_check_names
		    ** states, which could occur here for Latin 1 codes
		    ** for some cs_to if they had no translation in that
		    ** cs_to.  Normally all cs_to *should* now have valid
		    ** translations via UCTransUniChar or UCTransUniCharStr
		    ** for all Latin 1 codes, so that we would not get here
		    ** anyway, and no loop could occur.  Still, if we *do*
		    ** get here, FALL THROUGH to case S_recover now.  - kw
		    */
d1842 8
a1849 8
		    /*
		    **	If we get to here, convert and handle
		    **	the character as a named entity. - FM
		    */
		} else {
		    name = HTMLGetEntityName(code - 160);
		    state = S_check_name;
		    break;
d1851 1
a1851 1
		}
d1856 3
a1858 4
		**  Illegal or not yet handled value.
		**  Return "&#" verbatim and continue
		**  from there. - FM
		*/
d1864 1
a1864 1
		    *(p-1) = cpe;
d1872 2
a1873 2
		!(HTPassEightBitRaw &&
		 UCH(*p) >= lowest_8)) {
d1896 10
a1905 10
	    **	Seek the Unicode value for the named entity.
	    **
	    **	!!!! We manually recover the case of '=' terminator which
	    **	is commonly found on query to CGI-scripts
	    **	enclosed as href= URLs like  "somepath/?x=1&yz=2"
	    **	Without this dirty fix, submission of such URLs was broken
	    **	if &yz string happened to be a recognized entity name. - LP
	    */
	   if ( ((code = HTMLGetEntityUCValue(name)) > 0) &&
		!((cpe == '=') && (stype == st_URL)) ) {
d1910 2
a1911 3
	    **	Didn't find the entity.
	    **	Return verbatim.
	    */
d1915 1
a1915 1
				/* * * O U T P U T   S T A T E S * * */
d1942 1
a1942 1
		code = replace_buf[0]; /* assume string OK if first char is */
d1970 2
a1971 2
	    /*	Not a full HTEscape, only for 8bit and ctrl chars */
		(TOASCII(code) >= 127 ||  /* S/390 -- gil -- 1925 */
d1973 2
a1974 2
		    state = S_put_urlchar;
		    break;
d1976 1
a1976 1
		       && q != qs && *(q-1) == 13) {
d1978 4
a1981 4
		**  If this is not a hidden string, and the current char is
		**  the LF ('\n') of a CRLF pair, drop the CR ('\r'). - KW
		*/
		*(q-1) = *p++;
d1985 1
a1985 1
	    *q++ = (char)code;
d1990 1
a1990 1
	    REPLACE_CHAR(hex[(TOASCII(code) >> 4) & 15]);  /* S/390 -- gil -- 1944 */
d1992 1
a1992 1
				/* fall through */
d1998 1
a1998 1
				/* for next round */
d2004 1
a2004 1
	HTChunkPutb(CHUNK, qs, q-qs + 1); /* also terminates */
d2023 7
a2029 8
PUBLIC BOOL LYUCTranslateHTMLString ARGS7(
	char **, str,
	int,	cs_from,
	int,	cs_to,
	BOOL,	use_lynx_specials,
	BOOLEAN,	plain_space,
	BOOLEAN,	hidden,
	CharUtil_st,	stype)
d2032 1
d2035 2
a2036 2
				    use_lynx_specials, plain_space, hidden,
				    NO, stype)) {
d2042 4
a2045 5
PUBLIC BOOL LYUCTranslateBackFormData ARGS4(
	char **, str,
	int,	cs_from,
	int,	cs_to,
	BOOLEAN,	plain_space)
d2047 2
a2048 1
    char ** ret;
d2051 2
a2052 2
				       NO, plain_space, YES,
				       YES, st_HTML));
d2059 2
a2060 3
PUBLIC char *LYParseTagParam ARGS2(
	char *,		from,
	char *,		name)
d2072 2
a2073 1
	if (strlen(string) < len) return NULL;
d2090 3
a2092 4
    if (len > 2 && result[0] == '\'' && result[len-1] == result[0]) {
	result[len-1] = '\0';
	for (string = result; (string[0] = string[1]) != '\0'; ++string)
	    ;
d2101 3
a2103 4
PUBLIC void LYParseRefreshURL ARGS3(
	char *,		content,
	char **,	p_seconds,
	char **,	p_address)
d2110 1
a2110 1
     *  Look for the Seconds field. - FM
d2122 3
a2124 2
    CTRACE((tfp, "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
	   content, NonNull(*p_seconds), NonNull(*p_address)));
d2128 5
a2132 7
**  This function processes META tags in HTML streams. - FM
*/
PUBLIC void LYHandleMETA ARGS4(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	char **,		include GCC_UNUSED)
d2143 1
a2143 1
     *	Load the attributes for possible use by Lynx. - FM
d2146 1
a2146 1
	value[HTML_META_HTTP_EQUIV] && *value[HTML_META_HTTP_EQUIV]) {
d2150 1
a2150 1
				 NO, NO, YES, st_other);
d2156 1
a2156 1
	value[HTML_META_NAME] && *value[HTML_META_NAME]) {
d2160 1
a2160 1
				 NO, NO, YES, st_other);
d2166 1
a2166 1
	value[HTML_META_CONTENT] && *value[HTML_META_CONTENT]) {
d2168 7
a2174 9
	 *  Technically, we should be creating a comma-separated
	 *  list, but META tags come one at a time, and we'll
	 *  handle (or ignore) them as each is received.  Also,
	 *  at this point, we only trim leading and trailing
	 *  blanks from the CONTENT value, without translating
	 *  any named entities or numeric character references,
	 *  because how we should do that depends on what type
	 *  of information it contains, and whether or not any
	 *  of it might be sent to the screen. - FM
d2184 5
a2188 4
    CTRACE((tfp, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
		(http_equiv ? http_equiv : "NULL"),
		(name ? name : "NULL"),
		(content ? content : "NULL")));
d2191 1
a2191 1
     *	Make sure we have META name/value pairs to handle. - FM
d2203 1
a2203 1
				 NO, NO, YES, st_other);
d2210 3
a2212 5
	 *  If we didn't get a Cache-Control MIME header,
	 *  and the META has one, convert to lowercase,
	 *  store it in the anchor element, and if we
	 *  haven't yet set no_cache, check whether we
	 *  should. - FM
d2258 3
a2260 3
    /*
     * Check for an Expires directive. - FM
     */
d2263 5
a2267 8
	 *  If we didn't get an Expires MIME header,
	 *  store it in the anchor element, and if we
	 *  haven't yet set no_cache, check whether we
	 *  should.  Note that we don't accept a Date
	 *  header via META tags, because it's likely
	 *  to be untrustworthy, but do check for a
	 *  Date header from a server when making the
	 *  comparison. - FM
d2270 1
a2270 1
				 NO, NO, YES, st_other);
d2275 2
a2276 2
		 *  The value is zero, which we treat as
		 *  an absolute no-cache directive. - FM
d2282 2
a2283 3
		 *  We have a Date header, so check if
		 *  the value is less than or equal to
		 *  that. - FM
d2292 2
a2293 2
		 *  We don't have a Date header, and
		 *  the value is in past for us. - FM
d2300 5
a2304 6
    /*
     *	Check for a text/html Content-Type with a
     *	charset directive, if we didn't already set
     *	the charset via a server's header. - AAC & FM
     */
    } else if (!(me->node_anchor->charset && *me->node_anchor->charset) &&
d2306 3
a2308 2
	LYUCcharset * p_in = NULL;
	LYUCcharset * p_out = NULL;
d2310 1
a2310 1
				 NO, NO, YES, st_other);
d2322 1
a2322 1
	    StrAllocCopy(cp3, cp1); /* copy to mutilate more */
d2324 1
a2324 1
			     *cp4 != ';'  && *cp4 != ':' &&
d2326 1
a2326 1
		; /* do nothing */
d2334 1
a2334 1
	    if (Switch_Display_Charset (chndl, SWITCH_DISPLAY_CHARSET_MAYBE)) {
d2337 2
a2338 2
		int structured = HTAnchor_getUCInfoStage(me->node_anchor,
							 UCT_STAGE_STRUCTURED);
d2343 1
a2343 1
					UCT_SETBY_MIME); /* highest priorty! */
d2347 1
a2347 1
					UCT_SETBY_MIME); /* highest priorty! */
d2362 1
a2362 1
		 *  Got something but we don't recognize it.
d2365 2
a2366 2
		if (chndl < 0) /* UCLYhndl_for_unrec not defined :-( */
		     chndl = UCLYhndl_for_unspec; /* always >= 0 */
d2383 1
a2383 1
		     *	Try again.
d2391 4
a2394 4
				HTAnchor_getUCLYhndl(me->node_anchor,
						     UCT_STAGE_HTEXT),
						     UCT_STAGE_PARSER,
						     UCT_SETBY_DEFAULT);
d2399 2
a2400 2
				HTAnchor_getUCLYhndl(me->node_anchor,
						     UCT_STAGE_PARSER),
d2404 5
a2408 1
		if (p_in->enc != UCT_ENC_CJK) {
d2420 3
a2422 4
		**  Update the chartrans info homologously to
		**  a Content-Type MIME header with a charset
		**  parameter. - FM
		*/
d2440 16
a2455 20
		 *  Cannot translate.
		 *  If according to some heuristic the given
		 *  charset and the current display character
		 *  both are likely to be like ISO-8859 in
		 *  structure, pretend we have some kind
		 *  of match.
		 */
		BOOL given_is_8859
		    = (BOOL) (!strncmp(cp4, "iso-8859-", 9) &&
		       isdigit(UCH(cp4[9])));
		BOOL given_is_8859like
		    = (BOOL) (given_is_8859 || !strncmp(cp4, "windows-", 8) ||
			!strncmp(cp4, "cp12", 4) ||
			!strncmp(cp4, "cp-12", 5));
		BOOL given_and_display_8859like
		    = (BOOL) (given_is_8859like &&
		       (strstr(LYchar_set_names[current_char_set],
			       "ISO-8859") ||
			strstr(LYchar_set_names[current_char_set],
			       "windows-")));
d2480 1
a2480 1
	 *  Set the kcode element based on the charset. - FM
d2484 3
a2486 3
    /*
     *	Check for a Refresh directive. - FM
     */
d2495 1
a2495 1
		 *  We found a URL field, so check it out. - FM
d2499 3
a2501 3
		     *	The specs require a complete URL,
		     *	but this is a Netscapism, so don't
		     *	expect the author to know that. - FM
d2505 1
a2505 2
		     *	Use the document's address
		     *	as the base. - FM
d2519 1
a2519 1
		     *  Check whether to fill in localhost. - FM
d2522 2
a2523 2
				   (me->inBASE ?
				 me->base_href : me->node_anchor->address));
d2527 2
a2528 2
		 *  Set the no_cache flag if the Refresh URL
		 *  is the same as the document's address. - FM
d2535 2
a2536 3
		 *  We didn't find a URL field, so use
		 *  the document's own address and set
		 *  the no_cache flag. - FM
d2542 1
a2542 1
	     *	Check for an anchor in http or https URLs. - FM
d2556 3
a2558 4
		 *  Ugh!  The META tag, which is a HEAD element,
		 *  is in an Anchor, which is BODY element.  All
		 *  we can do is close the Anchor and cross our
		 *  fingers. - FM
d2567 6
a2572 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				id_string,		/* Tag */
				href,			/* Addresss */
				(void *)0);		/* Type */
d2598 6
a2603 6
    /*
     *	Check for a suggested filename via a Content-Disposition with
     *	a filename=name.suffix in it, if we don't already have it
     *	via a server header. - FM
     */
    } else if (!(me->node_anchor->SugFname && *me->node_anchor->SugFname) &&
d2610 2
a2611 4
	    cp += 8;
	    while ((*cp != '\0') && (WHITE(*cp) || *cp == '='))
		cp++;
	    while (*cp != '\0' && WHITE(*cp))
d2613 1
d2616 1
a2616 1
		if (*me->node_anchor->SugFname == '\"') {
d2618 1
a2618 1
				     '\"')) != NULL) {
d2621 3
a2626 4
		    if (me->node_anchor->SugFname != NULL &&
			*me->node_anchor->SugFname == '\0') {
			FREE(me->node_anchor->SugFname);
		    }
d2628 5
d2634 5
a2638 5
		    while (*cp != '\0' && !WHITE(*cp))
			cp++;
		    *cp = '\0';
		    if (*me->node_anchor->SugFname == '\0')
			FREE(me->node_anchor->SugFname);
d2640 1
d2643 3
a2645 3
    /*
     *	Check for a Set-Cookie directive. - AK
     */
d2648 3
a2650 3
	 *  This will need to be updated when Set-Cookie/Set-Cookie2
	 *  handling is finalized.  For now, we'll still assume
	 *  "historical" cookies in META directives. - FM
d2653 1
a2653 1
		       me->base_href : me->node_anchor->address);
d2658 1
a2658 1
		      me->base_href : me->node_anchor->address));
d2663 1
a2663 1
     *	Free the copies. - FM
d2665 1
a2665 1
free_META_copies:
d2672 13
a2684 15
**  This function handles P elements in HTML streams.
**  If start is TRUE it handles a start tag, and if
**  FALSE, an end tag.	We presently handle start
**  and end tags identically, but this can lead to
**  a different number of blank lines between the
**  current paragraph and subsequent text when a P
**  end tag is present or not in the markup. - FM
*/
PUBLIC void LYHandlePlike ARGS6(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	char **,		include GCC_UNUSED,
	int,			align_idx,
	BOOL,			start)
d2688 5
a2692 5
	 *  FIG content should be a true block, which like P inherits
	 *  the current style.	APPLET is like character elements or
	 *  an ALT attribute, unless it content contains a block element.
	 *  If we encounter a P in either's content, we set flags to treat
	 *  the content as a block.  - FM
d2705 3
a2707 4
	     *	We're in a list.  Treat P as an instruction to
	     *	create one blank line, if not already present,
	     *	then fall through to handle attributes, with
	     *	the "second line" margins. - FM
d2721 3
a2723 3
	     *	We're in an ADDRESS.  Treat P as an instruction
	     *	to start a newline, if needed, then fall through
	     *	to handle attributes. - FM
d2726 1
a2726 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d2746 3
a2748 3
			(me->sp->style->id == ST_DivCenter ||
			 me->sp->style->id == ST_DivLeft ||
			 me->sp->style->id == ST_DivRight)) ||
d2750 3
a2752 3
			(me->sp->style->id == ST_Normal ||
			 me->sp->style->id == ST_Preformatted))) {
		me->sp->style->alignment = HT_LEFT;
d2763 1
a2763 1
		    !(me->List_Nesting_Level >= 0 && !me->inP))
d2773 2
a2774 3
	 *  Mark that we are starting a new paragraph
	 *  and don't have any of it's text yet. - FM
	 *
d2783 8
a2790 10
**  This function handles SELECT elements in HTML streams.
**  If start is TRUE it handles a start tag, and if FALSE,
**  an end tag. - FM
*/
PUBLIC void LYHandleSELECT ARGS5(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	char **,		include GCC_UNUSED,
	BOOL,			start)
d2800 1
a2800 1
	 *  Initialize the disable attribute.
d2805 1
a2805 1
	 *  Make sure we're in a form.
d2813 7
a2819 6
	     *	We should have covered all crash possibilities with the
	     *	current TagSoup parser, so we'll allow it because some
	     *	people with other browsers use SELECT for "information"
	     *	popups, outside of FORM blocks, though no Lynx user
	     *	would do anything that awful, right? - FM
	     *//***
d2825 1
a2825 1
	 *  Check for unclosed TEXTAREA.
d2833 1
a2833 1
	 *  Set to know we are in a select tag.
d2838 1
a2838 1
	      value[HTML_SELECT_NAME]  && *value[HTML_SELECT_NAME])) {
d2847 1
a2847 1
	    multiple=YES;
d2851 1
a2851 1
	    value[HTML_SELECT_SIZE] && *value[HTML_SELECT_SIZE]) {
d2853 1
a2853 1
	     *	Let the size be determined by the number of OPTIONs. - FM
d2856 1
a2856 1
			value[HTML_SELECT_SIZE]));
d2874 1
a2874 1
	    HText_LastLineSize(me->text, FALSE) > (LYcols - 8)) {
d2876 5
a2880 6
	     *	Force a newline when we're using a popup in
	     *	a PRE block and are within 7 columns from the
	     *	right margin.  This will allow for the '['
	     *	popup designator and help avoid a wrap in the
	     *	underscore placeholder for the retracted popup
	     *	entry in the HText structure. - FM
d2886 1
a2886 1
	LYCheckForID(me, present, value, (int)HTML_SELECT_ID);
d2895 1
a2895 1
	 *  Handle end tag.
d2900 1
a2900 1
	 *  Make sure we had a select start tag.
d2909 1
a2909 1
	 *  Set to know that we are no longer in a select tag.
d2914 1
a2914 1
	 *  Clear the disable attribute.
d2919 1
a2919 1
	 *  Finish the data off.
d2923 1
a2923 1
	 *  Finish the previous option.
d2939 1
a2939 1
	     *	Start a newline after the last checkbox/button option.
d2944 2
a2945 2
	     *	Output popup box with the default option to screen,
	     *	but use non-breaking spaces for output.
d2950 3
a2952 3
		 *  The code inadequately handles OPTION fields in PRE tags.
		 *  We'll put up a minimum of 6 characters, and if any
		 *  more would exceed the wrap column, we'll ignore them.
d2963 1
a2963 1
	    for (; ptr && *ptr != '\0'; ptr++) {
d2970 1
a2970 1
	     *	Add end option character.
d2994 9
a3002 11
**  This function strips white characters and
**  generally fixes up attribute values that
**  were received from the SGML parser and
**  are to be treated as partial or absolute
**  URLs. - FM
*/
PUBLIC int LYLegitimizeHREF ARGS4(
	HTStructured *,		me,
	char **,		href,
	BOOL,			force_slash,
	BOOL,			strip_dots)
d3007 1
a3007 1
    CONST char *Base = NULL;
d3010 1
a3010 1
	return(url_type);
d3014 4
a3017 5
	 *  Collapse spaces in the actual URL, but just
	 *  protect against tabs or newlines in the
	 *  fragment, if present.  This seeks to cope
	 *  with atrocities inflicted on the Web by
	 *  authoring tools such as Frontpage. - FM
d3021 1
a3021 2
	for (p = *href; (*p && !isspace(*p)); p++)
	    ;
d3023 2
a3024 2
	if (*p) {  /* p == first space character */
		   /* no reallocs below, all converted in place */
d3029 1
a3029 1
		convert_to_spaces(p, FALSE);  /* done */
d3033 1
a3033 1
		    *pound = '\0';  /* mark */
d3042 1
a3042 1
		    LYRemoveBlanks(p);  /* a compromise... */
d3047 1
a3047 1
		    *pound = '#';  /* restore */
d3056 1
a3056 1
	return(url_type);
d3061 1
a3061 1
		me->base_href : me->node_anchor->address;
d3066 1
a3066 1
	 !isFILE_URL(Base)) {
d3068 5
a3072 6
	 *  The Fielding RFC/ID for resolving partial HREFs says
	 *  that a slash should be on the end of the preceding
	 *  symbolic element for "." and "..", but all tested
	 *  browsers only do that for an explicit "./" or "../",
	 *  so we'll respect the RFC/ID only if force_slash was
	 *  TRUE and it's not a file URL. - FM
d3077 1
a3077 1
	 !strncasecomp(Base, "http", 4)) {
d3079 11
a3089 12
	 *  We will be resolving a partial reference versus an http
	 *  or https URL, and it has lead dots, which may be retained
	 *  when resolving via HTParse(), but the request would fail
	 *  if the first element of the resultant path is two dots,
	 *  because no http or https server accepts such paths, and
	 *  the current URL draft, likely to become an RFC, says that
	 *  it's optional for the UA to strip them as a form of error
	 *  recovery.  So we will, recursively, for http/https URLs,
	 *  like the "major market browsers" which made this problem
	 *  so common on the Web, but we'll also issue a message about
	 *  it, such that the bad partial reference might get corrected
	 *  by the document provider. - FM
d3092 1
a3092 1
	CONST char *str = "";
d3095 1
a3095 1
	path = HTParse(temp, "", PARSE_PATH+PARSE_PUNCTUATION);
d3102 2
a3103 1
		CTRACE((tfp, "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
d3130 1
a3130 1
    return(url_type);
d3134 7
a3140 8
**  This function checks for a Content-Base header,
**  and if not present, a Content-Location header
**  which is an absolute URL, and sets the BASE
**  accordingly.  If set, it will be replaced by
**  any BASE tag in the HTML stream, itself. - FM
*/
PUBLIC void LYCheckForContentBase ARGS1(
	HTStructured *,		me)
d3144 1
a3144 1
    CONST char *value[HTML_BASE_ATTRIBUTES];
d3152 1
a3152 2
	 *  We have a Content-Base value.  Use it
	 *  if it's non-zero length. - FM
d3160 2
a3161 3
	 *  We didn't have a Content-Base value, but do
	 *  have a Content-Location value.  Use it if
	 *  it's an absolute URL. - FM
d3173 1
a3173 2
	 *  We had neither a Content-Base nor
	 *  Content-Location value. - FM
d3179 1
a3179 2
     *	If we collapsed to a zero-length value,
     *	ignore it. - FM
d3187 1
a3187 2
     *	Pass the value to HTML_start_element as
     *	the HREF of a BASE tag. - FM
d3190 1
a3190 1
	 present[i] = NO;
d3192 3
a3194 3
    value[HTML_BASE_HREF] = (CONST char *)cp;
    (*me->isa->start_element)(me, HTML_BASE, present, value,
			      0, 0);
d3199 6
a3204 8
**  This function creates NAMEd Anchors if a non-zero-length NAME
**  or ID attribute was present in the tag. - FM
*/
PUBLIC void LYCheckForID ARGS4(
	HTStructured *,		me,
	CONST BOOL *,		present,
	CONST char **,		value,
	int,			attribute)
d3213 1
a3213 1
	&& value[attribute] && *value[attribute]) {
d3215 1
a3215 1
	 *  Translate any named or numeric character references. - FM
d3219 1
a3219 1
				 NO, NO, YES, st_URL);
d3222 1
a3222 1
	 *  Create the link if we still have a non-zero-length string. - FM
d3225 6
a3230 5
	    (ID_A = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				temp,			/* Tag */
				NULL,			/* Addresss */
				(void *)0))) {		/* Type */
d3239 5
a3243 7
**  This function creates a NAMEd Anchor for the ID string
**  passed to it directly as an argument.  It assumes the
**  does not need checking for character references. - FM
*/
PUBLIC void LYHandleID ARGS2(
	HTStructured *,		me,
	CONST char *,		id)
d3248 1
a3248 1
	!(id && *id))
d3252 1
a3252 1
     *	Create the link if we still have a non-zero-length string. - FM
d3254 6
a3259 5
    if ((ID_A = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				id,			/* Tag */
				NULL,			/* Addresss */
				(void *)0)) != NULL) {	/* Type */
d3266 6
a3271 7
**  This function checks whether we want to override
**  the current default alignment for paragraphs and
**  instead use that specified in the element's style
**  sheet. - FM
*/
PUBLIC BOOLEAN LYoverride_default_alignment ARGS1(
	HTStructured *, me)
d3276 8
a3283 8
    switch(me->sp[0].tag_number) {
	case HTML_BLOCKQUOTE:
	case HTML_BQ:
	case HTML_NOTE:
	case HTML_FN:
	case HTML_ADDRESS:
	    me->sp->style->alignment = HT_LEFT;
	    return YES;
d3285 2
a3286 2
	default:
	    break;
d3292 5
a3296 6
**  This function inserts newlines if needed to create double spacing,
**  and sets the left margin for subsequent text to the second line
**  indentation of the current style. - FM
*/
PUBLIC void LYEnsureDoubleSpace ARGS1(
	HTStructured *, me)
d3302 1
a3302 1
	HText_setLastChar(me->text, ' ');  /* absorb white space */
d3306 1
a3306 1
	HText_setLastChar(me->text, ' ');  /* absorb white space */
d3316 5
a3320 6
**  This function inserts a newline if needed to create single spacing,
**  and sets the left margin for subsequent text to the second line
**  indentation of the current style. - FM
*/
PUBLIC void LYEnsureSingleSpace ARGS1(
	HTStructured *, me)
d3326 1
a3326 1
	HText_setLastChar(me->text, ' ');  /* absorb white space */
d3336 4
a3339 5
**  This function resets paragraph alignments for block
**  elements which do not have a defined style sheet. - FM
*/
PUBLIC void LYResetParagraphAlignment ARGS1(
	HTStructured *, me)
d3356 18
a3373 19
**  This example function checks whether the given anchor has
**  an address with a file scheme, and if so, loads it into the
**  the SGML parser's context->url element, which was passed as
**  the second argument.  The handle_comment() calling function in
**  SGML.c then calls LYDoCSI() in LYUtils.c to insert HTML markup
**  into the corresponding stream, homologously to an SSI by an
**  HTTP server. - FM
**
**  For functions similar to this but which depend on details of
**  the HTML handler's internal data, the calling interface should
**  be changed, and functions in SGML.c would have to make sure not
**  to call such functions inappropriately (e.g., calling a function
**  specific to the Lynx_HTML_Handler when SGML.c output goes to
**  some other HTStructured object like in HTMLGen.c), or the new
**  functions could be added to the SGML.h interface.
*/
PUBLIC BOOLEAN LYCheckForCSI ARGS2(
	HTParentAnchor *,	anchor,
	char **,		url)
d3389 22
a3410 23
**  This function is called from the SGML parser to look at comments
**  and see whether we should collect some info from them.  Currently
**  it only looks for comments with Message-Id and Subject info, in the
**  exact form generated by MHonArc for archived mailing list.  If found,
**  the info is stored in the document's HTParentAnchor.  It can later be
**  used for generating a mail response.
**
**  We are extra picky here because there isn't any official definition
**  for these kinds of comments - we might (and still can) misinterpret
**  arbitrary comments as something they aren't.
**
**  If something doesn't look right, for example invalid characters, the
**  strings are not stored.  Mail responses will use something else as
**  the subject, probably the document URL, and will not have an
**  In-Reply-To header.
**
**  All this is a hack - to do this the right way, mailing list archivers
**  would have to agree on some better mechanism to make this kind of info
**  from original mail headers available, for example using LINK.  - kw
*/
PUBLIC BOOLEAN LYCommentHacks ARGS2(
	HTParentAnchor *,	anchor,
	CONST char *,		comment)
d3412 1
a3412 1
    CONST char *cp = comment;
d3424 2
a3425 1
	for (cp = comment+17; *cp; cp++) {
d3452 2
a3453 2
	if ((len = strlen(p)) >= 8 && !strcmp(&p[len-3], " --")) {
	    p[len-3] = '\0';
d3469 2
a3470 1
	for (cp = comment+14; *cp; cp++) {
d3498 2
a3499 2
	if ((len = strlen(p)) >= 4 && !strcmp(&p[len-3], " --")) {
	    p[len-3] = '\0';
d3517 2
a3518 3
     *	Create the Title with any left-angle-brackets
     *	converted to &lt; entities and any ampersands
     *	converted to &amp; entities.  - FM
d3520 6
a3525 7
     *  Convert 8-bit letters to &#xUUUU to avoid dependencies
     *  from display character set which may need changing.
     *  Do NOT convert any 8-bit chars if we have CJK display. - LP
     */
void LYformTitle ARGS2(
	char **,	dst,
	CONST char *,	src)
d3529 2
a3530 1
	if ((tmp_buffer = (char *) malloc (strlen(src)+1)) == 0)
d3532 1
a3532 1
	switch(kanji_code) {	/* 1997/11/22 (Sat) 09:28:00 */
d3534 1
a3534 1
	    TO_EUC((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
d3537 1
a3537 1
	    TO_SJIS((CONST unsigned char *) src, (unsigned char *) tmp_buffer);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a40 5
extern BOOL HTPassEightBitRaw;
extern BOOL HTPassEightBitNum;
extern BOOL HTPassHighCtrlRaw;
extern BOOL HTPassHighCtrlNum;

d67 1
a67 1
    if (p == NULL || *p == '\0')
d230 1
a230 1
    int i = 0, j;
d232 1
a232 1
    if (!str || *str == '\0')
d235 6
a240 5
    while (str[i] != '\0' && WHITE(str[i]) && UCH(str[i]) != UCH(CH_ESC))   /* S/390 -- gil -- 1669 */
	i++;
    if (i > 0) {
	for (j = 0; str[i] != '\0'; i++) {
	    str[j++] = str[i];
d242 1
a242 1
	str[j] = '\0';
d256 1
a256 1
    if (!str || *str == '\0')
d259 1
a259 1
    i = (strlen(str) - 1);
d394 1
a394 1
    if (*href == NULL || *(*href) == '\0')
d398 2
a399 2
	if (base != NULL && !strncmp(base, "file:", 5)) {
	    StrAllocCopy(temp, "file:");
d404 1
a404 1
    if (!strncmp(*href, "file:", 5)) {
d418 2
a419 2
#if defined(DOSPATH) || defined(__EMX__)
    if (isalpha(*(*href)) && (*(*href+1) == ':'))  {
d431 1
a431 2
	  && isalpha(*(*href+17))
	  && (*(*href+18) == ':')) {
d436 1
a436 1
	StrAllocCat(*href, "/");
d438 1
a438 1
#endif /* DOSPATH */
d445 1
a445 1
	char *temp2;
d447 1
a447 1
	temp2 = HTVMS_wwwName(getenv("PATH"));
d1111 1
a1111 1
    if (!str || *str == NULL || **str == '\0')
d1984 1
a1984 1
	if (stype == st_URL) {
d1991 1
a1991 1
	if (stype == st_URL) {
d2036 72
a2132 2
	LYTrimHead(http_equiv);
	LYTrimTail(http_equiv);
a2142 2
	LYTrimHead(name);
	LYTrimTail(name);
d2183 2
a2184 2
    if (!strcasecomp((http_equiv ? http_equiv : ""), "Pragma") ||
	!strcasecomp((http_equiv ? http_equiv : ""), "Cache-Control")) {
a2186 2
	LYTrimHead(content);
	LYTrimTail(content);
d2200 1
a2200 1
	    !strcasecomp((http_equiv ? http_equiv : ""), "Cache-Control")) {
d2246 1
a2246 1
    } else if (!strcasecomp((http_equiv ? http_equiv : ""), "Expires")) {
a2258 2
	LYTrimHead(content);
	LYTrimTail(content);
d2295 1
a2295 1
	       !strcasecomp((http_equiv ? http_equiv : ""), "Content-Type")) {
a2299 2
	LYTrimHead(content);
	LYTrimTail(content);
d2302 1
a2302 3
	if ((cp = strstr(content, "text/html;")) != NULL &&
	    (cp1 = strstr(content, "charset")) != NULL &&
	    cp1 > cp) {
d2477 1
a2477 1
    } else if (!strcasecomp((http_equiv ? http_equiv : ""), "Refresh")) {
d2480 2
a2481 12
	/*
	 *  Look for the Seconds field. - FM
	 */
	cp = LYSkipBlanks(content);
	if (*cp && isdigit(UCH(*cp))) {
	    cp1 = cp;
	    while (*cp1 && isdigit(UCH(*cp1)))
		cp1++;
	    if (*cp1)
		*cp1++ = '\0';
	    StrAllocCopy(Seconds, cp);
	}
a2482 19
	    /*
	     *	We have the seconds field.
	     *	Now look for a URL field - FM
	     */
	    while (*cp1) {
		if (!strncasecomp(cp1, "URL", 3)) {
		    cp = (cp1 + 3);
		    while (*cp && (*cp == '=' || isspace(UCH(*cp))))
			cp++;
		    cp1 = cp;
		    while (*cp1 && !isspace(UCH(*cp1)))
			cp1++;
		    *cp1 = '\0';
		    if (*cp)
			StrAllocCopy(href, cp);
		    break;
		}
		cp1++;
	    }
d2487 1
a2487 2
		if (!(url_type = LYLegitimizeHREF(me, (char**)&href,
						  TRUE, FALSE))) {
d2507 6
a2512 5
		}
		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL((char **)&href,
d2515 2
d2536 1
d2541 1
a2541 1
		(cp = strrchr(href, '#')) != NULL) {
d2634 1
a2634 1
    } else if (!strcasecomp((http_equiv ? http_equiv : ""), "Set-Cookie")) {
d2716 1
a2716 1
	    if (HText_LastLineSize(me->text, FALSE)) {
d2737 3
a2739 1
		    strncmp(me->sp->style->name, "Div", 3)) ||
d2741 2
a2742 2
		    (!strcmp(me->sp->style->name, "Normal") ||
		     !strcmp(me->sp->style->name, "Preformatted")))) {
d3001 1
d3003 1
a3003 1
    char *fragment = NULL;
d3005 1
a3005 1
    if (!me || !href || *href == NULL || *(*href) == '\0')
d3016 35
a3050 15
	if ((pound = strchr(*href, '#')) != NULL) {
	    StrAllocCopy(fragment, pound);
	    *pound = '\0';
	    convert_to_spaces(fragment, FALSE);
	}
	/*
	 * No blanks really belong in the HREF, but if it refers to an actual
	 * file, it may actually have blanks in the name.  Try to accommodate.
	 */
	convert_to_spaces(*href, FALSE);
	LYTrimLeading(*href);
	LYTrimTrailing(*href);
	if (fragment != NULL) {
	    StrAllocCat(*href, fragment);
	    FREE(fragment);
d3053 1
a3053 1
    if (*(*href) == '\0')
d3055 6
a3060 2
    LYUCTranslateHTMLString(href, me->tag_charset, me->tag_charset,
			     NO, NO, YES, st_URL);
d3062 1
a3062 1
    if (!url_type && force_slash &&
d3064 1
a3064 3
	 strncmp((me->inBASE ?
	       me->base_href : me->node_anchor->address),
		 "file:", 5)) {
d3075 2
a3076 4
    if ((!url_type && LYStripDotDotURLs && strip_dots && *(*href) == '.') &&
	 !strncasecomp((me->inBASE ?
		     me->base_href : me->node_anchor->address),
		       "http", 4)) {
d3094 3
a3096 7
	if (((temp = HTParse(*href,
			     (me->inBASE ?
			   me->base_href : me->node_anchor->address),
			     PARSE_ALL)) != NULL && temp[0] != '\0') &&
	    (path = HTParse(temp, "",
			    PARSE_PATH+PARSE_PUNCTUATION)) != NULL &&
	    !strncmp(path, "/..", 3)) {
d3099 1
a3099 3
		if ((me->inBASE
		   ? me->base_href[4]
		   : me->node_anchor->address[4]) == 's') {
d3310 1
a3310 1
    if (HText_LastLineSize(me->text, FALSE)) {
d3314 1
a3314 1
    } else if (HText_PreviousLineSize(me->text, FALSE)) {
d3335 1
a3335 1
    if (HText_LastLineSize(me->text, FALSE)) {
d3357 2
a3358 2
	 (!strcmp(me->sp->style->name, "Normal") ||
	  !strcmp(me->sp->style->name, "Preformatted")))) {
d3390 1
a3390 1
    if (strncasecomp(anchor->address, "file:", 5))
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a27 1
#include <HTFont.h>
a44 2
extern HTkcode kanji_code;
extern HTCJKlang HTCJK;
d65 6
d114 2
a115 2
    q = (char *)calloc(1,
		     (strlen(*str) + (4 * amps) + (3 * lts) + (3 * gts) + 1));
d119 83
d222 3
a224 2
    StrAllocCopy(*str, cp);
    FREE(cp);
d240 1
a240 1
    while (str[i] != '\0' && WHITE(str[i]) && (unsigned char)str[i] != (unsigned char)CH_ESC)   /* S/390 -- gil -- 1669 */
d361 1
a361 1
		} else if (!(WHITE(*cp) && (unsigned char)*cp != (unsigned char)CH_ESC)) {  /* S/390 -- gil -- 1686 */
d394 1
a394 1
	CONST char *, 	base)
d457 2
a458 1
	LYAddHtmlSep(href);
d478 1
a478 1
	StrAllocCat(*href, (HTVMS_wwwName((char *)Home_Dir())+1));
d512 1
a512 1
	FILE *, 	fd,
d616 1
d621 1
a621 1
    static char OLstring[8];
d751 1
d756 1
a756 1
    static char OLstring[8];
d887 1
a887 1
	HTStructured *, 	me)
d909 1
a909 1
	HTStructured *, 	me)
a931 618
#ifdef NOTUSED_FOTEMODS
/*
**  This function reallocates an allocated string and converts
**  characters for the current display character set.  It assumes
**  that invalid control characters have been dealt with by the
**  SGML (or other initial) parser of the document input stream
**  (i.e., are present only if elements or global flags have been
**  set to allow them), and that otherwise this is a copy of the
**  string with the charset of the input stream.  It handles Lynx
**  special characters based on the 'me' structure's element values
**  (the me->UsePlainSpace and me->HiddenValue elements, and its
**  chartrans related elements), and calls to other functions which
**  return structure element values.  HTChunk functions are used to
**  keep memory allocations at a minimum. - FM
*/
PUBLIC void LYExpandString ARGS2(
	HTStructured *, 	me,
	char **,		str)
{
    char *p = *str;
    HTChunk *s;
    BOOLEAN plain_space, hidden;
    char c;
    unsigned char c_unsign;
    char saved_char_in = '\0';
    BOOLEAN chk;
    UCode_t code, uck;
    char replace_buf [64];
    char utf_buf[8], utf_count = 0;
    char *utf_buf_p = utf_buf;
    UCode_t utf_char = 0, value;
    CONST char *name;
    int i, j, high, low, diff = 0;

    /*
    **	Don't do anything if we have no structure
    **	or string, or are in CJK mode. - FM
    */
    if (!me || !p || *p == '\0' ||
	HTCJK != NOCJK)
	return;

    /*
    **	Set "convenience copies" of me structure
    **	elements. - FM
    */
    plain_space = me->UsePlainSpace;
    hidden = me->HiddenValue;

    /*
    **	Check for special input charsets - FM
    */
    if (!strcmp(me->inUCI->MIMEname, "x-transparent")) {
	/*
	**  Conversions not intended. - FM
	*/
	return;
    }
    if (!strcmp(me->inUCI->MIMEname, "mnemonic") ||
	!strcmp(me->inUCI->MIMEname, "mnemonic+ascii+0")) {
	/*
	**  All ASCII representations of Unicode characters,
	**  and we have no reverse translation code for the
	**  multibyte characters, so punt. - FM
	*/
	return;
    }
    if (me->inUCLYhndl < 0 || me->outUCLYhndl < 0) {
	/*
	**  The chartrans procedure failed, so we don't
	**  do anything, and hope for the best. - FM
	*/
	CTRACE(tfp, "LYExpandString: Bad in (%d) or out (%d) handle(s).\n",
		    me->inUCLYhndl, me->outUCLYhndl);
	return;
    }

    /*
    **	Zero the UTF-8 multibytes buffer. - FM
    */
    utf_buf[0] = utf_buf[6] = utf_buf[7] = '\0';

    /*
    **	Set up an HTChunk for accumulating the expanded copy
    **	of the string, so that allocations are done in 128
    **	byte increments, only as required. - FM
    */
    s = HTChunkCreate(128);

    /*
    **	Check each character in the original string,
    **	and add the characters or substitutions to
    **	our clean copy. - FM
    */
    for (i = 0; p[i]; i++) {
	/*
	**  Make sure the character is handled as Unicode
	**  whenever that's appropriate.  - FM
	*/
	c = p[i];
	c_unsign = (unsigned char)c;
	code = (UCode_t)c_unsign;
	saved_char_in = '\0';
	/*
	**  Combine any UTF-8 multibytes into Unicode
	**  to check for special characters. - FM
	*/
	if (me->T.decode_utf8) {
	    /*
	    **	Our input charset is UTF-8, so check
	    **	for non-ASCII characters. - FM
	    */
	    if (TOASCII(c_unsign) > 127) {  /* S/390 -- gil -- 1703 */
		/*
		**  We have an octet from a multibyte character. - FM
		*/
		if (utf_count > 0 && (c & 0xc0) == 0x80) {
		    /*
		    **	Adjust the UCode_t value, add the octet
		    **	to the buffer, and decrement the byte
		    **	count. - FM
		    */
		    utf_char = (utf_char << 6) | (c & 0x3f);
		    utf_count--;
		    *utf_buf_p = c;
		    utf_buf_p++;
		    if (utf_count == 0) {
			/*
			**  We have all of the bytes, so terminate
			**  the buffer and set 'code' to the UCode_t
			**  value. - FM
			*/
			*utf_buf_p = '\0';
			code = utf_char;
			/*
			**  Set up the monobyte character
			**  values or non-character flags
			**  and fall through. - FM
			*/
			if (code > 0 && code < 256) {
			    c = ((char)(code & 0xff));
			    c_unsign = (unsigned char)c;
			}
		    } else {
			/*
			**  Get the next byte. - FM
			*/
			continue;
		    }
		} else {
		    /*
		    **	Start handling a new multibyte character. - FM
		    */
		    utf_buf[0] = c;
		    utf_buf_p = &utf_buf[1];
		    if ((c & 0xe0) == 0xc0) {
			utf_count = 1;
			utf_char = (c & 0x1f);
		    } else if ((c & 0xf0) == 0xe0) {
			utf_count = 2;
			utf_char = (c & 0x0f);
		    } else if ((c & 0xf8) == 0xf0) {
			utf_count = 3;
			utf_char = (c & 0x07);
		    } else if ((c & 0xfc) == 0xf8) {
			utf_count = 4;
			utf_char = (c & 0x03);
		    } else if ((c & 0xfe) == 0xfc) {
			utf_count = 5;
			utf_char = (c & 0x01);
		    } else {
			/*
			**  We got garbage, even though it should
			**  have been filtered out by the SGML or
			**  input stream parser, so we'll ignore
			**  it. - FM
			*/
			utf_count = 0;
			utf_buf[0] = '\0';
			utf_buf_p = utf_buf;
		    }
		    /*
		    **	Get the next byte. - FM
		    */
		    continue;
		}
	    } else if (utf_count > 0) {
		/*
		**  Got an ASCII character when expecting
		**  UTF-8 multibytes, so ignore the buffered
		**  multibyte characters and fall through with
		**  the current ASCII character. - FM
		*/
		utf_count = 0;
		utf_buf[0] = '\0';
		utf_buf_p = utf_buf;
		code = (UCode_t)c_unsign;
	    } else {
		/*
		**  Got a valid ASCII character, so fall
		**  through with it. - FM
		*/
		code = (UCode_t)c_unsign;
	    }
	}
	/*
	**  Convert characters from non-UTF-8 charsets
	**  to Unicode (if appropriate). - FM
	*/
	if (!(me->T.decode_utf8 &&
	      (unsigned char)p[i] > 127)) {
#ifdef NOTDEFINED
	    if (me->T.strip_raw_char_in)
		saved_char_in = c;
#endif /* NOTDEFINED */
	    if (me->T.trans_to_uni &&
		(code >= LYlowest_eightbit[me->inUCLYhndl] ||
		 (code < 32 && code != 0 &&
		  me->T.trans_C0_to_uni))) {
		/*
		**  Convert the octet to Unicode. - FM
		*/
		code = (UCode_t)UCTransToUni(c, me->inUCLYhndl);
		if (code > 0) {
		    saved_char_in = c;
		    if (code < 256) {
			c = ((char)(code & 0xff));
			c_unsign = (unsigned char)c;
		    }
		}
	    } else if (code < ' ' && code != 0 &&  /* S/390 -- gil -- 1720 */
		       me->T.trans_C0_to_uni) {
		/*
		**  Quote from SGML.c:
		**	"This else if may be too ugly to keep. - KW"
		*/
		if (me->T.trans_from_uni &&
		    (((code = UCTransToUni(c, me->inUCLYhndl)) >= ' ') ||  /* S/390 -- gil -- 1737 */
		     (me->T.transp &&
		      (code = UCTransToUni(c, me->inUCLYhndl)) > 0))) {
		    saved_char_in = c;
		    if (code < 256) {
			c = ((char)(code & 0xff));
			c_unsign = (unsigned char)c;
		    }
		} else {
		    uck = -1;
		    if (me->T.transp) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->inUCLYhndl, NO);
		    }
		    if (!me->T.transp || uck < 0) {
			uck = UCTransCharStr(replace_buf, 60, c,
					     me->inUCLYhndl,
					     me->outUCLYhndl, YES);
		    }
		    if (uck == 0) {
			continue;
		    } else if (uck < 0) {
			utf_buf[0] = '\0';
			code = (unsigned char)c;
		    } else {
			c = replace_buf[0];
			if (c && replace_buf[1]) {
			    HTChunkPuts(s, replace_buf);
			    continue;
			}
		    }
		    utf_buf[0] = '\0';
		    code = (unsigned char)c;
		} /*  Next line end of ugly stuff for C0. - KW */
	    } else {
		utf_buf[0] = '\0';
		code = (unsigned char)c;
	    }
	}
	/*
	**  Ignore low ISO 646 7-bit control characters
	**  if they sneaked through (should have been
	**  filtered by the parser). - FM
	*/
	if (code < ' ' &&  /* S/390 -- gil -- 1754 */
	    c != 9 && c != 10 && c != 13) {
	    continue;
	}
	/*
	**  Ignore 127 if we don't have HTPassHighCtrlRaw
	**  and it sneaked through (should have been
	**  filtered by the parser). - FM
	*/
	if (TOASCII(c) == 127 &&  /* S/390 -- gil -- 1771 */
	    !(me->T.transp ||
	      code >= LYlowest_eightbit[me->inUCLYhndl])) {
	    continue;
	}
	/*
	**  Ignore 8-bit control characters 128 - 159 if we don't
	**  have HTPassHighCtrlRaw set and they sneaked through
	**  (should have been filtered by the parser). - FM
	*/
	if (TOASCII(code) > 127 && TOASCII(code) < 160 &&  /* S/390 -- gil -- 1788 */
	    !(me->T.transp ||
	      code >= LYlowest_eightbit[me->inUCLYhndl])) {
	    continue;
	}
	/*
	**  For 160 (nbsp), substitute Lynx special character
	**  (or a space if plain_space or hidden is set) if
	**  HTPassHighCtrlRaw is not set. - FM
	*/
	if (code == CH_NBSP) {  /* S/390 -- gil -- 1805 */
	    if (!me->T.pass_160_173_raw) {
		if (plain_space || hidden) {
		    HTChunkPutc(s, ' ');
		} else {
		    HTChunkPutc(s, HT_NON_BREAK_SPACE);
		}
	    } else if (!me->T.output_utf8) {
		HTChunkPutc(s, ((char)(code & 0xff)));
	    } else if (me->T.decode_utf8 && *utf_buf) {
		HTChunkPuts(s, utf_buf);
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    } else {
		HTChunkPutUtf8Char(s, code);
	    }
	    continue;
	}
	/*
	**  For 173 (shy), substitute Lynx special character
	**  (or skip it if plain_space or hidden is set) if
	**  HTPassHighCtrlRaw is not set. - FM
	*/
	if (code == CH_SHY) {  /* S/390 -- gil -- 1822 */
	    if (!me->T.pass_160_173_raw) {
		if (!(plain_space || hidden)) {
		    HTChunkPutc(s, LY_SOFT_HYPHEN);
		}
	    } else if (!me->T.output_utf8) {
		HTChunkPutc(s, ((char)(code & 0xff)));
	    } else if (me->T.decode_utf8 && *utf_buf) {
		HTChunkPuts(s, utf_buf);
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    } else {
		HTChunkPutUtf8Char(s, code);
	    }
	    continue;
	}
	/*
	**  For 8194 (ensp), 8195 (emsp), or 8201 (thinsp), use
	**  an ASCII space (32) if plain_space or hidden is TRUE,
	**  otherwise use the Lynx special character. - FM
	*/
	if (code == 8194 || code == 8195 || code == 8201) {
	    if (plain_space || hidden) {
		HTChunkPutc(s, ' ');
	    } else {
		HTChunkPutc(s, HT_EN_SPACE);
	    }
	    if (me->T.decode_utf8 && *utf_buf) {
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    }
	    continue;
	}
	/*
	**  If we want the raw character, pass it now. - FM
	*/
	if (me->T.use_raw_char_in && saved_char_in) {
	    HTChunkPutc(s, saved_char_in);
	    continue;
	}
	/*
	**  Seek a translation from the chartrans tables.
	*/
	if ((chk = (me->T.trans_from_uni && code >= 160)) &&
	    (uck = UCTransUniChar(code, me->outUCLYhndl)) >= 32 &&
	    uck < 256 &&
	    (uck < 127 ||
	     uck >= LYlowest_eightbit[me->outUCLYhndl])) {
	    HTChunkPutc(s, ((char)(uck & 0xff)));
	    continue;
	} else if (chk &&
		   (uck == -4 ||
		    (me->T.repl_translated_C0 &&
		     uck > 0 && uck < ' ')) &&  /* S/390 -- gil -- 1839 */
		   /*
		   **  Not found; look for replacement string.
		   */
		   (uck = UCTransUniCharStr(replace_buf,
					    60, code,
					    me->outUCLYhndl,
					    0) >= 0)) {
	    /*
	    **	Got a replacement string.
	    */
	    HTChunkPuts(s, replace_buf);
	    continue;
	}
	/*
	**  If we want raw UTF-8, output that now. - FM
	*/
	if (me->T.output_utf8 &&
	    TOASCII(code) > 127 && code <= 0x7fffffffL) {  /* S/390 -- gil -- 1856 */
	    if (me->T.decode_utf8 && *utf_buf) {
		HTChunkPuts(s, utf_buf);
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    } else {
		HTChunkPutUtf8Char(s, code);
	    }
	    continue;
	}
	/*
	**  If it's any other (> 160) 8-bit character
	**  and we have not set HTPassEightBitRaw
	**  nor have the "ISO Latin 1" character set selected,
	**  back translate for our character set. - FM
	*/
	if (code > 160 && code < 256 &&
	     me->outUCLYhndl != LATIN1 &&
	     (!(HTPassEightBitRaw ||
		(me->T.do_8bitraw && !me->T.trans_from_uni)))) {
	    value = (code - 160);
	    name = HTMLGetEntityName(value);
	    for (low = 0, high = HTML_dtd.number_of_entities;
		 high > low;
		 diff < 0 ? (low = j+1) : (high = j)) {
		/*
		**  Binary search.
		*/
		j = (low + (high-low)/2);
		diff = strcmp(HTML_dtd.entity_names[j], name);
		if (diff == 0) {
		    HTChunkPuts(s, LYCharSets[me->outUCLYhndl][j]);
		    break;
		}
	    }
	    if (diff == 0) {
		continue;
	    }
	}
	/*
	**  If it's ASCII at this point, use it. - FM
	*/
	if (TOASCII(code) < 127 && code > 0) {  /* S/390 -- gil -- 1873 */
	    HTChunkPutc(s, ((char)(code & 0xff)));
	    continue;
	}
	/*
	**  At this point, if we should have translated, the
	**  translation has failed.  We should have sent UTF-8
	**  output to the parser already, but what the heck,
	**  try again. - FM
	*/
	if (me->T.output_utf8 && *utf_buf) {
	    HTChunkPuts(s, utf_buf);
	    utf_buf[0] == '\0';
	    utf_buf_p = utf_buf;
	    continue;
	}
#ifdef NOTDEFINED
	/*
	**  Check for a strippable koi8-r 8-bit character. - FM
	*/
	if (me->T.strip_raw_char_in &&
	    (unsigned char)saved_char_in >= 192 &&
	    (unsigned char)saved_char_in < 255 &&
	    saved_char_in) {
	    /*
	    **	KOI8 special: strip high bit, gives (somewhat) readable
	    **	ASCII or KOI7 - it was constructed that way! - KW
	    */
	    HTChunkPutc(s, (saved_char_in & 0x7f));
	    continue;
	}
#endif /* NOTDEFINED */
	/*
	**  Ignore 8204 (zwnj), 8205 (zwj)
	**  8206 (lrm), and 8207 (rlm),
	**  if we get to here. - FM
	*/
	if (code == 8204 || code == 8205 ||
	    code == 8206 || code == 8207) {
	    CTRACE(tfp, "LYExpandString: Ignoring '%ld'.\n", code);
	    if (me->T.decode_utf8 && *utf_buf) {
		utf_buf[0] == '\0';
		utf_buf_p = utf_buf;
	    }
	    continue;
	}
	/*
	**  If we don't actually want the character,
	**  make it safe and output that now. - FM
	*/
	if ((c_unsign > 0 &&
	     c_unsign < LYlowest_eightbit[me->outUCLYhndl]) ||
	    (me->T.trans_from_uni && !HTPassEightBitRaw)) {
	    /*
	    **	If we do not have the "7-bit approximations" as our
	    **	output character set (in which case we did it already)
	    **	seek a translation for that.  Otherwise, or if the
	    **	translation fails, use UHHH notation. - FM
	    */
	    if ((chk = (me->outUCLYhndl !=
			UCGetLYhndl_byMIME("us-ascii"))) &&
		(uck = UCTransUniChar(code,
				      UCGetLYhndl_byMIME("us-ascii")))
				      >= ' ' && TOASCII(uck) < 127) {  /* S/390 -- gil -- 1890 */
		/*
		**  Got an ASCII character (yippey). - FM
		*/
		c = ((char)(uck & 0xff));
		HTChunkPutc(s, c);
		continue;
	    } else if ((uck == -4) &&
		       (uck = UCTransUniCharStr(replace_buf,
						60, code,
						UCGetLYhndl_byMIME("us-ascii"),
						0) >= 0)) {
		/*
		**  Got a replacement string (yippey). - FM
		*/
		HTChunkPuts(s, replace_buf);
		continue;
	    } else {
		/*
		**  Out of luck, so use the UHHH notation (ugh). - FM
		*/
		sprintf(replace_buf, "U%.2lX", TOASCII(code));  /* S/390 -- gil -- 1907 */
		HTChunkPuts(s, replace_buf);
		continue;
	    }
	}
	/*
	**  If we get to here and have a monobyte character,
	**  pass it. - FM
	*/
	if (c_unsign > 0 && c_unsign < 256) {
	    HTChunkPutc(s, c);
	}
    }

    /*
    **	Terminate the expanded string,
    **	replace the original, and free
    **	the chunk. - FM
    */
    HTChunkTerminate(s);
    StrAllocCopy(*str, s->data);
    HTChunkFree(s);
}
#endif /* NOTUSED_FOTEMODS */

/*
** Get UCS character code for one character from UTF-8 encoded string.
**
** On entry:
**	*ppuni should point to beginning of UTF-8 encoding character
** On exit:
**	*ppuni is advanced to point to the last byte of UTF-8 sequence,
**		if there was a valid one; otherwise unchanged.
** returns the UCS value
** returns negative value on error (invalid UTF-8 sequence)
*/
PRIVATE UCode_t UCGetUniFromUtf8String ARGS1(char **, ppuni)
{
    UCode_t uc_out = 0;
    char * p = *ppuni;
    int utf_count, i;
    if (!(**ppuni&0x80))
	return (UCode_t) **ppuni; /* ASCII range character */
    else if (!(**ppuni&0x40))
	return (-1);		/* not a valid UTF-8 start */
    if ((*p & 0xe0) == 0xc0) {
	utf_count = 1;
    } else if ((*p & 0xf0) == 0xe0) {
	utf_count = 2;
    } else if ((*p & 0xf8) == 0xf0) {
	utf_count = 3;
    } else if ((*p & 0xfc) == 0xf8) {
	utf_count = 4;
    } else if ((*p & 0xfe) == 0xfc) {
	utf_count = 5;
    } else { /* garbage */
	return (-1);
    }
    for (p = *ppuni, i = 0; i < utf_count ; i++) {
	if ((*(++p) & 0xc0) != 0x80)
	    return (-1);
    }
    p = *ppuni;
    switch (utf_count) {
    case 1:
	uc_out = (((*p&0x1f) << 6) | (*(p+1)&0x3f));
	break;
    case 2:
	uc_out = (((((*p&0x0f) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f));
	break;
    case 3:
	uc_out = (((((((*p&0x07) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
	    | (*(p+3)&0x3f));
	break;
    case 4:
	uc_out = (((((((((*p&0x03) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f));
	break;
    case 5:
	uc_out = (((((((((((*p&0x01) << 6) | (*(p+1)&0x3f)) << 6) | (*(p+2)&0x3f)) << 6)
		  | (*(p+3)&0x3f)) << 6) | (*(p+4)&0x3f)) << 6) | (*(p+5)&0x3f));
	break;
    }
    *ppuni = p + utf_count;
    return uc_out;
}

d1068 1
a1068 1
PRIVATE char ** LYUCFullyTranslateString_1 ARGS9(
d1106 6
d1128 1
a1128 1
    **	are both iso-8859-1,
d1131 5
a1135 3
    no_bytetrans = ((cs_to <= 0 && cs_from == cs_to) ||
		    HTCJK != NOCJK);

d1137 3
a1139 4
    if (!no_bytetrans)
	no_bytetrans = (!use_lynx_specials && !Back &&
			UCNeedNotTranslate(cs_from, cs_to));

d1165 1
a1165 1
	from_is_utf8 = (LYCharSet_UC[cs_from].enc == UCT_ENC_UTF8);
d1170 1
a1170 1
	output_utf8 = (LYCharSet_UC[cs_to].enc == UCT_ENC_UTF8 ||
d1172 1
a1172 1
	repl_translated_C0 = (LYCharSet_UC[cs_to].enc == UCT_ENC_8BIT_C0);
d1212 21
a1232 1
	    code = (unsigned char)(*p);
d1273 1
a1351 1
			*p = 160;
d1357 6
a1365 1
		    *p = 173;
d1371 6
d1384 1
a1384 1
		    *p = rev_c;
d1399 1
a1399 1
			code = (unsigned char)(*p);
d1418 1
a1418 1
		    code = (unsigned char)(*p);
a1419 8
#ifdef NOTUSED_FOTEMODS
	    } else if (T.strip_raw_char_in &&
		       (unsigned char)(*p) >= 0xc0 &&
		       (unsigned char)(*p) < 255) {
		code = ((*p & 0x7f));
		state = S_got_outchar;
		break;
#endif /* NOTUSED_FOTEMODS */
d1425 3
a1427 3
		    **	Substitute Lynx special character for
		    **	160 (nbsp) if use_lynx_specials is set.
		    */
d1447 2
a1448 2
		    (unsigned char)*(pp+2) < 127 &&
		    isxdigit((unsigned char)*(pp+2))) {
d1452 2
a1453 2
			   (unsigned char)*(pp+1) < 127 &&
			   isdigit((unsigned char)*(pp+1))) {
d1456 2
a1457 2
		} else if ((unsigned char)*pp < 127 &&
			   isalpha((unsigned char)*pp)) {
d1475 3
a1477 3
		while (*p && (unsigned char)*p < 127 &&
		       (what == P_hex ? isxdigit((unsigned char)*p) :
					isdigit((unsigned char)*p))) {
d1677 1
a1677 3
		    if (hidden) {
			;
		    } else if (plain_space) {
d1679 16
d1696 3
a1698 1
			code = HT_NON_BREAK_SPACE;
a1699 2
		    state = S_got_outchar;
		    break;
d1720 1
a1720 1
		    } else {
d1779 1
a1779 1
		    CTRACE(tfp, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code);
d1808 16
d1832 1
d1837 13
a1849 13
		    /*
		    **	Illegal or not yet handled value.
		    **	Return "&#" verbatim and continue
		    **	from there. - FM
		    */
		    *q++ = '&';
		    *q++ = '#';
		    if (what == P_hex)
			*q++ = 'x';
		    if (cpe != '\0')
			*(p-1) = cpe;
		    p = cp;
		    state = S_done;
a1853 7
#ifdef NOTUSED_FOTEMODS
	    } else if (T.strip_raw_char_in &&
		(unsigned char)(*p) >= 0xc0 &&
		(unsigned char)(*p) < 255) {
		code = (((*p) & 0x7f));
		state = S_got_outchar;
#endif /* NOTUSED_FOTEMODS */
d1856 1
a1856 1
		 (unsigned char)(*p) >= lowest_8)) {
d1861 1
a1861 1
		code = (unsigned char)(*p);
d1868 2
a1869 2
	    while (*cp && (unsigned char)*cp < 127 &&
		   isalnum((unsigned char)*cp))
a1872 1
/*	    ppuni = cp - 1; */
d2007 1
a2007 1
PUBLIC BOOL LYUCFullyTranslateString ARGS7(
d2018 1
a2018 1
    if (!LYUCFullyTranslateString_1(str, cs_from, cs_to, TRUE,
d2034 1
a2034 1
    ret = (LYUCFullyTranslateString_1(str, cs_from, cs_to, FALSE,
d2037 1
a2037 1
    return (ret != NULL);
d2044 1
a2044 1
	HTStructured *, 	me,
d2064 1
a2064 1
	LYUCFullyTranslateString(&http_equiv, me->tag_charset, me->tag_charset,
d2076 1
a2076 1
	LYUCFullyTranslateString(&name, me->tag_charset, me->tag_charset,
d2105 1
a2105 1
    CTRACE(tfp, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
d2108 1
a2108 1
		(content ? content : "NULL"));
d2122 1
a2122 1
	LYUCFullyTranslateString(&content, me->tag_charset, me->tag_charset,
d2166 1
a2166 1
			if (isdigit((unsigned char)*cp)) {
d2168 1
a2168 1
			    while (isdigit((unsigned char)*cp))
d2196 1
a2196 1
	LYUCFullyTranslateString(&content, me->tag_charset, me->tag_charset,
d2220 1
a2220 1
	    } else if (LYmktime(content, FALSE) <= 0) {
d2239 1
a2239 1
	LYUCFullyTranslateString(&content, me->tag_charset, me->tag_charset,
d2265 23
d2379 2
a2380 2
		    = (!strncmp(cp4, "iso-8859-", 9) &&
		       isdigit((unsigned char)cp4[9]));
d2382 1
a2382 1
		    = (given_is_8859 || !strncmp(cp4, "windows-", 8) ||
d2386 1
a2386 1
		    = (given_is_8859like &&
d2395 1
a2395 1
			   isdigit((unsigned char)(*cp1)))
d2409 1
a2409 1
		CTRACE(tfp,
d2411 1
a2411 1
			me->node_anchor->charset);
d2429 1
a2429 1
	if (*cp && isdigit(*cp)) {
d2431 1
a2431 1
	    while (*cp1 && isdigit(*cp1))
d2445 1
a2445 1
		    while (*cp && (*cp == '=' || isspace((unsigned char)*cp)))
d2448 1
a2448 1
		    while (*cp1 && !isspace((unsigned char)*cp1))
d2508 3
d2516 1
d2639 2
a2640 2
PUBLIC void LYHandleP ARGS5(
	HTStructured *, 	me,
d2644 1
d2707 2
a2708 1
	} else if (me->List_Nesting_Level >= 0 ||
d2714 1
a2714 1
	    me->sp->style->alignment = me->current_default_alignment;
d2718 2
a2719 2
	    if (present && present[HTML_P_ALIGN] && value[HTML_P_ALIGN]) {
		if (!strcasecomp(value[HTML_P_ALIGN], "center") &&
d2722 1
a2722 1
		else if (!strcasecomp(value[HTML_P_ALIGN], "right") &&
d2725 2
a2726 2
		else if (!strcasecomp(value[HTML_P_ALIGN], "left") ||
			 !strcasecomp(value[HTML_P_ALIGN], "justify"))
a2729 1
	    CHECK_ID(HTML_P_ID);
d2749 1
a2749 1
	HTStructured *, 	me,
d2771 3
a2773 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: SELECT start tag not within FORM tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d2790 2
a2791 6
	    if (TRACE) {
		fprintf(tfp, "Bad HTML: Missing TEXTAREA end tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
a2813 3
#ifdef NOTDEFINED
	    StrAllocCopy(size, value[HTML_SELECT_SIZE]);
#else
d2817 2
a2818 3
	    CTRACE(tfp, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
			value[HTML_SELECT_SIZE]);
#endif /* NOTDEFINED */
d2866 2
a2867 6
	    if (TRACE) {
		fprintf(tfp, "Bad HTML: Unmatched SELECT end tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d2964 1
a2964 1
	HTStructured *, 	me,
d2989 7
a2995 1
	LYRemoveBlanks(*href);
d3003 1
a3003 1
    LYUCFullyTranslateString(href, me->tag_charset, me->tag_charset,
d3051 3
a3053 2
		if ((me->inBASE ?
	       me->base_href[4] : me->node_anchor->address[4]) == 's') {
d3056 4
a3059 7
		if (TRACE) {
		    fprintf(tfp,
			 "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n",
			   *href, str);
		    fprintf(tfp,
			 "                  Stripping lead dots.\n");
		} else if (!me->inBadHREF) {
d3094 1
a3094 1
	HTStructured *, 	me)
d3162 1
a3162 1
	HTStructured *, 	me,
d3179 1
a3179 1
	LYUCFullyTranslateString(&temp, me->tag_charset, me->tag_charset,
d3204 2
a3205 2
	HTStructured *, 	me,
	char *, 		id)
d3315 1
a3315 1
	me->sp->style->alignment = me->current_default_alignment;
d3392 1
a3392 1
	    if ((unsigned char)*cp >= 127 || !isgraph((unsigned char)*cp)) {
d3402 1
a3402 1
	if (!LYUCFullyTranslateString(&messageid, 0, 0, NO, NO, YES, st_URL))
d3405 1
a3405 1
	    if ((unsigned char)*p >= 127 || !isgraph((unsigned char)*p)) {
d3436 1
a3436 1
	    if ((unsigned char)*cp >= 127 || !isprint((unsigned char)*cp)) {
d3454 1
a3454 1
	if (!LYUCFullyTranslateString(&subject, 0, 0, NO, YES, NO, st_HTML))
d3457 1
a3457 1
	    if ((unsigned char)*p >= 127 || !isprint((unsigned char)*p)) {
d3479 36
@


1.1
log
@Initial revision
@
text
@d5 2
a6 3
#include "HTUtils.h"
#include "tcp.h"
#include "SGML.h"
d9 29
a37 29
#include "HTChunk.h"
#include "HText.h"
#include "HTStyle.h"
#include "HTMIME.h"
#include "HTML.h"

#include "HTCJK.h"
#include "HTAtom.h"
#include "HTMLGen.h"
#include "HTParse.h"
#include "UCMap.h"
#include "UCDefs.h"
#include "UCAux.h"

#include "LYGlobalDefs.h"
#include "LYCharUtils.h"
#include "LYCharSets.h"

#include "HTAlert.h"
#include "HTFont.h"
#include "HTForms.h"
#include "HTNestedList.h"
#include "GridText.h"
#include "LYSignal.h"
#include "LYUtils.h"
#include "LYMap.h"
#include "LYBookmark.h"
#include "LYCurses.h"
#include "LYCookie.h"
d39 2
a40 11
#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */
#ifdef DOSPATH
#include "HTDOS.h"
#endif

#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d142 1
a142 1
**  including HT_NON_BREAK_SPACE (1) and HT_EM_SPACE (2),
d153 1
a153 1
    while (str[i] != '\0' && WHITE(str[i]) && (unsigned char)str[i] != 27)
d165 1
a165 1
**  including HT_NON_BREAK_SPACE (1), HT_EM_SPACE (2), and
d274 1
a274 1
		} else if (!(WHITE(*cp) && (unsigned char)*cp != 27)) {
d307 1
a307 1
	char *, 	base)
d328 2
a329 3
	    StrAllocCopy(*href, "file://localhost");
	    StrAllocCat(*href, temp);
	} else if (!strncmp(*href, "file:/", 6) && *(*href+6) != '/') {
d331 1
a331 2
	    StrAllocCopy(*href, "file://localhost");
	    StrAllocCat(*href, temp);
d335 23
d367 2
a368 11
	char curdir[DIRNAMESIZE];
#if HAVE_GETCWD
	getcwd (curdir, DIRNAMESIZE);
#else
	getwd (curdir);
#endif /* NO_GETCWD */
#ifdef DOSPATH
	temp2 = HTDOS_wwwName(curdir);
#else
	temp2 = curdir;
#endif /* DOSPATH */
d370 1
a370 2
	if (temp2[0] != '/')
	    StrAllocCat(*href, "/");
d421 1
a421 1
** 								 - LP
d842 1
a842 1
#if NOTUSED_FOTEMODS
d848 1
a848 1
**  (i.e. are present only if elements or global flags have been
d914 1
a914 3
	if (TRACE) {
	    fprintf(stderr,
		    "LYExpandString: Bad in (%d) or out (%d) handle(s).\n",
a915 1
	}
d954 1
a954 1
	    if (c_unsign > 127) {
d1058 1
a1058 1
		(code >= 127 ||
d1072 1
a1072 1
	    } else if (code < 32 && code != 0 &&
d1079 1
a1079 1
		    (((code = UCTransToUni(c, me->inUCLYhndl)) >= 32) ||
d1124 1
a1124 1
	if (code < 32 &&
d1133 1
a1133 1
	if (c == 127 &&
d1143 1
a1143 1
	if (code > 127 && code < 160 &&
d1153 1
a1153 1
	if (code == 160) {
d1176 1
a1176 1
	if (code == 173) {
d1201 1
a1201 1
		HTChunkPutc(s, HT_EM_SPACE);
d1229 1
a1229 1
		     uck > 0 && uck < 32)) &&
d1247 1
a1247 1
	    code > 127 && code <= 0x7fffffffL) {
d1264 1
a1264 1
	     me->outUCLYhndl != 0 &&
d1289 1
a1289 1
	if (code < 127 && code > 0) {
d1328 1
a1328 4
	    if (TRACE) {
		fprintf(stderr,
			"LYExpandString: Ignoring '%ld'.\n", code);
	    }
d1352 1
a1352 1
				      >= 32 && uck < 127) {
d1373 1
a1373 1
		sprintf(replace_buf, "U%.2lX", code);
d1513 1
a1513 1
PRIVATE char *hex = "0123456789ABCDEF";
d1516 2
a1517 2
 *	  Any raw 8-bit or multibyte characters already have been 
 *	  handled in relation to the display character set        
d1536 1
a1536 1
**  `use_lynx_specials', `plain_space' and `hidden'. It is not clear yet:
d1550 1
a1550 1
**  If `Back' is YES, the reverse is done instead i.e. Lynx special codes
d1568 1
a1568 1
**  - dropped		if `stype'  is st_other, otherwise (i.e. st_HTML)
d1580 14
d1846 1
a1846 1
		    (*p) == HT_EM_SPACE) {
d2000 135
d2251 1
a2251 1
			code = HT_EM_SPACE;
d2263 1
a2263 4
		    if (TRACE) {
			fprintf(stderr,
				"LYUCFullyTranslateString: Ignoring '%ld'.\n", code);
		    }
d2286 1
a2286 3
			    (HTPassEightBitNum ||
			     !strncmp(LYchar_set_names[cs_to],
				      "ISO Latin 1", 11)))) {
d2355 6
d2362 2
a2363 1
	    if ((code = HTMLGetEntityUCValue(name)) > 0) {
d2405 1
d2430 2
a2431 2
		(code >= 127 ||
		 (code < 32 && (code != 9 && code != 10)))) {
d2449 2
a2450 2
	    REPLACE_CHAR(hex[(code >> 4) & 15]);
	    REPLACE_CHAR(hex[(code & 15)]);
d2522 1
a2522 1
	char **,		include)
d2527 1
a2527 1
    int url_type = 0, i;
d2580 1
a2580 3
    if (TRACE) {
	fprintf(stderr,
		"LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",
a2583 1
    }
d2615 1
a2615 2
	    for (i = 0; content[i]; i++)
		 content[i] = TOLOWER(content[i]);
d2713 1
d2718 1
a2718 5
	/*
	 *  Force the Content-type value to all lower case. - FM
	 */
	for (cp = content; *cp; cp++)
	    *cp = TOLOWER(*cp);
d2751 2
a2760 5
		LYUCcharset * p_out =
				HTAnchor_setUCInfoStage(me->node_anchor,
							current_char_set,
							UCT_STAGE_HTEXT,
							UCT_SETBY_DEFAULT);
d2763 4
d2798 1
a2798 21
		    if (LYRawMode) {
			if ((!strcmp(p_in->MIMEname, "euc-jp") ||
			     !strcmp(p_in->MIMEname, "shift_jis")) &&
			    (!strcmp(p_out->MIMEname, "euc-jp") ||
			     !strcmp(p_out->MIMEname, "shift_jis"))) {
			    HTCJK = JAPANESE;
			} else if (!strcmp(p_in->MIMEname, "euc-cn") &&
				   !strcmp(p_out->MIMEname, "euc-cn")) {
			    HTCJK = CHINESE;
			} else if (!strcmp(p_in->MIMEname, "big-5") &&
				   !strcmp(p_out->MIMEname, "big-5")) {
			    HTCJK = TAIPEI;
			} else if (!strcmp(p_in->MIMEname, "euc-kr") &&
				   !strcmp(p_out->MIMEname, "euc-kr")) {
			    HTCJK = KOREAN;
			} else {
			    HTCJK = NOCJK;
			}
		    } else {
			HTCJK = NOCJK;
		    }
a2800 8
	    /*
	     *	Fall through to old behavior.
	     */
	    } else if (!strncmp(cp1, "us-ascii", 8) ||
		       !strncmp(cp1, "iso-8859-1", 10)) {
		StrAllocCopy(me->node_anchor->charset, "iso-8859-1");
		HTCJK = NOCJK;

d2802 27
a2828 1
		 *  Hope it's a match, for now. - FM
d2830 26
a2855 22
		cp1 = &cp4[10];
		while (*cp1 &&
		       isdigit((unsigned char)(*cp1)))
		    cp1++;
		*cp1 = '\0';
		StrAllocCopy(me->node_anchor->charset, cp4);
		HTPassEightBitRaw = TRUE;
		HTAlert(me->node_anchor->charset);

	    } else if (!strncmp(cp1, "euc-jp", 6) && HTCJK == JAPANESE) {
		StrAllocCopy(me->node_anchor->charset, "euc-jp");

	    } else if (!strncmp(cp1, "shift_jis", 9) && HTCJK == JAPANESE) {
		StrAllocCopy(me->node_anchor->charset, "shift_jis");

	    } else if (!strncmp(cp1, "iso-2022-jp", 11) &&
				HTCJK == JAPANESE) {
		StrAllocCopy(me->node_anchor->charset, "iso-2022-jp");

	    } else if (!strncmp(cp1, "iso-2022-jp-2", 13) &&
				HTCJK == JAPANESE) {
		StrAllocCopy(me->node_anchor->charset, "iso-2022-jp-2");
a2856 21
	    } else if (!strncmp(cp1, "euc-kr", 6) && HTCJK == KOREAN) {
		StrAllocCopy(me->node_anchor->charset, "euc-kr");

	    } else if (!strncmp(cp1, "iso-2022-kr", 11) && HTCJK == KOREAN) {
		StrAllocCopy(me->node_anchor->charset, "iso-2022-kr");

	    } else if ((!strncmp(cp1, "big5", 4) ||
			!strncmp(cp1, "cn-big5", 7)) &&
		       HTCJK == TAIPEI) {
		StrAllocCopy(me->node_anchor->charset, "big5");

	    } else if (!strncmp(cp1, "euc-cn", 6) && HTCJK == CHINESE) {
		StrAllocCopy(me->node_anchor->charset, "euc-cn");

	    } else if ((!strncmp(cp1, "gb2312", 6) ||
			!strncmp(cp1, "cn-gb", 5)) &&
		       HTCJK == CHINESE) {
		StrAllocCopy(me->node_anchor->charset, "gb2312");

	    } else if (!strncmp(cp1, "iso-2022-cn", 11) && HTCJK == CHINESE) {
		StrAllocCopy(me->node_anchor->charset, "iso-2022-cn");
d2860 2
a2861 2
	    if (TRACE && me->node_anchor->charset) {
		fprintf(stderr,
d2880 1
a2880 3
	cp = content;
	while (*cp && isspace((unsigned char)*cp))
	    cp++;
d2920 1
a2920 1
		    HTAlert(REFRESH_URL_NOT_ABSOLUTE);
d3091 1
a3091 1
	char **,		include,
d3130 1
a3130 1
	     *	We're in an ADDRESS. Treat P as an instruction
d3153 1
a3153 1
	    me->sp->style->alignment = styles[me->sp[0].tag_number]->alignment;
d3199 1
a3199 1
	char **,		include,
d3219 1
a3219 1
		fprintf(stderr,
d3222 1
a3222 1
		_statusline(BAD_HTML_USE_TRACE);
a3223 1
		sleep(MessageSecs);
d3242 1
a3242 1
		fprintf(stderr, "Bad HTML: Missing TEXTAREA end tag\n");
d3244 1
a3244 1
		_statusline(BAD_HTML_USE_TRACE);
a3245 1
		sleep(MessageSecs);
d3275 2
a3276 5
	    if (TRACE) {
		fprintf(stderr,
			"LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",
			(char *)value[HTML_SELECT_SIZE]);
	    }
d3326 1
a3326 1
		fprintf(stderr, "Bad HTML: Unmatched SELECT end tag\n");
d3328 1
a3328 1
		_statusline(BAD_HTML_USE_TRACE);
a3329 1
		sleep(MessageSecs);
d3439 1
a3439 13
    LYTrimHead(*href);
    if (!strncasecomp(*href, "lynxexec:", 9) ||
	!strncasecomp(*href, "lynxprog:", 9)) {
	/*
	 *  The original implementations of these schemes expected
	 *  white space without hex escaping, and did not check
	 *  for hex escaping, so we'll continue to support that,
	 *  until that code is redone in conformance with SGML
	 *  principles.  - FM
	 */
	HTUnEscapeSome(*href, " \r\n\t");
	convert_to_spaces(*href, TRUE);
    } else {
d3452 1
a3452 1
	collapse_spaces(*href);
d3496 2
a3497 1
	char *temp = NULL, *path = NULL, *str = "", *cp;
d3507 1
a3507 1
	    if (*cp == '/' || *cp == '\0') {
d3513 1
a3513 1
		    fprintf(stderr,
d3516 1
a3516 1
		    fprintf(stderr,
d3519 1
a3519 1
		    _statusline(BAD_PARTIAL_REFERENCE);
a3520 1
		    sleep(AlertSecs);
d3525 1
a3525 1
	    } else if (*cp == '/') {
d3571 1
a3571 1
	collapse_spaces(cp);
d3581 1
a3581 1
	collapse_spaces(cp);
a3704 1
	    break;
d3791 1
a3791 1
**  to call such functions inappropriately (e.g. calling a function
d3811 127
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
