head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.22
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.18
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.16
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.14
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.12
	OPENBSD_5_0:1.6.0.10
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.16
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.14
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.12
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.10
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.8
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.06.01.36.12;	author cloder;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.13;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYUpload.c,v 1.40 2013/11/28 11:22:34 tom Exp $
 *
 *  Routines to upload files to the local filesystem.
 *  Created by: Rick Mallett, Carleton University
 *  Report problems to rmallett@@ccs.carleton.ca
 *  Modified 15-Dec-95 George Lindholm (lindholm@@ucs.ubc.ca):
 *	Reread the upload menu page every time, in case the "upload" directory
 *	  has changed (make the current directory that for the upload process).
 *	Prompt for the upload file name if there is no "%s" in the command
 *	  string.  Most protocols allow the user to specify the file name
 *	  from the client side.  Xmodem appears to be the only that can't
 *	  figure out the filename from the transfer data so it needs the
 *	  information from lynx (or an upload script which prompts for it).
 *	  On the other hand, zmodem aborts when you give it a filename on
 *	  the command line (great way of bypassing the nodotfile code :=( ).
 */

#include <HTUtils.h>
#include <HTFile.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYGetFile.h>
#include <LYUpload.h>
#include <LYLocal.h>

#include <LYexit.h>
#include <LYLeaks.h>

#define SUBDIR_COMMAND "cd %s ; "

/*
 * LYUpload uploads a file to a given location using a specified upload method. 
 * It parses an incoming link that looks like:
 *	LYNXDIRED://UPLOAD=<#>/TO=<STRING>
 */
int LYUpload(char *line)
{
    char *method, *directory;
    int method_number;
    int count;
    char *the_upload = 0;
    char tmpbuf[LY_MAXPATH];
    char *filename = NULL;
    lynx_list_item_type *upload_command = 0;
    char *the_command = 0;

    /*
     * Use configured upload commands.
     */
    if ((directory = strstr(line, "TO=")) == NULL)
	goto failed;
    *(directory - 1) = '\0';
    /* go past "Directory=" */
    directory += 3;

    if ((method = strstr(line, "UPLOAD=")) == NULL)
	goto failed;
    /*
     * Go past "Method=".
     */
    method += 7;
    method_number = atoi(method);

    for (count = 0, upload_command = uploaders; count < method_number;
	 count++, upload_command = upload_command->next) ;	/* null body */

    /*
     * Parsed out the Method and the Location?
     */
    if (upload_command->command == NULL) {
	HTAlert(gettext("ERROR! - upload command is misconfigured"));
	goto failed;
    }

    /*
     * Care about the local name?
     */
    if (HTCountCommandArgs(upload_command->command)) {
	/*
	 * Commands have the form "command %s [etc]" where %s is the filename.
	 */
	_statusline(FILENAME_PROMPT);
      retry:
	*tmpbuf = '\0';
	if (LYGetStr(tmpbuf, FALSE, sizeof(tmpbuf), NORECALL) < 0)
	    goto cancelled;

	if (*tmpbuf == '\0')
	    goto cancelled;

	if (strstr(tmpbuf, "../") != NULL) {
	    HTAlert(gettext("Illegal redirection \"../\" found! Request ignored."));
	    goto cancelled;
	} else if (StrChr(tmpbuf, '/') != NULL) {
	    HTAlert(gettext("Illegal character \"/\" found! Request ignored."));
	    goto cancelled;
	} else if (tmpbuf[0] == '~') {
	    HTAlert(gettext("Illegal redirection using \"~\" found! Request ignored."));
	    goto cancelled;
	}
	HTSprintf0(&filename, "%s/%s", directory, tmpbuf);

#ifdef HAVE_POPEN
	if (LYIsPipeCommand(filename)) {
	    HTAlert(CANNOT_WRITE_TO_FILE);
	    _statusline(NEW_FILENAME_PROMPT);
	    goto retry;
	}
#endif
	switch (LYValidateOutput(filename)) {
	case 'Y':
	    break;
	case 'N':
	    goto retry;
	default:
	    goto cancelled;
	}

	/*
	 * See if we can write to it.
	 */
	CTRACE((tfp, "LYUpload: filename is %s", filename));

	HTAddParam(&the_upload, upload_command->command, 1, filename);
	HTEndParam(&the_upload, upload_command->command, 1);
    } else {			/* No substitution, no changes */
	StrAllocCopy(the_upload, upload_command->command);
    }

    HTAddParam(&the_command, SUBDIR_COMMAND, 1, directory);
    HTEndParam(&the_command, SUBDIR_COMMAND, 1);
    StrAllocCat(the_command, the_upload);

    CTRACE((tfp, "command: %s\n", the_command));

    stop_curses();
    LYSystem(the_command);
    start_curses();

    FREE(the_command);
    FREE(the_upload);
#if defined(MULTI_USER_UNIX)
    if (filename != 0)
	chmod(filename, HIDE_CHMOD);
#endif /* UNIX */
    FREE(filename);

    return 1;

  failed:
    HTAlert(gettext("Unable to upload file."));
    return 0;

  cancelled:
    HTInfoMsg(CANCELLING);
    return 0;
}

/*
 * LYUpload_options writes out the current upload choices to a file so that the
 * user can select printers in the same way that they select all other links. 
 * Upload links look like:
 *	LYNXDIRED://UPLOAD=<#>/TO=<STRING>
 */
int LYUpload_options(char **newfile,
		     char *directory)
{
    static char tempfile[LY_MAXPATH];
    FILE *fp0;
    lynx_list_item_type *cur_upload;
    int count;
    char *curloc = NULL;

    if ((fp0 = InternalPageFP(tempfile, TRUE)) == 0)
	return (-1);

#ifdef VMS
    StrAllocCopy(curloc, "/sys$login");
#else
    StrAllocCopy(curloc, HTfullURL_toFile(directory));
    LYTrimPathSep(curloc);
#endif /* VMS */

    LYLocalFileToURL(newfile, tempfile);
    LYRegisterUIPage(*newfile, UIP_UPLOAD_OPTIONS);

    BeginInternalPage(fp0, UPLOAD_OPTIONS_TITLE, UPLOAD_OPTIONS_HELP);

    fprintf(fp0, "<pre>\n");
    fprintf(fp0, "   <em>%s</em> %s\n", gettext("Upload To:"), curloc);
    fprintf(fp0, "\n%s\n", gettext("Upload options:"));

    if (uploaders != NULL) {
	for (count = 0, cur_upload = uploaders;
	     cur_upload != NULL;
	     cur_upload = cur_upload->next, count++) {
	    fprintf(fp0, "   <a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\">",
		    count, curloc);
	    fprintf(fp0, "%s", (cur_upload->name ?
				cur_upload->name : gettext("No Name Given")));
	    fprintf(fp0, "</a>\n");
	}
    } else {
	fprintf(fp0, "   &lt;NONE&gt;\n");
    }

    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);

    LYforce_no_cache = TRUE;
    FREE(curloc);

    return (0);
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d91 1
a91 1
	if (LYgetstr(tmpbuf, VISIBLE, sizeof(tmpbuf), NORECALL) < 0)
d100 1
a100 1
	} else if (strchr(tmpbuf, '/') != NULL) {
a129 4
	if (!LYCanWriteFile(filename)) {
	    goto retry;
	}

d178 1
a178 2
    static char curloc[LY_MAXPATH];
    char *cp;
d184 1
a184 1
    strcpy(curloc, "/sys$login");
d186 1
a186 2
    cp = HTfullURL_toFile(directory);
    strcpy(curloc, cp);
a187 1
    FREE(cp);
d218 1
@


1.5
log
@Use fprintf correctly.
OK deraadt@@
@
text
@d2 14
a15 14
**  Routines to upload files to the local filesystem.
**  Created by: Rick Mallett, Carleton University
**  Report problems to rmallett@@ccs.carleton.ca
**  Modified 15-Dec-95 George Lindholm (lindholm@@ucs.ubc.ca):
**	Reread the upload menu page every time, in case the "upload" directory
**	  has changed (make the current directory that for the upload process).
**	Prompt for the upload file name if there is no "%s" in the command
**	  string.  Most protocols allow the user to specify the file name
**	  from the client side.  Xmodem appears to be the only that can't
**	  figure out the filename from the transfer data so it needs the
**	  information from lynx (or an upload script which prompts for it).
**	  On the other hand, zmodem aborts when you give it a filename on
**	  the command line (great way of bypassing the nodotfile code :=( ).
*/
d36 2
a37 3
 *  LYUpload uploads a file to a given location using a
 *  specified upload method.  It parses an incoming link
 *  that looks like:
d40 1
a40 2
PUBLIC int LYUpload ARGS1(
	char *, 	line)
d52 1
a52 1
     *	Use configured upload commands.
d54 1
a54 1
    if((directory = strstr(line, "TO=")) == NULL)
d60 1
a60 1
    if((method = strstr(line, "UPLOAD=")) == NULL)
d63 1
a63 1
     *	Go past "Method=".
d69 1
a69 2
	count++, upload_command = upload_command->next)
      ; /* null body */
d72 1
a72 1
     *	Parsed out the Method and the Location?
d80 1
a80 1
     *	Care about the local name?
d82 1
a82 1
    if (HTCountCommandArgs (upload_command->command)) {
d84 1
a84 2
	 *  Commands have the form "command %s [etc]"
	 *  where %s is the filename.
d87 1
a87 1
retry:
d124 1
a124 1
	 *  See if we can write to it.
d128 1
a128 1
	if (! LYCanWriteFile(filename)) {
d158 1
a158 1
failed:
d162 1
a162 1
cancelled:
d168 3
a170 3
 *  LYUpload_options writes out the current upload choices to a
 *  file so that the user can select printers in the same way that
 *  they select all other links.  Upload links look like:
d173 2
a174 3
PUBLIC int LYUpload_options ARGS2(
	char **,	newfile,
	char *, 	directory)
d184 1
a184 1
	return(-1);
d190 1
a190 1
    strcpy(curloc,cp);
d209 1
a209 1
			 count, curloc);
d211 1
a211 1
			  cur_upload->name : gettext("No Name Given")));
d224 1
a224 1
    return(0);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d215 1
a215 1
	    fprintf(fp0, (cur_upload->name ?
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d111 1
a111 1
#if HAVE_POPEN
d154 1
a154 1
#ifdef UNIX
d188 1
a188 8
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
a189 1
    }
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a32 2
PUBLIC char LYUploadFileURL[LY_MAXPATH] = "\0";

d49 2
a50 3
    char buffer[LY_MAXPATH];
    lynx_html_item_type *upload_command = 0;
    FILE *fp;
d56 1
a56 1
    if((directory = (char *)strstr(line, "TO=")) == NULL)
d62 1
a62 1
    if((method = (char *)strstr(line, "UPLOAD=")) == NULL)
d109 1
a109 1
	sprintf(buffer, "%s/%s", directory, tmpbuf);
d112 1
a112 1
	if (LYIsPipeCommand(buffer)) {
d118 1
a118 1
	switch (LYValidateOutput(buffer)) {
d130 1
a130 1
	CTRACE(tfp, "LYUpload: filename is %s", buffer);
d132 1
a132 6
	if ((fp = fopen(buffer, "w")) != NULL) {
	    fclose(fp);
	    remove(buffer);
	} else {
	    HTAlert(CANNOT_WRITE_TO_FILE);
	    _statusline(NEW_FILENAME_PROMPT);
d136 1
a136 1
	HTAddParam(&the_upload, upload_command->command, 1, buffer);
d146 1
a146 1
    CTRACE(tfp, "command: %s\n", the_command);
d155 2
a156 1
    chmod(buffer, HIDE_CHMOD);
d158 1
a158 1
    /* don't remove(file); */
d183 1
a183 1
    lynx_html_item_type *cur_upload;
d188 7
a194 2
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
d209 1
a209 1
    strcpy(LYUploadFileURL, *newfile);
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
**	  string. Most protocols allow the user to specify the file name
d17 12
a28 14
#include "HTUtils.h"
#include "tcp.h"
#include "HTParse.h"
#include "HTAlert.h"
#include "LYCurses.h"
#include "LYUtils.h"
#include "LYGlobalDefs.h"
#include "LYSignal.h"
#include "LYStrings.h"
#include "LYClean.h"
#include "LYGetFile.h"
#include "LYUpload.h"
#include "LYSystem.h"
#include "LYLocal.h"
d30 2
a31 2
#include "LYexit.h"
#include "LYLeaks.h"
d33 1
a33 1
#define FREE(x) if (x) {free(x); x = NULL;}
d35 1
a35 1
PUBLIC char LYUploadFileURL[256] = "\0";
d38 1
a38 1
 *  LYUpload uploads a file to a given location using a 
d44 1
a44 1
	char *,		line) 
d46 1
a46 1
    char *method, *directory, *dir;
d49 3
a51 2
    char tmpbuf[256];
    char buffer[256];
a52 2
    int c;
    char *cp;
d54 1
a54 4
    char cmd[512];
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;
#endif /* VMS */
d57 1
a57 1
     *  Use configured upload commands.
d63 1
a63 1
    directory+=3;
d68 1
a68 1
     *  Go past "Method=".
d78 1
a78 1
     *  Parsed out the Method and the Location?
d81 1
a81 2
	_statusline("ERROR! - upload command is misconfigured");
	sleep(AlertSecs);
d86 1
a86 1
     *  Care about the local name?
d88 1
a88 1
    if (strstr(upload_command->command, "%s")) {
d93 1
a93 1
	_statusline("Enter a filename: ");
d103 1
a103 3
	    _statusline(
		    "Illegal redirection \"../\" found! Request ignored.");
	    sleep(AlertSecs);
d106 1
a106 2
	    _statusline("Illegal character \"/\" found! Request ignored.");
	    sleep(AlertSecs);
d109 1
a109 3
	    _statusline(
		"Illegal redirection using \"~\" found! Request ignored.");
	    sleep(AlertSecs);
d114 5
a118 11
	if (no_dotfiles || !show_dotfiles) {
	    if (*buffer == '.' ||
#ifdef VMS
		((cp = strrchr(buffer, ':')) && *(cp+1) == '.') ||
		((cp = strrchr(buffer, ']')) && *(cp+1) == '.') ||
#endif /* VMS */
		((cp = strrchr(buffer, '/')) && *(cp+1) == '.')) {
		_statusline(
		  "File name may not begin with dot. Enter a new filename: ");
		goto retry;
	    }
d120 8
a127 30

	/*
	 *  See if it already exists.
	 */
	if ((fp = fopen(buffer, "r")) != NULL) {
	    fclose(fp);

#ifdef VMS
	    _statusline("File exists. Create higher version? (y/n)");
#else
	    _statusline("File exists. Overwrite? (y/n)");
#endif /* VMS */
	    c = 0;
	    while (TOUPPER(c) != 'Y' && TOUPPER(c) != 'N' && c != 7 && c != 3)
		c = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		goto cancelled;
	    }
#endif /* VMS */

	    if (c == 7 || c == 3) { /* Control-G or Control-C */
		goto cancelled;
	    }

	    if (TOUPPER(c) == 'N') {
		_statusline("Enter a filename: ");
		goto retry;
	    }
d133 2
d139 2
a140 1
	    _statusline("Cannot write to file. Enter a new filename: ");
d144 2
a145 7
#ifdef VMS
	sprintf(tmpbuf, upload_command->command, buffer, "", "", "", "", "");
#else
	cp = quote_pathname(buffer); /* to prevent spoofing of the shell */
	sprintf(tmpbuf, upload_command->command, cp, "", "", "", "", "");
	FREE(cp);
#endif /* VMS */
d147 1
a147 1
	strcpy(tmpbuf, upload_command->command);
d150 6
a155 3
    dir = quote_pathname(directory);
    sprintf(cmd, "cd %s ; %s", dir, tmpbuf);
    FREE(dir);
d157 1
a157 4
    if (TRACE)
	fprintf(stderr, "command: %s\n", cmd);
    system(cmd);
    fflush(stdout);
d159 4
a162 1
#ifdef UNIX 
d164 1
a164 1
#endif /* UNIX */ 
d170 1
a170 2
    _statusline("Unable to upload file.");
    sleep(AlertSecs);
d174 1
a174 2
    _statusline("Cancelling.");
    sleep(InfoSecs);
d186 1
a186 1
	char *,		directory)
d188 1
a188 2
    static char tempfile[256];
    static BOOLEAN first = TRUE;
d192 1
a192 1
    static char curloc[256];
d195 2
a196 17
    if (first) {
	/*
	 *  Get an unused tempfile name. - FM
	 */
        tempname(tempfile, NEW_FILE);
#ifdef VMS
    } else {
        remove(tempfile);   /* Remove duplicates on VMS. */
#endif /* VMS */
    }

    /*
     *  Open the tempfile for writing and set it's
     *  protection in case this wasn't done via an
     *  external umask. - FM
     */
    if ((fp0 = LYNewTxtFile(tempfile)) == NULL) {
d204 1
a204 5
    cp = directory;
    if (!strncmp(cp, "file://localhost", 16))
        cp += 16;
    else if (!strncmp(cp, "file:", 5))
        cp += 5;
d206 2
a207 13
    HTUnEscape(curloc);
    if (curloc[strlen(curloc) - 1] == '/')
        curloc[strlen(curloc) - 1] = '\0';
#endif /* VMS */

    if (first) {
	/*
	 *  Make the tempfile a URL.
 	 */
#if defined (VMS) || defined (DOSPATH)
	sprintf(LYUploadFileURL, "file://localhost/%s", tempfile);
#else
	sprintf(LYUploadFileURL, "file://localhost%s", tempfile);
a208 3
	first = FALSE;
    }
    StrAllocCopy(*newfile, LYUploadFileURL);
d210 2
a211 2
    fprintf(fp0, "<head>\n<title>%s</title>\n</head>\n<body>\n",
    		 UPLOAD_OPTIONS_TITLE);
d213 1
a213 2
    fprintf(fp0, "<h1>Upload Options (%s Version %s)</h1>\n",
    				      LYNX_NAME, LYNX_VERSION);
d215 3
a217 2
    fputs("You have the following upload choices.<br>\n", fp0);
    fputs("Please select one:<br>\n<pre>\n", fp0);
d221 1
a221 1
	     cur_upload != NULL; 
d225 2
a226 2
	    fprintf(fp0, (cur_upload->name ? 
			  cur_upload->name : "No Name Given"));
d230 2
a231 3
	fprintf(fp0, "\n   \
No other upload methods have been defined yet.  You may define\n   \
an unlimited number of upload methods using the lynx.cfg file.\n");
d233 3
a235 3
    }
    fprintf(fp0, "</pre>\n</body>\n");
    fclose(fp0);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
