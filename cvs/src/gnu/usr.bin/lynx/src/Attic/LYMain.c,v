head	1.17;
access;
symbols
	OPENBSD_5_5:1.15.0.14
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.10
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.8
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.6
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.16;
commitid	EcR8E7r0stjLUV4p;

1.16
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.15;
commitid	lGGuvDWEniklWrQe;

1.15
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.13.17.02.02;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.16.19.59.49;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.07.00.04.58;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.25.14.29.10;	author margarida;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.05.16.44.01;	author deraadt;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.11.07.00.36.04;	author fgsch;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2000.04.30.21.33.17;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.25.18.17.10;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.22.50.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.10.28.18.01.04;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches;
next	;

1.6.6.1
date	2003.01.22.23.54.24;	author miod;	state Exp;
branches;
next	;

1.7.2.1
date	2002.12.04.15.50.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.17
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYMain.c,v 1.253 2014/02/12 23:48:36 tom Exp $
 */
#include <HTUtils.h>
#include <HTTP.h>
#include <HTParse.h>
#include <HTAccess.h>
#include <HTList.h>
#include <HTFile.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <HTInit.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYStyle.h>
#include <HTML.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYMail.h>
#include <LYOptions.h>
#include <LYSignal.h>
#include <LYGetFile.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYReadCFG.h>
#include <LYrcFile.h>
#include <LYKeymap.h>
#include <HTForms.h>
#include <LYList.h>
#include <LYJump.h>

#ifdef USE_SESSIONS
#include <LYSession.h>
#endif

#include <LYMainLoop.h>
#include <LYBookmark.h>
#include <LYCookie.h>
#include <LYPrettySrc.h>
#include <LYShowInfo.h>
#include <LYHistory.h>

#ifdef VMS
#include <HTFTP.h>
#endif /* !DECNET */

#ifdef __DJGPP__
#include <dos.h>
#include <dpmi.h>
#include <io.h>
#include <sys/stat.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifdef __EMX__
#include <io.h>
#endif

#if defined(LOCALE) && (!defined(HAVE_LIBINTL_H) || !defined(LC_ALL))
#undef gettext			/* Solaris locale.h prototypes gettext() */
#include <locale.h>
#ifndef HAVE_GETTEXT
#define gettext(s) s
#endif
#endif /* LOCALE */

#include <LYexit.h>
#include <LYLeaks.h>

/* ahhhhhhhhhh!! Global variables :-< */
#ifdef SOCKS
BOOLEAN socks_flag = TRUE;
#endif /* SOCKS */

#ifdef IGNORE_CTRL_C
BOOLEAN sigint = FALSE;
#endif /* IGNORE_CTRL_C */

#ifdef __DJGPP__
static char init_ctrl_break[1];
#endif /* __DJGPP__ */

#if USE_VMS_MAILER
char *mail_adrs = NULL;		/* the mask for a VMS mail transport */
#endif

#ifdef VMS
	       /* create FIXED 512 binaries */
BOOLEAN UseFixedRecords = USE_FIXED_RECORDS;
#endif /* VMS */

#ifndef VMS
static char *lynx_version_putenv_command = NULL;
char *list_format = NULL;	/* LONG_LIST formatting mask */
#endif /* !VMS */

char *ftp_format = NULL;	/* LONG_LIST formatting mask */

#ifdef SYSLOG_REQUESTED_URLS
char *syslog_txt = NULL;	/* syslog arb text for session */
BOOLEAN syslog_requested_urls = FALSE;
#endif

int cfg_bad_html = BAD_HTML_WARN;

#ifdef DIRED_SUPPORT
BOOLEAN lynx_edit_mode = FALSE;
BOOLEAN no_dired_support = FALSE;
HTList *tagged = NULL;
int LYAutoUncacheDirLists = 2;	/* default dired uncaching behavior */
int dir_list_order = ORDER_BY_NAME;
int dir_list_style = MIXED_STYLE;

#ifdef OK_OVERRIDE
BOOLEAN prev_lynx_edit_mode = FALSE;
#endif /* OK_OVERRIDE */

#ifdef OK_PERMIT
#ifdef NO_CHANGE_EXECUTE_PERMS
BOOLEAN no_change_exec_perms = TRUE;

#else
BOOLEAN no_change_exec_perms = FALSE;
#endif /* NO_CHANGE_EXECUTE_PERMS */
#endif /* OK_PERMIT */

#endif /* DIRED_SUPPORT */

	   /* Number of docs cached in memory */
int HTCacheSize = DEFAULT_CACHE_SIZE;

#if defined(VMS) && defined(VAXC) && !defined(__DECC)
	   /* Don't dump doc cache unless this size is exceeded */
int HTVirtualMemorySize = DEFAULT_VIRTUAL_MEMORY_SIZE;
#endif /* VMS && VAXC && !_DECC */

#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifndef NEVER_ALLOW_REMOTE_EXEC
BOOLEAN local_exec = LOCAL_EXECUTION_LINKS_ALWAYS_ON;

#else
BOOLEAN local_exec = FALSE;
#endif /* NEVER_ALLOW_REMOTE_EXEC */
BOOLEAN local_exec_on_local_files =
LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE;
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

#if defined(LYNXCGI_LINKS) && !defined(VMS)	/* WebSter Mods -jkt */
char *LYCgiDocumentRoot = NULL;	/* DOCUMENT_ROOT in the lynxcgi env */
#endif /* LYNXCGI_LINKS */

#ifdef TRACK_INTERNAL_LINKS
BOOLEAN track_internal_links = TRUE;

#else
BOOLEAN track_internal_links = FALSE;
#endif

#ifdef REVERSE_CLEAR_SCREEN_PROBLEM
BOOLEAN enable_scrollback = TRUE;

#else
BOOLEAN enable_scrollback = FALSE;
#endif /* REVERSE_CLEAR_SCREEN_PROBLEM */

char empty_string[] =
{'\0'};

int display_lines;		/* number of lines in display */
int www_search_result = -1;

			       /* linked list of printers */
lynx_list_item_type *printers = NULL;

			    /* linked list of download options */
lynx_list_item_type *downloaders = NULL;

			    /* linked list of upload options */
#ifdef USE_EXTERNALS
lynx_list_item_type *externals = NULL;

			    /* linked list of external options */
#endif

lynx_list_item_type *uploaders = NULL;
int LYShowColor = SHOW_COLOR_UNKNOWN;	/* to show or not */
int LYrcShowColor = SHOW_COLOR_UNKNOWN;		/* ... last used */

#if !defined(NO_OPTION_FORMS) && !defined(NO_OPTION_MENU)
BOOLEAN LYUseFormsOptions = TRUE;	/* use forms-based options menu */
#endif

BOOLEAN LYJumpFileURL = FALSE;	/* always FALSE the first time */
BOOLEAN LYPermitURL = FALSE;
BOOLEAN LYRestricted = FALSE;	/* whether we have -anonymous option */
BOOLEAN LYShowCursor = SHOW_CURSOR;	/* to show or not to show */
BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS;	/* Show the links underlined vs bold */
BOOLEAN LYUseDefShoCur = TRUE;	/* Command line -show_cursor toggle */
BOOLEAN LYUserSpecifiedURL = TRUE;	/* always TRUE  the first time */
BOOLEAN LYValidate = FALSE;
BOOLEAN LYforce_no_cache = FALSE;
BOOLEAN LYinternal_flag = FALSE;	/* override no-cache b/c internal link */
BOOLEAN LYoverride_no_cache = FALSE;	/*override no-cache b/c history etc */
BOOLEAN LYresubmit_posts = ALWAYS_RESUBMIT_POSTS;
BOOLEAN LYtrimInputFields = FALSE;
BOOLEAN LYxhtml_parsing = FALSE;
BOOLEAN bold_H1 = FALSE;
BOOLEAN bold_headers = FALSE;
BOOLEAN bold_name_anchors = FALSE;
BOOLEAN LYcase_sensitive = CASE_SENSITIVE_ALWAYS_ON;
BOOLEAN check_mail = CHECKMAIL;
BOOLEAN child_lynx = FALSE;
BOOLEAN dump_links_inline = FALSE;
BOOLEAN dump_links_only = FALSE;
BOOLEAN dump_output_immediately = FALSE;
BOOLEAN dump_to_stderr = FALSE;
BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
BOOLEAN goto_buffer = GOTOBUFFER;	/* TRUE if offering default goto URL */
BOOLEAN historical_comments = FALSE;
BOOLEAN html5_charsets = FALSE;
BOOLEAN is_www_index = FALSE;
BOOLEAN jump_buffer = JUMPBUFFER;	/* TRUE if offering default shortcut */
BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
BOOLEAN minimal_comments = FALSE;
BOOLEAN number_fields_on_left = TRUE;
BOOLEAN number_links_on_left = TRUE;
BOOLEAN recent_sizechange = FALSE;	/* the window size changed recently? */
BOOLEAN soft_dquotes = FALSE;
BOOLEAN unique_urls = FALSE;
BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
BOOLEAN verbose_img = VERBOSE_IMAGES;	/* show filenames or not */
BOOLEAN vi_keys = VI_KEYS_ALWAYS_ON;
int keypad_mode = DEFAULT_KEYPAD_MODE;
int user_mode = NOVICE_MODE;

BOOLEAN telnet_ok = TRUE;

#ifndef DISABLE_NEWS
BOOLEAN news_ok = TRUE;
#endif
BOOLEAN rlogin_ok = TRUE;
BOOLEAN long_url_ok = FALSE;
BOOLEAN ftp_ok = TRUE;
BOOLEAN system_editor = FALSE;

BOOLEAN had_restrictions_default = FALSE;
BOOLEAN had_restrictions_all = FALSE;

BOOLEAN exec_frozen = FALSE;
BOOLEAN no_bookmark = FALSE;
BOOLEAN no_bookmark_exec = FALSE;
BOOLEAN no_chdir = FALSE;
BOOLEAN no_disk_save = FALSE;
BOOLEAN no_dotfiles = NO_DOT_FILES;
BOOLEAN no_download = FALSE;
BOOLEAN no_editor = FALSE;
BOOLEAN no_exec = FALSE;
BOOLEAN no_file_url = FALSE;
BOOLEAN no_goto = FALSE;
BOOLEAN no_goto_configinfo = FALSE;
BOOLEAN no_goto_cso = FALSE;
BOOLEAN no_goto_file = FALSE;
BOOLEAN no_goto_finger = FALSE;
BOOLEAN no_goto_ftp = FALSE;
BOOLEAN no_goto_gopher = FALSE;
BOOLEAN no_goto_http = FALSE;
BOOLEAN no_goto_https = FALSE;
BOOLEAN no_goto_lynxcgi = FALSE;
BOOLEAN no_goto_lynxexec = FALSE;
BOOLEAN no_goto_lynxprog = FALSE;
BOOLEAN no_goto_mailto = FALSE;
BOOLEAN no_goto_rlogin = FALSE;
BOOLEAN no_goto_telnet = FALSE;
BOOLEAN no_goto_tn3270 = FALSE;
BOOLEAN no_goto_wais = FALSE;
BOOLEAN no_inside_ftp = FALSE;
BOOLEAN no_inside_rlogin = FALSE;
BOOLEAN no_inside_telnet = FALSE;
BOOLEAN no_jump = FALSE;
BOOLEAN no_lynxcfg_info = FALSE;
BOOLEAN no_lynxcgi = FALSE;
BOOLEAN no_mail = FALSE;
BOOLEAN no_multibook = FALSE;
BOOLEAN no_option_save = FALSE;
BOOLEAN no_outside_ftp = FALSE;
BOOLEAN no_outside_rlogin = FALSE;
BOOLEAN no_outside_telnet = FALSE;
BOOLEAN no_print = FALSE;
BOOLEAN no_shell = FALSE;
BOOLEAN no_suspend = FALSE;
BOOLEAN no_telnet_port = FALSE;
BOOLEAN no_useragent = FALSE;

#ifndef DISABLE_FTP
BOOLEAN ftp_passive = FTP_PASSIVE;	/* TRUE if doing ftp in passive mode */
BOOLEAN ftp_local_passive;
HTList *broken_ftp_epsv = NULL;
HTList *broken_ftp_retr = NULL;
char *ftp_lasthost = NULL;
#endif

#ifndef DISABLE_NEWS
BOOLEAN no_goto_news = FALSE;
BOOLEAN no_goto_nntp = FALSE;
BOOLEAN no_goto_snews = FALSE;
BOOLEAN no_inside_news = FALSE;
BOOLEAN no_newspost = FALSE;
BOOLEAN no_outside_news = FALSE;
#endif

#ifdef USE_EXTERNALS
BOOLEAN no_externals = FALSE;
#endif

#ifndef NO_CONFIG_INFO
BOOLEAN no_lynxcfg_xinfo = FALSE;

#ifdef HAVE_CONFIG_H
BOOLEAN no_compileopts_info = FALSE;
#endif
#endif

BOOLEAN no_statusline = FALSE;
BOOLEAN no_filereferer = TRUE;
char LYRefererWithQuery = 'D';	/* 'D' for drop */
BOOLEAN local_host_only = FALSE;
BOOLEAN override_no_download = FALSE;
BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
BOOLEAN LYforce_HTML_mode = FALSE;
BOOLEAN LYfind_leaks = TRUE;

#ifdef __DJGPP__
BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
BOOLEAN dj_is_bash = FALSE;	/* Check for bash shell under DJGPP */
#endif /* __DJGPP__ */

#ifdef WIN_EX
BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
#endif

#ifdef _WINDOWS
#define	TIMEOUT	180		/* 1998/03/30 (Mon) 14:50:44 */
int lynx_timeout = TIMEOUT;
CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
#endif /* _WINDOWS */

#if defined(WIN_EX)
BOOLEAN system_is_NT = FALSE;
#endif

BOOLEAN show_cfg = FALSE;

BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */

#if USE_BLAT_MAILER
BOOLEAN mail_is_blat = TRUE;
BOOLEAN mail_is_altblat = USE_ALT_BLAT_MAILER;

#if USE_ALT_BLAT_MAILER
#define THIS_BLAT_MAIL ALTBLAT_MAIL
#define THAT_BLAT_MAIL BLAT_MAIL
#else
#define THIS_BLAT_MAIL BLAT_MAIL
#define THAT_BLAT_MAIL ALTBLAT_MAIL
#endif
#endif

#ifdef USE_BLINK
#  ifdef __EMX__
BOOLEAN term_blink_is_boldbg = TRUE;

#  else
BOOLEAN term_blink_is_boldbg = FALSE;

#  endif
#endif

BOOLEAN HEAD_request = FALSE;
BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES;	/* take all cookies? */
BOOLEAN LYCancelledFetch = FALSE;	/* TRUE if cancelled binary fetch */
BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;	/* Collapse serial BRs? */
BOOLEAN LYDefaultRawMode;
BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
BOOLEAN LYNewsPosting = NEWS_POSTING;	/* News posting supported? */
BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?         */
BOOLEAN LYNoRefererForThis = FALSE;	/* No Referer header for this URL? */
BOOLEAN LYNoRefererHeader = FALSE;	/* Never send Referer header?     */
BOOLEAN LYRawMode;
BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
BOOLEAN LYSendUserAgent = SEND_USERAGENT;	/* send Lynx User-Agent header? */
BOOLEAN LYSetCookies = SET_COOKIES;	/* Process Set-Cookie headers? */
BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
BOOLEAN LYUseDefaultRawMode = TRUE;
BOOLEAN LYUseMouse = FALSE;
BOOLEAN LYisConfiguredForX = FALSE;
BOOLEAN UCForce8bitTOUPPER = FALSE;	/* override locale for case-conversion? */
BOOLEAN UCSaveBookmarksInUnicode = FALSE;
BOOLEAN bookmark_start = FALSE;
BOOLEAN check_realm = FALSE;	/* Restrict to the starting realm? */
BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
BOOLEAN crawl = FALSE;		/* Do crawl? */
BOOLEAN keep_mime_headers = FALSE;	/* Include mime headers with source dump */
BOOLEAN more_text = FALSE;	/* is there more text to display? */
BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
BOOLEAN no_list = FALSE;
BOOLEAN no_margins = FALSE;
BOOLEAN no_pause = FALSE;
BOOLEAN no_title = FALSE;
BOOLEAN no_url_redirection = FALSE;	/* Don't follow URL redirections */
BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
BOOLEAN scan_for_buried_news_references = TRUE;
BOOLEAN startfile_ok = FALSE;
static BOOLEAN startfile_stdin = FALSE;
BOOLEAN traversal = FALSE;	/* Do traversals? */

char *BookmarkPage = NULL;	/* the name of the current bookmark page */
char *LYCookieAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieLooseCheckDomains = NULL;		/* check loosely   */
char *LYCookieQueryCheckDomains = NULL;		/* check w/a query */
char *LYCookieRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSAcceptDomains = NULL;	/* domains to accept all cookies */
char *LYCookieSLooseCheckDomains = NULL;	/* check loosely   */
char *LYCookieSQueryCheckDomains = NULL;	/* check w/a query */
char *LYCookieSRejectDomains = NULL;	/* domains to reject all cookies */
char *LYCookieSStrictCheckDomains = NULL;	/* check strictly  */
char *LYCookieStrictCheckDomains = NULL;	/* check strictly  */
char *LYHostName = NULL;	/* treat as a local host name */
char *LYLocalDomain = NULL;	/* treat as a local domain tail */
char *LYUserAgent = NULL;	/* Lynx User-Agent header          */
char *LYUserAgentDefault = NULL;	/* Lynx default User-Agent header  */
char *LynxHome = NULL;		/* the default Home HREF. */
char *LynxSigFile = NULL;	/* Signature file, in or off home */
char *UCAssume_MIMEcharset = NULL;
char *URLDomainPrefixes = NULL;
char *URLDomainSuffixes = NULL;
char *anonftp_password = NULL;	/* anonymous ftp password (default: email) */
char *authentication_info[2] =
{NULL, NULL};			/* Id:Password for protected documents */
char *bookmark_page = NULL;	/* the name of the default bookmark page */
char *editor = NULL;		/* the name of the current editor */
char *form_get_data = NULL;	/* User data for get form */
char *form_post_data = NULL;	/* User data for post form */
char *global_extension_map = NULL;	/* global mime.types */
char *global_type_map = NULL;	/* global mailcap */
char *helpfile = NULL;		/* the main help file */
char *helpfilepath = NULL;	/* the path to the help file set */
char *homepage = NULL;		/* home page or main screen */
char *http_error_file = NULL;	/* Place HTTP status code in this file */
char *indexfile = NULL;		/* an index file if there is one */
char *jumpfile = NULL;		/* the name of the default jumps file */
char *jumpprompt = NULL;	/* the default jumps prompt */
char *language = NULL;		/* preferred language */
char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
char *lynx_cmd_script;		/* file to read keystroke commands, if any */
char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
char *lynxjumpfile = NULL;	/* the current jump file URL */
char *lynxlinksfile = NULL;	/* the current visited links file URL */
char *lynxlistfile = NULL;	/* the current list file URL */
char *original_dir = NULL;	/* the original directory */
char *personal_extension_map = NULL;	/* .mime.types */
char *personal_mail_address = NULL;	/* the user's mail address */
char *personal_mail_name = NULL;	/* the user's personal name mail */
char *personal_type_map = NULL;	/* .mailcap */
char *pref_charset = NULL;	/* preferred character set */
char *proxyauth_info[2] =
{NULL, NULL};			/* Id:Password for protected proxy servers */

#ifdef USE_SESSIONS
BOOLEAN LYAutoSession = FALSE;	/* enable/disable auto saving/restoring of */

				/* session */
char *LYSessionFile = NULL;	/* the session file from lynx.cfg */
char *session_file = NULL;	/* the current session file */
char *sessionin_file = NULL;	/* only resume session from this file */
char *sessionout_file = NULL;	/* only save session to this file */
short session_limit = 250;	/* maximal number of entries saved per */

				/* session file, rest will be ignored */
#endif /* USE_SESSIONS */
char *startfile = NULL;		/* the first file */
char *startrealm = NULL;	/* the startfile realm */
char *system_mail = NULL;	/* The path for sending mail */
char *system_mail_flags = NULL;	/* Flags for sending mail */
char *x_display = NULL;		/* display environment variable */

HistInfo *history;
int nhist = 0;			/* number of used history entries */
int size_history;		/* number of allocated history entries */

LinkInfo links[MAXLINKS];

BOOLEAN nomore = FALSE;		/* display -more- string in statusline messages */
int AlertSecs;			/* time-delay for HTAlert() messages   */
int DelaySecs;			/* time-delay for HTProgress messages */
int InfoSecs;			/* time-delay for Information messages */
int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
int LYStatusLine = -1;		/* Line for statusline() if > -1 */
int LYcols = DFT_COLS;
int LYlines = DFT_ROWS;
int MessageSecs;		/* time-delay for important Messages   */
int ReplaySecs;			/* time-delay for command-scripts */
int crawl_count = 0;		/* Starting number for lnk#.dat files in crawls */
int dump_output_width = 0;
int dump_server_status = 0;
int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
int max_cookies_domain = 50;
int max_cookies_global = 500;
int max_cookies_buffer = 4096;
int max_uri_size = 8192;
int nlinks = 0;			/* number of links in memory */
int outgoing_mail_charset = -1;	/* translate mail to this charset */

#ifndef DISABLE_BIBP
BOOLEAN BibP_bibhost_available = FALSE;		/* until check succeeds  */
BOOLEAN BibP_bibhost_checked = FALSE;	/*  until LYCheckBibHost   */
BOOLEAN no_goto_bibp = FALSE;
char *BibP_bibhost = NULL;	/* local server for bibp: links  */
char *BibP_globalserver = NULL;	/* global server for bibp: links */
#endif

#ifdef USE_PERSISTENT_COOKIES
BOOLEAN persistent_cookies = FALSE;	/* disabled by default! */
char *LYCookieFile = NULL;	/* cookie read file */
char *LYCookieSaveFile = NULL;	/* cookie save file */
#endif /* USE_PERSISTENT_COOKIES */

#ifdef EXP_NESTED_TABLES
BOOLEAN nested_tables =
#if defined(USE_COLOR_STYLE)
TRUE
#else
FALSE				/* see 2001-08-15  */
#endif
 ;
#endif

BOOLEAN LYShowTransferRate = TRUE;
int LYTransferRate = rateKB;
int LYAcceptEncoding = encodingALL;
int LYAcceptMedia = mediaOpt1;
char *LYTransferName = NULL;

char *XLoadImageCommand = NULL;	/* Default image viewer for X */
BOOLEAN LYNoISMAPifUSEMAP = FALSE;	/* Omit ISMAP link if MAP present? */
int LYHiddenLinks = HIDDENLINKS_SEPARATE;	/* Show hidden links? */

char *SSL_cert_file = NULL;	/* Default CA CERT file */

int Old_DTD = NO;
static BOOLEAN DTD_recovery = NO;

#ifndef NO_LYNX_TRACE
FILE *LYTraceLogFP = NULL;	/* Pointer for TRACE log  */
#endif
char *LYTraceLogPath = NULL;	/* Path for TRACE log      */
BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?        */

BOOLEAN LYSeekFragMAPinCur = TRUE;
BOOLEAN LYSeekFragAREAinCur = TRUE;
BOOLEAN LYStripDotDotURLs = TRUE;	/* Try to fix ../ in some URLs? */
BOOLEAN LYForceSSLCookiesSecure = FALSE;
BOOLEAN LYNoCc = FALSE;
BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
BOOLEAN LYPrependBaseToSource = TRUE;
BOOLEAN LYPrependCharsetToSource = TRUE;
BOOLEAN LYQuitDefaultYes = QUIT_DEFAULT_YES;
BOOLEAN dont_wrap_pre = FALSE;

int cookie_noprompt;

#ifdef USE_SSL
int ssl_noprompt = FORCE_PROMPT_DFT;
#endif
BOOLEAN conv_jisx0201kana = TRUE;
BOOLEAN wait_viewer_termination = FALSE;

int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/
int reading_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/

#ifdef USE_JUSTIFY_ELTS
BOOLEAN ok_justify = FALSE;
int justify_max_void_percent = 35;
#endif

#ifdef USE_LOCALE_CHARSET
BOOLEAN LYLocaleCharset = FALSE;
#endif
BOOLEAN assumed_charset = FALSE;

#ifndef NO_DUMP_WITH_BACKSPACES
BOOLEAN with_backspaces = FALSE;
#endif

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
int scrsize_x = 0;
int scrsize_y = 0;
#endif

BOOLEAN force_empty_hrefless_a = FALSE;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
BOOL textfields_need_activation = FALSE;
BOOLEAN textfields_activation_option = FALSE;
#endif

BOOLEAN textfield_prompt_at_left_edge = FALSE;

#ifdef MARK_HIDDEN_LINKS
char *hidden_link_marker = NULL;
#endif

#ifdef DISP_PARTIAL
BOOLEAN display_partial_flag = TRUE;	/* Display document during download */
BOOLEAN debug_display_partial = FALSE;	/* Show with MessageSecs delay */
int partial_threshold = -1;	/* # of lines to be d/l'ed until we repaint */
#endif

BOOLEAN LYNonRestartingSIGWINCH = FALSE;
BOOLEAN LYReuseTempfiles = FALSE;
BOOLEAN LYUseBuiltinSuffixes = TRUE;

#ifdef MISC_EXP
int LYNoZapKey = 0;		/* 0: off (do z checking), 1: full, 2: initially */
#endif

#ifndef DISABLE_NEWS
#include <HTNews.h>
#endif

BOOLEAN FileInitAlreadyDone = FALSE;

#ifdef USE_PROGRAM_DIR
char *program_dir = NULL;
#endif

static BOOLEAN stack_dump = FALSE;
static char *terminal = NULL;
static const char *pgm;
static BOOLEAN no_numbers = FALSE;
static BOOLEAN number_links = FALSE;
static BOOLEAN number_fields = FALSE;
static BOOLEAN LYPrependBase = FALSE;
static HTList *LYStdinArgs = NULL;
HTList *positionable_editor = NULL;

#ifndef EXTENDED_OPTION_LOGIC
/* if set then '--' will be recognized as the end of options */
#define EXTENDED_OPTION_LOGIC 1
#endif

#ifndef EXTENDED_STARTFILE_RECALL
/* if set then additional non-option args (before the last one) will be
   made available for 'g'oto recall - kw */
#define EXTENDED_STARTFILE_RECALL 1
#endif

#if EXTENDED_STARTFILE_RECALL
static char *nonoption = 0;
#endif

#ifndef OPTNAME_ALLOW_DASHES
/* if set, then will allow dashes and underscores to be used interchangeable
   in commandline option's names - VH */
#define OPTNAME_ALLOW_DASHES 1
#endif

static BOOL parse_arg(char **arg, unsigned mask, int *countp);
static void print_help_and_exit(int exit_status) GCC_NORETURN;
static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       int option);

#ifndef VMS
BOOLEAN LYNoCore = NO_FORCED_CORE_DUMP;
BOOLEAN restore_sigpipe_for_children = FALSE;
static void FatalProblem(int sig);
#endif /* !VMS */

#if defined(USE_COLOR_STYLE)
int LYuse_color_style = TRUE;
char *lynx_lss_file = NULL;	/* from config-file, etc. */
static char *lynx_lss_file2 = NULL;	/* from command-line options */
const char *default_color_styles = "\
lynx.lss;\
blue-background.lss;\
bright-blue.lss;\
midnight.lss;\
mild-colors.lss;\
opaque.lss\
";
#endif

#ifdef USE_DEFAULT_COLORS
BOOLEAN LYuse_default_colors = TRUE;
#endif

#ifdef __DJGPP__
static void LY_set_ctrl_break(int setting)
{
    (void) signal(SIGINT, (setting ? SIG_DFL : SIG_IGN));
    setcbrk(setting);
}

static int LY_get_ctrl_break(void)
{
    __dpmi_regs regs;

    regs.h.ah = 0x33;
    regs.h.al = 0x00;
    __dpmi_int(0x21, &regs);
    return ((int) regs.h.dl);
}

static void reset_break(void)
{
    LY_set_ctrl_break(init_ctrl_break[0]);
}
#endif /* __DJGPP__ */

#if defined(WIN_EX)
static int is_windows_nt(void)
{
    DWORD version;

    version = GetVersion();
    if ((version & 0x80000000) == 0)
	return 1;
    else
	return 0;
}
#endif

#ifdef LY_FIND_LEAKS
static void free_lynx_globals(void)
{
    int i;

    FREE(ftp_format);
#ifndef VMS
    FREE(list_format);
#ifdef LYNXCGI_LINKS		/* WebSter Mods -jkt */
    FREE(LYCgiDocumentRoot);
#endif /* LYNXCGI_LINKS */
    free_lynx_cfg();
#endif /* !VMS */

#ifdef SYSLOG_REQUESTED_URLS
    FREE(syslog_txt);
#endif

#ifdef VMS
    Define_VMSLogical("LYNX_VERSION", "");
#endif /* VMS */
#ifndef VMS
    FREE(lynx_version_putenv_command);
#endif

#if USE_VMS_MAILER
    FREE(mail_adrs);
#endif

    FREE(LynxHome);
    FREE(history);
    FREE(homepage);
    FREE(original_dir);
    FREE(startfile);
    FREE(helpfile);
    FREE(helpfilepath);
    FREE(jumpprompt);
#ifdef JUMPFILE
    FREE(jumpfile);
#endif /* JUMPFILE */
    FREE(indexfile);
    FREE(x_display);
    FREE(global_type_map);
    FREE(personal_type_map);
    FREE(global_extension_map);
    FREE(personal_extension_map);
    FREE(language);
    FREE(pref_charset);
    FREE(LynxSigFile);
    FREE(system_mail);
    FREE(system_mail_flags);
#ifndef DISABLE_BIBP
    FREE(BibP_bibhost);
    FREE(BibP_globalserver);
#endif
#ifdef USE_PERSISTENT_COOKIES
    FREE(LYCookieFile);
    FREE(LYCookieSaveFile);
#endif
    FREE(LYCookieAcceptDomains);
    FREE(LYCookieRejectDomains);
    FREE(LYCookieLooseCheckDomains);
    FREE(LYCookieStrictCheckDomains);
    FREE(LYCookieQueryCheckDomains);
    FREE(LYUserAgent);
    FREE(LYUserAgentDefault);
    FREE(LYHostName);
    FREE(LYLocalDomain);
    FREE(lynx_save_space);
    FREE(bookmark_page);
    FREE(BookmarkPage);
    for (i = 0; i <= MBM_V_MAXFILES; i++) {
	FREE(MBM_A_subbookmark[i]);
	FREE(MBM_A_subdescript[i]);
    }
    FREE(editor);
    FREE(authentication_info[0]);
    FREE(authentication_info[1]);
    FREE(proxyauth_info[0]);
    FREE(proxyauth_info[1]);
    FREE(lynxjumpfile);
#ifndef DISABLE_FTP
    FREE(ftp_lasthost);
    LYFreeStringList(broken_ftp_epsv);
    LYFreeStringList(broken_ftp_retr);
#endif
    FREE(startrealm);
    FREE(personal_mail_address);
    FREE(personal_mail_name);
    FREE(anonftp_password);
    FREE(URLDomainPrefixes);
    FREE(URLDomainSuffixes);
    FREE(XLoadImageCommand);
    FREE(lynx_temp_space);
    FREE(LYTransferName);
    FREE(LYTraceLogPath);
    FREE(lynx_cfg_file);
    FREE(SSL_cert_file);
#if defined(USE_COLOR_STYLE)
    FREE(lynx_lss_file2);
    FREE(lynx_lss_file);
#endif
    FREE(UCAssume_MIMEcharset);
    LYUIPages_free();
    LYFreeHilites(0, nlinks);
    nlinks = 0;
    LYFreeStringList(LYcommandList());
    HTInitProgramPaths(FALSE);
#if EXTENDED_STARTFILE_RECALL
    FREE(nonoption);
#endif
    LYFreeStringList(positionable_editor);

    return;
}
#endif /* LY_FIND_LEAKS */

/*
 * This function frees the LYStdinArgs list.  - FM
 */
static void LYStdinArgs_free(void)
{
    LYFreeStringList(LYStdinArgs);
    LYStdinArgs = NULL;
}

void reset_signals(void)
{
#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
    if (no_suspend)
	(void) signal(SIGTSTP, SIG_DFL);
#endif /* SIGTSTP */
}

void exit_immediately(int code)
{
    reset_signals();
    exit(code);
}

#ifdef  EBCDIC
static void FixCharacters(void)
{
    int c;
    int work1[256], work2[256];

    for (c = 0; c < 256; c++) {
	work1[c] = keymap[c + 1];
	work2[c] = key_override[c + 1];
    }
    for (c = 0; c < 256; c++) {
	keymap[IBM1047[c] + 1] = work1[c];
	key_override[IBM1047[c] + 1] = work2[c];
    }
}
#endif /* EBCDIC */

static BOOL GetStdin(char **buf,
		     int marker)
{
    if (LYSafeGets(buf, stdin) != 0
	&& (!marker || StrNCmp(*buf, "---", 3) != 0)) {
	LYTrimTrailing(*buf);
	CTRACE((tfp, "...data: %s\n", *buf));
	return TRUE;
    }
    CTRACE((tfp, "...mark: %s\n", *buf ? *buf : ""));
    return FALSE;
}

#ifdef WIN32
static BOOL cleanup_win32(DWORD fdwCtrlType)
{
    switch (fdwCtrlType) {
    case CTRL_CLOSE_EVENT:
	cleanup_sig(-1);
	return TRUE;
    default:
	return FALSE;
    }
}
#endif

/*
 * Append the SSL version to lynx version or user-agent string.
 */
#ifdef USE_SSL
static void append_ssl_version(char **target,
			       const char *separator)
{
    char SSLLibraryVersion[256];
    char *SSLcp;

    HTSprintf(target, " SSL-MM%s1.4.1", separator);

#undef LYNX_SSL_VERSION

#if defined(SSLEAY_VERSION)
#define LYNX_SSL_VERSION SSLeay_version(SSLEAY_VERSION)
#elif defined(OPENSSL_VERSION_TEXT)
#define LYNX_SSL_VERSION OPENSSL_VERSION_TEXT
#elif defined(GNUTLS_VERSION)
#define LYNX_SSL_VERSION "GNUTLS " GNUTLS_VERSION " "
#endif

#ifdef LYNX_SSL_VERSION
    if (*separator == ' ')
	StrAllocCat(*target, ",");
    LYStrNCpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion) - 1);
    if ((SSLcp = StrChr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = *separator;
	if ((SSLcp = StrChr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    StrAllocCat(*target, " ");
	    StrAllocCat(*target, SSLLibraryVersion);
	}
    }
#endif /* LYNX_SSL_VERSION */
}
#endif /* USE_SSL */

/* Set the text message domain.  */
void LYSetTextDomain(void)
{
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
    const char *cp;

    if ((cp = LYGetEnv("LYNX_LOCALEDIR")) == 0) {
#ifdef USE_PROGRAM_DIR
	char *localedir = NULL;

	HTSprintf0(&localedir, "%s\\locale", program_dir);
	cp = localedir;
#else
	cp = LOCALEDIR;
#endif
    }
    bindtextdomain(NLS_TEXTDOMAIN, cp);
    textdomain(NLS_TEXTDOMAIN);
#endif
}

static void SetLocale(void)
{
#ifdef LOCALE
    /*
     * LOCALE support for international characters.
     */
    setlocale(LC_ALL, "");
#endif /* LOCALE */
    LYSetTextDomain();
}

/*
 * Wow!  Someone wants to start up Lynx.
 */
int main(int argc,
	 char **argv)
{
    int i;			/* indexing variable */
    int status = 0;		/* exit status */
    char *temp = NULL;
    const char *ccp;
    char *cp;
    FILE *fp;
    struct stat dir_info;
    char filename[LY_MAXPATH];
    BOOL LYGetStdinArgs = FALSE;

#ifdef _WINDOWS
    WSADATA WSAData;
#endif /* _WINDOWS */

    /*
     * Just in case someone has the idea to install lynx set-uid, let's try
     * to discourage it.
     */
#if defined(GETUID) && defined(SETUID)
    setuid(getuid());
#endif

#ifdef LY_FIND_LEAKS
    /*
     * Register the final function to be executed when being exited.  Will
     * display memory leaks if the -find-leaks option is used.  This should
     * be the first call to atexit() for leak-checking, which ensures that 
     * all of the other functions will be invoked before LYLeaks().
     */
    atexit(LYLeaks);
    /*
     * Register the function which will free our allocated globals.
     */
    atexit(free_lynx_globals);
#endif /* LY_FIND_LEAKS */

#ifdef    NOT_ASCII
    FixCharacters();
#endif /* NOT_ASCII */

#ifndef DISABLE_FTP
    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
    ftp_lasthost = typecalloc(char);
#endif

    LYinitEditmap();
    LYinitKeymap();
#ifdef USE_CHARSET_CHOICE
    memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
#endif

#ifdef _WINDOWS
    {
	int err;
	WORD wVerReq;

	wVerReq = MAKEWORD(1, 1);

	err = WSAStartup(wVerReq, &WSAData);
	if (err != 0) {
	    puts(gettext("No Winsock found, sorry."));
	    sleep(5);
	    return 1;
	}
    }

    /* 1998/09/03 (Thu) 22:02:32 */
    InitializeCriticalSection(&critSec_DNS);
    InitializeCriticalSection(&critSec_READ);

#endif /* _WINDOWS */

#if defined(WIN_EX)
    /* 1997/10/19 (Sun) 21:40:54 */
    system_is_NT = (BOOL) is_windows_nt();

    /* 1998/01/13 (Tue) 21:13:47 */
    GetWindowsDirectory(filename, sizeof filename);
    windows_drive[0] = filename[0];
    windows_drive[1] = filename[1];
    windows_drive[2] = '\0';
#endif

#ifdef __DJGPP__
    if (LY_get_ctrl_break() == 0) {
	LY_set_ctrl_break(TRUE);
	init_ctrl_break[0] = 0;
    } else {
	init_ctrl_break[0] = 1;
    }
    __djgpp_set_sigquit_key(0x082D);	/* Bind ALT-X to SIGQUIT */
    signal(SIGQUIT, cleanup_sig);
    atexit(reset_break);

    if (((ccp = LYGetEnv("SHELL")) != NULL)
	&& (strstr(LYPathLeaf(ccp), "sh") != NULL))
	dj_is_bash = TRUE;
#endif /* __DJGPP__ */

    /*
     * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2
     * we open files and stdout in BINARY mode by default.
     * Where necessary we should open and (close!) TEXT mode.
     * (use LYNewTxtFile/LYAppendToTxtFile to open text files for writing)
     */
    SetDefaultMode(O_BINARY);
    SetOutputMode(O_BINARY);

#ifdef DOSPATH
    if (LYGetEnv("TERM") == NULL)
	putenv("TERM=vt100");
#endif

    LYShowColor = (SHOW_COLOR ? SHOW_COLOR_ON : SHOW_COLOR_OFF);
    /*
     * Set up the argument list.
     */
    pgm = argv[0];
    cp = NULL;
#ifdef USE_PROGRAM_DIR
    StrAllocCopy(program_dir, pgm);
    if ((cp = strrchr(program_dir, '\\')) != NULL) {
	*cp = '\0';
    } else {
	FREE(program_dir);
	StrAllocCopy(program_dir, ".");
    }
#endif
    if ((cp = LYLastPathSep(pgm)) != NULL) {
	pgm = cp + 1;
    }

    /*
     * Set up trace, the anonymous account defaults, validate restrictions,
     * and/or the nosocks flag, if requested, and an alternate configuration
     * file, if specified, NOW.  Also, if we only want the help menu, output
     * that and exit.  - FM
     */
#ifndef NO_LYNX_TRACE
    if (LYGetEnv("LYNX_TRACE") != 0) {
	WWW_TraceFlag = TRUE;
    }
#endif

    /*
     * Set up the TRACE log path, and logging if appropriate.  - FM
     */
    if ((ccp = LYGetEnv("LYNX_TRACE_FILE")) == 0)
	ccp = FNAME_LYNX_TRACE;
    LYTraceLogPath = typeMallocn(char, LY_MAXPATH);

    LYAddPathToHome(LYTraceLogPath, (size_t) LY_MAXPATH, ccp);

    /*
     * Act on -version, -trace and -trace-mask NOW.
     */
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 1, &i);
    }
    LYOpenTraceLog();

    SetLocale();

    /*
     * Initialize our startup and global variables.
     */
#ifdef ULTRIX
    /*
     * Need this for Ultrix.
     */
    terminal = LYGetEnv("TERM");
    if ((terminal == NULL) || !strncasecomp(terminal, "xterm", 5))
	terminal = "vt100";
#endif /* ULTRIX */
    /*
     * Zero the links and history struct arrays.
     */
    memset((void *) links, 0, sizeof(LinkInfo) * MAXLINKS);
    LYAllocHistory(8);
    /*
     * Zero the MultiBookmark arrays.
     */
    memset((void *) MBM_A_subbookmark, 0, sizeof(char) * (MBM_V_MAXFILES + 1));
    memset((void *) MBM_A_subdescript, 0, sizeof(char) * (MBM_V_MAXFILES + 1));

#ifndef VMS
    StrAllocCopy(list_format, LIST_FORMAT);
    StrAllocCopy(ftp_format, FTP_FORMAT);
#endif /* !VMS */

    AlertSecs = SECS2Secs(ALERTSECS);
    DelaySecs = SECS2Secs(DEBUGSECS);
    InfoSecs = SECS2Secs(INFOSECS);
    MessageSecs = SECS2Secs(MESSAGESECS);
    ReplaySecs = SECS2Secs(REPLAYSECS);

    StrAllocCopy(LYTransferName, "KiB");
    StrAllocCopy(helpfile, HELPFILE);
    StrAllocCopy(startfile, STARTFILE);
    LYEscapeStartfile(&startfile);
    StrAllocCopy(indexfile, DEFAULT_INDEX_FILE);
    StrAllocCopy(global_type_map, GLOBAL_MAILCAP);
    StrAllocCopy(personal_type_map, PERSONAL_MAILCAP);
    StrAllocCopy(global_extension_map, GLOBAL_EXTENSION_MAP);
    StrAllocCopy(personal_extension_map, PERSONAL_EXTENSION_MAP);
    StrAllocCopy(language, PREFERRED_LANGUAGE);
    StrAllocCopy(pref_charset, PREFERRED_CHARSET);
    StrAllocCopy(system_mail, SYSTEM_MAIL);
    StrAllocCopy(system_mail_flags, SYSTEM_MAIL_FLAGS);

    StrAllocCopy(LYUserAgent, LYNX_NAME);
    StrAllocCat(LYUserAgent, "/");
    StrAllocCat(LYUserAgent, LYNX_VERSION);
    if (HTLibraryVersion) {
	StrAllocCat(LYUserAgent, " libwww-FM/");
	StrAllocCat(LYUserAgent, HTLibraryVersion);
    }
#ifdef USE_SSL
    append_ssl_version(&LYUserAgent, "/");
#endif /* USE_SSL */
    StrAllocCopy(LYUserAgentDefault, LYUserAgent);

#ifdef VMS
    Define_VMSLogical("LYNX_VERSION", LYNX_VERSION);
#else
    StrAllocCopy(lynx_version_putenv_command, "LYNX_VERSION=");
    StrAllocCat(lynx_version_putenv_command, LYNX_VERSION);
    (void) putenv(lynx_version_putenv_command);
    /* Note: you must not free the data passed to 'putenv()' until you give it
     * a new value for that variable.
     */
#endif /* VMS */

    if ((ccp = LYGetEnv("LYNX_TEMP_SPACE")) != NULL)
	StrAllocCopy(lynx_temp_space, ccp);
#if defined (UNIX) || defined (__DJGPP__)
    else if ((ccp = LYGetEnv("TMPDIR")) != NULL)
	StrAllocCopy(lynx_temp_space, ccp);
#endif
#if defined (DOSPATH) || defined (__EMX__)
    else if ((ccp = LYGetEnv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, ccp);
    else if ((ccp = LYGetEnv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, ccp);
#endif
    else {
#if defined(USE_PROGRAM_DIR)
	StrAllocCopy(lynx_temp_space, program_dir);
#elif defined(TEMP_SPACE)
	StrAllocCopy(lynx_temp_space, TEMP_SPACE);
#else
	puts(gettext("You MUST define a valid TMP or TEMP area!"));
	exit_immediately(EXIT_FAILURE);
#endif
    }

#ifdef WIN_EX			/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
    if (access(lynx_temp_space, 0) != 0)
#endif
	LYTildeExpand(&lynx_temp_space, TRUE);

    if ((cp = strstr(lynx_temp_space, "$USER")) != NULL) {
	char *cp1;

	if ((cp1 = LYGetEnv("USER")) != NULL) {
	    *cp = '\0';
	    StrAllocCopy(temp, lynx_temp_space);
	    *cp = '$';
	    StrAllocCat(temp, cp1);
	    cp += 5;
	    StrAllocCat(temp, cp);
	    StrAllocCopy(lynx_temp_space, temp);
	    FREE(temp);
	}
    }
#ifdef VMS
    LYLowerCase(lynx_temp_space);
    if (StrChr(lynx_temp_space, '/') != NULL) {
	if (strlen(lynx_temp_space) == 1) {
	    StrAllocCopy(lynx_temp_space, "sys$scratch:");
	} else {
	    LYAddPathSep(&lynx_temp_space);
	    StrAllocCopy(temp, HTVMS_name("", lynx_temp_space));
	    StrAllocCopy(lynx_temp_space, temp);
	    FREE(temp);
	}
    }
    if (StrChr(lynx_temp_space, ':') == NULL &&
	StrChr(lynx_temp_space, ']') == NULL) {
	StrAllocCat(lynx_temp_space, ":");
    }
#else
    LYAddPathSep(&lynx_temp_space);
    StrAllocCopy(lynx_temp_space, HTSYS_name(lynx_temp_space));
#endif /* VMS */

    if ((HTStat(lynx_temp_space, &dir_info) < 0
#if defined(MULTI_USER_UNIX)
	 && mkdir(lynx_temp_space, 0700) < 0
#endif
	)
	|| !S_ISDIR(dir_info.st_mode)) {
	fprintf(stderr, "%s: %s\n",
		lynx_temp_space,
		gettext("No such directory"));
	exit_immediately(EXIT_FAILURE);
    }
#if USE_VMS_MAILER
#ifndef MAIL_ADRS
#define MAIL_ADRS "\"IN%%\"\"%s\"\"\""
#endif
    StrAllocCopy(mail_adrs, MAIL_ADRS);
#endif

#ifdef LYNX_HOST_NAME
    StrAllocCopy(LYHostName, LYNX_HOST_NAME);
#else
    StrAllocCopy(LYHostName, HTHostName());
#endif /* LYNX_HOST_NAME */

    StrAllocCopy(LYLocalDomain, LOCAL_DOMAIN);
    StrAllocCopy(URLDomainPrefixes, URL_DOMAIN_PREFIXES);
    StrAllocCopy(URLDomainSuffixes, URL_DOMAIN_SUFFIXES);
    StrAllocCopy(XLoadImageCommand, XLOADIMAGE_COMMAND);
    StrAllocCopy(SSL_cert_file, SSL_CERT_FILE);

#ifndef DISABLE_BIBP
    StrAllocCopy(BibP_globalserver, BIBP_GLOBAL_SERVER);
    StrAllocCopy(BibP_bibhost, "http://bibhost/");	/* protocol specified. */
#endif

    /*
     * Disable news posting if the compilation-based LYNewsPosting value is
     * FALSE.  This may be changed further down via lynx.cfg or the
     * -restriction command line switch.  - FM
     */
#ifndef DISABLE_NEWS
    no_newspost = (BOOL) (LYNewsPosting == FALSE);
#endif

    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 2, &i);
    }

    /*
     * If we have a lone "-" switch for getting arguments from stdin, get them
     * NOW, and act on the relevant ones, saving the others into an HTList for
     * handling after the other initializations.  The primary purpose of this
     * feature is to allow for the potentially very long command line that can
     * be associated with post or get data.  The original implementation
     * required that the lone "-" be the only command line argument, but that
     * precluded its use when the lynx command is aliased with other arguments.
     * When interactive, the stdin input is terminated by by Control-D on Unix
     * or Control-Z on VMS, and each argument is terminated by a RETURN.  When
     * the argument is -get_data or -post_data, the data are terminated by a
     * "---" string, alone on the line (also terminated by RETURN).  - FM
     */
    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-") == 0) {
	    LYGetStdinArgs = TRUE;
	    break;
	}
    }
    if (LYGetStdinArgs == TRUE) {
	char *buf = NULL;

	CTRACE((tfp, "processing stdin arguments\n"));
	while (GetStdin(&buf, TRUE)) {
	    char *noargv[2];

	    noargv[0] = buf;
	    noargv[1] = NULL;
	    LYTrimTrailing(buf);

	    if (parse_arg(&noargv[0], 2, (int *) 0) == FALSE
		&& buf[0] != '\0') {
		char *argument = NULL;

		if (LYStdinArgs == NULL) {
		    LYStdinArgs = HTList_new();
#ifdef LY_FIND_LEAKS
		    atexit(LYStdinArgs_free);
#endif
		}
		StrAllocCopy(argument, buf);
		HTList_appendObject(LYStdinArgs, argument);
		CTRACE((tfp, "...StdinArg:%s\n", argument));
	    } else {
		CTRACE((tfp, "...complete:%s\n", buf));
	    }
	}
	CTRACE((tfp, "...done with stdin arguments\n"));
	FREE(buf);
    }
#ifdef SOCKS
    if (socks_flag)
	SOCKSinit(argv[0]);
#endif /* SOCKS */

    /*
     * If we had -validate set all of the restrictions and disallow a TRACE log
     * NOW.  - FM
     */
    if (LYValidate == TRUE) {
	parse_restrictions("all");
	LYUseTraceLog = FALSE;
    }

    /*
     * If we didn't get and act on a -validate or -anonymous switch, but can
     * verify that this is the anonymous account, set the default restrictions
     * for that account and disallow a TRACE log NOW.  - FM
     */
    if (!LYValidate && !LYRestricted &&
	strlen(ANONYMOUS_USER) > 0 &&
#if defined (VMS) || defined (NOUSERS)
	!strcasecomp((LYGetEnv("USER") == NULL ? " " : LYGetEnv("USER")),
		     ANONYMOUS_USER)
#else
#ifdef HAVE_CUSERID
	STREQ((char *) cuserid((char *) NULL), ANONYMOUS_USER)
#else
	STREQ(((char *) getlogin() == NULL ? " " : getlogin()), ANONYMOUS_USER)
#endif /* HAVE_CUSERID */
#endif /* VMS */
	) {
	parse_restrictions("default");
	LYRestricted = TRUE;
	LYUseTraceLog = FALSE;
    }
#ifdef USE_CMD_LOGGING
    /*
     * Open command-script, if specified
     */
    if (lynx_cmd_script != 0) {
	LYTildeExpand(&lynx_cmd_script, TRUE);
	LYOpenCmdScript();
    }
    /*
     * Open command-logging, if specified
     */
    if (lynx_cmd_logfile != 0) {
	LYTildeExpand(&lynx_cmd_logfile, TRUE);
	LYOpenCmdLogfile(argc, argv);
    }
#endif

    /*
     * Set up the default jump file stuff.  - FM
     */
    StrAllocCopy(jumpprompt, JUMP_PROMPT);
#ifdef JUMPFILE
    StrAllocCopy(jumpfile, JUMPFILE);
    {
	temp = NULL;
	HTSprintf0(&temp, "JUMPFILE:%s", jumpfile);
	if (!LYJumpInit(temp)) {
	    CTRACE((tfp, "Failed to register %s\n", temp));
	}
	FREE(temp);
    }
#endif /* JUMPFILE */

    /*
     * If no alternate configuration file was specified on the command line,
     * see if it's in the environment.
     */
    if (!lynx_cfg_file) {
	if (((cp = LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp = LYGetEnv("lynx_cfg")) != NULL)
	    StrAllocCopy(lynx_cfg_file, cp);
    }
#ifdef USE_PROGRAM_DIR
    if (!lynx_cfg_file) {
	HTSprintf0(&lynx_cfg_file, "%s\\lynx.cfg", program_dir);
	if (!LYCanReadFile(lynx_cfg_file)) {
	    FREE(lynx_cfg_file);
	    lynx_cfg_file = NULL;
	}
    }
#endif

    /*
     * If we still don't have a configuration file, use the userdefs.h
     * definition.
     */
    if (!lynx_cfg_file)
	StrAllocCopy(lynx_cfg_file, LYNX_CFG_FILE);

#ifndef _WINDOWS		/* avoid the whole ~ thing for now */
    LYTildeExpand(&lynx_cfg_file, FALSE);
#endif

    /*
     * If the configuration file is not available, inform the user and exit.
     */
    if (!LYCanReadFile(lynx_cfg_file)) {
	fprintf(stderr,
		gettext("\nConfiguration file \"%s\" is not available.\n\n"),
		lynx_cfg_file);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Make sure we have the character sets declared.  This will initialize the
     * CHARTRANS handling.  - KW
     */
    if (!LYCharSetsDeclared()) {
	fprintf(stderr, gettext("\nLynx character sets not declared.\n\n"));
	exit_immediately(EXIT_FAILURE);
    }
    /*
     * (**) in Lynx, UCLYhndl_HTFile_for_unspec and UCLYhndl_for_unrec may be
     * valid or not, but current_char_set and UCLYhndl_for_unspec SHOULD ALWAYS
     * be a valid charset.  Initialized here and may be changed later from
     * lynx.cfg/command_line/options_menu.  - LP (**)
     */
    /*
     * Set up the compilation default character set.  - FM
     */
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (auto_display_charset >= 0)
	current_char_set = auto_display_charset;
    else
#endif
	current_char_set = safeUCGetLYhndl_byMIME(CHARACTER_SET);
    /*
     * Set up HTTP default for unlabeled charset (iso-8859-1).
     */
    UCLYhndl_for_unspec = LATIN1;
    StrAllocCopy(UCAssume_MIMEcharset,
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);

#ifdef USE_COLOR_TABLE
    /*
     * Set up default foreground and background colors.
     */
    lynx_setup_colors();
#endif /* USE_COLOR_TABLE */

    /*
     * Set the original directory, used for default download
     */
    if (!strcmp(Current_Dir(filename), ".")) {
	if ((cp = LYGetEnv("PWD")) != 0)
	    StrAllocCopy(original_dir, cp);
    } else {
	StrAllocCopy(original_dir, filename);
    }

    /*
     * Set the compilation default signature file.  - FM
     */
    LYStrNCpy(filename, LYNX_SIG_FILE, sizeof(filename) - 1);
    if (LYPathOffHomeOK(filename, sizeof(filename))) {
	StrAllocCopy(LynxSigFile, filename);
	LYAddPathToHome(filename, sizeof(filename), LynxSigFile);
	StrAllocCopy(LynxSigFile, filename);
	CTRACE((tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile));
    } else {
	CTRACE((tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE));
    }

#ifdef USE_PRETTYSRC
    /*this is required for checking the tagspecs when parsing cfg file by
       LYReadCFG.c:parse_html_src_spec -HV */
    HTSwitchDTD(TRUE);
#endif
    /*
     * Process the configuration file.
     */
    read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);

#if defined(USE_COLOR_STYLE)
    if (!dump_output_immediately) {
	init_color_styles(&lynx_lss_file2, default_color_styles);
    }
#endif /* USE_COLOR_STYLE */

    /*
     * Process the RC file.
     */
    read_rc(NULL);

#ifdef USE_LOCALE_CHARSET
    LYFindLocaleCharset();
#endif

    /*
     * Get WWW_HOME environment variable if it exists.
     */
    if ((cp = LYGetEnv("WWW_HOME")) != NULL) {
	StrAllocCopy(startfile, cp);
	LYEscapeStartfile(&startfile);
    }

    /*
     * Set the LynxHome URL.  If it's a file URL and the
     * host is defaulted, force in "//localhost", and if
     * it's not an absolute URL, make it one. - FM
     */
    StrAllocCopy(LynxHome, startfile);
    LYEnsureAbsoluteURL(&LynxHome, "LynxHome", FALSE);

    /*
     * Process any command line arguments not already handled.  - FM
     * May set startfile as a side-effect.
     */
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], 4, &i);
    }

    /*
     * Process any stdin-derived arguments for a lone "-" which we've loaded
     * into LYStdinArgs.  - FM
     */
    if (LYStdinArgs != NULL) {
	char *my_args[2];
	HTList *cur = LYStdinArgs;

	my_args[1] = NULL;
	while (NULL != (my_args[0] = (char *) HTList_nextObject(cur))) {
	    parse_arg(my_args, 4, (int *) 0);
	}
	LYStdinArgs_free();
    }
#ifdef HAVE_TTYNAME
    /*
     * If the input is not a tty, we are either running in cron, or are
     * getting input via a pipe:
     *
     * a) in cron, none of stdin/stdout/stderr are tty's.
     * b) from a pipe, we should have either "-" or "-stdin" options.
     */
    if (!LYGetStdinArgs
	&& !startfile_stdin
	&& !isatty(fileno(stdin))
	&& (isatty(fileno(stdout) || isatty(fileno(stderr))))) {
	int ignored = 0;

	while (fgetc(stdin) != EOF) {
	    ++ignored;
	}
	if (ignored) {
	    fprintf(stderr,
		    gettext("Ignored %d characters from standard input.\n"), ignored);
	    fprintf(stderr,
		    gettext("Use \"-stdin\" or \"-\" to tell how to handle piped input.\n"));
	}
    }
#endif /* HAVE_TTYNAME */

#ifdef CAN_SWITCH_DISPLAY_CHARSET
    if (current_char_set == auto_display_charset)	/* Better: explicit option */
	switch_display_charsets = 1;
#endif

#if defined (TTY_DEVICE) || defined(HAVE_TTYNAME)
    /*
     * If we are told to read the startfile from standard input, do it now,
     * after we have read all of the option data from standard input.
     * Later we'll use LYReopenInput().
     */
    if (startfile_stdin) {
	char result[LY_MAXPATH];
	char *buf = NULL;

	CTRACE((tfp, "processing stdin startfile\n"));
	if ((fp = LYOpenTemp(result, HTML_SUFFIX, "w")) != 0) {
	    StrAllocCopy(startfile, result);
	    while (GetStdin(&buf, FALSE)) {
		fputs(buf, fp);
		fputc('\n', fp);
	    }
	    FREE(buf);
	    LYCloseTempFP(fp);
	}
	CTRACE((tfp, "...done stdin startfile\n"));
    }
#endif

    /*
     * Initialize other things based on the configuration read.
     */

#ifdef USE_PRETTYSRC
    if ((!Old_DTD) != TRUE)	/* skip if they are already initialized -HV */
#endif
	HTSwitchDTD(!Old_DTD);

    /*
     * Set up the proper character set with the desired
     * startup raw 8-bit or CJK mode handling.  - FM
     */
    HTMLUseCharacterSet(current_char_set);

#ifdef USE_PERSISTENT_COOKIES
    /*
     * Sod it, this looks like a reasonable place to load the
     * cookies file, probably.  - RP
     *
     * And to set LYCookieSaveFile. - BJP
     */
    if (persistent_cookies) {
	if (LYCookieFile == NULL) {
	    LYCookieFile = typeMallocn(char, LY_MAXPATH);

	    LYAddPathToHome(LYCookieFile, (size_t) LY_MAXPATH, FNAME_LYNX_COOKIES);
	} else {
	    LYTildeExpand(&LYCookieFile, FALSE);
	}
	LYLoadCookies(LYCookieFile);
    }

    /* tilde-expand LYCookieSaveFile */
    if (LYCookieSaveFile != NULL) {
	LYTildeExpand(&LYCookieSaveFile, FALSE);
    }
#ifdef USE_PROGRAM_DIR
    if (is_url(helpfile) == 0) {
	char *tmp = NULL;

	HTSprintf0(&tmp, "%s\\%s", program_dir, helpfile);
	FREE(helpfile);
	LYLocalFileToURL(&helpfile, tmp);
	FREE(tmp);
    }
#endif

    /*
     * In dump_output_immediately mode, LYCookieSaveFile defaults to
     * /dev/null, otherwise it defaults to LYCookieFile.
     */

    if (LYCookieSaveFile == NULL) {
	if (dump_output_immediately) {
	    StrAllocCopy(LYCookieSaveFile, "/dev/null");
	} else {
	    StrAllocCopy(LYCookieSaveFile, LYCookieFile);
	}
    }
#endif

    /*
     * Check for a help file URL in the environment. Overiding
     * compiled-in default and configuration file setting, if found.
     */
    if ((cp = LYGetEnv("LYNX_HELPFILE")) != NULL)
	StrAllocCopy(helpfile, cp);

    /*
     * Set up our help and about file base paths. - FM
     */
    StrAllocCopy(helpfilepath, helpfile);
    if ((cp = LYPathLeaf(helpfilepath)) != helpfilepath)
	*cp = '\0';
    LYAddHtmlSep(&helpfilepath);

    /*
     * Check for a save space path in the environment.  If one was set in the
     * configuration file, that one will be overridden.  - FM
     */
    if ((cp = LYGetEnv("LYNX_SAVE_SPACE")) != NULL)
	StrAllocCopy(lynx_save_space, cp);

    /*
     * We have a save space path, make sure it's valid.  - FM
     */
    if (lynx_save_space && *lynx_save_space == '\0') {
	FREE(lynx_save_space);
    }
    if (lynx_save_space) {
	LYTildeExpand(&lynx_save_space, TRUE);
#ifdef VMS
	LYLowerCase(lynx_save_space);
	if (StrChr(lynx_save_space, '/') != NULL) {
	    if (strlen(lynx_save_space) == 1) {
		StrAllocCopy(lynx_save_space, "sys$login:");
	    } else {
		LYAddPathSep(&lynx_save_space);
		StrAllocCopy(temp, HTVMS_name("", lynx_save_space));
		StrAllocCopy(lynx_save_space, temp);
		FREE(temp);
	    }
	}
	if (StrChr(lynx_save_space, ':') == NULL &&
	    StrChr(lynx_save_space, ']') == NULL) {
	    StrAllocCat(lynx_save_space, ":");
	}
#else
	LYAddPathSep(&lynx_save_space);
#endif /* VMS */
    }

    /*
     * Set up the file extension and mime type maps from src/HTInit.c and the
     * global and personal mime.types and mailcap files.  These will override
     * any SUFFIX or VIEWER maps in userdefs.h or the configuration file, if
     * they overlap.
     */
    HTFormatInit();
    if (!FileInitAlreadyDone)
	HTFileInit();

    if (!LYCheckUserAgent()) {
	HTAlwaysAlert(gettext("Warning:"), UA_NO_LYNX_WARNING);
    }
    if (show_cfg) {
	cleanup();
	exit_immediately(EXIT_SUCCESS);
    }
#ifdef USE_SLANG
    if (LYShowColor >= SHOW_COLOR_ON &&
	!(Lynx_Color_Flags & SL_LYNX_USE_COLOR)) {
	Lynx_Color_Flags |= SL_LYNX_USE_COLOR;
    } else if ((Lynx_Color_Flags & SL_LYNX_USE_COLOR) ||
	       LYGetEnv("COLORTERM") != NULL) {
	if (LYShowColor != SHOW_COLOR_NEVER &&
	    LYShowColor != SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
    }
#endif /* USE_SLANG */

    if (LYPreparsedSource) {
	HTPreparsedFormatInit();
    }
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifdef NEVER_ALLOW_REMOTE_EXEC
    if (local_exec) {
	local_exec = FALSE;
	local_exec_on_local_files = TRUE;
    }
#endif /* NEVER_ALLOW_REMOTE_EXEC */
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

    if (emacs_keys)
	set_emacs_keys();

    if (vi_keys)
	set_vi_keys();

    if (no_numbers) {
	number_links = FALSE;
	number_fields = FALSE;
	keypad_mode = NUMBERS_AS_ARROWS;
	set_numbers_as_arrows();
    }

    if (crawl) {
	/* No numbered links by default, as documented
	   in CRAWL.announce. - kw */
	if (!number_links) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	}
    }

    if (!links_are_numbered()) {
	if (number_fields)
	    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
	if (number_links)
	    keypad_mode = LINKS_ARE_NUMBERED;
	set_numbers_as_arrows();
    }

    /*
     * Check the -popup command line toggle.  - FM
     */
    if (LYUseDefSelPop == FALSE) {
	LYSelectPopups = (BOOLEAN) !LYSelectPopups;
    }

    /*
     * Check the -show_cursor command line toggle.  - FM
     */
    if (LYUseDefShoCur == FALSE) {
	LYShowCursor = (BOOLEAN) !LYShowCursor;
    }

    /*
     * Check the -base command line switch with -source.  - FM
     */
    if (LYPrependBase && HTOutputFormat == HTAtom_for("www/download")) {
	LYPrependBaseToSource = TRUE;
    }

    /*
     * Disable multiple bookmark support if not interactive, so it doesn't
     * crash on curses functions, or if the support was blocked via userdefs.h
     * and/or lynx.cfg, or via command line restrictions.  - FM
     */
    if (no_multibook)
	LYMBMBlocked = TRUE;
    if (dump_output_immediately || LYMBMBlocked || no_multibook) {
	LYMultiBookmarks = MBM_OFF;
	LYMBMBlocked = TRUE;
	no_multibook = TRUE;
    }
#ifdef USE_SOURCE_CACHE
    /*
     * Disable source caching if not interactive.
     */
    if (dump_output_immediately)
	LYCacheSource = SOURCE_CACHE_NONE;
#endif
#ifdef DISP_PARTIAL
    /*
     * Disable partial mode if not interactive.
     */
    if (dump_output_immediately)
	display_partial_flag = FALSE;
#endif

#ifdef VMS
    set_vms_keys();
#endif /* VMS */

#if defined (__DJGPP__)
    if (watt_debug)
	dbug_init();
    sock_init();

    __system_flags =
	__system_emulate_chdir |	/* handle `cd' internally */
	__system_handle_null_commands |		/* ignore cmds with no effect */
	__system_allow_long_cmds |	/* handle commands > 126 chars   */
	__system_use_shell |	/* use $SHELL if set */
	__system_allow_multiple_cmds |	/* allow `cmd1; cmd2; ...' */
	__system_redirect;	/* redirect internally */

    /* This speeds up stat() tremendously */
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC | _STAT_DIRSIZE;
#endif /* __DJGPP__ */

    /* trap interrupts */
#ifdef WIN32
    SetConsoleCtrlHandler((PHANDLER_ROUTINE) cleanup_win32, TRUE);
#endif

#ifndef NOSIGHUP
    if (!dump_output_immediately)
	(void) signal(SIGHUP, cleanup_sig);
#endif /* NOSIGHUP */

    (void) signal(SIGTERM, cleanup_sig);
#ifdef SIGWINCH
    LYExtSignal(SIGWINCH, size_change);
#endif /* SIGWINCH */
#ifndef VMS
    if (!TRACE && !dump_output_immediately && !stack_dump) {
	(void) signal(SIGINT, cleanup_sig);
#ifndef __linux__
#ifdef SIGBUS
	(void) signal(SIGBUS, FatalProblem);
#endif /* SIGBUS */
#endif /* !__linux__ */
	(void) signal(SIGSEGV, FatalProblem);
	(void) signal(SIGILL, FatalProblem);
	/*
	 * Since we're doing lots of TCP, just ignore SIGPIPE altogether.
	 *
	 * HTTCP.c should deal with a broken pipe for servers.  Rick Mallet's
	 * check after c = GetChar() in LYStrings.c should deal with a
	 * disconnected terminal.  So the runaway CPU time problem on Unix
	 * should not occur any more.
	 */
#ifdef SIGPIPE
	if (signal(SIGPIPE, SIG_IGN) != SIG_IGN)
	    restore_sigpipe_for_children = TRUE;
#endif /* SIGPIPE */
    }
#endif /* !VMS */

#ifdef SIGTSTP
    /*
     * Block Control-Z suspending if requested.  - FM
     */
    if (no_suspend)
	(void) signal(SIGTSTP, SIG_IGN);
#endif /* SIGTSTP */

    /*
     * Check for a valid HEAD request.  - FM
     */
    if (HEAD_request && LYCanDoHEAD(startfile) != TRUE) {
	fprintf(stderr,
		"The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
		startfile);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Check for a valid MIME headers request.  - FM
     */
    if (keep_mime_headers && LYCanDoHEAD(startfile) != TRUE) {
	fprintf(stderr,
		"The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
		startfile);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Check for a valid traversal request.  - FM
     */
    if (traversal && StrNCmp(startfile, "http", 4)) {
	fprintf(stderr,
		"The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
		startfile);
	exit_immediately(EXIT_FAILURE);
    }

    /*
     * Finish setting up for an INTERACTIVE session.  Done here so that URL
     * guessing in LYEnsureAbsoluteURL() can be interruptible (terminal is in
     * raw mode, select() works).  -BL
     */
#ifdef USE_PRETTYSRC
    if (!dump_output_immediately) {
	HTMLSRC_init_caches(FALSE);	/* do it before terminal is initialized */
#ifdef LY_FIND_LEAKS
	atexit(html_src_clean_data);
#endif
    }
#endif

    if (!dump_output_immediately) {
	setup(terminal);
    }
    /*
     * If startfile is a file URL and the host is defaulted, force in
     * "//localhost", and if it's not an absolute URL, make it one.  - FM
     */
    LYEnsureAbsoluteURL(&startfile, "STARTFILE", FALSE);

    /*
     * If homepage was specified and is a file URL with the host defaulted,
     * force in "//localhost", and if it's not an absolute URL, make it one.  -
     * FM
     */
    if (homepage) {
	LYEnsureAbsoluteURL(&homepage, "HOMEPAGE", FALSE);
    }

    /*
     * If we don't have a homepage specified, set it to startfile.  Otherwise,
     * reset LynxHome.  - FM
     */
    if (isEmpty(homepage)) {
	StrAllocCopy(homepage, startfile);
    } else {
	StrAllocCopy(LynxHome, homepage);
    }

    /*
     * Set up the inside/outside domain restriction flags.  - FM
     */
    if (inlocaldomain()) {
#if !defined(HAVE_UTMP) || defined(VMS)		/* not selective */
	telnet_ok = (BOOL) (!no_inside_telnet && !no_outside_telnet && telnet_ok);
#ifndef DISABLE_NEWS
	news_ok = (BOOL) (!no_inside_news && !no_outside_news && news_ok);
#endif
	ftp_ok = (BOOL) (!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
#else
	CTRACE((tfp, "LYMain: User in Local domain\n"));
	telnet_ok = (BOOL) (!no_inside_telnet && telnet_ok);
#ifndef DISABLE_NEWS
	news_ok = (BOOL) (!no_inside_news && news_ok);
#endif
	ftp_ok = (BOOL) (!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_inside_rlogin && rlogin_ok);
#endif /* !HAVE_UTMP || VMS */
    } else {
	CTRACE((tfp, "LYMain: User in REMOTE domain\n"));
	telnet_ok = (BOOL) (!no_outside_telnet && telnet_ok);
#ifndef DISABLE_NEWS
	news_ok = (BOOL) (!no_outside_news && news_ok);
#endif
	ftp_ok = (BOOL) (!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL) (!no_outside_rlogin && rlogin_ok);
    }
#ifdef DISABLE_FTP
    ftp_ok = FALSE;
#else
    /* predefine some known broken ftp servers */
    LYSetConfigValue(RC_BROKEN_FTP_RETR, "ProFTPD 1.2.5");
    LYSetConfigValue(RC_BROKEN_FTP_RETR, "spftp/");
    LYSetConfigValue(RC_BROKEN_FTP_EPSV, "(Version wu-2.6.2-12)");
#endif

    /*
     * Make sure our bookmark default strings are all allocated and
     * synchronized.  - FM
     */
    if (isEmpty(bookmark_page)) {
	temp = NULL;
	HTSprintf0(&temp, "lynx_bookmarks%s", HTML_SUFFIX);
	set_default_bookmark_page(temp);
	FREE(temp);
    }
    if (isEmpty(BookmarkPage)) {
	set_default_bookmark_page(bookmark_page);
    }
#if defined(SYSLOG_REQUESTED_URLS)
    LYOpenlog(syslog_txt);
#endif

    if (non_empty(x_display)) {
	LYisConfiguredForX = TRUE;
    }

    /*
     * Here's where we do all the work.
     */
    if (dump_output_immediately) {
	/*
	 * Finish setting up and start a NON-INTERACTIVE session.  - FM
	 */
	if (crawl && !number_links && !number_fields) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	} else if (no_numbers) {
	    keypad_mode = NUMBERS_AS_ARROWS;
	} else if (!no_list) {
	    if (!links_are_numbered()) {
		if (number_fields)
		    keypad_mode = LINKS_AND_FIELDS_ARE_NUMBERED;
		else
		    keypad_mode = LINKS_ARE_NUMBERED;
	    }
	}
	if (dump_output_width > 0) {
	    LYcols = dump_output_width;
	}
	/*
	 * Normal argument processing puts non-options (URLs) into the Goto
	 * history.  Use this to dump all of the pages listed on the command
	 * line, or (if none are listed) via the startfile mechanism.
	 * history.
	 */
#ifdef EXTENDED_STARTFILE_RECALL
	HTAddGotoURL(startfile);
	for (i = HTList_count(Goto_URLs) - 1; i >= 0; --i) {
	    StrAllocCopy(startfile, (char *) HTList_objectAt(Goto_URLs, i));
	    CTRACE((tfp, "dumping %d:%d %s\n",
		    i + 1, HTList_count(Goto_URLs), startfile));
	    status = mainloop();
	    if (!no_list &&
		!dump_links_inline &&
		!crawl)		/* For -crawl it has already been done! */
		printlist(stdout, FALSE);
	    if (i != 0)
		printf("\n");
	}
#else
	status = mainloop();
	if (!no_list &&
	    !dump_links_inline &&
	    !crawl &&		/* For -crawl it has already been done! */
	    links_are_numbered())
	    printlist(stdout, FALSE);
#endif
#ifdef USE_PERSISTENT_COOKIES
	/*
	 * We want to save cookies picked up when in immediate dump mode.
	 * Instead of calling cleanup() here, let's only call this one.  - BJP
	 */
	if (persistent_cookies)
	    LYStoreCookies(LYCookieSaveFile);
#endif /* USE_PERSISTENT_COOKIES */
	exit_immediately(status);
    } else {
	/*
	 * Start an INTERACTIVE session.  - FM
	 */
#ifdef USE_COLOR_STYLE
	cache_tag_styles();
#endif

#ifndef NO_DUMP_WITH_BACKSPACES
	if (with_backspaces) {
	    /* we should warn about this somehow (nop for now) -VH */
	    with_backspaces = FALSE;
	}
#endif

#ifndef ALL_CHARSETS_IN_O_MENU_SCREEN
	init_charset_subsets();
#endif

	ena_csi((BOOLEAN) (LYlowest_eightbit[current_char_set] > 155));
#ifdef USE_SESSIONS
	RestoreSession();
#endif /* USE_SESSIONS */
	status = mainloop();
	LYCloseCloset(RECALL_URL);
	LYCloseCloset(RECALL_MAIL);
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
	if (!isendwin()) {
	    if ((saved_scrsize_x != 0) && (saved_scrsize_y != 0)) {
		resize_term(saved_scrsize_y, saved_scrsize_x);
	    }
	}
#endif
	cleanup();
	exit_immediately(status);
    }

    return (status);		/* though redundant, for compiler-warnings */
}

/*
 * Called by HTAccessInit to register any protocols supported by lynx.
 * Protocols added by lynx:
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE, LYNXCACHE, LYNXMESSAGES
 */
#ifdef GLOBALREF_IS_MACRO
extern GLOBALREF (HTProtocol, LYLynxEditmap);
extern GLOBALREF (HTProtocol, LYLynxKeymap);
extern GLOBALREF (HTProtocol, LYLynxCGI);
extern GLOBALREF (HTProtocol, LYLynxIMGmap);
extern GLOBALREF (HTProtocol, LYLynxCookies);

#ifdef USE_CACHEJAR
extern GLOBALREF (HTProtocol, LYLynxCache);
#endif
extern GLOBALREF (HTProtocol, LYLynxStatusMessages);

#else
GLOBALREF HTProtocol LYLynxEditmap;
GLOBALREF HTProtocol LYLynxKeymap;
GLOBALREF HTProtocol LYLynxCGI;
GLOBALREF HTProtocol LYLynxIMGmap;
GLOBALREF HTProtocol LYLynxCookies;

#ifdef USE_CACHEJAR
GLOBALREF HTProtocol LYLynxCache;
#endif
GLOBALREF HTProtocol LYLynxStatusMessages;
#endif /* GLOBALREF_IS_MACRO */

void LYRegisterLynxProtocols(void)
{
    HTRegisterProtocol(&LYLynxEditmap);
    HTRegisterProtocol(&LYLynxKeymap);
    HTRegisterProtocol(&LYLynxCGI);
    HTRegisterProtocol(&LYLynxIMGmap);
    HTRegisterProtocol(&LYLynxCookies);
#ifdef USE_CACHEJAR
    HTRegisterProtocol(&LYLynxCache);
#endif
    HTRegisterProtocol(&LYLynxStatusMessages);
}

#ifndef NO_CONFIG_INFO
/*
 * Some stuff to reload lynx.cfg without restarting new lynx session, also load
 * options menu items and command-line options to make things consistent.
 *
 * Called by user of interactive session by LYNXCFG://reload/ link.
 *
 * Warning:  experimental, more main() reorganization required.
 *	*Known* exceptions: persistent cookies, cookie files.
 *
 *	Some aspects of COLOR (with slang?).
 *	Viewer stuff, mailcap files
 *	SUFFIX, mime.types files
 *	RULESFILE/RULE
 *
 *	All work "somewhat", but not exactly as the first time.
 */
void reload_read_cfg(void)
{
    char *tempfile;
    FILE *rcfp;

    /*
     * no_option_save is always set for -anonymous and -validate.  It is better
     * to check for one or several specific restriction flags than for
     * 'LYRestricted', which doesn't get set for individual restrictions or for
     * -validate!  However, no_option_save may not be the appropriate one to
     * check - in that case, a new no_something should be added that gets
     * automatically set for -anonymous and -validate (and whether it applies
     * for -anonymous can be made installer- configurable in the usual way at
     * the bottom of userdefs.h).  - kw
     *
     */
    if (no_option_save) {
	/* current logic requires(?) that saving user preferences is
	   possible.  Additional applicable restrictions are already
	   checked by caller. - kw */
	return;
    }

    /*
     * Current user preferences are saved in a temporary file, to be read in
     * again after lynx.cfg has been read.  This avoids accidental changing of
     * the preferences file.  The regular preferences file doesn't even need to
     * exist, and won't be created as a side effect of this function.  Honoring
     * the no_option_save restriction may thus be unnecessarily restrictive,
     * but the check is currently still left in place.  - kw
     */
    tempfile = typecallocn(char, LY_MAXPATH);
    if (!tempfile) {
	HTAlwaysAlert(NULL, NOT_ENOUGH_MEMORY);
	return;
    }
    rcfp = LYOpenTemp(tempfile, ".rc", "w");
    if (rcfp == NULL) {
	FREE(tempfile);
	HTAlwaysAlert(NULL, CANNOT_OPEN_TEMP);
	return;
    }
    if (!save_rc(rcfp)) {
	HTAlwaysAlert(NULL, OPTIONS_NOT_SAVED);
	(void) LYRemoveTemp(tempfile);
	FREE(tempfile);
	return;			/* can not write the very own file :( */
    } {
	/* set few safe flags: */
#ifdef USE_PERSISTENT_COOKIES
	BOOLEAN persistent_cookies_flag = persistent_cookies;
	char *LYCookieFile_flag = NULL;
	char *LYCookieSaveFile_flag = NULL;

	if (persistent_cookies) {
	    StrAllocCopy(LYCookieFile_flag, LYCookieFile);
	    StrAllocCopy(LYCookieSaveFile_flag, LYCookieSaveFile);
	}
#endif

#ifdef USE_CHARSET_CHOICE
	custom_assumed_doc_charset = FALSE;
	custom_display_charset = FALSE;
	memset((char *) charset_subsets, 0, sizeof(charset_subset_t) * MAXCHARSETS);
#endif

#ifdef USE_PRETTYSRC
	html_src_on_lynxcfg_reload();
#endif
	/* free downloaders, printers, environments, dired menu */
	free_lynx_cfg();
#ifdef USE_SOURCE_CACHE
	source_cache_file_error = FALSE;	/* reset flag */
#endif

	/*
	 * Process the configuration file.
	 */
	read_cfg(lynx_cfg_file, "main program", 1, (FILE *) 0);

	/*
	 * Process the temporary RC file.
	 */
	rcfp = fopen(tempfile, "r");
	read_rc(rcfp);
	(void) LYRemoveTemp(tempfile);
	FREE(tempfile);		/* done with it - kw */

#ifdef USE_CHARSET_CHOICE
	init_charset_subsets();
#endif

	/*
	 * Initialize other things based on the configuration read.
	 */
	LYSetDisplayLines();
	/* Not implemented yet here,
	 * a major problem: file paths
	 * like lynx_save_space, LYCookieFile etc.
	 */
#ifdef USE_PERSISTENT_COOKIES
	/* restore old settings */
	if (persistent_cookies != persistent_cookies_flag) {
	    persistent_cookies = persistent_cookies_flag;
	    HTAlert(gettext("persistent cookies state will be changed in next session only."));
	}
	if (persistent_cookies) {
	    if (strcmp(LYCookieFile, LYCookieFile_flag)) {
		StrAllocCopy(LYCookieFile, LYCookieFile_flag);
		CTRACE((tfp,
			"cookie file can be changed in next session only, restored.\n"));
	    }
	    if (strcmp(LYCookieSaveFile, LYCookieSaveFile_flag)) {
		StrAllocCopy(LYCookieSaveFile, LYCookieSaveFile_flag);
		CTRACE((tfp,
			"cookie save file can be changed in next session only, restored.\n"));
	    }
	    FREE(LYCookieFile_flag);
	    FREE(LYCookieSaveFile_flag);
	}
#endif

    }
}
#endif /* !NO_CONFIG_INFO */

static void force_dump_mode(void)
{
    dump_output_immediately = TRUE;
    no_pause = TRUE;
    LYcols = DFT_COLS;
}

/* There are different ways of setting arguments on the command line, and
 * there are different types of arguments.  These include:
 *
 *   -set_some_variable		 ==> some_variable  = TRUE
 *   -toggle_some_variable	 ==> some_variable = !some_variable
 *   -some_variable=value	 ==> some_variable = value
 *
 * Others are complicated and require a function call.
 */

#define PARSE_SET(n,t,v,h) {n,    t, UNION_SET(v), h}
#define PARSE_INT(n,t,v,h) {n,    t, UNION_INT(v), h}
#define PARSE_STR(n,t,v,h) {n,    t, UNION_STR(v), h}
#define PARSE_FUN(n,t,v,h) {n,    t, UNION_FUN(v), h}
#define PARSE_NIL          {NULL, 0, UNION_DEF(0), NULL}

typedef struct parse_args_type {
    const char *name;
    int type;

#define TOGGLE_ARG		0x0010
#define SET_ARG			0x0020
#define UNSET_ARG		0x0030
#define FUNCTION_ARG		0x0040
#define LYSTRING_ARG		0x0050
#define INT_ARG			0x0060
#define STRING_ARG		0x0070
#define TIME_ARG		0x0080
#define ARG_TYPE_MASK		0x0FF0
#define NEED_NEXT_ARG		0x1000

#define NEED_INT_ARG		(NEED_NEXT_ARG | INT_ARG)
#define NEED_TIME_ARG		(NEED_NEXT_ARG | TIME_ARG)
#define NEED_LYSTRING_ARG	(NEED_NEXT_ARG | LYSTRING_ARG)
#define NEED_STRING_ARG		(NEED_NEXT_ARG | STRING_ARG)
#define NEED_FUNCTION_ARG	(NEED_NEXT_ARG | FUNCTION_ARG)

    /* If the NEED_NEXT_ARG flags is set, and the option was not specified
     * with an '=' character, then use the next argument in the argv list.
     */

      ParseData;
    const char *help_string;
} Config_Type;

/* -auth, -pauth */
static int parse_authentication(char *next_arg,
				char **result)
{
    /*
     * Authentication information for protected documents.
     */
    char *auth_info = 0;

    if (next_arg != 0) {
	StrAllocCopy(auth_info, next_arg);
	memset(next_arg, ' ', strlen(next_arg));	/* Let's not show too much */
    }

    if (auth_info != 0) {
	char *cp;

	if ((cp = StrChr(auth_info, ':')) != 0) {	/* Pw */
	    *cp++ = '\0';	/* Terminate ID */
	    HTUnEscape(cp);
	    StrAllocCopy(result[1], cp);
	}
	if (*auth_info) {	/* Id */
	    HTUnEscape(auth_info);
	    StrAllocCopy(result[0], auth_info);
	}
	FREE(auth_info);
    }
    return 0;
}

/* -anonymous */
static int anonymous_fun(char *next_arg GCC_UNUSED)
{
    if (!LYValidate && !LYRestricted)
	parse_restrictions("default");
    LYRestricted = TRUE;
    return 0;
}

/* -assume_charset */
static int assume_charset_fun(char *next_arg)
{
    assumed_charset = TRUE;
    UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
    StrAllocCopy(UCAssume_MIMEcharset,
		 LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
    CTRACE((tfp, "assume_charset_fun %s ->%d ->%s\n",
	    NonNull(next_arg),
	    UCLYhndl_for_unspec,
	    UCAssume_MIMEcharset));
    return 0;
}

/* -assume_local_charset */
static int assume_local_charset_fun(char *next_arg)
{
    UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
    return 0;
}

/* -assume_unrec_charset */
static int assume_unrec_charset_fun(char *next_arg)
{
    UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(next_arg);
    return 0;
}

/* -auth */
static int auth_fun(char *next_arg)
{
    parse_authentication(next_arg, authentication_info);
    return 0;
}

/* -base */
static int base_fun(char *next_arg GCC_UNUSED)
{
    /*
     * Treat -source equivalently to an interactive download with
     * LYPrefixBaseToSource configured to TRUE, so that a BASE tag is prepended
     * for text/html content types.  We normally treat the module-wide global
     * LYPrefixBaseToSource flag as FALSE with -source, but force it TRUE,
     * later, if LYPrependBase is set TRUE here.  - FM
     */
    LYPrependBase = TRUE;
    if (HTOutputFormat == HTAtom_for("www/dump"))
	HTOutputFormat = HTAtom_for("www/download");

    return 0;
}

/* -cache */
static int cache_fun(char *next_arg)
{
    if (next_arg != 0)
	HTCacheSize = atoi(next_arg);
    /*
     * Limit size.
     */
    if (HTCacheSize < 2)
	HTCacheSize = 2;

    return 0;
}

/* -child */
static int child_fun(char *next_arg GCC_UNUSED)
{
    child_lynx = TRUE;
    no_disk_save = TRUE;
    no_mail = TRUE;
    return 0;
}

/* -child_relaxed */
static int child_relaxed_fun(char *next_arg GCC_UNUSED)
{
    child_lynx = TRUE;
    return 0;
}

#ifdef USE_SLANG
/* -color */
static int color_fun(char *next_arg GCC_UNUSED)
{
    Lynx_Color_Flags |= SL_LYNX_USE_COLOR;

    if (LYShowColor != SHOW_COLOR_ALWAYS)
	LYShowColor = SHOW_COLOR_ON;

    return 0;
}
#endif

#ifdef MISC_EXP
/* -convert_to */
static int convert_to_fun(char *next_arg)
{
    if (next_arg != 0) {
	char *outformat = NULL;
	char *cp1, *cp2, *cp4;
	int chndl;

	StrAllocCopy(outformat, next_arg);
	/* not lowercased, to allow for experimentation - kw */
	/*LYLowerCase(outformat); */
	if ((cp1 = StrChr(outformat, ';')) != NULL) {
	    if ((cp2 = LYstrstr(cp1, "charset")) != NULL) {
		cp2 += 7;
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '"')
		    cp2++;
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '"' &&
				 *cp4 != ';' &&
				 !WHITE(*cp4)); cp4++) ;	/* do nothing */
		*cp4 = '\0';
		/* This is intentionally not the "safe" version,
		   to allow for experimentation. */
		chndl = UCGetLYhndl_byMIME(cp2);
		if (chndl < 0)
		    chndl = UCLYhndl_for_unrec;
		if (chndl < 0) {
		    fprintf(stderr,
			    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
		} else {
		    current_char_set = chndl;
		}
		*cp1 = '\0';	/* truncate outformat */
	    }
	}
	HTOutputFormat = HTAtom_for(outformat);
	FREE(outformat);
    } else {
	HTOutputFormat = NULL;
    }
    return 0;
}
#endif

/* -crawl */
static int crawl_fun(char *next_arg GCC_UNUSED)
{
    crawl = TRUE;
    LYcols = DFT_COLS;
    return 0;
}

/* -display */
static int display_fun(char *next_arg)
{
    if (next_arg != 0) {
	LYsetXDisplay(next_arg);
    }

    return 0;
}

/* -display_charset */
static int display_charset_fun(char *next_arg)
{
    int i = UCGetLYhndl_byMIME(next_arg);

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
    if (i < 0 && !strcasecomp(next_arg, "auto"))
	i = auto_display_charset;
#endif
    if (i < 0) {		/* do nothing here: so fallback to lynx.cfg */
	fprintf(stderr,
		gettext("Lynx: ignoring unrecognized charset=%s\n"), next_arg);
    } else
	current_char_set = i;
    return 0;
}

/* -dump */
static int dump_output_fun(char *next_arg GCC_UNUSED)
{
    force_dump_mode();
    return 0;
}

/* -editor */
static int editor_fun(char *next_arg)
{
    if (next_arg != 0)
	StrAllocCopy(editor, next_arg);
    system_editor = TRUE;
    return 0;
}

/* -error_file */
static int error_file_fun(char *next_arg)
{
    /*
     * Output return (success/failure) code of an HTTP transaction.
     */
    if (next_arg != 0)
	http_error_file = next_arg;
    return 0;
}

#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
/* -exec */
static int exec_fun(char *next_arg GCC_UNUSED)
{
#ifndef NEVER_ALLOW_REMOTE_EXEC
    local_exec = TRUE;
#else
    local_exec_on_local_files = TRUE;
#endif /* NEVER_ALLOW_REMOTE_EXEC */
    return 0;
}
#endif

/* -get_data */
static int get_data_fun(char *next_arg GCC_UNUSED)
{
    /*
     * User data for GET form.
     */
    char **get_data;
    char *buf = NULL;

    /*
     * On Unix, conflicts with curses when interactive so let's force a dump.
     * -CL
     *
     * On VMS, mods have been made in LYCurses.c to deal with potential
     * conflicts, so don't force the dump here.  - FM
     */
#ifndef VMS
    force_dump_mode();
#endif /* VMS */

    StrAllocCopy(form_get_data, "?");	/* Prime the pump */
    get_data = &form_get_data;

    /*
     * Build GET data for later.  Stop reading when we see a line with "---" as
     * its first three characters.
     */
    while (GetStdin(&buf, TRUE)) {
	StrAllocCat(*get_data, buf);
    }

    CTRACE((tfp, "get_data:%s\n", *get_data));
    CTRACE((tfp, "get_data:%s\n", form_get_data));
    return 0;
}

/* -help */
static int help_fun(char *next_arg GCC_UNUSED)
{
    print_help_and_exit(0);
    return 0;
}

/* -hiddenlinks */
int hiddenlinks_fun(char *next_arg)
{
    /* *INDENT-OFF* */
    static Config_Enum table[] = {
	{ "merge",	HIDDENLINKS_MERGE },
	{ "listonly",	HIDDENLINKS_SEPARATE },
	{ "ignore",	HIDDENLINKS_IGNORE },
	{ NULL,		-1 },
    };
    /* *INDENT-ON* */

    if (next_arg != 0) {
	if (!LYgetEnum(table, next_arg, &LYHiddenLinks))
	    print_help_and_exit(-1);
    } else {
	LYHiddenLinks = HIDDENLINKS_MERGE;
    }

    return 0;
}

/* -homepage */
static int homepage_fun(char *next_arg)
{
    if (next_arg != 0) {
	StrAllocCopy(homepage, next_arg);
	LYEscapeStartfile(&homepage);
    }
    return 0;
}

/* -mime_header */
static int mime_header_fun(char *next_arg GCC_UNUSED)
{
    /*
     * Include mime headers and force source dump.
     */
    keep_mime_headers = TRUE;
    force_dump_mode();
    HTOutputFormat = (LYPrependBase ?
		      HTAtom_for("www/download") : HTAtom_for("www/dump"));
    LYcols = MAX_COLS;
    return 0;
}

#ifndef DISABLE_NEWS
/* -newschunksize */
static int newschunksize_fun(char *next_arg)
{
    if (next_arg != 0) {
	HTNewsChunkSize = atoi(next_arg);
	/*
	 * If the new HTNewsChunkSize exceeds the maximum,
	 * increase HTNewsMaxChunk to this size. - FM
	 */
	if (HTNewsChunkSize > HTNewsMaxChunk)
	    HTNewsMaxChunk = HTNewsChunkSize;
    }
    return 0;
}

/* -newsmaxchunk */
static int newsmaxchunk_fun(char *next_arg)
{
    if (next_arg) {
	HTNewsMaxChunk = atoi(next_arg);
	/*
	 * If HTNewsChunkSize exceeds the new maximum,
	 * reduce HTNewsChunkSize to this maximum. - FM
	 */
	if (HTNewsChunkSize > HTNewsMaxChunk)
	    HTNewsChunkSize = HTNewsMaxChunk;
    }
    return 0;
}
#endif /* not DISABLE_NEWS */

/* -nobold */
static int nobold_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(1);
    return 0;
}

/* -nobrowse */
static int nobrowse_fun(char *next_arg GCC_UNUSED)
{
    HTDirAccess = HT_DIR_FORBID;
    return 0;
}

/* -nocolor */
static int nocolor_fun(char *next_arg GCC_UNUSED)
{
    LYShowColor = SHOW_COLOR_NEVER;
#ifdef USE_SLANG
    Lynx_Color_Flags &= ~(unsigned) SL_LYNX_USE_COLOR;
    Lynx_Color_Flags |= SL_LYNX_OVERRIDE_COLOR;
#endif
    return 0;
}

/* -nopause */
static int nopause_fun(char *next_arg GCC_UNUSED)
{
    no_pause = TRUE;
    return 0;
}

/* -nomore */
static int nomore_fun(char *next_arg GCC_UNUSED)
{
    nomore = TRUE;
    return 0;
}

/* -noreverse */
static int noreverse_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(2);
    return 0;
}

/* -nounderline */
static int nounderline_fun(char *next_arg GCC_UNUSED)
{
    LYnoVideo(4);
    return 0;
}

#ifdef MISC_EXP
/* -nozap */
static int nozap_fun(char *next_arg)
{
    LYNoZapKey = 1;		/* everything but "initially" treated as "full" - kw */
    if (next_arg != 0) {
	if (strcasecomp(next_arg, "initially") == 0)
	    LYNoZapKey = 2;

    }
    return 0;
}
#endif /* MISC_EXP */

/* -pauth */
static int pauth_fun(char *next_arg)
{
    parse_authentication(next_arg, proxyauth_info);
    return 0;
}

/* -post_data */
static int post_data_fun(char *next_arg GCC_UNUSED)
{
    /*
     * User data for POST form.
     */
    char **post_data;
    char *buf = NULL;

    /*
     * On Unix, conflicts with curses when interactive so let's force a dump.
     * - CL
     *
     * On VMS, mods have been made in LYCurses.c to deal with potential
     * conflicts, so don't force a dump here.  - FM
     */
#ifndef VMS
    force_dump_mode();
#endif /* VMS */

    post_data = &form_post_data;

    /*
     * Build post data for later.  Stop reading when we see a line with "---"
     * as its first three characters.
     */
    while (GetStdin(&buf, TRUE)) {
	StrAllocCat(*post_data, buf);
    }
    return 0;
}

static const char *show_restriction(const char *name)
{
    const char *value = 0;

    switch (find_restriction(name, -1)) {
    case TRUE:
	value = "on";
	break;
    case FALSE:
	value = "off";
	break;
    default:
	value = "?";
	break;
    }
    return value;
}

/* -restrictions */
static int restrictions_fun(char *next_arg)
{
    /* *INDENT-OFF* */
    static const struct {
	const char *name;
	const char *help;
    } table[] = {
	{ "all", "restricts all options." },
	{ "bookmark", "disallow changing the location of the bookmark file" },
	{ "bookmark_exec", "disallow execution links via the bookmark file" },
#if defined(DIRED_SUPPORT) && defined(OK_PERMIT)
	{ "change_exec_perms", "\
disallow changing the eXecute permission on files\n\
(but still allow it for directories) when local file\n\
management is enabled." },
#endif /* DIRED_SUPPORT && OK_PERMIT */
#ifdef SUPPORT_CHDIR
	{ "chdir", "\
disallow changing the working directory of lynx, e.g.,\n\
to affect the behavior of download command" },
#endif
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	{ "compileopts_info", "\
disable info on options used to compile the binary" },
#endif
	{ "default", "\
same as commandline option -anonymous.  Sets the\n\
default service restrictions for anonymous users.  Set to\n\
all restricted, except for: inside_telnet, outside_telnet,\n\
inside_ftp, outside_ftp, inside_rlogin, outside_rlogin,\n\
inside_news, outside_news, telnet_port, jump, mail, print,\n\
exec, and goto.  The settings for these, as well as\n\
additional goto restrictions for specific URL schemes\n\
that are also applied, are derived from definitions\n\
within userdefs.h." },
#ifdef DIRED_SUPPORT
	{ "dired_support", "disallow local file management" },
#endif /* DIRED_SUPPORT */
	{ "disk_save", "disallow saving to disk in the download and print menus" },
	{ "dotfiles", "disallow access to, or creation of, hidden (dot) files" },
	{ "download", "disallow some downloaders in the download menu" },
	{ "editor", "disallow editing" },
	{ "exec", "disable execution scripts" },
	{ "exec_frozen", "disallow the user from changing the execution link option" },
#ifdef USE_EXTERNALS
	{ "externals", "disable passing URLs to some external programs" },
#endif
	{ "file_url", "\
disallow using G)oto, served links or bookmarks for\n\
file: URL's" },
	{ "goto", "disable the 'g' (goto) command" },
#if !defined(HAVE_UTMP) || defined(VMS) /* not selective */
	{ "inside_ftp", "\
disallow ftps coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain (utmp required for selectivity)" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your\n\
domain (utmp required for selectivity)" },
	{ "inside_telnet", "\
disallow telnets coming from inside your\n\
domain (utmp required for selectivity)" },
#else
	{ "inside_ftp", "\
disallow ftps coming from inside your domain" },
	{ "inside_news", "\
disallow USENET news reading and posting coming\n\
from inside your domain" },
	{ "inside_rlogin", "\
disallow rlogins coming from inside your domain" },
	{ "inside_telnet", "\
disallow telnets coming from inside your domain" },
#endif /* HAVE_UTMP || VMS */
	{ "jump", "disable the 'j' (jump) command" },
	{ "lynxcfg_info", "\
disable viewing of lynx.cfg configuration file info" },
#ifndef NO_CONFIG_INFO
	{ "lynxcfg_xinfo", "\
disable extended lynx.cfg viewing and reloading" },
#endif
	{ "lynxcgi", "\
disallow execution of Lynx CGI URLs" },
	{ "mail", "disallow mail" },
	{ "multibook", "disallow multiple bookmark files" },
	{ "news_post", "disallow USENET News posting." },
	{ "option_save", "disallow saving options in .lynxrc" },
#if !defined(HAVE_UTMP) || defined(VMS) /* not selective */
	{ "outside_ftp", "\
disallow ftps coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain (utmp required for selectivity)" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your\n\
domain (utmp required for selectivity)" },
	{ "outside_telnet", "\
disallow telnets coming from outside your\n\
domain (utmp required for selectivity)" },
#else
	{ "outside_ftp", "\
disallow ftp coming from outside your domain" },
	{ "outside_news", "\
disallow USENET news reading and posting coming\n\
from outside your domain" },
	{ "outside_rlogin", "\
disallow rlogins coming from outside your domain" },
	{ "outside_telnet", "\
disallow telnets coming from outside your domain" },
#endif /* !HAVE_UTMP || VMS */
	{ "print", "disallow most print options" },
	{ "shell", "\
disallow shell escapes, and lynxexec, lynxprog or lynxcgi\n\
G)oto's" },
	{ "suspend", "disallow Control-Z suspends with escape to shell" },
	{ "telnet_port", "disallow specifying a port in telnet G)oto's" },
	{ "useragent", "disallow modifications of the User-Agent header" },
    };
    /* *INDENT-ON* */

    static const char *Usage[] =
    {
	""
	,"USAGE: lynx -restrictions=[option][,option][,option]"
	,"List of Options:"
	,"  ?                 when used alone, list restrictions in effect."

    };
    unsigned j, k, column = 0;
    const char *name;
    const char *value;
    BOOLEAN found, first;

    if (isEmpty(next_arg)) {
	SetOutputMode(O_TEXT);
	for (j = 0; j < TABLESIZE(Usage); j++) {
	    printf("%s\n", Usage[j]);
	}
	for (j = 0; j < TABLESIZE(table); j++) {
	    if (!strcmp(table[j].name, "all")
		|| !strcmp(table[j].name, "default")) {
		value = NULL;
	    } else {
		value = show_restriction(table[j].name);
	    }
	    print_help_strings(table[j].name, table[j].help, value, FALSE);
	}
	first = TRUE;
	for (j = 0; j < TABLESIZE(table); j++) {
	    found = FALSE;
	    if ((name = index_to_restriction(j)) == 0) {
		break;
	    }
	    for (k = 0; k < TABLESIZE(table); k++) {
		if (!strcmp(name, table[k].name)) {
		    found = TRUE;
		}
	    }
	    if (!found) {
		if (first) {
		    printf("Other restrictions (see the user's guide):\n");
		}
		value = show_restriction(table[j].name);
		printf("%s%s (%s)", column ? ", " : "  ", name, value);
		column += (unsigned) (5 + strlen(name) + strlen(value));
		if (column > 50) {
		    column = 0;
		    printf("\n");
		}
		first = FALSE;
	    }
	}
	if (column)
	    printf("\n");
	SetOutputMode(O_BINARY);
	exit_immediately(EXIT_SUCCESS);
    } else if (*next_arg == '?') {
	SetOutputMode(O_TEXT);
	print_restrictions_to_fd(stdout);
	SetOutputMode(O_BINARY);
	exit_immediately(EXIT_SUCCESS);
    } else {
	parse_restrictions(next_arg);
    }
    return 0;
}

/* -selective */
static int selective_fun(char *next_arg GCC_UNUSED)
{
    HTDirAccess = HT_DIR_SELECTIVE;
    return 0;
}

/* -source */
static int source_fun(char *next_arg GCC_UNUSED)
{
    force_dump_mode();
    HTOutputFormat = (LYPrependBase ?
		      HTAtom_for("www/download") : HTAtom_for("www/dump"));
    LYcols = MAX_COLS;
    return 0;
}

/* -traversal */
static int traversal_fun(char *next_arg GCC_UNUSED)
{
    traversal = TRUE;
#ifdef USE_SLANG
    LYcols = DFT_COLS;
#else
    LYcols = MAX_COLS;
#endif /* USE_SLANG */

    return 0;
}

/* -version */
static int version_fun(char *next_arg GCC_UNUSED)
{
    char *result = NULL;

    SetLocale();
    SetOutputMode(O_TEXT);

    HTSprintf0(&result, gettext("%s Version %s (%s)"),
	       LYNX_NAME, LYNX_VERSION,
	       LYVersionDate());

    StrAllocCat(result, "\n");
#ifdef USE_SSL
    HTSprintf(&result, "libwww-FM %s,", HTLibraryVersion);
    append_ssl_version(&result, " ");
#else
    HTSprintf(&result, "libwww-FM %s", HTLibraryVersion);
#endif /* USE_SSL */

#if defined(NCURSES) && defined(HAVE_CURSES_VERSION)
    HTSprintf(&result, ", %s", curses_version());
#if defined(WIDEC_CURSES)
    HTSprintf(&result, "(wide)");
#endif
#elif defined(PDCURSES) && defined(PDC_BUILD)
    HTSprintf(&result, ", pdcurses %.3f", PDC_BUILD * 0.001);
#elif defined(USE_SLANG) && defined(SLANG_VERSION_STRING)
    HTSprintf(&result, ", s-lang %s", SLANG_VERSION_STRING);
#endif

    printf("%s\n", result);
    free(result);

#ifndef __DATE__
#define __DATE__ ""
#endif
#ifndef __TIME__
#define __TIME__ ""
#endif

/*
 * SYSTEM_NAME is set by the configure script.  Show build date/time for other
 * systems, according to predefined compiler symbols.
 */
#ifdef SYSTEM_NAME
    printf(gettext("Built on %s %s %s\n"), SYSTEM_NAME, __DATE__, __TIME__);
#else
#ifdef __CYGWIN__
    printf("Compiled by CYGWIN (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __BORLANDC__
    printf("Compiled by Borland C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef _MSC_VER
    printf("Compiled by Microsoft Visual C++ (%s %s).\n", __DATE__, __TIME__);
#else
#ifdef __DJGPP__
    printf("Compiled by DJGPP (%s %s).\n", __DATE__, __TIME__);
#else
    printf("Compiled at (%s %s).\n", __DATE__, __TIME__);
#endif /* __DJGPP__ */
#endif /* _MSC_VER */
#endif /* __BORLANDC__ */
#endif /* __CYGWIN__ */
#endif

    puts("");
    puts(gettext("Copyrights held by the Lynx Developers Group,"));
    puts(gettext("the University of Kansas, CERN, and other contributors."));
    puts(gettext("Distributed under the GNU General Public License (Version 2)."));
    puts(gettext("See http://lynx.isc.org/ and the online help for more information."));
    puts("");
#ifdef USE_SSL
#if defined(OPENSSL_VERSION_TEXT) && !defined(LIBGNUTLS_VERSION)
    puts("See http://www.openssl.org/ for information about OpenSSL.");
#endif /* OPENSSL_VERSION_TEXT */
    puts("");
#endif /* USE_SSL */

    SetOutputMode(O_BINARY);

    exit_immediately(EXIT_SUCCESS);
    /* NOT REACHED */
    return 0;
}

/* -width */
static int width_fun(char *next_arg)
{
    if (next_arg != 0) {
	int w = atoi(next_arg);

	if (w > 0)
	    dump_output_width = ((w < MAX_COLS) ? w : MAX_COLS);
    }

    return 0;
}

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* -scrsize */
static int scrsize_fun(char *next_arg)
{
    if (next_arg != 0) {
	char *cp;

	if ((cp = StrChr(next_arg, ',')) != 0) {
	    *cp++ = '\0';	/* Terminate ID */
	    scrsize_x = atoi(next_arg);
	    scrsize_y = atoi(cp);
	    if ((scrsize_x <= 1) || (scrsize_y <= 1)) {
		scrsize_x = scrsize_y = 0;
	    }
	    if ((scrsize_x > 0) && (scrsize_x < 80)) {
		scrsize_x = 80;
	    }
	    if ((scrsize_y > 0) && (scrsize_y < 4)) {
		scrsize_y = 4;
	    }
	    CTRACE((tfp, "scrsize: x=%d, y=%d\n", scrsize_x, scrsize_y));
	}
    }
    return 0;
}
#endif

/* NOTE: This table is sorted by name to make the help message useful */
/* *INDENT-OFF* */
static Config_Type Arg_Table [] =
{
   PARSE_SET(
      "accept_all_cookies", 4|SET_ARG,		LYAcceptAllCookies,
      "\naccept cookies without prompting if Set-Cookie handling\nis on"
   ),
#if USE_BLAT_MAILER
   PARSE_SET(
      "altblat",	4|TOGGLE_ARG,		mail_is_altblat,
      "select mail tool (`"THIS_BLAT_MAIL"' ==> `"THAT_BLAT_MAIL"')"
   ),
#endif
   PARSE_FUN(
      "anonymous",	2|FUNCTION_ARG,		anonymous_fun,
      "apply restrictions for anonymous account,\nsee also -restrictions"
   ),
   PARSE_FUN(
      "assume_charset", 4|NEED_FUNCTION_ARG,	assume_charset_fun,
      "=MIMEname\ncharset for documents that don't specify it"
   ),
   PARSE_FUN(
      "assume_local_charset", 4|NEED_FUNCTION_ARG, assume_local_charset_fun,
      "=MIMEname\ncharset assumed for local files"
   ),
   PARSE_FUN(
      "assume_unrec_charset", 4|NEED_FUNCTION_ARG, assume_unrec_charset_fun,
      "=MIMEname\nuse this instead of unrecognized charsets"
   ),
   PARSE_FUN(
      "auth",		4|NEED_FUNCTION_ARG,	auth_fun,
      "=id:pw\nauthentication information for protected documents"
   ),
   PARSE_FUN(
      "base",		4|FUNCTION_ARG,		base_fun,
      "prepend a request URL comment and BASE tag to text/html\n\
outputs for -source dumps"
   ),
#ifndef DISABLE_BIBP
   PARSE_STR(
      "bibhost",	4|NEED_LYSTRING_ARG,	BibP_bibhost,
      "=URL\nlocal bibp server (default http://bibhost/)"
   ),
#endif
#ifdef USE_BLINK
   PARSE_SET(
      "blink",		4|SET_ARG,		term_blink_is_boldbg,
      "enable bright background via the BLINK terminal attribute"
   ),
#endif
   PARSE_SET(
      "book",		4|SET_ARG,		bookmark_start,
      "use the bookmark page as the startfile"
   ),
   PARSE_SET(
      "buried_news",	4|TOGGLE_ARG,		scan_for_buried_news_references,
      "toggles scanning of news articles for buried references"
   ),
   PARSE_FUN(
      "cache",		4|NEED_FUNCTION_ARG,	cache_fun,
      "=NUMBER\nNUMBER of documents cached in memory"
   ),
   PARSE_SET(
      "case",		4|SET_ARG,		LYcase_sensitive,
      "enable case sensitive user searching"
   ),
   PARSE_SET(
      "center",		4|TOGGLE_ARG,		no_table_center,
      "toggle center alignment in HTML TABLE"
   ),
   PARSE_STR(
      "cfg",		2|NEED_LYSTRING_ARG,	lynx_cfg_file,
      "=FILENAME\nspecifies a lynx.cfg file other than the default"
   ),
   PARSE_FUN(
      "child",		4|FUNCTION_ARG,		child_fun,
      "exit on left-arrow in startfile, and disable save to disk"
   ),
   PARSE_FUN(
      "child_relaxed",	4|FUNCTION_ARG,		child_relaxed_fun,
      "exit on left-arrow in startfile (allows save to disk)"
   ),
#ifdef USE_CMD_LOGGING
   PARSE_STR(
      "cmd_log",	2|NEED_LYSTRING_ARG,	lynx_cmd_logfile,
      "=FILENAME\nlog keystroke commands to the given file"
   ),
   PARSE_STR(
      "cmd_script",	2|NEED_LYSTRING_ARG,	lynx_cmd_script,
      "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
   ),
#endif
#ifdef USE_SLANG
   PARSE_FUN(
      "color",		4|FUNCTION_ARG,		color_fun,
      "force color mode on with standard bg colors"
   ),
#endif
   PARSE_INT(
      "connect_timeout", 4|NEED_INT_ARG,	connect_timeout,
      "=N\nset the N-second connection timeout"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "convert_to",	4|FUNCTION_ARG,		convert_to_fun,
      "=FORMAT\nconvert input, FORMAT is in MIME type notation\n(experimental)"
   ),
#endif
#ifdef USE_PERSISTENT_COOKIES
   PARSE_STR(
      "cookie_file",	4|LYSTRING_ARG,		LYCookieFile,
      "=FILENAME\nspecifies a file to use to read cookies"
   ),
   PARSE_STR(
      "cookie_save_file", 4|LYSTRING_ARG,	LYCookieSaveFile,
      "=FILENAME\nspecifies a file to use to store cookies"
   ),
#endif /* USE_PERSISTENT_COOKIES */
   PARSE_SET(
      "cookies",	4|TOGGLE_ARG,		LYSetCookies,
      "toggles handling of Set-Cookie headers"
   ),
#ifndef VMS
   PARSE_SET(
      "core",		4|TOGGLE_ARG,		LYNoCore,
      "toggles forced core dumps on fatal errors"
   ),
#endif
   PARSE_FUN(
      "crawl",		4|FUNCTION_ARG,		crawl_fun,
      "with -traversal, output each page to a file\n\
with -dump, format output as with -traversal, but to stdout"
   ),
#ifdef USE_CURSES_PADS
   PARSE_SET(
      "curses_pads",	4|TOGGLE_ARG,		LYuseCursesPads,
      "uses curses pad feature to support left/right shifting"
   ),
#endif
#ifdef DISP_PARTIAL
   PARSE_SET(
      "debug_partial",	4|TOGGLE_ARG,		debug_display_partial,
      "incremental display stages with MessageSecs delay"
   ),
#endif
#ifdef USE_DEFAULT_COLORS
   PARSE_SET(
      "default_colors",	4|TOGGLE_ARG,		LYuse_default_colors,
      "use terminal default foreground/background colors"
   ),
#endif
   PARSE_INT(
      "delay",		4|NEED_TIME_ARG,	DelaySecs,
      "=NNN\nset NNN-second delay at statusline message"
   ),
   PARSE_FUN(
      "display",	4|NEED_FUNCTION_ARG,	display_fun,
      "=DISPLAY\nset the display variable for X exec'ed programs"
   ),
   PARSE_FUN(
      "display_charset", 4|NEED_FUNCTION_ARG,	display_charset_fun,
      "=MIMEname\ncharset for the terminal output"
   ),
   PARSE_SET(
      "dont_wrap_pre",	4|SET_ARG,		dont_wrap_pre,
      "inhibit wrapping of text in <pre> when -dump'ing and\n\
-crawl'ing, mark wrapped lines in interactive session"
   ),
   PARSE_FUN(
      "dump",		1|FUNCTION_ARG,		dump_output_fun,
      "dump the first file to stdout and exit"
   ),
   PARSE_FUN(
      "editor",		4|NEED_FUNCTION_ARG,	editor_fun,
      "=EDITOR\nenable edit mode with specified editor"
   ),
   PARSE_SET(
      "emacskeys",	4|SET_ARG,		emacs_keys,
      "enable emacs-like key movement"
   ),
   PARSE_SET(
      "enable_scrollback", 4|TOGGLE_ARG,	enable_scrollback,
      "\ntoggles compatibility with comm programs' scrollback\n\
keys (may be incompatible with some curses packages)"
   ),
   PARSE_FUN(
      "error_file",	4|NEED_FUNCTION_ARG,	error_file_fun,
      "=FILE\nwrite the HTTP status code here"
   ),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifndef NEVER_ALLOW_REMOTE_EXEC
   PARSE_FUN(
      "exec",		4|FUNCTION_ARG,		exec_fun,
      "enable local program execution"
   ),
#endif
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#ifdef VMS
   PARSE_SET(
      "fileversions",	4|SET_ARG,		HTVMSFileVersions,
      "include all versions of files in local VMS directory\nlistings"
   ),
#endif
#ifdef LY_FIND_LEAKS
   PARSE_SET(
      "find_leaks",	4|TOGGLE_ARG,		LYfind_leaks,
      "toggles memory-leak checking"
   ),
#endif
   PARSE_SET(
      "force_empty_hrefless_a",	4|SET_ARG,	force_empty_hrefless_a,
      "\nforce HREF-less 'A' elements to be empty (close them as\n\
soon as they are seen)"
   ),
   PARSE_SET(
      "force_html",	4|SET_ARG,		LYforce_HTML_mode,
      "forces the first document to be interpreted as HTML"
   ),
   PARSE_SET(
      "force_secure",	4|TOGGLE_ARG,		LYForceSSLCookiesSecure,
      "toggles forcing of the secure flag for SSL cookies"
   ),
#if !defined(NO_OPTION_FORMS) && !defined(NO_OPTION_MENU)
   PARSE_SET(
      "forms_options",	4|TOGGLE_ARG,		LYUseFormsOptions,
      "toggles forms-based vs old-style options menu"
   ),
#endif
   PARSE_SET(
      "from",		4|TOGGLE_ARG,		LYNoFromHeader,
      "toggle transmission of From headers"
   ),
#ifndef DISABLE_FTP
   PARSE_SET(
      "ftp",		4|UNSET_ARG,		ftp_ok,
      "disable ftp access"
   ),
#endif
   PARSE_FUN(
      "get_data",	2|FUNCTION_ARG,		get_data_fun,
      "user data for get forms, read from stdin,\nterminated by '---' on a line"
   ),
   PARSE_SET(
      "head",		4|SET_ARG,		HEAD_request,
      "send a HEAD request"
   ),
   PARSE_FUN(
      "help",		4|FUNCTION_ARG,		help_fun,
      "print this usage message"
   ),
   PARSE_FUN(
      "hiddenlinks",	4|NEED_FUNCTION_ARG,	hiddenlinks_fun,
      "=[option]\nhidden links: options are merge, listonly, or ignore"
   ),
   PARSE_SET(
      "historical",	4|TOGGLE_ARG,		historical_comments,
      "toggles use of '>' or '-->' as terminator for comments"
   ),
   PARSE_FUN(
      "homepage",	4|NEED_FUNCTION_ARG,	homepage_fun,
      "=URL\nset homepage separate from start page"
   ),
   PARSE_SET(
      "html5_charsets",	4|TOGGLE_ARG,		html5_charsets,
      "toggles use of HTML5 charset replacements"
   ),
   PARSE_SET(
      "image_links",	4|TOGGLE_ARG,		clickable_images,
      "toggles inclusion of links for all images"
   ),
   PARSE_STR(
      "index",		4|NEED_LYSTRING_ARG,	indexfile,
      "=URL\nset the default index file to URL"
   ),
   PARSE_SET(
      "ismap",		4|TOGGLE_ARG,		LYNoISMAPifUSEMAP,
      "toggles inclusion of ISMAP links when client-side\nMAPs are present"
   ),
#ifdef USE_JUSTIFY_ELTS
   PARSE_SET(
      "justify",	4|SET_ARG,		ok_justify,
      "do justification of text"
   ),
#endif
   PARSE_INT(
      "link",		4|NEED_INT_ARG,		crawl_count,
      "=NUMBER\nstarting count for lnk#.dat files produced by -crawl"
   ),
   PARSE_SET(
      "list_inline",	4|TOGGLE_ARG,		dump_links_inline,
      "with -dump, forces it to show links inline with text"
   ),
   PARSE_SET(
      "listonly",	4|TOGGLE_ARG,		dump_links_only,
      "with -dump, forces it to show only the list of links"
   ),
   PARSE_SET(
      "localhost",	4|SET_ARG,		local_host_only,
      "disable URLs that point to remote hosts"
   ),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "locexec",	4|SET_ARG,		local_exec_on_local_files,
      "enable local program execution from local files only"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
#if defined(USE_COLOR_STYLE)
   PARSE_STR(
      "lss",		2|NEED_LYSTRING_ARG,	lynx_lss_file2,
      "=FILENAME\nspecifies a lynx.lss file other than the default"
   ),
#endif
   PARSE_FUN(
      "mime_header",	4|FUNCTION_ARG,		mime_header_fun,
      "include mime headers and force source dump"
   ),
   PARSE_SET(
      "minimal",	4|TOGGLE_ARG,		minimal_comments,
      "toggles minimal versus valid comment parsing"
   ),
#ifdef EXP_NESTED_TABLES
   PARSE_SET(
      "nested_tables",	4|TOGGLE_ARG,		nested_tables,
      "toggles nested-tables logic"
   ),
#endif
#ifndef DISABLE_NEWS
   PARSE_FUN(
      "newschunksize",	4|NEED_FUNCTION_ARG,	newschunksize_fun,
      "=NUMBER\nnumber of articles in chunked news listings"
   ),
   PARSE_FUN(
      "newsmaxchunk",	4|NEED_FUNCTION_ARG,	newsmaxchunk_fun,
      "=NUMBER\nmaximum news articles in listings before chunking"
   ),
#endif
#if USE_BLAT_MAILER
   PARSE_SET(
      "noblat",		4|TOGGLE_ARG,		mail_is_blat,
      "select mail tool (`"THIS_BLAT_MAIL"' ==> `"SYSTEM_MAIL"')"
   ),
#endif
   PARSE_FUN(
      "nobold",		4|FUNCTION_ARG,		nobold_fun,
      "disable bold video-attribute"
   ),
   PARSE_FUN(
      "nobrowse",	4|FUNCTION_ARG,		nobrowse_fun,
      "disable directory browsing"
   ),
   PARSE_SET(
      "nocc",		4|SET_ARG,		LYNoCc,
      "disable Cc: prompts for self copies of mailings"
   ),
   PARSE_FUN(
      "nocolor",	4|FUNCTION_ARG,		nocolor_fun,
      "turn off color support"
   ),
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
   PARSE_SET(
      "noexec",		4|UNSET_ARG,		local_exec,
      "disable local program execution (DEFAULT)"
   ),
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
   PARSE_SET(
      "nofilereferer",	4|SET_ARG,		no_filereferer,
      "disable transmission of Referer headers for file URLs"
   ),
   PARSE_SET(
      "nolist",		4|SET_ARG,		no_list,
      "disable the link list feature in dumps"
   ),
   PARSE_SET(
      "nolog",		4|UNSET_ARG,		error_logging,
      "disable mailing of error messages to document owners"
   ),
   PARSE_SET(
      "nomargins",	4|SET_ARG,		no_margins,
      "disable the right/left margins in the default\nstyle-sheet"
   ),
   PARSE_FUN(
      "nomore",		4|FUNCTION_ARG,		nomore_fun,
      "disable -more- string in statusline messages"
   ),
#if defined(HAVE_SIGACTION) && defined(SIGWINCH)
   PARSE_SET(
      "nonrestarting_sigwinch", 4|SET_ARG,	LYNonRestartingSIGWINCH,
      "\nmake window size change handler non-restarting"
   ),
#endif /* HAVE_SIGACTION */
   PARSE_SET(
      "nonumbers",	4|SET_ARG,		no_numbers,
      "disable the link/form numbering feature in dumps"
   ),
   PARSE_FUN(
      "nopause",	4|FUNCTION_ARG,		nopause_fun,
      "disable forced pauses for statusline messages"
   ),
   PARSE_SET(
      "noprint",	4|SET_ARG,		no_print,
      "disable some print functions, like -restrictions=print"
   ),
   PARSE_SET(
      "noredir",	4|SET_ARG,		no_url_redirection,
      "don't follow Location: redirection"
   ),
   PARSE_SET(
      "noreferer",	4|SET_ARG,		LYNoRefererHeader,
      "disable transmission of Referer headers"
   ),
   PARSE_FUN(
      "noreverse",	4|FUNCTION_ARG,		noreverse_fun,
      "disable reverse video-attribute"
   ),
#ifdef SOCKS
   PARSE_SET(
      "nosocks",	2|UNSET_ARG,		socks_flag,
      "don't use SOCKS proxy for this session"
   ),
#endif
   PARSE_SET(
      "nostatus",	4|SET_ARG,		no_statusline,
      "disable the miscellaneous information messages"
   ),
   PARSE_SET(
      "notitle",	4|SET_ARG,		no_title,
      "disable the title at the top of each page"
   ),
   PARSE_FUN(
      "nounderline",	4|FUNCTION_ARG,		nounderline_fun,
      "disable underline video-attribute"
   ),
#ifdef MISC_EXP
   PARSE_FUN(
      "nozap",		4|FUNCTION_ARG,		nozap_fun,
      "=DURATION (\"initially\" or \"full\") disable checks for 'z' key"
   ),
#endif
   PARSE_SET(
      "number_fields",	4|SET_ARG,		number_fields,
      "force numbering of links as well as form input fields"
   ),
   PARSE_SET(
      "number_links",	4|SET_ARG,		number_links,
      "force numbering of links"
   ),
#ifdef DISP_PARTIAL
   PARSE_SET(
      "partial",	4|TOGGLE_ARG,		display_partial_flag,
      "toggles display partial pages while downloading"
   ),
   PARSE_INT(
      "partial_thres",	4|NEED_INT_ARG,		partial_threshold,
      "[=NUMBER]\nnumber of lines to render before repainting display\n\
with partial-display logic"
   ),
#endif
#ifndef DISABLE_FTP
   PARSE_SET(
      "passive-ftp",	4|TOGGLE_ARG,		ftp_passive,
      "toggles passive ftp connection"
   ),
#endif
   PARSE_FUN(
      "pauth",		4|NEED_FUNCTION_ARG,	pauth_fun,
      "=id:pw\nauthentication information for protected proxy server"
   ),
   PARSE_SET(
      "popup",		4|UNSET_ARG,		LYUseDefSelPop,
      "toggles handling of single-choice SELECT options via\n\
popup windows or as lists of radio buttons"
   ),
   PARSE_FUN(
      "post_data",	2|FUNCTION_ARG,		post_data_fun,
      "user data for post forms, read from stdin,\n\
terminated by '---' on a line"
   ),
   PARSE_SET(
      "preparsed",	4|SET_ARG,		LYPreparsedSource,
      "show parsed text/html with -source and in source view\n\
to visualize how lynx behaves with invalid HTML"
   ),
#ifdef USE_PRETTYSRC
   PARSE_SET(
      "prettysrc",	4|SET_ARG,		LYpsrc,
      "do syntax highlighting and hyperlink handling in source\nview"
   ),
#endif
   PARSE_SET(
      "print",		4|UNSET_ARG,		no_print,
      "enable print functions (DEFAULT), opposite of -noprint"
   ),
   PARSE_SET(
      "pseudo_inlines", 4|TOGGLE_ARG,		pseudo_inline_alts,
      "toggles pseudo-ALTs for inlines with no ALT string"
   ),
   PARSE_SET(
      "raw",		4|UNSET_ARG,		LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\n\
or CJK mode for the startup character set"
   ),
   PARSE_SET(
      "realm",		4|SET_ARG,		check_realm,
      "restricts access to URLs in the starting realm"
   ),
   PARSE_INT(
      "read_timeout",	4|NEED_INT_ARG,		reading_timeout,
      "=N\nset the N-second read-timeout"
   ),
   PARSE_SET(
      "reload",		4|SET_ARG,		reloading,
      "flushes the cache on a proxy server\n(only the first document affected)"
   ),
   PARSE_FUN(
      "restrictions",	4|FUNCTION_ARG,		restrictions_fun,
      "=[options]\nuse -restrictions to see list"
   ),
   PARSE_SET(
      "resubmit_posts", 4|TOGGLE_ARG,		LYresubmit_posts,
      "toggles forced resubmissions (no-cache) of forms with\n\
method POST when the documents they returned are sought\n\
with the PREV_DOC command or from the History List"
   ),
   PARSE_SET(
      "rlogin",		4|UNSET_ARG,		rlogin_ok,
      "disable rlogins"
   ),
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
   PARSE_FUN(
      "scrsize",	4|NEED_FUNCTION_ARG,	scrsize_fun,
      "=width,height\nsize of window"
   ),
#endif
#ifdef USE_SCROLLBAR
   PARSE_SET(
      "scrollbar",	4|TOGGLE_ARG,		LYShowScrollbar,
      "toggles showing scrollbar"
   ),
   PARSE_SET(
      "scrollbar_arrow", 4|TOGGLE_ARG,		LYsb_arrow,
      "toggles showing arrows at ends of the scrollbar"
   ),
#endif
   PARSE_FUN(
      "selective",	4|FUNCTION_ARG,		selective_fun,
      "require .www_browsable files to browse directories"
   ),
#ifdef USE_SESSIONS
   PARSE_STR(
      "session",	2|NEED_LYSTRING_ARG,	session_file,
      "=FILENAME\nresumes from specified file on startup and\n\
saves session to that file on exit"
   ),
   PARSE_STR(
      "sessionin",	2|NEED_LYSTRING_ARG,	sessionin_file,
      "=FILENAME\nresumes session from specified file"
   ),
   PARSE_STR(
      "sessionout",	2|NEED_LYSTRING_ARG,	sessionout_file,
      "=FILENAME\nsaves session to specified file"
   ),
#endif /* USE_SESSIONS */
   PARSE_SET(
      "short_url",	4|SET_ARG,		long_url_ok,
      "enables examination of beginning and end of long URL in\nstatus line"
   ),
   PARSE_SET(
      "show_cfg",	1|SET_ARG,		show_cfg,
      "Show `LYNX.CFG' setting"
   ),
   PARSE_SET(
      "show_cursor",	4|TOGGLE_ARG,		LYUseDefShoCur,
      "toggles hiding of the cursor in the lower right corner"
   ),
#ifdef USE_READPROGRESS
   PARSE_SET(
      "show_rate",	4|TOGGLE_ARG,		LYShowTransferRate,
      "toggles display of transfer rate"
   ),
#endif
   PARSE_SET(
      "soft_dquotes",	4|TOGGLE_ARG,		soft_dquotes,
      "toggles emulation of the old Netscape and Mosaic\n\
bug which treated '>' as a co-terminator for\ndouble-quotes and tags"
   ),
   PARSE_FUN(
      "source",		4|FUNCTION_ARG,		source_fun,
      "dump the source of the first file to stdout and exit"
   ),
   PARSE_SET(
      "stack_dump",	4|SET_ARG,		stack_dump,
      "disable SIGINT cleanup handler"
   ),
   PARSE_SET(
      "startfile_ok",	4|SET_ARG,		startfile_ok,
      "allow non-http startfile and homepage with -validate"
   ),
   PARSE_SET(
      "stderr",		4|SET_ARG,		dump_to_stderr,
      "write warning messages to standard error when -dump\nor -source is used"
   ),
   PARSE_SET(
      "stdin",		4|SET_ARG,		startfile_stdin,
      "read startfile from standard input"
   ),
#ifdef SYSLOG_REQUESTED_URLS
   PARSE_STR(
      "syslog",		4|NEED_LYSTRING_ARG,	syslog_txt,
      "=text\ninformation for syslog call"
   ),
   PARSE_SET(
      "syslog-urls",	4|SET_ARG,		syslog_requested_urls,
      "log requested URLs with syslog"
   ),
#endif
   PARSE_SET(
      "tagsoup",	4|SET_ARG,		DTD_recovery,
      "use TagSoup rather than SortaSGML parser"
   ),
   PARSE_SET(
      "telnet",		4|UNSET_ARG,		telnet_ok,
      "disable telnets"
   ),
   PARSE_STR(
      "term",		4|NEED_STRING_ARG,	terminal,
      "=TERM\nset terminal type to TERM"
   ),
#ifdef _WINDOWS
   PARSE_INT(
      "timeout",	4|INT_ARG,		lynx_timeout,
      "=NUMBER\nset TCP/IP timeout"
   ),
#endif
   PARSE_SET(
      "tlog",		2|TOGGLE_ARG,		LYUseTraceLog,
      "toggles use of a Lynx Trace Log for the current\nsession"
   ),
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
   PARSE_SET(
      "tna",		4|SET_ARG,		textfields_activation_option,
      "turn on \"Textfields Need Activation\" mode"
   ),
#endif
#ifndef NO_LYNX_TRACE
   PARSE_SET(
      "trace",		1|SET_ARG,		WWW_TraceFlag,
      "turns on Lynx trace mode"
   ),
   PARSE_INT(
      "trace_mask",	1|INT_ARG,		WWW_TraceMask,
      "customize Lynx trace mode"
   ),
#endif
   PARSE_FUN(
      "traversal",	4|FUNCTION_ARG,		traversal_fun,
      "traverse all http links derived from startfile"
   ),
   PARSE_SET(
      "trim_input_fields", 2|SET_ARG,		LYtrimInputFields,
      "\ntrim input text/textarea fields in forms"
   ),
   PARSE_SET(
      "underline_links",4|TOGGLE_ARG,		LYUnderlineLinks,
      "toggles use of underline/bold attribute for links"
   ),
   PARSE_SET(
      "underscore",	4|TOGGLE_ARG,		use_underscore,
      "toggles use of _underline_ format in dumps"
   ),
   PARSE_SET(
      "unique_urls",	4|TOGGLE_ARG,		unique_urls,
      "toggles use of unique-urls setting for -dump and -listonly options"
   ),
#if defined(USE_MOUSE)
   PARSE_SET(
      "use_mouse",	4|SET_ARG,		LYUseMouse,
      "turn on mouse support"
   ),
#endif
   PARSE_STR(
      "useragent",	4|NEED_LYSTRING_ARG,	LYUserAgent,
      "=Name\nset alternate Lynx User-Agent header"
   ),
   PARSE_SET(
      "validate",	2|SET_ARG,		LYValidate,
      "accept only http URLs (meant for validation)\n\
implies more restrictions than -anonymous, but\n\
goto is allowed for http and https"
   ),
   PARSE_SET(
      "verbose",	4|TOGGLE_ARG,		verbose_img,
      "toggles [LINK], [IMAGE] and [INLINE] comments\n\
with filenames of these images"
   ),
   PARSE_FUN(
      "version",	1|FUNCTION_ARG,		version_fun,
      "print Lynx version information"
   ),
   PARSE_SET(
      "vikeys",		4|SET_ARG,		vi_keys,
      "enable vi-like key movement"
   ),
#ifdef __DJGPP__
   PARSE_SET(
      "wdebug",		4|TOGGLE_ARG,		watt_debug,
      "enables Waterloo tcp/ip packet debug. Prints to watt\ndebugfile"
  ),
#endif /* __DJGPP__ */
   PARSE_FUN(
      "width",		4|NEED_FUNCTION_ARG,	width_fun,
      "=NUMBER\nscreen width for formatting of dumps (default is 80)"
   ),
#ifndef NO_DUMP_WITH_BACKSPACES
   PARSE_SET(
      "with_backspaces", 4|SET_ARG,		with_backspaces,
      "emit backspaces in output if -dumping or -crawling\n(like 'man' does)"
   ),
#endif
   PARSE_SET(
      "xhtml-parsing",	4|SET_ARG,		LYxhtml_parsing,
      "enable XHTML 1.0 parsing"
   ),
   PARSE_NIL
};
/* *INDENT-ON* */

static void print_help_strings(const char *name,
			       const char *help,
			       const char *value,
			       int option)
{
    int pad;
    int c;
    int first;
    int field_width = 20;

    pad = field_width - (2 + option + (int) strlen(name));

    fprintf(stdout, "  %s%s", option ? "-" : "", name);

    if (*help != '=') {
	pad--;
	while (pad > 0) {
	    fputc(' ', stdout);
	    pad--;
	}
	fputc(' ', stdout);	/* at least one space */
	first = 0;
    } else {
	first = pad;
    }

    if (StrChr(help, '\n') == 0) {
	fprintf(stdout, "%s", help);
    } else {
	while ((c = *help) != 0) {
	    if (c == '\n') {
		if ((pad = --first) < 0) {
		    pad = field_width;
		} else {
		    c = ' ';
		}
		fputc(c, stdout);
		while (pad--)
		    fputc(' ', stdout);
	    } else {
		fputc(c, stdout);
	    }
	    help++;
	    first--;
	}
    }
    if (value)
	printf(" (%s)", value);
    fputc('\n', stdout);
}

static void print_help_and_exit(int exit_status)
{
    Config_Type *p;

    if (pgm == NULL)
	pgm = "lynx";

    SetOutputMode(O_TEXT);

    fprintf(stdout, gettext("USAGE: %s [options] [file]\n"), pgm);
    fprintf(stdout, gettext("Options are:\n"));
#ifdef VMS
    print_help_strings("",
		       "receive the arguments from stdin (enclose\n\
in double-quotes (\"-\") on VMS)", NULL, TRUE);
#else
    print_help_strings("", "receive options and arguments from stdin", NULL, TRUE);
#endif /* VMS */

    for (p = Arg_Table; p->name != 0; p++) {
	char temp[LINESIZE], *value = temp;
	ParseUnionPtr q = ParseUnionOf(p);

	switch (p->type & ARG_TYPE_MASK) {
	case TOGGLE_ARG:
	case SET_ARG:
	    strcpy(temp, *(q->set_value) ? "on" : "off");
	    break;
	case UNSET_ARG:
	    strcpy(temp, *(q->set_value) ? "off" : "on");
	    break;
	case INT_ARG:
	    sprintf(temp, "%d", *(q->int_value));
	    break;
	case TIME_ARG:
	    sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
	    break;
	case STRING_ARG:
	    if ((value = *(q->str_value)) != 0
		&& !*value)
		value = 0;
	    break;
	default:
	    value = 0;
	    break;
	}
	print_help_strings(p->name, p->help_string, value, TRUE);
    }

    SetOutputMode(O_BINARY);

    exit_immediately(exit_status);
}

/*
 * This function performs a string comparison on two strings a and b.  a is
 * assumed to be an ordinary null terminated string, but b may be terminated
 * by an '=', '+' or '-' character.  If terminated by '=', *c will be pointed
 * to the character following the '='.  If terminated by '+' or '-', *c will
 * be pointed to that character.  (+/- added for toggle processing - BL.)
 * If a and b match, it returns 1.  Otherwise 0 is returned.
 */
static int arg_eqs_parse(const char *a,
			 char *b,
			 char **c)
{
    int result = -1;

    *c = NULL;
    while (result < 0) {
	if ((*a != *b)
	    || (*a == 0)
	    || (*b == 0)) {
	    if (*a == 0) {
		switch (*b) {
		case '\t':	/* embedded blank when reading stdin */
		case ' ':
		    *c = LYSkipBlanks(b);
		    result = 1;
		    break;
		case '=':
		case ':':
		    *c = b + 1;
		    result = 1;
		    break;
		case '-':
#if OPTNAME_ALLOW_DASHES
		    if (isalpha(UCH(b[1]))) {
			result = 0;
			break;
		    }
#endif
		    /* FALLTHRU */
		case '+':
		    *c = b;
		    result = 1;
		    break;
		case 0:
		    result = 1;
		    break;
		default:
		    result = 0;
		    break;
		}
	    } else {
#if OPTNAME_ALLOW_DASHES
		if (!(*a == '_' && *b == '-'))
#endif
		    result = 0;
	    }
	}
	a++;
	b++;
    }
    return result;
}

#define is_true(s)  (*s == '1' || *s == '+' || !strcasecomp(s, "on")  || !strcasecomp(s, "true"))
#define is_false(s) (*s == '0' || *s == '-' || !strcasecomp(s, "off") || !strcasecomp(s, "false"))

/*
 * Parse an option.
 *	argv[] points to the beginning of the unprocessed options.
 *	mask is used to select certain options which must be processed
 *		before others.
 *	countp (if nonnull) points to an index into argv[], which is updated
 *		to reflect option values which are also parsed.
 */
static BOOL parse_arg(char **argv,
		      unsigned mask,
		      int *countp)
{
    Config_Type *p;
    char *arg_name;

#if EXTENDED_STARTFILE_RECALL
    static BOOLEAN no_options_further = FALSE;	/* set to TRUE after '--' argument */
    static int nof_index = 0;	/* set the index of -- argument */
#endif

    arg_name = argv[0];
    CTRACE((tfp, "parse_arg(arg_name=%s, mask=%u, count=%d)\n",
	    arg_name, mask, countp ? *countp : -1));

#if EXTENDED_STARTFILE_RECALL
    if (mask == (unsigned) ((countp != 0) ? 0 : 1)) {
	no_options_further = FALSE;
	/* want to reset nonoption when beginning scan for --stdin */
	if (nonoption != 0) {
	    FREE(nonoption);
	}
    }
#endif

    /*
     * Check for a command line startfile.  - FM
     */
    if (*arg_name != '-'
#if EXTENDED_OPTION_LOGIC
	|| ((no_options_further == TRUE)
	    && (countp != 0)
	    && (nof_index < (*countp)))
#endif
	) {
#if EXTENDED_STARTFILE_RECALL
	/*
	 * On the last pass (mask==4), check for cases where we may want to
	 * provide G)oto history for multiple startfiles.
	 */
	if (mask == 4) {
	    if (nonoption != 0) {
		LYEnsureAbsoluteURL(&nonoption, "NONOPTION", FALSE);
		HTAddGotoURL(nonoption);
		FREE(nonoption);
	    }
	    StrAllocCopy(nonoption, arg_name);
	}
#endif
	StrAllocCopy(startfile, arg_name);
	LYEscapeStartfile(&startfile);
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 20:11:17 */
	HTUnEscape(startfile);
	{
	    char *q = startfile;

	    while (*q++) {
		if (*q == '|')
		    *q = ':';
	    }
	}
#endif
	CTRACE((tfp, "parse_arg startfile:%s\n", startfile));
	return (BOOL) (countp != 0);
    }
#if EXTENDED_OPTION_LOGIC
    if (strcmp(arg_name, "--") == 0) {
	no_options_further = TRUE;
	nof_index = countp ? *countp : -1;
	return TRUE;
    }
#endif

    /* lose the first '-' character */
    arg_name++;

    /*
     * Skip any lone "-" arguments, because we've loaded the stdin input into
     * an HTList structure for special handling.  - FM
     */
    if (*arg_name == 0)
	return TRUE;

    /* allow GNU-style options with -- prefix */
    if (*arg_name == '-')
	++arg_name;

    CTRACE((tfp, "parse_arg lookup(%s)\n", arg_name));

    p = Arg_Table;
    while (p->name != 0) {
	ParseUnionPtr q = ParseUnionOf(p);
	ParseFunc fun;
	char *next_arg = NULL;
	char *temp_ptr = NULL;

	if ((p->name[0] != *arg_name)
	    || (0 == arg_eqs_parse(p->name, arg_name, &next_arg))) {
	    p++;
	    continue;
	}

	if (p->type & NEED_NEXT_ARG) {
	    if (next_arg == 0) {
		next_arg = argv[1];
		if ((countp != 0) && (next_arg != 0))
		    (*countp)++;
	    }
	    CTRACE((tfp, "...arg:%s\n", NONNULL(next_arg)));
	}

	/* ignore option if it's not our turn */
	if (((unsigned) (p->type) & mask) == 0) {
	    CTRACE((tfp, "...skip (mask %u/%d)\n", mask, p->type & 7));
	    return FALSE;
	}

	switch (p->type & ARG_TYPE_MASK) {
	case TOGGLE_ARG:	/* FALLTHRU */
	case SET_ARG:		/* FALLTHRU */
	case UNSET_ARG:
	    if (q->set_value != 0) {
		if (next_arg == 0) {
		    switch (p->type & ARG_TYPE_MASK) {
		    case TOGGLE_ARG:
			*(q->set_value) = (BOOL) !(*(q->set_value));
			break;
		    case SET_ARG:
			*(q->set_value) = TRUE;
			break;
		    case UNSET_ARG:
			*(q->set_value) = FALSE;
			break;
		    }
		} else if (is_true(next_arg)) {
		    *(q->set_value) = TRUE;
		} else if (is_false(next_arg)) {
		    *(q->set_value) = FALSE;
		}
		/* deliberately ignore anything else - BL */
	    }
	    break;

	case FUNCTION_ARG:
	    fun = q->fun_value;
	    if (0 != fun) {
		if (-1 == (*fun) (next_arg)) {
		}
	    }
	    break;

	case LYSTRING_ARG:
	    if ((q->str_value != 0) && (next_arg != 0))
		StrAllocCopy(*(q->str_value), next_arg);
	    break;

	case INT_ARG:
	    if ((q->int_value != 0) && (next_arg != 0))
		*(q->int_value) = (int) strtol(next_arg, &temp_ptr, 0);
	    break;

	case TIME_ARG:
	    if ((q->int_value != 0) && (next_arg != 0)) {
		float ival;

		if (1 == LYscanFloat(next_arg, &ival)) {
		    *(q->int_value) = (int) SECS2Secs(ival);
		}
	    }
	    break;

	case STRING_ARG:
	    if ((q->str_value != 0) && (next_arg != 0))
		*(q->str_value) = next_arg;
	    break;
	}

	Old_DTD = DTD_recovery;	/* BOOL != int */
	return TRUE;
    }

    if (pgm == 0)
	pgm = "LYNX";

    fprintf(stderr, gettext("%s: Invalid Option: %s\n"), pgm, argv[0]);
    print_help_and_exit(-1);
    return FALSE;
}

#ifndef VMS
static void FatalProblem(int sig)
{
    /*
     * Ignore further interrupts.  - mhc:  11/2/91
     */
#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_IGN);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_IGN);
    (void) signal(SIGINT, SIG_IGN);
#ifndef __linux__
#ifdef SIGBUS
    (void) signal(SIGBUS, SIG_IGN);
#endif /* ! SIGBUS */
#endif /* !__linux__ */
    (void) signal(SIGSEGV, SIG_IGN);
    (void) signal(SIGILL, SIG_IGN);

    /*
     * Flush all messages.  - FM
     */
    fflush(stderr);
    fflush(stdout);

    /*
     * Deal with curses, if on, and clean up.  - FM
     */
    if (LYOutOfMemory && LYCursesON) {
	LYSleepAlert();
    }
    cleanup_sig(0);
#ifndef __linux__
#ifdef SIGBUS
    signal(SIGBUS, SIG_DFL);
#endif /* SIGBUS */
#endif /* !__linux__ */
    signal(SIGSEGV, SIG_DFL);
    signal(SIGILL, SIG_DFL);

    /*
     * Issue appropriate messages and abort or exit.  - FM
     */
    if (LYOutOfMemory == FALSE) {
	fprintf(stderr, "\r\n\
A Fatal error has occurred in %s Ver. %s\r\n", LYNX_NAME, LYNX_VERSION);

	fprintf(stderr, "\r\n\
Please notify your system administrator to confirm a bug, and\r\n\
if confirmed, to notify the lynx-dev list.  Bug reports should\r\n\
have concise descriptions of the command and/or URL which causes\r\n\
the problem, the operating system name with version number, the\r\n\
TCPIP implementation, and any other relevant information.\r\n");

	if (!(sig == 0 && LYNoCore)) {
	    fprintf(stderr, "\r\n\
Do NOT mail the core file if one was generated.\r\n");
	}
	if (sig != 0) {
	    fprintf(stderr, "\r\n\
Lynx now exiting with signal:  %d\r\n\r\n", sig);
#ifdef WIN_EX			/* 1998/08/09 (Sun) 09:58:25 */
	    {
		char *msg;

		switch (sig) {
		case SIGABRT:
		    msg = "SIGABRT";
		    break;
		case SIGFPE:
		    msg = "SIGFPE";
		    break;
		case SIGILL:
		    msg = "SIGILL";
		    break;
		case SIGSEGV:
		    msg = "SIGSEGV";
		    break;
		default:
		    msg = "Not-def";
		    break;
		}
		fprintf(stderr, "signal code = %s\n", msg);
	    }
#endif
	}

	/*
	 * Exit and possibly dump core.
	 */
	if (LYNoCore) {
	    exit_immediately(EXIT_FAILURE);
	}
	abort();

    } else {
	LYOutOfMemory = FALSE;
	printf("\r\n%s\r\n\r\n", MEMORY_EXHAUSTED_ABORT);
	fflush(stdout);

	/*
	 * Exit without dumping core.
	 */
	exit_immediately(EXIT_FAILURE);
    }
}
#endif /* !VMS */
@


1.16
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.15
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYMain.c,v 1.204 2009/06/30 08:35:34 tom Exp $
d19 1
d61 1
a61 1
#if defined(LOCALE) && !defined(HAVE_LIBINTL_H)
d103 1
a103 1
BOOLEAN syslog_requested_urls = TRUE;
d154 7
d212 1
a212 1
BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
d215 1
d223 1
d232 1
d362 9
d470 2
a471 1
char *personal_mail_address = NULL;	/* the users mail address */
d503 1
a503 1
int DebugSecs;			/* time-delay for HTProgress messages */
d518 1
d583 2
d589 1
a589 1
#ifdef EXP_JUSTIFY_ELTS
d597 1
d641 4
d681 1
a681 1
			       BOOLEAN option);
d690 1
a690 1
char *lynx_lss_file2 = NULL;	/* from command-line options */
d692 9
d831 1
d840 1
d850 1
a850 1
    HTInitProgramPaths();
d908 1
a908 1
		     BOOL marker)
d911 1
a911 1
	&& (!marker || strncmp(*buf, "---", 3) != 0)) {
d949 1
a949 2
#else
#if defined(OPENSSL_VERSION_TEXT)
d951 2
a952 5
#else
#if defined(GNUTLS_VERSION)
#define LYNX_SSL_VERSION GNUTLS_VERSION
#endif /* GNUTLS_VERSION */
#endif /* OPENSSL_VERSION_TEXT */
d958 2
a959 2
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion) - 1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
d961 1
a961 1
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
d971 21
d1000 1
a1000 11
    /* Set the text message domain.  */
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
    {
	char *cp;

	if ((cp = LYGetEnv("LYNX_LOCALEDIR")) == 0)
	    cp = LOCALEDIR;
	bindtextdomain("lynx", cp);
	textdomain("lynx");
    }
#endif /* HAVE_LIBINTL_H */
d1012 1
d1031 14
d1054 3
a1056 1
#ifdef EXP_CHARSET_CHOICE
d1103 2
a1104 2
    if (((cp = LYGetEnv("SHELL")) != NULL)
	&& (strstr(LYPathLeaf(cp), "sh") != NULL))
d1128 9
d1156 2
a1157 2
    if ((cp = LYGetEnv("LYNX_TRACE_FILE")) == 0)
	cp = FNAME_LYNX_TRACE;
d1160 1
a1160 1
    LYAddPathToHome(LYTraceLogPath, LY_MAXPATH, cp);
a1169 12
#ifdef LY_FIND_LEAKS
    /*
     * Register the final function to be executed when being exited.  Will
     * display memory leaks if the -find-leaks option is used.
     */
    atexit(LYLeaks);
    /*
     * Register the function which will free our allocated globals.
     */
    atexit(free_lynx_globals);
#endif /* LY_FIND_LEAKS */

d1196 1
a1197 1
    StrAllocCopy(ftp_format, FTP_FORMAT);
d1200 1
a1200 1
    DebugSecs = SECS2Secs(DEBUGSECS);
a1216 1
#ifdef SYSTEM_MAIL_FLAGS
a1217 3
#else
    StrAllocCopy(system_mail_flags, "");
#endif
d1242 2
a1243 2
    if ((cp = LYGetEnv("LYNX_TEMP_SPACE")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
d1245 2
a1246 2
    else if ((cp = LYGetEnv("TMPDIR")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
d1249 9
a1257 7
    else if ((cp = LYGetEnv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
    else if ((cp = LYGetEnv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, cp);
#endif
    else
#ifdef TEMP_SPACE
a1259 1
    {
d1262 1
a1263 1
#endif
d1286 1
a1286 1
    if (strchr(lynx_temp_space, '/') != NULL) {
d1296 2
a1297 2
    if (strchr(lynx_temp_space, ':') == NULL &&
	strchr(lynx_temp_space, ']') == NULL) {
d1439 1
a1439 1
#ifdef EXP_CMD_LOGGING
d1481 9
a1541 7
    /*
     * Make sure we have the edit map declared.  - FM
     */
    if (!LYEditmapDeclared()) {
	fprintf(stderr, gettext("\nLynx edit map not declared.\n\n"));
	exit_immediately(EXIT_FAILURE);
    }
d1562 1
a1562 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename) - 1);
d1583 2
a1584 37
    /*
     * A command-line "-lss" always overrides the config-file, even if it is
     * an empty string such as -lss="".
     */
    if (lynx_lss_file2 != 0) {
	FREE(lynx_lss_file);
	lynx_lss_file = lynx_lss_file2;
	lynx_lss_file2 = 0;
    }

    /*
     * If no alternate lynx-style file was specified on the command line, see
     * if it's in the environment.
     */
    if (!lynx_lss_file) {
	if (((cp = LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp = LYGetEnv("lynx_lss")) != NULL)
	    StrAllocCopy(lynx_lss_file, cp);
    }

    /*
     * If we still don't have a lynx-style file, use the userdefs.h definition.
     */
    if (!lynx_lss_file)
	StrAllocCopy(lynx_lss_file, LYNX_LSS_FILE);

    LYTildeExpand(&lynx_lss_file, TRUE);

    /*
     * If the lynx-style file is not available, inform the user and exit.
     */
    if (!isEmpty(lynx_lss_file) && !LYCanReadFile(lynx_lss_file)) {
	fprintf(stderr, gettext("\nLynx file \"%s\" is not available.\n\n"),
		lynx_lss_file);
	exit_immediately(EXIT_FAILURE);
    } else {
	style_readFromFile(lynx_lss_file);
a1647 1
	int ch;
d1649 1
a1649 1
	while ((ch = fgetc(stdin)) != EOF) {
d1716 1
a1716 1
	    LYAddPathToHome(LYCookieFile, LY_MAXPATH, FNAME_LYNX_COOKIES);
d1727 10
d1784 1
a1784 1
	if (strchr(lynx_save_space, '/') != NULL) {
d1794 2
a1795 2
	if (strchr(lynx_save_space, ':') == NULL &&
	    strchr(lynx_save_space, ']') == NULL) {
d2013 1
a2013 1
    if (traversal && strncmp(startfile, "http", 4)) {
d2104 1
a2104 1
    if (!bookmark_page || *bookmark_page == '\0') {
d2110 1
a2110 1
    if (!BookmarkPage || *BookmarkPage == '\0') {
d2157 1
d2166 1
d2226 1
d2238 1
d2252 1
d2324 1
a2324 1
	LYRemoveTemp(tempfile);
d2340 1
a2340 1
#ifdef EXP_CHARSET_CHOICE
d2365 1
a2365 1
	LYRemoveTemp(tempfile);
d2368 1
a2368 1
#ifdef EXP_CHARSET_CHOICE
d2475 1
a2475 1
	if ((cp = strchr(auth_info, ':')) != 0) {	/* Pw */
d2501 1
d2505 4
a2508 4
/*	   this may be a memory for bogus typo -
    StrAllocCopy(UCAssume_MIMEcharset, next_arg);
    LYLowerCase(UCAssume_MIMEcharset);   */

d2605 1
a2605 1
	if ((cp1 = strchr(outformat, ';')) != NULL) {
d2756 1
a2756 1
static int hiddenlinks_fun(char *next_arg)
d2852 1
a2852 1
    Lynx_Color_Flags &= ~SL_LYNX_USE_COLOR;
d3108 1
a3108 1
	for (j = 0;; j++) {
d3124 1
a3124 1
		column += 5 + strlen(name) + strlen(value);
d3284 1
a3284 1
	if ((cp = strchr(next_arg, ',')) != 0) {
d3312 6
d3368 1
a3368 1
      "case",		4|SET_ARG,		case_sensitive,
d3387 1
a3387 1
#ifdef EXP_CMD_LOGGING
d3450 6
d3457 1
a3457 1
      "delay",		4|NEED_TIME_ARG,	DebugSecs,
d3474 1
a3474 1
      "dump",		4|FUNCTION_ARG,		dump_output_fun,
d3568 4
d3583 1
a3583 1
#ifdef EXP_JUSTIFY_ELTS
d3594 4
d3644 1
a3644 1
      "select mail tool (`BLAT' ==> `sendmail')"
d3974 4
d4034 1
a4034 1
			       BOOLEAN option)
d4057 1
a4057 1
    if (strchr(help, '\n') == 0) {
d4241 3
a4243 1
	|| (no_options_further == TRUE && nof_index < (*countp))
d4279 1
a4279 1
	nof_index = *countp;
d4323 1
a4323 1
	if ((p->type & mask) == 0) {
d4369 1
a4369 1
		*(q->int_value) = strtol(next_arg, &temp_ptr, 0);
@


1.14
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d32 5
d60 1
a60 1
#ifdef LOCALE
a70 8
#ifdef FNAMES_8_3
#define COOKIE_FILE "cookies"
#define TRACE_FILE "LY-TRACE.LOG"
#else
#define COOKIE_FILE ".lynx_cookies"
#define TRACE_FILE "Lynx.trace"
#endif /* FNAMES_8_3 */

d98 2
d105 2
d200 1
a211 3
BOOLEAN ftp_passive = FTP_PASSIVE;	/* TRUE if doing ftp in passive mode */
BOOLEAN ftp_local_passive;
char *ftp_lasthost;
d286 8
a344 1
#ifdef SH_EX
a345 1
#endif
d377 1
d394 1
d455 13
d480 1
d492 1
d534 2
d537 1
a537 1
static BOOL DTD_recovery = NO;
d563 1
d566 1
a566 1
BOOL ok_justify = FALSE;
d570 1
a570 1
#ifdef EXP_LOCALE_CHARSET
d583 1
a583 1
BOOL force_empty_hrefless_a = FALSE;
d587 1
a587 1
BOOL textfields_activation_option = FALSE;
d624 1
d710 1
d786 1
d788 3
d814 1
a846 3
#ifdef NCURSES_NO_LEAKS
    _nc_freeall();
#endif
a850 23
/* *INDENT-OFF* */
      char un_IBM1047[ 256 ] = "";
unsigned char IBM1047[ 256 ] = /* ATOE OEMVS311 */
{
0x00,0x01,0x02,0x03,0x37,0x2d,0x2e,0x2f,0x16,0x05,0x15,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x3c,0x3d,0x32,0x26,0x18,0x19,0x3f,0x27,0x1c,0x1d,0x1e,0x1f,
0x40,0x5a,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xad,0xe0,0xbd,0x5f,0x6d,
0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x4f,0xd0,0xa1,0x07,
0x20,0x21,0x22,0x23,0x24,0x25,0x06,0x17,0x28,0x29,0x2a,0x2b,0x2c,0x09,0x0a,0x1b,
0x30,0x31,0x1a,0x33,0x34,0x35,0x36,0x08,0x38,0x39,0x3a,0x3b,0x04,0x14,0x3e,0xff,
0x41,0xaa,0x4a,0xb1,0x9f,0xb2,0x6a,0xb5,0xbb,0xb4,0x9a,0x8a,0xb0,0xca,0xaf,0xbc,
0x90,0x8f,0xea,0xfa,0xbe,0xa0,0xb6,0xb3,0x9d,0xda,0x9b,0x8b,0xb7,0xb8,0xb9,0xab,
0x64,0x65,0x62,0x66,0x63,0x67,0x9e,0x68,0x74,0x71,0x72,0x73,0x78,0x75,0x76,0x77,
0xac,0x69,0xed,0xee,0xeb,0xef,0xec,0xbf,0x80,0xfd,0xfe,0xfb,0xfc,0xba,0xae,0x59,
0x44,0x45,0x42,0x46,0x43,0x47,0x9c,0x48,0x54,0x51,0x52,0x53,0x58,0x55,0x56,0x57,
0x8c,0x49,0xcd,0xce,0xcb,0xcf,0xcc,0xe1,0x70,0xdd,0xde,0xdb,0xdc,0x8d,0x8e,0xdf
} ;
/* *INDENT-ON* */

a856 1
	un_IBM1047[IBM1047[c]] = c;
a866 31
static void tildeExpand(char **pathname,
			BOOLEAN embedded)
{
    char *temp = *pathname;

    if (embedded) {
	if (temp != NULL) {
	    temp = strstr(*pathname, "/~");
	    if (temp != 0)
		temp++;
	    else
		temp = *pathname;
	}
    }

    if (temp != NULL
	&& temp[0] == '~') {
	if (temp[1] == '/'
	    && temp[2] != '\0') {
	    temp = NULL;
	    StrAllocCopy(temp, *pathname + 2);
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	    LYAddPathSep(pathname);
	    StrAllocCat(*pathname, temp);
	    FREE(temp);
	} else if (temp[1] == '\0') {
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
	}
    }
}

d935 21
a1016 7
#if 0				/* defined(__CYGWIN__) - does not work with screen */
    if (strcmp(ttyname(fileno(stdout)), "/dev/conout") != 0) {
	printf("please \"$CYGWIN=notty\"\n");
	exit_immediately(EXIT_SUCCESS);
    }
#endif

d1069 22
a1090 1
     * Act on -help NOW, so we only output the help and exit.  - FM
d1095 1
d1100 1
a1100 1
     * display memory leaks if LY_FIND_LEAKS is defined.
d1109 1
a1109 13
#ifdef LOCALE
    /*
     * LOCALE support for international characters.
     */
    setlocale(LC_ALL, "");
#endif /* LOCALE */
    /* Set the text message domain.  */
#if defined(HAVE_LIBINTL_H) || defined(HAVE_LIBGETTEXT_H)
    if ((cp = LYGetEnv("LYNX_LOCALEDIR")) == 0)
	cp = LOCALEDIR;
    bindtextdomain("lynx", cp);
    textdomain("lynx");
#endif /* HAVE_LIBINTL_H */
d1136 1
d1210 1
a1210 1
	tildeExpand(&lynx_temp_space, TRUE);
a1225 6
    StrAllocCat(lynx_temp_space, "/lynx-XXXXXXXXXX");
    lynx_temp_space = mkdtemp(lynx_temp_space);
    if (lynx_temp_space == NULL) {
	fprintf(stderr, "temporary directory: %s\n", LYStrerror(errno));
	exit(EXIT_FAILURE);
    }
d1275 1
a1290 11
    /*
     * Set up trace, the anonymous account defaults, validate restrictions,
     * and/or the nosocks flag, if requested, and an alternate configuration
     * file, if specified, NOW.  Also, if we only want the help menu, output
     * that and exit.  - FM
     */
#ifndef NO_LYNX_TRACE
    if (LYGetEnv("LYNX_TRACE") != 0) {
	WWW_TraceFlag = TRUE;
    }
#endif
d1302 1
a1302 1
     * precluded its use when the lynx command is aliased with other arguments. 
a1380 12

    /*
     * Set up the TRACE log path, and logging if appropriate.  - FM
     */
    if ((cp = LYGetEnv("LYNX_TRACE_FILE")) == 0)
	cp = TRACE_FILE;
    LYTraceLogPath = typeMallocn(char, LY_MAXPATH);

    LYAddPathToHome(LYTraceLogPath, LY_MAXPATH, cp);

    LYOpenTraceLog();

d1386 1
a1386 1
	tildeExpand(&lynx_cmd_script, TRUE);
d1393 1
a1393 1
	tildeExpand(&lynx_cmd_logfile, TRUE);
d1432 1
a1432 1
    tildeExpand(&lynx_cfg_file, FALSE);
d1549 1
a1549 1
    tildeExpand(&lynx_lss_file, TRUE);
d1568 1
a1568 1
#ifdef EXP_LOCALE_CHARSET
d1610 27
d1692 1
a1692 1
	    LYAddPathToHome(LYCookieFile, LY_MAXPATH, COOKIE_FILE);
d1694 1
a1694 1
	    tildeExpand(&LYCookieFile, FALSE);
d1701 1
a1701 1
	tildeExpand(&LYCookieSaveFile, FALSE);
d1719 7
d1747 1
a1747 1
	tildeExpand(&lynx_save_space, TRUE);
a1781 1
#ifdef SH_EX
a1785 2
#endif

d1844 1
a1844 1
	LYSelectPopups = !LYSelectPopups;
d1851 1
a1851 1
	LYShowCursor = !LYShowCursor;
d1927 1
a1927 1
#ifndef DOSPATH
d1929 1
a1929 1
#endif /* DOSPATH */
d1941 1
a1941 1
#ifndef DOSPATH
d1944 1
a1944 1
#endif /* DOSPATH */
d2057 8
d2123 1
a2123 2
		!crawl &&	/* For -crawl it has already been done! */
		links_are_numbered())
d2137 1
a2137 1
	 * We want to save cookies picked up when in immediate dump mode. 
d2164 3
d2185 1
a2185 1
 * Called by HTAccessInit to register any protocols supported by lynx. 
d2187 1
a2187 1
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE, LYNXMESSAGES
d2194 4
d2205 4
d2218 3
a2332 14
	/* We are not interested in startfile here */
	/* but other things may be lost: */

	/*
	 * Process any command line arguments not already handled.
	 */
	/* Not implemented yet here */

	/*
	 * Process any stdin-derived arguments for a lone "-" which we've
	 * loaded into LYStdinArgs.
	 */
	/* Not implemented yet here */

d2336 1
a2336 5
	if (user_mode == NOVICE_MODE) {
	    display_lines = LYlines - 4;
	} else {
	    display_lines = LYlines - 2;
	}
a2366 9
static void disable_pausing(void)
{
    AlertSecs = 0;
    DebugSecs = 0;
    InfoSecs = 0;
    MessageSecs = 0;
    ReplaySecs = 0;
}

d2370 1
a2370 1
    disable_pausing();
d2529 8
d2682 1
a2682 1
     * On Unix, conflicts with curses when interactive so let's force a dump. 
d2821 8
a2828 1
    disable_pausing();
d3142 1
d3148 2
a3150 1
    StrAllocCat(result, "\n");
d3153 2
d3182 3
d3196 2
d3202 1
d3205 3
a3207 2
    puts(gettext("Copyrights held by the University of Kansas, CERN, and other contributors."));
    puts(gettext("Distributed under the GNU General Public License."));
d3281 1
a3281 1
      "assume_local_charset",	4|NEED_FUNCTION_ARG,assume_local_charset_fun,
d3285 1
a3285 1
      "assume_unrec_charset",	4|NEED_FUNCTION_ARG,assume_unrec_charset_fun,
d3294 2
a3295 1
      "prepend a request URL comment and BASE tag to text/html\noutputs for -source dumps"
d3337 4
d3343 2
a3344 2
       "cmd_log",	2|NEED_LYSTRING_ARG,	lynx_cmd_logfile,
       "=FILENAME\nlog keystroke commands to the given file"
d3347 2
a3348 2
       "cmd_script",	2|NEED_LYSTRING_ARG,	lynx_cmd_script,
       "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
d3373 1
a3373 1
      "cookie_save_file",	4|LYSTRING_ARG,	LYCookieSaveFile,
d3464 2
a3465 1
      "\nforce HREF-less 'A' elements to be empty (close them as\nsoon as they are seen)"
d3485 1
d3490 1
d3500 1
a3500 1
      "help",		1|FUNCTION_ARG,		help_fun,
d3623 5
a3627 1
      "disable the right/left margins in the default style-sheet"
d3702 6
d3714 2
a3715 1
      "toggles handling of single-choice SELECT options via\npopup windows or as lists of radio buttons"
d3719 2
a3720 1
      "user data for post forms, read from stdin,\nterminated by '---' on a line"
d3750 4
d3792 15
a3810 1
#ifdef SH_EX
a3814 1
#endif
d3827 2
a3828 2
      "toggles emulation of the old Netscape and Mosaic bug which\n\
treated '>' as a co-terminator for double-quotes and tags"
d3844 1
a3844 1
      "write warning messages to standard error when -dump -or -source is used"
d3880 1
a3880 1
      "toggles use of a Lynx Trace Log for the current session"
d3890 1
a3890 1
      "trace",		2|SET_ARG,		WWW_TraceFlag,
d3894 1
a3894 1
      "trace_mask",	2|INT_ARG,		WWW_TraceMask,
d3904 1
a3904 1
      "trim input text/textarea fields in forms"
d3926 3
a3928 1
      "accept only http URLs (meant for validation)\nimplies more restrictions than -anonymous, but\ngoto is allowed for http and https"
d3932 2
a3933 1
      "toggles [LINK], [IMAGE] and [INLINE] comments \nwith filenames of these images"
d3959 4
d4155 1
d4163 1
a4163 1
    if (mask == ((countp != 0) ? 0 : 1)) {
d4177 1
a4177 1
	|| no_options_further == TRUE
d4213 1
d4310 1
a4310 1
		if (1 == sscanf(next_arg, "%f", &ival)) {
d4346 1
a4346 1
#ifndef DOSPATH
d4348 1
a4348 1
#endif /* ! DOSPATH */
d4367 1
a4367 1
#ifndef DOSPATH
d4369 1
a4369 1
#endif /* DOSPATH */
d4437 1
a4437 1
	exit_immediately(EXIT_SUCCESS);
@


1.13
log
@Add check for mkdtemp(3) failure.  Prevents segfaults when TMPDIR
or TMP are set to nonexistent directories.

Fixes PR 5247, reported by Marcus Popp <mpopp at paranoidbsd dot
org>

OK millert@@, jaredy@@, and improvement by moritz@@.
@
text
@d26 1
d34 1
d53 1
a53 1
#undef gettext		/* Solaris locale.h prototypes gettext() */
d73 1
a73 1
PUBLIC BOOLEAN socks_flag=TRUE;
d77 1
a77 1
PUBLIC BOOLEAN sigint = FALSE;
d81 1
a81 1
PRIVATE char init_ctrl_break[1];
d85 1
a85 1
PUBLIC char *mail_adrs = NULL;	/* the mask for a VMS mail transport */
d90 1
a90 1
PUBLIC BOOLEAN UseFixedRecords = USE_FIXED_RECORDS;
d94 4
a97 2
PRIVATE char *lynx_version_putenv_command = NULL;
PUBLIC char *list_format = NULL;	/* LONG_LIST formatting mask */
d99 3
a101 3
PUBLIC char *syslog_txt = NULL;		/* syslog arb text for session */
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d104 6
a109 6
PUBLIC BOOLEAN lynx_edit_mode = FALSE;
PUBLIC BOOLEAN no_dired_support = FALSE;
PUBLIC HTList *tagged = NULL;
PUBLIC int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
PUBLIC int dir_list_order = ORDER_BY_NAME;
PUBLIC int dir_list_style = MIXED_STYLE;
d112 1
a112 1
PUBLIC BOOLEAN prev_lynx_edit_mode = FALSE;
d117 2
a118 1
PUBLIC BOOLEAN no_change_exec_perms = TRUE;
d120 1
a120 1
PUBLIC BOOLEAN no_change_exec_perms = FALSE;
d127 2
a128 1
PUBLIC int HTCacheSize = DEFAULT_CACHE_SIZE;
d131 1
a131 1
PUBLIC int HTVirtualMemorySize = DEFAULT_VIRTUAL_MEMORY_SIZE;
d136 2
a137 1
PUBLIC BOOLEAN local_exec = LOCAL_EXECUTION_LINKS_ALWAYS_ON;
d139 1
a139 1
PUBLIC BOOLEAN local_exec = FALSE;
d141 2
a142 2
PUBLIC BOOLEAN local_exec_on_local_files =
	       LOCAL_EXECUTION_LINKS_ON_BUT_NOT_REMOTE;
d145 2
a146 2
#if defined(LYNXCGI_LINKS) && !defined(VMS)  /* WebSter Mods -jkt */
PUBLIC char *LYCgiDocumentRoot = NULL; /* DOCUMENT_ROOT in the lynxcgi env */
d150 2
a151 1
PUBLIC BOOLEAN enable_scrollback=TRUE;
d153 1
a153 1
PUBLIC BOOLEAN enable_scrollback=FALSE;
d156 6
a161 3
PUBLIC char *empty_string = "\0";
PUBLIC int display_lines;  /* number of lines in display */
PUBLIC int www_search_result= -1;
d163 2
a164 1
PUBLIC lynx_list_item_type *printers = NULL;
d166 2
a167 1
PUBLIC lynx_list_item_type *downloaders = NULL;
d170 2
a171 1
PUBLIC lynx_list_item_type *externals = NULL;
d175 3
a177 4
PUBLIC lynx_list_item_type *uploaders = NULL;
PUBLIC int port_syntax = 1;
PUBLIC int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not */
PUBLIC int LYrcShowColor = SHOW_COLOR_UNKNOWN; /* ... last used */
d180 1
a180 1
PUBLIC BOOLEAN LYUseFormsOptions = TRUE; /* use forms-based options menu */
d183 44
a226 41
PUBLIC BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
PUBLIC BOOLEAN LYPermitURL = FALSE;
PUBLIC BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
PUBLIC BOOLEAN LYShowCursor = SHOW_CURSOR; /* to show or not to show */
PUBLIC BOOLEAN LYUnderlineLinks = UNDERLINE_LINKS; /* Show the links underlined vs bold */
PUBLIC BOOLEAN LYUseDefShoCur = TRUE;	/* Command line -show_cursor toggle */
PUBLIC BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
PUBLIC BOOLEAN LYValidate = FALSE;
PUBLIC BOOLEAN LYforce_no_cache = FALSE;
PUBLIC BOOLEAN LYinternal_flag = FALSE; /* override no-cache b/c internal link*/
PUBLIC BOOLEAN LYoverride_no_cache = FALSE;/*override no-cache b/c history etc*/
PUBLIC BOOLEAN LYresubmit_posts = ALWAYS_RESUBMIT_POSTS;
PUBLIC BOOLEAN LYtrimInputFields = FALSE;
PUBLIC BOOLEAN bold_H1 = FALSE;
PUBLIC BOOLEAN bold_headers = FALSE;
PUBLIC BOOLEAN bold_name_anchors = FALSE;
PUBLIC BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
PUBLIC BOOLEAN check_mail = CHECKMAIL;
PUBLIC BOOLEAN child_lynx = FALSE;
PUBLIC BOOLEAN dump_output_immediately = FALSE;
PUBLIC BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
PUBLIC BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
PUBLIC BOOLEAN ftp_passive = FTP_PASSIVE; /* TRUE if doing ftp in passive mode */
PUBLIC BOOLEAN ftp_local_passive;
PUBLIC char *ftp_lasthost;
PUBLIC BOOLEAN goto_buffer = GOTOBUFFER; /* TRUE if offering default goto URL */
PUBLIC BOOLEAN historical_comments = FALSE;
PUBLIC BOOLEAN is_www_index = FALSE;
PUBLIC BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
PUBLIC BOOLEAN lynx_mode = NORMAL_LYNX_MODE;
PUBLIC BOOLEAN minimal_comments = FALSE;
PUBLIC BOOLEAN nolist = FALSE;
PUBLIC BOOLEAN number_fields_on_left = TRUE;
PUBLIC BOOLEAN number_links_on_left = TRUE;
PUBLIC BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
PUBLIC BOOLEAN soft_dquotes = FALSE;
PUBLIC BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
PUBLIC BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
PUBLIC BOOLEAN vi_keys = VI_KEYS_ALWAYS_ON;
PUBLIC int keypad_mode = DEFAULT_KEYPAD_MODE;
PUBLIC int user_mode = NOVICE_MODE;
a227 1
PUBLIC BOOLEAN telnet_ok = TRUE;
d229 1
a229 1
PUBLIC BOOLEAN news_ok = TRUE;
d231 52
a282 52
PUBLIC BOOLEAN rlogin_ok = TRUE;
PUBLIC BOOLEAN long_url_ok = FALSE;
PUBLIC BOOLEAN ftp_ok = TRUE;
PUBLIC BOOLEAN system_editor = FALSE;

PUBLIC BOOLEAN had_restrictions_default = FALSE;
PUBLIC BOOLEAN had_restrictions_all = FALSE;

PUBLIC BOOLEAN exec_frozen = FALSE;
PUBLIC BOOLEAN no_bookmark = FALSE;
PUBLIC BOOLEAN no_bookmark_exec = FALSE;
PUBLIC BOOLEAN no_chdir = FALSE;
PUBLIC BOOLEAN no_disk_save = FALSE;
PUBLIC BOOLEAN no_dotfiles = NO_DOT_FILES;
PUBLIC BOOLEAN no_download = FALSE;
PUBLIC BOOLEAN no_editor = FALSE;
PUBLIC BOOLEAN no_exec = FALSE;
PUBLIC BOOLEAN no_file_url = FALSE;
PUBLIC BOOLEAN no_goto = FALSE;
PUBLIC BOOLEAN no_goto_configinfo = FALSE;
PUBLIC BOOLEAN no_goto_cso = FALSE;
PUBLIC BOOLEAN no_goto_file = FALSE;
PUBLIC BOOLEAN no_goto_finger = FALSE;
PUBLIC BOOLEAN no_goto_ftp = FALSE;
PUBLIC BOOLEAN no_goto_gopher = FALSE;
PUBLIC BOOLEAN no_goto_http = FALSE;
PUBLIC BOOLEAN no_goto_https = FALSE;
PUBLIC BOOLEAN no_goto_lynxcgi = FALSE;
PUBLIC BOOLEAN no_goto_lynxexec = FALSE;
PUBLIC BOOLEAN no_goto_lynxprog = FALSE;
PUBLIC BOOLEAN no_goto_mailto = FALSE;
PUBLIC BOOLEAN no_goto_rlogin = FALSE;
PUBLIC BOOLEAN no_goto_telnet = FALSE;
PUBLIC BOOLEAN no_goto_tn3270 = FALSE;
PUBLIC BOOLEAN no_goto_wais = FALSE;
PUBLIC BOOLEAN no_inside_ftp = FALSE;
PUBLIC BOOLEAN no_inside_rlogin = FALSE;
PUBLIC BOOLEAN no_inside_telnet = FALSE;
PUBLIC BOOLEAN no_jump = FALSE;
PUBLIC BOOLEAN no_lynxcfg_info = FALSE;
PUBLIC BOOLEAN no_lynxcgi = FALSE;
PUBLIC BOOLEAN no_mail = FALSE;
PUBLIC BOOLEAN no_multibook = FALSE;
PUBLIC BOOLEAN no_option_save = FALSE;
PUBLIC BOOLEAN no_outside_ftp = FALSE;
PUBLIC BOOLEAN no_outside_rlogin = FALSE;
PUBLIC BOOLEAN no_outside_telnet = FALSE;
PUBLIC BOOLEAN no_print = FALSE;
PUBLIC BOOLEAN no_shell = FALSE;
PUBLIC BOOLEAN no_suspend = FALSE;
PUBLIC BOOLEAN no_telnet_port = FALSE;
PUBLIC BOOLEAN no_useragent = FALSE;
d285 6
a290 6
PUBLIC BOOLEAN no_goto_news = FALSE;
PUBLIC BOOLEAN no_goto_nntp = FALSE;
PUBLIC BOOLEAN no_goto_snews = FALSE;
PUBLIC BOOLEAN no_inside_news = FALSE;
PUBLIC BOOLEAN no_newspost = FALSE;
PUBLIC BOOLEAN no_outside_news = FALSE;
d294 1
a294 1
PUBLIC BOOLEAN no_externals = FALSE;
d298 2
a299 1
PUBLIC BOOLEAN no_lynxcfg_xinfo = FALSE;
d301 1
a301 1
PUBLIC BOOLEAN no_compileopts_info = FALSE;
d305 8
a312 8
PUBLIC BOOLEAN no_statusline = FALSE;
PUBLIC BOOLEAN no_filereferer = TRUE;
PUBLIC char LYRefererWithQuery = 'D';	/* 'D' for drop */
PUBLIC BOOLEAN local_host_only = FALSE;
PUBLIC BOOLEAN override_no_download = FALSE;
PUBLIC BOOLEAN show_dotfiles = FALSE;	/* From rcfile if no_dotfiles is false */
PUBLIC BOOLEAN LYforce_HTML_mode = FALSE;
PUBLIC BOOLEAN LYfind_leaks = TRUE;
d315 2
a316 2
PUBLIC BOOLEAN watt_debug = FALSE;	/* WATT-32 debugging */
PUBLIC BOOLEAN dj_is_bash = FALSE;  /* Check for bash shell under DJGPP */
d320 2
a321 2
PUBLIC BOOLEAN focus_window = FALSE;	/* 1998/10/05 (Mon) 17:18:42 */
PUBLIC char windows_drive[4];		/* 1998/01/13 (Tue) 21:13:24 */
d325 4
a328 4
#define	TIMEOUT	180			/* 1998/03/30 (Mon) 14:50:44 */
PUBLIC int lynx_timeout = TIMEOUT;
PUBLIC CRITICAL_SECTION critSec_DNS;	/* 1998/09/03 (Thu) 22:01:56 */
PUBLIC CRITICAL_SECTION critSec_READ;	/* 1998/09/03 (Thu) 22:01:56 */
d332 1
a332 1
PUBLIC BOOLEAN system_is_NT = FALSE;
d336 1
a336 1
PUBLIC BOOLEAN show_cfg = FALSE;
d339 1
a339 1
PUBLIC BOOLEAN no_table_center = FALSE;	/* 1998/10/09 (Fri) 15:12:49 */
d342 1
a342 1
PUBLIC BOOLEAN mail_is_blat = TRUE;
d347 2
a348 1
PUBLIC BOOLEAN term_blink_is_boldbg = TRUE;
d350 2
a351 1
PUBLIC BOOLEAN term_blink_is_boldbg = FALSE;
d355 119
a473 105
PUBLIC BOOLEAN HEAD_request = FALSE;
PUBLIC BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
PUBLIC BOOLEAN LYCancelledFetch = FALSE;/* TRUE if cancelled binary fetch */
PUBLIC BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
PUBLIC BOOLEAN LYDefaultRawMode;
PUBLIC BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
PUBLIC BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
PUBLIC BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
PUBLIC BOOLEAN LYNewsPosting = NEWS_POSTING; /* News posting supported? */
PUBLIC BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
PUBLIC BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
PUBLIC BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
PUBLIC BOOLEAN LYRawMode;
PUBLIC BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
PUBLIC BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
PUBLIC BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
PUBLIC BOOLEAN LYUseDefaultRawMode = TRUE;
PUBLIC BOOLEAN LYUseMouse = FALSE;
PUBLIC BOOLEAN LYisConfiguredForX = FALSE;
PUBLIC BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
PUBLIC BOOLEAN UCSaveBookmarksInUnicode = FALSE;
PUBLIC BOOLEAN bookmark_start = FALSE;
PUBLIC BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
PUBLIC BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
PUBLIC BOOLEAN crawl = FALSE;		/* Do crawl? */
PUBLIC BOOLEAN keep_mime_headers = FALSE; /* Include mime headers with source dump */
PUBLIC BOOLEAN more = FALSE;		/* is there more text to display? */
PUBLIC BOOLEAN more_links = FALSE;	/* Links beyond a displayed page with no links? */
PUBLIC BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
PUBLIC BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
PUBLIC BOOLEAN scan_for_buried_news_references = TRUE;
PUBLIC BOOLEAN startfile_ok = FALSE;
PUBLIC BOOLEAN startfile_stdin = FALSE;
PUBLIC BOOLEAN traversal = FALSE;	/* Do traversals? */
PUBLIC char *BookmarkPage = NULL;	/* the name of the current bookmark page */
PUBLIC char *LYCookieAcceptDomains = NULL; /* domains to accept all cookies */
PUBLIC char *LYCookieLooseCheckDomains = NULL;  /* check loosely   */
PUBLIC char *LYCookieQueryCheckDomains = NULL;  /* check w/a query */
PUBLIC char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieSAcceptDomains = NULL; /* domains to accept all cookies */
PUBLIC char *LYCookieSLooseCheckDomains = NULL;  /* check loosely   */
PUBLIC char *LYCookieSQueryCheckDomains = NULL;  /* check w/a query */
PUBLIC char *LYCookieSRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieSStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
PUBLIC char *LYHostName = NULL;		/* treat as a local host name */
PUBLIC char *LYLocalDomain = NULL;	/* treat as a local domain tail */
PUBLIC char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
PUBLIC char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
PUBLIC char *LynxHome = NULL;		/* the default Home HREF. */
PUBLIC char *LynxSigFile = NULL;	/* Signature file, in or off home */
PUBLIC char *UCAssume_MIMEcharset = NULL;
PUBLIC char *URLDomainPrefixes = NULL;
PUBLIC char *URLDomainSuffixes = NULL;
PUBLIC char *authentication_info[2] = {NULL, NULL}; /* Id:Password for protected documents */
PUBLIC char *bookmark_page = NULL;	/* the name of the default bookmark page */
PUBLIC char *editor = NULL;		/* the name of the current editor */
PUBLIC char *form_get_data = NULL;	/* User data for get form */
PUBLIC char *form_post_data = NULL;	/* User data for post form */
PUBLIC char *global_extension_map = NULL;  /* global mime.types */
PUBLIC char *global_type_map = NULL;	/* global mailcap */
PUBLIC char *helpfile = NULL;		/* the main help file */
PUBLIC char *helpfilepath = NULL;	/* the path to the help file set */
PUBLIC char *homepage = NULL;		/* home page or main screen */
PUBLIC char *http_error_file = NULL;	/* Place HTTP status code in this file */
PUBLIC char *indexfile = NULL;		/* an index file if there is one */
PUBLIC char *jumpfile = NULL;		/* the name of the default jumps file */
PUBLIC char *jumpprompt = NULL;		/* the default jumps prompt */
PUBLIC char *language = NULL;		/* preferred language */
PUBLIC char *lynx_cfg_file = NULL;	/* location of active lynx.cfg */
PUBLIC char *lynx_cmd_logfile;		/* file to write keystroke commands, if any */
PUBLIC char *lynx_cmd_script;		/* file to read keystroke commands, if any */
PUBLIC char *lynx_save_space = NULL;	/* The prefix for save to disk paths */
PUBLIC char *lynx_temp_space = NULL;	/* The prefix for temporary file paths */
PUBLIC char *lynxjumpfile = NULL;	/* the current jump file URL */
PUBLIC char *lynxlinksfile = NULL;	/* the current visited links file URL */
PUBLIC char *lynxlistfile = NULL;	/* the current list file URL */
PUBLIC char *original_dir = NULL;	/* the original directory */
PUBLIC char *personal_extension_map = NULL;/* .mime.types */
PUBLIC char *personal_mail_address = NULL; /* the users mail address */
PUBLIC char *personal_type_map = NULL;	   /* .mailcap */
PUBLIC char *pref_charset = NULL;	/* preferred character set */
PUBLIC char *proxyauth_info[2] = {NULL, NULL}; /* Id:Password for protected proxy servers */
PUBLIC char *startfile = NULL;		/* the first file */
PUBLIC char *startrealm = NULL;		/* the startfile realm */
PUBLIC char *system_mail = NULL;	/* The path for sending mail */
PUBLIC char *system_mail_flags = NULL;	/* Flags for sending mail */
PUBLIC char *x_display = NULL;		/* display environment variable */
PUBLIC HistInfo history[MAXHIST];
PUBLIC int AlertSecs;			/* time-delay for HTAlert() messages   */
PUBLIC int DebugSecs;			/* time-delay for HTProgress messages */
PUBLIC int InfoSecs;			/* time-delay for Information messages */
PUBLIC int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
PUBLIC int LYStatusLine = -1;		/* Line for statusline() if > -1 */
PUBLIC int LYcols = DFT_COLS;
PUBLIC int LYlines = DFT_ROWS;
PUBLIC int MessageSecs;			/* time-delay for important Messages   */
PUBLIC int ReplaySecs;			/* time-delay for command-scripts */
PUBLIC int ccount = 0;			/* Starting number for lnk#.dat files in crawls */
PUBLIC int dump_output_width = 0;
PUBLIC int lynx_temp_subspace = 0;	/* > 0 if we made temp-directory */
PUBLIC int nhist = 0;			/* number of history entries */
PUBLIC int nlinks = 0;			/* number of links in memory */
PUBLIC int outgoing_mail_charset = -1;	/* translate mail to this charset */
PUBLIC LinkInfo links[MAXLINKS];
d476 5
a480 5
PUBLIC BOOLEAN BibP_bibhost_available = FALSE;  /* until check succeeds  */
PUBLIC BOOLEAN BibP_bibhost_checked = FALSE;  /*  until LYCheckBibHost   */
PUBLIC BOOLEAN no_goto_bibp = FALSE;
PUBLIC char *BibP_bibhost = NULL;	 /* local server for bibp: links  */
PUBLIC char *BibP_globalserver = NULL;   /* global server for bibp: links */
d484 3
a486 3
PUBLIC BOOLEAN persistent_cookies = FALSE; /* disabled by default! */
PUBLIC char *LYCookieFile = NULL;	/* cookie read file */
PUBLIC char *LYCookieSaveFile = NULL;	/* cookie save file */
d490 1
a490 1
PUBLIC BOOLEAN nested_tables =
d492 1
a492 1
    TRUE
d494 1
a494 1
    FALSE				/* see 2001-08-15  */
d496 1
a496 1
    ;
d499 5
a503 3
PUBLIC BOOLEAN LYShowTransferRate = TRUE;
PUBLIC int LYTransferRate = rateKB;
PUBLIC char * LYTransferName = NULL;
d505 3
a507 3
PUBLIC char *XLoadImageCommand = NULL;	/* Default image viewer for X */
PUBLIC BOOLEAN LYNoISMAPifUSEMAP = FALSE; /* Omit ISMAP link if MAP present? */
PUBLIC int LYHiddenLinks = HIDDENLINKS_SEPARATE; /* Show hidden links? */
d509 2
a510 2
PUBLIC int Old_DTD = NO;
PRIVATE BOOL DTD_recovery = NO;
d513 1
a513 1
PUBLIC FILE *LYTraceLogFP = NULL;		/* Pointer for TRACE log  */
d515 2
a516 2
PUBLIC char *LYTraceLogPath = NULL;		/* Path for TRACE log	   */
PUBLIC BOOLEAN LYUseTraceLog = USE_TRACE_LOG;	/* Use a TRACE log?	   */
d518 10
a527 10
PUBLIC BOOLEAN LYSeekFragMAPinCur = TRUE;
PUBLIC BOOLEAN LYSeekFragAREAinCur = TRUE;
PUBLIC BOOLEAN LYStripDotDotURLs = TRUE;	/* Try to fix ../ in some URLs? */
PUBLIC BOOLEAN LYForceSSLCookiesSecure = FALSE;
PUBLIC BOOLEAN LYNoCc = FALSE;
PUBLIC BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed? */
PUBLIC BOOLEAN LYPrependBaseToSource = TRUE;
PUBLIC BOOLEAN LYPrependCharsetToSource = TRUE;
PUBLIC BOOLEAN LYQuitDefaultYes = QUIT_DEFAULT_YES;
PUBLIC BOOLEAN dont_wrap_pre = FALSE;
d529 1
a529 1
PUBLIC int cookie_noprompt;
d532 1
a532 1
PUBLIC int ssl_noprompt = FORCE_PROMPT_DFT;
d535 1
a535 1
PUBLIC int connect_timeout = 18000; /*=180000*0.1 - used in HTDoConnect.*/
d538 2
a539 2
PUBLIC BOOL ok_justify = TRUE;
PUBLIC int justify_max_void_percent = 35;
d543 1
a543 1
PUBLIC BOOLEAN LYLocaleCharset = FALSE;
d547 1
a547 1
PUBLIC BOOLEAN with_backspaces = FALSE;
d551 2
a552 2
PUBLIC int scrsize_x = 0;
PUBLIC int scrsize_y = 0;
d555 1
a555 1
PUBLIC BOOL force_empty_hrefless_a = FALSE;
d558 2
a559 2
PUBLIC BOOL textfields_need_activation = FALSE;
PUBLIC BOOL textfields_activation_option = FALSE;
d562 1
a562 1
PUBLIC BOOLEAN textfield_prompt_at_left_edge = FALSE;
d565 1
a565 1
PUBLIC char* hidden_link_marker = NULL;
d569 3
a571 3
PUBLIC BOOLEAN display_partial_flag = TRUE; /* Display document during download */
PUBLIC BOOLEAN debug_display_partial = FALSE; /* Show with MessageSecs delay */
PUBLIC int partial_threshold = -1;  /* # of lines to be d/l'ed until we repaint */
d574 3
a576 3
PUBLIC BOOLEAN LYNonRestartingSIGWINCH = FALSE;
PUBLIC BOOLEAN LYReuseTempfiles = FALSE;
PUBLIC BOOLEAN LYUseBuiltinSuffixes = TRUE;
d579 1
a579 1
PUBLIC int LYNoZapKey = 0; /* 0: off (do z checking), 1: full, 2: initially */
d586 1
a586 1
PUBLIC BOOLEAN FileInitAlreadyDone = FALSE;
d588 8
a595 7
PRIVATE BOOLEAN stack_dump = FALSE;
PRIVATE char *terminal = NULL;
PRIVATE char *pgm;
PRIVATE BOOLEAN number_links = FALSE;
PRIVATE BOOLEAN number_fields = FALSE;
PRIVATE BOOLEAN LYPrependBase = FALSE;
PRIVATE HTList *LYStdinArgs = NULL;
d608 4
d618 6
a623 7
#if EXTENDED_OPTION_LOGIC
PRIVATE BOOLEAN no_options_further=FALSE; /* set to TRUE after '--' argument */
#endif

PRIVATE BOOL parse_arg PARAMS((char **arg, unsigned mask, int *i));
PRIVATE void print_help_and_exit PARAMS((int exit_status)) GCC_NORETURN;
PRIVATE void print_help_strings PARAMS((CONST char * name, CONST char * help, CONST char * value, BOOLEAN option));
d626 3
a628 3
PUBLIC BOOLEAN LYNoCore = NO_FORCED_CORE_DUMP;
PUBLIC BOOLEAN restore_sigpipe_for_children = FALSE;
PRIVATE void FatalProblem PARAMS((int sig));
d632 6
a637 1
PUBLIC char *lynx_lss_file = NULL;
d641 1
a641 1
PRIVATE void LY_set_ctrl_break(int setting)
d643 1
a643 1
    (void)signal(SIGINT, (setting ? SIG_DFL : SIG_IGN));
d647 1
a647 1
PRIVATE int LY_get_ctrl_break(void)
d650 1
d653 1
a653 1
    __dpmi_int (0x21, &regs);
d657 1
a657 1
PRIVATE void reset_break(void)
d664 1
a664 1
PRIVATE int is_windows_nt(void)
a675 1

d677 1
a677 1
PRIVATE void free_lynx_globals NOARGS
d683 1
a683 4
#ifdef SYSLOG_REQUESTED_URLS
    FREE(syslog_txt);
#endif /* SYSLOG_REQUESTED_URLS */
#ifdef LYNXCGI_LINKS  /* WebSter Mods -jkt */
d689 4
d705 1
d756 1
d759 1
d768 1
d773 1
a773 3
    for (i = 0; i < nlinks; i++) {
	FREE(links[i].lname);
    }
d775 5
a779 1
    HTList_delete(LYcommandList());
d786 1
a786 1
 *  This function frees the LYStdinArgs list. - FM
d788 1
a788 1
PRIVATE void LYStdinArgs_free NOARGS
d790 1
a790 10
    char *argument;
    HTList *cur = LYStdinArgs;

    if (cur == NULL)
	return;

    while (NULL != (argument = (char *)HTList_nextObject(cur))) {
	FREE(argument);
    }
    HTList_delete(LYStdinArgs);
a791 1
    return;
d794 1
a794 2
PUBLIC void exit_immediately ARGS1(
	int,		code)
d807 8
d819 1
d840 1
d842 1
a842 1
PRIVATE void FixCharacters(void)
d845 1
a845 2
    int work1[256],
	work2[256];
d849 2
a850 2
	work1[c] = keymap[c+1];
	work2[c] = key_override[c+1];
d853 2
a854 2
	keymap      [IBM1047[c]+1] = work1[c];
	key_override[IBM1047[c]+1] = work2[c];
d859 2
a860 16
PRIVATE int argncmp ARGS2(
	char*,		str,
	char*,		what)
{
    if (str[0] == '-' && str[1] == '-' ) ++str;
#if OPTNAME_ALLOW_DASHES
    return strncmp(str, what, strlen(what));
#else
    ++str; ++what; /*skip leading dash in both strings*/
    return !strn_dash_equ(str, what, strlen(what));
#endif
}

PRIVATE void tildeExpand ARGS2(
	char **,	pathname,
	BOOLEAN,	embedded)
d875 1
a875 1
     && temp[0] == '~') {
d877 1
a877 1
	 && temp[2] != '\0') {
d890 2
a891 3
PRIVATE BOOL GetStdin ARGS2(
	char **,	buf,
	BOOL,		marker)
d894 1
a894 1
     && (!marker || strncmp(*buf, "---", 3) != 0)) {
d904 1
a904 1
PRIVATE BOOL cleanup_win32(DWORD fdwCtrlType)
d920 2
a921 3
PRIVATE void append_ssl_version ARGS2(
	char **,	target,
	char *,		separator)
d945 1
a945 1
    LYstrncpy(SSLLibraryVersion, LYNX_SSL_VERSION, sizeof(SSLLibraryVersion)-1);
d961 2
a962 3
PUBLIC int main ARGS2(
	int,		argc,
	char **,	argv)
d964 2
a965 2
    int  i;		/* indexing variable */
    int status = 0;	/* exit status */
d972 1
d991 1
a991 1
    ftp_lasthost = calloc(1,sizeof(char));
d995 1
a995 1
    memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
d1006 2
a1007 3
	if (err != 0)
	{
	    printf(gettext("No Winsock found, sorry."));
d1019 1
a1019 1
#if 0 /* defined(__CYGWIN__) - does not work with screen */
d1022 1
a1022 1
	exit(EXIT_SUCCESS);
a1036 1

d1044 1
a1044 1
    __djgpp_set_sigquit_key(0x082D); /* Bind ALT-X to SIGQUIT */
d1049 1
a1049 1
      && (strstr(LYPathLeaf(cp), "sh") != NULL))
d1063 2
a1064 1
    if (LYGetEnv("TERM")==NULL) putenv("TERM=vt100");
d1069 1
a1069 1
     *	Set up the argument list.
d1078 1
a1078 1
     *	Act on -help NOW, so we only output the help and exit. - FM
d1081 1
a1081 8
	if (argncmp(argv[i], "-help") == 0) {
	    parse_arg(&argv[i], 1, &i);
	}
#ifdef SH_EX
	if (strncmp(argv[i], "-show_cfg", 9) == 0) {
	    show_cfg = TRUE;
	}
#endif
d1086 2
a1087 2
     *	Register the final function to be executed when being exited.
     *	Will display memory leaks if LY_FIND_LEAKS is defined.
d1091 1
a1091 1
     *	Register the function which will free our allocated globals.
a1095 1

d1098 1
a1098 1
     *	LOCALE support for international characters.
a1103 1
#ifndef __DJGPP__
d1106 2
a1107 3
    bindtextdomain ("lynx", cp);
#endif /* !__DJGPP__ */
    textdomain ("lynx");
d1111 1
a1111 1
     *	Initialize our startup and global variables.
d1115 1
a1115 1
     *	Need this for Ultrix.
d1122 1
a1122 1
     *	Zero the links and history struct arrays.
d1124 2
a1125 2
    memset((void *)links, 0, sizeof(LinkInfo)*MAXLINKS);
    memset((void *)history, 0, sizeof(HistInfo)*MAXHIST);
d1127 1
a1127 1
     *	Zero the MultiBookmark arrays.
d1129 3
a1131 2
    memset((void *)MBM_A_subbookmark, 0, sizeof(char)*(MBM_V_MAXFILES+1));
    memset((void *)MBM_A_subdescript, 0, sizeof(char)*(MBM_V_MAXFILES+1));
d1136 5
a1140 5
    AlertSecs	= SECS2Secs(ALERTSECS);
    DebugSecs	= SECS2Secs(DEBUGSECS);
    InfoSecs	= SECS2Secs(INFOSECS);
    MessageSecs	= SECS2Secs(MESSAGESECS);
    ReplaySecs	= SECS2Secs(REPLAYSECS);
d1200 2
a1201 2
	printf(gettext("You MUST define a valid TMP or TEMP area!\n"));
	exit(EXIT_FAILURE);
d1205 1
a1205 1
#ifdef WIN_EX	/* for Windows 2000 ... 1999/08/23 (Mon) 08:24:35 */
d1253 1
a1253 1
	&& mkdir(lynx_temp_space, 0700) < 0
d1256 1
a1256 1
     || !S_ISDIR(dir_info.st_mode)) {
a1261 1

d1282 1
a1282 1
    StrAllocCopy(BibP_bibhost, "http://bibhost/");  /* protocol specified. */
d1286 3
a1288 4
     *	Disable news posting if the compilation-based
     *	LYNewsPosting value is FALSE.  This may be changed
     *	further down via lynx.cfg or the -restriction
     *	command line switch. - FM
d1295 4
a1298 5
     *	Set up trace, the anonymous account defaults,
     *	validate restrictions, and/or the nosocks flag,
     *	if requested, and an alternate configuration
     *	file, if specified, NOW.  Also, if we only want
     *	the help menu, output that and exit. - FM
d1310 11
a1320 13
     *	If we have a lone "-" switch for getting arguments from stdin,
     *	get them NOW, and act on the relevant ones, saving the others
     *	into an HTList for handling after the other initializations.
     *	The primary purpose of this feature is to allow for the
     *	potentially very long command line that can be associated with
     *	post or get data.  The original implementation required that
     *	the lone "-" be the only command line argument, but that
     *	precluded its use when the lynx command is aliased with other
     *	arguments.  When interactive, the stdin input is terminated by
     *	by Control-D on Unix or Control-Z on VMS, and each argument
     *	is terminated by a RETURN.  When the argument is -get_data or
     *	-post_data, the data are terminated by a "---" string, alone
     *	on the line (also terminated by RETURN). - FM
d1339 2
a1340 2
	    if (parse_arg(&noargv[0], 2, (int *)0) == FALSE
	     &&  buf[0] != '\0') {
a1358 1

d1365 2
a1366 2
     *	If we had -validate set all of the restrictions
     *	and disallow a TRACE log NOW. - FM
d1374 3
a1376 4
     *	If we didn't get and act on a -validate or -anonymous
     *	switch, but can verify that this is the anonymous account,
     *	set the default restrictions for that account and disallow
     *	a TRACE log NOW. - FM
d1381 1
a1381 1
	!strcasecomp((LYGetEnv("USER")==NULL ? " " : LYGetEnv("USER")),
d1385 1
a1385 1
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER)
d1387 1
a1387 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER)
d1397 1
a1397 1
     *	Set up the TRACE log path, and logging if appropriate. - FM
d1401 3
a1403 1
    LYAddPathToHome(LYTraceLogPath = malloc(LY_MAXPATH), LY_MAXPATH, cp);
d1409 1
a1409 1
     *	Open command-script, if specified
d1416 1
a1416 1
     *	Open command-logging, if specified
d1425 1
a1425 1
     *	Set up the default jump file stuff. - FM
d1441 2
a1442 2
     *	If no alternate configuration file was specified on
     *	the command line, see if it's in the environment.
d1445 2
a1446 2
	if (((cp=LYGetEnv("LYNX_CFG")) != NULL) ||
	    (cp=LYGetEnv("lynx_cfg")) != NULL)
d1451 2
a1452 2
     *	If we still don't have a configuration file,
     *	use the userdefs.h definition.
d1457 1
a1457 1
#ifndef _WINDOWS /* avoid the whole ~ thing for now */
d1462 1
a1462 2
     *	If the configuration file is not available,
     *	inform the user and exit.
d1465 4
a1468 3
	fprintf(stderr, gettext("\nConfiguration file %s is not available.\n\n"),
			lynx_cfg_file);
	exit(EXIT_FAILURE);
d1472 2
a1473 2
     * Make sure we have the character sets declared.
     *	This will initialize the CHARTRANS handling. - KW
d1477 1
a1477 1
	exit(EXIT_FAILURE);
d1480 4
a1483 4
     *  (**) in Lynx, UCLYhndl_HTFile_for_unspec and UCLYhndl_for_unrec may be
     *  valid or not, but current_char_set and UCLYhndl_for_unspec SHOULD
     *  ALWAYS be a valid charset.  Initialized here and may be changed later
     *  from lynx.cfg/command_line/options_menu. - LP  (**)
d1486 1
a1486 1
     *	Set up the compilation default character set. - FM
d1493 1
a1493 1
    current_char_set = safeUCGetLYhndl_byMIME(CHARACTER_SET);
d1495 1
a1495 1
     *	Set up HTTP default for unlabeled charset (iso-8859-1).
d1502 1
a1502 1
     *	Make sure we have the edit map declared. - FM
d1506 1
a1506 34
	exit(EXIT_FAILURE);
    }

#if defined(USE_COLOR_STYLE)
    /*
     *	If no alternate lynx-style file was specified on
     *	the command line, see if it's in the environment.
     */
    if (!lynx_lss_file) {
	if (((cp=LYGetEnv("LYNX_LSS")) != NULL) ||
	    (cp=LYGetEnv("lynx_lss")) != NULL)
	    StrAllocCopy(lynx_lss_file, cp);
    }

    /*
     *	If we still don't have a lynx-style file,
     *	use the userdefs.h definition.
     */
    if (!lynx_lss_file)
	StrAllocCopy(lynx_lss_file, LYNX_LSS_FILE);

    tildeExpand(&lynx_lss_file, TRUE);

    /*
     *	If the lynx-style file is not available,
     *	inform the user and exit.
     */
    if (!LYCanReadFile(lynx_lss_file)) {
	fprintf(stderr, gettext("\nLynx file %s is not available.\n\n"),
			lynx_lss_file);
    }
    else
    {
	style_readFromFile(lynx_lss_file);
a1507 2
#endif /* USE_COLOR_STYLE */

d1510 1
a1510 1
     *	Set up default foreground and background colors.
d1516 1
a1516 1
     *  Set the original directory, used for default download
d1526 1
a1526 1
     *	Set the compilation default signature file. - FM
d1528 1
a1528 1
    LYstrncpy(filename, LYNX_SIG_FILE, sizeof(filename)-1);
d1544 27
a1570 1
     *	Process the configuration file.
d1572 16
a1587 1
    read_cfg(lynx_cfg_file, "main program", 1, (FILE *)0);
d1590 1
a1590 1
     *	Process the RC file.
d1612 1
a1612 1
    LYEnsureAbsoluteURL((char **)&LynxHome, "LynxHome", FALSE);
d1615 2
a1616 1
     *  Process any command line arguments not already handled. - FM
d1623 2
a1624 2
     *  Process any stdin-derived arguments for a lone "-"  which we've
     *  loaded into LYStdinArgs. - FM
d1631 2
a1632 2
	while (NULL != (my_args[0] = (char *)HTList_nextObject(cur))) {
	    parse_arg(my_args, 4, (int *)0);
d1637 1
a1637 1
    if (current_char_set == auto_display_charset) /* Better: explicit option */
d1643 3
a1645 2
     *	If we are told to read the startfile from standard input, do it now,
     *	after we have read all of the option data from standard input.
a1649 6
	char *tty = NULL;
# ifdef HAVE_TTYNAME
	tty = ttyname(fileno(stderr));
# endif
	if (tty == NULL)
	    tty = isatty(fileno(stdin)) ? TTY_DEVICE : NUL_DEVICE;
d1651 2
a1652 2
	CTRACE((tfp, "processing stdin startfile, tty=%s\n", tty));
	if ((fp = LYOpenTemp (result, HTML_SUFFIX, "w")) != 0) {
a1661 7
	if ((freopen(tty, "r", stdin)) == 0) {
	    CTRACE((tfp, "cannot open a terminal (%s)\n", tty));
	    if (!dump_output_immediately) {
		fprintf(stderr, "cannot open a terminal (%s)\n", tty);
		exit(1);
	    }
	}
d1666 1
a1666 1
     *  Initialize other things based on the configuration read.
d1670 1
a1670 1
    if ( (!Old_DTD) != TRUE ) /* skip if they are already initialized -HV */
d1672 1
a1672 1
    HTSwitchDTD(!Old_DTD);
d1688 4
a1691 2
	if(LYCookieFile == NULL) {
	    LYAddPathToHome(LYCookieFile = malloc(LY_MAXPATH), LY_MAXPATH, COOKIE_FILE);
d1726 2
a1727 3
     *	Check for a save space path in the environment.
     *	If one was set in the configuration file, that
     *	one will be overridden. - FM
d1733 1
a1733 1
     *	We have a save space path, make sure it's valid. - FM
d1762 4
a1765 5
     *	Set up the file extension and mime type maps from
     *	src/HTInit.c and the global and personal mime.types
     *	and mailcap files.  These will override any SUFFIX
     *	or VIEWER maps in userdefs.h or the configuration
     *	file, if they overlap.
d1777 1
a1777 1
	exit(EXIT_SUCCESS);
a1796 1

d1812 7
d1836 1
a1836 1
     *	Check the -popup command line toggle. - FM
d1843 1
a1843 1
     *	Check the -show_cursor command line toggle. - FM
d1850 1
a1850 1
     *	Check the -base command line switch with -source. - FM
d1857 3
a1859 4
     *	Disable multiple bookmark support if not interactive,
     *	so it doesn't crash on curses functions, or if the
     *	support was blocked via userdefs.h and/or lynx.cfg,
     *	or via command line restrictions. - FM
a1867 1

d1893 6
a1898 6
	__system_emulate_chdir	      | /* handle `cd' internally */
	__system_handle_null_commands | /* ignore cmds with no effect */
	__system_allow_long_cmds      | /* handle commands > 126 chars	 */
	__system_use_shell	      | /* use $SHELL if set */
	__system_allow_multiple_cmds  | /* allow `cmd1; cmd2; ...' */
	__system_redirect;		/* redirect internally */
d1901 2
a1902 2
    _djstat_flags |= _STAT_INODE | _STAT_EXEC_MAGIC |_STAT_DIRSIZE;
#endif  /* __DJGPP__ */
d1929 1
a1929 1
	 *  Since we're doing lots of TCP, just ignore SIGPIPE altogether.
d1931 4
a1934 5
	 *  HTTCP.c should deal with a broken pipe for servers.
	 *  Rick Mallet's check after c = GetChar() in LYStrings.c should
	 *   deal with a disconnected terminal.
	 *  So the runaway CPU time problem on Unix should not occur any
	 *   more.
d1938 1
a1938 1
	     restore_sigpipe_for_children = TRUE;
d1945 1
a1945 1
     *	Block Control-Z suspending if requested. - FM
d1952 1
a1952 1
     *	Check for a valid HEAD request. - FM
d1956 1
a1956 1
 "The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
d1962 1
a1962 1
     *	Check for a valid MIME headers request. - FM
d1966 1
a1966 1
 "The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
d1972 1
a1972 1
     *	Check for a valid traversal request. - FM
d1976 1
a1976 1
 "The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
d1982 3
a1984 3
     *  Finish setting up for an INTERACTIVE session.
     *  Done here so that URL guessing in LYEnsureAbsoluteURL() can be
     *  interruptible (terminal is in raw mode, select() works).  -BL
d1988 1
a1988 1
	HTMLSRC_init_caches(FALSE); /* do it before terminal is initialized*/
d1999 2
a2000 3
     *	If startfile is a file URL and the host is defaulted,
     *	force in "//localhost", and if it's not an absolute URL,
     *	make it one. - FM
d2002 1
a2002 1
    LYEnsureAbsoluteURL((char **)&startfile, "STARTFILE", FALSE);
d2005 3
a2007 3
     *	If homepage was specified and is a file URL with the
     *	host defaulted, force in "//localhost", and if it's
     *	not an absolute URL, make it one. - FM
d2010 1
a2010 1
	LYEnsureAbsoluteURL((char **)&homepage, "HOMEPAGE", FALSE);
d2014 2
a2015 3
     *	If we don't have a homepage specified,
     *	set it to startfile.  Otherwise, reset
     *	LynxHome. - FM
d2017 1
a2017 1
    if (!(homepage && *homepage)) {
d2024 1
a2024 1
     *	Set up the inside/outside domain restriction flags. - FM
d2027 2
a2028 2
#if !defined(HAVE_UTMP) || defined(VMS) /* not selective */
	telnet_ok = (BOOL)(!no_inside_telnet && !no_outside_telnet && telnet_ok);
d2030 1
a2030 1
	news_ok = (BOOL)(!no_inside_news && !no_outside_news && news_ok);
d2032 2
a2033 2
	ftp_ok = (BOOL)(!no_inside_ftp && !no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && !no_outside_rlogin && rlogin_ok);
d2036 1
a2036 1
	telnet_ok = (BOOL)(!no_inside_telnet && telnet_ok);
d2038 1
a2038 1
	news_ok = (BOOL)(!no_inside_news && news_ok);
d2040 2
a2041 2
	ftp_ok = (BOOL)(!no_inside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_inside_rlogin && rlogin_ok);
d2045 1
a2045 1
	telnet_ok = (BOOL)(!no_outside_telnet && telnet_ok);
d2047 1
a2047 1
	news_ok = (BOOL)(!no_outside_news && news_ok);
d2049 2
a2050 2
	ftp_ok = (BOOL)(!no_outside_ftp && ftp_ok);
	rlogin_ok = (BOOL)(!no_outside_rlogin && rlogin_ok);
d2054 2
a2055 2
     *	Make sure our bookmark default strings
     *	are all allocated and synchronized. - FM
d2066 3
d2070 3
a2072 3
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
    LYOpenlog (syslog_txt);
#endif
d2075 1
a2075 1
     *	Here's where we do all the work.
d2079 1
a2079 2
	 *  Finish setting up and start a
	 *  NON-INTERACTIVE session. - FM
d2083 3
a2085 1
	} else if (!nolist) {
a2092 4

	if (x_display != NULL && *x_display != '\0') {
	    LYisConfiguredForX = TRUE;
	}
d2096 21
d2118 1
a2118 1
	if (!nolist &&
d2122 1
d2125 2
a2126 3
	 *  We want to save cookies picked up when in immediate dump
	 *  mode.  Instead of calling cleanup() here, let's only call
	 *  this one. - BJP
d2134 1
a2134 1
	 *  Start an INTERACTIVE session. - FM
a2135 3
	if (x_display != NULL && *x_display != '\0') {
	    LYisConfiguredForX = TRUE;
	}
d2151 1
a2151 1
	ena_csi((BOOLEAN)(LYlowest_eightbit[current_char_set] > 155));
d2156 1
a2156 3
	if (! isendwin()) {
	    extern int saved_scrsize_x;
	    extern int saved_scrsize_y;
d2158 1
a2158 1
	        resize_term(saved_scrsize_y, saved_scrsize_x);
d2163 1
a2163 1
	exit(status);
d2166 1
a2166 1
    return(status);	/* though redundant, for compiler-warnings */
d2170 2
a2171 2
 *  Called by HTAccessInit to register any protocols supported by lynx.
 *  Protocols added by lynx:
d2180 1
d2182 5
a2186 5
GLOBALREF  HTProtocol LYLynxKeymap;
GLOBALREF  HTProtocol LYLynxCGI;
GLOBALREF  HTProtocol LYLynxIMGmap;
GLOBALREF  HTProtocol LYLynxCookies;
GLOBALREF  HTProtocol LYLynxStatusMessages;
d2189 1
a2189 1
PUBLIC void LYRegisterLynxProtocols NOARGS
d2200 2
a2201 3
 *  Some stuff to reload lynx.cfg without restarting new lynx session,
 *  also load options menu items and command-line options
 *  to make things consistent.
d2203 1
a2203 1
 *  Called by user of interactive session by LYNXCFG://reload/ link.
d2205 1
a2205 1
 *  Warning: experimental, more main() reorganization required.
d2215 1
a2215 1
PUBLIC void reload_read_cfg NOARGS
d2219 1
d2221 8
a2228 9
     *  no_option_save is always set for -anonymous and -validate.
     *  It is better to check for one or several specific restriction
     *  flags than for 'LYRestricted', which doesn't get set for
     *  individual restrictions or for -validate!
     *  However, no_option_save may not be the appropriate one to
     *  check - in that case, a new no_something should be added
     *  that gets automatically set for -anonymous and -validate
     *  (and whether it applies for -anonymous can be made installer-
     *  configurable in the usual way at the bottom of userdefs.h). - kw
d2239 6
a2244 7
     *  Current user preferences are saved in a temporary file, to be
     *  read in again after lynx.cfg has been read.  This avoids
     *  accidental changing of the preferences file.  The regular
     *  preferences file doesn't even need to exist, and won't be
     *  created as a side effect of this function.  Honoring the
     *  no_option_save restriction may thus be unnecessarily restrictive,
     *  but the check is currently still left in place. - kw
d2251 1
a2251 1
    rcfp = LYOpenTemp(tempfile, ".rc" , "w");
d2261 2
a2262 4
	return;    /* can not write the very own file :( */
    }

    {
d2266 3
a2268 2
	char * LYCookieFile_flag = NULL;
	char * LYCookieSaveFile_flag = NULL;
d2278 1
a2278 1
	memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
d2287 1
a2287 1
	source_cache_file_error = FALSE; /* reset flag */
d2291 1
a2291 1
	 *  Process the configuration file.
d2293 1
a2293 1
	read_cfg(lynx_cfg_file, "main program", 1, (FILE *)0);
d2296 1
a2296 1
	 *  Process the temporary RC file.
d2311 1
a2311 1
	 *  Process any command line arguments not already handled.
d2313 1
a2313 1
		/* Not implemented yet here */
d2316 2
a2317 2
	 *  Process any stdin-derived arguments for a lone "-"  which we've
	 *  loaded into LYStdinArgs.
d2319 1
a2319 1
		/* Not implemented yet here */
d2322 1
a2322 1
	 *  Initialize other things based on the configuration read.
d2329 4
a2332 4
		/* Not implemented yet here,
		 * a major problem: file paths
		 * like lynx_save_space, LYCookieFile etc.
		 */
d2342 2
a2343 1
		CTRACE((tfp, "cookie file can be changed in next session only, restored.\n"));
d2347 2
a2348 1
		CTRACE((tfp, "cookie save file can be changed in next session only, restored.\n"));
d2359 1
a2359 1
PRIVATE void disable_pausing NOARGS
d2368 1
a2368 1
PRIVATE void force_dump_mode NOARGS
d2391 3
a2393 4
typedef struct parse_args_type
{
   CONST char *name;
   int type;
d2412 3
a2414 3
   /* If the NEED_NEXT_ARG flags is set, and the option was not specified
    * with an '=' character, then use the next argument in the argv list.
    */
d2416 3
a2418 4
   ParseData;
   CONST char *help_string;
}
Config_Type;
d2421 2
a2422 3
PRIVATE int parse_authentication ARGS2(
	char *,			next_arg,
	char **,		result)
d2425 1
a2425 1
     *  Authentication information for protected documents.
d2431 1
a2431 1
	memset(next_arg, ' ', strlen(next_arg));  /* Let's not show too much */
d2437 1
a2437 1
	if ((cp = strchr(auth_info, ':')) != 0) {		/* Pw */
d2442 1
a2442 1
	if (*auth_info) {					/* Id */
d2452 1
a2452 2
PRIVATE int anonymous_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2461 1
a2461 2
PRIVATE int assume_charset_fun ARGS1(
	char *,			next_arg)
d2474 1
a2474 2
PRIVATE int assume_local_charset_fun ARGS1(
	char *,			next_arg)
d2481 1
a2481 2
PRIVATE int assume_unrec_charset_fun ARGS1(
	char *,			next_arg)
d2488 1
a2488 2
PRIVATE int auth_fun ARGS1(
	char *,			next_arg)
d2495 1
a2495 2
PRIVATE int base_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2498 5
a2502 6
     *  Treat -source equivalently to an interactive download with
     *  LYPrefixBaseToSource configured to TRUE, so that a BASE tag is
     *  prepended for text/html content types.  We normally treat the
     *  module-wide global LYPrefixBaseToSource flag as FALSE with
     *  -source, but force it TRUE, later, if LYPrependBase is set
     *  TRUE here. - FM
d2512 1
a2512 2
PRIVATE int cache_fun ARGS1(
	char *,			next_arg)
d2517 1
a2517 1
     *  Limit size.
d2519 2
a2520 1
    if (HTCacheSize < 2) HTCacheSize = 2;
d2526 1
a2526 2
PRIVATE int child_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2535 1
a2535 2
PRIVATE int color_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2548 1
a2548 2
PRIVATE int convert_to_fun ARGS1(
	char *,			next_arg)
d2554 1
d2557 1
a2557 1
	/*LYLowerCase(outformat);*/
d2561 1
a2561 1
		while (*cp2 == ' ' || *cp2 == '=' || *cp2 == '\"')
d2563 3
a2565 4
		for (cp4 = cp2; (*cp4 != '\0' && *cp4 != '\"' &&
				 *cp4 != ';'  &&
				 !WHITE(*cp4));	cp4++)
		    ; /* do nothing */
d2570 2
a2571 1
		if (chndl < 0) chndl = UCLYhndl_for_unrec;
d2574 1
a2574 1
		    gettext("Lynx: ignoring unrecognized charset=%s\n"), cp2);
d2591 1
a2591 2
PRIVATE int crawl_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2599 1
a2599 2
PRIVATE int display_fun ARGS1(
	char *,			next_arg)
d2609 1
a2609 2
PRIVATE int display_charset_fun ARGS1(
	char *,			next_arg)
d2617 1
a2617 1
    if (i < 0) {	/* do nothing here: so fallback to lynx.cfg */
d2620 1
a2620 2
    }
    else
d2626 1
a2626 2
PRIVATE int dump_output_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2633 1
a2633 2
PRIVATE int editor_fun ARGS1(
	char *,			next_arg)
d2642 1
a2642 2
PRIVATE int error_file_fun ARGS1(
	char *,			next_arg)
d2645 1
a2645 2
     *  Output return (success/failure) code
     *  of an HTTP transaction.
d2654 1
a2654 2
PRIVATE int exec_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2666 1
a2666 2
PRIVATE int get_data_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2669 1
a2669 1
     *  User data for GET form.
d2675 2
a2676 2
     *  On Unix, conflicts with curses when interactive
     *  so let's force a dump.  - CL
d2678 2
a2679 2
     *  On VMS, mods have been made in LYCurses.c to deal with
     *  potential conflicts, so don't force the dump here. - FM
d2685 1
a2685 1
    StrAllocCopy(form_get_data, "?");   /* Prime the pump */
d2689 2
a2690 2
     *  Build GET data for later.  Stop reading when we see a line
     *  with "---" as its first three characters.
d2696 2
d2702 1
a2702 2
PRIVATE int help_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2704 1
a2704 1
    print_help_and_exit (0);
d2709 1
a2709 2
PRIVATE int hiddenlinks_fun ARGS1(
	char *,			next_arg)
d2711 1
d2718 1
d2722 1
a2722 1
	    print_help_and_exit (-1);
d2731 1
a2731 2
PRIVATE int homepage_fun ARGS1(
	char *,			next_arg)
d2741 1
a2741 2
PRIVATE int mime_header_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2744 1
a2744 1
     *  Include mime headers and force source dump.
d2756 1
a2756 2
PRIVATE int newschunksize_fun ARGS1(
	char *,			next_arg)
d2771 1
a2771 2
PRIVATE int newsmaxchunk_fun ARGS1(
	char *,			next_arg)
d2787 1
a2787 2
PRIVATE int nobold_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2789 2
a2790 2
   LYnoVideo(1);
   return 0;
d2794 1
a2794 2
PRIVATE int nobrowse_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2796 2
a2797 2
   HTDirAccess = HT_DIR_FORBID;
   return 0;
d2801 1
a2801 2
PRIVATE int nocolor_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2812 1
a2812 2
PRIVATE int nopause_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2819 1
a2819 2
PRIVATE int noreverse_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2821 2
a2822 2
   LYnoVideo(2);
   return 0;
d2826 1
a2826 2
PRIVATE int nounderline_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2828 2
a2829 2
   LYnoVideo(4);
   return 0;
d2834 1
a2834 2
PRIVATE int nozap_fun ARGS1(
	char *,			next_arg)
d2836 1
a2836 1
    LYNoZapKey = 1; /* everything but "initially" treated as "full" - kw */
d2842 1
a2842 1
   return 0;
d2847 1
a2847 2
PRIVATE int pauth_fun ARGS1(
	char *,			next_arg)
d2854 1
a2854 2
PRIVATE int post_data_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d2857 1
a2857 1
     *  User data for POST form.
d2885 1
a2885 2
PRIVATE char *show_restriction ARGS1(
	CONST char *,		name)
d2887 1
a2887 1
    char *value = 0;
d2904 1
a2904 2
PRIVATE int restrictions_fun ARGS1(
	char *,			next_arg)
d2906 4
a2909 3
    static CONST struct {
	CONST char *name;
	CONST char *help;
d3024 8
a3031 5
    static CONST char *Usage[] = {
 ""
,"USAGE: lynx -restrictions=[option][,option][,option]"
,"List of Options:"
,"  ?                 when used alone, list restrictions in effect."
d3035 2
a3036 2
    CONST char *name;
    CONST char *value;
d3040 1
a3040 1
	SetOutputMode( O_TEXT );
d3046 1
a3046 1
	     || !strcmp(table[j].name, "default")) {
d3051 1
a3051 2
	    print_help_strings (
		table[j].name, table[j].help, value, FALSE);
d3054 1
a3054 1
	for (j = 0; ; j++) {
d3080 2
a3081 2
	SetOutputMode( O_BINARY );
	exit(EXIT_SUCCESS);
d3083 1
a3083 1
	SetOutputMode( O_TEXT );
d3085 2
a3086 2
	SetOutputMode( O_BINARY );
	exit(EXIT_SUCCESS);
d3094 1
a3094 2
PRIVATE int selective_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3096 2
a3097 2
   HTDirAccess = HT_DIR_SELECTIVE;
   return 0;
d3101 1
a3101 2
PRIVATE int source_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3111 1
a3111 2
PRIVATE int traversal_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3124 1
a3124 2
PRIVATE int version_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
d3128 1
a3128 1
    SetOutputMode( O_TEXT );
d3138 12
d3180 5
a3184 8
    printf("\n");
    printf(gettext(
	  "Copyrights held by the University of Kansas, CERN, and other contributors.\n"
	  ));
    printf(gettext("Distributed under the GNU General Public License.\n"));
    printf(gettext(
	  "See http://lynx.isc.org/ and the online help for more information.\n\n"
	  ));
d3186 2
a3187 3
    printf("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.\n");
#ifdef OPENSSL_VERSION_TEXT
    printf("See http://www.openssl.org/ for information about OpenSSL.\n");
d3189 1
a3189 1
    printf("\n");
d3192 1
a3192 1
    SetOutputMode( O_BINARY );
d3194 1
a3194 1
    exit(EXIT_SUCCESS);
d3200 1
a3200 2
PRIVATE int width_fun ARGS1(
	char *,			next_arg)
d3204 1
d3214 1
a3214 2
PRIVATE int scrsize_fun ARGS1(
	char *,			next_arg)
d3240 2
a3241 1
PRIVATE Config_Type Arg_Table [] =
d3459 1
a3459 1
      "get_data",	6|FUNCTION_ARG,		get_data_fun,
d3467 1
a3467 1
      "help",		5|FUNCTION_ARG,		help_fun,
d3501 1
a3501 1
      "link",		4|NEED_INT_ARG,		ccount,
d3505 4
d3520 1
a3520 1
      "lss",		2|NEED_LYSTRING_ARG,	lynx_lss_file,
d3581 1
a3581 1
      "nolist",		4|SET_ARG,		nolist,
d3588 4
d3598 4
d3624 1
a3624 1
      "nosocks",	6|UNSET_ARG,		socks_flag,
d3632 4
d3674 1
a3674 1
      "post_data",	6|FUNCTION_ARG,		post_data_fun,
d3749 1
a3749 1
      "show_cfg",	4|SET_ARG,		show_cfg,
d3781 4
a3787 1
#ifndef VMS
d3793 4
a3796 1
#endif
d3871 1
a3871 1
      "version",	4|FUNCTION_ARG,		version_fun,
d3896 1
d3898 4
a3901 5
PRIVATE void print_help_strings ARGS4(
	CONST char *,	name,
	CONST char *,	help,
	CONST char *,	value,
	BOOLEAN,	option)
d3908 1
a3908 1
    pad = field_width - (2 + option + (int) strlen (name));
d3910 1
a3910 1
    fprintf (stdout, "  %s%s", option ? "-" : "", name);
d3915 1
a3915 1
	    fputc (' ', stdout);
d3918 1
a3918 1
	fputc (' ', stdout);	  /* at least one space */
d3924 2
a3925 2
    if (strchr (help, '\n') == 0) {
	fprintf (stdout, "%s", help);
d3934 1
a3934 1
		fputc (c, stdout);
d3936 1
a3936 1
		    fputc (' ', stdout);
d3938 1
a3938 1
		fputc (c, stdout);
d3946 1
a3946 1
    fputc ('\n', stdout);
d3949 1
a3949 1
PRIVATE void print_help_and_exit ARGS1(int, exit_status)
d3953 2
a3954 1
    if (pgm == NULL) pgm = "lynx";
d3956 1
a3956 1
    SetOutputMode( O_TEXT );
d3958 2
a3959 2
    fprintf (stdout, gettext("USAGE: %s [options] [file]\n"), pgm);
    fprintf (stdout, gettext("Options are:\n"));
d3962 1
a3962 1
"receive the arguments from stdin (enclose\n\
d3973 16
a3988 19
	    case TOGGLE_ARG:
	    case SET_ARG:
		strcpy(temp, *(q->set_value) ? "on" : "off");
		break;
	    case UNSET_ARG:
		strcpy(temp, *(q->set_value) ? "off" : "on");
		break;
	    case INT_ARG:
		sprintf(temp, "%d", *(q->int_value));
		break;
	    case TIME_ARG:
		sprintf(temp, SECS_FMT, (double) Secs2SECS(*(q->int_value)));
		break;
	    case STRING_ARG:
		if ((value = *(q->str_value)) != 0
		 && !*value)
		    value = 0;
		break;
	    default:
d3990 4
a3993 1
		break;
d3998 1
a3998 1
    SetOutputMode( O_BINARY );
d4000 1
a4000 1
    exit (exit_status);
d4011 3
a4013 4
PRIVATE int arg_eqs_parse ARGS3(
	CONST char *,	a,
	char *,		b,
	char **,	c)
d4020 2
a4021 2
	 || (*a == 0)
	 || (*b == 0)) {
d4057 1
a4057 1
		result = 0;
d4066 2
a4067 2
#define is_true(s)  (*s == '1' || *s == '+' || !strcmp(s, "on"))
#define is_false(s) (*s == '0' || *s == '-' || !strcmp(s, "off"))
d4069 11
a4079 4
PRIVATE BOOL parse_arg ARGS3(
	char **,	argv,
	unsigned,	mask,
	int *,		i)
d4083 1
d4085 1
a4085 1
    static BOOLEAN had_nonoption = FALSE;
d4089 12
d4103 1
a4103 1
     *	Check for a command line startfile. - FM
d4105 3
a4107 4
#if !EXTENDED_OPTION_LOGIC
    if (*arg_name != '-')
#else
    if (*arg_name != '-' || no_options_further == TRUE )
d4109 1
a4109 1
    {
d4111 11
a4121 2
	if (had_nonoption && !dump_output_immediately) {
	    HTAddGotoURL(startfile); /* startfile was set by a previous arg */
a4122 1
	had_nonoption = TRUE;
d4126 1
a4126 1
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 20:11:17 */
d4129 1
a4129 1
	    char *p;
d4131 3
a4133 4
	    p = startfile;
	    while (*p++) {
		if (*p == '|')
		    *p = ':';
d4137 2
a4138 1
	return (BOOL)(i != 0);
d4141 1
a4141 1
    if (strcmp(arg_name,"--") == 0) {
d4151 2
a4152 3
     *	Skip any lone "-" arguments, because we've loaded
     *	the stdin input into an HTList structure for
     *	special handling. - FM
d4157 3
a4159 2
    /* allow GNU-style options with -- prefix*/
    if (*arg_name == '-') ++arg_name;
d4161 1
a4161 1
    CTRACE((tfp, "parse_arg(%s)\n", arg_name));
d4171 1
a4171 1
	    || (0 == arg_eqs_parse (p->name, arg_name, &next_arg))) {
d4179 2
a4180 2
		if ((i != 0) && (next_arg != 0))
		    (*i)++;
d4182 1
a4182 1
	    CTRACE((tfp, "...arg:%s\n", next_arg != 0 ? next_arg : "<null>"));
d4187 1
a4187 1
	    CTRACE((tfp, "...skip (mask %d/%d)\n", mask, p->type & 7));
d4195 2
a4196 2
	     if (q->set_value != 0) {
		 if (next_arg == 0) {
d4199 2
a4200 2
			 *(q->set_value) = (BOOL) !(*(q->set_value));
			 break;
d4202 2
a4203 2
			 *(q->set_value) = TRUE;
			 break;
d4205 2
a4206 2
			 *(q->set_value) = FALSE;
			 break;
d4208 8
a4215 8
		 } else if (is_true(next_arg)) {
		     *(q->set_value) = TRUE;
		 } else if (is_false(next_arg)) {
		     *(q->set_value) = FALSE;
		 }
		 /* deliberately ignore anything else - BL */
	     }
	     break;
d4218 6
a4223 6
	     fun = q->fun_value;
	     if (0 != fun) {
		 if (-1 == (*fun) (next_arg)) {
		 }
	     }
	     break;
d4226 3
a4228 3
	     if ((q->str_value != 0) && (next_arg != 0))
		 StrAllocCopy(*(q->str_value), next_arg);
	     break;
d4231 3
a4233 3
	     if ((q->int_value != 0) && (next_arg != 0))
		 *(q->int_value) = strtol (next_arg, &temp_ptr, 0);
	     break;
d4238 2
a4239 1
		if (1 == sscanf (next_arg, "%f", &ival)) {
d4255 2
a4256 1
    if (pgm == 0) pgm = "LYNX";
d4258 2
a4259 2
    fprintf (stderr, gettext("%s: Invalid Option: %s\n"), pgm, argv[0]);
    print_help_and_exit (-1);
d4264 1
a4264 2
PRIVATE void FatalProblem ARGS1(
	int,		sig)
d4267 1
a4267 1
     *	Ignore further interrupts. - mhc: 11/2/91
d4272 2
a4273 2
    (void) signal (SIGTERM, SIG_IGN);
    (void) signal (SIGINT, SIG_IGN);
d4283 1
a4283 1
     *	Flush all messages. - FM
d4289 1
a4289 1
     *	Deal with curses, if on, and clean up. - FM
d4304 1
a4304 1
     *	Issue appropriate messages and abort or exit. - FM
d4307 1
a4307 1
	fprintf (stderr, "\r\n\
d4324 22
a4345 9
#ifdef WIN_EX	/* 1998/08/09 (Sun) 09:58:25 */
	{
	    char *msg;
	    switch (sig) {
	    case SIGABRT:	msg = "SIGABRT";	break;
	    case SIGFPE:	msg = "SIGFPE";		break;
	    case SIGILL:	msg = "SIGILL";		break;
	    case SIGSEGV:	msg = "SIGSEGV";	break;
	    default:		msg = "Not-def";	break;
a4346 2
	    fprintf(stderr, "signal code = %s\n", msg);
	}
d4351 1
a4351 1
	 *  Exit and possibly dump core.
d4354 1
a4354 1
	    exit(EXIT_FAILURE);
d4364 1
a4364 1
	 *  Exit without dumping core.
d4366 1
a4366 1
	exit(EXIT_SUCCESS);
@


1.12
log
@zap compilation date from the binary; ok henning@@
@
text
@d1204 4
@


1.11
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@a3154 3
#ifdef SYSTEM_NAME
    printf(gettext("Built on %s %s %s\n"), SYSTEM_NAME, __DATE__, __TIME__);
#else
a3165 2
#else
    printf("Compiled at (%s %s).\n", __DATE__, __TIME__);
a3169 1
#endif
@


1.10
log
@Re-include a patch missed in the recent upgrade:
When passive FTP fails, switch to active FTP and try again

Submitted by Andrew Basterfield <bob@@cemetery.homeunix.org>
@
text
@d43 1
d63 1
d66 1
d79 1
a79 1
char init_ctrl_break[1];
a98 4
#ifdef VMS
PUBLIC char *LYCSwingPath = NULL;
#endif /* VMS */

d102 3
d106 1
a106 1
PUBLIC HTList *tagged = NULL;
d110 1
d118 1
a118 1
PUBLIC int LYAutoUncacheDirLists = 2; /* default dired uncaching behavior */
d160 1
d165 1
d169 4
d174 1
a174 1
PUBLIC BOOLEAN verbose_img = VERBOSE_IMAGES;  /* show filenames or not */
d176 2
d179 1
a180 1
PUBLIC BOOLEAN LYinternal_flag = FALSE; /* override no-cache b/c internal link*/
d183 9
a191 4
PUBLIC BOOLEAN LYUserSpecifiedURL = TRUE;/* always TRUE  the first time */
PUBLIC BOOLEAN LYJumpFileURL = FALSE;	 /* always FALSE the first time */
PUBLIC BOOLEAN jump_buffer = JUMPBUFFER; /* TRUE if offering default shortcut */
PUBLIC BOOLEAN goto_buffer = GOTOBUFFER; /* TRUE if offering default goto URL */
d195 2
a196 3
PUBLIC BOOLEAN recent_sizechange = FALSE;/* the window size changed recently? */
PUBLIC int user_mode = NOVICE_MODE;
PUBLIC BOOLEAN dump_output_immediately = FALSE;
d198 1
d200 1
a200 4
PUBLIC BOOLEAN bold_headers = FALSE;
PUBLIC BOOLEAN bold_H1 = FALSE;
PUBLIC BOOLEAN bold_name_anchors = FALSE;
PUBLIC BOOLEAN use_underscore = SUBSTITUTE_UNDERSCORES;
d202 3
a204 2
PUBLIC BOOLEAN historical_comments = FALSE;
PUBLIC BOOLEAN minimal_comments = FALSE;
d206 2
a207 6
PUBLIC BOOLEAN LYRestricted = FALSE; /* whether we have -anonymous option */
PUBLIC BOOLEAN LYValidate = FALSE;
PUBLIC BOOLEAN LYPermitURL = FALSE;
PUBLIC BOOLEAN child_lynx = FALSE;
PUBLIC BOOLEAN error_logging = MAIL_SYSTEM_ERROR_LOGGING;
PUBLIC BOOLEAN check_mail = CHECKMAIL;
a208 1
PUBLIC BOOLEAN emacs_keys = EMACS_KEYS_ALWAYS_ON;
d210 1
a210 1
PUBLIC BOOLEAN case_sensitive = CASE_SENSITIVE_ALWAYS_ON;
d296 1
d300 1
a320 2
#ifdef WIN_EX
PUBLIC int     debug_delay = 0;		/* 1998/10/06 (Tue) 08:41:20 */
d322 1
a323 1
#endif /* SH_EX */
d425 1
a425 1
PUBLIC histstruct history[MAXHIST];
d427 1
d434 1
d441 1
a441 1
PUBLIC linkstruct links[MAXLINKS];
d451 1
a451 1
#ifdef EXP_PERSISTENT_COOKIES
d455 1
a455 1
#endif /* EXP_PERSISTENT_COOKIES */
d468 2
a469 1
PUBLIC int LYTransferRate = rateEtaKB_maybe;
d495 6
d508 4
d516 5
d549 1
a549 2
extern int HTNewsChunkSize; /* Number of news articles per chunk (HTNews.c) */
extern int HTNewsMaxChunk;  /* Max news articles before chunking (HTNews.c) */
d620 1
a620 1
PUBLIC int is_windows_nt(void)
a650 1
    FREE(LYCSwingPath);
d652 3
d685 1
a685 1
#ifdef EXP_PERSISTENT_COOKIES
d716 45
d762 59
a820 1
    FREE(lynx_version_putenv_command);
d822 17
a838 13
	    FREE(lynx_temp_space);
	    FREE(LYTraceLogPath);
	    FREE(lynx_cfg_file);
	#if defined(USE_COLOR_STYLE)
	    FREE(lynx_lss_file);
	#endif
	    FREE(UCAssume_MIMEcharset);
	    LYUIPages_free();
	    for (i = 0; i < nlinks; i++) {
		FREE(links[i].lname);
	    }
	    nlinks = 0;
	    HTList_delete(LYcommandList());
d840 12
a851 1
	    return;
d853 29
a881 1
	#endif /* LY_FIND_LEAKS */
d883 14
a896 7
	/*
	 *  This function frees the LYStdinArgs list. - FM
	 */
	PRIVATE void LYStdinArgs_free NOARGS
	{
	    char *argument;
	    HTList *cur = LYStdinArgs;
d898 11
a908 2
	    if (cur == NULL)
		return;
d910 10
a919 6
	    while (NULL != (argument = (char *)HTList_nextObject(cur))) {
		FREE(argument);
	    }
	    HTList_delete(LYStdinArgs);
	    LYStdinArgs = NULL;
	    return;
d921 4
d926 39
a964 38
	PUBLIC void exit_immediately ARGS1(
		int,		code)
	{
	#ifndef NOSIGHUP
	    (void) signal(SIGHUP, SIG_DFL);
	#endif /* NOSIGHUP */
	    (void) signal(SIGTERM, SIG_DFL);
	#ifndef VMS
	    (void) signal(SIGINT, SIG_DFL);
	#endif /* !VMS */
	#ifdef SIGTSTP
	    if (no_suspend)
		(void) signal(SIGTSTP, SIG_DFL);
	#endif /* SIGTSTP */
	    exit(code);
	}

	#ifdef  EBCDIC
	      char un_IBM1047[ 256 ] = "";
	unsigned char IBM1047[ 256 ] = /* ATOE OEMVS311 */
	{
	0x00,0x01,0x02,0x03,0x37,0x2d,0x2e,0x2f,0x16,0x05,0x15,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13,0x3c,0x3d,0x32,0x26,0x18,0x19,0x3f,0x27,0x1c,0x1d,0x1e,0x1f,
	0x40,0x5a,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
	0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
	0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xad,0xe0,0xbd,0x5f,0x6d,
	0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
	0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x4f,0xd0,0xa1,0x07,
	0x20,0x21,0x22,0x23,0x24,0x25,0x06,0x17,0x28,0x29,0x2a,0x2b,0x2c,0x09,0x0a,0x1b,
	0x30,0x31,0x1a,0x33,0x34,0x35,0x36,0x08,0x38,0x39,0x3a,0x3b,0x04,0x14,0x3e,0xff,
	0x41,0xaa,0x4a,0xb1,0x9f,0xb2,0x6a,0xb5,0xbb,0xb4,0x9a,0x8a,0xb0,0xca,0xaf,0xbc,
	0x90,0x8f,0xea,0xfa,0xbe,0xa0,0xb6,0xb3,0x9d,0xda,0x9b,0x8b,0xb7,0xb8,0xb9,0xab,
	0x64,0x65,0x62,0x66,0x63,0x67,0x9e,0x68,0x74,0x71,0x72,0x73,0x78,0x75,0x76,0x77,
	0xac,0x69,0xed,0xee,0xeb,0xef,0xec,0xbf,0x80,0xfd,0xfe,0xfb,0xfc,0xba,0xae,0x59,
	0x44,0x45,0x42,0x46,0x43,0x47,0x9c,0x48,0x54,0x51,0x52,0x53,0x58,0x55,0x56,0x57,
	0x8c,0x49,0xcd,0xce,0xcb,0xcf,0xcc,0xe1,0x70,0xdd,0xde,0xdb,0xdc,0x8d,0x8e,0xdf
	} ;
d966 4
a969 5
	PRIVATE void FixCharacters(void)
	{
	    int c;
	    int work1[256],
		work2[256];
d971 1
a971 11
	    for (c = 0; c < 256; c++) {
		un_IBM1047[IBM1047[c]] = c;
		work1[c] = keymap[c+1];
		work2[c] = key_override[c+1];
	    }
	    for (c = 0; c < 256; c++) {
		keymap      [IBM1047[c]+1] = work1[c];
		key_override[IBM1047[c]+1] = work2[c];
	    }
	}
	#endif /* EBCDIC */
d973 2
a974 3
	PRIVATE int argncmp ARGS2(
		char*,		str,
		char*,		what)
d976 3
a978 7
	    if (str[0] == '-' && str[1] == '-' ) ++str;
	#if OPTNAME_ALLOW_DASHES
	    return strncmp(str, what, strlen(what));
	#else
	    ++str; ++what; /*skip leading dash in both strings*/
	    return !strn_dash_equ(str, what, strlen(what));
	#endif
d980 1
d982 53
a1034 5
	PRIVATE void tildeExpand ARGS2(
		char **,	pathname,
		BOOLEAN,	embedded)
	{
	    char *temp = *pathname;
d1036 9
a1044 9
	    if (embedded) {
		if (temp != NULL) {
		    temp = strstr(*pathname, "/~");
		    if (temp != 0)
			temp++;
		    else
			temp = *pathname;
		}
	    }
d1046 10
a1055 14
	    if (temp != NULL
	     && temp[0] == '~') {
		if (temp[1] == '/'
		 && temp[2] != '\0') {
		    temp = NULL;
		    StrAllocCopy(temp, *pathname + 2);
		    StrAllocCopy(*pathname, wwwName(Home_Dir()));
		    LYAddPathSep(pathname);
		    StrAllocCat(*pathname, temp);
		    FREE(temp);
		} else if (temp[1] == '\0') {
		    StrAllocCopy(*pathname, wwwName(Home_Dir()));
		}
	    }
d1057 14
a1071 13
	PRIVATE BOOL GetStdin ARGS2(
		char **,	buf,
		BOOL,		marker)
	{
	    if (LYSafeGets(buf, stdin) != 0
	     && (!marker || strncmp(*buf, "---", 3) != 0)) {
		LYTrimTrailing(*buf);
		CTRACE((tfp, "...data: %s\n", *buf));
		return TRUE;
	    }
	    CTRACE((tfp, "...mark: %s\n", *buf ? *buf : ""));
	    return FALSE;
	}
d1073 15
a1087 12
	#ifdef WIN32
	PRIVATE BOOL cleanup_win32(DWORD fdwCtrlType)
	{
	    switch (fdwCtrlType) {
	    case CTRL_CLOSE_EVENT:
		cleanup_sig(-1);
		return TRUE;
	    default:
		return FALSE;
	    }
	}
	#endif
d1089 24
a1112 60
	/*
	 * Wow!  Someone wants to start up Lynx.
	 */
	PUBLIC int main ARGS2(
		int,		argc,
		char **,	argv)
	{
	    int  i;		/* indexing variable */
	    int status = 0;	/* exit status */
	    char *temp = NULL;
	    char *cp;
	    FILE *fp;
	    struct stat dir_info;
	    char filename[LY_MAXPATH];
	    BOOL LYGetStdinArgs = FALSE;
	#ifdef _WINDOWS
	    WSADATA WSAData;
	#endif /* _WINDOWS */
	#ifdef USE_SSL
	    char SSLLibraryVersion[256];
	    char *SSLcp;
	#endif /* USE_SSL */

	    /*
	     * Just in case someone has the idea to install lynx set-uid, let's try
	     * to discourage it.
	     */
	#if defined(GETUID) && defined(SETUID)
	    setuid(getuid());
	#endif

	#ifdef    NOT_ASCII
	    FixCharacters();
	#endif /* NOT_ASCII */

	#ifndef DISABLE_FTP
	    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
	    ftp_lasthost = (char *)malloc(sizeof(char));
	    *ftp_lasthost = NULL;
	#endif

	#ifdef EXP_CHARSET_CHOICE
	    memset((char*)charset_subsets, 0, sizeof(charset_subset_t)*MAXCHARSETS);
	#endif

	#ifdef _WINDOWS
	    {
		int err;
		WORD wVerReq;

		wVerReq = MAKEWORD(1, 1);

		err = WSAStartup(wVerReq, &WSAData);
		if (err != 0)
		{
		    printf(gettext("No Winsock found, sorry."));
		    sleep(5);
		    return 1;
		}
	    }
d1114 23
a1136 34
	    /* 1998/09/03 (Thu) 22:02:32 */
	    InitializeCriticalSection(&critSec_DNS);
	    InitializeCriticalSection(&critSec_READ);

	#endif /* _WINDOWS */

	#if defined(__CYGWIN__) && defined(DOSPATH)
	    if (strcmp(ttyname(fileno(stdout)), "/dev/conout") != 0) {
		printf("please \"$CYGWIN=notty\"\n");
		exit(EXIT_SUCCESS);
	    }
	#endif

	#if defined(WIN_EX)
	    /* 1997/10/19 (Sun) 21:40:54 */
	    system_is_NT = (BOOL) is_windows_nt();

	    /* 1998/01/13 (Tue) 21:13:47 */
	    GetWindowsDirectory(filename, sizeof filename);
	    windows_drive[0] = filename[0];
	    windows_drive[1] = filename[1];
	    windows_drive[2] = '\0';
	#endif


	#ifdef __DJGPP__
	    if (LY_get_ctrl_break() == 0) {
		LY_set_ctrl_break(TRUE);
		init_ctrl_break[0] = 0;
	    } else {
		init_ctrl_break[0] = 1;
	    }
	    atexit(reset_break);
	#endif /* __DJGPP__ */
d1138 11
a1148 41
	    /*
	     * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2
	     * we open files and stdout in BINARY mode by default.
	     * Where necessary we should open and (close!) TEXT mode.
	     * (use LYNewTxtFile/LYAppendToTxtFile to open text files for writing)
	     */
	    SetDefaultMode(O_BINARY);
	    SetOutputMode(O_BINARY);

	#ifdef DOSPATH
	    if (getenv("TERM")==NULL) putenv("TERM=vt100");
	#endif

	    LYShowColor = (SHOW_COLOR ? SHOW_COLOR_ON : SHOW_COLOR_OFF);
	    /*
	     *	Set up the argument list.
	     */
	    pgm = argv[0];
	    cp = NULL;
	#ifdef DOSPATH
	    if ((cp = strrchr(pgm, '\\')) != NULL) {
		pgm = cp + 1;
	    } else if (cp == NULL)
	#endif
	    if ((cp = strrchr(pgm, '/')) != NULL) {
		pgm = cp + 1;
	    }

	    /*
	     *	Act on -help NOW, so we only output the help and exit. - FM
	     */
	    for (i = 1; i < argc; i++) {
		if (argncmp(argv[i], "-help") == 0) {
		    parse_arg(&argv[i], 1, &i);
		}
	#ifdef SH_EX
		if (strncmp(argv[i], "-show_cfg", 9) == 0) {
		    show_cfg = TRUE;
		}
	#endif
	    }
d1150 2
a1151 97
	#ifdef LY_FIND_LEAKS
	    /*
	     *	Register the final function to be executed when being exited.
	     *	Will display memory leaks if LY_FIND_LEAKS is defined.
	     */
	    atexit(LYLeaks);
	    /*
	     *	Register the function which will free our allocated globals.
	     */
	    atexit(free_lynx_globals);
	#endif /* LY_FIND_LEAKS */


	#ifdef LOCALE
	    /*
	     *	LOCALE support for international characters.
	     */
	    setlocale(LC_ALL, "");
	#endif /* LOCALE */
	    /* Set the text message domain.  */
	#ifdef HAVE_LIBINTL_H
	#ifndef __DJGPP__
	    bindtextdomain ("lynx", LOCALEDIR);
	#endif /* !__DJGPP__ */
	    textdomain ("lynx");
	#endif /* HAVE_LIBINTL_H */

	    /*
	     *	Initialize our startup and global variables.
	     */
	#ifdef ULTRIX
	    /*
	     *	Need this for Ultrix.
	     */
	    terminal = getenv("TERM");
	    if ((terminal == NULL) || !strncasecomp(terminal, "xterm", 5))
		terminal = "vt100";
	#endif /* ULTRIX */
	    /*
	     *	Zero the links and history struct arrays.
	     */
	    memset((void *)links, 0, sizeof(linkstruct)*MAXLINKS);
	    memset((void *)history, 0, sizeof(histstruct)*MAXHIST);
	    /*
	     *	Zero the MultiBookmark arrays.
	     */
	    memset((void *)MBM_A_subbookmark, 0, sizeof(char)*(MBM_V_MAXFILES+1));
	    memset((void *)MBM_A_subdescript, 0, sizeof(char)*(MBM_V_MAXFILES+1));
	#ifndef VMS
	    StrAllocCopy(list_format, LIST_FORMAT);
	#endif /* !VMS */

	#ifdef HAVE_NAPMS
	#define SECS2Secs(n) (1000 * (n))
	#else
	#define SECS2Secs(n) (n)
	#endif
	    InfoSecs	= SECS2Secs(INFOSECS);
	    MessageSecs = SECS2Secs(MESSAGESECS);
	    AlertSecs	= SECS2Secs(ALERTSECS);

	    StrAllocCopy(helpfile, HELPFILE);
	    StrAllocCopy(startfile, STARTFILE);
	    LYEscapeStartfile(&startfile);
	    StrAllocCopy(indexfile, DEFAULT_INDEX_FILE);
	    StrAllocCopy(global_type_map, GLOBAL_MAILCAP);
	    StrAllocCopy(personal_type_map, PERSONAL_MAILCAP);
	    StrAllocCopy(global_extension_map, GLOBAL_EXTENSION_MAP);
	    StrAllocCopy(personal_extension_map, PERSONAL_EXTENSION_MAP);
	    StrAllocCopy(language, PREFERRED_LANGUAGE);
	    StrAllocCopy(pref_charset, PREFERRED_CHARSET);
	    StrAllocCopy(system_mail, SYSTEM_MAIL);
	    StrAllocCopy(system_mail_flags, SYSTEM_MAIL_FLAGS);
	    StrAllocCopy(LYUserAgent, LYNX_NAME);
	    StrAllocCat(LYUserAgent, "/");
	    StrAllocCat(LYUserAgent, LYNX_VERSION);
	    if (HTLibraryVersion) {
		StrAllocCat(LYUserAgent, " libwww-FM/");
		StrAllocCat(LYUserAgent, HTLibraryVersion);
	    }
	#ifdef USE_SSL
	    StrAllocCat(LYUserAgent, " SSL-MM/1.4.1");
	#ifdef OPENSSL_VERSION_TEXT
	    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
	    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
		*SSLcp++ = '/';
		if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
		    *SSLcp = '\0';
		    StrAllocCat(LYUserAgent, " ");
		    StrAllocCat(LYUserAgent, SSLLibraryVersion);
		}
	    }
	#endif /* OPENSSL_VERSION_TEXT */
	#endif /* USE_SSL */
	    StrAllocCopy(LYUserAgentDefault, LYUserAgent);
	#ifdef VMS
	    Define_VMSLogical("LYNX_VERSION", LYNX_VERSION);
d1161 1
a1161 1
    if ((cp = getenv("LYNX_TEMP_SPACE")) != NULL)
d1163 2
a1164 2
#if defined (UNIX)
    else if ((cp = getenv("TMPDIR")) != NULL)
d1168 4
a1171 4
    else if ((cp = getenv("TEMP")) != NULL)
	StrAllocCopy(lynx_temp_space, HTSYS_name(cp));
    else if ((cp = getenv("TMP")) != NULL)
	StrAllocCopy(lynx_temp_space, HTSYS_name(cp));
d1191 1
a1191 1
	if ((cp1 = getenv("USER")) != NULL) {
a1203 1

d1222 1
d1226 1
a1226 1
#ifdef UNIX
a1236 6
#ifdef VMS
#ifdef CSWING_PATH
    StrAllocCopy(LYCSwingPath, CSWING_PATH);
#endif /* CSWING_PATH */
#endif /* VMS */

d1278 1
a1278 1
    if (getenv("LYNX_TRACE") != 0) {
d1362 1
a1362 1
	!strcasecomp((getenv("USER")==NULL ? " " : getenv("USER")),
d1365 1
a1365 1
#if HAVE_CUSERID
d1380 3
a1382 7
#ifdef FNAMES_8_3
    LYAddPathToHome(LYTraceLogPath =
		malloc(LY_MAXPATH), LY_MAXPATH, "LY-TRACE.LOG");
#else
    LYAddPathToHome(LYTraceLogPath =
		malloc(LY_MAXPATH), LY_MAXPATH, "Lynx.trace");
#endif
d1424 2
a1425 2
	if (((cp=getenv("LYNX_CFG")) != NULL) ||
	    (cp=getenv("lynx_cfg")) != NULL)
d1494 2
a1495 2
	if (((cp=getenv("LYNX_LSS")) != NULL) ||
	    (cp=getenv("lynx_lss")) != NULL)
d1533 1
a1533 1
	if ((cp = getenv("PWD")) != 0)
d1567 4
d1574 1
a1574 1
    if ((cp = getenv("WWW_HOME")) != NULL) {
a1584 1
    LYFillLocalFileURL((char **)&LynxHome, "file://localhost");
a1612 18
#undef TTY_DEVICE
#undef NUL_DEVICE

#ifdef VMS
#define TTY_DEVICE "tt:"
#define NUL_DEVICE "nl:"
#endif

#ifdef _WINDOWS
#define TTY_DEVICE "con"
#define NUL_DEVICE "nul"
#endif

#ifndef TTY_DEVICE
#define TTY_DEVICE "/dev/tty"
#define NUL_DEVICE "/dev/null"
#endif

d1664 1
a1664 1
#ifdef EXP_PERSISTENT_COOKIES
d1692 1
a1692 1
		StrAllocCopy(LYCookieSaveFile, "/dev/null");
d1694 1
a1694 1
		StrAllocCopy(LYCookieSaveFile, LYCookieFile);
d1712 1
a1712 1
    if ((cp=getenv("LYNX_SAVE_SPACE")) != NULL)
d1770 1
a1770 1
	       getenv("COLORTERM") != NULL) {
d1805 1
a1805 1
    if (keypad_mode == NUMBERS_AS_ARROWS) {
d1848 1
a1848 1
#ifdef SOURCE_CACHE
d1888 2
a1890 1
#ifndef NOSIGHUP
a1983 1
    LYFillLocalFileURL((char **)&startfile, "file://localhost");
a1991 1
	LYFillLocalFileURL((char **)&homepage, "file://localhost");
d2065 1
a2065 1
	    if (keypad_mode == NUMBERS_AS_ARROWS) {
d2082 1
a2082 2
	    (keypad_mode == LINKS_ARE_NUMBERED ||
	     keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED))
d2084 1
a2084 1
#ifdef EXP_PERSISTENT_COOKIES
d2092 1
a2092 1
#endif /* EXP_PERSISTENT_COOKIES */
d2120 9
d2234 1
a2234 1
#ifdef EXP_PERSISTENT_COOKIES
d2255 1
a2255 1
#ifdef SOURCE_CACHE
d2302 1
a2302 1
#ifdef EXP_PERSISTENT_COOKIES
d2326 15
d2370 1
d2375 1
d2612 1
a2612 2
    dump_output_immediately = TRUE;
    LYcols = DFT_COLS;
d2671 1
a2671 2
    dump_output_immediately = TRUE;
    LYcols = DFT_COLS;
d2700 7
d2708 1
a2708 7
	if (strncasecomp(next_arg, "merge", 1) == 0)
	    LYHiddenLinks = HIDDENLINKS_MERGE;
	else if (strncasecomp(next_arg, "listonly", 1) == 0)
	    LYHiddenLinks = HIDDENLINKS_SEPARATE;
	else if (strncasecomp(next_arg, "ignore", 1) == 0)
	    LYHiddenLinks = HIDDENLINKS_IGNORE;
	else
d2736 1
a2736 1
    dump_output_immediately = TRUE;
d2809 1
a2809 3
    InfoSecs = 0;
    MessageSecs = 0;
    AlertSecs = 0;
d2870 1
a2870 2
    dump_output_immediately = TRUE;
    LYcols = DFT_COLS;
d2885 19
d2921 5
d2930 1
a2930 1
{ "default", "\
d2987 2
d3037 1
a3037 1
    if (next_arg == 0 || *next_arg == '\0') {
d3047 1
a3047 11
		switch (find_restriction(table[j].name, -1)) {
		case TRUE:
		    value = "on";
		    break;
		case FALSE:
		    value = "off";
		    break;
		default:
		    value = "?";
		    break;
		}
d3067 3
a3069 2
		printf("%s%s", column ? ", " : "  ", name);
		column += 2 + strlen(name);
d3104 1
a3104 1
    dump_output_immediately = TRUE;
d3129 1
a3129 4
#ifdef USE_SSL
    char SSLLibraryVersion[256];
    char *SSLcp;
#endif
d3133 3
a3135 3
    printf(gettext("%s Version %s (%s)\n"),
	  LYNX_NAME, LYNX_VERSION,
	  LYVersionDate());
d3137 3
a3139 12
    printf("libwww-FM %s, SSL-MM 1.4.1", HTLibraryVersion);
#ifdef OPENSSL_VERSION_TEXT
    LYstrncpy(SSLLibraryVersion, OPENSSL_VERSION_TEXT, sizeof(SSLLibraryVersion)-1);
    if ((SSLcp = strchr(SSLLibraryVersion, ' ')) != NULL) {
	*SSLcp++ = ' ';
	if ((SSLcp = strchr(SSLcp, ' ')) != NULL) {
	    *SSLcp = '\0';
	    printf(", %s", SSLLibraryVersion);
	}
    }
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
d3141 2
a3143 1
#ifdef SYSTEM_NAME
d3150 6
d3157 1
a3157 19
#endif

    printf("\n");
    printf(gettext(
	  "Copyrights held by the University of Kansas, CERN, and other contributors.\n"
	  ));
    printf(gettext("Distributed under the GNU General Public License.\n"));
    printf(gettext(
	  "See http://lynx.browser.org/ and the online help for more information.\n\n"
	  ));
#ifdef USE_SSL
    printf("See http://www.moxienet.com/lynx/ for information about SSL for Lynx.\n");
#ifdef OPENSSL_VERSION_TEXT
    printf("See http://www.openssl.org/ for information about OpenSSL.\n");
#endif /* OPENSSL_VERSION_TEXT */
    printf("\n");
#endif /* USE_SSL */

#ifdef SH_EX
d3175 17
a3191 1
#endif /* SH_EX */
d3213 28
a3299 1
#ifdef SH_EX
d3302 1
a3302 1
      "Toggle center alignment in HTML TABLE"
a3303 1
#endif
a3327 1
#ifndef __DJGPP__
a3331 1
#endif
d3338 1
a3338 1
#ifdef EXP_PERSISTENT_COOKIES
d3347 1
a3347 1
#endif /* EXP_PERSISTENT_COOKIES */
a3374 1
#if defined(SH_EX) && defined(WIN_EX)
d3376 2
a3377 2
      "delay",		4|NEED_INT_ARG,		debug_delay,
      "=NNN\nset the NNN msec delay at statusline message"
a3378 1
#endif
d3427 6
d3529 6
d3585 1
a3585 1
#if HAVE_SIGACTION && defined(SIGWINCH)
d3708 6
d3716 1
a3716 1
      "scrollbar",	4|TOGGLE_ARG,		LYsb,
d3742 1
a3742 1
#ifdef EXP_READPROGRESS
d3824 4
d3961 3
d4187 9
d4197 1
a4197 1
	     if ((q->str_value != 0) && (next_arg != 0))
d4199 1
a4199 1
	     break;
@


1.9
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d177 2
d891 6
@


1.8
log
@Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d10 1
d16 1
d32 5
d41 2
a48 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */

d79 4
a83 1
PUBLIC char *mail_adrs = NULL;	/* the mask for a VMS mail transport */
d115 1
d149 1
a149 1
PUBLIC lynx_printer_item_type *printers = NULL;
d151 1
a151 1
PUBLIC lynx_html_item_type *downloaders = NULL;
d154 1
a154 1
PUBLIC lynx_html_item_type *externals = NULL;
d157 1
a157 1
PUBLIC lynx_html_item_type *uploaders = NULL;
d159 2
a160 3
PUBLIC int LYShowColor = SHOW_COLOR_UNKNOWN; /* to show or not to show */
PUBLIC int LYChosenShowColor = SHOW_COLOR_UNKNOWN; /* whether to show and save */
PUBLIC int LYrcShowColor = SHOW_COLOR_UNKNOWN;	/* ... as last read or written */
d171 1
a171 1
PUBLIC BOOLEAN LYshow_kb_rate = TRUE;
a176 2
PUBLIC BOOLEAN ftp_local_passive;    /* TRUE for PASV for this server only */
PUBLIC char *ftp_lasthost;           /* host of last ftp transaction */
d190 1
a190 1
PUBLIC BOOLEAN LYRestricted = FALSE;
d200 1
d206 1
d209 5
a213 17
#ifdef USE_EXTERNALS
PUBLIC BOOLEAN no_externals = FALSE;
#endif
PUBLIC BOOLEAN no_inside_telnet = FALSE;
PUBLIC BOOLEAN no_outside_telnet = FALSE;
PUBLIC BOOLEAN no_telnet_port = FALSE;
#ifndef DISABLE_NEWS
PUBLIC BOOLEAN no_inside_news = FALSE;
PUBLIC BOOLEAN no_outside_news = FALSE;
#endif
PUBLIC BOOLEAN no_inside_ftp = FALSE;
PUBLIC BOOLEAN no_outside_ftp = FALSE;
PUBLIC BOOLEAN no_inside_rlogin = FALSE;
PUBLIC BOOLEAN no_outside_rlogin = FALSE;
PUBLIC BOOLEAN no_suspend = FALSE;
PUBLIC BOOLEAN no_editor = FALSE;
PUBLIC BOOLEAN no_shell = FALSE;
a214 1
PUBLIC BOOLEAN no_multibook = FALSE;
d216 3
a218 2
PUBLIC BOOLEAN no_option_save = FALSE;
PUBLIC BOOLEAN no_print = FALSE;
d220 1
a220 1
PUBLIC BOOLEAN no_disk_save = FALSE;
d222 1
a222 2
PUBLIC BOOLEAN no_lynxcgi = FALSE;
PUBLIC BOOLEAN exec_frozen = FALSE;
d224 1
a235 4
#ifndef DISABLE_NEWS
PUBLIC BOOLEAN no_goto_news = FALSE;
PUBLIC BOOLEAN no_goto_nntp = FALSE;
#endif
a236 3
#ifndef DISABLE_NEWS
PUBLIC BOOLEAN no_goto_snews = FALSE;
#endif
d240 3
d244 14
a257 1
PUBLIC BOOLEAN no_file_url = FALSE;
d259 4
d264 5
d270 8
a277 3
PUBLIC BOOLEAN no_mail = FALSE;
PUBLIC BOOLEAN no_dotfiles = NO_DOT_FILES;
PUBLIC BOOLEAN no_useragent = FALSE;
d279 2
a280 1
PUBLIC BOOLEAN no_filereferer = FALSE;
d283 1
a283 1
PUBLIC BOOLEAN show_dotfiles = FALSE; /* From rcfile if no_dotfiles is false */
d285 49
a333 25
PUBLIC char *editor = NULL;	/* the name of the current editor */
PUBLIC char *jumpfile = NULL;	/* the name of the default jumps file */
PUBLIC char *jumpprompt = NULL; /* the default jumps prompt */
PUBLIC char *bookmark_page = NULL; /* the name of the default bookmark page */
PUBLIC char *BookmarkPage = NULL;  /* the name of the current bookmark page */
PUBLIC char *LynxHome = NULL;	/* the default Home HREF. */
PUBLIC char *homepage = NULL;  /* home page or main screen */
PUBLIC char *original_dir = NULL; /* the original directory */
PUBLIC char *startfile = NULL;	/* the first file */
PUBLIC char *helpfile = NULL;	/* the main help file */
PUBLIC char *helpfilepath = NULL;   /* the path to the help file set */
PUBLIC char *lynxjumpfile = NULL;   /* the current jump file URL */
PUBLIC char *lynxlistfile = NULL;   /* the current list file URL */
PUBLIC char *lynxlinksfile = NULL;  /* the current visited links file URL */
PUBLIC char *startrealm = NULL;     /* the startfile realm */
PUBLIC char *indexfile = NULL;	    /* an index file if there is one */
PUBLIC int outgoing_mail_charset = -1;     /* translate mail to this charset */
PUBLIC char *personal_mail_address = NULL; /* the users mail address */
PUBLIC char *x_display = NULL;	    /* display environment variable */
PUBLIC char *personal_type_map = NULL;	   /* .mailcap */
PUBLIC char *global_type_map = NULL;	   /* global mailcap */
PUBLIC char *global_extension_map = NULL;  /* global mime.types */
PUBLIC char *personal_extension_map = NULL;/* .mime.types */
PUBLIC char *language = NULL;	    /* preferred language */
PUBLIC char *pref_charset = NULL;   /* preferred character set */
d335 3
a337 29
PUBLIC char *LynxSigFile = NULL;    /* Signature file, in or off home */
PUBLIC char *system_mail = NULL;	  /* The path for sending mail */
PUBLIC char *system_mail_flags = NULL;	  /* Flags for sending mail */
PUBLIC char *lynx_cfg_file = NULL;	  /* location of active lynx.cfg */
PUBLIC char *lynx_temp_space = NULL; /* The prefix for temporary file paths */
PUBLIC char *lynx_save_space = NULL; /* The prefix for save to disk paths */
PUBLIC char *LYHostName = NULL;		/* treat as a local host name */
PUBLIC char *LYLocalDomain = NULL;	/* treat as a local domain tail */
PUBLIC BOOLEAN clickable_images = MAKE_LINKS_FOR_ALL_IMAGES;
PUBLIC BOOLEAN pseudo_inline_alts = MAKE_PSEUDO_ALTS_FOR_INLINES;
PUBLIC BOOLEAN crawl = FALSE;	     /* Do crawl? */
PUBLIC BOOLEAN traversal = FALSE;    /* Do traversals? */
PUBLIC BOOLEAN check_realm = FALSE;  /* Restrict to the starting realm? */
	       /* Links beyond a displayed page with no links? */
PUBLIC BOOLEAN more_links = FALSE;
PUBLIC int     ccount = 0; /* Starting number for lnk#.dat files in crawls */
PUBLIC BOOLEAN LYCancelledFetch = FALSE; /* TRUE if cancelled binary fetch */
	       /* Include mime headers with source dump */
PUBLIC BOOLEAN keep_mime_headers = FALSE;
PUBLIC BOOLEAN no_url_redirection = FALSE; /* Don't follow URL redirections */
PUBLIC char *form_post_data = NULL;  /* User data for post form */
PUBLIC char *form_get_data = NULL;   /* User data for get form */
PUBLIC char *http_error_file = NULL; /* Place HTTP status code in this file */
	     /* Id:Password for protected documents */
PUBLIC char *authentication_info[2] = {NULL, NULL};
	     /* Id:Password for protected proxy servers */
PUBLIC char *proxyauth_info[2] = {NULL, NULL};
PUBLIC BOOLEAN HEAD_request = FALSE;
PUBLIC BOOLEAN scan_for_buried_news_references = TRUE;
d339 3
a341 1
PUBLIC BOOLEAN LYDefaultRawMode;
d343 3
a345 1
PUBLIC char *UCAssume_MIMEcharset = NULL;
a346 12
PUBLIC BOOLEAN UCForce8bitTOUPPER = FALSE; /* override locale for case-conversion? */
PUBLIC int LYlines = 24;
PUBLIC int LYcols = 80;
PUBLIC int dump_output_width = 0;
PUBLIC linkstruct links[MAXLINKS];
PUBLIC histstruct history[MAXHIST];
PUBLIC int nlinks = 0;		/* number of links in memory */
PUBLIC int nhist = 0;		/* number of history entries */
PUBLIC int more = FALSE;	/* is there more text to display? */
PUBLIC int InfoSecs;	/* Seconds to sleep() for Information messages */
PUBLIC int MessageSecs; /* Seconds to sleep() for important Messages   */
PUBLIC int AlertSecs;	/* Seconds to sleep() for HTAlert() messages   */
d348 9
a356 11
PUBLIC char *LYUserAgent = NULL;	/* Lynx User-Agent header	   */
PUBLIC char *LYUserAgentDefault = NULL; /* Lynx default User-Agent header  */
PUBLIC BOOLEAN LYUseMouse = FALSE;
PUBLIC BOOLEAN LYNoRefererHeader=FALSE; /* Never send Referer header?	   */
PUBLIC BOOLEAN LYNoRefererForThis=FALSE;/* No Referer header for this URL? */
PUBLIC BOOLEAN LYNoFromHeader = TRUE;	/* Never send From header?	   */
PUBLIC BOOLEAN LYListNewsNumbers = LIST_NEWS_NUMBERS;
PUBLIC BOOLEAN LYListNewsDates = LIST_NEWS_DATES;
PUBLIC BOOLEAN LYisConfiguredForX = FALSE;
PUBLIC char *URLDomainPrefixes = NULL;
PUBLIC char *URLDomainSuffixes = NULL;
d358 3
a360 9
PUBLIC BOOLEAN LYSelectPopups = USE_SELECT_POPUPS;
PUBLIC BOOLEAN LYUseDefSelPop = TRUE;	/* Command line -popup toggle */
PUBLIC BOOLEAN LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
PUBLIC BOOLEAN LYMBMBlocked = BLOCK_MULTI_BOOKMARKS;
PUBLIC BOOLEAN LYMBMAdvanced = TRUE;
PUBLIC int LYStatusLine = -1;		 /* Line for statusline() if > -1 */
PUBLIC BOOLEAN LYCollapseBRs = COLLAPSE_BR_TAGS;  /* Collapse serial BRs? */
PUBLIC BOOLEAN LYSetCookies = SET_COOKIES; /* Process Set-Cookie headers? */
PUBLIC BOOLEAN LYAcceptAllCookies = ACCEPT_ALL_COOKIES; /* take all cookies? */
a361 2
PUBLIC char *LYCookieRejectDomains = NULL; /* domains to reject all cookies */
PUBLIC char *LYCookieStrictCheckDomains = NULL; /* check strictly  */
d364 1
d366 2
d370 68
a437 2
PUBLIC char *LYCookieSLooseCheckDomains = NULL;  /* check loosely   */
PUBLIC char *LYCookieSQueryCheckDomains = NULL;  /* check w/a query */
d439 3
a441 2
BOOLEAN persistent_cookies = TRUE;
PUBLIC char *LYCookieFile = NULL;	   /* default cookie file */
d443 14
d461 4
a464 1
PUBLIC BOOL Old_DTD = NO;
d466 1
d469 1
a471 1

d475 1
a475 1
PUBLIC BOOLEAN LYPreparsedSource = FALSE;	/* Show source as preparsed?	 */
d479 25
d511 7
a517 5
/* These are declared in cutil.h for current freeWAIS libraries. - FM */
#ifdef DECLARE_WAIS_LOGFILES
PUBLIC char *log_file_name = NULL; /* for WAIS log file name	in libWWW */
PUBLIC FILE *logfile = NULL;	   /* for WAIS log file output	in libWWW */
#endif /* DECLARE_WAIS_LOGFILES */
d524 2
d530 1
d539 12
d555 3
a557 3

PRIVATE void parse_arg PARAMS((char **arg, int *i));
PRIVATE void print_help_and_exit PARAMS((int exit_status));
d561 1
d565 2
a566 2
#if defined(USE_HASH)
    char *lynx_lss_file=NULL;
d570 1
a570 1
PRIVATE int LY_set_ctrl_break(int setting)
d591 14
a622 1
    FREE(mail_adrs);
d626 4
d651 4
d657 1
d689 15
a703 12
    FREE(lynx_temp_space);
    FREE(LYTraceLogPath);
    FREE(lynx_cfg_file);
#if defined(USE_HASH)
    FREE(lynx_lss_file);
#endif
    FREE(UCAssume_MIMEcharset);
    {
	char *p = LYlist_temp_url();
	if (p && *p) {
	    *p = '\0';
	    FREE(p);
d705 12
a716 5
    }
    for (i = 0; i < nlinks; i++) {
	FREE(links[i].lname);
    }
    nlinks = 0;
d718 7
a724 3
    return;
}
#endif /* LY_FIND_LEAKS */
d726 16
a741 7
/*
 *  This function frees the LYStdinArgs list. - FM
 */
PRIVATE void LYStdinArgs_free NOARGS
{
    char *argument;
    HTList *cur = LYStdinArgs;
d743 21
a763 2
    if (cur == NULL)
	return;
d765 17
a781 7
    while (NULL != (argument = (char *)HTList_nextObject(cur))) {
	FREE(argument);
    }
    HTList_delete(LYStdinArgs);
    LYStdinArgs = NULL;
    return;
}
d783 12
a794 16
PUBLIC void exit_immediately ARGS1(
	int,		code)
{
#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
    if (no_suspend)
	(void) signal(SIGTSTP, SIG_DFL);
#endif /* SIGTSTP */
    exit(code);
}
d796 5
a800 21
#ifdef  EBCDIC
      char un_IBM1047[ 256 ] = "";
unsigned char IBM1047[ 256 ] = /* ATOE OEMVS311 */
{
0x00,0x01,0x02,0x03,0x37,0x2d,0x2e,0x2f,0x16,0x05,0x15,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x3c,0x3d,0x32,0x26,0x18,0x19,0x3f,0x27,0x1c,0x1d,0x1e,0x1f,
0x40,0x5a,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xad,0xe0,0xbd,0x5f,0x6d,
0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x4f,0xd0,0xa1,0x07,
0x20,0x21,0x22,0x23,0x24,0x25,0x06,0x17,0x28,0x29,0x2a,0x2b,0x2c,0x09,0x0a,0x1b,
0x30,0x31,0x1a,0x33,0x34,0x35,0x36,0x08,0x38,0x39,0x3a,0x3b,0x04,0x14,0x3e,0xff,
0x41,0xaa,0x4a,0xb1,0x9f,0xb2,0x6a,0xb5,0xbb,0xb4,0x9a,0x8a,0xb0,0xca,0xaf,0xbc,
0x90,0x8f,0xea,0xfa,0xbe,0xa0,0xb6,0xb3,0x9d,0xda,0x9b,0x8b,0xb7,0xb8,0xb9,0xab,
0x64,0x65,0x62,0x66,0x63,0x67,0x9e,0x68,0x74,0x71,0x72,0x73,0x78,0x75,0x76,0x77,
0xac,0x69,0xed,0xee,0xeb,0xef,0xec,0xbf,0x80,0xfd,0xfe,0xfb,0xfc,0xba,0xae,0x59,
0x44,0x45,0x42,0x46,0x43,0x47,0x9c,0x48,0x54,0x51,0x52,0x53,0x58,0x55,0x56,0x57,
0x8c,0x49,0xcd,0xce,0xcb,0xcf,0xcc,0xe1,0x70,0xdd,0xde,0xdb,0xdc,0x8d,0x8e,0xdf
} ;
d802 9
a810 5
static void FixCharacters(void)
{
    int c;
    int work1[256],
	work2[256];
d812 15
a826 11
    for (c = 0; c < 256; c++) {
	un_IBM1047[IBM1047[c]] = c;
	work1[c] = keymap[c+1];
	work2[c] = key_override[c+1];
    }
    for (c = 0; c < 256; c++) {
	keymap      [IBM1047[c]+1] = work1[c];
	key_override[IBM1047[c]+1] = work2[c];
    }
}
#endif /* EBCDIC */
d828 13
a840 8
/* these are used for matching commandline options. */
PRIVATE int argcmp ARGS2(
	char*,		str,
	char*,		what)
{
    if (str[0] == '-' && str[1] == '-' ) ++str;
    return strcmp(str,what);
}
d842 12
a853 7
PRIVATE int argncmp ARGS2(
	char*,		str,
	char*,		what)
{
    if (str[0] == '-' && str[1] == '-' ) ++str;
    return strncmp(str, what, strlen(what));
}
d855 22
a876 24
/*
 * Wow!  Someone wants to start up Lynx.
 */
PUBLIC int main ARGS2(
	int,		argc,
	char **,	argv)
{
    int  i;		/* indexing variable */
    int status = 0;	/* exit status */
    char *temp = NULL;
    char *cp;
    FILE *fp;
    char filename[LY_MAXPATH];
    BOOL LYGetStdinArgs = FALSE;

#ifndef DISABLE_FTP
    /* malloc a sizeof(char) so 1st strcmp() won't dump in HTLoadFile() */
    ftp_lasthost = (char *)malloc(sizeof(char));
    *ftp_lasthost = NULL;
#endif /* DISABLE_FTP */

#ifdef    NOT_ASCII
    FixCharacters();
#endif /* NOT_ASCII */
d878 31
a908 5
#ifdef _WINDOWS
    WSADATA WSAData;
    {
	int err;
	WORD wVerReq;
d910 12
a921 1
	wVerReq = MAKEWORD(1,1);
d923 21
a943 9
	err = WSAStartup(wVerReq, &WSAData);
	if (err != 0)
	{
	    printf(gettext("No Winsock found, sorry."));
	    sleep(5);
	    return;
	}
    }
#endif /* _WINDOWS */
d945 8
a952 11
#ifdef __DJGPP__
    if (LY_get_ctrl_break() == 0) {
	LY_set_ctrl_break(TRUE);
	init_ctrl_break[0] = 0;
    } else {
	init_ctrl_break[0] = 1;
    }
    atexit(reset_break);
    dbug_init();
    sock_init();
#endif
d954 3
a956 8
    /*
     * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2
     * we open files and stdout in BINARY mode by default.
     * Where necessary we should open and (close!) TEXT mode.
     * (use LYNewTxtFile/LYAppendToTxtFile to open text files for writing)
     */
    SetDefaultMode(O_BINARY);
    SetOutputMode(O_BINARY);
d958 14
a971 3
#ifdef DOSPATH
    if (getenv("TERM")==NULL) putenv("TERM=vt100");
#endif
d973 13
a985 8
    LYShowColor = (SHOW_COLOR ? SHOW_COLOR_ON : SHOW_COLOR_OFF);
    /*
     *	Set up the argument list.
     */
    pgm = argv[0];
    if ((cp = strrchr(pgm, '/')) != NULL) {
	pgm = cp + 1;
    }
d987 11
a997 8
    /*
     *	Act on -help NOW, so we only output the help and exit. - FM
     */
    for (i = 1; i < argc; i++) {
	if (argncmp(argv[i], "-help") == 0) {
	    parse_arg(&argv[i], &i);
	}
    }
a998 11
#ifdef LY_FIND_LEAKS
    /*
     *	Register the final function to be executed when being exited.
     *	Will display memory leaks if LY_FIND_LEAKS is defined.
     */
    atexit(LYLeaks);
    /*
     *	Register the function which will free our allocated globals.
     */
    atexit(free_lynx_globals);
#endif /* LY_FIND_LEAKS */
d1000 13
d1014 70
a1083 66
#ifdef LOCALE
    /*
     *	LOCALE support for international characters.
     */
    setlocale(LC_ALL, "");
#endif /* LOCALE */
    /* Set the text message domain.  */
#ifdef HAVE_LIBINTL_H
#ifndef __DJGPP__
    bindtextdomain ("lynx", LOCALEDIR);
#endif /* !__DJGPP__ */
    textdomain ("lynx");
#endif /* HAVE_LIBINTL_H */

    /*
     *	Initialize our startup and global variables.
     */
#ifdef ULTRIX
    /*
     *	Need this for Ultrix.
     */
    terminal = getenv("TERM");
    if ((terminal == NULL) || !strncasecomp(terminal, "xterm", 5))
	terminal = "vt100";
#endif /* ULTRIX */
    /*
     *	Zero the links and history struct arrays.
     */
    memset((void *)links, 0, sizeof(linkstruct)*MAXLINKS);
    memset((void *)history, 0, sizeof(histstruct)*MAXHIST);
    /*
     *	Zero the MultiBookmark arrays.
     */
    memset((void *)MBM_A_subbookmark, 0, sizeof(char)*(MBM_V_MAXFILES+1));
    memset((void *)MBM_A_subdescript, 0, sizeof(char)*(MBM_V_MAXFILES+1));
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif /* SYSLOG_REQUESTED_URLS */
    StrAllocCopy(list_format, LIST_FORMAT);
#endif /* !VMS */
    InfoSecs	= (int)INFOSECS;
    MessageSecs = (int)MESSAGESECS;
    AlertSecs	= (int)ALERTSECS;
    StrAllocCopy(helpfile, HELPFILE);
    StrAllocCopy(startfile, STARTFILE);
    LYEscapeStartfile(&startfile); 
    StrAllocCopy(indexfile, DEFAULT_INDEX_FILE);
    StrAllocCopy(global_type_map, GLOBAL_MAILCAP);
    StrAllocCopy(personal_type_map, PERSONAL_MAILCAP);
    StrAllocCopy(global_extension_map, GLOBAL_EXTENSION_MAP);
    StrAllocCopy(personal_extension_map, PERSONAL_EXTENSION_MAP);
    StrAllocCopy(language, PREFERRED_LANGUAGE);
    StrAllocCopy(pref_charset, PREFERRED_CHARSET);
    StrAllocCopy(system_mail, SYSTEM_MAIL);
    StrAllocCopy(system_mail_flags, SYSTEM_MAIL_FLAGS);
    StrAllocCopy(LYUserAgent, LYNX_NAME);
    StrAllocCat(LYUserAgent, "/");
    StrAllocCat(LYUserAgent, LYNX_VERSION);
    if (HTLibraryVersion) {
	StrAllocCat(LYUserAgent, " libwww-FM/");
	StrAllocCat(LYUserAgent, HTLibraryVersion);
    }
    StrAllocCopy(LYUserAgentDefault, LYUserAgent);
#ifdef VMS
    Define_VMSLogical("LYNX_VERSION", LYNX_VERSION);
d1101 1
a1101 1
	StrAllocCopy(lynx_temp_space, HTDOS_name(cp));
d1103 1
a1103 1
	StrAllocCopy(lynx_temp_space, HTDOS_name(cp));
d1111 1
a1111 1
	exit(-1);
d1115 5
a1119 9
    if ((cp = strchr(lynx_temp_space, '~'))) {
	*(cp++) = '\0';
	StrAllocCopy(temp, lynx_temp_space);
	LYTrimPathSep(temp);
	StrAllocCat(temp, wwwName(Home_Dir()));
	StrAllocCat(temp, cp);
	StrAllocCopy(lynx_temp_space, temp);
	FREE(temp);
    }
d1123 1
a1123 1
	if ((cp1 = (char *)getenv("USER")) != NULL) {
d1134 1
a1134 1
    StrAllocCat(lynx_temp_space, "/lynx-XXXXXX");
d1136 1
d1156 13
a1169 1
    StrAllocCopy(mail_adrs, MAIL_ADRS);
d1174 8
d1187 1
d1193 5
d1205 1
a1205 1
    no_newspost = (LYNewsPosting == FALSE);
d1215 5
d1221 1
a1221 41
	if (argncmp(argv[i], "-trace") == 0) {
	    WWW_TraceFlag = TRUE;
	} else if (argncmp(argv[i], "-tlog") == 0) {
	    if (LYUseTraceLog) {
		LYUseTraceLog = FALSE;
	    } else {
		LYUseTraceLog = TRUE;
	    }
	} else if (argncmp(argv[i], "-anonymous") == 0) {
	    if (!LYValidate)
		parse_restrictions("default");
	    LYRestricted = TRUE;
	} else if (argcmp(argv[i], "-validate") == 0) {
	    /*
	     *	Follow only http URLs.
	     */
	    LYValidate = TRUE;
#ifdef SOCKS
	} else if (argncmp(argv[i], "-nosocks") == 0) {
	    socks_flag = FALSE;
#endif /* SOCKS */
	} else if (argncmp(argv[i], "-cfg") == 0) {
	    if ((cp=strchr(argv[i],'=')) != NULL)
		StrAllocCopy(lynx_cfg_file, cp+1);
	    else {
		StrAllocCopy(lynx_cfg_file, argv[i+1]);
		i++;
	    }

#if defined(USE_HASH)
	} else if (argncmp(argv[i], "-lss") == 0) {
	    if ((cp=strchr(argv[i],'=')) != NULL)
		StrAllocCopy(lynx_lss_file, cp+1);
	    else {
		StrAllocCopy(lynx_lss_file, argv[i+1]);
		i++;
	    }
	    CTRACE(tfp, "LYMain found -lss flag, lss file is %s\n",
		    lynx_lss_file ? lynx_lss_file : "<NONE>");
#endif
	}
d1236 1
a1236 1
     *	-post_data, the data are terminate by a "___" string, alone
d1242 1
d1248 7
a1254 72
	while (LYSafeGets(&buf, stdin) != 0) {
	    int j;

	    for (j = strlen(buf) - 1; j > 0 &&
		(buf[j] == CR || buf[j] == LF); j--) {
		buf[j] = '\0';
	    }

	    if (argncmp(buf, "-trace") == 0) {
		WWW_TraceFlag = TRUE;
	    } else if (argncmp(buf, "-tlog") == 0) {
		if (LYUseTraceLog) {
		    LYUseTraceLog = FALSE;
		} else {
		    LYUseTraceLog = TRUE;
		}
	    } else if (argncmp(buf, "-anonymous") == 0) {
		if (!LYValidate && !LYRestricted)
		    parse_restrictions("default");
		LYRestricted = TRUE;
	    } else if (argcmp(buf, "-validate") == 0) {
		/*
		 *  Follow only http URLs.
		 */
		LYValidate = TRUE;
#ifdef SOCKS
	    } else if (argncmp(buf, "-nosocks") == 0) {
		socks_flag = FALSE;
#endif /* SOCKS */
	    } else if (argncmp(buf, "-cfg") == 0) {
		if ((cp = strchr(buf,'=')) != NULL) {
		    StrAllocCopy(lynx_cfg_file, cp+1);
		} else {
		    cp = LYSkipNonBlanks(buf);
		    cp = LYSkipBlanks(cp);
		    if (*cp)
			StrAllocCopy(lynx_cfg_file, cp);
		}
#if defined(USE_HASH)
	    } else if (argncmp(buf, "-lss") == 0) {
		if ((cp = strchr(buf,'=')) != NULL) {
		    StrAllocCopy(lynx_lss_file, cp+1);
		} else {
		    cp = LYSkipNonBlanks(buf);
		    cp = LYSkipBlanks(cp);
		    if (*cp)
			StrAllocCopy(lynx_lss_file, cp);
		}
		CTRACE(tfp, "LYMain found -lss flag, lss file is %s\n",
			lynx_lss_file ? lynx_lss_file : "<NONE>");
#endif
	    } else if (argcmp(buf, "-get_data") == 0) {
		/*
		 *  User data for GET form.
		 */
		char **get_data;

		/*
		 *  On Unix, conflicts with curses when interactive
		 *  so let's force a dump.  - CL
		 *
		 *  On VMS, mods have been made in LYCurses.c to deal
		 *  with potential conflicts, so don't force the dump
		 *  here. - FM
		 */
#ifndef VMS
		dump_output_immediately = TRUE;
		LYcols = 80;
#endif /* VMS */

		StrAllocCopy(form_get_data, "?");   /* Prime the pump */
		get_data = &form_get_data;
d1256 2
a1257 56
		/*
		 *  Build GET data for later.  Stop reading when we see
		 *  a line with "---" as its first three characters.
		 */
		while (LYSafeGets(&buf, stdin) != 0 &&
		       strncmp(buf, "---", 3) != 0) {
		    int j2;

		    /*
		     *	Strip line terminators.
		     */
		    for (j2 = strlen(buf) - 1; j2 >= 0 &&
			 (buf[j2] == CR || buf[j2] == LF); j2--) {
			buf[j2] = '\0';
		    }
		    StrAllocCat(*get_data, buf);
		}
	    } else if (argcmp(buf, "-post_data") == 0) {
		/*
		 *  User data for POST form.
		 */
		char **post_data;

		/*
		 *  On Unix, conflicts with curses when interactive
		 *  so let's force a dump.  - CL
		 *
		 *  On VMS, mods have been made in LYCurses.c to deal
		 *  with potential conflicts, so don't force a dump
		 *  here. - FM
		 */
#ifndef VMS
		dump_output_immediately = TRUE;
		LYcols = 80;
#endif /* VMS */

		post_data = &form_post_data;

		/*
		 *  Build post data for later.	Stop reading when we see
		 *  a line with "---" as its first three characters.
		 */
		while (LYSafeGets(&buf, stdin) != 0 &&
		       strncmp(buf, "---", 3) != 0) {
		    int j2;

		     /*
		      *  Strip line terminators.
		      */
		    for (j2 = strlen(buf) - 1; j2 >= 0 &&
			 (buf[j2] == CR || buf[j2] == LF); j2--) {
			buf[j2] = '\0';
		    }
		    StrAllocCat(*post_data, buf);
		}
	    } else if (buf[0] != '\0') {
d1268 3
d1273 1
d1298 1
a1298 1
	strlen((char *)ANONYMOUS_USER) > 0 &&
d1300 2
a1301 2
	!strcasecomp(((char *)getenv("USER")==NULL ? " " : getenv("USER")),
		     ANONYMOUS_USER))
d1304 1
a1304 1
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER))
d1306 1
a1306 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER))
d1309 1
a1309 1
    {
d1318 8
a1325 1
    LYAddPathToHome(LYTraceLogPath = malloc(LY_MAXPATH), LY_MAXPATH, "Lynx.trace");
d1328 17
d1352 4
a1355 9
	temp = (char *)malloc(strlen(jumpfile) + 10);
	if (!temp) {
	    outofmem(__FILE__, "main");
	} else {
	    sprintf(temp, "JUMPFILE:%s", jumpfile);
	    if (!LYJumpInit(temp)) {
		CTRACE(tfp, "Failed to register %s\n", temp);
	    }
	    FREE(temp);
d1357 1
a1377 3
    /*
     *	Convert a '~' in the configuration file path to $HOME.
     */
d1379 1
a1379 12
   /* I think this should only be performed if lynx_cfg_file starts with ~/ */
   if ((lynx_cfg_file[0] == '~') && LYIsPathSep(lynx_cfg_file[1]))
     {
#ifdef VMS
	StrAllocCopy(temp, HTVMS_wwwName((char *)Home_Dir()));
#else
	StrAllocCopy(temp, Home_Dir());
#endif /* VMS */
	StrAllocCat(temp, lynx_cfg_file + 1);
	StrAllocCopy(lynx_cfg_file, temp);
	FREE(temp);
     }
d1386 1
a1386 1
    if ((fp = fopen(lynx_cfg_file, "r")) == NULL) {
d1389 1
a1389 1
	exit(-1);
a1390 6
    fclose(fp);

#if defined(USE_KEYMAPS) && defined(USE_SLANG)
    if (-1 == lynx_initialize_keymaps ())
	exit (-1);
#endif
d1398 1
a1398 1
	exit(-1);
d1409 5
d1420 1
a1420 1
			LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
d1427 1
a1427 1
	exit(-1);
d1430 1
a1430 1
#if defined(USE_HASH)
d1448 2
a1449 16
    /*
     *	Convert a '~' in the lynx-style file path to $HOME.
     */
    if ((cp = strchr(lynx_lss_file, '~'))) {
	*(cp++) = '\0';
	StrAllocCopy(temp, lynx_lss_file);
	LYTrimPathSep(temp);
#ifdef VMS
	StrAllocCat(temp, HTVMS_wwwName((char *)Home_Dir()));
#else
	StrAllocCat(temp, Home_Dir());
#endif /* VMS */
	StrAllocCat(temp, cp);
	StrAllocCopy(lynx_lss_file, temp);
	FREE(temp);
    }
d1454 1
a1454 1
    if ((fp = fopen(lynx_lss_file, "r")) == NULL) {
a1459 1
	fclose(fp);
d1462 1
a1462 1
#endif /* USE_HASH */
d1464 1
a1464 1
#if USE_COLOR_TABLE
d1484 1
a1484 1
    strcpy(filename, LYNX_SIG_FILE);
d1489 1
a1489 1
	CTRACE(tfp, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile);
d1491 1
a1491 1
	CTRACE(tfp, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", LYNX_SIG_FILE);
d1494 1
a1494 1
#ifdef USE_PSRC
d1507 1
a1507 1
    read_rc();
d1530 1
a1530 1
	parse_arg(&argv[i], &i);
d1543 1
a1543 1
	     parse_arg(my_args, (int *)0);
d1547 58
d1610 1
a1610 1
#ifdef USE_PSRC
d1625 2
d1630 1
a1630 1
	   LYAddPathToHome(LYCookieFile = malloc(LY_MAXPATH), LY_MAXPATH, COOKIE_FILE);
d1632 1
a1632 9
	    if ((cp = strchr(LYCookieFile, '~'))) {
		temp = NULL;
		*(cp++) = '\0';
		StrAllocCopy(temp, cp);
		LYTrimPathSep(temp);
		StrAllocCopy(LYCookieFile, wwwName(Home_Dir()));
		StrAllocCat(LYCookieFile, temp);
		FREE(temp);
	    }
d1636 18
d1679 1
a1679 9
	if ((cp = strchr(lynx_save_space, '~')) != NULL) {
	    *(cp++) = '\0';
	    StrAllocCopy(temp, lynx_save_space);
	    LYTrimPathSep(temp);
	    StrAllocCat(temp, wwwName(Home_Dir()));
	    StrAllocCat(temp, cp);
	    StrAllocCopy(lynx_save_space, temp);
	    FREE(temp);
	}
d1709 2
a1710 1
    HTFileInit();
d1712 7
a1718 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    if (syslog_txt) {
	syslog(LOG_INFO, "Session start:%s", syslog_txt);
    } else {
	syslog(LOG_INFO, "Session start");
d1720 1
a1720 2
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d1754 13
a1766 3
    if (number_links && keypad_mode == NUMBERS_AS_ARROWS)
	keypad_mode = LINKS_ARE_NUMBERED;
    if (keypad_mode == NUMBERS_AS_ARROWS)
d1768 1
d1774 1
a1774 4
	if (LYSelectPopups == TRUE)
	    LYSelectPopups = FALSE;
	else
	    LYSelectPopups = TRUE;
d1781 1
a1781 4
	if (LYShowCursor == TRUE)
	    LYShowCursor = FALSE;
	else
	    LYShowCursor = TRUE;
d1800 1
a1800 1
	LYMultiBookmarks = FALSE;
d1824 17
d1842 3
d1849 1
d1852 1
a1852 1
    (void) signal(SIGWINCH, size_change);
d1874 2
a1875 1
	(void) signal(SIGPIPE, SIG_IGN);
d1885 1
a1885 1
	(void) signal(SIGTSTP,SIG_IGN);
d1895 1
a1895 1
	exit_immediately(-1);
d1905 1
a1905 1
	exit_immediately(-1);
d1915 1
a1915 1
	exit_immediately(-1);
d1923 7
a1929 3
#ifdef USE_PSRC
    if (!dump_output_immediately)
	HTMLSRC_init_caches(); /* do it before terminal is initialized*/
d1969 1
a1969 1
	telnet_ok = !no_inside_telnet && !no_outside_telnet && telnet_ok;
d1971 1
a1971 1
	news_ok = !no_inside_news && !no_outside_news && news_ok;
d1973 2
a1974 2
	ftp_ok = !no_inside_ftp && !no_outside_ftp && ftp_ok;
	rlogin_ok = !no_inside_rlogin && !no_outside_rlogin && rlogin_ok;
d1976 2
a1977 2
	CTRACE(tfp,"LYMain.c: User in Local domain\n");
	telnet_ok = !no_inside_telnet && telnet_ok;
d1979 1
a1979 1
	news_ok = !no_inside_news && news_ok;
d1981 2
a1982 2
	ftp_ok = !no_inside_ftp && ftp_ok;
	rlogin_ok = !no_inside_rlogin && rlogin_ok;
d1985 2
a1986 2
	CTRACE(tfp,"LYMain.c: User in REMOTE domain\n");
	telnet_ok = !no_outside_telnet && telnet_ok;
d1988 1
a1988 1
	news_ok = !no_outside_news && news_ok;
d1990 2
a1991 2
	ftp_ok = !no_outside_ftp && ftp_ok;
	rlogin_ok = !no_outside_rlogin && rlogin_ok;
d1999 4
a2002 5
	StrAllocCopy(bookmark_page, "lynx_bookmarks");
	StrAllocCat(bookmark_page, HTML_SUFFIX);
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], "Default");
d2005 1
a2005 3
	StrAllocCopy(BookmarkPage, bookmark_page);
	StrAllocCopy(MBM_A_subbookmark[0], bookmark_page);
	StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
d2008 4
d2020 1
a2020 1
	if (crawl && !number_links) {
d2024 4
a2027 1
		keypad_mode = LINKS_ARE_NUMBERED;
d2030 1
d2039 1
d2041 2
a2042 2
	     keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED))
	    printlist(stdout,FALSE);
d2050 1
a2050 1
	    LYStoreCookies(LYCookieFile);
a2051 1
	cleanup_files();
d2064 12
a2075 2
	ena_csi((LYlowest_eightbit[current_char_set] > 155));
	LYOpenCloset();
d2077 2
a2078 1
	LYCloseCloset();
d2089 1
a2089 1
 *    LYNXKEYMAP, lynxcgi, LYNXIMGMAP, LYNXCOOKIE
d2096 1
d2102 1
d2111 1
d2118 4
a2121 1
 *  to make things consistent.  Not implemented yet.
d2123 1
d2125 6
a2130 1
 *  Called by user of interactive session by LYNXCFG://reload/ link.
d2134 20
a2153 1
    if (LYRestricted) return;  /* for sure */
d2155 26
a2180 2
    /* save .lynxrc file in case we change something from Options Menu */
    if (!save_rc()) return;    /* can not write the very own file :( */
d2184 1
a2184 1
#ifdef PERSISTENT_COOKIES
d2186 21
a2206 1
	char * LYCookieFile_flag = LYCookieFile;
a2208 1
	free_lynx_cfg(); /* free downloaders, printers, not always environments */
d2215 1
a2215 1
	 *  Process the RC file.
d2217 4
a2220 1
	read_rc();
d2222 3
d2243 5
d2252 1
a2252 1
#ifdef PERSISTENT_COOKIES
d2254 16
a2269 8
	 if (persistent_cookies != persistent_cookies_flag) {
	     persistent_cookies = persistent_cookies_flag;
	     HTAlert(gettext("persistent cookies state will be changed in next session only."));
	 }
	 if (strcmp(LYCookieFile, LYCookieFile_flag)) {
	     StrAllocCopy(LYCookieFile, LYCookieFile_flag);
	     CTRACE(tfp, "cookies file can be changed in next session only, restored.\n")
	 }
d2287 5
a2291 29
struct parse_args_type;
typedef int (*ParseFunc) PARAMS((char *));

typedef union {
	BOOLEAN * set_value;
	int *     int_value;
	char **   str_value;
	ParseFunc fun_value;
} ParseUnion;

/*
 * Storing the four types of data in separate fields costs about 1K of data.
 * However, this provides usable type-checking.  The initial version of the
 * parse_args_type used 'long' for all types, and dumped core when processing
 * "lynx -help".  (The compiler was unable to detect some minor errors).
 */
#ifdef  PARSE_DEBUG
#define ParseData BOOLEAN *set_value; int *int_value; char **str_value; ParseFunc fun_value
#define PARSE_SET(n,t,v,h) {n,t,    v,  0,  0,  0,    h}
#define PARSE_INT(n,t,v,h) {n,t,    0,  v,  0,  0,    h}
#define PARSE_STR(n,t,v,h) {n,t,    0,  0,  v,  0,    h}
#define PARSE_FUN(n,t,v,h) {n,t,    0,  0,  0,  v,    h}
#else
#define ParseData long value
#define PARSE_SET(n,t,v,h) {n,t,   (long) (v),        h}
#define PARSE_INT(n,t,v,h) {n,t,   (long) (v),        h}
#define PARSE_STR(n,t,v,h) {n,t,   (long) (v),        h}
#define PARSE_FUN(n,t,v,h) {n,t,   (long) (v),        h}
#endif
d2297 10
a2306 10
#define IGNORE_ARG		0x000
#define TOGGLE_ARG		0x001
#define SET_ARG			0x002
#define UNSET_ARG		0x003
#define FUNCTION_ARG		0x004
#define LYSTRING_ARG		0x005
#define INT_ARG			0x006
#define STRING_ARG		0x007
#define ARG_TYPE_MASK		0x0FF
#define NEED_NEXT_ARG		0x100
d2320 1
a2320 1
Parse_Args_Type;
d2323 1
a2323 1
static int parse_authentication ARGS2(
d2355 1
a2355 1
static int anonymous_fun ARGS1(
d2358 4
a2361 9
   /*
    *  Should already have been set, so we don't
    *  override or replace any additional
    *  restrictions from the command line. - FM
    */
   if (!LYRestricted)
      parse_restrictions("default");
   LYRestricted = TRUE;
   return 0;
d2365 1
a2365 1
static int assume_charset_fun ARGS1(
d2379 1
a2379 1
static int assume_local_charset_fun ARGS1(
d2387 1
a2387 1
static int assume_unrec_charset_fun ARGS1(
d2395 1
a2395 1
static int auth_fun ARGS1(
d2403 1
a2403 1
static int base_fun ARGS1(
a2420 10
#ifdef USE_SLANG
/* -blink */
static int blink_fun ARGS1(
	char *,			next_arg GCC_UNUSED)
{
    Lynx_Color_Flags |= SL_LYNX_USE_BLINK;
    return 0;
}
#endif

d2422 1
a2422 1
static int cache_fun ARGS1(
d2436 1
a2436 1
static int child_fun ARGS1(
d2446 1
a2446 1
static int color_fun ARGS1(
d2458 44
d2503 1
a2503 1
static int crawl_fun ARGS1(
d2507 1
a2507 1
    LYcols = 80;
d2512 1
a2512 1
static int display_fun ARGS1(
a2516 2
	if ((next_arg = LYgetXDisplay()) != 0)
	    StrAllocCopy(x_display, next_arg);
d2522 19
d2542 1
a2542 1
static int dump_output_fun ARGS1(
d2546 1
a2546 1
    LYcols = 80;
d2551 1
a2551 1
static int editor_fun ARGS1(
d2561 1
a2561 1
static int error_file_fun ARGS1(
d2575 1
a2575 1
static int exec_fun ARGS1(
d2588 1
a2588 1
static int get_data_fun ARGS1(
d2606 1
a2606 1
    LYcols = 80;
d2616 1
a2616 8
    while (LYSafeGets(&buf, stdin) != 0 &&
	  strncmp(buf, "---", 3) != 0) {
	int j;

	for (j = strlen(buf) - 1; j >= 0 && /* Strip line terminators */
	    (buf[j] == CR || buf[j] == LF); j--)
	    buf[j] = '\0';

d2624 1
a2624 1
static int help_fun ARGS1(
d2632 1
a2632 1
static int hiddenlinks_fun ARGS1(
d2652 1
a2652 1
static int homepage_fun ARGS1(
d2663 1
a2663 1
static int mime_header_fun ARGS1(
d2673 1
a2673 1
    LYcols = 999;
d2679 1
a2679 1
static int newschunksize_fun ARGS1(
d2695 1
a2695 1
static int newsmaxchunk_fun ARGS1(
d2711 8
d2720 1
a2720 1
static int nobrowse_fun ARGS1(
d2728 1
a2728 1
static int nocolor_fun ARGS1(
d2740 1
a2740 1
static int nopause_fun ARGS1(
d2749 31
d2781 1
a2781 1
static int pauth_fun ARGS1(
d2789 1
a2789 1
static int post_data_fun ARGS1(
d2807 1
a2807 1
    LYcols = 80;
d2816 1
a2816 8
    while (LYSafeGets(&buf, stdin) != 0 &&
	  strncmp(buf, "---", 3) != 0) {
	int j;

	for (j = strlen(buf) - 1; j >= 0 && /* Strip line terminators */
	    (buf[j] == CR || buf[j] == LF); j--) {
	    buf[j] = '\0';
	}
d2823 1
a2823 1
static int restrictions_fun ARGS1(
d2826 7
a2832 7
    static CONST char *Usage[] = {
 ""
,"   USAGE: lynx -restrictions=[option][,option][,option]"
,"   List of Options:"
,"   all             restricts all options."
,"   bookmark        disallow changing the location of the bookmark file."
,"   bookmark_exec   disallow execution links via the bookmark file"
d2834 4
a2837 3
,"   change_exec_perms  disallow changing the eXecute permission on files"
,"                   (but still allow it for directories) when local file"
,"                   management is enabled."
d2839 14
a2852 6
,"   default         same as commandline option -anonymous.  Disables"
,"                   default services for anonymous users.  Currently set to,"
,"                   all restricted except for: inside_telnet, outside_telnet,"
,"                   inside_news, inside_ftp, outside_ftp, inside_rlogin,"
,"                   outside_rlogin, goto, jump and mail.  Defaults"
,"                   are settable within userdefs.h"
d2854 1
a2854 1
,"   dired_support   disallow local file management"
d2856 6
a2861 6
,"   disk_save       disallow saving to disk in the download and print menus"
,"   dotfiles        disallow access to, or creation of, hidden (dot) files"
,"   download        disallow downloaders in the download menu"
,"   editor          disallow editing"
,"   exec            disable execution scripts"
,"   exec_frozen     disallow the user from changing the execution link"
d2863 1
a2863 1
,"   externals       disable passing URLs to external programs"
d2865 4
a2868 3
,"   file_url        disallow using G)oto, served links or bookmarks for"
,"                   file: URL's"
,"   goto            disable the 'g' (goto) command"
d2870 22
a2891 14
,"   inside_ftp      disallow ftps for people coming from inside your"
,"                   domain (utmp required for selectivity)"
,"   inside_news     disallow USENET news posting for people coming from"
,"                   inside your domain (utmp required for selectivity)"
,"   inside_rlogin   disallow rlogins for people coming from inside your"
,"                   domain (utmp required for selectivity)"
,"   inside_telnet   disallow telnets for people coming from inside your"
,"                   domain (utmp required for selectivity)"
#else
,"   inside_ftp      disallow ftps for people coming from inside your domain"
,"   inside_news     disallow USENET news posting for people coming from inside"
,"                   your domain"
,"   inside_rlogin   disallow rlogins for people coming from inside your domain"
,"   inside_telnet   disallow telnets for people coming from inside your domain"
d2893 11
a2903 5
,"   jump            disable the 'j' (jump) command"
,"   mail            disallow mail"
,"   multibook       disallow multiple bookmark files"
,"   news_post       disallow USENET News posting."
,"   option_save     disallow saving options in .lynxrc"
d2905 22
a2926 14
,"   outside_ftp     disallow ftps for people coming from outside your"
,"                   domain (utmp required for selectivity)"
,"   outside_news    disallow USENET news posting for people coming from"
,"                   outside your domain (utmp required for selectivity)"
,"   outside_rlogin  disallow rlogins for people coming from outside your"
,"                   domain (utmp required for selectivity)"
,"   outside_telnet  disallow telnets for people coming from outside your"
,"                   domain (utmp required for selectivity)"
#else
,"   outside_ftp     disallow ftps for people coming from outside your domain"
,"   outside_news    disallow USENET news posting for people coming from outside"
,"                   your domain"
,"   outside_rlogin  disallow rlogins for people coming from outside your domain"
,"   outside_telnet  disallow telnets for people coming from outside your domain"
d2928 14
a2941 6
,"   print           disallow most print options"
,"   shell           disallow shell escapes, and lynxexec, lynxprog or lynxcgi"
,"                   G)oto's"
,"   suspend         disallow Control-Z suspends with escape to shell"
,"   telnet_port     disallow specifying a port in telnet G)oto's"
,"   useragent       disallow modifications of the User-Agent header"
d2943 4
a2946 1
    size_t n;
d2948 54
a3001 3
    if (next_arg != 0) {
	parse_restrictions(next_arg);
    } else {
d3003 1
a3003 2
	for (n = 0; n < sizeof(Usage)/sizeof(Usage[0]); n++)
	    printf("%s\n", Usage[n]);
d3005 3
a3007 1
	exit(0);
d3013 1
a3013 1
static int selective_fun ARGS1(
d3021 1
a3021 1
static int source_fun ARGS1(
d3027 1
a3027 1
    LYcols = 999;
d3032 1
a3032 1
static int traversal_fun ARGS1(
d3037 1
a3037 1
    LYcols = 80;
d3039 1
a3039 1
    LYcols = 999;
d3046 1
a3046 1
static int version_fun ARGS1(
d3049 5
d3056 15
d3072 2
a3073 5
    printf(gettext("\n%s Version %s (%.*s)\n"),
	  LYNX_NAME, LYNX_VERSION,
	  LYNX_DATE_LEN,
	  LYNX_RELEASE ? LYNX_RELEASE_DATE : &LYNX_DATE[LYNX_DATE_OFF]
	  );
d3083 1
d3092 27
d3122 1
a3122 1
    exit(0);
d3128 1
a3128 1
static int width_fun ARGS1(
d3134 1
a3134 1
	    dump_output_width = ((w < 999) ? w : 999);
d3140 2
a3141 2
/* NOTE: This table is sorted by name; the lookup relies on that. */
static Parse_Args_Type Arg_Table [] =
d3144 2
a3145 2
      "accept_all_cookies", SET_ARG,		&LYAcceptAllCookies,
      "\naccepts all cookies"
d3148 2
a3149 2
      "anonymous",	FUNCTION_ARG,	anonymous_fun,
      "used to specify the anonymous account"
d3152 1
a3152 1
      "assume_charset", NEED_FUNCTION_ARG, assume_charset_fun,
d3156 1
a3156 1
      "assume_local_charset",	NEED_FUNCTION_ARG,assume_local_charset_fun,
d3160 1
a3160 1
      "assume_unrec_charset",	NEED_FUNCTION_ARG,assume_unrec_charset_fun,
d3164 1
a3164 1
      "auth",		NEED_FUNCTION_ARG,	auth_fun,
d3168 1
a3168 1
      "base",		FUNCTION_ARG,		base_fun,
d3171 10
a3180 4
#ifdef USE_SLANG
   PARSE_FUN(
      "blink",		FUNCTION_ARG,		blink_fun,
      "force high intensity bg colors in color mode"
d3184 1
a3184 1
      "book",		SET_ARG,		&bookmark_start,
d3188 1
a3188 1
      "buried_news",	TOGGLE_ARG,		&scan_for_buried_news_references,
d3192 1
a3192 1
      "cache",		NEED_FUNCTION_ARG,	cache_fun,
d3196 1
a3196 1
      "case",		SET_ARG,		&case_sensitive,
d3199 6
d3206 1
a3206 1
      "cfg",		IGNORE_ARG|NEED_NEXT_ARG,	0,
d3210 1
a3210 1
      "child",		FUNCTION_ARG,		child_fun,
d3213 10
d3225 1
a3225 1
      "color",		FUNCTION_ARG,		color_fun,
d3229 10
a3238 3
   PARSE_SET(
      "cookies",	TOGGLE_ARG,		&LYSetCookies,
      "toggles handling of Set-Cookie headers"
d3240 1
d3243 5
a3247 1
      "cookie_file",	LYSTRING_ARG,		&LYCookieFile,
d3251 4
d3257 1
a3257 1
      "core",		TOGGLE_ARG,		&LYNoCore,
d3262 1
a3262 1
      "crawl",		FUNCTION_ARG,		crawl_fun,
d3266 6
d3274 1
a3274 1
      "debug_partial",	TOGGLE_ARG,		&debug_display_partial,
d3278 6
d3285 1
a3285 1
      "display",	NEED_FUNCTION_ARG,	display_fun,
d3289 10
a3298 1
      "dump",		FUNCTION_ARG,		dump_output_fun,
d3302 1
a3302 1
      "editor",		NEED_FUNCTION_ARG,	editor_fun,
d3306 1
a3306 1
      "emacskeys",	SET_ARG,		&emacs_keys,
d3310 1
a3310 1
      "enable_scrollback", TOGGLE_ARG,		&enable_scrollback,
d3315 1
a3315 1
      "error_file",	NEED_FUNCTION_ARG,	error_file_fun,
d3321 1
a3321 1
      "exec",		FUNCTION_ARG,		exec_fun,
a3324 8
   PARSE_SET(
      "locexec",	SET_ARG,		&local_exec_on_local_files,
      "enable local program execution from local files only"
   ),
   PARSE_SET(
      "noexec",		UNSET_ARG,		&local_exec,
      "disable local program execution (DEFAULT)"
   ),
d3328 1
a3328 1
      "fileversions",	SET_ARG,		&HTVMSFileVersions,
d3333 5
a3337 1
      "force_html",	SET_ARG,		&LYforce_HTML_mode,
d3341 1
a3341 1
      "force_secure",	TOGGLE_ARG,		&LYForceSSLCookiesSecure,
a3343 4
   PARSE_SET(
      "from",		TOGGLE_ARG,		&LYNoFromHeader,
      "toggle transmissions of From headers"
   ),
d3346 1
a3346 1
      "forms_options",	TOGGLE_ARG,		&LYUseFormsOptions,
d3351 5
a3355 1
      "ftp",		UNSET_ARG,		&ftp_ok,
d3359 1
a3359 1
      "get_data",	FUNCTION_ARG,		get_data_fun,
d3363 1
a3363 1
      "head",		SET_ARG,		&HEAD_request,
d3367 1
a3367 1
      "help",		FUNCTION_ARG,		help_fun,
d3371 1
a3371 1
      "hiddenlinks",	NEED_FUNCTION_ARG,	hiddenlinks_fun,
d3375 2
a3376 2
      "historical",	TOGGLE_ARG,		&historical_comments,
      "toggles use of '>' or '-->' as a terminator for comments"
d3379 1
a3379 1
      "homepage",	NEED_FUNCTION_ARG,	homepage_fun,
d3383 1
a3383 1
      "image_links",	TOGGLE_ARG,		&clickable_images,
d3387 1
a3387 1
      "index",		NEED_LYSTRING_ARG,	&indexfile,
d3391 1
a3391 1
      "ismap",		TOGGLE_ARG,		&LYNoISMAPifUSEMAP,
d3394 6
d3401 1
a3401 1
      "link",		NEED_INT_ARG,		&ccount,
d3405 1
a3405 1
      "localhost",	SET_ARG,		&local_host_only,
d3408 7
a3414 1
#if defined(USE_HASH)
d3416 1
a3416 1
      "lss",		IGNORE_ARG|NEED_NEXT_ARG,	0,
d3421 1
a3421 1
      "mime_header",	FUNCTION_ARG,		mime_header_fun,
d3425 1
a3425 1
      "minimal",	TOGGLE_ARG,		&minimal_comments,
d3430 1
a3430 1
      "newschunksize",	NEED_FUNCTION_ARG,	newschunksize_fun,
d3434 1
a3434 1
      "newsmaxchunk",	NEED_FUNCTION_ARG,	newsmaxchunk_fun,
d3438 10
d3449 1
a3449 1
      "nobrowse",	FUNCTION_ARG,		nobrowse_fun,
d3453 1
a3453 1
      "nocc",		SET_ARG,		&LYNoCc,
d3457 1
a3457 1
      "nocolor",	FUNCTION_ARG,		nocolor_fun,
d3460 6
d3467 2
a3468 2
      "nofilereferer",	SET_ARG,		&no_filereferer,
      "disable transmissions of Referer headers for file URLs"
d3471 1
a3471 1
      "nolist",		SET_ARG,		&nolist,
d3475 1
a3475 1
      "nolog",		UNSET_ARG,		&error_logging,
d3478 6
d3485 1
a3485 1
      "nopause",	FUNCTION_ARG,		nopause_fun,
d3489 2
a3490 2
      "noprint",	SET_ARG,		&no_print,
      "disable print functions"
d3493 1
a3493 1
      "noredir",	SET_ARG,		&no_url_redirection,
d3497 6
a3502 2
      "noreferer",	SET_ARG,		&LYNoRefererHeader,
      "disable transmissions of Referer headers"
d3506 1
a3506 1
      "nosocks",	UNSET_ARG,		&socks_flag,
d3511 1
a3511 1
      "nostatus",	SET_ARG,		&no_statusline,
d3514 14
d3529 1
a3529 1
      "number_links",	SET_ARG,		&number_links,
d3534 1
a3534 1
      "partial",	TOGGLE_ARG,		&display_partial_flag,
d3538 1
a3538 1
      "partial_thres",  NEED_INT_ARG,          &partial_threshold,
d3544 1
a3544 1
      "pauth",		NEED_FUNCTION_ARG,	pauth_fun,
d3548 1
a3548 1
      "popup",		UNSET_ARG,		&LYUseDefSelPop,
d3552 1
a3552 1
      "post_data",	FUNCTION_ARG,		post_data_fun,
d3556 1
a3556 1
      "preparsed",	SET_ARG,		&LYPreparsedSource,
d3560 1
a3560 1
#ifdef USE_PSRC
d3562 2
a3563 2
      "prettysrc",	SET_ARG,		&LYpsrc,
      "do syntax highlighting and hyperlink handling in source view"
d3567 2
a3568 2
      "print",		UNSET_ARG,		&no_print,
      "enable print functions (DEFAULT)"
d3571 1
a3571 1
      "pseudo_inlines", TOGGLE_ARG,		&pseudo_inline_alts,
d3575 3
a3577 2
      "raw",		UNSET_ARG,		&LYUseDefaultRawMode,
      "toggles default setting of 8-bit character translations\nor CJK mode for the startup character set"
d3580 1
a3580 1
      "realm",		SET_ARG,		&check_realm,
d3584 1
a3584 1
      "reload",		SET_ARG,		&reloading,
d3588 1
a3588 1
      "restrictions",	FUNCTION_ARG,		restrictions_fun,
d3592 1
a3592 1
      "resubmit_posts", TOGGLE_ARG,		&LYresubmit_posts,
d3598 1
a3598 1
      "rlogin",		UNSET_ARG,		&rlogin_ok,
d3601 10
d3612 1
a3612 1
      "selective",	FUNCTION_ARG,		selective_fun,
d3616 11
a3626 1
      "show_cursor",	TOGGLE_ARG,		&LYUseDefShoCur,
d3629 6
d3636 1
a3636 1
      "soft_dquotes",	TOGGLE_ARG,		&soft_dquotes,
d3641 1
a3641 1
      "source",		FUNCTION_ARG,		source_fun,
d3645 1
a3645 1
      "stack_dump",	SET_ARG,		&stack_dump,
d3649 1
a3649 1
      "startfile_ok",	SET_ARG,		&startfile_ok,
d3652 4
d3659 1
a3659 1
      "syslog",		NEED_LYSTRING_ARG,	&syslog_txt,
d3665 1
a3665 1
      "tagsoup",	SET_ARG,		&Old_DTD,
d3669 1
a3669 1
      "telnet",		UNSET_ARG,		&telnet_ok,
d3673 1
a3673 1
      "term",		NEED_STRING_ARG,	&terminal,
d3676 6
d3683 1
a3683 1
      "tlog",		IGNORE_ARG,		0,
d3686 1
d3688 7
a3694 1
      "trace",		IGNORE_ARG,		0,
d3697 5
d3703 1
a3703 1
      "traversal",	FUNCTION_ARG,		traversal_fun,
d3707 5
a3711 1
      "underscore",	TOGGLE_ARG,		&use_underscore,
d3714 1
a3714 1
#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
d3716 2
a3717 2
      "use_mouse",	SET_ARG,		&LYUseMouse,
      "turn on xterm mouse support"
d3721 1
a3721 1
      "useragent",	NEED_LYSTRING_ARG,	&LYUserAgent,
d3725 2
a3726 2
      "validate",	IGNORE_ARG,		0,
      "accept only http URLs (for validation)"
d3729 1
a3729 1
      "verbose",	TOGGLE_ARG,		&verbose_img,
d3733 1
a3733 1
      "version",	FUNCTION_ARG,		version_fun,
d3737 1
a3737 1
      "vikeys",		SET_ARG,		&vi_keys,
d3740 6
d3747 1
a3747 1
      "width",		NEED_FUNCTION_ARG,	width_fun,
d3750 7
a3756 1
   {NULL, 0, 0, NULL}
d3759 1
a3759 1
static void print_help_strings ARGS3(
d3762 2
a3763 1
	CONST char *,	value)
d3770 1
a3770 1
    pad = field_width - (4 + (int) strlen (name));
d3772 1
a3772 1
    fprintf (stdout, "   -%s", name);
d3811 1
a3811 1
static void print_help_and_exit ARGS1(int, exit_status)
d3813 1
a3813 1
    Parse_Args_Type *p;
d3821 1
d3824 4
a3827 1
in double-quotes (\"-\") on VMS)", NULL);
d3831 2
a3832 5
#ifdef PARSE_DEBUG
	Parse_Args_Type * q = p;
#else
	ParseUnion *q = (ParseUnion *)(&(p->value));
#endif
d3836 1
a3836 1
		sprintf(temp, "%s", *(q->set_value) ? "on" : "off");
d3839 1
a3839 1
		sprintf(temp, "%s", *(q->set_value) ? "off" : "on");
d3853 1
a3853 1
	print_help_strings(p->name, p->help_string, value);
d3869 1
a3869 1
static int arg_eqs_parse ARGS3(
d3874 2
d3877 1
a3877 1
    while (1) {
d3883 5
d3889 1
d3891 10
a3900 2
		    return 1;
		case '-':	/* FALLTHRU */
d3903 2
a3904 1
		    return 1;
d3906 2
a3907 1
		    return 1;
d3909 2
a3910 1
		    return 0;
d3913 4
a3916 1
		return 0;
d3921 2
a3922 1
     }
d3928 1
a3928 1
PRIVATE void parse_arg ARGS2(
d3930 1
d3933 1
a3933 1
    Parse_Args_Type *p;
d3935 3
d3950 6
d3958 13
a3970 1
	return;
d3975 1
a3975 1
	return;
d3988 1
a3988 1
	return;
d3993 1
d3997 1
a3997 5
#ifdef PARSE_DEBUG
	Parse_Args_Type *q = p;
#else
	ParseUnion *q = (ParseUnion *)(&(p->value));
#endif
d4000 1
d4008 13
a4020 4
	if ((p->type & NEED_NEXT_ARG) && (next_arg == 0)) {
	    next_arg = argv[1];
	    if ((i != 0) && (next_arg != 0))
		(*i)++;
d4031 1
a4031 1
			 *(q->set_value) = !(*(q->set_value));
d4064 1
a4064 1
		 *(q->int_value) = atoi (next_arg);
a4070 3

	case IGNORE_ARG:
	     break;
d4073 2
a4074 1
	return;
d4081 1
d4114 1
a4114 1
	sleep(AlertSecs);
d4139 2
a4140 1
	fprintf(stderr, "\r\n\
d4142 3
a4144 2

	fprintf(stderr, "\r\n\
d4146 14
d4165 1
a4165 1
	    exit(-1);
d4177 1
a4177 1
	exit(0);
@


1.7
log
@default to passive, upgrade to active as needed; Andrew Basterfield
list@@lostgeneration.freeserve.co.uk
@
text
@d799 1
a799 1
    LYTrimStartfile(startfile);
d1385 1
a1385 1
	LYTrimStartfile(startfile);
d2310 1
a2310 1
	LYTrimStartfile(homepage);
d3231 1
a3231 1
	LYTrimStartfile(startfile);
@


1.7.2.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d799 1
a799 1
    LYEscapeStartfile(&startfile); 
d1385 1
a1385 1
	LYEscapeStartfile(&startfile);
d2310 1
a2310 1
	LYEscapeStartfile(&homepage);
d3231 1
a3231 1
	LYEscapeStartfile(&startfile);
@


1.6
log
@Passive ftp support from newer lynx sources. To enable it, see
FTP_PASSIVE in lynx.cfg.
@
text
@d171 2
d668 6
@


1.6.6.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html
@
text
@d791 1
a791 1
    LYEscapeStartfile(&startfile); 
d1377 1
a1377 1
	LYEscapeStartfile(&startfile);
d2302 1
a2302 1
	LYEscapeStartfile(&homepage);
d3223 1
a3223 1
	LYEscapeStartfile(&startfile);
@


1.5
log
@code missed when upgraded to 2.8.2. -moj
@
text
@d170 1
@


1.4
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d864 2
@


1.3
log
@cleanup if -dump is called; markus.friedl@@fau.de
@
text
@d1 37
a37 34
#include "HTUtils.h"
#include "tcp.h"
#include "HTTP.h"
#include "HTParse.h"
#include "HTAccess.h"
#include "HTList.h"
#include "HTFile.h"
#include "UCMap.h"
#include "UCDefs.h"
#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */
#include "HTInit.h"
#include "LYCurses.h"
#include "LYStyle.h"
#include "HTML.h"
#include "LYUtils.h"
#include "LYGlobalDefs.h"
#include "LYSignal.h"
#include "LYGetFile.h"
#include "LYStrings.h"
#include "LYClean.h"
#include "LYCharSets.h"
#include "LYCharUtils.h"
#include "UCMap.h"
#include "LYReadCFG.h"
#include "LYrcFile.h"
#include "LYKeymap.h"
#include "LYList.h"
#include "LYJump.h"
#include "LYMainLoop.h"
#include "LYBookmark.h"
#ifdef DOSPATH
#include "HTDOS.h"
d47 5
a51 1
#include<locale.h>
d54 2
a55 2
#include "LYexit.h"
#include "LYLeaks.h"
d57 2
a58 4
#define FREE(x) if (x) {free(x); x = NULL;}

#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
d60 2
a61 2
#define DISPLAY "DISPLAY"
#endif /* VMS */
d83 2
a84 18
PUBLIC char *lynx_version_putenv_command = NULL;
PUBLIC char *NNTPSERVER_putenv_cmd = NULL;   /* lynx.cfg defined NNTPSERVER */
PUBLIC char *http_proxy_putenv_cmd = NULL;   /* lynx.cfg defined http_proxy */
PUBLIC char *https_proxy_putenv_cmd = NULL;  /* lynx.cfg defined https_proxy */
PUBLIC char *ftp_proxy_putenv_cmd = NULL;    /* lynx.cfg defined ftp_proxy */
PUBLIC char *gopher_proxy_putenv_cmd = NULL; /* lynx.cfg defined gopher_proxy */
PUBLIC char *cso_proxy_putenv_cmd = NULL;    /* lynx.cfg defined cso_proxy */
PUBLIC char *news_proxy_putenv_cmd = NULL;   /* lynx.cfg defined news_proxy */
PUBLIC char *newspost_proxy_putenv_cmd = NULL;
PUBLIC char *newsreply_proxy_putenv_cmd = NULL;
PUBLIC char *snews_proxy_putenv_cmd = NULL;  /* lynx.cfg defined snews_proxy */
PUBLIC char *snewspost_proxy_putenv_cmd = NULL;
PUBLIC char *snewsreply_proxy_putenv_cmd = NULL;
PUBLIC char *nntp_proxy_putenv_cmd = NULL;   /* lynx.cfg defined nntp_proxy */
PUBLIC char *wais_proxy_putenv_cmd = NULL;   /* lynx.cfg defined wais_proxy */
PUBLIC char *finger_proxy_putenv_cmd = NULL; /* lynx.cfg defined finger_proxy */
PUBLIC char *no_proxy_putenv_cmd = NULL;     /* lynx.cfg defined no_proxy */
PUBLIC char *list_format=NULL;		/* LONG_LIST formatting mask */
d86 1
a86 1
PUBLIC char *syslog_txt = NULL; 	/* syslog arb text for session */
d97 1
a97 1
PUBLIC BOOLEAN dir_list_style = MIXED_STYLE;
d155 3
d159 1
d165 1
d171 1
a171 1
PUBLIC BOOLEAN user_mode = NOVICE_MODE;
d183 1
d191 1
a191 1
PUBLIC BOOLEAN keypad_mode = DEFAULT_KEYPAD_MODE;
d194 1
d196 1
a202 3
#ifdef RAWDOSKEYHACK
PUBLIC BOOLEAN raw_dos_key_hack = TRUE;
#endif /* RAWDOSKEYHACK */
d206 1
d209 1
d239 1
d242 1
d244 1
d246 1
d252 1
d254 1
a263 1
PUBLIC char *homepage = NULL;	/* home page or main screen */
d270 2
d280 1
d282 1
a282 1
PUBLIC char *display = NULL;	    /* display environment variable */
d293 1
d296 1
a296 1
PUBLIC char *LYHostName = NULL; 	/* treat as a local host name */
d323 2
a324 2
PUBLIC char *UCAssume_localMIMEcharset = NULL;
PUBLIC char *UCAssume_unrecMIMEcharset = NULL;
d351 1
a351 1
PUBLIC int LYMultiBookmarks = MULTI_BOOKMARK_SUPPORT;
d357 15
d376 1
a376 1
PUBLIC BOOL New_DTD = YES;
a379 1
PUBLIC FILE LYOrigStderr;			/* Original stderr pointer */
d388 1
a388 1
PUBLIC BOOLEAN LYPrependCharsetToSource = FALSE;
d391 6
d403 1
d406 1
a407 1
PRIVATE BOOLEAN anon_restrictions_set = FALSE;
d415 13
a427 1
PRIVATE void parse_arg PARAMS((char **arg, int *i, int argc));
d438 16
a453 1
void  reset_break()
d455 1
a455 1
    PDC_set_ctrl_break(init_ctrl_break[0]);
d459 1
d472 1
a472 17
    FREE(lynx_version_putenv_command);
    FREE(NNTPSERVER_putenv_cmd);
    FREE(http_proxy_putenv_cmd);
    FREE(https_proxy_putenv_cmd);
    FREE(ftp_proxy_putenv_cmd);
    FREE(gopher_proxy_putenv_cmd);
    FREE(cso_proxy_putenv_cmd);
    FREE(news_proxy_putenv_cmd);
    FREE(newspost_proxy_putenv_cmd);
    FREE(newsreply_proxy_putenv_cmd);
    FREE(snews_proxy_putenv_cmd);
    FREE(snewspost_proxy_putenv_cmd);
    FREE(snewsreply_proxy_putenv_cmd);
    FREE(nntp_proxy_putenv_cmd);
    FREE(wais_proxy_putenv_cmd);
    FREE(finger_proxy_putenv_cmd);
    FREE(no_proxy_putenv_cmd);
d482 2
d486 1
d492 1
a492 1
    FREE(display);
d502 8
a514 2
    FREE(homepage);
    FREE(helpfilepath);
d532 4
d537 1
d542 7
a548 2
    FREE(UCAssume_unrecMIMEcharset);
    FREE(UCAssume_localMIMEcharset);
d556 1
d577 74
a659 2
    int len;
    char *lynx_cfg_file = NULL;
d663 1
a663 1
    char filename[256];
d666 4
d681 1
a681 1
	    printf("No Winsock found, sorry.");
d689 6
a694 4
if (PDC_get_ctrl_break() == 0) {
    PDC_set_ctrl_break(TRUE);
    init_ctrl_break[0] = 0;}
else {init_ctrl_break[0] = 1;}
d696 1
d700 8
a707 9
#if defined(_WINDOWS) || defined(DJGPP)
	/*
	 * To prevent corrupting binary data with _WINDOWS and DJGPP
	 * we open files and stdout in BINARY mode by default.
	 * Where necessary we should open and (close!) TEXT mode.
	 */
	_fmode = O_BINARY;
	setmode( fileno( stdout ), O_BINARY );
#endif
d710 1
a710 1
    terminal = "vt100";
d726 2
a727 2
	if (strncmp(argv[i], "-help", 5) == 0) {
	    parse_arg(&argv[i], &i, argc);
a736 1
#endif /* LY_FIND_LEAKS */
d741 2
d750 7
d790 1
a790 13
    LYTrimHead(startfile);
    if (!strncasecomp(startfile, "lynxexec:", 9) ||
	!strncasecomp(startfile, "lynxprog:", 9)) {
	/*
	 *  The original implementations of these schemes expected
	 *  white space without hex escaping, and did not check
	 *  for hex escaping, so we'll continue to support that,
	 *  until that code is redone in conformance with SGML
	 *  principles.  - FM
	 */
	HTUnEscapeSome(startfile, " \r\n\t");
	convert_to_spaces(startfile, TRUE);
    }
d813 4
a816 1
    putenv(lynx_version_putenv_command);
d818 1
d821 2
a822 3
    else
#ifdef DOSPATH
    if ((cp = getenv("TEMP")) != NULL)
d824 4
d829 2
a830 1
	StrAllocCopy(lynx_temp_space, cp);
d832 7
d840 1
a840 1
	StrAllocCopy(lynx_temp_space, TEMP_SPACE);
d844 2
a845 11
	if (((len = strlen(temp)) > 0) && temp[len-1] == '/')
	    temp[len-1] = '\0';
#ifdef DOSPATH
	StrAllocCat(temp, HTDOS_wwwName((char *)Home_Dir()));
#else
#ifdef VMS
	StrAllocCat(temp, HTVMS_wwwName((char *)Home_Dir()));
#else
	StrAllocCat(temp, Home_Dir());
#endif /* VMS */
#endif /* DOSPATH */
d865 1
a865 2
    for (i = 0; lynx_temp_space[i]; i++)
	lynx_temp_space[i] = TOLOWER(lynx_temp_space[i]);
d867 1
a867 1
	if ((len = strlen(lynx_temp_space)) == 1) {
d870 1
a870 2
	    if (lynx_temp_space[len-1] != '/')
		StrAllocCat(lynx_temp_space, "/");
d881 1
a881 13
    StrAllocCat(lynx_temp_space, "/lynx-XXXXXX");
    lynx_temp_space = mkdtemp(lynx_temp_space);
#ifndef __DJGPP__
    if (((len = strlen(lynx_temp_space)) > 1) &&
	lynx_temp_space[len-1] != '/') {
	StrAllocCat(lynx_temp_space, "/");
    }
#else
    if (((len = strlen(lynx_temp_space)) > 1) &&
	lynx_temp_space[len-1] != '\\') {
	StrAllocCat(lynx_temp_space, "\\");
    }
#endif /* __DJGPP__ */
a897 13
    /*
     *	Set up the compilation default character set. - FM
     */
    for (i = 0; LYchar_set_names[i]; i++) {
	if (!strncmp(CHARACTER_SET, LYchar_set_names[i],
		     strlen(CHARACTER_SET))) {
	    current_char_set=i;
	    break;
	}
    }
    if (!LYchar_set_names[i])
	current_char_set = i = 0;
    HTMLSetRawModeDefault(i);
d905 1
d907 1
d917 1
a917 1
	if (strncmp(argv[i], "-trace", 6) == 0) {
d919 1
a919 1
	} else if (strncmp(argv[i], "-tlog", 5) == 0) {
d925 1
a925 1
	} else if (strncmp(argv[i], "-anonymous", 10) == 0) {
d928 2
a929 2
	    anon_restrictions_set = TRUE;
	} else if (strcmp(argv[i], "-validate") == 0) {
d935 1
a935 1
	} else if (strncmp(argv[i], "-nosocks", 8) == 0) {
d938 1
a938 1
	} else if (strncmp(argv[i], "-cfg", 4) == 0) {
d947 1
a947 1
	} else if (strncmp(argv[i], "-lss", 4) == 0) {
d954 1
a954 2
	    if (TRACE)
		fprintf(stderr, "LYMain found -lss flag, lss file is %s\n",
d981 1
a981 1
	char buf[1025];
d983 1
a983 1
	while (fgets(buf, sizeof(buf) - 1, stdin)) {
d991 1
a991 1
	    if (strncmp(buf, "-trace", 6) == 0) {
d993 1
a993 1
	    } else if (strncmp(buf, "-tlog", 5) == 0) {
d999 2
a1000 2
	    } else if (strncmp(buf, "-anonymous", 10) == 0) {
		if (!LYValidate && !anon_restrictions_set)
d1002 2
a1003 2
		anon_restrictions_set = TRUE;
	    } else if (strcmp(buf, "-validate") == 0) {
d1009 1
a1009 1
	    } else if (strncmp(buf, "-nosocks", 8) == 0) {
d1012 1
a1012 1
	    } else if (strncmp(buf, "-cfg", 4) == 0) {
d1016 2
a1017 5
		    cp = buf;
		    while (*cp && !isspace((unsigned char)*cp))
			cp++;
		    while (*cp && isspace((unsigned char)*cp))
			cp++;
d1022 1
a1022 1
	    } else if (strncmp(buf, "-lss", 4) == 0) {
d1026 2
a1027 5
		    cp = buf;
		    while (*cp && !isspace((unsigned char)*cp))
			cp++;
		    while (*cp && isspace((unsigned char)*cp))
			cp++;
d1029 1
a1029 1
			StrAllocCopy(lynx_cfg_file, cp);
d1031 1
a1031 2
		if (TRACE)
		    fprintf(stderr, "LYMain found -lss flag, lss file is %s\n",
d1034 1
a1034 1
	    } else if (strcmp(buf, "-get_data") == 0) {
d1060 1
a1060 1
		while (fgets(buf, sizeof(buf), stdin) &&
d1073 1
a1073 1
	    } else if (strcmp(buf, "-post_data") == 0) {
d1098 1
a1098 1
		while (fgets(buf, sizeof(buf), stdin) &&
d1116 1
d1118 1
d1124 1
d1147 1
a1147 1
    if (!LYValidate && !anon_restrictions_set &&
d1151 1
a1151 1
		     ANONYMOUS_USER)) {
d1154 1
a1154 1
	STREQ((char *)cuserid((char *) NULL), ANONYMOUS_USER)) {
d1156 1
a1156 1
	STREQ(((char *)getlogin()==NULL ? " " : getlogin()), ANONYMOUS_USER)) {
d1159 1
d1161 1
a1161 1
	anon_restrictions_set = TRUE;
d1168 2
a1169 42
#ifdef VMS
    StrAllocCopy(LYTraceLogPath, "sys$login:Lynx.trace");
#else
    StrAllocCopy(LYTraceLogPath, (Home_Dir() ? Home_Dir() : ""));
    StrAllocCat(LYTraceLogPath, "/Lynx.trace");
#endif /* VMS */
    LYOrigStderr = *stderr;
    if (TRACE && LYUseTraceLog) {
	/*
	 *  If we can't open it for writing, give up.
	 *  Otherwise, on VMS close it, delete it and any
	 *  versions from previous sessions so they don't
	 *  accumulate, and open it again. - FM
	 */
	if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
	    WWW_TraceFlag = FALSE;
	    fprintf(stderr, "%s\n", TRACELOG_OPEN_FAILED);
	    exit(-1);
	}
#ifdef VMS
	fclose(LYTraceLogFP);
	while (remove(LYTraceLogPath) == 0)
	    ;
	if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
	    WWW_TraceFlag = FALSE;
	    printf("%s\n", TRACELOG_OPEN_FAILED);
	    exit(-1);
	}
#endif /* VMS */
	fflush(stdout);
	fflush(stderr);
	*stderr = *LYTraceLogFP;
	fprintf(stderr, "\t\t%s\n\n", LYNX_TRACELOG_TITLE);
    }

    /*
     *	If TRACE is on, indicate whether the
     *	anonymous restrictions are set. - FM
     */
    if (TRACE && anon_restrictions_set) {
	fprintf(stderr, "LYMain: Anonymous restrictions set.\n");
    }
d1184 1
a1184 2
		if (TRACE)
		    fprintf(stderr, "Failed to register %s\n", temp);
d1213 1
a1213 1
   if ((lynx_cfg_file[0] == '~') && (lynx_cfg_file[1] == '/'))
d1231 1
a1231 1
	fprintf(stderr, "\nConfiguration file %s is not available.\n\n",
d1237 5
d1247 25
a1271 1
	fprintf(stderr, "\nLynx character sets not declared.\n\n");
d1299 1
a1299 2
	if ((len=strlen(temp)) > 0 && temp[len-1] == '/')
	    temp[len-1] = '\0';
d1314 1
a1314 1
	fprintf(stderr, "\nLynxile file %s is not available.\n\n",
d1322 1
a1322 1
#endif
d1324 1
d1326 1
a1326 1
     *	Make sure we have the edit map declared. - FM
d1328 2
a1329 4
    if (!LYEditmapDeclared()) {
	fprintf(stderr, "\nLynx edit map not declared.\n\n");
	exit(-1);
    }
a1330 1
#if USE_COLOR_TABLE
d1332 1
a1332 1
     *	Set up default foreground and background colors.
d1334 6
a1339 2
    lynx_setup_colors();
#endif /* USE_SLANG */
d1349 1
a1349 2
	if (TRACE)
	    fprintf(stderr, "LYNX_SIG_FILE set to '%s'\n", LynxSigFile);
d1351 1
a1351 3
	if (TRACE)
	    fprintf(stderr, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n",
			    LYNX_SIG_FILE);
d1354 5
d1362 81
a1442 3
    if (TRACE) {
	fprintf(stderr,
		"Loading cfg file '%s'.\n", lynx_cfg_file);
d1444 1
a1444 2
    read_cfg(lynx_cfg_file);
    FREE(lynx_cfg_file);
d1446 7
a1452 1
    HTSwitchDTD(New_DTD);
d1472 2
a1473 11
	    if (((len = strlen(temp)) > 0) && temp[len-1] == '/')
		temp[len-1] = '\0';
#ifdef DOSPATH
	    StrAllocCat(temp, HTDOS_wwwName((char *)Home_Dir()));
#else
#ifdef VMS
	    StrAllocCat(temp, HTVMS_wwwName((char *)Home_Dir()));
#else
	    StrAllocCat(temp, Home_Dir());
#endif /* VMS */
#endif /* DOSPATH */
d1479 1
a1479 2
	for (i = 0; lynx_save_space[i]; i++)
	    lynx_save_space[i] = TOLOWER(lynx_save_space[i]);
d1481 1
a1481 1
	    if ((len = strlen(lynx_save_space)) == 1) {
d1484 1
a1484 2
		if (lynx_save_space[len-1] != '/')
		    StrAllocCat(lynx_save_space, "/");
d1495 1
a1495 6
    {
	if (((len = strlen(lynx_save_space)) > 1) &&
	    lynx_save_space[len-1] != '/') {
	    StrAllocCat(lynx_save_space, "/");
	}
    }
d1509 19
a1527 75
    /*
     *	Get WWW_HOME environment variable if it exists.
     */
    if ((cp = getenv("WWW_HOME")) != NULL) {
	StrAllocCopy(startfile, cp);
	LYTrimHead(startfile);
	if (!strncasecomp(startfile, "lynxexec:", 9) ||
	    !strncasecomp(startfile, "lynxprog:", 9)) {
	    /*
	     *	The original implementations of these schemes expected
	     *	white space without hex escaping, and did not check
	     *	for hex escaping, so we'll continue to support that,
	     *	until that code is redone in conformance with SGML
	     *	principles.  - FM
	     */
	    HTUnEscapeSome(startfile, " \r\n\t");
	    convert_to_spaces(startfile, TRUE);
	}
    }

    /*
     *	Set the LynxHome URL.  If it's a file URL and the
     *	host is defaulted, force in "//localhost", and if
     *	it's not an absolute URL, make it one. - FM
     */
    StrAllocCopy(LynxHome, startfile);
    LYFillLocalFileURL((char **)&LynxHome, "file://localhost");
    LYEnsureAbsoluteURL((char **)&LynxHome, "LynxHome");

    /*
     *	Process any command line arguments not already handled. - FM
     */
    for (i = 1; i < argc; i++) {
	parse_arg(&argv[i], &i, argc);
    }

    /*
     *	Process any stdin-derived arguments for a lone "-"  which we've
     *	loaded into LYStdinArgs. - FM
     */
    if (LYStdinArgs != NULL) {
	char *my_args[2];
	HTList *cur = LYStdinArgs;

	my_args[1] = NULL;
	while (NULL != (my_args[0] = (char *)HTList_nextObject(cur))) {
	    parse_arg(my_args, NULL, -1);
	}
	LYStdinArgs_free();
    }

#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    if (syslog_txt) {
	syslog(LOG_INFO, "Session start:%s", syslog_txt);
    } else {
	syslog(LOG_INFO, "Session start");
    }
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */

    /*
     *	Process the RC file.
     */
    read_rc();

#ifdef USE_SLANG
    if (LYShowColor >= SHOW_COLOR_ON &&
	!(Lynx_Color_Flags & SL_LYNX_USE_COLOR)) {
	Lynx_Color_Flags |= SL_LYNX_USE_COLOR;
    } else if ((Lynx_Color_Flags & SL_LYNX_USE_COLOR) ||
	       getenv("COLORTERM") != NULL) {
	if (LYShowColor != SHOW_COLOR_NEVER &&
	    LYShowColor != SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
d1597 15
d1650 8
d1659 33
a1691 2
     *	Set up the proper character set with the desired
     *	startup raw 8-bit or CJK mode handling.  - FM
d1693 4
a1696 1
    HTMLUseCharacterSet(current_char_set);
d1698 3
d1707 1
a1707 1
    LYEnsureAbsoluteURL((char **)&startfile, "STARTFILE");
d1716 1
a1716 1
	LYEnsureAbsoluteURL((char **)&homepage, "HOMEPAGE");
d1736 1
d1738 1
d1742 1
a1742 2
	if (TRACE)
	   fprintf(stderr,"LYMain.c: User in Local domain\n");
d1744 1
d1746 1
d1751 1
a1751 2
	if (TRACE)
	   fprintf(stderr,"LYMain.c: User in REMOTE domain\n");
d1753 1
d1755 1
a1759 84
#ifdef SIGTSTP
    /*
     *	Block Control-Z suspending if requested. - FM
     */
    if (no_suspend)
	(void) signal(SIGTSTP,SIG_IGN);
#endif /* SIGTSTP */

    /*
     *	Check for a valid HEAD request. - FM
     */
    if (HEAD_request && LYCanDoHEAD(startfile) != TRUE) {
	fprintf(stderr,
 "The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n",
		startfile);
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(-1);
    }

    /*
     *	Check for a valid MIME headers request. - FM
     */
    if (keep_mime_headers && LYCanDoHEAD(startfile) != TRUE) {
	fprintf(stderr,
 "The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n",
		startfile);
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(-1);
    }

    /*
     *	Check for a valid traversal request. - FM
     */
    if (traversal && strncmp(startfile, "http", 4)) {
	fprintf(stderr,
 "The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n",
		startfile);
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(-1);
    }

    /*
     *	Set up our help and about file base paths. - FM
     */
    StrAllocCopy(helpfilepath, helpfile);
    if ((cp=strrchr(helpfilepath, '/')) != NULL)
	*cp = '\0';
    /*
     *	Remove code to merge the historical about_lynx
     *	directory into lynx_help. - HN
     */
    StrAllocCat(helpfilepath, "/");


d1792 1
a1792 1
	if (display != NULL && *display != '\0') {
d1803 11
a1813 11
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
d1816 1
a1816 2
	 *  Finish setting up and start an
	 *  INTERACTIVE session. - FM
d1818 2
a1819 6
	if (setup(terminal)) {
	    if (display != NULL && *display != '\0') {
		LYisConfiguredForX = TRUE;
	    }
	    ena_csi((LYlowest_eightbit[current_char_set] > 155));
	    status = mainloop();
d1821 10
a1831 1
    cleanup();
d1833 1
a1833 1
    exit(status);
d1861 1
d1863 6
a1868 2
 *  Parse one argument, optionally picking up the next entry in argv (if
 *  appropriate).
d1870 1
a1870 4

PRIVATE char * scan3D ARGS2(
	char **,	argv,
	int *,		i)
d1872 1
a1872 1
    char *result;
d1874 2
a1875 6
    if ((result=strchr(argv[0],'=')) != NULL)
	return result+1;
    if (argv[1] && i)
	(*i)++; /* Let master know we've stolen an argument */
    return argv[1];
}
d1877 6
a1882 42
PRIVATE void parse_arg ARGS3(
	char **,	argv,
	int *,		i,
	int,		argc)
{
    char *cp;
#ifndef VMS
    static char display_putenv_command[142];
#endif /* !VMS */
#define nextarg ((cp=scan3D(&argv[0], i))!=NULL)

    /*
     *	Check for a command line startfile. - FM
     */
    if (argv[0][0] != '-') {
	StrAllocCopy(startfile, argv[0]);
	LYTrimHead(startfile);
	if (!strncasecomp(startfile, "lynxexec:", 9) ||
	    !strncasecomp(startfile, "lynxprog:", 9)) {
	    /*
	     *	The original implementations of these schemes expected
	     *	white space without hex escaping, and did not check
	     *	for hex escaping, so we'll continue to support that,
	     *	until that code is redone in conformance with SGML
	     *	principles.  - FM
	     */
	    HTUnEscapeSome(startfile, " \r\n\t");
	    convert_to_spaces(startfile, TRUE);
	}
	return;
    }

    /*
     *	Skip any lone "-" arguments, because we've loaded
     *	the stdin input into an HTList structure for
     *	special handling. - FM
     */
    if (strcmp(argv[0], "-") == 0) {
	return;
    }

    switch (TOLOWER(argv[0][1])) {
d1884 1
a1884 2
    case 'a':
    if (strncmp(argv[0], "-anonymous", 10) == 0) {
d1886 1
a1886 3
	 *  Should already have been set, so we don't
	 *  override or replace any additional
	 *  restrictions from the command line. - FM
d1888 1
a1888 39
	if (!anon_restrictions_set)
	    parse_restrictions("default");
	    anon_restrictions_set = TRUE;

    } else if ((strncmp(argv[0], "-assume_charset", 15) == 0) ||
	       (strncmp(argv[0], "-assume_local_charset", 21) == 0) ||
	       (strncmp(argv[0], "-assume_unrec_charset", 21) == 0)) {
	BOOL local_flag = (argv[0][8] == 'l');
	BOOL unrec_flag = (argv[0][8] == 'u');

	if (nextarg) {
	    int j;

	    for (j = 0; cp[j]; j++)
		cp[j] = TOLOWER(cp[j]);
	    if (local_flag) {
		StrAllocCopy(UCAssume_localMIMEcharset, cp);
		if (UCAssume_localMIMEcharset && *UCAssume_localMIMEcharset)
		    UCLYhndl_HTFile_for_unspec =
			UCGetLYhndl_byMIME(UCAssume_localMIMEcharset);
	    } else if (unrec_flag) {
		StrAllocCopy(UCAssume_unrecMIMEcharset, cp);
		if (UCAssume_unrecMIMEcharset && *UCAssume_unrecMIMEcharset)
		    UCLYhndl_for_unrec =
			UCGetLYhndl_byMIME(UCAssume_unrecMIMEcharset);
	    } else {
		StrAllocCopy(UCAssume_MIMEcharset, cp);
		if (UCAssume_MIMEcharset && *UCAssume_MIMEcharset)
		    UCLYhndl_for_unspec =
			UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
	    }
	} else {
	    if (local_flag)
		UCLYhndl_HTFile_for_unspec = 0;
	    else if (unrec_flag)
		UCLYhndl_for_unrec = 0;
	    else
		UCLYhndl_for_unspec = 0;
	}
a1889 1
    } else if (strncmp(argv[0], "-auth", 5) == 0) {
d1891 1
a1891 1
	 *  Authentication information for protected documents.
d1893 1
a1893 1
	char *auth_info = NULL;
a1894 18
	if (nextarg) {
	    StrAllocCopy(auth_info, cp);
	    memset(cp, ' ', strlen(cp));	/* Let's not show too much */
	}
	if (auth_info != NULL)	{
	    if ((cp = strchr(auth_info, ':')) != NULL) {	/* Pw */
		*cp++ = '\0';	/* Terminate ID */
		if (*cp) {
		    HTUnEscape(cp);
		    StrAllocCopy(authentication_info[1], cp);
		}
	    }
	    if (*auth_info) {					/* Id */
		HTUnEscape(auth_info);
		StrAllocCopy(authentication_info[0], auth_info);
	    }
	    FREE(auth_info);
	}
d1896 2
a1897 4
    } else {
	goto Output_Error_and_Help_List;
    }
    break;
a1898 2
    case 'b':
    if (strcmp(argv[0], "-base") == 0) {
d1900 1
a1900 7
	 *  Treat -source equivalently to an interactive
	 *  download with LYPrefixBaseToSource configured
	 *  to TRUE, so that a BASE tag is prepended for
	 *  text/html content types.  We normally treat
	 *  the module-wide global LYPrefixBaseToSource
	 *  flag as FALSE with -source, but force it TRUE,
	 *  later, if LYPrependBase is set TRUE here. - FM
d1902 1
a1902 4
	LYPrependBase = TRUE;
	if (HTOutputFormat == HTAtom_for("www/dump")) {
	    HTOutputFormat = HTAtom_for("www/download");
	}
a1903 1
    } else if (strcmp(argv[0], "-book") == 0) {
d1905 2
a1906 1
	 *  Use bookmarks as startfile.
d1908 1
a1908 1
	bookmark_start = TRUE;
a1909 1
    } else if (strcmp(argv[0], "-buried_news") == 0) {
d1911 1
a1911 1
	 *  Toggle scans for buried news references.
d1913 15
a1927 4
	if (scan_for_buried_news_references)
	    scan_for_buried_news_references = FALSE;
	else
	    scan_for_buried_news_references = TRUE;
d1929 3
a1931 4
#ifdef USE_SLANG
    } else if (strncmp(argv[0], "-blink", 6) == 0) {
	Lynx_Color_Flags |= SL_LYNX_USE_BLINK;
#endif /* USE_SLANG */
a1932 4
    } else {
	goto Output_Error_and_Help_List;
    }
    break;
d1934 9
a1942 8
    case 'c':
    if (strncmp(argv[0], "-cache", 6) == 0) {
	if (nextarg)
	    HTCacheSize = atoi(cp);
	/*
	 *  Limit size.
	 */
	if (HTCacheSize < 2) HTCacheSize = 2;
d1944 2
a1945 2
    } else if (strncmp(argv[0], "-case", 5) == 0) {
	case_sensitive = TRUE;
d1947 6
a1952 7
    } else if (strncmp(argv[0], "-cfg", 4) == 0) {
	/*
	 *  Already read the alternate configuration file
	 *  so just check whether we need to increment i
	 */
	if (nextarg)
	    ; /* do nothing */
d1954 19
a1972 3
    } else if (strncmp(argv[0], "-child", 6) == 0) {
	child_lynx = TRUE;
	no_disk_save = TRUE;
d1974 23
a1996 7
#ifdef USE_SLANG
    } else if (strncmp(argv[0], "-color", 6) == 0) {
	Lynx_Color_Flags |= SL_LYNX_USE_COLOR;
	if (LYShowColor != SHOW_COLOR_ALWAYS) {
	    LYShowColor = SHOW_COLOR_ON;
	}
#endif /* USE_SLANG */
d1998 4
a2001 9
    } else if (strncmp(argv[0], "-crawl", 6) == 0) {
	crawl = TRUE;
	LYcols = 80;

    } else if (strncmp(argv[0], "-cookies", 8) == 0) {
	if (LYSetCookies)
	    LYSetCookies = FALSE;
	else
	    LYSetCookies = TRUE;
d2003 9
a2011 7
#ifndef VMS
    } else if (strncmp(argv[0], "-core", 5) == 0) {
	if (LYNoCore)
	    LYNoCore = FALSE;
	else
	    LYNoCore = TRUE;
#endif /* !VMS */
d2013 3
a2015 2
    } else {
	goto Output_Error_and_Help_List;
a2016 1
    break;
d2018 7
a2024 15
    case 'd':
    if (strncmp(argv[0], "-display", 8) == 0) {
	if (nextarg) {
#ifdef VMS
	    int j;
	    for (j = 0; cp[j]; j++)
		cp[j] = TOUPPER(cp[j]);
	    Define_VMSLogical(DISPLAY, cp ? cp : "");
#else
	    sprintf(display_putenv_command, "DISPLAY=%s", cp ? cp : "");
	    putenv(display_putenv_command);
#endif /* VMS */
	    if ((cp = getenv(DISPLAY)) != NULL && *cp != '\0') {
		StrAllocCopy(display, cp);
	    }
d2026 53
d2080 7
a2086 3
    } else if (strncmp(argv[0], "-dump", 5) == 0) {
	dump_output_immediately = TRUE;
	LYcols=80;
d2088 15
a2102 4
    } else {
	goto Output_Error_and_Help_List;
    }
    break;
d2104 2
a2105 14
    case 'e':
    if (strncmp(argv[0], "-editor", 7) == 0) {
	if (nextarg)
	    StrAllocCopy(editor,cp);
	system_editor = TRUE;

    } else if (strncmp(argv[0], "-emacskeys", 10) == 0) {
	emacs_keys = TRUE;

    } else if (strncmp(argv[0], "-enable_scrollback", 18) == 0) {
	if (enable_scrollback)
	    enable_scrollback = FALSE;
	else
	    enable_scrollback = TRUE;
d2107 9
a2115 7
    } else if (strncmp(argv[0], "-error_file", 11) == 0) {
	/*
	 *  Output return (success/failure) code
	 *  of an HTTP transaction.
	 */
	if (nextarg)
	    http_error_file = cp;
d2117 10
a2126 8
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    } else if (strncmp(argv[0], "-exec", 5) == 0) {
#ifndef NEVER_ALLOW_REMOTE_EXEC
	local_exec = TRUE;
#else
	local_exec_on_local_files = TRUE;
#endif /* NEVER_ALLOW_REMOTE_EXEC */
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
d2128 2
a2129 4
    } else {
	goto Output_Error_and_Help_List;
    }
    break;
d2131 8
a2138 3
    case 'f':
    if (strncmp(argv[0], "-force_html", 11) == 0) {
	LYforce_HTML_mode = TRUE;
d2140 6
a2145 6
    } else if (strncmp(argv[0], "-fileversions", 13) == 0) {
#ifdef VMS
	HTVMSFileVersions = TRUE;
#else
	break;;
#endif /* VMS */
d2147 2
a2148 5
    } else if (strncmp(argv[0], "-force_secure", 13) == 0) {
	if (LYForceSSLCookiesSecure)
	    LYForceSSLCookiesSecure = FALSE;
	else
	    LYForceSSLCookiesSecure = TRUE;
d2150 3
a2152 5
    } else if (strncmp(argv[0], "-from", 5) == 0) {
	if (LYNoFromHeader)
	    LYNoFromHeader = FALSE;
	else
	    LYNoFromHeader = TRUE;
d2154 8
a2161 2
    } else if (strncmp(argv[0], "-ftp", 4) == 0) {
	ftp_ok = FALSE;
d2163 8
a2170 2
    } else {
	goto Output_Error_and_Help_List;
a2171 1
    break;
d2173 58
a2230 7
    case 'g':
    if (strcmp(argv[0], "-get_data") == 0) {
	/*
	 *  User data for GET form.
	 */
	char **get_data;
	char buf[1024];
d2232 7
a2238 7
	/*
	 *  On Unix, conflicts with curses when interactive
	 *  so let's force a dump.  - CL
	 *
	 *  On VMS, mods have been made in LYCurses.c to deal with
	 *  potential conflicts, so don't force the dump here. - FM
	 */
d2240 2
a2241 2
	dump_output_immediately = TRUE;
	LYcols = 80;
d2244 2
a2245 2
	StrAllocCopy(form_get_data, "?");   /* Prime the pump */
	get_data = &form_get_data;
d2247 7
a2253 7
	/*
	 *  Build GET data for later.  Stop reading when we see a line
	 *  with "---" as its first three characters.
	 */
	while (fgets(buf, sizeof(buf), stdin) &&
	       strncmp(buf, "---", 3) != 0) {
	    int j;
d2255 3
a2257 6
	    for (j = strlen(buf) - 1; j >= 0 && /* Strip line terminators */
		(buf[j] == CR || buf[j] == LF); j--) {
		buf[j] = '\0';
	    }
	    StrAllocCat(*get_data, buf);
	}
d2259 1
a2259 2
    } else {
	goto Output_Error_and_Help_List;
a2260 1
    break;
d2262 2
a2263 3
    case 'h':
    if (strcmp(argv[0], "-help") == 0) {
	goto Output_Help_List;
d2265 7
a2271 5
    } else if (strcmp(argv[0], "-head") == 0) {
	/*
	 *  Return mime headers.
	 */
	HEAD_request = TRUE;
d2273 6
a2278 11
    } else if (strncmp(argv[0], "-hiddenlinks", 7) == 0) {
	if (nextarg) {
	    if (strncasecomp(cp, "merge", 1) == 0)
		LYHiddenLinks = HIDDENLINKS_MERGE;
	    else if (strncasecomp(cp, "listonly", 1) == 0)
		LYHiddenLinks = HIDDENLINKS_SEPARATE;
	    else if (strncasecomp(cp, "ignore", 1) == 0)
		LYHiddenLinks = HIDDENLINKS_IGNORE;
	    else
		goto Output_Error_and_Help_List;
	} else
d2280 4
a2283 4

    } else if (strncmp(argv[0], "-historical", 11) == 0) {
	if (historical_comments)
	    historical_comments = FALSE;
d2285 1
a2285 19
	    historical_comments = TRUE;

    } else if (strncmp(argv[0], "-homepage", 9) == 0) {
	if (nextarg) {
	    StrAllocCopy(homepage, cp);
	    LYTrimHead(homepage);
	    if (!strncasecomp(homepage, "lynxexec:", 9) ||
		!strncasecomp(homepage, "lynxprog:", 9)) {
		/*
		 *  The original implementations of these schemes expected
		 *  white space without hex escaping, and did not check
		 *  for hex escaping, so we'll continue to support that,
		 *  until that code is redone in conformance with SGML
		 *  principles.  - FM
		 */
		HTUnEscapeSome(homepage, " \r\n\t");
		convert_to_spaces(homepage, TRUE);
	    }
	}
d2287 1
a2287 1
	goto Output_Error_and_Help_List;
a2288 1
    break;
d2290 2
a2291 6
    case 'i':
    if (strncmp(argv[0], "-image_links", 12) == 0) {
	if (clickable_images)
	    clickable_images = FALSE;
	else
	    clickable_images = TRUE;
d2293 7
a2299 12
    } else if (strncmp(argv[0], "-index", 6) == 0) {
	if (nextarg)
	    StrAllocCopy(indexfile, cp);

    } else if (strncmp(argv[0], "-ismap", 6) == 0) {
	if (LYNoISMAPifUSEMAP)
	    LYNoISMAPifUSEMAP = FALSE;
	else
	    LYNoISMAPifUSEMAP = TRUE;

    } else {
	goto Output_Error_and_Help_List;
d2301 2
a2302 1
    break;
d2304 14
a2317 4
    case 'l':
    if (strncmp(argv[0], "-link", 5) == 0) {
	if (nextarg)
	    ccount = atoi(cp);
d2319 7
a2325 10
    } else if (strncmp(argv[0], "-localhost", 10) == 0) {
	local_host_only = TRUE;

#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    } else if (strncmp(argv[0], "-locexec", 8) == 0) {
	local_exec_on_local_files = TRUE;
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

#if defined(USE_HASH)
    } else if (strncmp(argv[0], "-lss", 4) == 0) {
d2327 2
a2328 2
	 *  Already read the alternate lynx-style file
	 *  so just check whether we need to increment i
d2330 2
a2331 6
	if (nextarg)
	    ; /* do nothing */
#endif

    } else {
	goto Output_Error_and_Help_List;
d2333 2
a2334 1
    break;
d2336 6
a2341 2
    case 'm':
    if (strcmp(argv[0], "-mime_header") == 0) {
d2343 2
a2344 1
	 *  Include mime headers and force source dump.
d2346 2
a2347 14
	keep_mime_headers = TRUE;
	dump_output_immediately = TRUE;
	HTOutputFormat = (LYPrependBase ?
	     HTAtom_for("www/download") : HTAtom_for("www/dump"));
	LYcols=999;

    } else if (strncmp(argv[0], "-minimal", 8) == 0) {
	if (minimal_comments)
	    minimal_comments = FALSE;
	else
	    minimal_comments = TRUE;

    } else {
	goto Output_Error_and_Help_List;
d2349 3
a2351 1
    break;
d2353 7
a2359 12
    case 'n':
    if (strncmp(argv[0], "-newschunksize", 14) == 0) {
	if (nextarg) {
	    HTNewsChunkSize = atoi(cp);
	    /*
	     * If the new HTNewsChunkSize exceeds the maximum,
	     * increase HTNewsMaxChunk to this size. - FM
	     */
	    if (HTNewsChunkSize > HTNewsMaxChunk) {
		HTNewsMaxChunk = HTNewsChunkSize;
	    }
	}
d2361 5
a2365 20
    } else if (strncmp(argv[0], "-newsmaxchunk", 13) == 0) {
	if (nextarg) {
	    HTNewsMaxChunk = atoi(cp);
	    /*
	     * If HTNewsChunkSize exceeds the new maximum,
	     * reduce HTNewsChunkSize to this maximum. - FM
	     */
	    if (HTNewsChunkSize > HTNewsMaxChunk) {
		HTNewsChunkSize = HTNewsMaxChunk;
	    }
	}

    } else if (strncmp(argv[0], "-nobrowse", 9) == 0) {
	HTDirAccess = HT_DIR_FORBID;

    } else if (strncmp(argv[0], "-nocc", 5) == 0) {
	LYNoCc = TRUE;

    } else if (strncmp(argv[0], "-nocolor", 8) == 0) {
	LYShowColor = SHOW_COLOR_NEVER;
d2367 2
a2368 2
	Lynx_Color_Flags &= ~SL_LYNX_USE_COLOR;
	Lynx_Color_Flags |= SL_LYNX_OVERRIDE_COLOR;
d2370 2
d2373 9
a2381 4
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    } else if (strncmp(argv[0], "-noexec", 7) == 0) {
	local_exec = FALSE;
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
d2383 7
a2389 2
    } else if (strncmp(argv[0], "-nofilereferer", 14) == 0) {
	no_filereferer = TRUE;
d2391 9
a2399 2
    } else if (strncmp(argv[0], "-nolist", 7) == 0) {
	nolist = TRUE;
d2401 7
a2407 79
    } else if (strncmp(argv[0], "-nolog", 6) == 0) {
	error_logging = FALSE;

    } else if (strcmp(argv[0], "-nopause") == 0) { /* No statusline pauses */
	InfoSecs = 0;
	MessageSecs = 0;
	AlertSecs = 0;

    } else if (strncmp(argv[0], "-noprint", 8) == 0) {
	no_print = TRUE;

    } else if (strcmp(argv[0], "-noredir") == 0) {
	/*
	 *  Don't follow URL redirections.
	 */
	no_url_redirection = TRUE;

    } else if (strncmp(argv[0], "-noreferer", 10) == 0) {
	LYNoRefererHeader = TRUE;

#ifdef SOCKS
    } else if (strncmp(argv[0], "-nosocks", 8) == 0) {
	socks_flag = FALSE;
#endif /* SOCKS */

    } else if (strncmp(argv[0], "-nostatus", 9) == 0)	{
	no_statusline = TRUE;

    } else if (strncmp(argv[0], "-number_links", 13) == 0) {
	number_links = TRUE;

    } else {
	goto Output_Error_and_Help_List;
    }
    break;

    case 'p':
    if (strncmp(argv[0], "-pauth", 6) == 0) {
	/*
	 *  Authentication information for protected proxy server. - AJL
	 */
	char *pauth_info = NULL;

	if (nextarg) {
	    StrAllocCopy(pauth_info, cp);
	    memset(cp, ' ', strlen(cp));	/* Let's not show too much */
	}
	if (pauth_info != NULL)  {
	    if ((cp = strchr(pauth_info, ':')) != NULL) {	/* Pw */
		*cp++ = '\0';	/* Terminate ID */
		if (*cp) {
		    HTUnEscape(cp);
		    StrAllocCopy(proxyauth_info[1], cp);
		}
	    }
	    if (*pauth_info) {					/* Id */
		HTUnEscape(pauth_info);
		StrAllocCopy(proxyauth_info[0], pauth_info);
	    }
	    FREE(pauth_info);
	}

    } else if (strncmp(argv[0], "-popup", 6) == 0) {
	LYUseDefSelPop = FALSE;

    } else if (strcmp(argv[0], "-post_data") == 0) {
	/*
	 *  User data for POST form.
	 */
	char **post_data;
	char buf[1024];

	/*
	 *  On Unix, conflicts with curses when interactive
	 *  so let's force a dump.  - CL
	 *
	 *  On VMS, mods have been made in LYCurses.c to deal with
	 *  potential conflicts, so don't force a dump here. - FM
	 */
d2409 2
a2410 2
	dump_output_immediately = TRUE;
	LYcols = 80;
d2413 1
a2413 1
	post_data = &form_post_data;
d2415 7
a2421 7
	/*
	 *  Build post data for later.	Stop reading when we see a line
	 *  with "---" as its first three characters.
	 */
	while (fgets(buf, sizeof(buf), stdin) &&
	       strncmp(buf, "---", 3) != 0) {
	    int j;
d2423 3
a2425 5
	    for (j = strlen(buf) - 1; j >= 0 && /* Strip line terminators */
		(buf[j] == CR || buf[j] == LF); j--) {
		buf[j] = '\0';
	    }
	    StrAllocCat(*post_data, buf);
d2427 1
a2427 15

    } else if (strncmp(argv[0], "-preparsed", 9) == 0) {
	LYPreparsedSource = TRUE;

    } else if (strncmp(argv[0], "-print", 6) == 0) {
	no_print=FALSE;

    } else if (strncmp(argv[0], "-pseudo_inlines", 15) == 0) {
	if (pseudo_inline_alts)
	    pseudo_inline_alts = FALSE;
	else
	    pseudo_inline_alts = TRUE;

    } else {
	goto Output_Error_and_Help_List;
d2429 2
a2430 1
    break;
d2432 5
a2436 15
    case 'r':
    if (strncmp(argv[0], "-raw", 4) == 0) {
	LYUseDefaultRawMode = FALSE;

    } else if (strncmp(argv[0], "-realm", 6) == 0) {
	check_realm = TRUE;

    } else if (strncmp(argv[0], "-reload", 7) == 0) {
	reloading = TRUE;

    } else if (strncmp(argv[0], "-restrictions", 13) == 0) {
	if ((cp=strchr(argv[0],'=')) != NULL)
	    parse_restrictions(cp+1);
	else {
		static CONST char *Usage[] = {
d2512 2
a2513 15
		};
		size_t n;
		for (n = 0; n < sizeof(Usage)/sizeof(Usage[0]); n++)
			printf("%s\n", Usage[n]);
		exit(0);
	    }

    } else if (strncmp(argv[0], "-resubmit_posts", 15) == 0) {
	if (LYresubmit_posts)
	    LYresubmit_posts = FALSE;
	else
	    LYresubmit_posts = TRUE;

    } else if (strncmp(argv[0], "-rlogin", 7) == 0) {
	rlogin_ok = FALSE;
d2515 2
d2518 5
a2522 1
	goto Output_Error_and_Help_List;
d2524 2
a2525 1
    break;
d2527 7
a2533 3
    case 's':
    if (strncmp(argv[0], "-selective", 10) == 0) {
	HTDirAccess = HT_DIR_SELECTIVE;
d2535 10
a2544 2
    } else if (strncmp(argv[0], "-show_cursor", 12) == 0) {
	LYUseDefShoCur = FALSE;
d2546 10
a2555 5
    } else if (strncmp(argv[0], "-soft_dquotes", 13) == 0) {
	if (soft_dquotes)
	    soft_dquotes = FALSE;
	else
	    soft_dquotes = TRUE;
d2557 2
a2558 5
    } else if (strncmp(argv[0], "-source", 7) == 0) {
	dump_output_immediately = TRUE;
	HTOutputFormat = (LYPrependBase ?
	     HTAtom_for("www/download") : HTAtom_for("www/dump"));
	LYcols=999;
d2560 5
a2564 2
    } else if (strncmp(argv[0], "-stack_dump", 11) == 0) {
	stack_dump = TRUE;
d2566 23
a2588 2
    } else if (strncmp(argv[0], "-startfile_ok", 13) == 0) {
	startfile_ok = TRUE;
d2590 6
a2595 7
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    } else if (strncmp(argv[0], "-syslog", 7) == 0) {
	if (nextarg)
	    StrAllocCopy(syslog_txt, cp);
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d2597 8
a2604 2
    } else {
	goto Output_Error_and_Help_List;
a2605 1
    break;
d2607 2
a2608 3
    case 't':
    if (strncmp(argv[0], "-telnet", 7) == 0) {
	telnet_ok = FALSE;
d2610 456
a3065 3
    } else if (strncmp(argv[0], "-term", 5) == 0) {
	if (nextarg)
	    terminal = cp;
d3067 1
a3067 5
    } else if (strncmp(argv[0], "-tlog", 5) == 0) {
	/*
	 *  Already handled. - FM
	 */
	break;
d3069 1
a3069 5
    } else if (strncmp(argv[0], "-trace", 6) == 0) {
	/*
	 *  Already handled. - FM
	 */
	break;
d3071 11
a3081 7
    } else if (strncmp(argv[0], "-traversal", 10) == 0) {
	traversal = TRUE;
#ifdef USE_SLANG
	LYcols=80;
#else
	LYcols=999;
#endif /* USE_SLANG */
d3083 2
d3086 16
a3101 1
	goto Output_Error_and_Help_List;
d3103 4
a3106 1
    break;
d3108 7
a3114 6
    case 'u':
    if (strncmp(argv[0], "-underscore", 11) == 0) {
	if (use_underscore)
	    use_underscore = FALSE;
	else
	    use_underscore = TRUE;
d3116 5
a3120 6
    } else if (strncmp(argv[0], "-useragent", 10) == 0) {
      /*
       *  Set alternate Lynx User-Agent header.
       */
      if (nextarg)
	  StrAllocCopy(LYUserAgent, cp);
d3122 6
a3127 3
#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
    } else if (strncmp(argv[0], "-use_mouse", 9) == 0) {
	LYUseMouse = TRUE;
d3129 21
a3149 2
    } else {
	goto Output_Error_and_Help_List;
a3150 1
    break;
d3152 4
a3155 7
    case 'v':
    if (strcmp(argv[0], "-validate") == 0) {
	/*
	 *  Follow only http URLs.
	 *  Already handled. - FM
	 */
	break;
d3157 40
a3196 10
    } else if (strncmp(argv[0], "-version", 8) == 0) {
	printf("\n%s Version %s (1998)\n", LYNX_NAME, LYNX_VERSION);
	printf(
 "Copyrights held by the University of Kansas, CERN, and other contributors.\n"
	      );
	printf("Distributed under the GNU General Public License.\n");
	printf(
 "See http://lynx.browser.org/ and the online help for more information.\n\n"
	      );
	exit(0);
d3198 2
a3199 2
    } else if (strncmp(argv[0], "-vikeys", 7) == 0) {
	vi_keys = TRUE;
d3201 6
a3206 4
    } else {
	goto Output_Error_and_Help_List;
    }
    break;
d3208 1
a3208 14
    case 'w':
    if (strncmp(argv[0], "-width", 2) == 0) {
	if (nextarg) {
	    int w = atoi(cp);
	    if (w > 0) {
		dump_output_width = ((w < 999) ? w : 999);
		break;
	    }
	}
	dump_output_width = 80;
    } else {
	goto Output_Error_and_Help_List;
    }
    break;
d3210 5
a3214 4
    default:
Output_Error_and_Help_List:
#ifdef VMS
    printf(" LYNX: Invalid Option: %s\n", argv[0]);
d3216 2
a3217 13
#ifdef UNIX
    if (strncmp(argv[0], "-help", 5) != 0)
	fprintf(stderr, "%s: Invalid Option: %s\n", pgm, argv[0]);
    else
#endif /* UNIX */
	printf("%s: Invalid Option: %s\n", pgm, argv[0]);
#endif /* VMS */
Output_Help_List:
#ifdef VMS
    printf("USAGE: lynx [options] [file]\n");
#else
    printf("USAGE: %s [options] [file]\n",pgm);
#endif /* VMS */
d3219 9
a3227 62
	static CONST char *Options[] = {
 "Options are:"
,"    -                receive the arguments from stdin (enclose"
,"                     in double-quotes (\"-\") on VMS)"
,"    -anonymous       used to specify the anonymous account"
,"    -assume_charset=MIMEname  charset for documents that don't specify it"
,"    -assume_local_charset=MIMEname  charset assumed for local files"
,"    -assume_unrec_charset=MIMEname  use this instead of unrecognized charsets"
,"    -auth=id:pw      authentication information for protected documents"
,"    -base            prepend a request URL comment and BASE tag to text/html"
,"                     outputs for -source dumps"
,"    -book            use the bookmark page as the startfile"
,"    -buried_news     toggles scanning of news articles for buried references"
,"    -cache=NUMBER    NUMBER of documents cached in memory"
,"    -case            enable case sensitive user searching"
,"    -cfg=FILENAME    specifies a lynx.cfg file other than the default"
,"    -child           exit on left-arrow in startfile, and disable save to disk"
#ifdef USE_SLANG
,"    -color           force color mode on with standard bg colors"
,"    -blink           force high intensity bg colors in color mode"
#endif /* USE_SLANG */
,"    -cookies         toggles handling of Set-Cookie headers"
#ifndef VMS
,"    -core            toggles forced core dumps on fatal errors"
#endif /* !VMS */
,"    -crawl           with -traversal, output each page to a file"
,"                     with -dump, format output as with -traversal, but to stdout"
,"    -display=DISPLAY set the display variable for X execed programs"
,"    -dump            dump the first file to stdout and exit"
,"    -editor=EDITOR   enable edit mode with specified editor"
,"    -emacskeys       enable emacs-like key movement"
,"    -enable_scrollback  toggles compatibility with comm programs' scrollback"
,"                        keys (may be incompatible with some curses packages)"
,"    -error_file=FILE write the HTTP status code here"
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
#ifndef NEVER_ALLOW_REMOTE_EXEC
,"    -exec            enable local program execution"
#endif /* !NEVER_ALLOW_REMOTE_EXEC */
,"    -locexec         enable local program execution from local files only"
,"    -noexec          disable local program execution (DEFAULT)"
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
,"    -fileversions    include all versions of files in local VMS directory"
,"                     listings"
,"    -force_html      forces the first document to be interpreted as HTML"
,"    -force_secure    toggles forcing of the secure flag for SSL cookies"
,"    -from            toggle transmissions of From headers"
,"    -ftp             disable ftp access"
,"    -get_data        user data for get forms, read from stdin,"
,"                     terminated by '---' on a line"
,"    -head            send a HEAD request"
,"    -help            print this usage message"
,"    -hiddenlinks=[option]  hidden links: options are merge, listonly, or ignore"
,"    -historical      toggles use of '>' or '-->' as a terminator for comments"
,"    -homepage=URL    set homepage separate from start page"
,"    -image_links     toggles inclusion of links for all images"
,"    -index=URL       set the default index file to URL"
,"    -ismap           toggles inclusion of ISMAP links when client-side"
,"                     MAPs are present"
,"    -link=NUMBER     starting count for lnk#.dat files produced by -crawl"
,"    -localhost       disable URLs that point to remote hosts"
#if defined(USE_HASH)
,"    -lss=FILENAME    specifies a lynx.css file other than the default"
d3229 22
a3250 56
,"    -mime_header     include mime headers and force source dump"
,"    -minimal         toggles minimal versus valid comment parsing"
,"    -newschunksize=NUMBER  number of articles in chunked news listings"
,"    -newsmaxchunk=NUMBER   maximum news articles in listings before chunking"
,"    -nobrowse        disable directory browsing"
,"    -nocc            disable Cc: prompts for self copies of mailings"
,"    -nofilereferer   disable transmissions of Referer headers for file URLs"
,"    -nolist          disable the link list feature in dumps"
,"    -nolog           disable mailing of error messages to document owners"
,"    -nopause         disable forced pauses for statusline messages"
,"    -noprint         disable print functions"
,"    -noredir         don't follow Location: redirection"
,"    -noreferer       disable transmissions of Referer headers"
#ifdef SOCKS
,"    -nosocks         don't use SOCKS proxy for this session"
#endif /* SOCKS */
,"    -nostatus        disable the miscellaneous information messages"
,"    -number_links    force numbering of links"
,"    -pauth=id:pw     authentication information for protected proxy server"
,"    -popup           toggles handling of single-choice SELECT options via"
,"                     popup windows or as lists of radio buttons"
,"    -post_data       user data for post forms, read from stdin,"
,"                     terminated by '---' on a line"
,"    -preparsed       show parsed text/html with -source and in source view"
,"    -print           enable print functions (DEFAULT)"
,"    -pseudo_inlines  toggles pseudo-ALTs for inlines with no ALT string"
,"    -raw             toggles default setting of 8-bit character translations"
,"                     or CJK mode for the startup character set"
,"    -realm           restricts access to URLs in the starting realm"
,"    -reload          flushes the cache on a proxy server"
,"                     (only the first document affected)"
,"    -restrictions=[options]  use -restrictions to see list"
,"    -resubmit_posts  toggles forced resubmissions (no-cache) of forms with"
,"                     method POST when the documents they returned are sought"
,"                     with the PREV_DOC command or from the History List"
,"    -rlogin          disable rlogins"
,"    -selective       require .www_browsable files to browse directories"
,"    -show_cursor     toggles hiding of the cursor in the lower right corner"
,"    -soft_dquotes    toggles emulation of the old Netscape and Mosaic bug which"
,"                     treated '>' as a co-terminator for double-quotes and tags"
,"    -source          dump the source of the first file to stdout and exit"
,"    -startfile_ok    allow non-http startfile and homepage with -validate"
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
,"    -syslog=text     information for syslog call"
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
,"    -telnet          disable telnets"
,"    -term=TERM       set terminal type to TERM"
,"    -tlog            toggles use of a Lynx Trace Log for the current session"
,"    -trace           turns on Lynx trace mode"
,"    -traversal       traverse all http links derived from startfile"
,"    -underscore      toggles use of _underline_ format in dumps"
,"    -useragent=Name  set alternate Lynx User-Agent header"
#if defined(NCURSES_MOUSE_VERSION) || defined(USE_SLANG_MOUSE)
,"    -use_mouse       enable use of the mouse"
d3252 69
a3320 8
,"    -validate        accept only http URLs (for validation)"
,"    -version         print Lynx version information"
,"    -vikeys          enable vi-like key movement"
,"    -width=NUMBER    screen width for formatting of dumps (default is 80)"
	};
	size_t n;
	for (n = 0; n < sizeof(Options)/sizeof(Options[0]); n++)
	    printf("%s\n", Options[n]);
a3321 4
    if (strncmp(argv[0], "-help", 5) != 0)
	exit(-1);
    exit(0);
    break;
d3323 4
a3326 1
    } /* end of switch. */
@


1.2
log
@mkdtemp a directory where Lynx puts all it's temporary files.
Fixing creation of all temp files would involve rewriting Lynx.
@
text
@a1733 1
	    cleanup();
d1736 1
@


1.1
log
@Initial revision
@
text
@d745 2
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
