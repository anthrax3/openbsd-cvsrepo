head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.52.36;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.09;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.54;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.54;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYKeymap.c,v 1.110 2013/12/17 00:27:55 tom Exp $ */
#include <HTUtils.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYKeymap.h>
#include <LYCharSets.h>		/* for LYlowest_eightbit - kw */
#include <HTAccess.h>
#include <HTFormat.h>
#include <HTAlert.h>
#include <LYStrings.h>		/* for USE_KEYMAP stuff - kw */

#include <LYLeaks.h>

#ifdef EXP_KEYBOARD_LAYOUT
#include <jcuken_kb.h>
#include <yawerty_kb.h>
#include <rot13_kb.h>
#endif

#define PUTS(buf)    (*target->isa->put_block)(target, buf, (int) strlen(buf))

#ifdef EXP_KEYBOARD_LAYOUT
int current_layout = 0;		/* Index into LYKbLayouts[]   */

LYKbLayout_t *LYKbLayouts[] =
{
    kb_layout_rot13,
    kb_layout_jcuken,
    kb_layout_yawerty
};

const char *LYKbLayoutNames[] =
{
    "ROT13'd keyboard layout",
    "JCUKEN Cyrillic, for AT 101-key kbd",
    "YAWERTY Cyrillic, for DEC LK201 kbd",
    (char *) 0
};
#endif /* EXP_KEYBOARD_LAYOUT */

/* * * Tables mapping LynxKeyCodes to LynxActionCodes  * * */

/*
 * Lynxkeycodes include all single-byte keys as well as codes for function keys
 * and some special purposes.  See LYStrings.h.  Extended lynxkeycode values
 * can also contain flags for modifiers and other purposes, but here only the
 * base values are mapped to lynxactioncodes.  They are called `keystrokes' in
 * lynx.cfg.
 *
 * Lynxactioncodes (confusingly, constants are named LYK_foo and typed as
 * specify key `functions', see LYKeymap.h.
 */

/* the character gets 1 added to it before lookup,
 * so that EOF maps to 0
 */
LYKeymap_t keymap[KEYMAP_SIZE];

static const LYEditInit initKeymapData[] =
{
    {1, LYK_DO_NOTHING},	/* nul */
    {2, LYK_HOME},		/* ^B */
    {3, LYK_PREV_PAGE},		/* ^C */
    {5, LYK_ABORT},		/* ^E */
    {6, LYK_END},		/* ^F */
    {7, LYK_NEXT_PAGE},		/* ^G */
    {9, LYK_HISTORY},		/* ^I */
    {10, LYK_FASTFORW_LINK},	/* ^J */
    {11, LYK_ACTIVATE},		/* ^K */
    {12, LYK_COOKIE_JAR},	/* ^L */
    {13, LYK_REFRESH},		/* ^M */
    {14, LYK_ACTIVATE},		/* ^N */
    {15, LYK_DOWN_TWO},		/* ^O */
    {17, LYK_UP_TWO},		/* ^Q */
    {18, LYK_CHANGE_CENTER},	/* XON */
    {19, LYK_RELOAD},		/* ^S */
    {20, LYK_TO_CLIPBOARD},	/* XOFF */
    {21, LYK_TRACE_TOGGLE},	/* ^U */
    {22, LYK_NEXT_DOC},		/* ^V */
    {23, LYK_SWITCH_DTD},	/* ^W */
    {24, LYK_REFRESH},		/* ^X */
    {25, LYK_CACHE_JAR},	/* ^Y */
    {27, LYK_MAXSCREEN_TOGGLE},	/* ^Z */
    {33, LYK_NEXT_PAGE},	/*   */
    {34, LYK_SHELL},		/* ! */
    {35, LYK_SOFT_DQUOTES},	/* " */
    {36, LYK_TOOLBAR},		/* # */
    {37, LYK_LAST_LINK},	/* $ */
    {40, LYK_HISTORICAL},	/* ' */
    {41, LYK_UP_HALF},		/* ( */
    {42, LYK_DOWN_HALF},	/* ) */
    {43, LYK_IMAGE_TOGGLE},	/* * */
    {44, LYK_NEXT_PAGE},	/* + */
    {45, LYK_EXTERN_PAGE},	/* , */
    {46, LYK_PREV_PAGE},	/* - */
    {47, LYK_EXTERN_LINK},	/* . */
    {48, LYK_WHEREIS},		/* / */
    {49, LYK_F_LINK_NUM},	/* 0 */
    {50, LYK_1},		/* 1 */
    {51, LYK_2},		/* 2 */
    {52, LYK_3},		/* 3 */
    {53, LYK_4},		/* 4 */
    {54, LYK_5},		/* 5 */
    {55, LYK_6},		/* 6 */
    {56, LYK_7},		/* 7 */
    {57, LYK_8},		/* 8 */
    {58, LYK_9},		/* 9 */
    {59, LYK_COMMAND},		/* : */
    {60, LYK_TRACE_LOG},	/* ; */
    {61, LYK_UP_LINK},		/* < */
    {62, LYK_INFO},		/* = */
    {63, LYK_DOWN_LINK},	/* > */
    {64, LYK_HELP},		/* ? */
    {65, LYK_RAW_TOGGLE},	/* @@ */
    {66, LYK_ADDRLIST},		/* A */
    {67, LYK_PREV_PAGE},	/* B */
#ifdef SUPPORT_CHDIR
    {68, LYK_CHDIR},		/* C */
#else
    {68, LYK_COMMENT},		/* C */
#endif
    {69, LYK_DOWNLOAD},		/* D */
    {70, LYK_ELGOTO},		/* E */
    {71, LYK_DIRED_MENU},	/* F */
    {72, LYK_ECGOTO},		/* G */
    {73, LYK_HELP},		/* H */
    {74, LYK_INDEX},		/* I */
#ifdef KANJI_CODE_OVERRIDE
    {75, LYK_CHANGE_KCODE},	/* J */
#else
    {75, LYK_JUMP},		/* J */
#endif
    {76, LYK_KEYMAP},		/* K */
    {77, LYK_LIST},		/* L */
    {78, LYK_MAIN_MENU},	/* M */
    {79, LYK_PREV},		/* N */
    {80, LYK_OPTIONS},		/* O */
    {81, LYK_PRINT},		/* P */
    {82, LYK_ABORT},		/* Q */
    {83, LYK_DEL_BOOKMARK},	/* R */
    {84, LYK_INDEX_SEARCH},	/* S */
    {85, LYK_TAG_LINK},		/* T */
    {86, LYK_PREV_DOC},		/* U */
    {87, LYK_VLINKS},		/* V */
    {89, LYK_NOCACHE},		/* X */
    {91, LYK_INTERRUPT},	/* Z */
    {92, LYK_INLINE_TOGGLE},	/* [ */
    {93, LYK_SOURCE},		/* \ */
    {94, LYK_HEAD},		/* ] */
    {95, LYK_FIRST_LINK},	/* ^ */
    {96, LYK_CLEAR_AUTH},	/* _ */
    {97, LYK_MINIMAL},		/* ` */
    {98, LYK_ADD_BOOKMARK},	/* a */
    {99, LYK_PREV_PAGE},	/* b */
    {100, LYK_COMMENT},		/* c */
    {101, LYK_DOWNLOAD},	/* d */
    {102, LYK_EDIT},		/* e */
    {103, LYK_DIRED_MENU},	/* f */
    {104, LYK_GOTO},		/* g */
    {105, LYK_HELP},		/* h */
    {106, LYK_INDEX},		/* i */
    {107, LYK_JUMP},		/* j */
    {108, LYK_KEYMAP},		/* k */
    {109, LYK_LIST},		/* l */
    {110, LYK_MAIN_MENU},	/* m */
    {111, LYK_NEXT},		/* n */
    {112, LYK_OPTIONS},		/* o */
    {113, LYK_PRINT},		/* p */
    {114, LYK_QUIT},		/* q */
    {115, LYK_DEL_BOOKMARK},	/* r */
    {116, LYK_INDEX_SEARCH},	/* s */
    {117, LYK_TAG_LINK},	/* t */
    {118, LYK_PREV_DOC},	/* u */
    {119, LYK_VIEW_BOOKMARK},	/* v */
    {121, LYK_NOCACHE},		/* x */
    {123, LYK_INTERRUPT},	/* z */
    {124, LYK_SHIFT_LEFT},	/* { */
    {125, LYK_LINEWRAP_TOGGLE},	/* | */
    {126, LYK_SHIFT_RIGHT},	/* } */
    {127, LYK_NESTED_TABLES},	/* ~ */
    {128, LYK_HISTORY},		/* DEL */
    {257, LYK_PREV_LINK},	/* UPARROW_KEY */
    {258, LYK_NEXT_LINK},	/* DNARROW_KEY */
    {259, LYK_ACTIVATE},	/* RTARROW_KEY */
    {260, LYK_PREV_DOC},	/* LTARROW_KEY */
    {261, LYK_NEXT_PAGE},	/* PGDOWN_KEY */
    {262, LYK_PREV_PAGE},	/* PGUP_KEY */
    {263, LYK_HOME},		/* HOME_KEY */
    {264, LYK_END},		/* END_KEY */
    {265, LYK_DWIMHELP},	/* F1_KEY */
#if !(defined(_WINDOWS) || defined(__DJGPP__))
    {266, LYK_ACTIVATE},	/* DO_KEY */
    {267, LYK_HOME},		/* FIND_KEY */
    {268, LYK_END},		/* SELECT_KEY */
#endif
    {269, LYK_UP_TWO},		/* INSERT_KEY */
    {270, LYK_DOWN_TWO},	/* REMOVE_KEY */
    {271, LYK_DO_NOTHING},	/* DO_NOTHING */
    {272, LYK_FASTBACKW_LINK},	/* BACKTAB_KEY */
    {282, LYK_DO_NOTHING},	/* F11_KEY */
#ifdef DJGPP_KEYHANDLER
    {302, LYK_ABORT},
#endif				/* DJGPP_KEYHANDLER */
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(USE_SLANG)	/* PDCurses */
    {441, LYK_ABORT},		/* ALT_X */
    {459, LYK_WHEREIS},		/* KP_SLASH */
    {464, LYK_IMAGE_TOGGLE},	/* KP_* */
    {465, LYK_PREV_PAGE},	/* KP_- */
    {466, LYK_NEXT_PAGE},	/* KP_+ */
#endif
    {657, LYK_CHANGE_LINK},
    {-1, LYE_UNKNOWN}
};

static LYEditConfig myKeymapData =
{
    "Key Map", initKeymapData, keymap
};

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
/*
 * This table is used to override the standard keyboard assignments
 * when lynx_edit_mode is in effect and keyboard overrides have been
 * allowed at compile time.
 */

LYKeymap_t key_override[KEYMAP_SIZE];

static const LYEditInit initOverrideData[] =
{
    {22, LYK_NEXT_DOC},		/* ^V */
    {47, LYK_TAG_LINK},		/* . */
#ifndef SUPPORT_CHDIR
    {68, LYK_CREATE},		/* C */
#else
    {68, LYK_CHDIR},		/* C */
#endif
    {71, LYK_DIRED_MENU},	/* F */
    {78, LYK_MODIFY},		/* M */
    {83, LYK_REMOVE},		/* R */
    {85, LYK_TAG_LINK},		/* T */
    {86, LYK_UPLOAD},		/* U */
    {100, LYK_CREATE},		/* c */
    {103, LYK_DIRED_MENU},	/* f */
    {110, LYK_MODIFY},		/* m */
    {115, LYK_REMOVE},		/* r */
    {117, LYK_TAG_LINK},	/* t */
    {118, LYK_UPLOAD},		/* u */
    {271, LYK_DO_NOTHING},	/* DO_NOTHING */
    {-1, LYE_UNKNOWN}
};

static LYEditConfig myOverrideData =
{
    "Key Override", initOverrideData, key_override
};
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

#define DATA(code, name, doc) { code, name, doc }
/* The order of this array must match the LYKeymapCode enum in LYKeymap.h */
static Kcmd revmap[] =
{
    DATA(
	    LYK_UNKNOWN, "UNMAPPED",
	    NULL),
    DATA(
	    LYK_COMMAND, "COMMAND",
	    "prompt for, execute a command"),
    DATA(
	    LYK_1, "1",
	    NULL),
    DATA(
	    LYK_2, "2",
	    NULL),
    DATA(
	    LYK_3, "3",
	    NULL),
    DATA(
	    LYK_4, "4",
	    NULL),
    DATA(
	    LYK_5, "5",
	    NULL),
    DATA(
	    LYK_6, "6",
	    NULL),
    DATA(
	    LYK_7, "7",
	    NULL),
    DATA(
	    LYK_8, "8",
	    NULL),
    DATA(
	    LYK_9, "9",
	    NULL),
    DATA(
	    LYK_SOURCE, "SOURCE",
	    "toggle source/presentation for current document"),
    DATA(
	    LYK_RELOAD, "RELOAD",
	    "reload the current document"),
    DATA(
	    LYK_QUIT, "QUIT",
	    "quit the browser"),
    DATA(
	    LYK_ABORT, "ABORT",
	    "quit the browser unconditionally"),
    DATA(
	    LYK_NEXT_PAGE, "NEXT_PAGE",
	    "view the next page of the document"),
    DATA(
	    LYK_PREV_PAGE, "PREV_PAGE",
	    "view the previous page of the document"),
    DATA(
	    LYK_UP_TWO, "UP_TWO",
	    "go back two lines in the document"),
    DATA(
	    LYK_DOWN_TWO, "DOWN_TWO",
	    "go forward two lines in the document"),
    DATA(
	    LYK_UP_HALF, "UP_HALF",
	    "go back half a page in the document"),
    DATA(
	    LYK_DOWN_HALF, "DOWN_HALF",
	    "go forward half a page in the document"),
    DATA(
	    LYK_REFRESH, "REFRESH",
	    "refresh the screen to clear garbled text"),
    DATA(
	    LYK_HOME, "HOME",
	    "go to the beginning of the current document"),
    DATA(
	    LYK_END, "END",
	    "go to the end of the current document"),
    DATA(
	    LYK_FIRST_LINK, "FIRST_LINK",
	    "make the first link on the line current"),
    DATA(
	    LYK_LAST_LINK, "LAST_LINK",
	    "make the last link on the line current"),
    DATA(
	    LYK_PREV_LINK, "PREV_LINK",
	    "make the previous link current"),
    DATA(
	    LYK_NEXT_LINK, "NEXT_LINK",
	    "make the next link current"),
    DATA(
	    LYK_LPOS_PREV_LINK, "LPOS_PREV_LINK",
	    "make previous link current, same column for input"),
    DATA(
	    LYK_LPOS_NEXT_LINK, "LPOS_NEXT_LINK",
	    "make next link current, same column for input"),
    DATA(
	    LYK_FASTBACKW_LINK, "FASTBACKW_LINK",
	    "previous link or text area, only stops on links"),
    DATA(
	    LYK_FASTFORW_LINK, "FASTFORW_LINK",
	    "next link or text area, only stops on links"),
    DATA(
	    LYK_UP_LINK, "UP_LINK",
	    "move up the page to a previous link"),
    DATA(
	    LYK_DOWN_LINK, "DOWN_LINK",
	    "move down the page to another link"),
    DATA(
	    LYK_RIGHT_LINK, "RIGHT_LINK",
	    "move right to another link"),
    DATA(
	    LYK_LEFT_LINK, "LEFT_LINK",
	    "move left to a previous link"),
    DATA(
	    LYK_HISTORY, "HISTORY",
	    "display stack of currently-suspended documents"),
    DATA(
	    LYK_PREV_DOC, "PREV_DOC",
	    "go back to the previous document"),
    DATA(
	    LYK_NEXT_DOC, "NEXT_DOC",
	    "undo going back to the previous document"),
    DATA(
	    LYK_ACTIVATE, "ACTIVATE",
	    "go to the document given by the current link"),
    DATA(
	    LYK_MOUSE_SUBMIT, "MOUSE_SUBMIT",
	    "DO NOT MAP:  follow current link, submit"),
    DATA(
	    LYK_SUBMIT, "SUBMIT",
	    "prompt and submit form"),
    DATA(
	    LYK_RESET, "RESET",
	    "reset fields on current form"),
    DATA(
	    LYK_GOTO, "GOTO",
	    "go to a document given as a URL"),
    DATA(
	    LYK_ECGOTO, "ECGOTO",
	    "edit the current document's URL and go to it"),
    DATA(
	    LYK_HELP, "HELP",
	    "display help on using the browser"),
    DATA(
	    LYK_DWIMHELP, "DWIMHELP",
	    "display help page that may depend on context"),
    DATA(
	    LYK_INDEX, "INDEX",
	    "display an index of potentially useful documents"),
    DATA(
	    LYK_NOCACHE, "NOCACHE",
	    "force submission of form or link with no-cache"),
    DATA(
	    LYK_INTERRUPT, "INTERRUPT",
	    "interrupt network connection or transmission"),
    DATA(
	    LYK_MAIN_MENU, "MAIN_MENU",
	    "return to the first screen (home page)"),
    DATA(
	    LYK_OPTIONS, "OPTIONS",
	    "display and change option settings"),
    DATA(
	    LYK_INDEX_SEARCH, "INDEX_SEARCH",
	    "allow searching of an index"),
    DATA(
	    LYK_WHEREIS, "WHEREIS",
	    "search within the current document"),
    DATA(
	    LYK_PREV, "PREV",
	    "search for the previous occurence"),
    DATA(
	    LYK_NEXT, "NEXT",
	    "search for the next occurence"),
    DATA(
	    LYK_COMMENT, "COMMENT",
	    "send a comment to the author of the current document"),
    DATA(
	    LYK_EDIT, "EDIT",
	    "edit the current document or a form's textarea"),
    DATA(
	    LYK_INFO, "INFO",
	    "display information on the current document and link"),
    DATA(
	    LYK_PRINT, "PRINT",
	    "display choices for printing the current document"),
    DATA(
	    LYK_ADD_BOOKMARK, "ADD_BOOKMARK",
	    "add to your personal bookmark list"),
    DATA(
	    LYK_DEL_BOOKMARK, "DEL_BOOKMARK",
	    "delete from your personal bookmark list"),
    DATA(
	    LYK_VIEW_BOOKMARK, "VIEW_BOOKMARK",
	    "view your personal bookmark list"),
    DATA(
	    LYK_VLINKS, "VLINKS",
	    "list links visited during the current Lynx session"),
    DATA(
	    LYK_SHELL, "SHELL",
	    "escape from the browser to the system"),
    DATA(
	    LYK_DOWNLOAD, "DOWNLOAD",
	    "download the current link to your computer"),
    DATA(
	    LYK_TRACE_TOGGLE, "TRACE_TOGGLE",
	    "toggle tracing of browser operations"),
    DATA(
	    LYK_TRACE_LOG, "TRACE_LOG",
	    "view trace log if started in the current session"),
    DATA(
	    LYK_IMAGE_TOGGLE, "IMAGE_TOGGLE",
	    "toggle handling of all images as links"),
    DATA(
	    LYK_INLINE_TOGGLE, "INLINE_TOGGLE",
	    "toggle pseudo-ALTs for inlines with no ALT string"),
    DATA(
	    LYK_HEAD, "HEAD",
	    "send a HEAD request for the current document or link"),
    DATA(
	    LYK_DO_NOTHING, "DO_NOTHING",
	    NULL),
    DATA(
	    LYK_TOGGLE_HELP, "TOGGLE_HELP",
	    "show other commands in the novice help menu"),
    DATA(
	    LYK_JUMP, "JUMP",
	    "go directly to a target document or action"),
    DATA(
	    LYK_EDITMAP, "EDITMAP",
	    "display the current edit-key map"),
    DATA(
	    LYK_KEYMAP, "KEYMAP",
	    "display the current key map"),
    DATA(
	    LYK_LIST, "LIST",
	    "list the references (links) in the current document"),
    DATA(
	    LYK_TOOLBAR, "TOOLBAR",
	    "go to Toolbar or Banner in the current document"),
    DATA(
	    LYK_HISTORICAL, "HISTORICAL",
	    "toggle historical vs.  valid/minimal comment parsing"),
    DATA(
	    LYK_MINIMAL, "MINIMAL",
	    "toggle minimal vs.  valid comment parsing"),
    DATA(
	    LYK_SOFT_DQUOTES, "SOFT_DQUOTES",
	    "toggle valid vs.  soft double-quote parsing"),
    DATA(
	    LYK_RAW_TOGGLE, "RAW_TOGGLE",
	    "toggle raw 8-bit translations or CJK mode ON or OFF"),
    DATA(
	    LYK_COOKIE_JAR, "COOKIE_JAR",
	    "examine the Cookie Jar"),
    DATA(
	    LYK_F_LINK_NUM, "F_LINK_NUM",
	    "invoke the 'Follow link (or page) number:' prompt"),
    DATA(
	    LYK_CLEAR_AUTH, "CLEAR_AUTH",
	    "clear all authorization info for this session"),
    DATA(
	    LYK_SWITCH_DTD, "SWITCH_DTD",
	    "switch between two ways of parsing HTML"),
    DATA(
	    LYK_ELGOTO, "ELGOTO",
	    "edit the current link's URL or ACTION and go to it"),
    DATA(
	    LYK_CHANGE_LINK, "CHANGE_LINK",
	    "force reset of the current link on the page"),
    DATA(
	    LYK_DWIMEDIT, "DWIMEDIT",
	    "use external editor for context-dependent purpose"),
    DATA(
	    LYK_EDITTEXTAREA, "EDITTEXTAREA",
	    "use an external editor to edit a form's textarea"),
    DATA(
	    LYK_GROWTEXTAREA, "GROWTEXTAREA",
	    "add 5 new blank lines to the bottom of a textarea"),
    DATA(
	    LYK_INSERTFILE, "INSERTFILE",
	    "insert file into a textarea (just above cursorline)"),
#ifdef USE_ADDRLIST_PAGE
    DATA(
	    LYK_ADDRLIST, "ADDRLIST",
	    "like LIST command, but always shows the links' URLs"),
#endif
#ifdef USE_EXTERNALS
    DATA(
	    LYK_EXTERN_LINK, "EXTERN_LINK",
	    "run external program with current link"),
    DATA(
	    LYK_EXTERN_PAGE, "EXTERN_PAGE",
	    "run external program with current page"),
#endif
#ifdef VMS
    DATA(
	    LYK_DIRED_MENU, "DIRED_MENU",
	    "invoke File/Directory Manager, if available"),
#else
#ifdef DIRED_SUPPORT
    DATA(
	    LYK_DIRED_MENU, "DIRED_MENU",
	    "display a full menu of file operations"),
    DATA(
	    LYK_CREATE, "CREATE",
	    "create a new file or directory"),
    DATA(
	    LYK_REMOVE, "REMOVE",
	    "remove a file or directory"),
    DATA(
	    LYK_MODIFY, "MODIFY",
	    "modify the name or location of a file or directory"),
    DATA(
	    LYK_TAG_LINK, "TAG_LINK",
	    "tag a file or directory for later action"),
    DATA(
	    LYK_UPLOAD, "UPLOAD",
	    "upload from your computer to the current directory"),
    DATA(
	    LYK_INSTALL, "INSTALL",
	    "install file or tagged files into a system area"),
#endif				/* DIRED_SUPPORT */
    DATA(
	    LYK_CHANGE_CENTER, "CHANGE_CENTER",
	    "toggle center alignment in HTML TABLE"),
#ifdef KANJI_CODE_OVERRIDE
    DATA(
	    LYK_CHANGE_KCODE, "CHANGE_KCODE",
	    "Change Kanji code"),
#endif
#endif				/* VMS */
#ifdef SUPPORT_CHDIR
    DATA(
	    LYK_CHDIR, "CHDIR",
	    "change current directory"),
    DATA(
	    LYK_PWD, "PWD",
	    "print current directory"),
#endif
#ifdef USE_CURSES_PADS
    DATA(
	    LYK_SHIFT_LEFT, "SHIFT_LEFT",
	    "shift the screen left"),
    DATA(
	    LYK_SHIFT_RIGHT, "SHIFT_RIGHT",
	    "shift the screen right"),
    DATA(
	    LYK_LINEWRAP_TOGGLE, "LINEWRAP_TOGGLE",
	    "toggle linewrap on/off"),
#endif
#ifdef CAN_CUT_AND_PASTE
    DATA(
	    LYK_PASTE_URL, "PASTE_URL",
	    "Goto the URL in the clipboard"),
    DATA(
	    LYK_TO_CLIPBOARD, "TO_CLIPBOARD",
	    "link's URL to Clip Board"),
#endif
#ifdef EXP_NESTED_TABLES
    DATA(
	    LYK_NESTED_TABLES, "NESTED_TABLES",
	    "toggle nested-table parsing on/off"),
#endif
#ifdef USE_CACHEJAR
    DATA(
	    LYK_CACHE_JAR, "CACHE_JAR",
	    "examine list of cached documents"),
#endif
#ifdef USE_MAXSCREEN_TOGGLE
    DATA(
	    LYK_MAXSCREEN_TOGGLE, "MAXSCREEN_TOGGLE",
	    "toggle max screen and normal"),
#endif
    DATA(
	    LYK_UNKNOWN, NULL,
	    "")
};

#undef DATA
/* *INDENT-OFF* */
static const struct {
    int key;
    const char *name;
} named_keys[] = {
    { '\t',		"<tab>" },
    { '\r',		"<return>" },
    { CH_ESC,		"ESC" },
    { ' ',		"<space>" },
    { '<',		"<" },
    { '>',		">" },
    /* LYExtraKeys */
    { CH_DEL,		"<delete>" },
    { UPARROW_KEY,	"Up Arrow" },
    { DNARROW_KEY,	"Down Arrow" },
    { RTARROW_KEY,	"Right Arrow" },
    { LTARROW_KEY,	"Left Arrow" },
    { PGDOWN_KEY,	"Page Down" },
    { PGUP_KEY,		"Page Up" },
    { HOME_KEY,		"Home" },
    { END_KEY,		"End" },
    { F1_KEY,		"F1" },
    { F2_KEY,		"F2" },
    { F3_KEY,		"F3" },
    { F4_KEY,		"F4" },
    { F5_KEY,		"F5" },
    { F6_KEY,		"F6" },
    { F7_KEY,		"F7" },
    { F8_KEY,		"F8" },
    { F9_KEY,		"F9" },
    { F10_KEY,		"F10" },
    { F11_KEY,		"F11" },
    { F12_KEY,		"F12" },
    { DO_KEY,		"Do key" },
    { FIND_KEY,		"Find key" },
    { SELECT_KEY,	"Select key" },
    { INSERT_KEY,	"Insert key" },
    { REMOVE_KEY,	"Remove key" },
    { DO_NOTHING,	"(DO_NOTHING)" },
    { BACKTAB_KEY,	"Back Tab" },
    { MOUSE_KEY,	"mouse pseudo key" },
};
/* *INDENT-ON* */

/*
 * Build a list of Lynx's commands, for use in the tab-completion in LYgetstr.
 */
HTList *LYcommandList(void)
{
    static HTList *myList = NULL;

    if (myList == NULL) {
	unsigned j;

	myList = HTList_new();
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].doc != 0) {
		char *data = NULL;

		StrAllocCopy(data, revmap[j].name);
		HTList_addObject(myList, data);
	    }
	}
    }
    return myList;
}

/*
 * Find the given keycode.
 */
Kcmd *LYKeycodeToKcmd(LYKeymapCode code)
{
    unsigned j;
    Kcmd *result = 0;

    if (code > LYK_UNKNOWN) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (revmap[j].code == code) {
		result = revmap + j;
		break;
	    }
	}
    }
    return result;
}

/*
 * Find the given command-name, accepting an abbreviation if it is unique.
 */
Kcmd *LYStringToKcmd(const char *name)
{
    size_t need = strlen(name);
    size_t j;
    BOOL exact = FALSE;
    Kcmd *result = 0;
    Kcmd *maybe = 0;

    if (non_empty(name)) {
	for (j = 0; revmap[j].name != 0; j++) {
	    if (!strcasecomp(revmap[j].name, name)) {
		result = revmap + j;
		break;
	    } else if (!exact
		       && !strncasecomp(revmap[j].name, name, (int) need)) {
		if (maybe == 0) {
		    maybe = revmap + j;
		} else {
		    if (revmap[j].name[need] != 0
			&& maybe->name[need] != 0) {
			maybe = 0;
			exact = TRUE;
		    }
		}
	    }
	}
    }
    return (result != 0) ? result : maybe;
}

char *LYKeycodeToString(int c,
			int upper8)
{
    static char buf[30];
    unsigned n;
    BOOLEAN named = FALSE;

    for (n = 0; n < TABLESIZE(named_keys); n++) {
	if (named_keys[n].key == c) {
	    named = TRUE;
	    LYStrNCpy(buf, named_keys[n].name, sizeof(buf) - 1);
	    break;
	}
    }

    if (!named) {
	if (c <= 0377
	    && TOASCII(c) > TOASCII(' ')
	    && TOASCII(c) < 0177)
	    sprintf(buf, "%c", c);
	else if (upper8
		 && TOASCII(c) > TOASCII(' ')
		 && c <= 0377
		 && c <= LYlowest_eightbit[current_char_set])
	    sprintf(buf, "%c", c);
	else if (TOASCII(c) < TOASCII(' '))
	    sprintf(buf, "^%c", FROMASCII(TOASCII(c) | 0100));
	else if (c >= 0400)
	    sprintf(buf, "key-0x%x", c);
	else
	    sprintf(buf, "0x%x", c);
    }
    return buf;
}

int LYStringToKeycode(char *src)
{
    unsigned n;
    int key = -1;
    int len = (int) strlen(src);

    if (len == 1) {
	key = *src;
    } else if (len == 2 && *src == '^') {
	key = src[1] & 0x1f;
    } else if (len > 2 && !strncasecomp(src, "0x", 2)) {
	char *dst = 0;

	key = (int) strtol(src, &dst, 0);
	if (non_empty(dst))
	    key = -1;
    } else if (len > 6 && !strncasecomp(src, "key-", 4)) {
	char *dst = 0;

	key = (int) strtol(src + 4, &dst, 0);
	if (isEmpty(dst))
	    key = -1;
    }
    if (key < 0) {
	for (n = 0; n < TABLESIZE(named_keys); n++) {
	    if (!strcasecomp(named_keys[n].name, src)) {
		key = named_keys[n].key;
		break;
	    }
	}
    }
    return key;
}

#define PRETTY_LEN 11

static char *pretty_html(int c)
{
    char *src = LYKeycodeToString(c, TRUE);

    if (src != 0) {
	/* *INDENT-OFF* */
	static const struct {
	    int	code;
	    const char *name;
	} table[] = {
	    { '<',	"&lt;" },
	    { '>',	"&gt;" },
	    { '"',	"&quot;" },
	    { '&',	"&amp;" }
	};
	/* *INDENT-ON* */

	static char buf[30];
	char *dst = buf;
	int adj = 0;
	unsigned n;
	BOOLEAN found;

	while ((c = *src++) != 0) {
	    found = FALSE;
	    for (n = 0; n < TABLESIZE(table); n++) {
		if (c == table[n].code) {
		    found = TRUE;
		    LYStrNCpy(dst, table[n].name, sizeof(dst) - 1);
		    adj += (int) strlen(dst) - 1;
		    dst += (int) strlen(dst);
		    break;
		}
	    }
	    if (!found) {
		*dst++ = (char) c;
	    }
	}
	adj -= (int) (dst - buf) - PRETTY_LEN;
	while (adj-- > 0)
	    *dst++ = ' ';
	*dst = 0;
	return buf;
    }

    return 0;
}

static char *format_binding(LYKeymap_t *table, int i)
{
    LYKeymap_t the_key = table[i];
    char *buf = 0;
    char *formatted;
    Kcmd *rmap = LYKeycodeToKcmd((LYKeymapCode) the_key);

    if (rmap != 0
	&& rmap->name != 0
	&& rmap->doc != 0
	&& (formatted = pretty_html(i - 1)) != 0) {
	HTSprintf0(&buf, "%-*s %-13s %s\n",
		   PRETTY_LEN, formatted,
		   rmap->name,
		   rmap->doc);
	return buf;
    }
    return 0;
}

/* if both is true, produce an additional line for the corresponding
   uppercase key if its binding is different. - kw */
static void print_binding(HTStream *target, int i, int both)
{
    char *buf;
    LYKeymap_t lac1 = LYK_UNKNOWN;	/* 0 */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support &&
	(lac1 = key_override[i]) != LYK_UNKNOWN) {
	if ((buf = format_binding(key_override, i)) != 0) {
	    PUTS(buf);
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if ((buf = format_binding(keymap, i)) != 0) {
	lac1 = keymap[i];
	PUTS(buf);
	FREE(buf);
    }

    if (!both)
	return;
    i -= ' ';			/* corresponding uppercase key */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    if (prev_lynx_edit_mode && !no_dired_support && key_override[i]) {
	if (key_override[i] != lac1 &&
	    (buf = format_binding(key_override, i)) != 0) {
	    PUTS(buf);
	    FREE(buf);
	}
    } else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
    if (keymap[i] != lac1 && (buf = format_binding(keymap, i)) != 0) {
	PUTS(buf);
	FREE(buf);
    }
}

/*
 * Return lynxactioncode whose name is the string func.  returns -1 if not
 * found.  - kw
 */
int lacname_to_lac(const char *func)
{
    Kcmd *mp = LYStringToKcmd(func);

    return (mp != 0) ? (int) mp->code : -1;
}

/*
 * Return lynxkeycode represented by string src.  returns -1 if not valid.
 *
 * This is simpler than what map_string_to_keysym() does for USE_KEYMAP, but
 * compatible with revmap() used for processing KEYMAP options in the
 * configuration file.  - kw
 */
int lkcstring_to_lkc(const char *src)
{
    int c = -1;

    if (strlen(src) == 1) {
	c = *src;
    } else if (strlen(src) == 2 && *src == '^') {
	c = src[1] & 037;
    } else if (strlen(src) >= 2 && isdigit(UCH(*src))) {
	char *next = 0;

	c = (int) strtol(src, &next, 0);
	if (next != 0 && *next != '\0')
	    c = (-1);
#ifdef USE_KEYMAPS
    } else {
	map_string_to_keysym(src, &c);
#ifndef USE_SLANG
	if (c >= 0) {
	    /* make curses-keys mapped from Keysym_Strings[] available here */
	    if ((c & LKC_MASK) > 255)
		c &= ~LKC_ISLKC;
	}
#endif
#endif
    }

    if (c == CH_ESC) {
	escape_bound = 1;
    } else if (c < -1) {
	c = (-1);
    }

    return c;
}

static int LYLoadKeymap(const char *arg GCC_UNUSED,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target;
    char *buf = 0;
    int i;

    /*
     * Set up the stream.  - FM
     */
    target = HTStreamStack(format_in, format_out, sink, anAnchor);
    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }
    anAnchor->no_cache = TRUE;

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       CURRENT_KEYMAP_TITLE);
    PUTS(buf);
    HTSprintf0(&buf, "<pre>\n");
    PUTS(buf);

    for (i = 'a' + 1; i <= 'z' + 1; i++) {
	print_binding(target, i, TRUE);
    }
    for (i = 1; i < KEYMAP_SIZE; i++) {
	/*
	 * Don't show CHANGE_LINK if mouse not enabled.
	 */
	if ((i >= 0200 || i <= ' ' || !isalpha(i - 1)) &&
	    (LYUseMouse || (keymap[i] != LYK_CHANGE_LINK))) {
	    print_binding(target, i, FALSE);
	}
    }

    HTSprintf0(&buf, "</pre>\n</body>\n</html>\n");
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(buf);
    return (HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYKEYMAP_C_GLOBALDEF_1_INIT { "LYNXKEYMAP", LYLoadKeymap, 0}
GLOBALDEF(HTProtocol, LYLynxKeymap, _LYKEYMAP_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxKeymap =
{"LYNXKEYMAP", LYLoadKeymap, 0};
#endif /* GLOBALDEF_IS_MACRO */

/*
 * Install func as the mapping for key.
 * If for_dired is TRUE, install it in the key_override[] table
 * for Dired mode, otherwise in the general keymap[] table.
 * If DIRED_SUPPORT or OK_OVERRIDE is not defined, don't do anything
 * when for_dired is requested.
 * returns lynxkeycode value != 0 if the mapping was made, 0 if not.
 */
int remap(char *key,
	  const char *func,
	  int for_dired)
{
    Kcmd *mp;
    int c;

#if !defined(DIRED_SUPPORT) || !defined(OK_OVERRIDE)
    if (for_dired)
	return 0;
#endif
    if (func == NULL)
	return 0;
    c = lkcstring_to_lkc(key);
    if (c <= -1)
	return 0;
    else if (c >= 0) {
	/* Remapping of key actions is supported only for basic
	 * lynxkeycodes, without modifiers etc.!  If we get somehow
	 * called for an invalid lynxkeycode, fail or silently ignore
	 * modifiers. - kw
	 */
	if (c & (LKC_ISLECLAC | LKC_ISLAC))
	    return 0;
	if ((c & LKC_MASK) != c)
	    c &= LKC_MASK;
    }
    if (c + 1 >= KEYMAP_SIZE)
	return 0;
    if ((mp = LYStringToKcmd(func)) != 0) {
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (for_dired)
	    key_override[c + 1] = mp->code;
	else
#endif
	    keymap[c + 1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code));	/* don't return 0, successful */
    }
    return 0;
}

typedef struct {
    int code;
    LYKeymap_t map;
    LYKeymap_t save;
} ANY_KEYS;

/*
 * Save the given keys in the table, setting them to the map'd value.
 */
static void set_any_keys(ANY_KEYS * table, size_t size)
{
    size_t j, k;

    for (j = 0; j < size; ++j) {
	k = (size_t) (table[j].code + 1);
	table[j].save = keymap[k];
	keymap[k] = table[j].map;
    }
}

/*
 * Restore the given keys from the table.
 */
static void reset_any_keys(ANY_KEYS * table, size_t size)
{
    size_t j, k;

    for (j = 0; j < size; ++j) {
	k = (size_t) (table[j].code + 1);
	keymap[k] = table[j].save;
    }
}

static ANY_KEYS vms_keys_table[] =
{
    {26, LYK_ABORT, 0},		/* control-Z */
    {'$', LYK_SHELL, 0},
};

void set_vms_keys(void)
{
    set_any_keys(vms_keys_table, TABLESIZE(vms_keys_table));
}

static ANY_KEYS vi_keys_table[] =
{
    {'h', LYK_PREV_DOC, 0},
    {'j', LYK_NEXT_LINK, 0},
    {'k', LYK_PREV_LINK, 0},
    {'l', LYK_ACTIVATE, 0},
};

static BOOLEAN did_vi_keys;

void set_vi_keys(void)
{
    set_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
    did_vi_keys = TRUE;
}

void reset_vi_keys(void)
{
    if (did_vi_keys) {
	reset_any_keys(vi_keys_table, TABLESIZE(vi_keys_table));
	did_vi_keys = FALSE;
    }
}

static ANY_KEYS emacs_keys_table[] =
{
    {2, LYK_PREV_DOC, 0},	/* ^B */
    {14, LYK_NEXT_LINK, 0},	/* ^N */
    {16, LYK_PREV_LINK, 0},	/* ^P */
    {6, LYK_ACTIVATE, 0},	/* ^F */
};

static BOOLEAN did_emacs_keys;

void set_emacs_keys(void)
{
    set_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
    did_emacs_keys = TRUE;
}

void reset_emacs_keys(void)
{
    if (did_emacs_keys) {
	reset_any_keys(emacs_keys_table, TABLESIZE(emacs_keys_table));
	did_emacs_keys = FALSE;
    }
}

/*
 * Map numbers to functions as labeled on the IBM Enhanced keypad, and save
 * their original mapping for reset_numbers_as_arrows().  - FM
 */
static ANY_KEYS number_keys_table[] =
{
    {'1', LYK_END, 0},
    {'2', LYK_NEXT_LINK, 0},
    {'3', LYK_NEXT_PAGE, 0},
    {'4', LYK_PREV_DOC, 0},
    {'5', LYK_DO_NOTHING, 0},
    {'6', LYK_ACTIVATE, 0},
    {'7', LYK_HOME, 0},
    {'8', LYK_PREV_LINK, 0},
    {'9', LYK_PREV_PAGE, 0},
};

static BOOLEAN did_number_keys;

void set_numbers_as_arrows(void)
{
    set_any_keys(number_keys_table, TABLESIZE(number_keys_table));
    did_number_keys = TRUE;
}

void reset_numbers_as_arrows(void)
{
    if (did_number_keys) {
	reset_any_keys(number_keys_table, TABLESIZE(number_keys_table));
	did_number_keys = FALSE;
    }
}

char *key_for_func(int func)
{
    static char *buf;
    int i;
    char *formatted;

    if ((i = LYReverseKeymap(func)) >= 0) {
	formatted = LYKeycodeToString(i, TRUE);
	StrAllocCopy(buf, formatted != 0 ? formatted : "?");
    } else if (buf == 0) {
	StrAllocCopy(buf, "");
    }
    return buf;
}

/*
 * Given one or two keys as lynxkeycodes, returns an allocated string
 * representing the key(s) suitable for statusline messages, or NULL if no
 * valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other failure). 
 * The caller must free the string.  - kw
 */
char *fmt_keys(int lkc_first,
	       int lkc_second)
{
    char *buf = NULL;
    BOOLEAN quotes = FALSE;
    char *fmt_first;
    char *fmt_second;

    if (lkc_first < 0)
	return NULL;
    fmt_first = LYKeycodeToString(lkc_first, TRUE);
    if (fmt_first && strlen(fmt_first) == 1 && *fmt_first != '\'') {
	quotes = TRUE;
    }
    if (quotes) {
	if (lkc_second < 0) {
	    HTSprintf0(&buf, "'%s'", fmt_first);
	    return buf;
	} else {
	    HTSprintf0(&buf, "'%s", fmt_first);
	}
    } else {
	StrAllocCopy(buf, fmt_first);
    }
    if (lkc_second >= 0) {
	fmt_second = LYKeycodeToString(lkc_second, TRUE);
	if (!fmt_second) {
	    FREE(buf);
	    return NULL;
	}
	HTSprintf(&buf, "%s%s%s",
		  (((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		    (strlen(buf) > 2 && buf[strlen(buf) - 1] != '>'))
		   ? " "
		   : ""),
		  fmt_second, quotes ? "'" : "");
    }
    return buf;
}

/*
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  It is like LYReverseKeymap, only the order of search is
 * different; e.g., small ASCII letters will be returned in preference to
 * capital ones.  Cf.  LYKeyForEditAction, LYEditKeyForAction in LYEditmap.c
 * which use the same order to find a best key.  In addition, this function
 * takes the dired override map into account while LYReverseKeymap doesn't. 
 * The caller must free the returned string.  - kw
 */
#define FIRST_I 97
#define NEXT_I(i,imax) ((i==122) ? 32 : (i==96) ? 123 : (i==126) ? 0 :\
			(i==31) ? 256 : (i==imax) ? 127 :\
			(i==255) ? (-1) :i+1)
static int best_reverse_keymap(int lac)
{
    int i, c;

    for (i = FIRST_I; i >= 0; i = NEXT_I(i, KEYMAP_SIZE - 1)) {
#ifdef NOT_ASCII
	if (i < 256) {
	    c = FROMASCII(i);
	} else
#endif
	    c = i;
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && lac &&
	    LKC_TO_LAC(key_override, c) == lac)
	    return c;
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	if (LKC_TO_LAC(keymap, c) == lac) {
	    return c;
	}
    }

    return (-1);
}

/*
 * This function returns a string representing a key mapped to a LYK_foo
 * function, or NULL if not found.  The string may represent a pair of keys. 
 * if context_code is FOR_INPUT, an appropriate binding for use while in the
 * (forms) line editor is sought.  - kw
 */
char *key_for_func_ext(int lac,
		       int context_code)
{
    int lkc, modkey = -1;

    if (context_code == FOR_INPUT) {
	lkc = LYEditKeyForAction(lac, &modkey);
	if (lkc >= 0) {
	    if (lkc & (LKC_MOD1 | LKC_MOD2 | LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1 | LKC_MOD2 | LKC_MOD3));
	    } else {
		return fmt_keys(lkc, -1);
	    }
	}
    }
    lkc = best_reverse_keymap(lac);
    if (lkc < 0)
	return NULL;
    if (context_code == FOR_INPUT) {
	modkey = LYKeyForEditAction(LYE_LKCMD);
	if (modkey < 0)
	    return NULL;
	return fmt_keys(modkey, lkc);
    } else {
	return fmt_keys(lkc, -1);
    }
}

/*
 * This function returns TRUE if the ch is non-alphanumeric and maps to KeyName
 * (LYK_foo in the keymap[] array).  - FM
 */
BOOLEAN LYisNonAlnumKeyname(int ch,
			    int KeyName)
{
    BOOLEAN result = FALSE;

    if (ch >= 0 && (ch + 1) < KEYMAP_SIZE) {
	if ((ch <= 0
	     || StrChr("0123456789"
		       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		       "abcdefghijklmnopqrstuvwxyz", ch) == NULL)
	    && (keymap[ch + 1] == KeyName)) {
	    result = TRUE;
	}
    }
    return result;
}

/*
 * This function returns the (int)ch mapped to the LYK_foo value passed to it
 * as an argument.  - FM
 */
int LYReverseKeymap(int KeyName)
{
    int i;
    int result = -1;

    for (i = 1; i < KEYMAP_SIZE; i++) {
	if (keymap[i] == KeyName) {
	    result = (i - 1);
	    break;
	}
    }

    return result;
}

#ifdef EXP_KEYBOARD_LAYOUT
BOOLEAN LYSetKbLayout(char *layout_id)
{
    int i;
    BOOLEAN result = FALSE;

    for (i = 0; i < (int) TABLESIZE(LYKbLayoutNames) - 1; i++) {
	if (!strcasecomp(LYKbLayoutNames[i], layout_id)) {
	    current_layout = i;
	    result = TRUE;
	    break;
	}
    }

    return result;
}
#endif

#if 0
/*
 * This function was useful in converting the hand-crafted key-bindings to
 * their reusable form in 2.8.8 -TD
 */
static void checkKeyMap(LYEditConfig * table)
{
    unsigned j, k;
    char comment[80];
    int first = TRUE;

    for (j = 0; table->init[j].code >= 0; ++j) {
	int code = table->init[j].code;

	if (table->init[j].edit != table->used[code]) {
	    if (first) {
		printf("TABLE %s\n", table->name);
		first = FALSE;
	    }
	    printf("%u: init %d vs used %d\n",
		   j,
		   table->init[j].edit,
		   table->used[code]);
	}
    }
    for (j = 0; j < KEYMAP_SIZE; ++j) {
	int code = (int) j;
	BOOL found = FALSE;

	for (k = 0; table->init[k].code >= 0; ++k) {
	    if (code == table->init[k].code) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    if (table->used[j] != 0) {
		unsigned used = (j - 1);
		int edit = table->used[j];
		const char *prefix = "LYK_";
		const char *name = 0;
		Kcmd *cmd = LYKeycodeToKcmd(edit + 0);

		if (cmd != 0) {
		    name = cmd->name;
		}

		if (used < 32) {
		    char temp[80];
		    const char *what = 0;

		    switch (used) {
		    case 0:
			what = "nul";
			break;
		    case 17:
			what = "XON";
			break;
		    case 19:
			what = "XOFF";
			break;
		    default:
			sprintf(temp, "^%c", used + 'A');
			what = temp;
			break;
		    }
		    sprintf(comment, "\t/* %s */", what);
		} else if (used < 127) {
		    sprintf(comment, "\t/* %c */", used);
		} else if (used == 127) {
		    strcpy(comment, "\t/* DEL */");
		} else {
		    const char *what = LYextraKeysToName(used);

		    if (non_empty(what)) {
			sprintf(comment, "\t/* %s%s */", what,
				((StrChr(what, '_') != 0)
				 ? ""
				 : "_KEY"));
		    } else {
			strcpy(comment, "");
		    }
		}
		if (name == 0) {
		    name = "XXX";
		}
		if (first) {
		    printf("TABLE %s\n", table->name);
		    first = FALSE;
		}
		printf("\t{ %d, %s%s },%s\n", code, prefix, name, comment);
	    }
	}
    }
}

#else
#define checkKeyMap(table)	/* nothing */
#endif

static void initKeyMap(LYEditConfig * table)
{
    unsigned k;
    LYEditCode *used = table->used;
    const LYEditInit *init = table->init;

    memset(used, 0, sizeof(LYEditCode) * KEYMAP_SIZE);
    for (k = 0; init[k].code >= 0; ++k) {
	int code = init[k].code;

	used[code] = init[k].edit;
    }
    checkKeyMap(table);
}

/*
 * Reset the key bindings to their default values.
 */
void LYinitKeymap(void)
{
    initKeyMap(&myKeymapData);
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
    initKeyMap(&myOverrideData);
#endif
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYKeymap.c,v 1.68 2009/01/25 18:34:57 tom Exp $ */
a40 4
struct _HTStream {
    HTStreamClass *isa;
};

d51 1
a51 1
 * LYKeymapCode) specify key `functions', see LYKeymap.h.
d57 1
a57 2
/* *INDENT-OFF* */
LYKeymap_t keymap[KEYMAP_SIZE] = {
d59 60
a118 24
0,
/* EOF */

LYK_DO_NOTHING,     LYK_HOME,       LYK_PREV_PAGE,     0,
/* nul */           /* ^A */        /* ^B */       /* ^C */

LYK_ABORT,          LYK_END,        LYK_NEXT_PAGE,     0,
/* ^D */            /* ^E */        /* ^F */       /* ^G */

LYK_HISTORY,    LYK_FASTFORW_LINK,  LYK_ACTIVATE,  LYK_COOKIE_JAR,
/* bs */            /* ht */        /* nl */       /* ^K */

LYK_REFRESH,      LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

LYK_UP_TWO,       LYK_CHG_CENTER,   LYK_RELOAD,    LYK_TO_CLIPBOARD,
/* ^P */            /* XON */       /* ^R */       /* ^S */

LYK_TRACE_TOGGLE,  LYK_NEXT_DOC,  LYK_SWITCH_DTD,  LYK_REFRESH,
/* ^T */            /* ^U */        /* ^V */       /* ^W */

#ifdef USE_CACHEJAR
LYK_CACHE_JAR,          0,              0,             0,
/* ^X */            /* ^Y */        /* ^Z */       /* ESC */
d120 1
a120 2
0,                      0,              0,             0,
/* ^X */            /* ^Y */        /* ^Z */       /* ESC */
d122 8
a129 31

0,                      0,              0,             0,
/* ^\ */            /* ^] */        /* ^^ */       /* ^_ */

LYK_NEXT_PAGE,       LYK_SHELL,  LYK_SOFT_DQUOTES,  LYK_TOOLBAR,
/* sp */             /* ! */         /* " */        /* # */

LYK_LAST_LINK,          0,              0,          LYK_HISTORICAL,
/* $ */              /* % */         /* & */        /* ' */

LYK_UP_HALF,      LYK_DOWN_HALF, LYK_IMAGE_TOGGLE,  LYK_NEXT_PAGE,
/* ( */              /* ) */         /* * */        /* + */

LYK_EXTERN_PAGE,  LYK_PREV_PAGE, LYK_EXTERN_LINK,   LYK_WHEREIS,
/* , */              /* - */         /* . */        /* / */

LYK_F_LINK_NUM,      LYK_1,          LYK_2,         LYK_3,
/* 0 */              /* 1 */         /* 2 */        /* 3 */

LYK_4,               LYK_5,          LYK_6,         LYK_7,
/* 4 */              /* 5 */         /* 6 */        /* 7 */

LYK_8,               LYK_9,         LYK_COMMAND,    LYK_TRACE_LOG,
/* 8 */              /* 9 */         /* : */        /* ; */

LYK_UP_LINK,         LYK_INFO,     LYK_DOWN_LINK,   LYK_HELP,
/* < */              /* = */         /* > */        /* ? */

#ifndef SUPPORT_CHDIR
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_COMMENT,
/* @@ */              /* A */         /* B */        /* C */
d131 64
a194 2
LYK_RAW_TOGGLE,      LYK_ADDRLIST, LYK_PREV_PAGE,   LYK_CHDIR,
/* @@ */              /* A */         /* B */        /* C */
d196 14
a209 11

LYK_DOWNLOAD,        LYK_ELGOTO,  LYK_DIRED_MENU,   LYK_ECGOTO,
/* D */              /* E */         /* F */        /* G */

#ifdef KANJI_CODE_OVERRIDE
LYK_HELP,            LYK_INDEX,      LYK_CHG_KCODE, LYK_KEYMAP,
/* H */              /* I */         /* J */        /* K */

#else
LYK_HELP,            LYK_INDEX,      LYK_JUMP,      LYK_KEYMAP,
/* H */              /* I */         /* J */        /* K */
d211 3
d215 3
a217 221
LYK_LIST,          LYK_MAIN_MENU,    LYK_PREV,      LYK_OPTIONS,
/* L */              /* M */         /* N */        /* O */

LYK_PRINT,          LYK_ABORT,    LYK_DEL_BOOKMARK, LYK_INDEX_SEARCH,
/* P */              /* Q */         /* R */        /* S */

LYK_TAG_LINK,      LYK_PREV_DOC,    LYK_VLINKS,         0,
/* T */              /* U */         /* V */        /* W */

LYK_NOCACHE,            0,        LYK_INTERRUPT,    LYK_INLINE_TOGGLE,
/* X */              /* Y */         /* Z */        /* [ */

LYK_SOURCE,          LYK_HEAD,    LYK_FIRST_LINK,   LYK_CLEAR_AUTH,
/* \ */              /* ] */         /* ^ */        /* _ */

LYK_MINIMAL,   LYK_ADD_BOOKMARK,  LYK_PREV_PAGE,    LYK_COMMENT,
/* ` */              /* a */         /* b */        /* c */

LYK_DOWNLOAD,        LYK_EDIT,    LYK_DIRED_MENU,   LYK_GOTO,
/* d */              /* e */         /* f */        /* g */

LYK_HELP,            LYK_INDEX,      LYK_JUMP,      LYK_KEYMAP,
/* h */              /* i */         /* j */        /* k */

LYK_LIST,         LYK_MAIN_MENU,     LYK_NEXT,      LYK_OPTIONS,
/* l */              /* m */         /* n */        /* o */

LYK_PRINT,           LYK_QUIT,    LYK_DEL_BOOKMARK, LYK_INDEX_SEARCH,
/* p */              /* q */         /* r */        /* s */

LYK_TAG_LINK,     LYK_PREV_DOC,   LYK_VIEW_BOOKMARK,   0,
/* t */              /* u */         /* v */        /* w */

LYK_NOCACHE,            0,          LYK_INTERRUPT, LYK_SHIFT_LEFT,
/* x */              /* y */          /* z */       /* { */

LYK_LINEWRAP_TOGGLE, LYK_SHIFT_RIGHT, LYK_NESTED_TABLES, LYK_HISTORY,
/* | */               /* } */         /* ~ */       /* del */


/* 80..9F (illegal ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* A0..FF (permissible ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* 100..10F function key definitions in LYStrings.h */
LYK_PREV_LINK,    LYK_NEXT_LINK,    LYK_ACTIVATE,   LYK_PREV_DOC,
/* UPARROW */     /* DNARROW */     /* RTARROW */   /* LTARROW */

LYK_NEXT_PAGE,    LYK_PREV_PAGE,    LYK_HOME,       LYK_END,
/* PGDOWN */      /* PGUP */        /* HOME */      /* END */

#if (defined(_WINDOWS) || defined(__DJGPP__))

LYK_DWIMHELP,          0,              0,             0,
/* F1*/
#else

LYK_DWIMHELP,     LYK_ACTIVATE,     LYK_HOME,       LYK_END,
/* F1*/ 	  /* Do key */      /* Find key */  /* Select key */

#endif /* _WINDOWS || __DJGPP__ */

LYK_UP_TWO,       LYK_DOWN_TWO,     LYK_DO_NOTHING, LYK_FASTBACKW_LINK,
/* Insert key */  /* Remove key */  /* DO_NOTHING*/ /* Back tab */

/* 110..18F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,             LYK_DO_NOTHING,      0,             0,
               /* 0x11d: MOUSE_KEY */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
#ifdef DJGPP_KEYHANDLER
   0,                  LYK_ABORT,      0,             0,
                       /* ALT_X */
#else
   0,                  0,              0,             0,
#endif /* DJGPP_KEYHANDLER */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 190..20F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(USE_SLANG) /* PDCurses */
   LYK_ABORT,          0,              0,             0,
   /* ALT_X */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              LYK_WHEREIS,   0,
                                       /* KP_SLASH */
   0,                  0,              0,           LYK_IMAGE_TOGGLE,
                                                    /* KP_* */
   LYK_PREV_PAGE,      LYK_NEXT_PAGE,  0,             0,
   /* KP_- */          /* KP_+ */
#else
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
#endif /* (_WINDOWS || __DJGPP__ || __CYGWIN__) && !USE_SLANG */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 210..28F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   /* 290...293 */
   LYK_CHANGE_LINK,    0,              0,             0,
d227 1
a227 1
LYKeymap_t key_override[KEYMAP_SIZE] = {
d229 4
a232 50
    0,
/* EOF */

    0,                  0,              0,            0,
/* nul */           /* ^A */        /* ^B */      /* ^C */

    0,                  0,              0,            0,
/* ^D */            /* ^E */        /* ^F */      /* ^G */

    0,                  0,              0,            0,
/* bs */            /* ht */        /* nl */      /* ^K */

    0,                  0,              0,            0,
/* ^L */            /* cr */        /* ^N */      /* ^O */

    0,                  0,              0,            0,
/* ^P */            /* XON */       /* ^R */      /* XOFF */

    0,            LYK_NEXT_DOC,         0,            0,
/* ^T */            /* ^U */        /* ^V */      /* ^W */

    0,                  0,              0,            0,
/* ^X */            /* ^Y */        /* ^Z */      /* ESC */

    0,                  0,              0,            0,
/* ^\ */            /* ^] */        /* ^^ */      /* ^_ */

    0,                 0,              0,            0,
/* sp */            /* ! */         /* " */       /* # */

   0,                  0,              0,            0,
/* $ */             /* % */         /* & */       /* ' */

    0,                 0,              0,            0,
/* ( */             /* ) */         /* * */       /* + */

    0,                 0,         LYK_TAG_LINK,      0,
/* , */             /* - */         /* . */       /* / */

   0,                  0,              0,            0,
/* 0 */             /* 1 */         /* 2 */       /* 3 */

   0,                  0,              0,            0,
/* 4 */             /* 5 */         /* 6 */       /* 7 */

   0,                  0,              0,             0,
/* 8 */             /* 9 */         /* : */        /* ; */

   0,                  0,              0,             0,
/* < */             /* = */         /* > */        /* ? */
d234 1
a234 2
   0,                  0,              0,         LYK_CREATE,
/* @@ */             /* A */         /* B */        /* C */
d236 1
a236 2
   0,                  0,              0,         LYK_CHDIR,
/* @@ */             /* A */         /* B */        /* C */
d238 14
d253 3
a255 198
   0,                  0,        LYK_DIRED_MENU,       0,
/* D */             /* E */         /* F */        /* G */

   0,                  0,              0,             0,
/* H */             /* I */         /* J */        /* K */

   0,             LYK_MODIFY,          0,             0,
/* L */             /* M */         /* N */        /* O */

   0,                  0,         LYK_REMOVE,         0,
/* P */             /* Q */         /* R */        /* S */

LYK_TAG_LINK,     LYK_UPLOAD,          0,             0,
/* T */             /* U */         /* V */        /* W */

   0,                  0,              0,             0,
/* X */             /* Y */         /* Z */        /* [ */

   0,                  0,              0,             0,
/* \ */             /* ] */         /* ^ */        /* _ */

0,                     0,              0,         LYK_CREATE,
/* ` */             /* a */         /* b */        /* c */

   0,                  0,       LYK_DIRED_MENU,       0,
/* d */             /* e */         /* f */        /* g */

   0,                  0,              0,             0,
/* h */             /* i */         /* j */        /* k */

0,                LYK_MODIFY,          0,             0,
/* l */             /* m */         /* n */        /* o */

   0,                  0,          LYK_REMOVE,        0,
/* p */             /* q */         /* r */        /* s */

LYK_TAG_LINK,      LYK_UPLOAD,         0,             0,
/* t */             /* u */         /* v */         /* w */

   0,                  0,               0,            0,
/* x */             /* y */          /* z */       /* { */

   0,                   0,             0,              0,
/* | */              /* } */         /* ~ */       /* del */

/* 80..9F (illegal ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* A0..FF (permissible ISO-8859-1) 8-bit characters. */
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,

/* 100..10F function key definitions in LYStrings.h */
   0,                   0,             0,              0,
/* UPARROW */     /* DNARROW */     /* RTARROW */   /* LTARROW */

   0,                  0,              0,              0,
/* PGDOWN */      /* PGUP */        /* HOME */      /* END */

   0,                  0,              0,              0,
/* F1*/ 	  /* Do key */      /* Find key */  /* Select key */

   0,                  0,           LYK_DO_NOTHING,    0,
/* Insert key */  /* Remove key */  /* DO_NOTHING */ /* Back tab */

/* 110..18F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 190..20F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
/* 210..28F */

   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   0,                  0,              0,             0,
   /* 290...293 */
   0,                  0,              0,             0,
d261 8
a268 1
static Kcmd revmap[] = {
d270 2
a271 2
	LYK_UNKNOWN, "UNMAPPED",
	NULL ),
d273 2
a274 2
	LYK_COMMAND, "COMMAND",
	"prompt for, execute a command" ),
d276 2
a277 2
	LYK_1, "1",
	NULL ),
d279 2
a280 2
	LYK_2, "2",
	NULL ),
d282 2
a283 2
	LYK_3, "3",
	NULL ),
d285 2
a286 2
	LYK_4, "4",
	NULL ),
d288 2
a289 2
	LYK_5, "5",
	NULL ),
d291 2
a292 2
	LYK_6, "6",
	NULL ),
d294 2
a295 2
	LYK_7, "7",
	NULL ),
d297 2
a298 2
	LYK_8, "8",
	NULL ),
d300 2
a301 2
	LYK_9, "9",
	NULL ),
d303 2
a304 2
	LYK_SOURCE, "SOURCE",
	"toggle source/presentation for current document" ),
d306 2
a307 2
	LYK_RELOAD, "RELOAD",
	"reload the current document" ),
d309 2
a310 2
	LYK_QUIT, "QUIT",
	"quit the browser" ),
d312 2
a313 2
	LYK_ABORT, "ABORT",
	"quit the browser unconditionally" ),
d315 2
a316 2
	LYK_NEXT_PAGE, "NEXT_PAGE",
	"view the next page of the document" ),
d318 2
a319 2
	LYK_PREV_PAGE, "PREV_PAGE",
	"view the previous page of the document" ),
d321 2
a322 2
	LYK_UP_TWO, "UP_TWO",
	"go back two lines in the document" ),
d324 2
a325 2
	LYK_DOWN_TWO, "DOWN_TWO",
	"go forward two lines in the document" ),
d327 2
a328 2
	LYK_UP_HALF, "UP_HALF",
	"go back half a page in the document" ),
d330 2
a331 2
	LYK_DOWN_HALF, "DOWN_HALF",
	"go forward half a page in the document" ),
d333 2
a334 2
	LYK_REFRESH, "REFRESH",
	"refresh the screen to clear garbled text" ),
d336 2
a337 2
	LYK_HOME, "HOME",
	"go to the beginning of the current document" ),
d339 2
a340 2
	LYK_END, "END",
	"go to the end of the current document" ),
d342 2
a343 2
	LYK_FIRST_LINK, "FIRST_LINK",
	"make the first link on the line current" ),
d345 2
a346 2
	LYK_LAST_LINK, "LAST_LINK",
	"make the last link on the line current" ),
d348 2
a349 2
	LYK_PREV_LINK, "PREV_LINK",
	"make the previous link current" ),
d351 2
a352 2
	LYK_NEXT_LINK, "NEXT_LINK",
	"make the next link current" ),
d354 2
a355 2
	LYK_LPOS_PREV_LINK, "LPOS_PREV_LINK",
	"make previous link current, same column for input" ),
d357 2
a358 2
	LYK_LPOS_NEXT_LINK, "LPOS_NEXT_LINK",
	"make next link current, same column for input" ),
d360 2
a361 2
	LYK_FASTBACKW_LINK, "FASTBACKW_LINK",
	"previous link or text area, only stops on links" ),
d363 2
a364 2
	LYK_FASTFORW_LINK, "FASTFORW_LINK",
	"next link or text area, only stops on links" ),
d366 2
a367 2
	LYK_UP_LINK, "UP_LINK",
	"move up the page to a previous link" ),
d369 2
a370 2
	LYK_DOWN_LINK, "DOWN_LINK",
	"move down the page to another link" ),
d372 2
a373 2
	LYK_RIGHT_LINK, "RIGHT_LINK",
	"move right to another link" ),
d375 2
a376 2
	LYK_LEFT_LINK, "LEFT_LINK",
	"move left to a previous link" ),
d378 2
a379 2
	LYK_HISTORY, "HISTORY",
	"display stack of currently-suspended documents" ),
d381 2
a382 2
	LYK_PREV_DOC, "PREV_DOC",
	"go back to the previous document" ),
d384 2
a385 2
	LYK_NEXT_DOC, "NEXT_DOC",
	"undo going back to the previous document" ),
d387 2
a388 2
	LYK_ACTIVATE, "ACTIVATE",
	"go to the document given by the current link" ),
d390 2
a391 2
	LYK_SUBMIT, "MOUSE_SUBMIT",
	"DO NOT MAP:  follow current link, submit" ),
d393 2
a394 2
	LYK_GOTO, "GOTO",
	"go to a document given as a URL" ),
d396 2
a397 2
	LYK_ECGOTO, "ECGOTO",
	"edit the current document's URL and go to it" ),
d399 2
a400 2
	LYK_HELP, "HELP",
	"display help on using the browser" ),
d402 2
a403 2
	LYK_DWIMHELP, "DWIMHELP",
	"display help page that may depend on context" ),
d405 2
a406 2
	LYK_INDEX, "INDEX",
	"display an index of potentially useful documents" ),
d408 2
a409 2
	LYK_NOCACHE, "NOCACHE",
	"force submission of form or link with no-cache" ),
d411 2
a412 2
	LYK_INTERRUPT, "INTERRUPT",
	"interrupt network connection or transmission" ),
d414 2
a415 2
	LYK_MAIN_MENU, "MAIN_MENU",
	"return to the first screen (home page)" ),
d417 2
a418 2
	LYK_OPTIONS, "OPTIONS",
	"display and change option settings" ),
d420 2
a421 2
	LYK_INDEX_SEARCH, "INDEX_SEARCH",
	"allow searching of an index" ),
d423 2
a424 2
	LYK_WHEREIS, "WHEREIS",
	"search within the current document" ),
d426 2
a427 2
	LYK_PREV, "PREV",
	"search for the previous occurence" ),
d429 2
a430 2
	LYK_NEXT, "NEXT",
	"search for the next occurence" ),
d432 2
a433 2
	LYK_COMMENT, "COMMENT",
	"send a comment to the author of the current document" ),
d435 2
a436 2
	LYK_EDIT, "EDIT",
	"edit the current document or a form's textarea" ),
d438 2
a439 2
	LYK_INFO, "INFO",
	"display information on the current document and link" ),
d441 2
a442 2
	LYK_PRINT, "PRINT",
	"display choices for printing the current document" ),
d444 2
a445 2
	LYK_ADD_BOOKMARK, "ADD_BOOKMARK",
	"add to your personal bookmark list" ),
d447 2
a448 2
	LYK_DEL_BOOKMARK, "DEL_BOOKMARK",
	"delete from your personal bookmark list" ),
d450 2
a451 2
	LYK_VIEW_BOOKMARK, "VIEW_BOOKMARK",
	"view your personal bookmark list" ),
d453 2
a454 2
	LYK_VLINKS, "VLINKS",
	"list links visited during the current Lynx session" ),
d456 2
a457 2
	LYK_SHELL, "SHELL",
	"escape from the browser to the system" ),
d459 2
a460 2
	LYK_DOWNLOAD, "DOWNLOAD",
	"download the current link to your computer" ),
d462 2
a463 2
	LYK_TRACE_TOGGLE, "TRACE_TOGGLE",
	"toggle tracing of browser operations" ),
d465 2
a466 2
	LYK_TRACE_LOG, "TRACE_LOG",
	"view trace log if started in the current session" ),
d468 2
a469 2
	LYK_IMAGE_TOGGLE, "IMAGE_TOGGLE",
	"toggle handling of all images as links" ),
d471 2
a472 2
	LYK_INLINE_TOGGLE, "INLINE_TOGGLE",
	"toggle pseudo-ALTs for inlines with no ALT string" ),
d474 2
a475 2
	LYK_HEAD, "HEAD",
	"send a HEAD request for the current document or link" ),
d477 2
a478 2
	LYK_DO_NOTHING, "DO_NOTHING",
	NULL ),
d480 2
a481 2
	LYK_TOGGLE_HELP, "TOGGLE_HELP",
	"show other commands in the novice help menu" ),
d483 2
a484 2
	LYK_JUMP, "JUMP",
	"go directly to a target document or action" ),
d486 2
a487 2
	LYK_KEYMAP, "KEYMAP",
	"display the current key map" ),
d489 2
a490 2
	LYK_LIST, "LIST",
	"list the references (links) in the current document" ),
d492 2
a493 2
	LYK_TOOLBAR, "TOOLBAR",
	"go to Toolbar or Banner in the current document" ),
d495 2
a496 2
	LYK_HISTORICAL, "HISTORICAL",
	"toggle historical vs.  valid/minimal comment parsing" ),
d498 2
a499 2
	LYK_MINIMAL, "MINIMAL",
	"toggle minimal vs.  valid comment parsing" ),
d501 2
a502 2
	LYK_SOFT_DQUOTES, "SOFT_DQUOTES",
	"toggle valid vs.  soft double-quote parsing" ),
d504 2
a505 2
	LYK_RAW_TOGGLE, "RAW_TOGGLE",
	"toggle raw 8-bit translations or CJK mode ON or OFF" ),
d507 2
a508 2
	LYK_COOKIE_JAR, "COOKIE_JAR",
	"examine the Cookie Jar" ),
d510 2
a511 2
	LYK_F_LINK_NUM, "F_LINK_NUM",
	"invoke the 'Follow link (or page) number:' prompt" ),
d513 2
a514 2
	LYK_CLEAR_AUTH, "CLEAR_AUTH",
	"clear all authorization info for this session" ),
d516 2
a517 2
	LYK_SWITCH_DTD, "SWITCH_DTD",
	"switch between two ways of parsing HTML" ),
d519 2
a520 2
	LYK_ELGOTO, "ELGOTO",
	"edit the current link's URL or ACTION and go to it" ),
d522 2
a523 2
	LYK_CHANGE_LINK, "CHANGE_LINK",
	"force reset of the current link on the page" ),
d525 2
a526 2
	LYK_DWIMEDIT, "DWIMEDIT",
	"use external editor for context-dependent purpose" ),
d528 2
a529 2
	LYK_EDIT_TEXTAREA, "EDITTEXTAREA",
	"use an external editor to edit a form's textarea" ),
d531 2
a532 2
	LYK_GROW_TEXTAREA, "GROWTEXTAREA",
	"add 5 new blank lines to the bottom of a textarea" ),
d534 2
a535 3
	LYK_INSERT_FILE, "INSERTFILE",
	"insert file into a textarea (just above cursorline)" ),
#ifdef EXP_ADDRLIST_PAGE
d537 6
a542 2
	LYK_ADDRLIST, "ADDRLIST",
	"like LIST command, but always shows the links' URLs" ),
d546 2
a547 2
	LYK_EXTERN_LINK, "EXTERN_LINK",
	"run external program with current link" ),
d549 2
a550 2
	LYK_EXTERN_PAGE, "EXTERN_PAGE",
	"run external program with current page" ),
d554 2
a555 2
	LYK_DIRED_MENU, "DIRED_MENU",
	"invoke File/Directory Manager, if available" ),
d559 2
a560 2
	LYK_DIRED_MENU, "DIRED_MENU",
	"display a full menu of file operations" ),
d562 2
a563 2
	LYK_CREATE, "CREATE",
	"create a new file or directory" ),
d565 2
a566 2
	LYK_REMOVE, "REMOVE",
	"remove a file or directory" ),
d568 2
a569 2
	LYK_MODIFY, "MODIFY",
	"modify the name or location of a file or directory" ),
d571 2
a572 2
	LYK_TAG_LINK, "TAG_LINK",
	"tag a file or directory for later action" ),
d574 2
a575 2
	LYK_UPLOAD, "UPLOAD",
	"upload from your computer to the current directory" ),
d577 3
a579 3
	LYK_INSTALL, "INSTALL",
	"install file or tagged files into a system area" ),
#endif /* DIRED_SUPPORT */
d581 2
a582 2
	LYK_CHG_CENTER, "CHANGE_CENTER",
	"toggle center alignment in HTML TABLE" ),
d585 2
a586 2
	LYK_CHG_KCODE, "CHANGE_KCODE",
	"Change Kanji code" ),
d588 1
a588 1
#endif /* VMS */
d591 5
a595 2
	LYK_CHDIR, "CHDIR",
	"change current directory" ),
d599 2
a600 2
	LYK_SHIFT_LEFT, "SHIFT_LEFT",
	"shift the screen left" ),
d602 2
a603 2
	LYK_SHIFT_RIGHT, "SHIFT_RIGHT",
	"shift the screen right" ),
d605 2
a606 2
	LYK_LINEWRAP_TOGGLE, "LINEWRAP_TOGGLE",
	"toggle linewrap on/off" ),
d610 2
a611 2
	LYK_PASTE_URL, "PASTE_URL",
	"Goto the URL in the clipboard" ),
d613 2
a614 2
	LYK_TO_CLIPBOARD, "TO_CLIPBOARD",
	"link's URL to Clip Board" ),
d618 2
a619 2
	LYK_NESTED_TABLES, "NESTED_TABLES",
	"toggle nested-table parsing on/off" ),
d623 2
a624 2
	LYK_CACHE_JAR, "CACHE_JAR",
	"examine list of cached documents" ),
d626 1
d628 6
a633 2
	LYK_UNKNOWN, NULL,
	"" )
d635 1
d637 1
a637 1

d648 1
d650 7
a656 7
    { UPARROW,		"Up Arrow" },
    { DNARROW,		"Down Arrow" },
    { RTARROW,		"Right Arrow" },
    { LTARROW,		"Left Arrow" },
    { PGDOWN,		"Page Down" },
    { PGUP,		"Page Up" },
    { HOME,		"Home" },
d658 12
a669 1
    { F1,		"F1" },
a678 61

struct emap {
    const char *name;
    const int   code;
    const char *descr;
};

static struct emap ekmap[] = {
  {"NOP",	LYE_NOP,	"Do Nothing"},
  {"CHAR",	LYE_CHAR,	"Insert printable char"},
  {"ENTER",	LYE_ENTER,	"Input complete, return char/lynxkeycode"},
  {"TAB",	LYE_TAB,	"Input complete, return TAB"},
  {"STOP",	LYE_STOP,	"Input deactivated"},
  {"ABORT",	LYE_ABORT,	"Input cancelled"},

  {"PASS",	LYE_FORM_PASS,  "In fields: input complete, or Do Nothing"},

  {"DELN",	LYE_DELN,	"Delete next/curr char"},
  {"DELP",	LYE_DELP,	"Delete prev      char"},
  {"DELNW",	LYE_DELNW,	"Delete next word"},
  {"DELPW",	LYE_DELPW,	"Delete prev word"},

  {"ERASE",	LYE_ERASE,	"Erase the line"},

  {"BOL",	LYE_BOL,	"Go to begin of line"},
  {"EOL",	LYE_EOL,	"Go to end   of line"},
  {"FORW",	LYE_FORW,	"Cursor forwards"},
  {"FORW_RL",	LYE_FORW_RL,	"Cursor forwards or right link"},
  {"BACK",	LYE_BACK,	"Cursor backwards"},
  {"BACK_LL",	LYE_BACK_LL,	"Cursor backwards or left link"},
  {"FORWW",	LYE_FORWW,	"Word forward"},
  {"BACKW",	LYE_BACKW,	"Word back"},

  {"LOWER",	LYE_LOWER,	"Lower case the line"},
  {"UPPER",	LYE_UPPER,	"Upper case the line"},

  {"LKCMD",	LYE_LKCMD,	"Invoke command prompt"},

  {"AIX",	LYE_AIX,	"Hex 97"},

  {"DELBL",	LYE_DELBL,	"Delete back to BOL"},
  {"DELEL",	LYE_DELEL,	"Delete thru EOL"},

  {"SWMAP",	LYE_SWMAP,	"Switch input keymap"},

  {"TPOS",	LYE_TPOS,	"Transpose characters"},

  {"SETM1",	LYE_SETM1,	"Set modifier 1 flag"},
  {"SETM2",	LYE_SETM2,	"Set modifier 2 flag"},
  {"UNMOD",	LYE_UNMOD,	"Fall back to no-modifier command"},

  {"C1CHAR",	LYE_C1CHAR,	"Insert C1 char if printable"},

  {"SETMARK",	LYE_SETMARK,	"emacs-like set-mark-command"},
  {"XPMARK",	LYE_XPMARK,	"emacs-like exchange-point-and-mark"},
  {"KILLREG",	LYE_KILLREG,	"emacs-like kill-region"},
  {"YANK",	LYE_YANK,	"emacs-like yank"},
#ifdef CAN_CUT_AND_PASTE
  {"PASTE",	LYE_PASTE,	"ClipBoard to Lynx"},
#endif
};
d728 2
a729 2
    unsigned need = strlen(name);
    unsigned j;
d757 1
a757 1
			BOOLEAN upper8)
d766 1
a766 1
	    strcpy(buf, named_keys[n].name);
d804 2
a805 2
	key = strtol(src, &dst, 0);
	if (!isEmpty(dst))
d810 1
a810 1
	key = strtol(src + 4, &dst, 0);
d855 1
a855 1
		    strcpy(dst, table[n].name);
d865 1
a865 1
	adj -= (dst - buf) - PRETTY_LEN;
d875 1
a875 1
static char *format_binding(LYKeymap_t * table, int i)
d877 1
a877 1
    LYKeymapCode the_key = (LYKeymapCode) table[i];
d880 1
a880 1
    Kcmd *rmap = LYKeycodeToKcmd(the_key);
d897 1
a897 2
static void print_binding(HTStream *target, int i,
			  BOOLEAN both)
d900 1
a900 1
    LYKeymapCode lac1 = LYK_UNKNOWN;	/* 0 */
d904 1
a904 1
	(lac1 = (LYKeymapCode) key_override[i]) != LYK_UNKNOWN) {
d912 1
a912 1
	lac1 = (LYKeymapCode) keymap[i];
a947 19
 * Return editactioncode whose name is the string func.  func must be present
 * in the ekmap table.  returns -1 if not found.  - kw
 */
int lecname_to_lec(const char *func)
{
    int i;
    struct emap *mp;

    if (non_empty(func)) {
	for (i = 0, mp = ekmap; (*mp).name != NULL; mp++, i++) {
	    if (strcmp((*mp).name, func) == 0) {
		return (*mp).code;
	    }
	}
    }
    return (-1);
}

/*
d958 1
a958 1
    if (strlen(src) == 1)
d960 1
a960 1
    else if (strlen(src) == 2 && *src == '^')
d962 6
a967 3
    else if (strlen(src) >= 2 && isdigit(UCH(*src))) {
	if (sscanf(src, "%d", &c) != 1)
	    return (-1);
d973 2
a974 3
	    if ((c & LKC_MASK) > 255 && !(c & LKC_ISLKC))
		return (-1);	/* Don't accept untranslated curses KEY_* */
	    else
d980 2
a981 1
    if (c == CH_ESC)
d983 5
a987 4
    if (c < -1)
	return (-1);
    else
	return c;
d1058 1
a1058 1
	  BOOLEAN for_dired)
d1106 1
a1106 1
static void set_any_keys(ANY_KEYS * table, int size)
d1108 1
a1108 1
    int j, k;
d1111 1
a1111 1
	k = table[j].code + 1;
d1120 1
a1120 1
static void reset_any_keys(ANY_KEYS * table, int size)
d1122 1
a1122 1
    int j, k;
d1125 1
a1125 1
	k = table[j].code + 1;
d1300 1
a1300 1
    for (i = FIRST_I; i >= 0; i = NEXT_I(i, KEYMAP_SIZE - 2)) {
d1361 1
a1361 7
    if (ch < 0 || ch >= KEYMAP_SIZE)
	return (FALSE);
    if (ch > 0
	&& strchr("0123456789\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz", ch) != NULL)
	return (FALSE);
d1363 10
a1372 1
    return (BOOL) (keymap[ch + 1] == KeyName);
d1382 1
d1386 2
a1387 1
	    return (i - 1);
d1391 1
a1391 1
    return (-1);
d1395 1
a1395 1
int LYSetKbLayout(char *layout_id)
d1398 1
d1401 1
a1401 1
	if (!strcmp(LYKbLayoutNames[i], layout_id)) {
d1403 101
a1503 1
	    return (-1);
d1506 15
d1522 3
a1524 1
    return 0;
d1526 9
d1536 1
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d20 1
a20 1
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))
a75 5
#ifdef KANJI_CODE_OVERRIDE
LYK_CHG_KCODE,    LYK_ACTIVATE,     LYK_DOWN_TWO,      0,
/* ^L */            /* cr */        /* ^N */       /* ^O */

#else
a77 1
#endif
d82 1
a82 1
LYK_TRACE_TOGGLE,       0,        LYK_SWITCH_DTD,  LYK_REFRESH,
d85 4
d91 1
d131 5
d138 1
d390 1
a390 1
    0,            LYK_PREV_DOC,         0,            0,
d980 5
d1142 1
a1142 1
		       && !strncasecomp(revmap[j].name, name, need)) {
d1174 3
a1176 2
	if (c > ' '
	    && c < 0177)
d1179 1
a1179 1
		 && c > ' '
d1183 2
a1184 2
	else if (c < ' ')
	    sprintf(buf, "^%c", c | 0100);
d1197 1
a1197 1
    int len = strlen(src);
d1258 2
a1259 2
		    adj += strlen(dst) - 1;
		    dst += strlen(dst);
d1385 1
a1385 1
	if (sscanf(src, "%i", &c) != 1)
@


1.5
log
@sync with lynx 2.8.5.rel2 which fixes a few minor bugs (null pointer checks,
progress bar with very slow connections)
@
text
@d19 2
d22 1
a22 1
PUBLIC int current_layout = 0;  /* Index into LYKbLayouts[]   */
d24 5
a28 4
PUBLIC LYKbLayout_t * LYKbLayouts[]={
	kb_layout_rot13,
	kb_layout_jcuken,
	kb_layout_yawerty
d31 6
a36 5
PUBLIC char * LYKbLayoutNames[]={
	"ROT13'd keyboard layout",
	"JCUKEN Cyrillic, for AT 101-key kbd",
	"YAWERTY Cyrillic, for DEC LK201 kbd",
        (char *) 0
d40 2
a41 3
struct _HTStream
{
  HTStreamClass * isa;
d44 1
a44 1
/* * *  Tables mapping LynxKeyCodes to LynxActionCodes  * * */
d47 5
a51 5
 *  Lynxkeycodes include all single-byte keys as well as codes
 *  for function keys and some special purposes.  See LYStrings.h.
 *  Extended lynxkeycode values can also contain flags for modifiers
 *  and other purposes, but here only the base values are mapped to
 *  lynxactioncodes.  They are called `keystrokes' in lynx.cfg.
d53 2
a54 2
 *  Lynxactioncodes (confusingly, constants are named LYK_foo and
 *  typed as LYKeymapCode) specify key `functions', see LYKeymap.h.
d60 1
d627 1
a627 1
PRIVATE Kcmd revmap[] = {
d980 1
a980 1
PRIVATE CONST struct {
d982 1
a982 1
    CONST char *name;
d1011 3
a1013 3
	CONST char *name;
	CONST int   code;
	CONST char *descr;
d1016 1
a1016 1
PRIVATE struct emap ekmap[] = {
d1070 1
d1075 1
a1075 1
PUBLIC HTList *LYcommandList NOARGS
d1081 1
d1086 1
d1098 1
a1098 2
PUBLIC Kcmd * LYKeycodeToKcmd ARGS1(
	LYKeymapCode,	code)
d1117 1
a1117 2
PUBLIC Kcmd * LYStringToKcmd ARGS1(
	CONST char *,	name)
d1125 1
a1125 1
    if (name != 0 && *name != 0) {
d1131 1
a1131 1
		&& !strncasecomp(revmap[j].name, name, need)) {
d1136 1
a1136 1
		     && maybe->name[need] != 0) {
d1147 2
a1148 3
PUBLIC char *LYKeycodeToString ARGS2 (
	int,		c,
	BOOLEAN,	upper8)
d1164 1
a1164 1
	 && c < 0177)
d1167 3
a1169 3
	 && c > ' '
	 && c <= 0377
	 && c <= LYlowest_eightbit[current_char_set])
d1172 1
a1172 1
	    sprintf(buf, "^%c", c|0100);
d1181 1
a1181 2
PUBLIC int LYStringToKeycode ARGS1 (
	char *,		src)
d1193 1
d1195 1
a1195 1
	if (isEmpty(dst))
d1199 1
d1217 1
a1217 1
PRIVATE char *pretty_html ARGS1 (int, c)
d1222 2
a1223 1
	static CONST struct {
d1225 1
a1225 1
	    CONST char *name;
d1232 1
d1265 1
a1265 3
PRIVATE char * format_binding ARGS2(
	LYKeymap_t *,	table,
	int,		i)
d1267 1
a1267 1
    LYKeymap_t the_key = table[i];
d1273 3
a1275 3
     && rmap->name != 0
     && rmap->doc != 0
     && (formatted = pretty_html(i-1)) != 0) {
d1287 2
a1288 4
PRIVATE void print_binding ARGS3(
    HTStream *,	target,
    int,	i,
    BOOLEAN, 	both)
d1291 1
a1291 1
    LYKeymapCode lac1 = LYK_UNKNOWN; /* 0 */
d1295 1
a1295 1
	(lac1 = key_override[i]) != LYK_UNKNOWN) {
d1297 1
a1297 1
	    (*target->isa->put_block)(target, buf, strlen(buf));
d1303 2
a1304 2
	lac1 = keymap[i];
	(*target->isa->put_block)(target, buf, strlen(buf));
d1316 1
a1316 1
	    (*target->isa->put_block)(target, buf, strlen(buf));
d1322 1
a1322 1
	(*target->isa->put_block)(target, buf, strlen(buf));
d1328 2
a1329 2
 *  Return lynxactioncode whose name is the string func.
 *  returns -1 if not found. - kw
d1331 1
a1331 2
PUBLIC int lacname_to_lac ARGS1(
	CONST char *,	func)
d1339 2
a1340 3
 *  Return editactioncode whose name is the string func.
 *  func must be present in the ekmap table.
 *  returns -1 if not found. - kw
d1342 1
a1342 2
PUBLIC int lecname_to_lec ARGS1(
	CONST char *,	func)
d1347 1
a1347 1
    if (func != NULL && *func != '\0') {
d1358 5
a1362 5
 *  Return lynxkeycode represented by string src.
 *  returns -1 if not valid.
 *  This is simpler than what map_string_to_keysym() does for
 *  USE_KEYMAP, but compatible with revmap() used for processing
 *  KEYMAP options in the configuration file. - kw
d1364 1
a1364 2
PUBLIC int lkcstring_to_lkc ARGS1(
	CONST char *,	src)
d1380 1
a1380 1
	    if ((c&LKC_MASK) > 255 && !(c & LKC_ISLKC))
d1396 4
a1399 5
PRIVATE int LYLoadKeymap ARGS4 (
	CONST char *, 		arg GCC_UNUSED,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d1407 1
a1407 1
     *  Set up the stream. - FM
d1412 1
a1412 1
			 HTAtom_name(format_in), HTAtom_name(format_out));
d1415 1
a1415 1
	return(HT_NOT_LOADED);
a1418 2
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

d1420 1
a1420 1
		     CURRENT_KEYMAP_TITLE);
d1425 1
a1425 1
    for (i = 'a'+1; i <= 'z'+1; i++) {
d1430 1
a1430 1
	 *  Don't show CHANGE_LINK if mouse not enabled.
d1432 1
a1432 1
	if ((i >= 0200 || i <= ' ' || !isalpha(i-1)) &&
d1438 1
a1438 1
    HTSprintf0(&buf,"</pre>\n</body>\n</html>\n");
d1441 1
a1441 1
    (*target->isa->_free)(target);
d1443 1
a1443 1
    return(HT_LOADED);
d1448 1
a1448 1
GLOBALDEF (HTProtocol,LYLynxKeymap,_LYKEYMAP_C_GLOBALDEF_1_INIT);
d1450 2
a1451 1
GLOBALDEF PUBLIC HTProtocol LYLynxKeymap = {"LYNXKEYMAP", LYLoadKeymap, 0};
d1462 3
a1464 4
PUBLIC int remap ARGS3(
	char *,		key,
	char *,		func,
	BOOLEAN,	for_dired)
d1484 2
a1485 2
	if (c & (LKC_ISLECLAC|LKC_ISLAC))
	   return 0;
d1487 1
a1487 1
	   c &= LKC_MASK;
d1494 1
a1494 1
	    key_override[c+1] = mp->code;
d1497 2
a1498 2
	    keymap[c+1] = (LYKeymap_t) mp->code;
	return (c ? c : (int) LAC_TO_LKC0(mp->code)); /* don't return 0, successful */
d1504 1
a1504 1
    int	code;
d1512 1
a1512 3
PRIVATE void set_any_keys ARGS2(
	ANY_KEYS *,	table,
	int,		size)
d1526 1
a1526 3
PRIVATE void reset_any_keys ARGS2(
	ANY_KEYS *,	table,
	int,		size)
d1536 4
a1539 3
static ANY_KEYS vms_keys_table[] = {
    { 26,   LYK_ABORT,   0 },	/* control-Z */
    { '$',  LYK_SHELL,   0 },
d1542 1
a1542 1
PUBLIC void set_vms_keys NOARGS
d1547 6
a1552 5
static ANY_KEYS vi_keys_table[] = {
    { 'h', LYK_PREV_DOC,  0 },
    { 'j', LYK_NEXT_LINK, 0 },
    { 'k', LYK_PREV_LINK, 0 },
    { 'l', LYK_ACTIVATE,  0 },
d1557 1
a1557 1
PUBLIC void set_vi_keys NOARGS
d1563 1
a1563 1
PUBLIC void reset_vi_keys NOARGS
d1571 6
a1576 5
static ANY_KEYS emacs_keys_table[] = {
    { 2,  LYK_PREV_DOC,  0 },	/* ^B */
    { 14, LYK_NEXT_LINK, 0 },	/* ^N */
    { 16, LYK_PREV_LINK, 0 },	/* ^P */
    { 6,  LYK_ACTIVATE,  0 },	/* ^F */
d1581 1
a1581 1
PUBLIC void set_emacs_keys NOARGS
d1587 1
a1587 1
PUBLIC void reset_emacs_keys NOARGS
d1599 11
a1609 10
static ANY_KEYS number_keys_table[] = {
    { '1', LYK_END,        0 },
    { '2', LYK_NEXT_LINK,  0 },
    { '3', LYK_NEXT_PAGE,  0 },
    { '4', LYK_PREV_DOC,   0 },
    { '5', LYK_DO_NOTHING, 0 },
    { '6', LYK_ACTIVATE,   0 },
    { '7', LYK_HOME,       0 },
    { '8', LYK_PREV_LINK,  0 },
    { '9', LYK_PREV_PAGE,  0 },
d1614 1
a1614 1
PUBLIC void set_numbers_as_arrows NOARGS
d1620 1
a1620 1
PUBLIC void reset_numbers_as_arrows NOARGS
d1628 1
a1628 2
PUBLIC char *key_for_func ARGS1 (
	int,	func)
d1644 4
a1647 4
 *  Given one or two keys as lynxkeycodes, returns an allocated string
 *  representing the key(s) suitable for statusline messages, or NULL
 *  if no valid lynxkeycode is passed in (i.e., lkc_first < 0 or some other
 *  failure).  The caller must free the string. - kw
d1649 2
a1650 3
PUBLIC char *fmt_keys ARGS2(
    int,	lkc_first,
    int,	lkc_second)
d1680 4
a1683 2
		  ((strlen(fmt_second) > 2 && *fmt_second != '<') ||
		   (strlen(buf) > 2 && buf[strlen(buf)-1] != '>')) ? " " : "",
d1690 7
a1696 9
 *  This function returns the (int)ch mapped to the
 *  LYK_foo value passed to it as an argument.  It is like
 *  LYReverseKeymap, only the order of search is different;
 *  e.g., small ASCII letters will be returned in preference to
 *  capital ones.  Cf. LYKeyForEditAction, LYEditKeyForAction in
 *  LYEditmap.c which use the same order to find a best key.
 *  In addition, this function takes the dired override map into
 *  account while LYReverseKeymap doesn't.
 *  The caller must free the returned string. - kw
d1702 1
a1702 2
PRIVATE int best_reverse_keymap ARGS1(
	int,	lac)
d1706 1
a1706 1
    for (i = FIRST_I; i >= 0; i = NEXT_I(i,KEYMAP_SIZE-2)) {
d1715 1
a1715 1
	    LKC_TO_LAC(key_override,c) == lac)
d1718 1
a1718 1
	if (LKC_TO_LAC(keymap,c) == lac) {
d1723 1
a1723 1
    return(-1);
d1727 4
a1730 5
 *  This function returns a string representing a key mapped
 *  to a LYK_foo function, or NULL if not found.  The string
 *  may represent a pair of keys.  if context_code is FOR_INPUT,
 *  an appropriate binding for use while in the (forms) line editor
 *  is sought.  - kw
d1732 2
a1733 3
PUBLIC char* key_for_func_ext ARGS2(
    int,	lac,
    int,	context_code)
d1740 2
a1741 2
	    if (lkc & (LKC_MOD1|LKC_MOD2|LKC_MOD3)) {
		return fmt_keys(modkey, lkc & ~(LKC_MOD1|LKC_MOD2|LKC_MOD3));
d1761 2
a1762 2
 *  This function returns TRUE if the ch is non-alphanumeric
 *  and maps to KeyName (LYK_foo in the keymap[] array). - FM
d1764 2
a1765 3
PUBLIC BOOL LYisNonAlnumKeyname ARGS2(
	int,	ch,
	int,	KeyName)
d1770 1
a1770 1
     && strchr("0123456789\
d1775 1
a1775 1
    return (BOOL) (keymap[ch+1] == KeyName);
d1779 2
a1780 2
 *  This function returns the (int)ch mapped to the
 *  LYK_foo value passed to it as an argument. - FM
d1782 1
a1782 2
PUBLIC int LYReverseKeymap ARGS1(
	int,	KeyName)
d1788 1
a1788 1
	    return(i - 1);
d1792 1
a1792 1
    return(-1);
d1796 1
a1796 2
PUBLIC int LYSetKbLayout ARGS1(
	char *,	layout_id)
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d1078 5
a1082 2
	    if (revmap[j].doc != 0)
		HTList_addObject(myList, (char *)revmap[j].name);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a79 1
#ifdef SH_EX	/* 1998/10/02 (Fri) 08:48:44 */
a82 5
#else
LYK_UP_TWO,             0,          LYK_RELOAD,        0,
/* ^P */            /* XON */       /* ^R */       /* XOFF */
#endif

d213 1
a213 1
#if (defined(_WINDOWS) || defined(__DJGPP__) || defined(__CYGWIN__))
d222 1
a222 1
#endif /* _WINDOWS || __DJGPP__ || __CYGWIN__ */
a931 1
#ifdef SH_EX /* 1999/01/01 (Fri) 01:18:12 */
a934 1
#endif
d986 1
a986 1
    { 0177,		"<delete>" },
d1167 1
a1167 1
	    sprintf(buf, "key-%#x", c);
d1169 1
a1169 1
	    return 0;
d1181 1
a1181 1
    if (len == 1)
d1183 1
a1183 1
    else if (len == 2 && *src == '^')
d1185 6
a1190 1
    else if (len > 6 && !strncasecomp(src, "key-", 4)) {
d1193 1
a1193 1
	if (dst == 0 || *dst != 0)
d1504 41
d1548 1
a1548 2
      keymap[26+1] = LYK_ABORT;  /* control-Z */
      keymap['$'+1] = LYK_SHELL;
d1551 7
a1557 1
static LYKeymap_t saved_vi_keys[4];
d1562 2
a1563 10
      saved_vi_keys[0] = keymap['h'+1];
      keymap['h'+1] = LYK_PREV_DOC;
      saved_vi_keys[1] = keymap['j'+1];
      keymap['j'+1] = LYK_NEXT_LINK;
      saved_vi_keys[2] = keymap['k'+1];
      keymap['k'+1] = LYK_PREV_LINK;
      saved_vi_keys[3] = keymap['l'+1];
      keymap['l'+1] = LYK_ACTIVATE;

      did_vi_keys = TRUE;
d1568 5
a1572 2
      if (!did_vi_keys)
              return;
d1574 6
a1579 7
      keymap['h'+1] = saved_vi_keys[0];
      keymap['j'+1] = saved_vi_keys[1];
      keymap['k'+1] = saved_vi_keys[2];
      keymap['l'+1] = saved_vi_keys[3];

      did_vi_keys = FALSE;
}
a1580 1
static LYKeymap_t saved_emacs_keys[4];
d1585 2
a1586 10
      saved_emacs_keys[0] = keymap[2+1];
      keymap[2+1] = LYK_PREV_DOC;       /* ^B */
      saved_emacs_keys[1] = keymap[14+1];
      keymap[14+1] = LYK_NEXT_LINK;     /* ^N */
      saved_emacs_keys[2] = keymap[16+1];
      keymap[16+1] = LYK_PREV_LINK;     /* ^P */
      saved_emacs_keys[3] = keymap[6+1];
      keymap[6+1] = LYK_ACTIVATE;         /* ^F */

      did_emacs_keys = TRUE;
d1591 5
a1595 2
      if (!did_emacs_keys)
              return;
d1597 15
a1611 7
      keymap[2+1] = saved_emacs_keys[0];
      keymap[14+1] = saved_emacs_keys[1];
      keymap[16+1] = saved_emacs_keys[2];
      keymap[6+1] = saved_emacs_keys[3];

      did_emacs_keys = FALSE;
}
a1612 1
static LYKeymap_t saved_number_keys[9];
d1617 1
a1617 28
    /*
     *  Map numbers to functions as labeled on the
     *  IBM Enhanced keypad, and save their original
     *  mapping for reset_numbers_as_arrows(). - FM
     */
    saved_number_keys[0] = keymap['4'+1];
    keymap['4'+1] = LYK_PREV_DOC;
    saved_number_keys[1] = keymap['2'+1];
    keymap['2'+1] = LYK_NEXT_LINK;
    saved_number_keys[2] = keymap['8'+1];
    keymap['8'+1] = LYK_PREV_LINK;
    saved_number_keys[3] = keymap['6'+1];
    keymap['6'+1] = LYK_ACTIVATE;
    saved_number_keys[4] = keymap['7'+1];
    keymap['7'+1] = LYK_HOME;
    saved_number_keys[5] = keymap['1'+1];
    keymap['1'+1] = LYK_END;
    saved_number_keys[6] = keymap['9'+1];
    keymap['9'+1] = LYK_PREV_PAGE;
    saved_number_keys[7] = keymap['3'+1];
    keymap['3'+1] = LYK_NEXT_PAGE;

    /*
     *  Disable the 5.
     */
    saved_number_keys[8] = keymap['5'+1];
    keymap['5'+1] = LYK_DO_NOTHING;

d1623 4
a1626 14
    if (!did_number_keys)
	return;

    keymap['4'+1] = saved_number_keys[0];
    keymap['2'+1] = saved_number_keys[1];
    keymap['8'+1] = saved_number_keys[2];
    keymap['6'+1] = saved_number_keys[3];
    keymap['7'+1] = saved_number_keys[4];
    keymap['1'+1] = saved_number_keys[5];
    keymap['9'+1] = saved_number_keys[6];
    keymap['3'+1] = saved_number_keys[7];
    keymap['5'+1] = saved_number_keys[8];

    did_number_keys = FALSE;
d1659 1
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d3 1
d5 1
a5 1
#include <LYGlobalDefs.h>
d9 1
d22 1
a22 1
PUBLIC LYKeymap_t * LYKbLayouts[]={
d34 1
a34 4
#endif

PRIVATE CONST DocAddress keymap_anchor = {"LYNXKEYMAP", NULL, NULL,
	NULL, FALSE, FALSE};
d41 13
d71 5
d78 1
d80 5
d87 1
d101 1
a101 1
0,                      0,              0,          LYK_HISTORICAL,
d107 1
a107 2
#ifndef USE_EXTERNALS
LYK_NEXT_PAGE,    LYK_PREV_PAGE,        0,          LYK_WHEREIS,
a108 4
#else
LYK_NEXT_PAGE,    LYK_PREV_PAGE, LYK_EXTERN,        LYK_WHEREIS,
/* , */              /* - */         /* . */        /* / */
#endif
d116 1
a116 1
LYK_8,               LYK_9,             0,          LYK_TRACE_LOG,
d122 1
a124 6

LYK_DOWNLOAD,        LYK_ELGOTO,
/* D */              /* E */

#if defined(DIRED_SUPPORT) || defined(VMS)
LYK_DIRED_MENU,
d126 3
a128 3
0,
#endif /* DIRED_SUPPORT || VMS */
/* F */
d130 2
a131 2
LYK_ECGOTO,
/* G */
d136 1
a136 1
LYK_LIST,          LYK_MAIN_MENU,    LYK_NEXT,      LYK_OPTIONS,
d148 1
a148 1
LYK_SOURCE,          LYK_HEAD,          0,          LYK_CLEAR_AUTH,
d154 2
a155 12
LYK_DOWNLOAD,        LYK_EDIT,
/* d */              /* e */

#if defined(DIRED_SUPPORT) || defined(VMS)
LYK_DIRED_MENU,
#else
0,
#endif /* DIRED_SUPPORT || VMS */
/* f */

LYK_GOTO,
/* g */
d169 1
a169 1
LYK_NOCACHE,            0,          LYK_INTERRUPT,     0,
d172 1
a172 8
#if (defined(_WINDOWS) || defined(__DJGPP__))

LYK_PIPE,               0,              0,             0,
/* | */               /* } */         /* ~ */

#else

LYK_PIPE,               0,              0,          LYK_HISTORY,
a174 1
#endif /* _WINDOWS || __DJGPP__ */
d219 1
a219 1
#if (defined(_WINDOWS) || defined(__DJGPP__))
d221 1
a221 1
LYK_HELP,              0,              0,             0,
d225 1
a225 1
LYK_HELP,         LYK_ACTIVATE,     LYK_HOME,       LYK_END,
d228 1
a228 1
#endif /* _WINDOWS || __DJGPP__ */
a234 4
#if (defined(_WINDOWS) || defined(__DJGPP__)) && defined(USE_SLANG) && !defined(DJGPP_KEYHANDLER)
   LYK_HISTORY,        LYK_ACTIVATE,   0,             0,
   /* Backspace */     /* Enter */
#else
a235 1
#endif /* USE_SLANG &&(_WINDOWS || __DJGPP) && !DJGPP_KEYHANDLER */
d285 1
a285 1
#if (defined(_WINDOWS) || defined(__DJGPP__)) && !defined(USE_SLANG) /* PDCurses */
d305 1
a305 1
#endif /* (_WINDOWS || __DJGPP__) && !USE_SLANG */
d418 1
a418 1

d421 4
d627 1
a627 5
struct rmap {
	CONST char *name;
	CONST char *doc;
};

d629 268
a896 81
PRIVATE struct rmap revmap[] = {
{ "UNMAPPED",		NULL },
{ "1",			NULL },
{ "2",			NULL },
{ "3",			NULL },
{ "4",			NULL },
{ "5",			NULL },
{ "6",			NULL },
{ "7",			NULL },
{ "8",			NULL },
{ "9",			NULL },
{ "SOURCE",		"toggle source/presentation for current document" },
{ "RELOAD",		"reload the current document" },
{ "PIPE",		"pipe the current document to an external command" },
{ "QUIT",		"quit the browser" },
{ "ABORT",		"quit the browser unconditionally" },
{ "NEXT_PAGE",		"view the next page of the document" },
{ "PREV_PAGE",		"view the previous page of the document" },
{ "UP_TWO",		"go back two lines in the document" },
{ "DOWN_TWO",		"go forward two lines in the document" },
{ "UP_HALF",		"go back half a page in the document" },
{ "DOWN_HALF",		"go forward half a page in the document" },
{ "REFRESH",		"refresh the screen to clear garbled text" },
{ "HOME",		"go to the beginning of the current document" },
{ "END",		"go to the end of the current document" },
{ "PREV_LINK",		"make the previous link current" },
{ "NEXT_LINK",		"make the next link current" },
{ "FASTBACKW_LINK",	"previous link or text area, only stops on links" },
{ "FASTFORW_LINK",	"next link or text area, only stops on links" },
{ "UP_LINK",		"move up the page to a previous link" },
{ "DOWN_LINK",		"move down the page to another link" },
{ "RIGHT_LINK",		"move right to another link" },
{ "LEFT_LINK",		"move left to a previous link" },
{ "HISTORY",		"display stack of currently-suspended documents" },
{ "PREV_DOC",		"go back to the previous document" },
{ "ACTIVATE",		"go to the document given by the current link" },
{ "GOTO",		"go to a document given as a URL" },
{ "ECGOTO",		"edit the current document's URL and go to it" },
{ "HELP",		"display help on using the browser" },
{ "INDEX",		"display an index of potentially useful documents" },
{ "NOCACHE",		"force submission of form or link with no-cache" },
{ "INTERRUPT",		"interrupt network connection or transmission" },
{ "MAIN_MENU",		"return to the first screen (home page)" },
{ "OPTIONS",		"display and change option settings" },
{ "INDEX_SEARCH",	"allow searching of an index" },
{ "WHEREIS",		"search within the current document" },
{ "NEXT",		"search for the next occurence" },
{ "COMMENT",		"send a comment to the author of the current document" },
{ "EDIT",		"edit the current document or a form's textarea" },
{ "INFO",		"display information on the current document and link" },
{ "PRINT",		"display choices for printing the current document" },
{ "ADD_BOOKMARK",	"add to your personal bookmark list" },
{ "DEL_BOOKMARK",	"delete from your personal bookmark list" },
{ "VIEW_BOOKMARK",	"view your personal bookmark list" },
{ "VLINKS",		"list links visited during the current Lynx session" },
{ "SHELL",		"escape from the browser to the system" },
{ "DOWNLOAD",		"download the current link to your computer" },
{ "TRACE_TOGGLE",	"toggle tracing of browser operations" },
{ "TRACE_LOG",		"view trace log if started in the current session" },
{ "IMAGE_TOGGLE",	"toggle handling of all images as links" },
{ "INLINE_TOGGLE",	"toggle pseudo-ALTs for inlines with no ALT string" },
{ "HEAD",		"send a HEAD request for the current document or link" },
{ "DO_NOTHING",		NULL },
{ "TOGGLE_HELP",	"show other commands in the novice help menu" },
{ "JUMP",		"go directly to a target document or action" },
{ "KEYMAP",		"display the current key map" },
{ "LIST",		"list the references (links) in the current document" },
{ "TOOLBAR",		"go to Toolbar or Banner in the current document" },
{ "HISTORICAL",		"toggle historical vs. valid/minimal comment parsing" },
{ "MINIMAL",		"toggle minimal vs. valid comment parsing" },
{ "SOFT_DQUOTES",	"toggle valid vs. soft double-quote parsing" },
{ "RAW_TOGGLE",		"toggle raw 8-bit translations or CJK mode ON or OFF" },
{ "COOKIE_JAR",		"examine the Cookie Jar" },
{ "F_LINK_NUM",		"invoke the 'Follow link (or page) number:' prompt" },
{ "CLEAR_AUTH",		"clear all authorization info for this session" },
{ "SWITCH_DTD",		"switch between two ways of parsing HTML" },
{ "ELGOTO",		"edit the current link's URL or ACTION and go to it" },
{ "CHANGE_LINK",	"force reset of the current link on the page" },
{ "EDITTEXTAREA",	"use an external editor to edit a form's textarea" },
{ "GROWTEXTAREA",	"add 5 new blank lines to the bottom of a textarea" },
{ "INSERTFILE",		"insert file into a textarea (just above cursorline)" },
d898 3
a900 1
{ "ADDRLIST",		"like LIST command, but always shows the links URL's" },
d903 6
a908 1
{ "EXTERN",		"run external program with url" },
d911 3
a913 1
{ "DIRED_MENU",		"invoke File/Directory Manager, if available" },
d916 21
a936 7
{ "DIRED_MENU",		"display a full menu of file operations" },
{ "CREATE",		"create a new file or directory" },
{ "REMOVE",		"remove a file or directory" },
{ "MODIFY",		"modify the name or location of a file or directory" },
{ "TAG_LINK",		"tag a file or directory for later action" },
{ "UPLOAD",		"upload from your computer to the current directory" },
{ "INSTALL",		"install file or tagged files into a system area" },
d938 10
d949 32
a980 1
{ NULL,			"" }
d982 1
d984 28
a1011 20
PRIVATE CONST char *funckey[] = {
  "Up Arrow",
  "Down Arrow",
  "Right Arrow",
  "Left Arrow",
  "Page Down",
  "Page Up",
  "Home",
  "End",
  "F1",
  "Do key",
  "Find key",
  "Select key",
  "Insert key",
  "Remove key",
  "(DO_NOTHING)",		/* should normally not appear in list */
  "Back Tab",
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  "mouse pseudo key",		/* normally not mapped to keymap[] action? */
d1014 136
a1149 1
PRIVATE char *pretty ARGS1 (int, c)
d1151 11
a1161 1
	static char buf[30];
d1163 9
a1171 14
	if (c == '\t')
		sprintf(buf, "&lt;tab&gt;      ");
	else if (c == '\r')
		sprintf(buf, "&lt;return&gt;   ");
	else if (c == ' ')
		sprintf(buf, "&lt;space&gt;    ");
	else if (c == '<')
		sprintf(buf, "&lt;          ");
	else if (c == '>')
		sprintf(buf, "&gt;          ");
	else if (c == 0177)
		sprintf(buf, "&lt;delete&gt;   ");
	else if (c > ' ' && c <= 0377)
		sprintf(buf, "%c", c);
d1173 1
a1173 4
		sprintf(buf, "^%c", c|0100);
	else if (c >= 0400 && (c - 0400) < (int) TABLESIZE(funckey)
		 && funckey[c-0400])
		sprintf(buf, "%s", funckey[c-0400]);
d1175 1
a1175 1
		sprintf(buf, "%#x", c);
d1177 4
a1180 1
		return 0;
d1182 70
d1253 3
d1262 1
a1262 1
    unsigned the_key = table[i];
d1265 1
d1267 8
a1274 8
    if (the_key != 0
     && the_key < TABLESIZE(revmap)
     && revmap[the_key].name != 0
     && revmap[the_key].doc != 0
     && (formatted = pretty(i-1)) != 0) {
	HTSprintf0(&buf, "%-11s %-13s %s\n", formatted,
		revmap[the_key].name,
		revmap[the_key].doc);
d1280 6
a1285 1
PRIVATE void print_binding ARGS2(HTStream *, target, int, i)
d1288 2
d1292 9
a1300 1
        (buf = format_binding(key_override, i)) != 0) {
d1303 13
d1318 1
a1318 1
    if ((buf = format_binding(keymap, i)) != 0) {
d1324 73
d1421 3
a1423 1
    HTSprintf0(&buf, "<head>\n<title>%s</title>\n</head>\n<body>\n",
d1425 1
a1425 6
    (*target->isa->put_block)(target, buf, strlen(buf));
    HTSprintf0(&buf, "<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",
	LYNX_NAME, LYNX_VERSION,
	HELP_ON_SEGMENT,
	helpfilepath, CURRENT_KEYMAP_HELP, CURRENT_KEYMAP_TITLE);
    (*target->isa->put_block)(target, buf, strlen(buf));
d1427 1
a1427 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d1430 1
a1430 4
	print_binding(target, i);
	if (keymap[i - ' '] != keymap[i]) {
	    print_binding(target, i-' ');  /* uppercase mapping is different */
	}
a1433 2
	 *  LYK_PIPE not implemented yet.
	 *
d1436 3
a1438 4
	if ((i >= 0400 || i <= ' ' || !isalpha(i-1)) &&
	    strcmp(revmap[keymap[i]].name, "PIPE") &&
	    (LYUseMouse || strcmp(revmap[keymap[i]].name, "CHANGE_LINK"))) {
	    print_binding(target, i);
d1442 2
a1443 2
    HTSprintf0(&buf,"</pre>\n</body>\n");
    (*target->isa->put_block)(target, buf, strlen(buf));
d1458 6
a1463 3
 * install func as the mapping for key.
 * func must be present in the revmap table.
 * returns TRUE if the mapping was made, FALSE if not.
d1465 40
a1504 24
PUBLIC int remap ARGS2(
	char *,	key,
	char *,	func)
{
       int i;
       struct rmap *mp;
       int c = 0;

       if (func == NULL)
	       return 0;
       if (strlen(key) == 1)
               c = *key;
       else if (strlen(key) == 2 && *key == '^')
               c = key[1] & 037;
       else if (strlen(key) >= 2 && isdigit(*key))
               if (sscanf(key, "%i", &c) != 1)
                       return 0;
       for (i = 0, mp = revmap; (*mp).name != NULL; mp++, i++) {
               if (strcmp((*mp).name, func) == 0) {
                       keymap[c+1] = i;
                       return c;
               }
       }
       return 0;
d1514 1
a1514 1
static char saved_vi_keys[4];
d1544 1
a1544 1
static char saved_emacs_keys[4];
d1574 1
a1574 1
static char saved_number_keys[9];
a1627 13
PUBLIC int lookup_keymap ARGS1(
	int,	func)
{
    size_t i;

    for (i = 1; i < KEYMAP_SIZE; i++) {
	if (LYisNonAlnumKeyname(i, func)) {
	    return i;
	}
    }
    return -1;
}

d1636 1
a1636 1
	formatted = pretty(i);
d1645 120
d1766 1
a1766 1
 *  and maps to key_name (LYK_foo in the keymap[] array). - FM
d1770 1
a1770 1
	int,	key_name)
d1772 6
a1777 3
    if ((ch >= '0' && ch <= '9') ||
        (ch >= 'A' && ch <= 'z') ||
	ch < 0 || ch >= KEYMAP_SIZE)
d1780 1
a1780 1
    return(keymap[ch+1] == key_name);
d1788 1
a1788 1
	int,	key_name)
d1793 1
a1793 1
	if (keymap[i] == key_name) {
@


1.1
log
@Initial revision
@
text
@d1 18
a18 8
#include "HTUtils.h"
#include "tcp.h"
#include "LYUtils.h"
#include "LYKeymap.h"
#include "LYGlobalDefs.h"
#include "HTAccess.h"
#include "HTFormat.h"
#include "HTAlert.h"
d20 5
a24 1
#include "LYLeaks.h"
d26 7
a32 1
PRIVATE CONST DocAddress keymap_anchor = {"LYNXKEYMAP", NULL, NULL};
d34 4
a37 1
struct _HTStream 
d45 1
a45 1
char keymap[] = {
d50 1
a50 1
0,                  LYK_HOME,       LYK_PREV_PAGE,     0,
d56 1
a56 1
LYK_HISTORY,      LYK_NEXT_LINK,    LYK_ACTIVATE,  LYK_COOKIE_JAR,
a64 4
#ifdef NOT_USED
LYK_TRACE_TOGGLE,       0,          LYK_VERSION,   LYK_REFRESH,
/* ^T */            /* ^U */        /* ^V */       /* ^W */
#endif /* NOT_USED */
d103 1
a103 1
LYK_RAW_TOGGLE,  LYK_ADD_BOOKMARK, LYK_PREV_PAGE,   LYK_COMMENT,
d106 2
a107 2
LYK_DOWNLOAD,        LYK_ELGOTO,             
/* D */              /* E */         
d112 1
a112 1
0,          
d114 1
a114 1
/* F */        
d128 2
a129 9
#ifdef DIRED_SUPPORT
LYK_TAG_LINK,     
#else
0,
#endif /* DIRED_SUPPORT */
/* T */

 	          LYK_PREV_DOC,    LYK_VLINKS,         0,
                     /* U */         /* V */        /* W */
a130 4
#ifdef NOT_USED
LYK_FORM_UP,            0,        LYK_FORM_DOWN,    LYK_INLINE_TOGGLE,
/* X */              /* Y */         /* Z */        /* [ */
#endif /* NOT_USED */
d140 2
a141 2
LYK_DOWNLOAD,        LYK_EDIT,             
/* d */              /* e */         
d146 1
a146 1
0,          
d148 1
a148 1
/* f */        
d162 2
a163 9
#ifdef DIRED_SUPPORT
LYK_TAG_LINK,     
#else
0,
#endif /* DIRED_SUPPORT */
/* t */

                    LYK_PREV_DOC,   LYK_VIEW_BOOKMARK,   0,
                     /* u */         /* v */         /* w */
a164 4
#ifdef NOT_USED
LYK_FORM_UP,            0,          LYK_FORM_DOWN,     0,
/* x */              /* y */          /* z */       /* { */
#endif /* NOT_USED */
d168 7
d178 2
d216 1
a216 1
/* 100..10E function key definitions in LYStrings.h */
d223 6
d232 99
a330 2
LYK_UP_TWO,       LYK_DOWN_TWO,
/* Insert key */  /* Remove key */
d332 34
a365 2
LYK_DO_NOTHING,
/* DO_NOTHING*/
d375 1
a375 1
char override[] = {
d512 1
a512 1
/* 100..10E function key definitions in LYStrings.h */
d522 2
a523 2
   0,                  0,
/* Insert key */  /* Remove key */
d525 104
a628 2
LYK_DO_NOTHING,
/* DO_NOTHING*/
d633 2
a634 2
	char *name;
	char *doc;
d636 2
d665 2
d679 1
a679 1
{ "INTERRUPT",		"interrupt network transmission" },
d686 1
a686 1
{ "EDIT",		"edit the current document" },
d715 7
a737 5
#ifdef NOT_USED
{ "VERSION",		"report version of lynx"},
{ "FORM_UP",		"toggle a checkbox" },
{ "FORM_DOWN",		"toggle a checkbox" },
#endif /* NOT_USED */
d741 1
a741 1
PRIVATE char *funckey[] = {
d755 6
a760 1
  "Remove key"
d768 1
a768 1
		sprintf(buf, "&lt;tab&gt;       ");
d770 1
a770 1
		sprintf(buf, "&lt;return&gt;    ");
d772 1
a772 1
		sprintf(buf, "&lt;space&gt;     ");
d774 1
a774 1
		sprintf(buf, "&lt;           ");
d776 1
a776 1
		sprintf(buf, "&gt;           ");
d778 1
a778 1
		sprintf(buf, "&lt;delete&gt;    ");
d783 5
d789 2
a790 2
		sprintf(buf, "%s", funckey[c-0400]);
	
d794 3
a796 1
PRIVATE void print_binding ARGS3(HTStream *, target, char *, buf, int, i)
d798 20
d820 1
a820 4
        override[i] && revmap[(unsigned char)override[i]].doc) {
	sprintf(buf, "%-12s%-14s%s\n", pretty(i-1),
		revmap[(unsigned char)override[i]].name,
		revmap[(unsigned char)override[i]].doc);
d822 1
d825 1
a825 4
    if (keymap[i] && revmap[(unsigned char)keymap[i]].doc) {
	sprintf(buf, "%-12s%-14s%s\n", pretty(i-1),
		revmap[(unsigned char)keymap[i]].name,
		revmap[(unsigned char)keymap[i]].doc);
d827 1
d839 1
a839 1
    char buf[256];
d847 2
a848 2
	sprintf(buf, CANNOT_CONVERT_I_TO_O,
		     HTAtom_name(format_in), HTAtom_name(format_out));
d850 1
d855 7
a861 2
    sprintf(buf, "<head>\n<title>%s</title>\n</head>\n<body>\n",
    		  CURRENT_KEYMAP_TITLE);
d863 1
a863 3
	
    sprintf(buf, "<h1>%s (%s Version %s)</h1>\n<pre>",
		 CURRENT_KEYMAP_TITLE, LYNX_NAME, LYNX_VERSION);
d867 1
a867 1
	print_binding(target, buf, i);
d869 1
a869 2
	    print_binding(target, buf,
			  i-' ');  /* uppercase mapping is different */
d872 1
a872 1
    for (i = 1; i < (int) sizeof(keymap); i++) {
d875 2
d878 4
a881 3
	if ((i > 127 || i <= ' ' || !isalpha(i-1)) &&
	    strcmp(revmap[(unsigned char)keymap[i]].name, "PIPE")) {
	    print_binding(target, buf, i);
d885 1
a885 1
    sprintf(buf,"</pre>\n</body>\n");
d889 1
d905 4
a908 2
PUBLIC int remap ARGS2(char *,key, char *,func)
 {
d935 2
a936 2
      keymap['$'+1] = LYK_SHELL;  
} 
d1052 13
d1066 1
a1066 1
	int,		func)
d1068 3
a1070 2
	static char buf[512];
	size_t i;
d1072 7
a1078 9
	buf[0] = '\0';
	for (i = 1; i < sizeof(keymap); i++) {
		if (keymap[i] == func) {
			if (*buf)
				strcat(buf, " or ");
			strcat(buf, pretty(i-1));
		}
	}
	return buf;
d1084 1
a1084 1
 */ 
d1091 1
a1091 1
	ch < 0 || ch > 269)
a1096 1
#ifdef NOTUSED_FOTEMODS
d1102 1
a1102 1
	int,		key_name)
d1106 1
a1106 1
    for (i = 1; i < sizeof(keymap); i++) {
d1112 17
a1128 1
    return(0);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
