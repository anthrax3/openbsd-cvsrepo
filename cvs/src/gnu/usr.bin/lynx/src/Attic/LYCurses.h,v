head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.21.17.04.48;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2000.03.25.18.17.08;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.54;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.54;	author maja;	state Exp;
branches;
next	;

1.3.2.1
date	2004.11.06.04.19.29;	author brad;	state Exp;
branches;
next	;

1.3.4.1
date	2004.11.06.04.00.44;	author brad;	state Exp;
branches;
next	;

1.4.2.1
date	2004.11.06.05.06.25;	author brad;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYCurses.h,v 1.94 2013/10/22 08:10:43 tom Exp $ */
#ifndef LYCURSES_H
#define LYCURSES_H

#ifndef HTUTILS_H
#include <HTUtils.h>
#endif

/*
 * Because we have to configure PDCURSES last, we may get bogus definitions
 * from the system curses library - cancel these now.
 */
#ifdef HAVE_XCURSES

#undef ASSUME_DEFAULT_COLORS
#undef COLOR_CURSES
#undef FANCY_CURSES
#undef HAVE_CBREAK
#undef HAVE_RESIZETERM
#undef HAVE_USE_DEFAULT_COLORS
#undef NCURSES
#undef USE_DEFAULT_COLORS

#define HAVE_CBREAK 1
#define COLOR_CURSES 1
#define FANCY_CURSES 1

#endif

/*
 * The simple color scheme maps the 8 combinations of bold/underline/reverse
 * to the standard 8 ANSI colors (with some variations based on context).
 */
#undef USE_COLOR_TABLE

#ifdef USE_COLOR_STYLE
#define USE_COLOR_TABLE 1	/* default color logic is used */
#else
#if defined(USE_SLANG) || defined(COLOR_CURSES)
#define USE_COLOR_TABLE 1
#endif
#endif

#ifdef TRUE
#undef TRUE			/* to prevent parse error :( */
#endif /* TRUE */
#ifdef FALSE
#undef FALSE			/* to prevent parse error :( */
#endif /* FALSE */

#ifdef USE_SLANG
#define ENABLE_SLFUTURE_CONST 1
#include <slang.h>
#ifndef SLFUTURE_CONST
#define SLFUTURE_CONST		/* nothing */
#endif
typedef unsigned long chtype;

#undef WINDOW
typedef struct {
    int top_y;
    int left_x;
    int height;
    int width;
} WINDOW;

/* slang doesn't really do windows... */
#define waddch(w,c)  LYaddch(c)
#define waddstr(w,s) addstr(s)
#define wmove(win, row, col) SLsmg_gotorc(((win)?(win)->top_y:0) + (row), ((win)?(win)->left_x:0) + (col))

#ifndef SLSMG_UARROW_CHAR
#define SLSMG_UARROW_CHAR '^'
#endif

#ifndef SLSMG_DARROW_CHAR
#define SLSMG_DARROW_CHAR 'v'
#endif

#ifndef SLSMG_LARROW_CHAR
#define SLSMG_LARROW_CHAR '<'
#endif

#ifndef SLSMG_RARROW_CHAR
#define SLSMG_RARROW_CHAR '>'
#endif

#ifndef SLSMG_CKBRD_CHAR
#define SLSMG_CKBRD_CHAR '#'
#endif

#ifndef SLSMG_BLOCK_CHAR
#define SLSMG_BLOCK_CHAR '#'
#endif

#ifndef ACS_UARROW
#define ACS_UARROW  SLSMG_UARROW_CHAR
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  SLSMG_DARROW_CHAR
#endif

#ifndef ACS_LARROW
#define ACS_LARROW  SLSMG_LARROW_CHAR
#endif

#ifndef ACS_RARROW
#define ACS_RARROW  SLSMG_RARROW_CHAR
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD SLSMG_CKBRD_CHAR
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK   SLSMG_BLOCK_CHAR
#endif

#else /* Using curses: */

#ifdef VMS
#define FANCY_CURSES

#endif /* VMS */

#ifndef HAVE_TYPE_CHTYPE

#ifdef __PDCURSES__
#define HAVE_TYPE_CHTYPE 1
#endif

#if defined(_VMS_CURSES) || defined(VMS)
typedef char chtype;

#define HAVE_TYPE_CHTYPE 1
#endif

#endif /* ! HAVE_TYPE_CHTYPE */

/*
 *	CR may be defined before the curses.h include occurs.
 *	There is a conflict between the termcap char *CR and the define.
 *	Assuming that the definition of CR will always be carriage return.
 *	06-09-94 Lynx 2-3-1 Garrett Arch Blythe
 */
#ifdef CR
#undef CR			/* to prevent parse error :( */
#define REDEFINE_CR
#endif /* CR */

#ifdef HZ
#undef HZ			/* to prevent parse error :( */
#endif /* HZ */

/* SunOS 4.x has a redefinition between ioctl.h and termios.h */
#if defined(sun) && !defined(__SVR4)
#undef NL0
#undef NL1
#undef CR0
#undef CR1
#undef CR2
#undef CR3
#undef TAB0
#undef TAB1
#undef TAB2
#undef XTABS
#undef BS0
#undef BS1
#undef FF0
#undef FF1
#undef ECHO
#undef NOFLSH
#undef TOSTOP
#undef FLUSHO
#undef PENDIN
#endif

#if defined(_MSC_VER)
#undef MOUSE_MOVED		/* conflict between PDCURSES and _WIN32 */
#endif /* _MSC_VER */

/*
 * Do this to build with glibc 2.1.3 (apparently it was not used to build a
 * system before release).
 */
#include <signal.h>

#undef CS			/* some BSD versions of curses use this */
#define CS curses_CS		/* ...but we don't */

#ifdef ERR
#undef ERR			/* all versions of curses define this */
#endif

#ifdef KEY_EVENT
#undef KEY_EVENT		/* wincon.h or Cygwin's copy of it */
#endif

#ifdef MOUSE_MOVED
#undef MOUSE_MOVED		/* wincon.h or MINGW32's copy of it */
#endif

#ifdef HAVE_CONFIG_H
# ifdef HAVE_NCURSESW_NCURSES_H
#  undef GCC_PRINTFLIKE		/* <libutf8.h> may define 'printf' */
#  include <ncursesw/ncurses.h>
#  undef printf			/* but we don't want that... */
# else
#  ifdef HAVE_NCURSES_NCURSES_H
#   include <ncurses/ncurses.h>
#  else
#   ifdef HAVE_NCURSES_H
#    include <ncurses.h>
#   else
#    ifdef HAVE_CURSESX_H
#     include <cursesX.h>	/* Ultrix */
#    else
#     ifdef HAVE_JCURSES_H
#      include <jcurses.h>	/* sony_news */
#     else
#      ifdef HAVE_XCURSES
#       include <xcurses.h>	/* PDCurses' UNIX port */
#      else
#       include <curses.h>	/* default */
#      endif
#     endif
#    endif
#   endif
#  endif
# endif

# if defined(wgetbkgd) && !defined(getbkgd)
#  define getbkgd(w) wgetbkgd(w)	/* workaround pre-1.9.9g bug */
# endif

# ifdef FANCY_CURSES
#  if defined(NCURSES) && defined(HAVE_NCURSESW_TERM_H)
#    include <ncursesw/term.h>
#  else
#    if defined(NCURSES) && defined(HAVE_NCURSES_TERM_H)
#      include <ncurses/term.h>
#    else
#     if defined(HAVE_NCURSESW_NCURSES_H) || defined(HAVE_NCURSES_NCURSES_H) || defined(HAVE_XCURSES)
#       undef HAVE_TERM_H	/* only use one in comparable path! */
#     endif
#     if defined(HAVE_TERM_H)
#      include <term.h>
#     endif
#   endif
#  endif
# endif

# if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#  define USE_KEYMAPS		1
# endif

#else
# if defined(VMS) && defined(__GNUC__)
#  include <LYGCurses.h>
#  else
#   include <curses.h>		/* everything else */
# endif	/* VMS && __GNUC__ */
#endif /* HAVE_CONFIG_H */

/*
 * PDCurses' mouse code does nothing in the DJGPP configuration.
 */
#if defined(PDCURSES) && !defined(__DJGPP__) && !defined(HAVE_XCURSES)
#define USE_MOUSE 1
#endif

/*
 * Pick up the native ncurses name:
 */
#if defined(NCURSES_MOUSE_VERSION)
#define USE_MOUSE 1
#endif

/*
 * For systems where select() does not work for TTY's, we can poll using
 * curses.
 */
#if defined(_WINDOWS) || defined(__MINGW32__)
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
#define USE_CURSES_NODELAY 1
#endif

#if defined(NCURSES_VERSION)
#define USE_CURSES_NODELAY 1
#endif
#endif /* _WINDOWS || __MINGW32__ */

#if defined(NCURSES_VERSION) && defined(__BEOS__)
#define USE_CURSES_NODELAY 1
#endif

/*
 * If we have pads, use them to implement left/right scrolling.
 */
#if defined(HAVE_NEWPAD) && defined(HAVE_PNOUTREFRESH) && !defined(PDCURSES)
#define USE_CURSES_PADS 1
#endif

/*
 * ncurses 1.9.9e won't work for pads, but 4.2 does (1.9.9g doesn't have a
 * convenient ifdef, though it would work).
 */
#if defined(NCURSES_VERSION) && !defined(NCURSES_VERSION_MAJOR)
#undef USE_CURSES_PADS
#endif

/*
 * Most implementations of curses treat pair 0 specially, as the default
 * foreground and background color.  Also, the COLORS variable corresponds to
 * the total number of colors.
 *
 * PDCurses does not follow these rules.  Its COLORS variable claims it has
 * 8 colors, but it actually implements 16.  That makes it hard to optimize
 * color settings against color pair 0 in a portable fashion.
 */
#if defined(COLOR_CURSES)
#if defined(PDCURSES) || defined(HAVE_XCURSES)
#define COLORS 16		/* should be a variable... */
#else
#define USE_CURSES_PAIR_0
#endif
#endif

#if defined(_WINDOWS) && defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
#define USE_MAXSCREEN_TOGGLE 1
extern void maxmizeWindowSize(void);
extern void recoverWindowSize(void);
#endif

#endif /* USE_SLANG */

#ifdef __cplusplus
extern "C" {
#endif
#ifdef USE_SLANG
#define LYstopPopup()		/* nothing */
#define LYtopwindow() LYwin
#else
    extern void LYsubwindow(WINDOW * param);
    extern WINDOW *LYtopwindow(void);

#define LYstopPopup() LYsubwindow(0)
#endif				/* NCURSES */

    extern void LYbox(WINDOW * win, int formfield);
    extern WINDOW *LYstartPopup(int *top_y, int *left_x, int *height, int *width);

/*
 * Useful macros not in PDCurses or very old ncurses headers.
 */
#if !defined(HAVE_GETBEGX) && !defined(getbegx)
#define getbegx(win) ((win)->_begx)
#endif
#if !defined(HAVE_GETBEGY) && !defined(getbegy)
#define getbegy(win) ((win)->_begy)
#endif
#if !defined(HAVE_GETBKGD) && !defined(getbkgd)
#define getbkgd(win) ((win)->_bkgd)
#endif

#if defined(HAVE_WATTR_GET)
    extern long LYgetattrs(WINDOW * win);

#else
#if defined(HAVE_GETATTRS) || defined(getattrs)
#define LYgetattrs(win) getattrs(win)
#else
#define LYgetattrs(win) ((win)->_attrs)
#endif
#endif				/* HAVE_WATTR_GET */

#if defined(PDCURSES)
#define HAVE_GETBKGD 1		/* can use fallback definition */
#define HAVE_NAPMS 1		/* can use millisecond-delays */
#  if defined(PDC_BUILD) && PDC_BUILD >= 2401
    extern int saved_scrsize_x;
    extern int saved_scrsize_y;
#  endif
#endif

#ifdef HAVE_NAPMS
#define SECS2Secs(n) (1000 * (n))
#define Secs2SECS(n) ((n) / 1000.0)
#define SECS_FMT "%.3f"
#else
#define SECS2Secs(n) (n)
#define Secs2SECS(n) (n)
#define SECS_FMT "%.0f"
#endif

#ifdef NCURSES_VERSION
    extern void _nc_freeall(void);	/* HAVE__NC_FREEALL */
    extern void _nc_free_and_exit(int);		/* HAVE__NC_FREE_AND_EXIT */
#endif

/* Both slang and curses: */
#ifndef TRUE
#define TRUE  1
#endif				/* !TRUE */
#ifndef FALSE
#define FALSE 0
#endif				/* !FALSE */

#ifdef REDEFINE_CR
#define CR FROMASCII('\015')
#endif				/* REDEFINE_CR */

#ifdef ALT_CHAR_SET
#define BOXVERT 0		/* use alt char set for popup window vertical borders */
#define BOXHORI 0		/* use alt char set for popup window vertical borders */
#endif

#ifndef BOXVERT
#define BOXVERT '*'		/* character for popup window vertical borders */
#endif
#ifndef BOXHORI
#define BOXHORI '*'		/* character for popup window horizontal borders */
#endif

#ifndef KEY_DOWN
#undef HAVE_KEYPAD		/* avoid confusion with bogus 'keypad()' */
#endif

    extern int LYlines;		/* replaces LINES */
    extern int LYcols;		/* replaces COLS */

/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#if defined(PDCURSES)
#define LYcolLimit (LYcols - LYbarWidth - 1)	/* PDCurses wrapping is buggy */
#else
#define LYcolLimit (LYcols - LYbarWidth)
#endif
#else
#define LYcolLimit (LYcols - 1)
#endif

#ifdef USE_CURSES_PADS
    extern WINDOW *LYwin;
    extern int LYshiftWin;
    extern int LYwideLines;
    extern int LYtableCols;
    extern BOOLEAN LYuseCursesPads;

#else
#define LYwin stdscr
#define LYshiftWin	0
#define LYwideLines	0
#define LYtableCols	0
#endif

    extern BOOLEAN setup(char *terminal);
    extern int LYscreenHeight(void);
    extern int LYscreenWidth(void);
    extern int LYstrExtent(const char *string, int len, int maxCells);
    extern int LYstrExtent2(const char *string, int len);
    extern int LYstrFittable(const char *string, int maxCells);
    extern int LYstrCells(const char *string);
    extern void LYclear(void);
    extern void LYclrtoeol(void);
    extern void LYerase(void);
    extern void LYmove(int y, int x);
    extern void LYnoVideo(int mask);
    extern void LYnormalColor(void);
    extern void LYpaddstr(WINDOW * w, int width, const char *s);
    extern void LYrefresh(void);
    extern void LYstartTargetEmphasis(void);
    extern void LYstopTargetEmphasis(void);
    extern void LYtouchline(int row);
    extern void LYwaddnstr(WINDOW * w, const char *s, size_t len);
    extern void start_curses(void);
    extern void stop_curses(void);

#define LYaddstr(s)      LYwaddnstr(LYwin, s, strlen(s))

#ifdef VMS
    extern int DCLsystem(char *command);
    extern void VMSexit();
    extern int ttopen();
    extern int ttclose();
    extern int ttgetc();
    extern void VMSsignal(int sig, void (*func) ());
#endif				/* VMS */

#if defined(USE_COLOR_STYLE)
    extern void add_to_lss_list(const char *source, const char *resolved);
    extern void curses_css(char *name, int dir);
    extern void curses_style(int style, int dir);
    extern void curses_w_style(WINDOW * win, int style, int dir);
    extern void init_color_styles(char **from_cmdline, const char *default_styles);
    extern void reinit_color_styles(void);
    extern void setHashStyle(int style, int color, int cattr, int mono, const char *element);
    extern void setStyle(int style, int color, int cattr, int mono);
    extern void update_color_style(void);
    extern void wcurses_css(WINDOW * win, char *name, int dir);

#  define LynxChangeStyle(style,dir) curses_style(style,dir)
#  define LynxWChangeStyle(win,style,dir) curses_w_style(win,style,dir)
#else
#  define LynxWChangeStyle(win,style,dir)	(void)1
#endif				/* USE_COLOR_STYLE */

#ifdef USE_COLOR_TABLE
    extern void LYaddAttr(int a);
    extern void LYsubAttr(int a);
    extern void lynx_setup_colors(void);
    extern unsigned Lynx_Color_Flags;
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
    extern int Current_Attr;
#endif

#ifdef USE_SLANG
#define SHOW_WHEREIS_TARGETS 1

#if !defined(VMS) && !defined(DJGPP)
#define USE_MOUSE              1
#endif

#if !defined(__DJGPP__) && !defined(__CYGWIN__)
#define USE_KEYMAPS		1
#endif

#define SL_LYNX_USE_COLOR	1
#define SL_LYNX_OVERRIDE_COLOR	2

#define start_bold()      	LYaddAttr(LYUnderlineLinks ? 4 : 1)
#define start_reverse()   	LYaddAttr(2)
#define start_underline() 	LYaddAttr(LYUnderlineLinks ? 1 : 4)
#define stop_bold()       	LYsubAttr(LYUnderlineLinks ? 4 : 1)
#define stop_reverse()    	LYsubAttr(2)
#define stop_underline()  	LYsubAttr(LYUnderlineLinks ? 1 : 4)

#ifdef FANCY_CURSES
#undef FANCY_CURSES
#endif				/* FANCY_CURSES */

/*
 *  Map some curses functions to slang functions.
 */
#define stdscr ((WINDOW *)0)
#ifdef SLANG_MBCS_HACK
    extern int PHYSICAL_SLtt_Screen_Cols;

#define COLS PHYSICAL_SLtt_Screen_Cols
#else
#define COLS SLtt_Screen_Cols
#endif				/* SLANG_MBCS_HACK */
#define LINES SLtt_Screen_Rows
#define move SLsmg_gotorc
#define addstr SLsmg_write_string
    extern void LY_SLerase(void);

#define erase LY_SLerase
#define clear LY_SLerase
#define standout SLsmg_reverse_video
#define standend  SLsmg_normal_video
#define clrtoeol SLsmg_erase_eol

#ifdef SLSMG_NEWLINE_SCROLLS
#define scrollok(a,b) SLsmg_Newline_Behavior \
   = ((b) ? SLSMG_NEWLINE_SCROLLS : SLSMG_NEWLINE_MOVES)
#else
#define scrollok(a,b) SLsmg_Newline_Moves = ((b) ? 1 : -1)
#endif

#define LYaddch(ch)   SLsmg_write_char(ch)

#if SLANG_VERSION >= 20000
#define addch_raw(ch) do {                                \
                        SLsmg_Char_Type buf;              \
                        buf.nchars = 1;                   \
                        buf.wchars[0] = ch;               \
                        buf.color = Current_Attr;         \
                        SLsmg_write_raw (&buf, 1);        \
                      } while (0)
#else
#define addch_raw(ch) do {                                \
                        SLsmg_Char_Type buf;              \
                        buf = (ch) | (Current_Attr << 4); \
                        SLsmg_write_raw (&buf, 1);        \
                      } while (0)
#endif				/* SLANG_VERSION >= 20000 */

#define echo()
#define printw        SLsmg_printf

    extern int curscr;
    extern BOOLEAN FullRefresh;

#ifdef clearok
#undef clearok
#endif				/* clearok */
#define clearok(a,b) { FullRefresh = (BOOLEAN)b; }
    extern void LY_SLrefresh(void);

#ifdef refresh
#undef refresh
#endif				/* refresh */
#define refresh LY_SLrefresh

#ifdef VMS
    extern void VTHome(void);

#define endwin() LYclear(),refresh(),SLsmg_reset_smg(),VTHome()
#else
#define endwin SLsmg_reset_smg(),SLang_reset_tty
#endif				/* VMS */

#else				/* Define curses functions: */

#ifdef FANCY_CURSES
#define SHOW_WHEREIS_TARGETS 1

#ifdef VMS
/*
 *  For VMS curses, [w]setattr() and [w]clrattr()
 *  add and subtract, respectively, the attributes
 *  _UNDERLINE, _BOLD, _REVERSE, and _BLINK. - FM
 */
#define start_bold()		setattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define stop_bold()		clrattr(LYUnderlineLinks ? _UNDERLINE : _BOLD)
#define start_underline()	setattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
#define stop_underline()	clrattr(LYUnderlineLinks ? _BOLD : _UNDERLINE)
#define start_reverse()		setattr(_REVERSE)
#define wstart_reverse(w)	wsetattr(w, _REVERSE)
#define stop_reverse()		clrattr(_REVERSE)
#define wstop_reverse(w)	wclrattr(w, _REVERSE)

#else				/* Not VMS: */

    extern int string_to_attr(const char *name);

/*
 *  For Unix FANCY_FANCY curses we interpose
 *  our own functions to add or subtract the
 *  A_foo attributes. - FM
 */
#if defined(USE_COLOR_TABLE) && !defined(USE_COLOR_STYLE)
    extern void LYaddWAttr(WINDOW * win, int a);
    extern void LYsubWAttr(WINDOW * win, int a);
    extern void LYaddWAttr(WINDOW * win, int a);
    extern void LYsubWAttr(WINDOW * win, int a);

#undef  standout
#define standout() 		lynx_standout(TRUE)
#undef  standend
#define standend() 		lynx_standout(FALSE)
#else
#define LYaddAttr(attr)		LYaddWAttr(LYwin,attr)
#define LYaddWAttr(win,attr)	wattron(win,attr)
#define LYsubAttr(attr)		LYsubWAttr(LYwin,attr)
#define LYsubWAttr(win,attr)	wattroff(win,attr)
#endif

#if defined(USE_COLOR_TABLE)
    extern void lynx_set_color(int a);
    extern void lynx_standout(int a);
    extern char *LYgetTableString(int code);
    extern int LYgetTableAttr(void);
    extern int lynx_chg_color(int, int, int);
#endif

#define start_bold()		LYaddAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define stop_bold()		LYsubAttr(LYUnderlineLinks ? A_UNDERLINE : A_BOLD)
#define start_underline()	LYaddAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)
#define stop_underline()	LYsubAttr(LYUnderlineLinks ? A_BOLD : A_UNDERLINE)

#if defined(SNAKE) && defined(HP_TERMINAL)
#define start_reverse()		LYaddWAttr(LYwin, A_DIM)
#define wstart_reverse(w)	LYaddWAttr(w, A_DIM)
#define stop_reverse()		LYsubWAttr(LYwin, A_DIM)
#define wstop_reverse(w)	LYsubWAttr(w, A_DIM)
#else
#define start_reverse()		LYaddAttr(A_REVERSE)
#define wstart_reverse(w)	LYaddWAttr(w, A_REVERSE)
#define stop_reverse()		LYsubAttr(A_REVERSE)
#define wstop_reverse(w)	LYsubWAttr(w, A_REVERSE)
#endif				/* SNAKE && HP_TERMINAL */

#endif				/* VMS */

#else				/* Not FANCY_CURSES: */
/* *INDENT-OFF* */
#ifdef COLOR_CURSES
#undef COLOR_CURSES
Error FANCY_CURSES
There is a problem with the configuration.  We expect to have FANCY_CURSES
defined when COLOR_CURSES is defined, since we build on the attributes used in
FANCY_CURSES.  Check your config.log to see why the FANCY_CURSES test failed.
#endif
/* *INDENT-ON* */

/*
 *  We only have [w]standout() and [w]standin(),
 *  so we'll use them synonymously for bold and
 *  reverse, and ignore underline. - FM
 */
#define start_bold()		standout()
#define start_underline()	/* nothing */
#define start_reverse()		standout()
#define wstart_reverse(a)	wstandout(a)
#define stop_bold()		standend()
#define stop_underline()	/* nothing */
#define stop_reverse()		standend()
#define wstop_reverse(a)	wstandend(a)

#endif				/* FANCY_CURSES */

#ifdef __hpux			/* FIXME: configure check */
#undef ACS_UARROW
#undef ACS_DARROW
#undef ACS_LARROW
#undef ACS_RARROW
#undef ACS_BLOCK
#undef ACS_CKBOARD
#endif

#ifndef ACS_UARROW
#define ACS_UARROW  '^'
#endif

#ifndef ACS_DARROW
#define ACS_DARROW  'V'
#endif

#ifndef ACS_LARROW
#define ACS_LARROW '{'
#endif

#ifndef ACS_RARROW
#define ACS_RARROW '}'
#endif

#ifndef ACS_BLOCK
#define ACS_BLOCK  '}'
#endif

#ifndef ACS_CKBOARD
#define ACS_CKBOARD '}'
#endif

#define LYaddch(ch)		waddch(LYwin, ch)

#define addch_raw(ch)           LYaddch(ch)

#endif				/* USE_SLANG */

#ifdef USE_SLANG
#define LYGetYX(y, x)   y = SLsmg_get_row(), x = SLsmg_get_column()
#else
#ifdef getyx
#define LYGetYX(y, x)   getyx(LYwin, y, x)
#else
#define LYGetYX(y, x)   y = LYwin->_cury, x = LYwin->_curx
#endif				/* getyx */
#endif				/* USE_SLANG */

/*
 * If the screen library allows us to specify "default" color, allow user to
 * control it.
 */
#ifdef USE_DEFAULT_COLORS
#if defined(USE_SLANG) || defined(HAVE_ASSUME_DEFAULT_COLORS)
#define EXP_ASSUMED_COLOR 1
#endif
#endif

    extern void lynx_enable_mouse(int);
    extern void lynx_force_repaint(void);
    extern void lynx_nl2crlf(int normal);
    extern void lynx_start_title_color(void);
    extern void lynx_stop_title_color(void);
    extern void lynx_start_link_color(int flag, int pending);
    extern void lynx_stop_link_color(int flag, int pending);
    extern void lynx_stop_target_color(void);
    extern void lynx_start_target_color(void);
    extern void lynx_start_status_color(void);
    extern void lynx_stop_status_color(void);
    extern void lynx_start_h1_color(void);
    extern void lynx_stop_h1_color(void);
    extern void lynx_start_prompt_color(void);
    extern void lynx_stop_prompt_color(void);
    extern void lynx_start_radio_color(void);
    extern void lynx_stop_radio_color(void);
    extern void lynx_stop_all_colors(void);

    extern void lynx_start_bold(void);
    extern void lynx_start_reverse(void);
    extern void lynx_start_underline(void);
    extern void lynx_stop_bold(void);
    extern void lynx_stop_reverse(void);
    extern void lynx_stop_underline(void);

    extern void restart_curses(void);

/*
 * To prevent corrupting binary data on DOS, MS-WINDOWS or OS/2 we open files
 * and stdout in BINARY mode by default.  Where necessary we should open and
 * (close!) TEXT mode.
 *
 * Note:  EMX has no corresponding variable like _fmode on DOS, but it does
 * have setmode.
 */
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__) || defined(WIN_EX)
#define SetOutputMode(mode) fflush(stdout), setmode(fileno(stdout), mode)
#else
#define SetOutputMode(mode)	/* nothing */
#endif

#if defined(_WINDOWS) || defined(DJGPP)
#define SetDefaultMode(mode) _fmode = mode
#else
#define SetDefaultMode(mode)	/* nothing */
#endif

/*
 * Very old versions of curses cannot put the cursor on the lower right corner.
 * Adjust our "hidden" cursor position accordingly.
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit - 1))
#else
#define LYHideCursor() LYmove((LYlines - 1), (LYcolLimit - 2))
#endif

#define LYParkCursor() LYmove((LYlines - 1), 0); LYclrtoeol()

    extern void LYstowCursor(WINDOW * win, int row, int col);
    extern void LYSetDisplayLines(void);

#ifdef __cplusplus
}
#endif
#endif				/* LYCURSES_H */
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYCurses.h,v 1.80 2009/04/07 00:03:47 tom Exp $ */
d52 1
d54 3
d196 4
d263 1
a263 1
# endif				/* VMS && __GNUC__ */
d330 6
d351 1
a351 1
    extern void LYbox(WINDOW * win, BOOLEAN formfield);
d474 1
d503 1
d506 4
a509 1
    extern void setHashStyle(int style, int color, int cattr, int mono, char *element);
d511 1
a512 1
    extern void curses_w_style(WINDOW * win, int style, int dir);
d650 1
a650 1
    extern int string_to_attr(char *name);
d813 2
d844 2
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d53 1
d120 1
d123 14
d284 1
a284 1
#endif	/* _WINDOWS || __MINGW32__ */
d383 5
a440 18
/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

d446 1
a446 1
    extern BOOL LYuseCursesPads;
d825 1
@


1.5
log
@Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>
@
text
@d35 3
a37 1
#ifndef USE_COLOR_STYLE
d44 1
a44 1
#undef TRUE  /* to prevent parse error :( */
d47 1
a47 1
#undef FALSE  /* to prevent parse error :( */
d55 1
a55 1
    int	top_y;
d127 1
a127 1
#undef CR  /* to prevent parse error :( */
d132 1
a132 1
#undef HZ  /* to prevent parse error :( */
d159 1
a159 1
#undef MOUSE_MOVED	/* conflict between PDCURSES and _WIN32 */
d220 1
a220 1
#       undef HAVE_TERM_H			/* only use one in comparable path! */
d237 2
a238 2
#   include <curses.h>  /* everything else */
# endif /* VMS && __GNUC__ */
d256 18
d307 3
d311 1
a311 1
#define LYstopPopup() /* nothing */
d314 3
a316 2
extern void LYsubwindow PARAMS((WINDOW * param));
extern WINDOW * LYtopwindow NOPARAMS;
d318 1
a318 1
#endif /* NCURSES */
d320 2
a321 2
extern void LYbox PARAMS((WINDOW *win, BOOLEAN formfield));
extern WINDOW *LYstartPopup PARAMS((int top_y, int left_x, int height, int width));
d337 2
a338 1
extern long LYgetattrs PARAMS((WINDOW *win));
d345 1
a345 1
#endif /* HAVE_WATTR_GET */
d348 6
a353 2
#define HAVE_GETBKGD 1	/* can use fallback definition */
#define HAVE_NAPMS 1	/* can use millisecond-delays */
d369 1
a369 1
#endif /* !TRUE */
d372 1
a372 1
#endif /* !FALSE */
d376 1
a376 1
#endif /* REDEFINE_CR */
d379 2
a380 2
#define BOXVERT 0   /* use alt char set for popup window vertical borders */
#define BOXHORI 0   /* use alt char set for popup window vertical borders */
d384 1
a384 1
#define BOXVERT '*'	/* character for popup window vertical borders */
d387 1
a387 1
#define BOXHORI '*'	/* character for popup window horizontal borders */
d391 1
a391 1
#undef HAVE_KEYPAD	/* avoid confusion with bogus 'keypad()' */
d394 24
a417 2
extern int LYlines;	/* replaces LINES */
extern int LYcols;	/* replaces COLS */
d438 6
a443 5
extern WINDOW *LYwin;
extern int LYshiftWin;
extern int LYwideLines;
extern int LYtableCols;
extern BOOL LYuseCursesPads;
d451 20
a470 21
#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
extern int Current_Attr;
extern int Masked_Attr;
#endif

extern BOOLEAN setup PARAMS((char *terminal));
extern int LYscreenHeight NOPARAMS;
extern int LYscreenWidth NOPARAMS;
extern void LYclear NOPARAMS;
extern void LYclrtoeol NOPARAMS;
extern void LYerase NOPARAMS;
extern void LYmove PARAMS((int y, int x));
extern void LYnoVideo PARAMS((int mask));
extern void LYpaddstr PARAMS((WINDOW *w, int width, CONST char *s));
extern void LYrefresh NOPARAMS;
extern void LYstartTargetEmphasis NOPARAMS;
extern void LYstopTargetEmphasis NOPARAMS;
extern void LYtouchline PARAMS((int row));
extern void LYwaddnstr PARAMS((WINDOW *w, CONST char *s, size_t len));
extern void start_curses NOPARAMS;
extern void stop_curses NOPARAMS;
a472 2
#define LYaddnstr(s,len) LYwaddnstr(LYwin, s, len)
#define LYwaddstr(w,s)   LYwaddnstr(w, s, strlen(s))
d475 7
a481 7
extern int DCLsystem (char *command);
extern void VMSexit();
extern int ttopen();
extern int ttclose();
extern int ttgetc();
extern void VMSsignal PARAMS((int sig, void (*func)()));
#endif /* VMS */
d484 7
a490 6
extern void curses_css PARAMS((char * name, int dir));
extern void curses_style PARAMS((int style, int dir));
extern void setHashStyle PARAMS((int style, int color, int cattr, int mono, char* element));
extern void setStyle PARAMS((int style, int color, int cattr, int mono));
extern void wcurses_css PARAMS((WINDOW * win, char* name, int dir));
extern void curses_w_style PARAMS((WINDOW* win, int style, int	dir));
d495 1
a495 1
#endif /* USE_COLOR_STYLE */
d498 8
a505 4
extern void LYaddAttr PARAMS((int a));
extern void LYsubAttr PARAMS((int a));
extern void lynx_setup_colors NOPARAMS;
extern unsigned int Lynx_Color_Flags;
d531 1
a531 1
#endif /* FANCY_CURSES */
d538 2
a539 1
extern int PHYSICAL_SLtt_Screen_Cols;
d543 1
a543 1
#endif /* SLANG_MBCS_HACK */
d547 2
a548 1
extern void LY_SLerase NOPARAMS;
d563 10
d578 2
d583 3
a585 2
extern int curscr;
extern BOOLEAN FullRefresh;
d588 1
a588 1
#endif /* clearok */
d590 2
a591 1
extern void LY_SLrefresh NOPARAMS;
d594 1
a594 1
#endif /* refresh */
d598 2
a599 1
extern void VTHome NOPARAMS;
d603 1
a603 1
#endif /* VMS */
d605 1
a605 1
#else /* Define curses functions: */
d625 1
a625 1
#else /* Not VMS: */
d627 1
a627 1
extern int string_to_attr PARAMS((char *name));
d634 6
a639 8
#ifdef USE_COLOR_TABLE
extern void LYaddWAttr PARAMS((WINDOW *win, int a));
extern void LYsubWAttr PARAMS((WINDOW *win, int a));
extern void LYaddWAttr PARAMS((WINDOW *win, int a));
extern void LYsubWAttr PARAMS((WINDOW *win, int a));
extern void lynx_set_color PARAMS((int a));
extern void lynx_standout  PARAMS((int a));
extern int  lynx_chg_color PARAMS((int, int, int));
d651 8
d674 1
a674 3
#endif /* SNAKE && HP_TERMINAL */

#endif /* VMS */
d676 1
a676 1
#else /* Not FANCY_CURSES: */
d678 2
d687 1
d703 1
a703 1
#endif /* FANCY_CURSES */
d742 1
a742 1
#endif /* USE_SLANG */
d751 2
a752 2
#endif /* getyx */
#endif /* USE_SLANG */
d764 25
a788 25
extern void lynx_enable_mouse PARAMS((int));
extern void lynx_force_repaint NOPARAMS;
extern void lynx_nl2crlf PARAMS((int normal));
extern void lynx_start_title_color NOPARAMS;
extern void lynx_stop_title_color NOPARAMS;
extern void lynx_start_link_color PARAMS((int flag, int pending));
extern void lynx_stop_link_color PARAMS((int flag, int pending));
extern void lynx_stop_target_color NOPARAMS;
extern void lynx_start_target_color NOPARAMS;
extern void lynx_start_status_color NOPARAMS;
extern void lynx_stop_status_color NOPARAMS;
extern void lynx_start_h1_color NOPARAMS;
extern void lynx_stop_h1_color NOPARAMS;
extern void lynx_start_prompt_color NOPARAMS;
extern void lynx_stop_prompt_color NOPARAMS;
extern void lynx_start_radio_color NOPARAMS;
extern void lynx_stop_radio_color NOPARAMS;
extern void lynx_stop_all_colors NOPARAMS;

extern void lynx_start_bold NOPARAMS;
extern void lynx_start_reverse NOPARAMS;
extern void lynx_start_underline NOPARAMS;
extern void lynx_stop_bold NOPARAMS;
extern void lynx_stop_reverse NOPARAMS;
extern void lynx_stop_underline NOPARAMS;
d801 1
a801 1
#define SetOutputMode(mode) /* nothing */
d807 1
a807 1
#define SetDefaultMode(mode) /* nothing */
d815 1
a815 1
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 1))
d817 1
a817 1
#define LYHideCursor() LYmove((LYlines - 1), (LYcols - 2))
d820 1
a820 1
extern void LYstowCursor PARAMS((WINDOW * win, int row, int col));
d822 4
a825 1
#endif /* LYCURSES_H */
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d368 18
@


1.4.2.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@a367 18
/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d62 1
a62 1
#define wmove(win, row, col) SLsmg_gotorc((win)->top_y + (row), (win)->left_x + (col));
d88 1
a88 1
#ifndef ACS_UARROW  
d173 4
d178 6
a183 1
# ifdef HAVE_NCURSES_NCURSES_H
a184 3
# else
#  ifdef HAVE_NCURSES_H
#   include <ncurses.h>
d186 2
a187 2
#   ifdef HAVE_CURSESX_H
#    include <cursesX.h>	/* Ultrix */
d189 2
a190 2
#    ifdef HAVE_JCURSES_H
#     include <jcurses.h>	/* sony_news */
d192 2
a193 2
#     ifdef HAVE_XCURSES
#      include <xcurses.h>	/* PDCurses' UNIX port */
d195 5
a199 1
#      include <curses.h>	/* default */
d211 2
a212 2
#  if defined(NCURSES) && defined(HAVE_NCURSES_TERM_H)
#    include <ncurses/term.h>
d214 9
a222 2
#   if defined(HAVE_TERM_H)
#    include <term.h>
d256 1
a256 1
#if defined(HAVE_NEWPAD) && defined(HAVE_PNOUTREFRESH)
d268 17
d289 1
d292 1
a301 3
#if !defined(HAVE_GETATTRS) && !defined(getattrs)
#define getattrs(win) ((win)->_attrs)
#endif
d312 10
d324 11
d429 1
a429 1
#if USE_COLOR_TABLE
d450 1
a450 1
#define start_bold()      	LYaddAttr(1)
d452 2
a453 2
#define start_underline() 	LYaddAttr(4)
#define stop_bold()       	LYsubAttr(1)
d455 1
a455 1
#define stop_underline()  	LYsubAttr(4)
d464 1
a464 1
#define stdscr NULL
d527 4
a530 11
#ifdef UNDERLINE_LINKS
#define start_bold()		setattr(_UNDERLINE)
#define stop_bold()		clrattr(_UNDERLINE)
#define start_underline()	setattr(_BOLD)
#define stop_underline()	clrattr(_BOLD)
#else /* not UNDERLINE_LINKS */
#define start_bold()		setattr(_BOLD)
#define stop_bold()		clrattr(_BOLD)
#define start_underline()	setattr(_UNDERLINE)
#define stop_underline()	clrattr(_UNDERLINE)
#endif /* UNDERLINE_LINKS */
d545 1
a545 1
#if USE_COLOR_TABLE
d564 4
a567 20
#ifdef UNDERLINE_LINKS
#define start_bold()		LYaddAttr(A_UNDERLINE)
#define stop_bold()		LYsubAttr(A_UNDERLINE)
#ifdef __CYGWIN__	/* 1999/02/25 (Thu) 01:09:45 */
#define start_underline()	/* LYaddAttr(A_BOLD) */
#define stop_underline()	/* LYsubAttr(A_BOLD) */
#else
#define start_underline()	LYaddAttr(A_BOLD)
#define stop_underline()	LYsubAttr(A_BOLD)
#endif /* __CYGWIN__ */
#else /* not UNDERLINE_LINKS: */
#define start_bold()		LYaddAttr(A_BOLD)
#define stop_bold()		LYsubAttr(A_BOLD)
#ifdef USE_COLOR_STYLE
#define start_underline()	attron(A_UNDERLINE) /* allow combining - kw */
#else
#define start_underline()	LYaddAttr(A_UNDERLINE)
#endif /* USE_COLOR_STYLE */
#define stop_underline()	LYsubAttr(A_UNDERLINE)
#endif /* UNDERLINE_LINKS */
d609 10
a618 1
#ifndef ACS_UARROW  
d634 8
d659 1
a659 1
 * If the screen library allows us to specify "default" color, allow user to 
d662 2
a663 2
#if USE_DEFAULT_COLORS
#if USE_SLANG || (HAVE_ASSUME_DEFAULT_COLORS && !defined(USE_COLOR_STYLE))
d686 7
@


1.3.2.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@a313 18
/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

@


1.3.4.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@a313 18
/*
 * The scrollbar, if used, occupies the rightmost column.
 */
#ifdef USE_SCROLLBAR
#define LYbarWidth (LYShowScrollbar ? 1 : 0)
#else
#define LYbarWidth 0
#endif

/*
 * Usable limits for display:
 */
#if defined(FANCY_CURSES) || defined(USE_SLANG)
#define LYcolLimit (LYcols - LYbarWidth)
#else
#define LYcolLimit (LYcols - 1)
#endif

@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d9 21
a48 3
#if defined(UNIX) && !defined(unix)
#define unix
#endif /* UNIX && !unix */
d51 61
d156 17
d174 2
a175 2
# ifdef HAVE_NCURSES_H
#  include <ncurses.h>
d177 2
a178 2
#  ifdef HAVE_CURSESX_H
#   include <cursesX.h>		/* Ultrix */
d180 2
a181 2
#   ifdef HAVE_JCURSES_H
#    include <jcurses.h>	/* sony_news */
d183 9
a191 1
#    include <curses.h>		/* default */
d200 9
a208 3
# ifdef NCURSES
extern void LYsubwindow PARAMS((WINDOW * param));
# endif /* NCURSES */
d210 3
a212 4
#if defined(NCURSES_VERSION) && defined(HAVE_DEFINE_KEY)
#include <term.h>
#define USE_KEYMAPS		1
#endif
d217 2
a218 2
# else
#  include <curses.h>  /* everything else */
d222 33
a254 2
#ifdef VMS
extern void VMSbox PARAMS((WINDOW *win, int height, int width));
d256 4
d261 17
a277 2
#endif /* VMS */
#endif /* USE_SLANG */
d279 3
d311 20
a330 2
extern int LYlines;  /* replaces LINES */
extern int LYcols;   /* replaces COLS */
a331 2
extern void start_curses NOPARAMS;
extern void stop_curses NOPARAMS;
d333 9
d344 8
a364 1
extern void curses_w_style PARAMS((WINDOW* win, int style, int dir));
d368 3
a370 1
#define LynxChangeStyle(style,dir,previous) curses_style(style,dir)
d372 1
a372 2
extern int slang_style PARAMS((int style, int dir, int previous));
#define LynxChangeStyle(style,dir,previous) slang_style(style,dir,previous)
d383 1
d386 1
a386 1
#define USE_SLANG_MOUSE		1
d389 1
a389 1
#if !defined(__DJGPP__)
d394 1
a394 2
#define SL_LYNX_USE_BLINK	2
#define SL_LYNX_OVERRIDE_COLOR	4
a409 3
#ifndef WINDOW
#define WINDOW void
#endif
d434 6
a439 1
#define addch SLsmg_write_char
d441 1
a441 1
#define printw SLsmg_printf
d457 1
a457 1
#define endwin() clear(),refresh(),SLsmg_reset_smg(),VTHome()
d465 1
d485 1
a485 2
#define wstart_reverse(a)	wsetattr(a, _REVERSE)
#define wstop_underline(a)	wclrattr(a, _UNDERLINE)
d487 1
a487 1
#define wstop_reverse(a)	wclrattr(a, _REVERSE)
d491 2
d511 4
a514 4
#define LYaddAttr		attrset
#define LYaddWAttr		wattrset
#define LYsubAttr		attroff
#define LYsubWAttr		wattroff
d520 4
d526 1
d537 1
d539 4
a542 4
#define start_reverse()		LYaddWAttr(stdscr, A_DIM)
#define wstart_reverse(a)	LYaddWAttr(a, A_DIM)
#define stop_reverse()		LYsubWAttr(stdscr, A_DIM)
#define wstop_reverse(a)	LYsubWAttr(a, A_DIM)
d545 1
a545 1
#define wstart_reverse(a)	LYaddWAttr(a, A_REVERSE)
d547 1
a547 1
#define wstop_reverse(a)	LYsubWAttr(a, A_REVERSE)
d549 1
d577 21
d604 1
a604 1
#define LYGetYX(y, x)   getyx(stdscr, y, x)
d606 1
a606 1
#define LYGetYX(y, x)   y = stdscr->_cury, x = stdscr->_curx
d610 10
d622 1
d647 2
a648 2
#if defined(_WINDOWS) || defined(DJGPP) || defined(__EMX__)
#define SetOutputMode(mode) setmode(fileno(stdout), mode)
d658 12
@


1.1
log
@Initial revision
@
text
@d4 3
a6 1
#include "userdefs.h"
a30 3
#ifdef va_start
#undef va_start	 /* not used, undef to avoid warnings on some systems */
#endif /* va_start */
d100 5
d107 1
a107 1
#  include "LYGCurses.h"
a151 4
#ifndef HTUTILS_H
#include "HTUtils.h"
#endif /* HTUTILS_H */

d159 1
d164 1
a164 1
extern void *VMSsignal PARAMS((int sig, void (*func)()));
d169 2
a170 2
extern void curses_style PARAMS((int style, int dir, int previous));
extern void curses_w_style PARAMS((WINDOW* win, int style, int dir, int previous));
d174 1
a174 1
#define LynxChangeStyle curses_style
d177 1
a177 1
#define LynxChangeStyle slang_style
d188 1
d191 5
a195 1
#endif /* USE_SLANG */
d200 1
d215 3
a300 1
extern void LYaddAttr PARAMS((int a));
a301 1
extern void LYsubAttr PARAMS((int a));
d326 3
d330 1
d348 8
d400 20
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
