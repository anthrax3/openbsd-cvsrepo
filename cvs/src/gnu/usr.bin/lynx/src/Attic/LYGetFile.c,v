head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.08;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.57;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.57;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYGetFile.c,v 1.92 2013/11/28 11:18:56 tom Exp $ */
#include <HTUtils.h>
#include <HTTP.h>
#include <HTAnchor.h>		/* Anchor class */
#include <HTAccess.h>
#include <HTParse.h>
#include <LYCurses.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <HTAlert.h>
#include <LYSignal.h>
#include <LYGetFile.h>
#include <LYPrint.h>
#include <LYOptions.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYDownload.h>
#include <LYNews.h>
#include <LYMail.h>
#include <LYKeymap.h>
#include <LYBookmark.h>
#include <LYMap.h>
#include <LYList.h>
#ifdef DIRED_SUPPORT
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */
#include <LYReadCFG.h>
#include <LYHistory.h>
#include <LYPrettySrc.h>

#include <LYexit.h>
#include <LYLeaks.h>

static int fix_httplike_urls(DocInfo *doc, UrlTypes type);

#ifdef VMS
#define STRNADDRCOMP strncasecomp
#else
#define STRNADDRCOMP strncmp
#endif /* !VMS */

int HTNoDataOK = 0;

/*
 * getfile is the main mechanism to load a new document (or a previously loaded
 * one whose rendering is cached in a HText structure) from mainloop, nearly
 * everything goes through it.
 * It should return one of the values
 *     NORMAL     - requested document loaded successfully, usually [always?]
 *                  its rendering is available as HTMainText.  It can be an
 *                  HTTP error message page or similar, we make no
 *                  distinction here.
 *     NOT_FOUND  - requested document cannot be accessed, and the reason
 *                  is a real error (as may be caused by an invalid link),
 *                  not just that lynx disallows access because of some
 *                  permission restrictions, and we have no error page
 *                  to show for it either.
 *     NULLFILE   - requested document not loaded into HTMainText, either
 *                  some interactive protocol was requested (like telnet),
 *                  or lynx does not allow access.
 * The distinction between NOT_FOUND and NULLFILE is not very crucial, but
 * getting it right prevents mainloop from exiting with the wrong message if it
 * happens for the first file, and from logging (or not logging) errors
 * inappropriately with -traversal, and from sending bogus error mail with
 * MAIL_SYSTEM_ERROR_LOGGING:TRUE.  - kw
 */
int getfile(DocInfo *doc, int *target)
{
    UrlTypes url_type = NOT_A_URL_TYPE;
    char *pound;
    char *cp = NULL;
    char *temp = NULL;
    DocAddress WWWDoc;		/* a WWW absolute doc address struct */

    /*
     * Reset LYCancelDownload to prevent unwanted delayed effect.  - KW
     */
    if (LYCancelDownload) {
	CTRACE((tfp, "getfile:    resetting LYCancelDownload to FALSE\n"));
	LYCancelDownload = FALSE;
    }

    /*
     * Reset fake 'Z' to prevent unwanted delayed effect.  - kw
     */
    LYFakeZap(NO);

    /*
     * Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS in rare
     * situations if the previous cycle got to the limit, but did not fail for
     * that reason because the URL of the final location was handled specially,
     * not via HTLoadAbsolute.  - kw
     */
    redirection_attempts = 0;

  Try_Redirected_URL:
    /*
     * Load the WWWDoc struct in case we need to use it.
     */
    WWWDoc.address = doc->address;
    WWWDoc.post_data = doc->post_data;
    WWWDoc.post_content_type = doc->post_content_type;
    WWWDoc.bookmark = doc->bookmark;
    WWWDoc.isHEAD = doc->isHEAD;
    WWWDoc.safe = doc->safe;

    /*
     * Reset HTPermitRedir, it has done its job if it was set.  - kw
     */
    HTPermitRedir = FALSE;

    /*
     * Reset WWW_Download_File just in case.
     */
    FREE(WWW_Download_File);

    /*
     * Reset redirect_post_content just in case.
     */
    redirect_post_content = FALSE;

    /*
     * This flag is a hack to allow us to pass on the fact that 'no data' may
     * not really be an error although HTLoadAbsolute returned NO.  There
     * should be a better way...  HT_NO_DATA should always mean 'not data but
     * not an error', and be passed on to us as that, but current usage if
     * HT_NO_DATA vs HT_NOT_LOADED has to be reviewed everywhere.  Anyway, some
     * protocol module can set it to say 'I really mean it', we have to reset
     * it here.  - kw
     */
    HTNoDataOK = 0;

    CTRACE((tfp, "getfile: getting %s\n\n", doc->address));

    /*
     * Protect against denial of service attacks via the port 19 CHARGEN
     * service, and block connections to the port 25 ESMTP service.  Also
     * reject any likely spoof attempts via wrap arounds at 65536.  - FM
     */
    if ((temp = HTParse(doc->address, "", PARSE_HOST)) != NULL &&
	strlen(temp) > 3) {
	char *cp1;

	if ((cp1 = StrChr(temp, '@@')) == NULL)
	    cp1 = temp;
	if ((cp = strrchr(cp1, ':')) != NULL) {
	    long int value;

	    cp++;
	    if (sscanf(cp, "%ld", &value) == 1) {
		if (value == 19 || value == 65555) {
		    HTAlert(PORT_NINETEEN_INVALID);
		    FREE(temp);
		    return (NULLFILE);
		} else if (value == 25 || value == 65561) {
		    HTAlert(PORT_TWENTYFIVE_INVALID);
		    FREE(temp);
		    return (NULLFILE);
		} else if (value > 65535 || value < 0) {
		    char *msg = 0;

		    HTSprintf0(&msg, PORT_INVALID, (unsigned long) value);
		    HTAlert(msg);
		    FREE(msg);
		    FREE(temp);
		    return (NULLFILE);
		}
	    } else if (isdigit(UCH(*cp))) {
		HTAlert(URL_PORT_BAD);
		FREE(temp);
		return (NULLFILE);
	    }
	}
    }
    cp = NULL;
    FREE(temp);

    /*
     * Check to see if this is a universal document ID that lib WWW wants to
     * handle.
     *
     * Some special URL's we handle ourselves.  :)
     */
    if ((url_type = is_url(doc->address)) != 0) {
	if (LYValidate && !LYPermitURL) {
	    if (!(url_type == HTTP_URL_TYPE ||
		  url_type == HTTPS_URL_TYPE ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXEDITMAP_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
#ifdef USE_CACHEJAR
		  url_type == LYNXCACHE_URL_TYPE ||
#endif
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  (url_type == LYNXOPTIONS_URL_TYPE &&
		   WWWDoc.post_data) ||
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
		  (lynxlinksfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				     strlen(lynxlinksfile))) ||
		  (lynxjumpfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_HTTP_URL_OR_ACTION);
		return (NULLFILE);
	    }
	}
	if (traversal) {
	    /*
	     * Only traverse http URLs.
	     */
	    if (url_type != HTTP_URL_TYPE &&
		url_type != LYNXIMGMAP_URL_TYPE) {
		return (NULLFILE);
	    }
	} else if (check_realm && !LYPermitURL && !LYJumpFileURL) {
	    if (!(0 == StrNCmp(startrealm, WWWDoc.address,
			       strlen(startrealm)) ||
		  url_type == LYNXHIST_URL_TYPE ||
		  url_type == LYNXEDITMAP_URL_TYPE ||
		  url_type == LYNXKEYMAP_URL_TYPE ||
		  url_type == LYNXIMGMAP_URL_TYPE ||
		  url_type == LYNXCOOKIE_URL_TYPE ||
#ifdef USE_CACHEJAR
		  url_type == LYNXCACHE_URL_TYPE ||
#endif
		  url_type == LYNXPRINT_URL_TYPE ||
		  url_type == LYNXOPTIONS_URL_TYPE ||
		  url_type == LYNXCFG_URL_TYPE ||
		  url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		  url_type == LYNXMESSAGES_URL_TYPE ||
		  url_type == LYNXDOWNLOAD_URL_TYPE ||
		  url_type == MAILTO_URL_TYPE ||
		  url_type == NEWSPOST_URL_TYPE ||
		  url_type == NEWSREPLY_URL_TYPE ||
		  url_type == SNEWSPOST_URL_TYPE ||
		  url_type == SNEWSREPLY_URL_TYPE ||
		  (!LYUserSpecifiedURL &&
		   (url_type == LYNXEXEC_URL_TYPE ||
		    url_type == LYNXPROG_URL_TYPE ||
		    url_type == LYNXCGI_URL_TYPE)) ||
		  (WWWDoc.bookmark != NULL &&
		   *WWWDoc.bookmark != '\0') ||
		  0 == STRNADDRCOMP(WWWDoc.address, helpfilepath,
				    strlen(helpfilepath)) ||
		  (lynxlistfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				     strlen(lynxlistfile))) ||
		  (lynxjumpfile != NULL &&
		   0 == STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				     strlen(lynxjumpfile))))) {
		HTUserMsg(NOT_IN_STARTING_REALM);
		return (NULLFILE);
	    }
	}
	if (WWWDoc.post_data &&
	    url_type != HTTP_URL_TYPE &&
	    url_type != HTTPS_URL_TYPE &&
	    url_type != LYNXCGI_URL_TYPE &&
	    url_type != LYNXIMGMAP_URL_TYPE &&
	    url_type != GOPHER_URL_TYPE &&
	    url_type != CSO_URL_TYPE &&
	    url_type != PROXY_URL_TYPE &&
	    url_type != LYNXOPTIONS_URL_TYPE &&
	    !(url_type == FILE_URL_TYPE &&
	      (LYIsUIPage(WWWDoc.address, UIP_LIST_PAGE) ||
	       LYIsUIPage(WWWDoc.address, UIP_ADDRLIST_PAGE)))) {
	    CTRACE((tfp, "getfile: dropping post_data!\n"));
	    HTAlert(IGNORED_POST);
	    LYFreePostData(doc);
	    WWWDoc.post_data = NULL;
	    WWWDoc.post_content_type = NULL;
	}
#ifdef SYSLOG_REQUESTED_URLS
	LYSyslog(doc->address);
#endif
	if (url_type == UNKNOWN_URL_TYPE ||
	    url_type == AFS_URL_TYPE ||
	    url_type == PROSPERO_URL_TYPE) {
	    HTAlert(UNSUPPORTED_URL_SCHEME);
	    return (NULLFILE);

	} else if (url_type == DATA_URL_TYPE) {
	    HTAlert(UNSUPPORTED_DATA_URL);
	    return (NULLFILE);

	} else if (url_type == LYNXPRINT_URL_TYPE) {
	    return (printfile(doc));

#ifndef NO_OPTION_FORMS
	} else if (url_type == LYNXOPTIONS_URL_TYPE) {
	    /* proceed forms-based options menu */
	    return (postoptions(doc));
#endif

	} else if (url_type == LYNXCFG_URL_TYPE &&
		   !no_lynxcfg_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted. - kw */
	    /* show/change/reload lynx.cfg settings */
	    return (lynx_cfg_infopage(doc));

#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE &&
		   !no_compileopts_info) {
	    /* @@@@@@ maybe we should generate a specific error message
	       if attempted but restricted or not supported. - kw */
	    /* show compile-time settings */
	    return (lynx_compile_opts(doc));
#endif

#ifndef DISABLE_NEWS
	} else if (url_type == NEWSPOST_URL_TYPE ||
		   url_type == NEWSREPLY_URL_TYPE ||
		   url_type == SNEWSPOST_URL_TYPE ||
		   url_type == SNEWSREPLY_URL_TYPE) {

	    if (no_newspost) {
		HTUserMsg(NEWSPOSTING_DISABLED);
		return (NULLFILE);
	    } else if (!news_ok && (url_type == NEWSPOST_URL_TYPE ||
				    url_type == NEWSREPLY_URL_TYPE)) {
		HTUserMsg(NEWS_DISABLED);
		return (NULLFILE);
	    } else {
		HTLoadAbsolute(&WWWDoc);
		return (NULLFILE);
	    }
#endif

	} else if (url_type == LYNXDOWNLOAD_URL_TYPE) {
	    LYDownload(doc->address);
#ifdef VMS
	    if (LYDidRename) {
		/*
		 * The temporary file was saved to disk via a rename(), so we
		 * can't access the temporary file again via the download menu. 
		 * Clear the flag, and return NULLFILE to pop.  - FM
		 */
		LYDidRename = FALSE;
		return (NULLFILE);
	    }
#endif /* VMS */
	    return (NORMAL);
	} else if (url_type == LYNXDIRED_URL_TYPE) {
#ifdef DIRED_SUPPORT
	    if (!no_dired_support) {
		local_dired(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;

		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		}
		return (NORMAL);
	    }
#endif /* DIRED_SUPPORT */
	    HTUserMsg(DIRED_DISABLED);
	    return (NULLFILE);
	}

	if (LYNoRefererHeader == FALSE &&
	    LYNoRefererForThis == FALSE) {
	    const char *ref_url = HTLoadedDocumentURL();

	    if (isLYNXIMGMAP(ref_url))
		ref_url += LEN_LYNXIMGMAP;
	    if (no_filereferer == TRUE && isFILE_URL(ref_url)) {
		LYNoRefererForThis = TRUE;
	    }
	    if (LYNoRefererForThis == FALSE &&
		(cp = StrChr(ref_url, '?')) != NULL &&
		StrChr(cp, '=') != NULL) {
		/*
		 * Don't send a Referer header if the URL is the reply from a
		 * form with method GET, in case the content has personal data
		 * (e.g., a password or credit card number) which would become
		 * visible in logs.  - FM
		 *
		 * Changed 1999-11-01 to be controlled by REFERER_WITH_QUERY
		 * option.  - kw
		 */
		if (LYRefererWithQuery == 'S') {	/* SEND */
		    StrAllocCopy(LYRequestReferer, ref_url);
		} else if (LYRefererWithQuery == 'P') {		/* PARTIAL */
		    FREE(LYRequestReferer);	/* just to be sure */
		    LYRequestReferer = HTParse(ref_url, "",
					       PARSE_ACCESS
					       | PARSE_HOST
					       | PARSE_STRICTPATH
					       | PARSE_PUNCTUATION);
		} else {	/* Everything else - don't send Referer */
		    LYNoRefererForThis = TRUE;
		}
		cp = NULL;
	    } else if (LYNoRefererForThis == FALSE) {
		StrAllocCopy(LYRequestReferer, ref_url);
	    }
	} else {
	    StrAllocCopy(LYRequestReferer, HTLoadedDocumentURL());
	}
	if (url_type == LYNXHIST_URL_TYPE) {
	    /*
	     * 'doc' will change to the new file if we had a successful
	     * LYpop_num(), and the return value will be FALSE if we had a
	     * cancel.  - FM
	     */
	    if ((historytarget(doc) == FALSE) ||
		!doc || !doc->address) {
		return (NOT_FOUND);
	    }

	    /*
	     * We changed it so reload.
	     */
	    WWWDoc.address = doc->address;
	    WWWDoc.post_data = doc->post_data;
	    WWWDoc.post_content_type = doc->post_content_type;
	    WWWDoc.bookmark = doc->bookmark;
	    WWWDoc.isHEAD = doc->isHEAD;
	    WWWDoc.safe = doc->safe;
	    if (track_internal_links && doc->internal_link && !reloading) {
		LYinternal_flag = TRUE;
	    }
#ifdef DIRED_SUPPORT
	    lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return (NOT_FOUND);
	    }
	    return (NORMAL);

	} else if (url_type == LYNXEXEC_URL_TYPE ||
		   url_type == LYNXPROG_URL_TYPE) {
#ifdef EXEC_LINKS
	    if (no_exec &&
		!exec_ok(HTLoadedDocumentURL(),
			 doc->address + 9, ALWAYS_EXEC_PATH)) {
		HTUserMsg(EXECUTION_DISABLED);
	    } else if (no_bookmark_exec &&
		       HTLoadedDocumentBookmark()) {
		HTUserMsg(BOOKMARK_EXEC_DISABLED);
	    } else if (local_exec || (local_exec_on_local_files &&
				      exec_ok(HTLoadedDocumentURL(),
					      doc->address + 9, EXEC_PATH))) {

		char *p = NULL;

		/*
		 * Bug puts slash on end if none is in the string.
		 */
		char *last_slash = strrchr(doc->address, '/');

		if (last_slash - doc->address
		    == (int) strlen(doc->address) - 1)
		    doc->address[strlen(doc->address) - 1] = '\0';

		/*
		 * Convert '~' to $HOME.
		 */
		StrAllocCopy(p, doc->address);
		LYTildeExpand(&p, TRUE);

		/*
		 * Show URL before executing it.
		 */
		HTInfoMsg(doc->address);
		stop_curses();
		/*
		 * Run the command.
		 */
		if (strstr(p, "//") == p + 9)
		    LYSystem(p + 11);
		else
		    LYSystem(p + 9);
		FREE(p);

		if (url_type != LYNXPROG_URL_TYPE) {
		    /*
		     * Make sure user gets to see screen output.
		     */
#ifndef VMS
		    signal(SIGINT, SIG_IGN);
#endif /* !VMS */
		    printf("\n%s", RETURN_TO_LYNX);
		    fflush(stdout);
		    (void) LYgetch();
#ifdef VMS
		    HadVMSInterrupt = FALSE;
#endif /* VMS */
		}
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}

	    } else {
		char *buf = 0;

		HTSprintf0(&buf,
			   EXECUTION_DISABLED_FOR_FILE,
			   key_for_func(LYK_OPTIONS));
		HTAlert(buf);
		FREE(buf);
	    }
#else /* no exec_links */
	    HTUserMsg(EXECUTION_NOT_COMPILED);
#endif /* EXEC_LINKS */
	    return (NULLFILE);

	} else if (url_type == MAILTO_URL_TYPE) {
	    if (no_mail) {
		HTUserMsg(MAIL_DISABLED);
	    } else if (!dump_output_immediately) {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		const char *title;
		char *tmptitle = NULL;

		title = "";
		if (HTAnchor_title(tmpanchor)) {
		    title = HTAnchor_title(tmpanchor);
		} else if (HTMainAnchor && !LYUserSpecifiedURL) {
		    title = HTAnchor_subject(HTMainAnchor);
		    if (non_empty(title)) {
			if (strncasecomp(title, "Re:", 3)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, title);
			    title = tmptitle;
			}
		    } else {
			title = "";
		    }
		}
		cp = StrChr(doc->address, ':') + 1;
		reply_by_mail(cp,
			      ((HTMainAnchor && !LYUserSpecifiedURL)
			       ? (char *) HTMainAnchor->address
			       : (char *) doc->address),
			      title,
			      (HTMainAnchor && !LYUserSpecifiedURL)
			      ? HTMainAnchor->message_id
			      : NULL);
		FREE(tmptitle);
	    }
	    return (NULLFILE);

	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     */
	} else if (local_host_only &&
		   url_type != LYNXEDITMAP_URL_TYPE &&
		   url_type != LYNXKEYMAP_URL_TYPE &&
		   url_type != LYNXIMGMAP_URL_TYPE &&
		   url_type != LYNXCOOKIE_URL_TYPE &&
		   url_type != LYNXMESSAGES_URL_TYPE &&
#ifdef USE_CACHEJAR
		   url_type != LYNXCACHE_URL_TYPE &&
#endif
		   url_type != LYNXCGI_URL_TYPE &&
		   !(url_type == NEWS_URL_TYPE &&
		     StrNCmp(doc->address, "news://", 7)) &&
		   !(LYisLocalHost(doc->address) ||
		     LYisLocalAlias(doc->address))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	    return (NULLFILE);

	    /*
	     * Disable www telnet access if not telnet_ok.
	     */
	} else if (url_type == TELNET_URL_TYPE ||
		   url_type == TN3270_URL_TYPE ||
		   url_type == TELNET_GOPHER_URL_TYPE) {
	    char *proxy;

	    if (!telnet_ok) {
		HTUserMsg(TELNET_DISABLED);
		return (NULLFILE);
	    } else if (no_telnet_port && StrChr(doc->address + 7, ':')) {
		HTUserMsg(TELNET_PORT_SPECS_DISABLED);
		return (NULLFILE);
		/*
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
		 */
	    } else if ((proxy = LYGetEnv(((url_type == TN3270_URL_TYPE)
					  ? "tn3270_proxy"
					  :
					  ((url_type == TELNET_GOPHER_URL_TYPE)
					   ? "gopher_proxy"
					   : "telnet_proxy")))) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		if (!dump_output_immediately) {
		    start_curses();
		    fflush(stdout);
		    LYAddVisitedLink(doc);
		}
		return (NULLFILE);
	    }

	    /*
	     * Disable www news access if not news_ok.
	     */
#ifndef DISABLE_NEWS
	} else if (!news_ok && (url_type == NEWS_URL_TYPE ||
				url_type == NNTP_URL_TYPE)) {
	    HTUserMsg(NEWS_DISABLED);
	    return (NULLFILE);
#endif

	} else if (url_type == RLOGIN_URL_TYPE) {
	    char *proxy;

	    if (!rlogin_ok) {
		HTUserMsg(RLOGIN_DISABLED);
		return (NULLFILE);
		/*
		 * Detect weird case where interactive protocol would be
		 * proxied, and to a non-interactive protocol at that.
		 */
	    } else if ((proxy = LYGetEnv("rlogin_proxy")) != NULL &&
		       !override_proxy(doc->address) &&
		       (!isTELNET_URL(proxy) &&
			!isTN3270_URL(proxy) &&
			!isRLOGIN_URL(proxy))) {
		/* Do nothing, fall through to generic code - kw */
	    } else {
		stop_curses();
		HTLoadAbsolute(&WWWDoc);
		fflush(stdout);
		if (!dump_output_immediately) {
		    start_curses();
		    LYAddVisitedLink(doc);
		}
		return (NULLFILE);
	    }

	    /*
	     * If it's a gopher index type and there isn't a search term
	     * already attached then do this.  Otherwise just load it!
	     */
	} else if (url_type == INDEX_GOPHER_URL_TYPE &&
		   StrChr(doc->address, '?') == NULL) {
	    int status;

	    /*
	     * Make sure we don't have a gopher+ escaped tab instead of a
	     * gopher0 question mark delimiting the search term.  - FM
	     */
	    if ((cp = strstr(doc->address, "%09")) != NULL) {
		*cp = '\0';
		StrAllocCopy(temp, doc->address);
		cp += 3;
		if (*cp && StrNCmp(cp, "%09", 3)) {
		    StrAllocCat(temp, "?");
		    StrAllocCat(temp, cp);
		    if ((cp = strstr(temp, "%09")) != NULL) {
			*cp = '\0';
		    }
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		goto Try_Redirected_URL;
	    }
	    /*
	     * Load it because the do_www_search routine uses the base url of
	     * the currently loaded document :(
	     */
	    if (!HTLoadAbsolute(&WWWDoc)) {
		return (NOT_FOUND);
	    }
	    status = do_www_search(doc);
	    if (status == NULLFILE) {
		LYpop(doc);
		WWWDoc.address = doc->address;
		WWWDoc.post_data = doc->post_data;
		WWWDoc.post_content_type = doc->post_content_type;
		WWWDoc.bookmark = doc->bookmark;
		WWWDoc.isHEAD = doc->isHEAD;
		WWWDoc.safe = doc->safe;
		status = HTLoadAbsolute(&WWWDoc);
#ifdef DIRED_SUPPORT
	    } else {
		lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */
	    }
	    return (status);
	}

	if (!ftp_ok
	    && (url_type == FTP_URL_TYPE
		|| url_type == NCFTP_URL_TYPE)) {
	    HTUserMsg(FTP_DISABLED);
	    return (NULLFILE);
	} else if (url_type == HTML_GOPHER_URL_TYPE) {
	    char *tmp = NULL;

	    /*
	     * If tuple's Path=GET%20/...  convert to an http URL.
	     */
	    if ((cp = StrChr(doc->address + 9, '/')) != NULL &&
		0 == StrNCmp(++cp, "hGET%20/", 8)) {
		StrAllocCopy(tmp, "http://");
		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp = '\0';
		StrAllocCat(tmp, doc->address + 9);
		/*
		 * If the port is defaulted, it should stay 70.
		 */
		if (StrChr(tmp + 6, ':') == NULL) {
		    StrAllocCat(tmp, "70/");
		    tmp[strlen(tmp) - 4] = ':';
		}
		if (strlen(cp + 7) > 1)
		    StrAllocCat(tmp, cp + 8);
		StrAllocCopy(doc->address, tmp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		FREE(tmp);
		url_type = HTTP_URL_TYPE;
	    }
	}

	if (url_type == HTTP_URL_TYPE ||
	    url_type == HTTPS_URL_TYPE ||
	    url_type == FTP_URL_TYPE ||
	    url_type == NCFTP_URL_TYPE ||
	    url_type == CSO_URL_TYPE) {
	    fix_httplike_urls(doc, url_type);
	}

	WWWDoc.address = doc->address;	/* possible reload */
#ifdef DIRED_SUPPORT
	lynx_edit_mode = FALSE;
#endif /* DIRED_SUPPORT */

#ifndef DISABLE_BIBP
	if (url_type == BIBP_URL_TYPE) {
	    char *bibpTmp = NULL;

	    if (!BibP_bibhost_checked)
		LYCheckBibHost();
	    if (BibP_bibhost_available) {
		StrAllocCopy(bibpTmp, BibP_bibhost);
	    } else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
	    } else {
		StrAllocCopy(bibpTmp, BibP_globalserver);
	    }
	    if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		StrAllocCat(bibpTmp, "&usin=");
	    } else {
		StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
	    }
	    StrAllocCat(bibpTmp, doc->address + 5);	/* USIN after bibp: */
	    StrAllocCopy(doc->address, bibpTmp);
	    WWWDoc.address = doc->address;
	    FREE(bibpTmp);
	}
#endif /* !DISABLE_BIBP */

	if (url_type == FILE_URL_TYPE) {
	    /*
	     * If a file URL has a '~' as the lead character of its first
	     * symbolic element, convert the '~' to Home_Dir(), then append
	     * the rest of of path, if present, skipping "user" if "~user"
	     * was entered, simplifying, and eliminating any residual
	     * relative elements.  - FM
	     */
	    LYTildeExpand(&(doc->address), TRUE);
	    WWWDoc.address = doc->address;
	}
	CTRACE_SLEEP(MessageSecs);
	user_message(WWW_WAIT_MESSAGE, doc->address);

	if (TRACE) {
#ifdef USE_SLANG
	    if (LYCursesON) {
		LYaddstr("*\n");
		LYrefresh();
	    }
#endif /* USE_SLANG */
	    CTRACE((tfp, "\n"));
	}

	if (!HTLoadAbsolute(&WWWDoc)) {
	    /*
	     * Check for redirection.
	     */
	    if (use_this_url_instead != NULL) {
		if (!is_url(use_this_url_instead)) {
		    /*
		     * The server did not return a complete URL in its
		     * Location:  header, probably due to a FORM or other
		     * CGI script written by someone who doesn't know that
		     * the http protocol requires that it be a complete
		     * URL, or using a server which does not treat such a
		     * redirect string from the script as an instruction to
		     * resolve it versus the initial request, check
		     * authentication with that URL, and then act on it
		     * without returning redirection to us.  We'll violate
		     * the http protocol and resolve it ourselves using the
		     * URL of the original request as the BASE, rather than
		     * doing the RIGHT thing and returning an invalid
		     * address message.  - FM
		     */
		    HTUserMsg(LOCATION_NOT_ABSOLUTE);
		    temp = HTParse(use_this_url_instead,
				   WWWDoc.address,
				   PARSE_ALL);
		    if (non_empty(temp)) {
			StrAllocCopy(use_this_url_instead, temp);
		    }
		    FREE(temp);
		}
		url_type = is_url(use_this_url_instead);
		if (!HTPermitRedir &&
		    (url_type == LYNXDOWNLOAD_URL_TYPE ||
		     url_type == LYNXEXEC_URL_TYPE ||
		     url_type == LYNXPROG_URL_TYPE ||
#ifdef DIRED_SUPPORT
		     url_type == LYNXDIRED_URL_TYPE ||
#endif /* DIRED_SUPPORT */
		     url_type == LYNXPRINT_URL_TYPE ||
		     url_type == LYNXOPTIONS_URL_TYPE ||
		     url_type == LYNXCFG_URL_TYPE ||
		     url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
		     url_type == LYNXHIST_URL_TYPE ||
		     url_type == LYNXCOOKIE_URL_TYPE ||
#ifdef USE_CACHEJAR
		     url_type == LYNXCACHE_URL_TYPE ||
#endif
		     url_type == LYNXMESSAGES_URL_TYPE ||
		     (LYValidate &&
		      url_type != HTTP_URL_TYPE &&
		      url_type != HTTPS_URL_TYPE) ||
		     ((no_file_url || no_goto_file) &&
		      url_type == FILE_URL_TYPE) ||
		     (no_goto_lynxcgi &&
		      url_type == LYNXCGI_URL_TYPE) ||
#ifndef DISABLE_BIBP
		     (no_goto_bibp &&
		      url_type == BIBP_URL_TYPE) ||
#endif
		     (no_goto_cso &&
		      url_type == CSO_URL_TYPE) ||
		     (no_goto_finger &&
		      url_type == FINGER_URL_TYPE) ||
		     (no_goto_ftp &&
		      (url_type == FTP_URL_TYPE ||
		       url_type == NCFTP_URL_TYPE)) ||
		     (no_goto_gopher &&
		      url_type == GOPHER_URL_TYPE) ||
		     (no_goto_http &&
		      url_type == HTTP_URL_TYPE) ||
		     (no_goto_https &&
		      url_type == HTTPS_URL_TYPE) ||
		     (no_goto_mailto &&
		      url_type == MAILTO_URL_TYPE) ||
#ifndef DISABLE_NEWS
		     (no_goto_news &&
		      url_type == NEWS_URL_TYPE) ||
		     (no_goto_nntp &&
		      url_type == NNTP_URL_TYPE) ||
#endif
		     (no_goto_rlogin &&
		      url_type == RLOGIN_URL_TYPE) ||
#ifndef DISABLE_NEWS
		     (no_goto_snews &&
		      url_type == SNEWS_URL_TYPE) ||
#endif
		     (no_goto_telnet &&
		      url_type == TELNET_URL_TYPE) ||
		     (no_goto_tn3270 &&
		      url_type == TN3270_URL_TYPE) ||
		     (no_goto_wais &&
		      url_type == WAIS_URL_TYPE))) {
		    /*
		     * Some schemes are not acceptable from server
		     * redirections.  - KW & FM
		     */
		    HTAlert(ILLEGAL_REDIRECTION_URL);
		    if (LYCursesON) {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				   use_this_url_instead);
		    } else {
			fprintf(stderr,
				WWW_ILLEGAL_URL_MESSAGE,
				use_this_url_instead);
		    }
		    FREE(use_this_url_instead);
		    return (NULLFILE);
		}
		if ((pound = findPoundSelector(doc->address)) != NULL
		    && findPoundSelector(use_this_url_instead) == NULL) {
		    /*
		     * Our requested URL had a fragment associated with it,
		     * and the redirection URL doesn't, so we'll append the
		     * fragment associated with the original request.  If
		     * it's bogus for the redirection URL, we'll be
		     * positioned at the top of that document, so there's
		     * no harm done.  - FM
		     */
		    CTRACE((tfp,
			    "getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
		    StrAllocCat(use_this_url_instead, pound);
		    doc->link = -1;
		}
		CTRACE_SLEEP(MessageSecs);
		HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		CTRACE((tfp, "\n"));
		StrAllocCopy(doc->address,
			     use_this_url_instead);
		FREE(use_this_url_instead);
		if (redirect_post_content == FALSE) {
		    /*
		     * Freeing the content also yields a GET request.  - FM
		     */
		    LYFreePostData(doc);
		}
		/*
		 * Go to top to check for URL's which get special handling
		 * and/or security checks in Lynx.  - FM
		 */
		goto Try_Redirected_URL;
	    }
	    if (HTNoDataOK) {
		return (NULLFILE);
	    } else {
		return (NOT_FOUND);
	    }
	} else {

	    lynx_mode = NORMAL_LYNX_MODE;

	    /*
	     * Some URL's don't actually return a document; compare
	     * doc->address with the document that is actually loaded and
	     * return NULLFILE if not loaded.  If www_search_result is not -1
	     * then this is a reference to a named anchor within the same
	     * document; do NOT return NULLFILE in that case.
	     */

	    /*
	     * Check for a #fragment selector.
	     */
	    pound = findPoundSelector(doc->address);

	    /*
	     * Check to see if there is a temp file waiting for us to
	     * download.
	     */
	    if (WWW_Download_File) {
		HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		char *fname = NULL;

		/*
		 * Check for a suggested filename from the
		 * Content-Disposition header.  - FM
		 */
		if (HTAnchor_SugFname(tmpanchor) != NULL) {
		    StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		} else {
		    StrAllocCopy(fname, doc->address);
		}
		/*
		 * Check whether this is a compressed file, which we don't
		 * uncompress for downloads, and adjust any suffix
		 * appropriately.  - FM
		 */
		HTCheckFnameForCompression(&fname, tmpanchor, FALSE);

		if (LYdownload_options(&fname,
				       WWW_Download_File) < 0) {
		    FREE(fname);
		    return (NOT_FOUND);
		}
		LYAddVisitedLink(doc);
		StrAllocCopy(doc->address, fname);
		FREE(fname);
		doc->internal_link = FALSE;
		WWWDoc.address = doc->address;
		LYFreePostData(doc);
		WWWDoc.post_data = NULL;
		WWWDoc.post_content_type = NULL;
		WWWDoc.bookmark = doc->bookmark = FALSE;
		WWWDoc.isHEAD = doc->isHEAD = FALSE;
		WWWDoc.safe = doc->safe = FALSE;
		HTOutputFormat = WWW_PRESENT;
		if (!HTLoadAbsolute(&WWWDoc)) {
		    return (NOT_FOUND);
		} else {
		    return (NORMAL);
		}

	    } else if (pound == NULL &&
		/*
		 * HTAnchor hash-table searches are now case-sensitive
		 * (hopefully, without anchor deletion problems), so this
		 * is too.  - FM
		 */
		       (strcmp(doc->address,
			       HTLoadedDocumentURL()) ||
		/*
		 * Also check the post_data elements.  - FM
		 */
			!BINEQ(doc->post_data,
			       HTLoadedDocumentPost_data()) ||
		/*
		 * Also check the isHEAD element.  - FM
		 */
			doc->isHEAD != HTLoadedDocumentIsHEAD())) {
		/*
		 * Nothing needed to be shown.
		 */
		LYAddVisitedLink(doc);
		return (NULLFILE);

	    } else {
		if (pound != NULL) {
		    if (!HTMainText) {	/* this should not happen... */
			return (NULLFILE);	/* but it can. - kw */
		    }
		    /*
		     * May set www_search_result.
		     */
		    if (HTFindPoundSelector(pound + 1)) {
			*target = www_search_result;
			doc->link = -1;
		    }
		}
		return (NORMAL);
	    }
	}
    } else {
	CTRACE_SLEEP(MessageSecs);
	HTUserMsg2(WWW_BAD_ADDR_MESSAGE, doc->address);
	CTRACE((tfp, "\n"));
	return (NULLFILE);
    }
}

/*
 * Set source mode for the next retrieval via getfile or HTreparse_document.
 * mode == -1:  force normal presentation
 * mode == 1:  force source presentation
 * mode == 0:  reset to normal if it was set to source
 * - kw
 */
void srcmode_for_next_retrieval(int mode)
{
    if (mode < 0) {
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	psrc_view = FALSE;
#endif

    } else if (mode == 0) {
	if (HTOutputFormat == WWW_SOURCE)
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	else if (LYpsrc)
	    psrc_view = FALSE;
#endif

    } else {
#ifdef USE_PRETTYSRC
	if (LYpsrc)
	    psrc_view = TRUE;
	else
	    HTOutputFormat = WWW_SOURCE;
#else
	HTOutputFormat = WWW_SOURCE;
#endif
    }
}

/*
 * The user wants to select a link or page by number.
 *
 * If follow_link_number returns DO_LINK_STUFF do_link will be run immediately
 * following its execution.
 *
 * If follow_link_number returns DO_GOTOLINK_STUFF it has updated the passed in
 * doc for positioning on a link.
 *
 * If follow_link_number returns DO_GOTOPAGE_STUFF it has set doc->line to the
 * top line of the desired page for displaying that page.
 *
 * If follow_link_number returns PRINT_ERROR an error message will be given to
 * the user.
 *
 * If follow_link_number returns DO_FORMS_STUFF some forms stuff will be done. 
 * (Not yet implemented.)
 *
 * If follow_link_number returns DO_NOTHING nothing special will run after it.
 */
int follow_link_number(int c,
		       int cur,
		       DocInfo *doc,
		       int *num)
{
    bstring *temp = NULL;
    char *p;
    int rel = 0;
    int new_top, new_link;
    BOOL want_go;
    int curline = *num;		/* passed in from mainloop() */
    int code;

    CTRACE((tfp, "follow_link_number(%d,%d,...)\n", c, cur));
    BStrCopy0(temp, "?");
    temp->str[0] = (char) c;
    *num = -1;
    _statusline(FOLLOW_LINK_NUMBER);

    /*
     * Get the number, possibly with a letter suffix, from the user.
     */
    if (LYgetBString(&temp, FALSE, sizeof(temp), NORECALL) < 0 ||
	isBEmpty(temp)) {
	HTInfoMsg(CANCELLED);
	return (DO_NOTHING);
    }

    p = temp->str;
    *num = atoi(p);
    while (isdigit(UCH(*p)))
	++p;
    c = *p;			/* reuse c; 0 or g or p or + or - */
    switch (c) {
    case '+':
    case '-':
	/* 123+ or 123- */
	rel = c;
	c = *++p;
	break;
    default:
	rel = *++p;
	break;
    case 0:
	break;
    }
    /* don't currently check for errors typing suffix */

    CTRACE((tfp, "  temp=%s, *num=%d, rel='%c'\n", temp->str, *num, rel));
    /*
     * Check if we had a 'p' or 'P' following the number as a flag for
     * displaying the page with that number.  - FM
     */
    if ((c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp, " curline=%d, LYlines=%d, display too small!\n",
		curline, LYlines));
	code = PRINT_ERROR;
    } else if (c == 'p' || c == 'P') {
	int nlines = HText_getNumOfLines();
	int npages = (((nlines + 1) > display_lines)
		      ? (((nlines + 1) + (display_lines - 1)) / (display_lines))
		      : 1);
	int curpage = (((curline + 1) > display_lines)
		       ? (((curline + 1) + (display_lines - 1)) / (display_lines))
		       : 1);

	CTRACE((tfp, " nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines, npages, curline, curpage));
	if (*num < 1)
	    *num = rel ? 0 : 1;
	if (rel == '+')
	    *num = curpage + *num;
	else if (rel == '-')
	    *num = curpage - *num;
	doc->line = ((npages <= 1)
		     ? 1
		     : ((*num <= npages)
			? (((*num - 1) * display_lines) + 1)
			: (((npages - 1) * display_lines) + 1)));
	code = DO_GOTOPAGE_STUFF;
    } else {

	/*
	 * Check if we want to make the link corresponding to the number the
	 * current link, rather than ACTIVATE-ing it.
	 */
	want_go = (BOOL) (c == 'g' || c == 'G');

	/* If rel, add or subtract num from current link, or
	 * nearest previous/subsequent link if current link is not on screen.
	 */
	if (rel)
	    *num = HTGetRelLinkNum(*num, rel, cur);
	/*
	 * If we have a valid number, act on it.
	 */
	if (*num > 0) {
	    int info;
	    char *text = NULL;

	    /*
	     * Get the lname, and hightext, directly from www structures and
	     * add it to the cur link so that we can pass it transparently on
	     * to getfile(), and load new_top and new_link if we instead want
	     * to make the link number current.  These things are done so that
	     * a link can be selected anywhere in the current document, whether
	     * it is displayed on the screen or not!
	     */
	    info = HTGetLinkInfo(*num,
				 want_go,
				 &new_top,
				 &new_link,
				 &text,
				 &links[cur].lname);
	    if (text != NULL)
		LYSetHilite(cur, text);

	    if (info == WWW_INTERN_LINK_TYPE) {
		links[cur].type = WWW_INTERN_LINK_TYPE;
		code = DO_LINK_STUFF;
	    } else if (info == LINK_LINE_FOUND) {
		doc->line = new_top + 1;
		doc->link = new_link;
		code = DO_GOTOLINK_STUFF;
	    } else if (info) {
		links[cur].type = WWW_LINK_TYPE;
		code = DO_LINK_STUFF;
	    } else {
		code = PRINT_ERROR;
	    }
	} else {
	    code = PRINT_ERROR;
	}
    }
    BStrFree(temp);
    return code;
}

#if defined(EXEC_LINKS) || defined(LYNXCGI_LINKS)

struct trust {
    char *src;
    char *path;
    int type;
    struct trust *next;
};

static struct trust *trusted_exec = 0;
static struct trust *always_trusted_exec;
static struct trust *trusted_cgi = 0;

static struct trust *new_trust(const char *src, const char *path, int type)
{
    struct trust *tp;

    tp = typecalloc(struct trust);

    if (tp == NULL)
	outofmem(__FILE__, "new_trust");

    assert(tp != NULL);

    tp->type = type;
    StrAllocCopy(tp->src, src);
    StrAllocCopy(tp->path, path);

    return tp;
}

static struct trust *get_trust(struct trust **table, const char *src, int type)
{
    if (*table == 0) {
	*table = new_trust(src, "", type);
    }
    return *table;
}

#ifdef LY_FIND_LEAKS
static void free_data(struct trust *cur)
{
    struct trust *next;

    cur = trusted_exec;
    while (cur) {
	FREE(cur->src);
	FREE(cur->path);
	next = cur->next;
	FREE(cur);
	cur = next;
    }
}

static void LYTrusted_free(void)
{
    free_data(trusted_exec);
    free_data(always_trusted_exec);
    free_data(trusted_cgi);

    return;
}
#endif /* LY_FIND_LEAKS */

void add_trusted(char *str,
		 int type)
{
    struct trust *tp;
    char *path;
    char *src = str;
    const char *after_tab;
    int Type = type;
    static BOOLEAN first = TRUE;

    if (!src)
	return;
    if (first) {
#ifdef LY_FIND_LEAKS
	atexit(LYTrusted_free);
#endif
	first = FALSE;
    }

    path = StrChr(src, '\t');
    if (path) {
	*path++ = '\0';
	after_tab = path;
    } else {
	after_tab = "";
    }

    tp = new_trust(src, after_tab, Type);

    if (Type == EXEC_PATH) {
	tp->next = trusted_exec;
	trusted_exec = tp;
    } else if (Type == ALWAYS_EXEC_PATH) {
	tp->next = always_trusted_exec;
	always_trusted_exec = tp;
    } else if (Type == CGI_PATH) {
	tp->next = trusted_cgi;
	trusted_cgi = tp;
    }
}

/*
 * Check to see if the supplied paths is allowed to be executed.
 */
BOOLEAN exec_ok(const char *source,
		const char *linktext,
		int type)
{
    struct trust *tp;
    const char *cp;
    const char *allowed_extra_chars;
    int Type = type;

    /*
     * Always OK if it is a jump file shortcut.
     */
    if (LYJumpFileURL)
	return TRUE;

    /*
     * Choose the trust structure based on the type.
     */
    if (Type == EXEC_PATH) {
	tp = get_trust(&trusted_exec, "file://localhost/", EXEC_PATH);
    } else if (Type == ALWAYS_EXEC_PATH) {
	tp = get_trust(&always_trusted_exec, "none", ALWAYS_EXEC_PATH);
    } else if (Type == CGI_PATH) {
	tp = get_trust(&trusted_cgi, "none", CGI_PATH);
    } else {
	HTAlert(MALFORMED_EXEC_REQUEST);
	return FALSE;
    }

#ifdef VMS
    /*
     * Security:  reject on relative path.
     */
    if ((cp = StrChr(linktext, '[')) != NULL) {
	char *cp1;

	if (((cp1 = StrChr(cp, '-')) != NULL) &&
	    StrChr(cp1, ']') != NULL) {
	    while (cp1[1] == '-')
		cp1++;
	    if (cp1[1] == ']' ||
		cp1[1] == '.') {
		HTAlert(RELPATH_IN_EXEC_LINK);
		return FALSE;
	    }
	}
    }
#else
    /*
     * Security:  reject on relative path.
     */
    if (strstr(linktext, "../") != NULL) {
	HTAlert(RELPATH_IN_EXEC_LINK);
	return FALSE;
    }

    /*
     * Security:  reject on strange character.
     */
    if (Type == CGI_PATH)
	allowed_extra_chars = " _-:./@@~$&+=\t";
    else
	allowed_extra_chars = " _-:./@@~$+=\t";
    for (cp = linktext; *cp != '\0'; cp++) {
	if (!isalnum(UCH(*cp)) && !StrChr(allowed_extra_chars, *cp)) {
	    char *buf = 0;

	    HTSprintf0(&buf,
		       BADCHAR_IN_EXEC_LINK,
		       *cp);
	    HTAlert(buf);
	    FREE(buf);
	    return FALSE;
	}
    }
#endif /* VMS */

  check_tp_for_entry:
    while (tp) {
	if (tp->type == Type) {
	    char const *command = linktext;

	    if (strstr(command, "//") == linktext) {
		command += 2;
	    }
	    CTRACE((tfp, "comparing source\n\t'%s'\n\t'%s'\n", source, tp->src));
	    CTRACE((tfp, "comparing command\n\t'%s'\n\t'%s'\n", command, tp->path));
	    if (STRNADDRCOMP(source, tp->src, strlen(tp->src)) == 0 &&
		STRNADDRCOMP(command, tp->path, strlen(tp->path)) == 0)
		return TRUE;
	}
	tp = tp->next;
    }
    if (Type == EXEC_PATH &&
	always_trusted_exec->next != 0) {
	Type = ALWAYS_EXEC_PATH;
	tp = always_trusted_exec;
	goto check_tp_for_entry;
    }
    if (!(no_exec && type == ALWAYS_EXEC_PATH))
	HTAlert(BADLOCPATH_IN_EXEC_LINK);
    return FALSE;
}
#endif /* EXEC_LINKS || LYNXCGI_LINKS */

static int fix_httplike_urls(DocInfo *doc, UrlTypes type)
{
    char *slash;

    /*
     * If there's a fragment present, our simplistic methods won't work.  - kw
     */
    if (findPoundSelector(doc->address) != NULL)
	return 0;

#ifndef DISABLE_FTP
    /*
     * If it's an ftp URL with a trailing slash, trim it off.
     */
    if (type == FTP_URL_TYPE &&
	LYIsHtmlSep(doc->address[strlen(doc->address) - 1])) {
	char *path = HTParse(doc->address, "", PARSE_PATH | PARSE_PUNCTUATION);

	/*
	 * If the path is a lone slash, we're done.  - FM
	 */
	if (path) {
	    if (LYIsHtmlSep(path[0]) && path[1] == '\0') {
		FREE(path);
		return 0;
	    }
	    FREE(path);
	}

	/*
	 * If we're proxying ftp, don't trim anything.  - KW
	 */
	if ((LYGetEnv("ftp_proxy") != NULL) &&
	    !override_proxy(doc->address))
	    return 0;

	/*
	 * If we get to here, trim the trailing slash.  - FM
	 */
	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
	LYTrimHtmlSep(doc->address);
	CTRACE((tfp, "            changed to '%s'\n", doc->address));
	CTRACE_SLEEP(MessageSecs);
    } else if (type == NCFTP_URL_TYPE) {
	char *path = NULL;
	char *first = doc->address;
	char *second = StrChr(first, ':');

	CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
	if (second == 0)
	    second = first + strlen(first);
	else
	    *second++ = '\0';
	HTSprintf0(&path, "%s//%s%s", STR_FTP_URL, first, second);
	FREE(doc->address);
	doc->address = path;

	CTRACE((tfp, "            changed to '%s'\n", doc->address));
	CTRACE_SLEEP(MessageSecs);
    }
#endif /* DISABLE_FTP */

    /*
     * If there isn't a slash besides the two at the beginning, append one.
     */
    if ((slash = strrchr(doc->address, '/')) != NULL) {
	if (!LYIsHtmlSep(*(slash - 1)) || *(slash - 2) != ':') {
	    return (0);
	}
	if (type == HTTP_URL_TYPE ||
	    type == HTTPS_URL_TYPE) {
	    if ((slash - 2) != StrChr(doc->address, ':')) {
		/*
		 * Turns out we were not looking at the right slash after all,
		 * there must have been more than one "://" which is valid at
		 * least for http URLs (later occurrences can be part of a
		 * query string, for example), so leave this alone, too.  - kw
		 */
		return (0);
	    }
	    if (StrChr(doc->address, '?')) {
		/*
		 * If there is a question mark that appears to be part of the
		 * hostname, don't append anything either.  Leave it to HTParse
		 * to interpret the question mark as ending the hostname.  - kw
		 */
		return (0);
	    }
	}
    }
    CTRACE((tfp, "fix_httplike_urls: URL '%s'\n", doc->address));
    LYAddHtmlSep(&(doc->address));
    CTRACE((tfp, "            changed to '%s'\n", doc->address));
    CTRACE_SLEEP(MessageSecs);

    return (1);
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYGetFile.c,v 1.79 2009/04/12 17:24:06 tom Exp $ */
d147 1
a147 1
	if ((cp1 = strchr(temp, '@@')) == NULL)
d192 1
d226 1
a226 1
	    if (!(0 == strncmp(startrealm, WWWDoc.address,
d229 1
d385 2
a386 2
		(cp = strchr(ref_url, '?')) != NULL &&
		strchr(cp, '=') != NULL) {
d435 1
a435 2
#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (doc->internal_link && !reloading) {
a437 2
#endif

d527 1
a527 1
	    } else {
d547 1
a547 1
		cp = strchr(doc->address, ':') + 1;
d549 3
a551 3
			      ((HTMainAnchor && !LYUserSpecifiedURL) ?
			       (char *) HTMainAnchor->address :
			       (char *) doc->address),
d553 3
a555 2
			      (HTMainAnchor && !LYUserSpecifiedURL) ?
			      HTMainAnchor->message_id : NULL);
d565 1
d575 1
a575 1
		     strncmp(doc->address, "news://", 7)) &&
d592 1
a592 1
	    } else if (no_telnet_port && strchr(doc->address + 7, ':')) {
d663 1
a663 1
		   strchr(doc->address, '?') == NULL) {
d674 1
a674 1
		if (*cp && strncmp(cp, "%09", 3)) {
d721 2
a722 2
	    if ((cp = strchr(doc->address + 9, '/')) != NULL &&
		0 == strncmp(++cp, "hGET%20/", 8)) {
d731 1
a731 1
		if (strchr(tmp + 6, ':') == NULL) {
d1127 2
a1128 2
    char temp[120];
    char *p = temp;
d1133 1
d1136 2
a1137 2
    temp[0] = (char) c;
    temp[1] = '\0';
d1140 1
d1144 2
a1145 1
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
d1149 2
d1170 1
a1170 1
    CTRACE((tfp, "  temp=%s, *num=%d, rel='%c'\n", temp, *num, rel));
d1178 1
a1178 1
	return (PRINT_ERROR);
d1181 6
a1186 6
	int npages = ((nlines + 1) > display_lines) ?
	(((nlines + 1) + (display_lines - 1)) / (display_lines))
	: 1;
	int curpage = ((curline + 1) > display_lines) ?
	(((curline + 1) + (display_lines - 1)) / (display_lines))
	: 1;
d1196 7
a1202 6
	doc->line = (npages <= 1) ?
	    1 :
	    ((*num <= npages) ? (((*num - 1) * display_lines) + 1)
	     : (((npages - 1) * display_lines) + 1));
	return (DO_GOTOPAGE_STUFF);
    }
d1204 5
a1208 17
    /*
     * Check if we want to make the link corresponding to the number the
     * current link, rather than ACTIVATE-ing it.
     */
    want_go = (BOOL) (c == 'g' || c == 'G');

    /* If rel, add or subtract num from current link, or
     * nearest previous/subsequent link if current link is not on screen.
     */
    if (rel)
	*num = HTGetRelLinkNum(*num, rel, cur);
    /*
     * If we have a valid number, act on it.
     */
    if (*num > 0) {
	int info;
	char *text = NULL;
d1210 5
d1216 1
a1216 6
	 * Get the lname, and hightext, directly from www structures and add it
	 * to the cur link so that we can pass it transparently on to
	 * getfile(), and load new_top and new_link if we instead want to make
	 * the link number current.  These things are done so that a link can
	 * be selected anywhere in the current document, whether it is
	 * displayed on the screen or not!
d1218 34
a1251 18
	info = HTGetLinkInfo(*num,
			     want_go,
			     &new_top,
			     &new_link,
			     &text,
			     &links[cur].lname);
	if (text != NULL)
	    LYSetHilite(cur, text);
	if (info == WWW_INTERN_LINK_TYPE) {
	    links[cur].type = WWW_INTERN_LINK_TYPE;
	    return (DO_LINK_STUFF);
	} else if (info == LINK_LINE_FOUND) {
	    doc->line = new_top + 1;
	    doc->link = new_link;
	    return (DO_GOTOLINK_STUFF);
	} else if (info) {
	    links[cur].type = WWW_LINK_TYPE;
	    return (DO_LINK_STUFF);
d1253 1
a1253 1
	    return (PRINT_ERROR);
a1254 2
    } else {
	return (PRINT_ERROR);
d1256 2
d1269 5
a1273 1
static struct trust trusted_exec_default =
d1275 17
a1291 3
    "file://localhost/", "", EXEC_PATH, NULL
};
static struct trust always_trusted_exec_default =
d1293 5
a1297 10
    "none", "", ALWAYS_EXEC_PATH, NULL
};
static struct trust trusted_cgi_default =
{
    "none", "", CGI_PATH, NULL
};

static struct trust *trusted_exec = &trusted_exec_default;
static struct trust *always_trusted_exec = &always_trusted_exec_default;
static struct trust *trusted_cgi = &trusted_cgi_default;
d1300 1
a1300 1
static void LYTrusted_free(void)
a1301 1
    struct trust *cur;
d1304 7
a1310 9
    if (trusted_exec != &trusted_exec_default) {
	cur = trusted_exec;
	while (cur) {
	    FREE(cur->src);
	    FREE(cur->path);
	    next = cur->next;
	    FREE(cur);
	    cur = next;
	}
d1312 1
d1314 5
a1318 21
    if (always_trusted_exec != &always_trusted_exec_default) {
	cur = always_trusted_exec;
	while (cur) {
	    FREE(cur->src);
	    FREE(cur->path);
	    next = cur->next;
	    FREE(cur);
	    cur = next;
	}
    }

    if (trusted_cgi != &trusted_cgi_default) {
	cur = trusted_cgi;
	while (cur) {
	    FREE(cur->src);
	    FREE(cur->path);
	    next = cur->next;
	    FREE(cur);
	    cur = next;
	}
    }
d1330 1
d1343 2
a1344 2
    path = strchr(src, '\t');
    if (path)
d1346 6
a1351 2
    else
	path = "";
a1352 8
    tp = (struct trust *) malloc(sizeof(*tp));
    if (tp == NULL)
	outofmem(__FILE__, "add_trusted");
    tp->src = NULL;
    tp->path = NULL;
    tp->type = Type;
    StrAllocCopy(tp->src, src);
    StrAllocCopy(tp->path, path);
d1354 1
a1354 4
	if (trusted_exec == &trusted_exec_default)
	    tp->next = NULL;
	else
	    tp->next = trusted_exec;
d1357 1
a1357 4
	if (always_trusted_exec == &always_trusted_exec_default)
	    tp->next = NULL;
	else
	    tp->next = always_trusted_exec;
d1360 1
a1360 4
	if (trusted_cgi == &trusted_cgi_default)
	    tp->next = NULL;
	else
	    tp->next = trusted_cgi;
d1387 1
a1387 1
	tp = trusted_exec;
d1389 1
a1389 1
	tp = always_trusted_exec;
d1391 1
a1391 1
	tp = trusted_cgi;
d1401 1
a1401 1
    if ((cp = strchr(linktext, '[')) != NULL) {
d1404 2
a1405 2
	if (((cp1 = strchr(cp, '-')) != NULL) &&
	    strchr(cp1, ']') != NULL) {
d1432 1
a1432 1
	if (!isalnum(UCH(*cp)) && !strchr(allowed_extra_chars, *cp)) {
d1462 1
a1462 1
	always_trusted_exec != &always_trusted_exec_default) {
a1488 1
	char *proxy;
d1505 1
a1505 1
	if (((proxy = LYGetEnv("ftp_proxy")) != NULL) &&
d1519 1
a1519 1
	char *second = strchr(first, ':');
d1522 4
a1525 2

	*second++ = '\0';
d1544 1
a1544 1
	    if ((slash - 2) != strchr(doc->address, ':')) {
d1553 1
a1553 1
	    if (strchr(doc->address, '?')) {
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d195 3
d231 3
d475 3
a477 9
		if ((cp = strchr(doc->address, '~'))) {
		    HTSprintf0(&p, "%.*s%s%s",
			       cp - doc->address,
			       doc->address,
			       wwwName(Home_Dir()),
			       cp + 1);
		} else {
		    StrAllocCopy(p, doc->address);
		}
d569 3
d792 2
a793 27
	    if (((cp = HTParse(doc->address, "",
			       PARSE_PATH + PARSE_ANCHOR + PARSE_PUNCTUATION))
		 != NULL) &&
		!strncmp(cp, "/~", 2)) {
		char *cp1 = strstr(doc->address, "/~");
		char *cp2;

		CTRACE((tfp, "getfile: URL '%s'\n",
			doc->address));
		*cp1 = '\0';
		cp1 += 2;
		StrAllocCopy(temp, doc->address);
		StrAllocCopy(cp, wwwName(Home_Dir()));
		if (!LYIsHtmlSep(*cp))
		    LYAddHtmlSep(&temp);
		StrAllocCat(temp, cp);
		if ((cp2 = strchr(cp1, '/')) != NULL) {
		    LYTrimRelFromAbsPath(cp2);
		    StrAllocCat(temp, cp2);
		}
		StrAllocCopy(doc->address, temp);
		FREE(temp);
		CTRACE((tfp, "  changed to '%s'\n",
			doc->address));
		WWWDoc.address = doc->address;
	    }
	    FREE(cp);
d852 3
d1268 1
a1268 1
    "", "", CGI_PATH, NULL
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d3 1
a3 1
#include <HTAnchor.h>	    /* Anchor class */
d36 1
a36 1
PRIVATE int fix_httplike_urls PARAMS((DocInfo *doc, UrlTypes type));
d44 1
a44 1
PUBLIC int HTNoDataOK = 0;
d47 4
a50 4
 *  getfile is the main mechanism to load a new document (or a previously
 *  loaded one whose rendering is cached in a HText structure) from
 *  mainloop, nearly everything goes through it.
 *  It should return one of the values
d63 5
a67 5
 *  The distinction between NOT_FOUND and NULLFILE is not very crucial,
 *  but getting it right prevents mainloop from exiting with the wrong
 *  message if it happens for the first file, and from logging (or not
 *  logging) errors inappropriately with -traversal, and from sending
 *  bogus error mail with MAIL_SYSTEM_ERROR_LOGGING:TRUE. - kw
d69 1
a69 2
PUBLIC int getfile ARGS1(
	DocInfo *,	doc)
d71 2
a72 1
    int url_type = 0;
d75 1
a75 1
    DocAddress WWWDoc;  /* a WWW absolute doc address struct */
d78 1
a78 1
     *  Reset LYCancelDownload to prevent unwanted delayed effect. - KW
d86 1
a86 1
     *  Reset fake 'Z' to prevent unwanted delayed effect. - kw
d91 4
a94 4
     *  Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS
     *  in rare situations if the previous cycle got to the limit, but
     *  did not fail for that reason because the URL of the final location
     *  was handled specially, not via HTLoadAbsolute. - kw
d98 1
a98 1
Try_Redirected_URL:
d100 1
a100 1
     *  Load the WWWDoc struct in case we need to use it.
d110 1
a110 1
     *  Reset HTPermitRedir, it has done its job if it was set. - kw
d115 1
a115 1
     *  Reset WWW_Download_File just in case.
d120 1
a120 1
     *  Reset redirect_post_content just in case.
d125 7
a131 9
     *  This flag is a hack to allow us to pass on the fact
     *  that 'no data' may not really be an error although
     *  HTLoadAbsolute returned NO.  There should be a better
     *  way...  HT_NO_DATA should always mean 'not data but
     *  not an error', and be passed on to us as that, but
     *  current usage if HT_NO_DATA vs HT_NOT_LOADED has
     *  to be reviewed everywhere.
     *  Anyway, some protocol module can set it to say
     *  'I really mean it', we have to reset it here. - kw
d135 1
a135 1
    CTRACE((tfp,"getfile: getting %s\n\n",doc->address));
d138 3
a140 5
     *  Protect against denial of service attacks
     *  via the port 19 CHARGEN service, and block
     *  connections to the port 25 ESMTP service.
     *  Also reject any likely spoof attempts via
     *  wrap arounds at 65536. - FM
d156 2
a157 3
		    return(NULLFILE);
		}
		if (value == 25 || value == 65561) {
d160 2
a161 3
		    return(NULLFILE);
		}
		if (value > 65535 || value < 0) {
d163 2
a164 1
		    HTSprintf0(&msg, PORT_INVALID, (unsigned long)value);
d168 1
a168 1
		    return(NULLFILE);
d173 1
a173 1
		return(NULLFILE);
d181 2
a182 2
     *  Check to see if this is a universal document ID
     *  that lib WWW wants to handle.
d184 1
a184 1
     *  Some special URL's we handle ourselves. :)
d197 2
a198 2
		  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
				  strlen(helpfilepath)) ||
d200 2
a201 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				  strlen(lynxlistfile))) ||
d203 2
a204 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
				  strlen(lynxlinksfile))) ||
d206 2
a207 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				  strlen(lynxjumpfile))))) {
d209 1
a209 1
		return(NULLFILE);
d214 1
a214 1
	     *	Only traverse http URLs.
d218 1
a218 1
		return(NULLFILE);
d221 2
a222 2
	    if (!(0==strncmp(startrealm, WWWDoc.address,
			     strlen(startrealm)) ||
d244 2
a245 2
		  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
				  strlen(helpfilepath)) ||
d247 2
a248 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
				  strlen(lynxlistfile))) ||
d250 2
a251 2
		   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
				  strlen(lynxjumpfile))))) {
d253 1
a253 1
		return(NULLFILE);
d274 2
a275 2
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
	LYSyslog (doc->address);
d281 1
a281 1
	    return(NULLFILE);
d285 1
a285 1
	    return(NULLFILE);
d288 1
a288 1
	    return(printfile(doc));
d293 1
a293 1
	    return(postoptions(doc));
d297 1
a297 1
	    !no_lynxcfg_info) {
d301 1
a301 1
	    return(lynx_cfg_infopage(doc));
d305 1
a305 1
	    !no_compileopts_info) {
d309 1
a309 1
	    return(lynx_compile_opts(doc));
d320 3
a322 4
		return(NULLFILE);
	    } else if (!news_ok && (
		url_type == NEWSPOST_URL_TYPE ||
		url_type == NEWSREPLY_URL_TYPE)) {
d324 1
a324 1
		return(NULLFILE);
d327 1
a327 1
		return(NULLFILE);
d336 3
a338 4
		 *  The temporary file was saved to disk via a
		 *  rename(), so we can't access the temporary
		 *  file again via the download menu.  Clear the
		 *  flag, and return NULLFILE to pop. - FM
d341 1
a341 1
		return(NULLFILE);
d344 1
a344 1
	    return(NORMAL);
d348 12
a359 12
	       local_dired(doc);
	       WWWDoc.address = doc->address;
	       WWWDoc.post_data = doc->post_data;
	       WWWDoc.post_content_type = doc->post_content_type;
	       WWWDoc.bookmark = doc->bookmark;
	       WWWDoc.isHEAD = doc->isHEAD;
	       WWWDoc.safe = doc->safe;

	       if (!HTLoadAbsolute(&WWWDoc)) {
		   return(NOT_FOUND);
	       }
	       return(NORMAL);
d363 1
a363 1
	    return(NULLFILE);
d368 2
a369 1
	    char *ref_url = HTLoadedDocumentURL();
d379 4
a382 5
		 *  Don't send a Referer header if the URL is
		 *  the reply from a form with method GET, in
		 *  case the content has personal data (e.g.,
		 *  a password or credit card number) which
		 *  would become visible in logs. - FM
d384 2
a385 2
		 *  Changed 1999-11-01 to be controlled by
		 *  REFERER_WITH_QUERY option. - kw
d387 1
a387 1
		if (LYRefererWithQuery == 'S') { /* SEND */
d389 2
a390 2
		} else if (LYRefererWithQuery == 'P') { /* PARTIAL */
		    FREE(LYRequestReferer); /* just to be sure */
d392 5
a396 2
					       PARSE_ACCESS|PARSE_HOST|PARSE_STRICTPATH|PARSE_PUNCTUATION);
		} else { /* Everything else - don't send Referer */
d408 3
a410 4
	     *	'doc' will change to the new file
	     *	if we had a successful LYpop_num(),
	     *	and the return value will be FALSE
	     *	if we had a cancel. - FM
d414 1
a414 1
		return(NOT_FOUND);
d418 1
a418 1
	     *	We changed it so reload.
d436 1
a436 1
		return(NOT_FOUND);
d438 1
a438 1
	    return(NORMAL);
d445 1
a445 1
			 doc->address+9, ALWAYS_EXEC_PATH)) {
d451 2
a452 2
		       exec_ok(HTLoadedDocumentURL(),
			       doc->address+9, EXEC_PATH))) {
d457 1
a457 1
		 *  Bug puts slash on end if none is in the string.
d459 2
a460 1
		char *last_slash = strrchr(doc->address,'/');
d462 2
a463 2
		 == (int)strlen(doc->address) - 1)
		    doc->address[strlen(doc->address)-1] = '\0';
d466 1
a466 1
		 *  Convert '~' to $HOME.
d470 4
a473 4
				   cp - doc->address,
				   doc->address,
				   wwwName(Home_Dir()),
				   cp + 1);
d478 1
a478 1
		 *  Show URL before executing it.
d483 1
a483 1
		 *  Run the command.
d485 2
a486 2
		if (strstr(p,"//") == p+9)
		    LYSystem(p+11);
d488 1
a488 1
		    LYSystem(p+9);
d493 1
a493 1
		     *	Make sure user gets to see screen output.
d510 1
a510 1
	     } else {
d514 2
a515 2
			EXECUTION_DISABLED_FOR_FILE,
			key_for_func(LYK_OPTIONS));
d518 1
a518 1
	     }
d520 1
a520 1
	     HTUserMsg(EXECUTION_NOT_COMPILED);
d522 1
a522 1
	     return(NULLFILE);
d529 1
a529 1
		CONST char *title;
d534 1
a534 1
			title = HTAnchor_title(tmpanchor);
d537 1
a537 1
		    if (title && *title) {
d547 1
a547 1
		cp = strchr(doc->address,':')+1;
d550 2
a551 2
			       (char *)HTMainAnchor->address :
			       (char *)doc->address),
d554 1
a554 1
			       HTMainAnchor->message_id : NULL);
d557 1
a557 1
	    return(NULLFILE);
d559 4
a562 4
	/*
	 *  From here on we could have a remote host,
	 *  so check if that's allowed.
	 */
d574 1
a574 1
	    return(NULLFILE);
d576 3
a578 3
	/*
	 *  Disable www telnet access if not telnet_ok.
	 */
d582 2
a583 1
	    char * proxy;
d586 2
a587 2
		return(NULLFILE);
	    } else if (no_telnet_port && strchr(doc->address+7, ':')) {
d589 11
a599 9
		return(NULLFILE);
	    /*
	     *  Detect weird case where interactive protocol would
	     *  be proxied, and to a non-interactive protocol at that.
	     */
	    } else if ((proxy = LYGetEnv(
		(url_type==TN3270_URL_TYPE) ? "tn3270_proxy" :
		(url_type==TELNET_GOPHER_URL_TYPE) ? "gopher_proxy" :
		"telnet_proxy")) != NULL &&
d613 1
a613 1
		return(NULLFILE);
d616 3
a618 3
	/*
	 *  Disable www news access if not news_ok.
	 */
d620 2
a621 3
	} else if (!news_ok && (
	    url_type == NEWS_URL_TYPE ||
	    url_type == NNTP_URL_TYPE)) {
d623 1
a623 1
	    return(NULLFILE);
d627 2
a628 1
	    char * proxy;
d631 6
a636 7
		return(NULLFILE);
	    /*
	     *  Detect weird case where interactive protocol would
	     *  be proxied, and to a non-interactive protocol at that.
	     */
	    } else if ((proxy = LYGetEnv(
		"rlogin_proxy")) != NULL &&
d650 1
a650 1
		return(NULLFILE);
d653 4
a656 5
	/*
	 *  If it's a gopher index type and there isn't a search
	 *  term already attached then do this.  Otherwise
	 *  just load it!
	 */
d658 1
a658 1
		   strchr(doc->address,'?') == NULL) {
d660 1
d662 2
a663 3
	     *	Make sure we don't have a gopher+ escaped tab
	     *	instead of a gopher0 question mark delimiting
	     *	the search term. - FM
d681 2
a682 3
	     *	Load it because the do_www_search routine
	     *	uses the base url of the currently loaded
	     *	document :(
d685 1
a685 1
		return(NOT_FOUND);
d702 10
a711 1
	    return(status);
d713 16
a728 35
	}
	{
	    if (!ftp_ok
	     && (url_type == FTP_URL_TYPE
	      || url_type == NCFTP_URL_TYPE)) {
		HTUserMsg(FTP_DISABLED);
		return(NULLFILE);
	    }

	    if (url_type == HTML_GOPHER_URL_TYPE) {
		char *tmp=NULL;
	       /*
		*  If tuple's Path=GET%20/... convert to an http URL.
		*/
		if ((cp=strchr(doc->address+9, '/')) != NULL &&
		   0==strncmp(++cp, "hGET%20/", 8)) {
		    StrAllocCopy(tmp, "http://");
		    CTRACE((tfp, "getfile: URL '%s'\n",
				doc->address));
		    *cp = '\0';
		    StrAllocCat(tmp, doc->address+9);
		   /*
		    *  If the port is defaulted, it should stay 70.
		    */
		    if (strchr(tmp+6, ':') == NULL) {
			StrAllocCat(tmp, "70/");
			tmp[strlen(tmp)-4] = ':';
		    }
		    if (strlen(cp+7) > 1)
			StrAllocCat(tmp, cp+8);
		    StrAllocCopy(doc->address, tmp);
		    CTRACE((tfp, "  changed to '%s'\n",
				doc->address));
		    FREE(tmp);
		    url_type = HTTP_URL_TYPE;
d730 7
d738 11
a748 7
	    if (url_type == HTTP_URL_TYPE ||
		url_type == HTTPS_URL_TYPE ||
		url_type == FTP_URL_TYPE ||
		url_type == NCFTP_URL_TYPE ||
		url_type == CSO_URL_TYPE)
		fix_httplike_urls(doc, url_type);
	    WWWDoc.address = doc->address;  /* possible reload */
d750 1
a750 1
	    lynx_edit_mode = FALSE;
d752 1
d754 18
a771 22
	    if (url_type == BIBP_URL_TYPE) {
		char *bibpTmp = NULL;
		if (!BibP_bibhost_checked)
		    LYCheckBibHost();
		if (BibP_bibhost_available) {
		    StrAllocCopy(bibpTmp, BibP_bibhost);
		} else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		    StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		} else {
		    StrAllocCopy(bibpTmp, BibP_globalserver);
		}
		if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
		    StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
		    StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
		    StrAllocCat(bibpTmp, "&usin=");
		} else {
		    StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
		}
		StrAllocCat(bibpTmp, doc->address+5); /* USIN after bibp: */
		StrAllocCopy(doc->address, bibpTmp);
		WWWDoc.address = doc->address;
		FREE(bibpTmp);
d773 5
d780 27
a806 34
	    if (url_type == FILE_URL_TYPE) {
		/*
		 *  If a file URL has a '~' as the lead character
		 *  of its first symbolic element, convert the '~'
		 *  to Home_Dir(), then append the rest of of path,
		 *  if present, skipping "user" if "~user" was
		 *  entered, simplifying, and eliminating any
		 *  residual relative elements. - FM
		 */
		if (((cp = HTParse(doc->address, "",
			   PARSE_PATH+PARSE_ANCHOR+PARSE_PUNCTUATION))
		      != NULL) &&
		    !strncmp(cp, "/~", 2)) {
		    char *cp1 = strstr(doc->address, "/~");
		    char *cp2;

		    CTRACE((tfp, "getfile: URL '%s'\n",
				doc->address));
		    *cp1 = '\0';
		    cp1 += 2;
		    StrAllocCopy(temp, doc->address);
		    StrAllocCopy(cp, wwwName(Home_Dir()));
		    if (!LYIsHtmlSep(*cp))
			LYAddHtmlSep(&temp);
		    StrAllocCat(temp, cp);
		    if ((cp2 = strchr(cp1, '/')) != NULL) {
			LYTrimRelFromAbsPath(cp2);
			StrAllocCat(temp, cp2);
		    }
		    StrAllocCopy(doc->address, temp);
		    FREE(temp);
		    CTRACE((tfp, "  changed to '%s'\n",
				doc->address));
		    WWWDoc.address = doc->address;
d808 5
a812 1
		FREE(cp);
d814 4
a817 2
	    CTRACE_SLEEP(MessageSecs);
	    user_message(WWW_WAIT_MESSAGE, doc->address);
d819 1
a819 1
	    if (TRACE) {
d821 4
a824 4
		if (LYCursesON) {
		    LYaddstr("*\n");
		    LYrefresh();
		}
d826 2
a827 8
		CTRACE((tfp, "\n"));
	    }
	    if (!HTLoadAbsolute(&WWWDoc)) {
		/*
		 *  Check for redirection.
		 */
		if (use_this_url_instead != NULL) {
		    char *pound;
d829 27
a855 27
		    if (!is_url(use_this_url_instead)) {
			/*
			 *  The server did not return a complete
			 *  URL in its Location: header, probably
			 *  due to a FORM or other CGI script written
			 *  by someone who doesn't know that the http
			 *  protocol requires that it be a complete
			 *  URL, or using a server which does not treat
			 *  such a redirect string from the script as
			 *  an instruction to resolve it versus the
			 *  initial request, check authentication with
			 *  that URL, and then act on it without
			 *  returning redirection to us.  We'll
			 *  violate the http protocol and resolve it
			 *  ourselves using the URL of the original
			 *  request as the BASE, rather than doing
			 *  the RIGHT thing and returning an invalid
			 *  address message. - FM
			 */
			HTUserMsg(LOCATION_NOT_ABSOLUTE);
			temp = HTParse(use_this_url_instead,
				       WWWDoc.address,
				       PARSE_ALL);
			if (temp && *temp) {
			    StrAllocCopy(use_this_url_instead, temp);
			}
			FREE(temp);
d857 7
a863 5
		    url_type = is_url(use_this_url_instead);
		    if (!HTPermitRedir &&
		       (url_type == LYNXDOWNLOAD_URL_TYPE ||
			url_type == LYNXEXEC_URL_TYPE ||
			url_type == LYNXPROG_URL_TYPE ||
d865 1
a865 1
			url_type == LYNXDIRED_URL_TYPE ||
d867 14
a880 14
			url_type == LYNXPRINT_URL_TYPE ||
			url_type == LYNXOPTIONS_URL_TYPE ||
			url_type == LYNXCFG_URL_TYPE ||
			url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			url_type == LYNXHIST_URL_TYPE ||
			url_type == LYNXCOOKIE_URL_TYPE ||
			url_type == LYNXMESSAGES_URL_TYPE ||
			(LYValidate &&
			 url_type != HTTP_URL_TYPE &&
			 url_type != HTTPS_URL_TYPE) ||
			((no_file_url || no_goto_file) &&
			 url_type == FILE_URL_TYPE) ||
			(no_goto_lynxcgi &&
			 url_type == LYNXCGI_URL_TYPE) ||
d882 2
a883 2
			(no_goto_bibp &&
			 url_type == BIBP_URL_TYPE) ||
d885 15
a899 15
			(no_goto_cso &&
			 url_type == CSO_URL_TYPE) ||
			(no_goto_finger &&
			 url_type == FINGER_URL_TYPE) ||
			(no_goto_ftp &&
			 (url_type == FTP_URL_TYPE ||
			  url_type == NCFTP_URL_TYPE)) ||
			(no_goto_gopher &&
			 url_type == GOPHER_URL_TYPE) ||
			(no_goto_http &&
			 url_type == HTTP_URL_TYPE) ||
			(no_goto_https &&
			 url_type == HTTPS_URL_TYPE) ||
			(no_goto_mailto &&
			 url_type == MAILTO_URL_TYPE) ||
d901 4
a904 4
			(no_goto_news &&
			 url_type == NEWS_URL_TYPE) ||
			(no_goto_nntp &&
			 url_type == NNTP_URL_TYPE) ||
d906 2
a907 2
			(no_goto_rlogin &&
			 url_type == RLOGIN_URL_TYPE) ||
d909 2
a910 2
			(no_goto_snews &&
			 url_type == SNEWS_URL_TYPE) ||
d912 18
a929 37
			(no_goto_telnet &&
			 url_type == TELNET_URL_TYPE) ||
			(no_goto_tn3270 &&
			 url_type == TN3270_URL_TYPE) ||
			(no_goto_wais &&
			 url_type == WAIS_URL_TYPE))) {
			/*
			 *  Some schemes are not acceptable from
			 *  server redirections. - KW & FM
			 */
			HTAlert(ILLEGAL_REDIRECTION_URL);
			if (LYCursesON) {
			    HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE,
				       use_this_url_instead);
			} else {
			    fprintf(stderr,
				    WWW_ILLEGAL_URL_MESSAGE,
				    use_this_url_instead);
			}
			FREE(use_this_url_instead);
			return(NULLFILE);
		    }
		    if ((pound = findPoundSelector(doc->address)) != NULL
		     && findPoundSelector(use_this_url_instead) == NULL) {
			/*
			 *  Our requested URL had a fragment
			 *  associated with it, and the redirection
			 *  URL doesn't, so we'll append the fragment
			 *  associated with the original request.  If
			 *  it's bogus for the redirection URL, we'll
			 *  be positioned at the top of that document,
			 *  so there's no harm done. - FM
			 */
			CTRACE((tfp,
		"getfile: Adding fragment '%s' to redirection URL.\n",
			    pound));
			StrAllocCat(use_this_url_instead, pound);
a930 5
		    CTRACE_SLEEP(MessageSecs);
		    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);
		    CTRACE((tfp, "\n"));
		    StrAllocCopy(doc->address,
				use_this_url_instead);
d932 4
a935 7
		    if (redirect_post_content == FALSE) {
			/*
			 *  Freeing the content also yields
			 *  a GET request. - FM
			 */
			LYFreePostData(doc);
		    }
d937 6
a942 3
		     *	Go to top to check for URL's which get
		     *	special handling and/or security checks
		     *	in Lynx. - FM
d944 5
a948 1
		    goto Try_Redirected_URL;
d950 11
a960 2
		if (HTNoDataOK) {
		    return(NULLFILE);
d962 10
a971 1
		return(NOT_FOUND);
d973 1
d978 15
a992 7
	     *	Some URL's don't actually return a document;
	     *	compare doc->address with the document that is
	     *	actually loaded and return NULLFILE if not
	     *	loaded.  If www_search_result is not -1
	     *	then this is a reference to a named anchor
	     *	within the same document; do NOT return
	     *	NULLFILE in that case.
d994 13
a1006 2
	    {
		char *pound;
d1008 3
a1010 1
		 *  Check for a #fragment selector.
d1012 1
a1012 1
		pound = findPoundSelector(doc->address);
d1014 31
d1046 1
a1046 2
		 *  Check to see if there is a temp
		 *  file waiting for us to download.
d1048 11
a1058 3
		if (WWW_Download_File) {
		    HTParentAnchor *tmpanchor = HTAnchor_findAddress(&WWWDoc);
		    char *fname = NULL;
d1060 4
a1063 20
		    /*
		     *	Check for a suggested filename from
		     *	the Content-Disposition header. - FM
		     */
		    if (HTAnchor_SugFname(tmpanchor) != NULL) {
			StrAllocCopy(fname, HTAnchor_SugFname(tmpanchor));
		    } else {
			StrAllocCopy(fname, doc->address);
		    }
		    /*
		     *	Check whether this is a compressed file,
		     *	which we don't uncompress for downloads,
		     *	and adjust any suffix appropriately. - FM
		     */
		    HTCheckFnameForCompression(&fname, tmpanchor, FALSE);

		    if (LYdownload_options(&fname,
					   WWW_Download_File) < 0) {
			FREE(fname);
			return(NOT_FOUND);
a1064 36
		    LYAddVisitedLink(doc);
		    StrAllocCopy(doc->address, fname);
		    FREE(fname);
		    doc->internal_link = FALSE;
		    WWWDoc.address = doc->address;
		    LYFreePostData(doc);
		    WWWDoc.post_data = NULL;
		    WWWDoc.post_content_type = NULL;
		    WWWDoc.bookmark = doc->bookmark = FALSE;
		    WWWDoc.isHEAD = doc->isHEAD = FALSE;
		    WWWDoc.safe = doc->safe = FALSE;
		    HTOutputFormat = WWW_PRESENT;
		    if (!HTLoadAbsolute(&WWWDoc)) {
			return(NOT_FOUND);
		    } else {
			return(NORMAL);
		    }

		} else if (pound == NULL &&
			   /*
			    *  HTAnchor hash-table searches are now
			    *  case-sensitive (hopefully, without
			    *  anchor deletion problems), so this
			    *  is too. - FM
			    */
			   (strcmp(doc->address,
				   HTLoadedDocumentURL()) ||
			   /*
			    *  Also check the post_data elements. - FM
			    */
			   !BINEQ(doc->post_data,
				  HTLoadedDocumentPost_data()) ||
			   /*
			    *  Also check the isHEAD element. - FM
			    */
			   doc->isHEAD != HTLoadedDocumentIsHEAD())) {
d1066 1
a1066 1
		     *	Nothing needed to be shown.
d1068 3
a1070 12
		    LYAddVisitedLink(doc);
		    return(NULLFILE);

		} else {
		    if (pound != NULL) {
			if (!HTMainText) { /* this should not happen... */
			    return(NULLFILE); /* but it can. - kw */
			}
			/*
			 *  May set www_search_result.
			 */
			HTFindPoundSelector(pound+1);
a1071 1
		    return(NORMAL);
d1073 1
d1079 2
a1080 2
	CTRACE((tfp,"\n"));
	return(NULLFILE);
d1085 5
a1089 5
 *  Set source mode for the next retrieval via getfile or HTreparse_document.
 *  mode == -1: force normal presentation
 *  mode ==  1: force source presentation
 *  mode ==  0: reset to normal if it was set to source
 *  - kw
d1091 1
a1091 2
PUBLIC void srcmode_for_next_retrieval ARGS1(
    int,	mode)
d1120 18
a1137 14
 *  The user wants to select a link or page by number.
 *  If follow_link_number returns DO_LINK_STUFF do_link
 *   will be run immediately following its execution.
 *  If follow_link_number returns DO_GOTOLINK_STUFF
 *   it has updated the passed in doc for positioning on a link.
 *  If follow_link_number returns DO_GOTOPAGE_STUFF
 *   it has set doc->line to the top line of the desired page
 *   for displaying that page.
 *  If follow_link_number returns PRINT_ERROR an error message
 *   will be given to the user.
 *  If follow_link_number returns DO_FORMS_STUFF some forms stuff
 *   will be done. (Not yet implemented.)
 *  If follow_link_number returns DO_NOTHING nothing special
 *   will run after it.
d1139 4
a1142 5
PUBLIC int follow_link_number ARGS4(
	int,		c,
	int,		cur,
	DocInfo *,	doc,
	int *,		num)
d1149 1
a1149 1
    int curline = *num; /* passed in from mainloop() */
d1151 1
a1151 1
    CTRACE((tfp,"follow_link_number(%d,%d,...)\n",c,cur));
d1157 1
a1157 1
     *	Get the number, possibly with a letter suffix, from the user.
d1161 1
a1161 1
	return(DO_NOTHING);
d1164 1
a1164 1
    while ( isdigit(UCH(*p)) )
d1166 4
a1169 3
    c = *p; /* reuse c; 0 or g or p or + or - */
    switch ( c ) {
    case '+': case '-':
d1171 2
a1172 1
	rel = c; c = *++p;
d1182 1
a1182 1
    CTRACE((tfp,"  temp=%s, *num=%d, rel='%c'\n",temp,*num,rel));
d1184 2
a1185 2
     *	Check if we had a 'p' or 'P' following the number as
     *	a flag for displaying the page with that number. - FM
d1187 5
a1191 5
    if (( c == 'p' || c == 'P') && display_lines == 0) {
	CTRACE((tfp," curline=%d, LYlines=%d, display too small!\n",
	       curline,LYlines));
	return(PRINT_ERROR);
    } else if ( c == 'p' || c == 'P' ) {
d1194 2
a1195 2
		(((nlines + 1) + (display_lines - 1))/(display_lines))
						    : 1;
d1197 5
a1201 4
		     (((curline + 1) + (display_lines - 1))/(display_lines))
						      : 1;
	CTRACE((tfp," nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines,npages,curline,curpage));
d1204 1
a1204 1
	if ( rel == '+' )
d1206 1
a1206 1
	else if ( rel == '-' )
d1209 4
a1212 4
				1 :
		((*num <= npages) ? (((*num - 1) * display_lines) + 1)
				  : (((npages - 1) * display_lines) + 1));
	return(DO_GOTOPAGE_STUFF);
d1216 2
a1217 2
     *	Check if we want to make the link corresponding to the
     *	number the current link, rather than ACTIVATE-ing it.
d1219 1
a1219 1
    want_go = (BOOL) ( c == 'g' || c == 'G' );
d1224 6
a1229 6
    if ( rel )
	*num = HTGetRelLinkNum( *num, rel, cur );
   /*
    *  If we have a valid number, act on it.
    */
   if (*num > 0) {
d1234 6
a1239 8
	 *  Get the lname, and hightext, directly from www
	 *  structures and add it to the cur link so that
	 *  we can pass it transparently on to getfile(),
	 *  and load new_top and new_link if we instead want
	 *  to make the link number current.  These things
	 *  are done so that a link can be selected anywhere
	 *  in the current document, whether it is displayed
	 *  on the screen or not!
d1251 1
a1251 1
	    return(DO_LINK_STUFF);
d1255 1
a1255 1
	    return(DO_GOTOLINK_STUFF);
d1258 1
a1258 1
	    return(DO_LINK_STUFF);
d1260 1
a1260 1
	    return(PRINT_ERROR);
d1263 1
a1263 1
	return(PRINT_ERROR);
d1270 4
a1273 4
	char *src;
	char *path;
	int type;
	struct trust *next;
d1276 3
a1278 2
static struct trust trusted_exec_default = {
  "file://localhost/",	"",	EXEC_PATH,		NULL
d1280 3
a1282 2
static struct trust always_trusted_exec_default = {
  "none",		"",	ALWAYS_EXEC_PATH,	NULL
d1284 3
a1286 2
static struct trust trusted_cgi_default = {
  "",			"",	CGI_PATH,		NULL
d1294 1
a1294 1
PRIVATE void LYTrusted_free NOARGS
d1336 2
a1337 3
PUBLIC void add_trusted ARGS2(
	char *,		str,
	int,		type)
d1360 1
a1360 1
    tp = (struct trust *)malloc(sizeof(*tp));
d1390 1
a1390 1
 *  Check to see if the supplied paths is allowed to be executed.
d1392 3
a1394 4
PUBLIC BOOLEAN exec_ok ARGS3(
	CONST char *,	source,
	CONST char *,	linktext,
	int,		type)
d1397 2
a1398 2
    CONST char *cp;
    CONST char *allowed_extra_chars;
d1402 1
a1402 1
     *	Always OK if it is a jump file shortcut.
d1408 1
a1408 1
     *	Choose the trust structure based on the type.
d1423 1
a1423 1
     *	Security: reject on relative path.
d1427 1
d1441 1
a1441 1
     *	Security: reject on relative path.
d1449 1
a1449 1
     *	Security: reject on strange character.
d1460 2
a1461 2
		    BADCHAR_IN_EXEC_LINK,
		    *cp);
d1469 1
a1469 1
check_tp_for_entry:
d1472 1
a1472 1
	    char CONST *command = linktext;
d1474 1
a1474 1
	    if (strstr(command,"//") == linktext) {
d1477 2
d1497 1
a1497 3
PRIVATE int fix_httplike_urls ARGS2(
	DocInfo *,	doc,
	UrlTypes,	type)
d1502 1
a1502 2
     *  If there's a fragment present, our simplistic methods won't
     *  work.  - kw
d1509 1
a1509 1
     *	If it's an ftp URL with a trailing slash, trim it off.
d1512 3
a1514 3
	LYIsHtmlSep(doc->address[strlen(doc->address)-1])) {
	char * proxy;
	char *path = HTParse(doc->address, "", PARSE_PATH|PARSE_PUNCTUATION);
d1517 1
a1517 1
	 *  If the path is a lone slash, we're done. - FM
d1528 1
a1528 1
	 *  If we're proxying ftp, don't trim anything. - KW
d1535 1
a1535 1
	 *  If we get to here, trim the trailing slash. - FM
d1559 1
a1559 1
     *	If there isn't a slash besides the two at the beginning, append one.
d1562 2
a1563 2
	if (!LYIsHtmlSep(*(slash-1)) || *(slash-2) != ':') {
	    return(0);
d1567 1
a1567 1
	    if ((slash-2) != strchr(doc->address, ':')) {
d1569 4
a1572 4
		 *  Turns out we were not looking at the right slash after all,
		 *  there must have been more than one "://" which is valid
		 *  at least for http URLs (later occurrences can be part of
		 *  a query string, for example), so leave this alone, too. - kw
d1574 1
a1574 1
		return(0);
d1578 3
a1580 4
		 *  If there is a question mark that appears to be part
		 *  of the hostname, don't append anything either. Leave
		 *  it to HTParse to interpret the question mark as ending
		 *  the hostname. - kw
d1582 1
a1582 1
		return(0);
d1591 1
a1591 1
    return(1);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d36 1
a36 5
PRIVATE int fix_httplike_urls PARAMS((document *doc, UrlTypes type));

#ifdef VMS
extern BOOLEAN LYDidRename;
#endif /* VMS */
d70 1
a70 1
	document *,	doc)
d72 4
a75 4
	int url_type = 0;
	char *cp = NULL;
	char *temp = NULL;
	DocAddress WWWDoc;  /* a WWW absolute doc address struct */
d77 7
a83 7
	/*
	 *  Reset LYCancelDownload to prevent unwanted delayed effect. - KW
	 */
	if (LYCancelDownload) {
	    CTRACE((tfp, "getfile:    resetting LYCancelDownload to FALSE\n"));
	    LYCancelDownload = FALSE;
	}
d85 4
a88 4
	/*
	 *  Reset fake 'Z' to prevent unwanted delayed effect. - kw
	 */
	LYFakeZap(NO);
d90 7
a96 7
	/*
	 *  Reset redirection counter to prevent bogus TOO_MANY_REDIRECTIONS
	 *  in rare situations if the previous cycle got to the limit, but
	 *  did not fail for that reason because the URL of the final location
	 *  was handled specially, not via HTLoadAbsolute. - kw
	 */
	redirection_attempts = 0;
d99 14
a112 9
	/*
	 *  Load the WWWDoc struct in case we need to use it.
	 */
	WWWDoc.address = doc->address;
	WWWDoc.post_data = doc->post_data;
	WWWDoc.post_content_type = doc->post_content_type;
	WWWDoc.bookmark = doc->bookmark;
	WWWDoc.isHEAD = doc->isHEAD;
	WWWDoc.safe = doc->safe;
d114 4
a117 4
	/*
	 *  Reset HTPermitRedir, it has done its job if it was set. - kw
	 */
	HTPermitRedir = FALSE;
d119 4
a122 4
	/*
	 *  Reset WWW_Download_File just in case.
	 */
	FREE(WWW_Download_File);
d124 12
a135 4
	/*
	 *  Reset redirect_post_content just in case.
	 */
	redirect_post_content = FALSE;
d137 1
a137 12
	/*
	 *  This flag is a hack to allow us to pass on the fact
	 *  that 'no data' may not really be an error although
	 *  HTLoadAbsolute returned NO.  There should be a better
	 *  way...  HT_NO_DATA should always mean 'not data but
	 *  not an error', and be passed on to us as that, but
	 *  current usage if HT_NO_DATA vs HT_NOT_LOADED has
	 *  to be reviewed everywhere.
	 *  Anyway, some protocol module can set it to say
	 *  'I really mean it', we have to reset it here. - kw
	 */
	HTNoDataOK = 0;
d139 10
a148 1
	CTRACE((tfp,"getfile: getting %s\n\n",doc->address));
d150 22
a171 38
	/*
	 *  Protect against denial of service attacks
	 *  via the port 19 CHARGEN service, and block
	 *  connections to the port 25 ESMTP service.
	 *  Also reject any likely spoof attempts via
	 *  wrap arounds at 65536. - FM
	 */
	if ((temp = HTParse(doc->address, "", PARSE_HOST)) != NULL &&
	    strlen(temp) > 3) {
	    char *cp1;

	    if ((cp1 = strchr(temp, '@@')) == NULL)
		cp1 = temp;
	    if ((cp = strrchr(cp1, ':')) != NULL) {
		long int value;

		cp++;
		if (sscanf(cp, "%ld", &value) == 1) {
		    if (value == 19 || value == 65555) {
			HTAlert(PORT_NINETEEN_INVALID);
			FREE(temp);
			return(NULLFILE);
		    }
		    if (value == 25 || value == 65561) {
			HTAlert(PORT_TWENTYFIVE_INVALID);
			FREE(temp);
			return(NULLFILE);
		    }
		    if (value > 65535 || value < 0) {
			char *msg = 0;
			HTSprintf0(&msg, PORT_INVALID, (unsigned long)value);
			HTAlert(msg);
			FREE(msg);
			FREE(temp);
			return(NULLFILE);
		    }
		} else if (isdigit(UCH(*cp))) {
		    HTAlert(URL_PORT_BAD);
d175 4
d181 3
a183 2
	cp = NULL;
	FREE(temp);
d185 94
a278 94
	/*
	 *  Check to see if this is a universal document ID
	 *  that lib WWW wants to handle.
	 *
	 *  Some special URL's we handle ourselves. :)
	 */
	if ((url_type = is_url(doc->address)) != 0) {
		if (LYValidate && !LYPermitURL) {
		    if (!(url_type == HTTP_URL_TYPE ||
			  url_type == HTTPS_URL_TYPE ||
			  url_type == LYNXHIST_URL_TYPE ||
			  url_type == LYNXKEYMAP_URL_TYPE ||
			  url_type == LYNXIMGMAP_URL_TYPE ||
			  url_type == LYNXCOOKIE_URL_TYPE ||
			  url_type == LYNXMESSAGES_URL_TYPE ||
			  (url_type == LYNXOPTIONS_URL_TYPE &&
			   WWWDoc.post_data) ||
			  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
					  strlen(helpfilepath)) ||
			  (lynxlistfile != NULL &&
			   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
					  strlen(lynxlistfile))) ||
			  (lynxlinksfile != NULL &&
			   0==STRNADDRCOMP(WWWDoc.address, lynxlinksfile,
					  strlen(lynxlinksfile))) ||
			  (lynxjumpfile != NULL &&
			   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
					  strlen(lynxjumpfile))))) {
			HTUserMsg(NOT_HTTP_URL_OR_ACTION);
			return(NULLFILE);
		    }
		}
		if (traversal) {
		    /*
		     *	Only traverse http URLs.
		     */
		    if (url_type != HTTP_URL_TYPE &&
			url_type != LYNXIMGMAP_URL_TYPE)
			return(NULLFILE);
		} else if (check_realm && !LYPermitURL && !LYJumpFileURL) {
		    if (!(0==strncmp(startrealm, WWWDoc.address,
				     strlen(startrealm)) ||
			  url_type == LYNXHIST_URL_TYPE ||
			  url_type == LYNXKEYMAP_URL_TYPE ||
			  url_type == LYNXIMGMAP_URL_TYPE ||
			  url_type == LYNXCOOKIE_URL_TYPE ||
			  url_type == LYNXPRINT_URL_TYPE ||
			  url_type == LYNXOPTIONS_URL_TYPE ||
			  url_type == LYNXCFG_URL_TYPE ||
			  url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
			  url_type == LYNXMESSAGES_URL_TYPE ||
			  url_type == LYNXDOWNLOAD_URL_TYPE ||
			  url_type == MAILTO_URL_TYPE ||
			  url_type == NEWSPOST_URL_TYPE ||
			  url_type == NEWSREPLY_URL_TYPE ||
			  url_type == SNEWSPOST_URL_TYPE ||
			  url_type == SNEWSREPLY_URL_TYPE ||
			  (!LYUserSpecifiedURL &&
			   (url_type == LYNXEXEC_URL_TYPE ||
			    url_type == LYNXPROG_URL_TYPE ||
			    url_type == LYNXCGI_URL_TYPE)) ||
			  (WWWDoc.bookmark != NULL &&
			   *WWWDoc.bookmark != '\0') ||
			  0==STRNADDRCOMP(WWWDoc.address, helpfilepath,
					  strlen(helpfilepath)) ||
			  (lynxlistfile != NULL &&
			   0==STRNADDRCOMP(WWWDoc.address, lynxlistfile,
					  strlen(lynxlistfile))) ||
			  (lynxjumpfile != NULL &&
			   0==STRNADDRCOMP(WWWDoc.address, lynxjumpfile,
					  strlen(lynxjumpfile))))) {
			HTUserMsg(NOT_IN_STARTING_REALM);
			return(NULLFILE);
		    }
		}
		if (WWWDoc.post_data &&
		    url_type != HTTP_URL_TYPE &&
		    url_type != HTTPS_URL_TYPE &&
		    url_type != LYNXCGI_URL_TYPE &&
		    url_type != LYNXIMGMAP_URL_TYPE &&
		    url_type != GOPHER_URL_TYPE &&
		    url_type != CSO_URL_TYPE &&
		    url_type != PROXY_URL_TYPE &&
		    url_type != LYNXOPTIONS_URL_TYPE &&
		    !(url_type == FILE_URL_TYPE &&
		      (LYIsUIPage(WWWDoc.address, UIP_LIST_PAGE) ||
		       LYIsUIPage(WWWDoc.address, UIP_ADDRLIST_PAGE)))) {
		    CTRACE((tfp, "getfile: dropping post_data!\n"));
		    HTAlert(IGNORED_POST);
		    FREE(doc->post_data);
		    FREE(doc->post_content_type);
		    WWWDoc.post_data = NULL;
		    WWWDoc.post_content_type = NULL;
		}
d280 1
a280 1
		LYSyslog (doc->address);
d282 9
a290 5
		if (url_type == UNKNOWN_URL_TYPE ||
		    url_type == AFS_URL_TYPE ||
		    url_type == PROSPERO_URL_TYPE) {
		    HTAlert(UNSUPPORTED_URL_SCHEME);
		    return(NULLFILE);
d292 2
a293 6
		} else if (url_type == DATA_URL_TYPE) {
		    HTAlert(UNSUPPORTED_DATA_URL);
		    return(NULLFILE);

		} else if (url_type == LYNXPRINT_URL_TYPE) {
		    return(printfile(doc));
d296 3
a298 3
		} else if (url_type == LYNXOPTIONS_URL_TYPE) {
		    /* proceed forms-based options menu */
		    return(postoptions(doc));
d301 6
a306 6
		} else if (url_type == LYNXCFG_URL_TYPE &&
		    !no_lynxcfg_info) {
		    /* @@@@@@ maybe we should generate a specific error message
		       if attempted but restricted. - kw */
		    /* show/change/reload lynx.cfg settings */
		    return(lynx_cfg_infopage(doc));
d309 6
a314 6
		} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE &&
		    !no_compileopts_info) {
		    /* @@@@@@ maybe we should generate a specific error message
		       if attempted but restricted or not supported. - kw */
		    /* show compile-time settings */
		    return(lynx_compile_opts(doc));
d318 17
a334 17
		} else if (url_type == NEWSPOST_URL_TYPE ||
			   url_type == NEWSREPLY_URL_TYPE ||
			   url_type == SNEWSPOST_URL_TYPE ||
			   url_type == SNEWSREPLY_URL_TYPE) {

		    if (no_newspost) {
			HTUserMsg(NEWSPOSTING_DISABLED);
			return(NULLFILE);
		    } else if (!news_ok && (
			url_type == NEWSPOST_URL_TYPE ||
			url_type == NEWSREPLY_URL_TYPE)) {
			HTUserMsg(NEWS_DISABLED);
			return(NULLFILE);
		    } else {
			HTLoadAbsolute(&WWWDoc);
			return(NULLFILE);
		    }
d337 2
a338 2
		} else if (url_type == LYNXDOWNLOAD_URL_TYPE) {
		    LYDownload(doc->address);
d340 10
a349 10
		    if (LYDidRename) {
			/*
			 *  The temporary file was saved to disk via a
			 *  rename(), so we can't access the temporary
			 *  file again via the download menu.  Clear the
			 *  flag, and return NULLFILE to pop. - FM
			 */
			LYDidRename = FALSE;
			return(NULLFILE);
		    }
d351 2
a352 2
		    return(NORMAL);
		} else if (url_type == LYNXDIRED_URL_TYPE) {
d354 14
a367 13
		    if (!no_dired_support) {
		       local_dired(doc);
		       WWWDoc.address = doc->address;
		       WWWDoc.post_data = doc->post_data;
		       WWWDoc.post_content_type = doc->post_content_type;
		       WWWDoc.bookmark = doc->bookmark;
		       WWWDoc.isHEAD = doc->isHEAD;
		       WWWDoc.safe = doc->safe;

		       if (!HTLoadAbsolute(&WWWDoc))
			   return(NOT_FOUND);
		       return(NORMAL);
		    }
d369 3
a371 3
		    HTUserMsg(DIRED_DISABLED);
		    return(NULLFILE);
		}
d373 29
a401 37
		if (LYNoRefererHeader == FALSE &&
		    LYNoRefererForThis == FALSE) {
		    char *ref_url = HTLoadedDocumentURL();
		    if (!strncmp(ref_url, "LYNXIMGMAP:", 11))
			ref_url += 11;
		    if (no_filereferer == TRUE &&
			!strncmp(ref_url, "file:", 5)) {
			LYNoRefererForThis = TRUE;
		    }
		    if (LYNoRefererForThis == FALSE &&
			(cp = strchr(ref_url, '?')) != NULL &&
			strchr(cp, '=') != NULL) {
			/*
			 *  Don't send a Referer header if the URL is
			 *  the reply from a form with method GET, in
			 *  case the content has personal data (e.g.,
			 *  a password or credit card number) which
			 *  would become visible in logs. - FM
			 *
			 *  Changed 1999-11-01 to be controlled by
			 *  REFERER_WITH_QUERY option. - kw
			 */
			if (LYRefererWithQuery == 'S') { /* SEND */
			    StrAllocCopy(LYRequestReferer, ref_url);
			} else if (LYRefererWithQuery == 'P') { /* PARTIAL */
			    FREE(LYRequestReferer); /* just to be sure */
			    LYRequestReferer = HTParse(ref_url, "",
		PARSE_ACCESS|PARSE_HOST|PARSE_STRICTPATH|PARSE_PUNCTUATION);
			} else { /* Everyhting else - don't send Referer */
			    LYNoRefererForThis = TRUE;
			}
			cp = NULL;
		    } else if (LYNoRefererForThis == FALSE) {
			StrAllocCopy(LYRequestReferer, ref_url);
		    }
		} else {
		    StrAllocCopy(LYRequestReferer, HTLoadedDocumentURL());
d403 18
a420 11
		if (url_type == LYNXHIST_URL_TYPE) {
		    /*
		     *	'doc' will change to the new file
		     *	if we had a successful LYpop_num(),
		     *	and the return value will be FALSE
		     *	if we had a cancel. - FM
		     */
		    if ((historytarget(doc) == FALSE) ||
			!doc || !doc->address) {
			return(NOT_FOUND);
		    }
d422 9
a430 9
		    /*
		     *	We changed it so reload.
		     */
		    WWWDoc.address = doc->address;
		    WWWDoc.post_data = doc->post_data;
		    WWWDoc.post_content_type = doc->post_content_type;
		    WWWDoc.bookmark = doc->bookmark;
		    WWWDoc.isHEAD = doc->isHEAD;
		    WWWDoc.safe = doc->safe;
d432 3
a434 3
		    if (doc->internal_link && !reloading) {
			LYinternal_flag = TRUE;
		    }
d438 1
a438 1
		    lynx_edit_mode = FALSE;
d440 4
a443 4
		    if (!HTLoadAbsolute(&WWWDoc)) {
			return(NOT_FOUND);
		    }
		    return(NORMAL);
d445 2
a446 2
		} else if (url_type == LYNXEXEC_URL_TYPE ||
			   url_type == LYNXPROG_URL_TYPE) {
d448 10
a457 10
		    if (no_exec &&
			!exec_ok(HTLoadedDocumentURL(),
				 doc->address+9, ALWAYS_EXEC_PATH)) {
			HTUserMsg(EXECUTION_DISABLED);
		    } else if (no_bookmark_exec &&
			       HTLoadedDocumentBookmark()) {
			HTUserMsg(BOOKMARK_EXEC_DISABLED);
		    } else if (local_exec || (local_exec_on_local_files &&
			       exec_ok(HTLoadedDocumentURL(),
				       doc->address+9, EXEC_PATH))) {
d459 1
a459 1
			char *p = NULL;
d461 33
a493 7
			/*
			 *  Bug puts slash on end if none is in the string.
			 */
			char *last_slash = strrchr(doc->address,'/');
			if (last_slash - doc->address
			 == (int)strlen(doc->address) - 1)
			    doc->address[strlen(doc->address)-1] = '\0';
d495 4
a498 30
			/*
			 *  Convert '~' to $HOME.
			 */
			if ((cp = strchr(doc->address, '~'))) {
			    HTSprintf0(&p, "%.*s%s%s",
					   cp - doc->address,
					   doc->address,
					   wwwName(Home_Dir()),
					   cp + 1);
			} else {
			    StrAllocCopy(p, doc->address);
			}
			/*
			 *  Show URL before executing it.
			 */
			HTInfoMsg(doc->address);
			stop_curses();
			/*
			 *  Run the command.
			 */
			if (strstr(p,"//") == p+9)
			    LYSystem(p+11);
			else
			    LYSystem(p+9);
			FREE(p);

			if (url_type != LYNXPROG_URL_TYPE) {
			    /*
			     *	Make sure user gets to see screen output.
			     */
d500 1
a500 1
			    signal(SIGINT, SIG_IGN);
d502 3
a504 3
			    printf("\n%s", RETURN_TO_LYNX);
			    fflush(stdout);
			    (void) LYgetch();
d506 1
a506 1
			    HadVMSInterrupt = FALSE;
d508 5
a512 5
			}
			if (!dump_output_immediately) {
			    start_curses();
			    LYAddVisitedLink(doc);
			}
d514 2
a515 2
		     } else {
			char *buf = 0;
d517 6
a522 6
			HTSprintf0(&buf,
				EXECUTION_DISABLED_FOR_FILE,
				key_for_func(LYK_OPTIONS));
			HTAlert(buf);
			FREE(buf);
		     }
d524 1
a524 1
		     HTUserMsg(EXECUTION_NOT_COMPILED);
d526 1
a526 1
		     return(NULLFILE);
d528 19
a546 3
		} else if (url_type == MAILTO_URL_TYPE) {
		    if (no_mail) {
			HTUserMsg(MAIL_DISABLED);
a547 4
			HTParentAnchor *tmpanchor;
			CONST char *title;
			char *tmptitle = NULL;

a548 26
			if ((tmpanchor = HTAnchor_parent(
						HTAnchor_findAddress(&WWWDoc)
							)) != NULL &&
			    HTAnchor_title(tmpanchor)) {
				title = HTAnchor_title(tmpanchor);
			} else if (HTMainAnchor && !LYUserSpecifiedURL) {
			    title = HTAnchor_subject(HTMainAnchor);
			    if (title && *title) {
				if (strncasecomp(title, "Re:", 3)) {
				    StrAllocCopy(tmptitle, "Re: ");
				    StrAllocCat(tmptitle, title);
				    title = tmptitle;
				}
			    } else {
				title = "";
			    }
			}
			cp = (char *)strchr(doc->address,':')+1;
			reply_by_mail(cp,
				      ((HTMainAnchor && !LYUserSpecifiedURL) ?
				       (char *)HTMainAnchor->address :
				       (char *)doc->address),
				      title,
				      (HTMainAnchor && !LYUserSpecifiedURL) ?
				       HTMainAnchor->message_id : NULL);
			FREE(tmptitle);
d550 12
a561 1
		    return(NULLFILE);
d563 16
a578 16
		/*
		 *  From here on we could have a remote host,
		 *  so check if that's allowed.
		 */
		} else if (local_host_only &&
			   url_type != LYNXKEYMAP_URL_TYPE &&
			   url_type != LYNXIMGMAP_URL_TYPE &&
			   url_type != LYNXCOOKIE_URL_TYPE &&
			   url_type != LYNXMESSAGES_URL_TYPE &&
			   url_type != LYNXCGI_URL_TYPE &&
			   !(url_type == NEWS_URL_TYPE &&
			     strncmp(doc->address, "news://", 7)) &&
			   !(LYisLocalHost(doc->address) ||
			     LYisLocalAlias(doc->address))) {
		    HTUserMsg(ACCESS_ONLY_LOCALHOST);
		    return(NULLFILE);
d580 36
a615 37
		/*
		 *  Disable www telnet access if not telnet_ok.
		 */
		} else if (url_type == TELNET_URL_TYPE ||
			   url_type == TN3270_URL_TYPE ||
			   url_type == TELNET_GOPHER_URL_TYPE) {
		    char * proxy;
		    if (!telnet_ok) {
			HTUserMsg(TELNET_DISABLED);
			return(NULLFILE);
		    } else if (no_telnet_port && strchr(doc->address+7, ':')) {
			HTUserMsg(TELNET_PORT_SPECS_DISABLED);
			return(NULLFILE);
		    /*
		     *  Detect weird case where interactive protocol would
		     *  be proxied, and to a non-interactive protocol at that.
		     */
		    } else if ((proxy = (char *)getenv(
			(url_type==TN3270_URL_TYPE) ? "tn3270_proxy" :
			(url_type==TELNET_GOPHER_URL_TYPE) ? "gopher_proxy" :
			"telnet_proxy")) != NULL &&
			       *proxy != '\0' &&
			       !override_proxy(doc->address) &&
			       (strncmp(proxy, "telnet:", 7) &&
				strncmp(proxy, "tn3270:", 7) &&
				strncmp(proxy, "rlogin:", 7))) {
			/* Do nothing, fall through to generic code - kw */
		    } else {
			stop_curses();
			HTLoadAbsolute(&WWWDoc);
			if (!dump_output_immediately) {
			    start_curses();
			    fflush(stdout);
			    LYAddVisitedLink(doc);
			}
			return(NULLFILE);
		    }
d617 3
a619 3
		/*
		 *  Disable www news access if not news_ok.
		 */
d621 5
a625 5
		} else if (!news_ok && (
		    url_type == NEWS_URL_TYPE ||
		    url_type == NNTP_URL_TYPE)) {
		    HTUserMsg(NEWS_DISABLED);
		    return(NULLFILE);
d628 26
a653 27
		} else if (url_type == RLOGIN_URL_TYPE) {
		    char * proxy;
		    if (!rlogin_ok) {
			HTUserMsg(RLOGIN_DISABLED);
			return(NULLFILE);
		    /*
		     *  Detect weird case where interactive protocol would
		     *  be proxied, and to a non-interactive protocol at that.
		     */
		    } else if ((proxy = (char *)getenv(
			"rlogin_proxy")) != NULL &&
			       *proxy != '\0' &&
			       !override_proxy(doc->address) &&
			       (strncmp(proxy, "telnet:", 7) &&
				strncmp(proxy, "tn3270:", 7) &&
				strncmp(proxy, "rlogin:", 7))) {
			/* Do nothing, fall through to generic code - kw */
		    } else {
			stop_curses();
			HTLoadAbsolute(&WWWDoc);
			fflush(stdout);
			if (!dump_output_immediately) {
			    start_curses();
			    LYAddVisitedLink(doc);
			}
			return(NULLFILE);
		    }
d655 21
a675 14
		/*
		 *  If its a gopher index type and there isn't a search
		 *  term already attached then do this.  Otherwise
		 *  just load it!
		 */
		} else if (url_type == INDEX_GOPHER_URL_TYPE &&
					strchr(doc->address,'?') == NULL) {
		    int status;
		    /*
		     *	Make sure we don't have a gopher+ escaped tab
		     *	instead of a gopher0 question mark delimiting
		     *	the search term. - FM
		     */
		    if ((cp = strstr(doc->address, "%09")) != NULL) {
a676 12
			StrAllocCopy(temp, doc->address);
			cp += 3;
			if (*cp && strncmp(cp, "%09", 3)) {
			    StrAllocCat(temp, "?");
			    StrAllocCat(temp, cp);
			    if ((cp = strstr(temp, "%09")) != NULL) {
				*cp = '\0';
			    }
			}
			StrAllocCopy(doc->address, temp);
			FREE(temp);
			goto Try_Redirected_URL;
d678 23
a700 17
		    /*
		     *	Load it because the do_www_search routine
		     *	uses the base url of the currently loaded
		     *	document :(
		     */
		    if (!HTLoadAbsolute(&WWWDoc))
			return(NOT_FOUND);
		    status = do_www_search(doc);
		    if (status == NULLFILE) {
			LYpop(doc);
			WWWDoc.address = doc->address;
			WWWDoc.post_data = doc->post_data;
			WWWDoc.post_content_type = doc->post_content_type;
			WWWDoc.bookmark = doc->bookmark;
			WWWDoc.isHEAD = doc->isHEAD;
			WWWDoc.safe = doc->safe;
			status = HTLoadAbsolute(&WWWDoc);
d702 2
a703 2
		    } else {
			lynx_edit_mode = FALSE;
d705 11
a715 2
		    }
		    return(status);
d717 26
d744 8
a751 41
		{

		    if (url_type == FTP_URL_TYPE && !ftp_ok) {
			HTUserMsg(FTP_DISABLED);
			return(NULLFILE);
		    }

		    if (url_type == HTML_GOPHER_URL_TYPE) {
			char *tmp=NULL;
		       /*
			*  If tuple's Path=GET%20/... convert to an http URL.
			*/
			if ((cp=strchr(doc->address+9, '/')) != NULL &&
			   0==strncmp(++cp, "hGET%20/", 8)) {
			    StrAllocCopy(tmp, "http://");
			    CTRACE((tfp, "getfile: URL '%s'\n",
					doc->address));
			    *cp = '\0';
			    StrAllocCat(tmp, doc->address+9);
			   /*
			    *  If the port is defaulted, it should stay 70.
			    */
			    if (strchr(tmp+6, ':') == NULL) {
				StrAllocCat(tmp, "70/");
				tmp[strlen(tmp)-4] = ':';
			    }
			    if (strlen(cp+7) > 1)
				StrAllocCat(tmp, cp+8);
			    StrAllocCopy(doc->address, tmp);
			    CTRACE((tfp, "  changed to '%s'\n",
					doc->address));
			    FREE(tmp);
			    url_type = HTTP_URL_TYPE;
			}
		    }
		    if (url_type == HTTP_URL_TYPE ||
			url_type == HTTPS_URL_TYPE ||
			url_type == FTP_URL_TYPE ||
			url_type == CSO_URL_TYPE)
			fix_httplike_urls(doc, url_type);
		    WWWDoc.address = doc->address;  /* possible reload */
d753 1
a753 1
		    lynx_edit_mode = FALSE;
d756 23
a778 23
		    if (url_type == BIBP_URL_TYPE) {
			char *bibpTmp = NULL;
			if (!BibP_bibhost_checked)
			    LYCheckBibHost();
			if (BibP_bibhost_available) {
			    StrAllocCopy(bibpTmp, BibP_bibhost);
			} else if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
			    StrAllocCopy(bibpTmp, HTAnchor_citehost(HTMainAnchor));
			} else {
			    StrAllocCopy(bibpTmp, BibP_globalserver);
			}
			if (HTMainAnchor && HTAnchor_citehost(HTMainAnchor)) {
			    StrAllocCat(bibpTmp, "bibp1.0/resolve?citehost=");
			    StrAllocCat(bibpTmp, HTAnchor_citehost(HTMainAnchor));
			    StrAllocCat(bibpTmp, "&usin=");
			} else {
			    StrAllocCat(bibpTmp, "bibp1.0/resolve?usin=");
			}
			StrAllocCat(bibpTmp, doc->address+5); /* USIN after bibp: */
			StrAllocCopy(doc->address, bibpTmp);
			WWWDoc.address = doc->address;
			FREE(bibpTmp);
		    }
d781 28
a808 36
		    if (url_type == FILE_URL_TYPE) {
			/*
			 *  If a file URL has a '~' as the lead character
			 *  of its first symbolic element, convert the '~'
			 *  to Home_Dir(), then append the rest of of path,
			 *  if present, skipping "user" if "~user" was
			 *  entered, simplifying, and eliminating any
			 *  residual relative elements. - FM
			 */
			if (((cp = HTParse(doc->address, "",
				   PARSE_PATH+PARSE_ANCHOR+PARSE_PUNCTUATION))
			      != NULL) &&
			    !strncmp(cp, "/~", 2)) {
			    char *cp1 = strstr(doc->address, "/~");
			    char *cp2;

			    CTRACE((tfp, "getfile: URL '%s'\n",
					doc->address));
			    *cp1 = '\0';
			    cp1 += 2;
			    StrAllocCopy(temp, doc->address);
			    StrAllocCopy(cp, wwwName(Home_Dir()));
			    if (!LYIsHtmlSep(*cp))
				LYAddHtmlSep(&temp);
			    StrAllocCat(temp, cp);
			    if ((cp2 = strchr(cp1, '/')) != NULL) {
				LYTrimRelFromAbsPath(cp2);
				StrAllocCat(temp, cp2);
			    }
			    StrAllocCopy(doc->address, temp);
			    FREE(temp);
			    CTRACE((tfp, "  changed to '%s'\n",
					doc->address));
			    WWWDoc.address = doc->address;
			}
			FREE(cp);
d810 10
a819 2
		    CTRACE_SLEEP(MessageSecs);
		    user_message(WWW_WAIT_MESSAGE, doc->address);
d821 1
a821 1
		    if (TRACE) {
d823 4
a826 4
			if (LYCursesON) {
			    LYaddstr("*\n");
			    LYrefresh();
			}
d828 10
a837 3
			CTRACE((tfp, "\n"));
		    }
		    if (!HTLoadAbsolute(&WWWDoc)) {
d839 16
a854 1
			 *  Check for redirection.
d856 14
a869 36
			if (use_this_url_instead != NULL) {
			    char *pound;

			    if (!is_url(use_this_url_instead)) {
				/*
				 *  The server did not return a complete
				 *  URL in its Location: header, probably
				 *  due to a FORM or other CGI script written
				 *  by someone who doesn't know that the http
				 *  protocol requires that it be a complete
				 *  URL, or using a server which does not treat
				 *  such a redirect string from the script as
				 *  an instruction to resolve it versus the
				 *  initial request, check authentication with
				 *  that URL, and then act on it without
				 *  returning redirection to us.  We'll
				 *  violate the http protocol and resolve it
				 *  ourselves using the URL of the original
				 *  request as the BASE, rather than doing
				 *  the RIGHT thing and returning an invalid
				 *  address message. - FM
				 */
				HTUserMsg(LOCATION_NOT_ABSOLUTE);
				temp = HTParse(use_this_url_instead,
					       WWWDoc.address,
					       PARSE_ALL);
				if (temp && *temp) {
				    StrAllocCopy(use_this_url_instead, temp);
				}
				FREE(temp);
			    }
			    url_type = is_url(use_this_url_instead);
			    if (!HTPermitRedir &&
			       (url_type == LYNXDOWNLOAD_URL_TYPE ||
				url_type == LYNXEXEC_URL_TYPE ||
				url_type == LYNXPROG_URL_TYPE ||
d871 1
a871 1
				url_type == LYNXDIRED_URL_TYPE ||
d873 14
a886 14
				url_type == LYNXPRINT_URL_TYPE ||
				url_type == LYNXOPTIONS_URL_TYPE ||
				url_type == LYNXCFG_URL_TYPE ||
				url_type == LYNXCOMPILE_OPTS_URL_TYPE ||
				url_type == LYNXHIST_URL_TYPE ||
				url_type == LYNXCOOKIE_URL_TYPE ||
				url_type == LYNXMESSAGES_URL_TYPE ||
				(LYValidate &&
				 url_type != HTTP_URL_TYPE &&
				 url_type != HTTPS_URL_TYPE) ||
				((no_file_url || no_goto_file) &&
				 url_type == FILE_URL_TYPE) ||
				(no_goto_lynxcgi &&
				 url_type == LYNXCGI_URL_TYPE) ||
d888 2
a889 2
				(no_goto_bibp &&
				 url_type == BIBP_URL_TYPE) ||
d891 15
a905 14
				(no_goto_cso &&
				 url_type == CSO_URL_TYPE) ||
				(no_goto_finger &&
				 url_type == FINGER_URL_TYPE) ||
				(no_goto_ftp &&
				 url_type == FTP_URL_TYPE) ||
				(no_goto_gopher &&
				 url_type == GOPHER_URL_TYPE) ||
				(no_goto_http &&
				 url_type == HTTP_URL_TYPE) ||
				(no_goto_https &&
				 url_type == HTTPS_URL_TYPE) ||
				(no_goto_mailto &&
				 url_type == MAILTO_URL_TYPE) ||
d907 4
a910 4
				(no_goto_news &&
				 url_type == NEWS_URL_TYPE) ||
				(no_goto_nntp &&
				 url_type == NNTP_URL_TYPE) ||
d912 2
a913 2
				(no_goto_rlogin &&
				 url_type == RLOGIN_URL_TYPE) ||
d915 2
a916 2
				(no_goto_snews &&
				 url_type == SNEWS_URL_TYPE) ||
d918 18
a935 61
				(no_goto_telnet &&
				 url_type == TELNET_URL_TYPE) ||
				(no_goto_tn3270 &&
				 url_type == TN3270_URL_TYPE) ||
				(no_goto_wais &&
				 url_type == WAIS_URL_TYPE))) {
				/*
				 *  Some schemes are not acceptable from
				 *  server redirections. - KW & FM
				 */
				HTAlert(ILLEGAL_REDIRECTION_URL);
				if (LYCursesON) {
				    _user_message(WWW_ILLEGAL_URL_MESSAGE,
						  use_this_url_instead);
				    LYSleepAlert();
				} else {
				    fprintf(stderr,
					    WWW_ILLEGAL_URL_MESSAGE,
					    use_this_url_instead);
				}
				FREE(use_this_url_instead);
				return(NULLFILE);
			    }
			    if ((pound = strchr(doc->address, '#')) != NULL &&
				strchr(use_this_url_instead, '#') == NULL) {
				/*
				 *  Our requested URL had a fragment
				 *  associated with it, and the redirection
				 *  URL doesn't, so we'll append the fragment
				 *  associated with the original request.  If
				 *  it's bogus for the redirection URL, we'll
				 *  be positioned at the top of that document,
				 *  so there's no harm done. - FM
				 */
				CTRACE((tfp,
			"getfile: Adding fragment '%s' to redirection URL.\n",
				    pound));
				StrAllocCat(use_this_url_instead, pound);
			    }
			    CTRACE_SLEEP(MessageSecs);
			    _user_message(WWW_USING_MESSAGE,
					  use_this_url_instead);
			    LYSleepInfo();
			    CTRACE((tfp, "\n"));
			    StrAllocCopy(doc->address,
					use_this_url_instead);
			    FREE(use_this_url_instead);
			    if (redirect_post_content == FALSE) {
				/*
				 *  Freeing the content also yields
				 *  a GET request. - FM
				 */
				FREE(doc->post_data);
				FREE(doc->post_content_type);
			    }
			    /*
			     *	Go to top to check for URL's which get
			     *	special handling and/or security checks
			     *	in Lynx. - FM
			     */
			    goto Try_Redirected_URL;
d937 90
a1026 2
			if (HTNoDataOK)
			    return(NULLFILE);
d1029 17
d1047 18
a1064 2
		    lynx_mode = NORMAL_LYNX_MODE;

d1066 1
a1066 7
		     *	Some URL's don't actually return a document;
		     *	compare doc->address with the document that is
		     *	actually loaded and return NULLFILE if not
		     *	loaded.  If www_search_result is not -1
		     *	then this is a reference to a named anchor
		     *	within the same document; do NOT return
		     *	NULLFILE in that case.
d1068 2
a1069 6
		    {
			char *pound;
			/*
			 *  Check for a #fragment selector.
			 */
			pound = (char *)strchr(doc->address, '#');
d1071 5
d1077 1
a1077 2
			 *  Check to see if there is a temp
			 *  file waiting for us to download.
d1079 1
a1079 85
			if (WWW_Download_File) {
			    HTParentAnchor *tmpanchor;
			    char *fname = NULL;

			    /*
			     *	Check for a suggested filename from
			     *	the Content-Disposition header. - FM
			     */
			    if (((tmpanchor = HTAnchor_parent(
						HTAnchor_findAddress(&WWWDoc)
							     )) != NULL) &&
				HTAnchor_SugFname(tmpanchor) != NULL) {
				StrAllocCopy(fname,
					     HTAnchor_SugFname(tmpanchor));
			    } else {
				StrAllocCopy(fname, doc->address);
			    }
			    /*
			     *	Check whether this is a compressed file,
			     *	which we don't uncompress for downloads,
			     *	and adjust any suffix appropriately. - FM
			     */
			    if (tmpanchor != NULL) {
				HTCheckFnameForCompression(&fname, tmpanchor,
							   FALSE);
			    }
			    if (LYdownload_options(&fname,
						   WWW_Download_File) < 0) {
				FREE(fname);
				return(NOT_FOUND);
			    }
			    LYAddVisitedLink(doc);
			    StrAllocCopy(doc->address, fname);
			    FREE(fname);
			    doc->internal_link = FALSE;
			    WWWDoc.address = doc->address;
			    FREE(doc->post_data);
			    WWWDoc.post_data = NULL;
			    FREE(doc->post_content_type);
			    WWWDoc.post_content_type = NULL;
			    WWWDoc.bookmark = doc->bookmark = FALSE;
			    WWWDoc.isHEAD = doc->isHEAD = FALSE;
			    WWWDoc.safe = doc->safe = FALSE;
			    HTOutputFormat = WWW_PRESENT;
			    if (!HTLoadAbsolute(&WWWDoc))
				return(NOT_FOUND);
			    else
				return(NORMAL);

			} else if (pound == NULL &&
				   /*
				    *  HTAnchor hash-table searches are now
				    *  case-sensitive (hopefully, without
				    *  anchor deletion problems), so this
				    *  is too. - FM
				    */
				   (strcmp(doc->address,
					   HTLoadedDocumentURL()) ||
				   /*
				    *  Also check the post_data elements. - FM
				    */
				   strcmp((doc->post_data ?
					   doc->post_data : ""),
					  HTLoadedDocumentPost_data()) ||
				   /*
				    *  Also check the isHEAD element. - FM
				    */
				   doc->isHEAD != HTLoadedDocumentIsHEAD())) {
			    /*
			     *	Nothing needed to be shown.
			     */
			    LYAddVisitedLink(doc);
			    return(NULLFILE);

			} else {
			    if (pound != NULL) {
				if (!HTMainText) /* this should not happen... */
				    return(NULLFILE); /* but it can. - kw */
				/*
				 *  May set www_search_result.
				 */
				HTFindPoundSelector(pound+1);
			    }
			    return(NORMAL);
			}
d1081 1
d1083 8
a1090 6
	  } else {
	      CTRACE_SLEEP(MessageSecs);
	      HTUserMsg2(WWW_BAD_ADDR_MESSAGE, doc->address);
	      CTRACE((tfp,"\n"));
	      return(NULLFILE);
	  }
d1148 1
a1148 1
	document *,	doc,
d1235 2
d1247 9
a1255 6
	if ((info = HTGetLinkInfo(*num,
				  want_go,
				  &new_top,
				  &new_link,
				  &links[cur].hightext,
			  &links[cur].lname)) == WWW_INTERN_LINK_TYPE) {
d1500 1
a1500 1
	document *,	doc,
d1509 1
a1509 1
    if (strchr(doc->address, '#'))
d1535 2
a1536 2
	if (((proxy = (char *)getenv("ftp_proxy")) != NULL) &&
	    *proxy != '\0' && !override_proxy(doc->address))
d1546 14
d1572 7
a1578 7
	    if ((slash-2) - strchr(doc->address, ':')) {
	    /*
	     *  Turns out we were not looking at the right slash after all,
	     *  there must have been more than one "://" which is valid
	     *  at least for http URLs (later occurrences can be part of
	     *  a query string, for example), so leave this alone, too. - kw
	     */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a16 1
#include <LYHistory.h>
d30 2
d36 1
a36 5
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
a37 2
PRIVATE int fix_http_urls PARAMS((document *doc));
extern char * WWW_Download_File;
d42 32
a73 1
PUBLIC BOOLEAN getfile ARGS1(
d85 1
a85 1
	    CTRACE(tfp, "getfile:    resetting LYCancelDownload to FALSE\n");
d94 8
d114 5
d128 14
a141 1
	CTRACE(tfp,"getfile: getting %s\n\n",doc->address);
d179 1
a179 1
		} else if (isdigit((unsigned char)*cp)) {
d203 4
a206 1
			  0==strncasecomp(WWWDoc.address, helpfilepath,
d209 1
a209 1
			   0==strncasecomp(WWWDoc.address, lynxlistfile,
d212 1
a212 1
			   0==strncasecomp(WWWDoc.address, lynxlinksfile,
d215 1
a215 1
			   0==strncasecomp(WWWDoc.address, lynxjumpfile,
d239 1
d252 1
a252 1
			  0==strncasecomp(WWWDoc.address, helpfilepath,
d255 1
a255 1
			   0==strncasecomp(WWWDoc.address, lynxlistfile,
d258 1
a258 1
			   0==strncasecomp(WWWDoc.address, lynxjumpfile,
d274 3
a276 4
		      *(LYlist_temp_url()) &&
		      !strncmp(WWWDoc.address, LYlist_temp_url(),
			       strlen(LYlist_temp_url())))) {
		    CTRACE(tfp, "getfile: dropping post_data!\n");
d283 3
a285 5
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
		syslog(LOG_INFO|LOG_LOCAL5, "%s", doc->address);
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d305 4
a308 1
		} else if (url_type == LYNXCFG_URL_TYPE) {
d313 4
a316 1
		} else if (url_type == LYNXCOMPILE_OPTS_URL_TYPE) {
a320 4
		} else if (url_type == LYNXMESSAGES_URL_TYPE) {
		    /* show list of recent statusline messages */
		    return(LYshow_statusline_messages(doc));

d330 5
a352 2
		    } else {
			return(NORMAL);
d354 1
a354 1
#else
a355 1
#endif /* VMS */
d358 1
a358 4
		    if (no_dired_support) {
		       HTUserMsg(DIRED_DISABLED);
		       return(NULLFILE);
		    } else {
d371 1
a371 1
#else
d374 1
a374 1
#endif /* DIRED_SUPPORT */
d376 39
a414 1
		} else if (url_type == LYNXHIST_URL_TYPE) {
d441 3
d463 1
a463 1
			char *p, addressbuf[1024];
a472 1
			p = doc->address;
d477 7
a483 6
			    strncpy(addressbuf, doc->address, cp-doc->address);
			    addressbuf[cp - doc->address] = '\0';
			    p = wwwName(Home_Dir());
			    strcat(addressbuf, p);
			    strcat(addressbuf, cp+1);
			    p = addressbuf;
d497 2
d508 1
a508 1
			    LYgetch();
d513 4
a516 2
			start_curses();
			LYAddVisitedLink(doc);
a574 1
			   url_type != NEWS_URL_TYPE &&
d578 1
d580 2
d593 1
d596 1
d599 15
d617 6
a622 3
			start_curses();
			fflush(stdout);
			LYAddVisitedLink(doc);
a623 1
		    return(NULLFILE);
d629 3
a631 1
		} else if (url_type == NEWS_URL_TYPE && !news_ok) {
d637 1
d640 13
d657 5
a661 2
			start_curses();
			LYAddVisitedLink(doc);
a662 1
		    return(NULLFILE);
d709 4
d716 2
a717 1
		} else {
d732 2
a733 2
			    CTRACE(tfp, "getfile: URL '%s'\n",
					doc->address);
d746 2
a747 2
			    CTRACE(tfp, "  changed to '%s'\n",
					doc->address);
d756 1
a756 1
			fix_http_urls(doc);
d761 25
d803 2
a804 2
			    CTRACE(tfp, "getfile: URL '%s'\n",
					doc->address);
d818 2
a819 2
			    CTRACE(tfp, "  changed to '%s'\n",
					doc->address);
d826 1
d830 2
a831 2
			    addstr("*\n");
			    refresh();
d834 1
a834 16
			fprintf(tfp,"\n");
		    }
		    if ((LYNoRefererHeader == FALSE &&
			 LYNoRefererForThis == FALSE) &&
			(url_type == HTTP_URL_TYPE ||
			 url_type == HTTPS_URL_TYPE) &&
			(cp = strchr(HTLoadedDocumentURL(), '?')) != NULL &&
			strchr(cp, '=') != NULL) {
			/*
			 *  Don't send a Referer header if the URL is
			 *  the reply from a form with method GET, in
			 *  case the content has personal data (e.g.,
			 *  a password or credit card number) which
			 *  would become visible in logs. - FM
			 */
			LYNoRefererForThis = TRUE;
a835 1
		    cp = NULL;
d872 2
a873 1
			    if (url_type == LYNXDOWNLOAD_URL_TYPE ||
d885 1
d893 4
d928 1
a928 1
				 url_type == WAIS_URL_TYPE)) {
d937 1
a937 1
				    sleep(AlertSecs);
d957 1
a957 1
				CTRACE(tfp,
d959 1
a959 1
				    pound);
d965 2
a966 2
			    sleep(InfoSecs);
			    CTRACE(tfp, "\n");
d985 2
d993 1
a993 1
		     *	Some URL's don't actually return a document
d995 1
a995 1
		     *	actually loaded and return NULL if not
d998 2
a999 2
		     *	within the same document.  Do NOT return
		     *	NULL.
d1087 6
a1092 4
			/*
			 *  May set www_search_result.
			 */
			    if (pound != NULL)
d1094 1
d1102 1
a1102 1
	      CTRACE(tfp,"\n");
d1108 36
d1172 2
a1173 2
    CTRACE(tfp,"follow_link_number(%d,%d,...)\n",c,cur);
    temp[0] = c;
d1185 1
a1185 1
    while ( isdigit(*p) )
d1195 1
d1201 1
a1201 1
    CTRACE(tfp,"  temp=%s, *num=%d, rel='%c'\n",temp,*num,rel);
d1206 5
a1210 1
    if ( c == 'p' || c == 'P' ) {
d1218 2
a1219 2
	CTRACE(tfp," nlines=%d, npages=%d, curline=%d, curpage=%d\n",
		nlines,npages,curline,curpage);
d1237 1
a1237 1
    want_go = ( c == 'g' || c == 'G' );
d1412 1
d1464 4
d1469 1
a1469 6
	if (!isalnum(*cp) &&
	    *cp != '_' && *cp != '-' && *cp != ' ' &&
	    *cp != ':' && *cp != '.' && *cp != '/' &&
	    *cp != '@@' && *cp != '~' && *cp != '$' &&
	    *cp != '&' && *cp != '+' && *cp != '=' &&
	    *cp != '\t') {
d1490 2
a1491 7
#ifdef VMS
	    if (strncasecomp(source, tp->src, strlen(tp->src)) == 0 &&
		strncasecomp(command, tp->path, strlen(tp->path)) == 0)
#else
	    if (strncmp(source, tp->src, strlen(tp->src)) == 0 &&
		strncmp(command, tp->path, strlen(tp->path)) == 0)
#endif /* VMS */
d1508 3
a1510 2
PRIVATE int fix_http_urls ARGS1(
	document *,	doc)
d1515 8
d1525 1
a1525 1
    if (!strncmp(doc->address, "ftp", 3) &&
d1551 1
a1551 1
	CTRACE(tfp, "fix_http_urls: URL '%s'\n", doc->address);
d1553 1
a1553 1
	CTRACE(tfp, "        changed to '%s'\n", doc->address);
d1556 1
d1565 21
d1587 1
a1587 1
    CTRACE(tfp, "fix_http_urls: URL '%s'\n", doc->address);
d1589 1
a1589 1
    CTRACE(tfp, "        changed to '%s'\n",doc->address);
@


1.1
log
@Initial revision
@
text
@d1 26
a26 33
#include "HTUtils.h"
#include "tcp.h"
#include "HTTP.h"
#include "HTAnchor.h"	    /* Anchor class */
#include "HTAccess.h"
#include "HTParse.h"
#include "LYCurses.h"
#include "GridText.h"
#include "LYGlobalDefs.h"
#include "LYUtils.h"
#include "LYCharSets.h"
#include "LYCharUtils.h"
#include "HTAlert.h"
#include "LYSignal.h"
#include "LYGetFile.h"
#include "LYPrint.h"
#include "LYHistory.h"
#include "LYStrings.h"
#include "LYClean.h"
#include "LYDownload.h"
#include "LYNews.h"
#include "LYMail.h"
#include "LYSystem.h"
#include "LYKeymap.h"
#include "LYBookmark.h"
#include "LYMap.h"
#include "LYList.h"
#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */
#ifdef DOSPATH
#include "HTDOS.h"
#endif
d28 1
a28 1
#include "LYLocal.h"
d30 1
d32 2
a33 2
#include "LYexit.h"
#include "LYLeaks.h"
a40 2
#define FREE(x) if (x) {free(x); x = NULL;}

a46 35
#if 0 /* UNUSED */
#ifdef DIRED_SUPPORT
PRIVATE char * LYSanctify ARGS1(
	char *, 	href)
{
    int i;
    char *p, *cp, *tp;
    char address_buffer[1024];

    i = (strlen(href) - 1);
    while (i && href[i] == '/') href[i--] = '\0';

    if ((cp = (char *)strchr(href,'~')) != NULL) {
       if (!strncmp(href, "file://localhost/", 17))
	 tp = (href + 17);
       else
	 tp = (href + 5);
       if ((cp - tp) && *(cp-1) != '/')
	 return href;
       LYstrncpy(address_buffer, href, (cp - href));
       if (address_buffer[(strlen(address_buffer) - 1)] == '/')
	 address_buffer[(strlen(address_buffer) - 1)] = '\0';
       p = (char *)Home_Dir();
       strcat(address_buffer, p);
       if (strlen(++cp))
	 strcat(address_buffer, cp);
       if (strcmp(href, address_buffer))
	 StrAllocCopy(href, address_buffer);
    }
    return href;
}
#endif /* DIRED_SUPPORT */
#endif


d59 1
a59 3
	    if (TRACE)
		fprintf(stderr,
			"getfile:    resetting LYCancelDownload to FALSE\n");
d89 1
a89 3
	if (TRACE) {
	    fprintf(stderr,"getfile: getting %s\n\n",doc->address);
	}
d120 2
a121 2
			char msg[265];
			sprintf(msg, PORT_INVALID, (unsigned long)value);
d123 1
d162 1
a162 2
			_statusline(NOT_HTTP_URL_OR_ACTION);
			sleep(MessageSecs);
d181 3
d204 1
a204 2
			_statusline(NOT_IN_STARTING_REALM);
			sleep(MessageSecs);
d216 1
d221 2
a222 4
		    if (TRACE)
			fprintf(stderr,
				"getfile: dropping post_data!\n");
		    HTAlert("POST not supported for this URL - ignoring POST data!");
d246 21
d273 1
a273 2
			_statusline(NEWSPOSTING_DISABLED);
			sleep(MessageSecs);
d279 1
d302 1
a302 2
		       _statusline(DIRED_DISABLED);
		       sleep(MessageSecs);
d318 1
a318 2
		    _statusline(DIRED_DISABLED);
		    sleep(MessageSecs);
a330 1
			HTMLSetCharacterHandling(current_char_set);
a349 1
			HTMLSetCharacterHandling(current_char_set);
a351 1
		    HTMLSetCharacterHandling(current_char_set);
d360 1
a360 2
			statusline(EXECUTION_DISABLED);
			sleep(MessageSecs);
d363 1
a363 2
			statusline(BOOKMARK_EXEC_DISABLED);
			sleep(MessageSecs);
d374 2
a375 1
			if (last_slash-doc->address==strlen(doc->address)-1)
d385 1
a385 9
#ifdef DOSPATH
			    p = HTDOS_wwwName((char *)Home_Dir());
#else
#ifdef VMS
			    p = HTVMS_wwwName((char *)Home_Dir());
#else
			    p = (char *)Home_Dir();
#endif /* VMS */
#endif /* DOSPATH */
d393 1
a393 2
			statusline(doc->address);
			sleep(InfoSecs);
d399 1
a399 1
			    system(p+11);
d401 1
a401 1
			    system(p+9);
d413 1
a413 4
			    {
			      extern BOOLEAN HadVMSInterrupt;
			      HadVMSInterrupt = FALSE;
			    }
d420 1
a420 1
			char buf[512];
d422 1
a422 1
			sprintf(buf,
d425 2
a426 2
			_statusline(buf);
			sleep(AlertSecs);
d429 1
a429 2
		     _statusline(EXECUTION_NOT_COMPILED);
		     sleep(MessageSecs);
d435 1
a435 2
			_statusline(MAIL_DISABLED);
			sleep(MessageSecs);
d439 1
d444 2
a445 2
							)) != NULL) {
			    if (HTAnchor_title(tmpanchor)) {
d447 10
d464 4
a467 1
				      title);
d483 1
a483 2
		    statusline(ACCESS_ONLY_LOCALHOST);
		    sleep(MessageSecs);
d493 1
a493 2
			_statusline(TELNET_DISABLED);
			sleep(MessageSecs);
d495 1
a495 2
			statusline(TELNET_PORT_SPECS_DISABLED);
			sleep(MessageSecs);
d508 1
d510 1
a510 2
		    _statusline(NEWS_DISABLED);
		    sleep(MessageSecs);
d512 1
d516 1
a516 2
			statusline(RLOGIN_DISABLED);
			sleep(MessageSecs);
d577 1
a577 2
			statusline(FTP_DISABLED);
			sleep(MessageSecs);
d589 1
a589 3
			    if (TRACE)
				fprintf(stderr,
					"getfile: URL '%s'\n",
d603 2
a604 3
			    if (TRACE)
				fprintf(stderr, "  changed to '%s'\n",
						doc->address);
d635 2
a636 3
			    if (TRACE)
				fprintf(stderr, "getfile: URL '%s'\n",
						doc->address);
d640 4
a643 11
#ifdef DOSPATH
			    StrAllocCat(temp, "/");
			    StrAllocCat(temp, HTDOS_wwwName((char *)Home_Dir()));
#else
#ifdef VMS
			    StrAllocCat(temp,
					HTVMS_wwwName((char *)Home_Dir()));
#else
			    StrAllocCat(temp, Home_Dir());
#endif /* VMS */
#endif /* DOSPATH */
d650 2
a651 3
			    if (TRACE)
				fprintf(stderr, "  changed to '%s'\n",
						doc->address);
d656 1
a656 2
		    if (TRACE && LYTraceLogFP == NULL)
			sleep(MessageSecs);
a657 3
#ifdef NOTDEFINED
		    sleep(InfoSecs);
#endif /* NOTDEFINED */
d665 1
a665 1
			fprintf(stderr,"\n");
d709 1
a709 1
				HTAlert(LOCATION_NOT_ABSOLUTE);
a717 1
			    HTMLSetCharacterHandling(current_char_set);
d726 3
d752 1
d757 1
d760 1
d763 1
d781 1
a781 1
					    "Illegal Redirection URL: %s",
d798 1
a798 2
				if (TRACE) {
				    fprintf(stderr,
a800 1
				}
d803 1
a803 2
			    if (TRACE && LYTraceLogFP == NULL)
				sleep(MessageSecs);
d807 1
a807 2
			    if (TRACE)
				fprintf(stderr, "\n");
a825 1
			HTMLSetCharacterHandling(current_char_set);
a854 1
			    HTMLSetCharacterHandling(current_char_set);
d857 1
a857 1
			     *	the Content-Dispostion header. - FM
a918 1
			    HTMLSetCharacterHandling(current_char_set);
a930 1
			    HTMLSetCharacterHandling(current_char_set);
d936 3
a938 6
	      if (TRACE && LYTraceLogFP == NULL)
		  sleep(MessageSecs);
	      _user_message(WWW_BAD_ADDR_MESSAGE, doc->address);
	      if (TRACE)
		  fprintf(stderr,"\n");
	      sleep(MessageSecs);
d966 2
d970 1
d972 1
d981 1
a981 2
	_statusline(CANCELLED);
	sleep(InfoSecs);
d984 15
a998 1
    *num = atoi(temp);
d1000 1
d1005 1
a1005 1
    if (strchr(temp, 'p') != NULL || strchr(temp, 'P') != NULL) {
d1010 5
d1016 5
a1020 1
	    *num = 1;
d1032 1
a1032 1
    want_go = (strchr(temp, 'g') != NULL || strchr(temp, 'G') != NULL);
d1034 5
d1100 1
d1141 1
d1144 1
a1144 1
	char *, 	str,
d1156 1
d1158 1
d1202 1
a1202 1
	CONST char *,	link,
d1233 1
a1233 1
    if ((cp = strchr(link, '[')) != NULL) {
d1250 1
a1250 1
    if (strstr(link, "../") != NULL) {
d1258 1
a1258 1
    for (cp = link; *cp != '\0'; cp++) {
d1265 1
a1265 1
	    char buf[128];
d1267 1
a1267 1
	    sprintf(buf,
d1271 1
d1280 1
a1280 1
	    char CONST *command = link;
d1282 1
a1282 1
	    if (strstr(command,"//") == link) {
d1317 1
a1317 1
	doc->address[strlen(doc->address)-1] == '/') {
d1325 1
a1325 1
	    if (path[0] == '/' && path[1] == '\0') {
d1342 4
a1345 8
	if (TRACE)
	    fprintf(stderr, "fix_http_urls: URL '%s'\n", doc->address);
	doc->address[strlen(doc->address)-1] = '\0';
	if (TRACE) {
	    fprintf(stderr, "        changed to '%s'\n", doc->address);
	    if (!LYTraceLogFP)
		sleep(MessageSecs);
	}
d1352 1
a1352 1
	if (*(slash-1) != '/' || *(slash-2) != ':') {
d1356 4
a1359 8
    if (TRACE)
	fprintf(stderr, "fix_http_urls: URL '%s'\n", doc->address);
    StrAllocCat(doc->address, "/");
    if (TRACE) {
	fprintf(stderr, "        changed to '%s'\n",doc->address);
	if (!LYTraceLogFP)
	    sleep(MessageSecs);
    }
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
