head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.06.01.53.42;	author martynas;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.40;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.14;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.59;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.59;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: UCdomap.c,v 1.96 2014/02/04 01:29:44 tom Exp $
 *
 *  UCdomap.c
 *  =========
 *
 * This is a Lynx chartrans engine, its external calls are in UCMap.h
 *
 * Derived from code in the Linux kernel console driver.
 * The GNU Public Licence therefore applies, see
 * the file COPYING in the top-level directory
 * which should come with every Lynx distribution.
 *
 *  [ original comment: - KW ]
 *
 * Mapping from internal code (such as Latin-1 or Unicode or IBM PC code)
 * to font positions.
 *
 * aeb, 950210
 */
#include <HTUtils.h>
#include <HTMLDTD.h>

#include <LYGlobalDefs.h>
#include <UCdomap.h>
#include <UCMap.h>
#include <UCAux.h>
#include <UCDefs.h>
#include <LYCharSets.h>
#include <LYStrings.h>
#include <LYUtils.h>

#if defined(USE_LOCALE_CHARSET) && defined(HAVE_LANGINFO_CODESET)
#include <langinfo.h>
#endif

#ifdef EXP_JAPANESEUTF8_SUPPORT
#include <iconv.h>
#endif

#include <LYLeaks.h>

/*
 * Include chartrans tables:
 */
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)   */
#include <cp1251_uni.h>		/* WinCyrillic (cp1251) */
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)   */
#include <cp1253_uni.h>		/* WinGreek (cp1253)    */
#include <cp1255_uni.h>		/* WinHebrew (cp1255)   */
#include <cp1256_uni.h>		/* WinArabic (cp1256)   */
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)  */
#include <cp437_uni.h>		/* DosLatinUS (cp437)   */
#include <cp737_uni.h>		/* DosGreek (cp737)     */
#include <cp775_uni.h>		/* DosBaltRim (cp775)   */
#include <cp850_uni.h>		/* DosLatin1 (cp850)    */
#include <cp852_uni.h>		/* DosLatin2 (cp852)    */
#include <cp857_uni.h>		/* DosTurkish (cp857)   */
#include <cp862_uni.h>		/* DosHebrew (cp862)    */
#include <cp864_uni.h>		/* DosArabic (cp864)    */
#include <cp866_uni.h>		/* DosCyrillic (cp866)  */
#include <cp869_uni.h>		/* DosGreek2 (cp869)    */
#include <def7_uni.h>		/* 7 bit approximations */
#include <dmcs_uni.h>		/* DEC Multinational    */
#include <hp_uni.h>		/* HP Roman8            */
#include <iso01_uni.h>		/* ISO Latin 1          */
#include <iso02_uni.h>		/* ISO Latin 2          */
#include <iso03_uni.h>		/* ISO Latin 3          */
#include <iso04_uni.h>		/* ISO Latin 4          */
#include <iso05_uni.h>		/* ISO 8859-5 Cyrillic  */
#include <iso06_uni.h>		/* ISO 8859-6 Arabic    */
#include <iso07_uni.h>		/* ISO 8859-7 Greek     */
#include <iso08_uni.h>		/* ISO 8859-8 Hebrew    */
#include <iso09_uni.h>		/* ISO 8859-9 (Latin 5) */
#include <iso10_uni.h>		/* ISO 8859-10          */
#include <iso13_uni.h>		/* ISO 8859-13 (Latin 7) */
#include <iso14_uni.h>		/* ISO 8859-14 (Latin 8) */
#include <iso15_uni.h>		/* ISO 8859-15 (Latin 9) */
#include <koi8r_uni.h>		/* KOI8-R Cyrillic      */
#include <mac_uni.h>		/* Macintosh (8 bit)    */
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic    */
#include <next_uni.h>		/* NeXT character set   */
#include <rfc_suni.h>		/* RFC 1345 w/o Intro   */
/* #include <utf8_uni.h> */ /* UNICODE UTF 8        */
#include <viscii_uni.h>		/* Vietnamese (VISCII)  */
#include <cp866u_uni.h>		/* Ukrainian Cyrillic (866) */
#include <koi8u_uni.h>		/* Ukrainian Cyrillic (koi8-u */
#include <pt154_uni.h>		/* Cyrillic-Asian (PT154) */

#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
int auto_display_charset = -1;
#endif

static const char *UC_GNsetMIMEnames[4] =
{
    "iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"
};

static int UC_GNhandles[4] =
{
    -1, -1, -1, -1
};

/*
 * Some of the code below, and some of the comments, are left in for
 * historical reasons.  Not all those tables below are currently
 * really needed (and what with all those hardwired codepoints),
 * but let's keep them around for now.  They may come in handy if we
 * decide to make more extended use of the mechanisms (including e.g.
 * for chars < 127...).  - KW
 */

static u16 translations[][256] =
{
    /*
     * 8-bit Latin-1 mapped to Unicode -- trivial mapping.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * VT100 graphics mapped to Unicode.
     */
    {
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
	0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
	0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
	0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
	0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
	0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
	0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
	0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
	0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
	0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
	0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
	0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
	0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
	0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
	0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
	0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
	0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
	0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
	0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
	0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
    },
    /*
     * IBM Codepage 437 mapped to Unicode.
     */
    {
	0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
	0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
	0x25ba, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
	0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
	0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
	0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
	0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
	0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
	0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
	0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
	0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
	0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
	0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
	0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
	0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
	0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
	0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
	0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
    },
    /*
     * User mapping -- default to codes for direct font mapping.
     */
    {
	0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
	0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
	0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
	0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
	0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
	0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
	0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
	0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
	0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
	0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
	0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
	0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
	0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
	0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
	0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
	0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
	0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
	0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
	0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
	0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
	0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
	0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
	0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
	0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
	0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
	0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
	0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
	0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
	0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
	0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
	0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
	0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
    }
};
static u16 *UC_translate = NULL;

static struct UC_charset UCInfo[MAXCHARSETS];

/*
 * The standard kernel character-to-font mappings are not invertible
 * -- this is just a best effort.
 */
#define MAX_GLYPH 512		/* Max possible glyph value */

static unsigned char *inv_translate = NULL;
static unsigned char inv_norm_transl[MAX_GLYPH];
static unsigned char *inverse_translations[4] =
{NULL, NULL, NULL, NULL};

static void set_inverse_transl(int i);
static u16 *set_translate(int m);
static int UC_valid_UC_charset(int UC_charset_hndl);
static void UC_con_set_trans(int UC_charset_in_hndl, int Gn, int update_flag);
static int con_insert_unipair(unsigned unicode, unsigned fontpos, int fordefault);
static int con_insert_unipair_str(unsigned unicode, const char *replace_str, int fordefault);
static void con_clear_unimap(int fordefault);
static void con_clear_unimap_str(int fordefault);
static void con_set_default_unimap(void);
static int UC_con_set_unimap(int UC_charset_out_hndl, int update_flag);
static int UC_con_set_unimap_str(unsigned ct, struct unipair_str *list, int fordefault);
static int conv_uni_to_pc(long ucs, int usedefault);
static int conv_uni_to_str(char *outbuf, int buflen, UCode_t ucs, int usedefault);
static void UCconsole_map_init(void);
static int UC_MapGN(int UChndl, int update_flag);
static int UC_FindGN_byMIME(const char *UC_MIMEcharset);
static void UCreset_allocated_LYCharSets(void);
static STRING2PTR UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned lowest8);
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit);

#ifdef LY_FIND_LEAKS
static void UCfree_allocated_LYCharSets(void);
static void UCcleanup_mem(void);
#endif

static int default_UChndl = -1;

static void set_inverse_transl(int i)
{
    int j, glyph;
    u16 *p = translations[i];
    unsigned char *q = inverse_translations[i];

    if (!q) {
	/*
	 * Slightly messy to avoid calling kmalloc too early.
	 */
	q = inverse_translations[i] = ((i == LAT1_MAP) ?
				       inv_norm_transl :
				       typeMallocn(unsigned char, MAX_GLYPH));

	if (!q)
	    return;
    }
    for (j = 0; j < MAX_GLYPH; j++)
	q[j] = 0;

    for (j = 0; j < E_TABSZ; j++) {
	glyph = conv_uni_to_pc((long) p[j], 0);
	if (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {
	    /*
	     * Prefer '-' above SHY etc.
	     */
	    q[glyph] = UCH(j);
	}
    }
}

static u16 *set_translate(int m)
{
    if (!inverse_translations[m])
	set_inverse_transl(m);
    inv_translate = inverse_translations[m];
    return translations[m];
}

static int UC_valid_UC_charset(int UC_charset_hndl)
{
    return (UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets);
}

static void UC_con_set_trans(int UC_charset_in_hndl,
			     int Gn,
			     int update_flag)
{
    int i, j;
    const u16 *p;
    u16 *ptrans;

    if (!UC_valid_UC_charset(UC_charset_in_hndl)) {
	CTRACE((tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		UC_charset_in_hndl));
	return;
    }
    ptrans = translations[Gn];
    p = UCInfo[UC_charset_in_hndl].unitable;
#if(0)
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
	return;			/* nothing to be done */
    }
    /*
     * The font is always 256 characters - so far.
     */
    con_clear_unimap();
#endif
    for (i = 0; i < 256; i++) {
	if ((j = UCInfo[UC_charset_in_hndl].unicount[i])) {
	    ptrans[i] = *p;
	    for (; j; j--) {
		p++;
	    }
	} else {
	    ptrans[i] = 0xfffd;
	}
    }
    if (update_flag) {
	set_inverse_transl(Gn);	/* Update inverse translation for this one */
    }
}

/*
 * Unicode -> current font conversion
 *
 * A font has at most 512 chars, usually 256.
 * But one font position may represent several Unicode chars.
 * A hashtable is somewhat of a pain to deal with, so use a
 * "paged table" instead.  Simulation has shown the memory cost of
 * this 3-level paged table scheme to be comparable to a hash table.
 */
static int hashtable_contents_valid = 0;	/* Use ASCII-only mode for bootup */
static int hashtable_str_contents_valid = 0;

static u16 **uni_pagedir[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static char ***uni_pagedir_str[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static const u16 *UC_current_unitable = NULL;
static struct unimapdesc_str *UC_current_unitable_str = NULL;

/*
 * Keep a second set of structures for the translation designated
 * as "default" - kw
 */
static int unidefault_contents_valid = 0;	/* Use ASCII-only mode for bootup */
static int unidefault_str_contents_valid = 0;

static u16 **unidefault_pagedir[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};
static char ***unidefault_pagedir_str[32] =
{
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static const u16 *UC_default_unitable = 0;
static const struct unimapdesc_str *UC_default_unitable_str = 0;

static int con_insert_unipair(unsigned unicode, unsigned fontpos, int fordefault)
{
    int i;
    unsigned n;
    u16 **p1, *p2;

    if (fordefault)
	p1 = unidefault_pagedir[n = unicode >> 11];
    else
	p1 = uni_pagedir[n = unicode >> 11];
    if (!p1) {
	p1 = (u16 * *)malloc(32 * sizeof(u16 *));
	if (fordefault)
	    unidefault_pagedir[n] = p1;
	else
	    uni_pagedir[n] = p1;
	if (!p1)
	    return ucError;

	for (i = 0; i < 32; i++) {
	    p1[i] = NULL;
	}
    }

    if (!(p2 = p1[n = (unicode >> 6) & 0x1f])) {
	p2 = p1[n] = (u16 *) malloc(64 * sizeof(u16));
	if (!p2)
	    return ucError;

	for (i = 0; i < 64; i++) {
	    p2[i] = 0xffff;	/* No glyph for this character (yet) */
	}
    }

    p2[unicode & 0x3f] = (u16) fontpos;

    return 0;
}

static int con_insert_unipair_str(unsigned unicode, const char *replace_str,
				  int fordefault)
{
    int i;
    unsigned n;
    char ***p1;
    const char **p2;

    if (fordefault)
	p1 = unidefault_pagedir_str[n = unicode >> 11];
    else
	p1 = uni_pagedir_str[n = unicode >> 11];
    if (!p1) {
	p1 = (char ***) malloc(32 * sizeof(char **));

	if (fordefault)
	    unidefault_pagedir_str[n] = p1;
	else
	    uni_pagedir_str[n] = p1;
	if (!p1)
	    return ucError;

	for (i = 0; i < 32; i++) {
	    p1[i] = NULL;
	}
    }

    n = ((unicode >> 6) & 0x1f);
    if (!p1[n]) {
	p1[n] = (char **) malloc(64 * sizeof(char *));

	if (!p1[n])
	    return ucError;

	p2 = (const char **) p1[n];
	for (i = 0; i < 64; i++) {
	    p2[i] = NULL;	/* No replace string this character (yet) */
	}
    }
    p2 = (const char **) p1[n];

    p2[unicode & 0x3f] = replace_str;

    return 0;
}

/*
 * ui arg was a leftover, deleted.  - KW
 */
static void con_clear_unimap(int fordefault)
{
    int i, j;
    u16 **p1;

    if (fordefault) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = unidefault_pagedir[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    unidefault_pagedir[i] = NULL;
	}

	unidefault_contents_valid = 1;
    } else {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    uni_pagedir[i] = NULL;
	}

	hashtable_contents_valid = 1;
    }
}

static void con_clear_unimap_str(int fordefault)
{
    int i, j;
    char ***p1;

    if (fordefault) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = unidefault_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    unidefault_pagedir_str[i] = NULL;
	}

	unidefault_str_contents_valid = 1;	/* ??? probably no use... */
    } else {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir_str[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    FREE(p1[j]);
		}
		FREE(p1);
	    }
	    uni_pagedir_str[i] = NULL;
	}

	hashtable_str_contents_valid = 1;	/* ??? probably no use... */
    }
}

/*
 * Loads the unimap for the hardware font, as defined in uni_hash.tbl.
 * The representation used was the most compact I could come up
 * with.  This routine is executed at sys_setup time, and when the
 * PIO_FONTRESET ioctl is called.
 */
static void con_set_default_unimap(void)
{
    int i, j;
    const u16 *p;

    /*
     * The default font is always 256 characters.
     */
    con_clear_unimap(1);

    p = dfont_unitable;
    for (i = 0; i < 256; i++) {
	for (j = dfont_unicount[i]; j; j--) {
	    con_insert_unipair(*(p++), (u16) i, 1);
	}
    }

    UC_default_unitable = dfont_unitable;

    con_clear_unimap_str(1);
    UC_con_set_unimap_str(dfont_replacedesc.entry_ct, repl_map, 1);
    UC_default_unitable_str = &dfont_replacedesc;
}

int UCNumCharsets = 0;

int UCLYhndl_HTFile_for_unspec = -1;
int UCLYhndl_HTFile_for_unrec = -1;
int UCLYhndl_for_unspec = -1;
int UCLYhndl_for_unrec = -1;

/* easy to type, will initialize later */
int LATIN1 = -1;		/* UCGetLYhndl_byMIME("iso-8859-1") */
int US_ASCII = -1;		/* UCGetLYhndl_byMIME("us-ascii")   */
int UTF8_handle = -1;		/* UCGetLYhndl_byMIME("utf-8")      */
int TRANSPARENT = -1;		/* UCGetLYhndl_byMIME("x-transparent")  */

static int UC_con_set_unimap(int UC_charset_out_hndl,
			     int update_flag)
{
    int i, j;
    const u16 *p;

    if (!UC_valid_UC_charset(UC_charset_out_hndl)) {
	CTRACE((tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		UC_charset_out_hndl));
	return ucError;
    }

    p = UCInfo[UC_charset_out_hndl].unitable;
    if (p == UC_current_unitable) {	/* test whether pointers are equal */
	return update_flag;	/* nothing to be done */
    }
    UC_current_unitable = p;

    /*
     * The font is always 256 characters - so far.
     */
    con_clear_unimap(0);

    for (i = 0; i < 256; i++) {
	for (j = UCInfo[UC_charset_out_hndl].unicount[i]; j; j--) {
	    con_insert_unipair(*(p++), (u16) i, 0);
	}
    }

    if (update_flag) {
	for (i = 0; i <= 3; i++) {
	    set_inverse_transl(i);	/* Update all inverse translations */
	}
    }

    return 0;
}

static int UC_con_set_unimap_str(unsigned ct, struct unipair_str *list,
				 int fordefault)
{
    int err = 0, err1;

    while (ct--) {
	if ((err1 = con_insert_unipair_str(list->unicode,
					   list->replace_str,
					   fordefault)) != 0) {
	    err = err1;
	}
	list++;
    }

    /*
     * No inverse translations for replacement strings!
     */
    if (!err) {
	if (fordefault)
	    unidefault_str_contents_valid = 1;
	else
	    hashtable_str_contents_valid = 1;
    }

    return err;
}

static int conv_uni_to_pc(long ucs,
			  int usedefault)
{
    int h;
    u16 **p1, *p2;

    /*
     * Only 16-bit codes supported at this time.
     */
    if (ucs > 0xffff) {
	/*
	 * U+FFFD:  REPLACEMENT CHARACTER.
	 */
	ucs = 0xfffd;
    } else if (ucs < 0x20 || ucs >= 0xfffe) {
	/*
	 * Not a printable character.
	 */
	return ucError;
    } else if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f)) {
	/*
	 * Zero-width space.
	 */
	return ucZeroWidth;
    } else if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE) {
	/*
	 * UNI_DIRECT_BASE indicates the start of the region in the
	 * User Zone which always has a 1:1 mapping to the currently
	 * loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 * of the region.
	 */
	return (ucs & UNI_DIRECT_MASK);
    }

    if (usedefault) {
	if (!unidefault_contents_valid)
	    return ucInvalidHash;
	p1 = unidefault_pagedir[ucs >> 11];
    } else {
	if (!hashtable_contents_valid)
	    return ucInvalidHash;
	p1 = uni_pagedir[ucs >> 11];
    }

    if (p1 &&
	(p2 = p1[(ucs >> 6) & 0x1f]) &&
	(h = p2[ucs & 0x3f]) < MAX_GLYPH) {
	return h;
    }

    /*
     * Not found.
     */
    return ucNotFound;
}

/*
 * Note:  contents of outbuf is not changes for negative return value!
 */
static int conv_uni_to_str(char *outbuf,
			   int buflen,
			   UCode_t ucs,
			   int usedefault)
{
    char *h;
    char ***p1, **p2;

    /*
     * Only 16-bit codes supported at this time.
     */
    if (ucs > 0xffff) {
	/*
	 * U+FFFD:  REPLACEMENT CHARACTER.
	 */
	ucs = 0xfffd;
	/*
	 * Maybe the following two cases should be allowed here??  - KW
	 */
    } else if (ucs < 0x20 || ucs >= 0xfffe) {
	/*
	 * Not a printable character.
	 */
	return ucError;
    } else if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f)) {
	/*
	 * Zero-width space.
	 */
	return ucZeroWidth;
    }

    if (usedefault) {
	if (!unidefault_str_contents_valid)
	    return ucInvalidHash;
	p1 = unidefault_pagedir_str[ucs >> 11];
    } else {
	if (!hashtable_str_contents_valid)
	    return ucInvalidHash;
	p1 = uni_pagedir_str[ucs >> 11];
    }

    if (p1 &&
	(p2 = p1[(ucs >> 6) & 0x1f]) &&
	(h = p2[ucs & 0x3f])) {
	StrNCpy(outbuf, h, (buflen - 1));
	return 1;		/* ok ! */
    }

    /*
     * Not found.
     */
    return ucNotFound;
}

int UCInitialized = 0;

/*
 * [ original comment:  - KW ]
 * This is called at sys_setup time, after memory and the console are
 * initialized.  It must be possible to call kmalloc(..., GFP_KERNEL)
 * from this function, hence the call from sys_setup.
 */
static void UCconsole_map_init(void)
{
    con_set_default_unimap();
    UCInitialized = 1;
}

/*
 * OK now, finally, some stuff that is more specifically for Lynx:  - KW
 */
int UCTransUniChar(UCode_t unicode,
		   int charset_out)
{
    int rc = 0;
    int UChndl_out;
    int isdefault, trydefault = 0;
    const u16 *ut;

    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0) {
	    if (unicode < 128) {
		rc = (int) unicode;
	    } else {
		rc = LYCharSet_UC[charset_out].codepage;
	    }
	    return rc;
	}
	if ((UChndl_out = default_UChndl) < 0) {
	    return ucCannotOutput;
	}
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }

    if (!isdefault) {
	ut = UCInfo[UChndl_out].unitable;
	if (ut != UC_current_unitable) {
	    rc = UC_con_set_unimap(UChndl_out, 1);
	    if (rc < 0) {
		return rc;
	    }
	}
	rc = conv_uni_to_pc(unicode, 0);
	if (rc >= 0) {
	    return rc;
	}
    }
    if (isdefault || trydefault) {
	rc = conv_uni_to_pc(unicode, 1);
	if (rc >= 0) {
	    return rc;
	}
    }
    if (!isdefault && (rc == ucNotFound)) {
	rc = conv_uni_to_pc(0xfffdL, 0);
    }
    if ((isdefault || trydefault) && (rc == ucNotFound)) {
	rc = conv_uni_to_pc(0xfffdL, 1);
    }
    return rc;
}

/*
 * Returns string length, or negative value for error.
 */
int UCTransUniCharStr(char *outbuf,
		      int buflen,
		      UCode_t unicode,
		      int charset_out,
		      int chk_single_flag)
{
    int rc = ucUnknown, src = 0;
    int UChndl_out;
    int isdefault, trydefault = 0;
    struct unimapdesc_str *repl;
    const u16 *ut;

    if (buflen < 2)
	return ucBufferTooSmall;

    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return ucCannotOutput;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }

    if (chk_single_flag) {
	if (!isdefault) {
	    ut = UCInfo[UChndl_out].unitable;
	    if (ut != UC_current_unitable) {
		src = UC_con_set_unimap(UChndl_out, 1);
		if (src < 0) {
		    return src;
		}
	    }
	}
	src = conv_uni_to_pc(unicode, isdefault);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }

    repl = &(UCInfo[UChndl_out].replacedesc);
    if (!isdefault) {
	if (repl != UC_current_unitable_str) {
	    con_clear_unimap_str(0);
	    (void) UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
	    UC_current_unitable_str = repl;
	}
	rc = conv_uni_to_str(outbuf, buflen, unicode, 0);
	if (rc >= 0)
	    return (int) strlen(outbuf);
    }
    if (trydefault && chk_single_flag) {
	src = conv_uni_to_pc(unicode, 1);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }
    if (isdefault || trydefault) {
#ifdef EXP_JAPANESEUTF8_SUPPORT
	if (LYCharSet_UC[charset_out].codepage == 0 &&
	    LYCharSet_UC[charset_out].codepoints == 0) {
	    iconv_t cd;
	    char str[3], *pin, *pout;
	    size_t inleft, outleft;
	    char *tocode = NULL;

	    str[0] = (char) (unicode >> 8);
	    str[1] = (char) (unicode & 0xFF);
	    str[2] = 0;
	    pin = str;
	    inleft = 2;
	    pout = outbuf;
	    outleft = (size_t) buflen;
	    /*
	     * Try TRANSLIT first, since it is an extension which can provide
	     * translations when there is no available exact translation to
	     * the target character set.
	     */
	    HTSprintf0(&tocode, "%s//TRANSLIT", LYCharSet_UC[charset_out].MIMEname);
	    cd = iconv_open(tocode, "UTF-16BE");
	    if (cd == (iconv_t) -1) {
		/*
		 * Try again, without TRANSLIT
		 */
		HTSprintf0(&tocode, "%s", LYCharSet_UC[charset_out].MIMEname);
		cd = iconv_open(tocode, "UTF-16BE");

		if (cd == (iconv_t) -1) {
		    CTRACE((tfp,
			    "Warning: Cannot transcode form charset %s to %s!\n",
			    "UTF-16BE", tocode));
		}
	    }
	    FREE(tocode);

	    if (cd != (iconv_t) -1) {
		rc = (int) iconv(cd, (ICONV_CONST char **) &pin, &inleft,
				 &pout, &outleft);
		iconv_close(cd);
		if ((pout - outbuf) == 3) {
		    CTRACE((tfp,
			    "It seems to be a JIS X 0201 code(%" PRI_UCode_t
			    "). Not supported.\n", unicode));
		    pin = str;
		    inleft = 2;
		    pout = outbuf;
		    outleft = (size_t) buflen;
		} else if (rc >= 0) {
		    *pout = '\0';
		    return (int) strlen(outbuf);
		}
	    }
	}
#endif
	rc = conv_uni_to_str(outbuf, buflen, unicode, 1);
	if (rc >= 0)
	    return (int) strlen(outbuf);
    }
    if (rc == ucNotFound) {
	if (!isdefault)
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffdL, 0);
	if ((rc == ucNotFound) && (isdefault || trydefault))
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffdL, 1);
	if (rc >= 0)
	    return (int) strlen(outbuf);
    }
    if (chk_single_flag && src == ucNotFound) {
	if (!isdefault)
	    rc = conv_uni_to_pc(0xfffdL, 0);
	if ((rc == ucNotFound) && (isdefault || trydefault))
	    rc = conv_uni_to_pc(0xfffdL, 1);
	if (rc >= 32) {
	    outbuf[0] = (char) rc;
	    outbuf[1] = '\0';
	    return 1;
	}
	return rc;
    }
    return ucNotFound;
}

static int UC_lastautoGN = 0;

static int UC_MapGN(int UChndl,
		    int update_flag)
{
    int i, Gn, found, lasthndl;

    found = 0;
    Gn = -1;
    for (i = 0; i < 4 && Gn < 0; i++) {
	if (UC_GNhandles[i] < 0) {
	    Gn = i;
	} else if (UC_GNhandles[i] == UChndl) {
	    Gn = i;
	    found = 1;
	}
    }
    if (found)
	return Gn;
    if (Gn >= 0) {
	UCInfo[UChndl].GN = Gn;
	UC_GNhandles[Gn] = UChndl;
    } else {
	if (UC_lastautoGN == GRAF_MAP) {
	    Gn = IBMPC_MAP;
	} else {
	    Gn = GRAF_MAP;
	}
	UC_lastautoGN = Gn;
	lasthndl = UC_GNhandles[Gn];
	UCInfo[lasthndl].GN = -1;
	UCInfo[UChndl].GN = Gn;
	UC_GNhandles[Gn] = UChndl;
    }
    CTRACE((tfp, "UC_MapGN: Using %d <- %d (%s)\n",
	    Gn, UChndl, UCInfo[UChndl].MIMEname));
    UC_con_set_trans(UChndl, Gn, update_flag);
    return Gn;
}

int UCTransChar(int ch_in,
		int charset_in,
		int charset_out)
{
    UCode_t unicode;
    int Gn;
    int rc = ucNotFound;
    int UChndl_in, UChndl_out;
    int isdefault, trydefault = 0;
    const u16 *ut;
    int upd = 0;

    if (charset_in == charset_out)
	return UCH(ch_in);
    if (charset_in < 0)
	return ucCannotConvert;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return ucCannotConvert;
    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return ucCannotOutput;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }
    if (!UCInfo[UChndl_in].num_uni)
	return ucCannotConvert;
    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
	Gn = UC_MapGN(UChndl_in, 0);
	upd = 1;
    }

    ut = UCInfo[UChndl_out].unitable;
    if (!isdefault) {
	if (ut == UC_current_unitable) {
	    if (upd) {
		set_inverse_transl(Gn);
	    }
	} else {
	    rc = UC_con_set_unimap(UChndl_out, 1);
	    if (rc > 0) {
		set_inverse_transl(Gn);
	    } else if (rc < 0) {
		return rc;
	    }
	}
    }
    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];
    if (!isdefault) {
	rc = conv_uni_to_pc(unicode, 0);
	if (rc >= 0)
	    return rc;
    }
    if ((rc == ucNotFound) && (isdefault || trydefault)) {
	rc = conv_uni_to_pc(unicode, 1);
    }
    if ((rc == ucNotFound) && !isdefault) {
	rc = conv_uni_to_pc(0xfffdL, 0);
    }
    if ((rc == ucNotFound) && (isdefault || trydefault)) {
	rc = conv_uni_to_pc(0xfffdL, 1);
    }
    return rc;
}

#ifdef EXP_JAPANESEUTF8_SUPPORT
UCode_t UCTransJPToUni(char *inbuf,
		       int buflen,
		       int charset_in)
{
    char outbuf[3], *pin, *pout;
    size_t ilen, olen;
    iconv_t cd;

    pin = inbuf;
    pout = outbuf;
    ilen = 2;
    olen = (size_t) buflen;

    cd = iconv_open("UTF-16BE", LYCharSet_UC[charset_in].MIMEname);
    (void) iconv(cd, (ICONV_CONST char **) &pin, &ilen, &pout, &olen);
    iconv_close(cd);
    if ((ilen == 0) && (olen == 0)) {
	return (((unsigned char) outbuf[0]) << 8) + (unsigned char) outbuf[1];
    }
    return ucCannotConvert;
}
#endif

/*
 * Translate a character to Unicode.  If additional bytes are needed, this
 * returns ucNeedMore, based on its internal state.  To reset the state,
 * call this with charset_in < 0.
 */
UCode_t UCTransToUni(int ch_in,
		     int charset_in)
{
    static char buffer[10];
    static unsigned inx = 0;

    UCode_t unicode;
    int Gn;
    unsigned char ch_iu = UCH(ch_in);
    int UChndl_in;

    /*
     * Reset saved-state.
     */
    if (charset_in < 0) {
	inx = 0;
	return ucCannotConvert;
    } else if (charset_in == LATIN1) {
	return ch_iu;
    } else if (charset_in == UTF8_handle) {
	if (is8bits(ch_iu)) {
	    unsigned need;
	    char *ptr;

	    buffer[inx++] = (char) ch_iu;
	    buffer[inx] = '\0';
	    need = (unsigned) utf8_length(TRUE, buffer);
	    if (need && (need + 1) == inx) {
		inx = 0;
		ptr = buffer;
		return UCGetUniFromUtf8String(&ptr);
	    } else if (inx < sizeof(buffer) - 1) {
		return ucNeedMore;
	    } else {
		inx = 0;
	    }
	} else {
	    inx = 0;
	}
    }
#ifdef EXP_JAPANESEUTF8_SUPPORT
    if ((strcmp(LYCharSet_UC[charset_in].MIMEname, "shift_jis") == 0) ||
	(strcmp(LYCharSet_UC[charset_in].MIMEname, "euc-jp") == 0)) {
	char obuffer[3], *pin, *pout;
	size_t ilen, olen;
	iconv_t cd;

	pin = buffer;
	pout = obuffer;
	ilen = olen = 2;
	if (strcmp(LYCharSet_UC[charset_in].MIMEname, "shift_jis") == 0) {
	    if (inx == 0) {
		if (IS_SJIS_HI1(ch_iu) ||
		    IS_SJIS_HI2(ch_iu)) {
		    buffer[0] = (char) ch_in;
		    inx = 1;
		    return ucNeedMore;
		}
	    } else {
		if (IS_SJIS_LO(ch_iu)) {
		    buffer[1] = (char) ch_in;
		    buffer[2] = 0;

		    cd = iconv_open("UTF-16BE", "Shift_JIS");
		    (void) iconv(cd, (ICONV_CONST char **) &pin, &ilen, &pout, &olen);
		    iconv_close(cd);
		    inx = 0;
		    if ((ilen == 0) && (olen == 0)) {
			return (UCH(obuffer[0]) << 8) + UCH(obuffer[1]);
		    }
		}
	    }
	}
	if (strcmp(LYCharSet_UC[charset_in].MIMEname, "euc-jp") == 0) {
	    if (inx == 0) {
		if (IS_EUC_HI(ch_iu)) {
		    buffer[0] = (char) ch_in;
		    inx = 1;
		    return ucNeedMore;
		}
	    } else {
		if (IS_EUC_LOX(ch_iu)) {
		    buffer[1] = (char) ch_in;
		    buffer[2] = 0;

		    cd = iconv_open("UTF-16BE", "EUC-JP");
		    (void) iconv(cd, (ICONV_CONST char **) &pin, &ilen, &pout, &olen);
		    iconv_close(cd);
		    inx = 0;
		    if ((ilen == 0) && (olen == 0)) {
			return (UCH(obuffer[0]) << 8) + UCH(obuffer[1]);
		    }
		}
	    }
	}
	inx = 0;
    }
#endif
    if (ch_iu < 128 && ch_iu >= 32)
	return ch_iu;

    if (ch_iu < 32 &&
	LYCharSet_UC[charset_in].enc != UCT_ENC_8BIT_C0) {
	/*
	 * Don't translate C0 chars except for specific charsets.
	 */
	return ch_iu;
    } else if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0) {
	return ucCannotConvert;
    } else if (!UCInfo[UChndl_in].num_uni) {
	return ucCannotConvert;
    }

    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
	Gn = UC_MapGN(UChndl_in, 1);
    }

    UC_translate = set_translate(Gn);
    unicode = UC_translate[ch_iu];

    return unicode;
}

int UCReverseTransChar(int ch_out,
		       int charset_in,
		       int charset_out)
{
    int Gn;
    int rc = ucError;
    int UChndl_in, UChndl_out;
    int isdefault;
    int i_ch = UCH(ch_out);
    const u16 *ut;

    if (charset_in == charset_out)
	return UCH(ch_out);
    if (charset_in < 0)
	return ucCannotConvert;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return ucCannotConvert;
    if (!UCInfo[UChndl_in].num_uni)
	return ucCannotConvert;
    if (charset_out < 0)
	return ucCannotOutput;
    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return ucCannotOutput;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    }

    if (!isdefault) {
	/*
	 * Try to use the inverse table if charset_out is not equivalent
	 * to using just the default table.  If it is, it should have
	 * just ASCII chars and trying to back-translate those should
	 * not give anything but themselves.  - kw
	 */
	ut = UCInfo[UChndl_out].unitable;
	if (ut == UC_current_unitable) {
	    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
		Gn = UC_MapGN(UChndl_in, 1);
	    }
	    UC_translate = set_translate(Gn);
	    if (inv_translate)
		rc = inv_translate[i_ch];
	    if (rc >= 32) {
		return rc;
	    }
	}
    }
    return UCTransChar(ch_out, charset_out, charset_in);
}

/*
 * Returns string length, or negative value for error.
 */
int UCTransCharStr(char *outbuf,
		   int buflen,
		   int ch_in,
		   int charset_in,
		   int charset_out,
		   int chk_single_flag)
{
    UCode_t unicode;
    int Gn;
    int rc = ucUnknown, src = 0;
    int UChndl_in, UChndl_out;
    int isdefault, trydefault = 0;
    struct unimapdesc_str *repl;
    const u16 *ut;
    int upd = 0;

    if (buflen < 2)
	return ucBufferTooSmall;
    if (chk_single_flag && charset_in == charset_out) {
	outbuf[0] = (char) ch_in;
	outbuf[1] = '\0';
	return 1;
    }
    if (charset_in < 0)
	return ucCannotConvert;
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return ucCannotConvert;
    if (!UCInfo[UChndl_in].num_uni)
	return ucCannotConvert;
    if ((UChndl_out = LYCharSet_UC[charset_out].UChndl) < 0) {
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return ucCannotOutput;
	isdefault = 1;
    } else {
	isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
	trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
    }
    if ((Gn = UCInfo[UChndl_in].GN) < 0) {
	Gn = UC_MapGN(UChndl_in, !chk_single_flag);
	upd = chk_single_flag;
    }

    UC_translate = set_translate(Gn);
    unicode = UC_translate[UCH(ch_in)];

    if (chk_single_flag) {
	if (!isdefault) {
	    ut = UCInfo[UChndl_out].unitable;
	    if (ut == UC_current_unitable) {
		if (upd)
		    set_inverse_transl(Gn);
	    } else {
		src = UC_con_set_unimap(UChndl_out, 1);
		if (src > 0) {
		    set_inverse_transl(Gn);
		} else if (src < 0) {
		    return src;
		}
	    }
	}
	src = conv_uni_to_pc(unicode, isdefault);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }

    repl = &(UCInfo[UChndl_out].replacedesc);
    if (!isdefault) {
	if (repl != UC_current_unitable_str) {
	    con_clear_unimap_str(0);
	    (void) UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
	    UC_current_unitable_str = repl;
	}
	rc = conv_uni_to_str(outbuf, buflen, unicode, 0);
	if (rc >= 0)
	    return (int) strlen(outbuf);
    }
    if (trydefault && chk_single_flag) {
	src = conv_uni_to_pc(unicode, 1);
	if (src >= 32) {
	    outbuf[0] = (char) src;
	    outbuf[1] = '\0';
	    return 1;
	}
    }
    if (isdefault || trydefault) {
	rc = conv_uni_to_str(outbuf, buflen, unicode, 1);
	if (rc >= 0)
	    return (int) strlen(outbuf);
    }
    if (rc == ucNotFound) {
	if (!isdefault)
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffdL, 0);
	if ((rc == ucNotFound) && (isdefault || trydefault))
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffdL, 1);
	if (rc >= 0)
	    return (int) strlen(outbuf);
    }
    if (chk_single_flag && src == ucNotFound) {
	if (!isdefault)
	    rc = conv_uni_to_pc(0xfffdL, 0);
	if ((rc == ucNotFound) && (isdefault || trydefault))
	    rc = conv_uni_to_pc(0xfffdL, 1);
	if (rc >= 32) {
	    outbuf[0] = (char) rc;
	    outbuf[1] = '\0';
	    return 1;
	} else if (rc <= 0) {
	    outbuf[0] = '\0';
	    return rc;
	}
	return rc;
    }
    return ucNotFound;
}

static int UC_FindGN_byMIME(const char *UC_MIMEcharset)
{
    int i;

    for (i = 0; i < 4; i++) {
	if (!strcmp(UC_MIMEcharset, UC_GNsetMIMEnames[i])) {
	    return i;
	}
    }
    return ucError;
}

int UCGetRawUniMode_byLYhndl(int i)
{
    if (i < 0)
	return 0;
    return LYCharSet_UC[i].enc;
}

/*
 * Construct a new charset name, given prefix and codepage.  This introduces
 * potentially unchecked recursion into UCGetLYhntl_byMIME if neither the "cp"
 * nor "windows-" prefixes are configured, so we check it here.
 */
static int getLYhndl_byCP(const char *prefix,
			  const char *codepage)
{
    static int nested;
    int result = ucError;

    if (!nested++) {
	char *cptmp = NULL;

	StrAllocCopy(cptmp, prefix);
	StrAllocCat(cptmp, codepage);
	result = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
    }
    nested--;
    return result;
}

/*
 * Get Lynx internal charset handler from MIME name,
 * return -1 if we got NULL or did not recognize value.
 * According to RFC, MIME headers should match case-insensitively.
 */
int UCGetLYhndl_byMIME(const char *value)
{
    int i;
    int LYhndl = -1;

    if (isEmpty(value)) {
	CTRACE((tfp,
		"UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
	return ucError;
    }

    for (i = 0;
	 (i < MAXCHARSETS && i < LYNumCharsets &&
	  LYchar_set_names[i]); i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    return i;
	}
    }

    /*
     * Not yet found, try synonyms.  - FM
     */
#if !NO_CHARSET_utf_8
    if (!strcasecomp(value, "unicode-1-1-utf-8") ||
	!strcasecomp(value, "utf8")) {
	/*
	 * Treat these as synonyms for the IANA registered name.  - FM
	 */
	return UCGetLYhndl_byMIME("utf-8");
    }
#endif
    if (!strncasecomp(value, "iso", 3) && !StrNCmp(value + 3, "8859", 4)) {
	return getLYhndl_byCP("iso-", value + 3);
    }
    if (!strcasecomp(value, "iso-8859-8-i") ||
	!strcasecomp(value, "iso-8859-8-e")) {
	return UCGetLYhndl_byMIME("iso-8859-8");
    }
#if !NO_CHARSET_euc_jp
    if (!strcasecomp(value, "x-euc-jp") ||
	!strcasecomp(value, "eucjp")) {
	return UCGetLYhndl_byMIME("euc-jp");
    }
#endif
#if !NO_CHARSET_shift_jis
    if ((!strcasecomp(value, "x-shift-jis")) ||
	(!strcasecomp(value, "x-sjis")) ||
	(!strcasecomp(value, "pck"))) {
	return UCGetLYhndl_byMIME("shift_jis");
    }
#endif
#if !NO_CHARSET_euc_kr
    if (!strcasecomp(value, "iso-2022-kr")) {
	return UCGetLYhndl_byMIME("euc-kr");
    }
#endif
#if !NO_CHARSET_euc_cn
    if (!strcasecomp(value, "gb2312") ||
	!strncasecomp(value, "cn-gb", 5) ||
	!strcasecomp(value, "iso-2022-cn")) {
	return UCGetLYhndl_byMIME("euc-cn");
    }
#endif
#if !NO_CHARSET_big5
    if (!strcasecomp(value, "cn-big5")) {
	return UCGetLYhndl_byMIME("big5");
    }
#endif
#if !NO_CHARSET_macintosh
    if (!strcasecomp(value, "x-mac-roman") ||
	!strcasecomp(value, "mac-roman")) {
	return UCGetLYhndl_byMIME("macintosh");
    }
#endif
#if !NO_CHARSET_next
    if (!strcasecomp(value, "x-next") ||
	!strcasecomp(value, "nextstep") ||
	!strcasecomp(value, "x-nextstep")) {
	return UCGetLYhndl_byMIME("next");
    }
#endif
#if !NO_CHARSET_windows_1252
    if (!strcasecomp(value, "iso-8859-1-windows-3.1-latin-1") ||
	!strcasecomp(value, "cp1252") ||
	!strcasecomp(value, "cp-1252") ||
	!strcasecomp(value, "ibm1252") ||
	!strcasecomp(value, "iso-8859-1-windows-3.0-latin-1")) {
	/*
	 * Treat these as synonyms for windows-1252, which is more
	 * commonly used than the IANA registered name.  - FM
	 */
	return UCGetLYhndl_byMIME("windows-1252");
    }
#endif
#if !NO_CHARSET_windows_1251
    if (!strcasecomp(value, "ansi-1251")) {
	return UCGetLYhndl_byMIME("windows-1251");
    }
#endif
#if !NO_CHARSET_windows_1250
    if (!strcasecomp(value, "iso-8859-2-windows-latin-2") ||
	!strcasecomp(value, "cp1250") ||
	!strcasecomp(value, "cp-1250") ||
	!strcasecomp(value, "ibm1250")) {
	/*
	 * Treat these as synonyms for windows-1250.  - FM
	 */
	return UCGetLYhndl_byMIME("windows-1250");
    }
#endif
    if ((!strncasecomp(value, "ibm", 3) ||
	 !strncasecomp(value, "cp-", 3)) &&
	isdigit(UCH(value[3])) &&
	isdigit(UCH(value[4])) &&
	isdigit(UCH(value[5]))) {
	/*
	 * For "ibmNNN<...>" or "cp-NNN", try "cpNNN<...>"
	 * if not yet found.  - KW & FM
	 */
	if ((LYhndl = getLYhndl_byCP("cp", value + 3)) >= 0)
	    return LYhndl;
	/*
	 * Try windows-NNN<...> if not yet found.  - FM
	 */
	return getLYhndl_byCP("windows-", value + 3);
    }
    if (!strncasecomp(value, "windows-", 8) &&
	isdigit(UCH(value[8])) &&
	isdigit(UCH(value[9])) &&
	isdigit(UCH(value[10]))) {
	/*
	 * For "windows-NNN<...>", try "cpNNN<...>" - FM
	 */
	return getLYhndl_byCP("cp", value + 8);
    }
#if !NO_CHARSET_koi8_r
    if (!strcasecomp(value, "koi-8")) {		/* accentsoft bugosity */
	return UCGetLYhndl_byMIME("koi8-r");
    }
#endif
    if (!strcasecomp(value, "ANSI_X3.4-1968")) {
	return US_ASCII;
    }
    /* no more synonyms if come here... */

    CTRACE((tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value));
    return ucError;		/* returns -1 if no charset found by that MIME name */
}

/*
 * Function UC_setup_LYCharSets_repl() tries to set up a subtable in
 * LYCharSets[] appropriate for this new charset, for compatibility with the
 * "old method".  Maybe not nice (maybe not even necessary any more), but it
 * works (as far as it goes..).
 *
 * We try to be conservative and only allocate new memory for this if needed.
 * If not needed, just point to SevenBitApproximations[i].  [Could do the same
 * for ISO_Latin1[] if it's identical to that, but would make it even *more*
 * messy than it already is...] This the only function in this file that knows,
 * or cares, about the HTMLDTD or details of LYCharSets[] subtables (and
 * therefore somewhat violates the idea that this file should be independent of
 * those).  As in other places, we rely on ISO_Latin1 being the *first* table
 * in LYCharSets.  - KW
 */

/*
 * We need to remember which ones were allocated and which are static.
 */
static STRING2PTR remember_allocated_LYCharSets[MAXCHARSETS];

static void UCreset_allocated_LYCharSets(void)
{
    int i = 0;

    for (; i < MAXCHARSETS; i++) {
	remember_allocated_LYCharSets[i] = NULL;
    }
}

#ifdef LY_FIND_LEAKS
static void UCfree_allocated_LYCharSets(void)
{
    int i = 0;

    for (; i < MAXCHARSETS; i++) {
	if (remember_allocated_LYCharSets[i] != NULL) {
	    FREE(remember_allocated_LYCharSets[i]);
	}
    }
}
#endif

static STRING2PTR UC_setup_LYCharSets_repl(int UC_charset_in_hndl,
					   unsigned lowest8)
{
    STRING2PTR ISO_Latin1 = LYCharSets[0];
    const char **p;
    char **prepl;
    const u16 *pp;
    const char **tp;
    const char *s7;
    const char *s8;
    size_t i;
    int j, changed;
    u16 k;
    u8 *ti;

    /*
     * Create a temporary table for reverse lookup of latin1 codes:
     */
    tp = (const char **) malloc(96 * sizeof(char *));

    if (!tp)
	return NULL;
    for (i = 0; i < 96; i++)
	tp[i] = NULL;
    ti = (u8 *) malloc(96 * sizeof(u8));
    if (!ti) {
	FREE(tp);
	return NULL;
    }
    for (i = 0; i < 96; i++)
	ti[i] = 0;

    pp = UCInfo[UC_charset_in_hndl].unitable;

    /*
     * Determine if we have any mapping of a Unicode in the range 160-255
     * to an allowed code point > 0x80 in our new charset...
     * Store any mappings found in ti[].
     */
    if (UCInfo[UC_charset_in_hndl].num_uni > 0) {
	for (i = 0; i < 256; i++) {
	    if ((j = UCInfo[UC_charset_in_hndl].unicount[i])) {
		if ((k = *pp) >= 160 && k < 256 && i >= lowest8) {
		    ti[k - 160] = UCH(i);
		}
		for (; j; j--) {
		    pp++;
		}
	    }
	}
    } {
	u16 ct;
	struct unipair_str *list;

	/*
	 * Determine if we have any mapping of a Unicode in the range
	 * 160-255 to a replacement string for our new charset...
	 * Store any mappings found in tp[].
	 */
	ct = UCInfo[UC_charset_in_hndl].replacedesc.entry_ct;
	list = UCInfo[UC_charset_in_hndl].replacedesc.entries;
	while (ct--) {
	    if ((k = list->unicode) >= 160 && k < 256) {
		tp[k - 160] = list->replace_str;
	    }
	    list++;
	}
    }
    /*
     * Now allocate a new table compatible with LYCharSets[]
     * and with the HTMLDTD for entities.
     * We don't know yet whether we'll keep it around.
     */
    prepl = (char **) malloc(HTML_dtd.number_of_entities * sizeof(char *));

    if (!prepl) {
	FREE(tp);
	FREE(ti);
	return 0;
    }

    p = (const char **) prepl;
    changed = 0;
    for (i = 0; i < HTML_dtd.number_of_entities; i++, p++) {
	/*
	 * For each of those entities, we check what the "old method"
	 * ISO_Latin1[] mapping does with them.  If it is nothing we
	 * want to use, just point to the SevenBitApproximations[] string.
	 */
	s7 = SevenBitApproximations[i];
	s8 = ISO_Latin1[i];
	*p = s7;
	if (s8 && UCH(*s8) >= 160 && s8[1] == '\0') {
	    /*
	     * We have an entity that is mapped to
	     * one valid eightbit latin1 char.
	     */
	    if (ti[UCH(*s8) - 160] >= UCH(lowest8) &&
		!(UCH(s7[0]) == ti[UCH(*s8) - 160] &&
		  s7[1] == '\0')) {
		/*
		 * ...which in turn is mapped, by our "new method",
		 * to another valid eightbit char for this new
		 * charset:  either to itself...
		 */
		if (ti[UCH(*s8) - 160] == UCH(*s8)) {
		    *p = s8;
		} else {
		    /*
		     * make those 1-char strings
		     * into HTAtoms, so they will be cleaned up
		     * at exit...  all for the sake of preventing
		     * memory leaks, sigh.
		     */
		    static char dummy[2];	/* one char dummy string */

		    dummy[0] = (char) ti[UCH(*s8) - 160];
		    *p = HTAtom_name(HTAtom_for(dummy));
		}
		changed = 1;
	    } else if (tp[UCH(*s8) - 160] &&
		       strcmp(s7, tp[UCH(*s8) - 160])) {
		/*
		 * ...or which is mapped, by our "new method",
		 * to a replacement string for this new charset.
		 */
		*p = tp[UCH(*s8) - 160];
		changed = 1;
	    }
	}
    }
    FREE(tp);
    FREE(ti);
    if (!changed) {
	FREE(prepl);
	return NULL;
    }
    return (STRING2PTR) prepl;
}

/*
 * "New method" meets "Old method" ...
 */
static int UC_Register_with_LYCharSets(int s,
				       const char *UC_MIMEcharset,
				       const char *UC_LYNXcharset,
				       int lowest_eightbit)
{
    int i, LYhndl, found;
    STRING2PTR repl;

    LYhndl = -1;
    if (LYNumCharsets == 0) {
	/*
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i + 1;
	}
    }

    /*
     * Search by MIME name, (LYchar_set_names may differ...)
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    LYhndl = i;
	}
    }

    if (LYhndl < 0) {		/* not found */
	found = 0;
	if (LYNumCharsets >= MAXCHARSETS) {
	    CTRACE((tfp,
		    "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
	    return ucError;
	}
	/*
	 * Add to LYCharSets.c lists.
	 */
	LYhndl = LYNumCharsets;
	LYNumCharsets++;
	LYlowest_eightbit[LYhndl] = 999;
	LYCharSets[LYhndl] = SevenBitApproximations;
	/*
	 * Hmm, try to be conservative here.
	 */
	LYchar_set_names[LYhndl] = UC_LYNXcharset;
	LYchar_set_names[LYhndl + 1] = NULL;
	/*
	 * Terminating NULL may be looked for by Lynx code.
	 */
    } else {
	found = 1;
    }
    LYCharSet_UC[LYhndl].UChndl = s;
    /*
     * Can we just copy the pointer?  Hope so...
     */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UCInfo[s].enc;
    LYCharSet_UC[LYhndl].codepage = UCInfo[s].codepage;

    /*
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
     */
    if (lowest_eightbit < LYlowest_eightbit[LYhndl]) {
	LYlowest_eightbit[LYhndl] = lowest_eightbit;
    } else if (lowest_eightbit > LYlowest_eightbit[LYhndl]) {
	UCInfo[s].lowest_eight = LYlowest_eightbit[LYhndl];
    }

    if (!found && LYhndl > 0) {
	repl = UC_setup_LYCharSets_repl(s, (unsigned) UCInfo[s].lowest_eight);
	if (repl) {
	    LYCharSets[LYhndl] = repl;
	    /*
	     * Remember to FREE at exit.
	     */
	    remember_allocated_LYCharSets[LYhndl] = repl;
	}
    }
    return LYhndl;
}

/*
 * This only sets up the structure - no initialization of the tables
 * is done here yet.
 */
void UC_Charset_Setup(const char *UC_MIMEcharset,
		      const char *UC_LYNXcharset,
		      const u8 * unicount,
		      const u16 * unitable,
		      int nnuni,
		      struct unimapdesc_str replacedesc,
		      int lowest_eight,
		      int UC_rawuni,
		      int codepage)
{
    int s, Gn;
    int i, status = 0, found;

    /*
     * Get (new?) slot.
     */
    found = -1;
    for (i = 0; i < UCNumCharsets && found < 0; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    found = i;
	}
    }
    if (found >= 0) {
	s = found;
    } else {
	if (UCNumCharsets >= MAXCHARSETS) {
	    CTRACE((tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
		    UC_MIMEcharset, UC_LYNXcharset));
	    return;
	}
	s = UCNumCharsets;
	UCInfo[s].MIMEname = UC_MIMEcharset;
    }
    UCInfo[s].LYNXname = UC_LYNXcharset;
    UCInfo[s].unicount = unicount;
    UCInfo[s].unitable = unitable;
    UCInfo[s].num_uni = nnuni;
    UCInfo[s].replacedesc = replacedesc;
    if (replacedesc.isdefault) {
	default_UChndl = s;
    }
    Gn = UC_FindGN_byMIME(UC_MIMEcharset);
    if (Gn >= 0)
	UC_GNhandles[Gn] = s;
    UCInfo[s].GN = Gn;
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;	/* cheat here */
    UCInfo[s].lowest_eight = lowest_eight;
    UCInfo[s].enc = UC_rawuni;
    UCInfo[s].codepage = codepage;
    UCInfo[s].LYhndl = UC_Register_with_LYCharSets(s,
						   UC_MIMEcharset,
						   UC_LYNXcharset,
						   lowest_eight);
    CTRACE2(TRACE_CFG, (tfp, "registered charset %d mime \"%s\" lynx \"%s\"\n",
			s, UC_MIMEcharset, UC_LYNXcharset));
    UCInfo[s].uc_status = status;
    if (found < 0)
	UCNumCharsets++;
    return;
}

/*
 * UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 * Alternative functions for adding character set info to the lists
 * kept in LYCharSets.c.
 *
 * These are for character sets without any real tables of their own.
 * We don't keep an entry in UCinfo[] for them.
 */
static int UC_NoUctb_Register_with_LYCharSets(const char *UC_MIMEcharset,
					      const char *UC_LYNXcharset,
					      int lowest_eightbit,
					      int UC_rawuni,
					      int codepage)
{
    int i, LYhndl = -1;

    if (LYNumCharsets == 0) {
	/*
	 * Initialize here; so whoever changes
	 * LYCharSets.c doesn't have to count...
	 */
	for (i = 0; (i < MAXCHARSETS) && LYchar_set_names[i]; i++) {
	    LYNumCharsets = i + 1;
	}
    }

    /*
     * Search by MIME name, (LYchar_set_names may differ...)
     * ignore if already present!
     */
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
	if (LYCharSet_UC[i].MIMEname &&
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    return ucError;
	}
    }

    /* not found */
    if (LYNumCharsets >= MAXCHARSETS) {
	CTRACE((tfp,
		"UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
		UC_MIMEcharset, UC_LYNXcharset));
	return ucError;
    }
    /*
     * Add to LYCharSets.c lists.
     */
    LYhndl = LYNumCharsets;
    LYNumCharsets++;
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl + 1] = NULL;
    /*
     * Terminating NULL may be looked for by Lynx code.
     */

    LYCharSet_UC[LYhndl].UChndl = -1;	/* no corresponding UChndl ! */
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UC_rawuni;
    LYCharSet_UC[LYhndl].codepage = codepage;

    /*
     * @@@@@@ We really SHOULD get more info from the table files,
     * and set relevant flags in the LYCharSet_UC[] entry with
     * that info...  For now, let's try it without.  - KW
     */

    return LYhndl;
}

/*
 * A wrapper for the previous function.
 */
static void UC_Charset_NoUctb_Setup(const char *UC_MIMEcharset,
				    const char *UC_LYNXcharset,
				    int trydefault,
				    int lowest_eight,
				    int UC_rawuni,
				    int codepage)
{
    int i;

    /*
     * Ignore completely if already in slot.
     */
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].MIMEname, UC_MIMEcharset)) {
	    return;
	}
    }
    if (UC_rawuni == UCT_ENC_UTF8)
	lowest_eight = 128;	/* cheat here */
    /* 'codepage' doubles as a flag for 'do not try any table
     * lookup, not even default' when negative.  The value will
     * be returned immediately by UCTrans* functions.
     */
    if (!trydefault && codepage == 0)
	codepage = ucCannotOutput;	/* if not already set; any negative should do. */
    UC_NoUctb_Register_with_LYCharSets(UC_MIMEcharset,
				       UC_LYNXcharset,
				       lowest_eight,
				       UC_rawuni,
				       codepage);
    return;
}

#ifdef LY_FIND_LEAKS
static void UCcleanup_mem(void)
{
    int i;

    UCfree_allocated_LYCharSets();
    con_clear_unimap_str(0);
    con_clear_unimap_str(1);
    con_clear_unimap(0);
    con_clear_unimap(1);
    for (i = 1; i < 4; i++) {	/* first one is static! */
	FREE(inverse_translations[i]);
    }
}
#endif /* LY_FIND_LEAKS */

#ifdef EXP_CHARTRANS_AUTOSWITCH
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
static int CpOrdinal(const unsigned UCode_t cp, const int other)
{
    char lyName[80];
    char myMimeName[80];
    char *mimeName, *mName = NULL, *lName = NULL;
    int s, i, exists = 0, ret;

    CTRACE((tfp, "CpOrdinal(cp=%lu, other=%d).\n", cp, other));
    sprintf(myMimeName, "auto%s-cp%lu", (other ? "2" : ""), cp);
    mimeName = myMimeName + 5 + (other != 0);
    sprintf(lyName, "AutoDetect%s (cp%lu)",
	    (other ? "-2" : ""), cp);
    /* Find slot. */
    s = -1;
    for (i = 0; i < UCNumCharsets; i++) {
	if (!strcmp(UCInfo[i].LYNXname, lyName))
	    return UCGetLYhndl_byMIME(myMimeName);
	else if (!strcasecomp(UCInfo[i].MIMEname, mimeName))
	    s = i;
    }
    if (s < 0)
	return ucError;
    /* Store the "real" charset info */
    real_charsets[other != 0] = UCGetLYhndl_byMIME(mimeName);
    /* Duplicate the record. */
    StrAllocCopy(mName, myMimeName);
    StrAllocCopy(lName, lyName);
    UC_Charset_Setup(mName, lName,
		     UCInfo[s].unicount, UCInfo[s].unitable,
		     UCInfo[s].num_uni, UCInfo[s].replacedesc,
		     UCInfo[s].lowest_eight, UCInfo[s].enc,
		     UCInfo[s].codepage);
    ret = UCGetLYhndl_byMIME(myMimeName);
    CTRACE((tfp, "Found %i.\n", ret));
    return ret;
}
#  endif /* __EMX__ */
#endif /* CAN_AUTODETECT_DISPLAY_CHARSET */
#endif /* EXP_CHARTRANS_AUTOSWITCH */

void UCInit(void)
{

    UCreset_allocated_LYCharSets();
#ifdef LY_FIND_LEAKS
    atexit(UCcleanup_mem);
#endif
    UCconsole_map_init();

    /*
     * The order of charset names visible in Lynx Options menu correspond to
     * the order of lines below, except the first two described in LYCharSet.c
     *
     * Entries whose comment is marked with *** are declared in UCdomap.h,
     * others are based on the included tables - UCdomap.c, near the top.
     */

    UC_CHARSET_SETUP_iso_8859_1;	/* ISO Latin 1          */
    UC_CHARSET_SETUP_iso_8859_15;	/* ISO 8859-15 (Latin 9) */
    UC_CHARSET_SETUP_cp850;	/* DosLatin1 (cp850)    */
    UC_CHARSET_SETUP_windows_1252;	/* WinLatin1 (cp1252)   */
    UC_CHARSET_SETUP_cp437;	/* DosLatinUS (cp437)   */

    UC_CHARSET_SETUP_dec_mcs;	/* DEC Multinational    */
    UC_CHARSET_SETUP_macintosh;	/* Macintosh (8 bit)    */
    UC_CHARSET_SETUP_next;	/* NeXT character set   */
    UC_CHARSET_SETUP_hp_roman8;	/* HP Roman8            */

    UC_CHARSET_SETUP_euc_cn;		  /*** Chinese		    */
    UC_CHARSET_SETUP_euc_jp;		  /*** Japanese (EUC_JP)    */
    UC_CHARSET_SETUP_shift_jis;		  /*** Japanese (Shift_JIS) */
    UC_CHARSET_SETUP_euc_kr;		  /*** Korean		    */
    UC_CHARSET_SETUP_big5;		  /*** Taipei (Big5)	    */

    UC_CHARSET_SETUP_viscii;	/* Vietnamese (VISCII)  */
    UC_CHARSET_SETUP;		/* us-ascii */ /* 7 bit approximations */

    UC_CHARSET_SETUP_x_transparent;	  /*** Transparent	  */

    UC_CHARSET_SETUP_iso_8859_2;	/* ISO Latin 2          */
    UC_CHARSET_SETUP_cp852;	/* DosLatin2 (cp852)    */
    UC_CHARSET_SETUP_windows_1250;	/* WinLatin2 (cp1250)   */

    UC_CHARSET_SETUP_iso_8859_3;	/* ISO Latin 3          */
    UC_CHARSET_SETUP_iso_8859_4;	/* ISO Latin 4          */
    UC_CHARSET_SETUP_iso_8859_13;	/* ISO 8859-13 Baltic Rim */
    UC_CHARSET_SETUP_cp775;	/* DosBaltRim (cp775)   */
    UC_CHARSET_SETUP_windows_1257;	/* WinBaltRim (cp1257)  */
    UC_CHARSET_SETUP_iso_8859_5;	/* ISO 8859-5 Cyrillic  */
    UC_CHARSET_SETUP_cp866;	/* DosCyrillic (cp866)  */
    UC_CHARSET_SETUP_windows_1251;	/* WinCyrillic (cp1251) */
    UC_CHARSET_SETUP_koi8_r;	/* KOI8-R Cyrillic      */
    UC_CHARSET_SETUP_iso_8859_6;	/* ISO 8869-6 Arabic    */
    UC_CHARSET_SETUP_cp864;	/* DosArabic (cp864)    */
    UC_CHARSET_SETUP_windows_1256;	/* WinArabic (cp1256)   */
    UC_CHARSET_SETUP_iso_8859_14;	/* ISO 8859-14 Celtic   */
    UC_CHARSET_SETUP_iso_8859_7;	/* ISO 8859-7 Greek     */
    UC_CHARSET_SETUP_cp737;	/* DosGreek (cp737)     */
    UC_CHARSET_SETUP_cp869;	/* DosGreek2 (cp869)    */
    UC_CHARSET_SETUP_windows_1253;	/* WinGreek (cp1253)    */
    UC_CHARSET_SETUP_iso_8859_8;	/* ISO 8859-8 Hebrew    */
    UC_CHARSET_SETUP_cp862;	/* DosHebrew (cp862)    */
    UC_CHARSET_SETUP_windows_1255;	/* WinHebrew (cp1255)   */
    UC_CHARSET_SETUP_iso_8859_9;	/* ISO 8859-9 (Latin 5) */
    UC_CHARSET_SETUP_cp857;	/* DosTurkish (cp857) */
    UC_CHARSET_SETUP_iso_8859_10;	/* ISO 8859-10 North European */

    UC_CHARSET_SETUP_utf_8;		  /*** UNICODE UTF-8	  */
    UC_CHARSET_SETUP_mnemonic_ascii_0;	/* RFC 1345 w/o Intro   */
    UC_CHARSET_SETUP_mnemonic;	/* RFC 1345 Mnemonic    */
    UC_CHARSET_SETUP_cp866u;	/* Ukrainian Cyrillic (866) */
    UC_CHARSET_SETUP_koi8_u;	/* Ukrainian Cyrillic (koi8-u) */
    UC_CHARSET_SETUP_ptcp154;	/* Cyrillic-Asian (PT154) */

#ifdef EXP_CHARTRANS_AUTOSWITCH
#ifdef CAN_AUTODETECT_DISPLAY_CHARSET
#  ifdef __EMX__
    {
	unsigned UCode_t lst[3];
	unsigned UCode_t len, rc;

	rc = DosQueryCp(sizeof(lst), lst, &len);
	if (rc == 0) {
	    if (len >= 1)
		auto_display_charset = CpOrdinal(lst[0], 0);
#    ifdef CAN_SWITCH_DISPLAY_CHARSET
	    if (len >= 3) {
		codepages[0] = lst[0];
		codepages[1] = (lst[0] == lst[1] ? lst[2] : lst[1]);
		auto_other_display_charset = CpOrdinal(codepages[1], 1);
	    }
#    endif
	} else {
	    CTRACE((tfp, "DosQueryCp() returned %#lx=%lu.\n", rc, rc));
	}
    }
#  endif
#endif
#endif

/*
 * To add synonyms for any charset name check function UCGetLYhndl_byMIME in
 * this file.
 */

/* for coding/performance - easy to type: */
    LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
    US_ASCII = UCGetLYhndl_byMIME("us-ascii");
    UTF8_handle = UCGetLYhndl_byMIME("utf-8");
    TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
}

/*
 * Safe variant of UCGetLYhndl_byMIME, with blind recovery from typo in user
 * input:  lynx.cfg, userdefs.h, command line switches.
 */
int safeUCGetLYhndl_byMIME(const char *value)
{
    int i = UCGetLYhndl_byMIME(value);

    if (i == -1) {		/* was user's typo or not yet recognized value */
	i = LATIN1;		/* error recovery? */
	CTRACE((tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n"));
    }

    return (i);
}

#ifdef USE_LOCALE_CHARSET

#if defined(USE_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET)
/*
 * This is a quick-and-dirty emulator of the nl_langinfo(CODESET)
 * function defined in the Single Unix Specification for those systems
 * (FreeBSD, etc.) that don't have one yet. It behaves as if it had
 * been called after setlocale(LC_CTYPE, ""), that is it looks at
 * the locale environment variables.
 *
 * http://www.opengroup.org/onlinepubs/7908799/xsh/langinfo.h.html
 *
 * Please extend it as needed and suggest improvements to the author.
 * This emulator will hopefully become redundant soon as
 * nl_langinfo(CODESET) becomes more widely implemented.
 *
 * Since the proposed Li18nux encoding name registry is still not mature,
 * the output follows the MIME registry where possible:
 *
 *   http://www.iana.org/assignments/character-sets
 *
 * A possible autoconf test for the availability of nl_langinfo(CODESET)
 * can be found in
 *
 *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#activate
 *
 * Markus.Kuhn@@cl.cam.ac.uk -- 2002-03-11
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 *
 * Latest version:
 *
 *   http://www.cl.cam.ac.uk/~mgk25/ucs/langinfo.c
 */

/*
#include "langinfo.h"
*/
typedef int nl_item;

#define CODESET 1

#define C_CODESET "US-ASCII"	/* Return this as the encoding of the
				 * C/POSIX locale. Could as well one day
				 * become "UTF-8". */

#define digit(x) ((x) >= '0' && (x) <= '9')

static char buf[16];

static char *nl_langinfo(nl_item item)
{
    char *l, *p;

    if (item != CODESET)
	return NULL;

    if (((l = LYGetEnv("LC_ALL")) != 0) ||
	((l = LYGetEnv("LC_CTYPE")) != 0) ||
	((l = LYGetEnv("LANG")) != 0)) {
	/* check standardized locales */
	if (!strcmp(l, "C") || !strcmp(l, "POSIX"))
	    return C_CODESET;
	/* check for encoding name fragment */
	if (strstr(l, "UTF") || strstr(l, "utf"))
	    return "UTF-8";
	if ((p = strstr(l, "8859-"))) {
	    memcpy(buf, "ISO-8859-\0\0", 12);
	    p += 5;
	    if (digit(*p)) {
		buf[9] = *p++;
		if (digit(*p))
		    buf[10] = *p++;
		return buf;
	    }
	}
	if (strstr(l, "KOI8-R"))
	    return "KOI8-R";
	if (strstr(l, "KOI8-U"))
	    return "KOI8-U";
	if (strstr(l, "620"))
	    return "TIS-620";
	if (strstr(l, "2312"))
	    return "GB2312";
	if (strstr(l, "HKSCS"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "Big5") || strstr(l, "BIG5"))
	    return "Big5";
	if (strstr(l, "GBK"))
	    return "GBK";	/* no MIME charset */
	if (strstr(l, "18030"))
	    return "GB18030";	/* no MIME charset */
	if (strstr(l, "Shift_JIS") || strstr(l, "SJIS"))
	    return "Shift_JIS";
	/* check for conclusive modifier */
	if (strstr(l, "euro"))
	    return "ISO-8859-15";
	/* check for language (and perhaps country) codes */
	if (strstr(l, "zh_TW"))
	    return "Big5";
	if (strstr(l, "zh_HK"))
	    return "Big5HKSCS";	/* no MIME charset */
	if (strstr(l, "zh"))
	    return "GB2312";
	if (strstr(l, "ja"))
	    return "EUC-JP";
	if (strstr(l, "ko"))
	    return "EUC-KR";
	if (strstr(l, "ru"))
	    return "KOI8-R";
	if (strstr(l, "uk"))
	    return "KOI8-U";
	if (strstr(l, "pl") || strstr(l, "hr") ||
	    strstr(l, "hu") || strstr(l, "cs") ||
	    strstr(l, "sk") || strstr(l, "sl"))
	    return "ISO-8859-2";
	if (strstr(l, "eo") || strstr(l, "mt"))
	    return "ISO-8859-3";
	if (strstr(l, "el"))
	    return "ISO-8859-7";
	if (strstr(l, "he"))
	    return "ISO-8859-8";
	if (strstr(l, "tr"))
	    return "ISO-8859-9";
	if (strstr(l, "th"))
	    return "TIS-620";	/* or ISO-8859-11 */
	if (strstr(l, "lt"))
	    return "ISO-8859-13";
	if (strstr(l, "cy"))
	    return "ISO-8859-14";
	if (strstr(l, "ro"))
	    return "ISO-8859-2";	/* or ISO-8859-16 */
	if (strstr(l, "am") || strstr(l, "vi"))
	    return "UTF-8";
	/* Send me further rules if you like, but don't forget that we are
	 * *only* interested in locale naming conventions on platforms
	 * that do not already provide an nl_langinfo(CODESET) implementation. */
	return "ISO-8859-1";	/* should perhaps be "UTF-8" instead */
    }
    return C_CODESET;
}
#endif /* defined(USE_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET) */

/*
 * If LYLocaleCharset is true, use the current locale to lookup a MIME name
 * that corresponds, and use that as the display charset.  This feature is
 * experimental because while nl_langinfo(CODESET) itself is standardized,
 * the return values and their relationship to the locale value is not.
 * GNU libiconv happens to give useful values, but other implementations are
 * not guaranteed to do this.
 *
 * Not all Linux versions provide useful information.  GNU libc 2.2 returns
 *	"ANSI_X3.4-1968"
 * whether locale is POSIX or en_US.UTF-8.
 *
 * Another possible thing to investigate is the locale_charset() function
 * provided in libiconv 1.5.1.
 */
void LYFindLocaleCharset(void)
{
    char *name;

    CTRACE((tfp, "LYFindLocaleCharset(%d)\n", LYLocaleCharset));
    name = nl_langinfo(CODESET);

    if (name != 0) {
	int value = UCGetLYhndl_byMIME(name);

	if (value >= 0) {
	    linedrawing_char_set = value;
	    CTRACE((tfp, "Found name \"%s\" -> %d\n", name, value));
	    /*
	     * If no locale was set, we will get the POSIX character set, which
	     * in Lynx is treated as US-ASCII.  However, Lynx's longstanding
	     * behavior has been to default to ISO-8859-1.  So we treat that
	     * encoding specially.  Otherwise, if LOCALE_CHARSET is set, then
	     * we will use the locale encoding -- unless overridden by the
	     * ASSUME_CHARSET value and/or command-line option.
	     */
	    if (LYLocaleCharset) {
		CTRACE((tfp, "...prior LocaleCharset '%s'\n", NonNull(UCAssume_MIMEcharset)));
		if (value == US_ASCII) {
		    CTRACE((tfp, "...prefer existing charset to ASCII\n"));
		} else if (assumed_charset) {
		    CTRACE((tfp, "...already assumed-charset\n"));
		} else {
		    current_char_set = linedrawing_char_set;
		    UCLYhndl_for_unspec = current_char_set;
		    StrAllocCopy(UCAssume_MIMEcharset, name);
		    CTRACE((tfp, "...using LocaleCharset '%s'\n", NonNull(UCAssume_MIMEcharset)));
		}
	    }
	} else {
	    CTRACE((tfp, "Cannot find a handle for MIME name \"%s\"\n", name));
	}
    } else {
	CTRACE((tfp, "Cannot find a MIME name for locale\n"));
    }
}
#endif /* USE_LOCALE_CHARSET */

BOOL UCScanCode(UCode_t *target, const char *source, BOOL isHex)
{
    BOOL status = FALSE;
    long lcode;
    char *endptr;

    errno = 0;
    *target = 0;
    lcode = strtol(source, &endptr, isHex ? 16 : 10);
    if (lcode >= 0
	&& (endptr > source)
#if defined(ERANGE) && defined(LONG_MAX) && defined(LONG_MIN)
	&& (errno != ERANGE || (lcode != LONG_MAX && lcode != LONG_MIN))
#else
	&& (endptr - source) < (isHex ? 8 : 10)
#endif
	&& (endptr != 0)
	&& (*endptr == '\0')) {
	*target = (UCode_t) lcode;
	status = TRUE;
    }
    return status;
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: UCdomap.c,v 1.76 2009/03/16 22:41:41 tom Exp $
d84 1
a84 1
/* #include <utf8_uni.h> *//* UNICODE UTF 8        */
d283 2
a284 2
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault);
static int con_insert_unipair_str(u16 unicode, const char *replace_str, int fordefault);
d289 1
a289 1
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list, int fordefault);
d291 1
a291 1
static int conv_uni_to_str(char *outbuf, int buflen, long ucs, int usedefault);
d296 1
a296 1
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned lowest8);
d321 2
a322 1
				       (unsigned char *) malloc(MAX_GLYPH));
d330 1
a330 1
	glyph = conv_uni_to_pc(p[j], 0);
d448 1
a448 1
static int con_insert_unipair(u16 unicode, u16 fontpos, int fordefault)
d450 2
a451 1
    int i, n;
d482 1
a482 1
    p2[unicode & 0x3f] = fontpos;
d487 1
a487 1
static int con_insert_unipair_str(u16 unicode, const char *replace_str,
d490 2
a491 1
    int i, n;
d681 1
a681 1
static int UC_con_set_unimap_str(u16 ct, struct unipair_str *list,
d769 1
a769 1
			   long ucs,
d811 1
a811 1
	strncpy(outbuf, h, (size_t) (buflen - 1));
d838 1
a838 1
int UCTransUniChar(long unicode,
d884 1
a884 1
	rc = conv_uni_to_pc(0xfffd, 0);
d887 1
a887 1
	rc = conv_uni_to_pc(0xfffd, 1);
d897 1
a897 1
		      long unicode,
d901 1
a901 1
    int rc = ucUnknown, src = 0, ignore_err;
d943 1
a943 1
	    ignore_err = UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
d981 1
a981 1
	    if (cd == (iconv_t) - 1) {
d988 1
a988 1
		if (cd == (iconv_t) - 1) {
d996 1
a996 1
	    if (cd != (iconv_t) - 1) {
d1002 2
a1003 1
			    "It seems to be a JIS X 0201 code(%ld). Not supported.\n", unicode));
d1021 1
a1021 1
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 0);
d1023 1
a1023 1
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 1);
d1029 1
a1029 1
	    rc = conv_uni_to_pc(0xfffd, 0);
d1031 1
a1031 1
	    rc = conv_uni_to_pc(0xfffd, 1);
d1082 1
a1082 1
int UCTransChar(char ch_in,
d1086 2
a1087 1
    int unicode, Gn;
d1143 1
a1143 1
	rc = conv_uni_to_pc(0xfffd, 0);
d1146 1
a1146 1
	rc = conv_uni_to_pc(0xfffd, 1);
d1152 3
a1154 3
long int UCTransJPToUni(char *inbuf,
			int buflen,
			int charset_in)
d1157 1
a1157 1
    size_t rc, ilen, olen;
d1166 1
a1166 1
    rc = iconv(cd, (ICONV_CONST char **) &pin, &ilen, &pout, &olen);
d1180 2
a1181 2
long int UCTransToUni(char ch_in,
		      int charset_in)
d1186 2
a1187 1
    int unicode, Gn;
d1200 1
a1200 1
	if (is8bits(ch_in)) {
d1206 1
a1206 1
	    need = utf8_length(TRUE, buffer);
d1224 1
a1224 1
	size_t rc, ilen, olen;
d1234 1
a1234 1
		    buffer[0] = ch_in;
d1240 1
a1240 1
		    buffer[1] = ch_in;
d1244 1
a1244 1
		    rc = iconv(cd, (ICONV_CONST char **) &pin, &ilen, &pout, &olen);
d1256 1
a1256 1
		    buffer[0] = ch_in;
d1262 1
a1262 1
		    buffer[1] = ch_in;
d1266 1
a1266 1
		    rc = iconv(cd, (ICONV_CONST char **) &pin, &ilen, &pout, &olen);
d1303 1
a1303 1
int UCReverseTransChar(char ch_out,
d1362 1
a1362 1
		   char ch_in,
d1367 3
a1369 2
    int unicode, Gn;
    int rc = ucUnknown, src = 0, ignore_err;
d1379 1
a1379 1
	outbuf[0] = ch_in;
d1434 1
a1434 1
	    ignore_err = UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
d1456 1
a1456 1
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 0);
d1458 1
a1458 1
	    rc = conv_uni_to_str(outbuf, buflen, 0xfffd, 1);
d1464 1
a1464 1
	    rc = conv_uni_to_pc(0xfffd, 0);
d1466 1
a1466 1
	    rc = conv_uni_to_pc(0xfffd, 1);
d1532 1
a1532 1
    if (!value || !(*value)) {
d1559 1
a1559 1
    if (!strncasecomp(value, "iso", 3) && !strncmp(value + 3, "8859", 4)) {
d1562 4
d1696 1
a1696 1
static const char **remember_allocated_LYCharSets[MAXCHARSETS];
d1720 2
a1721 2
static const char **UC_setup_LYCharSets_repl(int UC_charset_in_hndl,
					     unsigned lowest8)
d1723 1
a1723 1
    const char **ISO_Latin1 = LYCharSets[0];
d1818 1
a1818 1
		!(s7[0] == ti[UCH(*s8) - 160] &&
d1857 1
a1857 1
    return (const char **) prepl;
d1869 1
a1869 1
    const char **repl;
d2142 1
a2142 1
static int CpOrdinal(const unsigned long cp, const int other)
d2178 1
a2178 1
#  endif			/* __EMX__ */
d2217 1
a2217 1
    UC_CHARSET_SETUP;		/* us-ascii *//* 7 bit approximations */
d2260 2
a2261 2
	unsigned long lst[3];
	unsigned long len, rc;
a2470 1
    BOOL found = FALSE;
a2479 1
	    found = TRUE;
d2482 21
d2509 2
d2512 20
a2531 2
    if (found && LYLocaleCharset) {
	current_char_set = linedrawing_char_set;
d2533 1
a2534 1
#endif /* USE_LOCALE_CHARSET */
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d27 1
d30 2
d33 1
a33 1
#if defined(EXP_LOCALE_CHARSET) && defined(HAVE_LANGINFO_CODESET)
d95 3
a97 1
{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};
d100 3
a102 1
{-1, -1, -1, -1};
d463 1
a463 1
	    return -1;
d473 1
a473 1
	    return -1;
d504 1
a504 1
	    return -1;
d516 1
a516 1
	    return -1;
d649 1
a649 1
	return -1;
d723 1
a723 1
	return -1;
d728 1
a728 1
	return -2;
d741 1
a741 1
	    return -3;
d745 1
a745 1
	    return -3;
d758 1
a758 1
    return -4;
d787 1
a787 1
	return -1;
d792 1
a792 1
	return -2;
d797 1
a797 1
	    return -3;
d801 1
a801 1
	    return -3;
d815 1
a815 1
    return -4;
d844 11
a854 4
	if (LYCharSet_UC[charset_out].codepage < 0)
	    return (unicode < 128) ? (int) unicode : LYCharSet_UC[charset_out].codepage;
	if ((UChndl_out = default_UChndl) < 0)
	    return -12;
d870 1
a870 1
	if (rc >= 0)
d872 1
d876 1
a876 1
	if (rc >= 0)
d878 1
d880 1
a880 1
    if (!isdefault && (rc == -4)) {
d883 1
a883 1
    if ((isdefault || trydefault) && (rc == -4)) {
d898 1
a898 1
    int rc = -14, src = 0, ignore_err;
d905 1
a905 1
	return -13;
d911 1
a911 1
	    return -12;
d945 1
a945 1
	    return (strlen(outbuf));
d957 2
a958 2
	if ((strcmp(LYCharSet_UC[charset_out].MIMEname, "shift_jis") == 0) ||
	    (strcmp(LYCharSet_UC[charset_out].MIMEname, "euc-jp") == 0)) {
d964 2
a965 2
	    str[0] = unicode >> 8;
	    str[1] = unicode & 0xFF;
d969 7
a975 1
	    pout = outbuf, outleft = buflen;
d978 30
a1007 12
	    FREE(tocode)
		rc = iconv(cd, &pin, &inleft, &pout, &outleft);
	    iconv_close(cd);
	    if ((pout - outbuf) == 3) {
		CTRACE((tfp,
			"It seems to be a JIS X 0201 code(%ld). Not supported.\n", unicode));
		pin = str;
		inleft = 2;
		pout = outbuf, outleft = buflen;
	    } else if (rc >= 0) {
		*pout = '\0';
		return (strlen(outbuf));
d1013 1
a1013 1
	    return (strlen(outbuf));
d1015 1
a1015 1
    if (rc == -4) {
d1018 1
a1018 1
	if ((rc == -4) && (isdefault || trydefault))
d1021 1
a1021 1
	    return (strlen(outbuf));
d1023 1
a1023 1
    if (chk_single_flag && src == -4) {
d1026 1
a1026 1
	if ((rc == -4) && (isdefault || trydefault))
d1035 1
a1035 1
    return -4;
d1083 1
a1083 1
    int rc = -4;
a1088 1
#ifndef UC_NO_SHORTCUTS
a1090 1
#endif /* UC_NO_SHORTCUTS */
d1092 1
a1092 1
	return -11;
d1094 1
a1094 1
	return -11;
d1099 1
a1099 1
	    return -12;
d1106 1
a1106 1
	return -11;
d1134 1
a1134 1
    if ((rc == -4) && (isdefault || trydefault)) {
d1137 1
a1137 1
    if ((rc == -4) && !isdefault) {
d1140 1
a1140 1
    if ((rc == -4) && (isdefault || trydefault)) {
d1158 1
a1158 1
    olen = buflen;
d1161 1
a1161 1
    rc = iconv(cd, &pin, &ilen, &pout, &olen);
d1166 1
a1166 1
    return -11;
d1170 5
d1178 3
d1182 1
a1182 1
    unsigned char ch_iu;
d1185 7
a1191 3
    ch_iu = UCH(ch_in);
#ifndef UC_NO_SHORTCUTS
    if (charset_in == LATIN1)
d1193 21
a1216 1
	static char buffer[3];
a1217 1
	static int inx = 0;
d1226 2
a1227 2
		if (IS_SJIS_HI1((unsigned char) ch_in) ||
		    IS_SJIS_HI2((unsigned char) ch_in)) {
d1230 1
a1230 1
		    return -11;
d1233 1
a1233 1
		if (IS_SJIS_LO((unsigned char) ch_in)) {
d1238 1
a1238 1
		    rc = iconv(cd, &pin, &ilen, &pout, &olen);
d1242 1
a1242 2
			return (((unsigned char) obuffer[0]) << 8)
			    + (unsigned char) obuffer[1];
d1249 1
a1249 1
		if (IS_EUC_HI((unsigned char) ch_in)) {
d1252 1
a1252 1
		    return -11;
d1255 1
a1255 1
		if (IS_EUC_LOX((unsigned char) ch_in)) {
d1260 1
a1260 1
		    rc = iconv(cd, &pin, &ilen, &pout, &olen);
d1264 1
a1264 2
			return (((unsigned char) obuffer[0]) << 8)
			    + (unsigned char) obuffer[1];
d1272 1
a1272 1
    if (UCH(ch_in) < 128 && UCH(ch_in) >= 32)
d1274 3
a1276 5
#endif /* UC_NO_SHORTCUTS */
    if (charset_in < 0)
	return -11;
    if (UCH(ch_in) < 32 &&
	LYCharSet_UC[charset_in].enc != UCT_ENC_8BIT_C0)
d1281 6
a1286 4
    if ((UChndl_in = LYCharSet_UC[charset_in].UChndl) < 0)
	return -11;
    if (!UCInfo[UChndl_in].num_uni)
	return -11;
d1292 1
a1292 1
    unicode = UC_translate[UCH(ch_in)];
d1302 1
a1302 1
    int rc = -1;
a1307 1
#ifndef UC_NO_SHORTCUTS
a1309 1
#endif /* UC_NO_SHORTCUTS */
d1311 1
a1311 1
	return -11;
d1313 1
a1313 1
	return -11;
d1315 1
a1315 1
	return -11;
d1317 1
a1317 1
	return -12;
d1322 1
a1322 1
	    return -12;
d1362 1
a1362 1
    int rc = -14, src = 0, ignore_err;
d1370 1
a1370 2
	return -13;
#ifndef UC_NO_SHORTCUTS
a1375 1
#endif /* UC_NO_SHORTCUTS */
d1377 1
a1377 1
	return -11;
d1379 1
a1379 1
	return -11;
d1381 1
a1381 1
	return -11;
d1386 1
a1386 1
	    return -12;
d1432 1
a1432 1
	    return (strlen(outbuf));
d1445 1
a1445 1
	    return (strlen(outbuf));
d1447 1
a1447 1
    if (rc == -4) {
d1450 1
a1450 1
	if ((rc == -4) && (isdefault || trydefault))
d1453 1
a1453 1
	    return (strlen(outbuf));
d1455 1
a1455 1
    if (chk_single_flag && src == -4) {
d1458 1
a1458 1
	if ((rc == -4) && (isdefault || trydefault))
d1470 1
a1470 1
    return -4;
d1482 1
a1482 1
    return -1;
d1501 1
a1501 1
    int result = -1;
d1528 1
a1528 1
	return -1;
d1552 3
d1556 2
a1557 1
    if (!strcasecomp(value, "x-euc-jp")) {
d1563 2
a1564 1
	(!strcasecomp(value, "x-sjis"))) {
d1611 5
d1663 1
a1663 1
    return -1;			/* returns -1 if no charset found by that MIME name */
d1672 1
a1672 1
 * We try to be conservative and only allocate new memory for this if needed. 
d1716 1
a1716 1
    char **tp;
d1727 1
a1727 1
    tp = (char **) malloc(96 * sizeof(char *));
d1772 1
a1772 1
		tp[k - 160] = (char *) list->replace_str;
d1825 1
a1825 1
		    dummy[0] = ti[UCH(*s8) - 160];
d1887 1
a1887 1
	    return -1;
d1927 1
a1927 1
	repl = UC_setup_LYCharSets_repl(s, UCInfo[s].lowest_eight);
d1997 2
d2038 1
a2038 1
	    return -1;
d2047 1
a2047 1
	return -1;
d2103 1
a2103 1
	codepage = -12;		/* if not already set; any negative should do. */
d2152 1
a2152 1
	return -1;
d2299 1
a2299 1
#ifdef EXP_LOCALE_CHARSET
d2301 1
a2301 1
#if defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET)
d2357 3
a2359 3
    if (((l = getenv("LC_ALL")) && *l) ||
	((l = getenv("LC_CTYPE")) && *l) ||
	((l = getenv("LANG")) && *l)) {
d2441 1
a2441 1
#endif /* defined(EXP_LOCALE_CHARSET) && !defined(HAVE_LANGINFO_CODESET) */
d2484 1
a2484 1
#endif /* EXP_LOCALE_CHARSET */
@


1.5
log
@add support for iso8859-13
@
text
@d32 4
d39 1
a39 1
 *  Include chartrans tables:
d41 1
a41 1
#include <cp1250_uni.h>		/* WinLatin2 (cp1250)	*/
d43 15
a57 14
#include <cp1252_uni.h>		/* WinLatin1 (cp1252)	*/
#include <cp1253_uni.h>		/* WinGreek (cp1253)	*/
#include <cp1255_uni.h>		/* WinHebrew (cp1255)	*/
#include <cp1256_uni.h>		/* WinArabic (cp1256)	*/
#include <cp1257_uni.h>		/* WinBaltRim (cp1257)	*/
#include <cp437_uni.h>		/* DosLatinUS (cp437)	*/
#include <cp737_uni.h>		/* DosGreek (cp737)	*/
#include <cp775_uni.h>		/* DosBaltRim (cp775)	*/
#include <cp850_uni.h>		/* DosLatin1 (cp850)	*/
#include <cp852_uni.h>		/* DosLatin2 (cp852)	*/
#include <cp862_uni.h>		/* DosHebrew (cp862)	*/
#include <cp864_uni.h>		/* DosArabic (cp864)	*/
#include <cp866_uni.h>		/* DosCyrillic (cp866)	*/
#include <cp869_uni.h>		/* DosGreek2 (cp869)	*/
d59 10
a68 10
#include <dmcs_uni.h>		/* DEC Multinational	*/
#include <hp_uni.h>		/* HP Roman8		*/
#include <iso01_uni.h>		/* ISO Latin 1		*/
#include <iso02_uni.h>		/* ISO Latin 2		*/
#include <iso03_uni.h>		/* ISO Latin 3		*/
#include <iso04_uni.h>		/* ISO Latin 4		*/
#include <iso05_uni.h>		/* ISO 8859-5 Cyrillic	*/
#include <iso06_uni.h>		/* ISO 8859-6 Arabic	*/
#include <iso07_uni.h>		/* ISO 8859-7 Greek	*/
#include <iso08_uni.h>		/* ISO 8859-8 Hebrew	*/
d70 11
a80 10
#include <iso10_uni.h>		/* ISO 8859-10		*/
#include <iso13_uni.h>		/* ISO 8859-13		*/
#include <iso15_uni.h>		/* ISO 8859-15 (Latin 9)*/
#include <koi8r_uni.h>		/* KOI8-R Cyrillic	*/
#include <mac_uni.h>		/* Macintosh (8 bit)	*/
#include <mnem2_suni.h>		/* RFC 1345 Mnemonic	*/
#include <next_uni.h>		/* NeXT character set	*/
#include <rfc_suni.h>		/* RFC 1345 w/o Intro	*/
/* #include <utf8_uni.h> */     /* UNICODE UTF 8        */
#include <viscii_uni.h>		/* Vietnamese (VISCII)	*/
d89 2
a90 2
CONST char *UC_GNsetMIMEnames[4] =
	{"iso-8859-1", "x-dec-graphics", "cp437", "x-transparent"};
d92 2
a93 1
int UC_GNhandles[4] = {-1, -1, -1, -1};
d96 158
a253 157
 *  Some of the code below, and some of the comments, are left in for
 *  historical reasons.  Not all those tables below are currently
 *  really needed (and what with all those hardwired codepoints),
 *  but let's keep them around for now.  They may come in handy if we
 *  decide to make more extended use of the mechanisms (including e.g.
 *  for chars < 127...).  - KW
 */

PRIVATE u16 translations[][256] = {
  /*
   *  8-bit Latin-1 mapped to Unicode -- trivial mapping.
   */
  {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
  },
  /*
   *  VT100 graphics mapped to Unicode.
   */
  {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
    0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
    0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
    0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
    0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
  },
  /*
   *  IBM Codepage 437 mapped to Unicode.
   */
  {
    0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
    0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
    0x25ba, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
    0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
    0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
    0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
    0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
    0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
    0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
    0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
    0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
    0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
    0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
    0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
    0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
    0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
    0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
    0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
    0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
  },
  /*
   *  User mapping -- default to codes for direct font mapping.
   */
  {
    0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
    0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
    0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
    0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
    0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
    0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
    0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
    0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
    0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
    0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
    0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
    0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
    0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
    0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
    0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
    0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
    0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
    0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
    0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
    0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
    0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
    0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
    0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
    0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
    0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
    0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
    0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
    0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
    0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
    0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
    0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
    0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
  }
d255 1
a255 1
PRIVATE u16 *UC_translate = NULL;
d257 1
a257 1
PRIVATE struct UC_charset UCInfo[MAXCHARSETS];
d260 2
a261 2
 *  The standard kernel character-to-font mappings are not invertible
 *  -- this is just a best effort.
d265 28
a292 57
PRIVATE unsigned char * inv_translate = NULL;
PRIVATE unsigned char inv_norm_transl[MAX_GLYPH];
PRIVATE unsigned char * inverse_translations[4] = { NULL, NULL, NULL, NULL };

PRIVATE void set_inverse_transl PARAMS((
	int		i));
PRIVATE u16 *set_translate PARAMS((
	int		m));
PRIVATE int UC_valid_UC_charset PARAMS((
	int		UC_charset_hndl));
PRIVATE void UC_con_set_trans PARAMS((
	int		UC_charset_in_hndl,
	int		Gn,
	int		update_flag));
PRIVATE int con_insert_unipair PARAMS((
	u16		unicode,
	u16		fontpos,
	int		fordefault));
PRIVATE int con_insert_unipair_str PARAMS((
	u16		unicode,
	CONST char *	replace_str,
	int		fordefault));
PRIVATE void con_clear_unimap PARAMS((
	int		fordefault));
PRIVATE void con_clear_unimap_str PARAMS((
	int		fordefault));
PRIVATE void con_set_default_unimap NOPARAMS;
PRIVATE int UC_con_set_unimap PARAMS((
	int		UC_charset_out_hndl,
	int		update_flag));
PRIVATE int UC_con_set_unimap_str PARAMS((
	u16			ct,
	struct unipair_str *	list,
	int			fordefault));
PRIVATE int conv_uni_to_pc PARAMS((
	long			ucs,
	int			usedefault));
PRIVATE int conv_uni_to_str PARAMS((
	char*		outbuf,
	int		buflen,
	long		ucs,
	int		usedefault));
PRIVATE void UCconsole_map_init NOPARAMS;
PRIVATE int UC_MapGN PARAMS((
	int		UChndl,
	int		update_flag));
PRIVATE int UC_FindGN_byMIME PARAMS((
	CONST char *	UC_MIMEcharset));
PRIVATE void UCreset_allocated_LYCharSets NOPARAMS;
PRIVATE CONST char ** UC_setup_LYCharSets_repl PARAMS((
	int		UC_charset_in_hndl,
	unsigned	lowest8));
PRIVATE int UC_Register_with_LYCharSets PARAMS((
	int		s,
	CONST char *	UC_MIMEcharset,
	CONST char *	UC_LYNXcharset,
	int		lowest_eightbit));
d294 2
a295 2
PRIVATE void UCfree_allocated_LYCharSets NOPARAMS;
PRIVATE void UCcleanup_mem NOPARAMS;
d298 1
a298 1
PRIVATE int default_UChndl = -1;
d300 1
a300 2
PRIVATE void set_inverse_transl ARGS1(
	int,		i)
d308 1
a308 1
	 *  Slightly messy to avoid calling kmalloc too early.
d312 1
a312 1
				       (unsigned char *)malloc(MAX_GLYPH));
d323 1
a323 1
	     *	Prefer '-' above SHY etc.
d330 1
a330 2
PRIVATE u16 *set_translate ARGS1(
	int,		m)
d332 4
a335 4
	if (!inverse_translations[m])
		set_inverse_transl(m);
	inv_translate = inverse_translations[m];
	return translations[m];
d338 1
a338 2
PRIVATE int UC_valid_UC_charset ARGS1(
	int,		UC_charset_hndl)
d340 1
a340 1
  return (UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets);
d343 3
a345 4
PRIVATE void UC_con_set_trans ARGS3(
	int,		UC_charset_in_hndl,
	int,		Gn,
	int,		update_flag)
d348 1
a348 1
    CONST u16 *p;
d353 1
a353 1
		    UC_charset_in_hndl));
d359 1
a359 1
    if (p == UC_current_unitable) {    /* test whether pointers are equal */
d363 1
a363 1
     *	The font is always 256 characters - so far.
d378 1
a378 1
	set_inverse_transl(Gn); /* Update inverse translation for this one */
d391 2
a392 2
PRIVATE int hashtable_contents_valid = 0; /* Use ASCII-only mode for bootup*/
PRIVATE int hashtable_str_contents_valid = 0;
d394 1
a394 1
PRIVATE u16 **uni_pagedir[32] =
d396 4
a399 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d402 1
a402 1
PRIVATE char* **uni_pagedir_str[32] =
d404 4
a407 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d410 2
a411 2
PRIVATE CONST u16 * UC_current_unitable = NULL;
PRIVATE struct unimapdesc_str *UC_current_unitable_str = NULL;
d414 2
a415 2
 *  Keep a second set of structures for the translation designated
 *  as "default" - kw
d417 2
a418 2
PRIVATE int unidefault_contents_valid = 0; /* Use ASCII-only mode for bootup*/
PRIVATE int unidefault_str_contents_valid = 0;
d422 4
a425 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d427 1
a427 1
static char* **unidefault_pagedir_str[32] =
d429 4
a432 4
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d435 2
a436 2
PRIVATE CONST u16 * UC_default_unitable = 0;
PRIVATE CONST struct unimapdesc_str *UC_default_unitable_str = 0;
d438 1
a438 4
PRIVATE int con_insert_unipair ARGS3(
	u16,		unicode,
	u16,		fontpos,
	int,		fordefault)
d443 1
a443 1
    if(fordefault)
d448 1
a448 1
	p1 = (u16* *)malloc(32*sizeof(u16 *));
d453 1
a453 1
	if ( !p1 )
d462 1
a462 1
	p2 = p1[n] = (u16 *)malloc(64*sizeof(u16));
d467 1
a467 1
	    p2[i] = 0xffff;		/* No glyph for this character (yet) */
d476 2
a477 4
PRIVATE int con_insert_unipair_str ARGS3(
	u16,		unicode,
	CONST char *,	replace_str,
	int,		fordefault)
d481 1
a481 1
    CONST char **p2;
d483 1
a483 1
    if(fordefault)
d488 2
a489 1
	p1 = (char** *)malloc(32*sizeof(char **));
d494 1
a494 1
	if ( !p1 )
d504 2
a505 1
	p1[n] = (char **)malloc(64*sizeof(char *));
d509 1
a509 1
	p2 = (CONST char **)p1[n];
d514 1
a514 1
    p2 = (CONST char **)p1[n];
d522 1
a522 1
 *  ui arg was a leftover, deleted. - KW
d524 1
a524 2
PRIVATE void con_clear_unimap ARGS1(
	int,		fordefault)
d556 1
a556 1
PRIVATE void con_clear_unimap_str ARGS1(int, fordefault)
d558 2
a559 2
  int i, j;
  char ***p1;
d561 7
a567 5
  if (fordefault) {
    for (i = 0; i < 32; i++) {
	if ((p1 = unidefault_pagedir_str[i]) != NULL) {
	    for (j = 0; j < 32; j++) {
		FREE(p1[j]);
d569 1
a569 1
	    FREE(p1);
a570 2
      unidefault_pagedir_str[i] = NULL;
    }
d572 8
a579 6
    unidefault_str_contents_valid = 1;	/* ??? probably no use... */
  } else {
    for (i = 0; i < 32; i++) {
	if ((p1 = uni_pagedir_str[i]) != NULL) {
	    for (j = 0; j < 32; j++) {
		FREE(p1[j]);
d581 1
a581 1
	    FREE(p1);
d583 2
a584 1
      uni_pagedir_str[i] = NULL;
a585 3

    hashtable_str_contents_valid = 1;  /* ??? probably no use... */
  }
d589 4
a592 4
 *  Loads the unimap for the hardware font, as defined in uni_hash.tbl.
 *  The representation used was the most compact I could come up
 *  with.  This routine is executed at sys_setup time, and when the
 *  PIO_FONTRESET ioctl is called.
d594 1
a594 1
PRIVATE void con_set_default_unimap NOARGS
d597 1
a597 1
    CONST u16 *p;
d600 1
a600 1
     *	The default font is always 256 characters.
d607 1
a607 1
	    con_insert_unipair(*(p++), (u16)i, 1);
d618 12
a629 1
PUBLIC int UCNumCharsets = 0;
d631 2
a632 15
PUBLIC int UCLYhndl_HTFile_for_unspec = -1;
PUBLIC int UCLYhndl_HTFile_for_unrec = -1;
PUBLIC int UCLYhndl_for_unspec = -1;
PUBLIC int UCLYhndl_for_unrec = -1;

 /* easy to type, will initialize later */
PUBLIC int LATIN1 = -1;        /* UCGetLYhndl_byMIME("iso-8859-1") */
PUBLIC int US_ASCII = -1;      /* UCGetLYhndl_byMIME("us-ascii")   */
PUBLIC int UTF8_handle = -1;   /* UCGetLYhndl_byMIME("utf-8")      */
PUBLIC int TRANSPARENT = -1;   /* UCGetLYhndl_byMIME("x-transparent")  */


PRIVATE int UC_con_set_unimap ARGS2(
	int,		UC_charset_out_hndl,
	int,		update_flag)
d635 1
a635 1
    CONST u16 *p;
d639 1
a639 1
		    UC_charset_out_hndl));
d644 2
a645 2
    if (p == UC_current_unitable) {    /* test whether pointers are equal */
	return update_flag;			/* nothing to be done */
d650 1
a650 1
     *	The font is always 256 characters - so far.
d656 1
a656 1
	    con_insert_unipair(*(p++), (u16)i, 0);
d669 2
a670 4
PRIVATE int UC_con_set_unimap_str ARGS3(
	u16,		ct,
	struct unipair_str *, list,
	int,		fordefault)
d684 1
a684 1
     *	No inverse translations for replacement strings!
d696 2
a697 3
PRIVATE int conv_uni_to_pc ARGS2(
	long,		ucs,
	int,		usedefault)
d703 1
a703 1
     *	Only 16-bit codes supported at this time.
d707 1
a707 1
	 *  U+FFFD: REPLACEMENT CHARACTER.
d712 1
a712 1
	 *  Not a printable character.
d717 1
a717 1
	 *  Zero-width space.
d722 4
a725 4
	 *  UNI_DIRECT_BASE indicates the start of the region in the
	 *  User Zone which always has a 1:1 mapping to the currently
	 *  loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 *  of the region.
d747 1
a747 1
     *	Not found.
d753 1
a753 1
 *  Note: contents of outbuf is not changes for negative return value!
d755 4
a758 5
PRIVATE int conv_uni_to_str ARGS4(
	char*,		outbuf,
	int,		buflen,
	long,		ucs,
	int,		usedefault)
d764 1
a764 1
     *	Only 16-bit codes supported at this time.
d768 1
a768 1
	 *  U+FFFD: REPLACEMENT CHARACTER.
d771 3
a773 3
    /*
     *	Maybe the following two cases should be allowed here?? - KW
     */
d776 1
a776 1
	 *  Not a printable character.
d781 1
a781 1
	 *  Zero-width space.
d799 2
a800 2
	strncpy (outbuf,h,(size_t) (buflen-1));
	return 1;     /* ok ! */
d804 1
a804 1
     *	Not found.
d809 1
a809 1
PUBLIC int UCInitialized = 0;
d812 1
a812 1
 *  [ original comment: - KW ]
d817 1
a817 1
PRIVATE void UCconsole_map_init NOARGS
d824 1
a824 1
 *  OK now, finally, some stuff that is more specifically for Lynx: - KW
d826 2
a827 3
PUBLIC int UCTransUniChar ARGS2(
	long,		unicode,
	int,		charset_out)
d832 1
a832 1
    CONST u16 * ut;
d836 1
a836 1
	    return (unicode < 128) ? (int)unicode : LYCharSet_UC[charset_out].codepage;
d872 1
a872 1
 *  Returns string length, or negative value for error.
d874 5
a878 6
PUBLIC int UCTransUniCharStr ARGS5(
	char *,		outbuf,
	int,		buflen,
	long,		unicode,
	int,		charset_out,
	int,		chk_single_flag)
d883 2
a884 2
    struct unimapdesc_str * repl;
    CONST u16 * ut;
d912 1
a912 1
	    outbuf[0] = (char)src;
d920 1
a920 1
	if (repl != UC_current_unitable_str)  {
d932 1
a932 1
	    outbuf[0] = (char)src;
d938 31
d987 1
a987 1
	    outbuf[0] = (char)rc;
d996 1
a996 1
PRIVATE int UC_lastautoGN = 0;
d998 2
a999 3
PRIVATE int UC_MapGN ARGS2(
	int,		UChndl,
	int,		update_flag)
d1002 1
d1031 2
a1032 2
		Gn, UChndl, UCInfo[UChndl].MIMEname));
    UC_con_set_trans(UChndl,Gn,update_flag);
d1036 3
a1038 4
PUBLIC int UCTransChar ARGS3(
	char,		ch_in,
	int,		charset_in,
	int,		charset_out)
d1044 1
a1044 1
    CONST u16 * ut;
d1068 1
a1068 1
	Gn = UC_MapGN(UChndl_in,0);
d1106 23
a1128 7
PUBLIC long int UCTransToUni ARGS2(
	char,		ch_in,
	int,		charset_in)
{
  int unicode, Gn;
  unsigned char ch_iu;
  int UChndl_in;
d1130 8
a1137 1
  ch_iu = UCH(ch_in);
d1141 62
d1211 1
a1211 1
	 *  Don't translate C0 chars except for specific charsets.
d1219 1
a1219 1
	Gn = UC_MapGN(UChndl_in,1);
d1222 2
a1223 2
  UC_translate = set_translate(Gn);
  unicode = UC_translate[UCH(ch_in)];
d1225 1
a1225 1
  return unicode;
d1228 3
a1230 4
PUBLIC int UCReverseTransChar ARGS3(
	char,		ch_out,
	int,		charset_in,
	int,		charset_out)
d1237 1
a1237 1
    CONST u16 * ut;
d1263 4
a1266 4
	 *  Try to use the inverse table if charset_out is not equivalent
	 *  to using just the default table.  If it is, it should have
	 *  just ASCII chars and trying to back-translate those should
	 *  not give anything but themselves. - kw
d1271 1
a1271 1
		Gn = UC_MapGN(UChndl_in,1);
d1285 1
a1285 1
 *  Returns string length, or negative value for error.
d1287 6
a1292 7
PUBLIC int UCTransCharStr ARGS6(
	char *,		outbuf,
	int,		buflen,
	char,		ch_in,
	int,		charset_in,
	int,		charset_out,
	int,		chk_single_flag)
d1298 2
a1299 2
    struct unimapdesc_str * repl;
    CONST u16 * ut;
d1339 2
a1340 1
		if (upd) set_inverse_transl(Gn);
d1352 1
a1352 1
	    outbuf[0] = (char)src;
d1372 1
a1372 1
	    outbuf[0] = (char)src;
d1396 1
a1396 1
	    outbuf[0] = (char)rc;
d1408 1
a1408 2
PRIVATE int UC_FindGN_byMIME ARGS1(
	CONST char *,	UC_MIMEcharset)
d1410 1
a1410 1
  int i;
d1413 2
a1414 2
	if (!strcmp(UC_MIMEcharset,UC_GNsetMIMEnames[i])) {
      return i;
d1417 1
a1417 1
  return -1;
d1420 1
a1420 2
PUBLIC int UCGetRawUniMode_byLYhndl ARGS1(
	int,		i)
d1424 1
a1424 1
  return LYCharSet_UC[i].enc;
d1432 2
a1433 3
PRIVATE int getLYhndl_byCP ARGS2(
	CONST char *,	prefix,
	CONST char *,	codepage)
d1440 1
d1451 3
a1453 3
 *  Get Lynx internal charset handler from MIME name,
 *  return -1 if we got NULL or did not recognize value.
 *  According to RFC, MIME headers should match case-insensitively.
d1455 1
a1455 2
PUBLIC int UCGetLYhndl_byMIME ARGS1(
	CONST char *,	value)
d1461 2
a1462 1
	CTRACE((tfp, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n"));
d1470 1
a1470 1
	   !strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
d1561 1
a1561 1
	if ((LYhndl = getLYhndl_byCP("cp", value+3)) >= 0)
d1578 2
a1579 2
    if (!strcasecomp(value, "koi-8")) { /* accentsoft bugosity */
      return UCGetLYhndl_byMIME("koi8-r");
d1582 3
d1588 1
a1588 1
    return -1;	/* returns -1 if no charset found by that MIME name */
d1592 4
a1595 4
 *  Function UC_setup_LYCharSets_repl() tries to set up a subtable in
 *  LYCharSets[] appropriate for this new charset, for compatibility
 *  with the "old method".  Maybe not nice (maybe not even necessary
 *  any more), but it works (as far as it goes..).
d1597 8
a1604 9
 *  We try to be conservative and only allocate new memory for this
 *  if needed.	If not needed, just point to SevenBitApproximations[i].
 *  [Could do the same for ISO_Latin1[] if it's identical to that, but
 *   would make it even *more* messy than it already is...]
 *  This the only function in this file that knows, or cares, about the
 *  HTMLDTD or details of LYCharSets[] subtables (and therefore somewhat
 *  violates the idea that this file should be independent of those).
 *  As in other places, we rely on ISO_Latin1 being the *first* table
 *  in LYCharSets. - KW
d1608 1
a1608 1
 *  We need to remember which ones were allocated and which are static.
d1610 1
a1610 1
PRIVATE CONST char ** remember_allocated_LYCharSets[MAXCHARSETS];
d1612 1
a1612 1
PRIVATE void UCreset_allocated_LYCharSets NOARGS
d1622 1
a1622 1
PRIVATE void UCfree_allocated_LYCharSets NOARGS
d1634 2
a1635 3
PRIVATE CONST char ** UC_setup_LYCharSets_repl ARGS2(
	int,		UC_charset_in_hndl,
	unsigned,	lowest8)
d1637 2
a1638 2
    CONST char **ISO_Latin1 = LYCharSets[0];
    CONST char **p;
d1640 1
a1640 1
    CONST u16 *pp;
d1642 2
a1643 2
    CONST char *s7;
    CONST char *s8;
d1650 1
a1650 1
     *	Create a temporary table for reverse lookup of latin1 codes:
d1652 2
a1653 1
    tp = (char **)malloc(96 * sizeof(char *));
d1658 1
a1658 1
    ti = (u8 *)malloc(96 * sizeof(u8));
d1669 3
a1671 3
     *	Determine if we have any mapping of a Unicode in the range 160-255
     *	to an allowed code point > 0x80 in our new charset...
     *	Store any mappings found in ti[].
d1677 1
a1677 1
		   ti[k-160] = UCH(i);
d1684 1
a1684 2
    }
    {
d1689 3
a1691 3
	 *  Determine if we have any mapping of a Unicode in the range
	 *  160-255 to a replacement string for our new charset...
	 *  Store any mappings found in tp[].
d1697 1
a1697 1
		tp[k-160] = (char *)list->replace_str;
d1703 6
a1708 4
     *	Now allocate a new table compatible with LYCharSets[]
     *	and with the HTMLDTD for entities.
     *	We don't know yet whether we'll keep it around. */
    prepl = (char **)malloc(HTML_dtd.number_of_entities * sizeof(char *));
d1715 1
a1715 1
    p = (CONST char **)prepl;
d1719 3
a1721 3
	 *  For each of those entities, we check what the "old method"
	 *  ISO_Latin1[] mapping does with them.  If it is nothing we
	 *  want to use, just point to the SevenBitApproximations[] string.
d1728 2
a1729 2
	     *	We have an entity that is mapped to
	     *	one valid eightbit latin1 char.
d1733 1
a1733 1
		s7[1] == '\0')) {
d1735 3
a1737 3
		 *  ...which in turn is mapped, by our "new method",
		 *   to another valid eightbit char for this new
		 *   charset: either to itself...
d1743 4
a1746 4
		     *	make those 1-char strings
		     *	into HTAtoms, so they will be cleaned up
		     *	at exit... all for the sake of preventing
		     *	memory leaks, sigh.
d1757 2
a1758 2
		 *  ...or which is mapped, by our "new method",
		 *  to a replacement string for this new charset.
d1771 1
a1771 1
    return (CONST char **)prepl;
d1775 1
a1775 1
 *  "New method" meets "Old method" ...
d1777 4
a1780 5
PRIVATE int UC_Register_with_LYCharSets ARGS4(
	int,		s,
	CONST char *,	UC_MIMEcharset,
	CONST char *,	UC_LYNXcharset,
	int,		lowest_eightbit)
d1783 1
a1783 1
    CONST char **repl;
d1788 2
a1789 2
	 *  Initialize here; so whoever changes
	 *  LYCharSets.c doesn't have to count...
d1792 1
a1792 1
	    LYNumCharsets = i+1;
d1797 1
a1797 1
     *	Search by MIME name, (LYchar_set_names may differ...)
d1809 3
a1811 2
	    CTRACE((tfp, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset));
d1815 1
a1815 1
	 *  Add to LYCharSets.c lists.
d1818 1
a1818 1
	LYNumCharsets ++;
d1822 1
a1822 1
	 *  Hmm, try to be conservative here.
d1825 1
a1825 1
	LYchar_set_names[LYhndl+1] = NULL;
d1827 2
a1828 2
	*  Terminating NULL may be looked for by Lynx code.
	*/
d1834 1
a1834 1
     *	Can we just copy the pointer?  Hope so...
d1841 3
a1843 3
     *	@@@@@@ We really SHOULD get more info from the table files,
     *	and set relevant flags in the LYCharSet_UC[] entry with
     *	that info...  For now, let's try it without. - KW
d1852 1
a1852 1
	repl = UC_setup_LYCharSets_repl(s,UCInfo[s].lowest_eight);
d1856 1
a1856 1
	     *	Remember to FREE at exit.
d1865 1
a1865 1
 *  This only sets up the structure - no initialization of the tables
d1868 9
a1876 10
PUBLIC void UC_Charset_Setup ARGS9(
	CONST char *,		UC_MIMEcharset,
	CONST char *,		UC_LYNXcharset,
	CONST u8 *,		unicount,
	CONST u16 *,		unitable,
	int,			nnuni,
	struct unimapdesc_str,	replacedesc,
	int,			lowest_eight,
	int,			UC_rawuni,
	int,			codepage)
d1882 1
a1882 1
     *	Get (new?) slot.
d1895 1
a1895 1
			UC_MIMEcharset, UC_LYNXcharset));
d1914 1
a1914 1
	lowest_eight = 128;  /* cheat here */
d1929 12
a1940 12
 *  UC_NoUctb_Register_with_LYCharSets, UC_Charset_NoUctb_Setup -
 *  Alternative functions for adding character set info to the lists
 *  kept in LYCharSets.c.
 *  These are for character sets without any real tables of their own.
 *  We don't keep an entry in UCinfo[] for them.
 */
PRIVATE int UC_NoUctb_Register_with_LYCharSets ARGS5(
	CONST char *,	UC_MIMEcharset,
	CONST char *,	UC_LYNXcharset,
	int,		lowest_eightbit,
	int,			UC_rawuni,
	int,			codepage)
d1946 2
a1947 2
	 *  Initialize here; so whoever changes
	 *  LYCharSets.c doesn't have to count...
d1950 1
a1950 1
	    LYNumCharsets = i+1;
d1955 2
a1956 2
     *	Search by MIME name, (LYchar_set_names may differ...)
     *  ignore if already present!
d1967 3
a1969 2
	CTRACE((tfp, "UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
	       UC_MIMEcharset, UC_LYNXcharset));
d1973 2
a1974 2
	 *  Add to LYCharSets.c lists.
	 */
d1976 1
a1976 1
    LYNumCharsets ++;
d1980 1
a1980 1
    LYchar_set_names[LYhndl+1] = NULL;
d1982 1
a1982 1
     *  Terminating NULL may be looked for by Lynx code.
d1985 1
a1985 1
    LYCharSet_UC[LYhndl].UChndl = -1; /* no corresponding UChndl ! */
d1991 3
a1993 3
     *	@@@@@@ We really SHOULD get more info from the table files,
     *	and set relevant flags in the LYCharSet_UC[] entry with
     *	that info...  For now, let's try it without. - KW
d2000 1
a2000 1
 *  A wrapper for the previous function.
d2002 6
a2007 7
PRIVATE void UC_Charset_NoUctb_Setup ARGS6(
	CONST char *,		UC_MIMEcharset,
	CONST char *,		UC_LYNXcharset,
	int,			trydefault,
	int,			lowest_eight,
	int,			UC_rawuni,
	int,			codepage)
d2012 1
a2012 1
     *	Ignore completely if already in slot.
d2020 1
a2020 1
	lowest_eight = 128;  /* cheat here */
d2022 3
a2024 3
    ** lookup, not even default' when negative.  The value will
    ** be returned immediately by UCTrans* functions.
    */
d2026 1
a2026 1
	codepage = -12;	/* if not already set; any negative should do. */
d2036 1
a2036 1
PRIVATE void UCcleanup_mem NOARGS
d2051 1
d2054 1
a2054 1
PRIVATE int CpOrdinal ARGS2 (CONST unsigned long, cp, CONST int, other)
d2061 1
a2061 1
    CTRACE((tfp, "CpOrdinal(cp=%ul, other=%d).\n", cp, other));
d2090 1
a2090 1
#  endif /* __EMX__ */
d2092 1
d2094 1
a2094 1
PUBLIC void UCInit NOARGS
d2103 7
a2109 8
/*
 *  The order of charset names visible in Lynx Options menu
 *  correspond to the order of lines below,
 *  except the first two described in LYCharSet.c
 *
 *  Entries whose comment is marked with *** are declared in UCdomap.h,
 *  others are based on the included tables - UCdomap.c, near the top.
 */
d2111 10
a2120 10
    UC_CHARSET_SETUP_iso_8859_1;	  /* ISO Latin 1	  */
    UC_CHARSET_SETUP_iso_8859_15;	  /* ISO 8859-15 (Latin 9)*/
    UC_CHARSET_SETUP_cp850;		  /* DosLatin1 (cp850)	  */
    UC_CHARSET_SETUP_windows_1252;	  /* WinLatin1 (cp1252)   */
    UC_CHARSET_SETUP_cp437;		  /* DosLatinUS (cp437)   */

    UC_CHARSET_SETUP_dec_mcs;		  /* DEC Multinational	  */
    UC_CHARSET_SETUP_macintosh;		  /* Macintosh (8 bit)	  */
    UC_CHARSET_SETUP_next;		  /* NeXT character set   */
    UC_CHARSET_SETUP_hp_roman8;		  /* HP Roman8		  */
d2128 2
a2129 2
    UC_CHARSET_SETUP_viscii;		  /* Vietnamese (VISCII)  */
    UC_CHARSET_SETUP;	/* us-ascii */	  /* 7 bit approximations */
d2133 27
a2159 24
    UC_CHARSET_SETUP_iso_8859_2;	  /* ISO Latin 2	  */
    UC_CHARSET_SETUP_cp852;		  /* DosLatin2 (cp852)	  */
    UC_CHARSET_SETUP_windows_1250;	  /* WinLatin2 (cp1250)   */
    UC_CHARSET_SETUP_iso_8859_3;	  /* ISO Latin 3	  */
    UC_CHARSET_SETUP_iso_8859_4;	  /* ISO Latin 4	  */
    UC_CHARSET_SETUP_cp775;		  /* DosBaltRim (cp775)   */
    UC_CHARSET_SETUP_windows_1257;	  /* WinBaltRim (cp1257)  */
    UC_CHARSET_SETUP_iso_8859_5;	  /* ISO 8859-5 Cyrillic  */
    UC_CHARSET_SETUP_cp866;		  /* DosCyrillic (cp866)  */
    UC_CHARSET_SETUP_windows_1251;	  /* WinCyrillic (cp1251) */
    UC_CHARSET_SETUP_koi8_r;		  /* KOI8-R Cyrillic	  */
    UC_CHARSET_SETUP_iso_8859_6;	  /* ISO 8869-6 Arabic	  */
    UC_CHARSET_SETUP_cp864;		  /* DosArabic (cp864)	  */
    UC_CHARSET_SETUP_windows_1256;	  /* WinArabic (cp1256)   */
    UC_CHARSET_SETUP_iso_8859_7;	  /* ISO 8859-7 Greek	  */
    UC_CHARSET_SETUP_cp737;		  /* DosGreek (cp737)	  */
    UC_CHARSET_SETUP_cp869;		  /* DosGreek2 (cp869)	  */
    UC_CHARSET_SETUP_windows_1253;	  /* WinGreek (cp1253)	  */
    UC_CHARSET_SETUP_iso_8859_8;	  /* ISO 8859-8 Hebrew	  */
    UC_CHARSET_SETUP_cp862;		  /* DosHebrew (cp862)	  */
    UC_CHARSET_SETUP_windows_1255;	  /* WinHebrew (cp1255)   */
    UC_CHARSET_SETUP_iso_8859_9;	  /* ISO 8859-9 (Latin 5) */
    UC_CHARSET_SETUP_iso_8859_10;	  /* ISO 8859-10	  */
    UC_CHARSET_SETUP_iso_8859_13;	  /* ISO 8859-13	  */
d2162 5
a2166 5
    UC_CHARSET_SETUP_mnemonic_ascii_0;	  /* RFC 1345 w/o Intro   */
    UC_CHARSET_SETUP_mnemonic;		  /* RFC 1345 Mnemonic	  */
    UC_CHARSET_SETUP_cp866u;		  /* Ukrainian Cyrillic (866) */
    UC_CHARSET_SETUP_koi8_u;		  /* Ukrainian Cyrillic (koi8-u) */
    UC_CHARSET_SETUP_ptcp154;		  /* Cyrillic-Asian (PT154) */
d2168 1
d2192 1
d2195 2
a2196 2
 *  To add synonyms for any charset name
 *  check function UCGetLYhndl_byMIME in this file.
d2200 1
a2200 1
    LATIN1   = UCGetLYhndl_byMIME("iso-8859-1");
d2207 2
a2208 2
 *  Safe variant of UCGetLYhndl_byMIME, with blind recovery from typo
 *  in user input: lynx.cfg, userdefs.h, command line switches.
d2210 1
a2210 1
PUBLIC int safeUCGetLYhndl_byMIME ARGS1 (CONST char *, value)
d2214 2
a2215 2
    if (i == -1) {	/* was user's typo or not yet recognized value */
	i = LATIN1;	/* error recovery? */
d2219 1
a2219 1
    return(i);
d2262 1
d2265 3
a2267 3
#define C_CODESET "US-ASCII"     /* Return this as the encoding of the
				  * C/POSIX locale. Could as well one day
				  * become "UTF-8". */
d2273 1
a2273 1
PRIVATE char *nl_langinfo(nl_item item)
d2275 1
a2275 1
  char *l, *p;
d2277 2
a2278 2
  if (item != CODESET)
    return NULL;
d2280 83
a2362 55
  if (((l = getenv("LC_ALL"))   && *l) ||
      ((l = getenv("LC_CTYPE")) && *l) ||
      ((l = getenv("LANG"))     && *l)) {
    /* check standardized locales */
    if (!strcmp(l, "C") || !strcmp(l, "POSIX"))
      return C_CODESET;
    /* check for encoding name fragment */
    if (strstr(l, "UTF") || strstr(l, "utf"))
      return "UTF-8";
    if ((p = strstr(l, "8859-"))) {
      memcpy(buf, "ISO-8859-\0\0", 12);
      p += 5;
      if (digit(*p)) {
	buf[9] = *p++;
	if (digit(*p)) buf[10] = *p++;
	return buf;
      }
    }
    if (strstr(l, "KOI8-R")) return "KOI8-R";
    if (strstr(l, "KOI8-U")) return "KOI8-U";
    if (strstr(l, "620")) return "TIS-620";
    if (strstr(l, "2312")) return "GB2312";
    if (strstr(l, "HKSCS")) return "Big5HKSCS";   /* no MIME charset */
    if (strstr(l, "Big5") || strstr(l, "BIG5")) return "Big5";
    if (strstr(l, "GBK")) return "GBK";           /* no MIME charset */
    if (strstr(l, "18030")) return "GB18030";     /* no MIME charset */
    if (strstr(l, "Shift_JIS") || strstr(l, "SJIS")) return "Shift_JIS";
    /* check for conclusive modifier */
    if (strstr(l, "euro")) return "ISO-8859-15";
    /* check for language (and perhaps country) codes */
    if (strstr(l, "zh_TW")) return "Big5";
    if (strstr(l, "zh_HK")) return "Big5HKSCS";   /* no MIME charset */
    if (strstr(l, "zh")) return "GB2312";
    if (strstr(l, "ja")) return "EUC-JP";
    if (strstr(l, "ko")) return "EUC-KR";
    if (strstr(l, "ru")) return "KOI8-R";
    if (strstr(l, "uk")) return "KOI8-U";
    if (strstr(l, "pl") || strstr(l, "hr") ||
	strstr(l, "hu") || strstr(l, "cs") ||
	strstr(l, "sk") || strstr(l, "sl")) return "ISO-8859-2";
    if (strstr(l, "eo") || strstr(l, "mt")) return "ISO-8859-3";
    if (strstr(l, "el")) return "ISO-8859-7";
    if (strstr(l, "he")) return "ISO-8859-8";
    if (strstr(l, "tr")) return "ISO-8859-9";
    if (strstr(l, "th")) return "TIS-620";      /* or ISO-8859-11 */
    if (strstr(l, "lt")) return "ISO-8859-13";
    if (strstr(l, "cy")) return "ISO-8859-14";
    if (strstr(l, "ro")) return "ISO-8859-2";   /* or ISO-8859-16 */
    if (strstr(l, "am") || strstr(l, "vi")) return "UTF-8";
    /* Send me further rules if you like, but don't forget that we are
     * *only* interested in locale naming conventions on platforms
     * that do not already provide an nl_langinfo(CODESET) implementation. */
    return "ISO-8859-1"; /* should perhaps be "UTF-8" instead */
  }
  return C_CODESET;
d2381 1
a2381 1
PUBLIC void LYFindLocaleCharset NOARGS
d2383 3
d2387 9
a2395 10
    if (LYLocaleCharset) {
	char *name = nl_langinfo(CODESET);
	if (name != 0) {
	    int value = UCGetLYhndl_byMIME(name);
	    if (value >= 0) {
		current_char_set = value;
	    } else {
		CTRACE((tfp, "Cannot find a handle for MIME name \"%s\"\n", name));
		LYLocaleCharset = FALSE;
	    }
d2397 1
a2397 2
	    CTRACE((tfp, "Cannot find a MIME name for locale\n"));
	    LYLocaleCharset = FALSE;
d2399 6
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d66 1
d2078 1
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d28 4
d76 1
d82 5
d656 1
a656 1
PUBLIC int UTF8 = -1;          /* UCGetLYhndl_byMIME("utf-8")      */
d844 1
d1647 1
a1647 1
	if (s8 && UCH(*s8) >= 160 && strlen(s8) == 1) {
d2083 1
d2117 1
a2117 1
    UTF8     = UCGetLYhndl_byMIME("utf-8");
d2136 151
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a22 1
#include <UCkd.h>
d33 7
a39 7
#include <cp1250_uni.h> 	/* WinLatin2 (cp1250)	*/
#include <cp1251_uni.h> 	/* WinCyrillic (cp1251) */
#include <cp1252_uni.h> 	/* WinLatin1 (cp1252)	*/
#include <cp1253_uni.h> 	/* WinGreek (cp1253)	*/
#include <cp1255_uni.h> 	/* WinHebrew (cp1255)	*/
#include <cp1256_uni.h> 	/* WinArabic (cp1256)	*/
#include <cp1257_uni.h> 	/* WinBaltRim (cp1257)	*/
d65 1
a65 1
#include <mnem2_suni.h> 	/* RFC 1345 Mnemonic	*/
d69 1
a69 1
#include <viscii_uni.h> 	/* Vietnamese (VISCII)	*/
d72 4
a75 3
#ifdef NOTDEFINED
#include <mnem_suni.h>
#endif /* NOTDEFINED */
a253 7
#ifdef NOTDEFINED
PRIVATE unsigned char inverse_translate PARAMS((int glyph));
PRIVATE int con_set_trans_old PARAMS((unsigned char *arg));
PRIVATE int con_get_trans_old PARAMS((unsigned char *arg));
PRIVATE int con_set_trans_new PARAMS((u16 *arg));
PRIVATE int con_get_trans_new PARAMS((u16 *arg));
#endif /* NOTDEFINED */
a271 5
#ifdef NOTDEFINED
PRIVATE int con_set_unimap PARAMS((
	u16			ct,
	struct unipair *	list));
#endif /* NOTDEFINED */
a279 6
#ifdef NOTDEFINED
PRIVATE int con_get_unimap PARAMS((
	u16			ct,
	u16 *			uct,
	struct unipair *	list));
#endif /* NOTDEFINED */
d336 1
a336 1
	    q[glyph] = j;
a349 99
#ifdef NOTDEFINED
/*
 * Inverse translation is impossible for several reasons:
 * 1. The font<->character maps are not 1-1.
 * 2. The text may have been written while a different translation map
 *    was active, or using Unicode.
 * Still, it is now possible to a certain extent to cut and paste non-ASCII.
 */
PRIVATE unsigned char inverse_translate ARGS1(
	int,		glyph)
{
    if (glyph < 0 || glyph >= MAX_GLYPH) {
		return 0;
    } else {
	return ((inv_translate && inv_translate[glyph]) ?
				   inv_translate[glyph] :
				   (unsigned char)(glyph & 0xff));
    }
}

/*
 *  Load customizable translation table.
 *  'arg' points to a 256 byte translation table.
 *
 *  The "old" variants are for translation directly to font (using the
 *  0xf000-0xf0ff "transparent" Unicodes) whereas the "new" variants set
 *  Unicodes explicitly.
 */
PRIVATE int con_set_trans_old ARGS1(
	unsigned char *,	arg)
{
    int i;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_READ, (void *)arg, E_TABSZ);
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++)
	p[i] = UNI_DIRECT_BASE | (u16)arg[i];

    set_inverse_transl(USER_MAP);
    return 0;
}

PRIVATE int con_get_trans_old ARGS1(
	unsigned char *,	arg)
{
    int i, ch;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_WRITE, (void *)arg, E_TABSZ);
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++) {
	ch = conv_uni_to_pc(p[i]);
#ifdef NOTDEFINED
	put_user((ch & ~0xff) ? 0 : ch, arg+i);
#endif /* NOTDEFINED */
	arg[i] = (unsigned char)((ch & ~0xff) ? 0 : ch);
    }
    return 0;
}

PRIVATE int con_set_trans_new ARGS1(
	u16 *,		arg)
{
    int i;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_READ, (void *)arg, E_TABSZ*sizeof(u16));
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++)
	p[i] = arg[i];

    set_inverse_transl(USER_MAP);
    return 0;
}

PRIVATE int con_get_trans_new ARGS1(
	u16 *		arg)
{
    int i;
    u16 *p = translations[USER_MAP];
#if(0)
    i = verify_area(VERIFY_WRITE, (void *)arg, E_TABSZ*sizeof(u16));
    if (i)
	return i;
#endif
    for (i = 0; i < E_TABSZ; i++)
	arg[i] = p[i];

    return 0;
}
#endif /* NOTDEFINED */

d366 2
a367 2
	CTRACE(tfp, "UC_con_set_trans: Invalid charset handle %d.\n",
		    UC_charset_in_hndl);
a377 2
     *  (this function preserved by num_uni==0 so unicount=NULL for built-in
     *  charsets like CJK or x-transparent should not be a problem?)
d471 1
a471 1
	    return -ENOMEM;
d481 1
a481 1
	    return -ENOMEM;
d495 1
a495 1
	CONST char *, 	replace_str,
d513 1
a513 1
	    return -ENOMEM;
d524 1
a524 1
	    return -ENOMEM;
a605 21
#ifdef NOTDEFINED
PRIVATE int con_set_unimap ARGS2(
	u16,			ct,
	struct unipair *,	list)
{
    int err = 0, err1, i;

    while (ct--) {
	if ((err1 = con_insert_unipair(list->unicode, list->fontpos)) != 0) {
	    err = err1;
	}
	list++;
    }

    for (i = 0; i <= 3; i++) {
	set_inverse_transl(i); /* Update all inverse translations */
    }
    return err;
}
#endif /* NOTDEFINED */

a618 1
     *  (default font can not be a fake one, so unicout!=NULL for sure.)
d625 1
a625 1
	    con_insert_unipair(*(p++), i, 1);
a628 6
#if 0
    for (i = 0; i <= 3; i++) {
	set_inverse_transl(i);	/* Update all inverse translations */
    }
#endif

d647 1
d658 2
a659 2
	CTRACE(tfp, "UC_con_set_unimap: Invalid charset handle %d.\n",
		    UC_charset_out_hndl);
a670 1
     *  (fake 0 for built-in charsets like CJK or x-transparent, add a check)
d674 1
a674 1
    for (i = 0; i < 256 && UCInfo[UC_charset_out_hndl].unicount != NULL; i++) {
d676 1
a676 1
	    con_insert_unipair(*(p++), i, 0);
a717 33
#ifdef NOTDEFINED
PRIVATE int con_get_unimap ARGS3(
	u16,			ct,
	u16 *,			uct,
	struct unipair *,	list)
{
    int i, j, k, ect;
    u16 **p1, *p2;

    ect = 0;
    if (hashtable_contents_valid) {
	for (i = 0; i < 32; i++) {
	    if ((p1 = uni_pagedir[i]) != NULL) {
		for (j = 0; j < 32; j++) {
		    if ((p2 = *(p1++)) != NULL) {
			for (k = 0; k < 64; k++) {
			    if (*p2 < MAX_GLYPH && ect++ < ct) {
				list->unicode = (u16) ((i<<11)+(j<<6)+k);
				list->fontpos = (u16) *p2;
				list++;
			    }
			    p2++;
			}
		    }
		}
	    }
	}
    }
    *uct = ect;
    return ((ect <= ct) ? 0 : -ENOMEM);
}
#endif /* NOTDEFINED */

a807 10
#ifdef NOTDEFINED	/* We don't handle the following here: */
    } else if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE) {
	/*
	 *  UNI_DIRECT_BASE indicates the start of the region in the
	 *  User Zone which always has a 1:1 mapping to the currently
	 *  loaded font.  The UNI_DIRECT_MASK indicates the bit span
	 *  of the region.
	 */
	return ucs & UNI_DIRECT_MASK;
#endif /* NOTDEFINED */
d859 2
d899 1
a899 1
	char *, 	outbuf,
d915 2
d937 2
a938 1
	    outbuf[0] = src; outbuf[1] = '\0';
d957 2
a958 1
	    outbuf[0] = src; outbuf[1] = '\0';
d981 2
a982 1
	    outbuf[0] = rc; outbuf[1] = '\0';
d1024 2
a1025 2
    CTRACE(tfp, "UC_MapGN: Using %d <- %d (%s)\n",
		Gn, UChndl, UCInfo[UChndl].MIMEname);
d1044 1
a1044 1
	return (unsigned char)ch_in;
d1051 2
d1083 1
a1083 1
    unicode = UC_translate[(unsigned char)ch_in];
d1109 1
a1109 1
  ch_iu = (unsigned char)ch_in;
d1113 1
a1113 1
    if ((unsigned char)ch_in < 128 && (unsigned char)ch_in >= 32)
d1118 1
a1118 1
    if ((unsigned char)ch_in < 32 &&
d1133 1
a1133 1
  unicode = UC_translate[(unsigned char)ch_in];
d1144 1
a1144 1
    int rc;
d1147 1
a1147 1
    int i_ch = (unsigned char)ch_out;
d1152 1
a1152 1
	return ch_out;
d1163 2
d1181 1
a1181 7
	    if ((Gn = UCInfo[UChndl_in].GN) >= 0) {
		UC_translate = set_translate(Gn);
		rc = inv_translate[i_ch];
		if (rc >= 32) {
		    return rc;
		}
	    } else {
d1183 3
a1185 1
		UC_translate = set_translate(Gn);
d1187 2
a1188 3
		if (rc >= 32) {
		    return rc;
		}
d1199 1
a1199 1
	char *, 	outbuf,
d1230 2
d1245 1
a1245 1
    unicode = UC_translate[(unsigned char)ch_in];
d1263 2
a1264 1
	    outbuf[0] = src; outbuf[1] = '\0';
d1283 2
a1284 1
	    outbuf[0] = src; outbuf[1] = '\0';
d1307 2
a1308 1
	    outbuf[0] = rc; outbuf[1] = '\0';
d1341 23
d1375 1
a1375 1
	CTRACE(tfp, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n");
d1391 1
d1399 3
a1401 2
    if (!strncasecomp(value, "iso-2022-jp", 11) ||
	!strcasecomp(value, "x-euc-jp")) {
d1404 4
a1407 1
    if (!strcasecomp(value, "x-shift-jis")) {
d1410 2
d1415 2
d1422 2
d1427 2
d1433 2
d1440 2
d1453 2
d1464 1
d1467 3
a1469 3
	isdigit((unsigned char)value[3]) &&
	isdigit((unsigned char)value[4]) &&
	isdigit((unsigned char)value[5])) {
d1474 1
a1474 7
	char * cptmp = NULL;

	StrAllocCopy(cptmp, (value + 1));
	cptmp[0] = 'c';
	cptmp[1] = 'p';
	if ((LYhndl = UCGetLYhndl_byMIME(cptmp)) >= 0) {
	    FREE(cptmp);
a1475 1
	}
d1479 1
a1479 5
	StrAllocCopy(cptmp, "windows-");
	StrAllocCat(cptmp, (value + 3));
	LYhndl = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
	return LYhndl;
d1482 3
a1484 3
	isdigit((unsigned char)value[8]) &&
	isdigit((unsigned char)value[9]) &&
	isdigit((unsigned char)value[10])) {
d1488 1
a1488 8
	char * cptmp = NULL;

	StrAllocCopy(cptmp, (value + 6));
	cptmp[0] = 'c';
	cptmp[1] = 'p';
	LYhndl = UCGetLYhndl_byMIME(cptmp);
	FREE(cptmp);
	return LYhndl;
d1490 1
d1494 1
d1497 1
a1497 1
    CTRACE(tfp, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value);
d1553 1
a1553 1
    CONST char **tp;
d1564 1
a1564 1
    tp = (CONST char **)malloc(96 * sizeof(CONST char *));
d1588 1
a1588 1
		   ti[k-160] = i;
d1609 1
a1609 1
		tp[k-160] = list->replace_str;
d1636 1
a1636 1
	if (s8 && (unsigned char)(*s8) >= 160 && strlen(s8) == 1) {
d1641 2
a1642 2
	    if (ti[(unsigned char)(*s8) - 160] >= lowest8 &&
		!(s7[0] == ti[(unsigned char)(*s8) - 160] &&
d1649 1
a1649 1
		if (ti[(unsigned char)(*s8) - 160] == (unsigned char)(*s8)) {
d1653 1
a1653 15
		     *			      ...or another byte...
		     */
#ifdef NOTDEFINED
		    *p = (char *)malloc(2*sizeof(char));
		    if (!*p) {
			FREE(tp);
			FREE(ti);
			FREE(prepl);
			return NULL;
		    }
		    (*p)[0] = ti[(unsigned char)(*s8) - 160];
		    (*p)[1] = '\0';
#else
		    /*
		     *	Use this instead... make those 1-char strings
d1660 1
a1660 1
		    dummy[0] = ti[(unsigned char)(*s8) - 160];
a1661 1
#endif /* NOTDEFINED */
d1664 2
a1665 2
	    } else if (tp[(unsigned char)(*s8) - 160] &&
		       strcmp(s7, tp[(unsigned char)(*s8) - 160])) {
d1670 1
a1670 1
		*p = tp[(unsigned char)(*s8) - 160];
d1720 2
a1721 2
	    CTRACE(tfp, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset);
d1805 2
a1806 2
	    CTRACE(tfp, "UC_Charset_Setup: Too many.  Ignoring %s/%s.",
			UC_MIMEcharset, UC_LYNXcharset);
d1839 107
d1962 41
d2028 1
a2028 1
    UC_CHARSET_SETUP_macintosh; 	  /* Macintosh (8 bit)	  */
d2034 1
a2034 1
    UC_CHARSET_SETUP_shift_jis; 	  /*** Japanese (Shift_JIS) */
d2072 24
a2095 3
#ifdef NOTDEFINED
    UC_CHARSET_SETUP_mnem;
#endif /* NOTDEFINED */
d2102 1
a2102 1
/* easy to type: */
d2106 1
d2111 1
a2111 1
 *  in user input: lynx.cfg, userdefs.h, switches from command line.
d2119 1
a2119 1
	CTRACE(tfp, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n");
@


1.1
log
@Initial revision
@
text
@d5 2
d19 54
a72 49
#include "HTUtils.h"
#include "tcp.h"
#include "HTMLDTD.h"

#include "LYGlobalDefs.h"
#include "UCkd.h"
#include "UCdomap.h"
#include "UCMap.h"
#include "UCDefs.h"
#include "LYCharSets.h"

/*
 *  Include tables & parameters.
 */
#include "cp1250_uni.h" 	/* WinLatin2 (cp1250)	*/
#include "cp1251_uni.h" 	/* WinCyrillic (cp1251) */
#include "cp1252_uni.h" 	/* WinLatin1 (cp1252)	*/
#include "cp1253_uni.h" 	/* WinGreek (cp1253)	*/
#include "cp1255_uni.h" 	/* WinHebrew (cp1255)	*/
#include "cp1256_uni.h" 	/* WinArabic (cp1256)	*/
#include "cp1257_uni.h" 	/* WinBaltRim (cp1257)	*/
#include "cp437_uni.h"		/* DosLatinUS (cp437)	*/
#include "cp737_uni.h"		/* DosGreek (cp737)	*/
#include "cp775_uni.h"		/* DosBaltRim (cp775)	*/
#include "cp850_uni.h"		/* DosLatin1 (cp850)	*/
#include "cp852_uni.h"		/* DosLatin2 (cp852)	*/
#include "cp862_uni.h"		/* DosHebrew (cp862)	*/
#include "cp864_uni.h"		/* DosArabic (cp864)	*/
#include "cp866_uni.h"		/* DosCyrillic (cp866)	*/
#include "cp869_uni.h"		/* DosGreek2 (cp869)	*/
#include "def7_uni.h"		/* 7 bit approximations */
#include "dmcs_uni.h"		/* DEC Multinational	*/
#include "iso01_uni.h"		/* ISO Latin 1		*/
#include "iso02_uni.h"		/* ISO Latin 2		*/
#include "iso03_uni.h"		/* ISO Latin 3		*/
#include "iso04_uni.h"		/* ISO Latin 4		*/
#include "iso05_uni.h"		/* ISO 8859-5 Cyrillic	*/
#include "iso06_uni.h"		/* ISO 8859-6 Arabic	*/
#include "iso07_uni.h"		/* ISO 8859-7 Greek	*/
#include "iso08_uni.h"		/* ISO 8859-8 Hebrew	*/
#include "iso09_uni.h"		/* ISO 8859-9 (Latin 5) */
#include "iso10_uni.h"		/* ISO 8859-10		*/
#include "koi8r_uni.h"		/* KOI8-R Cyrillic	*/
#include "mac_uni.h"		/* Macintosh (8 bit)	*/
#include "mnem2_suni.h" 	/* RFC 1345 Mnemonic	*/
#include "next_uni.h"		/* NeXT character set	*/
#include "rfc_suni.h"		/* RFC 1345 w/o Intro	*/
#include "utf8_uni.h"		/* UNICODE UTF 8	*/
#include "viscii_uni.h" 	/* Vietnamese (VISCII)	*/
d74 1
a74 1
#include "mnem_suni.h"
a76 2
#define FREE(x) if (x) {free(x); x = NULL;}

d273 1
a273 1
	char *		replace_str,
d313 1
a313 2
PRIVATE void UCfree_allocated_LYCharSets NOPARAMS;
PRIVATE char ** UC_setup_LYCharSets_repl PARAMS((
d321 2
d324 1
d478 3
a480 3
  int i, j;
  u16 *p;
  u16 *ptrans;
d483 1
a483 2
	if (TRACE)
	    fprintf(stderr, "UC_con_set_trans: Invalid charset handle %d.\n",
d490 3
a492 3
  if (p == UC_current_unitable) {    /* test whether pointers are equal */
    return;			/* nothing to be done */
  }
d495 2
d498 1
a498 1
  con_clear_unimap();
d543 1
a543 1
PRIVATE u16 * UC_current_unitable = NULL;
d568 2
a569 2
PRIVATE u16 * UC_default_unitable = NULL;
PRIVATE struct unimapdesc_str *UC_default_unitable_str = NULL;
d614 1
a614 1
	char *, 	replace_str,
d618 2
a619 1
    char ***p1, **p2;
d639 4
a642 3
    if (!(p2 = p1[n = (unicode >> 6) & 0x1f])) {
	p2 = p1[n] = (char* *)malloc(64*sizeof(char *));
	if (!p2)
d645 1
d650 1
d755 1
a755 1
    u16 *p;
d759 1
d790 6
d801 1
a801 1
    u16 *p;
d804 1
a804 2
	if (TRACE)
	    fprintf(stderr, "UC_con_set_unimap: Invalid charset handle %d.\n",
d817 1
d821 1
a821 1
    for (i = 0; i < 256; i++) {
d918 1
a918 1
    } else if (ucs == 0xfeff || (ucs >= 0x200a && ucs <= 0x200f)) {
d983 1
a983 1
    } else if (ucs == 0xfeff || (ucs >= 0x200a && ucs <= 0x200f)) {
a1038 5
#ifdef NOTDEFINED
PUBLIC int UCGetcharset_byMIMEname PARAMS((CONST char * UC_MIMEcharset));
PUBLIC int UCGetcharset_byLYNXname PARAMS((CONST char * UC_LYNXcharset));
#endif /* NOTDEFINED */

d1046 1
a1046 1
    u16 * ut;
d1097 1
a1097 1
    u16 * ut;
d1207 1
a1207 3
    if (TRACE) {
	fprintf(stderr,
		"UC_MapGN: Using %d <- %d (%s)\n",
a1208 1
    }
d1222 1
a1222 1
    u16 * ut;
d1292 1
a1292 1
    if (charset_in == 0)
d1329 1
a1329 1
    u16 * ut;
d1395 1
a1395 1
    u16 * ut;
d1520 3
a1522 2
 *  Currently the charset name has to match exactly -- not substring
 *  matching as was done before (see HTMIME.c, HTML.c).
d1525 1
a1525 1
	CONST char *,	UC_MIMEcharset)
d1527 2
a1528 2
  int i;
  int LYhndl = -1;
d1530 2
a1531 1
    if (!UC_MIMEcharset || !(*UC_MIMEcharset))
d1533 1
d1537 1
a1537 1
	  LYchar_set_names[i] && LYhndl < 0); i++) {
d1539 2
a1540 2
	    !strcmp(UC_MIMEcharset, LYCharSet_UC[i].MIMEname)) {
	    LYhndl = i;
d1543 6
a1548 1
    if (LYhndl < 0) {
d1550 1
a1550 1
	 *  Not yet found, try synonyms. - FM
d1552 59
a1610 64
	if (!strcmp(UC_MIMEcharset, "unicode-1-1-utf-8") ||
	    !strcmp(UC_MIMEcharset, "utf8")) {
	    /*
	     *	Treat these as synonyms for the IANA registered name. - FM
	     */
	    return UCGetLYhndl_byMIME("utf-8");
	}
	if (!strncmp(UC_MIMEcharset, "iso-2022-jp", 11) ||
	    !strcmp(UC_MIMEcharset, "x-euc-jp")) {
	    return UCGetLYhndl_byMIME("euc-jp");
	}
	if (!strcmp(UC_MIMEcharset, "x-shift-jis")) {
	    return UCGetLYhndl_byMIME("shift_jis");
	}
	if (!strcmp(UC_MIMEcharset, "iso-2022-kr")) {
	    return UCGetLYhndl_byMIME("euc-kr");
	}
	if (!strcmp(UC_MIMEcharset, "gb2312") ||
	    !strncmp(UC_MIMEcharset, "cn-gb", 5) ||
	    !strcmp(UC_MIMEcharset, "iso-2022-cn")) {
	    return UCGetLYhndl_byMIME("euc-cn");
	}
	if (!strcmp(UC_MIMEcharset, "cn-big5")) {
	    return UCGetLYhndl_byMIME("big5");
	}
	if (!strcmp(UC_MIMEcharset, "x-mac-roman") ||
	    !strcmp(UC_MIMEcharset, "mac-roman")) {
	    return UCGetLYhndl_byMIME("macintosh");
	}
	if (!strcmp(UC_MIMEcharset, "x-next") ||
	    !strcmp(UC_MIMEcharset, "nextstep") ||
	    !strcmp(UC_MIMEcharset, "x-nextstep")) {
	    return UCGetLYhndl_byMIME("next");
	}
	if (!strcmp(UC_MIMEcharset, "iso-8859-1-windows-3.1-latin-1") ||
	    !strcmp(UC_MIMEcharset, "cp1252") ||
	    !strcmp(UC_MIMEcharset, "cp-1252") ||
	    !strcmp(UC_MIMEcharset, "ibm1252") ||
	    !strcmp(UC_MIMEcharset, "iso-8859-1-windows-3.0-latin-1")) {
	    /*
	     *	Treat these as synonyms for windows-1252, which is more
	     *	commonly used than the IANA registered name. - FM
	     */
	    return UCGetLYhndl_byMIME("windows-1252");
	}
	if (!strcmp(UC_MIMEcharset, "iso-8859-2-windows-latin-2") ||
	    !strcmp(UC_MIMEcharset, "cp1250") ||
	    !strcmp(UC_MIMEcharset, "cp-1250") ||
	    !strcmp(UC_MIMEcharset, "ibm1250")) {
	    /*
	     *	Treat these as synonyms for windows-1250. - FM
	     */
	    return UCGetLYhndl_byMIME("windows-1250");
	}
	if ((!strncmp(UC_MIMEcharset, "ibm", 3) ||
	     !strncmp(UC_MIMEcharset, "cp-", 3)) &&
	    isdigit((unsigned char)UC_MIMEcharset[3]) &&
	    isdigit((unsigned char)UC_MIMEcharset[4]) &&
	    isdigit((unsigned char)UC_MIMEcharset[5])) {
	    /*
	     *	For "ibmNNN<...>" or "cp-NNN", try "cpNNN<...>"
	     *	if not yet found. - KW & FM
	     */
	    char * cptmp = NULL;
d1612 4
a1615 13
	    StrAllocCopy(cptmp, (UC_MIMEcharset + 1));
	    cptmp[0] = 'c';
	    cptmp[1] = 'p';
	    if ((LYhndl = UCGetLYhndl_byMIME(cptmp)) >= 0) {
		FREE(cptmp);
		return LYhndl;
	    }
	    /*
	     *	Try windows-NNN<...> if not yet found. - FM
	     */
	    StrAllocCopy(cptmp, "windows-");
	    StrAllocCat(cptmp, (UC_MIMEcharset + 3));
	    LYhndl = UCGetLYhndl_byMIME(cptmp);
d1619 17
a1635 8
	if (!strncmp(UC_MIMEcharset, "windows-", 8) &&
	    isdigit((unsigned char)UC_MIMEcharset[8]) &&
	    isdigit((unsigned char)UC_MIMEcharset[9]) &&
	    isdigit((unsigned char)UC_MIMEcharset[10])) {
	    /*
	     *	For "windows-NNN<...>", try "cpNNN<...>" - FM
	     */
	    char * cptmp = NULL;
d1637 9
a1645 10
	    StrAllocCopy(cptmp, (UC_MIMEcharset + 6));
	    cptmp[0] = 'c';
	    cptmp[1] = 'p';
	    LYhndl = UCGetLYhndl_byMIME(cptmp);
	    FREE(cptmp);
	    return LYhndl;
	}
	if (!strcmp(UC_MIMEcharset, "koi-8")) { /* accentsoft bugosity */
	  return UCGetLYhndl_byMIME("koi8-r");
  }
d1647 4
a1650 1
  return LYhndl;	/* returns -1 if no charset found by that MIME name */
d1673 1
a1673 1
PRIVATE char ** remember_allocated_LYCharSets[MAXCHARSETS];
d1684 1
d1695 1
d1697 1
a1697 1
PRIVATE char ** UC_setup_LYCharSets_repl ARGS2(
d1701 2
a1702 2
    char **ISO_Latin1 = LYCharSets[0];
    char **p;
d1704 4
a1707 4
    u16 *pp;
    char **tp;
    char *s7;
    char *s8;
d1716 1
a1716 1
    tp = (char **)malloc(96 * sizeof(char *));
d1770 2
a1771 2
    p = prepl = (char **)malloc(HTML_dtd.number_of_entities * sizeof(char *));
    if (!p) {
d1774 1
a1774 1
	return NULL;
d1776 2
d1848 1
a1848 1
    return prepl;
d1860 2
a1861 2
  int i, LYhndl, found;
  char **repl;
d1863 1
a1863 1
  LYhndl = -1;
d1870 1
a1870 1
      LYNumCharsets = i+1;
d1875 1
a1875 2
     *	Do different kinds of searches...
     *	Normally the first should find the match if there is one!
a1877 5
	if (!strcmp(UC_LYNXcharset, LYchar_set_names[i])) {
	    LYhndl = i;
	}
    }
    for (i = 0; i < MAXCHARSETS && LYchar_set_names[i] && LYhndl < 0; i++) {
d1884 4
a1887 6
  if (LYhndl < 0) {		/* not found */
    found = 0;
    if (LYNumCharsets >= MAXCHARSETS) {
	    if (TRACE) {
		fprintf(stderr,
		    "UC_Register_with_LYCharSets: Too many. Ignoring %s/%s.",
d1889 2
a1890 3
	    }
      return -1;
    }
d1896 2
a1897 2
    LYlowest_eightbit[LYhndl] = 999;
    LYCharSets[LYhndl] = SevenBitApproximations;
d1904 2
a1905 2
	 *  Terminating NULL may be looked for by Lynx code.
	 */
d1909 1
a1909 1
  LYCharSet_UC[LYhndl].UChndl = s;
d1913 3
a1915 2
  LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
  LYCharSet_UC[LYhndl].enc = UCInfo[s].enc;
d1923 1
a1923 1
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
d1925 1
a1925 1
    UCInfo[s].lowest_eight = LYlowest_eightbit[LYhndl];
d1928 4
a1931 4
  if (!found && LYhndl > 0) {
    repl = UC_setup_LYCharSets_repl(s,UCInfo[s].lowest_eight);
    if (repl) {
      LYCharSets[LYhndl] = repl;
d1935 2
a1936 1
      remember_allocated_LYCharSets[LYhndl]=repl;
d1938 1
a1938 2
  }
  return LYhndl;
d1945 1
a1945 1
PUBLIC void UC_Charset_Setup ARGS8(
d1948 2
a1949 2
	u8 *,			unicount,
	u16 *,			unitable,
d1953 2
a1954 1
	int,			UC_rawuni)
d1972 2
a1973 4
	    if (TRACE) {
		fprintf(stderr, "UC_Charset_Setup: Too many. Ignoring %s/%s.",
				UC_MIMEcharset, UC_LYNXcharset);
	    }
d1995 1
d2006 1
d2020 1
d2024 1
d2026 1
d2028 1
a2030 2
    UC_CHARSET_SETUP;	/* us-ascii */	  /* 7 bit approximations */

d2034 4
a2037 1
 *  except for CJK and others described in LYCharSet.c
d2041 1
d2049 7
d2058 3
d2086 1
a2086 1
    UC_CHARSET_SETUP_utf_8;		  /* UNICODE UTF-8	  */
d2089 2
d2099 21
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
