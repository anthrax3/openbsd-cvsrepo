head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.49;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.10;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.51;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.51;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYMap.c,v 1.48 2013/11/28 11:21:09 tom Exp $
 *			Lynx Client-side Image MAP Support	       LYMap.c
 *			==================================
 *
 *	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
 *
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTAnchor.h>
#include <HTAccess.h>
#include <HTFormat.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYKeymap.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>
#include <LYStrings.h>

#ifdef DIRED_SUPPORT
#include <LYUpload.h>
#include <LYLocal.h>
#endif

#include <LYexit.h>
#include <LYLeaks.h>

#define NO_MAP_TITLE "[USEMAP]"

typedef struct _LYMapElement {
    char *address;
    char *title;
    BOOLEAN intern_flag;
} LYMapElement;

typedef struct _LYImageMap {
    char *address;
    char *title;
    HTList *elements;
} LYImageMap;

static HTList *LynxMaps = NULL;

BOOL LYMapsOnly = FALSE;

/*
 * Utility for freeing a list of MAPs.
 */
void ImageMapList_free(HTList *theList)
{
    LYImageMap *map;
    LYMapElement *element;
    HTList *cur = theList;
    HTList *current;

    if (!cur)
	return;

    while (NULL != (map = (LYImageMap *) HTList_nextObject(cur))) {
	FREE(map->address);
	FREE(map->title);
	if (map->elements) {
	    current = map->elements;
	    while (NULL !=
		   (element = (LYMapElement *) HTList_nextObject(current))) {
		FREE(element->address);
		FREE(element->title);
		FREE(element);
	    }
	    HTList_delete(map->elements);
	    map->elements = NULL;
	}
	FREE(map);
    }
    HTList_delete(theList);
    return;
}

#ifdef LY_FIND_LEAKS
/*
 * Utility for freeing the global list of MAPs.  - kw
 */
static void LYLynxMaps_free(void)
{
    ImageMapList_free(LynxMaps);
    LynxMaps = NULL;
    return;
}
#endif /* LY_FIND_LEAKS */

/*
 * We keep two kinds of lists:
 * - A global list (LynxMaps) shared by MAPs from all documents that
 *   do not have POST data.
 * - For each response to a POST which contains MAPs, a list specific
 *   to this combination of URL and post_data.  It is kept in the
 *   HTParentAnchor structure and is freed when the document is removed
 *   from memory, in the course of normal removal of anchors.
 *   MAPs from POST responses can only be accessed via internal links,
 *   i.e., from within the same document (with the same post_data).
 *   The notion of "same document" is extended, so that LYNXIMGMAP:
 *   and List Page screens are logically part of the document on which
 *   they are based. - kw
 *
 * If track_internal_links is false, only the global list will be used
 * for all MAPs.
 *
 */

/*
 * Utility for creating an LYImageMap list, if it doesn't exist already, adding
 * LYImageMap entry structures if needed, and removing any LYMapElements in a
 * pre-existing LYImageMap entry so that it will have only those from AREA tags
 * for the current analysis of MAP element content.  - FM
 */
BOOL LYAddImageMap(char *address,
		   char *title,
		   HTParentAnchor *node_anchor)
{
    LYImageMap *tmp = NULL;
    LYImageMap *old = NULL;
    HTList *cur = NULL;
    HTList *theList = NULL;
    HTList *curele = NULL;
    LYMapElement *ele = NULL;

    if (isEmpty(address))
	return FALSE;
    if (!(node_anchor && node_anchor->address))
	return FALSE;

    /*
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list is created if it doesn't
     * already exist.  - kw
     */
    if (track_internal_links && node_anchor->post_data) {
	/*
	 * We are handling a MAP element found while parsing node_anchor's
	 * stream of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
	 */
	theList = node_anchor->imaps;
	if (!theList) {
	    theList = node_anchor->imaps = HTList_new();
	}
    } else {
	if (!LynxMaps) {
	    LynxMaps = HTList_new();
#ifdef LY_FIND_LEAKS
	    atexit(LYLynxMaps_free);
#endif
	}
	theList = LynxMaps;
    }

    if (theList) {
	cur = theList;
	while (NULL != (old = (LYImageMap *) HTList_nextObject(cur))) {
	    if (old->address == 0)	/* shouldn't happen */
		continue;
	    if (!strcmp(old->address, address)) {
		FREE(old->address);
		FREE(old->title);
		if (old->elements) {
		    curele = old->elements;
		    while (NULL !=
			   (ele = (LYMapElement *) HTList_nextObject(curele))) {
			FREE(ele->address);
			FREE(ele->title);
			FREE(ele);
		    }
		    HTList_delete(old->elements);
		    old->elements = NULL;
		}
		break;
	    }
	}
    }

    tmp = (old != NULL) ?
	old : typecalloc(LYImageMap);
    if (tmp == NULL) {
	outofmem(__FILE__, "LYAddImageMap");
	return FALSE;
    }
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    if (tmp != old)
	HTList_addObject(theList, tmp);
    return TRUE;
}

/*
 * Utility for adding LYMapElement's to LYImageMap's
 * in the appropriate list. - FM
 */
BOOL LYAddMapElement(char *map,
		     char *address,
		     char *title,
		     HTParentAnchor *node_anchor,
		     int intern_flag GCC_UNUSED)
{
    LYMapElement *tmp = NULL;
    LYImageMap *theMap = NULL;
    HTList *theList = NULL;
    HTList *cur = NULL;

    if (isEmpty(map) || isEmpty(address))
	return FALSE;
    if (!(node_anchor && node_anchor->address))
	return FALSE;

    /*
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list should already exist, since
     * this function is only called if the AREA tag we are handling was within
     * a MAP element in node_anchor's stream of data, so that LYAddImageMap has
     * been called.  - kw
     */
    if (track_internal_links && node_anchor->post_data) {
	/*
	 * We are handling an AREA tag found while parsing node_anchor's stream
	 * of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
	 */
	theList = node_anchor->imaps;
	if (!theList) {
	    return FALSE;
	}
    } else {
	if (!LynxMaps)
	    LYAddImageMap(map, NULL, node_anchor);
	theList = LynxMaps;
    }

    cur = theList;
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(theMap->address, map)) {
	    break;
	}
    }
    if (!theMap)
	return FALSE;
    if (!theMap->elements)
	theMap->elements = HTList_new();
    cur = theMap->elements;
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	if (!strcmp(tmp->address, address)) {
	    FREE(tmp->address);
	    FREE(tmp->title);
	    HTList_removeObject(theMap->elements, tmp);
	    FREE(tmp);
	    break;
	}
    }

    tmp = typecalloc(LYMapElement);
    if (tmp == NULL) {
	perror("Out of memory in LYAddMapElement");
	return FALSE;
    }
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    else
	StrAllocCopy(tmp->title, address);
    if (track_internal_links)
	tmp->intern_flag = (BOOLEAN) intern_flag;
    HTList_appendObject(theMap->elements, tmp);

    CTRACE((tfp,
	    "LYAddMapElement\n\tmap     %s\n\taddress %s\n\ttitle   %s)\n",
	    NonNull(map), NonNull(address), NonNull(title)));

    return TRUE;
}

/*
 * Utility for checking whether an LYImageMap entry with a given address
 * already exists in the LynxMaps structure.  - FM
 */
BOOL LYHaveImageMap(char *address)
{
    LYImageMap *Map;
    HTList *cur = LynxMaps;

    if (!(cur && non_empty(address)))
	return FALSE;

    while (NULL != (Map = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(Map->address, address)) {
	    return TRUE;
	}
    }

    return FALSE;
}

/*
 * Fills in a DocAddress structure for getting the HTParentAnchor of the
 * underlying resource.  ALso returns a pointer to that anchor in
 * *punderlying if we are dealing with POST data.  - kw
 *
 * address  is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 * anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	    data, we want the specific list, otherwise the global list.
 */
static void fill_DocAddress(DocAddress *wwwdoc,
			    const char *address,
			    HTParentAnchor *anAnchor,
			    HTParentAnchor **punderlying)
{
    char *doc_address = NULL;
    HTParentAnchor *underlying;

    StrAllocCopy(doc_address, address);
    if (anAnchor && anAnchor->post_data) {
	wwwdoc->address = doc_address;
	wwwdoc->post_data = anAnchor->post_data;
	wwwdoc->post_content_type = anAnchor->post_content_type;
	wwwdoc->bookmark = NULL;
	wwwdoc->isHEAD = FALSE;
	wwwdoc->safe = FALSE;
	underlying = HTAnchor_findAddress(wwwdoc);
	if (underlying->safe)
	    wwwdoc->safe = TRUE;
	if (punderlying)
	    *punderlying = underlying;
    } else {
	wwwdoc->address = doc_address;
	wwwdoc->post_data = NULL;
	wwwdoc->post_content_type = NULL;
	wwwdoc->bookmark = NULL;
	wwwdoc->isHEAD = FALSE;
	wwwdoc->safe = FALSE;
	if (punderlying)
	    *punderlying = NULL;
    }
}

/*
 * Get the appropriate list for creating a LYNXIMGMAP:  pseudo- document: 
 * either the global list (LynxMaps), or the specific list if a List Page for a
 * POST response is requested.  Also fill in the DocAddress structure etc.  by
 * calling fill_DocAddress().
 *
 * address is the address of the underlying resource, i.e., the one
 *	   containing the MAP element, the MAP's name appended as
 *	   fragment is ignored.
 * anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	   requested; if it is associated with POST data, we want the
 *	   specific list for this combination of address+post_data.
 *
 * if track_internal_links is false, the Anchor passed to
 * LYLoadIMGmap() will never have post_data, so that the global list
 * will be used. - kw
 */
static HTList *get_the_list(DocAddress *wwwdoc,
			    const char *address,
			    HTParentAnchor *anchor,
			    HTParentAnchor **punderlying)
{
    HTList *result;

    if (anchor->post_data) {
	fill_DocAddress(wwwdoc, address, anchor, punderlying);
	if (non_empty(punderlying)) {
	    result = (*punderlying)->imaps;
	} else {
	    result = anchor->imaps;
	}
    } else {
	fill_DocAddress(wwwdoc, address, NULL, punderlying);
	result = LynxMaps;
    }
    return result;
}

/*	LYLoadIMGmap - F.Macrides (macrides@@sci.wfeb.edu)
 *	------------
 *	Create a text/html stream with a list of links
 *	for HyperText References in AREAs of a MAP.
 */

static int LYLoadIMGmap(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    LYMapElement *tmp = NULL;
    LYImageMap *theMap = NULL;
    char *MapTitle = NULL;
    char *MapAddress = NULL;
    HTList *theList;
    HTList *cur = NULL;
    const char *address = NULL;
    char *cp = NULL;
    DocAddress WWWDoc;
    HTParentAnchor *underlying;
    BOOL old_cache_setting = LYforce_no_cache;
    BOOL old_reloading = reloading;
    HTFormat old_format_out = HTOutputFormat;

    if (isLYNXIMGMAP(arg)) {
	address = (arg + LEN_LYNXIMGMAP);
    }
    if (!(address && StrChr(address, ':'))) {
	HTAlert(MISDIRECTED_MAP_REQUEST);
	return (HT_NOT_LOADED);
    }

    theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    if (WWWDoc.safe)
	anAnchor->safe = TRUE;

    if (!theList) {
	if (anAnchor->post_data && !WWWDoc.safe &&
	    ((underlying && underlying->document && !LYforce_no_cache) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert(FAILED_MAP_POST_REQUEST);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = TRUE;
	reloading = TRUE;
	HTOutputFormat = WWW_PRESENT;
	LYMapsOnly = TRUE;
	if (!HTLoadAbsolute(&WWWDoc)) {
	    LYforce_no_cache = old_cache_setting;
	    reloading = old_reloading;
	    HTOutputFormat = old_format_out;
	    LYMapsOnly = FALSE;
	    HTAlert(MAP_NOT_ACCESSIBLE);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = old_cache_setting;
	reloading = old_reloading;
	HTOutputFormat = old_format_out;
	LYMapsOnly = FALSE;
	theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    }

    if (!theList) {
	HTAlert(MAPS_NOT_AVAILABLE);
	return (HT_NOT_LOADED);
    }

    cur = theList;
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(theMap->address, address)) {
	    break;
	}
    }
    if (theMap && HTList_count(theMap->elements) == 0) {
	/*
	 * We found a MAP without any usable AREA.  Fake a redirection to the
	 * address with fragment.  We do this even for post data (internal link
	 * within a document with post data) if it will not result in an
	 * unwanted network request.  - kw
	 */
	if (!anAnchor->post_data) {
	    StrAllocCopy(redirecting_url, address);
	    return (HT_REDIRECTING);
	} else if (WWWDoc.safe ||
		   (underlying->document && !anAnchor->document &&
		    (LYinternal_flag || LYoverride_no_cache))) {
	    StrAllocCopy(redirecting_url, address);
	    redirect_post_content = TRUE;
	    return (HT_REDIRECTING);
	}
    }
    if (!(theMap && theMap->elements)) {
	if (anAnchor->post_data && !WWWDoc.safe &&
	    ((underlying && underlying->document && !LYforce_no_cache) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert(FAILED_MAP_POST_REQUEST);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = TRUE;
	reloading = TRUE;
	HTOutputFormat = WWW_PRESENT;
	LYMapsOnly = TRUE;
	if (!HTLoadAbsolute(&WWWDoc)) {
	    LYforce_no_cache = old_cache_setting;
	    reloading = old_reloading;
	    HTOutputFormat = old_format_out;
	    LYMapsOnly = FALSE;
	    HTAlert(MAP_NOT_ACCESSIBLE);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = old_cache_setting;
	reloading = old_reloading;
	HTOutputFormat = old_format_out;
	LYMapsOnly = FALSE;
	cur = get_the_list(&WWWDoc, address, anAnchor, &underlying);
	while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	    if (!strcmp(theMap->address, address)) {
		break;
	    }
	}
	if (!(theMap && theMap->elements)) {
	    HTAlert(MAP_NOT_AVAILABLE);
	    return (HT_NOT_LOADED);
	}
    }
    if (track_internal_links)
	anAnchor->no_cache = TRUE;

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }

    if (non_empty(theMap->title)) {
	StrAllocCopy(MapTitle, theMap->title);
    } else if (non_empty(anAnchor->title)) {
	StrAllocCopy(MapTitle, anAnchor->title);
    } else if (non_empty(LYRequestTitle) &&
	       strcasecomp(LYRequestTitle, NO_MAP_TITLE)) {
	StrAllocCopy(MapTitle, LYRequestTitle);
    } else if ((cp = StrChr(address, '#')) != NULL) {
	StrAllocCopy(MapTitle, (cp + 1));
    }
    if (isEmpty(MapTitle)) {
	StrAllocCopy(MapTitle, NO_MAP_TITLE);
    } else {
	LYEntify(&MapTitle, TRUE);
    }

#define PUTS(buf)    (*target->isa->put_block)(target, buf, (int) strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    /*
     * This page is a list of titles and anchors for them.  Since titles
     * already passed SGML/HTML stage they are converted to current_char_set. 
     * That is why we insist on META charset for this page.
     */
    HTSprintf0(&buf, "<title>%s</title>\n", MapTitle);
    PUTS(buf);
    HTSprintf0(&buf, "</head>\n<body>\n");
    PUTS(buf);

    HTSprintf0(&buf, "<h1><em>%s</em></h1>\n", MapTitle);
    PUTS(buf);

    StrAllocCopy(MapAddress, address);
    LYEntify(&MapAddress, FALSE);
    HTSprintf0(&buf, "<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
    PUTS(buf);

    HTSprintf0(&buf, "<%s compact>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
					"ol" : "ul"));
    PUTS(buf);
    cur = theMap->elements;
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	StrAllocCopy(MapAddress, tmp->address);
	LYEntify(&MapAddress, FALSE);
	PUTS("<li><a href=\"");
	PUTS(MapAddress);
	PUTS("\"");
	if (track_internal_links && tmp->intern_flag) {
	    PUTS(" TYPE=\"internal link\"");
	}
	PUTS("\n>");
	LYformTitle(&MapTitle, tmp->title);
	LYEntify(&MapTitle, TRUE);
	PUTS(MapTitle);
	PUTS("</a>\n");
    }
    HTSprintf0(&buf, "</%s>\n</body>\n</html>\n",
	       ((keypad_mode == NUMBERS_AS_ARROWS)
		? "ol"
		: "ul"));
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(MapAddress);
    FREE(MapTitle);
    FREE(buf);
    return (HT_LOADED);
}

void LYPrintImgMaps(FILE *fp)
{
    const char *only = HTLoadedDocumentURL();
    size_t only_len = strlen(only);
    HTList *outer = LynxMaps;
    HTList *inner;
    LYImageMap *map;
    LYMapElement *elt;
    int count;

    if (HTList_count(outer) > 0) {
	while (NULL != (map = (LYImageMap *) HTList_nextObject(outer))) {
	    if (only_len != 0) {
		if (StrNCmp(only, map->address, only_len)
		    || (map->address[only_len] != '\0'
			&& map->address[only_len] != '#')) {
		    continue;
		}
	    }
	    fprintf(fp, "\n%s\n", isEmpty(map->title) ? NO_MAP_TITLE : map->title);
	    fprintf(fp, "%s\n", map->address);
	    inner = map->elements;
	    count = 0;
	    while (NULL != (elt = (LYMapElement *) HTList_nextObject(inner))) {
		fprintf(fp, "%4d. %s", ++count, elt->address);
		if (track_internal_links && elt->intern_flag)
		    fprintf(fp, " TYPE=\"internal link\"");
		fprintf(fp, "\n");
	    }
	}
    }
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYIMGMAP_C_GLOBALDEF_1_INIT { "LYNXIMGMAP", LYLoadIMGmap, 0}
GLOBALDEF(HTProtocol, LYLynxIMGmap, _LYIMGMAP_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxIMGmap =
{"LYNXIMGMAP", LYLoadIMGmap, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYMap.c,v 1.37 2009/01/01 22:30:15 tom Exp $
d39 1
a39 3
#ifndef DONT_TRACK_INTERNAL_LINKS
    BOOL intern_flag;
#endif
a47 4
struct _HTStream {
    HTStreamClass *isa;
};

d111 1
a111 1
 * If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will be used
d143 1
a143 2
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (node_anchor->post_data) {
d153 1
a153 3
    } else
#endif
    {
d209 1
a209 1
		     BOOL intern_flag GCC_UNUSED)
d228 1
a228 2
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (node_anchor->post_data) {
d238 1
a238 3
    } else
#endif
    {
d275 2
a276 3
#ifndef DONT_TRACK_INTERNAL_LINKS
    tmp->intern_flag = intern_flag;
#endif
d364 1
a364 1
 * if DONT_TRACK_INTERNAL_LINKS is defined, the Anchor passed to
d373 3
a375 1
    if (anchor && anchor->post_data) {
d377 5
a381 3
	if (non_empty(punderlying))
	    return (*punderlying)->imaps;
	return anchor->imaps;
d384 1
a384 1
	return LynxMaps;
d386 1
d420 1
a420 1
    if (!(address && strchr(address, ':'))) {
d518 2
a519 3
#ifdef DONT_TRACK_INTERNAL_LINKS
    anAnchor->no_cache = TRUE;
#endif
d540 1
a540 1
    } else if ((cp = strchr(address, '#')) != NULL) {
d585 1
a585 2
#ifndef DONT_TRACK_INTERNAL_LINKS
	if (tmp->intern_flag)
d587 1
a587 1
#endif
d610 1
a610 1
    unsigned only_len = strlen(only);
d620 1
a620 1
		if (strncmp(only, map->address, only_len)
d632 1
a632 2
#ifndef DONT_TRACK_INTERNAL_LINKS
		if (elt->intern_flag)
a633 1
#endif
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
a3 1
/*			Lynx Client-side Image MAP Support	       LYMap.c
d331 2
a332 1
static void fill_DocAddress(DocAddress *wwwdoc, char *address,
d336 1
d339 1
d341 1
a341 1
	wwwdoc->address = address;
d353 1
a353 1
	wwwdoc->address = address;
d381 2
a382 1
static HTList *get_the_list(DocAddress *wwwdoc, char *address,
d417 1
a417 1
    char *address = NULL;
d426 1
a426 1
	address = (char *) (arg + LEN_LYNXIMGMAP);
d558 1
a558 1
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))
d620 1
a620 1
    int only_len = strlen(only);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 5
a6 5
**			==================================
**
**	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
**
*/
d22 1
d32 2
d35 2
a36 2
   char * address;
   char * title;
d38 1
a38 1
   BOOL   intern_flag;
d43 3
a45 3
   char * address;
   char * title;
   HTList * elements;
d48 2
a49 3
struct _HTStream
{
  HTStreamClass * isa;
d52 1
a52 1
PRIVATE HTList * LynxMaps = NULL;
d54 1
a54 1
PUBLIC BOOL LYMapsOnly = FALSE;
d57 1
a57 1
 *  Utility for freeing a list of MAPs.
d59 1
a59 2
PUBLIC void ImageMapList_free ARGS1(
    HTList *,		theList)
d69 1
a69 1
    while (NULL != (map = (LYImageMap *)HTList_nextObject(cur))) {
d75 1
a75 1
		   (element = (LYMapElement *)HTList_nextObject(current))) {
d91 1
a91 1
 *  Utility for freeing the global list of MAPs. - kw
d93 1
a93 1
PRIVATE void LYLynxMaps_free NOARGS
d102 12
a113 12
 *  We keep two kinds of lists:
 *  - A global list (LynxMaps) shared by MAPs from all documents that
 *    do not have POST data.
 *  - For each response to a POST which contains MAPs, a list specific
 *    to this combination of URL and post_data.  It is kept in the
 *    HTParentAnchor structure and is freed when the document is removed
 *    from memory, in the course of normal removal of anchors.
 *    MAPs from POST responses can only be accessed via internal links,
 *    i.e., from within the same document (with the same post_data).
 *    The notion of "same document" is extended, so that LYNXIMGMAP:
 *    and List Page screens are logically part of the document on which
 *    they are based. - kw
d115 2
a116 2
 *  If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will
 *  be used for all MAPs.
d121 4
a124 5
 *  Utility for creating an LYImageMap list, if it doesn't
 *  exist already, adding LYImageMap entry structures if needed, and
 *  removing any LYMapElements in a pre-existing LYImageMap entry so that
 *  it will have only those from AREA tags for the current analysis of
 *  MAP element content. - FM
d126 3
a128 4
PUBLIC BOOL LYAddImageMap ARGS3(
	char *,		address,
	char *,		title,
	HTParentAnchor *, node_anchor)
d130 1
a130 1
    LYImageMap *new = NULL;
d137 1
a137 1
    if (!(address && *address))
d143 3
a145 3
     *	Set theList to either the global LynxMaps list or, if we
     *	are associated with post data, the specific list.  The
     *	list is created if it doesn't already exist. - kw
d150 3
a152 4
	 *  We are handling a MAP element found while parsing
	 *  node_anchor's stream of data, and node_anchor has
	 *  post_data associated and should therefore represent
	 *  a POST response, so use the specific list. - kw
d172 1
a172 1
	while (NULL != (old = (LYImageMap *)HTList_nextObject(cur))) {
d181 1
a181 1
			   (ele = (LYMapElement *)HTList_nextObject(curele))) {
d194 3
a196 3
    new = (old != NULL) ?
		    old : typecalloc(LYImageMap);
    if (new == NULL) {
d200 5
a204 5
    StrAllocCopy(new->address, address);
    if (title && *title)
	StrAllocCopy(new->title, title);
    if (new != old)
	HTList_addObject(theList, new);
d209 1
a209 1
 * Utility for adding LYMapElements to LYImageMaps
d212 5
a216 6
PUBLIC BOOL LYAddMapElement ARGS5(
	char *,		map,
	char *,		address,
	char *,		title,
	HTParentAnchor *, node_anchor,
	BOOL,		intern_flag GCC_UNUSED)
d218 1
a218 1
    LYMapElement *new = NULL;
d223 1
a223 1
    if (!(map && *map && address && *address))
d229 5
a233 6
     *	Set theList to either the global LynxMaps list or, if we
     *	are associated with post data, the specific list.  The
     *	list should already exist, since this function is only called
     *	if the AREA tag we are handling was within a MAP element
     *	in node_anchor's stream of data, so that LYAddImageMap has
     *	been called. - kw
d238 3
a240 4
	 *  We are handling an AREA tag found while parsing
	 *  node_anchor's stream of data, and node_anchor has
	 *  post_data associated and should therefore represent
	 *  a POST response, so use the specific list. - kw
d243 1
a243 1
	if (!theList)
d245 1
d255 1
a255 1
    while (NULL != (theMap = (LYImageMap *)HTList_nextObject(cur))) {
d265 6
a270 6
    while (NULL != (new = (LYMapElement *)HTList_nextObject(cur))) {
	if (!strcmp(new->address, address)) {
	    FREE(new->address);
	    FREE(new->title);
	    HTList_removeObject(theMap->elements, new);
	    FREE(new);
d275 2
a276 2
    new = typecalloc(LYMapElement);
    if (new == NULL) {
d280 3
a282 3
    StrAllocCopy(new->address, address);
    if (title && *title)
	StrAllocCopy(new->title, title);
d284 1
a284 1
	StrAllocCopy(new->title, address);
d286 1
a286 1
    new->intern_flag = intern_flag;
d288 6
a293 1
    HTList_appendObject(theMap->elements, new);
d298 2
a299 3
 *  Utility for checking whether an LYImageMap entry
 *  with a given address already exists in the LynxMaps
 *  structure. - FM
d301 1
a301 2
PUBLIC BOOL LYHaveImageMap ARGS1(
	char *,		address)
d306 1
a306 1
    if (!(cur && address && *address != '\0'))
d309 1
a309 1
    while (NULL != (Map = (LYImageMap *)HTList_nextObject(cur))) {
d319 3
a321 3
 *  Fills in a DocAddress structure for getting the HTParentAnchor of
 *  the underlying resource.  ALso returns a pointer to that anchor in
 *  *punderlying if we are dealing with POST data. - kw
d323 5
a327 5
 *  address  is the address of the underlying resource, i.e., the one
 *	     containing the MAP element, the MAP's name appended as
 *	     fragment is ignored.
 *  anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	     data, we want the specific list, otherwise the global list.
d329 3
a331 5
PRIVATE void fill_DocAddress ARGS4(
    DocAddress *,	wwwdoc,
    char *,		address,
    HTParentAnchor *,	anAnchor,
    HTParentAnchor **,	punderlying)
d333 2
a334 1
    HTParentAnchor * underlying;
d360 4
a363 4
 *  Get the appropriate list for creating a LYNXIMGMAP: pseudo-
 *  document: either the global list (LynxMaps), or the specific
 *  list if a List Page for a POST response is requested.  Also
 *  fill in the DocAddress structure etc. by calling fill_DocAddress().
d365 6
a370 6
 *  address is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 *  anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	    requested; if it is associated with POST data, we want the
 *	    specific list for this combination of address+post_data.
d376 3
a378 5
PRIVATE HTList * get_the_list ARGS4(
    DocAddress *,	wwwdoc,
    char *,		address,
    HTParentAnchor *,	anchor,
    HTParentAnchor **,	punderlying)
d382 1
a382 1
	if (punderlying && *punderlying)
d392 9
a400 10
**	------------
**	Create a text/html stream with a list of links
**	for HyperText References in AREAs of a MAP.
*/

PRIVATE int LYLoadIMGmap ARGS4 (
	CONST char *,		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d405 1
a405 1
    LYMapElement *new = NULL;
d414 1
a414 1
    HTParentAnchor * underlying;
d420 1
a420 1
	address = (char *)(arg + LEN_LYNXIMGMAP);
d424 1
a424 1
	return(HT_NOT_LOADED);
d436 1
a436 1
	    return(HT_NOT_LOADED);
d448 1
a448 1
	    return(HT_NOT_LOADED);
d459 1
a459 1
	return(HT_NOT_LOADED);
d463 1
a463 1
    while (NULL != (theMap = (LYImageMap *)HTList_nextObject(cur))) {
d470 4
a473 5
	 *  We found a MAP without any usable AREA.
	 *  Fake a redirection to the address with fragment.
	 *  We do this even for post data (internal link within
	 *  a document with post data) if it will not result in
	 *  an unwanted network request. - kw
d477 1
a477 1
	    return(HT_REDIRECTING);
d483 1
a483 1
	    return(HT_REDIRECTING);
d489 1
a489 1
	    HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
d491 1
a491 1
	    return(HT_NOT_LOADED);
d503 1
a503 1
	    return(HT_NOT_LOADED);
d510 1
a510 1
	while (NULL != (theMap = (LYImageMap *)HTList_nextObject(cur))) {
d517 1
a517 1
	    return(HT_NOT_LOADED);
a519 1

d530 1
a530 1
		HTAtom_name(format_in), HTAtom_name(format_out));
d533 1
a533 1
	return(HT_NOT_LOADED);
d536 1
a536 1
    if (theMap->title && *theMap->title) {
d538 1
a538 1
    } else if (anAnchor->title && *anAnchor->title) {
d540 2
a541 2
    } else if (LYRequestTitle && *LYRequestTitle &&
	       strcasecomp(LYRequestTitle, "[USEMAP]")) {
d544 1
a544 1
	StrAllocCopy(MapTitle, (cp+1));
d546 2
a547 2
    if (!(MapTitle && *MapTitle)) {
	StrAllocCopy(MapTitle, "[USEMAP]");
d557 2
a558 2
		"http-equiv=\"content-type\"",
		LYCharSet_UC[current_char_set].MIMEname);
d560 5
a564 6
	/*
	 *  This page is a list of titles and anchors for them.
	 *  Since titles already passed SGML/HTML stage
	 *  they converted to current_char_set.
	 *  That is why we insist on META charset for this page.
	 */
d570 1
a570 1
    HTSprintf0(&buf,"<h1><em>%s</em></h1>\n", MapTitle);
d575 1
a575 1
    HTSprintf0(&buf,"<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
d579 1
a579 1
				    "ol" : "ul"));
d582 2
a583 2
    while (NULL != (new=(LYMapElement *)HTList_nextObject(cur))) {
	StrAllocCopy(MapAddress, new->address);
d589 1
a589 1
	if (new->intern_flag)
d593 1
a593 1
	LYformTitle(&MapTitle, new->title);
d599 3
a601 3
		    ((keypad_mode == NUMBERS_AS_ARROWS)
		    ? "ol"
		    : "ul"));
d604 1
a604 1
    (*target->isa->_free)(target);
d608 36
a643 1
    return(HT_LOADED);
d648 1
a648 1
GLOBALDEF (HTProtocol,LYLynxIMGmap,_LYIMGMAP_C_GLOBALDEF_1_INIT);
d650 2
a651 1
GLOBALDEF PUBLIC HTProtocol LYLynxIMGmap = {"LYNXIMGMAP", LYLoadIMGmap, 0};
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d219 1
a219 1
	BOOL,		intern_flag)
d344 1
a344 1
	underlying = HTAnchor_parent(HTAnchor_findAddress(wwwdoc));
d424 2
a425 2
    if (!strncasecomp(arg, "LYNXIMGMAP:", 11)) {
	address = (char * )(arg + 11);
d550 1
a550 1
    } else if ((cp=strrchr(address, '#')) != NULL) {
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d127 2
a128 2
	char *, 	address,
	char *, 	title,
d176 1
a176 1
	    	continue;
d197 1
a197 1
		    old : (LYImageMap *)calloc(1, sizeof(LYImageMap));
d215 3
a217 3
	char *, 	map,
	char *, 	address,
	char *, 	title,
d279 1
a279 1
    new = (LYMapElement *)calloc(1, sizeof(LYMapElement));
d302 1
a302 1
	char *, 	address)
d473 19
d536 1
a536 1
	HTSprintf(&buf, CANNOT_CONVERT_I_TO_O,
d601 1
a601 1
	StrAllocCopy(MapTitle, new->title);
@


1.1
log
@Initial revision
@
text
@d8 14
a21 15
#include "HTUtils.h"
#include "tcp.h"
#include "HTTP.h"
#include "HTAnchor.h"
#include "HTAccess.h"
#include "HTFormat.h"
#include "HTParse.h"
#include "HTAlert.h"
#include "LYUtils.h"
#include "LYMap.h"
#include "GridText.h"
#include "LYSignal.h"
#include "LYGlobalDefs.h"
#include "LYKeymap.h"
#include "LYCharUtils.h"
d24 2
a25 2
#include "LYUpload.h"
#include "LYLocal.h"
d28 2
a29 4
#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x=NULL;}
d88 1
d98 1
d109 1
a109 1
 *    i.e. from within the same document (with the same post_data).
d165 1
d167 1
d175 2
d199 1
a199 1
	perror("Out of memory in LYAddImageMap");
d324 1
a324 1
 *  address  is the address of the underlying resource, i.e. the one
d367 1
a367 1
 *  address is the address of the underlying resource, i.e. the one
d409 1
a409 1
    char buf[1024];
d439 2
a440 6
	     HTConfirm(
#if __STDC__
		"LYNXIMGMAP: "
#endif
		CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert("Image map from POST response not available!");
d476 2
a477 6
	    HTConfirm(
#if __STDC__
		"LYNXIMGMAP: "
#endif
		CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert("Image map from POST response not available!");
d517 1
a517 1
	sprintf(buf, CANNOT_CONVERT_I_TO_O,
d520 1
d540 18
a557 2
    sprintf(buf,"<head>\n<title>%s</title>\n</head>\n<body>\n", MapTitle);
    (*target->isa->put_block)(target, buf, strlen(buf));
d559 2
a560 2
    sprintf(buf,"<h1><em>%s</em></h1>\n", MapTitle);
    (*target->isa->put_block)(target, buf, strlen(buf));
d564 2
a565 2
    sprintf(buf,"<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
    (*target->isa->put_block)(target, buf, strlen(buf));
d567 1
a567 1
    sprintf(buf, "<%s compact>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
d569 1
a569 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d574 3
a576 2
	(*target->isa->put_block)(target, "<li><a href=\"", 13);
	(*target->isa->put_block)(target, MapAddress, strlen(MapAddress));
d579 1
a579 2
	    (*target->isa->put_block)(target, "\" TYPE=\"internal link\"\n>",24);
	else
d581 1
a581 1
	    (*target->isa->put_block)(target, "\"\n>", 3);
d584 2
a585 2
	(*target->isa->put_block)(target, MapTitle, strlen(MapTitle));
	(*target->isa->put_block)(target, "</a>\n", 5);
d587 5
a591 3
    sprintf(buf,"</%s>\n</body>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
				     "ol" : "ul"));
    (*target->isa->put_block)(target, buf, strlen(buf));
d596 1
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
