head	1.10;
access;
symbols
	OPENBSD_5_5:1.8.0.14
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.8
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.6
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.14
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.12
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.10
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.9;
commitid	EcR8E7r0stjLUV4p;

1.9
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.8;
commitid	lGGuvDWEniklWrQe;

1.8
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.04.04.24.03;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.25.14.29.10;	author margarida;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.10;	author maja;	state Exp;
branches
	1.2.10.1
	1.2.12.1;
next	1.1;

1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches;
next	;

1.2.10.1
date	2003.01.22.23.54.24;	author miod;	state Exp;
branches;
next	;

1.2.12.1
date	2002.12.04.15.50.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.10
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYMainLoop.c,v 1.230 2013/11/28 11:20:34 tom Exp $
 */
#include <HTUtils.h>
#include <HTAccess.h>
#include <HTParse.h>
#include <HTList.h>
#include <HTML.h>
#include <HTFTP.h>
#include <HTFile.h>
#include <HTTP.h>
#include <HTAABrow.h>
#include <HTNews.h>
#include <LYCurses.h>
#include <LYStyle.h>
#include <LYGlobalDefs.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYOptions.h>
#include <LYSignal.h>
#include <LYGetFile.h>
#include <HTForms.h>
#include <LYSearch.h>
#include <LYClean.h>
#include <LYHistory.h>
#include <LYPrint.h>
#include <LYMail.h>
#include <LYEdit.h>
#include <LYShowInfo.h>
#include <LYBookmark.h>
#include <LYKeymap.h>
#include <LYJump.h>
#include <LYDownload.h>
#include <LYList.h>
#include <LYMap.h>
#include <LYTraversal.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>
#include <LYCookie.h>
#include <LYMainLoop.h>
#include <LYPrettySrc.h>

#ifdef USE_SESSIONS
#include <LYSession.h>
#endif

#ifdef KANJI_CODE_OVERRIDE
#include <HTCJK.h>
#endif

#define LinkIsTextarea(linkNumber) \
		(links[linkNumber].type == WWW_FORM_LINK_TYPE && \
		 links[linkNumber].l_form->type == F_TEXTAREA_TYPE)

#define LinkIsTextLike(linkNumber) \
	     (links[linkNumber].type == WWW_FORM_LINK_TYPE && \
	      F_TEXTLIKE(links[linkNumber].l_form->type))

#ifdef KANJI_CODE_OVERRIDE
char *str_kcode(HTkcode code)
{
    char *p;
    static char buff[8];

    if (current_char_set == TRANSPARENT) {
	p = "THRU";
    } else if (!LYRawMode) {
	p = "RAW";
    } else {
	switch (code) {
	case NOKANJI:
	    p = "AUTO";
	    break;

	case EUC:
	    p = "EUC+";
	    break;

	case SJIS:
	    p = "SJIS";
	    break;

	case JIS:
	    p = " JIS";
	    break;

	default:
	    p = " ???";
	    break;
	}
    }

    if (no_table_center) {
	buff[0] = '!';
	strcpy(buff + 1, p);
    } else {
	strcpy(buff, p);
    }

    return buff;
}
#endif

#ifdef WIN_EX

static char *str_sjis(char *to, char *from)
{
    if (!LYRawMode) {
	strcpy(to, from);
#ifdef KANJI_CODE_OVERRIDE
    } else if (last_kcode == EUC) {
	EUC_TO_SJIS(from, to);
    } else if (last_kcode == SJIS) {
	strcpy(to, from);
#endif
    } else {
	TO_SJIS((unsigned char *) from, (unsigned char *) to);
    }
    return to;
}

static void set_ws_title(char *str)
{
    SetConsoleTitle(str);
}

#endif /* WIN_EX */

#if defined(USE_EXTERNALS) || defined(WIN_EX)
#include <LYExtern.h>
#endif

#ifdef __EMX__
#include <io.h>
#endif

#ifdef DIRED_SUPPORT
#include <LYLocal.h>
#include <LYUpload.h>
#endif /* DIRED_SUPPORT */

#include <LYexit.h>
#include <LYLeaks.h>

/* two constants: */
HTLinkType *HTInternalLink = 0;
HTAtom *WWW_SOURCE = 0;

#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) \
	((track_internal_links && \
	 (!curdoc.internal_link || are_phys_different(p,n))) || \
	are_different(p,n))

#define NO_INTERNAL_OR_DIFFERENT(c,n) \
	(track_internal_links || are_different(c,n))

static void exit_immediately_with_error_message(int state, int first_file);
static void status_link(char *curlink_name, int show_more, int show_indx);
static void show_main_statusline(const LinkInfo curlink, int for_what);
static void form_noviceline(int);
static int are_different(DocInfo *doc1, DocInfo *doc2);

static int are_phys_different(DocInfo *doc1, DocInfo *doc2);

#define FASTTAB

static int sametext(char *een,
		    char *twee)
{
    if (een && twee)
	return (strcmp(een, twee) == 0);
    return TRUE;
}

HTList *Goto_URLs = NULL;	/* List of Goto URLs */

char *LYRequestTitle = NULL;	/* newdoc.title in calls to getfile() */
char *LYRequestReferer = NULL;	/* Referer, may be set in getfile() */

static bstring *prev_target = NULL;

#ifdef DISP_PARTIAL
BOOLEAN display_partial = FALSE;	/* could be enabled in HText_new() */
int NumOfLines_partial = 0;	/* number of lines displayed in partial mode */
#endif

static int Newline = 0;
static DocInfo newdoc;
static DocInfo curdoc;
static char *traversal_host = NULL;
static char *traversal_link_to_add = NULL;
static char *owner_address = NULL;	/* Holds the responsible owner's address     */
static char *ownerS_address = NULL;	/* Holds owner's address during source fetch */

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
static BOOL textinput_activated = FALSE;

#else
#define textinput_activated TRUE	/* a current text input is always active */
#endif
#ifdef INACTIVE_INPUT_STYLE_VH
BOOL textinput_redrawn = FALSE;

    /*must be public since used in LYhighlight(..) */
#endif

#ifdef LY_FIND_LEAKS
/*
 * Function for freeing allocated mainloop() variables.  - FM
 */
static void free_mainloop_variables(void)
{
    LYFreeDocInfo(&newdoc);
    LYFreeDocInfo(&curdoc);

#ifdef USE_COLOR_STYLE
    FREE(curdoc.style);
    FREE(newdoc.style);
#endif
    FREE(traversal_host);
    FREE(traversal_link_to_add);
    FREE(owner_address);
    FREE(ownerS_address);
#ifdef DIRED_SUPPORT
    clear_tags();
    reset_dired_menu();
#endif /* DIRED_SUPPORT */
    FREE(WWW_Download_File);	/* LYGetFile.c/HTFWriter.c */
    FREE(LYRequestReferer);

    return;
}
#endif /* LY_FIND_LEAKS */

#ifndef NO_LYNX_TRACE
static void TracelogOpenFailed(void)
{
    WWW_TraceFlag = FALSE;
    if (LYCursesON) {
	HTUserMsg(TRACELOG_OPEN_FAILED);
    } else {
	fprintf(stderr, "%s\n", TRACELOG_OPEN_FAILED);
	exit_immediately(EXIT_FAILURE);
    }
}

static BOOLEAN LYReopenTracelog(BOOLEAN *trace_flag_ptr)
{
    CTRACE((tfp, "\nTurning off TRACE for fetch of log.\n"));
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
	return FALSE;
    }
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
    }
    return TRUE;
}

static void turn_trace_back_on(BOOLEAN *trace_flag_ptr)
{
    if (*trace_flag_ptr == TRUE) {
	WWW_TraceFlag = TRUE;
	*trace_flag_ptr = FALSE;
	fprintf(tfp, "Turning TRACE back on.\n\n");
    }
}
#else
#define LYReopenTracelog(flag) TRUE
#define turn_trace_back_on(flag)	/*nothing */
#endif /* NO_LYNX_TRACE */

FILE *TraceFP(void)
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
    }
#endif /* NO_LYNX_TRACE */
    return stderr;
}

BOOLEAN LYOpenTraceLog(void)
{
#ifndef NO_LYNX_TRACE
    if (TRACE && LYUseTraceLog && LYTraceLogFP == NULL) {
	/*
	 * If we can't open it for writing, give up.  Otherwise, on VMS close
	 * it, delete it and any versions from previous sessions so they don't
	 * accumulate, and open it again.  - FM
	 */
	if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
	    TracelogOpenFailed();
	    return FALSE;
	}
#ifdef VMS
	LYCloseTracelog();
	HTSYS_remove(LYTraceLogPath);
	if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
	    TracelogOpenFailed();
	    return FALSE;
	}
#endif /* VMS */
	fflush(stdout);
	fflush(stderr);
	fprintf(tfp, "\t\t%s (%s)\n\n", LYNX_TRACELOG_TITLE, LYNX_VERSION);
	/*
	 * If TRACE is on, indicate whether the anonymous restrictions are set.
	 * - FM, LP, kw
	 *
	 * This is only a summary for convenience - it doesn't take the case of
	 * individual -restrictions= options into account.  - kw
	 */
	if (LYValidate) {
	    if (LYRestricted && had_restrictions_default) {
		CTRACE((tfp,
			"Validate and some anonymous restrictions are set.\n"));
	    } else if (had_restrictions_default) {
		CTRACE((tfp,
			"Validate restrictions set, restriction \"default\" was given.\n"));
	    } else if (LYRestricted) {
		CTRACE((tfp,
			"Validate restrictions set, additional anonymous restrictions ignored.\n"));
	    } else {
		CTRACE((tfp, "Validate restrictions are set.\n"));
	    }
	    /* But none of the above can actually happen, since there should
	     * never be a Trace Log with -validate.  If it appears in a log
	     * file something went wrong! */
	} else if (LYRestricted) {
	    if (had_restrictions_all) {
		CTRACE((tfp,
			"Anonymous restrictions set, restriction \"all\" was given.\n"));
	    } else {
		CTRACE((tfp, "Anonymous restrictions are set.\n"));
	    }
	} else if (had_restrictions_all && had_restrictions_default) {
	    CTRACE((tfp, "Restrictions \"all\" and \"default\" were given.\n"));
	} else if (had_restrictions_default) {
	    CTRACE((tfp, "Restriction \"default\" was given.\n"));
	} else if (had_restrictions_all) {
	    CTRACE((tfp, "\"all\" restrictions are set.\n"));
	}
    }
#endif /* NO_LYNX_TRACE */
    return TRUE;
}

void LYCloseTracelog(void)
{
#ifndef NO_LYNX_TRACE
    if (LYTraceLogFP != 0) {
	fflush(stdout);
	fflush(stderr);
	fclose(LYTraceLogFP);
	LYTraceLogFP = 0;
    }
#endif /* NO_LYNX_TRACE */
}

void handle_LYK_TRACE_TOGGLE(void)
{
#ifndef NO_LYNX_TRACE
    WWW_TraceFlag = (BOOLEAN) !WWW_TraceFlag;
    if (LYOpenTraceLog())
	HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

void LYSetNewline(int value)
{
    Newline = value;
}

#define LYSetNewline(value)	Newline = value

int LYGetNewline(void)
{
    return Newline;
}

#define LYGetNewline()		Newline

void LYChgNewline(int adjust)
{
    LYSetNewline(Newline + adjust);
}

#define LYChgNewline(adjust)	Newline += (adjust)

#ifdef USE_SOURCE_CACHE
static BOOLEAN from_source_cache = FALSE;

/*
 * Like HTreparse_document(), but also set the flag.
 */
static BOOLEAN reparse_document(void)
{
    BOOLEAN result;

    from_source_cache = TRUE;	/* set for LYMainLoop_pageDisplay() */
    if ((result = HTreparse_document()) != FALSE) {
	from_source_cache = TRUE;	/* set for mainloop refresh */
    } else {
	from_source_cache = FALSE;
    }
    return result;
}
#endif /* USE_SOURCE_CACHE */

/*
 * Prefer reparsing if we can, but reload if we must - to force regeneration
 * of the display.
 */
static BOOLEAN reparse_or_reload(int *cmd)
{
#ifdef USE_SOURCE_CACHE
    if (reparse_document()) {
	return FALSE;
    }
#endif
    *cmd = LYK_RELOAD;
    return TRUE;
}

/*
 * Functions for setting the current address
 */
static void set_address(DocInfo *doc, const char *address)
{
    StrAllocCopy(doc->address, address);
}

static void copy_address(DocInfo *dst, DocInfo *src)
{
    StrAllocCopy(dst->address, src->address);
}

static void free_address(DocInfo *doc)
{
    FREE(doc->address);
}

static void move_address(DocInfo *dst, DocInfo *src)
{
    copy_address(dst, src);
    free_address(src);
}

#ifdef DISP_PARTIAL
/*
 * This is for traversal call from within partial mode in LYUtils.c
 * and HTFormat.c  It simply calls HText_pageDisplay() but utilizes
 * LYMainLoop.c static variables to manage proper newline position
 * in case of #fragment
 */
BOOL LYMainLoop_pageDisplay(int line_num)
{
    const char *pound;
    int prev_newline = LYGetNewline();

    /*
     * Override Newline with a new value if user scrolled the document while
     * loading (in LYUtils.c).
     */
    LYSetNewline(line_num);

#ifdef USE_SOURCE_CACHE
    /*
     * reparse_document() acts on 'curdoc' which always on top of the
     * history stack: no need to resolve #fragment position since
     * we already know it (curdoc.line).
     * So bypass here. Sorry for possible confusion...
     */
    if (!from_source_cache)
#endif
	/*
	 * If the requested URL has the #fragment, and we are not popped
	 * from the history stack, and have not scrolled the document yet -
	 * we should calculate correct newline position for the fragment.
	 * (This is a bit suboptimal since HTFindPoundSelector() traverse
	 * anchors list each time, so we have a quadratic complexity
	 * and may load CPU in a worst case).
	 */
	if (display_partial
	    && newdoc.line == 1 && line_num == 1 && prev_newline == 1
	    && (pound = findPoundSelector(newdoc.address))
	    && *pound && *(pound + 1)) {
	    if (HTFindPoundSelector(pound + 1)) {
		/* HTFindPoundSelector will initialize www_search_result */
		LYSetNewline(www_search_result);
	    } else {
		LYSetNewline(prev_newline);	/* restore ??? */
		return NO;	/* no repaint */
	    }
	}

    HText_pageDisplay(LYGetNewline(), prev_target->str);
    return YES;
}
#endif /* DISP_PARTIAL */

static BOOL set_curdoc_link(int nextlink)
{
    BOOL result = FALSE;

    if (curdoc.link != nextlink
	&& nextlink >= 0
	&& nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks) {
	    LYhighlight(FALSE, curdoc.link, prev_target->str);
	    result = TRUE;
	}
	curdoc.link = nextlink;
    }
    return result;
}

/*
 * Setup newdoc to jump to the given line.
 *
 * FIXME: prefer to also jump to the link given in a URL fragment, but the
 * interface of getfile() does not provide that ability yet.
 */
static void goto_line(int nextline)
{
    int n;
    int old_link = newdoc.link;

    newdoc.link = 0;
    for (n = 0; n < nlinks; ++n) {
	if (nextline == links[n].anchor_line_num + 1) {
	    CTRACE((tfp, "top_of_screen %d\n", HText_getTopOfScreen() + 1));
	    CTRACE((tfp, "goto_line(%d) -> link %d -> %d\n", nextline,
		    old_link, n));
	    newdoc.link = n;
	    break;
	}
    }
}

#ifdef USE_MOUSE
static void set_curdoc_link_by_mouse(int nextlink)
{
    if (set_curdoc_link(nextlink)) {
	LYhighlight(TRUE, nextlink, prev_target->str);
	LYmsec_delay(20);
    }
}
#else
#define set_curdoc_link_by_mouse(nextlink) set_curdoc_link(nextlink)
#endif

static int do_change_link(void)
{
#ifdef USE_MOUSE
    /* Is there a mouse-clicked link waiting? */
    int mouse_tmp = get_mouse_link();

    /* If yes, use it as the link */
    if (mouse_tmp != -1) {
	if (mouse_tmp < 0 || mouse_tmp >= nlinks) {
	    char *msgtmp = NULL;

	    HTSprintf0(&msgtmp,
		       gettext("Internal error: Invalid mouse link %d!"),
		       mouse_tmp);
	    HTAlert(msgtmp);
	    FREE(msgtmp);
	    return (-1);	/* indicates unexpected error */
	}
	set_curdoc_link_by_mouse(mouse_tmp);
    }
#endif /* USE_MOUSE */
    return (0);			/* indicates OK */
}

#ifdef DIRED_SUPPORT
#define DIRED_UNCACHE_1 if (LYAutoUncacheDirLists < 1) /*nothing*/ ;\
			else HTuncache_current_document()
#define DIRED_UNCACHE_2 if (LYAutoUncacheDirLists < 2) /*nothing*/ ;\
			else HTuncache_current_document()
#endif /* DIRED_SUPPORT */

static void do_check_goto_URL(bstring **user_input,
			      char **old_user_input,
			      BOOLEAN *force_load)
{
    static BOOLEAN always = TRUE;
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	BOOLEAN *flag;
    } table[] = {
	{ STR_FILE_URL,		&no_file_url },
	{ STR_FILE_URL,		&no_goto_file },
	{ STR_LYNXEXEC,		&no_goto_lynxexec },
	{ STR_LYNXPROG,		&no_goto_lynxprog },
	{ STR_LYNXCGI,		&no_goto_lynxcgi },
	{ STR_CSO_URL,		&no_goto_cso },
	{ STR_FINGER_URL,	&no_goto_finger },
	{ STR_FTP_URL,		&no_goto_ftp },
	{ STR_GOPHER_URL,	&no_goto_gopher },
	{ STR_HTTP_URL,		&no_goto_http },
	{ STR_HTTPS_URL,	&no_goto_https },
	{ STR_MAILTO_URL,	&no_goto_mailto },
	{ STR_RLOGIN_URL,	&no_goto_rlogin },
	{ STR_TELNET_URL,	&no_goto_telnet },
	{ STR_TN3270_URL,	&no_goto_tn3270 },
	{ STR_WAIS_URL,		&no_goto_wais },
#ifndef DISABLE_BIBP
	{ STR_BIBP_URL,		&no_goto_bibp },
#endif
#ifndef DISABLE_NEWS
	{ STR_NEWS_URL,		&no_goto_news },
	{ STR_NNTP_URL,		&no_goto_nntp },
	{ STR_SNEWS_URL,	&no_goto_snews },
#endif
#ifdef EXEC_LINKS
	{ STR_LYNXEXEC,		&local_exec_on_local_files },
	{ STR_LYNXPROG,		&local_exec_on_local_files },
#endif /* EXEC_LINKS */
	{ STR_LYNXCFG,		&no_goto_configinfo },
	{ STR_LYNXCFLAGS,	&no_goto_configinfo },
	{ STR_LYNXCOOKIE,	&always },
#ifdef USE_CACHEJAR
	{ STR_LYNXCACHE,	&always },
#endif
	{ STR_LYNXDIRED,	&always },
	{ STR_LYNXDOWNLOAD,	&always },
	{ STR_LYNXOPTIONS,	&always },
	{ STR_LYNXPRINT,	&always },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOLEAN found = FALSE;

    /* allow going to anchors */
    if ((*user_input)->str[0] == '#') {
	if ((*user_input)->str[1] &&
	    HTFindPoundSelector((*user_input)->str + 1)) {
	    /* HTFindPoundSelector will initialize www_search_result,
	       so we do nothing else. */
	    HTAddGotoURL((*user_input)->str);
	    trimPoundSelector(curdoc.address);
	    StrAllocCat(curdoc.address, (*user_input)->str);
	}
    } else {
	/*
	 * If it's not a URL then make it one.
	 */
	StrAllocCopy(*old_user_input, (*user_input)->str);
	LYEnsureAbsoluteURL(old_user_input, "", TRUE);
	BStrCopy0((*user_input), *old_user_input);
	FREE(*old_user_input);

	for (n = 0; n < TABLESIZE(table); n++) {
	    if (*(table[n].flag)
		&& !StrNCmp((*user_input)->str,
			    table[n].name,
			    strlen(table[n].name))) {
		found = TRUE;
		HTUserMsg2(GOTO_XXXX_DISALLOWED, table[n].name);
		break;
	    }
	}
	if (found) {
	    ;
	} else if (LYValidate &&
		   !isHTTP_URL((*user_input)->str) &&
		   !isHTTPS_URL((*user_input)->str)) {
	    HTUserMsg(GOTO_NON_HTTP_DISALLOWED);

	} else {
	    set_address(&newdoc, (*user_input)->str);
	    newdoc.isHEAD = FALSE;
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * dont't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		/*
		 * Make a name for this new URL.
		 */
		StrAllocCopy(newdoc.title,
			     gettext("A URL specified by the user"));
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		*force_load = TRUE;
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode) {
		    DIRED_UNCACHE_2;
		}
#endif /* DIRED_SUPPORT */
	    }
	    LYUserSpecifiedURL = TRUE;
	    HTAddGotoURL(newdoc.address);
	}
    }
}

/* returns FALSE if user cancelled input or URL was invalid, TRUE otherwise */
static BOOL do_check_recall(int ch,
			    bstring **user_input,
			    char **old_user_input,
			    int URLTotal,
			    int *URLNum,
			    RecallType recall,
			    BOOLEAN *FirstURLRecall)
{
    char *cp;
    BOOL ret = FALSE;

    if (*old_user_input == 0)
	StrAllocCopy(*old_user_input, "");

    for (;;) {
#ifdef WIN_EX			/* 1998/10/11 (Sun) 10:41:05 */
	int len = strlen((*user_input)->str);

	if (len >= 3) {
	    if (len < MAX_LINE - 1
		&& LYIsHtmlSep((*user_input)->str[len - 3])
		&& LYIsDosDrive((*user_input)->str + len - 2))
		LYAddPathSep0((*user_input)->str);

	} else if (len == 2 && (*user_input)->str[1] == ':') {
	    if (LYIsDosDrive((*user_input)->str)) {
		LYAddPathSep0((*user_input)->str);
	    } else {
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, (*user_input)->str);
		BStrCopy0((*user_input), *old_user_input);
		FREE(*old_user_input);
		ret = FALSE;
		break;
	    }
	}
#endif
	/*
	 * Get rid of leading spaces (and any other spaces).
	 */
	LYTrimAllStartfile((*user_input)->str);
	if (isBEmpty(*user_input) &&
	    !(recall && (ch == UPARROW_KEY || ch == DNARROW_KEY))) {
	    BStrCopy0((*user_input), *old_user_input);
	    FREE(*old_user_input);
	    HTInfoMsg(CANCELLED);
	    ret = FALSE;
	    break;
	}
	if (recall && ch == UPARROW_KEY) {
	    if (*FirstURLRecall) {
		/*
		 * Use last URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = 0;
	    } else {
		/*
		 * Go back to the previous URL in the list.  - FM
		 */
		*URLNum += 1;
	    }
	    if (*URLNum >= URLTotal)
		/*
		 * Roll around to the last URL in the list.  - FM
		 */
		*URLNum = 0;
	    if ((cp = (char *) HTList_objectAt(Goto_URLs,
					       *URLNum)) != NULL) {
		BStrCopy0((*user_input), cp);
		if (goto_buffer
		    && **old_user_input
		    && !strcmp(*old_user_input, (*user_input)->str)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetBString(user_input, FALSE, 0, recall)) < 0) {
		    /*
		     * User cancelled the Goto via ^G.  Restore
		     * user_input and break.  - FM
		     */
		    BStrCopy0((*user_input), *old_user_input);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else if (recall && ch == DNARROW_KEY) {
	    if (*FirstURLRecall) {
		/*
		 * Use the first URL in the list.  - FM
		 */
		*FirstURLRecall = FALSE;
		*URLNum = URLTotal - 1;
	    } else {
		/*
		 * Advance to the next URL in the list.  - FM
		 */
		*URLNum -= 1;
	    }
	    if (*URLNum < 0)
		/*
		 * Roll around to the first URL in the list.  - FM
		 */
		*URLNum = URLTotal - 1;
	    if ((cp = (char *) HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
		BStrCopy0((*user_input), cp);
		if (goto_buffer && **old_user_input &&
		    !strcmp(*old_user_input, (*user_input)->str)) {
		    _statusline(EDIT_CURRENT_GOTO);
		} else if ((goto_buffer && URLTotal == 2) ||
			   (!goto_buffer && URLTotal == 1)) {
		    _statusline(EDIT_THE_PREV_GOTO);
		} else {
		    _statusline(EDIT_A_PREV_GOTO);
		}
		if ((ch = LYgetBString(user_input, FALSE, 0, recall)) < 0) {
		    /*
		     * User cancelled the Goto via ^G.  Restore
		     * user_input and break.  - FM
		     */
		    BStrCopy0((*user_input), *old_user_input);
		    FREE(*old_user_input);
		    HTInfoMsg(CANCELLED);
		    ret = FALSE;
		    break;
		}
		continue;
	    }
	} else {
	    ret = TRUE;
	    break;
	}
    }
    return ret;
}

static void do_cleanup_after_delete(void)
{
    HTuncache_current_document();
    move_address(&newdoc, &curdoc);
    newdoc.line = curdoc.line;
    if (curdoc.link == nlinks - 1) {
	/*
	 * We deleted the last link on the page.  - FM
	 */
	newdoc.link = curdoc.link - 1;
    } else {
	newdoc.link = curdoc.link;
    }
}

static int find_link_near_col(int col,
			      int delta)
{
    int i;

    for (i = curdoc.link; delta > 0 ? (i < nlinks) : (i >= 0); i += delta) {
	if ((links[i].ly - links[curdoc.link].ly) * delta > 0) {
	    int cy = links[i].ly, best = -1, dist = 1000000;

	    while ((delta > 0 ? (i < nlinks) : (i >= 0)) && cy == links[i].ly) {
		int cx = links[i].lx;
		const char *text = LYGetHiliteStr(i, 0);

		if (text != NULL)
		    cx += (int) strlen(text) / 2;
		cx -= col;
		if (cx < 0)
		    cx = -cx;
		if (cx < dist) {
		    dist = cx;
		    best = i;
		}
		i += delta;
	    }
	    return (best);
	}
    }
    return (-1);
}

/*
 * This is a special feature to traverse every http link derived from startfile
 * and check for errors or create crawl output files.  Only URL's that begin
 * with "traversal_host" are searched - this keeps the search from crossing to
 * other servers (a feature, not a bug!).
 */
static int DoTraversal(int c,
		       BOOLEAN *crawl_ok)
{
    BOOLEAN rlink_rejected = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;

    rlink_exists = (BOOL) (nlinks > 0 &&
			   links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
			   links[curdoc.link].lname != NULL);

    if (rlink_exists) {
	rlink_rejected = lookup_reject(links[curdoc.link].lname);
	if (!rlink_rejected &&
	    traversal_host &&
	    links[curdoc.link].lname) {
	    if (!isLYNXIMGMAP(links[curdoc.link].lname)) {
		rlink_allowed = (BOOL) !StrNCmp(traversal_host,
						links[curdoc.link].lname,
						strlen(traversal_host));
	    } else {
		rlink_allowed = (BOOL) !StrNCmp(traversal_host,
						links[curdoc.link].lname + LEN_LYNXIMGMAP,
						strlen(traversal_host));
	    }
	} else {
	    rlink_allowed = FALSE;
	}
    } else {
	rlink_allowed = FALSE;
    }
    if (rlink_exists && rlink_allowed) {
	if (lookup_link(links[curdoc.link].lname)) {
	    if (more_links ||
		(curdoc.link > -1 && curdoc.link < nlinks - 1)) {
		c = DNARROW_KEY;
	    } else {
		if (STREQ(curdoc.title, "Entry into main screen") ||
		    (nhist <= 0)) {
		    if (!dump_output_immediately) {
			cleanup();
			exit_immediately(EXIT_FAILURE);
		    }
		    c = -1;
		} else {
		    c = LTARROW_KEY;
		}
	    }
	} else {
	    StrAllocCopy(traversal_link_to_add,
			 links[curdoc.link].lname);
	    if (!isLYNXIMGMAP(traversal_link_to_add))
		*crawl_ok = TRUE;
	    c = RTARROW_KEY;
	}
    } else {			/* no good right link, so only down and left arrow ok */
	if (rlink_exists /* && !rlink_rejected */ )
	    /* uncomment in previous line to avoid duplicates - kw */
	    add_to_reject_list(links[curdoc.link].lname);
	if (more_links ||
	    (curdoc.link > -1 && curdoc.link < nlinks - 1)) {
	    c = DNARROW_KEY;
	} else {
	    /*
	     * curdoc.title doesn't always work, so bail out if the history
	     * list is empty.
	     */
	    if (STREQ(curdoc.title, "Entry into main screen") ||
		(nhist <= 0)) {
		if (!dump_output_immediately) {
		    cleanup();
		    exit_immediately(EXIT_FAILURE);
		}
		c = -1;
	    } else {
		c = LTARROW_KEY;
	    }
	}
    }
    CTRACE((tfp, "DoTraversal(%d:%d) -> %s\n",
	    nlinks > 0 ? curdoc.link : 0,
	    nlinks,
	    LYKeycodeToString(c, FALSE)));
    return c;
}

static BOOLEAN check_history(void)
{
    const char *base;

    if (!curdoc.post_data)
	/*
	 * Normal case - List Page is not associated with post data.  - kw
	 */
	return TRUE;

    if (nhist > 0
	&& !LYresubmit_posts
	&& HDOC(nhist - 1).post_data
	&& BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
	&& (base = HText_getContentBase()) != 0) {
	char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
	? HDOC(nhist - 1).address
	: HDOC(nhist - 1).address + LEN_LYNXIMGMAP;

	if (!StrNCmp(base, text, strlen(base))) {
	    /*
	     * Normal case - as best as we can check, the document at the top
	     * of the history stack seems to be the document the List Page is
	     * about (or a LYNXIMGMAP derived from it), and LYresubmit_posts is
	     * not set, so don't prompt here.  If we actually have to repeat a
	     * POST because, against expectations, the underlying document
	     * isn't cached any more, HTAccess will prompt for confirmation,
	     * unless we had LYK_NOCACHE -kw
	     */
	    return TRUE;
	}
    }
    return FALSE;
}

static int handle_LYK_ACTIVATE(int *c,
			       int cmd GCC_UNUSED,
			       BOOLEAN *try_internal GCC_UNUSED,
			       BOOLEAN *refresh_screen,
			       BOOLEAN *force_load,
			       int real_cmd)
{
    if (do_change_link() == -1) {
	LYforce_no_cache = FALSE;
	reloading = FALSE;
	return 1;		/* mouse stuff was confused, ignore - kw */
    }
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (real_cmd == LYK_ACTIVATE && textfields_need_activation &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {

		textinput_activated = TRUE;
		show_main_statusline(links[curdoc.link], FOR_INPUT);
		textfields_need_activation = textfields_activation_option;

		return 0;
	    }
#endif
	    /*
	     * Don't try to submit forms with bad actions.  - FM
	     */
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) {
		/*
		 * Do nothing if it's disabled.  - FM
		 */
		if (links[curdoc.link].l_form->disabled == YES) {
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure we have an action.  - FM
		 */
		if (isEmpty(links[curdoc.link].l_form->submit_action)) {
		    HTUserMsg(NO_FORM_ACTION);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Check for no_mail if the form action is a mailto URL.  - FM
		 */
		if (links[curdoc.link].l_form->submit_method
		    == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure this isn't a spoof in an account with restrictions
		 * on file URLs.  - FM
		 */
		if (no_file_url &&
		    isFILE_URL(links[curdoc.link].l_form->submit_action)) {
		    HTAlert(FILE_ACTIONS_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
		/*
		 * Make sure this isn't a spoof attempt via an internal URL.  -
		 * FM
		 */
		if (isLYNXCOOKIE(links[curdoc.link].l_form->submit_action) ||
		    isLYNXCACHE(links[curdoc.link].l_form->submit_action) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
		    (isLYNXDIRED(links[curdoc.link].l_form->submit_action) &&
		     (no_dired_support ||
		      strncasecomp((links[curdoc.link].l_form->submit_action
				    + 10),
				   "//PERMIT_LOCATION", 17) ||
		      !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS))) ||
#else
		    isLYNXDIRED(links[curdoc.link].l_form->submit_action) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
		    isLYNXDOWNLOAD(links[curdoc.link].l_form->submit_action) ||
		    isLYNXHIST(links[curdoc.link].l_form->submit_action) ||
		    isLYNXEDITMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXKEYMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXIMGMAP(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPRINT(links[curdoc.link].l_form->submit_action) ||
		    isLYNXEXEC(links[curdoc.link].l_form->submit_action) ||
		    isLYNXPROG(links[curdoc.link].l_form->submit_action)) {

		    HTAlert(SPECIAL_ACTION_DISALLOWED);
		    CTRACE((tfp, "LYMainLoop: Rejected '%s'\n",
			    links[curdoc.link].l_form->submit_action));
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}
#ifdef NOTDEFINED		/* We're disabling form inputs instead of using this. - FM */
		/*
		 * Check for enctype and let user know we don't yet support
		 * multipart/form-data - FM
		 */
		if (links[curdoc.link].l_form->submit_enctype) {
		    if (!strcmp(links[curdoc.link].l_form->submit_enctype,
				"multipart/form-data")) {
			HTAlert(gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			reloading = FALSE;
			return 0;
		    }
		}
#endif /* NOTDEFINED */
		if (check_realm) {
		    LYPermitURL = TRUE;
		}
		if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
		    LYNoRefererForThis = TRUE;
		}
		if (links[curdoc.link].l_form->submit_method != URL_MAIL_METHOD) {
		    StrAllocCopy(newdoc.title,
				 LYGetHiliteStr(curdoc.link, 0));
		}
	    }

	    /*
	     * Normally we don't get here for text input fields, but it can
	     * happen as a result of mouse positioning.  In that case the
	     * statusline will not have updated info, so update it now.  - kw
	     */
	    if (F_TEXTLIKE(links[curdoc.link].l_form->type)) {
		show_formlink_statusline(links[curdoc.link].l_form,
					 (real_cmd == LYK_NOCACHE ||
					  real_cmd == LYK_DOWNLOAD ||
					  real_cmd == LYK_HEAD ||
					  (real_cmd == LYK_MOUSE_SUBMIT &&
					   !textinput_activated)) ?
					 FOR_PANEL : FOR_INPUT);
		if (user_mode == NOVICE_MODE &&
		    textinput_activated &&
		    (real_cmd == LYK_ACTIVATE ||
		     real_cmd == LYK_MOUSE_SUBMIT)) {
		    form_noviceline(FormIsReadonly(links[curdoc.link].l_form));
		}
	    }

	    *c = change_form_link(curdoc.link,
				  &newdoc, refresh_screen,
				  FALSE,
				  (real_cmd == LYK_MOUSE_SUBMIT ||
				   real_cmd == LYK_NOCACHE ||
				   real_cmd == LYK_DOWNLOAD ||
				   real_cmd == LYK_HEAD));
	    if (*c != LKC_DONE || *refresh_screen) {
		/*
		 * Cannot have been a submit field for which newdoc was filled
		 * in.  - kw
		 */
		if ((links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		     links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) &&
		    links[curdoc.link].l_form->submit_method
		    != URL_MAIL_METHOD) {
		    /*
		     * Try to undo change of newdoc.title done above.
		     */
		    if (HText_getTitle()) {
			StrAllocCopy(newdoc.title, HText_getTitle());
		    } else if (curdoc.title) {
			StrAllocCopy(newdoc.title, curdoc.title);
		    }
		}
	    } else {
		if (HTOutputFormat == HTAtom_for("www/download") &&
		    newdoc.post_data != NULL &&
		    newdoc.safe == FALSE) {

		    if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			HTOutputFormat = WWW_PRESENT;
			LYforce_no_cache = FALSE;
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			return 0;
		    }
		}
		/*
		 * Moved here from earlier to only apply when it should.
		 * Anyway, why should realm checking be overridden for form
		 * submissions, this seems to be an unnecessary loophole??  But
		 * that's the way it was, maybe there is some reason.  However,
		 * at least make sure this doesn't weaken restrictions implied
		 * by -validate!
		 * - kw 1999-05-25
		 */
		if (check_realm && !LYValidate) {
		    LYPermitURL = TRUE;
		}
	    }
	    if (*c == LKC_DONE) {
		*c = DO_NOTHING;
	    } else if (*c == 23) {
		*c = DO_NOTHING;
		*refresh_screen = TRUE;
	    } else {
		/* Avoid getting stuck with repeatedly calling
		 * handle_LYK_ACTIVATE(), instead of calling change_form_link()
		 * directly from mainloop(), for text input fields.  - kw
		 */
		switch (LKC_TO_C(*c)) {
		case '\n':
		case '\r':
		default:
		    if ((real_cmd == LYK_ACTIVATE ||
			 real_cmd == LYK_MOUSE_SUBMIT) &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
			textinput_activated) {
			return 3;
		    }
		    break;
		}
	    }
	    return 2;
	} else {
	    /*
	     * Not a forms link.
	     *
	     * Make sure this isn't a spoof in an account with restrictions on
	     * file URLs.  - FM
	     */
	    if (no_file_url && isFILE_URL(links[curdoc.link].lname)) {
		if (!isFILE_URL(curdoc.address) &&
		    !((isLYNXEDITMAP(curdoc.address) ||
		       isLYNXKEYMAP(curdoc.address) ||
		       isLYNXCOOKIE(curdoc.address) ||
		       isLYNXCACHE(curdoc.address)) &&
		      !StrNCmp(links[curdoc.link].lname,
			       helpfilepath,
			       strlen(helpfilepath)))) {
		    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		} else if (curdoc.bookmark != NULL) {
		    HTAlert(FILE_BOOKMARKS_DISALLOWED);
		    reloading = FALSE;
		    return 0;
		}
	    }
	    /*
	     * Make sure this isn't a spoof attempt via an internal URL in a
	     * non-internal document.  - FM
	     */
	    if ((isLYNXCOOKIE(links[curdoc.link].lname) &&
		 (strcmp(NonNull(curdoc.title), COOKIE_JAR_TITLE) ||
		  !isLYNXCOOKIE(curdoc.address))) ||
#ifdef USE_CACHEJAR
		(isLYNXCACHE(links[curdoc.link].lname) &&
		 (strcmp(NonNull(curdoc.title), CACHE_JAR_TITLE) ||
		  !isLYNXCACHE(curdoc.address))) ||
#endif
#ifdef DIRED_SUPPORT
		(isLYNXDIRED(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
		 !LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
#ifdef OK_INSTALL
		 !LYIsUIPage(curdoc.address, UIP_INSTALL) &&
#endif /* OK_INSTALL */
		 !LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) ||
#endif /* DIRED_SUPPORT */
		(isLYNXDOWNLOAD(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS)) ||
		(isLYNXHIST(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		 !LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		 !LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) ||
		(isLYNXPRINT(links[curdoc.link].lname) &&
		 !LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS))) {
		HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		HTOutputFormat = WWW_PRESENT;
		LYforce_no_cache = FALSE;
		reloading = FALSE;
		return 0;
	    }
#ifdef USE_EXTERNALS
	    if (run_external(links[curdoc.link].lname, TRUE)) {
		*refresh_screen = TRUE;
		return 0;
	    }
#endif /* USE_EXTERNALS */

	    /*
	     * Follow a normal link or anchor.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
	    /*
	     * For internal links, retain POST content if present.  If we are
	     * on the List Page, prevent pushing it on the history stack.
	     * Otherwise set try_internal to signal that the top of the loop
	     * should attempt to reposition directly, without calling getfile.
	     * - kw
	     */
	    if (track_internal_links) {
		/*
		 * Might be an internal link anchor in the same doc.  If so, take
		 * the try_internal shortcut if we didn't fall through from
		 * LYK_NOCACHE.  - kw
		 */
		newdoc.internal_link =
		    (links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
		if (newdoc.internal_link) {
		    /*
		     * Special case of List Page document with an internal link
		     * indication, which may really stand for an internal link
		     * within the document the List Page is about.  - kw
		     */
		    if (LYIsListpageTitle(NonNull(curdoc.title)) &&
			(LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
			 LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
			if (check_history()) {
			    LYinternal_flag = TRUE;
			} else {
			    HTLastConfirmCancelled();	/* reset flag */
			    if (!confirm_post_resub(newdoc.address,
						    newdoc.title,
						    ((LYresubmit_posts &&
						      HText_POSTReplyLoaded(&newdoc))
						     ? 1
						     : 2),
						    2)) {
				if (HTLastConfirmCancelled() ||
				    (LYresubmit_posts &&
				     cmd != LYK_NOCACHE &&
				     !HText_POSTReplyLoaded(&newdoc))) {
				    /* cancel the whole thing */
				    LYforce_no_cache = FALSE;
				    reloading = FALSE;
				    copy_address(&newdoc, &curdoc);
				    StrAllocCopy(newdoc.title, curdoc.title);
				    newdoc.internal_link = curdoc.internal_link;
				    HTInfoMsg(CANCELLED);
				    return 1;
				} else if (LYresubmit_posts &&
					   cmd != LYK_NOCACHE) {
				    /* If LYresubmit_posts is set, and the
				       answer was No, and the key wasn't
				       NOCACHE, and we have a cached copy,
				       then use it. - kw */
				    LYforce_no_cache = FALSE;
				} else {
				    /* if No, but not ^C or ^G, drop
				     * the post data.  Maybe the link
				     * wasn't meant to be internal after
				     * all, here we can recover from that
				     * assumption. - kw */
				    LYFreePostData(&newdoc);
				    newdoc.internal_link = FALSE;
				    HTAlert(DISCARDING_POST_DATA);
				}
			    }
			}
			/*
			 * Don't push the List Page if we follow an internal link
			 * given by it.  - kw
			 */
			free_address(&curdoc);
		    } else if (cmd != LYK_NOCACHE) {
			*try_internal = TRUE;
		    }
		    if (!(LYresubmit_posts && newdoc.post_data))
			LYinternal_flag = TRUE;
		    /* We still set force_load so that history pushing
		     * etc. will be done.  - kw
		     */
		    *force_load = TRUE;
		    return 1;
		} else {
		    /*
		     * Free POST content if not an internal link.  - kw
		     */
		    LYFreePostData(&newdoc);
		}
	    }
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc)) {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		if (isLYNXMESSAGES(newdoc.address))
		    LYforce_no_cache = TRUE;
	    }
	    if (!no_jump && lynxjumpfile && curdoc.address &&
		!strcmp(lynxjumpfile, curdoc.address)) {
		LYJumpFileURL = TRUE;
		LYUserSpecifiedURL = TRUE;
	    } else if ((curdoc.title &&
			(LYIsUIPage(curdoc.address, UIP_HISTORY) ||
			 !strcmp(curdoc.title, HISTORY_PAGE_TITLE))) ||
		       curdoc.bookmark != NULL ||
		       (lynxjumpfile &&
			curdoc.address &&
			!strcmp(lynxjumpfile, curdoc.address))) {
		LYUserSpecifiedURL = TRUE;
	    } else if (no_filereferer == TRUE &&
		       curdoc.address != NULL &&
		       isFILE_URL(curdoc.address)) {
		LYNoRefererForThis = TRUE;
	    }
	    newdoc.link = 0;
	    *force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;	/* we get here if link is not internal */
#endif

#if defined(DIRED_SUPPORT) && !defined(__DJGPP__)
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
		/*
		 * Unescaping any slash chars in the URL, but avoid double
		 * unescaping and too-early unescaping of other chars.  - KW
		 */
		HTUnEscapeSome(newdoc.address, "/");
		/* avoid stripping final slash for root dir - kw */
		if (strcasecomp(newdoc.address, "file://localhost/"))
		    strip_trailing_slash(newdoc.address);
	    }
#endif /* DIRED_SUPPORT  && !__DJGPP__ */
	    if (isLYNXCOOKIE(curdoc.address)
		|| isLYNXCACHE(curdoc.address)) {
		HTuncache_current_document();
	    }
	}
    }
    return 0;
}
/*
 * If the given form link does not point to the requested type, search for
 * the first link belonging to the form which does.  If there are none,
 * return null.
 */
#define SameFormAction(form,submit) \
 	((submit) \
	 ? (F_SUBMITLIKE((form)->type)) \
	 : ((form)->type == F_RESET_TYPE))

static FormInfo *FindFormAction(FormInfo * given, BOOLEAN submit)
{
    FormInfo *result = NULL;
    FormInfo *fi;
    int i;

    if (given == NULL) {
	HTAlert(LINK_NOT_IN_FORM);
    } else if (SameFormAction(given, submit)) {
	result = given;
    } else {
	for (i = 0; i < nlinks; i++) {
	    if ((fi = links[i].l_form) != 0 &&
		fi->number == given->number &&
		(SameFormAction(fi, submit))) {
		result = fi;
		break;
	    }
	}
    }
    return result;
}

static FormInfo *MakeFormAction(FormInfo * given, BOOLEAN submit)
{
    FormInfo *result = 0;

    if (given != 0) {
	result = typecalloc(FormInfo);

	if (result == NULL)
	    outofmem(__FILE__, "MakeFormAction");

	*result = *given;
	if (submit) {
	    if (result->submit_action == 0) {
		PerFormInfo *pfi = HText_PerFormInfo(result->number);

		*result = pfi->data;
	    }
	    result->type = F_SUBMIT_TYPE;
	} else {
	    result->type = F_RESET_TYPE;
	}
	result->number = given->number;
    }
    return result;
}

static void handle_LYK_SUBMIT(int cur, DocInfo *doc, BOOLEAN *refresh_screen)
{
    FormInfo *form = FindFormAction(links[cur].l_form, TRUE);
    FormInfo *make = NULL;
    char *save_submit_action = NULL;

    if (form == 0) {
	make = MakeFormAction(links[cur].l_form, TRUE);
	form = make;
    }

    StrAllocCopy(save_submit_action, form->submit_action);
    form->submit_action = HTPrompt(EDIT_SUBMIT_URL, form->submit_action);

    if (isEmpty(form->submit_action) ||
	(!isLYNXCGI(form->submit_action) &&
	 StrNCmp(form->submit_action, "http", 4))) {
	HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
    } else {
	HTInfoMsg(SUBMITTING_FORM);
	HText_SubmitForm(form, doc, form->name, form->value);
	*refresh_screen = TRUE;
    }

    StrAllocCopy(form->submit_action, save_submit_action);
    FREE(make);
}

static void handle_LYK_RESET(int cur, BOOLEAN *refresh_screen)
{
    FormInfo *form = FindFormAction(links[cur].l_form, FALSE);
    FormInfo *make = NULL;

    if (form == 0) {
	make = MakeFormAction(links[cur].l_form, FALSE);
	form = make;
    }

    if (form != 0) {
	HTInfoMsg(RESETTING_FORM);
	HText_ResetForm(form);
	*refresh_screen = TRUE;
	FREE(make);
    }
}

#ifdef USE_ADDRLIST_PAGE
static BOOLEAN handle_LYK_ADDRLIST(int *cmd)
{
    /*
     * Don't do if already viewing list addresses page.
     */
    if (LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE)) {
	/*
	 * Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print address list page to file.
     */
    if (showlist(&newdoc, FALSE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
    /*
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}
#endif /* USE_ADDRLIST_PAGE */

static void handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
{
    int c;

    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    if (!LYIsUIPage(curdoc.address, UIP_HISTORY) &&
	!LYIsUIPage(curdoc.address, UIP_SHOWINFO) &&
	!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS) &&
#ifdef DIRED_SUPPORT
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	!LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) &&
	!LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS) &&
#endif /* DIRED_SUPPORT */
	!LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS) &&
	!isLYNXCOOKIE(curdoc.address) &&
	!isLYNXCACHE(curdoc.address) &&
	!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU) &&
	((nlinks <= 0) ||
	 (links[curdoc.link].lname != NULL &&
	  !isLYNXHIST(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname) &&
	  !isLYNXDIRED(links[curdoc.link].lname) &&
	  !isLYNXDOWNLOAD(links[curdoc.link].lname) &&
	  !isLYNXCOOKIE(links[curdoc.link].lname) &&
	  !isLYNXCACHE(links[curdoc.link].lname) &&
	  !isLYNXPRINT(links[curdoc.link].lname)))) {
	if (nlinks > 0) {
	    if (curdoc.post_data == NULL &&
		curdoc.bookmark == NULL &&
		!LYIsUIPage(curdoc.address, UIP_LIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE) &&
		!LYIsUIPage(curdoc.address, UIP_VLINKS)) {
		/*
		 * The document doesn't have POST content, and is not a
		 * bookmark file, nor is the list or visited links page, so we
		 * can save either that or the link.  - FM
		 */
		_statusline(BOOK_D_L_OR_CANCEL);
		if ((c = LYgetch_single()) == 'D') {
		    save_bookmark_link(curdoc.address, curdoc.title);
		    *refresh_screen = TRUE;	/* MultiBookmark support */
		    goto check_add_bookmark_to_self;
		}
	    } else {
		if (LYMultiBookmarks == MBM_OFF &&
		    curdoc.bookmark != NULL &&
		    strstr(curdoc.address,
			   (*bookmark_page == '.'
			    ? (bookmark_page + 1)
			    : bookmark_page)) != NULL) {
		    /*
		     * If multiple bookmarks are disabled, offer the L)ink or
		     * C)ancel, but with wording which indicates that the link
		     * already exists in this bookmark file.  - FM
		     */
		    _statusline(MULTIBOOKMARKS_SELF);
		} else if (curdoc.post_data != NULL &&
			   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     * Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		} else {
		    /*
		     * Only offer the link in a document with POST content, or
		     * if the current document is a bookmark file and multiple
		     * bookmarks are enabled.  - FM
		     */
		    _statusline(BOOK_L_OR_CANCEL);
		}
		c = LYgetch_single();
	    }
	    if (c == 'L') {
		if (curdoc.post_data != NULL &&
		    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
		    /*
		     * Internal link, and document has POST content.
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    return;
		}
		/*
		 * User does want to save the link.  - FM
		 */
		if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    save_bookmark_link(links[curdoc.link].lname,
				       LYGetHiliteStr(curdoc.link, 0));
		    *refresh_screen = TRUE;	/* MultiBookmark support */
		} else {
		    HTUserMsg(NOBOOK_FORM_FIELD);
		    return;
		}
	    } else {
		return;
	    }
	} else if (curdoc.post_data != NULL) {
	    /*
	     * No links, and document has POST content.  - FM
	     */
	    HTUserMsg(NOBOOK_POST_FORM);
	    return;
	} else if (curdoc.bookmark != NULL) {
	    /*
	     * It's a bookmark file from which all of the links were deleted.
	     * - FM
	     */
	    HTUserMsg(BOOKMARKS_NOLINKS);
	    return;
	} else {
	    _statusline(BOOK_D_OR_CANCEL);
	    if (LYgetch_single() == 'D') {
		save_bookmark_link(curdoc.address, curdoc.title);
		*refresh_screen = TRUE;		/* MultiBookmark support */
	    } else {
		return;
	    }
	}
      check_add_bookmark_to_self:
	if (curdoc.bookmark && BookmarkPage &&
	    !strcmp(curdoc.bookmark, BookmarkPage)) {
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    newdoc.internal_link = FALSE;
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOBOOK_HSML);
	}
    }
}

static void handle_LYK_CLEAR_AUTH(int *old_c,
				  int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
	    FREE(authentication_info[0]);
	    FREE(authentication_info[1]);
	    FREE(proxyauth_info[0]);
	    FREE(proxyauth_info[1]);
	    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
	    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
	    HTClearFTPPassword();
#endif
	    HTUserMsg(AUTH_INFO_CLEARED);
	} else {
	    HTUserMsg(CANCELLED);
	}
    }
}

static int handle_LYK_COMMAND(bstring **user_input)
{
    LYKeymapCode ch;
    Kcmd *mp;
    char *src, *tmp;

    BStrCopy0((*user_input), "");
    _statusline(": ");
    if (LYgetBString(user_input, FALSE, 0, RECALL_CMD) >= 0) {
	src = LYSkipBlanks((*user_input)->str);
	tmp = LYSkipNonBlanks(src);
	*tmp = 0;
	ch = ((mp = LYStringToKcmd(src)) != 0) ? mp->code : LYK_UNKNOWN;
	CTRACE((tfp, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, (int) ch));
	if (ch == 0) {
	    return *src ? -1 : 0;
	}
	/* FIXME: reuse the rest of the buffer for parameters */
	return ch;
    }
    return 0;
}

static void handle_LYK_COMMENT(BOOLEAN *refresh_screen,
			       char **owner_address_p,
			       int *old_c,
			       int real_c)
{
    int c;

    if (!*owner_address_p &&
	strncasecomp(curdoc.address, "http", 4)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_OWNER);
	}
    } else if (no_mail) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(MAIL_DISALLOWED);
	}
    } else {
	if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
	    if (!*owner_address_p) {
		/*
		 * No owner defined, so make a guess and and offer it to the
		 * user.  - FM
		 */
		char *address = NULL;
		char *temp = HTParse(curdoc.address, "", PARSE_PATH);
		char *cp;

		if (temp != NULL) {
		    HTUnEscape(temp);
		    if (LYIsTilde(*temp) && strlen(temp) > 1) {
			/*
			 * It's a ~user URL so guess user@@host.  - FM
			 */
			if ((cp = StrChr((temp + 1), '/')) != NULL)
			    *cp = '\0';
			StrAllocCopy(address, STR_MAILTO_URL);
			StrAllocCat(address, (temp + 1));
			StrAllocCat(address, "@@");
		    }
		    FREE(temp);
		}
		if (address == NULL)
		    /*
		     * Wasn't a ~user URL so guess WebMaster@@host.  - FM
		     */
		    StrAllocCopy(address, "mailto:WebMaster@@");
		temp = HTParse(curdoc.address, "", PARSE_HOST);
		StrAllocCat(address, temp);
		HTSprintf0(&temp, NO_OWNER_USE, address);
		c = HTConfirmDefault(temp, NO);
		FREE(temp);
		if (c == YES) {
		    StrAllocCopy(*owner_address_p, address);
		    FREE(address);
		} else {
		    FREE(address);
		    return;
		}
	    }
	    if (is_url(*owner_address_p) != MAILTO_URL_TYPE) {
		/*
		 * The address is a URL.  Just follow the link.
		 */
		set_address(&newdoc, *owner_address_p);
		newdoc.internal_link = FALSE;
	    } else {
		/*
		 * The owner_address is a mailto:  URL.
		 */
		const char *kp = HText_getRevTitle();
		const char *id = HText_getMessageID();
		char *tmptitle = NULL;

		if (!kp && HTMainAnchor) {
		    kp = HTAnchor_subject(HTMainAnchor);
		    if (non_empty(kp)) {
			if (strncasecomp(kp, "Re: ", 4)) {
			    StrAllocCopy(tmptitle, "Re: ");
			    StrAllocCat(tmptitle, kp);
			    kp = tmptitle;
			}
		    }
		}

		if (StrChr(*owner_address_p, ':') != NULL)
		    /*
		     * Send a reply.  The address is after the colon.
		     */
		    reply_by_mail(StrChr(*owner_address_p, ':') + 1,
				  curdoc.address,
				  NonNull(kp), id);
		else
		    reply_by_mail(*owner_address_p, curdoc.address,
				  NonNull(kp), id);

		FREE(tmptitle);
		*refresh_screen = TRUE;		/* to force a showpage */
	    }
	}
    }
}

#ifdef USE_CACHEJAR
static BOOLEAN handle_LYK_CACHE_JAR(int *cmd)
{
    /*
     * Don't do this if already viewing cache jar.
     */
    if (!isLYNXCACHE(curdoc.address)) {
	set_address(&newdoc, STR_LYNXCACHE "/");
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the cache jar, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}
#endif /* USE_CACHEJAR */

static BOOLEAN handle_LYK_COOKIE_JAR(int *cmd)
{
    /*
     * Don't do if already viewing the cookie jar.
     */
    if (!isLYNXCOOKIE(curdoc.address)) {
	set_address(&newdoc, "LYNXCOOKIE:/");
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the cookie jar, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

#if defined(DIRED_SUPPORT)
static void handle_LYK_CREATE(void)
{
    if (lynx_edit_mode && !no_dired_support) {
	if (local_create(&curdoc) > 0) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen,
				    int *old_c,
				    int real_c)
{
    if (curdoc.bookmark != NULL) {
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE, NO) != YES)
	    return;
	remove_bookmark_link(links[curdoc.link].anchor_number - 1,
			     curdoc.bookmark);
    } else {			/* behave like REFRESH for backward compatibility */
	*refresh_screen = TRUE;
	if (*old_c != real_c) {
	    *old_c = real_c;
	    lynx_force_repaint();
	}
	return;
    }
    do_cleanup_after_delete();
}

#if defined(DIRED_SUPPORT) || defined(VMS)
static void handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen,
				  int *old_c GCC_UNUSED,
				  int real_c GCC_UNUSED)
{
#ifdef VMS
    char *cp, *temp = 0;
    const char *test = HTGetProgramPath(ppCSWING);

    /*
     * Check if the CSwing Directory/File Manager is available.  Will be
     * disabled if CSWING path is NULL, zero-length, or "none" (case
     * insensitive), if no_file_url was set via the file_url restriction, if
     * no_goto_file was set for the anonymous account, or if HTDirAccess was
     * set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse or -selective
     * switches.  - FM
     */
    if (isEmpty(test) ||
	!strcasecomp(test, "none") ||
	no_file_url || no_goto_file ||
	HTDirAccess == HT_DIR_FORBID ||
	HTDirAccess == HT_DIR_SELECTIVE) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(DFM_NOT_AVAILABLE);
	}
	return;
    }

    /*
     * If we are viewing a local directory listing or a local file which is not
     * temporary, invoke CSwing with the URL's directory converted to VMS path
     * specs and passed as the argument, so we start up CSwing positioned on
     * that node of the directory tree.  Otherwise, pass the current default
     * directory as the argument.  - FM
     */
    if (LYisLocalFile(curdoc.address) &&
	strncasecomp(curdoc.address,
		     lynx_temp_space, strlen(lynx_temp_space))) {
	/*
	 * We are viewing a local directory or a local file which is not
	 * temporary.  - FM
	 */
	struct stat stat_info;

	cp = HTParse(curdoc.address, "", PARSE_PATH | PARSE_PUNCTUATION);
	HTUnEscape(cp);
	if (HTStat(cp, &stat_info) == -1) {
	    CTRACE((tfp, "mainloop: Can't stat %s\n", cp));
	    FREE(cp);
	    HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	    *refresh_screen = TRUE;	/* redisplay */
	} else {
	    char *VMSdir = NULL;

	    if (S_ISDIR(stat_info.st_mode)) {
		/*
		 * We're viewing a local directory.  Make that the CSwing
		 * argument.  - FM
		 */
		LYAddPathSep(&cp);
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
	    } else {
		/*
		 * We're viewing a local file.  Make its directory the CSwing
		 * argument.  - FM
		 */
		StrAllocCopy(VMSdir, HTVMS_name("", cp));
		FREE(cp);
		if ((cp = strrchr(VMSdir, ']')) != NULL) {
		    *(cp + 1) = '\0';
		} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
		    *(cp + 1) = '\0';
		}
	    }
	    HTSprintf0(&temp, "%s %s", HTGetProgramPath(ppCSWING), VMSdir);
	    FREE(VMSdir);
	    /*
	     * Uncache the current document in case we change, move, or delete
	     * it during the CSwing session.  - FM
	     */
	    /* could use DIRED_UNCACHE_1 but it's currently only defined
	       for dired - kw */
	    HTuncache_current_document();
	    move_address(&newdoc, &curdoc);
	    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
    } else {
	/*
	 * We're not viewing a local directory or file.  Pass CSwing the
	 * current default directory as an argument and don't uncache the
	 * current document.  - FM
	 */
	HTSprintf0(&temp, "%s []", HTGetProgramPath(ppCSWING));
	*refresh_screen = TRUE;	/* redisplay */
    }
    stop_curses();
    LYSystem(temp);
    start_curses();
    FREE(temp);
#else
    /*
     * Don't do if not allowed or already viewing the menu.
     */
    if (lynx_edit_mode && !no_dired_support &&
	!LYIsUIPage(curdoc.address, UIP_DIRED_MENU) &&
	strcmp(NonNull(curdoc.title), DIRED_MENU_TITLE)) {
	dired_options(&curdoc, &newdoc.address);
	*refresh_screen = TRUE;	/* redisplay */
    }
#endif /* VMS */
}
#endif /* defined(DIRED_SUPPORT) || defined(VMS) */

static int handle_LYK_DOWNLOAD(int *cmd,
			       int *old_c,
			       int real_c)
{

    /*
     * Don't do if both download and disk_save are restricted.
     */
    if (LYValidate ||
	(no_download && !override_no_download && no_disk_save)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(DOWNLOAD_DISABLED);
	}
	return 0;
    }

    /*
     * Don't do if already viewing download options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_DOWNLOAD_OPTIONS))
	return 0;

    if (do_change_link() == -1)
	return 1;		/* mouse stuff was confused, ignore - kw */
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
	    if (links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE) {
		if (links[curdoc.link].l_form->submit_method ==
		    URL_MAIL_METHOD) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
		    }
		    return 0;
		}
		if (isLYNXOPTIONS(links[curdoc.link].l_form->submit_action)) {
		    if (*old_c != real_c) {
			*old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_SPECIAL);
		    }
		    return 0;
		}
		HTOutputFormat = HTAtom_for("www/download");
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return 2;
	    }
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_INPUT);
	    }

	} else if (isLYNXCOOKIE(curdoc.address)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_COOKIES);
	    }
	} else if (LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PRINT_OP);
	    }
#ifdef DIRED_SUPPORT
	} else if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
	    }

	} else if (LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
	    }

	} else if (lynx_edit_mode && !no_dired_support &&
		   !strstr(links[curdoc.link].lname, "/SugFile=")) {
	    /*
	     * Don't bother making a /tmp copy of the local file.
	     */
	    static DocInfo temp;

	    copy_address(&temp, &newdoc);
	    set_address(&newdoc, links[curdoc.link].lname);
	    if (LYdownload_options(&newdoc.address,
				   links[curdoc.link].lname) < 0)
		copy_address(&newdoc, &temp);
	    else
		newdoc.internal_link = FALSE;
	    LYFreeDocInfo(&temp);
#endif /* DIRED_SUPPORT */

	} else if (LYIsUIPage(curdoc.address, UIP_HISTORY) &&
		   isLYNXHIST(links[curdoc.link].lname)) {
	    int number = atoi(links[curdoc.link].lname + LEN_LYNXHIST);

	    if (number >= nhist || number < 0) {
		HTUserMsg(NO_DOWNLOAD_SPECIAL);
		return 0;
	    }
	    if ((HDOC(number).post_data != NULL &&
		 HDOC(number).safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		return 0;
	    }
	    /*
	     * OK, we download from history page, restore URL from stack.
	     */
	    copy_address(&newdoc, &HDOC(number));
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
	    StrAllocCopy(newdoc.bookmark, HDOC(number).bookmark);
	    LYFreePostData(&newdoc);
	    if (HDOC(number).post_data)
		BStrCopy(newdoc.post_data,
			 HDOC(number).post_data);
	    if (HDOC(number).post_content_type)
		StrAllocCopy(newdoc.post_content_type,
			     HDOC(number).post_content_type);
	    newdoc.isHEAD = HDOC(number).isHEAD;
	    newdoc.safe = HDOC(number).safe;
	    newdoc.internal_link = FALSE;
	    newdoc.link = (user_mode == NOVICE_MODE) ? 1 : 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    LYUserSpecifiedURL = TRUE;
	    /*
	     * Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;

	} else if (!StrNCmp(links[curdoc.link].lname, "data:", 5)) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTAlert(UNSUPPORTED_DATA_URL);
	    }

	} else if (isLYNXCOOKIE(links[curdoc.link].lname) ||
		   isLYNXCACHE(links[curdoc.link].lname) ||
		   isLYNXDIRED(links[curdoc.link].lname) ||
		   isLYNXDOWNLOAD(links[curdoc.link].lname) ||
		   isLYNXPRINT(links[curdoc.link].lname) ||
		   isLYNXOPTIONS(links[curdoc.link].lname) ||
		   isLYNXHIST(links[curdoc.link].lname) ||
	    /* handled above if valid - kw */
/* @@@@@@ should next two be downloadable? - kw */
		   isLYNXHIST(links[curdoc.link].lname) ||
		   isLYNXCFLAGS(links[curdoc.link].lname) ||
		   isLYNXEXEC(links[curdoc.link].lname) ||
		   isLYNXPROG(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_SPECIAL);

	} else if (isMAILTO_URL(links[curdoc.link].lname)) {
	    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

	    /*
	     * From here on we could have a remote host, so check if that's
	     * allowed.
	     *
	     * We copy all these checks from getfile() to LYK_DOWNLOAD here
	     * because LYNXDOWNLOAD:// will NOT be pushing the previous
	     * document into the history stack so preserve getfile() from
	     * returning a wrong status (NULLFILE).
	     */
	} else if (local_host_only &&
		   !(LYisLocalHost(links[curdoc.link].lname) ||
		     LYisLocalAlias(links[curdoc.link].lname))) {
	    HTUserMsg(ACCESS_ONLY_LOCALHOST);
	} else {		/* Not a forms, options or history link */
	    /*
	     * Follow a normal link or anchor.  Note that if it's an anchor
	     * within the same document, entire document will be downloaded.
	     */
	    set_address(&newdoc, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, LYGetHiliteStr(curdoc.link, 0));
	    /*
	     * Might be an internal link in the same doc from a POST form.  If
	     * so, don't free the content.  - kw
	     */
	    if (track_internal_links) {
		if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE) {
		    LYFreePostData(&newdoc);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		}
	    } else {
		/*
		 * Might be an anchor in the same doc from a POST form.  If so,
		 * don't free the content.  -- FM
		 */
		if (are_different(&curdoc, &newdoc)) {
		    LYFreePostData(&newdoc);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		}
	    }
	    newdoc.internal_link = FALSE;
	    newdoc.link = (user_mode == NOVICE_MODE) ? 1 : 0;
	    HTOutputFormat = HTAtom_for("www/download");
	    /*
	     * Force the document to be reloaded.
	     */
	    LYforce_no_cache = TRUE;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NO_DOWNLOAD_CHOICE);
    }
    return 0;
}

static void handle_LYK_DOWN_xxx(int *old_c,
				int real_c,
				int scroll_by)
{
    int i;

    if (more_text) {
	LYChgNewline(scroll_by);
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > scroll_by) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= scroll_by; i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_DOWN_HALF(int *old_c,
				 int real_c)
{
    handle_LYK_DOWN_xxx(old_c, real_c, display_lines / 2);
}

static void handle_LYK_DOWN_LINK(int *follow_col,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link < (nlinks - 1)) {	/* more links? */
	int newlink;

	if (*follow_col == -1) {
	    const char *text = LYGetHiliteStr(curdoc.link, 0);

	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += (int) strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, 1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (more_text) {	/* next page */
	    LYChgNewline(display_lines);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_BELOW);
	    return;
	}
    } else if (more_text) {	/* next page */
	LYChgNewline(display_lines);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_DOWN_TWO(int *old_c,
				int real_c)
{
    handle_LYK_DOWN_xxx(old_c, real_c, 2);
}

static int handle_LYK_DWIMEDIT(int *cmd,
			       int *old_c,
			       int real_c)
{
#ifdef TEXTAREA_AUTOEXTEDIT
    /*
     * If we're in a forms TEXTAREA, invoke the editor on *its* contents,
     * rather than attempting to edit the html source document.  KED
     */
    if (nlinks > 0 &&
	LinkIsTextarea(curdoc.link)) {
	*cmd = LYK_EDITTEXTAREA;
	return 2;
    }

    /*
     * If we're in a forms TEXT type, tell user the request is bogus (though in
     * reality, without this trap, if the document with the TEXT field is
     * local, the editor *would* be invoked on the source .html file; eg, the
     * o(ptions) form tempfile).
     *
     * [This is done to avoid possible user confusion, due to auto invocation
     * of the editor on the TEXTAREA's contents via the above if() statement.]
     */
    if (nlinks > 0 &&
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE) {
	HTUserMsg(CANNOT_EDIT_FIELD);
	return 1;
    }

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
	return 1;
    }
#endif /* TEXTAREA_AUTOEXTEDIT */
    return 0;
}

static int handle_LYK_ECGOTO(int *ch,
			     bstring **user_input,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 * Go to not allowed.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 * Disallow editing of File Management URLs.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     * Save the current user_input string, and load the current
     * document's address.
     */
    StrAllocCopy(*old_user_input, (*user_input)->str);
    BStrCopy0((*user_input), curdoc.address);

    /*
     * Warn the user if the current document has POST data associated with it.
     * - FM
     */
    if (curdoc.post_data)
	HTAlert(CURRENT_DOC_HAS_POST_DATA);

    /*
     * Offer the current document's URL for editing.  - FM
     */
    _statusline(EDIT_CURDOC_URL);
    if (((*ch = LYgetBString(user_input, FALSE, 0, RECALL_URL)) >= 0) &&
	!isBEmpty(*user_input) &&
	strcmp((*user_input)->str, curdoc.address)) {
	LYTrimAllStartfile((*user_input)->str);
	if (!isBEmpty(*user_input)) {
	    return 2;
	}
    }
    /*
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
     */
    HTInfoMsg(CANCELLED);
    BStrCopy0((*user_input), *old_user_input);
    FREE(*old_user_input);
    return 0;
}

static void handle_LYK_EDIT(int *old_c,
			    int real_c)
{
#ifdef DIRED_SUPPORT
    char *cp;
    char *tp = NULL;
    struct stat dir_info;
#endif /* DIRED_SUPPORT */

    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_DISABLED);
	}
    }
#ifdef DIRED_SUPPORT
    /*
     * Allow the user to edit the link rather than curdoc in edit mode.
     */
    else if (lynx_edit_mode &&
	     non_empty(editor) && !no_dired_support) {
	if (nlinks > 0) {
	    cp = links[curdoc.link].lname;
	    if (is_url(cp) == FILE_URL_TYPE) {
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(tp, cp);
		FREE(cp);

		if (stat(tp, &dir_info) == -1) {
		    HTAlert(NO_STATUS);
		} else {
		    if (S_ISREG(dir_info.st_mode)) {
			StrAllocCopy(tp, links[curdoc.link].lname);
			HTUnEscapeSome(tp, "/");
			if (edit_current_file(tp, curdoc.link, -1)) {
			    DIRED_UNCACHE_1;
			    move_address(&newdoc, &curdoc);
#ifdef NO_SEEK_OLD_POSITION
			    /*
			     * Go to top of file.
			     */
			    newdoc.line = 1;
			    newdoc.link = 0;
#else
			    /*
			     * Seek old position, which probably changed.
			     */
			    newdoc.line = curdoc.line;
			    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
			    LYclear();	/* clear the screen */
			}
		    }
		}
		FREE(tp);
	    }
	}
    }
#endif /* DIRED_SUPPORT */
    else if (non_empty(editor)) {
	if (edit_current_file(newdoc.address, curdoc.link, LYGetNewline())) {
	    HTuncache_current_document();
	    LYforce_no_cache = TRUE;	/*force reload of document */
	    free_address(&curdoc);	/* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
	    /*
	     * Go to top of file.
	     */
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    /*
	     * Seek old position, which probably changed.
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
	    LYclear();		/* clear the screen */
	}

    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    }
}

static void handle_LYK_DWIMHELP(const char **cshelpfile)
{
    /*
     * Currently a help file different from the main 'helpfile' is shown only
     * if current link is a text input form field.  - kw
     */
    if (curdoc.link >= 0 && curdoc.link < nlinks &&
	!FormIsReadonly(links[curdoc.link].l_form) &&
	LinkIsTextLike(curdoc.link)) {
	*cshelpfile = STR_LYNXEDITMAP;
    }
}

static void handle_LYK_EDITMAP(int *old_c,
			       int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	set_address(&newdoc, STR_LYNXEDITMAP);
	StrAllocCopy(newdoc.title, CURRENT_EDITMAP_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	/*
	 * Remember whether we are in dired menu so we can display the right
	 * keymap.
	 */
	if (!no_dired_support) {
	    prev_lynx_edit_mode = lynx_edit_mode;
	}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	LYforce_no_cache = TRUE;
    }
}

static void handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
{
    if (no_editor) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(ANYEDIT_DISABLED);
	}
    } else if (isEmpty(editor)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_EDITOR);
	}
    } else if (LinkIsTextarea(curdoc.link)) {
	/*
	 * if the current link is in a form TEXTAREA, it requires handling
	 * for the possible multiple lines.
	 */

	/* stop screen */
	stop_curses();

	(void) HText_EditTextArea(&links[curdoc.link]);

	/*
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st trailing blank line in the now edited TEXTAREA.  If the target
	 * line/ anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
	 */

	/* curdoc.link += n; */
	/* works, except for page crossing, */
	/* damnit; why is nothing ever easy */

	/* start screen */
	start_curses();
	*refresh_screen = TRUE;

    } else if (LinkIsTextLike(curdoc.link)) {
	/*
	 * other text fields are single-line
	 */
	stop_curses();
	HText_EditTextField(&links[curdoc.link]);
	start_curses();
	*refresh_screen = TRUE;
    } else {

	HTInfoMsg(NOT_IN_TEXTAREA_NOEDIT);
    }
}

static int handle_LYK_ELGOTO(int *ch,
			     bstring **user_input,
			     char **old_user_input,
			     int *old_c,
			     int real_c)
{
    if (no_goto && !LYValidate) {
	/*
	 * Go to not allowed.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return 0;
    }
    if (!(nlinks > 0 && curdoc.link > -1) ||
	(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	 links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	 links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE)) {
	/*
	 * No links on page, or not a normal link or form submit button.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	}
	return 0;
    }
    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
	(isEmpty(links[curdoc.link].l_form->submit_action))) {
	/*
	 * Form submit button with no ACTION defined.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_FORM_ACTION);
	}
	return 0;
    }
#ifdef DIRED_SUPPORT
    if (isLYNXDIRED(links[curdoc.link].lname) ||
	LYIsUIPage(curdoc.address, UIP_DIRED_MENU) ||
	LYIsUIPage(curdoc.address, UIP_PERMIT_OPTIONS) ||
	LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS)) {
	/*
	 * Disallow editing of File Management URLs.  - FM
	 */
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
	}
	return 0;
    }
#endif /* DIRED_SUPPORT */

    /*
     * Save the current user_input string, and load the current link's
     * address.  - FM
     */
    StrAllocCopy(*old_user_input, (*user_input)->str);
    BStrCopy0((*user_input),
	      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
	       ? links[curdoc.link].l_form->submit_action
	       : links[curdoc.link].lname));
    /*
     * Offer the current link's URL for editing.  - FM
     */
    _statusline(EDIT_CURLINK_URL);
    if (((*ch = LYgetBString(user_input, FALSE, 0, RECALL_URL)) >= 0) &&
	!isBEmpty(*user_input) &&
	strcmp((*user_input)->str,
	       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
		? links[curdoc.link].l_form->submit_action
		: links[curdoc.link].lname))) {
	LYTrimAllStartfile((*user_input)->str);
	if (!isBEmpty(*user_input)) {
	    return 2;
	}
    }
    /*
     * User cancelled via ^G, a full deletion, or not modifying the URL.  - FM
     */
    HTInfoMsg(CANCELLED);
    BStrCopy0((*user_input), *old_user_input);
    FREE(*old_user_input);
    return 0;
}

#ifdef USE_EXTERNALS
static void handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)
{
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL)) {
	run_external(links[curdoc.link].lname, FALSE);
	*refresh_screen = TRUE;
    }
}

static void handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)
{
    if (curdoc.address != NULL) {
	run_external(curdoc.address, FALSE);
	*refresh_screen = TRUE;
    }
}
#endif

static BOOLEAN handle_LYK_FASTBACKW_LINK(int *cmd,
					 int *old_c,
					 int real_c)
{
    int samepage = 0, nextlink = curdoc.link;
    int res;
    BOOLEAN code = FALSE;

    if (nlinks > 1) {

	/*
	 * If in textarea, move to first link or textarea group before it if
	 * there is one on this screen.  - kw
	 */
	if (LinkIsTextarea(curdoc.link)) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link > 0 &&
		!(LinkIsTextarea(0) &&
		  links[0].l_form->number == thisgroup &&
		  sametext(links[0].l_form->name, thisname))) {
		do
		    nextlink--;
		while
		    (LinkIsTextarea(nextlink) &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;

	    } else if (!more_text && LYGetNewline() == 1 &&
		       (LinkIsTextarea(0) &&
			links[0].l_form->number == thisgroup &&
			sametext(links[0].l_form->name, thisname)) &&
		       !(LinkIsTextarea(nlinks - 1) &&
			 links[nlinks - 1].l_form->number == thisgroup &&
			 sametext(links[nlinks - 1].l_form->name, thisname))) {
		nextlink = nlinks - 1;
		samepage = 1;

	    } else if (!more_text && LYGetNewline() == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link > 0) {
	    nextlink--;
	    samepage = 1;
	} else if (!more_text && LYGetNewline() == 1) {
	    nextlink = nlinks - 1;
	    samepage = 1;
	}
    }

    if (samepage) {
	/*
	 * If the link as determined so far is part of a group of textarea
	 * fields, try to use the first of them that's on the screen instead.
	 * - kw
	 */
	if (nextlink > 0 &&
	    LinkIsTextarea(nextlink)) {
	    int thisgroup = links[nextlink].l_form->number;
	    char *thisname = links[nextlink].l_form->name;

	    if (LinkIsTextarea(0) &&
		links[0].l_form->number == thisgroup &&
		sametext(links[0].l_form->name, thisname)) {
		nextlink = 0;
	    } else
		while
		    (nextlink > 1 &&
		     LinkIsTextarea(nextlink - 1) &&
		     links[nextlink - 1].l_form->number == thisgroup &&
		     sametext(links[nextlink - 1].l_form->name, thisname)) {
		    nextlink--;
		}
	}
	set_curdoc_link(nextlink);

    } else if (LYGetNewline() > 1 &&	/* need a previous page */
	       (res = HTGetLinkOrFieldStart(curdoc.link,
					    &Newline, &newdoc.link,
					    -1, TRUE)) != NO) {
	if (res == LINK_DO_ARROWUP) {
	    /*
	     * It says we should use the normal PREV_LINK mechanism, so we'll
	     * do that.  - kw
	     */
	    if (nlinks > 0)
		curdoc.link = 0;
	    *cmd = LYK_PREV_LINK;
	    code = TRUE;
	} else {
	    LYChgNewline(1);	/* our line counting starts with 1 not 0 */
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_ABOVE);
    }
    return code;
}

static void handle_LYK_FASTFORW_LINK(int *old_c,
				     int real_c)
{
    int samepage = 0, nextlink = curdoc.link;

    if (nlinks > 1) {

	/*
	 * If in textarea, move to first link or field after it if there is one
	 * on this screen.  - kw
	 */
	if (LinkIsTextarea(curdoc.link)) {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    if (curdoc.link < nlinks - 1 &&
		!(LinkIsTextarea(nlinks - 1) &&
		  links[nlinks - 1].l_form->number == thisgroup &&
		  sametext(links[nlinks - 1].l_form->name, thisname))) {
		do
		    nextlink++;
		while
		    (LinkIsTextarea(nextlink) &&
		     links[nextlink].l_form->number == thisgroup &&
		     sametext(links[nextlink].l_form->name, thisname));
		samepage = 1;
	    } else if (!more_text && LYGetNewline() == 1 && curdoc.link > 0) {
		nextlink = 0;
		samepage = 1;
	    }
	} else if (curdoc.link < nlinks - 1) {
	    nextlink++;
	    samepage = 1;
	} else if (!more_text && LYGetNewline() == 1 && curdoc.link > 0) {
	    nextlink = 0;
	    samepage = 1;
	}
    }

    if (samepage) {
	set_curdoc_link(nextlink);
    } else if (!more_text && LYGetNewline() == 1 && curdoc.link == nlinks - 1) {
	/*
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
	 */
	set_curdoc_link(0);

    } else if (more_text &&	/* need a later page */
	       HTGetLinkOrFieldStart(curdoc.link,
				     &Newline, &newdoc.link,
				     1, TRUE) != NO) {
	LYChgNewline(1);	/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(NO_LINKS_BELOW);
    }
    return;
}

static void handle_LYK_FIRST_LINK(void)
{
    int i = curdoc.link;

    for (;;) {
	if (--i < 0
	    || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i + 1);
	    break;
	}
    }
}

static BOOLEAN handle_LYK_GOTO(int *ch,
			       bstring **user_input,
			       char **old_user_input,
			       RecallType * recall,
			       int *URLTotal,
			       int *URLNum,
			       BOOLEAN *FirstURLRecall,
			       int *old_c,
			       int real_c)
{

    if (no_goto && !LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(GOTO_DISALLOWED);
	}
	return FALSE;
    }

    StrAllocCopy(*old_user_input, (*user_input)->str);
    if (!goto_buffer)
	BStrCopy0((*user_input), "");

    *URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
    if (goto_buffer && !isBEmpty(*user_input)) {
	*recall = ((*URLTotal > 1) ? RECALL_URL : NORECALL);
	*URLNum = 0;
	*FirstURLRecall = FALSE;
    } else {
	*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
	*URLNum = *URLTotal;
	*FirstURLRecall = TRUE;
    }

    /*
     * Ask the user.
     */
    _statusline(URL_TO_OPEN);
    if ((*ch = LYgetBString(user_input, FALSE, 0, *recall)) < 0) {
	/*
	 * User cancelled the Goto via ^G.  Restore user_input and
	 * break.  - FM
	 */
	BStrCopy0((*user_input), *old_user_input);
	FREE(*old_user_input);
	HTInfoMsg(CANCELLED);
	return FALSE;
    }
    return TRUE;
}

static void handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)
{
    /*
     * See if the current link is in a form TEXTAREA.
     */
    if (LinkIsTextarea(curdoc.link)) {

	HText_ExpandTextarea(&links[curdoc.link], TEXTAREA_EXPAND_SIZE);

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA);
    }
}

static BOOLEAN handle_LYK_HEAD(int *cmd)
{
    int c;

    if (nlinks > 0 &&
	(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
	 links[curdoc.link].l_form->type == F_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_IMAGE_SUBMIT_TYPE ||
	 links[curdoc.link].l_form->type == F_TEXT_SUBMIT_TYPE)) {
	/*
	 * We have links, and the current link is a normal link or a form's
	 * submit button.  - FM
	 */
	_statusline(HEAD_D_L_OR_CANCEL);
	c = LYgetch_single();
	if (c == 'D') {
	    char *scheme = !isLYNXIMGMAP(curdoc.address)
	    ? curdoc.address
	    : curdoc.address + LEN_LYNXIMGMAP;

	    if (LYCanDoHEAD(scheme) != TRUE) {
		HTUserMsg(DOC_NOT_HTTP_URL);
	    } else {
		/*
		 * Check if this is a reply from a POST, and if so, seek
		 * confirmation if the safe element is not set.  - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HText_setNoCache(HTMainText);
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
		}
	    }
	} else if (c == 'L') {
	    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		StrNCmp(links[curdoc.link].lname, "http", 4) &&
		StrNCmp(links[curdoc.link].lname, "LYNXIMGMAP:http", 15) &&
		LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
		(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
		 !curdoc.address ||
		 StrNCmp(curdoc.address, "http", 4))) {
		HTUserMsg(LINK_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       FormIsReadonly(links[curdoc.link].l_form)) {
		HTUserMsg(FORM_ACTION_DISABLED);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->submit_action != 0 &&
		       !isLYNXCGI(links[curdoc.link].l_form->submit_action) &&
		       StrNCmp(links[curdoc.link].l_form->submit_action,
			       "http", 4)) {
		HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
	    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		       links[curdoc.link].l_form->submit_method ==
		       URL_POST_METHOD &&
		       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
		HTInfoMsg(CANCELLED);
	    } else {
		HEAD_request = TRUE;
		LYforce_no_cache = TRUE;
		*cmd = LYK_ACTIVATE;
		return TRUE;
	    }
	}
    } else {
	/*
	 * We can offer only this document for a HEAD request.  Check if this
	 * is a reply from a POST, and if so, seek confirmation if the safe
	 * element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
	    HTInfoMsg(CANCELLED);
	} else {
	    if (nlinks > 0) {
		/*
		 * The current link is a non-submittable form link, so prompt
		 * the user to make it clear that the HEAD request would be for
		 * the current document, not the form link.  - FM
		 */
		_statusline(HEAD_D_OR_CANCEL);
		c = LYgetch_single();
	    } else {
		/*
		 * No links, so we can just assume that the user wants a HEAD
		 * request for the current document.  - FM
		 */
		c = 'D';
	    }
	    if (c == 'D') {
		char *scheme = !isLYNXIMGMAP(curdoc.address)
		? curdoc.address
		: curdoc.address + LEN_LYNXIMGMAP;

		/*
		 * The user didn't cancel, so check if a HEAD request is
		 * appropriate for the current document.  - FM
		 */
		if (LYCanDoHEAD(scheme) != TRUE) {
		    HTUserMsg(DOC_NOT_HTTP_URL);
		} else {
		    HEAD_request = TRUE;
		    LYforce_no_cache = TRUE;
		    StrAllocCopy(newdoc.title, curdoc.title);
		    if (HTLoadedDocumentIsHEAD()) {
			HText_setNoCache(HTMainText);
			free_address(&curdoc);
		    } else {
			StrAllocCat(newdoc.title, " - HEAD");
		    }
		}
	    }
	}
    }
    return FALSE;
}

static void handle_LYK_HELP(const char **cshelpfile)
{
    char *my_value = NULL;

    if (*cshelpfile == NULL)
	*cshelpfile = helpfile;
    StrAllocCopy(my_value, *cshelpfile);
    LYEnsureAbsoluteURL(&my_value, *cshelpfile, FALSE);
    if (!STREQ(curdoc.address, my_value)) {
	/*
	 * Set the filename.
	 */
	set_address(&newdoc, my_value);
	/*
	 * Make a name for this help file.
	 */
	StrAllocCopy(newdoc.title, gettext("Help Screen"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    }
    FREE(my_value);
    *cshelpfile = NULL;		/* reset pointer - kw */
}

static void handle_LYK_HISTORICAL(void)
{
#ifdef USE_SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    historical_comments = (BOOLEAN) !historical_comments;
    if (minimal_comments) {
	HTAlert(historical_comments ?
		HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
    } else {
	HTAlert(historical_comments ?
		HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
    }
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

static BOOLEAN handle_LYK_HISTORY(int ForcePush)
{
    if (curdoc.title && !LYIsUIPage(curdoc.address, UIP_HISTORY)) {
	/*
	 * Don't do this if already viewing history page.
	 *
	 * Push the current file so that the history list contains the current
	 * file for printing purposes.  Pop the file afterwards to prevent
	 * multiple copies.
	 */
	if (TRACE && !LYUseTraceLog && LYCursesON) {
	    LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
	    LYaddstr("\n");
#endif /* USE_SLANG */
	    LYrefresh();
	}
	LYpush(&curdoc, ForcePush);

	/*
	 * Print history options to file.
	 */
	if (showhistory(&newdoc.address) < 0) {
	    LYpop(&curdoc);
	    return TRUE;
	}
	LYRegisterUIPage(newdoc.address, UIP_HISTORY);
	StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	newdoc.link = 1;	/*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);	/* so it doesn't get pushed */

	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
	return TRUE;
    }				/* end if StrNCmp */
    return FALSE;
}

static BOOLEAN handle_LYK_IMAGE_TOGGLE(int *cmd)
{
    clickable_images = (BOOLEAN) !clickable_images;

    HTUserMsg(clickable_images ?
	      CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
    return reparse_or_reload(cmd);
}

static void handle_LYK_INDEX(int *old_c,
			     int real_c)
{
    /*
     * Make sure we are not in the index already.
     */
    if (!STREQ(curdoc.address, indexfile)) {

	if (indexfile[0] == '\0') {	/* no defined index */
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NO_INDEX_FILE);
	    }

	} else {
#ifdef KANJI_CODE_OVERRIDE
	    if (HTCJK == JAPANESE) {
		last_kcode = NOKANJI;	/* AUTO */
	    }
#endif
#ifdef USE_PROGRAM_DIR
	    if (is_url(indexfile) == 0) {
		char *tmp = NULL;

		HTSprintf0(&tmp, "%s\\%s", program_dir, indexfile);
		FREE(indexfile);
		LYLocalFileToURL(&indexfile, tmp);
		FREE(tmp);
	    }
#endif
	    set_address(&newdoc, indexfile);
	    StrAllocCopy(newdoc.title, gettext("System Index"));	/* name it */
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	}			/* end else */
    }				/* end if */
}

static void handle_LYK_INDEX_SEARCH(BOOLEAN *force_load,
				    int ForcePush,
				    int *old_c,
				    int real_c)
{
    if (is_www_index) {
	/*
	 * Perform a database search.
	 *
	 * do_www_search will try to go out and get the document.  If it
	 * returns TRUE, a new document was returned and is named in the
	 * newdoc.address.
	 */
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	if (do_www_search(&newdoc) == NORMAL) {
	    /*
	     * Yah, the search succeeded.
	     */
	    if (TRACE && !LYUseTraceLog && LYCursesON) {
		/*
		 * Make sure cursor is down.
		 */
		LYHideCursor();
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	    LYpush(&curdoc, ForcePush);
	    /*
	     * Make the curdoc.address the newdoc.address so that getfile
	     * doesn't try to get the newdoc.address.  Since we have already
	     * gotten it.
	     */
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type, curdoc.post_content_type);
	    newdoc.internal_link = FALSE;
	    curdoc.line = -1;
	    LYSetNewline(0);
	} else if (use_this_url_instead != NULL) {
	    /*
	     * Got back a redirecting URL.  Check it out.
	     */
	    HTUserMsg2(WWW_USING_MESSAGE, use_this_url_instead);

	    /*
	     * Make a name for this URL.
	     */
	    StrAllocCopy(newdoc.title,
			 "A URL specified by redirection");
	    set_address(&newdoc, use_this_url_instead);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    FREE(use_this_url_instead);
	    *force_load = TRUE;
	} else {
	    /*
	     * Yuk, the search failed.  Restore the old file.
	     */
	    copy_address(&newdoc, &curdoc);
	    BStrCopy(newdoc.post_data, curdoc.post_data);
	    StrAllocCopy(newdoc.post_content_type,
			 curdoc.post_content_type);
	    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
	    newdoc.isHEAD = curdoc.isHEAD;
	    newdoc.safe = curdoc.safe;
	    newdoc.internal_link = curdoc.internal_link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(NOT_ISINDEX);
    }
}

static BOOLEAN handle_LYK_INFO(int *cmd)
{
    /*
     * Don't do if already viewing info page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_SHOWINFO)) {
	if (do_change_link() != -1
	    && LYShowInfo(&curdoc, &newdoc, owner_address) >= 0) {
	    LYRegisterUIPage(newdoc.address, UIP_SHOWINFO);
	    StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYforce_no_cache = TRUE;
	    if (LYValidate || check_realm)
		LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in info page, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
    return FALSE;
}

static BOOLEAN handle_LYK_INLINE_TOGGLE(int *cmd)
{
    pseudo_inline_alts = (BOOLEAN) !pseudo_inline_alts;

    HTUserMsg(pseudo_inline_alts ?
	      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
    return reparse_or_reload(cmd);
}

static void handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen,
				   int *old_c,
				   int real_c)
{
    /*
     * See if the current link is in a form TEXTAREA.
     */
    if (LinkIsTextarea(curdoc.link)) {

	/*
	 * Reject attempts to use this for gaining access to local files when
	 * such access is restricted:  if no_file_url was set via the file_url
	 * restriction, if no_goto_file was set for the anonymous account, or
	 * if HTDirAccess was set to HT_DIR_FORBID or HT_DIR_SELECTIVE via the
	 * -nobrowse or -selective switches, it is assumed that inserting files
	 * or checking for existence of files needs to be denied.  - kw
	 */
	if (no_file_url || no_goto_file ||
	    HTDirAccess == HT_DIR_FORBID ||
	    HTDirAccess == HT_DIR_SELECTIVE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		if (no_goto_file)
		    HTUserMsg2(GOTO_XXXX_DISALLOWED, STR_FILE_URL);
		else
		    HTUserMsg(NOAUTH_TO_ACCESS_FILES);
		HTInfoMsg(FILE_INSERT_CANCELLED);
	    }
	    return;
	}

	(void) HText_InsertFile(&links[curdoc.link]);

	/*
	 * TODO:
	 * Move cursor "n" lines from the current line to position it on the
	 * 1st line following the text that was inserted.  If the target
	 * line/anchor requires us to scroll up/down, position the target in
	 * the approximate center of the screen.
	 *
	 * [Current behavior leaves cursor on the same line relative to the
	 * start of the TEXTAREA that it was on before the insertion.  This is
	 * the same behavior that occurs with (my) editor, so this TODO will
	 * stay unimplemented.]
	 */

	*refresh_screen = TRUE;

    } else {

	HTInfoMsg(NOT_IN_TEXTAREA);
    }
}

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
static void handle_LYK_INSTALL(void)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
	local_install(NULL, links[curdoc.link].lname, &newdoc.address);
}
#endif

static const char *hexy = "0123456789ABCDEF";

#define HEX(n) hexy[(n) & 0xf]
/*
 * URL-encode a parameter which can then be appended to a URI.
 * RFC-3986 lists reserved characters, which should be encoded.
 */
static char *urlencode(char *str)
{
    char *result = NULL;
    char *ptr;
    int ch;

    if (str != NULL) {
	result = malloc(strlen(str) * 3 + 1);
	ptr = result;

	assert(result);

	while ((ch = UCH(*str++)) != 0) {
	    if (ch == ' ') {
		*ptr = '+';
		ptr++;
	    } else if (ch > 127 ||
		       StrChr(":/?#[]@@!$&'()*+,;=", ch) != 0) {
		*ptr++ = '%';
		*ptr++ = HEX(ch >> 4);
		*ptr++ = HEX(ch);
	    } else {
		*ptr++ = (char) ch;
	    }
	}
	*ptr = '\0';
    }

    return result;
}

/*
 * Fill in "%s" marker(s) in the url_template by prompting the user for the
 * values.
 */
static BOOLEAN check_JUMP_param(char **url_template)
{
    int param = 1;
    char *subs;
    char *result = *url_template;
    char *encoded = NULL;
    int code = TRUE;
    bstring *input = NULL;

    CTRACE((tfp, "check_JUMP_param: %s\n", result));

    while ((subs = strstr(result, "%s")) != 0) {
	char prompt[MAX_LINE];
	RecallType recall = NORECALL;

	CTRACE((tfp, "Prompt for query param%d: %s\n", param, result));

	sprintf(prompt, gettext("Query parameter %d: "), param++);
	statusline(prompt);
	BStrCopy0(input, "");

	if (encoded)
	    FREE(encoded);

	if (LYgetBString(&input, FALSE, 0, recall) < 0) {
	    /*
	     * cancelled via ^G
	     */
	    HTInfoMsg(CANCELLED);
	    code = FALSE;
	    break;
	} else if ((encoded = urlencode(input->str)) != '\0') {
	    int subs_at = (int) (subs - result);
	    int fill_in = (int) strlen(encoded) - 2;
	    size_t have = strlen(result);
	    size_t want = strlen(encoded) + have - 1;
	    int n;
	    char *update = realloc(result, want + 1);

	    if (update == 0) {
		HTInfoMsg(NOT_ENOUGH_MEMORY);
		code = FALSE;
		break;
	    }

	    CTRACE((tfp, "  reply: %s\n", input->str));
	    CTRACE((tfp, "  coded: %s\n", encoded));

	    result = update;
	    result[want] = '\0';
	    for (n = (int) want; (n - fill_in) >= subs_at; --n) {
		result[n] = result[n - fill_in];
	    }
	    for (n = subs_at; encoded[n - subs_at] != '\0'; ++n) {
		result[n] = encoded[n - subs_at];
	    }
	    CTRACE((tfp, "  subst: %s\n", result));
	} else {
	    HTInfoMsg(CANCELLED);
	    code = FALSE;
	    break;
	}
    }
    BStrFree(input);
    FREE(encoded);
    *url_template = result;
    return (BOOLEAN) code;
}

static void fill_JUMP_Params(char **addressp)
{
    if (LYJumpFileURL) {
	check_JUMP_param(addressp);
    }
}

static BOOLEAN handle_LYK_JUMP(int c,
			       bstring **user_input,
			       char **old_user_input GCC_UNUSED,
			       RecallType * recall GCC_UNUSED,
			       BOOLEAN *FirstURLRecall GCC_UNUSED,
			       int *URLNum GCC_UNUSED,
			       int *URLTotal GCC_UNUSED,
			       int *ch GCC_UNUSED,
			       int *old_c,
			       int real_c)
{
    char *ret;

    if (no_jump || JThead == NULL) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    if (no_jump)
		HTUserMsg(JUMP_DISALLOWED);
	    else
		HTUserMsg(NO_JUMPFILE);
	}
    } else {
	LYJumpFileURL = TRUE;
	if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
	    if (!strncasecomp(ret, "Go ", 3)) {
		LYJumpFileURL = FALSE;
		StrAllocCopy(*old_user_input, (*user_input)->str);
		*URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
		*recall = ((*URLTotal >= 1) ? RECALL_URL : NORECALL);
		*URLNum = *URLTotal;
		*FirstURLRecall = TRUE;
		if (!strcasecomp(ret, "Go :")) {
		    if (recall) {
			*ch = UPARROW_KEY;
			return TRUE;
		    }
		    FREE(*old_user_input);
		    HTUserMsg(NO_RANDOM_URLS_YET);
		    return FALSE;
		}
		ret = HTParse((ret + 3), startfile, PARSE_ALL);
		BStrCopy0((*user_input), ret);
		FREE(ret);
		return TRUE;
	    }
#endif /* PERMIT_GOTO_FROM_JUMP */
	    ret = HTParse(ret, startfile, PARSE_ALL);
	    if (!LYTrimStartfile(ret)) {
		LYRemoveBlanks((*user_input)->str);
	    }
	    if (check_JUMP_param(&ret)) {
		set_address(&newdoc, ret);
		StrAllocCopy(lynxjumpfile, ret);
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYUserSpecifiedURL = TRUE;
	    }
	    FREE(ret);
	} else {
	    LYJumpFileURL = FALSE;
	}
    }
    return FALSE;
}

static void handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag,
			      BOOLEAN *emacs_keys_flag,
			      int *old_c,
			      int real_c)
{
    if (*old_c != real_c) {
	*old_c = real_c;
	set_address(&newdoc, STR_LYNXKEYMAP);
	StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 * If vi_keys changed, the keymap did too, so force no cache, and reset
	 * the flag.  - FM
	 */
	if (*vi_keys_flag != vi_keys ||
	    *emacs_keys_flag != emacs_keys) {
	    LYforce_no_cache = TRUE;
	    *vi_keys_flag = vi_keys;
	    *emacs_keys_flag = emacs_keys;
	}
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	/*
	 * Remember whether we are in dired menu so we can display the right
	 * keymap.
	 */
	if (!no_dired_support) {
	    prev_lynx_edit_mode = lynx_edit_mode;
	}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
	LYforce_no_cache = TRUE;
    }
}

static void handle_LYK_LAST_LINK(void)
{
    int i = curdoc.link;

    for (;;) {
	if (++i >= nlinks
	    || links[i].ly != links[curdoc.link].ly) {
	    set_curdoc_link(i - 1);
	    break;
	}
    }
}

static void handle_LYK_LEFT_LINK(void)
{
    if (curdoc.link > 0 &&
	links[curdoc.link].ly == links[curdoc.link - 1].ly) {
	set_curdoc_link(curdoc.link - 1);
    }
}

static BOOLEAN handle_LYK_LIST(int *cmd)
{
    /*
     * Don't do if already viewing list page.
     */
    if (!strcmp(NonNull(curdoc.title), LIST_PAGE_TITLE) &&
	LYIsUIPage(curdoc.address, UIP_LIST_PAGE)) {
	/*
	 * Already viewing list page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print list page to file.
     */
    if (showlist(&newdoc, TRUE) < 0)
	return FALSE;
    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
    /*
     * showlist will set newdoc's other fields.  It may leave post_data intact
     * so the list can be used to follow internal links in the current document
     * even if it is a POST response.  - kw
     */

    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlistfile, newdoc.address);
    }
    return FALSE;
}

static void handle_LYK_MAIN_MENU(int *old_c,
				 int real_c)
{
    /*
     * If its already the homepage then don't reload it.
     */
    if (!STREQ(curdoc.address, homepage)) {

	if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
	    set_address(&newdoc, homepage);
	    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    LYhighlight(FALSE, curdoc.link, prev_target->str);
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
#endif /* DIRED_SUPPORT */
	}
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(IN_MAIN_SCREEN);
	}
    }
}

static void handle_LYK_MINIMAL(void)
{
    if (!historical_comments) {
#ifdef USE_SOURCE_CACHE
	if (!HTcan_reparse_document()) {
#endif
	    /*
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HText_setNoCache(HTMainText);
		move_address(&newdoc, &curdoc);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef USE_SOURCE_CACHE
	}			/* end if no bypass */
#endif
    }
    minimal_comments = (BOOLEAN) !minimal_comments;
    if (!historical_comments) {
	HTAlert(minimal_comments ?
		MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
    } else {
	HTAlert(minimal_comments ?
		MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
    }
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

#if defined(DIRED_SUPPORT)
static void handle_LYK_MODIFY(BOOLEAN *refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int ret;

	ret = local_modify(&curdoc, &newdoc.address);
	if (ret == PERMIT_FORM_RESULT) {	/* Permit form thrown up */
	    *refresh_screen = TRUE;
	} else if (ret) {
	    DIRED_UNCACHE_1;
	    move_address(&newdoc, &curdoc);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	    LYclear();
	}
    }
}
#endif /* DIRED_SUPPORT */

#ifdef EXP_NESTED_TABLES
static BOOLEAN handle_LYK_NESTED_TABLES(int *cmd)
{
    nested_tables = (BOOLEAN) !nested_tables;
    HTUserMsg(nested_tables ? NESTED_TABLES_ON : NESTED_TABLES_OFF);
    return reparse_or_reload(cmd);
}
#endif

static BOOLEAN handle_LYK_OPTIONS(int *cmd,
				  BOOLEAN *refresh_screen)
{
#ifndef NO_OPTION_MENU
    if (!LYUseFormsOptions) {
	BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	BOOLEAN verbose_img_flag = verbose_img;
	BOOLEAN keypad_mode_flag = (BOOL) keypad_mode;
	BOOLEAN show_dotfiles_flag = show_dotfiles;
	BOOLEAN user_mode_flag = (BOOL) user_mode;
	int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	int CurrentCharSet_flag = current_char_set;
	int HTfileSortMethod_flag = HTfileSortMethod;
	char *CurrentUserAgent = NULL;
	char *CurrentNegoLanguage = NULL;
	char *CurrentNegoCharset = NULL;

	StrAllocCopy(CurrentUserAgent, NonNull(LYUserAgent));
	StrAllocCopy(CurrentNegoLanguage, NonNull(language));
	StrAllocCopy(CurrentNegoCharset, NonNull(pref_charset));

	LYoptions(); /** do the old-style options stuff **/

	if (keypad_mode_flag != keypad_mode ||
	    (user_mode_flag != user_mode &&
	     (user_mode_flag == NOVICE_MODE ||
	      user_mode == NOVICE_MODE)) ||
	    (((HTfileSortMethod_flag != HTfileSortMethod) ||
	      (show_dotfiles_flag != show_dotfiles)) &&
	     (isFILE_URL(curdoc.address) ||
	      isFTP_URL(curdoc.address))) ||
	    CurrentCharSet_flag != current_char_set ||
	    CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
	    verbose_img_flag != verbose_img ||
	    LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
	    LYSelectPopups_flag != LYSelectPopups ||
	    ((strcmp(CurrentUserAgent, NonNull(LYUserAgent)) ||
	      strcmp(CurrentNegoLanguage, NonNull(language)) ||
	      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
	     (!StrNCmp(curdoc.address, "http", 4) ||
	      isLYNXCGI(curdoc.address)))) {

	    BOOLEAN canreparse_post = FALSE;

	    /*
	     * Check if this is a reply from a POST, and if so, seek
	     * confirmation of reload if the safe element is not set.  - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
#ifdef USE_SOURCE_CACHE
		(!(canreparse_post = HTcan_reparse_document())) &&
#endif
		confirm_post_resub(curdoc.address, curdoc.title,
				   2, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		copy_address(&newdoc, &curdoc);
		if (((strcmp(CurrentUserAgent, NonNull(LYUserAgent)) ||
		      strcmp(CurrentNegoLanguage, NonNull(language)) ||
		      strcmp(CurrentNegoCharset, NonNull(pref_charset))) &&
		     (StrNCmp(curdoc.address, "http", 4) == 0 ||
		      !isLYNXCGI(curdoc.address) == 0))) {
		    /*
		     * An option has changed which may influence content
		     * negotiation, and the resource is from a http or https or
		     * lynxcgi URL (the only protocols which currently do
		     * anything with this information).  Set reloading = TRUE
		     * so that proxy caches will be flushed, which is necessary
		     * until the time when all proxies understand HTTP 1.1
		     * Vary:  and all Servers properly use it...  Treat like
		     * case LYK_RELOAD (see comments there).  - KW
		     */
		    reloading = TRUE;
		}
		if (HTisDocumentSource()) {
		    srcmode_for_next_retrieval(1);
		}
#ifdef USE_SOURCE_CACHE
		if (reloading == FALSE) {
		    /* one more attempt to be smart enough: */
		    if (reparse_document()) {
			FREE(CurrentUserAgent);
			FREE(CurrentNegoLanguage);
			FREE(CurrentNegoCharset);
			return FALSE;
		    }
		}
#endif
		if (canreparse_post &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    if (HTisDocumentSource()) {
			srcmode_for_next_retrieval(0);
		    }
		    FREE(CurrentUserAgent);
		    FREE(CurrentNegoLanguage);
		    FREE(CurrentNegoCharset);
		    return FALSE;
		}

		HEAD_request = HTLoadedDocumentIsHEAD();
		HText_setNoCache(HTMainText);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
		LYforce_no_cache = TRUE;
		free_address(&curdoc);	/* So it doesn't get pushed. */
	    }
	}
	FREE(CurrentUserAgent);
	FREE(CurrentNegoLanguage);
	FREE(CurrentNegoCharset);
	*refresh_screen = TRUE;	/* to repaint screen */
	return FALSE;
    }				/* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
    /*
     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
     * done in postoptions(), called from getfile() currently.
     *
     * postoptions() is also responsible for reloading the document
     * before the 'options menu' but only when (a few) important
     * options were changed.
     *
     * It is critical that post_data is freed here since the
     * submission of changed options is done via the same protocol as
     * LYNXOPTIONS:
     */
    /*
     * Don't do if already viewing options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_OPTIONS_MENU)) {

	set_address(&newdoc, LYNXOPTIONS_PAGE("/"));
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	LYforce_no_cache = TRUE;
	/* change to 'if (check_realm && !LYValidate)' and
	   make change near top of getfile to forbid
	   using forms options menu with -validate:  - kw */
	if (LYValidate || check_realm) {
	    LYPermitURL = TRUE;
	}
    } else {
	/*
	 * If already in the options menu, get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }
#endif /* !NO_OPTION_FORMS */
    return FALSE;
}

static void handle_NEXT_DOC(void)
{
    if (LYhist_next(&curdoc, &newdoc)) {
	free_address(&curdoc);	/* avoid push */
	return;
    }
    HTUserMsg(gettext("No next document present"));
}

static void handle_LYK_NEXT_LINK(int c,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link < nlinks - 1) {	/* next link */
	LYhighlight(FALSE, curdoc.link, prev_target->str);
#ifdef FASTTAB
	/*
	 * Move to different textarea if TAB in textarea.
	 */
	if (LinkIsTextarea(curdoc.link) &&
	    c == '\t') {
	    int thisgroup = links[curdoc.link].l_form->number;
	    char *thisname = links[curdoc.link].l_form->name;

	    do
		curdoc.link++;
	    while ((curdoc.link < nlinks - 1) &&
		   LinkIsTextarea(curdoc.link) &&
		   links[curdoc.link].l_form->number == thisgroup &&
		   sametext(links[curdoc.link].l_form->name, thisname));
	} else {
	    curdoc.link++;
	}
#else
	curdoc.link++;
#endif /* FASTTAB */
	/*
	 * At the bottom of list and there is only one page.  Move to the top
	 * link on the page.
	 */
    } else if (!more_text && LYGetNewline() == 1 && curdoc.link == nlinks - 1) {
	set_curdoc_link(0);

    } else if (more_text) {	/* next page */
	LYChgNewline(display_lines);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static void handle_LYK_NEXT_PAGE(int *old_c,
				 int real_c)
{
    if (more_text) {
	LYChgNewline(display_lines);
    } else if (curdoc.link < nlinks - 1) {
	set_curdoc_link(nlinks - 1);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
}

static BOOLEAN handle_LYK_NOCACHE(int *old_c,
				  int real_c)
{
    if (nlinks > 0) {
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type != F_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_IMAGE_SUBMIT_TYPE &&
	    links[curdoc.link].l_form->type != F_TEXT_SUBMIT_TYPE) {
	    if (*old_c != real_c) {
		*old_c = real_c;
		HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
	    }
	    return FALSE;
	} else {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
    }
    return TRUE;
}

static void handle_LYK_PREV_LINK(int *arrowup,
				 int *old_c,
				 int real_c)
{
    if (curdoc.link > 0) {	/* previous link */
	set_curdoc_link(curdoc.link - 1);

    } else if (!more_text &&
	       curdoc.link == 0 && LYGetNewline() == 1) {	/* at the top of list */
	/*
	 * If there is only one page of data and the user goes off the top,
	 * just move the cursor to last link on the page.
	 */
	set_curdoc_link(nlinks - 1);

    } else if (curdoc.line > 1) {	/* previous page */
	/*
	 * Go back to the previous page.
	 */
	int scrollamount = (LYGetNewline() > display_lines
			    ? display_lines
			    : LYGetNewline() - 1);

	LYChgNewline(-scrollamount);
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link == 0 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

#define nhist_1 (nhist - 1)	/* workaround for indent */

static int handle_PREV_DOC(int *cmd,
			   int *old_c,
			   int real_c)
{
    if (nhist > 0) {		/* if there is anything to go back to */
	/*
	 * Check if the previous document is a reply from a POST, and if so,
	 * seek confirmation of resubmission if the safe element is not set and
	 * the document is not still in the cache or LYresubmit_posts is set.
	 * If not confirmed and it is not the startfile, pop it so we go to the
	 * yet previous document, until we're OK or reach the startfile.  If we
	 * reach the startfile and its not OK or we don't get confirmation,
	 * cancel.  - FM
	 */
	DocAddress WWWDoc;
	HTParentAnchor *tmpanchor;
	BOOLEAN conf = FALSE, first = TRUE;

	HTLastConfirmCancelled();	/* reset flag */
	while (nhist > 0) {
	    conf = FALSE;
	    if (HDOC(nhist_1).post_data == NULL) {
		break;
	    }
	    WWWDoc.address = HDOC(nhist_1).address;
	    WWWDoc.post_data = HDOC(nhist_1).post_data;
	    WWWDoc.post_content_type =
		HDOC(nhist_1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist_1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist_1).isHEAD;
	    WWWDoc.safe = HDOC(nhist_1).safe;
	    tmpanchor = HTAnchor_findAddress(&WWWDoc);
	    if (HTAnchor_safe(tmpanchor)) {
		break;
	    }
	    if ((HTAnchor_document(tmpanchor) == NULL &&
		 (isLYNXIMGMAP(WWWDoc.address) ||
		  (conf = confirm_post_resub(WWWDoc.address,
					     HDOC(nhist_1).title,
					     0, 0))
		  == FALSE)) ||
		((LYresubmit_posts && !conf &&
		  (NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT((DocInfo *) &history[(nhist_1)],
						 &newdoc))) &&
		 !confirm_post_resub(WWWDoc.address,
				     HDOC(nhist_1).title,
				     2, 2))) {
		if (HTLastConfirmCancelled()) {
		    if (!first && curdoc.internal_link)
			free_address(&curdoc);
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		}
		if (nhist == 1) {
		    HTInfoMsg(CANCELLED);
		    *old_c = 0;
		    *cmd = LYK_DO_NOTHING;
		    return 2;
		} else {
		    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
		    do {	/* Should be LYhist_prev when _next supports */
			LYpop(&curdoc);		/* skipping of forms */
		    } while (nhist > 1
			     && !are_different((DocInfo *) &history[nhist_1],
					       &curdoc));
		    first = FALSE;	/* have popped at least one */
		    continue;
		}
	    } else {
		/*
		 * Break from loop; if user just confirmed to load again
		 * because document wasn't in cache, set LYforce_no_cache to
		 * avoid unnecessary repeat question down the road.  - kw
		 */
		if (conf)
		    LYforce_no_cache = TRUE;
		break;
	    }
	}

	if (!first)
	    curdoc.internal_link = FALSE;

	/*
	 * Set newdoc.address to empty to pop a file.
	 */
	LYhist_prev_register(&curdoc);	/* Why not call _prev instead of zeroing address?  */
	free_address(&newdoc);
#ifdef DIRED_SUPPORT
	if (lynx_edit_mode) {
	    DIRED_UNCACHE_2;
	}
#endif /* DIRED_SUPPORT */
    } else if (child_lynx == TRUE) {
	return (1);		/* exit on left arrow in main screen */

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTUserMsg(ALREADY_AT_FIRST);
    }
    return 0;
}

static void handle_LYK_PREV_PAGE(int *old_c,
				 int real_c)
{
    if (LYGetNewline() > 1) {
	LYChgNewline(-display_lines);
    } else if (curdoc.link > 0) {
	set_curdoc_link(0);
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_PRINT(BOOLEAN *ForcePush,
			     int *old_c,
			     int real_c)
{
    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(PRINT_DISABLED);
	}
	return;
    }

    /*
     * Don't do if already viewing print options page.
     */
    if (!LYIsUIPage(curdoc.address, UIP_PRINT_OPTIONS)
	&& print_options(&newdoc.address,
			 curdoc.address, HText_getNumOfLines()) >= 0) {
	LYRegisterUIPage(newdoc.address, UIP_PRINT_OPTIONS);
	StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	*ForcePush = TRUE;	/* see LYpush() and print_options() */
	if (check_realm)
	    LYPermitURL = TRUE;
    }
}

static BOOLEAN handle_LYK_QUIT(void)
{
    int c;

    if (LYQuitDefaultYes == TRUE) {
	c = HTConfirmDefault(REALLY_QUIT, YES);
    } else {
	c = HTConfirmDefault(REALLY_QUIT, NO);
    }
    if (LYQuitDefaultYes == TRUE) {
	if (c != NO) {
	    return (TRUE);
	} else {
	    HTInfoMsg(NO_CANCEL);
	}
    } else if (c == YES) {
	return (TRUE);
    } else {
	HTInfoMsg(NO_CANCEL);
    }
    return FALSE;
}

static BOOLEAN handle_LYK_RAW_TOGGLE(int *cmd)
{
    if (HTLoadedDocumentCharset()) {
	HTUserMsg(gettext("charset for this document specified explicitly, sorry..."));
	return FALSE;
    } else {
	LYUseDefaultRawMode = (BOOL) !LYUseDefaultRawMode;
	HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
	HTMLSetCharacterHandling(current_char_set);
	return reparse_or_reload(cmd);
    }
}

static void handle_LYK_RELOAD(int real_cmd)
{
    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    /*
     * Check to see if should reload source, or load html
     */

    if (HTisDocumentSource()) {
	if ((forced_UCLYhdnl = HTMainText_Get_UCLYhndl()) >= 0)
	    force_old_UCLYhndl_on_reload = TRUE;
	srcmode_for_next_retrieval(1);
    }

    HEAD_request = HTLoadedDocumentIsHEAD();
    HText_setNoCache(HTMainText);
    /*
     * Do assume the reloaded document will be the same.  - FM
     *
     * (I don't remember all the reasons why we couldn't assume this.  As the
     * problems show up, we'll try to fix them, or add warnings.  - FM)
     */
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
    free_address(&curdoc);	/* so it doesn't get pushed */
#ifdef VMS
    lynx_force_repaint();
#endif /* VMS */
    /*
     * Reload should force a cache refresh on a proxy.  -- Ari L.
     * <luotonen@@dxcern.cern.ch>
     *
     * -- but only if this was really a reload requested by the user, not if we
     * jumped here to handle reloading for INLINE_TOGGLE, IMAGE_TOGGLE,
     * RAW_TOGGLE, etc.  - KW
     */
    if (real_cmd == LYK_RELOAD)
	reloading = REAL_RELOAD;

    return;
}

#ifdef DIRED_SUPPORT
static void handle_LYK_REMOVE(BOOLEAN *refresh_screen)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	int linkno = curdoc.link;	/* may be changed in local_remove - kw */

	local_remove(&curdoc);
	if (LYAutoUncacheDirLists >= 1)
	    do_cleanup_after_delete();
	else if (curdoc.link != linkno)
	    *refresh_screen = TRUE;
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_RIGHT_LINK(void)
{
    if (curdoc.link < nlinks - 1 &&
	links[curdoc.link].ly == links[curdoc.link + 1].ly) {
	set_curdoc_link(curdoc.link + 1);
    }
}

static void handle_LYK_SHELL(BOOLEAN *refresh_screen,
			     int *old_c,
			     int real_c)
{
    if (!no_shell) {
	stop_curses();
	printf("%s\r\n", SPAWNING_MSG);
#if defined(__CYGWIN__)
	/* handling "exec $SHELL" does not work if $SHELL is null */
	if (LYGetEnv("SHELL") == NULL) {
	    Cygwin_Shell();
	} else
#endif
	{
	    static char *shell = NULL;

	    if (shell == 0)
		StrAllocCopy(shell, LYSysShell());
	    LYSystem(shell);
	}
	start_curses();
	*refresh_screen = TRUE;	/* for an HText_pageDisplay() */
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(SPAWNING_DISABLED);
	}
    }
}

static void handle_LYK_SOFT_DQUOTES(void)
{
#ifdef USE_SOURCE_CACHE
    if (!HTcan_reparse_document()) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so, seek confirmation
	 * of reload if the safe element is not set.  - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    soft_dquotes = (BOOLEAN) !soft_dquotes;
    HTUserMsg(soft_dquotes ?
	      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef USE_SOURCE_CACHE
    (void) reparse_document();
#endif
    return;
}

#define GetAnchorNumber(link) \
			((nlinks > 0 && link >= 0) \
    			 ? links[link].anchor_number \
			 : -1)
#define GetAnchorLineNo(link) \
			((nlinks > 0 && link >= 0) \
    			 ? links[link].anchor_line_num \
			 : -1)

/*
 * Adjust the top-of-screen line number for the new document if the redisplayed
 * screen would not show the given link-number.
 */
#ifdef USE_SOURCE_CACHE
static int wrap_reparse_document(void)
{
    int result;
    int anchor_number = GetAnchorNumber(curdoc.link);
    int old_line_num = HText_getAbsLineNumber(HTMainText, anchor_number);
    int old_from_top = old_line_num - LYGetNewline() + 1;

    /* get the offset for the current anchor */
    int old_offset = ((nlinks > 0 && curdoc.link >= 0)
		      ? links[curdoc.link].sgml_offset
		      : -1);

    CTRACE((tfp, "original anchor %d, topline %d, link %d, offset %d\n",
	    anchor_number, old_line_num, curdoc.link, old_offset));

    /* reparse the document (producing a new anchor list) */
    result = reparse_document();

    /* readjust top-line and link-number */
    if (result && old_offset >= 0) {
	int new_anchor = HText_closestAnchor(HTMainText, old_offset);
	int new_lineno = HText_getAbsLineNumber(HTMainText, new_anchor);
	int top_lineno;

	CTRACE((tfp, "old anchor %d -> new anchor %d\n", anchor_number, new_anchor));

	if (new_lineno - old_from_top < 0)
	    old_from_top = new_lineno;

	/* Newline and newdoc.line are 1-based,
	 * but 0-based lines are simpler to work with.
	 */
	top_lineno = HText_getPreferredTopLine(HTMainText, new_lineno -
					       old_from_top) + 1;
	CTRACE((tfp, "preferred top %d\n", top_lineno));

	if (top_lineno != LYGetNewline()) {
	    LYSetNewline(top_lineno);
	    newdoc.link = HText_anchorRelativeTo(HTMainText, top_lineno - 1, new_anchor);
	    curdoc.link = newdoc.link;
	    CTRACE((tfp,
		    "adjusted anchor %d, topline %d, link %d, offset %d\n",
		    new_anchor,
		    top_lineno,
		    curdoc.link,
		    HText_locateAnchor(HTMainText, new_anchor)));
	} else {
	    newdoc.link = curdoc.link;
	}
    }
    return result;
}
#endif /* USE_SOURCE_CACHE */

static void handle_LYK_SOURCE(char **ownerS_address_p)
{
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse_post = FALSE;
#endif

    /*
     * Check if this is a reply from a POST, and if so,
     * seek confirmation if the safe element is not set.  - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
#ifdef USE_SOURCE_CACHE
	(!(canreparse_post = HTcan_reparse_document())) &&
#endif
	(curdoc.isHEAD ? HTConfirm(CONFIRM_POST_RESUBMISSION) :
	 confirm_post_resub(curdoc.address, curdoc.title, 1, 1)) == FALSE) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (HTisDocumentSource()) {
	srcmode_for_next_retrieval(-1);
    } else {
	if (HText_getOwner())
	    StrAllocCopy(*ownerS_address_p, HText_getOwner());
	LYUCPushAssumed(HTMainAnchor);
	srcmode_for_next_retrieval(1);
    }

#ifdef USE_SOURCE_CACHE
    if (wrap_reparse_document()) {
	/*
	 * These normally get cleaned up after getfile() returns;
	 * since we're not calling getfile(), we have to clean them
	 * up ourselves.  -dsb
	 */
	HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	if (psrc_view)
	    HTMark_asSource();
	psrc_view = FALSE;
#endif
	FREE(*ownerS_address_p);	/* not used with source_cache */
	LYUCPopAssumed();	/* probably a right place here */
	HTMLSetCharacterHandling(current_char_set);	/* restore now */

	return;
    } else if (canreparse_post) {
	srcmode_for_next_retrieval(0);
	LYUCPopAssumed();	/* probably a right place here */
	return;
    }
#endif

    if (curdoc.title)
	StrAllocCopy(newdoc.title, curdoc.title);

    free_address(&curdoc);	/* so it doesn't get pushed */
    LYforce_no_cache = TRUE;
}

static void handle_LYK_SWITCH_DTD(void)
{
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse = FALSE;

    if (!(canreparse = HTcan_reparse_document())) {
#endif
	/*
	 * Check if this is a reply from a POST, and if so,
	 * seek confirmation of reload if the safe element
	 * is not set.  - FM, kw
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    /*
	     * If currently viewing preparsed source, switching to the other
	     * DTD parsing may show source differences, so stay in source view
	     * - kw
	     */

	    /* NOTE: this conditional can be considered incorrect -
	       current behaviour - when viewing source and
	       LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
	       AND switch back from the source view to presentation view.-HV
	     */
	    if (HTisDocumentSource() && LYPreparsedSource) {
		srcmode_for_next_retrieval(1);
	    }
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
#ifdef USE_SOURCE_CACHE
    }				/* end if no bypass */
#endif
    Old_DTD = !Old_DTD;
    HTSwitchDTD(!Old_DTD);
    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
#ifdef USE_SOURCE_CACHE
    if (canreparse) {
	if (HTisDocumentSource() && LYPreparsedSource) {
	    srcmode_for_next_retrieval(1);
	}
	if (!reparse_document()) {
	    srcmode_for_next_retrieval(0);
	}
    }
#endif
    return;
}

#ifdef DIRED_SUPPORT
static void handle_LYK_TAG_LINK(void)
{
    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
	if (!strcmp(LYGetHiliteStr(curdoc.link, 0), ".."))
	    return;		/* Never tag the parent directory */
	if (dir_list_style == MIXED_STYLE) {
	    if (!strcmp(LYGetHiliteStr(curdoc.link, 0), "../"))
		return;
	} else if (!StrNCmp(LYGetHiliteStr(curdoc.link, 0), "Up to ", 6))
	    return;
	{
	    /*
	     * HTList-based management of tag list, see LYLocal.c - KW
	     */
	    HTList *t1 = tagged;
	    char *tagname = NULL;
	    BOOLEAN found = FALSE;

	    while ((tagname = (char *) HTList_nextObject(t1)) != NULL) {
		if (!strcmp(links[curdoc.link].lname, tagname)) {
		    found = TRUE;
		    HTList_removeObject(tagged, tagname);
		    FREE(tagname);
		    tagflag(FALSE, curdoc.link);
		    break;
		}
	    }
	    if (!found) {
		if (tagged == NULL)
		    tagged = HTList_new();
		tagname = NULL;
		StrAllocCopy(tagname, links[curdoc.link].lname);
		HTList_addObject(tagged, tagname);
		tagflag(TRUE, curdoc.link);
	    }
	}
	if (curdoc.link < nlinks - 1) {
	    set_curdoc_link(curdoc.link + 1);
	} else if (!more_text && LYGetNewline() == 1 && curdoc.link == nlinks
		   - 1) {
	    set_curdoc_link(0);
	} else if (more_text) {	/* next page */
	    LYChgNewline(display_lines);
	}
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_TOGGLE_HELP(void)
{
    if (user_mode == NOVICE_MODE) {
	toggle_novice_line();
	noviceline(more_text);
    }
}

static void handle_LYK_TOOLBAR(BOOLEAN *try_internal,
			       BOOLEAN *force_load,
			       int *old_c,
			       int real_c)
{
    char *cp;
    char *toolbar = NULL;

    if (!HText_hasToolbar(HTMainText)) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_TOOLBAR);
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	cp = trimPoundSelector(curdoc.address);
	HTSprintf0(&toolbar, "%s#%s", curdoc.address, LYToolbarName);
	restorePoundSelector(cp);
	set_address(&newdoc, toolbar);
	FREE(toolbar);
	*try_internal = TRUE;
	*force_load = TRUE;	/* force MainLoop to reload */
    }
}

static void handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)
{
#ifndef NO_LYNX_TRACE
    /*
     * Check whether we've started a TRACE log in this session.  - FM
     */
    if (LYTraceLogFP == NULL) {
	HTUserMsg(NO_TRACELOG_STARTED);
	return;
    }

    /*
     * Don't do if already viewing the TRACE log.  - FM
     */
    if (LYIsUIPage(curdoc.address, UIP_TRACELOG))
	return;

    /*
     * If TRACE mode is on, turn it off during this fetch of the TRACE log, so
     * we don't enter stuff about this fetch, and set a flag for turning it
     * back on when we return to this loop.  Note that we'll miss any messages
     * about memory exhaustion if it should occur.  It seems unlikely that
     * anything else bad might happen, but if it does, we'll miss messages
     * about that too.  We also fflush(), close, and open it again, to make
     * sure all stderr messages thus far will be in the log.  - FM
     */
    if (!LYReopenTracelog(trace_flag_ptr))
	return;

    LYLocalFileToURL(&(newdoc.address), LYTraceLogPath);
    LYRegisterUIPage(newdoc.address, UIP_TRACELOG);
    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
    }
    LYforce_no_cache = TRUE;
#else
    HTUserMsg(TRACE_DISABLED);
#endif /* NO_LYNX_TRACE */
}

#ifdef DIRED_SUPPORT
static void handle_LYK_UPLOAD(void)
{
    /*
     * Don't do if already viewing upload options page.
     */
    if (LYIsUIPage(curdoc.address, UIP_UPLOAD_OPTIONS))
	return;

    if (lynx_edit_mode && !no_dired_support) {
	LYUpload_options(&(newdoc.address), curdoc.address);
	StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
	LYFreePostData(&newdoc);
	FREE(newdoc.bookmark);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
	/*
	 * Uncache the current listing so that it will be updated to included
	 * the uploaded file if placed in the current directory.  - FM
	 */
	DIRED_UNCACHE_1;
    }
}
#endif /* DIRED_SUPPORT */

static void handle_LYK_UP_xxx(int *arrowup,
			      int *old_c,
			      int real_c,
			      int scroll_by)
{
    if (LYGetNewline() > 1) {
	if (LYGetNewline() - scroll_by < 1)
	    scroll_by = LYGetNewline() - 1;
	LYChgNewline(-scroll_by);
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scroll_by <= display_lines) {
		newdoc.link = curdoc.link +
		    HText_LinksInLines(HTMainText,
				       LYGetNewline(),
				       scroll_by);
	    } else {
		*arrowup = TRUE;
	    }
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_UP_HALF(int *arrowup,
			       int *old_c,
			       int real_c)
{
    handle_LYK_UP_xxx(arrowup, old_c, real_c, display_lines / 2);
}

static void handle_LYK_UP_LINK(int *follow_col,
			       int *arrowup,
			       int *old_c,
			       int real_c)
{
    if (curdoc.link > 0 &&
	(links[0].ly != links[curdoc.link].ly ||
	 !HText_LinksInLines(HTMainText, 1, LYGetNewline() - 1))) {
	/* more links before this on screen, and first of them on
	   a different line or no previous links before this screen? */
	int newlink;

	if (*follow_col == -1) {
	    const char *text = LYGetHiliteStr(curdoc.link, 0);

	    *follow_col = links[curdoc.link].lx;

	    if (text != NULL)
		*follow_col += (int) strlen(text) / 2;
	}

	newlink = find_link_near_col(*follow_col, -1);
	if (newlink > -1) {
	    set_curdoc_link(newlink);
	} else if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(NO_LINKS_ABOVE);
	}

    } else if (curdoc.line > 1 && LYGetNewline() > 1) {		/* previous page */
	int scrollamount = (LYGetNewline() > display_lines
			    ? display_lines
			    : LYGetNewline() - 1);

	LYChgNewline(-scrollamount);
	if (scrollamount < display_lines &&
	    nlinks > 0 && curdoc.link > -1 &&
	    links[0].ly - 1 + scrollamount <= display_lines) {
	    newdoc.link = HText_LinksInLines(HTMainText,
					     1,
					     scrollamount) - 1;
	} else {
	    *arrowup = TRUE;
	}

    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
}

static void handle_LYK_UP_TWO(int *arrowup,
			      int *old_c,
			      int real_c)
{
    handle_LYK_UP_xxx(arrowup, old_c, real_c, 2);
}

static void handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen,
				     int *old_c,
				     int real_c)
{
    const char *cp;

    if (LYValidate) {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    HTUserMsg(BOOKMARKS_DISABLED);
	}
	return;
    }

    /*
     * See if a bookmark exists.  If it does replace newdoc.address with its
     * name.
     */
    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
	if (*cp == '\0' || !strcmp(cp, " ") ||
	    !strcmp(curdoc.address, newdoc.address)) {
	    if (LYMultiBookmarks != MBM_OFF)
		*refresh_screen = TRUE;
	    return;
	}
#ifdef KANJI_CODE_OVERRIDE
	if (HTCJK == JAPANESE) {
	    last_kcode = NOKANJI;	/* AUTO */
	}
#endif
	LYforce_no_cache = TRUE;	/*force the document to be reloaded */
	StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
	StrAllocCopy(newdoc.bookmark, BookmarkPage);
	LYFreePostData(&newdoc);
	newdoc.isHEAD = FALSE;
	newdoc.safe = FALSE;
	newdoc.internal_link = FALSE;
    } else {
	if (*old_c != real_c) {
	    *old_c = real_c;
	    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
	    LYSleepAlert();
	    if (LYMultiBookmarks != MBM_OFF) {
		*refresh_screen = TRUE;
	    }
	}
    }
}

static BOOLEAN handle_LYK_VLINKS(int *cmd,
				 BOOLEAN *newdoc_link_is_absolute)
{
    int c;

    if (LYIsUIPage(curdoc.address, UIP_VLINKS)) {
	/*
	 * Already viewing visited links page, so get out.
	 */
	*cmd = LYK_PREV_DOC;
	return TRUE;
    }

    /*
     * Print visited links page to file.
     */
    c = LYShowVisitedLinks(&newdoc.address);
    if (c < 0) {
	HTUserMsg(VISITED_LINKS_EMPTY);
	return FALSE;
    }
    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
    LYFreePostData(&newdoc);
    FREE(newdoc.bookmark);
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    if (c > 0) {
	/* Select a correct link. */
	*newdoc_link_is_absolute = TRUE;
	newdoc.link = c - 1;
    }
    if (LYValidate || check_realm) {
	LYPermitURL = TRUE;
	StrAllocCopy(lynxlinksfile, newdoc.address);
    }
    return FALSE;
}

void handle_LYK_WHEREIS(int cmd,
			BOOLEAN *refresh_screen)
{
    BOOLEAN have_target_onscreen = (BOOLEAN) (!isBEmpty(prev_target) &&
					      HText_pageHasPrevTarget());
    BOOL found;
    int oldcur = curdoc.link;	/* temporarily remember */
    char *remember_old_target = NULL;

    if (have_target_onscreen)
	StrAllocCopy(remember_old_target, prev_target->str);
    else
	StrAllocCopy(remember_old_target, "");

    if (cmd == LYK_WHEREIS) {
	/*
	 * Reset prev_target to force prompting for a new search string and to
	 * turn off highlighting if no search string is entered by the user.
	 */
	BStrCopy0(prev_target, "");
    }
    found = textsearch(&curdoc, &prev_target,
		       (cmd == LYK_WHEREIS)
		       ? 0
		       : ((cmd == LYK_NEXT)
			  ? 1
			  : -1));

    /*
     * Force a redraw to ensure highlighting of hits even when found on the
     * same page, or clearing of highlighting if the default search string was
     * erased without replacement.  - FM
     */
    /*
     * Well let's try to avoid it at least in a few cases
     * where it is not needed. - kw
     */
    if (www_search_result >= 0 && www_search_result != curdoc.line) {
	*refresh_screen = TRUE;	/* doesn't really matter */
    } else if (!found) {
	*refresh_screen = have_target_onscreen;
    } else if (!have_target_onscreen && found) {
	*refresh_screen = TRUE;
    } else if (www_search_result == curdoc.line &&
	       curdoc.link == oldcur &&
	       curdoc.link >= 0 && nlinks > 0 &&
	       links[curdoc.link].ly >= (display_lines / 3)) {
	*refresh_screen = TRUE;
    } else if ((LYcase_sensitive && 0 != strcmp(prev_target->str,
						remember_old_target)) ||
	       (!LYcase_sensitive && 0 != strcasecomp8(prev_target->str,
						       remember_old_target))) {
	*refresh_screen = TRUE;
    }
    FREE(remember_old_target);
}

/*
 * Get a number from the user and follow that link number.
 */
static void handle_LYK_digit(int c,
			     BOOLEAN *force_load,
			     int *old_c,
			     int real_c,
			     BOOLEAN *try_internal GCC_UNUSED)
{
    int lindx = ((nlinks > 0) ? curdoc.link : 0);
    int number;
    char *temp = NULL;

    /* pass cur line num for use in follow_link_number()
     * Note: Current line may not equal links[cur].line
     */
    number = curdoc.line;
    switch (follow_link_number(c, lindx, &newdoc, &number)) {
    case DO_LINK_STUFF:
	/*
	 * Follow a normal link.
	 */
	set_address(&newdoc, links[lindx].lname);
	StrAllocCopy(newdoc.title, LYGetHiliteStr(lindx, 0));
	/*
	 * For internal links, retain POST content if present.  If we are on
	 * the List Page, prevent pushing it on the history stack.  Otherwise
	 * set try_internal to signal that the top of the loop should attempt
	 * to reposition directly, without calling getfile.  - kw
	 */
	if (track_internal_links) {
	    if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
		LYinternal_flag = TRUE;
		newdoc.internal_link = TRUE;
		if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		    (LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		     LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		    if (check_history()) {
			LYinternal_flag = TRUE;
		    } else {
			HTLastConfirmCancelled();	/* reset flag */
			if (!confirm_post_resub(newdoc.address,
						newdoc.title,
						((LYresubmit_posts &&
						  HText_POSTReplyLoaded(&newdoc))
						 ? 1
						 : 2),
						2)) {
			    if (HTLastConfirmCancelled() ||
				(LYresubmit_posts &&
				 !HText_POSTReplyLoaded(&newdoc))) {
				/* cancel the whole thing */
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				copy_address(&newdoc, &curdoc);
				StrAllocCopy(newdoc.title, curdoc.title);
				newdoc.internal_link = curdoc.internal_link;
				HTInfoMsg(CANCELLED);
				if (nlinks > 0)
				    HText_pageDisplay(curdoc.line, prev_target->str);
				break;
			    } else if (LYresubmit_posts) {
				/* If LYresubmit_posts is set, and the
				   answer was No, and we have a cached
				   copy, then use it. - kw */
				LYforce_no_cache = FALSE;
			    } else {
				/* if No, but not ^C or ^G, drop
				 * the post data.  Maybe the link
				 * wasn't meant to be internal after
				 * all, here we can recover from that
				 * assumption. - kw */
				LYFreePostData(&newdoc);
				newdoc.internal_link = FALSE;
				HTAlert(DISCARDING_POST_DATA);
			    }
			}
		    }
		    /*
		     * Don't push the List Page if we follow an internal link given
		     * by it.  - kw
		     */
		    free_address(&curdoc);
		} else
		    *try_internal = TRUE;
		if (!(LYresubmit_posts && newdoc.post_data))
		    LYinternal_flag = TRUE;
		*force_load = TRUE;
		break;
	    } else {
		/*
		 * Free POST content if not an internal link.  - kw
		 */
		LYFreePostData(&newdoc);
	    }
	}
	/*
	 * Might be an anchor in the same doc from a POST form.  If so, don't
	 * free the content.  -- FM
	 */
	if (are_different(&curdoc, &newdoc)) {
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    if (isLYNXMESSAGES(newdoc.address))
		LYforce_no_cache = TRUE;
	}
	newdoc.internal_link = FALSE;
	*force_load = TRUE;	/* force MainLoop to reload */
	break;

    case DO_GOTOLINK_STUFF:
	/*
	 * Position on a normal link, don't follow it.  - KW
	 */
	LYSetNewline(newdoc.line);
	newdoc.line = 1;
	if (LYGetNewline() == curdoc.line) {
	    /*
	     * It's a link in the current page.  - FM
	     */
	    if (nlinks > 0 && curdoc.link > -1) {
		if (curdoc.link == newdoc.link) {
		    /*
		     * It's the current link, and presumably reflects a typo in
		     * the statusline entry, so issue a statusline message for
		     * the typo-prone users (like me 8-).  - FM
		     */
		    HTSprintf0(&temp, LINK_ALREADY_CURRENT, number);
		    HTUserMsg(temp);
		    FREE(temp);
		} else {
		    /*
		     * It's a different link on this page,
		     */
		    set_curdoc_link(newdoc.link);
		    newdoc.link = 0;
		}
	    }
	}
	break;			/* nothing more to do */

    case DO_GOTOPAGE_STUFF:
	/*
	 * Position on a page in this document.  - FM
	 */
	LYSetNewline(newdoc.line);
	newdoc.line = 1;
	if (LYGetNewline() == curdoc.line) {
	    /*
	     * It's the current page, so issue a statusline message for the
	     * typo-prone users (like me 8-).  - FM
	     */
	    if (LYGetNewline() <= 1) {
		HTInfoMsg(ALREADY_AT_BEGIN);
	    } else if (!more_text) {
		HTInfoMsg(ALREADY_AT_END);
	    } else {
		HTSprintf0(&temp, ALREADY_AT_PAGE, number);
		HTUserMsg(temp);
		FREE(temp);
	    }
	}
	break;

    case PRINT_ERROR:
	*old_c = real_c;
	HTUserMsg(BAD_LINK_NUM_ENTERED);
	break;
    }
    return;
}

#ifdef SUPPORT_CHDIR

/* original implementation by VH */
void handle_LYK_CHDIR(void)
{
    static bstring *buf = NULL;
    char *p = NULL;

    if (no_chdir) {
	HTUserMsg(CHDIR_DISABLED);
	return;
    }

    _statusline(gettext("cd to:"));
    if (LYgetBString(&buf, FALSE, 0, NORECALL) < 0 || isBEmpty(buf)) {
	HTInfoMsg(CANCELLED);
	return;
    }

    if (LYIsTilde(buf->str[0]) &&
	(LYIsPathSep(buf->str[1]) || buf->str[1] == '\0')) {
	HTSprintf0(&p, "%s%s", Home_Dir(), buf->str + 1);
    } else {
	StrAllocCopy(p, buf->str);
    }

    CTRACE((tfp, "changing directory to '%s'\n", p));
    if (chdir(p)) {
	switch (errno) {
	case EACCES:
	    HTInfoMsg(COULD_NOT_ACCESS_DIR);
	    break;
	case ENOENT:
	    HTInfoMsg(gettext("No such directory"));
	    break;
	case ENOTDIR:
	    HTInfoMsg(gettext("A component of path is not a directory"));
	    break;
	default:
	    HTInfoMsg(gettext("failed to change directory"));
	    break;
	}
    } else {
#ifdef DIRED_SUPPORT
	/*if in dired, load content of other directory */
	if (!no_dired_support
	    && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
	    char buf2[LY_MAXPATH];
	    char *addr = NULL;

	    Current_Dir(buf2);
	    LYLocalFileToURL(&addr, buf2);

	    newdoc.address = addr;
	    newdoc.isHEAD = FALSE;
	    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    /**force_load = TRUE;*/
	    if (lynx_edit_mode) {
		DIRED_UNCACHE_2;
	    }
	} else
#endif
	    HTInfoMsg(OPERATION_DONE);
    }
    FREE(p);
}

static void handle_LYK_PWD(void)
{
    char buffer[LY_MAXPATH];
    int save_secs = InfoSecs;
    BOOLEAN save_wait = no_pause;

    if (Secs2SECS(save_secs) < 1)
	InfoSecs = SECS2Secs(1);
    no_pause = FALSE;

    HTInfoMsg(Current_Dir(buffer));

    InfoSecs = save_secs;
    no_pause = save_wait;
}
#endif

#ifdef USE_CURSES_PADS
/*
 * Having jumps larger than this is counter-productive.  Indeed, it is natural
 * to expect that when the relevant text appears, one would "overshoot" and
 * would scroll 3-4 extra full screens.  When going back, the "accumulation"
 * logic would again start moving in full screens, so one would overshoot
 * again, etc.
 *
 * Going back, one can fix it in 28 keypresses. The relevant text will appear
 * on the screen soon enough for the key-repeat to become not that important,
 * and we are still moving in smaller steps than when we overshot.  Since key
 * repeat is not important, even if we overshoot again, it is going to be by 30
 * steps, which is easy to fix by reversing the direction again.
 */
static int repeat_to_delta(int n)
{
    int threshold = LYcols / 3;

    while (threshold > 0) {
	if (n >= threshold) {
	    n = threshold;
	    break;
	}
	threshold = (threshold * 2) / 3;
    }
    return n;
}

static void handle_LYK_SHIFT_LEFT(BOOLEAN *flag, int count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    if (LYshiftWin > 0) {
	LYshiftWin -= repeat_to_delta(count);
	*flag = TRUE;
    }
    if (LYshiftWin < 0)
	LYshiftWin = 0;
}

static void handle_LYK_SHIFT_RIGHT(BOOLEAN *flag, int count)
{
    if (!LYwideLines) {
	HTAlert(SHIFT_VS_LINEWRAP);
	return;
    }
    LYshiftWin += repeat_to_delta(count);
    *flag = TRUE;
}

static BOOLEAN handle_LYK_LINEWRAP_TOGGLE(int *cmd,
					  BOOLEAN *flag)
{
    static const char *choices[] =
    {
	"Try to fit screen width",
	"No line wrap in columns",
	"Wrap columns at screen width",
	"Wrap columns at 3/4 screen width",
	"Wrap columns at 2/3 screen width",
	"Wrap columns at 1/2 screen width",
	"Wrap columns at 1/3 screen width",
	"Wrap columns at 1/4 screen width",
	NULL
    };
    static int wrap[] =
    {
	0,
	0,
	12,			/* In units of 1/12 */
	9,
	8,
	6,
	4,
	3
    };
    int c;
    int code = FALSE;

    CTRACE((tfp, "Entering handle_LYK_LINEWRAP_TOGGLE\n"));
    if (LYwin != stdscr) {
	/* Somehow the mouse is over the number instead of being over the
	   name, so we decrease x. */
	c = LYChoosePopup(!LYwideLines,
			  LYlines / 2 - 2,
			  LYcolLimit / 2 - 6,
			  choices, (int) TABLESIZE(choices) - 1,
			  FALSE, TRUE);
	/*
	 * LYhandlePopupList() wasn't really meant to be used outside of
	 * old-style Options menu processing.  One result of mis-using it here
	 * is that we have to deal with side-effects regarding SIGINT signal
	 * handler and the term_options global variable.  - kw
	 */
	if (!term_options) {
	    CTRACE((tfp,
		    "...setting LYwideLines %d, LYtableCols %d (have %d and %d)\n",
		    c, wrap[c],
		    LYwideLines,
		    LYtableCols));

	    LYwideLines = c;
	    LYtableCols = wrap[c];

	    if (LYwideLines == 0)
		LYshiftWin = 0;
	    *flag = TRUE;
	    HTUserMsg(LYwideLines ? LINEWRAP_OFF : LINEWRAP_ON);
	    code = reparse_or_reload(cmd);
	}
    }
    return (BOOLEAN) code;
}
#endif

#ifdef USE_MAXSCREEN_TOGGLE
static BOOLEAN handle_LYK_MAXSCREEN_TOGGLE(int *cmd)
{
    static int flag = 0;

    CTRACE((tfp, "Entering handle_LYK_MAXSCREEN_TOGGLE\n"));
    if (flag) {
	CTRACE((tfp, "Calling recoverWindowSize()\n"));
	recoverWindowSize();
	flag = 0;
    } else {
	CTRACE((tfp, "Calling maxmizeWindowSize()\n"));
	maxmizeWindowSize();
	flag = 1;
    }
    return reparse_or_reload(cmd);
}
#endif

#ifdef LY_FIND_LEAKS
#define CleanupMainLoop() \
 	BStrFree(prev_target); \
 	BStrFree(user_input_buffer)
#else
#define CleanupMainLoop()	/* nothing */
#endif

/*
 * Here's where we do all the work.
 * mainloop is basically just a big switch dependent on the users input.  I
 * have tried to offload most of the work done here to procedures to make it
 * more modular, but this procedure still does a lot of variable manipulation.
 * This needs some work to make it neater.  - Lou Moutilli
 *					(memoir from the original Lynx - FM)
 */
int mainloop(void)
{
#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
    char sjis_buff[MAX_LINE];
    char temp_buff[sizeof(sjis_buff) * 4];
#endif
    int c = 0;
    int real_c = 0;
    int old_c = 0;
    int pending_form_c = -1;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    bstring *user_input_buffer = NULL;
    const char *cshelpfile = NULL;
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp;
    int ch = 0;
    RecallType recall = NORECALL;
    int URLTotal = 0;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    BOOLEAN newdoc_link_is_absolute = FALSE;
    BOOLEAN curlink_is_editable;
    BOOLEAN use_last_tfpos;
    unsigned int len;
    int i;
    int follow_col = -1, key_count = 0, last_key = 0;
    int tmpNewline;
    DocInfo tmpDocInfo;

    /* "internal" means "within the same document, with certainty".  It includes a
     * space so it cannot conflict with any (valid) "TYPE" attributes on A
     * elements.  [According to which DTD, anyway??] - kw
     */
    HTInternalLink = HTAtom_for("internal link");	/* init, used as const */

#ifndef WWW_SOURCE
    WWW_SOURCE = HTAtom_for("www/source");	/* init, used as const */
#endif

    /*
     * curdoc.address contains the name of the file that is currently open.
     * newdoc.address contains the name of the file that will soon be
     *                opened if it exits.
     * prev_target    contains the last search string the user searched for.
     * newdoc.title   contains the link name that the user last chose to get
     *                into the current link (file).
     */
    /* initialize some variables */
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    newdoc.internal_link = FALSE;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
    curdoc.internal_link = FALSE;
#ifdef USE_COLOR_STYLE
    curdoc.style = NULL;
    newdoc.style = NULL;
#endif
#ifndef USE_SESSIONS
    nhist = 0;
#endif
    BStrCopy0(user_input_buffer, "");
    BStrCopy0(prev_target, "");
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
  initialize:
    set_address(&newdoc, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;

#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	LYaddstr("\n");
	LYrefresh();
    }
#endif /* USE_SLANG */
    CTRACE((tfp, "Entering mainloop, startfile=%s\n", startfile));

    if (form_post_data) {
	BStrCopy0(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
    }

    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
	} else {
	    const char *cp1;

	    /*
	     * See if a bookmark page exists.  If it does, replace
	     * newdoc.address with its name
	     */
	    if ((cp1 = get_bookmark_filename(&newdoc.address)) != NULL &&
		*cp1 != '\0' && strcmp(cp1, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		LYFreePostData(&newdoc);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		CTRACE((tfp, "Using bookmarks=%s\n", newdoc.address));
	    } else {
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
	    }
	}
    }

    FREE(form_post_data);
    FREE(form_get_data);

    LYSetDisplayLines();

    while (TRUE) {
#ifdef USE_COLOR_STYLE
	if (curdoc.style != NULL)
	    force_load = TRUE;
#endif
	/*
	 * If newdoc.address is different from curdoc.address then we need to
	 * go out and find and load newdoc.address.
	 */
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {

	    force_load = FALSE;	/* done */
	    if (TRACE && LYCursesON) {
		LYHideCursor();	/* make sure cursor is down */
#ifdef USE_SLANG
		LYaddstr("\n");
#endif /* USE_SLANG */
		LYrefresh();
	    }
	  try_again:
	    /*
	     * Push the old file onto the history stack if we have a current
	     * doc and a new address.  - FM
	     */
	    if (curdoc.address && newdoc.address) {
		/*
		 * Don't actually push if this is a LYNXDOWNLOAD URL, because
		 * that returns NORMAL even if it fails due to a spoof attempt
		 * or file access problem, and we set the newdoc structure
		 * elements to the curdoc structure elements under case NORMAL.
		 * - FM
		 */
		if (!isLYNXDOWNLOAD(newdoc.address)) {
		    LYpush(&curdoc, ForcePush);
		}
	    } else if (!newdoc.address) {
		/*
		 * If newdoc.address is empty then pop a file and load it.  -
		 * FM
		 */
		LYhist_prev(&newdoc);
		popped_doc = TRUE;

		/*
		 * If curdoc had been reached via an internal
		 * (fragment) link from what we now have just
		 * popped into newdoc, then override non-caching in
		 * all cases. - kw
		 */
		if (track_internal_links &&
		    curdoc.internal_link &&
		    !are_phys_different(&curdoc, &newdoc)) {
		    LYinternal_flag = TRUE;
		    LYoverride_no_cache = TRUE;
		    LYforce_no_cache = FALSE;
		    try_internal = TRUE;
		} else {
		    /*
		     * Force a no_cache override unless it's a bookmark file,
		     * or it has POST content and LYresubmit_posts is set
		     * without safe also set, and we are not going to another
		     * position in the current document or restoring the
		     * previous document due to a NOT_FOUND or NULLFILE return
		     * value from getfile().  - FM
		     */
		    if ((newdoc.bookmark != NULL) ||
			(newdoc.post_data != NULL &&
			 !newdoc.safe &&
			 LYresubmit_posts &&
			 !override_LYresubmit_posts &&
			 NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			LYoverride_no_cache = FALSE;
		    } else {
			LYoverride_no_cache = TRUE;
		    }
		}
	    }
	    override_LYresubmit_posts = FALSE;

	    if (HEAD_request) {
		/*
		 * Make SURE this is an appropriate request.  - FM
		 */
		if (newdoc.address) {
		    if (LYCanDoHEAD(newdoc.address) == TRUE) {
			newdoc.isHEAD = TRUE;
		    } else if (isLYNXIMGMAP(newdoc.address)) {
			if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
			    StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
			    free_address(&newdoc);
			    newdoc.address = temp;
			    newdoc.isHEAD = TRUE;
			    temp = NULL;
			}
		    }
		}
		try_internal = FALSE;
		HEAD_request = FALSE;
	    }

	    /*
	     * If we're getting the TRACE log and it's not new, check whether
	     * its HText structure has been dumped, and if so, fflush() and
	     * fclose() it to ensure it's fully updated, and then fopen() it
	     * again.  - FM
	     */
	    if (LYUseTraceLog == TRUE &&
		trace_mode_flag == FALSE &&
		LYTraceLogFP != NULL &&
		LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		DocAddress WWWDoc;
		HTParentAnchor *tmpanchor;

		WWWDoc.address = newdoc.address;
		WWWDoc.post_data = newdoc.post_data;
		WWWDoc.post_content_type = newdoc.post_content_type;
		WWWDoc.bookmark = newdoc.bookmark;
		WWWDoc.isHEAD = newdoc.isHEAD;
		WWWDoc.safe = newdoc.safe;
		tmpanchor = HTAnchor_findAddress(&WWWDoc);
		if ((HText *) HTAnchor_document(tmpanchor) == NULL) {
		    if (!LYReopenTracelog(&trace_mode_flag)) {
			old_c = 0;
			cmd = LYK_PREV_DOC;
			goto new_cmd;
		    }
		}
	    }

	    LYRequestTitle = newdoc.title;
	    if (newdoc.bookmark)
		LYforce_HTML_mode = TRUE;
	    if (LYValidate &&
		startfile_ok &&
		newdoc.address && startfile && homepage &&
		(!strcmp(newdoc.address, startfile) ||
		 !strcmp(newdoc.address, homepage))) {
		LYPermitURL = TRUE;
	    }

	    /* reset these two variables here before getfile()
	     * so they will be available in partial mode
	     * (was previously implemented in case NORMAL).
	     */
	    BStrCopy0(prev_target, "");		/* Reset for new coming document */
	    LYSetNewline(newdoc.line);	/* set for LYGetNewline() */

#ifdef USE_PRETTYSRC
	    psrc_first_tag = TRUE;
#endif
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = textfields_activation_option;
#endif
	    FREE(LYRequestReferer);
	    /*
	     * Don't send Referer if we have to load a document again that we
	     * got from the history stack.  We don't know any more how we
	     * originally got to that page.  Using a Referer based on the
	     * current HTMainText could only be right by coincidence.  - kw
	     * 1999-11-01
	     */
	    if (popped_doc)
		LYNoRefererForThis = TRUE;

	    if (track_internal_links) {
		if (try_internal) {
		    if (newdoc.address &&
			isLYNXIMGMAP(newdoc.address)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			       isLYNXIMGMAP(curdoc.address)) {
			try_internal = FALSE;
		    }
		}
		if (try_internal) {
		    char *hashp = findPoundSelector(newdoc.address);

		    if (hashp) {
			HTFindPoundSelector(hashp + 1);
		    }
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE;	/* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    set_address(&newdoc, HTLoadedDocumentURL());
			} else {
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp);	/* append fragment */
			    set_address(&newdoc, temp);
			    FREE(temp);
			}
		    }
		} else {
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;

			if (isLYNXIMGMAP(HDOC(nhist_1).address))
			    cp0 = HDOC(nhist_1).address + LEN_LYNXIMGMAP;
			else
			    cp0 = HDOC(nhist_1).address;
			StrAllocCopy(temp, cp0);
			(void) trimPoundSelector(temp);
			StrAllocCat(temp, newdoc.address);
			free_address(&newdoc);
			newdoc.address = temp;
			temp = NULL;
		    }
		    tmpDocInfo = newdoc;
		    tmpNewline = -1;
		    fill_JUMP_Params(&newdoc.address);
		    getresult = getfile(&newdoc, &tmpNewline);
		    if (!reloading && !popped_doc && (tmpNewline >= 0)) {
			LYSetNewline(tmpNewline);
		    } else {
			newdoc.link = tmpDocInfo.link;
		    }
		}
	    } else {
		tmpDocInfo = newdoc;
		tmpNewline = -1;
		fill_JUMP_Params(&newdoc.address);
		getresult = getfile(&newdoc, &tmpNewline);
		if (!reloading && !popped_doc && (tmpNewline >= 0)) {
		    LYSetNewline(tmpNewline);
		} else {
		    newdoc.link = tmpDocInfo.link;
		}
	    }

#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;	/* for sure */
#endif

	    switch (getresult) {

	    case NOT_FOUND:
		/*
		 * OK!  can't find the file, so it must not be around now.  Do
		 * any error logging, if appropriate.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		if (!first_file && !LYCancelledFetch) {
		    /*
		     * Do error mail sending and/or traversal stuff.  Note that
		     * the links[] elements may not be valid at this point, if
		     * we did call HTuncache_current_document!  This should not
		     * have happened for traversal, but for sending error mail
		     * check that HTMainText exists for this reason.  - kw
		     */
		    if (error_logging && nhist > 0 && !popped_doc &&
			!LYUserSpecifiedURL &&
			HTMainText &&
			nlinks > 0 && curdoc.link < nlinks &&
			!isLYNXHIST(NonNull(newdoc.address)) &&
			!isLYNXCACHE(NonNull(newdoc.address)) &&
			!isLYNXCOOKIE(NonNull(newdoc.address))) {
			char *mail_owner = NULL;

			if (owner_address && isMAILTO_URL(owner_address)) {
			    mail_owner = owner_address + LEN_MAILTO_URL;
			}
			/*
			 * Email a bad link message to the owner of the
			 * document, or to ALERTMAIL if defined, but NOT to
			 * lynx-dev (it is rejected in mailmsg).  - FM, kw
			 */
#ifndef ALERTMAIL
			if (mail_owner)
#endif
			    mailmsg(curdoc.link,
				    mail_owner,
				    HDOC(nhist_1).address,
				    HDOC(nhist_1).title);
		    }
		    if (traversal) {
			FILE *ofp;

			if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
			    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				perror(NOOPEN_TRAV_ERR_FILE);
				exit_immediately(EXIT_FAILURE);
			    }
			}
			if (nhist > 0) {
			    fprintf(ofp,
				    "%s %s\tin %s\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target,
				    HDOC(nhist_1).address);
			} else {
			    fprintf(ofp,
				    "%s %s\t\n",
				    popped_doc ?
				    newdoc.address : links[curdoc.link].lname,
				    links[curdoc.link].target);
			}
			LYCloseOutput(ofp);
		    }
		}

		/*
		 * Fall through to do the NULL stuff and reload the old file,
		 * unless the first file wasn't found or has gone missing.
		 */
		if (!nhist) {
		    /*
		     * If nhist = 0 then it must be the first file.
		     */
		    CleanupMainLoop();
		    exit_immediately_with_error_message(NOT_FOUND, first_file);
		    return (EXIT_FAILURE);
		}
		/* FALLTHRU */

	    case NULLFILE:
		/*
		 * Not supposed to return any file.
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		popped_doc = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);
		free_address(&newdoc);	/* to pop last doc */
		FREE(newdoc.bookmark);
		LYJumpFileURL = FALSE;
		reloading = FALSE;
		LYPermitURL = FALSE;
		LYCancelledFetch = FALSE;
		ForcePush = FALSE;
		LYforce_HTML_mode = FALSE;
		force_old_UCLYhndl_on_reload = FALSE;
		if (traversal) {
		    crawl_ok = FALSE;
		    if (traversal_link_to_add) {
			/*
			 * It's a binary file, or the fetch attempt failed.
			 * Add it to TRAVERSE_REJECT_FILE so we don't try again
			 * in this run.
			 */
			if (!lookup_reject(traversal_link_to_add)) {
			    add_to_reject_list(traversal_link_to_add);
			}
			FREE(traversal_link_to_add);
		    }
		}
		/*
		 * Make sure the first file was found and has not gone missing.
		 */
		if (!nhist) {
		    /*
		     * If nhist = 0 then it must be the first file.
		     */
		    if (first_file && homepage &&
			!LYSameFilename(homepage, startfile)) {
			/*
			 * Couldn't return to the first file but there is a
			 * homepage we can use instead.  Useful for when the
			 * first URL causes a program to be invoked.  - GL
			 *
			 * But first make sure homepage is different from
			 * startfile (above), then make it the same (below) so
			 * we don't enter an infinite getfile() loop on on
			 * failures to find the files.  - FM
			 */
			set_address(&newdoc, homepage);
			LYFreePostData(&newdoc);
			FREE(newdoc.bookmark);
			StrAllocCopy(startfile, homepage);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
			newdoc.internal_link = FALSE;
			goto try_again;
		    } else {
			CleanupMainLoop();
			exit_immediately_with_error_message(NULLFILE, first_file);
			return (EXIT_FAILURE);
		    }
		}

		/*
		 * If we're going to pop from history because getfile didn't
		 * succeed, reset LYforce_no_cache first.  This would have been
		 * done in HTAccess.c if the request got that far, but the URL
		 * may have been handled or rejected in getfile without taking
		 * care of that.  - kw
		 */
		LYforce_no_cache = FALSE;
		/*
		 * Retrieval of a newdoc just failed, and just going to
		 * try_again would pop the next doc from history and try to get
		 * it without further questions.  This may not be the right
		 * thing to do if we have POST data, so fake a PREV_DOC key if
		 * it seems that some prompting should be done.  This doesn't
		 * affect the traversal logic, since with traversal POST data
		 * can never occur.  - kw
		 */
		if (HDOC(nhist - 1).post_data &&
		    !HDOC(nhist - 1).safe) {
		    if (HText_POSTReplyLoaded((DocInfo *) &history[(nhist_1)])) {
			override_LYresubmit_posts = TRUE;
			goto try_again;
		    }
		    /* Set newdoc fields, just in case the PREV_DOC gets
		     * cancelled.  - kw
		     */
		    if (!curdoc.address) {
			set_address(&newdoc, HTLoadedDocumentURL());
			StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			if (HTMainAnchor
			    && HTMainAnchor->post_data) {
			    BStrCopy(newdoc.post_data,
				     HTMainAnchor->post_data);
			    StrAllocCopy(newdoc.post_content_type,
					 HTMainAnchor->post_content_type);
			} else {
			    BStrFree(newdoc.post_data);
			}
			newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			newdoc.safe = HTLoadedDocumentIsSafe();
			newdoc.internal_link = FALSE;
		    } else {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, curdoc.title);
			BStrCopy(newdoc.post_data, curdoc.post_data);
			StrAllocCopy(newdoc.post_content_type,
				     curdoc.post_content_type);
			newdoc.isHEAD = curdoc.isHEAD;
			newdoc.safe = curdoc.safe;
			newdoc.internal_link = curdoc.internal_link;
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
		    }
		    cmd = LYK_PREV_DOC;
		    goto new_cmd;
		}
		override_LYresubmit_posts = TRUE;
		goto try_again;

	    case NORMAL:
		/*
		 * Marvelously, we got the document!
		 */
		LYoverride_no_cache = FALSE;	/* Was TRUE if popped. - FM */
		LYinternal_flag = FALSE;	/* Reset to default. - kw */
		turn_trace_back_on(&trace_mode_flag);

		/*
		 * If it's the first file and we're interactive, check whether
		 * it's a bookmark file which was not accessed via the -book
		 * switch.  - FM
		 */
		if (((first_file == TRUE) &&
		     (dump_output_immediately == FALSE) &&
		     isEmpty(newdoc.bookmark)) &&
		    ((LYisLocalFile(newdoc.address) == TRUE) &&
		     !(strcmp(NonNull(HText_getTitle()),
			      BOOKMARK_TITLE))) &&
		    (temp = HTParse(newdoc.address, "",
				    PARSE_PATH + PARSE_PUNCTUATION)) != NULL) {
		    const char *name = wwwName(Home_Dir());

		    len = (unsigned) strlen(name);
#ifdef VMS
		    if (!strncasecomp(temp, name, len) &&
			strlen(temp) > len)
#else
		    if (!StrNCmp(temp, name, len) &&
			strlen(temp) > len)
#endif /* VMS */
		    {
			/*
			 * We're interactive and this might be a bookmark file
			 * entered as a startfile rather than invoked via
			 * -book.  Check if it's in our bookmark file list, and
			 * if so, reload if with the relevant bookmark elements
			 * set.  - FM
			 */
			cp = NULL;
			if (temp[len] == '/') {
			    if (StrChr(&temp[(len + 1)], '/')) {
				HTSprintf0(&cp, ".%s", &temp[len]);
			    } else {
				StrAllocCopy(cp, &temp[(len + 1)]);
			    }
			} else {
			    StrAllocCopy(cp, &temp[len]);
			}
			for (i = 0; i <= MBM_V_MAXFILES; i++) {
			    if (MBM_A_subbookmark[i] &&
				LYSameFilename(cp, MBM_A_subbookmark[i])) {
				StrAllocCopy(BookmarkPage,
					     MBM_A_subbookmark[i]);
				break;
			    }
			}
			FREE(cp);
			if (i <= MBM_V_MAXFILES) {
			    FREE(temp);
			    if (LYValidate) {
				HTAlert(BOOKMARKS_DISABLED);
				CleanupMainLoop();
				return (EXIT_FAILURE);
			    }
			    if ((temp = HTParse(newdoc.address, "",
						PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION))) {
				set_address(&newdoc, temp);
				HTuncache_current_document();
				free_address(&curdoc);
				StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				StrAllocCat(newdoc.address, "/");
				StrAllocCat(newdoc.address,
					    (StrNCmp(BookmarkPage, "./", 2) ?
					     BookmarkPage :
					     (BookmarkPage + 2)));
				StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_COLOR_STYLE
				if (curdoc.style)
				    StrAllocCopy(newdoc.style, curdoc.style);
#endif
				StrAllocCopy(startrealm, newdoc.address);
				LYFreePostData(&newdoc);
				newdoc.isHEAD = FALSE;
				newdoc.safe = FALSE;
				FREE(temp);
				if (!strcmp(homepage, startfile))
				    StrAllocCopy(homepage, newdoc.address);
				StrAllocCopy(startfile, newdoc.address);
				CTRACE((tfp, "Reloading as bookmarks=%s\n",
					newdoc.address));
				goto try_again;
			    }
			}
		    }
		    cp = NULL;
		}
		FREE(temp);

		if (traversal) {
		    /*
		     * During traversal build up lists of all links traversed.
		     * Traversal mode is a special feature for traversing http
		     * links in the web.
		     */
		    if (traversal_link_to_add) {
			/*
			 * Add the address we sought to TRAVERSE_FILE.
			 */
			if (!lookup_link(traversal_link_to_add))
			    add_to_table(traversal_link_to_add);
			FREE(traversal_link_to_add);
		    }
		    if (curdoc.address && curdoc.title &&
			!isLYNXIMGMAP(curdoc.address))
			/*
			 * Add the address we got to TRAVERSE_FOUND_FILE.
			 */
			add_to_traverse_list(curdoc.address, curdoc.title);
		}

		/*
		 * If this was a LYNXDOWNLOAD, we still have curdoc, not a
		 * newdoc, so reset the address, title and positioning
		 * elements.  - FM
		 */
		if (newdoc.address && curdoc.address &&
		    isLYNXDOWNLOAD(newdoc.address)) {
		    copy_address(&newdoc, &curdoc);
		    StrAllocCopy(newdoc.title, NonNull(curdoc.title));
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    newdoc.internal_link = FALSE;	/* can't be true. - kw */
		}

		/*
		 * Set Newline to the saved line.  It contains the line the
		 * user was on if s/he has been in the file before, or it is 1
		 * if this is a new file.
		 *
		 * We already set Newline before getfile() and probably update
		 * it explicitly if popping from the history stack via LYpop()
		 * or LYpop_num() within getfile() cycle.
		 *
		 * In partial mode, Newline was probably updated in
		 * LYMainLoop_pageDisplay() if user scrolled the document while
		 * loading.  Incremental loading stage already closed in
		 * HT*Copy().
		 */
#ifdef DISP_PARTIAL
		/* Newline = newdoc.line; */
		display_partial = FALSE;	/* for sure, LYNXfoo:/ may be a problem */
#else
		/* Should not be needed either if we remove "DISP_PARTIAL" from
		 * LYHistory.c, but lets leave it as an important comment for
		 * now.
		 */
		/* Newline = newdoc.line; */
#endif

		/*
		 * If we are going to a target line or the first page of a
		 * popped document, override any www_search line result.
		 */
		if (LYGetNewline() > 1 || popped_doc == TRUE)
		    www_search_result = -1;

		/*
		 * Make sure curdoc.line will not be equal to Newline, so we
		 * get a redraw.
		 */
		curdoc.line = -1;
		break;
	    }			/* end switch */

	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();	/* allow me to look at the results */
		}
	    }

	    /*
	     * Set the files the same.
	     */
	    copy_address(&curdoc, &newdoc);
	    BStrCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_COLOR_STYLE
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile(curdoc.style);
#endif
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;

	    /*
	     * Set the remaining document elements and add to the visited links
	     * list.  - FM
	     */
	    if (ownerS_address != NULL) {
#ifndef USE_PRETTYSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ((LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
		    && !HText_getOwner())
#endif
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
	    }

	    /*
	     * Reset WWW present mode so that if we were getting the source, we
	     * get rendered HTML from now on.
	     */
	    HTOutputFormat = WWW_PRESENT;
#ifdef USE_PRETTYSRC
	    psrc_view = FALSE;
#endif

	    HTMLSetCharacterHandling(current_char_set);		/* restore, for sure? */

	    /*
	     * Reset all of the other relevant flags.  - FM
	     */
	    LYUserSpecifiedURL = FALSE;		/* only set for goto's and jumps's */
	    LYJumpFileURL = FALSE;	/* only set for jump's */
	    LYNoRefererForThis = FALSE;		/* always reset on return here */
	    reloading = FALSE;	/* set for RELOAD and NOCACHE keys */
	    HEAD_request = FALSE;	/* only set for HEAD requests */
	    LYPermitURL = FALSE;	/* only for LYValidate or check_realm */
	    ForcePush = FALSE;	/* only set for some PRINT requests. */
	    LYforce_HTML_mode = FALSE;
	    force_old_UCLYhndl_on_reload = FALSE;
	    popped_doc = FALSE;
	    pending_form_c = -1;

	}
	/* end if (LYforce_no_cache || force_load || are_different(...)) */
	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else if (!dump_links_only) {
		print_wwwfile_to_fd(stdout, FALSE, FALSE);
	    }
	    CleanupMainLoop();
	    return ((dump_server_status >= 400) ? EXIT_FAILURE : EXIT_SUCCESS);
	}

	/*
	 * If the recent_sizechange variable is set to TRUE then the window
	 * size changed recently.
	 */
	if (recent_sizechange) {
	    /*
	     * First we need to make sure the display library - curses, slang,
	     * whatever - gets notified about the change, and gets a chance to
	     * update external structures appropriately.  Hopefully the
	     * stop_curses()/start_curses() sequence achieves this, at least if
	     * the display library has a way to get the new screen size from
	     * the OS.
	     *
	     * However, at least for ncurses, the update of the internal
	     * structures will come still too late - the changed screen size is
	     * detected in doupdate(), which would only be called (indirectly
	     * through the HText_pageDisplay below) after the WINDOW structures
	     * are already filled based on the old size.  So we notify the
	     * ncurses library directly here.  - kw
	     */
#if defined(NCURSES) && defined(HAVE_RESIZETERM) && defined(HAVE_WRESIZE)
	    resizeterm(LYlines, LYcols);
	    wresize(LYwin, LYlines, LYcols);
#else
#if 0				/* defined(PDCURSES) && defined(HAVE_XCURSES) */
	    resize_term(LYlines, LYcols);
	    if (LYwin != 0)
		LYwin = resize_window(LYwin, LYlines, LYcols);
	    refresh();
#else
	    stop_curses();
	    start_curses();
	    LYclear();
#endif
#endif
	    refresh_screen = TRUE;	/* to force a redraw */
	    if (HTMainText)	/* to REALLY force it... - kw */
		HText_setStale(HTMainText);
	    recent_sizechange = FALSE;

	    LYSetDisplayLines();
	}

	if (www_search_result != -1) {
	    /*
	     * This was a WWW search, set the line to the result of the search.
	     */
	    LYSetNewline(www_search_result);
	    www_search_result = -1;	/* reset */
	}

	if (first_file == TRUE) {
	    /*
	     * We can never again have the first file.
	     */
	    first_file = FALSE;

	    /*
	     * Set the startrealm, and deal as best we can with preserving
	     * forced HTML mode for a local startfile.  - FM
	     */
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
	    if (isEmpty(temp)) {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
		FREE(temp);
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH + PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
		} else {
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			isFILE_URL(curdoc.address) &&
			strlen(temp) > 1) {
			/*
			 * We forced HTML for a local startfile which is not a
			 * bookmark file and has a path of at least two
			 * letters.  If it doesn't have a suffix mapped to
			 * text/html, we'll set the entire path (including the
			 * lead slash) as a "suffix" mapped to text/html to
			 * ensure it is always treated as an HTML source file.
			 * We are counting on a tail match to this full path
			 * for some other URL fetched during the session having
			 * too low a probability to worry about, but it could
			 * happen.  - FM
			 */
			HTAtom *encoding;

			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
			}
		    }
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp + 1) = '\0';
			StrAllocCat(startrealm, temp);
		    }
		}
	    }
	    FREE(temp);
	    CTRACE((tfp, "Starting realm is '%s'\n\n", startrealm));
	    if (traversal) {
		/*
		 * Set up the crawl output stuff.
		 */
		if (curdoc.address && !lookup_link(curdoc.address)) {
		    if (!isLYNXIMGMAP(curdoc.address))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
		}
		/*
		 * Set up the traversal_host comparison string.
		 */
		if (StrNCmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS + PARSE_HOST + PARSE_PUNCTUATION);
		    if (isEmpty(temp)) {
			StrAllocCopy(traversal_host, NO_NOTHING);
		    } else {
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
		    }
		    FREE(temp);
		}
		CTRACE((tfp, "Traversal host is '%s'\n\n", traversal_host));
	    }
	    if (startfile) {
		/*
		 * If homepage was not equated to startfile, make the homepage
		 * URL the first goto entry.  - FM
		 */
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
		/*
		 * If we are not starting up with startfile (e.g., had -book),
		 * or if we are using the startfile and it has no POST content,
		 * make the startfile URL a goto entry.  - FM
		 */
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
	    }
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    LYSleepAlert();
		}
	    }
	}
#ifdef USE_SOURCE_CACHE
	/*
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
	 */
	if (HTdocument_settings_changed()) {
	    if (HTcan_reparse_document()) {
		HTInfoMsg(gettext("Reparsing document under current settings..."));
		reparse_document();
	    } else {
		/*
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
		 */
		/*  currently disabled ***
		   HTUserMsg(gettext("Reparsing document under current settings..."));
		   cmd = LYK_RELOAD;
		   goto new_cmd;
		 */
	    }
	}

	if (from_source_cache) {
	    from_source_cache = FALSE;	/* reset */
	    curdoc.line = -1;	/* so curdoc.line != Newline, see below */
	}
#endif

	/*
	 * If the curdoc.line is different than Newline then there must have
	 * been a change since last update.  Run HText_pageDisplay() to create
	 * a fresh screen of text output.
	 *
	 * If we got new HTMainText go this way.  All display_partial calls
	 * ends here for final redraw.
	 */
	if (curdoc.line != LYGetNewline()) {
#ifdef INACTIVE_INPUT_STYLE_VH
	    textinput_redrawn = FALSE;
#endif

	    refresh_screen = FALSE;

	    HText_pageDisplay(LYGetNewline(), prev_target->str);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */

	    /*
	     * Check if there is more info below this page.
	     */
	    more_text = HText_canScrollDown();

	    if (newdoc.link < 0)
		goto_line(LYGetNewline());
	    LYSetNewline(HText_getTopOfScreen() + 1);
	    curdoc.line = LYGetNewline();

	    if (curdoc.title == NULL) {
		/*
		 * If we don't yet have a title, try to get it, or set to that
		 * for newdoc.title.  - FM
		 */
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
		} else {
		    StrAllocCopy(curdoc.title, newdoc.title);
		}
	    }

	    /*
	     * If the request is to highlight a link which is counted from the
	     * start of document, correct the link number:
	     */
	    if (newdoc_link_is_absolute) {
		newdoc_link_is_absolute = FALSE;
		if (curdoc.line > 1)
		    newdoc.link -= HText_LinksInLines(HTMainText, 1,
						      curdoc.line - 1);
	    }

	    if (arrowup) {
		/*
		 * arrowup is set if we just came up from a page below.
		 */
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
		    /*
		     * We may have popped a doc (possibly in local_dired) which
		     * didn't have any links when it was pushed, but does have
		     * links now (e.g., a file was created).  Code below
		     * assumes that curdoc.link is valid and that
		     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  -
		     * KW
		     */
		    curdoc.link = 0;
		}
	    }

	    show_help = FALSE;	/* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = LYGetNewline();	/* set */
	} else if (newdoc.link < 0) {
	    newdoc.link = 0;	/* ...just in case getfile set this */
	}

	/*
	 * Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		LYclear();
	    } else {
		LYerase();
	    }
#else
	    LYclear();
#endif /* FANCY_CURSES || USE_SLANG */
	    HText_pageDisplay(LYGetNewline(), prev_target->str);

#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */

	    /*
	     * Check if there is more info below this page.
	     */
	    more_text = HText_canScrollDown();

	    /*
	     * Adjust curdoc.link as above; nlinks may have changed, if the
	     * refresh_screen flag was set as a result of a size change.  Code
	     * below assumes that curdoc.link is valid and that
	     * (curdoc.link==-1) only occurs if (nlinks==0) is true.  - kw
	     */
	    if (curdoc.link >= nlinks) {
		curdoc.link = nlinks - 1;
	    } else if (curdoc.link < 0 && nlinks > 0) {
		curdoc.link = 0;
	    }

	    if (user_mode == NOVICE_MODE)
		noviceline(more_text);	/* print help message */
	    refresh_screen = FALSE;

	}

	curlink_is_editable = (BOOLEAN)
	    (nlinks > 0 &&
	     LinkIsTextLike(curdoc.link));

	use_last_tfpos = (BOOLEAN)
	    (curlink_is_editable &&
	     (real_cmd == LYK_LPOS_PREV_LINK ||
	      real_cmd == LYK_LPOS_NEXT_LINK));

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (!textfields_need_activation)
	    textinput_activated = TRUE;
#endif

#if defined(WIN_EX)		/* 1997/10/08 (Wed) 14:52:06 */
	if (nlinks > 0) {
	    char *p = "LYNX (unknown link type)";

	    /* Show the URL & kanji code . */
	    if (strlen(links[curdoc.link].lname) == 0) {

		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {

		    switch (links[curdoc.link].l_form->type) {
		    case F_TEXT_SUBMIT_TYPE:
		    case F_SUBMIT_TYPE:
		    case F_IMAGE_SUBMIT_TYPE:
			p = "[SUBMIT]";
			break;
		    case F_PASSWORD_TYPE:
			p = "Password";
			break;
		    case F_OPTION_LIST_TYPE:
			p = "Option list";
			break;
		    case F_CHECKBOX_TYPE:
			p = "Check box";
			break;
		    case F_RADIO_TYPE:
			p = "[Radio]";
			break;
		    case F_RESET_TYPE:
			p = "[Reset]";
			break;
		    case F_TEXT_TYPE:
			p = "Text input";
			break;
		    case F_TEXTAREA_TYPE:
			p = "Text input lines";
			break;
		    default:
			break;
		    }
		    set_ws_title(p);
		}
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    p = curdoc.title;
		} else {
		    p = links[curdoc.link].lname;
		}

		if (strlen(p) < (sizeof(sjis_buff) / 10)) {
		    strcpy(temp_buff, p);
		    if (StrChr(temp_buff, '%')) {
			HTUnEscape(temp_buff);
		    }
		    str_sjis(sjis_buff, temp_buff);
		    set_ws_title(LYElideString(sjis_buff, 10));
		}
	    }
	} else {
	    if (strlen(curdoc.address) < sizeof(temp_buff) - 1) {
		if (user_mode == ADVANCED_MODE) {
		    str_sjis(temp_buff, curdoc.title);
		} else {
		    strcpy(temp_buff, curdoc.address);
		}
		set_ws_title(HTUnEscape(temp_buff));
	    }
	}
#endif /* WIN_EX */

	/*
	 * Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();

	/*
	 * If help is not on the screen, then put a message on the screen to
	 * tell the user other misc info.
	 */
	if (!show_help) {
	    show_main_statusline(links[curdoc.link],
				 ((curlink_is_editable &&
				   textinput_activated)
				  ? FOR_INPUT
				  : FOR_PANEL));
	} else {
	    show_help = FALSE;
	}

	if (nlinks > 0) {
	    /*
	     * Highlight current link, unless it is an active text input field.
	     */
	    if (!curlink_is_editable) {
		LYhighlight(TRUE, curdoc.link, prev_target->str);
#ifndef INACTIVE_INPUT_STYLE_VH
	    } else if (!textinput_activated) {
		LYhighlight(TRUE, curdoc.link, prev_target->str);
#endif
	    }
	}

	if (traversal) {
	    /*
	     * Don't go interactively into forms, or accept keystrokes from the
	     * user
	     */
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile, "lnk%05d.dat", crawl_count);
#else
		sprintf(cfile, "lnk%08d.dat", crawl_count);
#endif /* FNAMES_8_3 */
		crawl_count = crawl_count + 1;
		if ((cfp = LYNewTxtFile(cfile)) != NULL) {
		    print_crawl_to_fd(cfp, curdoc.address, curdoc.title);
		    LYCloseOutput(cfp);
		} else {
#ifdef UNIX
		    FILE *fp = (dump_output_immediately
				? stderr
				: stdout);

#else
		    FILE *fp = stdout;
#endif
		    if (!dump_output_immediately)
			cleanup();
		    fprintf(fp,
			    gettext("Fatal error - could not open output file %s\n"),
			    cfile);
		    CleanupMainLoop();
		    if (!dump_output_immediately) {
			exit_immediately(EXIT_FAILURE);
		    }
		    return (EXIT_FAILURE);
		}
	    }
	} else {
	    /*
	     * Normal, non-traversal handling.
	     */
	    if (curlink_is_editable &&
		(textinput_activated || pending_form_c != -1)) {
		if (pending_form_c != -1) {
		    real_c = pending_form_c;
		    pending_form_c = -1;
		} else {
		    /*
		     * Replace novice lines if in NOVICE_MODE.
		     */
		    if (user_mode == NOVICE_MODE) {
			form_noviceline(FormIsReadonly(links[curdoc.link].l_form));
		    }
		    real_c = change_form_link(curdoc.link,
					      &newdoc, &refresh_screen,
					      use_last_tfpos, FALSE);
		}
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation)
		    textinput_activated = FALSE;
#ifdef INACTIVE_INPUT_STYLE_VH
		textinput_redrawn = FALSE;
#endif
#endif

		c = (real_c == LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
		if (c != DO_NOTHING &&
		    peek_mouse_link() != -1 && peek_mouse_link() != -2)
		    old_c = 0;
		if (peek_mouse_link() >= 0 &&
		    LKC_TO_LAC(keymap, real_c) != LYK_CHANGE_LINK) {
		    do_change_link();
		    if ((c == '\n' || c == '\r') &&
			LinkIsTextLike(curdoc.link) &&
			!textfields_need_activation) {
			c = DO_NOTHING;
		    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		} else if (LinkIsTextarea(curdoc.link)
			   && textfields_need_activation
			   && !FormIsReadonly(links[curdoc.link].l_form)
			   && peek_mouse_link() < 0 &&
			   (((LKC_TO_LAC(keymap, real_c) == LYK_NEXT_LINK ||
#ifdef TEXTAREA_AUTOGROW
			      LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE ||
#endif
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks - 1 &&
			       LinkIsTextarea(curdoc.link + 1)
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link + 1].l_form->number)
			       && strcmp(links[curdoc.link].l_form->name,
					 links[curdoc.link + 1].l_form->name)
			       == 0) ||
			      (curdoc.link == nlinks - 1 && more_text &&
			       HText_TAHasMoreLines(curdoc.link, 1)))) ||
			    ((LKC_TO_LAC(keymap, real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap, real_c) == LYK_UP_LINK) &&
			     ((curdoc.link > 0 &&
			       LinkIsTextarea(curdoc.link - 1)
			       && (links[curdoc.link].l_form->number ==
				   links[curdoc.link - 1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link - 1].l_form->name) == 0)
			      || (curdoc.link == 0 && curdoc.line > 1 &&
				  HText_TAHasMoreLines(curdoc.link, -1)))))) {
		    textinput_activated = TRUE;
#ifdef TEXTAREA_AUTOGROW
		    if ((c == '\n' || c == '\r') &&
			LKC_TO_LAC(keymap, real_c) == LYK_ACTIVATE)
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
#endif /* TEXTAREA_AUTOGROW */
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION */
		} else
		    switch (c) {
		    case '\n':
		    case '\r':
#ifdef TEXTAREA_AUTOGROW
			/*
			 * If on the bottom line of a TEXTAREA, and the user
			 * hit the ENTER key, we add a new line/anchor
			 * automatically, positioning the cursor on it.
			 *
			 * If at the bottom of the screen, we effectively
			 * perform an LYK_DOWN_HALF-like operation, then move
			 * down to the new line we just added.  --KED 02/14/99
			 *
			 * [There is some redundancy and non-standard
			 * indentation in the monster-if() below.  This is
			 * intentional ...  to try and improve the
			 * "readability" (such as it is).  Caveat emptor to
			 * anyone trying to change it.]
			 */
			if (LinkIsTextarea(curdoc.link)
			    && ((curdoc.link == nlinks - 1 &&
				 !(more_text &&
				   HText_TAHasMoreLines(curdoc.link, 1)))
				||
				((curdoc.link < nlinks - 1) &&
				 !LinkIsTextarea(curdoc.link + 1))
				||
				((curdoc.link < nlinks - 1) &&
				 (LinkIsTextarea(curdoc.link + 1)
				  && ((links[curdoc.link].l_form->number !=
				       links[curdoc.link + 1].l_form->number) ||
				      (strcmp(links[curdoc.link].l_form->name,
					      links[curdoc.link + 1].l_form->name)
				       != 0)))))) {

			    HText_ExpandTextarea(&links[curdoc.link], 1);

			    if (links[curdoc.link].ly < display_lines) {
				refresh_screen = TRUE;
			    } else {
				LYChgNewline(display_lines / 2);
				if (nlinks > 0 && curdoc.link > -1 &&
				    links[curdoc.link].ly > display_lines / 2) {
				    newdoc.link = curdoc.link;
				    for (i = 0;
					 links[i].ly <= (display_lines / 2);
					 i++)
					--newdoc.link;
				    newdoc.link++;
				}
			    }
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			    if (textfields_need_activation) {
				textinput_activated = TRUE;
				textfields_need_activation = textfields_activation_option;
#ifdef INACTIVE_INPUT_STYLE_VH
				textinput_redrawn = TRUE;
#endif
			    };
#endif

			}
#endif /* TEXTAREA_AUTOGROW */

			/*
			 * Make return in input field (if it was returned by
			 * change_form_link) act as LYK_NEXT_LINK, independent
			 * of what key (if any) is mapped to LYK_NEXT_LINK.  -
			 * kw
			 */
			c = LAC_TO_LKC0(LYK_NEXT_LINK);
			break;
		    default:

			if (old_c != c && old_c != real_c && c != real_c)
			    real_c = c;
		    }
	    } else {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
		if (curlink_is_editable && !textinput_redrawn) {
		    /*draw the text entry, but don't activate it */
		    textinput_redrawn = TRUE;
		    change_form_link_ex(curdoc.link,
					&newdoc, &refresh_screen,
					use_last_tfpos, FALSE, TRUE);
		    if (LYShowCursor) {
			LYmove(links[curdoc.link].ly,
			       ((links[curdoc.link].lx > 0) ?
				(links[curdoc.link].lx - 1) : 0));
		    } else {
			LYHideCursor();
		    }
		}
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
		/*
		 * Get a keystroke from the user.  Save the last keystroke to
		 * avoid redundant error reporting.
		 */
		real_c = c = LYgetch();		/* get user input */

		if (c != last_key)
		    key_count = 0;
		key_count++;
		last_key = c;
#ifndef VMS
		if (c == 3) {	/* ^C */
		    /*
		     * This shouldn't happen.  We'll try to deal with whatever
		     * bug caused it.  - FM
		     */
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
		}
#endif /* !VMS */
		if (LKC_HAS_ESC_MOD(c) && EditBinding(c) != LYE_FORM_PASS) {
		    /*
		     * If ESC + <key> was read (and not recognized as a
		     * terminal escape sequence for another key), ignore the
		     * ESC modifier and act on <key> only if the line editor
		     * binding would have passed the same ESC-modified
		     * lynxkeycode back to us if it had been pressed in a text
		     * input field.  Otherwise set interesting part so that it
		     * will map to 0, to prevent that ESC + <key> acts like
		     * <key>, which might be unexpected.  - kw
		     */
		    c = (c & ~LKC_MASK) | LAC_TO_LKC(0);
		}
		if (old_c != real_c) {
		    old_c = 0;
		}
	    }
	}

#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
#else
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
#endif /* VMS */

      new_keyboard_input:
	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
	if (traversal) {
	    if ((c = DoTraversal(c, &crawl_ok)) < 0) {
		CleanupMainLoop();
		return (EXIT_FAILURE);
	    }
	}
	/* traversal */
#ifdef WIN_EX
	if (c == DO_NOTHING)
	    cmd = LYK_DO_NOTHING;
	else
#endif
	    cmd = LKC_TO_LAC(keymap, c);	/* adds 1 to map EOF to 0 */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override, c))
	    cmd = LKC_TO_LAC(key_override, c);
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

	real_cmd = cmd;

	/*
	 * A goto point for new input without going back through the getch()
	 * loop.
	 */
      new_cmd:

	force_old_UCLYhndl_on_reload = FALSE;
	CTRACE_FLUSH(tfp);

	if (cmd != LYK_UP_LINK && cmd != LYK_DOWN_LINK)
	    follow_col = -1;

	CTRACE((tfp, "Handling key as %s\n",
		((LYKeycodeToKcmd((LYKeymapCode) cmd) != 0)
		 ? LYKeycodeToKcmd((LYKeymapCode) cmd)->name
		 : "unknown")));
	switch (cmd) {
	case -1:
	    HTUserMsg(COMMAND_UNKNOWN);
	    break;
	case 0:		/* unmapped character */
	default:
	    if (curdoc.link >= 0 && curdoc.link < nlinks &&
		LinkIsTextLike(curdoc.link)) {

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (textfields_need_activation) {
		    show_main_statusline(links[curdoc.link], FOR_PANEL);
#ifdef INACTIVE_INPUT_STYLE_VH
		    textinput_redrawn = FALSE;
#endif
		} else
#endif
		    show_main_statusline(links[curdoc.link], FOR_INPUT);
	    } else if (more_text) {
		HTInfoMsg(MOREHELP);
	    } else {
		HTInfoMsg(HELP);
	    }
	    show_help = TRUE;

	    if (TRACE) {
		sprintf(cfile, "%d", c);
		LYaddstr(cfile);	/* show the user input */
		cfile[0] = '\0';
	    }
	    break;

	case LYK_COMMAND:
	    cmd = handle_LYK_COMMAND(&user_input_buffer);
	    goto new_cmd;

	case LYK_INTERRUPT:
	    /*
	     * No network transmission to interrupt - 'til we multithread.
	     */
	    break;

	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    handle_LYK_digit(c, &force_load, &old_c, real_c, &try_internal);
	    break;

	case LYK_SOURCE:	/* toggle view source mode */
	    handle_LYK_SOURCE(&ownerS_address);
	    break;

	case LYK_CHANGE_CENTER:	/* ^Q */

	    if (no_table_center) {
		no_table_center = FALSE;
		HTInfoMsg(gettext("TABLE center enable."));
	    } else {
		no_table_center = TRUE;
		HTInfoMsg(gettext("TABLE center disable."));
	    }
	    /* FALLTHRU */

	case LYK_RELOAD:	/* control-R to reload and refresh */
	    handle_LYK_RELOAD(real_cmd);
	    break;

	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
	    handle_LYK_HISTORICAL();
	    break;

	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    handle_LYK_MINIMAL();
	    break;

	case LYK_SOFT_DQUOTES:
	    handle_LYK_SOFT_DQUOTES();
	    break;

	case LYK_SWITCH_DTD:
	    handle_LYK_SWITCH_DTD();
	    break;

	case LYK_QUIT:		/* quit */
	    if (handle_LYK_QUIT()) {
		CleanupMainLoop();
		return (EXIT_SUCCESS);
	    }
	    break;

	case LYK_ABORT:	/* don't ask the user about quitting */
	    CleanupMainLoop();
	    return (EXIT_SUCCESS);

	case LYK_NEXT_PAGE:	/* next page */
	    handle_LYK_NEXT_PAGE(&old_c, real_c);
	    break;

	case LYK_PREV_PAGE:	/* page up */
	    handle_LYK_PREV_PAGE(&old_c, real_c);
	    break;

	case LYK_UP_TWO:
	    handle_LYK_UP_TWO(&arrowup, &old_c, real_c);
	    break;

	case LYK_DOWN_TWO:
	    handle_LYK_DOWN_TWO(&old_c, real_c);
	    break;

	case LYK_UP_HALF:
	    handle_LYK_UP_HALF(&arrowup, &old_c, real_c);
	    break;

	case LYK_DOWN_HALF:
	    handle_LYK_DOWN_HALF(&old_c, real_c);
	    break;

#ifdef CAN_CUT_AND_PASTE
	case LYK_TO_CLIPBOARD:	/* ^S */
	    {
		char *s;
		int ch2;

		/* The logic resembles one of ADD_BOOKMARK */
		if (nlinks > 0 && links[curdoc.link].lname
		    && links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
		    /* Makes sense to copy a link */
		    _statusline("Copy D)ocument's or L)ink's URL to clipboard or C)ancel?");
		    ch2 = LYgetch_single();
		    if (ch2 == 'D')
			s = curdoc.address;
		    else if (ch2 == 'C')
			break;
		    else
			s = links[curdoc.link].lname;
		} else
		    s = curdoc.address;
		if (isEmpty(s))
		    HTInfoMsg(gettext("Current URL is empty."));
		if (put_clip(s))
		    HTInfoMsg(gettext("Copy to clipboard failed."));
		else if (s == curdoc.address)
		    HTInfoMsg(gettext("Document URL put to clipboard."));
		else
		    HTInfoMsg(gettext("Link URL put to clipboard."));
	    }
	    break;

	case LYK_PASTE_URL:
	    if (no_goto && !LYValidate) {	/*  Go to not allowed. - FM */
		HTUserMsg(GOTO_DISALLOWED);
	    } else {
		unsigned char *s = (unsigned char *) get_clip_grab(), *e, *t;
		char *buf;
		int len2;

		if (!s)
		    break;
		len2 = (int) strlen((const char *) s);
		e = s + len2;
		while (s < e && StrChr(" \t\n\r", *s))
		    s++;
		while (s < e && StrChr(" \t\n\r", e[-1]))
		    e--;
		if (s[0] == '<' && e > s && e[-1] == '>') {
		    s++;
		    e--;
		    if (!strncasecomp((const char *) s, "URL:", 4))
			s += 4;
		}
		if (s >= e) {
		    HTInfoMsg(gettext("No URL in the clipboard."));
		    break;
		}
		len = (unsigned) (e - s + 1);
		if (len < MAX_LINE)
		    len = MAX_LINE;	/* Required for do_check_goto_URL() */
		buf = typeMallocn(char, len);

		LYStrNCpy(buf, (const char *) s, (e - s));
		t = (unsigned char *) buf;

		while (s < e) {
		    if (StrChr(" \t\n\r", *s)) {
			int nl2 = 0;	/* Keep whitespace without NL - file names! */
			unsigned char *s1 = s;

			while (StrChr(" \t\n\r", *s)) {
			    if (!nl2 && *s == '\n')
				nl2 = 1;
			    s++;
			}
			if (!nl2) {
			    while (s1 < s) {
				if (*s1 != '\r' && *s1 != '\n')
				    *t = *s1;
				t++, s1++;
			    }
			}
		    } else
			*t++ = *s++;
		}
		*t = '\0';
		get_clip_release();
		BStrCopy0(user_input_buffer, buf);
		do_check_goto_URL(&user_input_buffer, &temp, &force_load);
		free(buf);
	    }
	    break;
#endif

#ifdef KANJI_CODE_OVERRIDE
	case LYK_CHG_KCODE:
	    if (LYRawMode && (HTCJK == JAPANESE)) {
		switch (last_kcode) {
		case NOKANJI:
		    last_kcode = SJIS;
		    break;
		case SJIS:
		    last_kcode = EUC;
		    break;
		case EUC:
		    last_kcode = NOKANJI;
		    break;
		default:
		    break;
		}
	    }
	    LYmove(0, 0);
	    lynx_start_title_color();
	    LYaddstr(str_kcode(last_kcode));
	    lynx_stop_title_color();

	    break;
#endif

	case LYK_REFRESH:
	    refresh_screen = TRUE;
	    lynx_force_repaint();
	    break;

	case LYK_HOME:
	    if (curdoc.line > 1) {
		LYSetNewline(1);
	    } else {
		cmd = LYK_PREV_PAGE;
		goto new_cmd;
	    }
	    break;

	case LYK_END:
	    i = HText_getNumOfLines() - display_lines + 2;
	    if (i >= 1 && LYGetNewline() != i) {
		LYSetNewline(i);	/* go to end of file */
		arrowup = TRUE;	/* position on last link */
	    } else {
		cmd = LYK_NEXT_PAGE;
		goto new_cmd;
	    }
	    break;

	case LYK_FIRST_LINK:
	    handle_LYK_FIRST_LINK();
	    break;

	case LYK_LAST_LINK:
	    handle_LYK_LAST_LINK();
	    break;

	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	    handle_LYK_PREV_LINK(&arrowup, &old_c, real_c);
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	    handle_LYK_NEXT_LINK(c, &old_c, real_c);
	    break;

	case LYK_FASTFORW_LINK:
	    handle_LYK_FASTFORW_LINK(&old_c, real_c);
	    break;

	case LYK_FASTBACKW_LINK:
	    if (handle_LYK_FASTBACKW_LINK(&cmd, &old_c, real_c))
		goto new_cmd;
	    break;

	case LYK_UP_LINK:
	    handle_LYK_UP_LINK(&follow_col, &arrowup, &old_c, real_c);
	    break;

	case LYK_DOWN_LINK:
	    handle_LYK_DOWN_LINK(&follow_col, &old_c, real_c);
	    break;

	case LYK_CHANGE_LINK:
	    do_change_link();
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	    if (textfields_need_activation)
		textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    break;

	case LYK_RIGHT_LINK:
	    handle_LYK_RIGHT_LINK();
	    break;

	case LYK_LEFT_LINK:
	    handle_LYK_LEFT_LINK();
	    break;

	case LYK_COOKIE_JAR:	/* show the cookie jar */
	    if (handle_LYK_COOKIE_JAR(&cmd))
		goto new_cmd;
	    break;

#ifdef USE_CACHEJAR
	case LYK_CACHE_JAR:	/* show the cache jar */
	    if (handle_LYK_CACHE_JAR(&cmd))
		goto new_cmd;
	    break;
#endif

	case LYK_HISTORY:	/* show the history page */
	    if (handle_LYK_HISTORY(ForcePush))
		break;

	    /* FALLTHRU */
	case LYK_PREV_DOC:	/* back up a level */
	    switch (handle_PREV_DOC(&cmd, &old_c, real_c)) {
	    case 1:
		CleanupMainLoop();
		return (EXIT_SUCCESS);
	    case 2:
		goto new_cmd;
	    }
	    break;

	case LYK_NEXT_DOC:	/* undo back up a level */
	    handle_NEXT_DOC();
	    break;

	case LYK_NOCACHE:	/* Force submission of form or link with no-cache */
	    if (!handle_LYK_NOCACHE(&old_c, real_c))
		break;

	    /* FALLTHRU */
	case LYK_ACTIVATE:	/* follow a link */
	case LYK_MOUSE_SUBMIT:	/* follow a link, submit TEXT_SUBMIT input */
	    switch (handle_LYK_ACTIVATE(&c,
					cmd,
					&try_internal,
					&refresh_screen,
					&force_load,
					real_cmd)) {
	    case 1:
		continue;
	    case 2:
		goto new_keyboard_input;
	    case 3:
		pending_form_c = c;
		break;
	    }
	    break;

	case LYK_SUBMIT:
	    handle_LYK_SUBMIT(curdoc.link, &newdoc, &refresh_screen);
	    break;

	case LYK_RESET:
	    handle_LYK_RESET(curdoc.link, &refresh_screen);
	    break;

	case LYK_ELGOTO:	/* edit URL of current link and go to it  */
	    if (handle_LYK_ELGOTO(&ch, &user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(&user_input_buffer, &temp, &force_load);
	    break;

	case LYK_ECGOTO:	/* edit current URL and go to to it     */
	    if (handle_LYK_ECGOTO(&ch, &user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(&user_input_buffer, &temp, &force_load);
	    break;

	case LYK_GOTO:		/* 'g' to goto a random URL  */
	    if (handle_LYK_GOTO(&ch, &user_input_buffer, &temp, &recall,
				&URLTotal, &URLNum, &FirstURLRecall, &old_c,
				real_c)) {
		if (do_check_recall(ch, &user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(&user_input_buffer, &temp, &force_load);
	    }
	    break;

	case LYK_DWIMHELP:	/* show context-dependent help file */
	    handle_LYK_DWIMHELP(&cshelpfile);
	    /* FALLTHRU */

	case LYK_HELP:		/* show help file */
	    handle_LYK_HELP(&cshelpfile);
	    break;

	case LYK_INDEX:	/* index file */
	    handle_LYK_INDEX(&old_c, real_c);
	    break;

	case LYK_MAIN_MENU:	/* return to main screen */
	    handle_LYK_MAIN_MENU(&old_c, real_c);
	    break;

#ifdef EXP_NESTED_TABLES
	case LYK_NESTED_TABLES:
	    if (handle_LYK_NESTED_TABLES(&cmd))
		goto new_cmd;
	    break;
#endif
	case LYK_OPTIONS:	/* options screen */
	    if (handle_LYK_OPTIONS(&cmd, &refresh_screen))
		goto new_cmd;
	    break;

	case LYK_INDEX_SEARCH:	/* search for a user string */
	    handle_LYK_INDEX_SEARCH(&force_load, ForcePush, &old_c, real_c);
	    break;

	case LYK_WHEREIS:	/* search within the document */
	case LYK_NEXT:		/* find the next occurrence in the document */
	case LYK_PREV:		/* find the previous occurrence in the document */
	    handle_LYK_WHEREIS(cmd, &refresh_screen);
	    break;

	case LYK_COMMENT:	/* reply by mail */
	    handle_LYK_COMMENT(&refresh_screen, &owner_address, &old_c, real_c);
	    break;

#ifdef DIRED_SUPPORT
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    handle_LYK_TAG_LINK();
	    break;

	case LYK_MODIFY:	/* rename a file or directory */
	    handle_LYK_MODIFY(&refresh_screen);
	    break;

	case LYK_CREATE:	/* create a new file or directory */
	    handle_LYK_CREATE();
	    break;
#endif /* DIRED_SUPPORT */

	case LYK_DWIMEDIT:	/* context-dependent edit */
	    switch (handle_LYK_DWIMEDIT(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
	    }
	    /* FALLTHRU */

	case LYK_EDIT:		/* edit */
	    handle_LYK_EDIT(&old_c, real_c);
	    break;

	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
	    handle_LYK_DEL_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

#ifdef DIRED_SUPPORT
	case LYK_REMOVE:	/* remove files and directories */
	    handle_LYK_REMOVE(&refresh_screen);
	    break;
#endif /* DIRED_SUPPORT */

#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
	case LYK_INSTALL:	/* install a file into system area */
	    handle_LYK_INSTALL();
	    break;
#endif /* DIRED_SUPPORT && OK_INSTALL */

	case LYK_INFO:		/* show document info */
	    if (handle_LYK_INFO(&cmd))
		goto new_cmd;
	    break;

	case LYK_EDITTEXTAREA:	/* use external editor on a TEXTAREA - KED */
	    handle_LYK_EDIT_TEXTAREA(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_GROWTEXTAREA:	/* add new lines to bottom of TEXTAREA - KED */
	    handle_LYK_GROW_TEXTAREA(&refresh_screen);
	    break;

	case LYK_INSERTFILE:	/* insert file in TEXTAREA, above cursor - KED */
	    handle_LYK_INSERT_FILE(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_PRINT:	/* print the file */
	    handle_LYK_PRINT(&ForcePush, &old_c, real_c);
	    break;

	case LYK_LIST:		/* list links in the current document */
	    if (handle_LYK_LIST(&cmd))
		goto new_cmd;
	    break;

#ifdef USE_ADDRLIST_PAGE
	case LYK_ADDRLIST:	/* always list URL's (only) */
	    if (handle_LYK_ADDRLIST(&cmd))
		goto new_cmd;
	    break;
#endif /* USE_ADDRLIST_PAGE */

	case LYK_VLINKS:	/* list links visited during the current session */
	    if (handle_LYK_VLINKS(&cmd, &newdoc_link_is_absolute))
		goto new_cmd;
	    break;

	case LYK_TOOLBAR:	/* go to Toolbar or Banner in current document */
	    handle_LYK_TOOLBAR(&try_internal, &force_load, &old_c, real_c);
	    break;

#if defined(DIRED_SUPPORT) || defined(VMS)
	case LYK_DIRED_MENU:	/* provide full file management menu */
	    handle_LYK_DIRED_MENU(&refresh_screen, &old_c, real_c);
	    break;
#endif /* DIRED_SUPPORT || VMS */

#ifdef USE_EXTERNALS
	case LYK_EXTERN_LINK:	/* use external program on url */
	    handle_LYK_EXTERN_LINK(&refresh_screen);
	    break;
	case LYK_EXTERN_PAGE:	/* use external program on current page */
	    handle_LYK_EXTERN_PAGE(&refresh_screen);
	    break;
#endif /* USE_EXTERNALS */

	case LYK_ADD_BOOKMARK:	/* add link to bookmark file */
	    handle_LYK_ADD_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_VIEW_BOOKMARK:	/* v to view home page */
	    handle_LYK_VIEW_BOOKMARK(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_SHELL:	/* (!) shell escape */
	    handle_LYK_SHELL(&refresh_screen, &old_c, real_c);
	    break;

	case LYK_DOWNLOAD:
	    switch (handle_LYK_DOWNLOAD(&cmd, &old_c, real_c)) {
	    case 1:
		continue;
	    case 2:
		goto new_cmd;
	    }
	    break;

#ifdef DIRED_SUPPORT
	case LYK_UPLOAD:
	    handle_LYK_UPLOAD();
	    break;
#endif /* DIRED_SUPPORT */

	case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	    handle_LYK_TRACE_TOGGLE();
	    break;

	case LYK_TRACE_LOG:	/*  View TRACE log. */
	    handle_LYK_TRACE_LOG(&trace_mode_flag);
	    break;

	case LYK_IMAGE_TOGGLE:
	    if (handle_LYK_IMAGE_TOGGLE(&cmd))
		goto new_cmd;
	    break;

	case LYK_INLINE_TOGGLE:
	    if (handle_LYK_INLINE_TOGGLE(&cmd))
		goto new_cmd;
	    break;

	case LYK_RAW_TOGGLE:
	    if (handle_LYK_RAW_TOGGLE(&cmd))
		goto new_cmd;
	    break;

	case LYK_HEAD:
	    if (handle_LYK_HEAD(&cmd))
		goto new_cmd;
	    break;

	case LYK_TOGGLE_HELP:
	    handle_LYK_TOGGLE_HELP();
	    break;

	case LYK_EDITMAP:
	    handle_LYK_EDITMAP(&old_c, real_c);
	    break;

	case LYK_KEYMAP:
	    handle_LYK_KEYMAP(&vi_keys_flag, &emacs_keys_flag, &old_c, real_c);
	    break;

	case LYK_JUMP:
	    if (handle_LYK_JUMP(c, &user_input_buffer, &temp, &recall,
				&FirstURLRecall, &URLNum, &URLTotal, &ch,
				&old_c, real_c)) {
		if (do_check_recall(ch, &user_input_buffer, &temp, URLTotal,
				    &URLNum, recall, &FirstURLRecall))
		    do_check_goto_URL(&user_input_buffer, &temp, &force_load);
	    }
	    break;

	case LYK_CLEAR_AUTH:
	    handle_LYK_CLEAR_AUTH(&old_c, real_c);
	    break;

	case LYK_DO_NOTHING:	/* pretty self explanatory */
	    break;
#ifdef SUPPORT_CHDIR
	case LYK_CHDIR:
	    handle_LYK_CHDIR();
	    break;
	case LYK_PWD:
	    handle_LYK_PWD();
	    break;
#endif
#ifdef USE_CURSES_PADS
	case LYK_SHIFT_LEFT:
	    handle_LYK_SHIFT_LEFT(&refresh_screen, key_count);
	    break;
	case LYK_SHIFT_RIGHT:
	    handle_LYK_SHIFT_RIGHT(&refresh_screen, key_count);
	    break;
	case LYK_LINEWRAP_TOGGLE:
	    if (handle_LYK_LINEWRAP_TOGGLE(&cmd, &refresh_screen))
		goto new_cmd;
	    break;
#endif

#ifdef USE_MAXSCREEN_TOGGLE
	case LYK_MAXSCREEN_TOGGLE:
	    if (handle_LYK_MAXSCREEN_TOGGLE(&cmd))
		goto new_cmd;
	    break;
#endif
	}			/* end of BIG switch */
    }
}

static int are_different(DocInfo *doc1, DocInfo *doc2)
{
    char *cp1, *cp2;

    /*
     * Do we have two addresses?
     */
    if (!doc1->address || !doc2->address)
	return (TRUE);

    /*
     * Do they differ in the type of request?
     */
    if (doc1->isHEAD != doc2->isHEAD)
	return (TRUE);

    /*
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
     */
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
    /*
     * Are the base addresses different?
     */
    if (strcmp(doc1->address, doc2->address)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
	return (TRUE);
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);

    /*
     * Do the docs have different contents?
     */
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
		return (TRUE);
	} else
	    return (TRUE);
    } else if (doc2->post_data)
	return (TRUE);

    /*
     * We'll assume the two documents in fact are the same.
     */
    return (FALSE);
}

/* This determines whether two docs are _physically_ different,
 * meaning they are "from different files". - kw
 */
static int are_phys_different(DocInfo *doc1, DocInfo *doc2)
{
    char *cp1, *cp2, *ap1 = doc1->address, *ap2 = doc2->address;

    /*
     * Do we have two addresses?
     */
    if (!doc1->address || !doc2->address)
	return (TRUE);

    /*
     * Do they differ in the type of request?
     */
    if (doc1->isHEAD != doc2->isHEAD)
	return (TRUE);

    /*
     * Skip over possible LYNXIMGMAP parts. - kw
     */
    if (isLYNXIMGMAP(doc1->address))
	ap1 += LEN_LYNXIMGMAP;
    if (isLYNXIMGMAP(doc2->address))
	ap2 += LEN_LYNXIMGMAP;
    /*
     * If there isn't any real URL in doc2->address, but maybe just
     * a fragment, doc2 is assumed to be an internal reference in
     * the same physical document, so return FALSE. - kw
     */
    if (*ap2 == '\0' || *ap2 == '#')
	return (FALSE);

    /*
     * See if the addresses are different, making sure we're not tripped up by
     * multiple anchors in the the same document from a POST form.  -- FM
     */
    cp1 = trimPoundSelector(doc1->address);
    cp2 = trimPoundSelector(doc2->address);
    /*
     * Are the base addresses different?
     */
    if (strcmp(ap1, ap2)) {
	restorePoundSelector(cp1);
	restorePoundSelector(cp2);
	return (TRUE);
    }
    restorePoundSelector(cp1);
    restorePoundSelector(cp2);

    /*
     * Do the docs have different contents?
     */
    if (doc1->post_data) {
	if (doc2->post_data) {
	    if (!BINEQ(doc1->post_data, doc2->post_data))
		return (TRUE);
	} else
	    return (TRUE);
    } else if (doc2->post_data)
	return (TRUE);

    /*
     * We'll assume the two documents in fact are the same.
     */
    return (FALSE);
}

/*
 * Utility for freeing the list of goto URLs.  - FM
 */
#ifdef LY_FIND_LEAKS
static void HTGotoURLs_free(void)
{
    LYFreeStringList(Goto_URLs);
    Goto_URLs = NULL;
}
#endif

/*
 * Utility for listing Goto URLs, making any repeated URLs the most current in
 * the list.  - FM
 */
void HTAddGotoURL(char *url)
{
    char *copy = NULL;
    char *old;
    HTList *cur;

    if (isEmpty(url))
	return;

    CTRACE((tfp, "HTAddGotoURL %s\n", url));
    StrAllocCopy(copy, url);

    if (!Goto_URLs) {
	Goto_URLs = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTGotoURLs_free);
#endif
	HTList_addObject(Goto_URLs, copy);
	return;
    }

    cur = Goto_URLs;
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, copy)) {
	    HTList_removeObject(Goto_URLs, old);
	    FREE(old);
	    break;
	}
    }
    HTList_addObject(Goto_URLs, copy);

    return;
}

/*
 * When help is not on the screen, put a message on the screen to tell the user
 * other misc info.
 */
static void show_main_statusline(const LinkInfo curlink,
				 int for_what)
{
    /*
     * Make sure form novice lines are replaced.
     */
    if (user_mode == NOVICE_MODE && for_what != FOR_INPUT) {
	noviceline(more_text);
    }

    if (HTisDocumentSource()) {
	/*
	 * Currently displaying HTML source.
	 */
	_statusline(SOURCE_HELP);

	/*
	 * If we are in forms mode then explicitly tell the user what each kind
	 * of link is.
	 */
#ifdef INDICATE_FORMS_MODE_FOR_ALL_LINKS_ON_PAGE
    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0) {
#else
#ifdef NORMAL_NON_FORM_LINK_STATUSLINES_FOR_ALL_USER_MODES
    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0 &&
	       !(curlink.type & WWW_LINK_TYPE)) {
#else
    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0 &&
	       !(user_mode == ADVANCED_MODE &&
		 (curlink.type & WWW_LINK_TYPE))) {
#endif /* NORMAL_NON_FORM_LINK_STATUSLINES_FOR_ALL_USER_MODES */
#endif /* INDICATE_FORMS_MODE_FOR_ALL_LINKS_ON_PAGE */
	if (curlink.type == WWW_FORM_LINK_TYPE) {
	    show_formlink_statusline(curlink.l_form, for_what);
	} else {
	    statusline(NORMAL_LINK_MESSAGE);
	}

	/*
	 * Let them know if it's an index -- very rare.
	 */
	if (is_www_index) {
	    const char *indx = gettext("-index-");

	    LYmove(LYlines - 1, LYcolLimit - (int) strlen(indx));
	    lynx_start_reverse();
	    LYaddstr(indx);
	    lynx_stop_reverse();
	}

    } else if (user_mode == ADVANCED_MODE && nlinks > 0) {
	/*
	 * Show the URL or, for some internal links, the fragment
	 */
	char *cp = NULL;

	if (curlink.type == WWW_INTERN_LINK_TYPE &&
	    !isLYNXIMGMAP(curlink.lname)) {
	    cp = findPoundSelector(curlink.lname);
	}
	if (!cp)
	    cp = curlink.lname;
	status_link(cp, more_text, is_www_index);
    } else if (is_www_index && more_text) {
	char buf[128];

	sprintf(buf, WWW_INDEX_MORE_MESSAGE, key_for_func(LYK_INDEX_SEARCH));
	_statusline(buf);
    } else if (is_www_index) {
	char buf[128];

	sprintf(buf, WWW_INDEX_MESSAGE, key_for_func(LYK_INDEX_SEARCH));
	_statusline(buf);
    } else if (more_text) {
	if (user_mode == NOVICE_MODE)
	    _statusline(MORE);
	else
	    _statusline(MOREHELP);
    } else {
	_statusline(HELP);
    }

    /* turn off cursor since now it's probably on statusline -HV */
    /* But not if LYShowCursor is on.  -show_cursor may be used as a
     * workaround to avoid putting the cursor in the last position, for
     * curses implementations or terminals that cannot deal with that
     * correctly. - kw */
    if (!LYShowCursor) {
	LYHideCursor();
    }
}

/*
 * Public function for redrawing the statusline appropriate for the selected
 * link.  It should only be called at times when curdoc.link, nlinks, and the
 * links[] array are valid.  - kw
 */
void repaint_main_statusline(int for_what)
{
    if (curdoc.link >= 0 && curdoc.link < nlinks)
	show_main_statusline(links[curdoc.link], for_what);
}

static void form_noviceline(int disabled)
{
    LYmove(LYlines - 2, 0);
    LYclrtoeol();
    if (!disabled) {
	LYaddstr(FORM_NOVICELINE_ONE);
    }
    LYParkCursor();

    if (disabled)
	return;
    if (EditBinding(FROMASCII('\025')) == LYE_ERASE) {
	LYaddstr(FORM_NOVICELINE_TWO);
    } else if (EditBinding(FROMASCII('\025')) == LYE_DELBL) {
	LYaddstr(FORM_NOVICELINE_TWO_DELBL);
    } else {
	char *temp = NULL;
	char *erasekey = fmt_keys(LYKeyForEditAction(LYE_ERASE), -1);

	if (erasekey) {
	    HTSprintf0(&temp, FORM_NOVICELINE_TWO_VAR, erasekey);
	} else {
	    erasekey = fmt_keys(LYKeyForEditAction(LYE_DELBL), -1);
	    if (erasekey)
		HTSprintf0(&temp,
			   FORM_NOVICELINE_TWO_DELBL_VAR, erasekey);
	}
	if (temp) {
	    LYaddstr(temp);
	    FREE(temp);
	}
	FREE(erasekey);
    }
}

static void exit_immediately_with_error_message(int state, int first_file)
{
    char *buf = 0;
    char *buf2 = 0;

    if (first_file) {
	/* print statusline messages as a hint, if any */
	LYstatusline_messages_on_exit(&buf2);
    }

    if (state == NOT_FOUND) {
	HTSprintf0(&buf, "%s\n%s %s\n",
		   NonNull(buf2),
		   gettext("lynx: Can't access startfile"),
	/*
	 * hack: if we fail in HTAccess.c
	 * avoid duplicating URL, oh.
	 */
		   (buf2 && strstr(buf2, gettext("Can't Access"))) ?
		   "" : startfile);
    }

    if (state == NULLFILE) {
	HTSprintf0(&buf, "%s\n%s\n%s\n",
		   NonNull(buf2),
		   gettext("lynx: Start file could not be found or is not text/html or text/plain"),
		   gettext("      Exiting..."));
    }

    FREE(buf2);

    if (!dump_output_immediately)
	cleanup();

    if (buf != 0) {
#ifdef UNIX
	if (dump_output_immediately) {
	    fputs(buf, stderr);
	} else
#endif /* UNIX */
	{
	    SetOutputMode(O_TEXT);
	    fputs(buf, stdout);
	    SetOutputMode(O_BINARY);
	}

	FREE(buf);
    }

    if (!dump_output_immediately) {
	exit_immediately(EXIT_FAILURE);
    }
    /* else: return(EXIT_FAILURE) in mainloop */
}

static void status_link(char *curlink_name,
			int show_more,
			int show_indx)
{
#define MAX_STATUS (LYcolLimit - 1)
#define MIN_STATUS 0
    char format[MAX_LINE];
    int prefix = 0;
    int length;

    *format = 0;
    if (show_more && !nomore) {
	sprintf(format, "%.*s ",
		(int) (sizeof(format) - 2),
		gettext("-more-"));
	prefix = (int) strlen(format);
    }
    if (show_indx) {
	sprintf(format + prefix, "%.*s ",
		((int) sizeof(format) - prefix - 2),
		gettext("-index-"));
    }
    prefix = (int) strlen(format);
    length = (int) strlen(curlink_name);

    if (prefix > MAX_STATUS || prefix >= MAX_LINE - 1) {
	_user_message("%s", format);	/* no room for url */
    } else {
	sprintf(format + prefix, "%%.%ds", MAX_STATUS - prefix);

	if ((length + prefix > MAX_STATUS) && long_url_ok) {
	    char *buf = NULL;
	    int cut_from_pos;
	    int cut_to_pos;
	    int n;

	    StrAllocCopy(buf, curlink_name);
	    /*
	     * Scan to find the final leaf of the URL.  Ignore trailing '/'.
	     */
	    for (cut_to_pos = length - 2;
		 (cut_to_pos > 0) && (buf[cut_to_pos] != '/');
		 cut_to_pos--) ;
	    /*
	     * Jump back to the next leaf to remove.
	     */
	    for (cut_from_pos = cut_to_pos - 4;
		 (cut_from_pos > 0) && ((buf[cut_from_pos] != '/')
					|| ((prefix + cut_from_pos
					     + 4
					     + (length - cut_to_pos)) >= MAX_STATUS));
		 cut_from_pos--) ;
	    /*
	     * Replace some leaves to '...', if possible, and put the final
	     * leaf at the end.  We assume that one can recognize the link from
	     * at least MIN_STATUS characters.
	     */
	    if (cut_from_pos > MIN_STATUS) {
		for (n = 1; n <= 3; n++)
		    buf[cut_from_pos + n] = '.';
		for (n = 0; cut_to_pos + n <= length; n++)
		    buf[cut_from_pos + 4 + n] = buf[cut_to_pos + n];
	    }
	    _user_message(format, buf);
	    CTRACE((tfp, "lastline = %s\n", buf));	/* don't forget to erase me */
	    FREE(buf);
	} else {		/* show (possibly truncated) url */
	    _user_message(format, curlink_name);
	}
    }
}

const char *LYDownLoadAddress(void)
{
    return NonNull(newdoc.address);
}
@


1.9
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.8
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYMainLoop.c,v 1.160 2009/02/01 12:51:11 tom Exp $
d57 4
d119 1
a119 1
	TO_SJIS(from, to);
d151 7
a157 8
#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */
d159 2
a160 2
static void exit_immediately_with_error_message(int state, BOOLEAN first_file);
static void status_link(char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx);
a164 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a165 1
#endif
d182 1
a182 1
static char prev_target[MAX_LINE];
d312 1
a312 1
	 * If TRACE is on, indicate whether the anonymous restrictions are set. 
d504 1
a504 1
    HText_pageDisplay(LYGetNewline(), prev_target);
d517 1
a517 1
	    LYhighlight(OFF, curdoc.link, prev_target);
d552 1
a552 1
	LYhighlight(ON, nextlink, prev_target);
d591 1
a591 1
static void do_check_goto_URL(char *user_input_buffer,
d646 3
a648 3
    if (*user_input_buffer == '#') {
	if (user_input_buffer[1] &&
	    HTFindPoundSelector(user_input_buffer + 1)) {
d651 1
a651 1
	    HTAddGotoURL(user_input_buffer);
d653 1
a653 1
	    StrAllocCat(curdoc.address, user_input_buffer);
d659 1
a659 1
	StrAllocCopy(*old_user_input, user_input_buffer);
d661 1
a661 2
	sprintf(user_input_buffer, "%.*s",
		(int) (MAX_LINE - 1), *old_user_input);
d666 3
a668 1
		&& !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
d677 2
a678 2
		   !isHTTP_URL(user_input_buffer) &&
		   !isHTTPS_URL(user_input_buffer)) {
d682 1
a682 1
	    set_address(&newdoc, user_input_buffer);
d713 1
a713 1
			    char *user_input_buffer,
d728 1
a728 1
	int len = strlen(user_input_buffer);
d732 7
a738 7
		&& LYIsHtmlSep(user_input_buffer[len - 3])
		&& LYIsDosDrive(user_input_buffer + len - 2))
		LYAddPathSep0(user_input_buffer);

	} else if (len == 2 && user_input_buffer[1] == ':') {
	    if (LYIsDosDrive(user_input_buffer)) {
		LYAddPathSep0(user_input_buffer);
d740 2
a741 2
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
		LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d751 4
a754 4
	LYTrimAllStartfile(user_input_buffer);
	if (*user_input_buffer == '\0' &&
	    !(recall && (ch == UPARROW || ch == DNARROW))) {
	    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d760 1
a760 1
	if (recall && ch == UPARROW) {
d780 1
a780 1
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
d783 1
a783 1
		    && !strcmp(*old_user_input, user_input_buffer)) {
d791 1
a791 3
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
d794 1
a794 1
		     * user_input_buffer and break.  - FM
d796 1
a796 1
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d804 1
a804 1
	} else if (recall && ch == DNARROW) {
d823 1
a823 1
		LYstrncpy(user_input_buffer, cp, MAX_LINE - 1);
d825 1
a825 1
		    !strcmp(*old_user_input, user_input_buffer)) {
d833 1
a833 3
		if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				   MAX_LINE,
				   recall)) < 0) {
d836 1
a836 1
		     * user_input_buffer and break.  - FM
d838 1
a838 1
		    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d922 1
a922 1
		rlink_allowed = (BOOL) !strncmp(traversal_host,
d926 1
a926 1
		rlink_allowed = (BOOL) !strncmp(traversal_host,
d940 1
a940 1
		c = DNARROW;
d950 1
a950 1
		    c = LTARROW;
d958 1
a958 1
	    c = RTARROW;
d966 1
a966 1
	    c = DNARROW;
d980 1
a980 1
		c = LTARROW;
a990 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d1010 1
a1010 1
	if (!strncmp(base, text, strlen(base))) {
a1024 1
#endif
d1056 1
a1056 2
		links[curdoc.link].l_form->type ==
		F_TEXT_SUBMIT_TYPE) {
d1069 1
a1069 3
		if (!links[curdoc.link].l_form->submit_action ||
		    *links[curdoc.link].l_form->submit_action
		    == '\0') {
a1103 1
#ifdef USE_CACHEJAR
a1104 1
#endif
d1119 1
d1172 1
a1172 1
					  (real_cmd == LYK_SUBMIT &&
d1177 3
a1179 2
		    (real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT)) {
		    form_noviceline(links[curdoc.link].l_form->disabled);
d1186 4
a1189 4
				  (BOOLEAN) (real_cmd == LYK_SUBMIT ||
					     real_cmd == LYK_NOCACHE ||
					     real_cmd == LYK_DOWNLOAD ||
					     real_cmd == LYK_HEAD));
d1232 1
a1232 1
		 * Moved here from earlier to only apply when it should. 
d1258 2
a1259 1
		    if ((real_cmd == LYK_ACTIVATE || real_cmd == LYK_SUBMIT) &&
d1277 2
a1278 4
		    !((isLYNXKEYMAP(curdoc.address) ||
#ifndef USE_CACHEJAR
		       isLYNXCOOKIE(curdoc.address)) &&
#else
d1281 1
a1281 2
#endif
		      !strncmp(links[curdoc.link].lname,
a1339 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d1342 1
a1342 1
	     * on the List Page, prevent pushing it on the history stack. 
d1344 1
a1344 1
	     * should attempt to reposition directly, without calling getfile. 
d1347 57
a1403 55
	    /*
	     * Might be an internal link anchor in the same doc.  If so, take
	     * the try_internal shortcut if we didn't fall through from
	     * LYK_NOCACHE.  - kw
	     */
	    newdoc.internal_link =
		(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
	    if (newdoc.internal_link) {
		/*
		 * Special case of List Page document with an internal link
		 * indication, which may really stand for an internal link
		 * within the document the List Page is about.  - kw
		 */
		if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		    (LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		     LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		    if (check_history()) {
			LYinternal_flag = TRUE;
		    } else {
			HTLastConfirmCancelled();	/* reset flag */
			if (!confirm_post_resub(newdoc.address,
						newdoc.title,
						((LYresubmit_posts &&
						  HText_POSTReplyLoaded(&newdoc))
						 ? 1
						 : 2),
						2)) {
			    if (HTLastConfirmCancelled() ||
				(LYresubmit_posts &&
				 cmd != LYK_NOCACHE &&
				 !HText_POSTReplyLoaded(&newdoc))) {
				/* cancel the whole thing */
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				copy_address(&newdoc, &curdoc);
				StrAllocCopy(newdoc.title, curdoc.title);
				newdoc.internal_link = curdoc.internal_link;
				HTInfoMsg(CANCELLED);
				return 1;
			    } else if (LYresubmit_posts &&
				       cmd != LYK_NOCACHE) {
				/* If LYresubmit_posts is set, and the
				   answer was No, and the key wasn't
				   NOCACHE, and we have a cached copy,
				   then use it. - kw */
				LYforce_no_cache = FALSE;
			    } else {
				/* if No, but not ^C or ^G, drop
				 * the post data.  Maybe the link
				 * wasn't meant to be internal after
				 * all, here we can recover from that
				 * assumption. - kw */
				LYFreePostData(&newdoc);
				newdoc.internal_link = FALSE;
				HTAlert(DISCARDING_POST_DATA);
d1406 7
d1414 8
d1423 1
a1423 2
		     * Don't push the List Page if we follow an internal link
		     * given by it.  - kw
d1425 1
a1425 3
		    free_address(&curdoc);
		} else if (cmd != LYK_NOCACHE) {
		    *try_internal = TRUE;
a1426 12
		if (!(LYresubmit_posts && newdoc.post_data))
		    LYinternal_flag = TRUE;
		/* We still set force_load so that history pushing
		 * etc. will be done.  - kw
		 */
		*force_load = TRUE;
		return 1;
	    } else {
		/*
		 * Free POST content if not an internal link.  - kw
		 */
		LYFreePostData(&newdoc);
a1427 1
#endif /* TRACK_INTERNAL_LINKS */
d1447 1
d1450 3
a1452 1
	    } else if (no_filereferer == TRUE && isFILE_URL(curdoc.address)) {
d1475 1
a1475 4
#ifdef USE_CACHEJAR
		|| isLYNXCACHE(curdoc.address)
#endif
		) {
d1482 104
d1587 1
a1587 1
#ifdef EXP_ADDRLIST_PAGE
d1619 1
a1619 1
#endif /* EXP_ADDRLIST_PAGE */
a1644 1
#ifdef USE_CACHEJAR
a1645 1
#endif
a1653 1
#ifdef USE_CACHEJAR
a1654 1
#endif
d1734 1
a1734 1
	     * It's a bookmark file from which all of the links were deleted. 
d1790 1
a1790 1
static int handle_LYK_COMMAND(char *user_input_buffer)
d1796 1
a1796 1
    *user_input_buffer = 0;
d1798 2
a1799 2
    if (LYgetstr(user_input_buffer, VISIBLE, MAX_LINE, RECALL_CMD) >= 0) {
	src = LYSkipBlanks(user_input_buffer);
d1848 1
a1848 1
			if ((cp = strchr((temp + 1), '/')) != NULL)
d1899 1
a1899 1
		if (strchr(*owner_address_p, ':') != NULL)
d1903 1
a1903 1
		    reply_by_mail(strchr(*owner_address_p, ':') + 1,
a2081 1
		    cp == NULL;
a2083 1
		    cp == NULL;
d2261 1
a2261 1
	} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
a2267 1
#ifdef USE_CACHEJAR
a2268 1
#endif
a2304 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d2309 18
a2326 13
	    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
#else
	    /*
	     * Might be an anchor in the same doc from a POST form.  If so,
	     * don't free the content.  -- FM
	     */
	    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
	    {
		LYFreePostData(&newdoc);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
d2420 1
a2420 1
	*cmd = LYK_EDIT_TEXTAREA;
d2452 1
a2452 1
			     char *user_input_buffer,
d2483 1
a2483 1
     * Save the current user_input_buffer string, and load the current
d2486 2
a2487 4
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
	      curdoc.address,
	      (MAX_LINE - 1));
d2490 1
a2490 1
     * Warn the user if the current document has POST data associated with it. 
d2500 5
a2504 6
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			 MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer, curdoc.address)) {
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
d2512 1
a2512 1
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d2551 1
a2551 1
			if (edit_current_file(tp, curdoc.link, LYGetNewline())) {
d2612 28
a2639 4
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	!links[curdoc.link].l_form->disabled &&
	F_TEXTLIKE(links[curdoc.link].l_form->type)) {
	*cshelpfile = LYLineeditHelpURL();
a2646 2
    int n;

d2652 1
a2652 1
    } else if (!editor || *editor == '\0') {
d2657 5
a2661 5
    }
    /*
     * See if the current link is in a form TEXTAREA.
     */
    else if (LinkIsTextarea(curdoc.link)) {
d2666 1
a2666 1
	n = HText_ExtEditForm(&links[curdoc.link]);
d2684 8
d2699 1
a2699 1
			     char *user_input_buffer,
d2729 1
a2729 2
	(!links[curdoc.link].l_form->submit_action ||
	 *links[curdoc.link].l_form->submit_action == '\0')) {
d2756 1
a2756 1
     * Save the current user_input_buffer string, and load the current link's
d2759 2
a2760 2
    StrAllocCopy(*old_user_input, user_input_buffer);
    LYstrncpy(user_input_buffer,
d2762 2
a2763 4
	       ?
	       links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
	      (MAX_LINE - 1));

d2768 3
a2770 4
    if (((*ch = LYgetstr(user_input_buffer, VISIBLE,
			 MAX_LINE, RECALL_URL)) >= 0) &&
	user_input_buffer[0] != '\0' &&
	strcmp(user_input_buffer,
d2774 2
a2775 2
	LYTrimAllStartfile(user_input_buffer);
	if (user_input_buffer[0] != '\0') {
d2783 1
a2783 1
    LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d2862 1
a2862 1
	 * fields, try to use the first of them that's on the screen instead. 
d2984 1
a2984 1
			       char *user_input_buffer,
d3002 1
a3002 1
    StrAllocCopy(*old_user_input, user_input_buffer);
d3004 1
a3004 1
	*user_input_buffer = '\0';
d3007 1
a3007 1
    if (goto_buffer && *user_input_buffer) {
d3021 1
a3021 2
    if ((*ch = LYgetstr(user_input_buffer, VISIBLE,
			MAX_LINE, *recall)) < 0) {
d3023 1
a3023 1
	 * User cancelled the Goto via ^G.  Restore user_input_buffer and
d3026 1
a3026 1
	LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
d3096 2
a3097 3
		strncmp(links[curdoc.link].lname, "http", 4) &&
		strncmp(links[curdoc.link].lname,
			"LYNXIMGMAP:http", 15) &&
d3101 1
a3101 1
		 strncmp(curdoc.address, "http", 4))) {
d3104 1
a3104 1
		       links[curdoc.link].l_form->disabled) {
d3109 1
a3109 1
		       strncmp(links[curdoc.link].l_form->submit_action,
d3241 1
a3241 1
static BOOLEAN handle_LYK_HISTORY(BOOLEAN ForcePush)
d3281 1
a3281 1
    }				/* end if strncmp */
d3314 10
d3336 1
a3336 1
				    BOOLEAN ForcePush,
a3455 2
    int n;

d3483 1
a3483 1
	n = HText_InsertFile(&links[curdoc.link]);
d3514 118
d3633 1
a3633 1
			       char *user_input_buffer,
d3659 1
a3659 1
		StrAllocCopy(*old_user_input, user_input_buffer);
d3666 1
a3666 1
			*ch = UPARROW;
d3674 1
a3674 1
		LYstrncpy(user_input_buffer, ret, MAX_LINE - 1);
d3681 11
a3691 1
		LYRemoveBlanks(user_input_buffer);
a3692 7
	    set_address(&newdoc, ret);
	    StrAllocCopy(lynxjumpfile, ret);
	    LYFreePostData(&newdoc);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
a3693 1
	    LYUserSpecifiedURL = TRUE;
d3808 1
a3808 1
	    LYhighlight(OFF, curdoc.link, prev_target);
d3935 1
a3935 1
	     (!strncmp(curdoc.address, "http", 4) ||
d3957 1
a3957 1
		     (strncmp(curdoc.address, "http", 4) == 0 ||
d4068 1
a4068 1
	LYhighlight(OFF, curdoc.link, prev_target);
d4189 1
a4189 1
	 * the document is not still in the cache or LYresubmit_posts is set. 
a4196 1
	HText *text;
d4216 1
a4216 1
	    if (((text = (HText *) HTAnchor_document(tmpanchor)) == NULL &&
d4403 1
a4403 1
     * Reload should force a cache refresh on a proxy.  -- Ari L. 
d4411 1
a4411 1
	reloading = TRUE;
d4694 1
a4694 1
	} else if (!strncmp(LYGetHiliteStr(curdoc.link, 0), "Up to ", 6))
d4709 1
a4709 1
		    tagflag(OFF, curdoc.link);
d4719 1
a4719 1
		tagflag(ON, curdoc.link);
d5020 1
a5020 1
    BOOLEAN have_target_onscreen = (BOOLEAN) (*prev_target != '\0' &&
d5027 1
a5027 1
	StrAllocCopy(remember_old_target, prev_target);
d5036 1
a5036 1
	*prev_target = '\0';
d5038 1
a5038 1
    found = textsearch(&curdoc, prev_target, sizeof(prev_target) - 1,
d5065 4
a5068 4
    } else if ((case_sensitive && 0 != strcmp(prev_target,
					      remember_old_target)) ||
	       (!case_sensitive && 0 != strcasecomp8(prev_target,
						     remember_old_target))) {
a5078 1
			     char *user_input_buffer,
a5097 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d5104 46
a5149 44
	if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
	    LYinternal_flag = TRUE;
	    newdoc.internal_link = TRUE;
	    if (LYIsListpageTitle(NonNull(curdoc.title)) &&
		(LYIsUIPage(curdoc.address, UIP_LIST_PAGE) ||
		 LYIsUIPage(curdoc.address, UIP_ADDRLIST_PAGE))) {
		if (check_history()) {
		    LYinternal_flag = TRUE;
		} else {
		    HTLastConfirmCancelled();	/* reset flag */
		    if (!confirm_post_resub(newdoc.address,
					    newdoc.title,
					    ((LYresubmit_posts &&
					      HText_POSTReplyLoaded(&newdoc))
					     ? 1
					     : 2),
					    2)) {
			if (HTLastConfirmCancelled() ||
			    (LYresubmit_posts &&
			     !HText_POSTReplyLoaded(&newdoc))) {
			    /* cancel the whole thing */
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    copy_address(&newdoc, &curdoc);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    newdoc.internal_link = curdoc.internal_link;
			    HTInfoMsg(CANCELLED);
			    if (nlinks > 0)
				HText_pageDisplay(curdoc.line, prev_target);
			    break;
			} else if (LYresubmit_posts) {
			    /* If LYresubmit_posts is set, and the
			       answer was No, and we have a cached
			       copy, then use it. - kw */
			    LYforce_no_cache = FALSE;
			} else {
			    /* if No, but not ^C or ^G, drop
			     * the post data.  Maybe the link
			     * wasn't meant to be internal after
			     * all, here we can recover from that
			     * assumption. - kw */
			    LYFreePostData(&newdoc);
			    newdoc.internal_link = FALSE;
			    HTAlert(DISCARDING_POST_DATA);
d5152 12
a5163 1
		}
d5165 1
a5165 2
		 * Don't push the List Page if we follow an internal link given
		 * by it.  - kw
d5167 2
a5168 12
		free_address(&curdoc);
	    } else
		*try_internal = TRUE;
	    if (!(LYresubmit_posts && newdoc.post_data))
		LYinternal_flag = TRUE;
	    *force_load = TRUE;
	    break;
	} else {
	    /*
	     * Free POST content if not an internal link.  - kw
	     */
	    LYFreePostData(&newdoc);
a5169 1
#endif /* DONT_TRACK_INTERNAL_LINKS */
d5203 2
a5204 5
		    StrAllocCopy(temp, user_input_buffer);
		    sprintf(user_input_buffer,
			    LINK_ALREADY_CURRENT, number);
		    HTUserMsg(user_input_buffer);
		    LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
d5233 2
a5234 5
		StrAllocCopy(temp, user_input_buffer);
		sprintf(user_input_buffer,
			ALREADY_AT_PAGE, number);
		HTUserMsg(user_input_buffer);
		LYstrncpy(user_input_buffer, temp, MAX_LINE - 1);
d5253 1
a5253 1
    static char buf[LY_MAXPATH];
d5262 1
a5262 4
    /* some people may prefer automatic clearing of the previous user input,
       here, to do this, just uncomment next line - VH */
    /* buf[0]='\0'; */
    if (LYgetstr(buf, VISIBLE, sizeof(buf) - 1, NORECALL) < 0 || !*buf) {
d5267 3
a5269 2
    if (LYIsTilde(*buf) && (LYIsPathSep(buf[1]) || buf[1] == '\0')) {
	HTSprintf0(&p, "%s%s", Home_Dir(), buf + 1);
d5271 1
a5271 1
	StrAllocCopy(p, buf);
d5318 16
d5415 23
d5439 13
a5451 2
    if (LYwin == stdscr)
	return FALSE;
d5453 4
a5456 14
    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup(!LYwideLines, LYlines / 2 - 2, LYcolLimit / 2 - 6,
		      choices, TABLESIZE(choices) - 1, FALSE, TRUE);
    /*
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
     */
    if (term_options)
	return FALSE;
    LYwideLines = c;
    LYtableCols = wrap[c];
d5458 10
a5467 4
    if (LYwideLines == 0)
	LYshiftWin = 0;
    *flag = TRUE;
    HTUserMsg(LYwideLines ? LINEWRAP_OFF : LINEWRAP_ON);
d5472 8
d5484 1
a5484 1
 * more modular, but this procedure still does a lot of variable manipulation. 
a5487 1

d5501 1
a5501 1
    char user_input_buffer[MAX_LINE];
d5571 2
a5572 3
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
d5671 1
a5671 1
		 * elements to the curdoc structure elements under case NORMAL. 
a5684 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d5691 2
a5692 1
		if (curdoc.internal_link &&
d5698 1
a5698 3
		} else
#endif /* TRACK_INTERNAL_LINKS */
		{
d5786 1
a5786 1
	    *prev_target = '\0';	/* Reset for new coming document */
d5806 51
a5856 22
#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (try_internal) {
		if (newdoc.address &&
		    isLYNXIMGMAP(newdoc.address)) {
		    try_internal = FALSE;
		} else if (curdoc.address &&
			   isLYNXIMGMAP(curdoc.address)) {
		    try_internal = FALSE;
		}
	    }
	    if (try_internal) {
		char *hashp = findPoundSelector(newdoc.address);

		if (hashp) {
		    HTFindPoundSelector(hashp + 1);
		}
		getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		try_internal = FALSE;	/* done */
		/* fix up newdoc.address which may have been fragment-only */
		if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
		    if (!hashp) {
			set_address(&newdoc, HTLoadedDocumentURL());
d5858 1
a5858 4
			StrAllocCopy(temp, HTLoadedDocumentURL());
			StrAllocCat(temp, hashp);	/* append fragment */
			set_address(&newdoc, temp);
			FREE(temp);
a5861 15
		if (newdoc.internal_link && newdoc.address &&
		    *newdoc.address == '#' && nhist > 0) {
		    char *cp0;

		    if (isLYNXIMGMAP(HDOC(nhist_1).address))
			cp0 = HDOC(nhist_1).address + LEN_LYNXIMGMAP;
		    else
			cp0 = HDOC(nhist_1).address;
		    StrAllocCopy(temp, cp0);
		    (void) trimPoundSelector(temp);
		    StrAllocCat(temp, newdoc.address);
		    free_address(&newdoc);
		    newdoc.address = temp;
		    temp = NULL;
		}
d5864 1
a5871 10
#else /* TRACK_INTERNAL_LINKS */
	    tmpDocInfo = newdoc;
	    tmpNewline = -1;
	    getresult = getfile(&newdoc, &tmpNewline);
	    if (!reloading && !popped_doc && (tmpNewline >= 0)) {
		LYSetNewline(tmpNewline);
	    } else {
		newdoc.link = tmpDocInfo.link;
	    }
#endif /* TRACK_INTERNAL_LINKS */
a5899 1
#ifdef USE_CACHEJAR
a5900 1
#endif
d5955 1
d5982 1
a5982 1
			 * It's a binary file, or the fetch attempt failed. 
d6020 1
d6108 1
a6108 1
		    len = strlen(name);
d6113 1
a6113 1
		    if (!strncmp(temp, name, len) &&
d6126 1
a6126 1
			    if (strchr(&temp[(len + 1)], '/')) {
d6147 1
d6159 1
a6159 1
					    (strncmp(BookmarkPage, "./", 2) ?
d6188 1
a6188 1
		     * During traversal build up lists of all links traversed. 
d6343 1
d6410 1
a6410 1
	    if (!temp || *temp == '\0') {
d6430 1
a6430 1
			 * ensure it is always treated as an HTML source file. 
d6462 1
a6462 1
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
d6470 1
a6470 1
		    if (!temp || *temp == '\0') {
d6549 1
a6549 1
	    HText_pageDisplay(LYGetNewline(), prev_target);
d6633 1
a6633 1
	    HText_pageDisplay(LYGetNewline(), prev_target);
d6665 1
a6665 2
	     (links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
	     F_TEXTLIKE(links[curdoc.link].l_form->type));
d6727 1
a6727 1
		    if (strchr(temp_buff, '%')) {
d6758 4
a6761 2
				 (curlink_is_editable && textinput_activated) ?
				 FOR_INPUT : FOR_PANEL);
d6771 1
a6771 1
		LYhighlight(ON, curdoc.link, prev_target);
d6774 1
a6774 1
		LYhighlight(ON, curdoc.link, prev_target);
a6795 3
		    if (!dump_output_immediately)
			cleanup();
		    fprintf(
d6797 1
a6797 1
			       (dump_output_immediately
d6799 2
a6800 1
				: stdout),
d6802 1
a6802 1
			       stdout,
d6804 6
a6809 1
			       gettext("Fatal error - could not open output file %s\n"), cfile);
d6830 1
a6830 1
			form_noviceline(links[curdoc.link].l_form->disabled);
d6852 1
a6852 2
			links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			F_TEXTLIKE(links[curdoc.link].l_form->type) &&
d6859 1
a6859 1
			   && !links[curdoc.link].l_form->disabled
d7048 2
a7049 1
	    if ((c = DoTraversal(c, &crawl_ok)) < 0)
d7051 1
d7080 4
d7091 1
a7091 2
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		F_TEXTLIKE(links[curdoc.link].l_form->type)) {
d7117 1
a7117 1
	    cmd = handle_LYK_COMMAND(user_input_buffer);
d7138 1
a7138 2
	    handle_LYK_digit(c, &force_load, user_input_buffer,
			     &old_c, real_c, &try_internal);
d7145 1
a7145 1
	case LYK_CHG_CENTER:	/* ^Q */
d7177 2
a7178 1
	    if (handle_LYK_QUIT())
d7180 1
d7184 1
d7254 1
a7254 1
		while (s < e && strchr(" \t\n\r", *s))
d7256 1
a7256 1
		while (s < e && strchr(" \t\n\r", e[-1]))
d7271 3
a7273 3
		buf = (char *) malloc(len);
		strncpy(buf, (const char *) s, (unsigned) (e - s));
		buf[e - s] = '\0';
d7277 1
a7277 1
		    if (strchr(" \t\n\r", *s)) {
d7281 1
a7281 1
			while (strchr(" \t\n\r", *s)) {
d7288 1
a7288 1
				if (*s1 != '\r' && *s1 != '\r')
d7298 2
a7299 1
		do_check_goto_URL(buf, &temp, &force_load);
d7426 1
d7443 1
a7443 1
	case LYK_SUBMIT:	/* follow a link, submit TEXT_SUBMIT input */
d7460 8
d7469 2
a7470 2
	    if (handle_LYK_ELGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
d7474 2
a7475 2
	    if (handle_LYK_ECGOTO(&ch, user_input_buffer, &temp, &old_c, real_c))
		do_check_goto_URL(user_input_buffer, &temp, &force_load);
d7479 1
a7479 1
	    if (handle_LYK_GOTO(&ch, user_input_buffer, &temp, &recall,
d7482 1
a7482 1
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
d7484 1
a7484 1
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d7577 1
a7577 1
	case LYK_EDIT_TEXTAREA:	/* use external editor on a TEXTAREA - KED */
d7581 1
a7581 1
	case LYK_GROW_TEXTAREA:	/* add new lines to bottom of TEXTAREA - KED */
d7585 1
a7585 1
	case LYK_INSERT_FILE:	/* insert file in TEXTAREA, above cursor - KED */
d7598 1
a7598 1
#ifdef EXP_ADDRLIST_PAGE
d7603 1
a7603 1
#endif /* EXP_ADDRLIST_PAGE */
d7688 4
d7697 1
a7697 1
	    if (handle_LYK_JUMP(c, user_input_buffer, &temp, &recall,
d7700 1
a7700 1
		if (do_check_recall(ch, user_input_buffer, &temp, URLTotal,
d7702 1
a7702 1
		    do_check_goto_URL(user_input_buffer, &temp, &force_load);
d7716 3
d7732 7
a7796 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a7861 1
#endif
d8026 2
a8027 2
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
d8054 1
a8054 2
static void exit_immediately_with_error_message(int state,
						BOOLEAN first_file)
d8088 1
d8090 3
a8092 3
    if (dump_output_immediately) {
	fputs(buf, stderr);
    } else
d8094 7
a8100 4
    {
	SetOutputMode(O_TEXT);
	fputs(buf, stdout);
	SetOutputMode(O_BINARY);
a8102 2
    FREE(buf);

d8110 2
a8111 2
			BOOLEAN show_more,
			BOOLEAN show_indx)
@


1.7
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d45 4
d53 4
a126 23
#ifdef SH_EX			/* 1998/10/30 (Fri) 10:06:47 */

#define NOT_EQU	1

static int str_n_cmp(const char *p, const char *q, int n)
{
    if (n == 0)
	return 0;

    if (p == NULL)
	return NOT_EQU;

    if (q == NULL)
	return NOT_EQU;

    return strncmp(p, q, n);
}

#undef strncmp
#define	strncmp(p, q, r)	str_n_cmp(p, q, r)

#endif /* SH_EX */

d181 1
a181 1
static char prev_target[512];
d367 1
a367 1
    WWW_TraceFlag = !WWW_TraceFlag;
d631 3
d885 1
a885 1
		    cx += strlen(text) / 2;
d1111 3
d1284 1
d1286 4
d1309 5
d1480 5
a1484 1
	    if (isLYNXCOOKIE(curdoc.address)) {
d1550 3
d1561 3
d1701 1
a1701 1
    int ch;
d1711 2
a1712 2
	ch = ((mp = LYStringToKcmd(src)) != 0) ? mp->code : 0;
	CTRACE((tfp, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, ch));
d1753 1
a1753 1
		    if (*temp == '~' && strlen(temp) > 1) {
d1826 28
a2098 1

d2164 1
a2164 1
	    newdoc.link = 0;
d2179 3
d2238 1
a2238 1
	    newdoc.link = 0;
d2291 1
a2291 1
		*follow_col += strlen(text) / 2;
d2328 1
a2328 2
	links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2443 1
a2443 1
    } else
d2445 5
a2449 5
	/*
	 * Allow the user to edit the link rather than curdoc in edit mode.
	 */
	if (lynx_edit_mode &&
	    non_empty(editor) && !no_dired_support) {
d2486 1
a2486 1
    } else
d2488 1
a2488 1
    if (non_empty(editor)) {
d2551 1
a2551 2
    else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2698 1
a2698 1
    int code = FALSE;
d2706 1
a2706 2
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2711 1
a2711 2
		!(links[0].type == WWW_FORM_LINK_TYPE &&
		  links[0].l_form->type == F_TEXTAREA_TYPE &&
d2717 1
a2717 2
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
d2723 1
a2723 2
		       (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].l_form->type == F_TEXTAREA_TYPE &&
d2726 1
a2726 2
		       !(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
d2752 1
a2752 2
	    links[nextlink].type == WWW_FORM_LINK_TYPE &&
	    links[nextlink].l_form->type == F_TEXTAREA_TYPE) {
d2756 1
a2756 2
	    if (links[0].type == WWW_FORM_LINK_TYPE &&
		links[0].l_form->type == F_TEXTAREA_TYPE &&
d2763 1
a2763 2
		     links[nextlink - 1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink - 1].l_form->type == F_TEXTAREA_TYPE &&
d2805 1
a2805 2
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d2810 1
a2810 2
		!(links[nlinks - 1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks - 1].l_form->type == F_TEXTAREA_TYPE &&
d2816 1
a2816 2
		    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink].l_form->type == F_TEXTAREA_TYPE &&
d2926 1
a2926 2
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d3115 1
a3115 1
    historical_comments = !historical_comments;
d3175 1
a3175 1
    clickable_images = !clickable_images;
d3323 1
a3323 1
    pseudo_inline_alts = !pseudo_inline_alts;
d3339 1
a3339 2
    if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) {
d3607 1
a3607 1
    minimal_comments = !minimal_comments;
d3649 1
a3649 1
    nested_tables = !nested_tables;
d3833 1
a3833 2
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
d3841 1
a3841 2
		   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		   links[curdoc.link].l_form->type == F_TEXTAREA_TYPE &&
d4252 1
a4252 1
    soft_dquotes = !soft_dquotes;
d4650 1
a4650 1
		*follow_col += strlen(text) / 2;
d5038 1
a5038 3
    if (*buf == '~' && !buf[1]) {
	StrAllocCopy(p, Home_Dir());
    } else if (*buf == '~') {
d5208 2
a5209 6
#undef	STRING_MAX
#define	STRING_MAX	4096
    char temp_buff[STRING_MAX];

#define	BUFF_MAX	1024
    char sjis_buff[BUFF_MAX];
d5285 1
d5287 1
d5357 1
a5357 4
    if (user_mode == NOVICE_MODE)
	display_lines = LYlines - 4;
    else
	display_lines = LYlines - 2;
d5618 3
d6060 1
a6060 1
	    return (EXIT_SUCCESS);
d6102 2
a6103 5
	    if (user_mode == NOVICE_MODE) {
		display_lines = LYlines - 4;
	    } else {
		display_lines = LYlines - 2;
	    }
d6379 1
a6379 1
	curlink_is_editable =
d6381 1
a6381 1
	     links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
d6384 4
a6387 3
	use_last_tfpos = (curlink_is_editable &&
			  (real_cmd == LYK_LPOS_PREV_LINK ||
			   real_cmd == LYK_LPOS_NEXT_LINK));
d6442 1
a6442 1
		if (strlen(p) < 500) {
d6570 1
a6570 2
		} else if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			    links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
d6581 1
a6581 2
			       links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE
d6593 1
a6593 2
			       links[curdoc.link - 1].type == WWW_FORM_LINK_TYPE
			       && links[curdoc.link - 1].l_form->type == F_TEXTAREA_TYPE
d6627 1
a6627 2
			if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)
d6633 1
a6633 2
				 !(links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE))
d6636 1
a6636 2
				 ((links[curdoc.link + 1].type == WWW_FORM_LINK_TYPE
				   && links[curdoc.link + 1].l_form->type == F_TEXTAREA_TYPE)
d6958 1
a6958 1
		len2 = strlen((const char *) s);
d6974 1
a6974 1
		len = e - s + 1;
d6978 1
a6978 1
		strncpy(buf, (const char *) s, e - s);
d7011 1
a7011 1
	case LYK_CHG_KCODE:	/* ^L */
d7116 7
d7644 1
a7644 1
	    LYmove(LYlines - 1, LYcolLimit - strlen(indx));
d7803 1
a7803 1
    if (show_more) {
d7807 1
a7807 1
	prefix = strlen(format);
d7811 1
a7811 1
		(int) (sizeof(format) - prefix - 2),
d7814 2
a7815 2
    prefix = strlen(format);
    length = strlen(curlink_name);
@


1.6
log
@update to lynx2.8.5rel.4; fixes CAN-2005-3120 among other things.
prompted by naddy@@, cloder@@ ok.
@
text
@d47 1
a47 1
PUBLIC char *str_kcode(HTkcode code)
d93 1
a93 1
PRIVATE char *str_sjis(char *to, char *from)
d109 1
a109 1
PRIVATE void set_ws_title(char * str)
d116 1
a116 2

#ifdef SH_EX  /* 1998/10/30 (Fri) 10:06:47 */
d120 1
a120 1
PRIVATE int str_n_cmp(const char *p, const char *q, int n)
d137 1
a137 1
#endif	/* SH_EX */
d156 2
a157 2
PUBLIC HTLinkType * HTInternalLink = 0;
PUBLIC HTAtom * WWW_SOURCE = 0;
d168 5
a172 6

PRIVATE void exit_immediately_with_error_message PARAMS((int state, BOOLEAN first_file));
PRIVATE void status_link PARAMS((char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx));
PRIVATE void show_main_statusline PARAMS((CONST LinkInfo curlink, int for_what));
PRIVATE void form_noviceline PARAMS((int));
PRIVATE int are_different PARAMS((DocInfo *doc1, DocInfo *doc2));
d175 1
a175 1
PRIVATE int are_phys_different PARAMS((DocInfo *doc1, DocInfo *doc2));
d180 2
a181 3
PRIVATE int sametext ARGS2(
	char *,		een,
	char *,		twee)
d188 1
a188 1
PUBLIC	HTList * Goto_URLs = NULL;  /* List of Goto URLs */
d190 2
a191 2
PUBLIC char * LYRequestTitle = NULL; /* newdoc.title in calls to getfile() */
PUBLIC char * LYRequestReferer = NULL; /* Referer, may be set in getfile() */
d193 1
a193 1
PRIVATE char prev_target[512];
d196 2
a197 2
PUBLIC BOOLEAN display_partial = FALSE; /* could be enabled in HText_new() */
PUBLIC int NumOfLines_partial = 0;  /* number of lines displayed in partial mode */
d200 7
a206 7
PRIVATE int Newline = 0;
PRIVATE DocInfo newdoc;
PRIVATE DocInfo curdoc;
PRIVATE char *traversal_host = NULL;
PRIVATE char *traversal_link_to_add = NULL;
PRIVATE char *owner_address = NULL;  /* Holds the responsible owner's address     */
PRIVATE char *ownerS_address = NULL; /* Holds owner's address during source fetch */
d209 2
a210 1
PRIVATE BOOL textinput_activated = FALSE;
d212 1
a212 1
#define textinput_activated TRUE /* a current text input is always active */
d215 3
a217 2
PUBLIC BOOL textinput_redrawn = FALSE;
    /*must be public since used in LYhighlight(..)*/
d222 1
a222 1
 *  Function for freeing allocated mainloop() variables. - FM
d224 1
a224 1
PRIVATE void free_mainloop_variables NOARGS
d249 1
a249 1
PRIVATE void TracelogOpenFailed NOARGS
d256 1
a256 1
	exit(EXIT_FAILURE);
d260 1
a260 1
PRIVATE BOOLEAN LYReopenTracelog ARGS1(BOOLEAN *, trace_flag_ptr)
d275 1
a275 1
PRIVATE void turn_trace_back_on ARGS1(BOOLEAN *, trace_flag_ptr)
d285 1
a285 1
#define turn_trace_back_on(flag) /*nothing*/
d288 1
a288 1
PUBLIC FILE *TraceFP NOARGS
d298 1
a298 1
PUBLIC BOOLEAN LYOpenTraceLog NOARGS
d323 5
a327 5
	 *  If TRACE is on, indicate whether the
	 *  anonymous restrictions are set. - FM, LP, kw
	 *  This is only a summary for convenience - it doesn't
	 *  take the case of individual -restrictions= options
	 *  into account. - kw
d331 2
a332 1
		CTRACE((tfp, "Validate and some anonymous restrictions are set.\n"));
d334 2
a335 1
		CTRACE((tfp, "Validate restrictions set, restriction \"default\" was given.\n"));
d337 2
a338 1
		CTRACE((tfp, "Validate restrictions set, additional anonymous restrictions ignored.\n"));
d347 2
a348 1
		CTRACE((tfp, "Anonymous restrictions set, restriction \"all\" was given.\n"));
d364 1
a364 1
PUBLIC void LYCloseTracelog NOARGS
d376 1
a376 1
PUBLIC void handle_LYK_TRACE_TOGGLE NOARGS
d379 1
a379 1
    WWW_TraceFlag = ! WWW_TraceFlag;
d387 1
a387 2
PUBLIC void LYSetNewline ARGS1(
	int,		value)
d392 3
a394 1
PUBLIC int LYGetNewline NOARGS
d399 9
d409 1
a409 1
PRIVATE BOOLEAN from_source_cache = FALSE;
d414 1
a414 1
PRIVATE BOOLEAN reparse_document NOARGS
d416 2
a417 1
    BOOLEAN ok;
d419 1
a419 1
    if ((ok = HTreparse_document()) != FALSE) {
d421 2
a422 1
	return ok;
d424 1
a424 2
    from_source_cache = FALSE;
    return ok;
d432 1
a432 2
PRIVATE BOOLEAN reparse_or_reload ARGS1(
    int *,	cmd)
d446 1
a446 3
PRIVATE void set_address ARGS2(
	DocInfo *,	doc,
	CONST char *,	address)
d451 1
a451 3
PRIVATE void copy_address ARGS2(
	DocInfo *,	dst,
	DocInfo *,	src)
d456 1
a456 2
PRIVATE void free_address ARGS1(
	DocInfo *,	doc)
d461 1
a461 3
PRIVATE void move_address ARGS2(
	DocInfo *,	dst,
	DocInfo *,	src)
d471 1
a471 1
 * LYMainLoop.c PRIVATE variables to manage proper newline position
d474 1
a474 2
PUBLIC BOOL LYMainLoop_pageDisplay ARGS1(
	int,		line_num)
d476 2
a477 2
    CONST char * pound;
    int prev_newline = Newline;
d480 2
a481 2
     *  Override Newline with a new value if user
     *  scrolled the document while loading (in LYUtils.c).
d483 1
a483 1
    Newline = line_num;
d505 2
a506 2
	    && *pound && *(pound+1)) {
	    if (HTFindPoundSelector(pound+1)) {
d508 1
a508 1
		Newline = www_search_result;
d510 1
a510 1
		Newline = prev_newline; /* restore ??? */
d515 1
a515 1
    HText_pageDisplay(Newline, prev_target);
d520 3
a523 3
PRIVATE void set_curdoc_link ARGS1(
    int,	nextlink)
{
d525 3
a527 3
     && nextlink >= 0
     && nextlink < nlinks) {
	if (curdoc.link >= 0 && curdoc.link < nlinks)
d529 2
d533 33
d567 3
d571 1
a571 1
PRIVATE int do_change_link NOARGS
d576 1
d581 1
d587 1
a587 1
	    return(-1);		/* indicates unexpected error */
d589 1
a589 1
	set_curdoc_link(mouse_tmp);
d592 1
a592 1
    return(0);			/* indicates OK */
d602 3
a604 4
PRIVATE void do_check_goto_URL ARGS3(
    char *,	user_input_buffer,
    char **,	old_user_input,
    BOOLEAN *,	force_load)
d607 1
d609 1
a609 1
	CONST char *name;
d648 2
d653 6
a658 6
    /* allow going to anchors*/
    if (*user_input_buffer == '#' ) {
	if ( user_input_buffer[1] &&
	     HTFindPoundSelector(user_input_buffer+1) ) {
	     /* HTFindPoundSelector will initialize www_search_result,
		so we do nothing else. */
d670 1
a670 1
		(int)(MAX_LINE - 1), *old_user_input);
d675 1
a675 1
	     && !strncmp(user_input_buffer, table[n].name, strlen(table[n].name))) {
d692 2
a693 2
	     *  Might be an anchor in the same doc from a POST
	     *  form.  If so, dont't free the content. -- FM
d699 2
a700 1
		StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
d719 7
a725 8
PRIVATE BOOL do_check_recall ARGS7(
    int,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int,	URLTotal,
    int *,	URLNum,
    int,	recall,
    BOOLEAN *,	FirstURLRecall)
d734 1
a734 1
#ifdef WIN_EX	/* 1998/10/11 (Sun) 10:41:05 */
d739 2
a740 2
	     && LYIsHtmlSep(user_input_buffer[len - 3])
	     && LYIsDosDrive(user_input_buffer + len - 2))
d744 9
a752 9
		if (LYIsDosDrive(user_input_buffer)) {
			LYAddPathSep0(user_input_buffer);
		} else {
			HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
			LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
			FREE(*old_user_input);
			ret = FALSE;
			break;
		}
d785 2
a786 2
	    if ((cp = (char *)HTList_objectAt(Goto_URLs,
					      *URLNum)) != NULL) {
d789 2
a790 2
		 && **old_user_input
		 && !strcmp(*old_user_input, user_input_buffer)) {
d799 2
a800 2
				  MAX_LINE,
				  recall)) < 0) {
d802 2
a803 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d831 1
a831 1
	    if ((cp=(char *)HTList_objectAt(Goto_URLs, *URLNum)) != NULL) {
d846 2
a847 2
		     *  User cancelled the Goto via ^G.
		     *  Restore user_input_buffer and break. - FM
d865 1
a865 1
PRIVATE void do_cleanup_after_delete NOARGS
d870 1
a870 1
    if (curdoc.link == nlinks-1) {
d874 1
a874 1
	newdoc.link = curdoc.link-1;
d880 2
a881 3
PRIVATE int find_link_near_col ARGS2(
	int,	col,
	int,	delta)
d886 1
a886 1
	if ( (links[i].ly - links[curdoc.link].ly) * delta > 0 ) {
d891 1
a891 1
		char *text = LYGetHiliteStr(i, 0);
d904 1
a904 1
	    return(best);
d907 1
a907 1
    return(-1);
d916 2
a917 3
PRIVATE int DoTraversal ARGS2(
    int,	c,
    BOOLEAN *,	crawl_ok)
d924 2
a925 2
		    links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].lname != NULL);
d930 2
a931 2
	     traversal_host &&
	     links[curdoc.link].lname) {
d934 2
a935 2
					 links[curdoc.link].lname,
					 strlen(traversal_host));
d938 2
a939 2
					 links[curdoc.link].lname + LEN_LYNXIMGMAP,
					 strlen(traversal_host));
d948 1
a948 1
	if (lookup(links[curdoc.link].lname)) {
d950 5
a954 5
		(curdoc.link > -1 && curdoc.link < nlinks -1))
		 c= DNARROW;
	    else {
		if (STREQ(curdoc.title,"Entry into main screen") ||
		    (nhist <= 0 )) {
d959 3
a961 1
		    return(-1);
a962 1
		c = LTARROW;
d971 2
a972 2
    } else { /* no good right link, so only down and left arrow ok*/
	if (rlink_exists /* && !rlink_rejected */)
d976 1
a976 1
	    (curdoc.link > -1 && curdoc.link < nlinks-1))
d978 1
a978 1
	else {
d980 2
a981 2
	     *	curdoc.title doesn't always work, so
	     *	bail out if the history list is empty.
d983 2
a984 2
	    if (STREQ(curdoc.title,"Entry into main screen") ||
		(nhist <= 0 )) {
d989 3
a991 1
		return(-1);
a992 1
	    c = LTARROW;
d994 5
a998 1
    } /* right link not NULL or link to another site*/
d1003 1
a1003 1
PRIVATE BOOLEAN check_history NOARGS
d1005 1
a1005 1
    CONST char *base;
d1009 1
a1009 2
	 *  Normal case - List Page is not associated
	 *  with post data. - kw
d1014 8
a1021 7
     && !LYresubmit_posts
     && HDOC(nhist - 1).post_data
     && BINEQ(curdoc.post_data, HDOC(nhist - 1).post_data)
     && (base = HText_getContentBase()) != 0) {
	 char *text = !isLYNXIMGMAP(HDOC(nhist - 1).address)
		     ? HDOC(nhist - 1).address
		     : HDOC(nhist - 1).address + LEN_LYNXIMGMAP;
d1039 6
a1044 7
PRIVATE int handle_LYK_ACTIVATE ARGS6(
    int *,	c,
    int,	cmd GCC_UNUSED,
    BOOLEAN *,	try_internal GCC_UNUSED,
    BOOLEAN *,	refresh_screen,
    BOOLEAN *,	force_load,
    int,	real_cmd)
d1049 1
a1049 1
	return 1;	/* mouse stuff was confused, ignore - kw */
d1065 1
a1065 1
	     *	Don't try to submit forms with bad actions. - FM
d1070 1
a1070 1
					    F_TEXT_SUBMIT_TYPE) {
d1072 1
a1072 1
		 *  Do nothing if it's disabled. - FM
d1081 1
a1081 1
		 *  Make sure we have an action. - FM
d1085 1
a1085 1
							== '\0') {
d1093 1
a1093 2
		 *  Check for no_mail if the form action
		 *  is a mailto URL. - FM
d1096 1
a1096 1
			     == URL_MAIL_METHOD && no_mail) {
d1104 2
a1105 2
		 *  Make sure this isn't a spoof in an account
		 *  with restrictions on file URLs. - FM
d1116 2
a1117 2
		 *  Make sure this isn't a spoof attempt
		 *  via an internal URL. - FM
d1124 2
a1125 2
		      strncasecomp(
			(links[curdoc.link].l_form->submit_action + 10),
d1142 1
a1142 1
				links[curdoc.link].l_form->submit_action));
d1148 1
a1148 1
#ifdef NOTDEFINED /* We're disabling form inputs instead of using this. - FM */
d1150 2
a1151 2
		 *  Check for enctype and let user know we
		 *  don't yet support multipart/form-data - FM
d1154 1
a1154 2
		    if (!strcmp(
			     links[curdoc.link].l_form->submit_enctype,
d1156 1
a1156 2
			HTAlert(
gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
d1177 3
a1179 4
	     *	Normally we don't get here for text input fields,
	     *  but it can happen as a result of mouse positioning.
	     *  In that case the statusline will not have updated
	     *  info, so update it now. - kw
d1192 1
a1192 1
			form_noviceline(links[curdoc.link].l_form->disabled);
d1197 6
a1202 6
				 &newdoc, refresh_screen,
				 FALSE,
				 (BOOLEAN)(real_cmd == LYK_SUBMIT ||
				  real_cmd == LYK_NOCACHE ||
				  real_cmd == LYK_DOWNLOAD ||
				  real_cmd == LYK_HEAD));
d1205 2
a1206 2
		 *  Cannot have been a submit field for which
		 *  newdoc was filled in. - kw
d1212 1
a1212 1
			     != URL_MAIL_METHOD) {
d1214 1
a1214 1
		     *  Try to undo change of newdoc.title done above.
d1245 7
a1251 8
		 *  Moved here from earlier to only apply when it
		 *  should.   Anyway, why should realm checking be
		 *  overridden for form submissions, this seems to
		 *  be an unnecessary loophole??  But that's the way
		 *  it was, maybe there is some reason.
		 *  However, at least make sure this doesn't weaken
		 *  restrictions implied by -validate!
		 *  - kw 1999-05-25
d1263 4
a1266 5
		/*  Avoid getting stuck with repeatedly calling
		**  handle_LYK_ACTIVATE(), instead of calling
		**  change_form_link() directly from mainloop(),
		**  for text input fields. - kw
		*/
d1273 1
a1273 1
			textinput_activated)
d1275 1
d1282 1
a1282 1
	     *	Not a forms link.
d1284 2
a1285 2
	     *	Make sure this isn't a spoof in an account
	     *	with restrictions on file URLs. - FM
d1304 2
a1305 3
	     *	Make sure this isn't a spoof attempt
	     *	via an internal URL in a non-internal
	     *	document. - FM
d1327 6
a1332 7
		    HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
		    HTOutputFormat = WWW_PRESENT;
		    LYforce_no_cache = FALSE;
		    reloading = FALSE;
		    return 0;
		}

d1334 1
a1334 2
	    if (run_external(links[curdoc.link].lname, TRUE))
	    {
d1341 1
a1341 1
	     *	Follow a normal link or anchor.
a1345 7
	/*
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
	 */
d1347 10
a1356 3
	     *	Might be an internal link anchor in the same doc.
	     *	If so, take the try_internal shortcut if we didn't
	     *	fall through from LYK_NOCACHE. - kw
d1362 3
a1364 4
		 *  Special case of List Page document with an
		 *  internal link indication, which may really stand
		 *  for an internal link within the document the
		 *  List Page is about. - kw
d1372 1
a1372 1
			HTLastConfirmCancelled(); /* reset flag */
d1375 4
a1378 2
					(LYresubmit_posts &&
			       HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
d1412 2
a1413 2
		     *	Don't push the List Page if we follow an
		     *	internal link given by it. - kw
d1422 2
a1423 1
		** etc. will be done.  - kw */
d1428 1
a1428 1
		 *  Free POST content if not an internal link. - kw
d1434 2
a1435 2
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
d1465 9
a1473 10
		  DIRED_UNCACHE_2;
		  /*
		   *  Unescaping any slash chars in the URL,
		   *  but avoid double unescaping and too-early
		   *  unescaping of other chars. - KW
		   */
		  HTUnEscapeSome(newdoc.address,"/");
		  /* avoid stripping final slash for root dir - kw */
		  if (strcasecomp(newdoc.address, "file://localhost/"))
		      strip_trailing_slash(newdoc.address);
d1485 1
a1485 2
PRIVATE BOOLEAN handle_LYK_ADDRLIST ARGS1(
    int *,     cmd)
d1488 1
a1488 1
     *	Don't do if already viewing list addresses page.
d1492 1
a1492 1
	 *  Already viewing list page, so get out.
d1499 1
a1499 1
     *	Print address list page to file.
d1505 3
a1507 4
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
d1518 3
a1520 4
PRIVATE void handle_LYK_ADD_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d1525 1
a1525 1
	if (*old_c != real_c)	{
d1558 3
a1560 4
		 *  The document doesn't have POST content,
		 *  and is not a bookmark file, nor is the
		 *  list or visited links page, so we can
		 *  save either that or the link. - FM
d1565 1
a1565 1
		    *refresh_screen = TRUE; /* MultiBookmark support */
d1573 2
a1574 2
					  ? (bookmark_page+1)
					  : bookmark_page)) != NULL) {
d1576 3
a1578 4
		     *	If multiple bookmarks are disabled, offer
		     *	the L)ink or C)ancel, but with wording
		     *	which indicates that the link already
		     *	exists in this bookmark file. - FM
d1584 1
a1584 1
		     *	Internal link, and document has POST content.
d1590 3
a1592 4
		     *	Only offer the link in a document with
		     *	POST content, or if the current document
		     *	is a bookmark file and multiple bookmarks
		     *	are enabled. - FM
d1602 1
a1602 1
		     *	Internal link, and document has POST content.
d1608 1
a1608 1
		 *  User does want to save the link. - FM
d1613 1
a1613 1
		    *refresh_screen = TRUE; /* MultiBookmark support */
d1623 1
a1623 1
	     *	No links, and document has POST content. - FM
d1629 2
a1630 2
	     *	It's a bookmark file from which all
	     *	of the links were deleted. - FM
d1638 1
a1638 1
		*refresh_screen = TRUE; /* MultiBookmark support */
d1643 1
a1643 1
check_add_bookmark_to_self:
d1654 1
a1654 1
	if (*old_c != real_c)	{
d1661 2
a1662 3
PRIVATE void handle_LYK_CLEAR_AUTH ARGS2(
    int *,	old_c,
    int,	real_c)
d1685 1
a1685 2
PRIVATE int handle_LYK_COMMAND ARGS1(
    char *,	user_input_buffer)
d1708 4
a1711 5
PRIVATE void handle_LYK_COMMENT ARGS4(
    BOOLEAN *,	refresh_screen,
    char **,	owner_address_p,
    int *,	old_c,
    int,	real_c)
d1713 1
a1713 1
    int	c;
d1717 1
a1717 1
	if (*old_c != real_c)	{
d1730 2
a1731 2
		 *  No owner defined, so make a guess and
		 *  and offer it to the user. - FM
d1741 1
a1741 1
			 *  It's a ~user URL so guess user@@host. - FM
d1743 1
a1743 1
			if ((cp = strchr((temp+1), '/')) != NULL)
d1746 1
a1746 1
			StrAllocCat(address, (temp+1));
d1753 1
a1753 1
		     *	Wasn't a ~user URL so guess WebMaster@@host. - FM
d1771 1
a1771 1
		 *  The address is a URL.  Just follow the link.
d1777 1
a1777 1
		 *  The owner_address is a mailto: URL.
d1779 2
a1780 2
		CONST char *kp = HText_getRevTitle();
		CONST char *id = HText_getMessageID();
d1782 1
d1785 1
a1785 1
		    if (kp && *kp) {
d1795 6
a1800 6
		     /*
		      *  Send a reply.	The address is after the colon.
		      */
		     reply_by_mail(strchr(*owner_address_p, ':') + 1,
				   curdoc.address,
				   NonNull(kp), id);
d1806 1
a1806 1
		*refresh_screen = TRUE;	/* to force a showpage */
d1812 1
a1812 2
PRIVATE BOOLEAN handle_LYK_COOKIE_JAR ARGS1(
    int *,	cmd)
d1815 1
a1815 1
     *	Don't do if already viewing the cookie jar.
d1830 1
a1830 1
	 *  If already in the cookie jar, get out.
d1839 1
a1839 1
PRIVATE void handle_LYK_CREATE NOARGS
d1857 3
a1859 4
PRIVATE void handle_LYK_DEL_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d1862 1
a1862 1
	if (HTConfirmDefault(CONFIRM_BOOKMARK_DELETE,NO) != YES)
d1864 1
a1864 1
	remove_bookmark_link(links[curdoc.link].anchor_number-1,
d1866 1
a1866 1
    } else {	/* behave like REFRESH for backward compatibility */
d1878 3
a1880 4
PRIVATE void handle_LYK_DIRED_MENU ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c GCC_UNUSED,
    int,	real_c GCC_UNUSED)
d1887 6
a1892 7
     *	Check if the CSwing Directory/File Manager is available.
     *	Will be disabled if CSWING path is NULL, zero-length,
     *	or "none" (case insensitive), if no_file_url was set via
     *	the file_url restriction, if no_goto_file was set for
     *	the anonymous account, or if HTDirAccess was set to
     *	HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse
     *	or -selective switches. - FM
d1899 1
a1899 1
	if (*old_c != real_c)	{
d1907 5
a1911 7
     *	If we are viewing a local directory listing or a
     *	local file which is not temporary, invoke CSwing
     *	with the URL's directory converted to VMS path specs
     *	and passed as the argument, so we start up CSwing
     *	positioned on that node of the directory tree.
     *	Otherwise, pass the current default directory as
     *	the argument. - FM
d1917 2
a1918 2
	 *  We are viewing a local directory or a local file
	 *  which is not temporary. - FM
d1922 1
a1922 1
	cp = HTParse(curdoc.address, "", PARSE_PATH|PARSE_PUNCTUATION);
d1928 1
a1928 1
	    *refresh_screen = TRUE;  /* redisplay */
d1934 2
a1935 2
		 *  We're viewing a local directory.  Make
		 *  that the CSwing argument. - FM
d1942 2
a1943 2
		 *  We're viewing a local file.  Make its
		 *  directory the CSwing argument. - FM
d1958 2
a1959 3
	     *	Uncache the current document in case we
	     *	change, move, or delete it during the
	     *	CSwing session. - FM
d1972 3
a1974 4
	 *  We're not viewing a local directory or file.
	 *  Pass CSwing the current default directory as
	 *  an argument and don't uncache the current
	 *  document. - FM
d1985 1
a1985 1
     *	Don't do if not allowed or already viewing the menu.
d1990 1
a1990 1
	dired_options(&curdoc,&newdoc.address);
d1997 3
a1999 4
PRIVATE int handle_LYK_DOWNLOAD ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
d2003 1
a2003 1
     *	Don't do if both download and disk_save are restricted.
d2007 1
a2007 1
	if (*old_c != real_c)	{
d2015 1
a2015 1
     *	Don't do if already viewing download options page.
d2021 1
a2021 1
	return 1;	/* mouse stuff was confused, ignore - kw */
d2028 1
a2028 1
			 URL_MAIL_METHOD) {
d2053 1
a2053 1
	    if (*old_c != real_c)	{
d2059 1
a2059 1
	    if (*old_c != real_c)	{
a2062 1

d2065 1
a2065 1
	    if (*old_c != real_c)	{
d2071 1
a2071 1
	    if (*old_c != real_c)	{
d2079 1
a2079 1
	     *	Don't bother making a /tmp copy of the local file.
d2082 1
d2094 1
a2094 1
	    isLYNXHIST(links[curdoc.link].lname)) {
d2096 1
d2108 1
a2108 1
	     *  OK, we download from history page, restore URL from stack.
d2127 1
a2127 1
	     *	Force the document to be reloaded.
d2143 1
a2143 1
		   /* handled above if valid - kw */
d2154 9
a2162 9
	/*
	 *  From here on we could have a remote host, so check if
	 *  that's allowed.
	 *
	 *  We copy all these checks from getfile() to LYK_DOWNLOAD
	 *  here because LYNXDOWNLOAD:// will NOT be pushing the
	 *  previous document into the history stack so preserve
	 *  getfile() from returning a wrong status (NULLFILE).
	 */
d2167 1
a2167 1
	} else {   /* Not a forms, options or history link */
d2169 2
a2170 3
	     *	Follow a normal link or anchor.  Note that
	     *	if it's an anchor within the same document,
	     *	entire document will be downloaded.
d2176 2
a2177 2
	     *	Might be an internal link in the same doc from a
	     *	POST form.  If so, don't free the content. - kw
d2182 2
a2183 2
	     *	Might be an anchor in the same doc from a POST
	     *	form.  If so, don't free the content. -- FM
d2197 1
a2197 1
	     *	Force the document to be reloaded.
d2208 3
a2210 3
PRIVATE void handle_LYK_DOWN_HALF ARGS2(
    int *,	old_c,
    int,	real_c)
d2214 2
a2215 2
    if (more) {
	Newline += (display_lines/2);
d2217 1
a2217 1
	    links[curdoc.link].ly > display_lines/2) {
d2219 1
a2219 1
	    for (i = 0; links[i].ly <= (display_lines/2); i++)
d2228 9
a2236 4
PRIVATE void handle_LYK_DOWN_LINK ARGS3(
    int *,	follow_col,
    int *,	old_c,
    int,	real_c)
d2238 1
a2238 1
    if (curdoc.link < (nlinks-1)) {	/* more links? */
d2242 2
a2243 1
	    char *text = LYGetHiliteStr(curdoc.link, 0);
d2253 2
a2254 2
	} else if (more) {  /* next page */
	    Newline += (display_lines);
d2260 2
a2261 3
    } else if (more) {	/* next page */
	    Newline += (display_lines);

d2268 2
a2269 3
PRIVATE void handle_LYK_DOWN_TWO ARGS2(
    int *,	old_c,
    int,	real_c)
d2271 1
a2271 14
    int i;

    if (more) {
	Newline += 2;
	if (nlinks > 0 && curdoc.link > -1 &&
	    links[curdoc.link].ly > 2) {
	    newdoc.link = curdoc.link;
	    for (i = 0; links[i].ly <= 2; i++)
		--newdoc.link;
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_END);
    }
d2274 3
a2276 4
PRIVATE int handle_LYK_DWIMEDIT ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
d2280 6
a2285 7
     *  If we're in a forms TEXTAREA, invoke the editor on *its*
     *  contents, rather than attempting to edit the html source
     *  document.  KED
     */
    if (nlinks > 0  &&
	links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d2291 4
a2294 5
     *  If we're in a forms TEXT type, tell user the request
     *  is bogus (though in reality, without this trap, if the
     *  document with the TEXT field is local, the editor *would*
     *  be invoked on the source .html file; eg, the o(ptions)
     *  form tempfile).
d2296 2
a2297 3
     *  [This is done to avoid possible user confusion, due to
     *   auto invocation of the editor on the TEXTAREA's contents
     *   via the above if() statement.]
d2300 3
a2302 3
	links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXT_TYPE)       {
	HTUserMsg (CANNOT_EDIT_FIELD);
d2317 5
a2321 6
PRIVATE int handle_LYK_ECGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
d2325 1
a2325 1
	 *  Go to not allowed. - FM
d2338 1
a2338 1
	 *  Disallow editing of File Management URLs. - FM
d2349 2
a2350 2
     *	Save the current user_input_buffer string,
     *	and load the current document's address.
d2358 2
a2359 2
     *	Warn the user if the current document has POST
     *	data associated with it. - FM
d2365 1
a2365 1
     *	Offer the current document's URL for editing. - FM
d2369 1
a2369 1
			MAX_LINE, RECALL_URL)) >= 0) &&
d2378 1
a2378 2
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
d2386 2
a2387 3
PRIVATE void handle_LYK_EDIT ARGS2(
    int *,	old_c,
    int,	real_c)
a2400 1

d2402 5
a2406 6
    /*
     *	Allow the user to edit the link rather
     *	than curdoc in edit mode.
     */
    if (lynx_edit_mode &&
	editor && *editor != '\0' && !no_dired_support) {
d2420 1
a2420 1
			if (edit_current_file(tp, curdoc.link, Newline)) {
d2425 1
a2425 1
			     *	Go to top of file.
d2431 1
a2431 2
			     *	Seek old position,
			     *	which probably changed.
d2436 1
a2436 1
			    LYclear();  /* clear the screen */
d2445 2
a2446 2
    if (editor && *editor != '\0') {
	if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
d2448 2
a2449 2
	    LYforce_no_cache = TRUE;  /*force reload of document */
	    free_address(&curdoc); /* so it doesn't get pushed */
d2452 1
a2452 1
	     *	Go to top of file.
d2458 1
a2458 1
	     *	Seek old position, which probably changed.
d2463 1
a2463 1
	    LYclear();  /* clear the screen */
d2474 1
a2474 2
PRIVATE void handle_LYK_DWIMHELP ARGS1(
    CONST char **,	cshelpfile)
d2477 2
a2478 3
     *  Currently a help file different from the main
     *  'helpfile' is shown only if current link is a
     *  text input form field. - kw
d2488 3
a2490 4
PRIVATE void handle_LYK_EDIT_TEXTAREA ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d2506 1
a2506 1
     *  See if the current link is in a form TEXTAREA.
d2508 2
a2509 2
    else if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	     links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d2514 1
a2514 1
	n = HText_ExtEditForm (&links[curdoc.link]);
d2517 5
a2521 6
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st trailing blank line in
	 *	  the now edited TEXTAREA.  If the target line/
	 *	  anchor requires us to scroll up/down, position
	 *	  the target in the approximate center of the
	 *	  screen.
d2524 3
a2526 2
	/* curdoc.link += n;*/	/* works, except for page crossing, */
				/* damnit; why is nothing ever easy */
d2534 1
a2534 1
	HTInfoMsg (NOT_IN_TEXTAREA_NOEDIT);
d2538 5
a2542 6
PRIVATE int handle_LYK_ELGOTO ARGS5(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	old_c,
    int,	real_c)
d2546 1
a2546 1
	 *  Go to not allowed. - FM
d2560 1
a2560 2
	 *  No links on page, or not a normal link
	 *  or form submit button. - FM
d2572 1
a2572 1
	 *  Form submit button with no ACTION defined. - FM
d2586 1
a2586 1
	 *  Disallow editing of File Management URLs. - FM
d2597 2
a2598 2
     *	Save the current user_input_buffer string,
     *	and load the current link's address. - FM
d2603 2
a2604 2
					?
    links[curdoc.link].l_form->submit_action : links[curdoc.link].lname),
d2608 1
a2608 1
     *	Offer the current link's URL for editing. - FM
d2612 1
a2612 1
			MAX_LINE, RECALL_URL)) >= 0) &&
d2616 2
a2617 2
			? links[curdoc.link].l_form->submit_action
			: links[curdoc.link].lname))) {
d2624 1
a2624 2
     *	User cancelled via ^G, a full deletion,
     *	or not modifying the URL. - FM
d2633 1
a2633 2
PRIVATE void handle_LYK_EXTERN_LINK ARGS1(
    BOOLEAN *,	refresh_screen)
d2635 1
a2635 2
    if ((nlinks > 0) && (links[curdoc.link].lname != NULL))
    {
d2641 1
a2641 2
PRIVATE void handle_LYK_EXTERN_PAGE ARGS1(
    BOOLEAN *,	refresh_screen)
d2643 1
a2643 2
    if (curdoc.address != NULL)
    {
d2650 3
a2652 4
PRIVATE BOOLEAN handle_LYK_FASTBACKW_LINK ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
d2656 1
d2661 2
a2662 2
	 *  If in textarea, move to first link or textarea group
	 *  before it if there is one on this screen. - kw
d2674 2
a2675 1
		do nextlink--;
d2683 1
a2683 1
	    } else if (!more && Newline == 1 &&
d2688 4
a2691 4
		       !(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
			 links[nlinks-1].l_form->type == F_TEXTAREA_TYPE &&
			 links[nlinks-1].l_form->number == thisgroup &&
			 sametext(links[nlinks-1].l_form->name, thisname))) {
d2695 1
a2695 1
	    } else if (!more && Newline == 1 && curdoc.link > 0) {
d2702 1
a2702 1
	} else if (!more && Newline == 1) {
d2707 1
d2710 3
a2712 3
	 *  If the link as determined so far is part of a
	 *  group of textarea fields, try to use the first
	 *  of them that's on the screen instead. - kw
d2719 1
d2728 4
a2731 4
		     links[nextlink-1].type == WWW_FORM_LINK_TYPE &&
		     links[nextlink-1].l_form->type == F_TEXTAREA_TYPE &&
		     links[nextlink-1].l_form->number == thisgroup &&
		     sametext(links[nextlink-1].l_form->name, thisname)) {
a2735 1
	return FALSE;		/* and we are done. */
d2737 1
a2737 1
    } else if (Newline > 1 &&	/* need a previous page */
d2743 2
a2744 2
	     *  It says we should use the normal PREV_LINK
	     *  mechanism, so we'll do that. - kw
d2749 3
a2751 1
	    return TRUE;
a2752 3
	Newline++;	/* our line counting starts with 1 not 0 */
	/* nothing more to do here */

d2757 1
a2757 1
    return FALSE;
d2760 2
a2761 3
PRIVATE void handle_LYK_FASTFORW_LINK ARGS2(
    int *,	old_c,
    int,	real_c)
d2768 2
a2769 2
	 *  If in textarea, move to first link or field
	 *  after it if there is one on this screen. - kw
d2776 7
a2782 6
	    if (curdoc.link < nlinks-1 &&
		!(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
		  links[nlinks-1].l_form->type == F_TEXTAREA_TYPE &&
		  links[nlinks-1].l_form->number == thisgroup &&
		  sametext(links[nlinks-1].l_form->name, thisname))) {
		do nextlink++;
d2789 1
a2789 1
	    } else if (!more && Newline == 1 && curdoc.link > 0) {
d2793 1
a2793 1
	} else if (curdoc.link < nlinks-1) {
d2796 1
a2796 1
	} else if (!more && Newline == 1 && curdoc.link > 0) {
d2801 1
d2804 5
a2808 7
	return;		/* and we are done. */

    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
d2811 1
a2811 1
    } else if (more &&	/* need a later page */
d2815 1
a2815 1
	Newline++;	/* our line counting starts with 1 not 0 */
d2825 1
a2825 1
PRIVATE void handle_LYK_FIRST_LINK NOARGS
d2831 1
a2831 1
	 || links[i].ly != links[curdoc.link].ly) {
d2838 9
a2846 10
PRIVATE BOOLEAN handle_LYK_GOTO ARGS9(
    int *,	ch,
    char *,	user_input_buffer,
    char **,	old_user_input,
    int *,	recall,
    int *,	URLTotal,
    int *,	URLNum,
    BOOLEAN *,	FirstURLRecall,
    int *,	old_c,
    int,	real_c)
d2873 1
a2873 1
     *	Ask the user.
d2877 1
a2877 1
		       MAX_LINE, *recall)) < 0 ) {
d2879 2
a2880 2
	 *  User cancelled the Goto via ^G.
	 *  Restore user_input_buffer and break. - FM
d2890 1
a2890 2
PRIVATE void handle_LYK_GROW_TEXTAREA ARGS1(
    BOOLEAN *,	refresh_screen)
d2893 1
a2893 1
     *  See if the current link is in a form TEXTAREA.
d2895 2
a2896 2
    if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d2898 1
a2898 1
	HText_ExpandTextarea (&links[curdoc.link], TEXTAREA_EXPAND_SIZE);
d2904 1
a2904 1
	HTInfoMsg (NOT_IN_TEXTAREA);
d2908 1
a2908 2
PRIVATE BOOLEAN handle_LYK_HEAD ARGS1(
    int *,	cmd)
d2913 1
a2913 1
	(links[curdoc.link].type         != WWW_FORM_LINK_TYPE ||
d2925 3
a2927 2
			 ? curdoc.address
			 : curdoc.address + LEN_LYNXIMGMAP;
d2965 1
d2968 1
a2968 1
							 "http", 4)) {
d2972 1
a2972 1
						  URL_POST_METHOD &&
d3010 3
a3012 2
			     ? curdoc.address
			     : curdoc.address + LEN_LYNXIMGMAP;
d3036 1
a3036 2
PRIVATE void handle_LYK_HELP ARGS1(
    CONST char **,	cshelpfile)
d3038 2
d3042 3
a3044 1
    if (!STREQ(curdoc.address, *cshelpfile)) {
d3046 1
a3046 1
	 *  Set the filename.
d3048 1
a3048 1
	set_address(&newdoc, *cshelpfile);
d3050 1
a3050 1
	 *  Make a name for this help file.
d3059 1
d3063 1
a3063 1
PRIVATE void handle_LYK_HISTORICAL NOARGS
d3068 14
a3081 15
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HText_setNoCache(HTMainText);
	move_address(&newdoc, &curdoc);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
d3083 1
a3083 1
    } /* end if no bypass */
d3099 1
a3099 2
PRIVATE BOOLEAN handle_LYK_HISTORY ARGS1(
    BOOLEAN,	ForcePush)
d3103 1
a3103 1
	 *  Don't do this if already viewing history page.
d3105 3
a3107 3
	 *  Push the current file so that the history list
	 *  contains the current file for printing purposes.
	 *  Pop the file afterwards to prevent multiple copies.
d3119 1
a3119 1
	 *  Print history options to file.
d3132 2
a3133 2
	newdoc.link = 1; /*@@@@@@ bypass "recent statusline messages" link */
	free_address(&curdoc);  /* so it doesn't get pushed */
d3139 1
a3139 1
    } /* end if strncmp */
d3143 1
a3143 2
PRIVATE BOOLEAN handle_LYK_IMAGE_TOGGLE ARGS1(
    int *,	cmd)
d3148 1
a3148 1
	     CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
d3152 2
a3153 3
PRIVATE void handle_LYK_INDEX ARGS2(
    int *,	old_c,
    int,	real_c)
d3156 1
a3156 1
     *	Make sure we are not in the index already.
d3160 5
a3164 5
	if (indexfile[0]=='\0') { /* no defined index */
		if (*old_c != real_c)	{
		    *old_c = real_c;
		    HTUserMsg(NO_INDEX_FILE);
		}
d3173 1
a3173 1
	    StrAllocCopy(newdoc.title, gettext("System Index")); /* name it */
d3179 2
a3180 2
	} /* end else */
    }  /* end if */
d3183 4
a3186 5
PRIVATE void handle_LYK_INDEX_SEARCH ARGS4(
    BOOLEAN *,	force_load,
    BOOLEAN,	ForcePush,
    int *,	old_c,
    int,	real_c)
d3190 1
a3190 1
	 *  Perform a database search.
d3192 3
a3194 3
	 *  do_www_search will try to go out and get the document.
	 *  If it returns TRUE, a new document was returned and is
	 *  named in the newdoc.address.
d3200 1
a3200 1
	     *	Yah, the search succeeded.
d3204 1
a3204 1
		 *  Make sure cursor is down.
d3214 3
a3216 3
	     *	Make the curdoc.address the newdoc.address so that
	     *	getfile doesn't try to get the newdoc.address.
	     *	Since we have already gotten it.
d3223 1
a3223 1
	    Newline = 0;
d3226 1
a3226 1
	     *	Got back a redirecting URL.  Check it out.
d3228 1
a3228 1
	    HTUserMsg2 (WWW_USING_MESSAGE, use_this_url_instead);
d3231 1
a3231 1
	     *	Make a name for this URL.
d3245 1
a3245 1
	     *	Yuk, the search failed.  Restore the old file.
d3262 1
a3262 2
PRIVATE BOOLEAN handle_LYK_INFO ARGS1(
    int *,	cmd)
d3265 1
a3265 1
     *	Don't do if already viewing info page.
d3269 1
a3269 2
	 && LYShowInfo(&curdoc, HText_getNumOfLines(),
		       &newdoc, owner_address) >= 0) {
d3283 1
a3283 1
	 *  If already in info page, get out.
d3291 1
a3291 2
PRIVATE BOOLEAN handle_LYK_INLINE_TOGGLE ARGS1(
    int *,	cmd)
d3300 3
a3302 4
PRIVATE void handle_LYK_INSERT_FILE ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d3307 1
a3307 1
     *  See if the current link is in a form TEXTAREA.
d3309 2
a3310 2
    if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].l_form->type == F_TEXTAREA_TYPE)   {
d3313 6
a3318 8
	 *  Reject attempts to use this for gaining access to
	 *  local files when such access is restricted:
	 *  if no_file_url was set via the file_url restriction,
	 *  if no_goto_file was set for the anonymous account,
	 *  or if HTDirAccess was set to HT_DIR_FORBID or
	 *  HT_DIR_SELECTIVE via the -nobrowse or -selective
	 *  switches, it is assumed that inserting files or
	 *  checking for existence of files needs to be denied. - kw
d3334 1
a3334 1
	n = HText_InsertFile (&links[curdoc.link]);
d3337 5
a3341 5
	 *  TODO: Move cursor "n" lines from the current line to
	 *	  position it on the 1st line following the text
	 *	  that was inserted.  If the target line/anchor
	 *	  requires us to scroll up/down, position the
	 *	  target in the approximate center of the screen.
d3343 4
a3346 4
	 *  [Current behavior leaves cursor on the same line relative
	 *   to the start of the TEXTAREA that it was on before the
	 *   insertion.  This is the same behavior that occurs with
	 *   (my) editor, so this TODO will stay unimplemented.]
d3353 1
a3353 1
	HTInfoMsg (NOT_IN_TEXTAREA);
d3358 1
a3358 1
PRIVATE void handle_LYK_INSTALL NOARGS
d3365 10
a3374 11
PRIVATE BOOLEAN handle_LYK_JUMP ARGS10(
    int,	c,
    char *,	user_input_buffer,
    char **,	old_user_input GCC_UNUSED,
    int *,	recall GCC_UNUSED,
    BOOLEAN *,	FirstURLRecall GCC_UNUSED,
    int *,	URLNum GCC_UNUSED,
    int *,	URLTotal GCC_UNUSED,
    int *,	ch GCC_UNUSED,
    int *,	old_c,
    int,	real_c)
d3406 1
a3406 1
		ret = HTParse((ret+3), startfile, PARSE_ALL);
d3432 4
a3435 5
PRIVATE void handle_LYK_KEYMAP ARGS4(
    BOOLEAN *,	vi_keys_flag,
    BOOLEAN *,	emacs_keys_flag,
    int *,	old_c,
    int,	real_c)
d3447 2
a3448 2
	 *  If vi_keys changed, the keymap did too,
	 *  so force no cache, and reset the flag. - FM
d3458 2
a3459 2
	 *  Remember whether we are in dired menu
	 *  so we can display the right keymap.
d3469 1
a3469 1
PRIVATE void handle_LYK_LAST_LINK NOARGS
d3475 1
a3475 1
	 || links[i].ly != links[curdoc.link].ly) {
d3482 1
a3482 1
PRIVATE void handle_LYK_LEFT_LINK NOARGS
d3484 3
a3486 3
    if (curdoc.link>0 &&
		links[curdoc.link].ly == links[curdoc.link-1].ly) {
	set_curdoc_link(curdoc.link-1);
d3490 1
a3490 2
PRIVATE BOOLEAN handle_LYK_LIST ARGS1(
    int *,     cmd)
d3493 1
a3493 1
     *	Don't do if already viewing list page.
d3498 1
a3498 1
	 *  Already viewing list page, so get out.
d3505 1
a3505 1
     *	Print list page to file.
d3511 3
a3513 4
     *	showlist will set newdoc's other fields.  It may leave
     *	post_data intact so the list can be used to follow
     *	internal links in the current document even if it is
     *	a POST response. - kw
d3523 2
a3524 3
PRIVATE void handle_LYK_MAIN_MENU ARGS2(
    int *,	old_c,
    int,	real_c)
d3527 1
a3527 1
     *	If its already the homepage then don't reload it.
d3529 1
a3529 1
    if (!STREQ(curdoc.address,homepage)) {
d3554 1
a3554 1
PRIVATE void handle_LYK_MINIMAL NOARGS
d3558 1
a3558 1
    if (!HTcan_reparse_document()) {
d3560 14
a3573 15
	/*
	 *  Check if this is a reply from a POST, and if so,
	 *  seek confirmation of reload if the safe element
	 *  is not set. - FM
	 */
	if ((curdoc.post_data != NULL &&
	     curdoc.safe != TRUE) &&
	    confirm_post_resub(curdoc.address, NULL, 0, 0) == FALSE) {
	    HTInfoMsg(WILL_NOT_RELOAD_DOC);
	} else {
	    HText_setNoCache(HTMainText);
	    move_address(&newdoc, &curdoc);
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
	}
d3575 1
a3575 1
    } /* end if no bypass */
d3587 1
a3587 1
    (void)reparse_document();
d3593 1
a3593 2
PRIVATE void handle_LYK_MODIFY ARGS1(
    BOOLEAN *,	refresh_screen)
d3599 1
a3599 1
	if (ret == PERMIT_FORM_RESULT) { /* Permit form thrown up */
d3618 1
a3618 2
PRIVATE BOOLEAN handle_LYK_NESTED_TABLES ARGS1(
    int *,	cmd)
d3626 2
a3627 3
PRIVATE BOOLEAN handle_LYK_OPTIONS ARGS2(
    int *,	cmd,
    BOOLEAN *,	refresh_screen)
d3643 4
a3646 6
	StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : ""));
	StrAllocCopy(CurrentNegoLanguage, (language ?
					   language : ""));
	StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""));
d3663 3
a3665 6
	    ((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
	      strcmp(CurrentNegoLanguage, (language ?
					   language : "")) ||
	      strcmp(CurrentNegoCharset, (pref_charset ?
					  pref_charset : ""))) &&
d3672 2
a3673 3
	     *  Check if this is a reply from a POST, and if so,
	     *  seek confirmation of reload if the safe element
	     *  is not set. - FM
d3685 1
a3685 2
		if (((strcmp(CurrentUserAgent, (LYUserAgent ?
					LYUserAgent : "")) ||
d3691 8
a3698 9
		     *  An option has changed which may influence
		     *  content negotiation, and the resource is from
		     *  a http or https or lynxcgi URL (the only protocols
		     *  which currently do anything with this information).
		     *  Set reloading = TRUE so that proxy caches will be
		     *  flushed, which is necessary until the time when
		     *  all proxies understand HTTP 1.1 Vary: and all
		     *  Servers properly use it...	Treat like
		     *  case LYK_RELOAD (see comments there). - KW
a3729 4
#ifdef NO_ASSUME_SAME_DOC
		newdoc.line = 1;
		newdoc.link = 0;
#else
a3731 1
#endif /* NO_ASSUME_SAME_DOC */
d3733 1
a3733 1
		free_address(&curdoc); /* So it doesn't get pushed. */
d3739 1
a3739 1
	*refresh_screen = TRUE; /* to repaint screen */
d3741 1
a3741 1
    } /* end if !LYUseFormsOptions */
d3757 1
a3757 1
     *	Don't do if already viewing options page.
d3761 1
a3761 1
	set_address(&newdoc, "LYNXOPTIONS:/");
d3774 1
a3774 1
   } else {
d3776 1
a3776 1
	 *  If already in the options menu, get out.
d3785 1
a3785 1
PRIVATE void handle_NEXT_DOC NOARGS
d3794 3
a3796 4
PRIVATE void handle_LYK_NEXT_LINK ARGS3(
    int,	c,
    int *,	old_c,
    int,	real_c)
d3798 1
a3798 1
    if (curdoc.link < nlinks-1) {	/* next link */
d3802 1
a3802 1
	 *  Move to different textarea if TAB in textarea.
d3804 1
a3804 1
	if (links[curdoc.link].type         == WWW_FORM_LINK_TYPE &&
d3806 1
a3806 1
	    c=='\t') {
d3810 3
a3812 2
	    do curdoc.link++;
	    while ((curdoc.link < nlinks-1) &&
d3823 5
a3827 5
    /*
     *	At the bottom of list and there is only one page.
     *	Move to the top link on the page.
     */
    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
d3830 2
a3831 3
    } else if (more) {	/* next page */
	Newline += (display_lines);

d3838 6
a3843 7
PRIVATE void handle_LYK_NEXT_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
{
    if (more) {
	Newline += display_lines;
    } else if (curdoc.link < nlinks-1) {
d3851 2
a3852 3
PRIVATE BOOLEAN handle_LYK_NOCACHE ARGS2(
    int *,	old_c,
    int,	real_c)
d3872 3
a3874 4
PRIVATE void handle_LYK_PREV_LINK ARGS3(
    int *,	arrowup,
    int	*,	old_c,
    int,	real_c)
d3876 1
a3876 1
    if (curdoc.link > 0) {	     /* previous link */
d3879 2
a3880 2
    } else if (!more &&
	       curdoc.link==0 && Newline==1) { /* at the top of list */
d3882 2
a3883 3
	 *  If there is only one page of data and the user
	 *  goes off the top, just move the cursor to last link on
	 *  the page.
d3889 1
a3889 1
	 *  Go back to the previous page.
d3891 5
a3895 3
	int scrollamount = (Newline > display_lines ?
				      display_lines : Newline - 1);
	Newline -= scrollamount;
d3899 3
a3901 3
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
d3912 15
a3926 15
PRIVATE int handle_PREV_DOC ARGS3(
    int *,	cmd,
    int *,	old_c,
    int,	real_c)
{
    if (nhist > 0) {  /* if there is anything to go back to */
	/*
	 *  Check if the previous document is a reply from a POST,
	 *  and if so, seek confirmation of resubmission if the safe
	 *  element is not set and the document is not still in the
	 *  cache or LYresubmit_posts is set.  If not confirmed and
	 *  it is not the startfile, pop it so we go to the yet
	 *  previous document, until we're OK or reach the startfile.
	 *  If we reach the startfile and its not OK or we don't get
	 *  confirmation, cancel. - FM
d3933 1
a3933 1
	HTLastConfirmCancelled(); /* reset flag */
d3936 1
a3936 1
	    if (HDOC(nhist - 1).post_data == NULL) {
d3939 2
a3940 2
	    WWWDoc.address = HDOC(nhist - 1).address;
	    WWWDoc.post_data = HDOC(nhist - 1).post_data;
d3942 4
a3945 4
			       HDOC(nhist - 1).post_content_type;
	    WWWDoc.bookmark = HDOC(nhist - 1).bookmark;
	    WWWDoc.isHEAD = HDOC(nhist - 1).isHEAD;
	    WWWDoc.safe = HDOC(nhist - 1).safe;
d3950 1
a3950 1
	    if (((text = (HText *)HTAnchor_document(tmpanchor)) == NULL &&
d3952 3
a3954 3
		 (conf = confirm_post_resub(WWWDoc.address,
					    HDOC(nhist - 1).title,
					    0, 0))
d3957 4
a3960 6
		  (NONINTERNAL_OR_PHYS_DIFFERENT(
		      (DocInfo *)&history[(nhist - 1)],
		      &curdoc) ||
		   NONINTERNAL_OR_PHYS_DIFFERENT(
		       (DocInfo *)&history[(nhist - 1)],
		       &newdoc))) &&
d3962 1
a3962 1
				     HDOC(nhist - 1).title,
d3979 4
a3982 4
		    } while (nhist > 1 && !are_different(
			(DocInfo *)&history[(nhist - 1)],
			&curdoc));
		    first = FALSE; /* have popped at least one */
d3987 3
a3989 4
		 *  Break from loop; if user just confirmed to
		 *  load again because document wasn't in cache,
		 *  set LYforce_no_cache to avoid unnecessary
		 *  repeat question down the road. - kw
d4001 1
a4001 1
	 *  Set newdoc.address to empty to pop a file.
d4011 1
a4011 1
	return(1); /* exit on left arrow in main screen */
d4020 2
a4021 3
PRIVATE void handle_LYK_PREV_PAGE ARGS2(
    int	*,	old_c,
    int,	real_c)
d4023 2
a4024 2
    if (Newline > 1) {
	Newline -= display_lines;
d4033 3
a4035 4
PRIVATE void handle_LYK_PRINT ARGS3(
    BOOLEAN *,	ForcePush,
    int *,	old_c,
    int,	real_c)
d4038 1
a4038 1
	if (*old_c != real_c)	{
d4046 1
a4046 1
     *	Don't do if already viewing print options page.
d4049 2
a4050 2
     && print_options(&newdoc.address,
		      curdoc.address, HText_getNumOfLines()) >= 0) {
d4057 1
a4057 1
	*ForcePush = TRUE;  /* see LYpush() and print_options() */
d4063 1
a4063 1
PRIVATE BOOLEAN handle_LYK_QUIT NOARGS
d4074 1
a4074 1
	    return(TRUE);
d4079 1
a4079 1
	return(TRUE);
d4086 1
a4086 2
PRIVATE BOOLEAN handle_LYK_RAW_TOGGLE ARGS1(
    int *,	cmd)
d4099 1
a4099 2
PRIVATE void handle_LYK_RELOAD ARGS1(
    int,	real_cmd)
d4113 1
a4113 1
     *	Check to see if should reload source, or load html
a4123 1
#ifdef NO_ASSUME_SAME_DOC
d4125 4
a4128 10
     *	Don't assume the reloaded document will be the same. - FM
     */
    newdoc.line = 1;
    newdoc.link = 0;
#else
    /*
     *	Do assume the reloaded document will be the same. - FM
     *	(I don't remember all the reasons why we couldn't assume
     *	 this.	As the problems show up, we'll try to fix them,
     *	 or add warnings.  - FM)
d4132 1
a4132 2
#endif /* NO_ASSUME_SAME_DOC */
    free_address(&curdoc); /* so it doesn't get pushed */
d4137 2
a4138 2
     *	Reload should force a cache refresh on a proxy.
     *	      -- Ari L. <luotonen@@dxcern.cern.ch>
d4140 3
a4142 3
     *	-- but only if this was really a reload requested by
     *	the user, not if we jumped here to handle reloading for
     *	INLINE_TOGGLE, IMAGE_TOGGLE, RAW_TOGGLE, etc. - KW
d4151 1
a4151 2
PRIVATE void handle_LYK_REMOVE ARGS1(
    BOOLEAN *,	refresh_screen)
d4154 2
a4155 1
	int linkno = curdoc.link; /* may be changed in local_remove - kw */
d4165 1
a4165 1
PRIVATE void handle_LYK_RIGHT_LINK NOARGS
d4167 2
a4168 2
    if (curdoc.link<nlinks-1 &&
		links[curdoc.link].ly == links[curdoc.link+1].ly) {
d4173 3
a4175 4
PRIVATE void handle_LYK_SHELL ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d4186 7
a4192 1
	LYSystem(LYSysShell());
d4196 1
a4196 1
	if (*old_c != real_c)	{
d4203 1
a4203 1
PRIVATE void handle_LYK_SOFT_DQUOTES NOARGS
d4208 14
a4221 15
    /*
     *	Check if this is a reply from a POST, and if so,
     *	seek confirmation of reload if the safe element
     *	is not set. - FM
     */
    if ((curdoc.post_data != NULL &&
	 curdoc.safe != TRUE) &&
	confirm_post_resub(curdoc.address, NULL, 1, 1) == FALSE) {
	HTInfoMsg(WILL_NOT_RELOAD_DOC);
    } else {
	HText_setNoCache(HTMainText);
	move_address(&newdoc, &curdoc);
	newdoc.line = curdoc.line;
	newdoc.link = curdoc.link;
    }
d4223 1
a4223 1
    } /* end if no bypass */
d4229 1
a4229 1
    (void)reparse_document();
d4234 69
a4302 2
PRIVATE void handle_LYK_SOURCE ARGS1(
    char **,	ownerS_address_p)
d4304 4
a4311 3
#ifdef USE_SOURCE_CACHE
    BOOLEAN canreparse_post = FALSE;
#endif
d4333 1
a4333 1
    if (reparse_document()) {
d4345 1
a4345 1
	FREE(*ownerS_address_p);  /* not used with source_cache */
d4347 1
a4347 1
	HTMLSetCharacterHandling(current_char_set);  /* restore now */
d4359 2
a4360 1
    free_address(&curdoc); /* so it doesn't get pushed */
d4364 1
a4364 1
PRIVATE void handle_LYK_SWITCH_DTD NOARGS
d4368 1
d4382 3
a4384 3
	     *  If currently viewing preparsed source, switching
	     *  to the other DTD parsing may show source differences,
	     *  so stay in source view - kw
d4391 1
a4391 1
	    */
a4396 4
#ifdef NO_ASSUME_SAME_DOC
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
a4398 1
#endif /* NO_ASSUME_SAME_DOC */
d4401 1
a4401 1
    } /* end if no bypass */
d4420 1
a4420 1
PRIVATE void handle_LYK_TAG_LINK NOARGS
d4424 1
a4424 1
	    return;	/* Never tag the parent directory */
d4432 1
a4432 1
	     *	HTList-based management of tag list, see LYLocal.c - KW
d4434 2
a4435 2
	    HTList * t1 = tagged;
	    char * tagname = NULL;
d4438 1
a4438 1
	    while ((tagname = (char *)HTList_nextObject(t1)) != NULL) {
d4443 1
a4443 1
		    tagflag(OFF,curdoc.link);
d4451 3
a4453 3
		StrAllocCopy(tagname,links[curdoc.link].lname);
		HTList_addObject(tagged,tagname);
		tagflag(ON,curdoc.link);
d4456 1
a4456 1
	if (curdoc.link < nlinks-1) {
d4458 2
a4459 1
	} else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
d4461 2
a4462 2
	} else if (more) {  /* next page */
	    Newline += (display_lines);
d4468 1
a4468 1
PRIVATE void handle_LYK_TOGGLE_HELP NOARGS
d4472 1
a4472 1
	noviceline(more);
d4476 4
a4479 5
PRIVATE void handle_LYK_TOOLBAR ARGS4(
    BOOLEAN *,	try_internal,
    BOOLEAN *,	force_load,
    int *,	old_c,
    int,	real_c)
d4497 1
a4497 1
	*force_load = TRUE;  /* force MainLoop to reload */
d4501 1
a4501 2
PRIVATE void handle_LYK_TRACE_LOG ARGS1(
    BOOLEAN *,	trace_flag_ptr)
d4505 1
a4505 2
     *	Check whether we've started a TRACE log
     *	in this session. - FM
d4513 1
a4513 1
     *	Don't do if already viewing the TRACE log. - FM
d4519 7
a4525 9
     *	If TRACE mode is on, turn it off during this fetch of the
     *	TRACE log, so we don't enter stuff about this fetch, and
     *	set a flag for turning it back on when we return to this
     *	loop.  Note that we'll miss any messages about memory
     *	exhaustion if it should occur.	It seems unlikely that
     *	anything else bad might happen, but if it does, we'll
     *	miss messages about that too.  We also fflush(), close,
     *	and open it again, to make sure all stderr messages thus
     *	far will be in the log. - FM
d4530 1
a4530 1
    LYLocalFileToURL (&(newdoc.address), LYTraceLogPath);
d4548 1
a4548 1
PRIVATE void handle_LYK_UPLOAD NOARGS
d4551 1
a4551 1
     *	Don't do if already viewing upload options page.
d4565 2
a4566 3
	 *  Uncache the current listing so that it will
	 *  be updated to included the uploaded file if
	 *  placed in the current directory. - FM
d4569 1
a4569 1
     }
d4573 9
a4581 10
PRIVATE void handle_LYK_UP_HALF ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	int scrollamount = display_lines/2;
	if (Newline - scrollamount < 1)
	    scrollamount = Newline - 1;
	Newline -= scrollamount;
d4583 1
a4583 1
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
d4585 3
a4587 3
			      HText_LinksInLines(HTMainText,
						 Newline,
						 scrollamount);
d4598 11
a4608 5
PRIVATE void handle_LYK_UP_LINK ARGS4(
    int *,	follow_col,
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
d4612 1
a4612 1
	 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
d4618 2
a4619 1
	    char *text = LYGetHiliteStr(curdoc.link, 0);
d4634 6
a4639 4
    } else if (curdoc.line > 1 && Newline > 1) {  /* previous page */
	int scrollamount = (Newline > display_lines ?
				      display_lines : Newline - 1);
	Newline -= scrollamount;
d4642 4
a4645 4
	    links[0].ly -1 + scrollamount <= display_lines) {
		newdoc.link = HText_LinksInLines(HTMainText,
						 1,
						 scrollamount) - 1;
d4656 5
a4660 21
PRIVATE void handle_LYK_UP_TWO ARGS3(
    int *,	arrowup,
    int *,	old_c,
    int,	real_c)
{
    if (Newline > 1) {
	int scrollamount = (Newline > 2 ? 2 : 1);
	Newline -= scrollamount;
	if (nlinks > 0 && curdoc.link > -1) {
	    if (links[curdoc.link].ly + scrollamount <= display_lines) {
		newdoc.link = curdoc.link +
			      HText_LinksInLines(HTMainText,
						 Newline, scrollamount);
	    } else {
		*arrowup = TRUE;
	    }
	}
    } else if (*old_c != real_c) {
	*old_c = real_c;
	HTInfoMsg(ALREADY_AT_BEGIN);
    }
d4663 3
a4665 4
PRIVATE void handle_LYK_VIEW_BOOKMARK ARGS3(
    BOOLEAN *,	refresh_screen,
    int *,	old_c,
    int,	real_c)
d4667 1
a4667 1
    char *cp;
d4670 1
a4670 1
	if (*old_c != real_c)	{
d4678 2
a4679 2
     *	See if a bookmark exists.
     *	If it does replace newdoc.address with its name.
d4693 1
a4693 1
	LYforce_no_cache = TRUE;  /*force the document to be reloaded*/
d4712 2
a4713 3
PRIVATE BOOLEAN handle_LYK_VLINKS ARGS2(
    int *,	cmd,
    BOOLEAN *,	newdoc_link_is_absolute)
d4719 1
a4719 1
	 *  Already viewing visited links page, so get out.
d4726 1
a4726 1
     *	Print visited links page to file.
d4751 2
a4752 3
PUBLIC void handle_LYK_WHEREIS ARGS2(
    int,	cmd,
    BOOLEAN *,	refresh_screen)
d4755 1
a4755 1
				    HText_pageHasPrevTarget());
d4757 1
a4757 1
    int oldcur = curdoc.link; /* temporarily remember */
d4759 1
d4767 2
a4768 4
	 *  Reset prev_target to force prompting
	 *  for a new search string and to turn
	 *  off highlighting if no search string
	 *  is entered by the user.
d4772 1
a4772 1
    found = textsearch(&curdoc, prev_target, sizeof(prev_target)-1,
d4776 2
a4777 2
			 ? 1
			 : -1));
d4780 3
a4782 4
     *	Force a redraw to ensure highlighting of hits
     *	even when found on the same page, or clearing
     *	of highlighting if the default search string
     *	was erased without replacement. - FM
d4785 3
a4787 3
    ** Well let's try to avoid it at least in a few cases
    ** where it is not needed. - kw
    */
d4789 1
a4789 1
	*refresh_screen = TRUE; /* doesn't really matter */
d4797 1
a4797 1
	       links[curdoc.link].ly >= (display_lines/3)) {
d4799 4
a4802 4
    } else if ((case_sensitive && 0!=strcmp(prev_target,
					    remember_old_target)) ||
	     (!case_sensitive && 0!=strcasecomp8(prev_target,
					    remember_old_target))) {
d4811 6
a4816 7
PRIVATE void handle_LYK_digit ARGS6(
    int,	c,
    BOOLEAN *,	force_load,
    char *,	user_input_buffer,
    int *,	old_c,
    int,	real_c,
    BOOLEAN *,	try_internal GCC_UNUSED)
d4829 1
a4829 1
	 *  Follow a normal link.
d4835 4
a4838 5
	 *  For internal links, retain POST content if present.
	 *  If we are on the List Page, prevent pushing it on
	 *  the history stack.	Otherwise set try_internal to
	 *  signal that the top of the loop should attempt to
	 *  reposition directly, without calling getfile. - kw
d4849 1
a4849 1
		    HTLastConfirmCancelled(); /* reset flag */
d4852 4
a4855 2
					    (LYresubmit_posts &&
					     HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
d4888 2
a4889 2
		 *  Don't push the List Page if we follow an
		 *  internal link given by it. - kw
d4900 1
a4900 1
	     *	Free POST content if not an internal link. - kw
d4906 2
a4907 2
	 *  Might be an anchor in the same doc from a POST
	 *  form.  If so, don't free the content. -- FM
d4918 1
a4918 1
	*force_load = TRUE;  /* force MainLoop to reload */
d4923 1
a4923 1
	 *  Position on a normal link, don't follow it. - KW
d4925 1
a4925 1
	Newline = newdoc.line;
d4927 1
a4927 1
	if (Newline == curdoc.line) {
d4929 1
a4929 1
	     *	It's a link in the current page. - FM
d4934 3
a4936 4
		     *	It's the current link, and presumably
		     *	reflects a typo in the statusline entry,
		     *	so issue a statusline message for the
		     *	typo-prone users (like me 8-). - FM
d4946 1
a4946 1
		     *	It's a different link on this page,
d4953 1
a4953 1
	break;		/* nothing more to do */
d4957 1
a4957 1
	 *  Position on a page in this document. - FM
d4959 1
a4959 1
	Newline = newdoc.line;
d4961 1
a4961 1
	if (Newline == curdoc.line) {
d4963 2
a4964 3
	     *	It's the current page, so issue a
	     *	statusline message for the typo-prone
	     *	users (like me 8-). - FM
d4966 1
a4966 1
	    if (Newline <= 1) {
d4968 1
a4968 1
	    } else if (!more) {
d4992 1
a4992 1
PUBLIC void handle_LYK_CHDIR NOARGS
d5006 1
a5006 1
    if (LYgetstr(buf, VISIBLE, sizeof(buf)-1, 0) < 0 || !*buf) {
d5014 1
a5014 1
	HTSprintf0(&p, "%s%s", Home_Dir(), buf+1);
d5037 1
a5037 1
	/*if in dired, load content of other directory*/
d5039 1
a5039 1
	 && (lynx_edit_mode || (LYIsUIPage(curdoc.address, UIP_DIRED_MENU)))) {
d5041 1
a5041 1
	    char* addr = NULL;
d5079 1
a5079 1
PRIVATE int repeat_to_delta ARGS1(int, n)
d5093 1
a5093 1
PRIVATE void handle_LYK_SHIFT_LEFT ARGS2(BOOLEAN *, flag, int, count)
d5107 1
a5107 1
PRIVATE void handle_LYK_SHIFT_RIGHT ARGS2(BOOLEAN *, flag, int, count)
d5117 2
a5118 3
PRIVATE BOOLEAN handle_LYK_LINEWRAP_TOGGLE ARGS2(
    int *,	cmd,
    BOOLEAN *,	flag)
d5120 2
a5121 1
    static char *choices[] = {
d5132 2
a5133 1
    static int wrap[] = {
d5136 1
a5136 1
	12,				/* In units of 1/12 */
d5150 1
a5150 1
    c = LYChoosePopup(!LYwideLines, LYlines /2 - 2, LYcols/2-6,
d5153 4
a5156 5
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
d5172 5
a5176 5
 *  Here's where we do all the work.
 *  mainloop is basically just a big switch dependent on the users input.
 *  I have tried to offload most of the work done here to procedures to
 *  make it more modular, but this procedure still does a lot of variable
 *  manipulation.  This needs some work to make it neater. - Lou Moutilli
d5180 1
a5180 1
int mainloop NOARGS
d5182 1
a5182 1
#if defined(WIN_EX)	/* 1997/10/08 (Wed) 14:52:06 */
d5190 4
a5193 1
    int c = 0, real_c = 0, old_c = 0, pending_form_c = -1;
d5198 1
a5198 1
    CONST char *cshelpfile = NULL;
d5212 2
a5213 1
    int ch = 0, recall = 0;
d5226 2
d5229 5
a5233 5
/*  "internal" means "within the same document, with certainty".
 *  It includes a space so it cannot conflict with any (valid) "TYPE"
 *  attributes on A elements. [According to which DTD, anyway??] - kw
 */
    HTInternalLink = HTAtom_for("internal link");  /* init, used as const */
d5236 1
a5236 1
    WWW_SOURCE = HTAtom_for("www/source");  /* init, used as const */
d5239 9
a5247 9
/*
 *  curdoc.address contains the name of the file that is currently open.
 *  newdoc.address contains the name of the file that will soon be
 *		     opened if it exits.
 *  prev_target    contains the last search string the user searched for.
 *  newdoc.title   contains the link name that the user last chose to get
 *		     into the current link (file).
 */
    /* initialize some variables*/
d5271 1
a5271 1
initialize:
d5308 2
d5311 2
a5312 2
	     *	See if a bookmark page exists.	If it does,
	     *	replace newdoc.address with its name
d5314 2
a5315 2
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL &&
		 *cp != '\0' && strcmp(cp, " ")) {
d5335 1
a5335 1
	display_lines = LYlines-4;
d5337 1
a5337 1
	display_lines = LYlines-2;
d5341 2
a5342 1
	if (curdoc.style != NULL) force_load = TRUE;
d5345 2
a5346 2
	 *  If newdoc.address is different then curdoc.address then
	 *  we need to go out and find and load newdoc.address.
d5351 3
a5353 3
		force_load = FALSE;  /* done */
		if (TRACE && LYCursesON) {
		    LYHideCursor();	/* make sure cursor is down */
d5355 1
a5355 1
		    LYaddstr("\n");
d5357 17
a5373 1
		    LYrefresh();
d5375 1
a5375 1
try_again:
d5377 2
a5378 2
		 *  Push the old file onto the history stack if we
		 *  have a current doc and a new address. - FM
d5380 2
a5381 22
		if (curdoc.address && newdoc.address) {
		    /*
		     *	Don't actually push if this is a LYNXDOWNLOAD
		     *	URL, because that returns NORMAL even if it
		     *	fails due to a spoof attempt or file access
		     *	problem, and we set the newdoc structure
		     *	elements to the curdoc structure elements
		     *	under case NORMAL.  - FM
		     */
		    if (!isLYNXDOWNLOAD(newdoc.address))
		    {
			LYpush(&curdoc, ForcePush);
		    }
		} else if (!newdoc.address) {
		    /*
		     *	If newdoc.address is empty then pop a file
		     *	and load it.  - FM
		     */
		    LYhist_prev(&newdoc);
		    popped_doc = TRUE;


d5384 15
d5400 15
a5414 8
		    ** If curdoc had been reached via an internal
		    ** (fragment) link from what we now have just
		    ** popped into newdoc, then override non-caching in
		    ** all cases. - kw
		    */
		    if (curdoc.internal_link &&
			!are_phys_different(&curdoc, &newdoc)) {
			LYinternal_flag = TRUE;
a5415 24
			LYforce_no_cache = FALSE;
			try_internal = TRUE;
		    } else
#endif /* TRACK_INTERNAL_LINKS */
		    {
			/*
			 * Force a no_cache override unless
			 *  it's a bookmark file, or it has POST content
			 *  and LYresubmit_posts is set without safe also
			 *  set, and we are not going to another position
			 *  in the current document or restoring the previous
			 *  document due to a NOT_FOUND or NULLFILE return
			 *  value from getfile(). - FM
			 */
			if ((newdoc.bookmark != NULL) ||
			    (newdoc.post_data != NULL &&
			     !newdoc.safe &&
			     LYresubmit_posts &&
			     !override_LYresubmit_posts &&
				NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			    LYoverride_no_cache = FALSE;
			} else {
			    LYoverride_no_cache = TRUE;
			}
d5418 2
a5419 1
		override_LYresubmit_posts = FALSE;
d5421 12
a5432 6
		if (HEAD_request) {
		    /*
		     *	Make SURE this is an appropriate request. - FM
		     */
		    if (newdoc.address) {
			if (LYCanDoHEAD(newdoc.address) == TRUE) {
d5434 1
a5434 8
			} else if (isLYNXIMGMAP(newdoc.address)) {
			    if (LYCanDoHEAD(newdoc.address + LEN_LYNXIMGMAP) == TRUE) {
				StrAllocCopy(temp, newdoc.address + LEN_LYNXIMGMAP);
				free_address(&newdoc);
				newdoc.address = temp;
				newdoc.isHEAD = TRUE;
				temp = NULL;
			    }
a5436 2
		    try_internal = FALSE;
		    HEAD_request = FALSE;
d5438 3
d5442 25
a5466 26
		/*
		 *  If we're getting the TRACE log and it's not new,
		 *  check whether its HText structure has been dumped,
		 *  and if so, fflush() and fclose() it to ensure it's
		 *  fully updated, and then fopen() it again. - FM
		 */
		if (LYUseTraceLog == TRUE &&
		    trace_mode_flag == FALSE &&
		    LYTraceLogFP != NULL &&
		    LYIsUIPage(newdoc.address, UIP_TRACELOG)) {
		    DocAddress WWWDoc;
		    HTParentAnchor *tmpanchor;

		    WWWDoc.address = newdoc.address;
		    WWWDoc.post_data = newdoc.post_data;
		    WWWDoc.post_content_type = newdoc.post_content_type;
		    WWWDoc.bookmark = newdoc.bookmark;
		    WWWDoc.isHEAD = newdoc.isHEAD;
		    WWWDoc.safe = newdoc.safe;
		    tmpanchor = HTAnchor_findAddress(&WWWDoc);
		    if ((HText *)HTAnchor_document(tmpanchor) == NULL) {
			if (!LYReopenTracelog(&trace_mode_flag)) {
			    old_c = 0;
			    cmd = LYK_PREV_DOC;
			    goto new_cmd;
			}
d5469 1
d5471 10
a5480 10
		LYRequestTitle = newdoc.title;
		if (newdoc.bookmark)
		    LYforce_HTML_mode = TRUE;
		if (LYValidate &&
		    startfile_ok &&
		    newdoc.address && startfile && homepage &&
		    (!strcmp(newdoc.address, startfile) ||
		     !strcmp(newdoc.address, homepage))) {
		    LYPermitURL = TRUE;
		}
d5482 6
a5487 6
		/* reset these two variables here before getfile()
		 * so they will be available in partial mode
		 * (was previously implemented in case NORMAL).
		 */
		*prev_target = '\0';	/* Reset for new coming document */
		Newline = newdoc.line;	/* set for LYGetNewline() */
d5490 1
a5490 1
		psrc_first_tag = TRUE;
d5493 1
a5493 1
		textfields_need_activation = textfields_activation_option;
d5495 10
a5504 10
		FREE(LYRequestReferer);
		/*
		 *  Don't send Referer if we have to load a document again
		 *  that we got from the history stack.  We don't know
		 *  any more how we originally got to that page.  Using
		 *  a Referer based on the current HTMainText could only
		 *  be right by coincidence. - kw 1999-11-01
		 */
		if (popped_doc)
		    LYNoRefererForThis = TRUE;
d5507 26
a5532 7
		if (try_internal) {
		    if (newdoc.address &&
			isLYNXIMGMAP(newdoc.address)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			isLYNXIMGMAP(curdoc.address)) {
			try_internal = FALSE;
d5535 21
a5555 18
		if (try_internal) {
		    char *hashp = findPoundSelector(newdoc.address);
		    if (hashp) {
			HTFindPoundSelector(hashp+1);
		    }
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE; /* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    set_address(&newdoc, HTLoadedDocumentURL());
			} else {
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp); /* append fragment */
			    set_address(&newdoc, temp);
			    FREE(temp);
			}
		    }
d5557 1
a5557 15
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;
			if (isLYNXIMGMAP(HDOC(nhist-1).address))
			    cp0 = HDOC(nhist-1).address + LEN_LYNXIMGMAP;
			else
			    cp0 = HDOC(nhist-1).address;
			StrAllocCopy(temp, cp0);
			(void) trimPoundSelector(temp);
			StrAllocCat(temp, newdoc.address);
			free_address(&newdoc);
			newdoc.address = temp;
			temp = NULL;
		    }
		    getresult = getfile(&newdoc);
d5559 10
a5568 2
#else  /* TRACK_INTERNAL_LINKS */
		getresult = getfile(&newdoc);
d5572 1
a5572 1
		textinput_redrawn = FALSE; /* for sure */
d5575 1
a5575 1
		switch(getresult) {
d5577 9
a5585 1
		case NOT_FOUND:
d5587 5
a5591 2
		     *	OK! can't find the file, so it must not be around now.
		     *	Do any error logging, if appropriate.
d5593 11
a5603 4
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    if (!first_file && !LYCancelledFetch) {
d5605 3
a5607 7
			 *  Do error mail sending and/or traversal
			 *  stuff.  Note that the links[] elements may
			 *  not be valid at this point, if we did call
			 *  HTuncache_current_document!   This should
			 *  not have happened for traversal, but for
			 *  sending error mail check that HTMainText
			 *  exists for this reason. - kw
a5608 16
			if (error_logging && nhist > 0 && !popped_doc &&
			    !LYUserSpecifiedURL &&
			    HTMainText &&
			    nlinks > 0 && curdoc.link < nlinks &&
			    !isLYNXHIST(NonNull(newdoc.address)) &&
			    !isLYNXCOOKIE(NonNull(newdoc.address))) {
			    char *mail_owner = NULL;
			    if (owner_address && isMAILTO_URL(owner_address)) {
				mail_owner = owner_address + LEN_MAILTO_URL;
			    }
			    /*
			     *  Email a bad link message to the owner of
			     *  the document, or to ALERTMAIL if defined,
			     *  but NOT to lynx-dev (it is rejected in
			     *  mailmsg). - FM, kw
			     */
d5610 1
a5610 1
			    if (mail_owner)
d5612 7
a5618 7
				mailmsg(curdoc.link,
					mail_owner,
					HDOC(nhist-1).address,
					HDOC(nhist-1).title);
			}
			if (traversal) {
			    FILE *ofp;
d5620 4
a5623 5
			    if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
				if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				    perror(NOOPEN_TRAV_ERR_FILE);
				    exit_immediately(EXIT_FAILURE);
				}
a5624 15
			    if (nhist > 0) {
				fprintf(ofp,
					"%s %s\tin %s\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target,
					HDOC(nhist-1).address);
			    } else {
				fprintf(ofp,
					"%s %s\t\n",
					popped_doc ?
					newdoc.address : links[curdoc.link].lname,
					links[curdoc.link].target);
			    }
			    LYCloseOutput(ofp);
d5626 15
d5642 1
d5644 5
d5650 1
a5650 3
		     *	Fall through to do the NULL stuff and reload the
		     *	old file, unless the first file wasn't found or
		     *	has gone missing.
d5652 25
a5676 1
		    if (!nhist) {
d5678 3
a5680 1
			 *  If nhist = 0 then it must be the first file.
d5682 2
a5683 34
			exit_immediately_with_error_message(NOT_FOUND, first_file);
			return(EXIT_FAILURE);
		    }
		    /* FALLTHRU */

		case NULLFILE:
		    /*
		     *	Not supposed to return any file.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
		    free_address(&newdoc); /* to pop last doc */
		    FREE(newdoc.bookmark);
		    LYJumpFileURL = FALSE;
		    reloading = FALSE;
		    LYPermitURL = FALSE;
		    LYCancelledFetch = FALSE;
		    ForcePush = FALSE;
		    LYforce_HTML_mode = FALSE;
		    force_old_UCLYhndl_on_reload = FALSE;
		    if (traversal) {
			crawl_ok = FALSE;
			if (traversal_link_to_add) {
			    /*
			     *	It's a binary file, or the fetch attempt
			     *	failed.  Add it to TRAVERSE_REJECT_FILE
			     *	so we don't try again in this run.
			     */
			    if (!lookup_reject(traversal_link_to_add)) {
				add_to_reject_list(traversal_link_to_add);
			    }
			    FREE(traversal_link_to_add);
d5685 1
d5687 5
d5693 1
a5693 2
		     *  Make sure the first file was found and
		     *  has not gone missing.
d5695 2
a5696 1
		    if (!nhist) {
d5698 8
a5705 1
			 *  If nhist = 0 then it must be the first file.
d5707 49
a5755 20
			if (first_file && homepage &&
			   !LYSameFilename(homepage, startfile)) {
			   /*
			    *  Couldn't return to the first file but there is a
			    *  homepage we can use instead. Useful for when the
			    *  first URL causes a program to be invoked. - GL
			    *
			    *  But first make sure homepage is different from
			    *  startfile (above), then make it the same (below)
			    *  so we don't enter an infinite getfile() loop on
			    *  on failures to find the files. - FM
			    */
			   set_address(&newdoc, homepage);
			   LYFreePostData(&newdoc);
			   FREE(newdoc.bookmark);
			   StrAllocCopy(startfile, homepage);
			   newdoc.isHEAD = FALSE;
			   newdoc.safe = FALSE;
			   newdoc.internal_link = FALSE;
			   goto try_again;
d5757 1
a5757 2
			   exit_immediately_with_error_message(NULLFILE, first_file);
			   return(EXIT_FAILURE);
d5759 14
d5774 5
d5780 7
a5786 59
		   /*
		    *  If we're going to pop from history because
		    *  getfile didn't succeed, reset LYforce_no_cache
		    *  first.  This would have been done in HTAccess.c
		    *  if the request got that far, but the URL may
		    *  have been handled or rejected in getfile without
		    *  taking care of that. - kw
		    */
		    LYforce_no_cache = FALSE;
		   /*
		    *  Retrieval of a newdoc just failed, and just
		    *  going to try_again would pop the next doc
		    *  from history and try to get it without further
		    *  questions.  This may not be the right thing to do if
		    *  we have POST data, so fake a PREV_DOC key if it seems
		    *  that some prompting should be done.  This doesn't
		    *  affect the traversal logic, since with traversal
		    *  POST data can never occur. - kw
		    */
		   if (HDOC(nhist - 1).post_data &&
		       !HDOC(nhist - 1).safe) {
		       if (HText_POSTReplyLoaded((DocInfo *)&history[(nhist - 1)])) {
			   override_LYresubmit_posts = TRUE;
			   goto try_again;
		       }
		       /*  Set newdoc fields, just in case the PREV_DOC
			*  gets cancelled. - kw */
		       if (!curdoc.address) {
			   set_address(&newdoc, HTLoadedDocumentURL());
			   StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			   if (HTMainAnchor
			    && HTMainAnchor->post_data) {
			       BStrCopy(newdoc.post_data,
					HTMainAnchor->post_data);
			       StrAllocCopy(newdoc.post_content_type,
					    HTMainAnchor->post_content_type);
			   } else {
			       BStrFree(newdoc.post_data);
			   }
			   newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			   newdoc.safe = HTLoadedDocumentIsSafe();
			   newdoc.internal_link = FALSE;
		       } else {
			   copy_address(&newdoc, &curdoc);
			   StrAllocCopy(newdoc.title, curdoc.title);
			   BStrCopy(newdoc.post_data, curdoc.post_data);
			   StrAllocCopy(newdoc.post_content_type,
					curdoc.post_content_type);
			   newdoc.isHEAD = curdoc.isHEAD;
			   newdoc.safe = curdoc.safe;
			   newdoc.internal_link = curdoc.internal_link;
			   newdoc.line = curdoc.line;
			   newdoc.link = curdoc.link;
		       }
		       cmd = LYK_PREV_DOC;
		       goto new_cmd;
		    }
		    override_LYresubmit_posts = TRUE;
		    goto try_again;
d5788 14
a5801 7
		case NORMAL:
		    /*
		     *	Marvelously, we got the document!
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    turn_trace_back_on(&trace_mode_flag);
d5803 1
a5803 15
		    /*
		     *	If it's the first file and we're interactive,
		     *	check whether it's a bookmark file which was
		     *	not accessed via the -book switch. - FM
		     */
		    if (((first_file == TRUE) &&
			 (dump_output_immediately == FALSE) &&
			 !(newdoc.bookmark && *newdoc.bookmark)) &&
			((LYisLocalFile(newdoc.address) == TRUE) &&
			 !(strcmp(NonNull(HText_getTitle()),
				  BOOKMARK_TITLE))) &&
			(temp = HTParse(newdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION)) != NULL) {
			CONST char *name = wwwName(Home_Dir());
			len = strlen(name);
d5805 2
a5806 2
			if (!strncasecomp(temp, name, len) &&
			    strlen(temp) > len)
d5808 2
a5809 2
			if (!strncmp(temp, name, len) &&
			    strlen(temp) > len)
d5811 12
a5822 16
			{
			    /*
			     *	We're interactive and this might be a
			     *	bookmark file entered as a startfile
			     *	rather than invoked via -book.	Check
			     *	if it's in our bookmark file list, and
			     *	if so, reload if with the relevant
			     *	bookmark elements set. - FM
			     */
			    cp = NULL;
			    if (temp[len] == '/') {
				if (strchr(&temp[(len + 1)], '/')) {
				    HTSprintf0(&cp, ".%s", &temp[len]);
				} else {
				    StrAllocCopy(cp, &temp[(len + 1)]);
				}
d5824 11
a5834 1
				StrAllocCopy(cp, &temp[len]);
d5836 7
a5842 7
			    for (i = 0; i <= MBM_V_MAXFILES; i++) {
				if (MBM_A_subbookmark[i] &&
				    LYSameFilename(cp, MBM_A_subbookmark[i])) {
				    StrAllocCopy(BookmarkPage,
						 MBM_A_subbookmark[i]);
				    break;
				}
d5844 6
a5849 13
			    FREE(cp);
			    if (i <= MBM_V_MAXFILES) {
				FREE(temp);
				if (LYValidate) {
				    HTAlert(BOOKMARKS_DISABLED);
				    return(EXIT_FAILURE);
				}
				if ((temp = HTParse(newdoc.address, "",
				 PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION))) {
				    set_address(&newdoc, temp);
				    HTuncache_current_document();
				    free_address(&curdoc);
				    StrAllocCat(newdoc.address,
d5851 7
a5857 7
				    StrAllocCat(newdoc.address, "/");
				    StrAllocCat(newdoc.address,
					(strncmp(BookmarkPage, "./", 2) ?
							   BookmarkPage :
							(BookmarkPage + 2)));
				    StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				    StrAllocCopy(newdoc.bookmark, BookmarkPage);
d5859 2
a5860 2
				    if (curdoc.style)
					StrAllocCopy(newdoc.style, curdoc.style);
d5862 11
a5872 12
				    StrAllocCopy(startrealm, newdoc.address);
				    LYFreePostData(&newdoc);
				    newdoc.isHEAD = FALSE;
				    newdoc.safe = FALSE;
				    FREE(temp);
				    if (!strcmp(homepage, startfile))
					StrAllocCopy(homepage, newdoc.address);
				    StrAllocCopy(startfile, newdoc.address);
				    CTRACE((tfp, "Reloading as bookmarks=%s\n",
						newdoc.address));
				    goto try_again;
				}
a5874 1
			cp = NULL;
d5876 3
a5878 1
		    FREE(temp);
d5880 7
a5886 1
		    if (traversal) {
d5888 1
a5888 3
			 *  During traversal build up lists of all links
			 *  traversed.	Traversal mode is a special
			 *  feature for traversing http links in the web.
d5890 3
a5892 14
			if (traversal_link_to_add) {
			    /*
			     *	Add the address we sought to TRAVERSE_FILE.
			     */
			    if (!lookup(traversal_link_to_add))
				add_to_table(traversal_link_to_add);
			    FREE(traversal_link_to_add);
			}
			if (curdoc.address && curdoc.title &&
			    !isLYNXIMGMAP(curdoc.address))
			    /*
			     *	Add the address we got to TRAVERSE_FOUND_FILE.
			     */
			    add_to_traverse_list(curdoc.address, curdoc.title);
d5894 7
d5902 14
a5915 15
		    /*
		     *	If this was a LYNXDOWNLOAD, we still have curdoc,
		     *	not a newdoc, so reset the address, title and
		     *	positioning elements. - FM
		     */
		    if (newdoc.address && curdoc.address &&
			isLYNXDOWNLOAD(newdoc.address)) {
			copy_address(&newdoc, &curdoc);
			StrAllocCopy(newdoc.title, (curdoc.title ?
						    curdoc.title : ""));
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
			newdoc.internal_link = FALSE; /* can't be true. - kw */
		    }
d5917 14
a5930 14
		    /*
		     *	Set Newline to the saved line.	It contains the
		     *	line the user was on if s/he has been in the file
		     *	before, or it is 1 if this is a new file.
		     *
		     * We already set Newline before getfile() and probably
		     * update it explicitly if popping from the history stack
		     * via LYpop() or LYpop_num() within getfile() cycle.
		     *
		     * In partial mode, Newline was probably updated in
		     * LYMainLoop_pageDisplay() if user scrolled
		     * the document while loading.
		     * Incremental loading stage already closed in HT*Copy().
		     */
d5932 2
a5933 2
		    /* Newline = newdoc.line; */
		    display_partial = FALSE; /* for sure, LYNXfoo:/ may be a problem */
d5935 5
a5939 5
		    /* Should not be needed either if we remove
		     * "DISP_PARTIAL" from LYHistory.c, but lets leave it
		     * as an important comment for now.
		     */
		    Newline = newdoc.line;
d5942 6
a5947 7
		    /*
		     *	If we are going to a target line or
		     *	the first page of a popped document,
		     *	override any www_search line result.
		     */
		    if (Newline > 1 || popped_doc == TRUE)
			 www_search_result = -1;
d5949 7
a5955 7
		    /*
		     *	Make sure curdoc.line will not be equal
		     *	to Newline, so we get a redraw.
		     */
		    curdoc.line = -1;
		    break;
		}  /* end switch */
d5959 1
a5959 1
		    LYSleepAlert(); /* allow me to look at the results */
d5964 1
a5964 1
	     *	Set the files the same.
d5973 1
a5973 1
		style_readFromFile (curdoc.style);
d5979 2
a5980 2
	     *	Set the remaining document elements and add to
	     *	the visited links list. - FM
d5986 2
a5987 2
		if ( (LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
			&& !HText_getOwner() )
d6003 5
a6007 6

	   /*
	    *  Reset WWW present mode so that if we were getting
	    *  the source, we get rendered HTML from now on.
	    */
	   HTOutputFormat = WWW_PRESENT;
d6009 1
a6009 1
	   psrc_view = FALSE;
d6012 1
a6012 1
	   HTMLSetCharacterHandling(current_char_set);	/* restore, for sure? */
d6014 14
a6027 16
	   /*
	    *  Reset all of the other relevant flags. - FM
	    */
	   LYUserSpecifiedURL = FALSE;	/* only set for goto's and jumps's */
	   LYJumpFileURL = FALSE;	/* only set for jump's */
	   LYNoRefererForThis = FALSE;	/* always reset on return here */
	   reloading = FALSE;		/* set for RELOAD and NOCACHE keys */
	   HEAD_request = FALSE;	/* only set for HEAD requests */
	   LYPermitURL = FALSE;		/* only for LYValidate or check_realm */
	   ForcePush = FALSE;		/* only set for some PRINT requests. */
	   LYforce_HTML_mode = FALSE;
	   force_old_UCLYhndl_on_reload = FALSE;
	   popped_doc = FALSE;
	   pending_form_c = -1;

	} /* end if (LYforce_no_cache || force_load || are_different(...)) */
d6029 2
d6034 2
a6035 2
	    } else {
		print_wwwfile_to_fd(stdout, FALSE);
d6037 1
a6037 1
	    return(EXIT_SUCCESS);
d6041 2
a6042 2
	 *  If the recent_sizechange variable is set to TRUE
	 *  then the window size changed recently.
d6046 13
a6058 12
	     *  First we need to make sure the display library - curses, slang,
	     *  whatever - gets notified about the change, and gets a chance
	     *  to update external structures appropriately.  Hopefully the
	     *  stop_curses()/start_curses() sequence achieves this, at least
	     *  if the display library has a way to get the new screen size
	     *  from the OS.
	     *  However, at least for ncurses, the update of the internal
	     *  structures will come still too late - the changed screen
	     *  size is detected in doupdate(), which would only be called
	     *  (indirectly through the HText_pageDisplay below) after the
	     *  WINDOW structures are already filled based on the old size.
	     *  So we notify the ncurses library directly here. - kw
d6064 1
a6064 1
#if 0 /* defined(PDCURSES) && defined(HAVE_XCURSES) */
d6075 1
a6075 1
	    refresh_screen = TRUE; /* to force a redraw */
d6080 1
a6080 1
		display_lines = LYlines-4;
d6082 1
a6082 1
		display_lines = LYlines-2;
d6087 5
a6091 6
	     /*
	      *  This was a WWW search, set the line
	      *  to the result of the search.
	      */
	     Newline = www_search_result;
	     www_search_result = -1;  /* reset */
d6096 1
a6096 1
	     *	We can never again have the first file.
d6101 2
a6102 3
	     *	Set the startrealm, and deal as best we can
	     *	with preserving forced HTML mode for a local
	     *	startfile. - FM
d6105 1
a6105 1
			   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
d6112 1
a6112 1
				     PARSE_PATH+PARSE_PUNCTUATION))) {
d6121 10
a6130 11
			 *  We forced HTML for a local startfile which
			 *  is not a bookmark file and has a path of at
			 *  least two letters.	If it doesn't have a
			 *  suffix mapped to text/html, we'll set the
			 *  entire path (including the lead slash) as a
			 *  "suffix" mapped to text/html to ensure it is
			 *  always treated as an HTML source file.  We
			 *  are counting on a tail match to this full path
			 *  for some other URL fetched during the session
			 *  having too low a probability to worry about,
			 *  but it could happen. - FM
d6139 1
a6139 1
			*(cp+1) = '\0';
d6148 1
a6148 1
		 *  Set up the crawl output stuff.
d6150 1
a6150 1
		if (curdoc.address && !lookup(curdoc.address)) {
d6156 1
a6156 1
		 *  Set up the traversal_host comparison string.
d6165 1
a6165 1
				   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
d6178 2
a6179 3
		 *  If homepage was not equated to startfile,
		 *  make the homepage URL the first goto
		 *  entry. - FM
d6184 3
a6186 4
		 *  If we are not starting up with startfile
		 *  (e.g., had -book), or if we are using the
		 *  startfile and it has no POST content, make
		 *  the startfile URL a goto entry. - FM
a6198 1

d6208 1
a6208 1
	   if (HTcan_reparse_document()) {
d6211 1
a6211 1
	   } else {
d6216 5
a6220 5
			/*  currently disabled ***
		HTUserMsg(gettext("Reparsing document under current settings..."));
		cmd = LYK_RELOAD;
		goto new_cmd;
			*/
d6225 2
a6226 2
	    from_source_cache = FALSE; /* reset */
	    curdoc.line = -1 ;  /* so curdoc.line != Newline, see below */
d6231 3
a6233 3
	 *  If the curdoc.line is different than Newline then there must
	 *  have been a change since last update.  Run HText_pageDisplay()
	 *  create a fresh screen of text out.
d6235 2
a6236 2
	 *  If we got new HTMainText go this way.
	 *  All display_partial calls ends here for final redraw.
d6238 1
a6238 1
	if (curdoc.line != Newline) {
d6245 1
a6245 1
	    HText_pageDisplay(Newline, prev_target);
d6249 1
a6249 1
	      showtags(tagged);
d6253 1
a6253 1
	     *  If more equals TRUE, then there is more info below this page.
d6255 6
a6260 2
	    more = HText_canScrollDown();
	    curdoc.line = Newline = HText_getTopOfScreen()+1;
d6264 2
a6265 2
		 *  If we don't yet have a title, try to get it,
		 *  or set to that for newdoc.title. - FM
d6275 2
a6276 2
	     *	If the request is to highlight a link which is counted
	     *  from the start of document, correct the link number:
d6287 1
a6287 2
		 *  arrowup is set if we just came up from
		 *  a page below.
d6297 6
a6302 6
		     *	We may have popped a doc (possibly in local_dired)
		     *	which didn't have any links when it was pushed, but
		     *	does have links now (e.g., a file was created).
		     *  Code below assumes that curdoc.link is valid and
		     *  that (curdoc.link==-1) only occurs if (nlinks==0)
		     *  is true. - KW
d6308 1
a6308 1
	    show_help = FALSE; /* reset */
d6311 3
a6313 1
	    curdoc.line = Newline; /* set */
d6317 1
a6317 1
	 *  Refresh the screen if necessary.
d6329 1
a6329 1
	   HText_pageDisplay(Newline, prev_target);
d6337 1
a6337 1
	     *  If more equals TRUE, then there is more info below this page.
d6339 1
a6339 1
	    more = HText_canScrollDown();
d6342 4
a6345 6
	     *  Adjust curdoc.link as above; nlinks may have changed,
	     *  if the refresh_screen flag was set as a result of
	     *  a size change.
	     *  Code below assumes that curdoc.link is valid and
	     *  that (curdoc.link==-1) only occurs if (nlinks==0)
	     *  is true. - kw
d6354 1
a6354 1
		noviceline(more);  /* print help message */
d6373 1
a6373 1
#if defined(WIN_EX)			/* 1997/10/08 (Wed) 14:52:06 */
d6380 1
a6380 1
	       if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
d6382 1
a6382 1
		    switch(links[curdoc.link].l_form->type) {
d6413 1
a6413 1
	       }
d6431 1
a6431 1
	    if (strlen(curdoc.address) < sizeof(temp_buff)-1) {
d6443 1
a6443 1
	 *  Report unread or new mail, if appropriate.
d6449 2
a6450 3
	 *  If help is not on the screen,
	 *  then put a message on the screen
	 *  to tell the user other misc info.
d6453 3
a6455 3
	   show_main_statusline(links[curdoc.link],
				(curlink_is_editable && textinput_activated) ?
				FOR_INPUT : FOR_PANEL);
d6457 1
a6457 1
	   show_help = FALSE;
d6461 3
a6463 4
	     /*
	      *  Highlight current link, unless it is an active
	      *  text input field.
	      */
d6475 2
a6476 2
	     *	Don't go interactively into forms,
	     *	or accept keystrokes from the user
d6481 1
a6481 1
		sprintf(cfile,"lnk%05d.dat",ccount);
d6483 1
a6483 1
		sprintf(cfile,"lnk%08d.dat",ccount);
d6485 3
a6487 3
		ccount = ccount + 1;
		if ((cfp = LYNewTxtFile(cfile))  != NULL) {
		    print_crawl_to_fd(cfp,curdoc.address,curdoc.title);
d6492 1
d6494 5
a6498 4
		    if (dump_output_immediately)
			fprintf(stderr,
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    else
d6500 1
a6500 2
			printf(
			gettext("Fatal error - could not open output file %s\n"),cfile);
d6504 1
a6504 1
		    return(EXIT_FAILURE);
d6509 1
a6509 1
	     *	Normal, non-traversal handling.
a6510 1

d6518 1
a6518 1
		     *  Replace novice lines if in NOVICE_MODE.
d6520 1
a6520 1
		    if (user_mode==NOVICE_MODE) {
d6524 2
a6525 2
				     &newdoc, &refresh_screen,
				     use_last_tfpos, FALSE);
d6535 1
a6535 1
		c = (real_c==LKC_DONE) ? DO_NOTHING : LKC_TO_C(real_c);
d6540 1
a6540 1
		    LKC_TO_LAC(keymap,real_c) != LYK_CHANGE_LINK) {
d6554 1
a6554 1
			   (((LKC_TO_LAC(keymap,real_c) == LYK_NEXT_LINK ||
d6556 1
a6556 1
			      LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE ||
d6558 5
a6562 5
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_NEXT_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_DOWN_LINK) &&
			     ((curdoc.link < nlinks-1 &&
			       links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE
d6564 5
a6568 4
				   links[curdoc.link+1].l_form->number) &&
			       strcmp(links[curdoc.link].l_form->name,
				      links[curdoc.link+1].l_form->name) == 0) ||
			      (curdoc.link == nlinks-1 && more &&
d6570 3
a6572 3
			    ((LKC_TO_LAC(keymap,real_c) == LYK_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_LPOS_PREV_LINK ||
			      LKC_TO_LAC(keymap,real_c) == LYK_UP_LINK) &&
d6574 2
a6575 2
			       links[curdoc.link-1].type == WWW_FORM_LINK_TYPE  &&
			       links[curdoc.link-1].l_form->type == F_TEXTAREA_TYPE
d6577 1
a6577 1
				   links[curdoc.link-1].l_form->number) &&
d6579 3
a6581 3
				      links[curdoc.link-1].l_form->name) == 0) ||
			      (curdoc.link == 0 && curdoc.line > 1 &&
			       HText_TAHasMoreLines(curdoc.link, -1)))))) {
d6585 1
a6585 1
			LKC_TO_LAC(keymap,real_c) == LYK_ACTIVATE)
d6594 33
a6626 31
		    /*
		     *  If on the bottom line of a TEXTAREA, and the user hit
		     *  the ENTER key, we add a new line/anchor automatically,
		     *  positioning the cursor on it.
		     *
		     *  If at the bottom of the screen, we effectively perform
		     *  an LYK_DOWN_HALF-like operation, then move down to the
		     *  new line we just added.  --KED  02/14/99
		     *
		     *  [There is some redundancy and non-standard indentation
		     *   in the monster-if() below.  This is intentional ... to
		     *   try and improve the "readability" (such as it is).
		     *   Caveat emptor to anyone trying to change it.]
		     */
		    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].l_form->type == F_TEXTAREA_TYPE) &&
			((curdoc.link == nlinks-1 &&
			  !(more && HText_TAHasMoreLines(curdoc.link, 1)))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  !(links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  ((links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].l_form->type == F_TEXTAREA_TYPE)
			    &&
			    ((links[curdoc.link].l_form->number	       !=
				      links[curdoc.link+1].l_form->number) ||
			     (strcmp (links[curdoc.link].l_form->name,
				      links[curdoc.link+1].l_form->name) != 0)))))) {
d6628 1
a6628 1
			HText_ExpandTextarea (&links[curdoc.link], 1);
d6630 6
a6635 8
			if (links[curdoc.link].ly < display_lines) {
			    refresh_screen = TRUE;

			} else {

			    Newline += (display_lines/2);
			    if (nlinks > 0 && curdoc.link > -1 &&
				links[curdoc.link].ly > display_lines/2) {
d6637 3
a6639 1
				    for (i = 0; links[i].ly <= (display_lines/2); i++)
d6642 1
a6643 1
			}
d6645 3
a6647 3
			if (textfields_need_activation) {
			    textinput_activated = TRUE;
			    textfields_need_activation = textfields_activation_option;
d6649 1
a6649 1
			    textinput_redrawn = TRUE;
d6651 1
a6651 1
			};
d6654 1
a6654 1
		   }
d6657 9
a6665 9
		    /*
		     *	Make return in input field (if it was returned
		     *  by change_form_link) act as LYK_NEXT_LINK,
		     *  independent of what key (if any) is mapped to
		     *  LYK_NEXT_LINK. - kw
		     */
		    c = LAC_TO_LKC0(LYK_NEXT_LINK);
		    break;
		default:
d6667 3
a6669 3
		    if (old_c != c && old_c != real_c && c != real_c)
			real_c = c;
		}
d6673 1
a6673 1
		/*draw the text entry, but don't activate it*/
d6676 2
a6677 2
				    &newdoc, &refresh_screen,
				    use_last_tfpos, FALSE, TRUE);
d6680 2
a6681 2
			     ((links[curdoc.link].lx > 0) ?
			      (links[curdoc.link].lx - 1) : 0));
d6688 2
a6689 3
		 *  Get a keystroke from the user.
		 *  Save the last keystroke to avoid
		 *  redundant error reporting.
d6691 1
a6691 1
		real_c = c = LYgetch(); /* get user input */
d6698 1
a6698 1
		if (c == 3) {		/* ^C */
d6700 2
a6701 2
		     *	This shouldn't happen.	We'll try to
		     *	deal with whatever bug caused it. - FM
d6711 8
a6718 8
		     *  If ESC + <key> was read (and not recognized as a
		     *  terminal escape sequence for another key), ignore
		     *  the ESC modifier and act on <key> only if the line
		     *  editor binding would have passed the same ESC-modified
		     *  lynxkeycode back to us if it had been pressed in a
		     *  text input field.  Otherwise set interesting part
		     *  so that it will map to 0, to prevent that ESC + <key>
		     *  acts like <key>, which might be unexpected. - kw
d6740 1
a6740 1
new_keyboard_input:
d6742 2
a6743 2
	 *  A goto point for new input without going
	 *  back through the getch() loop.
d6748 2
a6749 2
	} /* traversal */

d6755 1
a6755 1
	cmd = LKC_TO_LAC(keymap,c);  /* adds 1 to map EOF to 0 */
d6758 2
a6759 2
	if (lynx_edit_mode && !no_dired_support && LKC_TO_LAC(key_override,c))
	  cmd = LKC_TO_LAC(key_override,c);
d6764 5
a6768 4
new_cmd:  /*
	   *  A goto point for new input without going
	   *  back through the getch() loop.
	   */
d6776 1
a6776 1
	switch(cmd) {
d6780 1
a6780 1
	case 0: /* unmapped character */
d6795 1
a6795 1
	    } else if (more) {
d6815 1
a6815 1
	     *	No network transmission to interrupt - 'til we multithread.
d6820 10
a6829 10
	     c = '\0';
	     /* FALLTHRU */
	case LYK_1: /* FALLTHRU */
	case LYK_2: /* FALLTHRU */
	case LYK_3: /* FALLTHRU */
	case LYK_4: /* FALLTHRU */
	case LYK_5: /* FALLTHRU */
	case LYK_6: /* FALLTHRU */
	case LYK_7: /* FALLTHRU */
	case LYK_8: /* FALLTHRU */
d6835 1
a6835 1
	case LYK_SOURCE:  /* toggle view source mode */
d6850 1
a6850 1
	case LYK_RELOAD:  /* control-R to reload and refresh */
d6872 1
a6872 1
		return(EXIT_SUCCESS);
d6875 2
a6876 2
	case LYK_ABORT:		/* don't ask the user about quitting */
	    return(EXIT_SUCCESS);
d6886 1
a6886 1
	case  LYK_UP_TWO:
d6890 1
a6890 1
	case  LYK_DOWN_TWO:
d6894 1
a6894 1
	case  LYK_UP_HALF:
d6898 1
a6898 1
	case  LYK_DOWN_HALF:
d6934 1
a6934 1
	    if (no_goto && !LYValidate) { /*  Go to not allowed. - FM */
d6950 3
a6952 2
		    s++; e--;
		    if (!strncasecomp((const char *) s,"URL:", 4))
d6962 1
a6962 1
		buf = (char*)malloc(len);
d6998 1
a6998 1
		switch(last_kcode) {
d7013 1
a7013 1
	    lynx_start_title_color ();
d7015 1
a7015 1
	    lynx_stop_title_color ();
d7026 3
a7028 3
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
d7036 3
a7038 3
	    if (i >= 1 && Newline != i) {
		Newline = i;		/* go to end of file */
		arrowup = TRUE;		/* position on last link */
d7109 1
a7109 1
		return(EXIT_SUCCESS);
d7119 1
a7119 1
	case LYK_NOCACHE: /* Force submission of form or link with no-cache */
d7126 6
a7131 1
	    switch (handle_LYK_ACTIVATE(&c, cmd, &try_internal, &refresh_screen, &force_load, real_cmd)) {
d7138 1
d7147 1
a7147 1
	case LYK_ECGOTO:	/* edit current URL and go to to it	*/
d7156 2
a7157 2
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
d7170 1
a7170 1
	case LYK_INDEX:		/* index file */
d7251 1
a7251 1
	case LYK_EDIT_TEXTAREA: /* use external editor on a TEXTAREA - KED */
d7263 1
a7263 1
	case LYK_PRINT:		/* print the file */
d7279 1
a7279 1
	case LYK_VLINKS:  /* list links visited during the current session */
d7284 1
a7284 1
	case LYK_TOOLBAR:  /* go to Toolbar or Banner in current document */
d7289 1
a7289 1
	case LYK_DIRED_MENU:  /* provide full file management menu */
d7292 1
a7292 1
#endif /* DIRED_SUPPORT || VMS*/
d7311 1
a7311 1
	case LYK_SHELL:		/* (!) shell escape */
d7325 1
a7325 1
	  case LYK_UPLOAD:
d7368 4
a7371 4
				    &FirstURLRecall, &URLNum, &URLTotal, &ch,
				    &old_c, real_c)) {
		if (do_check_recall (ch, user_input_buffer, &temp, URLTotal,
				 &URLNum, recall, &FirstURLRecall))
d7399 1
a7399 1
	} /* end of BIG switch */
d7403 1
a7403 3
PRIVATE int are_different ARGS2(
	DocInfo *,	doc1,
	DocInfo *,	doc2)
d7408 1
a7408 1
     *	Do we have two addresses?
d7414 1
a7414 1
     *	Do they differ in the type of request?
d7420 2
a7421 3
     *	See if the addresses are different, making sure
     *	we're not tripped up by multiple anchors in the
     *	the same document from a POST form. -- FM
d7426 1
a7426 1
     *	Are the base addresses different?
d7431 1
a7431 1
	return(TRUE);
d7437 1
a7437 1
     *	Do the docs have different contents?
d7442 1
a7442 1
		return(TRUE);
d7444 1
a7444 1
	    return(TRUE);
d7446 1
a7446 1
	return(TRUE);
d7449 1
a7449 1
     *	We'll assume the two documents in fact are the same.
d7451 1
a7451 1
    return(FALSE);
d7458 1
a7458 3
PRIVATE int are_phys_different ARGS2(
	DocInfo *,	doc1,
	DocInfo *,	doc2)
d7463 1
a7463 1
     *	Do we have two addresses?
d7469 1
a7469 1
     *	Do they differ in the type of request?
d7487 1
a7487 1
	return(FALSE);
d7490 2
a7491 3
     *	See if the addresses are different, making sure
     *	we're not tripped up by multiple anchors in the
     *	the same document from a POST form. -- FM
d7496 1
a7496 1
     *	Are the base addresses different?
d7501 1
a7501 1
	return(TRUE);
d7507 1
a7507 1
     *	Do the docs have different contents?
d7512 1
a7512 1
		return(TRUE);
d7514 1
a7514 1
	    return(TRUE);
d7516 1
a7516 1
	return(TRUE);
d7519 1
a7519 1
     *	We'll assume the two documents in fact are the same.
d7521 1
a7521 1
    return(FALSE);
d7526 1
a7526 1
 *  Utility for freeing the list of goto URLs. - FM
d7529 1
a7529 1
PRIVATE void HTGotoURLs_free NOARGS
d7531 2
a7532 10
    char *url;
    HTList *cur = Goto_URLs;

    if (cur != 0) {
	while (NULL != (url = (char *)HTList_nextObject(cur))) {
	    FREE(url);
	}
	HTList_delete(Goto_URLs);
	Goto_URLs = NULL;
    }
d7537 2
a7538 2
 *  Utility for listing Goto URLs, making any
 *  repeated URLs the most current in the list. - FM
d7540 1
a7540 2
PUBLIC void HTAddGotoURL ARGS1(
	char *,		url)
d7542 1
a7542 1
    char *new = NULL;
d7546 1
a7546 1
    if (!(url && *url))
d7550 1
a7550 1
    StrAllocCopy(new, url);
d7557 1
a7557 1
	HTList_addObject(Goto_URLs, new);
d7562 2
a7563 2
    while (NULL != (old = (char *)HTList_nextObject(cur))) {
	if (!strcmp(old, new)) {
d7569 1
a7569 1
    HTList_addObject(Goto_URLs, new);
d7575 2
a7576 3
 *  When help is not on the screen,
 *  put a message on the screen
 *  to tell the user other misc info.
d7578 2
a7579 3
PRIVATE void show_main_statusline ARGS2(
    CONST LinkInfo,	curlink,
    int,		for_what)
d7582 1
a7582 1
     *	Make sure form novice lines are replaced.
d7585 1
a7585 1
	noviceline(more);
d7590 1
a7590 1
	 *  Currently displaying HTML source.
d7594 4
a7597 4
    /*
     *	If we are in forms mode then explicitly
     *	tell the user what each kind of link is.
     */
d7617 1
a7617 1
	 *  Let them know if it's an index -- very rare.
d7620 3
a7622 2
	    char *indx = gettext("-index-");
	    LYmove(LYlines-1, LYcols - strlen(indx) - 1);
d7630 1
a7630 1
	 *  Show the URL or, for some internal links, the fragment
d7640 2
a7641 2
	status_link(cp, more, is_www_index);
    } else if (is_www_index && more) {
d7651 1
a7651 1
    } else if (more) {
d7671 3
a7673 3
 *  Public function for redrawing the statusline appropriate for the
 *  selected link.  It should only be called at times when curdoc.link,
 *  nlinks, and the links[] array are valid. - kw
d7675 1
a7675 2
PUBLIC void repaint_main_statusline ARGS1(
    int,	for_what)
d7681 1
a7681 2
PRIVATE void form_noviceline ARGS1(
    int,	disabled)
d7683 2
a7684 1
    LYmove(LYlines-2,0); LYclrtoeol();
d7688 2
a7689 1
    LYmove(LYlines-1,0); LYclrtoeol();
d7699 1
d7716 2
a7717 3
PRIVATE void exit_immediately_with_error_message ARGS2(
	int,		state,
	BOOLEAN,	first_file)
d7727 1
a7727 2
    if (state == NOT_FOUND)
    {
d7731 4
a7734 4
		   /*
		    * hack: if we fail in HTAccess.c
		    * avoid duplicating URL, oh.
		    */
d7736 1
a7736 1
							       "" : startfile);
d7739 1
a7739 2
    if (state == NULLFILE)
    {
d7757 1
a7757 1
	SetOutputMode( O_TEXT );
d7759 1
a7759 1
	SetOutputMode( O_BINARY );
d7770 3
a7772 5

PRIVATE void status_link ARGS3(
	char *,		curlink_name,
	BOOLEAN,	show_more,
	BOOLEAN,	show_indx)
d7774 1
a7774 1
#define MAX_STATUS (LYcols - 2)
d7783 1
a7783 1
		(int)(sizeof(format) - 2),
d7789 1
a7789 1
		(int)(sizeof(format) - prefix - 2),
d7808 1
a7808 2
	     *  Scan to find the final leaf of the URL.
	     *  Ignore trailing '/'.
d7812 1
a7812 2
		 cut_to_pos--)
		 ;
d7814 1
a7814 1
	     *  Jump back to the next leaf to remove.
d7818 8
a7825 7
		 || (prefix + cut_from_pos + 4 + (length - cut_to_pos) >= MAX_STATUS));
		 cut_from_pos--)
		 ;
	    /*
	     *  Replace some leaves to '...', if possible, and put the
	     *  final leaf at the end. We assume that one can recognize
	     *  the link from at least MIN_STATUS characters.
d7834 1
a7834 1
	    CTRACE((tfp,"lastline = %s\n",buf)); /* don't forget to erase me */
d7836 1
a7836 1
	} else {	/* show (possibly truncated) url */
d7842 1
a7842 2
PUBLIC char*
LYDownLoadAddress NOARGS
d7844 1
a7844 2
    char *s = newdoc.address ? newdoc.address : "";
    return s;
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d5210 2
a5211 2
    int ch, recall;
    int URLTotal;
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a40 1
#include <GridText.h>
a79 1
#ifdef SH_EX	/* 1999/05/25 (Tue) 11:12:05 */
a85 3
#else
    strcpy(buff, p);
#endif
d156 3
d172 1
a172 1
PRIVATE void show_main_statusline PARAMS((CONST linkstruct curlink, int for_what));
d174 1
a174 1
PRIVATE int are_different PARAMS((document *doc1, document *doc2));
d177 1
a177 1
PRIVATE int are_phys_different PARAMS((document *doc1, document *doc2));
d204 2
a205 2
PRIVATE document newdoc;
PRIVATE document curdoc;
d218 1
a218 1
    /*must be public since used in highlight(..)*/
d227 3
a229 10
    FREE(newdoc.title);
    FREE(newdoc.address);
    FREE(newdoc.post_data);
    FREE(newdoc.post_content_type);
    FREE(newdoc.bookmark);
    FREE(curdoc.title);
    FREE(curdoc.address);
    FREE(curdoc.post_data);
    FREE(curdoc.post_content_type);
    FREE(curdoc.bookmark);
d395 3
a397 1
#ifdef SOURCE_CACHE
d399 1
a399 8
 * To reparse current html document under the different settings we call
 * reparse_document() within mainloop refresh cycle, it relies upon 'curdoc'.
 *
 * From the other hand, regular requests for new document go to getfile()
 * and rely upon 'newdoc'.
 *
 * To work around newdoc.line/curdoc.line/www_search_target/Newline message
 * the following flag is introduced:
a400 2
PRIVATE BOOLEAN from_source_cache = FALSE;

d412 1
a412 1
#endif /* SOURCE_CACHE */
d421 2
a422 3
#ifdef SOURCE_CACHE
    if (HTcan_reparse_document()) {
	reparse_document();
d431 32
d465 2
a466 2
 * LYMainLoop.c PRIVATE variables.
 * Perhaps, this could adhere more logic from mainloop(), in the future.
d468 1
a468 1
PUBLIC void LYMainLoop_pageDisplay ARGS1(
d471 10
a480 2
#ifdef DISP_PARTIAL
#ifdef SOURCE_CACHE
d489 20
a508 19
    /*
     * Disable display_partial if requested URL has #fragment and we are not
     * popped from the history stack so can't calculate correct newline
     * position for fragment.  Otherwise user got the new document from the
     * first page and was moved to #fragment later after download completed,
     * but only if s/he did not mess screen up by scrolling before...  So fall
     * down to old behavior here ... until we rewrite HTFindPoundSelector()
     */
    if (display_partial && newdoc.line == 1 && strchr(newdoc.address, '#')) {
	display_partial = FALSE; /* restrict for this document */
	return;			/* no repaint */
    }

    /*
     *  Override Newline with a new value if user
     *  scrolled the document while loading (in LYUtils.c).
     */
#endif /* DISP_PARTIAL */
    Newline = line_num;
d511 1
d513 1
d523 1
a523 1
	    highlight(OFF, curdoc.link, prev_target);
d567 16
a582 16
	{ "file:",		&no_file_url },
	{ "file:",		&no_goto_file },
	{ "lynxexec:",		&no_goto_lynxexec },
	{ "lynxprog:",		&no_goto_lynxprog },
	{ "lynxcgi:",		&no_goto_lynxcgi },
	{ "cso:",		&no_goto_cso },
	{ "finger:",		&no_goto_finger },
	{ "ftp:",		&no_goto_ftp },
	{ "gopher:",		&no_goto_gopher },
	{ "http:",		&no_goto_http },
	{ "https:",		&no_goto_https },
	{ "mailto:",		&no_goto_mailto },
	{ "rlogin:",		&no_goto_rlogin },
	{ "telnet:",		&no_goto_telnet },
	{ "tn3270:",		&no_goto_tn3270 },
	{ "wais:",		&no_goto_wais },
d584 1
a584 1
	{ "bibp:",		&no_goto_bibp },
d587 3
a589 3
	{ "news:",		&no_goto_news },
	{ "nntp:",		&no_goto_nntp },
	{ "snews:",		&no_goto_snews },
d592 2
a593 2
	{ "lynxexec:",		&local_exec_on_local_files },
	{ "lynxprog:",		&local_exec_on_local_files },
d595 7
a601 7
	{ "LYNXCFG:",		&no_goto_configinfo },
	{ "LYNXCOMPILEOPTS:",	&no_goto_configinfo },
	{ "LYNXCOOKIE:",	&always },
	{ "LYNXDIRED:",		&always },
	{ "LYNXDOWNLOAD:",	&always },
	{ "LYNXOPTIONS:",	&always },
	{ "LYNXPRINT:",		&always },
d613 2
a620 1
	LYFillLocalFileURL(old_user_input, "file://localhost");
d637 2
a638 2
		   strncmp(user_input_buffer, "http:", 5) &&
		   strncmp(user_input_buffer, "https:", 6)) {
d642 1
a642 1
	    StrAllocCopy(newdoc.address, user_input_buffer);
d653 1
a653 2
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
a688 1
	char last_2, last_1, last;
a690 5

	    last_2 = user_input_buffer[len - 3];
	    last_1 = user_input_buffer[len - 2];
	    last = user_input_buffer[len - 1];

d692 3
a694 4
	     && last_2 == '/'
	     && isalpha(last_1)
	     && last == ':')
		LYAddHtmlSep0(user_input_buffer);
d697 9
a705 9
	    if (isalpha(UCH(user_input_buffer[0]))) {
		LYAddHtmlSep0(user_input_buffer);
	    } else {
		HTUserMsg2(WWW_ILLEGAL_URL_MESSAGE, user_input_buffer);
		LYstrncpy(user_input_buffer, *old_user_input, MAX_LINE - 1);
		FREE(*old_user_input);
		ret = FALSE;
		break;
	    }
d821 1
a821 2
    StrAllocCopy(newdoc.address, curdoc.address);
    FREE(curdoc.address);
d845 1
d847 2
a848 2
		if (links[i].hightext)
		    cx += strlen(links[i].hightext)/2;
d887 1
a887 1
	    if (strncmp(links[curdoc.link].lname, "LYNXIMGMAP:", 11)) {
d893 1
a893 1
					 links[curdoc.link].lname + 11,
d921 1
a921 1
	    if (strncmp(traversal_link_to_add, "LYNXIMGMAP:", 11))
d965 2
a966 3
     && curdoc.post_data
     && history[nhist - 1].post_data
     && !strcmp(curdoc.post_data, history[nhist - 1].post_data)
d968 3
a970 3
	 char *text = strncmp(history[nhist - 1].address, "LYNXIMGMAP:", 11)
		     ? history[nhist - 1].address
		     : history[nhist - 1].address + 11;
d1005 1
a1005 1
		F_TEXTLIKE(links[curdoc.link].form->type)) {
d1017 3
a1019 3
	    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].form->type ==
d1024 1
a1024 1
		if (links[curdoc.link].form->disabled == YES) {
d1033 2
a1034 2
		if (!links[curdoc.link].form->submit_action ||
		    *links[curdoc.link].form->submit_action
d1046 1
a1046 1
		if (links[curdoc.link].form->submit_method
d1059 1
a1059 3
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "file:", 5)) {
d1070 1
a1070 3
		if (!strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXCOOKIE:", 11) ||
d1073 1
a1073 3
		    (!(strncasecomp(
			    links[curdoc.link].form->submit_action,
				   "LYNXDIRED:", 10)) &&
d1076 1
a1076 1
			(links[curdoc.link].form->submit_action + 10),
d1080 1
a1080 3
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXDIRED:", 10) ||
d1083 8
a1090 21
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXDOWNLOAD:", 13) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXHIST:", 9) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXKEYMAP:", 11) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXIMGMAP:", 11) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "LYNXPRINT:", 10) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "lynxexec:", 9) ||
		    !strncasecomp(
			    links[curdoc.link].form->submit_action,
				  "lynxprog:", 9)) {
d1093 1
a1093 1
				links[curdoc.link].form->submit_action));
d1104 1
a1104 1
		if (links[curdoc.link].form->submit_enctype) {
d1106 1
a1106 1
			     links[curdoc.link].form->submit_enctype,
d1120 1
a1120 2
		if (no_filereferer == TRUE &&
		    !strncmp(curdoc.address, "file:", 5)) {
d1123 1
a1123 2
		if (links[curdoc.link].form->submit_method
			     != URL_MAIL_METHOD) {
d1125 1
a1125 1
				 links[curdoc.link].hightext);
d1128 1
d1135 6
a1140 7

	    if (F_TEXTLIKE(links[curdoc.link].form->type)) {
		show_formlink_statusline(links[curdoc.link].form,
					 (real_cmd==LYK_NOCACHE ||
					  real_cmd==LYK_DOWNLOAD ||
					  real_cmd==LYK_HEAD ||
					  (real_cmd==LYK_SUBMIT &&
d1143 1
a1143 1
		if (user_mode==NOVICE_MODE &&
d1145 2
a1146 2
		    (real_cmd==LYK_ACTIVATE || real_cmd==LYK_SUBMIT)) {
			form_noviceline(links[curdoc.link].form->disabled);
d1150 1
a1150 1
	    *c = change_form_link(&links[curdoc.link],
a1151 2
				 links[curdoc.link].form->name,
				 links[curdoc.link].form->value,
d1153 4
a1156 4
				 (BOOLEAN)(real_cmd==LYK_SUBMIT ||
				  real_cmd==LYK_NOCACHE ||
				  real_cmd==LYK_DOWNLOAD ||
				  real_cmd==LYK_HEAD));
d1162 4
a1165 4
		if ((links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		     links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
		     links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE) &&
		    links[curdoc.link].form->submit_method
d1178 3
a1180 2
		newdoc.post_data != NULL &&
		newdoc.safe == FALSE) {
d1186 1
a1186 1
			StrAllocCopy(newdoc.address, curdoc.address);
d1188 1
a1188 1
			StrAllocCopy(newdoc.post_data, curdoc.post_data);
d1228 1
a1228 1
			F_TEXTLIKE(links[curdoc.link].form->type) &&
d1242 4
a1245 5
	    if (no_file_url &&
		!strncmp(links[curdoc.link].lname, "file:", 5)) {
		if (strncmp(curdoc.address, "file:", 5) &&
		    !((!strncmp(curdoc.address, "LYNXKEYMAP:", 11) ||
		       !strncmp(curdoc.address, "LYNXCOOKIE:", 11)) &&
d1263 3
a1265 5
	    if ((!strncmp(links[curdoc.link].lname,
			  "LYNXCOOKIE:", 11) &&
		 (strcmp((curdoc.title ? curdoc.title : ""),
			 COOKIE_JAR_TITLE) ||
		  strncmp(curdoc.address, "LYNXCOOKIE:", 11))) ||
d1267 1
a1267 2
		(!strncmp(links[curdoc.link].lname,
			  "LYNXDIRED:", 10) &&
d1275 1
a1275 2
		(!strncmp(links[curdoc.link].lname,
			 "LYNXDOWNLOAD:", 13) &&
d1277 1
a1277 2
		(!strncmp(links[curdoc.link].lname,
			  "LYNXHIST:", 9) &&
d1281 1
a1281 2
		(!strncmp(links[curdoc.link].lname,
			  "LYNXPRINT:", 10) &&
d1301 2
a1302 2
	    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
d1325 1
a1325 1
		if (LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
d1344 1
a1344 1
				StrAllocCopy(newdoc.address, curdoc.address);
d1362 1
a1362 2
				FREE(newdoc.post_data);
				FREE(newdoc.post_content_type);
d1372 1
a1372 1
		    FREE(curdoc.address);
d1386 1
a1386 2
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
d1394 1
a1394 2
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
d1396 1
a1396 1
		if (!strncmp(newdoc.address, "LYNXMESSAGES:", 13))
d1410 1
a1410 2
	    } else if (no_filereferer == TRUE &&
		       !strncmp(curdoc.address, "file:", 5)) {
d1433 1
a1433 1
	    if (!strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
d1501 1
a1501 1
	strncmp(curdoc.address, "LYNXCOOKIE:", 11) &&
d1505 6
a1510 6
	  strncmp(links[curdoc.link].lname, "LYNXHIST:", 9) &&
	  strncmp(links[curdoc.link].lname, "LYNXPRINT:", 10) &&
	  strncmp(links[curdoc.link].lname, "LYNXDIRED:", 10) &&
	  strncmp(links[curdoc.link].lname, "LYNXDOWNLOAD:", 13) &&
	  strncmp(links[curdoc.link].lname, "LYNXCOOKIE:", 11) &&
	  strncmp(links[curdoc.link].lname, "LYNXOPTIONS:", 12)))) {
d1534 2
a1535 2
					  ?
			(bookmark_page+1) : bookmark_page)) != NULL) {
d1575 1
a1575 1
				       links[curdoc.link].hightext);
d1610 1
a1610 1
	    StrAllocCopy(newdoc.address, curdoc.address);
a1611 1
	    FREE(curdoc.address);
d1711 1
a1711 1
			StrAllocCopy(address, "mailto:");
d1739 1
a1739 1
		StrAllocCopy(newdoc.address, *owner_address_p);
d1759 1
a1759 1
		if (strchr(*owner_address_p,':')!=NULL)
d1763 1
a1763 1
		     reply_by_mail(strchr(*owner_address_p,':')+1,
d1765 1
a1765 1
				   (kp ? kp : ""), id);
d1768 1
a1768 1
				  (kp ? kp : ""), id);
d1783 3
a1785 4
    if (strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
	StrAllocCopy(newdoc.address, "LYNXCOOKIE:/");
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d1810 2
a1811 4
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d1852 1
d1856 1
a1856 1
     *	Will be disabled if LYCSwingPath is NULL, zero-length,
d1863 2
a1864 2
    if (!(LYCSwingPath && *LYCSwingPath) ||
	!strcasecomp(LYCSwingPath, "none") ||
d1898 1
a1898 1
	    HTSprintf0(&temp, "%s []", LYCSwingPath);
d1926 1
a1926 1
	    HTSprintf0(&temp, "%s %s", LYCSwingPath, VMSdir);
d1936 2
a1937 3
	    StrAllocCopy(newdoc.address, curdoc.address);
	    StrAllocCopy(newdoc.title,
			 curdoc.title ? curdoc.title : "");
a1938 1
	    FREE(curdoc.address);
d1949 1
a1949 1
	HTSprintf0(&temp, "%s []", LYCSwingPath);
d1962 1
a1962 2
	strcmp((curdoc.title ? curdoc.title : ""),
	       DIRED_MENU_TITLE)) {
d1998 4
a2001 4
	    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
		links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE) {
		if (links[curdoc.link].form->submit_method ==
d2009 1
a2009 2
		if (!strncmp(links[curdoc.link].form->submit_action,
			"LYNXOPTIONS:", 12)) {
d2026 1
a2026 1
	} else if (!strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
d2056 3
a2058 3
	    char *temp = NULL;
	    StrAllocCopy(temp, newdoc.address);
	    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
d2061 1
a2061 1
		StrAllocCopy(newdoc.address, temp);
d2064 1
a2064 1
	    FREE(temp);
d2068 2
a2069 2
	    !strncmp(links[curdoc.link].lname, "LYNXHIST:", 9)) {
	    int number = atoi(links[curdoc.link].lname+9);
d2074 2
a2075 2
	    if ((history[number].post_data != NULL &&
		 history[number].safe != TRUE) &&
d2083 8
a2090 9
	    StrAllocCopy(newdoc.address, history[number].address);
	    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
	    StrAllocCopy(newdoc.bookmark, history[number].bookmark);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    if (history[number].post_data)
		StrAllocCopy(newdoc.post_data,
			     history[number].post_data);
	    if (history[number].post_content_type)
d2092 3
a2094 3
			     history[number].post_content_type);
	    newdoc.isHEAD = history[number].isHEAD;
	    newdoc.safe = history[number].safe;
d2110 7
a2116 12
	} else if (!strncmp(links[curdoc.link].lname,
			    "LYNXCOOKIE:", 11) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXDIRED:", 10) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXDOWNLOAD:", 13) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXPRINT:", 10) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXOPTIONS:", 12) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXHIST:", 9) || /* handled above if valid - kw */
d2118 4
a2121 8
		   !strncmp(links[curdoc.link].lname,
			    "LYNXCFG:", 8) ||
		   !strncmp(links[curdoc.link].lname,
			    "LYNXCOMPILEOPTS:", 16) ||
		   !strncmp(links[curdoc.link].lname,
			    "lynxexec:", 9) ||
		   !strncmp(links[curdoc.link].lname,
			    "lynxprog:", 9)) {
d2124 1
a2124 2
	} else if (!strncmp(links[curdoc.link].lname,
			    "mailto:", 7)) {
d2146 2
a2147 2
	    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
	    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
d2162 1
a2162 2
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
d2211 1
d2214 2
a2215 2
	    if (links[curdoc.link].hightext)
		*follow_col += strlen(links[curdoc.link].hightext)/2;
d2269 2
a2270 2
	links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d2287 2
a2288 2
	links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXT_TYPE)       {
d2414 1
a2414 3
			    StrAllocCopy(newdoc.address,
					 curdoc.address);
			    FREE(curdoc.address);
d2442 1
a2442 1
	    FREE(curdoc.address); /* so it doesn't get pushed */
d2477 2
a2478 5
	!links[curdoc.link].form->disabled &&
	(links[curdoc.link].form->type == F_TEXT_TYPE ||
	 links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE ||
	 links[curdoc.link].form->type == F_PASSWORD_TYPE ||
	 links[curdoc.link].form->type == F_TEXTAREA_TYPE)) {
d2504 2
a2505 2
    else if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d2553 3
a2555 3
	 links[curdoc.link].form->type != F_SUBMIT_TYPE &&
	 links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE &&
	 links[curdoc.link].form->type != F_TEXT_SUBMIT_TYPE)) {
d2567 2
a2568 2
	(!links[curdoc.link].form->submit_action ||
	 *links[curdoc.link].form->submit_action == '\0')) {
d2579 1
a2579 1
    if (!strncmp(links[curdoc.link].lname, "LYNXDIRED:", 10) ||
d2602 1
a2602 1
    links[curdoc.link].form->submit_action : links[curdoc.link].lname),
d2614 1
a2614 1
			? links[curdoc.link].form->submit_action
d2668 3
a2670 3
	    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].form->number;
	    char *thisname = links[curdoc.link].form->name;
d2674 3
a2676 3
		  links[0].form->type == F_TEXTAREA_TYPE &&
		  links[0].form->number == thisgroup &&
		  sametext(links[0].form->name, thisname))) {
d2680 3
a2682 3
		     links[nextlink].form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].form->number == thisgroup &&
		     sametext(links[nextlink].form->name, thisname));
d2687 3
a2689 3
			links[0].form->type == F_TEXTAREA_TYPE &&
			links[0].form->number == thisgroup &&
			sametext(links[0].form->name, thisname)) &&
d2691 3
a2693 3
			 links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
			 links[nlinks-1].form->number == thisgroup &&
			 sametext(links[nlinks-1].form->name, thisname))) {
d2717 3
a2719 3
	    links[nextlink].form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[nextlink].form->number;
	    char *thisname = links[nextlink].form->name;
d2721 3
a2723 3
		links[0].form->type == F_TEXTAREA_TYPE &&
		links[0].form->number == thisgroup &&
		sametext(links[0].form->name, thisname)) {
d2729 3
a2731 3
		     links[nextlink-1].form->type == F_TEXTAREA_TYPE &&
		     links[nextlink-1].form->number == thisgroup &&
		     sametext(links[nextlink-1].form->name, thisname)) {
d2775 3
a2777 3
	    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
	    int thisgroup = links[curdoc.link].form->number;
	    char *thisname = links[curdoc.link].form->name;
d2781 3
a2783 3
		  links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
		  links[nlinks-1].form->number == thisgroup &&
		  sametext(links[nlinks-1].form->name, thisname))) {
d2787 3
a2789 3
		     links[nextlink].form->type == F_TEXTAREA_TYPE &&
		     links[nextlink].form->number == thisgroup &&
		     sametext(links[nextlink].form->name, thisname));
d2900 2
a2901 2
    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d2919 4
a2922 4
	(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
	 links[curdoc.link].form->type == F_SUBMIT_TYPE ||
	 links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
	 links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE)) {
d2930 3
a2932 2
	    char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
		curdoc.address : curdoc.address + 11;
d2949 2
a2950 2
			HTuncache_current_document();
			FREE(curdoc.address);
d2967 1
a2967 1
		       links[curdoc.link].form->disabled) {
d2970 2
a2971 3
		       strncmp(links[curdoc.link].form->submit_action,
						      "lynxcgi:", 8) &&
		       strncmp(links[curdoc.link].form->submit_action,
d2975 1
a2975 1
		       links[curdoc.link].form->submit_method ==
d3013 3
a3015 2
		char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
		    curdoc.address : curdoc.address + 11;
d3027 2
a3028 2
			HTuncache_current_document();
			FREE(curdoc.address);
d3048 1
a3048 1
	StrAllocCopy(newdoc.address, *cshelpfile);
d3053 1
a3053 2
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d3064 1
a3064 1
#ifdef SOURCE_CACHE
d3074 1
a3074 2
	confirm_post_resub(curdoc.address, NULL,
			   0, 0) == FALSE) {
d3077 2
a3078 3
	HTuncache_current_document();
	StrAllocCopy(newdoc.address, curdoc.address);
	FREE(curdoc.address);
d3082 1
a3082 1
#ifdef SOURCE_CACHE
d3085 1
a3085 4
    if (historical_comments)
	historical_comments = FALSE;
    else
	historical_comments = TRUE;
d3093 1
a3093 1
#ifdef SOURCE_CACHE
d3128 1
a3128 2
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d3134 1
a3134 1
	FREE(curdoc.address);  /* so it doesn't get pushed */
d3147 1
a3147 4
    if (clickable_images)
	clickable_images = FALSE;
    else
	clickable_images = TRUE;
d3175 1
a3175 1
	    StrAllocCopy(newdoc.address, indexfile);
d3177 1
a3177 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d3222 2
a3223 2
	    StrAllocCopy(curdoc.address, newdoc.address);
	    StrAllocCopy(newdoc.post_data, curdoc.post_data);
d3232 2
a3233 1
	    _user_message("Using %s", use_this_url_instead);
d3239 2
a3240 3
	    StrAllocCopy(newdoc.address, use_this_url_instead);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d3251 2
a3252 2
	    StrAllocCopy(newdoc.address, curdoc.address);
	    StrAllocCopy(newdoc.post_data, curdoc.post_data);
d3278 1
a3278 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d3300 1
a3300 4
    if (pseudo_inline_alts)
	pseudo_inline_alts = FALSE;
    else
	pseudo_inline_alts = TRUE;
d3317 2
a3318 2
    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
	links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d3336 1
a3336 1
		    HTUserMsg2(GOTO_XXXX_DISALLOWED, "file:");
d3427 1
a3427 1
	    StrAllocCopy(newdoc.address, ret);
d3429 1
a3429 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d3451 1
a3451 1
	StrAllocCopy(newdoc.address, "LYNXKEYMAP:");
d3453 1
a3453 2
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d3508 1
a3508 2
    if (!strcmp((curdoc.title ? curdoc.title : ""),
		LIST_PAGE_TITLE) &&
d3547 1
a3547 1
	    StrAllocCopy(newdoc.address, homepage);
d3549 1
a3549 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d3554 1
a3554 1
	    highlight(OFF, curdoc.link, prev_target);
d3572 1
a3572 1
#ifdef SOURCE_CACHE
d3582 1
a3582 2
	    confirm_post_resub(curdoc.address, NULL,
			       0, 0) == FALSE) {
d3585 2
a3586 3
	    HTuncache_current_document();
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
d3590 1
a3590 1
#ifdef SOURCE_CACHE
d3594 1
a3594 4
    if (minimal_comments)
	minimal_comments = FALSE;
    else
	minimal_comments = TRUE;
a3597 3
#ifdef SOURCE_CACHE
	(void)reparse_document();
#endif
d3602 3
d3620 2
a3621 4
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d3677 2
a3678 2
	     (!strncmp(curdoc.address, "file:", 5) ||
	      !strncmp(curdoc.address, "ftp:", 4))) ||
d3691 1
a3691 1
	      !strncmp(curdoc.address, "lynxcgi:", 8)))) {
d3702 1
a3702 1
#ifdef SOURCE_CACHE
d3709 1
a3709 1
		StrAllocCopy(newdoc.address, curdoc.address);
d3712 2
a3713 4
		      strcmp(CurrentNegoLanguage,
			     (language ? language : "")) ||
		      strcmp(CurrentNegoCharset,
			     (pref_charset ? pref_charset : ""))) &&
d3715 1
a3715 1
		      strncmp(curdoc.address, "lynxcgi:", 8) == 0))) {
d3732 1
a3732 1
#ifdef SOURCE_CACHE
d3756 1
a3756 1
		HTuncache_current_document();
d3765 1
a3765 1
		FREE(curdoc.address); /* So it doesn't get pushed. */
d3793 2
a3794 3
	StrAllocCopy(newdoc.address, "LYNXOPTIONS:/");
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d3820 1
a3820 1
	FREE(curdoc.address);		/* avoid push */
d3832 1
a3832 1
	highlight(OFF, curdoc.link, prev_target);
d3837 2
a3838 2
	if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	    links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
d3840 2
a3841 2
	    int thisgroup = links[curdoc.link].form->number;
	    char *thisname = links[curdoc.link].form->name;
d3846 3
a3848 3
		   links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
		   links[curdoc.link].form->number == thisgroup &&
		   sametext(links[curdoc.link].form->name, thisname));
d3891 3
a3893 3
	    links[curdoc.link].form->type != F_SUBMIT_TYPE &&
	    links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE &&
	    links[curdoc.link].form->type != F_TEXT_SUBMIT_TYPE) {
d3971 1
a3971 1
	    if (history[(nhist - 1)].post_data == NULL) {
d3974 2
a3975 2
	    WWWDoc.address = history[(nhist - 1)].address;
	    WWWDoc.post_data = history[(nhist - 1)].post_data;
d3977 5
a3981 5
			       history[(nhist - 1)].post_content_type;
	    WWWDoc.bookmark = history[(nhist - 1)].bookmark;
	    WWWDoc.isHEAD = history[(nhist - 1)].isHEAD;
	    WWWDoc.safe = history[(nhist - 1)].safe;
	    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
d3985 2
a3986 3
	    if (((text =
		  (HText *)HTAnchor_document(tmpanchor)) == NULL &&
		 (!strncmp(WWWDoc.address, "LYNXIMGMAP:", 11) ||
d3988 1
a3988 1
					    history[(nhist - 1)].title,
d3993 1
a3993 1
		      (document *)&history[(nhist - 1)],
d3996 1
a3996 1
		       (document *)&history[(nhist - 1)],
d3999 1
a3999 1
				     history[(nhist - 1)].title,
d4003 1
a4003 1
			FREE(curdoc.address);
d4017 1
a4017 1
			(document *)&history[(nhist - 1)],
d4042 1
a4042 1
	FREE(newdoc.address);
d4093 1
a4093 2
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d4108 1
a4108 1
	c = HTConfirmDefault(REALLY_QUIT_Y, YES);
d4110 1
a4110 1
	c = HTConfirmDefault(REALLY_QUIT_N, NO);
a4139 4
/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
d4143 4
d4165 1
a4165 1
    HTuncache_current_document();
d4182 1
a4182 1
    FREE(curdoc.address); /* so it doesn't get pushed */
d4232 5
a4236 2
	Cygwin_Shell();
#else
a4237 1
#endif
d4250 1
a4250 1
#ifdef SOURCE_CACHE
d4263 2
a4264 3
	HTuncache_current_document();
	StrAllocCopy(newdoc.address, curdoc.address);
	FREE(curdoc.address);
d4268 1
a4268 1
#ifdef SOURCE_CACHE
d4271 1
a4271 4
    if (soft_dquotes)
	soft_dquotes = FALSE;
    else
	soft_dquotes = TRUE;
d4274 1
a4274 1
#ifdef SOURCE_CACHE
a4279 4
/*
 * Check if this is a reply from a POST, and if so,
 * seek confirmation if the safe element is not set.  - FM
 */
d4283 5
a4287 1
#ifdef SOURCE_CACHE
d4292 1
a4292 1
#ifdef SOURCE_CACHE
d4296 1
a4296 2
	 confirm_post_resub(curdoc.address, curdoc.title,
			    1, 1)) == FALSE) {
d4310 1
a4310 1
#ifdef SOURCE_CACHE
d4337 1
a4337 1
    FREE(curdoc.address); /* so it doesn't get pushed */
d4343 1
a4343 1
#ifdef SOURCE_CACHE
d4371 2
a4372 3
	    HTuncache_current_document();
	    StrAllocCopy(newdoc.address, curdoc.address);
	    FREE(curdoc.address);
d4381 1
a4381 1
#ifdef SOURCE_CACHE
d4387 1
a4387 1
#ifdef SOURCE_CACHE
d4404 1
a4404 1
	if (!strcmp(links[curdoc.link].hightext, ".."))
d4407 1
a4407 1
	    if (!strcmp(links[curdoc.link].hightext, "../"))
d4409 1
a4409 1
	} else if (!strncmp(links[curdoc.link].hightext, "Up to ", 6))
d4472 1
a4472 3
	if ((cp = strchr(curdoc.address, '#')) != NULL)
	    *cp = '\0';

d4474 2
a4475 3
	if (cp)
	    *cp = '#';
	StrAllocCopy(newdoc.address, toolbar);
d4518 1
a4518 2
    FREE(newdoc.post_data);
    FREE(newdoc.post_content_type);
d4542 1
a4542 2
	LYUpload_options((char **)&newdoc.address,
			 (char *)curdoc.address);
d4544 1
a4544 2
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d4599 1
d4602 2
a4603 2
	    if (links[curdoc.link].hightext)
		*follow_col += strlen(links[curdoc.link].hightext)/2;
d4691 1
a4691 2
	FREE(newdoc.post_data);
	FREE(newdoc.post_content_type);
d4730 1
a4730 2
    FREE(newdoc.post_data);
    FREE(newdoc.post_content_type);
d4831 2
a4832 2
	StrAllocCopy(newdoc.address, links[lindx].lname);
	StrAllocCopy(newdoc.title, links[lindx].hightext);
d4844 1
a4844 1
	    if (LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
d4862 1
a4862 1
			    StrAllocCopy(newdoc.address, curdoc.address);
d4880 1
a4880 2
			    FREE(newdoc.post_data);
			    FREE(newdoc.post_content_type);
d4890 1
a4890 1
		FREE(curdoc.address);
d4901 1
a4901 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d4909 1
a4909 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d4913 1
a4913 1
	    if (!strncmp(newdoc.address, "LYNXMESSAGES:", 13))
d5050 1
a5050 2
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
d5073 1
a5073 1
 * 
d5224 10
d5267 1
a5267 1
    StrAllocCopy(newdoc.address, startfile);
d5284 1
a5284 1
	StrAllocCopy(newdoc.post_data, form_post_data);
d5312 1
a5312 2
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
d5365 1
a5365 1
		    if (strncmp(newdoc.address, "LYNXDOWNLOAD:", 13))
d5425 4
a5428 4
			} else if (!strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			    if (LYCanDoHEAD(newdoc.address + 11) == TRUE) {
				StrAllocCopy(temp, newdoc.address + 11);
				FREE(newdoc.address);
d5458 1
a5458 1
		    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
d5506 1
a5506 1
			0==strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
d5509 1
a5509 1
			0==strncmp(curdoc.address, "LYNXIMGMAP:", 11)) {
d5514 1
a5514 1
		    char *hashp = strchr(newdoc.address,'#');
d5523 1
a5523 1
			    StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
d5527 1
a5527 1
			    StrAllocCopy(newdoc.address, temp);
d5535 2
a5536 2
			if (0==strncmp(history[nhist-1].address, "LYNXIMGMAP:", 11))
			    cp0 = history[nhist-1].address + 11;
d5538 1
a5538 1
			    cp0 = history[nhist-1].address;
d5540 1
a5540 3
			cp0 = strchr(temp, '#');
			if (cp0)
			    *cp0 = '\0';
d5542 1
a5542 1
			FREE(newdoc.address);
d5580 2
a5581 4
			    strncmp(newdoc.address ? newdoc.address : "",
				    "LYNXHIST:", 9) &&
			    strncmp(newdoc.address ? newdoc.address : "",
				    "LYNXCOOKIE:", 11)) {
d5583 2
a5584 3
			    if (owner_address &&
				strncasecomp(owner_address, "mailto:", 7)) {
				mail_owner = owner_address + 7;
d5597 2
a5598 2
					history[nhist-1].address,
					history[nhist-1].title);
d5615 1
a5615 1
					history[nhist-1].address);
d5649 1
a5649 1
		    FREE(newdoc.address); /* to pop last doc */
d5681 1
a5681 6
#ifdef VMS
			   strcasecomp(homepage, startfile) != 0
#else
			   strcmp(homepage, startfile) != 0
#endif /* VMS */
			   ) {
d5692 2
a5693 3
			   StrAllocCopy(newdoc.address, homepage);
			   FREE(newdoc.post_data);
			   FREE(newdoc.post_content_type);
d5725 3
a5727 3
		   if (history[nhist - 1].post_data &&
		       !history[nhist - 1].safe) {
		       if (HText_POSTReplyLoaded((document *)&history[(nhist - 1)])) {
d5734 1
a5734 1
			   StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
d5736 4
a5739 3
			   if (HTMainAnchor && HTMainAnchor->post_data) {
			       StrAllocCopy(newdoc.post_data,
					    HTMainAnchor->post_data);
d5743 1
a5743 1
			       FREE(newdoc.post_data);
d5749 1
a5749 1
			   StrAllocCopy(newdoc.address, curdoc.address);
d5751 1
a5751 1
			   StrAllocCopy(newdoc.post_data, curdoc.post_data);
d5783 1
a5783 1
			 !(strcmp((HText_getTitle() ? HText_getTitle() : ""),
d5787 2
a5788 2
			cp = wwwName(Home_Dir());
			len = strlen(cp);
d5790 1
a5790 1
			if (!strncasecomp(temp, cp, len) &&
d5793 1
a5793 1
			if (!strncmp(temp, cp, len) &&
a5814 5
#ifdef VMS
#define CompareBookmark(a,b) strcasecomp(a, b)
#else
#define CompareBookmark(a,b) strcmp(a, b)
#endif /* VMS */
d5817 1
a5817 1
				    !CompareBookmark(cp, MBM_A_subbookmark[i])) {
d5832 1
a5832 1
				    StrAllocCopy(newdoc.address, temp);
d5834 1
a5834 1
				    FREE(curdoc.address);
d5849 1
a5849 2
				    FREE(newdoc.post_data);
				    FREE(newdoc.post_content_type);
d5881 1
a5881 1
			    strncmp(curdoc.address, "LYNXIMGMAP:", 11))
d5894 2
a5895 2
			!strncmp(newdoc.address, "LYNXDOWNLOAD:", 13)) {
			StrAllocCopy(newdoc.address, curdoc.address);
d5954 2
a5955 2
	    StrAllocCopy(curdoc.address, newdoc.address);
	    StrAllocCopy(curdoc.post_data, newdoc.post_data);
d6052 6
d6062 1
d6108 1
a6108 1
			!strncasecomp(curdoc.address, "file:", 5) &&
d6142 1
a6142 1
		    if (strncmp(curdoc.address, "LYNXIMGMAP:", 11))
d6193 1
a6193 1
#ifdef SOURCE_CACHE
d6353 1
a6353 4
	     (links[curdoc.link].form->type == F_TEXT_TYPE ||
	      links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE ||
	      links[curdoc.link].form->type == F_PASSWORD_TYPE ||
	      links[curdoc.link].form->type == F_TEXTAREA_TYPE));
d6373 1
a6373 1
		    switch(links[curdoc.link].form->type) {
d6458 1
a6458 1
		highlight(ON, curdoc.link, prev_target);
d6461 1
a6461 1
		highlight(ON, curdoc.link, prev_target);
d6514 1
a6514 1
			form_noviceline(links[curdoc.link].form->disabled);
d6516 1
a6516 1
		    real_c = change_form_link(&links[curdoc.link],
d6518 1
a6518 3
				     links[curdoc.link].form->name,
					  links[curdoc.link].form->value,
					  use_last_tfpos, FALSE);
d6537 1
a6537 1
			F_TEXTLIKE(links[curdoc.link].form->type) &&
d6543 1
a6543 1
			    links[curdoc.link].form->type == F_TEXTAREA_TYPE)
d6545 1
a6545 1
			   && !links[curdoc.link].form->disabled
d6555 5
a6559 5
			       links[curdoc.link+1].form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].form->number ==
				   links[curdoc.link+1].form->number) &&
			       strcmp(links[curdoc.link].form->name,
				      links[curdoc.link+1].form->name) == 0) ||
d6567 5
a6571 5
			       links[curdoc.link-1].form->type == F_TEXTAREA_TYPE
			       && (links[curdoc.link].form->number ==
				   links[curdoc.link-1].form->number) &&
			       strcmp(links[curdoc.link].form->name,
				      links[curdoc.link-1].form->name) == 0) ||
d6600 2
a6601 2
		    if ((links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].form->type == F_TEXTAREA_TYPE) &&
d6607 1
a6607 1
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE))
d6611 1
a6611 1
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE)
d6613 4
a6616 4
			    ((links[curdoc.link].form->number	       !=
				      links[curdoc.link+1].form->number)     ||
			     (strcmp (links[curdoc.link].form->name,
				      links[curdoc.link+1].form->name) != 0)))))) {
d6665 1
a6665 1
		    change_form_link_ex(&links[curdoc.link],
a6666 2
				    links[curdoc.link].form->name,
				    links[curdoc.link].form->value,
d6774 1
a6774 1
		F_TEXTLIKE(links[curdoc.link].form->type)) {
a6828 1
#ifdef SH_EX		/* 1999/01/01 (Fri) */
d6833 1
a6833 1
		HTInfoMsg("TABLE center enable.");
d6836 1
a6836 1
		HTInfoMsg("TABLE center disable.");
a6837 1
#endif
d6839 1
d6896 1
a6896 1
		int c;
d6903 2
a6904 2
		    c = LYgetch_single();
		    if (c == 'D')
d6906 1
a6906 1
		    else if (c == 'C')
d6912 2
a6913 2
		if (!s && !*s)
		    HTInfoMsg("Current URL is empty.");
d6915 1
a6915 1
		    HTInfoMsg("Copy to clipboard failed.");
d6917 1
a6917 1
		    HTInfoMsg("Document URL put to clipboard.");
d6919 1
a6919 1
		    HTInfoMsg("Link URL put to clipboard.");
d6927 1
a6927 1
		unsigned char *s = get_clip_grab(), *e, *t;
d6929 1
a6929 1
		int len;
d6933 2
a6934 2
		len = strlen(s);
		e = s + len;
d6939 5
d6945 1
a6945 1
		    HTInfoMsg("No URL in the clipboard.");
d6948 5
a6952 2
		buf = (char*)malloc(e - s + 1);
		strncpy(buf, s, e - s);
d6954 1
a6954 1
		t = buf;
d6958 1
a6958 1
			int nl = 0;	/* Keep whitespace without NL - file names! */
d6962 2
a6963 2
			    if (!nl && *s == '\n')
				nl = 1;
d6966 1
a6966 1
			if (!nl) {
d7387 2
a7388 2
	document *,	doc1,
	document *,	doc2)
d7409 2
a7410 4
    if ((cp1 = strchr(doc1->address, '#')) != NULL)
	*cp1 = '\0';
    if ((cp2 = strchr(doc2->address, '#')) != NULL)
	*cp2 = '\0';
d7415 2
a7416 4
	if (cp1)
	    *cp1 = '#';
	if (cp2)
	    *cp2 = '#';
d7419 2
a7420 4
    if (cp1)
	*cp1 = '#';
    if (cp2)
	*cp2 = '#';
d7427 1
a7427 1
	    if (strcmp(doc1->post_data, doc2->post_data))
d7445 2
a7446 2
	document *,	doc1,
	document *,	doc2)
d7465 4
a7468 4
    if (0==strncmp(doc1->address, "LYNXIMGMAP:", 11))
	ap1 += 11;
    if (0==strncmp(doc2->address, "LYNXIMGMAP:", 11))
	ap2 += 11;
d7482 2
a7483 4
    if ((cp1 = strchr(doc1->address, '#')) != NULL)
	*cp1 = '\0';
    if ((cp2 = strchr(doc2->address, '#')) != NULL)
	*cp2 = '\0';
d7488 2
a7489 4
	if (cp1)
	    *cp1 = '#';
	if (cp2)
	    *cp2 = '#';
d7492 2
a7493 4
    if (cp1)
	*cp1 = '#';
    if (cp2)
	*cp2 = '#';
d7500 1
a7500 1
	    if (strcmp(doc1->post_data, doc2->post_data))
d7547 1
d7578 1
a7578 1
    CONST linkstruct,	curlink,
d7611 1
a7611 1
	    show_formlink_statusline(curlink.form, for_what);
d7622 1
a7622 1
	    start_reverse();
d7624 1
a7624 1
	    stop_reverse();
d7634 2
a7635 2
	    strncmp(curlink.lname, "LYNXIMGMAP:", 11)) {
	    cp = strchr(curlink.lname, '#');
d7729 1
a7729 1
		   buf2 ? buf2 : "",
d7742 1
a7742 1
		   buf2 ? buf2 : "",
d7844 7
@


1.3
log
@Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d3 1
d41 101
d143 3
a145 1
#ifdef USE_EXTERNALS
d162 10
d173 3
a175 6
PRIVATE void print_status_message PARAMS((CONST linkstruct curlink, char **cp));
PRIVATE BOOL confirm_post_resub PARAMS((
    CONST char*		address,
    CONST char*		title,
    int			if_imgmap,
    int			if_file));
a176 2
PUBLIC void HTGotoURLs_free NOPARAMS;
PUBLIC void HTAddGotoURL PARAMS((char *url));
d196 3
d201 2
a202 6
PUBLIC int Newline_partial = 0;     /* required for display_partial mode */
PUBLIC int NumOfLines_partial = -1; /* initialize to -1 the very first time */
PUBLIC BOOLEAN display_partial = FALSE;
PUBLIC int Newline = 0;
#else
PRIVATE int Newline = 0;
d205 1
d210 12
d239 1
a239 1
#ifdef USE_HASH
d245 2
d249 1
d251 2
d258 1
a258 8
PUBLIC FILE *TraceFP NOARGS
{
    if (LYTraceLogFP != 0) {
	return LYTraceLogFP;
    }
    return stderr;
}

d266 37
a302 1
	exit(-1);
d304 2
d310 1
d334 4
a337 1
	 *  anonymous restrictions are set. - FM
d339 25
a363 2
	if (LYRestricted) {
	    CTRACE(tfp, "Anonymous restrictions are set.\n");
d366 1
d372 1
d379 48
d428 1
d430 6
a435 1
PRIVATE BOOLEAN LYReopenTracelog ARGS1(BOOLEAN *, trace_flag_ptr)
d437 3
a439 4
    CTRACE(tfp, "\nTurning off TRACE for fetch of log.\n");
    LYCloseTracelog();
    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
	TracelogOpenFailed();
d442 57
a498 3
    if (TRACE) {
	WWW_TraceFlag = FALSE;
	*trace_flag_ptr = TRUE;
a499 1
    return TRUE;
d502 1
a502 2
PRIVATE void do_change_link ARGS1(
	char *,		prev_target)
d504 1
d509 10
a518 2
	highlight(OFF, curdoc.link, prev_target);
	curdoc.link = mouse_tmp;
d520 2
d524 6
a529 8
/*
 *  Here's where we do all the work.
 *  mainloop is basically just a big switch dependent on the users input.
 *  I have tried to offload most of the work done here to procedures to
 *  make it more modular, but this procedure still does a lot of variable
 *  manipulation.  This needs some work to make it neater. - Lou Moutilli
 *					(memoir from the original Lynx - FM)
 */
d531 4
a534 1
int mainloop NOARGS
d536 77
a612 33
    int c = 0, real_c = 0, old_c = 0;
    int cmd = LYK_DO_NOTHING, real_cmd = LYK_DO_NOTHING;
    int getresult;
    int arrowup = FALSE, show_help = FALSE;
    char prev_target[512];
    char user_input_buffer[1024];
    char *owner_address = NULL;  /* Holds the responsible owner's address     */
    char *ownerS_address = NULL; /* Holds owner's address during source fetch */
    BOOLEAN first_file = TRUE;
    BOOLEAN popped_doc = FALSE;
    BOOLEAN refresh_screen = FALSE;
    BOOLEAN force_load = FALSE;
    BOOLEAN try_internal = FALSE;
    BOOLEAN crawl_ok = FALSE;
    BOOLEAN rlink_exists;
    BOOLEAN rlink_allowed;
    BOOLEAN vi_keys_flag = vi_keys;
    BOOLEAN emacs_keys_flag = emacs_keys;
    BOOLEAN trace_mode_flag = FALSE;
    BOOLEAN forced_HTML_mode = LYforce_HTML_mode;
    char cfile[128];
    FILE *cfp;
    char *cp, *toolbar;
    int ch, recall;
    int URLTotal;
    int URLNum;
    BOOLEAN FirstURLRecall = TRUE;
    char *temp = NULL;
    BOOLEAN ForcePush = FALSE;
    BOOLEAN override_LYresubmit_posts = FALSE;
    unsigned int len;
    int i;
    int n;
d614 18
d633 3
a635 2
    char *tp = NULL;
    struct stat dir_info;
d637 22
d660 138
a797 39
/*
 *  curdoc.address contains the name of the file that is currently open.
 *  newdoc.address contains the name of the file that will soon be
 *		     opened if it exits.
 *  prev_target    contains the last search string the user searched for.
 *  newdoc.title   contains the link name that the user last chose to get
 *		     into the current link (file).
 */
    /* initialize some variables*/
    newdoc.address = NULL;
    newdoc.title = NULL;
    newdoc.post_data = NULL;
    newdoc.post_content_type = NULL;
    newdoc.bookmark = NULL;
    curdoc.address = NULL;
    curdoc.title = NULL;
    curdoc.post_data = NULL;
    curdoc.post_content_type = NULL;
    curdoc.bookmark = NULL;
#ifdef USE_HASH
    curdoc.style = NULL;
    newdoc.style = NULL;
#endif
    nhist = 0;
    user_input_buffer[(sizeof(user_input_buffer) - 1)] = '\0';
    *prev_target = '\0';
    *user_input_buffer = '\0';
#ifdef LY_FIND_LEAKS
    atexit(free_mainloop_variables);
#endif
initialize:
    StrAllocCopy(newdoc.address, startfile);
    StrAllocCopy(startrealm, startfile);
    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
    newdoc.isHEAD = FALSE;
    newdoc.safe = FALSE;
    newdoc.internal_link = FALSE;
    newdoc.line = 1;
    newdoc.link = 0;
d799 13
a811 4
#ifdef USE_SLANG
    if (TRACE && LYCursesON) {
	addstr("\n");
	refresh();
d813 7
a819 2
#endif /* USE_SLANG */
    CTRACE(tfp,"Entering mainloop, startfile=%s\n",startfile);
d821 20
a840 6
    if (form_post_data) {
	StrAllocCopy(newdoc.post_data, form_post_data);
	StrAllocCopy(newdoc.post_content_type,
		     "application/x-www-form-urlencoded");
    } else if (form_get_data) {
	StrAllocCat(newdoc.address, form_get_data);
d842 16
d859 13
a871 26
    if (bookmark_start) {
	if (LYValidate) {
	    HTAlert(BOOKMARKS_DISABLED);
	    bookmark_start = FALSE;
	    goto initialize;
	} else if (traversal) {
	    HTAlert(BOOKMARKS_NOT_TRAVERSED);
	    traversal = FALSE;
	    crawl = FALSE;
	    bookmark_start = FALSE;
	    goto initialize;
	} else {
	    /*
	     *	See if a bookmark page exists.	If it does,
	     *	replace newdoc.address with it's name
	     */
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL &&
		 *cp != '\0' && strcmp(cp, " ")) {
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		StrAllocCopy(startrealm, newdoc.address);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		CTRACE(tfp, "Using bookmarks=%s\n", newdoc.address);
d873 3
a875 3
		HTUserMsg(BOOKMARKS_NOT_OPEN);
		bookmark_start = FALSE;
		goto initialize;
d877 2
d880 2
d883 48
d932 4
a935 2
    FREE(form_post_data);
    FREE(form_get_data);
d937 6
a942 4
    if (user_mode == NOVICE_MODE)
	display_lines = LYlines-4;
    else
	display_lines = LYlines-2;
d944 24
a967 3
    while (TRUE) {
#ifdef USE_HASH
	if (curdoc.style != NULL) force_load = TRUE;
a968 6
	/*
	 *  If newdoc.address is different then curdoc.address then
	 *  we need to go out and find and load newdoc.address.
	 */
	if (LYforce_no_cache || force_load ||
	    are_different(&curdoc, &newdoc)) {
d970 131
a1100 7
		force_load = FALSE;  /* done */
		if (TRACE && LYCursesON) {
		    move(LYlines-1, LYcols-1);	/* make sure cursor is down */
#ifdef USE_SLANG
		    addstr("\n");
#endif /* USE_SLANG */
		    refresh();
d1102 1
a1102 1
try_again:
d1104 2
a1105 2
		 *  Push the old file onto the history stack if we
		 *  have a current doc and a new address. - FM
d1107 10
a1116 12
		if (curdoc.address && newdoc.address) {
		    /*
		     *	Don't actually push if this is a LYNXDOWNLOAD
		     *	URL, because that returns NORMAL even if it
		     *	fails due to a spoof attempt or file access
		     *	problem, and we set the newdoc structure
		     *	elements to the curdoc structure elements
		     *	under case NORMAL.  - FM
		     */
		    if (strncmp(newdoc.address, "LYNXDOWNLOAD:", 13))
		    {
			LYpush(&curdoc, ForcePush);
d1118 36
a1153 7
		} else if (!newdoc.address) {
		    /*
		     *	If newdoc.address is empty then pop a file
		     *	and load it.  - FM
		     */
		    LYpop(&newdoc);
		    popped_doc = TRUE;
d1155 36
a1190 22

#ifndef DONT_TRACK_INTERNAL_LINKS
#define NO_INTERNAL_OR_DIFFERENT(c,n) TRUE
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) (!curdoc.internal_link || \
			   are_phys_different(p,n))
#else /* TRACK_INTERNAL_LINKS */
#define NO_INTERNAL_OR_DIFFERENT(c,n) are_different(c,n)
#define NONINTERNAL_OR_PHYS_DIFFERENT(p,n) are_different(p,n)
#endif /* TRACK_INTERNAL_LINKS */


#ifndef DONT_TRACK_INTERNAL_LINKS
		    /*
		    ** If curdoc had been reached via an internal
		    ** (fragment) link from what we now have just
		    ** popped into newdoc, then override non-caching in
		    ** all cases. - kw
		    */
		    if (curdoc.internal_link &&
			!are_phys_different(&curdoc, &newdoc)) {
			LYinternal_flag = TRUE;
			LYoverride_no_cache = TRUE;
d1192 10
a1201 41
			try_internal = TRUE;
		    } else
#endif /* TRACK_INTERNAL_LINKS */
			/*
			 * Force a no_cache override unless
			 *  it's a bookmark file, or it has POST content
			 *  and LYresubmit_posts is set without safe also
			 *  set, and we are not going to another position
			 *  in the current document or restoring the previous
			 *  document due to a NOT_FOUND or NULLFILE return
			 *  value from getfile(). - FM
			 */
			if ((newdoc.bookmark != NULL) ||
			(newdoc.post_data != NULL &&
			 !newdoc.safe &&
			 LYresubmit_posts &&
			 !override_LYresubmit_posts &&
			    NO_INTERNAL_OR_DIFFERENT(&curdoc, &newdoc))) {
			LYoverride_no_cache = FALSE;
		    } else {
			LYoverride_no_cache = TRUE;
		    }
		}
		override_LYresubmit_posts = FALSE;

		if (HEAD_request) {
		    /*
		     *	Make SURE this is an appropriate request. - FM
		     */
		    if (newdoc.address) {
			if (LYCanDoHEAD(newdoc.address) == TRUE) {
			    newdoc.isHEAD = TRUE;
			} else if (!strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			    if (LYCanDoHEAD(newdoc.address + 11) == TRUE) {
				StrAllocCopy(temp, newdoc.address + 11);
				FREE(newdoc.address);
				newdoc.address = temp;
				newdoc.isHEAD = TRUE;
				temp = NULL;
			    }
			}
a1202 2
		    try_internal = FALSE;
		    HEAD_request = FALSE;
a1203 1

d1205 8
a1212 4
		 *  If we're getting the TRACE log and it's not new,
		 *  check whether its HText structure has been dumped,
		 *  and if so, fflush() and fclose() it to ensure it's
		 *  fully updated, and then fopen() it again. - FM
d1214 87
a1300 22
		if (LYUseTraceLog == TRUE &&
		    trace_mode_flag == FALSE &&
		    LYTraceLogFP != NULL &&
		    !strcmp((newdoc.title ? newdoc.title : ""),
			     LYNX_TRACELOG_TITLE)) {
		    DocAddress WWWDoc;
		    HTParentAnchor *tmpanchor;

		    WWWDoc.address = newdoc.address;
		    WWWDoc.post_data = newdoc.post_data;
		    WWWDoc.post_content_type = newdoc.post_content_type;
		    WWWDoc.bookmark = newdoc.bookmark;
		    WWWDoc.isHEAD = newdoc.isHEAD;
		    WWWDoc.safe = newdoc.safe;
		    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
		    if ((HText *)HTAnchor_document(tmpanchor) == NULL) {
			if (!LYReopenTracelog(&trace_mode_flag)) {
			    old_c = 0;
			    cmd = LYK_PREV_DOC;
			    goto new_cmd;
			}
		    }
d1303 7
a1309 10
		LYRequestTitle = newdoc.title;
		if (newdoc.bookmark)
		    LYforce_HTML_mode = TRUE;
		if (LYValidate &&
		    startfile_ok &&
		    newdoc.address && startfile && homepage &&
		    (!strcmp(newdoc.address, startfile) ||
		     !strcmp(newdoc.address, homepage))) {
		    LYPermitURL = TRUE;
		}
d1311 5
a1315 19
		Newline = newdoc.line; /* bypass for partial mode */
#ifdef DISP_PARTIAL
		display_partial = display_partial_flag; /* restore */
		Newline_partial = Newline;  /* initialize */
		/*
		 * Disable display_partial if requested URL has #fragment
		 * and we are not popped from the history stack
		 * so can't calculate correct newline position for fragment.
		 * Otherwise user got the new document from the first page
		 * and be moved to #fragment later after download
		 * completed, but only if s/he did not mess screen up by
		 * scrolling before...  So fall down to old behavior here.
		 */
		if (Newline_partial == 1 && strchr(newdoc.address, '#'))
		    display_partial = FALSE;
#endif /* DISP_PARTIAL */
#ifdef USE_PSRC
		psrc_first_tag = TRUE;
#endif
d1317 63
a1379 25
		if (try_internal) {
		    if (newdoc.address &&
			0==strncmp(newdoc.address, "LYNXIMGMAP:", 11)) {
			try_internal = FALSE;
		    } else if (curdoc.address &&
			0==strncmp(curdoc.address, "LYNXIMGMAP:", 11)) {
			try_internal = FALSE;
		    }
		}
		if (try_internal) {
		    char *hashp = strchr(newdoc.address,'#');
		    if (hashp) {
			HTFindPoundSelector(hashp+1);
		    }
		    getresult = (HTMainText != NULL) ? NORMAL : NOT_FOUND;
		    try_internal = FALSE; /* done */
		    /* fix up newdoc.address which may have been fragment-only */
		    if (getresult == NORMAL && (!hashp || hashp == newdoc.address)) {
			if (!hashp) {
			    StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
			} else {
			    StrAllocCopy(temp, HTLoadedDocumentURL());
			    StrAllocCat(temp, hashp); /* append fragment */
			    StrAllocCopy(newdoc.address, temp);
			    FREE(temp);
d1382 7
a1388 18
		} else {
		    if (newdoc.internal_link && newdoc.address &&
			*newdoc.address == '#' && nhist > 0) {
			char *cp0;
			if (0==strncmp(history[nhist-1].address, "LYNXIMGMAP:", 11))
			    cp0 = history[nhist-1].address + 11;
			else
			    cp0 = history[nhist-1].address;
			StrAllocCopy(temp, cp0);
			cp0 = strchr(temp, '#');
			if (cp0)
			    *cp0 = '\0';
			StrAllocCat(temp, newdoc.address);
			FREE(newdoc.address);
			newdoc.address = temp;
			temp = NULL;
		    }
		    getresult = getfile(&newdoc);
d1390 13
a1402 2
#else  /* TRACK_INTERNAL_LINKS */
		getresult = getfile(&newdoc);
d1404 81
d1486 7
a1492 1
		switch(getresult) {
d1494 6
a1499 31
		case NOT_FOUND:
		    /*
		     *	OK! can't find the file, so it must not be around now.
		     *	Do any error logging, if appropriate.
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    if (trace_mode_flag == TRUE) {
			WWW_TraceFlag = TRUE;
			trace_mode_flag = FALSE;
			fprintf(tfp, "Turning TRACE back on.\n\n");
		    }
		    if (error_logging &&
			first_file && owner_address && !LYCancelledFetch) {
			/*
			 *  Email a bad link message to the owner of
			 *  the document (but NOT to lynx-dev). - FM
			 */
			if (strncasecomp(owner_address, "mailto:", 7)) {
			    if (strncasecomp((owner_address + 7),
					     "lynx-dev@@", 9)) {
				mailmsg(curdoc.link,
					(owner_address+7),
					history[nhist-1].address,
					history[nhist-1].title);
			    }
			}
		    }
		    if (traversal && !first_file && !LYCancelledFetch) {
			FILE *ofp;
d1501 7
a1507 12
			if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
			    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
				perror(NOOPEN_TRAV_ERR_FILE);
				exit_immediately(-1);
			    }
			}
			fprintf(ofp, "%s %s\tin %s\n",
				     links[curdoc.link].lname,
				     links[curdoc.link].target,
				     history[nhist-1].address);
			fclose(ofp);
		    }
d1509 53
d1563 1
a1563 3
		     *	Fall through to do the NULL stuff and reload the
		     *	old file, unless the first file wasn't found or
		     *	has gone missing.
d1565 3
a1567 9
		    if (!nhist) {
			/*
			 *  If nhist = 0 then it must be the first file.
			 */
			exit_immediately_with_error_message(NOT_FOUND, first_file);
			return(-1);
		    }

		case NULLFILE:
d1569 4
a1572 1
		     *	Not supposed to return any file.
d1574 7
a1580 30
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    popped_doc = FALSE;		 /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    if (trace_mode_flag == TRUE) {
			WWW_TraceFlag = TRUE;
			trace_mode_flag = FALSE;
			fprintf(tfp, "Turning TRACE back on.\n\n");
		    }
		    FREE(newdoc.address); /* to pop last doc */
		    FREE(newdoc.bookmark);
		    LYJumpFileURL = FALSE;
		    reloading = FALSE;
		    LYPermitURL = FALSE;
		    LYCancelledFetch = FALSE;
		    ForcePush = FALSE;
		    LYforce_HTML_mode = FALSE;
		    if (traversal) {
			crawl_ok = FALSE;
			if (traversal_link_to_add) {
			    /*
			     *	It's a binary file, or the fetch attempt
			     *	failed.  Add it to TRAVERSE_REJECT_FILE
			     *	so we don't try again in this run.
			     */
			    if (!lookup_reject(traversal_link_to_add)) {
				add_to_reject_list(traversal_link_to_add);
			    }
			    FREE(traversal_link_to_add);
			}
		    }
d1582 1
a1582 2
		     *  Make sure the first file was found and
		     *  has not gone missing.
d1584 140
a1723 1
		    if (!nhist) {
d1725 1
a1725 1
			 *  If nhist = 0 then it must be the first file.
d1727 144
a1870 1
			if (first_file && homepage &&
d1872 106
a1977 1
			   strcasecomp(homepage, startfile) != 0
d1979 10
a1988 1
			   strcmp(homepage, startfile) != 0
d1990 47
a2036 24
			   ) {
			   /*
			    *  Couldn't return to the first file but there is a
			    *  homepage we can use instead. Useful for when the
			    *  first URL causes a program to be invoked. - GL
			    *
			    *  But first make sure homepage is different from
			    *  startfile (above), then make it the same (below)
			    *  so we don't enter an infinite getfile() loop on
			    *  on failures to find the files. - FM
			    */
			   StrAllocCopy(newdoc.address, homepage);
			   FREE(newdoc.post_data);
			   FREE(newdoc.post_content_type);
			   FREE(newdoc.bookmark);
			   StrAllocCopy(startfile, homepage);
			   newdoc.isHEAD = FALSE;
			   newdoc.safe = FALSE;
			   newdoc.internal_link = FALSE;
			   goto try_again;
			} else {
			   exit_immediately_with_error_message(NULLFILE, first_file);
			   return(-1);
			}
d2038 123
d2162 2695
a4856 48
		   /*
		    *  Retrieval of a newdoc just failed, and just
		    *  going to try_again would pop the next doc
		    *  from history and try to get it without further
		    *  questions.  This may not be the right thing to do if
		    *  we have POST data, so fake a PREV_DOC key if it seems
		    *  that some prompting should be done.  Dunno about the
		    *  traversal logic, so I leave that case alone.
		    */
		   if (history[nhist - 1].post_data &&
		       !history[nhist - 1].safe) {
		       if (HText_POSTReplyLoaded((document *)&history[(nhist - 1)])) {
			   override_LYresubmit_posts = TRUE;
			   goto try_again;
		       }
		       /*  Set newdoc fields, just in case the PREV_DOC
			*  gets cancelled. - kw */
		       if (!curdoc.address) {
			   StrAllocCopy(newdoc.address, HTLoadedDocumentURL());
			   StrAllocCopy(newdoc.title, HTLoadedDocumentTitle());
			   if (HTMainAnchor && HTMainAnchor->post_data) {
			       StrAllocCopy(newdoc.post_data,
					    HTMainAnchor->post_data);
			       StrAllocCopy(newdoc.post_content_type,
					    HTMainAnchor->post_content_type);
			   } else {
			       FREE(newdoc.post_data);
			   }
			   newdoc.isHEAD = HTLoadedDocumentIsHEAD();
			   newdoc.safe = HTLoadedDocumentIsSafe();
			   newdoc.internal_link = FALSE;
		       } else {
			   StrAllocCopy(newdoc.address, curdoc.address);
			   StrAllocCopy(newdoc.title, curdoc.title);
			   StrAllocCopy(newdoc.post_data, curdoc.post_data);
			   StrAllocCopy(newdoc.post_content_type,
					curdoc.post_content_type);
			   newdoc.isHEAD = curdoc.isHEAD;
			   newdoc.safe = curdoc.safe;
			   newdoc.internal_link = curdoc.internal_link;
			   newdoc.line = curdoc.line;
			   newdoc.link = curdoc.link;
		       }
		       cmd = LYK_PREV_DOC;
		       goto new_cmd;
		    }
		    override_LYresubmit_posts = TRUE;
		    goto try_again;
d4858 29
a4886 12
		case NORMAL:
		    /*
		     *	Marvelously, we got the document!
		     */
		    LYoverride_no_cache = FALSE; /* Was TRUE if popped. - FM */
		    LYinternal_flag = FALSE;	 /* Reset to default. - kw */
		    if (trace_mode_flag == TRUE) {
			WWW_TraceFlag = TRUE;
			trace_mode_flag = FALSE;
			fprintf(tfp, "Turning TRACE back on.\n\n");
		    }
		    *prev_target = '\0';    /* Reset for this document. - FM */
d4888 14
a4901 99
		    /*
		     *	If it's the first file and we're interactive,
		     *	check whether it's a bookmark file which was
		     *	not accessed via the -book switch. - FM
		     */
		    if (((first_file == TRUE) &&
			 (dump_output_immediately == FALSE) &&
			 !(newdoc.bookmark && *newdoc.bookmark)) &&
			((LYisLocalFile(newdoc.address) == TRUE) &&
			 !(strcmp((HText_getTitle() ? HText_getTitle() : ""),
				  BOOKMARK_TITLE))) &&
			(temp = HTParse(newdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION)) != NULL) {
			cp = wwwName(Home_Dir());
			len = strlen(cp);
#ifdef VMS
			if (!strncasecomp(temp, cp, len) &&
			    strlen(temp) > len)
#else
			if (!strncmp(temp, cp, len) &&
			    strlen(temp) > len)
#endif /* VMS */
			{
			    /*
			     *	We're interactive and this might be a
			     *	bookmark file entered as a startfile
			     *	rather than invoked via -book.	Check
			     *	if it's in our bookmark file list, and
			     *	if so, reload if with the relevant
			     *	bookmark elements set. - FM
			     */
			    if ((cp = (char *)calloc(1,
				  (strlen((char *)&temp[len]) + 2))) == NULL)
				outofmem(__FILE__, "mainloop");
			    if (temp[len] == '/') {
				if (strchr((char *)&temp[(len + 1)], '/')) {
				    sprintf(cp, ".%s", (char *)&temp[len]);
				} else {
				    strcpy(cp, (char *)&temp[(len + 1)]);
				}
			    } else {
				strcpy(cp, (char *)&temp[len]);
			    }
			    for (i = 0; i <= MBM_V_MAXFILES; i++) {
				if (MBM_A_subbookmark[i] &&
#ifdef VMS
				    !strcasecomp(cp, MBM_A_subbookmark[i])
#else
				    !strcmp(cp, MBM_A_subbookmark[i])
#endif /* VMS */
				    ) {
				    StrAllocCopy(BookmarkPage,
						 MBM_A_subbookmark[i]);
				    break;
				}
			    }
			    FREE(cp);
			    if (i <= MBM_V_MAXFILES) {
				FREE(temp);
				if (LYValidate) {
				    HTAlert(BOOKMARKS_DISABLED);
				    return(-1);
				}
				if ((temp = HTParse(newdoc.address, "",
				 PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION))) {
				    StrAllocCopy(newdoc.address, temp);
				    HTuncache_current_document();
				    FREE(curdoc.address);
				    StrAllocCat(newdoc.address,
					    wwwName(Home_Dir()));
				    StrAllocCat(newdoc.address, "/");
				    StrAllocCat(newdoc.address,
					(strncmp(BookmarkPage, "./", 2) ?
							   BookmarkPage :
							(BookmarkPage + 2)));
				    StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
				    StrAllocCopy(newdoc.bookmark, BookmarkPage);
#ifdef USE_HASH
				    if (curdoc.style)
					StrAllocCopy(newdoc.style, curdoc.style);
#endif
				    StrAllocCopy(startrealm, newdoc.address);
				    FREE(newdoc.post_data);
				    FREE(newdoc.post_content_type);
				    newdoc.isHEAD = FALSE;
				    newdoc.safe = FALSE;
				    FREE(temp);
				    if (!strcmp(homepage, startfile))
					StrAllocCopy(homepage, newdoc.address);
				    StrAllocCopy(startfile, newdoc.address);
				    CTRACE(tfp, "Reloading as bookmarks=%s\n",
						newdoc.address);
				    goto try_again;
				}
			    }
			}
			cp = NULL;
		    }
		    FREE(temp);
d4903 62
a4964 13
		    if (traversal) {
			/*
			 *  During traversal build up lists of all links
			 *  traversed.	Traversal mode is a special
			 *  feature for traversing http links in the web.
			 */
			if (traversal_link_to_add) {
			    /*
			     *	Add the address we sought to TRAVERSE_FILE.
			     */
			    if (!lookup(traversal_link_to_add))
				add_to_table(traversal_link_to_add);
			    FREE(traversal_link_to_add);
a4965 6
			if (curdoc.address && curdoc.title &&
			    strncmp(curdoc.address, "LYNXIMGMAP:", 11))
			    /*
			     *	Add the address we got to TRAVERSE_FOUND_FILE.
			     */
			    add_to_traverse_list(curdoc.address, curdoc.title);
d4967 36
d5004 25
d5030 1
a5030 3
		     *	If this was a LYNXDOWNLOAD, we still have curdoc,
		     *	not a newdoc, so reset the address, title and
		     *	positioning elements. - FM
d5032 54
a5085 10
		    if (newdoc.address && curdoc.address &&
			!strncmp(newdoc.address, "LYNXDOWNLOAD:", 13)) {
			StrAllocCopy(newdoc.address, curdoc.address);
			StrAllocCopy(newdoc.title, (curdoc.title ?
						    curdoc.title : ""));
			StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			newdoc.line = curdoc.line;
			newdoc.link = curdoc.link;
			newdoc.internal_link = FALSE; /* can't be true. - kw */
		    }
d5087 8
a5094 9
		    /*
		     *	Set Newline to the saved line.	It contains the
		     *	line the user was on if s/he has been in the file
		     *	before, or it is 1 if this is a new file.
		     */
#ifdef DISP_PARTIAL
		    /* Newline = newdoc.line; */
		    /* - alreary set and probably updated in partial mode */
		    /* incremental rendering stage already closed (but see below) */
d5096 7
a5102 11
		    if (Newline != Newline_partial || display_partial == TRUE) {
		       /* This is the case when we came from the history stack
			* _and_ cached HText was used instead of HT*Copy() call.
			* Set Newline and close partial mode here.
			*/
		       Newline = Newline_partial;
		       display_partial = FALSE;
		    }
#else
		    Newline = newdoc.line; /* now here, no partial mode */
#endif
d5104 23
a5126 7
		    /*
		     *	If we are going to a target line or
		     *	the first page of a popped document,
		     *	override any www_search line result.
		     */
		    if (Newline > 1 || popped_doc == TRUE)
			 www_search_result = -1;
d5128 2
a5129 14
		    /*
		     *	Make sure curdoc.line will not be equal
		     *	to Newline, so we get a redraw.
		     */
		    curdoc.line = -1;
#ifdef USE_PSRC
		    if (psrc_view)
			HTMark_asSource(); /* this flag is not set, since when
			displaying source, psrc_view is temporary unset when
			writing the HTML header - and HTMainText is created
			at that time.*/
#endif
		    break;
		}  /* end switch */
d5131 11
a5141 4
	    if (TRACE) {
		if (!LYTraceLogFP || trace_mode_flag) {
		    sleep(AlertSecs); /* allow me to look at the results */
		}
d5143 6
a5148 12

	    /*
	     *	Set the files the same.
	     */
	    StrAllocCopy(curdoc.address, newdoc.address);
	    StrAllocCopy(curdoc.post_data, newdoc.post_data);
	    StrAllocCopy(curdoc.post_content_type, newdoc.post_content_type);
	    StrAllocCopy(curdoc.bookmark, newdoc.bookmark);
#ifdef USE_HASH
	    StrAllocCopy(curdoc.style, HText_getStyle());
	    if (curdoc.style != NULL)
		style_readFromFile (curdoc.style);
a5149 2
	    curdoc.isHEAD = newdoc.isHEAD;
	    curdoc.internal_link = newdoc.internal_link;
d5151 17
a5167 24
	    /*
	     *	Set the remaining document elements and add to
	     *	the visited links list. - FM
	     */
	    if (ownerS_address != NULL) {
#ifndef USE_PSRC
		if (HTOutputFormat == WWW_SOURCE && !HText_getOwner())
#else
		if ( (LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE)
			&& !HText_getOwner() )
#endif
		    HText_setMainTextOwner(ownerS_address);
		FREE(ownerS_address);
	    }
	    if (HText_getTitle()) {
		StrAllocCopy(curdoc.title, HText_getTitle());
	    } else if (!dump_output_immediately) {
		StrAllocCopy(curdoc.title, newdoc.title);
	    }
	    StrAllocCopy(owner_address, HText_getOwner());
	    curdoc.safe = HTLoadedDocumentIsSafe();
	    if (!dump_output_immediately) {
		LYAddVisitedLink(&curdoc);
	    }
d5169 9
d5179 13
a5191 8
	   /*
	    *  Reset WWW present mode so that if we were getting
	    *  the source, we get rendered HTML from now on.
	    */
	   HTOutputFormat = WWW_PRESENT;
#ifdef USE_PSRC
	   psrc_view = FALSE;
#endif
d5193 9
a5201 1
	   HTMLSetCharacterHandling(current_char_set);	/* restore, for sure? */
d5203 26
a5228 12
	   /*
	    *  Reset all of the other relevant flags. - FM
	    */
	   LYUserSpecifiedURL = FALSE;	/* only set for goto's and jumps's */
	   LYJumpFileURL = FALSE;	/* only set for jump's */
	   LYNoRefererForThis = FALSE;	/* always reset on return here */
	   reloading = FALSE;		/* only set for RELOAD and RESUBMIT */
	   HEAD_request = FALSE;	/* only set for HEAD requests */
	   LYPermitURL = FALSE;		/* only set for LYValidate */
	   ForcePush = FALSE;		/* only set for some PRINT requests. */
	   LYforce_HTML_mode = FALSE;
	   popped_doc = FALSE;
d5230 2
a5231 1
	} /* end if (LYforce_no_cache || force_load || are_different(...)) */
d5233 15
a5247 8
	if (dump_output_immediately) {
	    if (crawl) {
		print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
	    } else {
		print_wwwfile_to_fd(stdout,0);
	    }
	    return(0);
	}
d5249 7
a5255 18
	/*
	 *  If the recent_sizechange variable is set to TRUE
	 *  then the window size changed recently.
	 */
	if (recent_sizechange) {
		stop_curses();
		start_curses();
		clear();
		refresh_screen = TRUE; /* to force a redraw */
		if (HTMainText)	/* to REALLY force it... - kw */
		    HText_setStale(HTMainText);
		recent_sizechange = FALSE;
		if (user_mode == NOVICE_MODE) {
		    display_lines = LYlines-4;
		} else {
		    display_lines = LYlines-2;
		}
	}
d5257 8
a5264 8
	if (www_search_result != -1) {
	     /*
	      *  This was a WWW search, set the line
	      *  to the result of the search.
	      */
	     Newline = www_search_result;
	     www_search_result = -1;  /* reset */
	}
d5266 6
a5271 5
	if (first_file == TRUE) {
	    /*
	     *	We can never again have the first file.
	     */
	    first_file = FALSE;
d5273 35
a5307 35
	    /*
	     *	Set the startrealm, and deal as best we can
	     *	with preserving forced HTML mode for a local
	     *	startfile. - FM
	     */
	    temp = HTParse(curdoc.address, "",
			   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
	    if (!temp || *temp == '\0') {
		StrAllocCopy(startrealm, NO_NOTHING);
	    } else {
		StrAllocCopy(startrealm, temp);
		FREE(temp);
		if (!(temp = HTParse(curdoc.address, "",
				     PARSE_PATH+PARSE_PUNCTUATION))) {
		    LYAddHtmlSep(&startrealm);
		} else {
		    if (forced_HTML_mode &&
			!dump_output_immediately &&
			!curdoc.bookmark &&
			!strncasecomp(curdoc.address, "file:", 5) &&
			strlen(temp) > 1) {
			/*
			 *  We forced HTML for a local startfile which
			 *  is not a bookmark file and has a path of at
			 *  least two letters.	If it doesn't have a
			 *  suffix mapped to text/html, we'll set the
			 *  entire path (including the lead slash) as a
			 *  "suffix" mapped to text/html to ensure it is
			 *  always treated as an HTML source file.  We
			 *  are counting on a tail match to this full path
			 *  for some other URL fetched during the session
			 *  having too low a probability to worry about,
			 *  but it could happen. - FM
			 */
			HTAtom *encoding;
d5309 40
a5348 67
			if (HTFileFormat(temp, &encoding, NULL) != WWW_HTML) {
			    HTSetSuffix(temp, "text/html", "8bit", 1.0);
			}
		    }
		    if ((cp = strrchr(temp, '/')) != NULL) {
			*(cp+1) = '\0';
			StrAllocCat(startrealm, temp);
		    }
		}
	    }
	    FREE(temp);
	    CTRACE(tfp, "Starting realm is '%s'\n\n", startrealm);
	    if (traversal) {
		/*
		 *  Set up the crawl output stuff.
		 */
		if (curdoc.address && !lookup(curdoc.address)) {
		    if (strncmp(curdoc.address, "LYNXIMGMAP:", 11))
			crawl_ok = TRUE;
		    add_to_table(curdoc.address);
		}
		/*
		 *  Set up the traversal_host comparison string.
		 */
		if (strncmp((curdoc.address ? curdoc.address : "NULL"),
			    "http", 4)) {
		    StrAllocCopy(traversal_host, NO_NOTHING);
		} else if (check_realm) {
		    StrAllocCopy(traversal_host, startrealm);
		} else {
		    temp = HTParse(curdoc.address, "",
				   PARSE_ACCESS+PARSE_HOST+PARSE_PUNCTUATION);
		    if (!temp || *temp == '\0') {
			StrAllocCopy(traversal_host, NO_NOTHING);
		    } else {
			StrAllocCopy(traversal_host, temp);
			LYAddHtmlSep(&traversal_host);
		    }
		    FREE(temp);
		}
		CTRACE(tfp, "Traversal host is '%s'\n\n", traversal_host);
	    }
	    if (startfile) {
		/*
		 *  If homepage was not equated to startfile,
		 *  make the homepage URL the first goto
		 *  entry. - FM
		 */
		if (homepage && strcmp(startfile, homepage))
		    HTAddGotoURL(homepage);
		/*
		 *  If we are not starting up with startfile
		 *  (e.g., had -book), or if we are using the
		 *  startfile and it has no POST content, make
		 *  the startfile URL a goto entry. - FM
		 */
		if (strcmp(startfile, newdoc.address) ||
		    newdoc.post_data == NULL)
		    HTAddGotoURL(startfile);
	    }
	    if (TRACE) {
		refresh_screen = TRUE;
		if (!LYTraceLogFP || trace_mode_flag) {
		    sleep(AlertSecs);
		}
	    }
	}
d5350 7
a5356 24
#ifdef SOURCE_CACHE
	/*
	 * If the parse settings have changed since this HText was
	 * generated, we need to reparse and redraw it.  -dsb
	 *
	 * Should be configured to avoid shock for experienced lynx users.
	 * Currently enabled for cached sources only.
	 */
	if (HTdocument_settings_changed()) {
	   if (HTcan_reparse_document()) {
	       HTUserMsg(gettext("Reparsing document under current settings..."));
	       if (HTreparse_document()) {}
	   } else {
		/*
		 * Urk.  I have no idea how to recover from a failure here.
		 * At a guess, I'll try reloading.  -dsb
		 */
			/*  currently disabled ***
		HTUserMsg(gettext("Reparsing document under current settings..."));
		cmd = LYK_RELOAD;
		goto new_cmd;
			*/
	    }
	}
d5358 7
a5364 8
	/*
	 *  Trying to accomodate HTreparse_document() logic
	 *  with mainloop events.  Working out of force_load cycle
	 *  set all the necessary flags here, from case NORMAL
	 *  (see also LYK_SOURCE, some staff implemented directly there).
	 */
	if (from_source_cache) {
	    from_source_cache = FALSE; /* done */
d5366 12
d5379 2
a5380 2
	     *	Make sure curdoc.line will not be equal
	     *	to Newline, so we get a redraw.
d5382 17
a5398 1
	    curdoc.line = -1;
d5400 2
a5401 2
	}
#endif
d5403 4
d5408 4
d5413 2
a5414 4
	 *  If the curdoc.line is different than Newline then there must
	 *  have been a change since last update.  Run HText_pageDisplay()
	 *  create a fresh screen of text out.
	 *  All display_partial calls ends here for final redraw.
d5416 36
a5451 1
	if (curdoc.line != Newline) {
a5452 1
	    refresh_screen = FALSE;
a5453 1
	    HText_pageDisplay(Newline, prev_target);
d5455 38
a5492 4
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
	      showtags(tagged);
#endif /* DIRED_SUPPORT */
d5494 20
a5513 5
	    /*
	     *  If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
	    curdoc.line = Newline = HText_getTopOfScreen()+1;
a5514 1
	    if (curdoc.title == NULL) {
d5516 4
a5519 2
		 *  If we don't yet have a title, try to get it,
		 *  or set to that for newdoc.title. - FM
d5521 21
a5541 4
		if (HText_getTitle()) {
		    StrAllocCopy(curdoc.title, HText_getTitle());
		} else {
		    StrAllocCopy(curdoc.title, newdoc.title);
a5542 1
	    }
d5544 9
a5552 18
	    if (arrowup) {
		/*
		 *  arrowup is set if we just came up from
		 *  a page below.
		 */
		curdoc.link = nlinks - 1;
		arrowup = FALSE;
	    } else {
		curdoc.link = newdoc.link;
		if (curdoc.link >= nlinks) {
		    curdoc.link = nlinks - 1;
		} else if (curdoc.link < 0 && nlinks > 0) {
		    /*
		     *	We may have popped a doc (possibly in local_dired)
		     *	which didn't have any links when it was pushed, but
		     *	does have links now (e.g., a file was created) - KW
		     */
		    curdoc.link = 0;
a5553 1
	    }
d5555 6
a5560 5
	    show_help = FALSE; /* reset */
	    newdoc.line = 1;
	    newdoc.link = 0;
	    curdoc.line = Newline; /* set */
	}
d5562 16
a5577 14
	/*
	 *  Refresh the screen if necessary.
	 */
	if (refresh_screen) {
#if defined(FANCY_CURSES) || defined (USE_SLANG)
	    if (enable_scrollback) {
		clear();
	    } else {
		erase();
	    }
#else
	    clear();
#endif /* FANCY_CURSES || USE_SLANG */
	    HText_pageDisplay(Newline, prev_target);
d5579 50
a5628 4
#ifdef DIRED_SUPPORT
	    if (lynx_edit_mode && nlinks > 0 && !HTList_isEmpty(tagged))
		showtags(tagged);
#endif /* DIRED_SUPPORT */
d5630 3
a5632 4
	    /*
	     *  If more equals TRUE, then there is more info below this page.
	     */
	    more = HText_canScrollDown();
d5634 1
a5634 3
	    if (user_mode == NOVICE_MODE)
		noviceline(more);  /* print help message */
	    refresh_screen = FALSE;
d5636 47
a5682 1
	}
d5684 23
a5706 5
	/*
	 *  Report unread or new mail, if appropriate.
	 */
	if (check_mail && !no_mail)
	    LYCheckMail();
d5708 13
a5720 10
	/*
	 *  If help is not on the screen,
	 *  then put a message on the screen
	 *  to tell the user other misc info.
	 */
	if (!show_help) {
	   print_status_message(links[curdoc.link], &cp);
	} else {
	   show_help = FALSE;
	}
d5722 30
a5751 38
	if (!(nlinks > 0 &&
	      links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
	      (links[curdoc.link].form->type == F_TEXT_TYPE ||
	       links[curdoc.link].form->type == F_TEXTAREA_TYPE)))
	     /*
	      *  Highlight current link.
	      */
	    highlight(ON, curdoc.link, prev_target);

	if (traversal) {
	    /*
	     *	Don't go interactively into forms,
	     *	or accept keystrokes from the user
	     */
	    if (crawl && crawl_ok) {
		crawl_ok = FALSE;
#ifdef FNAMES_8_3
		sprintf(cfile,"lnk%05d.dat",ccount);
#else
		sprintf(cfile,"lnk%08d.dat",ccount);
#endif /* FNAMES_8_3 */
		ccount = ccount + 1;
		if ((cfp = LYNewTxtFile(cfile))  != NULL) {
		    print_crawl_to_fd(cfp,curdoc.address,curdoc.title);
		    fclose(cfp);
		} else {
		    if (!dump_output_immediately)
			cleanup();
#ifdef UNIX
		    if (dump_output_immediately)
			fprintf(stderr,
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    else
#endif
			printf(
			gettext("Fatal error - could not open output file %s\n"),cfile);
		    if (!dump_output_immediately) {
			exit_immediately(-1);
a5752 29
		    return(-1);
		}
	    }
	} else {
	    /*
	     *	Normal, non-traversal handling.
	     */
	    if (nlinks > 0 &&
		links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		(links[curdoc.link].form->type == F_TEXT_TYPE ||
		 links[curdoc.link].form->type == F_TEXT_SUBMIT_TYPE ||
		 links[curdoc.link].form->type == F_PASSWORD_TYPE ||
		 links[curdoc.link].form->type == F_TEXTAREA_TYPE)) {
		/*
		 *  Replace novice lines if in NOVICE_MODE.
		 */
		if (user_mode==NOVICE_MODE) {
		    move(LYlines-2,0); clrtoeol();
		    addstr(FORM_NOVICELINE_ONE);
		    move(LYlines-1,0); clrtoeol();
		    addstr(FORM_NOVICELINE_TWO);
		}
		c = change_form_link(&links[curdoc.link],
				     &newdoc, &refresh_screen,
				     links[curdoc.link].form->name,
				     links[curdoc.link].form->value);

		if (c == '\n' || c == '\r') {
#ifdef AUTOGROW
d5754 33
a5786 36
		     *  If on the bottom line of a TEXTAREA, and the user hit
		     *  the ENTER key, we add a new line/anchor automatically,
		     *  positioning the cursor on it.
		     *
		     *  If at the bottom of the screen, we effectively perform
		     *  an LYK_DOWN_HALF-like operation, then move down to the
		     *  new line we just added.  --KED  02/14/99
		     *
		     *  [There is some redundancy and non-standard indentation
		     *   in the monster-if() below.  This is intentional ... to
		     *   try and improve the "readability" (such as it is).
		     *   Caveat emptor to anyone trying to change it.]
		     */
		    if ((links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
			 links[curdoc.link].form->type == F_TEXTAREA_TYPE)
			&&
			 ((curdoc.link == nlinks-1)
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  !(links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE))
			 ||
			 ((curdoc.link <  nlinks-1) &&
			  ((links[curdoc.link+1].type == WWW_FORM_LINK_TYPE  &&
			    links[curdoc.link+1].form->type == F_TEXTAREA_TYPE)
			    &&
			    ((links[curdoc.link].form->number	       !=
				      links[curdoc.link+1].form->number)     ||
			     (strcmp (links[curdoc.link].form->name,
				      links[curdoc.link+1].form->name) != 0)))))) {

			HText_ExpandTextarea (&links[curdoc.link], 1);

			if (links[curdoc.link].ly < display_lines) {
			    refresh_screen = TRUE;

d5788 4
d5793 58
a5850 11
			    Newline += (display_lines/2);
			    if (nlinks > 0 && curdoc.link > -1 &&
				links[curdoc.link].ly > display_lines/2) {
				    newdoc.link = curdoc.link;
				    for (i = 0; links[i].ly <= (display_lines/2); i++)
					--newdoc.link;
				    newdoc.link++;
			    }
			}
		   }
#endif /* AUTOGROW */
d5852 1
a5852 1
#ifdef FASTTAB
d5854 1
a5854 1
		     *	Make return act like down-arrow.
d5856 3
a5858 15
		    c = DNARROW;
#else
		    /*
		     *	Make return act like tab.
		     */
		    c = '\t';
#endif /* FASTTAB */
		}
	    } else {
		/*
		 *  Get a keystroke from the user.
		 *  Save the last keystroke to avoid
		 *  redundant error reporting.
		 */
		real_c = c = LYgetch(); /* get user input */
a5859 2
#ifndef VMS
		if (c == 3) {		/* ^C */
d5861 3
a5863 2
		     *	This shouldn't happen.	We'll try to
		     *	deal with whatever bug caused it. - FM
d5865 10
a5874 12
		    signal(SIGINT, cleanup_sig);
		    old_c = 0;
		    cmd = LYK_QUIT;
		    goto new_cmd;
		}
#endif /* !VMS */
		if (old_c != real_c) {
		    old_c = 0;
		}
	    }
	}

d5876 2
a5877 4
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    c = DO_NOTHING;
	}
d5879 2
a5880 4
	if (recent_sizechange) {
	    if (c <= 0)
		c = DO_NOTHING;
	}
d5882 1
a5882 156

new_keyboard_input:
	/*
	 *  A goto point for new input without going
	 *  back through the getch() loop.
	 */
	if (traversal) {
	    /*
	     *	This is a special feature to traverse every http link
	     *	derived from startfile and check for errors or create
	     *	crawl output files.  Only URL's that begin with
	     *	"traversal_host" are searched - this keeps the search
	     *	from crossing to other servers (a feature, not a bug!).
	     */
	    rlink_exists = (nlinks > 0 && links[curdoc.link].lname != NULL);
	    if (rlink_exists) {
		rlink_allowed =
		    (!lookup_reject(links[curdoc.link].lname) &&
		     traversal_host && links[curdoc.link].lname &&
		     !strncmp(traversal_host,
			      (strncmp(links[curdoc.link].lname,
				       "LYNXIMGMAP:", 11)
					 ?
		links[curdoc.link].lname : (links[curdoc.link].lname + 11)),
			      strlen(traversal_host)));
	    } else {
		rlink_allowed = FALSE;
	    }
	    if (rlink_exists && rlink_allowed) {
		if (lookup(links[curdoc.link].lname)) {
		    if (more_links ||
			(curdoc.link > -1 && curdoc.link < nlinks -1))
			 c= DNARROW;
		    else {
			if (STREQ(curdoc.title,"Entry into main screen") ||
			    (nhist <= 0 )) {
			    if (!dump_output_immediately) {
				cleanup();
				exit_immediately(-1);
			    }
			    return(-1);
			}
			c = LTARROW;
		    }
		} else {
		    StrAllocCopy(traversal_link_to_add,
				 links[curdoc.link].lname);
		    if (strncmp(traversal_link_to_add, "LYNXIMGMAP:", 11))
			crawl_ok = TRUE;
		    c = RTARROW;
		}
	    } else { /* no good right link, so only down and left arrow ok*/
		if (rlink_exists)
		    add_to_reject_list(links[curdoc.link].lname);
		if (more_links ||
		    (curdoc.link > -1 && curdoc.link < nlinks-1))
		    c = DNARROW;
		else {
		    /*
		     *	curdoc.title doesn't always work, so
		     *	bail out if the history list is empty.
		     */
		    if (STREQ(curdoc.title,"Entry into main screen") ||
			(nhist <= 0 )) {
			if (!dump_output_immediately) {
			    cleanup();
			    exit_immediately(-1);
			}
			return(-1);
		    }
		    c = LTARROW;
		}
	    } /* right link not NULL or link to another site*/
	} /* traversal */

	cmd = keymap[c+1];  /* add 1 to map EOF to 0 */

#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
	if (lynx_edit_mode && key_override[c+1] && !no_dired_support)
	  cmd = key_override[c+1];
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

	real_cmd = cmd;

new_cmd:  /*
	   *  A goto point for new input without going
	   *  back through the getch() loop.
	   */

	CTRACE_FLUSH(tfp);

	switch(cmd) {
	case 0: /* unmapped character */
	default:
	    if (more)
		_statusline(MOREHELP);
	    else
		_statusline(HELP);
	    show_help = TRUE;

	    if (TRACE) {
		sprintf(cfile, "%d", c);
		addstr(cfile);	/* show the user input */
		cfile[0] = '\0';
	    }
	    break;

	case LYK_INTERRUPT:
	    /*
	     *	No network transmission to interrupt - 'til we multithread.
	     */
	    break;

	case LYK_F_LINK_NUM:
	     c = '\0';
	case LYK_1:
	case LYK_2:
	case LYK_3:
	case LYK_4:
	case LYK_5:
	case LYK_6:
	case LYK_7:
	case LYK_8:
	case LYK_9:
	{
	    /*
	     *	Get a number from the user and follow that link number.
	     */
	    int lindx = ((nlinks > 0) ? curdoc.link : 0);
	    int number;

	    /* pass cur line num for use in follow_link_number()
	     * Note: Current line may not equal links[cur].line
	     */
	    number = curdoc.line;
	    switch (follow_link_number(c, lindx, &newdoc, &number)) {
	    case DO_LINK_STUFF:
		/*
		 *  Follow a normal link.
		 */
		StrAllocCopy(newdoc.address, links[lindx].lname);
		StrAllocCopy(newdoc.title, links[lindx].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
		/*
		 *  For internal links, retain POST content if present.
		 *  If we are on the List Page, prevent pushing it on
		 *  the history stack.	Otherwise set try_internal to
		 *  signal that the top of the loop should attempt to
		 *  reposition directly, without calling getfile. - kw
		 */
		if (links[lindx].type == WWW_INTERN_LINK_TYPE) {
		    LYinternal_flag = TRUE;
		    newdoc.internal_link = TRUE;
		    if (LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
			0==strcmp(HTLoadedDocumentURL(), LYlist_temp_url())) {
			if (!curdoc.post_data ||
d5884 6
a5889 2
			     *	Normal case - List Page is not associated
			     *	with post data. - kw
d5891 20
a5910 43
			    (!LYresubmit_posts && curdoc.post_data &&
			     history[nhist - 1].post_data &&
			     !strcmp(curdoc.post_data,
				     history[nhist - 1].post_data) &&
			     HText_getContentBase() &&
			     !strncmp(HText_getContentBase(),
				      strncmp(history[nhist - 1].address,
					      "LYNXIMGMAP:", 11) ?
				      history[nhist - 1].address :
				      history[nhist - 1].address + 11,
				      strlen(HText_getContentBase())))) {
			    /*
			     *	Normal case - as best as we can check, the
			     *	document at the top of the history stack
			     *	seems to be the document the List Page is
			     *	about (or a LYNXIMGMAP derived from it),
			     *	and LYresubmit_posts is not set, so don't
			     *	prompt here.  If we actually have to repeat
			     *	a POST because, against expectations, the
			     *	underlying document isn't cached any more,
			     *	HTAccess will prompt for confirmation,
			     *	unless we had LYK_NOCACHE. - kw
			     */
			    LYinternal_flag = TRUE;
			} else {
			    HTLastConfirmCancelled(); /* reset flag */
			    if (!confirm_post_resub(newdoc.address,
						    newdoc.title,
						    (LYresubmit_posts &&
						     HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
						    2)) {
				if (HTLastConfirmCancelled() ||
				    (LYresubmit_posts &&
				     !HText_POSTReplyLoaded(&newdoc))) {
				    /* cancel the whole thing */
				    LYforce_no_cache = FALSE;
				    reloading = FALSE;
				    StrAllocCopy(newdoc.address, curdoc.address);
				    StrAllocCopy(newdoc.title, curdoc.title);
				    newdoc.internal_link = curdoc.internal_link;
				    HTInfoMsg(CANCELLED);
				    if (nlinks > 0)
					HText_pageDisplay(curdoc.line, prev_target);
d5912 28
a5939 11
				} else if (LYresubmit_posts) {
				    /* If LYresubmit_posts is set, and the
				       answer was No, and we have a cached
				       copy, then use it. - kw */
				    LYforce_no_cache = FALSE;
				} else {
				    /* if No, but not ^C or ^G, drop
				     * the post data.  Maybe the link
				     * wasn't meant to be internal after
				     * all, here we can recover from that
				     * assumption. - kw */
d5942 9
a5950 2
				    newdoc.internal_link = FALSE;
				    HTAlert(DISCARDING_POST_DATA);
d5954 5
d5960 3
a5962 2
			 *  Don't push the List Page if we follow an
			 *  internal link given by it. - kw
d5964 1
a5964 42
			FREE(curdoc.address);
		    } else
			try_internal = TRUE;
		    if (!(LYresubmit_posts && newdoc.post_data))
			LYinternal_flag = TRUE;
		    force_load = TRUE;
		    break;
		} else {
		    /*
		     *	Free POST content if not an internal link. - kw
		     */
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		}
#endif /* DONT_TRACK_INTERNAL_LINKS */
		/*
		 *  Might be an anchor in the same doc from a POST
		 *  form.  If so, don't free the content. -- FM
		 */
		if (are_different(&curdoc, &newdoc)) {
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		}
		newdoc.internal_link = FALSE;
		force_load = TRUE;  /* force MainLoop to reload */
		break;

	    case DO_GOTOLINK_STUFF:
		/*
		 *  Position on a normal link, don't follow it. - KW
		 */
		Newline = newdoc.line;
		newdoc.line = 1;
		if (Newline == curdoc.line) {
		    /*
		     *	It's a link in the current page. - FM
		     */
		    if (nlinks > 0 && curdoc.link > -1) {
			if (curdoc.link == newdoc.link) {
d5966 1
a5966 4
			     *	It's the current link, and presumably
			     *	reflects a typo in the statusline entry,
			     *	so issue a statusline message for the
			     *	typo-prone users (like me 8-). - FM
d5968 6
a5973 7
			    StrAllocCopy(temp, user_input_buffer);
			    sprintf(user_input_buffer,
				    LINK_ALREADY_CURRENT, number);
			    HTUserMsg(user_input_buffer);
			    strcpy(user_input_buffer, temp);
			    FREE(temp);
			} else {
d5975 1
a5975 5
			     *	It's a different link on this page,
			     *	so turn the highlighting off, set the
			     *	current link to the new link value from
			     *	follow_link_number(), and re-initialize
			     *	the new link value. - FM
d5977 1
a5977 4
			    highlight(OFF, curdoc.link, prev_target);
			    curdoc.link = newdoc.link;
			    newdoc.link = 0;
			}
a5978 2
		}
		break;		/* nothing more to do */
a5979 7
	    case DO_GOTOPAGE_STUFF:
		/*
		 *  Position on a page in this document. - FM
		 */
		Newline = newdoc.line;
		newdoc.line = 1;
		if (Newline == curdoc.line) {
d5981 3
a5983 3
		     *	It's the current page, so issue a
		     *	statusline message for the typo-prone
		     *	users (like me 8-). - FM
d5985 9
a5993 11
		    if (Newline <= 1) {
			HTInfoMsg(ALREADY_AT_BEGIN);
		    } else if (!more) {
			HTInfoMsg(ALREADY_AT_END);
		    } else {
			StrAllocCopy(temp, user_input_buffer);
			sprintf(user_input_buffer,
				ALREADY_AT_PAGE, number);
			HTUserMsg(user_input_buffer);
			strcpy(user_input_buffer, temp);
			FREE(temp);
a5994 2
		}
		break;
d5996 17
a6012 35
	    case PRINT_ERROR:
		old_c = real_c;
		HTUserMsg(BAD_LINK_NUM_ENTERED);
		break;
	    }
	    break;
	}

	case LYK_SOURCE:  /* toggle view source mode */
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation if the safe element is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, curdoc.title,
				   1, 1) == FALSE) {
		HTInfoMsg(CANCELLED);
		break;
	    }

	    if (HTisDocumentSource()) {
		HTOutputFormat = WWW_PRESENT;
#ifdef USE_PSRC
		psrc_view = FALSE;
#endif
	    } else {
		if (HText_getOwner())
		    StrAllocCopy(ownerS_address, HText_getOwner());
		LYUCPushAssumed(HTMainAnchor);
#ifdef USE_PSRC
		if (LYpsrc)
		    psrc_view = TRUE;
		else
		    HTOutputFormat = WWW_SOURCE;
d6014 5
a6018 280
		HTOutputFormat = WWW_SOURCE;
#endif
	    }

#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
			/*
			 * These normally get cleaned up after getfile() returns;
			 * since we're not calling getfile(), we have to clean them
			 * up ourselves.  -dsb
			 */
			HTOutputFormat = WWW_PRESENT;
#ifdef USE_PSRC
			if (psrc_view)
				HTMark_asSource();
			psrc_view = FALSE;
#endif
			FREE(ownerS_address);   /* not used with source_cache */
			LYUCPopAssumed();  		/* probably a right place here */
			HTMLSetCharacterHandling(current_char_set);  /* restore now */

			break;
	    }
#endif

	    FREE(curdoc.address); /* so it doesn't get pushed */
	    LYforce_no_cache = TRUE;
	    break;

	case LYK_RELOAD:  /* control-R to reload and refresh */
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation if the safe element is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
		HTInfoMsg(CANCELLED);
		break;
	    }

	    /*
	     *	Check to see if should reload source, or load html
	     */

	    if (HTisDocumentSource()) {
		force_old_UCLYhndl_on_reload = TRUE;
		forced_UCLYhdnl = HTMainText_Get_UCLYhndl();
#ifndef USE_PSRC
		HTOutputFormat = WWW_SOURCE;
#else
		if (LYpsrc)
		    psrc_view = TRUE;
		else
		    HTOutputFormat = WWW_SOURCE;
#endif
	    }

	    HEAD_request = HTLoadedDocumentIsHEAD();
	    HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
	    /*
	     *	Don't assume the reloaded document will be the same. - FM
	     */
	    newdoc.line = 1;
	    newdoc.link = 0;
#else
	    /*
	     *	Do assume the reloaded document will be the same. - FM
	     *	(I don't remember all the reasons why we couldn't assume
	     *	 this.	As the problems show up, we'll try to fix them,
	     *	 or add warnings.  - FM)
	     */
	    newdoc.line = curdoc.line;
	    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
	    FREE(curdoc.address); /* so it doesn't get pushed */
#ifdef VMS
	    lynx_force_repaint();
#endif /* VMS */
	    /*
	     *	Reload should force a cache refresh on a proxy.
	     *	      -- Ari L. <luotonen@@dxcern.cern.ch>
	     *
	     *	-- but only if this was really a reload requested by
	     *	the user, not if we jumped here to handle reloading for
	     *	INLINE_TOGGLE, IMAGE_TOGGLE, RAW_TOGGLE, etc. - KW
	     */
	    if (real_cmd == LYK_RELOAD)
		reloading = TRUE;
	    break;

	case LYK_HISTORICAL:	/* toggle 'historical' comments parsing */
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation of reload if the safe element
	     *	is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL,
				   0, 0) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
#endif
	    if (historical_comments)
		historical_comments = FALSE;
	    else
		historical_comments = TRUE;
	    if (minimal_comments) {
		HTAlert(historical_comments ?
			HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
	    } else {
		HTAlert(historical_comments ?
			HISTORICAL_ON_VALID_OFF : HISTORICAL_OFF_VALID_ON);
	    }
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break; /* OK */
	    }
#endif
	    break;

	case LYK_MINIMAL:	/* toggle 'minimal' comments parsing */
	    if (!historical_comments) {
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
		/*
		 *  Check if this is a reply from a POST, and if so,
		 *  seek confirmation of reload if the safe element
		 *  is not set. - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    confirm_post_resub(curdoc.address, NULL,
				       0, 0) == FALSE) {
		    HTInfoMsg(WILL_NOT_RELOAD_DOC);
		} else {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    FREE(curdoc.address);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		}
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
#endif
	    if (minimal_comments)
		minimal_comments = FALSE;
	    else
		minimal_comments = TRUE;
	    if (!historical_comments) {
		HTAlert(minimal_comments ?
			MINIMAL_ON_IN_EFFECT : MINIMAL_OFF_VALID_ON);
	    } else {
		HTAlert(minimal_comments ?
			MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
	    }
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break; /* OK */
	    }
#endif
	    break;

	case LYK_SOFT_DQUOTES:
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation of reload if the safe element
	     *	is not set. - FM
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL,
				   1, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
#endif
	    if (soft_dquotes)
		soft_dquotes = FALSE;
	    else
		soft_dquotes = TRUE;
	    HTUserMsg(soft_dquotes ?
		      SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break; /* OK */
	    }
#endif
	    break;

	case LYK_SWITCH_DTD:
#ifdef SOURCE_CACHE
	    if (!HTcan_reparse_document()) {
#endif
	    /*
	     *	Check if this is a reply from a POST, and if so,
	     *	seek confirmation of reload if the safe element
	     *	is not set. - FM, kw
	     */
	    if ((curdoc.post_data != NULL &&
		 curdoc.safe != TRUE) &&
		confirm_post_resub(curdoc.address, NULL,
				   1, 1) == FALSE) {
		HTInfoMsg(WILL_NOT_RELOAD_DOC);
	    } else {
		/*
		 *  If currently viewing preparsed source, switching
		 *  to the other DTD parsing may show source differences,
		 *  so stay in source view - kw
		 */

		/* NOTE: this conditional can be considered incorrect -
		   current behaviour - when viewing source and
		   LYPreparsedSource==TRUE, pressing ^V will toggle parser mode
		   AND switch back from the source view to presentation view.-HV
		*/
		if (HTisDocumentSource() && LYPreparsedSource) {
#ifdef USE_PSRC
		    if (LYpsrc)
			psrc_view = TRUE;
		    else
#endif
		    HTOutputFormat = WWW_SOURCE;
		}
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
#ifdef NO_ASSUME_SAME_DOC
		newdoc.line = 1;
		newdoc.link = 0;
#else
		newdoc.line = curdoc.line;
		newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
	    }
#ifdef SOURCE_CACHE
	    } /* end if no bypass */
#endif
	    Old_DTD = !Old_DTD;
	    HTSwitchDTD(!Old_DTD);
	    HTUserMsg(Old_DTD ? USING_DTD_0 : USING_DTD_1);
#ifdef SOURCE_CACHE
	    if (HTcan_reparse_document()) {
	    if (HTisDocumentSource() && LYPreparsedSource) {
#ifdef USE_PSRC
		if (LYpsrc)
		    psrc_view = TRUE;
		else
#endif
		HTOutputFormat = WWW_SOURCE;
	    }
	    if (HTreparse_document()) {
		break;
	    }
	    } /* end if no bypass */
a6019 1
	    break;
d6021 15
a6035 5
#ifdef NOT_DONE_YET
	case LYK_PIPE:
	    /* ignore for now */
	    break;
#endif /* NOT_DONE_YET */
d6037 3
a6039 11
	case LYK_QUIT:	/* quit */
	    if (LYQuitDefaultYes == TRUE) {
		c = HTConfirmDefault(REALLY_QUIT_Y, YES);
	    } else {
		c = HTConfirmDefault(REALLY_QUIT_N, NO);
	    }
	    if (LYQuitDefaultYes == TRUE) {
		if (c != NO) {
		    return(0);
		} else {
		    HTInfoMsg(NO_CANCEL);
a6040 4
	    } else if (c == YES) {
		return(0);
	    } else {
		HTInfoMsg(NO_CANCEL);
a6041 1
	    break;
d6043 14
a6056 2
	case LYK_ABORT:		/* don't ask the user about quitting */
	    return(0);
d6058 13
a6070 9
	case LYK_NEXT_PAGE:	/* next page */
	    if (more) {
		Newline += display_lines;
	    } else if (curdoc.link < nlinks-1) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nlinks-1;  /* put on last link */
	    } else if (old_c != real_c) {
		   old_c = real_c;
		   HTInfoMsg(ALREADY_AT_END);
d6072 4
a6075 11
	    break;

	case LYK_PREV_PAGE:  /* page up */
	    if (Newline > 1) {
		Newline -= display_lines;
	    } else if (curdoc.link > 0) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;  /* put on first link */
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
d6077 4
a6080 18
	    break;

	case  LYK_UP_TWO:
	    if (Newline > 1) {
		int scrollamount = (Newline > 2 ? 2 : 1);
		Newline -= scrollamount;
		if (nlinks > 0 && curdoc.link > -1) {
		    if (links[curdoc.link].ly + scrollamount <= display_lines) {
			newdoc.link = curdoc.link +
				      HText_LinksInLines(HTMainText,
							 Newline, scrollamount);
		    } else {
			arrowup = TRUE;
		    }
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
a6081 1
	    break;
a6082 14
	case  LYK_DOWN_TWO:
	    if (more) {
		Newline += 2;
		if (nlinks > 0 && curdoc.link > -1 &&
		    links[curdoc.link].ly > 2) {
		    newdoc.link = curdoc.link;
		    for (i = 0; links[i].ly <= 2; i++)
			--newdoc.link;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
	    }
	    break;
d6084 8
a6091 21
	case  LYK_UP_HALF:
	    if (Newline > 1) {
		int scrollamount = display_lines/2;
		if (Newline - scrollamount < 1)
		    scrollamount = Newline - 1;
		Newline -= scrollamount;
		if (nlinks > 0 && curdoc.link > -1) {
		    if (links[curdoc.link].ly + scrollamount <= display_lines) {
			newdoc.link = curdoc.link +
				      HText_LinksInLines(HTMainText,
							 Newline,
							 scrollamount);
		    } else {
			arrowup = TRUE;
		    }
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;
d6093 1
a6093 14
	case  LYK_DOWN_HALF:
	    if (more) {
		Newline += (display_lines/2);
		if (nlinks > 0 && curdoc.link > -1 &&
		    links[curdoc.link].ly > display_lines/2) {
		    newdoc.link = curdoc.link;
		    for (i = 0; links[i].ly <= (display_lines/2); i++)
			--newdoc.link;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
	    }
	    break;
d6095 14
a6108 4
	case LYK_REFRESH:
	   refresh_screen = TRUE;
	   lynx_force_repaint();
	   break;
d6110 1
a6110 8
	case LYK_HOME:
	    if (curdoc.line > 1)
		Newline = 1;
	    else {
		cmd = LYK_PREV_PAGE;
		goto new_cmd;
	    }
	    break;
d6112 3
a6114 4
	case LYK_END:
	    if (more) {
	       Newline = HText_getNumOfLines() - display_lines + 3;  /* go to end of file */
	       arrowup = TRUE;	 /* position on last link */
d6116 1
a6116 2
		cmd = LYK_NEXT_PAGE;
		goto new_cmd;
d6118 2
a6119 1
	    break;
d6121 22
a6142 64
	case LYK_PREV_LINK:
	    if (curdoc.link > 0) {	     /* previous link */
		/*
		 *  Unhighlight current link.
		 */
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link--;

	    } else if (!more &&
		       curdoc.link==0 && Newline==1) { /* at the top of list */
		/*
		 *  If there is only one page of data and the user
		 *  goes off the top, then unhighlight the current
		 *  link and just move the cursor to last link on
		 *  the page.
		 */
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nlinks-1;  /* the last link */

	    } else if (curdoc.line > 1) {	/* previous page */
		/*
		 *  Go back to the previous page.
		 */
		int scrollamount = (Newline > display_lines ?
					      display_lines : Newline - 1);
		Newline -= scrollamount;
		if (scrollamount < display_lines &&
		    nlinks > 0 && curdoc.link == 0 &&
		    links[0].ly - 1 + scrollamount <= display_lines) {
			newdoc.link = HText_LinksInLines(HTMainText,
							 1,
							 scrollamount) - 1;
		} else {
		    arrowup = TRUE;
		}

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;

	case LYK_NEXT_LINK:
	    if (curdoc.link < nlinks-1) {	/* next link */
		highlight(OFF, curdoc.link, prev_target);
#ifdef FASTTAB
		/*
		 *  Move to different textarea if TAB in textarea.
		 */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
		    c=='\t') {
		    int thisgroup = links[curdoc.link].form->number;
		    char *thisname = links[curdoc.link].form->name;

		    do curdoc.link++;
		    while ((curdoc.link < nlinks-1) &&
			   links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			   links[curdoc.link].form->type == F_TEXTAREA_TYPE &&
			   links[curdoc.link].form->number == thisgroup &&
			   sametext(links[curdoc.link].form->name, thisname));
		} else {
		    curdoc.link++;
		}
d6144 12
a6155 16
		curdoc.link++;
#endif /* FASTTAB */
	    /*
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
	     */
	    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;

	    } else if (more) {	/* next page */
		 Newline += (display_lines);

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
d6157 1
a6157 1
	    break;
d6159 8
a6166 42
	case LYK_FASTFORW_LINK:
	{
	    int samepage = 0, nextlink = curdoc.link;
	    if (nlinks > 1) {

		/*
		 *  If in textarea, move to first link or field
		 *  after it if there is one on this screen. - kw
		 */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
		    int thisgroup = links[curdoc.link].form->number;
		    char *thisname = links[curdoc.link].form->name;

		    if (curdoc.link < nlinks-1 &&
			!(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
			  links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
			  links[nlinks-1].form->number == thisgroup &&
			  sametext(links[nlinks-1].form->name, thisname))) {
			do nextlink++;
			while
			    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
			     links[nextlink].form->type == F_TEXTAREA_TYPE &&
			     links[nextlink].form->number == thisgroup &&
			     sametext(links[nextlink].form->name, thisname));
			samepage = 1;
		    } else if (!more && Newline == 1 && curdoc.link > 0) {
			nextlink = 0;
			samepage = 1;
		    }
		} else if (curdoc.link < nlinks-1) {
		    nextlink++;
		    samepage = 1;
		} else if (!more && Newline == 1 && curdoc.link > 0) {
		    nextlink = 0;
		    samepage = 1;
		}
	    }
	    if (samepage) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nextlink;
		break;		/* and we are done. */
d6168 1
d6170 1
a6170 2
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
d6172 1
a6172 151
	    } else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;

	    } else if (more &&	/* need a later page */
		       HTGetLinkOrFieldStart(curdoc.link,
					     &Newline, &newdoc.link,
					     1, TRUE) != NO) {
		Newline++;	/* our line counting starts with 1 not 0 */
		/* nothing more to do here */

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(NO_LINKS_BELOW);
	    }
	    break;
	}
	case LYK_FASTBACKW_LINK:
	{
	    int samepage = 0, nextlink = curdoc.link;
	    int res;
	    if (nlinks > 1) {

		/*
		 *  If in textarea, move to first link or textarea group
		 *  before it if there is one on this screen. - kw
		 */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type == F_TEXTAREA_TYPE) {
		    int thisgroup = links[curdoc.link].form->number;
		    char *thisname = links[curdoc.link].form->name;

		    if (curdoc.link > 0 &&
			!(links[0].type == WWW_FORM_LINK_TYPE &&
			  links[0].form->type == F_TEXTAREA_TYPE &&
			  links[0].form->number == thisgroup &&
			  sametext(links[0].form->name, thisname))) {
			do nextlink--;
			while
			    (links[nextlink].type == WWW_FORM_LINK_TYPE &&
			     links[nextlink].form->type == F_TEXTAREA_TYPE &&
			     links[nextlink].form->number == thisgroup &&
			     sametext(links[nextlink].form->name, thisname));
			samepage = 1;

		    } else if (!more && Newline == 1 &&
			       (links[0].type == WWW_FORM_LINK_TYPE &&
				links[0].form->type == F_TEXTAREA_TYPE &&
				links[0].form->number == thisgroup &&
				sametext(links[0].form->name, thisname)) &&
			       !(links[nlinks-1].type == WWW_FORM_LINK_TYPE &&
				 links[nlinks-1].form->type == F_TEXTAREA_TYPE &&
				 links[nlinks-1].form->number == thisgroup &&
				 sametext(links[nlinks-1].form->name, thisname))) {
			nextlink = nlinks - 1;
			samepage = 1;

		    } else if (!more && Newline == 1 && curdoc.link > 0) {
			nextlink = 0;
			samepage = 1;
		    }
		} else if (curdoc.link > 0) {
		    nextlink--;
		    samepage = 1;
		} else if (!more && Newline == 1) {
		    nextlink = nlinks - 1;
		    samepage = 1;
		}
	    }
	    if (samepage) {
		/*
		 *  If the link as determined so far is part of a
		 *  group of textarea fields, try to use the first
		 *  of them that's on the screen instead. - kw
		 */
		if (nextlink > 0 &&
		    links[nextlink].type == WWW_FORM_LINK_TYPE &&
		    links[nextlink].form->type == F_TEXTAREA_TYPE) {
		    int thisgroup = links[nextlink].form->number;
		    char *thisname = links[nextlink].form->name;
		    if (links[0].type == WWW_FORM_LINK_TYPE &&
			links[0].form->type == F_TEXTAREA_TYPE &&
			links[0].form->number == thisgroup &&
			sametext(links[0].form->name, thisname)) {
			nextlink = 0;
		    } else
			while
			    (nextlink > 1 &&
			     links[nextlink-1].type == WWW_FORM_LINK_TYPE &&
			     links[nextlink-1].form->type == F_TEXTAREA_TYPE &&
			     links[nextlink-1].form->number == thisgroup &&
			     sametext(links[nextlink-1].form->name, thisname)) {
			    nextlink--;
			}
		}
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = nextlink;
		break;		/* and we are done. */

	    } else if (Newline > 1 &&	/* need a previous page */
		       (res = HTGetLinkOrFieldStart(curdoc.link,
						    &Newline, &newdoc.link,
						    -1, TRUE)) != NO) {
		if (res == LINK_DO_ARROWUP) {
		    /*
		     *  It says we should use the normal PREV_LINK
		     *  mechanism, so we'll do that. - kw
		     */
		    if (nlinks > 0)
			curdoc.link = 0;
		    cmd = LYK_PREV_LINK;
		    goto new_cmd;
		}
		Newline++;	/* our line counting starts with 1 not 0 */
		/* nothing more to do here */

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(NO_LINKS_ABOVE);
	    }
	    break;
	}

	case LYK_UP_LINK:
	    if (curdoc.link > 0 &&
		(links[0].ly != links[curdoc.link].ly ||
		 !HText_LinksInLines(HTMainText, 1, Newline - 1))) {
		/* more links before this on screen, and first of them on
		   a different line or no previous links before this screen? */
		int newlink = -1;
		for (i = curdoc.link; i >= 0; i--) {
		    if (links[i].ly < links[curdoc.link].ly) {
			newlink = i;
			break;
		    }
		}
		if (newlink > -1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = newlink;
#ifdef NOTDEFINED
		} else if (!more && Newline == 1 && curdoc.link == 0) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = (nlinks-1);
		} else if (more) {  /* next page */
			Newline += (display_lines);
#else
		} else if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_LINKS_ABOVE);
#endif /* NOTDEFINED */
		}
a6173 1
#ifdef NOTDEFINED
d6175 3
a6177 2
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
d6179 10
a6188 15
	    } else if (!more && Newline == 1 && curdoc.link == (nlinks-1)) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;
#endif /* NOTDEFINED */

	    } else if (curdoc.line > 1 && Newline > 1) {  /* previous page */
		int scrollamount = (Newline > display_lines ?
					      display_lines : Newline - 1);
		Newline -= scrollamount;
		if (scrollamount < display_lines &&
		    nlinks > 0 && curdoc.link > -1 &&
		    links[0].ly -1 + scrollamount <= display_lines) {
			newdoc.link = HText_LinksInLines(HTMainText,
							 1,
							 scrollamount) - 1;
d6190 19
a6208 17
		    arrowup = TRUE;
		}

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_BEGIN);
	    }
	    break;

	case LYK_DOWN_LINK:
	    if (curdoc.link < (nlinks-1)) {	/* more links? */
		int newlink = -1;
		for (i = curdoc.link; i < nlinks; i++)
		   if (links[i].ly > links[curdoc.link].ly) {
			newlink = i;
			break;
		   }
d6210 8
a6217 15
		if (newlink > -1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = newlink;
#ifdef NOTDEFINED
		} else if (!more &&
			   Newline == 1 && curdoc.link == (nlinks-1)) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = 0;
#endif /* NOTDEFINED */
		} else if (more) {  /* next page */
			Newline += (display_lines);
		} else if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_LINKS_BELOW);
		    break;
a6218 15
#ifdef NOTDEFINED
	    /*
	     *	At the bottom of list and there is only one page.
	     *	Move to the top link on the page.
	     */
	    } else if (!more && Newline == 1 && curdoc.link == (nlinks-1)) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link = 0;
#endif /* NOTDEFINED */
	    } else if (more) {	/* next page */
		    Newline += (display_lines);

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTInfoMsg(ALREADY_AT_END);
d6220 10
a6229 38
	    break;

	case LYK_CHANGE_LINK:
	    do_change_link(prev_target);
	    break;

	case LYK_RIGHT_LINK:
	    if (curdoc.link<nlinks-1 &&
			links[curdoc.link].ly == links[curdoc.link+1].ly) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link++;
	    }
	    break;

	case LYK_LEFT_LINK:
	    if (curdoc.link>0 &&
			links[curdoc.link].ly == links[curdoc.link-1].ly) {
		highlight(OFF, curdoc.link, prev_target);
		curdoc.link--;
	    }
	    break;

	case LYK_COOKIE_JAR:	   /* show the cookie jar */
	    /*
	     *	Don't do if already viewing the cookie jar.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       COOKIE_JAR_TITLE)) {
		StrAllocCopy(newdoc.address, "LYNXCOOKIE:/");
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYforce_no_cache = TRUE;
		if (LYValidate || check_realm) {
		    LYPermitURL = TRUE;
a6230 1
	    } else {
d6232 1
a6232 1
		 *  If already in the cookie jar, get out.
d6234 17
a6250 2
		cmd = LYK_PREV_DOC;
		goto new_cmd;
d6252 1
a6252 4
	    break;

	case LYK_HISTORY:	/* show the history page */
	    if (curdoc.title && strcmp(curdoc.title, HISTORY_PAGE_TITLE)) {
d6254 3
a6256 5
		 *  Don't do this if already viewing history page.
		 *
		 *  Push the current file so that the history list
		 *  contains the current file for printing purposes.
		 *  Pop the file afterwards to prevent multiple copies.
d6258 2
a6259 9
		if (TRACE && !LYUseTraceLog && LYCursesON) {
		    move(LYlines-1, LYcols-1);	/* make sure cursor is down */
#ifdef USE_SLANG
		    addstr("\n");
#endif /* USE_SLANG */
		    refresh();
		}
		LYpush(&curdoc, ForcePush);

d6261 4
a6264 1
		 *  Print history options to file.
d6266 5
a6270 14
		if (showhistory(&newdoc.address) < 0) {
		    LYpop(&curdoc);
		    break;
		}
		StrAllocCopy(newdoc.title, HISTORY_PAGE_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		newdoc.link = 1; /*@@@@@@ bypass "recent statusline messages" link */
		FREE(curdoc.address);  /* so it doesn't get pushed */

d6272 2
a6273 94
		if (LYValidate || check_realm) {
		    LYPermitURL = TRUE;
		}
		break;
	    } /* end if strncmp */
	    /*
	     *	Don't put break here so that if the backspace key
	     *	is pressed in the history page, we fall though,
	     *	i.e., it acts like a left arrow.
	     */

	case LYK_PREV_DOC:			 /* back up a level */
	    if (nhist > 0) {  /* if there is anything to go back to */
		/*
		 *  Check if the previous document is a reply from a POST,
		 *  and if so, seek confirmation of resubmission if the safe
		 *  element is not set and the document is not still in the
		 *  cache or LYresubmit_posts is set.  If not confirmed and
		 *  it is not the startfile, pop it so we go to the yet
		 *  previous document, until we're OK or reach the startfile.
		 *  If we reach the startfile and its not OK or we don't get
		 *  confirmation, cancel. - FM
		 */
		DocAddress WWWDoc;
		HTParentAnchor *tmpanchor;
		HText *text;
		BOOLEAN conf = FALSE, first = TRUE;

		HTLastConfirmCancelled(); /* reset flag */
		while (nhist > 0) {
		    conf = FALSE;
		    if (history[(nhist - 1)].post_data == NULL) {
			break;
		    }
		    WWWDoc.address = history[(nhist - 1)].address;
		    WWWDoc.post_data = history[(nhist - 1)].post_data;
		    WWWDoc.post_content_type =
				       history[(nhist - 1)].post_content_type;
		    WWWDoc.bookmark = history[(nhist - 1)].bookmark;
		    WWWDoc.isHEAD = history[(nhist - 1)].isHEAD;
		    WWWDoc.safe = history[(nhist - 1)].safe;
		    tmpanchor = HTAnchor_parent(HTAnchor_findAddress(&WWWDoc));
		    if (HTAnchor_safe(tmpanchor)) {
			break;
		    }
		    if (((text =
			  (HText *)HTAnchor_document(tmpanchor)) == NULL &&
			 (!strncmp(WWWDoc.address, "LYNXIMGMAP:", 11) ||
			 (conf = confirm_post_resub(WWWDoc.address,
						    history[(nhist - 1)].title,
						    0, 0))
			  == FALSE)) ||
			((LYresubmit_posts && !conf &&
			  (NONINTERNAL_OR_PHYS_DIFFERENT(
			      (document *)&history[(nhist - 1)],
			      &curdoc) ||
			   NONINTERNAL_OR_PHYS_DIFFERENT(
			       (document *)&history[(nhist - 1)],
			       &newdoc))) &&
			 !confirm_post_resub(WWWDoc.address,
					     history[(nhist - 1)].title,
					     2, 2))) {
			if (HTLastConfirmCancelled()) {
			    if (!first && curdoc.internal_link)
				FREE(curdoc.address);
			    cmd = LYK_DO_NOTHING;
			    goto new_cmd;
			}
			if (nhist == 1) {
			    HTInfoMsg(CANCELLED);
			    old_c = 0;
			    cmd = LYK_DO_NOTHING;
			    goto new_cmd;
			} else {
			    HTUserMsg2(WWW_SKIP_MESSAGE, WWWDoc.address);
			    do {
				LYpop(&curdoc);
			    } while (nhist > 1 && !are_different(
				(document *)&history[(nhist - 1)],
				&curdoc));
			    first = FALSE; /* have popped at least one */
			    continue;
			}
		    } else {
			/*
			 *  Break from loop; if user just confirmed to
			 *  load again because document wasn't in cache,
			 *  set LYforce_no_cache to avoid unnecessary
			 *  repeat question down the road. - kw
			 */
			if (conf)
			    LYforce_no_cache = TRUE;
			break;
		    }
d6275 2
d6278 13
a6290 3
		if (!first)
		    curdoc.internal_link = FALSE;

d6292 2
a6293 1
		 *  Set newdoc.address to empty to pop a file.
d6295 5
a6299 11
		FREE(newdoc.address);
#ifdef DIRED_SUPPORT
		if (lynx_edit_mode)
		    HTuncache_current_document();
#endif /* DIRED_SUPPORT */
	    } else if (child_lynx == TRUE) {
		return(0); /* exit on left arrow in main screen */

	    } else if (old_c != real_c) {
		old_c = real_c;
		HTUserMsg(ALREADY_AT_FIRST);
d6301 1
a6301 1
	    break;
d6303 5
a6307 15
	case LYK_NOCACHE: /* Force submission of form or link with no-cache */
	    if (nlinks > 0) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		    links[curdoc.link].form->type != F_SUBMIT_TYPE &&
		    links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE) {
		    if (old_c == real_c)
			break;
		    old_c = real_c;
		    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
		    break;
		} else {
		    LYforce_no_cache = TRUE;
		    reloading = TRUE;
		}
	    } /* fall through to LYK_ACTIVATE */
d6309 11
a6319 380
	case LYK_ACTIVATE:			/* follow a link */
	    {
	     /* Is there a mouse-clicked link waiting? */
	     int mouse_tmp = get_mouse_link();
	     /* If yes, use it as the link */
	     if (mouse_tmp != -1) curdoc.link = mouse_tmp;
	    }
	     if (nlinks > 0) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
		    /*
		     *	Don't try to submit forms with bad actions. - FM
		     */
		    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
			links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE ||
			links[curdoc.link].form->type ==
						    F_TEXT_SUBMIT_TYPE) {
			/*
			 *  Do nothing if it's disabled. - FM
			 */
			if (links[curdoc.link].form->disabled == YES) {
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Make sure we have an action. - FM
			 */
			if (!links[curdoc.link].form->submit_action ||
			    *links[curdoc.link].form->submit_action
								== '\0') {
			    HTUserMsg(NO_FORM_ACTION);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Check for no_mail if the form action
			 *  is a mailto URL. - FM
			 */
			if (links[curdoc.link].form->submit_method
				     == URL_MAIL_METHOD && no_mail) {
			    HTAlert(FORM_MAILTO_DISALLOWED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Make sure this isn't a spoof in an account
			 *  with restrictions on file URLs. - FM
			 */
			if (no_file_url &&
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "file:", 5)) {
			    HTAlert(FILE_ACTIONS_DISALLOWED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
			/*
			 *  Make sure this isn't a spoof attempt
			 *  via an internal URL. - FM
			 */
			if (!strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXCOOKIE:", 11) ||
#ifdef DIRED_SUPPORT
#ifdef OK_PERMIT
			    (!(strncasecomp(
				    links[curdoc.link].form->submit_action,
					   "LYNXDIRED:", 10)) &&
			     (no_dired_support ||
			      strncasecomp(
				(links[curdoc.link].form->submit_action + 10),
					   "//PERMIT_LOCATION", 17) ||
			      strcmp(curdoc.address, LYPermitFileURL) ||
			      strcmp((curdoc.title ? curdoc.title : ""),
				     PERMIT_OPTIONS_TITLE)))  ||
#else
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXDIRED:", 10) ||
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXDOWNLOAD:", 13) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXHIST:", 9) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXKEYMAP:", 11) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXIMGMAP:", 11) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "LYNXPRINT:", 10) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "lynxexec:", 9) ||
			    !strncasecomp(
				    links[curdoc.link].form->submit_action,
					  "lynxprog:", 9)) {
			    HTAlert(SPECIAL_ACTION_DISALLOWED);
			    CTRACE(tfp, "LYMainLoop: Rejected '%s'\n",
					links[curdoc.link].form->submit_action);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
#ifdef NOTDEFINED /* We're disabling form inputs instead of using this. - FM */
			/*
			 *  Check for enctype and let user know we
			 *  don't yet support multipart/form-data - FM
			 */
			if (links[curdoc.link].form->submit_enctype) {
			    if (!strcmp(
				     links[curdoc.link].form->submit_enctype,
					"multipart/form-data")) {
				HTAlert(
	gettext("Enctype multipart/form-data not yet supported!  Cannot submit."));
				HTOutputFormat = WWW_PRESENT;
				LYforce_no_cache = FALSE;
				reloading = FALSE;
				break;
			    }
			}
#endif /* NOTDEFINED */
			if (check_realm) {
			    LYPermitURL = TRUE;
			}
			if (no_filereferer == TRUE &&
			    !strncmp(curdoc.address, "file:", 5)) {
			    LYNoRefererForThis = TRUE;
			}
			StrAllocCopy(newdoc.title,
				     links[curdoc.link].hightext);
		    }
		    c = change_form_link(&links[curdoc.link],
					 &newdoc, &refresh_screen,
					 links[curdoc.link].form->name,
					 links[curdoc.link].form->value);
		    if (HTOutputFormat == HTAtom_for("www/download") &&
			newdoc.post_data != NULL &&
			newdoc.safe == FALSE) {
			if ((HText_POSTReplyLoaded(&newdoc) == TRUE) &&
			    HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			    HTInfoMsg(CANCELLED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    StrAllocCopy(newdoc.address, curdoc.address);
			    StrAllocCopy(newdoc.title, curdoc.title);
			    StrAllocCopy(newdoc.post_data, curdoc.post_data);
			    StrAllocCopy(newdoc.post_content_type,
					 curdoc.post_content_type);
			    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
			    newdoc.isHEAD = curdoc.isHEAD;
			    newdoc.safe = curdoc.safe;
			    newdoc.internal_link = curdoc.internal_link;
			    break;
			}
		    }
		    if (c == 23) {
			c = DO_NOTHING;
			refresh_screen = TRUE;
		    }
		    goto new_keyboard_input;
		} else {
		    /*
		     *	Not a forms link.
		     *
		     *	Make sure this isn't a spoof in an account
		     *	with restrictions on file URLs. - FM
		     */
		    if (no_file_url &&
			!strncmp(links[curdoc.link].lname, "file:", 5)) {
			if (strncmp(curdoc.address, "file:", 5)) {
			    HTAlert(FILE_SERVED_LINKS_DISALLOWED);
			    reloading = FALSE;
			    break;
			} else if (curdoc.bookmark != NULL) {
			    HTAlert(FILE_BOOKMARKS_DISALLOWED);
			    reloading = FALSE;
			    break;
			}
		    }
		    /*
		     *	Make sure this isn't a spoof attempt
		     *	via an internal URL in a non-internal
		     *	document. - FM
		     */
		    if ((!strncmp(links[curdoc.link].lname,
				  "LYNXCOOKIE:", 11) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				COOKIE_JAR_TITLE)) ||
#ifdef DIRED_SUPPORT
			(!strncmp(links[curdoc.link].lname,
				  "LYNXDIRED:", 10) &&
			 (strcmp(curdoc.address, LYDiredFileURL) ||
			  strcmp((curdoc.title ? curdoc.title : ""),
				DIRED_MENU_TITLE)) &&
			 (strcmp(curdoc.address, LYPermitFileURL) ||
			  strcmp((curdoc.title ? curdoc.title : ""),
				PERMIT_OPTIONS_TITLE)) &&
			 (strcmp(curdoc.address, LYUploadFileURL) ||
			  strcmp((curdoc.title ? curdoc.title : ""),
				UPLOAD_OPTIONS_TITLE))) ||
#endif /* DIRED_SUPPORT */
			(!strncmp(links[curdoc.link].lname,
				 "LYNXDOWNLOAD:", 13) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				DOWNLOAD_OPTIONS_TITLE)) ||
			(!strncmp(links[curdoc.link].lname,
				  "LYNXHIST:", 9) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				HISTORY_PAGE_TITLE) &&
			 strcmp(curdoc.address, LYlist_temp_url())) ||
			(!strncmp(links[curdoc.link].lname,
				  "LYNXPRINT:", 10) &&
			 strcmp((curdoc.title ? curdoc.title : ""),
				PRINT_OPTIONS_TITLE))) {
			    HTAlert(SPECIAL_VIA_EXTERNAL_DISALLOWED);
			    HTOutputFormat = WWW_PRESENT;
			    LYforce_no_cache = FALSE;
			    reloading = FALSE;
			    break;
			}
		    /*
		     *	Follow a normal link or anchor.
		     */
		    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
		    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
		/*
		 *  For internal links, retain POST content if present.
		 *  If we are on the List Page, prevent pushing it on
		 *  the history stack.	Otherwise set try_internal to
		 *  signal that the top of the loop should attempt to
		 *  reposition directly, without calling getfile. - kw
		 */
		    /*
		     *	Might be an internal link anchor in the same doc.
		     *	If so, take the try_internal shortcut if we didn't
		     *	fall through from LYK_NOCACHE. - kw
		     */
		    newdoc.internal_link =
			(links[curdoc.link].type == WWW_INTERN_LINK_TYPE);
		    if (newdoc.internal_link) {
			/*
			 *  Special case of List Page document with an
			 *  internal link indication, which may really stand
			 *  for an internal link within the document the
			 *  List Page is about. - kw
			 */
			if ( 0==strcmp(curdoc.address, LYlist_temp_url()) &&
			    (LYIsListpageTitle(curdoc.title ? curdoc.title : ""))) {
			    if (!curdoc.post_data ||
				/*
				 *  Normal case - List Page is not associated
				 *  with post data. - kw
				 */
				(!LYresubmit_posts && curdoc.post_data &&
				history[nhist - 1].post_data &&
				!strcmp(curdoc.post_data,
					 history[nhist - 1].post_data) &&
				HText_getContentBase() &&
				!strncmp(HText_getContentBase(),
					 strncmp(history[nhist - 1].address,
						 "LYNXIMGMAP:", 11) ?
					 history[nhist - 1].address :
					 history[nhist - 1].address + 11,
					 strlen(HText_getContentBase())))) {
				/*
				 *  Normal case - as best as we can check, the
				 *  document at the top of the history stack
				 *  seems to be the document the List Page is
				 *  about (or a LYNXIMGMAP derived from it),
				 *  and LYresubmit_posts is not set, so don't
				 *  prompt here.  If we actually have to repeat
				 *  a POST because, against expectations, the
				 *  underlying document isn't cached any more,
				 *  HTAccess will prompt for confirmation,
				 *  unless we had LYK_NOCACHE. - kw
				 */
				LYinternal_flag = TRUE;
			    } else {
				HTLastConfirmCancelled(); /* reset flag */
				if (!confirm_post_resub(newdoc.address,
							newdoc.title,
						(LYresubmit_posts &&
				       HText_POSTReplyLoaded(&newdoc)) ? 1 : 2,
							2)) {
				    if (HTLastConfirmCancelled() ||
					(LYresubmit_posts &&
					 cmd != LYK_NOCACHE &&
					 !HText_POSTReplyLoaded(&newdoc))) {
					/* cancel the whole thing */
					LYforce_no_cache = FALSE;
					reloading = FALSE;
					StrAllocCopy(newdoc.address, curdoc.address);
					StrAllocCopy(newdoc.title, curdoc.title);
					newdoc.internal_link = curdoc.internal_link;
					HTInfoMsg(CANCELLED);
					break;
				    } else if (LYresubmit_posts &&
					       cmd != LYK_NOCACHE) {
					/* If LYresubmit_posts is set, and the
					   answer was No, and the key wasn't
					   NOCACHE, and we have a cached copy,
					   then use it. - kw */
					LYforce_no_cache = FALSE;
				    } else {
					/* if No, but not ^C or ^G, drop
					 * the post data.  Maybe the link
					 * wasn't meant to be internal after
					 * all, here we can recover from that
					 * assumption. - kw */
					FREE(newdoc.post_data);
					FREE(newdoc.post_content_type);
					newdoc.internal_link = FALSE;
					HTAlert(DISCARDING_POST_DATA);
				    }
				}
			    }
			    /*
			     *	Don't push the List Page if we follow an
			     *	internal link given by it. - kw
			     */
			    FREE(curdoc.address);
			} else if (cmd != LYK_NOCACHE) {
			    try_internal = TRUE;
			}
			if (!(LYresubmit_posts && newdoc.post_data))
			    LYinternal_flag = TRUE;
			/* We still set force_load so that history pushing
			** etc. will be done.  - kw */
			force_load = TRUE;
			break;
		    } else {
			/*
			 *  Free POST content if not an internal link. - kw
			 */
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
		    }
#endif /* TRACK_INTERNAL_LINKS */
		    /*
		     *	Might be an anchor in the same doc from a POST
		     *	form.  If so, dont't free the content. -- FM
		     */
		    if (are_different(&curdoc, &newdoc)) {
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
			FREE(newdoc.bookmark);
		    }
		    if (!no_jump && lynxjumpfile && curdoc.address &&
			!strcmp(lynxjumpfile, curdoc.address)) {
			LYJumpFileURL = TRUE;
			LYUserSpecifiedURL = TRUE;
		    } else if ((curdoc.title &&
			       !strcmp(curdoc.title, HISTORY_PAGE_TITLE)) ||
			       curdoc.bookmark != NULL ||
			       (lynxjumpfile &&
				!strcmp(lynxjumpfile, curdoc.address))) {
			LYUserSpecifiedURL = TRUE;
		    } else if (no_filereferer == TRUE &&
			       !strncmp(curdoc.address, "file:", 5)) {
			LYNoRefererForThis = TRUE;
		    }
		    newdoc.link = 0;
		    force_load = TRUE;	/* force MainLoop to reload */
#ifdef USE_PSRC
		    psrc_view = FALSE;	/* we get here if link is not internal */
d6322 4
d6327 2
a6328 10
		    if (lynx_edit_mode) {
			  HTuncache_current_document();
			  /*
			   *  Unescaping any slash chars in the URL,
			   *  but avoid double unescaping and too-early
			   *  unescaping of other chars. - KW
			   */
			  HTUnEscapeSome(newdoc.address,"/");
			  strip_trailing_slash(newdoc.address);
		    }
a6329 6
		    if (!strncmp(curdoc.address, "LYNXCOOKIE:", 11)) {
			HTuncache_current_document();
		    }
		}
	    }
	    break;
d6331 7
a6337 2
	case LYK_ELGOTO:   /* edit URL of current link and go to it  */
	    if (no_goto && !LYValidate) {
d6339 2
a6340 1
		 *  Go to not allowed. - FM
d6342 4
a6345 3
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(GOTO_DISALLOWED);
a6346 1
		break;
d6348 13
a6360 5
	    if (!(nlinks > 0 && curdoc.link > -1) ||
		(links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
		 links[curdoc.link].form->type != F_SUBMIT_TYPE &&
		 links[curdoc.link].form->type != F_IMAGE_SUBMIT_TYPE &&
		 links[curdoc.link].form->type != F_TEXT_SUBMIT_TYPE)) {
d6362 2
a6363 2
		 *  No links on page, or not a normal link
		 *  or form submit button. - FM
d6365 16
a6380 3
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NOT_ON_SUBMIT_OR_LINK);
a6381 1
		break;
d6383 16
a6398 11
	    if ((links[curdoc.link].type == WWW_FORM_LINK_TYPE) &&
		(!links[curdoc.link].form->submit_action ||
		 *links[curdoc.link].form->submit_action == '\0')) {
		/*
		 *  Form submit button with no ACTION defined. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_FORM_ACTION);
		}
		break;
d6400 5
d6406 2
a6407 20
	    if (!strncmp(links[curdoc.link].lname,
			 "LYNXDIRED:", 10) ||
		!strcmp(curdoc.address, LYDiredFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			DIRED_MENU_TITLE) ||
		!strcmp(curdoc.address, LYPermitFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			PERMIT_OPTIONS_TITLE) ||
		!strcmp(curdoc.address, LYUploadFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			UPLOAD_OPTIONS_TITLE)) {
		/*
		 *  Disallow editing of File Management URLs. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
		}
		break;
	    }
d6411 1
a6411 2
	     *	Save the current user_input_buffer string,
	     *	and load the current link's address. - FM
d6413 2
a6414 23
	    StrAllocCopy(temp, user_input_buffer);
	    LYstrncpy(user_input_buffer,
		      ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
						?
	    links[curdoc.link].form->submit_action : links[curdoc.link].lname),
		      (sizeof(user_input_buffer) - 1));

	    /*
	     *	Offer the current link's URL for editing. - FM
	     */
	    _statusline(EDIT_CURLINK_URL);
	    if (((ch = LYgetstr(user_input_buffer, VISIBLE,
				sizeof(user_input_buffer), RECALL)) >= 0) &&
		user_input_buffer[0] != '\0' &&
		strcmp(user_input_buffer,
		       ((links[curdoc.link].type == WWW_FORM_LINK_TYPE)
				? links[curdoc.link].form->submit_action
				: links[curdoc.link].lname))) {
		LYTrimAllStartfile(user_input_buffer); 
		if (user_input_buffer[0] != '\0') {
		    goto check_goto_URL;
		}
	    }
d6416 6
a6421 2
	     *	User cancelled via ^G, a full deletion,
	     *	or not modifying the URL. - FM
d6423 76
a6498 4
	    HTInfoMsg(CANCELLED);
	    strcpy(user_input_buffer, temp);
	    FREE(temp);
	    break;
d6500 7
a6506 8
	case LYK_ECGOTO:   /* edit current URL and go to to it	*/
	    if (no_goto && !LYValidate) {
		/*
		 *  Go to not allowed. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(GOTO_DISALLOWED);
a6507 1
		break;
d6509 6
a6514 16
#ifdef DIRED_SUPPORT
	    if (!strcmp(curdoc.address, LYDiredFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			DIRED_MENU_TITLE) ||
		!strcmp(curdoc.address, LYPermitFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			PERMIT_OPTIONS_TITLE) ||
		!strcmp(curdoc.address, LYUploadFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			UPLOAD_OPTIONS_TITLE)) {
		/*
		 *  Disallow editing of File Management URLs. - FM
		 */
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_FM_MENU_URLS_DISALLOWED);
d6516 1
a6516 1
		break;
d6518 8
a6525 1
#endif /* DIRED_SUPPORT */
d6527 12
a6538 8
	    /*
	     *	Save the current user_input_buffer string,
	     *	and load the current document's address.
	     */
	    StrAllocCopy(temp, user_input_buffer);
	    LYstrncpy(user_input_buffer,
		      curdoc.address,
		      (sizeof(user_input_buffer) - 1));
d6540 13
a6552 6
	    /*
	     *	Warn the user if the current document has POST
	     *	data associated with it. - FM
	     */
	    if (curdoc.post_data)
		HTAlert(CURRENT_DOC_HAS_POST_DATA);
d6554 1
d6556 2
a6557 1
	     *	Offer the current document's URL for editing. - FM
d6559 26
a6584 8
	    _statusline(EDIT_CURDOC_URL);
	    if (((ch = LYgetstr(user_input_buffer, VISIBLE,
				sizeof(user_input_buffer), RECALL)) >= 0) &&
		user_input_buffer[0] != '\0' &&
		strcmp(user_input_buffer, curdoc.address)) {
		LYTrimAllStartfile(user_input_buffer); 
		if (user_input_buffer[0] != '\0') {
		    goto check_goto_URL;
d6587 1
d6589 1
a6589 2
	     *	User cancelled via ^G, a full deletion,
	     *	or not modifying the URL. - FM
a6590 4
	    HTInfoMsg(CANCELLED);
	    strcpy(user_input_buffer, temp);
	    FREE(temp);
	    break;
d6592 144
a6735 39
	case LYK_GOTO:	 /* 'g' to goto a random URL  */
	    if (no_goto && !LYValidate) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(GOTO_DISALLOWED);
		}
		break;
	    }

	    StrAllocCopy(temp, user_input_buffer);
	    if (!goto_buffer)
		*user_input_buffer = '\0';

	    URLTotal = (Goto_URLs ? HTList_count(Goto_URLs) : 0);
	    if (goto_buffer && *user_input_buffer) {
		recall = ((URLTotal > 1) ? RECALL : NORECALL);
		URLNum = 0;
		FirstURLRecall = FALSE;
	    } else {
		recall = ((URLTotal >= 1) ? RECALL : NORECALL);
		URLNum = URLTotal;
		FirstURLRecall = TRUE;
	    }

	    /*
	     *	Ask the user.
	     */
	    _statusline(URL_TO_OPEN);
	    if ((ch = LYgetstr(user_input_buffer, VISIBLE,
			       sizeof(user_input_buffer), recall)) < 0 ) {
		/*
		 *  User cancelled the Goto via ^G.
		 *  Restore user_input_buffer and break. - FM
		 */
		strcpy(user_input_buffer, temp);
		FREE(temp);
		HTInfoMsg(CANCELLED);
		break;
	    }
a6736 14
check_recall:
	    /*
	     *	Get rid of leading spaces (and any other spaces).
	     */
	    LYTrimAllStartfile(user_input_buffer); 
	    if (*user_input_buffer == '\0' &&
		!(recall && (ch == UPARROW || ch == DNARROW))) {
		strcpy(user_input_buffer, temp);
		FREE(temp);
		HTInfoMsg(CANCELLED);
		break;
	    }
	    if (recall && ch == UPARROW) {
		if (FirstURLRecall) {
d6738 4
a6741 1
		     *	Use last URL in the list. - FM
d6743 6
a6748 7
		    FirstURLRecall = FALSE;
		    URLNum = 0;
		} else {
		    /*
		     *	Go back to the previous URL in the list. - FM
		     */
		    URLNum++;
d6750 14
a6763 14
		if (URLNum >= URLTotal)
		    /*
		     *	Roll around to the last URL in the list. - FM
		     */
		    URLNum = 0;
		if ((cp = (char *)HTList_objectAt(Goto_URLs,
						  URLNum)) != NULL) {
		    strcpy(user_input_buffer, cp);
		    if (goto_buffer && *temp &&
			!strcmp(temp, user_input_buffer)) {
			_statusline(EDIT_CURRENT_GOTO);
		    } else if ((goto_buffer && URLTotal == 2) ||
			       (!goto_buffer && URLTotal == 1)) {
			_statusline(EDIT_THE_PREV_GOTO);
d6765 1
a6765 13
			_statusline(EDIT_A_PREV_GOTO);
		    }
		    if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				      sizeof(user_input_buffer),
				      recall)) < 0) {
			/*
			 *  User cancelled the Goto via ^G.
			 *  Restore user_input_buffer and break. - FM
			 */
			strcpy(user_input_buffer, temp);
			FREE(temp);
			HTInfoMsg(CANCELLED);
			break;
a6766 1
		    goto check_recall;
d6768 14
a6781 2
	    } else if (recall && ch == DNARROW) {
		if (FirstURLRecall) {
d6783 2
a6784 1
		     *	Use the first URL in the list. - FM
d6786 4
a6789 7
		    FirstURLRecall = FALSE;
		    URLNum = URLTotal - 1;
		} else {
		    /*
		     *	Advance to the next URL in the list. - FM
		     */
		    URLNum--;
d6791 2
a6792 1
		if (URLNum < 0)
d6794 8
a6801 1
		     *	Roll around to the first URL in the list. - FM
d6803 1
a6803 26
		    URLNum = URLTotal - 1;
		if ((cp=(char *)HTList_objectAt(Goto_URLs,
						    URLNum)) != NULL) {
		    strcpy(user_input_buffer, cp);
		    if (goto_buffer && *temp &&
			!strcmp(temp, user_input_buffer)) {
			_statusline(EDIT_CURRENT_GOTO);
		    } else if ((goto_buffer && URLTotal == 2) ||
			       (!goto_buffer && URLTotal == 1)) {
			_statusline(EDIT_THE_PREV_GOTO);
		    } else {
			_statusline(EDIT_A_PREV_GOTO);
		    }
		    if ((ch = LYgetstr(user_input_buffer, VISIBLE,
				       sizeof(user_input_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the Goto via ^G.
			 *  Restore user_input_buffer and break. - FM
			 */
			strcpy(user_input_buffer, temp);
			FREE(temp);
			HTInfoMsg(CANCELLED);
			break;
		    }
		    goto check_recall;
d6805 2
a6806 10
	    }

check_goto_URL:
	    /* allow going to anchors*/
	    if (*user_input_buffer == '#' ) {
		if ( user_input_buffer[1] &&
		     HTFindPoundSelector(user_input_buffer+1) ) {
		     /* HTFindPoundSelector will initialize www_search_result,
			so we do nothing else. */
		    HTAddGotoURL(user_input_buffer);
a6807 1
		break;
d6809 1
a6809 12
	    /*
	     *	If its not a URL then make it one.
	     */
	    StrAllocCopy(temp, user_input_buffer);
	    LYFillLocalFileURL((char **)&temp, "file://localhost");
	    LYEnsureAbsoluteURL((char **)&temp, "", TRUE);
	    sprintf(user_input_buffer, "%.*s",
		    (int)(sizeof(user_input_buffer) - 1), temp);
	    FREE(temp);
	    if ((no_file_url || no_goto_file) &&
		!strncmp(user_input_buffer,"file:",5)) {
		HTUserMsg(GOTO_FILE_DISALLOWED);
d6811 11
a6821 7
	    } else if ((no_shell || no_goto_lynxexec
#ifdef EXEC_LINKS
			|| local_exec_on_local_files
#endif /* EXEC_LINKS */
			) &&
		       !strncmp(user_input_buffer, "lynxexec:",9)) {
		HTUserMsg(GOTO_EXEC_DISALLOWED);
d6823 9
a6831 44
	    } else if ((no_shell || no_goto_lynxprog
#ifdef EXEC_LINKS
			|| local_exec_on_local_files
#endif /* EXEC_LINKS */
			) &&
		       !strncmp(user_input_buffer, "lynxprog:",9)) {
		HTUserMsg(GOTO_PROG_DISALLOWED);

	    } else if ((no_shell || no_goto_lynxcgi) &&
		       !strncmp(user_input_buffer, "lynxcgi:", 8)) {
		HTUserMsg(GOTO_CGI_DISALLOWED);

	    } else if (LYValidate &&
		       strncmp(user_input_buffer, "http:", 5) &&
		       strncmp(user_input_buffer, "https:", 6)) {
		HTUserMsg(GOTO_NON_HTTP_DISALLOWED);

	    } else if (no_goto_cso &&
		       !strncmp(user_input_buffer, "cso:", 4)) {
		HTUserMsg(GOTO_CSO_DISALLOWED);

	    } else if (no_goto_finger &&
		       !strncmp(user_input_buffer, "finger:", 7)) {
		HTUserMsg(GOTO_FINGER_DISALLOWED);

	    } else if (no_goto_ftp &&
		       !strncmp(user_input_buffer, "ftp:", 4)) {
		HTUserMsg(GOTO_FTP_DISALLOWED);

	    } else if (no_goto_gopher &&
		       !strncmp(user_input_buffer, "gopher:", 7)) {
		HTUserMsg(GOTO_GOPHER_DISALLOWED);

	    } else if (no_goto_http &&
		       !strncmp(user_input_buffer, "http:", 5)) {
		HTUserMsg(GOTO_HTTP_DISALLOWED);

	    } else if (no_goto_https &&
		       !strncmp(user_input_buffer, "https:", 6)) {
		HTUserMsg(GOTO_HTTPS_DISALLOWED);

	    } else if (no_goto_mailto &&
		       !strncmp(user_input_buffer, "mailto:", 7)) {
		HTUserMsg(GOTO_MAILTO_DISALLOWED);
d6833 4
a6836 8
#ifndef DISABLE_NEWS
	    } else if (no_goto_news &&
		       !strncmp(user_input_buffer, "news:", 5)) {
		HTUserMsg(GOTO_NEWS_DISALLOWED);

	    } else if (no_goto_nntp &&
		       !strncmp(user_input_buffer, "nntp:", 5)) {
		HTUserMsg(GOTO_NNTP_DISALLOWED);
d6838 13
d6852 5
a6856 3
	    } else if (no_goto_rlogin &&
		       !strncmp(user_input_buffer, "rlogin:", 7)) {
		HTUserMsg(GOTO_RLOGIN_DISALLOWED);
d6858 9
a6866 26
#ifndef DISABLE_NEWS
	    } else if (no_goto_snews &&
		       !strncmp(user_input_buffer, "snews:", 6)) {
		HTUserMsg(GOTO_SNEWS_DISALLOWED);
#endif

	    } else if (no_goto_telnet &&
		       !strncmp(user_input_buffer, "telnet:", 7)) {
		HTUserMsg(GOTO_TELNET_DISALLOWED);

	    } else if (no_goto_tn3270 &&
		       !strncmp(user_input_buffer, "tn3270:", 7)) {
		HTUserMsg(GOTO_TN3270_DISALLOWED);

	    } else if (no_goto_wais &&
		       !strncmp(user_input_buffer, "wais:", 5)) {
		HTUserMsg(GOTO_WAIS_DISALLOWED);

	    } else if (!strncmp(user_input_buffer, "LYNXCOOKIE:", 11) ||
		       !strncmp(user_input_buffer, "LYNXDIRED:", 10) ||
		       !strncmp(user_input_buffer, "LYNXDOWNLOAD:", 13) ||
		       !strncmp(user_input_buffer, "LYNXOPTIONS:", 12) ||
		       !strncmp(user_input_buffer, "LYNXCFG:", 8) ||
		       !strncmp(user_input_buffer, "LYNXCOMPILEOPTS:", 16) ||
		       !strncmp(user_input_buffer, "LYNXPRINT:", 10)) {
		HTUserMsg(GOTO_SPECIAL_DISALLOWED);
d6868 13
a6880 25
	   } else {
		StrAllocCopy(newdoc.address, user_input_buffer);
		newdoc.isHEAD = FALSE;
		/*
		 *  Might be an anchor in the same doc from a POST
		 *  form.  If so, dont't free the content. -- FM
		 */
		if (are_different(&curdoc, &newdoc)) {
		    /*
		     *	Make a name for this new URL.
		     */
		    StrAllocCopy(newdoc.title, gettext("A URL specified by the user"));
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    force_load = TRUE;
#ifdef DIRED_SUPPORT
		    if (lynx_edit_mode)
			HTuncache_current_document();
#endif /* DIRED_SUPPORT */
		}
		LYUserSpecifiedURL = TRUE;
		HTAddGotoURL(newdoc.address);
d6882 1
a6882 1
	    break;
d6884 4
a6887 16
	case LYK_HELP:			/* show help file */
	    if (!STREQ(curdoc.address, helpfile)) {
		/*
		 *  Set the filename.
		 */
		StrAllocCopy(newdoc.address, helpfile);
		/*
		 *  Make a name for this help file.
		 */
		StrAllocCopy(newdoc.title, gettext("Help Screen"));
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
d6891 5
a6895 1
	case LYK_INDEX:  /* index file */
d6897 1
a6897 1
	     *	Make sure we are not in the index already.
d6899 1
a6899 1
	    if (!STREQ(curdoc.address, indexfile)) {
d6901 15
a6915 5
		if (indexfile[0]=='\0') { /* no defined index */
			if (old_c != real_c)	{
			    old_c = real_c;
			    HTUserMsg(NO_INDEX_FILE);
			}
d6917 2
a6918 11
		} else {
		    StrAllocCopy(newdoc.address, indexfile);
		    StrAllocCopy(newdoc.title, gettext("System Index")); /* name it */
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		} /* end else */
	    }  /* end if */
d6921 2
a6922 5
	case LYK_MAIN_MENU:	/* return to main screen */
	    /*
	     *	If its already the homepage then don't reload it.
	     */
	    if (!STREQ(curdoc.address,homepage)) {
d6924 3
a6926 15
		if (HTConfirmDefault(CONFIRM_MAIN_SCREEN, NO) == YES) {
		    StrAllocCopy(newdoc.address, homepage);
		    StrAllocCopy(newdoc.title, gettext("Entry into main screen"));
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    highlight(OFF, curdoc.link, prev_target);
#ifdef DIRED_SUPPORT
		    if (lynx_edit_mode)
		      HTuncache_current_document();
#endif /* DIRED_SUPPORT */
		}
d6928 2
a6929 4
		if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(IN_MAIN_SCREEN);
		}
d6931 4
d6937 2
a6938 122
	case LYK_OPTIONS:     /* options screen */
#ifdef DIRED_SUPPORT
	    c = dir_list_style;
#endif /* DIRED_SUPPORT */
#ifndef NO_OPTION_MENU
if (!LYUseFormsOptions) {
	    BOOLEAN LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
	    BOOLEAN LYSelectPopups_flag = LYSelectPopups;
	    BOOLEAN verbose_img_flag = verbose_img;
	    BOOLEAN keypad_mode_flag = keypad_mode;
	    BOOLEAN show_dotfiles_flag = show_dotfiles;
	    BOOLEAN user_mode_flag = user_mode;
	    int CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
	    int CurrentCharSet_flag = current_char_set;
	    int HTfileSortMethod_flag = HTfileSortMethod;
	    char *CurrentUserAgent = NULL;
	    char *CurrentNegoLanguage = NULL;
	    char *CurrentNegoCharset = NULL;
	    StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : ""));
	    StrAllocCopy(CurrentNegoLanguage, (language ?
					       language : ""));
	    StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					      pref_charset : ""));

	    LYoptions(); /** do the old-style options stuff **/

	    if (keypad_mode_flag != keypad_mode ||
		(user_mode_flag != user_mode &&
		 (user_mode_flag == NOVICE_MODE ||
		  user_mode == NOVICE_MODE)) ||
		(((HTfileSortMethod_flag != HTfileSortMethod) ||
#ifdef DIRED_SUPPORT
		  (c != dir_list_style) ||
#endif /* DIRED_SUPPORT */
		  (show_dotfiles_flag != show_dotfiles)) &&
		 (!strncmp(curdoc.address, "file:", 5) ||
		  !strncmp(curdoc.address, "ftp:", 4))) ||
		CurrentCharSet_flag != current_char_set ||
		CurrentAssumeCharSet_flag != UCLYhndl_for_unspec ||
		verbose_img_flag != verbose_img ||
		LYUseDefaultRawMode_flag != LYUseDefaultRawMode ||
		LYSelectPopups_flag != LYSelectPopups ||
		((strcmp(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : "")) ||
		  strcmp(CurrentNegoLanguage, (language ?
					       language : "")) ||
		  strcmp(CurrentNegoCharset, (pref_charset ?
					      pref_charset : ""))) &&
		 (!strncmp(curdoc.address, "http", 4) ||
		  !strncmp(curdoc.address, "lynxcgi:", 8)))) {
		/*
		 *  Check if this is a reply from a POST, and if so,
		 *  seek confirmation of reload if the safe element
		 *  is not set. - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    confirm_post_resub(curdoc.address, curdoc.title,
				       2, 1) == FALSE) {
		    HTInfoMsg(WILL_NOT_RELOAD_DOC);
		} else {
		    StrAllocCopy(newdoc.address, curdoc.address);
		    if (((strcmp(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : "")) ||
			  strcmp(CurrentNegoLanguage,
				 (language ? language : "")) ||
			  strcmp(CurrentNegoCharset,
				 (pref_charset ? pref_charset : ""))) &&
			 (strncmp(curdoc.address, "http", 4) == 0 ||
			  strncmp(curdoc.address, "lynxcgi:", 8) == 0))) {
			/*
			 *  An option has changed which may influence
			 *  content negotiation, and the resource is from
			 *  a http or https or lynxcgi URL (the only protocols
			 *  which currently do anything with this information).
			 *  Set reloading = TRUE so that proxy caches will be
			 *  flushed, which is necessary until the time when
			 *  all proxies understand HTTP 1.1 Vary: and all
			 *  Servers properly use it...	Treat like
			 *  case LYK_RELOAD (see comments there). - KW
			 */
			reloading = TRUE;
		    }
		    if (HTisDocumentSource()) {
#ifndef USE_PSRC
			HTOutputFormat = WWW_SOURCE;
#else
			if (LYpsrc)
			    psrc_view = TRUE;
			else
			    HTOutputFormat = WWW_SOURCE;
#endif
		    }
#ifdef SOURCE_CACHE
		    if (reloading == FALSE) {
			/* one more attempt to be smart enough: */
			if (HTreparse_document()) {
			    FREE(CurrentUserAgent);
			    FREE(CurrentNegoLanguage);
			    FREE(CurrentNegoCharset);
			    break;
			}
		    }
#endif
		    HEAD_request = HTLoadedDocumentIsHEAD();
		    HTuncache_current_document();
#ifdef NO_ASSUME_SAME_DOC
		    newdoc.line = 1;
		    newdoc.link = 0;
#else
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
#endif /* NO_ASSUME_SAME_DOC */
		    LYforce_no_cache = TRUE;
		    FREE(curdoc.address); /* So it doesn't get pushed. */
		}
	    }
	    FREE(CurrentUserAgent);
	    FREE(CurrentNegoLanguage);
	    FREE(CurrentNegoCharset);
	    refresh_screen = TRUE; /* to repaint screen */
a6939 19
} /* end if !LYUseFormsOptions */
#endif /* !NO_OPTION_MENU */
#ifndef NO_OPTION_FORMS
	    /*
	     * Generally stolen from LYK_COOKIE_JAR.  Options menu handling is
	     * done in postoptions(), called from getfile() currently.
	     *
	     * postoptions() is also responsible for reloading the document
	     * before the 'options menu' but only when (a few) important
	     * options were changed.
	     *
	     * It is critical that post_data is freed here since the
	     * submission of changed options is done via the same protocol as
	     * LYNXOPTIONS:
	     */
	    /*
	     *	Don't do if already viewing options page.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""), OPTIONS_TITLE)) {
d6941 2
a6942 19
		StrAllocCopy(newdoc.address, "LYNXOPTIONS:/");
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYforce_no_cache = TRUE;
		if (LYValidate || check_realm) {
		    LYPermitURL = TRUE;
		}
	   } else {
		/*
		 *  If already in the options menu, get out.
		 */
		cmd = LYK_PREV_DOC;
		goto new_cmd;
	    }
#endif /* !NO_OPTION_FORMS */
d6945 2
a6946 74
	case LYK_INDEX_SEARCH: /* search for a user string */
	    if (is_www_index) {
		/*
		 *  Perform a database search.
		 *
		 *  do_www_search will try to go out and get the document.
		 *  If it returns TRUE, a new document was returned and is
		 *  named in the newdoc.address.
		 */
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		if (do_www_search(&newdoc) == NORMAL) {
		    /*
		     *	Yah, the search succeeded.
		     */
		    if (TRACE && !LYUseTraceLog && LYCursesON) {
			/*
			 *  Make sure cursor is down.
			 */
			move(LYlines-1, LYcols-1);
#ifdef USE_SLANG
			addstr("\n");
#endif /* USE_SLANG */
			refresh();
		    }
		    LYpush(&curdoc, ForcePush);
		    /*
		     *	Make the curdoc.address the newdoc.address so that
		     *	getfile doesn't try to get the newdoc.address.
		     *	Since we have already gotten it.
		     */
		    StrAllocCopy(curdoc.address, newdoc.address);
		    StrAllocCopy(newdoc.post_data, curdoc.post_data);
		    newdoc.internal_link = FALSE;
		    curdoc.line = -1;
		    Newline = 0;
		    refresh_screen = TRUE; /* redisplay it */
		} else if (use_this_url_instead != NULL) {
		    /*
		     *	Got back a redirecting URL.  Check it out.
		     */
		    _user_message("Using %s", use_this_url_instead);
		    /*
		     *	Make a name for this URL.
		     */
		    StrAllocCopy(newdoc.title,
				 "A URL specified by redirection");
		    StrAllocCopy(newdoc.address, use_this_url_instead);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    FREE(use_this_url_instead);
		    force_load = TRUE;
		    break;
		} else {
		    /*
		     *	Yuk, the search failed.  Restore the old file.
		     */
		    StrAllocCopy(newdoc.address, curdoc.address);
		    StrAllocCopy(newdoc.post_data, curdoc.post_data);
		    StrAllocCopy(newdoc.post_content_type,
				 curdoc.post_content_type);
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    newdoc.isHEAD = curdoc.isHEAD;
		    newdoc.safe = curdoc.safe;
		    newdoc.internal_link = curdoc.internal_link;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTUserMsg(NOT_ISINDEX);
	    }
d6949 2
a6950 66
	case LYK_WHEREIS: /* search within the document */
	case LYK_NEXT:	  /* search for the next occurrence in the document */
	    /* user search */
	{
	    BOOLEAN have_target_onscreen = (*prev_target != '\0' &&
					    HText_pageHasPrevTarget());
	    BOOL found;
	    int oldcur = curdoc.link; /* temporarily remember */
	    char *remember_old_target = NULL;
	    if (have_target_onscreen)
		StrAllocCopy(remember_old_target, prev_target);
	    else
		StrAllocCopy(remember_old_target, "");

	    if (cmd != LYK_NEXT) {
		/*
		 *  Reset prev_target to force prompting
		 *  for a new search string and to turn
		 *  off highlighting in no search string
		 *  is entered by the user.
		 */
		*prev_target = '\0';
		found = textsearch(&curdoc, prev_target, FALSE);
	    } else {
		/*
		 *  When the third argument is TRUE, the previous
		 *  search string, if any, will be recalled from
		 *  a buffer, loaded into prev_target, and used
		 *  for the search without prompting for a new
		 *  search string.  This allows the LYK_NEXT
		 *  command to repeat a search in a new document,
		 *  after prev_target was reset on fetch of that
		 *  document.
		 */
		found = textsearch(&curdoc, prev_target, TRUE);
	    }

	    /*
	     *	Force a redraw to ensure highlighting of hits
	     *	even when found on the same page, or clearing
	     *	of highlighting is the default search string
	     *	was erased without replacement. - FM
	     */
	    /*
	    ** Well let's try to avoid it at least in a few cases
	    ** where it is not needed. - kw
	    */
	    if (www_search_result >= 0 && www_search_result != curdoc.line) {
		refresh_screen = TRUE; /* doesn't really matter */
	    } else if (!found) {
		refresh_screen = have_target_onscreen;
	    } else if (!have_target_onscreen && found) {
		refresh_screen = TRUE;
	    } else if (www_search_result == curdoc.line &&
		       curdoc.link == oldcur &&
		       curdoc.link >= 0 && nlinks > 0 &&
		       links[curdoc.link].ly >= (display_lines/3)) {
		refresh_screen = TRUE;
	    } else if ((case_sensitive && 0!=strcmp(prev_target,
						    remember_old_target)) ||
		      (!case_sensitive && 0!=strcasecomp8(prev_target,
						    remember_old_target))) {
		refresh_screen = TRUE;
	    }
	    FREE(remember_old_target);
	}
d6953 4
a6956 21
	case LYK_COMMENT:  /* reply by mail */
	    if (!owner_address &&
		strncasecomp(curdoc.address, "http", 4)) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(NO_OWNER);
		}
	    } else if (no_mail) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(MAIL_DISALLOWED);
		}
	    } else {
		if (HTConfirmDefault(CONFIRM_COMMENT, NO)) {
		    if (!owner_address) {
			/*
			 *  No owner defined, so make a guess and
			 *  and offer it to the user. - FM
			 */
			char *address = NULL;
			temp = HTParse(curdoc.address, "", PARSE_PATH);
d6958 2
a6959 55
			if (temp != NULL) {
			    HTUnEscape(temp);
			    if (*temp == '~' && strlen(temp) > 1) {
				/*
				 *  It's a ~user URL so guess user@@host. - FM
				 */
				if ((cp = strchr((temp+1), '/')) != NULL)
				    *cp = '\0';
				StrAllocCopy(address, "mailto:");
				StrAllocCat(address, (temp+1));
				StrAllocCat(address, "@@");
			    }
			    FREE(temp);
			}
			if (address == NULL)
			    /*
			     *	Wasn't a ~user URL so guess WebMaster@@host. - FM
			     */
			    StrAllocCopy(address, "mailto:WebMaster@@");
			temp = HTParse(curdoc.address, "", PARSE_HOST);
			StrAllocCat(address, temp);
			HTSprintf0(&temp, NO_OWNER_USE, address);
			c = HTConfirmDefault(temp, NO);
			FREE(temp);
			if (c == YES) {
			    StrAllocCopy(owner_address, address);
			    FREE(address);
			} else {
			    FREE(address);
			    break;
			}
		    }
		    if (is_url(owner_address) != MAILTO_URL_TYPE) {
			/*
			 *  The address is a URL.  Just follow the link.
			 */
			StrAllocCopy(newdoc.address, owner_address);
			newdoc.internal_link = FALSE;
		    } else {
			/*
			 *  The owner_address is a mailto: URL.
			 */
			CONST char *kp = HText_getRevTitle();
			CONST char *id = HText_getMessageID();
			char *tmptitle = NULL;
			if (!kp && HTMainAnchor) {
			    kp = HTAnchor_subject(HTMainAnchor);
			    if (kp && *kp) {
				if (strncasecomp(kp, "Re: ", 4)) {
				    StrAllocCopy(tmptitle, "Re: ");
				    StrAllocCat(tmptitle, kp);
				    kp = tmptitle;
				}
			    }
			}
d6961 3
a6963 10
			if (strchr(owner_address,':')!=NULL)
			     /*
			      *  Send a reply.	The address is after the colon.
			      */
			     reply_by_mail(strchr(owner_address,':')+1,
					   curdoc.address,
					   (kp ? kp : ""), id);
			else
			    reply_by_mail(owner_address, curdoc.address,
					  (kp ? kp : ""), id);
d6965 2
a6966 5
			FREE(tmptitle);
			refresh_screen = TRUE;	/* to force a showpage */
		    }
		}
	    }
d6969 2
a6970 46
#ifdef DIRED_SUPPORT
	case LYK_TAG_LINK:	/* tag or untag the current link */
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
		if (!strcmp(links[curdoc.link].hightext, ".."))
		    break;	/* Never tag the parent directory */
		if (dir_list_style == MIXED_STYLE) {
		    if (!strcmp(links[curdoc.link].hightext, "../"))
			break;
		} else if (!strncmp(links[curdoc.link].hightext, "Up to ", 6))
		    break;
		{
		    /*
		     *	HTList-based management of tag list, see LYLocal.c - KW
		     */
		    HTList * t1 = tagged;
		    char * tagname = NULL;
		    BOOLEAN found = FALSE;

		    while ((tagname = (char *)HTList_nextObject(t1)) != NULL) {
			if (!strcmp(links[curdoc.link].lname, tagname)) {
			    found = TRUE;
			    HTList_removeObject(tagged, tagname);
			    FREE(tagname);
			    tagflag(OFF,curdoc.link);
			    break;
			}
		    }
		    if (!found) {
			if (tagged == NULL)
			    tagged = HTList_new();
			tagname = NULL;
			StrAllocCopy(tagname,links[curdoc.link].lname);
			HTList_addObject(tagged,tagname);
			tagflag(ON,curdoc.link);
		    }
		}
		if (curdoc.link < nlinks-1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link++;
		} else if (!more && Newline == 1 && curdoc.link == nlinks-1) {
		    highlight(OFF, curdoc.link, prev_target);
		    curdoc.link = 0;
		} else if (more) {  /* next page */
		    Newline += (display_lines);
		}
	    }
d6973 3
a6975 3
	case LYK_MODIFY:  /* rename a file or directory */
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
		int ret;
d6977 2
a6978 18
		ret = local_modify(&curdoc, &newdoc.address);
		if (ret == PERMIT_FORM_RESULT) { /* Permit form thrown up */
		    refresh_screen = TRUE;
		} else if (ret) {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    FREE(curdoc.address);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.internal_link = FALSE;
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    clear();
		}
	    }
d6981 2
a6982 16
	case LYK_CREATE:  /* create a new file or directory */
	    if (lynx_edit_mode && !no_dired_support) {
		if (local_create(&curdoc)) {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    FREE(curdoc.address);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    FREE(newdoc.bookmark);
		    newdoc.isHEAD = FALSE;
		    newdoc.safe = FALSE;
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link > -1 ? curdoc.link : 0;
		    clear();
		}
	    }
a6983 1
#endif /* DIRED_SUPPORT */
d6985 5
a6989 19
	case LYK_EDIT:	/* edit */
	    if (no_editor) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_DISABLED);
		}
		break;
	    }
#ifdef AUTOEXTEDIT
	    /*
	     *  If we're in a forms TEXTAREA, invoke the editor on *its*
	     *  contents, rather than attempting to edit the html source
	     *  document.  KED
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
		cmd = LYK_EDIT_TEXTAREA;
		goto new_cmd;
	    }
d6991 22
a7012 15
	    /*
	     *  If we're in a forms TEXT type, tell user the request
	     *  is bogus (though in reality, without this trap, if the
	     *  document with the TEXT field is local, the editor *would*
	     *  be invoked on the source .html file; eg, the o(ptions)
	     *  form tempfile).
	     *
	     *  [This is done to avoid possible user confusion, due to
	     *   auto invocation of the editor on the TEXTAREA's contents
	     *   via the above if() statement.]
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXT_TYPE)       {
		HTUserMsg (CANNOT_EDIT_FIELD);
		break;
d7014 1
a7014 1
#endif /* AUTOEXTEDIT */
d7016 7
a7022 13
#ifdef DIRED_SUPPORT
	    /*
	     *	Allow the user to edit the link rather
	     *	than curdoc in edit mode.
	     */
	    if (lynx_edit_mode &&
		editor && *editor != '\0' && !no_dired_support) {
		if (nlinks > 0) {
		    cp = links[curdoc.link].lname;
		    if (is_url(cp) == FILE_URL_TYPE) {
			cp = HTfullURL_toFile(cp);
			StrAllocCopy(tp, cp);
			FREE(cp);
d7024 32
a7055 28
			if (stat(tp, &dir_info) == -1) {
			    HTAlert(NO_STATUS);
			} else {
			    if (S_ISREG(dir_info.st_mode)) {
				StrAllocCopy(tp, links[curdoc.link].lname);
				HTUnEscapeSome(tp, "/");
				if (edit_current_file(tp,
						      curdoc.link, Newline)) {
				    HTuncache_current_document();
				    StrAllocCopy(newdoc.address,
						 curdoc.address);
				    FREE(curdoc.address);
#ifdef NO_SEEK_OLD_POSITION
				    /*
				     *	Go to top of file.
				     */
				    newdoc.line = 1;
				    newdoc.link = 0;
#else
				    /*
				     *	Seek old position,
				     *	which probably changed.
				     */
				    newdoc.line = curdoc.line;
				    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
				    clear();  /* clear the screen */
				}
d7058 2
a7059 30
			FREE(tp);
		    }
		}
	    } else
#endif /* DIRED_SUPPORT */
	    if (editor && *editor != '\0') {
		if (edit_current_file(newdoc.address, curdoc.link, Newline)) {
		    HTuncache_current_document();
		    LYforce_no_cache = TRUE;  /*force reload of document */
		    FREE(curdoc.address); /* so it doesn't get pushed */
#ifdef NO_SEEK_OLD_POSITION
		    /*
		     *	Go to top of file.
		     */
		    newdoc.line = 1;
		    newdoc.link = 0;
#else
		    /*
		     *	Seek old position, which probably changed.
		     */
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
#endif /* NO_SEEK_OLD_POSITION */
		    clear();  /* clear the screen */
		}

	    } else {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_EDITOR);
d7061 4
d7067 1
d7069 14
a7082 11
	case LYK_DEL_BOOKMARK:	/* remove a bookmark file link */
#ifdef DIRED_SUPPORT
	case LYK_REMOVE:	/* remove files and directories */
	    c = NO;
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support) {
		local_remove(&curdoc);
		c = YES;
	    } else
#endif /* DIRED_SUPPORT */
	    if (curdoc.bookmark != NULL) {
		if ((c = HTConfirmDefault(CONFIRM_BOOKMARK_DELETE,NO)) != YES)
a7083 22
		remove_bookmark_link(links[curdoc.link].anchor_number-1,
				     curdoc.bookmark);
	    } else {	/* behave like REFRESH for backward compatibility */
		refresh_screen = TRUE;
		if (old_c != real_c) {
		    old_c = real_c;
		    lynx_force_repaint();
		}
		break;
	    }
	    if (c == YES) {
		HTuncache_current_document();
		StrAllocCopy(newdoc.address, curdoc.address);
		FREE(curdoc.address);
		newdoc.line = curdoc.line;
		if (curdoc.link == nlinks-1) {
		    /*
		     *	We deleted the last link on the page. - FM
		     */
		    newdoc.link = curdoc.link-1;
		} else {
		    newdoc.link = curdoc.link;
d7086 11
d7099 7
a7105 4
#ifdef DIRED_SUPPORT
	case LYK_INSTALL:  /* install a file into system area */
	    if (lynx_edit_mode && nlinks > 0 && !no_dired_support)
		local_install(NULL, links[curdoc.link].lname, &newdoc.address);
a7106 1
#endif /* DIRED_SUPPORT */
d7108 5
a7112 19
	case LYK_INFO:	/* show document info */
	    /*
	     *	Don't do if already viewing info page.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       SHOWINFO_TITLE)) {
		if (showinfo(&curdoc, HText_getNumOfLines(),
			     &newdoc, owner_address) < 0)
		    break;
		StrAllocCopy(newdoc.title, SHOWINFO_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		LYforce_no_cache = TRUE;
		if (LYValidate || check_realm)
		    LYPermitURL = TRUE;
d7114 1
a7114 4
		/*
		 *  If already in info page, get out.
		 */
		cmd = LYK_PREV_DOC;
d7119 3
a7121 8
	case LYK_EDIT_TEXTAREA: /* use external editor on a TEXTAREA - KED */
	    if (no_editor) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(EDIT_DISABLED);
		}
		break;
	    }
d7123 3
a7125 5
	    /*
	     *  See if the current link is in a form TEXTAREA.
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d7127 4
a7130 2
		/* stop screen */
		stop_curses();
d7132 4
a7135 1
		n = HText_ExtEditForm (&links[curdoc.link]);
d7137 3
a7139 8
		/*
		 *  TODO: Move cursor "n" lines from the current line to
		 *	  position it on the 1st trailing blank line in
		 *	  the now edited TEXTAREA.  If the target line/
		 *	  anchor requires us to scroll up/down, position
		 *	  the target in the approximate center of the
		 *	  screen.
		 */
d7141 4
a7144 2
		/* curdoc.link += n;*/	/* works, except for page crossing, */
					/* damnit; why is nothing ever easy */
d7146 3
a7148 3
		/* start screen */
		start_curses();
		refresh_screen = TRUE;
d7150 3
a7152 1
	    } else {
d7154 6
a7159 2
		HTInfoMsg (NOT_IN_TEXTAREA);
	    }
d7162 3
a7164 6
	case LYK_GROW_TEXTAREA: /* add new lines to bottom of TEXTAREA - KED */
	    /*
	     *  See if the current link is in a form TEXTAREA.
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {
d7166 3
a7168 1
		HText_ExpandTextarea (&links[curdoc.link], TEXTAREA_EXPAND_SIZE);
d7170 4
a7173 1
		refresh_screen = TRUE;
d7175 3
a7177 1
	    } else {
d7179 7
a7185 1
		HTInfoMsg (NOT_IN_TEXTAREA);
d7189 2
a7190 28
	case LYK_INSERT_FILE: /* insert file in TEXTAREA, above cursor - KED */
	    /*
	     *  See if the current link is in a form TEXTAREA.
	     */
	    if (links[curdoc.link].type       == WWW_FORM_LINK_TYPE &&
		links[curdoc.link].form->type == F_TEXTAREA_TYPE)   {

		n = HText_InsertFile (&links[curdoc.link]);

		/*
		 *  TODO: Move cursor "n" lines from the current line to
		 *	  position it on the 1st line following the text
		 *	  that was inserted.  If the target line/anchor
		 *	  requires us to scroll up/down, position the
		 *	  target in the approximate center of the screen.
		 *
		 *  [Current behavior leaves cursor on the same line relative
		 *   to the start of the TEXTAREA that it was on before the
		 *   insertion.  This is the same behavior that occurs with
		 *   (my) editor, so this TODO will stay unimplemented.]
		 */

		refresh_screen = TRUE;

	    } else {

		HTInfoMsg (NOT_IN_TEXTAREA);
	    }
d7193 2
a7194 6
	case LYK_PRINT:  /* print the file */
	    if (LYValidate) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(PRINT_DISABLED);
		}
a7195 7
	    }

	    /*
	     *	Don't do if already viewing print options page.
	     */
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       PRINT_OPTIONS_TITLE)) {
d7197 10
a7206 13
		if (print_options(&newdoc.address,
				  &curdoc.address, HText_getNumOfLines()) < 0)
		    break;
		StrAllocCopy(newdoc.title, PRINT_OPTIONS_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		ForcePush = TRUE;  /* see LYpush() and print_options() */
		if (check_realm)
		    LYPermitURL = TRUE;
		refresh_screen = TRUE;	/* redisplay */
d7210 4
a7213 25
	case LYK_LIST:	/* list links in the current document */
	    /*
	     *	Don't do if already viewing list page.
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			LIST_PAGE_TITLE)) {
		/*
		 *  Already viewing list page, so get out.
		 */
		cmd = LYK_PREV_DOC;
		goto new_cmd;
	    }

	    /*
	     *	Print list page to file.
	     */
	    if (showlist(&newdoc, TRUE) < 0)
		break;
	    StrAllocCopy(newdoc.title, LIST_PAGE_TITLE);
	    /*
	     *	showlist will set newdoc's other fields.  It may leave
	     *	post_data intact so the list can be used to follow
	     *	internal links in the current document even if it is
	     *	a POST response. - kw
	     */
d7215 3
a7217 5
	    refresh_screen = TRUE;  /* redisplay */
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
		StrAllocCopy(lynxlistfile, newdoc.address);
	    }
d7220 7
a7226 12
#ifdef EXP_ADDRLIST_PAGE
	case LYK_ADDRLIST:   /* always list URL's (only) */
	    /*
	     *	Don't do if already viewing list addresses page.
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			ADDRLIST_PAGE_TITLE)) {
		/*
		 *  Already viewing list page, so get out.
		 */
		cmd = LYK_PREV_DOC;
		goto new_cmd;
d7228 5
d7234 7
a7240 12
	    /*
	     *	Print address list page to file.
	     */
	    if (showlist(&newdoc, FALSE) < 0)
		break;
	    StrAllocCopy(newdoc.title, ADDRLIST_PAGE_TITLE);
	    /*
	     *	showlist will set newdoc's other fields.  It may leave
	     *	post_data intact so the list can be used to follow
	     *	internal links in the current document even if it is
	     *	a POST response. - kw
	     */
d7242 2
a7243 5
	    refresh_screen = TRUE;  /* redisplay */
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
		StrAllocCopy(lynxlistfile, newdoc.address);
	    }
a7244 1
#endif /* EXP_ADDRLIST_PAGE */
d7246 8
a7253 7
	case LYK_VLINKS:  /* list links visited during the current session */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			VISITED_LINKS_TITLE)) {
		/*
		 *  Already viewing visited links page, so get out.
		 */
		cmd = LYK_PREV_DOC;
d7255 1
a7255 1
	    }
d7257 2
a7258 19
	    /*
	     *	Print visited links page to file.
	     */
	    if (LYShowVisitedLinks(&newdoc.address) < 0) {
		HTUserMsg(VISITED_LINKS_EMPTY);
		break;
	    }
	    StrAllocCopy(newdoc.title, VISITED_LINKS_TITLE);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    refresh_screen = TRUE;
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
		StrAllocCopy(lynxlinksfile, newdoc.address);
	    }
d7261 4
a7264 23
	case LYK_TOOLBAR:  /* go to Toolbar or Banner in current document */
	    if (!HText_hasToolbar(HTMainText)) {
		if (old_c != real_c) {
		    old_c = real_c;
		    HTUserMsg(NO_TOOLBAR);
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		if ((cp = strchr(curdoc.address, '#')) != NULL)
		    *cp = '\0';
		toolbar = (char *)malloc(strlen(curdoc.address) +
					 strlen(LYToolbarName) + 2);
		if (!toolbar)
		    outofmem(__FILE__, "mainloop");

		sprintf(toolbar, "%s#%s", curdoc.address, LYToolbarName);
		if (cp)
		    *cp = '#';
		StrAllocCopy(newdoc.address, toolbar);
		FREE(toolbar);
		try_internal = TRUE;
		force_load = TRUE;  /* force MainLoop to reload */
	    }
d7267 3
a7269 23
#if defined(DIRED_SUPPORT) || defined(VMS)
	case LYK_DIRED_MENU:  /* provide full file management menu */
#ifdef VMS
	    /*
	     *	Check if the CSwing Directory/File Manager is available.
	     *	Will be disabled if LYCSwingPath is NULL, zero-length,
	     *	or "none" (case insensitive), if no_file_url was set via
	     *	the file_url restriction, if no_goto_file was set for
	     *	the anonymous account, or if HTDirAccess was set to
	     *	HT_DIR_FORBID or HT_DIR_SELECTIVE via the -nobrowse
	     *	or -selective switches. - FM
	     */
	    if (!(LYCSwingPath && *LYCSwingPath) ||
		!strcasecomp(LYCSwingPath, "none") ||
		no_file_url || no_goto_file ||
		HTDirAccess == HT_DIR_FORBID ||
		HTDirAccess == HT_DIR_SELECTIVE) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(DFM_NOT_AVAILABLE);
		}
		break;
	    }
d7271 4
a7274 30
	    /*
	     *	If we are viewing a local directory listing or a
	     *	local file which is not temporary, invoke CSwing
	     *	with the URL's directory converted to VMS path specs
	     *	and passed as the argument, so we start up CSwing
	     *	positioned on that node of the directory tree.
	     *	Otherwise, pass the current default directory as
	     *	the argument. - FM
	     */
	    if (LYisLocalFile(curdoc.address) &&
		strncasecomp(curdoc.address,
			     lynx_temp_space, strlen(lynx_temp_space))) {
		/*
		 *  We are viewing a local directory or a local file
		 *  which is not temporary. - FM
		 */
		struct stat stat_info;

		cp = HTParse(curdoc.address, "", PARSE_PATH|PARSE_PUNCTUATION);
		HTUnEscape(cp);
		if (HTStat(cp, &stat_info) == -1) {
		    CTRACE(tfp, "mainloop: Can't stat %s\n", cp);
		    FREE(cp);
		    temp = (char *)calloc(1, (strlen(LYCSwingPath) + 4));
		    if (temp == NULL)
			outofmem(__FILE__, "mainloop");
		    sprintf(temp, "%s []", LYCSwingPath);
		    refresh_screen = TRUE;  /* redisplay */
		} else {
		    char *VMSdir = NULL;
d7276 2
a7277 62
		    if (S_ISDIR(stat_info.st_mode)) {
			/*
			 *  We're viewing a local directory.  Make
			 *  that the CSwing argument. - FM
			 */
			LYAddPathSep(&cp);
			StrAllocCopy(VMSdir, HTVMS_name("", cp));
			FREE(cp);
		    } else {
			/*
			 *  We're viewing a local file.  Make it's
			 *  directory the CSwing argument. - FM
			 */
			StrAllocCopy(VMSdir, HTVMS_name("", cp));
			FREE(cp);
			if ((cp = strrchr(VMSdir, ']')) != NULL) {
			    *(cp + 1) = '\0';
			    cp == NULL;
			} else if ((cp = strrchr(VMSdir, ':')) != NULL) {
			    *(cp + 1) = '\0';
			    cp == NULL;
			}
		    }
		    temp = (char *)calloc(1,
					  (strlen(LYCSwingPath) +
					   strlen(VMSdir) +
					   2));
		    if (temp == NULL)
			outofmem(__FILE__, "mainloop");
		    sprintf(temp, "%s %s", LYCSwingPath, VMSdir);
		    FREE(VMSdir);
		    /*
		     *	Uncache the current document in case we
		     *	change, move, or delete it during the
		     *	CSwing session. - FM
		     */
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    StrAllocCopy(newdoc.title,
				 curdoc.title ? curdoc.title : "");
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    FREE(curdoc.address);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		}
	    } else {
		/*
		 *  We're not viewing a local directory or file.
		 *  Pass CSwing the current default directory as
		 *  an argument and don't uncache the current
		 *  document. - FM
		 */
		temp = (char *)calloc(1, (strlen(LYCSwingPath) + 4));
		if (temp == NULL)
		    outofmem(__FILE__, "mainloop");
		sprintf(temp, "%s []", LYCSwingPath);
		refresh_screen = TRUE;	/* redisplay */
	    }
	    stop_curses();
	    LYSystem(temp);
	    start_curses();
	    FREE(temp);
d7279 3
a7281 11
#else
	    /*
	     *	Don't do if not allowed or already viewing the menu.
	     */
	    if (lynx_edit_mode && !no_dired_support &&
		strcmp(curdoc.address, LYDiredFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       DIRED_MENU_TITLE)) {
		dired_options(&curdoc,&newdoc.address);
		refresh_screen = TRUE;	/* redisplay */
	    }
d7283 1
a7283 2
#endif /* VMS */
#endif /* DIRED_SUPPORT || VMS*/
d7285 6
a7290 6
#ifdef USE_EXTERNALS
	case LYK_EXTERN:  /* use external program on url */
	    if  ((nlinks > 0) && (links[curdoc.link].lname != NULL))
	    {
		run_external(links[curdoc.link].lname);
		refresh_screen = TRUE;
d7292 4
a7296 1
#endif /* USE_EXTERNALS */
d7298 3
a7300 8
	case LYK_ADD_BOOKMARK:	/* add link to bookmark file */
	    if (LYValidate) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(BOOKMARKS_DISABLED);
		}
		break;
	    }
a7301 6
	    if (strcmp((curdoc.title ? curdoc.title : ""),
		       HISTORY_PAGE_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       SHOWINFO_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       PRINT_OPTIONS_TITLE) &&
d7303 3
a7305 9
		strcmp(curdoc.address, LYDiredFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       DIRED_MENU_TITLE) &&
		strcmp(curdoc.address, LYPermitFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       PERMIT_OPTIONS_TITLE) &&
		strcmp(curdoc.address, LYUploadFileURL) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       UPLOAD_OPTIONS_TITLE) &&
d7307 10
a7316 137
		strcmp((curdoc.title ? curdoc.title : ""),
		       DOWNLOAD_OPTIONS_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       COOKIE_JAR_TITLE) &&
		strcmp((curdoc.title ? curdoc.title : ""),
		       OPTIONS_TITLE) &&
		((nlinks <= 0) ||
		 (links[curdoc.link].lname != NULL &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXHIST:", 9) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXPRINT:", 10) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXDIRED:", 10) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXDOWNLOAD:", 13) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXCOOKIE:", 11) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXOPTIONS:", 12) &&
		  strncmp(links[curdoc.link].lname,
			 "LYNXLIST:", 9)))) {
		if (nlinks > 0) {
		    if (curdoc.post_data == NULL &&
			curdoc.bookmark == NULL &&
			!LYIsListpageTitle(curdoc.title ? curdoc.title : "") &&
			strcmp((curdoc.title ? curdoc.title : ""),
			       VISITED_LINKS_TITLE)) {
			/*
			 *  The document doesn't have POST content,
			 *  and is not a bookmark file, nor is the
			 *  list or visited links page, so we can
			 *  save either that or the link. - FM
			 */
			_statusline(BOOK_D_L_OR_CANCEL);
			c = LYgetch();
			if (TOUPPER(c) == 'D') {
			    save_bookmark_link(curdoc.address, curdoc.title);
			    refresh_screen = TRUE; /* MultiBookmark support */
			    goto check_add_bookmark_to_self;
			}
		    } else {
			if (LYMultiBookmarks == FALSE &&
			    curdoc.bookmark != NULL &&
			    strstr(curdoc.address,
				   (*bookmark_page == '.'
						  ?
				(bookmark_page+1) : bookmark_page)) != NULL) {
			    /*
			     *	If multiple bookmarks are disabled, offer
			     *	the L)ink or C)ancel, but with wording
			     *	which indicates that the link already
			     *	exists in this bookmark file. - FM
			     */
			    _statusline(MULTIBOOKMARKS_SELF);
			} else if (curdoc.post_data != NULL &&
				   links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
			    /*
			     *	Internal link, and document has POST content.
			     */
			    HTUserMsg(NOBOOK_POST_FORM);
			    break;
			} else {
			    /*
			     *	Only offer the link in a document with
			     *	POST content, or if the current document
			     *	is a bookmark file and multiple bookmarks
			     *	are enabled. - FM
			     */
			    _statusline(BOOK_L_OR_CANCEL);
			}
			c = LYgetch();
		    }
		    if (TOUPPER(c) == 'L') {
			if (curdoc.post_data != NULL &&
			    links[curdoc.link].type == WWW_INTERN_LINK_TYPE) {
			    /*
			     *	Internal link, and document has POST content.
			     */
			    HTUserMsg(NOBOOK_POST_FORM);
			    break;
			}
			/*
			 *  User does want to save the link. - FM
			 */
			if (links[curdoc.link].type != WWW_FORM_LINK_TYPE) {
			    save_bookmark_link(links[curdoc.link].lname,
					       links[curdoc.link].hightext);
			    refresh_screen = TRUE; /* MultiBookmark support */
			} else {
			    HTUserMsg(NOBOOK_FORM_FIELD);
			    break;
			}
		    } else {
			break;
		    }
		} else if (curdoc.post_data != NULL) {
		    /*
		     *	No links, and document has POST content. - FM
		     */
		    HTUserMsg(NOBOOK_POST_FORM);
		    break;
		} else if (curdoc.bookmark != NULL) {
		    /*
		     *	It's a bookmark file from which all
		     *	of the links were deleted. - FM
		     */
		    HTUserMsg(BOOKMARKS_NOLINKS);
		    break;
		} else {
		    _statusline(BOOK_D_OR_CANCEL);
		    c = LYgetch();
		    if (TOUPPER(c) == 'D') {
			save_bookmark_link(curdoc.address, curdoc.title);
			refresh_screen = TRUE; /* MultiBookmark support */
		    } else {
			break;
		    }
		}
check_add_bookmark_to_self:
		if (curdoc.bookmark && BookmarkPage &&
		    !strcmp(curdoc.bookmark, BookmarkPage)) {
		    HTuncache_current_document();
		    StrAllocCopy(newdoc.address, curdoc.address);
		    StrAllocCopy(newdoc.bookmark, curdoc.bookmark);
		    FREE(curdoc.address);
		    newdoc.line = curdoc.line;
		    newdoc.link = curdoc.link;
		    newdoc.internal_link = FALSE;
		}
		FREE(temp);
	    } else {
		if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NOBOOK_HSML);
		}
	    }
d7319 3
a7321 8
	case LYK_VIEW_BOOKMARK:   /* v to view home page */
	    if (LYValidate) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(BOOKMARKS_DISABLED);
		}
		break;
	    }
d7323 2
a7324 29
	    /*
	     *	See if a bookmark exists.
	     *	If it does replace newdoc.address with it's name.
	     */
	    if ((cp = get_bookmark_filename(&newdoc.address)) != NULL) {
		if (*cp == '\0' || !strcmp(cp, " ") ||
		    !strcmp(curdoc.address, newdoc.address)) {
		    if (LYMultiBookmarks == TRUE)
			refresh_screen = TRUE;
		    break;
		}
		LYforce_no_cache = TRUE;  /*force the document to be reloaded*/
		StrAllocCopy(newdoc.title, BOOKMARK_TITLE);
		StrAllocCopy(newdoc.bookmark, BookmarkPage);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
	    } else {
		if (old_c != real_c) {
		    old_c = real_c;
		    LYMBM_statusline(BOOKMARKS_NOT_OPEN);
		    sleep(AlertSecs);
		    if (LYMultiBookmarks == TRUE) {
			refresh_screen = TRUE;
		    }
		}
	    }
d7327 2
a7328 13
	case LYK_SHELL:  /* shell escape */
	    if (!no_shell) {
		stop_curses();
		printf("%s\r\n", SPAWNING_MSG);
		LYSystem(LYSysShell());
		start_curses();
		refresh_screen = TRUE;	/* for an HText_pageDisplay() */
	    } else {
		if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(SPAWNING_DISABLED);
		}
	    }
d7331 3
a7333 12
	case LYK_DOWNLOAD:
	    /*
	     *	Don't do if both download and disk_save are restricted.
	     */
	    if (LYValidate ||
		(no_download && !override_no_download && no_disk_save)) {
		if (old_c != real_c)	{
		    old_c = real_c;
		    HTUserMsg(DOWNLOAD_DISABLED);
		}
		break;
	    }
d7335 4
a7338 6
	    /*
	     *	Don't do if already viewing download options page.
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			DOWNLOAD_OPTIONS_TITLE))
		break;
d7340 6
a7345 43
	    if (nlinks > 0) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
		    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
			links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE) {
			if (links[curdoc.link].form->submit_method ==
				 URL_MAIL_METHOD) {
			    if (old_c != real_c) {
				old_c = real_c;
				HTUserMsg(NO_DOWNLOAD_MAILTO_ACTION);
			    }
			    break;
			}
			if (!strncmp(links[curdoc.link].form->submit_action,
				"LYNXOPTIONS:", 12)) {
			    if (old_c != real_c) {
				old_c = real_c;
				HTUserMsg(NO_DOWNLOAD_SPECIAL);
			    }
			    break;
			}
			HTOutputFormat = HTAtom_for("www/download");
			LYforce_no_cache = TRUE;
			cmd = LYK_ACTIVATE;
			goto new_cmd;
		    }
		    if (old_c != real_c) {
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_INPUT);
		    }

		} else if (!strcmp((curdoc.title ? curdoc.title : ""),
				   COOKIE_JAR_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_COOKIES);
		    }

		} else if (!strcmp((curdoc.title ? curdoc.title : ""),
				   PRINT_OPTIONS_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_PRINT_OP);
		    }
d7347 4
a7350 16
#ifdef DIRED_SUPPORT
		} else if (!strcmp(curdoc.address, LYUploadFileURL) ||
			   !strcmp((curdoc.title ? curdoc.title : ""),
				   UPLOAD_OPTIONS_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_UPLOAD_OP);
		    }

		} else if (!strcmp(curdoc.address, LYPermitFileURL) ||
			   !strcmp((curdoc.title ? curdoc.title : ""),
				   PERMIT_OPTIONS_TITLE)) {
		    if (old_c != real_c)	{
			old_c = real_c;
			HTUserMsg(NO_DOWNLOAD_PERMIT_OP);
		    }
d7352 3
a7354 13
		} else if (lynx_edit_mode && !no_dired_support) {
		    /*
		     *	Don't bother making a /tmp copy of the local file.
		     */
		    StrAllocCopy(temp, newdoc.address);
		    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
		    if (LYdownload_options(&newdoc.address,
					   links[curdoc.link].lname) < 0)
			StrAllocCopy(newdoc.address, temp);
		    else
			newdoc.internal_link = FALSE;
		    FREE(temp);
#endif /* DIRED_SUPPORT */
d7356 5
a7360 34
		} else if (!strcmp((curdoc.title ? curdoc.title : ""),
				   HISTORY_PAGE_TITLE) &&
		    !strncmp(links[curdoc.link].lname, "LYNXHIST:", 9)) {
		    int number = atoi(links[curdoc.link].lname+9);
		    if ((history[number].post_data != NULL &&
			 history[number].safe != TRUE) &&
			HTConfirm(CONFIRM_POST_RESUBMISSION) == FALSE) {
			HTInfoMsg(CANCELLED);
			break;
		    }
		    /*
		     *  OK, we download from history page, restore URL from stack.
		     */
		    StrAllocCopy(newdoc.address, history[number].address);
		    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
		    StrAllocCopy(newdoc.bookmark, history[number].bookmark);
		    FREE(newdoc.post_data);
		    FREE(newdoc.post_content_type);
		    if (history[number].post_data)
			StrAllocCopy(newdoc.post_data,
				     history[number].post_data);
		    if (history[number].post_content_type)
			StrAllocCopy(newdoc.post_content_type,
				     history[number].post_content_type);
		    newdoc.isHEAD = history[number].isHEAD;
		    newdoc.safe = history[number].safe;
		    newdoc.internal_link = FALSE;
		    newdoc.link = 0;
		    HTOutputFormat = HTAtom_for("www/download");
		    LYUserSpecifiedURL = TRUE;
		    /*
		     *	Force the document to be reloaded.
		     */
		    LYforce_no_cache = TRUE;
d7362 6
a7367 83
		} else if (!strncmp(links[curdoc.link].lname, "data:", 5)) {
		    if (old_c != real_c) {
			old_c = real_c;
			HTAlert(UNSUPPORTED_DATA_URL);
		    }

		} else if (!strncmp(links[curdoc.link].lname,
				    "LYNXCOOKIE:", 11) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXDIRED:", 10) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXDOWNLOAD:", 13) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXPRINT:", 10) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXOPTIONS:", 12) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXCFG:", 8) ||
			   !strncmp(links[curdoc.link].lname,
				    "LYNXCOMPILEOPTS:", 16) ||
			   !strncmp(links[curdoc.link].lname,
				    "lynxexec:", 9) ||
			   !strncmp(links[curdoc.link].lname,
				    "lynxprog:", 9)) {
		    HTUserMsg(NO_DOWNLOAD_SPECIAL);

		} else if (!strncmp(links[curdoc.link].lname,
				    "mailto:", 7)) {
		    HTUserMsg(NO_DOWNLOAD_MAILTO_LINK);

		/*
		 *  From here on we could have a remote host, so check if
		 *  that's allowed.
		 *
		 *  We copy all these checks from getfile() to LYK_DOWNLOAD
		 *  here because LYNXDOWNLOAD:// will NOT be pushing the
		 *  previous document into the history stack so preserve
		 *  getfile() from returning a wrong status (NULLFILE).
		 */
		} else if (local_host_only &&
			   !(LYisLocalHost(links[curdoc.link].lname) ||
			     LYisLocalAlias(links[curdoc.link].lname))) {
		    HTUserMsg(ACCESS_ONLY_LOCALHOST);
		} else {   /* Not a forms, options or history link */
		    /*
		     *	Follow a normal link or anchor.  Note that
		     *	if it's an anchor within the same document,
		     *	entire document will be downloaded.
		     */
		    StrAllocCopy(newdoc.address, links[curdoc.link].lname);
		    StrAllocCopy(newdoc.title, links[curdoc.link].hightext);
#ifndef DONT_TRACK_INTERNAL_LINKS
		    /*
		     *	Might be an internal link in the same doc from a
		     *	POST form.  If so, don't free the content. - kw
		     */
		    if (links[curdoc.link].type != WWW_INTERN_LINK_TYPE)
#else
		    /*
		     *	Might be an anchor in the same doc from a POST
		     *	form.  If so, don't free the content. -- FM
		     */
		    if (are_different(&curdoc, &newdoc))
#endif /* TRACK_INTERNAL_LINKS */
		    {
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
			FREE(newdoc.bookmark);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
		    }
		    newdoc.internal_link = FALSE;
		    newdoc.link = 0;
		    HTOutputFormat = HTAtom_for("www/download");
		    /*
		     *	Force the document to be reloaded.
		     */
		    LYforce_no_cache = TRUE;
		}
	    } else if (old_c != real_c) {
		old_c = real_c;
		HTUserMsg(NO_DOWNLOAD_CHOICE);
	    }
d7369 1
d7371 3
a7373 9
#ifdef DIRED_SUPPORT
	  case LYK_UPLOAD:
	    /*
	     *	Don't do if already viewing upload options page.
	     */
	    if (!strcmp(curdoc.address, LYUploadFileURL) ||
		!strcmp((curdoc.title ? curdoc.title : ""),
			UPLOAD_OPTIONS_TITLE))
		break;
d7375 2
a7376 17
	    if (lynx_edit_mode && !no_dired_support) {
		LYUpload_options((char **)&newdoc.address,
				 (char *)curdoc.address);
		StrAllocCopy(newdoc.title, UPLOAD_OPTIONS_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		/*
		 *  Uncache the current listing so that it will
		 *  be updated to included the uploaded file if
		 *  placed in the current directory. - FM
		 */
		HTuncache_current_document();
	     }
a7377 1
#endif /* DIRED_SUPPORT */
d7379 2
a7380 4
	case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	    WWW_TraceFlag = ! WWW_TraceFlag;
	    if (LYOpenTraceLog())
		HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
d7383 6
a7388 8
	case LYK_TRACE_LOG:	/*  View TRACE log. */
	    /*
	     *	Check whether we've started a TRACE log
	     *	in this session. - FM
	     */
	    if (LYTraceLogFP == NULL) {
		HTUserMsg(NO_TRACELOG_STARTED);
		break;
d7390 1
d7392 5
a7396 6
	    /*
	     *	Don't do if already viewing the TRACE log. - FM
	     */
	    if (!strcmp((curdoc.title ? curdoc.title : ""),
			LYNX_TRACELOG_TITLE))
		break;
d7398 3
a7400 13
	    /*
	     *	If TRACE mode is on, turn it off during this fetch of the
	     *	TRACE log, so we don't enter stuff about this fetch, and
	     *	set a flag for turning it back on when we return to this
	     *	loop.  Note that we'll miss any messages about memory
	     *	exhaustion if it should occur.	It seems unlikely that
	     *	anything else bad might happen, but if it does, we'll
	     *	miss messages about that too.  We also fflush(), close,
	     *	and open it again, to make sure all stderr messages thus
	     *	far will be in the log. - FM
	     */
	    if (!LYReopenTracelog(&trace_mode_flag))
		break;
d7402 2
a7403 12
	    LYLocalFileToURL (&(newdoc.address), LYTraceLogPath);
	    StrAllocCopy(newdoc.title, LYNX_TRACELOG_TITLE);
	    FREE(newdoc.post_data);
	    FREE(newdoc.post_content_type);
	    FREE(newdoc.bookmark);
	    newdoc.isHEAD = FALSE;
	    newdoc.safe = FALSE;
	    newdoc.internal_link = FALSE;
	    if (LYValidate || check_realm) {
		LYPermitURL = TRUE;
	    }
	    LYforce_no_cache = TRUE;
d7407 3
a7409 14
	    if (clickable_images)
		clickable_images = FALSE;
	    else
		clickable_images = TRUE;

	    HTUserMsg(clickable_images ?
		     CLICKABLE_IMAGES_ON : CLICKABLE_IMAGES_OFF);
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break;
	    }
#endif
	    cmd = LYK_RELOAD;
	    goto new_cmd;
d7412 3
a7414 14
	    if (pseudo_inline_alts)
		pseudo_inline_alts = FALSE;
	    else
		pseudo_inline_alts = TRUE;

	    HTUserMsg(pseudo_inline_alts ?
		      PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
#ifdef SOURCE_CACHE
	    if (HTreparse_document()) {
		break;
	    }
#endif
	    cmd = LYK_RELOAD;
	    goto new_cmd;
d7417 1
a7417 13
	    if (HTLoadedDocumentCharset()) {
		HTUserMsg(gettext("charset for this document specified explicitely, sorry..."));
		break;
	    } else {
		LYUseDefaultRawMode = !LYUseDefaultRawMode;
		HTUserMsg(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
		HTMLSetCharacterHandling(current_char_set);
#ifdef SOURCE_CACHE
		if (HTreparse_document()) {
		    break;
		}
#endif
		cmd = LYK_RELOAD;
d7419 1
a7419 1
	    }
d7422 2
a7423 122
	    if (nlinks > 0 &&
		(links[curdoc.link].type != WWW_FORM_LINK_TYPE ||
		 links[curdoc.link].form->type == F_SUBMIT_TYPE ||
		 links[curdoc.link].form->type == F_IMAGE_SUBMIT_TYPE)) {
		/*
		 *  We have links, and the current link is a
		 *  normal link or a form's submit button. - FM
		 */
		_statusline(HEAD_D_L_OR_CANCEL);
		c = LYgetch();
		if (TOUPPER(c) == 'D') {
		    char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
			curdoc.address : curdoc.address + 11;
		    if (LYCanDoHEAD(scheme) != TRUE) {
			HTUserMsg(DOC_NOT_HTTP_URL);
		    } else {
			/*
			 *  Check if this is a reply from a POST,
			 *  and if so, seek confirmation if the
			 *  safe element is not set. - FM
			 */
			if ((curdoc.post_data != NULL &&
			     curdoc.safe != TRUE) &&
			    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
			    HTInfoMsg(CANCELLED);
			    break;
			}
			HEAD_request = TRUE;
			LYforce_no_cache = TRUE;
			StrAllocCopy(newdoc.title, curdoc.title);
			if (HTLoadedDocumentIsHEAD()) {
			    HTuncache_current_document();
			    FREE(curdoc.address);
			} else {
			    StrAllocCat(newdoc.title, " - HEAD");
			}
		    }
		    break;
		} else if (TOUPPER(c) == 'L') {
		    if (links[curdoc.link].type != WWW_FORM_LINK_TYPE &&
			strncmp(links[curdoc.link].lname, "http", 4) &&
			strncmp(links[curdoc.link].lname,
				"LYNXIMGMAP:http", 15) &&
			LYCanDoHEAD(links[curdoc.link].lname) != TRUE &&
			(links[curdoc.link].type != WWW_INTERN_LINK_TYPE ||
			 !curdoc.address ||
			 strncmp(curdoc.address, "http", 4))) {
			HTUserMsg(LINK_NOT_HTTP_URL);
		    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			       links[curdoc.link].form->disabled) {
			HTUserMsg(FORM_ACTION_DISABLED);
		    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			       strncmp(links[curdoc.link].form->submit_action,
							      "lynxcgi:", 8) &&
			       strncmp(links[curdoc.link].form->submit_action,
								 "http", 4)) {
			HTUserMsg(FORM_ACTION_NOT_HTTP_URL);
		    } else if (links[curdoc.link].type == WWW_FORM_LINK_TYPE &&
			       links[curdoc.link].form->submit_method ==
							  URL_POST_METHOD &&
			       HTConfirm(CONFIRM_POST_LINK_HEAD) == FALSE) {
			HTInfoMsg(CANCELLED);
		    } else {
			HEAD_request = TRUE;
			LYforce_no_cache = TRUE;
			cmd = LYK_ACTIVATE;
			goto new_cmd;
		    }
		    break;
		}
		break;
	    } else {
		/*
		 *  We can offer only this document for a HEAD request.
		 *  Check if this is a reply from a POST, and if so,
		 *  seek confirmation if the safe element is not set. - FM
		 */
		if ((curdoc.post_data != NULL &&
		     curdoc.safe != TRUE) &&
		    HTConfirm(CONFIRM_POST_DOC_HEAD) == FALSE) {
		    HTInfoMsg(CANCELLED);
		    break;
		} else if (nlinks > 0) {
		    /*
		     *	The current link is a non-submittable form
		     *	link, so prompt the user to make it clear
		     *	that the HEAD request would be for the
		     *	current document, not the form link. - FM
		     */
		    _statusline(HEAD_D_OR_CANCEL);
		    c = LYgetch();
		} else {
		    /*
		     *	No links, so we can just assume that
		     *	the user wants a HEAD request for the
		     *	current document. - FM
		     */
		    c = 'D';
		}
		if (TOUPPER(c) == 'D') {
		    char *scheme = strncmp(curdoc.address, "LYNXIMGMAP:", 11) ?
			curdoc.address : curdoc.address + 11;
		    /*
		     *	The user didn't cancel, so check if
		     *	a HEAD request is appropriate for the
		     *	current document. - FM
		     */
		    if (LYCanDoHEAD(scheme) != TRUE) {
			HTUserMsg(DOC_NOT_HTTP_URL);
		    } else {
			HEAD_request = TRUE;
			LYforce_no_cache = TRUE;
			StrAllocCopy(newdoc.title, curdoc.title);
			if (HTLoadedDocumentIsHEAD()) {
			    HTuncache_current_document();
			    FREE(curdoc.address);
			} else {
			    StrAllocCat(newdoc.title, " - HEAD");
			}
		    }
		}
	    }
d7427 1
a7427 4
	    if (user_mode == NOVICE_MODE) {
		toggle_novice_line();
		noviceline(more);
	    }
d7431 1
a7431 31
	    if (old_c != real_c) {
		old_c = real_c;
		StrAllocCopy(newdoc.address, "LYNXKEYMAP:");
		StrAllocCopy(newdoc.title, CURRENT_KEYMAP_TITLE);
		FREE(newdoc.post_data);
		FREE(newdoc.post_content_type);
		FREE(newdoc.bookmark);
		newdoc.isHEAD = FALSE;
		newdoc.safe = FALSE;
		newdoc.internal_link = FALSE;
		/*
		 *  If vi_keys changed, the keymap did too,
		 *  so force no cache, and reset the flag. - FM
		 */
		if (vi_keys_flag != vi_keys ||
		    emacs_keys_flag != emacs_keys) {
		    LYforce_no_cache = TRUE;
		    vi_keys_flag = vi_keys;
		    emacs_keys_flag = emacs_keys;
		}
#if defined(DIRED_SUPPORT) && defined(OK_OVERRIDE)
		/*
		 *  Remember whether we are in dired menu
		 *  so we can display the right keymap.
		 */
		if (!no_dired_support) {
		    prev_lynx_edit_mode = lynx_edit_mode;
		}
#endif /* DIRED_SUPPORT && OK_OVERRIDE */
		LYforce_no_cache = TRUE;
	    }
d7435 6
a7440 56
	    {
		char *ret;

		if (no_jump || JThead == NULL) {
		    if (old_c != real_c) {
			old_c = real_c;
			if (no_jump)
			    HTUserMsg(JUMP_DISALLOWED);
			else
			    HTUserMsg(NO_JUMPFILE);
		    }
		} else {
		    LYJumpFileURL = TRUE;
		    if ((ret = LYJump(c)) != NULL) {
#ifdef PERMIT_GOTO_FROM_JUMP
			if (!strncasecomp(ret, "Go ", 3)) {
			    LYJumpFileURL = FALSE;
			    StrAllocCopy(temp, user_input_buffer);
			    URLTotal = (Goto_URLs ?
			  HTList_count(Goto_URLs) : 0);
			    recall = ((URLTotal >= 1) ? RECALL : NORECALL);
			    URLNum = URLTotal;
			    FirstURLRecall = TRUE;
			    if (!strcasecomp(ret, "Go :")) {
				if (recall) {
				    ch = UPARROW;
				    goto check_recall;
				}
				FREE(temp);
				HTUserMsg(NO_RANDOM_URLS_YET);
				break;
			    }
			    ret = HTParse((ret+3), startfile, PARSE_ALL);
			    strcpy(user_input_buffer, ret);
			    FREE(ret);
			    goto check_recall;
			}
#endif /* PERMIT_GOTO_FROM_JUMP */
			ret = HTParse(ret, startfile, PARSE_ALL);
			if (!LYTrimStartfile(ret)) {
			    LYRemoveBlanks(user_input_buffer);
			}
			StrAllocCopy(newdoc.address, ret);
			StrAllocCopy(lynxjumpfile, ret);
			FREE(newdoc.post_data);
			FREE(newdoc.post_content_type);
			FREE(newdoc.bookmark);
			newdoc.isHEAD = FALSE;
			newdoc.safe = FALSE;
			newdoc.internal_link = FALSE;
			FREE(ret);
			LYUserSpecifiedURL = TRUE;
		    } else {
			LYJumpFileURL = FALSE;
		    }
		}
d7445 1
a7445 19
	    if (old_c != real_c) {
		old_c = real_c;
		if (HTConfirm(CLEAR_ALL_AUTH_INFO)) {
		    FREE(authentication_info[0]);
		    FREE(authentication_info[1]);
		    FREE(proxyauth_info[0]);
		    FREE(proxyauth_info[1]);
		    HTClearHTTPAuthInfo();
#ifndef DISABLE_NEWS
		    HTClearNNTPAuthInfo();
#endif
#ifndef DISABLE_FTP
		    HTClearFTPPassword();
#endif
		    HTUserMsg(AUTH_INFO_CLEARED);
		} else {
		    HTUserMsg(CANCELLED);
		}
	    }
d7450 17
a7466 1

a7470 82
/*
 *  Ask a post resubmission prompt with some indication of what would
 *  be resubmitted, useful especially for going backward in history.
 *  Try to use parts of the address or, if given, the title, depending
 *  on how much fits on the statusline.
 *  if_imgmap and if_file indicate how to handle an address that is
 *  a "LYNXIMGMAP:", or a "file:" URL (presumably the List Page file),
 *  respectively: 0: auto-deny, 1: auto-confirm, 2: prompt.
 *  - kw
 */

PRIVATE BOOL confirm_post_resub ARGS4(
    CONST char*,	address,
    CONST char*,	title,
    int,		if_imgmap,
    int,		if_file)
{
    size_t len1;
    CONST char *msg = CONFIRM_POST_RESUBMISSION_TO;
    char buf[240];
    char *temp = NULL;
    BOOL res;
    size_t maxlen = LYcols - 6;
    if (!address) {
	return(NO);
    } else if (!strncmp(address, "LYNXIMGMAP:", 11)) {
	if (if_imgmap <= 0)
	    return(NO);
	else if (if_imgmap == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (!strncmp(address, "file:", 5)) {
	if (if_file <= 0)
	    return(NO);
	else if (if_file == 1)
	    return(YES);
	else
	    msg = CONFIRM_POST_LIST_RELOAD;
    } else if (dump_output_immediately) {
	return(NO);
    }
    if (maxlen >= sizeof(buf))
	maxlen = sizeof(buf) - 1;
    if ((len1 = strlen(msg)) +
	strlen(address) <= maxlen) {
	sprintf(buf, msg, address);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST+PARSE_PATH
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if (title && (len1 + strlen(title) <= maxlen)) {
	sprintf(buf, msg, title);
	return HTConfirm(buf);
    }
    if (len1 + strlen(temp = HTParse(address, "",
				     PARSE_ACCESS+PARSE_HOST
				     +PARSE_PUNCTUATION)) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    if ((temp = HTParse(address, "", PARSE_HOST)) && *temp &&
	len1 + strlen(temp) <= maxlen) {
	sprintf(buf, msg, temp);
	res = HTConfirm(buf);
	FREE(temp);
	return(res);
    }
    FREE(temp);
    return HTConfirm(CONFIRM_POST_RESUBMISSION);
}

d7501 1
a7501 2
    if (strcmp(doc1->address, doc2->address))
      {
d7507 1
a7507 1
      }
d7516 2
a7517 4
    if (doc1->post_data)
      {
	if (doc2->post_data)
	  {
d7520 1
a7520 6
	  }
	else
	    return(TRUE);
      }
    else
	if (doc2->post_data)
d7522 2
d7580 1
a7580 2
    if (strcmp(ap1, ap2))
      {
d7586 1
a7586 1
      }
d7595 2
a7596 4
    if (doc1->post_data)
      {
	if (doc2->post_data)
	  {
d7599 1
a7599 6
	  }
	else
	    return(TRUE);
      }
    else
	if (doc2->post_data)
d7601 2
d7614 2
a7615 1
PUBLIC void HTGotoURLs_free NOARGS
d7620 6
a7625 5
    if (!cur)
	return;

    while (NULL != (url = (char *)HTList_nextObject(cur))) {
	FREE(url);
a7626 3
    HTList_delete(Goto_URLs);
    Goto_URLs = NULL;
    return;
d7628 1
d7637 1
a7637 1
    char *new;
d7644 1
a7644 3
    if ((new = (char *)calloc(1, (strlen(url) + 1))) == NULL)
	outofmem(__FILE__, "HTAddGotoURL");
    strcpy(new, url);
d7673 3
a7675 3
PRIVATE void print_status_message ARGS2(
	CONST linkstruct,	curlink,
	char **,		cp)
d7680 1
a7680 1
    if (user_mode == NOVICE_MODE) {
a7683 4
    /*
     *	If we are in forms mode then explicitly
     *	tell the user what each kind of link is.
     */
d7690 4
d7707 1
a7707 103
	    switch(curlink.form->type) {
	    case F_PASSWORD_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_PASSWORD_UNM_MSG);
		else
		    statusline(FORM_LINK_PASSWORD_MESSAGE);
		break;
	    case F_OPTION_LIST_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		else
		    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		break;
	    case F_CHECKBOX_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
		else
		    statusline(FORM_LINK_CHECKBOX_MESSAGE);
		break;
	    case F_RADIO_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_RADIO_UNM_MSG);
		else
		    statusline(FORM_LINK_RADIO_MESSAGE);
		break;
	    case F_TEXT_SUBMIT_TYPE:
		if (curlink.form->disabled == YES) {
		    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
		} else if (curlink.form->submit_method ==
			 URL_MAIL_METHOD) {
		    if (no_mail)
			statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
		    else
			statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
		} else if (curlink.form->no_cache) {
		    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
		} else {
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
		}
		break;
	    case F_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if (curlink.form->disabled == YES) {
		    statusline(FORM_LINK_SUBMIT_DIS_MSG);
		} else if (curlink.form->submit_method ==
			 URL_MAIL_METHOD) {
		    if (no_mail) {
			statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
		    } else {
			if(user_mode == ADVANCED_MODE) {
			    char *submit_str = NULL;

			    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
			    StrAllocCat(submit_str, curlink.form->submit_action);
			    statusline(submit_str);
			    FREE(submit_str);
			} else {
			    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
			}
		    }
		} else if (curlink.form->no_cache) {
		    if(user_mode == ADVANCED_MODE) {
			char *submit_str = NULL;

			StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
			StrAllocCat(submit_str, curlink.form->submit_action);
			statusline(submit_str);
			FREE(submit_str);
		    } else {
			statusline(FORM_LINK_RESUBMIT_MESSAGE);
		    }
		} else {
		    if(user_mode == ADVANCED_MODE) {
			char *submit_str = NULL;

			StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
			StrAllocCat(submit_str, curlink.form->submit_action);
			statusline(submit_str);
			FREE(submit_str);
		    } else {
			statusline(FORM_LINK_SUBMIT_MESSAGE);
		    }
		}
		break;
	    case F_RESET_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_RESET_DIS_MSG);
		else
		    statusline(FORM_LINK_RESET_MESSAGE);
		break;
	    case F_TEXT_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_TEXT_UNM_MSG);
		else
		    statusline(FORM_LINK_TEXT_MESSAGE);
		break;
	    case F_TEXTAREA_TYPE:
		if (curlink.form->disabled == YES)
		    statusline(FORM_LINK_TEXT_UNM_MSG);
		else
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
		break;
	    }
d7716 2
a7717 1
	    move(LYlines-1, LYcols-8);
d7719 1
a7719 1
	    addstr("-index-");
d7727 2
a7728 1
	*cp = NULL;
d7731 1
a7731 15
	    *cp = strchr(curlink.lname, '#');
	}
	if (!(*cp))
	    *cp = curlink.lname;
	if (more) {
	    if (is_www_index)
		_user_message("-more- -index- %s",
					 *cp);
	    else
		_user_message("-more- %s",*cp);
	} else {
	    if (is_www_index)
		_user_message("-index- %s",*cp);
	    else
		statusline(*cp);
d7733 3
d7748 1
a7748 1
		_statusline(MORE);
d7750 1
a7750 1
		_statusline(MOREHELP);
d7754 1
d7756 19
a7774 1
    move((LYlines - 1), (LYcols - 1));
d7777 32
d7825 1
a7825 1
		   buf2,
d7831 2
a7832 1
		   strstr(buf2, gettext("Can't Access")) ? "" : startfile);
d7838 1
a7838 1
		   buf2,
d7850 1
a7850 1
	fprintf(stderr, buf);
d7855 1
a7855 1
	printf(buf);
d7862 77
a7938 1
	exit_immediately(-1);
a7939 1
    /* else: return(-1) in mainloop */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d3359 1
a3359 3
		if (!LYTrimStartfile(user_input_buffer)) {
		    LYRemoveBlanks(user_input_buffer);
		}
d3429 1
a3429 3
		if (!LYTrimStartfile(user_input_buffer)) {
		    LYRemoveBlanks(user_input_buffer);
		}
d3487 1
a3487 3
	    if (!LYTrimStartfile(user_input_buffer)) {
		LYRemoveBlanks(user_input_buffer);
	    }
@


1.2.10.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html
@
text
@d3359 3
a3361 1
		LYTrimAllStartfile(user_input_buffer); 
d3431 3
a3433 1
		LYTrimAllStartfile(user_input_buffer); 
d3491 3
a3493 1
	    LYTrimAllStartfile(user_input_buffer); 
@


1.2.12.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d3359 3
a3361 1
		LYTrimAllStartfile(user_input_buffer); 
d3431 3
a3433 1
		LYTrimAllStartfile(user_input_buffer); 
d3491 3
a3493 1
	    LYTrimAllStartfile(user_input_buffer); 
@


1.1
log
@Initial revision
@
text
@d1 39
a39 44
#include "HTUtils.h"
#include "tcp.h"
#include "HTAccess.h"
#include "HTParse.h"
#include "HTList.h"
#include "HTML.h"
#include "HTFTP.h"
#include "HTFile.h"
#include "HTTP.h"
#include "HTAABrow.h"
#include "HTNews.h"
#include "LYCurses.h"
#include "LYStyle.h"
#include "LYGlobalDefs.h"
#include "HTAlert.h"
#include "LYUtils.h"
#include "GridText.h"
#include "LYStrings.h"
#include "LYOptions.h"
#include "LYSignal.h"
#include "LYGetFile.h"
#include "HTForms.h"
#include "LYSearch.h"
#include "LYClean.h"
#include "LYHistory.h"
#include "LYPrint.h"
#include "LYMail.h"
#include "LYEdit.h"
#include "LYShowInfo.h"
#include "LYBookmark.h"
#include "LYSystem.h"
#include "LYKeymap.h"
#include "LYJump.h"
#include "LYDownload.h"
#include "LYList.h"
#include "LYMap.h"
#include "LYTraversal.h"
#include "LYCharSets.h"
#include "LYCharUtils.h"
#include "LYCookie.h"
#include "LYMainLoop.h"
#ifdef DOSPATH
#include "HTDOS.h"
#endif
d42 1
a42 1
#include "LYExtern.h"
d45 3
a47 3
#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */
d50 2
a51 2
#include "LYLocal.h"
#include "LYUpload.h"
d54 2
a55 2
#include "LYexit.h"
#include "LYLeaks.h"
d57 3
d61 4
a64 4
    CONST char* 	address,
    CONST char* 	title,
    int 		if_imgmap,
    int 		if_file));
d74 1
a74 1
#ifdef FASTTAB
d76 2
a77 2
	char *, 	een,
	char *, 	twee)
a82 3
#endif /* FASTTAB */

#define FREE(x) if (x) {free(x); x = NULL;}
d88 9
a100 3
PRIVATE char *CurrentUserAgent = NULL;
PRIVATE char *CurrentNegoLanguage = NULL;
PRIVATE char *CurrentNegoCharset = NULL;
d102 1
a123 3
    FREE(CurrentUserAgent);
    FREE(CurrentNegoLanguage);
    FREE(CurrentNegoCharset);
d130 91
a236 2
    int lines_in_file = -1;
    int Newline = 0;
a250 7
    BOOLEAN keypad_mode_flag = keypad_mode;
    BOOLEAN user_mode_flag = user_mode;
    BOOLEAN HTfileSortMethod_flag = HTfileSortMethod;
    int CurrentCharSet_flag = current_char_set;
    BOOLEAN show_dotfiles_flag = show_dotfiles;
    BOOLEAN LYRawMode_flag = LYRawMode;
    BOOLEAN LYSelectPopups_flag = LYSelectPopups;
a255 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;   /* Flag from cleanup_sig */
#endif /* VMS */
d265 1
d299 1
a299 6
    StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
				    LYUserAgent : ""));
    StrAllocCopy(CurrentNegoLanguage, (language ?
				       language : ""));
    StrAllocCopy(CurrentNegoCharset, (pref_charset ?
				      pref_charset : ""));
d301 1
d305 1
a305 1
    StrAllocCopy(newdoc.title, "Entry into main screen");
d318 1
a318 2
    if (TRACE)
	fprintf(stderr,"Entering mainloop, startfile=%s\n",startfile);
d330 1
a330 2
	    _statusline(BOOKMARKS_DISABLED);
	    sleep(AlertSecs);
d334 1
a334 2
	    _statusline(BOOKMARKS_NOT_TRAVERSED);
	    sleep(AlertSecs);
d353 1
a353 2
		if (TRACE)
		    fprintf(stderr, "Using bookmarks=%s\n", newdoc.address);
d355 1
a355 2
		_statusline(BOOKMARKS_NOT_OPEN);
		sleep(MessageSecs);
d403 2
a404 1
		    if (strncmp(newdoc.address, "LYNXDOWNLOAD:", 13)) {
d506 1
a506 11
			if (TRACE)
			    fprintf(stderr,
				    "\nTurning off TRACE for fetch of log.\n");
			fflush(stdout);
			fflush(stderr);
			fclose(LYTraceLogFP);
			*stderr = LYOrigStderr;
			if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
			    WWW_TraceFlag = FALSE;
			    _statusline(TRACELOG_OPEN_FAILED);
			    sleep(MessageSecs);
a510 5
			*stderr = *LYTraceLogFP;
			if (TRACE) {
			    WWW_TraceFlag = FALSE;
			    trace_mode_flag = TRUE;
			}
d525 19
d603 1
a603 1
		    popped_doc = FALSE; 	 /* Was TRUE if popped. - FM */
d608 1
a608 1
			fprintf(stderr, "Turning TRACE back on.\n\n");
d632 1
a632 12
#ifndef NOSIGHUP
				(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
				(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
				(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
				if (no_suspend)
				    (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
				exit(-1);
d651 1
a651 24
			if (!dump_output_immediately)
			    cleanup();
#ifdef UNIX
			if (dump_output_immediately)
			    fprintf(stderr,"\nlynx: Can't access startfile %s\n",
			       startfile);
			else
#endif /* UNIX */
			    printf("\nlynx: Can't access startfile %s\n",
			       startfile);
			if (!dump_output_immediately) {
#ifndef NOSIGHUP
			    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
			    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
			    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
			    if (no_suspend)
				(void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
			    exit(-1);
			}
d660 1
a660 1
		    popped_doc = FALSE; 	 /* Was TRUE if popped. - FM */
d665 1
a665 1
			fprintf(stderr, "Turning TRACE back on.\n\n");
d689 9
a697 9
		   /*
		    *  Make sure the first file was found and
		    *  has not gone missing.
		    */
		   if (!nhist) {
		       /*
			*  If nhist = 0 then it must be the first file.
			*/
		       if (first_file && homepage &&
d723 2
a724 29
		       } else {
			   if (!dump_output_immediately)
			       cleanup();
#ifdef UNIX
			   if (dump_output_immediately) {
			       fprintf(stderr,
 "\nlynx: Start file could not be found or is not text/html or text/plain\n");
			       fprintf(stderr,"      Exiting...\n");
			   } else
#endif /* UNIX */
			   {
			       printf(
 "\nlynx: Start file could not be found or is not text/html or text/plain\n");
			       printf("      Exiting...\n");
			   }
			   if (!dump_output_immediately) {
#ifndef NOSIGHUP
				(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
				(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
				(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
				if (no_suspend)
				    (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
			       exit(-1);
			   }
d726 1
a726 1
		       }
d774 1
a774 1
		       }
a776 1
		    break;
d787 1
a787 1
			fprintf(stderr, "Turning TRACE back on.\n\n");
d804 1
a804 9
#ifdef DOSPATH
			cp = HTDOS_wwwName((char *)Home_Dir());
#else
#ifdef VMS
			cp = HTVMS_wwwName((char *)Home_Dir());
#else
			cp = (char *)Home_Dir();
#endif /* VMS */
#endif /* DOSPATH */
d851 1
a851 2
				    _statusline(BOOKMARKS_DISABLED);
				    sleep(AlertSecs);
a858 5
#ifdef DOSPATH
				    StrAllocCat(newdoc.address,
					    HTDOS_wwwName((char *)Home_Dir()));
#else
#ifdef VMS
d860 1
a860 5
					    HTVMS_wwwName((char *)Home_Dir()));
#else
				    StrAllocCat(newdoc.address, Home_Dir());
#endif /* VMS */
#endif /* DOSPATH */
d881 1
a881 3
				    if (TRACE)
					fprintf(stderr,
						"Reloading as bookmarks=%s\n",
d934 16
a949 1
		    Newline = newdoc.line;
d964 7
a970 1

d997 1
a997 1
	     *	the visitied links list. - FM
d1000 1
d1002 4
d1014 1
a1014 1
	    owner_address = HText_getOwner();
d1026 5
d1040 1
a1040 1
	   LYPermitURL = FALSE; 	/* only set for LYValidate */
d1065 2
a1081 1
	     more = HText_canScrollDown();
d1098 1
a1098 1
		StrAllocCopy(startrealm, "None");
d1104 1
a1104 3
		    if (startrealm[strlen(startrealm)-1] != '/') {
			StrAllocCat(startrealm, "/");
		    }
d1137 1
a1137 3
	    if (TRACE) {
		fprintf(stderr, "Starting realm is '%s'\n\n", startrealm);
	    }
d1152 1
a1152 1
		    StrAllocCopy(traversal_host, "None");
d1159 1
a1159 1
			StrAllocCopy(traversal_host, "None");
d1162 1
a1162 3
			if (traversal_host[strlen(traversal_host)-1] != '/') {
			    StrAllocCat(traversal_host, "/");
			}
d1166 1
a1166 4
		if (TRACE) {
		    fprintf(stderr,
			    "Traversal host is '%s'\n\n", traversal_host);
		}
d1194 44
d1242 1
d1254 1
d1256 1
a1256 2
	     *	If more equals TRUE, then there is more
	     *	info below this page .
a1259 1
	    lines_in_file = HText_getNumOfLines();
d1288 1
a1288 1
		     *	does have links now (e.g. a file was created) - KW
d1319 6
d1334 2
a1335 2
	if (check_mail && !no_mail && LYCheckMail())
	    sleep(MessageSecs);
d1343 1
a1343 155
	    /*
	     *	Make sure form novice lines are replaced.
	     */
	    if (user_mode == NOVICE_MODE) {
		noviceline(more);
	    }

	    /*
	     *	If we are in forms mode then explicitly
	     *	tell the user what each kind of link is.
	     */
	    if (HTisDocumentSource()) {
		/*
		 *  Currently displaying HTML source.
		 */
		_statusline(SOURCE_HELP);

#ifdef INDICATE_FORMS_MODE_FOR_ALL_LINKS_ON_PAGE
	    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0) {
#else
#ifdef NORMAL_NON_FORM_LINK_STATUSLINES_FOR_ALL_USER_MODES
	    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0 &&
		       !(links[curdoc.link].type & WWW_LINK_TYPE)) {
#else
	    } else if (lynx_mode == FORMS_LYNX_MODE && nlinks > 0 &&
		       !(user_mode == ADVANCED_MODE &&
			 (links[curdoc.link].type & WWW_LINK_TYPE))) {
#endif /* NORMAL_NON_FORM_LINK_STATUSLINES_FOR_ALL_USER_MODES */
#endif /* INDICATE_FORMS_MODE_FOR_ALL_LINKS_ON_PAGE */
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE)
		    switch(links[curdoc.link].form->type) {
		    case F_PASSWORD_TYPE:
			if (links[curdoc.link].form->disabled == YES)
			    statusline(FORM_LINK_PASSWORD_UNM_MSG);
			else
			    statusline(FORM_LINK_PASSWORD_MESSAGE);
			break;
		    case F_OPTION_LIST_TYPE:
			if (links[curdoc.link].form->disabled == YES)
			    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			else
			    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			break;
		    case F_CHECKBOX_TYPE:
			if (links[curdoc.link].form->disabled == YES)
			    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
			else
			    statusline(FORM_LINK_CHECKBOX_MESSAGE);
			break;
		    case F_RADIO_TYPE:
			if (links[curdoc.link].form->disabled == YES)
			    statusline(FORM_LINK_RADIO_UNM_MSG);
			else
			    statusline(FORM_LINK_RADIO_MESSAGE);
			break;
		    case F_TEXT_SUBMIT_TYPE:
			if (links[curdoc.link].form->disabled == YES) {
			    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
			} else if (links[curdoc.link].form->submit_method ==
				 URL_MAIL_METHOD) {
			    if (no_mail)
				statusline(
				       FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
			    else
				statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
			} else if (links[curdoc.link].form->no_cache) {
			    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
			} else {
			    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
			}
			break;
		    case F_SUBMIT_TYPE:
		    case F_IMAGE_SUBMIT_TYPE:
			if (links[curdoc.link].form->disabled == YES) {
			    statusline(FORM_LINK_SUBMIT_DIS_MSG);
			} else if (links[curdoc.link].form->submit_method ==
				 URL_MAIL_METHOD) {
			    if (no_mail) {
				statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
			    } else {
				statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
			    }
			} else if (links[curdoc.link].form->no_cache) {
			    statusline(FORM_LINK_RESUBMIT_MESSAGE);
			} else {
			    statusline(FORM_LINK_SUBMIT_MESSAGE);
			}
			break;
		    case F_RESET_TYPE:
			if (links[curdoc.link].form->disabled == YES)
			    statusline(FORM_LINK_RESET_DIS_MSG);
			else
			    statusline(FORM_LINK_RESET_MESSAGE);
			break;
		    case F_TEXT_TYPE:
		    case F_TEXTAREA_TYPE:
			if (links[curdoc.link].form->disabled == YES)
			    statusline(FORM_LINK_TEXT_UNM_MSG);
			else
			    statusline(FORM_LINK_TEXT_MESSAGE);
			break;
		    }
		else
		    statusline(NORMAL_LINK_MESSAGE);

		/*
		 *  Let them know if it's an index -- very rare.
		 */
		if (is_www_index) {
		    move(LYlines-1,LYcols-8);
		    start_reverse();
		    addstr("-index-");
		    stop_reverse();
		}

	    } else if (user_mode == ADVANCED_MODE && nlinks > 0) {
		/*
		 *  Show the URL or, for some internal links, the fragment
		 */
		cp = NULL;
		if (links[curdoc.link].type == WWW_INTERN_LINK_TYPE &&
		    strncmp(links[curdoc.link].lname, "LYNXIMGMAP:", 11)) {
		    cp = strchr(links[curdoc.link].lname, '#');
		}
		if (!cp)
		    cp = links[curdoc.link].lname;
		if (more)
		    if (is_www_index)
			_user_message("-more- -index- %s",
						 cp);
		    else
			_user_message("-more- %s",cp);
		else
		    if (is_www_index)
			_user_message("-index- %s",cp);
		    else
			statusline(cp);
	    } else if (is_www_index && more) {
		char buf[128];

		sprintf(buf, WWW_INDEX_MORE_MESSAGE, key_for_func(LYK_INDEX_SEARCH));
		_statusline(buf);
	    } else if (is_www_index) {
		char buf[128];

		sprintf(buf, WWW_INDEX_MESSAGE, key_for_func(LYK_INDEX_SEARCH));
		_statusline(buf);
	    } else if (more) {
		if (user_mode == NOVICE_MODE)
			_statusline(MORE);
		else
			_statusline(MOREHELP);
	    } else {
	       _statusline(HELP);
	    }
d1379 1
a1379 1
			"Fatal error - could not open output file %s\n",cfile);
d1383 1
a1383 1
			"Fatal error - could not open output file %s\n",cfile);
d1385 1
a1385 12
#ifndef NOSIGHUP
			(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
			(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
			(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
			if (no_suspend)
			    (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
			exit(-1);
d1410 1
a1410 1
				     FORM_UP, &newdoc, &refresh_screen,
d1414 53
a1466 1
		if (c == '\n' || c == '\r')
d1478 1
d1554 1
a1554 12
#ifndef NOSIGHUP
				(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
				(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
				(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
				if (no_suspend)
				    (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
				exit(-1);
d1582 1
a1582 12
#ifndef NOSIGHUP
			    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
			    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
			    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
			    if (no_suspend)
				(void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
			    exit(-1);
d1594 2
a1595 2
	if (lynx_edit_mode && override[c+1] && !no_dired_support)
	  cmd = override[c+1];
d1605 2
d1647 4
d1669 1
a1669 2
		    if (0==strcmp((curdoc.title ? curdoc.title : ""),
				      LIST_PAGE_TITLE) &&
d1716 1
a1716 2
				    _statusline(CANCELLED);
				    sleep(InfoSecs);
d1734 1
a1734 2
				    _statusline(DISCARDING_POST_DATA);
				    sleep(AlertSecs);
d1793 1
a1793 2
			    _statusline(user_input_buffer);
			    sleep(MessageSecs);
d1825 1
a1825 1
			_statusline(ALREADY_AT_BEGIN);
d1827 1
a1827 1
			_statusline(ALREADY_AT_END);
d1832 1
a1832 2
			_statusline(user_input_buffer);
			sleep(MessageSecs);
a1835 1
		    sleep(MessageSecs);
d1841 1
a1841 2
		_statusline(BAD_LINK_NUM_ENTERED);
		sleep(MessageSecs);
d1856 1
a1856 2
		_statusline(CANCELLED);
		sleep(InfoSecs);
d1862 3
d1869 6
d1876 21
d1898 3
a1901 1
	    FREE(curdoc.address); /* so it doesn't get pushed */
d1912 1
a1912 2
		_statusline(CANCELLED);
		sleep(InfoSecs);
d1919 1
d1921 3
d1925 6
d1932 1
d1948 2
a1949 13
	    if (lynx_mode == FORMS_LYNX_MODE) {
		/*
		 *  Note that if there are no form links on the current
		 *  page, lynx_mode won't have this setting and we won't
		 *  know that this warning should be issued. - FM
		 */
		_statusline(RELOADING_FORM);
		sleep(AlertSecs);
	    }
	    newdoc.line = ((curdoc.line > 0) ?
				 curdoc.line : 1);
	    newdoc.link = ((curdoc.link > -1) ?
				  curdoc.link : 0);
d1967 4
a1970 1
	case LYK_HISTORICAL:
d1980 1
a1980 2
		_statusline(WILL_NOT_RELOAD_DOC);
		sleep(InfoSecs);
d1985 2
d1988 3
d1996 2
a1997 2
		_statusline(historical_comments ?
		      HISTORICAL_ON_MINIMAL_OFF : HISTORICAL_OFF_MINIMAL_ON);
d1999 1
a1999 1
		_statusline(historical_comments ?
d2002 5
a2006 1
	    sleep(AlertSecs);
d2009 1
a2009 1
	case LYK_MINIMAL:
d2011 3
d2023 1
a2023 2
		    _statusline(WILL_NOT_RELOAD_DOC);
		    sleep(InfoSecs);
d2028 2
d2032 3
d2040 1
a2040 1
		_statusline(minimal_comments ?
d2043 2
a2044 2
		_statusline(minimal_comments ?
		   MINIMAL_ON_BUT_HISTORICAL : MINIMAL_OFF_HISTORICAL_ON);
d2046 5
a2050 1
	    sleep(AlertSecs);
d2054 3
d2066 1
a2066 2
		_statusline(WILL_NOT_RELOAD_DOC);
		sleep(InfoSecs);
d2071 2
d2074 3
d2081 7
a2087 3
	    _statusline(soft_dquotes ?
		SOFT_DOUBLE_QUOTE_ON : SOFT_DOUBLE_QUOTE_OFF);
	    sleep(MessageSecs);
d2091 3
d2103 1
a2103 2
		_statusline(WILL_NOT_RELOAD_DOC);
		sleep(InfoSecs);
d2110 6
d2117 6
a2122 1
			HTOutputFormat = WWW_SOURCE;
a2126 1
	    }
d2128 2
a2129 2
	    newdoc.line=1;
	    newdoc.link=0;
d2131 2
a2132 2
	    newdoc.line = ((curdoc.line > 0) ? curdoc.line : 1);
	    newdoc.link = ((curdoc.link > -1) ? curdoc.link : 0);
d2134 22
a2155 7
	    if (New_DTD)
		New_DTD = NO;
	    else
		New_DTD = YES;
	    HTSwitchDTD(New_DTD);
	    _statusline(New_DTD ? USING_DTD_1 : USING_DTD_0);
	    sleep(MessageSecs);
d2166 1
a2166 1
		_statusline(REALLY_QUIT_Y);
d2168 1
a2168 1
		_statusline(REALLY_QUIT_N);
a2169 1
	    c = LYgetch();
d2171 1
a2171 2
		if (TOUPPER(c) != 'N' &&
		    c != 7) {
d2174 1
a2174 2
		    statusline(NO_CANCEL);
		    sleep(InfoSecs);
d2176 1
a2176 1
	    } else if (TOUPPER(c) == 'Y') {
d2179 1
a2179 2
		statusline(NO_CANCEL);
		sleep(InfoSecs);
d2183 1
a2183 1
	case LYK_ABORT: 	/* don't ask the user about quitting */
a2184 1
	    break;
d2194 1
a2194 2
		   _statusline(ALREADY_AT_END);
		   sleep(MessageSecs);
d2206 1
a2206 2
		_statusline(ALREADY_AT_BEGIN);
		sleep(MessageSecs);
d2225 1
a2225 2
		_statusline(ALREADY_AT_BEGIN);
		sleep(MessageSecs);
d2240 1
a2240 2
		_statusline(ALREADY_AT_END);
		sleep(MessageSecs);
d2262 1
a2262 2
		_statusline(ALREADY_AT_BEGIN);
		sleep(MessageSecs);
d2277 1
a2277 2
		_statusline(ALREADY_AT_END);
		sleep(MessageSecs);
d2297 1
a2297 1
	       Newline = MAXINT; /* go to end of file */
d2343 1
a2343 2
		_statusline(ALREADY_AT_BEGIN);
		sleep(MessageSecs);
d2385 1
a2385 2
		_statusline(ALREADY_AT_END);
		sleep(MessageSecs);
d2389 170
d2584 1
a2584 2
		    _statusline(NO_LINKS_ABOVE);
		    sleep(MessageSecs);
d2614 1
a2614 2
		_statusline(ALREADY_AT_BEGIN);
		sleep(MessageSecs);
d2640 1
a2640 2
		    _statusline(NO_LINKS_BELOW);
		    sleep(MessageSecs);
d2657 1
a2657 2
		_statusline(ALREADY_AT_END);
		sleep(MessageSecs);
d2661 4
d2739 1
d2760 1
a2760 1
		 *  cache or LYresubmit_posts is set. If not confirmed and
d2812 1
a2812 2
			    _statusline(CANCELLED);
			    sleep(InfoSecs);
d2817 1
a2817 2
			    _user_message(WWW_SKIP_MESSAGE, WWWDoc.address);
			    sleep(MessageSecs);
d2855 1
a2855 2
		_statusline(ALREADY_AT_FIRST);
		sleep(MessageSecs);
d2867 1
a2867 2
		    _statusline(NOT_ON_SUBMIT_OR_LINK);
		    sleep(MessageSecs);
d2906 1
a2906 2
			    _statusline(NO_FORM_ACTION);
			    sleep(MessageSecs);
d2985 1
a2985 3
			    if (TRACE) {
				fprintf(stderr,
					"LYMainLoop: Rejected '%s'\n",
a2986 1
			    }
d3002 1
a3002 1
	"Enctype multipart/form-data not yet supported!  Cannot submit.");
d3021 1
a3021 1
					 FORM_UP, &newdoc, &refresh_screen,
d3029 1
a3029 2
			    _statusline(CANCELLED);
			    sleep(InfoSecs);
d3136 2
a3137 3
			if (0==strcmp(curdoc.address, LYlist_temp_url()) &&
			    0==strcmp((curdoc.title ? curdoc.title : ""),
				      LIST_PAGE_TITLE)) {
d3184 1
a3184 2
					_statusline(CANCELLED);
					sleep(InfoSecs);
d3202 1
a3202 2
					_statusline(DISCARDING_POST_DATA);
					sleep(AlertSecs);
d3253 4
d3283 1
a3283 2
		    _statusline(GOTO_DISALLOWED);
		    sleep(MessageSecs);
d3298 1
a3298 2
		    _statusline(NOT_ON_SUBMIT_OR_LINK);
		    sleep(MessageSecs);
d3310 1
a3310 2
		    _statusline(NO_FORM_ACTION);
		    sleep(MessageSecs);
d3331 1
a3331 2
		    _statusline(EDIT_FM_MENU_URLS_DISALLOWED);
		    sleep(MessageSecs);
d3345 1
a3345 1
	 links[curdoc.link].form->submit_action : links[curdoc.link].lname),
d3359 2
a3360 14
		LYTrimHead(user_input_buffer);
		if (!strncasecomp(user_input_buffer, "lynxexec:", 9) ||
		    !strncasecomp(user_input_buffer, "lynxprog:", 9)) {
		    /*
		     *	The original implementations of these schemes expected
		     *	white space without hex escaping, and did not check
		     *	for hex escaping, so we'll continue to support that,
		     *	until that code is redone in conformance with SGML
		     *	principles.  - FM
		     */
		    HTUnEscapeSome(user_input_buffer, " \r\n\t");
		    convert_to_spaces(user_input_buffer, TRUE);
		} else {
		    collapse_spaces(user_input_buffer);
d3370 1
a3370 2
	    _statusline(CANCELLED);
	    sleep(InfoSecs);
d3382 1
a3382 2
		    _statusline(GOTO_DISALLOWED);
		    sleep(MessageSecs);
d3401 1
a3401 2
		    _statusline(EDIT_FM_MENU_URLS_DISALLOWED);
		    sleep(MessageSecs);
d3431 2
a3432 14
		LYTrimHead(user_input_buffer);
		if (!strncasecomp(user_input_buffer, "lynxexec:", 9) ||
		    !strncasecomp(user_input_buffer, "lynxprog:", 9)) {
		    /*
		     *	The original implementations of these schemes expected
		     *	white space without hex escaping, and did not check
		     *	for hex escaping, so we'll continue to support that,
		     *	until that code is redone in conformance with SGML
		     *	principles.  - FM
		     */
		    HTUnEscapeSome(user_input_buffer, " \r\n\t");
		    convert_to_spaces(user_input_buffer, TRUE);
		} else {
		    collapse_spaces(user_input_buffer);
d3442 1
a3442 2
	    _statusline(CANCELLED);
	    sleep(InfoSecs);
d3451 1
a3451 2
		    _statusline(GOTO_DISALLOWED);
		    sleep(MessageSecs);
d3483 1
a3483 2
		_statusline(CANCELLED);
		sleep(InfoSecs);
d3491 2
a3492 14
	    LYTrimHead(user_input_buffer);
	    if (!strncasecomp(user_input_buffer, "lynxexec:", 9) ||
		!strncasecomp(user_input_buffer, "lynxprog:", 9)) {
		/*
		 *  The original implementations of these schemes expected
		 *  white space without hex escaping, and did not check
		 *  for hex escaping, so we'll continue to support that,
		 *  until that code is redone in conformance with SGML
		 *  principles.  - FM
		 */
		HTUnEscapeSome(user_input_buffer, " \r\n\t");
		convert_to_spaces(user_input_buffer, TRUE);
	    } else {
		collapse_spaces(user_input_buffer);
d3498 1
a3498 2
		_statusline(CANCELLED);
		sleep(InfoSecs);
d3540 1
a3540 2
			_statusline(CANCELLED);
			sleep(InfoSecs);
d3584 1
a3584 2
			_statusline(CANCELLED);
			sleep(InfoSecs);
d3592 10
d3607 1
a3607 1
	    LYEnsureAbsoluteURL((char **)&temp, "");
d3613 1
a3613 2
		_statusline(GOTO_FILE_DISALLOWED);
		sleep(MessageSecs);
d3621 1
a3621 2
		_statusline(GOTO_EXEC_DISALLOWED);
		sleep(MessageSecs);
d3629 1
a3629 2
		_statusline(GOTO_PROG_DISALLOWED);
		sleep(MessageSecs);
d3633 1
a3633 2
		_statusline(GOTO_CGI_DISALLOWED);
		sleep(MessageSecs);
d3638 1
a3638 2
		_statusline(GOTO_NON_HTTP_DISALLOWED);
		sleep(MessageSecs);
d3642 1
a3642 2
		_statusline(GOTO_CSO_DISALLOWED);
		sleep(MessageSecs);
d3646 1
a3646 2
		_statusline(GOTO_FINGER_DISALLOWED);
		sleep(MessageSecs);
d3650 1
a3650 2
		_statusline(GOTO_FTP_DISALLOWED);
		sleep(MessageSecs);
d3652 1
a3652 1
	     } else if (no_goto_gopher &&
d3654 1
a3654 2
		_statusline(GOTO_GOPHER_DISALLOWED);
		sleep(MessageSecs);
d3658 1
a3658 2
		_statusline(GOTO_HTTP_DISALLOWED);
		sleep(MessageSecs);
d3662 1
a3662 2
		_statusline(GOTO_HTTPS_DISALLOWED);
		sleep(MessageSecs);
d3666 1
a3666 2
		_statusline(GOTO_MAILTO_DISALLOWED);
		sleep(MessageSecs);
d3668 1
d3671 1
a3671 2
		_statusline(GOTO_NEWS_DISALLOWED);
		sleep(MessageSecs);
d3675 2
a3676 2
		_statusline(GOTO_NNTP_DISALLOWED);
		sleep(MessageSecs);
d3680 1
a3680 2
		_statusline(GOTO_RLOGIN_DISALLOWED);
		sleep(MessageSecs);
d3682 1
d3685 2
a3686 2
		_statusline(GOTO_SNEWS_DISALLOWED);
		sleep(MessageSecs);
d3690 1
a3690 2
		_statusline(GOTO_TELNET_DISALLOWED);
		sleep(MessageSecs);
d3694 1
a3694 2
		_statusline(GOTO_TN3270_DISALLOWED);
		sleep(MessageSecs);
d3698 1
a3698 2
		_statusline(GOTO_WAIS_DISALLOWED);
		sleep(MessageSecs);
d3703 3
d3707 1
a3707 2
		_statusline(GOTO_SPECIAL_DISALLOWED);
		sleep(MessageSecs);
d3720 1
a3720 1
		    StrAllocCopy(newdoc.title, "A URL specified by the user");
d3746 1
a3746 1
		StrAllocCopy(newdoc.title, "Help Screen");
d3765 1
a3765 2
			    _statusline(NO_INDEX_FILE);
			    sleep(MessageSecs);
d3770 1
a3770 1
		    StrAllocCopy(newdoc.title, "System Index"); /* name it */
a3780 44
#ifdef NOT_USED
	case LYK_FORM_UP:  /* change form */
	    break;	   /* not implemented */
	    if (lynx_mode == FORMS_LYNX_MODE) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
		    c = change_form_link(&links[curdoc.link],
					 FORM_UP, &newdoc, &refresh_screen,
					 links[curdoc.link].form->name,
					 links[curdoc.link].form->value);
		    /*
		     *	Code to handle multiple submit buttons?
		     *	Taken out due to bug it causes.
		    if (links[curdoc.link].form->type == F_SUBMIT_TYPE ||
			links[curdoc.link].form->type == F_IMAGESUBMIT_TYPE) {
			curdoc.address = NULL;
		    }
		     */
		    goto new_keyboard_input;
		} else {
		    _statusline("'X' can only toggle a form link");
		}
	    } else {
		_statusline("'X' only toggles in forms mode");
	    }
	    break;

	case LYK_FORM_DOWN:  /* change form */
	    break;	     /* not implemented */
	    if (lynx_mode==FORMS_LYNX_MODE) {
		if (links[curdoc.link].type == WWW_FORM_LINK_TYPE) {
		    c = change_form_link(&links[curdoc.link],
					 FORM_DOWN,&newdoc,&refresh_screen,
					 links[curdoc.link].form->name,
					 links[curdoc.link].form->value);
		    goto new_keyboard_input;
		} else {
		    _statusline("'Z' can only toggle a form link");
		}
	    } else {
		_statusline("'Z' only toggles in forms mode");
	    }
	    break;
#endif /* NOT_USED */

d3787 1
a3787 3
		_statusline(CONFIRM_MAIN_SCREEN);
		c = LYgetch();
		if (TOUPPER(c)=='Y') {
d3789 1
a3789 1
		    StrAllocCopy(newdoc.title, "Entry into main screen");
a3801 4
#ifdef VMS
		if (HadVMSInterrupt)
		    HadVMSInterrupt = FALSE;
#endif /* VMS */
d3805 1
a3805 2
			_statusline(IN_MAIN_SCREEN);
			sleep(MessageSecs);
d3814 22
a3835 1
	    options(); /* do the options stuff */
d3849 3
a3851 1
		LYRawMode_flag != LYRawMode ||
d3870 1
a3870 3
		    _statusline(WILL_NOT_RELOAD_DOC);
		    sleep(InfoSecs);

a3893 4
		    if (lynx_mode == FORMS_LYNX_MODE) {
			_statusline(RELOADING_FORM);
			sleep(AlertSecs);
		    }
d3895 1
d3897 16
d3914 1
d3921 2
a3922 4
		    newdoc.line = ((curdoc.line > 0) ?
					 curdoc.line : 1);
		    newdoc.link = ((curdoc.link > -1) ?
					  curdoc.link : 0);
d3928 3
a3930 13
	    keypad_mode_flag = keypad_mode;
	    user_mode_flag = user_mode;
	    HTfileSortMethod_flag = HTfileSortMethod;
	    CurrentCharSet_flag = current_char_set;
	    show_dotfiles_flag = show_dotfiles;
	    LYRawMode_flag = LYRawMode;
	    LYSelectPopups_flag = LYSelectPopups;
	    StrAllocCopy(CurrentUserAgent, (LYUserAgent ?
					    LYUserAgent : ""));
	    StrAllocCopy(CurrentNegoLanguage, (language ?
					       language : ""));
	    StrAllocCopy(CurrentNegoCharset, (pref_charset ?
					      pref_charset : ""));
d3933 40
d4046 1
a4046 2
		_statusline(NOT_ISINDEX);
		sleep(MessageSecs);
d4123 1
a4123 2
		    _statusline(NO_OWNER);
		    sleep(MessageSecs);
d4128 1
a4128 2
		    _statusline(MAIL_DISALLOWED);
		    sleep(MessageSecs);
d4131 1
a4131 3
		_statusline(CONFIRM_COMMENT);
		c = LYgetch();
		if (TOUPPER(c) == 'Y') {
d4161 2
d4164 1
a4164 3
			_user_message(NO_OWNER_USE, address);
			c = LYgetch();
			if (TOUPPER(c) == 'Y') {
d4182 14
a4195 1
			cp = HText_getRevTitle();
d4202 1
a4202 1
					   (cp ? cp : ""));
d4205 1
a4205 1
					  (cp ? cp : ""));
d4207 1
d4209 4
a4212 4
		   }
	       }
	   }
	   break;
d4307 1
a4307 1
		if (old_c != real_c)	{
d4309 1
a4309 2
		    _statusline(EDIT_DISABLED);
		    sleep(MessageSecs);
d4313 29
d4353 4
a4356 11
			if (!strncmp(cp, "file://localhost", 16)) {
			    /*
			     *	This is the only case that should occur. - kw
			     */
			    StrAllocCopy(tp, cp + 16);
			} else if (!strncmp(cp, "file:", 5)) {
			    StrAllocCopy(tp, cp + 5);
			} else {
			    StrAllocCopy(tp, cp);
			}
			HTUnEscape(tp);
d4358 1
a4358 2
			    _statusline(NO_STATUS);
			    sleep(AlertSecs);
d4360 2
a4361 2
			    if (((dir_info.st_mode) & S_IFMT) == S_IFREG) {
				StrAllocCopy(tp, cp);
d4380 2
a4381 4
				    newdoc.line =
					((curdoc.line > 0) ? curdoc.line : 1);
				    newdoc.link =
					((curdoc.link > -1) ? curdoc.link : 0);
d4416 1
a4416 2
		    _statusline(NO_EDITOR);
		    sleep(MessageSecs);
d4424 1
a4424 1
	    c = 'N';
d4427 1
a4427 1
		c = 'Y';
d4431 1
a4431 3
		_statusline(CONFIRM_BOOKMARK_DELETE);
		c = LYgetch();
		if (TOUPPER(c) != 'Y')
d4443 1
a4443 1
	    if (TOUPPER(c) == 'Y') {
d4472 2
a4473 2
		if (!showinfo(&curdoc, lines_in_file,
			      &newdoc, owner_address))
d4494 89
d4587 1
a4587 2
		    _statusline(PRINT_DISABLED);
		    sleep(MessageSecs);
d4598 2
a4599 1
		if (print_options(&newdoc.address, lines_in_file) < 0)
d4607 1
a4607 1
		ForcePush = TRUE;
d4647 35
d4696 1
a4696 2
		_statusline(VISITED_LINKS_EMPTY);
		sleep(MessageSecs);
d4717 1
a4717 2
		    _statusline(NO_TOOLBAR);
		    sleep(MessageSecs);
d4725 3
d4739 1
a4739 1
       case LYK_DIRED_MENU:  /* provide full file management menu */
d4757 1
a4757 2
		    _statusline(DFM_NOT_AVAILABLE);
		    sleep(MessageSecs);
d4783 1
a4783 2
		    if (TRACE)
			fprintf(stderr, "mainloop: Can't stat %s\n", cp);
d4793 1
a4793 1
		    if (((stat_info.st_mode) & S_IFMT) == S_IFDIR) {
d4798 1
a4798 2
			if (cp[(strlen(cp) - 1)] != '/')
			    StrAllocCat(cp, "/");
d4852 1
a4852 1
	    system(temp);
d4873 5
a4877 2
	    run_external(links[curdoc.link].lname);
	    refresh_screen = TRUE;
d4885 1
a4885 2
		    _statusline(BOOKMARKS_DISABLED);
		    sleep(MessageSecs);
d4911 2
d4926 2
d4932 1
a4932 2
			strcmp((curdoc.title ? curdoc.title : ""),
			       LIST_PAGE_TITLE) &&
d4967 1
a4967 2
			    _statusline(NOBOOK_POST_FORM);
			    sleep(MessageSecs);
d4986 1
a4986 2
			    _statusline(NOBOOK_POST_FORM);
			    sleep(MessageSecs);
d4997 1
a4997 2
			    _statusline(NOBOOK_FORM_FIELD);
			    sleep(MessageSecs);
d5007 1
a5007 2
		    _statusline(NOBOOK_POST_FORM);
		    sleep(MessageSecs);
d5014 1
a5014 2
		    _statusline(BOOKMARKS_NOLINKS);
		    sleep(MessageSecs);
d5041 1
a5041 2
			_statusline(NOBOOK_HSML);
			sleep(MessageSecs);
d5050 1
a5050 2
		    _statusline(BOOKMARKS_DISABLED);
		    sleep(MessageSecs);
d5089 2
a5090 36
		printf(SPAWNING_MSG);
		fflush(stdout);
		fflush(stderr);
		if (LYTraceLogFP)
		    /*
		     *	Set stderr back to its original value
		     *	during the shell escape. - FM
		     */
		    *stderr = LYOrigStderr;
#ifdef DOSPATH
#ifdef __DJGPP__
		__djgpp_set_ctrl_c(0);
		_go32_want_ctrl_break(1);
#endif /* __DJGPP__ */
		if (getenv("SHELL") != NULL) {
		    system(getenv("SHELL"));
		} else {
		    system(getenv("COMSPEC") == NULL ? "command.com" : getenv("COMSPEC"));
		}
#ifdef __DJGPP__
		__djgpp_set_ctrl_c(1);
		_go32_want_ctrl_break(0);
#endif /* __DJGPP__ */
#else
#ifdef VMS
		system("");
#else
		system("exec $SHELL");
#endif /* VMS */
#endif /* DOSPATH */
		if (LYTraceLogFP)
		    /*
		     *	Set stderr back to the log file on
		     *	return from the shell escape. - FM
		     */
		    *stderr = *LYTraceLogFP;
d5096 1
a5096 2
			_statusline(SPAWNING_DISABLED);
			sleep(MessageSecs);
d5109 1
a5109 2
		    _statusline(DOWNLOAD_DISABLED);
		    sleep(MessageSecs);
d5129 9
a5137 2
				_statusline(NO_DOWNLOAD_MAILTO_ACTION);
				sleep(MessageSecs);
d5148 1
a5148 2
			_statusline(NO_DOWNLOAD_INPUT);
			sleep(MessageSecs);
d5155 1
a5155 2
			_statusline(NO_DOWNLOAD_COOKIES);
			sleep(MessageSecs);
d5162 1
a5162 2
			_statusline(NO_DOWNLOAD_PRINT_OP);
			sleep(MessageSecs);
d5171 1
a5171 2
			_statusline(NO_DOWNLOAD_UPLOAD_OP);
			sleep(MessageSecs);
d5179 1
a5179 2
			_statusline(NO_DOWNLOAD_PERMIT_OP);
			sleep(MessageSecs);
d5203 1
a5203 2
			_statusline(CANCELLED);
			sleep(InfoSecs);
d5206 3
d5246 6
d5255 1
a5255 2
		    _statusline(NO_DOWNLOAD_SPECIAL);
		    sleep(MessageSecs);
d5257 17
d5312 1
a5312 2
		_statusline(NO_DOWNLOAD_CHOICE);
		sleep(MessageSecs);
d5347 3
a5349 40
	    if (WWW_TraceFlag)
		WWW_TraceFlag = FALSE;
	    else
		WWW_TraceFlag = TRUE;

	    _statusline(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
	    sleep(MessageSecs);

	    if (TRACE && LYUseTraceLog && LYTraceLogFP == NULL) {
		/*
		 *  We haven't yet started a TRACE log for this
		 *  session.  If we can't open the file with write
		 *  access, turn off TRACE and give up.  Otherwise,
		 *  on VMS we'll close it and delete it and any
		 *  log file from a previous session, so they don't
		 *  accumulate, and then open it again, including
		 *  "shr=get" to overcome open file locking when
		 *  attempting to read the log via the TRACE_LOG
		 *  command. - FM
		 */
		if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
		    WWW_TraceFlag = FALSE;
		    _statusline(TRACELOG_OPEN_FAILED);
		    sleep(MessageSecs);
		    break;
		}
#ifdef VMS
		fclose(LYTraceLogFP);
		while (remove(LYTraceLogPath) == 0)
		    ;
		if ((LYTraceLogFP = LYNewTxtFile(LYTraceLogPath)) == NULL) {
		    WWW_TraceFlag == FALSE;
		    _statusline(TRACELOG_OPEN_FAILED);
		    sleep(MessageSecs);
		    break;
		}
#endif /* VMS */
		*stderr = *LYTraceLogFP;
		fprintf(stderr, "\t\t%s\n\n", LYNX_TRACELOG_TITLE);
	    }
d5358 1
a5358 2
		_statusline(NO_TRACELOG_STARTED);
		sleep(MessageSecs);
d5380 1
a5380 10
	    if (TRACE)
		fprintf(stderr, "\nTurning off TRACE for fetch of log.\n");
	    fflush(stdout);
	    fflush(stderr);
	    fclose(LYTraceLogFP);
	    *stderr = LYOrigStderr;
	    if ((LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath)) == NULL) {
		WWW_TraceFlag = FALSE;
		_statusline(TRACELOG_OPEN_FAILED);
		sleep(MessageSecs);
d5382 2
a5383 12
	    }
	    *stderr = *LYTraceLogFP;
	    if (TRACE) {
		WWW_TraceFlag = FALSE;
		trace_mode_flag = TRUE;
	    }
	    StrAllocCopy(newdoc.address, "file://localhost");
#ifdef VMS
	    StrAllocCat(newdoc.address, HTVMS_wwwName(LYTraceLogPath));
#else
	    StrAllocCat(newdoc.address, LYTraceLogPath);
#endif /* VMS */
d5403 1
a5403 1
	    _statusline(clickable_images ?
d5405 5
a5409 1
	    sleep(MessageSecs);
a5411 1
	    break;
d5419 7
a5425 3
	    _statusline(pseudo_inline_alts ?
		     PSEUDO_INLINE_ALTS_ON : PSEUDO_INLINE_ALTS_OFF);
	    sleep(MessageSecs);
a5427 1
	    break;
d5430 15
a5444 11
	    if (LYUseDefaultRawMode)
		LYUseDefaultRawMode = FALSE;
	    else
		LYUseDefaultRawMode = TRUE;
	    _statusline(LYRawMode ? RAWMODE_OFF : RAWMODE_ON);
	    HTMLSetCharacterHandling(current_char_set);
	    LYRawMode_flag = LYRawMode;
	    sleep(MessageSecs);
	    cmd = LYK_RELOAD;
	    goto new_cmd;
	    break;
d5461 1
a5461 2
			_statusline(DOC_NOT_HTTP_URL);
			sleep(MessageSecs);
d5471 1
a5471 2
			    _statusline(CANCELLED);
			    sleep(InfoSecs);
d5494 1
a5494 2
			_statusline(LINK_NOT_HTTP_URL);
			sleep(MessageSecs);
d5497 1
a5497 2
			_statusline(FORM_ACTION_DISABLED);
			sleep(MessageSecs);
d5503 1
a5503 2
			_statusline(FORM_ACTION_NOT_HTTP_URL);
			sleep(MessageSecs);
d5508 1
a5508 2
			_statusline(CANCELLED);
			sleep(InfoSecs);
d5527 1
a5527 2
		    _statusline(CANCELLED);
		    sleep(InfoSecs);
d5555 1
a5555 2
			_statusline(DOC_NOT_HTTP_URL);
			sleep(MessageSecs);
d5620 1
a5620 1
			    _statusline(JUMP_DISALLOWED);
d5622 1
a5622 2
			    _statusline(NO_JUMPFILE);
			sleep(MessageSecs);
d5642 1
a5642 2
				statusline(NO_RANDOM_URLS_YET);
				sleep(MessageSecs);
d5652 2
a5653 15
			LYTrimHead(ret);
			if (!strncasecomp(ret, "lynxexec:", 9) ||
			    !strncasecomp(ret, "lynxprog:", 9)) {
			    /*
			     *	The original implementations of these schemes
			     *	expected white space without hex escaping,
			     *	and did not check for hex escaping, so we'll
			     *	continue to support that, until that code is
			     *	redone in conformance with SGML principles.
			     *	- FM
			     */
			    HTUnEscapeSome(ret, " \r\n\t");
			    convert_to_spaces(ret, TRUE);
			} else {
			    collapse_spaces(user_input_buffer);
d5681 1
d5683 2
d5686 2
a5687 1
		    _statusline(AUTH_INFO_CLEARED);
d5689 1
a5689 1
		    _statusline(CANCELLED);
a5690 1
		sleep(MessageSecs);
a5693 13
#ifdef NOT_USED
	case LYK_VERSION:
	    if (old_c != real_c) {
		char version[128];
		old_c = real_c;
		sprintf(version, "*** %s Version %s ***",
				 LYNX_NAME, LYNX_VERSION);
		statusline(version);
		sleep(AlertMessage);
	    }
	    break;
#endif /* NOT_USED */

d5959 1
a5959 1
	char *, 	url)
d5974 1
d5976 1
d5992 258
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
