head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.25.18.17.10;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	98.05.06.04.08.41;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYMail.c,v 1.96 2013/11/28 11:23:37 tom Exp $
 */
#include <HTUtils.h>
#include <HTParse.h>
#include <LYGlobalDefs.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <LYSignal.h>
#include <LYUtils.h>
#include <LYClean.h>
#include <LYStrings.h>
#include <GridText.h>
#include <LYMail.h>
#include <LYEdit.h>
#include <LYCharSets.h>		/* to get current charset for mail header */

#include <LYLeaks.h>

#define MAX_SUBJECT 70

BOOLEAN term_letter;		/* Global variable for async i/o. */

static void terminate_letter(int sig GCC_UNUSED)
{
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if USE_VMS_MAILER || defined(PDCURSES)
    /*
     * Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	LYrefresh();
    }
#endif /* VMS */
}

/* HTUnEscape with control-code nuking */
static void SafeHTUnEscape(char *string)
{
    int i;
    int flg = FALSE;

    HTUnEscape(string);
    for (i = 0; string[i] != '\0'; i++) {
	/* FIXME: this is no longer explicitly 7-bit ASCII,
	   but are there portability problems? */
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i]))) {
	    string[i] = '?';
	    flg = TRUE;
	}
    }
    if (flg)
	HTAlert(MAILTO_SQUASH_CTL);
}

static void remove_tildes(char *string)
{
    /*
     * Change the first character to a space if it is a '~'.
     */
    if (*string == '~')
	*string = ' ';
}

static void comma_append(char **dst,
			 char *src)
{
    if (*src) {
	while (*src == ',' || isspace(UCH(*src)))
	    src++;
	if (*src) {
	    if (isEmpty(*dst)) {
		StrAllocCopy(*dst, src);
	    } else {
		StrAllocCat(*dst, ",");
		StrAllocCat(*dst, src);
	    }
	}
    }
}

static void extract_field(char **dst,
			  char *src,
			  const char *keyword)
{
    int len = (int) strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = StrChr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    comma_append(dst, cp);
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, *dst));
}

/*
 * Seek and handle a subject=foo.  - FM
 */
static void extract_subject(char *dst,
			    char *src)
{
    const char *keyword = "subject=";
    int len = (int) strlen(keyword);
    char *cp, *cp1;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len))
	    break;
	cp++;
    }
    if (*cp) {
	cp += len;
	if ((cp1 = StrChr(cp, '&')) != NULL) {
	    *cp1 = '\0';
	}
	if (*cp) {
	    LYStrNCpy(dst, cp, MAX_SUBJECT);
	    SafeHTUnEscape(dst);
	}
	if (cp1) {
	    *cp1 = '&';
	    cp1 = NULL;
	}
    }
    CTRACE((tfp, "extract_subject(%s) = '%s'\n", keyword, NONNULL(dst)));
}

/*
 * Seek and handle body=foo fields.  - FM
 */
static void extract_body(char **dst,
			 char *src)
{
    const char *keyword = "body=";
    int len = (int) strlen(keyword);
    int i;
    char *cp, *cp0, *cp1, *temp = 0;

    cp = (src + 1);
    while (*cp != '\0') {
	if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
	    !strncasecomp(cp, keyword, len)) {
	    cp += len;
	    if ((cp1 = StrChr(cp, '&')) != NULL) {
		*cp1 = '\0';
	    }
	    if (*cp) {
		/*
		 * Break up the value into lines with a maximum length of 78. 
		 * - FM
		 */
		StrAllocCopy(temp, cp);
		HTUnEscape(temp);
		cp0 = temp;
		while ((cp = StrChr(cp0, '\n')) != NULL) {
		    *cp = '\0';
		    if (cp > cp0) {
			if (*(cp - 1) == '\r') {
			    *(cp - 1) = '\0';
			}
		    }
		    i = 0;
		    len = (int) strlen(cp0);
		    while (len > 78) {
			HTSprintf(dst, "%.78s\n", &cp0[i]);
			i += 78;
			len = (int) strlen(&cp0[i]);
		    }
		    HTSprintf(dst, "%s\n", &cp0[i]);
		    cp0 = (cp + 1);
		}
		i = 0;
		len = (int) strlen(cp0);
		while (len > 78) {
		    HTSprintf(dst, "%.78s\n", &cp0[i]);
		    i += 78;
		    len = (int) strlen(&cp0[i]);
		}
		if (len) {
		    HTSprintf(dst, "%s\n", &cp0[i]);
		}
		FREE(temp);
	    }
	    if (cp1) {
		*cp1 = '&';
		cp = cp1;
		cp1 = NULL;
	    } else {
		break;
	    }
	}
	cp++;
    }
    CTRACE((tfp, "extract_body(%s) = '%s'\n", keyword, NONNULL(*dst)));
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
static BOOLEAN trim_comma(char *address)
{
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    return (BOOL) (*address == '\0');
}

/*
 * Convert any Explorer semi-colon Internet address separators to commas - FM
 */
static BOOLEAN convert_explorer(char *address)
{
    char *cp = address;
    char *cp0;
    char *cp1;

    while ((cp1 = StrChr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = StrChr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    return trim_comma(address);
}

/*
 * reply_by_mail() prompts line-by-line for header information, allowing
 * scrolling of the screen.
 */
static int header_prompt(const char *label,
			 char **result,
			 unsigned limit)
{
    char buffer[LINESIZE];
    int ok;

    if (*result != 0) {
	LYaddstr(CTRL_U_TO_ERASE);
	LYStrNCpy(buffer, *result, sizeof(buffer) - 1);
    } else
	*buffer = 0;

    if (limit > sizeof(buffer))
	limit = sizeof(buffer);

    LYaddstr(gettext(label));
    LYaddstr(": ");
    ok = (LYGetStr(buffer, FALSE, limit, NORECALL) >= 0
	  && !term_letter);
    LYaddstr("\n");

    if (ok) {
	remove_tildes(buffer);
	StrAllocCopy(*result, buffer);
    }
    term_letter = FALSE;
    return ok;
}

static void show_addresses(char *addresses)
{
    char *cp = addresses;
    char *cp1;

    while ((cp1 = StrChr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    LYaddstr(cp);
	    LYaddstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	LYaddstr(cp);
    }
}

#if USE_BLAT_MAILER

/*
 * blat's options-file parser (see makeargv.cpp) treats backslash and double
 * quote characters specially.  lynx doesn't.  Do a conversion as we write the
 * option.
 *
 * Other quirks (reading blat 3.06):
 * + Whitespace not in quotes terminates a line.
 * + Blat allows a comment-character to terminate a line.  By default, that
 *   is a semicolon.
 *
 * Given that, the simplest thing to do is to always quote the string, using
 * escaping to handle special cases.
 */
static void blat_option(FILE *fp, const char *option, const char *value)
{
    if (non_empty(value)) {
	char *result = malloc(strlen(option) + 4 + 4 * strlen(value));
	char *working = result;

	CTRACE((tfp, "blat_option(opt=\"%s\", value=\"%s\")\n", option, value));
	sprintf(working, "%s \"", option);
	working += strlen(working);

	while (*value != '\0') {
	    unsigned ch = UCH(*value);

	    switch (ch) {
	    case '\\':
		*working++ = '\\';
		*working++ = '\\';
		break;
	    case '"':
		*working++ = '\\';
		*working++ = '"';
		break;
	    default:
		if (ch < ' ' || ch > '~') {
		    sprintf(working, "\\%03o", ch);
		} else {
		    *working++ = ch;
		}
		break;
	    }
	    ++value;
	}
	*working++ = '"';
	*working++ = '\n';
	*working = 0;

	CTRACE((tfp, "->%s", result));
	fputs(result, fp);
	FREE(result);
    }
}

/*
syntax for blat 2.6.2:
Blat <filename> -t <recipient> [optional switches (see below)]

-bodyF <filename> : file with the message body
-t <recipient>    : recipient list (comma separated)
-s <subj>         : subject line
-f <sender>       : overrides the default sender address (must be known to server)
-i <addr>         : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>    : carbon copy recipient list (comma separated)
-b <recipient>    : blind carbon copy recipient list (comma separated)
-help             : displays the help message.
-mime             : MIME Quoted-Printable Content-Transfer-Encoding.
-q                : supresses *all* output.
-server <addr>    : overrides the default SMTP server to be used.

*/

static char *blat_cmd(char *filename,
		      char *address,
		      char *subject,
		      char *ccaddr,
		      char *mail_addr)
{
    char *b_cmd = NULL;

    if (mail_is_altblat) {
	const char *format = "%s %s -t %s -s %s %s%s%s";

	HTAddParam(&b_cmd, format, 1, ALTBLAT_MAIL);
	HTAddParam(&b_cmd, format, 2, filename);
	HTAddParam(&b_cmd, format, 3, address);
	HTAddParam(&b_cmd, format, 4, subject);
	HTAddToCmd(&b_cmd, format, 5, ALTBLAT_MAIL_FLAGS);
	if (non_empty(ccaddr)) {
	    HTAddToCmd(&b_cmd, format, 6, " -c ");
	    HTAddParam(&b_cmd, format, 7, NonNull(ccaddr));
	}
	HTEndParam(&b_cmd, format, 8);

    } else {

	const char *format = "%s -of %s";
	char bl_cmd_file[LY_MAXPATH];
	FILE *fp;

#ifdef __CYGWIN__
	char dosname[LY_MAXPATH];

#else
	char *dosname;
#endif

	bl_cmd_file[0] = '\0';
	if ((fp = LYOpenTemp(bl_cmd_file, ".blt", "w")) == NULL) {
	    HTAlert(FORM_MAILTO_FAILED);
	    return NULL;
	}

	HTAddParam(&b_cmd, format, 1, BLAT_MAIL);

	ConvertToWin32Path(filename, dosname);
	blat_option(fp, "-bodyF", dosname);
	blat_option(fp, "-t", address);
	blat_option(fp, "-s", subject);
	blat_option(fp, "-f", mail_addr);
	blat_option(fp, "-c", ccaddr);
	LYCloseOutput(fp);

	ConvertToWin32Path(bl_cmd_file, dosname);

	HTAddParam(&b_cmd, format, 2, dosname);
	HTEndParam(&b_cmd, format, 3);

    }

    return b_cmd;
}

#endif /* USE_BLAT_MAILER */

#if USE_VMS_MAILER
BOOLEAN LYMailPMDF(void)
{
    return (system_mail != 0)
	? !strncasecomp(system_mail, "PMDF SEND", 9)
	: FALSE;
}

/*
 * Add all of the people in the address field to the command
 */
static void vms_append_addrs(char **cmd, char *address, char *option)
{
    BOOLEAN first = TRUE;
    char *cp;
    char *address_ptr1;
    char *address_ptr2;

    address_ptr1 = address;
    do {
	if ((cp = StrChr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp + 1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 * 4 letters is arbitrarily the smallest possible mail address, at
	 * least for lynx.  That way extra spaces won't confuse the mailer and
	 * give a blank address.
	 */
	if (strlen(address_ptr1) > 3) {
	    if (!first) {
		StrAllocCat(*cmd, ",");
	    }
	    HTSprintf(cmd, mail_adrs, address_ptr1);
	    if (*option && LYMailPMDF())
		StrAllocCat(*cmd, option);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
}

static void remove_quotes(char *string)
{
    while (*string != 0) {
	if (StrChr("\"&|", *string) != 0)
	    *string = ' ';
	string++;
    }
}
#else
#if CAN_PIPE_TO_MAILER

/*
 * Open a pipe to the mailer
 */
FILE *LYPipeToMailer(void)
{
    char *buffer = NULL;
    FILE *fp = NULL;

    if (LYSystemMail()) {
	HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
	fp = popen(buffer, "w");
	CTRACE((tfp, "popen(%s) %s\n", buffer, fp != 0 ? "OK" : "FAIL"));
	FREE(buffer);
    }
    return fp;
}
#else /* DOS, Win32, etc. */

int LYSendMailFile(char *the_address,
		   char *the_filename,
		   char *the_subject GCC_UNUSED,
		   char *the_ccaddr GCC_UNUSED,
		   char *message)
{
    char *cmd = NULL;
    int code;

    if (!LYSystemMail())
	return 0;

#if USE_BLAT_MAILER
    if (mail_is_blat) {
	cmd = blat_cmd(the_filename,
		       the_address,
		       the_subject,
		       the_ccaddr,
		       personal_mail_address);
    } else
#endif
#ifdef __DJGPP__
    if (LYGetEnv("SHELL")) {
	extern int dj_is_bash;
	extern char *shell;
	const char *c_option;
	const char *format = "%s %s %s -t %s -F %s";

	if (dj_is_bash) {
	    c_option = "-c";
	} else {
	    c_option = "/c";
	}
	HTAddParam(&cmd, format, 1, shell);
	HTAddParam(&cmd, format, 2, c_option);
	HTAddParam(&cmd, format, 3, system_mail);
	HTAddParam(&cmd, format, 4, the_address);
	HTAddParam(&cmd, format, 5, the_filename);
	HTEndParam(&cmd, format, 6);
    } else
#endif /* __DJGPP__ */
    {
	const char *format = "%s -t %s -F %s";

	HTAddParam(&cmd, format, 1, system_mail);
	HTAddParam(&cmd, format, 2, the_address);
	HTAddParam(&cmd, format, 3, the_filename);
	HTEndParam(&cmd, format, 4);
    }

    stop_curses();
    SetOutputMode(O_TEXT);
    printf("%s\n\n$ %s\n\n%s",
	   *message ? message : gettext("Sending"),
	   cmd, PLEASE_WAIT);
    code = LYSystem(cmd);
    LYSleepMsg();
    start_curses();
    SetOutputMode(O_BINARY);

    FREE(cmd);

    return code;
}
#endif /* CAN_PIPE_TO_FILE */
#endif /* USE_VMS_MAILER */

/*
 *  mailform() sends form content to the mailto address(es). - FM
 */
void mailform(const char *mailto_address,
	      const char *mailto_subject,
	      const char *mailto_content,
	      const char *mailto_type)
{
    FILE *fd;
    char *address = NULL;
    char *ccaddr = NULL;
    char *keywords = NULL;
    char *cp = NULL;
    char self[MAX_SUBJECT + 10];
    char subject[MAX_SUBJECT + 10];
    char *searchpart = NULL;
    char buf[512];
    int len, i;

#if USE_VMS_MAILER
    static char *cmd;
    char *command = NULL;
    BOOLEAN isPMDF = LYMailPMDF();
    char hdrfile[LY_MAXPATH];
#endif
#if !CAN_PIPE_TO_MAILER
    char my_tmpfile[LY_MAXPATH];
#endif

    CTRACE((tfp, "mailto_address: \"%s\"\n", NONNULL(mailto_address)));
    CTRACE((tfp, "mailto_subject: \"%s\"\n", NONNULL(mailto_subject)));
    CTRACE((tfp, "mailto_content: \"%s\"\n", NONNULL(mailto_content)));
    CTRACE((tfp, "mailto_type:    \"%s\"\n", NONNULL(mailto_type)));

    if (!LYSystemMail())
	return;

    if (!mailto_address || !mailto_content) {
	HTAlert(BAD_FORM_MAILTO);
	return;
    }
    subject[0] = '\0';
    self[0] = '\0';

    if ((cp = StrChr(mailto_address, '\n')) != NULL)
	*cp = '\0';
    StrAllocCopy(address, mailto_address);

    /*
     * Check for a ?searchpart.  - FM
     */
    if ((cp = StrChr(address, '?')) != NULL) {
	StrAllocCopy(searchpart, cp);
	*cp = '\0';
	cp = (searchpart + 1);
	if (*cp != '\0') {
	    /*
	     * Seek and handle a subject=foo.  - FM
	     */
	    extract_subject(subject, searchpart);

	    /*
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
	     */
	    extract_field(&address, searchpart, "to=");

	    /*
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
	     */
	    extract_field(&ccaddr, searchpart, "cc=");

	    /*
	     * Seek and handle keywords=term(s) fields.  - FM
	     */
	    extract_field(&keywords, searchpart, "keywords=");

	    if (keywords != NULL) {
		if (*keywords != '\0') {
		    SafeHTUnEscape(keywords);
		} else {
		    FREE(keywords);
		}
	    }

	    FREE(searchpart);
	}
    }

    if (convert_explorer(address)) {
	HTAlert(BAD_FORM_MAILTO);
	goto cleanup;
    }
    if (ccaddr != NULL) {
	if (convert_explorer(ccaddr)) {
	    FREE(ccaddr);
	}
    }

    /*
     * Unescape the address and ccaddr fields.  - FM
     */
    SafeHTUnEscape(address);
    if (ccaddr != NULL) {
	SafeHTUnEscape(ccaddr);
    }

    /*
     * Allow user to edit the default Subject - FM
     */
    if (subject[0] == '\0') {
	if (non_empty(mailto_subject)) {
	    LYStrNCpy(subject, mailto_subject, MAX_SUBJECT);
	} else {
	    sprintf(subject, "mailto:%.63s", address);
	}
    }
    _statusline(SUBJECT_PROMPT);
    if (LYGetStr(subject, FALSE, MAX_SUBJECT, NORECALL) < 0) {
	/*
	 * User cancelled via ^G. - FM
	 */
	HTInfoMsg(FORM_MAILTO_CANCELLED);
	goto cleanup;
    }

    /*
     * Allow user to specify a self copy via a CC:  entry, if permitted.  - FM
     */
    if (!LYNoCc) {
	sprintf(self, "%.*s", MAX_SUBJECT,
		isEmpty(personal_mail_address) ? "" : personal_mail_address);
	_statusline("Cc: ");
	if (LYGetStr(self, FALSE, MAX_SUBJECT, NORECALL) < 0) {
	    /*
	     * User cancelled via ^G. - FM
	     */
	    HTInfoMsg(FORM_MAILTO_CANCELLED);
	    goto cleanup;
	}
	remove_tildes(self);
	if (ccaddr == NULL) {
	    StrAllocCopy(ccaddr, self);
	} else {
	    StrAllocCat(ccaddr, ",");
	    StrAllocCat(ccaddr, self);
	}
    }
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }

    if (non_empty(mailto_type)) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd, "To: %s\n", address);
    if (non_empty(personal_mail_address))
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (non_empty(ccaddr))
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (non_empty(keywords))
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
#else /* e.g., VMS, DOS */
    if ((fd = LYOpenTemp(my_tmpfile, ".txt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	goto cleanup;
    }
#if USE_VMS_MAILER
    if (isPMDF) {
	FILE *hfd;

	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
	    HTAlert(FORM_MAILTO_FAILED);
	    LYCloseTempFP(fd);
	    goto cleanup;
	}
	if (non_empty(mailto_type)) {
	    fprintf(hfd, "Mime-Version: 1.0\n");
	    fprintf(hfd, "Content-Type: %s\n", mailto_type);
	    if (non_empty(personal_mail_address))
		fprintf(hfd, "From: %s\n", personal_mail_address);
	}
	/*
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
	 */
	if (non_empty(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
    } else if (mailto_type &&
	       !strncasecomp(mailto_type, "multipart/form-data", 19)) {
	/*
	 * Ugh!  There's no good way to include headers while we're still using
	 * "generic" VMS MAIL, so we'll put this in the body of the message.  -
	 * FM
	 */
	fprintf(fd, "X-Content-Type: %s\n\n", mailto_type);
    }
#else /* !VMS (DOS) */
#if USE_BLAT_MAILER
    if (mail_is_blat) {
	if (strlen(subject) > MAX_SUBJECT)
	    subject[MAX_SUBJECT] = '\0';
    } else
#endif
    {
	if (non_empty(mailto_type)) {
	    fprintf(fd, "Mime-Version: 1.0\n");
	    fprintf(fd, "Content-Type: %s\n", mailto_type);
	}
	fprintf(fd, "To: %s\n", address);
	if (non_empty(personal_mail_address))
	    fprintf(fd, "From: %s\n", personal_mail_address);
	fprintf(fd, "Subject: %.70s\n\n", subject);
    }
#endif /* VMS */
#endif /* CAN_PIPE_TO_MAILER */

    /*
     * Break up the content into lines with a maximum length of 78.  If the
     * ENCTYPE was text/plain, we have physical newlines and should take them
     * into account.  Otherwise, the actual newline characters in the content
     * are hex escaped.  - FM
     */
    while ((cp = StrChr(mailto_content, '\n')) != NULL) {
	*cp = '\0';
	i = 0;
	len = (int) strlen(mailto_content);
	while (len > 78) {
	    LYStrNCpy(buf, &mailto_content[i], 78);
	    fprintf(fd, "%s\n", buf);
	    i += 78;
	    len = (int) strlen(&mailto_content[i]);
	}
	fprintf(fd, "%s\n", &mailto_content[i]);
	mailto_content = (cp + 1);
    }
    i = 0;
    len = (int) strlen(mailto_content);
    while (len > 78) {
	LYStrNCpy(buf, &mailto_content[i], 78);
	fprintf(fd, "%s\n", buf);
	i += 78;
	len = (int) strlen(&mailto_content[i]);
    }
    if (len)
	fprintf(fd, "%s\n", &mailto_content[i]);

#if CAN_PIPE_TO_MAILER
    pclose(fd);
    LYSleepMsg();
#else
    LYCloseTempFP(fd);
#if USE_VMS_MAILER
    /*
     * Set the mail command.  - FM
     */
    if (isPMDF) {
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&cmd,
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
	 */
	HTSprintf0(&cmd,
		   "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   subject,
		   my_tmpfile);
    }
    StrAllocCopy(command, cmd);

    vms_append_addrs(&command, address, "");
    if (non_empty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
    }

    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_FORM_CONTENT, command, PLEASE_WAIT);
    LYSystem(command);		/* Mail (VMS) */
    FREE(command);
    LYSleepAlert();
    start_curses();
    (void) LYRemoveTemp(my_tmpfile);
    if (isPMDF)
	(void) LYRemoveTemp(hdrfile);
#else /* DOS */
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   SENDING_FORM_CONTENT);
    (void) LYRemoveTemp(my_tmpfile);
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */

  cleanup:
    FREE(address);
    FREE(ccaddr);
    FREE(keywords);
    return;
}

/*
 *  mailmsg() sends a message to the owner of the file, if one is defined,
 *  telling of errors (i.e., link not available).
 */
void mailmsg(int cur,
	     char *owner_address,
	     char *filename,
	     char *linkname)
{
    FILE *fd, *fp;
    char *address = NULL;
    char *searchpart = NULL;
    char *cmd = NULL, *cp;

#ifdef ALERTMAIL
    BOOLEAN skip_parsing = FALSE;
#endif
#if !CAN_PIPE_TO_MAILER
    char *ccaddr;
    char subject[128];
    char my_tmpfile[LY_MAXPATH];
#endif
#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
    char hdrfile[LY_MAXPATH];
    char *command = NULL;

    CTRACE((tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	    NONNULL(owner_address),
	    NONNULL(filename),
	    NONNULL(linkname)));

#endif /* VMS */

    if (!LYSystemMail())
	return;

#ifdef ALERTMAIL
    if (owner_address == NULL) {
	owner_address = ALERTMAIL;
	skip_parsing = TRUE;
    }
#endif

    if (isEmpty(owner_address))
	return;
    if ((cp = StrChr(owner_address, '\n')) != NULL) {
#ifdef ALERTMAIL
	if (skip_parsing)
	    return;		/* invalidly defined - ignore - kw */
#else
	*cp = '\0';
#endif
    }
    if (!strncasecomp(owner_address, "lynx-dev@@", 9)) {
	/*
	 * Silently refuse sending bad link messages to lynx-dev.
	 */
	return;
    }
    StrAllocCopy(address, owner_address);

#ifdef ALERTMAIL
    /*
     * If we are using a fixed address given by ALERTMAIL, it is supposed to
     * already be in usable form, without URL-isms like ?-searchpart and
     * URL-escaping.  So skip some code.  - kw
     */
    if (!skip_parsing)
#endif
    {
	/*
	 * Check for a ?searchpart.  - FM
	 */
	if ((cp = StrChr(address, '?')) != NULL) {
	    StrAllocCopy(searchpart, cp);
	    *cp = '\0';
	    cp = (searchpart + 1);
	    if (*cp != '\0') {
		/*
		 * Seek and handle to=address(es) fields.
		 * Appends to address.  We ignore any other
		 * headers in the ?searchpart.  - FM
		 */
		extract_field(&address, searchpart, "to=");
	    }
	}

	(void) convert_explorer(address);

	/*
	 * Unescape the address field.  - FM
	 */
	SafeHTUnEscape(address);
    }

    if (trim_comma(address)) {
	FREE(address);
	CTRACE((tfp, "mailmsg: No address in '%s'.\n", owner_address));
	return;
    }
#if CAN_PIPE_TO_MAILER
    if ((fd = LYPipeToMailer()) == 0) {
	FREE(address);
	CTRACE((tfp, "mailmsg: '%s' failed.\n", cmd));
	return;
    }

    fprintf(fd, "To: %s\n", address);
    fprintf(fd, "Subject: Lynx Error in %s\n", filename);
    if (non_empty(personal_mail_address)) {
	fprintf(fd, "Cc: %s\n", personal_mail_address);
    }
    fprintf(fd, "X-URL: %s\n", filename);
    fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
#else
    if ((fd = LYOpenTemp(my_tmpfile, ".txt", "w")) == NULL) {
	CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", my_tmpfile));
	FREE(address);
	return;
    }
    sprintf(subject, "Lynx Error in %.56s", filename);
    ccaddr = personal_mail_address;
#if USE_VMS_MAILER
    if (isPMDF) {
	FILE *hfd;

	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
	    CTRACE((tfp, "mailmsg: Could not fopen '%s'.\n", hdrfile));
	    FREE(address);
	    return;
	}

	if (non_empty(personal_mail_address)) {
	    fprintf(fd, "Cc: %s\n", personal_mail_address);
	}
	fprintf(fd, "X-URL: %s\n", filename);
	fprintf(fd, "X-Mailer: %s, Version %s\n\n", LYNX_NAME, LYNX_VERSION);
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
    }
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */

    fprintf(fd, gettext("The link   %s :?: %s \n"),
	    links[cur].lname, links[cur].target);
    fprintf(fd, gettext("called \"%s\"\n"), LYGetHiliteStr(cur, 0));
    fprintf(fd, gettext("in the file \"%s\" called \"%s\"\n"), filename, linkname);
    fprintf(fd, "%s\n\n", gettext("was requested but was not available."));
    fprintf(fd, "%s\n\n", gettext("Thought you might want to know."));

    fprintf(fd, "%s\n", gettext("This message was automatically generated by"));
    fprintf(fd, "%s %s", LYNX_NAME, LYNX_VERSION);
    if ((LynxSigFile != NULL) &&
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
	fputs("-- \n", fd);
	while (LYSafeGets(&cmd, fp) != NULL)
	    fputs(cmd, fd);
	LYCloseInput(fp);
    }
#if CAN_PIPE_TO_MAILER
    pclose(fd);
#else
    LYCloseTempFP(fd);
#if USE_VMS_MAILER
    if (isPMDF) {
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&command,
		   "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command.  - FM
	 */
	HTSprintf0(&command,
		   "%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		   system_mail,
		   system_mail_flags,
		   filename,
		   my_tmpfile);
    }
    vms_append_addrs(&command, address, "");

    LYSystem(command);		/* VMS */
    FREE(command);
    FREE(cmd);
    (void) LYRemoveTemp(my_tmpfile);
    if (isPMDF) {
	(void) LYRemoveTemp(hdrfile);
    }
#else /* DOS */
    LYSendMailFile(address,
		   my_tmpfile,
		   subject,
		   ccaddr,
		   "");
    (void) LYRemoveTemp(my_tmpfile);
#endif /* USE_VMS_MAILER */
#endif /* CAN_PIPE_TO_MAILER */

    if (traversal) {
	FILE *ofp;

	if ((ofp = LYAppendToTxtFile(TRAVERSE_ERRORS)) == NULL) {
	    if ((ofp = LYNewTxtFile(TRAVERSE_ERRORS)) == NULL) {
		perror(NOOPEN_TRAV_ERR_FILE);
		exit_immediately(EXIT_FAILURE);
	    }
	}

	fprintf(ofp, "%s\t%s \tin %s\n",
		links[cur].lname, links[cur].target, filename);
	LYCloseOutput(ofp);
    }

    FREE(address);
    return;
}

/*
 *  reply_by_mail() invokes sendmail on Unix or mail on VMS to send
 *  a comment from the users to the owner
 */
void reply_by_mail(char *mail_address,
		   char *filename,
		   const char *title,
		   const char *refid)
{
    char user_input[LINESIZE];
    FILE *fd, *fp;
    const char *label = NULL;
    char *from_address = NULL;
    char *cc_address = NULL;
    char *to_address = NULL;
    char *the_subject = NULL;
    char *ccaddr = NULL;
    char *keywords = NULL;
    char *searchpart = NULL;
    char *body = NULL;
    char *cp = NULL, *cp1 = NULL;
    int i;
    int c = 0;			/* user input */
    char my_tmpfile[LY_MAXPATH];
    char default_subject[MAX_SUBJECT + 10];

#if USE_VMS_MAILER
    char *command = NULL;
    BOOLEAN isPMDF = LYMailPMDF();
    char hdrfile[LY_MAXPATH];
    FILE *hfd = 0;

#else
#if !CAN_PIPE_TO_MAILER
    char tmpfile2[LY_MAXPATH];
#endif
    char buf[4096];		/* 512 */
    char *header = NULL;
    size_t nbytes;
#endif /* USE_VMS_MAILER */

    CTRACE((tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	    NONNULL(mail_address),
	    NONNULL(filename),
	    NONNULL(title),
	    NONNULL(refid)));

    term_letter = FALSE;

    if (!LYSystemMail())
	return;

    if (isEmpty(mail_address)) {
	HTAlert(NO_ADDRESS_IN_MAILTO_URL);
	return;
    }
    StrAllocCopy(to_address, mail_address);

    if ((fd = LYOpenTemp(my_tmpfile, ".txt", "w")) == NULL) {
	HTAlert(MAILTO_URL_TEMPOPEN_FAILED);
	return;
    }
#if USE_VMS_MAILER
    if (isPMDF) {
	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
	    HTAlert(MAILTO_URL_TEMPOPEN_FAILED);
	    return;
	}
    }
#endif /* VMS */
    default_subject[0] = '\0';

    /*
     * Check for a ?searchpart.  - FM
     */
    if ((cp = StrChr(to_address, '?')) != NULL) {
	StrAllocCopy(searchpart, cp);
	*cp = '\0';
	cp = (searchpart + 1);
	if (*cp != '\0') {
	    /*
	     * Seek and handle a subject=foo.  - FM
	     */
	    extract_subject(default_subject, searchpart);

	    /*
	     * Seek and handle to=address(es) fields.  Appends to address.  -
	     * FM
	     */
	    extract_field(&to_address, searchpart, "to=");

	    /*
	     * Seek and handle cc=address(es) fields.  Excludes Bcc=address(es)
	     * as unsafe.  We may append our own cc (below) as a list for the
	     * actual mailing.  - FM
	     */
	    extract_field(&ccaddr, searchpart, "cc=");

	    /*
	     * Seek and handle keywords=term(s) fields.  - FM
	     */
	    extract_field(&keywords, searchpart, "keywords=");

	    if (keywords != NULL) {
		if (*keywords != '\0') {
		    SafeHTUnEscape(keywords);
		} else {
		    FREE(keywords);
		}
	    }

	    /*
	     * Seek and handle body=foo fields.  - FM
	     */
	    extract_body(&body, searchpart);

	    FREE(searchpart);
	}
    }

    if (convert_explorer(to_address)) {
	HTAlert(NO_ADDRESS_IN_MAILTO_URL);
	goto cancelled;
    }
    if (ccaddr != NULL) {
	if (convert_explorer(ccaddr)) {
	    FREE(ccaddr);
	}
    }

    /*
     * Unescape the address and ccaddr fields.  - FM
     */
    SafeHTUnEscape(to_address);
    if (ccaddr != NULL) {
	SafeHTUnEscape(ccaddr);
    }

    /*
     * Set the default subject.  - FM
     */
    if ((default_subject[0] == '\0') && non_empty(title)) {
	LYStrNCpy(default_subject, title, MAX_SUBJECT);
    }

    /*
     * Use ^G to cancel mailing of comment and don't let SIGINTs exit lynx.
     */
    signal(SIGINT, terminate_letter);

#if USE_VMS_MAILER
    if (isPMDF || !body) {
	/*
	 * Put the X-URL and X-Mailer lines in the hdrfile for PMDF or
	 * my_tmpfile for VMS MAIL.  - FM
	 */
	fprintf((isPMDF ? hfd : fd),
		"X-URL: %s%s\n",
		isEmpty(filename) ? STR_MAILTO_URL : filename,
		isEmpty(filename) ? to_address : "");
	fprintf((isPMDF ? hfd : fd),
		"X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);
#ifdef NO_ANONYMOUS_EMAIL
	if (!isPMDF) {
	    fprintf(fd, "\n");
	}
#endif /* NO_ANONYMOUS_EMAIL */
    }
#else /* Unix/DOS/Windows */
    /*
     * Put the To:  line in the header.
     */
#ifndef DOSPATH
    HTSprintf(&header, "To: %s\n", to_address);
#endif

    /*
     * Put the Mime-Version, Content-Type and Content-Transfer-Encoding in the
     * header.  This assumes that the same character set is used for composing
     * the mail which is currently selected as display character set...  Don't
     * send a charset if we have a CJK character set selected, since it may not
     * be appropriate for mail...  Also don't use an unofficial "x-" charset. 
     * Also if the charset would be "us-ascii" (7-bit replacements selected,
     * don't send any MIME headers.  - kw
     */
    if (strncasecomp(LYCharSet_UC[current_char_set].MIMEname,
		     "us-ascii", 8) != 0) {
	StrAllocCat(header, "Mime-Version: 1.0\n");
	if (!LYHaveCJKCharacterSet &&
	    strncasecomp(LYCharSet_UC[current_char_set].MIMEname, "x-", 2)
	    != 0) {
	    HTSprintf(&header, "Content-Type: text/plain; charset=%s\n",
		      LYCharSet_UC[current_char_set].MIMEname);
	}
	StrAllocCat(header, "Content-Transfer-Encoding: 8bit\n");
    }
    /*
     * Put the X-URL and X-Mailer lines in the header.
     */
    if (non_empty(filename)) {
	HTSprintf(&header, "X-URL: %s\n", filename);
    } else {
	HTSprintf(&header, "X-URL: mailto:%s\n", to_address);
    }
    HTSprintf(&header, "X-Mailer: %s, Version %s\n", LYNX_NAME, LYNX_VERSION);

    if (non_empty(refid)) {
	HTSprintf(&header, "In-Reply-To: <%s>\n", refid);
    }
#endif /* VMS */

    /*
     * Clear the screen and inform the user.
     */
    LYclear();
    LYmove(2, 0);
    scrollok(LYwin, TRUE);	/* Enable scrolling. */
    if (body)
	LYaddstr(SENDING_MESSAGE_WITH_BODY_TO);
    else
	LYaddstr(SENDING_COMMENT_TO);
    show_addresses(to_address);
    if (
#if USE_VMS_MAILER
	   (isPMDF == TRUE) &&
#endif /* VMS */
	   (cp = ccaddr) != NULL) {
	if (StrChr(cp, ',') != NULL) {
	    LYaddstr(WITH_COPIES_TO);
	} else {
	    LYaddstr(WITH_COPY_TO);
	}
	show_addresses(ccaddr);
    }
    LYaddstr(CTRL_G_TO_CANCEL_SEND);

#if USE_VMS_MAILER
    if (isPMDF || !body) {
#endif /* USE_VMS_MAILER */
#ifndef NO_ANONYMOUS_EMAIL
	/*
	 * Get the user's personal name.
	 */
	LYaddstr(ENTER_NAME_OR_BLANK);
#if USE_VMS_MAILER
	if (isPMDF) {
	    label = "Personal_name";
	} else {
	    label = "X-Personal_name";
	}
#else
	label = "X-Personal_Name";
#endif /* USE_VMS_MAILER */
	if (!header_prompt(label, &personal_mail_name, LINESIZE)) {
	    goto cancelled;
	}
	if (*personal_mail_name) {
#if USE_VMS_MAILER
	    fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_mail_name);
#else
	    HTSprintf(&header, "%s: %s\n", label, personal_mail_name);
#endif /* VMS */
	}

	/*
	 * Get the user's return address.
	 */
	LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
	LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
#if USE_VMS_MAILER
	if (isPMDF) {
	    label = "From";
	} else {
	    label = "X-From";
	}
#else
	label = "From";
#endif /* VMS */
	/* Add the personal mail address if there is one. */
	if (personal_mail_address)
	    StrAllocCopy(from_address, personal_mail_address);
	if (!header_prompt(label, &from_address, LINESIZE)) {
	    goto cancelled;
	}
#if USE_VMS_MAILER
	if (*from_address) {
	    fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
	}
	if (!isPMDF) {
	    fprintf(fd, "\n");
	}
#else
	HTSprintf(&header, "%s: %s\n", label, from_address);
#endif /* USE_VMS_MAILER */
#endif /* !NO_ANONYMOUS_EMAIL */
#if USE_VMS_MAILER
    }
#endif /* USE_VMS_MAILER */

    /*
     * Get the subject line.
     */
    LYaddstr(ENTER_SUBJECT_LINE);
    label = "Subject";
    if (*default_subject) {
	StrAllocCopy(the_subject, default_subject);
    } else if (non_empty(filename)) {
	HTSprintf(&the_subject, "%s", filename);
    } else {
	HTSprintf(&the_subject, "mailto:%s", to_address);
    }
    if (!header_prompt(label, &the_subject, MAX_SUBJECT)) {
	goto cancelled;
    }

    /*
     * Offer a CC line, if permitted.  - FM
     */
    if (!LYNoCc) {
	LYaddstr(ENTER_ADDRESS_FOR_CC);
	LYaddstr(BLANK_FOR_NO_COPY);
	if (personal_mail_address)
	    StrAllocCopy(cc_address, personal_mail_address);
	if (!header_prompt("Cc", &cc_address, LINESIZE)) {
	    goto cancelled;
	}
	comma_append(&ccaddr, cc_address);
    }
#if !USE_VMS_MAILER
    HTSprintf(&header, "%s: %s\n", label, the_subject);
#if !CAN_PIPE_TO_MAILER
    if (*to_address) {
	HTSprintf(&header, "To: %s\n", to_address);
    }
#endif

    /*
     * Add the Cc:  header.  - FM
     */
    if (non_empty(ccaddr)) {
	HTSprintf(&header, "Cc: %s\n", ccaddr);
    }

    /*
     * Add the Keywords:  header.  - FM
     */
    if (non_empty(keywords)) {
	HTSprintf(&header, "Keywords: %s\n", keywords);
    }

    /*
     * Terminate the header.
     */
    StrAllocCat(header, "\n");
    CTRACE((tfp, "**header==\n%s", header));
#endif /* !VMS */

    if (!no_editor && non_empty(editor)) {

	if (body) {
	    cp1 = body;
	    while ((cp = StrChr(cp1, '\n')) != NULL) {
		*cp++ = '\0';
		fprintf(fd, "%s\n", cp1);
		cp1 = cp;
	    }
	} else if (strcmp(HTLoadedDocumentURL(), "")) {
	    /*
	     * Ask if the user wants to include the original message.
	     */
	    BOOLEAN is_preparsed = (BOOL) (LYPreparsedSource &&
					   HTisDocumentSource());

	    if (HTConfirm(is_preparsed
			  ? INC_PREPARSED_MSG_PROMPT
			  : INC_ORIG_MSG_PROMPT) == YES) {
		print_wwwfile_to_fd(fd, TRUE, (BOOL) !is_preparsed);
	    }
	}
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(LYwin, FALSE);	/* Stop scrolling.    */

	if (term_letter || LYCharIsINTERRUPT(c))
	    goto cleanup;

	/*
	 * Spawn the users editor on the mail file
	 */
	edit_temporary_file(my_tmpfile, "", SPAWNING_EDITOR_FOR_MAIL);

    } else if (body) {
	/*
	 * Let user review the body.  - FM
	 */
	LYclear();
	LYmove(0, 0);
	LYaddstr(REVIEW_MESSAGE_BODY);
	LYrefresh();
	cp1 = body;
	i = (LYlines - 5);
	while ((cp = StrChr(cp1, '\n')) != NULL) {
	    if (i <= 0) {
		LYaddstr(RETURN_TO_CONTINUE);
		LYrefresh();
		c = LYgetch();
		LYaddstr("\n");
		if (term_letter || LYCharIsINTERRUPT(c)) {
		    goto cancelled;
		}
		i = (LYlines - 2);
	    }
	    *cp++ = '\0';
	    fprintf(fd, "%s\n", cp1);
	    LYaddstr(cp1);
	    LYaddstr("\n");
	    cp1 = cp;
	    i--;
	}
	while (i >= 0) {
	    LYaddstr("\n");
	    i--;
	}
	LYrefresh();
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */

    } else {
	/*
	 * Use the internal line editor for the message.
	 */
	LYaddstr(ENTER_MESSAGE_BELOW);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_A);
	LYaddstr(ENTER_PERIOD_WHEN_DONE_B);
	LYaddstr(CTRL_G_TO_CANCEL_SEND);
	LYaddstr("\n\n");
	LYrefresh();
	*user_input = '\0';
	if (LYGetStr(user_input, FALSE, sizeof(user_input), NORECALL) < 0 ||
	    term_letter || STREQ(user_input, ".")) {
	    goto cancelled;
	}

	while (!STREQ(user_input, ".") && !term_letter) {
	    LYaddstr("\n");
	    remove_tildes(user_input);
	    fprintf(fd, "%s\n", user_input);
	    *user_input = '\0';
	    if (LYGetStr(user_input, FALSE,
			 sizeof(user_input), NORECALL) < 0) {
		goto cancelled;
	    }
	}

	fprintf(fd, "\n");	/* Terminate the message. */
	LYCloseTempFP(fd);	/* Close the tmpfile.     */
	scrollok(LYwin, FALSE);	/* Stop scrolling.        */
    }

#if !USE_VMS_MAILER
    /*
     * Ignore CTRL-C on this last question.
     */
    signal(SIGINT, SIG_IGN);
#endif /* !VMS */
    LYStatusLine = (LYlines - 1);
    c = HTConfirm(body ? SEND_MESSAGE_PROMPT : SEND_COMMENT_PROMPT);
    LYStatusLine = -1;
    if (c != YES) {
	LYclear();		/* clear the screen */
	goto cleanup;
    }
    if ((body == NULL && LynxSigFile != NULL) &&
	(fp = fopen(LynxSigFile, TXT_R)) != NULL) {
	LYStatusLine = (LYlines - 1);
	if (term_letter) {
	    _user_message(APPEND_SIG_FILE, LynxSigFile);
	    c = 0;
	} else {
	    char *msg = NULL;

	    HTSprintf0(&msg, APPEND_SIG_FILE, LynxSigFile);
	    c = HTConfirm(msg);
	    FREE(msg);
	}
	LYStatusLine = -1;
	if (c == YES) {
	    if ((fd = fopen(my_tmpfile, TXT_A)) != NULL) {
		char *buffer = NULL;

		fputs("-- \n", fd);
		while (LYSafeGets(&buffer, fp) != NULL) {
		    fputs(buffer, fd);
		}
		LYCloseOutput(fd);
		FREE(buffer);
	    }
	}
	LYCloseInput(fp);
    }
    LYclear();			/* Clear the screen. */

    /*
     * Send the message.
     */
#if USE_VMS_MAILER
    /*
     * Set the mail command.  - FM
     */
    if (isPMDF) {
	/*
	 * For PMDF, put any keywords and the subject in the header file and
	 * close it.  - FM
	 */
	if (non_empty(keywords)) {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", the_subject);
	LYCloseTempFP(hfd);
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&command, "%s %s %s,%s ",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_tmpfile);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command, and
	 * ignore any keywords to minimize risk of them making the line too
	 * long or having problem characters.  - FM
	 */
	HTSprintf0(&command, "%s %s%s/subject=\"%s\" %s ",
		   system_mail,
		   system_mail_flags,
		   (strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		   the_subject,
		   my_tmpfile);
    }

    vms_append_addrs(&command, to_address, "");
    if (non_empty(ccaddr)) {
	vms_append_addrs(&command, ccaddr, "/CC");
    }

    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_COMMENT, command, PLEASE_WAIT);
    LYSystem(command);		/* SENDING COMMENT (VMS) */
    FREE(command);
    LYSleepAlert();
    start_curses();
#else /* Unix/DOS/Windows */
    /*
     * Send the tmpfile into sendmail.
     */
    _statusline(SENDING_YOUR_MSG);
#if CAN_PIPE_TO_MAILER
    signal(SIGINT, SIG_IGN);
    if ((fp = LYPipeToMailer()) == 0) {
	HTInfoMsg(CANCELLED);
    }
#else
    if ((fp = LYOpenTemp(tmpfile2, ".txt", "w")) == NULL) {
	HTAlert(MAILTO_URL_TEMPOPEN_FAILED);
    }
#endif /* CAN_PIPE_TO_MAILER */
    if (fp != 0) {
	fd = fopen(my_tmpfile, TXT_R);
	if (fd == NULL) {
	    HTInfoMsg(CANCELLED);
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);
#endif /* CAN_PIPE_TO_MAILER */
	} else {
#if USE_BLAT_MAILER
	    if (!mail_is_blat)
		fputs(header, fp);
#else
	    fputs(header, fp);
#endif
	    while ((nbytes = fread(buf, (size_t) 1, sizeof(buf), fd)) != 0) {
		if (fwrite(buf, (size_t) 1, (size_t) nbytes, fp) < nbytes)
		    break;
	    }
#if CAN_PIPE_TO_MAILER
	    pclose(fp);
#else
	    LYCloseTempFP(fp);	/* Close the tmpfile. */
	    LYSendMailFile(to_address,
			   tmpfile2,
			   the_subject,
			   ccaddr,
			   SENDING_COMMENT);
	    (void) LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
	    LYCloseInput(fd);	/* Close the tmpfile. */
	}
    }
#endif /* USE_VMS_MAILER */
    goto cleanup;

    /*
     * Come here to cleanup and exit.
     */
  cancelled:
    HTInfoMsg(CANCELLED);
    LYCloseTempFP(fd);		/* Close the tmpfile.   */
    scrollok(LYwin, FALSE);	/* Stop scrolling.      */
  cleanup:
    signal(SIGINT, cleanup_sig);
    term_letter = FALSE;

#if USE_VMS_MAILER
    while (LYRemoveTemp(my_tmpfile) == 0) ;	/* Delete the tmpfile(s). */
    if (isPMDF) {
	(void) LYRemoveTemp(hdrfile);	/* Delete the hdrfile. */
    }
#else
    FREE(header);
    (void) LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
#endif /* VMS */

    FREE(from_address);
    FREE(the_subject);
    FREE(cc_address);
    FREE(to_address);
    FREE(ccaddr);
    FREE(keywords);
    FREE(body);
    return;
}

/*
 * Check that we have configured values for system mailer.
 */
BOOLEAN LYSystemMail(void)
{
    if (system_mail == 0 || !strcmp(system_mail, "unknown")) {
	HTAlert(gettext("No system mailer configured"));
	return FALSE;
    }
    return TRUE;
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYMail.c,v 1.71 2009/01/03 00:39:50 tom Exp $
d97 1
a97 1
	    if ((cp1 = strchr(cp, '&')) != NULL) {
d111 1
a111 1
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, NONNULL(*dst)));
d133 1
a133 1
	if ((cp1 = strchr(cp, '&')) != NULL) {
d137 1
a137 2
	    strncpy(dst, cp, MAX_SUBJECT);
	    dst[MAX_SUBJECT] = '\0';
d164 1
a164 1
	    if ((cp1 = strchr(cp, '&')) != NULL) {
d175 1
a175 1
		while ((cp = strchr(cp0, '\n')) != NULL) {
d236 1
a236 1
    while ((cp1 = strchr(cp, '@@')) != NULL) {
d238 1
a238 1
	if ((cp0 = strchr(cp1, ';')) != NULL) {
d260 1
a260 1
	LYstrncpy(buffer, *result, sizeof(buffer) - 1);
d269 1
a269 1
    ok = (LYgetstr(buffer, VISIBLE, limit, NORECALL) >= 0
d286 1
a286 1
    while ((cp1 = strchr(cp, ',')) != NULL) {
d305 56
a360 1
syntax:
d363 11
a373 11
<filename>    : file with the message body
-t <recipient>: recipient list (comma separated)
-s <subj>     : subject line
-f <sender>   : overrides the default sender address (must be known to server)
-i <addr>     : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>: carbon copy recipient list (comma separated)
-b <recipient>: blind carbon copy recipient list (comma separated)
-h            : displays this help.
-mime         : MIME Quoted-Printable Content-Transfer-Encoding.
-q            : supresses *all* output.
-server <addr>: overrides the default SMTP server to be used.
d377 1
a377 2
static char *blat_cmd(char *mail_cmd,
		      char *filename,
d383 1
a383 1
    static char *b_cmd;
d385 2
a386 1
#ifdef USE_ALT_BLAT_MAILER
d388 10
a397 9
    HTSprintf0(&b_cmd, "%s %s -t \"%s\" -s \"%s\" %s%s%s%s",
	       mail_cmd,
	       filename,
	       address,
	       subject,
	       system_mail_flags,
	       ccaddr ? " -c \"" : "",
	       NonNull(ccaddr),
	       ccaddr ? "\"" : "");
d399 1
a399 1
#else /* !USE_ALT_BLAT_MAILER */
d401 3
a403 2
    static char bl_cmd_file[512];
    FILE *fp;
d406 1
a406 2
    char dosname[LY_MAXPATH];
#endif
a407 8
    bl_cmd_file[0] = '\0';
    if ((fp = LYOpenTemp(bl_cmd_file, ".blt", "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	return NULL;
    }
#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(filename, dosname);
    fprintf(fp, "%s\n", dosname);
d409 1
a409 1
    fprintf(fp, "%s\n", filename);
a410 10
    fprintf(fp, "-t\n%s\n", address);
    if (subject)
	fprintf(fp, "-s\n%s\n", subject);
    if (!isEmpty(mail_addr)) {
	fprintf(fp, "-f\n%s\n", mail_addr);
    }
    if (!isEmpty(ccaddr)) {
	fprintf(fp, "-c\n%s\n", ccaddr);
    }
    LYCloseOutput(fp);
d412 20
a431 6
#ifdef __CYGWIN__
    cygwin_conv_to_full_win32_path(bl_cmd_file, dosname);
    HTSprintf0(&b_cmd, "%s \"@@%s\"", mail_cmd, dosname);
#else
    HTSprintf0(&b_cmd, "%s @@%s", mail_cmd, bl_cmd_file);
#endif
d433 1
a433 1
#endif /* USE_ALT_BLAT_MAILER */
d460 1
a460 1
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
d488 1
a488 1
	if (strchr("\"&|", *string) != 0)
a520 4

#ifdef __DJGPP__
    char *shell;
#endif /* __DJGPP__ */
d527 7
a533 11
    if (mail_is_blat)
	StrAllocCopy(cmd,
		     blat_cmd(system_mail,
			      the_filename,
			      the_address,
			      the_subject,
			      the_ccaddr,
			      personal_mail_address
		     )
	    );
    else
d536 8
a543 7
    if ((shell = LYGetEnv("SHELL")) != NULL) {
	if (strstr(shell, "sh") != NULL) {
	    HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
d545 1
a545 5
	    HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
		       shell,
		       system_mail,
		       the_address,
		       the_filename);
d547 15
a561 5
    } else {
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
a562 6
#else
	HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
		   system_mail,
		   the_address,
		   the_filename);
#endif /* __DJGPP__ */
d598 1
a598 1
    int ch, len, i;
d625 1
a625 1
    if ((cp = (char *) strchr(mailto_address, '\n')) != NULL)
d632 1
a632 1
    if ((cp = strchr(address, '?')) != NULL) {
d694 2
a695 2
	if (!isEmpty(mailto_subject)) {
	    LYstrncpy(subject, mailto_subject, MAX_SUBJECT);
d701 1
a701 1
    if ((ch = LYgetstr(subject, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d716 1
a716 1
	if ((ch = LYgetstr(self, VISIBLE, MAX_SUBJECT, NORECALL)) < 0) {
d737 1
a737 1
    if (!isEmpty(mailto_type)) {
d742 1
a742 1
    if (!isEmpty(personal_mail_address))
d744 1
a744 1
    if (!isEmpty(ccaddr))
d747 1
a747 1
    if (!isEmpty(keywords))
d764 1
a764 1
	if (!isEmpty(mailto_type)) {
d767 1
a767 1
	    if (!isEmpty(personal_mail_address))
d774 1
a774 1
	if (!isEmpty(keywords)) {
d796 1
a796 1
	if (!isEmpty(mailto_type)) {
d801 1
a801 1
	if (!isEmpty(personal_mail_address))
d814 1
a814 1
    while ((cp = strchr(mailto_content, '\n')) != NULL) {
d819 1
a819 2
	    strncpy(buf, &mailto_content[i], 78);
	    buf[78] = '\0';
d830 1
a830 2
	strncpy(buf, &mailto_content[i], 78);
	buf[78] = '\0';
d874 1
a874 1
    if (!isEmpty(ccaddr)) {
d884 1
a884 1
    LYRemoveTemp(my_tmpfile);
d886 1
a886 1
	LYRemoveTemp(hdrfile);
d893 1
a893 1
    LYRemoveTemp(my_tmpfile);
d950 1
a950 1
    if ((cp = (char *) strchr(owner_address, '\n')) != NULL) {
d978 1
a978 1
	if ((cp = strchr(address, '?')) != NULL) {
d992 1
a992 1
	convert_explorer(address);
d1014 1
a1014 1
    if (!isEmpty(personal_mail_address)) {
d1037 1
a1037 1
	if (!isEmpty(personal_mail_address)) {
d1098 1
a1098 1
    LYRemoveTemp(my_tmpfile);
d1100 1
a1100 1
	LYRemoveTemp(hdrfile);
d1108 1
a1108 1
    LYRemoveTemp(my_tmpfile);
a1139 3
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
d1169 1
a1169 1
    int n;
d1206 1
a1206 1
    if ((cp = strchr(to_address, '?')) != NULL) {
d1272 2
a1273 3
    if ((default_subject[0] == '\0') && !isEmpty(title)) {
	strncpy(default_subject, title, MAX_SUBJECT);
	default_subject[MAX_SUBJECT] = '\0';
d1330 1
a1330 1
    if (!isEmpty(filename)) {
d1337 1
a1337 1
    if (!isEmpty(refid)) {
d1358 1
a1358 1
	if (strchr(cp, ',') != NULL) {
d1377 1
a1377 1
	    label = "Personal_name: ";
d1379 1
a1379 1
	    label = "X-Personal_name: ";
d1382 1
a1382 1
	label = "X-Personal_Name: ";
d1384 1
a1384 1
	if (!header_prompt(label, &personal_name, LINESIZE)) {
d1387 1
a1387 1
	if (*personal_name) {
d1389 1
a1389 1
	    fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1391 1
a1391 1
	    HTSprintf(&header, "%s: %s\n", label, personal_name);
d1437 1
a1437 1
    } else if (!isEmpty(filename)) {
d1470 1
a1470 1
    if (!isEmpty(ccaddr)) {
d1477 1
a1477 1
    if (!isEmpty(keywords)) {
d1488 1
a1488 1
    if (!no_editor && !isEmpty(editor)) {
d1492 1
a1492 1
	    while ((cp = strchr(cp1, '\n')) != NULL) {
d1531 1
a1531 1
	while ((cp = strchr(cp1, '\n')) != NULL) {
d1564 1
d1568 1
a1568 1
	if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
d1578 1
a1578 1
	    if (LYgetstr(user_input, VISIBLE,
d1644 1
a1644 1
	if (!isEmpty(keywords)) {
d1672 1
a1672 1
    if (!isEmpty(ccaddr)) {
d1713 3
a1715 2
	    while ((n = (int) fread(buf, 1, sizeof(buf), fd)) != 0) {
		fwrite(buf, 1, (size_t) n, fp);
d1726 1
a1726 1
	    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
d1748 1
a1748 1
	LYRemoveTemp(hdrfile);	/* Delete the hdrfile. */
d1752 1
a1752 1
    LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d89 1
a89 1
    int len = strlen(keyword);
d121 1
a121 1
    int len = strlen(keyword);
d156 1
a156 1
    int len = strlen(keyword);
d184 1
a184 1
		    len = strlen(cp0);
d188 1
a188 1
			len = strlen(&cp0[i]);
d194 1
a194 1
		len = strlen(cp0);
d198 1
a198 1
		    len = strlen(&cp0[i]);
d649 1
a649 1
    if (isEmpty(subject)) {
d773 1
a773 1
	len = strlen(mailto_content);
d779 1
a779 1
	    len = strlen(&mailto_content[i]);
d785 1
a785 1
    len = strlen(mailto_content);
d791 1
a791 1
	len = strlen(&mailto_content[i]);
d1233 1
a1233 1
    if (isEmpty(default_subject) && !isEmpty(title)) {
d1674 2
a1675 2
	    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0) {
		fwrite(buf, 1, n, fp);
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d13 1
a13 1
#include <LYCharSets.h>  /* to get current charset for mail header */
d19 1
a19 1
BOOLEAN term_letter;	/* Global variable for async i/o. */
d21 1
a21 1
PRIVATE void terminate_letter ARGS1(int,sig GCC_UNUSED)
d28 1
a28 1
     *	Refresh the screen to get rid of the "interrupt" message.
d38 1
a38 2
PRIVATE void SafeHTUnEscape ARGS1(
    char *,	string)
d40 2
a41 2
     int i;
     int flg = FALSE;
d43 2
a44 3
     HTUnEscape(string);
     for (i=0; string[i] != '\0'; i++)
     {
d47 3
a49 4
	if ((!LYIsASCII(string[i])) || !isprint(UCH(string[i])))
	{
	   string[i] = '?';
	   flg = TRUE;
d51 2
a52 2
     }
     if (flg)
d56 1
a56 1
PRIVATE void remove_tildes ARGS1(char *,string)
d58 3
a60 4
   /*
    *  Change the first character to
    *  a space if it is a '~'.
    */
d65 2
a66 3
PRIVATE void comma_append ARGS2(
    char **,	dst,
    char *,	src)
d82 3
a84 4
PRIVATE void extract_field ARGS3(
    char **,	dst,
    char *,	src,
    char *,	keyword)
d114 2
a115 3
PRIVATE void extract_subject ARGS2(
    char *,	dst,
    char *,	src)
d117 1
a117 1
    CONST char *keyword = "subject=";
d149 2
a150 3
PRIVATE void extract_body ARGS2(
    char **,	dst,
    char *,	src)
d152 1
a152 1
    CONST char *keyword = "body=";
d167 2
a168 2
		 *  Break up the value into lines with
		 *  a maximum length of 78. - FM
d173 1
a173 1
		while((cp = strchr(cp0, '\n')) != NULL) {
d218 1
a218 2
PRIVATE BOOLEAN trim_comma ARGS1(
    char *,	address)
d228 1
a228 2
PRIVATE BOOLEAN convert_explorer ARGS1(
    char *,	address)
d249 3
a251 4
PRIVATE int header_prompt ARGS3(
    char *,		label,
    char **,		result,
    unsigned,		limit)
d258 1
a258 1
	LYstrncpy(buffer, *result, sizeof(buffer)-1);
d268 1
a268 1
	&& !term_letter);
d279 1
a279 2
PRIVATE void show_addresses ARGS1(
    char *,	addresses)
d320 6
a325 7
PRIVATE char *blat_cmd(
	char *mail_cmd,
	char *filename,
	char *address,
	char *subject,
	char *ccaddr,
	char *mail_addr)
d332 8
a339 8
		mail_cmd,
		filename,
		address,
		subject,
		system_mail_flags,
		ccaddr? " -c \"" : "",
		NonNull(ccaddr),
		ccaddr? "\"" : "");
d345 1
a354 1

d387 1
a387 1
PUBLIC BOOLEAN LYMailPMDF(void)
d390 2
a391 2
	    ? !strncasecomp(system_mail, "PMDF SEND", 9)
	    : FALSE;
d397 1
a397 1
PRIVATE void vms_append_addrs (char **cmd, char *address, char *option)
d407 1
a407 1
	    address_ptr2 = (cp+1);
d414 3
a416 3
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
d431 1
a431 1
PRIVATE void remove_quotes (char * string)
d445 1
a445 1
PUBLIC FILE *LYPipeToMailer NOARGS
d458 1
a458 1
#else	/* DOS, Win32, etc. */
d460 5
a464 6
PUBLIC int LYSendMailFile ARGS5(
    char *,	the_address,
    char *,	the_filename,
    char *,	the_subject GCC_UNUSED,
    char *,	the_ccaddr GCC_UNUSED,
    char *,	message)
d467 1
d479 8
a486 9
		blat_cmd(
		    system_mail,
		    the_filename,
		    the_address,
		    the_subject,
		    the_ccaddr,
		    personal_mail_address
		)
	);
d490 7
a496 14
	if ((shell = LYGetEnv("SHELL")) != NULL) {
	    if (strstr(shell, "sh") != NULL) {
		HTSprintf0(&cmd, "%s -c %s -t \"%s\" -F %s",
			   shell,
			   system_mail,
			   the_address,
			   the_filename);
	    } else {
		HTSprintf0(&cmd, "%s /c %s -t \"%s\" -F %s",
			   shell,
			   system_mail,
			   the_address,
			   the_filename);
	    }
d498 2
a499 1
	    HTSprintf0(&cmd, "%s -t \"%s\" -F %s",
d504 6
d525 1
a525 1
    SetOutputMode( O_BINARY );
d535 6
a540 7
**  mailform() sends form content to the mailto address(es). - FM
*/
PUBLIC void mailform ARGS4(
    CONST char *,	mailto_address,
    CONST char *,	mailto_subject,
    CONST char *,	mailto_content,
    CONST char *,	mailto_type)
d552 1
d578 1
a578 1
    if ((cp = (char *)strchr(mailto_address,'\n')) != NULL)
d583 1
a583 1
     *	Check for a ?searchpart. - FM
d591 1
a591 1
	     *	Seek and handle a subject=foo. - FM
d596 2
a597 2
	     *	Seek and handle to=address(es) fields.
	     *	Appends to address. - FM
d602 3
a604 3
	     *	Seek and handle cc=address(es) fields.	Excludes
	     *	Bcc=address(es) as unsafe.  We may append our own
	     *	cc (below) as a list for the actual mailing. - FM
d609 1
a609 1
	     *	Seek and handle keywords=term(s) fields. - FM
d636 1
a636 1
     *	Unescape the address and ccaddr fields. - FM
d644 1
a644 1
     *	Allow user to edit the default Subject - FM
d663 1
a663 2
     *	Allow user to specify a self copy via a CC:
     *	entry, if permitted. - FM
a683 1

d703 1
a703 1
#else	/* e.g., VMS, DOS */
d711 1
d724 2
a725 2
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
d735 3
a737 3
	 *  Ugh!  There's no good way to include headers while
	 *  we're still using "generic" VMS MAIL, so we'll put
	 *  this in the body of the message. - FM
d741 1
a741 1
#else	/* !VMS (DOS) */
d753 1
a753 1
	fprintf(fd,"To: %s\n", address);
d755 2
a756 2
	    fprintf(fd,"From: %s\n", personal_mail_address);
	fprintf(fd,"Subject: %.70s\n\n", subject);
d762 4
a765 4
     *	Break up the content into lines with a maximum length of 78.
     *	If the ENCTYPE was text/plain, we have physical newlines and
     *	should take them into account.	Otherwise, the actual newline
     *	characters in the content are hex escaped. - FM
d767 1
a767 1
    while((cp = strchr(mailto_content, '\n')) != NULL) {
d779 1
a779 1
	mailto_content = (cp+1);
d800 1
a800 1
     *	Set the mail command. - FM
d804 1
a804 1
	 *  Now set up the command. - FM
d807 5
a811 5
		"%s %s %s,%s ",
		system_mail,
		system_mail_flags,
		hdrfile,
		my_tmpfile);
d814 3
a816 4
	 *  For "generic" VMS MAIL, include the subject in the
	 *  command, and ignore any keywords to minimize risk
	 *  of them making the line too long or having problem
	 *  characters. - FM
d819 6
a824 6
		"%s %s%s/subject=\"%s\" %s ",
		system_mail,
		system_mail_flags,
		(strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		subject,
		my_tmpfile);
d835 1
a835 1
    LYSystem(command);	/* Mail (VMS) */
d843 5
a847 6
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	SENDING_FORM_CONTENT);
d852 1
a852 1
cleanup:
d860 7
a866 8
**  mailmsg() sends a message to the owner of the file, if one is defined,
**  telling of errors (i.e., link not available).
*/
PUBLIC void mailmsg ARGS4(
	int,		cur,
	char *,		owner_address,
	char *,		filename,
	char *,		linkname)
d872 1
d887 3
a889 3
	NONNULL(owner_address),
	NONNULL(filename),
	NONNULL(linkname)));
d905 1
a905 1
    if ((cp = (char *)strchr(owner_address,'\n')) != NULL) {
d915 1
a915 1
	 *  Silently refuse sending bad link messages to lynx-dev.
d923 3
a925 3
     *  If we are using a fixed address given by ALERTMAIL, it is
     *  supposed to already be in usable form, without URL-isms like
     *  ?-searchpart and URL-escaping.  So skip some code. - kw
d931 1
a931 1
	 *	Check for a ?searchpart. - FM
d950 1
a950 1
	 *  Unescape the address field. - FM
a959 1

d985 1
d998 1
a998 2
	 *  For PMDF, put the subject in the
	 *  header file and close it. - FM
d1007 1
a1007 1
		links[cur].lname, links[cur].target);
d1029 1
a1029 1
	 *  Now set up the command. - FM
d1032 5
a1036 5
		"%s %s %s,%s ",
		system_mail,
		system_mail_flags,
		hdrfile,
		my_tmpfile);
d1039 1
a1039 2
	 *  For "generic" VMS MAIL, include the
	 *  subject in the command. - FM
d1042 5
a1046 5
		"%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		system_mail,
		system_mail_flags,
		filename,
		my_tmpfile);
d1050 1
a1050 1
    LYSystem(command);	/* VMS */
d1058 5
a1062 6
    LYSendMailFile (
	address,
	my_tmpfile,
	subject,
	ccaddr,
	"");
d1078 1
a1078 1
		     links[cur].lname, links[cur].target, filename);
d1087 7
a1093 8
**  reply_by_mail() invokes sendmail on Unix or mail on VMS to send
**  a comment from the users to the owner
*/
PUBLIC void reply_by_mail ARGS4(
	char *,		mail_address,
	char *,		filename,
	CONST char *,	title,
	CONST char *,	refid)
d1100 1
a1100 1
    char *label = NULL;
d1111 1
a1111 1
    int c = 0;	/* user input */
d1114 1
d1120 1
d1125 1
a1125 1
    char buf[4096];	/* 512 */
d1131 4
a1134 4
	NONNULL(mail_address),
	NONNULL(filename),
	NONNULL(title),
	NONNULL(refid)));
d1162 1
a1162 1
     *	Check for a ?searchpart. - FM
d1170 1
a1170 1
	     *	Seek and handle a subject=foo. - FM
d1175 2
a1176 2
	     *	Seek and handle to=address(es) fields.
	     *	Appends to address. - FM
d1181 3
a1183 3
	     *	Seek and handle cc=address(es) fields.	Excludes
	     *	Bcc=address(es) as unsafe.  We may append our own
	     *	cc (below) as a list for the actual mailing. - FM
d1188 1
a1188 1
	     *	Seek and handle keywords=term(s) fields. - FM
d1201 1
a1201 1
	     *	Seek and handle body=foo fields. - FM
d1220 1
a1220 1
     *	Unescape the address and ccaddr fields. - FM
d1228 1
a1228 1
     *	Set the default subject. - FM
d1236 1
a1236 2
     *	Use ^G to cancel mailing of comment
     *	and don't let SIGINTs exit lynx.
d1243 2
a1244 2
	 *  Put the X-URL and X-Mailer lines in the hdrfile
	 *  for PMDF or my_tmpfile for VMS MAIL. - FM
d1260 1
a1260 1
     *	Put the To: line in the header.
d1263 1
a1263 5
    asprintf(&header, "To: %s\n", to_address);
    if (!header) {
	fprintf(stderr, "Out of memory, you lose!\n");
	exit(1);
    }
d1267 7
a1273 10
     *	Put the Mime-Version, Content-Type and
     *	Content-Transfer-Encoding in the header.
     *	This assumes that the same character set is used
     *	for composing the mail which is currently selected
     *	as display character set...
     *	Don't send a charset if we have a CJK character set
     *	selected, since it may not be appropriate for mail...
     *	Also don't use an unofficial "x-" charset.
     *	Also if the charset would be "us-ascii" (7-bit replacements
     *	selected, don't send any MIME headers. - kw
d1282 1
a1282 1
		    LYCharSet_UC[current_char_set].MIMEname);
d1287 1
a1287 1
     *	Put the X-URL and X-Mailer lines in the header.
d1302 1
a1302 1
     *	Clear the screen and inform the user.
d1305 1
a1305 1
    LYmove(2,0);
d1314 1
a1314 1
	(isPMDF == TRUE) &&
d1316 1
a1316 2
	(cp = ccaddr) != NULL)
    {
d1330 4
a1333 4
    /*
     *	Get the user's personal name.
     */
    LYaddstr(ENTER_NAME_OR_BLANK);
d1335 5
a1339 5
    if (isPMDF) {
	label = "Personal_name: ";
    } else {
	label = "X-Personal_name: ";
    }
d1341 1
a1341 1
    label = "X-Personal_Name: ";
d1343 4
a1346 4
    if (!header_prompt(label, &personal_name, LINESIZE)) {
	goto cancelled;
    }
    if (*personal_name) {
d1348 1
a1348 1
	fprintf((isPMDF ? hfd : fd), "%s: %s\n", label, personal_name);
d1350 1
a1350 1
	HTSprintf(&header, "%s: %s\n", label, personal_name);
d1352 1
a1352 1
    }
d1354 5
a1358 5
    /*
     *	Get the user's return address.
     */
    LYaddstr(ENTER_MAIL_ADDRESS_OR_OTHER);
    LYaddstr(MEANS_TO_CONTACT_FOR_RESPONSE);
d1360 6
a1365 1
    if (isPMDF) {
a1366 5
    } else {
	label = "X-From";
    }
#else
    label = "From";
d1368 6
a1373 6
    /* Add the personal mail address if there is one. */
    if (personal_mail_address)
	StrAllocCopy(from_address, personal_mail_address);
    if (!header_prompt(label, &from_address, LINESIZE)) {
	goto cancelled;
    }
d1375 6
a1380 6
    if (*from_address) {
	fprintf(isPMDF ? hfd : fd, "%s: %s\n", label, from_address);
    }
    if (!isPMDF) {
	fprintf(fd, "\n");
    }
d1382 1
a1382 1
    HTSprintf(&header, "%s: %s\n", label, from_address);
d1390 1
a1390 1
     *	Get the subject line.
d1406 1
a1406 1
     *	Offer a CC line, if permitted. - FM
a1417 1

d1427 2
a1428 2
    **	Add the Cc: header. - FM
    */
d1434 2
a1435 2
    **	Add the Keywords: header. - FM
    */
d1441 1
a1441 1
     *	Terminate the header.
d1444 1
a1444 1
    CTRACE((tfp,"**header==\n%s",header));
d1451 1
a1451 1
	    while((cp = strchr(cp1, '\n')) != NULL) {
d1458 1
a1458 1
	     *	Ask if the user wants to include the original message.
d1461 2
a1462 1
				    HTisDocumentSource());
d1464 3
a1466 3
		? INC_PREPARSED_MSG_PROMPT
		: INC_ORIG_MSG_PROMPT) == YES) {
		print_wwwfile_to_fd(fd, (BOOL) !is_preparsed);
d1470 1
a1470 1
	scrollok(LYwin,FALSE);	/* Stop scrolling.    */
d1476 1
a1476 1
	 *  Spawn the users editor on the mail file
d1482 1
a1482 1
	 *  Let user review the body. - FM
d1485 1
a1485 1
	LYmove(0,0);
d1490 1
a1490 1
	while((cp = strchr(cp1, '\n')) != NULL) {
d1513 2
a1514 2
	LYCloseTempFP(fd);	/* Close the tmpfile.	  */
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1518 1
a1518 1
	 *  Use the internal line editor for the message.
d1543 2
a1544 2
	LYCloseTempFP(fd);	/* Close the tmpfile.	  */
	scrollok(LYwin,FALSE);	/* Stop scrolling.	  */
d1549 1
a1549 1
     *	Ignore CTRL-C on this last question.
d1554 1
a1554 1
    c = HTConfirm (body ? SEND_MESSAGE_PROMPT : SEND_COMMENT_PROMPT);
d1557 1
a1557 1
	LYclear();  /* clear the screen */
d1568 1
d1577 1
d1588 1
a1588 1
    LYclear();  /* Clear the screen. */
d1591 1
a1591 1
     *	Send the message.
d1595 1
a1595 1
     *	Set the mail command. - FM
d1599 2
a1600 2
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
d1608 1
a1608 1
	 *  Now set up the command. - FM
d1611 4
a1614 4
		system_mail,
		system_mail_flags,
		hdrfile,
		my_tmpfile);
d1617 3
a1619 4
	 *  For "generic" VMS MAIL, include the subject in the
	 *  command, and ignore any keywords to minimize risk
	 *  of them making the line too long or having problem
	 *  characters. - FM
d1622 5
a1626 5
		system_mail,
		system_mail_flags,
		(strncasecomp(system_mail, "MAIL", 4) ? "" : "/noself"),
		the_subject,
		my_tmpfile);
d1636 1
a1636 1
    LYSystem(command);	/* SENDING COMMENT (VMS) */
d1642 1
a1642 1
     *	Send the tmpfile into sendmail.
d1678 5
a1682 6
	    LYSendMailFile (
		to_address,
		tmpfile2,
		the_subject,
		ccaddr,
		SENDING_COMMENT);
d1685 1
a1685 1
	    LYCloseInput(fd); /* Close the tmpfile. */
d1692 1
a1692 1
     *	Come here to cleanup and exit.
d1694 1
a1694 1
cancelled:
d1696 3
a1698 3
    LYCloseTempFP(fd);		/* Close the tmpfile.	*/
    scrollok(LYwin,FALSE);	/* Stop scrolling.	*/
cleanup:
d1703 1
a1703 2
    while (LYRemoveTemp(my_tmpfile) == 0)
	;		 /* Delete the tmpfile(s). */
d1705 1
a1705 1
	LYRemoveTemp(hdrfile); /* Delete the hdrfile. */
d1709 1
a1709 1
    LYRemoveTemp(my_tmpfile);  /* Delete the tmpfile. */
d1725 1
a1725 1
PUBLIC BOOLEAN LYSystemMail NOARGS
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a17 2
#define EMPTY(s) ((s) == 0 || *(s) == 0)
#define NIL_OK(s) (((s) != 0) ? (s) : "<nil>")
d26 1
a26 1
#if USE_VMS_MAILER || defined(DOSPATH) || defined(WIN_EX)
d77 1
a77 1
	    if (EMPTY(*dst)) {
d114 1
a114 1
    CTRACE((tfp, "extract_field(%s) = '%s'\n", keyword, NIL_OK(*dst)));
d150 1
a150 1
    CTRACE((tfp, "extract_subject(%s) = '%s'\n", keyword, NIL_OK(dst)));
d220 1
a220 1
    CTRACE((tfp, "extract_body(%s) = '%s'\n", keyword, NIL_OK(*dst)));
d351 1
a351 1
		ccaddr? ccaddr : "",
d377 1
a377 1
    if (!EMPTY(mail_addr)) {
d380 1
a380 1
    if (!EMPTY(ccaddr)) {
d402 3
a404 1
    return !strncasecomp(system_mail, "PMDF SEND", 9);
d461 1
a461 1
    FILE *fp;
d463 6
a468 4
    HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
    fp = popen(buffer, "w");
    CTRACE((tfp, "popen(%s) %s\n", buffer, fp != 0 ? "OK" : "FAIL"));
    FREE(buffer);
d481 3
d486 3
d503 22
d529 1
d552 4
a555 4
    CONST char *, 	mailto_address,
    CONST char *, 	mailto_subject,
    CONST char *, 	mailto_content,
    CONST char *, 	mailto_type)
d577 7
a583 5
    CTRACE((tfp, "mailform(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	NIL_OK(mailto_address),
	NIL_OK(mailto_subject),
	NIL_OK(mailto_content),
	NIL_OK(mailto_type)));
d660 2
a661 2
    if (EMPTY(subject)) {
	if (!EMPTY(mailto_subject)) {
d682 1
a682 1
		EMPTY(personal_mail_address) ? "" : personal_mail_address);
d706 1
a706 1
    if (!EMPTY(mailto_type)) {
d711 1
a711 1
    if (!EMPTY(personal_mail_address))
d713 1
a713 1
    if (!EMPTY(ccaddr))
d716 1
a716 1
    if (!EMPTY(keywords))
d719 1
a719 1
#else	/* e.g., VMS, DOSPATH */
d732 1
a732 1
	if (!EMPTY(mailto_type)) {
d735 1
a735 1
	    if (!EMPTY(personal_mail_address))
d742 1
a742 1
	if (!EMPTY(keywords)) {
d764 1
a764 1
	if (!EMPTY(mailto_type)) {
d769 1
a769 1
	if (!EMPTY(personal_mail_address))
d845 1
a845 1
    if (!EMPTY(ccaddr)) {
d858 1
a858 1
#else /* DOSPATH */
d882 3
a884 3
	char *, 	owner_address,
	char *, 	filename,
	char *, 	linkname)
d904 3
a906 3
	NIL_OK(owner_address),
	NIL_OK(filename),
	NIL_OK(linkname)));
d910 3
d920 1
a920 1
    if (owner_address == NULL || *owner_address == '\0') {
a921 1
    }
d987 1
a987 1
    if (!EMPTY(personal_mail_address)) {
d1009 1
a1009 1
	if (!EMPTY(personal_mail_address)) {
d1026 1
a1026 1
    fprintf(fd, gettext("called \"%s\"\n"), links[cur].hightext);
d1076 1
a1076 1
#else /* DOSPATH */
d1111 2
a1112 2
	char *, 	mail_address,
	char *, 	filename,
a1133 1
    char *command = NULL;
d1136 1
d1150 4
a1153 4
	NIL_OK(mail_address),
	NIL_OK(filename),
	NIL_OK(title),
	NIL_OK(refid)));
d1157 4
a1160 1
    if (EMPTY(mail_address)) {
d1249 1
a1249 1
    if (EMPTY(default_subject) && !EMPTY(title)) {
d1268 2
a1269 2
		EMPTY(filename) ? "mailto:" : filename,
		EMPTY(filename) ? to_address : "");
d1283 5
a1287 1
    HTSprintf(&header, "To: %s\n", to_address);
d1316 1
a1316 1
    if (!EMPTY(filename)) {
d1323 1
a1323 1
    if (!EMPTY(refid)) {
d1424 1
a1424 1
    } else if (!EMPTY(filename)) {
d1458 1
a1458 1
    if (!EMPTY(ccaddr)) {
d1465 1
a1465 1
    if (!EMPTY(keywords)) {
d1476 1
a1476 1
    if (!no_editor && !EMPTY(editor)) {
d1492 1
a1492 1
	    	? INC_PREPARSED_MSG_PROMPT
d1628 1
a1628 1
	if (!EMPTY(keywords)) {
d1657 1
a1657 1
    if (!EMPTY(ccaddr)) {
a1676 1
    FREE(command);
d1725 1
a1725 1
    scrollok(LYwin,FALSE); 	/* Stop scrolling.	*/
a1730 1
    FREE(command);
d1749 12
@


1.3
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a0 10
/*
 * This file checked for sprintf() buffer overruns on 1998/05/06 by Bela
 * Lubkin <filbo@@armory.com>.  Please don't introduce any new ones...
 *
 * See comments marked "- BL" for two still-possible overruns in the VMS
 * code.
 *
 * Not yet checked for any other sort of buffer overrun.
 */

d12 1
d17 4
d22 16
a37 2
PRIVATE void terminate_letter  PARAMS((int sig));
PRIVATE void remove_tildes PARAMS((char *string));
d41 1
a41 1
	char *,	string)
d51 1
a51 1
	if ((!LYIsASCII(string[i])) || !isprint(string[i]))
d61 456
d521 4
a524 4
	CONST char *, 	mailto_address,
	CONST char *, 	mailto_subject,
	CONST char *, 	mailto_content,
	CONST char *, 	mailto_type)
d530 3
d534 9
a542 6
    char *cp = NULL, *cp0 = NULL, *cp1 = NULL;
    char subject[80];
    char self[80];
    char cmd[512];
    int len, i, ch;
#if defined(VMS) || defined(DOSPATH)
a543 4
    char *command = NULL;
#ifdef VMS
    char *address_ptr1, *address_ptr2;
    BOOLEAN first = TRUE;
a544 3
    BOOLEAN isPMDF = FALSE;
    char hdrfile[LY_MAXPATH];
    FILE *hfd;
d546 5
a550 4
    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
    }
#endif /* VMS */
d574 1
a574 20
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "subject=", 8))
		    break;
		cp++;
	    }
	    if (*cp) {
		cp += 8;
		if ((cp1 = strchr(cp, '&')) != NULL) {
		    *cp1 = '\0';
		}
		if (*cp) {
		    SafeHTUnEscape(subject);
		    LYstrncpy(subject, cp, 70);
		}
		if (cp1) {
		    *cp1 = '&';
		    cp1 = NULL;
		}
	    }
d580 1
a580 26
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "to=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (*address) {
			    StrAllocCat(address, ",");
			}
			StrAllocCat(address, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d587 1
a587 28
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "cc=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (ccaddr == NULL) {
			    StrAllocCopy(ccaddr, cp);
			} else {
			    StrAllocCat(ccaddr, ",");
			    StrAllocCat(ccaddr, cp);
			}
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d592 2
a593 28
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "keywords=", 9)) {
		    cp += 9;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (keywords == NULL) {
			    StrAllocCopy(keywords, cp);
			} else {
			    StrAllocCat(keywords, cp);
			    StrAllocCat(keywords, ", ");
			}
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d606 1
a606 19
    /*
     * Convert any Explorer semi-colon Internet address
     * separators to commas. - FM
     */
    cp = address;
    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    if (*address == '\0') {
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
d608 1
a608 1
	return;
d611 1
a611 13
	cp = ccaddr;
	while ((cp1 = strchr(cp, '@@')) != NULL) {
	    cp1++;
	    if ((cp0 = strchr(cp1, ';')) != NULL) {
		*cp0 = ',';
		cp1 = cp0 + 1;
	    }
	    cp = cp1;
	}
	if (ccaddr[(strlen(ccaddr) - 1)] == ',') {
	    ccaddr[(strlen(ccaddr) - 1)] = '\0';
	}
	if (*ccaddr == '\0') {
d627 3
a629 3
    if (subject[0] == '\0') {
	if (mailto_subject && *mailto_subject) {
	    LYstrncpy(subject, mailto_subject, 70);
d631 1
a631 2
	    strcpy(subject, "mailto:");
	    LYstrncpy((char*)&subject[7], address, 63);
d635 1
a635 1
    if ((ch = LYgetstr(subject, VISIBLE, 71, NORECALL)) < 0) {
d640 1
a640 4
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	return;
d648 2
a649 3
	sprintf(self, "%.79s", (personal_mail_address ?
				personal_mail_address : ""));
	self[79] = '\0';
d651 1
a651 1
	if ((ch = LYgetstr(self, VISIBLE, sizeof(self), NORECALL)) < 0) {
d656 1
a656 4
	    FREE(address);
	    FREE(ccaddr);
	    FREE(keywords);
	    return;
d667 20
a686 1
#if defined(VMS) || defined(DOSPATH)
d689 1
a689 4
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	return;
d691 1
d693 1
d697 1
a697 4
	    FREE(address);
	    FREE(ccaddr);
	    FREE(keywords);
	    return;
d699 1
a699 4
    }
#ifdef VMS
    if (isPMDF) {
	if (mailto_type && *mailto_type) {
d702 1
a702 1
	    if (personal_mail_address && *personal_mail_address)
d704 10
a713 1
	    }
d723 6
a728 10
#else
    if (mailto_type && *mailto_type) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
    }
    fprintf(fd,"To: %s\n", address);
    if (personal_mail_address && *personal_mail_address)
	fprintf(fd,"From: %s\n", personal_mail_address);
    remove_tildes(self);
    fprintf(fd,"Subject: %.70s\n\n", subject);
d730 9
a738 14

#else
    sprintf(cmd, "%s %s", system_mail, system_mail_flags);
    if ((fd = popen(cmd, "w")) == NULL) {
	HTAlert(FORM_MAILTO_FAILED);
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	return;
    }

    if (mailto_type && *mailto_type) {
	fprintf(fd, "Mime-Version: 1.0\n");
	fprintf(fd, "Content-Type: %s\n", mailto_type);
a739 9
    fprintf(fd, "To: %s\n", address);
    if (personal_mail_address && *personal_mail_address)
	fprintf(fd, "From: %s\n", personal_mail_address);
    if (ccaddr != NULL && *ccaddr != '\0')
	fprintf(fd, "Cc: %s\n", ccaddr);
    fprintf(fd, "Subject: %s\n\n", subject);
    if (keywords != NULL && *keywords != '\0')
	fprintf(fd, "Keywords: %s\n", keywords);
    _statusline(SENDING_FORM_CONTENT);
d741 1
d754 3
a756 3
	    strncpy(cmd, &mailto_content[i], 78);
	    cmd[78] = '\0';
	    fprintf(fd, "%s\n", cmd);
d766 3
a768 3
	strncpy(cmd, &mailto_content[i], 78);
	cmd[78] = '\0';
	fprintf(fd, "%s\n", cmd);
d775 1
a775 1
#ifdef UNIX
d777 2
a778 3
    sleep(MessageSecs);
#endif /* UNIX */
#if defined(VMS) || defined(DOSPATH)
d780 1
a780 1
#ifdef VMS
a785 9
	 *  For PMDF, put any keywords and the subject
	 *  in the header file and close it. - FM
	 */
	if (keywords != NULL && *keywords != '\0') {
	    fprintf(hfd, "Keywords: %s\n", keywords);
	}
	fprintf(hfd, "Subject: %s\n\n", subject);
	LYCloseTempFP(hfd);
	/*
d788 1
a788 1
	sprintf(cmd,
a799 2
	 *
	 *  Possibly still a problem if user supplies long subject. - BL
d801 1
a801 1
	sprintf(cmd,
d811 3
a813 64
    /*
     *	Now add all the people in the address field. - FM
     */
    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 *
	 *  ignore addresses so long that they would overflow the
	 *  temporary buffer (i.e., about 500 chars). - BL
	 */
	if (strlen(address_ptr1) > 3 &&
	    strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
	    if (!first) {
		StrAllocCat(command, ",");
	    }
	    sprintf(cmd, mail_adrs, address_ptr1);
	    StrAllocCat(command, cmd);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);

    /*
     *	Now add all the people in the CC field. - FM
     */
    if (ccaddr != NULL && *ccaddr != '\0') {
	address_ptr1 = ccaddr;
	do {
	    if ((cp = strchr(address_ptr1, ',')) != NULL) {
		address_ptr2 = (cp+1);
		*cp = '\0';
	    } else {
		address_ptr2 = NULL;
	    }

	    /*
	     *	4 letters is arbitrarily the smallest possible mail
	     *	address, at least for lynx.  That way extra spaces
	     *	won't confuse the mailer and give a blank address.
	     *
	     *  ignore addresses so long that they would overflow the
	     *  temporary buffer (i.e., about 500 chars). - BL
	     */
	    if (strlen(address_ptr1) > 3 &&
		strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
		StrAllocCat(command, ",");
		sprintf(cmd, mail_adrs, address_ptr1);
		if (isPMDF) {
		    strcat(cmd, "/CC");
		}
		StrAllocCat(command, cmd);
	    }
	    address_ptr1 = address_ptr2;
	} while (address_ptr1 != NULL);
d818 1
a818 1
    LYSystem(command);
d820 1
a820 1
    sleep(AlertSecs);
d823 2
a824 1
    LYRemoveTemp(hdrfile);
d826 6
a831 11
    StrAllocCopy(command, system_mail);
    StrAllocCat(command, " -t \"");
    StrAllocCat(command, address);
    StrAllocCat(command, "\" -F ");
    StrAllocCat(command, my_tmpfile);
    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_FORM_CONTENT, command, PLEASE_WAIT);
    LYSystem(command);
    FREE(command);
    sleep(MessageSecs);
    start_curses();
d833 2
a834 2
#endif
#endif /* VMS */
d836 1
d856 7
a862 2
    char *cmd = NULL, *cp, *cp0, *cp1;
#if defined(VMS) || defined(DOSPATH)
a863 4
    char *command = NULL;
#ifdef VMS
    char *address_ptr1, *address_ptr2;
    BOOLEAN first = TRUE;
d865 2
a866 1
    BOOLEAN isPMDF = FALSE;
d868 1
a868 1
    FILE *hfd;
d870 4
a873 4
    CTRACE(tfp, "mailmsg(%d, \"%s\", \"%s\", \"%s\")\n", cur,
	owner_address?owner_address:"<nil>",
	filename?filename:"<nil>",
	linkname?linkname:"<nil>");
d875 6
a880 2
    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
d882 1
a882 1
#endif /* VMS */
d887 5
a891 1
    if ((cp = (char *)strchr(owner_address,'\n')) != NULL)
d893 8
d903 1
d905 3
a907 1
     *	Check for a ?searchpart. - FM
d909 9
a917 10
    if ((cp = strchr(address, '?')) != NULL) {
	StrAllocCopy(searchpart, cp);
	*cp = '\0';
	cp = (searchpart + 1);
	if (*cp != '\0') {
	    /*
	     *	Seek and handle to=address(es) fields.
	     *	Appends to address.  We ignore any other
	     *	headers in the ?searchpart. - FM
	     */
d919 7
a925 24
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "to=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (*address) {
			    StrAllocCat(address, ",");
			}
			StrAllocCat(address, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
a927 1
    }
d929 6
a934 12
    /*
     *	Convert any Explorer semi-colon Internet address
     *	separators to commas. - FM
     */
    cp = address;
    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
d937 1
a937 7
    /*
     *	Unescape the address field. - FM
     */
    SafeHTUnEscape(address);
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    if (*address == '\0') {
d939 1
a939 2
	CTRACE(tfp, "mailmsg: No address in '%s'.\n",
		    owner_address);
d943 2
a944 3
#ifdef UNIX
    HTSprintf0(&cmd, "%s %s", system_mail, system_mail_flags);
    if ((fd = popen(cmd, "w")) == NULL) {
d946 1
a946 2
	CTRACE(tfp, "mailmsg: '%s' failed.\n",
		    cmd);
d952 1
a952 1
    if (personal_mail_address != NULL && *personal_mail_address != '\0') {
d956 2
a957 3
    fprintf(fd, "X-Mailer: Lynx, Version %s\n\n", LYNX_VERSION);
#endif /* UNIX */
#if defined(VMS) || defined(DOSPATH)
d959 1
a959 2
	CTRACE(tfp, "mailmsg: Could not fopen '%s'.\n",
		    my_tmpfile);
d963 3
d967 1
d969 1
a969 2
	    CTRACE(tfp, "mailmsg: Could not fopen '%s'.\n",
			hdrfile);
d974 1
a974 1
	if (personal_mail_address != NULL && *personal_mail_address != '\0') {
d978 7
a984 1
	fprintf(fd, "X-Mailer: Lynx, Version %s\n\n", LYNX_VERSION);
d986 2
a987 1
#endif /* VMS */
d997 1
a997 1
    fprintf(fd, gettext("Lynx ver. %s"), LYNX_VERSION);
d999 1
a999 1
	(fp = fopen(LynxSigFile, "r")) != NULL) {
d1003 1
a1003 1
	fclose(fp);
d1005 1
a1005 1
#ifdef UNIX
d1007 1
a1007 2
#endif /* UNIX */
#if defined(VMS) || defined(DOSPATH)
d1009 1
a1009 1
#ifdef VMS
a1011 6
	 *  For PMDF, put the subject in the
	 *  header file and close it. - FM
	 */
	fprintf(hfd, "Subject: Lynx Error in %.56s\n\n", filename);
	LYCloseTempFP(hfd);
	/*
d1025 8
a1032 31
	HTSprintf0(&command,
		"%s %s/self/subject=\"Lynx Error in %.56s\" %s ",
		system_mail,
		system_mail_flags,
		filename,
		my_tmpfile);
    }
    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else
	    address_ptr2 = NULL;

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 *
	 *  ignore addresses so long that they would overflow the
	 *  temporary buffer (i.e., about 500 chars). - BL
	 */
	if (!first) {
	    StrAllocCat(command, ",");
	}
	HTSprintf0(&cmd, mail_adrs, address_ptr1);
	StrAllocCat(command, cmd);
	first = FALSE;
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);
d1034 1
a1034 1
    LYSystem(command);
d1042 6
a1047 7
    StrAllocCopy(command, system_mail);
    StrAllocCat(command, " -t \"");
    StrAllocCat(command, address);
    StrAllocCat(command, "\" -F ");
    StrAllocCat(command, my_tmpfile);
    LYSystem(command);
    FREE(command);
d1049 2
a1050 2
#endif
#endif /* VMS */
d1058 1
a1058 1
		exit_immediately(-1);
d1064 1
a1064 1
	fclose(ofp);
d1073 1
a1073 1
**  a comment  from the users to the owner
d1081 4
a1084 1
    char user_input[1000];
d1086 5
a1090 1
    char *address = NULL;
d1095 2
a1096 3
    char *cp = NULL, *cp0 = NULL, *cp1 = NULL;
    char *temp = NULL;
    int i, len;
d1098 1
a1098 5
    char my_tmpfile[LY_MAXPATH], cmd[512];
#ifdef DOSPATH
    char tmpfile2[LY_MAXPATH];
#endif
#if defined(DOSPATH) || defined(VMS)
d1100 3
a1102 9
#endif
#ifndef NO_ANONYMOUS_EMAIL
    static char *personal_name = NULL;
#endif
    char subject[80];
#ifdef VMS
    char *address_ptr1 = NULL, *address_ptr2 = NULL;
    BOOLEAN first = TRUE;
    BOOLEAN isPMDF = FALSE;
d1104 1
a1104 5
    FILE *hfd;

    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
    }
d1106 4
a1109 1
    char buf[512];
d1112 1
a1112 1
#endif /* VMS */
d1114 5
a1118 5
    CTRACE(tfp, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",
	mail_address?mail_address:"<nil>",
	filename?filename:"<nil>",
	title?title:"<nil>",
	refid?refid:"<nil>");
d1122 1
a1122 3
    if (mail_address && *mail_address) {
	StrAllocCopy(address, mail_address);
    } else {
d1126 1
d1132 1
a1132 1
#ifdef VMS
d1140 1
a1140 1
    subject[0] = '\0';
d1145 1
a1145 1
    if ((cp = strchr(address, '?')) != NULL) {
d1153 1
a1153 21
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "subject=", 8))
		    break;
		cp++;
	    }
	    if (*cp) {
		cp += 8;
		if ((cp1 = strchr(cp, '&')) != NULL) {
		    *cp1 = '\0';
		}
		if (*cp) {
		    strncpy(subject, cp, 70);
		    subject[70] = '\0';
		    SafeHTUnEscape(subject);
		}
		if (cp1) {
		    *cp1 = '&';
		    cp1 = NULL;
		}
	    }
d1159 1
a1159 26
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "to=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (*address) {
			    StrAllocCat(address, ",");
			}
			StrAllocCat(address, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1166 1
a1166 28
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "cc=", 3)) {
		    cp += 3;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (ccaddr == NULL) {
			    StrAllocCopy(ccaddr, cp);
			} else {
			    StrAllocCat(ccaddr, ",");
			    StrAllocCat(ccaddr, cp);
			}
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1171 2
a1172 29
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "keywords=", 9)) {
		    cp += 9;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    while (*cp == ',' || isspace((unsigned char)*cp))
			cp++;
		    if (*cp) {
			if (keywords == NULL) {
			    StrAllocCopy(keywords, cp);
			} else {
			    StrAllocCat(keywords, cp);
			    StrAllocCat(keywords, ", ");
			}
			StrAllocCat(keywords, cp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1184 1
a1184 63
	    cp = (searchpart + 1);
	    while (*cp != '\0') {
		if ((*(cp - 1) == '?' || *(cp - 1) == '&') &&
		    !strncasecomp(cp, "body=", 5)) {
		    cp += 5;
		    if ((cp1 = strchr(cp, '&')) != NULL) {
			*cp1 = '\0';
		    }
		    if (*cp) {
			/*
			 *  Break up the value into lines with
			 *  a maximum length of 78. - FM
			 */
			StrAllocCopy(temp, cp);
			HTUnEscape(temp);
			cp0 = temp;
			while((cp = strchr(cp0, '\n')) != NULL) {
			    *cp = '\0';
			    if (cp > cp0) {
				if (*(cp - 1) == '\r') {
				    *(cp - 1) = '\0';
				}
			    }
			    i = 0;
			    len = strlen(cp0);
			    while (len > 78) {
				strncpy(cmd, (char *)&cp0[i], 78);
				cmd[78] = '\0';
				strcat(cmd, "\n");
				StrAllocCat(body, cmd);
				i += 78;
				len = strlen((char *)&cp0[i]);
			    }
			    sprintf(cmd, "%s\n", (char *)&cp0[i]);
			    StrAllocCat(body, cmd);
			    cp0 = (cp + 1);
			}
			i = 0;
			len = strlen(cp0);
			while (len > 78) {
			    strncpy(cmd, (char *)&cp0[i], 78);
			    cmd[78] = '\0';
			    strcat(cmd, "\n");
			    StrAllocCat(body, cmd);
			    i += 78;
			    len = strlen((char *)&cp0[i]);
			}
			if (len) {
			    sprintf(cmd, "%s\n", (char *)&cp0[i]);
			    StrAllocCat(body, cmd);
			}
			FREE(temp);
		    }
		    if (cp1) {
			*cp1 = '&';
			cp = cp1;
			cp1 = NULL;
		    } else {
			break;
		    }
		}
		cp++;
	    }
d1190 1
a1190 22
    /*
     *	Convert any Explorer semi-colon Internet address
     *	separators to commas. - FM
     */
    cp = address;
    while ((cp1 = strchr(cp, '@@')) != NULL) {
	cp1++;
	if ((cp0 = strchr(cp1, ';')) != NULL) {
	    *cp0 = ',';
	    cp1 = cp0 + 1;
	}
	cp = cp1;
    }
    if (address[(strlen(address) - 1)] == ',')
	address[(strlen(address) - 1)] = '\0';
    if (*address == '\0') {
	FREE(address);
	FREE(ccaddr);
	FREE(keywords);
	FREE(body);
	LYCloseTempFP(fd);		/* Close the tmpfile.  */
	LYRemoveTemp(my_tmpfile);	/* Delete the tmpfile. */
d1192 1
a1192 1
	return;
d1195 1
a1195 13
	cp = ccaddr;
	while ((cp1 = strchr(cp, '@@')) != NULL) {
	    cp1++;
	    if ((cp0 = strchr(cp1, ';')) != NULL) {
		*cp0 = ',';
		cp1 = cp0 + 1;
	    }
	    cp = cp1;
	}
	if (ccaddr[(strlen(ccaddr) - 1)] == ',') {
	    ccaddr[(strlen(ccaddr) - 1)] = '\0';
	}
	if (*ccaddr == '\0') {
d1203 1
a1203 1
    SafeHTUnEscape(address);
d1211 3
a1213 3
    if (subject[0] == '\0' && title && *title) {
	strncpy(subject, title, 70);
	subject[70] = '\0';
d1222 1
a1222 2

#ifdef VMS
d1230 2
a1231 2
		(filename && *filename) ? filename : "mailto:",
		(filename && *filename) ? "" : address);
d1233 2
a1234 2
		"X-Mailer: Lynx, Version %s\n",LYNX_VERSION);
#ifdef NO_ANONYMOUS_MAIL
d1238 1
a1238 1
#endif /* NO_ANONYMOUS_MAIL */
d1240 1
a1240 1
#else /* Unix: */
d1245 1
a1245 3
    StrAllocCopy(header, "To: ");
    StrAllocCat(header, address);
    StrAllocCat(header, "\n");
d1266 1
a1266 1
	    sprintf(buf,"Content-Type: text/plain; charset=%s\n",
a1267 1
	    StrAllocCat(header, buf);
d1274 4
a1277 7
    StrAllocCat(header, "X-URL: ");
    if (filename && *filename) {
	StrAllocCat(header, filename);
    }
    else {
	StrAllocCat(header, "mailto:");
	StrAllocCat(header, address);
d1279 1
a1279 3
    StrAllocCat(header, "\n");
    sprintf(buf, "X-Mailer: Lynx, Version %s\n", LYNX_VERSION);
    StrAllocCat(header, buf);
d1281 2
a1282 4
    if (refid && *refid) {
	StrAllocCat(header, "In-Reply-To: <");
	StrAllocCat(header, refid);
	StrAllocCat(header, ">\n");
d1289 3
a1291 3
    clear();
    move(2,0);
    scrollok(stdscr, TRUE);	/* Enable scrolling. */
d1293 1
a1293 1
	addstr(SENDING_MESSAGE_WITH_BODY_TO);
d1295 6
a1300 18
	addstr(SENDING_COMMENT_TO);
    cp = address;
    while ((cp1 = strchr(cp, ',')) != NULL) {
	*cp1 = '\0';
	while (*cp == ' ')
	    cp++;
	if (*cp) {
	    addstr(cp);
	    addstr(",\n  ");
	}
	*cp1 = ',';
	cp = (cp1 + 1);
    }
    if (*cp) {
	addstr(cp);
    }
#ifdef VMS
    if ((isPMDF == TRUE) &&
a1301 3
#else
    if ((cp = ccaddr) != NULL)
#endif /* VMS */
d1304 1
a1304 1
	    addstr(WITH_COPIES_TO);
d1306 1
a1306 15
	    addstr(WITH_COPY_TO);
	}
	while ((cp1 = strchr(cp, ',')) != NULL) {
	    *cp1 = '\0';
	    while (*cp == ' ')
		cp++;
	    if (*cp) {
		addstr(cp);
		addstr(",\n  ");
	    }
	    *cp1 = ',';
	    cp = (cp1 + 1);
	}
	if (*cp) {
	    addstr(cp);
d1308 1
d1310 1
a1310 1
    addstr(CTRL_G_TO_CANCEL_SEND);
d1312 1
a1312 1
#ifdef VMS
d1314 1
a1314 1
#endif /* VMS */
d1319 2
a1320 8
    addstr(ENTER_NAME_OR_BLANK);
    if (personal_name == NULL)
	*user_input = '\0';
    else {
	addstr(CTRL_U_TO_ERASE);
	strcpy(user_input, personal_name);
    }
#ifdef VMS
d1322 1
a1322 1
	addstr(gettext("Personal_name: "));
d1324 1
a1324 1
	addstr(gettext("X_Personal_name: "));
d1327 8
a1334 18
    addstr(gettext("Personal Name: "));
#endif /* VMS */
    if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	term_letter) {
	addstr("\n");
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
	goto cleanup;
    }
    addstr("\n");
    remove_tildes(user_input);
    StrAllocCopy(personal_name, user_input);
    term_letter = FALSE;
    if (*user_input) {
#ifdef VMS
	fprintf((isPMDF ? hfd : fd),
		"X-Personal_name: %s\n",user_input);
d1336 1
a1336 3
	StrAllocCat(header, "X-Personal_name: ");
	StrAllocCat(header, user_input);
	StrAllocCat(header, "\n");
d1343 3
a1345 5
    addstr(ENTER_MAIL_ADDRESS_OR_OTHER);
    addstr(MEANS_TO_CONTACT_FOR_RESPONSE);
    if (personal_mail_address)
	addstr(CTRL_U_TO_ERASE);
#ifdef VMS
d1347 1
a1347 1
	addstr("From: ");
d1349 1
a1349 1
	addstr("X-From: ");
d1352 1
a1352 1
    addstr("From: ");
d1355 8
a1362 9
    sprintf(user_input, "%s", (personal_mail_address ?
			       personal_mail_address : ""));
    if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	term_letter) {
	addstr("\n");
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
	goto cleanup;
d1364 1
a1364 10
    addstr("\n");
    remove_tildes(user_input);
#ifdef VMS
    if (*user_input) {
	if (isPMDF) {
	    fprintf(hfd, "From: %s\n", user_input);
	} else {
	    fprintf(fd, "X-From: %s\n\n", user_input);
	}
    } else if (!isPMDF) {
d1368 2
a1369 4
    StrAllocCat(header, "From: ");
    StrAllocCat(header, user_input);
    StrAllocCat(header, "\n");
#endif /* VMS */
d1371 1
a1371 1
#ifdef VMS
d1373 1
a1373 1
#endif /* VMS */
d1378 11
a1388 20
    addstr(ENTER_SUBJECT_LINE);
    addstr(CTRL_U_TO_ERASE);
    addstr(SUBJECT_PROMPT);
    /* Add the default subject. */
    sprintf(user_input, "%.70s%.63s",
			(subject[0] != '\0') ?
				     subject :
		    ((filename && *filename) ?
				    filename : "mailto:"),
			(subject[0] != '\0') ?
					  "" :
		    ((filename && *filename) ?
					  "" : address));
    if (LYgetstr(user_input, VISIBLE, 71, NORECALL) < 0 ||
	term_letter) {
	addstr("\n");
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	LYCloseTempFP(fd);	/* Close the tmpfile. */
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
	goto cleanup;
a1389 9
    addstr("\n");
    remove_tildes(user_input);
#ifdef VMS
    sprintf(subject, "%.70s", user_input);
#else
    StrAllocCat(header, "Subject: ");
    StrAllocCat(header, user_input);
    StrAllocCat(header, "\n");
#endif /* VMS */
a1393 1
    user_input[0] = '\0';
d1395 2
a1396 1
	addstr(ENTER_ADDRESS_FOR_CC);
d1398 5
a1402 32
	    addstr(CTRL_U_TO_ERASE);
	addstr(BLANK_FOR_NO_COPY);
	addstr("Cc: ");
	/*
	 *  Add the mail address if there is one.
	 */
	sprintf(user_input, "%s", (personal_mail_address ?
				   personal_mail_address : ""));
	if (LYgetstr(user_input, VISIBLE, sizeof(user_input), NORECALL) < 0 ||
	    term_letter) {
	    addstr("\n");
	    HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	    LYCloseTempFP(fd); 		/* Close the tmpfile. */
	    scrollok(stdscr, FALSE);	/* Stop scrolling.    */
	    goto cleanup;
	}
	addstr("\n");
    }
    remove_tildes(user_input);

    if (*user_input) {
	cp = user_input;
	while (*cp == ',' || isspace((unsigned char)*cp))
	    cp++;
	if (*cp) {
	    if (ccaddr == NULL) {
		StrAllocCopy(ccaddr, cp);
	    } else {
		StrAllocCat(ccaddr, ",");
		StrAllocCat(ccaddr, cp);
	    }
	}
d1405 5
a1409 5
#ifdef DOSPATH
    if (*address) {
	StrAllocCat(header, "To: ");
	StrAllocCat(header, address);
	StrAllocCat(header, "\n");
a1412 1
#ifndef VMS
d1416 2
a1417 4
    if (ccaddr != NULL && *ccaddr != '\0') {
	StrAllocCat(header, "Cc: ");
	StrAllocCat(header, ccaddr);
	StrAllocCat(header, "\n");
d1423 2
a1424 4
    if (keywords != NULL && *keywords != '\0') {
	StrAllocCat(header, "Keywords: ");
	StrAllocCat(header, keywords);
	StrAllocCat(header, "\n");
d1430 2
a1431 3
    sprintf(buf, "\n");
    StrAllocCat(header, buf);
    CTRACE(tfp,"**header==\n%s",header);
d1434 1
a1434 5
    if (!no_editor && editor && *editor != '\0') {
	/*
	 *  Use an external editor for the message.
	 */
	char *editor_arg = "";
d1447 1
a1447 1
	    BOOLEAN is_preparsed = (LYPreparsedSource &&
d1452 1
a1452 7
		/*
		 *  The 1 will add the reply "> " in front of every line.
		 */
		if (is_preparsed)
		    print_wwwfile_to_fd(fd, 0);
		else
		    print_wwwfile_to_fd(fd, 1);
d1456 1
a1456 1
	scrollok(stdscr,FALSE); /* Stop scrolling.    */
d1458 1
a1458 1
	if (term_letter || c == 7 || c == 3)
d1464 1
a1464 12
	if (strstr(editor, "pico")) {
	    editor_arg = " -t"; /* No prompt for filename to use */
	}
	sprintf(user_input, "%s%s %s", editor, editor_arg, my_tmpfile);
	_statusline(SPAWNING_EDITOR_FOR_MAIL);
	stop_curses();
	if (LYSystem(user_input)) {
	    start_curses();
	    HTAlert(ERROR_SPAWNING_EDITOR);
	} else {
	    start_curses();
	}
d1470 4
a1473 4
	clear();
	move(0,0);
	addstr(REVIEW_MESSAGE_BODY);
	refresh();
d1478 2
a1479 2
		addstr(RETURN_TO_CONTINUE);
		refresh();
d1481 3
a1483 7
		addstr("\n");
		if (term_letter || c == 7 || c == 3) {
		    addstr(CANCELLED);
		    sleep(InfoSecs);
		    LYCloseTempFP(fd); 		/* Close the tmpfile. */
		    scrollok(stdscr, FALSE);	/* Stop scrolling.    */
		    goto cleanup;
d1489 2
a1490 2
	    addstr(cp1);
	    addstr("\n");
d1495 1
a1495 1
	    addstr("\n");
d1498 1
a1498 1
	refresh();
d1500 1
a1500 1
	scrollok(stdscr,FALSE); /* Stop scrolling.	  */
d1506 5
a1510 5
	addstr(ENTER_MESSAGE_BELOW);
	addstr(ENTER_PERIOD_WHEN_DONE_A);
	addstr(ENTER_PERIOD_WHEN_DONE_B);
	addstr("\n\n");
	refresh();
d1514 1
a1514 4
	    HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	    LYCloseTempFP(fd); 		/* Close the tmpfile. */
	    scrollok(stdscr,FALSE);	/* Stop scrolling.    */
	    goto cleanup;
d1518 1
a1518 1
	    addstr("\n");
d1524 1
a1524 4
		HTInfoMsg(COMMENT_REQUEST_CANCELLED);
		LYCloseTempFP(fd);	/* Close the tmpfile. */
		scrollok(stdscr,FALSE); /* Stop scrolling.    */
		goto cleanup;
d1530 1
a1530 1
	scrollok(stdscr,FALSE); /* Stop scrolling.	  */
d1533 1
a1533 1
#ifndef VMS
d1543 1
a1543 1
	clear();  /* clear the screen */
d1547 1
a1547 1
	(fp = fopen(LynxSigFile, "r")) != NULL) {
d1560 1
a1560 1
	    if ((fd = fopen(my_tmpfile, "a")) != NULL) {
d1566 2
a1567 1
		fclose(fd);
d1570 1
a1570 1
	fclose(fp);
d1572 1
a1572 1
    clear();  /* Clear the screen. */
d1577 1
a1577 1
#ifdef VMS
d1586 1
a1586 1
	if (keywords != NULL && *keywords != '\0') {
d1589 1
a1589 1
	fprintf(hfd, "Subject: %s\n\n", subject);
d1594 1
a1594 2
	sprintf(cmd,
		"%s %s %s,%s ",
a1604 2
	 *
	 *  Possibly still a problem if user supplies long subject. - BL
d1606 1
a1606 2
	sprintf(cmd,
		"%s %s%s/subject=\"%s\" %s ",
d1610 1
a1610 1
		subject,
a1612 46
    StrAllocCopy(command, cmd);

    /*
     *	Now add all the people in the address field. - FM
     */
    address_ptr1 = address;
    do {
	if ((cp = strchr(address_ptr1, ',')) != NULL) {
	    address_ptr2 = (cp+1);
	    *cp = '\0';
	} else {
	    address_ptr2 = NULL;
	}

	/*
	 *  4 letters is arbitrarily the smallest possible mail
	 *  address, at least for lynx.  That way extra spaces
	 *  won't confuse the mailer and give a blank address.
	 *
	 *  ignore addresses so long that they would overflow the
	 *  temporary buffer (i.e., about 500 chars). - BL
	 */
	if (strlen(address_ptr1) > 3 &&
	    strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
	    if (!first) {
		StrAllocCat(command, ",");
	    }
	    sprintf(cmd, mail_adrs, address_ptr1);
	    StrAllocCat(command, cmd);
	    first = FALSE;
	}
	address_ptr1 = address_ptr2;
    } while (address_ptr1 != NULL);

    /*
     *	Now add all the people in the CC field. - FM
     */
    if (ccaddr != NULL && *ccaddr != '\0') {
	address_ptr1 = ccaddr;
	do {
	    if ((cp = strchr(address_ptr1, ',')) != NULL) {
		address_ptr2 = (cp+1);
		*cp = '\0';
	    } else {
		address_ptr2 = NULL;
	    }
d1614 3
a1616 19
	    /*
	     *	4 letters is arbitrarily the smallest possible mail
	     *	address, at least for lynx.  That way extra spaces
	     *	won't confuse the mailer and give a blank address.
	     *
	     *  ignore addresses so long that they would overflow the
	     *  temporary buffer (i.e., about 500 chars). - BL
	     */
	    if (strlen(address_ptr1) > 3 &&
		strlen(address_ptr1) + strlen(mail_adrs) < sizeof(cmd)) {
		StrAllocCat(command, ",");
		sprintf(cmd, mail_adrs, address_ptr1);
		if (isPMDF) {
		    strcat(cmd, "/CC");
		}
		StrAllocCat(command, cmd);
	    }
	    address_ptr1 = address_ptr2;
	} while (address_ptr1 != NULL);
d1621 1
a1621 1
    LYSystem(command);
d1623 1
a1623 1
    sleep(AlertSecs);
d1625 1
a1625 2
    goto cleandown;
#else /* Unix: */
d1630 7
a1636 2
    sprintf(cmd, "%s %s", system_mail, system_mail_flags);
#ifdef DOSPATH
a1638 1
	return;
d1640 7
d1648 6
a1653 30
    signal(SIGINT, SIG_IGN);
    fp = popen(cmd, "w");
    if (fp == NULL) {
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	goto cleanup;
    }
#endif /* DOSPATH */
    fd = fopen(my_tmpfile, "r");
    if (fd == NULL) {
	HTInfoMsg(COMMENT_REQUEST_CANCELLED);
	pclose(fp);
	goto cleanup;
    }
    fputs(header, fp);
    while ((n = fread(buf, 1, sizeof(buf), fd)) != 0)
	fwrite(buf, 1, n, fp);
#ifdef DOSPATH
    StrAllocCopy(command, system_mail);
    StrAllocCat(command, " -t \"");
    StrAllocCat(command, address);
    StrAllocCat(command, "\" -F ");
    StrAllocCat(command, tmpfile2);
    LYCloseTempFP(fp);	/* Close the tmpfile. */
    stop_curses();
    printf("%s\n\n$ %s\n\n%s", SENDING_COMMENT, command, PLEASE_WAIT);
    LYSystem(command);
    FREE(command);
    sleep(MessageSecs);
    start_curses();
    LYRemoveTemp(tmpfile2);	/* Delete the tmpfile. */
d1655 1
a1655 1
    pclose(fp);
d1657 20
a1676 4
    LYCloseTempFP(fd); /* Close the tmpfile. */

    CTRACE(tfp, "%s\n", cmd);
#endif /* VMS */
d1681 4
d1687 1
a1687 3
#if !defined(VMS) && !defined(DOSPATH)
    FREE(header);
#endif /* !VMS */
d1689 1
a1689 5
#if defined(VMS) || defined(DOSPATH)
cleandown:
#endif /* VMS */
    term_letter = FALSE;
#ifdef VMS
d1691 2
d1694 1
a1694 1
	LYRemoveTemp(hdrfile);
d1696 3
d1700 5
a1704 2
    LYRemoveTemp(my_tmpfile);
    FREE(address);
a1708 26
}

PRIVATE void terminate_letter ARGS1(int,sig GCC_UNUSED)
{
    term_letter = TRUE;
    /* Reassert the AST */
    signal(SIGINT, terminate_letter);
#if defined(VMS) || defined(DOSPATH)
    /*
     *	Refresh the screen to get rid of the "interrupt" message.
     */
    if (!dump_output_immediately) {
	lynx_force_repaint();
	refresh();
    }
#endif /* VMS */
}

PRIVATE void remove_tildes ARGS1(char *,string)
{
   /*
    *  Change the first character to
    *  a space if it is a '~'.
    */
    if (*string == '~')
	*string = ' ';
@


1.2
log
@Don't overflow on long mailto:-tags.
@
text
@d1 22
a22 16
#include "HTUtils.h"
#include "tcp.h"
#include "HTParse.h"
#include "LYGlobalDefs.h"
#include "HTAlert.h"
#include "LYCurses.h"
#include "LYSignal.h"
#include "LYUtils.h"
#include "LYClean.h"
#include "LYStrings.h"
#include "GridText.h"
#include "LYSystem.h"
#include "LYMail.h"
#include "LYCharSets.h"  /* to get current charset for mail header */

#include "LYLeaks.h"
d24 1
a24 1
#define FREE(x) if (x) {free(x); x = NULL;}
d30 22
d56 4
a59 4
	char *, 	mailto_address,
	char *, 	mailto_subject,
	char *, 	mailto_content,
	char *, 	mailto_type)
d72 3
a74 1
    char my_tmpfile[256];
a75 1
    char *command = NULL;
d77 1
d79 1
a79 1
    char hdrfile[256];
d121 1
a121 1
		    HTUnEscape(subject);
d228 1
a228 1
		    HTUnEscape(keywords);
d281 1
a281 1
    HTUnEscape(address);
d283 1
a283 1
	HTUnEscape(ccaddr);
d302 1
a302 2
	_statusline(FORM_MAILTO_CANCELLED);
	sleep(InfoSecs);
d322 1
a322 2
	    _statusline(FORM_MAILTO_CANCELLED);
	    sleep(InfoSecs);
d338 1
a338 8
    tempname(my_tmpfile, NEW_FILE);
    if (((cp = strrchr(my_tmpfile, '.')) != NULL) &&
	NULL == strchr(cp, ']') &&
	NULL == strchr(cp, '/')) {
	*cp = '\0';
	strcat(my_tmpfile, ".txt");
    }
    if ((fd = LYNewTxtFile(my_tmpfile)) == NULL) {
d346 1
a346 8
	tempname(hdrfile, NEW_FILE);
	if (((cp = strrchr(hdrfile, '.')) != NULL) &&
	    NULL == strchr(cp, ']') &&
	    NULL == strchr(cp, '/')) {
	    *cp = '\0';
	    strcat(hdrfile, ".txt");
	}
	if ((hfd = LYNewTxtFile(hdrfile)) == NULL) {
d348 1
d420 1
a420 1
	    strncpy(cmd, (char *)&mailto_content[i], 78);
d424 1
a424 1
	    len = strlen((char *)&mailto_content[i]);
d426 1
a426 1
	fprintf(fd, "%s\n", (char *)&mailto_content[i]);
d432 1
a432 1
	strncpy(cmd, (char *)&mailto_content[i], 78);
d436 1
a436 1
	len = strlen((char *)&mailto_content[i]);
d439 1
a439 1
	fprintf(fd, "%s\n", (char *)&mailto_content[i]);
d446 1
a446 1
    fclose(fd);
d460 1
a460 1
	fclose(hfd);
d476 2
d505 3
d509 2
a510 1
	if (strlen(address_ptr1) > 3) {
d538 3
d542 2
a543 1
	    if (strlen(address_ptr1) > 3) {
d556 2
a557 2
    printf("Sending form content:\n\n$ %s\n\nPlease wait...", command);
    system(command);
d561 2
a562 2
    remove(my_tmpfile);
    remove(hdrfile);
d564 5
a568 1
    sprintf(cmd, "%s -t \"%s\" -F %s", system_mail, address, my_tmpfile);
d570 3
a572 2
    printf("Sending form content:\n\n$ %s\n\nPlease wait...", cmd);
    system(cmd);
d575 1
a575 1
    remove(my_tmpfile);
d598 1
a598 1
    char cmd[512], *cp, *cp0, *cp1;
d600 3
a602 1
    char my_tmpfile[256];
a603 1
    char *command = NULL;
d605 1
d607 1
a607 1
    char hdrfile[256];
d610 5
d686 1
a686 1
    HTUnEscape(address);
d691 1
a691 3
	if (TRACE) {
	    fprintf(stderr,
		    "mailmsg: No address in '%s'.\n",
a692 1
	}
d697 1
a697 1
    sprintf(cmd, "%s %s", system_mail, system_mail_flags);
d700 1
a700 3
	if (TRACE) {
	    fprintf(stderr,
		    "mailmsg: '%s' failed.\n",
a701 1
	}
d714 2
a715 11
    tempname(my_tmpfile, NEW_FILE);
    if (((cp = strrchr(my_tmpfile, '.')) != NULL) &&
	NULL == strchr(cp, ']') &&
	NULL == strchr(cp, '/')) {
	*cp = '\0';
	strcat(my_tmpfile, ".txt");
    }
    if ((fd = LYNewTxtFile(my_tmpfile)) == NULL) {
	if (TRACE) {
	    fprintf(stderr,
		    "mailmsg: Could not fopen '%s'.\n",
a716 1
	}
d721 2
a722 11
	tempname(hdrfile, NEW_FILE);
	if (((cp = strrchr(hdrfile, '.')) != NULL) &&
	    NULL == strchr(cp, ']') &&
	    NULL == strchr(cp, '/')) {
	    *cp = '\0';
	    strcat(hdrfile, ".txt");
	}
	if ((hfd = LYNewTxtFile(hdrfile)) == NULL) {
	    if (TRACE) {
		fprintf(stderr,
			"mailmsg: Could not fopen '%s'.\n",
a723 1
	    }
d736 1
a736 1
    fprintf(fd, "The link   %s :?: %s \n",
d738 4
a741 2
    fprintf(fd, "called \"%s\"\n", links[cur].hightext);
    fprintf(fd, "in the file \"%s\" called \"%s\"", filename, linkname);
d743 2
a744 5
    fputs("\nwas requested but was not available.", fd);
    fputs("\n\nThought you might want to know.", fd);

    fputs("\n\nThis message was automatically generated by\n", fd);
    fprintf(fd, "Lynx ver. %s", LYNX_VERSION);
d748 1
a748 1
	while (fgets(cmd, sizeof(cmd), fp) != NULL)
d756 1
a756 1
    fclose(fd);
d764 1
a764 1
	fclose(hfd);
d768 1
a768 1
	sprintf(cmd,
d779 1
a779 1
	sprintf(cmd,
a785 1
    StrAllocCopy(command, cmd);
d794 10
a803 7
	if (strlen(address) > 3) {
	    if (!first) {
		StrAllocCat(command, ",");
	    }
	    sprintf(cmd, mail_adrs, address_ptr1);
	    StrAllocCat(command, cmd);
	    first = FALSE;
d805 3
d811 1
a811 1
    system(command);
d813 2
a814 1
    remove(my_tmpfile);
d816 1
a816 1
	remove(hdrfile);
d819 8
a826 3
    sprintf(cmd, "%s -t \"%s\" -F %s", system_mail, address, my_tmpfile);
    system(cmd);
    remove(my_tmpfile);
d836 1
a836 12
#ifndef NOSIGHUP
		(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
		(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
		(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
		if (no_suspend)
		    (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
		exit(-1);
d853 1
a853 1
PUBLIC void reply_by_mail ARGS3(
d856 2
a857 1
	CONST char *,	title)
d870 1
a870 1
    char my_tmpfile[256], cmd[512];
d872 4
a875 1
    char tmpfile2[256];
d877 1
d879 1
a882 1
    char *command = NULL;
d885 1
a885 1
    char hdrfile[256];
d897 6
d912 1
a912 10
    tempname(my_tmpfile, NEW_FILE);
    if (((cp = strrchr(my_tmpfile, '.')) != NULL) &&
#ifdef VMS
	NULL == strchr(cp, ']') &&
#endif /* VMS */
	NULL == strchr(cp, '/')) {
	*cp = '\0';
	strcat(my_tmpfile, ".txt");
    }
    if ((fd = LYNewTxtFile(my_tmpfile)) == NULL) {
d918 1
a918 8
	tempname(hdrfile, NEW_FILE);
	if (((cp = strrchr(hdrfile, '.')) != NULL) &&
	    NULL == strchr(cp, ']') &&
	    NULL == strchr(cp, '/')) {
	    *cp = '\0';
	    strcat(hdrfile, ".txt");
	}
	if ((hfd = LYNewTxtFile(hdrfile)) == NULL) {
d951 1
a951 1
		    HTUnEscape(subject);
d1058 1
a1058 1
		    HTUnEscape(keywords);
d1155 2
a1156 2
	fclose(fd);		/* Close the tmpfile.  */
	remove(my_tmpfile);	/* Delete the tmpfile. */
d1181 1
a1181 1
    HTUnEscape(address);
d1183 1
a1183 1
	HTUnEscape(ccaddr);
d1224 3
a1226 5
    asprintf(&header, "To: %s\n", address);
    if (!header) {
	fprintf(stderr, "Out of memory, you loose!\n");
	exit(1);
    }
d1256 9
a1264 5
    sprintf(buf,
	    "X-URL: %s%s\n",
	    (filename && *filename) ? filename : "mailto:",
	    (filename && *filename) ? "" : address);
    StrAllocCat(header, buf);
d1267 6
d1345 1
a1345 1
	addstr("Personal_name: ");
d1347 1
a1347 1
	addstr("X_Personal_name: ");
d1350 1
a1350 1
    addstr("Personal Name: ");
d1355 2
a1356 3
	_statusline(COMMENT_REQUEST_CANCELLED);
	sleep(InfoSecs);
	fclose(fd);		/* Close the tmpfile. */
d1369 3
a1371 2
	sprintf(buf, "X-Personal_name: %s\n", user_input);
	StrAllocCat(header, buf);
d1397 2
a1398 3
	_statusline(COMMENT_REQUEST_CANCELLED);
	sleep(InfoSecs);
	fclose(fd);		/* Close the tmpfile. */
d1415 3
a1417 2
    sprintf(buf, "From: %s\n", user_input);
    StrAllocCat(header, buf);
d1429 1
a1429 1
    addstr("Subject: ");
d1443 2
a1444 3
	_statusline(COMMENT_REQUEST_CANCELLED);
	sleep(InfoSecs);
	fclose(fd);		/* Close the tmpfile. */
d1453 3
a1455 2
    sprintf(buf, "Subject: %s\n", user_input);
    StrAllocCat(header, buf);
d1476 2
a1477 3
	    _statusline(COMMENT_REQUEST_CANCELLED);
	    sleep(InfoSecs);
	    fclose(fd); 		/* Close the tmpfile. */
d1484 1
a1484 1
#if defined (VMS) || defined (DOSPATH)
d1498 1
a1498 1
#endif
d1501 3
a1503 2
	sprintf(buf, "To: %s\n", address);
	StrAllocCat(header, buf);
d1531 1
d1553 3
a1555 9
	    if (is_preparsed)
		_statusline(INC_PREPARSED_MSG_PROMPT);
	    else
		_statusline(INC_ORIG_MSG_PROMPT);
	    c = 0;
	    while (TOUPPER(c) != 'Y' && TOUPPER(c) != 'N' &&
		   !term_letter && c != 7   && c != 3)
		c = LYgetch();
	    if (TOUPPER(c) == 'Y') {
d1565 1
a1565 1
	fclose(fd);		/* Close the tmpfile. */
d1580 1
a1580 1
	if (system(user_input)) {
d1582 1
a1582 2
	    _statusline(ERROR_SPAWNING_EDITOR);
	    sleep(AlertSecs);
d1606 1
a1606 1
		    fclose(fd); 		/* Close the tmpfile. */
d1613 3
a1615 3
	    sprintf(cmd, "%s\n", cp1);
	    fprintf(fd, cmd);
	    addstr(cmd);
d1624 1
a1624 1
	fclose(fd);		/* Close the tmpfile.	  */
d1639 2
a1640 3
	    _statusline(COMMENT_REQUEST_CANCELLED);
	    sleep(InfoSecs);
	    fclose(fd); 		/* Close the tmpfile. */
d1652 2
a1653 3
		_statusline(COMMENT_REQUEST_CANCELLED);
		sleep(InfoSecs);
		fclose(fd);		/* Close the tmpfile. */
d1660 1
a1660 1
	fclose(fd);		/* Close the tmpfile.	  */
d1671 1
a1671 4
    if (body)
	_statusline(SEND_MESSAGE_PROMPT);
    else
	_statusline(SEND_COMMENT_PROMPT);
d1673 1
a1673 5
    c = 0;
    while (TOUPPER(c) != 'Y' && TOUPPER(c) != 'N' &&
	   !term_letter && c != 7   && c != 3)
	c = LYgetch();
    if (TOUPPER(c) != 'Y') {
d1680 9
a1688 2
	_user_message(APPEND_SIG_FILE, LynxSigFile);
	c = 0;
d1690 1
a1690 4
	while (TOUPPER(c) != 'Y' && TOUPPER(c) != 'N' &&
	       !term_letter && c != 7	&& c != 3)
	    c = LYgetch();
	if (TOUPPER(c) == 'Y') {
d1692 1
d1694 2
a1695 2
		while (fgets(user_input, sizeof(user_input), fp) != NULL) {
		    fputs(user_input, fd);
d1720 1
a1720 1
	fclose(hfd);
d1736 2
d1765 3
d1769 2
a1770 1
	if (strlen(address_ptr1) > 3) {
d1798 3
d1802 2
a1803 1
	    if (strlen(address_ptr1) > 3) {
d1816 2
a1817 2
    printf("Sending your comment:\n\n$ %s\n\nPlease wait...", command);
    system(command);
d1829 1
a1829 7
    tempname(tmpfile2, NEW_FILE);
    if (((cp = strrchr(tmpfile2, '.')) != NULL) &&
	NULL == strchr(cp, '/')) {
	*cp = '\0';
	strcat(tmpfile2, ".txt");
    }
    if ((fp = LYNewTxtFile(tmpfile2)) == NULL) {
d1837 1
a1837 2
	_statusline(COMMENT_REQUEST_CANCELLED);
	sleep(InfoSecs);
d1843 1
a1843 2
	_statusline(COMMENT_REQUEST_CANCELLED);
	sleep(InfoSecs);
d1851 13
a1863 8
	sprintf(cmd, "%s -t \"%s\" -F %s", system_mail, address, tmpfile2);
	fclose(fp);		/* Close the tmpfile. */
	stop_curses();
	printf("Sending your comment:\n\n$ %s\n\nPlease wait...", cmd);
	system(cmd);
	sleep(MessageSecs);
	start_curses();
	remove(tmpfile2);	/* Delete the tmpfile. */
d1867 1
a1867 1
    fclose(fd); /* Close the tmpfile. */
d1869 1
a1869 2
    if (TRACE)
	printf("%s\n", cmd);
a1886 2
    while (remove(my_tmpfile) == 0)
	;		 /* Delete the tmpfile(s). */
d1888 1
a1888 1
	remove(hdrfile); /* Delete the hdrfile. */
a1889 2
#else
    remove(my_tmpfile);  /* Delete the tmpfile. */
d1891 1
@


1.1
log
@Initial revision
@
text
@d1219 5
a1223 2
    sprintf(buf, "To: %s\n", address);
    StrAllocCopy(header, buf);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
