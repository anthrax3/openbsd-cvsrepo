head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.07;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.51;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.51;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYCgi.c,v 1.67 2013/11/28 11:35:56 tom Exp $
 *                   Lynx CGI support                              LYCgi.c
 *                   ================
 *
 * Authors
 *          GL      George Lindholm <George.Lindholm@@ubc.ca>
 *
 * History
 *      15 Jun 95   Created as way to provide a lynx based service with
 *                  dynamic pages without the need for a http daemon.  GL
 *      27 Jun 95   Added <index> (command line) support.  Various cleanup
 *                  and bug fixes. GL
 *	04 Sep 97   Added support for PATH_INFO scripts.  JKT
 *
 * Bugs
 *      If the called scripts aborts before sending the mime headers then
 *      lynx hangs.
 *
 *      Should do something about SIGPIPE, (but then it should never happen)
 *
 *      No support for redirection.  Or mime-types.
 *
 *      Should try and parse for a HTTP 1.1 header in case we are "calling" a
 *      nph- script.
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTParse.h>
#include <HTTCP.h>
#include <HTFormat.h>
#include <HTFile.h>
#include <HTAlert.h>
#include <HTMIME.h>
#include <HTAABrow.h>

#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <HTML.h>
#include <HTInit.h>
#include <LYGetFile.h>
#include <LYBookmark.h>
#include <GridText.h>
#include <LYCgi.h>
#include <LYStrings.h>
#include <LYLocal.h>

#include <LYLeaks.h>
#include <www_wait.h>

static char **env = NULL;	/* Environment variables */
static unsigned envc_size = 0;	/* Slots in environment array */
static unsigned envc = 0;	/* Slots used so far */
static HTList *alloced = NULL;

#if defined(LYNXCGI_LINKS) && !defined(__MINGW32__)
static char *user_agent = NULL;
static char *server_software = NULL;
static char *accept_language = NULL;
static char *post_len = NULL;
#endif /* LYNXCGI_LINKS */

static void add_environment_value(const char *env_value);

#define PERROR(msg) CTRACE((tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno)))

#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))

#ifdef LY_FIND_LEAKS
static void free_alloced_lynxcgi(void)
{
    void *ptr;

    while ((ptr = HTList_removeLastObject(alloced)) != NULL) {
	FREE(ptr);
    }
    FREE(alloced);
#ifdef LYNXCGI_LINKS
    FREE(user_agent);
    FREE(server_software);
#endif
}
#endif /* LY_FIND_LEAKS */

static void remember_alloced(void *ptr)
{
    if (!alloced) {
	alloced = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(free_alloced_lynxcgi);
#endif
    }
    HTList_addObject(alloced, ptr);
}

/*
 * Simple routine for expanding the environment array and adding a value to
 * it
 */
static void add_environment_value(const char *env_value)
{
    if (envc == envc_size) {	/* Need some more slots */
	envc_size += 10;
	if (env) {
	    env = (char **) realloc(env,
				    sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
	} else {
	    env = (char **) malloc(sizeof(env[0]) * (envc_size + 2));
	    /* + terminator and base 0 */
	    remember_alloced(env);
	}
	if (env == NULL) {
	    outofmem(__FILE__, "LYCgi");
	}
	assert(env != NULL);
    }

    env[envc++] = DeConst(env_value);
    env[envc] = NULL;		/* Make sure it is always properly terminated */
}

/*
 * Add the value of an existing environment variable to those passed on to the
 * lynxcgi script.
 */
void add_lynxcgi_environment(const char *variable_name)
{
    char *env_value;

    env_value = LYGetEnv(variable_name);
    if (env_value != NULL) {
	char *add_value = NULL;

	HTSprintf0(&add_value, "%s=%s", variable_name, env_value);
	add_environment_value(add_value);
	remember_alloced(add_value);
    }
}

#ifdef __MINGW32__
static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
{
    return -1;
}
#else
#ifdef LYNXCGI_LINKS
/*
 * Wrapper for exec_ok(), confirming with user if the link text is not visible
 * in the status line.
 */
static BOOL can_exec_cgi(const char *linktext, const char *linkargs)
{
    const char *format = gettext("Do you want to execute \"%s\"?");
    char *message = NULL;
    char *command = NULL;
    char *p;
    BOOL result = TRUE;

    if (!exec_ok(HTLoadedDocumentURL(), linktext, CGI_PATH)) {
	/* exec_ok gives out msg. */
	result = FALSE;
    } else {
	StrAllocCopy(command, linktext);
	if (non_empty(linkargs)) {
	    HTSprintf(&command, " %s", linkargs);
	}
	HTUnEscape(command);
	for (p = command; *p; ++p)
	    if (*p == '+')
		*p = ' ';
	HTSprintf0(&message, format, command);
	result = HTConfirm(message);
	FREE(message);
	FREE(command);
    }
    return result;
}
#endif /* LYNXCGI_LINKS */

static int LYLoadCGI(const char *arg,
		     HTParentAnchor *anAnchor,
		     HTFormat format_out,
		     HTStream *sink)
{
    int status = 0;

#ifdef LYNXCGI_LINKS
#ifndef VMS
    char *cp;
    struct stat stat_buf;
    char *pgm = NULL;		/* executable */
    char *pgm_args = NULL;	/* and its argument(s) */
    int statrv;
    char *orig_pgm = NULL;	/* Path up to ? as given, URL-escaped */
    char *document_root = NULL;	/* Corrected value of DOCUMENT_ROOT  */
    char *path_info = NULL;	/* PATH_INFO extracted from pgm      */
    char *pgm_buff = NULL;	/* PATH_INFO extraction buffer       */
    char *path_translated;	/* From document_root/path_info      */

    if (isEmpty(arg) || strlen(arg) <= 8) {
	HTAlert(BAD_REQUEST);
	status = -2;
	return (status);

    } else {
	if (StrNCmp(arg, "lynxcgi://localhost", 19) == 0) {
	    StrAllocCopy(pgm, arg + 19);
	} else {
	    StrAllocCopy(pgm, arg + 8);
	}
	if ((cp = StrChr(pgm, '?')) != NULL) {	/* Need to terminate executable */
	    *cp++ = '\0';
	    pgm_args = cp;
	}
    }

    StrAllocCopy(orig_pgm, pgm);
    if (trimPoundSelector(pgm) != NULL) {
	/*
	 * Strip a #fragment from path.  In this case any pgm_args found above
	 * will also be bogus, since the '?' came after the '#' and is part of
	 * the fragment.  Note that we don't handle the case where a '#'
	 * appears after a '?' properly according to URL rules.  - kw
	 */
	pgm_args = NULL;
    }
    HTUnEscape(pgm);

    /* BEGIN WebSter Mods */
    /* If pgm is not stat-able, see if PATH_INFO data is at the end of pgm */
    if ((statrv = stat(pgm, &stat_buf)) < 0) {
	StrAllocCopy(pgm_buff, pgm);
	while (statrv < 0 || (statrv = stat(pgm_buff, &stat_buf)) < 0) {
	    if ((cp = strrchr(pgm_buff, '/')) != NULL) {
		*cp = '\0';
		statrv = 1;	/* force new stat()  - kw */
	    } else {
		PERROR("strrchr(pgm_buff, '/') returned NULL");
		break;
	    }
	}

	if (statrv < 0) {
	    /* Did not find PATH_INFO data */
	    PERROR("stat() of pgm_buff failed");
	} else {
	    /* Found PATH_INFO data.  Strip it off of pgm and into path_info. */
	    StrAllocCopy(path_info, pgm + strlen(pgm_buff));
	    /* The following is safe since pgm_buff was derived from pgm
	       by stripping stuff off its end and by HTUnEscaping, so we
	       know we have enough memory allocated for pgm.  Note that
	       pgm_args may still point into that memory, so we cannot
	       reallocate pgm here. - kw */
	    strcpy(pgm, pgm_buff);
	    CTRACE((tfp,
		    "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
		    pgm_buff, path_info));
	}
	FREE(pgm_buff);
    }
    /* END WebSter Mods */

    if (statrv != 0) {
	/*
	 * Neither the path as given nor any components examined by backing up
	 * were stat()able.  - kw
	 */
	HTAlert(gettext("Unable to access cgi script"));
	PERROR("stat() failed");
	status = -4;

    } else
#ifdef _WINDOWS			/* 1998/01/14 (Wed) 09:16:04 */
#define isExecutable(mode) (mode & (S_IXUSR))
#else
#define isExecutable(mode) (mode & (S_IXUSR|S_IXGRP|S_IXOTH))
#endif
    if (!(S_ISREG(stat_buf.st_mode) && isExecutable(stat_buf.st_mode))) {
	/*
	 * Not a runnable file, See if we can load it using "file:" code.
	 */
	char *new_arg = NULL;

	/*
	 * But try "file:" only if the file we are looking at is the path as
	 * given (no path_info was extracted), otherwise it will be to
	 * confusing to know just what file is loaded.  - kw
	 */
	if (path_info) {
	    CTRACE((tfp,
		    "%s is not a file and %s not an executable, giving up.\n",
		    orig_pgm, pgm));
	    FREE(path_info);
	    FREE(pgm);
	    FREE(orig_pgm);
	    status = -4;
	    return (status);
	}

	LYLocalFileToURL(&new_arg, orig_pgm);

	CTRACE((tfp, "%s is not an executable file, passing the buck.\n", arg));
	status = HTLoadFile(new_arg, anAnchor, format_out, sink);
	FREE(new_arg);

    } else if (path_info &&
	       anAnchor != HTMainAnchor &&
	       !(reloading && anAnchor->document) &&
	       strcmp(arg, HTLoadedDocumentURL()) &&
	       HText_AreDifferent(anAnchor, arg) &&
	       HTUnEscape(orig_pgm) &&
	       !can_exec_cgi(orig_pgm, "")) {
	/*
	 * If we have extra path info and are not just reloading the current,
	 * check the full file path (after unescaping) now to catch forbidden
	 * segments.  - kw
	 */
	status = HT_NOT_LOADED;

    } else if (no_lynxcgi) {
	HTUserMsg(CGI_DISABLED);
	status = HT_NOT_LOADED;

    } else if (no_bookmark_exec &&
	       anAnchor != HTMainAnchor &&
	       !(reloading && anAnchor->document) &&
	       strcmp(arg, HTLoadedDocumentURL()) &&
	       HText_AreDifferent(anAnchor, arg) &&
	       HTLoadedDocumentBookmark()) {
	/*
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if no_bookmark_exec is
	 * TRUE an we are not now coming from a bookmark page.  - kw
	 */
	HTUserMsg(BOOKMARK_EXEC_DISABLED);
	status = HT_NOT_LOADED;

    } else if (anAnchor != HTMainAnchor &&
	       !(reloading && anAnchor->document) &&
	       strcmp(arg, HTLoadedDocumentURL()) &&
	       HText_AreDifferent(anAnchor, arg) &&
	       !can_exec_cgi(pgm, pgm_args)) {
	/*
	 * If we are reloading a lynxcgi document that had already been loaded,
	 * the various checks above should allow it even if exec_ok() would
	 * reject it because we are not now coming from a document with a URL
	 * allowed by TRUSTED_LYNXCGI rules.  - kw
	 */
	status = HT_NOT_LOADED;

    } else {
	HTFormat format_in;
	HTStream *target = NULL;	/* Unconverted data */
	int fd1[2], fd2[2];
	char buf[MAX_LINE];
	int pid;

#ifdef HAVE_TYPE_UNIONWAIT
	union wait wstatus;

#else
	int wstatus;
#endif

	fd1[0] = -1;
	fd1[1] = -1;
	fd2[0] = -1;
	fd2[1] = -1;

	if (anAnchor->isHEAD || keep_mime_headers) {

	    /* Show output as plain text */
	    format_in = WWW_PLAINTEXT;
	} else {

	    /* Decode full HTTP response */
	    format_in = HTAtom_for("www/mime");
	}

	target = HTStreamStack(format_in,
			       format_out,
			       sink, anAnchor);

	if (!target || target == NULL) {
	    char *tmp = 0;

	    HTSprintf0(&tmp, CANNOT_CONVERT_I_TO_O,
		       HTAtom_name(format_in),
		       HTAtom_name(format_out));
	    HTAlert(tmp);
	    FREE(tmp);
	    status = HT_NOT_LOADED;

	} else if (anAnchor->post_data && pipe(fd1) < 0) {
	    HTAlert(CONNECT_SET_FAILED);
	    PERROR("pipe() failed");
	    status = -3;

	} else if (pipe(fd2) < 0) {
	    HTAlert(CONNECT_SET_FAILED);
	    PERROR("pipe() failed");
	    close(fd1[0]);
	    close(fd1[1]);
	    status = -3;

	} else {
	    static BOOL first_time = TRUE;	/* One time setup flag */

	    if (first_time) {	/* Set up static environment variables */
		first_time = FALSE;	/* Only once */

		add_environment_value("REMOTE_HOST=localhost");
		add_environment_value("REMOTE_ADDR=127.0.0.1");

		HTSprintf0(&user_agent, "HTTP_USER_AGENT=%s/%s libwww/%s",
			   LYNX_NAME, LYNX_VERSION, HTLibraryVersion);
		add_environment_value(user_agent);

		HTSprintf0(&server_software, "SERVER_SOFTWARE=%s/%s",
			   LYNX_NAME, LYNX_VERSION);
		add_environment_value(server_software);
	    }
	    fflush(stdout);
	    fflush(stderr);
	    CTRACE_FLUSH(tfp);

	    if ((pid = fork()) > 0) {	/* The good, */
		ssize_t chars;
		off_t total_chars;

		close(fd2[1]);

		if (anAnchor->post_data) {
		    ssize_t written;
		    int remaining, total_written = 0;

		    close(fd1[0]);

		    /* We have form data to push across the pipe */
		    if (TRACE) {
			CTRACE((tfp,
				"LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type));
			CTRACE((tfp, "LYNXCGI: Writing:\n"));
			trace_bstring(anAnchor->post_data);
			CTRACE((tfp, "----------------------------------\n"));
		    }
		    remaining = BStrLen(anAnchor->post_data);
		    while ((written = write(fd1[1],
					    BStrData(anAnchor->post_data) + total_written,
					    (size_t) remaining)) != 0) {
			if (written < 0) {
#ifdef EINTR
			    if (errno == EINTR)
				continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
			    if (errno == ERESTARTSYS)
				continue;
#endif /* ERESTARTSYS */
			    PERROR("write() of POST data failed");
			    break;
			}
			CTRACE((tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				(int) written));
			total_written += (int) written;
			remaining -= (int) written;
			if (remaining == 0)
			    break;
		    }
		    if (remaining != 0) {
			CTRACE((tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				remaining));
		    }
		    close(fd1[1]);
		}

		HTReadProgress(total_chars = 0, (off_t) 0);
		while ((chars = read(fd2[0], buf, sizeof(buf))) != 0) {
		    if (chars < 0) {
#ifdef EINTR
			if (errno == EINTR)
			    continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
			if (errno == ERESTARTSYS)
			    continue;
#endif /* ERESTARTSYS */
			PERROR("read() of CGI output failed");
			break;
		    }
		    total_chars += (int) chars;
		    HTReadProgress(total_chars, (off_t) 0);
		    CTRACE((tfp, "LYNXCGI: Rx: %.*s\n", (int) chars, buf));
		    (*target->isa->put_block) (target, buf, (int) chars);
		}

		if (chars < 0 && total_chars == 0) {
		    status = HT_NOT_LOADED;
		    (*target->isa->_abort) (target, NULL);
		    target = NULL;
		} else if (chars != 0) {
		    status = HT_PARTIAL_CONTENT;
		} else {
		    status = HT_LOADED;
		}

#if !HAVE_WAITPID
		while (wait(&wstatus) != pid) ;		/* do nothing */
#else
		while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
#ifdef EINTR
		    if (errno == EINTR)
			continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
		    if (errno == ERESTARTSYS)
			continue;
#endif /* ERESTARTSYS */
		    break;
		}
#endif /* !HAVE_WAITPID */
		close(fd2[0]);

	    } else if (pid == 0) {	/* The Bad, */
		char **argv = NULL;
		int argv_cnt = 3;	/* name, one arg and terminator */
		char **cur_argv = NULL;
		int exec_errno;

		/* Set up output pipe */
		close(fd2[0]);
		dup2(fd2[1], fileno(stdout));	/* Should check success code */
		dup2(fd2[1], fileno(stderr));
		close(fd2[1]);

		if (non_empty(language)) {
		    HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
		    add_environment_value(accept_language);
		}

		if (non_empty(pref_charset)) {
		    cp = NULL;
		    StrAllocCopy(cp, "HTTP_ACCEPT_CHARSET=");
		    StrAllocCat(cp, pref_charset);
		    add_environment_value(cp);
		}

		if (anAnchor->post_data &&
		    anAnchor->post_content_type) {
		    cp = NULL;
		    StrAllocCopy(cp, "CONTENT_TYPE=");
		    StrAllocCat(cp, anAnchor->post_content_type);
		    add_environment_value(cp);
		}

		if (anAnchor->post_data) {	/* post script, read stdin */
		    close(fd1[1]);
		    dup2(fd1[0], fileno(stdin));
		    close(fd1[0]);

		    /* Build environment variables */

		    add_environment_value("REQUEST_METHOD=POST");

		    HTSprintf0(&post_len, "CONTENT_LENGTH=%d",
			       BStrLen(anAnchor->post_data));
		    add_environment_value(post_len);
		} else {
		    close(fileno(stdin));

		    if (anAnchor->isHEAD) {
			add_environment_value("REQUEST_METHOD=HEAD");
		    }
		}

		/*
		 * Set up argument line, mainly for <index> scripts
		 */
		if (pgm_args != NULL) {
		    for (cp = pgm_args; *cp != '\0'; cp++) {
			if (*cp == '+') {
			    argv_cnt++;
			}
		    }
		}

		argv = (char **) malloc((unsigned) argv_cnt * sizeof(char *));

		if (argv == NULL) {
		    outofmem(__FILE__, "LYCgi");
		}
		assert(argv != NULL);

		cur_argv = argv + 1;	/* For argv[0] */
		if (pgm_args != NULL) {
		    char *cr;

		    /* Data for a get/search form */
		    if (is_www_index) {
			add_environment_value("REQUEST_METHOD=SEARCH");
		    } else if (!anAnchor->isHEAD && !anAnchor->post_data) {
			add_environment_value("REQUEST_METHOD=GET");
		    }

		    cp = NULL;
		    StrAllocCopy(cp, "QUERY_STRING=");
		    StrAllocCat(cp, pgm_args);
		    add_environment_value(cp);

		    /*
		     * Split up arguments into argv array
		     */
		    cp = pgm_args;
		    cr = cp;
		    while (1) {
			if (*cp == '\0') {
			    *(cur_argv++) = HTUnEscape(cr);
			    break;

			} else if (*cp == '+') {
			    *cp++ = '\0';
			    *(cur_argv++) = HTUnEscape(cr);
			    cr = cp;
			}
			cp++;
		    }
		} else if (!anAnchor->isHEAD && !anAnchor->post_data) {
		    add_environment_value("REQUEST_METHOD=GET");
		}
		*cur_argv = NULL;	/* Terminate argv */
		argv[0] = pgm;

		/* Begin WebSter Mods  -jkt */
		if (LYCgiDocumentRoot != NULL) {
		    /* Add DOCUMENT_ROOT to env */
		    cp = NULL;
		    StrAllocCopy(cp, "DOCUMENT_ROOT=");
		    StrAllocCat(cp, LYCgiDocumentRoot);
		    add_environment_value(cp);
		}
		if (path_info != NULL) {
		    /* Add PATH_INFO to env */
		    cp = NULL;
		    StrAllocCopy(cp, "PATH_INFO=");
		    StrAllocCat(cp, path_info);
		    add_environment_value(cp);
		}
		if (LYCgiDocumentRoot != NULL && path_info != NULL) {
		    /* Construct and add PATH_TRANSLATED to env */
		    StrAllocCopy(document_root, LYCgiDocumentRoot);
		    LYTrimHtmlSep(document_root);
		    path_translated = document_root;
		    StrAllocCat(path_translated, path_info);
		    cp = NULL;
		    StrAllocCopy(cp, "PATH_TRANSLATED=");
		    StrAllocCat(cp, path_translated);
		    add_environment_value(cp);
		    FREE(path_translated);
		}
		/* End WebSter Mods  -jkt */

		execve(argv[0], argv, env);
		exec_errno = errno;
		PERROR("execve failed");
		printf("Content-Type: text/plain\r\n\r\n");
		if (!anAnchor->isHEAD) {
		    printf("exec of %s failed", pgm);
		    printf(": %s.\r\n", LYStrerror(exec_errno));
		}
		fflush(stdout);
		fflush(stderr);
		_exit(1);

	    } else {		/* and the Ugly */
		HTAlert(CONNECT_FAILED);
		PERROR("fork() failed");
		close(fd1[0]);
		close(fd1[1]);
		close(fd2[0]);
		close(fd2[1]);
		status = -1;
	    }

	}
	if (target != NULL) {
	    (*target->isa->_free) (target);
	}
    }
    FREE(path_info);
    FREE(pgm);
    FREE(orig_pgm);
#else /* VMS */
    HTStream *target;
    char *buf = 0;

    target = HTStreamStack(WWW_HTML,
			   format_out,
			   sink, anAnchor);

    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       gettext("Good Advice"));
    PUTS(buf);

    HTSprintf0(&buf, "<h1>%s</h1>\n", gettext("Good Advice"));
    PUTS(buf);

    HTSprintf0(&buf, "%s <a\n",
	       gettext("An excellent http server for VMS is available via"));
    PUTS(buf);

    HTSprintf0(&buf,
	       "href=\"http://www.ecr6.ohio-state.edu/www/doc/serverinfo.html\"\n");
    PUTS(buf);

    HTSprintf0(&buf, ">%s</a>.\n", gettext("this link"));
    PUTS(buf);

    HTSprintf0(&buf, "<p>%s\n",
	       gettext("It provides state of the art CGI script support.\n"));
    PUTS(buf);

    HTSprintf0(&buf, "</body>\n</html>\n");
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(buf);
    status = HT_LOADED;
#endif /* VMS */
#else /* LYNXCGI_LINKS */
    HTUserMsg(CGI_NOT_COMPILED);
    status = HT_NOT_LOADED;
#endif /* LYNXCGI_LINKS */

    (void) arg;
    (void) anAnchor;
    (void) format_out;
    (void) sink;

    return (status);
}
#endif /* __MINGW32__ */

#ifdef GLOBALDEF_IS_MACRO
#define _LYCGI_C_GLOBALDEF_1_INIT { "lynxcgi", LYLoadCGI, 0 }
GLOBALDEF(HTProtocol, LYLynxCGI, _LYCGI_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxCGI =
{"lynxcgi", LYLoadCGI, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYCgi.c,v 1.56 2009/04/12 17:14:41 tom Exp $
a51 4
struct _HTStream {
    HTStreamClass *isa;
};

d117 1
d120 1
a120 1
    env[envc++] = (char *) env_value;
d211 1
a211 1
	if (strncmp(arg, "lynxcgi://localhost", 19) == 0) {
d216 1
a216 1
	if ((cp = strchr(pgm, '?')) != NULL) {	/* Need to terminate executable */
d223 1
a223 1
    if ((cp = trimPoundSelector(pgm)) != NULL) {
d370 5
d433 2
a434 1
		int chars, total_chars;
d439 2
a440 1
		    int written, remaining, total_written = 0;
d456 1
a456 1
					    (unsigned) remaining)) != 0) {
d470 3
a472 3
				written));
			total_written += written;
			remaining -= written;
d483 1
a483 1
		HTReadProgress(total_chars = 0, 0);
d497 4
a500 3
		    HTReadProgress(total_chars += chars, 0);
		    CTRACE((tfp, "LYNXCGI: Rx: %.*s\n", chars, buf));
		    (*target->isa->put_block) (target, buf, chars);
d598 2
a682 1
		status = HT_NO_DATA;
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
a3 1
/*                   Lynx CGI support                              LYCgi.c
d57 2
a58 2
static int envc_size = 0;	/* Slots in environment array */
static int envc = 0;		/* Slots used so far */
d61 1
a61 1
#ifdef LYNXCGI_LINKS
d170 1
a170 1
    } else if (user_mode < ADVANCED_MODE) {
d363 1
a363 1
	char buf[1024];
d452 1
a452 1
					    remaining)) != 0) {
d588 1
a588 1
		argv = (char **) malloc(argv_cnt * sizeof(char *));
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 23
a24 23
**                   ================
**
** Authors
**          GL      George Lindholm <George.Lindholm@@ubc.ca>
**
** History
**      15 Jun 95   Created as way to provide a lynx based service with
**                  dynamic pages without the need for a http daemon.  GL
**      27 Jun 95   Added <index> (command line) support.  Various cleanup
**                  and bug fixes. GL
**	04 Sep 97   Added support for PATH_INFO scripts.  JKT
**
** Bugs
**      If the called scripts aborts before sending the mime headers then
**      lynx hangs.
**
**      Should do something about SIGPIPE, (but then it should never happen)
**
**      No support for redirection.  Or mime-types.
**
**      Should try and parse for a HTTP 1.1 header in case we are "calling" a
**      nph- script.
*/
d50 2
a51 3
struct _HTStream
{
  HTStreamClass * isa;
d54 5
a58 4
PRIVATE char **env = NULL;  /* Environment variables */
PRIVATE int envc_size = 0;  /* Slots in environment array */
PRIVATE int envc = 0;	    /* Slots used so far */
PRIVATE HTList *alloced = NULL;
d60 4
a63 4
PRIVATE char *user_agent = NULL;
PRIVATE char *server_software = NULL;
PRIVATE char *accept_language = NULL;
PRIVATE char *post_len = NULL;
d66 1
a66 1
PRIVATE void add_environment_value PARAMS((char *env_value));
d70 2
d73 1
a73 1
PRIVATE void free_alloced_lynxcgi NOARGS
d76 1
d88 1
a88 2
PRIVATE void remember_alloced ARGS1(
    void *,		ptr)
d103 1
a103 2
PRIVATE void add_environment_value ARGS1(
	char *,	env_value)
d105 1
a105 1
    if (envc == envc_size) {   /* Need some more slots */
d108 3
a110 3
	    env = (char **)realloc(env,
				   sizeof(env[0]) * (envc_size + 2));
						/* + terminator and base 0 */
d112 2
a113 2
	    env = (char **)malloc(sizeof(env[0]) * (envc_size + 2));
						/* + terminator and base 0 */
d121 2
a122 2
    env[envc++] = env_value;
    env[envc] = NULL;      /* Make sure it is always properly terminated */
d129 1
a129 2
PUBLIC void add_lynxcgi_environment ARGS1(
	CONST char *,	variable_name)
d144 4
a147 5
PRIVATE int LYLoadCGI ARGS4(
	CONST char *, 		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d149 1
a149 1
	return -1;
d152 38
a189 5
PRIVATE int LYLoadCGI ARGS4(
	CONST char *, 		arg,
	HTParentAnchor *,	anAnchor,
	HTFormat,		format_out,
	HTStream*,		sink)
d192 1
d197 2
a198 2
    char *pgm = NULL;		        /* executable */
    char *pgm_args = NULL;	        /* and its argument(s) */
d200 5
a204 5
    char *orig_pgm = NULL;		/* Path up to ? as given, URL-escaped*/
    char *document_root = NULL;		/* Corrected value of DOCUMENT_ROOT  */
    char *path_info = NULL;             /* PATH_INFO extracted from pgm      */
    char *pgm_buff = NULL;		/* PATH_INFO extraction buffer       */
    char *path_translated;		/* From document_root/path_info      */
d209 1
a209 1
	return(status);
d213 1
a213 1
	    StrAllocCopy(pgm, arg+19);
d215 1
a215 1
	    StrAllocCopy(pgm, arg+8);
d217 1
a217 1
	if ((cp=strchr(pgm, '?')) != NULL) { /* Need to terminate executable */
d226 4
a229 5
	 *  Strip a #fragment from path.  In this case any pgm_args
	 *  found above will also be bogus, since the '?' came after
	 *  the '#' and is part of the fragment.  Note that we don't
	 *  handle the case where a '#' appears after a '?' properly
	 *  according to URL rules. - kw
d240 1
a240 1
	    if ((cp=strrchr(pgm_buff, '/')) != NULL) {
d245 1
a245 1
	    	break;
d247 1
a247 1
        }
d261 3
a263 2
	    CTRACE((tfp, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
			pgm_buff, path_info));
d271 2
a272 2
	 *  Neither the path as given nor any components examined by
	 *  backing up were stat()able. - kw
d279 1
a279 1
#ifdef _WINDOWS	/* 1998/01/14 (Wed) 09:16:04 */
d286 1
a286 1
	 *  Not a runnable file, See if we can load it using "file:" code.
d291 3
a293 3
	 *  But try "file:" only if the file we are looking at is the path
	 *  as given (no path_info was extracted), otherwise it will be
	 *  to confusing to know just what file is loaded. - kw
d296 3
a298 2
	    CTRACE((tfp, "%s is not a file and %s not an executable, giving up.\n",
			orig_pgm, pgm));
d303 1
a303 1
	    return(status);
d306 1
a306 1
	LYLocalFileToURL (&new_arg, orig_pgm);
d318 1
a318 2
	       !exec_ok(HTLoadedDocumentURL(), orig_pgm,
			CGI_PATH)) { /* exec_ok gives out msg. */
d320 3
a322 3
	 *  If we have extra path info and are not just reloading
	 *  the current, check the full file path (after unescaping)
	 *  now to catch forbidden segments. - kw
d335 1
a335 1
 	       HTLoadedDocumentBookmark()) {
d337 3
a339 4
	 *  If we are reloading a lynxcgi document that had already been
	 *  loaded, the various checks above should allow it even if
	 *  no_bookmark_exec is TRUE an we are not now coming from a
	 *  bookmark page. - kw
d348 1
a348 2
	       !exec_ok(HTLoadedDocumentURL(), pgm,
			CGI_PATH)) { /* exec_ok gives out msg. */
d350 4
a353 4
	 *  If we are reloading a lynxcgi document that had already been
	 *  loaded, the various checks above should allow it even if
	 *  exec_ok() would reject it because we are not now coming from
	 *  a document with a URL allowed by TRUSTED_LYNXCGI rules. - kw
d359 1
a359 1
	HTStream *target  = NULL;		/* Unconverted data */
d363 1
d366 1
d387 1
d408 1
a408 1
	    static BOOL first_time = TRUE;      /* One time setup flag */
d417 1
a417 1
			LYNX_NAME, LYNX_VERSION, HTLibraryVersion);
d421 1
a421 1
			LYNX_NAME, LYNX_VERSION);
d428 1
a428 1
	    if ((pid = fork()) > 0) { /* The good, */
d440 2
a441 1
			CTRACE((tfp, "LYNXCGI: Doing post, content-type '%s'\n",
d464 1
a464 1
				    written));
d472 1
a472 1
				    remaining));
d478 1
a478 1
		while((chars = read(fd2[0], buf, sizeof(buf))) != 0) {
d493 1
a493 1
		    (*target->isa->put_block)(target, buf, chars);
d498 1
a498 1
		    (*target->isa->_abort)(target, NULL);
d507 1
a507 2
		while (wait(&wstatus) != pid)
		    ; /* do nothing */
d509 1
a509 1
		while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
d523 1
a523 1
	    } else if (pid == 0) { /* The Bad, */
d525 1
a525 1
		int argv_cnt = 3; /* name, one arg and terminator */
d531 1
a531 1
		dup2(fd2[1], fileno(stdout)); /* Should check success code */
d535 3
a537 3
		if (language && *language) {
		HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
		add_environment_value(accept_language);
d540 1
a540 1
		if (pref_charset && *pref_charset) {
d555 1
a555 1
		if (anAnchor->post_data) { /* post script, read stdin */
d586 2
a587 1
		argv = (char**)malloc(argv_cnt * sizeof(char*));
d591 1
a591 1
		cur_argv = argv + 1;		/* For argv[0] */
d612 1
a612 1
		    while(1) {
d638 1
a638 1
		if (path_info != NULL ) {
d645 1
a645 1
		if (LYCgiDocumentRoot != NULL && path_info != NULL ) {
d671 1
a671 1
	    } else {	/* and the Ugly */
d684 1
a684 1
	    (*target->isa->_free)(target);
d690 1
a690 1
#else  /* VMS */
d700 1
a700 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d703 1
a703 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d705 3
a707 2
    HTSprintf0(&buf, "%s <a\n", gettext("An excellent http server for VMS is available via"));
    (*target->isa->put_block)(target, buf, strlen(buf));
d710 2
a711 2
	       "href=\"http://kcgl1.eng.ohio-state.edu/www/doc/serverinfo.html\"\n");
    (*target->isa->put_block)(target, buf, strlen(buf));
d714 1
a714 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d718 1
a718 1
    (*target->isa->put_block)(target, buf, strlen(buf));
d720 2
a721 2
    HTSprintf0(&buf,"</body>\n</html>\n");
    (*target->isa->put_block)(target, buf, strlen(buf));
d723 1
a723 1
    (*target->isa->_free)(target);
d731 7
a737 1
    return(status);
d743 1
a743 1
GLOBALDEF (HTProtocol,LYLynxCGI,_LYCGI_C_GLOBALDEF_1_INIT);
d745 2
a746 1
GLOBALDEF PUBLIC HTProtocol LYLynxCGI = { "lynxcgi", LYLoadCGI, 0 };
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d133 1
a133 1
    env_value = getenv(variable_name);
d143 10
d173 1
a173 1
    if (!arg || !*arg || strlen(arg) <= 8) {
d191 1
a191 1
    if ((cp=strchr(pgm, '#')) != NULL) {
a198 1
	*cp = '\0';
d331 1
a331 1
	pid_t pid;
d401 1
d405 2
a406 1
		    CTRACE((tfp, "LYNXCGI: Doing post, content-type '%s'\n",
d408 5
a412 3
		    CTRACE((tfp, "LYNXCGI: Writing:\n%s----------------------------------\n",
				anAnchor->post_data));
		    remaining = strlen(anAnchor->post_data);
d414 1
a414 1
					    anAnchor->post_data + total_written,
d531 1
a531 1
			    strlen(anAnchor->post_data));
d697 1
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d48 1
a48 4

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
d68 1
a68 1
#define PERROR(msg) CTRACE(tfp, "LYNXCGI: %s: %s\n", msg, LYStrerror(errno))
d137 1
a137 8
	add_value = (char *)malloc(strlen(variable_name) +
				   strlen(env_value) + 2);
	if (add_value == NULL) {
	    outofmem(__FILE__, "LYCgi");
	}
	strcpy(add_value, variable_name);
	strcat(add_value, "=");
	strcat(add_value, env_value);
d201 1
a201 1
		statrv = 999;	/* force new stat()  - kw */
d213 6
a218 1
	    StrAllocCopy(path_info, pgm+strlen(pgm_buff));
d220 2
a221 2
	    CTRACE(tfp, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
			pgm_buff, path_info);
d236 7
a242 2
    } else if (!(S_ISREG(stat_buf.st_mode) &&
		 stat_buf.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))) {
d254 2
a255 2
	    CTRACE(tfp, "%s is not a file and %s not an executable, giving up.\n",
			orig_pgm, pgm);
d265 1
a265 1
	CTRACE(tfp, "%s is not an executable file, passing the buck.\n", arg);
d395 4
a398 4
		    CTRACE(tfp, "LYNXCGI: Doing post, content-type '%s'\n",
				anAnchor->post_content_type);
		    CTRACE(tfp, "LYNXCGI: Writing:\n%s----------------------------------\n",
				anAnchor->post_data);
d415 2
a416 2
			CTRACE(tfp, "LYNXCGI: Wrote %d bytes of POST data.\n",
				    written);
d423 2
a424 2
			CTRACE(tfp, "LYNXCGI: %d bytes remain unwritten!\n",
				    remaining);
d444 1
a444 1
		    CTRACE(tfp, "LYNXCGI: Rx: %.*s\n", chars, buf);
d650 2
a651 1
    HTSprintf0(&buf, "<head>\n<title>%s</title>\n</head>\n<body>\n", gettext("Good Advice"));
d671 1
a671 1
    HTSprintf0(&buf,"</body>\n");
@


1.1
log
@Initial revision
@
text
@d9 2
a10 2
**                  dynamic pages without the need for a http daemon. GL
**      27 Jun 95   Added <index> (command line) support. Various cleanup
d20 1
a20 1
**      No support for redirection. Or mime-types.
d24 1
a24 1
*/ 
d26 20
a45 22
#include "HTUtils.h"
#include "tcp.h"
#include "HTTP.h"
#include "HTParse.h"
#include "HTTCP.h"
#include "HTFormat.h"
#include "HTFile.h"
#include "HTAlert.h"
#include "HTMIME.h"
#include "HTAABrow.h"

#include "LYGlobalDefs.h"
#include "LYUtils.h"
#include "HTML.h"
#include "HTInit.h"
#include "LYGetFile.h"
#include "LYBookmark.h"
#include "GridText.h"
#include <ctype.h>
#include "LYCgi.h"
#include "LYSignal.h"
#include "LYLocal.h"
d47 1
a47 1
#include "LYLeaks.h"
d49 3
a51 1
#define FREE(x) if (x) {free(x); x = NULL;}
d53 1
a53 1
struct _HTStream 
d61 1
d63 4
a66 2
PRIVATE char user_agent[64];
PRIVATE char server_software[64];
d71 28
d109 1
a109 1
	if (env)
d113 1
a113 1
	else
d116 2
d126 1
a126 1
    
d149 1
d159 1
a159 1
    int status;
d213 1
a213 2
		if (TRACE)
		    perror("LYNXCGI: strrchr(pgm_buff, '/') returned NULL");
d220 1
a220 2
	    if (TRACE) 
		perror("LYNXCGI: stat() of pgm_buff failed");
d222 1
a222 1
	    /* Found PATH_INFO data. Strip it off of pgm and into path_info. */
d225 1
a225 3
	    if (TRACE)
		fprintf(stderr,
			"LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",
d237 2
a238 4
	HTAlert("Unable to access cgi script");
	if (TRACE) {
	    perror("LYNXCGI: stat() failed");
	}
d254 1
a254 3
	    if (TRACE) {
		fprintf(stderr,
			"%s is not a file and %s not an executable, giving up.\n",
a255 1
	    }
d262 4
a265 8
	    
	StrAllocCopy(new_arg, "file://localhost");
	StrAllocCat(new_arg, orig_pgm);

	if (TRACE) {
	    fprintf(stderr,
		    "%s is not an executable file, passing the buck.\n", arg);
	}
d285 1
a285 2
	_statusline(CGI_DISABLED);
	sleep(MessageSecs);
d300 1
a300 2
	_statusline(BOOKMARK_EXEC_DISABLED);
	sleep(MessageSecs);
d323 1
a323 1
#if HAVE_TYPE_UNIONWAIT
d334 1
a334 1
	    
d338 1
a338 1
		
d342 1
a342 1
		
d344 6
a349 4
	    sprintf(buf, CANNOT_CONVERT_I_TO_O,
		    HTAtom_name(format_in), HTAtom_name(format_out));
	    _statusline(buf);
	    sleep(AlertSecs);
d354 1
a354 3
	    if (TRACE) {
		perror("LYNXCGI: pipe() failed");
	    }
d356 1
a356 1
	    
d359 1
a359 3
	    if (TRACE) {
		perror("LYNXCGI: pipe() failed");
	    }
d363 2
a364 2
	    
	} else {	
d369 1
a369 1
		
d372 2
a373 2
		
		sprintf(user_agent, "HTTP_USER_AGENT=%s/%s libwww/%s",
d376 2
a377 2
		
		sprintf(server_software, "SERVER_SOFTWARE=%s/%s",
d381 4
a384 1
	    
d387 1
a387 1
		
d389 1
a389 1
		
d395 1
a395 2
		    if (TRACE) {
			fprintf(stderr, "LYNXCGI: Doing post, content-type '%s'\n",
d397 2
a398 4
			fprintf(stderr,
				"LYNXCGI: Writing:\n%s----------------------------------\n",
				anAnchor->post_data);			
		    }
d412 1
a412 3
			    if (TRACE) {
				perror("LYNXCGI: write() of POST data failed");
			    }
d415 1
a415 3
			if (TRACE) {
			    fprintf(stderr,
				    "LYNXCGI: Wrote %d bytes of POST data.\n",
a416 1
			}
d423 1
a423 3
			if (TRACE)
			    fprintf(stderr,
				    "LYNXCGI: %d bytes remain unwritten!\n",
d428 14
a441 10
		
		total_chars = 0;
		while((chars = read(fd2[0], buf, sizeof(buf))) > 0) {
		    char line[40];
		    
		    total_chars += chars;
		    sprintf (line, "Read %d bytes of data.", total_chars);
		    HTProgress(line);
		    if (TRACE) {
			fprintf(stderr, "LYNXCGI: Rx: %.*s\n", chars, buf);
d443 2
a444 1
		    
d447 11
d475 1
a475 2
		status = HT_LOADED;
		
a477 1
		char post_len[32];
d480 1
a480 1
		char buf[BUFSIZ];
d488 4
a491 4
		sprintf(buf, "HTTP_ACCEPT_LANGUAGE=%.*s",
			     (int)(sizeof(buf) - 22), language);
		buf[(sizeof(buf) - 1)] = '\0';
		add_environment_value(buf);
d493 1
a493 1
		if (pref_charset) {
d517 1
a517 1
		    sprintf(post_len, "CONTENT_LENGTH=%d",
d528 1
a528 1
		/* 
d544 1
a544 1
		if (pgm_args != NULL) {		
d550 1
a550 1
		    } else if (!anAnchor->isHEAD) {
d553 1
a553 1
		    
d568 1
a568 1
			    
d576 2
d579 1
a579 1
		*cur_argv = NULL;	/* Terminate argv */		
d582 1
a582 1
		/* Begin WebSter Mods  -jkt */                
d600 1
a600 3
		    if (document_root[strlen(document_root) - 1] == '/') {
			document_root[strlen(document_root) - 1] = '\0';
		    }
d612 11
a622 4
		if (TRACE) {
		    perror("LYNXCGI: execve failed");
		}
		
d625 1
a625 3
		if (TRACE) {
		    perror("LYNXCGI: fork() failed");
		}
d643 2
a644 2
	HTStream *target;
	char buf[256];
d646 19
a664 3
	target = HTStreamStack(WWW_HTML, 
			       format_out,
			       sink, anAnchor);
d666 3
a668 19
	sprintf(buf,"<head>\n<title>Good Advice</title>\n</head>\n<body>\n");
	(*target->isa->put_block)(target, buf, strlen(buf));
	
	sprintf(buf,"<h1>Good Advice</h1>\n");
	(*target->isa->put_block)(target, buf, strlen(buf));

	sprintf(buf, "An excellent http server for VMS is available via <a\n");
	(*target->isa->put_block)(target, buf, strlen(buf));

	sprintf(buf,
	 "href=\"http://kcgl1.eng.ohio-state.edu/www/doc/serverinfo.html\"\n");
	(*target->isa->put_block)(target, buf, strlen(buf));

	sprintf(buf, ">this link</a>.\n");
	(*target->isa->put_block)(target, buf, strlen(buf));

	sprintf(buf,
		"<p>It provides <b>state of the art</b> CGI script support.\n");
	(*target->isa->put_block)(target, buf, strlen(buf));
d670 2
a671 2
	sprintf(buf,"</body>\n");
	(*target->isa->put_block)(target, buf, strlen(buf));
d673 3
a675 2
	(*target->isa->_free)(target);
	status = HT_LOADED;
d678 1
a678 2
    _statusline(CGI_NOT_COMPILED);
    sleep(MessageSecs);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
