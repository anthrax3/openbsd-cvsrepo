head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.25;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.38;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.06;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.53;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.53;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTFWriter.c,v 1.106 2013/11/28 11:17:04 tom Exp $
 *
 *		FILE WRITER				HTFWrite.h
 *		===========
 *
 *	This version of the stream object just writes to a C file.
 *	The file is assumed open and left open.
 *
 *	Bugs:
 *		strings written must be less than buffer size.
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>
#include <LYCurses.h>
#include <HTFWriter.h>
#include <HTSaveToFile.h>

#ifdef WIN_EX
#include <HTParse.h>
#endif

#include <HTFormat.h>
#include <UCDefs.h>
#include <HTAlert.h>
#include <HTFile.h>
#include <HTInit.h>
#include <HTPlain.h>

#include <LYStrings.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYClean.h>
#include <GridText.h>
#include <LYExtern.h>
#include <LYexit.h>
#include <LYLeaks.h>
#include <LYKeymap.h>
#include <LYGetFile.h>
#include <LYHistory.h>		/* store statusline messages */

#ifdef USE_PERSISTENT_COOKIES
#include <LYCookie.h>
#endif

/* contains the name of the temp file which is being downloaded into */
char *WWW_Download_File = NULL;
BOOLEAN LYCancelDownload = FALSE;	/* exported to HTFormat.c in libWWW */

#ifdef VMS
static char *FIXED_RECORD_COMMAND = NULL;

#ifdef USE_COMMAND_FILE		/* Keep this as an option. - FM    */
#define FIXED_RECORD_COMMAND_MASK "@@Lynx_Dir:FIXED512 %s"
#else
#define FIXED_RECORD_COMMAND_MASK "%s"
static unsigned long LYVMS_FixedLengthRecords(char *filename);
#endif /* USE_COMMAND_FILE */
#endif /* VMS */

HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink);

/*	Stream Object
 *	-------------
 */
struct _HTStream {
    const HTStreamClass *isa;

    FILE *fp;			/* The file we've opened */
    char *end_command;		/* What to do on _free.  */
    char *remove_command;	/* What to do on _abort. */
    char *viewer_command;	/* Saved external viewer */
    HTFormat input_format;	/* Original pres->rep     */
    HTFormat output_format;	/* Original pres->rep_out */
    HTParentAnchor *anchor;	/* Original stream's anchor. */
    HTStream *sink;		/* Original stream's sink.   */
#ifdef FNAMES_8_3
    BOOLEAN idash;		/* remember position to become '.' */
#endif
};

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 *  Bug:
 *	Most errors are ignored.
 */

/*	Error handling
 *	------------------
 */
static void HTFWriter_error(HTStream *me, const char *id)
{
    char buf[200];

    sprintf(buf, "%.60s: %.60s: %.60s",
	    id,
	    me->isa->name,
	    LYStrerror(errno));
    HTAlert(buf);
/*
 * Only disaster results from:
 *	me->isa->_abort(me, NULL);
 */
}

/*	Character handling
 *	------------------
 */
static void HTFWriter_put_character(HTStream *me, int c)
{
    if (me->fp) {
	putc(c, me->fp);
    }
}

/*	String handling
 *	---------------
 */
static void HTFWriter_put_string(HTStream *me, const char *s)
{
    if (me->fp) {
	fputs(s, me->fp);
    }
}

/*	Buffer write.  Buffers can (and should!) be big.
 *	------------
 */
static void HTFWriter_write(HTStream *me, const char *s, int l)
{
    size_t result;

    if (me->fp) {
	result = fwrite(s, (size_t) 1, (size_t) l, me->fp);
	if (result != (size_t) l) {
	    HTFWriter_error(me, "HTFWriter_write");
	}
    }
}

/*	Free an HTML object
 *	-------------------
 *
 *	Note that the SGML parsing context is freed, but the created
 *	object is not,
 *	as it takes on an existence of its own unless explicitly freed.
 */
static void HTFWriter_free(HTStream *me)
{
    int len;
    char *path = NULL;
    char *addr = NULL;
    BOOL use_zread = NO;
    BOOLEAN found = FALSE;

#ifdef WIN_EX
    HANDLE cur_handle;

    cur_handle = GetForegroundWindow();
#endif

    if (me->fp)
	fflush(me->fp);
    if (me->end_command) {	/* Temp file */
	LYCloseTempFP(me->fp);
#ifdef VMS
	if (0 == strcmp(me->end_command, "SaveVMSBinaryFile")) {
	    /*
	     * It's a binary file saved to disk on VMS, which
	     * we want to convert to fixed records format.  - FM
	     */
#ifdef USE_COMMAND_FILE
	    LYSystem(FIXED_RECORD_COMMAND);
#else
	    LYVMS_FixedLengthRecords(FIXED_RECORD_COMMAND);
#endif /* USE_COMMAND_FILE */
	    FREE(FIXED_RECORD_COMMAND);

	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort! */
		FREE(me->remove_command);
	    }
	} else
#endif /* VMS */
	if (me->input_format == HTAtom_for("www/compressed")) {
	    /*
	     * It's a compressed file supposedly cached to
	     * a temporary file for uncompression.  - FM
	     */
	    if (me->anchor->FileCache != NULL) {
		BOOL skip_loadfile = (BOOL) (me->viewer_command != NULL);

		/*
		 * Save the path with the "gz" or "Z" suffix trimmed,
		 * and remove any previous uncompressed copy.  - FM
		 */
		StrAllocCopy(path, me->anchor->FileCache);
		if ((len = (int) strlen(path)) > 3 &&
		    (!strcasecomp(&path[len - 2], "gz") ||
		     !strcasecomp(&path[len - 2], "zz"))) {
#ifdef USE_ZLIB
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
#endif /* USE_ZLIB */
		    {
			path[len - 3] = '\0';
			(void) remove(path);
		    }
		} else if (len > 4 && !strcasecomp(&path[len - 3], "bz2")) {
#ifdef USE_BZLIB
		    if (!skip_loadfile) {
			use_zread = YES;
		    } else
#endif /* USE_BZLIB */
		    {
			path[len - 4] = '\0';
			(void) remove(path);
		    }
		} else if (len > 2 && !strcasecomp(&path[len - 1], "Z")) {
		    path[len - 2] = '\0';
		    (void) remove(path);
		}
		if (!use_zread) {
		    if (!dump_output_immediately) {
			/*
			 * Tell user what's happening.  - FM
			 */
			_HTProgress(me->end_command);
		    }
		    /*
		     * Uncompress it.  - FM
		     */
		    if (me->end_command && me->end_command[0])
			LYSystem(me->end_command);
		    found = LYCanReadFile(me->anchor->FileCache);
		}
		if (found) {
		    /*
		     * It's still there with the "gz" or "Z" suffix,
		     * so the uncompression failed.  - FM
		     */
		    if (!dump_output_immediately) {
			lynx_force_repaint();
			LYrefresh();
		    }
		    HTAlert(ERROR_UNCOMPRESSING_TEMP);
		    (void) LYRemoveTemp(me->anchor->FileCache);
		    FREE(me->anchor->FileCache);
		} else {
		    /*
		     * Succeeded!  Create a complete address
		     * for the uncompressed file and invoke
		     * HTLoadFile() to handle it.  - FM
		     */
#ifdef FNAMES_8_3
		    /*
		     * Assuming we have just uncompressed e.g.
		     * FILE-mpeg.gz -> FILE-mpeg, restore/shorten
		     * the name to be fit for passing to an external
		     * viewer, by renaming FILE-mpeg -> FILE.mpe - kw
		     */
		    if (skip_loadfile) {
			char *new_path = NULL;
			char *the_dash = me->idash ? strrchr(path, '-') : 0;

			if (the_dash != 0) {
			    unsigned off = (the_dash - path);

			    StrAllocCopy(new_path, path);
			    new_path[off] = '.';
			    if (strlen(new_path + off) > 4)
				new_path[off + 4] = '\0';
			    if (rename(path, new_path) == 0) {
				FREE(path);
				path = new_path;
			    } else {
				FREE(new_path);
			    }
			}
		    }
#endif /* FNAMES_8_3 */
		    LYLocalFileToURL(&addr, path);
		    if (!use_zread) {
			LYRenamedTemp(me->anchor->FileCache, path);
			StrAllocCopy(me->anchor->FileCache, path);
			StrAllocCopy(me->anchor->content_encoding, "binary");
		    }
		    FREE(path);
		    if (!skip_loadfile) {
			/*
			 * Lock the chartrans info we may possibly have,
			 * so HTCharsetFormat() will not apply the default
			 * for local files.  - KW
			 */
			if (HTAnchor_getUCLYhndl(me->anchor,
						 UCT_STAGE_PARSER) < 0) {
			    /*
			     * If not yet set - KW
			     */
			    HTAnchor_copyUCInfoStage(me->anchor,
						     UCT_STAGE_PARSER,
						     UCT_STAGE_MIME,
						     UCT_SETBY_DEFAULT + 1);
			}
			HTAnchor_copyUCInfoStage(me->anchor,
						 UCT_STAGE_PARSER,
						 UCT_STAGE_MIME, -1);
		    }
		    /*
		     * Create a complete address for
		     * the uncompressed file.  - FM
		     */
		    if (!dump_output_immediately) {
			/*
			 * Tell user what's happening.  - FM
			 * HTInfoMsg2(WWW_USING_MESSAGE, addr);
			 * but only in the history, not on screen -RS
			 */
			LYstore_message2(WWW_USING_MESSAGE, addr);
		    }

		    if (skip_loadfile) {
			/*
			 * It's a temporary file we're passing to a viewer or
			 * helper application.  Loading the temp file through
			 * HTLoadFile() would result in yet another HTStream
			 * (created with HTSaveAndExecute()) which would just
			 * copy the temp file to another temp file (or even the
			 * same!).  We can skip this needless duplication by
			 * using the viewer_command which has already been
			 * determined when the HTCompressed stream was created. 
			 * - kw
			 */
			FREE(me->end_command);

			HTAddParam(&(me->end_command), me->viewer_command, 1, me->anchor->FileCache);
			HTEndParam(&(me->end_command), me->viewer_command, 1);

			if (!dump_output_immediately) {
			    /*
			     * Tell user what's happening.  - FM
			     */
			    HTProgress(me->end_command);
#ifndef WIN_EX
			    stop_curses();
#endif
			}
#ifdef _WIN_CC
			exec_command(me->end_command, FALSE);
#else
			LYSystem(me->end_command);
#endif
			if (me->remove_command) {
			    /* NEVER REMOVE THE FILE unless during an abort!!! */
			    FREE(me->remove_command);
			}
			if (!dump_output_immediately) {
#ifdef WIN_EX
			    if (focus_window) {
				HTInfoMsg(gettext("Set focus1"));
				(void) SetForegroundWindow(cur_handle);
			    }
#else
			    start_curses();
#endif
			}
		    } else {
			(void) HTLoadFile(addr,
					  me->anchor,
					  me->output_format,
					  me->sink);
		    }
		    if (dump_output_immediately &&
			me->output_format == HTAtom_for("www/present")) {
			FREE(addr);
			(void) remove(me->anchor->FileCache);
			FREE(me->anchor->FileCache);
			FREE(me->remove_command);
			FREE(me->end_command);
			FREE(me->viewer_command);
			FREE(me);
			return;
		    }
		}
		FREE(addr);
	    }
	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort!!! */
		FREE(me->remove_command);
	    }
	} else if (strcmp(me->end_command, "SaveToFile")) {
	    /*
	     * It's a temporary file we're passing to a viewer or helper
	     * application.  - FM
	     */
	    if (!dump_output_immediately) {
		/*
		 * Tell user what's happening.  - FM
		 */
		_HTProgress(me->end_command);
#ifndef WIN_EX
		stop_curses();
#endif
	    }
#ifdef _WIN_CC
	    exec_command(me->end_command, wait_viewer_termination);
#else
	    LYSystem(me->end_command);
#endif

	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort!!! */
		FREE(me->remove_command);
	    }
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus2"));
		    (void) SetForegroundWindow(cur_handle);
		}
#else
		start_curses();
#endif
	    }
	} else {
	    /*
	     * It's a file we saved to disk for handling via a menu.  - FM
	     */
	    if (me->remove_command) {
		/* NEVER REMOVE THE FILE unless during an abort!!! */
		FREE(me->remove_command);
	    }
	    if (!dump_output_immediately) {
#ifdef WIN_EX
		if (focus_window) {
		    HTInfoMsg(gettext("Set focus3"));
		    (void) SetForegroundWindow(cur_handle);
		}
#else
		start_curses();
#endif
	    }
	}
	FREE(me->end_command);
    }
    FREE(me->viewer_command);

    if (dump_output_immediately) {
	if (me->anchor->FileCache)
	    (void) remove(me->anchor->FileCache);
	FREE(me);
#ifdef USE_PERSISTENT_COOKIES
	/*
	 * We want to save cookies picked up when in source mode.  ...
	 */
	if (persistent_cookies)
	    LYStoreCookies(LYCookieSaveFile);
#endif /* USE_PERSISTENT_COOKIES */
	exit_immediately(EXIT_SUCCESS);
    }

    FREE(me);
    return;
}

#ifdef VMS
#  define REMOVE_COMMAND "delete/noconfirm/nolog %s;"
#else
#  define REMOVE_COMMAND "%s"
#endif /* VMS */

/*	Abort writing
 *	-------------
 */
static void HTFWriter_abort(HTStream *me, HTError e GCC_UNUSED)
{
    CTRACE((tfp, "HTFWriter_abort called\n"));
    LYCloseTempFP(me->fp);
    FREE(me->viewer_command);
    if (me->end_command) {	/* Temp file */
	CTRACE((tfp, "HTFWriter: Aborting: file not executed or saved.\n"));
	FREE(me->end_command);
	if (me->remove_command) {
#ifdef VMS
	    LYSystem(me->remove_command);
#else
	    (void) chmod(me->remove_command, 0600);	/* Ignore errors */
	    if (0 != unlink(me->remove_command)) {
		char buf[560];

		sprintf(buf, "%.60s '%.400s': %.60s",
			gettext("Error deleting file"),
			me->remove_command, LYStrerror(errno));
		HTAlert(buf);
	    }
#endif
	    FREE(me->remove_command);
	}
    }

    FREE(WWW_Download_File);

    FREE(me);
}

/*	Structured Object Class
 *	-----------------------
 */
static const HTStreamClass HTFWriter =	/* As opposed to print etc */
{
    "FileWriter",
    HTFWriter_free,
    HTFWriter_abort,
    HTFWriter_put_character,
    HTFWriter_put_string,
    HTFWriter_write
};

/*	Subclass-specific Methods
 *	-------------------------
 */
HTStream *HTFWriter_new(FILE *fp)
{
    HTStream *me;

    if (!fp)
	return NULL;

    me = typecalloc(HTStream);
    if (me == NULL)
	outofmem(__FILE__, "HTFWriter_new");

    assert(me != NULL);

    me->isa = &HTFWriter;

    me->fp = fp;
    me->end_command = NULL;
    me->remove_command = NULL;
    me->anchor = NULL;
    me->sink = NULL;

    return me;
}

/*	Make system command from template
 *	---------------------------------
 *
 *	See mailcap spec for description of template.
 */
static char *mailcap_substitute(HTParentAnchor *anchor,
				HTPresentation *pres,
				char *fnam)
{
    char *result = LYMakeMailcapCommand(pres->command,
					anchor->content_type_params,
					fnam);

#if defined(UNIX)
    /* if we don't have a "%s" token, expect to provide the file via stdin */
    if (!LYMailcapUsesPctS(pres->command)) {
	char *prepend = 0;
	const char *format = "( %s ) < %s";

	HTSprintf(&prepend, "( %s", result);	/* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam);	/* ...to quote if needed */
	FREE(result);
	result = prepend;
    }
#endif
    return result;
}

/*	Take action using a system command
 *	----------------------------------
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Creates temporary file, writes to it, executes system command
 *	on end-document.  The suffix of the temp file can be given
 *	in case the application is fussy, or so that a generic opener can
 *	be used.
 */
HTStream *HTSaveAndExecute(HTPresentation *pres,
			   HTParentAnchor *anchor,
			   HTStream *sink)
{
    char fnam[LY_MAXPATH];
    const char *suffix;
    HTStream *me;

    if (traversal) {
	LYCancelledFetch = TRUE;
	return (NULL);
    }
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    if (pres->quality >= 999.0) {	/* exec link */
	if (dump_output_immediately) {
	    LYCancelledFetch = TRUE;
	    return (NULL);
	}
	if (no_exec) {
	    HTAlert(EXECUTION_DISABLED);
	    return HTPlainPresent(pres, anchor, sink);
	}
	if (!local_exec) {
	    if (local_exec_on_local_files &&
		(LYJumpFileURL ||
		 !StrNCmp(anchor->address, "file://localhost", 16))) {
		/* allow it to continue */
		;
	    } else {
		char *buf = 0;

		HTSprintf0(&buf, EXECUTION_DISABLED_FOR_FILE,
			   key_for_func(LYK_OPTIONS));
		HTAlert(buf);
		FREE(buf);
		return HTPlainPresent(pres, anchor, sink);
	    }
	}
    }
#endif /* EXEC_LINKS || EXEC_SCRIPTS */

    if (dump_output_immediately) {
	return (HTSaveToFile(pres, anchor, sink));
    }

    me = typecalloc(HTStream);
    if (me == NULL)
	outofmem(__FILE__, "HTSaveAndExecute");

    assert(me != NULL);

    me->isa = &HTFWriter;
    me->input_format = pres->rep;
    me->output_format = pres->rep_out;
    me->anchor = anchor;
    me->sink = sink;

    if (LYCachedTemp(fnam, &(anchor->FileCache))) {
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
	 */
	me->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
    } else {
#if defined(WIN_EX) && !defined(__CYGWIN__)	/* 1998/01/04 (Sun) */
	if (!StrNCmp(anchor->address, "file://localhost", 16)) {

	    /* 1998/01/23 (Fri) 17:38:26 */
	    char *cp, *view_fname;

	    me->fp = NULL;

	    view_fname = fnam + 3;
	    LYStrNCpy(view_fname, anchor->address + 17, sizeof(fnam) - 5);
	    HTUnEscape(view_fname);

	    if (StrChr(view_fname, ':') == NULL) {
		fnam[0] = windows_drive[0];
		fnam[1] = windows_drive[1];
		fnam[2] = '/';
		view_fname = fnam;
	    }

	    /* 1998/04/21 (Tue) 11:04:16 */
	    cp = view_fname;
	    while (*cp) {
		if (IS_SJIS_HI1(UCH(*cp)) || IS_SJIS_HI2(UCH(*cp))) {
		    cp += 2;
		    continue;
		} else if (*cp == '/') {
		    *cp = '\\';
		}
		cp++;
	    }
	    if (StrChr(view_fname, ' '))
		view_fname = quote_pathname(view_fname);

	    StrAllocCopy(me->viewer_command, pres->command);

	    me->end_command = mailcap_substitute(anchor, pres, view_fname);
	    me->remove_command = NULL;

	    return me;
	}
#endif
	/*
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
	 */
	if (!strcasecomp(pres->rep->name, "text/html")) {
	    suffix = HTML_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if ((suffix = HTFileSuffix(pres->rep,
					  anchor->content_encoding)) == 0
		   || *suffix != '.') {
	    if (!strncasecomp(pres->rep->name, "application/", 12)) {
		suffix = BIN_SUFFIX;
	    } else {
		suffix = HTML_SUFFIX;
	    }
	}
	me->fp = LYOpenTemp(fnam, suffix, BIN_W);
    }

    if (!me->fp) {
	HTAlert(CANNOT_OPEN_TEMP);
	FREE(me);
	return NULL;
    }

    StrAllocCopy(me->viewer_command, pres->command);
    /*
     * Make command to process file.
     */
    me->end_command = mailcap_substitute(anchor, pres, fnam);

    /*
     * Make command to delete file.
     */
    me->remove_command = 0;
    HTAddParam(&(me->remove_command), REMOVE_COMMAND, 1, fnam);
    HTEndParam(&(me->remove_command), REMOVE_COMMAND, 1);

    StrAllocCopy(anchor->FileCache, fnam);
    return me;
}

/*	Format Converter using system command
 *	-------------------------------------
 */

/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */

/*	Save to a local file   LJM!!!
 *	--------------------
 *
 *	usually a binary file that can't be displayed
 *
 *	originally from Ghostview handling by Marc Andreseen.
 *	Asks the user if he wants to continue, creates a temporary
 *	file, and writes to it.  In HTSaveToFile_Free
 *	the user will see a list of choices for download
 */
HTStream *HTSaveToFile(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
{
    HTStream *ret_obj;
    char fnam[LY_MAXPATH];
    const char *suffix;
    char *cp;
    int c = 0;

#ifdef VMS
    BOOL IsBinary = TRUE;
#endif

    ret_obj = typecalloc(HTStream);

    if (ret_obj == NULL)
	outofmem(__FILE__, "HTSaveToFile");

    assert(ret_obj != NULL);

    ret_obj->isa = &HTFWriter;
    ret_obj->remove_command = NULL;
    ret_obj->end_command = NULL;
    ret_obj->input_format = pres->rep;
    ret_obj->output_format = pres->rep_out;
    ret_obj->anchor = anchor;
    ret_obj->sink = sink;

    if (dump_output_immediately) {
	ret_obj->fp = stdout;	/* stdout */
	if (HTOutputFormat == HTAtom_for("www/download"))
	    goto Prepend_BASE;
	return ret_obj;
    }

    LYCancelDownload = FALSE;
    if (HTOutputFormat != HTAtom_for("www/download")) {
	if (traversal ||
	    (no_download && !override_no_download && no_disk_save)) {
	    if (!traversal) {
		HTAlert(CANNOT_DISPLAY_FILE);
	    }
	    LYCancelDownload = TRUE;
	    if (traversal)
		LYCancelledFetch = TRUE;
	    FREE(ret_obj);
	    return (NULL);
	}

	if (((cp = StrChr(pres->rep->name, ';')) != NULL) &&
	    strstr((cp + 1), "charset") != NULL) {
	    _user_message(MSG_DOWNLOAD_OR_CANCEL, pres->rep->name);
	} else if (*(pres->rep->name) != '\0') {
	    _user_message(MSG_DOWNLOAD_OR_CANCEL, pres->rep->name);
	} else {
	    _statusline(CANNOT_DISPLAY_FILE_D_OR_C);
	}

	while (c != 'D' && c != 'C' && !LYCharIsINTERRUPT(c)) {
	    c = LYgetch_single();
#ifdef VMS
	    /*
	     * 'C'ancel on Control-C or Control-Y and
	     * a 'N'o to the "really exit" query.  - FM
	     */
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		c = 'C';
	    }
#endif /* VMS */
	}

	/*
	 * Cancel on 'C', 'c' or Control-G or Control-C.
	 */
	if (c == 'C' || LYCharIsINTERRUPT(c)) {
	    _statusline(CANCELLING_FILE);
	    LYCancelDownload = TRUE;
	    FREE(ret_obj);
	    return (NULL);
	}
    }

    /*
     * Set up a 'D'ownload.
     */
    if (LYCachedTemp(fnam, &(anchor->FileCache))) {
	/* This used to be LYNewBinFile(fnam); changed to a different call so
	 * that the open fp gets registered in the list keeping track of temp
	 * files, equivalent to when LYOpenTemp() gets called below.  This
	 * avoids a file descriptor leak caused by LYCloseTempFP() not being
	 * able to find the fp.  The binary suffix is expected to not be used,
	 * it's only for fallback in unusual error cases.  - kw
	 */
	ret_obj->fp = LYOpenTempRewrite(fnam, BIN_SUFFIX, BIN_W);
    } else {
	/*
	 * Check for a suffix.
	 * Save the file under a suitably suffixed name.
	 */
	if (!strcasecomp(pres->rep->name, "text/html")) {
	    suffix = HTML_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "text/", 5)) {
	    suffix = TEXT_SUFFIX;
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
	} else if ((suffix = HTFileSuffix(pres->rep,
					  anchor->content_encoding)) == 0
		   || *suffix != '.') {
	    suffix = HTML_SUFFIX;
	}
	ret_obj->fp = LYOpenTemp(fnam, suffix, BIN_W);
    }

    if (!ret_obj->fp) {
	HTAlert(CANNOT_OPEN_OUTPUT);
	FREE(ret_obj);
	return NULL;
    }

    if (0 == strncasecomp(pres->rep->name, "text/", 5) ||
	0 == strcasecomp(pres->rep->name, "application/postscript") ||
	0 == strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL"))
	/*
	 * It's a text file requested via 'd'ownload.  Keep adding others to
	 * the above list, 'til we add a configurable procedure.  - FM
	 */
#ifdef VMS
	IsBinary = FALSE;
#endif

    /*
     * Any "application/foo" or other non-"text/foo" types that are actually
     * text but not checked, above, will be treated as binary, so show the type
     * to help sort that out later.  Unix folks don't need to know this, but
     * we'll show it to them, too.  - FM
     */
    HTInfoMsg2(CONTENT_TYPE_MSG, pres->rep->name);

    StrAllocCopy(WWW_Download_File, fnam);

    /*
     * Make command to delete file.
     */
    ret_obj->remove_command = 0;
    HTAddParam(&(ret_obj->remove_command), REMOVE_COMMAND, 1, fnam);
    HTEndParam(&(ret_obj->remove_command), REMOVE_COMMAND, 1);

#ifdef VMS
    if (IsBinary && UseFixedRecords) {
	StrAllocCopy(ret_obj->end_command, "SaveVMSBinaryFile");
	FIXED_RECORD_COMMAND = 0;
	HTAddParam(&FIXED_RECORD_COMMAND, FIXED_RECORD_COMMAND_MASK, 1, fnam);
	HTEndParam(&FIXED_RECORD_COMMAND, FIXED_RECORD_COMMAND_MASK, 1);

    } else {
#endif /* VMS */
	StrAllocCopy(ret_obj->end_command, "SaveToFile");
#ifdef VMS
    }
#endif /* VMS */

    _statusline(RETRIEVING_FILE);

    StrAllocCopy(anchor->FileCache, fnam);
  Prepend_BASE:
    if (LYPrependBaseToSource &&
	!strncasecomp(pres->rep->name, "text/html", 9) &&
	!anchor->content_encoding) {
	/*
	 * Add the document's base as a BASE tag at the top of the file, so
	 * that any partial or relative URLs within it will be resolved
	 * relative to that if no BASE tag is present and replaces it.  Note
	 * that the markup will be technically invalid if a DOCTYPE
	 * declaration, or HTML or HEAD tags, are present, and thus the file
	 * may need editing for perfection.  - FM
	 *
	 * Add timestamp (last reload).
	 */
	char *temp = NULL;

	if (non_empty(anchor->content_base)) {
	    StrAllocCopy(temp, anchor->content_base);
	} else if (non_empty(anchor->content_location)) {
	    StrAllocCopy(temp, anchor->content_location);
	}
	if (temp) {
	    LYRemoveBlanks(temp);
	    if (!is_url(temp)) {
		FREE(temp);
	    }
	}

	fprintf(ret_obj->fp,
		"<!-- X-URL: %s -->\n", anchor->address);
	if (non_empty(anchor->date)) {
	    fprintf(ret_obj->fp,
		    "<!-- Date: %s -->\n", anchor->date);
	    if (non_empty(anchor->last_modified)
		&& strcmp(anchor->last_modified, anchor->date)
		&& strcmp(anchor->last_modified,
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(ret_obj->fp,
			"<!-- Last-Modified: %s -->\n", anchor->last_modified);
	    }
	}
	fprintf(ret_obj->fp,
		"<BASE HREF=\"%s\">\n\n", (temp ? temp : anchor->address));
	FREE(temp);
    }
    if (LYPrependCharsetToSource &&
	!strncasecomp(pres->rep->name, "text/html", 9) &&
	!anchor->content_encoding) {
	/*
	 * Add the document's charset as a META CHARSET tag at the top of the
	 * file, so HTTP charset header will not be forgotten when a document
	 * saved as local file.  We add this line only(!) if HTTP charset
	 * present.  - LP Note that the markup will be technically invalid if a
	 * DOCTYPE declaration, or HTML or HEAD tags, are present, and thus the
	 * file may need editing for perfection.  - FM
	 */
	char *temp = NULL;

	if (non_empty(anchor->charset)) {
	    StrAllocCopy(temp, anchor->charset);
	    LYRemoveBlanks(temp);
	    fprintf(ret_obj->fp,
		    "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		    temp);
	}
	FREE(temp);
    }
    return ret_obj;
}

/*	Set up stream for uncompressing - FM
 *	-------------------------------
 */
HTStream *HTCompressed(HTPresentation *pres,
		       HTParentAnchor *anchor,
		       HTStream *sink)
{
    HTStream *me;
    HTFormat format;
    char *type = NULL;
    HTPresentation *Pres = NULL;
    HTPresentation *Pnow = NULL;
    int n, i;
    BOOL can_present = FALSE;
    char fnam[LY_MAXPATH];
    char temp[LY_MAXPATH];	/* actually stores just a suffix */
    const char *suffix;
    char *uncompress_mask = NULL;
    const char *compress_suffix = "";
    const char *middle;

    /*
     * Deal with any inappropriate invocations of this function, or a download
     * request, in which case we won't bother to uncompress the file.  - FM
     */
    if (!(anchor->content_encoding && anchor->content_type)) {
	/*
	 * We have no idea what we're dealing with, so treat it as a binary
	 * stream.  - FM
	 */
	format = HTAtom_for("application/octet-stream");
	me = HTStreamStack(format, pres->rep_out, sink, anchor);
	return me;
    }
    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i++) {
	Pnow = (HTPresentation *) HTList_objectAt(HTPresentations, i);
	if (!strcasecomp(Pnow->rep->name, anchor->content_type) &&
	    Pnow->rep_out == WWW_PRESENT) {
	    const char *program = "";

	    /*
	     * Pick the best presentation.  User-defined mappings are at the
	     * end of the list, and unless the quality is lower, we prefer
	     * those.
	     */
	    if (Pres == 0)
		Pres = Pnow;
	    else if (Pres->quality > Pnow->quality)
		continue;
	    else
		Pres = Pnow;
	    /*
	     * We have a presentation mapping for it.  - FM
	     */
	    can_present = TRUE;
	    switch (HTEncodingToCompressType(anchor->content_encoding)) {
	    case cftGzip:
		if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		    /*
		     * It's compressed with the modern gzip.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d --no-name %s");
		    compress_suffix = "gz";
		}
		break;
	    case cftDeflate:
		if ((program = HTGetProgramPath(ppINFLATE)) != NULL) {
		    /*
		     * It's compressed with a zlib wrapper.
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "zz";
		}
		break;
	    case cftBzip2:
		if ((program = HTGetProgramPath(ppBZIP2)) != NULL) {
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " -d %s");
		    compress_suffix = "bz2";
		}
		break;
	    case cftCompress:
		if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
		    /*
		     * It's compressed the old fashioned Unix way.  - FM
		     */
		    StrAllocCopy(uncompress_mask, program);
		    StrAllocCat(uncompress_mask, " %s");
		    compress_suffix = "Z";
		}
		break;
	    case cftNone:
		break;
	    }
	}
    }
    if (can_present == FALSE ||	/* no presentation mapping */
	uncompress_mask == NULL ||	/* not gzip or compress */
	StrChr(anchor->content_type, ';') ||	/* wrong charset */
	HTOutputFormat == HTAtom_for("www/download") ||		/* download */
	!strcasecomp(pres->rep_out->name, "www/download") ||	/* download */
	(traversal &&		/* only handle html or plain text for traversals */
	 strcasecomp(anchor->content_type, "text/html") &&
	 strcasecomp(anchor->content_type, "text/plain"))) {
	/*
	 * Cast the Content-Encoding to a Content-Type and pass it back to be
	 * handled as that type.  - FM
	 */
	if (StrChr(anchor->content_encoding, '/') == NULL) {
	    /*
	     * Use "x-" prefix, none of the types we are likely to construct
	     * here are official.  That is we generate "application/x-gzip" and
	     * so on.  - kw
	     */
	    if (!strncasecomp(anchor->content_encoding, "x-", 2))
		StrAllocCopy(type, "application/");
	    else
		StrAllocCopy(type, "application/x-");
	    StrAllocCat(type, anchor->content_encoding);
	} else {
	    StrAllocCopy(type, anchor->content_encoding);
	}
	format = HTAtom_for(type);
	FREE(type);
	FREE(uncompress_mask);
	me = HTStreamStack(format, pres->rep_out, sink, anchor);
	return me;
    }

    /*
     * Set up the stream structure for uncompressing and then handling based on
     * the uncompressed Content-Type.- FM
     */
    me = typecalloc(HTStream);
    if (me == NULL)
	outofmem(__FILE__, "HTCompressed");

    assert(me != NULL);

    me->isa = &HTFWriter;
    me->input_format = pres->rep;
    me->output_format = pres->rep_out;
    me->anchor = anchor;
    me->sink = sink;
#ifdef FNAMES_8_3
    me->idash = FALSE;
#endif

    /*
     * Remove any old versions of the file.  - FM
     */
    if (anchor->FileCache) {
	(void) LYRemoveTemp(anchor->FileCache);
	FREE(anchor->FileCache);
    }

    /*
     * Get a new temporary filename and substitute a suitable suffix.  - FM
     */
    middle = NULL;
    if (!strcasecomp(anchor->content_type, "text/html")) {
	middle = HTML_SUFFIX;
	middle++;		/* point to 'h' of .htm(l) - kw */
    } else if (!strncasecomp(anchor->content_type, "text/", 5)) {
	middle = TEXT_SUFFIX + 1;
    } else if (!strncasecomp(anchor->content_type, "application/", 12)) {
	/* FIXME: why is this BEFORE HTFileSuffix? */
	middle = BIN_SUFFIX + 1;
    } else if ((suffix =
		HTFileSuffix(HTAtom_for(anchor->content_type), NULL)) &&
	       *suffix == '.') {
#if defined(VMS) || defined(FNAMES_8_3)
	if (StrChr(suffix + 1, '.') == NULL)
#endif
	    middle = suffix + 1;
    }

    temp[0] = 0;		/* construct the suffix */
    if (middle) {
#ifdef FNAMES_8_3
	me->idash = TRUE;	/* remember position of '-'  - kw */
	strcat(temp, "-");	/* NAME-htm,  NAME-txt, etc. - hack for DOS */
#else
	strcat(temp, ".");	/* NAME.html, NAME-txt etc. */
#endif /* FNAMES_8_3 */
	strcat(temp, middle);
#ifdef VMS
	strcat(temp, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc. */
#else
	strcat(temp, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc. */
#endif /* VMS */
    }
    strcat(temp, compress_suffix);

    /*
     * Open the file for receiving the compressed input stream.  - FM
     */
    me->fp = LYOpenTemp(fnam, temp, BIN_W);
    if (!me->fp) {
	HTAlert(CANNOT_OPEN_TEMP);
	FREE(uncompress_mask);
	FREE(me);
	return NULL;
    }

    /*
     * me->viewer_command will be NULL if the converter Pres found above is not
     * for an external viewer but an internal HTStream converter.  We also
     * don't set it under conditions where HTSaveAndExecute would disallow
     * execution of the command.  - KW
     */
    if (!dump_output_immediately && !traversal
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
	&& (Pres->quality < 999.0 ||
	    (!no_exec &&	/* allowed exec link or script ? */
	     (local_exec ||
	      (local_exec_on_local_files &&
	       (LYJumpFileURL ||
		!StrNCmp(anchor->address, "file://localhost", 16))))))
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
	) {
	StrAllocCopy(me->viewer_command, Pres->command);
    }

    /*
     * Make command to process file.  - FM
     */
#ifdef USE_BZLIB
    if (compress_suffix[0] == 'b'	/* must be bzip2 */
	&& !me->viewer_command) {
	/*
	 * We won't call bzip2 externally, so we don't need to supply a command
	 * for it.
	 */
	StrAllocCopy(me->end_command, "");
    } else
#endif
#ifdef USE_ZLIB
	/* FIXME: allow deflate here, e.g., 'z' */
	if (compress_suffix[0] == 'g'	/* must be gzip */
	    && !me->viewer_command) {
	/*
	 * We won't call gzip or compress externally, so we don't need to
	 * supply a command for it.
	 */
	StrAllocCopy(me->end_command, "");
    } else
#endif /* USE_ZLIB */
    {
	me->end_command = 0;
	HTAddParam(&(me->end_command), uncompress_mask, 1, fnam);
	HTEndParam(&(me->end_command), uncompress_mask, 1);
    }
    FREE(uncompress_mask);

    /*
     * Make command to delete file.  - FM
     */
    me->remove_command = 0;
    HTAddParam(&(me->remove_command), REMOVE_COMMAND, 1, fnam);
    HTEndParam(&(me->remove_command), REMOVE_COMMAND, 1);

    /*
     * Save the filename and return the structure.  - FM
     */
    StrAllocCopy(anchor->FileCache, fnam);
    return me;
}

/*	Dump output to stdout - LJM & FM
 *	---------------------
 *
 */
HTStream *HTDumpToStdout(HTPresentation *pres GCC_UNUSED,
			 HTParentAnchor *anchor,
			 HTStream *sink GCC_UNUSED)
{
    HTStream *ret_obj;

    ret_obj = typecalloc(HTStream);

    if (ret_obj == NULL)
	outofmem(__FILE__, "HTDumpToStdout");

    assert(ret_obj != NULL);

    ret_obj->isa = &HTFWriter;
    ret_obj->remove_command = NULL;
    ret_obj->end_command = NULL;
    ret_obj->anchor = anchor;

    ret_obj->fp = stdout;	/* stdout */
    return ret_obj;
}

#if defined(VMS) && !defined(USE_COMMAND_FILE)
#include <fab.h>
#include <rmsdef.h>		/* RMS status codes */
#include <iodef.h>		/* I/O function codes */
#include <fibdef.h>		/* file information block defs */
#include <atrdef.h>		/* attribute request codes */
#ifdef NOTDEFINED /*** Not all versions of VMS compilers have these.	 ***/
#include <fchdef.h>		/* file characteristics */
#include <fatdef.h>		/* file attribute defs */
#else		  /*** So we'll define what we need from them ourselves. ***/
#define FCH$V_CONTIGB	0x005	/* pos of cont best try bit */
#define FCH$M_CONTIGB	(1 << FCH$V_CONTIGB)	/* contig best try bit mask */
/* VMS I/O User's Reference Manual: Part I (V5.x doc set) */
struct fatdef {
    unsigned char fat$b_rtype, fat$b_rattrib;
    unsigned short fat$w_rsize;
    unsigned long fat$l_hiblk, fat$l_efblk;
    unsigned short fat$w_ffbyte;
    unsigned char fat$b_bktsize, fat$b_vfcsize;
    unsigned short fat$w_maxrec, fat$w_defext, fat$w_gbc;
    unsigned:16,:32,:16;	/* 6 bytes reserved, 2 bytes not used */
    unsigned short fat$w_versions;
};
#endif /* NOTDEFINED */

/* arbitrary descriptor without type and class info */
typedef struct dsc {
    unsigned short len, mbz;
    void *adr;
} Desc;

extern unsigned long sys$open(), sys$qiow(), sys$dassgn();

#define syswork(sts)	((sts) & 1)
#define sysfail(sts)	(!syswork(sts))

/*
 * 25-Jul-1995 - Pat Rankin (rankin@@eql.caltech.edu)
 *
 * Force a file to be marked as having fixed-length, 512 byte records
 * without implied carriage control, and with best_try_contiguous set.
 */
static unsigned long LYVMS_FixedLengthRecords(char *filename)
{
    struct FAB fab;		/* RMS file access block */
    struct fibdef fib;		/* XQP file information block */
    struct fatdef recattr;	/* XQP file "record" attributes */
    struct atrdef attr_rqst_list[3];	/* XQP attribute request itemlist */

    Desc fib_dsc;
    unsigned short channel, iosb[4];
    unsigned long fchars, sts, tmp;

    /* initialize file access block */
    fab = cc$rms_fab;
    fab.fab$l_fna = filename;
    fab.fab$b_fns = (unsigned char) strlen(filename);
    fab.fab$l_fop = FAB$M_UFO;	/* user file open; no further RMS processing */
    fab.fab$b_fac = FAB$M_PUT;	/* need write access */
    fab.fab$b_shr = FAB$M_NIL;	/* exclusive access */

    sts = sys$open(&fab);	/* channel in stv; $dassgn to close */
    if (sts == RMS$_FLK) {
	/* For MultiNet, at least, if the file was just written by a remote
	   NFS client, the local NFS server might still have it open, and the
	   failed access attempt will provoke it to be closed, so try again. */
	sts = sys$open(&fab);
    }
    if (sysfail(sts))
	return sts;

    /* RMS supplies a user-mode channel (see FAB$L_FOP FAB$V_UFO doc) */
    channel = (unsigned short) fab.fab$l_stv;

    /* set up ACP interface structures */
    /* file information block, passed by descriptor; it's okay to start with
       an empty FIB after RMS has accessed the file for us */
    fib_dsc.len = sizeof fib;
    fib_dsc.mbz = 0;
    fib_dsc.adr = &fib;
    memset((void *) &fib, 0, sizeof fib);
    /* attribute request list */
    attr_rqst_list[0].atr$w_size = sizeof recattr;
    attr_rqst_list[0].atr$w_type = ATR$C_RECATTR;
    *(void **) &attr_rqst_list[0].atr$l_addr = (void *) &recattr;
    attr_rqst_list[1].atr$w_size = sizeof fchars;
    attr_rqst_list[1].atr$w_type = ATR$C_UCHAR;
    *(void **) &attr_rqst_list[1].atr$l_addr = (void *) &fchars;
    attr_rqst_list[2].atr$w_size = attr_rqst_list[2].atr$w_type = 0;
    attr_rqst_list[2].atr$l_addr = 0;
    /* file "record" attributes */
    memset((void *) &recattr, 0, sizeof recattr);
    fchars = 0;			/* file characteristics */

    /* get current attributes */
    sts = sys$qiow(0, channel, IO$_ACCESS, iosb, (void (*)()) 0, 0,
		   &fib_dsc, 0, 0, 0, attr_rqst_list, 0);
    if (syswork(sts))
	sts = iosb[0];

    /* set desired attributes */
    if (syswork(sts)) {
	recattr.fat$b_rtype = FAB$C_SEQ | FAB$C_FIX;	/* org=seq, rfm=fix */
	recattr.fat$w_rsize = recattr.fat$w_maxrec = 512;	/* lrl=mrs=512 */
	recattr.fat$b_rattrib = 0;	/* rat=none */
	fchars |= FCH$M_CONTIGB;	/* contiguous-best-try */
	sts = sys$qiow(0, channel, IO$_DEACCESS, iosb, (void (*)()) 0, 0,
		       &fib_dsc, 0, 0, 0, attr_rqst_list, 0);
	if (syswork(sts))
	    sts = iosb[0];
    }

    /* all done */
    tmp = sys$dassgn(channel);
    if (syswork(sts))
	sts = tmp;
    return sts;
}
#endif /* VMS && !USE_COMMAND_FILE */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTFWriter.c,v 1.91 2009/01/01 22:58:59 tom Exp $
d14 2
d96 1
a96 1
static void HTFWriter_error(HTStream *me, char *id)
d114 1
a114 1
static void HTFWriter_put_character(HTStream *me, char c)
d139 1
a139 1
	result = fwrite(s, 1, (unsigned) l, me->fp);
a157 1
    int status;
d213 1
a213 1
			remove(path);
d223 1
a223 1
			remove(path);
d227 1
a227 1
		    remove(path);
d253 1
a253 1
		    LYRemoveTemp(me->anchor->FileCache);
d367 1
a367 1
				status = SetForegroundWindow(cur_handle);
d374 4
a377 4
			status = HTLoadFile(addr,
					    me->anchor,
					    me->output_format,
					    me->sink);
d382 1
a382 1
			remove(me->anchor->FileCache);
d412 1
a412 1
	    exec_command(me->end_command, FALSE);
d425 1
a425 1
		    status = SetForegroundWindow(cur_handle);
d443 1
a443 1
		    status = SetForegroundWindow(cur_handle);
d456 1
a456 1
	    remove(me->anchor->FileCache);
d493 1
a493 1
	    chmod(me->remove_command, 0600);	/* Ignore errors */
d538 3
d614 1
a614 1
		 !strncmp(anchor->address, "file://localhost", 16))) {
d637 3
d657 1
a657 1
	if (!strncmp(anchor->address, "file://localhost", 16)) {
d660 1
a660 4
	    unsigned char *cp, *view_fname;

#define IS_SJIS_HI1(hi) ((0x81<=hi)&&(hi<=0x9F))	/* 1st lev. */
#define IS_SJIS_HI2(hi) ((0xE0<=hi)&&(hi<=0xEF))	/* 2nd lev. */
d665 1
a665 1
	    LYstrncpy(view_fname, anchor->address + 17, sizeof(fnam) - 5);
d668 1
a668 1
	    if (strchr(view_fname, ':') == NULL) {
d678 1
a678 1
		if (IS_SJIS_HI1(*cp) || IS_SJIS_HI2(*cp)) {
d686 2
a687 2
	    if (strchr(view_fname, ' '))
		view_fname = (unsigned char *) quote_pathname(view_fname);
d765 2
d768 1
d774 3
d806 1
a806 1
	if (((cp = strchr(pres->rep->name, ';')) != NULL) &&
d884 1
d886 1
d1017 1
a1017 1
    if (!(anchor && anchor->content_encoding && anchor->content_type)) {
d1093 1
a1093 1
	strchr(anchor->content_type, ';') ||	/* wrong charset */
d1103 1
a1103 1
	if (strchr(anchor->content_encoding, '/') == NULL) {
d1131 3
d1147 1
a1147 1
	LYRemoveTemp(anchor->FileCache);
d1167 1
a1167 1
	if (strchr(suffix + 1, '.') == NULL)
d1213 1
a1213 1
		!strncmp(anchor->address, "file://localhost", 16))))))
d1278 3
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		FILE WRITER				HTFWrite.h
d40 1
d137 1
a137 1
	result = fwrite(s, 1, l, me->fp);
d202 1
a202 1
		if ((len = strlen(path)) > 3 &&
d321 2
d324 1
a324 1
			HTUserMsg2(WWW_USING_MESSAGE, addr);
d598 1
a598 1
    if (pres->quality == 999.0) {	/* exec link */
d882 1
a882 1
    HTUserMsg2(CONTENT_TYPE_MSG, pres->rep->name);
d1193 1
a1193 1
	&& (Pres->quality != 999.0 ||
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 8
a9 8
**		===========
**
**	This version of the stream object just writes to a C file.
**	The file is assumed open and left open.
**
**	Bugs:
**		strings written must be less than buffer size.
*/
a19 4
#ifdef _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

d24 1
d36 1
d42 3
a44 4
PUBLIC char * WWW_Download_File=NULL; /* contains the name of the temp file
				      ** which is being downloaded into
				      */
PUBLIC BOOLEAN LYCancelDownload=FALSE;   /* exported to HTFormat.c in libWWW */
d47 3
a49 2
PRIVATE char * FIXED_RECORD_COMMAND = NULL;
#ifdef USE_COMMAND_FILE		     /* Keep this as an option. - FM	*/
d53 1
a53 1
PUBLIC unsigned long LYVMS_FixedLengthRecords PARAMS((char *filename));
d57 3
a59 4
PUBLIC HTStream* HTSaveToFile PARAMS((
	HTPresentation *       pres,
	HTParentAnchor *       anchor,
	HTStream *	       sink));
d62 2
a63 2
**	-------------
*/
d65 1
a65 1
	CONST HTStreamClass *	isa;
d67 8
a74 8
	FILE *			fp;		/* The file we've opened */
	char *			end_command;	/* What to do on _free.  */
	char *			remove_command; /* What to do on _abort. */
	char *			viewer_command; /* Saved external viewer */
	HTFormat		input_format;  /* Original pres->rep	 */
	HTFormat		output_format; /* Original pres->rep_out */
	HTParentAnchor *	anchor;     /* Original stream's anchor. */
	HTStream *		sink;	    /* Original stream's sink.	 */
d76 1
a76 1
	BOOLEAN			idash; /* remember position to become '.'*/
d80 13
d94 10
a103 6
/*_________________________________________________________________________
**
**			A C T I O N	R O U T I N E S
**  Bug:
**	All errors are ignored.
*/
d106 3
a108 3
**	------------------
*/
PRIVATE void HTFWriter_put_character ARGS2(HTStream *, me, char, c)
d116 3
a118 5
**	---------------
**
**	Strings must be smaller than this buffer size.
*/
PRIVATE void HTFWriter_put_string ARGS2(HTStream *, me, CONST char*, s)
d126 3
a128 3
**	------------
*/
PRIVATE void HTFWriter_write ARGS3(HTStream *, me, CONST char*, s, int, l)
d130 2
d133 4
a136 1
	fwrite(s, 1, l, me->fp);
a139 3



d141 7
a147 7
**	-------------------
**
**	Note that the SGML parsing context is freed, but the created
**	object is not,
**	as it takes on an existence of its own unless explicitly freed.
*/
PRIVATE void HTFWriter_free ARGS1(HTStream *, me)
d155 1
d164 1
a164 1
    if (me->end_command) {		/* Temp file */
d168 4
a171 4
	/*
	 *  It's a binary file saved to disk on VMS, which
	 *  we want to convert to fixed records format. - FM
	 */
d180 1
a180 1
		/* NEVER REMOVE THE FILE unless during an abort!*/
d187 2
a188 2
	     *	It's a compressed file supposedly cached to
	     *	a temporary file for uncompression. - FM
d192 1
d194 2
a195 2
		 *  Save the path with the "gz" or "Z" suffix trimmed,
		 *  and remove any previous uncompressed copy. - FM
d199 2
a200 1
		    !strcasecomp(&path[len-2], "gz")) {
d207 1
a207 1
			path[len-3] = '\0';
d210 1
a210 1
		} else if (len > 4 && !strcasecomp(&path[len-3], "bz2")) {
d217 1
a217 1
			path[len-4] = '\0';
d220 2
a221 2
		} else if (len > 2 && !strcasecomp(&path[len-1], "Z")) {
		    path[len-2] = '\0';
d227 1
a227 1
			 *  Tell user what's happening. - FM
d232 1
a232 1
		     *	Uncompress it. - FM
d240 2
a241 2
		     *	It's still there with the "gz" or "Z" suffix,
		     *	so the uncompression failed. - FM
d252 3
a254 3
		     *	Succeeded!  Create a complete address
		     *	for the uncompressed file and invoke
		     *	HTLoadFile() to handle it. - FM
d258 4
a261 4
		     *	Assuming we have just uncompressed e.g.
		     *	FILE-mpeg.gz -> FILE-mpeg, restore/shorten
		     *	the name to be fit for passing to an external
		     *	viewer, by renaming FILE-mpeg -> FILE.mpe  - kw
d266 1
d269 1
d283 1
a283 1
		    LYLocalFileToURL (&addr, path);
d292 3
a294 3
			 *  Lock the chartrans info we may possibly have,
			 *  so HTCharsetFormat() will not apply the default
			 *  for local files. - KW
d297 1
a297 1
						 UCT_STAGE_PARSER) < 0 ) {
d299 1
a299 1
			     *	If not yet set - KW
d304 1
a304 1
						     UCT_SETBY_DEFAULT+1);
d311 2
a312 2
		     *	Create a complete address for
		     *	the uncompressed file. - FM
d316 1
a316 1
			 *  Tell user what's happening. - FM
d323 9
a331 11
			 *  It's a temporary file we're passing to a
			 *  viewer or helper application.
			 *  Loading the temp file through HTLoadFile()
			 *  would result in yet another HTStream (created
			 *  with HTSaveAndExecute()) which would just
			 *  copy the temp file to another temp file
			 *  (or even the same!).  We can skip this
			 *  needless duplication by using the
			 *  viewer_command which has already been
			 *  determined when the HTCompressed stream was
			 *  created. - kw
d340 1
a340 1
			     *	Tell user what's happening. - FM
d353 1
a353 1
			    /* NEVER REMOVE THE FILE unless during an abort!!!*/
d366 6
a371 5
		    } else
		    status = HTLoadFile(addr,
					me->anchor,
					me->output_format,
					me->sink);
d387 1
a387 1
		/* NEVER REMOVE THE FILE unless during an abort!!!*/
d392 2
a393 2
	     *	It's a temporary file we're passing to a
	     *	viewer or helper application. - FM
d397 1
a397 1
		 *  Tell user what's happening. - FM
d411 1
a411 1
		/* NEVER REMOVE THE FILE unless during an abort!!!*/
d426 1
a426 2
	     *	It's a file we saved to disk for handling
	     *	via a menu. - FM
d429 1
a429 1
		/* NEVER REMOVE THE FILE unless during an abort!!!*/
d453 1
a453 2
	 *  We want to save cookies picked up when in source
	 *  mode.  ...
d472 3
a474 5
**	-------------
*/
PRIVATE void HTFWriter_abort ARGS2(
	HTStream *,	me,
	HTError,	e GCC_UNUSED)
d476 1
a476 1
    CTRACE((tfp,"HTFWriter_abort called\n"));
d479 1
a479 1
    if (me->end_command) {		/* Temp file */
d486 1
a486 1
	    chmod(me->remove_command, 0600);		/* Ignore errors */
d506 3
a508 3
**	-----------------------
*/
PRIVATE CONST HTStreamClass HTFWriter = /* As opposed to print etc */
d510 6
a515 5
	"FileWriter",
	HTFWriter_free,
	HTFWriter_abort,
	HTFWriter_put_character,	HTFWriter_put_string,
	HTFWriter_write
d519 3
a521 3
**	-------------------------
*/
PUBLIC HTStream* HTFWriter_new ARGS1(FILE *, fp)
d523 1
a523 1
    HTStream* me;
d542 8
a549 3
PRIVATE void chrcat ARGS2(
	char *,		result,
	int,		ch)
d551 3
a553 4
    result += strlen(result);
    *result++ = (char)ch;
    *result = 0;
}
a554 65
/*	Make system command from template
**	---------------------------------
**
**	See mailcap spec for description of template.
*/
PRIVATE char *mailcap_substitute ARGS3(
	HTParentAnchor *,	anchor,
	HTPresentation *,	pres,
	char *,			fnam)
{
    int pass;
    int skip;
    size_t need = 0;
    char *result = 0;
    char *s;
    char *repl;

    for (pass = 0; pass < 2; pass++) {
	for (s = pres->command; *s; s++) {
	    if (*s == '%') {
		repl = 0;
		skip = 0;
		if (s[1] == 't') {
		    repl = pres->rep->name;
		    skip = 1;
		} else if (s[1] == 's') {
		    repl = fnam;
		    skip = 1;
		} else if (!strncasecomp(s+1, "{charset}", 9)) {
		    repl = anchor->charset;
		    skip = 9;
		} else if (!strncasecomp(s+1, "{encoding}", 10)) {
		    repl = anchor->content_encoding;
		    skip = 10;
		}
		if (skip != 0) {
		    if (repl == 0)
			repl = "";
		    if (pass) {
			strcat(result, repl);
		    } else {
			need += strlen(repl);
		    }
		    s += skip;
		} else {
		    if (pass) {
			chrcat(result, *s);
		    } else {
			need++;
		    }
		}
	    } else {
		if (pass) {
		    chrcat(result, *s);
		} else {
		    need++;
		}
	    }
	}
	if (pass == 0) {
	    if ((result = malloc(need + 1)) == 0)
		outofmem(__FILE__, "mailcap_substitute");
	    *result = 0;
	}
    }
d557 1
a557 1
    if (strstr(pres->command, "%s") == 0) {
d559 4
a562 3
	char *format = "( %s ) < %s";
	HTSprintf(&prepend, "( %s", pres->command); /* ...avoid quoting */
	HTAddParam(&prepend, format, 2, fnam); /* ...to quote if needed */
d571 11
a581 12
**	----------------------------------
**
**	originally from Ghostview handling by Marc Andreseen.
**	Creates temporary file, writes to it, executes system command
**	on end-document.  The suffix of the temp file can be given
**	in case the application is fussy, or so that a generic opener can
**	be used.
*/
PUBLIC HTStream* HTSaveAndExecute ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d584 2
a585 2
    CONST char *suffix;
    HTStream* me;
d589 1
a589 1
	return(NULL);
d592 1
a592 1
    if (pres->quality == 999.0) { /* exec link */
d595 1
a595 1
	    return(NULL);
d604 1
a604 1
		 !strncmp(anchor->address,"file://localhost",16))) {
d621 1
a621 1
	return(HTSaveToFile(pres, anchor, sink));
d634 6
a639 6
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The binary suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
d644 1
a644 1
	if (!strncmp(anchor->address,"file://localhost",16)) {
d658 1
a658 1
	    if (strchr(view_fname, ':')==NULL) {
d688 2
a689 2
	 *  Check for a suffix.
	 *  Save the file under a suitably suffixed name.
a694 2
	} else if (!strncasecomp(pres->rep->name, "application/", 12)) {
	    suffix = BIN_SUFFIX;
d697 6
a702 2
		    || *suffix != '.') {
	    suffix = HTML_SUFFIX;
d715 1
a715 1
     *	Make command to process file.
d720 1
a720 1
     *	Make command to delete file.
a729 1

d731 2
a732 2
**	-------------------------------------
*/
d737 12
a748 13
**	--------------------
**
**	usually a binary file that can't be displayed
**
**	originally from Ghostview handling by Marc Andreseen.
**	Asks the user if he wants to continue, creates a temporary
**	file, and writes to it.  In HTSaveToFile_Free
**	the user will see a list of choices for download
*/
PUBLIC HTStream* HTSaveToFile ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d750 1
a750 1
    HTStream * ret_obj;
d752 1
a752 1
    CONST char * suffix;
d758 1
d770 1
a770 1
	ret_obj->fp = stdout; /* stdout*/
d787 1
a787 1
	    return(NULL);
d791 1
a791 1
	    strstr((cp+1), "charset") != NULL) {
d793 1
a793 1
	} else if (*(pres->rep->name) != '\0')	{
d803 2
a804 2
	     *	'C'ancel on Control-C or Control-Y and
	     *	a 'N'o to the "really exit" query. - FM
d814 1
a814 1
	 *  Cancel on 'C', 'c' or Control-G or Control-C.
d820 1
a820 1
	    return(NULL);
d825 1
a825 1
     *	Set up a 'D'ownload.
d828 6
a833 6
	/*  This used to be LYNewBinFile(fnam); changed to a different call
	 *  so that the open fp gets registered in the list keeping track of
	 *  temp files, equivalent to when LYOpenTemp() gets called below.
	 *  This avoids a file descriptor leak caused by LYCloseTempFP()
	 *  not being able to find the fp.  The binary suffix is expected
	 *  to not be used, it's only for fallback in unusual error cases. - kw
d838 2
a839 2
	 *  Check for a suffix.
	 *  Save the file under a suitably suffixed name.
d849 1
a849 1
		    || *suffix != '.') {
d861 3
a863 3
    if (0==strncasecomp(pres->rep->name, "text/", 5) ||
	0==strcasecomp(pres->rep->name, "application/postscript") ||
	0==strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL"))
d865 2
a866 3
	 *  It's a text file requested via 'd'ownload.
	 *  Keep adding others to the above list, 'til
	 *  we add a configurable procedure. - FM
d871 4
a874 5
     *	Any "application/foo" or other non-"text/foo" types that
     *	are actually text but not checked, above, will be treated
     *	as binary, so show the type to help sort that out later.
     *	Unix folks don't need to know this, but we'll show it to
     *	them, too. - FM
d878 1
a878 1
    StrAllocCopy(WWW_Download_File,fnam);
d881 1
a881 1
     *	Make command to delete file.
d896 1
a896 1
    StrAllocCopy(ret_obj->end_command, "SaveToFile");
d904 1
a904 1
Prepend_BASE:
d909 6
a914 6
	 *  Add the document's base as a BASE tag at the top of the file,
	 *  so that any partial or relative URLs within it will be resolved
	 *  relative to that if no BASE tag is present and replaces it.
	 *  Note that the markup will be technically invalid if a DOCTYPE
	 *  declaration, or HTML or HEAD tags, are present, and thus the
	 *  file may need editing for perfection. - FM
d916 1
a916 1
	 *  Add timestamp (last reload).
d920 1
a920 1
	if (anchor->content_base && *anchor->content_base) {
d922 1
a922 1
	} else if (anchor->content_location && *anchor->content_location) {
d934 1
a934 1
	if (anchor->date && *anchor->date) {
d936 5
a940 4
		"<!-- Date: %s -->\n", anchor->date);
	    if (anchor->last_modified && *anchor->last_modified
			&& strcmp(anchor->last_modified, anchor->date)
			&& strcmp(anchor->last_modified, "Thu, 01 Jan 1970 00:00:01 GMT")) {
d942 1
a942 1
		    "<!-- Last-Modified: %s -->\n", anchor->last_modified);
d953 6
a958 7
	 *  Add the document's charset as a META CHARSET tag
	 *  at the top of the file, so HTTP charset header
	 *  will not be forgotten when a document saved as local file.
	 *  We add this line only(!) if HTTP charset present. - LP
	 *  Note that the markup will be technically invalid if a DOCTYPE
	 *  declaration, or HTML or HEAD tags, are present, and thus the
	 *  file may need editing for perfection. - FM
d962 1
a962 1
	if (anchor->charset && *anchor->charset) {
d966 2
a967 2
		"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		temp);
d975 5
a979 6
**	-------------------------------
*/
PUBLIC HTStream* HTCompressed ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d981 1
a981 1
    HTStream* me;
d985 1
d990 1
a990 2
    CONST char *program;
    CONST char *suffix;
d992 2
a993 2
    char *compress_suffix = "";
    CONST char *middle;
d996 2
a997 3
     *	Deal with any inappropriate invocations of this function,
     *	or a download request, in which case we won't bother to
     *	uncompress the file. - FM
d1001 2
a1002 2
	 *  We have no idea what we're dealing with,
	 *  so treat it as a binary stream. - FM
d1010 16
a1025 3
	Pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
	if (!strcasecomp(Pres->rep->name, anchor->content_type) &&
	    Pres->rep_out == WWW_PRESENT) {
d1027 1
a1027 1
	     *	We have a presentation mapping for it. - FM
d1030 27
a1056 9
	    if ((!strcasecomp(anchor->content_encoding, "x-gzip") ||
		 !strcasecomp(anchor->content_encoding, "gzip")) &&
		 (program = HTGetProgramPath(ppGZIP)) != NULL) {
		/*
		 *  It's compressed with the modern gzip. - FM
		 */
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " -d --no-name %s");
		compress_suffix = "gz";
d1058 9
a1066 7
	    }
	    if ((!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		 !strcasecomp(anchor->content_encoding, "bzip2")) &&
		(program = HTGetProgramPath(ppBZIP2)) != NULL) {
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " -d %s");
		compress_suffix = "bz2";
d1068 1
a1068 10
	    }
	    if ((!strcasecomp(anchor->content_encoding, "x-compress") ||
		 !strcasecomp(anchor->content_encoding, "compress")) &&
		(program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
		/*
		 *  It's compressed the old fashioned Unix way. - FM
		 */
		StrAllocCopy(uncompress_mask, program);
		StrAllocCat(uncompress_mask, " %s");
		compress_suffix = "Z";
a1070 1
	    break;
d1073 3
a1075 3
    if (can_present == FALSE ||			 /* no presentation mapping */
	uncompress_mask == NULL ||		    /* not gzip or compress */
	strchr(anchor->content_type, ';') ||		   /* wrong charset */
d1078 1
a1078 1
	(traversal &&	   /* only handle html or plain text for traversals */
d1082 2
a1083 2
	 *  Cast the Content-Encoding to a Content-Type
	 *  and pass it back to be handled as that type. - FM
d1087 3
a1089 3
	     *  Use "x-" prefix, none of the types we are likely to
	     *  construct here are official.  That is we generate
	     *  "application/x-gzip" and so on. - kw
d1100 1
a1100 1
	FREE(type)
d1107 2
a1108 2
     *	Set up the stream structure for uncompressing and then
     *	handling based on the uncompressed Content-Type.- FM
d1123 1
a1123 1
     *	Remove any old versions of the file. - FM
d1131 1
a1131 1
     *	Get a new temporary filename and substitute a suitable suffix. - FM
d1140 1
d1161 1
a1161 1
	strcat(temp, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc.*/
d1163 1
a1163 1
	strcat(temp, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc.*/
d1169 1
a1169 1
     *	Open the file for receiving the compressed input stream. - FM
d1171 1
a1171 1
    me->fp = LYOpenTemp (fnam, temp, BIN_W);
d1180 4
a1183 4
     *	me->viewer_command will be NULL if the converter Pres found above
     *	is not for an external viewer but an internal HTStream converter.
     *	We also don't set it under conditions where HTSaveAndExecute would
     *	disallow execution of the command. - KW
d1192 1
a1192 1
		!strncmp(anchor->address,"file://localhost",16))))))
d1199 1
a1199 1
     *	Make command to process file. - FM
d1212 3
a1214 2
    if (compress_suffix[0] == 'g'	/* must be gzip */
	&& !me->viewer_command) {
d1230 1
a1230 1
     *	Make command to delete file. - FM
d1237 1
a1237 1
     *	Save the filename and return the structure. - FM
d1244 6
a1249 7
**	---------------------
**
*/
PUBLIC HTStream* HTDumpToStdout ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink GCC_UNUSED)
d1251 2
a1252 1
    HTStream * ret_obj;
d1254 1
d1262 1
a1262 1
    ret_obj->fp = stdout; /* stdout*/
d1276 1
a1276 1
#define FCH$V_CONTIGB	0x005			/* pos of cont best try bit */
d1280 8
a1287 8
    unsigned char	fat$b_rtype,	fat$b_rattrib;
    unsigned short	fat$w_rsize;
    unsigned long	fat$l_hiblk,	fat$l_efblk;
    unsigned short	fat$w_ffbyte;
    unsigned char	fat$b_bktsize,	fat$b_vfcsize;
    unsigned short	fat$w_maxrec,	fat$w_defext,	fat$w_gbc;
    unsigned	: 16, : 32, : 16;   /* 6 bytes reserved, 2 bytes not used */
    unsigned short	fat$w_versions;
d1292 4
a1295 1
typedef struct dsc { unsigned short len, mbz; void *adr; } Desc;
d1297 1
a1297 1
extern unsigned long	sys$open(),  sys$qiow(),  sys$dassgn();
a1301 1

d1303 1
a1303 1
 *  25-Jul-1995 - Pat Rankin (rankin@@eql.caltech.edu)
d1305 2
a1306 2
 *  Force a file to be marked as having fixed-length, 512 byte records
 *  without implied carriage control, and with best_try_contiguous set.
d1308 1
a1308 1
PUBLIC unsigned long LYVMS_FixedLengthRecords ARGS1(char *, filename)
d1310 8
a1317 8
    struct FAB	    fab;		/* RMS file access block */
    struct fibdef   fib;		/* XQP file information block */
    struct fatdef   recattr;		/* XQP file "record" attributes */
    struct atrdef   attr_rqst_list[3];	/* XQP attribute request itemlist */

    Desc	    fib_dsc;
    unsigned short  channel,  iosb[4];
    unsigned long   fchars,  sts,  tmp;
d1334 2
a1335 1
    if (sysfail(sts)) return sts;
d1346 1
a1346 1
    memset((void *)&fib, 0, sizeof fib);
d1350 1
a1350 1
    *(void **)&attr_rqst_list[0].atr$l_addr = (void *)&recattr;
d1353 1
a1353 1
    *(void **)&attr_rqst_list[1].atr$l_addr = (void *)&fchars;
d1357 2
a1358 2
    memset((void *)&recattr, 0, sizeof recattr);
    fchars = 0;		/* file characteristics */
d1361 1
a1361 1
    sts = sys$qiow(0, channel, IO$_ACCESS, iosb, (void(*)())0, 0,
d1369 4
a1372 4
	recattr.fat$w_rsize = recattr.fat$w_maxrec = 512;   /* lrl=mrs=512 */
	recattr.fat$b_rattrib = 0;			/* rat=none */
	fchars |= FCH$M_CONTIGB;		/* contiguous-best-try */
	sts = sys$qiow(0, channel, IO$_DEACCESS, iosb, (void(*)())0, 0,
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d20 1
a20 1
#if _WIN_CC
d40 1
a40 1
#ifdef EXP_PERSISTENT_COOKIES 
d51 1
a51 1
#ifdef USE_COMMAND_FILE 	     /* Keep this as an option. - FM	*/
d139 1
a139 1
    BOOL use_gzread = NO;
d186 1
a186 1
			use_gzread = YES;
a192 1
#ifdef BZIP2_PATH
d194 9
a202 3
		    path[len-4] = '\0';
		    remove(path);
#endif /* BZIP2_PATH */
d207 1
a207 1
		if (!use_gzread) {
d265 1
a265 1
		    if (!use_gzread) {
d299 1
a299 1
			_user_message(WWW_USING_MESSAGE, addr);
d330 1
a330 1
#if _WIN_CC
d342 1
a342 1
				HTInfoMsg("Set focus1");
d386 1
a386 1
#if _WIN_CC
d399 1
a399 1
		    HTInfoMsg("Set focus2");
d418 1
a418 1
		    HTInfoMsg("Set focus3");
d422 1
a422 1
	        start_curses();
d434 8
a441 8
#ifdef EXP_PERSISTENT_COOKIES 
	/* 
	 *  We want to save cookies picked up when in source 
	 *  mode.  ... 
	 */ 
	if (persistent_cookies) 
	    LYStoreCookies(LYCookieSaveFile); 
#endif /* EXP_PERSISTENT_COOKIES */ 
d449 6
d469 1
d471 11
a614 6
#ifndef VMS
#define REMOVE_COMMAND "/bin/rm -f %s"
#else
#define REMOVE_COMMAND "delete/noconfirm/nolog %s;"
#endif /* VMS */

d684 1
a684 1
	 *  not being able to find the fp.  The ".bin" suffix is expected
d687 1
a687 1
	me->fp = LYOpenTempRewrite(fnam, ".bin", BIN_W);
d739 7
a745 9
	} else if (!strcasecomp(pres->rep->name, "text/plain")) {
	    suffix = ".txt";
	} else if (!strcasecomp(pres->rep->name,
				"application/octet-stream")) {
	    suffix = ".bin";
	} else if (
	(suffix = HTFileSuffix(pres->rep, anchor->content_encoding)) == 0
		   || *suffix != '.')
	{
d877 1
a877 1
	 *  not being able to find the fp.  The ".bin" suffix is expected
d880 1
a880 1
	ret_obj->fp = LYOpenTempRewrite(fnam, ".bin", BIN_W);
d888 4
a891 5
	} else if (!strcasecomp(pres->rep->name, "text/plain")) {
	    suffix = ".txt";
	} else if (!strcasecomp(pres->rep->name,
				    "application/octet-stream")) {
	    suffix = ".bin";
d1037 1
d1066 3
a1068 2
	    if (!strcasecomp(anchor->content_encoding, "x-gzip") ||
		!strcasecomp(anchor->content_encoding, "gzip")) {
d1072 1
a1072 1
		StrAllocCopy(uncompress_mask, GZIP_PATH);
d1075 6
a1080 4
#ifdef BZIP2_PATH
	    } else if (!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		!strcasecomp(anchor->content_encoding, "bzip2")) {
		StrAllocCopy(uncompress_mask, BZIP2_PATH);
d1083 5
a1087 3
#endif /* BZIP2_PATH */
	    } else if (!strcasecomp(anchor->content_encoding, "x-compress") ||
		       !strcasecomp(anchor->content_encoding, "compress")) {
d1091 1
a1091 1
		StrAllocCopy(uncompress_mask, UNCOMPRESS_PATH);
d1094 1
d1099 1
a1099 1
    if (can_present == FALSE || 		 /* no presentation mapping */
d1102 1
a1102 1
	HTOutputFormat == HTAtom_for("www/download") || 	/* download */
d1163 4
a1166 5
    } else if (!strcasecomp(anchor->content_type, "text/plain")) {
	middle = "txt";
    } else if (!strcasecomp(anchor->content_type,
			    "application/octet-stream")) {
	middle = "bin";
d1226 10
d1237 2
a1238 2
    if (compress_suffix[0] == 'g' && /* must be gzip */
	!me->viewer_command) {
d1240 2
a1241 2
	 *  We won't call gzip externally, so we don't need to supply
	 *  a command for it. - kw
d1378 1
a1378 1
    fchars = 0; 	/* file characteristics */
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d16 8
d35 1
d40 4
d96 3
a98 1
    putc(c, me->fp);
d108 3
a110 1
    fputs(s, me->fp);
d118 3
a120 1
    fwrite(s, 1, l, me->fp);
a134 1
    FILE *fp = NULL;
d140 6
d147 2
a148 1
    fflush(me->fp);
d176 1
a176 1
		BOOL skip_loadfile = (me->viewer_command != NULL);
d182 2
a183 5
		if ((len = strlen(path)) > 3) {
		    if (!strcasecomp(&path[len-3], "bz2")) {
			    path[len-4] = '\0';
			    remove(path);
		    } else if (!strcasecomp(&path[len-2], "gz")) {
d185 3
a187 3
			if (!skip_loadfile) {
			    use_gzread = YES;
			} else
d189 2
a190 6
			{
			    path[len-3] = '\0';
			    remove(path);
			}
		    } else if (!strcasecomp(&path[len-1], "Z")) {
			path[len-2] = '\0';
d193 8
d214 1
a214 1
		    fp = fopen(me->anchor->FileCache, "r");
d216 1
a216 1
		if (fp != NULL) {
a220 2
		    fclose(fp);
		    fp = NULL;
d223 1
a223 1
			refresh();
d226 1
a226 1
		    remove(me->anchor->FileCache);
d321 1
d323 1
d325 3
d329 1
a329 1

d334 7
a340 1
			if (!dump_output_immediately)
d342 2
d377 1
d379 1
d381 3
d385 1
d391 7
a397 1
	    if (!dump_output_immediately)
d399 2
d410 10
d429 9
a437 1
	exit_immediately(0);
d451 1
a451 1
    CTRACE(tfp,"HTFWriter_abort called\n");
d455 1
a455 1
	CTRACE(tfp, "HTFWriter: Aborting: file not executed.\n");
d490 1
a490 1
    me = (HTStream*)calloc(sizeof(*me),1);
d504 9
d518 73
a619 1

d630 1
a630 1
	if (!local_exec)
d635 1
d645 1
d653 1
a653 1
    me = (HTStream*)calloc(sizeof(*me),1);
d663 8
a670 1
	me->fp = LYNewBinFile (fnam);
d672 44
d727 4
a730 2
	} else if ((suffix = HTFileSuffix(pres->rep, anchor->content_encoding)) == 0
		   || *suffix != '.') {
d733 1
a733 1
	me->fp = LYOpenTemp(fnam, suffix, "wb");
d746 1
a746 3
    me->end_command = 0;
    HTAddParam(&(me->end_command), pres->command, 1, fnam);
    HTEndParam(&(me->end_command), pres->command, 1);
d788 1
a788 1
    ret_obj = (HTStream*)calloc(sizeof(* ret_obj),1);
d820 1
a820 1
	if (((cp=strchr(pres->rep->name, ';')) != NULL) &&
d829 2
a830 2
	while(TOUPPER(c)!='C' && TOUPPER(c)!='D' && c!=7) {
	    c=LYgetch();
d846 1
a846 1
	if (TOUPPER(c)=='C' || c==7 || c==3) {
d858 8
a865 1
	ret_obj->fp = LYNewBinFile (fnam);
d883 1
a883 1
	ret_obj->fp = LYOpenTemp(fnam, suffix, "wb");
d967 2
a968 2
	if (anchor->date && *anchor->date)
	     fprintf(ret_obj->fp,
d970 7
a1026 1
    FILE *fp = NULL;
d1051 1
a1051 6
	    if (!strcasecomp(anchor->content_encoding, "x-bzip2") ||
		!strcasecomp(anchor->content_encoding, "bzip")) {
		StrAllocCopy(uncompress_mask, BZIP2_PATH);
		StrAllocCat(uncompress_mask, " -d %s");
		compress_suffix = "bz2";
	    } else if (!strcasecomp(anchor->content_encoding, "x-gzip") ||
d1059 7
d1091 9
a1099 1
	    StrAllocCopy(type, "application/");
d1115 1
a1115 1
    me = (HTStream*)calloc(sizeof(*me),1);
d1131 1
a1131 4
	while ((fp = fopen(anchor->FileCache, "r")) != NULL) {
	    fclose(fp);
	    remove(anchor->FileCache);
	}
d1176 1
a1176 1
    me->fp = LYOpenTemp (fnam, temp, "wb");
d1247 1
a1247 1
    ret_obj = (HTStream*)calloc(sizeof(* ret_obj),1);
@


1.1
log
@Initial revision
@
text
@d11 19
a29 28
#include "HTUtils.h"
#include "tcp.h"
#include "LYCurses.h"
#include "HTFWriter.h"
#include "HTSaveToFile.h"

#include "HTFormat.h"
#include "UCDefs.h"
#include "HTAlert.h"
#include "HTFile.h"
#include "HTPlain.h"
#include "HTFile.h"
#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */
#ifdef DOSPATH
#include "HTDOS.h"
#endif

#include "LYStrings.h"
#include "LYUtils.h"
#include "LYGlobalDefs.h"
#include "LYSignal.h"
#include "LYSystem.h"
#include "GridText.h"
#include "LYexit.h"
#include "LYLeaks.h"
#include "LYKeymap.h"
d34 1
a34 1
PUBLIC char LYCancelDownload=FALSE;   /* exported to HTFormat.c in libWWW */
a36 1
extern BOOLEAN HadVMSInterrupt;      /* flag from cleanup_sig() 	*/
a50 3
#define FREE(x) if (x) {free(x); x = NULL;}


d66 1
a66 1
	int			idash; /* remember position to become '.'*/
d125 1
a125 1
	fclose(me->fp);
d133 1
a133 1
	    system(FIXED_RECORD_COMMAND);
a140 1
		/* system(me->remove_command); */
d157 5
a161 2
		if ((len = strlen(path)) > 2) {
		    if (!strcasecomp((char *)&path[len-2], "gz")) {
d171 1
a171 1
		    } else if (!strcasecomp((char *)&path[len-1], "Z")) {
d187 1
a187 1
			system(me->end_command);
d219 3
a221 1
			if (me->idash > 1 && path[me->idash] == '-') {
d223 3
a225 3
			    new_path[me->idash] = '.';
			    if (strlen(new_path + me->idash) > 4)
				new_path[me->idash + 4] = '\0';
d235 1
a235 11
		    StrAllocCopy(addr, "file://localhost");
#ifdef DOSPATH
		    StrAllocCat(addr, "/");
		    StrAllocCat(addr, HTDOS_wwwName(path));
#else
#ifdef VMS
		    StrAllocCat(addr, HTVMS_wwwName(path));
#else
		    StrAllocCat(addr, path);
#endif /* VMS */
#endif /* DOSPATH */
d237 1
d284 1
a284 1
			 *  determind when the HTCompressed stream was
d288 4
a291 10
			me->end_command = (char *)calloc (
			    (strlen (me->viewer_command) + 10 +
			     strlen(me->anchor->FileCache))
			    * sizeof (char),1);
			if (me->end_command == NULL)
			    outofmem(__FILE__, "HTFWriter_free (HTCompressed)");

			sprintf(me->end_command,
				me->viewer_command, me->anchor->FileCache,
				"", "", "", "", "", "");
d299 1
a299 1
			system(me->end_command);
a302 1
			    /* system(me->remove_command); */
a327 1
		/* system(me->remove_command); */
d342 1
a342 1
	    system(me->end_command);
a345 1
		/* system(me->remove_command); */
a356 1
		/* system(me->remove_command); */
d368 1
a368 12
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(0);
d382 2
a383 4
    if (TRACE)
	fprintf(stderr,"HTFWriter_abort called\n");

    fclose(me->fp);
d386 1
a386 2
	if (TRACE)
	    fprintf(stderr, "HTFWriter: Aborting: file not executed.\n");
d389 1
a389 1
	    system(me->remove_command);
a439 1
/* @@@@ to be written.  sprintfs will do for now.  */
d461 1
a461 1
    char fnam[256];
a462 1
    char *cp;
a463 1
    FILE *fp = NULL;
d477 1
a477 2
	    _statusline(EXECUTION_DISABLED);
	    sleep(AlertSecs);
d486 1
a486 1
		char buf[512];
d488 4
a491 4
		sprintf(buf, EXECUTION_DISABLED_FOR_FILE,
			     key_for_func(LYK_OPTIONS));
		_statusline(buf);
		sleep(AlertSecs);
d510 2
a511 8
    if (anchor->FileCache) {
	strcpy(fnam, anchor->FileCache);
	FREE(anchor->FileCache);
	if ((fp = fopen(fnam, "r")) != NULL) {
	    fclose(fp);
	    fp = NULL;
	    remove(fnam);
	}
a513 5
	 *  Lynx routine to create a temporary filename
	 */
SaveAndExecute_tempname:
	tempname (fnam, NEW_FILE);
	/*
d515 1
d517 10
a526 34
	if (((cp = strrchr(fnam, '.')) != NULL) &&
#ifdef VMS
	    NULL == strchr(cp, ']') &&
#endif /* VMS */
	    NULL == strchr(cp, '/')) {
	    /*
	     *	Save the file under a suitably suffixed name.
	     */
	    *cp = '\0';
	    if (!strcasecomp(pres->rep->name, "text/html")) {
		strcat(fnam, HTML_SUFFIX);
	    } else if (!strcasecomp(pres->rep->name, "text/plain")) {
		strcat(fnam, ".txt");
	    } else if (!strcasecomp(pres->rep->name,
				    "application/octet-stream")) {
		strcat(fnam, ".bin");
	    } else if ((suffix = HTFileSuffix(pres->rep, anchor->content_encoding))
		       && *suffix == '.') {
		strcat(fnam, suffix);
		/*
		 *  It's not one of the suffixes checked for a
		 *  spoof in tempname(), so check it now. - FM
		 */
		if (strcmp(suffix, HTML_SUFFIX) &&
		    strcmp(suffix, ".txt") &&
		    strcmp(suffix, ".bin") &&
		    (fp = fopen(fnam, "r")) != NULL) {
		    fclose(fp);
		    fp = NULL;
		    goto SaveAndExecute_tempname;
		}
	    } else {
		*cp = '.';
	    }
d528 1
a530 1
    me->fp = LYNewBinFile (fnam);
d541 3
a543 7
    me->end_command = (char *)calloc (
			(strlen (pres->command) + 10 + strlen(fnam))
			 * sizeof (char),1);
    if (me->end_command == NULL)
	outofmem(__FILE__, "HTSaveAndExecute");

    sprintf(me->end_command, pres->command, fnam, "", "", "", "", "", "");
d548 3
a550 7
    me->remove_command = (char *)calloc (
			(strlen (REMOVE_COMMAND) + 10 + strlen(fnam))
			 * sizeof (char),1);
    if (me->remove_command == NULL)
	outofmem(__FILE__, "HTSaveAndExecute");

    sprintf(me->remove_command, REMOVE_COMMAND, fnam);
d579 1
a579 1
    char fnam[256];
d582 1
a582 1
    int c=0;
a583 1
    FILE *fp = NULL;
d608 1
a608 2
		_statusline(CANNOT_DISPLAY_FILE);
		sleep(AlertSecs);
d617 1
a617 1
	if (((cp=strchr((char *)pres->rep->name, ';')) != NULL) &&
d619 3
a621 3
	    _user_message(WRONG_CHARSET_D_OR_C, (char *)pres->rep->name);
	} else if (*((char *)pres->rep->name) != '\0')	{
	    _user_message(UNMAPPED_TYPE_D_OR_C, (char *)pres->rep->name);
d654 2
a655 8
    if (anchor->FileCache) {
	strcpy(fnam, anchor->FileCache);
	FREE(anchor->FileCache);
	if ((fp = fopen(fnam, "r")) != NULL) {
	    fclose(fp);
	    fp = NULL;
	    remove(fnam);
	}
a657 5
	 *  Lynx routine to create a temporary filename
	 */
SaveToFile_tempname:
	tempname(fnam, NEW_FILE);
	/*
d659 1
d661 5
a665 14
	if (((cp=strrchr(fnam, '.')) != NULL) &&
#ifdef VMS
	    NULL == strchr(cp, ']') &&
#endif /* VMS */
	    NULL == strchr(cp, '/')) {
	    /*
	     *	Save the file under a suitably suffixed name.
	     */
	    *cp = '\0';
	    if (!strcasecomp(pres->rep->name, "text/html")) {
		strcat(fnam, HTML_SUFFIX);
	    } else if (!strcasecomp(pres->rep->name, "text/plain")) {
		strcat(fnam, ".txt");
	    } else if (!strcasecomp(pres->rep->name,
d667 5
a671 19
		strcat(fnam, ".bin");
	    } else if ((suffix = HTFileSuffix(pres->rep,
					      anchor->content_encoding)) && *suffix == '.') {
		strcat(fnam, suffix);
		/*
		 *  It's not one of the suffixes checked for a
		 *  spoof in tempname(), so check it now. - FM
		 */
		if (strcmp(suffix, HTML_SUFFIX) &&
		    strcmp(suffix, ".txt") &&
		    strcmp(suffix, ".bin") &&
		    (fp = fopen(fnam, "r")) != NULL) {
		    fclose(fp);
		    fp = NULL;
		    goto SaveToFile_tempname;
		}
	    } else {
		*cp = '.';
	    }
d673 7
a691 7
    ret_obj->fp = LYNewBinFile (fnam);
    if (!ret_obj->fp) {
	HTAlert(CANNOT_OPEN_OUTPUT);
	FREE(ret_obj);
	return NULL;
    }

d699 1
a699 2
    user_message("Content-type: %s", pres->rep->name);
    sleep(MessageSecs);
d706 3
a708 7
    ret_obj->remove_command = (char *)calloc (
			(strlen (REMOVE_COMMAND) + 10+ strlen(fnam))
			 * sizeof (char),1);
    if (ret_obj->remove_command == NULL)
	outofmem(__FILE__, "HTSaveToFile");

    sprintf(ret_obj->remove_command, REMOVE_COMMAND, fnam);
d712 5
a716 11
	ret_obj->end_command = (char *)calloc (sizeof(char)*20,1);
	if (ret_obj->end_command == NULL)
	    outofmem(__FILE__, "HTSaveToFile");
	sprintf(ret_obj->end_command, "SaveVMSBinaryFile");
	FIXED_RECORD_COMMAND = (char *)calloc (
		(strlen (FIXED_RECORD_COMMAND_MASK) + 10 + strlen(fnam))
		* sizeof (char),1);
	if (FIXED_RECORD_COMMAND == NULL)
	    outofmem(__FILE__, "HTSaveToFile");
	sprintf(FIXED_RECORD_COMMAND,
		FIXED_RECORD_COMMAND_MASK, fnam, "", "", "", "", "", "");
d719 1
a719 4
    ret_obj->end_command = (char *)calloc (sizeof(char)*12,1);
    if (ret_obj->end_command == NULL)
	outofmem(__FILE__, "HTSaveToFile");
    sprintf(ret_obj->end_command, "SaveToFile");
d738 2
d749 1
a749 1
	    collapse_spaces(temp);
d756 6
a761 2
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		anchor->address, (temp ? temp : anchor->address));
d780 2
a781 2
	    collapse_spaces(temp);
		fprintf(ret_obj->fp,
d804 2
a805 1
    char fnam[256];
a808 1
    char *cp;
d813 1
a813 1
     *	Deal with any inappropriate invokations of this function,
d835 6
a840 1
	    if (!strcasecomp(anchor->content_encoding, "x-gzip") ||
d897 3
d915 12
a926 15
Compressed_tempname:
    tempname(fnam, NEW_FILE);
    if ((cp = strrchr(fnam, '.')) != NULL) {
	middle = NULL;
	if (!strcasecomp(anchor->content_type, "text/html")) {
	    middle = HTML_SUFFIX;
	    middle++;		/* point to 'h' of .htm(l) - kw */
	} else if (!strcasecomp(anchor->content_type, "text/plain")) {
	    middle = "txt";
	} else if (!strcasecomp(anchor->content_type,
				"application/octet-stream")) {
	    middle = "bin";
	} else if ((suffix =
		    HTFileSuffix(HTAtom_for(anchor->content_type), NULL)) &&
		   *suffix == '.') {
d928 1
a928 1
	    if (strchr(suffix + 1, '.') == NULL)
d930 5
a934 4
		middle = suffix + 1;
	}
	if (middle) {
	    *cp = '\0';
d936 2
a937 2
	    me->idash = strlen(fnam);	  /* remember position of '-'  - kw */
	    strcat(fnam, "-");	/* NAME-htm,  NAME-txt, etc. - hack for DOS */
d939 1
a939 1
	    strcat(fnam, ".");	/* NAME.html, NAME-txt etc. */
d941 1
a941 1
	    strcat(fnam, middle);
d943 1
a943 1
	    strcat(fnam, "-");	/* NAME.html-gz, NAME.txt-gz, NAME.txt-Z etc.*/
d945 1
a945 1
	    strcat(fnam, ".");	/* NAME-htm.gz (DOS), NAME.html.gz (UNIX)etc.*/
a946 15
	} else {
	    *(cp + 1) = '\0';
	}
    } else {
	strcat(fnam, ".");
    }
    strcat(fnam, compress_suffix);
    /*
     *	It's not one of the suffixes checked for a
     *	spoof in tempname(), so check it now. - FM
     */
    if ((fp = fopen(fnam, "r")) != NULL) {
	fclose(fp);
	fp = NULL;
	goto Compressed_tempname;
d948 1
d953 1
a953 1
    me->fp = LYNewBinFile (fnam);
d994 3
a996 5
	me->end_command = (char *)calloc(1, (strlen(uncompress_mask) + 10 +
					     strlen(fnam)) * sizeof(char));
	if (me->end_command == NULL)
	    outofmem(__FILE__, "HTCompressed");
	sprintf(me->end_command, uncompress_mask, fnam, "", "", "", "", "", "");
d1003 3
a1005 5
    me->remove_command = (char *)calloc(1, (strlen(REMOVE_COMMAND) + 10 +
					    strlen(fnam)) * sizeof(char));
    if (me->remove_command == NULL)
	outofmem(__FILE__, "HTCompressed");
    sprintf(me->remove_command, REMOVE_COMMAND, fnam);
d1107 1
a1107 1
    /* set up ACP interface strutures */
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
