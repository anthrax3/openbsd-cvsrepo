head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.6
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.14
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.12
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.10
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.25;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2011.02.16.21.22.24;	author pirofti;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.27.19.24.18;	author moritz;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.21.17.04.47;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.46;	author avsm;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.05.01.18.59.38;	author avsm;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2000.03.25.18.17.05;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.58;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.58;	author maja;	state Exp;
branches;
next	;

1.3.2.1
date	2004.11.06.04.19.29;	author brad;	state Exp;
branches;
next	;

1.3.4.1
date	2004.11.06.04.00.44;	author brad;	state Exp;
branches;
next	;

1.4.2.1
date	2004.11.06.05.06.25;	author brad;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: GridText.c,v 1.277 2014/02/13 19:32:01 tom Exp $
 *
 *		Character grid hypertext object
 *		===============================
 */

#include <HTUtils.h>
#include <HTString.h>
#include <HTAccess.h>
#include <HTAnchor.h>
#include <HTParse.h>
#include <HTTP.h>
#include <HTAlert.h>
#include <HTCJK.h>
#include <HTFile.h>
#include <UCDefs.h>
#include <UCAux.h>
#include <HText.h>

#include <assert.h>

#include <GridText.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYStructs.h>
#include <LYGlobalDefs.h>
#include <LYGetFile.h>
#include <LYClean.h>
#include <LYMail.h>
#include <LYList.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>	/* LYUCTranslateBack... */
#include <UCMap.h>
#include <LYEdit.h>
#include <LYPrint.h>
#include <LYPrettySrc.h>
#include <LYSearch.h>
#include <TRSTable.h>
#include <LYHistory.h>
#ifdef EXP_CHARTRANS_AUTOSWITCH
#include <UCAuto.h>
#endif /* EXP_CHARTRANS_AUTOSWITCH */

#include <LYexit.h>
#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>

#endif

#include <LYJustify.h>

#define is_CJK2(b) (IS_CJK_TTY && is8bits(UCH(b)))

#ifdef USE_CURSES_PADS
#  define DISPLAY_COLS    (LYwideLines ? MAX_COLS : LYcols)
#  define WRAP_COLS(text) ((text)->stbl ?				\
			   (LYtableCols <= 0				\
			    ? DISPLAY_COLS				\
			    : (LYtableCols * LYcols)/12) - LYbarWidth	\
			   : LYcolLimit)
#else
#  define DISPLAY_COLS    LYcols
#  define WRAP_COLS(text) LYcolLimit
#endif

#define FirstHTLine(text) ((text)->last_line->next)
#define LastHTLine(text)  ((text)->last_line)

static void HText_trimHightext(HText *text, int final, int stop_before);

#define IS_UTF_EXTRA(ch) (text->T.output_utf8 && \
			  (UCH((ch))&0xc0) == 0x80)

#define IS_UTF8_EXTRA(ch) (!(text && text->T.output_utf8) || \
			  !is8bits(ch) || \
			  (UCH(line->data[i] & 0xc0) == 0xc0))

/* a test in compact form: how many extra UTF-8 chars after initial? - kw */
#define UTF8_XNEGLEN(c) (c&0xC0? 0 :c&32? 1 :c&16? 2 :c&8? 3 :c&4? 4 :c&2? 5:0)
#define UTF_XLEN(c) UTF8_XNEGLEN(((char)~(c)))

#ifdef KANJI_CODE_OVERRIDE
HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
#endif

#ifdef CJK_EX
#define CHAR_WIDTH 6
#else
#define CHAR_WIDTH 1
#endif

/*	Exports
*/
HText *HTMainText = NULL;	/* Equivalent of main window */
HTParentAnchor *HTMainAnchor = NULL;	/* Anchor for HTMainText */

const char *HTAppName = LYNX_NAME;	/* Application name */
const char *HTAppVersion = LYNX_VERSION;	/* Application version */

static int HTFormNumber = 0;
static int HTFormFields = 0;
static char *HTCurSelectGroup = NULL;	/* Form select group name */
static int HTCurSelectGroupCharset = -1;	/* ... and name's charset */
int HTCurSelectGroupType = F_RADIO_TYPE;	/* Group type */
char *HTCurSelectGroupSize = NULL;	/* Length of select */
static char *HTCurSelectedOptionValue = NULL;	/* Select choice */

const char *checked_box = "[X]";
const char *unchecked_box = "[ ]";
const char *checked_radio = "(*)";
const char *unchecked_radio = "( )";

static BOOLEAN underline_on = FALSE;
static BOOLEAN bold_on = FALSE;

#ifdef USE_SOURCE_CACHE
int LYCacheSource = SOURCE_CACHE_NONE;
int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
#endif

#ifdef USE_SCROLLBAR
BOOLEAN LYShowScrollbar = FALSE;
BOOLEAN LYsb_arrow = TRUE;
int LYsb_begin = -1;
int LYsb_end = -1;
#endif

#ifndef VMS			/* VMS has a better way - right? - kw */
#define CHECK_FREE_MEM
#endif

#ifdef CHECK_FREE_MEM
static void *LY_check_calloc(size_t nmemb, size_t size);

#define LY_CALLOC LY_check_calloc
#else
  /* using the regular calloc */
#define LY_CALLOC calloc
#endif

/*
 * The HTPool.data[] array has to align the same as malloc() would, to make the
 * ALLOC_POOL scheme portable.  For many platforms, that is the same as the
 * number of bytes in a pointer.  It may be larger, e.g., on machines which
 * have more stringent requirements for floating point.  32-bits are plenty for
 * representing styles, but we may need 64-bit or 128-bit alignment.
 *
 * The real issue is that performance is degraded if the alignment is not met,
 * and some platforms such as Tru64 generate lots of warning messages.
 */
#ifndef ALIGN_SIZE
#define ALIGN_SIZE      sizeof(double)
#endif

typedef struct {
    unsigned int sc_direction:2;	/* on or off */
    unsigned int sc_horizpos:14;	/* horizontal position of this change */
    unsigned int sc_style:16;	/* which style to change to */
} HTStyleChange;

#if defined(USE_COLOR_STYLE)
#define MAX_STYLES_ON_LINE   64
  /* buffers used when current line is being aggregated, in split_line() */
static HTStyleChange stylechanges_buffers[2][MAX_STYLES_ON_LINE];
#endif

typedef HTStyleChange pool_data;

enum {
    POOL_SIZE = ((8192
		  - 4 * sizeof(void *)
		  - sizeof(struct _HTPool *)
		  - sizeof(int))
		 / sizeof(pool_data))
};

typedef struct _HTPool {
    pool_data data[POOL_SIZE];
    struct _HTPool *prev;
    unsigned used;
} HTPool;

/************************************************************************
These are generic macros for any pools (provided those structures have the
same members as HTPool).  Pools are used for allocation of groups of
objects of the same type T.  Pools are represented as a list of structures of
type P (called pool chunks here).  Structure P has an array of N objects of
type T named 'data' (the number N in the array can be chosen arbitrary),
pointer to the previous pool chunk named 'prev', and the number of used items
in that pool chunk named 'used'.  Here is a definition of the structure P:
	struct P
	{
	    T data[N];
	    struct P* prev;
	    int used;
	};
 It's recommended that sizeof(P) be memory page size minus 32 in order malloc'd
chunks to fit in machine page size.
 Allocation of 'n' items in the pool is implemented by incrementing member
'used' by 'n' if (used+n <= N), or malloc a new pool chunk and
allocating 'n' items in that new chunk.  It's the task of the programmer to
assert that 'n' is <= N.  Only entire pool may be freed - this limitation makes
allocation algorithms trivial and fast - so the use of pools is limited to
objects that are freed in batch, that are not deallocated not in the batch, and
not reallocated.
 Pools greatly reduce memory fragmentation and memory allocation/deallocation
speed due to the simple algorithms used.  Due to the fact that memory is
'allocated' in array, alignment overhead is minimal.  Allocating strings in a
pool provided their length will never exceed N and is much smaller than N seems
to be very efficient.
 [Several types of memory-hungry objects are stored in the pool now:  styles,
lines, anchors, and FormInfo. Arrays of HTStyleChange are stored as is,
other objects are stored using a cast.]

 Pool is referenced by the pointer to the last chunk that contains free slots.
Functions that allocate memory in the pool update that pointer if needed.
There are 3 functions - POOL_NEW, POOL_FREE, and ALLOC_IN_POOL.

      - VH

*************************************************************************/

#define POOLallocstyles(ptr, n)     ptr = ALLOC_IN_POOL(&HTMainText->pool, (unsigned) ((n) * sizeof(pool_data)))
#define POOLallocHTLine(ptr, size)  ptr = (HTLine*) ALLOC_IN_POOL(&HTMainText->pool, (unsigned) LINE_SIZE(size))
#define POOLallocstring(ptr, len)   ptr = (char*) ALLOC_IN_POOL(&HTMainText->pool, (unsigned) ((len) + 1))
#define POOLtypecalloc(T, ptr)      ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, (unsigned) sizeof(T))

/**************************************************************************/
/*
 * Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 * Returns a pointer to the "allocated" memory if successful.
 * Updates 'poolptr' if necessary.
 */
static void *ALLOC_IN_POOL(HTPool ** ppoolptr, unsigned request)
{
    HTPool *pool = *ppoolptr;
    pool_data *ptr;
    unsigned n;
    unsigned j;

    if (!pool) {
	outofmem(__FILE__, "ALLOC_IN_POOL");
    } else {
	n = request;
	if (n == 0)
	    n = 1;
	j = (n % ALIGN_SIZE);
	if (j != 0)
	    n += (unsigned) (ALIGN_SIZE - j);
	n /= sizeof(pool_data);

	if (POOL_SIZE >= (pool->used + n)) {
	    ptr = pool->data + pool->used;
	    pool->used += n;
	} else {
	    HTPool *newpool = (HTPool *) LY_CALLOC((size_t) 1, sizeof(HTPool));

	    if (!newpool) {
		outofmem(__FILE__, "ALLOC_IN_POOL");
	    } else {
		newpool->prev = pool;
		newpool->used = n;
		ptr = newpool->data;
		*ppoolptr = newpool;
	    }
	}
    }
    return ptr;
}

/*
 * Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
 */
static HTPool *POOL_NEW(void)
{
    HTPool *poolptr = (HTPool *) LY_CALLOC((size_t) 1, sizeof(HTPool));

    if (poolptr) {
	poolptr->prev = NULL;
	poolptr->used = 0;
    }
    return poolptr;
}

/*
 * Frees a pool of type 'HTPool' pointed by poolptr.
 */
static void POOL_FREE(HTPool * poolptr)
{
    HTPool *cur = poolptr;
    HTPool *prev;

    while (cur) {
	prev = cur->prev;
	free(cur);
	cur = prev;
    }
}

/**************************************************************************/
/**************************************************************************/

typedef struct _line {
    struct _line *next;
    struct _line *prev;
    unsigned short offset;	/* Implicit initial spaces */
    unsigned short size;	/* Number of characters */
#if defined(USE_COLOR_STYLE)
    HTStyleChange *styles;
    unsigned short numstyles;
#endif
    char data[1];		/* Space for terminator at least! */
} HTLine;

    /* Allow for terminator */
#define LINE_SIZE(size) (sizeof(HTLine) + (size_t)(size))

#ifndef HTLINE_NOT_IN_POOL
#define HTLINE_NOT_IN_POOL 0	/* debug with this set to 1 */
#endif

#if HTLINE_NOT_IN_POOL
#define allocHTLine(ptr, size)  { ptr = (HTLine *)calloc(1, LINE_SIZE(size)); }
#define freeHTLine(self, ptr)   { \
	if (ptr && ptr != TEMP_LINE(self, 0) && ptr != TEMP_LINE(self, 1)) \
	    FREE(ptr); \
    }
#else
#define allocHTLine(ptr, size)  POOLallocHTLine(ptr, size)
#define freeHTLine(self, ptr)   {}
#endif

/*
 * Last line buffer; the second is used in split_line(). Not in pool!
 * We cannot wrap in middle of multibyte sequences, so allocate 2 extra
 * for a workspace.  This is stored in the HText, to prevent confusion
 * between different documents.  Note also that it is declared with an
 * HTLine at the beginning so pointers will be properly aligned.
 */
typedef struct {
    HTLine base;
    char data[MAX_LINE + 2];
} HTLineTemp;

#define TEMP_LINE(p,n) ((HTLine *)&(p->temp_line[n]))

typedef struct _TextAnchor {
    struct _TextAnchor *next;
    struct _TextAnchor *prev;	/* www_user_search only! */
    int sgml_offset;		/* used for updating position after reparsing */
    int number;			/* For user interface */
    int show_number;		/* For user interface (unique-urls) */
    int line_num;		/* Place in document */
    short line_pos;		/* Bytes/chars - extent too */
    short extent;		/* (see HText_trimHightext) */
    BOOL show_anchor;		/* Show the anchor? */
    BOOL inUnderline;		/* context is underlined */
    BOOL expansion_anch;	/* TEXTAREA edit new anchor */
    char link_type;		/* Normal, internal, or form? */
    FormInfo *input_field;	/* Info for form links */
    HiliteList lites;

    HTChildAnchor *anchor;
} TextAnchor;

typedef struct {
    char *name;			/* ID value of TAB */
    int column;			/* Zero-based column value */
} HTTabID;

typedef enum {
    S_text,
    S_esc,
    S_dollar,
    S_paren,
    S_nonascii_text,
    S_dollar_paren,
    S_jisx0201_text
} eGridState;			/* Escape sequence? */

#ifdef USE_TH_JP_AUTO_DETECT
typedef enum {			/* Detected Kanji code */
    DET_SJIS,
    DET_EUC,
    DET_NOTYET,
    DET_MIXED
} eDetectedKCode;

typedef enum {
    SJIS_state_neutral,
    SJIS_state_in_kanji,
    SJIS_state_has_bad_code
} eSJIS_status;

typedef enum {
    EUC_state_neutral,
    EUC_state_in_kanji,
    EUC_state_in_kana,
    EUC_state_has_bad_code
} eEUC_status;
#endif

/*	Notes on struct _HText:
 *	next_line is valid if stale is false.
 *	top_of_screen line means the line at the top of the screen
 *			or just under the title if there is one.
 */
struct _HText {
    HTParentAnchor *node_anchor;

    HTLine *last_line;
    HTLineTemp temp_line[2];
    int Lines;			/* Number of them */
    TextAnchor *first_anchor;	/* double-linked on demand */
    TextAnchor *last_anchor;
    TextAnchor *last_anchor_before_stbl;
    TextAnchor *last_anchor_before_split;
    HTList *forms;		/* also linked internally */
    int last_anchor_number;	/* user number */
    BOOL source;		/* Is the text source? */
    BOOL toolbar;		/* Toolbar set? */
    HTList *tabs;		/* TAB IDs */
    HTList *hidden_links;	/* Content-less links ... */
    int hiddenlinkflag;		/*  ... and how to treat them */
    BOOL no_cache;		/* Always refresh? */
    char LastChar;		/* For absorbing white space */

/* For Internal use: */
    HTStyle *style;		/* Current style */
    int display_on_the_fly;	/* Lines left */
    int top_of_screen;		/* Line number */
    HTLine *top_of_screen_line;	/* Top */
    HTLine *next_line;		/* Bottom + 1 */
    unsigned permissible_split;	/* in last line */
    BOOL in_line_1;		/* of paragraph */
    BOOL stale;			/* Must refresh */
    BOOL page_has_target;	/* has target on screen */
    BOOL has_utf8;		/* has utf-8 on screen or line */
    BOOL had_utf8;		/* had utf-8 when last displayed */
    int next_number;		/* next a->number value */
#ifdef DISP_PARTIAL
    int first_lineno_last_disp_partial;
    int last_lineno_last_disp_partial;
#endif
    STable_info *stbl;
    HTList *enclosed_stbl;

    HTkcode kcode;		/* Kanji code? */
    HTkcode specified_kcode;	/* Specified Kanji code */
#ifdef USE_TH_JP_AUTO_DETECT
    eDetectedKCode detected_kcode;
    eSJIS_status SJIS_status;
    eEUC_status EUC_status;
#endif
    eGridState state;		/* Escape sequence? */
    int kanji_buf;		/* Lead multibyte */
    int in_sjis;		/* SJIS flag */
    int halted;			/* emergency halt */

    BOOL have_8bit_chars;	/* Any non-ASCII chars? */
    LYUCcharset *UCI;		/* node_anchor UCInfo */
    int UCLYhndl;		/* charset we are fed */
    UCTransParams T;

    HTStream *target;		/* Output stream */
    HTStreamClass targetClass;	/* Output routines */

    HTPool *pool;		/* this HText memory pool */

#ifdef USE_SOURCE_CACHE
    /*
     * Parse settings when this HText was generated.
     */
    BOOL clickable_images;
    BOOL pseudo_inline_alts;
    BOOL verbose_img;
    BOOL raw_mode;
    BOOL historical_comments;
    BOOL minimal_comments;
    BOOL soft_dquotes;
    short old_dtd;
    short keypad_mode;
    short disp_lines;		/* Screen size */
    short disp_cols;		/* Used for reports only */
#endif
};

/* exported */
void *HText_pool_calloc(HText *text, unsigned size)
{
    return (void *) ALLOC_IN_POOL(&text->pool, size);
}

static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor);

#ifdef USE_JUSTIFY_ELTS
BOOL can_justify_here;
BOOL can_justify_here_saved;

BOOL can_justify_this_line;	/* =FALSE if line contains form objects */
int wait_for_this_stacked_elt;	/* -1 if can justify contents of the

				   element on the op of stack. If positive - specifies minimal stack depth
				   plus 1 at which we can justify element (can be MAX_LINE+2 if
				   ok_justify ==FALSE or in psrcview. */
BOOL form_in_htext;		/*to indicate that we are in form (since HTML_FORM is

				   not stacked in the HTML.c */
BOOL in_DT = FALSE;

#ifdef DEBUG_JUSTIFY
BOOL can_justify_stack_depth;	/* can be 0 or 1 if all code is correct */
#endif

typedef struct {
    int byte_len;		/*length in bytes */
    int cell_len;		/*length in cells */
} ht_run_info;

static int justify_start_position;	/* this is an index of char from which

					   justification can start (eg after "* " preceeding <li> text) */

static int ht_num_runs;		/*the number of runs filled */
static ht_run_info ht_runs[MAX_LINE];
static BOOL this_line_was_split;
static TextAnchor *last_anchor_of_previous_line;
static BOOL have_raw_nbsps = FALSE;

void ht_justify_cleanup(void)
{
    wait_for_this_stacked_elt = !ok_justify
#  ifdef USE_PRETTYSRC
	|| psrc_view
#  endif
	? 30000 /*MAX_NESTING */  + 2	/*some unreachable value */
	: -1;
    can_justify_here = TRUE;
    can_justify_this_line = TRUE;
    form_in_htext = FALSE;

    last_anchor_of_previous_line = NULL;
    this_line_was_split = FALSE;
    in_DT = FALSE;
    have_raw_nbsps = FALSE;
}

void mark_justify_start_position(void *text)
{
    if (text && ((HText *) text)->last_line)
	justify_start_position = ((HText *) text)->last_line->size;
}

#define REALLY_CAN_JUSTIFY(text) ( (wait_for_this_stacked_elt<0) && \
	( text->style->alignment == HT_LEFT     || \
	  text->style->alignment == HT_JUSTIFY) && \
	!IS_CJK_TTY && !in_DT && \
	can_justify_here && can_justify_this_line && !form_in_htext )

#endif /* USE_JUSTIFY_ELTS */

/*
 * Boring static variable used for moving cursor across
 */
#define UNDERSCORES(n) \
 ((n) >= MAX_LINE ? underscore_string : &underscore_string[(MAX_LINE-1)] - (n))

static char underscore_string[MAX_LINE + 1];
char star_string[MAX_LINE + 1];

static int ctrl_chars_on_this_line = 0;		/* num of ctrl chars in current line */
static int utfxtra_on_this_line = 0;	/* num of UTF-8 extra bytes in line,

					   they *also* count as ctrl chars. */
#ifdef WIDEC_CURSES
#define UTFXTRA_ON_THIS_LINE 0
#else
#define UTFXTRA_ON_THIS_LINE utfxtra_on_this_line
#endif

static HTStyle default_style =
{0, NULL, "(Unstyled)", 0, NULL, "",
 (HTFont) 0, 1, HT_BLACK, 0, 0,
 0, 0, 0, HT_LEFT, 1, 0, 0,
 NO, NO, 0, 0, 0};

static HTList *loaded_texts = NULL;	/* A list of all those in memory */
HTList *search_queries = NULL;	/* isindex and whereis queries   */

#ifdef LY_FIND_LEAKS
static void free_all_texts(void);
#endif

static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, int IgnoreSpaces);

static int HText_TrueLineSize(HTLine *line, HText *text, int IgnoreSpaces);

#ifdef CHECK_FREE_MEM

/*
 * text->halted = 1: have set fake 'Z' and output a message
 *		  2: next time when HText_appendCharacter is called
 *		     it will append *** MEMORY EXHAUSTED ***, then set
 *		     to 3.
 *		  3: normal text output will be suppressed (but not anchors,
 *		     form fields etc.)
 */
static void HText_halt(void)
{
    if (HTFormNumber > 0)
	HText_DisableCurrentForm();
    if (!HTMainText)
	return;
    if (HTMainText->halted < 2)
	HTMainText->halted = 2;
}

#define MIN_NEEDED_MEM 5000

/*
 * Check whether factor*min(bytes,MIN_NEEDED_MEM) is available,
 * or bytes if factor is 0.
 * MIN_NEEDED_MEM and factor together represent a security margin,
 * to take account of all the memory allocations where we don't check
 * and of buffers which may be emptied before HTCheckForInterupt()
 * is (maybe) called and other things happening, with some chance of
 * success.
 * This just tries to malloc() the to-be-checked-for amount of memory,
 * which might make the situation worse depending how allocation works.
 * There should be a better way...  - kw
 */
static BOOL mem_is_avail(int factor, size_t bytes)
{
    void *p;

    if (bytes < MIN_NEEDED_MEM && factor > 0)
	bytes = MIN_NEEDED_MEM;
    if (factor == 0)
	factor = 1;
    p = malloc((size_t) factor * bytes);
    if (p) {
	FREE(p);
	return YES;
    } else {
	return NO;
    }
}

/*
 * Replacement for calloc which checks for "enough" free memory
 * (with some security margins) and tries various recovery actions
 * if deemed necessary.  - kw
 */
static void *LY_check_calloc(size_t nmemb, size_t size)
{
    int i, n;

    if (mem_is_avail(4, nmemb * size)) {
	return (calloc(nmemb, size));
    }
    n = HTList_count(loaded_texts);
    for (i = n - 1; i > 0; i--) {
	HText *t = (HText *) HTList_objectAt(loaded_texts, i);

	CTRACE((tfp,
		"\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
		i + 1, n,
		((t && t->node_anchor &&
		  t->node_anchor->address) ?
		 t->node_anchor->address : "unknown anchor"),
		((t && t->node_anchor &&
		  t->node_anchor->post_data) ?
		 " with POST data" : "")));
	HTList_removeObjectAt(loaded_texts, i);
	HText_free(t);
	if (mem_is_avail(4, nmemb * size)) {
	    return (calloc(nmemb, size));
	}
    }
    LYFakeZap(YES);
    if (!HTMainText || HTMainText->halted <= 1) {
	if (!mem_is_avail(2, nmemb * size)) {
	    HText_halt();
	    if (mem_is_avail(0, (size_t) 700)) {
		HTAlert(gettext("Memory exhausted, display interrupted!"));
	    }
	} else {
	    if ((!HTMainText || HTMainText->halted == 0) &&
		mem_is_avail(0, (size_t) 700)) {
		HTAlert(gettext("Memory exhausted, will interrupt transfer!"));
		if (HTMainText)
		    HTMainText->halted = 1;
	    }
	}
    }
    return (calloc(nmemb, size));
}

#endif /* CHECK_FREE_MEM */

#ifdef USE_COLOR_STYLE
/*
 * Color style information is stored with the multibyte-character offset into
 * the string at which the style would apply.  Compute the corresponding column
 * so we can compare it with the updated column value after writing strings
 * with curses.
 *
 * The offsets count multibyte characters.  Other parts of the code assume each
 * character uses one cell, but some CJK (or UTF-8) codes use two cells.  We
 * need to know the number of cells.
 */
static int StyleToCols(HText *text, HTLine *line, int nstyle)
{
    int result = line->offset;	/* this much is spaces one byte/cell */
    int nchars = line->styles[nstyle].sc_horizpos;
    char *data = line->data;
    char *last = line->size + data;
    int utf_extra;

    while (nchars > 0 && data < last) {
	if (IsSpecialAttrChar(*data) && *data != LY_SOFT_NEWLINE) {
	    ++data;
	} else {
	    utf_extra = (int) utf8_length(text->T.output_utf8, data);
	    if (utf_extra++) {
		result += LYstrExtent(data, utf_extra, 2);
		data += utf_extra;
	    } else if (is_CJK2(*data)) {
		data += 2;
		result += 2;
	    } else {
		++data;
		++result;
	    }
	    --nchars;
	}
    }

    return result;
}
#endif

/*
 * Clear highlight information for a given anchor
 * (text was allocated in the pool).
 */
static void LYClearHiText(TextAnchor *a)
{
    FREE(a->lites.hl_info);

    a->lites.hl_base.hl_text = NULL;
    a->lites.hl_len = 0;
}

#define LYFreeHiText(a)     FREE((a)->lites.hl_info)

/*
 * Set the initial highlight information for a given anchor.
 */
static void LYSetHiText(TextAnchor *a,
			const char *text,
			unsigned len)
{
    if (text != NULL) {
	POOLallocstring(a->lites.hl_base.hl_text, len + 1);
	memcpy(a->lites.hl_base.hl_text, text, (size_t) len);
	*(a->lites.hl_base.hl_text + len) = '\0';

	a->lites.hl_len = 1;
    }
}

/*
 * Add highlight information for the next line of a anchor.
 */
static void LYAddHiText(TextAnchor *a,
			const char *text,
			int x)
{
    HiliteInfo *have = a->lites.hl_info;
    size_t need = (unsigned) (a->lites.hl_len - 1);
    size_t want;

    a->lites.hl_len = (short) (a->lites.hl_len + 1);
    want = (size_t) (a->lites.hl_len) * sizeof(HiliteInfo);
    if (have != NULL) {
	have = (HiliteInfo *) realloc(have, want);
    } else {
	have = (HiliteInfo *) malloc(want);
    }
    a->lites.hl_info = have;

    POOLallocstring(have[need].hl_text, strlen(text) + 1);
    strcpy(have[need].hl_text, text);
    have[need].hl_x = (short) x;
}

/*
 * Return an offset to skip leading blanks in the highlighted link.  That is
 * needed to avoid having the color-style paint the leading blanks.
 */
#ifdef USE_COLOR_STYLE
static int LYAdjHiTextPos(TextAnchor *a, int count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;

    return (result != 0) ? (int) (LYSkipBlanks(result) - result) : 0;
}

#else
#define LYAdjHiTextPos(a,count) 0
#endif

/*
 * Get the highlight text, counting from zero.
 */
static char *LYGetHiTextStr(TextAnchor *a, int count)
{
    char *result;

    if (count >= a->lites.hl_len)
	result = NULL;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_text;
    else
	result = a->lites.hl_base.hl_text;
    result += LYAdjHiTextPos(a, count);
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
static int LYGetHiTextPos(TextAnchor *a, int count)
{
    int result;

    if (count >= a->lites.hl_len)
	result = -1;
    else if (count > 0)
	result = a->lites.hl_info[count - 1].hl_x;
    else
	result = a->line_pos;
    result += LYAdjHiTextPos(a, count);
    return result;
}

/*
 * Copy highlighting information from anchor 'b' to 'a'.
 */
static void LYCopyHiText(TextAnchor *a, TextAnchor *b)
{
    int count;
    char *s;

    LYClearHiText(a);
    for (count = 0;; ++count) {
	if ((s = LYGetHiTextStr(b, count)) == NULL)
	    break;
	if (count == 0) {
	    LYSetHiText(a, s, (unsigned) strlen(s));
	} else {
	    LYAddHiText(a, s, LYGetHiTextPos(b, count));
	}
    }
}

static void HText_getChartransInfo(HText *me)
{
    me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, UCT_STAGE_HTEXT);
    if (me->UCLYhndl < 0) {
	int chndl = current_char_set;

	HTAnchor_setUCInfoStage(me->node_anchor, chndl,
				UCT_STAGE_HTEXT, UCT_SETBY_STRUCTURED);
	me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					    UCT_STAGE_HTEXT);
    }
    me->UCI = HTAnchor_getUCInfoStage(me->node_anchor, UCT_STAGE_HTEXT);
}

static void PerFormInfo_free(PerFormInfo * form)
{
    if (form) {
	FREE(form->data.submit_action);
	FREE(form->data.submit_enctype);
	FREE(form->data.submit_title);
	FREE(form->accept_cs);
	FREE(form->thisacceptcs);
	FREE(form);
    }
}

static void free_form_fields(FormInfo * input_field)
{
    /*
     * Free form fields.
     */
    if (input_field->type == F_OPTION_LIST_TYPE &&
	input_field->select_list != NULL) {
	/*
	 * Free off option lists if present.
	 * It should always be present for F_OPTION_LIST_TYPE
	 * unless we had invalid markup which prevented
	 * HText_setLastOptionValue from finishing its job
	 * and left the input field in an insane state.  - kw
	 */
	OptionType *optptr = input_field->select_list;
	OptionType *tmp;

	while (optptr) {
	    tmp = optptr;
	    optptr = tmp->next;
	    FREE(tmp->name);
	    FREE(tmp->cp_submit_value);
	    FREE(tmp);
	}
	input_field->select_list = NULL;
	/*
	 * Don't free the value field on option
	 * lists since it points to a option value
	 * same for orig value.
	 */
	input_field->value = NULL;
	input_field->orig_value = NULL;
	input_field->cp_submit_value = NULL;
	input_field->orig_submit_value = NULL;
    } else {
	FREE(input_field->value);
	FREE(input_field->orig_value);
	FREE(input_field->cp_submit_value);
	FREE(input_field->orig_submit_value);
    }
    FREE(input_field->name);
    FREE(input_field->submit_action);
    FREE(input_field->submit_enctype);
    FREE(input_field->submit_title);

    FREE(input_field->accept_cs);
}

static void FormList_delete(HTList *forms)
{
    HTList *cur = forms;
    PerFormInfo *form;

    while ((form = (PerFormInfo *) HTList_nextObject(cur)) != NULL)
	PerFormInfo_free(form);
    HTList_delete(forms);
}

#ifdef DISP_PARTIAL
static void ResetPartialLinenos(HText *text)
{
    if (text != 0) {
	text->first_lineno_last_disp_partial = -1;
	text->last_lineno_last_disp_partial = -1;
    }
}
#endif

/*			Creation Method
 *			---------------
 */
HText *HText_new(HTParentAnchor *anchor)
{
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
#include <lib$routines.h>
    int status, VMType = 3, VMTotal;
#endif /* VMS && VAXC && !__DECC */
    HTLine *line = NULL;
    HText *self = typecalloc(HText);

    if (!self)
	outofmem(__FILE__, "HText_New");

    CTRACE((tfp, "GridText: start HText_new\n"));

#if defined(VMS) && defined (VAXC) && !defined(__DECC)
    status = lib$stat_vm(&VMType, &VMTotal);
    CTRACE((tfp, "GridText: VMTotal = %d\n", VMTotal));
#endif /* VMS && VAXC && !__DECC */

    /*
     * If the previously shown text had UTF-8 characters on screen,
     * remember this in the newly created object.  Do this now, before
     * the previous object may become invalid.  - kw
     */
    if (HTMainText) {
	if (HText_hasUTF8OutputSet(HTMainText) &&
	    HTLoadedDocumentEightbit() &&
	    IS_UTF8_TTY) {
	    self->had_utf8 = HTMainText->has_utf8;
	} else {
	    self->had_utf8 = HTMainText->has_utf8;
	}
	HTMainText->has_utf8 = NO;
    }

    if (!loaded_texts) {
	loaded_texts = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(free_all_texts);
#endif
    }

    /*
     * Links between anchors & documents are a 1-1 relationship.  If
     * an anchor is already linked to a document we didn't call
     * HTuncache_current_document(), so we'll check now
     * and free it before reloading.  - Dick Wesseling (ftu@@fi.ruu.nl)
     */
    if (anchor->document) {
	HTList_removeObject(loaded_texts, anchor->document);
	CTRACE((tfp, "GridText: Auto-uncaching\n"));

	HTAnchor_delete_links(anchor);
	((HText *) anchor->document)->node_anchor = NULL;
	HText_free((HText *) anchor->document);
	anchor->document = NULL;
    }

    HTList_addObject(loaded_texts, self);
#if defined(VMS) && defined(VAXC) && !defined(__DECC)
    while (HTList_count(loaded_texts) > HTCacheSize &&
	   VMTotal > HTVirtualMemorySize)
#else
    if (HTList_count(loaded_texts) > HTCacheSize)
#endif /* VMS && VAXC && !__DECC */
    {
	CTRACE((tfp, "GridText: Freeing off cached doc.\n"));
	HText_free((HText *) HTList_removeFirstObject(loaded_texts));
#if defined(VMS) && defined (VAXC) && !defined(__DECC)
	status = lib$stat_vm(&VMType, &VMTotal);
	CTRACE((tfp, "GridText: VMTotal reduced to %d\n", VMTotal));
#endif /* VMS && VAXC && !__DECC */
    }

    self->pool = POOL_NEW();
    if (!self->pool)
	outofmem(__FILE__, "HText_New");

    line = self->last_line = TEMP_LINE(self, 0);
    line->next = line->prev = line;
    line->offset = line->size = 0;
    line->data[line->size] = '\0';
#ifdef USE_COLOR_STYLE
    line->numstyles = 0;
    line->styles = stylechanges_buffers[0];
#endif
    self->Lines = 0;
    self->first_anchor = self->last_anchor = NULL;
    self->last_anchor_before_split = NULL;
    self->style = &default_style;
    self->top_of_screen = 0;
    self->node_anchor = anchor;
    self->last_anchor_number = 0;	/* Numbering of them for references */
    self->stale = YES;
    self->toolbar = NO;
    self->tabs = NULL;
    self->next_number = 1;
#ifdef USE_SOURCE_CACHE
    /*
     * Remember the parse settings.
     */
    self->clickable_images = clickable_images;
    self->pseudo_inline_alts = pseudo_inline_alts;
    self->verbose_img = verbose_img;
    self->raw_mode = LYUseDefaultRawMode;
    self->historical_comments = historical_comments;
    self->minimal_comments = minimal_comments;
    self->soft_dquotes = soft_dquotes;
    self->old_dtd = (short) Old_DTD;
    self->keypad_mode = (short) keypad_mode;
    self->disp_lines = (short) LYlines;
    self->disp_cols = (short) DISPLAY_COLS;
#endif
    /*
     * If we are going to render the List Page, always merge in hidden
     * links to get the numbering consistent if form fields are numbered
     * and show up as hidden links in the list of links.
     * If we are going to render a bookmark file, also always merge in
     * hidden links, to get the link numbers consistent with the counting
     * in remove_bookmark_link().  Normally a bookmark file shouldn't
     * contain any entries with empty titles, but it might happen.  - kw
     */
    if (anchor->bookmark ||
	LYIsUIPage3(anchor->address, UIP_LIST_PAGE, 0) ||
	LYIsUIPage3(anchor->address, UIP_ADDRLIST_PAGE, 0))
	self->hiddenlinkflag = HIDDENLINKS_MERGE;
    else
	self->hiddenlinkflag = LYHiddenLinks;
    self->hidden_links = NULL;
    self->no_cache = (BOOLEAN) ((anchor->no_cache ||
				 anchor->post_data)
				? YES
				: NO);
    self->LastChar = '\0';

#ifndef USE_PRETTYSRC
    if (HTOutputFormat == WWW_SOURCE)
	self->source = YES;
    else
	self->source = NO;
#else
    /* mark_htext_as_source == TRUE if we are parsing html file (and psrc_view
     * is set temporary to false at creation time)
     *
     * psrc_view == TRUE if source of the text produced by some lynx module
     * (like ftp browsers) is requested).  - VH
     */
    self->source = (BOOL) (LYpsrc
			   ? mark_htext_as_source || psrc_view
			   : HTOutputFormat == WWW_SOURCE);
    mark_htext_as_source = FALSE;
#endif
    HTAnchor_setDocument(anchor, (HyperDoc *) self);
    HTFormNumber = 0;		/* no forms started yet */
    HTMainText = self;
    HTMainAnchor = anchor;
    self->display_on_the_fly = 0;
    self->kcode = NOKANJI;
    self->specified_kcode = NOKANJI;
#ifdef USE_TH_JP_AUTO_DETECT
    self->detected_kcode = DET_NOTYET;
    self->SJIS_status = SJIS_state_neutral;
    self->EUC_status = EUC_state_neutral;
#endif
    self->state = S_text;
    self->kanji_buf = '\0';
    self->in_sjis = 0;
    self->have_8bit_chars = NO;
    HText_getChartransInfo(self);
    UCSetTransParams(&self->T,
		     self->UCLYhndl, self->UCI,
		     current_char_set,
		     &LYCharSet_UC[current_char_set]);

    /*
     * Check the kcode setting if the anchor has a charset element.  -FM
     */
    HText_setKcode(self, anchor->charset,
		   HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));

    /*
     * Check to see if our underline and star_string need initialization
     * if the underline is not filled with dots.
     */
    if (underscore_string[0] != '.') {
	/*
	 * Create an array of dots for the UNDERSCORES macro.  -FM
	 */
	memset(underscore_string, '.', (size_t) (MAX_LINE - 1));
	underscore_string[(MAX_LINE - 1)] = '\0';
	underscore_string[MAX_LINE] = '\0';
	/*
	 * Create an array of underscores for the STARS macro.  -FM
	 */
	memset(star_string, '_', (size_t) (MAX_LINE - 1));
	star_string[(MAX_LINE - 1)] = '\0';
	star_string[MAX_LINE] = '\0';
    }

    underline_on = FALSE;	/* reset */
    bold_on = FALSE;

#ifdef DISP_PARTIAL
    /*
     * By this function we create HText object
     * so we may start displaying the document while downloading. - LP
     */
    if (display_partial_flag) {
	display_partial = TRUE;	/* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	/* initialize */
    }

    /*
     * These two fields should only be set to valid line numbers
     * by calls of display_page during partial displaying.  This
     * is just so that the FIRST display_page AFTER that can avoid
     * repainting the same lines on the screen.  - kw
     */
    ResetPartialLinenos(self);
#endif

#ifdef USE_JUSTIFY_ELTS
    ht_justify_cleanup();
#endif
    return self;
}

/*			Creation Method 2
 *			---------------
 *
 *      Stream is assumed open and left open.
 */
HText *HText_new2(HTParentAnchor *anchor,
		  HTStream *stream)
{
    HText *result = HText_new(anchor);

    if (stream) {
	result->target = stream;
	result->targetClass = *stream->isa;	/* copy action procedures */
    }
    return result;
}

/*	Free Entire Text
 *	----------------
 */
void HText_free(HText *self)
{
    if (!self)
	return;

#if HTLINE_NOT_IN_POOL
    {
	HTLine *f = FirstHTLine(self);
	HTLine *l = self->last_line;

	while (l != f) {	/* Free off line array */
	    self->last_line = l->prev;
	    freeHTLine(self, l);
	    l = self->last_line;
	}
	freeHTLine(self, f);
    }
#endif

    while (self->first_anchor) {	/* Free off anchor array */
	TextAnchor *l = self->first_anchor;

	self->first_anchor = l->next;

	if (l->link_type == INPUT_ANCHOR && l->input_field) {
	    free_form_fields(l->input_field);
	}

	LYFreeHiText(l);
    }
    FormList_delete(self->forms);

    /*
     * Free the tabs list.  -FM
     */
    if (self->tabs) {
	HTTabID *Tab = NULL;
	HTList *cur = self->tabs;

	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
	    FREE(Tab->name);
	    FREE(Tab);
	}
	HTList_delete(self->tabs);
	self->tabs = NULL;
    }

    /*
     * Free the hidden links list.  -FM
     */
    if (self->hidden_links) {
	LYFreeStringList(self->hidden_links);
	self->hidden_links = NULL;
    }

    /*
     * Invoke HTAnchor_delete() to free the node_anchor
     * if it is not a destination of other links.  -FM
     */
    if (self->node_anchor) {
	HTAnchor_resetUCInfoStage(self->node_anchor, -1, UCT_STAGE_STRUCTURED,
				  UCT_SETBY_NONE);
	HTAnchor_resetUCInfoStage(self->node_anchor, -1, UCT_STAGE_HTEXT,
				  UCT_SETBY_NONE);
#ifdef USE_SOURCE_CACHE
	/* Remove source cache files and chunks always, even if the
	 * HTAnchor_delete call does not actually remove the anchor.
	 * Keeping them would just be a waste of space - they won't
	 * be used any more after the anchor has been disassociated
	 * from a HText structure. - kw
	 */
	HTAnchor_clearSourceCache(self->node_anchor);
#endif

	HTAnchor_delete_links(self->node_anchor);

	HTAnchor_setDocument(self->node_anchor, (HyperDoc *) 0);

	if (HTAnchor_delete(self->node_anchor->parent))
	    /*
	     * Make sure HTMainAnchor won't point
	     * to an invalid structure.  - KW
	     */
	    HTMainAnchor = NULL;
    }

    POOL_FREE(self->pool);
    FREE(self);
}

/*		Display Methods
 *		---------------
 */

/*	Output a line
 *	-------------
 */
static int display_line(HTLine *line,
			HText *text,
			int scrline GCC_UNUSED,
			const char *target GCC_UNUSED)
{
    register int i, j;
    char buffer[7];
    char *data;
    size_t utf_extra = 0;
    char LastDisplayChar = ' ';

#ifdef USE_COLOR_STYLE
    int current_style = 0;

#define inunderline NO
#define inbold NO
#else
    BOOL inbold = NO, inunderline = NO;
#endif
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    const char *cp_tgt;
    int i_start_tgt = 0, i_after_tgt;
    int HitOffset, LenNeeded;
    BOOL intarget = NO;

#else
#define intarget NO
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */

#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    text->has_utf8 = NO;	/* use as per-line flag, except with ncurses */
#endif

#if defined(WIDEC_CURSES)
    /*
     * FIXME: this should not be necessary, but in some wide-character pages
     * the output line wraps, foiling our attempt to just use newlines to
     * advance to the next page.
     */
    LYmove(scrline + TITLE_LINES - 1, 0);
#endif

    /*
     * Set up the multibyte character buffer,
     * and clear the line to which we will be
     * writing.
     */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    LYclrtoeol();

    /*
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
     */
    j = (int) line->offset;
    if (j >= DISPLAY_COLS)
	j = DISPLAY_COLS - 1;
#ifdef USE_SLANG
    SLsmg_forward(j);
    i = j;
#else
#ifdef USE_COLOR_STYLE
    if (line->size == 0)
	i = j;
    else
#endif
	for (i = 0; i < j; i++)
	    LYaddch(' ');
#endif /* USE_SLANG */

    /*
     * Add the data, making sure that we do not
     * go over the COLS limit on the display.
     */
    data = line->data;
    i++;

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
    /*
     * If the target is on this line, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(data,
				     target,
				     text->T.output_utf8, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if (((int) line->offset + LenNeeded) >= DISPLAY_COLS) {
		cp_tgt = NULL;
	    } else {
		text->page_has_target = YES;
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

    while ((i <= DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {

#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {
		cp_tgt = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     &HitOffset,
					     &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		}
		if (!cp_tgt || i_start_tgt != i) {
		    LYstopTargetEmphasis();
		    intarget = NO;
		    if (inbold)
			lynx_start_bold();
		    if (inunderline)
			lynx_start_underline();
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */

	data++;

#if defined(USE_COLOR_STYLE)
#define CStyle line->styles[current_style]

	while (current_style < line->numstyles &&
	       i >= (int) (CStyle.sc_horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.sc_style, CStyle.sc_direction);
	    current_style++;
	}
#endif
	switch (buffer[0]) {

#ifndef USE_COLOR_STYLE
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = YES;
		if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_start_bold();
		    else
			lynx_start_underline();
#else
		    lynx_start_underline();
#endif /* PDCURSES */
		}
	    }
	    break;

	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		inunderline = NO;
		if (!intarget) {
#if defined(PDCURSES)
		    if (LYShowColor == SHOW_COLOR_NEVER)
			lynx_stop_bold();
		    else
			lynx_stop_underline();
#else
		    lynx_stop_underline();
#endif /* PDCURSES */
		}
	    }
	    break;

	case LY_BOLD_START_CHAR:
	    inbold = YES;
	    if (!intarget)
		lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (!intarget)
		lynx_stop_bold();
	    break;

#endif /* !USE_COLOR_STYLE */
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately) {
		LYaddch('+');
		i++;
#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
		i_after_tgt++;
#endif
	    }
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last character in
		 * the line.  Also ignore it if is first character following
		 * the margin, or if it is preceded by a white character (we
		 * loaded 'M' into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have been excluded by
		 * HText_appendCharacter() or by split_line() in those cases.
		 * -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
#ifndef USE_COLOR_STYLE
#if defined(SHOW_WHEREIS_TARGETS)
	    if (!intarget && cp_tgt && i >= i_start_tgt) {
		/*
		 * Start the emphasis.
		 */
		if (data > cp_tgt) {
		    LYstartTargetEmphasis();
		    intarget = YES;
		}
	    }
#endif /* SHOW_WHEREIS_TARGETS */
#endif /* USE_COLOR_STYLE */
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		text->has_utf8 = YES;
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		LYStrNCpy(&buffer[1], data, utf_extra);
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (is_CJK2(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (i <= DISPLAY_COLS) {
		    buffer[1] = *data;
		    buffer[2] = '\0';
		    data++;
		    i++;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
#ifndef USE_SLANG
		    {
			int y, x;

			getyx(LYwin, y, x);
			(void) y;
			if (x >= DISPLAY_COLS || x == 0)
			    break;
		    }
#endif
		}
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	    i++;
	}			/* end of switch */
    }				/* end of while */

#if !(defined(NCURSES_VERSION) || defined(WIDEC_CURSES))
    if (text->has_utf8) {
	LYtouchline(scrline);
	text->has_utf8 = NO;	/* we had some, but have dealt with it. */
    }
#endif
    /*
     * Add the return.
     */
    LYaddch('\n');

#if defined(SHOW_WHEREIS_TARGETS) && !defined(USE_COLOR_STYLE)
    if (intarget)
	LYstopTargetEmphasis();
#else
#undef intarget
#endif /* SHOW_WHEREIS_TARGETS && !USE_COLOR_STYLE */
#ifndef USE_COLOR_STYLE
    lynx_stop_underline();
    lynx_stop_bold();
#else
    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.sc_style, CStyle.sc_direction);
	current_style++;
    }
#undef CStyle
#endif
    return (0);
}

/*	Output the title line
 *	---------------------
 */
static void display_title(HText *text)
{
    char *title = NULL;
    char percent[20];
    unsigned char *tmp = NULL;
    int i = 0, j = 0;
    int limit;

#ifdef USE_COLOR_STYLE
    int toolbar = 0;
#endif

    /*
     * Make sure we have a text structure.  -FM
     */
    if (!text)
	return;

    lynx_start_title_color();
#ifdef USE_COLOR_STYLE
/* turn the TITLE style on */
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_title, STACK_ON);
    } else {
	LynxChangeStyle(s_title, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    /*
     * Load the title field.  -FM
     */
    StrAllocCopy(title,
		 (HTAnchor_title(text->node_anchor) ?
		  HTAnchor_title(text->node_anchor) : " "));	/* "" -> " " */
    LYReduceBlanks(title);

    /*
     * Generate the page indicator (percent) string.
     */
    limit = LYscreenWidth();
    if (limit < 10) {
	percent[0] = '\0';
    } else if ((display_lines) <= 0 && LYlines > 0 &&
	       text->top_of_screen <= 99999 && text->Lines <= 999999) {
	sprintf(percent, " (l%d of %d)",
		text->top_of_screen, text->Lines);
    } else if ((text->Lines >= display_lines) && (display_lines > 0)) {
	int total_pages = ((text->Lines + display_lines)
			   / display_lines);
	int start_of_last_page = ((text->Lines <= display_lines)
				  ? 0
				  : (text->Lines - display_lines));

	sprintf(percent, " (p%d of %d)",
		((text->top_of_screen > start_of_last_page)
		 ? total_pages
		 : ((text->top_of_screen + display_lines) / (display_lines))),
		total_pages);
    } else {
	percent[0] = '\0';
    }

    /*
     * Generate and display the title string, with page indicator
     * if appropriate, preceded by the toolbar token if appropriate,
     * and truncated if necessary.  -FM & KW
     */
    if (IS_CJK_TTY) {
	if (*title &&
	    (tmp = typecallocn(unsigned char, (strlen(title) * 2 + 256)))) {
	    if (kanji_code == EUC) {
		TO_EUC((unsigned char *) title, tmp);
	    } else if (kanji_code == SJIS) {
		TO_SJIS((unsigned char *) title, tmp);
	    } else {
		for (i = 0, j = 0; title[i]; i++) {
		    if (title[i] != CH_ESC) {	/* S/390 -- gil -- 1487 */
			tmp[j++] = UCH(title[i]);
		    }
		}
		tmp[j] = '\0';
	    }
	    StrAllocCopy(title, (const char *) tmp);
	    FREE(tmp);
	}
    }
    LYmove(0, 0);
    LYclrtoeol();
#if defined(SH_EX) && defined(KANJI_CODE_OVERRIDE)
    LYaddstr(str_kcode(last_kcode));
#endif
    if (HText_hasToolbar(text)) {
	LYaddch('#');
#ifdef USE_COLOR_STYLE
	toolbar = 1;
#endif
    }
#ifdef USE_COLOR_STYLE
    if (s_forw_backw != NOSTYLE && (nhist || nhist_extra > 1)) {
	chtype c = nhist ? ACS_LARROW : ' ';

	/* turn the FORWBACKW.ARROW style on */
	LynxChangeStyle(s_forw_backw, STACK_ON);
	if (nhist) {
	    LYaddch(c);
	    LYaddch(c);
	    LYaddch(c);
	} else
	    LYmove(0, 3 + toolbar);
	if (nhist_extra > 1) {
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	    LYaddch(ACS_RARROW);
	}
	LynxChangeStyle(s_forw_backw, STACK_OFF);
    }
#endif /* USE_COLOR_STYLE */
#ifdef WIDEC_CURSES
    i = limit - LYbarWidth - (int) strlen(percent) - LYstrCells(title);
    if (i <= 0) {		/* title is truncated */
	i = limit - LYbarWidth - (int) strlen(percent) - 3;
	if (i <= 0) {		/* no room at all */
	    title[0] = '\0';
	} else {
	    strcpy(title + LYstrFittable(title, i), "...");
	}
	i = 0;
    }
    LYmove(0, i);
#else
    i = (limit - 1) - (int) (strlen(percent) + strlen(title));
    if (i >= CHAR_WIDTH) {
	LYmove(0, i);
    } else {
	/*
	 * Truncation takes into account the possibility that
	 * multibyte characters might be present.  -HS (H.  Senshu)
	 */
	int last;

	last = (int) strlen(percent) + CHAR_WIDTH;
	if (limit - 3 >= last) {
	    title[(limit - 3) - last] = '.';
	    title[(limit - 2) - last] = '.';
	    title[(limit - 1) - last] = '\0';
	} else {
	    title[(limit - 1) - last] = '\0';
	}
	LYmove(0, CHAR_WIDTH);
    }
#endif
    LYaddstr(title);
    if (percent[0] != '\0')
	LYaddstr(percent);
    LYaddch('\n');
    FREE(title);

#if defined(USE_COLOR_STYLE) && defined(CAN_CUT_AND_PASTE)
    if (s_hot_paste != NOSTYLE) {	/* Only if the user set the style */
	LYmove(0, LYcolLimit);
	LynxChangeStyle(s_hot_paste, STACK_ON);
	LYaddch(ACS_RARROW);
	LynxChangeStyle(s_hot_paste, STACK_OFF);
	LYmove(1, 0);		/* As after \n */
    }
#endif /* USE_COLOR_STYLE */

#ifdef USE_COLOR_STYLE
/* turn the TITLE style off */
    LynxChangeStyle(s_title, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    lynx_stop_title_color();

    return;
}

/*	Output the scrollbar
 *	---------------------
 */
#ifdef USE_SCROLLBAR
static void display_scrollbar(HText *text)
{
    int i;
    int h = display_lines - 2 * (LYsb_arrow != 0);	/* Height of the scrollbar */
    int off = (LYsb_arrow != 0);	/* Start of the scrollbar */
    int top_skip, bot_skip, sh, shown;

    LYsb_begin = LYsb_end = -1;
    if (!LYShowScrollbar || !text || h <= 2
	|| text->Lines <= display_lines)
	return;

    if (text->top_of_screen >= text->Lines - display_lines) {
	/* Only part of the screen shows actual text */
	shown = text->Lines - text->top_of_screen;

	if (shown <= 0)
	    shown = 1;
    } else
	shown = display_lines;
    /* Each cell of scrollbar represents text->Lines/h lines of text. */
    /* Always smaller than h */
    sh = (shown * h + text->Lines / 2) / text->Lines;
    if (sh <= 0)
	sh = 1;
    if (sh >= h - 1)
	sh = h - 2;		/* Position at ends indicates BEG and END */

    if (text->top_of_screen == 0)
	top_skip = 0;
    else if (text->Lines - (text->top_of_screen + display_lines - 1) <= 0)
	top_skip = h - sh;
    else {
	/* text->top_of_screen between 1 and text->Lines - display_lines
	   corresponds to top_skip between 1 and h - sh - 1 */
	/* Use rounding to get as many positions into top_skip==h - sh - 1
	   as into top_skip == 1:
	   1--->1, text->Lines - display_lines + 1--->h - sh. */
	top_skip = (int) (1 +
			  1. * (h - sh - 1) * text->top_of_screen
			  / (text->Lines - display_lines + 1));
    }
    bot_skip = h - sh - top_skip;

    LYsb_begin = top_skip;
    LYsb_end = h - bot_skip;

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = top_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(1, LYcolLimit + LYshiftWin);
	addch_raw(ACS_UARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
#ifdef USE_COLOR_STYLE
    if (last_colorattr_ptr > 0) {
	LynxChangeStyle(s_sb_bg, STACK_ON);
    } else {
	LynxChangeStyle(s_sb_bg, ABS_ON);
    }
#endif /* USE_COLOR_STYLE */

    for (i = 1; i <= h; i++) {
#ifdef USE_COLOR_STYLE
	if (i - 1 <= top_skip && i > top_skip)
	    LynxChangeStyle(s_sb_bar, STACK_ON);
	if (i - 1 <= h - bot_skip && i > h - bot_skip)
	    LynxChangeStyle(s_sb_bar, STACK_OFF);
#endif /* USE_COLOR_STYLE */
	LYmove(i + off, LYcolLimit + LYshiftWin);
	if (i > top_skip && i <= h - bot_skip) {
	    LYaddch(ACS_BLOCK);
	} else {
	    LYaddch(ACS_CKBOARD);
	}
    }
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(s_sb_bg, STACK_OFF);
#endif /* USE_COLOR_STYLE */

    if (LYsb_arrow) {
#ifdef USE_COLOR_STYLE
	int s = bot_skip ? s_sb_aa : s_sb_naa;

	if (last_colorattr_ptr > 0) {
	    LynxChangeStyle(s, STACK_ON);
	} else {
	    LynxChangeStyle(s, ABS_ON);
	}
#endif /* USE_COLOR_STYLE */
	LYmove(h + 2, LYcolLimit + LYshiftWin);
	addch_raw(ACS_DARROW);
#ifdef USE_COLOR_STYLE
	LynxChangeStyle(s, STACK_OFF);
#endif /* USE_COLOR_STYLE */
    }
    return;
}
#else
#define display_scrollbar(text)	/*nothing */
#endif /* USE_SCROLLBAR */

/*	Output a page
 *	-------------
 */
static void display_page(HText *text,
			 int line_number,
			 const char *target)
{
    HTLine *line = NULL;
    int i;
    int title_lines = TITLE_LINES;

#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
    const char *cp;
#endif
    char tmp[7];
    TextAnchor *Anchor_ptr = NULL;
    int stop_before_for_anchors;
    FormInfo *FormInfo_ptr;
    BOOL display_flag = FALSE;
    HTAnchor *link_dest;
    HTAnchor *link_dest_intl = NULL;
    static int last_nlinks = 0;
    static int charset_last_displayed = -1;

#ifdef DISP_PARTIAL
    int last_disp_partial = -1;
#endif

    lynx_mode = NORMAL_LYNX_MODE;

    if (text == NULL) {
	/*
	 * Check whether to force a screen clear to enable scrollback,
	 * or as a hack to fix a reverse clear screen problem for some
	 * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
	 */
	if (enable_scrollback) {
	    LYaddch('*');
	    LYrefresh();
	    LYclear();
	}
	LYaddstr("\n\nError accessing document!\nNo data available!\n");
	LYrefresh();
	nlinks = 0;		/* set number of links to 0 */
	return;
    }
#ifdef DISP_PARTIAL
    if (display_partial || recent_sizechange || text->stale) {
	/*  Reset them, will be set near end if all is okay. - kw */
	ResetPartialLinenos(text);
    }
#endif /* DISP_PARTIAL */

    tmp[0] = tmp[1] = tmp[2] = '\0';
    if (target && *target == '\0')
	target = NULL;
    text->page_has_target = NO;
    if (display_lines <= 0) {
	/* No screen space to display anything!
	 * returning here makes it more likely we will survive if
	 * an xterm is temporarily made very small.  - kw */
	return;
    }

    line_number = HText_getPreferredTopLine(text, line_number);

    for (i = 0, line = FirstHTLine(text);	/* Find line */
	 i < line_number && (line != text->last_line);
	 i++, line = line->next) {	/* Loop */
#ifndef VMS
	if (!LYNoCore) {
	    assert(line->next != NULL);
	} else if (line->next == NULL) {
	    if (enable_scrollback) {
		LYaddch('*');
		LYrefresh();
		LYclear();
	    }
	    LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
	    LYrefresh();
	    nlinks = 0;		/* set number of links to 0 */
	    return;
	}
#else
	assert(line->next != NULL);
#endif /* !VMS */
    }				/* Loop */

    if (LYlowest_eightbit[current_char_set] <= 255 &&
	(current_char_set != charset_last_displayed) &&
    /*
     * current_char_set has changed since last invocation,
     * and it's not just 7-bit.
     * Also we don't want to do this for -dump and -source etc.
     */
	LYCursesON) {
#ifdef EXP_CHARTRANS_AUTOSWITCH
	UCChangeTerminalCodepage(current_char_set,
				 &LYCharSet_UC[current_char_set]);
#endif /* EXP_CHARTRANS_AUTOSWITCH */
	charset_last_displayed = current_char_set;
    }

    /*
     * Check whether to force a screen clear to enable scrollback,
     * or as a hack to fix a reverse clear screen problem for some
     * curses packages.  - shf@@access.digex.net & seldon@@eskimo.com
     */
    if (enable_scrollback) {
	LYaddch('*');
	LYrefresh();
	LYclear();
    }
#ifdef USE_COLOR_STYLE
    /*
     * Reset stack of color attribute changes to avoid color leaking,
     * except if what we last displayed from this text was the previous
     * screenful, in which case carrying over the state might be beneficial
     * (although it shouldn't generally be needed any more).  - kw
     */
    if (text->stale ||
	line_number != text->top_of_screen + (display_lines)) {
	last_colorattr_ptr = 0;
    }
#endif

    text->top_of_screen = line_number;
    text->top_of_screen_line = line;
    if (no_title) {
	LYmove(0, 0);
	title_lines = 0;
    } else {
	display_title(text);	/* will move cursor to top of screen */
    }
    display_flag = TRUE;

#ifdef USE_COLOR_STYLE
#ifdef DISP_PARTIAL
    if (display_partial ||
	line_number != text->first_lineno_last_disp_partial ||
	line_number > text->last_lineno_last_disp_partial)
#endif /* DISP_PARTIAL */
	ResetCachedStyles();
#endif /* USE_COLOR_STYLE */

#ifdef DISP_PARTIAL
    if (display_partial && text->stbl) {
	stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
	if (stop_before_for_anchors > line_number + (display_lines))
	    stop_before_for_anchors = line_number + (display_lines);
    } else
#endif
	stop_before_for_anchors = line_number + (display_lines);

    /*
     * Output the page.
     */
    if (line) {
#if defined(USE_COLOR_STYLE) && defined(SHOW_WHEREIS_TARGETS)
	char *data;
	int offset, LenNeeded;
#endif
#ifdef DISP_PARTIAL
	if (display_partial ||
	    line_number != text->first_lineno_last_disp_partial)
	    text->has_utf8 = NO;
#else
	text->has_utf8 = NO;
#endif
	for (i = 0; i < (display_lines); i++) {
	    /*
	     * Verify and display each line.
	     */
#ifndef VMS
	    if (!LYNoCore) {
		assert(line != NULL);
	    } else if (line == NULL) {
		if (enable_scrollback) {
		    LYaddch('*');
		    LYrefresh();
		    LYclear();
		}
		LYaddstr("\n\nError drawing page!\nBad HText structure!\n");
		LYrefresh();
		nlinks = 0;	/* set number of links to 0 */
		return;
	    }
#else
	    assert(line != NULL);
#endif /* !VMS */

#ifdef DISP_PARTIAL
	    if (!display_partial &&
		line_number == text->first_lineno_last_disp_partial &&
		i + line_number <= text->last_lineno_last_disp_partial)
		LYmove((i + title_lines + 1), 0);
	    else
#endif
		display_line(line, text, i + 1, target);

#if defined(SHOW_WHEREIS_TARGETS)
#ifdef USE_COLOR_STYLE		/* otherwise done in display_line - kw */
	    /*
	     * If the target is on this line, recursively
	     * seek and emphasize it.  -FM
	     */
	    data = (char *) line->data;
	    offset = (int) line->offset;
	    while (non_empty(target) &&
		   (cp = LYno_attr_mb_strstr(data,
					     target,
					     text->T.output_utf8, YES,
					     NULL,
					     &LenNeeded)) != NULL &&
		   ((int) line->offset + LenNeeded) <= DISPLAY_COLS) {
		size_t itmp = 0;
		size_t written = 0;
		int x_off = offset + (int) (cp - data);
		size_t len = strlen(target);
		size_t utf_extra = 0;

		text->page_has_target = YES;

		/*
		 * Start the emphasis.
		 */
		LYstartTargetEmphasis();

		/*
		 * Output the target characters.
		 */
		for (;
		     written < len && (tmp[0] = data[itmp]) != '\0';
		     itmp++) {
		    if (IsSpecialAttrChar(tmp[0]) && tmp[0] != LY_SOFT_NEWLINE) {
			/*
			 * Ignore special characters.
			 */
			x_off--;

		    } else if (&data[itmp] >= cp) {
			if (cp == &data[itmp]) {
			    /*
			     * First printable character of target.
			     */
			    LYmove((i + title_lines),
				   line->offset + LYstrExtent2(line->data,
							       x_off - line->offset));
			}
			/*
			 * Output all the printable target chars.
			 */
			utf_extra = utf8_length(text->T.output_utf8, data + itmp);
			if (utf_extra) {
			    LYStrNCpy(&tmp[1], &line->data[itmp + 1], utf_extra);
			    itmp += utf_extra;
			    LYaddstr(tmp);
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			} else if (IS_CJK_TTY && is8bits(tmp[0])) {
			    /*
			     * For CJK strings, by Masanobu Kimura.
			     */
			    tmp[1] = data[++itmp];
			    LYaddstr(tmp);
			    tmp[1] = '\0';
			    written += 2;
			} else {
			    LYaddstr(tmp);
			    written++;
			}
		    }
		}

		/*
		 * Stop the emphasis, and reset the offset and
		 * data pointer for our current position in the
		 * line.  -FM
		 */
		LYstopTargetEmphasis();
		data = (char *) &data[itmp];
		offset = (int) (data - line->data + line->offset);

	    }			/* end while */
	    LYmove((i + title_lines + 1), 0);
#endif /* USE_COLOR_STYLE */
#endif /* SHOW_WHEREIS_TARGETS */

	    /*
	     * Stop if this is the last line.  Otherwise, make sure
	     * display_flag is set and process the next line.  -FM
	     */
	    if (line == text->last_line) {
		/*
		 * Clear remaining lines of display.
		 */
		for (i++; i < (display_lines); i++) {
		    LYmove((i + title_lines), 0);
		    LYclrtoeol();
		}
		break;
	    }
#ifdef DISP_PARTIAL
	    if (display_partial) {
		/*
		 * Remember as fully shown during last partial display,
		 * if it was not the last text line.  - kw
		 */
		last_disp_partial = i + line_number;
	    }
#endif /* DISP_PARTIAL */
	    display_flag = TRUE;
	    line = line->next;
	}			/* end of "Verify and display each line." loop */
    }
    /* end "Output the page." */
    text->next_line = line;	/* Line after screen */
    text->stale = NO;		/* Display is up-to-date */

    /*
     * Add the anchors to Lynx structures.
     */
    nlinks = 0;
    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= stop_before_for_anchors;
	 Anchor_ptr = Anchor_ptr->next) {

	if (Anchor_ptr->line_num >= line_number
	    && Anchor_ptr->line_num < stop_before_for_anchors) {
	    char *hi_string = LYGetHiTextStr(Anchor_ptr, 0);

	    /*
	     * Load normal hypertext anchors.
	     */
	    if (Anchor_ptr->show_anchor
		&& non_empty(hi_string)
		&& (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
		int count;
		char *s;

		for (count = 0;; ++count) {
		    s = LYGetHiTextStr(Anchor_ptr, count);
		    if (count == 0)
			LYSetHilite(nlinks, s);
		    if (s == NULL)
			break;
		    if (count != 0) {
			LYAddHilite(nlinks, s, LYGetHiTextPos(Anchor_ptr, count));
		    }
		}

		links[nlinks].inUnderline = Anchor_ptr->inUnderline;

		links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
		links[nlinks].anchor_number = Anchor_ptr->number;
		links[nlinks].anchor_line_num = Anchor_ptr->line_num;

		link_dest = HTAnchor_followLink(Anchor_ptr->anchor);
		{
		    auto char *cp_AnchorAddress = NULL;

		    if (traversal) {
			cp_AnchorAddress = stub_HTAnchor_address(link_dest);
		    } else if (track_internal_links) {
			if (Anchor_ptr->link_type == INTERNAL_LINK_ANCHOR) {
			    link_dest_intl = HTAnchor_followTypedLink(Anchor_ptr->anchor,
								      HTInternalLink);
			    if (link_dest_intl && link_dest_intl != link_dest) {

				CTRACE((tfp,
					"GridText: display_page: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
				link_dest_intl = NULL;
			    }
			} else {
			    link_dest_intl = NULL;
			}
			if (link_dest_intl) {
			    char *cp2 = HTAnchor_address(link_dest_intl);

			    cp_AnchorAddress = cp2;
			} else {
			    cp_AnchorAddress = HTAnchor_address(link_dest);
			}
		    } else {
			cp_AnchorAddress = HTAnchor_address(link_dest);
		    }
		    FREE(links[nlinks].lname);

		    if (cp_AnchorAddress != NULL)
			links[nlinks].lname = cp_AnchorAddress;
		    else
			StrAllocCopy(links[nlinks].lname, empty_string);
		}

		links[nlinks].lx = Anchor_ptr->line_pos;
		links[nlinks].ly = ((Anchor_ptr->line_num + 1) - line_number);
		if (link_dest_intl)
		    links[nlinks].type = WWW_INTERN_LINK_TYPE;
		else
		    links[nlinks].type = WWW_LINK_TYPE;
		links[nlinks].target = empty_string;
		links[nlinks].l_form = NULL;

		nlinks++;
		display_flag = TRUE;

	    } else if (Anchor_ptr->link_type == INPUT_ANCHOR
		       && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
		/*
		 * Handle form fields.
		 */
		lynx_mode = FORMS_LYNX_MODE;

		FormInfo_ptr = Anchor_ptr->input_field;

		links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
		links[nlinks].anchor_number = Anchor_ptr->number;
		links[nlinks].anchor_line_num = Anchor_ptr->line_num;

		links[nlinks].l_form = FormInfo_ptr;
		links[nlinks].lx = Anchor_ptr->line_pos;
		links[nlinks].ly = ((Anchor_ptr->line_num + 1) - line_number);
		links[nlinks].type = WWW_FORM_LINK_TYPE;
		links[nlinks].inUnderline = Anchor_ptr->inUnderline;
		links[nlinks].target = empty_string;
		StrAllocCopy(links[nlinks].lname, empty_string);

		if (FormInfo_ptr->type == F_RADIO_TYPE) {
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_radio
				: unchecked_radio);
		} else if (FormInfo_ptr->type == F_CHECKBOX_TYPE) {
		    LYSetHilite(nlinks,
				FormInfo_ptr->num_value
				? checked_box
				: unchecked_box);
		} else if (FormInfo_ptr->type == F_PASSWORD_TYPE) {
		    LYSetHilite(nlinks,
				STARS(LYstrCells(FormInfo_ptr->value)));
		} else {	/* TEXT type */
		    LYSetHilite(nlinks,
				FormInfo_ptr->value);
		}

		nlinks++;
		/*
		 * Bold the link after incrementing nlinks.
		 */
		LYhighlight(FALSE, (nlinks - 1), target);

		display_flag = TRUE;

	    } else {
		/*
		 * Not showing anchor.
		 */
		if (non_empty(hi_string))
		    CTRACE((tfp,
			    "\nGridText: Not showing link, hightext=%s\n",
			    hi_string));
	    }
	}

	if (nlinks == MAXLINKS) {
	    /*
	     * Links array is full.  If interactive, tell user
	     * to use half-page or two-line scrolling.  -FM
	     */
	    if (LYCursesON) {
		HTAlert(MAXLINKS_REACHED);
	    }
	    CTRACE((tfp, "\ndisplay_page: MAXLINKS reached.\n"));
	    break;
	}
    }				/* end of loop "Add the anchors to Lynx structures." */

    /*
     * Free any un-reallocated links[] entries
     * from the previous page draw.  -FM
     */
    LYFreeHilites(nlinks, last_nlinks);
    last_nlinks = nlinks;

    /*
     * If Anchor_ptr is not NULL and is not pointing to the last
     * anchor, then there are anchors farther down in the document,
     * and we need to flag this for traversals.
     */
    more_links = FALSE;
    if (traversal && Anchor_ptr) {
	if (Anchor_ptr->next)
	    more_links = TRUE;
    }

    if (!display_flag) {
	/*
	 * Nothing on the page.
	 */
	LYaddstr("\n     Document is empty");
    }
    display_scrollbar(text);

#ifdef DISP_PARTIAL
    if (display_partial && display_flag &&
	last_disp_partial >= text->top_of_screen &&
	!enable_scrollback &&
	!recent_sizechange) {	/*  really remember them if ok - kw  */
	text->first_lineno_last_disp_partial = text->top_of_screen;
	text->last_lineno_last_disp_partial = last_disp_partial;
    } else {
	ResetPartialLinenos(text);
    }
#endif /* DISP_PARTIAL */

#if !defined(WIDEC_CURSES)
    if (text->has_utf8 || text->had_utf8) {
	/*
	 * For other than ncurses, repainting is taken care of
	 * by touching lines in display_line and highlight.  - kw 1999-10-07
	 */
	text->had_utf8 = text->has_utf8;
	clearok(curscr, TRUE);
    } else if (IS_CJK_TTY) {
	/*
	 * For non-multibyte curses.
	 *
	 * Full repainting is necessary, otherwise only part of a multibyte
	 * character sequence might be written because of curses output
	 * optimizations.
	 */
	clearok(curscr, TRUE);
    }
#endif /* WIDEC_CURSES */

    LYrefresh();
    return;
}

/*			Object Building methods
 *			-----------------------
 *
 *	These are used by a parser to build the text in an object
 */
void HText_beginAppend(HText *text)
{
    text->permissible_split = 0;
    text->in_line_1 = YES;

}

/* LYcols_cu is the notion that the display library has of the screen
   width.  Normally it is the same as LYcols, but there may be a
   difference via SLANG_MBCS_HACK.  Checks of the line length (as the
   non-UTF-8-aware display library would see it) against LYcols_cu are
   is used to try to prevent that lines with UTF-8 chars get wrapped
   by the library when they shouldn't.
   If there is no display library involved, i.e. dump_output_immediately,
   no such limit should be imposed.  MAX_COLS should be just as good
   as any other large value.  (But don't use INT_MAX or something close
   to it to, avoid over/underflow.) - kw */
#ifdef USE_SLANG
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : SLtt_Screen_Cols)
#else
#ifdef WIDEC_CURSES
#define LYcols_cu(text) WRAP_COLS(text)
#else
#define LYcols_cu(text) (dump_output_immediately ? MAX_COLS : DISPLAY_COLS)
#endif
#endif

/*	Add a new line of text
 *	----------------------
 *
 * On entry,
 *
 *	split	is zero for newline function, else number of characters
 *		before split.
 *	text->display_on_the_fly
 *		may be set to indicate direct output of the finished line.
 * On exit,
 *		A new line has been made, justified according to the
 *		current style.  Text after the split (if split nonzero)
 *		is taken over onto the next line.
 *
 *		If display_on_the_fly is set, then it is decremented and
 *		the finished line is displayed.
 */

static int set_style_by_embedded_chars(char *s,
				       char *e,
				       unsigned start_c,
				       unsigned end_c)
{
    int ret = NO;

    while (--e >= s) {
	if (UCH(*e) == UCH(end_c))
	    break;
	if (UCH(*e) == UCH(start_c)) {
	    ret = YES;
	    break;
	}
    }
    return ret;
}

static void move_anchors_in_region(HTLine *line, int line_number,
				   TextAnchor **prev_anchor,	/*updates++ */
				   int *prev_head_processed,
				   int sbyte,
				   int ebyte,
				   int shift)	/* Likewise */
{
    /*
     * Update anchor positions for anchors that start on this line.  Note:  we
     * rely on a->line_pos counting bytes, not characters.  That's one reason
     * why HText_trimHightext has to be prevented from acting on these anchors
     * in partial display mode before we get a chance to deal with them here.
     */
    TextAnchor *a;
    int head_processed = *prev_head_processed;

    /*
     * We need to know whether (*prev_anchor)->line_pos is "in new coordinates"
     * or in old ones.  If prev_anchor' head was touched on the previous
     * iteration, we set head_processed.  The tail may need to be treated now.
     */
    for (a = *prev_anchor;
	 a && a->line_num <= line_number;
	 a = a->next, head_processed = 0) {
	/* extent==0 needs to be special-cased; happens if no text for
	   the anchor was processed yet.  */
	/* Subtract one so that the space is not inserted at the end
	   of the anchor... */
	int last = a->line_pos + (a->extent ? a->extent - 1 : 0);

	/* Include the anchors started on the previous line */
	if (a->line_num < line_number - 1)
	    continue;
	if (a->line_num == line_number - 1)
	    last -= line->prev->size + 1;	/* Fake "\n" "between" lines counted too */
	if (last < sbyte)	/* Completely before the start */
	    continue;

	if (!head_processed	/* a->line_pos is not edited yet */
	    && a->line_num == line_number
	    && a->line_pos >= ebyte)	/* Completely after the end */
	    break;
	/* Now we know that the anchor context intersects the chunk */

	/* Fix the start */
	if (!head_processed && a->line_num == line_number
	    && a->line_pos >= sbyte) {
	    a->line_pos = (short) (a->line_pos + shift);
	    a->extent = (short) (a->extent - shift);
	    head_processed = 1;
	}
	/* Fix the end */
	if (last < ebyte) {
	    a->extent = (short) (a->extent + shift);
	} else {
	    break;		/* Keep this `a' for the next step */
	}
    }
    *prev_anchor = a;
    *prev_head_processed = head_processed;
}

/*
 * Given a line and two int arrays of old/now position, this function
 * creates a new line where spaces have been inserted/removed
 * in appropriate places - so that characters at/after the old
 * position end up at/after the new position, for each pair, if possible.
 * Some necessary changes for anchors starting on this line are also done
 * here if needed.  Updates 'prev_anchor' internally.
 * Returns a newly allocated HTLine* if changes were made
 * (caller has to free the old one).
 * Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
 * - kw
 */
static HTLine *insert_blanks_in_line(HTLine *line, int line_number,
				     HText *text,
				     TextAnchor **prev_anchor,	/*updates++ */
				     int ninserts,
				     int *oldpos,	/* Measured in cells */
				     int *newpos)	/* Likewise */
{
    int ioldc = 0;		/* count visible characters */
    int ip;			/* count insertion pairs */

#if defined(USE_COLOR_STYLE)
    int istyle = 0;
#endif
    int added_chars = 0;
    int shift = 0;
    int head_processed;
    HTLine *mod_line;
    char *newdata;
    char *s = line->data;
    char *pre = s;
    char *copied = line->data, *t;

    if (!(line && line->size && ninserts))
	return NULL;
    for (ip = 0; ip < ninserts; ip++)
	if (newpos[ip] > oldpos[ip] &&
	    (newpos[ip] - oldpos[ip]) > added_chars)
	    added_chars = newpos[ip] - oldpos[ip];
    if (line->size + added_chars > MAX_LINE - 2)
	return NULL;
    if (line == text->last_line) {
	if (line == TEMP_LINE(text, 0))
	    mod_line = TEMP_LINE(text, 1);
	else
	    mod_line = TEMP_LINE(text, 0);
    } else {
	allocHTLine(mod_line, (unsigned) (line->size + added_chars));
    }
    if (!mod_line)
	return NULL;
    if (!*prev_anchor)
	*prev_anchor = text->first_anchor;
    head_processed = (*prev_anchor && (*prev_anchor)->line_num < line_number);
    memcpy(mod_line, line, LINE_SIZE(0));
    t = newdata = mod_line->data;
    ip = 0;
    while (ip <= ninserts) {
	/* line->size is in bytes, so it may be larger than needed... */
	int curlim = (ip < ninserts
		      ? oldpos[ip]
		      : ((int) line->size <= MAX_LINE
			 ? MAX_LINE + 1
			 : (int) line->size + 1));

	pre = s;

	/* Fast forward to char==curlim or EOL.  Stop *before* the
	   style-change chars. */
	while (*s) {
	    if (text && text->T.output_utf8
		&& UCH(*s) >= 0x80 && UCH(*s) < 0xC0) {
		pre = s + 1;
	    } else if (!IsSpecialAttrChar(*s)) {	/* At a "displayed" char */
		if (ioldc >= curlim)
		    break;
		ioldc++;
		pre = s + 1;
	    }
	    s++;
	}

	/* Now s is at the "displayed" char, pre is before the style change */
	if (ip)			/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++ */ ,
				   &head_processed,
				   (int) (copied - line->data), (int) (pre - line->data),
				   shift);
#if defined(USE_COLOR_STYLE)	/* Move styles too */
#define NStyle mod_line->styles[istyle]
	for (;
	     istyle < line->numstyles && (int) NStyle.sc_horizpos < curlim;
	     istyle++)
	    /* Should not we include OFF-styles at curlim? */
	    NStyle.sc_horizpos += shift;
#endif
	while (copied < pre)	/* Copy verbatim to byte == pre */
	    *t++ = *copied++;
	if (ip < ninserts) {	/* Insert spaces */
	    int delta = newpos[ip] - oldpos[ip] - shift;

	    if (delta < 0) {	/* Not used yet? */
		while (delta++ < 0 && t > newdata && t[-1] == ' ')
		    t--, shift--;
	    } else
		shift = newpos[ip] - oldpos[ip];
	    while (delta-- > 0)
		*t++ = ' ';
	}
	ip++;
    }
    while (pre < s)		/* Copy remaining style-codes */
	*t++ = *pre++;
    /* Check whether the last anchor continues on the next line */
    if (head_processed
	&& *prev_anchor
	&& (*prev_anchor)->line_num == line_number) {
	(*prev_anchor)->extent = (short) ((*prev_anchor)->extent + shift);
    }
    *t = '\0';
    mod_line->size = (unsigned short) (t - newdata);
    return mod_line;
}

#if defined(USE_COLOR_STYLE)
#define direction2s(d) ((d) == STACK_OFF \
			? "OFF" \
			: ((d) == STACK_ON \
			   ? "ON" \
			   : "*ON"))

/*
 * Found an OFF change not part of an adjacent matched pair.
 *
 * Walk backward looking for the corresponding ON change.
 * Move everything after split_pos to be at split_pos.
 *
 * This can only work correctly if all changes are correctly nested!  If this
 * fails, assume it is safer to leave whatever comes before the OFF on the
 * previous line alone.
 */
static HTStyleChange *skip_matched_and_correct_offsets(HTStyleChange *end,
						       HTStyleChange *start,
						       unsigned split_pos)
{
    HTStyleChange *result = 0;
    int level = 0;
    HTStyleChange *tmp = end;

    CTRACE_STYLE((tfp, "SKIP Style %d %d (%s), split %u\n",
		  tmp->sc_horizpos,
		  tmp->sc_style,
		  direction2s(tmp->sc_direction),
		  split_pos));
    for (; tmp >= start; tmp--) {
	CTRACE_STYLE((tfp, "... %d %d (%s)\n",
		      tmp->sc_horizpos,
		      tmp->sc_style,
		      direction2s(tmp->sc_direction)));
	if (tmp->sc_style == end->sc_style) {
	    if (tmp->sc_direction == STACK_OFF) {
		level--;
	    } else if (tmp->sc_direction == STACK_ON) {
		if (++level == 0) {
		    result = tmp;
		    break;
		}
	    } else {
		break;
	    }
	}
	if (tmp->sc_horizpos > split_pos) {
	    tmp->sc_horizpos = split_pos;
	}
    }
    return result;
}
#endif /* USE_COLOR_STYLE */

#define reset_horizpos(value) value = 0, value = ~value

static void split_line(HText *text, unsigned split)
{
    HTStyle *style = text->style;
    int spare;
    int indent = (text->in_line_1
		  ? text->style->indent1st
		  : text->style->leftIndent);
    int new_offset;
    short alignment;
    TextAnchor *a;
    int CurLine = text->Lines;
    int HeadTrim = 0;
    int SpecialAttrChars = 0;
    int TailTrim = 0;
    int s, s_post, s_pre, t_underline = underline_on, t_bold = bold_on;
    char *p;
    char *cp;
    int ctrl_chars_on_previous_line = 0;

#ifndef WIDEC_CURSES
    int utfxtra_on_previous_line = UTFXTRA_ON_THIS_LINE;
#endif

    HTLine *previous = text->last_line;
    HTLine *line;

    /*
     * Set new line.
     */
    if (previous == TEMP_LINE(text, 0))
	line = TEMP_LINE(text, 1);
    else
	line = TEMP_LINE(text, 0);
    if (line == NULL)
	return;
    memset(line, 0, (size_t) LINE_SIZE(0));

    ctrl_chars_on_this_line = 0;	/*reset since we are going to a new line */
    utfxtra_on_this_line = 0;	/*reset too, we'll count them */
    text->LastChar = ' ';

#ifdef DEBUG_APPCH
    CTRACE((tfp, "GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp, "   previous=%s\n", previous->data));
    CTRACE((tfp, "   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
#endif

    cp = previous->data;

    /* Float LY_SOFT_NEWLINE to the start */
    if (cp[0] == LY_BOLD_START_CHAR
	|| cp[0] == LY_UNDERLINE_START_CHAR) {
	switch (cp[1]) {
	case LY_SOFT_NEWLINE:
	    cp[1] = cp[0];
	    cp[0] = LY_SOFT_NEWLINE;
	    break;
	case LY_BOLD_START_CHAR:
	case LY_UNDERLINE_START_CHAR:
	    if (cp[2] == LY_SOFT_NEWLINE) {
		cp[2] = cp[1];
		cp[1] = cp[0];
		cp[0] = LY_SOFT_NEWLINE;
	    }
	    break;
	}
    }
    if (split > previous->size) {
	CTRACE((tfp,
		"*** split_line: split==%u greater than last_line->size==%d !\n",
		split, previous->size));
	if (split > MAX_LINE) {
	    split = previous->size;
	    if ((cp = strrchr(previous->data, ' ')) &&
		cp - previous->data > 1)
		split = (unsigned) (cp - previous->data);
	    CTRACE((tfp, "                split adjusted to %u.\n", split));
	}
    }

    text->Lines++;

    previous->next->prev = line;
    line->prev = previous;
    line->next = previous->next;
    previous->next = line;
    text->last_line = line;
    line->size = 0;
    line->offset = 0;
    text->permissible_split = 0;	/* 12/13/93 */
    line->data[0] = '\0';

    alignment = style->alignment;

    if (split > 0) {		/* Restore flags to the value at the splitting point */
	if (!(dump_output_immediately && use_underscore))
	    t_underline = set_style_by_embedded_chars(previous->data,
						      previous->data + split,
						      LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(previous->data,
					     previous->data + split,
					     LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);

    }

    if (!(dump_output_immediately && use_underscore) && t_underline) {
	line->data[line->size++] = LY_UNDERLINE_START_CHAR;
	line->data[line->size] = '\0';
	ctrl_chars_on_this_line++;
	SpecialAttrChars++;
    }
    if (t_bold) {
	line->data[line->size++] = LY_BOLD_START_CHAR;
	line->data[line->size] = '\0';
	ctrl_chars_on_this_line++;
	SpecialAttrChars++;
    }

    /*
     * Split at required point
     */
    if (split > 0) {		/* Delete space at "split" splitting line */
	char *prevdata = previous->data, *linedata = line->data;
	unsigned plen;
	int i;

	/* Split the line. -FM */
	prevdata[previous->size] = '\0';
	previous->size = (unsigned short) split;

	/*
	 * Trim any spaces or soft hyphens from the beginning
	 * of our new line.  -FM
	 */
	p = prevdata + split;
	while (((*p == ' '
#ifdef USE_JUSTIFY_ELTS
	/* if justification is allowed for prev line, then raw
	 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	 * substituted at the end of this function with ' ') - VH
	 */
		 || *p == HT_NON_BREAK_SPACE
#endif
		)
		&& (HeadTrim || text->first_anchor ||
		    underline_on || bold_on ||
		    alignment != HT_LEFT ||
		    style->wordWrap || style->freeFormat ||
		    style->spaceBefore || style->spaceAfter)) ||
	       *p == LY_SOFT_HYPHEN) {
	    p++;
	    HeadTrim++;
	}

	plen = (unsigned) strlen(p);
	if (plen) {		/* Count funny characters */
	    for (i = (int) (plen - 1); i >= 0; i--) {
		if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR ||
		    p[i] == LY_BOLD_START_CHAR ||
		    p[i] == LY_BOLD_END_CHAR ||
		    p[i] == LY_SOFT_HYPHEN) {
		    ctrl_chars_on_this_line++;
		} else if (IS_UTF_EXTRA(p[i])) {
		    utfxtra_on_this_line++;
		}
		if (p[i] == LY_SOFT_HYPHEN &&
		    (int) text->permissible_split < i)
		    text->permissible_split = (unsigned) (i + 1);
	    }
	    ctrl_chars_on_this_line += utfxtra_on_this_line;

	    /* Add the data to the new line. -FM */
	    strcat(linedata, p);
	    line->size = (unsigned short) (line->size + plen);
	}
    }

    /*
     * Economize on space.
     */
    p = previous->data + previous->size - 1;
    while (p >= previous->data
	   && (*p == ' '
#ifdef USE_JUSTIFY_ELTS
    /* if justification is allowed for prev line, then raw
     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
     * substituted at the end of this function with ' ') - VH
     */
	       || *p == HT_NON_BREAK_SPACE
#endif
	   )
#ifdef USE_PRETTYSRC
	   && !psrc_view	/*don't strip trailing whites - since next line can
				   start with LY_SOFT_NEWLINE - so we don't lose spaces when
				   'p'rinting this text to file -VH */
#endif
	   && (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	       underline_on || bold_on ||
	       alignment != HT_LEFT ||
	       style->wordWrap || style->freeFormat ||
	       style->spaceBefore || style->spaceAfter)) {
	p--;			/*  Strip trailers. */
    }
    /*  Strip trailers. */
    TailTrim = (int) (previous->data + previous->size - 1 - p);
    previous->size = (unsigned short) (previous->size - TailTrim);
    p[1] = '\0';

    /*
     * s is the effective split position, given by either a non-zero
     * value of split or by the size of the previous line before
     * trimming.  - kw
     */
    if (split == 0) {
	s = previous->size + TailTrim;	/* the original size */
    } else {
	s = (int) split;
    }
    s_post = s + HeadTrim;
    s_pre = s - TailTrim;

#ifdef DEBUG_SPLITLINE
#ifdef DEBUG_APPCH
    if (s != (int) split)
#endif
	CTRACE((tfp, "GridText: split_line(%u [now:%d]) called\n", split, s));
#endif

#if defined(USE_COLOR_STYLE)
    if (previous->styles == stylechanges_buffers[0])
	line->styles = stylechanges_buffers[1];
    else
	line->styles = stylechanges_buffers[0];
    line->numstyles = 0;
    {
	HTStyleChange *from = previous->styles + previous->numstyles - 1;
	HTStyleChange *to = line->styles + MAX_STYLES_ON_LINE - 1;
	HTStyleChange *scan, *at_end;

	/* Color style changes after the split position
	 * are transferred to the new line.  Ditto for changes
	 * in the trimming region, but we stop when we reach an OFF change.
	 * The second loop below may then handle remaining changes.  - kw */
	while (from >= previous->styles && to >= line->styles) {
	    *to = *from;
	    if ((int) to->sc_horizpos > s_post) {
		to->sc_horizpos += -s_post + SpecialAttrChars;
	    } else if ((int) to->sc_horizpos > s_pre &&
		       (to->sc_direction == STACK_ON ||
			to->sc_direction == ABS_ON)) {
		to->sc_horizpos = ((int) to->sc_horizpos < s) ? 0 : SpecialAttrChars;
	    } else {
		break;
	    }
	    to--;
	    from--;
	}
	/* FROM may be invalid, otherwise it is either an ON change at or
	   before s_pre, or is an OFF change at or before s_post.  */

	scan = from;
	at_end = from;
	/* Now on the previous line we have a correctly nested but
	   possibly non-terminated sequence of style changes.
	   Terminate it, and duplicate unterminated changes at the
	   beginning of the new line. */
	while (scan >= previous->styles && at_end >= previous->styles) {
	    /* The algorithm: scan back though the styles on the previous line.
	       a) If OFF, skip the matched group.
	       Report a bug on failure.
	       b) If ON, (try to) cancel the corresponding ON at at_end,
	       and the corresponding OFF at to;
	       If not, put the corresponding OFF at at_end, and copy to to;
	     */
	    if (scan->sc_direction == STACK_OFF) {
		scan = skip_matched_and_correct_offsets(scan, previous->styles,
							(unsigned) s_pre);
		if (!scan) {
		    CTRACE((tfp, "BUG: styles improperly nested.\n"));
		    break;
		}
	    } else if (scan->sc_direction == STACK_ON) {
		if (at_end->sc_direction == STACK_ON
		    && at_end->sc_style == scan->sc_style
		    && (int) at_end->sc_horizpos >= s_pre)
		    at_end--;
		else if (at_end >= previous->styles + MAX_STYLES_ON_LINE - 1) {
		    CTRACE((tfp, "BUG: style overflow before split_line.\n"));
		    break;
		} else {
		    at_end++;
		    at_end->sc_direction = STACK_OFF;
		    at_end->sc_style = scan->sc_style;
		    at_end->sc_horizpos = s_pre;
		    CTRACE_STYLE((tfp,
				  "split_line, %d:style[%d] %d (dir=%d)\n",
				  s_pre,
				  (int) (at_end - from),
				  scan->sc_style,
				  at_end->sc_direction));
		}
		if (to < line->styles + MAX_STYLES_ON_LINE - 1
		    && to[1].sc_direction == STACK_OFF
		    && to[1].sc_horizpos <= (unsigned) SpecialAttrChars
		    && to[1].sc_style == scan->sc_style)
		    to++;
		else if (to >= line->styles) {
		    *to = *scan;
		    to->sc_horizpos = SpecialAttrChars;
		    to--;
		} else {
		    CTRACE((tfp, "BUG: style overflow after split_line.\n"));
		    break;
		}
	    }
	    if ((int) scan->sc_horizpos > s_pre) {
		scan->sc_horizpos = s_pre;
	    }
	    scan--;
	}
	line->numstyles = (unsigned short) (line->styles
					    + MAX_STYLES_ON_LINE
					    - 1 - to);
	if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	    int n;

	    for (n = 0; n < line->numstyles; n++)
		line->styles[n] = to[n + 1];
	} else if (line->numstyles == 0) {
	    reset_horizpos(line->styles[0].sc_horizpos);
	}
	previous->numstyles = (unsigned short) (at_end - previous->styles + 1);
	if (previous->numstyles == 0) {
	    reset_horizpos(previous->styles[0].sc_horizpos);
	}
    }
#endif /*USE_COLOR_STYLE */

    {
	HTLine *temp;

	allocHTLine(temp, previous->size);
	if (!temp)
	    outofmem(__FILE__, "split_line_2");

	assert(temp != NULL);

	memcpy(temp, previous, LINE_SIZE(previous->size));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, previous->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "split_line_2");
	memcpy(temp->styles, previous->styles, sizeof(HTStyleChange) * previous->numstyles);
#endif
	previous = temp;
    }

    previous->prev->next = previous;	/* Link in new line */
    previous->next->prev = previous;	/* Could be same node of course */

    /*
     * Terminate finished line for printing.
     */
    previous->data[previous->size] = '\0';

    /*
     * Align left, right or center.
     */
    spare = 0;
    if (
#ifdef USE_JUSTIFY_ELTS
	   this_line_was_split ||
#endif
	   (alignment == HT_CENTER ||
	    alignment == HT_RIGHT) || text->stbl) {
	/* Calculate spare character positions if needed */
	for (cp = previous->data; *cp; cp++) {
	    if (*cp == LY_UNDERLINE_START_CHAR ||
		*cp == LY_UNDERLINE_END_CHAR ||
		*cp == LY_BOLD_START_CHAR ||
		*cp == LY_BOLD_END_CHAR ||
#ifndef WIDEC_CURSES
		IS_UTF_EXTRA(*cp) ||
#endif
		*cp == LY_SOFT_HYPHEN) {
		ctrl_chars_on_previous_line++;
	    }
	}
	if ((previous->size > 0) &&
	    (int) (previous->data[previous->size - 1] == LY_SOFT_HYPHEN))
	    ctrl_chars_on_previous_line--;

	/* @@@@ first line indent */
#ifdef WIDEC_CURSES
	spare = WRAP_COLS(text)
	    - (int) style->rightIndent
	    - indent
	    + ctrl_chars_on_previous_line
	    - LYstrExtent2(previous->data, previous->size);
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;
#else
	spare = WRAP_COLS(text)
	    - (int) style->rightIndent
	    - indent
	    + ctrl_chars_on_previous_line
	    - previous->size;
	if (spare < 0 && LYwideLines)	/* Can be wider than screen */
	    spare = 0;

	if (spare > 0 && !dump_output_immediately &&
	    text->T.output_utf8 && ctrl_chars_on_previous_line) {
	    utfxtra_on_previous_line -= UTFXTRA_ON_THIS_LINE;
	    if (utfxtra_on_previous_line) {
		int spare_cu = (LYcols_cu(text) -
				utfxtra_on_previous_line - indent +
				ctrl_chars_on_previous_line - previous->size);

		/*
		 * Shift non-leftaligned UTF-8 lines that would be
		 * mishandled by the display library towards the left
		 * if this would make them fit.  The resulting display
		 * will not be as intended, but this is better than
		 * having them split by curses.  (Curses cursor movement
		 * optimization may still cause wrong positioning within
		 * the line, in particular after a sequence of spaces).
		 * - kw
		 */
		if (spare_cu < spare) {
		    if (spare_cu >= 0) {
			if (alignment == HT_CENTER &&
			    (int) (previous->offset + indent + spare / 2 +
				   previous->size)
			    - ctrl_chars_on_previous_line
			    + utfxtra_on_previous_line <= LYcols_cu(text))
			    /* do nothing - it still fits - kw */ ;
			else {
			    spare = spare_cu;
			}
		    } else if (indent + (int) previous->offset + spare_cu >= 0) {	/* subtract overdraft from effective indentation */
			indent += (int) previous->offset + spare_cu;
			previous->offset = 0;
			spare = 0;
		    }
		}
	    }
	}
#endif
    }

    new_offset = previous->offset;
    switch (style->alignment) {
    case HT_CENTER:
	new_offset += indent + spare / 2;
	break;
    case HT_RIGHT:
	new_offset += indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:		/* Not implemented */
    default:
	new_offset += indent;
	break;
    }				/* switch */
    previous->offset = (unsigned short) ((new_offset < 0) ? 0 : new_offset);

    if (text->stbl)
	/*
	 * Notify simple table stuff of line split, so that it can
	 * set the last cell's length.  The last cell should and
	 * its row should really end here, or on one of the following
	 * lines with no more characters added after the break.
	 * We don't know whether a cell has been started, so ignore
	 * errors here.
	 * This call is down here because we need the
	 * ctrl_chars_on_previous_line, which have just been re-
	 * counted above.  - kw
	 */
	Stbl_lineBreak(text->stbl,
		       text->Lines - 1,
		       previous->offset,
		       previous->size - ctrl_chars_on_previous_line);

    text->in_line_1 = NO;	/* unless caller sets it otherwise */

    /*
     * If we split the line, adjust the anchor
     * structure values for the new line.  -FM
     */

    if (s > 0) {		/* if not completely empty */
	int moved = 0;

	/* In the algorithm below we move or not move anchors between
	   lines using some heuristic criteria.  However, it is
	   desirable not to have two consequent anchors on different
	   lines *in a wrong order*!  (How can this happen?)
	   So when the "reasonable choice" is not unique, we use the
	   MOVED flag to choose one.
	 */
	/* Our operations can make a non-empty all-whitespace link
	   empty.  So what? */
	if ((a = text->last_anchor_before_split) == 0)
	    a = text->first_anchor;

	for (; a; a = a->next) {
	    if (a->line_num == CurLine) {
		int len = a->extent, n = a->number, start = a->line_pos;
		int end = start + len;

		text->last_anchor_before_split = a;

		/* Which anchors do we leave on the previous line?
		   a) empty finished (We need a cut-off value.
		   "Just because": those before s;
		   this is the only case when we use s, not s_pre/s_post);
		   b) Those which start before s_pre;
		 */
		if (start < s_pre) {
		    if (end <= s_pre)
			continue;	/* No problem */

		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation", n));
		    if (end > s_post) {
			CTRACE_SPLITLINE((tfp, " of the start.\n"));
			a->extent = (short) (a->extent
					     - (TailTrim + HeadTrim)
					     + SpecialAttrChars);
		    } else {
			CTRACE_SPLITLINE((tfp, ", cut the end.\n"));
			a->extent = (short) (s_pre - start);
		    }
		    continue;
		} else if (start < s && !len
			   && (!n || (a->show_anchor && !moved))) {
		    CTRACE_SPLITLINE((tfp,
				      "anchor %d: no relocation, empty-finished",
				      n));
		    a->line_pos = (short) s_pre;	/* Leave at the end of line */
		    continue;
		}

		/* The rest we relocate */
		moved = 1;
		a->line_num++;
		CTRACE_SPLITLINE((tfp,
				  "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
				  n, TailTrim, HeadTrim, SpecialAttrChars,
				  a->line_num, a->line_pos, a->extent));
		if (end < s_post) {	/* Move the end to s_post */
		    CTRACE_SPLITLINE((tfp, "Move end +%d, ", s_post - end));
		    len += s_post - end;
		}
		if (start < s_post) {	/* Move the start to s_post */
		    CTRACE_SPLITLINE((tfp, "Move start +%d, ", s_post - start));
		    len -= s_post - start;
		    start = s_post;
		}
		a->line_pos = (short) (start - s_post + SpecialAttrChars);
		a->extent = (short) len;

		CTRACE_SPLITLINE((tfp, "->(%d,%d,%d)\n",
				  a->line_num, a->line_pos, a->extent));
	    } else if (a->line_num > CurLine)
		break;
	}
    }
#ifdef USE_JUSTIFY_ELTS
    /* now perform justification - by VH */

    if (this_line_was_split
	&& spare > 0
	&& !text->stbl		/* We don't inform TRST on the cell width change yet */
	&& justify_max_void_percent > 0
	&& justify_max_void_percent <= 100
	&& justify_max_void_percent >= ((100 * spare)
					/ (WRAP_COLS(text)
					   - (int) style->rightIndent
					   - indent
					   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification */
	char *jp = previous->data + justify_start_position;
	ht_run_info *r = ht_runs;
	char c;
	int d_, r_;
	HTLine *jline;

	ht_num_runs = 0;
	r->byte_len = r->cell_len = 0;

	for (; (c = *jp) != 0; ++jp) {
	    if (c == ' ') {
		++r;
		++ht_num_runs;
		r->byte_len = r->cell_len = 0;
		continue;
	    }
	    ++r->byte_len;
	    if (IsSpecialAttrChar(c))
		continue;

	    ++r->cell_len;
	    if (c == HT_NON_BREAK_SPACE) {
		*jp = ' ';	/* substitute it */
		continue;
	    }
	    if (text->T.output_utf8 && is8bits(c)) {
		int utf_extra = (int) utf8_length(text->T.output_utf8, jp);

		r->byte_len += utf_extra;
		jp += utf_extra;
	    }
	}
	++ht_num_runs;

	if (ht_num_runs != 1) {
	    int *oldpos = (int *) malloc(sizeof(int)
					 * 2 * (size_t) (ht_num_runs - 1));
	    int *newpos = oldpos + ht_num_runs - 1;
	    int i = 1;

	    if (oldpos == NULL)
		outofmem(__FILE__, "split_line_3");

	    d_ = spare / (ht_num_runs - 1);
	    r_ = spare % (ht_num_runs - 1);

	    /* The first run is not moved, proceed to the second one */
	    oldpos[0] = justify_start_position + ht_runs[0].cell_len + 1;
	    newpos[0] = oldpos[0] + (d_ + (r_-- > 0));
	    while (i < ht_num_runs - 1) {
		int delta = ht_runs[i].cell_len + 1;

		oldpos[i] = oldpos[i - 1] + delta;
		newpos[i] = newpos[i - 1] + delta + (d_ + (r_-- > 0));
		i++;
	    }
	    jline = insert_blanks_in_line(previous, CurLine, text,
					  &last_anchor_of_previous_line /*updates++ */ ,
					  ht_num_runs - 1, oldpos, newpos);
	    free(oldpos);
	    if (jline == NULL)
		outofmem(__FILE__, "split_line_4");
	    previous->next->prev = jline;
	    previous->prev->next = jline;

	    freeHTLine(text, previous);

	    previous = jline;
	}
	if (justify_start_position) {
	    char *p2 = previous->data;

	    for (; p2 < previous->data + justify_start_position; ++p2)
		*p2 = (char) (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
	}
    } else {
	if (REALLY_CAN_JUSTIFY(text)) {
	    char *p2;

	    /* it was permitted to justify line, but this function was called
	     * to end paragraph - we must substitute HT_NON_BREAK_SPACEs with
	     * spaces in previous line
	     */
	    if (line->size && !text->stbl) {
		CTRACE((tfp,
			"BUG: justification: shouldn't happen - new line is not empty!\n\t'%.*s'\n",
			line->size, line->data));
	    }

	    for (p2 = previous->data; *p2; ++p2)
		if (*p2 == HT_NON_BREAK_SPACE)
		    *p2 = ' ';
	} else if (have_raw_nbsps) {
	    /* this is very rare case, that can happen in forms placed in
	       table cells */
	    unsigned i;

	    for (i = 0; i < previous->size; ++i)
		if (previous->data[i] == HT_NON_BREAK_SPACE)
		    previous->data[i] = ' ';

	    /*next line won't be justified, so substitute nbsps in it too */
	    for (i = 0; i < line->size; ++i)
		if (line->data[i] == HT_NON_BREAK_SPACE)
		    line->data[i] = ' ';
	}

	/* else HT_NON_BREAK_SPACEs were substituted with spaces in
	   HText_appendCharacter */
    }
    /* cleanup */
    can_justify_this_line = TRUE;
    justify_start_position = 0;
    this_line_was_split = FALSE;
    have_raw_nbsps = FALSE;
#endif /* USE_JUSTIFY_ELTS */
    return;
}				/* split_line */

#ifdef DEBUG_SPLITLINE
static void do_new_line(HText *text, const char *fn, int ln)
{
    CTRACE_SPLITLINE((tfp, "new_line %s@@%d\n", fn, ln));
    split_line(text, 0);
}

#define new_line(text) do_new_line(text, __FILE__, __LINE__)
#else
#define new_line(text) split_line(text, 0)
#endif

/*	Allow vertical blank space
 *	--------------------------
 */
static void blank_lines(HText *text, int newlines)
{
    if (HText_TrueEmptyLine(text->last_line, text, FALSE)) {	/* No text on current line */
	HTLine *line = text->last_line->prev;
	BOOL first = (BOOL) (line == text->last_line);

	if (no_title && first)
	    return;

#ifdef USE_COLOR_STYLE
	/* Style-change petty requests at the start of the document: */
	if (first && newlines == 1)
	    return;		/* Do not add a blank line at start */
#endif

	while (line != NULL &&
	       line != text->last_line &&
	       HText_TrueEmptyLine(line, text, FALSE)) {
	    if (newlines == 0)
		break;
	    newlines--;		/* Don't bother: already blank */
	    line = line->prev;
	}
    } else {
	newlines++;		/* Need also to finish this line */
    }

    for (; newlines; newlines--) {
	new_line(text);
    }
    text->in_line_1 = YES;
}

/*	New paragraph in current style
 *	------------------------------
 * See also: setStyle.
 */
void HText_appendParagraph(HText *text)
{
    int after = text->style->spaceAfter;
    int before = text->style->spaceBefore;

    blank_lines(text, ((after > before) ? after : before));
}

/*	Set Style
 *	---------
 *
 *	Does not filter unnecessary style changes.
 */
void HText_setStyle(HText *text, HTStyle *style)
{
    int after, before;

    if (!style)
	return;			/* Safety */
    after = text->style->spaceAfter;
    before = style->spaceBefore;

    CTRACE((tfp, "GridText: Change to style %s\n", GetHTStyleName(style)));

    blank_lines(text, ((after > before) ? after : before));

    text->style = style;
}

/*	Append a character to the text object
 *	-------------------------------------
 */
void HText_appendCharacter(HText *text, int ch)
{
    HTLine *line;
    HTStyle *style;
    int indent;
    int actual;

#ifdef DEBUG_APPCH
#ifdef CJK_EX
    static unsigned char save_ch = 0;
#endif

    if (TRACE) {
	char *special = NULL;	/* make trace a little more readable */

	switch (ch) {
	case HT_NON_BREAK_SPACE:
	    special = "HT_NON_BREAK_SPACE";
	    break;
	case HT_EN_SPACE:
	    special = "HT_EN_SPACE";
	    break;
	case LY_UNDERLINE_START_CHAR:
	    special = "LY_UNDERLINE_START_CHAR";
	    break;
	case LY_UNDERLINE_END_CHAR:
	    special = "LY_UNDERLINE_END_CHAR";
	    break;
	case LY_BOLD_START_CHAR:
	    special = "LY_BOLD_START_CHAR";
	    break;
	case LY_BOLD_END_CHAR:
	    special = "LY_BOLD_END_CHAR";
	    break;
	case LY_SOFT_HYPHEN:
	    special = "LY_SOFT_HYPHEN";
	    break;
	case LY_SOFT_NEWLINE:
	    special = "LY_SOFT_NEWLINE";
	    break;
	default:
	    special = NULL;
	    break;
	}

	if (special != NULL) {
	    CTRACE((tfp, "add(%s %d special char) %d/%d\n", special, ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	} else {
#ifdef CJK_EX			/* 1998/08/30 (Sun) 13:26:23 */
	    if (save_ch == 0) {
		if (IS_SJIS_HI1(ch) || IS_SJIS_HI2(ch)) {
		    save_ch = ch;
		} else {
		    CTRACE((tfp, "add(%c) %d/%d\n", ch,
			    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		}
	    } else {
		CTRACE((tfp, "add(%c%c) %d/%d\n", save_ch, ch,
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
		save_ch = 0;
	    }
#else
	    if (UCH(ch) < 0x80) {
		CTRACE((tfp, "add(%c) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    } else {
		CTRACE((tfp, "add(%02x) %d/%d\n", UCH(ch),
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
	    }
#endif /* CJK_EX */
	}
    }				/* trace only */
#endif /* DEBUG_APPCH */

    /*
     * Make sure we don't crash on NULLs.
     */
    if (!text)
	return;

    if (text->halted > 1) {
	/*
	 * We should stop outputting more text, because low memory was
	 * detected.  - kw
	 */
	if (text->halted == 2) {
	    /*
	     * But if we haven't done so yet, first append a warning.
	     * We should still have a few bytes left for that :).
	     * We temporarily reset test->halted to 0 for this, since
	     * this function will get called recursively.  - kw
	     */
	    text->halted = 0;
	    text->kanji_buf = '\0';
	    HText_appendText(text, gettext(" *** MEMORY EXHAUSTED ***"));
	}
	text->halted = 3;
	return;
    }
#ifdef USE_TH_JP_AUTO_DETECT
    if ((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED) &&
	(text->specified_kcode != SJIS) && (text->specified_kcode != EUC)) {
	unsigned char c;
	eDetectedKCode save_d_kcode;

	c = UCH(ch);
	save_d_kcode = text->detected_kcode;
	switch (text->SJIS_status) {
	case SJIS_state_has_bad_code:
	    break;
	case SJIS_state_neutral:
	    if (IS_SJIS_HI1(c) || IS_SJIS_HI2(c)) {
		text->SJIS_status = SJIS_state_in_kanji;
	    } else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	case SJIS_state_in_kanji:
	    if (IS_SJIS_LO(c)) {
		text->SJIS_status = SJIS_state_neutral;
	    } else {
		text->SJIS_status = SJIS_state_has_bad_code;
		if (text->EUC_status == EUC_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_EUC;
	    }
	    break;
	}
	switch (text->EUC_status) {
	case EUC_state_has_bad_code:
	    break;
	case EUC_state_neutral:
	    if (IS_EUC_HI(c)) {
		text->EUC_status = EUC_state_in_kanji;
	    } else if (c == 0x8e) {
		text->EUC_status = EUC_state_in_kana;
	    } else if (c & 0x80) {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kanji:
	    if (IS_EUC_LOX(c)) {
		text->EUC_status = EUC_state_neutral;
	    } else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	case EUC_state_in_kana:
	    if ((0xA1 <= c) && (c <= 0xDF)) {
		text->EUC_status = EUC_state_neutral;
	    } else {
		text->EUC_status = EUC_state_has_bad_code;
		if (text->SJIS_status == SJIS_state_has_bad_code)
		    text->detected_kcode = DET_MIXED;
		else
		    text->detected_kcode = DET_SJIS;
	    }
	    break;
	}
	if (save_d_kcode != text->detected_kcode) {
	    switch (text->detected_kcode) {
	    case DET_SJIS:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
		break;
	    case DET_EUC:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
		break;
	    case DET_MIXED:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
		break;
	    default:
		CTRACE((tfp,
			"TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
		break;
	    }
	}
    }
#endif /* USE_TH_JP_AUTO_DETECT */
    /*
     * Make sure we don't hang on escape sequences.
     */
    if (ch == CH_ESC && !IS_CJK_TTY) {	/* decimal 27  S/390 -- gil -- 1504 */
	return;
    }
#ifndef USE_SLANG
    /*
     * Block 8-bit chars not allowed by the current display character
     * set if they are below what LYlowest_eightbit indicates.
     * Slang used its own replacements, so for USE_SLANG blocking here
     * is not necessary to protect terminals from those characters.
     * They should have been filtered out or translated by an earlier
     * processing stage anyway.  - kw
     */
#ifndef   EBCDIC		/* S/390 -- gil -- 1514 */
    if (is8bits(ch) && !IS_CJK_TTY &&
	!text->T.transp && !text->T.output_utf8 &&
	UCH(ch) < LYlowest_eightbit[current_char_set]) {
	return;
    }
#endif /* EBCDIC */
#endif /* !USE_SLANG */
    if (UCH(ch) == 155 && !IS_CJK_TTY) {	/* octal 233 */
	if (!HTPassHighCtrlRaw &&
	    !text->T.transp && !text->T.output_utf8 &&
	    (155 < LYlowest_eightbit[current_char_set])) {
	    return;
	}
    }

    line = text->last_line;
    style = text->style;

    indent = text->in_line_1 ? (int) style->indent1st : (int) style->leftIndent;

    if (IS_CJK_TTY) {
	switch (text->state) {
	case S_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1536 */
		/*
		 * Setting up for CJK escape sequence handling (based on
		 * Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx).  -FM
		 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		return;
	    }
	    break;

	case S_esc:
	    /*
	     * Expecting '$'or '(' following CJK ESC.
	     */
	    if (ch == '$') {
		text->state = S_dollar;
		return;
	    } else if (ch == '(') {
		text->state = S_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    /* FALLTHRU */

	case S_dollar:
	    /*
	     * Expecting '@@', 'B', 'A' or '(' after CJK "ESC$".
	     */
	    if (ch == '@@' || ch == 'B' || ch == 'A') {
		text->state = S_nonascii_text;
		if (ch == '@@' || ch == 'B')
		    text->kcode = JIS;
		return;
	    } else if (ch == '(') {
		text->state = S_dollar_paren;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_dollar_paren:
	    /*
	     * Expecting 'C' after CJK "ESC$(".
	     */
	    if (ch == 'C') {
		text->state = S_nonascii_text;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_paren:
	    /*
	     * Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(".
	     */
	    if (ch == 'B' || ch == 'J' || ch == 'T') {
		/*
		 * Can split here.  -FM
		 */
		text->permissible_split = text->last_line->size;
		text->state = S_text;
		return;
	    } else if (ch == 'I') {
		text->state = S_jisx0201_text;
		/*
		 * Can split here.  -FM
		 */
		text->permissible_split = text->last_line->size;
		text->kcode = JIS;
		return;
	    } else {
		text->state = S_text;
	    }
	    break;

	case S_nonascii_text:
	    /*
	     * Expecting CJK ESC after non-ASCII text.
	     */
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1553 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
		}
		return;
	    } else if (UCH(ch) < 32) {
		text->state = S_text;
		text->kanji_buf = '\0';
		if (HTCJK == JAPANESE) {
		    text->kcode = NOKANJI;
		}
	    } else {
		ch |= 0200;
	    }
	    break;

	    /*
	     * JIS X0201 Kana in JIS support.  - by ASATAKU
	     */
	case S_jisx0201_text:
	    if (ch == CH_ESC) {	/* S/390 -- gil -- 1570 */
		text->state = S_esc;
		text->kanji_buf = '\0';
		text->kcode = NOKANJI;
		return;
	    } else {
		text->kanji_buf = '\216';
		ch |= 0200;
	    }
	    break;
	}			/* end switch */

	if (!text->kanji_buf) {
	    if ((ch & 0200) != 0) {
		/*
		 * JIS X0201 Kana in SJIS support.  - by ASATAKU
		 */
		if ((text->kcode != JIS)
#ifdef USE_TH_JP_AUTO_DETECT
		    && (text->specified_kcode != EUC)
		    && (text->detected_kcode != DET_EUC)
#endif
		    && (
#ifdef KANJI_CODE_OVERRIDE
			   (last_kcode == SJIS) ||
			   ((last_kcode == NOKANJI) &&
#endif
			    ((text->kcode == SJIS) ||
#ifdef USE_TH_JP_AUTO_DETECT
			     ((text->detected_kcode == DET_SJIS) &&
			      (text->specified_kcode == NOKANJI)) ||
#endif
			     ((text->kcode == NOKANJI) &&
			      (text->specified_kcode == SJIS)))
#ifdef KANJI_CODE_OVERRIDE
			   )
#endif
		    ) &&
		    (UCH(ch) >= 0xA1) &&
		    (UCH(ch) <= 0xDF)) {
		    if (conv_jisx0201kana) {
			unsigned char c = UCH(ch);
			unsigned char kb = UCH(text->kanji_buf);

			JISx0201TO0208_SJIS(c,
					    (unsigned char *) &kb,
					    (unsigned char *) &c);
			ch = (char) c;
			text->kanji_buf = kb;
		    }
		    /* 1998/01/19 (Mon) 09:06:15 */
		    text->permissible_split = (int) text->last_line->size;
		} else {
		    text->kanji_buf = ch;
		    /*
		     * Can split here.  -FM
		     */
		    text->permissible_split = text->last_line->size;
		    return;
		}
	    }
	} else {
	    goto check_WrapSource;
	}
    } else if (ch == CH_ESC) {	/* S/390 -- gil -- 1587 */
	return;
    }
#ifdef CJK_EX			/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
    if (IS_CJK_TTY &&		/* added condition - kw */
	(ch == LY_BOLD_START_CHAR || ch == LY_BOLD_END_CHAR)) {
	text->permissible_split = (int) line->size;	/* Can split here */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }
#endif

    if (IsSpecialAttrChar(ch) && ch != LY_SOFT_NEWLINE) {
#if !defined(USE_COLOR_STYLE) || !defined(NO_DUMP_WITH_BACKSPACES)
	if (line->size >= (MAX_LINE - 1)) {
	    return;
	}
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	if (with_backspaces && !IS_CJK_TTY && !text->T.output_utf8) {
#endif
	    if (ch == LY_UNDERLINE_START_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_START_CHAR;
		line->data[line->size] = '\0';
		underline_on = TRUE;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_UNDERLINE_END_CHAR) {
		line->data[line->size++] = LY_UNDERLINE_END_CHAR;
		line->data[line->size] = '\0';
		underline_on = FALSE;
		if (!(dump_output_immediately && use_underscore))
		    ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_BOLD_START_CHAR) {
		line->data[line->size++] = LY_BOLD_START_CHAR;
		line->data[line->size] = '\0';
		bold_on = TRUE;
		ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_BOLD_END_CHAR) {
		line->data[line->size++] = LY_BOLD_END_CHAR;
		line->data[line->size] = '\0';
		bold_on = FALSE;
		ctrl_chars_on_this_line++;
		return;
	    } else if (ch == LY_SOFT_HYPHEN) {
		int i;

		/*
		 * Ignore the soft hyphen if it is the first character
		 * on the line, or if it is preceded by a space or
		 * hyphen.  -FM
		 */
		if (line->size < 1 || text->permissible_split >= line->size) {
		    return;
		}

		for (i = (int) (text->permissible_split + 1);
		     line->data[i];
		     i++) {
		    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
			!isspace(UCH(line->data[i])) &&
			UCH(line->data[i]) != '-' &&
			UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
			UCH(line->data[i]) != HT_EN_SPACE) {
			break;
		    }
		}
		if (line->data[i] == '\0') {
		    return;
		}
	    }
#if defined(USE_COLOR_STYLE) && !defined(NO_DUMP_WITH_BACKSPACES)
	} else {
	    /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	    return;
	}
#endif

#else
	return;
#endif
    } else if (ch == LY_SOFT_NEWLINE) {
	line->data[line->size++] = LY_SOFT_NEWLINE;
	line->data[line->size] = '\0';
	return;
    }

    if (text->T.output_utf8) {
	/*
	 * Some extra checks for UTF-8 output here to make sure
	 * memory is not overrun.  For a non-first char, append
	 * to the line here and return.  - kw
	 */
	if (IS_UTF_EXTRA(ch)) {
	    if ((line->size > (MAX_LINE - 1))
		|| (indent + (int) (line->offset + line->size)
		    + UTFXTRA_ON_THIS_LINE
		    - ctrl_chars_on_this_line
		    + ((line->size > 0) &&
		       (int) (line->data[line->size - 1] ==
			      LY_SOFT_HYPHEN ?
			      1 : 0)) >= LYcols_cu(text))
		) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   IS_UTF_EXTRA(line->data[text->permissible_split - 1]))
			text->permissible_split--;
		    if (text->permissible_split &&
			(line->data[text->permissible_split - 1] & 0x80))
			text->permissible_split--;
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    }
	    line->data[line->size++] = (char) ch;
	    line->data[line->size] = '\0';
	    utfxtra_on_this_line++;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch & 0x80) {	/* a first char of UTF-8 sequence - kw */
	    if ((line->size > (MAX_LINE - 7))) {
		if (!text->permissible_split || text->source) {
		    text->permissible_split = line->size;
		    while (text->permissible_split > 0 &&
			   (line->data[text->permissible_split - 1] & 0xc0)
			   == 0x80) {
			text->permissible_split--;
		    }
		    if (text->permissible_split == line->size)
			text->permissible_split = 0;
		}
		split_line(text, text->permissible_split);
		line = text->last_line;
		if (text->source && line->size - ctrl_chars_on_this_line
		    + UTFXTRA_ON_THIS_LINE == 0)
		    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    }
	}
    }

    /*
     * New Line.
     */
    if (ch == '\n') {
	new_line(text);
	text->in_line_1 = YES;	/* First line of new paragraph */
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
	return;
    }

    /*
     * Convert EN_SPACE to a space here so that it doesn't get collapsed.
     */
    if (ch == HT_EN_SPACE)
	ch = ' ';

#ifdef SH_EX			/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {		/* ^K ??? */
	ch = '\r';
    }
    if (ch == 0x1a) {		/* ^Z ??? */
	ch = '\r';
    }
#endif

    /*
     * I'm going to cheat here in a BIG way.  Since I know that all
     * \r's will be trapped by HTML_put_character I'm going to use
     * \r to mean go down a line but don't start a new paragraph.
     * i.e., use the second line indenting.
     */
    if (ch == '\r') {
	new_line(text);
	text->in_line_1 = NO;
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA & kw
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
	return;
    }

    /*
     * Tabs.
     */
    if (ch == '\t') {
	const HTTabStop *Tab;
	int target, target_cu;	/* Where to tab to */
	int here, here_cu;	/* in _cu we try to guess what curses thinks */

	if (line->size > 0 && line->data[line->size - 1] == LY_SOFT_HYPHEN) {
	    /*
	     * A tab shouldn't follow a soft hyphen, so
	     * if one does, we'll dump the soft hyphen.  -FM
	     */
	    line->data[--line->size] = '\0';
	    ctrl_chars_on_this_line--;
	}
	here = ((int) (line->size + line->offset) + indent)
	    - ctrl_chars_on_this_line;	/* Consider special chars GAB */
	here_cu = here + UTFXTRA_ON_THIS_LINE;
	if (style->tabs) {	/* Use tab table */
	    for (Tab = style->tabs;
		 Tab->position <= here;
		 Tab++) {
		if (!Tab->position) {
		    new_line(text);
		    return;
		}
	    }
	    target = Tab->position;
	} else if (text->in_line_1) {	/* Use 2nd indent */
	    if (here >= (int) style->leftIndent) {
		new_line(text);	/* wrap */
		return;
	    } else {
		target = (int) style->leftIndent;
	    }
	} else {		/* Default tabs align with left indent mod 8 */
#ifdef DEFAULT_TABS_8
	    target = (((int) line->offset + (int) line->size + 8) & (-8))
		+ (int) style->leftIndent;
#else
	    new_line(text);
	    return;
#endif
	}

	if (target >= here)
	    target_cu = target;
	else
	    target_cu = target + (here_cu - here);

	if (target > WRAP_COLS(text) - (int) style->rightIndent &&
	    HTOutputFormat != WWW_SOURCE) {
	    new_line(text);
	} else {
	    /*
	     * Can split here.  -FM
	     */
	    text->permissible_split = line->size;
	    if (target_cu > WRAP_COLS(text))
		target -= target_cu - WRAP_COLS(text);
	    if (line->size == 0) {
		line->offset = (unsigned short) (line->offset + (target - here));
	    } else {
		for (; here < target; here++) {
		    /* Put character into line */
		    line->data[line->size++] = ' ';
		    line->data[line->size] = '\0';
		}
	    }
	}
	return;
    }
    /* if tab */
  check_WrapSource:
    if ((text->source || dont_wrap_pre) && text == HTMainText) {
	/*
	 * If we're displaying document source, wrap long lines to keep all of
	 * the source visible.
	 */
	int target = (int) (line->offset + line->size) - ctrl_chars_on_this_line;
	int target_cu = target + UTFXTRA_ON_THIS_LINE;

	if (target >= WRAP_COLS(text) - style->rightIndent -
	    ((IS_CJK_TTY && text->kanji_buf) ? 1 : 0) ||
	    (text->T.output_utf8 &&
	     target_cu + UTF_XLEN(ch) >= LYcols_cu(text))) {
	    int saved_kanji_buf;
	    eGridState saved_state;
	    BOOL add_blank = (dont_wrap_pre
			      && line->size
			      && (line->data[line->size - 1] == ' '));

	    new_line(text);
	    line = text->last_line;

	    saved_kanji_buf = text->kanji_buf;
	    saved_state = text->state;
	    text->kanji_buf = '\0';
	    text->state = S_text;
	    HText_appendCharacter(text, LY_SOFT_NEWLINE);
	    if (add_blank)
		HText_appendCharacter(text, ' ');
	    text->kanji_buf = saved_kanji_buf;
	    text->state = saved_state;
	}
    }

    if (ch == ' ') {
	/*
	 * Can split here.  -FM
	 */
	text->permissible_split = text->last_line->size;
	/*
	 * There are some pages written in
	 * different kanji codes.  - TA
	 */
	if (HTCJK == JAPANESE)
	    text->kcode = NOKANJI;
    }

    /*
     * Check for end of line.
     *
     * Notes:
     * 1) text->permissible_split is nonzero if we found a place to split the
     *    line.  If there is no such place, we still will wrap at the display
     *    limits (the comparison against LYcols_cu).  Furthermore, if the
     *    curses-pads feature is active, we will ignore the first comparison
     *    (against WRAP_COLS) to allow wide preformatted text to be displayed
     *    without wrapping.
     * 2) ctrl_chars_on_this_line are nonprintable bytes used for formatting.
     */
    actual = ((indent + (int) line->offset + (int) line->size) +
	      ((line->size > 0) &&
	       (int) (line->data[line->size - 1] == LY_SOFT_HYPHEN ? 1 : 0))
	      - ctrl_chars_on_this_line);

    if (((text->permissible_split
#ifdef USE_CURSES_PADS
	  || !LYwideLines
#endif
	 ) && (actual
	       + (int) style->rightIndent
	       + ((IS_CJK_TTY && text->kanji_buf) ? 1 : 0)
	 ) >= WRAP_COLS(text))
	|| (text->T.output_utf8
	    && ((actual
		 + UTFXTRA_ON_THIS_LINE
		 + UTF_XLEN(ch)
		) > (LYcols_cu(text) - 1)))) {

	if (style->wordWrap && HTOutputFormat != WWW_SOURCE) {
#ifdef USE_JUSTIFY_ELTS
	    if (REALLY_CAN_JUSTIFY(text))
		this_line_was_split = TRUE;
#endif
	    split_line(text, text->permissible_split);
	    if (ch == ' ') {
		return;		/* Ignore space causing split */
	    }

	} else if (HTOutputFormat == WWW_SOURCE) {
	    /*
	     * For source output we don't want to wrap this stuff
	     * unless absolutely necessary.  - LJM
	     * !
	     * If we don't wrap here we might get a segmentation fault.
	     * but let's see what happens
	     */
	    if ((int) line->size >= (int) (MAX_LINE - 1)) {
		new_line(text);	/* try not to linewrap */
	    }
	} else {
	    /*
	     * For normal stuff like pre let's go ahead and
	     * wrap so the user can see all of the text.
	     */
	    if ((dump_output_immediately || (crawl && traversal))
		&& dont_wrap_pre) {
		if ((int) line->size >= (int) (MAX_LINE - 1)) {
		    new_line(text);
		}
	    } else {
		new_line(text);
	    }
	}
    } else if ((int) line->size >= (int) (MAX_LINE - 1)) {
	/*
	 * Never overrun memory if DISPLAY_COLS is set to a large value - KW
	 */
	new_line(text);
    }

    /*
     * Insert normal characters.
     */
    if (ch == HT_NON_BREAK_SPACE
#ifdef USE_JUSTIFY_ELTS
	&& !REALLY_CAN_JUSTIFY(text)
#endif
	)
	ch = ' ';
#ifdef USE_JUSTIFY_ELTS
    else
	have_raw_nbsps = TRUE;
#endif

    /* we leave raw HT_NON_BREAK_SPACE otherwise (we'll substitute it later) */

    if (ch & 0x80)
	text->have_8bit_chars = YES;

    /*
     * Kanji charactor handling.
     */
    {
	HTFont font = style->font;
	unsigned char hi, lo, tmp[2];

	line = text->last_line;	/* May have changed */

	if (IS_CJK_TTY && text->kanji_buf) {
	    hi = UCH(text->kanji_buf);
	    lo = UCH(ch);

	    if (HTCJK == JAPANESE) {
		if (text->kcode != JIS) {
		    if (IS_SJIS_2BYTE(hi, lo)) {
			if (IS_EUC(hi, lo)) {
#ifdef KANJI_CODE_OVERRIDE
			    if (last_kcode != NOKANJI)
				text->kcode = last_kcode;
			    else
#endif
			    if (text->specified_kcode != NOKANJI)
				text->kcode = text->specified_kcode;
#ifdef USE_TH_JP_AUTO_DETECT
			    else if (text->detected_kcode == DET_EUC)
				text->kcode = EUC;
			    else if (text->detected_kcode == DET_SJIS)
				text->kcode = SJIS;
#endif
			    else if (IS_EUC_X0201KANA(hi, lo) &&
				     (text->kcode != EUC))
				text->kcode = SJIS;
			} else
			    text->kcode = SJIS;
		    } else if (IS_EUC(hi, lo))
			text->kcode = EUC;
		    else
			text->kcode = NOKANJI;
		}

		switch (kanji_code) {
		case EUC:
		    if (text->kcode == SJIS) {
			SJIS_TO_EUC1(hi, lo, tmp);
			line->data[line->size++] = (char) tmp[0];
			line->data[line->size++] = (char) tmp[1];
		    } else if (IS_EUC(hi, lo)) {
			if (conv_jisx0201kana) {
			    JISx0201TO0208_EUC(hi, lo, &hi, &lo);
			}
			line->data[line->size++] = (char) hi;
			line->data[line->size++] = (char) lo;
		    } else {
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
		    }
		    break;

		case SJIS:
		    if ((text->kcode == EUC) || (text->kcode == JIS)) {
			if (!conv_jisx0201kana && IS_EUC_X0201KANA(hi, lo)) {
			    if (IS_EUC_X0201KANA(hi, lo)) {
				line->data[line->size++] = (char) lo;
			    } else {
				EUC_TO_SJIS1(hi, lo, tmp);
				line->data[line->size++] = (char) tmp[0];
				line->data[line->size++] = (char) tmp[1];
			    }
			}
		    } else if (IS_SJIS_2BYTE(hi, lo)) {
			line->data[line->size++] = (char) hi;
			line->data[line->size++] = (char) lo;
		    } else {
			line->data[line->size++] = '=';
			line->data[line->size++] = '=';
			CTRACE((tfp,
				"This character (%X:%X) doesn't seem Japanese\n",
				hi, lo));
		    }
		    break;

		default:
		    break;
		}
	    } else {
		line->data[line->size++] = (char) hi;
		line->data[line->size++] = (char) lo;
	    }
	    text->kanji_buf = 0;
	} else if (!conv_jisx0201kana
		   && (HTCJK == JAPANESE)
		   && IS_SJIS_X0201KANA(UCH((ch))) &&
		   (kanji_code == EUC)) {
	    line->data[line->size++] = (char) UCH(0x8e);
	    line->data[line->size++] = (char) ch;
	} else if (IS_CJK_TTY) {
	    line->data[line->size++] = (char) ((kanji_code != NOKANJI) ?
					       ch :
					       (font & HT_CAPITALS) ?
					       TOUPPER(ch) : ch);
	} else {
	    line->data[line->size++] =	/* Put character into line */
		(char) (font & HT_CAPITALS ? TOUPPER(ch) : ch);
	}
	line->data[line->size] = '\0';
	if (font & HT_DOUBLE)	/* Do again if doubled */
	    HText_appendCharacter(text, HT_NON_BREAK_SPACE);
	/* NOT a permissible split */

	if (ch == LY_SOFT_HYPHEN) {
	    ctrl_chars_on_this_line++;
	    /*
	     * Can split here.  -FM
	     */
	    text->permissible_split = text->last_line->size;
	}
	if (ch == LY_SOFT_NEWLINE) {
	    ctrl_chars_on_this_line++;
	}
    }
    return;
}

#ifdef USE_COLOR_STYLE
/*  Insert a style change into the current line
 *  -------------------------------------------
 */
void _internal_HTC(HText *text, int style, int dir)
{
    HTLine *line;

    /* can't change style if we have no text to change style with */
    if (text != 0) {

	line = text->last_line;

	if (line->numstyles > 0 && dir == 0 &&
	    line->styles[line->numstyles - 1].sc_direction &&
	    line->styles[line->numstyles - 1].sc_style == (unsigned) style &&
	    (int) line->styles[line->numstyles - 1].sc_horizpos
	    == (int) line->size - ctrl_chars_on_this_line) {
	    /*
	     * If this is an OFF change directly preceded by an
	     * ON for the same style, just remove the previous one.  - kw
	     */
	    line->numstyles--;
	} else if (line->numstyles < MAX_STYLES_ON_LINE) {
	    line->styles[line->numstyles].sc_horizpos = line->size;
	    /*
	     * Special chars for bold and underlining usually don't
	     * occur with color style, but soft hyphen can.
	     * And in UTF-8 display mode all non-initial bytes are
	     * counted as ctrl_chars.  - kw
	     */
	    if ((int) line->styles[line->numstyles].sc_horizpos >= ctrl_chars_on_this_line) {
		line->styles[line->numstyles].sc_horizpos -= ctrl_chars_on_this_line;
	    }
	    line->styles[line->numstyles].sc_style = style;
	    line->styles[line->numstyles].sc_direction = dir;
	    CTRACE_STYLE((tfp, "internal_HTC %d:style[%d] %d (dir=%d)\n",
			  line->size,
			  line->numstyles,
			  style,
			  dir));
	    line->numstyles++;
	}
    }
}
#endif

/*	Set LastChar element in the text object.
 *	----------------------------------------
 */
void HText_setLastChar(HText *text, int ch)
{
    if (!text)
	return;

    text->LastChar = (char) ch;
}

/*	Get LastChar element in the text object.
 *	----------------------------------------
 */
char HText_getLastChar(HText *text)
{
    if (!text)
	return ('\0');

    return ((char) text->LastChar);
}

/*		Simple table handling - private
 *		-------------------------------
 */

/*
 * HText_insertBlanksInStblLines fixes up table lines when simple table
 * processing is closed, by calling insert_blanks_in_line for lines
 * that need fixup.  Also recalculates alignment for those lines,
 * does additional updating of anchor positions, and makes sure the
 * display of the lines on screen will be updated after partial display
 * upon return to mainloop.  - kw
 */
static int HText_insertBlanksInStblLines(HText *me, int ncols)
{
    HTLine *line;
    HTLine *mod_line, *first_line = NULL;
    int *oldpos;
    int *newpos;
    int ninserts, lineno;
    int last_lineno, first_lineno_pass2;

#ifdef EXP_NESTED_TABLES
    int last_nonempty = -1;
#endif
    int added_chars_before = 0;
    int lines_changed = 0;
    int max_width = 0, indent, spare, table_offset;
    HTStyle *style;
    short alignment;
    int i = 0;

    lineno = Stbl_getStartLine(me->stbl);
    if (lineno < 0 || lineno > me->Lines)
	return -1;
    /*
     * oldpos, newpos:  allocate space for two int arrays.
     */
    oldpos = typecallocn(int, 2 * (size_t)ncols);
    if (!oldpos)
	return -1;
    else
	newpos = oldpos + ncols;
    for (line = FirstHTLine(me); i < lineno; line = line->next, i++) {
	if (!line) {
	    free(oldpos);
	    return -1;
	}
    }
    first_lineno_pass2 = last_lineno = me->Lines;
    for (; line && lineno <= last_lineno; line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts < 0)
	    continue;
	if (!first_line) {
	    first_line = line;
	    first_lineno_pass2 = lineno;
	    if (TRACE) {
		int ip;

		CTRACE((tfp, "line %d first to adjust  --  newpos:", lineno));
		for (ip = 0; ip < ncols; ip++)
		    CTRACE((tfp, " %d", newpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
	if (line == me->last_line) {
	    if (line->size == 0 || HText_TrueEmptyLine(line, me, FALSE))
		continue;
	    /*
	     * Last ditch effort to end the table with a line break,
	     * if HTML_end_element didn't do it.  - kw
	     */
	    if (first_line == line)	/* obscure: all table on last line... */
		first_line = NULL;
	    new_line(me);
	    line = me->last_line->prev;
	    if (first_line == NULL)
		first_line = line;
	}
	if (ninserts == 0) {
	    /*  Do it also for no positions (but not error) */
	    int width = HText_TrueLineSize(line, me, FALSE);

	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    CTRACE((tfp, "line %d true/max width:%d/%d oldpos: NONE\n",
		    lineno, width, max_width));
	    continue;
	}
	mod_line = insert_blanks_in_line(line, lineno, me,
					 &me->last_anchor_before_stbl /*updates++ */ ,
					 ninserts, oldpos, newpos);
	if (mod_line) {
	    if (line == me->last_line) {
		me->last_line = mod_line;
	    } else {
		added_chars_before += (mod_line->size - line->size);
	    }
	    line->prev->next = mod_line;
	    line->next->prev = mod_line;
	    lines_changed++;
	    if (line == first_line)
		first_line = mod_line;
	    freeHTLine(me, line);
	    line = mod_line;
#ifdef DISP_PARTIAL
	    /*
	     * Make sure modified lines get fully re-displayed after
	     * loading with partial display is done.
	     */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    ResetPartialLinenos(me);
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	} {
	    int width = HText_TrueLineSize(line, me, FALSE);

	    if (width > max_width)
		max_width = width;
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		if (width && last_nonempty < lineno)
		    last_nonempty = lineno;
	    }
#endif
	    if (TRACE) {
		int ip;

		CTRACE((tfp, "line %d true/max width:%d/%d oldpos:",
			lineno, width, max_width));
		for (ip = 0; ip < ninserts; ip++)
		    CTRACE((tfp, " %d", oldpos[ip]));
		CTRACE((tfp, "\n"));
	    }
	}
    }
    /*
     * Line offsets have been set based on the paragraph style, and
     * have already been updated for centering or right-alignment
     * for each line in split_line.  Here we want to undo all that, and
     * align the table as a whole (i.e.  all lines for which
     * Stbl_getFixupPositions returned >= 0).  All those lines have to
     * get the same offset, for the simple table formatting mechanism
     * to make sense, and that may not actually be the case at this point.
     *
     * What indentation and alignment do we want for the table as
     * a whole?  Let's take most style properties from me->style.
     * With some luck, it is the appropriate style for the element
     * enclosing the TABLE.  But let's take alignment from the attribute
     * of the TABLE itself instead, if it was specified.
     *
     * Note that this logic assumes that all lines have been finished
     * by split_line.  The order of calls made by HTML_end_element for
     * HTML_TABLE should take care of this.
     */
    style = me->style;
    alignment = Stbl_getAlignment(me->stbl);
    if (alignment == HT_ALIGN_NONE)
	alignment = style->alignment;
    indent = style->leftIndent;
    /* Calculate spare character positions */
    spare = WRAP_COLS(me) -
	(int) style->rightIndent - indent - max_width;
    if (spare < 0 && (int) style->rightIndent + spare >= 0) {
	/*
	 * Not enough room!  But we can fit if we ignore right indentation,
	 * so let's do that.
	 */
	spare = 0;
    } else if (spare < 0) {
	spare += style->rightIndent;	/* ignore right indent, but need more */
    }
    if (spare < 0 && indent + spare >= 0) {
	/*
	 * Still not enough room.  But we can move to the left.
	 */
	indent += spare;
	spare = 0;
    } else if (spare < 0) {
	/*
	 * Still not enough.  Something went wrong.  Try the best we
	 * can do.
	 */
	CTRACE((tfp,
		"BUG: insertBlanks: resulting table too wide by %d positions!\n",
		-spare));
	indent = spare = 0;
    }
    /*
     * Align left, right or center.
     */
    switch (alignment) {
    case HT_CENTER:
	table_offset = indent + spare / 2;
	break;
    case HT_RIGHT:
	table_offset = indent + spare;
	break;
    case HT_LEFT:
    case HT_JUSTIFY:
    default:
	table_offset = indent;
	break;
    }				/* switch */

    CTRACE((tfp, "changing offsets"));
    for (line = first_line, lineno = first_lineno_pass2;
	 line && lineno <= last_lineno && line != me->last_line;
	 line = line->next, lineno++) {
	ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
	if (ninserts >= 0 && (int) line->offset != table_offset) {
#ifdef DISP_PARTIAL
	    /*  As above make sure modified lines get fully re-displayed */
	    if (me->first_lineno_last_disp_partial >= 0) {
		if (me->first_lineno_last_disp_partial >= lineno) {
		    ResetPartialLinenos(me);
		} else if (me->last_lineno_last_disp_partial >= lineno) {
		    me->last_lineno_last_disp_partial = lineno - 1;
		}
	    }
#endif
	    CTRACE((tfp, " %d:%d", lineno, table_offset - line->offset));
	    line->offset = (unsigned short) (table_offset > 0
					     ? table_offset
					     : 0);
	}
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	if (max_width)
	    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
    }
#endif
    CTRACE((tfp, " %d:done\n", lineno));
    free(oldpos);
    return lines_changed;
}

/*		Simple table handling - public functions
 *		----------------------------------------
 */

/*	Cancel simple table handling
*/
void HText_cancelStbl(HText *me)
{
    if (!me || !me->stbl) {
	CTRACE((tfp, "cancelStbl: ignored.\n"));
	return;
    }
    CTRACE((tfp, "cancelStbl: ok, will do.\n"));
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	STable_info *stbl = me->stbl;

	while (stbl) {
	    STable_info *enclosing = Stbl_get_enclosing(stbl);

	    Stbl_free(stbl);
	    stbl = enclosing;
	}
    } else
#endif
	Stbl_free(me->stbl);
    me->stbl = NULL;
}

/*	Start simple table handling
*/
void HText_startStblTABLE(HText *me, int alignment)
{
    if (me) {
#ifdef EXP_NESTED_TABLES
	STable_info *current = me->stbl;
#endif

#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    if (current)
		new_line(me);
	} else
#endif
	{
	    if (me->stbl)
		HText_cancelStbl(me);	/* auto cancel previously open table */
	}

	me->stbl = Stbl_startTABLE(alignment);
	if (me->stbl) {
	    CTRACE((tfp, "startStblTABLE: started.\n"));
#ifdef EXP_NESTED_TABLES
	    if (nested_tables) {
		Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
	    }
#endif
	    me->last_anchor_before_stbl = me->last_anchor;
	} else {
	    CTRACE((tfp, "startStblTABLE: failed.\n"));
	}
    }
}

#ifdef EXP_NESTED_TABLES
static void free_enclosed_stbl(HText *me)
{
    if (me != NULL && me->enclosed_stbl != NULL) {
	HTList *list = me->enclosed_stbl;
	STable_info *stbl;

	while (NULL != (stbl = (STable_info *) HTList_nextObject(list))) {
	    CTRACE((tfp, "endStblTABLE: finally free %p\n", (void *) me->stbl));
	    Stbl_free(stbl);
	}
	HTList_delete(me->enclosed_stbl);
	me->enclosed_stbl = NULL;
    }
}

#else
#define free_enclosed_stbl(me)	/* nothing */
#endif

/*	Finish simple table handling
 *	Return TRUE if the table is nested inside another table.
 */
BOOLEAN HText_endStblTABLE(HText *me)
{
    int ncols, lines_changed = 0;
    STable_info *enclosing = NULL;

    if (!me || !me->stbl) {
	CTRACE((tfp, "endStblTABLE: ignored.\n"));
	free_enclosed_stbl(me);
	return FALSE;
    }
    CTRACE((tfp, "endStblTABLE: ok, will try.\n"));

    ncols = Stbl_finishTABLE(me->stbl);
    CTRACE((tfp, "endStblTABLE: ncols = %d.\n", ncols));

    if (ncols > 0) {
	lines_changed = HText_insertBlanksInStblLines(me, ncols);
	CTRACE((tfp, "endStblTABLE: changed %d lines, done.\n", lines_changed));
#ifdef DISP_PARTIAL
	/* allow HTDisplayPartial() to redisplay the changed lines.
	 * There is no harm if we got several stbl in the document, hope so.
	 */
	NumOfLines_partial -= lines_changed;	/* fake */
#endif /* DISP_PARTIAL */
    }
#ifdef EXP_NESTED_TABLES
    if (nested_tables) {
	enclosing = Stbl_get_enclosing(me->stbl);
	me->last_anchor_before_stbl = Stbl_get_last_anchor_before(me->stbl);
	if (enclosing == NULL) {
	    Stbl_free(me->stbl);
	    free_enclosed_stbl(me);
	} else {
	    if (me->enclosed_stbl == NULL)
		me->enclosed_stbl = HTList_new();
	    HTList_addObject(me->enclosed_stbl, me->stbl);
	    CTRACE((tfp, "endStblTABLE: postpone free %p\n", (void *) me->stbl));
	}
	me->stbl = enclosing;
    } else {
	Stbl_free(me->stbl);
	me->stbl = NULL;
    }
#else
    Stbl_free(me->stbl);
    me->stbl = NULL;
#endif

    CTRACE((tfp, "endStblTABLE: have%s enclosing table (%p)\n",
	    enclosing == 0 ? " NO" : "", (void *) enclosing));

    return (BOOLEAN) (enclosing != 0);
}

/*	Start simple table row
*/
void HText_startStblTR(HText *me, int alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowToTable(me->stbl, alignment, me->Lines) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish simple table row
*/
void HText_endStblTR(HText *me)
{
    if (!me || !me->stbl)
	return;
    /* should this do something?? */
}

/*	Start simple table cell
*/
void HText_startStblTD(HText *me, int colspan,
		       int rowspan,
		       int alignment,
		       int isheader)
{
    if (!me || !me->stbl)
	return;
    if (colspan < 0)
	colspan = 1;
    if (colspan > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** COLSPAN=%d is too large, ignored!\n", colspan));
	colspan = 1;
    }
    if (rowspan > TRST_MAXROWSPAN) {
	CTRACE((tfp, "*** ROWSPAN=%d is too large, ignored!\n", rowspan));
	rowspan = 1;
    }
    if (Stbl_addCellToTable(me->stbl, colspan, rowspan, alignment, isheader,
			    me->Lines,
			    HText_LastLineOffset(me),
			    HText_LastLineSize(me, FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish simple table cell
*/
void HText_endStblTD(HText *me)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_finishCellInTable(me->stbl, TRST_ENDCELL_ENDTD,
			       me->Lines,
			       HText_LastLineOffset(me),
			       HText_LastLineSize(me, FALSE)) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Remember COL info / Start a COLGROUP and remember info
*/
void HText_startStblCOL(HText *me, int span,
			int alignment,
			int isgroup)
{
    if (!me || !me->stbl)
	return;
    if (span <= 0)
	span = 1;
    if (span > TRST_MAXCOLSPAN) {
	CTRACE((tfp, "*** SPAN=%d is too large, ignored!\n", span));
	span = 1;
    }
    if (Stbl_addColInfo(me->stbl, span, alignment, isgroup) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Finish a COLGROUP
*/
void HText_endStblCOLGROUP(HText *me)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_finishColGroup(me->stbl) < 0)
	HText_cancelStbl(me);	/* give up */
}

/*	Start a THEAD / TFOOT / TBODY - remember its alignment info
*/
void HText_startStblRowGroup(HText *me, int alignment)
{
    if (!me || !me->stbl)
	return;
    if (Stbl_addRowGroup(me->stbl, alignment) < 0)
	HText_cancelStbl(me);	/* give up */
}

static void compute_show_number(TextAnchor *a)
{
    HTAnchor *cur, *tst;
    TextAnchor *b;
    int match;

    a->show_number = a->number;
    if (unique_urls
	&& HTMainText != 0
	&& HTMainText->first_anchor != 0
	&& a->anchor != 0
	&& (cur = a->anchor->dest) != 0
	&& cur->parent != 0
	&& cur->parent->address != 0) {

	match = 0;
	for (b = HTMainText->first_anchor; b != a; b = b->next) {
	    if (b->anchor != 0
		&& (tst = b->anchor->dest) != 0
		&& tst->parent != 0
		&& tst->parent->address != 0
		&& !strcmp(cur->parent->address,
			   tst->parent->address)
		&& !strcmp(NonNull(a->anchor->tag), NonNull(b->anchor->tag))) {
		match = b->show_number;
		break;
	    }
	}
	if (match)
	    a->show_number = match;
	else
	    a->show_number = HTMainText->next_number++;
    }
}

/*		Anchor handling
 *		---------------
 */
static void add_link_number(HText *text, TextAnchor *a, int save_position)
{
    char marker[32];

    /*
     * If we are doing link_numbering add the link number.
     */
    if ((a->number > 0)
#ifdef USE_PRETTYSRC
	&& (text->source ? !psrcview_no_anchor_numbering : 1)
#endif
	&& links_are_numbered()) {
	char saved_lastchar = text->LastChar;
	int saved_linenum = text->Lines;
	HTAnchor *link_dest;
	char *link_text;

	compute_show_number(a);

	if (dump_links_inline
	    && (link_dest = HTAnchor_followLink(a->anchor)) != 0
	    && (link_text = HTAnchor_address(link_dest)) != 0) {
	    HText_appendText(text, "[");
	    HText_appendText(text, link_text);
	    HText_appendText(text, "]");
	} else {
	    sprintf(marker, "[%d]", a->show_number);
	    HText_appendText(text, marker);
	}
	if (saved_linenum && text->Lines && saved_lastchar != ' ')
	    text->LastChar = ']';	/* if marker not after space caused split */
	if (save_position) {
	    a->line_num = text->Lines;
	    a->line_pos = (short) text->last_line->size;
	}
    }
}

/*	Start an anchor field
*/
int HText_beginAnchor(HText *text, int underline,
		      HTChildAnchor *anc)
{
    TextAnchor *a;

    POOLtypecalloc(TextAnchor, a);

    if (a == NULL)
	outofmem(__FILE__, "HText_beginAnchor");

    assert(a != NULL);

    a->inUnderline = (BOOLEAN) underline;

    a->sgml_offset = SGML_offset();
    a->line_num = text->Lines;
    a->line_pos = (short) text->last_line->size;
    if (text->last_anchor) {
	text->last_anchor->next = a;
    } else {
	text->first_anchor = a;
    }
    a->next = 0;
    a->anchor = anc;
    a->extent = 0;
    a->link_type = HYPERTEXT_ANCHOR;
    text->last_anchor = a;

    if (track_internal_links
	&& HTAnchor_followTypedLink(anc, HTInternalLink)) {
	a->number = ++(text->last_anchor_number);
	a->link_type = INTERNAL_LINK_ANCHOR;
    } else if (HTAnchor_followLink(anc)) {
	a->number = ++(text->last_anchor_number);
    } else {
	a->number = 0;
    }
    a->show_number = 0;

    if (number_links_on_left)
	add_link_number(text, a, TRUE);
    return (a->number);
}

/* If !really, report whether the anchor is empty. */
static BOOL HText_endAnchor0(HText *text, int number,
			     int really)
{
    TextAnchor *a;

    /*
     * The number argument is set to 0 in HTML.c and
     * LYCharUtils.c when we want to end the anchor
     * for the immediately preceding HText_beginAnchor()
     * call.  If it's greater than 0, we want to handle
     * a particular anchor.  This allows us to set links
     * for positions indicated by NAME or ID attributes,
     * without needing to close any anchor with an HREF
     * within which that link might be embedded.  -FM
     */
    if (number <= 0 || number == text->last_anchor->number) {
	a = text->last_anchor;
    } else {
	for (a = text->first_anchor; a; a = a->next) {
	    if (a->number == number) {
		break;
	    }
	}
	if (a == NULL) {
	    /*
	     * There's no anchor with that number,
	     * so we'll default to the last anchor,
	     * and cross our fingers.  -FM
	     */
	    a = text->last_anchor;
	}
    }

    CTRACE((tfp, "GridText:HText_endAnchor0: number:%d link_type:%d\n",
	    a->number, a->link_type));
    if (a->link_type == INPUT_ANCHOR) {
	/*
	 * Shouldn't happen, but put test here anyway to be safe.  - LE
	 */

	CTRACE((tfp,
		"BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
	return FALSE;
    }

    if (a->number) {
	/*
	 * If it goes somewhere...
	 */
	int i, j, k, l;
	BOOL remove_numbers_on_empty = (BOOL) ((links_are_numbered() &&
						((text->hiddenlinkflag != HIDDENLINKS_MERGE)
						 || (LYNoISMAPifUSEMAP &&
						     !(text->node_anchor && text->node_anchor->bookmark)
						     && HTAnchor_isISMAPScript
						     (HTAnchor_followLink(a->anchor))))));
	HTLine *last = text->last_line;
	HTLine *prev = text->last_line->prev;
	HTLine *start = last;
	int CurBlankExtent = 0;
	int BlankExtent = 0;
	int extent_adjust = 0;

	/* Find the length taken by the anchor */
	l = text->Lines;	/* lineno of last */

	/* the last line of an anchor may contain a trailing blank,
	 * which will be trimmed later.  Discount it from the extent.
	 */
	if (l > a->line_num) {
	    for (i = start->size; i > 0; --i) {
		if (isspace(UCH(start->data[i - 1]))) {
		    --extent_adjust;
		} else {
		    break;
		}
	    }
	}

	while (l > a->line_num) {
	    extent_adjust += start->size;
	    start = start->prev;
	    l--;
	}
	/* Now start is the start line of the anchor */
	extent_adjust += start->size - a->line_pos;
	start = last;		/* Used later */

	/*
	 * Check if the anchor content has only
	 * white and special characters, starting
	 * with the content on the last line.  -FM
	 */
	a->extent = (short) (a->extent + extent_adjust);
	if (a->extent > (int) last->size) {
	    /*
	     * The anchor extends over more than one line,
	     * so set up to check the entire last line.  -FM
	     */
	    i = last->size;
	} else {
	    /*
	     * The anchor is restricted to the last line,
	     * so check from the start of the anchor.  -FM
	     */
	    i = a->extent;
	}
	k = j = (last->size - i);
	while (j < (int) last->size) {
	    if (!IsSpecialAttrChar(last->data[j]) &&
		!isspace(UCH(last->data[j])) &&
		last->data[j] != HT_NON_BREAK_SPACE &&
		last->data[j] != HT_EN_SPACE)
		break;
	    i--;
	    j++;
	}
	if (i == 0) {
	    if (a->extent > (int) last->size) {
		/*
		 * The anchor starts on a preceding line, and
		 * the last line has only white and special
		 * characters, so declare the entire extent
		 * of the last line as blank.  -FM
		 */
		CurBlankExtent = BlankExtent = last->size;
	    } else {
		/*
		 * The anchor starts on the last line, and
		 * has only white or special characters, so
		 * declare the anchor's extent as blank.  -FM
		 */
		CurBlankExtent = BlankExtent = a->extent;
	    }
	}
	/*
	 * While the anchor starts on a line preceding
	 * the one we just checked, and the one we just
	 * checked has only white and special characters,
	 * check whether the anchor's content on the
	 * immediately preceding line also has only
	 * white and special characters.  -FM
	 */
	while (i == 0 &&
	       (a->extent > CurBlankExtent ||
		(a->extent == CurBlankExtent &&
		 k == 0 &&
		 prev != text->last_line &&
		 (prev->size == 0 ||
		  prev->data[prev->size - 1] == ']')))) {
	    start = prev;
	    k = j = prev->size - a->extent + CurBlankExtent;
	    if (j < 0) {
		/*
		 * The anchor starts on a preceding line,
		 * so check all of this line.  -FM
		 */
		j = 0;
		i = prev->size;
	    } else {
		/*
		 * The anchor starts on this line.  -FM
		 */
		i = a->extent - CurBlankExtent;
	    }
	    while (j < (int) prev->size) {
		if (!IsSpecialAttrChar(prev->data[j]) &&
		    !isspace(UCH(prev->data[j])) &&
		    prev->data[j] != HT_NON_BREAK_SPACE &&
		    prev->data[j] != HT_EN_SPACE)
		    break;
		i--;
		j++;
	    }
	    if (i == 0) {
		if (a->extent > (CurBlankExtent + (int) prev->size) ||
		    (a->extent == CurBlankExtent + (int) prev->size &&
		     k == 0 &&
		     prev->prev != text->last_line &&
		     (prev->prev->size == 0 ||
		      prev->prev->data[prev->prev->size - 1] == ']'))) {
		    /*
		     * This line has only white and special
		     * characters, so treat its entire extent
		     * as blank, and decrement the pointer for
		     * the line to be analyzed.  -FM
		     */
		    CurBlankExtent += prev->size;
		    BlankExtent = CurBlankExtent;
		    prev = prev->prev;
		} else {
		    /*
		     * The anchor starts on this line, and it
		     * has only white or special characters, so
		     * declare the anchor's extent as blank.  -FM
		     */
		    BlankExtent = a->extent;
		    break;
		}
	    }
	}
	if (!really) {		/* Just report whether it is empty */
	    a->extent = (short) (a->extent - extent_adjust);
	    return (BOOL) (i == 0);
	}
	if (i == 0) {
	    /*
	     * It's an invisible anchor probably from an ALT=""
	     * or an ignored ISMAP attribute due to a companion
	     * USEMAP.  -FM
	     */
	    a->show_anchor = NO;

	    CTRACE((tfp,
		    "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));

	    /*
	     * If links are numbered, then try to get rid of the
	     * numbered bracket and adjust the anchor count.  -FM
	     *
	     * Well, let's do this only if -hiddenlinks=merged is not in
	     * effect, or if we can be reasonably sure that
	     * this is the result of an intentional non-generation of
	     * anchor text via NO_ISMAP_IF_USEMAP.  In other cases it can
	     * actually be a feature that numbered links alert the viewer
	     * to the presence of a link which is otherwise not selectable -
	     * possibly caused by HTML errors. - kw
	     */
	    if (remove_numbers_on_empty) {
		int NumSize = 0;
		TextAnchor *anc;

		/*
		 * Set start->data[j] to the close-square-bracket,
		 * or to the beginning of the line on which the
		 * anchor start.  -FM
		 */
		if (start == last) {
		    /*
		     * The anchor starts on the last line.  -FM
		     */
		    j = (last->size - a->extent - 1);
		} else {
		    /*
		     * The anchor starts on a previous line.  -FM
		     */
		    prev = start->prev;
		    j = (start->size - a->extent + CurBlankExtent - 1);
		}
		if (j < 0)
		    j = 0;
		i = j;

		/*
		 * If start->data[j] is a close-square-bracket, verify
		 * that it's the end of the numbered bracket, and if so,
		 * strip the numbered bracket.  If start->data[j] is not
		 * a close-square-bracket, check whether we had a wrap
		 * and the close-square-bracket is at the end of the
		 * previous line.  If so, strip the numbered bracket
		 * from that line.  -FM
		 */
		if (start->data[j] == ']') {
		    j--;
		    NumSize++;
		    while (j >= 0 && isdigit(UCH(start->data[j]))) {
			j--;
			NumSize++;
		    }
		    while (j < 0) {
			j++;
			NumSize--;
		    }
		    if (start->data[j] == '[') {
			/*
			 * The numbered bracket is entirely
			 * on this line.  -FM
			 */
			NumSize++;
			if (start == last && (int) text->permissible_split > j) {
			    if ((int) text->permissible_split - NumSize < j)
				text->permissible_split = (unsigned) j;
			    else
				text->permissible_split -= (unsigned) NumSize;
			}
			k = j + NumSize;
			while (k < (int) start->size)
			    start->data[j++] = start->data[k++];
			for (anc = a; anc; anc = anc->next) {
			    if (anc->line_num == a->line_num &&
				anc->line_pos >= NumSize) {
				anc->line_pos = (short) (anc->line_pos - NumSize);
			    }
			}
			start->size = (unsigned short) j;
			start->data[j++] = '\0';
			while (j < k)
			    start->data[j++] = '\0';
		    } else if (prev && prev->size > 1) {
			k = (i + 1);
			j = (prev->size - 1);
			while ((j >= 0) && IsSpecialAttrChar(prev->data[j]))
			    j--;
			i = (j + 1);
			while (j >= 0 &&
			       isdigit(UCH(prev->data[j]))) {
			    j--;
			    NumSize++;
			}
			while (j < 0) {
			    j++;
			    NumSize--;
			}
			if (prev->data[j] == '[') {
			    /*
			     * The numbered bracket started on the
			     * previous line, and part of it was
			     * wrapped to this line.  -FM
			     */
			    while (i < (int) prev->size)
				prev->data[j++] = prev->data[i++];
			    prev->size = (unsigned short) j;
			    prev->data[j] = '\0';
			    while (j < i)
				prev->data[j++] = '\0';
			    if (start == last && text->permissible_split > 0) {
				if ((int) text->permissible_split < k)
				    text->permissible_split = 0;
				else
				    text->permissible_split -= (unsigned) k;
			    }
			    j = 0;
			    i = k;
			    while (k < (int) start->size)
				start->data[j++] = start->data[k++];
			    for (anc = a; anc; anc = anc->next) {
				if (anc->line_num == a->line_num &&
				    anc->line_pos >= i) {
				    anc->line_pos = (short) (anc->line_pos - i);
				}
			    }
			    start->size = (unsigned short) j;
			    start->data[j++] = '\0';
			    while (j < k)
				start->data[j++] = '\0';
			} else {
			    /*
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
			     */
			    a->show_anchor = YES;
			}
		    } else {
			/*
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
			 */
			a->show_anchor = YES;
		    }
		} else if (prev && prev->size > 2) {
		    j = (prev->size - 1);
		    while ((j >= 0) && IsSpecialAttrChar(prev->data[j]))
			j--;
		    if (j < 0)
			j = 0;
		    if ((j >= 2) &&
			(prev->data[j] == ']' &&
			 isdigit(UCH(prev->data[j - 1])))) {
			j--;
			NumSize++;
			while (j >= 0 &&
			       isdigit(UCH(prev->data[j]))) {
			    j--;
			    NumSize++;
			}
			while (j < 0) {
			    j++;
			    NumSize--;
			}
			if (prev->data[j] == '[') {
			    /*
			     * The numbered bracket is all on the
			     * previous line, and the anchor content
			     * was wrapped to the last line.  -FM
			     */
			    NumSize++;
			    k = j + NumSize;
			    while (k < (int) prev->size)
				prev->data[j++] = prev->data[k++];
			    prev->size = (unsigned short) j;
			    prev->data[j++] = '\0';
			    while (j < k)
				prev->data[j++] = '\0';
			} else {
			    /*
			     * Shucks!  We didn't find the
			     * numbered bracket.  -FM
			     */
			    a->show_anchor = YES;
			}
		    } else {
			/*
			 * Shucks!  We didn't find the
			 * numbered bracket.  -FM
			 */
			a->show_anchor = YES;
		    }
		} else {
		    /*
		     * Shucks!  We didn't find the
		     * numbered bracket.  -FM
		     */
		    a->show_anchor = YES;
		}
	    }
	} else {
	    if (!number_links_on_left)
		add_link_number(text, a, FALSE);
	    /*
	     * The anchor's content is not restricted to only
	     * white and special characters, so we'll show it
	     * as a link.  -FM
	     */
	    a->show_anchor = YES;
	    if (BlankExtent) {
		CTRACE((tfp,
			"HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
			a->line_num, a->line_pos, a->extent,
			BlankExtent));
	    }
	}
	if (a->show_anchor == NO) {
	    /*
	     * The anchor's content is restricted to white
	     * and special characters, so set its number
	     * and extent to zero, decrement the visible
	     * anchor number counter, and add this anchor
	     * to the hidden links list.  -FM
	     */
	    a->extent = 0;
	    if (text->hiddenlinkflag != HIDDENLINKS_MERGE) {
		a->number = 0;
		text->last_anchor_number--;
		HText_AddHiddenLink(text, a);
	    }
	} else {
	    /*
	     * The anchor's content is not restricted to white
	     * and special characters, so we'll display the
	     * content, but shorten its extent by any trailing
	     * blank lines we've detected.  -FM
	     */
	    a->extent = (short) (a->extent - ((BlankExtent < a->extent)
					      ? BlankExtent
					      : 0));
	}
	if (BlankExtent || a->extent <= 0 || a->number <= 0) {
	    CTRACE((tfp,
		    "->[%d](%d,%d,%d,%d)\n",
		    a->number,
		    a->line_num, a->line_pos, a->extent,
		    BlankExtent));
	}
    } else {
	if (!really)		/* Just report whether it is empty */
	    return FALSE;
	/*
	 * It's a named anchor without an HREF, so it
	 * should be registered but not shown as a
	 * link.  -FM
	 */
	a->show_anchor = NO;
	a->extent = 0;
    }
    return FALSE;
}

void HText_endAnchor(HText *text, int number)
{
    HText_endAnchor0(text, number, 1);
}

/*
    This returns whether the given anchor has blank content. Shamelessly copied
    from HText_endAnchor. The values returned are meaningful only for "normal"
    links - like ones produced by <a href=".">foo</a>, no inputs, etc. - VH
*/
#ifdef MARK_HIDDEN_LINKS
BOOL HText_isAnchorBlank(HText *text, int number)
{
    return HText_endAnchor0(text, number, 0);
}
#endif /* MARK_HIDDEN_LINKS */

void HText_appendText(HText *text, const char *str)
{
    const char *p;

    if (str != NULL &&
	text != NULL &&
	text->halted != 3) {
	for (p = str; *p; p++) {
	    HText_appendCharacter(text, *p);
	}
    }
}

static int remove_special_attr_chars(char *buf)
{
    register char *cp;
    register int soft_newline_count = 0;

    for (cp = buf; *cp != '\0'; cp++) {
	/*
	 * Don't print underline chars.
	 */
	soft_newline_count += (*cp == LY_SOFT_NEWLINE);
	if (!IsSpecialAttrChar(*cp)) {
	    *buf++ = *cp;
	}
    }
    *buf = '\0';
    return soft_newline_count;
}

/*
 *  This function trims blank lines from the end of the document, and
 *  then gets the hightext from the text by finding the char position,
 *  and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 */
void HText_endAppend(HText *text)
{
    HTLine *line_ptr;

    if (!text)
	return;

    CTRACE((tfp, "GridText: Entering HText_endAppend\n"));

    /*
     * Create a blank line at the bottom.
     */
    new_line(text);

    if (text->halted) {
	if (text->stbl)
	    HText_cancelStbl(text);
	/*
	 * If output was stopped because memory was low, and we made
	 * it to the end of the document, reset those flags and hope
	 * things are better now.  - kw
	 */
	LYFakeZap(NO);
	text->halted = 0;
    } else if (text->stbl) {
	/*
	 * Could happen if TABLE end tag was missing.
	 * Alternatively we could cancel in this case.  - kw
	 */
	HText_endStblTABLE(text);
    }

    /*
     * Get the first line.
     */
    if ((line_ptr = FirstHTLine(text)) != 0) {
	/*
	 * Remove the blank lines at the end of document.
	 */
	while (text->last_line->data[0] == '\0' && text->Lines > 2) {
	    HTLine *next_to_the_last_line = text->last_line->prev;

	    CTRACE((tfp, "GridText: Removing bottom blank line: `%s'\n",
		    text->last_line->data));
	    /*
	     * line_ptr points to the first line.
	     */
	    next_to_the_last_line->next = line_ptr;
	    line_ptr->prev = next_to_the_last_line;
	    freeHTLine(text, text->last_line);
	    text->last_line = next_to_the_last_line;
	    text->Lines--;
	    CTRACE((tfp, "GridText: New bottom line: `%s'\n",
		    text->last_line->data));
	}
    }

    /*
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
     */
    HText_trimHightext(text, TRUE, -1);
}

/*
 *  This function gets the hightext from the text by finding the char
 *  position, and brings the anchors in line with the text by adding the text
 *  offset to each of the anchors.
 *
 *  `Forms input' fields cannot be displayed properly without this function
 *  to be invoked (detected in display_partial mode).
 *
 *  If final is set, this is the final fixup; if not set, we don't have
 *  to do everything because there should be another call later.
 *
 *  BEFORE this function has treated a TextAnchor, its line_pos and
 *  extent fields are counting bytes in the HTLine data, including
 *  invisible special attribute chars and counting UTF-8 multibyte
 *  characters as multiple bytes.
 *
 *  AFTER the adjustment, the anchor line_pos (and hightext offset if
 *  applicable) fields indicate x positions in terms of displayed character
 *  cells, and the extent field apparently is unimportant; the anchor text has
 *  been copied to the hightext fields (which should have been NULL up to that
 *  point), with special attribute chars removed.
 *
 *  This needs to be done so that display_page finds the anchors in the
 *  form it expects when it sets the links[] elements.
 */
static void HText_trimHightext(HText *text,
			       int final,
			       int stop_before)
{
    int cur_line, cur_shift;
    TextAnchor *anchor_ptr;
    TextAnchor *prev_a = NULL;
    HTLine *line_ptr;
    HTLine *line_ptr2;
    unsigned char ch;
    char *hilite_str;
    int hilite_len;
    int actual_len;
    int count_line;

    if (!text)
	return;

    if (final) {
	CTRACE((tfp, "GridText: Entering HText_trimHightext (final)\n"));
    } else {
	if (stop_before < 0 || stop_before > text->Lines)
	    stop_before = text->Lines;
	CTRACE((tfp,
		"GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n",
		stop_before, text->Lines));
    }

    /*
     * Get the first line.
     */
    line_ptr = FirstHTLine(text);
    cur_line = 0;

    /*
     * Fix up the anchor structure values and
     * create the hightext strings.  -FM
     */
    for (anchor_ptr = text->first_anchor;
	 anchor_ptr != NULL;
	 prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
	int anchor_col;

      re_parse:
	/*
	 * Find the right line.
	 */
	for (; anchor_ptr->line_num > cur_line;
	     line_ptr = line_ptr->next, cur_line++) {
	    ;			/* null body */
	}

	if (!final) {
	    /*
	     * If this is not the final call, stop when we have reached
	     * the last line, or the very end of preceding line.
	     * The last line is probably still not finished.  - kw
	     */
	    if (cur_line >= stop_before)
		break;
	    if (anchor_ptr->line_num >= text->Lines - 1
		&& anchor_ptr->line_pos >= (int) text->last_line->prev->size)
		break;
	    /*
	     * Also skip this anchor if it looks like HText_endAnchor
	     * is not yet done with it.  - kw
	     */
	    if (!anchor_ptr->extent && anchor_ptr->number &&
		(anchor_ptr->link_type & HYPERTEXT_ANCHOR) &&
		!anchor_ptr->show_anchor &&
		anchor_ptr->number == text->last_anchor_number)
		continue;
	}

	/*
	 * If hightext has already been set, then we must have already
	 * done the trimming & adjusting for this anchor, so avoid
	 * doing it a second time.  - kw
	 */
	if (LYGetHiTextStr(anchor_ptr, 0) != NULL)
	    continue;

	if (anchor_ptr->line_pos > (int) line_ptr->size) {
	    anchor_ptr->line_pos = (short) line_ptr->size;
	}
	if (anchor_ptr->line_pos < 0) {
	    anchor_ptr->line_pos = 0;
	    anchor_ptr->line_num = cur_line;
	}
	CTRACE((tfp,
		"GridText: Anchor found on line:%d col:%d [%05d:%d] ext:%d\n",
		cur_line,
		anchor_ptr->line_pos,
		anchor_ptr->sgml_offset,
		anchor_ptr->number,
		anchor_ptr->extent));

	cur_shift = 0;
	/*
	 * Strip off any spaces or SpecialAttrChars at the beginning,
	 * if they exist, but only on HYPERTEXT_ANCHORS.
	 */
	if (anchor_ptr->link_type & HYPERTEXT_ANCHOR) {
	    ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
	    while (isspace(ch) ||
		   IsSpecialAttrChar(ch)) {
		anchor_ptr->line_pos++;
		anchor_ptr->extent--;
		cur_shift++;
		ch = UCH(line_ptr->data[anchor_ptr->line_pos]);
	    }
	}
	if (anchor_ptr->extent < 0) {
	    anchor_ptr->extent = 0;
	}

	CTRACE((tfp, "anchor text: '%s'\n", line_ptr->data));
	/*
	 * If the link begins with an end of line and we have more lines, then
	 * start the highlighting on the next line.  -FM.
	 *
	 * But if an empty anchor is at the end of line and empty, keep it
	 * where it is, unless the previous anchor in the list (if any) already
	 * starts later.  - kw
	 */
	if ((unsigned) anchor_ptr->line_pos >= strlen(line_ptr->data)) {
	    if (cur_line < text->Lines &&
		(anchor_ptr->extent ||
		 anchor_ptr->line_pos != (int) line_ptr->size ||
		 (prev_a &&	/* How could this happen? */
		  (prev_a->line_num > anchor_ptr->line_num)))) {
		anchor_ptr->line_num++;
		anchor_ptr->line_pos = 0;
		CTRACE((tfp, "found anchor at end of line\n"));
		goto re_parse;
	    } else {
		CTRACE((tfp, "found anchor at end of line, leaving it there\n"));
	    }
	}

	/*
	 * Copy the link name into the data structure.
	 */
	if (anchor_ptr->extent > 0
	    && anchor_ptr->line_pos >= 0) {
	    int size = (int) line_ptr->size - anchor_ptr->line_pos;

	    if (size > anchor_ptr->extent)
		size = anchor_ptr->extent;
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr,
			&line_ptr->data[anchor_ptr->line_pos],
			(unsigned) size);
	} else {
	    LYClearHiText(anchor_ptr);
	    LYSetHiText(anchor_ptr, "", 0);
	}

	/*
	 * If the anchor extends over more than one line, copy that into the
	 * data structure.
	 */
	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	hilite_len = (int) strlen(hilite_str);
	actual_len = anchor_ptr->extent;

	line_ptr2 = line_ptr;
	assert(line_ptr2 != 0);

	count_line = cur_line;
	while (actual_len > hilite_len) {
	    HTLine *old_line_ptr2 = line_ptr2;

	    count_line++;
	    if ((line_ptr2 = line_ptr2->next) == NULL)
		break;

	    if (!final
		&& count_line >= stop_before) {
		LYClearHiText(anchor_ptr);
		break;
	    } else if (old_line_ptr2 == text->last_line) {
		break;
	    }

	    /*
	     * Double check that we have a line pointer, and if so, copy into
	     * highlight text.
	     */
	    if (line_ptr2) {
		char *hi_string = NULL;
		int hi_offset = line_ptr2->offset;

		StrnAllocCopy(hi_string,
			      line_ptr2->data,
			      (size_t) (actual_len - hilite_len));
		actual_len -= (int) strlen(hi_string);
		/*handle LY_SOFT_NEWLINEs -VH */
		hi_offset += remove_special_attr_chars(hi_string);

		if (anchor_ptr->link_type & HYPERTEXT_ANCHOR) {
		    LYTrimTrailing(hi_string);
		}
		if (non_empty(hi_string)) {
		    LYAddHiText(anchor_ptr, hi_string, hi_offset);
		} else if (actual_len > hilite_len) {
		    LYAddHiText(anchor_ptr, "", hi_offset);
		}
		FREE(hi_string);
	    }
	}

	if (!final
	    && count_line >= stop_before) {
	    break;
	}

	hilite_str = LYGetHiTextStr(anchor_ptr, 0);
	remove_special_attr_chars(hilite_str);
	if (anchor_ptr->link_type & HYPERTEXT_ANCHOR) {
	    LYTrimTrailing(hilite_str);
	}

	/*
	 * Save the offset (bytes) of the anchor in the line's data.
	 */
	anchor_col = anchor_ptr->line_pos;

	/*
	 * Subtract any formatting characters from the x position of the link.
	 */
#ifdef WIDEC_CURSES
	if (anchor_ptr->line_pos > 0) {
	    /*
	     * LYstrExtent filters out the formatting characters, so we do not
	     * have to count them here, except for soft newlines.
	     */
	    anchor_ptr->line_pos = (short) LYstrExtent2(line_ptr->data, anchor_col);
	    if (line_ptr->data[0] == LY_SOFT_NEWLINE)
		anchor_ptr->line_pos = (short) (anchor_ptr->line_pos + 1);
	}
#else /* 8-bit curses, etc.  */
	if (anchor_ptr->line_pos > 0) {
	    register int offset = 0, i = 0;
	    int have_soft_newline_in_1st_line = 0;

	    for (; i < anchor_col; i++) {
		if (IS_UTF_EXTRA(line_ptr->data[i]) ||
		    IsSpecialAttrChar(line_ptr->data[i])) {
		    offset++;
		    have_soft_newline_in_1st_line += (line_ptr->data[i] == LY_SOFT_NEWLINE);
		}
	    }
	    anchor_ptr->line_pos = (short) (anchor_ptr->line_pos - offset);
	    /*handle LY_SOFT_NEWLINEs -VH */
	    anchor_ptr->line_pos = (short) (anchor_ptr->line_pos + have_soft_newline_in_1st_line);
	}
#endif /* WIDEC_CURSES */

	/*
	 * Set the line number.
	 */
	anchor_ptr->line_pos = (short) (anchor_ptr->line_pos + line_ptr->offset);
	anchor_ptr->line_num = cur_line;

	CTRACE((tfp, "GridText:     add link on line %d col %d [%d] %s\n",
		cur_line, anchor_ptr->line_pos,
		anchor_ptr->number, "in HText_trimHightext"));
    }
}

/*	Return the anchor associated with this node
*/
HTParentAnchor *HText_nodeAnchor(HText *text)
{
    return text->node_anchor;
}

/*				GridText specials
 *				=================
 */

/*
 * HText_childNextNumber() returns the anchor with index [number],
 * using a pointer from the previous number (=optimization) or NULL.
 */
HTChildAnchor *HText_childNextNumber(int number, void **prev)
{
    /* Sorry, TextAnchor is not declared outside this file, use a cast. */
    TextAnchor *a = (TextAnchor *) *prev;

    if (!HTMainText || number <= 0)
	return (HTChildAnchor *) 0;	/* Fail */
    if (number == 1 || !a)
	a = HTMainText->first_anchor;

    /* a strange thing:  positive a->number's are sorted,
     * and between them several a->number's may be 0 -- skip them
     */
    for (; a && a->number != number; a = a->next) ;

    if (!a)
	return (HTChildAnchor *) 0;	/* Fail */
    *prev = (void *) a;
    return a->anchor;
}

/*
 * For the -unique-urls option, find the anchor-number of the first occurrence
 * of a given address.
 */
int HText_findAnchorNumber(void *avoid)
{
    TextAnchor *a = (TextAnchor *) avoid;

    if (a->number > 0 && a->show_number == 0)
	compute_show_number(a);

    return a->show_number;
}

static const char *inputFieldDesc(FormInfo * input)
{
    const char *result = 0;

    switch (input->type) {
    case F_TEXT_TYPE:
	result = gettext("text entry field");
	break;
    case F_PASSWORD_TYPE:
	result = gettext("password entry field");
	break;
    case F_CHECKBOX_TYPE:
	result = gettext("checkbox");
	break;
    case F_RADIO_TYPE:
	result = gettext("radio button");
	break;
    case F_SUBMIT_TYPE:
	result = gettext("submit button");
	break;
    case F_RESET_TYPE:
	result = gettext("reset button");
	break;
    case F_BUTTON_TYPE:
	result = gettext("script button");
	break;
    case F_OPTION_LIST_TYPE:
	result = gettext("popup menu");
	break;
    case F_HIDDEN_TYPE:
	result = gettext("hidden form field");
	break;
    case F_TEXTAREA_TYPE:
	result = gettext("text entry area");
	break;
    case F_RANGE_TYPE:
	result = gettext("range entry field");
	break;
    case F_FILE_TYPE:
	result = gettext("file entry field");
	break;
    case F_TEXT_SUBMIT_TYPE:
	result = gettext("text-submit field");
	break;
    case F_IMAGE_SUBMIT_TYPE:
	result = gettext("image-submit button");
	break;
    case F_KEYGEN_TYPE:
	result = gettext("keygen field");
	break;
    default:
	result = gettext("unknown form field");
	break;
    }
    return result;
}

/*
 * HText_FormDescNumber() returns a description of the form field
 * with index N.  The index corresponds to the [number] we print
 * for the field.  -FM & LE
 */
void HText_FormDescNumber(int number,
			  const char **desc)
{
    TextAnchor *a;

    if (!desc)
	return;

    if (!(HTMainText && HTMainText->first_anchor) || number <= 0) {
	*desc = gettext("unknown field or link");
	return;
    }

    for (a = HTMainText->first_anchor; a; a = a->next) {
	if (a->number == number) {
	    if (!(a->input_field && a->input_field->type)) {
		*desc = gettext("unknown field or link");
		return;
	    }
	    break;
	}
    }

    if (a != NULL)
	*desc = inputFieldDesc(a->input_field);
}

/* HTGetRelLinkNum returns the anchor number to which follow_link_number()
 * is to jump (input was 123+ or 123- or 123+g or 123-g or 123 or 123g)
 * num is the number specified
 * rel is 0 or '+' or '-'
 * cur is the current link
 */
int HTGetRelLinkNum(int num,
		    int rel,
		    int cur)
{
    TextAnchor *a, *l = 0;
    int scrtop = HText_getTopOfScreen();	/*XXX +1? */
    int curline = links[cur].anchor_line_num;
    int curpos = links[cur].lx;
    int on_screen = (curline >= scrtop && curline < (scrtop + display_lines));

    /* curanchor may or may not be the "current link", depending whether it's
     * on the current screen
     */
    int curanchor = links[cur].anchor_number;

    CTRACE((tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	    num, rel, cur, (void *) HTMainText));
    CTRACE((tfp,
	    "  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
	    scrtop, curline, curanchor, display_lines,
	    on_screen ? "on_screen" : "0"));
    if (!HTMainText)
	return 0;
    if (rel == 0)
	return num;

    /* if cur numbered link is on current page, use it */
    if (on_screen && curanchor) {
	CTRACE((tfp, "curanchor=%d at line %d on screen\n", curanchor, curline));
	if (rel == '+')
	    return curanchor + num;
	else if (rel == '-')
	    return curanchor - num;
	else
	    return num;		/* shouldn't happen */
    }

    /* no current link on screen, or current link is not numbered
     * -- find previous closest numbered link
     */
    for (a = HTMainText->first_anchor; a; a = a->next) {
	CTRACE((tfp, "  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
	if (a->line_num >= scrtop)
	    break;
	if (a->number == 0)
	    continue;
	l = a;
	curanchor = l->number;
    }
    CTRACE((tfp, "  a=%p, l=%p, curanchor=%d\n", (void *) a, (void *) l, curanchor));
    if (on_screen) {		/* on screen but not a numbered link */
	for (; a; a = a->next) {
	    if (a->number) {
		l = a;
		curanchor = l->number;
	    }
	    if (curline == a->line_num && curpos == a->line_pos)
		break;
	}
    }
    if (rel == '+') {
	return curanchor + num;
    } else if (rel == '-') {
	if (l)
	    return curanchor + 1 - num;
	else {
	    for (; a && a->number == 0; a = a->next) ;
	    return a ? a->number - num : 0;
	}
    } else
	return num;		/* shouldn't happen */
}

/*
 * HTGetLinkInfo returns some link info based on the number.
 *
 * If want_go is not 0, caller requests to know a line number for
 * the link indicated by number.  It will be returned in *go_line, and
 * *linknum will be set to an index into the links[] array, to use after
 * the line in *go_line has been made the new top screen line.
 * *hightext and *lname are unchanged.  - KW
 *
 * If want_go is 0 and the number doesn't represent an input field, info
 * on the link indicated by number is deposited in *hightext and *lname.
 */
int HTGetLinkInfo(int number,
		  int want_go,
		  int *go_line,
		  int *linknum,
		  char **hightext,
		  char **lname)
{
    TextAnchor *a;
    HTAnchor *link_dest;

    HTAnchor *link_dest_intl = NULL;
    int anchors_this_line = 0, anchors_this_screen = 0;
    int prev_anchor_line = -1, prev_prev_anchor_line = -1;

    if (!HTMainText)
	return (NO);

    for (a = HTMainText->first_anchor; a; a = a->next) {
	/*
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
	 */
	if ((a->show_anchor) &&
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
	    if (a->line_num == prev_anchor_line) {
		anchors_this_line++;
	    } else {
		/*
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
		 */
		anchors_this_line = 1;
		prev_prev_anchor_line = prev_anchor_line;
		prev_anchor_line = a->line_num;
	    }
	    if (a->line_num >= HTMainText->top_of_screen) {
		/*
		 * Count all anchors starting with the top line of the
		 * currently displayed screen.  Just keep on counting
		 * beyond this screen's bottom line - we'll know whether
		 * a found anchor is below the current screen by a check
		 * against nlinks later.  - KW
		 */
		anchors_this_screen++;
	    }
	}

	if (a->number == number) {
	    /*
	     * We found it.  Now process it, depending
	     * on what kind of info is requested.  - KW
	     */
	    if (want_go || a->link_type == INPUT_ANCHOR) {
		if (a->show_anchor == NO) {
		    /*
		     * The number requested has been assigned to an anchor
		     * without any selectable text, so we cannot position
		     * on it.  The code for suppressing such anchors in
		     * HText_endAnchor() may not have applied, or it may
		     * have failed.  Return a failure indication so that
		     * the user will notice that something is wrong,
		     * instead of positioning on some other anchor which
		     * might result in inadvertent activation.  - KW
		     */
		    return (NO);
		}
		if (anchors_this_screen > 0 &&
		    anchors_this_screen <= nlinks &&
		    a->line_num >= HTMainText->top_of_screen &&
		    a->line_num < HTMainText->top_of_screen + (display_lines)) {
		    /*
		     * If the requested anchor is within the current screen,
		     * just set *go_line so that the screen window won't move
		     * (keep it as it is), and set *linknum to the index of
		     * this link in the current links[] array.  - KW
		     */
		    *go_line = HTMainText->top_of_screen;
		    if (linknum)
			*linknum = anchors_this_screen - 1;
		} else {
		    /*
		     * if the requested anchor is not within the currently
		     * displayed screen, set *go_line such that the top line
		     * will be either
		     *  (1) the line immediately below the previous
		     *      anchor, or
		     *  (2) about one third of a screenful above the line
		     *      with the target, or
		     *  (3) the first line of the document -
		     * whichever comes last.  In all cases the line with our
		     * target will end up being the first line with any links
		     * on the new screen, so that we can use the
		     * anchors_this_line counter to point to the anchor in
		     * the new links[] array.  - kw
		     */
		    int max_offset = SEARCH_GOAL_LINE - 1;

		    if (max_offset < 0)
			max_offset = 0;
		    else if (max_offset >= display_lines)
			max_offset = display_lines - 1;
		    *go_line = prev_anchor_line - max_offset;
		    if (*go_line <= prev_prev_anchor_line)
			*go_line = prev_prev_anchor_line + 1;
		    if (*go_line < 0)
			*go_line = 0;
		    if (linknum)
			*linknum = anchors_this_line - 1;
		}
		return (LINK_LINE_FOUND);
	    } else {
		*hightext = LYGetHiTextStr(a, 0);
		link_dest = HTAnchor_followLink(a->anchor);
		{
		    char *cp_freeme = NULL;

		    if (traversal) {
			cp_freeme = stub_HTAnchor_address(link_dest);
		    } else if (track_internal_links) {
			if (a->link_type == INTERNAL_LINK_ANCHOR) {
			    link_dest_intl =
				HTAnchor_followTypedLink(a->anchor, HTInternalLink);
			    if (link_dest_intl && link_dest_intl != link_dest) {

				CTRACE((tfp,
					"HTGetLinkInfo: unexpected typed link to %s!\n",
					link_dest_intl->parent->address));
				link_dest_intl = NULL;
			    }
			}
			if (link_dest_intl) {
			    char *cp2 = HTAnchor_address(link_dest_intl);

			    FREE(*lname);
			    *lname = cp2;
			    return (WWW_INTERN_LINK_TYPE);
			} else {
			    cp_freeme = HTAnchor_address(link_dest);
			}
		    } else {
			cp_freeme = HTAnchor_address(link_dest);
		    }
		    StrAllocCopy(*lname, cp_freeme);
		    FREE(cp_freeme);
		}
		return (WWW_LINK_TYPE);
	    }
	}
    }
    return (NO);
}

static BOOLEAN same_anchor_or_field(int numberA,
				    FormInfo * formA,
				    int numberB,
				    FormInfo * formB,
				    int ta_same)
{
    if (numberA > 0 || numberB > 0) {
	if (numberA == numberB)
	    return (YES);
	else if (!ta_same)
	    return (NO);
    }
    if (formA || formB) {
	if (formA == formB) {
	    return (YES);
	} else if (!ta_same) {
	    return (NO);
	} else if (!(formA && formB)) {
	    return (NO);
	}
    } else {
	return (NO);
    }
    if (formA->type != formB->type ||
	formA->type != F_TEXTAREA_TYPE ||
	formB->type != F_TEXTAREA_TYPE) {
	return (NO);
    }
    if (formA->number != formB->number)
	return (NO);
    if (!formA->name || !formB->name)
	return (YES);
    return (BOOL) (strcmp(formA->name, formB->name) == 0);
}

#define same_anchor_as_link(i,a,ta_same) (BOOL) (i >= 0 && a && \
		same_anchor_or_field(links[i].anchor_number,\
		(links[i].type == WWW_FORM_LINK_TYPE) ? links[i].l_form : NULL,\
		a->number,\
		(a->link_type == INPUT_ANCHOR) ? a->input_field : NULL,\
		ta_same))
#define same_anchors(a1,a2,ta_same) (BOOL) (a1 && a2 && \
		same_anchor_or_field(a1->number,\
		(a1->link_type == INPUT_ANCHOR) ? a1->input_field : NULL,\
		a2->number,\
		(a2->link_type == INPUT_ANCHOR) ? a2->input_field : NULL,\
		ta_same))

/*
 * Are there more textarea lines belonging to the same textarea before
 * (direction < 0) or after (direction > 0) the current one?
 * On entry, curlink must be the index in links[] of a textarea field.  - kw
 */
BOOL HText_TAHasMoreLines(int curlink,
			  int direction)
{
    TextAnchor *a;
    TextAnchor *prev_a = NULL;

    if (!HTMainText)
	return (NO);
    if (direction < 0) {
	for (a = HTMainText->first_anchor; a; prev_a = a, a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, prev_a, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    } else {
	for (a = HTMainText->first_anchor; a; a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		links[curlink].l_form == a->input_field) {
		return same_anchors(a, a->next, TRUE);
	    }
	    if (links[curlink].anchor_number &&
		a->number >= links[curlink].anchor_number)
		break;
	}
	return NO;
    }
}

/*
 * HTGetLinkOrFieldStart - moving to previous or next link or form field.
 *
 * On input,
 *	curlink: current link, as index in links[] array (-1 if none)
 *	direction: whether to move up or down (or stay where we are)
 *	ta_skip: if FALSE, input fields belonging to the same textarea are
 *		 are treated as different fields, as usual;
 *		 if TRUE, fields of the same textarea are treated as a
 *		 group for skipping.
 * The caller wants information for positioning on the new link to be
 * deposited in *go_line and (if linknum is not NULL) *linknum.
 *
 * On failure (no more links in the requested direction) returns NO
 * and doesn't change *go_line or *linknum.  Otherwise, LINK_DO_ARROWUP
 * may be returned, and *go_line and *linknum not changed, to indicate that
 * the caller should use a normal PREV_LINK or PREV_PAGE mechanism.
 * Otherwise:
 * The number (0-based counting) for the new top screen line will be returned
 * in *go_line, and *linknum will be set to an index into the links[] array,
 * to use after the line in *go_line has been made the new top screen
 * line.  - kw
 */
int HTGetLinkOrFieldStart(int curlink,
			  int *go_line,
			  int *linknum,
			  int direction,
			  int ta_skip)
{
    TextAnchor *a;
    int anchors_this_line = 0;
    int prev_anchor_line = -1, prev_prev_anchor_line = -1;

    struct agroup {
	TextAnchor *anc;
	int prev_anchor_line;
	int anchors_this_line;
	int anchors_this_group;
    } previous, current;
    struct agroup *group_to_go = NULL;

    if (!HTMainText)
	return (NO);

    previous.anc = current.anc = NULL;
    previous.prev_anchor_line = current.prev_anchor_line = -1;
    previous.anchors_this_line = current.anchors_this_line = 0;
    previous.anchors_this_group = current.anchors_this_group = 0;

    for (a = HTMainText->first_anchor; a; a = a->next) {
	/*
	 * Count anchors, first on current line if there is more
	 * than one.  We have to count all links, including form
	 * field anchors and others with a->number == 0, because
	 * they are or will be included in the links[] array.
	 * The exceptions are hidden form fields and anchors with
	 * show_anchor not set, because they won't appear in links[]
	 * and don't count towards nlinks.  - KW
	 */
	if ((a->show_anchor) &&
	    !(a->link_type == INPUT_ANCHOR
	      && a->input_field->type == F_HIDDEN_TYPE)) {
	    if (a->line_num == prev_anchor_line) {
		anchors_this_line++;
	    } else {
		/*
		 * This anchor is on a different line than the previous one.
		 * Remember which was the line number of the previous anchor,
		 * for use in screen positioning later.  - KW
		 */
		anchors_this_line = 1;
		prev_prev_anchor_line = prev_anchor_line;
		prev_anchor_line = a->line_num;
	    }

	    if (!same_anchors(current.anc, a, ta_skip)) {
		previous.anc = current.anc;
		previous.prev_anchor_line = current.prev_anchor_line;
		previous.anchors_this_line = current.anchors_this_line;
		previous.anchors_this_group = current.anchors_this_group;
		current.anc = a;
		current.prev_anchor_line = prev_prev_anchor_line;
		current.anchors_this_line = anchors_this_line;
		current.anchors_this_group = 1;
	    } else {
		current.anchors_this_group++;
	    }
	    if (curlink >= 0) {
		if (same_anchor_as_link(curlink, a, ta_skip)) {
		    if (direction == -1) {
			group_to_go = &previous;
			break;
		    } else if (direction == 0) {
			group_to_go = &current;
			break;
		    }
		} else if (direction > 0 &&
			   same_anchor_as_link(curlink, previous.anc, ta_skip)) {
		    group_to_go = &current;
		    break;
		}
	    } else {
		if (a->line_num >= HTMainText->top_of_screen) {
		    if (direction < 0) {
			group_to_go = &previous;
			break;
		    } else if (direction == 0) {
			if (previous.anc) {
			    group_to_go = &previous;
			    break;
			} else {
			    group_to_go = &current;
			    break;
			}
		    } else {
			group_to_go = &current;
			break;
		    }
		}
	    }
	}
    }
    if (!group_to_go && curlink < 0 && direction <= 0) {
	group_to_go = &current;
    }
    if (group_to_go) {
	a = group_to_go->anc;
	if (a) {
	    int max_offset;

	    /*
	     * We know where to go; most of the stuff below is just
	     * tweaks to try to position the new screen in a specific
	     * way.
	     *
	     * In some cases going to a previous link can be done
	     * via the normal LYK_PREV_LINK action, which may give
	     * better positioning of the new screen.  - kw
	     */
	    if (a->line_num < HTMainText->top_of_screen &&
		a->line_num >= HTMainText->top_of_screen - (display_lines)) {
		if ((curlink < 0 &&
		     group_to_go->anchors_this_group == 1) ||
		    (direction < 0 &&
		     group_to_go != &current &&
		     current.anc &&
		     current.anc->line_num >= HTMainText->top_of_screen &&
		     group_to_go->anchors_this_group == 1) ||
		    (a->next &&
		     a->next->line_num >= HTMainText->top_of_screen)) {
		    return (LINK_DO_ARROWUP);
		}
	    }
	    /*
	     * The fundamental limitation of the current anchors_this_line
	     * counter method is that we only can set *linknum to the right
	     * index into the future links[] array if the line with our link
	     * ends up being the first line with any links (that count) on
	     * the new screen.  Subject to that restriction we still have
	     * some vertical liberty (sometimes), and try to make the best
	     * of it.  It may be a question of taste though.  - kw
	     */
	    if (a->line_num <= (display_lines)) {
		max_offset = 0;
	    } else if (a->line_num < HTMainText->top_of_screen) {
		int screensback =
		(HTMainText->top_of_screen - a->line_num + (display_lines) - 1)
		/ (display_lines);

		max_offset = a->line_num - (HTMainText->top_of_screen -
					    screensback * (display_lines));
	    } else if (HTMainText->Lines - a->line_num <= (display_lines)) {
		max_offset = a->line_num - (HTMainText->Lines + 1
					    - (display_lines));
	    } else if (a->line_num >=
		       HTMainText->top_of_screen + (display_lines)) {
		int screensahead =
		(a->line_num - HTMainText->top_of_screen) / (display_lines);

		max_offset = a->line_num - HTMainText->top_of_screen -
		    screensahead * (display_lines);
	    } else {
		max_offset = SEARCH_GOAL_LINE - 1;
	    }

	    /* Stuff below should remain unchanged if line positioning
	       is tweaked. - kw */
	    if (max_offset < 0)
		max_offset = 0;
	    else if (max_offset >= display_lines)
		max_offset = display_lines - 1;
	    *go_line = a->line_num - max_offset;
	    if (*go_line <= group_to_go->prev_anchor_line)
		*go_line = group_to_go->prev_anchor_line + 1;

	    if (*go_line < 0)
		*go_line = 0;
	    if (linknum)
		*linknum = group_to_go->anchors_this_line - 1;
	    return (LINK_LINE_FOUND);
	}
    }
    return (NO);
}

/*
 * This function finds the line indicated by line_num in the
 * HText structure indicated by text, and searches that line
 * for the first hit with the string indicated by target.  If
 * there is no hit, FALSE is returned.  If there is a hit, then
 * a copy of the line starting at that first hit is loaded into
 * *data with all IsSpecial characters stripped, its offset and
 * the printable target length (without IsSpecial, or extra CJK
 * or utf8 characters) are loaded into *offset and *tLen, and
 * TRUE is returned.  -FM
 */
BOOL HText_getFirstTargetInLine(HText *text, int line_num,
				int utf_flag,
				int *offset,
				int *tLen,
				char **data,
				const char *target)
{
    HTLine *line;
    char *LineData;
    int LineOffset, HitOffset, LenNeeded, i;
    const char *cp;

    /*
     * Make sure we have an HText structure, that line_num is
     * in its range, and that we have a target string.  -FM
     */
    if (!(text &&
	  line_num >= 0 &&
	  line_num <= text->Lines &&
	  non_empty(target))) {
	return (FALSE);
    }

    /*
     * Find the line and set up its data and offset -FM
     */
    for (i = 0, line = FirstHTLine(text);
	 i < line_num && (line != text->last_line);
	 i++, line = line->next) {
	if (line->next == NULL) {
	    return (FALSE);
	}
    }
    if (!(line && line->data[0]))
	return (FALSE);
    LineData = (char *) line->data;
    LineOffset = (int) line->offset;

    /*
     * If the target is on the line, load the offset of
     * its first character and the subsequent line data,
     * strip any special characters from the loaded line
     * data, and return TRUE.  -FM
     */
    if (((cp = LYno_attr_mb_strstr(LineData,
				   target,
				   utf_flag, YES,
				   &HitOffset,
				   &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) <= DISPLAY_COLS) {
	/*
	 * We had a hit so load the results,
	 * remove IsSpecial characters from
	 * the allocated data string, and
	 * return TRUE.  -FM
	 */
	*offset = (LineOffset + HitOffset);
	*tLen = (LenNeeded - HitOffset);
	StrAllocCopy(*data, cp);
	remove_special_attr_chars(*data);
	return (TRUE);
    }

    /*
     * The line does not contain the target.  -FM
     */
    return (FALSE);
}

/*
 * HText_getNumOfLines returns the number of lines in the
 * current document.
 */
int HText_getNumOfLines(void)
{
    return (HTMainText ? HTMainText->Lines : 0);
}

/*
 * HText_getNumOfBytes returns the size of the document, as rendered.  This
 * may be different from the original filesize.
 */
int HText_getNumOfBytes(void)
{
    int result = -1;
    HTLine *line = NULL;

    if (HTMainText != 0) {
	for (line = FirstHTLine(HTMainText);
	     line != HTMainText->last_line;
	     line = line->next) {
	    result += 1 + (int) strlen(line->data);
	}
    }
    return result;
}

/*
 * HText_getTitle returns the title of the
 * current document.
 */
const char *HText_getTitle(void)
{
    return (HTMainText ?
	    HTAnchor_title(HTMainText->node_anchor) : 0);
}

#ifdef USE_COLOR_STYLE
const char *HText_getStyle(void)
{
    return (HTMainText ?
	    HTAnchor_style(HTMainText->node_anchor) : 0);
}
#endif

/*
 * HText_getSugFname returns the suggested filename of the current
 * document (normally derived from a Content-Disposition header with
 * attachment; filename=name.suffix).  -FM
 */
const char *HText_getSugFname(void)
{
    return (HTMainText ?
	    HTAnchor_SugFname(HTMainText->node_anchor) : 0);
}

/*
 * HTCheckFnameForCompression receives the address of an allocated
 * string containing a filename, and an anchor pointer, and expands
 * or truncates the string's suffix if appropriate, based on whether
 * the anchor indicates that the file is compressed.  We assume
 * that the file was not uncompressed (as when downloading), and
 * believe the headers about whether it's compressed or not.  -FM
 *
 * Added third arg - if strip_ok is FALSE, we don't trust the anchor
 * info enough to remove a compression suffix if the anchor object
 * does not indicate compression.  - kw
 */
void HTCheckFnameForCompression(char **fname,
				HTParentAnchor *anchor,
				int strip_ok)
{
    char *fn = *fname;
    char *dot = NULL;
    char *cp = NULL;
    const char *suffix = "";
    CompressFileType method;
    CompressFileType second;

    /*
     * Make sure we have a string and anchor.  -FM
     */
    if (!(fn && anchor))
	return;

    /*
     * Make sure we have a file, not directory, name.  -FM
     */
    if (*(fn = LYPathLeaf(fn)) == '\0')
	return;

    method = HTContentToCompressType(anchor);

    /*
     * If no Content-Encoding has been detected via the anchor
     * pointer, but strip_ok is not set, there is nothing left
     * to do.  - kw
     */
    if ((method == cftNone) && !strip_ok)
	return;

    /*
     * Treat .tgz specially
     */
    if ((dot = strrchr(fn, '.')) != NULL
	&& !strcasecomp(dot, ".tgz")) {
	if (method == cftNone) {
	    strcpy(dot, ".tar");
	}
	return;
    }

    /*
     * Seek the last dot, and check whether
     * we have a gzip or compress suffix.  -FM
     */
    if ((dot = strrchr(fn, '.')) != NULL) {
	int rootlen = 0;

	if (HTCompressFileType(fn, ".", &rootlen) != cftNone) {
	    if (method == cftNone) {
		/*
		 * It has a suffix which signifies a gzipped
		 * or compressed file for us, but the anchor
		 * claims otherwise, so tweak the suffix.  -FM
		 */
		*dot = '\0';
	    }
	    return;
	}
	if ((second = HTCompressFileType(fn, "-_", &rootlen)) != cftNone) {
	    cp = fn + rootlen;
	    if (method == cftNone) {
		/*
		 * It has a tail which signifies a gzipped
		 * file for us, but the anchor claims otherwise,
		 * so tweak the suffix.  -FM
		 */
		if (cp == dot + 1)
		    cp--;
		*cp = '\0';
	    } else {
		/*
		 * The anchor claims it's gzipped, and we
		 * believe it, so force this tail to the
		 * conventional suffix.  -FM
		 */
#ifdef VMS
		*cp = '-';
#else
		*cp = '.';
#endif /* VMS */
		if (second == cftCompress)
		    LYUpperCase(cp);
		else
		    LYLowerCase(cp);
	    }
	    return;
	}
    }

    suffix = HTCompressTypeToSuffix(method);

    /*
     * Add the appropriate suffix.  -FM
     */
    if (*suffix) {
	if (!dot) {
	    StrAllocCat(*fname, suffix);
	} else if (*++dot == '\0') {
	    StrAllocCat(*fname, suffix + 1);
	} else {
	    StrAllocCat(*fname, suffix);
#ifdef VMS
	    (*fname)[strlen(*fname) - strlen(suffix)] = '-';
#endif /* !VMS */
	}
    }
}

/*
 * HText_getLastModified returns the Last-Modified header
 * if available, for the current document.  -FM
 */
const char *HText_getLastModified(void)
{
    return (HTMainText ?
	    HTAnchor_last_modified(HTMainText->node_anchor) : 0);
}

/*
 * HText_getDate returns the Date header
 * if available, for the current document.  -FM
 */
const char *HText_getDate(void)
{
    return (HTMainText ?
	    HTAnchor_date(HTMainText->node_anchor) : 0);
}

/*
 * HText_getServer returns the Server header
 * if available, for the current document.  -FM
 */
const char *HText_getServer(void)
{
    return (HTMainText ?
	    HTAnchor_server(HTMainText->node_anchor) : 0);
}

#ifdef EXP_HTTP_HEADERS
/*
 * Returns the full text of HTTP headers, if available, for the current
 * document.
 */
const char *HText_getHttpHeaders(void)
{
    return (HTMainText ?
	    HTAnchor_http_headers(HTMainText->node_anchor) : 0);
}
#endif

/*
 * HText_pageDisplay displays a screen of text
 * starting from the line 'line_num'-1.
 * This is the primary call for lynx.
 */
void HText_pageDisplay(int line_num,
		       char *target)
{
#ifdef DISP_PARTIAL
    if (debug_display_partial || (LYTraceLogFP != NULL)) {
	CTRACE((tfp, "GridText: HText_pageDisplay at line %d started\n", line_num));
    }

    if (display_partial) {
	int stop_before = -1;

	/*
	 * Garbage is reported from forms input fields in incremental mode.
	 * So we start HText_trimHightext() to forget this side effect.
	 * This function was split-out from HText_endAppend().
	 * It may not be the best solution but it works.  - LP
	 *
	 * (FALSE = indicate that we are in partial mode)
	 * Multiple calls of HText_trimHightext works without problem now.
	 */
	if (HTMainText && HTMainText->stbl)
	    stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
	HText_trimHightext(HTMainText, FALSE, stop_before);
    }
#endif
    display_page(HTMainText, line_num - 1, target);

#ifdef DISP_PARTIAL
    if (display_partial && debug_display_partial)
	LYSleepMsg();
#endif

    is_www_index = HTAnchor_isIndex(HTMainAnchor);

#ifdef DISP_PARTIAL
    if (debug_display_partial || (LYTraceLogFP != NULL)) {
	CTRACE((tfp, "GridText: HText_pageDisplay finished\n"));
    }
#endif
}

/*
 * Return YES if we have a whereis search target on the displayed
 * page.  - kw
 */
BOOL HText_pageHasPrevTarget(void)
{
    if (!HTMainText)
	return NO;
    else
	return HTMainText->page_has_target;
}

/*
 * Find the number of the closest anchor to the given document offset.  Used
 * in reparsing, this will usually find an exact match, as a link shifts around
 * on the display.  It will not find a match when (for example) the source view
 * shows images that are not links in the html.
 */
int HText_closestAnchor(HText *text, int offset)
{
    int result = -1;
    int absdiff = 0;
    int newdiff;
    TextAnchor *Anchor_ptr = NULL;
    TextAnchor *closest = NULL;

    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL;
	 Anchor_ptr = Anchor_ptr->next) {
	if (Anchor_ptr->sgml_offset == offset) {
	    result = Anchor_ptr->number;
	    break;
	} else {
	    newdiff = abs(Anchor_ptr->sgml_offset - offset);
	    if (absdiff == 0 || absdiff > newdiff) {
		absdiff = newdiff;
		closest = Anchor_ptr;
	    }
	}
    }
    if (result < 0 && closest != 0) {
	result = closest->number;
    }

    return result;
}

/*
 * Find the offset for the given anchor, e.g., the inverse of
 * HText_closestAnchor().
 */
int HText_locateAnchor(HText *text, int anchor_number)
{
    int result = -1;
    TextAnchor *Anchor_ptr = NULL;

    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL;
	 Anchor_ptr = Anchor_ptr->next) {
	if (Anchor_ptr->number == anchor_number) {
	    result = Anchor_ptr->sgml_offset;
	    break;
	}
    }

    return result;
}

/*
 * This is supposed to give the same result as the inline checks in
 * display_page(), so we can decide which anchors will be visible.
 */
static BOOL anchor_is_numbered(TextAnchor *Anchor_ptr)
{
    BOOL result = FALSE;

    if (Anchor_ptr->show_anchor
	&& (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
	result = TRUE;
    } else if (Anchor_ptr->link_type == INPUT_ANCHOR
	       && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
	result = TRUE;
    }
    return result;
}

/*
 * Return the absolute line number (counting from the beginning of the
 * document) for the given absolute anchor number.  Normally line numbers are
 * computed within the screen, and for that we use the links[] array.  A few
 * uses require the absolute anchor number.  For example, reparsing a document,
 * e.g., switching between normal and source views will alter the line numbers
 * of each link, and may require adjusting the top line number used for the
 * display, before we recompute the links[] array.
 */
int HText_getAbsLineNumber(HText *text,
			   int anchor_number)
{
    int result = -1;

    if (anchor_number >= 0 && text != 0) {
	TextAnchor *Anchor_ptr = NULL;

	for (Anchor_ptr = text->first_anchor;
	     Anchor_ptr != NULL;
	     Anchor_ptr = Anchor_ptr->next) {
	    if (anchor_is_numbered(Anchor_ptr)
		&& Anchor_ptr->number == anchor_number) {
		result = Anchor_ptr->line_num;
		break;
	    }
	}
    }
    return result;
}

/*
 * Compute the link-number in a page, given the top line number of the page and
 * the absolute anchor number.
 */
int HText_anchorRelativeTo(HText *text, int top_lineno, int anchor_number)
{
    int result = 0;
    int from_top = 0;
    TextAnchor *Anchor_ptr = NULL;

    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL;
	 Anchor_ptr = Anchor_ptr->next) {
	if (Anchor_ptr->number == anchor_number) {
	    result = from_top;
	    break;
	}
	if (!anchor_is_numbered(Anchor_ptr))
	    continue;
	if (Anchor_ptr->line_num >= top_lineno) {
	    ++from_top;
	}
    }
    return result;
}

/*
 * HText_LinksInLines returns the number of links in the
 * 'Lines' number of lines beginning with 'line_num'-1.  -FM
 */
int HText_LinksInLines(HText *text,
		       int line_num,
		       int Lines)
{
    int total = 0;
    int start = (line_num - 1);
    int end = (start + Lines);
    TextAnchor *Anchor_ptr = NULL;

    if (!text)
	return total;

    for (Anchor_ptr = text->first_anchor;
	 Anchor_ptr != NULL && Anchor_ptr->line_num <= end;
	 Anchor_ptr = Anchor_ptr->next) {
	if (Anchor_ptr->line_num >= start &&
	    Anchor_ptr->line_num < end &&
	    Anchor_ptr->show_anchor &&
	    !(Anchor_ptr->link_type == INPUT_ANCHOR
	      && Anchor_ptr->input_field->type == F_HIDDEN_TYPE))
	    ++total;
    }

    return total;
}

void HText_setStale(HText *text)
{
    text->stale = YES;
}

void HText_refresh(HText *text)
{
    if (text->stale)
	display_page(text, text->top_of_screen, "");
}

int HText_sourceAnchors(HText *text)
{
    return (text ? text->last_anchor_number : -1);
}

BOOL HText_canScrollUp(HText *text)
{
    return (BOOL) (text->top_of_screen != 0);
}

/*
 * Check if there is more info below this page.
 */
BOOL HText_canScrollDown(void)
{
    HText *text = HTMainText;

    return (BOOL) ((text != 0)
		   && ((text->top_of_screen + display_lines) <= text->Lines));
}

/*		Scroll actions
*/
void HText_scrollTop(HText *text)
{
    display_page(text, 0, "");
}

void HText_scrollDown(HText *text)
{
    display_page(text, text->top_of_screen + display_lines, "");
}

void HText_scrollUp(HText *text)
{
    display_page(text, text->top_of_screen - display_lines, "");
}

void HText_scrollBottom(HText *text)
{
    display_page(text, text->Lines - display_lines, "");
}

/*		Browsing functions
 *		==================
 */

/* Bring to front and highlight it
*/
BOOL HText_select(HText *text)
{
    if (text != HTMainText) {
	/*
	 * Reset flag for whereis search string - cannot be true here
	 * since text is not our HTMainText.  - kw
	 */
	if (text)
	    text->page_has_target = NO;

#ifdef DISP_PARTIAL
	/* Reset these for the previous and current text. - kw */
	ResetPartialLinenos(text);
	ResetPartialLinenos(HTMainText);
#endif /* DISP_PARTIAL */

#ifdef CAN_SWITCH_DISPLAY_CHARSET
	/* text->UCLYhndl is not reset by META, so use a more circumvent way */
	if (text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	    != current_char_set)
	    Switch_Display_Charset(text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl, SWITCH_DISPLAY_CHARSET_MAYBE);
#endif
	assert(text != NULL);
	if (HTMainText) {
	    if (HText_hasUTF8OutputSet(HTMainText) &&
		HTLoadedDocumentEightbit() &&
		IS_UTF8_TTY) {
		text->had_utf8 = HTMainText->has_utf8;
	    } else {
		text->had_utf8 = NO;
	    }
	    HTMainText->has_utf8 = NO;
	    text->has_utf8 = NO;
	}

	HTMainText = text;
	HTMainAnchor = text->node_anchor;

	/*
	 * Make this text the most current in the loaded texts list.  -FM
	 */
	if (loaded_texts && HTList_removeObject(loaded_texts, text))
	    HTList_addObject(loaded_texts, text);
    }
    return YES;
}

/*
 * This function returns TRUE if doc's post_data, address
 * and isHEAD elements are identical to those of a loaded
 * (memory cached) text.  -FM
 */
BOOL HText_POSTReplyLoaded(DocInfo *doc)
{
    HText *text = NULL;
    HTList *cur = loaded_texts;
    bstring *post_data;
    char *address;
    BOOL is_head;

    /*
     * Make sure we have the structures.  -FM
     */
    if (!cur || !doc)
	return (FALSE);

    /*
     * Make sure doc is for a POST reply.  -FM
     */
    if ((post_data = doc->post_data) == NULL ||
	(address = doc->address) == NULL)
	return (FALSE);
    is_head = doc->isHEAD;

    /*
     * Loop through the loaded texts looking for a
     * POST reply match.  -FM
     */
    while (NULL != (text = (HText *) HTList_nextObject(cur))) {
	if (text->node_anchor &&
	    text->node_anchor->post_data &&
	    BINEQ(post_data, text->node_anchor->post_data) &&
	    text->node_anchor->address &&
	    !strcmp(address, text->node_anchor->address) &&
	    is_head == text->node_anchor->isHEAD) {
	    return (TRUE);
	}
    }

    return (FALSE);
}

BOOL HTFindPoundSelector(const char *selector)
{
    TextAnchor *a;

    CTRACE((tfp, "FindPound: searching for \"%s\"\n", selector));
    for (a = HTMainText->first_anchor; a != 0; a = a->next) {

	if (a->anchor && a->anchor->tag) {
	    if (!strcmp(a->anchor->tag, selector)) {

		www_search_result = a->line_num + 1;

		CTRACE((tfp, "FindPound: Selecting anchor [%d] at line %d\n",
			a->number, www_search_result));
		if (!strcmp(selector, LYToolbarName)) {
		    --www_search_result;
		}
		return (YES);
	    }
	}
    }
    return (NO);
}

BOOL HText_selectAnchor(HText *text, HTChildAnchor *anchor)
{
    TextAnchor *a;
    int l;

    for (a = text->first_anchor; a; a = a->next) {
	if (a->anchor == anchor)
	    break;
    }
    if (!a) {
	CTRACE((tfp, "HText: No such anchor in this text!\n"));
	return NO;
    }

    if (text != HTMainText) {	/* Comment out by ??? */
	HTMainText = text;	/* Put back in by tbl 921208 */
	HTMainAnchor = text->node_anchor;
    }
    l = a->line_num;

    CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
	    a->number, l));

    if (!text->stale &&
	(l >= text->top_of_screen) &&
	(l < text->top_of_screen + display_lines + 1))
	return YES;

    www_search_result = l - (display_lines / 3);	/* put in global variable */

    return YES;
}

/*		Editing functions		- NOT IMPLEMENTED
 *		=================
 *
 *	These are called from the application.  There are many more functions
 *	not included here from the original text object.
 */

/*	Style handling:
*/
/*	Apply this style to the selection
*/
void HText_applyStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
{

}

/*	Update all text with changed style.
*/
void HText_updateStyle(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
{

}

/*	Return style of  selection
*/
HTStyle *HText_selectionStyle(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
{
    return 0;
}

/*	Paste in styled text
*/
void HText_replaceSel(HText *me GCC_UNUSED, const char *aString GCC_UNUSED,
		      HTStyle *aStyle GCC_UNUSED)
{
}

/*	Apply this style to the selection and all similarly formatted text
 *	(style recovery only)
 */
void HTextApplyToSimilar(HText *me GCC_UNUSED, HTStyle *style GCC_UNUSED)
{

}

/*	Select the first unstyled run.
 *	(style recovery only)
 */
void HTextSelectUnstyled(HText *me GCC_UNUSED, HTStyleSheet *sheet GCC_UNUSED)
{

}

/*	Anchor handling:
*/
void HText_unlinkSelection(HText *me GCC_UNUSED)
{

}

HTAnchor *HText_referenceSelected(HText *me GCC_UNUSED)
{
    return 0;
}

int HText_getTopOfScreen(void)
{
    HText *text = HTMainText;

    return text != 0 ? text->top_of_screen : 0;
}

int HText_getLines(HText *text)
{
    return text->Lines;
}

/*
 * Constrain the line number to be within the document.  The line number is
 * zero-based.
 */
int HText_getPreferredTopLine(HText *text, int line_number)
{
    int last_screen = text->Lines - (display_lines - 2);

    if (text->Lines < display_lines) {
	line_number = 0;
    } else if (line_number > text->Lines) {
	line_number = last_screen;
    } else if (line_number < 0) {
	line_number = 0;
    }
    return line_number;
}

HTAnchor *HText_linkSelTo(HText *me GCC_UNUSED,
			  HTAnchor * anchor GCC_UNUSED)
{
    return 0;
}

/*
 * Utility for freeing the list of previous isindex and whereis queries.  -FM
 */
void HTSearchQueries_free(void)
{
    LYFreeStringList(search_queries);
    search_queries = NULL;
}

/*
 * Utility for listing isindex and whereis queries, making
 * any repeated queries the most current in the list.  -FM
 */
void HTAddSearchQuery(char *query)
{
    char *new_query = NULL;
    char *old;
    HTList *cur;

    if (!non_empty(query))
	return;

    StrAllocCopy(new_query, query);

    if (!search_queries) {
	search_queries = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTSearchQueries_free);
#endif
	HTList_addObject(search_queries, new_query);
	return;
    }

    cur = search_queries;
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, new_query)) {
	    HTList_removeObject(search_queries, old);
	    FREE(old);
	    break;
	}
    }
    HTList_addObject(search_queries, new_query);

    return;
}

int do_www_search(DocInfo *doc)
{
    bstring *searchstring = NULL;
    bstring *temp = NULL;
    char *cp;
    char *tmpaddress = NULL;
    int ch;
    RecallType recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN PreviousSearch = FALSE;
    int code;

    /*
     * Load the default query buffer
     */
    if ((cp = StrChr(doc->address, '?')) != NULL) {
	/*
	 * This is an index from a previous search.
	 * Use its query as the default.
	 */
	PreviousSearch = TRUE;
	BStrCopy0(searchstring, ++cp);
	for (cp = searchstring->str; *cp; cp++)
	    if (*cp == '+')
		*cp = ' ';
	HTUnEscape(searchstring->str);
	BStrCopy(temp, searchstring);
	/*
	 * Make sure it's treated as the most recent query.  -FM
	 */
	HTAddSearchQuery(searchstring->str);
    } else {
	/*
	 * New search; no default.
	 */
	BStrCopy0(searchstring, "");
	BStrCopy0(temp, "");
    }

    /*
     * Prompt for a query string.
     */
    if (isBEmpty(searchstring)) {
	if (HTMainAnchor->isIndexPrompt)
	    _statusline(HTMainAnchor->isIndexPrompt);
	else
	    _statusline(ENTER_DATABASE_QUERY);
    } else
	_statusline(EDIT_CURRENT_QUERY);
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = (((PreviousSearch && QueryTotal >= 2) ||
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

  get_query:
    if ((ch = LYgetBString(&searchstring, FALSE, 0, recall)) < 0 ||
	isBEmpty(searchstring) ||
	ch == UPARROW_KEY ||
	ch == DNARROW_KEY) {

	if (recall && ch == UPARROW_KEY) {
	    if (PreviousSearch) {
		/*
		 * Use the second to last query in the list.  -FM
		 */
		QueryNum = 1;
		PreviousSearch = FALSE;
	    } else {
		/*
		 * Go back to the previous query in the list.  -FM
		 */
		QueryNum++;
	    }
	    if (QueryNum >= QueryTotal)
		/*
		 * Roll around to the last query in the list.  -FM
		 */
		QueryNum = 0;
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		BStrCopy0(searchstring, cp);
		if (!isBEmpty(temp) &&
		    !strcmp(temp->str, searchstring->str)) {
		    _statusline(EDIT_CURRENT_QUERY);
		} else if ((!isBEmpty(temp) && QueryTotal == 2) ||
			   (isBEmpty(temp) && QueryTotal == 1)) {
		    _statusline(EDIT_THE_PREV_QUERY);
		} else {
		    _statusline(EDIT_A_PREV_QUERY);
		}
		goto get_query;
	    }
	} else if (recall && ch == DNARROW_KEY) {
	    if (PreviousSearch) {
		/*
		 * Use the first query in the list.  -FM
		 */
		QueryNum = QueryTotal - 1;
		PreviousSearch = FALSE;
	    } else {
		/*
		 * Advance to the next query in the list.  -FM
		 */
		QueryNum--;
	    }
	    if (QueryNum < 0)
		/*
		 * Roll around to the first query in the list.  -FM
		 */
		QueryNum = QueryTotal - 1;
	    if ((cp = (char *) HTList_objectAt(search_queries,
					       QueryNum)) != NULL) {
		BStrCopy0(searchstring, cp);
		if (!isBEmpty(temp) &&
		    !strcmp(temp->str, searchstring->str)) {
		    _statusline(EDIT_CURRENT_QUERY);
		} else if ((!isBEmpty(temp) && QueryTotal == 2) ||
			   (isBEmpty(temp) && QueryTotal == 1)) {
		    _statusline(EDIT_THE_PREV_QUERY);
		} else {
		    _statusline(EDIT_A_PREV_QUERY);
		}
		goto get_query;
	    }
	}

	/*
	 * Search cancelled.
	 */
	HTInfoMsg(CANCELLED);
	code = NULLFILE;
    } else {

	LYTrimLeading(searchstring->str);
	LYTrimTrailing(searchstring->str);
	if (isBEmpty(searchstring)) {
	    HTInfoMsg(CANCELLED);
	    code = NULLFILE;
	} else if (!LYforce_no_cache &&
		   !isBEmpty(temp) &&
		   !strcmp(temp->str, searchstring->str)) {
	    /*
	     * Don't resubmit the same query unintentionally.
	     */
	    HTUserMsg(USE_C_R_TO_RESUB_CUR_QUERY);
	    code = NULLFILE;
	} else {

	    /*
	     * Add searchstring to the query list,
	     * or make it the most current.  -FM
	     */
	    HTAddSearchQuery(searchstring->str);

	    /*
	     * Show the URL with the new query.
	     */
	    if ((cp = StrChr(doc->address, '?')) != NULL)
		*cp = '\0';
	    StrAllocCopy(tmpaddress, doc->address);
	    StrAllocCat(tmpaddress, "?");
	    StrAllocCat(tmpaddress, searchstring->str);
	    user_message(WWW_WAIT_MESSAGE, tmpaddress);
#ifdef SYSLOG_REQUESTED_URLS
	    LYSyslog(tmpaddress);
#endif
	    FREE(tmpaddress);
	    if (cp)
		*cp = '?';

	    /*
	     * OK, now we do the search.
	     */
	    if (HTSearch(searchstring->str, HTMainAnchor)) {
		auto char *cp_freeme = NULL;

		if (traversal)
		    cp_freeme = stub_HTAnchor_address((HTAnchor *) HTMainAnchor);
		else
		    cp_freeme = HTAnchor_address((HTAnchor *) HTMainAnchor);
		StrAllocCopy(doc->address, cp_freeme);
		FREE(cp_freeme);

		CTRACE((tfp, "\ndo_www_search: newfile: %s\n", doc->address));

		/*
		 * Yah, the search succeeded.
		 */
		code = NORMAL;
	    } else {

		/*
		 * Either the search failed (Yuk), or we got redirection.
		 * If it's redirection, use_this_url_instead is set, and
		 * mainloop() will deal with it such that security features
		 * and restrictions are checked before acting on the URL, or
		 * rejecting it.  -FM
		 */
		code = NOT_FOUND;
	    }
	}
    }
    BStrFree(searchstring);
    BStrFree(temp);
    return code;
}

static void write_offset(FILE *fp, HTLine *line)
{
    int i;

    if (line->data[0]) {
	for (i = 0; i < (int) line->offset; i++) {
	    fputc(' ', fp);
	}
    }
}

static void write_hyphen(FILE *fp)
{
    if (dump_output_immediately &&
	LYRawMode &&
	LYlowest_eightbit[current_char_set] <= 173 &&
	(LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
	 (LYCharSet_UC[current_char_set].like8859 & UCT_R_8859SPECL)) != 0) {
	fputc(0xad, fp);	/* the iso8859 byte for SHY */
    } else {
	fputc('-', fp);
    }
}

/*
 * Returns the length after trimming trailing blanks.  Modify the string as
 * needed so that any special character which follows a trailing blank is moved
 * before the (trimmed) blank, so the result which will be dumped has no
 * trailing blanks.
 */
static int TrimmedLength(char *string)
{
    int result = (int) strlen(string);

    if (!HTisDocumentSource()) {
	int adjust = result;
	unsigned ch;

	while (adjust > 0) {
	    ch = UCH(string[adjust - 1]);
	    if (isspace(ch) || IsSpecialAttrChar(ch)) {
		--adjust;
	    } else {
		break;
	    }
	}
	if (result != adjust) {
	    char *dst = string + adjust;
	    char *src = dst;

	    for (;;) {
		src = LYSkipBlanks(src);
		if ((*dst++ = *src++) == '\0')
		    break;
	    }
	    result = (int) (dst - string - 1);
	}
    }
    return result;
}

typedef struct _AnchorIndex {
    struct _AnchorIndex *next;
    int type;			/* field type */
    int size;			/* character-width of field */
    int length;			/* byte-count for field's data */
    int offset;			/* byte-offset in line's data */
    int filler;			/* character to use for filler */
    const char *value;		/* field's value */
} AnchorIndex;

static unsigned countHTLines(void)
{
    unsigned result = 0;
    HTLine *line = FirstHTLine(HTMainText);

    while (line != 0) {
	++result;
	if (line == HTMainText->last_line)
	    break;
	line = line->next;
    }
    CTRACE((tfp, "countHTLines %u\n", result));
    return result;
}

/*
 * The TextAnchor list is not organized to allow efficient dumping of a page.
 * Make an array with one item per line of the page, and store (by byte-offset)
 * pointers to the TextAnchor's we want to use.
 */
static AnchorIndex **allocAnchorIndex(unsigned *size)
{
    AnchorIndex **result = NULL;
    AnchorIndex *p, *q;
    TextAnchor *anchor = NULL;
    FormInfo *input = NULL;

    *size = countHTLines();
    if (*size != 0) {
	result = typecallocn(AnchorIndex *, *size + 1);
	if (result == NULL)
	    outofmem(__FILE__, "allocAnchorIndex");

	for (anchor = HTMainText->first_anchor;
	     anchor != NULL;
	     anchor = anchor->next) {

	    if (anchor->link_type == INPUT_ANCHOR
		&& anchor->show_anchor
		&& anchor->line_num < (int) *size
		&& (input = anchor->input_field) != NULL) {
		CTRACE2(TRACE_GRIDTEXT,
			(tfp, "line %d.%d %d %s->%s(%s)\n",
			 anchor->line_num,
			 anchor->line_pos,
			 input->size,
			 inputFieldDesc(input),
			 input->value,
			 input->orig_value));
		switch (input->type) {
		case F_SUBMIT_TYPE:
		case F_RESET_TYPE:
		case F_TEXT_SUBMIT_TYPE:
		case F_IMAGE_SUBMIT_TYPE:
		    CTRACE2(TRACE_GRIDTEXT, (tfp, "skipping\n"));
		    continue;
		case F_TEXT_TYPE:
		case F_PASSWORD_TYPE:
		case F_CHECKBOX_TYPE:
		case F_RADIO_TYPE:
		case F_OPTION_LIST_TYPE:
		case F_TEXTAREA_TYPE:
		case F_RANGE_TYPE:
		case F_FILE_TYPE:
		    p = typecalloc(AnchorIndex);
		    if (p == NULL)
			outofmem(__FILE__, "allocAnchorIndex");

		    assert(p != NULL);
		    p->type = input->type;
		    p->size = input->size;
		    p->offset = anchor->line_pos;
		    p->value = input->value;

		    switch (input->type) {
		    case F_TEXTAREA_TYPE:
		    case F_TEXT_TYPE:
		    case F_PASSWORD_TYPE:
			p->filler = '_';
			break;
		    case F_OPTION_LIST_TYPE:
			p->filler = '_';
			break;
		    case F_CHECKBOX_TYPE:
			p->value = (input->num_value
				    ? checked_box
				    : unchecked_box);
			break;
		    case F_RADIO_TYPE:
			p->value = (input->num_value
				    ? checked_radio
				    : unchecked_radio);
			break;
		    default:
			p->filler = ' ';
			break;
		    }
		    p->length = (int) strlen(p->value);

		    if ((q = result[anchor->line_num]) != NULL) {
			/* insert, ordering by offset */
			if (q->offset < p->offset) {
			    while (q->next != NULL
				   && q->next->offset < p->offset) {
				q = q->next;
			    }
			    p->next = q->next;
			    q->next = p;
			} else {
			    p->next = q;
			    result[anchor->line_num] = p;
			}
		    } else {
			result[anchor->line_num] = p;
		    }
		    break;
		}
	    }
	}
    }
    return result;
}

/*
 * Free the data allocated in allocAnchorIndex().
 */
static void freeAnchorIndex(AnchorIndex ** inx, unsigned inx_size)
{
    AnchorIndex *cur;
    unsigned num;

    if (inx != 0) {
	if (inx_size != 0) {
	    for (num = 0; num < inx_size; ++num) {
		while ((cur = inx[num]) != NULL) {
		    inx[num] = cur->next;
		    free(cur);
		}
	    }
	}
	free(inx);
    }
}

/*
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * If is_email is TRUE add ">" before each "From " line.
 * If is_reply is TRUE add ">" to the beginning of each
 * line to specify the file is a reply to message.
 */
#define FieldFirst(p) (this_wrap ? 0 : (p)->offset)
#define FieldLast(p)  (FieldFirst(p) + (p)->size - this_wrap)
void print_wwwfile_to_fd(FILE *fp,
			 int is_email,
			 int is_reply)
{
    int line_num, byte_num, byte_count;
    int first = TRUE;
    HTLine *line;
    AnchorIndex **inx;		/* sorted index of input-fields */
    AnchorIndex *cur = 0;	/* current input-field */
    unsigned inx_size;		/* number of entries in inx[] */
    int in_field = -1;		/* if positive, is index in cur->value[] */
    int this_wrap = 0;		/* current wrapping point of cur->value[] */
    int next_wrap = 0;		/* next wrapping point of cur->value[] */

#ifndef NO_DUMP_WITH_BACKSPACES
    HText *text = HTMainText;
    BOOL in_b = FALSE;
    BOOL in_u = FALSE;
    BOOL bs = (BOOL) (!is_email && !is_reply
		      && text != 0
		      && with_backspaces
		      && !IS_CJK_TTY
		      && !text->T.output_utf8);
#endif

    if (!HTMainText)
	return;

    /*
     * Build an index of anchors for each line, so we can override the
     * static text which is stored in the list of HTLine's.
     */
    inx = allocAnchorIndex(&inx_size);

    line = FirstHTLine(HTMainText);
    for (line_num = 0;; ++line_num, line = line->next) {
	if (in_field >= 0) {
	    this_wrap = next_wrap;
	    next_wrap = 0;	/* FIXME - allow for multiple continuations */
	    CTRACE2(TRACE_GRIDTEXT,
		    (tfp, "wrap %d:%d, offset %d\n",
		     in_field, cur ? cur->length : -1, this_wrap));
	} else {
	    cur = inx[line_num];
	}

	CTRACE2(TRACE_GRIDTEXT, (tfp, "dump %d:%s\n", line_num, line->data));

	if (first) {
	    first = FALSE;
	    if (is_reply) {
		fputc('>', fp);
	    } else if (is_email && !StrNCmp(line->data, "From ", 5)) {
		fputc('>', fp);
	    }
	} else if (line->data[0] != LY_SOFT_NEWLINE) {
	    fputc('\n', fp);
	    /*
	     * Add news-style quotation if requested.  -FM
	     */
	    if (is_reply) {
		fputc('>', fp);
	    } else if (is_email && !StrNCmp(line->data, "From ", 5)) {
		fputc('>', fp);
	    }
	}

	write_offset(fp, line);

	/*
	 * Add data.
	 */
	byte_count = TrimmedLength(line->data);
	for (byte_num = 0; byte_num < byte_count; byte_num++) {
	    int byte_offset = byte_num + line->offset;
	    int ch = UCH(line->data[byte_num]);
	    int c2;

	    while (cur != 0 && FieldLast(cur) < byte_offset) {
		CTRACE2(TRACE_GRIDTEXT,
			(tfp, "skip field since last %d < %d\n",
			 FieldLast(cur), byte_offset));
		cur = cur->next;
		in_field = -1;
	    }
	    if (cur != 0 && in_field >= 0) {
		CTRACE2(TRACE_GRIDTEXT,
			(tfp, "compare %d to [%d..%d]\n",
			 byte_offset,
			 FieldFirst(cur),
			 FieldLast(cur) - 1));
	    }
	    if (cur != 0
		&& FieldFirst(cur) <= byte_offset
		&& FieldLast(cur) > byte_offset) {
		int off2 = ((in_field > 0)
			    ? in_field
			    : (byte_offset - FieldFirst(cur)));

		/*
		 * On the first time (for each line that the field appears on),
		 * check if this field wraps.  If it does, save the offset into
		 * the field which will be used to adjust the beginning of the
		 * continuation line.
		 */
		if (byte_offset == FieldFirst(cur)) {
		    next_wrap = 0;
		    if (cur->size - this_wrap + byte_num > byte_count) {
			CTRACE((tfp, "size %d, offset %d, length %d\n",
				cur->size,
				cur->offset,
				cur->length));
			CTRACE((tfp, "byte_count %d, byte_num %d\n",
				byte_count, byte_num));
			next_wrap = byte_count - byte_num;
			CTRACE2(TRACE_GRIDTEXT,
				(tfp, "field will wrap: %d\n", next_wrap));
		    }
		}

		c2 = ((off2 < cur->length)
		      ? cur->value[off2]
		      : cur->filler);

		if (ch != c2) {
		    CTRACE2(TRACE_GRIDTEXT,
			    (tfp, "line %d %d/%d [%d..%d] map %d %c->%c\n",
			     line_num,
			     off2, cur->length,
			     FieldFirst(cur), FieldLast(cur) - 1,
			     byte_offset, ch, c2));
		    ch = c2;
		}
		++off2;
		if ((off2 >= cur->size) &&
		    (off2 >= cur->length || F_TEXTLIKE(cur->type))) {
		    in_field = -1;
		    this_wrap = 0;
		    next_wrap = 0;
		} else {
		    in_field = off2;
		}
	    }

	    if (!IsSpecialAttrChar(ch)) {
#ifndef NO_DUMP_WITH_BACKSPACES
		if (in_b) {
		    fputc(ch, fp);
		    fputc('\b', fp);
		    fputc(ch, fp);
		} else if (in_u) {
		    fputc('_', fp);
		    fputc('\b', fp);
		    fputc(ch, fp);
		} else
#endif
		    fputc(ch, fp);
	    } else if (ch == LY_SOFT_HYPHEN &&
		       (byte_num + 1) >= byte_count) {
		write_hyphen(fp);
	    } else if (dump_output_immediately && use_underscore) {
		switch (ch) {
		case LY_UNDERLINE_START_CHAR:
		case LY_UNDERLINE_END_CHAR:
		    fputc('_', fp);
		    break;
		case LY_BOLD_START_CHAR:
		case LY_BOLD_END_CHAR:
		    break;
		}
	    }
#ifndef NO_DUMP_WITH_BACKSPACES
	    else if (bs) {
		switch (ch) {
		case LY_UNDERLINE_START_CHAR:
		    if (!in_b)
			in_u = TRUE;	/*favor bold over underline */
		    break;
		case LY_UNDERLINE_END_CHAR:
		    in_u = FALSE;
		    break;
		case LY_BOLD_START_CHAR:
		    if (in_u)
			in_u = FALSE;	/* turn it off */
		    in_b = TRUE;
		    break;
		case LY_BOLD_END_CHAR:
		    in_b = FALSE;
		    break;
		}
	    }
#endif
	}

	if (line == HTMainText->last_line)
	    break;

#ifdef VMS
	if (HadVMSInterrupt)
	    break;
#endif /* VMS */
    }
    fputc('\n', fp);

    freeAnchorIndex(inx, inx_size);
}

/*
 * Print the contents of the file in HTMainText to
 * the file descriptor fp.
 * First output line is "thelink", ie, the URL for this file.
 */
void print_crawl_to_fd(FILE *fp, char *thelink,
		       char *thetitle)
{
    register int i;
    int first = TRUE;
    int limit;
    HTLine *line;

    if (!HTMainText)
	return;

    line = FirstHTLine(HTMainText);
    fprintf(fp, "THE_URL:%s\n", thelink);
    if (thetitle != NULL) {
	fprintf(fp, "THE_TITLE:%s\n", thetitle);
    }

    for (;; line = line->next) {
	if (!first && line->data[0] != LY_SOFT_NEWLINE)
	    fputc('\n', fp);
	first = FALSE;
	write_offset(fp, line);

	/*
	 * Add data.
	 */
	limit = TrimmedLength(line->data);
	for (i = 0; i < limit; i++) {
	    int ch = UCH(line->data[i]);

	    if (!IsSpecialAttrChar(ch)) {
		fputc(ch, fp);
	    } else if (ch == LY_SOFT_HYPHEN &&
		       (i + 1) >= limit) {	/* last char on line */
		write_hyphen(fp);
	    }
	}

	if (!HTMainText || (line == HTMainText->last_line)) {
	    break;
	}
    }
    fputc('\n', fp);

    /*
     * Add the References list if appropriate
     */
    if ((no_list == FALSE) &&
	(dump_links_inline == FALSE) &&
	links_are_numbered()) {
	printlist(fp, FALSE);
    }
#ifdef VMS
    HadVMSInterrupt = FALSE;
#endif /* VMS */
}

static void adjust_search_result(DocInfo *doc, int tentative_result,
				 int start_line)
{
    if (tentative_result > 0) {
	int anch_line = -1;
	TextAnchor *a;
	int nl_closest = -1;
	int goal = SEARCH_GOAL_LINE;
	int max_offset;
	BOOL on_screen = (BOOL) (tentative_result > HTMainText->top_of_screen &&
				 tentative_result <= HTMainText->top_of_screen +
				 display_lines);

	if (goal < 1)
	    goal = 1;
	else if (goal > display_lines)
	    goal = display_lines;
	max_offset = goal - 1;

	if (on_screen && nlinks > 0) {
	    int i;

	    for (i = 0; i < nlinks; i++) {
		if (doc->line + links[i].ly - 1 <= tentative_result)
		    nl_closest = i;
		if (doc->line + links[i].ly - 1 >= tentative_result)
		    break;
	    }
	    if (nl_closest >= 0 &&
		doc->line + links[nl_closest].ly - 1 == tentative_result) {
		www_search_result = doc->line;
		doc->link = nl_closest;
		return;
	    }
	}

	/* find last anchor before or on target line */
	for (a = HTMainText->first_anchor;
	     a && a->line_num <= tentative_result - 1; a = a->next) {
	    anch_line = a->line_num + 1;
	}
	/* position such that the anchor found is on first screen line,
	   if it is not too far above the target line; but also try to
	   make sure we move forward. */
	if (anch_line >= 0 &&
	    anch_line >= tentative_result - max_offset &&
	    (anch_line > start_line ||
	     tentative_result <= HTMainText->top_of_screen)) {
	    www_search_result = anch_line;
	} else if (tentative_result - start_line > 0 &&
		   tentative_result - (start_line + 1) <= max_offset) {
	    www_search_result = start_line + 1;
	} else if (tentative_result > HTMainText->top_of_screen &&
		   tentative_result <= start_line &&	/* have wrapped */
		   tentative_result <= HTMainText->top_of_screen + goal) {
	    www_search_result = HTMainText->top_of_screen + 1;
	} else if (tentative_result <= goal)
	    www_search_result = 1;
	else
	    www_search_result = tentative_result - max_offset;
	if (www_search_result == doc->line) {
	    if (nl_closest >= 0) {
		doc->link = nl_closest;
		return;
	    }
	}
    }
}

/*
 * see also link_has_target
 */
static BOOL anchor_has_target(TextAnchor *a, char *target)
{
    char *text = NULL;
    const char *last = "?";
    int count;

    /*
     * Combine the parts of the link's text using the highlighting information,
     * and compare the target against that.
     */
    for (count = 0; count < 10; ++count) {
	const char *part = LYGetHiTextStr(a, count);

	if (part == NULL || part == last) {
	    if (text != NULL && LYno_attr_strstr(text, target)) {
		return TRUE;
	    }
	    break;
	}
	StrAllocCat(text, part);
	last = part;
    }

    return field_has_target(a->input_field, target);
}

static TextAnchor *line_num_to_anchor(int line_num)
{
    TextAnchor *a;

    if (HTMainText != 0) {
	a = HTMainText->first_anchor;
	while (a != 0 && a->line_num < line_num) {
	    a = a->next;
	}
    } else {
	a = 0;
    }
    return a;
}

static int line_num_in_text(HText *text, HTLine *line)
{
    int result = 1;
    HTLine *temp = FirstHTLine(text);

    while (temp != line) {
	temp = temp->next;
	++result;
    }
    return result;
}

/* Computes the 'prev' pointers on demand, and returns the one for the given
 * anchor.
 */
static TextAnchor *get_prev_anchor(TextAnchor *a)
{
    TextAnchor *p, *q;

    if (a->prev == 0) {
	if ((p = HTMainText->first_anchor) != 0) {
	    while ((q = p->next) != 0) {
		q->prev = p;
		p = q;
	    }
	}
    }
    return a->prev;
}

static int www_search_forward(int start_line,
			      DocInfo *doc,
			      char *target,
			      HTLine *line,
			      int count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = a->next;
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
	    break;
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == HTMainText->last_line) {
	    count = 0;
	    wrapped++;
	    a = HTMainText->first_anchor;
	}
	line = line->next;
	count++;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

static int www_search_backward(int start_line,
			       DocInfo *doc,
			       char *target,
			       HTLine *line,
			       int count)
{
    int wrapped = 0;
    TextAnchor *a = line_num_to_anchor(count - 1);
    int tentative_result = -1;

    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		!(a->link_type == INPUT_ANCHOR
		  && a->input_field->type == F_HIDDEN_TYPE)) {
		if (anchor_has_target(a, target)) {
		    adjust_search_result(doc, count, start_line);
		    return 1;
		}
	    }
	    a = get_prev_anchor(a);
	}

	if (LYno_attr_strstr(line->data, target)) {
	    tentative_result = count;
	    break;
	} else if ((count == start_line && wrapped) || wrapped > 1) {
	    HTUserMsg2(STRING_NOT_FOUND, target);
	    return -1;
	} else if (line == FirstHTLine(HTMainText)) {
	    count = line_num_in_text(HTMainText, LastHTLine(HTMainText)) + 1;
	    wrapped++;
	    a = HTMainText->last_anchor;
	}
	line = line->prev;
	count--;
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
    return 0;
}

void www_user_search(int start_line,
		     DocInfo *doc,
		     char *target,
		     int direction)
{
    HTLine *line;
    int count;

    if (!HTMainText) {
	return;
    }

    /*
     * Advance to the start line.
     */
    line = FirstHTLine(HTMainText);
    if (start_line + direction > 0) {
	for (count = 1;
	     count < start_line + direction;
	     line = line->next, count++) {
	    if (line == HTMainText->last_line) {
		line = FirstHTLine(HTMainText);
		count = 1;
		break;
	    }
	}
    } else {
	line = HTMainText->last_line;
	count = line_num_in_text(HTMainText, line);
    }

    if (direction >= 0)
	www_search_forward(start_line, doc, target, line, count);
    else
	www_search_backward(start_line, doc, target, line, count);
}

void user_message(const char *message,
		  const char *argument)
{
    if (message == NULL) {
	mustshow = FALSE;
    } else {
	char *temp = NULL;

	HTSprintf0(&temp, message, NonNull(argument));
	statusline(temp);
	FREE(temp);
    }
}

/*
 * HText_getOwner returns the owner of the
 * current document.
 */
const char *HText_getOwner(void)
{
    return (HTMainText ?
	    HTAnchor_owner(HTMainText->node_anchor) : 0);
}

/*
 * HText_setMainTextOwner sets the owner for the
 * current document.
 */
void HText_setMainTextOwner(const char *owner)
{
    if (!HTMainText)
	return;

    HTAnchor_setOwner(HTMainText->node_anchor, owner);
}

/*
 * HText_getRevTitle returns the RevTitle element of the
 * current document, used as the subject for mailto comments
 * to the owner.
 */
const char *HText_getRevTitle(void)
{
    return (HTMainText ?
	    HTAnchor_RevTitle(HTMainText->node_anchor) : 0);
}

/*
 * HText_getContentBase returns the Content-Base header
 * of the current document.
 */
const char *HText_getContentBase(void)
{
    return (HTMainText ?
	    HTAnchor_content_base(HTMainText->node_anchor) : 0);
}

/*
 * HText_getContentLocation returns the Content-Location header
 * of the current document.
 */
const char *HText_getContentLocation(void)
{
    return (HTMainText ?
	    HTAnchor_content_location(HTMainText->node_anchor) : 0);
}

/*
 * HText_getMessageID returns the Message-ID of the
 * current document.
 */
const char *HText_getMessageID(void)
{
    return (HTMainText ?
	    HTAnchor_messageID(HTMainText->node_anchor) : NULL);
}

void HTuncache_current_document(void)
{
    /*
     * Should remove current document from memory.
     */
    if (HTMainText) {
	HTParentAnchor *htmain_anchor = HTMainText->node_anchor;

	if (htmain_anchor) {
	    if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
		FREE(htmain_anchor->UCStages);
	    }
	}
	CTRACE((tfp, "\nHTuncache.. freeing document for '%s'%s\n",
		((htmain_anchor &&
		  htmain_anchor->address) ?
		 htmain_anchor->address : "unknown anchor"),
		((htmain_anchor &&
		  htmain_anchor->post_data)
		 ? " with POST data"
		 : "")));
	HTList_removeObject(loaded_texts, HTMainText);
	HText_free(HTMainText);
	HTMainText = NULL;
    } else {
	CTRACE((tfp, "HTuncache.. HTMainText already is NULL!\n"));
    }
}

/*
 * This magic FREE(anchor->UCStages) call
 * stolen from HTuncache_current_document() above.
 */
static void magicUncache(void)
{
    if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	FREE(HTMainAnchor->UCStages);
    }
    /* avoid null-reference later */
    if (!HTOutputFormat)
	HTOutputFormat = WWW_SOURCE;
}

#ifdef USE_SOURCE_CACHE

/* dummy - kw */
static HTProtocol scm =
{
    "source-cache-mem", 0, 0
};

static BOOLEAN useSourceCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_FILE) {
	result = (BOOLEAN) (HTMainAnchor->source_cache_file != 0);
	CTRACE((tfp, "SourceCache: file-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

static BOOLEAN useMemoryCache(void)
{
    BOOLEAN result = FALSE;

    if (LYCacheSource == SOURCE_CACHE_MEMORY) {
	result = (BOOLEAN) (HTMainAnchor->source_cache_chunk != 0);
	CTRACE((tfp, "SourceCache: memory-cache%s found\n",
		result ? "" : " not"));
    }
    return result;
}

BOOLEAN HTreparse_document(void)
{
    BOOLEAN ok = FALSE;

    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	CTRACE((tfp, "HTreparse_document returns FALSE\n"));
    } else if (useSourceCache()) {
	FILE *fp;
	HTFormat format;
	int ret;

	CTRACE((tfp, "SourceCache: Reparsing file %s\n",
		HTMainAnchor->source_cache_file));

	magicUncache();

	/*
	 * This is more or less copied out of HTLoadFile(), except we don't
	 * get a content encoding.  This may be overkill.  -dsb
	 */
	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
	    format = HTFileFormat(HTMainAnchor->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainAnchor,
				     UCLYhndl_for_unspec);
	    /* not UCLYhndl_HTFile_for_unspec - we are talking about remote
	     * documents...
	     */
	}
	CTRACE((tfp, "  Content type is \"%s\"\n", format->name));

	fp = fopen(HTMainAnchor->source_cache_file, "r");
	if (!fp) {
	    CTRACE((tfp, "  Cannot read file %s\n", HTMainAnchor->source_cache_file));
	    (void) LYRemoveTemp(HTMainAnchor->source_cache_file);
	    FREE(HTMainAnchor->source_cache_file);
	} else {

	    if (HText_HaveUserChangedForms(HTMainText)) {
		/*
		 * Issue a warning.  Will not restore changed forms, currently.
		 */
		HTAlert(RELOADING_FORM);
	    }
	    /* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	     * the SourceCacheWriter to not regenerate the cache file (which
	     * would be an unnecessary "loop"). - kw
	     */
	    HTAnchor_setProtocol(HTMainAnchor, &HTFile);
	    ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, NULL);
	    LYCloseInput(fp);
	    if (ret == HT_PARTIAL_CONTENT) {
		HTInfoMsg(gettext("Loading incomplete."));
		CTRACE((tfp,
			"SourceCache: `%s' has been accessed, partial content.\n",
			HTLoadedDocumentURL()));
	    }
	    ok = (BOOL) (ret == HT_LOADED || ret == HT_PARTIAL_CONTENT);

	    CTRACE((tfp, "Reparse file %s\n", (ok ? "succeeded" : "failed")));
	}
    } else if (useMemoryCache()) {
	HTFormat format = WWW_HTML;
	int ret;

	CTRACE((tfp, "SourceCache: Reparsing from memory chunk %p\n",
		(void *) HTMainAnchor->source_cache_chunk));

	magicUncache();

	if (HTMainAnchor->content_type) {
	    format = HTAtom_for(HTMainAnchor->content_type);
	} else {
	    /*
	     * This is only done to make things aligned with SOURCE_CACHE_NONE
	     * and SOURCE_CACHE_FILE when switching to source mode since the
	     * original document's charset will be LYPushAssumed() and then
	     * LYPopAssumed().  See LYK_SOURCE in mainloop if you change
	     * something here.  No user-visible benefits, seems just '=' Info
	     * Page will show source's effective charset as "(assumed)".
	     */
	    format = HTCharsetFormat(format, HTMainAnchor,
				     UCLYhndl_for_unspec);
	}
	/* not UCLYhndl_HTFile_for_unspec - we are talking about remote documents... */

	if (HText_HaveUserChangedForms(HTMainText)) {
	    /*
	     * Issue a warning.  Will not restore changed forms, currently.
	     */
	    HTAlert(RELOADING_FORM);
	}
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache chunk (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &scm);	/* cheating -
							   anything != &HTTP or &HTTPS would do - kw */
	ret = HTParseMem(format, HTOutputFormat, HTMainAnchor,
			 HTMainAnchor->source_cache_chunk, NULL);
	ok = (BOOL) (ret == HT_LOADED);

	CTRACE((tfp, "Reparse memory %s\n", (ok ? "succeeded" : "failed")));
    }

    return ok;
}

BOOLEAN HTcan_reparse_document(void)
{
    BOOLEAN result = FALSE;

    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE) {
	result = FALSE;
    } else if (useSourceCache()) {
	result = LYCanReadFile(HTMainAnchor->source_cache_file);
    } else if (useMemoryCache()) {
	result = TRUE;
    }

    CTRACE((tfp, "HTcan_reparse_document -> %d\n", result));
    return result;
}

static void trace_setting_change(const char *name,
				 int prev_setting,
				 int new_setting)
{
    if (prev_setting != new_setting)
	CTRACE((tfp,
		"HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
		name, prev_setting, new_setting));
}

BOOLEAN HTdocument_settings_changed(void)
{
    /*
     * Annoying Hack(TM):  If we don't have a source cache, we can't
     * reparse anyway, so pretend the settings haven't changed.
     */
    if (!HTMainText || !HTcan_reparse_document())
	return FALSE;

    if (TRACE) {
	/*
	 * If we're tracing, note everying that has changed.
	 */
	trace_setting_change("CLICKABLE_IMAGES",
			     HTMainText->clickable_images, clickable_images);
	trace_setting_change("PSEUDO_INLINE_ALTS",
			     HTMainText->pseudo_inline_alts,
			     pseudo_inline_alts);
	trace_setting_change("VERBOSE_IMG",
			     HTMainText->verbose_img,
			     verbose_img);
	trace_setting_change("RAW_MODE", HTMainText->raw_mode,
			     LYUseDefaultRawMode);
	trace_setting_change("HISTORICAL_COMMENTS",
			     HTMainText->historical_comments,
			     historical_comments);
	trace_setting_change("MINIMAL_COMMENTS",
			     HTMainText->minimal_comments, minimal_comments);
	trace_setting_change("SOFT_DQUOTES",
			     HTMainText->soft_dquotes, soft_dquotes);
	trace_setting_change("OLD_DTD", HTMainText->old_dtd, Old_DTD);
	trace_setting_change("KEYPAD_MODE",
			     HTMainText->keypad_mode, keypad_mode);
	if (HTMainText->disp_lines != LYlines || HTMainText->disp_cols != DISPLAY_COLS)
	    CTRACE((tfp,
		    "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
		    HTMainText->disp_cols,
		    HTMainText->disp_lines,
		    DISPLAY_COLS,
		    LYlines));
    }

    return (BOOLEAN) (HTMainText->clickable_images != clickable_images ||
		      HTMainText->pseudo_inline_alts != pseudo_inline_alts ||
		      HTMainText->verbose_img != verbose_img ||
		      HTMainText->raw_mode != LYUseDefaultRawMode ||
		      HTMainText->historical_comments != historical_comments ||
		      (HTMainText->minimal_comments != minimal_comments &&
		       !historical_comments) ||
		      HTMainText->soft_dquotes != soft_dquotes ||
		      HTMainText->old_dtd != Old_DTD ||
		      HTMainText->keypad_mode != keypad_mode ||
		      HTMainText->disp_cols != DISPLAY_COLS);
}
#endif

int HTisDocumentSource(void)
{
    return (HTMainText != 0) ? HTMainText->source : FALSE;
}

const char *HTLoadedDocumentURL(void)
{
    if (!HTMainText)
	return ("");

    if (HTMainText->node_anchor && HTMainText->node_anchor->address)
	return (HTMainText->node_anchor->address);
    else
	return ("");
}

bstring *HTLoadedDocumentPost_data(void)
{
    if (HTMainText
	&& HTMainText->node_anchor
	&& HTMainText->node_anchor->post_data)
	return (HTMainText->node_anchor->post_data);
    else
	return (0);
}

const char *HTLoadedDocumentTitle(void)
{
    if (!HTMainText)
	return ("");

    if (HTMainText->node_anchor && HTMainText->node_anchor->title)
	return (HTMainText->node_anchor->title);
    else
	return ("");
}

BOOLEAN HTLoadedDocumentIsHEAD(void)
{
    if (!HTMainText)
	return (FALSE);

    if (HTMainText->node_anchor && HTMainText->node_anchor->isHEAD)
	return (HTMainText->node_anchor->isHEAD);
    else
	return (FALSE);
}

BOOLEAN HTLoadedDocumentIsSafe(void)
{
    if (!HTMainText)
	return (FALSE);

    if (HTMainText->node_anchor && HTMainText->node_anchor->safe)
	return (HTMainText->node_anchor->safe);
    else
	return (FALSE);
}

const char *HTLoadedDocumentCharset(void)
{
    const char *result = NULL;

    if (HTMainText &&
	HTMainText->node_anchor) {
	result = HTMainText->node_anchor->charset;
    }

    return result;
}

BOOL HTLoadedDocumentEightbit(void)
{
    if (!HTMainText)
	return (NO);
    else
	return (HTMainText->have_8bit_chars);
}

void HText_setNodeAnchorBookmark(const char *bookmark)
{
    if (!HTMainText)
	return;

    if (HTMainText->node_anchor)
	HTAnchor_setBookmark(HTMainText->node_anchor, bookmark);
}

const char *HTLoadedDocumentBookmark(void)
{
    if (!HTMainText)
	return (NULL);

    if (HTMainText->node_anchor && HTMainText->node_anchor->bookmark)
	return (HTMainText->node_anchor->bookmark);
    else
	return (NULL);
}

int HText_LastLineSize(HText *text, int IgnoreSpaces)
{
    if (!text || !text->last_line || !text->last_line->size)
	return 0;
    return HText_TrueLineSize(text->last_line, text, IgnoreSpaces);
}

BOOL HText_LastLineEmpty(HText *text, int IgnoreSpaces)
{
    if (!text || !text->last_line || !text->last_line->size)
	return TRUE;
    return HText_TrueEmptyLine(text->last_line, text, IgnoreSpaces);
}

int HText_LastLineOffset(HText *text)
{
    if (!text || !text->last_line)
	return 0;
    return text->last_line->offset;
}

int HText_PreviousLineSize(HText *text, int IgnoreSpaces)
{
    HTLine *line;

    if (!text || !text->last_line)
	return 0;
    if (!(line = text->last_line->prev))
	return 0;
    return HText_TrueLineSize(line, text, IgnoreSpaces);
}

BOOL HText_PreviousLineEmpty(HText *text, int IgnoreSpaces)
{
    HTLine *line;

    if (!text || !text->last_line)
	return TRUE;
    if (!(line = text->last_line->prev))
	return TRUE;
    return HText_TrueEmptyLine(line, text, IgnoreSpaces);
}

/*
 * Compute the "true" line size.
 */
static int HText_TrueLineSize(HTLine *line, HText *text, int IgnoreSpaces)
{
    size_t i;
    int true_size = 0;

    if (!(line && line->size))
	return 0;

    if (IgnoreSpaces) {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
		true_size++;
	    }
	}
    } else {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(line->data[i]) &&
		IS_UTF8_EXTRA(line->data[i])) {
		true_size++;
	    }
	}
    }
    return true_size;
}

/*
 * Tell if the line is really empty.  This is invoked much more often than
 * HText_TrueLineSize(), and most lines are not empty.  So it is faster to
 * do this check than to check if the line size happens to be zero.
 */
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, int IgnoreSpaces)
{
    size_t i;

    if (!(line && line->size))
	return TRUE;

    if (IgnoreSpaces) {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		IS_UTF8_EXTRA(line->data[i]) &&
		!isspace(UCH(line->data[i])) &&
		UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		UCH(line->data[i]) != HT_EN_SPACE) {
		return FALSE;
	    }
	}
    } else {
	for (i = 0; i < line->size; i++) {
	    if (!IsSpecialAttrChar(line->data[i]) &&
		IS_UTF8_EXTRA(line->data[i])) {
		return FALSE;
	    }
	}
    }
    return TRUE;
}

void HText_NegateLineOne(HText *text)
{
    if (text) {
	text->in_line_1 = NO;
    }
    return;
}

BOOL HText_inLineOne(HText *text)
{
    if (text) {
	return text->in_line_1;
    }
    return YES;
}

/*
 * This function is for removing the first of two
 * successive blank lines.  It should be called after
 * checking the situation with HText_LastLineSize()
 * and HText_PreviousLineSize().  Any characters in
 * the removed line (i.e., control characters, or it
 * wouldn't have tested blank) should have been
 * reiterated by split_line() in the retained blank
 * line.  -FM
 */
void HText_RemovePreviousLine(HText *text)
{
    HTLine *line, *previous;

    if (!(text && text->Lines > 1))
	return;

    line = text->last_line->prev;
    previous = line->prev;
    previous->next = text->last_line;
    text->last_line->prev = previous;
    text->Lines--;
    freeHTLine(text, line);
}

/*
 * NOTE:  This function presently is correct only if the
 *	  alignment is HT_LEFT.  The offset is still zero,
 *	  because that's not determined for HT_CENTER or
 *	  HT_RIGHT until subsequent characters are received
 *	  and split_line() is called. -FM
 */
int HText_getCurrentColumn(HText *text)
{
    int column = 0;
    BOOL IgnoreSpaces = FALSE;

    if (text) {
	column = ((text->in_line_1
		   ? (int) text->style->indent1st
		   : (int) text->style->leftIndent)
		  + (int) text->last_line->offset
		  + HText_LastLineSize(text, IgnoreSpaces));
    }
    return column;
}

int HText_getMaximumColumn(HText *text)
{
    int column = DISPLAY_COLS;

    if (text) {
	column -= (int) text->style->rightIndent;
    }
    return column;
}

/*
 * NOTE:  This function uses HText_getCurrentColumn() which
 *	  presently is correct only if the alignment is
 *	  HT_LEFT. -FM
 */
void HText_setTabID(HText *text, const char *name)
{
    HTTabID *Tab = NULL;
    HTList *cur = text->tabs;
    HTList *last = NULL;

    if (!text || isEmpty(name))
	return;

    if (!cur) {
	cur = text->tabs = HTList_new();
    } else {
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
	    if (Tab->name && !strcmp(Tab->name, name))
		return;		/* Already set.  Keep the first value. */
	    last = cur;
	}
	if (last)
	    cur = last;
    }
    if (!Tab) {			/* New name.  Create a new node */
	Tab = typecalloc(HTTabID);
	if (Tab == NULL)
	    outofmem(__FILE__, "HText_setTabID");
	HTList_addObject(cur, Tab);
	StrAllocCopy(Tab->name, name);
    }

    assert(Tab != NULL);
    Tab->column = HText_getCurrentColumn(text);
    return;
}

int HText_getTabIDColumn(HText *text, const char *name)
{
    int column = 0;
    HTTabID *Tab;
    HTList *cur = text->tabs;

    if (text && non_empty(name) && cur) {
	while (NULL != (Tab = (HTTabID *) HTList_nextObject(cur))) {
	    if (Tab->name && !strcmp(Tab->name, name))
		break;
	}
	if (Tab)
	    column = Tab->column;
    }
    return column;
}

/*
 * This function is for saving the address of a link
 * which had an attribute in the markup that resolved
 * to a URL (i.e., not just a NAME or ID attribute),
 * but was found in HText_endAnchor() to have no visible
 * content for use as a link name.  It loads the address
 * into text->hidden_links, whose count can be determined
 * via HText_HiddenLinks(), below.  The addresses can be
 * retrieved via HText_HiddenLinkAt(), below, based on
 * count.  -FM
 */
static void HText_AddHiddenLink(HText *text, TextAnchor *textanchor)
{
    HTAnchor *dest;

    /*
     * Make sure we have an HText structure and anchor.  -FM
     */
    if (!(text && textanchor && textanchor->anchor))
	return;

    /*
     * Create the hidden links list
     * if it hasn't been already.  -FM
     */
    if (text->hidden_links == NULL)
	text->hidden_links = HTList_new();

    /*
     * Store the address, in reverse list order
     * so that first in will be first out on
     * retrievals.  -FM
     */
    if ((dest = HTAnchor_followLink(textanchor->anchor)) &&
	(text->hiddenlinkflag != HIDDENLINKS_IGNORE ||
	 HTList_isEmpty(text->hidden_links))) {
	char *value = HTAnchor_address(dest);
	BOOL ignore = FALSE;

	if (unique_urls) {
	    int cnt;
	    char *check;

	    for (cnt = 0;; ++cnt) {

		check = (char *) HTList_objectAt(text->hidden_links, cnt);
		if (check == 0)
		    break;
		if (!strcmp(check, value)) {
		    ignore = TRUE;
		    break;
		}
	    }
	}
	if (ignore) {
	    FREE(value);
	} else {
	    HTList_appendObject(text->hidden_links, value);
	}
    }

    return;
}

/*
 * This function returns the number of addresses
 * that are loaded in text->hidden_links.  -FM
 */
int HText_HiddenLinkCount(HText *text)
{
    int count = 0;

    if (text && text->hidden_links)
	count = HTList_count((HTList *) text->hidden_links);

    return (count);
}

/*
 * This function returns the address, corresponding to
 * a hidden link, at the position (zero-based) in the
 * text->hidden_links list of the number argument.  -FM
 */
const char *HText_HiddenLinkAt(HText *text, int number)
{
    char *href = NULL;

    if (text && text->hidden_links && number >= 0)
	href = (char *) HTList_objectAt((HTList *) text->hidden_links, number);

    return (href);
}

/*
 * Form methods
 * These routines are used to build forms consisting
 * of input fields
 */
static BOOLEAN HTFormDisabled = FALSE;
static PerFormInfo *HTCurrentForm;

static BOOLEAN addFormAction(FormInfo * f)
{
    BOOLEAN result = FALSE;

    if (HTCurrentForm != NULL) {
	result = TRUE;
	f->submit_action = NULL;
	StrAllocCopy(f->submit_action, HTCurrentForm->data.submit_action);
	if (HTCurrentForm->data.submit_enctype != NULL)
	    StrAllocCopy(f->submit_enctype, HTCurrentForm->data.submit_enctype);
	if (HTCurrentForm->data.submit_title != NULL)
	    StrAllocCopy(f->submit_title, HTCurrentForm->data.submit_title);
	f->submit_method = HTCurrentForm->data.submit_method;
    }
    return result;
}

void HText_beginForm(char *action,
		     char *method,
		     char *enctype,
		     char *title,
		     const char *accept_cs)
{
    PerFormInfo *newform;
    int HTFormMethod = URL_GET_METHOD;
    char *HTFormAction = NULL;
    char *HTFormEnctype = NULL;
    char *HTFormTitle = NULL;
    char *HTFormAcceptCharset = NULL;

    HTFormNumber++;

    HTFormFields = 0;
    HTFormDisabled = FALSE;

    /*
     * Check the ACTION.  -FM
     */
    if (action != NULL) {
	if (isMAILTO_URL(action)) {
	    HTFormMethod = URL_MAIL_METHOD;
	}
	StrAllocCopy(HTFormAction, action);
    } else
	StrAllocCopy(HTFormAction, HTLoadedDocumentURL());

    /*
     * Check the METHOD.  -FM
     */
    if (method != NULL && HTFormMethod != URL_MAIL_METHOD)
	if (!strcasecomp(method, "post") || !strcasecomp(method, "pget"))
	    HTFormMethod = URL_POST_METHOD;

    /*
     * Check the ENCTYPE.  -FM
     */
    if (non_empty(enctype)) {
	StrAllocCopy(HTFormEnctype, enctype);
	if (HTFormMethod != URL_MAIL_METHOD &&
	    !strncasecomp(enctype, "multipart/form-data", 19))
	    HTFormMethod = URL_POST_METHOD;
    } else {
	FREE(HTFormEnctype);
    }

    /*
     * Check the TITLE.  -FM
     */
    if (non_empty(title))
	StrAllocCopy(HTFormTitle, title);
    else
	FREE(HTFormTitle);

    /*
     * Check for an ACCEPT_CHARSET.  If present, store it and
     * convert to lowercase and collapse spaces.  - kw
     */
    if (accept_cs != NULL) {
	StrAllocCopy(HTFormAcceptCharset, accept_cs);
	LYRemoveBlanks(HTFormAcceptCharset);
	LYLowerCase(HTFormAcceptCharset);
    }

    /*
     * Create a new "PerFormInfo" structure to hold info on the current form. 
     * This will be appended to the forms list kept by the HText object if and
     * when we reach a HText_endForm.
     */
    newform = typecalloc(PerFormInfo);
    if (newform == NULL)
	outofmem(__FILE__, "HText_beginForm");

    assert(newform != NULL);

    PerFormInfo_free(HTCurrentForm);	/* shouldn't happen here - kw */
    HTCurrentForm = newform;

    newform->number = HTFormNumber;
    newform->data.submit_action = HTFormAction;
    newform->data.submit_enctype = HTFormEnctype;
    newform->data.submit_method = HTFormMethod;
    newform->data.submit_title = HTFormTitle;
    newform->accept_cs = HTFormAcceptCharset;

    CTRACE((tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
	    HTFormAction, HTFormMethod,
	    (HTFormTitle ? " Title:" : ""),
	    NonNull(HTFormTitle),
	    (HTFormEnctype ? " Enctype:" : ""),
	    NonNull(HTFormEnctype),
	    (HTFormAcceptCharset ? " Accept-charset:" : ""),
	    NonNull(HTFormAcceptCharset)));
}

void HText_endForm(HText *text)
{
    if (text != NULL) {
	if (HTFormFields == 1 && text->first_anchor) {
	    /*
	     * Support submission of a single text input field in
	     * the form via <return> instead of a submit button.  -FM
	     */
	    TextAnchor *a;

	    /*
	     * Go through list of anchors and get our input field.  -FM
	     */
	    for (a = text->first_anchor; a != NULL; a = a->next) {
		if (a->link_type == INPUT_ANCHOR &&
		    a->input_field->number == HTFormNumber &&
		    a->input_field->type != F_TEXTAREA_TYPE &&
		    F_TEXTLIKE(a->input_field->type)) {
		    /*
		     * Got it.  Make it submitting.  -FM
		     */
		    if (addFormAction(a->input_field)) {
			a->input_field->type = F_TEXT_SUBMIT_TYPE;
			if (HTFormDisabled)
			    a->input_field->disabled = TRUE;
		    }
		    break;
		}
	    }
	}

	/*
	 * Append info on the current form to the HText object's list of forms. 
	 * HText_beginInput call will have set some of the data in the
	 * PerFormInfo structure (if there were any form fields at all).
	 */
	if (HTCurrentForm) {
	    if (HTFormDisabled)
		HTCurrentForm->disabled = TRUE;
	    if (!text->forms)
		text->forms = HTList_new();
	    HTList_appendObject(text->forms, HTCurrentForm);
	    HTCurrentForm = NULL;
	} else {
	    CTRACE((tfp, "endForm:    HTCurrentForm is missing!\n"));
	}
    } else {
	CTRACE((tfp, "endForm:    HText is missing!\n"));
    }

    FREE(HTCurSelectGroup);
    FREE(HTCurSelectGroupSize);
    FREE(HTCurSelectedOptionValue);
    HTFormFields = 0;
    HTFormDisabled = FALSE;
}

void HText_beginSelect(char *name,
		       int name_cs,
		       int multiple,
		       char *size)
{
    /*
     * Save the group name.
     */
    StrAllocCopy(HTCurSelectGroup, name);
    HTCurSelectGroupCharset = name_cs;

    /*
     * If multiple then all options are actually checkboxes.
     */
    if (multiple)
	HTCurSelectGroupType = F_CHECKBOX_TYPE;
    /*
     * If not multiple then all options are radio buttons.
     */
    else
	HTCurSelectGroupType = F_RADIO_TYPE;

    /*
     * Length of an option list.
     */
    StrAllocCopy(HTCurSelectGroupSize, size);

    CTRACE((tfp, "HText_beginSelect: name=%s type=%d size=%s\n",
	    ((HTCurSelectGroup == NULL) ?
	     "<NULL>" : HTCurSelectGroup),
	    HTCurSelectGroupType,
	    ((HTCurSelectGroupSize == NULL) ?
	     "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp, "HText_beginSelect: name_cs=%d \"%s\"\n",
	    HTCurSelectGroupCharset,
	    (HTCurSelectGroupCharset >= 0 ?
	     LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
}

/*
 *  This function returns the number of the option whose
 *  value currently is being accumulated for a select
 *  block. - LE && FM
 */
int HText_getOptionNum(HText *text)
{
    TextAnchor *a;
    OptionType *op;
    int n = 1;			/* start count at 1 */

    if (!(text && text->last_anchor))
	return (0);

    a = text->last_anchor;
    if (!(a->link_type == INPUT_ANCHOR && a->input_field &&
	  a->input_field->type == F_OPTION_LIST_TYPE))
	return (0);

    for (op = a->input_field->select_list; op; op = op->next)
	n++;
    CTRACE((tfp, "HText_getOptionNum: Got number '%d'.\n", n));
    return (n);
}

/*
 *  This function checks for a numbered option pattern
 *  as the prefix for an option value.  If present, and
 *  we are in the correct keypad mode, it returns a
 *  pointer to the actual value, following that prefix.
 *  Otherwise, it returns the original pointer.
 */
static char *HText_skipOptionNumPrefix(char *opname)
{
    /*
     * Check if we are in the correct keypad mode.
     */
    if (fields_are_numbered()) {
	/*
	 * Skip the option number embedded in the option name so the
	 * extra chars won't mess up cgi scripts processing the value.
	 * The format is (nnn)__ where nnn is a number and there is a
	 * minimum of 5 chars (no underscores if (nnn) exceeds 5 chars).
	 * See HTML.c.  If the chars don't exactly match this format,
	 * just use all of opname.  - LE
	 */
	char *cp = opname;

	if ((non_empty(cp) && *cp++ == '(') &&
	    *cp && isdigit(UCH(*cp++))) {
	    while (*cp && isdigit(UCH(*cp)))
		++cp;
	    if (*cp && *cp++ == ')') {
		int i = (int) (cp - opname);

		while (i < 5) {
		    if (*cp != '_')
			break;
		    i++;
		    cp++;
		}
		if (i < 5) {
		    cp = opname;
		}
	    } else {
		cp = opname;
	    }
	} else {
	    cp = opname;
	}
	return (cp);
    }

    return (opname);
}

/*
 * We couldn't set the value field for the previous option tag so we have to do
 * it now.  Assume that the last anchor was the previous options' tag.
 */
char *HText_setLastOptionValue(HText *text, char *value,
			       char *submit_value,
			       int order,
			       int checked,
			       int val_cs,
			       int submit_val_cs)
{
    char *cp, *cp1;
    char *ret_Value = NULL;
    unsigned char *tmp = NULL;
    int number = 0, i, j;

    if (!(value
	  && text
	  && text->last_anchor
	  && text->last_anchor->input_field
	  && text->last_anchor->link_type == INPUT_ANCHOR)) {
	CTRACE((tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		(value ? value : "<NULL>")));
	return NULL;
    }

    CTRACE((tfp,
	    "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
	    value, (checked ? "on" : "off")));

    /*
     * Strip end spaces, newline is also whitespace.
     */
    if (*value) {
	cp = &value[strlen(value) - 1];
	while ((cp >= value) && (isspace(UCH(*cp)) ||
				 IsSpecialAttrChar(UCH(*cp))))
	    cp--;
	*(cp + 1) = '\0';
    }

    /*
     * Find first non space
     */
    cp = value;
    while (isspace(UCH(*cp)) ||
	   IsSpecialAttrChar(UCH(*cp)))
	cp++;
    if (HTCurSelectGroupType == F_RADIO_TYPE &&
	LYSelectPopups &&
	fields_are_numbered()) {
	/*
	 * Collapse any space between the popup option
	 * prefix and actual value.  -FM
	 */
	if ((cp1 = HText_skipOptionNumPrefix(cp)) > cp) {
	    i = 0, j = (int) (cp1 - cp);
	    while (isspace(UCH(cp1[i])) ||
		   IsSpecialAttrChar(UCH(cp1[i]))) {
		i++;
	    }
	    if (i > 0) {
		while (cp1[i] != '\0')
		    cp[j++] = cp1[i++];
		cp[j] = '\0';
	    }
	}
    }

    if (HTCurSelectGroupType == F_CHECKBOX_TYPE) {
	StrAllocCopy(text->last_anchor->input_field->value, cp);
	text->last_anchor->input_field->value_cs = val_cs;
	/*
	 * Put the text on the screen as well.
	 */
	HText_appendText(text, cp);

    } else if (LYSelectPopups == FALSE) {
	StrAllocCopy(text->last_anchor->input_field->value,
		     (submit_value ? submit_value : cp));
	text->last_anchor->input_field->value_cs = (submit_value ?
						    submit_val_cs : val_cs);
	/*
	 * Put the text on the screen as well.
	 */
	HText_appendText(text, cp);

    } else {
	/*
	 * Create a linked list of option values.
	 */
	OptionType *op_ptr = text->last_anchor->input_field->select_list;
	OptionType *new_ptr = NULL;
	BOOLEAN first_option = FALSE;

	/*
	 * Deal with newlines or tabs.
	 */
	LYReduceBlanks(value);

	if (!op_ptr) {
	    /*
	     * No option items yet.
	     */
	    if (text->last_anchor->input_field->type != F_OPTION_LIST_TYPE) {
		CTRACE((tfp,
			"HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			F_OPTION_LIST_TYPE));
		CTRACE((tfp, "                          but %d, ignoring!\n",
			text->last_anchor->input_field->type));
		return NULL;
	    }

	    new_ptr = typecalloc(OptionType);
	    if (new_ptr == NULL)
		outofmem(__FILE__, "HText_setLastOptionValue");

	    text->last_anchor->input_field->select_list = new_ptr;
	    first_option = TRUE;
	} else {
	    while (op_ptr->next) {
		number++;
		op_ptr = op_ptr->next;
	    }
	    number++;		/* add one more */

	    op_ptr->next = new_ptr = typecalloc(OptionType);
	    if (new_ptr == NULL)
		outofmem(__FILE__, "HText_setLastOptionValue");
	}

	assert(new_ptr != NULL);
	new_ptr->name = NULL;
	new_ptr->cp_submit_value = NULL;
	new_ptr->next = NULL;
	/*
	 * Find first non-space again, convert_to_spaces above may have
	 * changed the string.  - kw
	 */
	cp = value;
	while (isspace(UCH(*cp)) ||
	       IsSpecialAttrChar(UCH(*cp)))
	    cp++;
	for (i = 0, j = 0; cp[i]; i++) {
	    if (cp[i] == HT_NON_BREAK_SPACE ||
		cp[i] == HT_EN_SPACE) {
		cp[j++] = ' ';
	    } else if (cp[i] != LY_SOFT_HYPHEN &&
		       !IsSpecialAttrChar(UCH(cp[i]))) {
		cp[j++] = cp[i];
	    }
	}
	cp[j] = '\0';
	if (IS_CJK_TTY) {
	    if ((tmp = typecallocn(unsigned char, strlen(cp) * 2 + 1)) != 0) {
		if (kanji_code == EUC) {
		    TO_EUC((unsigned char *) cp, tmp);
		    val_cs = current_char_set;
		} else if (kanji_code == SJIS) {
		    TO_SJIS((unsigned char *) cp, tmp);
		    val_cs = current_char_set;
		} else {
		    for (i = 0, j = 0; cp[i]; i++) {
			if (cp[i] != CH_ESC) {	/* S/390 -- gil -- 1604 */
			    tmp[j++] = UCH(cp[i]);
			}
		    }
		}
		StrAllocCopy(new_ptr->name, (const char *) tmp);
		FREE(tmp);
	    } else {
		outofmem(__FILE__, "HText_setLastOptionValue");
	    }
	} else {
	    StrAllocCopy(new_ptr->name, cp);
	}
	StrAllocCopy(new_ptr->cp_submit_value,
		     (submit_value ? submit_value :
		      HText_skipOptionNumPrefix(new_ptr->name)));
	new_ptr->value_cs = (submit_value ? submit_val_cs : val_cs);

	if (first_option) {
	    FormInfo *last_input = text->last_anchor->input_field;

	    StrAllocCopy(HTCurSelectedOptionValue, new_ptr->name);
	    last_input->num_value = 0;
	    /*
	     * If this is the first option in a popup select list,
	     * HText_beginInput may have allocated the value and
	     * cp_submit_value fields, so free them now to avoid
	     * a memory leak.  - kw
	     */
	    FREE(last_input->value);
	    FREE(last_input->cp_submit_value);

	    last_input->value = last_input->select_list->name;
	    last_input->orig_value = last_input->select_list->name;
	    last_input->cp_submit_value = last_input->select_list->cp_submit_value;
	    last_input->orig_submit_value = last_input->select_list->cp_submit_value;
	    last_input->value_cs = new_ptr->value_cs;
	} else {
	    int newlen = (int) strlen(new_ptr->name);
	    int curlen = (int) (HTCurSelectedOptionValue
				? strlen(HTCurSelectedOptionValue)
				: 0);

	    /*
	     * Make the selected Option Value as long as
	     * the longest option.
	     */
	    if (newlen > curlen)
		StrAllocCat(HTCurSelectedOptionValue,
			    UNDERSCORES(newlen - curlen));
	}

	if (checked) {
	    int curlen = (int) strlen(new_ptr->name);
	    int newlen = (HTCurSelectedOptionValue
			  ? (int) strlen(HTCurSelectedOptionValue)
			  : 0);
	    FormInfo *last_input = text->last_anchor->input_field;

	    /*
	     * Set the default option as this one.
	     */
	    last_input->num_value = number;
	    last_input->value = new_ptr->name;
	    last_input->orig_value = new_ptr->name;
	    last_input->cp_submit_value = new_ptr->cp_submit_value;
	    last_input->orig_submit_value = new_ptr->cp_submit_value;
	    last_input->value_cs = new_ptr->value_cs;
	    StrAllocCopy(HTCurSelectedOptionValue, new_ptr->name);
	    if (newlen > curlen)
		StrAllocCat(HTCurSelectedOptionValue,
			    UNDERSCORES(newlen - curlen));
	}

	/*
	 * Return the selected Option value to be sent to the screen.
	 */
	if (order == LAST_ORDER) {
	    /*
	     * Change the value.
	     */
	    if (HTCurSelectedOptionValue == 0)
		StrAllocCopy(HTCurSelectedOptionValue, "");
	    text->last_anchor->input_field->size =
		(int) strlen(HTCurSelectedOptionValue);
	    ret_Value = HTCurSelectedOptionValue;
	}
    }

    if (TRACE) {
	CTRACE((tfp, "HText_setLastOptionValue:%s value=\"%s\"\n",
		(order == LAST_ORDER) ? " LAST_ORDER" : "",
		value));
	CTRACE((tfp, "            val_cs=%d \"%s\"",
		val_cs,
		(val_cs >= 0 ?
		 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
	if (submit_value) {
	    CTRACE((tfp, " (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n",
		    submit_val_cs,
		    (submit_val_cs >= 0 ?
		     LYCharSet_UC[submit_val_cs].MIMEname : "<UNKNOWN>"),
		    (HTCurSelectGroupType == F_CHECKBOX_TYPE) ?
		    "(ignored)" : "",
		    submit_value));
	} else {
	    CTRACE((tfp, "\n"));
	}
    }
    return (ret_Value);
}

/*
 * Assign a form input anchor.
 * Returns the number of characters to leave
 * blank so that the input field can fit.
 */
int HText_beginInput(HText *text,
		     int underline,
		     InputFieldData * I)
{
    TextAnchor *a;
    FormInfo *f;
    const char *cp_option = NULL;
    char *IValue = NULL;
    unsigned char *tmp = NULL;
    int i, j;
    int adjust_marker = 0;
    int MaximumSize;
    char marker[16];

    CTRACE((tfp, "GridText: Entering HText_beginInput type=%s\n", NonNull(I->type)));

    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || f == NULL)
	outofmem(__FILE__, "HText_beginInput");

    assert(a != NULL);
    assert(f != NULL);

    a->sgml_offset = SGML_offset();
    a->inUnderline = (BOOLEAN) underline;
    a->line_num = text->Lines;
    a->line_pos = (short) text->last_line->size;

    /*
     * If this is a radio button, or an OPTION we're converting
     * to a radio button, and it's the first with this name, make
     * sure it's checked by default.  Otherwise, if it's checked,
     * uncheck the default or any preceding radio button with this
     * name that was checked.  -FM
     */
    if (I->type != NULL && !strcmp(I->type, "OPTION") &&
	HTCurSelectGroupType == F_RADIO_TYPE && LYSelectPopups == FALSE) {
	I->type = "RADIO";
	I->name = HTCurSelectGroup;
	I->name_cs = HTCurSelectGroupCharset;
    }
    if (I->name && I->type && !strcasecomp(I->type, "radio")) {
	if (!text->last_anchor) {
	    I->checked = TRUE;
	} else {
	    TextAnchor *b;
	    int i2 = 0;

	    for (b = text->first_anchor; b != NULL; b = b->next) {
		if (b->link_type == INPUT_ANCHOR &&
		    b->input_field->type == F_RADIO_TYPE &&
		    b->input_field->number == HTFormNumber) {
		    if (!strcmp(b->input_field->name, I->name)) {
			if (I->checked && b->input_field->num_value) {
			    b->input_field->num_value = 0;
			    StrAllocCopy(b->input_field->orig_value, "0");
			    break;
			}
			i2++;
		    }
		}
	    }
	    if (i2 == 0)
		I->checked = TRUE;
	}
    }

    a->next = 0;
    a->anchor = NULL;
    a->link_type = INPUT_ANCHOR;
    a->show_anchor = YES;

    LYClearHiText(a);
    a->extent = 2;

    a->input_field = f;

    f->select_list = 0;
    f->number = HTFormNumber;
    f->disabled = HTFormDisabled || I->disabled;
    f->readonly = I->readonly;
    f->no_cache = NO;

    HTFormFields++;

    /*
     * Set up VALUE.
     */
    if (I->value)
	StrAllocCopy(IValue, I->value);
    if (IValue &&
	IS_CJK_TTY &&
	((I->type == NULL) || strcasecomp(I->type, "hidden"))) {
	if ((tmp = typecallocn(unsigned char, strlen(IValue) * 2 + 1)) != 0) {
	    if (kanji_code == EUC) {
		TO_EUC((unsigned char *) IValue, tmp);
		I->value_cs = current_char_set;
	    } else if (kanji_code == SJIS) {
		TO_SJIS((unsigned char *) IValue, tmp);
		I->value_cs = current_char_set;
	    } else {
		for (i = 0, j = 0; IValue[i]; i++) {
		    if (IValue[i] != CH_ESC) {	/* S/390 -- gil -- 1621 */
			tmp[j++] = UCH(IValue[i]);
		    }
		}
	    }
	    StrAllocCopy(IValue, (const char *) tmp);
	    FREE(tmp);
	}
    }

    /*
     * Special case of OPTION.
     * Is handled above if radio type and LYSelectPopups is FALSE.
     */
    /* set the values and let the parsing below do the work */
    if (I->type != NULL && !strcmp(I->type, "OPTION")) {
	cp_option = I->type;
	if (HTCurSelectGroupType == F_RADIO_TYPE)
	    I->type = "OPTION_LIST";
	else
	    I->type = "CHECKBOX";
	I->name = HTCurSelectGroup;
	I->name_cs = HTCurSelectGroupCharset;

	/*
	 * The option's size parameter actually gives the length and not
	 * the width of the list.  Perform the conversion here
	 * and get rid of the allocated HTCurSelect....
	 * 0 is ok as it means any length (arbitrary decision).
	 */
	if (HTCurSelectGroupSize != NULL) {
	    f->size_l = atoi(HTCurSelectGroupSize);
	    FREE(HTCurSelectGroupSize);
	}
    }

    /*
     * Set SIZE.
     */
    if (I->size != 0) {
	f->size = I->size;
	/*
	 * Leave at zero for option lists.
	 */
	if (f->size == 0 && cp_option == NULL) {
	    f->size = 20;	/* default */
	}
    } else {
	f->size = 20;		/* default */
    }

    /*
     * Set MAXLENGTH.
     */
    if (I->maxlength != NULL) {
	f->maxlength = (unsigned) atoi(I->maxlength);
    } else {
	f->maxlength = 0;	/* 0 means infinite */
    }

    /*
     * Set CHECKED
     * (num_value is only relevant to check and radio types).
     */
    if (I->checked == TRUE)
	f->num_value = 1;
    else
	f->num_value = 0;

    /*
     * Set TYPE.
     */
    if (I->type != NULL) {
	if (!strcasecomp(I->type, "password")) {
	    f->type = F_PASSWORD_TYPE;
	} else if (!strcasecomp(I->type, "checkbox")) {
	    f->type = F_CHECKBOX_TYPE;
	} else if (!strcasecomp(I->type, "radio")) {
	    f->type = F_RADIO_TYPE;
	} else if (!strcasecomp(I->type, "submit")) {
	    f->type = F_SUBMIT_TYPE;
	} else if (!strcasecomp(I->type, "image")) {
	    f->type = F_IMAGE_SUBMIT_TYPE;
	} else if (!strcasecomp(I->type, "reset")) {
	    f->type = F_RESET_TYPE;
	} else if (!strcasecomp(I->type, "OPTION_LIST")) {
	    f->type = F_OPTION_LIST_TYPE;
	} else if (!strcasecomp(I->type, "hidden")) {
	    f->type = F_HIDDEN_TYPE;
	    HTFormFields--;
	    f->size = 0;
	} else if (!strcasecomp(I->type, "textarea")) {
	    f->type = F_TEXTAREA_TYPE;
	} else if (!strcasecomp(I->type, "range")) {
	    f->type = F_RANGE_TYPE;
	} else if (!strcasecomp(I->type, "file")) {
	    f->type = F_FILE_TYPE;
	    CTRACE((tfp, "ok, got a file uploader\n"));
	} else if (!strcasecomp(I->type, "keygen")) {
	    f->type = F_KEYGEN_TYPE;
	} else if (!strcasecomp(I->type, "button")) {
	    f->type = F_BUTTON_TYPE;
	} else {
	    /*
	     * Note that TYPE="scribble" defaults to TYPE="text".  -FM
	     */
	    f->type = F_TEXT_TYPE;	/* default */
	}
    } else {
	f->type = F_TEXT_TYPE;
    }

    /*
     * Set NAME.
     */
    if (I->name != NULL) {
	StrAllocCopy(f->name, I->name);
	f->name_cs = I->name_cs;
    } else {
	if (f->type == F_RESET_TYPE ||
	    f->type == F_SUBMIT_TYPE ||
	    f->type == F_IMAGE_SUBMIT_TYPE) {
	    /*
	     * Set name to empty string.
	     */
	    StrAllocCopy(f->name, "");
	} else {
	    /*
	     * Error!  NAME must be present.
	     */
	    CTRACE((tfp,
		    "GridText: No name present in input field; not displaying\n"));
	    FREE(IValue);
	    return (0);
	}
    }

    /*
     * Add this anchor to the anchor list
     */
    if (text->last_anchor) {
	text->last_anchor->next = a;
    } else {
	text->first_anchor = a;
    }

    /*
     * Set VALUE, if it exists.  Otherwise, if it's not
     * an option list make it a zero-length string.  -FM
     */
    if (IValue != NULL) {
	/*
	 * OPTION VALUE is not actually the value to be seen but is to
	 * be sent....
	 */
	if (f->type == F_OPTION_LIST_TYPE ||
	    f->type == F_CHECKBOX_TYPE) {
	    /*
	     * Fill both with the value.  The f->value may be
	     * overwritten in HText_setLastOptionValue....
	     */
	    StrAllocCopy(f->value, IValue);
	    StrAllocCopy(f->cp_submit_value, IValue);
	} else {
	    StrAllocCopy(f->value, IValue);
	}
	f->value_cs = I->value_cs;
    } else if (f->type != F_OPTION_LIST_TYPE) {
	StrAllocCopy(f->value, "");
	/*
	 * May be an empty INPUT field.  The text entered will then
	 * probably be in the current display character set.  - kw
	 */
	f->value_cs = current_char_set;
    }

    /*
     * Run checks and fill in necessary values.
     */
    if (f->type == F_RESET_TYPE) {
	if (non_empty(f->value)) {
	    f->size = (int) strlen(f->value);
	} else {
	    StrAllocCopy(f->value, "Reset");
	    f->size = 5;
	}
    } else if (f->type == F_BUTTON_TYPE) {
	if (non_empty(f->value)) {
	    f->size = (int) strlen(f->value);
	} else {
	    StrAllocCopy(f->value, "BUTTON");
	    f->size = 5;
	}
    } else if (f->type == F_IMAGE_SUBMIT_TYPE ||
	       f->type == F_SUBMIT_TYPE) {
	if (non_empty(f->value)) {
	    f->size = (int) strlen(f->value);
	} else if (f->type == F_IMAGE_SUBMIT_TYPE) {
	    StrAllocCopy(f->value, "[IMAGE]-Submit");
	    f->size = 14;
	} else {
	    StrAllocCopy(f->value, "Submit");
	    f->size = 6;
	}
	addFormAction(f);
    } else if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE) {
	f->size = 3;
	if (IValue == NULL)
	    StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));

    }
    FREE(IValue);

    /*
     * Set original values.
     */
    if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE) {
	if (f->num_value)
	    StrAllocCopy(f->orig_value, "1");
	else
	    StrAllocCopy(f->orig_value, "0");
    } else if (f->type == F_OPTION_LIST_TYPE) {
	f->orig_value = NULL;
    } else {
	StrAllocCopy(f->orig_value, f->value);
    }

    /*
     * Store accept-charset if present, converting to lowercase
     * and collapsing spaces.  - kw
     */
    if (I->accept_cs) {
	StrAllocCopy(f->accept_cs, I->accept_cs);
	LYRemoveBlanks(f->accept_cs);
	LYLowerCase(f->accept_cs);
    }

    /*
     * Add numbers to form fields if needed.  - LE & FM
     */
    switch (f->type) {
	/*
	 * Do not supply number for hidden fields, nor
	 * for types that are not yet implemented.
	 */
    case F_HIDDEN_TYPE:
#ifndef USE_FILE_UPLOAD
    case F_FILE_TYPE:
#endif
    case F_RANGE_TYPE:
    case F_KEYGEN_TYPE:
    case F_BUTTON_TYPE:
	a->number = 0;
	break;

    default:
	if (fields_are_numbered())
	    a->number = ++(text->last_anchor_number);
	else
	    a->number = 0;
	break;
    }
    if (fields_are_numbered() && (a->number > 0)) {
	if (HTMainText != 0) {
	    HText_findAnchorNumber(a);
	} else {
	    a->show_number = a->number;
	}
	sprintf(marker, "[%d]", a->show_number);
	adjust_marker = (int) strlen(marker);
	if (number_fields_on_left) {
	    BOOL had_bracket = (BOOL) (f->type == F_OPTION_LIST_TYPE);

	    HText_appendText(text, had_bracket ? (marker + 1) : marker);
	    if (had_bracket)
		HText_appendCharacter(text, '[');
	}
	a->line_num = text->Lines;
	a->line_pos = (short) text->last_line->size;
    } else {
	*marker = '\0';
    }

    /*
     * Restrict SIZE to maximum allowable size.
     */
    MaximumSize = WRAP_COLS(text) + 1 - adjust_marker;
    switch (f->type) {

    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
    case F_RESET_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
	/*
	 * For submit and reset buttons, and for text entry
	 * fields and areas, we limit the size element to that
	 * of one line for the current style because that's
	 * the most we could highlight on overwrites, and/or
	 * handle in the line editor.  The actual values for
	 * text entry lines can be long, and will be scrolled
	 * horizontally within the editing window.  -FM
	 */
	MaximumSize -= (1 +
			(int) text->style->leftIndent +
			(int) text->style->rightIndent);

	/*  If we are numbering form links, place is taken by [nn]  */
	if (fields_are_numbered()) {
	    if (!number_fields_on_left
		&& f->type == F_TEXT_TYPE
		&& MaximumSize > a->line_pos + 10)
		MaximumSize -= a->line_pos;
	    else
		MaximumSize -= (int) strlen(marker);
	}

	/*
	 * Save value for submit/reset buttons so they
	 * will be visible when printing the page.  - LE
	 */
	I->value = f->value;
	break;

    default:
	/*
	 * For all other fields we limit the size element to
	 * 10 less than the screen width, because either they
	 * are types with small placeholders, and/or are a
	 * type which is handled via a popup window.  -FM
	 */
	MaximumSize -= 10;
	break;
    }

    if (MaximumSize < 1)
	MaximumSize = 1;

    if (f->size > MaximumSize)
	f->size = MaximumSize;

    /*
     * Add this anchor to the anchor list
     */
    text->last_anchor = a;

    if (HTCurrentForm) {	/* should always apply! - kw */
	if (!HTCurrentForm->first_field) {
	    HTCurrentForm->first_field = f;
	}
	HTCurrentForm->last_field = f;
	HTCurrentForm->nfields++;	/* will count hidden fields - kw */
	/*
	 * Set the no_cache flag if the METHOD is POST.  -FM
	 */
	if (HTCurrentForm->data.submit_method == URL_POST_METHOD)
	    f->no_cache = TRUE;
	/*
	 * Propagate form field's accept-charset attribute to enclosing
	 * form if the form itself didn't have an accept-charset - kw
	 */
	if (f->accept_cs && !HTCurrentForm->accept_cs) {
	    StrAllocCopy(HTCurrentForm->accept_cs, f->accept_cs);
	}
	if (!text->forms) {
	    text->forms = HTList_new();
	}
    } else {
	CTRACE((tfp, "beginInput: HTCurrentForm is missing!\n"));
    }

    CTRACE((tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
	    f->name,
	    NonNull(f->value),
	    f->size));
    CTRACE((tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
	    f->name_cs,
	    (f->name_cs >= 0 ?
	     LYCharSet_UC[f->name_cs].MIMEname : "<UNKNOWN>"),
	    I->name_cs,
	    (I->name_cs >= 0 ?
	     LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
    CTRACE((tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
	    f->value_cs,
	    (f->value_cs >= 0 ?
	     LYCharSet_UC[f->value_cs].MIMEname : "<UNKNOWN>"),
	    I->value_cs,
	    (I->value_cs >= 0 ?
	     LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));

    /*
     * Return the SIZE of the input field.
     */
    if (I->size && f->size > adjust_marker) {
	f->size -= adjust_marker;
    }
    return (f->size);
}

/*
 * If we're numbering fields on the right, do it.  Note that some fields may
 * be too long for the line - we'll lose the marker in that case rather than
 * truncate the field.
 */
void HText_endInput(HText *text)
{
    if (fields_are_numbered()
	&& !number_fields_on_left
	&& text != NULL
	&& text->last_anchor != NULL
	&& text->last_anchor->number > 0) {
	char marker[20];

	sprintf(marker, "[%d]", text->last_anchor->show_number);
	HText_appendText(text, marker);
    }
}

/*
 * Get a translation (properly:  transcoding) quality, factoring in
 * our ability to translate (an UCTQ_t) and a possible q parameter
 * on the given charset string, for cs_from -> givenmime.
 * The parsed input string will be mutilated on exit(!).
 * Note that results are not normalised to 1.0, but results from
 * different calls of this function can be compared.  - kw
 *
 * Obsolete, it was planned to use here a quality parametr UCTQ_t,
 * which is boolean now.
 */
static double get_trans_q(int cs_from,
			  char *givenmime)
{
    double df = 1.0;
    BOOL tq;
    char *p;

    if (!givenmime || !(*givenmime))
	return 0.0;
    if ((p = StrChr(givenmime, ';')) != NULL) {
	*p++ = '\0';
    }
    if (!strcmp(givenmime, "*"))
	tq = UCCanTranslateFromTo(cs_from,
				  UCGetLYhndl_byMIME("utf-8"));
    else
	tq = UCCanTranslateFromTo(cs_from,
				  UCGetLYhndl_byMIME(givenmime));
    if (!tq)
	return 0.0;
    if (non_empty(p)) {
	char *pair, *field = p, *pval, *ptok;

	/* Get all the parameters to the Charset */
	while ((pair = HTNextTok(&field, ";", "\"", NULL)) != NULL) {
	    if ((ptok = HTNextTok(&pair, "= ", NULL, NULL)) != NULL &&
		(pval = HTNextField(&pair)) != NULL) {
		if (0 == strcasecomp(ptok, "q")) {
		    df = strtod(pval, NULL);
		    break;
		}
	    }
	}
	return (df * tq);
    } else {
	return tq;
    }
}

/*
 * Find the best charset for submission, if we have an ACCEPT_CHARSET
 * list.  It factors in how well we can translate (just as guess, and
 * not a very good one..) and possible ";q=" factors.  Yes this is
 * more general than it needs to be here.
 *
 * Input is cs_in and acceptstring.
 *
 * Will return charset handle as int.
 * best_csname will point to a newly allocated MIME string for the
 * charset corresponding to the return value if return value >= 0.
 * - kw
 */
static int find_best_target_cs(char **best_csname,
			       int cs_from,
			       const char *acceptstring)
{
    char *paccept = NULL;
    double bestq = -1.0;
    char *bestmime = NULL;
    char *field, *nextfield;

    StrAllocCopy(paccept, acceptstring);
    nextfield = paccept;
    while ((field = HTNextTok(&nextfield, ",", "\"", NULL)) != NULL) {
	double q;

	if (*field != '\0') {
	    /* Get the Charset */
	    q = get_trans_q(cs_from, field);
	    if (q > bestq) {
		bestq = q;
		bestmime = field;
	    }
	}
    }
    if (bestmime) {
	if (!strcmp(bestmime, "*"))	/* non-standard for HTML attribute.. */
	    StrAllocCopy(*best_csname, "utf-8");
	else
	    StrAllocCopy(*best_csname, bestmime);
	FREE(paccept);
	if (bestq > 0)
	    return (UCGetLYhndl_byMIME(*best_csname));
	else
	    return (-1);
    }
    FREE(paccept);
    return (-1);
}

#ifdef USE_FILE_UPLOAD
static void load_a_file(const char *val_used,
			bstring **result)
{
    FILE *fd;
    size_t bytes;
    char buffer[BUFSIZ + 1];

    CTRACE((tfp, "Ok, about to convert \"%s\" to mime/thingy\n", val_used));

    if (*val_used) {		/* ignore empty form field */
	if ((fd = fopen(val_used, BIN_R)) == 0) {
	    HTAlert(gettext("Can't open file for uploading"));
	} else {
	    while ((bytes = fread(buffer, sizeof(char), BUFSIZ, fd)) != 0) {
		HTSABCat(result, buffer, (int) bytes);
	    }
	    LYCloseInput(fd);
	}
    }
}

static const char *guess_content_type(const char *filename)
{
    HTAtom *encoding;
    const char *desc;
    HTFormat format = HTFileFormat(filename, &encoding, &desc);

    return (format != 0 && non_empty(format->name))
	? format->name
	: "text/plain";
}
#endif /* USE_FILE_UPLOAD */

static void cannot_transcode(BOOL *had_warning,
			     const char *target_csname)
{
    if (*had_warning == NO) {
	*had_warning = YES;
	_user_message(CANNOT_TRANSCODE_FORM,
		      target_csname ? target_csname : "UNKNOWN");
	LYSleepAlert();
    }
}

#define SPECIAL_8BIT 1
#define SPECIAL_FORM 2

static unsigned check_form_specialchars(const char *value)
{
    unsigned result = 0;
    const char *p;

    for (p = value;
	 non_empty(p) && (result != (SPECIAL_8BIT | SPECIAL_FORM));
	 p++) {
	if ((*p == HT_NON_BREAK_SPACE) ||
	    (*p == HT_EN_SPACE) ||
	    (*p == LY_SOFT_HYPHEN)) {
	    result |= SPECIAL_FORM;
	} else if ((*p & 0x80) != 0) {
	    result |= SPECIAL_8BIT;
	}
    }
    return result;
}

/*
 * Scan the given data, adding characters to the MIME-boundary to keep it from
 * matching any part of the data.
 */
static void UpdateBoundary(char **Boundary,
			   bstring *data)
{
    size_t j;
    size_t have = strlen(*Boundary);
    size_t last = (size_t) BStrLen(data);
    char *text = BStrData(data);
    char *want = *Boundary;

    assert(want != NULL);
    assert(text != NULL);

    for (j = 0; (long) j <= (long) (last - have); ++j) {
	if (want[0] == text[j]
	    && !memcmp(want, text + j, have)) {
	    char temp[2];

	    temp[0] = (char) (isdigit(UCH(text[have + j])) ? 'a' : '0');
	    temp[1] = '\0';
	    StrAllocCat(want, temp);
	    ++have;
	}
    }
    *Boundary = want;
}

/*
 * Convert a string to base64
 */
static char *convert_to_base64(const char *src,
			       size_t len)
{
#define B64_LINE       76

    static const char basis_64[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    char *dest;
    size_t rlen;		/* length of result string */
    unsigned char c1, c2, c3;
    const char *eol;
    char *r;
    const char *str;
    size_t eollen;
    int chunk;

    str = src;
    eol = "\n";
    eollen = 1;

    /* calculate the length of the result */
    rlen = (len + 2) / 3 * 4;	/* encoded bytes */
    if (rlen) {
	/* add space for EOL */
	rlen += ((rlen - 1) / B64_LINE + 1) * eollen;
    }

    /* allocate a result buffer */
    if ((dest = (char *) malloc(rlen + 1)) == NULL) {
	outofmem(__FILE__, "convert_to_base64");
    }
    assert(dest != NULL);
    r = dest;

    /* encode */
    for (chunk = 0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE / 4)) {
	    const char *c = eol;
	    const char *e = eol + eollen;

	    while (c < e)
		*r++ = *c++;
	    chunk = 0;
	}
	c1 = UCH(*str++);
	c2 = UCH(*str++);
	*r++ = basis_64[c1 >> 2];
	*r++ = basis_64[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
	if (len > 2) {
	    c3 = UCH(*str++);
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
	    *r++ = basis_64[c3 & 0x3F];
	} else if (len == 2) {
	    *r++ = basis_64[(c2 & 0xF) << 2];
	    *r++ = '=';
	} else {		/* len == 1 */
	    *r++ = '=';
	    *r++ = '=';
	}
    }
    if (rlen) {
	/* append eol to the result string */
	const char *c = eol;
	const char *e = eol + eollen;

	while (c < e)
	    *r++ = *c++;
    }
    *r = '\0';

    return dest;
}

typedef enum {
    NO_QUOTE			/* no quoting needed */
    ,QUOTE_MULTI		/* multipart */
    ,QUOTE_BASE64		/* encode as base64 */
    ,QUOTE_SPECIAL		/* escape special characters only */
} QuoteData;

typedef struct {
    int type;			/* the type of this field */
    BOOL first;			/* true if this begins a submission part */
    char *name;			/* the name of this field */
    char *value;		/* the nominal value of this field */
    bstring *data;		/* its data, which is usually the same as the value */
    QuoteData quote;		/* how to quote/translate the data */
} PostData;

static char *escape_or_quote_name(const char *name,
				  QuoteData quoting,
				  const char *MultipartContentType)
{
    char *escaped1 = NULL;

    switch (quoting) {
    case NO_QUOTE:
	StrAllocCopy(escaped1, name);
	break;
    case QUOTE_MULTI:
    case QUOTE_BASE64:
	StrAllocCopy(escaped1, "Content-Disposition: form-data");
	HTSprintf(&escaped1, "; name=\"%s\"", name);
	if (MultipartContentType)
	    HTSprintf(&escaped1, MultipartContentType, "text/plain");
	if (quoting == QUOTE_BASE64)
	    StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
	StrAllocCat(escaped1, "\r\n\r\n");
	break;
    case QUOTE_SPECIAL:
	escaped1 = HTEscapeSP(name, URL_XALPHAS);
	break;
    }
    return escaped1;
}

static char *escape_or_quote_value(const char *value,
				   QuoteData quoting)
{
    char *escaped2 = NULL;

    switch (quoting) {
    case NO_QUOTE:
    case QUOTE_MULTI:
	StrAllocCopy(escaped2, NonNull(value));
	break;
    case QUOTE_BASE64:
	/* FIXME: this is redundant */
	escaped2 = convert_to_base64(value, strlen(value));
	break;
    case QUOTE_SPECIAL:
	escaped2 = HTEscapeSP(value, URL_XALPHAS);
	break;
    }
    return escaped2;
}

/*
 * Check if we should encode the data in base64.  We can, only if we're using
 * a multipart content type.  We should, if we're sending mail and the data
 * contains long lines or nonprinting characters.
 */
static int check_if_base64_needed(int submit_method,
				  bstring *data)
{
    int width = 0;
    BOOL printable = TRUE;
    char *text = BStrData(data);

    if (text != 0) {
	int col = 0;
	int n;
	int length = BStrLen(data);

	for (n = 0; n < length; ++n) {
	    int ch = UCH(text[n]);

	    if (is8bits(ch) || ((ch < 32 && ch != '\n'))) {
		CTRACE((tfp, "nonprintable %d:%#x\n", n, ch));
		printable = FALSE;
	    }
	    if (ch == '\n' || ch == '\r') {
		if (width < col)
		    width = col;
		col = 0;
	    } else {
		++col;
	    }
	}
	if (width < col)
	    width = col;
    }
    return !printable && ((submit_method == URL_MAIL_METHOD) && (width > 72));
}

PerFormInfo *HText_PerFormInfo(int number)
{
    return (PerFormInfo *) HTList_objectAt(HTMainText->forms, number - 1);
}

/*
 * HText_SubmitForm - generate submit data from form fields.
 * For mailto forms, send the data.
 * For other methods, set fields in structure pointed to by doc
 * appropriately for next request.
 * Returns 1 if *doc set appropriately for next request,
 * 0 otherwise.  - kw
 */
int HText_SubmitForm(FormInfo * submit_item, DocInfo *doc,
		     const char *link_name,
		     const char *link_value)
{
    BOOL had_chartrans_warning = NO;
    BOOL have_accept_cs = NO;
    BOOL success;
    BOOLEAN PlainText = FALSE;
    BOOLEAN SemiColon = FALSE;
    BOOL skip_field = FALSE;
    const char *out_csname;
    const char *target_csname = NULL;
    PerFormInfo *thisform;
    PostData *my_data = NULL;
    TextAnchor *anchor_ptr;
    bstring *my_query = NULL;
    char *Boundary = NULL;
    char *MultipartContentType = NULL;
    char *content_type_out = NULL;
    char *copied_name_used = NULL;
    char *copied_val_used = NULL;
    char *escaped1 = NULL;
    char *escaped2 = NULL;
    char *last_textarea_name = NULL;
    const char *name_used = "";
    char *previous_blanks = NULL;
    const char *val_used = "";
    int anchor_count = 0;
    int anchor_limit = 0;
    int form_number = submit_item->number;
    int result = 0;
    int target_cs = -1;
    int textarea_lineno = 0;
    unsigned form_is_special = 0;

    CTRACE((tfp, "SubmitForm\n  link_name=%s\n  link_value=%s\n", link_name, link_value));
    if (!HTMainText)
	return 0;

    thisform = HText_PerFormInfo(form_number);
    /*  Sanity check */
    if (!thisform) {
	CTRACE((tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		form_number));
    } else if (thisform->number != form_number) {
	CTRACE((tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		thisform->number, form_number));
	thisform = NULL;
    }

    if (isEmpty(submit_item->submit_action)) {
	CTRACE((tfp, "SubmitForm: no action given\n"));
	return 0;
    }

    /*
     * If we're mailing, make sure it's a mailto ACTION.  -FM
     */
    if ((submit_item->submit_method == URL_MAIL_METHOD) &&
	!isMAILTO_URL(submit_item->submit_action)) {
	HTAlert(BAD_FORM_MAILTO);
	return 0;
    }

    /*
     * Check the ENCTYPE and set up the appropriate variables.  -FM
     */
    if (submit_item->submit_enctype &&
	!strncasecomp(submit_item->submit_enctype, "text/plain", 10)) {
	/*
	 * Do not hex escape, and use physical newlines
	 * to separate name=value pairs.  -FM
	 */
	PlainText = TRUE;
    } else if (submit_item->submit_enctype &&
	       !strncasecomp(submit_item->submit_enctype,
			     "application/sgml-form-urlencoded", 32)) {
	/*
	 * Use semicolons instead of ampersands as the
	 * separators for name=value pairs.  -FM
	 */
	SemiColon = TRUE;
    } else if (submit_item->submit_enctype &&
	       !strncasecomp(submit_item->submit_enctype,
			     "multipart/form-data", 19)) {
	/*
	 * Use the multipart MIME format.  Later we will ensure it does not
	 * occur within the content.
	 */
	StrAllocCopy(Boundary, "xnyLAaB03X");
    }

    /*
     * Determine in what character encoding (aka.  charset) we should
     * submit.  We call this target_cs and the MIME name for it
     * target_csname.
     * TODO:   - actually use ACCEPT-CHARSET stuff from FORM
     * TODO:   - deal with list in ACCEPT-CHARSET, find a "best"
     *           charset to submit
     */

    /* Look at ACCEPT-CHARSET on the submitting field if we have one. */
    if (thisform && submit_item->accept_cs &&
	strcasecomp(submit_item->accept_cs, "UNKNOWN")) {
	have_accept_cs = YES;
	target_cs = find_best_target_cs(&thisform->thisacceptcs,
					current_char_set,
					submit_item->accept_cs);
    }
    /* Look at ACCEPT-CHARSET on form as a whole if submitting field
     * didn't have one. */
    if (thisform && !have_accept_cs && thisform->accept_cs &&
	strcasecomp(thisform->accept_cs, "UNKNOWN")) {
	have_accept_cs = YES;
	target_cs = find_best_target_cs(&thisform->thisacceptcs,
					current_char_set,
					thisform->accept_cs);
    }
    if (have_accept_cs && (target_cs >= 0) && thisform->thisacceptcs) {
	target_csname = thisform->thisacceptcs;
    }

    if (target_cs < 0 &&
	non_empty(HTMainText->node_anchor->charset)) {
	target_cs = UCGetLYhndl_byMIME(HTMainText->node_anchor->charset);
	if (target_cs >= 0) {
	    target_csname = HTMainText->node_anchor->charset;
	} else {
	    target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
	    target_csname = LYCharSet_UC[target_cs].MIMEname;
	}
    }
    if (target_cs < 0) {
	target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
    }

    /*
     * Go through list of anchors and get a "max." charset parameter - kw
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {

	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;

	if (anchor_ptr->input_field->number == form_number &&
	    !anchor_ptr->input_field->disabled) {

	    FormInfo *form_ptr = anchor_ptr->input_field;
	    char *val = (form_ptr->cp_submit_value != NULL
			 ? form_ptr->cp_submit_value
			 : form_ptr->value);

	    unsigned field_is_special = check_form_specialchars(val);
	    unsigned name_is_special = check_form_specialchars(form_ptr->name);

	    form_is_special = (field_is_special | name_is_special);

	    if (field_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((field_is_special & SPECIAL_8BIT) == 0
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->value_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->value_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->value_cs)) {
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
	    } else {
		target_cs = -1;	/* don't know what to do */
	    }

	    /*  Same for name */
	    if (name_is_special == 0) {
		/* already ok */
	    } else if (target_cs < 0) {
		/* already confused */
	    } else if ((name_is_special & SPECIAL_8BIT) == 0
		       && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
			   || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		/* those specials will be trivial */
	    } else if (UCNeedNotTranslate(form_ptr->name_cs, target_cs)) {
		/* already ok */
	    } else if (UCCanTranslateFromTo(form_ptr->name_cs, target_cs)) {
		/* also ok */
	    } else if (UCCanTranslateFromTo(target_cs, form_ptr->name_cs)) {
		target_cs = form_ptr->value_cs;		/* try this */
		target_csname = NULL;	/* will be set after loop */
	    } else {
		target_cs = -1;	/* don't know what to do */
	    }

	    ++anchor_limit;
	} else if (anchor_ptr->input_field->number > form_number) {
	    break;
	}
    }

    /*
     * If we have input fields (we expect this), make an array of them so we
     * can organize the data.
     */
    if (anchor_limit != 0) {
	my_data = typecallocn(PostData, (size_t) anchor_limit);
	if (my_data == 0)
	    outofmem(__FILE__, "HText_SubmitForm");
	assert(my_data != NULL);
    }

    if (target_csname == NULL) {
	if (target_cs >= 0) {
	    if ((form_is_special & SPECIAL_8BIT) != 0) {
		target_csname = LYCharSet_UC[target_cs].MIMEname;
	    } else if ((form_is_special & SPECIAL_FORM) != 0) {
		target_csname = LYCharSet_UC[target_cs].MIMEname;
	    } else {
		target_csname = "us-ascii";
	    }
	} else {
	    target_csname = "us-ascii";
	    target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
	}
    } else if (target_cs < 0) {
	target_cs = UCLYhndl_for_unspec;	/* always >= 0 */
    }

    if (submit_item->submit_method == URL_GET_METHOD && Boundary == NULL) {
	char *temp = NULL;

	StrAllocCopy(temp, submit_item->submit_action);
	/*
	 * Method is GET.  Clip out any anchor in the current URL.
	 */
	strtok(temp, "#");
	/*
	 * Clip out any old query in the current URL.
	 */
	strtok(temp, "?");
	/*
	 * Add the lead question mark for the new URL.
	 */
	StrAllocCat(temp, "?");
	BStrCat0(my_query, temp);
	free(temp);
    } else {
	/*
	 * We are submitting POST content to a server,
	 * so load content_type_out.  This will be put in
	 * the post_content_type element if all goes well.  -FM, kw
	 */
	if (SemiColon == TRUE) {
	    StrAllocCopy(content_type_out,
			 "application/sgml-form-urlencoded");
	} else if (PlainText == TRUE) {
	    StrAllocCopy(content_type_out,
			 "text/plain");
	} else if (Boundary != NULL) {
	    StrAllocCopy(content_type_out,
			 "multipart/form-data");
	} else {
	    StrAllocCopy(content_type_out,
			 "application/x-www-form-urlencoded");
	}

	/*
	 * If the ENCTYPE is not multipart/form-data, append the
	 * charset we'll be sending to the post_content_type, IF
	 *  (1) there was an explicit accept-charset attribute, OR
	 *  (2) we have 8-bit or special chars, AND the document had
	 *      an explicit (recognized and accepted) charset parameter,
	 *      AND it or target_csname is different from iso-8859-1,
	 *      OR
	 *  (3) we have 8-bit or special chars, AND the document had
	 *      no explicit (recognized and accepted) charset parameter,
	 *      AND target_cs is different from the currently effective
	 *      assumed charset (which should have been set by the user
	 *      so that it reflects what the server is sending, if the
	 *      document is rendered correctly).
	 * For multipart/form-data the equivalent will be done later,
	 * separately for each form field.  - kw
	 */
	if (have_accept_cs
	    || ((form_is_special & SPECIAL_8BIT) != 0
		|| (form_is_special & SPECIAL_FORM) != 0)) {
	    if (target_cs >= 0 && target_csname) {
		if (Boundary == NULL) {
		    if ((HTMainText->node_anchor->charset &&
			 (strcmp(HTMainText->node_anchor->charset,
				 "iso-8859-1") ||
			  strcmp(target_csname, "iso-8859-1"))) ||
			(!HTMainText->node_anchor->charset &&
			 target_cs != UCLYhndl_for_unspec)) {
			HTSprintf(&content_type_out, "; charset=%s", target_csname);
		    }
		}
	    } else {
		cannot_transcode(&had_chartrans_warning, target_csname);
	    }
	}
    }

    out_csname = target_csname;

    /*
     * Build up a list of the input fields and their associated values.
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {

	if (anchor_ptr->link_type != INPUT_ANCHOR)
	    continue;

	if (anchor_ptr->input_field->number == form_number &&
	    !anchor_ptr->input_field->disabled) {

	    FormInfo *form_ptr = anchor_ptr->input_field;
	    int out_cs;
	    QuoteData quoting = (PlainText
				 ? NO_QUOTE
				 : (Boundary
				    ? QUOTE_MULTI
				    : QUOTE_SPECIAL));

	    assert(my_data != NULL);

	    if (form_ptr->type != F_TEXTAREA_TYPE)
		textarea_lineno = 0;

	    CTRACE((tfp, "SubmitForm[%d/%d]: ",
		    anchor_count + 1, anchor_limit));

	    name_used = NonNull(form_ptr->name);

	    switch (form_ptr->type) {
	    case F_RESET_TYPE:
		CTRACE((tfp, "reset\n"));
		break;
#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		val_used = NonNull(form_ptr->value);
		CTRACE((tfp, "I will submit \"%s\" (from %s)\n",
			val_used, name_used));
		break;
#endif
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if (!(non_empty(form_ptr->name) &&
		      !strcmp(form_ptr->name, link_name))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s.\n",
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    non_empty(form_ptr->name) ?
			    "not current link" : "no field name"));
		    break;
		}
		if (!(form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		      (non_empty(form_ptr->value) &&
		       !strcmp(form_ptr->value, link_value)))) {
		    CTRACE((tfp, "skipping submit field with "));
		    CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s!\n",
			    form_ptr->name ? form_ptr->name : "???",
			    link_name ? link_name : "???",
			    "values are different"));
		    break;
		}
		/* FALLTHRU */
	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
	    case F_TEXTAREA_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		/*
		 * Be sure to actually look at the option submit value.
		 */
		if (form_ptr->cp_submit_value != NULL) {
		    val_used = form_ptr->cp_submit_value;
		} else {
		    val_used = form_ptr->value;
		}

		/*
		 * Charset-translate value now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (check_form_specialchars(val_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_val_used, val_used);
		    success = FALSE;
		    if (HTCJK == JAPANESE) {
			if ((0 <= target_cs) &&
			    !strcmp(LYCharSet_UC[target_cs].MIMEname, "euc-jp")) {
			    TO_EUC((const unsigned char *) val_used,
				   (unsigned char *) copied_val_used);
			    success = YES;
			} else if ((0 <= target_cs) &&
				   !strcmp(LYCharSet_UC[target_cs].MIMEname,
					   "shift_jis")) {
			    TO_SJIS((const unsigned char *) val_used,
				    (unsigned char *) copied_val_used);
			    success = YES;
			}
		    }
		    if (!success) {
			success = LYUCTranslateBackFormData(&copied_val_used,
							    form_ptr->value_cs,
							    target_cs, PlainText);
		    }
		    CTRACE((tfp, "field \"%s\" %d %s -> %d %s %s\n",
			    NonNull(form_ptr->name),
			    form_ptr->value_cs,
			    ((form_ptr->value_cs >= 0)
			     ? LYCharSet_UC[form_ptr->value_cs].MIMEname
			     : "???"),
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
		    if (success) {
			val_used = copied_val_used;
		    }
		} else {	/* We can use the value directly. */
		    CTRACE((tfp, "field \"%s\" %d %s OK\n",
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
		    success = YES;
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		    out_cs = form_ptr->value_cs;
		} else {
		    out_cs = target_cs;
		}
		if (out_cs >= 0)
		    out_csname = LYCharSet_UC[out_cs].MIMEname;
		if (Boundary) {
		    StrAllocCopy(MultipartContentType,
				 "\r\nContent-Type: %s");
		    if (!success && form_ptr->value_cs < 0) {
			/*  This is weird. */
			out_csname = "UNKNOWN-8BIT";
		    } else if (!success) {
			target_csname = NULL;
		    } else {
			if (!target_csname) {
			    target_csname = LYCharSet_UC[target_cs].MIMEname;
			}
		    }
		    if (strcmp(out_csname, "iso-8859-1"))
			HTSprintf(&MultipartContentType, "; charset=%s", out_csname);
		}

		/*
		 * Charset-translate name now, because we need to know the
		 * charset parameter for multipart bodyparts.  - kw
		 */
		if (form_ptr->type == F_TEXTAREA_TYPE) {
		    textarea_lineno++;
		    if (textarea_lineno > 1 &&
			last_textarea_name && form_ptr->name &&
			!strcmp(last_textarea_name, form_ptr->name)) {
			break;
		    }
		}

		if (check_form_specialchars(name_used) != 0) {
		    /*  We should translate back. */
		    StrAllocCopy(copied_name_used, name_used);
		    success = LYUCTranslateBackFormData(&copied_name_used,
							form_ptr->name_cs,
							target_cs, PlainText);
		    CTRACE((tfp, "name \"%s\" %d %s -> %d %s %s\n",
			    NonNull(form_ptr->name),
			    form_ptr->name_cs,
			    ((form_ptr->name_cs >= 0)
			     ? LYCharSet_UC[form_ptr->name_cs].MIMEname
			     : "???"),
			    target_cs,
			    target_csname ? target_csname : "???",
			    success ? "OK" : "FAILED"));
		    if (success) {
			name_used = copied_name_used;
		    }
		    if (Boundary) {
			if (!success) {
			    StrAllocCopy(MultipartContentType, "");
			    target_csname = NULL;
			} else {
			    if (!target_csname)
				target_csname = LYCharSet_UC[target_cs].MIMEname;
			}
		    }
		} else {	/* We can use the name directly. */
		    CTRACE((tfp, "name \"%s\" %d %s OK\n",
			    NonNull(form_ptr->name),
			    target_cs,
			    target_csname ? target_csname : "???"));
		    success = YES;
		    if (Boundary) {
			StrAllocCopy(copied_name_used, name_used);
		    }
		}
		if (!success) {
		    cannot_transcode(&had_chartrans_warning, target_csname);
		}
		if (Boundary) {
		    /*
		     * According to RFC 1867, Non-ASCII field names
		     * "should be encoded according to the prescriptions
		     * of RFC 1522 [...].  I don't think RFC 1522 actually
		     * is meant to apply to parameters like this, and it
		     * is unknown whether any server would make sense of
		     * it, so for now just use some quoting/escaping and
		     * otherwise leave 8-bit values as they are.
		     * Non-ASCII characters in form field names submitted
		     * as multipart/form-data can only occur if the form
		     * provider specifically asked for it anyway.  - kw
		     */
		    HTMake822Word(&copied_name_used, FALSE);
		    name_used = copied_name_used;
		}

		break;
	    default:
		CTRACE((tfp, "What type is %d?\n", form_ptr->type));
		break;
	    }

	    skip_field = FALSE;
	    my_data[anchor_count].first = TRUE;
	    my_data[anchor_count].type = form_ptr->type;

	    /*
	     * Using the values of 'name_used' and 'val_used' computed in the
	     * previous case-statement, compute the 'first' and 'data' values
	     * for the current input field.
	     */
	    switch (form_ptr->type) {

	    default:
		skip_field = TRUE;
		break;

#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		load_a_file(val_used, &(my_data[anchor_count].data));
		break;
#endif /* USE_FILE_UPLOAD */

	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		if ((non_empty(form_ptr->name) &&
		     !strcmp(form_ptr->name, link_name)) &&
		    (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		     (non_empty(form_ptr->value) &&
		      !strcmp(form_ptr->value, link_value)))) {
		    ;
		} else {
		    skip_field = TRUE;
		}
		break;

	    case F_RADIO_TYPE:
	    case F_CHECKBOX_TYPE:
		/*
		 * Only add if selected.
		 */
		if (form_ptr->num_value) {
		    ;
		} else {
		    skip_field = TRUE;
		}
		break;

	    case F_TEXTAREA_TYPE:
		if (!last_textarea_name ||
		    strcmp(last_textarea_name, form_ptr->name)) {
		    textarea_lineno = 1;
		    last_textarea_name = form_ptr->name;
		} else {
		    my_data[anchor_count].first = FALSE;
		}
		break;

	    case F_PASSWORD_TYPE:
	    case F_TEXT_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		break;
	    }

	    /*
	     * If we did not decide to skip the current field, populate the
	     * values in the array for it.
	     */
	    if (!skip_field) {
		StrAllocCopy(my_data[anchor_count].name, name_used);
		StrAllocCopy(my_data[anchor_count].value, val_used);
		if (my_data[anchor_count].data == 0)
		    BStrCat0(my_data[anchor_count].data, val_used);
		my_data[anchor_count].quote = quoting;
		if (quoting == QUOTE_MULTI
		    && check_if_base64_needed(submit_item->submit_method,
					      my_data[anchor_count].data)) {
		    CTRACE((tfp, "will encode as base64\n"));
		    my_data[anchor_count].quote = QUOTE_BASE64;
		    escaped2 =
			convert_to_base64(BStrData(my_data[anchor_count].data),
					  (size_t)
					  BStrLen(my_data[anchor_count].data));
		    BStrCopy0(my_data[anchor_count].data, escaped2);
		    FREE(escaped2);
		}
	    }
	    ++anchor_count;

	    FREE(copied_name_used);
	    FREE(copied_val_used);

	} else if (anchor_ptr->input_field->number > form_number) {
	    break;
	}
    }

    FREE(copied_name_used);

    if (my_data != 0) {
	BOOL first_one = TRUE;

	/*
	 * If we're using a MIME-boundary, make it unique.
	 */
	if (content_type_out != 0 && Boundary != 0) {
	    Boundary = 0;
	    StrAllocCopy(Boundary, "LYNX");
	    for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
		if (my_data[anchor_count].data != 0) {
		    UpdateBoundary(&Boundary, my_data[anchor_count].data);
		}
	    }
	    HTSprintf(&content_type_out, "; boundary=%s", Boundary);
	}

	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {

	    if (my_data[anchor_count].name != 0
		&& my_data[anchor_count].value != 0) {

		CTRACE((tfp,
			"processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
			anchor_count + 1,
			anchor_limit,
			NonNull(my_data[anchor_count].name),
			my_data[anchor_count].first,
			NonNull(my_data[anchor_count].value),
			(void *) my_data[anchor_count].data));

		if (my_data[anchor_count].first) {
		    if (first_one) {
			if (Boundary) {
			    HTBprintf(&my_query, "--%s\r\n", Boundary);
			}
			first_one = FALSE;
		    } else {
			if (PlainText) {
			    BStrCat0(my_query, "\n");
			} else if (SemiColon) {
			    BStrCat0(my_query, ";");
			} else if (Boundary) {
			    HTBprintf(&my_query, "\r\n--%s\r\n", Boundary);
			} else {
			    BStrCat0(my_query, "&");
			}
		    }
		}

		/* append a null to the string */
		HTSABCat(&(my_data[anchor_count].data), "", 1);
		name_used = my_data[anchor_count].name;
		val_used = my_data[anchor_count].value;

	    } else {
		/* there is no data to send */
		continue;
	    }

	    switch (my_data[anchor_count].type) {
	    case F_TEXT_TYPE:
	    case F_PASSWORD_TYPE:
	    case F_OPTION_LIST_TYPE:
	    case F_HIDDEN_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_CHECKBOX_TYPE:
	    case F_RADIO_TYPE:
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		HTBprintf(&my_query,
			  "%s%s%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""),
			  escaped2,
			  ((PlainText && *escaped2) ? "\n" : ""));
		break;
	    case F_SUBMIT_TYPE:
	    case F_TEXT_SUBMIT_TYPE:
	    case F_IMAGE_SUBMIT_TYPE:
		/*
		 * If it has a non-zero length name (e.g., because
		 * its IMAGE_SUBMIT_TYPE is to be handled homologously
		 * to an image map, or a SUBMIT_TYPE in a set of
		 * multiple submit buttons, or a single type="text"
		 * that's been converted to a TEXT_SUBMIT_TYPE),
		 * include the name=value pair, or fake name.x=0 and
		 * name.y=0 pairs for IMAGE_SUBMIT_TYPE.  -FM
		 */
		escaped1 = escape_or_quote_name(my_data[anchor_count].name,
						my_data[anchor_count].quote,
						MultipartContentType);

		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		if (my_data[anchor_count].type == F_IMAGE_SUBMIT_TYPE) {
		    /*
		     * It's a clickable image submit button.  Fake a 0,0
		     * coordinate pair, which typically returns the image's
		     * default.  -FM
		     */
		    if (Boundary) {
			*(StrChr(escaped1, '=') + 1) = '\0';
			HTBprintf(&my_query,
				  "%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",
				  escaped1,
				  my_data[anchor_count].name,
				  Boundary,
				  escaped1,
				  my_data[anchor_count].name);
		    } else {
			HTBprintf(&my_query,
				  "%s.x=0%s%s.y=0%s",
				  escaped1,
				  (PlainText ?
				   "\n" : (SemiColon ?
					   ";" : "&")),
				  escaped1,
				  ((PlainText && *escaped1) ?
				   "\n" : ""));
		    }
		} else {
		    /*
		     * It's a standard submit button.  Use the name=value
		     * pair.  = FM
		     */
		    HTBprintf(&my_query,
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
		}
		break;
	    case F_RESET_TYPE:
		/* ignore */
		break;
	    case F_TEXTAREA_TYPE:
		escaped2 = escape_or_quote_value(val_used,
						 my_data[anchor_count].quote);

		if (my_data[anchor_count].first) {
		    /*
		     * Names are different so this is the first textarea or a
		     * different one from any before it.
		     */
		    if (PlainText) {
			FREE(previous_blanks);
		    } else if (Boundary) {
			StrAllocCopy(previous_blanks, "\r\n");
		    } else {
			StrAllocCopy(previous_blanks, "%0d%0a");
		    }
		    escaped1 = escape_or_quote_name(name_used,
						    my_data[anchor_count].quote,
						    MultipartContentType);

		    HTBprintf(&my_query,
			      "%s%s%s%s%s",
			      escaped1,
			      (Boundary ? "" : "="),
			      (PlainText ? "\n" : ""),
			      escaped2,
			      ((PlainText && *escaped2) ? "\n" : ""));
		} else {
		    const char *marker = (PlainText
					  ? "\n"
					  : (Boundary
					     ? "\r\n"
					     : "%0d%0a"));

		    /*
		     * This is a continuation of a previous textarea.
		     */
		    if (escaped2[0] != '\0') {
			if (previous_blanks) {
			    BStrCat0(my_query, previous_blanks);
			    FREE(previous_blanks);
			}
			BStrCat0(my_query, escaped2);
			if (PlainText || Boundary)
			    BStrCat0(my_query, marker);
			else
			    StrAllocCopy(previous_blanks, marker);
		    } else {
			StrAllocCat(previous_blanks, marker);
		    }
		}
		break;
	    case F_RANGE_TYPE:
		/* not implemented */
		break;
#ifdef USE_FILE_UPLOAD
	    case F_FILE_TYPE:
		if (PlainText) {
		    StrAllocCopy(escaped1, my_data[anchor_count].name);
		} else if (Boundary) {
		    const char *t = guess_content_type(val_used);
		    char *copied_fname = NULL;

		    StrAllocCopy(escaped1, "Content-Disposition: form-data");
		    HTSprintf(&escaped1, "; name=\"%s\"",
			      my_data[anchor_count].name);

		    StrAllocCopy(copied_fname, val_used);
		    HTMake822Word(&copied_fname, FALSE);
		    HTSprintf(&escaped1, "; filename=\"%s\"", copied_fname);
		    FREE(copied_fname);

		    /* Should we take into account the encoding? */
		    HTSprintf(&escaped1, "\r\nContent-Type: %s", t);
		    if (my_data[anchor_count].quote == QUOTE_BASE64)
			StrAllocCat(escaped1,
				    "\r\nContent-Transfer-Encoding: base64");
		    StrAllocCat(escaped1, "\r\n\r\n");
		} else {
		    escaped1 = HTEscapeSP(my_data[anchor_count].name, URL_XALPHAS);
		}

		HTBprintf(&my_query,
			  "%s%s%s",
			  escaped1,
			  (Boundary ? "" : "="),
			  (PlainText ? "\n" : ""));
		/*
		 * If we have anything more than the trailing null we added,
		 * append the file-data to the query.
		 */
		if (BStrLen(my_data[anchor_count].data) > 1) {
		    HTSABCat(&my_query,
			     BStrData(my_data[anchor_count].data),
			     BStrLen(my_data[anchor_count].data) - 1);
		    if (PlainText)
			HTBprintf(&my_query, "\n");
		}
		break;
#endif /* USE_FILE_UPLOAD */
	    case F_KEYGEN_TYPE:
	    case F_BUTTON_TYPE:
		/* not implemented */
		break;
	    }

	    FREE(escaped1);
	    FREE(escaped2);
	}
	if (Boundary) {
	    HTBprintf(&my_query, "\r\n--%s--\r\n", Boundary);
	}
	/*
	 * The data may contain a null - so we use fwrite().
	 */
	if (TRACE) {
	    CTRACE((tfp, "Query %d{", BStrLen(my_query)));
	    trace_bstring(my_query);
	    CTRACE((tfp, "}\n"));
	}
    }

    if (submit_item->submit_method == URL_MAIL_METHOD) {
	HTUserMsg2(gettext("Submitting %s"), submit_item->submit_action);
	HTSABCat(&my_query, "", 1);	/* append null */
	mailform((submit_item->submit_action + 7),
		 (isEmpty(submit_item->submit_title)
		  ? NonNull(HText_getTitle())
		  : submit_item->submit_title),
		 BStrData(my_query),
		 content_type_out);
	result = 0;
	BStrFree(my_query);
	FREE(content_type_out);
    } else {
	_statusline(SUBMITTING_FORM);

	/*
	 * File-URLs (whether via GET or POST) cannot provide search queries. 
	 * The relevant RFCs 1630, 1738 are silent on what to do with
	 * unexpected query parameters in a file-URL.
	 *
	 * Internet Explorer trims the query string here (after all, a "?" is
	 * not a legal part of a Windows filename), and other browsers copy the
	 * behavior.  We do this for compatibility, in case someone cares.
	 */
	if (my_query != 0 &&
	    my_query->len > 5 &&
	    !strncmp(my_query->str, "file:", 5)) {
	    strtok(my_query->str, "?");
	}
	if (submit_item->submit_method == URL_POST_METHOD || Boundary) {
	    LYFreePostData(doc);
	    doc->post_data = my_query;
	    doc->post_content_type = content_type_out;	/* don't free c_t_out */
	    CTRACE((tfp, "GridText - post_data set:\n%s\n", content_type_out));
	    StrAllocCopy(doc->address, submit_item->submit_action);
	} else {		/* GET_METHOD */
	    HTSABCat(&my_query, "", 1);		/* append null */
	    StrAllocCopy(doc->address, BStrData(my_query));
	    LYFreePostData(doc);
	    FREE(content_type_out);
	    HTSABFree(&my_query);
	}
	result = 1;
    }

    FREE(MultipartContentType);
    FREE(previous_blanks);
    FREE(Boundary);
    if (my_data != 0) {
	for (anchor_count = 0; anchor_count < anchor_limit; ++anchor_count) {
	    FREE(my_data[anchor_count].name);
	    FREE(my_data[anchor_count].value);
	    BStrFree(my_data[anchor_count].data);
	}
	FREE(my_data);
    }

    return (result);
}

void HText_DisableCurrentForm(void)
{
    TextAnchor *anchor_ptr;

    HTFormDisabled = TRUE;
    if (HTMainText != NULL) {
	/*
	 * Go through list of anchors and set the disabled flag.
	 */
	for (anchor_ptr = HTMainText->first_anchor;
	     anchor_ptr != NULL;
	     anchor_ptr = anchor_ptr->next) {

	    if (anchor_ptr->link_type == INPUT_ANCHOR &&
		anchor_ptr->input_field->number == HTFormNumber) {

		anchor_ptr->input_field->disabled = TRUE;
	    }
	}
    }
    return;
}

void HText_ResetForm(FormInfo * form)
{
    TextAnchor *anchor_ptr;

    _statusline(RESETTING_FORM);
    if (HTMainText == 0)
	return;

    /*
     * Go through list of anchors and reset values.
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {
	    if (anchor_ptr->input_field->number == form->number) {

		if (anchor_ptr->input_field->type == F_RADIO_TYPE ||
		    anchor_ptr->input_field->type == F_CHECKBOX_TYPE) {

		    if (anchor_ptr->input_field->orig_value[0] == '0')
			anchor_ptr->input_field->num_value = 0;
		    else
			anchor_ptr->input_field->num_value = 1;

		} else if (anchor_ptr->input_field->type ==
			   F_OPTION_LIST_TYPE) {
		    anchor_ptr->input_field->value =
			anchor_ptr->input_field->orig_value;

		    anchor_ptr->input_field->cp_submit_value =
			anchor_ptr->input_field->orig_submit_value;

		} else {
		    StrAllocCopy(anchor_ptr->input_field->value,
				 anchor_ptr->input_field->orig_value);
		}
	    } else if (anchor_ptr->input_field->number > form->number) {
		break;
	    }
	}
    }
}

/*
 * This function is called before reloading/reparsing current document to find
 * whether any forms content was changed by user so any information will be
 * lost.
 */
BOOLEAN HText_HaveUserChangedForms(HText *text)
{
    TextAnchor *anchor_ptr;

    if (text == 0)
	return FALSE;

    /*
     * Go through list of anchors to check if any value was changed.
     * This code based on HText_ResetForm()
     */
    for (anchor_ptr = text->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {

	    if (anchor_ptr->input_field->type == F_RADIO_TYPE ||
		anchor_ptr->input_field->type == F_CHECKBOX_TYPE) {

		if ((anchor_ptr->input_field->orig_value[0] == '0' &&
		     anchor_ptr->input_field->num_value == 1) ||
		    (anchor_ptr->input_field->orig_value[0] != '0' &&
		     anchor_ptr->input_field->num_value == 0))
		    return TRUE;

	    } else if (anchor_ptr->input_field->type == F_OPTION_LIST_TYPE) {
		if (strcmp(anchor_ptr->input_field->value,
			   anchor_ptr->input_field->orig_value))
		    return TRUE;

		if (strcmp(anchor_ptr->input_field->cp_submit_value,
			   anchor_ptr->input_field->orig_submit_value))
		    return TRUE;

	    } else {
		if (strcmp(anchor_ptr->input_field->value,
			   anchor_ptr->input_field->orig_value))
		    return TRUE;
	    }
	}
    }
    return FALSE;
}

void HText_activateRadioButton(FormInfo * form)
{
    TextAnchor *anchor_ptr;
    int form_number = form->number;

    if (!HTMainText)
	return;
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR &&
	    anchor_ptr->input_field->type == F_RADIO_TYPE) {

	    if (anchor_ptr->input_field->number == form_number) {

		/* if it has the same name and its on */
		if (!strcmp(anchor_ptr->input_field->name, form->name) &&
		    anchor_ptr->input_field->num_value) {
		    anchor_ptr->input_field->num_value = 0;
		    break;
		}
	    } else if (anchor_ptr->input_field->number > form_number) {
		break;
	    }

	}
    }

    form->num_value = 1;
}

#ifdef LY_FIND_LEAKS
/*
 *	Purpose:	Free all currently loaded HText objects in memory.
 *	Arguments:	void
 *	Return Value:	void
 *	Remarks/Portability/Dependencies/Restrictions:
 *		Usage of this function should really be limited to program
 *			termination.
 *	Revision History:
 *		05-27-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void free_all_texts(void)
{
    HText *cur = NULL;

    if (!loaded_texts)
	return;

    /*
     * Simply loop through the loaded texts list killing them off.
     */
    while (loaded_texts && !HTList_isEmpty(loaded_texts)) {
	if ((cur = (HText *) HTList_removeLastObject(loaded_texts)) != NULL) {
	    HText_free(cur);
	}
    }

    /*
     * Get rid of the text list.
     */
    if (loaded_texts) {
	HTList_delete(loaded_texts);
    }

    /*
     * Insurance for bad HTML.
     */
    FREE(HTCurSelectGroup);
    FREE(HTCurSelectGroupSize);
    FREE(HTCurSelectedOptionValue);
    PerFormInfo_free(HTCurrentForm);

    return;
}
#endif /* LY_FIND_LEAKS */

/*
 *  stub_HTAnchor_address is like HTAnchor_address, but it returns the
 *  parent address for child links.  This is only useful for traversal's
 *  where one does not want to index a text file N times, once for each
 *  of N internal links.  Since the parent link has already been taken,
 *  it won't go again, hence the (incorrect) links won't cause problems.
 */
char *stub_HTAnchor_address(HTAnchor * me)
{
    char *addr = NULL;

    if (me)
	StrAllocCopy(addr, me->parent->address);
    return addr;
}

void HText_setToolbar(HText *text)
{
    if (text)
	text->toolbar = TRUE;
    return;
}

BOOL HText_hasToolbar(HText *text)
{
    return (BOOL) ((text && text->toolbar) ? TRUE : FALSE);
}

void HText_setNoCache(HText *text)
{
    if (text)
	text->no_cache = TRUE;
    return;
}

BOOL HText_hasNoCacheSet(HText *text)
{
    return (BOOL) ((text && text->no_cache) ? TRUE : FALSE);
}

BOOL HText_hasUTF8OutputSet(HText *text)
{
    return (BOOL) ((text && text->T.output_utf8) ? TRUE : FALSE);
}

/*
 *  Check charset and set the kcode element. -FM
 *  Info on the input charset may be passed in in two forms,
 *  as a string (if given explicitly) and as a pointer to
 *  a LYUCcharset (from chartrans mechanism); either can be NULL.
 *  For Japanese the kcode will be reset at a space or explicit
 *  line or paragraph break, so what we set here may not last for
 *  long.  It's potentially more important not to set HTCJK to
 *  NOCJK unless we are sure. - kw
 */
void HText_setKcode(HText *text, const char *charset,
		    LYUCcharset *p_in)
{
    BOOL charset_explicit;

    if (!text)
	return;

    /*
     * Check whether we have some kind of info.  - kw
     */
    if (!charset && !p_in) {
	return;
    }
    charset_explicit = (BOOLEAN) (charset ? TRUE : FALSE);
    /*
     * If no explicit charset string, use the implied one.  - kw
     */
    if (isEmpty(charset)) {
	charset = p_in->MIMEname;
    }
    /*
     * Check whether we have a specified charset.  -FM
     */
    if (isEmpty(charset)) {
	return;
    }

    /*
     * We've included the charset, and not forced a download offer,
     * only if the currently selected character set can handle it,
     * so check the charset value and set the text->kcode element
     * appropriately.  -FM
     */
    /*  If charset isn't specified explicitely nor assumed,
     * p_in->MIMEname would be set as display charset.
     * So text->kcode sholud be set as SJIS or EUC here only if charset
     * is specified explicitely, otherwise text->kcode would cause
     * mishandling Japanese strings.  -- TH
     */
    if (charset_explicit && (!strcmp(charset, "shift_jis") ||
			     !strcmp(charset, "x-sjis") ||	/* 1997/11/28 (Fri) 18:11:33 */
			     !strcmp(charset, "x-shift-jis"))) {
	text->kcode = SJIS;
    } else if (charset_explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	       && strcmp(charset, "utf-8")
#endif
	       && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
		   !strcmp(charset, "x-euc") ||		/* 1997/11/28 (Fri) 18:11:24 */
		   !strcmp(charset, "euc-jp") ||
		   !StrNCmp(charset, "x-euc-", 6) ||
		   !strcmp(charset, "euc-kr") ||
		   !strcmp(charset, "iso-2022-kr") ||
		   !strcmp(charset, "big5") ||
		   !strcmp(charset, "cn-big5") ||
		   !strcmp(charset, "euc-cn") ||
		   !strcmp(charset, "gb2312") ||
		   !StrNCmp(charset, "cn-gb", 5) ||
		   !strcmp(charset, "iso-2022-cn"))) {
	text->kcode = EUC;
    } else {
	/*
	 * If we get to here, it's not CJK, so disable that if
	 * it is enabled.  But only if we are quite sure.  -FM & kw
	 */
	text->kcode = NOKANJI;
	if (IS_CJK_TTY) {
	    if (!p_in || ((p_in->enc != UCT_ENC_CJK)
#ifdef EXP_JAPANESEUTF8_SUPPORT
			  && (p_in->enc != UCT_ENC_UTF8)
#endif
		)) {
		HTCJK = NOCJK;
	    }
	}
    }

    if (charset_explicit
#ifdef EXP_JAPANESEUTF8_SUPPORT
	&& strcmp(charset, "utf-8")
#endif
	) {
	text->specified_kcode = text->kcode;
    } else {
	if (UCAssume_MIMEcharset) {
	    if (!strcmp(UCAssume_MIMEcharset, "euc-jp"))
		text->kcode = text->specified_kcode = EUC;
	    else if (!strcmp(UCAssume_MIMEcharset, "shift_jis"))
		text->kcode = text->specified_kcode = SJIS;
	}
    }

    return;
}

/*
 *  Set a permissible split at the current end of the last line. -FM
 */
void HText_setBreakPoint(HText *text)
{
    if (!text)
	return;

    /*
     * Can split here.  -FM
     */
    text->permissible_split = text->last_line->size;

    return;
}

/*
 *  This function determines whether a document which
 *  would be sought via the a URL that has a fragment
 *  directive appended is otherwise identical to the
 *  currently loaded document, and if so, returns
 *  FALSE, so that any no_cache directives can be
 *  overridden "safely", on the grounds that we are
 *  simply acting on the equivalent of a paging
 *  command.  Otherwise, it returns TRUE, i.e, that
 *  the target document might differ from the current,
 *  based on any caching directives or analyses which
 *  claimed or suggested this. -FM
 */
BOOL HText_AreDifferent(HTParentAnchor *anchor,
			const char *full_address)
{
    HTParentAnchor *MTanc;
    char *MTaddress;
    char *MTpound;

    /*
     * Do we have a loaded document and both
     * arguments for this function?
     */
    if (!(HTMainText && anchor && full_address))
	return TRUE;

    /*
     * Do we have both URLs?
     */
    MTanc = HTMainText->node_anchor;
    if (!(MTanc->address && anchor->address))
	return (TRUE);

    /*
     * Do we have a fragment associated with the target?
     */
    if (findPoundSelector(full_address) == NULL)
	return (TRUE);

    /*
     * Always treat client-side image map menus
     * as potentially stale, so we'll create a
     * fresh menu from the LynxMaps HTList.
     */
    if (isLYNXIMGMAP(anchor->address))
	return (TRUE);

    /*
     * Do the docs differ in the type of request?
     */
    if (MTanc->isHEAD != anchor->isHEAD)
	return (TRUE);

    /*
     * Are the actual URLs different, after factoring
     * out a "LYNXIMGMAP:" leader in the MainText URL
     * and its fragment, if present?
     */
    MTaddress = (isLYNXIMGMAP(MTanc->address)
		 ? MTanc->address + LEN_LYNXIMGMAP
		 : MTanc->address);
    MTpound = trimPoundSelector(MTaddress);
    if (strcmp(MTaddress, anchor->address)) {
	restorePoundSelector(MTpound);
	return (TRUE);
    }
    restorePoundSelector(MTpound);

    /*
     * If the MainText is not an image map menu,
     * do the docs have different POST contents?
     */
    if (MTaddress == MTanc->address) {
	if (MTanc->post_data) {
	    if (anchor->post_data) {
		if (!BINEQ(MTanc->post_data, anchor->post_data)) {
		    /*
		     * Both have contents, and they differ.
		     */
		    return (TRUE);
		}
	    } else {
		/*
		 * The loaded document has content, but the
		 * target doesn't, so they're different.
		 */
		return (TRUE);
	    }
	} else if (anchor->post_data) {
	    /*
	     * The loaded document does not have content, but
	     * the target does, so they're different.
	     */
	    return (TRUE);
	}
    }

    /*
     * We'll assume the target is a position in the currently
     * displayed document, and thus can ignore any header, META,
     * or other directives not to use a cached rendition.  -FM
     */
    return (FALSE);
}

#define CanTrimTextArea(c) \
    (LYtrimInputFields ? isspace(c) : ((c) == '\r' || (c) == '\n'))

/*
 * Re-render the text of a tagged ("[123]") HTLine (arg1), with the tag
 * number incremented by some value (arg5).  The re-rendered string may
 * be allowed to expand in the event of a tag width change (eg, 99 -> 100)
 * as controlled by arg6 (CHOP or NOCHOP).  Arg4 is either (the address
 * of) a value which must match, in order for the tag to be incremented,
 * or (the address of) a 0-value, which will match any value, and cause
 * any valid tag to be incremented.  Arg2 is a pointer to the first/only
 * anchor that exists on the line; we may need to adjust their position(s)
 * on the line.  Arg3 when non-0 indicates the number of new digits that
 * were added to the 2nd line in a line crossing pair.
 *
 * All tags fields in a line which individually match an expected new value,
 * are incremented.  Line crossing [tags] are handled (PITA).
 *
 * Untagged or improperly tagged lines are not altered.
 *
 * Returns the number of chars added to the original string's length, if
 * any.
 *
 * --KED 02/03/99
 */
static int increment_tagged_htline(HTLine *ht, TextAnchor *a, int *lx_val,
				   int *old_val,
				   int incr,
				   int mode)
{
    char buf[MAX_LINE];
    char lxbuf[MAX_LINE * 2];

    TextAnchor *st_anchor = a;
    TextAnchor *nxt_anchor;

    char *p = ht->data;
    char *s = buf;
    char *lx = lxbuf;
    char *t;

    BOOLEAN plx = FALSE;
    BOOLEAN valid;

    int val;
    int n;
    int new_n;
    int pre_n;
    int post_n;
    int fixup = 0;

    /*
     * Cleanup for the 2nd half of a line crosser, whose number of tag
     * digits grew by some number of places (usually 1 when it does
     * happen, though it *could* be more).  The tag chars were already
     * rendered into the 2nd line of the pair, but the positioning and
     * other effects haven't been rippled through any other anchors on
     * the (2nd) line.  So we do that here, as a special case, since
     * the part of the tag that's in the 2nd line of the pair, will not
     * be found by the tag string parsing code.  Double PITA.
     *
     * [see comments below on line crosser caused problems]
     */
    if (*lx_val != 0) {
	nxt_anchor = st_anchor;
	while ((nxt_anchor) && (nxt_anchor->line_num == a->line_num)) {
	    nxt_anchor->line_pos = (short) (nxt_anchor->line_pos + *lx_val);
	    nxt_anchor = nxt_anchor->next;
	}
	fixup = *lx_val;
	*lx_val = 0;
	if (st_anchor)
	    st_anchor = st_anchor->next;
    }

    /*
     * Walk thru the line looking for tags (ie, "[nnn]" strings).
     */
    while (*p != '\0') {
	if (*p != '[') {
	    *s++ = *p++;
	    continue;

	} else {
	    *s++ = *p++;
	    t = p;
	    n = 0;
	    valid = TRUE;	/* p = t = byte after '[' */

	    /*
	     * Make sure there are only digits between "[" and "]".
	     */
	    while (*t != ']') {
		if (*t == '\0') {	/* uhoh - we have a potential line crosser */
		    valid = FALSE;
		    plx = TRUE;
		    break;
		}
		if (isdigit(UCH(*t++))) {
		    n++;
		    continue;
		} else {
		    valid = FALSE;
		    break;
		}
	    }

	    /*
	     * If the format is OK, we check to see if the value is what
	     * we expect.  If not, we have a random [nn] string in the text,
	     * and leave it alone.
	     *
	     * [It is *possible* to have a false match here, *if* there are
	     * two identical [nn] strings (including the numeric value of
	     * nn), one of which is the [tag], and the other being part of
	     * a document.  In such a case, the 1st [nn] string will get
	     * incremented; the 2nd one won't, which makes it a 50-50 chance
	     * of being correct, if and when such an unlikely juxtaposition
	     * of text ever occurs.  Further validation tests of the [nnn]
	     * string are probably not possible, since little of the actual
	     * anchor-associated-text is retained in the TextAnchor or the
	     * FormInfo structs.  Fortunately, I think the current method is
	     * more than adequate to weed out 99.999% of any possible false
	     * matches, just as it stands.  Caveat emptor.]
	     */
	    if ((valid) && (n > 0)) {
		val = atoi(p);
		if ((val == *old_val) || (*old_val == 0)) {	/* 0 matches all */
		    if (*old_val != 0)
			(*old_val)++;
		    val += incr;
		    sprintf(s, "%d", val);
		    new_n = (int) strlen(s);
		    s += new_n;
		    p += n;

		    /*
		     * If the number of digits in an existing [tag] increased
		     * (eg, [99] --> [100], etc), we need to "adjust" its
		     * horizontal position, and that of all subsequent tags
		     * that may be on the same line.  PITA.
		     *
		     * [This seems to work as long as a tag isn't a line
		     * crosser; when it is, the position of anchors on either
		     * side of the split tag, seem to "float" and try to be
		     * as "centered" as possible.  Which means that simply
		     * incrementing the line_pos by the fixed value of the
		     * number of digits that got added to some tag in either
		     * line doesn't work quite right, and the text for (say)
		     * a button may get stomped on by another copy of itself,
		     * but offset by a few chars, when it is selected (eg,
		     * "Box Office" may end up looking like "BoBox Office" or
		     * "Box Officece", etc.
		     *
		     * Dunno how to fix that behavior ATT, but at least the
		     * tag numbers themselves are correct.  -KED /\oo/\ ]
		     */
		    if ((new_n -= n) != 0) {
			nxt_anchor = st_anchor;
			while ((nxt_anchor) &&
			       (nxt_anchor->line_num == a->line_num)) {
			    nxt_anchor->line_pos = (short) (nxt_anchor->line_pos
							    + new_n);
			    nxt_anchor = nxt_anchor->next;
			}
			if (st_anchor)
			    st_anchor = st_anchor->next;
		    }
		}
	    }

	    /*
	     * Unfortunately, valid [tag] strings *can* be split across two
	     * lines.  Perhaps it would be best to just prevent that from
	     * happening, but a look into that code, makes me wonder.  Anyway,
	     * we can handle such tags without *too* much trouble in here [I
	     * think], though since such animals are rather rare, it makes it
	     * a bit difficult to test thoroughly (ie, Beyond here, there be
	     * Dragons).
	     *
	     * We use lxbuf[] to deal with the two lines involved.
	     */
	    pre_n = (int) strlen(p);	/* count of 1st part chars in this line */
	    post_n = (int) strlen(ht->next->data);
	    if (plx
		&& (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
		strcpy(lx, p);	/* <- 1st part of a possible lx'ing tag */
		strcat(lx, ht->next->data);	/* tack on NEXT line          */

		t = lx;
		n = 0;
		valid = TRUE;

		/*
		 * Go hunting again for just digits, followed by tag end ']'.
		 */
		while (*t != ']') {
		    if (isdigit(UCH(*t++))) {
			n++;
			continue;
		    } else {
			valid = FALSE;
			break;
		    }
		}

		/*
		 * It *looks* like a line crosser; now we value test it to
		 * find out for sure [but see the "false match" warning,
		 * above], and if it matches, increment it into the buffer,
		 * along with the 2nd line's text.
		 */
		if ((valid)
		    && (n > 0)
		    && (n + post_n + 2) < MAX_LINE) {
		    val = atoi(lx);
		    if ((val == *old_val) || (*old_val == 0)) {
			const char *r;

			if (*old_val != 0)
			    (*old_val)++;
			val += incr;
			sprintf(lx, "%d", val);
			new_n = (int) strlen(lx);
			if ((r = StrChr(ht->next->data, ']')) == 0) {
			    r = "";
			}
			strcat(lx, r);

			/*
			 * We keep the the same number of chars from the
			 * adjusted tag number in the current line; any
			 * extra chars due to a digits increase, will be
			 * stuffed into the next line.
			 *
			 * Keep track of any digits added, for the next
			 * pass through.
			 */
			s = StrNCpy(s, lx, pre_n) + pre_n;
			lx += pre_n;
			strcpy(ht->next->data, lx);

			*lx_val = new_n - n;
		    }
		}
		break;		/* had an lx'er, so we're done with this line */
	    }
	}
    }

    *s = '\0';

    n = (int) strlen(ht->data);
    if (mode == CHOP) {
	*(buf + n) = '\0';
    } else if (strlen(buf) > ht->size) {
	/* we didn't allocate enough space originally - increase it */
	HTLine *temp;

	allocHTLine(temp, strlen(buf));
	if (!temp)
	    outofmem(__FILE__, "increment_tagged_htline");
	assert(temp != NULL);

	memcpy(temp, ht, LINE_SIZE(0));
#if defined(USE_COLOR_STYLE)
	POOLallocstyles(temp->styles, ht->numstyles);
	if (!temp->styles)
	    outofmem(__FILE__, "increment_tagged_htline");
	assert(temp->styles != NULL);
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange) * ht->numstyles);
#endif
	ht = temp;
	ht->prev->next = ht;	/* Link in new line */
	ht->next->prev = ht;	/* Could be same node of course */
    }
    strcpy(ht->data, buf);

    return ((int) strlen(buf) - n + fixup);
}

/*
 * Creates a new anchor and associated struct's appropriate for a form
 * TEXTAREA, and links them into the lists following the current anchor
 * position (as specified by arg1).
 *
 * Exits with arg1 now pointing at the new TextAnchor, and arg2 pointing
 * at the new, associated HTLine.
 *
 * --KED 02/13/99
 */
static void insert_new_textarea_anchor(TextAnchor **curr_anchor, HTLine **exit_htline)
{
    TextAnchor *anchor = *curr_anchor;
    HTLine *htline;

    TextAnchor *a = 0;
    FormInfo *f = 0;
    HTLine *l = 0;

    int curr_tag = 0;		/* 0 ==> match any [tag] number */
    int lx = 0;			/* 0 ==> no line crossing [tag]; it's a new line */
    int i;

    /*
     * Find line in the text that matches ending anchorline of
     * the TEXTAREA.
     *
     * [Yes, Virginia ...  we *do* have to go thru this for each
     * anchor being added, since there is NOT a 1-to-1 mapping
     * between anchors and htlines.  I suppose we could create
     * YAS (Yet Another Struct), but there are too many structs{}
     * floating around in here, as it is.  IMNSHO.]
     */
    for (htline = FirstHTLine(HTMainText), i = 0; anchor->line_num != i; i++) {
	htline = htline->next;
	if (htline == HTMainText->last_line)
	    break;
    }

    /*
     * Clone and initialize the struct's needed to add a new TEXTAREA
     * anchor.
     */
    allocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
	outofmem(__FILE__, "insert_new_textarea_anchor");

    assert(a != NULL);
    assert(f != NULL);
    assert(l != NULL);

    /*  Init all the fields in the new TextAnchor.                 */
    /*  [anything "special" needed based on ->show_anchor value ?] */
    a->next = anchor->next;
    a->number = anchor->number;
    a->line_pos = anchor->line_pos;
    a->extent = anchor->extent;
    a->sgml_offset = SGML_offset();
    a->line_num = anchor->line_num + 1;
    LYCopyHiText(a, anchor);
    a->link_type = anchor->link_type;
    a->input_field = f;
    a->show_anchor = anchor->show_anchor;
    a->inUnderline = anchor->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor = NULL;

    /*  Just the (seemingly) relevant fields in the new FormInfo.  */
    /*  [do we need to do anything "special" based on ->disabled]  */
    StrAllocCopy(f->name, anchor->input_field->name);
    f->number = anchor->input_field->number;
    f->type = anchor->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor->input_field->size;
    f->maxlength = anchor->input_field->maxlength;
    f->no_cache = anchor->input_field->no_cache;
    f->disabled = anchor->input_field->disabled;
    f->readonly = anchor->input_field->readonly;
    f->value_cs = current_char_set;	/* use current setting - kw */

    /*  Init all the fields in the new HTLine (but see the #if).   */
    l->next = htline->next;
    l->prev = htline;
    l->offset = htline->offset;
    l->size = htline->size;
#if defined(USE_COLOR_STYLE)
    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0's] */
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
    l->styles = htline->styles;
#endif
    strcpy(l->data, htline->data);

    /*
     * Link in the new HTLine.
     */
    htline->next->prev = l;
    htline->next = l;

    if (fields_are_numbered()) {
	a->number++;
	increment_tagged_htline(l, a, &lx, &curr_tag, 1, CHOP);
    }

    /*
     * If we're at the tail end of the TextAnchor or HTLine list(s),
     * the new node becomes the last node.
     */
    if (anchor == HTMainText->last_anchor)
	HTMainText->last_anchor = a;
    if (htline == HTMainText->last_line)
	HTMainText->last_line = l;

    /*
     * Link in the new TextAnchor and point the entry anchor arg at it;
     * point the entry HTLine arg at it, too.
     */
    anchor->next = a;
    *curr_anchor = a;

    *exit_htline = l->next;

    return;
}

/*
 * If new anchors were added to expand a TEXTAREA, we need to ripple the
 * new line numbers [and char counts ?] thru the subsequent anchors.
 *
 * If form lines are getting [nnn] tagged, we need to update the displayed
 * tag values to match (which means rerendering them ...  sigh).
 *
 * Finally, we need to update various HTMainText and other counts, etc.
 *
 * [dunno if the char counts really *need* to be done, or if we're using
 * the exactly proper values/algorithms ...  seems to be OK though ...]
 *
 * --KED 02/13/99
 */
static void update_subsequent_anchors(int newlines,
				      TextAnchor *start_anchor,
				      HTLine *start_htline,
				      int start_tag)
{
    TextAnchor *anchor;
    HTLine *htline = start_htline;

    int line_adj = 0;
    int tag_adj = 0;
    int lx = 0;
    int hang = 0;		/* for HANG detection of a nasty intermittent */
    int hang_detect = 100000;	/* ditto */

    CTRACE((tfp, "GridText: adjusting struct's to add %d new line(s)\n", newlines));

    /*
     * Update numeric fields of the rest of the anchors.
     *
     * [We bypass bumping ->number if it has a value of 0, which takes care
     * of the ->input_field->type == F_HIDDEN_TYPE (as well as any other
     * "hidden" anchors, if such things exist).  Seems like the "right
     * thing" to do.  I think.]
     */
    anchor = start_anchor->next;	/* begin updating with the NEXT anchor */
    while (anchor) {
	if (fields_are_numbered() &&
	    (anchor->number != 0))
	    anchor->number += newlines;
	anchor->line_num += newlines;
	anchor = anchor->next;
    }

    /*
     * Update/rerender anchor [tags], if they are being numbered.
     *
     * [If a number tag (eg, "[177]") is itself broken across a line
     * boundary, this fixup only partially works.  While the tag
     * numbering is done properly across the pair of lines, the
     * horizontal positioning on *either* side of the split, can get
     * out of sync by a char or two when it gets selected.  See the
     * [comments] in increment_tagged_htline() for some more detail.
     *
     * I suppose THE fix is to prevent such tag-breaking in the first
     * place (dunno where yet, though).  Ah well ...  at least the tag
     * numbers themselves are correct from top to bottom now.
     *
     * All that said, about the only time this will be a problem in
     * *practice*, is when a page has near 1000 links or more (possibly
     * after a TEXTAREA expansion), and has line crossing tag(s), and
     * the tag numbers in a line crosser go from initially all 3 digit
     * numbers, to some mix of 3 and 4 digits (or all 4 digits) as a
     * result of the expansion process.  Oh, you also need a "clump" of
     * anchors all on the same lines.
     *
     * Yes, it *can* happen, but in real life, it probably won't be
     * seen very much ...]
     *
     * [This may also be an artifact of bumping into the right hand
     * screen edge (or RHS margin), since we don't even *think* about
     * relocating an anchor to the following line, when [tag] digits
     * expansion pushes things too far in that direction.]
     */
    if (fields_are_numbered()) {
	anchor = start_anchor->next;
	while (htline != FirstHTLine(HTMainText)) {

	    while (anchor) {
		if ((anchor->number - newlines) == start_tag)
		    break;

		/*** A HANG (infinite loop) *has* occurred here, with */
		/*** the values of anchor and anchor->next being the  */
		/*** the same, OR with anchor->number "magically" and */
		/*** suddenly taking on an anchor-pointer-like value. */
		/***                                                  */
		/*** The same code and same doc have both passed and  */
		/*** failed at different times, which indicates some  */
		/*** sort of content/html dependency, or some kind of */
		/*** a "race" condition, but I'll be damned if I can  */
		/*** find it after tons of CTRACE's, printf()'s, gdb  */
		/*** breakpoints and watchpoints, etc.                */
		/***                                                  */
		/*** I have added a hang detector (with error msg and */
		/*** beep) here, to break the loop and warn the user, */
		/*** until it can be isolated and fixed.              */
		/***                                                  */
		/*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */

		hang++;
		if ((anchor == anchor->next) || (hang >= hang_detect))
		    goto hang_detected;

		anchor = anchor->next;
	    }

	    if (anchor) {
		line_adj = increment_tagged_htline(htline, anchor, &lx,
						   &start_tag, newlines,
						   NOCHOP);
		htline->size = (unsigned short) (htline->size + line_adj);
		tag_adj += line_adj;

	    } else {

		break;		/* out of anchors ... we're done */
	    }

	    htline = htline->next;
	}
    }

  finish:
    /*
     * Fixup various global variables.
     */
    nlinks += newlines;
    HTMainText->Lines += newlines;
    HTMainText->last_anchor_number += newlines;

    more_text = HText_canScrollDown();

    CTRACE((tfp, "GridText: TextAnchor and HTLine struct's adjusted\n"));

    return;

  hang_detected:		/* ugliness has happened; inform user and do the best we can */

    HTAlert(gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!"));
    goto finish;
}

/*
 * Check if the given anchor is a TEXTAREA belonging to the given form.
 *
 * KED's note -
 * [Finding the TEXTAREA we're actually *in* with these attributes isn't
 * foolproof.  The form number isn't unique to a given TEXTAREA, and there
 * *could* be TEXTAREA's with the same "name".  If that should ever be true,
 * we'll actually get the data from the *1st* TEXTAREA in the page that
 * matches.  We should probably assign a unique id to each TEXTAREA in a page,
 * and match on that, to avoid this (potential) problem.
 *
 * Since the odds of "false matches" *actually* happening in real life seem
 * rather small though, we'll hold off doing this, for a rainy day ...]
 */
static BOOLEAN IsFormsTextarea(FormInfo * form, TextAnchor *anchor_ptr)
{
    return (BOOLEAN) ((anchor_ptr->link_type == INPUT_ANCHOR) &&
		      (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
		      (anchor_ptr->input_field->number == form->number) &&
		      !strcmp(anchor_ptr->input_field->name, form->name));
}

static char *readEditedFile(char *ed_temp)
{
    struct stat stat_info;
    size_t size;

    FILE *fp;

    char *ebuf;

    CTRACE((tfp, "GridText: entered HText_EditTextArea()\n"));

    /*
     * Read back the edited temp file into our buffer.
     */
    if ((stat(ed_temp, &stat_info) < 0) ||
	!S_ISREG(stat_info.st_mode) ||
	((size = (size_t) stat_info.st_size) == 0)) {
	size = 0;
	ebuf = typecalloc(char);

	if (!ebuf)
	    outofmem(__FILE__, "HText_EditTextArea");

	assert(ebuf != NULL);
    } else {
	ebuf = typecallocn(char, size + 1);

	if (!ebuf) {
	    /*
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  With some luck, the user may be even able
	     * to recover the file manually from the temp space while
	     * the lynx session is not over.  - kw
	     */
	    HTAlwaysAlert(NULL, MEMORY_EXHAUSTED_FILE);
	    return 0;
	}
	assert(ebuf != NULL);

	if ((fp = fopen(ed_temp, "r")) != 0) {
	    size = fread(ebuf, (size_t) 1, size, fp);
	    LYCloseInput(fp);
	    ebuf[size] = '\0';	/* Terminate! - kw */
	} else {
	    size = 0;
	}
    }

    /*
     * Nuke any blank lines from the end of the edited data.
     */
    while ((size != 0)
	   && (CanTrimTextArea(UCH(ebuf[size - 1])) || (ebuf[size - 1] == '\0')))
	ebuf[--size] = '\0';

    return ebuf;
}

static int finish_ExtEditForm(LinkInfo * form_link, TextAnchor *start_anchor,
			      char *ed_temp,
			      int orig_cnt)
{
    TextAnchor *anchor_ptr;
    TextAnchor *end_anchor = NULL;
    BOOLEAN wrapalert = FALSE;

    int entry_line = form_link->anchor_line_num;
    int exit_line = 0;
    int line_cnt = 1;

    HTLine *htline = NULL;

    char *ebuf;
    char *line;
    char *lp;
    char *cp;
    int match_tag = 0;
    int newlines = 0;
    int len, len0;
    int display_size;
    int wanted_fieldlen_wrap = -1;	/* not yet asked; 0 means don't. */
    char *skip_at = NULL;
    int skip_num = 0, i;
    size_t line_used = MAX_LINE;

    CTRACE((tfp, "GridText: entered HText_EditTextArea()\n"));

    if ((ebuf = readEditedFile(ed_temp)) == 0) {
	return 0;
    }

    /*
     * Copy each line from the temp file into the corresponding anchor
     * struct.  Add new lines to the TEXTAREA if needed.  (Always leave
     * the user with a blank line at the end of the TEXTAREA.)
     */
    if ((line = typeMallocn(char, line_used)) == 0)
	  outofmem(__FILE__, "HText_EditTextArea");

    assert(line != NULL);

    anchor_ptr = start_anchor;
    display_size = anchor_ptr->input_field->size;
    if (display_size <= 4 ||
	display_size >= MAX_LINE)
	wanted_fieldlen_wrap = 0;

    len = 0;
    lp = ebuf;

    while ((line_cnt <= orig_cnt) || (*lp) || ((len != 0) && (*lp == '\0'))) {

	if (skip_at) {
	    len0 = (int) (skip_at - lp);
	    LYStrNCpy(line, lp, len0);
	    lp = skip_at + skip_num;
	    skip_at = NULL;
	    skip_num = 0;

	    assert(lp != NULL);
	} else {
	    len0 = 0;
	}
	line[len0] = '\0';

	if ((cp = StrChr(lp, '\n')) != 0)
	    len = (int) (cp - lp);
	else
	    len = (int) strlen(lp);

	if (wanted_fieldlen_wrap < 0 &&
	    !wrapalert &&
	    len0 + len >= display_size &&
	    (cp = StrChr(lp, ' ')) != NULL &&
	    (cp - lp) < display_size - 1) {

	    LYFixCursesOn("ask for confirmation:");
	    LYerase();		/* don't show previous state */
	    if (HTConfirmDefault(gettext("Wrap lines to fit displayed area?"),
				 NO)) {
		wanted_fieldlen_wrap = display_size - 1;
	    } else {
		wanted_fieldlen_wrap = 0;
	    }
	}

	if (wanted_fieldlen_wrap > 0 &&
	    len0 + len > wanted_fieldlen_wrap) {

	    for (i = wanted_fieldlen_wrap - len0;
		 i + len0 >= wanted_fieldlen_wrap / 4; i--) {

		if (isspace(UCH(lp[i]))) {
		    len = i + 1;
		    cp = lp + i;
		    if (cp[1] != '\n' &&
			isspace(UCH(cp[1])) &&
			!isspace(UCH(cp[2]))) {
			len++;
			cp++;
		    }
		    if (!isspace(UCH(cp[1]))) {
			while (*cp && *cp != '\r' && *cp != '\n' &&
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap / 4))
			    cp++;	/* search for next line break */
			if (*cp == '\r' && cp[1] == '\n')
			    cp++;
			if (*cp == '\n' &&
			    (cp[1] == '\r' || cp[1] == '\n' ||
			     !isspace(UCH(cp[1])))) {
			    *cp = ' ';
			    while (isspace(UCH(*(cp - 1)))) {
				skip_num++;
				cp--;
			    }
			    skip_at = cp;
			}
		    }
		    break;
		}
	    }
	}

	if (wanted_fieldlen_wrap > 0 &&
	    (len0 + len) > wanted_fieldlen_wrap) {

	    i = len - 1;
	    while (len0 + i + 1 > wanted_fieldlen_wrap &&
		   isspace(UCH(lp[i])))
		i--;
	    if (len0 + i + 1 > wanted_fieldlen_wrap)
		len = wanted_fieldlen_wrap - len0;
	}

	/*
	 * Check if the new text will fit in the buffer.  HTML does not define
	 * a "maxlength" attribute for TEXTAREA; its data can grow as needed.
	 * Lynx will not adjust the display to reflect larger amounts of text;
	 * it relies on the rows/cols attributes as well as the initial content
	 * of the text area for the layout.
	 */
	if ((size_t) (len0 + len) >= line_used) {
	    line_used = (size_t) (3 * (len0 + len)) / 2;
	    if ((line = typeRealloc(char, line, line_used)) == 0)
		  outofmem(__FILE__, "HText_EditTextArea");
	}

	strncat(line, lp, (size_t) len);
	*(line + len0 + len) = '\0';

	/*
	 * If there are more lines in the edit buffer than were in the
	 * original TEXTAREA, we need to add a new line/anchor, continuing
	 * on until the edit buffer is empty.
	 */
	if (line_cnt > orig_cnt) {
	    insert_new_textarea_anchor(&end_anchor, &htline);

	    assert(end_anchor != NULL);
	    assert(end_anchor->input_field != NULL);

	    anchor_ptr = end_anchor;	/* make the new anchor current */
	    newlines++;
	}

	assert(anchor_ptr != NULL);

	/*
	 * Finally copy the new line from the edit buffer into the anchor.
	 */
	StrAllocCopy(anchor_ptr->input_field->value, line);

	/*
	 * Keep track of 1st blank line in any trailing blank lines, for
	 * later cursor repositioning.
	 */
	if (len0 + len > 0)
	    exit_line = 0;
	else if (exit_line == 0)
	    exit_line = anchor_ptr->line_num;

	/*
	 * And do the next line of edited text, for the next anchor ...
	 */
	lp += len;
	if (*lp && isspace(UCH(*lp)))
	    lp++;

	end_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;

	if (anchor_ptr)
	    match_tag = anchor_ptr->number;

	line_cnt++;
    }

    CTRACE((tfp, "GridText: edited text inserted into lynx struct's\n"));

    /*
     * If we've added any new lines/anchors, we need to adjust various
     * things in all anchor-bearing lines following the last newly added
     * line/anchor.  The fun stuff starts here ...
     */
    if (newlines > 0)
	update_subsequent_anchors(newlines, end_anchor, htline, match_tag);

    /*
     * Cleanup time.
     */
    FREE(line);
    FREE(ebuf);

    /*
     * Return the offset needed to move the cursor from its current
     * (on entry) line number, to the 1st blank line of the trailing
     * (group of) blank line(s), which is where we want to be.  Let
     * the caller deal with moving us there, however ...  :-) ...
     */
    return (exit_line - entry_line);
}

/*
 * Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 * user's editor on that file, then transfer the contents of the resultant
 * edited file back into the TEXTAREA (expanding the size of the area, if
 * required).
 *
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st blank line of whatever number of trailing blank
 * lines there are in the TEXTAREA (there will *always* be at least one).
 *
 * --KED 02/01/99
 */
int HText_EditTextArea(LinkInfo * form_link)
{
    char *ed_temp;
    FILE *fp;

    TextAnchor *anchor_ptr;
    TextAnchor *start_anchor = NULL;
    BOOLEAN firstanchor = TRUE;

    char ed_offset[10];
    int start_line = 0;
    int entry_line = form_link->anchor_line_num;
    int orig_cnt = 0;
    int offset = 0;

    FormInfo *form = form_link->l_form;

    CTRACE((tfp, "GridText: entered HText_EditTextArea()\n"));

    if ((ed_temp = typeMallocn(char, LY_MAXPATH)) == 0) {
	outofmem(__FILE__, "HText_EditTextArea");
    } else if ((fp = LYOpenTemp(ed_temp, "", "w")) != 0) {

	/*
	 * Begin at the beginning, to find 1st anchor in the TEXTAREA, then
	 * write all of its lines (anchors) out to the edit temp file.
	 */
	anchor_ptr = HTMainText->first_anchor;

	while (anchor_ptr) {

	    if (IsFormsTextarea(form, anchor_ptr)) {

		if (firstanchor) {
		    firstanchor = FALSE;
		    start_anchor = anchor_ptr;
		    start_line = anchor_ptr->line_num;
		}
		orig_cnt++;

		/*
		 * Write the anchors' text to the temp edit file.
		 */
		fputs(anchor_ptr->input_field->value, fp);
		fputc('\n', fp);

	    } else {

		if (!firstanchor)
		    break;
	    }
	    anchor_ptr = anchor_ptr->next;
	}
	LYCloseTempFP(fp);

	if (start_anchor != 0) {
	    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", form->name));
	    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));

	    /*
	     * Go edit the TEXTAREA temp file, with the initial editor line
	     * corresponding to the TEXTAREA line the cursor is on (if such
	     * positioning is supported by the editor [as lynx knows it]).
	     */
	    ed_offset[0] = 0;	/* pre-ANSI compilers don't initialize aggregates - TD */
	    if (((entry_line - start_line) > 0) && editor_can_position())
		sprintf(ed_offset, "%d", ((entry_line - start_line) + 1));

	    edit_temporary_file(ed_temp, ed_offset, NULL);

	    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));

	    if (!form->disabled)
		offset = finish_ExtEditForm(form_link, start_anchor, ed_temp, orig_cnt);

	    CTRACE((tfp, "GridText: exiting HText_EditTextArea()\n"));
	}
	(void) LYRemoveTemp(ed_temp);
	FREE(ed_temp);
    }

    /*
     * Return the offset needed to move the cursor from its current
     * (on entry) line number, to the 1st blank line of the trailing
     * (group of) blank line(s), which is where we want to be.  Let
     * the caller deal with moving us there, however ...  :-) ...
     */
    return offset;
}

/*
 * Similar to HText_EditTextArea, but assume a single-line text field -TD
 */
void HText_EditTextField(LinkInfo * form_link)
{
    char *ed_temp;
    FILE *fp;

    FormInfo *form = form_link->l_form;

    CTRACE((tfp, "GridText: entered HText_EditTextField()\n"));

    ed_temp = typeMallocn(char, LY_MAXPATH);

    if ((fp = LYOpenTemp(ed_temp, "", "w")) == 0) {
	FREE(ed_temp);
	return;
    }

    /*
     * Write the anchors' text to the temp edit file.
     */
    fputs(form->value, fp);
    fputc('\n', fp);

    LYCloseTempFP(fp);

    CTRACE((tfp, "GridText: text field |%s| dumped to tempfile\n", form_link->lname));
    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));

    edit_temporary_file(ed_temp, "", NULL);

    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));

    if (!form->disabled) {
	char *ebuf;
	char *p;

	if ((ebuf = readEditedFile(ed_temp)) != 0) {
	    /*
	     * Only use the first line of the result.
	     */
	    for (p = ebuf; *p != '\0'; ++p) {
		if (*p == '\n' || *p == '\r') {
		    *p = '\0';
		    break;
		}
	    }
	    StrAllocCopy(form->value, ebuf);
	    FREE(ebuf);
	}
    }

    (void) LYRemoveTemp(ed_temp);
    FREE(ed_temp);

    CTRACE((tfp, "GridText: exiting HText_EditTextField()\n"));
}

/*
 * Expand the size of a TEXTAREA by a fixed number of lines (as specified
 * by arg2).
 *
 * --KED 02/14/99
 */
void HText_ExpandTextarea(LinkInfo * form_link, int newlines)
{
    TextAnchor *anchor_ptr;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;

    FormInfo *form = form_link->l_form;

    HTLine *htline = NULL;

    int match_tag = 0;
    int i;

    CTRACE((tfp, "GridText: entered HText_ExpandTextarea()\n"));

    if (newlines < 1)
	return;

    /*
     * Begin at the beginning, to find the TEXTAREA, then on to find
     * the last line (anchor) in it.
     */
    anchor_ptr = HTMainText->first_anchor;

    while (anchor_ptr) {

	if (IsFormsTextarea(form, anchor_ptr)) {

	    if (firstanchor)
		firstanchor = FALSE;

	    end_anchor = anchor_ptr;

	} else {

	    if (!firstanchor)
		break;
	}
	anchor_ptr = anchor_ptr->next;
    }

    for (i = 1; i <= newlines; i++) {
	insert_new_textarea_anchor(&end_anchor, &htline);

	/*
	 * Make the new line blank.
	 */
	StrAllocCopy(end_anchor->input_field->value, "");

	/*
	 * And go add another line ...
	 */
	if (end_anchor->next)
	    match_tag = end_anchor->next->number;
    }

    CTRACE((tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
	    newlines, form->name));

    /*
     * We need to adjust various things in all anchor bearing lines
     * following the last newly added line/anchor.  Fun stuff.
     */
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);

    CTRACE((tfp, "GridText: exiting HText_ExpandTextarea()\n"));

    return;
}

/*
 * Insert the contents of a file into a TEXTAREA between the cursor line,
 * and the line preceding it.
 *
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st line in the TEXTAREA following the inserted file
 * (if we decide to do that).
 *
 * --KED 02/21/99
 */
int HText_InsertFile(LinkInfo * form_link)
{
    struct stat stat_info;
    size_t size;

    FILE *fp;
    char *fn;

    TextAnchor *anchor_ptr;
    TextAnchor *prev_anchor = NULL;
    TextAnchor *end_anchor = NULL;
    BOOLEAN firstanchor = TRUE;
    BOOLEAN truncalert = FALSE;

    FormInfo *form = form_link->l_form;

    HTLine *htline = NULL;

    TextAnchor *a = 0;
    FormInfo *f = 0;
    HTLine *l = 0;

    char *fbuf = 0;
    char *line = 0;
    char *lp;
    char *cp;
    int entry_line = form_link->anchor_line_num;
    int file_cs;
    int match_tag = 0;
    int newlines = 0;
    int len;
    int i;

    CTRACE((tfp, "GridText: entered HText_InsertFile()\n"));

    /*
     * Get the filename of the insert file.
     */
    if (!(fn = GetFileName())) {
	HTInfoMsg(FILE_INSERT_CANCELLED);
	CTRACE((tfp,
		"GridText: file insert cancelled - no filename provided\n"));
	return (0);
    }
    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(fn) == '.') {
	    HTUserMsg(FILENAME_CANNOT_BE_DOT);
	    return (0);
	}
    }

    /*
     * Read it into our buffer (abort on 0-length file).
     */
    if ((stat(fn, &stat_info) < 0) ||
	((size = (size_t) stat_info.st_size) == 0)) {
	HTInfoMsg(FILE_INSERT_0_LENGTH);
	CTRACE((tfp,
		"GridText: file insert aborted - file=|%s|- was 0-length\n",
		fn));
	FREE(fn);
	return (0);

    } else {

	if ((fbuf = typecallocn(char, size + 1)) == NULL) {
	    /*
	     * This could be huge - don't exit if we don't have enough
	     * memory for it.  - kw
	     */
	    free(fn);
	    HTAlert(MEMORY_EXHAUSTED_FILE);
	    return 0;
	}

	/* Try to make the same assumption for the charset of the inserted
	 * file as we would for normal loading of that file, i.e. taking
	 * assume_local_charset and suffix mappings into account.
	 * If there is a mismatch with the display character set, characters
	 * may be displayed wrong, too bad; but the user has a chance to
	 * correct this by editing the lines, which will update f->value_cs
	 * again. - kw
	 */
	LYGetFileInfo(fn, 0, 0, 0, 0, 0, &file_cs);

	fp = fopen(fn, "r");
	if (!fp) {
	    free(fbuf);
	    free(fn);
	    HTAlert(FILE_CANNOT_OPEN_R);
	    return 0;
	}
	size = fread(fbuf, (size_t) 1, size, fp);
	LYCloseInput(fp);
	FREE(fn);
	fbuf[size] = '\0';	/* Terminate! - kw */
    }

    /*
     * Begin at the beginning, to find the TEXTAREA we're in, then
     * the current cursorline.
     */
    anchor_ptr = HTMainText->first_anchor;

    while (anchor_ptr) {

	if (IsFormsTextarea(form, anchor_ptr)) {
	    if (anchor_ptr->line_num == entry_line)
		break;
	}
	prev_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;
    }

    if (anchor_ptr == NULL) {
	CTRACE((tfp, "BUG: could not find anchor for TEXTAREA.\n"));
	FREE(line);
	FREE(fbuf);
	return 0;
    }

    /*
     * Clone a new TEXTAREA line/anchor using the cursorline anchor as
     * a template, but link it in BEFORE the cursorline anchor/htline.
     *
     * [We can probably combine this with insert_new_textarea_anchor()
     * along with a flag to indicate "insert before" as we do here,
     * or the "normal" mode of operation (add after "current" anchor/
     * line).  Beware of the differences ...  some are a bit subtle to
     * notice.]
     */
    for (htline = FirstHTLine(HTMainText), i = 0;
	 anchor_ptr->line_num != i; i++) {
	htline = htline->next;
	if (htline == HTMainText->last_line)
	    break;
    }

    allocHTLine(l, MAX_LINE);
    POOLtypecalloc(TextAnchor, a);

    POOLtypecalloc(FormInfo, f);
    if (a == NULL || l == NULL || f == NULL)
	outofmem(__FILE__, "HText_InsertFile");

    assert(a != NULL);
    assert(f != NULL);
    assert(l != NULL);

    /*  Init all the fields in the new TextAnchor.                 */
    /*  [anything "special" needed based on ->show_anchor value ?] */
    /* *INDENT-EQLS* */
    a->next        = anchor_ptr;
    a->number      = anchor_ptr->number;
    a->show_number = anchor_ptr->show_number;
    a->line_pos    = anchor_ptr->line_pos;
    a->extent      = anchor_ptr->extent;
    a->sgml_offset = SGML_offset();
    a->line_num    = anchor_ptr->line_num;
    LYCopyHiText(a, anchor_ptr);
    a->link_type   = anchor_ptr->link_type;
    a->input_field = f;
    a->show_anchor = anchor_ptr->show_anchor;
    a->inUnderline = anchor_ptr->inUnderline;
    a->expansion_anch = TRUE;
    a->anchor      = NULL;

    /*  Just the (seemingly) relevant fields in the new FormInfo.  */
    /*  [do we need to do anything "special" based on ->disabled]  */
    StrAllocCopy(f->name, anchor_ptr->input_field->name);
    f->number = anchor_ptr->input_field->number;
    f->type = anchor_ptr->input_field->type;
    StrAllocCopy(f->orig_value, "");
    f->size = anchor_ptr->input_field->size;
    f->maxlength = anchor_ptr->input_field->maxlength;
    f->no_cache = anchor_ptr->input_field->no_cache;
    f->disabled = anchor_ptr->input_field->disabled;
    f->readonly = anchor_ptr->input_field->readonly;
    f->value_cs = (file_cs >= 0) ? file_cs : current_char_set;

    /*  Init all the fields in the new HTLine (but see the #if).   */
    l->offset = htline->offset;
    l->size = htline->size;
#if defined(USE_COLOR_STYLE)
    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0's] */
    l->numstyles = htline->numstyles;
    /*we fork the pointers! */
    l->styles = htline->styles;
#endif
    strcpy(l->data, htline->data);

    /*
     * If we're at the head of the TextAnchor list, the new node becomes
     * the first node.
     */
    if (anchor_ptr == HTMainText->first_anchor)
	HTMainText->first_anchor = a;

    /*
     * Link in the new TextAnchor, and corresponding HTLine.
     */
    if (prev_anchor)
	prev_anchor->next = a;

    htline = htline->prev;
    l->next = htline->next;
    l->prev = htline;
    htline->next->prev = l;
    htline->next = l;

    /*
     * update_subsequent_anchors() expects htline to point to 1st potential
     * line needing fixup; we need to do this just in case the inserted file
     * was only a single line (yes, it's pathological ...  ).
     */
    htline = htline->next;	/* ->new (current) htline, for 1st inserted line  */
    htline = htline->next;	/* ->1st potential (following) [tag] fixup htline */

    anchor_ptr = a;
    newlines++;

    /*
     * Copy each line from the insert file into the corresponding anchor
     * struct.
     *
     * Begin with the new line/anchor we just added (above the cursorline).
     */
    if ((line = typeMallocn(char, MAX_LINE)) == 0)
	  outofmem(__FILE__, "HText_InsertFile");

    assert(line != NULL);

    match_tag = anchor_ptr->number;

    lp = fbuf;

    while (*lp) {

	if ((cp = StrChr(lp, '\n')) != 0)
	    len = (int) (cp - lp);
	else
	    len = (int) strlen(lp);

	if (len >= MAX_LINE) {
	    if (!truncalert) {
		HTAlert(gettext("Very long lines have been truncated!"));
		truncalert = TRUE;
	    }
	    len = MAX_LINE - 1;
	    if (lp[len])
		lp[len + 1] = '\0';	/* prevent next iteration */
	}
	LYStrNCpy(line, lp, len);

	/*
	 * If not the first line from the insert file, we need to add
	 * a new line/anchor, continuing on until the buffer is empty.
	 */
	if (!firstanchor) {
	    insert_new_textarea_anchor(&end_anchor, &htline);
	    anchor_ptr = end_anchor;	/* make the new anchor current */
	    newlines++;
	}

	/*
	 * Copy the new line from the buffer into the anchor.
	 */
	StrAllocCopy(anchor_ptr->input_field->value, line);

	/*
	 * insert_new_textarea_anchor always uses current_char_set,
	 * we may want something else, so fix it up.  - kw
	 */
	if (file_cs >= 0)
	    anchor_ptr->input_field->value_cs = file_cs;

	/*
	 * And do the next line of insert text, for the next anchor ...
	 */
	lp += len;
	if (*lp)
	    lp++;

	firstanchor = FALSE;
	end_anchor = anchor_ptr;
	anchor_ptr = anchor_ptr->next;
    }

    CTRACE((tfp, "GridText: file inserted into lynx struct's\n"));

    /*
     * Now adjust various things in all anchor-bearing lines following the
     * last newly added line/anchor.  Some say this is the fun part ...
     */
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);

    /*
     * Cleanup time.
     */
    FREE(line);
    FREE(fbuf);

    CTRACE((tfp, "GridText: exiting HText_InsertFile()\n"));

    return (newlines);
}

#ifdef USE_COLOR_STYLE
static int GetColumn(void)
{
    int result;

#ifdef USE_SLANG
    result = SLsmg_get_column();
#else
    int y, x;

    LYGetYX(y, x);
    result = x;
    (void) y;
#endif
    return result;
}

static BOOL DidWrap(int y0, int x0)
{
    BOOL result = NO;

#ifndef USE_SLANG
    int y, x;

    LYGetYX(y, x);
    (void) x0;
    if (x >= DISPLAY_COLS || ((x == 0) && (y != y0)))
	result = YES;
#endif
    return result;
}
#endif /* USE_COLOR_STYLE */

/*
 * This function draws the part of line 'line', pointed by 'str' (which can be
 * non terminated with null - i.e., is line->data+N) drawing 'len' bytes (not
 * characters) of it.  It doesn't check whether the 'len' bytes crosses a
 * character boundary (if multibyte chars are in string).  Assumes that the
 * cursor is positioned in the place where the 1st char of string should be
 * drawn.
 *
 * This code is based on display_line.  This code was tested with ncurses only
 * (since no support for lss is availble for Slang) -HV.
 */
#ifdef USE_COLOR_STYLE
static void redraw_part_of_line(HTLine *line, const char *str,
				int len,
				HText *text)
{
    register int i;
    char buffer[7];
    const char *data, *end_of_data;
    size_t utf_extra = 0;

#ifdef USE_COLOR_STYLE
    int current_style = 0;
    int tcols, scols;
#endif
    char LastDisplayChar = ' ';
    int YP, XP;

    LYGetYX(YP, XP);

    i = XP;

    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';

    data = str;
    end_of_data = data + len;
    i++;

    /* this assumes that the part of line to be drawn fits in the screen */
    while (data < end_of_data) {
	buffer[0] = *data;
	data++;

#if defined(USE_COLOR_STYLE)
#define CStyle line->styles[current_style]

	tcols = GetColumn();
	scols = StyleToCols(text, line, current_style);

	while (current_style < line->numstyles &&
	       tcols >= scols) {
	    LynxChangeStyle(CStyle.sc_style, CStyle.sc_direction);
	    current_style++;
	    scols = StyleToCols(text, line, current_style);
	}
#endif
	switch (buffer[0]) {

#ifndef USE_COLOR_STYLE
	case LY_UNDERLINE_START_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_start_underline();
	    }
	    break;

	case LY_UNDERLINE_END_CHAR:
	    if (dump_output_immediately && use_underscore) {
		LYaddch('_');
		i++;
	    } else {
		lynx_stop_underline();
	    }
	    break;

	case LY_BOLD_START_CHAR:
	    lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    lynx_stop_bold();
	    break;

#endif
	case LY_SOFT_NEWLINE:
	    if (!dump_output_immediately) {
		LYaddch('+');
		i++;
	    }
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last character in
		 * the line.  Also ignore it if it first character following
		 * the margin, or if it is preceded by a white character (we
		 * loaded 'M' into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have been excluded by
		 * HText_appendCharacter() or by split_line() in those cases.
		 * -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
	    if (text->T.output_utf8 && is8bits(buffer[0])) {
		utf_extra = utf8_length(text->T.output_utf8, data - 1);
		LastDisplayChar = 'M';
	    }
	    if (utf_extra) {
		LYStrNCpy(&buffer[1], data, utf_extra);
		LYaddstr(buffer);
		buffer[1] = '\0';
		data += utf_extra;
		utf_extra = 0;
	    } else if (is_CJK2(buffer[0])) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (i <= DISPLAY_COLS) {
		    buffer[1] = *data;
		    buffer[2] = '\0';
		    data++;
		    i++;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
		}
	    } else {
		LYaddstr(buffer);
		LastDisplayChar = buffer[0];
	    }
	    if (DidWrap(YP, XP))
		break;
	    i++;
	}			/* end of switch */
    }				/* end of while */

#ifndef USE_COLOR_STYLE
    lynx_stop_underline();
    lynx_stop_bold();
#else

    while (current_style < line->numstyles) {
	LynxChangeStyle(CStyle.sc_style, CStyle.sc_direction);
	current_style++;
    }

#undef CStyle
#endif
    return;
}
#endif /* USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 * Function move_to_glyph is called from LYMoveToLink and does all
 * the real work for it.
 * The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 * redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 * LYMoveToLink/move_to_glyph redraw_*
 * -----------------------------------------------------------------
 * - used without color style           - used with color style
 * - handles showing WHEREIS target     - WHEREIS handled elsewhere
 * - handles only one line              - handles first two lines for
 *                                        hypertext anchors
 * - right columns position for UTF-8
 *   by redrawing as necessary
 * - currently used for highlight       - currently used for highlight
 *   ON and OFF                         OFF
 *
 * Eventually the two sets of function should be unified, and should handle
 * UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 * cases.  If possible.  The complex WHEREIS target logic in LYhighlight()
 * could then be completely removed.  - kw
 */
static void move_to_glyph(int YP,
			  int XP,
			  int XP_draw_min,
			  const char *data,
			  int datasize,
			  unsigned offset,
			  const char *target,
			  const char *hightext,
			  int flags,
			  int utf_flag)
{
    char buffer[7];
    const char *end_of_data;
    size_t utf_extra = 0;

#if defined(SHOW_WHEREIS_TARGETS)
    const char *cp_tgt;
    int i_start_tgt = 0, i_after_tgt;
    int HitOffset, LenNeeded;
#endif /* SHOW_WHEREIS_TARGETS */
    BOOL intarget = NO;
    BOOL inunderline = NO;
    BOOL inbold = NO;
    BOOL drawing = NO;
    BOOL inU = NO;
    BOOL hadutf8 = NO;
    BOOL incurlink = NO;
    BOOL drawingtarget = NO;
    BOOL flag = NO;
    const char *sdata = data;
    char LastDisplayChar = ' ';

    int i = (int) offset;	/* FIXME: should be columns, not offset? */
    int last_i = DISPLAY_COLS;
    int XP_link = XP;		/* column of link */
    int XP_next = XP;		/* column to move to when done drawing */
    int linkvlen;

    int len;

    if (no_title)
	YP -= TITLE_LINES;

    if (flags & 1)
	flag = YES;
    if (flags & 2)
	inU = YES;
    /* Set up the multibyte character buffer  */
    buffer[0] = buffer[1] = buffer[2] = '\0';
    /*
     * Add offset, making sure that we do not
     * go over the COLS limit on the display.
     */
    if (hightext != 0) {
#ifdef WIDEC_CURSES
	last_i = i + LYstrExtent2(data, datasize);
#endif
	linkvlen = LYmbcsstrlen(hightext, utf_flag, YES);
    } else {
	linkvlen = 0;
    }
    if (i >= last_i)
	i = last_i - 1;

    /*
     * Scan through the data, making sure that we do not
     * go over the COLS limit on the display etc.
     */
    len = datasize;
    end_of_data = data + len;

#if defined(SHOW_WHEREIS_TARGETS)
    /*
     * If the target overlaps with the part of this line that
     * we are drawing, it will be emphasized.
     */
    i_after_tgt = i;
    if (target) {
	cp_tgt = LYno_attr_mb_strstr(sdata,
				     target,
				     utf_flag, YES,
				     &HitOffset,
				     &LenNeeded);
	if (cp_tgt) {
	    if ((int) offset + LenNeeded > last_i ||
		((int) offset + HitOffset >= XP + linkvlen)) {
		cp_tgt = NULL;
	    } else {
		i_start_tgt = i + HitOffset;
		i_after_tgt = i + LenNeeded;
	    }
	}
    } else {
	cp_tgt = NULL;
    }
#endif /* SHOW_WHEREIS_TARGETS */

    /*
     * Iterate through the line data from the start, keeping track of
     * the display ("glyph") position in i.  Drawing will be turned
     * on when either the first UTF-8 sequence (that occurs after
     * XP_draw_min) is found, or when we reach the link itself (if
     * highlight is non-NULL).  - kw
     */
    while ((i <= last_i) && data < end_of_data && (*data != '\0')) {

	if (hightext && i >= XP && !incurlink) {

	    /*
	     * We reached the position of link itself, and hightext is
	     * non-NULL.  We switch data from being a pointer into the HTLine
	     * to being a pointer into hightext.  Normally (as long as this
	     * routine is applied to normal hyperlink anchors) the text in
	     * hightext will be identical to that part of the HTLine that
	     * data was already pointing to, except that special attribute
	     * chars LY_BOLD_START_CHAR etc., have been stripped out (see
	     * HText_trimHightext).  So the switching should not result in
	     * any different display, but it ensures that it doesn't go
	     * unnoticed if somehow hightext got messed up somewhere else.
	     * This is also useful in preparation for using this function
	     * for something else than normal hyperlink anchors, i.e., form
	     * fields.
	     * Turn on drawing here or make sure it gets turned on before the
	     * next actual normal character is handled.  - kw
	     */
	    data = hightext;
	    len = (int) strlen(hightext);
	    end_of_data = hightext + len;
	    last_i = i + len;
	    XP_next += linkvlen;
	    incurlink = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    if (cp_tgt) {
		if (flag && i_after_tgt >= XP)
		    i_after_tgt = XP - 1;
	    }
#endif
	    /*
	     * The logic of where to set in-target drawing target etc.
	     * and when to react to it should be cleaned up (here and
	     * further below).  For now this seems to work but isn't
	     * very clear.  The complications arise from reproducing
	     * the behavior (previously done in LYhighlight()) for target
	     * strings that fall into or overlap a link:  use target
	     * emphasis for the target string, except for the first
	     * and last character of the anchor text if the anchor is
	     * highlighted as "current link".  - kw
	     */
	    if (!drawing) {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget) {
		    if (i_after_tgt > i) {
			LYmove(YP, i);
			if (flag) {
			    drawing = YES;
			    drawingtarget = NO;
			    if (inunderline)
				inU = YES;
			    lynx_start_link_color(flag, inU);
			} else {
			    drawing = YES;
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			}
		    }
		}
#endif /* SHOW_WHEREIS_TARGETS */
	    } else {
#ifdef SHOW_WHEREIS_TARGETS
		if (intarget && i_after_tgt > i) {
		    if (flag && (data == hightext)) {
			drawingtarget = NO;
			LYstopTargetEmphasis();
		    }
		} else if (!intarget)
#endif /* SHOW_WHEREIS_TARGETS */
		{
		    if (inunderline)
			inU = YES;
		    if (inunderline)
			lynx_stop_underline();
		    if (inbold)
			lynx_stop_bold();
		    lynx_start_link_color(flag, inU);
		}

	    }
	}
	if (i >= last_i || data >= end_of_data)
	    break;
	if ((buffer[0] = *data) == '\0')
	    break;
#if defined(SHOW_WHEREIS_TARGETS)
	/*
	 * Look for a subsequent occurrence of the target string,
	 * if we had a previous one and have now stepped past it.  - kw
	 */
	if (cp_tgt && i >= i_after_tgt) {
	    if (intarget) {

		if (incurlink && flag && i == last_i - 1)
		    cp_tgt = NULL;
		else
		    cp_tgt = LYno_attr_mb_strstr(sdata,
						 target,
						 utf_flag, YES,
						 &HitOffset,
						 &LenNeeded);
		if (cp_tgt) {
		    i_start_tgt = i + HitOffset;
		    i_after_tgt = i + LenNeeded;
		    if (incurlink) {
			if (flag && i_start_tgt == XP_link)
			    i_start_tgt++;
			if (flag && i_start_tgt == last_i - 1)
			    i_start_tgt++;
			if (flag && i_after_tgt >= last_i)
			    i_after_tgt = last_i - 1;
			if (flag && i_start_tgt >= last_i)
			    cp_tgt = NULL;
		    } else if (i_start_tgt == last_i) {
			if (flag)
			    i_start_tgt++;
		    }
		}
		if (!cp_tgt || i_start_tgt != i) {
		    intarget = NO;
		    if (drawing) {
			if (drawingtarget) {
			    drawingtarget = NO;
			    LYstopTargetEmphasis();
			    if (incurlink) {
				lynx_start_link_color(flag, inU);
			    }
			}
			if (!incurlink) {
			    if (inbold)
				lynx_start_bold();
			    if (inunderline)
				lynx_start_underline();
			}
		    }
		}
	    }
	}
#endif /* SHOW_WHEREIS_TARGETS */

	/*
	 * Advance data to point to the next input char (for the
	 * next round).  Advance sdata, used for searching for a
	 * target string, so that they stay in synch.  As long
	 * as we are not within the highlight text, data and sdata
	 * have identical values.  After we have switched data to
	 * point into hightext, sdata remains a pointer into the
	 * HTLine (so that we don't miss a partial target match at
	 * the end of the anchor text).  So sdata has to sometimes
	 * skip additional special attribute characters that are
	 * not present in highlight in order to stay in synch.  - kw
	 */
	data++;
	if (incurlink) {
	    while (IsNormalChar(*sdata)) {
		++sdata;
	    }
	}

	switch (buffer[0]) {

	case LY_UNDERLINE_START_CHAR:
	    if (!drawing || !incurlink)
		inunderline = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_underline();
	    break;

	case LY_UNDERLINE_END_CHAR:
	    inunderline = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_underline();
	    break;

	case LY_BOLD_START_CHAR:
	    if (!drawing || !incurlink)
		inbold = YES;
	    if (drawing && !intarget && !incurlink)
		lynx_start_bold();
	    break;

	case LY_BOLD_END_CHAR:
	    inbold = NO;
	    if (drawing && !intarget && !incurlink)
		lynx_stop_bold();
	    break;

	case LY_SOFT_NEWLINE:
	    if (drawing) {
		LYaddch('+');
	    }
	    i++;
	    break;

	case LY_SOFT_HYPHEN:
	    if (*data != '\0' ||
		isspace(UCH(LastDisplayChar)) ||
		LastDisplayChar == '-') {
		/*
		 * Ignore the soft hyphen if it is not the last
		 * character in the line.  Also ignore it if it
		 * first character following the margin, or if it
		 * is preceded by a white character (we loaded 'M'
		 * into LastDisplayChar if it was a multibyte
		 * character) or hyphen, though it should have
		 * been excluded by HText_appendCharacter() or by
		 * split_line() in those cases.  -FM
		 */
		break;
	    } else {
		/*
		 * Make it a hard hyphen and fall through.  -FM
		 */
		buffer[0] = '-';
	    }
	    /* FALLTHRU */

	default:
	    /*
	     * We have got an actual normal displayable character, or
	     * the start of one.  Before proceeding check whether
	     * drawing needs to be turned on now.  - kw
	     */
#if defined(SHOW_WHEREIS_TARGETS)
	    if (incurlink && intarget && flag && i_after_tgt > i) {
		if (i == last_i - 1) {
		    i_after_tgt = i;
		} else if (i == last_i - 2 && IS_CJK_TTY &&
			   is8bits(buffer[0])) {
		    i_after_tgt = i;
		    cp_tgt = NULL;
		    if (drawing) {
			if (drawingtarget) {
			    LYstopTargetEmphasis();
			    drawingtarget = NO;
			    lynx_start_link_color(flag, inU);
			}
		    }
		}
	    }
	    if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		if (!intarget ||
		    (intarget && incurlink && !drawingtarget)) {

		    if (incurlink && drawing &&
			!(flag &&
			  (i == XP_link || i == last_i - 1))) {
			lynx_stop_link_color(flag, inU);
		    }
		    if (incurlink && !drawing) {
			LYmove(YP, i);
			if (inunderline)
			    inU = YES;
			if (flag && (i == XP_link || i == last_i - 1)) {
			    lynx_start_link_color(flag, inU);
			    drawingtarget = NO;
			} else {
			    LYstartTargetEmphasis();
			    drawingtarget = YES;
			}
			drawing = YES;
		    } else if (incurlink && drawing &&
			       intarget && !drawingtarget &&
			       (flag &&
				(i == XP_link))) {
			if (inunderline)
			    inU = YES;
			lynx_start_link_color(flag, inU);
		    } else if (drawing &&
			       !(flag &&
				 (i == XP_link || (incurlink && i == last_i - 1)))) {
			LYstartTargetEmphasis();
			drawingtarget = YES;
		    }
		    intarget = YES;
		}
	    } else
#endif /* SHOW_WHEREIS_TARGETS */
	    if (incurlink) {
		if (!drawing) {
		    LYmove(YP, i);
		    if (inunderline)
			inU = YES;
		    lynx_start_link_color(flag, inU);
		    drawing = YES;
		}
	    }

	    i++;
#ifndef WIDEC_CURSES
	    if (utf_flag && is8bits(buffer[0])) {
		hadutf8 = YES;
		utf_extra = utf8_length(utf_flag, data - 1);
		LastDisplayChar = 'M';
	    }
#endif
	    if (utf_extra) {
		LYStrNCpy(&buffer[1], data, utf_extra);
		if (!drawing && i >= XP_draw_min) {
		    LYmove(YP, i - 1);
		    drawing = YES;
#if defined(SHOW_WHEREIS_TARGETS)
		    if (intarget) {
			drawingtarget = YES;
			LYstartTargetEmphasis();
		    } else
#endif /* SHOW_WHEREIS_TARGETS */
		    {
			if (inbold)
			    lynx_start_bold();
			if (inunderline)
			    lynx_start_underline();
		    }
		}
		LYaddstr(buffer);
		buffer[1] = '\0';
		sdata += utf_extra;
		data += utf_extra;
		utf_extra = 0;
	    } else if (IS_CJK_TTY && is8bits(buffer[0])
		       && (!conv_jisx0201kana && (kanji_code != SJIS))) {
		/*
		 * For CJK strings, by Masanobu Kimura.
		 */
		if (drawing && (i <= last_i)) {
		    buffer[1] = *data;
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		}
		i++;
		sdata++;
		data++;
		/*
		 * For now, load 'M' into LastDisplayChar, but we should
		 * check whether it's white and if so, use ' '.  I don't
		 * know if there actually are white CJK characters, and
		 * we're loading ' ' for multibyte spacing characters in
		 * this code set, but this will become an issue when the
		 * development code set's multibyte character handling is
		 * used.  -FM
		 */
		LastDisplayChar = 'M';
	    } else {
		if (drawing) {
		    LYaddstr(buffer);
		}
		LastDisplayChar = buffer[0];
	    }
	}			/* end of switch */
    }				/* end of while */

    if (!drawing) {
	LYmove(YP, XP_next);
	lynx_start_link_color(flag, inU);
    } else {
#if defined(SHOW_WHEREIS_TARGETS)
	if (drawingtarget) {
	    LYstopTargetEmphasis();
	    lynx_start_link_color(flag, inU);
	}
#endif /* SHOW_WHEREIS_TARGETS */
	if (hadutf8) {
	    LYtouchline(YP);
	}
    }
    return;
}
#endif /* !USE_COLOR_STYLE */

#ifndef USE_COLOR_STYLE
/*
 * Move cursor position to a link's place in the display.
 * The "moving to" is done by scanning through the line's
 * character data in the corresponding HTLine of HTMainText,
 * and starting to draw when a UTF-8 encoded non-ASCII character
 * is encountered before the link (with some protection against
 * overwriting form fields).  This refreshing of preceding data is
 * necessary for preventing curses's or slang's display logic from
 * getting too clever; their logic counts character positions wrong
 * since they don't know about multi-byte characters that take up
 * only one screen position.  So we have to make them forget their
 * idea of what's in a screen line drawn previously.
 * If hightext is non-NULL, it should be the anchor text for a normal
 * link as stored in a links[] element, and the anchor text will be
 * drawn too, with appropriate attributes.  - kw
 */
void LYMoveToLink(int cur,
		  const char *target,
		  const char *hightext,
		  int flag,
		  int inU,
		  int utf_flag)
{
#define pvtTITLE_HEIGHT 1
    HTLine *todr;
    int i, n = 0;
    int XP_draw_min = 0;
    int flags = ((flag == TRUE) ? 1 : 0) | (inU ? 2 : 0);

    /*
     * We need to protect changed form text fields preceding this
     * link on the same line against overwriting.  - kw
     */
    for (i = cur - 1; i >= 0; i++) {
	if (links[i].ly < links[cur].ly)
	    break;
	if (links[i].type == WWW_FORM_LINK_TYPE) {
	    XP_draw_min = links[i].ly + links[i].l_form->size;
	    break;
	}
    }

    /*  Find the right HTLine. */
    if (!HTMainText) {
	todr = NULL;
    } else if (HTMainText->stale) {
	todr = FirstHTLine(HTMainText);
	n = links[cur].ly - pvtTITLE_HEIGHT + HTMainText->top_of_screen;
    } else {
	todr = HTMainText->top_of_screen_line;
	n = links[cur].ly - pvtTITLE_HEIGHT;
    }
    for (i = 0; i < n && todr; i++) {
	todr = (todr == HTMainText->last_line) ? NULL : todr->next;
    }
    if (todr) {
	if (target && *target == '\0')
	    target = NULL;
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      todr->data, todr->size, todr->offset,
		      target, hightext, flags, utf_flag);
    } else {
	/*  This should not happen. */
	move_to_glyph(links[cur].ly, links[cur].lx, XP_draw_min,
		      "", 0, (unsigned) links[cur].lx,
		      target, hightext, flags, utf_flag);
    }
}
#endif /* !USE_COLOR_STYLE */

/*
 * This is used only if compiled with lss support.  It's called to redraw a
 * regular link when it's being unhighlighted in LYhighlight().
 */
#ifdef USE_COLOR_STYLE
void redraw_lines_of_link(int cur)
{
#define pvtTITLE_HEIGHT 1
    HTLine *todr1;
    int lines_back;
    int row, col, count;
    const char *text;

    if (HTMainText->next_line == HTMainText->last_line) {
	/* we are at the last page - that is partially filled */
	lines_back = HTMainText->Lines - (links[cur].ly - pvtTITLE_HEIGHT +
					  HTMainText->top_of_screen);
    } else {
	lines_back = display_lines - (links[cur].ly - pvtTITLE_HEIGHT);
    }
    todr1 = HTMainText->next_line;
    while (lines_back-- > 0)
	todr1 = todr1->prev;

    row = links[cur].ly;
    if (no_title)
	row -= TITLE_LINES;

    for (count = 0;
	 row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL;
	 ++count) {
	col = LYGetHilitePos(cur, count);
	if (col >= 0) {
	    LYmove(row, col);
	    redraw_part_of_line(todr1, text, (int) strlen(text), HTMainText);
	}
	todr1 = todr1->next;
	row++;
    }
#undef pvtTITLE_HEIGHT
    return;
}
#endif

#ifdef USE_PRETTYSRC
void HTMark_asSource(void)
{
    if (HTMainText)
	HTMainText->source = TRUE;
}
#endif

HTkcode HText_getKcode(HText *text)
{
    return text->kcode;
}

void HText_updateKcode(HText *text, HTkcode kcode)
{
    text->kcode = kcode;
}

HTkcode HText_getSpecifiedKcode(HText *text)
{
    return text->specified_kcode;
}

void HText_updateSpecifiedKcode(HText *text, HTkcode kcode)
{
    text->specified_kcode = kcode;
}

int HTMainText_Get_UCLYhndl(void)
{
    return (HTMainText ?
	    HTAnchor_getUCLYhndl(HTMainText->node_anchor, UCT_STAGE_MIME)
	    : -1);
}

#ifdef USE_CACHEJAR
static int LYHandleCache(const char *arg,
			 HTParentAnchor *anAnchor,
			 HTFormat format_out,
			 HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char c;
    char *buf = NULL;
    char *title = NULL;
    char *address = NULL;
    char *content_type = NULL;
    char *content_language = NULL;
    char *content_encoding = NULL;
    char *content_location = NULL;
    char *content_disposition = NULL;
    char *content_md5 = NULL;
    char *message_id = NULL;
    char *date = NULL;
    char *owner = NULL;
    char *subject = NULL;
    char *expires = NULL;
    char *ETag = NULL;
    char *server = NULL;
    char *FileCache = NULL;
    char *last_modified = NULL;
    char *cache_control = NULL;

#ifdef USE_SOURCE_CACHE
    char *source_cache_file = NULL;
#endif
    off_t Size = 0;
    int x = -1;

    /*
     * Check if there is something to do.
     */
    if (HTList_count(loaded_texts) == 0) {
	HTProgress(CACHE_JAR_IS_EMPTY);
	LYSleepMsg();
	HTNoDataOK = 1;
	return (HT_NO_DATA);
    }

    /*
     * If # of LYNXCACHE:/# is number ask user if he/she want to delete it.
     */
    if (sscanf(arg, STR_LYNXCACHE "/%d", &x) == 1 && x > 0) {
	CTRACE((tfp, "LYNXCACHE number is %d\n", x));
	_statusline(CACHE_D_OR_CANCEL);
	c = (char) LYgetch_single();
	if (c == 'D') {
	    HText *t = (HText *) HTList_objectAt(loaded_texts, x - 1);

	    HTList_removeObjectAt(loaded_texts, x - 1);
	    HText_free(t);
	}
	return (HT_NO_DATA);
    }

    /*
     * If we get to here, it was a LYNXCACHE:/ URL for creating and displaying
     * the Cache Jar Page.
     * Set up an HTML stream and return an updated Cache Jar Page.
     */
    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);
    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }

    /*
     * Load HTML strings into buf and pass buf to the target for parsing and
     * rendering.
     */
#define PUTS(buf)    (*target->isa->put_block)(target, buf, (int) strlen(buf))

    HTSprintf0(&buf,
	       "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",
	       CACHE_JAR_TITLE);
    PUTS(buf);
    HTSprintf0(&buf, "<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",
	       LYNX_NAME, LYNX_VERSION,
	       HELP_ON_SEGMENT,
	       helpfilepath, CACHE_JAR_HELP, CACHE_JAR_TITLE);
    PUTS(buf);

    /*
     * Max number of cached documents is always same as HTCacheSize.
     * We count them from oldest to newest. Currently cached document
     * is *never* listed, resulting in maximal entries of Cache Jar
     * to be HTCacheSize - 1
     */
    for (x = HTList_count(loaded_texts) - 1; x > 0; x--) {
	/*
	 * The number of the document in the cache list, its title in a link,
	 * and its address and memory allocated for each cached document.
	 */
	HText *cachedoc = (HText *) HTList_objectAt(loaded_texts, x);

	if (cachedoc != 0) {
	    HTParentAnchor *docanchor = cachedoc->node_anchor;

	    if (docanchor != 0) {
#ifdef USE_SOURCE_CACHE
		source_cache_file = docanchor->source_cache_file;
#endif
		Size = docanchor->content_length;
		StrAllocCopy(title, docanchor->title);
		StrAllocCopy(address, docanchor->address);
		content_type = docanchor->content_type;
		content_language = docanchor->content_language;
		content_encoding = docanchor->content_encoding;
		content_location = docanchor->content_location;
		content_disposition = docanchor->content_disposition;
		content_md5 = docanchor->content_md5;
		message_id = docanchor->message_id;
		owner = docanchor->owner;
		StrAllocCopy(subject, docanchor->subject);
		date = docanchor->date;
		expires = docanchor->expires;
		ETag = docanchor->ETag;
		StrAllocCopy(server, docanchor->server);
		FileCache = docanchor->FileCache;
		last_modified = docanchor->last_modified;
		cache_control = docanchor->cache_control;
	    }
	}

	LYEntify(&address, TRUE);
	if (isEmpty(title))
	    StrAllocCopy(title, NO_TITLE);
	else
	    LYEntify(&title, TRUE);

	HTSprintf0(&buf,
		   "<p><em>%d.</em> Title: <a href=\"%s%d\">%s</a><br />URL: <a href=\"%s\">%s</a><br />",
		   x, STR_LYNXCACHE, x, title, address, address);
	PUTS(buf);
	if (Size > 0) {
	    HTSprintf0(&buf, "Size: %" PRI_off_t "  ", Size);

	    PUTS(buf);
	}
	if (cachedoc != NULL && cachedoc->Lines > 0) {
	    HTSprintf0(&buf, "Lines: %d  ", cachedoc->Lines);
	    PUTS(buf);
	}
	if (FileCache != NULL) {
	    HTSprintf0(&buf, "File-Cache: <a href=\"file://%s\">%s</a>  ",
		       FileCache, FileCache);
	    PUTS(buf);
	}
	if (cache_control != NULL) {
	    HTSprintf0(&buf, "Cache-Control: %s  ", cache_control);
	    PUTS(buf);
	}
	if (content_type != NULL) {
	    HTSprintf0(&buf, "Content-Type: %s  ", content_type);
	    PUTS(buf);
	}
	if (content_language != NULL) {
	    HTSprintf0(&buf, "Content-Language: %s  ", content_language);
	    PUTS(buf);
	}
	if (content_encoding != NULL) {
	    HTSprintf0(&buf, "Content-Encoding: %s  ", content_encoding);
	    PUTS(buf);
	}
	if (content_location != NULL) {
	    HTSprintf0(&buf, "Content-Location: %s  ", content_location);
	    PUTS(buf);
	}
	if (content_disposition != NULL) {
	    HTSprintf0(&buf, "Content-Disposition: %s  ", content_disposition);
	    PUTS(buf);
	}
	if (content_md5 != NULL) {
	    HTSprintf0(&buf, "Content-MD5: %s  ", content_md5);
	    PUTS(buf);
	}
	if (message_id != NULL) {
	    HTSprintf0(&buf, "Message-ID: %s  ", message_id);
	    PUTS(buf);
	}
	if (subject != NULL) {
	    LYEntify(&subject, TRUE);
	    HTSprintf0(&buf, "Subject: %s  ", subject);
	    PUTS(buf);
	}
	if (owner != NULL) {
	    HTSprintf0(&buf, "Owner: <a href=%s>%s</a>  ", owner, owner);
	    PUTS(buf);
	}
	if (date != NULL) {
	    HTSprintf0(&buf, "Date: %s  ", date);
	    PUTS(buf);
	}
	if (expires != NULL) {
	    HTSprintf0(&buf, "Expires: %s  ", expires);
	    PUTS(buf);
	}
	if (last_modified != NULL) {
	    HTSprintf0(&buf, "Last-Modified: %s  ", last_modified);
	    PUTS(buf);
	}
	if (ETag != NULL) {
	    HTSprintf0(&buf, "ETag: %s  ", ETag);
	    PUTS(buf);
	}
	if (server != NULL) {
	    LYEntify(&server, TRUE);
	    HTSprintf0(&buf, "Server: <em>%s</em>  ", server);
	    PUTS(buf);
	}
#ifdef USE_SOURCE_CACHE
	if (source_cache_file != NULL) {
	    HTSprintf0(&buf,
		       "Source-Cache-File: <a href=\"file://%s\">%s</a>",
		       source_cache_file, source_cache_file);
	    PUTS(buf);
	}
#endif
	HTSprintf0(&buf, "<br />");
	PUTS(buf);
    }
    HTSprintf0(&buf, "</body></html>");
    PUTS(buf);
    FREE(subject);
    FREE(title);
    FREE(address);
    FREE(server);

    /*
     * Free the target to complete loading of the Cache Jar Page, and report a
     * successful load.
     */
    (*target->isa->_free) (target);
    FREE(buf);
    return (HT_LOADED);
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYCACHE_C_GLOBALDEF_1_INIT { "LYNXCACHE",LYHandleCache,0}
GLOBALDEF(HTProtocol, LYLynxCache, _LYCACHE_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxCache =
{"LYNXCACHE", LYHandleCache, 0};
#endif /* GLOBALDEF_IS_MACRO */
#endif /* USE_CACHEJAR */
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: GridText.c,v 1.171 2009/05/30 12:54:35 tom Exp $
d39 1
a48 9
/*#define DEBUG_APPCH 1*/
/*#define DEBUG_STYLE 1*/

#ifdef DEBUG_STYLE
#define CTRACE_STYLE(p) CTRACE2(TRACE_STYLE, p)
#else
#define CTRACE_STYLE(p)		/* nothing */
#endif

a57 1
#ifdef CONV_JISX0201KANA_JISX0208KANA
a58 3
#else
#define is_CJK2(b) (IS_CJK_TTY && is8bits(UCH(b)) && kanji_code != SJIS)
#endif
d75 1
a75 7
static void HText_trimHightext(HText *text, BOOLEAN final,
			       int stop_before);

struct _HTStream {		/* only know it as object */
    const HTStreamClass *isa;
    /* ... */
};
d119 2
a120 2
static BOOLEAN underline_on = OFF;
static BOOLEAN bold_on = OFF;
d186 1
a186 1
    int used;
d229 4
a232 4
#define POOLallocstyles(ptr, n)     ptr = ALLOC_IN_POOL(&HTMainText->pool, n * sizeof(pool_data))
#define POOLallocHTLine(ptr, size)  ptr = (HTLine*) ALLOC_IN_POOL(&HTMainText->pool, LINE_SIZE(size))
#define POOLallocstring(ptr, len)   ptr = (char*) ALLOC_IN_POOL(&HTMainText->pool, len + 1)
#define POOLtypecalloc(T, ptr)      ptr = (T*) ALLOC_IN_POOL(&HTMainText->pool, sizeof(T))
d237 1
a237 1
 * Returns a pointer to the "allocated" memory or NULL if fails.
d240 1
a240 1
static pool_data *ALLOC_IN_POOL(HTPool ** ppoolptr, unsigned request)
d248 1
a248 1
	ptr = NULL;
d255 1
a255 1
	    n += (ALIGN_SIZE - j);
d262 1
a262 1
	    HTPool *newpool = (HTPool *) LY_CALLOC(1, sizeof(HTPool));
d265 1
a265 1
		ptr = NULL;
d282 1
a282 1
    HTPool *poolptr = (HTPool *) LY_CALLOC(1, sizeof(HTPool));
d321 2
a322 1
#define LINE_SIZE(size) (sizeof(HTLine)+(size))		/* Allow for terminator */
d358 1
d446 1
d502 1
a502 1
#ifdef EXP_JUSTIFY_ELTS
d566 1
a566 1
#endif /* EXP_JUSTIFY_ELTS */
a573 5
/*
 *	Memory leak fixed.
 *	05-29-94 Lynx 2-3-1 Garrett Arch Blythe
 *	Changed to arrays.
 */
d588 1
a588 1
{0, "(Unstyled)", 0, "",
d600 1
a600 1
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces);
d602 1
a602 1
static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces);
d638 1
a638 1
static BOOL mem_is_avail(size_t factor, size_t bytes)
d646 1
a646 1
    p = malloc(factor * bytes);
d690 1
a690 1
	    if (mem_is_avail(0, 700)) {
d695 1
a695 1
		mem_is_avail(0, 700)) {
d730 1
a730 1
	    utf_extra = utf8_length(text->T.output_utf8, data);
d768 1
a768 1
			int len)
d772 1
a772 1
	memcpy(a->lites.hl_base.hl_text, text, len);
d787 2
a788 2
    unsigned need = (a->lites.hl_len - 1);
    unsigned want = (a->lites.hl_len += 1) * sizeof(HiliteInfo);
d790 2
d801 1
a801 1
    have[need].hl_x = x;
d820 1
a820 1
    return (result != 0) ? (LYSkipBlanks(result) - result) : 0;
d822 1
d874 1
a874 1
	    LYSetHiText(a, s, strlen(s));
d898 3
d988 1
a988 1
	return self;
d1074 1
d1086 4
a1089 4
    self->old_dtd = Old_DTD;
    self->keypad_mode = keypad_mode;
    self->disp_lines = LYlines;
    self->disp_cols = DISPLAY_COLS;
a1158 2
     * Memory leak fixed.
     * 05-29-94 Lynx 2-3-1 Garrett Arch Blythe
d1166 1
a1166 1
	memset(underscore_string, '.', (MAX_LINE - 1));
d1172 1
a1172 1
	memset(star_string, '_', (MAX_LINE - 1));
d1199 1
a1199 1
#ifdef EXP_JUSTIFY_ELTS
d1539 1
a1539 1
		 * HText_appendCharacter() or by split_line() in those cases. 
d1571 1
a1571 2
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
d1602 1
d1654 1
a1654 1
    int i = 0, j = 0, toolbar = 0;
d1657 4
d1742 1
d1744 1
d1767 1
a1767 1
    i = limit - LYbarWidth - strlen(percent) - LYstrCells(title);
d1769 1
a1769 1
	i = limit - LYbarWidth - strlen(percent) - 3;
d1773 1
a1773 1
	    strcpy(title + LYstrExtent2(title, i), "...");
d1779 1
a1779 1
    i = (limit - 1) - strlen(percent) - strlen(title);
a2003 1
    line = text->last_line->prev;
d2155 4
a2158 4
		int itmp = 0;
		int written = 0;
		int x_pos = offset + (int) (cp - data);
		int len = strlen(target);
a2159 1
		int y;
d2178 1
a2178 1
			x_pos--;
d2185 3
a2187 1
			    LYmove((i + title_lines), x_pos);
d2194 1
a2194 2
			    strncpy(&tmp[1], &line->data[itmp + 1], utf_extra);
			    tmp[utf_extra + 1] = '\0';
a2198 1
			    utf_extra = 0;
a2219 1
		LYGetYX(y, offset);
d2221 1
a2222 6
		/*
		 * Adjust the cursor position, should we be at
		 * the end of the line, or not have another hit
		 * in it.  -FM
		 */
		LYmove((i + title_lines + 1), 0);
d2224 1
a2298 4
		    /*
		     * Memory leak fixed 05-27-94
		     * Garrett Arch Blythe
		     */
d2301 1
a2301 1
		    if (traversal)
d2303 1
a2303 2
		    else {
#ifndef DONT_TRACK_INTERNAL_LINKS
d2305 2
a2306 2
			    link_dest_intl = HTAnchor_followTypedLink(
									 Anchor_ptr->anchor, HTInternalLink);
d2314 1
a2314 1
			} else
d2316 1
d2321 1
a2321 2
			} else
#endif
d2323 3
d2390 1
a2390 1
		LYhighlight(OFF, (nlinks - 1), target);
a2529 8
/* #define DEBUG_SPLITLINE */

#ifdef DEBUG_SPLITLINE
#define CTRACE_SPLITLINE(p)	CTRACE(p)
#else
#define CTRACE_SPLITLINE(p)	/*nothing */
#endif

d2532 2
a2533 2
				       unsigned char start_c,
				       unsigned char end_c)
d2538 1
a2538 1
	if (*e == end_c)
d2540 1
a2540 1
	if (*e == start_c) {
d2595 2
a2596 2
	    a->line_pos += shift;
	    a->extent -= shift;
d2601 1
a2601 1
	    a->extent += shift;
d2658 1
a2658 1
	allocHTLine(mod_line, line->size + added_chars);
d2697 1
a2697 1
				   copied - line->data, pre - line->data,
d2725 5
a2729 2
    if (head_processed && *prev_anchor && (*prev_anchor)->line_num == line_number)
	(*prev_anchor)->extent += shift;
d2731 1
a2731 1
    mod_line->size = t - newdata;
d2736 6
d2760 1
a2760 1
    CTRACE_STYLE((tfp, "SKIP Style %d %d (%d)\n",
d2763 2
a2764 1
		  tmp->sc_direction));
d2766 1
a2766 1
	CTRACE_STYLE((tfp, "... %d %d (%d)\n",
d2769 1
a2769 1
		      tmp->sc_direction));
d2790 2
d2827 1
a2827 1
    memset(line, 0, LINE_SIZE(0));
d2835 1
d2867 1
a2867 1
		split = cp - previous->data;
d2921 1
a2921 1
	previous->size = split;
d2929 1
a2929 1
#ifdef EXP_JUSTIFY_ELTS
d2947 1
a2947 1
	plen = strlen(p);
d2949 1
a2949 1
	    for (i = (plen - 1); i >= 0; i--) {
d2961 1
a2961 1
		    text->permissible_split = i + 1;
d2967 1
a2967 1
	    line->size += plen;
d2977 1
a2977 1
#ifdef EXP_JUSTIFY_ELTS
d2997 3
a2999 2
    TailTrim = previous->data + previous->size - 1 - p;		/*  Strip trailers. */
    previous->size -= TailTrim;
d3010 1
a3010 1
	s = split;
d3070 1
a3070 1
							s_pre);
d3091 1
a3091 1
				  at_end - from,
d3114 3
a3116 1
	line->numstyles = line->styles + MAX_STYLES_ON_LINE - 1 - to;
d3123 1
a3123 1
	    line->styles[0].sc_horizpos = ~0;	/* ?!!! */
d3125 1
a3125 1
	previous->numstyles = at_end - previous->styles + 1;
d3127 1
a3127 1
	    previous->styles[0].sc_horizpos = ~0;	/* ?!!! */
d3138 3
d3164 1
a3164 1
#ifdef EXP_JUSTIFY_ELTS
a3231 8
			    if (alignment == HT_CENTER) {
				/*
				 * Can't move toward center all the way,
				 * but at least make line contents appear
				 * as far right as possible.  - kw
				 */
				alignment = HT_RIGHT;
			    }
d3258 1
a3258 1
    previous->offset = ((new_offset < 0) ? 0 : new_offset);
d3319 3
a3321 1
			a->extent += -(TailTrim + HeadTrim) + SpecialAttrChars;
d3324 1
a3324 1
			a->extent = s_pre - start;
d3332 1
a3332 1
		    a->line_pos = s_pre;	/* Leave at the end of line */
d3352 2
a3353 2
		a->line_pos = start - s_post + SpecialAttrChars;
		a->extent = len;
d3361 1
a3361 1
#ifdef EXP_JUSTIFY_ELTS
a3377 1
	int total_byte_len = 0, total_cell_len = 0;
a3385 2
		total_byte_len += r->byte_len;
		total_cell_len += r->cell_len;
d3401 1
a3401 1
		int utf_extra = utf8_length(text->T.output_utf8, jp);
a3406 2
	total_byte_len += r->byte_len;
	total_cell_len += r->cell_len;
d3410 2
a3411 1
	    int *oldpos = (int *) malloc(sizeof(int) * 2 * (ht_num_runs - 1));
d3490 1
a3490 1
#endif /* EXP_JUSTIFY_ELTS */
d3511 1
a3511 1
    if (HText_LastLineEmpty(text, FALSE)) {	/* No text on current line */
d3568 1
a3568 1
    CTRACE((tfp, "GridText: Change to style %s\n", style->name));
d3935 4
d3957 10
a3966 10
#ifdef CONV_JISX0201KANA_JISX0208KANA
		    unsigned char c = UCH(ch);
		    unsigned char kb = UCH(text->kanji_buf);

		    JISx0201TO0208_SJIS(c,
					(unsigned char *) &kb,
					(unsigned char *) &c);
		    ch = (char) c;
		    text->kanji_buf = kb;
#endif
d4004 1
a4004 1
		underline_on = ON;
d4011 1
a4011 1
		underline_on = OFF;
d4018 1
a4018 1
		bold_on = ON;
d4024 1
a4024 1
		bold_on = OFF;
d4039 3
a4041 1
		for (i = (text->permissible_split + 1); line->data[i]; i++) {
d4113 2
a4114 2
			   (line->data[text->permissible_split - 1] & 0x80)
			   == 0xC0) {
d4239 1
a4239 1
		line->offset += (target - here);
d4266 3
d4278 2
d4300 9
d4312 2
a4313 1
	       (int) (line->data[line->size - 1] == LY_SOFT_HYPHEN ? 1 : 0)));
d4315 8
a4322 5
    if ((actual
	 + (int) style->rightIndent
	 - ctrl_chars_on_this_line
	 + ((IS_CJK_TTY && text->kanji_buf) ? 1 : 0)
	) >= WRAP_COLS(text)
a4325 1
		 - ctrl_chars_on_this_line
d4330 1
a4330 1
#ifdef EXP_JUSTIFY_ELTS
d4375 1
a4375 1
#ifdef EXP_JUSTIFY_ELTS
d4380 1
a4380 1
#ifdef EXP_JUSTIFY_ELTS
d4438 3
a4440 3
#ifdef CONV_JISX0201KANA_JISX0208KANA
			JISx0201TO0208_EUC(hi, lo, &hi, &lo);
#endif
d4454 8
a4461 9
#ifndef CONV_JISX0201KANA_JISX0208KANA
			if (IS_EUC_X0201KANA(hi, lo))
			    line->data[line->size++] = lo;
			else
#endif
			{
			    EUC_TO_SJIS1(hi, lo, tmp);
			    line->data[line->size++] = (char) tmp[0];
			    line->data[line->size++] = (char) tmp[1];
d4483 7
a4489 9
	}
#ifndef CONV_JISX0201KANA_JISX0208KANA
	else if ((HTCJK == JAPANESE) && IS_SJIS_X0201KANA(UCH((ch))) &&
		 (kanji_code == EUC)) {
	    line->data[line->size++] = UCH(0x8e);
	    line->data[line->size++] = ch;
	}
#endif
	else if (IS_CJK_TTY) {
d4567 1
a4567 1
void HText_setLastChar(HText *text, char ch)
d4572 1
a4572 1
    text->LastChar = ch;
d4605 1
a4605 1
    int first_lineno, last_lineno, first_lineno_pass2;
d4617 1
a4617 1
    lineno = first_lineno = Stbl_getStartLine(me->stbl);
d4623 1
a4623 1
    oldpos = typecallocn(int, 2 * ncols);
d4818 3
a4820 3
	    line->offset = (table_offset > 0
			    ? table_offset
			    : 0);
d4865 1
a4865 1
void HText_startStblTABLE(HText *me, short alignment)
d4867 1
d4869 1
a4869 1
    STable_info *current = me->stbl;
a4871 3
    if (!me)
	return;

d4873 4
a4876 4
    if (nested_tables) {
	if (current)
	    new_line(me);
    } else
d4878 4
a4881 4
    {
	if (me->stbl)
	    HText_cancelStbl(me);	/* auto cancel previously open table */
    }
d4883 3
a4885 3
    me->stbl = Stbl_startTABLE(alignment);
    if (me->stbl) {
	CTRACE((tfp, "startStblTABLE: started.\n"));
d4887 7
a4893 2
	if (nested_tables) {
	    Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
a4894 4
#endif
	me->last_anchor_before_stbl = me->last_anchor;
    } else {
	CTRACE((tfp, "startStblTABLE: failed.\n"));
d4901 1
a4901 1
    if (me->enclosed_stbl != NULL) {
d4977 1
a4977 1
void HText_startStblTR(HText *me, short alignment)
d4998 2
a4999 2
		       short alignment,
		       BOOL isheader)
d5036 2
a5037 2
			short alignment,
			BOOL isgroup)
d5063 1
a5063 1
void HText_startStblRowGroup(HText *me, short alignment)
d5071 35
d5109 1
a5109 1
static void add_link_number(HText *text, TextAnchor *a, BOOL save_position)
d5123 4
d5128 10
a5137 2
	sprintf(marker, "[%d]", a->number);
	HText_appendText(text, marker);
d5142 1
a5142 1
	    a->line_pos = text->last_line->size;
d5149 1
a5149 1
int HText_beginAnchor(HText *text, BOOL underline,
d5158 4
a5161 1
    a->inUnderline = underline;
d5165 1
a5165 1
    a->line_pos = text->last_line->size;
d5177 2
a5178 2
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (HTAnchor_followTypedLink(anc, HTInternalLink)) {
d5181 1
a5181 3
    } else
#endif
    if (HTAnchor_followLink(anc)) {
d5186 1
d5287 1
a5287 1
	a->extent += extent_adjust;
d5396 1
a5396 1
	    a->extent -= extent_adjust;
d5477 1
a5477 1
				text->permissible_split = j;
d5479 1
a5479 1
				text->permissible_split -= NumSize;
d5487 1
a5487 1
				anc->line_pos -= NumSize;
d5490 1
a5490 1
			start->size = j;
a5514 2
			    NumSize++;
			    l = (i - j);
d5517 1
a5517 1
			    prev->size = j;
d5525 1
a5525 1
				    text->permissible_split -= k;
d5534 1
a5534 1
				    anc->line_pos -= i;
d5537 1
a5537 1
			    start->size = j;
a5560 1
		    i = (j + 1);
a5565 1
			k = (j + 1);
d5585 1
a5585 1
			    prev->size = j;
d5648 3
a5650 2
	    a->extent -= ((BlankExtent < a->extent) ?
			  BlankExtent : 0);
d5694 6
a5699 8
    if (str == NULL)
	return;

    if (text->halted == 3)
	return;

    for (p = str; *p; p++) {
	HText_appendCharacter(text, *p);
d5762 6
a5767 1
    line_ptr = FirstHTLine(text);
d5769 13
a5781 18
    /*
     * Remove the blank lines at the end of document.
     */
    while (text->last_line->data[0] == '\0' && text->Lines > 2) {
	HTLine *next_to_the_last_line = text->last_line->prev;

	CTRACE((tfp, "GridText: Removing bottom blank line: `%s'\n",
		text->last_line->data));
	/*
	 * line_ptr points to the first line.
	 */
	next_to_the_last_line->next = line_ptr;
	line_ptr->prev = next_to_the_last_line;
	freeHTLine(text, text->last_line);
	text->last_line = next_to_the_last_line;
	text->Lines--;
	CTRACE((tfp, "GridText: New bottom line: `%s'\n",
		text->last_line->data));
d5817 1
a5817 1
			       BOOLEAN final,
d5899 1
a5899 1
	    anchor_ptr->line_pos = line_ptr->size;
d5959 1
a5959 2
	if (line_ptr->data
	    && anchor_ptr->extent > 0
d5968 1
a5968 1
			size);
d5979 1
a5979 1
	hilite_len = strlen(hilite_str);
d5983 2
d5990 2
a5991 1
	    line_ptr2 = line_ptr2->next;
d6011 2
a6012 2
			      (actual_len - hilite_len));
		actual_len -= strlen(hi_string);
d6053 1
a6053 1
	    anchor_ptr->line_pos = LYstrExtent2(line_ptr->data, anchor_col);
d6055 1
a6055 1
		anchor_ptr->line_pos += 1;
d6069 1
a6069 1
	    anchor_ptr->line_pos -= offset;
d6071 1
a6071 1
	    anchor_ptr->line_pos += have_soft_newline_in_1st_line;
d6078 1
a6078 1
	anchor_ptr->line_pos += line_ptr->offset;
d6124 71
d6222 2
a6223 50
    switch (a->input_field->type) {
    case F_TEXT_TYPE:
	*desc = gettext("text entry field");
	return;
    case F_PASSWORD_TYPE:
	*desc = gettext("password entry field");
	return;
    case F_CHECKBOX_TYPE:
	*desc = gettext("checkbox");
	return;
    case F_RADIO_TYPE:
	*desc = gettext("radio button");
	return;
    case F_SUBMIT_TYPE:
	*desc = gettext("submit button");
	return;
    case F_RESET_TYPE:
	*desc = gettext("reset button");
	return;
    case F_BUTTON_TYPE:
	*desc = gettext("script button");
	return;
    case F_OPTION_LIST_TYPE:
	*desc = gettext("popup menu");
	return;
    case F_HIDDEN_TYPE:
	*desc = gettext("hidden form field");
	return;
    case F_TEXTAREA_TYPE:
	*desc = gettext("text entry area");
	return;
    case F_RANGE_TYPE:
	*desc = gettext("range entry field");
	return;
    case F_FILE_TYPE:
	*desc = gettext("file entry field");
	return;
    case F_TEXT_SUBMIT_TYPE:
	*desc = gettext("text-submit field");
	return;
    case F_IMAGE_SUBMIT_TYPE:
	*desc = gettext("image-submit button");
	return;
    case F_KEYGEN_TYPE:
	*desc = gettext("keygen field");
	return;
    default:
	*desc = gettext("unknown form field");
	return;
    }
a6326 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a6327 1
#endif
d6442 1
a6442 2
		    } else {
#ifndef DONT_TRACK_INTERNAL_LINKS
d6460 1
a6460 2
			} else
#endif
d6462 3
d6480 1
a6480 1
				    BOOLEAN ta_same)
d6589 1
a6589 1
			  BOOLEAN ta_skip)
d6779 1
a6779 1
				BOOL utf_flag,
d6811 1
a6811 1
    if (!line && line->data[0])
d6869 1
a6869 1
	    result += 1 + strlen(line->data);
d6918 1
a6918 1
				BOOLEAN strip_ok)
a7099 1

a7192 1
    /* FIXME: && non_empty(hi_string) */
d7370 1
d7467 1
a7467 7

/* This is done later, hence HText_select is unused in GridText.c
   Should it be the contrary ? @@@@@@
    if (text != HTMainText) {
	HText_select(text);
    }
*/
d7481 2
a7482 2
    } {
	int l = a->line_num;
d7484 2
a7485 2
	CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		a->number, l));
d7487 4
a7490 4
	if (!text->stale &&
	    (l >= text->top_of_screen) &&
	    (l < text->top_of_screen + display_lines + 1))
	    return YES;
d7492 1
a7492 2
	www_search_result = l - (display_lines / 3);	/* put in global variable */
    }
d7646 4
a7649 1
    char searchstring[256], temp[256], *cp, *tmpaddress = NULL;
d7655 1
d7660 1
a7660 1
    if ((cp = strchr(doc->address, '?')) != NULL) {
d7666 2
a7667 2
	LYstrncpy(searchstring, ++cp, sizeof(searchstring) - 1);
	for (cp = searchstring; *cp; cp++)
d7670 2
a7671 2
	HTUnEscape(searchstring);
	strcpy(temp, searchstring);
d7675 1
a7675 1
	HTAddSearchQuery(searchstring);
d7680 2
a7681 2
	searchstring[0] = '\0';
	temp[0] = '\0';
d7687 1
a7687 1
    if (searchstring[0] == '\0') {
d7698 1
d7700 6
a7705 4
    if ((ch = LYgetstr(searchstring, VISIBLE,
		       sizeof(searchstring), recall)) < 0 ||
	*searchstring == '\0' || ch == UPARROW || ch == DNARROW) {
	if (recall && ch == UPARROW) {
d7725 3
a7727 2
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
		if (*temp && !strcmp(temp, searchstring)) {
d7729 2
a7730 2
		} else if ((*temp && QueryTotal == 2) ||
			   (!(*temp) && QueryTotal == 1)) {
d7737 1
a7737 1
	} else if (recall && ch == DNARROW) {
d7757 3
a7759 2
		LYstrncpy(searchstring, cp, sizeof(searchstring) - 1);
		if (*temp && !strcmp(temp, searchstring)) {
d7761 2
a7762 2
		} else if ((*temp && QueryTotal == 2) ||
			   (!(*temp) && QueryTotal == 1)) {
d7775 2
a7776 2
	return (NULLFILE);
    }
d7778 14
a7791 9
    /*
     * Strip leaders and trailers.  -FM
     */
    LYTrimLeading(searchstring);
    if (!(*searchstring)) {
	HTInfoMsg(CANCELLED);
	return (NULLFILE);
    }
    LYTrimTrailing(searchstring);
d7793 5
a7797 7
    /*
     * Don't resubmit the same query unintentionally.
     */
    if (!LYforce_no_cache && 0 == strcmp(temp, searchstring)) {
	HTUserMsg(USE_C_R_TO_RESUB_CUR_QUERY);
	return (NULLFILE);
    }
d7799 9
a7807 15
    /*
     * Add searchstring to the query list,
     * or make it the most current.  -FM
     */
    HTAddSearchQuery(searchstring);

    /*
     * Show the URL with the new query.
     */
    if ((cp = strchr(doc->address, '?')) != NULL)
	*cp = '\0';
    StrAllocCopy(tmpaddress, doc->address);
    StrAllocCat(tmpaddress, "?");
    StrAllocCat(tmpaddress, searchstring);
    user_message(WWW_WAIT_MESSAGE, tmpaddress);
d7809 1
a7809 1
    LYSyslog(tmpaddress);
d7811 9
a7819 3
    FREE(tmpaddress);
    if (cp)
	*cp = '?';
d7821 6
a7826 9
    /*
     * OK, now we do the search.
     */
    if (HTSearch(searchstring, HTMainAnchor)) {
	/*
	 * Memory leak fixed.
	 * 05-28-94 Lynx 2-3-1 Garrett Arch Blythe
	 */
	auto char *cp_freeme = NULL;
d7828 1
a7828 6
	if (traversal)
	    cp_freeme = stub_HTAnchor_address((HTAnchor *) HTMainAnchor);
	else
	    cp_freeme = HTAnchor_address((HTAnchor *) HTMainAnchor);
	StrAllocCopy(doc->address, cp_freeme);
	FREE(cp_freeme);
d7830 5
a7834 1
	CTRACE((tfp, "\ndo_www_search: newfile: %s\n", doc->address));
d7836 10
a7845 4
	/*
	 * Yah, the search succeeded.
	 */
	return (NORMAL);
d7847 3
a7849 9

    /*
     * Either the search failed (Yuk), or we got redirection.
     * If it's redirection, use_this_url_instead is set, and
     * mainloop() will deal with it such that security features
     * and restrictions are checked before acting on the URL, or
     * rejecting it.  -FM
     */
    return (NOT_FOUND);
d7884 1
a7884 1
    int result = strlen(string);
d7907 1
a7907 1
	    result = (dst - string - 1);
d7913 154
d8074 2
d8077 2
a8078 2
			 BOOLEAN is_email,
			 BOOLEAN is_reply)
d8080 1
a8080 1
    register int i;
a8081 1
    int limit;
d8083 6
d8104 6
d8111 13
a8123 1
    for (;; line = line->next) {
d8128 1
a8128 1
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
d8138 1
a8138 1
	    } else if (is_email && !strncmp(line->data, "From ", 5)) {
d8148 71
a8218 3
	limit = TrimmedLength(line->data);
	for (i = 0; i < limit; i++) {
	    int ch = UCH(line->data[i]);
d8234 1
a8234 1
		       (i + 1) >= limit) {	/* last char on line */
d8280 1
d8326 1
a8326 1
	if (line == HTMainText->last_line) {
d8336 1
d8414 3
d8419 2
a8420 3
    OptionType *option;
    char *stars = NULL, *sp;
    const char *cp;
d8424 2
a8425 2
     * Search the hightext strings, taking the case_sensitive setting into
     * account.  -FM
d8427 2
a8428 6
    for (count = 0;; ++count) {
	if ((cp = LYGetHiTextStr(a, count)) == NULL)
	    break;
	if (LYno_attr_strstr(cp, target))
	    return TRUE;
    }
d8430 2
a8431 65
    /*
     * Search the relevant form fields, taking the
     * case_sensitive setting into account.  -FM
     */
    if ((a->input_field != NULL && a->input_field->value != NULL) &&
	a->input_field->type != F_HIDDEN_TYPE) {
	if (a->input_field->type == F_PASSWORD_TYPE) {
	    /*
	     * Check the actual, hidden password, and then
	     * the displayed string.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
		return TRUE;
	    }
	    StrAllocCopy(stars, a->input_field->value);
	    for (sp = stars; *sp != '\0'; sp++)
		*sp = '*';
	    if (LYno_attr_strstr(stars, target)) {
		FREE(stars);
		return TRUE;
	    }
	    FREE(stars);
	} else if (a->input_field->type == F_OPTION_LIST_TYPE) {
	    /*
	     * Search the option strings that are displayed
	     * when the popup is invoked.  -FM
	     */
	    option = a->input_field->select_list;
	    while (option != NULL) {
		if (LYno_attr_strstr(option->name, target)) {
		    return TRUE;
		}
		option = option->next;
	    }
	} else if (a->input_field->type == F_RADIO_TYPE) {
	    /*
	     * Search for checked or unchecked parens.  -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_radio;
	    } else {
		cp = unchecked_radio;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else if (a->input_field->type == F_CHECKBOX_TYPE) {
	    /*
	     * Search for checked or unchecked square brackets.  -FM
	     */
	    if (a->input_field->num_value) {
		cp = checked_box;
	    } else {
		cp = unchecked_box;
	    }
	    if (LYno_attr_strstr(cp, target)) {
		return TRUE;
	    }
	} else {
	    /*
	     * Check the values intended for display.  May have been found
	     * already via the hightext search, but make sure here that the
	     * entire value is searched.  -FM
	     */
	    if (LYno_attr_strstr(a->input_field->value, target)) {
d8434 1
d8436 2
d8439 2
a8440 1
    return FALSE;
d8520 1
d8563 1
d8717 14
d8777 1
a8777 7
	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
d8798 1
a8798 1
	    LYRemoveTemp(HTMainAnchor->source_cache_file);
d8832 1
a8832 7
	/*
	 * This magic FREE(anchor->UCStages) call
	 * stolen from HTuncache_current_document() above.
	 */
	if (!(HTOutputFormat && HTOutputFormat == WWW_SOURCE)) {
	    FREE(HTMainAnchor->UCStages);
	}
d9015 6
a9020 2
    if (!HTMainText)
	return (NULL);
d9022 1
a9022 4
    if (HTMainText->node_anchor && HTMainText->node_anchor->charset)
	return (HTMainText->node_anchor->charset);
    else
	return (NULL);
d9053 1
a9053 1
int HText_LastLineSize(HText *text, BOOL IgnoreSpaces)
d9060 1
a9060 1
BOOL HText_LastLineEmpty(HText *text, BOOL IgnoreSpaces)
d9074 1
a9074 1
int HText_PreviousLineSize(HText *text, BOOL IgnoreSpaces)
d9085 1
a9085 1
BOOL HText_PreviousLineEmpty(HText *text, BOOL IgnoreSpaces)
d9099 1
a9099 1
static int HText_TrueLineSize(HTLine *line, HText *text, BOOL IgnoreSpaces)
d9133 1
a9133 1
static BOOL HText_TrueEmptyLine(HTLine *line, HText *text, BOOL IgnoreSpaces)
d9215 5
a9219 4
	column = (text->in_line_1 ?
		  (int) text->style->indent1st : (int) text->style->leftIndent)
	    + HText_LastLineSize(text, IgnoreSpaces)
	    + (int) text->last_line->offset;
d9266 2
d9325 23
a9347 1
	HTList_appendObject(text->hidden_links, HTAnchor_address(dest));
a9386 5
static int HTFormMethod;
static char *HTFormAction = NULL;
static char *HTFormEnctype = NULL;
static char *HTFormTitle = NULL;
static char *HTFormAcceptCharset = NULL;
d9390 17
d9414 5
a9419 1
    HTFormMethod = URL_GET_METHOD;
d9421 1
d9474 3
a9476 7
     * Create a new "PerFormInfo" structure to hold info on the current
     * form.  The HTForm* variables could all migrate there, currently
     * this isn't done (yet?) but it might be less confusing.
     * Currently the only data saved in this structure that will actually
     * be used is the accept_cs string.
     * This will be appended to the forms list kept by the HText object
     * if and when we reach a HText_endForm.  - kw
d9481 2
a9482 1
    newform->number = HTFormNumber;
d9487 7
d9506 28
a9533 6
    if (HTFormFields == 1 && text && text->first_anchor) {
	/*
	 * Support submission of a single text input field in
	 * the form via <return> instead of a submit button.  -FM
	 */
	TextAnchor *a;
d9536 13
a9548 22
	 * Go through list of anchors and get our input field.  -FM
	 */
	for (a = text->first_anchor; a != NULL; a = a->next) {
	    if (a->link_type == INPUT_ANCHOR &&
		a->input_field->number == HTFormNumber &&
		a->input_field->type == F_TEXT_TYPE) {
		/*
		 * Got it.  Make it submitting.  -FM
		 */
		a->input_field->submit_action = NULL;
		StrAllocCopy(a->input_field->submit_action, HTFormAction);
		if (HTFormEnctype != NULL)
		    StrAllocCopy(a->input_field->submit_enctype,
				 HTFormEnctype);
		if (HTFormTitle != NULL)
		    StrAllocCopy(a->input_field->submit_title, HTFormTitle);
		a->input_field->submit_method = HTFormMethod;
		a->input_field->type = F_TEXT_SUBMIT_TYPE;
		if (HTFormDisabled)
		    a->input_field->disabled = TRUE;
		break;
	    }
a9549 18
    }
    /*
     * Append info on the current form to the HText object's list of
     * forms.
     * HText_beginInput call will have set some of the data in the
     * PerFormInfo structure (if there were any form fields at all),
     * we also fill in the ACCEPT-CHARSET data now (this could have
     * been done earlier).  - kw
     */
    if (HTCurrentForm) {
	if (HTFormDisabled)
	    HTCurrentForm->disabled = TRUE;
	HTCurrentForm->accept_cs = HTFormAcceptCharset;
	HTFormAcceptCharset = NULL;
	if (!text->forms)
	    text->forms = HTList_new();
	HTList_appendObject(text->forms, HTCurrentForm);
	HTCurrentForm = NULL;
d9551 1
a9551 1
	CTRACE((tfp, "endForm:    HTCurrentForm is missing!\n"));
a9556 4
    FREE(HTFormAction);
    FREE(HTFormEnctype);
    FREE(HTFormTitle);
    FREE(HTFormAcceptCharset);
d9563 1
a9563 1
		       BOOLEAN multiple,
d9653 1
a9653 1
		int i = (cp - opname);
d9677 2
a9678 3
 *  We couldn't set the value field for the previous option
 *  tag so we have to do it now.  Assume that the last anchor
 *  was the previous options tag.
d9683 1
a9683 1
			       BOOLEAN checked,
d9732 1
a9732 1
	    i = 0, j = (cp1 - cp);
d9789 1
a9789 2
	    new_ptr = text->last_anchor->input_field->select_list =
		typecalloc(OptionType);
d9793 1
d9807 1
d9830 1
a9830 4
	    if (cp &&
		(tmp = typecallocn(unsigned char, strlen(cp) * 2 + 1)) != 0) {
		if (tmp == NULL)
		    outofmem(__FILE__, "HText_setLastOptionValue");
d9846 2
d9892 1
a9892 1
	    int curlen = strlen(new_ptr->name);
d9894 1
a9894 1
			  ? strlen(HTCurSelectedOptionValue)
d9923 1
a9923 1
		strlen(HTCurSelectedOptionValue);
d9956 2
a9957 1
int HText_beginInput(HText *text, BOOL underline,
d9978 3
d9982 1
a9982 1
    a->inUnderline = underline;
d9984 1
a9984 1
    a->line_pos = text->last_line->size;
d10038 1
a10043 6
     * Set the no_cache flag if the METHOD is POST.  -FM
     */
    if (HTFormMethod == URL_POST_METHOD)
	f->no_cache = TRUE;

    /*
d10115 1
a10115 1
	f->maxlength = atoi(I->maxlength);
d10241 1
a10241 1
	    f->size = strlen(f->value);
d10248 1
a10248 1
	    f->size = strlen(f->value);
d10256 1
a10256 1
	    f->size = strlen(f->value);
d10264 1
a10264 8
	f->submit_action = NULL;
	StrAllocCopy(f->submit_action, HTFormAction);
	if (HTFormEnctype != NULL)
	    StrAllocCopy(f->submit_enctype, HTFormEnctype);
	if (HTFormTitle != NULL)
	    StrAllocCopy(f->submit_title, HTFormTitle);
	f->submit_method = HTFormMethod;

d10323 7
a10329 2
	sprintf(marker, "[%d]", a->number);
	adjust_marker = strlen(marker);
d10338 1
a10338 1
	a->line_pos = text->last_line->size;
d10374 1
a10374 1
		MaximumSize -= strlen(marker);
d10413 5
d10421 2
a10422 2
	if (f->accept_cs && !HTFormAcceptCharset) {
	    StrAllocCopy(HTFormAcceptCharset, f->accept_cs);
d10473 1
a10473 1
	sprintf(marker, "[%d]", text->last_anchor->number);
d10498 1
a10498 1
    if ((p = strchr(givenmime, ';')) != NULL) {
d10585 1
a10585 1
    char buffer[257];
d10587 1
a10587 1
    CTRACE((tfp, "Ok, about to convert %s to mime/thingy\n", val_used));
d10593 2
a10594 2
	    while ((bytes = fread(buffer, sizeof(char), 256, fd)) != 0) {
		HTSABCat(result, buffer, bytes);
d10653 3
a10655 3
    int j;
    int have = strlen(*Boundary);
    int last = BStrLen(data);
d10659 4
a10662 1
    for (j = 0; j <= (last - have); ++j) {
d10680 1
a10680 1
			       int len)
d10688 1
a10688 1
    int rlen;			/* length of result string */
d10693 1
a10693 1
    int eollen;
d10711 1
d10855 5
d10868 3
a10870 2
int HText_SubmitForm(FormInfo * submit_item, DocInfo *doc, char *link_name,
		     char *link_value)
d10907 1
a10907 2
    thisform = (PerFormInfo *) HTList_objectAt(HTMainText->forms, form_number
					       - 1);
d10957 1
a10957 1
	Boundary = "xnyLAaB03X";
d10991 1
a10991 2
	HTMainText->node_anchor->charset &&
	*HTMainText->node_anchor->charset) {
d11077 1
a11077 1
	my_data = typecallocn(PostData, anchor_limit);
d11080 1
d11083 9
a11091 5
    if (target_csname == NULL && target_cs >= 0) {
	if ((form_is_special & SPECIAL_8BIT) != 0) {
	    target_csname = LYCharSet_UC[target_cs].MIMEname;
	} else if ((form_is_special & SPECIAL_FORM) != 0) {
	    target_csname = LYCharSet_UC[target_cs].MIMEname;
d11094 1
d11096 2
d11117 1
d11198 2
d11215 1
a11215 1
		CTRACE((tfp, "I will submit %s (from %s)\n",
d11266 20
a11285 3
		    success = LYUCTranslateBackFormData(&copied_val_used,
							form_ptr->value_cs,
							target_cs, PlainText);
d11487 1
d11628 1
a11628 1
			*(strchr(escaped1, '=') + 1) = '\0';
a11668 1
		    textarea_lineno = 1;
d11801 14
d11823 1
a11823 1
	    StrAllocCopy(doc->address, BStrData(my_query));	/* FIXME? */
d11826 1
d11851 7
a11857 2
    if (!HTMainText)
	return;
d11859 2
a11860 8
    /*
     * Go through list of anchors and set the disabled flag.
     */
    for (anchor_ptr = HTMainText->first_anchor;
	 anchor_ptr != NULL;
	 anchor_ptr = anchor_ptr->next) {
	if (anchor_ptr->link_type == INPUT_ANCHOR &&
	    anchor_ptr->input_field->number == HTFormNumber) {
d11862 2
a11863 1
	    anchor_ptr->input_field->disabled = TRUE;
a11865 1

a12032 4
    FREE(HTFormAction);
    FREE(HTFormEnctype);
    FREE(HTFormTitle);
    FREE(HTFormAcceptCharset);
d12112 1
a12112 1
    if (!charset || *charset == '\0') {
d12118 1
a12118 1
    if (!charset || *charset == '\0') {
d12145 1
a12145 1
		   !strncmp(charset, "x-euc-", 6) ||
d12152 1
a12152 1
		   !strncmp(charset, "cn-gb", 5) ||
d12378 1
a12378 1
	    nxt_anchor->line_pos += *lx_val;
d12444 1
a12444 1
		    new_n = strlen(s);
d12473 2
a12474 1
			    nxt_anchor->line_pos += new_n;
d12494 2
a12495 2
	    pre_n = strlen(p);	/* count of 1st part chars in this line */
	    post_n = strlen(ht->next->data);
d12529 2
d12535 5
a12539 2
			new_n = strlen(lx);
			strcat(lx, strchr(ht->next->data, ']'));
d12550 1
a12550 1
			s = strncpy(s, lx, pre_n) + pre_n;
d12564 1
a12564 1
    n = strlen(ht->data);
d12574 2
d12581 1
d12590 1
a12590 1
    return (strlen(buf) - n + fixup);
d12626 1
a12626 2
    for (htline = FirstHTLine(HTMainText), i = 0;
	 anchor->line_num != i; i++) {
d12643 4
d12673 1
d12835 1
a12835 1
		htline->size += line_adj;
d12889 1
a12889 3
static int finish_ExtEditForm(LinkInfo * form_link, TextAnchor *start_anchor,
			      char *ed_temp,
			      int orig_cnt)
a12895 10
    TextAnchor *anchor_ptr;
    TextAnchor *end_anchor = NULL;
    BOOLEAN wrapalert = FALSE;

    int entry_line = form_link->anchor_line_num;
    int exit_line = 0;
    int line_cnt = 1;

    HTLine *htline = NULL;

a12896 9
    char *line;
    char *lp;
    char *cp;
    int match_tag = 0;
    int newlines = 0;
    int len, len0, len_in;
    int wanted_fieldlen_wrap = -1;	/* not yet asked; 0 means don't. */
    char *skip_at = NULL;
    int skip_num = 0, i;
d12898 1
a12898 1
    CTRACE((tfp, "GridText: entered HText_ExtEditForm()\n"));
d12905 1
a12905 1
	((size = stat_info.st_size) == 0)) {
d12910 3
a12912 1
	    outofmem(__FILE__, "HText_ExtEditForm");
d12926 1
d12928 7
a12934 4
	fp = fopen(ed_temp, "r");
	size = fread(ebuf, 1, size, fp);
	LYCloseInput(fp);
	ebuf[size] = '\0';	/* Terminate! - kw */
d12944 36
d12985 4
a12988 2
    if ((line = (char *) malloc(MAX_LINE)) == 0)
	outofmem(__FILE__, "HText_ExtEditForm");
d12991 3
a12993 2
    if (anchor_ptr->input_field->size <= 4 ||
	anchor_ptr->input_field->size >= MAX_LINE)
d12996 1
a12996 1
    len = len_in = 0;
d13002 2
a13003 3
	    len0 = skip_at - lp;
	    strncpy(line, lp, len0);
	    line[len0] = '\0';
d13007 2
d13014 2
a13015 2
	if ((cp = strchr(lp, '\n')) != 0)
	    len = len_in = cp - lp;
d13017 7
a13023 1
	    len = len_in = strlen(lp);
a13024 4
	if (wanted_fieldlen_wrap < 0 && !wrapalert &&
	    len0 + len >= start_anchor->input_field->size &&
	    (cp = strchr(lp, ' ')) != NULL &&
	    (cp - lp) < start_anchor->input_field->size - 1) {
d13029 1
a13029 1
		wanted_fieldlen_wrap = start_anchor->input_field->size - 1;
d13034 4
a13037 1
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
d13040 1
d13071 4
a13074 1
	if (wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap) {
d13083 11
a13093 17
	if (len0 + len >= MAX_LINE) {
	    if (!wrapalert) {
		LYFixCursesOn("show alert:");
		HTAlert(gettext("Very long lines have been wrapped!"));
		wrapalert = TRUE;
	    }
	    /*
	     * First try to find a space character for wrapping - kw
	     */
	    for (i = MAX_LINE - len0 - 1; i > 0; i--) {
		if (isspace(UCH(lp[i]))) {
		    len = i;
		    break;
		}
	    }
	    if (len0 + len >= MAX_LINE)
		len = MAX_LINE - len0 - 1;
d13096 1
a13096 1
	strncat(line, lp, len);
d13106 4
d13114 2
d13183 1
a13183 1
int HText_ExtEditForm(LinkInfo * form_link)
d13196 1
a13196 1
    int offset;
d13200 5
a13204 1
    CTRACE((tfp, "GridText: entered HText_ExtEditForm()\n"));
d13206 9
a13214 5
    ed_temp = (char *) malloc(LY_MAXPATH);
    if ((fp = LYOpenTemp(ed_temp, "", "w")) == 0) {
	FREE(ed_temp);
	return (0);
    }
d13216 6
a13221 5
    /*
     * Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     * write all of its lines (anchors) out to the edit temp file.
     */
    anchor_ptr = HTMainText->first_anchor;
d13223 5
a13227 1
    while (anchor_ptr) {
d13229 1
a13229 1
	if (IsFormsTextarea(form, anchor_ptr)) {
d13231 2
a13232 4
	    if (firstanchor) {
		firstanchor = FALSE;
		start_anchor = anchor_ptr;
		start_line = anchor_ptr->line_num;
d13234 7
a13240 1
	    orig_cnt++;
d13243 3
a13245 1
	     * Write the anchors' text to the temp edit file.
d13247 7
a13253 2
	    fputs(anchor_ptr->input_field->value, fp);
	    fputc('\n', fp);
d13255 2
a13256 1
	} else {
d13258 1
a13258 2
	    if (!firstanchor)
		break;
d13260 30
a13289 1
	anchor_ptr = anchor_ptr->next;
d13291 7
d13300 1
a13300 1
    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", form->name));
d13303 1
a13303 10
    /*
     * Go edit the TEXTAREA temp file, with the initial editor line
     * corresponding to the TEXTAREA line the cursor is on (if such
     * positioning is supported by the editor [as lynx knows it]).
     */
    ed_offset[0] = 0;		/* pre-ANSI compilers don't initialize aggregates - TD */
    if (((entry_line - start_line) > 0) && editor_can_position())
	sprintf(ed_offset, "%d", ((entry_line - start_line) + 1));

    edit_temporary_file(ed_temp, ed_offset, NULL);
d13307 18
a13324 4
    if (form->disabled)
	offset = 0;
    else
	offset = finish_ExtEditForm(form_link, start_anchor, ed_temp, orig_cnt);
d13326 1
a13326 1
    LYRemoveTemp(ed_temp);
d13329 1
a13329 9
    CTRACE((tfp, "GridText: exiting HText_ExtEditForm()\n"));

    /*
     * Return the offset needed to move the cursor from its current
     * (on entry) line number, to the 1st blank line of the trailing
     * (group of) blank line(s), which is where we want to be.  Let
     * the caller deal with moving us there, however ...  :-) ...
     */
    return offset;
d13440 2
a13441 2
    char *fbuf;
    char *line;
d13510 1
a13510 1
	size = fread(fbuf, 1, size, fp);
d13532 7
d13563 4
d13569 6
a13574 4
    a->next = anchor_ptr;
    a->number = anchor_ptr->number;
    a->line_pos = anchor_ptr->line_pos;
    a->extent = anchor_ptr->extent;
d13576 1
a13576 1
    a->line_num = anchor_ptr->line_num;
d13578 1
a13578 1
    a->link_type = anchor_ptr->link_type;
d13583 1
a13583 1
    a->anchor = NULL;
d13595 1
d13645 4
a13648 2
    if ((line = (char *) malloc(MAX_LINE)) == 0)
	outofmem(__FILE__, "HText_InsertFile");
a13651 1
    len = 0;
d13656 2
a13657 2
	if ((cp = strchr(lp, '\n')) != 0)
	    len = cp - lp;
d13659 1
a13659 1
	    len = strlen(lp);
d13670 1
a13670 2
	strncpy(line, lp, len);
	*(line + len) = '\0';
d13862 1
a13862 1
		 * HText_appendCharacter() or by split_line() in those cases. 
d13880 1
a13880 2
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
d13964 1
a13964 1
			  BOOL utf_flag)
a14009 1
	len = strlen(hightext);
d14061 1
a14061 1
	if (data && hightext && i >= XP && !incurlink) {
d14081 1
a14081 1
	    len = strlen(hightext);
d14359 1
a14359 2
		strncpy(&buffer[1], data, utf_extra);
		buffer[utf_extra + 1] = '\0';
d14381 2
a14382 1
	    } else if (IS_CJK_TTY && is8bits(buffer[0])) {
d14452 2
a14453 2
		  BOOL inU,
		  BOOL utf_flag)
d14459 1
a14459 1
    int flags = ((flag == ON) ? 1 : 0) | (inU ? 2 : 0);
d14496 1
a14496 1
		      "", 0, links[cur].lx,
d14534 4
a14537 2
	LYmove(row++, col);
	redraw_part_of_line(todr1, text, (int) strlen(text), HTMainText);
d14539 1
d14613 1
a14613 1
    int Size = 0;
a14614 1
    int cached = 0;
d14619 1
a14619 1
    if ((cached = HTList_count(loaded_texts)) == 0) {
d14727 2
a14728 1
	    HTSprintf0(&buf, "Size: %d  ", Size);
d14731 1
a14731 1
	if (cachedoc->Lines > 0) {
@


1.8
log
@Fix off by one in page display.

From Patrick Keshishian, thanks! Fix found upstream as well.

Okay miod@@. fgs@@ seemed to agree.
@
text
@d1 4
a4 1
/*		Character grid hypertext object
d49 7
d60 1
a60 2

unsigned int cached_styles[CACHEH][CACHEW];
d67 1
a67 1
#define is_CJK2(b) (HTCJK != NOCJK && is8bits(UCH(b)))
d69 1
a69 1
#define is_CJK2(b) (HTCJK != NOCJK && is8bits(UCH(b)) && kanji_code != SJIS)
a89 12
#ifdef USE_COLOR_STYLE
static void LynxResetScreenCache(void)
{
    int i, j;

    for (i = 1; (i < CACHEH && i <= display_lines); i++) {
	for (j = 0; j < CACHEW; j++)
	    cached_styles[i][j] = 0;
    }
}
#endif /* USE_COLOR_STYLE */

d180 3
a182 3
    unsigned int direction:2;	/* on or off */
    unsigned int horizpos:14;	/* horizontal position of this change */
    unsigned int style:16;	/* which style to change to */
a448 1
    BOOL IgnoreExcess;		/* Ignore chars at wrap point */
d578 1
a578 1
	HTCJK == NOCJK && !in_DT && \
d741 1
a741 1
    int nchars = line->styles[nstyle].horizpos;
d1019 1
a1019 1
	    LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
d1120 4
a1123 4
    self->no_cache = ((anchor->no_cache ||
		       anchor->post_data)
		      ? YES
		      : NO);
a1124 1
    self->IgnoreExcess = FALSE;
d1475 2
a1476 2
	       i >= (int) (CStyle.horizpos + line->offset + 1)) {
	    LynxChangeStyle(CStyle.style, CStyle.direction);
d1550 1
a1550 1
		 * the line.  Also ignore it if it first character following
d1653 1
a1653 1
	LynxChangeStyle(CStyle.style, CStyle.direction);
d1727 1
a1727 1
    if (HTCJK != NOCJK) {
d1737 1
a1737 1
			tmp[j++] = title[i];
d1757 1
a1757 1
	int c = nhist ? ACS_LARROW : ' ';
d2092 1
a2092 1
	LynxResetScreenCache();
d2210 1
a2210 1
			} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
a2396 1
		    /* FIXME: use LYstrExtent, not strlen */
d2398 1
a2398 1
				STARS(strlen(FormInfo_ptr->value)));
d2482 1
a2482 1
    } else if (HTCJK != NOCJK) {
a2546 1
#define new_line(text) split_line(text, 0)
d2548 1
a2548 1
#define DEBUG_SPLITLINE
a2697 1
	/* Include'em all! */
d2728 1
a2728 1
	     istyle < line->numstyles && (int) NStyle.horizpos < curlim;
d2731 1
a2731 1
	    NStyle.horizpos += shift;
d2759 10
d2772 2
a2773 6
{				/* Found an OFF change not part of an adjacent matched pair.
				 * Walk backward looking for the corresponding ON change.
				 * Move everything after split_pos to be at split_pos.
				 * This can only work correctly if all changes are correctly
				 * nested!  If this fails, assume it is safer to leave whatever
				 * comes before the OFF on the previous line alone. */
d2777 4
d2782 6
a2787 2
	if (tmp->style == end->style) {
	    if (tmp->direction == STACK_OFF)
d2789 8
a2796 5
	    else if (tmp->direction == STACK_ON) {
		if (++level == 0)
		    return tmp;
	    } else
		return 0;
d2798 2
a2799 2
	if (tmp->horizpos > split_pos) {
	    tmp->horizpos = split_pos;
d2802 1
a2802 1
    return 0;
d2972 2
a2973 1
		if (p[i] == LY_SOFT_HYPHEN && (int) text->permissible_split < i)
d3051 6
a3056 6
	    if ((int) to->horizpos > s_post) {
		to->horizpos += -s_post + SpecialAttrChars;
	    } else if ((int) to->horizpos > s_pre &&
		       (to->direction == STACK_ON ||
			to->direction == ABS_ON)) {
		to->horizpos = ((int) to->horizpos < s) ? 0 : SpecialAttrChars;
d3080 1
a3080 1
	    if (scan->direction == STACK_OFF) {
d3087 4
a3090 4
	    } else if (scan->direction == STACK_ON) {
		if (at_end->direction == STACK_ON
		    && at_end->style == scan->style
		    && (int) at_end->horizpos >= s_pre)
d3097 9
a3105 3
		    at_end->direction = STACK_OFF;
		    at_end->style = scan->style;
		    at_end->horizpos = s_pre;
d3108 3
a3110 3
		    && to[1].direction == STACK_OFF
		    && to[1].horizpos <= (unsigned) SpecialAttrChars
		    && to[1].style == scan->style)
d3114 1
a3114 1
		    to->horizpos = SpecialAttrChars;
d3121 2
a3122 2
	    if ((int) scan->horizpos > s_pre) {
		scan->horizpos = s_pre;
d3133 1
a3133 1
	    line->styles[0].horizpos = ~0;	/* ?!!! */
d3137 1
a3137 1
	    previous->styles[0].horizpos = ~0;	/* ?!!! */
d3198 1
d3203 5
a3207 3
	spare = WRAP_COLS(text) -
	    (int) style->rightIndent - indent +
	    ctrl_chars_on_previous_line - previous->size;
d3465 1
a3465 1
		*p2 = (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
d3511 12
d3530 1
a3530 1
	BOOL first = (line == text->last_line);
a3599 1
    int limit = 0;
d3793 1
a3793 1
    if (ch == CH_ESC && HTCJK == NOCJK) {	/* decimal 27  S/390 -- gil -- 1504 */
d3806 1
a3806 1
    if (is8bits(ch) && HTCJK == NOCJK &&
d3813 1
a3813 1
    if (UCH(ch) == 155 && HTCJK == NOCJK) {	/* octal 233 */
d3826 1
a3826 1
    if (HTCJK != NOCJK) {
d3998 1
a3998 1
    if (HTCJK != NOCJK &&	/* added condition - kw */
d4012 1
a4012 1
	if (with_backspaces && HTCJK == NOCJK && !text->T.output_utf8) {
d4272 1
a4272 1
	    (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) ||
a4304 30
     * Check if we should ignore characters at the wrap point.
     */
    if (text->IgnoreExcess) {
	int nominal = (indent + (int) (line->offset + line->size) - ctrl_chars_on_this_line);
	int number;

	limit = WRAP_COLS(text);
	if (fields_are_numbered()
	    && !number_fields_on_left
	    && text->last_anchor != 0
	    && (number = text->last_anchor->number) > 0) {
	    limit -= (number > 99999
		      ? 6
		      : (number > 9999
			 ? 5
			 : (number > 999
			    ? 4
			    : (number > 99
			       ? 3
			       : (number > 9
				  ? 2
				  : 1))))) + 2;
	}
	if ((nominal + (int) style->rightIndent) >= limit
	    || (nominal + UTFXTRA_ON_THIS_LINE) >= LYcols_cu(text)) {
	    return;
	}
    }

    /*
d4314 1
a4314 1
	 + (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0)
d4321 1
a4321 1
		) >= (LYcols_cu(text) - 1)))) {
d4393 1
a4393 1
	if (HTCJK != NOCJK && text->kanji_buf) {
d4429 2
a4430 2
			line->data[line->size++] = tmp[0];
			line->data[line->size++] = tmp[1];
d4435 2
a4436 2
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
d4455 2
a4456 2
			    line->data[line->size++] = tmp[0];
			    line->data[line->size++] = tmp[1];
d4459 2
a4460 2
			line->data[line->size++] = hi;
			line->data[line->size++] = lo;
d4474 2
a4475 2
		line->data[line->size++] = hi;
		line->data[line->size++] = lo;
d4486 1
a4486 1
	else if (HTCJK != NOCJK) {
d4528 3
a4530 3
	    line->styles[line->numstyles - 1].direction &&
	    line->styles[line->numstyles - 1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles - 1].horizpos
d4538 1
a4538 1
	    line->styles[line->numstyles].horizpos = line->size;
d4545 2
a4546 2
	    if ((int) line->styles[line->numstyles].horizpos >= ctrl_chars_on_this_line) {
		line->styles[line->numstyles].horizpos -= ctrl_chars_on_this_line;
d4548 7
a4554 2
	    line->styles[line->numstyles].style = style;
	    line->styles[line->numstyles].direction = dir;
a4582 11
/*	Set IgnoreExcess element in the text object.
 *	--------------------------------------------
 */
void HText_setIgnoreExcess(HText *text, BOOL ignore)
{
    if (!text)
	return;

    text->IgnoreExcess = ignore;
}

d4904 1
a4904 1
	    CTRACE((tfp, "endStblTABLE: finally free %p\n", me->stbl));
d4919 1
a4919 1
int HText_endStblTABLE(HText *me)
d4955 1
a4955 1
	    CTRACE((tfp, "endStblTABLE: postpone free %p\n", me->stbl));
d4968 1
a4968 1
	    enclosing == 0 ? " NO" : "", enclosing));
d4970 1
a4970 1
    return enclosing != 0;
d6122 3
d6177 1
a6177 1
	    num, rel, cur, HTMainText));
d6210 1
a6210 1
    CTRACE((tfp, "  a=%p, l=%p, curanchor=%d\n", a, l, curanchor));
d6441 1
a6441 1
#define same_anchor_as_link(i,a,ta_same) (i >= 0 && a &&\
d6447 1
a6447 1
#define same_anchors(a1,a2,ta_same) (a1 && a2 &&\
d6854 1
a6854 3
    const char *ct = NULL;
    const char *ce = NULL;
    CompressFileType method = cftNone;
d6869 1
a6869 24
    /*
     * Check the anchor's content_type and content_encoding
     * elements for a gzip or Unix compressed file.  -FM
     */
    ct = HTAnchor_content_type(anchor);
    ce = HTAnchor_content_encoding(anchor);
    if (ce == NULL && ct != 0) {
	/*
	 * No Content-Encoding, so check
	 * the Content-Type.  -FM
	 */
	if (!strncasecomp(ct, "application/gzip", 16) ||
	    !strncasecomp(ct, "application/x-gzip", 18)) {
	    method = cftGzip;
	} else if (!strncasecomp(ct, "application/compress", 20) ||
		   !strncasecomp(ct, "application/x-compress", 22)) {
	    method = cftCompress;
	} else if (!strncasecomp(ct, "application/bzip2", 17) ||
		   !strncasecomp(ct, "application/x-bzip2", 19)) {
	    method = cftBzip2;
	}
    } else if (ce != 0) {
	method = HTEncodingToCompressType(ce);
    }
d6939 1
a6939 17
    switch (method) {
    case cftNone:
	suffix = "";
	break;
    case cftCompress:
	suffix = ".Z";
	break;
    case cftDeflate:
	suffix = ".zz";
	break;
    case cftGzip:
	suffix = ".gz";
	break;
    case cftBzip2:
	suffix = ".bz2";
	break;
    }
d7305 1
a7305 1
		LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
a7814 2
    int adjust = result;
    int ch;
d7816 11
a7826 6
    while (adjust > 0) {
	ch = UCH(string[adjust - 1]);
	if (isspace(ch) || IsSpecialAttrChar(ch)) {
	    --adjust;
	} else {
	    break;
d7828 3
a7830 4
    }
    if (result != adjust) {
	char *dst = string + adjust;
	char *src = dst;
d7832 6
a7837 4
	for (;;) {
	    src = LYSkipBlanks(src);
	    if ((*dst++ = *src++) == '\0')
		break;
a7838 1
	result = (dst - string - 1);
d7866 1
a7866 1
		      && HTCJK == NOCJK
a8353 2
    char *temp = NULL;

d8356 6
a8361 1
	return;
a8362 7

    HTSprintf0(&temp, message, NonNull(argument));

    statusline(temp);

    FREE(temp);
    return;
d8459 1
d8461 3
a8463 1
{"source-cache-mem", 0, 0};	/* dummy - kw */
d8470 1
a8470 1
	result = (HTMainAnchor->source_cache_file != 0);
d8482 1
a8482 1
	result = (HTMainAnchor->source_cache_chunk != 0);
d8495 1
a8495 4
	return FALSE;
    }

    if (useSourceCache()) {
d8532 1
a8532 2
	    return FALSE;
	}
d8534 9
a8542 3
	if (HText_HaveUserChangedForms(HTMainText)) {
	    /*
	     * Issue a warning.  Will not restore changed forms, currently.
d8544 12
a8555 14
	    HTAlert(RELOADING_FORM);
	}
	/* Set HTMainAnchor->protocol or HTMainAnchor->physical to convince
	 * the SourceCacheWriter to not regenerate the cache file (which
	 * would be an unnecessary "loop"). - kw
	 */
	HTAnchor_setProtocol(HTMainAnchor, &HTFile);
	ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, NULL);
	LYCloseInput(fp);
	if (ret == HT_PARTIAL_CONTENT) {
	    HTInfoMsg(gettext("Loading incomplete."));
	    CTRACE((tfp,
		    "SourceCache: `%s' has been accessed, partial content.\n",
		    HTLoadedDocumentURL()));
a8556 4
	ok = (BOOL) (ret == HT_LOADED || ret == HT_PARTIAL_CONTENT);

	CTRACE((tfp, "Reparse file %s\n", (ok ? "succeeded" : "failed")));

d8678 11
a8688 11
    return (HTMainText->clickable_images != clickable_images ||
	    HTMainText->pseudo_inline_alts != pseudo_inline_alts ||
	    HTMainText->verbose_img != verbose_img ||
	    HTMainText->raw_mode != LYUseDefaultRawMode ||
	    HTMainText->historical_comments != historical_comments ||
	    (HTMainText->minimal_comments != minimal_comments &&
	     !historical_comments) ||
	    HTMainText->soft_dquotes != soft_dquotes ||
	    HTMainText->old_dtd != Old_DTD ||
	    HTMainText->keypad_mode != keypad_mode ||
	    HTMainText->disp_cols != DISPLAY_COLS);
d9529 1
a9529 1
	if (HTCJK != NOCJK) {
d9543 1
a9543 1
			    tmp[j++] = cp[i];
d9578 4
a9581 4
	    int newlen = strlen(new_ptr->name);
	    int curlen = (HTCurSelectedOptionValue
			  ? strlen(HTCurSelectedOptionValue)
			  : 0);
d9670 1
a9670 1
    CTRACE((tfp, "GridText: Entering HText_beginInput\n"));
d9734 1
a9734 1
    f->disabled = HTFormDisabled;
d9751 1
a9751 1
	HTCJK != NOCJK &&
d9763 1
a9763 1
			tmp[j++] = IValue[i];
d9862 2
d9948 7
d10020 1
d10035 1
a10035 1
	    BOOL had_bracket = (f->type == F_OPTION_LIST_TYPE);
a10171 1
	HText_setIgnoreExcess(text, FALSE);
d10363 1
a10363 1
	    temp[0] = isdigit(text[have + j]) ? 'a' : '0';
d10419 2
a10420 2
	c1 = *str++;
	c2 = *str++;
d10424 1
a10424 1
	    c3 = *str++;
d11196 1
a11196 1
			my_data[anchor_count].data));
d11388 1
d11393 6
a11398 1
		    HTSprintf(&escaped1, "; filename=\"%s\"", val_used);
d11428 1
d11761 1
a11761 1
    charset_explicit = charset ? TRUE : FALSE;
d11814 1
a11814 1
	if (HTCJK != NOCJK) {
a11968 96
 * Cleanup new lines coming into a TEXTAREA from an external editor, or a
 * file, such that they are in a suitable format for TEXTAREA rendering,
 * display, and manipulation.  That means trimming off trailing whitespace
 * from the line, expanding TABS into SPACES, and substituting a printable
 * character for control chars, and the like.
 *
 * --KED 02/24/99
 */
static void cleanup_line_for_textarea(char *line,
				      int len)
{
    char tbuf[MAX_LINE];

    char *cp;
    char *p;
    char *s;
    int i;
    int n;

    /*
     * Whack off trailing whitespace from the line.
     */
    for (i = len, p = line + (len - 1); i != 0; p--, i--) {
	if (CanTrimTextArea(UCH(*p)))
	    *p = '\0';
	else
	    break;
    }

    if (strlen(line) != 0) {
	/*
	 * Expand any tab's, since they won't render properly in a TEXTAREA.
	 *
	 * [Is that "by spec", or just a "lynxism"?  As may be, it seems that
	 * such chars may cause other problems, too ...  with cursor movement,
	 * submit'ing, etc.  Probably needs looking into more deeply.]
	 */
	p = line;
	s = tbuf;

	while (*p) {
	    if ((cp = strchr(p, '\t')) != 0) {
		i = cp - p;
		s = (strncpy(s, p, i)) + i;
		n = TABSTOP - (i % TABSTOP);
		s = (strncpy(s, SPACES, n)) + n;
		p += (i + 1);

	    } else {

		strcpy(s, p);
		break;
	    }
	}

	/*
	 * Replace control chars with something printable.  Note that char
	 * substitution above 0x7f is dependent on the charset being used,
	 * and then only applies to the contiguous run of char values that
	 * are between 0x80, and the 1st real high-order-bit-set character,
	 * as specified by the charset.  In general (ie, for many character
	 * sets), that usually means the so-called "C1 control chars" that
	 * range from 0x80 thru 0x9f.  For EBCDIC machines, we only trim the
	 * (control) chars below a space (x'40').
	 *
	 * The assumption in all this is that the charset used in the editor,
	 * is compatible with the charset specified in lynx.
	 *
	 * [At some point in time, when/if lynx ever supports multibyte chars
	 * internally (eg, UCS-2, UCS-4, UTF-16, etc), this kind of thing may
	 * well cause problems.  But then, supporting such char sets will
	 * require massive changes in (most) all parts of the lynx code, so
	 * until then, we do the rational thing with char values that would
	 * otherwise foul the display, if left alone.  If you're implementing
	 * multibyte character set support, consider yourself to have been
	 * warned.]
	 */
	for (p = line, s = tbuf; *s != '\0'; p++, s++) {
#ifndef EBCDIC
	    *p = ((UCH(*s) < UCH(' ')) ||
		  (UCH(*s) == UCH('\177')) ||
		  ((UCH(*s) > UCH('\177')) &&
		   (UCH(*s) <
		    UCH(LYlowest_eightbit[current_char_set]))))
		? (char) SPLAT : *s;
#else
	    *p = (UCH(*s) < UCH(' ')) ? SPLAT : *s;
#endif
	}
	*p = '\0';
    }

    return;
}

/*
d12508 1
a12508 4
 * Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 * user's editor on that file, then transfer the contents of the resultant
 * edited file back into the TEXTAREA (expanding the size of the area, if
 * required).
d12510 7
a12516 3
 * Returns the number of lines that the cursor should be moved so that it
 * will end up on the 1st blank line of whatever number of trailing blank
 * lines there are in the TEXTAREA (there will *always* be at least one).
d12518 2
a12519 1
 * --KED 02/01/99
d12521 11
a12531 1
int HText_ExtEditForm(LinkInfo * form_link)
a12535 1
    char *ed_temp;
a12538 1
    TextAnchor *start_anchor = NULL;
a12539 1
    BOOLEAN firstanchor = TRUE;
a12541 2
    char ed_offset[10];
    int start_line = 0;
a12543 1
    int orig_cnt = 0;
a12545 4
    FormInfo *form = form_link->l_form;
    char *areaname = form->name;
    int form_num = form->number;

a12560 69
    ed_temp = (char *) malloc(LY_MAXPATH);
    if ((fp = LYOpenTemp(ed_temp, "", "w")) == 0) {
	FREE(ed_temp);
	return (0);
    }

    /*
     * Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     * write all of its lines (anchors) out to the edit temp file.
     *
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually get the data from the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
     *
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
     */
    anchor_ptr = HTMainText->first_anchor;

    while (anchor_ptr) {

	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {

	    if (firstanchor) {
		firstanchor = FALSE;
		start_anchor = anchor_ptr;
		start_line = anchor_ptr->line_num;
	    }
	    orig_cnt++;

	    /*
	     * Write the anchors' text to the temp edit file.
	     */
	    fputs(anchor_ptr->input_field->value, fp);
	    fputc('\n', fp);

	} else {

	    if (!firstanchor)
		break;
	}
	anchor_ptr = anchor_ptr->next;
    }
    LYCloseTempFP(fp);

    CTRACE((tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname));
    CTRACE((tfp, "GridText: invoking editor (%s) on tempfile\n", editor));

    /*
     * Go edit the TEXTAREA temp file, with the initial editor line
     * corresponding to the TEXTAREA line the cursor is on (if such
     * positioning is supported by the editor [as lynx knows it]).
     */
    ed_offset[0] = 0;		/* pre-ANSI compilers don't initialize aggregates - TD */
    if (((entry_line - start_line) > 0) && editor_can_position())
	sprintf(ed_offset, "%d", ((entry_line - start_line) + 1));

    edit_temporary_file(ed_temp, ed_offset, NULL);

    CTRACE((tfp, "GridText: returned from editor (%s)\n", editor));

a12581 1
	    free(ed_temp);
a12710 2
	cleanup_line_for_textarea(line, len0 + len);

d12767 100
d12878 1
a12878 1
    return (exit_line - entry_line);
a12893 2
    char *areaname = form->name;
    int form_num = form->number;
a12907 12
     *
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually expand the *1st* TEXTAREA
     * in the page that matches.  We should probably assign a unique
     * id to each TEXTAREA in a page, and match on that, to avoid this
     * (potential) problem.
     *
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d12913 1
a12913 4
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {
d12944 1
a12944 1
	    newlines, areaname));
a12981 2
    char *areaname = form->name;
    int form_num = form->number;
d13022 1
a13022 1
	((size = stat_info.st_size) == 0)) {
a13067 12
     *
     * [Finding the TEXTAREA we're actually *in* with these attributes
     * isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     * and there *could* be TEXTAREA's with the same "name".  If that
     * should ever be true, we'll actually insert data into the *1st*
     * TEXTAREA in the page that matches.  We should probably assign
     * a unique id to each TEXTAREA in a page, and match on that, to
     * avoid this (potential) problem.
     *
     * Since the odds of "false matches" *actually* happening in real
     * life seem rather small though, we'll hold off doing this, for a
     * rainy day ...]
d13073 1
a13073 5
	if ((anchor_ptr->link_type == INPUT_ANCHOR) &&
	    (anchor_ptr->input_field->type == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num) &&
	    !strcmp(anchor_ptr->input_field->name, areaname)) {

a13206 2
	cleanup_line_for_textarea(line, len);

d13345 1
a13345 1
	    LynxChangeStyle(CStyle.style, CStyle.direction);
d13459 1
a13459 1
	LynxChangeStyle(CStyle.style, CStyle.direction);
d13826 1
a13826 1
		} else if (i == last_i - 2 && HTCJK != NOCJK &&
d13919 1
a13919 1
	    } else if (HTCJK != NOCJK && is8bits(buffer[0])) {
d14072 1
a14072 1
	redraw_part_of_line(todr1, text, strlen(text), HTMainText);
d14114 257
@


1.7
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1712 1
a1712 1
	int total_pages = ((text->Lines + display_lines - 1)
d1719 1
a1719 1
		((text->top_of_screen >= start_of_last_page)
d7293 1
a7293 1
		   && ((text->top_of_screen + display_lines) < text->Lines));
@


1.6
log
@Backport of a fix from lynx2.8.6dev.16 which prevents a crash.
Reported by Alexey Dobriyan. ok miod@@
@
text
@d2 2
a3 2
**		===============================
*/
d16 1
d57 6
d64 1
a64 1
#  define DISPLAY_COLS (LYwideLines ? MAX_COLS : LYcols)
d67 3
a69 2
			    ? DISPLAY_COLS : (LYtableCols * LYcols)/12)	\
			   : LYcols)
d71 2
a72 2
#  define DISPLAY_COLS LYcols
#  define WRAP_COLS(text) LYcols
d78 2
a79 4
PRIVATE void HText_trimHightext PARAMS((
	HText *		text,
	BOOLEAN		final,
	int		stop_before));
d82 1
a82 1
PRIVATE void LynxResetScreenCache NOARGS
d93 2
a94 2
struct _HTStream {			/* only know it as object */
    CONST HTStreamClass *       isa;
a97 2
#define TITLE_LINES  1

d110 1
a110 1
PUBLIC HTkcode last_kcode = NOKANJI;	/* 1997/11/14 (Fri) 09:09:26 */
d112 1
d121 2
a122 2
PUBLIC HText * HTMainText = NULL;		/* Equivalent of main window */
PUBLIC HTParentAnchor * HTMainAnchor = NULL;	/* Anchor for HTMainText */
d124 2
a125 2
PUBLIC char * HTAppName = LYNX_NAME;		/* Application name */
PUBLIC char * HTAppVersion = LYNX_VERSION;	/* Application version */
d127 12
a138 12
PUBLIC int HTFormNumber = 0;
PUBLIC int HTFormFields = 0;
PUBLIC char * HTCurSelectGroup = NULL;		/* Form select group name */
PRIVATE int HTCurSelectGroupCharset = -1;	/* ... and name's charset */
PUBLIC int HTCurSelectGroupType = F_RADIO_TYPE;	/* Group type */
PUBLIC char * HTCurSelectGroupSize = NULL;	/* Length of select */
PRIVATE char * HTCurSelectedOptionValue = NULL;	/* Select choice */

PUBLIC char * checked_box = "[X]";
PUBLIC char * unchecked_box = "[ ]";
PUBLIC char * checked_radio = "(*)";
PUBLIC char * unchecked_radio = "( )";
d140 2
a141 2
PRIVATE BOOLEAN underline_on = OFF;
PRIVATE BOOLEAN bold_on      = OFF;
d144 2
a145 2
PUBLIC int LYCacheSource = SOURCE_CACHE_NONE;
PUBLIC int LYCacheSourceForAborted = SOURCE_CACHE_FOR_ABORTED_DROP;
d149 4
a152 4
PUBLIC BOOLEAN LYShowScrollbar = FALSE;
PUBLIC BOOLEAN LYsb_arrow = TRUE;
PUBLIC int LYsb_begin = -1;
PUBLIC int LYsb_end = -1;
d160 2
a161 1
PRIVATE void * LY_check_calloc PARAMS((size_t nmemb, size_t size));
d183 3
a185 3
	unsigned int	direction:2;   /* on or off */
	unsigned int	horizpos:14;   /* horizontal position of this change */
	unsigned int	style:16;      /* which style to change to */
d196 7
a202 1
enum { POOL_SIZE = (8192 - 4*sizeof(void*) - sizeof(struct _HTPool*) - sizeof(int)) / sizeof(pool_data) };
d205 2
a206 2
    pool_data  data[POOL_SIZE];
    struct _HTPool* prev;
d257 5
a261 7
 *   Allocates 'n' items in the pool of type 'HTPool' pointed by 'poolptr'.
 *   Returns a pointer to the "allocated" memory or NULL if fails.
 *   Updates 'poolptr' if necessary.
 */
PRIVATE pool_data* ALLOC_IN_POOL ARGS2(
	HTPool**,	ppoolptr,
	unsigned,	request)
d263 2
a264 2
    HTPool* pool = *ppoolptr;
    pool_data* ptr;
d283 2
a284 1
	    HTPool* newpool = (HTPool*)LY_CALLOC(1, sizeof(HTPool));
d292 1
a292 1
	   }
d299 1
a299 1
 *   Returns a pointer to initialized pool of type 'HTPool', or NULL if fails.
d301 1
a301 1
PRIVATE HTPool* POOL_NEW NOARGS
d303 2
a304 1
    HTPool* poolptr = (HTPool*)LY_CALLOC(1, sizeof(HTPool));
d313 1
a313 1
 *   Frees a pool of type 'HTPool' pointed by poolptr.
d315 1
a315 2
PRIVATE void POOL_FREE ARGS1(
	HTPool*,	poolptr)
d317 3
a319 2
    HTPool* cur = poolptr;
    HTPool* prev;
d331 4
a334 4
	struct _line    *next;
	struct _line    *prev;
	unsigned short	offset;	/* Implicit initial spaces */
	unsigned short	size;	/* Number of characters */
d336 2
a337 2
	HTStyleChange*  styles;
	unsigned short  numstyles;
d339 1
a339 1
	char	data[1];	/* Space for terminator at least! */
d342 1
d344 1
a344 2
#define LINE_SIZE(size) (sizeof(HTLine)+(size))   /* Allow for terminator */

d346 1
d367 2
a368 2
	HTLine	base;
	char    data[MAX_LINE+2];
d374 13
a386 12
	struct _TextAnchor *	next;
	struct _TextAnchor *	prev;		/* www_user_search only! */
	int			number;		/* For user interface */
	int			line_num;	/* Place in document */
	short			line_pos;	/* Bytes/chars - extent too */
	short			extent;		/* (see HText_trimHightext) */
	BOOL			show_anchor;	/* Show the anchor? */
	BOOL			inUnderline;	/* context is underlined */
	BOOL			expansion_anch; /* TEXTAREA edit new anchor */
	char			link_type;	/* Normal, internal, or form? */
	FormInfo *		input_field;	/* Info for form links */
	HiliteList		lites;
d388 1
a388 1
	HTChildAnchor *		anchor;
d392 2
a393 2
	char *			name;		/* ID value of TAB */
	int			column;		/* Zero-based column value */
d396 31
d428 5
a432 5
/*	Notes on struct _Htext:
**	next_line is valid if stale is false.
**	top_of_screen line means the line at the top of the screen
**			or just under the title if there is one.
*/
d434 1
a434 1
	HTParentAnchor *	node_anchor;
d436 17
a452 17
	HTLine *		last_line;
	HTLineTemp		temp_line[2];
	int			Lines;		/* Number of them */
	TextAnchor *		first_anchor;	/* double-linked on demand */
	TextAnchor *		last_anchor;
	TextAnchor *		last_anchor_before_stbl;
	TextAnchor *		last_anchor_before_split;
	HTList *		forms;		/* also linked internally */
	int			last_anchor_number;	/* user number */
	BOOL			source;		/* Is the text source? */
	BOOL			toolbar;	/* Toolbar set? */
	HTList *		tabs;		/* TAB IDs */
	HTList *		hidden_links;	/* Content-less links ... */
	int			hiddenlinkflag; /*  ... and how to treat them */
	BOOL			no_cache;	/* Always refresh? */
	char			LastChar;	/* For absorbing white space */
	BOOL			IgnoreExcess;	/* Ignore chars at wrap point */
d455 11
a465 11
	HTStyle *		style;			/* Current style */
	int			display_on_the_fly;	/* Lines left */
	int			top_of_screen;		/* Line number */
	HTLine *		top_of_screen_line;	/* Top */
	HTLine *		next_line;		/* Bottom + 1 */
	unsigned		permissible_split;	/* in last line */
	BOOL			in_line_1;		/* of paragraph */
	BOOL			stale;			/* Must refresh */
	BOOL			page_has_target; /* has target on screen */
	BOOL			has_utf8; /* has utf-8 on screen or line */
	BOOL			had_utf8; /* had utf-8 when last displayed */
d467 2
a468 2
	int			first_lineno_last_disp_partial;
	int			last_lineno_last_disp_partial;
d470 2
a471 2
	STable_info *		stbl;
	HTList *		enclosed_stbl;
d473 2
a474 2
	HTkcode			kcode;			/* Kanji code? */
	HTkcode			specified_kcode;	/* Specified Kanji code */
d476 13
a488 20
	enum _detected_kcode  { DET_SJIS, DET_EUC, DET_NOTYET, DET_MIXED }
				detected_kcode;		/* Detected Kanji code */
	enum _SJIS_status     { SJIS_state_neutral, SJIS_state_in_kanji,
				SJIS_state_has_bad_code } SJIS_status;
	enum _EUC_status      { EUC_state_neutral, EUC_state_in_kanji,
				EUC_state_in_kana, EUC_state_has_bad_code }
				EUC_status;
#endif
	enum grid_state       { S_text, S_esc, S_dollar, S_paren,
				S_nonascii_text, S_dollar_paren,
				S_jisx0201_text }
				state;		/* Escape sequence? */
	int			kanji_buf;	/* Lead multibyte */
	int			in_sjis;	/* SJIS flag */
	int			halted;		/* emergency halt */

	BOOL			have_8bit_chars; /* Any non-ASCII chars? */
	LYUCcharset *		UCI;		/* node_anchor UCInfo */
	int			UCLYhndl;	/* charset we are fed */
	UCTransParams		T;
d490 2
a491 2
	HTStream *		target;		/* Output stream */
	HTStreamClass		targetClass;	/* Output routines */
d493 1
a493 1
	HTPool*			pool;		/* this HText memory pool */
d496 14
a509 14
	/*
	* Parse settings when this HText was generated.
	*/
	BOOL			clickable_images;
	BOOL			pseudo_inline_alts;
	BOOL			verbose_img;
	BOOL			raw_mode;
	BOOL			historical_comments;
	BOOL			minimal_comments;
	BOOL			soft_dquotes;
	short			old_dtd;
	short			keypad_mode;
	short			disp_lines;	/* Screen size */
	short			disp_cols;	/* Used for reports only */
d514 1
a514 3
PUBLIC void* HText_pool_calloc ARGS2(
	HText *,	text,
	unsigned,	size)
d516 1
a516 1
    return (void*) ALLOC_IN_POOL(&text->pool, size);
d519 1
a519 1
PRIVATE void HText_AddHiddenLink PARAMS((HText *text, TextAnchor *textanchor));
d522 13
a534 2
PUBLIC BOOL can_justify_here;
PUBLIC BOOL can_justify_here_saved;
a535 8
PUBLIC BOOL can_justify_this_line;/* =FALSE if line contains form objects */
PUBLIC int wait_for_this_stacked_elt;/* -1 if can justify contents of the
    element on the op of stack. If positive - specifies minimal stack depth
    plus 1 at which we can justify element (can be MAX_LINE+2 if
    ok_justify ==FALSE or in psrcview. */
PUBLIC BOOL form_in_htext;/*to indicate that we are in form (since HTML_FORM is
  not stacked in the HTML.c */
PUBLIC BOOL in_DT = FALSE;
d537 1
a537 1
PUBLIC BOOL can_justify_stack_depth;/* can be 0 or 1 if all code is correct*/
a539 1

d541 2
a542 2
    int byte_len;		/*length in bytes*/
    int cell_len;		/*length in cells*/
d545 1
a545 2
static int justify_start_position;/* this is an index of char from which
    justification can start (eg after "* " preceeding <li> text) */
d547 3
a549 1
static int ht_num_runs;/*the number of runs filled*/
d552 1
a552 1
static TextAnchor* last_anchor_of_previous_line;
d555 1
a555 1
PUBLIC void ht_justify_cleanup NOARGS
d561 2
a562 1
	? 30000/*MAX_NESTING*/+2 /*some unreachable value*/ : -1;
d573 1
a573 1
PUBLIC void mark_justify_start_position ARGS1(void*,text)
d575 2
a576 2
    if (text && ((HText*)text)->last_line)
	justify_start_position = ((HText*)text )->last_line->size;
a578 1

a586 2


d588 1
a588 1
 *  Boring static variable used for moving cursor across
d598 2
a599 2
PRIVATE char underscore_string[MAX_LINE + 1];
PUBLIC char star_string[MAX_LINE + 1];
d601 4
a604 3
PRIVATE int ctrl_chars_on_this_line = 0; /* num of ctrl chars in current line */
PRIVATE int utfxtra_on_this_line = 0; /* num of UTF-8 extra bytes in line,
				       they *also* count as ctrl chars. */
d611 5
a615 6
PRIVATE HTStyle default_style =
	{ 0,  "(Unstyled)", 0, "",
	(HTFont)0, 1, HT_BLACK,		0, 0,
	0, 0, 0, HT_LEFT,		1, 0,	0,
	NO, NO, 0, 0,			0 };

d617 2
a619 2
PRIVATE HTList * loaded_texts = NULL;	 /* A list of all those in memory */
PUBLIC  HTList * search_queries = NULL;  /* isindex and whereis queries   */
d621 1
a621 1
PRIVATE void free_all_texts NOARGS;
d624 3
a626 9
PRIVATE BOOL HText_TrueEmptyLine PARAMS((
	HTLine *	line,
	HText *		text,
	BOOL		IgnoreSpaces));

PRIVATE int HText_TrueLineSize PARAMS((
	HTLine *	line,
	HText *		text,
	BOOL		IgnoreSpaces));
d631 6
a636 6
 *  text->halted = 1: have set fake 'Z' and output a message
 *		   2: next time when HText_appendCharacter is called
 *		      it will append *** MEMORY EXHAUSTED ***, then set
 *		      to 3.
 *		   3: normal text output will be suppressed (but not anchors,
 *		      form fields etc.)
d638 1
a638 1
PRIVATE void HText_halt NOARGS
d651 12
a662 14
 *  Check whether factor*min(bytes,MIN_NEEDED_MEM) is available,
 *  or bytes if factor is 0.
 *  MIN_NEEDED_MEM and factor together represent a security margin,
 *  to take account of all the memory allocations where we don't check
 *  and of buffers which may be emptied before HTCheckForInterupt()
 *  is (maybe) called and other things happening, with some chance of
 *  success.
 *  This just tries to malloc() the to-be-checked-for amount of memory,
 *  which might make the situation worse depending how allocation works.
 *  There should be a better way... - kw
 */
PRIVATE BOOL mem_is_avail ARGS2(
    size_t,	factor,
    size_t,	bytes)
d665 1
d680 5
a684 7
 *  Replacement for calloc which checks for "enough" free memory
 *  (with some security margins) and tries various recovery actions
 *  if deemed necessary. - kw
 */
PRIVATE void * LY_check_calloc ARGS2(
    size_t,	nmemb,
    size_t,	size)
d687 1
d693 11
a703 9
	HText * t = (HText *) HTList_objectAt(loaded_texts, i);
	CTRACE((tfp, "\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n",
		    i + 1, n,
		    ((t && t->node_anchor &&
		      t->node_anchor->address) ?
		     t->node_anchor->address : "unknown anchor"),
		    ((t && t->node_anchor &&
		      t->node_anchor->post_data) ?
		     " with POST data" : "")));
d731 42
d777 1
a777 2
PRIVATE void LYClearHiText ARGS1(
	TextAnchor *,	a)
d784 1
d790 3
a792 4
PRIVATE void LYSetHiText ARGS3(
	TextAnchor *,	a,
	char *,		text,
	int,		len)
d806 3
a808 4
PRIVATE void LYAddHiText ARGS3(
	TextAnchor *,	a,
	char *,		text,
	int,		x)
d831 1
a831 3
PRIVATE int LYAdjHiTextPos ARGS2(
	TextAnchor *,	a,
	int,		count)
d851 1
a851 3
PRIVATE char *LYGetHiTextStr ARGS2(
	TextAnchor *,	a,
	int,		count)
d868 1
a868 3
PRIVATE int LYGetHiTextPos ARGS2(
	TextAnchor *,	a,
	int,		count)
d885 1
a885 3
PRIVATE void LYCopyHiText ARGS2(
	TextAnchor *,	a,
	TextAnchor *,	b)
d891 1
a891 1
    for (count = 0; ; ++count) {
d902 1
a902 2
PRIVATE void HText_getChartransInfo ARGS1(
	HText *,	me)
d907 1
d916 1
a916 2
PRIVATE void PerFormInfo_free ARGS1(
    PerFormInfo *,	form)
d925 1
a925 2
PRIVATE void free_form_fields ARGS1(
	FormInfo *,	input_field)
d928 1
a928 1
     *  Free form fields.
d933 5
a937 5
	 *  Free off option lists if present.
	 *  It should always be present for F_OPTION_LIST_TYPE
	 *  unless we had invalid markup which prevented
	 *  HText_setLastOptionValue from finishing its job
	 *  and left the input field in an insane state. - kw
d941 1
d951 3
a953 3
	 *  Don't free the value field on option
	 *  lists since it points to a option value
	 *  same for orig value.
d973 1
a973 2
PRIVATE void FormList_delete ARGS1(
    HTList *,		forms)
d977 2
a978 1
    while ((form = (PerFormInfo *)HTList_nextObject(cur)) != NULL)
d983 10
d994 3
a996 4
**			---------------
*/
PUBLIC HText *	HText_new ARGS1(
	HTParentAnchor *,	anchor)
d1000 1
a1000 1
    int status, VMType=3, VMTotal;
d1002 3
a1004 2
    HTLine * line = NULL;
    HText * self = typecalloc(HText);
d1016 3
a1018 3
     *  If the previously shown text had UTF-8 characters on screen,
     *  remember this in the newly created object.  Do this now, before
     *  the previous object may become invalid. - kw
d1031 1
a1031 1
    if (!loaded_texts)	{
d1039 4
a1042 4
     *  Links between anchors & documents are a 1-1 relationship.  If
     *  an anchor is already linked to a document we didn't call
     *  HTuncache_current_document(),  so we'll check now
     *  and free it before reloading. - Dick Wesseling (ftu@@fi.ruu.nl)
d1046 1
a1046 1
	CTRACE((tfp, "GridText: Auto-uncaching\n")) ;
d1049 2
a1050 2
	((HText *)anchor->document)->node_anchor = NULL;
	HText_free((HText *)anchor->document);
d1063 1
a1063 1
	HText_free((HText *)HTList_removeFirstObject(loaded_texts));
d1109 7
a1115 7
     *  If we are going to render the List Page, always merge in hidden
     *  links to get the numbering consistent if form fields are numbered
     *  and show up as hidden links in the list of links.
     *  If we are going to render a bookmark file, also always merge in
     *	hidden links, to get the link numbers consistent with the counting
     *  in remove_bookmark_link().  Normally a bookmark file shouldn't
     *	contain any entries with empty titles, but it might happen. - kw
d1125 1
a1125 1
		      anchor->post_data)
d1137 5
a1141 4
    /*  mark_htext_as_source == TRUE if we are parsing html file (and psrc_view is
     *	    set temporary to false at creation time)
     *	psrc_view == TRUE if source of the text produced by some lynx module
     *	    (like ftp browsers) is requested). - VH
d1143 3
a1145 1
    self->source = (BOOL) (LYpsrc ? mark_htext_as_source || psrc_view : HTOutputFormat == WWW_SOURCE);
d1148 2
a1149 2
    HTAnchor_setDocument(anchor, (HyperDoc *)self);
    HTFormNumber = 0;  /* no forms started yet */
d1171 1
a1171 1
     *  Check the kcode setting if the anchor has a charset element. -FM
d1177 4
a1180 4
     *	Memory leak fixed.
     *  05-29-94 Lynx 2-3-1 Garrett Arch Blythe
     *	Check to see if our underline and star_string need initialization
     *		if the underline is not filled with dots.
d1184 1
a1184 1
	 *  Create an array of dots for the UNDERSCORES macro. -FM
d1186 2
a1187 2
	memset(underscore_string, '.', (MAX_LINE-1));
	underscore_string[(MAX_LINE-1)] = '\0';
d1190 1
a1190 1
	 *  Create an array of underscores for the STARS macro. -FM
d1192 2
a1193 2
	memset(star_string, '_', (MAX_LINE-1));
	star_string[(MAX_LINE-1)] = '\0';
d1197 1
a1197 1
    underline_on = FALSE; /* reset */
d1206 2
a1207 2
	display_partial = TRUE;	 /* enable HTDisplayPartial() */
	NumOfLines_partial = 0;	 /* initialize */
d1211 4
a1214 4
     *  These two fields should only be set to valid line numbers
     *  by calls of display_page during partial displaying.  This
     *  is just so that the FIRST display_page AFTER that can avoid
     *  repainting the same lines on the screen. - kw
d1216 1
a1216 2
    self->first_lineno_last_disp_partial =
	self->last_lineno_last_disp_partial = -1;
d1226 6
a1231 8
**			---------------
**
**      Stream is assumed open and left open.
*/
PUBLIC HText *  HText_new2 ARGS2(
	HTParentAnchor *,	anchor,
	HTStream *,		stream)

d1233 1
a1233 1
    HText * this = HText_new(anchor);
d1236 2
a1237 2
	this->target = stream;
	this->targetClass = *stream->isa;	/* copy action procedures */
d1239 1
a1239 1
    return this;
d1243 3
a1245 4
**	----------------
*/
PUBLIC void HText_free ARGS1(
	HText *,	self)
d1264 3
a1266 2
    while (self->first_anchor) {		/* Free off anchor array */
	TextAnchor * l = self->first_anchor;
d1278 1
a1278 1
     *  Free the tabs list. -FM
d1281 2
a1282 2
	HTTabID * Tab = NULL;
	HTList * cur = self->tabs;
d1284 1
a1284 1
	while (NULL != (Tab = (HTTabID *)HTList_nextObject(cur))) {
d1293 1
a1293 1
     *  Free the hidden links list. -FM
d1296 1
a1296 6
	char * href = NULL;
	HTList * cur = self->hidden_links;

	while (NULL != (href = (char *)HTList_nextObject(cur)))
	    FREE(href);
	HTList_delete(self->hidden_links);
d1301 2
a1302 2
     *  Invoke HTAnchor_delete() to free the node_anchor
     *  if it is not a destination of other links. -FM
d1321 1
a1321 1
	HTAnchor_setDocument(self->node_anchor, (HyperDoc *)0);
d1325 2
a1326 2
	     *  Make sure HTMainAnchor won't point
	     *  to an invalid structure. - KW
d1336 2
a1337 3
**		---------------
*/

d1340 6
a1345 7
**	-------------
*/
PRIVATE int display_line ARGS4(
	HTLine *,	line,
	HText *,	text,
	int,		scrline GCC_UNUSED,
	CONST char*,	target GCC_UNUSED)
d1352 1
d1355 1
d1359 1
a1359 1
    BOOL inbold=NO, inunderline=NO;
d1362 2
a1363 2
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
d1365 2
a1366 1
    BOOL intarget=NO;
d1372 10
a1381 1
    text->has_utf8 = NO; /* use as per-line flag, except with ncurses */
d1385 3
a1387 3
     *  Set up the multibyte character buffer,
     *  and clear the line to which we will be
     *  writing.
d1393 2
a1394 2
     *  Add offset, making sure that we do not
     *  go over the COLS limit on the display.
d1396 3
a1398 3
    j = (int)line->offset;
    if (j > (int)DISPLAY_COLS - 1)
	j = (int)DISPLAY_COLS - 1;
d1400 1
a1400 1
    SLsmg_forward (j);
d1408 2
a1409 2
    for (i = 0; i < j; i++)
	LYaddch (' ');
d1413 2
a1414 2
     *  Add the data, making sure that we do not
     *  go over the COLS limit on the display.
d1422 1
a1422 1
     *  If the target is on this line, it will be emphasized.
d1427 4
a1430 4
				       target,
				       text->T.output_utf8, YES,
				       &HitOffset,
				       &LenNeeded);
d1432 1
a1432 1
	    if (((int)line->offset + LenNeeded) >= DISPLAY_COLS) {
d1446 1
a1446 1
    while ((i < DISPLAY_COLS) && ((buffer[0] = *data) != '\0')) {
d1453 4
a1456 4
					    target,
					    text->T.output_utf8, YES,
					    &HitOffset,
					    &LenNeeded);
d1464 4
a1467 2
		    if (inbold)		lynx_start_bold();
		    if (inunderline)	lynx_start_underline();
d1476 1
a1476 1
#if defined(USE_COLOR_STYLE) || defined(SLSC)
d1480 2
a1481 3
	       i >= (int) (CStyle.horizpos + line->offset + 1))
	{
	    LynxChangeStyle (CStyle.style, CStyle.direction);
d1488 7
a1494 7
	    case LY_UNDERLINE_START_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    inunderline = YES;
		    if (!intarget) {
d1496 4
a1499 4
			if (LYShowColor == SHOW_COLOR_NEVER)
			    lynx_start_bold();
			else
			    lynx_start_underline();
d1501 2
a1502 3
			lynx_start_underline();
#endif	/* PDCURSES */
		    }
d1504 2
a1505 1
		break;
d1507 7
a1513 7
	    case LY_UNDERLINE_END_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    inunderline = NO;
		    if (!intarget) {
d1521 1
a1521 2
#endif	/* PDCURSES */
		    }
d1523 2
a1524 1
		break;
d1526 5
a1530 5
	    case LY_BOLD_START_CHAR:
		inbold = YES;
		if (!intarget)
		    lynx_start_bold();
		break;
d1532 5
a1536 5
	    case LY_BOLD_END_CHAR:
		inbold = NO;
		if (!intarget)
		    lynx_stop_bold();
		break;
d1538 5
a1542 5
#endif
	    case LY_SOFT_NEWLINE:
		if (!dump_output_immediately) {
		    LYaddch('+');
		    i++;
d1544 1
a1544 1
		    i_after_tgt++;
d1546 16
a1561 1
		}
d1563 7
d1571 1
a1571 24
	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		}
		/* FALLTHRU */

	    default:
d1574 7
a1580 8
		if (!intarget && cp_tgt && i >= i_start_tgt) {
		    /*
		     *  Start the emphasis.
		     */
		    if (data > cp_tgt) {
			LYstartTargetEmphasis();
			intarget = YES;
		    }
d1582 1
d1585 17
a1601 23
		i++;
		if (text->T.output_utf8 && is8bits(buffer[0])) {
		    text->has_utf8 = YES;
		    utf_extra = utf8_length(text->T.output_utf8, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])
#ifndef CONV_JISX0201KANA_JISX0208KANA
		    && kanji_code != SJIS
#endif
		) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    if (i >= DISPLAY_COLS) goto after_while;

d1609 7
a1615 9
		     *  For now, load 'M' into LastDisplayChar,
		     *  but we should check whether it's white
		     *  and if so, use ' '.  I don't know if
		     *  there actually are white CJK characters,
		     *  and we're loading ' ' for multibyte
		     *  spacing characters in this code set,
		     *  but this will become an issue when
		     *  the development code set's multibyte
		     *  character handling is used. -FM
d1618 9
a1626 3
		} else {
		    LYaddstr(buffer);
		    LastDisplayChar = buffer[0];
d1628 7
a1634 2
	} /* end of switch */
    } /* end of while */
a1635 1
after_while:
d1643 1
a1643 1
     *  Add the return.
d1657 2
a1658 3
    while (current_style < line->numstyles)
    {
	LynxChangeStyle (CStyle.style, CStyle.direction);
d1663 1
a1663 1
    return(0);
d1667 3
a1669 4
**	---------------------
*/
PRIVATE void display_title ARGS1(
	HText *,	text)
a1672 1
    char *cp = NULL;
d1678 1
a1678 1
     *  Make sure we have a text structure. -FM
d1683 1
a1683 1
    lynx_start_title_color ();
d1694 1
a1694 1
     *  Load the title field. -FM
d1699 1
d1702 1
a1702 12
     *  There shouldn't be any \n in the title field,
     *  but if there is, lets kill it now.  Also trim
     *  any trailing spaces. -FM
     */
    if ((cp = strchr(title,'\n')) != NULL)
	*cp = '\0';
    i = (*title ? (strlen(title) - 1) : 0);
    while ((i >= 0) && title[i] == ' ')
	title[i--] = '\0';

    /*
     *  Generate the page indicator (percent) string.
d1706 1
a1706 1
	percent[0] = '\0';	/* Null string */
d1708 1
a1708 1
	text->top_of_screen <= 99999 && text->Lines <= 999999) {
d1711 6
a1716 14
    } else if ((text->Lines + 1) > (display_lines) &&
	(display_lines) > 0) {
	/*
	 *  In a small attempt to correct the number of pages counted....
	 *    GAB 07-14-94
	 *
	 *  In a bigger attempt (hope it holds up 8-)....
	 *    FM 02-08-95
	 */
	int total_pages =
		(((text->Lines + 1) + (display_lines - 1))/(display_lines));
	int start_of_last_page =
		((text->Lines + 1) < display_lines) ? 0 :
		((text->Lines + 1) - display_lines);
d1719 3
a1721 3
		((text->top_of_screen >= start_of_last_page) ?
						 total_pages :
		    ((text->top_of_screen + display_lines)/(display_lines))),
d1724 1
a1724 1
	percent[0] = '\0';	/* Null string */
d1728 3
a1730 3
     *  Generate and display the title string, with page indicator
     *  if appropriate, preceded by the toolbar token if appropriate,
     *  and truncated if necessary. -FM & KW
d1734 1
a1734 1
	    (tmp = typecallocn(unsigned char, (strlen(title) + 256)))) {
d1736 1
a1736 1
		TO_EUC((unsigned char *)title, tmp);
d1738 1
a1738 1
		TO_SJIS((unsigned char *)title, tmp);
d1741 1
a1741 1
		    if (title[i] != CH_ESC) {  /* S/390 -- gil -- 1487 */
d1747 1
a1747 1
	    StrAllocCopy(title, (CONST char *)tmp);
d1767 3
a1769 1
	    LYaddch(c); LYaddch(c); LYaddch(c);
d1773 3
a1775 1
	    LYaddch(ACS_RARROW); LYaddch(ACS_RARROW); LYaddch(ACS_RARROW);
d1780 13
d1798 2
a1799 2
	 *  Truncation takes into account the possibility that
	 *  multibyte characters might be present. -HS (H. Senshu)
d1802 2
a1803 1
	last = (int)strlen(percent) + CHAR_WIDTH;
d1813 1
d1822 1
a1822 1
	LYmove(0, LYcols - 1);
d1826 1
a1826 1
	LYmove(1, 0);			/* As after \n */
d1834 1
a1834 1
    lynx_stop_title_color ();
d1840 2
a1841 2
**	---------------------
*/
d1843 1
a1843 2
PRIVATE void display_scrollbar ARGS1(
	HText *,	text)
d1846 2
a1847 2
    int h = display_lines - 2 * (LYsb_arrow!=0); /* Height of the scrollbar */
    int off = (LYsb_arrow != 0);		 /* Start of the scrollbar */
d1852 1
a1852 1
	|| (text->Lines + 1) <= display_lines)
d1855 1
a1855 1
    if (text->top_of_screen >= text->Lines + 1 - display_lines) {
d1857 1
a1857 1
	shown = text->Lines + 1 - text->top_of_screen;
d1865 1
a1865 1
    sh = (shown*h + text->Lines/2)/(text->Lines + 1);
d1882 2
a1883 2
	    1. * (h - sh - 1) * text->top_of_screen
		/ (text->Lines - display_lines + 1));
d1900 1
a1900 1
	LYmove(1, LYcols + LYshiftWin - 1);
d1914 1
a1914 1
    for (i=1; i <= h; i++) {
d1916 1
a1916 1
	if (i-1 <= top_skip && i > top_skip)
d1918 1
a1918 1
	if (i-1 <= h - bot_skip && i > h - bot_skip)
d1921 1
a1921 1
	LYmove(i + off, LYcols + LYshiftWin - 1);
d1942 1
a1942 1
	LYmove(h + 2, LYcols + LYshiftWin - 1);
d1951 1
a1951 1
#define display_scrollbar(text) /*nothing*/
a1953 1

d1955 5
a1959 6
**	-------------
*/
PRIVATE void display_page ARGS3(
	HText *,	text,
	int,		line_number,
	char *,		target)
d1961 1
a1961 1
    HTLine * line = NULL;
d1963 2
d1966 1
a1966 1
    char *cp;
a1968 1
    int last_screen;
d1977 1
d1986 3
a1988 3
	 *  Check whether to force a screen clear to enable scrollback,
	 *  or as a hack to fix a reverse clear screen problem for some
	 *  curses packages. - shf@@access.digex.net & seldon@@eskimo.com
d1997 1
a1997 1
	nlinks = 0;  /* set number of links to 0 */
a1999 1

d2003 1
a2003 2
	text->first_lineno_last_disp_partial =
	    text->last_lineno_last_disp_partial = -1;
d2008 2
a2009 1
    if (target && *target == '\0') target = NULL;
d2012 3
a2014 3
	/*  No screen space to display anything!
	 *  returning here makes it more likely we will survive if
	 *  an xterm is temporarily made very small. - kw */
a2017 1
    last_screen = text->Lines - (display_lines - 2);
d2019 1
d2021 1
a2021 11
    /*
     *  Constrain the line number to be within the document.
     */
    if (text->Lines < (display_lines))
	line_number = 0;
    else if (line_number > text->Lines)
	line_number = last_screen;
    else if (line_number < 0)
	line_number = 0;

    for (i = 0, line = FirstHTLine(text);		/* Find line */
d2023 1
a2023 1
	 i++, line = line->next) {			/* Loop */
d2035 1
a2035 1
	    nlinks = 0;  /* set number of links to 0 */
d2041 1
a2041 1
    } /* Loop */
d2045 5
a2049 5
	/*
	 *  current_char_set has changed since last invocation,
	 *  and it's not just 7-bit.
	 *  Also we don't want to do this for -dump and -source etc.
	 */
a2051 3
	/*
	 *  Currently implemented only for LINUX
	 */
d2059 3
a2061 3
     *  Check whether to force a screen clear to enable scrollback,
     *  or as a hack to fix a reverse clear screen problem for some
     *  curses packages. - shf@@access.digex.net & seldon@@eskimo.com
a2067 1

d2070 4
a2073 4
     *  Reset stack of color attribute changes to avoid color leaking,
     *  except if what we last displayed from this text was the previous
     *  screenful, in which case carrying over the state might be beneficial
     *  (although it shouldn't generally be needed any more). - kw
d2083 7
a2089 2
    display_title(text);  /* will move cursor to top of screen */
    display_flag=TRUE;
d2097 1
a2097 1
    LynxResetScreenCache();
d2103 2
a2104 2
	if (stop_before_for_anchors > line_number+(display_lines))
	    stop_before_for_anchors = line_number+(display_lines);
d2107 1
a2107 1
	stop_before_for_anchors = line_number+(display_lines);
d2110 1
a2110 1
     *  Output the page.
d2124 1
a2124 1
	for (i = 0; i < (display_lines); i++)  {
d2126 1
a2126 1
	     *  Verify and display each line.
d2139 1
a2139 1
		nlinks = 0;  /* set number of links to 0 */
d2150 1
a2150 1
		LYmove((i + 2), 0);
d2153 1
a2153 1
	    display_line(line, text, i+1, target);
d2158 2
a2159 2
	     *  If the target is on this line, recursively
	     *  seek and emphasize it. -FM
d2161 2
a2162 2
	    data = (char *)line->data;
	    offset = (int)line->offset;
d2164 6
a2169 6
		    (cp = LYno_attr_mb_strstr(data,
					      target,
					      text->T.output_utf8, YES,
					      NULL,
					      &LenNeeded)) != NULL &&
		   ((int)line->offset + LenNeeded) < DISPLAY_COLS) {
d2172 1
a2172 1
		int x_pos = offset + (int)(cp - data);
d2180 1
a2180 1
		 *  Start the emphasis.
d2185 1
a2185 1
		 *  Output the target characters.
d2189 1
a2189 1
		     itmp++)  {
d2192 1
a2192 1
			 *  Ignore special characters.
d2199 1
a2199 1
			     *  First printable character of target.
d2201 1
a2201 1
			    LYmove((i + 1), x_pos);
d2204 1
a2204 1
			 *  Output all the printable target chars.
d2208 2
a2209 2
			    strncpy(&tmp[1], &line->data[itmp+1], utf_extra);
			    tmp[utf_extra+1] = '\0';
d2217 1
a2217 1
			     *  For CJK strings, by Masanobu Kimura.
d2231 3
a2233 3
		 *  Stop the emphasis, and reset the offset and
		 *  data pointer for our current position in the
		 *  line. -FM
d2237 1
a2237 1
		data = (char *)&data[itmp];
d2240 3
a2242 3
		 *  Adjust the cursor position, should we be at
		 *  the end of the line, or not have another hit
		 *  in it. -FM
d2244 2
a2245 2
		LYmove((i + 2), 0);
	    } /* end while */
d2250 2
a2251 2
	     *  Stop if this is the last line.  Otherwise, make sure
	     *  display_flag is set and process the next line. -FM
d2255 1
a2255 1
		 *  Clear remaining lines of display.
d2258 1
a2258 1
		    LYmove((i + 1), 0);
d2266 2
a2267 2
		 *  Remember as fully shown during last partial display,
		 *  if it was not the last text line. - kw
d2274 3
a2276 3
	} /* end of "Verify and display each line." loop */
    } /* end "Output the page." */

d2281 1
a2281 1
     *  Add the anchors to Lynx structures.
d2289 1
a2289 1
	 && Anchor_ptr->line_num < stop_before_for_anchors) {
d2293 1
a2293 1
	     *  Load normal hypertext anchors.
d2296 2
a2297 2
	     && non_empty(hi_string)
	     && (Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {
d2301 1
a2301 1
		for (count = 0; ; ++count) {
d2307 1
a2307 1
		    if (count != 0)
d2309 1
d2314 1
d2321 2
a2322 2
		     *	Memory leak fixed 05-27-94
		     *	Garrett Arch Blythe
d2325 1
d2332 1
a2332 1
				Anchor_ptr->anchor, HTInternalLink);
d2336 2
a2337 2
		    "GridText: display_page: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d2344 1
d2371 1
a2371 1
		    && Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d2373 1
a2373 1
		 *  Handle form fields.
d2379 1
d2402 1
d2405 1
a2405 1
		} else {  /* TEXT type */
d2412 1
a2412 1
		 *  Bold the link after incrementing nlinks.
d2420 1
a2420 1
		 *  Not showing anchor.
d2431 2
a2432 2
	     *  Links array is full.  If interactive, tell user
	     *  to use half-page or two-line scrolling. -FM
d2440 1
a2440 1
    } /* end of loop "Add the anchors to Lynx structures." */
d2443 2
a2444 2
     *  Free any un-reallocated links[] entries
     *  from the previous page draw. -FM
d2446 1
a2446 4
    for (i = nlinks; i < last_nlinks; i++) {
	LYSetHilite(i, NULL);
	FREE(links[i].lname);
    }
d2450 3
a2452 3
     *  If Anchor_ptr is not NULL and is not pointing to the last
     *  anchor, then there are anchors farther down in the document,
     *  and we need to flag this for traversals.
d2462 1
a2462 1
	 *  Nothing on the page.
d2476 1
a2476 2
	text->first_lineno_last_disp_partial =
	    text->last_lineno_last_disp_partial = -1;
d2483 2
a2484 2
	 *  For other than ncurses, repainting is taken care of
	 *  by touching lines in display_line and highlight. - kw 1999-10-07
d2490 1
a2490 1
	 *  For non-multibyte curses.
d2492 3
a2494 3
	 *  Full repainting is necessary, otherwise only part of a multibyte
	 *  character sequence might be written because of curses output
	 *  optimizations.
d2501 1
a2503 1

d2505 5
a2509 6
**			-----------------------
**
**	These are used by a parser to build the text in an object
*/
PUBLIC void HText_beginAppend ARGS1(
	HText *,	text)
a2515 1

d2537 16
a2552 16
**	----------------------
**
** On entry,
**
**	split	is zero for newline function, else number of characters
**		before split.
**	text->display_on_the_fly
**		may be set to indicate direct output of the finished line.
** On exit,
**		A new line has been made, justified according to the
**		current style.  Text after the split (if split nonzero)
**		is taken over onto the next line.
**
**		If display_on_the_fly is set, then it is decremented and
**		the finished line is displayed.
*/
d2560 1
a2560 1
#define CTRACE_SPLITLINE(p)	/*nothing*/
d2563 4
a2566 5
PRIVATE int set_style_by_embedded_chars ARGS4(
	char *,		s,
	char *,		e,
	unsigned char,	start_c,
	unsigned char,	end_c)
d2581 6
a2586 8
PRIVATE void move_anchors_in_region ARGS7(
    HTLine *,		line,
    int,		line_number,
    TextAnchor **,	prev_anchor,	/*updates++*/
    int *,		prev_head_processed,
    int,		sbyte,
    int,		ebyte,
    int,		shift)		/* Likewise */
d2615 2
a2616 2
	    last -= line->prev->size + 1; /* Fake "\n" "between" lines counted too */
	if (last < sbyte)		/* Completely before the start */
d2619 3
a2621 3
	if ( !head_processed		/* a->line_pos is not edited yet */
	     && a->line_num == line_number
	     && a->line_pos >= ebyte)	/* Completely after the end */
d2626 2
a2627 2
	if ( !head_processed && a->line_num == line_number
	     && a->line_pos >= sbyte ) {
d2633 1
a2633 1
	if ( last < ebyte )
d2635 3
a2637 2
	else
	    break;			/* Keep this `a' for the next step */
d2644 9
a2652 9
 *  Given a line and two int arrays of old/now position, this function
 *  creates a new line where spaces have been inserted/removed
 *  in appropriate places - so that characters at/after the old
 *  position end up at/after the new position, for each pair, if possible.
 *  Some necessary changes for anchors starting on this line are also done
 *  here if needed. Updates 'prev_anchor' internally.
 *  Returns a newly allocated HTLine* if changes were made
 *    (caller has to free the old one).
 *  Returns NULL if no changes needed.  (Remove-spaces code may be buggy...)
d2655 6
a2660 8
PRIVATE HTLine * insert_blanks_in_line ARGS7(
    HTLine *,		line,
    int,		line_number,
    HText *,		text,
    TextAnchor **,	prev_anchor,	/*updates++*/
    int,		ninserts,
    int *,		oldpos,		/* Measured in cells */
    int *,		newpos)		/* Likewise */
d2662 3
a2664 2
    int ioldc = 0;			/* count visible characters */
    int ip;				/* count insertion pairs */
d2671 1
a2671 1
    HTLine * mod_line;
d2687 1
a2687 1
	   mod_line = TEMP_LINE(text, 1);
d2689 1
a2689 1
	   mod_line = TEMP_LINE(text, 0);
d2705 5
a2709 4
		      /* Include'em all! */
		      : ((int)line->size <= MAX_LINE
			  ? MAX_LINE+1
			  : (int)line->size+1));
d2715 2
a2716 2
	    if ( text && text->T.output_utf8
		 && UCH(*s) >= 0x80 && UCH(*s) <  0xC0 ) {
d2718 1
a2718 1
	    } else if (!IsSpecialAttrChar(*s)) { /* At a "displayed" char */
d2728 2
a2729 2
	if (ip)				/* Fix anchor positions */
	    move_anchors_in_region(line, line_number, prev_anchor /*updates++*/,
d2735 3
a2737 1
	for (; istyle < line->numstyles && (int) NStyle.horizpos < curlim ; istyle++)
d2756 1
a2756 1
    while (pre < s)	/* Copy remaining style-codes */
d2767 9
a2775 10
PRIVATE HTStyleChange * skip_matched_and_correct_offsets ARGS3(
	HTStyleChange *,	end,
	HTStyleChange *,	start,
	unsigned,		split_pos)
{ /* Found an OFF change not part of an adjacent matched pair.
   * Walk backward looking for the corresponding ON change.
   * Move everything after split_pos to be at split_pos.
   * This can only work correctly if all changes are correctly
   * nested!  If this fails, assume it is safer to leave whatever
   * comes before the OFF on the previous line alone. */
d2789 1
a2789 1
	if (tmp->horizpos > split_pos)
d2791 1
d2797 1
a2797 3
PRIVATE void split_line ARGS2(
	HText *,	text,
	unsigned,	split)
d2799 1
a2799 1
    HTStyle * style = text->style;
d2801 4
a2804 2
    int indent = text->in_line_1 ?
	  text->style->indent1st : text->style->leftIndent;
d2806 1
a2806 1
    TextAnchor * a;
d2813 1
d2815 2
d2818 1
a2818 1
    char * cp;
d2820 2
a2821 2
    HTLine * previous = text->last_line;
    HTLine * line;
d2824 1
a2824 1
     *  Set new line.
d2834 2
a2835 2
    ctrl_chars_on_this_line = 0; /*reset since we are going to a new line*/
    utfxtra_on_this_line = 0;	/*reset too, we'll count them*/
d2839 2
a2840 2
    CTRACE((tfp,"GridText: split_line(%p,%d) called\n", text, split));
    CTRACE((tfp,"   bold_on=%d, underline_on=%d\n", bold_on, underline_on));
d2844 1
d2847 1
a2847 1
     || cp[0] == LY_UNDERLINE_START_CHAR) {
d2849 8
a2856 1
	    case LY_SOFT_NEWLINE:
d2859 2
a2860 9
		break;
	    case LY_BOLD_START_CHAR:
	    case LY_UNDERLINE_START_CHAR:
		if (cp[2] == LY_SOFT_NEWLINE) {
		    cp[2] = cp[1];
		    cp[1] = cp[0];
		    cp[0] = LY_SOFT_NEWLINE;
		}
		break;
d2865 2
a2866 2
	       "*** split_line: split==%d greater than last_line->size==%d !\n",
	       split, previous->size));
d2872 1
a2872 1
	    CTRACE((tfp, "                split adjusted to %d.\n", split));
d2885 1
a2885 1
    text->permissible_split = 0;  /* 12/13/93 */
d2890 1
a2890 1
    if (split > 0) { /* Restore flags to the value at the splitting point */
d2892 7
a2898 7
	    t_underline = set_style_by_embedded_chars(
		previous->data, previous->data + split,
		LY_UNDERLINE_START_CHAR, LY_UNDERLINE_END_CHAR);

	t_bold = set_style_by_embedded_chars(
	    previous->data, previous->data + split,
	    LY_BOLD_START_CHAR, LY_BOLD_END_CHAR);
d2916 1
a2916 1
     *  Split at required point
d2918 1
a2918 1
    if (split > 0) {	/* Delete space at "split" splitting line */
d2928 2
a2929 2
	 *  Trim any spaces or soft hyphens from the beginning
	 *  of our new line. -FM
d2932 1
a2932 2
	while ((
		(*p == ' '
d2934 4
a2937 4
		/* if justification is allowed for prev line, then raw
		 * HT_NON_BREAK_SPACE are still present in data[] (they'll be
		 * substituted at the end of this function with ' ') - VH
		 */
d2946 1
a2946 1
		*p == LY_SOFT_HYPHEN) {
d2952 1
a2952 1
	if (plen) {			/* Count funny characters */
d2963 1
a2963 1
		if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i)
d2975 1
a2975 1
     *  Economize on space.
d2981 4
a2984 4
	    /* if justification is allowed for prev line, then raw
	     * HT_NON_BREAK_SPACE are still present in data[] (they'll be
	     * substituted at the end of this function with ' ') - VH
	     */
d2987 1
a2987 1
	      )
d2989 3
a2991 3
	   && !psrc_view /*don't strip trailing whites - since next line can
		start with LY_SOFT_NEWLINE - so we don't lose spaces when
		'p'rinting this text to file -VH */
d2998 1
a2998 1
	p--;	/*  Strip trailers. */
d3000 1
a3000 1
    TailTrim = previous->data + previous->size - 1 - p;	/*  Strip trailers. */
d3005 3
a3007 3
     *  s is the effective split position, given by either a non-zero
     *  value of split or by the size of the previous line before
     *  trimming. - kw
d3010 1
a3010 1
	s = previous->size + TailTrim; /* the original size */
d3015 1
a3015 1
    s_pre  = s - TailTrim;
d3019 1
a3019 1
    if (s != (int)split)
d3021 1
a3021 1
	CTRACE((tfp,"GridText: split_line(%d [now:%d]) called\n", split, s));
d3035 4
a3038 4
	/*  Color style changes after the split position
	 *  are transferred to the new line.  Ditto for changes
	 *  in the trimming region, but we stop when we reach an OFF change.
	 *  The second loop below may then handle remaining changes. - kw */
d3041 5
a3045 5
	    if ((int) to->horizpos > s_post)
		to->horizpos += - s_post + SpecialAttrChars;
	    else if ((int) to->horizpos > s_pre &&
		     (to->direction == STACK_ON ||
		      to->direction == ABS_ON))
d3047 1
a3047 1
	    else
d3049 1
d3065 1
a3065 1
		  Report a bug on failure.
d3067 2
a3068 2
		  and the corresponding OFF at to;
		  If not, put the corresponding OFF at at_end, and copy to to;
d3078 3
a3080 3
		if ( at_end->direction == STACK_ON
		     && at_end->style == scan->style
		     && (int) at_end->horizpos >= s_pre )
d3091 4
a3094 4
		if ( to < line->styles + MAX_STYLES_ON_LINE - 1
		     && to[1].direction == STACK_OFF
		     && to[1].horizpos <= (unsigned) SpecialAttrChars
		     && to[1].style == scan->style )
d3105 1
a3105 1
	    if ((int) scan->horizpos > s_pre)
d3107 1
d3116 3
a3118 2
	} else if (line->numstyles == 0)
	    line->styles[0].horizpos = ~0; /* ?!!! */
d3120 1
a3120 1
	if (previous->numstyles == 0)
d3122 1
d3124 1
a3124 1
#endif /*USE_COLOR_STYLE*/
d3127 6
a3132 5
    HTLine* temp;
    allocHTLine(temp, previous->size);
    if (!temp)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp, previous, LINE_SIZE(previous->size));
d3134 4
a3137 4
    POOLallocstyles(temp->styles, previous->numstyles);
    if (!temp->styles)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp->styles, previous->styles, sizeof(HTStyleChange)*previous->numstyles);
d3139 1
a3139 1
    previous = temp;
d3146 1
a3146 1
     *  Terminate finished line for printing.
d3151 1
a3151 1
     *  Align left, right or center.
d3156 1
a3156 1
	this_line_was_split ||
d3158 2
a3159 2
	(alignment == HT_CENTER ||
	 alignment == HT_RIGHT) || text->stbl) {
d3166 1
d3168 1
d3174 1
a3174 1
		(int)(previous->data[previous->size-1] == LY_SOFT_HYPHEN))
d3178 10
a3187 2
	spare =  (WRAP_COLS(text)-1) -
	    (int)style->rightIndent - indent +
d3196 14
a3209 13
		int spare_cu = (LYcols_cu(text)-1) -
		    utfxtra_on_previous_line - indent +
		    ctrl_chars_on_previous_line - previous->size;
		    /*
		     *  Shift non-leftaligned UTF-8 lines that would be
		     *  mishandled by the display library towards the left
		     *  if this would make them fit.  The resulting display
		     *  will not be as intended, but this is better than
		     *  having them split by curses.  (Curses cursor movement
		     *  optimization may still cause wrong positioning within
		     *  the line, in particular after a sequence of spaces).
		     * - kw
		     */
d3213 2
a3214 2
			    (int)(previous->offset + indent + spare/2 +
				  previous->size)
d3216 2
a3217 2
			    + utfxtra_on_previous_line <= (LYcols_cu(text) - 1))
			    /* do nothing - it still fits - kw */;
d3222 3
a3224 3
				 *  Can't move towars center all the way,
				 *  but at least make line contents appear
				 *  as far right as possible. - kw
d3229 2
a3230 3
		    } else if (indent + (int)previous->offset + spare_cu >= 0)
		    { /* subtract overdraft from effective indentation */
			indent += (int)previous->offset + spare_cu;
d3237 1
d3240 1
d3242 13
a3254 12
	case HT_CENTER :
	    previous->offset = previous->offset + indent + spare/2;
	    break;
	case HT_RIGHT :
	    previous->offset = previous->offset + indent + spare;
	    break;
	case HT_LEFT :
	case HT_JUSTIFY :		/* Not implemented */
	default:
	    previous->offset = previous->offset + indent;
	    break;
    } /* switch */
d3258 9
a3266 9
	 *  Notify simple table stuff of line split, so that it can
	 *  set the last cell's length.  The last cell should and
	 *  its row should really end here, or on one of the following
	 *  lines with no more characters added after the break.
	 *  We don't know whether a cell has been started, so ignore
	 *  errors here.
	 *  This call is down here because we need the
	 *  ctrl_chars_on_previous_line, which have just been re-
	 *  counted above. - kw
d3273 1
a3273 1
    text->in_line_1 = NO;		/* unless caller sets it otherwise */
d3276 2
a3277 2
     *  If we split the line, adjust the anchor
     *  structure values for the new line. -FM
d3280 1
a3280 1
    if (s > 0) {			/* if not completely empty */
d3295 1
a3295 1
	for ( ; a; a = a->next) {
d3304 2
a3305 2
		      "Just because": those before s;
		      this is the only case when we use s, not s_pre/s_post);
d3323 2
a3324 1
		    CTRACE_SPLITLINE((tfp, "anchor %d: no relocation, empty-finished",
d3326 1
a3326 1
		    a->line_pos = s_pre; /* Leave at the end of line */
d3333 4
a3336 3
		CTRACE_SPLITLINE((tfp, "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
		       n, TailTrim,HeadTrim,SpecialAttrChars,
		       a->line_num,a->line_pos,a->extent));
d3350 1
a3350 1
		       a->line_num,a->line_pos,a->extent));
a3354 1

d3359 12
a3370 12
     && spare
     && !text->stbl	/* We don't inform TRST on the cell width change yet */
     && justify_max_void_percent > 0
     && justify_max_void_percent <= 100
     && justify_max_void_percent >= ((100*spare)
				  / ((WRAP_COLS(text) - 1)
				   - (int)style->rightIndent
				   - indent
				   + ctrl_chars_on_previous_line))) {
	/* this is the only case when we need justification*/
	char* jp = previous->data + justify_start_position;
	ht_run_info* r = ht_runs;
d3374 1
a3374 1
	HTLine * jline;
d3379 1
a3379 1
	for(; (c = *jp) != 0; ++jp) {
d3389 1
a3389 1
	    if ( IsSpecialAttrChar(c) )
d3399 1
d3409 1
a3409 1
	    int *oldpos = (int*)malloc(sizeof(int)*2*(ht_num_runs - 1));
d3416 2
a3417 2
	    d_ = spare/(ht_num_runs-1);
	    r_ = spare % (ht_num_runs-1);
d3421 1
a3421 1
	    newpos[0] = oldpos[0] + ( d_ + ( r_--  > 0 ) );
d3425 2
a3426 2
		oldpos[i] = oldpos[i-1] + delta;
		newpos[i] = newpos[i-1] + delta + ( d_ + ( r_--  > 0 ) );
d3430 1
a3430 1
					  &last_anchor_of_previous_line /*updates++*/,
d3432 1
a3432 1
	    free((char*)oldpos);
d3442 5
a3446 6
	{ /* (ht_num_runs==1) */
	    if (justify_start_position) {
		char* p2 = previous->data;
		for( ; p2 < previous->data + justify_start_position; ++p2)
		    *p2 = (*p2 == HT_NON_BREAK_SPACE ? ' ' : *p2);
	    }
d3449 2
a3450 2
	if (REALLY_CAN_JUSTIFY(text) ) {
	    char* p2;
d3457 3
a3459 1
		  CTRACE((tfp,"BUG: justification: shouldn't happen - new line is not empty!\n"));
d3462 1
a3462 1
	    for (p2=previous->data;*p2;++p2)
d3467 1
a3467 1
	       table cells*/
d3470 1
a3470 1
	    for (i = 0; i< previous->size; ++i)
d3475 1
a3475 1
	    for (i = 0; i< line->size; ++i)
d3483 1
a3483 1
	/* cleanup */
d3490 1
a3490 2
} /* split_line */

d3493 3
a3495 5
**	--------------------------
*/
PRIVATE void blank_lines ARGS2(
	HText *,	text,
	int,		newlines)
d3497 6
a3502 2
    if (HText_LastLineEmpty(text, FALSE)) { /* No text on current line */
	HTLine * line = text->last_line->prev;
d3506 2
a3507 2
	if (line == text->last_line && newlines == 1)
	    return;			/* Do not add a blank line at start */
d3519 1
a3519 1
	newlines++;			/* Need also to finish this line */
a3527 1

d3529 4
a3532 5
**	------------------------------
** See also: setStyle.
*/
PUBLIC void HText_appendParagraph ARGS1(
	HText *,	text)
d3536 1
a3539 1

d3541 5
a3545 7
**	---------
**
**	Does not filter unnecessary style changes.
*/
PUBLIC void HText_setStyle ARGS2(
	HText *,	text,
	HTStyle *,	style)
d3550 1
a3550 1
	return;				/* Safety */
d3556 1
a3556 1
    blank_lines (text, ((after > before) ? after : before));
d3562 3
a3564 5
**	-------------------------------------
*/
PUBLIC void HText_appendCharacter ARGS2(
	HText *,	text,
	int,		ch)
d3566 2
a3567 2
    HTLine * line;
    HTStyle * style;
d3578 3
a3580 2
	char * special = NULL;  /* make trace a little more readable */
	switch(ch) {
d3582 2
a3583 2
		special = "HT_NON_BREAK_SPACE";
		break;
d3585 2
a3586 2
		special = "HT_EN_SPACE";
		break;
d3588 2
a3589 2
		special = "LY_UNDERLINE_START_CHAR";
		break;
d3591 2
a3592 2
		special = "LY_UNDERLINE_END_CHAR";
		break;
d3594 2
a3595 2
		special = "LY_BOLD_START_CHAR";
		break;
d3597 2
a3598 2
		special = "LY_BOLD_END_CHAR";
		break;
d3600 2
a3601 2
		special = "LY_SOFT_HYPHEN";
		break;
d3603 2
a3604 2
		special = "LY_SOFT_NEWLINE";
		break;
d3606 2
a3607 2
		special = NULL;
		break;
d3612 1
a3612 1
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3614 1
a3614 1
#ifdef CJK_EX	/* 1998/08/30 (Sun) 13:26:23 */
d3620 1
a3620 1
			HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3635 1
a3635 1
#endif	/* CJK_EX */
d3637 1
a3637 1
    } /* trace only */
d3641 1
a3641 1
     *  Make sure we don't crash on NULLs.
d3648 2
a3649 2
	 *  We should stop outputting more text, because low memory was
	 *  detected.  - kw
d3653 4
a3656 4
	     *  But if we haven't done so yet, first append a warning.
	     *  We should still have a few bytes left for that :).
	     *  We temporarily reset test->halted to 0 for this, since
	     *  this function will get called recursively. - kw
d3669 1
a3669 1
	enum _detected_kcode save_d_kcode;
d3679 1
a3679 2
	    }
	    else if ((c & 0x80) && !IS_SJIS_X0201KANA(c)) {
d3690 1
a3690 2
	    }
	    else {
d3705 1
a3705 2
	    }
	    else if (c == 0x8e) {
d3707 1
a3707 2
	    }
	    else if (c & 0x80) {
d3718 1
a3718 2
	    }
	    else {
d3727 1
a3727 1
	    if ((0xA1<=c)&&(c<=0xDF)) {
d3729 1
a3729 2
	    }
	    else {
d3741 2
a3742 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n"));
d3745 2
a3746 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n"));
d3749 2
a3750 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n"));
d3753 2
a3754 1
		CTRACE((tfp, "TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n"));
d3761 1
a3761 1
     *  Make sure we don't hang on escape sequences.
d3763 1
a3763 1
    if (ch == CH_ESC && HTCJK == NOCJK) {		/* decimal 27  S/390 -- gil -- 1504 */
d3768 6
a3773 6
     *  Block 8-bit chars not allowed by the current display character
     *  set if they are below what LYlowest_eightbit indicates.
     *  Slang used its own replacements, so for USE_SLANG blocking here
     *  is not necessary to protect terminals from those characters.
     *  They should have been filtered out or translated by an earlier
     *  processing stage anyway. - kw
d3775 1
a3775 1
#ifndef   EBCDIC  /* S/390 -- gil -- 1514 */
d3794 1
a3794 1
    indent = text->in_line_1 ? (int)style->indent1st : (int)style->leftIndent;
d3797 3
a3799 14
	switch(text->state) {
	    case S_text:
		if (ch == CH_ESC) {  /* S/390 -- gil -- 1536 */
		    /*
		    **  Setting up for CJK escape sequence handling (based on
		    **  Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). -FM
		    */
		    text->state = S_esc;
		    text->kanji_buf = '\0';
		    return;
		}
		break;

	    case S_esc:
d3801 2
a3802 1
		 *  Expecting '$'or '(' following CJK ESC.
d3804 37
a3840 10
		if (ch == '$') {
		    text->state = S_dollar;
		    return;
		} else if (ch == '(') {
		    text->state = S_paren;
		    return;
		} else {
		    text->state = S_text;
		}
		/* FALLTHRU */
d3842 11
a3852 16
	    case S_dollar:
		/*
		 *  Expecting '@@', 'B', 'A' or '(' after CJK "ESC$".
		 */
		if (ch == '@@' || ch == 'B' || ch=='A') {
		    text->state = S_nonascii_text;
		    if (ch == '@@' || ch == 'B')
			text->kcode = JIS;
		    return;
		} else if (ch == '(') {
		    text->state = S_dollar_paren;
		    return;
		} else {
		    text->state = S_text;
		}
		break;
d3854 5
a3858 1
	    case S_dollar_paren:
d3860 1
a3860 1
		 * Expecting 'C' after CJK "ESC$(".
d3862 5
a3866 9
		if (ch == 'C') {
		    text->state = S_nonascii_text;
		    return;
		} else {
		    text->state = S_text;
		}
		break;

	    case S_paren:
d3868 1
a3868 1
		 *  Expecting 'B', 'J', 'T' or 'I' after CJK "ESC(".
d3870 7
a3876 19
		if (ch == 'B' || ch == 'J' || ch == 'T')  {
		    /*
		     *  Can split here. -FM
		     */
		    text->permissible_split = text->last_line->size;
		    text->state = S_text;
		    return;
		} else if (ch == 'I')  {
		    text->state = S_jisx0201_text;
		    /*
		     *  Can split here. -FM
		     */
		    text->permissible_split = text->last_line->size;
		    text->kcode = JIS;
		    return;
		} else {
		    text->state = S_text;
		}
		break;
d3878 9
a3886 19
	    case S_nonascii_text:
		/*
		 *  Expecting CJK ESC after non-ASCII text.
		 */
		if (ch == CH_ESC) {  /* S/390 -- gil -- 1553 */
		    text->state = S_esc;
		    text->kanji_buf = '\0';
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
		    return;
		} else if (UCH(ch) < 32) {
		    text->state = S_text;
		    text->kanji_buf = '\0';
		    if (HTCJK == JAPANESE) {
			text->kcode = NOKANJI;
		    }
		} else {
		    ch |= 0200;
d3888 5
a3892 9
		break;

		/*
		 *  JIS X0201 Kana in JIS support. - by ASATAKU
		 */
	    case S_jisx0201_text:
		if (ch == CH_ESC) {  /* S/390 -- gil -- 1570 */
		    text->state = S_esc;
		    text->kanji_buf = '\0';
a3893 4
		    return;
		} else {
		    text->kanji_buf = '\216';
		    ch |= 0200;
d3895 20
a3914 2
		break;
	} /* end switch */
d3919 1
a3919 1
		 *  JIS X0201 Kana in SJIS support. - by ASATAKU
d3922 1
a3922 1
		 && (
d3924 2
a3925 2
		    (last_kcode == SJIS) ||
		     ((last_kcode == NOKANJI) &&
d3927 1
a3927 1
		      ((text->kcode == SJIS) ||
d3929 2
a3930 2
		       ((text->detected_kcode == DET_SJIS) &&
			(text->specified_kcode == NOKANJI)) ||
d3932 2
a3933 2
		       ((text->kcode == NOKANJI) &&
			(text->specified_kcode == SJIS)) )
d3935 1
a3935 1
		     )
d3943 1
d3945 3
a3947 3
					(unsigned char *)&kb,
					(unsigned char *)&c);
		    ch = (char)c;
d3951 1
a3951 1
		    text->permissible_split = (int)text->last_line->size;
d3955 1
a3955 1
		     *  Can split here. -FM
d3964 1
a3964 1
    } else if (ch == CH_ESC) {  /* S/390 -- gil -- 1587 */
d3967 1
a3967 2

#ifdef CJK_EX	/* MOJI-BAKE Fix! 1997/10/12 -- 10/31 (Fri) 00:22:57 - JH7AYN */
d3970 1
a3970 1
	text->permissible_split = (int)line->size;	/* Can split here */
d3978 1
a3978 1
	if (line->size >= (MAX_LINE-1)) {
d3982 1
a3982 1
	if (with_backspaces && HTCJK==NOCJK && !text->T.output_utf8) {
d3984 18
a4001 5
	if (ch == LY_UNDERLINE_START_CHAR) {
	    line->data[line->size++] = LY_UNDERLINE_START_CHAR;
	    line->data[line->size] = '\0';
	    underline_on = ON;
	    if (!(dump_output_immediately && use_underscore))
d4003 5
a4007 6
	    return;
	} else if (ch == LY_UNDERLINE_END_CHAR) {
	    line->data[line->size++] = LY_UNDERLINE_END_CHAR;
	    line->data[line->size] = '\0';
	    underline_on = OFF;
	    if (!(dump_output_immediately && use_underscore))
d4009 3
a4011 15
	    return;
	} else if (ch == LY_BOLD_START_CHAR) {
	    line->data[line->size++] = LY_BOLD_START_CHAR;
	    line->data[line->size] = '\0';
	    bold_on = ON;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch == LY_BOLD_END_CHAR) {
	    line->data[line->size++] = LY_BOLD_END_CHAR;
	    line->data[line->size] = '\0';
	    bold_on = OFF;
	    ctrl_chars_on_this_line++;
	    return;
	} else if (ch == LY_SOFT_HYPHEN) {
	    int i;
d4013 8
a4020 8
	    /*
	     *  Ignore the soft hyphen if it is the first character
	     *  on the line, or if it is preceded by a space or
	     *  hyphen. -FM
	     */
	    if (line->size < 1 || text->permissible_split >= line->size) {
		return;
	    }
d4022 11
a4032 7
	    for (i = (text->permissible_split + 1); line->data[i]; i++) {
		if (!IsSpecialAttrChar(UCH(line->data[i])) &&
		    !isspace(UCH(line->data[i])) &&
		    UCH(line->data[i]) != '-' &&
		    UCH(line->data[i]) != HT_NON_BREAK_SPACE &&
		    UCH(line->data[i]) != HT_EN_SPACE) {
		    break;
a4034 4
	    if (line->data[i] == '\0') {
		return;
	    }
	}
d4036 2
a4037 2
	} /* if (with_backspaces && HTCJK==HTNOCJK && !text->T.output_utf8) */
	 else {
d4039 1
a4039 1
	 }
d4053 3
a4055 3
	 *  Some extra checks for UTF-8 output here to make sure
	 *  memory is not overrun.  For a non-first char, append
	 *  to the line here and return. - kw
d4058 2
a4059 2
	    if ((line->size > (MAX_LINE-1))
		|| (indent + (int)(line->offset + line->size)
d4063 3
a4065 3
		       (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0)) >= (LYcols_cu(text)-1))
d4070 1
a4070 1
			   IS_UTF_EXTRA(line->data[text->permissible_split-1]))
d4073 1
a4073 1
			(line->data[text->permissible_split-1] & 0x80))
d4082 1
a4082 1
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
d4090 1
a4090 1
	    if ((line->size > (MAX_LINE-7))) {
d4094 1
a4094 1
			   (line->data[text->permissible_split-1] & 0x80)
d4105 1
a4105 1
		    HText_appendCharacter (text, LY_SOFT_NEWLINE);
d4111 1
a4111 1
     *  New Line.
d4117 2
a4118 2
	 *  There are some pages written in
	 *  different kanji codes. - TA & kw
d4126 1
a4126 1
     *  Convert EN_SPACE to a space here so that it doesn't get collapsed.
d4131 2
a4132 2
#ifdef SH_EX	/* 1997/11/01 (Sat) 12:08:54 */
    if (ch == 0x0b) {	/* ^K ??? */
d4135 1
a4135 1
    if (ch == 0x1a) {	/* ^Z ??? */
d4141 4
a4144 4
     *  I'm going to cheat here in a BIG way.  Since I know that all
     *  \r's will be trapped by HTML_put_character I'm going to use
     *  \r to mean go down a line but don't start a new paragraph.
     *  i.e., use the second line indenting.
d4150 2
a4151 2
	 *  There are some pages written in
	 *  different kanji codes. - TA & kw
d4159 1
a4159 1
     *  Tabs.
d4162 1
a4162 1
	CONST HTTabStop * Tab;
d4166 1
a4166 1
	if (line->size > 0 && line->data[line->size-1] == LY_SOFT_HYPHEN) {
d4168 2
a4169 2
	     *  A tab shouldn't follow a soft hyphen, so
	     *  if one does, we'll dump the soft hyphen. -FM
d4174 2
a4175 2
	here = ((int)(line->size + line->offset) + indent)
		- ctrl_chars_on_this_line; /* Consider special chars GAB */
d4179 2
a4180 2
		Tab->position <= here;
		Tab++) {
d4188 2
a4189 2
	    if (here >= (int)style->leftIndent) {
		new_line(text); /* wrap */
d4192 1
a4192 1
		target = (int)style->leftIndent;
d4196 2
a4197 2
	    target = (((int)line->offset + (int)line->size + 8) & (-8))
			+ (int)style->leftIndent;
d4209 1
a4209 1
	if (target > (WRAP_COLS(text)-1) - (int)style->rightIndent &&
d4214 1
a4214 1
	     *  Can split here. -FM
d4217 2
a4218 2
	    if (target_cu > (WRAP_COLS(text)-1))
		target -= target_cu - (WRAP_COLS(text)-1);
d4220 1
a4220 1
		line->offset = line->offset + target - here;
d4222 1
a4222 1
		for (; here<target; here++) {
d4230 4
a4233 4
    } /* if tab */

check_WrapSource:
    if ( (text->source || dont_wrap_pre) && text == HTMainText) {
d4238 1
a4238 1
	int target = (int)(line->offset + line->size) - ctrl_chars_on_this_line;
d4240 2
a4241 1
	if (target >= (WRAP_COLS(text)-1) - style->rightIndent -
d4244 1
a4244 1
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu(text)-1))) {
d4246 1
a4246 1
	    int saved_state;
d4255 1
a4255 1
	    HText_appendCharacter (text, LY_SOFT_NEWLINE);
d4263 1
a4263 1
	 *  Can split here. -FM
d4267 2
a4268 2
	 *  There are some pages written in
	 *  different kanji codes. - TA
d4275 1
a4275 1
     *  Check if we should ignore characters at the wrap point.
d4278 1
a4278 1
	int nominal = (indent + (int)(line->offset + line->size) - ctrl_chars_on_this_line);
d4281 1
a4281 1
	limit = (WRAP_COLS(text) - 1);
d4283 3
a4285 3
	 && !number_fields_on_left
	 && text->last_anchor != 0
	 && (number = text->last_anchor->number) > 0) {
d4287 10
a4296 10
			? 6
			: (number > 9999
			    ? 5
			    : (number > 999
				? 4
				: (number > 99
				    ? 3
				    : (number > 9
					? 2
					: 1))))) + 2;
d4298 2
a4299 2
	if ((nominal + (int)style->rightIndent) >= limit
	 || (nominal + UTFXTRA_ON_THIS_LINE) >= (LYcols_cu(text) - 1)) {
d4305 1
a4305 1
     *  Check for end of line.
d4307 1
a4307 1
    actual = ((indent + (int)line->offset + (int)line->size) +
d4309 1
a4309 1
	       (int)(line->data[line->size-1] == LY_SOFT_HYPHEN ? 1 : 0)));
d4311 11
a4321 11
    if (text->T.output_utf8) {
	actual += (UTFXTRA_ON_THIS_LINE - ctrl_chars_on_this_line + UTF_XLEN(ch));
	limit = (LYcols_cu(text) - 1);
    } else {
	actual +=
	 (int)style->rightIndent - ctrl_chars_on_this_line +
	 (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0);
	limit = (WRAP_COLS(text) - 1);
    }

    if (actual >= limit) {
d4330 1
a4330 1
		return;	/* Ignore space causing split */
d4335 5
a4339 5
	     *  For source output we don't want to wrap this stuff
	     *  unless absolutely necessary. - LJM
	     *  !
	     *  If we don't wrap here we might get a segmentation fault.
	     *  but let's see what happens
d4341 2
a4342 2
	    if ((int)line->size >= (int)(MAX_LINE-1)) {
		new_line(text);  /* try not to linewrap */
d4346 2
a4347 2
	     *  For normal stuff like pre let's go ahead and
	     *  wrap so the user can see all of the text.
d4349 3
a4351 3
	    if ( (dump_output_immediately|| (crawl && traversal) )
		 && dont_wrap_pre) {
		if ((int)line->size >= (int)(MAX_LINE-1)) {
d4358 1
a4358 1
    } else if ((int)line->size >= (int)(MAX_LINE-1)) {
d4360 1
a4360 1
	 *  Never overrun memory if DISPLAY_COLS is set to a large value - KW
d4366 1
a4366 1
     *  Insert normal characters.
d4370 1
a4370 1
     && !REALLY_CAN_JUSTIFY(text)
d4372 1
a4372 1
     )
d4391 1
a4391 1
	line = text->last_line; /* May have changed */
d4406 2
a4407 2
				if (text->specified_kcode != NOKANJI)
				    text->kcode = text->specified_kcode;
d4409 9
a4417 9
				else if (text->detected_kcode == DET_EUC)
				    text->kcode = EUC;
				else if (text->detected_kcode == DET_SJIS)
				    text->kcode = SJIS;
#endif
				else if (IS_EUC_X0201KANA(hi, lo) && (text->kcode != EUC))
				    text->kcode = SJIS;
			}
			else
d4419 1
a4419 2
		    }
		    else if (IS_EUC(hi, lo))
d4438 3
a4440 1
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
d4447 1
a4447 2
		    if ((text->kcode == EUC) || (text->kcode == JIS))
		    {
d4464 3
a4466 1
			CTRACE((tfp, "This character (%X:%X) doesn't seem Japanese\n", hi, lo));
d4487 4
a4490 5
	    line->data[line->size++] = (char) (
				       (kanji_code != NOKANJI) ?
							    ch :
					  (font & HT_CAPITALS) ?
						   TOUPPER(ch) : ch);
d4496 1
a4496 1
	if (font & HT_DOUBLE)		/* Do again if doubled */
d4498 1
a4498 1
	    /* NOT a permissible split */
d4503 1
a4503 1
	     *  Can split here. -FM
d4516 3
a4518 3
**  -------------------------------------------
*/
PUBLIC void _internal_HTC ARGS3(HText *,text, int,style, int,dir)
d4520 1
a4520 1
    HTLine* line;
d4528 4
a4531 4
	    line->styles[line->numstyles-1].direction &&
	    line->styles[line->numstyles-1].style == (unsigned) style &&
	    (int) line->styles[line->numstyles-1].horizpos
	    == (int)line->size - ctrl_chars_on_this_line) {
d4533 2
a4534 2
	     *  If this is an OFF change directly preceded by an
	     *	ON for the same style, just remove the previous one. - kw
d4538 1
a4538 1
	    line->styles[line->numstyles].horizpos  = line->size;
d4540 4
a4543 4
	     *  Special chars for bold and underlining usually don't
	     *  occur with color style, but soft hyphen can.
	     *  And in UTF-8 display mode all non-initial bytes are
	     *  counted as ctrl_chars. - kw
d4545 1
a4545 1
	    if ((int) line->styles[line->numstyles].horizpos >= ctrl_chars_on_this_line)
d4547 2
a4548 1
	    line->styles[line->numstyles].style     = style;
a4555 2


d4557 3
a4559 5
**	----------------------------------------
*/
PUBLIC void HText_setLastChar ARGS2(
	HText *,	text,
	char,		ch)
d4568 3
a4570 4
**	----------------------------------------
*/
PUBLIC char HText_getLastChar ARGS1(
	HText *,	text)
d4573 1
a4573 1
	return('\0');
d4575 1
a4575 1
    return((char)text->LastChar);
d4579 3
a4581 5
**	--------------------------------------------
*/
PUBLIC void HText_setIgnoreExcess ARGS2(
	HText *,	text,
	BOOL,		ignore)
d4590 2
a4591 2
**		-------------------------------
*/
d4594 8
a4601 10
 *  HText_insertBlanksInStblLines fixes up table lines when simple table
 *  processing is closed, by calling insert_blanks_in_line for lines
 *  that need fixup.  Also recalculates alignment for those lines,
 *  does additional updating of anchor positions, and makes sure the
 *  display of the lines on screen will be updated after partial display
 *  upon return to mainloop. - kw
 */
PRIVATE int HText_insertBlanksInStblLines ARGS2(
    HText *,		me,
    int,		ncols)
d4605 5
a4609 4
    int *	oldpos;
    int *	newpos;
    int		ninserts, lineno;
    int		first_lineno, last_lineno, first_lineno_pass2;
d4611 1
a4611 1
    int		last_nonempty = -1;
d4613 1
a4613 1
    int		added_chars_before = 0;
d4624 1
a4624 1
     *  oldpos, newpos: allocate space for two int arrays.
d4647 1
d4658 2
a4659 2
	     *  Last ditch effort to end the table with a line break,
	     *  if HTML_end_element didn't do it. - kw
d4661 1
a4661 1
	    if (first_line == line) /* obscure: all table on last line... */
d4671 1
d4681 1
a4681 1
		   lineno, width, max_width));
d4685 1
a4685 1
					 &me->last_anchor_before_stbl /*updates++*/,
d4702 2
a4703 2
	     *  Make sure modified lines get fully re-displayed after
	     *  loading with partial display is done.
d4707 1
a4707 2
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
d4713 1
a4713 2
	}
	{
d4715 1
d4726 1
d4728 1
a4728 1
		       lineno, width, max_width));
d4736 7
a4742 7
     *  Line offsets have been set based on the paragraph style, and
     *  have already been updated for centering or right-alignment
     *  for each line in split_line.  Here we want to undo all that, and
     *  align the table as a whole (i.e. all lines for which
     *  Stbl_getFixupPositions returned >= 0).  All those lines have to
     *  get the same offset, for the simple table formatting mechanism
     *  to make sense, and that may not actually be the case at this point.
d4744 5
a4748 5
     *  What indentation and alignment do we want for the table as
     *  a whole?  Let's take most style properties from me->style.
     *  With some luck, it is the appropriate style for the element
     *  enclosing the TABLE.  But let's take alignment from the attribute
     *  of the TABLE itself instead, if it was specified.
d4750 3
a4752 3
     *  Note that this logic assumes that all lines have been finished
     *  by split_line.  The order of calls made by HTML_end_element for
     *  HTML_TABLE should take care of this.
d4760 3
a4762 3
    spare = (WRAP_COLS(me)-1) -
	(int)style->rightIndent - indent - max_width;
    if (spare < 0 && (int)style->rightIndent + spare >= 0) {
d4764 2
a4765 2
	 *  Not enough room!  But we can fit if we ignore right indentation,
	 *  so let's do that.
d4769 1
a4769 1
	spare += style->rightIndent; /* ignore right indent, but need more */
d4773 1
a4773 1
	 *  Still not enough room.  But we can move to the left.
d4779 2
a4780 2
	 *  Still not enough.  Something went wrong.  Try the best we
	 *  can do.
d4782 3
a4784 2
	CTRACE((tfp, "BUG: insertBlanks: resulting table too wide by %d positions!\n",
	       -spare));
d4788 1
a4788 1
     *  Align left, right or center.
d4791 12
a4802 12
	case HT_CENTER :
	    table_offset = indent + spare/2;
	    break;
	case HT_RIGHT :
	    table_offset = indent + spare;
	    break;
	case HT_LEFT :
	case HT_JUSTIFY :
	default:
	    table_offset = indent;
	    break;
    } /* switch */
d4814 1
a4814 2
		    me->first_lineno_last_disp_partial =
			me->last_lineno_last_disp_partial = -1;
d4821 3
a4823 1
	    line->offset = table_offset;
d4838 2
a4839 2
**		----------------------------------------
*/
d4843 1
a4843 2
PUBLIC void HText_cancelStbl ARGS1(
	HText *,	me)
d4853 1
d4856 1
d4862 1
a4862 1
    Stbl_free(me->stbl);
d4868 1
a4868 3
PUBLIC void HText_startStblTABLE ARGS2(
	HText *,	me,
	short,		alignment)
d4903 1
a4903 2
PRIVATE void free_enclosed_stbl ARGS1(
	HText *,	me)
d4908 2
a4909 1
	while (NULL != (stbl = (STable_info *)HTList_nextObject(list))) {
d4917 1
d4919 1
a4919 1
#define free_enclosed_stbl(me) /* nothing */
d4925 1
a4925 2
PUBLIC int HText_endStblTABLE ARGS1(
	HText *,	me)
d4947 2
a4948 2
	NumOfLines_partial -= lines_changed;  /* fake */
#endif  /* DISP_PARTIAL */
a4949 1

d4981 1
a4981 3
PUBLIC void HText_startStblTR ARGS2(
	HText *,	me,
	short,		alignment)
d4991 1
a4991 2
PUBLIC void HText_endStblTR ARGS1(
	HText *,	me)
d5000 4
a5003 6
PUBLIC void HText_startStblTD ARGS5(
	HText *,	me,
	int,		colspan,
	int,		rowspan,
	short,		alignment,
	BOOL,		isheader)
d5018 3
a5020 1
			    me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
d5026 1
a5026 2
PUBLIC void HText_endStblTD ARGS1(
	HText *,	me)
d5031 3
a5033 1
			       me->Lines, HText_LastLineOffset(me), HText_LastLineSize(me,FALSE)) < 0)
d5039 3
a5041 5
PUBLIC void HText_startStblCOL ARGS4(
	HText *,	me,
	int,		span,
	short,		alignment,
	BOOL,		isgroup)
d5057 1
a5057 2
PUBLIC void HText_endStblCOLGROUP ARGS1(
	HText *,	me)
d5067 1
a5067 3
PUBLIC void HText_startStblRowGroup ARGS2(
	HText *,	me,
	short,		alignment)
d5076 3
a5078 6
**		---------------
*/
PRIVATE void add_link_number ARGS3(
    HText *,		text,
    TextAnchor *,	a,
    BOOL,		save_position)
d5083 1
a5083 1
     *  If we are doing link_numbering add the link number.
d5087 1
a5087 1
     && (text->source ? !psrcview_no_anchor_numbering : 1 )
d5089 1
a5089 1
     && links_are_numbered()) {
d5092 2
a5093 1
	sprintf(marker,"[%d]", a->number);
d5096 1
a5096 1
	    text->LastChar = ']'; /* if marker not after space caused split */
d5106 2
a5107 4
PUBLIC int HText_beginAnchor ARGS3(
	HText *,		text,
	BOOL,			underline,
	HTChildAnchor *,	anc)
d5109 1
a5109 1
    TextAnchor * a;
d5112 1
d5117 1
d5145 1
a5145 1
    return(a->number);
d5149 2
a5150 4
PRIVATE BOOL HText_endAnchor0 ARGS3(
	HText *,	text,
	int,		number,
	int,		really)
d5155 8
a5162 8
     *  The number argument is set to 0 in HTML.c and
     *  LYCharUtils.c when we want to end the anchor
     *  for the immediately preceding HText_beginAnchor()
     *  call.  If it's greater than 0, we want to handle
     *  a particular anchor.  This allows us to set links
     *  for positions indicated by NAME or ID attributes,
     *  without needing to close any anchor with an HREF
     *  within which that link might be embedded. -FM
d5174 3
a5176 3
	     *  There's no anchor with that number,
	     *  so we'll default to the last anchor,
	     *  and cross our fingers. -FM
d5183 1
a5183 1
			a->number, a->link_type));
d5186 1
a5186 1
	 *  Shouldn't happen, but put test here anyway to be safe. - LE
d5190 1
a5190 1
	   "BUG: HText_endAnchor0: internal error: last anchor was input field!\n"));
d5196 1
a5196 1
	 *  If it goes somewhere...
d5199 6
a5204 7
	BOOL remove_numbers_on_empty = (BOOL) (
	    (links_are_numbered() &&
	     (text->hiddenlinkflag != HIDDENLINKS_MERGE ||
	      (LYNoISMAPifUSEMAP &&
	       !(text->node_anchor && text->node_anchor->bookmark) &&
	       HTAnchor_isISMAPScript(
		   HTAnchor_followLink(a->anchor))))));
d5213 15
a5227 1
	l = text->Lines;		/* lineno of last */
d5235 1
a5235 1
	start = last;			/* Used later */
d5238 3
a5240 3
	 *  Check if the anchor content has only
	 *  white and special characters, starting
	 *  with the content on the last line. -FM
d5243 1
a5243 1
	if (a->extent > (int)last->size) {
d5245 2
a5246 2
	     *  The anchor extends over more than one line,
	     *  so set up to check the entire last line. -FM
d5251 2
a5252 2
	     *  The anchor is restricted to the last line,
	     *  so check from the start of the anchor. -FM
d5257 1
a5257 1
	while (j < (int)last->size) {
d5267 1
a5267 1
	    if (a->extent > (int)last->size) {
d5269 4
a5272 4
		 *  The anchor starts on a preceding line, and
		 *  the last line has only white and special
		 *  characters, so declare the entire extent
		 *  of the last line as blank. -FM
d5277 3
a5279 3
		 *  The anchor starts on the last line, and
		 *  has only white or special characters, so
		 *  declare the anchor's extent as blank. -FM
d5285 6
a5290 6
	 *  While the anchor starts on a line preceding
	 *  the one we just checked, and the one we just
	 *  checked has only white and special characters,
	 *  check whether the anchor's content on the
	 *  immediately preceding line also has only
	 *  white and special characters. -FM
d5303 2
a5304 2
		 *  The anchor starts on a preceding line,
		 *  so check all of this line. -FM
d5310 1
a5310 1
		 *  The anchor starts on this line. -FM
d5314 1
a5314 1
	    while (j < (int)prev->size) {
d5324 2
a5325 2
		if (a->extent > (CurBlankExtent + (int)prev->size) ||
		    (a->extent == CurBlankExtent + (int)prev->size &&
d5331 4
a5334 4
		     *  This line has only white and special
		     *  characters, so treat its entire extent
		     *  as blank, and decrement the pointer for
		     *  the line to be analyzed. -FM
d5341 3
a5343 3
		     *  The anchor starts on this line, and it
		     *  has only white or special characters, so
		     *  declare the anchor's extent as blank. -FM
d5350 1
a5350 1
	if (!really) {			/* Just report whether it is empty */
d5352 1
a5352 1
	    return (BOOL)(i == 0);
d5356 3
a5358 3
	     *  It's an invisible anchor probably from an ALT=""
	     *  or an ignored ISMAP attribute due to a companion
	     *  USEMAP. -FM
d5363 3
a5365 3
		   "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num, a->line_pos, a->extent,
		   BlankExtent));
d5368 2
a5369 2
	     *  If links are numbered, then try to get rid of the
	     *  numbered bracket and adjust the anchor count. -FM
d5384 3
a5386 3
		 *  Set start->data[j] to the close-square-bracket,
		 *  or to the beginning of the line on which the
		 *  anchor start. -FM
d5390 1
a5390 1
		     *  The anchor starts on the last line. -FM
d5395 1
a5395 1
		     *  The anchor starts on a previous line. -FM
d5405 7
a5411 7
		 *  If start->data[j] is a close-square-bracket, verify
		 *  that it's the end of the numbered bracket, and if so,
		 *  strip the numbered bracket.  If start->data[j] is not
		 *  a close-square-bracket, check whether we had a wrap
		 *  and the close-square-bracket is at the end of the
		 *  previous line.  If so, strip the numbered bracket
		 *  from that line. -FM
d5426 2
a5427 2
			 *  The numbered bracket is entirely
			 *  on this line. -FM
d5430 2
a5431 2
			if (start==last && (int)text->permissible_split > j) {
			    if ((int)text->permissible_split - NumSize < j)
d5437 1
a5437 1
			while (k < (int)start->size)
d5448 1
a5448 1
			     start->data[j++] = '\0';
d5466 3
a5468 3
			     *  The numbered bracket started on the
			     *  previous line, and part of it was
			     *  wrapped to this line. -FM
d5472 1
a5472 1
			    while (i < (int)prev->size)
d5479 1
a5479 1
				if ((int)text->permissible_split < k)
d5486 1
a5486 1
			    while (k < (int)start->size)
d5500 2
a5501 2
			     *  Shucks!  We didn't find the
			     *  numbered bracket. -FM
d5507 2
a5508 2
			 *  Shucks!  We didn't find the
			 *  numbered bracket. -FM
d5536 3
a5538 3
			     *  The numbered bracket is all on the
			     *  previous line, and the anchor content
			     *  was wrapped to the last line. -FM
d5542 1
a5542 1
			    while (k < (int)prev->size)
d5550 2
a5551 2
			     *  Shucks!  We didn't find the
			     *  numbered bracket. -FM
d5557 2
a5558 2
			 *  Shucks!  We didn't find the
			 *  numbered bracket. -FM
d5564 2
a5565 2
		     *  Shucks!  We didn't find the
		     *  numbered bracket. -FM
d5574 3
a5576 3
	     *  The anchor's content is not restricted to only
	     *  white and special characters, so we'll show it
	     *  as a link. -FM
d5581 3
a5583 3
		   "HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
d5588 5
a5592 5
	     *  The anchor's content is restricted to white
	     *  and special characters, so set its number
	     *  and extent to zero, decrement the visible
	     *  anchor number counter, and add this anchor
	     *  to the hidden links list. -FM
d5602 4
a5605 4
	     *  The anchor's content is not restricted to white
	     *  and special characters, so we'll display the
	     *  content, but shorten its extent by any trailing
	     *  blank lines we've detected. -FM
d5608 1
a5608 1
					BlankExtent : 0);
d5612 4
a5615 4
		   "->[%d](%d,%d,%d,%d)\n",
		   a->number,
		   a->line_num,a->line_pos,a->extent,
		   BlankExtent));
d5618 1
a5618 1
	if (!really)			/* Just report whether it is empty */
d5621 3
a5623 3
	 *  It's a named anchor without an HREF, so it
	 *  should be registered but not shown as a
	 *  link. -FM
d5631 1
a5631 3
PUBLIC void HText_endAnchor ARGS2(
	HText *,	text,
	int,		number)
d5642 1
a5642 3
PUBLIC BOOL HText_isAnchorBlank ARGS2(
	HText *,	text,
	int,		number)
d5648 1
a5648 3
PUBLIC void HText_appendText ARGS2(
	HText *,	text,
	CONST char *,	str)
d5650 1
a5650 1
    CONST char *p;
d5663 1
a5663 3

PRIVATE int remove_special_attr_chars ARGS1(
	char *,		buf)
d5668 1
a5668 1
    for (cp = buf; *cp != '\0' ; cp++) {
d5670 1
a5670 1
	 *  Don't print underline chars.
d5674 1
a5674 1
	   *buf++ = *cp;
a5680 1

d5682 6
a5687 7
**  This function trims blank lines from the end of the document, and
**  then gets the hightext from the text by finding the char position,
**  and brings the anchors in line with the text by adding the text
**  offset to each of the anchors.
*/
PUBLIC void HText_endAppend ARGS1(
	HText *,	text)
d5694 1
a5694 1
    CTRACE((tfp,"Gridtext: Entering HText_endAppend\n"));
d5697 1
a5697 1
     *  Create a  blank line at the bottom.
d5705 3
a5707 3
	 *  If output was stopped because memory was low, and we made
	 *  it to the end of the document, reset those flags and hope
	 *  things are better now. - kw
d5713 2
a5714 2
	 *  Could happen if TABLE end tag was missing.
	 *  Alternatively we could cancel in this case. - kw
d5720 1
a5720 1
     *  Get the first line.
d5725 1
a5725 1
     *  Remove the blank lines at the end of document.
d5731 1
a5731 1
			    text->last_line->data));
d5733 1
a5733 1
	 *  line_ptr points to the first line.
d5741 1
a5741 1
			    text->last_line->data));
d5745 2
a5746 2
     *  Fix up the anchor structure values and
     *  create the hightext strings. -FM
a5750 1

d5752 27
a5778 28
**  This function gets the hightext from the text by finding the char
**  position, and brings the anchors in line with the text by adding the text
**  offset to each of the anchors.
**
**  `Forms input' fields cannot be displayed properly without this function
**  to be invoked (detected in display_partial mode).
**
**  If final is set, this is the final fixup; if not set, we don't have
**  to do everything because there should be another call later.
**
**  BEFORE this function has treated a TextAnchor, its line_pos and
**  extent fields are counting bytes in the HTLine data, including
**  invisible special attribute chars and counting UTF-8 multibyte
**  characters as multiple bytes.
**
**  AFTER the adjustment, the anchor line_pos (and hightext offset if
**  applicable) fields indicate x positions in terms of displayed character
**  cells, and the extent field apparently is unimportant; the anchor text has
**  been copied to the hightext fields (which should have been NULL up to that
**  point), with special attribute chars removed.
**
**  This needs to be done so that display_page finds the anchors in the
**  form it expects when it sets the links[] elements.
*/
PRIVATE void HText_trimHightext ARGS3(
	HText *,	text,
	BOOLEAN,	final,
	int,		stop_before)
d5795 1
a5795 1
	CTRACE((tfp, "Gridtext: Entering HText_trimHightext (final)\n"));
d5800 2
a5801 2
	       "Gridtext: Entering HText_trimHightext (partial: 0..%d/%d)\n",
	       stop_before, text->Lines));
d5805 1
a5805 1
     *  Get the first line.
d5811 2
a5812 2
     *  Fix up the anchor structure values and
     *  create the hightext strings. -FM
d5815 5
a5819 4
	anchor_ptr != NULL;
	prev_a = anchor_ptr, anchor_ptr = anchor_ptr->next) {
	int have_soft_newline_in_1st_line = 0;
re_parse:
d5821 1
a5821 1
	 *  Find the right line.
d5824 2
a5825 2
	       line_ptr = line_ptr->next, cur_line++) {
	    ; /* null body */
d5830 3
a5832 3
	     *  If this is not the final call, stop when we have reached
	     *  the last line, or the very end of preceding line.
	     *  The last line is probably still not finished. - kw
d5836 2
a5837 2
	    if ( anchor_ptr->line_num >= text->Lines - 1
		 && anchor_ptr->line_pos >= (int) text->last_line->prev->size )
d5840 2
a5841 2
	     *  Also skip this anchor if it looks like HText_endAnchor
	     *  is not yet done with it. - kw
d5851 3
a5853 3
	 *  If hightext has already been set, then we must have already
	 *  done the trimming & adjusting for this anchor, so avoid
	 *  doing it a second time. - kw
d5866 6
a5871 3
	       "Gridtext: Anchor found on line:%d col:%d [%d] ext:%d\n",
	       cur_line, anchor_ptr->line_pos,
	       anchor_ptr->number, anchor_ptr->extent));
d5875 2
a5876 2
	 *  Strip off any spaces or SpecialAttrChars at the beginning,
	 *  if they exist, but only on HYPERTEXT_ANCHORS.
d5901 1
a5901 1
	if ((unsigned)anchor_ptr->line_pos >= strlen(line_ptr->data)) {
d5904 2
a5905 2
		 anchor_ptr->line_pos != (int)line_ptr->size ||
		 (prev_a && /* How could this happen? */
d5920 2
a5921 2
	 && anchor_ptr->extent > 0
	 && anchor_ptr->line_pos >= 0) {
d5923 1
d5952 1
a5952 1
	     && count_line >= stop_before) {
d5963 1
a5963 2
	    if (line_ptr2
	     && line_ptr2->size) {
d5979 2
d5987 1
a5987 1
	 && count_line >= stop_before) {
d5998 5
d6005 11
d6018 3
a6020 1
	    for (; i < anchor_ptr->line_pos; i++) {
d6028 2
d6031 1
d6034 1
a6034 1
	 *  Add the offset, and set the line number.
d6037 1
a6037 4
	anchor_ptr->line_num  = cur_line;

	/*handle LY_SOFT_NEWLINEs -VH */
	anchor_ptr->line_pos += have_soft_newline_in_1st_line;
d6040 2
a6041 2
	       cur_line, anchor_ptr->line_pos,
	       anchor_ptr->number, "in HText_trimHightext"));
a6044 1

d6047 1
a6047 2
PUBLIC HTParentAnchor * HText_nodeAnchor ARGS1(
	HText *,	text)
d6053 2
a6054 2
**				=================
*/
d6057 2
a6058 2
 *  HText_childNextNumber() returns the anchor with index [number],
 *  using a pointer from the previous number (=optimization) or NULL.
d6060 1
a6060 3
PUBLIC HTChildAnchor * HText_childNextNumber ARGS2(
	int,		number,
	void**,		prev)
d6063 1
a6063 1
    TextAnchor * a = *prev;
d6066 1
a6066 1
	return (HTChildAnchor *)0;	/* Fail */
d6073 1
a6073 2
    for( ; a && a->number != number; a = a->next)
	;
d6076 2
a6077 2
	return (HTChildAnchor *)0;	/* Fail */
    *prev = (void*)a;
d6082 6
a6087 7
 *  HText_FormDescNumber() returns a description of the form field
 *  with index N.  The index corresponds to the [number] we print
 *  for the field. -FM & LE
 */
PUBLIC void HText_FormDescNumber ARGS2(
	int,		number,
	char **,	desc)
d6089 1
a6089 1
    TextAnchor * a;
d6095 2
a6096 2
	 *desc = gettext("unknown field or link");
	 return;
d6110 45
a6154 45
	case F_TEXT_TYPE:
	    *desc = gettext("text entry field");
	    return;
	case F_PASSWORD_TYPE:
	    *desc = gettext("password entry field");
	    return;
	case F_CHECKBOX_TYPE:
	    *desc = gettext("checkbox");
	    return;
	case F_RADIO_TYPE:
	    *desc = gettext("radio button");
	    return;
	case F_SUBMIT_TYPE:
	    *desc = gettext("submit button");
	    return;
	case F_RESET_TYPE:
	    *desc = gettext("reset button");
	    return;
	case F_OPTION_LIST_TYPE:
	    *desc = gettext("popup menu");
	    return;
	case F_HIDDEN_TYPE:
	    *desc = gettext("hidden form field");
	    return;
	case F_TEXTAREA_TYPE:
	    *desc = gettext("text entry area");
	    return;
	case F_RANGE_TYPE:
	    *desc = gettext("range entry field");
	    return;
	case F_FILE_TYPE:
	    *desc = gettext("file entry field");
	    return;
	case F_TEXT_SUBMIT_TYPE:
	    *desc = gettext("text-submit field");
	    return;
	case F_IMAGE_SUBMIT_TYPE:
	    *desc = gettext("image-submit button");
	    return;
	case F_KEYGEN_TYPE:
	    *desc = gettext("keygen field");
	    return;
	default:
	    *desc = gettext("unknown form field");
	    return;
d6159 1
a6159 1
 *    is to jump (input was 123+ or 123- or 123+g or 123-g or 123 or 123g)
d6164 3
a6166 4
PUBLIC int HTGetRelLinkNum ARGS3(
	int,	num,
	int,	rel,
	int,	cur)
d6169 1
a6169 1
    int scrtop = HText_getTopOfScreen(); /*XXX +1? */
d6172 2
a6173 1
    int on_screen = ( curline >= scrtop && curline < (scrtop + display_lines) );
d6180 9
a6188 6
	   num, rel, cur, HTMainText));
    CTRACE((tfp,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
	   scrtop, curline, curanchor, display_lines,
	   on_screen ? "on_screen" : "0"));
    if (!HTMainText) return 0;
    if ( rel==0 ) return num;
d6191 8
a6198 5
    if ( on_screen && curanchor ) {
	CTRACE((tfp,"curanchor=%d at line %d on screen\n",curanchor,curline));
	if ( rel == '+' ) return curanchor + num;
	else if ( rel == '-' ) return curanchor - num;
	else return num; /* shouldn't happen */
d6205 5
a6209 3
	CTRACE((tfp,"  a->line_num=%d, a->number=%d\n", a->line_num, a->number));
	if ( a->line_num >= scrtop ) break;
	if ( a->number == 0 ) continue;
d6213 9
a6221 5
    CTRACE((tfp,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor));
    if ( on_screen ) { /* on screen but not a numbered link */
	for ( ;  a;  a = a->next ) {
	    if ( a->number ) { l = a; curanchor = l->number; }
	    if ( curline == a->line_num && curpos == a->line_pos ) break;
d6224 1
a6224 1
    if ( rel == '+' ) {
d6226 2
a6227 2
    } else if ( rel == '-' ) {
	if ( l )
d6230 1
a6230 1
	    for ( ;  a && a->number==0;  a = a->next ) ;
d6233 2
a6234 2
    }
    else return num; /* shouldn't happen */
d6238 1
a6238 1
 *  HTGetLinkInfo returns some link info based on the number.
d6240 5
a6244 5
 *  If want_go is not 0, caller requests to know a line number for
 *  the link indicated by number.  It will be returned in *go_line, and
 *  *linknum will be set to an index into the links[] array, to use after
 *  the line in *go_line has been made the new top screen line.
 *  *hightext and *lname are unchanged. - KW
d6246 2
a6247 2
 *  If want_go is 0 and the number doesn't represent an input field, info
 *  on the link indicated by number is deposited in *hightext and *lname.
d6249 6
a6254 7
PUBLIC int HTGetLinkInfo ARGS6(
	int,		number,
	int,		want_go,
	int *,		go_line,
	int *,		linknum,
	char **,	hightext,
	char **,	lname)
d6258 1
d6266 1
a6266 1
	return(NO);
d6270 7
a6276 7
	 *  Count anchors, first on current line if there is more
	 *  than one.  We have to count all links, including form
	 *  field anchors and others with a->number == 0, because
	 *  they are or will be included in the links[] array.
	 *  The exceptions are hidden form fields and anchors with
	 *  show_anchor not set, because they won't appear in links[]
	 *  and don't count towards nlinks. - KW
d6285 3
a6287 3
		 *  This anchor is on a different line than the previous one.
		 *  Remember which was the line number of the previous anchor,
		 *  for use in screen positioning later. - KW
d6295 5
a6299 5
		 *  Count all anchors starting with the top line of the
		 *  currently displayed screen.  Just keep on counting
		 *  beyond this screen's bottom line - we'll know whether
		 *  a found anchor is below the current screen by a check
		 *  against nlinks later. - KW
d6307 2
a6308 2
	     *  We found it.  Now process it, depending
	     *  on what kind of info is requested. - KW
d6313 8
a6320 8
		     *  The number requested has been assigned to an anchor
		     *  without any selectable text, so we cannot position
		     *  on it.  The code for suppressing such anchors in
		     *  HText_endAnchor() may not have applied, or it may
		     *  have failed.  Return a failure indication so that
		     *  the user will notice that something is wrong,
		     *  instead of positioning on some other anchor which
		     *  might result in inadvertent activation. - KW
d6322 1
a6322 1
		    return(NO);
d6327 1
a6327 1
		    a->line_num < HTMainText->top_of_screen+(display_lines)) {
d6329 4
a6332 4
		     *  If the requested anchor is within the current screen,
		     *  just set *go_line so that the screen window won't move
		     *  (keep it as it is), and set *linknum to the index of
		     *  this link in the current links[] array. - KW
d6339 3
a6341 3
		     *  if the requested anchor is not within the currently
		     *  displayed screen, set *go_line such that the top line
		     *  will be either
d6347 5
a6351 5
		     *  whichever comes last.  In all cases the line with our
		     *  target will end up being the first line with any links
		     *  on the new screen, so that we can use the
		     *  anchors_this_line counter to point to the anchor in
		     *  the new links[] array.  - kw
d6354 1
d6367 1
a6367 1
		return(LINK_LINE_FOUND);
d6373 1
d6379 2
a6380 2
			    link_dest_intl = HTAnchor_followTypedLink(
				a->anchor, HTInternalLink);
d6383 3
a6385 2
				CTRACE((tfp, "HTGetLinkInfo: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address));
d6391 1
d6394 1
a6394 1
			    return(WWW_INTERN_LINK_TYPE);
d6402 1
a6402 1
		return(WWW_LINK_TYPE);
d6406 1
a6406 1
    return(NO);
d6409 5
a6413 6
PRIVATE BOOLEAN same_anchor_or_field ARGS5(
    int,		numberA,
    FormInfo *,		formA,
    int,		numberB,
    FormInfo *,		formB,
    BOOLEAN,		ta_same)
d6417 1
a6417 1
	    return(YES);
d6419 1
a6419 1
	    return(NO);
d6423 1
a6423 1
	    return(YES);
d6425 1
a6425 1
	    return(NO);
d6427 1
a6427 1
	    return(NO);
d6430 1
a6430 1
	return(NO);
d6435 1
a6435 1
	return(NO);
d6438 1
a6438 1
	return(NO);
d6440 1
a6440 1
	return(YES);
d6458 6
a6463 7
 *  Are there more textarea lines belonging to the same textarea before
 *  (direction < 0) or after (direction > 0) the current one?
 *  On entry, curlink must be the index in links[] of a textarea field. - kw
 */
PUBLIC BOOL HText_TAHasMoreLines ARGS2(
	int,		curlink,
	int,		direction)
d6469 1
a6469 1
	return(NO);
d6496 1
a6496 1
 *  HTGetLinkOrFieldStart - moving to previous or next link or form field.
d6498 1
a6498 1
 *  On input,
d6505 2
a6506 2
 *  The caller wants a information for positioning on the new link to be
 *  deposited in *go_line and (if linknum is not NULL) *linknum.
d6508 15
a6522 16
 *  On failure (no more links in the requested direction) returns NO
 *  and doesn't change *go_line or *linknum.  Otherwise, LINK_DO_ARROWUP
 *  may be returned, and *go_line and *linknum not changed, to indicate that
 *  the caller should use a normal PREV_LINK or PREV_PAGE mechanism.
 *  Otherwise:
 *  The number (0-based counting) for the new top screen line will be returned
 *  in *go_line, and *linknum will be set to an index into the links[] array,
 *  to use after the line in *go_line has been made the new top screen
 *  line. - kw
 */
PUBLIC int HTGetLinkOrFieldStart ARGS5(
	int,		curlink,
	int *,		go_line,
	int *,		linknum,
	int,		direction,
	BOOLEAN,	ta_skip)
d6537 1
a6537 1
	return(NO);
d6546 7
a6552 7
	 *  Count anchors, first on current line if there is more
	 *  than one.  We have to count all links, including form
	 *  field anchors and others with a->number == 0, because
	 *  they are or will be included in the links[] array.
	 *  The exceptions are hidden form fields and anchors with
	 *  show_anchor not set, because they won't appear in links[]
	 *  and don't count towards nlinks. - KW
d6561 3
a6563 3
		 *  This anchor is on a different line than the previous one.
		 *  Remember which was the line number of the previous anchor,
		 *  for use in screen positioning later. - KW
d6583 1
a6583 1
		if (same_anchor_as_link(curlink,a, ta_skip)) {
d6592 1
a6592 1
			   same_anchor_as_link(curlink,previous.anc, ta_skip)) {
d6624 1
d6626 3
a6628 3
	     *  We know where to go; most of the stuff below is just
	     *  tweaks to try to position the new screen in a specific
	     *  way.
d6630 3
a6632 3
	     *  In some cases going to a previous link can be done
	     *  via the normal LYK_PREV_LINK action, which may give
	     *  better positioning of the new screen. - kw
d6635 1
a6635 1
		a->line_num >= HTMainText->top_of_screen-(display_lines)) {
d6645 1
a6645 1
		    return(LINK_DO_ARROWUP);
d6649 7
a6655 7
	     *  The fundamental limitation of the current anchors_this_line
	     *  counter method is that we only can set *linknum to the right
	     *  index into the future links[] array if the line with our link
	     *  ends up being the first line with any links (that count) on
	     *  the new screen.  Subject to that restriction we still have
	     *  some vertical liberty (sometimes), and try to make the best
	     *  of it.  It may be a question of taste though. - kw
d6661 3
a6663 2
		    (HTMainText->top_of_screen - a->line_num + (display_lines) - 1)
		    / (display_lines);
d6670 1
a6670 1
		       HTMainText->top_of_screen+(display_lines)) {
d6672 2
a6673 1
		    (a->line_num - HTMainText->top_of_screen) / (display_lines);
d6694 1
a6694 1
	    return(LINK_LINE_FOUND);
d6697 1
a6697 1
    return(NO);
d6701 16
a6716 18
 *  This function finds the line indicated by line_num in the
 *  HText structure indicated by text, and searches that line
 *  for the first hit with the string indicated by target.  If
 *  there is no hit, FALSE is returned.  If there is a hit, then
 *  a copy of the line starting at that first hit is loaded into
 *  *data with all IsSpecial characters stripped, its offset and
 *  the printable target length (without IsSpecial, or extra CJK
 *  or utf8 characters) are loaded into *offset and *tLen, and
 *  TRUE is returned. -FM
 */
PUBLIC BOOL HText_getFirstTargetInLine ARGS7(
	HText *,	text,
	int,		line_num,
	BOOL,		utf_flag,
	int *,		offset,
	int *,		tLen,
	char **,	data,
	CONST char *,	target)
d6721 1
a6721 1
    char *cp;
d6724 2
a6725 2
     *  Make sure we have an HText structure, that line_num is
     *  in its range, and that we have a target string. -FM
d6728 4
a6731 4
	line_num >= 0 &&
	line_num <= text->Lines &&
	non_empty(target))) {
	return(FALSE);
d6735 1
a6735 1
     *  Find the line and set up its data and offset -FM
d6741 1
a6741 1
	    return(FALSE);
d6745 3
a6747 3
	return(FALSE);
    LineData = (char *)line->data;
    LineOffset = (int)line->offset;
d6750 4
a6753 4
     *  If the target is on the line, load the offset of
     *  its first character and the subsequent line data,
     *  strip any special characters from the loaded line
     *  data, and return TRUE. -FM
d6760 1
a6760 1
	(LineOffset + LenNeeded) < DISPLAY_COLS) {
d6762 4
a6765 4
	 *  We had a hit so load the results,
	 *  remove IsSpecial characters from
	 *  the allocated data string, and
	 *  return TRUE. -FM
d6769 3
a6771 3
	 StrAllocCopy(*data, cp);
	 remove_special_attr_chars(*data);
	 return(TRUE);
d6775 1
a6775 1
     *  The line does not contain the target. -FM
d6777 1
a6777 1
    return(FALSE);
d6781 2
a6782 2
 *  HText_getNumOfLines returns the number of lines in the
 *  current document.
d6784 1
a6784 1
PUBLIC int HText_getNumOfLines NOARGS
d6786 20
a6805 1
    return(HTMainText ? HTMainText->Lines : 0);
d6809 2
a6810 2
 *  HText_getTitle returns the title of the
 *  current document.
d6812 1
a6812 1
PUBLIC CONST char * HText_getTitle NOARGS
d6814 2
a6815 2
    return(HTMainText ?
	  HTAnchor_title(HTMainText->node_anchor) : 0);
d6819 1
a6819 1
PUBLIC CONST char *HText_getStyle NOARGS
d6821 2
a6822 2
   return(HTMainText ?
	  HTAnchor_style(HTMainText->node_anchor) : 0);
d6827 3
a6829 3
 *  HText_getSugFname returns the suggested filename of the current
 *  document (normally derived from a Content-Disposition header with
 *  attachment; filename=name.suffix). -FM
d6831 1
a6831 1
PUBLIC CONST char * HText_getSugFname NOARGS
d6833 2
a6834 2
    return(HTMainText ?
	  HTAnchor_SugFname(HTMainText->node_anchor) : 0);
d6838 6
a6843 6
 *  HTCheckFnameForCompression receives the address of an allocated
 *  string containing a filename, and an anchor pointer, and expands
 *  or truncates the string's suffix if appropriate, based on whether
 *  the anchor indicates that the file is compressed.  We assume
 *  that the file was not uncompressed (as when downloading), and
 *  believe the headers about whether it's compressed or not. -FM
d6845 7
a6851 8
 *  Added third arg - if strip_ok is FALSE, we don't trust the anchor
 *  info enough to remove a compression suffix if the anchor object
 *  does not indicate compression. - kw
 */
PUBLIC void HTCheckFnameForCompression ARGS3(
	char **,		fname,
	HTParentAnchor *,	anchor,
	BOOL,			strip_ok)
d6854 5
a6858 4
    char *dot = NULL, *cp = NULL;
    char *suffix;
    CONST char *ct = NULL;
    CONST char *ce = NULL;
d6863 1
a6863 1
     *  Make sure we have a string and anchor. -FM
d6869 1
a6869 1
     *  Make sure we have a file, not directory, name. -FM
d6875 2
a6876 2
     *  Check the anchor's content_type and content_encoding
     *  elements for a gzip or Unix compressed file. -FM
d6882 2
a6883 2
	 *  No Content-Encoding, so check
	 *  the Content-Type. -FM
d6896 1
a6896 10
	if (!strcasecomp(ce, "gzip") ||
	    !strcasecomp(ce, "x-gzip")) {
	    method = cftGzip;
	} else if (!strcasecomp(ce, "compress") ||
		   !strcasecomp(ce, "x-compress")) {
	    method = cftCompress;
	} else if (!strcasecomp(ce, "bzip2") ||
		   !strcasecomp(ce, "x-bzip2")) {
	    method = cftBzip2;
	}
d6900 3
a6902 3
     *  If no Content-Encoding has been detected via the anchor
     *  pointer, but strip_ok is not set, there is nothing left
     *  to do. - kw
d6911 1
a6911 1
     && !strcasecomp(dot, ".tgz")) {
d6919 2
a6920 2
     *  Seek the last dot, and check whether
     *  we have a gzip or compress suffix. -FM
d6923 3
a6925 1
	if (HTCompressFileType(fn, ".", &cp) != cftNone) {
d6928 3
a6930 3
		 *  It has a suffix which signifies a gzipped
		 *  or compressed file for us, but the anchor
		 *  claims otherwise, so tweak the suffix. -FM
d6936 2
a6937 1
	if ((second = HTCompressFileType(fn, "-_", &cp)) != cftNone) {
d6940 3
a6942 3
		 *  It has a tail which signifies a gzipped
		 *  file for us, but the anchor claims otherwise,
		 *  so tweak the suffix. -FM
d6944 1
a6944 1
		if (cp == dot+1)
d6949 3
a6951 3
		 *  The anchor claims it's gzipped, and we
		 *  believe it, so force this tail to the
		 *  conventional suffix. -FM
d6968 1
a6968 1
    default:
d6974 3
d6986 1
a6986 1
     *  Add the appropriate suffix. -FM
d7003 12
a7014 2
 *  HText_getLastModified returns the Last-Modified header
 *  if available, for the current document. -FM
d7016 1
a7016 1
PUBLIC CONST char * HText_getLastModified NOARGS
d7018 2
a7019 2
    return(HTMainText ?
	  HTAnchor_last_modified(HTMainText->node_anchor) : 0);
d7023 2
a7024 2
 *  HText_getDate returns the Date header
 *  if available, for the current document. -FM
d7026 1
a7026 1
PUBLIC CONST char * HText_getDate NOARGS
d7028 2
a7029 2
    return(HTMainText ?
	  HTAnchor_date(HTMainText->node_anchor) : 0);
d7032 1
d7034 2
a7035 2
 *  HText_getServer returns the Server header
 *  if available, for the current document. -FM
d7037 1
a7037 1
PUBLIC CONST char * HText_getServer NOARGS
d7039 2
a7040 2
    return(HTMainText ?
	  HTAnchor_server(HTMainText->node_anchor) : 0);
d7042 1
d7045 3
a7047 3
 *  HText_pageDisplay displays a screen of text
 *  starting from the line 'line_num'-1.
 *  This is the primary call for lynx.
d7049 2
a7050 3
PUBLIC void HText_pageDisplay ARGS2(
	int,		line_num,
	char *,		target)
d7059 1
d7061 8
a7068 8
	**  Garbage is reported from forms input fields in incremental mode.
	**  So we start HText_trimHightext() to forget this side effect.
	**  This function was split-out from HText_endAppend().
	**  It may not be the best solution but it works. - LP
	**
	**  (FALSE =  indicate that we are in partial mode)
	**  Multiple calls of HText_trimHightext works without problem now.
	*/
d7075 1
a7075 1
    display_page(HTMainText, line_num-1, target);
d7092 2
a7093 2
 *  Return YES if we have a whereis search target on the displayed
 *  page. - kw
d7095 1
a7095 1
PUBLIC BOOL HText_pageHasPrevTarget NOARGS
d7104 107
a7210 2
 *  HText_LinksInLines returns the number of links in the
 *  'Lines' number of lines beginning with 'line_num'-1. -FM
d7212 29
a7240 4
PUBLIC int HText_LinksInLines ARGS3(
	HText *,	text,
	int,		line_num,
	int,		Lines)
d7264 1
a7264 2
PUBLIC void HText_setStale ARGS1(
	HText *,	text)
d7269 1
a7269 2
PUBLIC void HText_refresh ARGS1(
	HText *,	text)
d7275 1
a7275 2
PUBLIC int HText_sourceAnchors ARGS1(
	HText *,	text)
d7280 1
a7280 2
PUBLIC BOOL HText_canScrollUp ARGS1(
	HText *,	text)
d7285 4
a7288 1
PUBLIC BOOL HText_canScrollDown NOARGS
d7290 1
a7290 1
    HText * text = HTMainText;
d7293 1
a7293 1
     && ((text->top_of_screen + display_lines) < text->Lines+1));
d7298 1
a7298 2
PUBLIC void HText_scrollTop ARGS1(
	HText *,	text)
d7303 1
a7303 2
PUBLIC void HText_scrollDown ARGS1(
	HText *,	text)
d7308 1
a7308 2
PUBLIC void HText_scrollUp ARGS1(
	HText *,	text)
d7313 1
a7313 2
PUBLIC void HText_scrollBottom ARGS1(
	HText *,	text)
a7317 1

d7319 2
a7320 2
**		==================
*/
d7324 1
a7324 2
PUBLIC BOOL HText_select ARGS1(
	HText *,	text)
d7328 2
a7329 2
	 *  Reset flag for whereis search string - cannot be true here
	 *  since text is not our HTMainText. - kw
d7336 2
a7337 6
	text->first_lineno_last_disp_partial =
	    text->last_lineno_last_disp_partial = -1;
	if (HTMainText) {
	    HTMainText->first_lineno_last_disp_partial =
		HTMainText->last_lineno_last_disp_partial = -1;
	}
d7342 2
a7343 2
	if ( text->node_anchor->UCStages->s[UCT_STAGE_HTEXT].LYhndl
	     != current_char_set )
d7362 1
a7362 1
	 *  Make this text the most current in the loaded texts list. -FM
a7365 2
	    /* let lynx do it */
	    /* display_page(text, text->top_of_screen, ""); */
d7371 3
a7373 3
 *  This function returns TRUE if doc's post_data, address
 *  and isHEAD elements are identical to those of a loaded
 *  (memory cached) text. -FM
d7375 1
a7375 2
PUBLIC BOOL HText_POSTReplyLoaded ARGS1(
	DocInfo *,	doc)
d7384 1
a7384 1
     *  Make sure we have the structures. -FM
d7387 1
a7387 1
	return(FALSE);
d7390 1
a7390 1
     *  Make sure doc is for a POST reply. -FM
d7394 1
a7394 1
	return(FALSE);
d7398 2
a7399 2
     *  Loop through the loaded texts looking for a
     *  POST reply match. -FM
d7401 1
a7401 1
    while (NULL != (text = (HText *)HTList_nextObject(cur))) {
d7408 1
a7408 1
	    return(TRUE);
d7412 1
a7412 1
    return(FALSE);
d7415 1
a7415 2
PUBLIC BOOL HTFindPoundSelector ARGS1(
	CONST char *,		selector)
d7417 1
a7417 1
    TextAnchor * a;
d7419 1
d7425 1
a7425 1
		www_search_result = a->line_num+1;
d7428 1
a7428 1
			     a->number, www_search_result));
d7432 1
a7432 1
		return(YES);
d7436 1
a7436 3

    return(NO);

d7439 1
a7439 3
PUBLIC BOOL HText_selectAnchor ARGS2(
	HText *,		text,
	HTChildAnchor *,	anchor)
d7441 1
a7441 1
    TextAnchor * a;
d7450 3
a7452 2
    for (a=text->first_anchor; a; a=a->next) {
	if (a->anchor == anchor) break;
d7459 2
a7460 2
    if (text != HTMainText) {		/* Comment out by ??? */
	HTMainText = text;		/* Put back in by tbl 921208 */
d7462 2
a7463 1
    }
d7465 2
a7466 9
    {
	 int l = a->line_num;
	 CTRACE((tfp, "HText: Selecting anchor [%d] at line %d\n",
		      a->number, l));

	if ( !text->stale &&
	     (l >= text->top_of_screen) &&
	     ( l < text->top_of_screen + display_lines+1))
		 return YES;
d7468 6
a7473 1
	www_search_result = l - (display_lines/3); /* put in global variable */
a7478 1

d7480 5
a7484 5
**		=================
**
**	These are called from the application.  There are many more functions
**	not included here from the original text object.
*/
d7490 1
a7490 3
PUBLIC void HText_applyStyle ARGS2(
	HText *,	me GCC_UNUSED,
	HTStyle *,	style GCC_UNUSED)
a7494 1

d7497 1
a7497 3
PUBLIC void HText_updateStyle ARGS2(
	HText *,	me GCC_UNUSED,
	HTStyle *,	style GCC_UNUSED)
a7501 1

d7504 1
a7504 3
PUBLIC HTStyle * HText_selectionStyle ARGS2(
	HText *,		me GCC_UNUSED,
	HTStyleSheet *,		sheet GCC_UNUSED)
a7508 1

d7511 2
a7512 4
PUBLIC void HText_replaceSel ARGS3(
	HText *,	me GCC_UNUSED,
	CONST char *,	aString GCC_UNUSED,
	HTStyle *,	aStyle GCC_UNUSED)
a7515 1

d7517 3
a7519 5
**	(style recovery only)
*/
PUBLIC void HTextApplyToSimilar ARGS2(
	HText *,	me GCC_UNUSED,
	HTStyle *,	style GCC_UNUSED)
a7523 1

d7525 3
a7527 5
**	(style recovery only)
*/
PUBLIC void HTextSelectUnstyled ARGS2(
	HText *,		me GCC_UNUSED,
	HTStyleSheet *,		sheet GCC_UNUSED)
a7531 1

d7534 1
a7534 2
PUBLIC void HText_unlinkSelection ARGS1(
	HText *,	me GCC_UNUSED)
d7539 1
a7539 2
PUBLIC HTAnchor * HText_referenceSelected ARGS1(
	HText *,	me GCC_UNUSED)
d7541 1
a7541 1
     return 0;
d7544 3
a7547 3
PUBLIC int HText_getTopOfScreen NOARGS
{
    HText * text = HTMainText;
d7551 1
a7551 2
PUBLIC int HText_getLines ARGS1(
	HText *,	text)
d7556 20
a7575 3
PUBLIC HTAnchor * HText_linkSelTo ARGS2(
	HText *,	me GCC_UNUSED,
	HTAnchor *,	anchor GCC_UNUSED)
d7581 1
a7581 1
 *  Utility for freeing the list of previous isindex and whereis queries. -FM
d7583 1
a7583 1
PUBLIC void HTSearchQueries_free NOARGS
d7585 1
a7585 10
    char *query;
    HTList *cur = search_queries;

    if (!cur)
	return;

    while (NULL != (query = (char *)HTList_nextObject(cur))) {
	FREE(query);
    }
    HTList_delete(search_queries);
a7586 1
    return;
d7590 2
a7591 2
 *  Utility for listing isindex and whereis queries, making
 *  any repeated queries the most current in the list. -FM
d7593 1
a7593 2
PUBLIC void HTAddSearchQuery ARGS1(
	char *,		query)
d7614 1
a7614 1
    while (NULL != (old = (char *)HTList_nextObject(cur))) {
d7626 1
a7626 2
PUBLIC int do_www_search ARGS1(
	DocInfo *,	doc)
d7629 2
a7630 1
    int ch, recall;
d7636 1
a7636 1
     *  Load the default query buffer
d7638 1
a7638 1
    if ((cp=strchr(doc->address, '?')) != NULL) {
d7640 2
a7641 2
	 *  This is an index from a previous search.
	 *  Use its query as the default.
d7644 2
a7645 2
	LYstrncpy(searchstring, ++cp, sizeof(searchstring)-1);
	for (cp=searchstring; *cp; cp++)
d7651 1
a7651 1
	 *  Make sure it's treated as the most recent query. -FM
d7656 1
a7656 1
	 *  New search; no default.
d7663 1
a7663 1
     *  Prompt for a query string.
d7676 3
a7678 3
get_query:
    if ((ch=LYgetstr(searchstring, VISIBLE,
		     sizeof(searchstring), recall)) < 0 ||
d7683 1
a7683 1
		 *  Use the second to last query in the list. -FM
d7689 1
a7689 1
		 *  Go back to the previous query in the list. -FM
d7695 1
a7695 1
		 *  Roll around to the last query in the list. -FM
d7698 3
a7700 3
	    if ((cp=(char *)HTList_objectAt(search_queries,
					    QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d7714 1
a7714 1
		 *  Use the first query in the list. -FM
d7720 1
a7720 1
		 *  Advance to the next query in the list. -FM
d7726 1
a7726 1
		 *  Roll around to the first query in the list. -FM
d7729 3
a7731 3
	    if ((cp=(char *)HTList_objectAt(search_queries,
					    QueryNum)) != NULL) {
		LYstrncpy(searchstring, cp, sizeof(searchstring)-1);
d7745 1
a7745 1
	 *  Search cancelled.
d7748 1
a7748 1
	return(NULLFILE);
d7752 1
a7752 1
     *  Strip leaders and trailers. -FM
d7757 1
a7757 1
	return(NULLFILE);
d7762 1
a7762 1
     *  Don't resubmit the same query unintentionally.
d7766 1
a7766 1
	return(NULLFILE);
d7770 2
a7771 2
     *  Add searchstring to the query list,
     *  or make it the most current. -FM
d7776 1
a7776 1
     *  Show the URL with the new query.
d7778 1
a7778 1
    if ((cp=strchr(doc->address, '?')) != NULL)
d7784 1
a7784 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
d7786 1
a7786 1
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
d7792 1
a7792 1
     *  OK, now we do the search.
d7796 2
a7797 2
	 *	Memory leak fixed.
	 *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d7800 1
d7802 1
a7802 1
	    cp_freeme = stub_HTAnchor_address((HTAnchor *)HTMainAnchor);
d7804 1
a7804 1
	    cp_freeme = HTAnchor_address((HTAnchor *)HTMainAnchor);
d7808 1
a7808 1
	CTRACE((tfp,"\ndo_www_search: newfile: %s\n",doc->address));
d7811 1
a7811 1
	 *  Yah, the search succeeded.
d7813 1
a7813 1
	return(NORMAL);
d7817 5
a7821 5
     *  Either the search failed (Yuk), or we got redirection.
     *  If it's redirection, use_this_url_instead is set, and
     *  mainloop() will deal with it such that security features
     *  and restrictions are checked before acting on the URL, or
     *  rejecting it. -FM
d7823 1
a7823 1
    return(NOT_FOUND);
d7826 1
a7826 3
PRIVATE void write_offset ARGS2(
	FILE *,		fp,
	HTLine *,	line)
d7831 2
a7832 2
	for (i = 0; i < (int)line->offset; i++) {
	     fputc(' ', fp);
d7837 1
a7837 2
PRIVATE void write_hyphen ARGS1(
	FILE *,		fp)
d7844 1
a7844 1
	fputc(0xad, fp); /* the iso8859 byte for SHY */
d7851 43
a7893 8
 *  Print the contents of the file in HTMainText to
 *  the file descriptor fp.
 *  If is_reply is TRUE add ">" to the beginning of each
 *  line to specify the file is a reply to message.
 */
PUBLIC void print_wwwfile_to_fd ARGS2(
	FILE *,		fp,
	BOOLEAN,	is_reply)
d7897 3
a7899 1
    HTLine * line;
d7901 1
a7901 1
    HText* text = HTMainText;
d7904 5
a7908 5
    BOOL bs = (BOOL)(!is_reply
		&& text != 0
		&& with_backspaces
		&& HTCJK == NOCJK
		&& !text->T.output_utf8);
d7919 3
a7921 1
		fputc('>',fp);
d7924 1
a7924 1
	    fputc('\n',fp);
d7926 1
a7926 1
	     *  Add news-style quotation if requested. -FM
d7929 3
a7931 1
		fputc('>',fp);
d7938 1
a7938 1
	 *  Add data.
d7940 5
a7944 2
	for (i = 0; line->data[i] != '\0'; i++) {
	    if (!IsSpecialAttrChar(line->data[i])) {
d7947 3
a7949 3
		    fputc(line->data[i], fp);
		    fputc('\b',fp);
		    fputc(line->data[i], fp);
d7951 3
a7953 3
		    fputc('_',fp);
		    fputc('\b',fp);
		    fputc(line->data[i], fp);
d7956 3
a7958 3
		fputc(line->data[i], fp);
	    } else if (line->data[i] == LY_SOFT_HYPHEN &&
		line->data[i + 1] == '\0') { /* last char on line */
d7961 8
a7968 8
		switch (line->data[i]) {
		    case LY_UNDERLINE_START_CHAR:
		    case LY_UNDERLINE_END_CHAR:
			fputc('_', fp);
			break;
		    case LY_BOLD_START_CHAR:
		    case LY_BOLD_END_CHAR:
			break;
d7973 16
a7988 16
		switch (line->data[i]) {
		    case LY_UNDERLINE_START_CHAR:
			if (!in_b)
			    in_u = TRUE; /*favor bold over underline*/
			break;
		    case LY_UNDERLINE_END_CHAR:
			in_u = FALSE;
			break;
		    case LY_BOLD_START_CHAR:
			if (in_u)
			    in_u = FALSE; /* turn it off*/
			in_b = TRUE;
			break;
		    case LY_BOLD_END_CHAR:
			in_b = FALSE;
			break;
d8002 1
a8002 1
    fputc('\n',fp);
d8007 3
a8009 3
 *  Print the contents of the file in HTMainText to
 *  the file descriptor fp.
 *  First output line is "thelink", ie, the URL for this file.
d8011 2
a8012 4
PUBLIC void print_crawl_to_fd ARGS3(
	FILE *,		fp,
	char *,		thelink,
	char *,		thetitle)
d8016 2
a8017 1
    HTLine * line;
d8030 1
a8030 1
	    fputc('\n',fp);
d8035 1
a8035 1
	 *  Add data.
d8037 8
a8044 5
	for (i = 0; line->data[i] != '\0'; i++) {
	    if (!IsSpecialAttrChar(line->data[i])) {
		fputc(line->data[i], fp);
	    } else if (line->data[i] == LY_SOFT_HYPHEN &&
		line->data[i + 1] == '\0') { /* last char on line */
d8053 1
a8053 1
    fputc('\n',fp);
d8056 1
a8056 1
     *  Add the References list if appropriate
d8058 1
a8058 1
    if ((nolist == FALSE) &&
d8060 1
a8060 1
	printlist(fp,FALSE);
a8061 1

d8067 2
a8068 4
PRIVATE void adjust_search_result ARGS3(
    DocInfo *,	doc,
    int,	tentative_result,
    int,	start_line)
d8072 1
a8072 1
	TextAnchor * a;
d8077 3
a8079 1
	    tentative_result <= HTMainText->top_of_screen+display_lines);
d8088 1
d8105 1
a8105 1
	     a && a->line_num <= tentative_result-1; a = a->next) {
d8114 1
a8114 1
		tentative_result <= HTMainText->top_of_screen)) {
d8116 2
a8117 3
	} else
	if (tentative_result - start_line > 0 &&
	    tentative_result - (start_line + 1) <= max_offset) {
d8119 3
a8121 4
	} else
	if (tentative_result > HTMainText->top_of_screen &&
	    tentative_result <= start_line && /* have wrapped */
	    tentative_result <= HTMainText->top_of_screen+goal) {
d8123 1
a8123 2
	} else
	if (tentative_result <= goal)
d8136 1
a8136 3
PRIVATE BOOL anchor_has_target ARGS2(
	TextAnchor *,	a,
	char *,		target)
d8138 3
a8140 2
    OptionType * option;
    char *stars = NULL, *cp;
d8147 1
a8147 1
    for (count = 0; ; ++count) {
d8155 2
a8156 2
     *  Search the relevant form fields, taking the
     *  case_sensitive setting into account. -FM
d8162 2
a8163 2
	     *  Check the actual, hidden password, and then
	     *  the displayed string. -FM
d8169 2
a8170 2
	    for (cp = stars; *cp != '\0'; cp++)
		*cp = '*';
d8178 2
a8179 2
	     *  Search the option strings that are displayed
	     *  when the popup is invoked. -FM
d8190 1
a8190 1
	     *  Search for checked or unchecked parens. -FM
d8202 1
a8202 1
	     *  Search for checked or unchecked square brackets. -FM
d8226 1
a8226 2
PRIVATE TextAnchor *line_num_to_anchor ARGS1(
    int,	line_num)
d8241 1
a8241 3
PRIVATE int line_num_in_text ARGS2(
    HText *,		text,
    HTLine *,		line)
d8256 1
a8256 2
PRIVATE TextAnchor *get_prev_anchor ARGS1(
    TextAnchor *,	a)
d8271 5
a8275 6
PRIVATE int www_search_forward ARGS5(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	HTLine *,	line,
	int,		count)
d8313 5
a8317 6
PRIVATE int www_search_backward ARGS5(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	HTLine *,	line,
	int,		count)
d8355 4
a8358 5
PUBLIC void www_user_search ARGS4(
	int,		start_line,
	DocInfo *,	doc,
	char *,		target,
	int,		direction)
d8360 1
a8360 1
    HTLine * line;
d8368 1
a8368 1
     *  Advance to the start line.
d8372 3
a8374 1
	for (count = 1; count < start_line + direction; line = line->next, count++) {
d8392 2
a8393 3
PUBLIC void user_message ARGS2(
	CONST char *,	message,
	CONST char *,	argument)
d8411 2
a8412 2
 *  HText_getOwner returns the owner of the
 *  current document.
d8414 1
a8414 1
PUBLIC CONST char * HText_getOwner NOARGS
d8416 2
a8417 2
    return(HTMainText ?
	   HTAnchor_owner(HTMainText->node_anchor) : 0);
d8421 2
a8422 2
 *  HText_setMainTextOwner sets the owner for the
 *  current document.
d8424 1
a8424 2
PUBLIC void HText_setMainTextOwner ARGS1(
	CONST char *,	owner)
d8433 3
a8435 3
 *  HText_getRevTitle returns the RevTitle element of the
 *  current document, used as the subject for mailto comments
 *  to the owner.
d8437 1
a8437 1
PUBLIC CONST char * HText_getRevTitle NOARGS
d8439 2
a8440 2
    return(HTMainText ?
	   HTAnchor_RevTitle(HTMainText->node_anchor) : 0);
d8444 2
a8445 2
 *  HText_getContentBase returns the Content-Base header
 *  of the current document.
d8447 1
a8447 1
PUBLIC CONST char * HText_getContentBase NOARGS
d8449 2
a8450 2
    return(HTMainText ?
	   HTAnchor_content_base(HTMainText->node_anchor) : 0);
d8454 2
a8455 2
 *  HText_getContentLocation returns the Content-Location header
 *  of the current document.
d8457 1
a8457 1
PUBLIC CONST char * HText_getContentLocation NOARGS
d8459 2
a8460 2
    return(HTMainText ?
	   HTAnchor_content_location(HTMainText->node_anchor) : 0);
d8464 2
a8465 2
 *  HText_getMessageID returns the Message-ID of the
 *  current document.
d8467 1
a8467 1
PUBLIC CONST char * HText_getMessageID NOARGS
d8469 2
a8470 2
    return(HTMainText ?
	   HTAnchor_messageID(HTMainText->node_anchor) : NULL);
d8473 1
a8473 1
PUBLIC void HTuncache_current_document NOARGS
d8476 1
a8476 1
     *  Should remove current document from memory.
d8479 1
a8479 1
	HTParentAnchor * htmain_anchor = HTMainText->node_anchor;
d8487 7
a8493 7
			    ((htmain_anchor &&
			      htmain_anchor->address) ?
			       htmain_anchor->address : "unknown anchor"),
			    ((htmain_anchor &&
			      htmain_anchor->post_data)
			      ? " with POST data"
			      : "")));
d8504 26
a8529 1
PRIVATE HTProtocol scm = { "source-cache-mem", 0, 0 }; /* dummy - kw */
d8531 1
a8531 1
PUBLIC BOOLEAN HTreparse_document NOARGS
d8535 2
a8536 5
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
	(LYCacheSource == SOURCE_CACHE_FILE &&
	!HTMainAnchor->source_cache_file) ||
	(LYCacheSource == SOURCE_CACHE_MEMORY &&
	!HTMainAnchor->source_cache_chunk))
d8538 1
d8540 2
a8541 2
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
	FILE * fp;
d8546 1
a8546 1
	      HTMainAnchor->source_cache_file));
d8565 1
a8565 1
					     UCLYhndl_for_unspec);
d8595 2
a8596 1
	    CTRACE((tfp, "SourceCache: `%s' has been accessed, partial content.\n",
a8599 1
    }
d8601 3
a8603 2
    if (LYCacheSource == SOURCE_CACHE_MEMORY &&
	HTMainAnchor->source_cache_chunk) {
d8608 1
a8608 1
		    (void *)HTMainAnchor->source_cache_chunk));
d8621 8
a8628 8
	/*
	 * This is only done to make things aligned with SOURCE_CACHE_NONE and
	 * SOURCE_CACHE_FILE when switching to source mode since the original
	 * document's charset will be LYPushAssumed() and then LYPopAssumed().
	 * See LYK_SOURCE in mainloop if you change something here.  No
	 * user-visible benefits, seems just '=' Info Page will show source's
	 * effective charset as "(assumed)".
	 */
d8630 1
a8630 1
					     UCLYhndl_for_unspec);
d8644 2
a8645 2
	HTAnchor_setProtocol(HTMainAnchor, &scm); /* cheating -
				   anything != &HTTP or &HTTPS would do - kw */
d8647 1
a8647 1
			HTMainAnchor->source_cache_chunk, NULL);
d8649 2
a8652 2
    CTRACE((tfp, "Reparse %s\n", (ok ? "succeeded" : "failed")));

d8656 1
a8656 1
PUBLIC BOOLEAN HTcan_reparse_document NOARGS
d8658 1
a8658 6
    if (!HTMainAnchor || LYCacheSource == SOURCE_CACHE_NONE ||
	(LYCacheSource == SOURCE_CACHE_FILE &&
	!HTMainAnchor->source_cache_file) ||
	(LYCacheSource == SOURCE_CACHE_MEMORY &&
	!HTMainAnchor->source_cache_chunk))
	return FALSE;
d8660 6
a8665 2
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainAnchor->source_cache_file) {
	return LYCanReadFile(HTMainAnchor->source_cache_file);
d8668 2
a8669 6
    if (LYCacheSource == SOURCE_CACHE_MEMORY &&
	HTMainAnchor->source_cache_chunk) {
	return TRUE;
    }

    return FALSE;  /* if came to here */
d8672 3
a8674 4
PRIVATE void trace_setting_change ARGS3(
	CONST char *,	name,
	int,		prev_setting,
	int,		new_setting)
d8677 3
a8679 2
	CTRACE((tfp, "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
	       name, prev_setting, new_setting));
d8682 1
a8682 1
PUBLIC BOOLEAN HTdocument_settings_changed NOARGS
d8688 1
a8688 5
    if (!HTMainAnchor || !HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
	(LYCacheSource == SOURCE_CACHE_FILE &&
	!HTMainAnchor->source_cache_file) ||
	(LYCacheSource == SOURCE_CACHE_MEMORY &&
	!HTMainAnchor->source_cache_chunk))
d8701 2
a8702 2
			    HTMainText->verbose_img,
			    verbose_img);
d8717 5
a8721 2
		   "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
		   HTMainText->disp_cols, HTMainText->disp_lines, DISPLAY_COLS, LYlines));
d8738 1
a8738 1
PUBLIC int HTisDocumentSource NOARGS
d8743 1
a8743 1
PUBLIC char * HTLoadedDocumentURL NOARGS
d8749 1
a8749 1
	return(HTMainText->node_anchor->address);
d8754 1
a8754 1
PUBLIC bstring * HTLoadedDocumentPost_data NOARGS
d8757 3
a8759 3
     && HTMainText->node_anchor
     && HTMainText->node_anchor->post_data)
	return(HTMainText->node_anchor->post_data);
d8764 1
a8764 1
PUBLIC char * HTLoadedDocumentTitle NOARGS
d8770 1
a8770 1
	return(HTMainText->node_anchor->title);
d8775 1
a8775 1
PUBLIC BOOLEAN HTLoadedDocumentIsHEAD NOARGS
d8781 1
a8781 1
	return(HTMainText->node_anchor->isHEAD);
d8786 1
a8786 1
PUBLIC BOOLEAN HTLoadedDocumentIsSafe NOARGS
d8792 1
a8792 1
	return(HTMainText->node_anchor->safe);
d8797 1
a8797 1
PUBLIC char * HTLoadedDocumentCharset NOARGS
d8803 1
a8803 1
	return(HTMainText->node_anchor->charset);
d8808 1
a8808 1
PUBLIC BOOL HTLoadedDocumentEightbit NOARGS
d8816 1
a8816 2
PUBLIC void HText_setNodeAnchorBookmark ARGS1(
	CONST char *,	bookmark)
d8825 1
a8825 1
PUBLIC char * HTLoadedDocumentBookmark NOARGS
d8831 1
a8831 1
	return(HTMainText->node_anchor->bookmark);
d8836 1
a8836 3
PUBLIC int HText_LastLineSize ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8843 1
a8843 3
PUBLIC BOOL HText_LastLineEmpty ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8850 1
a8850 2
PUBLIC int HText_LastLineOffset ARGS1(
	HText *,	text)
d8854 1
a8854 1
    return  text->last_line->offset;
d8857 1
a8857 3
PUBLIC int HText_PreviousLineSize ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8859 1
a8859 1
    HTLine * line;
d8868 1
a8868 3
PUBLIC BOOL HText_PreviousLineEmpty ARGS2(
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8870 1
a8870 1
    HTLine * line;
d8882 1
a8882 4
PRIVATE int HText_TrueLineSize ARGS3(
	HTLine *,	line,
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8916 1
a8916 4
PRIVATE BOOL HText_TrueEmptyLine ARGS3(
	HTLine *,	line,
	HText *,	text,
	BOOL,		IgnoreSpaces)
d8944 1
a8944 2
PUBLIC void HText_NegateLineOne ARGS1(
	HText *,	text)
d8952 1
a8952 2
PUBLIC BOOL HText_inLineOne ARGS1(
	HText *,	text)
d8961 8
a8968 8
 *  This function is for removing the first of two
 *  successive blank lines.  It should be called after
 *  checking the situation with HText_LastLineSize()
 *  and HText_PreviousLineSize().  Any characters in
 *  the removed line (i.e., control characters, or it
 *  wouldn't have tested blank) should have been
 *  reiterated by split_line() in the retained blank
 *  line. -FM
d8970 1
a8970 2
PUBLIC void HText_RemovePreviousLine ARGS1(
	HText *,	text)
d8986 1
a8986 1
 *  NOTE: This function presently is correct only if the
d8992 1
a8992 2
PUBLIC int HText_getCurrentColumn ARGS1(
	HText *,	text)
d8999 3
a9001 3
		  (int)text->style->indent1st : (int)text->style->leftIndent)
		  + HText_LastLineSize(text, IgnoreSpaces)
		  + (int)text->last_line->offset;
d9006 1
a9006 2
PUBLIC int HText_getMaximumColumn ARGS1(
	HText *,	text)
d9008 2
a9009 1
    int column = (DISPLAY_COLS-2);
d9011 1
a9011 2
	column = ((int)text->style->rightIndent ? (DISPLAY_COLS-2) :
		  ((DISPLAY_COLS-1) - (int)text->style->rightIndent));
d9017 1
a9017 1
 *  NOTE: This function uses HText_getCurrentColumn() which
d9021 5
a9025 7
PUBLIC void HText_setTabID ARGS2(
	HText *,	text,
	CONST char *,	name)
{
    HTTabID * Tab = NULL;
    HTList * cur = text->tabs;
    HTList * last = NULL;
d9033 1
a9033 1
	while (NULL != (Tab = (HTTabID *)HTList_nextObject(cur))) {
d9035 1
a9035 1
		return; /* Already set.  Keep the first value. */
d9041 1
a9041 1
    if (!Tab) { /* New name.  Create a new node */
d9052 1
a9052 3
PUBLIC int HText_getTabIDColumn ARGS2(
	HText *,	text,
	CONST char *,	name)
d9055 2
a9056 2
    HTTabID * Tab;
    HTList * cur = text->tabs;
d9059 1
a9059 1
	while (NULL != (Tab = (HTTabID *)HTList_nextObject(cur))) {
d9070 11
a9080 13
 *  This function is for saving the address of a link
 *  which had an attribute in the markup that resolved
 *  to a URL (i.e., not just a NAME or ID attribute),
 *  but was found in HText_endAnchor() to have no visible
 *  content for use as a link name.  It loads the address
 *  into text->hidden_links, whose count can be determined
 *  via HText_HiddenLinks(), below.  The addresses can be
 *  retrieved via HText_HiddenLinkAt(), below, based on
 *  count. -FM
 */
PRIVATE void HText_AddHiddenLink ARGS2(
	HText *,	text,
	TextAnchor *,	textanchor)
d9085 1
a9085 1
     *  Make sure we have an HText structure and anchor. -FM
d9091 2
a9092 2
     *  Create the hidden links list
     *  if it hasn't been already. -FM
d9098 3
a9100 3
     *  Store the address, in reverse list order
     *  so that first in will be first out on
     *  retrievals. -FM
d9104 1
a9104 1
	 HTList_isEmpty(text->hidden_links)))
d9106 1
d9112 2
a9113 2
 *  This function returns the number of addresses
 *  that are loaded in text->hidden_links. -FM
d9115 1
a9115 2
PUBLIC int HText_HiddenLinkCount ARGS1(
	HText *,	text)
d9120 1
a9120 1
	count = HTList_count((HTList *)text->hidden_links);
d9122 1
a9122 1
    return(count);
d9126 3
a9128 3
 *  This function returns the address, corresponding to
 *  a hidden link, at the position (zero-based) in the
 *  text->hidden_links list of the number argument. -FM
d9130 1
a9130 3
PUBLIC char * HText_HiddenLinkAt ARGS2(
	HText *,	text,
	int,		number)
d9135 1
a9135 1
	href = (char *)HTList_objectAt((HTList *)text->hidden_links, number);
d9137 1
a9137 1
    return(href);
a9139 1

d9141 3
a9143 3
 *  Form methods
 *    These routines are used to build forms consisting
 *    of input fields
d9145 7
a9151 7
PRIVATE int HTFormMethod;
PRIVATE char * HTFormAction = NULL;
PRIVATE char * HTFormEnctype = NULL;
PRIVATE char * HTFormTitle = NULL;
PRIVATE char * HTFormAcceptCharset = NULL;
PRIVATE BOOLEAN HTFormDisabled = FALSE;
PRIVATE PerFormInfo * HTCurrentForm;
d9153 5
a9157 6
PUBLIC void HText_beginForm ARGS5(
	char *,		action,
	char *,		method,
	char *,		enctype,
	char *,		title,
	CONST char *,	accept_cs)
d9159 2
a9160 1
    PerFormInfo * newform;
d9167 1
a9167 1
     *  Check the ACTION. -FM
d9174 1
a9174 2
    }
    else
d9178 1
a9178 1
     *  Check the METHOD. -FM
d9181 1
a9181 1
	if (!strcasecomp(method,"post") || !strcasecomp(method,"pget"))
d9185 1
a9185 1
     *  Check the ENCTYPE. -FM
d9197 1
a9197 1
     *  Check the TITLE. -FM
d9205 2
a9206 2
     *  Check for an ACCEPT_CHARSET.  If present, store it and
     *  convert to lowercase and collapse spaces. - kw
d9215 7
a9221 7
     *  Create a new "PerFormInfo" structure to hold info on the current
     *  form.  The HTForm* variables could all migrate there, currently
     *  this isn't done (yet?) but it might be less confusing.
     *  Currently the only data saved in this structure that will actually
     *  be used is the accept_cs string.
     *  This will be appended to the forms list kept by the HText object
     *  if and when we reach a HText_endForm. - kw
d9225 1
a9225 1
	outofmem(__FILE__,"HText_beginForm");
d9228 1
a9228 1
    PerFormInfo_free(HTCurrentForm); /* shouldn't happen here - kw */
d9232 7
a9238 7
		HTFormAction, HTFormMethod,
		(HTFormTitle ? " Title:" : ""),
		NonNull(HTFormTitle),
		(HTFormEnctype ? " Enctype:" : ""),
		NonNull(HTFormEnctype),
		(HTFormAcceptCharset ? " Accept-charset:" : ""),
		NonNull(HTFormAcceptCharset)));
d9241 1
a9241 2
PUBLIC void HText_endForm ARGS1(
	HText *,	text)
d9245 2
a9246 2
	 *  Support submission of a single text input field in
	 *  the form via <return> instead of a submit button. -FM
d9248 2
a9249 1
	TextAnchor * a;
d9251 1
a9251 1
	 *  Go through list of anchors and get our input field. -FM
d9258 1
a9258 1
		 *  Got it.  Make it submitting. -FM
d9276 6
a9281 6
     *  Append info on the current form to the HText object's list of
     *  forms.
     *  HText_beginInput call will have set some of the data in the
     *  PerFormInfo structure (if there were any form fields at all),
     *  we also fill in the ACCEPT-CHARSET data now (this could have
     *  been done earlier). - kw
d9307 4
a9310 5
PUBLIC void HText_beginSelect ARGS4(
	char *,		name,
	int,		name_cs,
	BOOLEAN,	multiple,
	char *,		size)
d9313 1
a9313 1
     *  Save the group name.
d9319 1
a9319 1
     *  If multiple then all options are actually checkboxes.
d9324 1
a9324 1
     *  If not multiple then all options are radio buttons.
d9330 1
a9330 1
     *  Length of an option list.
d9334 10
a9343 10
    CTRACE((tfp,"HText_beginSelect: name=%s type=%d size=%s\n",
	       ((HTCurSelectGroup == NULL) ?
				  "<NULL>" : HTCurSelectGroup),
		HTCurSelectGroupType,
	       ((HTCurSelectGroupSize == NULL) ?
				      "<NULL>" : HTCurSelectGroupSize)));
    CTRACE((tfp,"HText_beginSelect: name_cs=%d \"%s\"\n",
		HTCurSelectGroupCharset,
		(HTCurSelectGroupCharset >= 0 ?
		 LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>")));
d9347 5
a9351 6
**  This function returns the number of the option whose
**  value currently is being accumulated for a select
**  block. - LE && FM
*/
PUBLIC int HText_getOptionNum ARGS1(
	HText *,	text)
d9355 1
a9355 1
    int n = 1; /* start count at 1 */
d9358 1
a9358 1
	return(0);
d9363 1
a9363 1
	return(0);
d9368 1
a9368 1
    return(n);
d9372 7
a9378 8
**  This function checks for a numbered option pattern
**  as the prefix for an option value.  If present, and
**  we are in the correct keypad mode, it returns a
**  pointer to the actual value, following that prefix.
**  Otherwise, it returns the original pointer.
*/
PRIVATE char * HText_skipOptionNumPrefix ARGS1(
	char *,		opname)
d9381 1
a9381 1
     *  Check if we are in the correct keypad mode.
d9385 6
a9390 6
	 *  Skip the option number embedded in the option name so the
	 *  extra chars won't mess up cgi scripts processing the value.
	 *  The format is (nnn)__ where nnn is a number and there is a
	 *  minimum of 5 chars (no underscores if (nnn) exceeds 5 chars).
	 *  See HTML.c.  If the chars don't exactly match this format,
	 *  just use all of opname.  - LE
d9407 1
a9407 1
		if (i < 5 ) {
d9416 1
a9416 1
	return(cp);
d9419 1
a9419 1
    return(opname);
d9423 10
a9432 12
**  We couldn't set the value field for the previous option
**  tag so we have to do it now.  Assume that the last anchor
**  was the previous options tag.
*/
PUBLIC char * HText_setLastOptionValue ARGS7(
	HText *,	text,
	char *,		value,
	char*,		submit_value,
	int,		order,
	BOOLEAN,	checked,
	int,		val_cs,
	int,		submit_val_cs)
d9440 4
a9443 3
      && text
      && text->last_anchor
      && text->last_anchor->link_type == INPUT_ANCHOR)) {
d9445 1
a9445 1
		    (value ? value : "<NULL>")));
d9449 3
a9451 2
    CTRACE((tfp, "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",
		value, (checked ? "on" : "off")));
d9454 1
a9454 1
     *  Strip end spaces, newline is also whitespace.
d9457 1
a9457 1
	cp = &value[strlen(value)-1];
d9461 1
a9461 1
	*(cp+1) = '\0';
d9465 1
a9465 1
     *  Find first non space
d9475 2
a9476 2
	 *  Collapse any space between the popup option
	 *  prefix and actual value. -FM
d9496 1
a9496 1
	 *  Put the text on the screen as well.
d9506 1
a9506 1
	 *  Put the text on the screen as well.
d9512 1
a9512 1
	 *  Create a linked list of option values.
d9514 2
a9515 2
	OptionType * op_ptr = text->last_anchor->input_field->select_list;
	OptionType * new_ptr = NULL;
d9519 1
a9519 1
	 *  Deal with newlines or tabs.
d9521 1
a9521 1
	convert_to_spaces(value, FALSE);
d9525 1
a9525 1
	     *  No option items yet.
d9528 3
a9530 2
		CTRACE((tfp, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			    F_OPTION_LIST_TYPE));
d9532 1
a9532 1
			    text->last_anchor->input_field->type));
d9537 1
a9537 1
				typecalloc(OptionType);
d9547 1
a9547 1
	    number++;  /* add one more */
d9558 2
a9559 2
	 *  Find first non-space again, convert_to_spaces above may have
	 *  changed the string. - kw
d9577 1
a9577 1
		(tmp = typecallocn(unsigned char, strlen(cp)+1)) != 0) {
d9581 1
a9581 1
		    TO_EUC((unsigned char *)cp, tmp);
d9584 1
a9584 1
		    TO_SJIS((unsigned char *)cp, tmp);
d9593 1
a9593 1
		StrAllocCopy(new_ptr->name, (CONST char *)tmp);
d9610 4
a9613 4
	     *  If this is the first option in a popup select list,
	     *  HText_beginInput may have allocated the value and
	     *  cp_submit_value fields, so free them now to avoid
	     *  a memory leak. - kw
d9618 3
a9620 3
	    last_input->value             = last_input->select_list->name;
	    last_input->orig_value        = last_input->select_list->name;
	    last_input->cp_submit_value   = last_input->select_list->cp_submit_value;
d9622 1
a9622 1
	    last_input->value_cs          = new_ptr->value_cs;
d9625 8
a9632 5
	    int curlen = HTCurSelectedOptionValue ? strlen(HTCurSelectedOptionValue) : 0;
		/*
		 *  Make the selected Option Value as long as
		 *  the longest option.
		 */
d9635 1
a9635 1
			    UNDERSCORES(newlen-curlen));
d9640 3
a9642 1
	    int newlen = HTCurSelectedOptionValue ? strlen(HTCurSelectedOptionValue) : 0;
d9644 1
d9646 1
a9646 1
	     *  Set the default option as this one.
d9648 4
a9651 4
	    last_input->num_value	  = number;
	    last_input->value		  = new_ptr->name;
	    last_input->orig_value	  = new_ptr->name;
	    last_input->cp_submit_value	  = new_ptr->cp_submit_value;
d9653 1
a9653 1
	    last_input->value_cs	  = new_ptr->value_cs;
d9657 1
a9657 1
			    UNDERSCORES(newlen-curlen));
d9661 1
a9661 1
	 *  Return the selected Option value to be sent to the screen.
d9665 1
a9665 1
	     *  Change the value.
d9667 1
a9667 1
	    if (HTCurSelectedOptionValue == NULL)
d9670 1
a9670 1
				strlen(HTCurSelectedOptionValue);
d9679 4
a9682 4
	CTRACE((tfp,"            val_cs=%d \"%s\"",
			val_cs,
			(val_cs >= 0 ?
			 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>")));
d9689 1
a9689 1
						  "(ignored)" : "",
d9691 2
a9692 3
	}
	else {
	    CTRACE((tfp,"\n"));
d9695 1
a9695 1
    return(ret_Value);
d9699 3
a9701 3
 *  Assign a form input anchor.
 *  Returns the number of characters to leave
 *  blank so that the input field can fit.
d9703 2
a9704 4
PUBLIC int HText_beginInput ARGS3(
	HText *,		text,
	BOOL,			underline,
	InputFieldData *,	I)
d9706 3
a9708 3
    TextAnchor * a;
    FormInfo * f;
    CONST char *cp_option = NULL;
d9719 1
d9724 1
d9730 5
a9734 5
     *  If this is a radio button, or an OPTION we're converting
     *  to a radio button, and it's the first with this name, make
     *  sure it's checked by default.  Otherwise, if it's checked,
     *  uncheck the default or any preceding radio button with this
     *  name that was checked. -FM
d9736 1
a9736 1
    if (I->type != NULL && !strcmp(I->type,"OPTION") &&
d9746 1
a9746 1
	    TextAnchor * b;
d9748 1
d9764 1
a9764 1
	       I->checked = TRUE;
d9780 1
a9780 1
    f->disabled = (HTFormDisabled ? TRUE : I->disabled);
d9786 1
a9786 1
     *  Set the no_cache flag if the METHOD is POST. -FM
d9792 1
a9792 1
     *  Set up VALUE.
d9796 4
a9799 2
    if (IValue && HTCJK != NOCJK) {
	if ((tmp = typecallocn(unsigned char, strlen(IValue) + 1)) != 0) {
d9801 1
a9801 1
		TO_EUC((unsigned char *)IValue, tmp);
d9804 1
a9804 1
		TO_SJIS((unsigned char *)IValue, tmp);
d9808 1
a9808 1
		    if (IValue[i] != CH_ESC) {  /* S/390 -- gil -- 1621 */
d9813 1
a9813 1
	    StrAllocCopy(IValue, (CONST char *)tmp);
d9819 2
a9820 2
     *  Special case of OPTION.
     *  Is handled above if radio type and LYSelectPopups is FALSE.
d9823 1
a9823 1
    if (I->type != NULL && !strcmp(I->type,"OPTION")) {
d9833 4
a9836 4
	 *  The option's size parameter actually gives the length and not
	 *    the width of the list.  Perform the conversion here
	 *    and get rid of the allocated HTCurSelect....
	 *  0 is ok as it means any length (arbitrary decision).
d9845 1
a9845 1
     *  Set SIZE.
d9850 1
a9850 1
	 *  Leave at zero for option lists.
d9853 1
a9853 1
	    f->size = 20;  /* default */
d9856 1
a9856 1
	f->size = 20;  /* default */
d9860 1
a9860 1
     *  Set MAXLENGTH.
d9865 1
a9865 1
	f->maxlength = 0;  /* 0 means infinite */
d9869 2
a9870 2
     *  Set CHECKED
     *  (num_value is only relevant to check and radio types).
d9878 1
a9878 1
     *  Set TYPE.
d9881 1
a9881 1
	if (!strcasecomp(I->type,"password")) {
d9883 1
a9883 1
	} else if (!strcasecomp(I->type,"checkbox")) {
d9885 1
a9885 1
	} else if (!strcasecomp(I->type,"radio")) {
d9887 1
a9887 1
	} else if (!strcasecomp(I->type,"submit")) {
d9889 1
a9889 1
	} else if (!strcasecomp(I->type,"image")) {
d9891 1
a9891 1
	} else if (!strcasecomp(I->type,"reset")) {
d9893 1
a9893 1
	} else if (!strcasecomp(I->type,"OPTION_LIST")) {
d9895 1
a9895 1
	} else if (!strcasecomp(I->type,"hidden")) {
d9899 1
a9899 1
	} else if (!strcasecomp(I->type,"textarea")) {
d9901 1
a9901 1
	} else if (!strcasecomp(I->type,"range")) {
d9903 1
a9903 1
	} else if (!strcasecomp(I->type,"file")) {
d9906 1
a9906 1
	} else if (!strcasecomp(I->type,"keygen")) {
d9910 1
a9910 1
	     *  Note that TYPE="scribble" defaults to TYPE="text". -FM
d9912 1
a9912 1
	    f->type = F_TEXT_TYPE; /* default */
d9919 1
a9919 1
     *  Set NAME.
d9922 1
a9922 1
	StrAllocCopy(f->name,I->name);
d9929 1
a9929 1
	     *  Set name to empty string.
d9934 1
a9934 1
	     *  Error!  NAME must be present.
d9937 1
a9937 1
		  "GridText: No name present in input field; not displaying\n"));
d9939 1
a9939 1
	    return(0);
d9944 1
a9944 1
     *  Add this anchor to the anchor list
d9953 2
a9954 2
     *  Set VALUE, if it exists.  Otherwise, if it's not
     *  an option list make it a zero-length string. -FM
d9958 2
a9959 2
	 *  OPTION VALUE is not actually the value to be seen but is to
	 *    be sent....
d9964 2
a9965 2
	     *  Fill both with the value.  The f->value may be
	     *  overwritten in HText_setLastOptionValue....
d9976 2
a9977 2
	 *  May be an empty INPUT field.  The text entered will then
	 *  probably be in the current display character set. - kw
d9983 1
a9983 1
     *  Run checks and fill in necessary values.
d10012 1
a10012 1
	f->size=3;
d10020 1
a10020 1
     *  Set original values.
d10022 1
a10022 1
    if (f->type == F_RADIO_TYPE || f->type == F_CHECKBOX_TYPE ) {
d10034 2
a10035 2
     *  Store accept-charset if present, converting to lowercase
     *  and collapsing spaces. - kw
d10044 1
a10044 1
     *  Add numbers to form fields if needed. - LE & FM
d10048 2
a10049 2
	 *  Do not supply number for hidden fields, nor
	 *  for types that are not yet implemented.
d10051 1
a10051 1
	case F_HIDDEN_TYPE:
d10053 1
a10053 1
	case F_FILE_TYPE:
d10055 9
a10063 2
	case F_RANGE_TYPE:
	case F_KEYGEN_TYPE:
d10065 1
a10065 8
	    break;

	default:
	    if (fields_are_numbered())
		a->number = ++(text->last_anchor_number);
	    else
		a->number = 0;
	    break;
d10068 2
a10069 1
	sprintf(marker,"[%d]", a->number);
a10075 2
	} else {
	    adjust_marker = strlen(marker);
d10084 1
a10084 1
     *  Restrict SIZE to maximum allowable size.
d10086 1
a10086 1
    MaximumSize = WRAP_COLS(text) - adjust_marker;
d10089 27
a10115 27
	case F_SUBMIT_TYPE:
	case F_IMAGE_SUBMIT_TYPE:
	case F_RESET_TYPE:
	case F_TEXT_TYPE:
	case F_TEXTAREA_TYPE:
	    /*
	     *  For submit and reset buttons, and for text entry
	     *  fields and areas, we limit the size element to that
	     *  of one line for the current style because that's
	     *  the most we could highlight on overwrites, and/or
	     *  handle in the line editor.  The actual values for
	     *  text entry lines can be long, and will be scrolled
	     *  horizontally within the editing window. -FM
	     */
	    MaximumSize -= (1 +
			  (int)text->style->leftIndent +
			  (int)text->style->rightIndent);

	    /*  If we are numbering form links, place is taken by [nn]  */
	    if (fields_are_numbered()) {
		if (!number_fields_on_left
		 && f->type == F_TEXT_TYPE
		 && MaximumSize > a->line_pos + 10)
		    MaximumSize -= a->line_pos;
		else
		    MaximumSize -= strlen(marker);
	    }
d10117 6
a10122 6
	    /*
	     *  Save value for submit/reset buttons so they
	     *  will be visible when printing the page. - LE
	     */
	    I->value = f->value;
	    break;
d10124 9
a10132 9
	default:
	    /*
	     *  For all other fields we limit the size element to
	     *  10 less than the screen width, because either they
	     *  are types with small placeholders, and/or are a
	     *  type which is handled via a popup window. -FM
	     */
	    MaximumSize -= 10;
	    break;
d10134 4
d10142 1
a10142 1
     *  Add this anchor to the anchor list
d10151 1
a10151 1
	HTCurrentForm->nfields++; /* will count hidden fields - kw */
d10153 2
a10154 2
	 *  Propagate form field's accept-charset attribute to enclosing
	 *  form if the form itself didn't have an accept-charset - kw
d10167 3
a10169 3
			f->name,
			NonNull(f->value),
			f->size));
d10171 6
a10176 6
			f->name_cs,
			(f->name_cs >= 0 ?
			 LYCharSet_UC[f->name_cs].MIMEname : "<UNKNOWN>"),
			I->name_cs,
			(I->name_cs >= 0 ?
			 LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>")));
d10178 6
a10183 6
			f->value_cs,
			(f->value_cs >= 0 ?
			 LYCharSet_UC[f->value_cs].MIMEname : "<UNKNOWN>"),
			I->value_cs,
			(I->value_cs >= 0 ?
			 LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>")));
d10186 1
a10186 1
     *  Return the SIZE of the input field.
d10188 4
a10191 1
    return(f->size);
d10199 1
a10199 2
PUBLIC void HText_endInput ARGS1(
	HText *,		text)
d10202 4
a10205 4
     && !number_fields_on_left
     && text != NULL
     && text->last_anchor != NULL
     && text->last_anchor->number > 0) {
d10207 1
d10209 1
a10209 1
	sprintf(marker,"[%d]", text->last_anchor->number);
d10215 6
a10220 6
 *  Get a translation (properly: transcoding) quality, factoring in
 *  our ability to translate (an UCTQ_t) and a possible q parameter
 *  on the given charset string, for cs_from -> givenmime.
 *  The parsed input string will be mutilated on exit(!).
 *  Note that results are not normalised to 1.0, but results from
 *  different calls of this function can be compared. - kw
d10222 2
a10223 2
 *  Obsolete, it was planned to use here a quality parametr UCTQ_t,
 *  which is boolean now.
d10225 2
a10226 3
PRIVATE double get_trans_q ARGS2(
    int,		cs_from,
    char *,		givenmime)
d10231 1
d10234 1
a10234 1
    if ((p = strchr(givenmime,';')) != NULL) {
d10247 1
d10252 1
a10252 1
		if (0==strcasecomp(ptok,"q")) {
d10265 4
a10268 4
 *  Find the best charset for submission, if we have an ACCEPT_CHARSET
 *  list.  It factors in how well we can translate (just as guess, and
 *  not a very good one..) and possible  ";q=" factors.  Yes this is
 *  more general than it needs to be here.
d10270 1
a10270 1
 *  Input is cs_in and acceptstring.
d10272 8
a10279 9
 *  Will return charset handle as int.
 *  best_csname will point to a newly allocated MIME string for the
 *  charset corresponding to the return value if return value >= 0.
 *  - kw
 */
PRIVATE int find_best_target_cs ARGS3(
    char **,		best_csname,
    int,		cs_from,
    CONST char *,	acceptstring)
d10285 1
d10290 1
d10292 1
a10292 1
	    /* Get the Charset*/
d10301 1
a10301 1
	if (!strcmp(bestmime, "*")) /* non-standard for HTML attribute.. */
d10316 2
a10317 3
PRIVATE void load_a_file ARGS2(
    char *,	val_used,
    bstring **,	result)
d10337 1
a10337 1
PRIVATE CONST char *guess_content_type ARGS1(CONST char *, filename)
d10340 3
a10342 2
    CONST char *desc;
    HTFormat format = HTFileFormat (filename, &encoding, &desc);
d10344 2
a10345 2
	    ? format->name
	    : "text/plain";
d10349 2
a10350 4

PRIVATE void cannot_transcode ARGS2(
    BOOL *,		had_warning,
    CONST char *,	target_csname)
d10355 1
a10355 1
	    target_csname ? target_csname : "UNKNOWN");
d10363 1
a10363 2
PRIVATE unsigned check_form_specialchars ARGS1(
    char *,	value)
d10366 1
a10366 1
    char *p;
d10369 1
a10369 1
	 non_empty(p) && (result != (SPECIAL_8BIT|SPECIAL_FORM));
d10386 2
a10387 3
PRIVATE void UpdateBoundary ARGS2(
	char **,	Boundary,
	bstring *,	data)
d10397 1
a10397 1
	 && !memcmp(want, text + j, have)) {
d10399 1
d10412 2
a10413 3
PRIVATE char * convert_to_base64 ARGS2(
	char *,		src,
	int,		len)
d10417 2
a10418 2
    static CONST char basis_64[] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
d10421 1
a10421 1
    int rlen;   /* length of result string */
d10423 3
a10425 1
    char *eol, *r, *str;
d10434 1
a10434 1
    rlen = (len+2) / 3 * 4;	/* encoded bytes */
d10437 1
a10437 1
	rlen += ((rlen-1) / B64_LINE + 1) * eollen;
d10447 5
a10451 4
    for (chunk=0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE/4)) {
	    char *c = eol;
	    char *e = eol + eollen;
d10458 2
a10459 2
	*r++ = basis_64[c1>>2];
	*r++ = basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];
d10462 1
a10462 1
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
d10467 1
a10467 1
	} else { /* len == 1 */
d10474 3
a10476 2
	char *c = eol;
	char *e = eol + eollen;
d10486 4
a10489 4
    NO_QUOTE		/* no quoting needed */
    , QUOTE_MULTI	/* multipart */
    , QUOTE_BASE64	/* encode as base64 */
    , QUOTE_SPECIAL	/* escape special characters only */
d10493 6
a10498 6
    int type;		/* the type of this field */
    BOOL first;		/* true if this begins a submission part */
    char *name;		/* the name of this field */
    char *value;	/* the nominal value of this field */
    bstring *data;	/* its data, which is usually the same as the value */
    QuoteData quote;	/* how to quote/translate the data */
d10501 3
a10503 4
PRIVATE char *escape_or_quote_name ARGS3(
	char *,		name,
	QuoteData,	quoting,
	char *,		MultipartContentType)
d10509 2
a10510 2
       StrAllocCopy(escaped1, name);
       break;
d10528 2
a10529 3
PRIVATE char *escape_or_quote_value ARGS2(
	char *,		value,
	QuoteData,	quoting)
d10554 2
a10555 3
PRIVATE int check_if_base64_needed ARGS2(
	int,		submit_method,
	bstring *,	data)
d10568 1
d10588 9
a10596 12
 *  HText_SubmitForm - generate submit data from form fields.
 *  For mailto forms, send the data.
 *  For other methods, set fields in structure pointed to by doc
 *  appropriately for next request.
 *  Returns 1 if *doc set appropriately for next request,
 *	    0 otherwise. - kw
 */
PUBLIC int HText_SubmitForm ARGS4(
	FormInfo *,	submit_item,
	DocInfo *,	doc,
	char *,		link_name,
	char *,		link_value)
d10604 2
a10605 2
    CONST char *out_csname;
    CONST char *target_csname = NULL;
d10618 1
a10618 1
    char *name_used = "";
d10620 1
a10620 1
    char *val_used = "";
d10633 2
a10634 1
    thisform = HTList_objectAt(HTMainText->forms, form_number - 1);
d10638 1
a10638 1
		    form_number));
d10641 1
a10641 1
		    thisform->number, form_number));
d10651 1
a10651 1
     *  If we're mailing, make sure it's a mailto ACTION. -FM
d10660 1
a10660 1
     *  Check the ENCTYPE and set up the appropriate variables. -FM
d10665 2
a10666 2
	 *  Do not hex escape, and use physical newlines
	 *  to separate name=value pairs. -FM
d10673 2
a10674 2
	 *  Use semicolons instead of ampersands as the
	 *  separators for name=value pairs. -FM
d10681 2
a10682 2
	 *  Use the multipart MIME format.  Later we will ensure it does not
	 *  occur within the content.
d10688 6
a10693 6
     *  Determine in what character encoding (aka. charset) we should
     *  submit.  We call this target_cs and the MIME name for it
     *  target_csname.
     *  TODO:   - actually use ACCEPT-CHARSET stuff from FORM
     *  TODO:   - deal with list in ACCEPT-CHARSET, find a "best"
     *		  charset to submit
d10724 1
a10724 1
	    target_cs = UCLYhndl_for_unspec; /* always >= 0 */
d10729 1
a10729 1
	target_cs = UCLYhndl_for_unspec;  /* always >= 0 */
d10743 1
a10743 1
		    !anchor_ptr->input_field->disabled) {
d10746 3
a10748 3
	    char * val = form_ptr->cp_submit_value != NULL
			    ? form_ptr->cp_submit_value
			    : form_ptr->value;
d10760 2
a10761 2
	     && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
	      || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
d10768 2
a10769 2
		target_cs = form_ptr->value_cs;	/* try this */
		target_csname = NULL; /* will be set after loop */
d10771 1
a10771 1
		target_cs = -1; /* don't know what to do */
d10780 2
a10781 2
	     && (LYCharSet_UC[target_cs].enc == UCT_ENC_8859
	      || (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
d10788 2
a10789 2
		target_cs = form_ptr->value_cs;	/* try this */
		target_csname = NULL; /* will be set after loop */
d10791 1
a10791 1
		target_cs = -1; /* don't know what to do */
d10825 1
a10825 1
	 *  Method is GET.  Clip out any anchor in the current URL.
d10827 1
a10827 1
	strtok (temp, "#");
d10829 1
a10829 1
	 *  Clip out any old query in the current URL.
d10831 1
a10831 1
	strtok (temp, "?");
d10833 1
a10833 1
	 *  Add the lead question mark for the new URL.
d10835 1
a10835 1
	StrAllocCat(temp,"?");
d10839 3
a10841 3
	 *  We are submitting POST content to a server,
	 *  so load content_type_out.  This will be put in
	 *  the post_content_type element if all goes well. -FM, kw
d10858 2
a10859 2
	 *  If the ENCTYPE is not multipart/form-data, append the
	 *  charset we'll be sending to the post_content_type, IF
d10863 1
a10863 1
	 *	AND it or target_csname is different from iso-8859-1,
d10867 6
a10872 6
	 *	AND target_cs is different from the currently effective
	 *	assumed charset (which should have been set by the user
	 *	so that it reflects what the server is sending, if the
	 *	document is rendered correctly).
	 *  For multipart/form-data the equivalent will be done later,
	 *  separately for each form field. - kw
d10875 2
a10876 2
	 || ((form_is_special & SPECIAL_8BIT) != 0
	  || (form_is_special & SPECIAL_FORM) != 0)) {
d10907 1
a10907 1
		    !anchor_ptr->input_field->disabled) {
d10921 1
a10921 1
		   anchor_count + 1, anchor_limit));
d10925 1
a10925 1
	    switch(form_ptr->type) {
d10933 1
a10933 1
			     val_used, name_used));
d10943 4
a10946 4
				 form_ptr->name ? form_ptr->name : "???",
				 link_name ? link_name : "???",
				 non_empty(form_ptr->name) ?
				 "not current link" : "no field name"));
d10950 2
a10951 2
		    (non_empty(form_ptr->value) &&
		     !strcmp(form_ptr->value, link_value)))) {
d10954 3
a10956 3
				 form_ptr->name ? form_ptr->name : "???",
				 link_name ? link_name : "???",
				 "values are different"));
d10987 8
a10994 8
				 NonNull(form_ptr->name),
				 form_ptr->value_cs,
				 form_ptr->value_cs >= 0
				     ? LYCharSet_UC[form_ptr->value_cs].MIMEname
				     : "???",
				 target_cs,
				 target_csname ? target_csname : "???",
				 success ? "OK" : "FAILED"));
d10998 1
a10998 1
		} else {  /* We can use the value directly. */
d11000 3
a11002 3
				 NonNull(form_ptr->name),
				 target_cs,
				 target_csname ? target_csname : "???"));
d11050 8
a11057 8
				 NonNull(form_ptr->name),
				 form_ptr->name_cs,
				 form_ptr->name_cs >= 0
				     ? LYCharSet_UC[form_ptr->name_cs].MIMEname
				     : "???",
				 target_cs,
				 target_csname ? target_csname : "???",
				 success ? "OK" : "FAILED"));
d11070 1
a11070 1
		} else {  /* We can use the name directly. */
d11072 3
a11074 3
				NonNull(form_ptr->name),
				target_cs,
				target_csname ? target_csname : "???"));
d11085 10
a11094 10
		     *  According to RFC 1867, Non-ASCII field names
		     *  "should be encoded according to the prescriptions
		     *  of RFC 1522 [...].  I don't think RFC 1522 actually
		     *  is meant to apply to parameters like this, and it
		     *  is unknown whether any server would make sense of
		     *  it, so for now just use some quoting/escaping and
		     *  otherwise leave 8-bit values as they are.
		     *  Non-ASCII characters in form field names submitted
		     *  as multipart/form-data can only occur if the form
		     *  provider specifically asked for it anyway. - kw
d11115 1
a11115 1
	    switch(form_ptr->type) {
d11131 4
a11134 4
		    !strcmp(form_ptr->name, link_name)) &&
		   (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
		    (non_empty(form_ptr->value) &&
		     !strcmp(form_ptr->value, link_value)))) {
d11144 1
a11144 1
		 *  Only add if selected.
d11181 2
a11182 2
		 && check_if_base64_needed(submit_item->submit_method,
					   my_data[anchor_count].data)) {
d11185 3
a11187 3
		    escaped2 = convert_to_base64(
				BStrData(my_data[anchor_count].data),
				BStrLen(my_data[anchor_count].data));
d11224 1
a11224 1
	     && my_data[anchor_count].value != 0) {
d11226 2
a11227 1
		CTRACE((tfp, "processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
d11277 6
a11282 6
			"%s%s%s%s%s",
			escaped1,
			(Boundary ? "" : "="),
			(PlainText ? "\n" : ""),
			escaped2,
			((PlainText && *escaped2) ? "\n" : ""));
d11294 6
a11299 6
			"%s%s%s%s%s",
			escaped1,
			(Boundary ? "" : "="),
			(PlainText ? "\n" : ""),
			escaped2,
			((PlainText && *escaped2) ? "\n" : ""));
d11305 7
a11311 7
		 *  If it has a non-zero length name (e.g., because
		 *  its IMAGE_SUBMIT_TYPE is to be handled homologously
		 *  to an image map, or a SUBMIT_TYPE in a set of
		 *  multiple submit buttons, or a single type="text"
		 *  that's been converted to a TEXT_SUBMIT_TYPE),
		 *  include the name=value pair, or fake name.x=0 and
		 *  name.y=0 pairs for IMAGE_SUBMIT_TYPE. -FM
d11337 8
a11344 8
				"%s.x=0%s%s.y=0%s",
				escaped1,
				(PlainText ?
				      "\n" : (SemiColon ?
						    ";" : "&")),
				escaped1,
				((PlainText && *escaped1) ?
						     "\n" : ""));
d11352 6
a11357 6
			    "%s%s%s%s%s",
			    escaped1,
			    (Boundary ? "" : "="),
			    (PlainText ? "\n" : ""),
			    escaped2,
			    ((PlainText && *escaped2) ? "\n" : ""));
d11385 6
a11390 6
			    "%s%s%s%s%s",
			    escaped1,
			    (Boundary ? "" : "="),
			    (PlainText ? "\n" : ""),
			    escaped2,
			    ((PlainText && *escaped2) ? "\n" : ""));
d11392 6
a11397 5
		    char *marker = (PlainText
				    ? "\n"
				    : (Boundary
				       ? "\r\n"
				       : "%0d%0a"));
d11424 1
a11424 1
		    CONST char *t = guess_content_type(val_used);
d11427 2
a11428 1
		    HTSprintf(&escaped1, "; name=\"%s\"", my_data[anchor_count].name);
d11433 2
a11434 1
			StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
d11482 1
a11482 1
	mailform((submit_item->submit_action+7),
d11484 2
a11485 2
		   ? NonNull(HText_getTitle())
		   : submit_item->submit_title),
d11497 1
a11497 1
	    doc->post_content_type = content_type_out; /* don't free c_t_out */
d11500 2
a11501 2
	} else { /* GET_METHOD */
	    HTSABCat(&my_query, "", 1);	/* append null */
d11524 1
a11524 1
PUBLIC void HText_DisableCurrentForm NOARGS
d11526 1
a11526 1
    TextAnchor * anchor_ptr;
d11533 1
a11533 1
     *  Go through list of anchors and set the disabled flag.
d11548 1
a11548 2
PUBLIC void HText_ResetForm ARGS1(
	FormInfo *,	form)
d11550 1
a11550 1
    TextAnchor * anchor_ptr;
d11557 1
a11557 1
     *  Go through list of anchors and reset values.
d11576 1
a11576 1
				anchor_ptr->input_field->orig_value;
d11579 1
a11579 1
				anchor_ptr->input_field->orig_submit_value;
d11597 1
a11597 2
PUBLIC BOOLEAN HText_HaveUserChangedForms ARGS1(
	HText *,	text)
d11599 1
a11599 1
    TextAnchor * anchor_ptr;
d11605 2
a11606 2
     *  Go through list of anchors to check if any value was changed.
     *  This code based on HText_ResetForm()
d11641 1
a11641 2
PUBLIC void HText_activateRadioButton ARGS1(
	FormInfo *,	form)
d11643 1
a11643 1
    TextAnchor * anchor_ptr;
d11652 1
a11652 1
		anchor_ptr->input_field->type == F_RADIO_TYPE) {
d11656 3
a11658 3
		    /* if it has the same name and its on */
		 if (!strcmp(anchor_ptr->input_field->name, form->name) &&
		     anchor_ptr->input_field->num_value) {
d11661 1
a11661 1
		 }
d11663 1
a11663 1
		    break;
d11667 1
a11667 1
   }
d11669 1
a11669 1
   form->num_value = 1;
d11683 1
a11683 1
PRIVATE void free_all_texts NOARGS
d11691 1
a11691 1
     *  Simply loop through the loaded texts list killing them off.
d11694 1
a11694 1
	if ((cur = (HText *)HTList_removeLastObject(loaded_texts)) != NULL) {
d11700 1
a11700 1
     *  Get rid of the text list.
d11707 1
a11707 1
     *  Insurance for bad HTML.
d11723 7
a11729 8
**  stub_HTAnchor_address is like HTAnchor_address, but it returns the
**  parent address for child links.  This is only useful for traversal's
**  where one does not want to index a text file N times, once for each
**  of N internal links.  Since the parent link has already been taken,
**  it won't go again, hence the (incorrect) links won't cause problems.
*/
PUBLIC char * stub_HTAnchor_address ARGS1(
	HTAnchor *,	me)
d11732 1
d11734 1
a11734 1
	StrAllocCopy (addr, me->parent->address);
d11738 1
a11738 2
PUBLIC void HText_setToolbar ARGS1(
	HText *,	text)
d11745 1
a11745 2
PUBLIC BOOL HText_hasToolbar ARGS1(
	HText *,	text)
d11750 1
a11750 2
PUBLIC void HText_setNoCache ARGS1(
	HText *,	text)
d11757 1
a11757 2
PUBLIC BOOL HText_hasNoCacheSet ARGS1(
	HText *,	text)
d11762 1
a11762 2
PUBLIC BOOL HText_hasUTF8OutputSet ARGS1(
	HText *,	text)
d11768 11
a11778 13
**  Check charset and set the kcode element. -FM
**  Info on the input charset may be passed in in two forms,
**  as a string (if given explicitly) and as a pointer to
**  a LYUCcharset (from chartrans mechanism); either can be NULL.
**  For Japanese the kcode will be reset at a space or explicit
**  line or paragraph break, so what we set here may not last for
**  long.  It's potentially more important not to set HTCJK to
**  NOCJK unless we are sure. - kw
*/
PUBLIC void HText_setKcode ARGS3(
	HText *,	text,
	CONST char *,	charset,
	LYUCcharset *,	p_in)
d11780 1
a11780 1
    BOOL explicit;
d11786 2
a11787 2
    **  Check whether we have some kind of info. - kw
    */
d11791 1
a11791 1
    explicit = charset ? TRUE : FALSE;
d11793 2
a11794 2
    **  If no explicit charset string, use the implied one. - kw
    */
d11799 2
a11800 2
    **  Check whether we have a specified charset. -FM
    */
d11806 5
a11810 5
    **  We've included the charset, and not forced a download offer,
    **  only if the currently selected character set can handle it,
    **  so check the charset value and set the text->kcode element
    **  appropriately. -FM
    */
d11812 8
a11819 9
     *  p_in->MIMEname would be set as display charset.
     *  So text->kcode sholud be set as SJIS or EUC here only if charset
     *  is specified explicitely, otherwise text->kcode would cause
     *  mishandling Japanese strings. -- TH
     */
    if (explicit && (!strcmp(charset, "shift_jis") ||
	!strcmp(charset, "x-sjis") ||		/* 1997/11/28 (Fri) 18:11:33 */
	!strcmp(charset, "x-shift-jis")))
    {
d11821 16
a11836 12
    } else if (explicit && ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
	       !strcmp(charset, "x-euc") ||	/* 1997/11/28 (Fri) 18:11:24 */
	       !strcmp(charset, "euc-jp") ||
	       !strncmp(charset, "x-euc-", 6) ||
	       !strcmp(charset, "euc-kr") ||
	       !strcmp(charset, "iso-2022-kr") ||
	       !strcmp(charset, "big5") ||
	       !strcmp(charset, "cn-big5") ||
	       !strcmp(charset, "euc-cn") ||
	       !strcmp(charset, "gb2312") ||
	       !strncmp(charset, "cn-gb", 5) ||
	       !strcmp(charset, "iso-2022-cn"))) {
d11840 3
a11842 3
	**  If we get to here, it's not CJK, so disable that if
	**  it is enabled.  But only if we are quite sure. -FM & kw
	*/
d11845 5
a11849 1
	    if (!p_in || p_in->enc != UCT_ENC_CJK)
d11851 1
d11854 6
a11859 1
    if (explicit)
d11861 1
a11861 1
    else {
d11874 3
a11876 4
**  Set a permissible split at the current end of the last line. -FM
*/
PUBLIC void HText_setBreakPoint ARGS1(
	HText *,	text)
d11882 1
a11882 1
     *  Can split here. -FM
d11890 14
a11903 15
**  This function determines whether a document which
**  would be sought via the a URL that has a fragment
**  directive appended is otherwise identical to the
**  currently loaded document, and if so, returns
**  FALSE, so that any no_cache directives can be
**  overridden "safely", on the grounds that we are
**  simply acting on the equivalent of a paging
**  command.  Otherwise, it returns TRUE, i.e, that
**  the target document might differ from the current,
**  based on any caching directives or analyses which
**  claimed or suggested this. -FM
*/
PUBLIC BOOL HText_AreDifferent ARGS2(
	HTParentAnchor *,	anchor,
	CONST char *,		full_address)
d11910 2
a11911 2
     *  Do we have a loaded document and both
     *  arguments for this function?
d11917 1
a11917 1
     *  Do we have both URLs?
d11924 1
a11924 1
     *  Do we have a fragment associated with the target?
d11930 3
a11932 3
     *  Always treat client-side image map menus
     *  as potentially stale, so we'll create a
     *  fresh menu from the LynxMaps HTList.
d11938 1
a11938 1
     *  Do the docs differ in the type of request?
d11944 3
a11946 3
     *  Are the actual URLs different, after factoring
     *  out a "LYNXIMGMAP:" leader in the MainText URL
     *  and its fragment, if present?
d11949 2
a11950 2
		? MTanc->address + LEN_LYNXIMGMAP
		: MTanc->address);
d11954 1
a11954 1
	return(TRUE);
d11959 2
a11960 2
     *  If the MainText is not an image map menu,
     *  do the docs have different POST contents?
d11967 1
a11967 1
		     *  Both have contents, and they differ.
d11969 1
a11969 1
		    return(TRUE);
d11973 2
a11974 2
		 *  The loaded document has content, but the
		 *  target doesn't, so they're different.
d11976 1
a11976 1
		return(TRUE);
d11980 2
a11981 2
	     *  The loaded document does not have content, but
	     *  the target does, so they're different.
d11983 1
a11983 1
	    return(TRUE);
d11988 3
a11990 3
     *  We'll assume the target is a position in the currently
     *  displayed document, and thus can ignore any header, META,
     *  or other directives not to use a cached rendition. -FM
d11992 1
a11992 1
    return(FALSE);
d11999 5
a12003 5
 *  Cleanup new lines coming into a TEXTAREA from an external editor, or a
 *  file, such that they are in a suitable format for TEXTAREA rendering,
 *  display, and manipulation.  That means trimming off trailing whitespace
 *  from the line, expanding TABS into SPACES, and substituting a printable
 *  character for control chars, and the like.
d12005 1
a12005 1
 *  --KED  02/24/99
d12007 2
a12008 3
PRIVATE void cleanup_line_for_textarea ARGS2(
	     char *,  line,
	     int,     len)
d12010 1
a12010 1
    char  tbuf[MAX_LINE];
d12015 2
a12016 3
    int   i;
    int   n;

d12019 1
a12019 1
     *  Whack off trailing whitespace from the line.
d12028 1
a12028 1
    if (strlen (line) != 0) {
d12030 1
a12030 1
	 *  Expand any tab's, since they won't render properly in a TEXTAREA.
d12032 3
a12034 3
	 *  [Is that "by spec", or just a "lynxism"?  As may be, it seems that
	 *   such chars may cause other problems, too ... with cursor movement,
	 *   submit'ing, etc.  Probably needs looking into more deeply.]
d12040 5
a12044 5
	    if ((cp = strchr (p, '\t')) != 0) {
		i  = cp - p;
		s  = (strncpy (s, p, i))      + i;
		n  = TABSTOP - (i % TABSTOP);
		s  = (strncpy (s, SPACES, n)) + n;
d12049 1
a12049 1
		strcpy (s, p);
d12055 8
a12062 8
	 *  Replace control chars with something printable.  Note that char
	 *  substitution above 0x7f is dependent on the charset being used,
	 *  and then only applies to the contiguous run of char values that
	 *  are between 0x80, and the 1st real high-order-bit-set character,
	 *  as specified by the charset.  In general (ie, for many character
	 *  sets), that usually means the so-called "C1 control chars" that
	 *  range from 0x80 thru 0x9f.  For EBCDIC machines, we only trim the
	 *  (control) chars below a space (x'40').
d12064 2
a12065 2
	 *  The assumption in all this is that the charset used in the editor,
	 *  is compatible with the charset specified in lynx.
d12067 8
a12074 8
	 *  [At some point in time, when/if lynx ever supports multibyte chars
	 *   internally (eg, UCS-2, UCS-4, UTF-16, etc), this kind of thing may
	 *   well cause problems.  But then, supporting such char sets will
	 *   require massive changes in (most) all parts of the lynx code, so
	 *   until then, we do the rational thing with char values that would
	 *   otherwise foul the display, if left alone.  If you're implementing
	 *   multibyte character set support, consider yourself to have been
	 *   warned.]
d12078 2
a12079 2
	    *p = ((UCH(*s)  < UCH(' '))       ||
		  (UCH(*s) == UCH('\177'))    ||
d12083 1
a12083 1
		 ? (char) SPLAT : *s;
a12093 1

d12095 10
a12104 10
 *  Re-render the text of a tagged ("[123]") HTLine (arg1), with the tag
 *  number incremented by some value (arg5).  The re-rendered string may
 *  be allowed to expand in the event of a tag width change (eg, 99 -> 100)
 *  as controlled by arg6 (CHOP or NOCHOP).  Arg4 is either (the address
 *  of) a value which must match, in order for the tag to be incremented,
 *  or (the address of) a 0-value, which will match any value, and cause
 *  any valid tag to be incremented.  Arg2 is a pointer to the first/only
 *  anchor that exists on the line; we may need to adjust their position(s)
 *  on the line.  Arg3 when non-0 indicates the number of new digits that
 *  were added to the 2nd line in a line crossing pair.
d12106 2
a12107 2
 *  All tags fields in a line which individually match an expected new value,
 *  are incremented.  Line crossing [tags] are handled (PITA).
d12109 1
a12109 1
 *  Untagged or improperly tagged lines are not altered.
d12111 2
a12112 2
 *  Returns the number of chars added to the original string's length, if
 *  any.
d12114 1
a12114 1
 *  --KED  02/03/99
d12116 4
a12119 7
PRIVATE int increment_tagged_htline ARGS6(
	HTLine *,	ht,
	TextAnchor *,   a,
	int *,		lx_val,
	int *,		old_val,
	int,		incr,
	int,		mode)
d12121 2
a12122 2
    char    buf[MAX_LINE];
    char  lxbuf[MAX_LINE * 2];
d12124 1
a12124 1
    TextAnchor *st_anchor  = a;
d12127 3
a12129 3
    char *p   = ht->data;
    char *s   = buf;
    char *lx  = lxbuf;
d12132 2
a12133 9
    BOOLEAN   plx    = FALSE;
    BOOLEAN   valid;

    int   val;
    int   n;
    int   new_n;
    int   pre_n;
    int   post_n;
    int   fixup = 0;
d12135 16
a12150 10

    /*
     *  Cleanup for the 2nd half of a line crosser, whose number of tag
     *  digits grew by some number of places (usually 1 when it does
     *  happen, though it *could* be more).  The tag chars were already
     *  rendered into the 2nd line of the pair, but the positioning and
     *  other effects haven't been rippled through any other anchors on
     *  the (2nd) line.  So we do that here, as a special case, since
     *  the part of the tag that's in the 2nd line of the pair, will not
     *  be found by the tag string parsing code.  Double PITA.
d12152 1
a12152 1
     *  [see comments below on line crosser caused problems]
d12160 1
a12160 1
	fixup  = *lx_val;
d12162 2
a12163 1
	if (st_anchor) st_anchor = st_anchor->next;
d12167 1
a12167 1
     *  Walk thru the line looking for tags (ie, "[nnn]" strings).
d12169 2
a12170 2
    while  (*p != '\0') {
	if (*p != '[')	{
d12175 4
a12178 4
	    *s++  = *p++;
	    t     = p;
	    n     = 0;
	    valid = TRUE;   /* p = t = byte after '[' */
d12181 1
a12181 1
	     *  Make sure there are only digits between "[" and "]".
d12183 2
a12184 2
	    while  (*t != ']')  {
		if (*t == '\0') { /* uhoh - we have a potential line crosser */
d12186 1
a12186 1
		    plx   = TRUE;
d12199 3
a12201 3
	     *  If the format is OK, we check to see if the value is what
	     *  we expect.  If not, we have a random [nn] string in the text,
	     *  and leave it alone.
d12203 12
a12214 12
	     *  [It is *possible* to have a false match here, *if* there are
	     *   two identical [nn] strings (including the numeric value of
	     *   nn), one of which is the [tag], and the other being part of
	     *   a document.  In such a case, the 1st [nn] string will get
	     *   incremented; the 2nd one won't, which makes it a 50-50 chance
	     *   of being correct, if and when such an unlikely juxtaposition
	     *   of text ever occurs.  Further validation tests of the [nnn]
	     *   string are probably not possible, since little of the actual
	     *   anchor-associated-text is retained in the TextAnchor or the
	     *   FormInfo structs.  Fortunately, I think the current method is
	     *   more than adequate to weed out 99.999% of any possible false
	     *   matches, just as it stands.  Caveat emptor.]
d12217 2
a12218 2
		val = atoi (p);
		if ((val == *old_val) || (*old_val == 0)) { /* 0 matches all */
d12222 2
a12223 2
		    sprintf (s, "%d", val);
		    new_n = strlen (s);
d12228 4
a12231 4
		     *  If the number of digits in an existing [tag] increased
		     *  (eg, [99] --> [100], etc), we need to "adjust" its
		     *  horizontal position, and that of all subsequent tags
		     *  that may be on the same line.  PITA.
d12233 11
a12243 11
		     *  [This seems to work as long as a tag isn't a line
		     *   crosser; when it is, the position of anchors on either
		     *   side of the split tag, seem to "float" and try to be
		     *   as "centered" as possible.  Which means that simply
		     *   incrementing the line_pos by the fixed value of the
		     *   number of digits that got added to some tag in either
		     *   line doesn't work quite right, and the text for (say)
		     *   a button may get stomped on by another copy of itself,
		     *   but offset by a few chars, when it is selected (eg,
		     *   "Box Office" may end up looking like "BoBox Office" or
		     *   "Box Officece", etc.
d12245 2
a12246 2
		     *   Dunno how to fix that behavior ATT, but at least the
		     *   tag numbers themselves are correct.  -KED  /\oo/\ ]
d12250 1
a12250 1
			while ((nxt_anchor)			      &&
d12255 2
a12256 1
			if (st_anchor) st_anchor = st_anchor->next;
d12262 7
a12268 7
	     *  Unfortunately, valid [tag] strings *can* be split across two
	     *  lines.  Perhaps it would be best to just prevent that from
	     *  happening, but a look into that code, makes me wonder.  Anyway,
	     *  we can handle such tags without *too* much trouble in here [I
	     *  think], though since such animals are rather rare, it makes it
	     *  a bit difficult to test thoroughly (ie, Beyond here, there be
	     *  Dragons).
d12270 1
a12270 1
	     *  We use lxbuf[] to deal with the two lines involved.
d12272 1
a12272 1
	    pre_n = strlen (p);	/* count of 1st part chars in this line */
d12275 3
a12277 3
	     && (pre_n + post_n + 2 < (int) sizeof(lxbuf))) {
		strcpy (lx, p);      /* <- 1st part of a possible lx'ing tag */
		strcat (lx, ht->next->data);   /* tack on NEXT line	     */
d12279 2
a12280 2
		t     = lx;
		n     = 0;
d12284 1
a12284 1
		 *  Go hunting again for just digits, followed by tag end ']'.
d12297 4
a12300 4
		 *  It *looks* like a line crosser; now we value test it to
		 *  find out for sure [but see the "false match" warning,
		 *  above], and if it matches, increment it into the buffer,
		 *  along with the 2nd line's text.
d12303 3
a12305 3
		 && (n > 0)
		 && (n + post_n + 2) < MAX_LINE) {
		    val = atoi (lx);
d12310 3
a12312 3
			sprintf (lx, "%d", val);
			new_n = strlen (lx);
			strcat (lx, strchr (ht->next->data, ']'));
d12315 4
a12318 4
			 *  We keep the the same number of chars from the
			 *  adjusted tag number in the current line; any
			 *  extra chars due to a digits increase, will be
			 *  stuffed into the next line.
d12320 2
a12321 2
			 *  Keep track of any digits added, for the next
			 *  pass through.
d12323 1
a12323 1
			s   = strncpy (s, lx, pre_n) + pre_n;
d12325 1
a12325 1
			strcpy (ht->next->data, lx);
d12330 1
a12330 1
		break;	/* had an lx'er, so we're done with this line */
d12337 1
a12337 1
    n = strlen (ht->data);
d12342 2
a12343 1
	HTLine* temp;
d12352 1
a12352 1
	memcpy(temp->styles, ht->styles, sizeof(HTStyleChange)*ht->numstyles);
d12358 1
a12358 1
    strcpy (ht->data, buf);
d12360 1
a12360 1
    return (strlen (buf) - n + fixup);
a12362 1

d12364 3
a12366 3
 *  Creates a new anchor and associated struct's appropriate for a form
 *  TEXTAREA, and links them into the lists following the current anchor
 *  position (as specified by arg1).
d12368 2
a12369 2
 *  Exits with arg1 now pointing at the new TextAnchor, and arg2 pointing
 *  at the new, associated HTLine.
d12371 1
a12371 1
 *  --KED  02/13/99
d12373 1
a12373 3
PRIVATE void insert_new_textarea_anchor ARGS2(
	TextAnchor **,   curr_anchor,
	HTLine **,       exit_htline)
d12376 1
a12376 1
    HTLine     *htline;
d12379 2
a12380 2
    FormInfo   *f = 0;
    HTLine     *l = 0;
d12382 2
a12383 2
    int curr_tag  = 0;   /* 0 ==> match any [tag] number */
    int lx	  = 0;	 /* 0 ==> no line crossing [tag]; it's a new line */
a12385 1

d12387 2
a12388 2
     *  Find line in the text that matches ending anchorline of
     *  the TEXTAREA.
d12390 5
a12394 5
     *  [Yes, Virginia ... we *do* have to go thru this for each
     *   anchor being added, since there is NOT a 1-to-1 mapping
     *   between anchors and htlines.  I suppose we could create
     *   YAS (Yet Another Struct), but there are too many structs{}
     *   floating around in here, as it is.  IMNSHO.]
d12397 1
a12397 1
	 anchor->line_num != i;                i++) {
d12404 2
a12405 2
     *  Clone and initialize the struct's needed to add a new TEXTAREA
     *  anchor.
d12409 1
d12416 6
a12421 5
    a->next	       = anchor->next;
    a->number	       = anchor->number;
    a->line_pos	       = anchor->line_pos;
    a->extent	       = anchor->extent;
    a->line_num	       = anchor->line_num + 1;
d12423 6
a12428 6
    a->link_type       = anchor->link_type;
    a->input_field     = f;
    a->show_anchor     = anchor->show_anchor;
    a->inUnderline     = anchor->inUnderline;
    a->expansion_anch  = TRUE;
    a->anchor	       = NULL;
d12432 9
a12440 9
    StrAllocCopy (f->name, anchor->input_field->name);
    f->number	       = anchor->input_field->number;
    f->type	       = anchor->input_field->type;
    StrAllocCopy (f->orig_value, "");
    f->size	       = anchor->input_field->size;
    f->maxlength       = anchor->input_field->maxlength;
    f->no_cache        = anchor->input_field->no_cache;
    f->disabled        = anchor->input_field->disabled;
    f->value_cs        = current_char_set; /* use current setting - kw */
d12443 4
a12446 4
    l->next	       = htline->next;
    l->prev	       = htline;
    l->offset	       = htline->offset;
    l->size	       = htline->size;
d12449 2
a12450 2
    l->numstyles       = htline->numstyles;
    /*we fork the pointers!*/
d12453 1
a12453 1
    strcpy (l->data,     htline->data);
d12456 1
a12456 1
     *  Link in the new HTLine.
d12459 1
a12459 1
    htline->next       = l;
d12463 1
a12463 1
	increment_tagged_htline (l, a, &lx, &curr_tag, 1, CHOP);
d12467 2
a12468 2
     *  If we're at the tail end of the TextAnchor or HTLine list(s),
     *  the new node becomes the last node.
d12476 2
a12477 2
     *  Link in the new TextAnchor and point the entry anchor arg at it;
     *  point the entry HTLine arg at it, too.
d12480 1
a12480 1
   *curr_anchor  = a;
d12482 1
a12482 1
   *exit_htline        = l->next;
a12486 1

d12488 2
a12489 2
 *  If new anchors were added to expand a TEXTAREA, we need to ripple the
 *  new line numbers [and char counts ?] thru the subsequent anchors.
d12491 2
a12492 2
 *  If form lines are getting [nnn] tagged, we need to update the displayed
 *  tag values to match (which means rerendering them ... sigh).
d12494 1
a12494 1
 *  Finally, we need to update various HTMainText and other counts, etc.
d12496 2
a12497 2
 *  [dunno if the char counts really *need* to be done, or if we're using
 *   the exactly proper values/algorithms ... seems to be OK though ...]
d12499 1
a12499 1
 *  --KED  02/13/99
d12501 4
a12504 5
PRIVATE void update_subsequent_anchors ARGS4(
	int,		 newlines,
	TextAnchor *,	 start_anchor,
	HTLine *,	 start_htline,
	int,		 start_tag)
d12507 1
a12507 7
    HTLine     *htline = start_htline;

    int		line_adj = 0;
    int		tag_adj	 = 0;
    int		lx	 = 0;
    int	     hang	 = 0;  /* for HANG detection of a nasty intermittent */
    int      hang_detect = 100000;  /* ditto */
d12509 5
d12518 1
a12518 1
     *  Update numeric fields of the rest of the anchors.
d12520 4
a12523 4
     *  [We bypass bumping ->number if it has a value of 0, which takes care
     *   of the ->input_field->type == F_HIDDEN_TYPE (as well as any other
     *   "hidden" anchors, if such things exist).  Seems like the "right
     *   thing" to do.  I think.]
d12525 1
a12525 1
    anchor = start_anchor->next;   /* begin updating with the NEXT anchor */
d12530 1
a12530 1
	anchor->line_num  += newlines;
d12535 1
a12535 1
     *  Update/rerender anchor [tags], if they are being numbered.
d12537 6
a12542 6
     *  [If a number tag (eg, "[177]") is itself broken across a line
     *   boundary, this fixup only partially works.  While the tag
     *   numbering is done properly across the pair of lines, the
     *   horizontal positioning on *either* side of the split, can get
     *   out of sync by a char or two when it gets selected.  See the
     *   [comments] in  increment_tagged_htline()  for some more detail.
d12544 3
a12546 3
     *   I suppose THE fix is to prevent such tag-breaking in the first
     *   place (dunno where yet, though).  Ah well ... at least the tag
     *   numbers themselves are correct from top to bottom now.
d12548 7
a12554 7
     *   All that said, about the only time this will be a problem in
     *   *practice*, is when a page has near 1000 links or more (possibly
     *   after a TEXTAREA expansion), and has line crossing tag(s), and
     *   the tag numbers in a line crosser go from initially all 3 digit
     *   numbers, to some mix of 3 and 4 digits (or all 4 digits) as a
     *   result of the expansion process.  Oh, you also need a "clump" of
     *   anchors all on the same lines.
d12556 2
a12557 2
     *   Yes, it *can* happen, but in real life, it probably won't be
     *   seen very much ...]
d12559 4
a12562 4
     *  [This may also be an artifact of bumping into the right hand
     *   screen edge (or RHS margin), since we don't even *think* about
     *   relocating an anchor to the following line, when [tag] digits
     *   expansion pushes things too far in that direction.]
d12598 3
a12600 3
		line_adj = increment_tagged_htline (htline,  anchor,  &lx,
						    &start_tag, newlines,
						    NOCHOP);
d12602 1
a12602 1
		tag_adj      += line_adj;
d12606 1
a12606 1
		break;	/* out of anchors ... we're done */
d12613 1
a12613 1
finish:
d12615 1
a12615 1
     *  Fixup various global variables.
d12617 2
a12618 2
    nlinks                         += newlines;
    HTMainText->Lines              += newlines;
d12621 1
a12621 1
    more = HText_canScrollDown();
d12627 1
a12627 1
hang_detected:  /* ugliness has happened; inform user and do the best we can */
a12632 1

d12634 4
a12637 4
 *  Transfer the initial contents of a TEXTAREA to a temp file, invoke the
 *  user's editor on that file, then transfer the contents of the resultant
 *  edited file back into the TEXTAREA (expanding the size of the area, if
 *  required).
d12639 3
a12641 3
 *  Returns the number of lines that the cursor should be moved so that it
 *  will end up on the 1st blank line of whatever number of trailing blank
 *  lines there are in the TEXTAREA (there will *always* be at least one).
d12643 1
a12643 1
 *  --KED  02/01/99
d12645 1
a12645 2
PUBLIC int HText_ExtEditForm ARGS1(
	   LinkInfo *,	form_link)
d12648 1
a12648 1
    size_t	size;
d12650 2
a12651 2
    char       *ed_temp;
    FILE       *fp;
d12654 3
a12656 3
    TextAnchor *start_anchor  = NULL;
    TextAnchor *end_anchor    = NULL;
    BOOLEAN	firstanchor   = TRUE;
d12659 23
a12681 23
    char	ed_offset[10];
    int		start_line    = 0;
    int		entry_line    = form_link->anchor_line_num;
    int		exit_line     = 0;
    int		orig_cnt      = 0;
    int		line_cnt      = 1;

    FormInfo   *form	 = form_link->l_form;
    char       *areaname = form->name;
    int		form_num = form->number;

    HTLine     *htline	 = NULL;

    char       *ebuf;
    char       *line;
    char       *lp;
    char       *cp;
    int		match_tag = 0;
    int		newlines  = 0;
    int		len, len0, len_in;
    int		wanted_fieldlen_wrap = -1; /* not yet asked; 0 means don't. */
    char       *skip_at = NULL;
    int		skip_num = 0, i;
d12685 2
a12686 2
    ed_temp = (char *) malloc (LY_MAXPATH);
    if ((fp = LYOpenTemp (ed_temp, "", "w")) == 0) {
d12692 2
a12693 2
     *	Begin at the beginning, to find 1st anchor in the TEXTAREA, then
     *	write all of its lines (anchors) out to the edit temp file.
d12695 7
a12701 7
     *	[Finding the TEXTAREA we're actually *in* with these attributes
     *	 isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     *	 and there *could* be TEXTAREA's with the same "name".	If that
     *	 should ever be true, we'll actually get the data from the *1st*
     *	 TEXTAREA in the page that matches.  We should probably assign
     *	 a unique id to each TEXTAREA in a page, and match on that, to
     *	 avoid this (potential) problem.
d12703 3
a12705 3
     *	 Since the odds of "false matches" *actually* happening in real
     *	 life seem rather small though, we'll hold off doing this, for a
     *	 rainy day ...]
d12711 4
a12714 4
	if ((anchor_ptr->link_type	     == INPUT_ANCHOR)    &&
	    (anchor_ptr->input_field->type   == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num)	 &&
	    !strcmp (anchor_ptr->input_field->name, areaname))   {
d12717 1
a12717 1
		firstanchor  = FALSE;
d12719 1
a12719 1
		start_line   = anchor_ptr->line_num;
d12724 1
a12724 1
	     *  Write the anchors' text to the temp edit file.
d12726 2
a12727 2
	    fputs (anchor_ptr->input_field->value, fp);
	    fputc ('\n', fp);
d12729 1
a12729 1
	 } else {
d12733 2
a12734 2
	 }
	 anchor_ptr = anchor_ptr->next;
d12736 1
a12736 1
    LYCloseTempFP (fp);
d12742 3
a12744 3
     *	Go edit the TEXTAREA temp file, with the initial editor line
     *  corresponding to the TEXTAREA line the cursor is on (if such
     *  positioning is supported by the editor [as lynx knows it]).
d12746 1
a12746 1
    ed_offset[0] = 0; /* pre-ANSI compilers don't initialize aggregates - TD */
d12748 1
a12748 1
	sprintf (ed_offset, "%d", ((entry_line - start_line) + 1));
d12755 1
a12755 1
     *	Read back the edited temp file into our buffer.
d12757 2
a12758 2
    if ((stat (ed_temp, &stat_info) < 0)   ||
	!S_ISREG(stat_info.st_mode)        ||
d12761 2
a12762 1
	ebuf = typecalloc (char);
d12767 1
d12770 4
a12773 4
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it.  With some luck, the user may be even able
	     *  to recover the file manually from the temp space while
	     *  the lynx session is not over. - kw
d12780 3
a12782 3
	fp = fopen (ed_temp, "r");
	size = fread (ebuf, 1, size, fp);
	LYCloseInput (fp);
d12787 1
a12787 1
     *	Nuke any blank lines from the end of the edited data.
d12790 1
a12790 1
     && (CanTrimTextArea(UCH(ebuf[size-1])) || (ebuf[size-1] == '\0')))
d12794 3
a12796 3
     *	Copy each line from the temp file into the corresponding anchor
     *  struct.  Add new lines to the TEXTAREA if needed.  (Always leave
     *  the user with a blank line at the end of the TEXTAREA.)
d12798 1
a12798 1
    if ((line = (char *) malloc (MAX_LINE)) == 0)
d12807 1
a12807 1
    lp  = ebuf;
d12823 2
a12824 2
	if ((cp = strchr (lp, '\n')) != 0)
	   len = len_in = cp - lp;
d12826 1
a12826 2
	   len = len_in = strlen (lp);

d12829 1
a12829 1
	    len0+len >= start_anchor->input_field->size &&
d12831 1
a12831 1
	    (cp-lp) < start_anchor->input_field->size - 1) {
d12841 3
a12843 3
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    for (i = wanted_fieldlen_wrap-len0;
		 i+len0 >= wanted_fieldlen_wrap/4; i--) {
d12855 1
a12855 1
			       (cp - lp) <= len + (3 * wanted_fieldlen_wrap/4))
d12863 1
a12863 1
			    while (isspace(UCH(*(cp-1)))) {
d12874 3
a12876 3
	if (wanted_fieldlen_wrap > 0 && len0+len > wanted_fieldlen_wrap) {
	    i = len-1;
	    while (len0+i+1 > wanted_fieldlen_wrap &&
d12879 1
a12879 1
	    if (len0+i+1 > wanted_fieldlen_wrap)
d12883 1
a12883 1
	if (len0+len >= MAX_LINE) {
d12890 1
a12890 1
	     *  First try to find a space character for wrapping - kw
d12898 1
a12898 1
	    if (len0+len >= MAX_LINE)
d12902 2
a12903 2
	strncat (line, lp, len);
	*(line + len0+len) = '\0';
d12905 1
a12905 1
	cleanup_line_for_textarea (line, len0+len);
d12908 3
a12910 3
	 *  If there are more lines in the edit buffer than were in the
	 *  original TEXTAREA, we need to add a new line/anchor, continuing
	 *  on until the edit buffer is empty.
d12913 2
a12914 2
	    insert_new_textarea_anchor (&end_anchor, &htline);
	    anchor_ptr = end_anchor;   /* make the new anchor current */
d12919 1
a12919 1
	 *  Finally copy the new line from the edit buffer into the anchor.
d12924 2
a12925 2
	 *  Keep track of 1st blank line in any trailing blank lines, for
	 *  later cursor repositioning.
d12927 1
a12927 1
	if (len0+len > 0)
d12933 1
a12933 1
	 *  And do the next line of edited text, for the next anchor ...
d12936 2
a12937 1
	if (*lp && isspace(UCH(*lp))) lp++;
d12951 3
a12953 3
     *	If we've added any new lines/anchors, we need to adjust various
     *  things in all anchor-bearing lines following the last newly added
     *  line/anchor.  The fun stuff starts here ...
d12956 1
a12956 1
	update_subsequent_anchors (newlines, end_anchor, htline, match_tag);
d12959 1
a12959 1
     *  Cleanup time.
d12963 1
a12963 1
    LYRemoveTemp (ed_temp);
d12969 4
a12972 4
     *  Return the offset needed to move the cursor from its current
     *  (on entry) line number, to the 1st blank line of the trailing
     *  (group of) blank line(s), which is where we want to be.  Let
     *  the caller deal with moving us there, however ... :-) ...
a12976 1

d12978 2
a12979 2
 *  Expand the size of a TEXTAREA by a fixed number of lines (as specified
 *  by arg2).
d12981 1
a12981 1
 *  --KED  02/14/99
d12983 1
a12983 3
PUBLIC void HText_ExpandTextarea ARGS2(
	    LinkInfo *,	form_link,
	    int,	newlines)
d12986 2
a12987 2
    TextAnchor *end_anchor    = NULL;
    BOOLEAN	firstanchor   = TRUE;
d12989 3
a12991 3
    FormInfo *form      = form_link->l_form;
    char     *areaname  = form->name;
    int       form_num  = form->number;
d12993 1
a12993 4
    HTLine   *htline    = NULL;

    int       match_tag = 0;
    int       i;
d12995 2
d13000 2
a13001 1
    if (newlines < 1) return;
d13004 2
a13005 2
     *	Begin at the beginning, to find the TEXTAREA, then on to find
     *	the last line (anchor) in it.
d13007 7
a13013 7
     *	[Finding the TEXTAREA we're actually *in* with these attributes
     *	 isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     *	 and there *could* be TEXTAREA's with the same "name".	If that
     *	 should ever be true, we'll actually expand the *1st* TEXTAREA
     *	 in the page that matches.  We should probably assign a unique
     *	 id to each TEXTAREA in a page, and match on that, to avoid this
     *	 (potential) problem.
d13015 3
a13017 3
     *	 Since the odds of "false matches" *actually* happening in real
     *	 life seem rather small though, we'll hold off doing this, for a
     *	 rainy day ...]
d13023 4
a13026 4
	if ((anchor_ptr->link_type	     == INPUT_ANCHOR)    &&
	    (anchor_ptr->input_field->type   == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num)	 &&
	    !strcmp (anchor_ptr->input_field->name, areaname))   {
d13033 1
a13033 1
	 } else {
d13037 2
a13038 2
	 }
	 anchor_ptr = anchor_ptr->next;
d13042 1
a13042 1
	insert_new_textarea_anchor (&end_anchor, &htline);
d13045 1
a13045 1
	 *  Make the new line blank.
d13050 1
a13050 1
	 *  And go add another line ...
d13053 1
a13053 1
	   match_tag = end_anchor->next->number;
d13057 1
a13057 1
		newlines, areaname));
d13060 2
a13061 2
     *	We need to adjust various things in all anchor bearing lines
     *	following the last newly added line/anchor.  Fun stuff.
d13063 1
a13063 1
    update_subsequent_anchors (newlines, end_anchor, htline, match_tag);
a13069 1

d13071 2
a13072 2
 *  Insert the contents of a file into a TEXTAREA between the cursor line,
 *  and the line preceding it.
d13074 3
a13076 3
 *  Returns the number of lines that the cursor should be moved so that it
 *  will end up on the 1st line in the TEXTAREA following the inserted file
 *  (if we decide to do that).
d13078 1
a13078 1
 *  --KED  02/21/99
d13080 1
a13080 2
PUBLIC int HText_InsertFile ARGS1(
	   LinkInfo *,	form_link)
d13083 1
a13083 1
    size_t	size;
d13085 2
a13086 2
    FILE       *fp;
    char       *fn;
d13090 2
a13091 2
    TextAnchor *end_anchor  = NULL;
    BOOLEAN	firstanchor = TRUE;
d13094 3
a13096 3
    FormInfo   *form	 = form_link->l_form;
    char       *areaname = form->name;
    int		form_num = form->number;
d13098 1
a13098 1
    HTLine     *htline	 = NULL;
d13101 2
a13102 13
    FormInfo   *f = 0;
    HTLine     *l = 0;

    char       *fbuf;
    char       *line;
    char       *lp;
    char       *cp;
    int		entry_line = form_link->anchor_line_num;
    int		file_cs;
    int		match_tag  = 0;
    int		newlines   = 0;
    int		len;
    int		i;
d13104 10
d13121 3
a13123 2
	HTInfoMsg (FILE_INSERT_CANCELLED);
	CTRACE((tfp, "GridText: file insert cancelled - no filename provided\n"));
d13134 1
a13134 1
     *	Read it into our buffer (abort on 0-length file).
d13136 1
a13136 1
    if ((stat (fn, &stat_info) < 0)        ||
d13138 4
a13141 3
	HTInfoMsg (FILE_INSERT_0_LENGTH);
	CTRACE((tfp, "GridText: file insert aborted - file=|%s|- was 0-length\n",
		    fn));
d13149 3
a13151 3
	     *  This could be huge - don't exit if we don't have enough
	     *  memory for it. - kw
	     */ /*outofmem(__FILE__, "HText_InsertFile");*/
d13167 1
a13167 1
	fp   = fopen (fn, "r");
d13174 2
a13175 2
	size = fread (fbuf, 1, size, fp);
	LYCloseInput (fp);
a13179 1

d13181 2
a13182 2
     *	Begin at the beginning, to find the TEXTAREA we're in, then
     *	the current cursorline.
d13184 7
a13190 7
     *	[Finding the TEXTAREA we're actually *in* with these attributes
     *	 isn't foolproof.  The form_num isn't unique to a given TEXTAREA,
     *	 and there *could* be TEXTAREA's with the same "name".	If that
     *	 should ever be true, we'll actually insert data into the *1st*
     *	 TEXTAREA in the page that matches.  We should probably assign
     *	 a unique id to each TEXTAREA in a page, and match on that, to
     *	 avoid this (potential) problem.
d13192 3
a13194 3
     *	 Since the odds of "false matches" *actually* happening in real
     *	 life seem rather small though, we'll hold off doing this, for a
     *	 rainy day ...]
d13200 4
a13203 4
	if ((anchor_ptr->link_type	     == INPUT_ANCHOR)    &&
	    (anchor_ptr->input_field->type   == F_TEXTAREA_TYPE) &&
	    (anchor_ptr->input_field->number == form_num)	 &&
	    !strcmp (anchor_ptr->input_field->name, areaname))   {
d13205 2
a13206 2
	   if (anchor_ptr->line_num == entry_line)
	      break;
d13209 1
a13209 1
	anchor_ptr  = anchor_ptr->next;
a13211 1

d13213 2
a13214 2
     *  Clone a new TEXTAREA line/anchor using the cursorline anchor as
     *  a template, but link it in BEFORE the cursorline anchor/htline.
d13216 5
a13220 5
     *  [We can probably combine this with insert_new_textarea_anchor()
     *   along with a flag to indicate "insert before" as we do here,
     *   or the "normal" mode of operation (add after "current" anchor/
     *   line).  Beware of the differences ... some are a bit subtle to
     *   notice.]
d13223 1
a13223 1
	 anchor_ptr->line_num != i;            i++) {
d13231 1
d13238 6
a13243 5
    a->next	       = anchor_ptr;
    a->number	       = anchor_ptr->number;
    a->line_pos	       = anchor_ptr->line_pos;
    a->extent	       = anchor_ptr->extent;
    a->line_num	       = anchor_ptr->line_num;
d13245 6
a13250 6
    a->link_type       = anchor_ptr->link_type;
    a->input_field     = f;
    a->show_anchor     = anchor_ptr->show_anchor;
    a->inUnderline     = anchor_ptr->inUnderline;
    a->expansion_anch  = TRUE;
    a->anchor	       = NULL;
d13254 9
a13262 9
    StrAllocCopy (f->name, anchor_ptr->input_field->name);
    f->number	       = anchor_ptr->input_field->number;
    f->type	       = anchor_ptr->input_field->type;
    StrAllocCopy (f->orig_value, "");
    f->size	       = anchor_ptr->input_field->size;
    f->maxlength       = anchor_ptr->input_field->maxlength;
    f->no_cache        = anchor_ptr->input_field->no_cache;
    f->disabled        = anchor_ptr->input_field->disabled;
    f->value_cs        = (file_cs >= 0) ? file_cs : current_char_set;
d13265 2
a13266 2
    l->offset	       = htline->offset;
    l->size	       = htline->size;
d13269 2
a13270 2
    l->numstyles       = htline->numstyles;
    /*we fork the pointers!*/
d13273 1
a13273 1
    strcpy (l->data,     htline->data);
d13276 2
a13277 2
     *  If we're at the head of the TextAnchor list, the new node becomes
     *  the first node.
d13283 1
a13283 1
     *  Link in the new TextAnchor, and corresponding HTLine.
d13288 5
a13292 5
    htline		= htline->prev;
    l->next		= htline->next;
    l->prev		= htline;
    htline->next->prev	= l;
    htline->next	= l;
d13295 3
a13297 3
     *  update_subsequent_anchors() expects htline to point to 1st potential
     *  line needing fixup; we need to do this just in case the inserted file
     *  was only a single line (yes, it's pathological ... ).
d13299 2
a13300 2
    htline = htline->next; /* ->new (current) htline, for 1st inserted line  */
    htline = htline->next; /* ->1st potential (following) [tag] fixup htline */
a13304 1

d13306 2
a13307 2
     *	Copy each line from the insert file into the corresponding anchor
     *  struct.
d13309 1
a13309 1
     *  Begin with the new line/anchor we just added (above the cursorline).
d13311 1
a13311 1
    if ((line = (char *) malloc (MAX_LINE)) == 0)
d13317 1
a13317 1
    lp  = fbuf;
d13321 2
a13322 2
	if ((cp = strchr (lp, '\n')) != 0)
	   len = cp - lp;
d13324 1
a13324 1
	   len = strlen (lp);
d13333 1
a13333 1
		lp[len+1] = '\0'; /* prevent next iteration */
d13335 1
a13335 1
	strncpy (line, lp, len);
d13338 1
a13338 1
	cleanup_line_for_textarea (line, len);
d13341 2
a13342 2
	 *  If not the first line from the insert file, we need to add
	 *  a new line/anchor, continuing on until the buffer is empty.
d13345 3
a13347 3
	   insert_new_textarea_anchor (&end_anchor, &htline);
	   anchor_ptr = end_anchor;   /* make the new anchor current */
	   newlines++;
d13351 1
a13351 1
	 *  Copy the new line from the buffer into the anchor.
d13356 2
a13357 2
	 *  insert_new_textarea_anchor always uses current_char_set,
	 *  we may want something else, so fix it up. - kw
d13359 2
a13360 2
	 if (file_cs >= 0)
	     anchor_ptr->input_field->value_cs = file_cs;
d13363 1
a13363 1
	 *  And do the next line of insert text, for the next anchor ...
d13366 2
a13367 1
	if (*lp) lp++;
d13370 2
a13371 2
	end_anchor  = anchor_ptr;
	anchor_ptr  = anchor_ptr->next;
d13377 2
a13378 2
     *	Now adjust various things in all anchor-bearing lines following the
     *  last newly added line/anchor.  Some say this is the fun part ...
d13380 1
a13380 1
    update_subsequent_anchors (newlines, end_anchor, htline, match_tag);
d13383 1
a13383 1
     *  Cleanup time.
d13393 33
d13438 3
a13440 5
PRIVATE void redraw_part_of_line ARGS4(
	HTLine *,	line,
	char*,		str,
	int,		len,
	HText *,	text)
d13444 1
a13444 1
    char *data,*end_of_data;
d13446 1
d13449 1
d13452 1
a13452 1
    int YP,XP;
d13454 1
a13454 1
    LYGetYX(YP,XP);
d13465 2
a13466 2
    /* this assumes that the part of line to be drawn fits in the screen*/
    while (  data < end_of_data ) {
d13470 1
a13470 1
#if defined(USE_COLOR_STYLE) || defined(SLSC)
d13473 3
d13477 4
a13480 4
	       i >= (int) (CStyle.horizpos + line->offset + 1))
	{
		LynxChangeStyle (CStyle.style,CStyle.direction);
		current_style++;
d13486 8
a13493 8
	    case LY_UNDERLINE_START_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    lynx_start_underline();
		}
		break;
d13495 8
a13502 8
	    case LY_UNDERLINE_END_CHAR:
		if (dump_output_immediately && use_underscore) {
		    LYaddch('_');
		    i++;
		} else {
		    lynx_stop_underline();
		}
		break;
d13504 3
a13506 3
	    case LY_BOLD_START_CHAR:
		lynx_start_bold();
		break;
d13508 3
a13510 3
	    case LY_BOLD_END_CHAR:
		lynx_stop_bold ();
		break;
d13513 20
a13532 3
	    case LY_SOFT_NEWLINE:
		if (!dump_output_immediately)
		    LYaddch('+');
d13534 7
d13542 17
a13558 41
	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		    i++;
		}
		/* FALLTHRU */

	    default:
		i++;
		if (text->T.output_utf8 && is8bits(buffer[0])) {
		    utf_extra = utf8_length(text->T.output_utf8, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		    data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
d13560 1
d13562 1
d13566 7
a13572 9
		     *  For now, load 'M' into LastDisplayChar,
		     *  but we should check whether it's white
		     *  and if so, use ' '.  I don't know if
		     *  there actually are white CJK characters,
		     *  and we're loading ' ' for multibyte
		     *  spacing characters in this code set,
		     *  but this will become an issue when
		     *  the development code set's multibyte
		     *  character handling is used. -FM
a13574 3
		} else {
		    LYaddstr(buffer);
		    LastDisplayChar = buffer[0];
d13576 9
a13584 2
	} /* end of switch */
    } /* end of while */
d13591 2
a13592 3
    while (current_style < line->numstyles)
    {
	LynxChangeStyle (CStyle.style, CStyle.direction);
d13604 14
a13617 14
 *  Function move_to_glyph is called from LYMoveToLink and does all
 *  the real work for it.
 *  The pair LYMoveToLink()/move_to_glyph() is similar to the pair
 *  redraw_lines_of_link()/redraw_part_of_line(), some key differences:
 *   LYMoveToLink/move_to_glyph		redraw_*
 *   -----------------------------------------------------------------
 *   - used without color style         - used with color style
 *   - handles showing WHEREIS target	- WHEREIS handled elsewhere
 *   - handles only one line		- handles first two lines for
 *					  hypertext anchors
 *   - right columns position for UTF-8
 *     by redrawing as necessary
 *   - currently used for highlight	- currently used for highlight
 *     ON and OFF			  OFF
d13619 15
a13633 16
 *  Eventually the two sets of function should be unified, and should handle
 *  UTF-8 positioning, both lines of hypertext anchors, and WHEREIS in all
 *  cases.  If possible.  The complex WHEREIS target logic in highlight()
 *  could then be completely removed. - kw
 */
PRIVATE void move_to_glyph ARGS10(
	int,		YP,
	int,		XP,
	int,		XP_draw_min,
	char *,		data,
	int,		datasize,
	unsigned,	offset,
	CONST char *,	target,
	char *,		hightext,
	int,		flags,
	BOOL,		utf_flag)
a13634 1
    register int i;
d13636 1
a13636 1
    CONST char *end_of_data;
d13638 1
d13640 2
a13641 2
    CONST char *cp_tgt;
    int i_start_tgt=0, i_after_tgt;
d13644 10
a13653 4
    BOOL intarget = NO, inunderline = NO, inbold = NO;
    BOOL drawing = NO, inU = NO, hadutf8 = NO;
    BOOL incurlink = NO, drawingtarget = NO, flag = NO;
    char *sdata = data;
d13655 5
a13659 1
    int XP_link = XP;
d13662 4
a13665 1
    int	len;
d13674 2
a13675 2
     *  Add offset, making sure that we do not
     *  go over the COLS limit on the display.
d13677 11
a13687 5
    i = (int)offset;
    if (i > (int)DISPLAY_COLS - 1)
	i = (int)DISPLAY_COLS - 1;

    linkvlen = hightext ? LYmbcsstrlen(hightext, utf_flag, YES) : 0;
d13690 2
a13691 2
     *  Scan through the data, making sure that we do not
     *  go over the COLS limit on the display etc.
d13698 2
a13699 2
     *  If the target overlaps with the part of this line that
     *  we are drawing, it will be emphasized.
d13709 2
a13710 2
	    if ((int)offset + LenNeeded >= DISPLAY_COLS ||
		((int)offset + HitOffset >= XP + linkvlen)) {
a13721 1

d13723 5
a13727 5
     *  Iterate through the line data from the start, keeping track of
     *  the display ("glyph") position in i.  Drawing will be turned
     *  on when either the first UTF-8 sequence (that occurs after
     *  XP_draw_min) is found, or when we reach the link itself (if
     *  highlight is non-NULL). - kw
d13729 1
a13729 1
    while ((i < DISPLAY_COLS - 1) && data < end_of_data && (*data != '\0')) {
d13733 17
a13749 17
	/*
	 *  We reached the position of link itself, and hightext is
	 *  non-NULL.  We switch data from being a pointer into the HTLine
	 *  to being a pointer into hightext.  Normally (as long as this
	 *  routine is applied to normal hyperlink anchors) the text in
	 *  hightext will be identical to that part of the HTLine that
	 *  data was already pointing to, except that special attribute
	 *  chars LY_BOLD_START_CHAR etc. have been stripped out (see
	 *  HText_trimHightext).  So the switching should not result in
	 *  any different display, but it ensures that it doesn't go
	 *  unnoticed if somehow hightext got messed up somewhere else.
	 *  This is also useful in preparation for using this function
	 *  for something else than normal hyperlink anchors, i.e. form
	 *  fields.
	 *  Turn on drawing here or make sure it gets turned on before the
	 *  next actual normal character is handled. - kw
	 */
d13753 2
a13754 1
	    XP += linkvlen;	/* from now on XP includes hightext chars */
d13763 9
a13771 9
	     *  The logic of where to set intarget drawingtarget etc.
	     *  and when to react to it should be cleaned up (here and
	     *  further below).  For now this seems to work but isn't
	     *  very clear.  The complications arise from reproducing
	     *  the behavior (previously done in LYhighlight()) for target
	     *  strings that fall into or overlap a link: use target
	     *  emphasis for the target string, except for the first
	     *  and last character of the anchor text if the anchor is
	     *  highlighted as "current link". - kw
d13781 3
a13783 2
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
d13802 7
a13808 4
		    if (inunderline)	inU = YES;
		    if (inunderline)	lynx_stop_underline();
		    if (inbold)		lynx_stop_bold();
		    lynx_start_link_color (flag, inU);
d13813 1
a13813 1
	if (i >= XP || data >= end_of_data)
a13816 2


d13819 2
a13820 2
	 *  Look for a subsequent occurrence of the target string,
	 *  if we had a previous one and have now stepped past it. - kw
d13825 1
a13825 1
		if (incurlink && flag && i == XP - 1)
d13839 1
a13839 1
			if (flag && i_start_tgt == XP - 1)
d13841 3
a13843 3
			if (flag && i_after_tgt >= XP)
			    i_after_tgt = XP - 1;
			if (flag && i_start_tgt >= XP)
d13845 1
a13845 1
		    } else if (i_start_tgt == XP) {
d13857 1
a13857 1
				lynx_start_link_color (flag, inU);
d13861 4
a13864 2
			    if (inbold)		lynx_start_bold();
			    if (inunderline)	lynx_start_underline();
d13873 10
a13882 10
	 *  Advance data to point to the next input char (for the
	 *  next round).  Advance sdata, used for searching for a
	 *  target string, so that they stays in synch.  As long
	 *  as we are not within the highlight text, data and sdata
	 *  have identical values.  After we have switched data to
	 *  point into hightext, sdata remains a pointer into the
	 *  HTLine (so that we don't miss a partial target match at
	 *  the end of the anchor text).  So sdata has to sometimes
	 *  skip additional special attribute characters that are
	 *  not present in highlight in order to stay in synch. - kw
d13885 4
a13888 4
	if (*sdata) {
	    do sdata++;
		while (incurlink && *sdata && sdata != data &&
		       IsSpecialAttrChar(*(sdata-1)));
d13893 12
a13904 5
	    case LY_UNDERLINE_START_CHAR:
		if (!drawing || !incurlink) inunderline = YES;
		if (drawing && !intarget && !incurlink)
		    lynx_start_underline();
		break;
d13906 6
a13911 5
	    case LY_UNDERLINE_END_CHAR:
		inunderline = NO;
		if (drawing && !intarget && !incurlink)
		    lynx_stop_underline();
		break;
d13913 5
a13917 5
	    case LY_BOLD_START_CHAR:
		if (!drawing || !incurlink) inbold = YES;
		if (drawing && !intarget && !incurlink)
		    lynx_start_bold();
		break;
d13919 6
a13924 5
	    case LY_BOLD_END_CHAR:
		inbold = NO;
		if (drawing && !intarget && !incurlink)
		    lynx_stop_bold();
		break;
d13926 14
a13939 5
	    case LY_SOFT_NEWLINE:
		if (drawing) {
		    LYaddch('+');
		}
		i++;
d13941 1
a13941 25

	    case LY_SOFT_HYPHEN:
		if (*data != '\0' ||
		    isspace(UCH(LastDisplayChar)) ||
		    LastDisplayChar == '-') {
		    /*
		     *  Ignore the soft hyphen if it is not the last
		     *  character in the line.  Also ignore it if it
		     *  first character following the margin, or if it
		     *  is preceded by a white character (we loaded 'M'
		     *  into LastDisplayChar if it was a multibyte
		     *  character) or hyphen, though it should have
		     *  been excluded by HText_appendCharacter() or by
		     *  split_line() in those cases. -FM
		     */
		    break;
		} else {
		    /*
		     *  Make it a hard hyphen and fall through. -FM
		     */
		    buffer[0] = '-';
		}
		/* FALLTHRU */

	    default:
d13943 1
a13943 3
		 *  We have got an actual normal displayable character, or
		 *  the start of one.  Before proceeding check whether
		 *  drawing needs to be turned on now. - kw
d13945 10
d13956 12
a13967 13
		if (incurlink && intarget && flag && i_after_tgt > i) {
		    if (i == XP - 1) {
			i_after_tgt = i;
		    } else if (i == XP - 2 && HTCJK != NOCJK &&
			       is8bits(buffer[0])) {
			i_after_tgt = i;
			cp_tgt = NULL;
			if (drawing) {
			    if (drawingtarget) {
				LYstopTargetEmphasis();
				drawingtarget = NO;
				lynx_start_link_color (flag, inU);
			    }
d13971 18
a13988 29
		if (cp_tgt && i >= i_start_tgt && sdata > cp_tgt) {
		    if (!intarget ||
			(intarget && incurlink && !drawingtarget)) {

			if (incurlink && drawing &&
			    !(flag &&
			      (i == XP_link || i == XP - 1))) {
			    lynx_stop_link_color (flag, inU);
			}
			if (incurlink && !drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    if (flag && (i == XP_link || i == XP - 1)) {
				lynx_start_link_color (flag, inU);
				drawingtarget = NO;
			    } else {
				LYstartTargetEmphasis();
				drawingtarget = YES;
			    }
			    drawing = YES;
			} else if (incurlink && drawing &&
				   intarget && !drawingtarget &&
				   (flag &&
				    (i == XP_link))) {
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			} else if (drawing &&
				   !(flag &&
				     (i == XP_link || (incurlink && i == XP - 1)))) {
d13992 13
a14004 1
			intarget = YES;
d14006 3
a14008 1
		} else
d14010 9
a14018 8
		    if (incurlink) {
			if (!drawing) {
			    LYmove(YP, i);
			    if (inunderline)	inU = YES;
			    lynx_start_link_color (flag, inU);
			    drawing = YES;
			}
		    }
d14020 14
a14033 12
		i++;
		if (utf_flag && is8bits(buffer[0])) {
		    hadutf8 = YES;
		    utf_extra = utf8_length(utf_flag, data-1);
		    LastDisplayChar = 'M';
		}
		if (utf_extra) {
		    strncpy(&buffer[1], data, utf_extra);
		    buffer[utf_extra+1] = '\0';
		    if (!drawing && i >= XP_draw_min) {
			LYmove(YP, i - 1);
			drawing = YES;
d14035 4
a14038 4
			if (intarget) {
			    drawingtarget = YES;
			    LYstartTargetEmphasis();
			} else
d14040 5
a14044 6
			{
			    if (inbold)
				lynx_start_bold();
			    if (inunderline)
				lynx_start_underline();
			}
d14046 12
a14059 28
		    sdata += utf_extra; data += utf_extra;
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    /*
		     *  For CJK strings, by Masanobu Kimura.
		     */
		    if (drawing && (i < DISPLAY_COLS - 1)) {
			buffer[1] = *data;
			LYaddstr(buffer);
			buffer[1] = '\0';
		    }
		    i++;
		    sdata++; data++;
		    /*
		     * For now, load 'M' into LastDisplayChar, but we should
		     * check whether it's white and if so, use ' '.  I don't
		     * know if there actually are white CJK characters, and
		     * we're loading ' ' for multibyte spacing characters in
		     * this code set, but this will become an issue when the
		     * development code set's multibyte character handling is
		     * used.  -FM
		     */
		    LastDisplayChar = 'M';
		} else {
		    if (drawing) {
			LYaddstr(buffer);
		    }
		    LastDisplayChar = buffer[0];
d14061 21
a14081 2
	} /* end of switch */
    } /* end of while */
d14084 2
a14085 2
	LYmove(YP, i);
	lynx_start_link_color (flag, inU);
d14090 1
a14090 1
	    lynx_start_link_color (flag, inU);
d14103 21
a14123 22
 *  Move cursor position to a link's place in the display.
 *  The "moving to" is done by scanning through the line's
 *  character data in the corresponding HTLine of HTMainText,
 *  and starting to draw when a UTF-8 encoded non-ASCII character
 *  is encountered before the link (with some protection against
 *  overwriting form fields).  This refreshing of preceding data is
 *  necessary for preventing curses's or slang's display logic from
 *  getting too clever; their logic counts character positions wrong
 *  since they don't know about multi-byte characters that take up
 *  only one screen position.  So we have to make them forget their
 *  idea of what's in a screen line drawn previously.
 *  If hightext is non-NULL, it should be the anchor text for a normal
 *  link as stored in a links[] element, and the anchor text will be
 *  drawn too, with appropriate attributes. - kw
 */
PUBLIC void LYMoveToLink ARGS6(
	int,		cur,
	CONST char *,	target,
	char *,		hightext,
	int,		flag,
	BOOL,		inU,
	BOOL,		utf_flag)
d14126 2
a14127 2
    HTLine* todr;
    int i, n=0;
d14132 2
a14133 2
     *  We need to protect changed form text fields preceding this
     *  link on the same line against overwriting. - kw
d14135 1
a14135 1
    for (i = cur-1; i >= 0; i++) {
d14158 2
a14159 1
	if (target && *target == '\0') target = NULL;
a14167 1
	/* LYmove(links[cur].ly, links[cur].lx); */
d14173 2
a14174 2
 * This is used only if compiled with lss support.  It's called to draw regular
 * link (1st two lines of link) when it's being unhighlighted in LYhighlight().
d14176 2
a14177 2
PUBLIC void redraw_lines_of_link ARGS1(
	int,		cur GCC_UNUSED)
a14178 1
#ifdef USE_COLOR_STYLE
d14180 1
a14180 1
    HTLine* todr1;
d14183 1
a14183 1
    char *text;
d14186 3
a14188 3
    /* we are at the last page - that is partially filled */
	lines_back = HTMainText->Lines - ( links[cur].ly - pvtTITLE_HEIGHT+
	HTMainText->top_of_screen);
d14197 6
a14202 1
    for (count = 0; row <= display_lines && (text = LYGetHiliteStr(cur, count)) != NULL; ++count) {
d14205 1
a14205 1
	redraw_part_of_line (todr1, text, strlen(text), HTMainText);
a14208 3
#else
    /* no dead code !*/
#endif
d14211 1
d14214 1
a14214 1
PUBLIC void HTMark_asSource NOARGS
d14221 1
a14221 2
PUBLIC HTkcode HText_getKcode ARGS1(
	HText *,	text)
d14226 1
a14226 3
PUBLIC void HText_updateKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
d14231 1
a14231 2
PUBLIC HTkcode HText_getSpecifiedKcode ARGS1(
	HText *,	text)
d14236 1
a14236 3
PUBLIC void HText_updateSpecifiedKcode ARGS2(
	HText *,	text,
	HTkcode,	kcode)
d14241 1
a14241 1
PUBLIC int HTMainText_Get_UCLYhndl NOARGS
@


1.5
log
@Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>
@
text
@d9392 1
a9392 1
	    int newlen = strlen(HTCurSelectedOptionValue);
d9416 2
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d9592 2
a9593 2
    if (I->size != NULL) {
	f->size = atoi(I->size);
@


1.4.2.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@d9592 2
a9593 2
    if (I->size != 0) {
	f->size = I->size;
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d44 1
a44 9
#ifdef SH_EX	/* for DEBUG (1997/10/10 (Fri) 07:58:47) */
#define NOTUSED_BAD_FOR_SCREEN
#endif

#undef DEBUG_APPCH

#ifdef SOURCE_CACHE
#include <HTFile.h>
#endif
d93 1
d96 5
a104 2
extern BOOL HTPassHighCtrlRaw;

d138 1
a138 1
#ifdef SOURCE_CACHE
d144 1
a144 1
PUBLIC BOOLEAN LYsb = FALSE;
d150 25
a174 2
#if defined(USE_COLOR_STYLE)
#define MAX_STYLES_ON_LINE 64
d176 4
a179 6
    /*try to fit in 2 shorts*/
typedef struct _stylechange {
	unsigned int	direction:2;	/* on or off */
	unsigned int	horizpos: (sizeof(short)*CHAR_BIT-2);
	    /* horizontal position of this change */
	unsigned short	style;		/* which style to change to */
a180 1
#endif
a181 5
typedef struct _line {
	struct _line	*next;
	struct _line	*prev;
	unsigned	offset;		/* Implicit initial spaces */
	unsigned	size;		/* Number of characters */
d183 3
a185 2
	HTStyleChange* styles;
	int	numstyles;
a186 2
	char	data[1];		/* Space for terminator at least! */
} HTLine;
d188 9
a196 11
#if defined(USE_COLOR_STYLE)
typedef struct _HTStyleChangePool {
	HTStyleChange	data[4092];
	struct _HTStyleChangePool* next;
	int free_items;
} HTStyleChangePool;

/*these are used when current line is being aggregated. */
HTStyleChange stylechanges_buffers[2][MAX_STYLES_ON_LINE];
int stylechanges_buffers_free;/*this is an index of the free buffer.
    Can be 0 or 1*/
d198 3
a200 2
/* These are generic macors for any pools (provided those structures have the
same members as HTStyleChangePool).  Pools are used for allocation of groups of
d204 2
a205 2
pointer to the next pool chunk named 'pool', and the number of free items in
that pool chunk named 'free_items'.  Here is a definition of the structure P:
d209 2
a210 2
	    struct P* next;
	    int free_items;
d214 2
a215 2
 Allocation of 'n' items in the pool is implemented by decrementing member
'free_items' by 'n' if 'free_items' >= 'n', or allocating a new pool chunk and
d226 91
d318 22
a339 75
 Pool are referenced by pointer to the chunk that contains free slots. Macros
that allocate memory in pools update that pointer if needed.
 There are 3 macros that deal with pools - POOL_NEW, POOL_FREE and
ALLOC_IN_POOL.
 Here is a description of those macros as C++ functions (with names mentioned
above and with use of C++ references)

void ALLOC_IN_POOL( P*& pool, pool_type, int toalloc, T*& ptr)
    - allocates 'toalloc' items in the pool of type 'pool_type' pointed by
    'pool', sets the pointer 'ptr' to the "allocated" memory and updates 'pool'
    if necessary. Sets 'ptr' to NULL if fails.

void POOL_NEW( pool_type  , P*& ptr)
    Initializes a pool of type 'pool_type' pointed by 'ptr', updating 'ptr'.
    Sets 'ptr' to NULL if fails.

void POOL_FREE( pool_type , P* ptr)
    Frees a pool of type 'pool_type' pointed by ptr.

      - VH */

/*
void ALLOC_IN_POOL( P*& pool, pool_type, int toalloc, T*& ptr)
    - allocates 'toalloc' items in the pool of type 'pool_type' pointed by
    'pool', sets the pointer 'ptr' to the "allocated" memory and updates 'pool'
    if necessary. Sets 'ptr' to NULL if fails.
*/
#define ALLOC_IN_POOL(pool,pool_type,toalloc,ptr)     \
if (!pool)  \
    ptr = NULL; \
else { \
    if ((pool)->free_items > toalloc) { \
	(pool)->free_items -= toalloc; \
	ptr = (pool)->data + (pool)->free_items; \
    } else { \
	pool_type* newpool = (pool_type*)malloc(sizeof(pool_type)); \
	if (!newpool) { \
	    ptr = NULL; \
	} else { \
	    newpool->next = pool; \
	    newpool->free_items = sizeof newpool->data/ \
		    sizeof newpool->data[0] - toalloc; \
	    pool = newpool; \
	    ptr = newpool->data + sizeof newpool->data/sizeof newpool->data[0] - toalloc; \
	} \
    } \
}
/*
void POOL_NEW( pool_type  , P*& ptr)
    Initializes a pool of type 'pool_type' pointed by 'ptr', updating 'ptr'.
    Sets 'ptr' to NULL if fails.
*/
#define POOL_NEW(pool_type,ptr) \
    { \
	pool_type* newpool = (pool_type*)malloc(sizeof(pool_type)); \
	if (!newpool) { \
	    ptr = NULL; \
	} else { \
	    newpool->next = NULL; \
	    newpool->free_items = sizeof newpool->data/sizeof newpool->data[0]; \
	    ptr = newpool; \
	} \
    }
/*
void POOL_FREE( pool_type , P* ptr)
    Frees a pool of type 'pool_type' pointed by ptr.
*/
#define POOL_FREE(pool_type,xptr) \
    { \
	pool_type* ptr = xptr; \
	do { \
	    pool_type* prevpool = ptr; \
	    ptr = ptr->next; \
	    FREE(prevpool); \
	} while (ptr); \
d341 3
d346 13
a358 2
#define LINE_SIZE(l) (sizeof(HTLine)+(l))	/* Allow for terminator */
#define allocHTLine(l) (HTLine *)calloc(1, LINE_SIZE(l))
a363 2
	int			line_pos;	/* Bytes/chars - extent too */
	int			extent;		/* (see HText_trimHightext) */
d365 2
a366 5
	char *			hightext;	/* The link text */
	char *			hightext2;	/* A second line*/
	int			hightext2offset;/* offset from left */
	int			link_type;	/* Normal, internal, or form? */
	FormInfo *		input_field;	/* Info for form links */
d370 4
d377 1
a377 1
typedef struct _HTTabID {
d390 1
a390 16
#ifdef SOURCE_CACHE
	/*
	 * Parse settings when this HText was generated.
	 */
	BOOLEAN			clickable_images;
	BOOLEAN			pseudo_inline_alts;
	BOOLEAN			verbose_img;
	BOOLEAN			raw_mode;
	BOOLEAN			historical_comments;
	BOOLEAN			minimal_comments;
	BOOLEAN			soft_dquotes;
	int			old_dtd;
	int			keypad_mode;
	int			disp_lines;	/* Screen size */
	int			disp_cols;	/* Used for reports only */
#endif
d392 1
d394 1
a394 1
	TextAnchor *		first_anchor;	/* Singly linked list */
d397 1
d426 1
d442 8
a449 8
				state;			/* Escape sequence? */
	int			kanji_buf;		/* Lead multibyte */
	int			in_sjis;		/* SJIS flag */
	int			halted;			/* emergency halt */

	BOOL			have_8bit_chars;   /* Any non-ASCII chars? */
	LYUCcharset *		UCI;		   /* node_anchor UCInfo */
	int			UCLYhndl;	   /* charset we are fed */
d452 20
a471 4
	HTStream *		target;			/* Output stream */
	HTStreamClass		targetClass;		/* Output routines */
#if defined(USE_COLOR_STYLE)
	HTStyleChangePool*	styles_pool;
d475 8
d502 1
a502 1
typedef struct ht_run_info_ {
a545 2
#else
#define last_anchor_of_previous_line (TextAnchor*)0
d567 5
d574 1
a574 1
	{ 0,  "(Unstyled)", "",
d586 6
a596 5
#ifndef VMS			/* VMS has a better way - right? - kw */
#define CHECK_FREE_MEM
#endif


d664 1
a664 4
	HText * t = HTList_objectAt(loaded_texts, i);
	if (t == HTMainText)
	    t = NULL;		/* shouldn't happen */
	{
a672 1
	}
d698 108
a805 1
#define LY_CALLOC LY_check_calloc
d807 9
a815 1
#else  /* CHECK_FREE_MEM */
d817 9
a825 2
  /* using the regular calloc */
#define LY_CALLOC calloc
d827 11
a837 1
#endif /* CHECK_FREE_MEM */
d863 48
d969 1
a969 2
     *  HTuncache_current_document(), e.g., for the showinfo, options,
     *  download, print, etc., temporary file URLs, so we'll check now
d975 2
d998 2
a999 2
    line = self->last_line = allocHTLine(MAX_LINE);
    if (line == NULL)
d1001 2
d1005 1
a1007 4
    POOL_NEW(HTStyleChangePool,self->styles_pool);
    if (!self->styles_pool)
	outofmem(__FILE__, "HText_New");
    stylechanges_buffers_free = 0;
d1012 1
d1020 1
a1020 1
#ifdef SOURCE_CACHE
d1052 4
a1055 2
    self->no_cache = ((anchor->no_cache || anchor->post_data) ?
							  YES : NO);
d1096 1
a1096 1
     *  Check the kcode setting if the anchor has a charset element. - FM
d1109 1
a1109 1
	 *  Create an array of dots for the UNDERSCORES macro. - FM
d1115 1
a1115 1
	 *  Create an array of underscores for the STARS macro. - FM
d1179 6
a1184 9
    HTAnchor_setDocument(self->node_anchor, (HyperDoc *)0);
#if defined(USE_COLOR_STYLE)
    POOL_FREE(HTStyleChangePool,self->styles_pool);
#endif
    while (YES) {	/* Free off line array */
	HTLine * l = self->last_line;
	if (l) {
	    l->next->prev = l->prev;
	    l->prev->next = l->next;	/* Unlink l */
d1186 2
a1187 9
	    if (l != self->last_line) {
		FREE(l);
	    } else {
		free(l);
	    }
	}
	if (l == self->last_line) {	/* empty */
	    l = self->last_line = NULL;
	    break;
d1189 1
d1191 1
d1198 1
a1198 45
	    /*
	     *  Free form fields.
	     */
	    if (l->input_field->type == F_OPTION_LIST_TYPE &&
		l->input_field->select_list != NULL) {
		/*
		 *  Free off option lists if present.
		 *  It should always be present for F_OPTION_LIST_TYPE
		 *  unless we had invalid markup which prevented
		 *  HText_setLastOptionValue from finishing its job
		 *  and left the input field in an insane state. - kw
		 */
		OptionType *optptr = l->input_field->select_list;
		OptionType *tmp;
		while (optptr) {
		    tmp = optptr;
		    optptr = tmp->next;
		    FREE(tmp->name);
		    FREE(tmp->cp_submit_value);
		    FREE(tmp);
		}
		l->input_field->select_list = NULL;
		/*
		 *  Don't free the value field on option
		 *  lists since it points to a option value
		 *  same for orig value.
		 */
		l->input_field->value = NULL;
		l->input_field->orig_value = NULL;
		l->input_field->cp_submit_value = NULL;
		l->input_field->orig_submit_value = NULL;
	    } else {
		FREE(l->input_field->value);
		FREE(l->input_field->orig_value);
		FREE(l->input_field->cp_submit_value);
		FREE(l->input_field->orig_submit_value);
	    }
	    FREE(l->input_field->name);
	    FREE(l->input_field->submit_action);
	    FREE(l->input_field->submit_enctype);
	    FREE(l->input_field->submit_title);

	    FREE(l->input_field->accept_cs);

	    FREE(l->input_field);
d1201 1
a1201 4
	FREE(l->hightext);
	FREE(l->hightext2);

	FREE(l);
d1206 1
a1206 1
     *  Free the tabs list. - FM
d1221 1
a1221 1
     *  Free the hidden links list. - FM
d1235 1
a1235 1
     *  if it is not a destination of other links. - FM
d1242 1
a1242 1
#ifdef SOURCE_CACHE
d1251 6
a1256 1
	if (HTAnchor_delete(self->node_anchor))
d1264 1
d1303 1
a1303 1
#ifndef NCURSES_VERSION
d1387 2
a1388 2
		    if (inbold)		start_bold();
		    if (inunderline)	start_underline();
d1403 1
a1403 1
	    LynxChangeStyle (CStyle.style,CStyle.direction);
d1417 1
a1417 1
#if (defined(DOSPATH) || defined(WIN_EX)) && !defined(USE_SLANG)
d1419 1
a1419 1
			    start_bold();
d1421 1
a1421 1
			    start_underline();
d1423 2
a1424 2
			start_underline();
#endif	/* DOSPATH ... */
d1436 1
a1436 1
#if (defined(DOSPATH) || defined(WIN_EX)) && !defined(USE_SLANG)
d1438 1
a1438 1
			stop_bold();
d1440 1
a1440 1
			stop_underline();
d1442 2
a1443 2
		    stop_underline();
#endif	/* DOSPATH ... */
d1451 1
a1451 1
		    start_bold();
d1457 1
a1457 1
		    stop_bold();
d1465 3
d1483 1
a1483 1
		     *  split_line() in those cases. - FM
d1488 1
a1488 1
		     *  Make it a hard hyphen and fall through. - FM
d1509 1
a1509 1
		if (text->T.output_utf8 && !isascii(UCH(buffer[0]))) {
d1511 1
a1511 22
		    if ((*buffer & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*buffer & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*buffer & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*buffer & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*buffer & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			 /*
			  *  Garbage.
			  */
			utf_extra = 0;
		    }
		    if (strlen(data) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
d1521 1
a1521 1
		} else if (HTCJK != NOCJK && !isascii(UCH(buffer[0]))
d1546 1
a1546 1
		     *  character handling is used. - FM
d1557 1
a1557 1
#if !defined(NCURSES_VERSION)
d1575 2
a1576 2
    stop_underline();
    stop_bold();
d1602 1
a1602 1
     *  Make sure we have a text structure. - FM
d1618 1
a1618 1
     *  Load the title field. - FM
d1627 1
a1627 1
     *  any trailing spaces. - FM
d1672 1
a1672 1
     *  and truncated if necessary. - FM & KW
d1723 2
a1724 3
	 *  Note that this truncation is not taking into
	 *  account the possibility that multibyte
	 *  characters might be present. - FM
a1725 1
#ifdef SH_EX	/* 1999/06/15 (Tue) 10:17:28 */
a1734 4
#else
	if ((i = ((limit - 2) - strlen(percent)) - CHAR_WIDTH) >= 0)
	    title[i] = '\0';
#endif
d1743 10
d1775 1
a1775 1
    if (!LYsb || !text || h <= 2
d1846 1
a1846 1
	if (i > top_skip && i <= h - bot_skip)
d1848 1
a1848 1
	else
d1850 1
d1878 1
d1942 1
d2093 1
a2093 1
	     *  seek and emphasize it. - FM
d2097 1
a2097 1
	    while ((target && *target) &&
d2140 1
a2140 24
			if (text->T.output_utf8 && !isascii(UCH(tmp[0]))) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&line->data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
d2149 1
a2149 1
			} else if (HTCJK != NOCJK && !isascii(UCH(tmp[0]))) {
d2167 1
a2167 1
		 *  line. - FM
d2176 1
a2176 1
		 *  in it. - FM
d2185 1
a2185 1
	     *  display_flag is set and process the next line. - FM
d2218 7
a2224 3
    for (Anchor_ptr=text->first_anchor;  Anchor_ptr != NULL &&
		Anchor_ptr->line_num <= stop_before_for_anchors;
					    Anchor_ptr = Anchor_ptr->next) {
a2225 2
	if (Anchor_ptr->line_num >= line_number &&
		Anchor_ptr->line_num < stop_before_for_anchors) {
d2229 16
a2244 7
	    if (Anchor_ptr->show_anchor && Anchor_ptr->hightext &&
			strlen(Anchor_ptr->hightext) > 0 &&
			(Anchor_ptr->link_type & HYPERTEXT_ANCHOR)) {

		links[nlinks].hightext	= Anchor_ptr->hightext;
		links[nlinks].hightext2 = Anchor_ptr->hightext2;
		links[nlinks].hightext2_offset = Anchor_ptr->hightext2offset;
d2250 1
a2250 2
		link_dest = HTAnchor_followMainLink(
					     (HTAnchor *)Anchor_ptr->anchor);
d2263 1
a2263 1
				(HTAnchor *)Anchor_ptr->anchor, LINK_INTERNAL);
d2295 1
a2295 1
		links[nlinks].form = NULL;
d2301 1
a2301 1
			&& Anchor_ptr->input_field->type != F_HIDDEN_TYPE) {
d2312 1
a2312 1
		links[nlinks].form = FormInfo_ptr;
d2321 4
a2324 5
		    if (FormInfo_ptr->num_value)
			links[nlinks].hightext = checked_radio;
		    else
			links[nlinks].hightext = unchecked_radio;

d2326 4
a2329 5
		    if (FormInfo_ptr->num_value)
			links[nlinks].hightext = checked_box;
		    else
			links[nlinks].hightext = unchecked_box;

d2331 2
a2332 2
		    links[nlinks].hightext = STARS(strlen(FormInfo_ptr->value));

d2334 2
a2335 1
		    links[nlinks].hightext = FormInfo_ptr->value;
a2337 6
		/*
		 *  Never a second line on form types.
		 */
		links[nlinks].hightext2 = NULL;
		links[nlinks].hightext2_offset = 0;

d2342 1
a2342 1
		highlight(OFF, (nlinks - 1), target);
d2350 1
a2350 1
		if (Anchor_ptr->hightext && *Anchor_ptr->hightext)
d2353 1
a2353 1
			    Anchor_ptr->hightext));
a2356 6
	if (Anchor_ptr == text->last_anchor)
	    /*
	     *  No more links in document. - FM
	     */
	    break;

d2360 1
a2360 1
	     *  to use half-page or two-line scrolling. - FM
d2372 1
a2372 1
     *  from the previous page draw. - FM
d2374 2
a2375 1
    for (i = nlinks; i < last_nlinks; i++)
d2377 1
d2412 1
d2430 2
d2461 4
a2464 1
#define LYcols_cu (dump_output_immediately ? MAX_COLS : SLtt_Screen_Cols)
d2466 2
a2467 1
#define LYcols_cu (dump_output_immediately ? MAX_COLS : DISPLAY_COLS)
d2519 1
a2519 1
    TextAnchor **,	prev_anchor,
d2526 4
a2529 6
     *  Update anchor positions for anchors that start on this line.
     *  Note: we rely on a->line_pos counting bytes, not
     *  characters.  That's one reason why HText_trimHightext
     *  has to be prevented from acting on these anchors in
     *  partial display mode before we get a chance to
     *  deal with them here.
d2534 5
a2538 4
    /* We need to know whether (*prev_anchor)->line_pos is "in new
       coordinates" or in old ones.  If prev_anchor' head was touched
       on the previous iteraction, we set head_processed.  The tail
       may need to be treated now. */
d2585 1
a2585 1
 *  here if needed.
d2595 1
a2595 1
    TextAnchor *,	prev_anchor,
d2622 8
a2629 4
    if (line == text->last_line)
	mod_line = allocHTLine(MAX_LINE);
    else
	mod_line = allocHTLine(line->size + added_chars);
d2632 4
a2635 4
    if (!prev_anchor)
	prev_anchor = text->first_anchor;
    head_processed = (prev_anchor && prev_anchor->line_num < line_number);
    memcpy(mod_line, line, LINE_SIZE(1));
d2643 3
a2645 1
		      : (line->size <= MAX_LINE ? MAX_LINE+1 : line->size+1));
d2665 1
a2665 1
	    move_anchors_in_region(line, line_number, &prev_anchor,
d2693 2
a2694 2
    if (head_processed && prev_anchor && prev_anchor->line_num == line_number)
	prev_anchor->extent += shift;
a2735 1
    HTLine * temp;
a2746 1
    HTLine * previous = text->last_line;
d2748 1
a2748 1
    int utfxtra_on_previous_line = utfxtra_on_this_line;
d2750 3
a2752 2
    /* can't wrap in middle of multibyte sequences, so allocate 2 extra */
    HTLine * line = (HTLine *)LY_CALLOC(1, LINE_SIZE(MAX_LINE)+2);
d2755 1
a2755 1
     *  Make new line.
d2757 4
d2762 3
a2764 1
	outofmem(__FILE__, "split_line_1");
d2853 1
a2853 1
	/* Split the line. - FM */
d2859 1
a2859 1
	 *  of our new line. - FM
d2889 1
a2889 1
		    p[i] == LY_SOFT_HYPHEN)
d2891 1
a2891 1
		else if (IS_UTF_EXTRA(p[i]))
d2893 1
d2899 1
a2899 1
	    /* Add the data to the new line. - FM */
d2956 4
a2959 1
    line->styles = stylechanges_buffers[stylechanges_buffers_free = (stylechanges_buffers_free + 1) &1];
d3023 1
a3023 1
		     && to[1].horizpos <= SpecialAttrChars
d3053 4
a3056 2
    temp = (HTLine *)LY_CALLOC(1, LINE_SIZE(previous->size));
    if (temp == NULL)
d3060 1
a3060 2
    ALLOC_IN_POOL((text->styles_pool),HTStyleChangePool,previous->numstyles,temp->styles);
    memcpy(temp->styles, previous->styles, sizeof(HTStyleChange)*previous->numstyles);
d3063 1
a3064 1
    FREE(previous);
d3066 1
d3093 1
a3093 1
		*cp == LY_SOFT_HYPHEN)
d3095 1
d3110 1
a3110 1
	    utfxtra_on_previous_line -= utfxtra_on_this_line;
d3112 1
a3112 1
		int spare_cu = (LYcols_cu-1) -
d3131 1
a3131 1
			    + utfxtra_on_previous_line <= (LYcols_cu - 1))
d3190 1
a3190 1
     *  structure values for the new line. - FM
a3193 1
	TextAnchor * prev_a = NULL;
d3205 4
a3208 1
	for (a = text->first_anchor; a; prev_a = a, a = a->next) {
d3213 2
d3228 1
a3228 1
			a->extent += -(TailTrim + HeadTrim) - SpecialAttrChars;
d3309 2
a3310 16
	    if (text->T.output_utf8 && !isascii(UCH(c))) {
		int utf_extra = 0;
		if ((c & 0xe0) == 0xc0) {
		    utf_extra = 1;
		} else if ((c & 0xf0) == 0xe0) {
		    utf_extra = 2;
		} else if ((c & 0xf8) == 0xf0) {
		    utf_extra = 3;
		} else if ((c & 0xfc) == 0xf8) {
		    utf_extra = 4;
		} else if ((c & 0xfe) == 0xfc) {
		    utf_extra = 5;
		} else
		    utf_extra = 0;
		if ( (int) strlen(jp+1) < utf_extra)
		    utf_extra = 0;
d3341 1
a3341 1
					  last_anchor_of_previous_line,
d3349 1
a3349 1
	    FREE(previous);
a3353 2
	    /* keep maintaining 'last_anchor_of_previous_line' */
	    TextAnchor* a2 = last_anchor_of_previous_line;
a3358 11

	    if (!a2)
		a2 = text->first_anchor;
	    else if (a2 == text->last_anchor)
		a2 = NULL;
	    else
		a2 = a2->next; /* 1st anchor on line we justify */

	    if (a2)
		for (; a2 && a2->line_num <= text->Lines-1;
		    last_anchor_of_previous_line = a2, a2 = a2->next);
d3410 1
a3410 3
    BOOL IgnoreSpaces = FALSE;

    if (!HText_LastLineSize(text, IgnoreSpaces)) { /* No text on current line */
d3419 3
a3421 2
	while ((line != text->last_line) &&
	       (HText_TrueLineSize(line, text, IgnoreSpaces) == 0)) {
d3483 3
a3485 1
    int indent, utfx;
d3542 3
a3544 3
	    if (ch < 0x80) {
		CTRACE((tfp, "add(%c) %d/%d\n", ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3546 2
a3547 2
		CTRACE((tfp, "add(%02x) %d/%d\n", ch,
		    HTisDocumentSource(), HTOutputFormat != WWW_SOURCE));
d3692 1
a3692 1
    if (UCH(ch) >= 128 && HTCJK == NOCJK &&
d3694 1
a3694 1
	UCH(ch) < LYlowest_eightbit[current_char_set])
d3696 1
a3710 1
    utfx = utfxtra_on_this_line;
d3718 1
a3718 1
		    **  Takuya ASADA's (asada@@three-a.co.jp) CJK Lynx). - FM
d3776 1
a3776 1
		     *  Can split here. - FM
d3784 1
a3784 1
		     *  Can split here. - FM
d3870 1
a3870 1
		     *  Can split here. - FM
d3894 1
a3894 1
	if (line->size >= (MAX_LINE-1))
d3896 1
d3932 1
a3932 1
	     *  hyphen. - FM
d3934 1
a3934 1
	    if (line->size < 1 || text->permissible_split >= line->size)
d3936 1
d3953 3
a3955 2
	 else
	     return;
d3975 5
a3979 4
		|| (indent + (int)(line->offset + line->size) +
		    utfxtra_on_this_line - ctrl_chars_on_this_line +
		    ((line->size > 0) &&
		     (int)(line->data[line->size-1] ==
d3981 1
a3981 1
					     1 : 0)) >= (LYcols_cu-1))
d3997 1
a3997 1
		    + utfxtra_on_this_line == 0)
d4020 1
a4020 1
		    + utfxtra_on_this_line == 0)
d4030 9
a4038 9
	    new_line(text);
	    text->in_line_1 = YES;	/* First line of new paragraph */
	    /*
	     *  There are some pages written in
	     *  different kanji codes. - TA & kw
	     */
	    if (HTCJK == JAPANESE)
		text->kcode = NOKANJI;
	    return;
a4073 1

d4085 1
a4085 1
	     *  if one does, we'll dump the soft hyphen. - FM
d4092 1
a4092 1
	here_cu = here + utfxtra_on_this_line;
d4130 1
a4130 1
	     *  Can split here. - FM
d4155 1
a4155 1
	int target_cu = target + utfxtra_on_this_line;
d4159 1
a4159 2
	     target_cu + UTF_XLEN(ch) >= (LYcols_cu-1))
	    ) {
d4178 1
a4178 1
	 *  Can split here. - FM
d4192 26
a4217 6
    if (text->IgnoreExcess &&
	(((indent + (int)line->offset + (int)line->size) +
	  (int)style->rightIndent - ctrl_chars_on_this_line) >= (WRAP_COLS(text)-1) ||
	 ((indent + (int)line->offset + (int)line->size) +
	  utfxtra_on_this_line - ctrl_chars_on_this_line) >= (LYcols_cu-1)))
	return;
d4222 9
a4230 1
    if (((indent + (int)line->offset + (int)line->size) +
d4232 5
a4236 13
	 (((HTCJK != NOCJK) && text->kanji_buf) ? 1 : 0) +
	 ((line->size > 0) &&
	  (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0))) >= (WRAP_COLS(text) - 1) ||
	(text->T.output_utf8 &&
	 (((indent + (int)line->offset + (int)line->size) +
	   utfxtra_on_this_line - ctrl_chars_on_this_line +
	   UTF_XLEN(ch) +
	   ((line->size > 0) &&
	    (int)(line->data[line->size-1] ==
				LY_SOFT_HYPHEN ?
					     1 : 0))) >= (LYcols_cu - 1)))) {
d4244 3
a4246 1
	    if (ch == ' ') return;	/* Ignore space causing split */
d4248 18
a4265 8
	}  else if (HTOutputFormat == WWW_SOURCE) {
		 /*
		  *  For source output we don't want to wrap this stuff
		  *  unless absolutely necessary. - LJM
		  *  !
		  *  If we don't wrap here we might get a segmentation fault.
		  *  but let's see what happens
		  */
a4266 13
		   new_line(text);  /* try not to linewrap */
		}
	} else {
		/*
		 *  For normal stuff like pre let's go ahead and
		 *  wrap so the user can see all of the text.
		 */

		if ( (dump_output_immediately|| (crawl && traversal) )
		     && dont_wrap_pre) {
		    if ((int)line->size >= (int)(MAX_LINE-1))
			new_line(text);
		} else {
d4269 3
a4271 1

d4417 1
a4417 1
	     *  Can split here. - FM
d4443 1
a4443 1
	    line->styles[line->numstyles-1].style == style &&
d4575 1
a4575 1
	    if (line->size == 0 || !HText_TrueLineSize(line, me, FALSE))
d4604 1
a4604 1
					 me->last_anchor_before_stbl,
d4617 1
a4617 1
	    free(line);
d4820 19
d4850 1
d4854 1
d4857 1
d4868 1
d4873 15
a4887 2
    } else
#endif
d4889 1
a4889 4
#ifdef EXP_NESTED_TABLES
    if (nested_tables)
	me->stbl = enclosing;
    else
d4891 4
a4894 1
    me->stbl = NULL;
d5004 27
d5039 1
a5039 3
    char marker[32];

    TextAnchor * a = typecalloc(TextAnchor);
d5041 1
a5043 2
    a->hightext  = NULL;
    a->hightext2 = NULL;
d5060 1
a5060 1
    if (HTAnchor_followTypedLink((HTAnchor*)anc, LINK_INTERNAL)) {
d5065 1
a5065 1
    if (HTAnchor_followMainLink((HTAnchor*)anc)) {
d5071 2
a5072 19
    /*
     *  If we are doing link_numbering add the link number.
     */
    if ((a->number > 0) &&
#ifdef USE_PRETTYSRC
	(text->source ? !psrcview_no_anchor_numbering : 1 ) &&
#endif
	(keypad_mode == LINKS_ARE_NUMBERED ||
	 keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)) {
	char saved_lastchar = text->LastChar;
	int saved_linenum = text->Lines;
	sprintf(marker,"[%d]", a->number);
	HText_appendText(text, marker);
	if (saved_linenum && text->Lines && saved_lastchar != ' ')
	    text->LastChar = ']'; /* if marker not after space caused split */
	a->line_num = text->Lines;
	a->line_pos = text->last_line->size;
    }

d5092 1
a5092 1
     *  within which that link might be embedded. - FM
d5106 1
a5106 1
	     *  and cross our fingers. - FM
d5123 1
d5130 1
a5130 2
	    ((keypad_mode == LINKS_ARE_NUMBERED ||
	      keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) &&
d5135 1
a5135 1
		   HTAnchor_followMainLink((HTAnchor *)a->anchor))))));
d5157 1
a5157 1
	 *  with the content on the last line. - FM
d5163 1
a5163 1
	     *  so set up to check the entire last line. - FM
d5169 1
a5169 1
	     *  so check from the start of the anchor. - FM
d5189 1
a5189 1
		 *  of the last line as blank. - FM
d5196 1
a5196 1
		 *  declare the anchor's extent as blank. - FM
d5207 1
a5207 1
	 *  white and special characters. - FM
d5221 1
a5221 1
		 *  so check all of this line. - FM
d5227 1
a5227 1
		 *  The anchor starts on this line. - FM
d5251 1
a5251 1
		     *  the line to be analyzed. - FM
d5260 1
a5260 1
		     *  declare the anchor's extent as blank. - FM
d5275 1
a5275 1
	     *  USEMAP. - FM
d5286 1
a5286 1
	     *  numbered bracket and adjust the anchor count. - FM
d5303 1
a5303 1
		 *  anchor start. - FM
d5307 1
a5307 1
		     *  The anchor starts on the last line. - FM
d5312 1
a5312 1
		     *  The anchor starts on a previous line. - FM
d5328 1
a5328 1
		 *  from that line. - FM
d5344 1
a5344 1
			 *  on this line. - FM
d5359 1
a5359 1
			    anc->line_pos -= NumSize;
d5385 1
a5385 1
			     *  wrapped to this line. - FM
d5418 1
a5418 1
			     *  numbered bracket. - FM
d5425 1
a5425 1
			 *  numbered bracket. - FM
d5455 1
a5455 1
			     *  was wrapped to the last line. - FM
d5468 1
a5468 1
			     *  numbered bracket. - FM
d5475 1
a5475 1
			 *  numbered bracket. - FM
d5482 1
a5482 1
		     *  numbered bracket. - FM
d5488 2
d5493 1
a5493 1
	     *  as a link. - FM
d5509 1
a5509 1
	     *  to the hidden links list. - FM
d5522 1
a5522 1
	     *  blank lines we've detected. - FM
d5540 1
a5540 1
	 *  link. - FM
d5599 1
a5599 2
	   *buf = *cp,
	   buf++;
d5664 1
a5664 1
	FREE(text->last_line);
d5673 1
a5673 1
     *  create the hightext strings. - FM
d5694 7
a5700 6
**  AFTER the adjustment, the anchor line_pos (and hightext2offset
**  if applicable) fields indicate x positions in terms of displayed
**  character cells, and the extent field apparently is unimportant;
**  the anchor text has been copied to the hightext (and possibly
**  hightext2) fields (which should have been NULL up to that point),
**  with special attribute chars removed.
d5713 1
d5715 4
d5741 1
a5741 1
     *  create the hightext strings. - FM
d5744 2
a5745 2
	anchor_ptr;
	prev_a = anchor_ptr, anchor_ptr=anchor_ptr->next) {
d5783 1
a5783 1
	if (anchor_ptr->hightext)
d5819 6
a5824 5
	 *  If the link begins with an end of line and we have more
	 *  lines, then start the highlighting on the next line. - FM
	 *  But if an empty anchor is at the end of line and empty,
	 *  keep it where it is, unless the previous anchor in the list
	 *  (if any) already starts later. - kw
d5842 1
a5842 1
	 *  Copy the link name into the data structure.
d5844 10
a5853 5
	if (line_ptr->data &&
	    anchor_ptr->extent > 0 && anchor_ptr->line_pos >= 0) {
	    StrnAllocCopy(anchor_ptr->hightext,
			  &line_ptr->data[anchor_ptr->line_pos],
			  anchor_ptr->extent);
d5855 2
a5856 1
	    StrAllocCopy(anchor_ptr->hightext, "");
d5860 2
a5861 2
	 *  If true the anchor extends over two lines,
	 *  copy that into the data structure.
d5863 8
a5870 2
	if ((unsigned)anchor_ptr->extent > strlen(anchor_ptr->hightext)) {
	    HTLine *line_ptr2 = line_ptr->next;
d5872 9
a5880 5
	    if (!final) {
		if (cur_line + 1 >= stop_before) {
		    FREE(anchor_ptr->hightext); /* bail out */
		    break;
		}
d5882 1
d5884 2
a5885 2
	     *  Double check that we have a line pointer,
	     *  and if so, copy into hightext2.
d5887 6
a5892 2
	    if (line_ptr2) {
		StrnAllocCopy(anchor_ptr->hightext2,
d5894 2
a5895 3
			      (anchor_ptr->extent -
			       strlen(anchor_ptr->hightext)));
		anchor_ptr->hightext2offset = line_ptr2->offset;
d5897 1
a5897 2
		anchor_ptr->hightext2offset +=
			remove_special_attr_chars(anchor_ptr->hightext2);
d5900 4
a5903 5
		    LYTrimTrailing(anchor_ptr->hightext2);
		    if (anchor_ptr->hightext2[0] == '\0') {
			FREE(anchor_ptr->hightext2);
			anchor_ptr->hightext2offset = 0;
		    }
d5905 1
d5908 8
a5915 1
	remove_special_attr_chars(anchor_ptr->hightext);
d5917 1
a5917 1
	    LYTrimTrailing(anchor_ptr->hightext);
d5921 1
a5921 2
	 *  Subtract any formatting characters from the x position
	 *  of the link.
a5946 6

	/*
	 *  If this is the last anchor, we're done!
	 */
	if (anchor_ptr == text->last_anchor)
	    break;
d5962 1
d5964 2
a5965 2
 *  HTChildAnchor() returns the anchor with index N.
 *  The index corresponds to the [number] we print for the anchor.
d5967 3
a5969 2
PUBLIC HTChildAnchor * HText_childNumber ARGS1(
	int,		number)
d5971 2
a5972 1
    TextAnchor * a;
d5974 1
a5974 1
    if (!(HTMainText && HTMainText->first_anchor) || number <= 0)
d5976 8
d5985 4
a5988 5
    for (a = HTMainText->first_anchor; a; a = a->next) {
	if (a->number == number)
	    return(a->anchor);
    }
    return (HTChildAnchor *)0;	/* Fail */
d5994 1
a5994 1
 *  for the field. - FM & LE
d6267 2
a6268 2
		*hightext= a->hightext;
		link_dest = HTAnchor_followMainLink((HTAnchor *)a->anchor);
d6277 1
a6277 1
				(HTAnchor *)a->anchor, LINK_INTERNAL);
d6342 1
a6342 1
		(links[i].type == WWW_FORM_LINK_TYPE) ? links[i].form : NULL,\
d6370 1
a6370 1
		links[curlink].form == a->input_field) {
a6379 2
	    if (a == HTMainText->last_anchor)
		break;
d6381 1
a6381 1
		links[curlink].form == a->input_field) {
d6604 1
a6604 1
 *  TRUE is returned. - FM
d6622 1
a6622 1
     *  in its range, and that we have a target string. - FM
d6624 4
a6627 2
    if (!(text && line_num >= 0 && line_num <= text->Lines &&
	  target && *target))
d6629 1
d6632 1
a6632 1
     *  Find the line and set up its data and offset - FM
d6650 1
a6650 1
     *  data, and return TRUE. - FM
d6662 1
a6662 1
	 *  return TRUE. - FM
d6672 1
a6672 1
     *  The line does not contain the target. - FM
d6707 1
a6707 1
 *  attachment; filename=name.suffix). - FM
d6721 1
a6721 1
 *  believe the headers about whether it's compressed or not. - FM
d6741 1
a6741 1
     *  Make sure we have a string and anchor. - FM
d6754 1
a6754 1
     *  elements for a gzip or Unix compressed file. - FM
d6761 1
a6761 1
	 *  the Content-Type. - FM
d6807 1
a6807 1
     *  we have a gzip or compress suffix. - FM
d6815 1
a6815 1
		 *  claims otherwise, so tweak the suffix. - FM
d6826 1
a6826 1
		 *  so tweak the suffix. - FM
d6835 1
a6835 1
		 *  conventional suffix. - FM
d6867 1
a6867 1
     *  Add the appropriate suffix. - FM
d6885 1
a6885 1
 *  if available, for the current document. - FM
d6895 1
a6895 1
 *  if available, for the current document. - FM
d6905 1
a6905 1
 *  if available, for the current document. - FM
d6974 1
a6974 1
 *  'Lines' number of lines beginning with 'line_num'-1. - FM
d6990 2
a6991 2
		Anchor_ptr != NULL && Anchor_ptr->line_num <= end;
			Anchor_ptr = Anchor_ptr->next) {
a6997 2
	if (Anchor_ptr == text->last_anchor)
	    break;
d7112 1
a7112 1
	 *  Make this text the most current in the loaded texts list. - FM
d7125 1
a7125 1
 *  (memory cached) text. - FM
d7128 1
a7128 1
	document *,	doc)
d7132 2
a7133 1
    char *post_data, *address;
d7137 1
a7137 1
     *  Make sure we have the structures. - FM
d7143 1
a7143 1
     *  Make sure doc is for a POST reply. - FM
d7152 1
a7152 1
     *  POST reply match. - FM
d7157 1
a7157 1
	    !strcmp(post_data, text->node_anchor->post_data) &&
d7169 1
a7169 1
	char *,		selector)
d7173 1
a7173 1
    for (a=HTMainText->first_anchor; a; a=a->next) {
d7175 1
a7175 1
	if (a->anchor && a->anchor->tag)
d7180 2
a7181 3
		CTRACE((tfp,
		       "HText: Selecting anchor [%d] at line %d\n",
				     a->number, www_search_result));
d7187 1
d7222 2
a7223 3
	 CTRACE((tfp,
	    "HText: Selecting anchor [%d] at line %d\n",
	    a->number, l));
d7343 1
a7343 1
 *  Utility for freeing the list of previous isindex and whereis queries. - FM
d7363 1
a7363 1
 *  any repeated queries the most current in the list. - FM
d7372 1
a7372 1
    if (!(query && *query))
d7400 1
a7400 1
	document *,	doc)
d7424 1
a7424 1
	 *  Make sure it's treated as the most recent query. - FM
d7456 1
a7456 1
		 *  Use the second to last query in the list. - FM
d7462 1
a7462 1
		 *  Go back to the previous query in the list. - FM
d7468 1
a7468 1
		 *  Roll around to the last query in the list. - FM
d7487 1
a7487 1
		 *  Use the first query in the list. - FM
d7493 1
a7493 1
		 *  Advance to the next query in the list. - FM
d7499 1
a7499 1
		 *  Roll around to the first query in the list. - FM
d7525 1
a7525 1
     *  Strip leaders and trailers. - FM
d7544 1
a7544 1
     *  or make it the most current. - FM
d7593 1
a7593 1
     *  rejecting it. - FM
d7654 6
a7659 1
	if (!first && line->data[0] != LY_SOFT_NEWLINE) {
d7662 1
a7662 1
	     *  Add news-style quotation if requested. - FM
a7668 1
	first = FALSE;
d7788 1
a7788 2
	(keypad_mode == LINKS_ARE_NUMBERED ||
	 keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)) {
d7798 1
a7798 1
    document *,	doc,
d7874 1
d7877 2
a7878 2
     *  Search the hightext string, and hightext2 if present,
     *  taking the case_sensitive setting into account. - FM
d7880 5
a7884 3
    if (LYno_attr_strstr(a->hightext, target)
     || LYno_attr_strstr(a->hightext2, target)) {
	return TRUE;
d7889 1
a7889 1
     *  case_sensitive setting into account. - FM
d7896 1
a7896 1
	     *  the displayed string. - FM
d7909 1
a7909 1
       } else if (a->input_field->type == F_OPTION_LIST_TYPE) {
d7912 1
a7912 1
	     *  when the popup is invoked. - FM
d7923 1
a7923 1
	     *  Search for checked or unchecked parens. - FM
d7935 1
a7935 1
	     *  Search for checked or unchecked square brackets. - FM
d7947 3
a7949 4
	     *  Check the values intended for display.
	     *  May have been found already via the
	     *  hightext search, but make sure here
	     *  that the entire value is searched. - FM
d8010 1
a8010 1
	document *,	doc,
d8053 1
a8053 1
	document *,	doc,
d8096 1
a8096 1
	document *,	doc,
d8141 1
a8141 1
    HTSprintf0(&temp, message, (argument == 0) ? "" : argument);
a8220 7
	if (HText_HaveUserChangedForms()) {
	    /*
	     * Issue a warning.  User forms content will be lost.
	     */
	    HTAlert(RELOADING_FORM);
	}

d8231 3
a8233 2
			      htmain_anchor->post_data) ?
				      " with POST data" : "")));
d8242 1
a8242 1
#ifdef SOURCE_CACHE
d8297 1
a8297 1
	if (HText_HaveUserChangedForms()) {
d8350 1
a8350 1
	if (HText_HaveUserChangedForms()) {
d8476 1
a8476 1
PUBLIC char * HTLoadedDocumentPost_data NOARGS
d8478 3
a8480 4
    if (!HTMainText)
	return ("");

    if (HTMainText->node_anchor && HTMainText->node_anchor->post_data)
d8483 1
a8483 1
	return ("");
d8568 9
d8598 16
d8628 1
a8628 3
		(!(text && text->T.output_utf8) ||
		 UCH(line->data[i]) < 128 ||
		 (UCH((line->data[i] & 0xc0)) == 0xc0)) &&
d8638 1
a8638 3
		(!(text && text->T.output_utf8) ||
		 UCH(line->data[i]) < 128 ||
		 (UCH(line->data[i] & 0xc0) == 0xc0))) {
d8646 36
d8708 1
a8708 1
 *  line. - FM
a8713 1
    char *data;
a8718 1
    data = line->data;
d8723 1
a8723 1
    FREE(line);
d8731 1
a8731 1
 *	  and split_line() is called. - FM
d8762 1
a8762 1
 *	  HT_LEFT. - FM
d8772 1
a8772 1
    if (!text || !name || !*name)
d8805 1
a8805 1
    if (text && name && *name && cur) {
d8825 1
a8825 1
 *  count. - FM
d8834 1
a8834 1
     *  Make sure we have an HText structure and anchor. - FM
d8841 1
a8841 1
     *  if it hasn't been already. - FM
d8849 1
a8849 1
     *  retrievals. - FM
d8851 1
a8851 1
    if ((dest = HTAnchor_followMainLink((HTAnchor *)textanchor->anchor)) &&
d8861 1
a8861 1
 *  that are loaded in text->hidden_links. - FM
d8877 1
a8877 1
 *  text->hidden_links list of the number argument. - FM
d8919 1
a8919 1
     *  Check the ACTION. - FM
d8922 1
a8922 1
	if (!strncmp(action, "mailto:", 7)) {
d8931 1
a8931 1
     *  Check the METHOD. - FM
d8938 1
a8938 1
     *  Check the ENCTYPE. - FM
d8940 1
a8940 1
    if ((enctype != NULL) && *enctype) {
d8950 1
a8950 1
     *  Check the TITLE. - FM
d8952 1
a8952 1
    if ((title != NULL) && *title)
d8987 1
a8987 1
		(HTFormTitle ? HTFormTitle : ""),
d8989 1
a8989 1
		(HTFormEnctype ? HTFormEnctype : ""),
d8991 1
a8991 1
		(HTFormAcceptCharset ? HTFormAcceptCharset : "")));
d9000 1
a9000 1
	 *  the form via <return> instead of a submit button. - FM
d9002 1
a9002 1
	TextAnchor * a = text->first_anchor;
d9004 1
a9004 1
	 *  Go through list of anchors and get our input field. - FM
d9006 1
a9006 1
	while (a) {
d9011 1
a9011 1
		 *  Got it.  Make it submitting. - FM
a9025 3
	    if (a == text->last_anchor)
		break;
	    a = a->next;
d9139 1
a9139 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d9150 1
a9150 1
	if ((cp && *cp && *cp++ == '(') &&
d9197 4
a9200 2
    if (!(text && text->last_anchor &&
	  text->last_anchor->link_type == INPUT_ANCHOR)) {
d9206 1
a9206 1
    CTRACE((tfp, "Entering HText_setLastOptionValue: value:%s, checked:%s\n",
d9229 1
a9229 1
	keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d9232 1
a9232 1
	 *  prefix and actual value. - FM
a9332 1
#ifdef SH_EX
a9334 1
#endif
d9360 2
d9363 1
a9363 1
	    text->last_anchor->input_field->num_value = 0;
d9370 2
a9371 2
	    FREE(text->last_anchor->input_field->value);
	    FREE(text->last_anchor->input_field->cp_submit_value);
d9373 5
a9377 10
	    text->last_anchor->input_field->value =
		text->last_anchor->input_field->select_list->name;
	    text->last_anchor->input_field->orig_value =
		text->last_anchor->input_field->select_list->name;
	    text->last_anchor->input_field->cp_submit_value =
		text->last_anchor->input_field->select_list->cp_submit_value;
	    text->last_anchor->input_field->orig_submit_value =
		text->last_anchor->input_field->select_list->cp_submit_value;
	    text->last_anchor->input_field->value_cs =
		new_ptr->value_cs;
d9380 1
a9380 1
	    int curlen = strlen(HTCurSelectedOptionValue);
d9393 1
d9397 6
a9402 9
	    text->last_anchor->input_field->num_value = number;
	    text->last_anchor->input_field->value = new_ptr->name;
	    text->last_anchor->input_field->orig_value = new_ptr->name;
	    text->last_anchor->input_field->cp_submit_value =
				   new_ptr->cp_submit_value;
	    text->last_anchor->input_field->orig_submit_value =
				   new_ptr->cp_submit_value;
	    text->last_anchor->input_field->value_cs =
		new_ptr->value_cs;
d9423 1
a9423 1
	CTRACE((tfp, "HText_setLastOptionValue:%s value=%s",
d9431 1
a9431 1
	    CTRACE((tfp, " (submit_val_cs %d \"%s\") submit_value%s=%s\n",
d9456 2
a9457 2
    TextAnchor * a = typecalloc(TextAnchor);
    FormInfo * f = typecalloc(FormInfo);
d9462 3
d9468 2
a9476 1

d9482 1
a9482 1
     *  name that was checked. - FM
d9494 1
a9494 1
	    TextAnchor * b = text->first_anchor;
d9496 1
a9496 1
	    while (b) {
a9508 6
		if (b == text->last_anchor) {
		    if (i2 == 0)
		       I->checked = TRUE;
		    break;
		}
		b = b->next;
d9510 2
d9520 1
a9520 1
    a->hightext = NULL;
a9531 1

d9533 1
a9533 1
     *  Set the no_cache flag if the METHOD is POST. - FM
d9655 1
a9655 1
	     *  Note that TYPE="scribble" defaults to TYPE="text". - FM
a9682 2
	    FREE(a);
	    FREE(f);
d9699 1
a9699 1
     *  an option list make it a zero-length string. - FM
d9731 1
a9731 1
	if (f->value && *f->value != '\0') {
d9739 1
a9739 1
	if (f->value && *f->value != '\0') {
d9797 1
a9797 1
#ifndef EXP_FILE_UPLOAD
d9806 1
a9806 1
	    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)
d9812 4
a9815 2
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED && a->number > 0) {
	char marker[16];
d9817 6
a9822 13
	if (f->type != F_OPTION_LIST_TYPE)
	    /*
	     *  '[' was already put out for a popup menu
	     *  designator.  See HTML.c.
	     */
	    HText_appendCharacter(text, '[');
	sprintf(marker,"%d]", a->number);
	HText_appendText(text, marker);
	if (f->type == F_OPTION_LIST_TYPE)
	    /*
	     *  Add option list designation char.
	     */
	    HText_appendCharacter(text, '[');
d9825 2
d9832 1
a9833 1
	int MaximumSize;
d9847 1
a9847 1
	     *  horizontally within the editing window. - FM
d9849 3
a9851 3
	    MaximumSize = (WRAP_COLS(text) - 1) -
			  (int)text->style->leftIndent -
			  (int)text->style->rightIndent;
d9854 8
a9861 9
	    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED)
		MaximumSize -= (a->number >= 10	/*Buggy if 1e6 links, sowhat?*/
				? (a->number >= 100
				   ? (a->number >= 1000
				      ? (a->number >= 10000
					 ? (a->number >= 100000
					    ? 6 : 5) : 4) : 3) : 2) : 1) + 2;
	    if (f->size > MaximumSize)
		f->size = MaximumSize;
a9869 1

d9875 1
a9875 1
	     *  type which is handled via a popup window. - FM
d9877 1
a9877 2
	    if (f->size > WRAP_COLS(text)-10)
		f->size = WRAP_COLS(text)-10;  /* maximum */
d9880 2
d9910 1
a9910 1
			((f->value != NULL) ? f->value : ""),
d9934 20
d9984 1
a9984 1
    if (p && *p) {
d10052 274
d10336 1
a10336 1
	document *,	doc,
d10340 3
a10342 10
    TextAnchor *anchor_ptr;
    int form_number = submit_item->number;
    FormInfo *form_ptr;
    PerFormInfo *thisform;
    char *query = NULL;
    char *escaped1 = NULL, *escaped2 = NULL;
    int first_one = 1;
    char *last_textarea_name = NULL;
    int textarea_lineno = 0;
    char *previous_blanks = NULL;
d10345 7
d10355 5
a10359 3
    int target_cs = -1;
    CONST char *out_csname;
    CONST char *target_csname = NULL;
d10361 1
a10361 6
    BOOL form_has_8bit = NO, form_has_special = NO;
    BOOL field_has_8bit = NO, field_has_special = NO;
    BOOL name_has_8bit = NO, name_has_special = NO;
    BOOL have_accept_cs = NO;
    BOOL success;
    BOOL had_chartrans_warning = NO;
d10363 7
a10369 2
    char *copied_val_used = NULL;
    char *copied_name_used = NULL;
d10386 11
a10396 10
    if (submit_item->submit_action) {
	/*
	 *  If we're mailing, make sure it's a mailto ACTION. - FM
	 */
	if ((submit_item->submit_method == URL_MAIL_METHOD) &&
	    strncmp(submit_item->submit_action, "mailto:", 7)) {
	    HTAlert(BAD_FORM_MAILTO);
	    return 0;
	}
    } else {
d10401 1
a10401 1
     *  Check the ENCTYPE and set up the appropriate variables. - FM
d10407 1
a10407 1
	 *  to separate name=value pairs. - FM
d10415 1
a10415 1
	 *  separators for name=value pairs. - FM
d10422 2
a10423 4
	 *  Use the multipart MIME format.  We should generate
	 *  a boundary string which we are sure doesn't occur
	 *  in the content, but for now we'll just assume that
	 *  this string doesn't. - FM
d10474 1
a10474 1
     *  Go through list of anchors and get size first.
d10476 6
a10481 8
    /*
     *  also get a "max." charset parameter - kw
     */
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {
	    if (anchor_ptr->input_field->number == form_number &&
			!anchor_ptr->input_field->disabled) {
d10483 2
a10484 52
		char *p;
		char * val;
		form_ptr = anchor_ptr->input_field;
		val = form_ptr->cp_submit_value != NULL ?
				    form_ptr->cp_submit_value : form_ptr->value;
		field_has_8bit = NO;
		field_has_special = NO;

		for (p = val;
		     p && *p && !(field_has_8bit && field_has_special);
		     p++)
		    if ((*p == HT_NON_BREAK_SPACE) ||
			(*p == HT_EN_SPACE) ||
			(*p == LY_SOFT_HYPHEN)) {
			field_has_special = YES;
		    } else if ((*p & 0x80) != 0) {
			field_has_8bit = YES;
		    }
		for (p = form_ptr->name;
		     p && *p && !(name_has_8bit && name_has_special);
		     p++)
		    if ((*p == HT_NON_BREAK_SPACE) ||
			(*p == HT_EN_SPACE) ||
			(*p == LY_SOFT_HYPHEN)) {
			name_has_special = YES;
		    } else if ((*p & 0x80) != 0) {
			name_has_8bit = YES;
		    }

		if (field_has_8bit || name_has_8bit)
		    form_has_8bit = YES;
		if (field_has_special || name_has_special)
		    form_has_special = YES;

		if (!field_has_8bit && !field_has_special) {
		    /* already ok */
		} else if (target_cs < 0) {
		    /* already confused */
		} else if (!field_has_8bit &&
		    (LYCharSet_UC[target_cs].enc == UCT_ENC_8859 ||
		     (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		    /* those specials will be trivial */
		} else if (UCNeedNotTranslate(form_ptr->value_cs, target_cs)) {
		    /* already ok */
		} else if (UCCanTranslateFromTo(form_ptr->value_cs, target_cs)) {
		    /* also ok */
		} else if (UCCanTranslateFromTo(target_cs, form_ptr->value_cs)) {
		    target_cs = form_ptr->value_cs;	/* try this */
		    target_csname = NULL; /* will be set after loop */
		} else {
		    target_cs = -1; /* don't know what to do */
		}
d10486 28
a10513 19
		/*  Same for name */
		if (!name_has_8bit && !name_has_special) {
		    /* already ok */
		} else if (target_cs < 0) {
		    /* already confused */
		} else if (!name_has_8bit &&
		    (LYCharSet_UC[target_cs].enc == UCT_ENC_8859 ||
		     (LYCharSet_UC[target_cs].like8859 & UCT_R_8859SPECL))) {
		    /* those specials will be trivial */
		} else if (UCNeedNotTranslate(form_ptr->name_cs, target_cs)) {
		    /* already ok */
		} else if (UCCanTranslateFromTo(form_ptr->name_cs, target_cs)) {
		    /* also ok */
		} else if (UCCanTranslateFromTo(target_cs, form_ptr->name_cs)) {
		    target_cs = form_ptr->value_cs;	/* try this */
		    target_csname = NULL; /* will be set after loop */
		} else {
		    target_cs = -1; /* don't know what to do */
		}
d10515 18
a10532 2
	    } else if (anchor_ptr->input_field->number > form_number) {
		break;
a10533 1
	}
d10535 2
a10536 1
	if (anchor_ptr == HTMainText->last_anchor)
d10538 2
d10541 8
a10548 1
	anchor_ptr = anchor_ptr->next;
d10552 1
a10552 1
	if (form_has_8bit) {
d10554 1
a10554 1
	} else if (form_has_special) {
d10562 3
a10564 1
	StrAllocCopy(query, submit_item->submit_action);
d10568 1
a10568 1
	strtok (query, "#");
d10572 1
a10572 1
	strtok (query, "?");
d10576 2
a10577 1
	StrAllocCat(query,"?");
d10582 1
a10582 1
	 *  the post_content_type element if all goes well. - FM, kw
d10592 1
a10592 2
			 "multipart/form-data; boundary=");
	    StrAllocCat(content_type_out, Boundary);
d10615 3
a10617 2
	if (have_accept_cs ||
	    (form_has_8bit || form_has_special)) {
d10626 1
a10626 2
			StrAllocCat(content_type_out, "; charset=");
			StrAllocCat(content_type_out, target_csname);
d10630 1
a10630 5
		had_chartrans_warning = YES;
		_user_message(
		    CANNOT_TRANSCODE_FORM,
		    target_csname ? target_csname : "UNKNOWN");
		LYSleepAlert();
d10638 1
a10638 1
     *  Reset anchor->ptr.
d10640 6
a10645 11
    anchor_ptr = HTMainText->first_anchor;
    /*
     *  Go through list of anchors and assemble URL query.
     */
    while (anchor_ptr) {
	if (anchor_ptr->link_type == INPUT_ANCHOR) {
	    if (anchor_ptr->input_field->number == form_number &&
			!anchor_ptr->input_field->disabled) {
		char *p;
		int out_cs;
		form_ptr = anchor_ptr->input_field;
d10647 2
a10648 2
		if (form_ptr->type != F_TEXTAREA_TYPE)
		    textarea_lineno = 0;
d10650 38
a10687 2
		switch(form_ptr->type) {
		case F_RESET_TYPE:
d10689 9
a10697 33
		case F_SUBMIT_TYPE:
		case F_TEXT_SUBMIT_TYPE:
		case F_IMAGE_SUBMIT_TYPE:
		    if (!(form_ptr->name && *form_ptr->name != '\0' &&
			  !strcmp(form_ptr->name, link_name))) {
			CTRACE((tfp,
				    "SubmitForm: skipping submit field with "));
			CTRACE((tfp, "name \"%s\" for link_name \"%s\", %s.\n",
				    form_ptr->name ? form_ptr->name : "???",
				    link_name ? link_name : "???",
				    (form_ptr->name && *form_ptr->name) ?
				    "not current link" : "no field name"));
			break;
		    }
		    if (!(form_ptr->type == F_TEXT_SUBMIT_TYPE ||
			(form_ptr->value && *form_ptr->value != '\0' &&
			 !strcmp(form_ptr->value, link_value)))) {
			CTRACE((tfp,
				"SubmitForm: skipping submit field with "));
			CTRACE((tfp,
				"name \"%s\" for link_name \"%s\", %s!\n",
				form_ptr->name ? form_ptr->name : "???",
				link_name ? link_name : "???",
				"values are different"));
			break;
		    }
		    /* FALLTHRU */

#ifdef EXP_FILE_UPLOAD
		case F_FILE_TYPE:
		    CTRACE((tfp, "I'd submit %s (from %s), but you've not finished it\n", form_ptr->value, form_ptr->name));
		    name_used = (form_ptr->name ? form_ptr->name : "");
		    val_used = (form_ptr->value ? form_ptr->value : "");
d10699 17
a10715 1
#endif
d10717 45
a10761 13
		    /*  fall through  */
		case F_RADIO_TYPE:
		case F_CHECKBOX_TYPE:
		case F_TEXTAREA_TYPE:
		case F_PASSWORD_TYPE:
		case F_TEXT_TYPE:
		case F_OPTION_LIST_TYPE:
		case F_HIDDEN_TYPE:
		    /*
		     *	Be sure to actually look at the option submit value.
		     */
		    if (form_ptr->cp_submit_value != NULL) {
			val_used = form_ptr->cp_submit_value;
d10763 3
a10765 1
			val_used = form_ptr->value;
d10767 3
d10771 10
a10780 17
		    /*
		     *  Charset-translate value now, because we need
		     *  to know the charset parameter for multipart
		     *  bodyparts. - kw
		     */
		    field_has_8bit = NO;
		    field_has_special = NO;
		    for (p = val_used;
			 p && *p && !(field_has_8bit && field_has_special);
			 p++) {
			if ((*p == HT_NON_BREAK_SPACE) ||
			    (*p == HT_EN_SPACE) ||
			    (*p == LY_SOFT_HYPHEN)) {
			    field_has_special = YES;
			} else if ((*p & 0x80) != 0) {
			    field_has_8bit = YES;
			}
d10782 1
d10784 5
a10788 5
		    if (field_has_8bit || field_has_special) {
			/*  We should translate back. */
			StrAllocCopy(copied_val_used, val_used);
			success = LYUCTranslateBackFormData(&copied_val_used,
							form_ptr->value_cs,
d10790 11
a10800 30
			CTRACE((tfp, "SubmitForm: field \"%s\" %d %s -> %d %s %s\n",
				    form_ptr->name ? form_ptr->name : "",
				    form_ptr->value_cs,
				    form_ptr->value_cs >= 0 ?
				    LYCharSet_UC[form_ptr->value_cs].MIMEname :
									  "???",
				    target_cs,
				    target_csname ? target_csname : "???",
				    success ? "OK" : "FAILED"));
			if (success) {
			    val_used = copied_val_used;
			}
		    } else {  /* We can use the value directly. */
			CTRACE((tfp, "SubmitForm: field \"%s\" %d %s OK\n",
				    form_ptr->name ? form_ptr->name : "",
				    target_cs,
				    target_csname ? target_csname : "???"));
			success = YES;
		    }
		    if (!success) {
			if (!had_chartrans_warning) {
			    had_chartrans_warning = YES;
			    _user_message(
				CANNOT_TRANSCODE_FORM,
				target_csname ? target_csname : "UNKNOWN");
			    LYSleepAlert();
			}
			out_cs = form_ptr->value_cs;
		    } else {
			out_cs = target_cs;
a10801 2
		    if (out_cs >= 0)
			out_csname = LYCharSet_UC[out_cs].MIMEname;
d10803 2
a10804 9
			if (!success && form_ptr->value_cs < 0) {
			    /*  This is weird. */
			    StrAllocCopy(MultipartContentType,
					 "\r\nContent-Type: text/plain; charset=");
			    StrAllocCat(MultipartContentType, "UNKNOWN-8BIT");
			} else if (!success) {
			    StrAllocCopy(MultipartContentType,
					 "\r\nContent-Type: text/plain; charset=");
			    StrAllocCat(MultipartContentType, out_csname);
d10807 1
a10807 1
			    if (!target_csname) {
a10808 4
			    }
			    StrAllocCopy(MultipartContentType,
					 "\r\nContent-Type: text/plain; charset=");
			    StrAllocCat(MultipartContentType, out_csname);
d10811 131
d10943 1
a10943 15
		    /*
		     *  Charset-translate name now, because we need
		     *  to know the charset parameter for multipart
		     *  bodyparts. - kw
		     */
		    if (form_ptr->type == F_TEXTAREA_TYPE) {
			textarea_lineno++;
			if (textarea_lineno > 1 &&
			    last_textarea_name && form_ptr->name &&
			    !strcmp(last_textarea_name, form_ptr->name)) {
			    break;
			}
		    }
		    name_used = (form_ptr->name ?
				 form_ptr->name : "");
d10945 2
a10946 13
		    name_has_8bit = NO;
		    name_has_special = NO;
		    for (p = name_used;
			 p && *p && !(name_has_8bit && name_has_special);
			 p++) {
			if ((*p == HT_NON_BREAK_SPACE) ||
			    (*p == HT_EN_SPACE) ||
			    (*p == LY_SOFT_HYPHEN)) {
			    name_has_special = YES;
			} else if ((*p & 0x80) != 0) {
			    name_has_8bit = YES;
			}
		    }
d10948 9
a10956 68
		    if (name_has_8bit || name_has_special) {
			/*  We should translate back. */
			StrAllocCopy(copied_name_used, name_used);
			success = LYUCTranslateBackFormData(&copied_name_used,
							form_ptr->name_cs,
							target_cs, PlainText);
			CTRACE((tfp, "SubmitForm: name \"%s\" %d %s -> %d %s %s\n",
				    form_ptr->name ? form_ptr->name : "",
				    form_ptr->name_cs,
				    form_ptr->name_cs >= 0 ?
				    LYCharSet_UC[form_ptr->name_cs].MIMEname :
									  "???",
				    target_cs,
				    target_csname ? target_csname : "???",
				    success ? "OK" : "FAILED"));
			if (success) {
			    name_used = copied_name_used;
			}
			if (Boundary) {
			    if (!success) {
				StrAllocCopy(MultipartContentType, "");
				target_csname = NULL;
			    } else {
				if (!target_csname)
				    target_csname = LYCharSet_UC[target_cs].MIMEname;
			    }
			}
		    } else {  /* We can use the name directly. */
			CTRACE((tfp, "SubmitForm: name \"%s\" %d %s OK\n",
				    form_ptr->name ? form_ptr->name : "",
				    target_cs,
				    target_csname ? target_csname : "???"));
			success = YES;
			if (Boundary) {
			    StrAllocCopy(copied_name_used, name_used);
			}
		    }
		    if (!success) {
			if (!had_chartrans_warning) {
			    had_chartrans_warning = YES;
			    _user_message(
				CANNOT_TRANSCODE_FORM,
				target_csname ? target_csname : "UNKNOWN");
			    LYSleepAlert();
			}
		    }
		    if (Boundary) {
			/*
			 *  According to RFC 1867, Non-ASCII field names
			 *  "should be encoded according to the prescriptions
			 *  of RFC 1522 [...].  I don't think RFC 1522 actually
			 *  is meant to apply to parameters like this, and it
			 *  is unknown whether any server would make sense of
			 *  it, so for now just use some quoting/escaping and
			 *  otherwise leave 8-bit values as they are.
			 *  Non-ASCII characters in form field names submitted
			 *  as multipart/form-data can only occur if the form
			 *  provider specifically asked for it anyway. - kw
			 */
			HTMake822Word(&copied_name_used);
			name_used = copied_name_used;
		    }

		    break;
		default:
		    CTRACE((tfp, "SubmitForm: What type is %d?\n",
				form_ptr->type));
		    break;
d10958 3
d10962 1
a10962 1
		switch(form_ptr->type) {
d10964 2
a10965 2
		case F_RESET_TYPE:
		    break;
d10967 7
a10973 7
#ifdef EXP_FILE_UPLOAD
		case F_FILE_TYPE:
		{
		    int cdisp_name_startpos = 0;
		    FILE *fd;
		    int bytes;
		    char buffer[257];
d10975 1
a10975 1
		    CTRACE((tfp, "Ok, about to convert %s to mime/thingy\n", form_ptr->value));
d10978 1
a10978 1
			    HTSprintf(&query, "--%s\r\n", Boundary);
d10983 1
a10983 1
			    HTSprintf(&query, "\n");
d10985 1
a10985 1
			    HTSprintf(&query, ";");
d10987 1
a10987 1
			    HTSprintf(&query, "\r\n--%s\r\n", Boundary);
d10989 1
a10989 17
			    HTSprintf(&query, "&");
			}
		    }

		    if (PlainText) {
			StrAllocCopy(escaped1, name_used);
		    } else if (Boundary) {
			StrAllocCopy(escaped1,
				"Content-Disposition: form-data; name=");
			cdisp_name_startpos = strlen(escaped1);
			StrAllocCat(escaped1, name_used);
			StrAllocCat(escaped1, "; filename=\"");
			StrAllocCat(escaped1, val_used);
			StrAllocCat(escaped1, "\"");
			if (MultipartContentType) {
			    StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\nContent-Transfer-Encoding: base64");
a10990 3
			StrAllocCat(escaped1, "\r\n\r\n");
		    } else {
			escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
a10991 33

		    if ((fd = fopen(val_used, BIN_R)) == 0) {
			/* We can't open the file, what do we do? */
			HTAlert(gettext("Can't open file for uploading"));
			goto exit_disgracefully;
		    }
		    StrAllocCopy(escaped2, "");
		    while ((bytes = fread(buffer, sizeof(char), 45, fd)) != 0) {
			char base64buf[128];
			base64_encode(base64buf, buffer, bytes);
			StrAllocCat(escaped2, base64buf);
		    }
		    if (ferror(fd)) {
			/* We got an error reading the file, what do we do? */
			HTAlert(gettext("Short read from file, problem?"));
			LYCloseInput(fd);
			goto exit_disgracefully;
		    }
		    LYCloseInput(fd);
		    /* we need to modify the mime-type here - rp */
		    /* Note: could use LYGetFileInfo for that and for
		       other headers that should be transmitted - kw */

		    HTSprintf(&query,
				   "%s%s%s%s%s",
				   escaped1,
				   (Boundary ? "" : "="),
				   (PlainText ? "\n" : ""),
					escaped2,
				   ((PlainText && *escaped2) ?
							 "\n" : ""));
		    FREE(escaped1);
		    FREE(escaped2);
a10992 2
		break;
#endif /* EXP_FILE_UPLOAD */
d10994 4
a10997 34
		case F_SUBMIT_TYPE:
		case F_TEXT_SUBMIT_TYPE:
		case F_IMAGE_SUBMIT_TYPE:
		    /*
		     *  If it has a non-zero length name (e.g., because
		     *  its IMAGE_SUBMIT_TYPE is to be handled homologously
		     *  to an image map, or a SUBMIT_TYPE in a set of
		     *  multiple submit buttons, or a single type="text"
		     *  that's been converted to a TEXT_SUBMIT_TYPE),
		     *  include the name=value pair, or fake name.x=0 and
		     *  name.y=0 pairs for IMAGE_SUBMIT_TYPE. - FM
		     */
		    if ((form_ptr->name && *form_ptr->name != '\0' &&
			!strcmp(form_ptr->name, link_name)) &&
		       (form_ptr->type == F_TEXT_SUBMIT_TYPE ||
			(form_ptr->value && *form_ptr->value != '\0' &&
			 !strcmp(form_ptr->value, link_value)))) {
			int cdisp_name_startpos = 0;
			if (first_one) {
			    if (Boundary) {
				HTSprintf(&query, "--%s\r\n", Boundary);
			    }
			    first_one=FALSE;
			} else {
			    if (PlainText) {
				StrAllocCat(query, "\n");
			    } else if (SemiColon) {
				StrAllocCat(query, ";");
			    } else if (Boundary) {
				HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			    } else {
				StrAllocCat(query, "&");
			    }
			}
d10999 4
a11002 13
			if (PlainText) {
			    StrAllocCopy(escaped1, name_used);
			} else if (Boundary) {
			    StrAllocCopy(escaped1,
				    "Content-Disposition: form-data; name=");
			    cdisp_name_startpos = strlen(escaped1);
			    StrAllocCat(escaped1, name_used);
			    if (MultipartContentType)
				StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\n\r\n");
			} else {
			    escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
			}
d11004 52
a11055 7
			if (PlainText || Boundary) {
			    StrAllocCopy(escaped2,
					 (val_used ?
					  val_used : ""));
			} else {
			    escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
			}
d11057 2
a11058 46
			if (form_ptr->type == F_IMAGE_SUBMIT_TYPE) {
			    /*
			     *  It's a clickable image submit button.
			     *  Fake a 0,0 coordinate pair, which
			     *  typically returns the image's default. - FM
			     */
			    if (Boundary) {
				escaped1[cdisp_name_startpos] = '\0';
				HTSprintf(&query,
					"%s.x\r\n\r\n0\r\n--%s\r\n%s.y\r\n\r\n0",
					escaped1,
					Boundary,
					escaped1);
			    } else {
				HTSprintf(&query,
					"%s.x=0%s%s.y=0%s",
					escaped1,
					(PlainText ?
					      "\n" : (SemiColon ?
							    ";" : "&")),
					escaped1,
					((PlainText && *escaped1) ?
							     "\n" : ""));
			    }
			} else {
			    /*
			     *  It's a standard submit button.
			     *  Use the name=value pair. = FM
			     */
			    HTSprintf(&query,
				    "%s%s%s%s%s",
				    escaped1,
				    (Boundary ?
					   "" : "="),
				    (PlainText ?
					  "\n" : ""),
				    escaped2,
				    ((PlainText && *escaped2) ?
							 "\n" : ""));
			}
			FREE(escaped1);
			FREE(escaped2);
		    }
		    FREE(copied_name_used);
		    FREE(copied_val_used);
		    break;
d11060 1
a11060 2
		case F_RADIO_TYPE:
		case F_CHECKBOX_TYPE:
d11062 3
a11064 1
		     *  Only add if selected.
d11066 12
a11077 42
		    if (form_ptr->num_value) {
			if (first_one) {
			    if (Boundary) {
				HTSprintf(&query,
					"--%s\r\n", Boundary);
			    }
			    first_one=FALSE;
			} else {
			    if (PlainText) {
				StrAllocCat(query, "\n");
			    } else if (SemiColon) {
				StrAllocCat(query, ";");
			    } else if (Boundary) {
				HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			    } else {
				StrAllocCat(query, "&");
			    }
			}

			if (PlainText) {
			    StrAllocCopy(escaped1, name_used);
			} else if (Boundary) {
			    StrAllocCopy(escaped1,
				     "Content-Disposition: form-data; name=");
			    StrAllocCat(escaped1,
					name_used);
			    if (MultipartContentType)
				StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\n\r\n");
			} else {
			    escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
			}
			if (PlainText || Boundary) {
			    StrAllocCopy(escaped2,
					 (val_used ?
					  val_used : ""));
			} else {
			    escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
			}

			HTSprintf(&query,
				"%s%s%s%s%s",
a11078 2
				(Boundary ?
				       "" : "="),
d11080 2
a11081 63
				      "\n" : ""),
				escaped2,
				((PlainText && *escaped2) ?
						     "\n" : ""));
			FREE(escaped1);
			FREE(escaped2);
		    }
		    FREE(copied_name_used);
		    FREE(copied_val_used);
		    break;

		case F_TEXTAREA_TYPE:
		    if (PlainText || Boundary) {
			StrAllocCopy(escaped2,
				     (val_used ?
				      val_used : ""));
		    } else {
			escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
		    }

		    if (!last_textarea_name ||
			strcmp(last_textarea_name, form_ptr->name)) {
			textarea_lineno = 1;
			/*
			 *  Names are different so this is the first
			 *  textarea or a different one from any before
			 *  it.
			 */
			if (Boundary) {
			    StrAllocCopy(previous_blanks, "\r\n");
			} else {
			    FREE(previous_blanks);
			}
			if (first_one) {
			    if (Boundary) {
				HTSprintf(&query, "--%s\r\n", Boundary);
			    }
			    first_one = FALSE;
			} else {
			    if (PlainText) {
				StrAllocCat(query, "\n");
			    } else if (SemiColon) {
				StrAllocCat(query, ";");
			    } else if (Boundary) {
				HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			    } else {
				StrAllocCat(query, "&");
			    }
			}
			if (PlainText) {
			    StrAllocCopy(escaped1, name_used);
			} else if (Boundary) {
			    StrAllocCopy(escaped1,
				    "Content-Disposition: form-data; name=");
			    StrAllocCat(escaped1, name_used);
			    if (MultipartContentType)
				StrAllocCat(escaped1, MultipartContentType);
			    StrAllocCat(escaped1, "\r\n\r\n");
			} else {
			    escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
			}
			HTSprintf(&query,
				"%s%s%s%s%s",
d11083 1
a11083 6
				(Boundary ?
				       "" : "="),
				(PlainText ?
				      "\n" : ""),
				escaped2,
				((PlainText && *escaped2) ?
a11084 52
			FREE(escaped1);
			last_textarea_name = form_ptr->name;
		    } else {
			/*
			 *  This is a continuation of a previous textarea
			 *  add %0d%0a (\r\n) and the escaped string.
			 */
			if (escaped2[0] != '\0') {
			    if (previous_blanks) {
				StrAllocCat(query, previous_blanks);
				FREE(previous_blanks);
			    }
			    if (PlainText) {
				HTSprintf(&query, "%s\n", escaped2);
			    } else if (Boundary) {
				HTSprintf(&query, "%s\r\n", escaped2);
			    } else {
				HTSprintf(&query, "%%0d%%0a%s", escaped2);
			    }
			} else {
			    if (PlainText) {
				StrAllocCat(previous_blanks, "\n");
			    } else if (Boundary) {
				StrAllocCat(previous_blanks, "\r\n");
			    } else {
				StrAllocCat(previous_blanks, "%0d%0a");
			    }
			}
		    }
		    FREE(escaped2);
		    FREE(copied_val_used);
		    break;

		case F_PASSWORD_TYPE:
		case F_TEXT_TYPE:
		case F_OPTION_LIST_TYPE:
		case F_HIDDEN_TYPE:
		    if (first_one) {
			if (Boundary) {
			    HTSprintf(&query, "--%s\r\n", Boundary);
			}
			first_one=FALSE;
		    } else {
			if (PlainText) {
			    StrAllocCat(query, "\n");
			} else if (SemiColon) {
			    StrAllocCat(query, ";");
			} else if (Boundary) {
			    HTSprintf(&query, "\r\n--%s\r\n", Boundary);
			} else {
			    StrAllocCat(query, "&");
			}
d11086 20
d11107 6
d11114 1
a11114 1
		       StrAllocCopy(escaped1, name_used);
d11116 1
a11116 6
			StrAllocCopy(escaped1,
				    "Content-Disposition: form-data; name=");
			StrAllocCat(escaped1, name_used);
			if (MultipartContentType)
			    StrAllocCat(escaped1, MultipartContentType);
			StrAllocCat(escaped1, "\r\n\r\n");
d11118 1
a11118 1
			escaped1 = HTEscapeSP(name_used, URL_XALPHAS);
d11120 3
d11124 26
a11149 4
		    if (PlainText || Boundary) {
			StrAllocCopy(escaped2,
				     (val_used ?
				      val_used : ""));
d11151 1
a11151 1
			escaped2 = HTEscapeSP(val_used, URL_XALPHAS);
d11153 23
d11177 15
a11191 15
		    HTSprintf(&query,
			    "%s%s%s%s%s",
			    escaped1,
			    (Boundary ?
				   "" : "="),
			    (PlainText ?
				  "\n" : ""),
			    escaped2,
			    ((PlainText && *escaped2) ?
						 "\n" : ""));
		    FREE(escaped1);
		    FREE(escaped2);
		    FREE(copied_name_used);
		    FREE(copied_val_used);
		    break;
d11193 4
a11196 1
	    } else if (anchor_ptr->input_field->number > form_number) {
d11199 14
a11213 12

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
    }
    FREE(copied_name_used);
    if (Boundary) {
	FREE(MultipartContentType);
	HTSprintf(&query, "\r\n--%s--\r\n", Boundary);
    } else if (!query) {
	StrAllocCopy(query, "");
a11214 3
    FREE(previous_blanks);

    CTRACE((tfp, "QUERY (%d) >> \n%s\n", strlen(query), query));
d11218 1
a11218 9
	CTRACE((tfp, "\nGridText - mailto_address: %s\n",
			    (submit_item->submit_action+7)));
	CTRACE((tfp, "GridText - mailto_subject: %s\n",
			    ((submit_item->submit_title &&
			      *submit_item->submit_title) ?
			      (submit_item->submit_title) :
					(HText_getTitle() ?
					 HText_getTitle() : ""))));
	CTRACE((tfp,"GridText - mailto_content: %s\n",query));
d11220 4
a11223 6
		 ((submit_item->submit_title &&
		   *submit_item->submit_title) ?
		   (submit_item->submit_title) :
			     (HText_getTitle() ?
			      HText_getTitle() : "")),
		 query,
d11225 2
a11226 1
	FREE(query);
a11227 1
	return 0;
d11230 14
d11246 10
a11255 15
    if (submit_item->submit_method == URL_POST_METHOD || Boundary) {
	StrAllocCopy(doc->post_data, query);
	FREE(doc->post_content_type);
	doc->post_content_type = content_type_out; /* don't free c_t_out */
	CTRACE((tfp,"GridText - post_data: %s\n",doc->post_data));
	StrAllocCopy(doc->address, submit_item->submit_action);
	FREE(query);
	return 1;
    } else { /* GET_METHOD */
	StrAllocCopy(doc->address, query);
	FREE(doc->post_data);
	FREE(doc->post_content_type);
	FREE(content_type_out);
	FREE(query);
	return 1;
d11257 2
a11258 12
#ifdef EXP_FILE_UPLOAD
exit_disgracefully:
    FREE(escaped1);
    FREE(escaped2);
    FREE(previous_blanks);
    FREE(copied_name_used);
    FREE(copied_val_used);
    FREE(MultipartContentType);
    FREE(query);
    FREE(content_type_out);
    return 0;
#endif
d11272 3
a11274 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr) {
a11279 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
d11297 3
a11299 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != 0) {
a11326 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
d11335 2
a11336 1
PUBLIC BOOLEAN HText_HaveUserChangedForms NOARGS
d11340 1
a11340 1
    if (HTMainText == 0)
d11347 3
a11349 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr != 0) {
a11375 4
	if (anchor_ptr == HTMainText->last_anchor)
	   break;

	anchor_ptr = anchor_ptr->next;
d11388 3
a11390 2
    anchor_ptr = HTMainText->first_anchor;
    while (anchor_ptr) {
a11406 5

	if (anchor_ptr == HTMainText->last_anchor)
	    break;

	anchor_ptr = anchor_ptr->next;
a11434 2
	    if (cur->node_anchor && cur->node_anchor->underway)
		cur->node_anchor->underway = FALSE;
d11513 1
a11513 1
**  Check charset and set the kcode element. - FM
d11546 1
a11546 1
    **  Check whether we have a specified charset. - FM
d11556 1
a11556 1
    **  appropriately. - FM
d11585 1
a11585 1
	**  it is enabled.  But only if we are quite sure. - FM & kw
d11608 1
a11608 1
**  Set a permissible split at the current end of the last line. - FM
d11617 1
a11617 1
     *  Can split here. - FM
d11635 1
a11635 1
**  claimed or suggested this. - FM
a11643 1
    char *TargetPound;
d11662 1
a11662 1
    if ((TargetPound = strchr(full_address, '#')) == NULL)
d11670 1
a11670 1
    if (!strncasecomp(anchor->address, "LYNXIMGMAP:", 11))
d11684 4
a11687 5
    MTaddress = (strncasecomp(MTanc->address,
			      "LYNXIMGMAP:", 11) ?
				  MTanc->address : (MTanc->address + 11));
    if ((MTpound = strchr(MTaddress, '#')) != NULL)
	*MTpound = '\0';
d11689 1
a11689 3
	if (MTpound != NULL) {
	    *MTpound = '#';
	}
d11692 1
a11692 3
    if (MTpound != NULL) {
	*MTpound = '#';
    }
d11701 1
a11701 1
		if (strcmp(MTanc->post_data, anchor->post_data)) {
d11726 1
a11726 1
     *  or other directives not to use a cached rendition. - FM
d12079 1
a12079 1
    if (mode == CHOP)
d12081 17
d12151 4
a12154 3
    if (((a = typecalloc(TextAnchor)) == 0) ||
	((f = typecalloc(FormInfo)) == 0) ||
	((l = allocHTLine(MAX_LINE)) == 0))
d12164 1
a12164 3
    StrAllocCopy (a->hightext,  anchor->hightext);
    StrAllocCopy (a->hightext2, anchor->hightext2);
    a->hightext2offset = anchor->hightext2offset;
d12196 8
a12203 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d12219 1
a12219 1
     *  link in the new HTLine and point the entry htline arg at it, too.
a12223 2
    htline->next->prev = l;
    htline->next       = l;
d12272 1
a12272 1
	if ((keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) &&
d12309 1
a12309 1
    if (keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d12392 1
a12392 1
	   struct link *,  form_link)
d12413 1
a12413 1
    FormInfo   *form	 = form_link->form;
d12730 2
a12731 2
	    struct link *,  form_link,
	    int,	    newlines)
d12737 1
a12737 1
    FormInfo *form      = form_link->form;
d12830 1
a12830 1
	   struct link *,  form_link)
d12844 1
a12844 1
    FormInfo   *form	 = form_link->form;
d12980 4
a12983 3
    if (((a = typecalloc(TextAnchor)) == 0) ||
	((f = typecalloc(FormInfo)) == 0) ||
	((l = allocHTLine(MAX_LINE)) == 0))
d12993 1
a12993 3
    StrAllocCopy (a->hightext,  anchor_ptr->hightext);
    StrAllocCopy (a->hightext2, anchor_ptr->hightext2);
    a->hightext2offset = anchor_ptr->hightext2offset;
d13148 2
a13149 2
 * drawn.  Currently used only in redraw_lines_of_link when
 *    defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
d13151 1
a13151 3
 * (since no support for lss is availble for Slang) and with
 * defined(USE_COLOR_STYLE).
 * -HV.
d13153 1
a13153 1
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
d13204 1
a13204 1
		    start_underline();
d13213 1
a13213 1
		    stop_underline();
d13218 1
a13218 1
		start_bold();
d13222 1
a13222 1
		stop_bold ();
d13243 1
a13243 1
		     *  split_line() in those cases. - FM
d13248 1
a13248 1
		     *  Make it a hard hyphen and fall through. - FM
d13257 2
a13258 23
		if (text->T.output_utf8 && !isascii(UCH(buffer[0]))) {
		    if ((*buffer & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*buffer & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*buffer & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*buffer & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*buffer & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			 /*
			  *  Garbage.
			  */
			utf_extra = 0;
		    }
		    if (strlen(data) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
d13268 1
a13268 1
		} else if (HTCJK != NOCJK && !isascii(UCH(buffer[0]))) {
d13285 1
a13285 1
		     *  character handling is used. - FM
d13296 2
a13297 2
    stop_underline();
    stop_bold();
d13310 1
a13310 1
#endif /* defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)  */
d13459 1
a13459 1
	     *  the behavior (previously done in highlight()) for target
d13494 2
a13495 2
		    if (inunderline)	stop_underline();
		    if (inbold)		stop_bold();
d13551 2
a13552 2
			    if (inbold)		start_bold();
			    if (inunderline)	start_underline();
d13584 1
a13584 1
		    start_underline();
d13590 1
a13590 1
		    stop_underline();
d13596 1
a13596 1
		    start_bold();
d13602 1
a13602 1
		    stop_bold();
d13624 1
a13624 1
		     *  split_line() in those cases. - FM
d13629 1
a13629 1
		     *  Make it a hard hyphen and fall through. - FM
d13646 1
a13646 1
			       !isascii(UCH(buffer[0]))) {
d13704 1
a13704 1
		if (utf_flag && !isascii(UCH(buffer[0]))) {
d13706 1
a13706 22
		    if ((*buffer & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*buffer & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*buffer & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*buffer & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*buffer & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			 /*
			  *  Garbage.
			  */
			utf_extra = 0;
		    }
		    if (strlen(data) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
d13723 1
a13723 1
				start_bold();
d13725 1
a13725 1
				start_underline();
d13732 1
a13732 1
		} else if (HTCJK != NOCJK && !isascii(UCH(buffer[0]))) {
d13744 7
a13750 9
		     *  For now, load 'M' into LastDisplayChar,
		     *  but we should check whether it's white
		     *  and if so, use ' '.  I don't know if
		     *  there actually are white CJK characters,
		     *  and we're loading ' ' for multibyte
		     *  spacing characters in this code set,
		     *  but this will become an issue when
		     *  the development code set's multibyte
		     *  character handling is used. - FM
d13819 1
a13819 1
	    XP_draw_min = links[i].ly + links[i].form->size;
d13853 3
a13855 5
  This is used only if compiled with lss support. It's called to draw
  regular link (1st two lines of link) when it's being unhighlighted in
  highlight:LYUtils.
*/

d13859 1
a13859 1
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
d13861 1
a13861 1
    HTLine* todr1, *todr2;
d13863 2
d13868 1
a13868 1
	lines_back = HTMainText->Lines - ( links[cur].ly-pvtTITLE_HEIGHT+
d13871 1
a13871 1
	lines_back = display_lines - (links[cur].ly-pvtTITLE_HEIGHT);
a13875 2
    todr2 = (links[cur].hightext2 && links[cur].ly < display_lines) ?
	    todr1->next : 0;
d13877 6
a13882 7
    LYmove(links[cur].ly,  links[cur].lx);
    redraw_part_of_line (todr1, links[cur].hightext,
			 strlen(links[cur].hightext),  HTMainText);
    if (todr2) {
	LYmove(links[cur].ly+1,links[cur].hightext2_offset);
	redraw_part_of_line (todr2, links[cur].hightext2,
			     strlen(links[cur].hightext2),  HTMainText);
a13883 1

@


1.3.2.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@d9273 2
a9274 2
    if (I->size != 0) {
	f->size = I->size;
@


1.3.4.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@d9273 2
a9274 2
    if (I->size != 0) {
	f->size = I->size;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a6 1
#include <HTFont.h>
d13 1
a18 6
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
#include <syslog.h>
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */

d35 2
d44 4
d62 1
a62 4
#ifdef USE_COLOR_STYLE_UNUSED
void LynxClearScreenCache NOARGS
{
    int i,j;
d64 9
a72 5
    CTRACE(tfp, "flushing cached screen styles\n");
    for (i=0;i<CACHEH;i++)
	for (j=0;j<CACHEW;j++)
	    cached_styles[i][j]=s_a;
}
d74 9
d86 1
a86 1
    int i,j;
d88 3
a90 3
    for (i=1; (i<CACHEH && i <= display_lines); i++) {
	for (j=0;j<CACHEW;j++)
	    cached_styles[i][j]=0;
d102 4
a105 1
			  ((unsigned char)(ch)&0xc0) == 0x80)
d108 9
a116 2
extern HTkcode kanji_code;
extern HTCJKlang HTCJK;
d139 2
a140 2
PUBLIC BOOLEAN underline_on = OFF;
PUBLIC BOOLEAN bold_on      = OFF;
a142 2
PUBLIC char * source_cache_filename = NULL;
PUBLIC HTChunk * source_cache_chunk = NULL;
d144 8
a151 1
PUBLIC BOOLEAN from_source_cache = FALSE;  /* mutable */
d157 1
d159 4
a162 4
	int	horizpos;	/* horizontal position of this change */
	int	style;		/* which style to change to */
	int	direction;	/* on or off */
	int	previous;	/* previous style */
a170 3
	BOOL	split_after;		/* Can we split after? */
	BOOL	bullet;			/* Do we bullet? */
	BOOL	expansion_line;		/* TEXTAREA edit new line flag */
d172 1
a172 1
	HTStyleChange	styles[MAX_STYLES_ON_LINE];
d178 118
d297 1
d301 1
d303 2
a304 3
	int			start;		/* Characters */
	int			line_pos;	/* Position in text */
	int			extent;		/* Characters */
d324 1
a324 1
**	next_line is valid if state is false.
a330 3
#undef	lines			/* FIXME */
	char *			source_cache_file;
	HTChunk *		source_cache_chunk;
d336 1
d341 4
a344 3
	BOOLEAN			old_dtd;
	int			lines;		/* Screen size */
	int			cols;
a347 1
	int			chars;		/* Number of them */
d350 1
d372 2
d378 1
d381 10
d406 3
d413 67
d495 2
d520 1
d592 1
a592 1
	CTRACE(tfp, "\r *** Emergency freeing document %d/%d for '%s'%s!\n",
d599 1
a599 1
		     " with POST data" : ""));
d680 1
a680 1
    HText * self = (HText *) calloc(1, sizeof(*self));
d684 2
d688 1
a688 1
    CTRACE(tfp, "GridText: VMTotal = %d\n", VMTotal);
d691 16
d723 1
a723 1
	CTRACE(tfp, "GridText: Auto-uncaching\n") ;
d737 1
a737 1
	CTRACE(tfp, "GridText: Freeing off cached doc.\n");
d741 1
a741 1
	CTRACE(tfp, "GridText: VMTotal reduced to %d\n", VMTotal);
d745 1
a745 1
    line = self->last_line = (HTLine *)calloc(1, LINE_SIZE(MAX_LINE));
d752 5
d758 1
a758 1
    self->Lines = self->chars = 0;
a768 14
     * Yes, this is a Gross And Disgusting Hack(TM), I know...
     */
    self->source_cache_file = NULL;
    if (LYCacheSource == SOURCE_CACHE_FILE && source_cache_filename) {
      StrAllocCopy(self->source_cache_file, source_cache_filename);
      FREE(source_cache_filename);
    }
    self->source_cache_chunk = NULL;
    if (LYCacheSource == SOURCE_CACHE_MEMORY && source_cache_chunk) {
	self->source_cache_chunk = source_cache_chunk;
	source_cache_chunk = NULL;
    }

    /*
d773 1
d779 3
a781 2
    self->lines = LYlines;
    self->cols = LYcols;
d793 2
a794 1
	(anchor->address && !strcmp(anchor->address, LYlist_temp_url())))
d804 1
a804 1
#ifndef PSRC_TEST
d810 7
a816 1
    self->source=( LYpsrc ? psrc_view : HTOutputFormat == WWW_SOURCE);
d824 6
d843 2
a844 3
    if (anchor->charset)
	HText_setKcode(self, anchor->charset,
		       HTAnchor_getUCInfoStage(anchor, UCT_STAGE_HTEXT));
d872 1
a872 1
     * By this function we create HText object and set new Lines counter
d875 4
a878 2
    if (display_partial)
	 NumOfLines_partial = 0;  /* enable HTDisplayPartial() */
d890 3
a892 2
    CTRACE(tfp, "GridText: start HText_new\n");

d925 3
a927 1

d1042 9
a1058 17
#ifdef SOURCE_CACHE
    /*
     * Clean up the source cache, if any.
     */
    if (self->source_cache_file) {
	CTRACE(tfp, "Removing source cache file %s\n",
	       self->source_cache_file);
	LYRemoveTemp(self->source_cache_file);
	FREE(self->source_cache_file);
    }
    if (self->source_cache_chunk) {
	CTRACE(tfp, "Removing memory source cache %p\n",
	       (void *)self->source_cache_chunk);
	HTChunkFree(self->source_cache_chunk);
    }
#endif

d1070 1
a1070 1
PRIVATE int display_line ARGS2(
d1072 3
a1074 1
	HText *,	text)
d1080 1
d1083 16
a1099 1
    char LastDisplayChar = ' ';
d1107 1
a1107 1
    clrtoeol();
d1114 2
a1115 2
    if (j > (int)LYcols - 1)
	j = (int)LYcols - 1;
d1126 1
a1126 1
	addch (' ');
d1135 54
a1188 1
    while ((i < LYcols) && ((buffer[0] = *data) != '\0')) {
d1197 2
a1198 2
		LynxChangeStyle (CStyle.style,CStyle.direction,CStyle.previous);
		current_style++;
d1206 1
a1206 1
		    addch('_');
d1209 11
a1219 1
		    start_underline();
d1225 1
a1225 1
		    addch('_');
d1228 8
d1237 2
d1243 3
a1245 1
		start_bold();
d1249 3
a1251 1
		stop_bold ();
d1257 1
a1257 1
		    addch('+');
d1264 1
a1264 1
		    isspace((unsigned char)LastDisplayChar) ||
a1281 1
		    i++;
d1283 1
d1286 13
d1300 2
a1301 1
		if (text->T.output_utf8 && !isascii(buffer[0])) {
d1329 1
a1329 1
		    addstr(buffer);
d1333 5
a1337 1
		} else if (HTCJK != NOCJK && !isascii(buffer[0])) {
d1341 2
d1344 1
d1346 2
a1347 1
		    addstr(buffer);
d1362 1
a1362 1
		    addstr(buffer);
d1368 7
d1378 1
a1378 1
    addch('\n');
d1380 6
d1392 1
a1392 1
	LynxChangeStyle (CStyle.style, CStyle.direction, CStyle.previous);
d1410 2
a1411 1
    int i = 0, j = 0;
d1423 1
a1423 1
	LynxChangeStyle(s_title, STACK_ON, 0);
d1425 1
a1425 1
	LynxChangeStyle(s_title, ABS_ON, 0);
d1434 1
a1434 1
		  HTAnchor_title(text->node_anchor) : ""));
d1450 9
a1458 1
    if ((text->Lines + 1) > (display_lines)) {
d1488 1
a1488 1
	    (tmp = (unsigned char *)calloc(1, (strlen(title) + 1)))) {
d1505 28
a1532 8
    move(0, 0);
    clrtoeol();
    if (text->top_of_screen > 0 && HText_hasToolbar(text)) {
	addch('#');
    }
    i = (LYcols - 1) - strlen(percent) - strlen(title);
    if (i > 0) {
	move(0, i);
d1539 15
a1553 2
	title[((LYcols - 2) - strlen(percent))] = '\0';
	move(0, 1);
d1555 1
a1555 1
    addstr(title);
d1557 2
a1558 2
	addstr(percent);
    addch('\n');
d1563 1
a1563 1
    LynxChangeStyle(s_title, STACK_OFF, 0);
d1570 115
d1695 1
a1695 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d1701 1
d1721 3
a1723 3
	    addch('*');
	    refresh();
	    clear();
d1725 2
a1726 2
	addstr("\n\nError accessing document!\nNo data available!\n");
	refresh();
d1740 1
d1742 6
d1761 1
a1761 1
    for (i = 0, line = text->last_line->next;		/* Find line */
d1769 3
a1771 3
		addch('*');
		refresh();
		clear();
d1773 2
a1774 2
	    addstr("\n\nError drawing page!\nBad HText structure!\n");
	    refresh();
a1790 1
	charset_last_displayed = current_char_set;
a1791 1
#ifdef LINUX
a1796 1
#endif /* LINUX */
d1798 1
d1807 3
a1809 3
	addch('*');
	refresh();
	clear();
d1826 1
d1839 9
d1852 1
a1852 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d1854 8
a1861 1
	int offset, HitOffset, LenNeeded;
d1872 3
a1874 3
		    addch('*');
		    refresh();
		    clear();
d1876 2
a1877 2
		addstr("\n\nError drawing page!\nBad HText structure!\n");
		refresh();
d1889 1
a1889 1
		move((i + 2), 0);
d1892 1
a1892 1
	    display_line(line, text);
d1894 2
a1895 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d1903 6
a1908 12
		   (case_sensitive ?
		    (cp = LYno_attr_mbcs_strstr(data,
						target,
						text->T.output_utf8,
						&HitOffset,
						&LenNeeded)) != NULL :
		    (cp = LYno_attr_mbcs_case_strstr(data,
						     target,
						text->T.output_utf8,
						&HitOffset,
						&LenNeeded)) != NULL) &&
		   ((int)line->offset + LenNeeded) < LYcols) {
d1935 2
a1936 38
		    } else if (cp == &data[itmp]) {
			/*
			 *  First printable character of target.
			 */
			move((i + 1), x_pos);
			if (text->T.output_utf8 && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&line->data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
			if (utf_extra) {
			    strncpy(&tmp[1], &line->data[itmp+1], utf_extra);
			    tmp[utf_extra+1] = '\0';
			    itmp += utf_extra;
			    addstr(tmp);
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d1938 1
a1938 1
			     *  For CJK strings, by Masanobu Kimura.
d1940 1
a1940 7
			    tmp[1] = data[++itmp];
			    addstr(tmp);
			    tmp[1] = '\0';
			    written += 2;
			} else {
			    addstr(tmp);
			    written++;
a1941 2

		    } else if (&data[itmp] > cp) {
d1943 1
a1943 1
			 *  Output all the other printable target chars.
d1945 1
a1945 1
			if (text->T.output_utf8 && !isascii(tmp[0])) {
d1973 1
a1973 1
			    addstr(tmp);
d1977 1
a1977 1
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d1982 1
a1982 1
			    addstr(tmp);
d1986 1
a1986 1
			    addstr(tmp);
d2006 1
a2006 1
		move((i + 2), 0);
d2008 2
a2009 1
#endif /* FANCY CURSES || USE_SLANG */
d2020 2
a2021 2
		    move((i + 1), 0);
		    clrtoeol();
d2047 1
a2047 1
		Anchor_ptr->line_num <= line_number+(display_lines);
d2051 1
a2051 1
		Anchor_ptr->line_num < line_number+(display_lines)) {
d2084 3
a2086 3
				CTRACE(tfp,
				    "display_page: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address);
d2176 1
a2176 1
		    CTRACE(tfp,
d2178 1
a2178 1
			    Anchor_ptr->hightext);
d2196 1
a2196 1
	    CTRACE(tfp, "\ndisplay_page: MAXLINKS reached.\n");
d2224 1
a2224 1
	addstr("\n     Document is empty");
d2226 1
d2241 8
a2248 1
    if (HTCJK != NOCJK || text->T.output_utf8) {
d2251 4
d2256 1
a2256 1
	lynx_force_repaint();
d2258 1
a2258 2
    refresh();

d2276 16
d2311 240
a2550 3
PRIVATE void split_line ARGS2(
	HText *,	text,
	unsigned,	split)
a2554 3
#if defined(USE_COLOR_STYLE)
    int inew;
#endif
d2557 1
d2563 2
a2564 6
    int s;

#define DEBUG_SPLITLINE
    /*
     *  Make new line.
     */
d2567 1
d2571 4
a2576 1

d2578 1
d2582 2
a2583 2
    CTRACE(tfp,"GridText: split_line(%p,%d) called\n", text, split);
    CTRACE(tfp,"   bold_on=%d, underline_on=%d\n", bold_on, underline_on);
d2586 19
d2606 1
a2606 1
	CTRACE(tfp,
d2608 1
a2608 1
	       split, previous->size);
d2614 1
a2614 1
	    CTRACE(tfp, "                split adjusted to %d.\n", split);
d2630 15
a2644 5
    /*
     *  If we are not splitting and need an underline char, add it now. - FM
     */
    if ((split < 1) &&
	!(dump_output_immediately && use_underscore) && underline_on) {
d2648 1
d2650 1
a2650 4
    /*
     *  If we are not splitting and need a bold char, add it now. - FM
     */
    if ((split < 1) && bold_on) {
d2654 1
d2661 1
a2661 1
	char *p, *prevdata = previous->data, *linedata = line->data;
d2665 1
a2665 3
	/*
	 *  Split the line. - FM
	 */
d2674 16
a2689 7
	while ((*p == ' ' &&
		(HeadTrim || text->first_anchor ||
		 underline_on || bold_on ||
		 text->style->alignment != HT_LEFT ||
		 text->style->wordWrap || text->style->freeFormat ||
		 text->style->spaceBefore || text->style->spaceAfter)) ||
	       *p == LY_SOFT_HYPHEN) {
d2693 1
d2695 1
a2695 81

	/*
	 *  Add underline char if needed. - FM
	 */
	if (!(dump_output_immediately && use_underscore)) {
	    /*
	     * Make sure our global flag is correct. - FM
	     */
	    underline_on = NO;
	    for (i = (split-1); i >= 0; i--) {
		if (prevdata[i] == LY_UNDERLINE_END_CHAR) {
		    break;
		}
		if (prevdata[i] == LY_UNDERLINE_START_CHAR) {
		    underline_on = YES;
		    break;
		}
	    }
	    /*
	     *  Act on the global flag if set above. - FM
	     */
	    if (underline_on && *p != LY_UNDERLINE_END_CHAR) {
		linedata[line->size++] = LY_UNDERLINE_START_CHAR;
		linedata[line->size] = '\0';
		ctrl_chars_on_this_line++;
		SpecialAttrChars++;
	    }
	    if (plen) {
		for (i = (plen - 1); i >= 0; i--) {
		    if (p[i] == LY_UNDERLINE_START_CHAR) {
			underline_on = YES;
			break;
		    }
		    if (p[i] == LY_UNDERLINE_END_CHAR) {
			underline_on = NO;
			break;
		    }
		}
		for (i = (plen - 1); i >= 0; i--) {
		    if (p[i] == LY_UNDERLINE_START_CHAR ||
			p[i] == LY_UNDERLINE_END_CHAR) {
			ctrl_chars_on_this_line++;
		    }
		}
	    }
	}

	/*
	 *  Add bold char if needed, first making
	 *  sure that our global flag is correct. - FM
	 */
	bold_on = NO;
	for (i = (split - 1); i >= 0; i--) {
	    if (prevdata[i] == LY_BOLD_END_CHAR) {
		break;
	    }
	    if (prevdata[i] == LY_BOLD_START_CHAR) {
		bold_on = YES;
		break;
	    }
	}
	/*
	 *  Act on the global flag if set above. - FM
	 */
	if (bold_on && *p != LY_BOLD_END_CHAR) {
	    linedata[line->size++] = LY_BOLD_START_CHAR;
	    linedata[line->size] = '\0';
	    ctrl_chars_on_this_line++;
	    SpecialAttrChars++;
	}
	if (plen) {
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_BOLD_START_CHAR) {
		    bold_on = YES;
		    break;
		}
		if (p[i] == LY_BOLD_END_CHAR) {
		    bold_on = NO;
		    break;
		}
	    }
d2697 3
a2699 1
		if (p[i] == LY_BOLD_START_CHAR ||
d2701 1
a2701 2
		    IS_UTF_EXTRA(p[i]) ||
		    p[i] == LY_SOFT_HYPHEN) {
d2703 3
a2705 2
		}
		if (p[i] == LY_SOFT_HYPHEN && (int)text->permissible_split < i) {
a2706 1
		}
d2708 5
a2713 6

	/*
	 *  Add the data to the new line. - FM
	 */
	strcat(linedata, p);
	line->size += plen;
d2719 27
a2745 14
    while ((previous->size > 0) &&
	   (previous->data[previous->size-1] == ' ') &&
	   (ctrl_chars_on_this_line || HeadTrim || text->first_anchor ||
	    underline_on || bold_on ||
	    text->style->alignment != HT_LEFT ||
	    text->style->wordWrap || text->style->freeFormat ||
	    text->style->spaceBefore || text->style->spaceAfter)) {
	/*
	 *  Strip trailers.
	 */
	previous->data[previous->size-1] = '\0';
	previous->size--;
	TailTrim++;
    }
d2756 3
d2763 1
a2763 1
	CTRACE(tfp,"GridText: split_line(%d [now:%d]) called\n", split, s);
d2767 1
a2767 1
#define LastStyle (previous->numstyles-1)
d2769 17
a2785 117
    inew = MAX_STYLES_ON_LINE - 1;
    /*
     *  Color style changes after the split position + possible trimmed
     *  head characters are transferred to the new line.  Ditto for changes
     *  within the trimming region, but be stop when we reach an OFF change.
     *  The second while loop below may then handle remaining changes. - kw
     */
    while (previous->numstyles && inew >= 0) {
	if (previous->styles[LastStyle].horizpos > s + HeadTrim) {
	    line->styles[inew].horizpos =
		previous->styles[LastStyle].horizpos
		- (s + HeadTrim) + SpecialAttrChars;
	    line->styles[inew].direction = previous->styles[LastStyle].direction;
	    line->styles[inew].style = previous->styles[LastStyle].style;
	    inew --;
	    line->numstyles ++;
	    previous->numstyles --;
	} else if (previous->styles[LastStyle].horizpos > s - TailTrim &&
		   (previous->styles[LastStyle].direction == STACK_ON ||
		    previous->styles[LastStyle].direction == ABS_ON)) {
	    line->styles[inew].horizpos =
		(previous->styles[LastStyle].horizpos < s) ?
		0 : SpecialAttrChars;
	    line->styles[inew].direction = previous->styles[LastStyle].direction;
	    line->styles[inew].style = previous->styles[LastStyle].style;
	    inew --;
	    line->numstyles ++;
	    previous->numstyles --;
	} else
	    break;
    }
    spare = previous->numstyles;
    while (previous->numstyles && inew >= 0) {
	if (previous->numstyles >= 2 &&
	    previous->styles[LastStyle].style
	    == previous->styles[previous->numstyles-2].style &&
	    previous->styles[LastStyle].horizpos
	    == previous->styles[previous->numstyles-2].horizpos &&
	    ((previous->styles[LastStyle].direction == STACK_OFF &&
	      previous->styles[previous->numstyles-2].direction == STACK_ON) ||
	     (previous->styles[LastStyle].direction == ABS_OFF &&
	      previous->styles[previous->numstyles-2].direction == ABS_ON) ||
	     (previous->styles[LastStyle].direction == ABS_ON &&
	      previous->styles[previous->numstyles-2].direction == ABS_OFF)
		)) {
	    /*
	     *  Discard pairs of ON/OFF for the same color style, but only
	     *  if they appear at the same position. - kw
	     */
	    previous->numstyles -= 2;
	    if (spare > previous->numstyles)
		spare = previous->numstyles;
	} else if (spare > 0 && previous->styles[spare - 1].direction &&
		   previous->numstyles < MAX_STYLES_ON_LINE) {
	    /*
	     *  The index variable spare walks backwards through the
	     *  list of color style changes on the previous line, trying
	     *  to find an ON change which isn't followed by a
	     *  corresponding OFF.  When it finds one, the missing OFF
	     *  change is appended to the end, and an ON change is added
	     *  at the beginning of the current line.  The OFF change
	     *  appended to the previous line may get removed again in
	     *  the next iteration. - kw
	     */
	    line->styles[inew].horizpos = 0;
	    line->styles[inew].direction = ON;
	    line->styles[inew].style = previous->styles[spare - 1].style;
	    inew --;
	    line->numstyles ++;
	    previous->styles[previous->numstyles].style = line->styles[inew + 1].style;

	    previous->styles[previous->numstyles].direction = ABS_OFF;
	    previous->styles[previous->numstyles].horizpos = previous->size;
	    previous->numstyles++;
	    spare --;
	} else if (spare >= 2 &&
		   previous->styles[spare - 1].style == previous->styles[spare - 2].style &&
		   ((previous->styles[spare - 1].direction == STACK_OFF &&
		     previous->styles[spare - 2].direction == STACK_ON) ||
		    (previous->styles[spare - 1].direction == ABS_OFF &&
		     previous->styles[spare - 2].direction == ABS_ON) ||
		    (previous->styles[spare - 1].direction == STACK_ON &&
		     previous->styles[spare - 2].direction == STACK_OFF) ||
		    (previous->styles[spare - 1].direction == ABS_ON &&
		     previous->styles[spare - 2].direction == ABS_OFF)
		       )) {
	       /*
		*  Skip pairs of adjacent ON/OFF or OFF/ON changes.
		*/
	    spare -= 2;
	} else if (spare && !previous->styles[spare - 1].direction) {
	    /*
	     *  Found an OFF change not part of an adjacent matched pair.
	     *  Walk backward looking for the corresponding ON change.
	     *  If we find it, skip the ON/OFF and everything in between.
	     *  This can only work correctly if all changes are correctly
	     *  nested!  If this fails, assume it is safer to leave whatever
	     *  comes before the OFF on the previous line alone.  Setting
	     *  spare to 0 ensures that it won't be used in a following
	     *  iteration. - kw
	     */
	    int level=-1;
	    int itmp;
	    for (itmp = spare-1; itmp > 0; itmp--) {
		if (previous->styles[itmp - 1].style
		    == previous->styles[spare - 1].style) {
		    if (previous->styles[itmp - 1].direction == STACK_OFF) {
			level--;
		    } else if (previous->styles[itmp - 1].direction == STACK_ON) {
			if (++level == 0)
			    break;
		    } else
			break;
		}
	    }
	    if (level == 0)
		spare = itmp - 1;
d2787 3
a2789 6
		spare = 0;
	} else {
	    /*
	     *  Nothing applied, so we are done with the loop. - kw
	     */
	    break;
d2791 2
a2792 2
    }
    if (previous->numstyles > 0 && previous->styles[LastStyle].direction) {
d2794 64
a2857 3
	CTRACE(tfp, "%s\n%s%s\n",
		    "........... Too many character styles on line:",
		    "........... ", previous->data);
a2858 11
    if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	int n;
	inew ++;
	for (n = 0; n < line->numstyles; n++)
		line->styles[n] = line->styles[n + inew];
    } else
	if (line->numstyles == 0)
	/* FIXME: RJP - shouldn't use 0xffffffff for largest integer */
	line->styles[0].horizpos = 0xffffffff;
    if (previous->numstyles == 0)
	previous->styles[0].horizpos = 0xffffffff;
d2865 6
d2886 6
a2891 2
    if (style->alignment == HT_CENTER ||
	style->alignment == HT_RIGHT) {
d2902 4
d2907 1
a2907 1
	spare =  (LYcols-1) -
d2909 49
a2957 5
	    ctrl_chars_on_previous_line - previous->size -
	    ((previous->size > 0) &&
	     (int)(previous->data[previous->size-1] ==
		   LY_SOFT_HYPHEN ?
		   1 : 0));
d2974 17
a2990 1
    text->chars = text->chars + previous->size + 1;	/* 1 for the line */
d2998 1
a2998 1
    if (split > 0 || s > 0) {		/* if not completely empty */
d3000 11
d3013 20
a3032 8
		int old_e = a->extent;
		int a0 = a->line_pos, a1 = a->line_pos + a->extent;
		int S, d, new_pos, new_ext;
		if (a->link_type == INPUT_ANCHOR) {
		    if (a->line_pos >= s) {
			a->start += (1 + SpecialAttrChars - HeadTrim - TailTrim);
			a->line_pos -= (s - SpecialAttrChars + HeadTrim);
			a->line_num = text->Lines;
d3035 6
a3041 68
		if (a0 < s - TailTrim && a1 <= s - TailTrim) {
		    continue;	/* unaffected, leave it where it is. */
		}
		S = s + a->start - a->line_pos;
		d = S - s;	/* == a->start - a->line_pos */
		new_ext = old_e = a->extent;

		if (!old_e &&
		    (!a->number || a->show_anchor) &&
		    a0 <= s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,1);
#endif
		    /*
		     *  It is meant to be empty, and/or endAnchor
		     *  has seen it and recognized it as empty.
		     */
		    new_pos = (a0 <= s) ? s - TailTrim :
			s - TailTrim + 1;
		    if (prev_a && new_pos + d < prev_a->start) {
			if (prev_a->start <= S - TailTrim + 1 + SpecialAttrChars)
			    new_pos = prev_a->start - d;
			else
			    new_pos = s - TailTrim + 1 + SpecialAttrChars;
		    }
		} else if (old_e &&
		     a0 >= s - TailTrim && a0 <= s + HeadTrim &&
		     a1 <= s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,2);
#endif
		    /*
		     *  endAnchor has seen it, it is effectively empty
		     *  after our trimming, but endAnchor has for some
		     *  reason not recognized this.  In other words,
		     *  this should not happen.
		     *  Should we not adjust the extent and let it "leak"
		     *  into the new line?
		     */
		    new_pos = (a0 < s) ? s - TailTrim :
			s - TailTrim + 1;
		    if (prev_a && new_pos + d < prev_a->start) {
			if (prev_a->start <= S - TailTrim + 1 + SpecialAttrChars)
			    new_pos = prev_a->start - d;
			else
			    new_pos = s - TailTrim + 1 + SpecialAttrChars;
		    }
		    new_ext = 0;
		} else if (a0 >= s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,3);
#endif
		    /*
		     *  Completely after split, just shift.
		     */
		    new_pos = a0 - TailTrim + 1 - HeadTrim + SpecialAttrChars;
		} else if (!old_e) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,4);
#endif
		    /*
		     *  No extent set, we may still be growing it.
		     */
		    new_pos = s - TailTrim + 1 + SpecialAttrChars;
d3043 101
a3143 55
		    /*
		     *  Ok, it's neither empty, nor is it completely
		     *  before or after the split region (including trimmed
		     *  stuff).  So the anchor is either being split in
		     *  the middle, with stuff remaining on both lines,
		     *  or something is being nibbled off, either at
		     *  the end (anchor stays on previous line) or at
		     *  the beginning (anchor is on new line).  Let's
		     *  try in that order.
		     */
		} else if (a0 < s - TailTrim &&
			   a1 > s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,5);
#endif
		    new_pos = a0;
		    new_ext = old_e - TailTrim - HeadTrim + SpecialAttrChars;
		} else if (a0 < s - TailTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,6);
#endif
		    new_pos = a0;
		    new_ext = s - TailTrim - a0;
		} else if (a1 > s + HeadTrim) {
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "anchor %d case %d: ",
		       a->number,7);
#endif
		    new_pos = s - TailTrim + 1 + SpecialAttrChars;
		    new_ext = old_e - (s + HeadTrim - a0);
		} else {
		    CTRACE(tfp, "split_line anchor %d line %d: This should not happen!\n",
			   a->number, a->line_num);
		    CTRACE(tfp,
			   "anchor %d: (T,H,S)=(%d,%d,%d); (line,start,pos,ext):(%d,%d,%d,%d)!\n",
			   a->number,
			   TailTrim,HeadTrim,SpecialAttrChars,
			   a->line_num,a->start,a->line_pos,a->extent);
		    continue;
		}
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, "(T,H,S)=(%d,%d,%d); (line,start,pos,ext):(%d,%d,%d,%d",
		       TailTrim,HeadTrim,SpecialAttrChars,
		       a->line_num,a->start,a->line_pos,a->extent);
#endif
		if (new_pos != a->line_pos)
		    a->start = new_pos + d;
		if (new_pos > s - TailTrim) {
		    new_pos -= s - TailTrim + 1;
		    a->line_num = text->Lines;
		}
		a->line_pos = new_pos;
		a->extent = new_ext;
d3145 5
a3149 4
#ifdef DEBUG_SPLITLINE
		CTRACE(tfp, ")->(%d,%d,%d,%d)\n",
		       a->line_num,a->start,a->line_pos,a->extent);
#endif
d3151 3
d3155 32
d3188 40
a3227 1
    }
d3242 7
d3296 1
a3296 1
    CTRACE(tfp, "GridText: Change to style %s\n", style->name);
d3308 1
a3308 1
	char,		ch)
d3312 1
a3312 1
    int indent;
d3315 4
d3352 2
a3353 2
	    CTRACE(tfp, "add(%s %d special char) %d/%d\n", special, ch,
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE);
d3355 22
a3376 2
	    CTRACE(tfp, "add(%c) %d/%d\n", ch,
		   HTisDocumentSource(), HTOutputFormat != WWW_SOURCE);
d3406 97
d3506 1
a3506 1
    if (ch == CH_ESC && HTCJK == NOCJK)			/* decimal 27  S/390 -- gil -- 1504 */
d3508 1
d3519 1
a3519 1
    if ((unsigned char)ch >= 128 && HTCJK == NOCJK &&
d3521 1
a3521 1
	(unsigned char)ch < LYlowest_eightbit[current_char_set])
d3525 1
a3525 1
    if ((unsigned char)ch == 155 && HTCJK == NOCJK) {	/* octal 233 */
d3537 1
d3553 1
a3553 1
		case S_esc:
d3566 1
d3568 1
a3568 1
		case S_dollar:
d3574 2
d3585 1
a3585 1
		case S_dollar_paren:
d3597 1
a3597 1
		case S_paren:
d3614 1
d3621 1
a3621 1
		case S_nonascii_text:
d3628 3
d3632 6
d3646 1
a3646 1
		case S_jisx0201_text:
d3650 1
d3657 1
a3657 1
	}
d3664 22
a3685 5
		if ((text->kcode == SJIS) &&
		    ((unsigned char)ch >= 0xA1) &&
		    ((unsigned char)ch <= 0xDF)) {
		    unsigned char c = (unsigned char)ch;
		    unsigned char kb = (unsigned char)text->kanji_buf;
d3691 3
d3704 1
a3704 1
	    goto check_IgnoreExcess;
d3710 9
d3720 6
a3725 2
#ifndef USE_COLOR_STYLE
	if (line->size >= (MAX_LINE-1)) return;
d3764 5
a3768 5
		if (!IsSpecialAttrChar((unsigned char)line->data[i]) &&
		    !isspace((unsigned char)line->data[i]) &&
		    (unsigned char)line->data[i] != '-' &&
		    (unsigned char)line->data[i] != HT_NON_BREAK_SPACE &&
		    (unsigned char)line->data[i] != HT_EN_SPACE) {
d3776 6
d3791 56
a3846 5
    if (IS_UTF_EXTRA(ch)) {
	line->data[line->size++] = ch;
	line->data[line->size] = '\0';
	ctrl_chars_on_this_line++;
	return;
d3870 9
d3903 2
a3904 2
	int target;	/* Where to tab to */
	int here;
d3916 1
d3944 6
a3949 1
	if (target > (LYcols-1) - (int)style->rightIndent &&
d3957 2
d3971 3
a3973 1
    else {
d3978 10
a3987 3
	int target = (int)(line->offset + line->size);
	if ((target >= (LYcols-1) - style->rightIndent) &&
		HTisDocumentSource()) {
d3990 5
d3996 2
a4016 1
check_IgnoreExcess:
d4018 4
a4021 2
	((indent + (int)line->offset + (int)line->size) +
	(int)style->rightIndent - ctrl_chars_on_this_line) >= (LYcols-1))
d4029 1
d4033 9
a4041 1
					     1 : 0))) >= (LYcols - 1)) {
d4044 4
d4059 1
a4059 1
		if ((int)line->size >= (int)(MAX_LINE-1))
d4061 1
d4067 9
a4075 1
		new_line(text);
d4079 1
a4079 1
	 *  Never overrun memory if LYcols is set to a large value - KW
d4087 5
a4091 1
    if (ch == HT_NON_BREAK_SPACE) {
d4093 6
a4098 1
    }
d4103 3
d4111 1
d4113 76
a4188 8
	    hi = (unsigned char)text->kanji_buf, lo = (unsigned char)ch;
	    if (HTCJK == JAPANESE && text->kcode == NOKANJI) {
		if (IS_SJIS(hi, lo, text->in_sjis) && IS_EUC(hi, lo)) {
		    text->kcode = NOKANJI;
		} else if (IS_SJIS(hi, lo, text->in_sjis)) {
		    text->kcode = SJIS;
		} else if (IS_EUC(hi, lo)) {
		    text->kcode = EUC;
a4189 16
	    }
	    if (HTCJK == JAPANESE &&
		(kanji_code == EUC) && (text->kcode == SJIS)) {
		SJIS_TO_EUC1(hi, lo, tmp);
		line->data[line->size++] = tmp[0];
		line->data[line->size++] = tmp[1];
	    } else if (HTCJK == JAPANESE &&
		       (kanji_code == EUC) && (text->kcode == EUC)) {
		JISx0201TO0208_EUC(hi, lo, &hi, &lo);
		line->data[line->size++] = hi;
		line->data[line->size++] = lo;
	    } else if (HTCJK == JAPANESE &&
		       (kanji_code == SJIS) && (text->kcode == EUC)) {
		EUC_TO_SJIS1(hi, lo, tmp);
		line->data[line->size++] = tmp[0];
		line->data[line->size++] = tmp[1];
d4195 11
a4205 2
	} else if (HTCJK != NOCJK) {
	    line->data[line->size++] = (kanji_code != NOKANJI) ?
d4208 1
a4208 1
						   TOUPPER(ch) : ch;
d4211 1
a4211 1
		font & HT_CAPITALS ? TOUPPER(ch) : ch;
d4229 1
d4245 11
a4255 1
	if (line->numstyles < MAX_STYLES_ON_LINE) {
d4257 8
d4313 456
d4782 1
a4782 1
    TextAnchor * a = (TextAnchor *) calloc(1, sizeof(*a));
a4787 1
    a->start = text->chars + text->last_line->size;
d4809 1
a4809 1
	if (HTAnchor_followMainLink((HTAnchor*)anc)) {
d4819 3
d4823 1
a4823 1
	 keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)) {
a4829 1
	a->start = text->chars + text->last_line->size;
d4837 2
a4838 2

PUBLIC void HText_endAnchor ARGS2(
d4840 2
a4841 1
	int,		number)
d4873 2
a4874 2
    CTRACE(tfp, "HText_endAnchor: number:%d link_type:%d\n",
			a->number, a->link_type);
d4880 3
a4882 3
	CTRACE(tfp,
	   "HText_endAnchor: internal error: last anchor was input field!\n");
	return;
d4889 1
a4889 1
	BOOL remove_numbers_on_empty =
d4891 1
a4891 1
	      keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) &&
d4896 1
a4896 1
		   HTAnchor_followMainLink((HTAnchor *)a->anchor)))));
d4902 12
d4920 1
a4920 2
	a->extent += (text->chars + last->size) - a->start -
		     (text->Lines - a->line_num);
d4937 1
a4937 1
		!isspace((unsigned char)last->data[j]) &&
d4994 1
a4994 1
		    !isspace((unsigned char)prev->data[j]) &&
d5028 4
d5040 4
a5043 4
	    CTRACE(tfp,
		   "HText_endAnchor: hidden (line,start,pos,ext,BlankExtent):(%d,%d,%d,%d,%d)",
		   a->line_num,a->start,a->line_pos,a->extent,
		   BlankExtent);
d5094 1
a5094 1
		    while (j >= 0 && isdigit((unsigned char)start->data[j])) {
a5116 2
			if (start != last)
			    text->chars -= NumSize;
a5117 1
			    anc->start -= NumSize;
d5134 1
a5134 1
			       isdigit((unsigned char)prev->data[j])) {
a5151 4
			    text->chars -= l;
			    for (anc = a; anc; anc = anc->next) {
				anc->start -= l;
			    }
a5165 2
			    if (start != last)
				text->chars -= i;
a5166 1
				anc->start -= i;
d5199 1
a5199 1
			 isdigit((unsigned char)prev->data[j - 1]))) {
d5204 1
a5204 1
			       isdigit((unsigned char)prev->data[j])) {
a5221 4
			    text->chars -= NumSize;
			    for (anc = a; anc; anc = anc->next) {
				anc->start -= NumSize;
			    }
d5256 4
a5259 4
		CTRACE(tfp,
		   "HText_endAnchor: blanks (line,start,pos,ext,BlankExtent):(%d,%d,%d,%d,%d)",
		   a->line_num,a->start,a->line_pos,a->extent,
		   BlankExtent);
d5265 1
a5265 1
	     *  and special characters, so set it's number
d5280 1
a5280 1
	     *  content, but shorten it's extent by any trailing
d5287 2
a5288 2
	    CTRACE(tfp,
		   "->[%d](%d,%d,%d,%d,%d)\n",
d5290 2
a5291 2
		   a->line_num,a->start,a->line_pos,a->extent,
		   BlankExtent);
d5294 2
d5304 8
d5314 13
d5346 1
a5346 1
PRIVATE void remove_special_attr_chars ARGS1(
d5350 1
d5356 1
d5363 1
d5381 1
a5381 1
    CTRACE(tfp,"Gridtext: Entering HText_endAppend\n");
d5389 2
d5398 6
d5409 1
a5409 1
    line_ptr = text->last_line->next;
d5417 2
a5418 3

	CTRACE(tfp, "GridText: Removing bottom blank line: %s\n",
			    text->last_line->data);
d5427 2
a5428 2
	CTRACE(tfp, "GridText: New bottom line: %s\n",
			    text->last_line->data);
d5435 1
a5435 1
    HText_trimHightext(text, TRUE);
d5458 2
a5459 2
**  hightext2) fields (which should be NULL up to this point), with
**  special attribute chars removed.
d5463 1
a5463 1
PUBLIC void HText_trimHightext ARGS2(
d5465 2
a5466 1
	BOOLEAN,	final)
d5468 1
a5468 1
    int cur_line, cur_char, cur_shift;
d5477 9
a5485 2
    CTRACE(tfp,"Gridtext: Entering HText_trimHightext %s\n",
	       final ? "(final)" : "(partial)");
d5490 1
a5490 2
    line_ptr = text->last_line->next;
    cur_char = line_ptr->size;
d5500 1
d5505 2
a5506 4
	for (; anchor_ptr->start > cur_char;
	       line_ptr = line_ptr->next,
	       cur_char += line_ptr->size+1,
	       cur_line++) {
d5516 1
a5516 1
	    if (cur_line >= text->Lines)
d5518 2
a5519 1
	    if (anchor_ptr->start >= text->chars - 1)
d5540 1
a5540 1
	if (anchor_ptr->start == cur_char) {
a5541 3
	} else {
	    anchor_ptr->line_pos = anchor_ptr->start -
				   (cur_char - line_ptr->size);
a5543 1
	    anchor_ptr->start -= anchor_ptr->line_pos;
d5547 1
a5547 1
	CTRACE(tfp,
d5550 1
a5550 1
	       anchor_ptr->number, anchor_ptr->extent);
d5558 1
a5558 1
	    ch = (unsigned char)line_ptr->data[anchor_ptr->line_pos];
d5564 1
a5564 1
		ch = (unsigned char)line_ptr->data[anchor_ptr->line_pos];
a5569 1
	anchor_ptr->start += cur_shift;
d5571 1
a5571 2
	CTRACE(tfp, "anchor text: '%s'\n",
					   line_ptr->data);
d5583 5
a5587 3
		 (prev_a && prev_a->start > anchor_ptr->start))) {
		anchor_ptr->start++;
		CTRACE(tfp, "found anchor at end of line\n");
d5590 1
a5590 1
		CTRACE(tfp, "found anchor at end of line, leaving it there\n");
d5614 1
a5614 1
		if (cur_line + 1 >= text->Lines) {
d5629 4
a5632 1
		remove_special_attr_chars(anchor_ptr->hightext2);
d5653 1
a5653 1
	    for (; i < anchor_ptr->line_pos; i++)
d5655 1
a5655 1
		    IsSpecialAttrChar(line_ptr->data[i]))
d5657 3
d5669 4
a5672 1
	CTRACE(tfp, "GridText:     add link on line %d col %d [%d] %s\n",
d5674 1
a5674 1
	       anchor_ptr->number, "in HText_trimHightext");
a5684 9
/*	Dump diagnostics to tfp
*/
PUBLIC void HText_dump ARGS1(
	HText *,	text GCC_UNUSED)
{
    fprintf(tfp, "HText: Dump called\n");
}


d5814 3
a5816 3
    CTRACE(tfp, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",
	   num, rel, cur, HTMainText);
    CTRACE(tfp,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",
d5818 1
a5818 1
	   on_screen ? "on_screen" : "0");
d5824 1
a5824 1
	CTRACE(tfp,"curanchor=%d at line %d on screen\n",curanchor,curline);
d5834 1
a5834 1
	CTRACE(tfp,"  a->line_num=%d, a->number=%d\n",a->line_num,a->number);
d5840 1
a5840 1
    CTRACE(tfp,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor);
d5902 2
a5903 2
	    (a->link_type != INPUT_ANCHOR ||
	     a->input_field->type != F_HIDDEN_TYPE)) {
d6004 2
a6005 2
				CTRACE(tfp, "HTGetLinkInfo: unexpected typed link to %s!\n",
					    link_dest_intl->parent->address);
d6053 2
a6054 1
	formA->type != F_TEXTAREA_TYPE || formB->type != F_TEXTAREA_TYPE) {
d6061 1
a6061 1
    return(strcmp(formA->name, formB->name) == 0);
d6064 1
a6064 1
#define same_anchor_as_link(i,a) (i >= 0 && a &&\
d6069 2
a6070 2
		ta_skip))
#define same_anchors(a1,a2) (a1 && a2 &&\
d6075 42
a6116 1
		ta_skip))
d6179 2
a6180 2
	    (a->link_type != INPUT_ANCHOR ||
	     a->input_field->type != F_HIDDEN_TYPE)) {
d6194 1
a6194 1
	    if (!same_anchors(current.anc, a)) {
d6207 1
a6207 1
		if (same_anchor_as_link(curlink,a)) {
d6216 1
a6216 1
			   same_anchor_as_link(curlink,previous.anc)) {
a6310 7
#if 0
	    if (*go_line > HTMainText->top_of_screen &&
		*go_line < HTMainText->top_of_screen+(display_lines) &&
		HTMainText->top_of_screen+(display_lines) <= a->line_num &&
		HTMainText->top_of_screen+2*(display_lines) <= HTMainText->Lines)
		*go_line = HTMainText->top_of_screen+(display_lines);
#endif
d6327 1
a6327 1
 *  *data with all IsSpecial characters stripped, it's offset and
d6339 1
a6339 1
	char *,		target)
d6357 1
a6357 1
    for (i = 0, line = text->last_line->next;
d6375 6
a6380 12
    if ((case_sensitive ?
	 (cp = LYno_attr_mbcs_strstr(LineData,
				     target,
				     utf_flag,
				     &HitOffset,
				     &LenNeeded)) != NULL :
	 (cp = LYno_attr_mbcs_case_strstr(LineData,
				     target,
				     utf_flag,
				     &HitOffset,
				     &LenNeeded)) != NULL) &&
	(LineOffset + LenNeeded) < LYcols) {
d6419 1
a6419 1
#ifdef USE_HASH
d6457 1
d6460 2
a6461 1
    BOOLEAN method = 0;
d6466 1
a6466 1
    if (!(fn && *fn && anchor))
d6472 2
a6473 6
    if ((cp = strrchr(fn, '/')) != NULL) {
	fn = (cp +1);
	if (*fn == '\0') {
	    return;
	}
    }
d6481 1
a6481 1
    if (ce == NULL) {
d6486 21
a6506 21
	if (!strncasecomp((ct ? ct : ""), "application/gzip", 16) ||
	    !strncasecomp((ct ? ct : ""), "application/x-gzip", 18)) {
	    method = 1;
	} else if (!strncasecomp((ct ? ct : ""),
				 "application/compress", 20) ||
		   !strncasecomp((ct ? ct : ""),
				 "application/x-compress", 22)) {
	    method = 2;
	}
    } else if (!strcasecomp(ce, "gzip") ||
	       !strcasecomp(ce, "x-gzip")) {
	    /*
	     *  It's gzipped. - FM
	     */
	    method = 1;
    } else if (!strcasecomp(ce, "compress") ||
	       !strcasecomp(ce, "x-compress")) {
	    /*
	     *  It's Unix compressed. - FM
	     */
	    method = 2;
d6514 11
a6524 1
    if (method == 0 && !strip_ok)
d6526 1
d6533 2
a6534 4
	if (!strcasecomp(dot, ".tgz") ||
	    !strcasecomp(dot, ".gz") ||
	    !strcasecomp(dot, ".Z")) {
	    if (!method) {
a6539 1
		cp = (dot + 1);
a6540 3
		if (!strcasecomp(cp, "tgz")) {
		    StrAllocCat(*fname, ".tar");
		}
d6544 16
a6559 17
	if (strlen(dot) > 4) {
	    cp = ((dot + strlen(dot)) - 3);
	    if (!strcasecomp(cp, "-gz") ||
		!strcasecomp(cp, "_gz")) {
		if (!method) {
		    /*
		     *  It has a tail which signifies a gzipped
		     *  file for us, but the anchor claims otherwise,
		     *  so tweak the suffix. - FM
		     */
		    *dot = '\0';
		} else {
		    /*
		     *  The anchor claims it's gzipped, and we
		     *  believe it, so force this tail to the
		     *  conventional suffix. - FM
		     */
d6561 1
a6561 1
		    *cp = '-';
d6563 1
a6563 1
		    *cp = '.';
d6565 4
a6568 34
		    cp++;
		    *cp = TOLOWER(*cp);
		    cp++;
		    *cp = TOLOWER(*cp);
		}
		return;
	    }
	}
	if (strlen(dot) > 3) {
	    cp = ((dot + strlen(dot)) - 2);
	    if (!strcasecomp(cp, "-Z") ||
		!strcasecomp(cp, "_Z")) {
		if (!method) {
		    /*
		     *  It has a tail which signifies a compressed
		     *  file for us, but the anchor claims otherwise,
		     *  so tweak the suffix. - FM
		     */
		    *dot = '\0';
		} else {
		    /*
		     *  The anchor claims it's compressed, and
		     *  we believe it, so force this tail to the
		     *  conventional suffix. - FM
		     */
#ifdef VMS
		    *cp = '-';
#else
		    *cp = '.';
#endif /* VMS */
		    cp++;
		    *cp = TOUPPER(*cp);
		}
		return;
d6570 1
d6573 14
a6586 7
    if (!method) {
	/*
	 *  Don't know what compression method
	 *  was used, if any, so we won't do
	 *  anything. - FM
	 */
	return;
d6592 7
a6598 9
    if (!dot) {
	StrAllocCat(*fname, ((method == 1) ? ".gz" : ".Z"));
	return;
    }
    dot++;
    if (*dot == '\0') {
	StrAllocCat(*fname, ((method == 1) ? "gz" : "Z"));
	return;
    }
d6600 1
a6600 3
    StrAllocCat(*fname, ((method == 1) ? "-gz" : "-Z"));
#else
    StrAllocCat(*fname, ((method == 1) ? ".gz" : ".Z"));
d6602 2
a6603 1
    return;
d6647 1
a6647 1
	CTRACE(tfp, "GridText: HText_pageDisplay at line %d started\n", line_num);
d6651 1
d6661 3
a6663 1
	HText_trimHightext(HTMainText, FALSE);
d6671 1
a6671 1
	sleep(MessageSecs);
d6678 1
a6678 1
	CTRACE(tfp, "GridText: HText_pageDisplay finished\n");
d6718 2
a6719 2
	    (Anchor_ptr->link_type != INPUT_ANCHOR ||
	     Anchor_ptr->input_field->type != F_HIDDEN_TYPE))
d6750 1
a6750 1
    return (text->top_of_screen != 0);
d6757 2
a6758 2
    return (text != 0)
     && ((text->top_of_screen + display_lines) < text->Lines+1);
a6793 16
PRIVATE int line_for_char ARGS2(
	HText *,	text,
	int,		char_num)
{
    int line_number = 0;
    int characters = 0;
    HTLine * line = text->last_line->next;
    for (;;) {
	if (line == text->last_line) return 0;	/* Invalid */
	characters = characters + line->size + 1;
	if (characters > char_num) return line_number;
	line_number ++;
	line = line->next;
    }
}

a6797 3
	HTMainText = text;
	HTMainAnchor = text->node_anchor;

d6815 21
d6841 2
a6842 2
	  /* let lynx do it */
	/* display_page(text, text->top_of_screen, ""); */
d6904 4
a6907 4
		CTRACE(tfp,
		       "HText: Selecting anchor [%d] at character %d, line %d\n",
				     a->number, a->start, www_search_result);
		if (!strcmp(selector, LYToolbarName))
d6909 2
a6910 2

		 return(YES);
d6935 1
a6935 1
	CTRACE(tfp, "HText: No such anchor in this text!\n");
d6945 4
a6948 4
	 int l = line_for_char(text, a->start);
	 CTRACE(tfp,
	    "HText: Selecting anchor [%d] at character %d, line %d\n",
	    a->number, a->start, l);
d7050 2
a7051 2
      HText * text = HTMainText;
      return text != 0 ? text->top_of_screen : 0;
d7057 1
a7057 1
      return text->Lines;
d7093 1
a7093 1
    char *new;
d7100 1
a7100 3
    if ((new = (char *)calloc(1, (strlen(query) + 1))) == NULL)
	outofmem(__FILE__, "HTAddSearchQuery");
    strcpy(new, query);
d7107 1
a7107 1
	HTList_addObject(search_queries, new);
d7113 1
a7113 1
	if (!strcmp(old, new)) {
d7119 1
a7119 1
    HTList_addObject(search_queries, new);
d7142 1
a7142 1
	strcpy(searchstring, ++cp);
d7172 1
a7172 1
	       (!PreviousSearch && QueryTotal >= 1)) ? RECALL : NORECALL);
d7198 1
a7198 1
		strcpy(searchstring, cp);
d7229 1
a7229 1
		strcpy(searchstring, cp);
d7282 3
a7284 5
#ifndef VMS
#ifdef SYSLOG_REQUESTED_URLS
    syslog(LOG_INFO|LOG_LOCAL5, "%s", tmpaddress);
#endif /* SYSLOG_REQUESTED_URLS */
#endif /* !VMS */
d7305 1
a7305 1
	CTRACE(tfp,"\ndo_www_search: newfile: %s\n",doc->address);
d7323 27
d7358 1
a7358 1
	int,		is_reply)
d7363 10
d7377 1
a7377 1
    line = HTMainText->last_line->next;
d7379 1
a7379 2
	if (!first
	 && line->data[0] != LY_SOFT_NEWLINE)
d7381 6
a7386 7
	first = FALSE;

	/*
	 *  Add news-style quotation if requested. - FM
	 */
	if (is_reply) {
	    fputc('>',fp);
d7389 2
a7390 6
	/*
	 *  Add offset.
	 */
	for (i = 0; i < (int)line->offset; i++) {
	     fputc(' ', fp);
	}
d7397 11
d7411 1
a7411 10
		if (dump_output_immediately &&
		    LYRawMode &&
		    LYlowest_eightbit[current_char_set] <= 173 &&
		    (LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
		     LYCharSet_UC[current_char_set].like8859 &
				  UCT_R_8859SPECL)) {
		    fputc(0xad, fp); /* the iso8859 byte for SHY */
		} else {
		    fputc('-', fp);
		}
d7423 21
d7475 1
a7475 1
    line = HTMainText->last_line->next;
d7482 1
a7482 2
	if (!first
	 && line->data[0] != LY_SOFT_NEWLINE)
d7485 1
a7485 6
	/*
	 *  Add offset.
	 */
	for (i = 0; i < (int)line->offset; i++) {
	    fputc(' ', fp);
	}
d7495 2
a7496 11
		if (dump_output_immediately &&
		    LYRawMode &&
		    LYlowest_eightbit[current_char_set] <= 173 &&
		    (LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
		     LYCharSet_UC[current_char_set].like8859 &
				  UCT_R_8859SPECL)) {
		    fputc(0xad, fp); /* the iso8859 byte for SHY */
		} else {
		    fputc('-', fp);
		}
	     }
d7510 1
a7510 1
	 keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)) {
d7530 1
a7530 1
	BOOL on_screen = (tentative_result > HTMainText->top_of_screen &&
d7580 142
a7721 5
	    www_search_result = tentative_result - max_offset;
	if (www_search_result == doc->line) {
	    if (nl_closest >= 0) {
		doc->link = nl_closest;
		return;
d7725 1
d7728 1
a7728 20
/*
   John Bley, April 1, 1999 (No joke)
   www_user_search_internals was spawned from www_user_search to
   remove a cut-n-paste coding hack: basically, this entire function
   was duplicated at the two points that www_user_search now calls it.
   And, because www_user_search has a return value defined as modification
   of the screen and some global values, and since it used an awkward for(;;)
   construct, this method has to distinguish between when it's "really"
   returning and when it's just falling through via a break; in the
   infinite-for-loop.  So, basically, we have a large amount of arguments
   since this loop used to be directly in www_user_search, and we return
   1 to say we're "really" returning and 0 to indicate we fell through.
   Also, due to exactly one difference between the first pass of this
   code and the second pass, we have the "firstpass" argument, which is
   true iff it's the first pass.

   I hate cut-n-paste coding.
 */
PRIVATE int www_user_search_internals ARGS8(
	int,		firstpass,
a7731 1
	TextAnchor *,	a,
d7733 1
a7733 2
	int *,		count,
	int *,		tentative_result)
d7735 3
a7737 2
    OptionType * option;
    char *stars = NULL, *cp;
d7740 1
a7740 1
	while ((a != NULL) && a->line_num == (*count - 1)) {
d7742 4
a7745 7
		(a->link_type != INPUT_ANCHOR ||
		 a->input_field->type != F_HIDDEN_TYPE)) {
		if (((a->hightext != NULL && case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(a->hightext, target)) ||
		    ((a->hightext != NULL && case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(a->hightext, target))) {
		    adjust_search_result(doc, *count, start_line);
d7748 41
a7788 5
		if (((a->hightext2 != NULL && case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(a->hightext2, target)) ||
		    ((a->hightext2 != NULL && case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(a->hightext2, target))) {
		    adjust_search_result(doc, *count, start_line);
a7790 104

		/*
		 *  Search the relevant form fields, taking the
		 *  case_sensitive setting into account. - FM
		 */
		if ((a->input_field != NULL && a->input_field->value != NULL) &&
		    a->input_field->type != F_HIDDEN_TYPE) {
		    if (a->input_field->type == F_PASSWORD_TYPE) {
			/*
			 *  Check the actual, hidden password, and then
			 *  the displayed string. - FM
			 */
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(a->input_field->value,
						   target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(a->input_field->value,
							target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
			StrAllocCopy(stars, a->input_field->value);
			for (cp = stars; *cp != '\0'; cp++)
			    *cp = '*';
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(stars, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(stars, target))) {
			    FREE(stars);
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
			FREE(stars);
		   } else if (a->input_field->type == F_OPTION_LIST_TYPE) {
			/*
			 *  Search the option strings that are displayed
			 *  when the popup is invoked. - FM
			 */
			option = a->input_field->select_list;
			while (option != NULL) {
			    if (((option->name != NULL &&
				  case_sensitive == TRUE) &&
				 LYno_attr_char_strstr(option->name,
						       target)) ||
				((option->name != NULL &&
				  case_sensitive == FALSE) &&
				 LYno_attr_char_case_strstr(option->name,
							    target))) {
				adjust_search_result(doc, *count, start_line);
				return 1;
			    }
			    option = option->next;
			}
		    } else if (a->input_field->type == F_RADIO_TYPE) {
			/*
			 *  Search for checked or unchecked parens. - FM
			 */
			if (a->input_field->num_value) {
			    cp = checked_radio;
			} else {
			    cp = unchecked_radio;
			}
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(cp, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(cp, target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
		    } else if (a->input_field->type == F_CHECKBOX_TYPE) {
			/*
			 *  Search for checked or unchecked
			 *  square brackets. - FM
			 */
			if (a->input_field->num_value) {
			    cp = checked_box;
			} else {
			    cp = unchecked_box;
			}
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(cp, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(cp, target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
		    } else {
			/*
			 *  Check the values intended for display.
			 *  May have been found already via the
			 *  hightext search, but make sure here
			 *  that the entire value is searched. - FM
			 */
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(a->input_field->value,
						   target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(a->input_field->value,
							target))) {
			    adjust_search_result(doc, *count, start_line);
			    return 1;
			}
		    }
		}
d7792 1
a7792 4
	    a = a->next;
	}
	if (a != NULL && a->line_num <= (*count - 1)) {
	    a = a->next;
d7795 2
a7796 10
	if (case_sensitive && LYno_attr_char_strstr(line->data, target)) {
	    *tentative_result = *count;
	    break;
	} else if (!case_sensitive &&
		   LYno_attr_char_case_strstr(line->data, target)) {
	    *tentative_result = *count;
	    break;
	/* Note: this is where the two passes differ */
	} else if (firstpass && line == HTMainText->last_line) {
	    /* next line */
d7798 1
a7798 1
	} else if (!firstpass && *count > start_line) {
d7800 4
a7803 4
	    return 1;			/* end */
	} else {			/* end */
	    line = line->next;
	    (*count)++;
d7805 5
a7810 1
    /* No, man, we just fell through.  You want to call us again. */
d7814 1
a7814 1
PUBLIC void www_user_search ARGS3(
d7817 2
a7818 1
	char *,		target)
a7821 2
    int tentative_result = -1;
    TextAnchor *a;
d7830 8
a7837 6
    line = HTMainText->last_line->next;
    for (count = 1; count <= start_line; line = line->next, count++) {
	if (line == HTMainText->last_line) {
	    line = HTMainText->last_line->next; /* set to first line */
	    count = 1;
	    break;
d7839 3
a7841 8
    }
    a = HTMainText->first_anchor;
    while (a && a->line_num < count - 1) {
	a = a->next;
    }
    if (www_user_search_internals(1, start_line, doc, target,
	a, line, &count, &tentative_result) == 1) {
	return; /* Return the www_user_search_internals result */
d7844 4
a7847 18
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
	return;
    }
    /* That didn't work, search from the beginning instead */
    line = HTMainText->last_line->next; /* set to first line */
    count = 1;
    a = HTMainText->first_anchor;
    while (a && a->line_num < count - 1) {
	a = a->next;
    }
    if (www_user_search_internals(0, start_line, doc, target,
	a, line, &count, &tentative_result) == 1) {
	return; /* Return the www_user_search_internals result */
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
d7861 1
a7861 1
    HTSprintf(&temp, message, (argument == 0) ? "" : argument);
d7953 1
a7953 1
	CTRACE(tfp, "\rHTuncache.. freeing document for '%s'%s\n",
d7959 1
a7959 1
				      " with POST data" : ""));
d7964 1
a7964 1
	CTRACE(tfp, "HTuncache.. HTMainText already is NULL!\n");
d7969 3
d7976 1
a7976 1
    if (!HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d7978 1
a7978 1
	 !HTMainText->source_cache_file) ||
d7980 1
a7980 1
	 !HTMainText->source_cache_chunk))
d7983 1
a7983 1
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainText->source_cache_file) {
d7988 10
a7997 2
	CTRACE(tfp, "Reparsing source cache file %s\n",
	       HTMainText->source_cache_file);
d8003 2
a8004 2
	if (HTMainText->node_anchor->content_type) {
	    format = HTAtom_for(HTMainText->node_anchor->content_type);
d8006 2
a8007 2
	    format = HTFileFormat(HTMainText->source_cache_file, NULL, NULL);
	    format = HTCharsetFormat(format, HTMainText->node_anchor,
d8013 1
a8013 1
	CTRACE(tfp, "  Content type is \"%s\"\n", format->name);
d8015 1
a8015 8
	/*
	 * Pass the source cache filename on to the next HText.  Mark it
	 * NULL here so that it won't get deleted by HText_free().
	 */
	source_cache_filename = HTMainText->source_cache_file;
	HTMainText->source_cache_file = NULL;

	fp = fopen(source_cache_filename, "r");
d8017 3
a8019 2
	    CTRACE(tfp, "  Cannot read file %s\n", source_cache_filename);
	    FREE(source_cache_filename);
d8022 1
a8022 4
#ifdef DISP_PARTIAL
	display_partial = display_partial_flag;  /* restore */
	Newline_partial = Newline;  /* initialize */
#endif
d8029 11
a8039 6
	ret = HTParseFile(format, HTOutputFormat, HTMainText->node_anchor,
			  fp, NULL);
	fclose(fp);
	ok = (ret == HT_LOADED);
	if (!ok) {
	    FREE(source_cache_filename);
d8041 1
d8045 1
a8045 1
	HTMainText->source_cache_chunk) {
d8049 10
a8058 2
	CTRACE(tfp, "Reparsing from source memory cache %p\n",
	       (void *)HTMainText->source_cache_chunk);
d8060 3
d8071 3
a8073 2
	format = HTCharsetFormat(format, HTMainText->node_anchor,
					 UCLYhndl_for_unspec);
a8075 11
	/*
	 * Pass the source cache HTChunk on to the next HText.  Clear it
	 * here so that it won't get deleted by HText_free().
	 */
	source_cache_chunk = HTMainText->source_cache_chunk;
	HTMainText->source_cache_chunk = NULL;

#ifdef DISP_PARTIAL
	display_partial = display_partial_flag;  /* restore */
	Newline_partial = Newline;  /* initialize */
#endif
d8082 9
a8090 7
	ret = HTParseMem(format, HTOutputFormat, HTMainText->node_anchor,
			 source_cache_chunk, NULL);
	ok = (ret == HT_LOADED);
	if (!ok) {
	    HTChunkFree(source_cache_chunk);
	    source_cache_chunk = NULL;
	}
d8093 1
a8093 5
    CTRACE(tfp, "Reparse %s\n", (ok ? "succeeded" : "failed"));

    if (ok)  {
	from_source_cache = TRUE;  /* flag for mainloop events */
    }
d8100 1
a8100 1
    if (!HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d8102 1
a8102 1
	 !HTMainText->source_cache_file) ||
d8104 1
a8104 1
	 !HTMainText->source_cache_chunk))
d8107 2
a8108 9
    if (LYCacheSource == SOURCE_CACHE_FILE && HTMainText->source_cache_file) {
	FILE * fp;

	fp = fopen(HTMainText->source_cache_file, "r");
	if (!fp) {
	    return FALSE;
	}
	fclose(fp);
	return TRUE;
d8112 1
a8112 1
	HTMainText->source_cache_chunk) {
d8121 2
a8122 2
	BOOLEAN,	prev_setting,
	BOOLEAN,	new_setting)
d8125 2
a8126 2
	CTRACE(tfp, "HTdocument_settings_changed: %s setting has changed (was %s, now %s)\n",
	       name, prev_setting ? "ON" : "OFF", new_setting ? "ON" : "OFF");
d8135 1
a8135 1
    if (!HTMainText || LYCacheSource == SOURCE_CACHE_NONE ||
d8137 1
a8137 1
	 !HTMainText->source_cache_file) ||
d8139 1
a8139 1
	 !HTMainText->source_cache_chunk))
d8151 3
d8164 4
a8167 2
	if (HTMainText->lines != LYlines || HTMainText->cols != LYcols)
	    CTRACE(tfp,
d8169 1
a8169 1
		   HTMainText->cols, HTMainText->lines, LYcols, LYlines);
d8174 1
d8177 2
a8178 1
	    HTMainText->minimal_comments != minimal_comments ||
d8181 2
a8182 2
	    HTMainText->lines != LYlines ||
	    HTMainText->cols != LYcols);
d8295 8
d8329 1
a8329 1
	    if (!IsSpecialAttrChar((unsigned char)line->data[i]) &&
d8331 5
a8335 5
		 (unsigned char)line->data[i] < 128 ||
		 ((unsigned char)(line->data[i] & 0xc0) == 0xc0)) &&
		!isspace((unsigned char)line->data[i]) &&
		(unsigned char)line->data[i] != HT_NON_BREAK_SPACE &&
		(unsigned char)line->data[i] != HT_EN_SPACE) {
d8343 2
a8344 2
		 (unsigned char)line->data[i] < 128 ||
		 ((unsigned char)(line->data[i] & 0xc0) == 0xc0))) {
a8393 2
    text->chars -= ((data && *data == '\0') ?
					  1 : strlen(line->data) + 1);
d8423 1
a8423 1
    int column = (LYcols-2);
d8425 2
a8426 2
	column = ((int)text->style->rightIndent ? (LYcols-2) :
		  ((LYcols-1) - (int)text->style->rightIndent));
d8459 1
a8459 1
	Tab = (HTTabID *)calloc(1, sizeof(HTTabID));
d8648 1
a8648 1
    newform = (PerFormInfo *)calloc(1, sizeof(PerFormInfo));
d8656 1
a8656 1
    CTRACE(tfp, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
d8663 1
a8663 1
		(HTFormAcceptCharset ? HTFormAcceptCharset : ""));
d8721 1
a8721 1
	CTRACE(tfp, "endForm:    HTCurrentForm is missing!\n");
d8741 5
a8745 5
   /*
    *  Save the group name.
    */
   StrAllocCopy(HTCurSelectGroup, name);
   HTCurSelectGroupCharset = name_cs;
d8747 10
a8756 10
   /*
    *  If multiple then all options are actually checkboxes.
    */
   if (multiple)
      HTCurSelectGroupType = F_CHECKBOX_TYPE;
   /*
    *  If not multiple then all options are radio buttons.
    */
   else
      HTCurSelectGroupType = F_RADIO_TYPE;
d8763 1
a8763 1
    CTRACE(tfp,"HText_beginSelect: name=%s type=%d size=%s\n",
d8768 2
a8769 2
				      "<NULL>" : HTCurSelectGroupSize));
    CTRACE(tfp,"HText_beginSelect: name_cs=%d \"%s\"\n",
d8772 1
a8772 1
		 LYCharSet_UC[HTCurSelectGroupCharset].MIMEname : "<UNKNOWN>"));
d8797 1
a8797 1
    CTRACE(tfp, "HText_getOptionNum: Got number '%d'.\n", n);
d8814 1
a8814 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d8826 2
a8827 2
	    *cp && isdigit(*cp++)) {
	    while (*cp && isdigit(*cp))
d8874 2
a8875 2
	CTRACE(tfp, "HText_setLastOptionValue: invalid call!  value:%s!\n",
		    (value ? value : "<NULL>"));
d8879 2
a8880 2
    CTRACE(tfp, "Entering HText_setLastOptionValue: value:%s, checked:%s\n",
		value, (checked ? "on" : "off"));
d8887 2
a8888 2
	while ((cp >= value) && (isspace((unsigned char)*cp) ||
				 IsSpecialAttrChar((unsigned char)*cp)))
d8897 2
a8898 2
    while (isspace((unsigned char)*cp) ||
	   IsSpecialAttrChar((unsigned char)*cp))
d8902 1
a8902 1
	keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d8909 2
a8910 2
	    while (isspace((unsigned char)cp1[i]) ||
		   IsSpecialAttrChar((unsigned char)cp1[i])) {
d8957 4
a8960 4
		CTRACE(tfp, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
			    F_OPTION_LIST_TYPE);
		CTRACE(tfp, "                          but %d, ignoring!\n",
			    text->last_anchor->input_field->type);
d8965 1
a8965 1
				(OptionType *)calloc(1, sizeof(OptionType));
d8973 1
a8973 1
		op_ptr=op_ptr->next;
d8977 1
a8977 2
	    op_ptr->next = new_ptr =
				(OptionType *)calloc(1, sizeof(OptionType));
d8990 2
a8991 2
	while (isspace((unsigned char)*cp) ||
	       IsSpecialAttrChar((unsigned char)*cp))
d8998 1
a8998 1
		       !IsSpecialAttrChar((unsigned char)cp[i])) {
d9005 5
a9009 1
		(tmp = (unsigned char *)calloc(1, strlen(cp)+1))) {
d9103 1
a9103 1
	fprintf(tfp,"HText_setLastOptionValue:%s value=%s",
d9105 2
a9106 2
		value);
	fprintf(tfp,"            val_cs=%d \"%s\"",
d9109 1
a9109 1
			 LYCharSet_UC[val_cs].MIMEname : "<UNKNOWN>"));
d9111 1
a9111 1
	    fprintf(tfp, " (submit_val_cs %d \"%s\") submit_value%s=%s\n",
d9117 1
a9117 1
		    submit_value);
d9120 1
a9120 1
	    fprintf(tfp,"\n");
d9136 2
a9137 3

    TextAnchor * a = (TextAnchor *) calloc(1, sizeof(*a));
    FormInfo * f = (FormInfo *) calloc(1, sizeof(*f));
d9143 1
a9143 1
    CTRACE(tfp,"Entering HText_beginInput\n");
a9147 1
    a->start = text->chars + text->last_line->size;
d9225 1
a9225 1
	if ((tmp = (unsigned char *)calloc(1, (strlen(IValue) + 1)))) {
d9279 1
a9279 1
	   f->size = 20;  /* default */
d9331 1
d9362 2
a9363 2
	    CTRACE(tfp,
		  "GridText: No name present in input field; not displaying\n");
d9442 1
a9442 1
	   StrAllocCopy(f->value, (f->type == F_CHECKBOX_TYPE ? "on" : ""));
d9480 1
d9482 1
d9489 1
a9489 1
	    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)
d9495 1
a9495 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED && a->number > 0) {
a9510 1
	a->start = text->chars + text->last_line->size;
d9535 1
a9535 1
	    MaximumSize = (LYcols - 1) -
d9539 8
a9546 6
	    /*
	     *  If we are numbering form links, take that into
	     *  account as well. - FM
	     */
	    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED)
		MaximumSize -= ((a->number/10) + 3);
d9565 2
a9566 2
	    if (f->size > LYcols-10)
		f->size = LYcols-10;  /* maximum */
d9592 1
a9592 1
	CTRACE(tfp, "beginInput: HTCurrentForm is missing!\n");
d9595 1
a9595 1
    CTRACE(tfp, "Input link: name=%s\nvalue=%s\nsize=%d\n",
d9598 2
a9599 2
			f->size);
    CTRACE(tfp, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
d9605 2
a9606 2
			 LYCharSet_UC[I->name_cs].MIMEname : "<UNKNOWN>"));
    CTRACE(tfp, "            value_cs=%d \"%s\" (from %d \"%s\")\n",
d9612 1
a9612 1
			 LYCharSet_UC[I->value_cs].MIMEname : "<UNKNOWN>"));
d9719 9
a9727 1
PUBLIC void HText_SubmitForm ARGS4(
d9747 1
d9762 1
a9762 1
    CTRACE(tfp, "FIXME:SubmitForm\n");
d9764 1
a9764 1
	return;
d9769 2
a9770 2
	CTRACE(tfp, "SubmitForm: form %d not in HTMainText's list!\n",
		    form_number);
d9772 2
a9773 2
	CTRACE(tfp, "SubmitForm: failed sanity check, %d!=%d !\n",
		    thisform->number, form_number);
d9784 1
a9784 1
	    return;
d9787 1
a9787 1
	return;
d9874 2
a9875 1
	    if (anchor_ptr->input_field->number == form_number) {
d9889 1
a9889 1
		       (*p == HT_EN_SPACE) ||
d9988 2
a9989 1
	 *  so load the post_content_type element. - FM
d9992 1
a9992 1
	    StrAllocCopy(doc->post_content_type,
d9995 1
a9995 1
	    StrAllocCopy(doc->post_content_type,
d9998 1
a9998 1
	    StrAllocCopy(doc->post_content_type,
d10000 1
a10000 1
	    StrAllocCat(doc->post_content_type, Boundary);
d10002 1
a10002 1
	    StrAllocCopy(doc->post_content_type,
d10033 2
a10034 2
			StrAllocCat(doc->post_content_type, "; charset=");
			StrAllocCat(doc->post_content_type, target_csname);
d10042 1
a10042 1
		sleep(AlertSecs);
a10046 1

d10058 2
a10059 1
	    if (anchor_ptr->input_field->number == form_number) {
d10075 3
a10077 3
			CTRACE(tfp,
				    "SubmitForm: skipping submit field with ");
			CTRACE(tfp, "name \"%s\" for link_name \"%s\", %s.\n",
d10081 1
a10081 1
				    "not current link" : "no field name");
d10087 7
a10093 9
			if (TRACE) {
			    fprintf(tfp,
				    "SubmitForm: skipping submit field with ");
			    fprintf(tfp,
				    "name \"%s\" for link_name \"%s\", %s!\n",
				    form_ptr->name ? form_ptr->name : "???",
				    link_name ? link_name : "???",
				    "values are different");
			}
d10096 10
d10148 1
a10148 1
			CTRACE(tfp, "SubmitForm: field \"%s\" %d %s -> %d %s %s\n",
d10156 1
a10156 1
				    success ? "OK" : "FAILED");
d10161 1
a10161 1
			CTRACE(tfp, "SubmitForm: field \"%s\" %d %s OK\n",
d10164 1
a10164 1
				    target_csname ? target_csname : "???");
d10173 1
a10173 1
			    sleep(AlertSecs);
d10238 1
a10238 1
			CTRACE(tfp, "SubmitForm: name \"%s\" %d %s -> %d %s %s\n",
d10246 1
a10246 1
				    success ? "OK" : "FAILED");
d10260 1
a10260 1
			CTRACE(tfp, "SubmitForm: name \"%s\" %d %s OK\n",
d10263 1
a10263 1
				    target_csname ? target_csname : "???");
d10275 1
a10275 1
			    sleep(AlertSecs);
d10297 3
a10299 2
		    CTRACE(tfp, "SubmitForm: What type is %d?\n",
				form_ptr->type);
d10307 81
d10393 1
a10393 1
		     *  it's IMAGE_SUBMIT_TYPE to be handled homologously
d10580 1
a10580 1
			    first_one=FALSE;
d10619 1
a10619 1
			 *  add %0a (\n) and the escaped string.
d10631 1
a10631 1
				HTSprintf(&query, "%%0a%s", escaped2);
d10639 1
a10639 1
				StrAllocCat(previous_blanks, "%0a");
d10724 2
d10728 3
a10730 3
	CTRACE(tfp, "\nGridText - mailto_address: %s\n",
			    (submit_item->submit_action+7));
	CTRACE(tfp, "GridText - mailto_subject: %s\n",
d10735 2
a10736 2
					 HText_getTitle() : "")));
	CTRACE(tfp,"GridText - mailto_content: %s\n",query);
d10744 1
a10744 1
		 doc->post_content_type);
d10746 2
a10747 2
	FREE(doc->post_content_type);
	return;
d10754 3
a10756 1
	CTRACE(tfp,"GridText - post_data: %s\n",doc->post_data);
d10759 1
a10759 1
	return;
d10764 1
d10766 1
a10766 1
	return;
d10768 12
d10869 1
a10869 1
       return FALSE;
d11026 1
a11026 1
    return ((text && text->toolbar) ? TRUE : FALSE);
d11040 1
a11040 1
    return ((text && text->no_cache) ? TRUE : FALSE);
d11046 1
a11046 1
    return ((text && text->T.output_utf8) ? TRUE : FALSE);
d11064 2
d11075 1
d11095 10
a11104 2
    if (!strcmp(charset, "shift_jis") ||
	!strcmp(charset, "x-shift-jis")) {
d11106 2
a11107 1
    } else if ((p_in && (p_in->enc == UCT_ENC_CJK)) ||
a11109 2
	       !strcmp(charset, "iso-2022-jp") ||
	       !strcmp(charset, "iso-2022-jp-2") ||
d11117 1
a11117 1
	       !strcmp(charset, "iso-2022-cn")) {
d11130 10
d11274 2
d11303 1
a11303 1
	if (isspace (*p))
d11357 1
a11357 1
	for (p = line, s = tbuf; *s != '\0'; p++, s++)
d11359 6
a11364 6
	    *p = (((unsigned char)*s  < (unsigned char)' ')       ||
		  ((unsigned char)*s == (unsigned char)'\177')    ||
		  (((unsigned char)*s > (unsigned char)'\177') &&
		   ((unsigned char)*s <
		    (unsigned char)LYlowest_eightbit[current_char_set])))
		 ? SPLAT : *s;
d11366 1
a11366 1
	    *p = ((unsigned char)*s < (unsigned char)' ') ? SPLAT : *s;
d11368 1
d11424 1
d11474 1
a11474 1
		if (isdigit (*t++) != 0) {
d11493 1
a11493 1
	     *   of being correct, if and when such an unlikely juxitposition
d11515 1
a11515 1
		     *  horizontal position, and that of all subsequant tags
d11533 1
a11533 1
		    if (new_n -= n) {
d11543 1
a11543 1
	   }
d11556 4
a11559 1
	    if (plx) {
a11560 1
		pre_n = strlen (p);  /* count of 1st part chars in this line */
d11571 1
a11571 1
		    if (isdigit (*t++) != 0) {
d11586 3
a11588 1
		if ((valid) && (n > 0)) {
d11666 1
a11666 1
    for (htline = HTMainText->last_line->next, i = 0;
d11677 3
a11679 3
    if (((a = (TextAnchor *) calloc (1, sizeof(*a)))          == 0)  ||
	((f = (FormInfo   *) calloc (1, sizeof(*f)))          == 0)  ||
	((l = (HTLine     *) calloc (1, LINE_SIZE(MAX_LINE))) == 0))
a11685 1
    a->start	       = anchor->start + anchor->input_field->size + 1;
d11709 1
a11715 3
    l->split_after     = htline->split_after;
    l->bullet	       = htline->bullet;
    l->expansion_line  = TRUE;
d11719 2
d11723 1
a11723 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d11767 1
a11767 1
	int,		 n,
d11769 1
a11769 1
	HTLine *,        start_htline,
d11775 4
a11778 5
    int form_chars_added = (start_anchor->input_field->size + 1) * n;
    int         line_adj = 0;
    int         tag_adj  = 0;
    int         lx       = 0;
    int      hang        = 0;  /* for HANG detection of a nasty intermittent */
d11782 1
a11782 1
    CTRACE(tfp, "GridText: adjusting struct's to add %d new line(s)\n", n);
d11794 1
a11794 1
	if ((keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) &&
d11796 2
a11797 3
	    anchor->number += n;
	anchor->line_num  += n;
	anchor->start	  += form_chars_added;
d11831 1
a11831 1
    if (keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d11833 1
a11833 1
	while (htline != HTMainText->last_line->next) {
d11836 1
a11836 1
		if ((anchor->number - n) == start_tag)
d11839 17
a11855 17
	        /*** A HANG (infinite loop) *has* occurred here, with */
	        /*** the values of anchor and anchor->next being the  */
	        /*** the same, OR with anchor->number "magically" and */
	        /*** suddenly taking on an anchor-pointer-like value. */
	        /***                                                  */
	        /*** The same code and same doc have both passed and  */
	        /*** failed at different times, which indicates some  */
	        /*** sort of content/html dependency, or some kind of */
	        /*** a "race" condition, but I'll be damned if I can  */
	        /*** find it after tons of CTRACE's, printf()'s, gdb  */
	        /*** breakpoints and watchpoints, etc.                */
	        /***                                                  */
	        /*** I have added a hang detector (with error msg and */
	        /*** beep) here, to break the loop and warn the user, */
	        /*** until it can be isolated and fixed.              */
	        /***                                                  */
	        /*** [One UGLY intermittent .. gak ..!  02/22/99 KED] */
d11866 2
a11867 1
						    &start_tag, n,  NOCHOP);
d11880 1
a11880 1
exit:
d11884 3
a11886 4
    nlinks                         += n;
    HTMainText->Lines              += n;
    HTMainText->last_anchor_number += n;
    HTMainText->chars              += (form_chars_added + tag_adj);
d11890 1
a11890 1
    CTRACE(tfp, "GridText: TextAnchor and HTLine struct's adjusted\n");
d11894 1
a11894 1
hang_detected:  /* uglyness has happened; inform user and do the best we can */
d11896 2
a11897 5
    printf ("\007");  /* beep the user */
    fflush (NULL);
    HTAlert ("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
    HTAlert ("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
    goto exit;
d11926 1
a11941 1
    char       *tbuf = NULL;
d11945 1
a11945 1
    int         match_tag = 0;
d11947 4
a11950 1
    int		len;
d11952 1
a11952 2

    CTRACE(tfp, "GridText: entered HText_ExtEditForm()\n");
d12007 2
a12008 2
    CTRACE(tfp, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", areaname);
    CTRACE(tfp, "GridText: invoking editor (%s) on tempfile\n", editor);
d12017 1
a12017 7
#ifdef VMS
	sprintf (ed_offset, "-%d", ((entry_line - start_line) + 1));
    HTSprintf0 (&tbuf, "%s %s %s", editor, ed_temp, ed_offset);
#else
	sprintf (ed_offset, "+%d", ((entry_line - start_line) + 1));
    HTSprintf0 (&tbuf, "%s %s %s", editor, ed_offset, ed_temp);
#endif
d12019 1
a12019 11
    LYSystem (tbuf);   /* finally the editor is called */

#ifdef UNIX
    /*
     *  Delete backup file, if that's your style.
     */
    HTSprintf0 (&tbuf, "%s~", ed_temp);
    if (stat (tbuf, &stat_info) == 0)
	remove (tbuf);
#endif
    FREE(tbuf);
d12021 1
a12021 1
    CTRACE(tfp, "GridText: returned from editor (%s)\n", editor);
d12030 3
a12032 1
	ebuf = (char *) calloc (1, 1);
d12034 12
a12045 1
	ebuf = (char *) calloc (size + 1, (sizeof(char)));
d12049 2
a12050 1
	fclose (fp);
a12051 2
    if (ebuf == 0)
	outofmem(__FILE__, "HText_ExtEditForm");
d12056 2
a12057 1
    while ((size != 0) && (isspace (ebuf[size-1]) || (ebuf[size-1] == '\0')))
d12066 84
a12149 1
	outofmem(__FILE__, "HText_ExtEditForm");
d12151 18
a12168 11
    anchor_ptr = start_anchor;

    len = 0;
    lp  = ebuf;

    while ((line_cnt <= orig_cnt) || (*lp) || ((len != 0) && (*lp == '\0'))) {

	if ((cp = strchr (lp, '\n')) != 0)
	   len = cp - lp;
	else
	   len = strlen (lp);
d12170 2
a12171 2
	strncpy (line, lp, len);
	*(line + len) = '\0';
d12173 1
a12173 1
	cleanup_line_for_textarea (line, len);
d12195 1
a12195 1
	if (len > 0)
d12204 1
a12204 1
	if (*lp) lp++;
d12215 1
a12215 1
    CTRACE(tfp, "GridText: edited text inserted into lynx struct's\n");
d12233 1
a12233 1
    CTRACE(tfp, "GridText: exiting HText_ExtEditForm()\n");
d12253 1
a12253 1
	    int,            newlines)
d12269 1
a12269 1
    CTRACE(tfp, "GridText: entered HText_ExpandTextarea()\n");
d12299 1
a12299 1
	        firstanchor = FALSE;
d12326 2
a12327 2
    CTRACE(tfp, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",
	        newlines, areaname);
d12335 1
a12335 1
    CTRACE(tfp, "GridText: exiting HText_ExpandTextarea()\n");
d12342 2
a12343 2
 *  Insert the contents of a file into a TEXTAREA between the cursorline,
 *  and the line preceeding it.
d12364 1
d12381 1
d12388 1
a12388 1
    CTRACE(tfp, "GridText: entered HText_InsertFile()\n");
d12395 1
a12395 1
	CTRACE(tfp, "GridText: file insert cancelled - no filename provided\n");
d12398 6
d12411 2
a12412 2
	CTRACE(tfp, "GridText: file insert aborted - file=|%s|- was 0-length\n",
		    fn);
d12418 19
a12436 2
	if ((fbuf = (char *) calloc (size + 1, (sizeof(char)))) == NULL)
	    outofmem(__FILE__, "HText_InsertFile");
d12439 6
d12446 1
a12446 1
	fclose (fp);
d12448 1
d12495 1
a12495 1
    for (htline = HTMainText->last_line->next, i = 0;
d12502 3
a12504 3
    if (((a = (TextAnchor *) calloc (1, sizeof(*a)))          == 0)  ||
	((f = (FormInfo   *) calloc (1, sizeof(*f)))          == 0)  ||
	((l = (HTLine     *) calloc (1, LINE_SIZE(MAX_LINE))) == 0))
a12510 1
    a->start	       = anchor_ptr->start;
d12534 1
a12538 3
    l->split_after     = htline->split_after;
    l->bullet	       = htline->bullet;
    l->expansion_line  = TRUE;
d12542 2
d12560 5
a12564 5
    htline             = htline->prev;
    l->next	       = htline->next;
    l->prev	       = htline;
    htline->next->prev = l;
    htline->next       = l;
d12599 9
d12629 7
d12646 1
a12646 1
    CTRACE(tfp, "GridText: file inserted into lynx struct's\n");
a12653 1

d12660 1
a12660 1
    CTRACE(tfp, "GridText: exiting HText_InsertFile()\n");
d12717 1
a12717 1
		LynxChangeStyle (CStyle.style,CStyle.direction,CStyle.previous);
d12726 1
a12726 1
		    addch('_');
d12735 1
a12735 1
		    addch('_');
d12753 1
a12753 1
		    addch('+');
d12758 1
a12758 1
		    isspace((unsigned char)LastDisplayChar) ||
d12778 1
d12782 1
a12782 1
		if (text->T.output_utf8 && !isascii(buffer[0])) {
d12810 1
a12810 1
		    addstr(buffer);
d12814 1
a12814 1
		} else if (HTCJK != NOCJK && !isascii(buffer[0])) {
d12820 1
a12820 1
		    addstr(buffer);
d12835 1
a12835 1
		    addstr(buffer);
d12848 1
a12848 1
	LynxChangeStyle (CStyle.style, CStyle.direction, CStyle.previous);
d12858 563
d13443 1
a13443 1
    while (lines_back--)
d13448 1
a13448 1
    move(links[cur].ly,  links[cur].lx);
d13452 1
a13452 1
	move(links[cur].ly+1,links[cur].hightext2_offset);
d13464 1
a13464 1
#ifdef USE_PSRC
d13468 1
a13468 1
        HTMainText->source = TRUE;
d13472 26
d13500 3
a13502 1
    return (HTMainText ? HTMainText->node_anchor->UCStages->s[0].C.UChndl : 0);
@


1.1
log
@Initial revision
@
text
@d5 11
a15 12
#include "HTUtils.h"
#include "tcp.h"
#include "HTString.h"
#include "HTFont.h"
#include "HTAccess.h"
#include "HTAnchor.h"
#include "HTParse.h"
#include "HTTP.h"
#include "HTAlert.h"
#include "HTCJK.h"
#include "UCDefs.h"
#include "UCAux.h"
d18 1
a18 1
#include <ctype.h>
d25 16
a40 13
#include "GridText.h"
#include "LYCurses.h"
#include "LYUtils.h"
#include "LYStrings.h"
#include "LYStructs.h"
#include "LYGlobalDefs.h"
#include "LYGetFile.h"
#include "LYSignal.h"
#include "LYMail.h"
#include "LYList.h"
#include "LYCharSets.h"
#include "LYCharUtils.h"	/* LYUCTranslateBack... */
#include "UCMap.h"
d42 1
a42 1
#include "UCAuto.h"
d45 8
a52 2
#include "LYexit.h"
#include "LYLeaks.h"
d55 2
a56 2
#include "AttrList.h"
#include "LYHash.h"
d65 17
a81 6
	int i,j;
if (TRACE)
	fprintf(stderr, "flushing cached screen styles\n");
	for (i=0;i<CACHEH;i++)
		for (j=0;j<CACHEW;j++)
			cached_styles[i][j]=s_a;
d85 1
a85 1
struct _HTStream {                      /* only know it as object */
a93 2
#define FREE(x) if (x) {free(x); x = NULL;}

d103 1
a103 1
PUBLIC char * HTAppName = "Lynx";		/* Application name */
d122 7
d143 2
a144 2
	int unsigned	offset;		/* Implicit initial spaces */
	int unsigned	size;		/* Number of characters */
d147 1
d162 1
a162 1
	int			extent; 	/* Characters */
d171 1
d188 18
a205 1
	HTLine * 		last_line;
d227 1
a227 1
	int			permissible_split;	/* in last line */
d231 4
d236 1
a236 1
	HTkcode 		kcode;			/* Kanji code? */
d241 1
a241 1
	char			kanji_buf;		/* Lead multibyte */
d243 1
a243 1
	int			halted; 		/* emergency halt */
d250 1
a250 1
	HTStream *		target; 		/* Output stream */
d282 1
d284 1
d298 1
a298 1
 *                 2: next time when HText_appendCharacter is called
d364 2
a365 3
	if (TRACE) {
	    fprintf(stderr,
		    "\r *** Emergency freeing document %d/%d for '%s'%s!\n",
d385 1
a385 1
		HTAlert("Memory exhausted, display interrupted!");
d390 1
a390 1
		HTAlert("Memory exhausted, will interrupt transfer!");
d459 1
a459 2
    if (TRACE)
	fprintf(stderr, "GridText: VMTotal = %d\n", VMTotal);
d464 1
d466 1
d470 1
a470 1
     *  Links between anchors & documents are a 1-1 relationship. If
d477 5
a481 6
       HTList_removeObject(loaded_texts, anchor->document);
       if (TRACE)
	   fprintf(stderr, "GridText: Auto-uncaching\n") ;
       ((HText *)anchor->document)->node_anchor = NULL;
       HText_free((HText *)anchor->document);
       anchor->document = NULL;
d487 1
a487 1
	   VMTotal > HTVirtualMemorySize) {
d489 1
a489 1
    if (HTList_count(loaded_texts) > HTCacheSize) {
d491 2
a492 2
	if (TRACE)
	    fprintf(stderr, "GridText: Freeing off cached doc.\n");
d496 1
a496 2
	if (TRACE)
	    fprintf(stderr, "GridText: VMTotal reduced to %d\n", VMTotal);
d517 28
d548 5
a552 1
     *  and show up as hidden links in the list of links. - kw
d554 2
a555 1
    if (anchor->address && !strcmp(anchor->address, LYlist_temp_url()))
d565 1
d570 3
d620 20
d643 2
a644 2
/*                      Creation Method 2
**                      ---------------
d680 1
a680 1
	        FREE(l);
d682 1
a682 1
	        free(l);
d686 1
a686 1
	    l = NULL;
d689 1
a689 1
    };
d795 17
d877 1
a877 1
	       i >= CStyle.horizpos + line->offset + 1)
d879 1
a879 1
		(void) LynxChangeStyle (CStyle.style,CStyle.direction,CStyle.previous);
d887 1
a887 1
	        if (dump_output_immediately && use_underscore) {
d896 1
a896 1
	        if (dump_output_immediately && use_underscore) {
d911 1
d913 6
d921 1
a921 1
	        if (*data != '\0' ||
d1015 1
a1015 1
	(void) LynxChangeStyle (CStyle.style, CStyle.direction, CStyle.previous);
d1044 5
a1048 1
    LynxChangeStyle(s_title, ABS_ON, 0);
d1089 1
a1089 1
	            ((text->top_of_screen + display_lines)/(display_lines))),
d1104 1
a1104 1
	        TO_EUC((unsigned char *)title, tmp);
d1106 1
a1106 1
	        TO_SJIS((unsigned char *)title, tmp);
d1108 3
a1110 3
	        for (i = 0, j = 0; title[i]; i++) {
		    if (title[i] != '\033') {
		        tmp[j++] = title[i];
d1144 1
a1144 1
    LynxChangeStyle(s_title, ABS_OFF, 0);
d1161 4
a1164 1
    char *cp, tmp[7];
d1173 3
d1196 8
d1239 1
a1239 1
    }
a1254 1
	stop_curses();
a1256 1
	start_curses();
d1272 13
d1289 9
d1302 1
d1305 1
d1327 8
d1377 1
a1377 1
		    if (IsSpecialAttrChar(tmp[0])) {
d1499 1
a1499 1
	    }
d1516 9
d1527 2
a1528 2
	}
    }
d1565 1
a1565 1
	            auto char *cp_AnchorAddress = NULL;
d1567 1
a1567 1
		        cp_AnchorAddress = stub_HTAnchor_address(link_dest);
d1574 2
a1575 2
				if (TRACE)
				    fprintf(stderr,
d1606 1
a1606 1
	        nlinks++;
d1655 1
a1655 1
	        /*
d1666 2
a1667 3
		if (TRACE &&
		    Anchor_ptr->hightext && *Anchor_ptr->hightext)
		    fprintf(stderr,
d1685 1
a1685 2
		_statusline(MAXLINKS_REACHED);
		sleep(AlertSecs);
d1687 1
a1687 2
	    if (TRACE)
	        fprintf(stderr, "\ndisplay_page: MAXLINKS reached.\n");
d1690 1
a1690 1
    }
d1718 14
a1731 1
    if (HTCJK != NOCJK || text->T.output_utf8 || TRACE) {
d1767 1
a1767 1
**		current style. Text after the split (if split nonzero)
d1777 1
a1777 1
	int,		split)
d1792 1
d1794 1
d1801 2
a1802 1
    HTLine * line = (HTLine *)LY_CALLOC(1, LINE_SIZE(MAX_LINE));
d1809 17
a1825 2
    if (TRACE)
	fprintf(stderr,"GridText: split_line called\n");
a1831 97
#if defined(USE_COLOR_STYLE)
#define LastStyle (previous->numstyles-1)
    line->numstyles = 0;
    inew = MAX_STYLES_ON_LINE - 1;
    spare = previous->numstyles;
    while (previous->numstyles && inew >= 0) {
	if (previous->numstyles >= 2 &&
	    previous->styles[LastStyle].style
	    == previous->styles[previous->numstyles-2].style &&
	    previous->styles[LastStyle].horizpos
	    == previous->styles[previous->numstyles-2].horizpos &&
	    ((previous->styles[LastStyle].direction == STACK_OFF &&
	      previous->styles[previous->numstyles-2].direction == STACK_ON) ||
	     (previous->styles[LastStyle].direction == ABS_OFF &&
	      previous->styles[previous->numstyles-2].direction == ABS_ON) ||
	     (previous->styles[LastStyle].direction == ABS_ON &&
	      previous->styles[previous->numstyles-2].direction == ABS_OFF)
		)) {
	    /*
	     *  Discard pairs of ON/OFF for the same color style, but only
	     *  if they appear at the same position. - kw
	     */
	    previous->numstyles -= 2;
	    if (spare > previous->numstyles)
		spare = previous->numstyles;
	} else if (spare > 0 && previous->styles[spare - 1].direction &&
		   previous->numstyles < MAX_STYLES_ON_LINE) {
	    /*
	     *  The index variable spare walks backwards through the
	     *  list of color style changes on the previous line, trying
	     *  to find an ON change which isn't followed by a
	     *  corresponding OFF.  When it finds one, the missing OFF
	     *  change is appended to the end, and an ON change is added
	     *  at the beginning of the current line.  The OFF change
	     *  appended to the previous line may get removed again in
	     *  the next iteration. - kw
	     */
	    line->styles[inew].horizpos = 0;
	    line->styles[inew].direction = ON;
	    line->styles[inew].style = previous->styles[spare - 1].style;
	    inew --;
	    line->numstyles ++;
	    previous->styles[previous->numstyles].style = line->styles[inew + 1].style;

	    previous->styles[previous->numstyles].direction = ABS_OFF;
	    previous->styles[previous->numstyles].horizpos = previous->size;
	    previous->numstyles++;
	    spare --;
	} else if (spare >= 2 &&
		   previous->styles[spare - 1].style == previous->styles[spare - 2].style &&
		   ((previous->styles[spare - 1].direction == STACK_OFF &&
		     previous->styles[spare - 2].direction == STACK_ON) ||
		    (previous->styles[spare - 1].direction == ABS_OFF &&
		     previous->styles[spare - 2].direction == ABS_ON) ||
		    (previous->styles[spare - 1].direction == STACK_ON &&
		     previous->styles[spare - 2].direction == STACK_OFF) ||
		    (previous->styles[spare - 1].direction == ABS_ON &&
		     previous->styles[spare - 2].direction == ABS_OFF)
		       )) {
	       /*
		*  Skip pairs of adjacent ON/OFF or OFF/ON changes.
		*/
	    spare -= 2;
	} else if (spare && !previous->styles[spare - 1].direction) {
	    /*
	     *  Found an OFF change not part of a matched pair.
	     *  Assume it is safer to leave whatever comes before
	     *  it on the previous line alone.  Setting spare to 0
	     *  ensures that it won't be used in a following
	     *  iteration. - kw
	     */
	    spare = 0;
	} else {
	    /*
	     *  Nothing applied, so we are done with the loop. - kw
	     */
	    break;
	}
    }
    if (previous->numstyles > 0 && previous->styles[LastStyle].direction) {
	if (TRACE)
	    fprintf(stderr, "%s\n%s%s\n",
		    "........... Too many character styles on line:",
		    "........... ", previous->data);
    }
    if (line->numstyles > 0 && line->numstyles < MAX_STYLES_ON_LINE) {
	int n;
	inew ++;
	for (n = line->numstyles; n >= 0; n--)
		line->styles[n + inew] = line->styles[n];
    } else
	if (line->numstyles == 0)
	/* FIXME: RJP - shouldn't use 0xffffffff for largest integer */
	line->styles[0].horizpos = 0xffffffff;
    if (previous->numstyles == 0)
	previous->styles[0].horizpos = 0xffffffff;
#endif
d1862 1
a1862 1
	unsigned int plen;
d1876 7
a1882 1
	while (*p == ' ' || *p == LY_SOFT_HYPHEN) {
d1897 1
a1897 1
	        if (prevdata[i] == LY_UNDERLINE_END_CHAR) {
d1909 1
a1909 1
	        linedata[line->size++] = LY_UNDERLINE_START_CHAR;
d1914 10
a1923 4
	    for (i = (plen - 1); i >= 0; i--) {
		if (p[i] == LY_UNDERLINE_START_CHAR) {
		    underline_on = YES;
		    break;
d1925 5
a1929 9
		if (p[i] == LY_UNDERLINE_END_CHAR) {
		    underline_on = NO;
		    break;
		}
	    }
	    for (i = (plen - 1); i >= 0; i--) {
	        if (p[i] == LY_UNDERLINE_START_CHAR ||
		    p[i] == LY_UNDERLINE_END_CHAR) {
		    ctrl_chars_on_this_line++;
d1944 1
a1944 1
	        bold_on = YES;
d1955 1
a1955 1
	    SpecialAttrChars++;;
d1957 10
a1966 4
	for (i = (plen - 1); i >= 0; i--) {
	    if (p[i] == LY_BOLD_START_CHAR) {
	        bold_on = YES;
		break;
d1968 10
a1977 14
	    if (p[i] == LY_BOLD_END_CHAR) {
		bold_on = NO;
		break;
	    }
	}
	for (i = (plen - 1); i >= 0; i--) {
	    if (p[i] == LY_BOLD_START_CHAR ||
	        p[i] == LY_BOLD_END_CHAR ||
		IS_UTF_EXTRA(p[i]) ||
		p[i] == LY_SOFT_HYPHEN) {
	        ctrl_chars_on_this_line++;
	    }
	    if (p[i] == LY_SOFT_HYPHEN && text->permissible_split < i) {
	        text->permissible_split = i + 1;
d1992 6
a1997 1
	(previous->data[previous->size-1] == ' ')) {
a2004 10
    temp = (HTLine *)LY_CALLOC(1, LINE_SIZE(previous->size));
    if (temp == NULL)
	outofmem(__FILE__, "split_line_2");
    memcpy(temp, previous, LINE_SIZE(previous->size));
    FREE(previous);
    previous = temp;

    previous->prev->next = previous;	/* Link in new line */
    previous->next->prev = previous;	/* Could be same node of course */

d2006 3
a2008 1
     *  Terminate finished line for printing.
d2010 11
a2020 1
    previous->data[previous->size] = '\0';
d2022 4
d2027 4
a2030 1
     *  Align left, right or center.
d2032 182
a2213 21
    for (cp = previous->data; *cp; cp++) {
	if (*cp == LY_UNDERLINE_START_CHAR ||
	    *cp == LY_UNDERLINE_END_CHAR ||
	    *cp == LY_BOLD_START_CHAR ||
	    *cp == LY_BOLD_END_CHAR ||
	    IS_UTF_EXTRA(*cp) ||
	    *cp == LY_SOFT_HYPHEN)
	    ctrl_chars_on_previous_line++;
    }
    /* @@@@ first line indent */
    spare =  (LYcols-1) -
		(int)style->rightIndent - indent +
		ctrl_chars_on_previous_line - previous->size -
		((previous->size > 0) &&
		 (int)(previous->data[previous->size-1] ==
					    LY_SOFT_HYPHEN ?
							 1 : 0));

    switch (style->alignment) {
	case HT_CENTER :
	    previous->offset = previous->offset + indent + spare/2;
d2232 4
a2235 2
    if (split > 0) {
	for (a = text->first_anchor; a; a = a->next) {
d2237 131
a2367 3
		if (a->line_pos >= split) {
		    a->start += (1 + SpecialAttrChars - HeadTrim - TailTrim);
		    a->line_pos -= (split - SpecialAttrChars + HeadTrim);
a2368 6
		} else if ((a->link_type & HYPERTEXT_ANCHOR) &&
			   (a->line_pos + a->extent) >= split) {
		    a->extent -= (TailTrim + HeadTrim);
		    if (a->extent < 0) {
		        a->extent = 0;
		    }
d2370 8
d2398 1
a2398 1
	        break;
d2438 1
a2438 1
	return; 			/* Safety */
d2441 2
a2442 2
    if (TRACE)
	fprintf(stderr, "GridText: Change to style %s\n", style->name);
d2460 43
d2523 1
a2523 1
	    HText_appendText(text, " *** MEMORY EXHAUSTED ***");
d2531 1
a2531 1
    if (ch == '\033' && HTCJK == NOCJK)			/* decimal 27 */
d2542 1
d2547 2
a2548 1
#endif /* USE_SLANG */
d2552 1
a2552 9
	    (155 < LYlowest_eightbit[current_char_set]) &&
	    strncmp(LYchar_set_names[current_char_set],
		    "DosLatin1 (cp850)", 17) &&
	    strncmp(LYchar_set_names[current_char_set],
		    "DosLatinUS (cp437)", 18) &&
	    strncmp(LYchar_set_names[current_char_set],
		    "Macintosh (8 bit)", 17) &&
	    strncmp(LYchar_set_names[current_char_set],
		    "NeXT character set", 18)) {
d2565 1
a2565 1
		if (ch == '\033') {
d2625 1
a2625 1
		    text->permissible_split = (int)text->last_line->size;
d2633 1
a2633 1
		    text->permissible_split = (int)text->last_line->size;
d2644 1
a2644 1
		if (ch == '\033') {
d2657 1
a2657 1
		if (ch == '\033') {
d2662 1
a2662 1
		    text->kanji_buf = '\x8E';
d2673 1
a2673 1
	        if ((text->kcode == SJIS) &&
d2682 2
a2683 2
		    text->kanji_buf = (char)kb;
	        } else {
d2688 1
a2688 1
		    text->permissible_split = (int)text->last_line->size;
d2690 1
a2690 1
	        }
d2695 1
a2695 1
    } else if (ch == '\033') {
d2699 1
a2699 1
    if (IsSpecialAttrChar(ch)) {
d2701 1
d2736 1
a2736 1
	    if (line->size < 1 || text->permissible_split >= (int)line->size)
d2744 1
a2744 1
		    (unsigned char)line->data[i] != HT_EM_SPACE) {
d2755 4
d2784 1
a2784 1
     *  Convert EM_SPACE to a space here so that it doesn't get collapsed.
d2786 1
a2786 1
    if (ch == HT_EM_SPACE)
d2793 1
a2793 1
     *  i.e. use the second line indenting.
d2824 1
a2824 1
	here = (((int)line->size + (int)line->offset) + indent)
d2829 1
a2829 1
		Tab++)
d2834 1
d2838 1
a2838 1
	        new_line(text); /* wrap */
d2841 1
a2841 1
	        target = (int)style->leftIndent;
a2855 1
	    return;
d2860 1
a2860 1
	    text->permissible_split = (int)line->size;
d2862 1
a2862 1
	        line->offset = line->offset + target - here;
d2864 1
a2864 1
	        for (; here<target; here++) {
d2868 1
a2868 1
	        }
a2869 1
	    return;
d2871 1
a2871 1
	/*NOTREACHED*/
d2873 13
a2885 1

d2891 1
a2891 1
	text->permissible_split = (int)text->last_line->size;
d3012 4
a3015 1
	    text->permissible_split = (int)text->last_line->size;
d3026 14
a3039 18
 HTLine* line;
 static int last_style = -1;
 static int last_dir = -1;

 /* can't change style if we have no text to change style with */
 if (!text) return;

 line = text->last_line;

 if ((style != last_style || dir != last_dir) && line->numstyles < MAX_STYLES_ON_LINE)
 {
      line->styles[line->numstyles].horizpos = line->size;
      line->styles[line->numstyles].style = style;
      line->styles[line->numstyles].direction = dir;
      line->numstyles++;
 }
 last_style = style;
 last_dir = dir;
d3094 1
a3094 1
    char marker[16];
d3136 2
d3140 2
d3172 1
a3172 1
	        break;
d3184 2
a3185 2
    if (TRACE)
	fprintf(stderr, "HText_endAnchor: number:%d link_type:%d\n",
d3191 2
a3192 2
	if (TRACE)
	    fprintf(stderr,
d3206 1
d3211 1
d3222 1
a3222 1
	if (a->extent > last->size) {
d3235 2
a3236 2
	j = (last->size - i);
	while (j < last->size) {
d3238 1
a3238 1
	        !isspace((unsigned char)last->data[j]) &&
d3240 1
a3240 1
		last->data[j] != HT_EM_SPACE)
d3246 1
a3246 1
	    if (a->extent > last->size) {
d3271 9
a3279 2
	while (i == 0 && a->extent > CurBlankExtent) {
	    j = prev->size - a->extent + CurBlankExtent;
d3281 1
a3281 1
	        /*
d3285 1
a3285 1
	        j = 0;
d3288 1
a3288 1
	        /*
d3291 1
a3291 1
	        i = a->extent - CurBlankExtent;
d3293 2
a3294 2
	    while (j < prev->size) {
	        if (!IsSpecialAttrChar(prev->data[j]) &&
d3297 1
a3297 1
		    prev->data[j] != HT_EM_SPACE)
d3303 6
a3308 1
		if (a->extent > (CurBlankExtent + prev->size)) {
d3337 5
d3349 1
a3349 1
	     * anchor text via NO_ISMAP_IF_USEMAP. In other cases it can
a3354 1
		HTLine *start;
d3363 1
a3363 1
		if (prev == last->prev) {
a3366 1
		    start = last;
d3372 1
a3372 2
		    start = prev;
		    prev = prev->prev;
d3392 1
a3392 1
		        j--;
d3396 1
a3396 1
		        j++;
d3400 1
a3400 1
		        /*
d3405 6
d3412 1
a3412 1
			while (k < start->size)
d3418 2
d3421 1
d3423 1
a3423 1
		        start->size = j;
d3430 1
a3430 6
			while ((j >= 0) &&
			       (prev->data[j] == LY_BOLD_START_CHAR ||
			        prev->data[j] == LY_BOLD_END_CHAR ||
				prev->data[j] == LY_UNDERLINE_START_CHAR ||
			        prev->data[j] == LY_UNDERLINE_END_CHAR ||
				prev->data[j] == LY_SOFT_HYPHEN))
d3432 1
a3432 1
		        i = (j + 1);
d3450 2
a3451 2
			    while (i < prev->size)
				start->data[j++] = start->data[i++];
d3459 7
a3465 1
				start->data[j++] = '\0';
d3468 2
a3469 2
			    while (k < start->size)
			        start->data[j++] = start->data[k++];
d3471 1
a3471 1
			        text->chars -= i;
d3474 4
a3477 1
				anc->line_pos -= i;
d3482 1
a3482 1
			        start->data[j++] = '\0';
d3499 2
a3500 7
		    while ((j >= 0) &&
			   (prev->data[j] == LY_BOLD_START_CHAR ||
			    prev->data[j] == LY_BOLD_END_CHAR ||
			    prev->data[j] == LY_UNDERLINE_START_CHAR ||
			    prev->data[j] == LY_UNDERLINE_END_CHAR ||
			    prev->data[j] == LY_SOFT_HYPHEN))
		        j--;
d3502 1
a3502 1
		        j = 0;
d3504 2
a3505 2
		    if ((j > 2) &&
		        (prev->data[j] == ']' &&
d3507 1
a3507 1
		        j--;
d3509 1
a3509 1
		        k = (j + 1);
d3527 1
a3527 1
			    while (k < prev->size)
d3536 1
a3536 1
				start->data[j++] = '\0';
d3549 1
a3549 1
		        a->show_anchor = YES;
d3566 6
d3584 1
a3584 1
	        text->last_anchor_number--;
d3597 7
a3660 2
    int cur_line, cur_char, cur_shift, len;
    TextAnchor *anchor_ptr;
a3661 1
    unsigned char ch;
d3665 2
a3666 2
    if (TRACE)
	fprintf(stderr,"Gridtext: Entering HText_endAppend\n");
a3686 3
    cur_char = line_ptr->size;
    cur_line = 0;
    cur_shift = 0;
d3694 2
a3695 2
	if (TRACE)
	    fprintf(stderr, "GridText: Removing bottom blank line: %s\n",
d3705 1
a3705 3
#ifdef NOTUSED_BAD_FOR_SCREEN
	if (TRACE) {
	    fprintf(stderr, "GridText: New bottom line: %s\n",
a3706 2
	}
#endif
d3713 55
d3769 2
a3770 1
	 anchor_ptr; anchor_ptr=anchor_ptr->next) {
d3775 1
a3775 1
	for (; anchor_ptr->start >= cur_char;
d3781 30
d3817 2
a3818 1
	if (anchor_ptr->line_pos < 0)
d3820 6
a3825 3
	if (TRACE)
	    fprintf(stderr, "Gridtext: Anchor found on line:%d col:%d\n",
			    cur_line, anchor_ptr->line_pos);
d3827 1
d3835 1
a3835 1
	           IsSpecialAttrChar(ch)) {
d3845 4
a3848 5
#ifdef NOTUSED_BAD_FOR_SCREEN
	if (TRACE)
	    fprintf(stderr, "anchor text: '%s'   pos: %d\n",
			    line_ptr->data, anchor_ptr->line_pos);
#endif
d3852 15
a3866 8
	 */
	if (anchor_ptr->line_pos >= strlen(line_ptr->data) &&
	    cur_line < text->Lines) {
	    anchor_ptr->start += (cur_shift + 1);
	    cur_shift = 0;
	    if (TRACE)
		fprintf(stderr, "found anchor at end of line\n");
	    goto re_parse;
d3868 1
a3868 6
	cur_shift = 0;
#ifdef NOTUSED_BAD_FOR_SCREEN
	if (TRACE)
	    fprintf(stderr, "anchor text: '%s'   pos: %d\n",
			    line_ptr->data, anchor_ptr->line_pos);
#endif
d3885 1
a3885 1
	if (anchor_ptr->extent > strlen(anchor_ptr->hightext)) {
d3887 7
d3903 1
a3903 1
	        anchor_ptr->hightext2offset = line_ptr2->offset;
d3906 2
a3907 10
		    if ((len = strlen(anchor_ptr->hightext2)) > 0) {
			len--;
			while (len >= 0 &&
			       isspace((unsigned char)
				       anchor_ptr->hightext2[len])) {
			    anchor_ptr->hightext2[len] = '\0';
			    len--;
			}
		    }
		    if (len <= 0 && anchor_ptr->hightext2[0] == '\0') {
d3916 1
a3916 8
	    if ((len = strlen(anchor_ptr->hightext)) > 0) {
		len--;
		while (len >= 0 &&
		       isspace((unsigned char)anchor_ptr->hightext[len])) {
		    anchor_ptr->hightext[len] = '\0';
		    len--;
	        }
	    }
d3937 4
a3940 4
	if (TRACE)
	    fprintf(stderr,
		    "GridText: adding link on line %d in HText_endAppend\n",
		    cur_line);
d3951 1
a3951 1
/*	Dump diagnostics to stderr
d3956 1
a3956 1
    fprintf(stderr, "HText: Dump called\n");
d4005 1
a4005 1
	 *desc = "unknown field or link";
d4012 1
a4012 1
	        *desc = "unknown field or link";
d4021 1
a4021 1
	    *desc = "text entry field";
d4024 1
a4024 1
	    *desc = "password entry field";
d4027 1
a4027 1
	    *desc = "checkbox";
d4030 1
a4030 1
	    *desc = "radio button";
d4033 1
a4033 1
	    *desc = "submit button";
d4036 1
a4036 1
	    *desc = "reset button";
d4039 1
a4039 1
	    *desc = "popup menu";
d4042 1
a4042 1
	    *desc = "hidden form field";
d4045 1
a4045 1
	    *desc = "text entry area";
d4048 1
a4048 1
	    *desc = "range entry field";
d4051 1
a4051 1
	    *desc = "file entry field";
d4054 1
a4054 1
	    *desc = "text-submit field";
d4057 1
a4057 1
	    *desc = "image-submit button";
d4060 1
a4060 1
	    *desc = "keygen field";
d4063 1
a4063 1
	    *desc = "unknown form field";
d4068 67
d4138 1
a4138 1
 *  If want_go is not NULL, caller requests to know a line number for
d4141 1
a4141 1
 *  the line in *line has been made the new top screen line.
d4222 1
a4222 1
	        if (anchors_this_screen > 0 &&
d4234 1
a4234 1
		        *linknum = anchors_this_screen - 1;
d4258 1
a4258 1
		        *go_line = prev_prev_anchor_line + 1;
d4260 1
a4260 1
		        *go_line = 0;
d4262 3
a4264 3
		        *linknum = anchors_this_line - 1;
	        }
	        return(LINK_LINE_FOUND);
d4278 2
a4279 3
				if (TRACE)
				    fprintf(stderr,
					    "HTGetLinkInfo: unexpected typed link to %s!\n",
d4303 258
d4659 1
a4659 1
PUBLIC char * HText_getTitle NOARGS
d4662 1
a4662 1
	  (char *) HTAnchor_title(HTMainText->node_anchor) : NULL);
d4666 1
a4666 1
PUBLIC char *HText_getStyle NOARGS
d4669 1
a4669 1
	  (char *) HTAnchor_style(HTMainText->node_anchor) : NULL);
d4678 1
a4678 1
PUBLIC char * HText_getSugFname NOARGS
d4681 1
a4681 1
	  (char *) HTAnchor_SugFname(HTMainText->node_anchor) : NULL);
d4774 1
a4774 1
	        /*
d4779 1
a4779 1
	        cp = (dot + 1);
d4792 1
a4792 1
	            /*
d4822 1
a4822 1
	            /*
d4879 1
a4879 1
PUBLIC char * HText_getLastModified NOARGS
d4882 1
a4882 1
	  (char *) HTAnchor_last_modified(HTMainText->node_anchor) : NULL);
d4889 1
a4889 1
PUBLIC char * HText_getDate NOARGS
d4892 1
a4892 1
	  (char *) HTAnchor_date(HTMainText->node_anchor) : NULL);
d4899 1
a4899 1
PUBLIC char * HText_getServer NOARGS
d4902 1
a4902 1
	  (char *)HTAnchor_server(HTMainText->node_anchor) : NULL);
d4907 2
a4908 2
 *  starting from the line 'line_num'-1
 *  this is the primary call for lynx
d4914 19
d4935 5
d4941 6
d5023 2
a5024 1
    return ((text->top_of_screen + display_lines) < text->Lines+1);
d5089 11
d5166 4
a5169 4
		 www_search_result = a->line_num+1;
		 if (TRACE)
		    fprintf(stderr,
		"HText: Selecting anchor [%d] at character %d, line %d\n",
d5199 1
a5199 1
	if (TRACE) fprintf(stderr, "HText: No such anchor in this text!\n");
d5210 1
a5210 1
	if (TRACE) fprintf(stderr,
d5217 1
a5217 1
	         return YES;
d5229 1
a5229 1
**	These are called from the application. There are many more functions
d5315 1
a5315 1
      return text->top_of_screen;
d5370 1
d5372 1
d5394 1
a5394 1
    int ch, recall, i;
d5411 1
a5411 1
	        *cp = ' ';
d5446 1
a5446 1
	        /*
d5449 1
a5449 1
	        QueryNum = 1;
d5452 1
a5452 1
	        /*
d5455 1
a5455 1
	        QueryNum++;
d5458 1
a5458 1
	        /*
d5461 1
a5461 1
	        QueryNum = 0;
d5477 1
a5477 1
	        /*
d5480 1
a5480 1
	        QueryNum = QueryTotal - 1;
d5483 1
a5483 1
	        /*
d5486 1
a5486 1
	        QueryNum--;
d5489 1
a5489 1
	        /*
d5511 1
a5511 2
	_statusline(CANCELLED);
	sleep(InfoSecs);
d5518 3
a5520 6
    cp = searchstring;
    while (*cp && isspace((unsigned char)*cp))
	cp++;
    if (!(*cp)) {
	_statusline(CANCELLED);
	sleep(InfoSecs);
d5523 1
a5523 8
    if (cp > searchstring) {
	for (i = 0; *cp; i++)
	    searchstring[i] = *cp++;
	searchstring[i] = '\0';
    }
    cp = searchstring + strlen(searchstring) - 1;
    while ((cp > searchstring) && isspace((unsigned char)*cp))
	*cp-- = '\0';
d5529 1
a5529 2
	_statusline(USE_C_R_TO_RESUB_CUR_QUERY);
	sleep(MessageSecs);
d5573 1
a5573 2
	if (TRACE)
	    fprintf(stderr,"\ndo_www_search: newfile: %s\n",doc->address);
d5602 1
a5603 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;
#endif /* VMS */
d5610 5
d5622 1
a5622 1
        /*
d5634 1
a5634 1
		fputc(line->data[i],fp);
d5640 1
a5640 2
		    (current_char_set == 0 ||
		     LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
a5659 5
	/*
	 *  Add the return.
	 */
	fputc('\n',fp);

d5668 1
d5683 1
a5684 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;
#endif /* VMS */
d5696 4
d5713 12
a5724 13
	     } else if (line->data[i] == LY_SOFT_HYPHEN &&
		 line->data[i + 1] == '\0') { /* last char on line */
		 if (dump_output_immediately &&
		     LYRawMode &&
		     LYlowest_eightbit[current_char_set] <= 173 &&
		     (current_char_set == 0 ||
		      LYCharSet_UC[current_char_set].enc == UCT_ENC_8859 ||
		      LYCharSet_UC[current_char_set].like8859 &
				   UCT_R_8859SPECL)) {
		     fputc(0xad, fp); /* the iso8859 byte for SHY */
		 } else {
		     fputc('-', fp);
		 }
a5727 5
	/*
	 *  Add the return.
	 */
	fputc('\n',fp);

d5732 1
d5819 20
a5838 1
PUBLIC void www_user_search ARGS3(
d5841 5
a5845 1
	char *,		target)
d5847 1
a5847 5
    register HTLine * line;
    register int count;
    int tentative_result = -1;
    TextAnchor *a;
    OptionType *option;
a5849 20
    if (!HTMainText) {
	return;
    }

    /*
     *  Advance to the start line.
     */
    line = HTMainText->last_line->next;
    for (count = 1; count <= start_line; line = line->next, count++) {
	if (line == HTMainText->last_line) {
	    line = HTMainText->last_line->next; /* set to first line */
	    count = 1;
	    break;
	}
    }
    a = HTMainText->first_anchor;
    while (a && a->line_num < count - 1) {
	a = a->next;
    }

d5851 1
a5851 1
	while ((a != NULL) && a->line_num == (count - 1)) {
d5859 2
a5860 2
		    adjust_search_result(doc, count, start_line);
		    return;
d5866 2
a5867 2
		    adjust_search_result(doc, count, start_line);
		    return;
d5877 1
a5877 1
		        /*
d5887 2
a5888 2
			    adjust_search_result(doc, count, start_line);
			    return;
d5898 2
a5899 2
			    adjust_search_result(doc, count, start_line);
			    return;
d5917 2
a5918 2
				adjust_search_result(doc, count, start_line);
				return;
d5926 1
a5926 1
		        if (a->input_field->num_value) {
d5935 2
a5936 2
			    adjust_search_result(doc, count, start_line);
			    return;
d5943 1
a5943 1
		        if (a->input_field->num_value) {
d5952 2
a5953 2
			    adjust_search_result(doc, count, start_line);
			    return;
d5956 1
a5956 1
		        /*
d5968 2
a5969 2
			    adjust_search_result(doc, count, start_line);
			    return;
d5976 1
a5976 1
	if (a != NULL && a->line_num <= (count - 1)) {
d5981 1
a5981 1
	    tentative_result = count;
d5985 1
a5985 1
	    tentative_result = count;
d5987 3
a5989 1
	} else if (line == HTMainText->last_line) {  /* next line */
d5991 3
d5996 1
a5996 1
	    count++;
d5999 15
a6013 2
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
d6018 1
a6018 1
     *  Search from the beginning.
d6020 22
d6048 21
d6070 5
a6074 19
    for (;;) {
	while ((a != NULL) && a->line_num == (count - 1)) {
	    if (a->show_anchor &&
		(a->link_type != INPUT_ANCHOR ||
		 a->input_field->type != F_HIDDEN_TYPE)) {
		if (((a->hightext != NULL && case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(a->hightext, target)) ||
		    ((a->hightext != NULL && case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(a->hightext, target))) {
		    adjust_search_result(doc, count, start_line);
		    return;
		}
		if (((a->hightext2 != NULL && case_sensitive == TRUE) &&
		     LYno_attr_char_strstr(a->hightext2, target)) ||
		    ((a->hightext2 != NULL && case_sensitive == FALSE) &&
		     LYno_attr_char_case_strstr(a->hightext2, target))) {
		    adjust_search_result(doc, count, start_line);
		    return;
		}
d6076 9
a6084 168
		/*
		 *  Search the relevant form fields, taking the
		 *  case_sensitive setting into account. - FM
		 */
		if ((a->input_field != NULL && a->input_field->value != NULL) &&
		    a->input_field->type != F_HIDDEN_TYPE) {
		    if (a->input_field->type == F_PASSWORD_TYPE) {
		        /*
			 *  Check the actual, hidden password, and then
			 *  the displayed string. - FM
			 */
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(a->input_field->value,
						   target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(a->input_field->value,
							target))) {
			    adjust_search_result(doc, count, start_line);
			    return;
			}
			StrAllocCopy(stars, a->input_field->value);
			for (cp = stars; *cp != '\0'; cp++)
			    *cp = '*';
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(stars, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(stars, target))) {
			    FREE(stars);
			    adjust_search_result(doc, count, start_line);
			    return;
			}
			FREE(stars);
		   } else if (a->input_field->type == F_OPTION_LIST_TYPE) {
			/*
			 *  Search the option strings that are displayed
			 *  when the popup is invoked. - FM
			 */
			option = a->input_field->select_list;
			while (option != NULL) {
			    if (((option->name != NULL &&
				  case_sensitive == TRUE) &&
				 LYno_attr_char_strstr(option->name,
						       target)) ||
				((option->name != NULL &&
				  case_sensitive == FALSE) &&
				 LYno_attr_char_case_strstr(option->name,
							    target))) {
				adjust_search_result(doc, count, start_line);
				return;
			    }
			    option = option->next;
			}
		    } else if (a->input_field->type == F_RADIO_TYPE) {
			/*
			 *  Search for checked or unchecked parens. - FM
			 */
		        if (a->input_field->num_value) {
			    cp = checked_radio;
			} else {
			    cp = unchecked_radio;
			}
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(cp, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(cp, target))) {
			    adjust_search_result(doc, count, start_line);
			    return;
			}
		    } else if (a->input_field->type == F_CHECKBOX_TYPE) {
			/*
			 *  Search for checked or unchecked
			 *  square brackets. - FM
			 */
		        if (a->input_field->num_value) {
			    cp = checked_box;
			} else {
			    cp = unchecked_box;
			}
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(cp, target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(cp, target))) {
			    adjust_search_result(doc, count, start_line);
			    return;
			}
		    } else {
		        /*
			 *  Check the values intended for display.
			 *  May have been found already via the
			 *  hightext search, but make sure here
			 *  that the entire value is searched. - FM
			 */
			if (((case_sensitive == TRUE) &&
			     LYno_attr_char_strstr(a->input_field->value,
						   target)) ||
			    ((case_sensitive == FALSE) &&
			     LYno_attr_char_case_strstr(a->input_field->value,
							target))) {
			    adjust_search_result(doc, count, start_line);
			    return;
			}
		    }
		}
	    }
	    a = a->next;
	}
	if (a != NULL && a->line_num <= (count - 1)) {
	    a = a->next;
	}

	    if (case_sensitive && LYno_attr_char_strstr(line->data, target)) {
	        tentative_result=count;
		break;
	    } else if (!case_sensitive &&
		       LYno_attr_char_case_strstr(line->data, target)) {
	        tentative_result = count;
		break;
	    } else if (count > start_line) {  /* next line */
		_user_message(STRING_NOT_FOUND, target);
		sleep(MessageSecs);
	        return;			/* end */
	    } else {
	        line = line->next;
		count++;
	}
    }
    if (tentative_result > 0) {
	adjust_search_result(doc, tentative_result, start_line);
    }
}

PUBLIC void user_message ARGS2(
	CONST char *,	message,
	CONST char *,	argument)
{
    char *temp = NULL;
    char temp_arg[256];

    if (message == NULL) {
	mustshow = FALSE;
	return;
    }

    /*
     *  Make sure we don't overrun any buffers.
     */
    LYstrncpy(temp_arg, ((argument == NULL) ? "" : argument), 255);
    temp_arg[255] = '\0';
    temp = (char *)malloc(strlen(message) + strlen(temp_arg) + 1);
    if (temp == NULL)
	outofmem(__FILE__, "user_message");
    sprintf(temp, message, temp_arg);

    statusline(temp);

    FREE(temp);
    return;
}

/*
 *  HText_getOwner returns the owner of the
 *  current document.
 */
PUBLIC char * HText_getOwner NOARGS
{
    return(HTMainText ?
	   (char *)HTAnchor_owner(HTMainText->node_anchor) : NULL);
}
d6087 1
a6087 1
*   HText_setMainTextOwner sets the owner for the
d6104 1
a6104 1
PUBLIC char * HText_getRevTitle NOARGS
d6107 1
a6107 1
	   (char *)HTAnchor_RevTitle(HTMainText->node_anchor) : NULL);
d6114 1
a6114 1
PUBLIC char * HText_getContentBase NOARGS
d6117 1
a6117 1
	   (char *)HTAnchor_content_base(HTMainText->node_anchor) : NULL);
d6124 11
a6134 1
PUBLIC char * HText_getContentLocation NOARGS
d6137 1
a6137 1
	   (char *)HTAnchor_content_location(HTMainText->node_anchor) : NULL);
d6148 7
d6160 1
a6160 2
	if (TRACE) {
	    fprintf(stderr, "\rHTuncache.. freeing document for '%s'%s\n",
a6166 1
	}
d6171 142
a6312 2
	if (TRACE) {
	    fprintf(stderr, "HTuncache.. HTMainText already is NULL!\n");
d6314 7
d6322 61
d6384 1
d6388 1
a6388 1
    return(HTMainText->source);
d6525 1
a6525 1
	        !isspace((unsigned char)line->data[i]) &&
d6527 1
a6527 1
		(unsigned char)line->data[i] != HT_EM_SPACE) {
d6553 9
d6646 1
a6646 1
	        return; /* Already set.  Keep the first value. */
d6674 1
a6674 1
	        break;
a6827 1
	int i;
d6829 2
a6830 3
	collapse_spaces(HTFormAcceptCharset);
	for (i = 0; HTFormAcceptCharset[i]; i++)
	    HTFormAcceptCharset[i] = TOLOWER(HTFormAcceptCharset[i]);
d6850 1
a6850 3
    if (TRACE)
	fprintf(stderr,
		"BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",
d6874 1
a6874 1
	        a->input_field->number == HTFormNumber &&
d6893 1
a6893 1
	        break;
d6915 1
a6915 2
	if (TRACE)
	    fprintf(stderr, "endForm:    HTCurrentForm is missing!\n");
d6957 1
a6957 2
    if (TRACE) {
       fprintf(stderr,"HText_beginSelect: name=%s type=%d size=%s\n",
d6963 1
a6963 1
	fprintf(stderr,"HText_beginSelect: name_cs=%d \"%s\"\n",
a6966 1
    }
d6991 1
a6991 2
    if (TRACE)
	fprintf(stderr, "HText_getOptionNum: Got number '%d'.\n", n);
d7022 1
a7022 1
	        ++cp;
d7028 1
a7028 1
		        break;
d7036 1
a7036 1
	        cp = opname;
d7068 1
a7068 3
	if (TRACE)
	    fprintf(stderr,
		    "HText_setLastOptionValue: invalid call!  value:%s!\n",
d7073 1
a7073 3
    if (TRACE)
	fprintf(stderr,
		"Entering HText_setLastOptionValue: value:%s, checked:%s\n",
d7151 1
a7151 3
		if (TRACE) {
		    fprintf(stderr,
   "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",
d7153 1
a7153 2
		    fprintf(stderr,
   "                          but %d, ignoring!\n",
a7154 1
		}
d7161 1
a7161 1
	        outofmem(__FILE__, "HText_setLastOptionValue");
d7174 1
a7174 1
	        outofmem(__FILE__, "HText_setLastOptionValue");
d7180 8
d7190 1
a7190 1
	        cp[i] == HT_EM_SPACE) {
d7200 1
a7200 1
	        (tmp = (unsigned char *)calloc(1, strlen(cp)+1))) {
d7209 1
a7209 1
		        if (cp[i] != '\033') {
d7294 1
a7294 1
	fprintf(stderr,"HText_setLastOptionValue:%s value=%s",
d7297 1
a7297 1
	fprintf(stderr,"            val_cs=%d \"%s\"",
d7302 1
a7302 1
	    fprintf(stderr, " (submit_val_cs %d \"%s\") submit_value%s=%s\n",
d7307 1
a7307 1
		                                  "(ignored)" : "",
d7311 1
a7311 1
	    fprintf(stderr,"\n");
d7335 1
a7335 2
    if (TRACE)
	fprintf(stderr,"Entering HText_beginInput\n");
d7342 1
d7366 1
a7366 1
	        if (b->link_type == INPUT_ANCHOR &&
d7427 2
a7428 2
		    if (IValue[i] != '\033') {
		        tmp[j++] = IValue[i];
d7554 1
a7554 2
	    if (TRACE)
		fprintf(stderr,
d7659 2
a7660 3
	collapse_spaces(f->accept_cs);
	for (i = 0; f->accept_cs[i]; i++)
	    f->accept_cs[i] = TOLOWER(f->accept_cs[i]);
d7702 1
d7735 1
a7735 1
	        MaximumSize -= ((a->number/10) + 3);
d7737 1
a7737 1
	        f->size = MaximumSize;
d7781 1
a7781 2
	if (TRACE)
	    fprintf(stderr, "beginInput: HTCurrentForm is missing!\n");
d7784 1
a7784 2
    if (TRACE) {
	fprintf(stderr,"Input link: name=%s\nvalue=%s\nsize=%d\n",
d7788 1
a7788 1
	fprintf(stderr,"Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",
d7795 1
a7795 1
	fprintf(stderr,"            value_cs=%d \"%s\" (from %d \"%s\")\n",
a7801 1
    }
a7917 1
    int len;
d7942 1
d7949 1
a7949 3
	if (TRACE)
	    fprintf(stderr,
		    "SubmitForm: form %d not in HTMainText's list!\n",
d7952 1
a7952 3
	if (TRACE)
	    fprintf(stderr,
		    "SubmitForm: failed sanity check, %d!=%d !\n",
a7965 5

	/*
	 *  Set length plus breathing room.
	 */
	len = strlen(submit_item->submit_action) + 2048;
d8037 2
a8038 3
	    target_cs = UCLYhndl_for_unspec;
	    if (target_cs >= 0)
		target_csname = LYCharSet_UC[target_cs].MIMEname;
d8042 1
a8042 1
	target_cs = UCLYhndl_for_unspec;
d8058 1
a8058 1
	        form_ptr = anchor_ptr->input_field;
d8060 1
a8060 1
			            form_ptr->cp_submit_value : form_ptr->value;
a8063 11
	        len += (strlen(form_ptr->name) + (Boundary ? 100 : 10));
		/*
		 *  Calculate by the option submit value if present.
		 */
		if (form_ptr->cp_submit_value != NULL) {
		    len += (strlen(form_ptr->cp_submit_value) + 10);
		} else {
	            len += (strlen(form_ptr->value) + 10);
		}
	        len += 32; /* plus and ampersand + safety net */

d8068 1
a8068 1
			(*p == HT_EM_SPACE) ||
d8078 1
a8078 1
			(*p == HT_EM_SPACE) ||
d8130 1
a8130 1
	        break;
a8148 6
    /*
     *  Get query ready.
     */
    query = (char *)calloc(1, len);
    if (query == NULL)
	outofmem(__FILE__, "HText_SubmitForm");
d8151 1
a8151 1
	strcpy (query, submit_item->submit_action);
d8163 1
a8163 1
	strcat(query,"?");
a8164 1
	query[0] = '\0';
d8246 1
a8246 1
	        case F_RESET_TYPE:
d8248 3
a8250 3
	        case F_SUBMIT_TYPE:
	        case F_TEXT_SUBMIT_TYPE:
	        case F_IMAGE_SUBMIT_TYPE:
d8253 1
a8253 2
			if (TRACE) {
			    fprintf(stderr,
d8255 1
a8255 2
			    fprintf(stderr,
				    "name \"%s\" for link_name \"%s\", %s.",
a8259 1
			}
d8266 1
a8266 1
			    fprintf(stderr,
d8268 2
a8269 2
			    fprintf(stderr,
				    "name \"%s\" for link_name \"%s\", %s!",
d8277 1
a8277 1
	        case F_RADIO_TYPE:
d8281 1
a8281 1
	        case F_TEXT_TYPE:
d8304 1
a8304 1
			    (*p == HT_EM_SPACE) ||
d8318 1
a8318 3
			if (TRACE) {
			    fprintf(stderr,
				    "SubmitForm: field \"%s\" %d %s -> %d %s %s\n",
a8326 1
			}
d8331 1
a8331 3
			if (TRACE) {
			    fprintf(stderr,
				    "SubmitForm: field \"%s\" %d %s OK\n",
a8334 1
			}
d8394 1
a8394 1
			    (*p == HT_EM_SPACE) ||
d8408 1
a8408 3
			if (TRACE) {
			    fprintf(stderr,
				    "SubmitForm: name \"%s\" %d %s -> %d %s %s\n",
a8416 1
			}
d8430 1
a8430 3
			if (TRACE) {
			    fprintf(stderr,
				    "SubmitForm: name \"%s\" %d %s OK\n",
a8433 1
			}
d8467 1
a8467 2
		    if (TRACE)
			fprintf(stderr, "SubmitForm: What type is %d?\n",
d8496 1
a8496 2
				sprintf(&query[strlen(query)],
					"--%s\r\n", Boundary);
d8501 1
a8501 1
				strcat(query, "\n");
d8503 1
a8503 1
				strcat(query, ";");
d8505 1
a8505 2
				sprintf(&query[strlen(query)],
					"\r\n--%s\r\n", Boundary);
d8507 1
a8507 1
				strcat(query, "&");
d8541 2
a8542 2
				sprintf(&query[strlen(query)],
				    "%s.x\r\n\r\n0\r\n--%s\r\n%s.y\r\n\r\n0",
d8547 1
a8547 1
				sprintf(&query[strlen(query)],
d8562 1
a8562 1
			    sprintf(&query[strlen(query)],
d8588 1
a8588 1
				sprintf(&query[strlen(query)],
d8594 1
a8594 1
				strcat(query, "\n");
d8596 1
a8596 1
				strcat(query, ";");
d8598 1
a8598 2
				sprintf(&query[strlen(query)],
					"\r\n--%s\r\n", Boundary);
d8600 1
a8600 1
				strcat(query, "&");
d8625 1
a8625 1
			sprintf(&query[strlen(query)],
d8666 1
a8666 2
				sprintf(&query[strlen(query)],
					"--%s\r\n", Boundary);
d8671 1
a8671 1
				strcat(query, "\n");
d8673 1
a8673 1
				strcat(query, ";");
d8675 1
a8675 2
				sprintf(&query[strlen(query)],
					"\r\n--%s\r\n", Boundary);
d8677 1
a8677 1
				strcat(query, "&");
d8692 1
a8692 1
			sprintf(&query[strlen(query)],
d8711 1
a8711 1
				strcat(query, previous_blanks);
d8715 1
a8715 2
				sprintf(&query[strlen(query)], "%s\n",
							       escaped2);
d8717 1
a8717 2
				sprintf(&query[strlen(query)], "%s\r\n",
							       escaped2);
d8719 1
a8719 2
				sprintf(&query[strlen(query)], "%%0a%s",
							       escaped2);
d8741 1
a8741 2
			    sprintf(&query[strlen(query)],
				    "--%s\r\n", Boundary);
d8746 1
a8746 1
			    strcat(query, "\n");
d8748 1
a8748 1
			    strcat(query, ";");
d8750 1
a8750 2
			    sprintf(&query[strlen(query)],
				    "\r\n--%s\r\n", Boundary);
d8752 1
a8752 1
			    strcat(query, "&");
d8777 1
a8777 1
		    sprintf(&query[strlen(query)],
d8792 1
a8792 1
	        }
d8794 1
a8794 1
	        break;
d8805 4
a8808 1
	sprintf(&query[strlen(query)], "\r\n--%s--\r\n", Boundary);
d8813 2
a8814 3
	_user_message("Submitting %s", submit_item->submit_action);
	if (TRACE) {
	    fprintf(stderr, "\nGridText - mailto_address: %s\n",
d8816 1
a8816 1
	    fprintf(stderr, "GridText - mailto_subject: %s\n",
d8821 2
a8822 4
				         HText_getTitle() : "")));
	    fprintf(stderr,"GridText - mailto_content: %s\n",query);
	}
	sleep(MessageSecs);
d8840 1
a8840 2
	if (TRACE)
	    fprintf(stderr,"GridText - post_data: %s\n",doc->post_data);
a8874 1

d8887 1
a8887 1
    if (!HTMainText)
d8894 1
a8894 1
    while (anchor_ptr) {
d8898 2
a8899 2
		 if (anchor_ptr->input_field->type == F_RADIO_TYPE ||
		     anchor_ptr->input_field->type == F_CHECKBOX_TYPE) {
d8902 1
a8902 1
		        anchor_ptr->input_field->num_value = 0;
d8904 1
a8904 1
		        anchor_ptr->input_field->num_value = 1;
d8906 2
a8907 2
		 } else if (anchor_ptr->input_field->type ==
			    F_OPTION_LIST_TYPE) {
d8914 1
a8914 1
	         } else {
d8916 5
a8920 6
					anchor_ptr->input_field->orig_value);
		 }
	     } else if (anchor_ptr->input_field->number > form->number) {
		 break;
	     }

d8926 50
d8979 1
d8998 1
a8998 1
	         if (!strcmp(anchor_ptr->input_field->name, form->name) &&
d9002 1
a9002 1
	         }
d9004 1
a9004 1
	            break;
d9018 1
d9041 2
d9068 1
d9207 1
a9207 1
    text->permissible_split = (int)text->last_line->size;
d9323 1502
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
