head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.40;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.14;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.59;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.59;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: UCAuto.c,v 1.53 2013/11/29 00:22:00 tom Exp $
 *
 *  This file contains code for changing the Linux console mode.
 *  Currently some names for font files are hardwired in here.
 *  You have to change this code if it needs accommodation for your
 *  system (or get the required files...).
 *
 *  Depending on the Display Character Set switched to, and the previous
 *  one as far as it is known, system("setfont ...") and/or output of
 *  escape sequences to switch console mode are done.  Curses will be
 *  temporarily suspended while that happens.
 *
 *  NOTE that the setfont calls will also affect all other virtual consoles.
 *
 *  Any ideas how to do this for other systems?
 */

#include <HTUtils.h>
#include <LYUtils.h>

#include <UCMap.h>
#include <UCDefs.h>
#include <UCAuto.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYLeaks.h>
#include <LYCharSets.h>

#ifdef EXP_CHARTRANS_AUTOSWITCH

#include <HTFile.h>
#include <www_wait.h>

#ifdef LINUX
#include <sysexits.h>		/* EX_DATAERR, etc. */
#endif

#  ifdef CAN_SWITCH_DISPLAY_CHARSET
char *charset_switch_rules;
char *charsets_directory;
int auto_other_display_charset = -1;
int codepages[2];
int real_charsets[2] =
{-1, -1};			/* Non "auto-" charsets for the cps */
int switch_display_charsets;

#  endif

#ifdef HAVE_USE_LEGACY_CODING
static int original_coding = 0;
#endif

#  ifdef __EMX__
/* If we "just include" <os2.h>, BOOLEAN conflicts. */
#  define BOOLEAN OS2_BOOLEAN	/* This file doesn't use it, conflicts */
#  define INCL_VIO		/* I want some Vio functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  define INCL_DOSNLS		/* DosQueryCp. */
#  include <os2.h>		/* Misc stuff.. */
#  include <os2thunk.h>		/* 32 bit to 16 bit pointer conv */
#  endif

#ifdef LINUX
typedef enum {
    Is_Unset,
    Is_Set,
    Dunno,
    Dont_Care
} TGen_state_t;

/*
 * List the states the console has been set to via SCS (select character-set).
 */
typedef enum {
    GN_Blat1,			/* Latin-1 */
    GN_Ucp437,			/* PC -> PC */
    GN_Kuser,			/* user-defined */
    GN_dunno,
    GN_dontCare
} TTransT_t;

static char *T_font_fn = NULL;	/* font filename */
static char *T_umap_fn = NULL;	/* unicode-map filename */

#define NOOUTPUT "2>/dev/null >/dev/null"

/*
 * Return the configured path of the setfont/consolechars program.
 */
static const char *GetSetfontPath(void)
{
    return HTGetProgramPath(ppSETFONT);
}

/*
 * setfont and consolechars have different options and available data.
 */
static BOOL isSetFont(void)
{
    const char *program = GetSetfontPath();
    const char *slash = strrchr(program, '/');
    const char *leaf = (slash ? slash + 1 : program);

    return (BOOL) !strcmp(leaf, "setfont");
}

/*
 * Here are the differences in options which affect lynx:
 */
#define setfont_u()    (isSetFont() ? "-u "  : "--sfm ")
#define setfont_o()    (isSetFont() ? "-o "  : "--old-font-raw ")
#define setfont_ou()   (isSetFont() ? "-ou " : "--old-sfm ")
#define console_font() (isSetFont() ? ""     : "--font ")

/*
 * call_setfont - execute "setfont" command via system()
 * returns:	 0  ok (as far as we know)
 *		-1  error (assume font and umap are not loaded)
 *		 1  error with umap (assume font loaded but umap empty)
 */
static int call_setfont(const char *font,
			const char *fnsuffix,
			const char *umap)
{
    const char *program = GetSetfontPath();
    char *T_setfont_cmd = NULL;
    int rv;

    /*
     * console-data package has only a few unicode maps.
     */
    if (!isSetFont())
	umap = 0;

    if ((font && T_font_fn && !strcmp(font, T_font_fn))
	&& (umap && T_umap_fn && !strcmp(umap, T_umap_fn))) {
	/*
	 * No need to repeat.
	 */
	return 0;
    }
    if (font)
	StrAllocCopy(T_font_fn, font);
    if (umap)
	StrAllocCopy(T_umap_fn, umap);

    if (!*fnsuffix)
	fnsuffix = "";

    if (non_empty(umap) && non_empty(font)) {
	HTSprintf0(&T_setfont_cmd, "%s %s%s%s %s%s %s",
		   program,
		   console_font(), font, fnsuffix,
		   setfont_u(), umap,
		   NOOUTPUT);
    } else if (non_empty(font)) {
	HTSprintf0(&T_setfont_cmd, "%s %s%s%s %s",
		   program,
		   console_font(), font, fnsuffix,
		   NOOUTPUT);
    } else if (non_empty(umap)) {
	HTSprintf0(&T_setfont_cmd, "%s %s%s %s",
		   program,
		   setfont_u(), umap,
		   NOOUTPUT);
    }

    if (T_setfont_cmd) {
	CTRACE((tfp, "Changing font: '%s'\n", T_setfont_cmd));
	rv = LYSystem(T_setfont_cmd);
	FREE(T_setfont_cmd);
	if (rv) {
	    CTRACE((tfp, "call_setfont: system returned %d (0x%x)!\n",
		    rv, rv));
	    if (rv == -1 || WIFSIGNALED(rv) || !WIFEXITED(rv)) {
		return -1;
	    } else if ((WEXITSTATUS(rv) == EX_DATAERR ||
			WEXITSTATUS(rv) == EX_NOINPUT) &&
		       non_empty(umap)) {
		/*
		 * Check if the font was loaded ok but something was wrong with
		 * the umap file.
		 */
		return 1;
	    } else {
		return -1;
	    }
	}
    }
    return 0;
}

static void write_esc(const char *p)
{
    int fd = open("/dev/tty", O_WRONLY);

    if (fd >= 0) {
	IGNORE_RC(write(fd, p, strlen(p)));
	close(fd);
    }
}

static int nonempty_file(const char *p)
{
    struct stat sb;

    return (stat(p, &sb) == 0 &&
	    S_ISREG(sb.st_mode) &&
	    (sb.st_size != 0));
}

static BOOL on_console(void)
{
    if ((x_display != NULL) ||
	LYgetXDisplay() != NULL) {
	/*
	 * We won't do anything in an xterm.  Better that way...
	 */
	return FALSE;
    }
    return TRUE;
}

/*
 * This is the thing that actually gets called from display_page().
 */
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
{
    const char *program = GetSetfontPath();
    static int lastcs = -1;
    static const char *lastname = NULL;
    static TTransT_t lastTransT = GN_dunno;
    static TGen_state_t lastUtf = Dunno;
    static TGen_state_t lastHasUmap = Dunno;

    static char *old_font = NULL;
    static char *old_umap = NULL;

    const char *name;
    TTransT_t TransT = GN_dunno;
    TGen_state_t Utf = Dunno;
    TGen_state_t HasUmap = Dunno;

    char *tmpbuf1 = NULL;
    char *tmpbuf2 = NULL;
    int status = 0;

    if (!on_console())
	return;

#ifdef HAVE_USE_LEGACY_CODING
    if (newcs < 0) {
	use_legacy_coding(original_coding);
    } else {
	original_coding = use_legacy_coding(2);
    }
#endif

    /*
     * Restore the original character set.
     */
    if (newcs < 0 || p == 0) {
	if (non_empty(old_font) &&
	    non_empty(old_umap)) {

	    if (nonempty_file(old_font)) {
		if (nonempty_file(old_umap)) {
		    HTSprintf0(&tmpbuf1, "%s %s%s %s%s %s",
			       program,
			       console_font(), old_font,
			       setfont_u(), old_umap,
			       NOOUTPUT);
		} else {
		    HTSprintf0(&tmpbuf1, "%s %s%s %s",
			       program,
			       console_font(), old_font,
			       NOOUTPUT);
		}
		CTRACE((tfp, "Restoring font: '%s'\n", tmpbuf1));
		status = LYSystem(tmpbuf1);
		if (status != 0) {
		    CTRACE((tfp, "...system returned %d (0x%x)\n", status, status));
		}
		FREE(tmpbuf1);
	    }
	}
	if (newcs < 0 && p == 0) {
	    if (old_font) {
		(void) LYRemoveTemp(old_font);
		FREE(old_font);
	    }
	    if (old_umap) {
		(void) LYRemoveTemp(old_umap);
		FREE(old_umap);
	    }
	    if (status == 0) {
		FREE(T_font_fn);
		FREE(T_umap_fn);
	    }
	}
	return;
    } else if (lastcs < 0 && old_umap == 0 && old_font == 0) {
	FILE *fp1;
	FILE *fp2 = NULL;

	if ((old_font = typecallocn(char, LY_MAXPATH)) != 0)
	      old_umap = typecallocn(char, LY_MAXPATH);

	if (old_font == NULL)
	    outofmem(__FILE__, "UCChangeTerminalCodepage");

	assert(old_font != NULL);

	if ((fp1 = LYOpenTemp(old_font, ".fnt", BIN_W)) != 0)
	    fp2 = LYOpenTemp(old_umap, ".uni", BIN_W);

	if (fp1 && fp2) {
	    size_t nlen;
	    int rv;

	    HTSprintf0(&tmpbuf1, "%s %s%s %s%s %s",
		       program,
		       setfont_o(), old_font,
		       setfont_ou(), old_umap,
		       NOOUTPUT);

	    CTRACE((tfp, "Saving font: '%s'\n", tmpbuf1));
	    rv = LYSystem(tmpbuf1);
	    if (rv != 0) {
		CTRACE((tfp, "...system returned %d (0x%x)\n", rv, rv));
	    }
	    FREE(tmpbuf1);
	    LYCloseTempFP(fp1);
	    LYCloseTempFP(fp2);

	    /* free up a few bytes */
	    if ((nlen = strlen(old_font) + 1) < LY_MAXPATH)
		old_font = typeRealloc(char, old_font, nlen);

	    if ((nlen = strlen(old_umap) + 1) < LY_MAXPATH)
		old_umap = typeRealloc(char, old_umap, nlen);
	} else {
	    if (fp1)
		(void) LYRemoveTemp(old_font);
	    FREE(old_font);
	    FREE(old_umap);
	}
    }

    name = p->MIMEname;

    /*
     * Font sizes are currently hardwired here.
     */
#define SUFF1 ".f16"
#define SUFF2 "-16.psf"
#define SUFF3 "-8x16"
#define SUFF4 "8x16"
#define SUFF5 ".cp -16"
#define SUFF6 "_8x16"

    /* NOTE: `!!umap not in kbd!!' comments below means that the *.uni file
     * is not found in kbd package.  Reference Debian Package: kbd-data,
     * Version: 0.96a-14.  They should be located elsewhere or generated.
     * Also some cpNNN fonts used below are not in the kbd-data.  - kw
     */

    if (!StrNCmp(name, "iso-8859-1", 10) &&
	(!name[10] || !isdigit(UCH(name[10])))) {
	if ((lastHasUmap == Is_Set) && !strcmp(lastname, "cp850")) {
	    /*
	     * cp850 already contains all latin1 characters.
	     */
	    if (lastTransT != GN_Blat1) {
		TransT = GN_Blat1;
	    }
	} else {
	    /*
	     * "setfont lat1u-16.psf -u lat1u.uni"
	     */
	    status = call_setfont("lat1u", SUFF2, "lat1u.uni");
	    HasUmap = Is_Set;
	    if (lastTransT != GN_Blat1) {
		TransT = GN_Blat1;
	    }
	}
	Utf = Is_Unset;
    } else if (!strcmp(name, "iso-8859-2")) {
	/*
	 * "setfont iso02.f16 -u iso02.uni"
	 */
	status = call_setfont("iso02", SUFF1, "iso02.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "iso-8859-15")) {
	/*
	 * "setfont lat0-16.psf"
	 */
	status = call_setfont("lat0", SUFF2, NULL);
	TransT = GN_Blat1;	/* bogus! */
	HasUmap = Dunno;	/* distributed lat0 files have bogus map data! */
	Utf = Is_Unset;
    } else if (!StrNCmp(name, "iso-8859-", 9)) {
	if (strlen(name) <= 10 || !isdigit(UCH(name[10])))
	    HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	else
	    HTSprintf0(&tmpbuf1, "iso%s", &name[9]);
	HTSprintf0(&tmpbuf2, "%s.uni", tmpbuf1);
	/*
	 * "setfont iso0N.f16 -u iso0N.uni"
	 */
	status = call_setfont(tmpbuf1, SUFF1, tmpbuf2);
	FREE(tmpbuf1);
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "koi8-r")) {
	/*
	 * "setfont koi8-8x16"
	 * !!umap not in kbd!!
	 */
	status = call_setfont("koi8", SUFF3, "koi8r.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "koi8-u")) {
	/*
	 * "setfont koi8u_8x16"
	 * !!umap not in kbd!!
	 */
	status = call_setfont("koi8u", SUFF6, "koi8u.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp437")) {
	/*
	 * "setfont default8x16 -u cp437.uni"
	 */
	status = call_setfont("default", SUFF4, "cp437.uni");
	if (lastTransT == GN_Kuser || lastTransT == GN_Ucp437)
	    TransT = GN_dontCare;
	else
	    TransT = GN_Ucp437;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp850")) {
	/*
	 * "setfont cp850-8x16 -u cp850.uni"
	 * !!umap not in kbd!!
	 */
	status = call_setfont("cp850", SUFF3, "cp850.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp866") ||
	       !strcmp(name, "cp852") ||
	       !strcmp(name, "cp862")) {	/* MS-Kermit has these files */
	HTSprintf0(&tmpbuf2, "%s.uni", name);
	/*
	 * "setfont cpNNN.f16"
	 * !!umap not in kbd!!
	 */
	status = call_setfont(name, SUFF1, tmpbuf2);
	FREE(tmpbuf2);
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp737")) {
	/*
	 * "setfont cp737.cp"
	 * !!umap not in kbd!!
	 */
	if (isSetFont()) {
	    status = call_setfont("737", SUFF5, "cp737.uni");
	} else {
	    status = call_setfont("greek", "", "cp737.uni");
	}
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "cp857")) {
	status = call_setfont("cp857", SUFF3, "cp857.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strcmp(name, "x-transparent")) {
	Utf = Dont_Care;
    } else if (!strcmp(name, "us-ascii")) {
	Utf = Dont_Care;
    } else if (!StrNCmp(name, "mnem", 4)) {
	Utf = Dont_Care;
    }

    if (status == 1)
	HasUmap = Is_Unset;
    else if (status < 0) {
	if (HasUmap == Is_Set)
	    HasUmap = Dunno;
	name = "unknown-8bit";
    }

    if (TransT != lastTransT) {
	if (TransT == GN_Blat1) {
	    /*
	     * Switch Linux console to lat1 table.
	     */
	    write_esc("\033(B");
	} else if (TransT == GN_Ucp437) {
	    /*
	     * Switch Linux console to 437 table?
	     */
	    write_esc("\033(U");
	} else if (TransT == GN_Kuser) {
	    /*
	     * Switch Linux console to user table.
	     */
	    write_esc("\033(K");
	}
	if (TransT != GN_dunno && TransT != GN_dontCare) {
	    lastTransT = TransT;
	}
    }

    if (HasUmap != Dont_Care && HasUmap != Dunno)
	lastHasUmap = HasUmap;

    if (p->enc == UCT_ENC_UTF8) {
	if (lastUtf != Is_Set) {
	    Utf = Is_Set;
	    /*
	     * Turn Linux console UTF8 mode ON.
	     */
	    write_esc("\033%G");
	    lastUtf = Utf;
	}
	return;
    } else if (lastUtf == Is_Set && Utf != Dont_Care) {
	Utf = Is_Unset;
	/*
	 * Turn Linux console UTF8 mode OFF.
	 */
	write_esc("\033%@@");
	lastUtf = Utf;
    }

    if (Utf != Dont_Care && Utf != Dunno)
	lastUtf = Utf;

    lastcs = newcs;
    lastname = name;
}

#else /* Not LINUX: */
/*
 * This is the thing that actually gets called from display_page().
 */
void UCChangeTerminalCodepage(int newcs,
			      LYUCcharset *p)
{
#ifdef __EMX__
    int res = 0;

#ifdef HAVE_USE_LEGACY_CODING
    if (newcs < 0) {
	use_legacy_coding(original_coding);
    } else {
	original_coding = use_legacy_coding(2);
    }
#endif

    if (newcs < 0)
	newcs = auto_display_charset;
    res = Switch_Display_Charset(newcs, SWITCH_DISPLAY_CHARSET_REALLY);
    CTRACE((tfp,
	    "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n",
	    newcs, res));
#else
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
#endif
}
#endif /* LINUX */

#ifdef CAN_SWITCH_DISPLAY_CHARSET

int Find_Best_Display_Charset(int ord)
{
    const char *name = LYCharSet_UC[ord].MIMEname;
    char *s = charset_switch_rules, *r;
    char buf[160];
    static int lowercase;
    int n = strlen(name), source = 1;

    if (!s || !n)
	return ord;
    if (!lowercase++)
	LYLowerCase(charset_switch_rules);
    while (1) {
	while (*s && StrChr(" \t,", *s))
	    s++;		/* Go to start of a name or ':' */
	if (!*s && source)
	    return ord;		/* OK to find nothing */
	if (!*s) {
	    sprintf(buf,
		    gettext("No destination for '%.80s' in CHARSET_SWITCH_RULES"),
		    name);
	    HTInfoMsg(buf);
	    return ord;
	}
	if (*s == ':') {
	    /* Before the replacement name */
	    while (*s && StrChr(" \t:", *s))
		s++;		/* Go to the replacement */
	    /* At start of the replacement name */
	    r = s;
	    while (*s && !StrChr(" \t,:", *s))
		s++;		/* Skip the replacement */
	    if (source)
		continue;
	    break;
	}
	/* At start of the source name */
	if (source && !strncasecomp(name, s, n) && StrChr(" \t,", s[n])) {	/* Found! */
	    source = 0;
	    s += n;
	    continue;		/* Look for the replacement */
	}
	while (*s && !StrChr(" \t,:", *s))
	    s++;		/* Skip the other source names */
    }
    /* Here r point to the replacement, s to the end of the replacement. */
    if (s >= r + sizeof(buf)) {
	HTInfoMsg(gettext("Charset name in CHARSET_SWITCH_RULES too long"));
	return ord;
    }
    LYStrNCpy(buf, r, s - r);
    n = UCGetLYhndl_byMIME(buf);
    if (n < 0) {
	sprintf(buf,
		gettext("Unknown charset name '%.*s' in CHARSET_SWITCH_RULES"),
		s - r, r);
	HTInfoMsg(buf);
	return ord;
    }
    return n;
}

#  ifdef __EMX__
/* Switch display for the best fit for LYCharSet_UC[ord].
   If really is MAYBE, the switch is tentative only, another switch may happen
   before the actual display.

   Returns the charset we switched to.  */
static int _Switch_Display_Charset(int ord, enum switch_display_charset_t really)
{
    const char *name;
    unsigned short cp;
    static int font_loaded_for = -1, old_h, old_w;
    int rc, ord1;
    UCHAR msgbuf[MAXPATHLEN + 80];

    CTRACE((tfp, "_Switch_Display_Charset(cp=%d, really=%d).\n", ord, really));
    /* Do not trust current_char_set unless REALLY, we fake it if MAYBE! */
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;
    if (ord == auto_other_display_charset
	|| ord == auto_display_charset || ord == font_loaded_for) {
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord;		/* Report success, to avoid flicker, switch later */
    } else			/* Currently supports only koi8-r to cp866 translation */
	ord = Find_Best_Display_Charset(ord);

    /* Ignore sizechange unless the font is loaded */
    if (ord != font_loaded_for && really == SWITCH_DISPLAY_CHARSET_RESIZE)
	return ord;

    if (ord == real_charsets[0] || ord == real_charsets[1]) {
	ord1 = (ord == real_charsets[1]
		? auto_other_display_charset : auto_display_charset);
	if (really == SWITCH_DISPLAY_CHARSET_MAYBE)
	    return ord;		/* Can switch later, report success to avoid flicker */
    } else
	ord1 = ord;
    if (ord == current_char_set && really == SWITCH_DISPLAY_CHARSET_MAYBE)
	return ord;

    name = LYCharSet_UC[ord1].MIMEname;
    if (ord1 == auto_other_display_charset || ord1 == auto_display_charset) {
      retry:
	rc = VioSetCp(0, codepages[ord1 == auto_other_display_charset], 0);
	if (rc == 0)
	    goto report;
      err:
	sprintf(msgbuf, gettext("Can't change to '%s': err=%#x=%d"), name, rc, rc);
	HTInfoMsg(msgbuf);
	return -1;
    }

    /* Not a "prepared" codepage.  Need to load the user font. */
    if (charsets_directory) {
	TIB *tib;		/* Can't load font in a windowed-VIO */
	PIB *pib;
	VIOFONTINFO f[2];
	VIOFONTINFO *font;
	UCHAR b[1 << 17];
	UCHAR *buf = b;
	UCHAR fnamebuf[MAXPATHLEN];
	FILE *file;
	APIRET rc;
	long i, j;

	/* 0 means a FS protected-mode session */
	if (font_loaded_for == -1	/* Did not try it yet */
	    && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0)) {
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	/* Should not cross 64K boundaries: */
	font = f;
	if (((((ULONG) (char *) f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
	    font++;
	if (((ULONG) buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG) buf) & 0xFFFF);
	font->cb = sizeof(*font);	/* How large is this structure */
	font->type = 0;		/* Not the BIOS, the loaded font. */
	font->cbData = 65535;	/* How large is my buffer? */
	font->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */

	rc = VioGetFont(font, 0);	/* Retrieve data for current font */
	if (rc) {
	    sprintf(msgbuf,
		    gettext("Can't fetch current font info: err=%#x=%d"), rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	if (ord1 == font_loaded_for
	    && old_h == font->cyCell && old_w == font->cxCell) {
	    /* The same as the previous font */
	    if ((rc = VioSetCp(0, -1, 0)))	/* -1: User font */
		goto err;
	    goto report;
	}
	sprintf(fnamebuf, "%s/%dx%d/%s.fnt",
		charsets_directory, font->cyCell, font->cxCell, name);
	file = fopen(fnamebuf, BIN_R);
	if (!file) {
	    sprintf(msgbuf, gettext("Can't open font file '%s'"), fnamebuf);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	i = ftell(file);
	fseek(file, 0, SEEK_END);
	if (ftell(file) - i != font->cbData) {
	    fclose(file);
	    sprintf(msgbuf, gettext("Mismatch of size of font file '%s'"), fnamebuf);
	    HTAlert(msgbuf);
	    ord = ord1 = auto_display_charset;
	    goto retry;
	}
	fseek(file, i, SEEK_SET);
	fread(buf, 1, font->cbData, file);
	fclose(file);
	rc = VioSetFont(font, 0);	/* Put it all back.. */
	if (rc) {
	    sprintf(msgbuf, gettext("Can't set font: err=%#x=%d"), rc, rc);
	    HTInfoMsg(msgbuf);
	    ord = ord1 = auto_display_charset;
	    font_loaded_for = -1;
	    goto retry;
	}
	font_loaded_for = ord1;
	old_h = font->cyCell;
	old_w = font->cxCell;
    } else {
	ord = ord1 = auto_display_charset;
	goto retry;
    }
  report:
    CTRACE((tfp, "Display font set to '%s'.\n", name));
    return ord;
}
#  endif /* __EMX__ */

int Switch_Display_Charset(const int ord, const enum switch_display_charset_t really)
{
    int prev = current_char_set;
    int res;
    static int repeated;

    if (!switch_display_charsets)
	return 0;
    res = _Switch_Display_Charset(ord, really);
    if (res < 0 || prev == res)	/* No change */
	return 0;
    /* Register the change */
    current_char_set = res;
    HTMLUseCharacterSet(current_char_set);
    return 1;
}
#endif /* CAN_SWITCH_DISPLAY_CHARSET */

#else /* EXP_CHARTRANS_AUTOSWITCH not defined: */
/*
 * This is the thing that actually gets called from display_page().
 */
void UCChangeTerminalCodepage(int newcs GCC_UNUSED,
			      LYUCcharset *p GCC_UNUSED)
{
    CTRACE((tfp, "UCChangeTerminalCodepage: Called, but not implemented!"));
}
#endif /* EXP_CHARTRANS_AUTOSWITCH */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: UCAuto.c,v 1.39 2009/01/01 22:07:18 tom Exp $
a77 1
    GN_0decgraf,		/* VT100 graphics */
d200 1
a200 1
	write(fd, p, strlen(p));
d292 1
a292 1
		LYRemoveTemp(old_font);
d296 1
a296 1
		LYRemoveTemp(old_umap);
d312 5
d347 1
a347 3
		LYRemoveTemp(old_font);
	    if (fp2)
		LYRemoveTemp(old_umap);
d371 1
a371 1
    if (!strncmp(name, "iso-8859-1", 10) &&
d407 1
a407 1
    } else if (!strncmp(name, "iso-8859-", 9)) {
d495 1
a495 1
    } else if (!strncmp(name, "mnem", 4)) {
a512 2
	} else if (TransT == GN_0decgraf) {
	    write_esc("\033(0");
a525 2
	} else {
	    TransT = lastTransT;
d603 1
a603 1
	while (*s && strchr(" \t,", *s))
d608 2
a609 1
	    sprintf(buf, "No destination for '%.80s' in CHARSET_SWITCH_RULES",
d616 1
a616 1
	    while (*s && strchr(" \t:", *s))
d620 1
a620 1
	    while (*s && !strchr(" \t,:", *s))
d627 1
a627 1
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {	/* Found! */
d632 1
a632 1
	while (*s && !strchr(" \t,:", *s))
d640 1
a640 2
    strncpy(buf, r, s - r);
    buf[s - r] = '\0';
d643 2
a644 1
	sprintf(buf, "Unknown charset name '%.*s' in CHARSET_SWITCH_RULES",
d698 1
a698 1
	sprintf(msgbuf, "Can't change to '%s': err=%#x=%d", name, rc, rc);
d735 2
a736 1
	    sprintf(msgbuf, "Can't fetch current font info: err=%#x=%d", rc, rc);
d752 1
a752 1
	    sprintf(msgbuf, "Can't open font file '%s'", fnamebuf);
d761 1
a761 1
	    sprintf(msgbuf, "Mismatch of size of font file '%s'", fnamebuf);
d771 1
a771 1
	    sprintf(msgbuf, "Can't set font: err=%#x=%d", rc, rc);
d788 1
a788 1
#  endif			/* __EMX__ */
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d34 1
d107 1
a107 1
    return !strcmp(leaf, "setfont");
d178 5
a182 3
	    if ((rv == (EX_DATAERR << 8) ||
		 rv == (EX_NOINPUT << 8)) &&
		non_empty(umap)) {
d699 1
a699 1
	sprintf(msgbuf, "Can't change to '%s': err=%#lx=%ld", name, rc, rc);
d736 1
a736 1
	    sprintf(msgbuf, "Can't fetch current font info: err=%#lx=%ld", rc, rc);
d771 1
a771 1
	    sprintf(msgbuf, "Can't set font: err=%#lx=%ld", rc, rc);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 14
a15 14
**  This file contains code for changing the Linux console mode.
**  Currently some names for font files are hardwired in here.
**  You have to change this code if it needs accommodation for your
**  system (or get the required files...).
**
**  Depending on the Display Character Set switched to, and the previous
**  one as far as it is known, system("setfont ...") and/or output of
**  escape sequences to switch console mode are done.  Curses will be
**  temporarily suspended while that happens.
**
**  NOTE that the setfont calls will also affect all other virtual consoles.
**
**  Any ideas how to do this for other systems?
*/
d24 1
d31 6
d42 2
a43 1
int real_charsets[2] = {-1, -1};	/* Non "auto-" charsets for the cps */
d45 1
d48 4
d54 6
a59 6
#  define BOOLEAN OS2_BOOLEAN		/* This file doesn't use it, conflicts */
#  define INCL_VIO			/* I want some Vio functions.. */
#  define INCL_DOSPROCESS			/* TIB PIB. */
#  define INCL_DOSNLS			/* DosQueryCp. */
#  include <os2.h>			/* Misc stuff.. */
#  include <os2thunk.h>			/* 32 bit to 16 bit pointer conv */
d64 4
a67 1
    Is_Unset, Is_Set, Dunno, Dont_Care
d69 4
d74 6
a79 4
    G0, G1
} TGNstate_t;
typedef enum {
    GN_Blat1, GN_0decgraf, GN_Ucp437, GN_Kuser, GN_dunno, GN_dontCare
d82 2
a83 2
static char *T_font_fn = NULL;
static char *T_umap_fn = NULL;
a84 1
#define SETFONT "setfont"
d88 9
a96 4
 *  call_setfont - execute "setfont" command via system()
 *  returns:	0  ok (as far as we know)
 *	       -1  error (assume font and umap are not loaded)
 *		1  error with umap (assume font loaded but umap empty)
d98 1
a98 4
PRIVATE int call_setfont ARGS3(
	CONST char *,	font,
	CONST char *,	fnsuffix,
	CONST char *,	umap)
d100 26
d129 6
d136 1
a136 1
     && (umap && T_umap_fn && !strcmp(umap, T_umap_fn))) {
d138 1
a138 1
	 *  No need to repeat.
d150 12
a161 4
    if (umap &&*umap && font && *font) {
	HTSprintf0(&T_setfont_cmd, "%s %s%s -u %s %s",
		SETFONT, font, fnsuffix,	umap,	NOOUTPUT);
    } else if (font && *font) {
d163 3
a165 4
		SETFONT, font, fnsuffix,		NOOUTPUT);
    } else if (umap && *umap) {
	HTSprintf0(&T_setfont_cmd, "%s -u %s %s",
		SETFONT,			umap,	NOOUTPUT);
d169 1
a169 1
	CTRACE((tfp, "Executing setfont: '%s'\n", T_setfont_cmd));
d174 4
a177 2
		   rv, rv));
	    if ((rv == 0x4200 || rv == 0x4100) && umap && *umap)
d179 2
a180 3
		 * It seems setfont returns 65 or 66 to the shell if
		 * the font was loaded ok but something was wrong with
		 * the umap file. - kw
d183 1
a183 1
	    else
d185 1
d191 1
a191 2
PRIVATE void write_esc ARGS1(
	CONST char *,	p)
d201 1
a201 2
PRIVATE int nonempty_file ARGS1(
	CONST char *,	p)
d210 12
d223 1
a223 1
 *  This is the thing that actually gets called from display_page().
d225 2
a226 3
PUBLIC void UCChangeTerminalCodepage ARGS2(
	int,		newcs,
	LYUCcharset *,	p)
d228 1
d230 1
a230 1
    static CONST char * lastname = NULL;
d238 1
a238 1
    CONST char * name;
d247 11
d259 1
a259 1
     *	Restore the original character set.
d262 10
a271 9
	if (old_font && *old_font &&
	    old_umap && *old_umap) {
	    int have_font = nonempty_file(old_font);
	    int have_umap = nonempty_file(old_umap);

	    if (have_font) {
		if (have_umap) {
		    HTSprintf0(&tmpbuf1, "%s %s -u %s %s",
			    SETFONT, old_font, old_umap, NOOUTPUT);
d273 4
a276 2
		    HTSprintf0(&tmpbuf1, "%s %s %s",
			    SETFONT, old_font, NOOUTPUT);
d278 1
a278 1
		CTRACE((tfp, "Executing setfont to restore: '%s'\n", tmpbuf1));
d280 3
d302 7
a308 5
	FILE * fp1;
	FILE * fp2 = NULL;
	if ((old_font = typecallocn(char, LY_MAXPATH)))
	    old_umap = typecallocn(char, LY_MAXPATH);
	if ((fp1 = LYOpenTemp(old_font, ".fnt", BIN_W)))
d310 1
d313 13
a325 5
	    char *rp;
	    HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		       SETFONT, old_font, old_umap, NOOUTPUT);
	    CTRACE((tfp, "Executing setfont to save: '%s'\n", tmpbuf1));
	    LYSystem(tmpbuf1);
d329 7
a335 6
	    if ((nlen = strlen(old_font)) + 1 < LY_MAXPATH &&
		 (rp = realloc(old_font, nlen + 1)))
		old_font = rp;
	    if ((nlen = strlen(old_umap)) + 1 < LY_MAXPATH &&
		 (rp = realloc(old_umap, nlen + 1)))
		old_umap = rp;
d349 1
a349 1
     *	Font sizes are currently hardwired here.
d356 1
d358 4
a361 2
    /*
     *	Use this for output of escape sequences.
a362 13
    if ((x_display != NULL) ||
	LYgetXDisplay() != NULL) {
	/*
	 *  We won't do anything in an xterm.  Better that way...
	 */
	return;
    }

    /* NOTE: `!!umap not in kbd!!' comments below means that the *.uni file
       is not found in kbd package.  Reference Debian Package: kbd-data,
       Version: 0.96a-14.  They should be located elsewhere or generated.
       Also some cpNNN fonts used below are not in the kbd-data.  - kw
       */
d365 1
a365 2
	       (!name[10] || !isdigit(UCH(name[10])))
	) {
d368 1
a368 1
	     *	cp850 already contains all latin1 characters.
d375 1
a375 1
	     *	"setfont lat1u-16.psf -u lat1u.uni"
d386 1
a386 1
	 *  "setfont iso02.f16 -u iso02.uni"
d394 1
a394 1
	 *  "setfont lat0-16.psf"
d398 1
a398 1
	HasUmap = Dunno; /* distributed lat0 files have bogus map data! */
d407 1
a407 1
	 *  "setfont iso0N.f16 -u iso0N.uni"
d417 11
a427 1
	 *  "setfont koi8-8x16"
d429 1
a429 1
	status = call_setfont("koi8", SUFF3, "koi8r.uni"); /* !!umap not in kbd!! */
d435 1
a435 1
	 *  "setfont default8x16 -u cp437.uni"
d446 2
a447 1
	 *  "setfont cp850-8x16 -u cp850.uni"
d449 1
a449 1
	status = call_setfont("cp850", SUFF3, "cp850.uni"); /* !!umap not in kbd!! */
d455 1
a455 1
	       !strcmp(name, "cp862")) { /* MS-Kermit has these files */
d458 2
a459 1
	 *  "setfont cpNNN.f16"
d461 1
a461 1
	status = call_setfont(name, SUFF1, tmpbuf2); /* !!umap not in kbd!! */
d468 2
a469 1
	 *  "setfont cp737.cp"
d471 10
a480 1
	status = call_setfont("737", SUFF5, "cp737.uni"); /* !!umap not in kbd!! */
d503 1
a503 1
	     *	Switch Linux console to lat1 table.
d509 3
a511 3
	     /*
	      *  Switch Linux console to 437 table?
	      */
d514 3
a516 3
	     /*
	      *  Switch Linux console to user table.
	      */
d533 1
a533 1
	     *	Turn Linux console UTF8 mode ON.
d542 1
a542 1
	 *  Turn Linux console UTF8 mode OFF.
d557 1
a557 1
 *  This is the thing that actually gets called from display_page().
d559 2
a560 3
PUBLIC void UCChangeTerminalCodepage ARGS2(
	int,		newcs,
	LYUCcharset *,	p)
d565 8
d576 3
a578 1
    CTRACE((tfp, "UCChangeTerminalCodepage: Switch_Display_Charset(%d) returned %d\n", newcs, res));
d587 1
a587 1
PUBLIC int Find_Best_Display_Charset ARGS1 (int, ord)
d589 1
a589 1
    CONST char *name = LYCharSet_UC[ord].MIMEname;
d601 1
a601 1
	    s++;			/* Go to start of a name or ':' */
d603 1
a603 1
	    return ord;			/* OK to find nothing */
d613 1
a613 1
		s++;			/* Go to the replacement */
d617 1
a617 1
		s++;			/* Skip the replacement */
d623 1
a623 1
	if (source && !strnicmp(name, s, n) && strchr(" \t,", s[n])) {/* Found! */
d626 1
a626 1
	    continue;			/* Look for the replacement */
d629 1
a629 1
	    s++;			/* Skip the other source names */
d636 2
a637 2
    strncpy(buf, r, s-r);
    buf[s-r] = '\0';
d641 1
a641 1
		s-r, r);
d654 1
a654 1
PRIVATE int _Switch_Display_Charset ARGS2 (int, ord, enum switch_display_charset_t, really)
d656 1
a656 1
    CONST char *name;
d669 2
a670 2
	    return ord; /* Report success, to avoid flicker, switch later */
    } else	/* Currently supports only koi8-r to cp866 translation */
d679 1
a679 1
	       ? auto_other_display_charset : auto_display_charset);
d681 1
a681 1
	    return ord; /* Can switch later, report success to avoid flicker */
d690 1
a690 1
	rc = VioSetCp(0,codepages[ord1 == auto_other_display_charset],0);
d701 1
a701 1
	TIB *tib;			/* Can't load font in a windowed-VIO */
d705 1
a705 1
	UCHAR b[1<<17];
d708 1
a708 1
	FILE  *file;
d713 2
a714 2
	if ( font_loaded_for == -1		/* Did not try it yet */
	     && (DosGetInfoBlocks(&tib, &pib) || pib->pib_ultype != 0) ) {
d720 1
a720 1
	if (((((ULONG)(char*)f) + sizeof(*font)) & 0xFFFF) < sizeof(*font))
d722 2
a723 2
	if (((ULONG)buf) & 0xFFFF)
	    buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
d725 3
a727 3
	font->type=0;			/* Not the BIOS, the loaded font. */
	font->cbData = 65535;		/* How large is my buffer? */
	font->pbData = _emx_32to16(buf); /* Wants an 16:16 pointer */
d729 1
a729 1
	rc = VioGetFont(font,0);	/* Retrieve data for current font */
d736 2
a737 2
	if ( ord1 == font_loaded_for
	     && old_h == font->cyCell && old_w == font->cxCell ) {
d762 1
a762 1
	fread(buf, 1, font->cbData,file);
d764 1
a764 1
	rc = VioSetFont(font,0);	/* Put it all back.. */
d783 1
a783 1
#  endif /* __EMX__ */
d785 1
a785 1
PUBLIC int Switch_Display_Charset ARGS2 (CONST int, ord, CONST enum switch_display_charset_t, really)
d791 1
a791 5
    if (!switch_display_charsets
	&& (really == SWITCH_DISPLAY_CHARSET_MAYBE
	    /* The first switch is not due to an interactive action */
	    || (really == SWITCH_DISPLAY_CHARSET_REALLY
		&& !(repeated++))))
d794 1
a794 1
    if (res < 0 || prev == res)		/* No change */
d805 1
a805 1
 *  This is the thing that actually gets called from display_page().
d807 2
a808 3
PUBLIC void UCChangeTerminalCodepage ARGS2(
	int,		newcs GCC_UNUSED,
	LYUCcharset *,	p GCC_UNUSED)
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d510 1
a510 1
	HTInfoMsg("Charset name in CHARSET_SWITCH_RULES too long");
d551 1
a551 1
    if (ord != font_loaded_for && really == SWITCH_DISPLAY_CHARSET_SIZECHANGE)
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d4 1
a4 1
**  You have to change this code if it needs accomodation for your
d26 1
d30 19
d66 10
a75 4
PRIVATE void call_setfont ARGS3(
	char *, 	font,
	char *, 	fnsuffix,
	char *, 	umap)
d78 1
d85 1
a85 1
	return;
d107 2
a108 2
	CTRACE(tfp, "Executing setfont: '%s'\n", T_setfont_cmd);
	LYSystem(T_setfont_cmd);
d110 13
d124 1
d161 2
a162 2
    static char *old_font;
    static char *old_umap;
d171 1
d190 2
a191 1
		LYSystem(tmpbuf1);
d194 44
a237 2

	    remove(old_font);
a238 3
	    old_font = 0;

	    remove(old_umap);
a239 1
	    old_umap = 0;
a240 8
	return;
    } else if (lastcs < 0 && old_umap == 0 && old_font == 0) {
	old_umap = tempnam((char *)0, "umap");
	old_font = tempnam((char *)0, "font");
	HTSprintf0(&tmpbuf1, "%s -o %s -ou %s %s",
		SETFONT, old_font, old_umap, NOOUTPUT);
	LYSystem(tmpbuf1);
	FREE(tmpbuf1);
d252 1
d265 9
a273 6
    if (!strcmp(name, "iso-8859-10")) {
	call_setfont("iso10", SUFF1, "iso10.uni");
	TransT = GN_Kuser;
	HasUmap = Is_Set;
	Utf = Is_Unset;
    } else if (!strncmp(name, "iso-8859-1", 10)) {
d285 1
a285 1
	    call_setfont("lat1u", SUFF2, "lat1u.uni");
a292 6
#ifdef NOTDEFINED
	/*
	 *  "setfont lat2-16.psf -u lat2.uni"
	 */
	call_setfont("lat2", SUFF2, "lat2.uni");  */
#endif /* NOTDEFINED */
d296 1
a296 1
	call_setfont("iso02", SUFF1, "iso02.uni");
d300 8
d309 5
a313 2
	HTSprintf0(&tmpbuf1, "iso0%s", &name[9]);
	HTSprintf0(&tmpbuf2, "iso0%s%s", &name[9],".uni");
d317 2
a318 1
	call_setfont(tmpbuf1, SUFF1, tmpbuf2);
d327 1
a327 1
	call_setfont("koi8", SUFF3, NULL);
d329 1
a329 1
	HasUmap = Is_Unset;
d335 2
a336 2
	call_setfont("default", SUFF4, "cp437.uni");
	if (TransT == GN_Kuser || TransT == GN_Ucp437)
d346 21
a366 1
	call_setfont("cp850", SUFF3, "cp850.uni");
d378 8
d452 4
a455 4
    if (p->codepage) {
	res = VioSetCp(0, p->codepage, 0);
	CTRACE(tfp, "UCChangeTerminalCodepage: VioSetCp(%d) returned %d\n", p->codepage, res);
    }
d457 1
a457 1
    CTRACE(tfp, "UCChangeTerminalCodepage: Called, but not implemented!");
d462 222
d692 1
a692 1
    CTRACE(tfp, "UCChangeTerminalCodepage: Called, but not implemented!");
@


1.1
log
@Initial revision
@
text
@d17 2
a18 2
#include "HTUtils.h"
#include "tcp.h"
d20 6
a25 6
#include "UCMap.h"
#include "UCDefs.h"
#include "UCAuto.h"
#include "LYGlobalDefs.h"
#include "LYClean.h"
#include "LYUtils.h"
a28 6
#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */

d40 3
a42 3
static char T_font_fn[100] = "\0";
static char T_umap_fn[100] = "\0";
static char T_setfont_cmd[200] = "\0";
d51 4
a54 2
    if (font && *font && umap && *umap &&
	!strcmp(font, T_font_fn) && !strcmp(umap, T_umap_fn)) {
d61 1
a61 1
	strcpy(T_font_fn, font);
d63 1
a63 1
	strcpy(T_umap_fn, umap);
d69 1
a69 1
	sprintf(T_setfont_cmd, "%s %s%s -u %s %s",
d72 1
a72 1
	sprintf(T_setfont_cmd, "%s %s%s %s",
d75 1
a75 1
	sprintf(T_setfont_cmd, "%s -u %s %s",
a76 2
    } else {
	*T_setfont_cmd = '\0';
d79 4
a82 5
    if (*T_setfont_cmd) {
	if (TRACE) {
	    fprintf(stderr, "Executing setfont: '%s'\n", T_setfont_cmd);
	}
	system(T_setfont_cmd);
d103 1
a103 1
	    (sb.st_mode & S_IFMT) == S_IFREG &&
d128 2
a129 2
    char tmpbuf1[100], tmpbuf2[20];
    char *cp;
d142 1
a142 1
		    sprintf(tmpbuf1, "%s %s -u %s %s",
d145 1
a145 1
		    sprintf(tmpbuf1, "%s %s %s",
d148 2
a149 1
		system(tmpbuf1);
d153 1
a153 1
	    free(old_font);
d157 1
a157 1
	    free(old_umap);
d164 1
a164 1
	sprintf(tmpbuf1, "%s -o %s -ou %s %s",
d166 2
a167 1
	system(tmpbuf1);
d183 2
a184 2
    if ((display != NULL) ||
	((cp = getenv(DISPLAY)) != NULL && *cp != '\0')) {
d230 2
a231 2
	sprintf(tmpbuf1, "iso0%s", &name[9]);
	sprintf(tmpbuf2, "iso0%s%s", &name[9],".uni");
d236 1
d338 6
a343 3
    if (TRACE) {
	fprintf(stderr,
		"UCChangeTerminalCodepage: Called, but not implemented!");
d345 3
d359 1
a359 4
    if (TRACE) {
	fprintf(stderr,
		"UCChangeTerminalCodepage: Called, but not implemented!");
    }
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
