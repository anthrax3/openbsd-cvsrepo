head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.25;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.38;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.06;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.58;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.58;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTInit.c,v 1.88 2014/02/13 21:39:04 tom Exp $
 *
 *		Configuration-specific Initialization		HTInit.c
 *		----------------------------------------
 */

/*	Define a basic set of suffixes and presentations
 *	------------------------------------------------
 */

#include <HTUtils.h>

/* Implements:
*/
#include <HTInit.h>

#include <HTML.h>
#include <HTPlain.h>
#include <HTMLGen.h>
#include <HTFile.h>
#include <HTFormat.h>
#include <HTMIME.h>
#include <HTWSRC.h>

#include <HTSaveToFile.h>	/* LJM */
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>

#include <LYexit.h>
#include <LYLeaks.h>

#define CTrace(p) CTRACE2(TRACE_CFG, p)

static int HTLoadTypesConfigFile(char *fn, AcceptMedia media);
static int HTLoadExtensionsConfigFile(char *fn);

#define SET_SUFFIX1(suffix, description, type) \
	HTSetSuffix(suffix, description, type, 1.0)

#define SET_SUFFIX5(suffix, mimetype, type, description) \
       HTSetSuffix5(suffix, mimetype, type, description, 1.0)

#define SET_PRESENT(mimetype, command, quality, delay) \
  HTSetPresentation(mimetype, command, 0, quality, delay, 0.0, 0L, media)

#define SET_EXTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 3.0, 0.0, 0L, mediaEXT)

#define SET_INTERNL(rep_in, rep_out, command, quality) \
    HTSetConversion(rep_in, rep_out, command, quality, 0.0, 0.0, 0L, mediaINT)

void HTFormatInit(void)
{
    AcceptMedia media = mediaEXT;

    CTrace((tfp, "HTFormatInit\n"));
#ifdef NeXT
    SET_PRESENT("application/postscript", "open %s", 1.0, 2.0);
    SET_PRESENT("image/x-tiff", "open %s", 2.0, 2.0);
    SET_PRESENT("image/tiff", "open %s", 1.0, 2.0);
    SET_PRESENT("audio/basic", "open %s", 1.0, 2.0);
    SET_PRESENT("*", "open %s", 1.0, 0.0);
#else
    if (LYgetXDisplay() != 0) {	/* Must have X11 */
	SET_PRESENT("application/postscript", "ghostview %s&", 1.0, 3.0);
	if (non_empty(XLoadImageCommand)) {
	    /* *INDENT-OFF* */
	    SET_PRESENT("image/gif",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbm",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-xbitmap", XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-png",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/png",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-rgb",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/x-tiff",	   XLoadImageCommand, 2.0, 3.0);
	    SET_PRESENT("image/tiff",	   XLoadImageCommand, 1.0, 3.0);
	    SET_PRESENT("image/jpeg",	   XLoadImageCommand, 1.0, 3.0);
	    /* *INDENT-ON* */

	}
	SET_PRESENT("video/mpeg", "mpeg_play %s &", 1.0, 3.0);

    }
#endif

#ifdef EXEC_SCRIPTS
    /* set quality to 999.0 for protected exec applications */
#ifndef VMS
    SET_PRESENT("application/x-csh", "csh %s", 999.0, 3.0);
    SET_PRESENT("application/x-sh", "sh %s", 999.0, 3.0);
    SET_PRESENT("application/x-ksh", "ksh %s", 999.0, 3.0);
#else
    SET_PRESENT("application/x-VMS_script", "@@%s", 999.0, 3.0);
#endif /* not VMS */
#endif /* EXEC_SCRIPTS */

    /*
     * Add our header handlers.
     */
    SET_INTERNL("message/x-http-redirection", "*", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/present", HTMIMERedirect, 2.0);
    SET_INTERNL("message/x-http-redirection", "www/debug", HTMIMERedirect, 1.0);
    SET_INTERNL("www/mime", "www/present", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/download", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/source", HTMIMEConvert, 1.0);
    SET_INTERNL("www/mime", "www/dump", HTMIMEConvert, 1.0);

    /*
     * Add our compressed file handlers.
     */
    SET_INTERNL("www/compressed", "www/download", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/present", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/source", HTCompressed, 1.0);
    SET_INTERNL("www/compressed", "www/dump", HTCompressed, 1.0);

    /*
     * The following support some content types seen here/there:
     */
    SET_INTERNL("application/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("application/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("application/html", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/xml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("application/x-wais-source", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("application/x-wais-source", "www/present", HTWSRCConvert, 2.0);
    SET_INTERNL("application/x-wais-source", "www/download", HTWSRCConvert, 1.0);
    SET_INTERNL("application/x-wais-source", "www/dump", HTWSRCConvert, 1.0);

    /*
     * Save all unknown mime types to disk.
     */
    SET_EXTERNL("www/source", "www/present", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/source", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "www/download", HTSaveToFile, 1.0);
    SET_EXTERNL("www/source", "*", HTSaveToFile, 1.0);

    /*
     * Output all www/dump presentations to stdout.
     */
    SET_EXTERNL("www/source", "www/dump", HTDumpToStdout, 1.0);

    /*
     * Other internal types, which must precede the "www/present" entries
     * below (otherwise, they will be filtered out in HTFilterPresentations()).
     */
    SET_INTERNL("text/css", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("text/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("text/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("text/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/plain", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/x-sgml", "www/source", HTPlainPresent, 1.0);

    /*
     * Now add our basic conversions.  These include the types which will
     * be listed in a "Accept:" line sent to a server.  These criteria are
     * used in HTFilterPresentations() to select acceptable types:
     *
     * a) input is not "www/mime" or "www/compressed"
     * b) output is "www/present"
     * c) quality is in the range 0.0 to 1.0, i.e., excludes the 2.0's.
     *
     * For reference:
     * RFC 1874 - text/sgml
     * RFC 2046 - text/plain
     * RFC 2318 - text/css
     * RFC 3023 - text/xml
     * obsolete - text/x-sgml
     *
     * as well as
     * http://www.iana.org/assignments/media-types/media-types.xhtml
     *
     * and
     * http://www.w3.org/TR/xhtml-media-types/
     *
     * which describes
     * application/xhtml+xml
     * text/html
     */
    SET_INTERNL("application/xhtml+xml", "www/present", HTMLPresent, 1.0);
    SET_INTERNL("text/css", "www/present", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "www/present", HTMLPresent, 1.0);
    SET_INTERNL("text/plain", "www/present", HTPlainPresent, 1.0);
    SET_INTERNL("text/sgml", "www/present", HTMLPresent, 1.0);
    SET_INTERNL("text/x-sgml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("text/xml", "www/present", HTMLPresent, 2.0);

    if (LYisAbsPath(global_type_map)) {
	/* These should override the default types as necessary.  */
	HTLoadTypesConfigFile(global_type_map, mediaSYS);
    }

    /*
     * Load the local maps.
     */
    if (IsOurFile(LYAbsOrHomePath(&personal_type_map))
	&& LYCanReadFile(personal_type_map)) {
	/* These should override everything else. */
	HTLoadTypesConfigFile(personal_type_map, mediaUSR);
    }

    /*
     * Put text/html and text/plain at beginning of list.  - kw
     */
    HTReorderPresentation(WWW_PLAINTEXT, WWW_PRESENT);
    HTReorderPresentation(WWW_HTML, WWW_PRESENT);

    /*
     * Analyze the list, and set 'get_accept' for those whose representations
     * are not redundant.
     */
    HTFilterPresentations();
}

void HTPreparsedFormatInit(void)
{
    CTrace((tfp, "HTPreparsedFormatInit\n"));
    if (LYPreparsedSource) {
	SET_INTERNL("text/html", "www/source", HTMLParsedPresent, 1.0);
	SET_INTERNL("text/html", "www/dump", HTMLParsedPresent, 1.0);
    }
}

/* Some of the following is taken from: */

/*
Copyright (c) 1991 Bell Communications Research, Inc. (Bellcore)

Permission to use, copy, modify, and distribute this material
for any purpose and without fee is hereby granted, provided
that the above copyright notice and this permission notice
appear in all copies, and that the name of Bellcore not be
used in advertising or publicity pertaining to this
material without the specific, prior written permission
of an authorized representative of Bellcore.  BELLCORE
MAKES NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY
OF THIS MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS",
WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.
*/
/******************************************************
    Metamail -- A tool to help diverse mail readers
                cope with diverse multimedia mail formats.

    Author:  Nathaniel S. Borenstein, Bellcore

 ******************************************************* */

struct MailcapEntry {
    char *contenttype;
    char *command;
    char *testcommand;
    int needsterminal;
    int copiousoutput;
    int needtofree;
    char *label;
    char *printcommand;
    char *nametemplate;
    float quality;
    long int maxbytes;
};

static int ExitWithError(const char *txt);
static int PassesTest(struct MailcapEntry *mc);

static char *GetCommand(char *s, char **t)
{
    char *s2;
    int quoted = 0;

    s = LYSkipBlanks(s);
    /* marca -- added + 1 for error case -- oct 24, 1993. */
    s2 = typeMallocn(char, strlen(s) * 2 + 1);	/* absolute max, if all % signs */

    if (!s2)
	ExitWithError(MEMORY_EXHAUSTED_ABORT);

    assert(s2 != NULL);

    *t = s2;
    while (non_empty(s)) {
	if (quoted) {
	    if (*s == '%')
		*s2++ = '%';	/* Quote through next level, ugh! */

	    *s2++ = *s++;
	    quoted = 0;
	} else {
	    if (*s == ';') {
		*s2 = '\0';
		return (++s);
	    }
	    if (*s == ESCAPE) {
		quoted = 1;
		++s;
	    } else {
		*s2++ = *s++;
	    }
	}
    }
    *s2 = '\0';
    return (NULL);
}

/* no leading or trailing space, all lower case */
static char *Cleanse(char *s)
{
    LYTrimLeading(s);
    LYTrimTrailing(s);
    LYLowerCase(s);
    return (s);
}

/* remove unnecessary (unquoted) blanks in a shell command */
static void TrimCommand(char *command)
{
    LYTrimTrailing(command);
#ifdef UNIX
    {
	char *s = command;
	char *d = command;
	int ch;
	int c0 = ' ';
	BOOL escape = FALSE;
	BOOL dquote = FALSE;
	BOOL squote = FALSE;

	while ((ch = *s++) != '\0') {
	    if (escape) {
		escape = FALSE;
	    } else if (squote) {
		if (ch == SQUOTE)
		    squote = FALSE;
	    } else if (dquote) {
		switch (ch) {
		case DQUOTE:
		    dquote = FALSE;
		    break;
		case ESCAPE:
		    escape = TRUE;
		    break;
		}
	    } else {
		switch (ch) {
		case DQUOTE:
		    dquote = TRUE;
		    break;
		case SQUOTE:
		    squote = TRUE;
		    break;
		}
	    }
	    if (!escape && !dquote && !squote) {
		if (ch == '\t')
		    ch = ' ';
		if (ch == ' ') {
		    if (c0 == ' ')
			continue;
		}
	    }
	    *d++ = (char) ch;
	    c0 = ch;
	}
	*d = '\0';
    }
#endif
}

static int ProcessMailcapEntry(FILE *fp, struct MailcapEntry *mc, AcceptMedia media)
{
    size_t rawentryalloc = 2000, len, need;
    char *rawentry, *s, *t;
    char *LineBuf = NULL;

    rawentry = (char *) malloc(rawentryalloc);
    if (!rawentry)
	ExitWithError(MEMORY_EXHAUSTED_ABORT);

    assert(rawentry != NULL);

    *rawentry = '\0';
    while (LYSafeGets(&LineBuf, fp) != 0) {
	LYTrimNewline(LineBuf);
	if (LineBuf[0] == '#' || LineBuf[0] == '\0')
	    continue;
	len = strlen(LineBuf);
	need = len + strlen(rawentry) + 1;
	if (need > rawentryalloc) {
	    rawentryalloc += (2000 + need);
	    rawentry = typeRealloc(char, rawentry, rawentryalloc);

	    if (!rawentry)
		ExitWithError(MEMORY_EXHAUSTED_ABORT);

	    assert(rawentry != NULL);
	}
	if (len > 0 && LineBuf[len - 1] == ESCAPE) {
	    LineBuf[len - 1] = '\0';
	    strcat(rawentry, LineBuf);
	} else {
	    strcat(rawentry, LineBuf);
	    break;
	}
    }
    FREE(LineBuf);

    t = s = LYSkipBlanks(rawentry);
    if (!*s) {
	/* totally blank entry -- quietly ignore */
	FREE(rawentry);
	return (0);
    }
    s = StrChr(rawentry, ';');
    if (s == NULL) {
	CTrace((tfp,
		"ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		rawentry));
	FREE(rawentry);
	return (0);
    }
    *s++ = '\0';
    if (!strncasecomp(t, "text/html", 9) ||
	!strncasecomp(t, "text/plain", 10)) {
	--s;
	*s = ';';
	CTrace((tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		rawentry));
	FREE(rawentry);
	return (0);
    }
    LYRemoveBlanks(rawentry);
    LYLowerCase(rawentry);

    mc->needsterminal = 0;
    mc->copiousoutput = 0;
    mc->needtofree = 1;
    mc->testcommand = NULL;
    mc->label = NULL;
    mc->printcommand = NULL;
    mc->contenttype = NULL;
    StrAllocCopy(mc->contenttype, rawentry);
    mc->quality = (float) 1.0;
    mc->maxbytes = 0;
    t = GetCommand(s, &mc->command);
    if (!t) {
	goto assign_presentation;
    }
    s = LYSkipBlanks(t);
    while (s) {
	char *arg, *eq, *mallocd_string;

	t = GetCommand(s, &mallocd_string);
	arg = mallocd_string;
	eq = StrChr(arg, '=');
	if (eq) {
	    *eq++ = '\0';
	    eq = LYSkipBlanks(eq);
	}
	if (non_empty(arg)) {
	    arg = Cleanse(arg);
	    if (!strcmp(arg, "needsterminal")) {
		mc->needsterminal = 1;
	    } else if (!strcmp(arg, "copiousoutput")) {
		mc->copiousoutput = 1;
	    } else if (eq && !strcmp(arg, "test")) {
		mc->testcommand = NULL;
		StrAllocCopy(mc->testcommand, eq);
		TrimCommand(mc->testcommand);
		CTrace((tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			mc->testcommand));
	    } else if (eq && !strcmp(arg, "description")) {
		mc->label = eq;	/* ignored */
	    } else if (eq && !strcmp(arg, "label")) {
		mc->label = eq;	/* ignored: bogus old name for description */
	    } else if (eq && !strcmp(arg, "print")) {
		mc->printcommand = eq;	/* ignored */
	    } else if (eq && !strcmp(arg, "textualnewlines")) {
		/* no support for now.  What does this do anyways? */
		/* ExceptionalNewline(mc->contenttype, atoi(eq)); */
	    } else if (eq && !strcmp(arg, "q")) {
		mc->quality = (float) atof(eq);
		if (mc->quality > 0.000 && mc->quality < 0.001)
		    mc->quality = (float) 0.001;
	    } else if (eq && !strcmp(arg, "mxb")) {
		mc->maxbytes = atol(eq);
		if (mc->maxbytes < 0)
		    mc->maxbytes = 0;
	    } else if (strcmp(arg, "notes")) {	/* IGNORE notes field */
		if (*arg)
		    CTrace((tfp,
			    "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			    arg));
	    }

	}
	FREE(mallocd_string);
	s = t;
    }

  assign_presentation:
    FREE(rawentry);

    if (PassesTest(mc)) {
	CTrace((tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		mc->contenttype, mc->command));
	HTSetPresentation(mc->contenttype,
			  mc->command,
			  mc->testcommand,
			  mc->quality,
			  3.0, 0.0, mc->maxbytes, media);
    }
    FREE(mc->command);
    FREE(mc->testcommand);
    FREE(mc->contenttype);

    return (1);
}

#define L_CURL '{'
#define R_CURL '}'

static const char *LYSkipQuoted(const char *s)
{
    int escaped = 0;

    ++s;			/* skip first quote */
    while (*s != 0) {
	if (escaped) {
	    escaped = 0;
	} else if (*s == ESCAPE) {
	    escaped = 1;
	} else if (*s == DQUOTE) {
	    ++s;
	    break;
	}
	++s;
    }
    return s;
}

/*
 * Note: the tspecials[] here are those defined for Content-Type header, so
 * this function is not really general-purpose.
 */
static const char *LYSkipToken(const char *s)
{
    static const char tspecials[] = "\"()<>@@,;:\\/[]?.=";

    while (*s != '\0' && !WHITE(*s) && StrChr(tspecials, *s) == 0) {
	++s;
    }
    return s;
}

static const char *LYSkipValue(const char *s)
{
    if (*s == DQUOTE)
	s = LYSkipQuoted(s);
    else
	s = LYSkipToken(s);
    return s;
}

/*
 * Copy the value from the source, dequoting if needed.
 */
static char *LYCopyValue(const char *s)
{
    const char *t;
    char *result = 0;
    int j, k;

    if (*s == DQUOTE) {
	t = LYSkipQuoted(s);
	StrAllocCopy(result, s + 1);
	result[t - s - 2] = '\0';
	for (j = k = 0;; ++j, ++k) {
	    if (result[j] == ESCAPE) {
		++j;
	    }
	    if ((result[k] = result[j]) == '\0')
		break;
	}
    } else {
	t = LYSkipToken(s);
	StrAllocCopy(result, s);
	result[t - s] = '\0';
    }
    return result;
}

/*
 * The "Content-Type:" field, contains zero or more parameters after a ';'.
 * Return the value of the named parameter, or null.
 */
static char *LYGetContentType(const char *name,
			      const char *params)
{
    char *result = 0;

    if (params != 0) {
	if (name != 0) {
	    size_t length = strlen(name);
	    const char *test = StrChr(params, ';');	/* skip type/subtype */
	    const char *next;

	    while (test != 0) {
		BOOL found = FALSE;

		++test;		/* skip the ';' */
		test = LYSkipCBlanks(test);
		next = LYSkipToken(test);
		if ((next - test) == (int) length
		    && !StrNCmp(test, name, length)) {
		    found = TRUE;
		}
		test = LYSkipCBlanks(next);
		if (*test == '=') {
		    ++test;
		    test = LYSkipCBlanks(test);
		    if (found) {
			result = LYCopyValue(test);
			break;
		    } else {
			test = LYSkipValue(test);
		    }
		    test = LYSkipCBlanks(test);
		}
		if (*test != ';') {
		    break;	/* we're lost */
		}
	    }
	} else {		/* return the content-type */
	    StrAllocCopy(result, params);
	    *LYSkipNonBlanks(result) = '\0';
	}
    }
    return result;
}

/*
 * Check if the command uses a "%s" substitution.  We need to know this, to
 * decide when to create temporary files, etc.
 */
BOOL LYMailcapUsesPctS(const char *controlstring)
{
    BOOL result = FALSE;
    const char *from;
    const char *next;
    int prefixed = 0;
    int escaped = 0;

    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	} else if (*from == ESCAPE) {
	    escaped = 1;
	} else if (prefixed) {
	    prefixed = 0;
	    switch (*from) {
	    case '%':		/* not defined */
	    case 'n':
	    case 'F':
	    case 't':
		break;
	    case 's':
		result = TRUE;
		break;
	    case L_CURL:
		next = StrChr(from, R_CURL);
		if (next != 0) {
		    from = next;
		    break;
		}
		/* FALLTHRU */
	    default:
		break;
	    }
	} else if (*from == '%') {
	    prefixed = 1;
	}
    }
    return result;
}

/*
 * Build the command string for testing or executing a mailcap entry.
 * If a substitution from the Content-Type header is requested but no
 * parameters are available, return -1, otherwise 0.
 *
 * This does not support multipart %n or %F (does this apply to lynx?)
 */
static int BuildCommand(HTChunk *cmd,
			const char *controlstring,
			const char *TmpFileName,
			const char *params)
{
    int result = 0;
    size_t TmpFileLen = strlen(TmpFileName);
    const char *from;
    const char *next;
    char *name, *value;
    int prefixed = 0;
    int escaped = 0;

    for (from = controlstring; *from != '\0'; from++) {
	if (escaped) {
	    escaped = 0;
	    HTChunkPutc(cmd, UCH(*from));
	} else if (*from == ESCAPE) {
	    escaped = 1;
	} else if (prefixed) {
	    prefixed = 0;
	    switch (*from) {
	    case '%':		/* not defined */
		HTChunkPutc(cmd, UCH(*from));
		break;
	    case 'n':
		/* FALLTHRU */
	    case 'F':
		CTrace((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
			controlstring));
		break;
	    case 't':
		if ((value = LYGetContentType(NULL, params)) != 0) {
		    HTChunkPuts(cmd, value);
		    FREE(value);
		}
		break;
	    case 's':
		if (TmpFileLen) {
		    HTChunkPuts(cmd, TmpFileName);
		}
		break;
	    case L_CURL:
		next = StrChr(from, R_CURL);
		if (next != 0) {
		    if (params != 0) {
			++from;
			name = 0;
			HTSprintf0(&name, "%.*s", (int) (next - from), from);
			if ((value = LYGetContentType(name, params)) != 0) {
			    HTChunkPuts(cmd, value);
			    FREE(value);
			} else if (name) {
			    if (!strcmp(name, "charset")) {
				HTChunkPuts(cmd, "ISO-8859-1");
			    } else {
				CTrace((tfp, "BuildCommand no value for %s\n", name));
			    }
			}
			FREE(name);
		    } else {
			result = -1;
		    }
		    from = next;
		    break;
		}
		/* FALLTHRU */
	    default:
		CTrace((tfp,
			"BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n",
			*from));
		break;
	    }
	} else if (*from == '%') {
	    prefixed = 1;
	} else {
	    HTChunkPutc(cmd, UCH(*from));
	}
    }
    HTChunkTerminate(cmd);
    return result;
}

/*
 * Build the mailcap test-command and execute it.  This is only invoked when
 * we cannot tell just by looking at the command if it would succeed.
 *
 * Returns 0 for success, -1 for error and 1 for deferred.
 */
int LYTestMailcapCommand(const char *testcommand,
			 const char *params)
{
    int result;
    char TmpFileName[LY_MAXPATH];
    HTChunk *expanded = 0;

    if (LYMailcapUsesPctS(testcommand)) {
	if (LYOpenTemp(TmpFileName, HTML_SUFFIX, "w") == 0)
	    ExitWithError(CANNOT_OPEN_TEMP);
	LYCloseTemp(TmpFileName);
    } else {
	/* We normally don't need a temp file name - kw */
	TmpFileName[0] = '\0';
    }
    expanded = HTChunkCreate(1024);
    if (BuildCommand(expanded, testcommand, TmpFileName, params) != 0) {
	result = 1;
	CTrace((tfp, "PassesTest: Deferring test command: %s\n", expanded->data));
    } else {
	CTrace((tfp, "PassesTest: Executing test command: %s\n", expanded->data));
	if ((result = LYSystem(expanded->data)) != 0) {
	    result = -1;
	    CTrace((tfp, "PassesTest: Test failed!\n"));
	} else {
	    CTrace((tfp, "PassesTest: Test passed!\n"));
	}
    }

    HTChunkFree(expanded);
    (void) LYRemoveTemp(TmpFileName);

    return result;
}

char *LYMakeMailcapCommand(const char *command,
			   const char *params,
			   const char *filename)
{
    HTChunk *expanded = 0;
    char *result = 0;

    expanded = HTChunkCreate(1024);
    BuildCommand(expanded, command, filename, params);
    StrAllocCopy(result, expanded->data);
    HTChunkFree(expanded);
    return result;
}

#define RTR_forget      0
#define RTR_lookup      1
#define RTR_add         2

static int RememberTestResult(int mode, char *cmd, int result)
{
    struct cmdlist_s {
	char *cmd;
	int result;
	struct cmdlist_s *next;
    };
    static struct cmdlist_s *cmdlist = NULL;
    struct cmdlist_s *cur;

    switch (mode) {
    case RTR_forget:
	while (cmdlist) {
	    cur = cmdlist->next;
	    FREE(cmdlist->cmd);
	    FREE(cmdlist);
	    cmdlist = cur;
	}
	break;
    case RTR_lookup:
	for (cur = cmdlist; cur; cur = cur->next)
	    if (!strcmp(cmd, cur->cmd))
		return cur->result;
	return -1;
    case RTR_add:
	cur = typecalloc(struct cmdlist_s);

	if (cur == NULL)
	    outofmem(__FILE__, "RememberTestResult");

	assert(cur != NULL);

	cur->next = cmdlist;
	StrAllocCopy(cur->cmd, cmd);
	cur->result = result;
	cmdlist = cur;
	break;
    }
    return 0;
}

/* FIXME: this sometimes used caseless comparison, e.g., strcasecomp */
#define SameCommand(tst,ref) !strcmp(tst,ref)

static int PassesTest(struct MailcapEntry *mc)
{
    int result;

    /*
     *  Make sure we have a command
     */
    if (!mc->testcommand)
	return (1);

    /*
     *  Save overhead of system() calls by faking these. - FM
     */
    if (SameCommand(mc->testcommand, "test \"$DISPLAY\"") ||
	SameCommand(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	SameCommand(mc->testcommand, "test -n \"$DISPLAY\"")) {
	FREE(mc->testcommand);
	CTrace((tfp, "PassesTest: Testing for XWINDOWS environment.\n"));
	if (LYgetXDisplay() != NULL) {
	    CTrace((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
	} else {
	    CTrace((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
	}
    }
    if (SameCommand(mc->testcommand, "test -z \"$DISPLAY\"")) {
	FREE(mc->testcommand);
	CTrace((tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n"));
	if (LYgetXDisplay() == NULL) {
	    CTrace((tfp, "PassesTest: Test passed!\n"));
	    return (0 == 0);
	} else {
	    CTrace((tfp, "PassesTest: Test failed!\n"));
	    return (-1 == 0);
	}
    }

    /*
     *  Why do anything but return success for this one! - FM
     */
    if (SameCommand(mc->testcommand, "test -n \"$LYNX_VERSION\"")) {
	FREE(mc->testcommand);
	CTrace((tfp, "PassesTest: Testing for LYNX environment.\n"));
	CTrace((tfp, "PassesTest: Test passed!\n"));
	return (0 == 0);
    } else
	/*
	 *  ... or failure for this one! - FM
	 */
    if (SameCommand(mc->testcommand, "test -z \"$LYNX_VERSION\"")) {
	FREE(mc->testcommand);
	CTrace((tfp, "PassesTest: Testing for non-LYNX environment.\n"));
	CTrace((tfp, "PassesTest: Test failed!\n"));
	return (-1 == 0);
    }

    result = RememberTestResult(RTR_lookup, mc->testcommand, 0);
    if (result == -1) {
	result = LYTestMailcapCommand(mc->testcommand, NULL);
	RememberTestResult(RTR_add, mc->testcommand, result ? 1 : 0);
    }

    /*
     *  Free the test command as well since
     *  we wont be needing it anymore.
     */
    if (result != 1)
	FREE(mc->testcommand);

    if (result < 0) {
	CTrace((tfp, "PassesTest: Test failed!\n"));
    } else if (result == 0) {
	CTrace((tfp, "PassesTest: Test passed!\n"));
    }

    return (result >= 0);
}

static int ProcessMailcapFile(char *file, AcceptMedia media)
{
    struct MailcapEntry mc;
    FILE *fp;

    CTrace((tfp, "ProcessMailcapFile: Loading file '%s'.\n",
	    file));
    if ((fp = fopen(file, TXT_R)) == NULL) {
	CTrace((tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		file));
	return (-1 == 0);
    }

    while (fp && !feof(fp)) {
	ProcessMailcapEntry(fp, &mc, media);
    }
    LYCloseInput(fp);
    RememberTestResult(RTR_forget, NULL, 0);
    return (0 == 0);
}

static int ExitWithError(const char *txt)
{
    if (txt)
	fprintf(tfp, "Lynx: %s\n", txt);
    exit_immediately(EXIT_FAILURE);
    return (-1);
}

/* Reverse the entries from each mailcap after it has been read, so that
 * earlier entries have precedence.  Set to 0 to get traditional lynx
 * behavior, which means that the last match wins. - kw */
static int reverse_mailcap = 1;

static int HTLoadTypesConfigFile(char *fn, AcceptMedia media)
{
    int result = 0;
    HTList *saved = HTPresentations;

    if (reverse_mailcap) {	/* temporarily hide existing list */
	HTPresentations = NULL;
    }

    result = ProcessMailcapFile(fn, media);

    if (reverse_mailcap) {
	if (result && HTPresentations) {
	    HTList_reverse(HTPresentations);
	    HTList_appendList(HTPresentations, saved);
	    FREE(saved);
	} else {
	    HTPresentations = saved;
	}
    }
    return result;
}

/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*	Define a basic set of suffixes
 *	------------------------------
 *
 *	The LAST suffix for a type is that used for temporary files
 *	of that type.
 *	The quality is an apriori bias as to whether the file should be
 *	used.  Not that different suffixes can be used to represent files
 *	which are of the same format but are originals or regenerated,
 *	with different values.
 */
/*
 * Additional notes:  the encoding parameter may be taken into account when
 * looking for a match; for that purpose "7bit", "8bit", and "binary" are
 * equivalent.
 *
 * Use of mixed case and of pseudo MIME types with embedded spaces should be
 * avoided.  It was once necessary for getting the fancy strings into type
 * labels in FTP directory listings, but that can now be done with the
 * description field (using HTSetSuffix5).  AFAIK the only effect of such
 * "fancy" (and mostly invalid) types that cannot be reproduced by using a
 * description fields is some statusline messages in SaveToFile (HTFWriter.c). 
 * And showing the user an invalid MIME type as the 'Content-type:' is not such
 * a hot idea anyway, IMO.  Still, if you want it, it is still possible (even
 * in lynx.cfg now), but use of it in the defaults below has been reduced.
 *
 * Case variations rely on peculiar behavior of HTAtom.c for matching.  They
 * lead to surprising behavior, Lynx retains the case of a string in the form
 * first encountered after starting up.  So while later suffix rules generally
 * override or modify earlier ones, the case used for a MIME time is determined
 * by the first suffix rule (or other occurrence).  Matching in HTAtom_for is
 * effectively case insensitive, except for the first character of the string
 * which is treated as case-sensitive by the hash function there; best not to
 * rely on that, rather convert MIME types to lowercase on input as is already
 * done in most places (And HTAtom could become consistently case-sensitive, as
 * in newer W3C libwww).
 *  - kw 1999-10-12
 */
void HTFileInit(void)
{
#ifdef BUILTIN_SUFFIX_MAPS
    if (LYUseBuiltinSuffixes) {
	CTrace((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));

	/* default suffix interpretation */
	SET_SUFFIX1("*", "text/plain", "8bit");
	SET_SUFFIX1("*.*", "text/plain", "8bit");

#ifdef EXEC_SCRIPTS
	/*
	 * define these extensions for exec scripts.
	 */
#ifndef VMS
	/* for csh exec links */
	HTSetSuffix(".csh", "application/x-csh", "8bit", 0.8);
	HTSetSuffix(".sh", "application/x-sh", "8bit", 0.8);
	HTSetSuffix(".ksh", "application/x-ksh", "8bit", 0.8);
#else
	HTSetSuffix(".com", "application/x-VMS_script", "8bit", 0.8);
#endif /* !VMS */
#endif /* EXEC_SCRIPTS */

	/*
	 * Some of the old incarnation of the mappings is preserved and can be had
	 * by defining TRADITIONAL_SUFFIXES.  This is for some cases where I felt
	 * the old rules might be preferred by someone, for some reason.  It's not
	 * done consistently.  A lot more of this stuff could probably be changed
	 * too or omitted, now that nearly the equivalent functionality is
	 * available in lynx.cfg.  - kw 1999-10-12
	 */
	/* *INDENT-OFF* */
	SET_SUFFIX1(".saveme",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".dump",	"application/x-Binary",		"binary");
	SET_SUFFIX1(".bin",	"application/x-Binary",		"binary");

	SET_SUFFIX1(".arc",	"application/x-Compressed",	"binary");

	SET_SUFFIX1(".alpha-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".alpha_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".AXP_exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX-exe", "application/x-Executable",	"binary");
	SET_SUFFIX1(".VAX_exe", "application/x-Executable",	"binary");
	SET_SUFFIX5(".exe",	"application/octet-stream",	"binary", "Executable");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".exe.Z",	"application/x-Comp. Executable", "binary");
	SET_SUFFIX1(".Z",	"application/UNIX Compressed",	"binary");
	SET_SUFFIX1(".tar_Z",	"application/UNIX Compr. Tar",	"binary");
	SET_SUFFIX1(".tar.Z",	"application/UNIX Compr. Tar",	"binary");
#else
	SET_SUFFIX5(".Z",	"application/x-compress",	"binary", "UNIX Compressed");
	SET_SUFFIX5(".Z",	NULL,				"compress", "UNIX Compressed");
	SET_SUFFIX5(".exe.Z",	"application/octet-stream",	"compress", "Executable");
	SET_SUFFIX5(".tar_Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
	SET_SUFFIX5(".tar.Z",	"application/x-tar",		"compress", "UNIX Compr. Tar");
#endif

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1("-gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1("_gz",	"application/GNU Compressed",	"binary");
	SET_SUFFIX1(".gz",	"application/GNU Compressed",	"binary");

	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"binary", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
#else
	SET_SUFFIX5("-gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("_gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5(".gz",	"application/x-gzip",		"binary", "GNU Compressed");
	SET_SUFFIX5("-gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5("_gz",	NULL,				"gzip", "GNU Compressed");
	SET_SUFFIX5(".gz",	NULL,				"gzip", "GNU Compressed");

	SET_SUFFIX5(".tar.gz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
	SET_SUFFIX5(".tgz",	"application/x-tar",		"gzip", "GNU Compr. Tar");
#endif

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".src",	"application/x-WAIS-source",	"8bit");
	SET_SUFFIX1(".wsrc",	"application/x-WAIS-source",	"8bit");
#else
	SET_SUFFIX5(".wsrc",	"application/x-wais-source",	"8bit", "WAIS-source");
#endif

	SET_SUFFIX5(".zip",	"application/zip",		"binary", "Zip File");

	SET_SUFFIX1(".zz",	"application/x-deflate",	"binary");
	SET_SUFFIX1(".zz",	"application/deflate",		"binary");

	SET_SUFFIX1(".bz2",	"application/x-bzip2",		"binary");
	SET_SUFFIX1(".bz2",	"application/bzip2",		"binary");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".uu",	"application/x-UUencoded",	"8bit");

	SET_SUFFIX1(".hqx",	"application/x-Binhex",		"8bit");

	SET_SUFFIX1(".o",	"application/x-Prog. Object",	"binary");
	SET_SUFFIX1(".a",	"application/x-Prog. Library",	"binary");
#else
	SET_SUFFIX5(".uu",	"application/x-uuencoded",	"7bit", "UUencoded");

	SET_SUFFIX5(".hqx",	"application/mac-binhex40",	"8bit", "Mac BinHex");

	HTSetSuffix5(".o",	"application/octet-stream",	"binary", "Prog. Object", 0.5);
	HTSetSuffix5(".a",	"application/octet-stream",	"binary", "Prog. Library", 0.5);
	HTSetSuffix5(".so",	"application/octet-stream",	"binary", "Shared Lib", 0.5);
#endif

	SET_SUFFIX5(".oda",	"application/oda",		"binary", "ODA");

	SET_SUFFIX5(".pdf",	"application/pdf",		"binary", "PDF");

	SET_SUFFIX5(".eps",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ai",	"application/postscript",	"8bit", "Postscript");
	SET_SUFFIX5(".ps",	"application/postscript",	"8bit", "Postscript");

	SET_SUFFIX5(".rtf",	"application/rtf",		"8bit", "RTF");

	SET_SUFFIX5(".dvi",	"application/x-dvi",		"8bit", "DVI");

	SET_SUFFIX5(".hdf",	"application/x-hdf",		"8bit", "HDF");

	SET_SUFFIX1(".cdf",	"application/x-netcdf",		"8bit");
	SET_SUFFIX1(".nc",	"application/x-netcdf",		"8bit");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".latex",	"application/x-Latex",		"8bit");
	SET_SUFFIX1(".tex",	"application/x-Tex",		"8bit");
	SET_SUFFIX1(".texinfo", "application/x-Texinfo",	"8bit");
	SET_SUFFIX1(".texi",	"application/x-Texinfo",	"8bit");
#else
	SET_SUFFIX5(".latex",	"application/x-latex",		"8bit", "LaTeX");
	SET_SUFFIX5(".tex",	"text/x-tex",			"8bit", "TeX");
	SET_SUFFIX5(".texinfo", "application/x-texinfo",	"8bit", "Texinfo");
	SET_SUFFIX5(".texi",	"application/x-texinfo",	"8bit", "Texinfo");
#endif

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".t",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".tr",	"application/x-Troff",		"8bit");
	SET_SUFFIX1(".roff",	"application/x-Troff",		"8bit");

	SET_SUFFIX1(".man",	"application/x-Troff-man",	"8bit");
	SET_SUFFIX1(".me",	"application/x-Troff-me",	"8bit");
	SET_SUFFIX1(".ms",	"application/x-Troff-ms",	"8bit");
#else
	SET_SUFFIX5(".t",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".tr",	"application/x-troff",		"8bit", "Troff");
	SET_SUFFIX5(".roff",	"application/x-troff",		"8bit", "Troff");

	SET_SUFFIX5(".man",	"application/x-troff-man",	"8bit", "Man Page");
	SET_SUFFIX5(".me",	"application/x-troff-me",	"8bit", "Troff me");
	SET_SUFFIX5(".ms",	"application/x-troff-ms",	"8bit", "Troff ms");
#endif

	SET_SUFFIX1(".zoo",	"application/x-Zoo File",	"binary");

#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
	SET_SUFFIX1(".bak",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bkp",	"application/x-VMS BAK File",	"binary");
	SET_SUFFIX1(".bck",	"application/x-VMS BAK File",	"binary");

	SET_SUFFIX5(".bkp_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bkp-gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck_gz",	"application/octet-stream",	"gzip", "GNU BAK File");
	SET_SUFFIX5(".bck-gz",	"application/octet-stream",	"gzip", "GNU BAK File");

	SET_SUFFIX5(".bkp-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bkp_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck-Z",	"application/octet-stream",	"compress", "Comp. BAK File");
	SET_SUFFIX5(".bck_Z",	"application/octet-stream",	"compress", "Comp. BAK File");
#else
	HTSetSuffix5(".bak",	NULL,				"binary", "Backup", 0.5);
	SET_SUFFIX5(".bkp",	"application/octet-stream",	"binary", "VMS BAK File");
	SET_SUFFIX5(".bck",	"application/octet-stream",	"binary", "VMS BAK File");
#endif

#if defined(TRADITIONAL_SUFFIXES) || defined(VMS)
	SET_SUFFIX1(".hlb",	"application/x-VMS Help Libr.", "binary");
	SET_SUFFIX1(".olb",	"application/x-VMS Obj. Libr.", "binary");
	SET_SUFFIX1(".tlb",	"application/x-VMS Text Libr.", "binary");
	SET_SUFFIX1(".obj",	"application/x-VMS Prog. Obj.", "binary");
	SET_SUFFIX1(".decw$book", "application/x-DEC BookReader", "binary");
	SET_SUFFIX1(".mem",	"application/x-RUNOFF-MANUAL", "8bit");
#else
	SET_SUFFIX5(".hlb",	"application/octet-stream",	"binary", "VMS Help Libr.");
	SET_SUFFIX5(".olb",	"application/octet-stream",	"binary", "VMS Obj. Libr.");
	SET_SUFFIX5(".tlb",	"application/octet-stream",	"binary", "VMS Text Libr.");
	SET_SUFFIX5(".obj",	"application/octet-stream",	"binary", "Prog. Object");
	SET_SUFFIX5(".decw$book", "application/octet-stream",	"binary", "DEC BookReader");
	SET_SUFFIX5(".mem",	"text/x-runoff-manual",		"8bit", "RUNOFF-MANUAL");
#endif

	SET_SUFFIX1(".vsd",	"application/visio",		"binary");

	SET_SUFFIX5(".lha",	"application/x-lha",		"binary", "lha File");
	SET_SUFFIX5(".lzh",	"application/x-lzh",		"binary", "lzh File");
	SET_SUFFIX5(".sea",	"application/x-sea",		"binary", "sea File");
#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX5(".sit",	"application/x-sit",		"binary", "sit File");
#else
	SET_SUFFIX5(".sit",	"application/x-stuffit",	"binary", "StuffIt");
#endif
	SET_SUFFIX5(".dms",	"application/x-dms",		"binary", "dms File");
	SET_SUFFIX5(".iff",	"application/x-iff",		"binary", "iff File");

	SET_SUFFIX1(".bcpio",	"application/x-bcpio",		"binary");
	SET_SUFFIX1(".cpio",	"application/x-cpio",		"binary");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".gtar",	"application/x-gtar",		"binary");
#endif

	SET_SUFFIX1(".shar",	"application/x-shar",		"8bit");
	SET_SUFFIX1(".share",	"application/x-share",		"8bit");

#ifdef TRADITIONAL_SUFFIXES
	SET_SUFFIX1(".sh",	"application/x-sh",		"8bit"); /* xtra */
#endif

	SET_SUFFIX1(".sv4cpio", "application/x-sv4cpio",	"binary");
	SET_SUFFIX1(".sv4crc",	"application/x-sv4crc",		"binary");

	SET_SUFFIX5(".tar",	"application/x-tar",		"binary", "Tar File");
	SET_SUFFIX1(".ustar",	"application/x-ustar",		"binary");

	SET_SUFFIX1(".snd",	"audio/basic",			"binary");
	SET_SUFFIX1(".au",	"audio/basic",			"binary");

	SET_SUFFIX1(".aifc",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aif",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".aiff",	"audio/x-aiff",			"binary");
	SET_SUFFIX1(".wav",	"audio/x-wav",			"binary");
	SET_SUFFIX1(".midi",	"audio/midi",			"binary");
	SET_SUFFIX1(".mod",	"audio/mod",			"binary");

	SET_SUFFIX1(".gif",	"image/gif",			"binary");
	SET_SUFFIX1(".ief",	"image/ief",			"binary");
	SET_SUFFIX1(".jfif",	"image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jfif-tbnl", "image/jpeg",			"binary"); /* xtra */
	SET_SUFFIX1(".jpe",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".jpeg",	"image/jpeg",			"binary");
	SET_SUFFIX1(".tif",	"image/tiff",			"binary");
	SET_SUFFIX1(".tiff",	"image/tiff",			"binary");
	SET_SUFFIX1(".ham",	"image/ham",			"binary");
	SET_SUFFIX1(".ras",	"image/x-cmu-rast",		"binary");
	SET_SUFFIX1(".pnm",	"image/x-portable-anymap",	"binary");
	SET_SUFFIX1(".pbm",	"image/x-portable-bitmap",	"binary");
	SET_SUFFIX1(".pgm",	"image/x-portable-graymap",	"binary");
	SET_SUFFIX1(".ppm",	"image/x-portable-pixmap",	"binary");
	SET_SUFFIX1(".png",	"image/png",			"binary");
	SET_SUFFIX1(".rgb",	"image/x-rgb",			"binary");
	SET_SUFFIX1(".xbm",	"image/x-xbitmap",		"binary");
	SET_SUFFIX1(".xpm",	"image/x-xpixmap",		"binary");
	SET_SUFFIX1(".xwd",	"image/x-xwindowdump",		"binary");

	SET_SUFFIX1(".rtx",	"text/richtext",		"8bit");
	SET_SUFFIX1(".tsv",	"text/tab-separated-values",	"8bit");
	SET_SUFFIX1(".etx",	"text/x-setext",		"8bit");

	SET_SUFFIX1(".mpg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpe",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mpeg",	"video/mpeg",			"binary");
	SET_SUFFIX1(".mov",	"video/quicktime",		"binary");
	SET_SUFFIX1(".qt",	"video/quicktime",		"binary");
	SET_SUFFIX1(".avi",	"video/x-msvideo",		"binary");
	SET_SUFFIX1(".movie",	"video/x-sgi-movie",		"binary");
	SET_SUFFIX1(".mv",	"video/x-sgi-movie",		"binary");

	SET_SUFFIX1(".mime",	"message/rfc822",		"8bit");

	SET_SUFFIX1(".c",	"text/plain",			"8bit");
	SET_SUFFIX1(".cc",	"text/plain",			"8bit");
	SET_SUFFIX1(".c++",	"text/plain",			"8bit");
	SET_SUFFIX1(".css",	"text/plain",			"8bit");
	SET_SUFFIX1(".h",	"text/plain",			"8bit");
	SET_SUFFIX1(".pl",	"text/plain",			"8bit");
	SET_SUFFIX1(".text",	"text/plain",			"8bit");
	SET_SUFFIX1(".txt",	"text/plain",			"8bit");

	SET_SUFFIX1(".php",	"text/html",			"8bit");
	SET_SUFFIX1(".php3",	"text/html",			"8bit");
	SET_SUFFIX1(".html3",	"text/html",			"8bit");
	SET_SUFFIX1(".ht3",	"text/html",			"8bit");
	SET_SUFFIX1(".phtml",	"text/html",			"8bit");
	SET_SUFFIX1(".shtml",	"text/html",			"8bit");
	SET_SUFFIX1(".sht",	"text/html",			"8bit");
	SET_SUFFIX1(".htmlx",	"text/html",			"8bit");
	SET_SUFFIX1(".htm",	"text/html",			"8bit");
	SET_SUFFIX1(".html",	"text/html",			"8bit");
	/* *INDENT-ON* */

    } else {			/* LYSuffixRules */
	/*
	 * Note that even .html -> text/html, .htm -> text/html are omitted if
	 * default maps are compiled in but then skipped because of a
	 * configuration file directive.  Whoever changes the config file in
	 * this way can easily also add the SUFFIX rules there.  - kw
	 */
	CTrace((tfp,
		"HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    }				/* LYSuffixRules */

#else /* BUILTIN_SUFFIX_MAPS */

    CTrace((tfp,
	    "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
    /*
     * The following two are still used if BUILTIN_SUFFIX_MAPS was undefined. 
     * Without one of them, lynx would always need to have a mapping specified
     * in a lynx.cfg or mime.types file to be usable for local HTML files at
     * all.  That includes many of the generated user interface pages.  - kw
     */
    SET_SUFFIX1(".htm", "text/html", "8bit");
    SET_SUFFIX1(".html", "text/html", "8bit");
#endif /* BUILTIN_SUFFIX_MAPS */

    if (LYisAbsPath(global_extension_map)) {
	/* These should override the default extensions as necessary. */
	HTLoadExtensionsConfigFile(global_extension_map);
    }

    /*
     * Load the local maps.
     */
    if (IsOurFile(LYAbsOrHomePath(&personal_extension_map))
	&& LYCanReadFile(personal_extension_map)) {
	/* These should override everything else. */
	HTLoadExtensionsConfigFile(personal_extension_map);
    }
}

/* -------------------- Extension config file reading --------------------- */

/*
 *  The following is lifted from NCSA httpd 1.0a1, by Rob McCool;
 *  NCSA httpd is in the public domain, as is this code.
 *
 *  Modified Oct 97 - KW
 */

#define MAX_STRING_LEN 256

static int HTGetLine(char *s, int n, FILE *f)
{
    register int i = 0, r;

    if (!f)
	return (1);

    while (1) {
	r = fgetc(f);
	s[i] = (char) r;

	if (s[i] == CR) {
	    r = fgetc(f);
	    if (r == LF)
		s[i] = (char) r;
	    else if (r != EOF)
		ungetc(r, f);
	}

	if ((r == EOF) || (s[i] == LF) || (s[i] == CR) || (i == (n - 1))) {
	    s[i] = '\0';
	    return (feof(f) ? 1 : 0);
	}
	++i;
    }
}

static void HTGetWord(char *word, char *line, int stop, int stop2)
{
    int x = 0, y;

    for (x = 0; (line[x]
		 && UCH(line[x]) != UCH(stop)
		 && UCH(line[x]) != UCH(stop2)); x++) {
	word[x] = line[x];
    }

    word[x] = '\0';
    if (line[x])
	++x;
    y = 0;

    while ((line[y++] = line[x++])) {
	;
    }

    return;
}

static int HTLoadExtensionsConfigFile(char *fn)
{
    char line[MAX_STRING_LEN];
    char word[MAX_STRING_LEN];
    char *ct;
    FILE *f;
    int count = 0;

    CTrace((tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn));

    if ((f = fopen(fn, TXT_R)) == NULL) {
	CTrace((tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn));
	return count;
    }

    while (!(HTGetLine(line, (int) sizeof(line), f))) {
	HTGetWord(word, line, ' ', '\t');
	if (line[0] == '\0' || word[0] == '#')
	    continue;
	ct = NULL;
	StrAllocCopy(ct, word);
	LYLowerCase(ct);

	while (line[0]) {
	    HTGetWord(word, line, ' ', '\t');
	    if (word[0] && (word[0] != ' ')) {
		char *ext = NULL;

		HTSprintf0(&ext, ".%s", word);
		LYLowerCase(ext);

		CTrace((tfp, "setting suffix '%s' to '%s'.\n", ext, ct));

		if (strstr(ct, "tex") != NULL ||
		    strstr(ct, "postscript") != NULL ||
		    strstr(ct, "sh") != NULL ||
		    strstr(ct, "troff") != NULL ||
		    strstr(ct, "rtf") != NULL)
		    SET_SUFFIX1(ext, ct, "8bit");
		else
		    SET_SUFFIX1(ext, ct, "binary");
		count++;

		FREE(ext);
	    }
	}
	FREE(ct);
    }
    LYCloseInput(f);

    return count;
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTInit.c,v 1.70 2009/01/01 22:58:06 tom Exp $
d46 1
a46 1
  HTSetPresentation(mimetype, command, 0, quality, delay, 0.0, 0, media)
d49 1
a49 1
    HTSetConversion(rep_in, rep_out, command, quality, 3.0, 0.0, 0, mediaEXT)
d52 1
a52 1
    HTSetConversion(rep_in, rep_out, command, quality, 0.0, 0.0, 0, mediaINT)
a100 1
    media = mediaINT;
d118 1
a118 1
     * Added the following to support some content types beginning to surface.
a121 1
    SET_INTERNL("text/css", "text/plain", HTMLToPlain, 0.5);
d123 1
a123 1
    SET_INTERNL("application/xhtml+xml", "www/present", HTMLPresent, 2.0);
a124 1
    SET_INTERNL("application/html", "www/source", HTPlainPresent, 1.0);
d144 2
a145 1
     * Now add our basic conversions.
d147 6
d154 28
a181 3
    SET_INTERNL("text/x-sgml", "www/present", HTMLPresent, 2.0);
    SET_INTERNL("text/sgml", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/sgml", "www/present", HTMLPresent, 1.0);
d183 1
d185 2
a186 5
    SET_INTERNL("text/plain", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "www/source", HTPlainPresent, 1.0);
    SET_INTERNL("text/html", "text/x-c", HTMLToC, 0.5);
    SET_INTERNL("text/html", "text/plain", HTMLToPlain, 0.5);
    SET_INTERNL("text/html", "www/present", HTMLPresent, 1.0);
d278 2
d293 1
a293 1
	    if (*s == '\\') {
d332 1
a332 1
		if (ch == '\'')
d335 2
a336 1
		if (ch == '"')
d338 5
d345 1
a345 1
		case '"':
d348 1
a348 1
		case '\'':
a350 4
		case '\\':
		    if (dquote)
			escape = TRUE;
		    break;
d378 3
d394 2
d397 1
a397 1
	if (len > 0 && LineBuf[len - 1] == '\\') {
d413 1
a413 1
    s = strchr(rawentry, ';');
d454 1
a454 1
	eq = strchr(arg, '=');
d530 1
a530 1
	} else if (*s == '\\') {
d532 1
a532 1
	} else if (*s == '"') {
d549 1
a549 1
    while (*s != '\0' && !WHITE(*s) && strchr(tspecials, *s) == 0) {
d557 1
a557 1
    if (*s == '"')
d573 1
a573 1
    if (*s == '"') {
d578 1
a578 1
	    if (result[j] == '\\') {
d604 1
a604 1
	    const char *test = strchr(params, ';');	/* skip type/subtype */
d614 1
a614 1
		    && !strncmp(test, name, length)) {
d656 1
a656 1
	} else if (*from == '\\') {
d670 1
a670 1
		next = strchr(from, R_CURL);
d709 2
a710 2
	    HTChunkPutc(cmd, *from);
	} else if (*from == '\\') {
d716 1
a716 1
		HTChunkPutc(cmd, *from);
d731 1
a731 1
		if (TmpFileLen && TmpFileName) {
d736 1
a736 1
		next = strchr(from, R_CURL);
d745 1
a745 1
			} else {
d769 1
a769 1
	    HTChunkPutc(cmd, *from);
d798 1
a798 1
    if ((result = BuildCommand(expanded, testcommand, TmpFileName, params)) != 0) {
d812 1
a812 1
    LYRemoveTemp(TmpFileName);
d864 3
d1430 1
a1430 1
static void HTGetWord(char *word, char *line, char stop, char stop2)
d1434 3
a1436 1
    for (x = 0; line[x] && line[x] != stop && line[x] != stop2; x++) {
d1445 3
a1447 1
    while ((line[y++] = line[x++])) ;
d1467 1
a1467 1
    while (!(HTGetLine(line, sizeof(line), f))) {
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 4
a4 1
/*		Configuration-specific Initialization		HTInit.c
d34 2
d58 1
d170 4
a173 7
    {
	char buffer[LY_MAXPATH];

	LYAddPathToHome(buffer, sizeof(buffer), personal_type_map);
	if (IsOurFile(buffer)
	    && LYCanReadFile(buffer))
	    HTLoadTypesConfigFile(buffer, mediaUSR);
d191 1
d330 1
a330 1
	    *d++ = ch;
d379 1
a379 1
	CTRACE((tfp,
d390 1
a390 1
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
d433 1
a433 1
		CTRACE((tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
d454 1
a454 1
		    CTRACE((tfp,
d468 1
a468 1
	CTRACE((tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
d611 1
a611 1
    int result = FALSE;
d685 1
a685 1
		CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
d713 1
a713 1
				CTRACE((tfp, "BuildCommand no value for %s\n", name));
d725 1
a725 1
		CTRACE((tfp,
d764 1
a764 1
	CTRACE((tfp, "PassesTest: Deferring test command: %s\n", expanded->data));
d766 1
a766 1
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", expanded->data));
d769 1
a769 1
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
d771 1
a771 1
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d857 1
a857 1
	CTRACE((tfp, "PassesTest: Testing for XWINDOWS environment.\n"));
d859 1
a859 1
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d862 1
a862 1
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
d868 1
a868 1
	CTRACE((tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n"));
d870 1
a870 1
	    CTRACE((tfp, "PassesTest: Test passed!\n"));
d873 1
a873 1
	    CTRACE((tfp, "PassesTest: Test failed!\n"));
d883 2
a884 2
	CTRACE((tfp, "PassesTest: Testing for LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test passed!\n"));
d892 2
a893 2
	CTRACE((tfp, "PassesTest: Testing for non-LYNX environment.\n"));
	CTRACE((tfp, "PassesTest: Test failed!\n"));
d911 1
a911 1
	CTRACE((tfp, "PassesTest: Test failed!\n"));
d913 1
a913 1
	CTRACE((tfp, "PassesTest: Test passed!\n"));
d924 1
a924 1
    CTRACE((tfp, "ProcessMailcapFile: Loading file '%s'.\n",
d927 1
a927 1
	CTRACE((tfp, "ProcessMailcapFile: Could not open '%s'.\n",
d1021 1
a1021 1
	CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));
d1320 1
a1320 1
	CTRACE((tfp,
d1326 1
a1326 1
    CTRACE((tfp,
d1346 4
a1349 7
    {
	char buffer[LY_MAXPATH];

	LYAddPathToHome(buffer, sizeof(buffer), personal_extension_map);
	if (IsOurFile(buffer)
	    && LYCanReadFile(buffer))
	    HTLoadExtensionsConfigFile(buffer);
d1417 1
a1417 1
    CTRACE((tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn));
d1420 1
a1420 1
	CTRACE((tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn));
d1440 1
a1440 1
		CTRACE((tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct));
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 2
a3 2
**		----------------------------------------
*/
d6 2
a7 2
**	------------------------------------------------
*/
d23 1
a23 1
#include <HTSaveToFile.h>  /* LJM */
d31 11
a41 2
PRIVATE int HTLoadTypesConfigFile PARAMS((char *fn));
PRIVATE int HTLoadExtensionsConfigFile PARAMS((char *fn));
d43 7
a49 1
PUBLIC void HTFormatInit NOARGS
d51 2
d54 5
a58 5
  HTSetPresentation("application/postscript",   "open %s", 1.0, 2.0, 0.0, 0);
  HTSetPresentation("image/x-tiff",             "open %s", 2.0, 2.0, 0.0, 0);
  HTSetPresentation("image/tiff",               "open %s", 1.0, 2.0, 0.0, 0);
  HTSetPresentation("audio/basic",              "open %s", 1.0, 2.0, 0.0, 0);
  HTSetPresentation("*",                        "open %s", 1.0, 0.0, 0.0, 0);
d60 14
a73 15
 if (LYgetXDisplay() != 0) {	/* Must have X11 */
  HTSetPresentation("application/postscript", "ghostview %s&",
							    1.0, 3.0, 0.0, 0);
  if (XLoadImageCommand && *XLoadImageCommand) {
      HTSetPresentation("image/gif",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbm",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-xbitmap",XLoadImageCommand,1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-png",	XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/png",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-rgb",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/x-tiff", XLoadImageCommand,  2.0, 3.0, 0.0, 0);
      HTSetPresentation("image/tiff",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
      HTSetPresentation("image/jpeg",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  }
  HTSetPresentation("video/mpeg",       "mpeg_play %s &",   1.0, 3.0, 0.0, 0);
d75 4
a78 1
 }
d82 1
a82 1
 /* set quality to 999.0 for protected exec applications */
d84 3
a86 3
 HTSetPresentation("application/x-csh", "csh %s", 999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-sh",  "sh %s",  999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-ksh", "ksh %s", 999.0, 3.0, 0.0, 0);
d88 1
a88 1
 HTSetPresentation("application/x-VMS_script",	"@@%s", 999.0, 3.0, 0.0, 0);
d92 86
a177 13
/*
 *  Add our header handlers.
 */
 HTSetConversion("message/x-http-redirection", "*",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/present",
					     HTMIMERedirect, 2.0, 0.0, 0.0, 0);
 HTSetConversion("message/x-http-redirection", "www/debug",
					     HTMIMERedirect, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/present",  HTMIMEConvert, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/download", HTMIMEConvert, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/source",   HTMIMEConvert, 1.0, 0.0, 0.0, 0);
 HTSetConversion("www/mime",  "www/dump",     HTMIMEConvert, 1.0, 0.0, 0.0, 0);
d179 6
a184 48
/*
 *  Add our compressed file handlers.
 */
 HTSetConversion("www/compressed", "www/download",
					      HTCompressed,   1.0, 0.0, 0.0, 0);
 HTSetConversion("www/compressed", "www/present",
					      HTCompressed,   1.0, 0.0, 0.0, 0);
 HTSetConversion("www/compressed", "www/source",
					      HTCompressed,   1.0, 0.0, 0.0, 0);
 HTSetConversion("www/compressed", "www/dump",
					      HTCompressed,   1.0, 0.0, 0.0, 0);

 /*
  * Added the following to support some content types beginning to surface.
  */
 HTSetConversion("application/html", "text/x-c",
					HTMLToC,	0.5, 0.0, 0.0, 0);
 HTSetConversion("application/html", "text/plain",
					HTMLToPlain,	0.5, 0.0, 0.0, 0);
 HTSetConversion("application/html", "www/present",
					HTMLPresent,	2.0, 0.0, 0.0, 0);
 HTSetConversion("application/html", "www/source",
					HTPlainPresent,	1.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/source",
					HTPlainPresent,	1.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/present",
				        HTWSRCConvert,	2.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/download",
					HTWSRCConvert,	1.0, 0.0, 0.0, 0);
 HTSetConversion("application/x-wais-source", "www/dump",
					HTWSRCConvert,	1.0, 0.0, 0.0, 0);

 /*
  *  Save all unknown mime types to disk.
  */
 HTSetConversion("www/source",  "www/present",
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
 HTSetConversion("www/source",  "www/source",
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
 HTSetConversion("www/source",  "www/download",
					HTSaveToFile,	1.0, 3.0, 0.0, 0);
 HTSetConversion("www/source",  "*",	HTSaveToFile,	1.0, 3.0, 0.0, 0);

 /*
  *  Output all www/dump presentations to stdout.
  */
 HTSetConversion("www/source",  "www/dump",
					HTDumpToStdout,	1.0, 3.0, 0.0, 0);
d186 6
a191 52
/*
 *  Now add our basic conversions.
 */
 HTSetConversion("text/x-sgml",
			      "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/x-sgml",
			      "www/present", HTMLPresent,    2.0, 0.0, 0.0, 0);
 HTSetConversion("text/sgml", "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/sgml", "www/present", HTMLPresent,    1.0, 0.0, 0.0, 0);
 HTSetConversion("text/plain","www/present", HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/plain","www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/html", "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
 HTSetConversion("text/html", "text/x-c",    HTMLToC,	     0.5, 0.0, 0.0, 0);
 HTSetConversion("text/html", "text/plain",  HTMLToPlain,    0.5, 0.0, 0.0, 0);
 HTSetConversion("text/html", "www/present", HTMLPresent,    1.0, 0.0, 0.0, 0);

 /*
  *  These should override the default types as necessary.
  */
 HTLoadTypesConfigFile(global_type_map);

 /*
  *  Load the local maps.
  */
 if (LYCanReadFile(personal_type_map)) {
     /* These should override everything else. */
     HTLoadTypesConfigFile(personal_type_map);
 } else {
     char buffer[LY_MAXPATH];
     LYAddPathToHome(buffer, sizeof(buffer), personal_type_map);
     HTLoadTypesConfigFile(buffer);
 }

 /*
  *  Put text/html and text/plain at beginning of list. - kw
  */
 HTReorderPresentation(WWW_PLAINTEXT, WWW_PRESENT);
 HTReorderPresentation(WWW_HTML, WWW_PRESENT);

 /*
  * Analyze the list, and set 'get_accept' for those whose representations
  * are not redundant.
  */
 HTFilterPresentations();
}

PUBLIC void HTPreparsedFormatInit NOARGS
{
 if (LYPreparsedSource) {
     HTSetConversion("text/html", "www/source", HTMLParsedPresent, 1.0, 0.0, 0.0, 0);
     HTSetConversion("text/html", "www/dump",	HTMLParsedPresent, 1.0, 0.0, 0.0, 0);
 }
d227 1
d232 2
d235 1
a235 8
PRIVATE int ExitWithError PARAMS((char *txt));
PRIVATE int PassesTest PARAMS((struct MailcapEntry *mc));

#define LINE_BUF_SIZE		2048

PRIVATE char *GetCommand ARGS2(
	char *,		s,
	char **,	t)
d242 2
a243 1
    s2 = malloc(strlen(s)*2 + 1); /* absolute max, if all % signs */
d248 1
a248 1
    while (s && *s) {
d250 2
a251 1
	    if (*s == '%') *s2++ = '%'; /* Quote through next level, ugh! */
d258 1
a258 1
		return(++s);
d269 1
a269 1
    return(NULL);
d273 1
a273 2
PRIVATE char *Cleanse ARGS1(
	char *,		s)
d278 54
a331 1
    return(s);
d334 1
a334 3
PRIVATE int ProcessMailcapEntry ARGS2(
	FILE *,			fp,
	struct MailcapEntry *,	mc)
d340 1
a340 1
    rawentry = (char *)malloc(rawentryalloc);
d352 2
a353 1
	    rawentry = realloc(rawentry, rawentryalloc);
d355 1
a355 1
	        ExitWithError(MEMORY_EXHAUSTED_ABORT);
d357 2
a358 2
	if (len > 0 && LineBuf[len-1] == '\\') {
	    LineBuf[len-1] = '\0';
d371 1
a371 1
	return(0);
d375 3
a377 2
	CTRACE((tfp, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		    rawentry));
d379 1
a379 1
	return(0);
d387 1
a387 1
		    rawentry));
d389 1
a389 1
	return(0);
d419 1
a419 1
	if (arg && *arg) {
d428 1
d430 1
a430 1
			    mc->testcommand));
d432 1
a432 1
		mc->label = eq;
d434 1
a434 1
		mc->label = eq; /* bogus old name for description */
d436 1
a436 1
		mc->printcommand = eq;
d441 1
a441 1
	        mc->quality = (float)atof(eq);
d445 1
a445 1
	        mc->maxbytes = atol(eq);
d448 1
a448 1
	    } else if (strcmp(arg, "notes")) { /* IGNORE notes field */
d450 3
a452 2
		    CTRACE((tfp, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			        arg));
d460 1
a460 1
assign_presentation:
d465 6
a470 3
		    mc->contenttype, mc->command));
	HTSetPresentation(mc->contenttype, mc->command,
			  mc->quality, 3.0, 0.0, mc->maxbytes);
d473 1
d476 123
a598 1
    return(1);
d601 5
a605 6
PRIVATE void BuildCommand ARGS5(
	char **,	pBuf,
	size_t,		Bufsize,
	char *,		controlstring,
	char *,		TmpFileName,
	size_t,		TmpFileLen)
d607 3
a609 1
    char *from, *to;
d611 1
d613 6
a618 2
    for (from = controlstring, to = *pBuf; *from != '\0'; from++) {
	if (prefixed) {
d620 13
a632 3
	    switch(*from) {
		case '%':
		    *to++ = '%';
d634 77
a710 15
		case 'n':
		    /* FALLTHRU */
		case 'F':
		    CTRACE((tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
				controlstring));
		    /* FALLTHRU */
		case 's':
		    if (TmpFileLen && TmpFileName) {
			if ((to - *pBuf) + TmpFileLen + 1 > Bufsize) {
			    *to = '\0';
			    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
			    CTRACE((tfp, "              ignoring: %s%s...\n",
					*pBuf, TmpFileName));
			    **pBuf = '\0';
			    return;
d712 3
a714 2
			strcpy(to, TmpFileName);
			to += strlen(TmpFileName);
d716 1
d718 5
a722 3
		default:
		    CTRACE((tfp,
  "BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n",
d724 1
a724 1
		    break;
d729 1
a729 1
	    *to++ = *from;
d731 37
a767 7
	if (to >= *pBuf + Bufsize) {
	    (*pBuf)[Bufsize - 1] = '\0';
	    CTRACE((tfp, "BuildCommand: Too long mailcap \"test\" clause,\n"));
	    CTRACE((tfp, "              ignoring: %s...\n",
			*pBuf));
	    **pBuf = '\0';
	    return;
d770 19
a788 1
    *to = '\0';
d795 1
a795 4
PRIVATE int RememberTestResult ARGS3(
	int,		mode,
	char *,		cmd,
	int,		result)
d805 6
a810 21
    switch(mode) {
	case RTR_forget:
	    while(cmdlist) {
		cur = cmdlist->next;
		FREE(cmdlist->cmd);
		FREE(cmdlist);
		cmdlist = cur;
	    }
	    break;
	case RTR_lookup:
	    for(cur = cmdlist; cur; cur = cur->next)
		if(!strcmp(cmd, cur->cmd))
		    return cur->result;
	    return -1;
	case RTR_add:
	    cur = typecalloc(struct cmdlist_s);
	    if (cur == NULL)
		outofmem(__FILE__, "RememberTestResult");
	    cur->next = cmdlist;
	    StrAllocCopy(cur->cmd, cmd);
	    cur->result = result;
d812 17
a828 1
	    break;
d833 4
a836 2
PRIVATE int PassesTest ARGS1(
	struct MailcapEntry *,	mc)
a838 1
    char *cmd, TmpFileName[LY_MAXPATH];
d844 1
a844 1
	return(1);
d849 3
a851 3
    if (0 == strcmp(mc->testcommand, "test \"$DISPLAY\"") ||
	0 == strcmp(mc->testcommand, "test \"$DISPLAY\" != \"\"") ||
	0 == strcasecomp(mc->testcommand, "test -n \"$DISPLAY\"")) {
d856 1
a856 1
	    return(0 == 0);
d859 1
a859 1
	    return(-1 == 0);
d862 1
a862 1
    if (0 == strcasecomp(mc->testcommand, "test -z \"$DISPLAY\"")) {
d866 2
a867 2
	    CTRACE((tfp,"PassesTest: Test passed!\n"));
	    return(0 == 0);
d869 2
a870 2
	    CTRACE((tfp,"PassesTest: Test failed!\n"));
	    return(-1 == 0);
d877 1
a877 1
    if (0 == strcasecomp(mc->testcommand, "test -n \"$LYNX_VERSION\"")){
d881 1
a881 1
	return(0 == 0);
d883 4
a886 4
    /*
     *  ... or failure for this one! - FM
     */
    if (0 == strcasecomp(mc->testcommand, "test -z \"$LYNX_VERSION\"")) {
d890 1
a890 1
	return(-1 == 0);
d894 2
a895 23
    if(result == -1) {
	/*
	 *  Build the command and execute it.
	 */
	if (strchr(mc->testcommand, '%')) {
	    if (LYOpenTemp(TmpFileName, HTML_SUFFIX, "w") == 0)
		ExitWithError(CANNOT_OPEN_TEMP);
	    LYCloseTemp(TmpFileName);
	} else {
	    /* We normally don't need a temp file name - kw */
	    TmpFileName[0] = '\0';
	}
	cmd = (char *)malloc(1024);
	if (!cmd)
	    ExitWithError(MEMORY_EXHAUSTED_ABORT);
	BuildCommand(&cmd, 1024,
		     mc->testcommand,
		     TmpFileName,
		     strlen(TmpFileName));
	CTRACE((tfp, "PassesTest: Executing test command: %s\n", cmd));
	result = LYSystem(cmd);
	FREE(cmd);
	LYRemoveTemp(TmpFileName);
d903 2
a904 1
    FREE(mc->testcommand);
d906 4
a909 4
    if (result) {
	CTRACE((tfp,"PassesTest: Test failed!\n"));
    } else {
	CTRACE((tfp,"PassesTest: Test passed!\n"));
d912 1
a912 1
    return(result == 0);
d915 1
a915 2
PRIVATE int ProcessMailcapFile ARGS1(
	char *,		file)
d921 1
a921 1
		file));
d924 2
a925 2
		    file));
	return(-1 == 0);
d929 1
a929 1
	ProcessMailcapEntry(fp, &mc);
d933 1
a933 1
    return(0 == 0);
d936 1
a936 2
PRIVATE int ExitWithError ARGS1(
	char *,		txt)
d941 1
a941 1
    return(-1);
d949 1
a949 2
PRIVATE int HTLoadTypesConfigFile ARGS1(
	char *,		fn)
d952 1
a952 1
    HTList * saved = HTPresentations;
d954 1
a954 1
    if (reverse_mailcap) {		/* temporarily hide existing list */
d958 1
a958 1
    result = ProcessMailcapFile(fn);
a971 3



d977 9
a985 9
**	------------------------------
**
**	The LAST suffix for a type is that used for temporary files
**	of that type.
**	The quality is an apriori bias as to whether the file should be
**	used.  Not that different suffixes can be used to represent files
**	which are of the same format but are originals or regenerated,
**	with different values.
*/
d987 24
a1010 23
 *  Additional notes: the encoding parameter may be taken into account when
 *  looking for a match; for that purpose "7bit", "8bit", and "binary" are
 *  equivalent.
 *  Use of mixed case and of pseudo MIME types with embedded spaces should
 *  be avoided.  It was once necessary for getting the fancy strings into
 *  type labels in FTP directory listings, but that can now be done with
 *  the description field (using HTSetSuffix5).  AFAIK the only effect of
 *  such "fancy" (and mostly invalid) types that cannot be reproduced by
 *  using a description fields is some statusline messages in SaveToFile
 *  (HTFWriter.c).  And showing the user an invalid MIME type as the
 *  'Content-type:' is not such a hot idea anyway, IMO.  Still, if you
 *  want it, it is still possible (even in lynx.cfg now), but use of it
 *  in the defaults below has been reduced.
 *  Case variations rely on peculiar behavior of HTAtom.c for matching.
 *  They lead to surprising behavior, Lynx retains the case of a string
 *  in the form first encountered after starting up.  So while later suffix
 *  rules generally override or modify earlier ones, the case used for a
 *  MIME time is determined by the first suffix rule (or other occurrence).
 *  Matching in HTAtom_for is effectively case insensitive, except for the
 *  first character of the string which is treated as case-sensitive by the
 *  hash function there; best not to rely on that, rather convert MIME types
 *  to lowercase on input as is already done in most places (And HTAtom could
 *  become consistently case-sensitive, as in newer W3C libwww).
d1013 1
a1013 1
PUBLIC void HTFileInit NOARGS
d1016 2
a1017 7
    if (LYUseBuiltinSuffixes)
    {
    CTRACE((tfp, "HTFileInit: Loading default (HTInit) extension maps.\n"));

    /* default suffix interpretation */
    HTSetSuffix("*",		"text/plain", "8bit", 1.0);
    HTSetSuffix("*.*",		"text/plain", "8bit", 1.0);
d1019 3
d1024 3
a1026 3
    /*
     *  define these extensions for exec scripts.
     */
d1028 4
a1031 4
    /* for csh exec links */
    HTSetSuffix(".csh",		"application/x-csh", "8bit", 0.8);
    HTSetSuffix(".sh",		"application/x-sh", "8bit", 0.8);
    HTSetSuffix(".ksh",		"application/x-ksh", "8bit", 0.8);
d1033 1
a1033 1
    HTSetSuffix(".com",		"application/x-VMS_script", "8bit", 0.8);
d1037 22
a1058 22
    /*
     *  Some of the old incarnation of the mappings is preserved
     *  and can be had by defining TRADITIONAL_SUFFIXES.  This
     *  is for some cases where I felt the old rules might be preferred
     *  by someone, for some reason.  It's not done consistently.
     *  A lot more of this stuff could probably be changed too or
     *  omitted, now that nearly the equivalent functionality is
     *  available in lynx.cfg. - kw 1999-10-12
     */
    HTSetSuffix(".saveme",	"application/x-Binary", "binary", 1.0);
    HTSetSuffix(".dump",	"application/x-Binary", "binary", 1.0);
    HTSetSuffix(".bin",		"application/x-Binary", "binary", 1.0);

    HTSetSuffix(".arc",		"application/x-Compressed", "binary", 1.0);

    HTSetSuffix(".alpha-exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".alpha_exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".AXP-exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".AXP_exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".VAX-exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix(".VAX_exe",	"application/x-Executable", "binary", 1.0);
    HTSetSuffix5(".exe",	"application/octet-stream", "binary", "Executable", 1.0);
d1061 4
a1064 5
    HTSetSuffix(".exe.Z",	"application/x-Comp. Executable",
							     "binary", 1.0);
    HTSetSuffix(".Z",	        "application/UNIX Compressed", "binary", 1.0);
    HTSetSuffix(".tar_Z",	"application/UNIX Compr. Tar", "binary", 1.0);
    HTSetSuffix(".tar.Z",	"application/UNIX Compr. Tar", "binary", 1.0);
d1066 5
a1070 8
    HTSetSuffix5(".Z",	        "application/x-compress", "binary", "UNIX Compressed", 1.0);
    HTSetSuffix5(".Z",	        NULL, "compress",      "UNIX Compressed", 1.0);
    HTSetSuffix5(".exe.Z",	"application/octet-stream", "compress",
						       "Executable", 1.0);
    HTSetSuffix5(".tar_Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
    HTSetSuffix5(".tar.Z",	"application/x-tar", "compress",
						       "UNIX Compr. Tar", 1.0);
d1074 3
a1076 3
    HTSetSuffix("-gz",		"application/GNU Compressed", "binary", 1.0);
    HTSetSuffix("_gz",		"application/GNU Compressed", "binary", 1.0);
    HTSetSuffix(".gz",		"application/GNU Compressed", "binary", 1.0);
d1078 2
a1079 2
    HTSetSuffix5(".tar.gz",	"application/x-tar", "binary", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
d1081 6
a1086 6
    HTSetSuffix5("-gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		"application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("-gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz",		NULL, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz",		NULL, "gzip", "GNU Compressed", 1.0);
d1088 2
a1089 2
    HTSetSuffix5(".tar.gz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz",	"application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
d1093 2
a1094 2
    HTSetSuffix(".src",		"application/x-WAIS-source", "8bit", 1.0);
    HTSetSuffix(".wsrc",	"application/x-WAIS-source", "8bit", 1.0);
d1096 1
a1096 1
    HTSetSuffix5(".wsrc",	"application/x-wais-source", "8bit", "WAIS-source", 1.0);
d1099 1
a1099 1
    HTSetSuffix5(".zip",	"application/zip", "binary", "Zip File", 1.0);
d1101 2
a1102 1
    HTSetSuffix(".bz2",		"application/x-bzip2", "binary", 1.0);
d1104 2
a1105 1
    HTSetSuffix(".bz2",		"application/bzip2", "binary", 1.0);
d1108 1
a1108 1
    HTSetSuffix(".uu",		"application/x-UUencoded", "8bit", 1.0);
d1110 1
a1110 1
    HTSetSuffix(".hqx",		"application/x-Binhex", "8bit", 1.0);
d1112 2
a1113 2
    HTSetSuffix(".o",		"application/x-Prog. Object", "binary", 1.0);
    HTSetSuffix(".a",		"application/x-Prog. Library", "binary", 1.0);
d1115 1
a1115 1
    HTSetSuffix5(".uu",		"application/x-uuencoded", "7bit", "UUencoded", 1.0);
d1117 1
a1117 1
    HTSetSuffix5(".hqx",	"application/mac-binhex40", "8bit", "Mac BinHex", 1.0);
d1119 3
a1121 3
    HTSetSuffix5(".o",		"application/octet-stream", "binary", "Prog. Object", 0.5);
    HTSetSuffix5(".a",		"application/octet-stream", "binary", "Prog. Library", 0.5);
    HTSetSuffix5(".so",		"application/octet-stream", "binary", "Shared Lib", 0.5);
d1124 1
a1124 1
    HTSetSuffix5(".oda",	"application/oda", "binary", "ODA", 1.0);
d1126 1
a1126 1
    HTSetSuffix5(".pdf",	"application/pdf", "binary", "PDF", 1.0);
d1128 3
a1130 3
    HTSetSuffix5(".eps",	"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ai",		"application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ps",		"application/postscript", "8bit", "Postscript", 1.0);
d1132 1
a1132 1
    HTSetSuffix5(".rtf",	"application/rtf", "8bit", "RTF", 1.0);
d1134 1
a1134 1
    HTSetSuffix5(".dvi",	"application/x-dvi", "8bit", "DVI", 1.0);
d1136 1
a1136 1
    HTSetSuffix5(".hdf",	"application/x-hdf", "8bit", "HDF", 1.0);
d1138 2
a1139 2
    HTSetSuffix(".cdf",		"application/x-netcdf", "8bit", 1.0);
    HTSetSuffix(".nc",		"application/x-netcdf", "8bit", 1.0);
d1142 4
a1145 4
    HTSetSuffix(".latex",	"application/x-Latex", "8bit", 1.0);
    HTSetSuffix(".tex",		"application/x-Tex", "8bit", 1.0);
    HTSetSuffix(".texinfo",	"application/x-Texinfo", "8bit", 1.0);
    HTSetSuffix(".texi",	"application/x-Texinfo", "8bit", 1.0);
d1147 4
a1150 4
    HTSetSuffix5(".latex",	"application/x-latex", "8bit", "LaTeX", 1.0);
    HTSetSuffix5(".tex",	"text/x-tex", "8bit", "TeX", 1.0);
    HTSetSuffix5(".texinfo",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
    HTSetSuffix5(".texi",	"application/x-texinfo", "8bit", "Texinfo", 1.0);
d1154 7
a1160 7
    HTSetSuffix(".t",		"application/x-Troff", "8bit", 1.0);
    HTSetSuffix(".tr",		"application/x-Troff", "8bit", 1.0);
    HTSetSuffix(".roff",	"application/x-Troff", "8bit", 1.0);

    HTSetSuffix(".man",		"application/x-Troff-man", "8bit", 1.0);
    HTSetSuffix(".me",		"application/x-Troff-me", "8bit", 1.0);
    HTSetSuffix(".ms",		"application/x-Troff-ms", "8bit", 1.0);
d1162 7
a1168 7
    HTSetSuffix5(".t",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".tr",		"application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".roff",	"application/x-troff", "8bit", "Troff", 1.0);

    HTSetSuffix5(".man",	"application/x-troff-man", "8bit", "Man Page", 1.0);
    HTSetSuffix5(".me",		"application/x-troff-me", "8bit", "Troff me", 1.0);
    HTSetSuffix5(".ms",		"application/x-troff-ms", "8bit", "Troff ms", 1.0);
d1171 1
a1171 1
    HTSetSuffix(".zoo",		"application/x-Zoo File", "binary", 1.0);
d1174 13
a1186 13
    HTSetSuffix(".bak",		"application/x-VMS BAK File", "binary", 1.0);
    HTSetSuffix(".bkp",		"application/x-VMS BAK File", "binary", 1.0);
    HTSetSuffix(".bck",		"application/x-VMS BAK File", "binary", 1.0);

    HTSetSuffix5(".bkp_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bkp-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck_gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);
    HTSetSuffix5(".bck-gz",	"application/octet-stream", "gzip", "GNU BAK File", 1.0);

    HTSetSuffix5(".bkp-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bkp_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck-Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
    HTSetSuffix5(".bck_Z",	"application/octet-stream", "compress", "Comp. BAK File", 1.0);
d1188 3
a1190 3
    HTSetSuffix5(".bak",	NULL, "binary", "Backup", 0.5);
    HTSetSuffix5(".bkp",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
    HTSetSuffix5(".bck",	"application/octet-stream", "binary", "VMS BAK File", 1.0);
d1194 6
a1199 6
    HTSetSuffix(".hlb",		"application/x-VMS Help Libr.", "binary", 1.0);
    HTSetSuffix(".olb",		"application/x-VMS Obj. Libr.", "binary", 1.0);
    HTSetSuffix(".tlb",		"application/x-VMS Text Libr.", "binary", 1.0);
    HTSetSuffix(".obj",		"application/x-VMS Prog. Obj.", "binary", 1.0);
    HTSetSuffix(".decw$book",	"application/x-DEC BookReader", "binary", 1.0);
    HTSetSuffix(".mem",		"application/x-RUNOFF-MANUAL", "8bit", 1.0);
d1201 6
a1206 6
    HTSetSuffix5(".hlb",	"application/octet-stream", "binary", "VMS Help Libr.", 1.0);
    HTSetSuffix5(".olb",	"application/octet-stream", "binary", "VMS Obj. Libr.", 1.0);
    HTSetSuffix5(".tlb",	"application/octet-stream", "binary", "VMS Text Libr.", 1.0);
    HTSetSuffix5(".obj",	"application/octet-stream", "binary", "Prog. Object", 1.0);
    HTSetSuffix5(".decw$book",	"application/octet-stream", "binary", "DEC BookReader", 1.0);
    HTSetSuffix5(".mem",	"text/x-runoff-manual", "8bit", "RUNOFF-MANUAL", 1.0);
d1209 1
a1209 1
    HTSetSuffix(".vsd",		"application/visio", "binary", 1.0);
d1211 3
a1213 3
    HTSetSuffix5(".lha",	"application/x-lha", "binary", "lha File", 1.0);
    HTSetSuffix5(".lzh",	"application/x-lzh", "binary", "lzh File", 1.0);
    HTSetSuffix5(".sea",	"application/x-sea", "binary", "sea File", 1.0);
d1215 1
a1215 1
    HTSetSuffix5(".sit",	"application/x-sit", "binary", "sit File", 1.0);
d1217 1
a1217 1
    HTSetSuffix5(".sit",	"application/x-stuffit", "binary", "StuffIt", 1.0);
d1219 2
a1220 2
    HTSetSuffix5(".dms",	"application/x-dms", "binary", "dms File", 1.0);
    HTSetSuffix5(".iff",	"application/x-iff", "binary", "iff File", 1.0);
d1222 2
a1223 2
    HTSetSuffix(".bcpio",	"application/x-bcpio", "binary", 1.0);
    HTSetSuffix(".cpio",	"application/x-cpio", "binary", 1.0);
d1226 1
a1226 1
    HTSetSuffix(".gtar",	"application/x-gtar", "binary", 1.0);
d1229 2
a1230 2
    HTSetSuffix(".shar",	"application/x-shar", "8bit", 1.0);
    HTSetSuffix(".share",	"application/x-share", "8bit", 1.0);
d1233 1
a1233 1
    HTSetSuffix(".sh",		"application/x-sh", "8bit", 1.0); /* xtra */
d1236 2
a1237 2
    HTSetSuffix(".sv4cpio",	"application/x-sv4cpio", "binary", 1.0);
    HTSetSuffix(".sv4crc",	"application/x-sv4crc", "binary", 1.0);
d1239 2
a1240 2
    HTSetSuffix5(".tar",	"application/x-tar", "binary", "Tar File", 1.0);
    HTSetSuffix(".ustar",	"application/x-ustar", "binary", 1.0);
d1242 2
a1243 2
    HTSetSuffix(".snd",		"audio/basic", "binary", 1.0);
    HTSetSuffix(".au",		"audio/basic", "binary", 1.0);
d1245 63
a1307 61
    HTSetSuffix(".aifc",	"audio/x-aiff", "binary", 1.0);
    HTSetSuffix(".aif",		"audio/x-aiff", "binary", 1.0);
    HTSetSuffix(".aiff",	"audio/x-aiff", "binary", 1.0);
    HTSetSuffix(".wav",		"audio/x-wav", "binary", 1.0);
    HTSetSuffix(".midi",	"audio/midi", "binary", 1.0);
    HTSetSuffix(".mod",		"audio/mod", "binary", 1.0);

    HTSetSuffix(".gif",		"image/gif", "binary", 1.0);
    HTSetSuffix(".ief",		"image/ief", "binary", 1.0);
    HTSetSuffix(".jfif",	"image/jpeg", "binary", 1.0); /* xtra */
    HTSetSuffix(".jfif-tbnl",	"image/jpeg", "binary", 1.0); /* xtra */
    HTSetSuffix(".jpe",		"image/jpeg", "binary", 1.0);
    HTSetSuffix(".jpg",		"image/jpeg", "binary", 1.0);
    HTSetSuffix(".jpeg",	"image/jpeg", "binary", 1.0);
    HTSetSuffix(".tif",		"image/tiff", "binary", 1.0);
    HTSetSuffix(".tiff",	"image/tiff", "binary", 1.0);
    HTSetSuffix(".ham",		"image/ham", "binary", 1.0);
    HTSetSuffix(".ras",		"image/x-cmu-rast", "binary", 1.0);
    HTSetSuffix(".pnm",		"image/x-portable-anymap", "binary", 1.0);
    HTSetSuffix(".pbm",		"image/x-portable-bitmap", "binary", 1.0);
    HTSetSuffix(".pgm",		"image/x-portable-graymap", "binary", 1.0);
    HTSetSuffix(".ppm",		"image/x-portable-pixmap", "binary", 1.0);
    HTSetSuffix(".png",		"image/png", "binary", 1.0);
    HTSetSuffix(".rgb",		"image/x-rgb", "binary", 1.0);
    HTSetSuffix(".xbm",		"image/x-xbitmap", "binary", 1.0);
    HTSetSuffix(".xpm",		"image/x-xpixmap", "binary", 1.0);
    HTSetSuffix(".xwd",		"image/x-xwindowdump", "binary", 1.0);

    HTSetSuffix(".rtx",		"text/richtext", "8bit", 1.0);
    HTSetSuffix(".tsv",		"text/tab-separated-values", "8bit", 1.0);
    HTSetSuffix(".etx",		"text/x-setext", "8bit", 1.0);

    HTSetSuffix(".mpg",		"video/mpeg", "binary", 1.0);
    HTSetSuffix(".mpe",		"video/mpeg", "binary", 1.0);
    HTSetSuffix(".mpeg",	"video/mpeg", "binary", 1.0);
    HTSetSuffix(".mov",		"video/quicktime", "binary", 1.0);
    HTSetSuffix(".qt",		"video/quicktime", "binary", 1.0);
    HTSetSuffix(".avi",		"video/x-msvideo", "binary", 1.0);
    HTSetSuffix(".movie",	"video/x-sgi-movie", "binary", 1.0);
    HTSetSuffix(".mv",		"video/x-sgi-movie", "binary", 1.0);

    HTSetSuffix(".mime",	"message/rfc822", "8bit", 1.0);

    HTSetSuffix(".c",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".cc",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".c++",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".h",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".pl",		"text/plain", "8bit", 1.0);
    HTSetSuffix(".text",	"text/plain", "8bit", 1.0);
    HTSetSuffix(".txt",		"text/plain", "8bit", 1.0);

    HTSetSuffix(".php",		"text/html", "8bit", 1.0);
    HTSetSuffix(".php3",	"text/html", "8bit", 1.0);
    HTSetSuffix(".html3",	"text/html", "8bit", 1.0);
    HTSetSuffix(".ht3",		"text/html", "8bit", 1.0);
    HTSetSuffix(".phtml",	"text/html", "8bit", 1.0);
    HTSetSuffix(".shtml",	"text/html", "8bit", 1.0);
    HTSetSuffix(".sht",		"text/html", "8bit", 1.0);
    HTSetSuffix(".htmlx",	"text/html", "8bit", 1.0);
    HTSetSuffix(".htm",		"text/html", "8bit", 1.0);
    HTSetSuffix(".html",	"text/html", "8bit", 1.0);
d1309 10
a1318 9
    } else { /* LYSuffixRules */
    /*
     *  Note that even .html -> text/html, .htm -> text/html are omitted
     *  if default maps are compiled in but then skipped because of a
     *  configuration file directive.  Whoever changes the config file
     *  in this way can easily also add the SUFFIX rules there. - kw
     */
    CTRACE((tfp, "HTFileInit: Skipping all default (HTInit) extension maps!\n"));
    } /* LYSuffixRules */
d1322 2
a1323 1
    CTRACE((tfp, "HTFileInit: Default (HTInit) extension maps not compiled in.\n"));
d1325 4
a1328 5
     *  The followin two are still used if BUILTIN_SUFFIX_MAPS was
     *  undefined.  Without one of them, lynx would always need to
     *  have a mapping specified in a lynx.cfg or mime.types file
     *  to be usable for local HTML files at all.  That includes
     *  many of the generated user interface pages. - kw
d1330 2
a1331 2
    HTSetSuffix(".htm",		"text/html", "8bit", 1.0);
    HTSetSuffix(".html",	"text/html", "8bit", 1.0);
d1334 4
d1339 5
a1343 2
    /* These should override the default extensions as necessary. */
    HTLoadExtensionsConfigFile(global_extension_map);
a1344 5
    if (LYCanReadFile(personal_extension_map)) {
	/* These should override everything else. */
	HTLoadExtensionsConfigFile(personal_extension_map);
    } else {
	char buffer[LY_MAXPATH];
d1346 3
a1348 2
	/* These should override everything else. */
	HTLoadExtensionsConfigFile(buffer);
a1351 1

d1363 1
a1363 4
PRIVATE int HTGetLine ARGS3(
	char *,		s,
	int,		n,
	FILE *,		f)
d1368 1
a1368 1
	return(1);
d1372 1
a1372 1
	s[i] = (char)r;
d1382 1
a1382 1
	if ((r == EOF) || (s[i] == LF) || (s[i] == CR) || (i == (n-1))) {
d1390 1
a1390 5
PRIVATE void HTGetWord ARGS4(
	char *,		word,
	char *,		line,
	char ,		stop,
	char ,		stop2)
d1401 1
a1401 1
    y=0;
d1403 1
a1403 2
    while ((line[y++] = line[x++]))
	;
d1408 1
a1408 2
PRIVATE int HTLoadExtensionsConfigFile ARGS1(
	char *,		fn)
d1423 1
a1423 1
    while (!(HTGetLine(line,sizeof(line),f))) {
d1431 1
a1431 1
	while(line[0]) {
d1441 2
a1442 2
	        if (strstr(ct, "tex") != NULL ||
	            strstr(ct, "postscript") != NULL ||
d1446 3
a1448 3
		    HTSetSuffix (ext, ct, "8bit", 1.0);
	        else
		    HTSetSuffix (ext, ct, "binary", 1.0);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d45 1
a45 1
  							    1.0, 3.0, 0.0, 0);
d91 1
a91 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d93 1
a93 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d95 1
a95 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d97 1
a97 1
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d103 1
a103 1
 					HTMLToC,	0.5, 0.0, 0.0, 0);
d105 1
a105 1
 					HTMLToPlain,	0.5, 0.0, 0.0, 0);
d107 1
a107 1
 					HTMLPresent,	2.0, 0.0, 0.0, 0);
d109 1
a109 1
 					HTPlainPresent,	1.0, 0.0, 0.0, 0);
d123 1
a123 1
 					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d125 1
a125 1
 					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d127 1
a127 1
 					HTSaveToFile,	1.0, 3.0, 0.0, 0);
d134 1
a134 1
 					HTDumpToStdout,	1.0, 3.0, 0.0, 0);
d140 1
a140 1
 			      "www/source",  HTPlainPresent, 1.0, 0.0, 0.0, 0);
d142 1
a142 1
 			      "www/present", HTMLPresent,    2.0, 0.0, 0.0, 0);
d148 1
a148 1
 HTSetConversion("text/html", "text/x-c",    HTMLToC, 	     0.5, 0.0, 0.0, 0);
d284 1
a284 1
    size_t rawentryalloc = 2000, len;
d288 1
a288 1
    rawentry = (char *)malloc(1 + rawentryalloc);
d293 2
a294 1
	if (LineBuf[0] == '#')
d297 4
a300 7
	if (len == 0)
	    continue;
	if (LineBuf[len-1] == '\n')
	    LineBuf[--len] = '\0';
	if ((len + strlen(rawentry)) > rawentryalloc) {
	    rawentryalloc += 2000;
	    rawentry = realloc(rawentry, rawentryalloc+1);
d420 1
a420 1
	char **, 	pBuf,
d543 1
a543 1
    	if (LYgetXDisplay() != NULL) {
d554 1
a554 1
    	if (LYgetXDisplay() == NULL) {
d778 1
a778 1
    							     "binary", 1.0);
d786 1
a786 1
    						       "Executable", 1.0);
d861 1
a861 1
    HTSetSuffix(".tex",  	"application/x-Tex", "8bit", 1.0);
d866 1
a866 1
    HTSetSuffix5(".tex",  	"text/x-tex", "8bit", "TeX", 1.0);
d1014 2
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a35 2
 FILE *fp = NULL;

d46 11
a56 9
  HTSetPresentation("image/gif",        XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-xbm",      XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-xbitmap",  XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-png",      XLoadImageCommand,  2.0, 3.0, 0.0, 0);
  HTSetPresentation("image/png",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-rgb",      XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/x-tiff",     XLoadImageCommand,  2.0, 3.0, 0.0, 0);
  HTSetPresentation("image/tiff",	XLoadImageCommand,  1.0, 3.0, 0.0, 0);
  HTSetPresentation("image/jpeg",       XLoadImageCommand,  1.0, 3.0, 0.0, 0);
d65 3
a67 3
 HTSetPresentation("application/x-csh",	"csh %s", 999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-sh",	"sh %s",  999.0, 3.0, 0.0, 0);
 HTSetPresentation("application/x-ksh",	"ksh %s", 999.0, 3.0, 0.0, 0);
d76 6
a89 2
 HTSetConversion("www/compressed", "www/present",
 					      HTCompressed,   1.0, 0.0, 0.0, 0);
d160 1
a160 2
 if ((fp = fopen(personal_type_map,"r")) != NULL) {
     fclose(fp);
d174 6
d240 1
d316 1
a316 1
    s = LYSkipBlanks(rawentry);
d324 2
a325 2
	CTRACE(tfp, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
		    rawentry);
d330 2
a331 2
    if (!strncasecomp(rawentry, "text/html", 9) ||
	!strncasecomp(rawentry, "text/plain", 10)) {
d334 2
a335 2
	CTRACE(tfp, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
		    rawentry);
d348 3
a350 5
    mc->contenttype = (char *)malloc(1 + strlen(rawentry));
    if (!mc->contenttype)
	ExitWithError(MEMORY_EXHAUSTED_ABORT);
    strcpy(mc->contenttype, rawentry);
    mc->quality = 1.0;
d365 1
d376 2
a377 2
		CTRACE(tfp, "ProcessMailcapEntry: Found testcommand:%s\n",
			    mc->testcommand);
d388 1
a388 1
	        mc->quality = atof(eq);
d390 1
a390 1
		    mc->quality = 0.001;
d397 2
a398 2
		    CTRACE(tfp, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			        arg);
d410 2
a411 2
	CTRACE(tfp, "ProcessMailcapEntry Setting up conversion %s : %s\n",
		    mc->contenttype, mc->command);
d439 1
d441 3
a443 2
		    CTRACE(tfp, "BuildCommand: Bad mailcap \"test\" clause: %s\n",
				controlstring);
d448 3
a450 3
			    CTRACE(tfp, "BuildCommand: Too long mailcap \"test\" clause,\n");
			    CTRACE(tfp, "              ignoring: %s%s...\n",
					*pBuf, TmpFileName);
d459 1
a459 1
		    CTRACE(tfp,
d461 1
a461 1
			*from);
d471 3
a473 3
	    CTRACE(tfp, "BuildCommand: Too long mailcap \"test\" clause,\n");
	    CTRACE(tfp, "              ignoring: %s...\n",
			*pBuf);
d513 1
a513 1
	    cur = calloc(1, sizeof(struct cmdlist_s));
d517 1
a517 5
	    cur->cmd = (char *)malloc(strlen(cmd) + 1);
	    if(cur->cmd)
		strcpy(cur->cmd, cmd);
	    else
		ExitWithError("Out of memory");
d540 3
a542 1
    if (0 == strcasecomp(mc->testcommand, "test -n \"$DISPLAY\"")) {
d544 1
a544 1
	CTRACE(tfp, "PassesTest: Testing for XWINDOWS environment.\n");
d546 1
a546 1
	    CTRACE(tfp, "PassesTest: Test passed!\n");
d549 1
a549 1
	    CTRACE(tfp, "PassesTest: Test failed!\n");
d555 1
a555 1
	CTRACE(tfp, "PassesTest: Testing for NON_XWINDOWS environment.\n");
d557 1
a557 1
	    CTRACE(tfp,"PassesTest: Test passed!\n");
d560 1
a560 1
	    CTRACE(tfp,"PassesTest: Test failed!\n");
d570 2
a571 2
	CTRACE(tfp, "PassesTest: Testing for LYNX environment.\n");
	CTRACE(tfp, "PassesTest: Test passed!\n");
d579 2
a580 2
	CTRACE(tfp, "PassesTest: Testing for non-LYNX environment.\n");
	CTRACE(tfp, "PassesTest: Test failed!\n");
d604 1
a604 1
	CTRACE(tfp, "PassesTest: Executing test command: %s\n", cmd);
d618 1
a618 1
	CTRACE(tfp,"PassesTest: Test failed!\n");
d620 1
a620 1
	CTRACE(tfp,"PassesTest: Test passed!\n");
d632 5
a636 5
    CTRACE(tfp, "ProcessMailcapFile: Loading file '%s'.\n",
		file);
    if ((fp = fopen(file, "r")) == NULL) {
	CTRACE(tfp, "ProcessMailcapFile: Could not open '%s'.\n",
		    file);
d643 1
a643 1
    fclose(fp);
d652 2
a653 2
	fprintf(tfp, "metamail: %s\n", txt);
    exit_immediately(-1);
d657 4
a660 1
#define reverse_mailcap 1
d703 26
a728 1

d731 4
a734 1
    FILE *fp;
d736 3
a738 1
    CTRACE(tfp, "HTFileInit: Loading default (HTInit) extension maps.\n");
a739 3
    /* default suffix interpretation */
    HTSetSuffix("*",		"text/plain", "7bit", 1.0);
    HTSetSuffix("*.*",		"text/plain", "7bit", 1.0);
d755 9
a763 1

d776 1
a776 1
    HTSetSuffix(".exe",		"application/x-Executable", "binary", 1.0);
d778 1
a780 1

a781 1

d784 10
d795 1
d802 11
d814 1
d817 3
d821 1
a821 1
    HTSetSuffix(".zip",		"application/x-Zip File", "binary", 1.0);
d825 3
d834 9
d848 3
a850 3
    HTSetSuffix(".eps",		"application/Postscript", "8bit", 1.0);
    HTSetSuffix(".ai",		"application/Postscript", "8bit", 1.0);
    HTSetSuffix(".ps",		"application/Postscript", "8bit", 1.0);
d852 1
a852 1
    HTSetSuffix(".rtf",		"application/RTF", "8bit", 1.0);
d854 1
a854 1
    HTSetSuffix(".dvi",		"application/x-DVI", "8bit", 1.0);
d856 1
a856 1
    HTSetSuffix(".hdf",		"application/x-HDF", "8bit", 1.0);
d861 1
d866 6
d873 1
d881 9
d893 1
d898 14
a911 9
    HTSetSuffix(".bkp_gz",	"application/x-GNU BAK File", "binary", 1.0);
    HTSetSuffix(".bkp-gz",	"application/x-GNU BAK File", "binary", 1.0);
    HTSetSuffix(".bck_gz",	"application/x-GNU BAK File", "binary", 1.0);
    HTSetSuffix(".bck-gz",	"application/x-GNU BAK File", "binary", 1.0);

    HTSetSuffix(".bkp-Z",	"application/x-Comp. BAK File", "binary", 1.0);
    HTSetSuffix(".bkp_Z",	"application/x-Comp. BAK File", "binary", 1.0);
    HTSetSuffix(".bck-Z",	"application/x-Comp. BAK File", "binary", 1.0);
    HTSetSuffix(".bck_Z",	"application/x-Comp. BAK File", "binary", 1.0);
d913 1
d920 8
d931 10
a940 9
    HTSetSuffix(".lha",		"application/x-lha File", "binary", 1.0);
    HTSetSuffix(".lzh",		"application/x-lzh File", "binary", 1.0);

    HTSetSuffix(".sea",		"application/x-sea File", "binary", 1.0);
    HTSetSuffix(".sit",		"application/x-sit File", "binary", 1.0);

    HTSetSuffix(".dms",		"application/x-dms File", "binary", 1.0);

    HTSetSuffix(".iff",		"application/x-iff File", "binary", 1.0);
d945 1
d947 1
d952 1
d954 1
d1025 25
d1053 1
a1053 2
    if ((fp = fopen(personal_extension_map,"r")) != NULL) {
	fclose(fp);
d1093 1
a1093 1
		s[i] = r;
d1138 1
a1138 1
    CTRACE(tfp, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn);
d1140 2
a1141 2
    if ((f = fopen(fn,"r")) == NULL) {
	CTRACE(tfp, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn);
d1149 2
a1150 4
	ct = (char *)malloc(sizeof(char) * (strlen(word) + 1));
	if (!ct)
	    outofmem(__FILE__, "HTLoadExtensionsConfigFile");
	strcpy(ct,word);
d1156 1
a1156 3
		char *ext = (char *)malloc(sizeof(char) * (strlen(word)+1+1));
	        if (!ext)
	            outofmem(__FILE__, "HTLoadExtensionsConfigFile");
d1158 1
a1158 1
		sprintf(ext, ".%s", word);
d1161 1
a1161 1
		CTRACE (tfp, "SETTING SUFFIX '%s' to '%s'.\n", ext, ct);
d1178 1
a1178 1
    fclose(f);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*		Configuration-specific Initialialization	HTInit.c
d9 1
a9 2
#include "HTUtils.h"
#include "tcp.h"
d13 1
a13 1
#include "HTInit.h"
d15 12
a26 14
#include "HTML.h"
#include "HTPlain.h"
#include "HTMLGen.h"
#include "HTFile.h"
#include "HTFormat.h"
#include "HTMIME.h"
#include "HTWSRC.h"

#include "HTSaveToFile.h"  /* LJM */
#include "userdefs.h"
#include "LYUtils.h"
#include "LYGlobalDefs.h"
#include "LYSignal.h"
#include "LYSystem.h"
d28 2
a29 10
#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */
a36 1
 char *cp = NULL;
d45 1
a45 1
 if ((cp = getenv(DISPLAY)) != NULL && *cp != '\0') {	/* Must have X11 */
d161 2
a162 7
     char buffer[256];
#ifdef VMS
     sprintf(buffer, "sys$login:%s", personal_type_map);
#else
     sprintf(buffer, "%s/%s", (Home_Dir() ? Home_Dir() : ""),
			      personal_type_map);
#endif
a222 1
#define TMPFILE_NAME_SIZE	256
d234 1
a234 1
	ExitWithError("Out of memory");
d264 4
a267 14
    char *tmp, *news;

    /* strip leading white space */
    while (*s && isspace((unsigned char) *s))
	++s;
    news = s;
    /* put in lower case */
    for (tmp=s; *tmp; ++tmp) {
	*tmp = TOLOWER ((unsigned char)*tmp);
    }
    /* strip trailing white space */
    while ((tmp > news) && *--tmp && isspace((unsigned char) *tmp))
	*tmp = '\0';
    return(news);
a273 1
    int i, j;
d275 2
a276 1
    char *rawentry, *s, *t, *LineBuf;
a277 3
    LineBuf = (char *)malloc(LINE_BUF_SIZE);
    if (!LineBuf)
	ExitWithError("Out of memory");
d280 1
a280 1
	ExitWithError("Out of memory");
d282 1
a282 1
    while (fgets(LineBuf, LINE_BUF_SIZE, fp)) {
d294 1
a294 1
	        ExitWithError("Out of memory");
a303 1

d306 1
a306 2
    for (s = rawentry; *s && isspace((unsigned char) *s); ++s)
	;
d314 2
a315 5
	if (TRACE) {
		fprintf(stderr,
		 "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
			rawentry);
	}
d324 2
a325 5
	if (TRACE) {
		fprintf(stderr,
			"ProcessMailcapEntry: Ignoring mailcap entry: %s\n",
			rawentry);
	}
d329 3
a331 6
    for (i = 0, j = 0; rawentry[i]; i++) {
	if (rawentry[i] != ' ') {
	    rawentry[j++] = TOLOWER(rawentry[i]);
	}
    }
    rawentry[j] = '\0';
d340 1
a340 1
	ExitWithError("Out of memory");
d348 1
a348 2
    s = t;
    while (s && *s && isspace((unsigned char) *s)) ++s;
d367 1
a367 3
		if (TRACE)
		    fprintf(stderr,
		    	    "ProcessMailcapEntry: Found testcommand:%s\n",
d387 3
a389 4
		if (*arg && TRACE)
		    fprintf(stderr,
			"ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n",
			    arg);
d393 2
a394 2
      FREE(mallocd_string);
      s = t;
d401 1
a401 3
	if (TRACE)
	    fprintf(stderr,
	    	    "ProcessMailcapEntry Setting up conversion %s : %s\n",
d431 1
a431 3
		    if (TRACE) {
		        fprintf(stderr,
			     "BuildCommand: Bad mailcap \"test\" clause: %s\n",
a432 1
		    }
d437 2
a438 5
			    if (TRACE) {
				fprintf(stderr,
			"BuildCommand: Too long mailcap \"test\" clause,\n");
				fprintf(stderr,
					"              ignoring: %s%s...\n",
a439 1
			    }
d448 1
a448 2
		    if (TRACE) {
			fprintf(stderr,
a450 1
		    }
d460 2
a461 5
	    if (TRACE) {
		fprintf(stderr,
			"BuildCommand: Too long mailcap \"test\" clause,\n");
		fprintf(stderr,
			"              ignoring: %s...\n",
a462 1
	    }
d470 48
d522 1
a522 2
    char *cmd, TmpFileName[TMPFILE_NAME_SIZE];
    char *cp = NULL;
d535 3
a537 6
	if (TRACE)
	    fprintf(stderr,
		    "PassesTest: Testing for XWINDOWS environment.\n");
    	if ((cp = getenv(DISPLAY)) != NULL && *cp != '\0') {
	    if (TRACE)
	        fprintf(stderr,"PassesTest: Test passed!\n");
d540 1
a540 2
	    if (TRACE)
	        fprintf(stderr,"PassesTest: Test failed!\n");
d546 3
a548 6
	if (TRACE)
	    fprintf(stderr,
		    "PassesTest: Testing for NON_XWINDOWS environment.\n");
    	if (!((cp = getenv(DISPLAY)) != NULL && *cp != '\0')) {
	    if (TRACE)
	        fprintf(stderr,"PassesTest: Test passed!\n");
d551 1
a551 2
	    if (TRACE)
	        fprintf(stderr,"PassesTest: Test failed!\n");
d561 2
a562 5
	if (TRACE) {
	    fprintf(stderr,
		    "PassesTest: Testing for LYNX environment.\n");
	    fprintf(stderr,"PassesTest: Test passed!\n");
	}
d570 2
a571 5
	if (TRACE) {
	    fprintf(stderr,
		    "PassesTest: Testing for non-LYNX environment.\n");
	    fprintf(stderr,"PassesTest: Test failed!\n");
	}
d575 26
a600 15
    /*
     *  Build the command and execute it.
     */
    tempname(TmpFileName, NEW_FILE);
    cmd = (char *)malloc(1024);
    if (!cmd)
	ExitWithError("Out of memory");
    BuildCommand(&cmd, 1024,
		 mc->testcommand,
		 TmpFileName,
		 strlen(TmpFileName));
    if (TRACE)
	fprintf(stderr,"PassesTest: Executing test command: %s\n", cmd);
    result = system(cmd);
    FREE(cmd);
d608 5
a612 4
    if (TRACE && result)
	fprintf(stderr,"PassesTest: Test failed!\n");
    else if (TRACE)
	fprintf(stderr,"PassesTest: Test passed!\n");
d623 1
a623 3
    if (TRACE)
	fprintf(stderr,
		"ProcessMailcapFile: Loading file '%s'.\n",
d626 1
a626 3
	if (TRACE)
	    fprintf(stderr,
		"ProcessMailcapFile: Could not open '%s'.\n",
d635 1
d643 2
a644 13
	fprintf(stderr, "metamail: %s\n", txt);
#ifndef NOSIGHUP
    (void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
    (void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
    (void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
    if (no_suspend)
	(void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
    exit(-1);
d648 1
d653 19
a671 1
  return ProcessMailcapFile(fn);
d696 1
a696 3
    if (TRACE)
	fprintf(stderr,
		"HTFileInit: Loading default (HTInit) extension maps.\n");
d704 1
a704 1
     *  define these extentions for exec scripts.
d751 2
d899 1
d912 2
a913 7
	char buffer[256];
#ifdef VMS
	sprintf(buffer, "sys$login:%s", personal_extension_map);
#else
	sprintf(buffer, "%s/%s", (Home_Dir() ? Home_Dir() : ""),
				  personal_extension_map);
#endif /* VMS */
d987 3
a989 1
    char l[MAX_STRING_LEN],w[MAX_STRING_LEN],*ct;
d991 1
a991 1
    int x, count = 0;
d993 1
a993 3
    if (TRACE)
	fprintf(stderr,
		"HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn);
d996 2
a997 4
	if (TRACE)
	    fprintf(stderr,
		    "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn);
	    return count;
d1000 3
a1002 3
    while (!(HTGetLine(l,MAX_STRING_LEN,f))) {
	HTGetWord(w, l, ' ', '\t');
	if (l[0] == '\0' || w[0] == '#')
d1004 1
a1004 1
	ct = (char *)malloc(sizeof(char) * (strlen(w) + 1));
d1007 8
a1014 9
	strcpy(ct,w);
	for (x = 0; ct[x]; x++)
	    ct[x] = TOLOWER(ct[x]);

	while(l[0]) {
	    HTGetWord(w, l, ' ', '\t');
	    if (w[0] && (w[0] != ' ')) {
		char *ext = (char *)malloc(sizeof(char) * (strlen(w)+1+1));
	        if (!ct)
d1017 4
a1020 9
		for (x = 0; w[x]; x++)
		    ext[x+1] = TOLOWER(w[x]);
		ext[0] = '.';
		ext[strlen(w)+1] = '\0';

		if (TRACE) {
		    fprintf (stderr,
			     "SETTING SUFFIX '%s' to '%s'.\n", ext, ct);
		}
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
