head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.08;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.57;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.57;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYForms.c,v 1.111 2013/12/07 13:46:58 tom Exp $ */
#include <HTUtils.h>
#include <HTCJK.h>
#include <HTTP.h>
#include <HTAlert.h>
#include <LYCurses.h>
#include <GridText.h>
#include <LYCharSets.h>
#include <UCAux.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYKeymap.h>
#include <LYClean.h>

#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#endif

#if defined(VMS) && !defined(USE_SLANG)
#define RepaintKey() 12		/* CTRL-L for repaint */
#else
#define RepaintKey() ((!enable_scrollback) ? 23 : 12)	/* CTRL-W or CTRL-L */
#endif /* VMS && !USE_SLANG */

static int form_getstr(int cur,
		       int use_last_tfpos,
		       int redraw_only);

/*
 * Returns an array of pointers to the given list
 */
static char **options_list(OptionType * opt_ptr)
{
    char **result = 0;
    size_t len;
    int pass;
    OptionType *tmp_ptr;

    for (pass = 0; pass < 2; pass++) {
	for (tmp_ptr = opt_ptr, len = 0; tmp_ptr != 0; tmp_ptr = tmp_ptr->next) {
	    if (pass != 0)
		result[len] = tmp_ptr->name;
	    len++;
	}
	if (pass == 0) {
	    len++;
	    result = typecallocn(char *, len);

	    if (result == 0)
		outofmem(__FILE__, "options_list");
	} else {
	    result[len] = 0;
	}
    }

    return result;
}

int change_form_link_ex(int cur,
			DocInfo *newdoc,
			BOOLEAN *refresh_screen,
			int use_last_tfpos,
			int immediate_submit,
			int redraw_only)
{
    FormInfo *form = links[cur].l_form;
    char *link_name;
    char *link_value;
    int newdoc_changed = 0;
    int c = DO_NOTHING;
    int title_adjust = (no_title ? -TITLE_LINES : 0);
    char **my_data = 0;

    /*
     * If there is no form to perform action on, don't do anything.
     */
    if (form == NULL) {
	return (c);
    }
    link_name = form->name;
    link_value = form->value;
    my_data = options_list(form->select_list);

    /*
     * Move to the link position.
     */
    LYmove(links[cur].ly + title_adjust, links[cur].lx);

    switch (form->type) {
    case F_CHECKBOX_TYPE:
	if (FormIsReadonly(form))
	    break;
	LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	form->num_value = !form->num_value;
	break;

    case F_OPTION_LIST_TYPE:
	if (form->select_list == 0) {
	    HTAlert(BAD_HTML_NO_POPUP);
	    c = DO_NOTHING;
	    break;
	}

	if (FormIsReadonly(form)) {
	    (void) LYhandlePopupList(form->num_value,
				     links[cur].ly,
				     links[cur].lx,
				     (STRING2PTR) my_data,
				     form->size,
				     form->size_l,
				     FormIsReadonly(form),
				     FALSE);
	    c = RepaintKey();
	    break;
	}
	form->num_value = LYhandlePopupList(form->num_value,
					    links[cur].ly,
					    links[cur].lx,
					    (STRING2PTR) my_data,
					    form->size,
					    form->size_l,
					    FormIsReadonly(form),
					    FALSE);
	{
	    OptionType *opt_ptr = form->select_list;
	    int i;

	    for (i = 0; i < form->num_value; i++, opt_ptr = opt_ptr->next) ;	/* null body */
	    /*
	     * Set the name.
	     */
	    form->value = opt_ptr->name;
	    /*
	     * Set the value.
	     */
	    form->cp_submit_value = opt_ptr->cp_submit_value;
	    /*
	     * Set charset in which we have the submit value.  - kw
	     */
	    form->value_cs = opt_ptr->value_cs;
	}
	c = RepaintKey();
	break;

    case F_RADIO_TYPE:
	if (FormIsReadonly(form))
	    break;
	/*
	 * Radio buttons must have one and only one down at a time!
	 */
	if (form->num_value) {
	    if (user_mode == NOVICE_MODE) {
		HTUserMsg(NEED_CHECKED_RADIO_BUTTON);
	    }
	} else {
	    int i;

	    /*
	     * Run though list of the links on the screen and unselect any that
	     * are selected.  :)
	     */
	    lynx_start_radio_color();
	    for (i = 0; i < nlinks; i++) {
		if (links[i].type == WWW_FORM_LINK_TYPE
		    && links[i].l_form->type == F_RADIO_TYPE
		    && links[i].l_form->number == form->number
		/*
		 * If it has the same name and its on...
		 */
		    && !strcmp(links[i].l_form->name, form->name)
		    && links[i].l_form->num_value) {
		    LYmove(links[i].ly, links[i].lx);
		    LYaddstr(unchecked_radio);
		    LYSetHilite(i, unchecked_radio);
		}
	    }
	    lynx_stop_radio_color();
	    /*
	     * Will unselect other button and select this one.
	     */
	    HText_activateRadioButton(form);
	    /*
	     * Now highlight this one.
	     */
	    LYSetHilite(cur, checked_radio);
	}
	break;

    case F_FILE_TYPE:
    case F_TEXT_TYPE:
    case F_TEXTAREA_TYPE:
    case F_PASSWORD_TYPE:
	c = form_getstr(cur, use_last_tfpos, redraw_only);
	LYSetHilite(cur, ((form->type == F_PASSWORD_TYPE)
			  ? STARS(LYstrCells(form->value))
			  : form->value));
	break;

    case F_RESET_TYPE:
	if (FormIsReadonly(form))
	    break;
	HText_ResetForm(form);
	*refresh_screen = TRUE;
	break;

    case F_TEXT_SUBMIT_TYPE:
	if (redraw_only) {
	    c = form_getstr(cur, use_last_tfpos, TRUE);
	    break;
	}
	if (!immediate_submit)
	    c = form_getstr(cur, use_last_tfpos, FALSE);
	if (FormIsReadonly(form) &&
	    (c == '\r' || c == '\n' || immediate_submit)) {
	    if (peek_mouse_link() >= 0)
		c = LAC_TO_LKC0(LYK_ACTIVATE);
	    else
		c = '\t';
	    break;
	}
	/*
	 * If immediate_submit is set, we didn't enter the line editor above,
	 * and will now try to call HText_SubmitForm() directly.  If
	 * immediate_submit is not set, c is the lynxkeycode returned from line
	 * editing.  Then if c indicates that a key was pressed that means we
	 * should submit, but with some extra considerations (i.e.  NOCACHE,
	 * DOWNLOAD, different from simple Enter), or if we should act on some
	 * *other* link selected with the mouse, we'll just return c and leave
	 * it to mainloop() to do the right thing; if everything checks out, it
	 * should call this function again, with immediate_submit set.
	 *
	 * If c indicates that line editing ended with Enter, we still defer to
	 * mainloop() for further checking if the submit action URL could
	 * require more checks than we do here.  Only in the remaining cases do
	 * we proceed to call HText_SubmitForm() directly before returning.  -
	 * kw
	 */
	if (immediate_submit ||
	    ((c == '\r' ||
	      c == '\n' ||
	      c == LAC_TO_LKC0(LYK_MOUSE_SUBMIT)) &&
	     peek_mouse_link() == -1)) {
	    LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
	    if (!immediate_submit && (c == '\r' || c == '\n') &&
		!HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY, YES)) {
		/* User was prompted and declined; if canceled with ^G
		 * let mainloop stay on this field, otherwise move on to
		 * the next field or link. - kw
		 */
		if (HTLastConfirmCancelled())
		    c = DO_NOTHING;
		else
		    c = LAC_TO_LKC(LYK_NEXT_LINK);
		break;
	    }
#endif
	    if (isEmpty(form->submit_action)) {
		HTUserMsg(NO_FORM_ACTION);
		c = DO_NOTHING;
		break;
	    } else if (form->submit_method == URL_MAIL_METHOD && no_mail) {
		HTAlert(FORM_MAILTO_DISALLOWED);
		c = DO_NOTHING;
		break;
	    } else if (!immediate_submit &&
		       ((no_file_url &&
			 isFILE_URL(form->submit_action)) ||
			!strncasecomp(form->submit_action, "lynx", 4))) {
		c = LAC_TO_LKC0(LYK_MOUSE_SUBMIT);
		break;
	    } else {
		if (form->no_cache &&
		    form->submit_method != URL_MAIL_METHOD) {
		    LYforce_no_cache = TRUE;
		    reloading = TRUE;
		}
		newdoc_changed =
		    HText_SubmitForm(form, newdoc, link_name, form->value);
	    }
	    if (form->submit_method == URL_MAIL_METHOD) {
		*refresh_screen = TRUE;
	    } else {
		/*
		 * Returns new document URL.
		 */
		newdoc->link = 0;
		newdoc->internal_link = FALSE;
	    }
	    c = DO_NOTHING;
	    break;
	} else {
	    LYSetHilite(cur, form->value);
	}
	break;

    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (FormIsReadonly(form))
	    break;
	if (form->no_cache &&
	    form->submit_method != URL_MAIL_METHOD) {
	    LYforce_no_cache = TRUE;
	    reloading = TRUE;
	}
	newdoc_changed =
	    HText_SubmitForm(form, newdoc, link_name, link_value);
	if (form->submit_method == URL_MAIL_METHOD)
	    *refresh_screen = TRUE;
	else {
	    /* returns new document URL */
	    newdoc->link = 0;
	    newdoc->internal_link = FALSE;
	}
	break;

    }

    if (newdoc_changed) {
	c = LKC_DONE;
    } else {
	/*
	 * These flags may have been set in mainloop, anticipating that a
	 * request will be submitted.  But if we haven't filled in newdoc, that
	 * won't actually be the case, so unset them.  - kw
	 */
	LYforce_no_cache = FALSE;
	reloading = FALSE;
    }
    FREE(my_data);
    return (c);
}

int change_form_link(int cur,
		     DocInfo *newdoc,
		     BOOLEAN *refresh_screen,
		     int use_last_tfpos,
		     int immediate_submit)
{
    /*pass all our args and FALSE as last arg */
    return change_form_link_ex(cur,
			       newdoc,
			       refresh_screen,
			       use_last_tfpos,
			       immediate_submit,
			       FALSE /*redraw_only */ );
}

static int LastTFPos = -1;	/* remember last text field position */

static void LYSetLastTFPos(int pos)
{
    LastTFPos = pos;
}

static int form_getstr(int cur,
		       int use_last_tfpos,
		       int redraw_only)
{
    FormInfo *form = links[cur].l_form;
    char *link_value = form->value;
    int ch;
    int far_col;
    int startcol, startline;
    int action, repeat;
    int last_xlkc = -1;

#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif

    FieldEditor MyEdit, *edit = &MyEdit;
    BOOLEAN Edited = FALSE;	/* Value might be updated? */

    /*
     * Get the initial position of the cursor.
     */
    LYGetYX(startline, startcol);
    if (startline < 0)
	startline = 0;
    if (startcol < 0)
	startcol = 0;
    if ((startcol + form->size) > LYcolLimit)
	far_col = LYcolLimit;
    else
	far_col = (startcol + form->size);

    /*
     * Make sure the form field value does not exceed our buffer.  - FM
     */
    if (form->maxlength != 0 &&
	strlen(form->value) > form->maxlength) {
	/*
	 * We can't fit the entire value into the editing buffer, so enter as
	 * much of the tail as fits.  - FM
	 */
	link_value += (strlen(form->value) - form->maxlength);
	if (!FormIsReadonly(form) &&
	    !(form->submit_method == URL_MAIL_METHOD && no_mail)) {
	    /*
	     * If we can edit it, report that we are using the tail.  - FM
	     */
	    HTUserMsg(FORM_VALUE_TOO_LONG);
	    show_formlink_statusline(form, redraw_only ? FOR_PANEL : FOR_INPUT);
	    LYmove(startline, startcol);
	}
    }

    /*
     * Print panned line
     */
    LYSetupEdit(edit, link_value, form->maxlength, (far_col - startcol));
    edit->efPadChar = '_';
    edit->efIsMasked = (BOOL) (form->type == F_PASSWORD_TYPE);
    if (use_last_tfpos &&
	LastTFPos >= 0 &&
	LastTFPos < (int) edit->efBufInUse) {
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
	if (redraw_only) {
	    if (!(edit->efBufInUse >= edit->efWide &&
		  LastTFPos >= edit->efWide - edit->efPanMargin)) {
		edit->efEditAt = LastTFPos;
		if (edit->efBufInUse >= edit->efWide)
		    textinput_redrawn = FALSE;
	    }
	} else
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
	    edit->efEditAt = LastTFPos;
#ifdef ENHANCED_LINEEDIT
	if (edit->efEditAt == 0)
	    /* Do not show the region. */
	    edit->efEditMark = -(int) (1 + edit->efBufInUse);
#endif
    }
    /* Try to prepare for setting position based on the last mouse event */
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (!redraw_only) {
	if (peek_mouse_levent()) {
	    if (!use_last_tfpos && !textinput_redrawn) {
		edit->efEditAt = 0;
	    }
	}
	textinput_redrawn = FALSE;
    }
#else
    if (peek_mouse_levent()) {
	if (!use_last_tfpos)
	    edit->efEditAt = 0;
    }
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
    LYRefreshEdit(edit);
    if (redraw_only) {
	LYFinishEdit(edit);
	return 0;		/*return value won't be analysed */
    }
#ifdef FEPCTRL
    fep_on();
#endif
    /*
     * And go for it!
     */
    for (;;) {
      again:
	repeat = -1;
	get_mouse_link();	/* Reset mouse_link. */

	ch = LYgetch_input();
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR)
#ifndef WIN_EX
	    && (EditBinding(ch) != LYE_AIX)
#endif
	    )
	    goto again;
#endif /* SUPPORT_MULTIBYTE_EDIT */
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    ch = LYCharINTERRUPT2;
	}
#endif /* VMS */

	action = 0;
#ifdef USE_MOUSE
#  if defined(NCURSES) || defined(PDCURSES)
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC))	/* already lynxactioncode? */
	    break;		/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
	if (ch == MOUSE_KEY) {	/* Need to process ourselves */
#if defined(PDCURSES)
	    int curx, cury;

	    request_mouse_pos();
	    LYGetYX(cury, curx);
	    if (MOUSE_Y_POS == cury) {
		repeat = MOUSE_X_POS - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = -repeat;
		} else
		    action = LYE_FORW;
	    }
#else
	    MEVENT event;
	    int curx, cury;

	    getmouse(&event);
	    LYGetYX(cury, curx);
	    if (event.y == cury) {
		repeat = event.x - curx;
		if (repeat < 0) {
		    action = LYE_BACK;
		    repeat = -repeat;
		} else
		    action = LYE_FORW;
	    }
#endif /* PDCURSES */
	    else {
		/* Mouse event passed to us as MOUSE_KEY, and apparently not on
		 * this field's line?  Something is not as it should be...
		 *
		 * A call to statusline() may have happened, possibly from
		 * within a mouse menu.  Let's at least make sure here that the
		 * cursor position gets restored.  - kw
		 */
		edit->efIsDirty = TRUE;
	    }
	} else
#  endif /* NCURSES || PDCURSES */
#endif /* USE_MOUSE */

	{
	    if (!(ch & LKC_ISLECLAC))
		ch |= edit->efInputMods;
	    edit->efInputMods = 0;
	    if (last_xlkc != -1) {
		if (ch == last_xlkc)
		    ch |= LKC_MOD3;
	    }
	}
	if (peek_mouse_link() != -1)
	    break;

	if (!action)
	    action = EditBinding(ch);
	if ((action & LYE_DF) && !(action & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    action &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}

	if (action == LYE_SETM1) {
	    /*
	     * Set flag for modifier 1.
	     */
	    edit->efInputMods |= LKC_MOD1;
	    continue;
	}
	if (action == LYE_SETM2) {
	    /*
	     * Set flag for modifier 2.
	     */
	    edit->efInputMods |= LKC_MOD2;
	    continue;
	}
	/*
	 * Filter out global navigation keys that should not be passed to line
	 * editor, and LYK_REFRESH.
	 */
	if (action == LYE_ENTER)
	    break;
	if (action == LYE_FORM_PASS)
	    break;
	if (action & LYE_FORM_LAC) {
	    ch = (action & LAC_MASK) | LKC_ISLAC;
	    break;
	}
	if (action == LYE_LKCMD) {
	    _statusline(ENTER_LYNX_COMMAND);
	    ch = LYgetch();
#ifdef VMS
	    if (HadVMSInterrupt) {
		HadVMSInterrupt = FALSE;
		ch = LYCharINTERRUPT2;
	    }
#endif /* VMS */
	    break;
	}
#ifdef CAN_CUT_AND_PASTE	/* 1998/10/01 (Thu) 19:19:22 */
	if (action == LYE_PASTE) {
	    unsigned char *s = (unsigned char *) get_clip_grab(), *e;
	    char *buf = NULL;
	    int len;

	    if (!s)
		break;
	    len = (int) strlen((const char *) s);
	    e = s + len;

	    if (len > 0) {
		unsigned char *e1 = s;

		while (e1 < e) {
		    if (*e1 < ' ') {	/* Stop here? */
			if (e1 > s)
			    LYEditInsert(edit, s, (int) (e1 - s), -1, TRUE);
			s = e1;
			if (*e1 == '\t') {	/* Replace by space */
			    LYEditInsert(edit, (unsigned const char *) " ", 1,
					 -1, TRUE);
			    s = ++e1;
			} else
			    break;
		    } else
			++e1;
		}
		if (e1 > s)
		    LYEditInsert(edit, s, (int) (e1 - s), -1, TRUE);
		while (e1 < e && *e1 == '\r')
		    e1++;
		if (e1 + 1 < e && *e1 == '\n')
		    StrAllocCopy(buf, (char *) e1 + 1);		/* Survive _release() */
		get_clip_release();
		_statusline(ENTER_TEXT_ARROWS_OR_TAB);
		if (strcmp(link_value, edit->efBuffer) != 0) {
		    Edited = TRUE;
		}
		if (buf) {
		    put_clip(buf);
		    FREE(buf);
		    ch = '\n';	/* Sometimes moves to the next line */
		    break;
		}
		LYRefreshEdit(edit);
	    } else {
		HTInfoMsg(gettext("Clipboard empty or Not text data."));
#ifdef FEPCTRL
		fep_off();
#endif
		continue;
	    }
	}
#endif
#ifndef WIN_EX
	if (action == LYE_AIX &&
	    (!IS_CJK_TTY && LYlowest_eightbit[current_char_set] > 0x97))
	    break;
#endif
	if (action == LYE_TAB) {
	    ch = (int) ('\t');
	    break;
	}
	if (action == LYE_ABORT) {
#ifdef FEPCTRL
	    fep_off();
#endif
	    LYFinishEdit(edit);
	    return (DO_NOTHING);
	}
	if (action == LYE_STOP) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    break;
#else
#ifdef ENHANCED_LINEEDIT
	    if (edit->efEditMark >= 0)
		/* Disable. */
		edit->efEditMark = -(int) (1 + edit->efBufInUse);
#endif
#endif
	}
	if (action == LYE_NOP && LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
	    break;
#ifdef SH_EX
/* ASATAKU emacskey hack 1997/08/26 (Tue) 09:19:23 */
	if (emacs_keys &&
	    (EditBinding(ch) == LYE_FORWW || EditBinding(ch) == LYE_BACKW))
	    goto breakfor;
/* ASATAKU emacskey hack */
#endif
	switch (ch) {
	default:
	    /* [ 1999/04/14 (Wed) 15:01:33 ]
	     * Left arrow in column 0 deserves special treatment here, else
	     * you can get trapped in a form without submit button!
	     */
	    if (action == LYE_BACK && edit->efEditAt == 0 && repeat == -1) {
		int c = YES;	/* Go back immediately if no changes */

		if (textfield_prompt_at_left_edge) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		} else if (strcmp(edit->efBuffer, link_value)) {
		    c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		}
		if (c == YES) {
#ifdef FEPCTRL
		    fep_off();
#endif
		    LYFinishEdit(edit);
		    return (ch);
		} else {
		    if (FormIsReadonly(form))
			_statusline(ARROWS_OR_TAB_TO_MOVE);
		    else
			_statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
	    }
	    if (FormIsReadonly(form)) {
		/*
		 * Allow actions that don't modify the contents even in
		 * disabled form fields, so the user can scroll through the
		 * line for reading if necessary.  - kw
		 */
		switch (action) {
		case LYE_BOL:
		case LYE_EOL:
		case LYE_FORW:
		case LYE_FORW_RL:
		case LYE_BACK:
		case LYE_BACK_LL:
		case LYE_FORWW:
		case LYE_BACKW:
#ifdef EXP_KEYBOARD_LAYOUT
		case LYE_SWMAP:
#endif
#ifdef ENHANCED_LINEEDIT
		case LYE_SETMARK:
		case LYE_XPMARK:
#endif
		    break;
		default:
		    goto again;
		}
	    }
	    /*
	     * Make sure the statusline uses editmode help.
	     */
	    if (repeat < 0)
		repeat = 1;
	    while (repeat--) {
		int rc = LYDoEdit(edit, ch, action & ~LYE_DF, TRUE);

		if (rc < 0) {
		    ch = -rc;
		    /* FORW_RL and BACK_LL may require special attention.
		       BACK_LL wanted to switch to the previous link on
		       the same line.  However, if there is no such link,
		       then we would either disactivate the form
		       (with -tna), or will reenter the form, thus we jump
		       to the end of the line; both are counterintuitive.
		       Unfortunately, we do not have access to curdoc.link,
		       so we deduce it ourselves.  We don't have the info
		       to do it inside LYLineEdit().
		       This should work for prompts too.  */
		    switch (action) {
		    case LYE_BACK_LL:
			if (cur > 0
			    && links[cur - 1].ly == links[cur].ly) {
			    goto breakfor;
			}
			break;
		    case LYE_FORW_RL:
			if (cur >= 0
			    && cur < nlinks - 1
			    && links[cur + 1].ly == links[cur].ly) {
			    goto breakfor;
			}
			break;
		    default:
			goto breakfor;
		    }
		}
#ifdef SUPPORT_MULTIBYTE_EDIT
		if (rc == 0) {
		    if (IS_CJK_TTY && (0x80 <= ch)
			&& (ch <= 0xfe) && refresh_mb)
			refresh_mb = FALSE;
		    else
			refresh_mb = TRUE;
		} else {
		    if (!refresh_mb) {
			LYDoEdit(edit, 0, LYE_DELP, TRUE);
		    }
		}
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    }
	    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
	    if (strcmp(link_value, edit->efBuffer)) {
		Edited = TRUE;
	    }
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (refresh_mb)
#endif
		LYRefreshEdit(edit);
	    LYSetLastTFPos(edit->efEditAt);
	}
    }
  breakfor:
    if (Edited) {

	/*
	 * Load the new value.
	 */
	if (link_value == form->value) {
	    /*
	     * The previous value did fit in the line buffer, so replace it
	     * with the new value.  - FM
	     */
	    StrAllocCopy(form->value, edit->efBuffer);
	} else {
	    int old_len = (int) strlen(form->value);
	    int new_len = (int) strlen(link_value);

	    /*
	     * Combine the modified tail with the unmodified head.  - FM
	     */
	    form->value[(old_len > new_len) ? (old_len - new_len) : 0] = '\0';
	    StrAllocCat(form->value, edit->efBuffer);
	    HTUserMsg(FORM_TAIL_COMBINED_WITH_HEAD);
	}

	/* 2.8.4pre.3 - most browsers appear to preserve trailing spaces -VH */
	/*
	 * Remove trailing spaces
	 *
	 * Do we really need to do that here?  Trailing spaces will only be
	 * there if user keyed them in.  Rather rude to throw away their hard
	 * earned spaces.  Better deal with trailing spaces when submitting the
	 * form????
	 */
	if (LYtrimInputFields) {
	    LYTrimTrailing(form->value);
	}

	/*
	 * If the field has been changed, assume that it is now in current
	 * display character set, even if for some reason it wasn't!  Hopefully
	 * a user will only submit the form if the non-ASCII characters are
	 * displayed correctly, which means (assuming that the display
	 * character set has been set truthfully) the user confirms by changing
	 * the field that the character encoding is right.  - kw
	 */
	if (non_empty(form->value))
	    form->value_cs = current_char_set;
    }
#ifdef FEPCTRL
    fep_off();
#endif
    LYFinishEdit(edit);
    return (ch);
}

/*
 * Display statusline info tailored for the current form field.
 */
void show_formlink_statusline(const FormInfo * form,
			      int for_what)
{
    switch (form->type) {
    case F_PASSWORD_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_PASSWORD_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	else
#endif
	    statusline(FORM_LINK_PASSWORD_MESSAGE);
	break;
    case F_OPTION_LIST_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
	else
	    statusline(FORM_LINK_OPTION_LIST_MESSAGE);
	break;
    case F_CHECKBOX_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_CHECKBOX_UNM_MSG);
	else
	    statusline(FORM_LINK_CHECKBOX_MESSAGE);
	break;
    case F_RADIO_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_RADIO_UNM_MSG);
	else
	    statusline(FORM_LINK_RADIO_MESSAGE);
	break;
    case F_TEXT_SUBMIT_TYPE:
	if (FormIsReadonly(form)) {
	    statusline(FORM_LINK_TEXT_SUBMIT_UNM_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail)
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_DIS_MSG);
	    else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
	    else
#endif
		statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
	} else if (form->no_cache) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    if (for_what == FOR_PANEL)
		statusline(FORM_TEXT_RESUBMIT_MESSAGE_INA);
	    else
#endif
		statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
	} else {
	    char *submit_str = NULL;
	    char *xkey_info = key_for_func_ext(LYK_NOCACHE, for_what);

	    if (non_empty(xkey_info)) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_TEXT_SUBMIT_MESSAGE_INA_X,
			       xkey_info);
		else
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXT_SUBMIT_MESSAGE_X,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE_INA);
		else
#endif
		    statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
	    }
	    FREE(xkey_info);
	}
	break;
    case F_SUBMIT_TYPE:
    case F_IMAGE_SUBMIT_TYPE:
	if (FormIsReadonly(form)) {
	    statusline(FORM_LINK_SUBMIT_DIS_MSG);
	} else if (form->submit_method ==
		   URL_MAIL_METHOD) {
	    if (no_mail) {
		statusline(FORM_LINK_SUBMIT_MAILTO_DIS_MSG);
	    } else {
		if (user_mode == ADVANCED_MODE) {
		    char *submit_str = NULL;

		    StrAllocCopy(submit_str, FORM_LINK_SUBMIT_MAILTO_PREFIX);
		    StrAllocCat(submit_str, form->submit_action);
		    statusline(submit_str);
		    FREE(submit_str);
		} else {
		    statusline(FORM_LINK_SUBMIT_MAILTO_MSG);
		}
	    }
	} else if (form->no_cache) {
	    if (user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_RESUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_RESUBMIT_MESSAGE);
	    }
	} else {
	    if (user_mode == ADVANCED_MODE) {
		char *submit_str = NULL;

		StrAllocCopy(submit_str, FORM_LINK_SUBMIT_PREFIX);
		StrAllocCat(submit_str, form->submit_action);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
		statusline(FORM_LINK_SUBMIT_MESSAGE);
	    }
	}
	break;
    case F_RESET_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_RESET_DIS_MSG);
	else
	    statusline(FORM_LINK_RESET_MESSAGE);
	break;
    case F_BUTTON_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_BUTTON_DIS_MSG);
	else
	    statusline(FORM_LINK_BUTTON_MESSAGE);
	break;
    case F_FILE_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_FILE_UNM_MSG);
	else
	    statusline(FORM_LINK_FILE_MESSAGE);
	break;
    case F_TEXT_TYPE:
	if (FormIsReadonly(form))
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	else
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if (for_what == FOR_PANEL)
	    statusline(FORM_LINK_TEXT_MESSAGE_INA);
	else
#endif
	    statusline(FORM_LINK_TEXT_MESSAGE);
	break;
    case F_TEXTAREA_TYPE:
	if (FormIsReadonly(form)) {
	    statusline(FORM_LINK_TEXT_UNM_MSG);
	} else {
	    char *submit_str = NULL;
	    char *xkey_info = NULL;

	    if (!no_editor && non_empty(editor)) {
		xkey_info = key_for_func_ext(LYK_EDITTEXTAREA, for_what);
#ifdef TEXTAREA_AUTOEXTEDIT
		if (!xkey_info)
		    xkey_info = key_for_func_ext(LYK_DWIMEDIT, for_what);
#endif
	    }
	    if (non_empty(xkey_info)) {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_INA_E,
			       xkey_info);
		else
#endif
		    HTSprintf0(&submit_str, FORM_LINK_TEXTAREA_MESSAGE_E,
			       xkey_info);
		statusline(submit_str);
		FREE(submit_str);
	    } else {
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
		if (for_what == FOR_PANEL)
		    statusline(FORM_LINK_TEXTAREA_MESSAGE_INA);
		else
#endif
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
	    }
	    FREE(xkey_info);
	}
	break;
    }
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYForms.c,v 1.81 2009/05/28 23:10:06 tom Exp $ */
d24 1
a24 1
#define CTRL_W_HACK DO_NOTHING
d26 1
a26 1
#define CTRL_W_HACK 23		/* CTRL-W refresh without clearok */
d30 2
a31 2
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only);
d52 3
d66 3
a68 3
			BOOLEAN use_last_tfpos,
			BOOLEAN immediate_submit,
			BOOLEAN redraw_only)
d71 2
a72 2
    char *link_name = form->name;
    char *link_value = form->value;
a74 1
    int OrigNumValue;
d84 2
d95 1
a95 1
	if (form->disabled == YES)
d108 10
a117 17
	if (form->disabled == YES) {
	    int dummy;

	    dummy = LYhandlePopupList(form->num_value,
				      links[cur].ly,
				      links[cur].lx,
				      (const char **) my_data,
				      form->size,
				      form->size_l,
				      form->disabled,
				      FALSE);
#if CTRL_W_HACK != DO_NOTHING
	    if (!enable_scrollback)
		c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
	    else
#endif
		c = 12;		/* CTRL-L for repaint */
a119 1
	OrigNumValue = form->num_value;
d123 1
a123 1
					    (const char **) my_data,
d126 1
a126 1
					    form->disabled,
d146 1
a146 6
#if CTRL_W_HACK != DO_NOTHING
	if (!enable_scrollback)
	    c = CTRL_W_HACK;	/* CTRL-W refresh without clearok */
	else
#endif
	    c = 12;		/* CTRL-L for repaint */
d150 1
a150 1
	if (form->disabled == YES)
d204 1
a204 1
	if (form->disabled == YES)
d217 1
a217 1
	if (form->disabled == YES &&
d243 3
a245 1
	    ((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
d250 1
a250 1
		!HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
d262 1
a262 1
	    if (!form->submit_action || *form->submit_action == '\0') {
d274 1
a274 1
		c = LAC_TO_LKC0(LYK_SUBMIT);
d303 1
a303 1
	if (form->disabled == YES)
d341 2
a342 2
		     BOOLEAN use_last_tfpos,
		     BOOLEAN immediate_submit)
d361 2
a362 2
		       BOOLEAN use_last_tfpos,
		       BOOLEAN redraw_only)
d365 1
a365 1
    char *value = form->value;
a367 1
    unsigned max_length;
a368 1
    BOOL HaveMaxlength = FALSE;
d376 1
a376 1
    EditFieldData MyEdit;
d383 4
d395 2
a396 5
    max_length = ((form->maxlength > 0 &&
		   form->maxlength < sizeof(MyEdit.buffer))
		  ? form->maxlength
		  : (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > max_length) {
d401 2
a402 2
	value += (strlen(form->value) - max_length);
	if (!form->disabled &&
d416 6
a421 4
    LYSetupEdit(&MyEdit, value, (int) max_length, (far_col - startcol));
    MyEdit.pad = '_';
    MyEdit.hidden = (BOOL) (form->type == F_PASSWORD_TYPE);
    if (use_last_tfpos && LastTFPos >= 0 && LastTFPos < MyEdit.strlen) {
d424 4
a427 4
	    if (!(MyEdit.strlen >= MyEdit.dspwdth &&
		  LastTFPos >= MyEdit.dspwdth - MyEdit.margin)) {
		MyEdit.pos = LastTFPos;
		if (MyEdit.strlen >= MyEdit.dspwdth)
d432 1
a432 1
	    MyEdit.pos = LastTFPos;
d434 3
a436 2
	if (MyEdit.pos == 0)
	    MyEdit.mark = -1 - MyEdit.strlen;	/* Do not show the region. */
d444 1
a444 1
		MyEdit.pos = 0;
d452 1
a452 1
	    MyEdit.pos = 0;
d455 1
a455 1
    LYRefreshEdit(&MyEdit);
d457 1
d460 3
a462 1

d530 1
a530 1
		MyEdit.dirty = TRUE;
a531 1
	    last_xlkc = -1;
d533 1
a533 1
#  endif			/* NCURSES || PDCURSES */
d538 2
a539 2
		ch |= MyEdit.current_modifiers;
	    MyEdit.current_modifiers = 0;
a542 1
		last_xlkc = -1;	/* consumed */
d561 1
a561 1
	    MyEdit.current_modifiers |= LKC_MOD1;
d568 1
a568 1
	    MyEdit.current_modifiers |= LKC_MOD2;
d611 1
a611 1
			    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
d614 1
a614 1
			    LYEditInsert(&MyEdit, (unsigned char *) " ", 1,
d623 1
a623 1
		    LYEditInsert(&MyEdit, s, e1 - s, -1, TRUE);
d629 2
a630 8
		if (MyEdit.strlen >= (int) max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < (int) max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer) != 0) {
d639 1
a639 1
		LYRefreshEdit(&MyEdit);
d642 3
d659 4
d671 3
a673 2
	    if (MyEdit.mark >= 0)
		MyEdit.mark = -1 - MyEdit.strlen;	/* Disable. */
d692 1
a692 1
	    if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
d697 1
a697 1
		} else if (strcmp(MyEdit.buffer, value)) {
d701 4
d707 1
a707 1
		    if (form->disabled == YES)
d713 1
a713 1
	    if (form->disabled == YES) {
d746 1
a746 1
		int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);
d760 15
a774 10
		    if ((action != LYE_BACK_LL && action != LYE_FORW_RL)
			|| (cur >= 0
			    && cur < nlinks
			    && (action == LYE_FORW_RL
				? cur < nlinks - 1
				: cur > 0)
			    && links[cur + ((action == LYE_FORW_RL)
					    ? 1
					    : -1)].ly
			    == links[cur].ly))
d776 1
d787 1
a787 1
			LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
d792 2
a793 8
	    if (MyEdit.strlen >= (int) max_length) {
		HaveMaxlength = TRUE;
	    } else if (HaveMaxlength &&
		       MyEdit.strlen < (int) max_length) {
		HaveMaxlength = FALSE;
		_statusline(ENTER_TEXT_ARROWS_OR_TAB);
	    }
	    if (strcmp(value, MyEdit.buffer)) {
d799 2
a800 2
		LYRefreshEdit(&MyEdit);
	    LYSetLastTFPos(MyEdit.pos);
d809 1
a809 1
	if (value == form->value) {
d814 1
a814 1
	    StrAllocCopy(form->value, MyEdit.buffer);
d817 1
a817 1
	    int new_len = (int) strlen(value);
d823 1
a823 1
	    StrAllocCat(form->value, MyEdit.buffer);
d851 4
d866 1
a866 1
	if (form->disabled == YES)
d877 1
a877 1
	if (form->disabled == YES)
d883 1
a883 1
	if (form->disabled == YES)
d889 1
a889 1
	if (form->disabled == YES)
d895 1
a895 1
	if (form->disabled == YES) {
d943 1
a943 1
	if (form->disabled == YES) {
d986 1
a986 1
	if (form->disabled == YES)
d992 1
a992 1
	if (form->disabled == YES)
d998 1
a998 1
	if (form->disabled == YES)
d1004 1
a1004 1
	if (form->disabled == YES)
d1015 1
a1015 1
	if (form->disabled == YES) {
d1021 2
a1022 2
	    if (!no_editor && editor && editor) {
		xkey_info = key_for_func_ext(LYK_EDIT_TEXTAREA, for_what);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
a113 1
				      FALSE,
a130 1
					    FALSE,
d207 3
a209 3
	LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
		    ? STARS(strlen(form->value))
		    : form->value);
d375 1
a375 1
    int max_length;
d401 4
a404 4
		   form->maxlength < sizeof(MyEdit.buffer)) ?
		  form->maxlength :
		  (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > (size_t) max_length) {
d424 1
a424 1
    LYSetupEdit(&MyEdit, value, max_length, (far_col - startcol));
d461 1
a461 1
    if (redraw_only)
d463 1
d606 1
a606 1
	    len = strlen((const char *) s);
d633 1
a633 1
		if (MyEdit.strlen >= max_length) {
d636 1
a636 1
			   MyEdit.strlen < max_length) {
d658 1
a658 1
	    (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97))
d691 1
a691 1
	     * Left arrrow in column 0 deserves special treatment here, else
d772 1
a772 1
		    if (HTCJK != NOCJK && (0x80 <= ch)
d784 1
a784 1
	    if (MyEdit.strlen >= max_length) {
d787 1
a787 1
		       MyEdit.strlen < max_length) {
a802 1
	char *p;
d814 3
d820 1
a820 1
	    form->value[(strlen(form->value) - strlen(value))] = '\0';
d835 1
a835 4
	    p = &(form->value[strlen(form->value)]);
	    while ((p != form->value) && (p[-1] == ' '))
		p--;
	    *p = '\0';
d984 6
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d25 1
a25 1
#define CTRL_W_HACK 23  /* CTRL-W refresh without clearok */
d28 3
a30 4
PRIVATE int form_getstr PARAMS((
	int		cur,
	BOOLEAN		use_last_tfpos,
	BOOLEAN		redraw_only));
d35 1
a35 2
PRIVATE char ** options_list ARGS1(
	OptionType *,	opt_ptr)
d59 6
a64 7
PUBLIC int change_form_link_ex ARGS6(
	int,		cur,
	DocInfo *,	newdoc,
	BOOLEAN *,	refresh_screen,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit,
	BOOLEAN,	redraw_only)
d72 1
d76 1
a76 1
     *  If there is no form to perform action on, don't do anything.
d79 1
a79 1
	return(c);
d84 1
a84 1
     *  Move to the link position.
d86 1
a86 1
    LYmove(links[cur].ly, links[cur].lx);
d88 12
a99 6
    switch(form->type) {
	case F_CHECKBOX_TYPE:
	    if (form->disabled == YES)
		break;
	    LYSetHilite(cur, form->num_value ? unchecked_box : checked_box);
	    form->num_value = ! form->num_value;
d101 1
d103 2
a104 6
	case F_OPTION_LIST_TYPE:
	    if (form->select_list == 0) {
		HTAlert(BAD_HTML_NO_POPUP);
		c = DO_NOTHING;
		break;
	    }
d106 9
a114 47
	    if (form->disabled == YES) {
		int dummy;
		dummy = LYhandlePopupList(form->num_value,
					  links[cur].ly,
					  links[cur].lx,
					  (CONST char **)my_data,
					  form->size,
					  form->size_l,
					  form->disabled,
					  FALSE,
					  FALSE);
#if CTRL_W_HACK != DO_NOTHING
		if (!enable_scrollback)
		    c = CTRL_W_HACK;  /* CTRL-W refresh without clearok */
		else
#endif
		    c = 12;  /* CTRL-L for repaint */
		break;
	    }
	    OrigNumValue = form->num_value;
	    form->num_value = LYhandlePopupList(form->num_value,
						links[cur].ly,
						links[cur].lx,
						(CONST char **)my_data,
						form->size,
						form->size_l,
						form->disabled,
						FALSE,
						FALSE);
	    {
		OptionType * opt_ptr = form->select_list;
		int i;
		for (i = 0; i < form->num_value; i++, opt_ptr = opt_ptr->next)
		    ; /* null body */
		/*
		 *  Set the name.
		 */
		form->value = opt_ptr->name;
		/*
		 *  Set the value.
		 */
		form->cp_submit_value = opt_ptr->cp_submit_value;
		 /*
		  *  Set charset in which we have the submit value. - kw
		  */
		form->value_cs = opt_ptr->value_cs;
	    }
d117 1
a117 1
		c = CTRL_W_HACK;	 /* CTRL-W refresh without clearok */
d120 1
a120 1
		c = 12;	 /* CTRL-L for repaint */
d122 36
d159 8
a166 8
	case F_RADIO_TYPE:
	    if (form->disabled == YES)
		break;
		/*
		 *  Radio buttons must have one and
		 *  only one down at a time!
		 */
	    if (form->num_value) {
d168 13
a180 2
	    } else {
		int i;
d182 1
a182 2
		 *  Run though list of the links on the screen and
		 *  unselect any that are selected. :)
d184 5
a188 14
		lynx_start_radio_color ();
		for (i = 0; i < nlinks; i++) {
		    if (links[i].type == WWW_FORM_LINK_TYPE
		     && links[i].l_form->type == F_RADIO_TYPE
		     && links[i].l_form->number == form->number
			/*
			 *  If it has the same name and its on...
			 */
		     && !strcmp(links[i].l_form->name, form->name)
		     && links[i].l_form->num_value) {
			LYmove(links[i].ly, links[i].lx);
			LYaddstr(unchecked_radio);
			LYSetHilite(i, unchecked_radio);
		    }
a189 9
		lynx_stop_radio_color ();
		/*
		 *  Will unselect other button and select this one.
		 */
		HText_activateRadioButton(form);
		/*
		 *  Now highlight this one.
		 */
		LYSetHilite(cur, checked_radio);
d191 24
d216 3
d220 3
a222 8
	case F_FILE_TYPE:
	case F_TEXT_TYPE:
	case F_TEXTAREA_TYPE:
	case F_PASSWORD_TYPE:
	    c = form_getstr(cur, use_last_tfpos, redraw_only);
	    LYSetHilite(cur, (form->type == F_PASSWORD_TYPE)
			? STARS(strlen(form->value))
			: form->value);
d224 9
a232 6

	case F_RESET_TYPE:
	    if (form->disabled == YES)
		break;
	    HText_ResetForm(form);
	    *refresh_screen = TRUE;
d234 31
a264 12

	case F_TEXT_SUBMIT_TYPE:
	    if (redraw_only) {
		c = form_getstr(cur, use_last_tfpos, TRUE);
		break;
	    }
	    if (!immediate_submit)
		c = form_getstr(cur, use_last_tfpos, FALSE);
	    if (form->disabled == YES &&
		(c == '\r' || c == '\n' || immediate_submit)) {
		if (peek_mouse_link() >= 0)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
d266 1
a266 1
		    c = '\t';
a268 34
	    /*
	     *  If immediate_submit is set, we didn't enter the line editor
	     *  above, and will now try to call HText_SubmitForm() directly.
	     *  If immediate_submit is not set, c is the lynxkeycode returned
	     *  from line editing.   Then if c indicates that a key was pressed
	     *  that means we should submit, but with some extra considerations
	     *  (i.e. NOCACHE, DOWNLOAD, different from simple Enter), or if
	     *  we should act on some *other* link selected with the mouse,
	     *  we'll just return c and leave it to mainloop() to do the
	     *  right thing; if everything checks out, it should call this
	     *  function again, with immediate_submit set.
	     *  If c indicates that line editing ended with Enter, we still
	     *  defer to mainloop() for further checking if the submit
	     *  action URL could require more checks than we do here.
	     *  Only in the remaining cases do we proceed to call
	     *  HText_SubmitForm() directly before returning. - kw
	     */
	    if (immediate_submit ||
		((c == '\r' || c == '\n' || c == LAC_TO_LKC0(LYK_SUBMIT)) &&
		 peek_mouse_link() == -1)) {
		LYSetHilite(cur, form->value);
#ifdef TEXT_SUBMIT_CONFIRM_WANTED
		if (!immediate_submit && (c == '\r' || c == '\n') &&
		    !HTConfirmDefault(NO_SUBMIT_BUTTON_QUERY), YES) {
		    /* User was prompted and declined; if canceled with ^G
		     * let mainloop stay on this field, otherwise move on to
		     * the next field or link. - kw
		     */
		    if (HTLastConfirmCancelled())
			c = DO_NOTHING;
		    else
			c = LAC_TO_LKC(LYK_NEXT_LINK);
		    break;
		}
d270 6
a275 32
		if (!form->submit_action || *form->submit_action == '\0') {
		    HTUserMsg(NO_FORM_ACTION);
		    c = DO_NOTHING;
		    break;
		} else if (form->submit_method == URL_MAIL_METHOD && no_mail) {
		    HTAlert(FORM_MAILTO_DISALLOWED);
		    c = DO_NOTHING;
		    break;
		} else if (!immediate_submit &&
			   ((no_file_url &&
			     isFILE_URL(form->submit_action)) ||
			    !strncasecomp(form->submit_action, "lynx", 4))) {
		    c = LAC_TO_LKC0(LYK_SUBMIT);
		    break;
		} else {
		    if (form->no_cache &&
			form->submit_method != URL_MAIL_METHOD) {
			LYforce_no_cache = TRUE;
			reloading = TRUE;
		    }
		    newdoc_changed =
			HText_SubmitForm(form, newdoc, link_name, form->value);
		}
		if (form->submit_method == URL_MAIL_METHOD) {
		    *refresh_screen = TRUE;
		} else {
		    /*
		     *  Returns new document URL.
		     */
		    newdoc->link = 0;
		    newdoc->internal_link = FALSE;
		}
d278 6
d285 7
a291 1
		LYSetHilite(cur, form->value);
d293 1
a293 14
	    break;

	case F_SUBMIT_TYPE:
	case F_IMAGE_SUBMIT_TYPE:
	    if (form->disabled == YES)
		break;
	    if (form->no_cache &&
		form->submit_method != URL_MAIL_METHOD) {
		LYforce_no_cache = TRUE;
		reloading = TRUE;
	    }
	    newdoc_changed =
		HText_SubmitForm(form, newdoc, link_name, link_value);
	    if (form->submit_method == URL_MAIL_METHOD)
d295 4
a298 2
	    else {
		/* returns new document URL */
d302 10
d313 15
d335 3
a337 3
	 *  These flags may have been set in mainloop, anticipating that
	 *  a request will be submitted.  But if we haven't filled in
	 *  newdoc, that won't actually be the case, so unset them. - kw
d343 1
a343 1
    return(c);
d346 5
a350 6
PUBLIC int change_form_link ARGS5(
	int,		cur,
	DocInfo *,	newdoc,
	BOOLEAN *,	refresh_screen,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	immediate_submit)
d352 1
a352 1
    /*pass all our args and FALSE as last arg*/
d358 1
a358 1
			       FALSE /*redraw_only*/ );
d361 1
a361 1
PRIVATE int LastTFPos = -1;	/* remember last text field position */
d363 1
a363 2
PRIVATE void LYSetLastTFPos ARGS1(
    int,	pos)
d368 3
a370 4
PRIVATE int form_getstr ARGS3(
	int,		cur,
	BOOLEAN,	use_last_tfpos,
	BOOLEAN,	redraw_only)
d381 1
d387 1
a387 1
    BOOLEAN Edited = FALSE;		/* Value might be updated? */
d390 1
a390 1
     *  Get the initial position of the cursor.
d393 2
a394 2
    if ((startcol + form->size) > (LYcols - 1))
	far_col = (LYcols - 1);
d399 1
a399 1
     *  Make sure the form field value does not exceed our buffer. - FM
d403 3
a405 3
					    form->maxlength :
					    (sizeof(MyEdit.buffer) - 1));
    if (strlen(form->value) > (size_t)max_length) {
d407 2
a408 2
	 *  We can't fit the entire value into the editing buffer,
	 *  so enter as much of the tail as fits. - FM
d414 1
a414 1
	     *  If we can edit it, report that we are using the tail. - FM
d417 1
a417 1
	    show_formlink_statusline(form, redraw_only? FOR_PANEL : FOR_INPUT);
d423 1
a423 1
     *  Print panned line
d463 1
a463 1
	return 0;		/*return value won't be analysed*/
d466 1
a466 1
     *  And go for it!
d469 1
a469 1
again:
d476 1
a476 1
	 && (EditBinding(ch) != LYE_CHAR)
d478 1
a478 1
	 && (EditBinding(ch) != LYE_AIX)
d493 3
a495 3
	if (ch != -1 && (ch & LKC_ISLAC) && !(ch & LKC_ISLECLAC)) /* already lynxactioncode? */
	    break;	/* @@@@@@ maybe move these 2 lines outside ifdef -kw */
	if (ch == MOUSE_KEY) {		/* Need to process ourselves */
d505 1
a505 1
		    repeat = - repeat;
d510 1
a510 1
	    MEVENT	event;
d519 1
a519 1
		    repeat = - repeat;
d525 6
a530 6
		/*  Mouse event passed to us as MOUSE_KEY, and apparently
		 *  not on this field's line?  Something is not as it
		 *  should be...
		 *  A call to statusline() may have happened, possibly from
		 *  within a mouse menu.  Let's at least make sure here
		 *  that the cursor position gets restored.  - kw
d536 1
a536 1
#  endif     /* NCURSES || PDCURSES */
d563 1
a563 1
	     *  Set flag for modifier 1.
d570 1
a570 1
	     *  Set flag for modifier 2.
d576 2
a577 2
	 *  Filter out global navigation keys that should not be passed
	 *  to line editor, and LYK_REFRESH.
a597 1

d613 1
a613 1
		    if (*e1 < ' ') { /* Stop here? */
d617 3
a619 2
			if (*e1 == '\t') { /* Replace by space */
			    LYEditInsert(&MyEdit, (unsigned char *) " ", 1, -1, TRUE);
d631 1
a631 1
		    StrAllocCopy(buf, (char *) e1 + 1);	/* Survive _release() */
d646 1
a646 1
		    ch = '\n';		/* Sometimes moves to the next line */
d662 1
a662 1
	    ch = (int)('\t');
d666 1
a666 1
	    return(DO_NOTHING);
d679 1
a679 1
	if (action == LYE_NOP && LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
d689 20
a708 20
	    default:
	    /*	[ 1999/04/14 (Wed) 15:01:33 ]
	     *  Left arrrow in column 0 deserves special treatment here,
	     *  else you can get trapped in a form without submit button!
	     */
		if (action == LYE_BACK && MyEdit.pos == 0 && repeat == -1) {
		    int c = YES;    /* Go back immediately if no changes */
		    if (textfield_prompt_at_left_edge) {
			c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		    } else if (strcmp(MyEdit.buffer, value)) {
			c = HTConfirmDefault(PREV_DOC_QUERY, NO);
		    }
		    if (c == YES) {
			return(ch);
		    } else {
			if (form->disabled == YES)
			    _statusline(ARROWS_OR_TAB_TO_MOVE);
			else
			    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		    }
d710 16
a725 15
		if (form->disabled == YES) {
		    /*
		     *  Allow actions that don't modify the contents even
		     *  in disabled form fields, so the user can scroll
		     *  through the line for reading if necessary. - kw
		     */
		    switch(action) {
		    case LYE_BOL:
		    case LYE_EOL:
		    case LYE_FORW:
		    case LYE_FORW_RL:
		    case LYE_BACK:
		    case LYE_BACK_LL:
		    case LYE_FORWW:
		    case LYE_BACKW:
d727 1
a727 1
		    case LYE_SWMAP:
d730 2
a731 2
		    case LYE_SETMARK:
		    case LYE_XPMARK:
d733 36
a768 4
			break;
		    default:
			goto again;
		    }
a769 32
		/*
		 *  Make sure the statusline uses editmode help.
		 */
		if (repeat < 0)
		    repeat = 1;
		while (repeat--) {
		    int rc = LYEdit1(&MyEdit, ch, action & ~LYE_DF, TRUE);

		    if (rc < 0) {
			ch = -rc;
			/* FORW_RL and BACK_LL may require special attention.
			   BACK_LL wanted to switch to the previous link on
			   the same line.  However, if there is no such link,
			   then we would either disactivate the form
			   (with -tna), or will reenter the form, thus we jump
			   to the end of the line; both are counterintuitive.
			   Unfortunately, we do not have access to curdoc.link,
			   so we deduce it ourselves.  We don't have the info
			   to do it inside LYLineEdit().
			   This should work for prompts too.  */
			if ( (action != LYE_BACK_LL && action != LYE_FORW_RL)
			     || (cur >= 0
				&& cur < nlinks
				&& (action==LYE_FORW_RL
				    ? cur < nlinks - 1
				    : cur > 0)
				&& links[cur + ((action==LYE_FORW_RL)
						? 1
						: -1)].ly
				   == links[cur].ly))
			    goto breakfor;
		    }
d771 2
a772 2
		    if (rc == 0) {
			if (HTCJK != NOCJK && (0x80 <= ch)
d774 6
a779 7
			    refresh_mb = FALSE;
			else
			    refresh_mb = TRUE;
		    } else {
			if (!refresh_mb) {
			    LYEdit1(&MyEdit, 0, LYE_DELP, TRUE);
			}
d781 1
d783 11
a793 11
		}
		if (MyEdit.strlen >= max_length) {
		    HaveMaxlength = TRUE;
		} else if (HaveMaxlength &&
			   MyEdit.strlen < max_length) {
		    HaveMaxlength = FALSE;
		    _statusline(ENTER_TEXT_ARROWS_OR_TAB);
		}
		if (strcmp(value, MyEdit.buffer)) {
		    Edited = TRUE;
		}
d795 1
a795 1
		if (refresh_mb)
d798 1
a798 1
		LYSetLastTFPos(MyEdit.pos);
d803 1
a803 1
	char  *p;
d806 1
a806 1
	 *  Load the new value.
d810 2
a811 2
	     *  The previous value did fit in the line buffer,
	     *  so replace it with the new value. - FM
d816 1
a816 1
	     *  Combine the modified tail with the unmodified head. - FM
d825 1
a825 1
	 *  Remove trailing spaces
d827 4
a830 4
	 *  Do we really need to do that here?  Trailing spaces will only
	 *  be there if user keyed them in.  Rather rude to throw away
	 *  their hard earned spaces.  Better deal with trailing spaces
	 *  when submitting the form????
d840 6
a845 7
	 *  If the field has been changed, assume that it is now in
	 *  current display character set, even if for some reason
	 *  it wasn't!  Hopefully a user will only submit the form
	 *  if the non-ASCII characters are displayed correctly, which
	 *  means (assuming that the display character set has been set
	 *  truthfully) the user confirms by changing the field that
	 *  the character encoding is right. - kw
d847 1
a847 1
	if (form->value && *form->value)
d850 1
a850 1
    return(ch);
d854 1
a854 1
 *  Display statusline info tailored for the current form field.
d856 2
a857 3
PUBLIC void show_formlink_statusline ARGS2(
    CONST FormInfo *,	form,
    int,		for_what)
d859 1
a859 1
    switch(form->type) {
d865 3
a867 3
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_PASSWORD_MESSAGE_INA);
	    else
d898 3
a900 3
		if (for_what == FOR_PANEL)
		    statusline(FORM_TEXT_SUBMIT_MAILTO_MSG_INA);
		else
d909 1
a909 1
	    statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
d913 2
a914 1
	    if (xkey_info && *xkey_info) {
d931 1
a931 1
		statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
d945 1
a945 1
		if(user_mode == ADVANCED_MODE) {
d957 1
a957 1
	    if(user_mode == ADVANCED_MODE) {
d968 1
a968 1
	    if(user_mode == ADVANCED_MODE) {
d997 3
a999 3
	    if (for_what == FOR_PANEL)
		statusline(FORM_LINK_TEXT_MESSAGE_INA);
	    else
d1009 1
d1017 1
a1017 1
	    if (xkey_info && *xkey_info) {
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d29 1
a29 1
	struct link *	form_link,
d61 3
a63 3
PUBLIC int change_form_link_ex ARGS8(
	struct link *,	form_link,
	document *,	newdoc,
a64 2
	char *,		link_name,
	char *,		link_value,
d69 3
a71 1
    FormInfo *form = form_link->form;
d88 1
a88 1
    LYmove(form_link->ly, form_link->lx);
d94 2
a95 7
	    if (form->num_value) {
		form_link->hightext = unchecked_box;
		form->num_value = 0;
	    } else {
		form_link->hightext = checked_box;
		form->num_value = 1;
	    }
d108 2
a109 2
					  form_link->ly,
					  form_link->lx,
d126 2
a127 2
						form_link->ly,
						form_link->lx,
d177 3
a179 3
		    if (links[i].type == WWW_FORM_LINK_TYPE &&
			links[i].form->type == F_RADIO_TYPE &&
			links[i].form->number == form->number &&
d183 2
a184 2
			!strcmp(links[i].form->name, form->name) &&
			links[i].form->num_value) {
d187 1
a187 1
			links[i].hightext = unchecked_radio;
d198 1
a198 1
		form_link->hightext = checked_radio;
d206 4
a209 5
	    c = form_getstr(form_link, use_last_tfpos, redraw_only);
	    if (form->type == F_PASSWORD_TYPE)
		form_link->hightext = STARS(strlen(form->value));
	    else
		form_link->hightext = form->value;
d221 1
a221 1
		c = form_getstr(form_link, use_last_tfpos, TRUE);
d225 1
a225 1
		c = form_getstr(form_link, use_last_tfpos, FALSE);
d254 1
a254 1
		form_link->hightext = form->value;
d279 1
a279 1
			     !strncasecomp(form->submit_action, "file:", 5)) ||
d304 1
a304 1
		form_link->hightext = form->value;
d345 3
a347 3
PUBLIC int change_form_link ARGS7(
	struct link *,	form_link,
	document *,	newdoc,
a348 2
	char *,		link_name,
	char *,		link_value,
d353 6
a358 2
    return change_form_link_ex(form_link,newdoc,refresh_screen,link_name,
	link_value,use_last_tfpos,immediate_submit, FALSE /*redraw_only*/ );
d370 1
a370 1
	struct link *,	form_link,
d374 1
a374 1
    FormInfo *form = form_link->form;
d602 1
a602 1
	    unsigned char *s = get_clip_grab(), *e;
d608 1
a608 1
	    len = strlen(s);
d620 1
a620 1
			    LYEditInsert(&MyEdit, " ", 1, -1, TRUE);
d632 1
a632 1
		    StrAllocCopy(buf, e1 + 1);	/* Survive _release() */
d652 1
a652 1
		HTInfoMsg("Clipboard empty or Not text data.");
d759 2
a760 2
			     || ((form_link - links) >= 0
				&& (form_link - links) < nlinks
d762 6
a767 4
				    ? (form_link - links) < nlinks - 1
				    : (form_link - links) > 0)
				&& form_link[action==LYE_FORW_RL ? 1 : -1].ly
				   == form_link->ly))
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d9 1
a10 1
#include <LYStructs.h>  /* includes HTForms.h */
a11 1
#include <LYGlobalDefs.h>
d22 5
a26 1
extern HTCJKlang HTCJK;
d29 31
a59 9
	struct link *	form_link));
PRIVATE int popup_options PARAMS((
	int		cur_selection,
	OptionType *	list,
	int		ly,
	int		lx,
	int		width,
	int		i_length,
	int		disabled));
d61 1
a61 1
PUBLIC int change_form_link ARGS5(
d66 4
a69 1
	char *,		link_value)
d72 1
d75 1
d77 7
a83 6
	/*
	 *  If there is no form to perform action on, don't do anything.
	 */
	if (form == NULL) {
	    return(c);
	}
d88 1
a88 1
    move(form_link->ly, form_link->lx);
d104 1
a104 1
	    if (!form->select_list) {
d112 10
a121 4
		dummy = popup_options(form->num_value, form->select_list,
				form_link->ly, form_link->lx, form->size,
				form->size_l, form->disabled);
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d123 1
a123 5
#if defined(VMS) && !defined(USE_SLANG)
		    c = DO_NOTHING;
#else
		    c = 23;  /* CTRL-W refresh without clearok */
#endif /* VMS && !USE_SLANG */
d125 1
a125 1
#endif /* FANCY_CURSES || USE_SLANG */
d130 9
a138 4
	    form->num_value = popup_options(form->num_value, form->select_list,
				form_link->ly, form_link->lx, form->size,
				form->size_l, form->disabled);

d157 1
a157 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d159 1
a159 6
#if defined(VMS) && !defined(USE_SLANG)
		if (form->num_value == OrigNumValue)
		    c = DO_NOTHING;
		else
#endif /* VMS && !USE_SLANG*/
		c = 23;	 /* CTRL-W refresh without clearok */
d161 3
a163 3
#endif /* FANCY_CURSES || USE_SLANG */
                c = 12;  /* CTRL-L for repaint */
            break;
d190 2
a191 2
			move(links[i].ly, links[i].lx);
			addstr(unchecked_radio);
d207 1
d211 1
a211 1
	    c = form_getstr(form_link);
d226 6
a231 1
	    c = form_getstr(form_link);
d233 5
a237 2
		(c == '\r' || c == '\n')) {
		c = '\t';
d240 20
a259 1
	    if (c == '\r' || c == '\n') {
d261 14
d283 6
d295 2
a296 1
		    HText_SubmitForm(form, newdoc, link_name, form->value);
d323 2
a324 1
	    HText_SubmitForm(form, newdoc, link_name, link_value);
d336 12
d351 26
a376 2
PRIVATE int form_getstr ARGS1(
	struct link *,	form_link)
d385 5
a389 1
    int action, repeat, non_first = 0;
d422 2
a423 23
	    switch(form->type) {
		case F_PASSWORD_TYPE:
		    statusline(FORM_LINK_PASSWORD_MESSAGE);
		    break;
		case F_TEXT_SUBMIT_TYPE:
		    if (form->submit_method == URL_MAIL_METHOD) {
			statusline(FORM_LINK_TEXT_SUBMIT_MAILTO_MSG);
		    } else if (form->no_cache) {
			statusline(FORM_LINK_TEXT_RESUBMIT_MESSAGE);
		    } else {
			statusline(FORM_LINK_TEXT_SUBMIT_MESSAGE);
		    }
		    break;
		case F_TEXT_TYPE:
		    statusline(FORM_LINK_TEXT_MESSAGE);
		    break;
		case F_TEXTAREA_TYPE:
		    statusline(FORM_LINK_TEXTAREA_MESSAGE);
		    break;
		default:
		    break;
	    }
	    move(startline, startcol);
d432 34
a465 1
    MyEdit.hidden = (form->type == F_PASSWORD_TYPE);
d467 2
d476 1
a476 4
	get_mouse_link();		/* Reset mouse_link. */
	/* Try to set position basing on the last mouse event */
	if (!non_first++)
	    peek_mouse_levent();
d478 10
a487 1
	ch = LYgetch_for(FOR_INPUT);
d491 1
a491 1
	    ch = 7;
d494 6
a499 1
#  ifdef NCURSES_MOUSE_VERSION
d501 14
d523 1
a523 1
		    ch = LTARROW;
d526 26
a551 1
		    ch = RTARROW;
a553 1
#  endif	/* defined NCURSES_MOUSE_VERSION */
d556 24
a583 1
	action = EditBinding(ch);
d588 4
d598 1
a598 1
		ch = 7;
d603 59
d665 1
d673 12
a684 1
	if (keymap[ch + 1] == LYK_REFRESH)
d686 7
d694 2
a695 13
#ifdef NOTDEFINED	/* The first four are mapped to LYE_FORM_PASS now */
	    case DNARROW:
	    case UPARROW:
	    case PGUP:
	    case PGDOWN:
	    case HOME:
	    case END_KEY:
	    case FIND_KEY:
	    case SELECT_KEY:
		goto breakfor;
#endif /* NOTDEFINED */

	    /*
d699 1
a699 2
	    case LTARROW:
		if (MyEdit.pos == 0 && repeat == -1) {
d701 3
a703 1
		    if (strcmp(MyEdit.buffer, value)) {
d715 27
a741 5
		/* fall through */

	    default:
		if (form->disabled == YES)
		    goto again;
d747 39
a785 2
		while (repeat--)
		    LYLineEdit(&MyEdit, ch, TRUE);
d796 3
d800 1
d803 1
a803 3
#ifdef NOTDEFINED
breakfor:
#endif /* NOTDEFINED */
d825 1
d834 6
a839 4
	p = &(form->value[strlen(form->value)]);
	while ((p != form->value) && (p[-1] == ' '))
	    p--;
	*p = '\0';
d857 5
a861 7
**  This function prompts for an option or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM & LE
*/
PRIVATE int get_popup_option_number ARGS2(
	int *,		c,
	int *,		rel)
d863 23
a885 29
    char temp[120];
    char *p = temp;
    int num;

    /*
     *  Load the c argument into the prompt buffer.
     */
    temp[0] = *c;
    temp[1] = '\0';
    _statusline(SELECT_OPTION_NUMBER);

    /*
     *  Get the number, possibly with a suffix, from the user.
     */
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
	return(0);
    }

    *rel = '\0';
    num = atoi(p);
    while ( isdigit(*p) )
	++p;
    switch ( *p ) {
    case '+': case '-':
	/* 123+ or 123- */
	*rel = *p++; *c = *p;
d887 5
a891 4
    default:
	*c = *p++;
	*rel = *p;
    case 0:
d893 19
a911 36
    }

    /*
     *  If we had a 'g' or 'p' suffix, load it into c.
     *  Otherwise, zero c.  Then return the number.
     */
    if ( *p == 'g' || *p == 'G' ) {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P' ) {
	*c = 'p';
    } else {
	*c = '\0';
    }
    if ( *rel != '+' && *rel != '-' )
	*rel = 0;
    return num;
}

/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
PRIVATE void paddstr ARGS3(
	WINDOW *,	the_window,
	int,		width,
	char *, 	the_string)
{
    width -= strlen(the_string);
    waddstr(the_window, the_string);
    while (width-- > 0)
	waddstr(the_window, " ");
}
d913 1
a913 113


PRIVATE int popup_options ARGS7(
	int,		cur_selection,
	OptionType *,	list,
	int,		ly,
	int,		lx,
	int,		width,
	int,		i_length,
	int,		disabled)
{
    /*
     *  Revamped to handle within-tag VALUE's, if present,
     *  and to position the popup window appropriately,
     *  taking the user_mode setting into account. -- FM
     */
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_selection = cur_selection;
#ifndef USE_SLANG
    WINDOW * form_window;
#endif /* !USE_SLANG */
    int num_options = 0, top, bottom, length = -1;
    OptionType * opt_ptr = list;
    int window_offset = 0;
    int lines_to_show;
    int npages;
    static char prev_target[512];		/* Search string buffer */
    static char prev_target_buffer[512];	/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0, recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    OptionType * tmp_ptr;
    BOOLEAN ReDraw = FALSE;
    int number;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	*prev_target_buffer = '\0';
	first = FALSE;
    }
    *prev_target = '\0';
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
    QueryNum = QueryTotal;

    /*
     *  Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines-4;
    else
	lines_to_show = LYlines-2;

    /*
     *  Counting the number of options to be displayed.
     *   num_options ranges 0...n
     */
    for (; opt_ptr->next; num_options++, opt_ptr = opt_ptr->next)
	 ; /* null body */

    /*
     *  Let's assume for the sake of sanity that ly is the number
     *   corresponding to the line the selection box is on.
     *  Let's also assume that cur_selection is the number of the
     *   item that should be initially selected, as 0 beign the
     *   first item.
     *  So what we have, is the top equal to the current screen line
     *   subtracting the cur_selection + 1 (the one must be for the
     *   top line we will draw in a box).  If the top goes under 0,
     *   consider it 0.
     */
    top = ly - (cur_selection + 1);
    if (top < 0)
	top = 0;

    /*
     *  Check and see if we need to put the i_length parameter up to
     *  the number of real options.
     */
    if (!i_length) {
	i_length = num_options;
    } else {
	/*
	 *  Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     *  The bottom is the value of the top plus the number of options
     *  to view plus 3 (one for the top line, one for the bottom line,
     *  and one to offset the 0 counted in the num_options).
     */
    bottom = top + i_length + 3;

    /*
     *  Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 *  Position the window at the top if we have more
	 *  options than will fit in the window.
	 */
	if (i_length+3 > lines_to_show) {
	    top = 0;
	    bottom = top + i_length+3;
	    if (bottom > lines_to_show)
		bottom = lines_to_show + 1;
d915 22
a936 8
	    /*
	     *  Try to position the window so that the selected option will
	     *    appear where the selection box currently is positioned.
	     *  It could end up too high, at this point, but we'll move it
	     *    down latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
d938 12
a949 1
    }
d951 22
a972 4
    /*
     *  This is really fun, when the length is 4, it means 0-4, or 5.
     */
    length = (bottom - top) - 2;
d974 29
a1002 28
    /*
     *  Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    /*
     *  Set up the overall window, including the boxing characters ('*'),
     *  if it all fits.  Otherwise, set up the widest window possible. - FM
     */
#ifdef USE_SLANG
    SLsmg_fill_region(top, lx - 1, bottom - top, width + 4, ' ');
#else
    if (!(form_window = newwin(bottom - top, width + 4, top, lx - 1)) &&
	!(form_window = newwin(bottom - top, 0, top, 0))) {
	HTAlert(POPUP_FAILED);
	return(orig_selection);
    }
    scrollok(form_window, TRUE);
#ifdef PDCURSES
    keypad(form_window, TRUE);
#endif /* PDCURSES */
#ifdef NCURSES
    LYsubwindow(form_window);
d1004 13
a1016 3
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
    wbkgd(form_window, getbkgd(stdscr));
    wbkgdset(form_window, getbkgd(stdscr));
d1018 7
a1024 127
#endif /* USE_SLANG */

    /*
     *  Set up the window_offset for options.
     *   cur_selection ranges from 0...n
     *   length ranges from 0...m
     */
    if (cur_selection >= length) {
	window_offset = cur_selection - length + 1;
    }

    /*
     *  Compute the number of popup window pages. - FM
     */
    npages = ((num_options + 1) > length) ?
		(((num_options + 1) + (length - 1))/(length))
					  : 1;
/*
 * OH!  I LOVE GOTOs! hack hack hack
 *        07-11-94 GAB
 *      MORE hack hack hack
 *        09-05-94 FM
 */
redraw:
    opt_ptr = list;

    /*
     *  Display the boxed options.
     */
    for (i = 0; i <= num_options; i++, opt_ptr = opt_ptr->next) {
	if (i >= window_offset && i - window_offset < length) {
#ifdef USE_SLANG
	    SLsmg_gotorc(top + ((i + 1) - window_offset), (lx - 1 + 2));
	    SLsmg_write_nstring(opt_ptr->name, width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    paddstr(form_window, width, opt_ptr->name);
#endif /* USE_SLANG */
	}
    }
#ifdef USE_SLANG
    SLsmg_draw_box(top, (lx - 1), (bottom - top), (width + 4));
#else
#ifdef VMS
    VMSbox(form_window, (bottom - top), (width + 4));
#else
    LYbox(form_window, TRUE);
#endif /* VMS */
    wrefresh(form_window);
#endif /* USE_SLANG */
    opt_ptr = NULL;

    /*
     *  Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {

	/*
	 *  Unreverse cur selection.
	 */
	if (opt_ptr != NULL) {
#ifdef USE_SLANG
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	    SLsmg_write_nstring(opt_ptr->name, width);
#else
	    wmove(form_window, ((i + 1) - window_offset), 2);
	    paddstr(form_window, width, opt_ptr->name);
#endif /* USE_SLANG */
	}

	opt_ptr = list;

	for (i = 0; i < cur_selection; i++, opt_ptr = opt_ptr->next)
	    ; /* null body */

#ifdef USE_SLANG
	SLsmg_set_color(2);
	SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 2));
	SLsmg_write_nstring(opt_ptr->name, width);
	SLsmg_set_color(0);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current option, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each option is made current.  Otherwise, move it to
	 *  the bottom, right column of the screen, to "hide"
	 *  the cursor as for the main document, and let sighted
	 *  users rely on the current option's highlighting or
	 *  color without the distraction of a blinking cursor
	 *  in the window. - FM
	 */
	if (LYShowCursor)
	    SLsmg_gotorc((top + ((i + 1) - window_offset)), (lx - 1 + 1));
	else
	    SLsmg_gotorc((LYlines - 1), (LYcols - 1));
	SLsmg_refresh();
#else
	wmove(form_window, ((i + 1) - window_offset), 2);
	wstart_reverse(form_window);
	paddstr(form_window, width, opt_ptr->name);
	wstop_reverse(form_window);
	/*
	 *  If LYShowCursor is ON, move the cursor to the left
	 *  of the current option, so that blind users, who are
	 *  most likely to have LYShowCursor ON, will have it's
	 *  string spoken or passed to the braille interface as
	 *  each option is made current.  Otherwise, leave it to
	 *  the right of the current option, since we can't move
	 *  it out of the window, and let sighted users rely on
	 *  the highlighting of the current option without the
	 *  distraction of a blinking cursor preceding it. - FM
	 */
	if (LYShowCursor)
	    wmove(form_window, ((i + 1) - window_offset), 1);
	wrefresh(form_window);
#endif /* USE_SLANG  */

	c = LYgetch_for(FOR_CHOICE);
	if (c == 3 || c == 7) {	/* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, i + 1 + window_offset, &cur_selection)) < 0)
		goto redraw;
	    if  (cmd == LYK_ACTIVATE)
		break;
d1026 8
a1033 649
	} else {
	    cmd = keymap[c+1];
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
	    case LYK_1:
	    case LYK_2:
	    case LYK_3:
	    case LYK_4:
	    case LYK_5:
	    case LYK_6:
	    case LYK_7:
	    case LYK_8:
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_option_number((int *)&c,(int *)&rel);

		/* handle + or - suffix */
		CTRACE(tfp,"got popup option number %d, ",number);
		CTRACE(tfp,"rel='%c', c='%c', cur_selection=%d\n",
				rel,c,cur_selection);
		if ( c == 'p' ) {
		    int curpage = ((cur_selection + 1) > length) ?
			(((cur_selection + 1) + (length - 1))/(length))
					  : 1;
		    CTRACE(tfp,"  curpage=%d\n",curpage);
		    if ( rel == '+' )
			number = curpage + number;
		    else if ( rel == '-' )
			number = curpage - number;
		} else if ( rel == '+' ) {
		    number = cur_selection + number + 1;
		} else if ( rel == '-' ) {
		    number = cur_selection - number + 1;
		}
		if ( rel ) CTRACE(tfp,"new number=%d\n",number);
		/*
		 *  Check for a 'p' suffix. - FM
		 */
		if (c == 'p') {
		    /*
		     *  Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = 0;
			cur_selection = 0;
			if (disabled) {
			    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			} else {
			    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *  Treat a number equal to or greater than the
		     *  number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_options - length) + 1)) {
			    HTUserMsg(ALREADY_AT_OPTION_END);
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_options - length)) {
			    window_offset = (num_options - length + 1);
			}
			if (cur_selection < window_offset)
			    cur_selection = window_offset;
			if (disabled) {
			    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			} else {
			    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			}
			goto redraw;
		    }

		    /*
		     *  We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			char *msg = 0;
			HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
			HTUserMsg(msg);
			FREE(msg);
			if (disabled) {
			    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			} else {
			    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			}
			break;
		    }
		    cur_selection = window_offset = ((number - 1) * length);
		    if (disabled) {
			_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		    } else {
			_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		    }
		    goto redraw;

		}

		/*
		 *  Check for a positive number, which signifies
		 *  that an option should be sought. - FM
		 */
		if (number > 0) {
		    /*
		     *  Decrement the number so as to correspond
		     *  with our cur_selection values. - FM
		     */
		    number--;

		    /*
		     *  If the number is in range and had no legal
		     *  suffix, select the indicated option. - FM
		     */
		    if (number <= num_options && c == '\0') {
			cur_selection = number;
			cmd = LYK_ACTIVATE;
			break;
		    }

		    /*
		     *  Verify that we had a 'g' suffix,
		     *  and act on the number. - FM
		     */
		    if (c == 'g') {
			if (cur_selection == number) {
			    /*
			     *  The option already is current. - FM
			     */
			    char *msg = 0;
			    HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(msg);
			    FREE(msg);
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    break;
			}

			if (number <= num_options) {
			    /*
			     *  The number is in range and had a 'g'
			     *  suffix, so make it the current option,
			     *  scrolling if needed. - FM
			     */
			    j = (number - cur_selection);
			    cur_selection = number;
			    if ((j > 0) &&
				(cur_selection - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_options - length + 1))
				    window_offset = (num_options - length + 1);
			    } else if ((cur_selection - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    if (disabled) {
				_statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
			    } else {
				_statusline(FORM_LINK_OPTION_LIST_MESSAGE);
			    }
			    goto redraw;
			}

			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_OPTION_NUM_ENTERED);
		    }
		}

		/*
		 *  Restore the popup statusline. - FM
		 */
		if (disabled) {
		    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
		} else {
		    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		}
		break;

	    case LYK_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:

		if (cur_selection > 0)
		    cur_selection--;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_selection - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_FASTFORW_LINK:
	    case LYK_DOWN_LINK:
		if (cur_selection < num_options)
		    cur_selection++;

		/*
		 *  Scroll the window down if necessary
		 */
		if ((cur_selection - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_PAGE:
		/*
		 *  Okay, are we on the last page of the list?
		 *  If not then,
		 */
		if (window_offset != (num_options - length + 1)) {
		    /*
		     *  Modify the current selection to not be a
		     *  coordinate in the list, but a coordinate
		     *  on the item selected in the window.
		     */
		    cur_selection -= window_offset;

		    /*
		     *  Page down the proper length for the list.
		     *  If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_options - length)) {
			window_offset = (num_options - length + 1);
		    }

		    /*
		     *  Readjust the current selection to be a
		     *  list coordinate rather than window.
		     *  Redraw this thing.
		     */
		    cur_selection += window_offset;
		    goto redraw;
		}
		else if (cur_selection < num_options) {
		    /*
		     *  Already on last page of the list so just
		     *  redraw it with the last item selected.
		     */
		    cur_selection = num_options;
		}
		break;

	    case LYK_PREV_PAGE:
		/*
		 *  Are we on the first page of the list?
		 *  If not then,
		 */
		if (window_offset != 0) {
		    /*
		     *  Modify the current selection to not be a
		     *  list coordinate, but a window coordinate.
		     */
		    cur_selection -= window_offset;

		    /*
		     *  Page up the proper length.
		     *  If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }

		    /*
		     *  Readjust the current selection.
		     */
		    cur_selection += window_offset;
		    goto redraw;
		} else if (cur_selection > 0) {
		    /*
		     *  Already on the first page so just
		     *  back up to the first item.
		     */
		    cur_selection = 0;
		}
		break;

	    case LYK_HOME:
		cur_selection = 0;
		if (window_offset > 0) {
		    window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_END:
		cur_selection = num_options;
		if (window_offset != (num_options - length + 1)) {
		    window_offset = (num_options - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_DOWN_TWO:
		cur_selection += 2;
		if (cur_selection > num_options)
		    cur_selection = num_options;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_selection - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_options - length + 1))
			window_offset = (num_options - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_TWO:
		cur_selection -= 2;
		if (cur_selection < 0)
		    cur_selection = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_selection - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_DOWN_HALF:
		cur_selection += (length/2);
		if (cur_selection > num_options)
		    cur_selection = num_options;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_selection - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_options - length + 1))
			window_offset = (num_options - length + 1);
		    goto redraw;
		}
		break;

	    case LYK_UP_HALF:
		cur_selection -= (length/2);
		if (cur_selection < 0)
		    cur_selection = 0;

		/*
		 *  Scroll the window up if necessary.
		 */
		if ((cur_selection - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;

	    case LYK_REFRESH:
		lynx_force_repaint();
		refresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
		    /*
		     *  We got a 'n'ext command with no prior query
		     *  specified within the popup window.  See if
		     *  one was entered when the popup was retracted,
		     *  and if so, assume that's what's wanted.  Note
		     *  that it will become the default within popups,
		     *  unless another is entered within a popup.  If
		     *  the within popup default is to be changed at
		     *  that point, use WHEREIS ('/') and enter it,
		     *  or the up- or down-arrow keys to seek any of
		     *  the previously entered queries, regardless of
		     *  whether they were entered within or outside
		     *  of a popup window. - FM
		     */
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			strcpy(prev_target_buffer, cp);
			QueryNum = 0;
			FirstRecall = FALSE;
		    }
		}
		strcpy(prev_target, prev_target_buffer);
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
			/*
			 *  User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		}

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
		    /*
		     *  No entry.  Simply break.   - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
			    }
			} else {
			    QueryNum = 0;
			}
		    } else {
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
		    }
		    if (QueryNum >= QueryTotal)
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *  User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
		    /*
		     *  Use the current string or
		     *  first query in the list. - FM
		     */
		    FirstRecall = FALSE;
		    if (*prev_target_buffer) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				!strcmp(prev_target_buffer, cp)) {
				    break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     *  Advance to the next query in the list. - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0)
		    /*
		     *  Roll around to the first query in the list. - FM
		     */
		    QueryNum = (QueryTotal - 1);
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			strcpy(prev_target, cp);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		}
		/*
		 *  Replace the search string buffer with the new target. - FM
		 */
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

		/*
		 *  Start search at the next option. - FM
		 */
		for (j = 1, tmp_ptr = opt_ptr->next;
		     tmp_ptr != NULL; tmp_ptr = tmp_ptr->next, j++) {
		    if (case_sensitive) {
			if (strstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (tmp_ptr != NULL) {
		    /*
		     *  We have a hit, so make that option the current. - FM
		     */
		    cur_selection += j;
		    /*
		     *  Scroll the window down if necessary.
		     */
		    if ((cur_selection - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_options - length + 1))
			    window_offset = (num_options - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  If we started at the beginning, it can't be present. - FM
		 */
		if (cur_selection == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}

		/*
		 *  Search from the beginning to the current option. - FM
		 */
		for (j = 0, tmp_ptr = list;
		     j < cur_selection; tmp_ptr = tmp_ptr->next, j++) {
		    if (case_sensitive) {
			if (strstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(tmp_ptr->name, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_selection) {
		    /*
		     *  We have a hit, so make that option the current. - FM
		     */
		    j = (cur_selection - j);
		    cur_selection -= j;
		    /*
		     *  Scroll the window up if necessary.
		     */
		    if ((cur_selection - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
		}

		/*
		 *  Didn't find it in the preceding options either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);

restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		if (disabled)
		    _statusline(FORM_LINK_OPTION_LIST_UNM_MSG);
d1035 4
a1038 18
		    _statusline(FORM_LINK_OPTION_LIST_MESSAGE);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
		}
		break;

	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
		cur_selection = orig_selection;
		cmd = LYK_ACTIVATE; /* to exit */
		break;
d1040 1
a1040 1

a1041 8
#ifndef USE_SLANG
    delwin(form_window);
#ifdef NCURSES
    LYsubwindow(0);
#endif
#endif /* !USE_SLANG */

    return(disabled ? orig_selection : cur_selection);
@


1.1
log
@Initial revision
@
text
@d1 14
a14 15
#include "HTUtils.h"
#include "tcp.h"
#include "HTCJK.h"
#include "HTTP.h"
#include "HTAlert.h"
#include "LYCurses.h"
#include "GridText.h"
#include "LYCharSets.h"
#include "UCAux.h"
#include "LYUtils.h"
#include "LYStructs.h"  /* includes HTForms.h */
#include "LYStrings.h"
#include "LYGlobalDefs.h"
#include "LYKeymap.h"
#include "LYSignal.h"
d16 1
a16 1
#include "LYLeaks.h"
d19 2
a20 2
#include "AttrList.h"
#include "LYHash.h"
d36 1
a36 1
PUBLIC int change_form_link ARGS6(
a37 1
	int,		mode,
d140 1
a140 3
		_statusline(NEED_CHECKED_RADIO_BUTTON);
		sleep(MessageSecs);

d201 1
a201 2
		    _statusline(NO_FORM_ACTION);
		    sleep(MessageSecs);
d266 1
a266 5
    int action;

#ifdef VMS
    extern BOOLEAN HadVMSInterrupt;	/* Flag from cleanup_sig() AST */
#endif
d287 1
a287 1
    if (strlen(form->value) > max_length) {
d298 1
a298 2
	    _statusline(FORM_VALUE_TOO_LONG);
	    sleep(MessageSecs);
d313 2
d316 1
a316 1
		    statusline(FORM_LINK_TEXT_MESSAGE);
d338 7
a344 1
	ch = LYgetch();
d351 19
a369 1

d377 2
d403 1
a407 1
#ifdef NOTDEFINED
d409 1
a409 1
	    case END:
d412 1
a413 1
		goto breakfor;
d420 2
a421 2
		if (MyEdit.pos == 0) {
		    int c = 'Y';    /* Go back immediately if no changes */
d423 1
a423 2
			_statusline(PREV_DOC_QUERY);
			c = LYgetch();
d425 1
a425 1
		    if (TOUPPER(c) == 'Y') {
d442 4
a445 1
		LYLineEdit(&MyEdit, ch, TRUE);
d459 1
d461 1
d480 1
a480 2
	    _statusline(FORM_TAIL_COMBINED_WITH_HEAD);
	    sleep(MessageSecs);
d486 3
a488 3
	 *  Do we really need to do that here? Trailing spaces will only
	 *  be there if user keyed them in. Rather rude to throw away
	 *  their hard earned spaces. Better deal with trailing spaces
d516 3
a518 2
PRIVATE int get_popup_option_number ARGS1(
	int *,		c)
d521 2
d535 1
a535 2
	_statusline(CANCELLED);
	sleep(InfoSecs);
d537 1
d541 16
d561 1
a561 1
    if (strchr(temp, 'g') != NULL || strchr(temp, 'G') != NULL) {
d563 1
a563 1
    } else if (strchr(temp, 'p') != NULL || strchr(temp, 'P') != NULL) {
d568 3
a570 1
    return(atoi(temp));
d608 1
a608 1
    int c = 0, cmd = 0, i = 0, j = 0;
a617 3
#ifdef VMS
    extern BOOLEAN HadVMSInterrupt; /* Flag from cleanup_sig() AST */
#endif /* VMS */
a628 1
    char buffer[512];
d853 1
a854 1
	wmove(form_window, ((i + 1) - window_offset), 2);
d873 2
a874 2
	c = LYgetch();
	if (c == 3 || c == 7)	/* Control-C or Control-G */
d876 8
a883 1
	else
d885 1
d910 1
a910 1
		number = get_popup_option_number((int *)&c);
d912 19
d940 1
a940 2
			    _statusline(ALREADY_AT_OPTION_BEGIN);
			    sleep(MessageSecs);
d964 1
a964 2
			    _statusline(ALREADY_AT_OPTION_END);
			    sleep(MessageSecs);
d990 4
a993 3
			sprintf(buffer, ALREADY_AT_OPTION_PAGE, number);
			_statusline(buffer);
			sleep(MessageSecs);
d1041 4
a1044 4
			    sprintf(buffer,
				    OPTION_ALREADY_CURRENT, (number + 1));
			    _statusline(buffer);
			    sleep(MessageSecs);
d1082 1
a1082 2
			_statusline(BAD_OPTION_NUM_ENTERED);
			sleep(MessageSecs);
d1097 1
d1113 1
d1319 1
a1319 2
			_statusline(CANCELLED);
			sleep(InfoSecs);
d1330 1
a1330 2
		    _statusline(CANCELLED);
		    sleep(InfoSecs);
d1383 1
a1383 2
			    _statusline(CANCELLED);
			    sleep(InfoSecs);
d1439 1
a1439 2
			    _statusline(CANCELLED);
			    sleep(InfoSecs);
d1485 1
a1485 2
		    _user_message(STRING_NOT_FOUND, prev_target_buffer);
		    sleep(MessageSecs);
d1523 1
a1523 2
		_user_message(STRING_NOT_FOUND, prev_target_buffer);
		sleep(MessageSecs);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
