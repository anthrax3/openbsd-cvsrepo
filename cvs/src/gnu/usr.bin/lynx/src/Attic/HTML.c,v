head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.14
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.12
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.10
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.25;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.09.11.16.48;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.27.21.45.19;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.21.17.04.47;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.05.01.18.59.38;	author avsm;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2000.03.25.18.17.06;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.57;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.57;	author maja;	state Exp;
branches;
next	;

1.3.2.1
date	2004.11.06.04.19.29;	author brad;	state Exp;
branches;
next	;

1.3.4.1
date	2004.11.06.04.00.44;	author brad;	state Exp;
branches;
next	;

1.4.2.1
date	2004.11.06.05.06.25;	author brad;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: HTML.c,v 1.164 2013/11/28 11:17:39 tom Exp $
 *
 *		Structured stream to Rich hypertext converter
 *		============================================
 *
 *	This generates a hypertext object.  It converts from the
 *	structured stream interface of HTML events into the style-
 *	oriented interface of the HText.h interface.  This module is
 *	only used in clients and should not be linked into servers.
 *
 *	Override this module if making a new GUI browser.
 *
 *   Being Overidden
 *
 */

#define HTSTREAM_INTERNAL 1

#include <HTUtils.h>

#define Lynx_HTML_Handler
#include <HTChunk.h>
#include <HText.h>
#include <HTStyle.h>
#include <HTML.h>

#include <HTCJK.h>
#include <HTAtom.h>
#include <HTAnchor.h>
#include <HTMLGen.h>
#include <HTParse.h>
#include <HTList.h>
#include <UCMap.h>
#include <UCDefs.h>
#include <UCAux.h>

#include <LYGlobalDefs.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>

#include <HTAlert.h>
#include <HTForms.h>
#include <HTNestedList.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <LYList.h>
#include <LYBookmark.h>
#include <LYHistory.h>

#ifdef VMS
#include <LYCurses.h>
#endif /* VMS */

#ifdef USE_PRETTYSRC
#include <LYPrettySrc.h>
#endif

#ifdef USE_COLOR_STYLE
#include <SGML.h>
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>
#undef SELECTED_STYLES
#define pHText_changeStyle(X,Y,Z) {}

#if OMIT_SCN_KEEPING
# define HCODE_TO_STACK_OFF(x) /*(CSHASHSIZE+1)*/ 88888		/*special value. */
#else
# define HCODE_TO_STACK_OFF(x) x	/*pass computed value */
#endif

#endif /* USE_COLOR_STYLE */

#ifdef USE_SOURCE_CACHE
#include <HTAccess.h>
#endif

#include <LYCurses.h>
#include <LYJustify.h>

#include <LYexit.h>
#include <LYLeaks.h>

#define STACKLEVEL(me) ((me->stack + MAX_NESTING - 1) - me->sp)

#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4

#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)

#define LimitValue(name, value) \
 	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}

struct _HTStream {
    const HTStreamClass *isa;
#ifdef USE_SOURCE_CACHE
    HTParentAnchor *anchor;
    FILE *fp;
    char *filename;
    HTChunk *chunk;
    HTChunk *last_chunk;	/* the last chunk in a chain! */
    const HTStreamClass *actions;
    HTStream *target;
    int status;
#else
    /* .... */
#endif
};

static HTStyleSheet *styleSheet = NULL;		/* Application-wide */

/*	Module-wide style cache
*/
static HTStyle *styles[HTML_ELEMENTS + LYNX_HTML_EXTRA_ELEMENTS];

					   /* adding 24 nested list styles  */
					   /* and 3 header alignment styles */
					   /* and 3 div alignment styles    */
static HTStyle *default_style = NULL;

const char *LYToolbarName = "LynxPseudoToolbar";

/* used to turn off a style if the HTML author forgot to
static int i_prior_style = -1;
 */

/*
 *	Private function....
 */
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include);

static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      STRING2PTR value,
			      int tag_charset,
			      char **include);

/*
 * If we have verbose_img set, display labels for images.
 */
#define VERBOSE_IMG(value,src_type,string) \
      ((verbose_img) ? (newtitle = MakeNewTitle(value,src_type)): string)

static char *MakeNewTitle(STRING2PTR value, int src_type);
static char *MakeNewImageValue(STRING2PTR value);
static char *MakeNewMapValue(STRING2PTR value, const char *mapstr);

/*	Set an internal flag that the next call to a stack-affecting method
 *	is only internal and the stack manipulation should be skipped. - kw
 */
#define SET_SKIP_STACK(el_num) if (HTML_dtd.tags[el_num].contents != SGML_EMPTY) \
						{ me->skip_stack++; }

void strtolower(char *i)
{
    if (!i)
	return;
    while (*i) {
	*i = (char) TOLOWER(*i);
	i++;
    }
}

/*		Flattening the style structure
 *		------------------------------
 *
 * On the NeXT, and on any read-only browser, it is simpler for the text to
 * have a sequence of styles, rather than a nested tree of styles.  In this
 * case we have to flatten the structure as it arrives from SGML tags into a
 * sequence of styles.
 */

/*
 *  If style really needs to be set, call this.
 */
void actually_set_style(HTStructured * me)
{
    if (!me->text) {		/* First time through */
	LYGetChartransInfo(me);
	UCSetTransParams(&me->T,
			 me->UCLYhndl, me->UCI,
			 HTAnchor_getUCLYhndl(me->node_anchor,
					      UCT_STAGE_HTEXT),
			 HTAnchor_getUCInfoStage(me->node_anchor,
						 UCT_STAGE_HTEXT));
	me->text = HText_new2(me->node_anchor, me->target);
	HText_beginAppend(me->text);
	HText_setStyle(me->text, me->new_style);
	me->in_word = NO;
	LYCheckForContentBase(me);
    } else {
	HText_setStyle(me->text, me->new_style);
    }

    me->old_style = me->new_style;
    me->style_change = NO;
}

/*
 *  If you THINK you need to change style, call this.
 */
static void change_paragraph_style(HTStructured * me, HTStyle *style)
{
    if (me->new_style != style) {
	me->style_change = YES;
	me->new_style = style;
    }
    me->in_word = NO;
}

/*
 * Return true if we should write a message (to LYNXMESSAGES, or the trace
 * file) telling about some bad HTML that we've found.
 */
BOOL LYBadHTML(HTStructured * me)
{
    BOOL code = FALSE;

    switch ((enumBadHtml) cfg_bad_html) {
    case BAD_HTML_IGNORE:
	break;
    case BAD_HTML_TRACE:
	code = TRUE;
	break;
    case BAD_HTML_MESSAGE:
	code = TRUE;
	break;
    case BAD_HTML_WARN:
	/*
	 * If we're already tracing, do not add a warning.
	 */
	if (!TRACE && !me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
	code = TRACE;
	break;
    }
    return code;
}

/*
 * Handle the formatted message.
 */
void LYShowBadHTML(const char *message)
{
    if (dump_output_immediately && dump_to_stderr)
	fprintf(stderr, "%s", message);

    switch ((enumBadHtml) cfg_bad_html) {
    case BAD_HTML_IGNORE:
	break;
    case BAD_HTML_TRACE:
    case BAD_HTML_MESSAGE:
    case BAD_HTML_WARN:
	CTRACE((tfp, "%s", message));
	break;
    }

    switch ((enumBadHtml) cfg_bad_html) {
    case BAD_HTML_IGNORE:
    case BAD_HTML_TRACE:
    case BAD_HTML_WARN:
	break;
    case BAD_HTML_MESSAGE:
	LYstore_message(message);
	break;
    }
}

/*_________________________________________________________________________
 *
 *			A C T I O N	R O U T I N E S
 */

/* FIXME:  this should be amended to do the substitution only when not in a
 * multibyte stream.
 */
#ifdef EXP_JAPANESE_SPACES
#define FIX_JAPANESE_SPACES \
	(HTCJK == CHINESE || HTCJK == JAPANESE || HTCJK == TAIPEI)
	/* don't replace '\n' with ' ' if Chinese or Japanese - HN
	 */
#else
#define FIX_JAPANESE_SPACES 0
#endif

/*	Character handling
 *	------------------
 */
void HTML_put_character(HTStructured * me, int c)
{
    unsigned uc = UCH(c);

    /*
     * Ignore all non-MAP content when just scanning a document for MAPs.  - FM
     */
    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
	return;

    c = (int) uc;

    /*
     * Do EOL conversion if needed.  - FM
     *
     * Convert EOL styles:
     *   macintosh:  cr    --> lf
     *   ascii:      cr-lf --> lf
     *   unix:       lf    --> lf
     */
    if ((me->lastraw == '\r') && c == '\n') {
	me->lastraw = -1;
	return;
    }
    me->lastraw = c;
    if (c == '\r') {
	c = '\n';
	uc = UCH(c);
    }

    /*
     * Handle SGML_LITTERAL tags that have HTChunk elements.  - FM
     */
    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
	return;			/* Do Nothing */

    case HTML_TITLE:
	if (c == LY_SOFT_HYPHEN)
	    return;
	if (c != '\n' && c != '\t' && c != '\r') {
	    HTChunkPutc(&me->title, uc);
	} else if (FIX_JAPANESE_SPACES) {
	    if (c == '\t') {
		HTChunkPutc(&me->title, ' ');
	    } else {
		return;
	    }
	} else {
	    HTChunkPutc(&me->title, ' ');
	}
	return;

    case HTML_STYLE:
	HTChunkPutc(&me->style_block, uc);
	return;

    case HTML_SCRIPT:
	HTChunkPutc(&me->script, uc);
	return;

    case HTML_OBJECT:
	HTChunkPutc(&me->object, uc);
	return;

    case HTML_TEXTAREA:
	HTChunkPutc(&me->textarea, uc);
	return;

    case HTML_SELECT:
    case HTML_OPTION:
	HTChunkPutc(&me->option, uc);
	return;

    case HTML_MATH:
	HTChunkPutc(&me->math, uc);
	return;

    default:
	if (me->inSELECT) {
	    /*
	     * If we are within a SELECT not caught by the cases above -
	     * HTML_SELECT or HTML_OPTION may not be the last element pushed on
	     * the style stack if there were invalid markup tags within a
	     * SELECT element.  For error recovery, treat text as part of the
	     * OPTION text, it is probably meant to show up as user-visible
	     * text.  Having A as an open element while in SELECT is really
	     * sick, don't make anchor text part of the option text in that
	     * case since the option text will probably just be discarded.  -
	     * kw
	     */
	    if (me->sp[0].tag_number == HTML_A)
		break;
	    HTChunkPutc(&me->option, uc);
	    return;
	}
	break;
    }				/* end first switch */

    /*
     * Handle all other tag content.  - FM
     */
    switch (me->sp[0].tag_number) {

    case HTML_PRE:		/* Formatted text */
	/*
	 * We guarantee that the style is up-to-date in begin_litteral. But we
	 * still want to strip \r's.
	 */
	if (c != '\r' &&
	    !(c == '\n' && me->inLABEL && !me->inP) &&
	    !(c == '\n' && !me->inPRE)) {
	    me->inP = TRUE;
	    me->inLABEL = FALSE;
	    HText_appendCharacter(me->text, c);
	}
	me->inPRE = TRUE;
	break;

    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral.  But we
	 * still want to strip \r's.
	 */
	if (c != '\r') {
	    me->inP = TRUE;
	    me->inLABEL = FALSE;
	    HText_appendCharacter(me->text, c);
	}
	break;

    default:
	/*
	 * Free format text.
	 */
	if (me->sp->style->id == ST_Preformatted) {
	    if (c != '\r' &&
		!(c == '\n' && me->inLABEL && !me->inP) &&
		!(c == '\n' && !me->inPRE)) {
		me->inP = TRUE;
		me->inLABEL = FALSE;
		HText_appendCharacter(me->text, c);
	    }
	    me->inPRE = TRUE;

	} else if (me->sp->style->id == ST_Listing ||
		   me->sp->style->id == ST_Example) {
	    if (c != '\r') {
		me->inP = TRUE;
		me->inLABEL = FALSE;
		HText_appendCharacter(me->text, c);
	    }

	} else {
	    if (me->style_change) {
		if ((c == '\n') || (c == ' '))
		    return;	/* Ignore it */
		UPDATE_STYLE;
	    }
	    if (c == '\n') {
		if (!FIX_JAPANESE_SPACES) {
		    if (me->in_word) {
			if (HText_getLastChar(me->text) != ' ') {
			    me->inP = TRUE;
			    me->inLABEL = FALSE;
			    HText_appendCharacter(me->text, ' ');
			}
			me->in_word = NO;
		    }
		}

	    } else if (c == ' ' || c == '\t') {
		if (HText_getLastChar(me->text) != ' ') {
		    me->inP = TRUE;
		    me->inLABEL = FALSE;
		    HText_appendCharacter(me->text, ' ');
		}

	    } else if (c == '\r') {
		/* ignore */

	    } else {
		me->inP = TRUE;
		me->inLABEL = FALSE;
		HText_appendCharacter(me->text, c);
		me->in_word = YES;
	    }
	}
    }				/* end second switch */

    if (c == '\n' || c == '\t') {
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
    } else {
	HText_setLastChar(me->text, c);
    }
}

/*	String handling
 *	---------------
 *
 *	This is written separately from put_character because the loop can
 *	in some cases be promoted to a higher function call level for speed.
 */
void HTML_put_string(HTStructured * me, const char *s)
{
#ifdef USE_PRETTYSRC
    char *translated_string = NULL;
#endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
	break;			/* Do Nothing */

    case HTML_TITLE:
	HTChunkPuts(&me->title, s);
	break;

    case HTML_STYLE:
	HTChunkPuts(&me->style_block, s);
	break;

    case HTML_SCRIPT:
	HTChunkPuts(&me->script, s);
	break;

    case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
	break;

    case HTML_OBJECT:
	HTChunkPuts(&me->object, s);
	break;

    case HTML_TEXTAREA:
	HTChunkPuts(&me->textarea, s);
	break;

    case HTML_SELECT:
    case HTML_OPTION:
	HTChunkPuts(&me->option, s);
	break;

    case HTML_MATH:
	HTChunkPuts(&me->math, s);
	break;

    default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

	    }			/* for */
	}
    }				/* end switch */
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}

/*	Buffer write
 *	------------
 */
void HTML_write(HTStructured * me, const char *s, int l)
{
    const char *p;
    const char *e = s + l;

    if (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT)
	return;

    for (p = s; p < e; p++)
	HTML_put_character(me, *p);
}

/*
 *  "Internal links" are hyperlinks whose source and destination are
 *  within the same document, and for which the destination is given
 *  as a URL Reference with an empty URL, but possibly with a non-empty
 *  #fragment.	(This terminology re URL-Reference vs. URL follows the
 *  Fielding URL syntax and semantics drafts).
 *  Differences:
 *  (1) The document's base (in whatever way it is given) is not used for
 *	resolving internal link references.
 *  (2) Activating an internal link should not result in a new retrieval
 *	of a copy of the document.
 *  (3) Internal links are the only way to refer with a hyperlink to a document
 *	(or a location in it) which is only known as the result of a POST
 *	request (doesn't have a URL from which the document can be retrieved
 *	with GET), and can only be used from within that document.
 *
 * *If track_internal_links is true, we keep track of whether a
 *  link destination was given as an internal link.  This information is
 *  recorded in the type of the link between anchor objects, and is available
 *  to the HText object and the mainloop from there.  URL References to
 *  internal destinations are still resolved into an absolute form before
 *  being passed on, but using the current stream's retrieval address instead
 *  of the base URL.
 *  Examples:  (replace [...] to have a valid absolute URL)
 *  In document retrieved from [...]/mypath/mydoc.htm w/ base [...]/otherpath/
 *  a. HREF="[...]/mypath/mydoc.htm"	  -> [...]/mypath/mydoc.htm
 *  b. HREF="[...]/mypath/mydoc.htm#frag" -> [...]/mypath/mydoc.htm#frag
 *  c. HREF="mydoc.htm"			  -> [...]/otherpath/mydoc.htm
 *  d. HREF="mydoc.htm#frag"		  -> [...]/otherpath/mydoc.htm#frag
 *  e. HREF=""		      -> [...]/mypath/mydoc.htm      (marked internal)
 *  f. HREF="#frag"	      -> [...]/mypath/mydoc.htm#frag (marked internal)
 *
 * *If track_internal_links is false, URL-less URL-References are
 *  resolved differently from URL-References with a non-empty URL (using the
 *  current stream's retrieval address instead of the base), but we make no
 *  further distinction.  Resolution is then as in the examples above, execept
 *  that there is no "(marked internal)".
 *
 * *Note that this doesn't apply to form ACTIONs (always resolved using base,
 *  never marked internal).  Also other references encountered or generated
 *  are not marked internal, whether they have a URL or not, if in a given
 *  context an internal link makes no sense (e.g., IMG SRC=).
 */

/* A flag is used to keep track of whether an "URL reference" encountered
   had a real "URL" or not.  In the latter case, it will be marked as
   "internal".	The flag is set before we start messing around with the
   string (resolution of relative URLs etc.).  This variable only used
   locally here, don't confuse with LYinternal_flag which is for
   overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(flag,s) \
   	flag = (BOOLEAN) (((s) && (*(s)=='#' || *(s)=='\0')) ? TRUE : FALSE)

/* Last argument to pass to HTAnchor_findChildAndLink() calls,
   just an abbreviation. - kw */
#define INTERN_CHK(flag) (HTLinkType *)((flag) ? HTInternalLink : NULL)
#define INTERN_LT         INTERN_CHK(intern_flag)

#ifdef USE_COLOR_STYLE
static char *Style_className = 0;
static char *Style_className_end = 0;
static size_t Style_className_len = 0;
static int hcode;

#ifdef LY_FIND_LEAKS
static void free_Style_className(void)
{
    FREE(Style_className);
}
#endif

static void addClassName(const char *prefix,
			 const char *actual,
			 size_t length)
{
    size_t offset = strlen(prefix);
    size_t have = (unsigned) (Style_className_end - Style_className);
    size_t need = (offset + length + 1);

    if ((have + need) >= Style_className_len) {
	Style_className_len += 1024 + 2 * (have + need);
	if (Style_className == 0) {
	    Style_className = typeMallocn(char, Style_className_len);
	} else {
	    Style_className = typeRealloc(char, Style_className, Style_className_len);
	}
	if (Style_className == NULL)
	    outofmem(__FILE__, "addClassName");
	assert(Style_className != NULL);
	Style_className_end = Style_className + have;
    }
    if (offset)
	strcpy(Style_className_end, prefix);
    if (length)
	memcpy(Style_className_end + offset, actual, length);
    Style_className_end[offset + length] = '\0';
    strtolower(Style_className_end);

    Style_className_end += (offset + length);
}
#else
#define addClassName(prefix, actual, length)	/* nothing */
#endif

#ifdef USE_PRETTYSRC

static void HTMLSRC_apply_markup(HTStructured * context, HTlexeme lexeme, int start,
				 int tag_charset)
{
    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);

    while (ts) {
#ifdef USE_COLOR_STYLE
	if (ts->start) {
	    current_tag_style = ts->style;
	    force_current_tag_style = TRUE;
	    forced_classname = ts->class_name;
	    force_classname = TRUE;
	}
#endif
	CTRACE((tfp, ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n", (int) lexeme));
	if (ts->start)
	    HTML_start_element(context,
			       (int) ts->element,
			       ts->present,
			       (STRING2PTR) ts->value,
			       tag_charset,
			       NULL);
	else
	    HTML_end_element(context,
			     (int) ts->element,
			     NULL);
	ts = ts->next;
    }
}

#  define START TRUE
#  define STOP FALSE

#  define PSRCSTART(x)	HTMLSRC_apply_markup(me,HTL_##x,START,tag_charset)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(me,HTL_##x,STOP,tag_charset)

#  define PUTC(x) HTML_put_character(me,x)
#  define PUTS(x) HTML_put_string(me,x)

#endif /* USE_PRETTYSRC */

static void LYStartArea(HTStructured * obj, const char *href,
			const char *alt,
			const char *title,
			int tag_charset)
{
    BOOL new_present[HTML_AREA_ATTRIBUTES];
    const char *new_value[HTML_AREA_ATTRIBUTES];
    int i;

    for (i = 0; i < HTML_AREA_ATTRIBUTES; i++)
	new_present[i] = NO;

    if (alt) {
	new_present[HTML_AREA_ALT] = YES;
	new_value[HTML_AREA_ALT] = (const char *) alt;
    }
    if (non_empty(title)) {
	new_present[HTML_AREA_TITLE] = YES;
	new_value[HTML_AREA_TITLE] = (const char *) title;
    }
    if (href) {
	new_present[HTML_AREA_HREF] = YES;
	new_value[HTML_AREA_HREF] = (const char *) href;
    }

    (*obj->isa->start_element) (obj, HTML_AREA, new_present, new_value,
				tag_charset, 0);
}

static void LYHandleFIG(HTStructured * me, const BOOL *present,
			STRING2PTR value,
			int isobject,
			int imagemap,
			const char *id,
			const char *src,
			int convert,
			int start,
			BOOL *intern_flag GCC_UNUSED)
{
    if (start == TRUE) {
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, NULL);
	}
	if (!isobject) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	if (non_empty(id)) {
	    if (present && convert) {
		CHECK_ID(HTML_FIG_ID);
	    } else
		LYHandleID(me, id);
	}
	me->in_word = NO;
	me->inP = FALSE;

	if (clickable_images && non_empty(src)) {
	    char *href = NULL;

	    StrAllocCopy(href, src);
	    CHECK_FOR_INTERN(*intern_flag, href);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 INTERN_CHK(*intern_flag));	/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (isobject
				     ? (imagemap
					? "(IMAGE)"
					: "(OBJECT)")
				     : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
    } else {			/* handle end tag */
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
    }
}

static void clear_objectdata(HTStructured * me)
{
    if (me) {
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
    }
}

#define HTParseALL(pp,pconst)  \
	{ char* free_me = *pp; \
	  *pp = HTParse(*pp, pconst, PARSE_ALL); \
	  FREE(free_me);       \
	}

/*	Start Element
 *	-------------
 */
static int HTML_start_element(HTStructured * me, int element_number,
			      const BOOL *present,
			      STRING2PTR value,
			      int tag_charset,
			      char **include)
{
    char *alt_string = NULL;
    char *id_string = NULL;
    char *newtitle = NULL;
    char **pdoctitle = NULL;
    char *href = NULL;
    char *map_href = NULL;
    char *title = NULL;
    char *I_value = NULL;
    char *I_name = NULL;
    char *temp = NULL;
    const char *Base = NULL;
    int dest_char_set = -1;
    HTParentAnchor *dest = NULL;	/* An anchor's destination */
    BOOL dest_ismap = FALSE;	/* Is dest an image map script? */
    HTChildAnchor *ID_A = NULL;	/* HTML_foo_ID anchor */
    int url_type = 0, i = 0;
    char *cp = NULL;
    HTMLElement ElementNumber = (HTMLElement) element_number;
    BOOL intern_flag = FALSE;
    short stbl_align = HT_ALIGN_NONE;
    int status = HT_OK;

#ifdef USE_COLOR_STYLE
    char *class_name;
    int class_used = 0;
#endif

#ifdef USE_PRETTYSRC
    if (psrc_view && !sgml_in_psrc_was_initialized) {
	if (!psrc_nested_call) {
	    HTTag *tag = &HTML_dtd.tags[element_number];
	    char buf[200];
	    const char *p;

	    if (psrc_first_tag) {
		psrc_first_tag = FALSE;
		/* perform the special actions on the begining of the document.
		   It's assumed that all lynx modules start generating html
		   from tag (ie not a text) so we are able to trap this moment
		   and initialize.
		 */
		psrc_nested_call = TRUE;
		HTML_start_element(me, HTML_BODY, NULL, NULL, tag_charset, NULL);
		HTML_start_element(me, HTML_PRE, NULL, NULL, tag_charset, NULL);
		PSRCSTART(entire);
		psrc_nested_call = FALSE;
	    }

	    psrc_nested_call = TRUE;
	    /*write markup for tags and exit */
	    PSRCSTART(abracket);
	    PUTC('<');
	    PSRCSTOP(abracket);
	    PSRCSTART(tag);
	    if (tagname_transform != 0)
		PUTS(tag->name);
	    else {
		LYStrNCpy(buf, tag->name, sizeof(buf) - 1);
		LYLowerCase(buf);
		PUTS(buf);
	    }
	    if (present) {
		for (i = 0; i < tag->number_of_attributes; i++)
		    if (present[i]) {
			PUTC(' ');
			PSRCSTART(attrib);
			if (attrname_transform != 0)
			    PUTS(tag->attributes[i].name);
			else {
			    LYStrNCpy(buf,
				      tag->attributes[i].name,
				      sizeof(buf) - 1);
			    LYLowerCase(buf);
			    PUTS(buf);
			}
			if (value[i]) {
			    char q = '"';

			    /*0 in dquotes, 1 - in quotes, 2 mixed */
			    char kind = (char) (!StrChr(value[i], '"') ?
						0 :
						!StrChr(value[i], '\'') ?
						q = '\'', 1 :
						2);

			    PUTC('=');
			    PSRCSTOP(attrib);
			    PSRCSTART(attrval);
			    PUTC(q);
			    /*is it special ? */
			    if (tag->attributes[i].type == HTMLA_ANAME) {
				HTStartAnchor(me, value[i], NULL);
				HTML_end_element(me, HTML_A, NULL);
			    } else if (tag->attributes[i].type == HTMLA_HREF) {
				PSRCSTART(href);
				HTStartAnchor(me, NULL, value[i]);
			    }
			    if (kind != 2)
				PUTS(value[i]);
			    else
				for (p = value[i]; *p; p++)
				    if (*p != '"')
					PUTC(*p);
				    else
					PUTS("&#34;");
			    /*is it special ? */
			    if (tag->attributes[i].type == HTMLA_HREF) {
				HTML_end_element(me, HTML_A, NULL);
				PSRCSTOP(href);
			    }
			    PUTC(q);
			    PSRCSTOP(attrval);
			}	/* if value */
		    }		/* if present[i] */
	    }			/* if present */
	    PSRCSTOP(tag);
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
	    return HT_OK;
	}			/*if (!psrc_nested_call) */
	/*fall through */
    }
#endif /* USE_PRETTYSRC */

    if (LYMapsOnly) {
	if (!(ElementNumber == HTML_MAP || ElementNumber == HTML_AREA ||
	      ElementNumber == HTML_BASE || ElementNumber == HTML_OBJECT ||
	      ElementNumber == HTML_A)) {
	    return HT_OK;
	}
    } else if (!me->text) {
	UPDATE_STYLE;
    } {
	/*  me->tag_charset  is charset for attribute values.  */
	int j = ((tag_charset < 0) ? me->UCLYhndl : tag_charset);

	if ((me->tag_charset != j) || (j < 0 /* for trace entry */ )) {
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j));
	    CTRACE((tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		    me->UCLYhndl, tag_charset));
	    me->tag_charset = j;
	}
    }

/* this should be done differently */
#if defined(USE_COLOR_STYLE)

    addClassName(";",
		 HTML_dtd.tags[element_number].name,
		 (size_t) HTML_dtd.tags[element_number].name_len);

    class_name = (force_classname ? forced_classname : class_string);
    force_classname = FALSE;

    if (force_current_tag_style == FALSE) {
	current_tag_style = (class_name[0]
			     ? -1
			     : cached_tag_styles[element_number]);
    } else {
	force_current_tag_style = FALSE;
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSS.elt:<%s>\n", HTML_dtd.tags[element_number].name));

    if (current_tag_style == -1) {	/* Append class_name */
	hcode = hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
	if (class_name[0]) {
	    int ohcode = hcode;

	    hcode = hash_code_aggregate_char('.', hcode);
	    hcode = hash_code_aggregate_lower_str(class_name, hcode);
	    if (!hashStyles[hcode].name) {	/* None such -> classless version */
		hcode = ohcode;
		CTRACE2(TRACE_STYLE,
			(tfp,
			 "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
	    } else {
		addClassName(".", class_name, strlen(class_name));

		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.start_element: <%s>.<%s>, hcode=%d.\n",
			 HTML_dtd.tags[element_number].name, class_name, hcode));
		class_used = 1;
	    }
	}

	class_string[0] = '\0';

    } else {			/* (current_tag_style!=-1)  */
	if (class_name[0]) {
	    addClassName(".", class_name, strlen(class_name));
	    class_string[0] = '\0';
	}
	hcode = current_tag_style;
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.start_element: <%s>, hcode=%d.\n",
		 HTML_dtd.tags[element_number].name, hcode));
	current_tag_style = -1;
    }

#if !OMIT_SCN_KEEPING		/* Can be done in other cases too... */
    if (!class_used && ElementNumber == HTML_INPUT) {	/* For some other too? */
	const char *type = "";
	int ohcode = hcode;

	if (present && present[HTML_INPUT_TYPE] && value[HTML_INPUT_TYPE])
	    type = value[HTML_INPUT_TYPE];

	hcode = hash_code_aggregate_lower_str(".type.", hcode);
	hcode = hash_code_aggregate_lower_str(type, hcode);
	if (!hashStyles[hcode].name) {	/* None such -> classless version */
	    hcode = ohcode;
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: type <%s> not configured.\n",
		     type));
	} else {
	    addClassName(".type.", type, strlen(type));

	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.start_element: <%s>.type.<%s>, hcode=%d.\n",
		     HTML_dtd.tags[element_number].name, type, hcode));
	}
    }
#endif /* !OMIT_SCN_KEEPING */

    HText_characterStyle(me->text, hcode, STACK_ON);
#endif /* USE_COLOR_STYLE */

    /*
     * Handle the start tag.  - FM
     */
    switch (ElementNumber) {

    case HTML_HTML:
	break;

    case HTML_HEAD:
	break;

    case HTML_BASE:
	if (present && present[HTML_BASE_HREF] && !local_host_only &&
	    non_empty(value[HTML_BASE_HREF])) {
	    char *base = NULL;
	    const char *related = NULL;

	    StrAllocCopy(base, value[HTML_BASE_HREF]);
	    CTRACE((tfp, "*HTML_BASE: initial href=`%s'\n", NonNull(base)));

	    if (!(url_type = LYLegitimizeHREF(me, &base, TRUE, TRUE))) {
		CTRACE((tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			NonNull(base)));
		if (me->inBadBASE == FALSE)
		    HTAlert(BASE_NOT_ABSOLUTE);
		me->inBadBASE = TRUE;
	    }

	    if (url_type == LYNXIMGMAP_URL_TYPE) {
		/*
		 * These have a non-standard form, basically strip the prefix
		 * or the code below would insert a nonsense host into the
		 * pseudo URL.  These should never occur where they would be
		 * used for resolution of relative URLs anyway.  We can also
		 * strip the #map part.  - kw
		 */
		temp = base;
		base = HTParse(base + 11, "", PARSE_ALL_WITHOUT_ANCHOR);
		FREE(temp);
	    }

	    /*
	     * Get parent's address for defaulted fields.
	     */
	    related = me->node_anchor->address;

	    /*
	     * Create the access field.
	     */
	    temp = HTParse(base, related, PARSE_ACCESS + PARSE_PUNCTUATION);
	    StrAllocCopy(me->base_href, temp);
	    FREE(temp);

	    /*
	     * Create the host[:port] field.
	     */
	    temp = HTParse(base, "", PARSE_HOST + PARSE_PUNCTUATION);
	    if (!StrNCmp(temp, "//", 2)) {
		StrAllocCat(me->base_href, temp);
		if (!strcmp(me->base_href, "file://")) {
		    StrAllocCat(me->base_href, "localhost");
		}
	    } else {
		if (isFILE_URL(me->base_href)) {
		    StrAllocCat(me->base_href, "//localhost");
		} else if (strcmp(me->base_href, STR_NEWS_URL)) {
		    FREE(temp);
		    StrAllocCat(me->base_href, (temp = HTParse(related, "",
							       PARSE_HOST + PARSE_PUNCTUATION)));
		}
	    }
	    FREE(temp);

	    /*
	     * Create the path field.
	     */
	    temp = HTParse(base, "", PARSE_PATH + PARSE_PUNCTUATION);
	    if (*temp != '\0') {
		char *p = StrChr(temp, '?');

		if (p)
		    *p = '\0';
		p = strrchr(temp, '/');
		if (p)
		    *(p + 1) = '\0';	/* strip after the last slash */

		StrAllocCat(me->base_href, temp);
	    } else if (!strcmp(me->base_href, STR_NEWS_URL)) {
		StrAllocCat(me->base_href, "*");
	    } else if (isNEWS_URL(me->base_href) ||
		       isNNTP_URL(me->base_href) ||
		       isSNEWS_URL(me->base_href)) {
		StrAllocCat(me->base_href, "/*");
	    } else {
		StrAllocCat(me->base_href, "/");
	    }
	    FREE(temp);
	    FREE(base);

	    me->inBASE = TRUE;
	    me->node_anchor->inBASE = TRUE;
	    StrAllocCopy(me->node_anchor->content_base, me->base_href);
	    /* me->base_href is a valid URL */

	    CTRACE((tfp, "*HTML_BASE: final href=`%s'\n", me->base_href));
	}
	break;

    case HTML_META:
	if (present)
	    LYHandleMETA(me, present, value, include);
	break;

    case HTML_TITLE:
	HTChunkClear(&me->title);
	break;

    case HTML_LINK:
	intern_flag = FALSE;
	if (present && present[HTML_LINK_HREF]) {
	    CHECK_FOR_INTERN(intern_flag, value[HTML_LINK_HREF]);
	    /*
	     * Prepare to do housekeeping on the reference.  - FM
	     */
	    if (isEmpty(value[HTML_LINK_HREF])) {
		Base = (me->inBASE)
		    ? me->base_href
		    : me->node_anchor->address;
		StrAllocCopy(href, Base);
	    } else {
		StrAllocCopy(href, value[HTML_LINK_HREF]);
		(void) LYLegitimizeHREF(me, &href, TRUE, TRUE);

		Base = (me->inBASE && *href != '\0' && *href != '#')
		    ? me->base_href
		    : me->node_anchor->address;
		HTParseALL(&href, Base);
	    }

	    /*
	     * Handle links with a REV attribute.  - FM
	     * Handle REV="made" or REV="owner".  - LM & FM
	     * Handle REL="author" -TD
	     */
	    if (present &&
		((present[HTML_LINK_REV] &&
		  value[HTML_LINK_REV] &&
		  (!strcasecomp("made", value[HTML_LINK_REV]) ||
		   !strcasecomp("owner", value[HTML_LINK_REV]))) ||
		 (present[HTML_LINK_REL] &&
		  value[HTML_LINK_REL] &&
		  (!strcasecomp("author", value[HTML_LINK_REL]))))) {
		/*
		 * Load the owner element.  - FM
		 */
		HTAnchor_setOwner(me->node_anchor, href);
		CTRACE((tfp, "HTML: DOC OWNER '%s' found\n", href));
		FREE(href);

		/*
		 * Load the RevTitle element if a TITLE attribute and value
		 * are present.  - FM
		 */
		if (present && present[HTML_LINK_TITLE] &&
		    value[HTML_LINK_TITLE] &&
		    *value[HTML_LINK_TITLE] != '\0') {
		    StrAllocCopy(title, value[HTML_LINK_TITLE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		    LYTrimHead(title);
		    LYTrimTail(title);
		    if (*title != '\0')
			HTAnchor_setRevTitle(me->node_anchor, title);
		    FREE(title);
		}
		break;
	    }

	    /*
	     * Handle REL links.  - FM
	     */

	    if (present &&
		present[HTML_LINK_REL] && value[HTML_LINK_REL]) {
		/*
		 * Ignore style sheets, for now.  - FM
		 *
		 * lss and css have different syntax - lynx shouldn't try to
		 * parse them now (it tries to parse them as lss, so it exits
		 * with error message on the 1st non-empty line) - VH
		 */
#ifndef USE_COLOR_STYLE
		if (!strcasecomp(value[HTML_LINK_REL], "StyleSheet") ||
		    !strcasecomp(value[HTML_LINK_REL], "Style")) {
		    CTRACE2(TRACE_STYLE,
			    (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE,
			    (tfp, "        StyleSheets not yet implemented.\n"));
		    FREE(href);
		    break;
		}
#endif /* ! USE_COLOR_STYLE */

		/*
		 * Ignore anything not registered in the 28-Mar-95 IETF HTML
		 * 3.0 draft and W3C HTML 3.2 draft, or not appropriate for
		 * Lynx banner links in the expired Maloney and Quin relrev
		 * draft.  We'll make this more efficient when the situation
		 * stabilizes, and for now, we'll treat "Banner" as another
		 * toolbar element.  - FM
		 */
		if (!strcasecomp(value[HTML_LINK_REL], "Home") ||
		    !strcasecomp(value[HTML_LINK_REL], "ToC") ||
		    !strcasecomp(value[HTML_LINK_REL], "Contents") ||
		    !strcasecomp(value[HTML_LINK_REL], "Index") ||
		    !strcasecomp(value[HTML_LINK_REL], "Glossary") ||
		    !strcasecomp(value[HTML_LINK_REL], "Copyright") ||
		    !strcasecomp(value[HTML_LINK_REL], "Help") ||
		    !strcasecomp(value[HTML_LINK_REL], "Search") ||
		    !strcasecomp(value[HTML_LINK_REL], "Bookmark") ||
		    !strcasecomp(value[HTML_LINK_REL], "Banner") ||
		    !strcasecomp(value[HTML_LINK_REL], "Top") ||
		    !strcasecomp(value[HTML_LINK_REL], "Origin") ||
		    !strcasecomp(value[HTML_LINK_REL], "Navigator") ||
		    !strcasecomp(value[HTML_LINK_REL], "Disclaimer") ||
		    !strcasecomp(value[HTML_LINK_REL], "Author") ||
		    !strcasecomp(value[HTML_LINK_REL], "Editor") ||
		    !strcasecomp(value[HTML_LINK_REL], "Publisher") ||
		    !strcasecomp(value[HTML_LINK_REL], "Trademark") ||
		    !strcasecomp(value[HTML_LINK_REL], "Hotlist") ||
		    !strcasecomp(value[HTML_LINK_REL], "Begin") ||
		    !strcasecomp(value[HTML_LINK_REL], "First") ||
		    !strcasecomp(value[HTML_LINK_REL], "End") ||
		    !strcasecomp(value[HTML_LINK_REL], "Last") ||
		    !strcasecomp(value[HTML_LINK_REL], "Documentation") ||
		    !strcasecomp(value[HTML_LINK_REL], "Biblioentry") ||
		    !strcasecomp(value[HTML_LINK_REL], "Bibliography") ||
		    !strcasecomp(value[HTML_LINK_REL], "Start") ||
		    !strcasecomp(value[HTML_LINK_REL], "Appendix")) {
		    StrAllocCopy(title, value[HTML_LINK_REL]);
		    pdoctitle = &title;		/* for setting HTAnchor's title */
		} else if (!strcasecomp(value[HTML_LINK_REL], "Up") ||
			   !strcasecomp(value[HTML_LINK_REL], "Next") ||
			   !strcasecomp(value[HTML_LINK_REL], "Previous") ||
			   !strcasecomp(value[HTML_LINK_REL], "Prev") ||
			   !strcasecomp(value[HTML_LINK_REL], "Child") ||
			   !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
			   !strcasecomp(value[HTML_LINK_REL], "Parent") ||
			   !strcasecomp(value[HTML_LINK_REL], "Meta") ||
			   !strcasecomp(value[HTML_LINK_REL], "URC") ||
			   !strcasecomp(value[HTML_LINK_REL], "Pointer") ||
			   !strcasecomp(value[HTML_LINK_REL], "Translation") ||
			   !strcasecomp(value[HTML_LINK_REL], "Definition") ||
			   !strcasecomp(value[HTML_LINK_REL], "Alternate") ||
			   !strcasecomp(value[HTML_LINK_REL], "Section") ||
			   !strcasecomp(value[HTML_LINK_REL], "Subsection") ||
			   !strcasecomp(value[HTML_LINK_REL], "Chapter")) {
		    StrAllocCopy(title, value[HTML_LINK_REL]);
		    /* not setting target HTAnchor's title, for these
		       links of highly relative character.  Instead,
		       try to remember the REL attribute as a property
		       of the link (but not the destination), in the
		       (otherwise underused) link type in a special format;
		       the LIST page generation code may later use it. - kw */
		    if (!intern_flag) {
			StrAllocCopy(temp, "RelTitle: ");
			StrAllocCat(temp, value[HTML_LINK_REL]);
		    }
#ifndef DISABLE_BIBP
		} else if (!strcasecomp(value[HTML_LINK_REL], "citehost")) {
		    /*  Citehost determination for bibp links. - RDC */
		    HTAnchor_setCitehost(me->node_anchor, href);
		    CTRACE((tfp, "HTML: citehost '%s' found\n", href));
		    FREE(href);
		    break;
#endif
		} else {
		    CTRACE((tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
			    value[HTML_LINK_REL]));
		    FREE(href);
		    break;
		}
	    }
	} else if (present &&
		   present[HTML_LINK_REL] && value[HTML_LINK_REL]) {
	    /*
	     * If no HREF was specified, handle special REL links with
	     * self-designated HREFs.  - FM
	     */
	    if (!strcasecomp(value[HTML_LINK_REL], "Home")) {
		StrAllocCopy(href, LynxHome);
	    } else if (!strcasecomp(value[HTML_LINK_REL], "Help")) {
		StrAllocCopy(href, helpfile);
	    } else if (!strcasecomp(value[HTML_LINK_REL], "Index")) {
		StrAllocCopy(href, indexfile);
	    } else {
		CTRACE((tfp,
			"HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			value[HTML_LINK_REL]));
		break;
	    }
	    StrAllocCopy(title, value[HTML_LINK_REL]);
	    pdoctitle = &title;
	}
	if (href) {
	    /*
	     * Create a title (link name) from the TITLE value, if present, or
	     * default to the REL value that was loaded into title.  - FM
	     */
	    if (present && present[HTML_LINK_TITLE] &&
		non_empty(value[HTML_LINK_TITLE])) {
		StrAllocCopy(title, value[HTML_LINK_TITLE]);
		TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		LYTrimHead(title);
		LYTrimTail(title);
		pdoctitle = &title;
		FREE(temp);	/* forget about recording RelTitle - kw */
	    }
	    if (isEmpty(title)) {
		FREE(href);
		FREE(title);
		break;
	    }

	    if (me->inA) {
		/*
		 * Ugh!  The LINK tag, which is a HEAD element, is in an
		 * Anchor, which is BODY element.  All we can do is close the
		 * Anchor and cross our fingers.  - FM
		 */
		SET_SKIP_STACK(HTML_A);
		HTML_end_element(me, HTML_A, include);
	    }

	    /*
	     * Create anchors for the links that simulate a toolbar.  - FM
	     */
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (temp
						      ? (HTLinkType *)
						      HTAtom_for(temp)
						      : INTERN_LT));	/* Type */
	    FREE(temp);
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
		if (pdoctitle && !HTAnchor_title(dest))
		    HTAnchor_setTitle(dest, *pdoctitle);

		/* Don't allow CHARSET attribute to change *this* document's
		   charset assumption. - kw */
		if (dest == me->node_anchor)
		    dest = NULL;
		if (present[HTML_LINK_CHARSET] &&
		    non_empty(value[HTML_LINK_CHARSET])) {
		    dest_char_set = UCGetLYhndl_byMIME(value[HTML_LINK_CHARSET]);
		    if (dest_char_set < 0)
			dest_char_set = UCLYhndl_for_unrec;
		}
		if (dest && dest_char_set >= 0)
		    HTAnchor_setUCInfoStage(dest, dest_char_set,
					    UCT_STAGE_PARSER,
					    UCT_SETBY_LINK);
	    }
	    UPDATE_STYLE;
	    if (!HText_hasToolbar(me->text) &&
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  LYToolbarName,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
		HText_appendCharacter(me->text, '#');
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_beginAnchor(me->text, me->inUnderline, ID_A);
		HText_endAnchor(me->text, 0);
		HText_setToolbar(me->text);
	    } else {
		/*
		 * Add collapsible space to separate link from previous
		 * generated links.  - kw
		 */
		HTML_put_character(me, ' ');
	    }
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
#ifdef USE_COLOR_STYLE
	    if (present && present[HTML_LINK_CLASS] &&
		non_empty(value[HTML_LINK_CLASS])) {
		char *tmp = 0;

		HTSprintf0(&tmp, "link.%s.%s", value[HTML_LINK_CLASS], title);
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.link: using style <%s>\n", tmp));

		HText_characterStyle(me->text, hash_code(tmp), STACK_ON);
		HTML_put_string(me, title);
		HTML_put_string(me, " (");
		HTML_put_string(me, value[HTML_LINK_CLASS]);
		HTML_put_string(me, ")");
		HText_characterStyle(me->text, hash_code(tmp), STACK_OFF);
		FREE(tmp);
	    } else
#endif
		HTML_put_string(me, title);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	}
	FREE(href);
	FREE(title);
	break;

    case HTML_ISINDEX:
	if (((present)) &&
	    ((present[HTML_ISINDEX_HREF] && value[HTML_ISINDEX_HREF]) ||
	     (present[HTML_ISINDEX_ACTION] && value[HTML_ISINDEX_ACTION]))) {
	    /*
	     * Lynx was supporting ACTION, which never made it into the HTML
	     * 2.0 specs.  HTML 3.0 uses HREF, so we'll use that too, but allow
	     * use of ACTION as an alternate until people have fully switched
	     * over.  - FM
	     */
	    if (present[HTML_ISINDEX_HREF] && value[HTML_ISINDEX_HREF])
		StrAllocCopy(href, value[HTML_ISINDEX_HREF]);
	    else
		StrAllocCopy(href, value[HTML_ISINDEX_ACTION]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    Base = (me->inBASE && *href != '\0' && *href != '#')
		? me->base_href
		: me->node_anchor->address;
	    HTParseALL(&href, Base);
	    HTAnchor_setIndex(me->node_anchor, href);
	    FREE(href);

	} else {
	    Base = (me->inBASE) ?
		me->base_href : me->node_anchor->address;
	    HTAnchor_setIndex(me->node_anchor, Base);
	}
	/*
	 * Support HTML 3.0 PROMPT attribute.  - FM
	 */
	if (present &&
	    present[HTML_ISINDEX_PROMPT] &&
	    non_empty(value[HTML_ISINDEX_PROMPT])) {
	    StrAllocCopy(temp, value[HTML_ISINDEX_PROMPT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&temp, TRUE, FALSE);
	    LYTrimHead(temp);
	    LYTrimTail(temp);
	    if (*temp != '\0') {
		StrAllocCat(temp, " ");
		HTAnchor_setPrompt(me->node_anchor, temp);
	    } else {
		HTAnchor_setPrompt(me->node_anchor, ENTER_DATABASE_QUERY);
	    }
	    FREE(temp);
	} else {
	    HTAnchor_setPrompt(me->node_anchor, ENTER_DATABASE_QUERY);
	}
	break;

    case HTML_NEXTID:
	break;

    case HTML_STYLE:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkClear(&me->style_block);
	break;

    case HTML_SCRIPT:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkClear(&me->script);
	break;

    case HTML_BODY:
	CHECK_ID(HTML_BODY_ID);
	if (HText_hasToolbar(me->text))
	    HText_appendParagraph(me->text);
	break;

    case HTML_FRAMESET:
	break;

    case HTML_FRAME:
	if (present && present[HTML_FRAME_NAME] &&
	    non_empty(value[HTML_FRAME_NAME])) {
	    StrAllocCopy(id_string, value[HTML_FRAME_NAME]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&id_string, TRUE, FALSE);
	    LYTrimHead(id_string);
	    LYTrimTail(id_string);
	}
	if (present && present[HTML_FRAME_SRC] &&
	    non_empty(value[HTML_FRAME_SRC])) {
	    StrAllocCopy(href, value[HTML_FRAME_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    if (me->inA) {
		SET_SKIP_STACK(HTML_A);
		HTML_end_element(me, HTML_A, include);
	    }
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    CAN_JUSTIFY_PUSH(FALSE);
	    LYEnsureSingleSpace(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "FRAME:");
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');

	    me->in_word = NO;
	    CHECK_ID(HTML_FRAME_ID);
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, (id_string ? id_string : href));
	    FREE(href);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	    LYEnsureSingleSpace(me);
	    CAN_JUSTIFY_POP;
	} else {
	    CHECK_ID(HTML_FRAME_ID);
	}
	FREE(id_string);
	break;

    case HTML_NOFRAMES:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	break;

    case HTML_IFRAME:
	if (present && present[HTML_IFRAME_NAME] &&
	    non_empty(value[HTML_IFRAME_NAME])) {
	    StrAllocCopy(id_string, value[HTML_IFRAME_NAME]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&id_string, TRUE, FALSE);
	    LYTrimHead(id_string);
	    LYTrimTail(id_string);
	}
	if (present && present[HTML_IFRAME_SRC] &&
	    non_empty(value[HTML_IFRAME_SRC])) {
	    StrAllocCopy(href, value[HTML_IFRAME_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    if (me->inA)
		HTML_end_element(me, HTML_A, include);

	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    LYEnsureDoubleSpace(me);
	    CAN_JUSTIFY_PUSH_F
		LYResetParagraphAlignment(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "IFRAME:");
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');

	    me->in_word = NO;
	    CHECK_ID(HTML_IFRAME_ID);
	    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, (id_string ? id_string : href));
	    FREE(href);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    HText_endAnchor(me->text, 0);
	    LYEnsureSingleSpace(me);
	    CAN_JUSTIFY_POP;
	} else {
	    CHECK_ID(HTML_IFRAME_ID);
	}
	FREE(id_string);
	break;

    case HTML_BANNER:
    case HTML_MARQUEE:
	change_paragraph_style(me, styles[HTML_BANNER]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	/*
	 * Treat this as a toolbar if we don't have one yet, and we are in the
	 * first half of the first page.  - FM
	 */
	if ((!HText_hasToolbar(me->text) &&
	     HText_getLines(me->text) < (display_lines / 2)) &&
	    (ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
					      LYToolbarName,	/* Tag */
					      NULL,	/* Addresss */
					      (HTLinkType *) 0))) {	/* Type */
	    HText_beginAnchor(me->text, me->inUnderline, ID_A);
	    HText_endAnchor(me->text, 0);
	    HText_setToolbar(me->text);
	}
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_CENTER:
    case HTML_DIV:
	if (me->Division_Level < (MAX_NESTING - 1)) {
	    me->Division_Level++;
	} else {
	    CTRACE((tfp,
		    "HTML: ****** Maximum nesting of %d divisions exceeded!\n",
		    MAX_NESTING));
	}
	if (me->inP)
	    LYEnsureSingleSpace(me);	/* always at least break line - kw */
	if (ElementNumber == HTML_CENTER) {
	    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
	    change_paragraph_style(me, styles[HTML_DCENTER]);
	    UPDATE_STYLE;
	    me->current_default_alignment = styles[HTML_DCENTER]->alignment;
	} else if (me->List_Nesting_Level >= 0 &&
		   !(present && present[HTML_DIV_ALIGN] &&
		     value[HTML_DIV_ALIGN] &&
		     (!strcasecomp(value[HTML_DIV_ALIGN], "center") ||
		      !strcasecomp(value[HTML_DIV_ALIGN], "right")))) {
	    if (present && present[HTML_DIV_ALIGN])
		me->current_default_alignment = HT_LEFT;
	    else if (me->Division_Level == 0)
		me->current_default_alignment = HT_LEFT;
	    else if (me->sp[0].tag_number == HTML_UL ||
		     me->sp[0].tag_number == HTML_OL ||
		     me->sp[0].tag_number == HTML_MENU ||
		     me->sp[0].tag_number == HTML_DIR ||
		     me->sp[0].tag_number == HTML_LI ||
		     me->sp[0].tag_number == HTML_LH ||
		     me->sp[0].tag_number == HTML_DD)
		me->current_default_alignment = HT_LEFT;
	    LYHandlePlike(me, present, value, include, HTML_DIV_ALIGN, TRUE);
	    me->DivisionAlignments[me->Division_Level] = (short)
		me->current_default_alignment;
	} else if (present && present[HTML_DIV_ALIGN] &&
		   non_empty(value[HTML_DIV_ALIGN])) {
	    if (!strcasecomp(value[HTML_DIV_ALIGN], "center")) {
		me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		change_paragraph_style(me, styles[HTML_DCENTER]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DCENTER]->alignment;
	    } else if (!strcasecomp(value[HTML_DIV_ALIGN], "right")) {
		me->DivisionAlignments[me->Division_Level] = HT_RIGHT;
		change_paragraph_style(me, styles[HTML_DRIGHT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DRIGHT]->alignment;
	    } else {
		me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		change_paragraph_style(me, styles[HTML_DLEFT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DLEFT]->alignment;
	    }
	} else {
	    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
	    change_paragraph_style(me, styles[HTML_DLEFT]);
	    UPDATE_STYLE;
	    me->current_default_alignment = styles[HTML_DLEFT]->alignment;
	}
	CHECK_ID(HTML_DIV_ID);
	break;

    case HTML_H1:
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
	/*
	 * Close the previous style if not done by HTML doc.  Added to get rid
	 * of core dumps in BAD HTML on the net.
	 *              GAB 07-07-94
	 * But then again, these are actually allowed to nest.  I guess I have
	 * to depend on the HTML writers correct style.
	 *              GAB 07-12-94
	 if (i_prior_style != -1) {
	 HTML_end_element(me, i_prior_style);
	 }
	 i_prior_style = ElementNumber;
	 */

	/*
	 * Check whether we have an H# in a list, and if so, treat it as an LH. 
	 * - FM
	 */
	if ((me->List_Nesting_Level >= 0) &&
	    (me->sp[0].tag_number == HTML_UL ||
	     me->sp[0].tag_number == HTML_OL ||
	     me->sp[0].tag_number == HTML_MENU ||
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI)) {
	    if (HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY) {
		ElementNumber = HTML_LH;
	    } else {
		me->new_style = me->sp[0].style;
		ElementNumber = (HTMLElement) me->sp[0].tag_number;
		UPDATE_STYLE;
	    }
	    /*
	     * Some authors use H# headers as a substitute for FONT, so check
	     * if this one immediately followed an LI.  If so, both me->inP and
	     * me->in_word will be FALSE (though the line might not be empty
	     * due to a bullet and/or nbsp) and we can assume it is just for a
	     * FONT change.  We thus will not create another line break nor add
	     * to the current left indentation.  - FM
	     */
	    if (!(me->inP == FALSE && me->in_word == NO)) {
		HText_appendParagraph(me->text);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
		me->in_word = NO;
		me->inP = FALSE;
	    }
	    CHECK_ID(HTML_H_ID);
	    break;
	}

	if (present && present[HTML_H_ALIGN] &&
	    non_empty(value[HTML_H_ALIGN])) {
	    if (!strcasecomp(value[HTML_H_ALIGN], "center"))
		change_paragraph_style(me, styles[HTML_HCENTER]);
	    else if (!strcasecomp(value[HTML_H_ALIGN], "right"))
		change_paragraph_style(me, styles[HTML_HRIGHT]);
	    else if (!strcasecomp(value[HTML_H_ALIGN], "left") ||
		     !strcasecomp(value[HTML_H_ALIGN], "justify"))
		change_paragraph_style(me, styles[HTML_HLEFT]);
	    else
		change_paragraph_style(me, styles[ElementNumber]);
	} else if (me->Division_Level >= 0) {
	    if (me->DivisionAlignments[me->Division_Level] == HT_CENTER) {
		change_paragraph_style(me, styles[HTML_HCENTER]);
	    } else if (me->DivisionAlignments[me->Division_Level] == HT_LEFT) {
		change_paragraph_style(me, styles[HTML_HLEFT]);
	    } else if (me->DivisionAlignments[me->Division_Level] == HT_RIGHT) {
		change_paragraph_style(me, styles[HTML_HRIGHT]);
	    }
	} else {
	    change_paragraph_style(me, styles[ElementNumber]);
	}
	UPDATE_STYLE;
	CHECK_ID(HTML_H_ID);

	if ((bold_headers == TRUE ||
	     (ElementNumber == HTML_H1 && bold_H1 == TRUE)) &&
	    (styles[ElementNumber]->font & HT_BOLD)) {
	    if (me->inBoldA == FALSE && me->inBoldH == FALSE) {
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    }
	    me->inBoldH = TRUE;
	}
	break;

    case HTML_P:
	LYHandlePlike(me, present, value, include, HTML_P_ALIGN, TRUE);
	CHECK_ID(HTML_P_ID);
	break;

    case HTML_BR:
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	/* Add a \r (new line) if these three conditions are true:
	 *   1. We are not collapsing BR's, and
	 *   2. The previous line has text on it, or
	 *   3. This line has text on it.
	 * Otherwise, don't do anything. -DH 980814, TD 980827
	 */
	if ((LYCollapseBRs == FALSE &&
	     !HText_PreviousLineEmpty(me->text, FALSE)) ||
	    !HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
	    HText_appendCharacter(me->text, '\r');
	}
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_WBR:
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	HText_setBreakPoint(me->text);
	break;

    case HTML_HY:
    case HTML_SHY:
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	HText_appendCharacter(me->text, LY_SOFT_HYPHEN);
	break;

    case HTML_HR:
	{
	    int width;

	    /*
	     * Start a new line only if we had printable characters following
	     * the previous newline, or remove the previous line if both it and
	     * the last line are blank.  - FM
	     */
	    UPDATE_STYLE;
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_appendCharacter(me->text, '\r');
	    } else if (HText_PreviousLineEmpty(me->text, FALSE)) {
		HText_RemovePreviousLine(me->text);
	    }
	    me->in_word = NO;
	    me->inP = FALSE;

	    /*
	     * Add an ID link if needed.  - FM
	     */
	    CHECK_ID(HTML_HR_ID);

	    /*
	     * Center lines within the current margins, if a right or left
	     * ALIGNment is not specified.  If WIDTH="#%" is given and not
	     * garbage, use that to calculate the width, otherwise use the
	     * default width.  - FM
	     */
	    if (present && present[HTML_HR_ALIGN] && value[HTML_HR_ALIGN]) {
		if (!strcasecomp(value[HTML_HR_ALIGN], "right")) {
		    me->sp->style->alignment = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_HR_ALIGN], "left")) {
		    me->sp->style->alignment = HT_LEFT;
		} else {
		    me->sp->style->alignment = HT_CENTER;
		}
	    } else {
		me->sp->style->alignment = HT_CENTER;
	    }
	    width = LYcolLimit -
		me->new_style->leftIndent - me->new_style->rightIndent;
	    if (present && present[HTML_HR_WIDTH] && value[HTML_HR_WIDTH] &&
		isdigit(UCH(*value[HTML_HR_WIDTH])) &&
		value[HTML_HR_WIDTH][strlen(value[HTML_HR_WIDTH]) - 1] == '%') {
		char *percent = NULL;
		int Percent, Width;

		StrAllocCopy(percent, value[HTML_HR_WIDTH]);
		percent[strlen(percent) - 1] = '\0';
		Percent = atoi(percent);
		if (Percent > 100 || Percent < 1)
		    width -= 5;
		else {
		    Width = (width * Percent) / 100;
		    if (Width < 1)
			width = 1;
		    else
			width = Width;
		}
		FREE(percent);
	    } else {
		width -= 5;
	    }
	    for (i = 0; i < width; i++)
		HTML_put_character(me, '_');
	    HText_appendCharacter(me->text, '\r');
	    me->in_word = NO;
	    me->inP = FALSE;

	    /*
	     * Reset the alignment appropriately for the division and/or block. 
	     * - FM
	     */
	    if (me->List_Nesting_Level < 0 &&
		me->Division_Level >= 0) {
		me->sp->style->alignment =
		    me->DivisionAlignments[me->Division_Level];
	    } else if (me->sp->style->id == ST_HeadingCenter ||
		       me->sp->style->id == ST_Heading1) {
		me->sp->style->alignment = HT_CENTER;
	    } else if (me->sp->style->id == ST_HeadingRight) {
		me->sp->style->alignment = HT_RIGHT;
	    } else {
		me->sp->style->alignment = HT_LEFT;
	    }

	    /*
	     * Add a blank line and set the second line indentation for lists
	     * and addresses, or a paragraph separator for other blocks.  - FM
	     */
	    if (me->List_Nesting_Level >= 0 ||
		me->sp[0].tag_number == HTML_ADDRESS) {
		HText_setLastChar(me->text, ' ');	/* absorb white space */
		HText_appendCharacter(me->text, '\r');
	    } else {
		HText_appendParagraph(me->text);
	    }
	}
	break;

    case HTML_TAB:
	if (!present) {		/* Bad tag.  Must have at least one attribute. - FM */
	    CTRACE((tfp, "HTML: TAB tag has no attributes.  Ignored.\n"));
	    break;
	}
	/*
	 * If page author is using TAB within a TABLE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
	 */
	HText_cancelStbl(me->text);
	UPDATE_STYLE;

	CANT_JUSTIFY_THIS_LINE;
	if (present[HTML_TAB_ALIGN] && value[HTML_TAB_ALIGN] &&
	    (strcasecomp(value[HTML_TAB_ALIGN], "left") ||
	     !(present[HTML_TAB_TO] || present[HTML_TAB_INDENT]))) {
	    /*
	     * Just ensure a collapsible space, until we have the ALIGN and DP
	     * attributes implemented.  - FM
	     */
	    HTML_put_character(me, ' ');
	    CTRACE((tfp,
		    "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));

	} else if (!LYoverride_default_alignment(me) &&
		   me->current_default_alignment != HT_LEFT) {
	    /*
	     * Just ensure a collapsible space, until we can replace
	     * HText_getCurrentColumn() in GridText.c with code which doesn't
	     * require that the alignment be HT_LEFT.  - FM
	     */
	    HTML_put_character(me, ' ');
	    CTRACE((tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n"));

	} else if ((present[HTML_TAB_TO] &&
		    non_empty(value[HTML_TAB_TO])) ||
		   (present[HTML_TAB_INDENT] &&
		    value[HTML_TAB_INDENT] &&
		    isdigit(UCH(*value[HTML_TAB_INDENT])))) {
	    int column, target = -1;
	    int enval = 2;

	    column = HText_getCurrentColumn(me->text);
	    if (present[HTML_TAB_TO] &&
		non_empty(value[HTML_TAB_TO])) {
		/*
		 * TO has priority over INDENT if both are present.  - FM
		 */
		StrAllocCopy(temp, value[HTML_TAB_TO]);
		TRANSLATE_AND_UNESCAPE_TO_STD(&temp);
		if (*temp) {
		    target = HText_getTabIDColumn(me->text, temp);
		}
	    } else if (isEmpty(temp) && present[HTML_TAB_INDENT] &&
		       value[HTML_TAB_INDENT] &&
		       isdigit(UCH(*value[HTML_TAB_INDENT]))) {
		/*
		 * The INDENT value is in "en" (enval per column) units.
		 * Divide it by enval, rounding odd values up.  - FM
		 */
		target =
		    (int) (((1.0 * atoi(value[HTML_TAB_INDENT])) / enval) + (0.5));
	    }
	    FREE(temp);
	    /*
	     * If we are being directed to a column too far to the left or
	     * right, just add a collapsible space, otherwise, add the
	     * appropriate number of spaces.  - FM
	     */

	    if (target < column ||
		target > HText_getMaximumColumn(me->text)) {
		HTML_put_character(me, ' ');
		CTRACE((tfp,
			"HTML: Column out of bounds.  Using space instead of TAB.\n"));
	    } else {
		for (i = column; i < target; i++)
		    HText_appendCharacter(me->text, ' ');
		HText_setLastChar(me->text, ' ');	/* absorb white space */
	    }
	}
	me->in_word = NO;

	/*
	 * If we have an ID attribute, save it together with the value of the
	 * column we've reached.  - FM
	 */
	if (present[HTML_TAB_ID] &&
	    non_empty(value[HTML_TAB_ID])) {
	    StrAllocCopy(temp, value[HTML_TAB_ID]);
	    TRANSLATE_AND_UNESCAPE_TO_STD(&temp);
	    if (*temp)
		HText_setTabID(me->text, temp);
	    FREE(temp);
	}
	break;

    case HTML_BASEFONT:
	break;

    case HTML_FONT:

	/*
	 * FONT *may* have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c *may* check for a FONT end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack).  Or this may have been
	 * really a </FONT> end tag, for which some incarnations of SGML.c
	 * would fake a <FONT> start tag instead.  - fm & kw
	 *
	 * But if we have an open FONT, DON'T close that one now, since FONT
	 * tags can be legally nested AFAIK, and Lynx currently doesn't do
	 * anything with them anyway...  - kw
	 */
#ifdef NOTUSED_FOTEMODS
	if (me->inFONT == TRUE)
	    HTML_end_element(me, HTML_FONT, &include);
#endif /* NOTUSED_FOTEMODS */

	/*
	 * Set flag to know we are in a FONT container, and add code to do
	 * something about it, someday.  - FM
	 */
	me->inFONT = TRUE;
	break;

    case HTML_B:		/* Physical character highlighting */
    case HTML_BLINK:
    case HTML_I:
    case HTML_U:

    case HTML_CITE:		/* Logical character highlighting */
    case HTML_EM:
    case HTML_STRONG:
	UPDATE_STYLE;
	me->Underline_Level++;
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Ignore this if inside of a bold anchor or header.  Can't display
	 * both underline and bold at same time.
	 */
	if (me->inBoldA == TRUE || me->inBoldH == TRUE) {
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
	    break;
	}
	if (me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	    CTRACE((tfp, "Beginning underline\n"));
	} else {
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
	}
	break;

    case HTML_ABBR:		/* Miscellaneous character containers */
    case HTML_ACRONYM:
    case HTML_AU:
    case HTML_AUTHOR:
    case HTML_BIG:
    case HTML_CODE:
    case HTML_DFN:
    case HTML_KBD:
    case HTML_SAMP:
    case HTML_SMALL:
    case HTML_TT:
    case HTML_VAR:
	CHECK_ID(HTML_GEN_ID);
	break;			/* ignore */

    case HTML_SUP:
	HText_appendCharacter(me->text, '^');
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, '[');
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_DEL:
    case HTML_S:
    case HTML_STRIKE:
	CHECK_ID(HTML_GEN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "[DEL:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_INS:
	CHECK_ID(HTML_GEN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "[INS:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_Q:
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
	 */
	if (!(me->Quote_Level & 1))
	    HTML_put_character(me, '"');
	else
	    HTML_put_character(me, '`');
	me->Quote_Level++;
	break;

    case HTML_PRE:		/* Formatted text */
	/*
	 * Set our inPRE flag to FALSE so that a newline immediately following
	 * the PRE start tag will be ignored.  HTML_put_character() will set it
	 * to TRUE when the first character within the PRE block is received. 
	 * - FM
	 */
	me->inPRE = FALSE;
	/* FALLTHRU */
    case HTML_LISTING:		/* Literal text */
	/* FALLTHRU */
    case HTML_XMP:
	/* FALLTHRU */
    case HTML_PLAINTEXT:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	CHECK_ID(HTML_GEN_ID);
	if (me->comment_end)
	    HText_appendText(me->text, me->comment_end);
	break;

    case HTML_BLOCKQUOTE:
    case HTML_BQ:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_BQ_ID);
	break;

    case HTML_NOTE:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_NOTE_ID);
	{
	    char *note = NULL;

	    /*
	     * Indicate the type of NOTE.
	     */
	    if (present && present[HTML_NOTE_CLASS] &&
		value[HTML_NOTE_CLASS] &&
		(!strcasecomp(value[HTML_NOTE_CLASS], "CAUTION") ||
		 !strcasecomp(value[HTML_NOTE_CLASS], "WARNING"))) {
		StrAllocCopy(note, value[HTML_NOTE_CLASS]);
		LYUpperCase(note);
		StrAllocCat(note, ":");
	    } else if (present && present[HTML_NOTE_ROLE] &&
		       value[HTML_NOTE_ROLE] &&
		       (!strcasecomp(value[HTML_NOTE_ROLE], "CAUTION") ||
			!strcasecomp(value[HTML_NOTE_ROLE], "WARNING"))) {
		StrAllocCopy(note, value[HTML_NOTE_ROLE]);
		LYUpperCase(note);
		StrAllocCat(note, ":");
	    } else {
		StrAllocCopy(note, "NOTE:");
	    }
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, note);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');
	    CAN_JUSTIFY_START;
	    FREE(note);
	}
	CAN_JUSTIFY_START;
	me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_ADDRESS:
	if (me->List_Nesting_Level < 0) {
	    change_paragraph_style(me, styles[ElementNumber]);
	    UPDATE_STYLE;
	    if (me->sp->tag_number == (int) ElementNumber)
		LYEnsureDoubleSpace(me);
	} else {
	    LYHandlePlike(me, present, value, include, -1, TRUE);
	}
	CHECK_ID(HTML_ADDRESS_ID);
	break;

    case HTML_DL:
	me->List_Nesting_Level++;	/* increment the List nesting level */
	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, present && present[HTML_DL_COMPACT]
				   ? styles[HTML_DLC] : styles[HTML_DL]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, present && present[HTML_DL_COMPACT]
				   ? styles[HTML_DLC6] : styles[HTML_DL6]);

	} else {
	    change_paragraph_style(me, present && present[HTML_DL_COMPACT]
				   ? styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]
				   : styles[(HTML_DL1 - 1) + me->List_Nesting_Level]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_DL_ID);

	break;

    case HTML_DLC:
	me->List_Nesting_Level++;	/* increment the List nesting level */
	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, styles[HTML_DLC]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, styles[HTML_DLC6]);

	} else {
	    change_paragraph_style(me,
				   styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_DL_ID);
	break;

    case HTML_DT:
	CHECK_ID(HTML_GEN_ID);
	if (!me->style_change) {
	    BOOL in_line_1 = HText_inLineOne(me->text);
	    HTCoord saved_spaceBefore = me->sp->style->spaceBefore;
	    HTCoord saved_spaceAfter = me->sp->style->spaceAfter;

	    /*
	     * If there are several DT elements and this is not the first, and
	     * the preceding DT element's first (and normally only) line has
	     * not yet been ended, suppress intervening blank line by
	     * temporarily modifying the paragraph style in place.  Ugly but
	     * there's ample precedence.  - kw
	     */
	    if (in_line_1) {
		me->sp->style->spaceBefore = 0;		/* temporary change */
		me->sp->style->spaceAfter = 0;	/* temporary change */
	    }
	    HText_appendParagraph(me->text);
	    me->sp->style->spaceBefore = saved_spaceBefore;	/* undo */
	    me->sp->style->spaceAfter = saved_spaceAfter;	/* undo */
	    me->in_word = NO;
	    me->sp->style->alignment = HT_LEFT;
	}
	me->inP = FALSE;
	break;

    case HTML_DD:
	CHECK_ID(HTML_GEN_ID);
	HText_setLastChar(me->text, ' ');	/* absorb white space */
	if (!me->style_change) {
	    if (!HText_LastLineEmpty(me->text, FALSE)) {
		HText_appendCharacter(me->text, '\r');
	    } else {
		HText_NegateLineOne(me->text);
	    }
	} else {
	    UPDATE_STYLE;
	    HText_appendCharacter(me->text, '\t');
	}
	me->sp->style->alignment = HT_LEFT;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_OL:
	/*
	 * Set the default TYPE.
	 */
	me->OL_Type[(me->List_Nesting_Level < 11 ?
		     me->List_Nesting_Level + 1 : 11)] = '1';

	/*
	 * Check whether we have a starting sequence number, or want to
	 * continue the numbering from a previous OL in this nest.  - FM
	 */
	if (present && (present[HTML_OL_SEQNUM] || present[HTML_OL_START])) {
	    int seqnum;

	    /*
	     * Give preference to the valid HTML 3.0 SEQNUM attribute name over
	     * the Netscape START attribute name (too bad the Netscape
	     * developers didn't read the HTML 3.0 specs before re-inventing
	     * the "wheel" as "we'll").  - FM
	     */
	    if (present[HTML_OL_SEQNUM] &&
		non_empty(value[HTML_OL_SEQNUM])) {
		seqnum = atoi(value[HTML_OL_SEQNUM]);
	    } else if (present[HTML_OL_START] &&
		       non_empty(value[HTML_OL_START])) {
		seqnum = atoi(value[HTML_OL_START]);
	    } else {
		seqnum = 1;
	    }

	    /*
	     * Don't allow negative numbers less than or equal to our flags, or
	     * numbers less than 1 if an Alphabetic or Roman TYPE.  - FM
	     */
	    if (present[HTML_OL_TYPE] && value[HTML_OL_TYPE]) {
		if (*value[HTML_OL_TYPE] == 'A') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'A';
		    if (seqnum < 1)
			seqnum = 1;
		} else if (*value[HTML_OL_TYPE] == 'a') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'a';
		    if (seqnum < 1)
			seqnum = 1;
		} else if (*value[HTML_OL_TYPE] == 'I') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'I';
		    if (seqnum < 1)
			seqnum = 1;
		} else if (*value[HTML_OL_TYPE] == 'i') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'i';
		    if (seqnum < 1)
			seqnum = 1;
		} else {
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		}
	    } else if (seqnum <= OL_VOID) {
		seqnum = OL_VOID + 1;
	    }

	    me->OL_Counter[(me->List_Nesting_Level < 11 ?
			    me->List_Nesting_Level + 1 : 11)] = seqnum;

	} else if (present && present[HTML_OL_CONTINUE]) {
	    me->OL_Counter[me->List_Nesting_Level < 11 ?
			   me->List_Nesting_Level + 1 : 11] = OL_CONTINUE;

	} else {
	    me->OL_Counter[(me->List_Nesting_Level < 11 ?
			    me->List_Nesting_Level + 1 : 11)] = 1;
	    if (present && present[HTML_OL_TYPE] && value[HTML_OL_TYPE]) {
		if (*value[HTML_OL_TYPE] == 'A') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'A';
		} else if (*value[HTML_OL_TYPE] == 'a') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'a';
		} else if (*value[HTML_OL_TYPE] == 'I') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'I';
		} else if (*value[HTML_OL_TYPE] == 'i') {
		    me->OL_Type[(me->List_Nesting_Level < 11 ?
				 me->List_Nesting_Level + 1 : 11)] = 'i';
		}
	    }
	}
	me->List_Nesting_Level++;

	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, styles[ElementNumber]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, styles[HTML_OL6]);

	} else {
	    change_paragraph_style(me,
				   styles[HTML_OL1 + me->List_Nesting_Level - 1]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_OL_ID);
	break;

    case HTML_UL:
	me->List_Nesting_Level++;

	if (me->List_Nesting_Level <= 0) {
	    if (!(present && present[HTML_UL_PLAIN]) &&
		!(present && present[HTML_UL_TYPE] &&
		  value[HTML_UL_TYPE] &&
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
		change_paragraph_style(me, styles[ElementNumber]);
	    } else {
		change_paragraph_style(me, styles[HTML_DIR]);
		ElementNumber = HTML_DIR;
	    }

	} else if (me->List_Nesting_Level >= 6) {
	    if (!(present && present[HTML_UL_PLAIN]) &&
		!(present && present[HTML_UL_TYPE] &&
		  value[HTML_UL_TYPE] &&
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
		change_paragraph_style(me, styles[HTML_OL6]);
	    } else {
		change_paragraph_style(me, styles[HTML_MENU6]);
		ElementNumber = HTML_DIR;
	    }

	} else {
	    if (!(present && present[HTML_UL_PLAIN]) &&
		!(present && present[HTML_UL_TYPE] &&
		  value[HTML_UL_TYPE] &&
		  0 == strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
		change_paragraph_style(me,
				       styles[HTML_OL1 + me->List_Nesting_Level
					      - 1]);
	    } else {
		change_paragraph_style(me,
				       styles[HTML_MENU1 + me->List_Nesting_Level
					      - 1]);
		ElementNumber = HTML_DIR;
	    }
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_UL_ID);
	break;

    case HTML_MENU:
    case HTML_DIR:
	me->List_Nesting_Level++;

	if (me->List_Nesting_Level <= 0) {
	    change_paragraph_style(me, styles[ElementNumber]);

	} else if (me->List_Nesting_Level >= 6) {
	    change_paragraph_style(me, styles[HTML_MENU6]);

	} else {
	    change_paragraph_style(me,
				   styles[HTML_MENU1 + me->List_Nesting_Level
					  - 1]);
	}
	UPDATE_STYLE;		/* update to the new style */
	CHECK_ID(HTML_UL_ID);
	break;

    case HTML_LH:
	UPDATE_STYLE;		/* update to the new style */
	HText_appendParagraph(me->text);
	CHECK_ID(HTML_GEN_ID);
	HTML_put_character(me, HT_NON_BREAK_SPACE);
	HText_setLastChar(me->text, ' ');
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_LI:
	UPDATE_STYLE;		/* update to the new style */
	HText_appendParagraph(me->text);
	me->sp->style->alignment = HT_LEFT;
	CHECK_ID(HTML_LI_ID);
	{
	    int surrounding_tag_number = me->sp[0].tag_number;

	    /*
	     * No, a LI should never occur directly within another LI, but this
	     * may result from incomplete error recovery.  So check one more
	     * surrounding level in this case.  - kw
	     */
	    if (surrounding_tag_number == HTML_LI &&
		me->sp < (me->stack + MAX_NESTING - 1))
		surrounding_tag_number = me->sp[1].tag_number;
	    if (surrounding_tag_number == HTML_OL) {
		char number_string[20];
		int counter, seqnum;
		char seqtype;

		counter = me->List_Nesting_Level < 11 ?
		    me->List_Nesting_Level : 11;
		if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		    if (*value[HTML_LI_TYPE] == '1') {
			me->OL_Type[counter] = '1';
		    } else if (*value[HTML_LI_TYPE] == 'A') {
			me->OL_Type[counter] = 'A';
		    } else if (*value[HTML_LI_TYPE] == 'a') {
			me->OL_Type[counter] = 'a';
		    } else if (*value[HTML_LI_TYPE] == 'I') {
			me->OL_Type[counter] = 'I';
		    } else if (*value[HTML_LI_TYPE] == 'i') {
			me->OL_Type[counter] = 'i';
		    }
		}
		if (present && present[HTML_LI_VALUE] &&
		    ((value[HTML_LI_VALUE] != NULL) &&
		     (*value[HTML_LI_VALUE] != '\0')) &&
		    ((isdigit(UCH(*value[HTML_LI_VALUE]))) ||
		     (*value[HTML_LI_VALUE] == '-' &&
		      isdigit(UCH(*(value[HTML_LI_VALUE] + 1)))))) {
		    seqnum = atoi(value[HTML_LI_VALUE]);
		    if (seqnum <= OL_VOID)
			seqnum = OL_VOID + 1;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1)
			seqnum = 1;
		    me->OL_Counter[counter] = seqnum + 1;
		} else if (me->OL_Counter[counter] >= OL_VOID) {
		    seqnum = me->OL_Counter[counter]++;
		    seqtype = me->OL_Type[counter];
		    if (seqtype != '1' && seqnum < 1) {
			seqnum = 1;
			me->OL_Counter[counter] = seqnum + 1;
		    }
		} else {
		    seqnum = me->Last_OL_Count + 1;
		    seqtype = me->Last_OL_Type;
		    for (i = (counter - 1); i >= 0; i--) {
			if (me->OL_Counter[i] > OL_VOID) {
			    seqnum = me->OL_Counter[i]++;
			    seqtype = me->OL_Type[i];
			    i = 0;
			}
		    }
		}
		if (seqtype == 'A') {
		    strcpy(number_string, LYUppercaseA_OL_String(seqnum));
		} else if (seqtype == 'a') {
		    strcpy(number_string, LYLowercaseA_OL_String(seqnum));
		} else if (seqtype == 'I') {
		    strcpy(number_string, LYUppercaseI_OL_String(seqnum));
		} else if (seqtype == 'i') {
		    strcpy(number_string, LYLowercaseI_OL_String(seqnum));
		} else {
		    sprintf(number_string, "%2d.", seqnum);
		}
		me->Last_OL_Count = seqnum;
		me->Last_OL_Type = seqtype;
		/*
		 * Hack, because there is no append string!
		 */
		for (i = 0; number_string[i] != '\0'; i++)
		    if (number_string[i] == ' ')
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		    else
			HTML_put_character(me, number_string[i]);

		/*
		 * Use HTML_put_character so that any other spaces coming
		 * through will be collapsed.  We'll use nbsp, so it won't
		 * break at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else if (surrounding_tag_number == HTML_UL) {
		/*
		 * Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		switch (me->List_Nesting_Level % 7) {
		case 0:
		    HTML_put_character(me, '*');
		    break;
		case 1:
		    HTML_put_character(me, '+');
		    break;
		case 2:
		    HTML_put_character(me, 'o');
		    break;
		case 3:
		    HTML_put_character(me, '#');
		    break;
		case 4:
		    HTML_put_character(me, '@@');
		    break;
		case 5:
		    HTML_put_character(me, '-');
		    break;
		case 6:
		    HTML_put_character(me, '=');
		    break;

		}
		/*
		 * Keep using HTML_put_character so that any other spaces
		 * coming through will be collapsed.  We use nbsp, so we won't
		 * wrap at the spacing character if there are no spaces in the
		 * subsequent text up to the right margin, but will declare it
		 * as a normal space to ensure collapsing if a normal space
		 * does immediately follow it.  - FM
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    } else {
		/*
		 * Hack, because there is no append string!
		 */
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HTML_put_character(me, HT_NON_BREAK_SPACE);
		HText_setLastChar(me->text, ' ');
	    }
	}
	CAN_JUSTIFY_START;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_SPAN:
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
	 */
	break;

    case HTML_BDO:
	CHECK_ID(HTML_GEN_ID);
	/*
	 * Should check DIR (and LANG) attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * and do something here.  - FM
	 */
	break;

    case HTML_SPOT:
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_FN:
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
	CHECK_ID(HTML_GEN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "FOOTNOTE:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	CAN_JUSTIFY_START
	    me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_A:
	/*
	 * If we are looking for client-side image maps, then handle an A
	 * within a MAP that has a COORDS attribute as an AREA tag. 
	 * Unfortunately we lose the anchor text this way for the LYNXIMGMAP,
	 * we would have to do much more parsing to collect it.  After
	 * potentially handling the A as AREA, always return immediately if
	 * only looking for image maps, without pushing anything on the style
	 * stack.  - kw
	 */
	if (me->map_address && present && present[HTML_A_COORDS])
	    LYStartArea(me,
			present[HTML_A_HREF] ? value[HTML_A_HREF] : NULL,
			NULL,
			present[HTML_A_TITLE] ? value[HTML_A_TITLE] : NULL,
			tag_charset);
	if (LYMapsOnly) {
	    return HT_OK;
	}
	/*
	 * A may have been declared SGML_EMPTY in HTMLDTD.c, and
	 * SGML_character() in SGML.c may check for an A end tag to call
	 * HTML_end_element() directly (with a check in that to bypass
	 * decrementing of the HTML parser's stack), so if we have an open A,
	 * close that one now.  - FM & kw
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	/*
	 * Set to know we are in an anchor.
	 */
	me->inA = TRUE;

	/*
	 * Load id_string if we have an ID or NAME.  - FM
	 */
	if (present && present[HTML_A_ID] &&
	    non_empty(value[HTML_A_ID])) {
	    StrAllocCopy(id_string, value[HTML_A_ID]);
	} else if (present && present[HTML_A_NAME] &&
		   non_empty(value[HTML_A_NAME])) {
	    StrAllocCopy(id_string, value[HTML_A_NAME]);
	}
	if (id_string)
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);

	/*
	 * Handle the reference.  - FM
	 */
	if (present && present[HTML_A_HREF]) {
	    /*
	     * Set to know we are making the content bold.
	     */
	    me->inBoldA = TRUE;

	    if (isEmpty(value[HTML_A_HREF]))
		StrAllocCopy(href, "#");
	    else
		StrAllocCopy(href, value[HTML_A_HREF]);
	    CHECK_FOR_INTERN(intern_flag, href);	/* '#' */

	    if (intern_flag) { /*** FAST WAY: ***/
		TRANSLATE_AND_UNESCAPE_TO_STD(&href);

	    } else {
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

		/*
		 * Deal with our ftp gateway kludge.  - FM
		 */
		if (!url_type && !StrNCmp(href, "/foo/..", 7) &&
		    (isFTP_URL(me->node_anchor->address) ||
		     isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i + 7]) != 0; i++) ;
		}
	    }

	    if (present[HTML_A_ISMAP])	/*??? */
		intern_flag = FALSE;
	} else {
	    if (bold_name_anchors == TRUE) {
		me->inBoldA = TRUE;
	    }
	}

	if (present && present[HTML_A_TYPE] && value[HTML_A_TYPE]) {
	    StrAllocCopy(temp, value[HTML_A_TYPE]);
	    if (!intern_flag &&
		!strcasecomp(value[HTML_A_TYPE], HTAtom_name(HTInternalLink)) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) &&
		!LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0) &&
		!isLYNXIMGMAP(me->node_anchor->address)) {
		/* Some kind of spoof?
		 * Found TYPE="internal link" but not in a valid context
		 * where we have written it. - kw
		 */
		CTRACE((tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			href, temp));
		FREE(temp);
	    }
	}

	me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						 id_string,	/* Tag */
						 href,	/* Address */
						 (temp
						  ? (HTLinkType *)
						  HTAtom_for(temp)
						  : INTERN_LT));	/* Type */
	FREE(temp);
	FREE(id_string);

	if (me->CurrentA && present) {
	    if (present[HTML_A_TITLE] &&
		non_empty(value[HTML_A_TITLE])) {
		StrAllocCopy(title, value[HTML_A_TITLE]);
		TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		LYTrimHead(title);
		LYTrimTail(title);
		if (*title == '\0') {
		    FREE(title);
		}
	    }
	    if (present[HTML_A_ISMAP])
		dest_ismap = TRUE;
	    if (present[HTML_A_CHARSET] &&
		non_empty(value[HTML_A_CHARSET])) {
		/*
		 * Set up to load the anchor's chartrans structures
		 * appropriately for the current display character set if it
		 * can handle what's claimed.  - FM
		 */
		StrAllocCopy(temp, value[HTML_A_CHARSET]);
		TRANSLATE_AND_UNESCAPE_TO_STD(&temp);
		dest_char_set = UCGetLYhndl_byMIME(temp);
		if (dest_char_set < 0) {
		    dest_char_set = UCLYhndl_for_unrec;
		}
	    }
	    if (title != NULL || dest_ismap == TRUE || dest_char_set >= 0) {
		dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		    );
	    }
	    if (dest && title != NULL && HTAnchor_title(dest) == NULL)
		HTAnchor_setTitle(dest, title);
	    if (dest && dest_ismap)
		dest->isISMAPScript = TRUE;
	    /* Don't allow CHARSET attribute to change *this* document's
	       charset assumption. - kw */
	    if (dest && dest != me->node_anchor && dest_char_set >= 0) {
		/*
		 * Load the anchor's chartrans structures.  This should be done
		 * more intelligently when setting up the structured object,
		 * but it gets the job done for now.  - FM
		 */
		HTAnchor_setUCInfoStage(dest, dest_char_set,
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
		HTAnchor_setUCInfoStage(dest, dest_char_set,
					UCT_STAGE_PARSER,
					UCT_SETBY_LINK);
	    }
	    FREE(temp);
	    dest = NULL;
	    FREE(title);
	}
	me->CurrentANum = HText_beginAnchor(me->text,
					    me->inUnderline, me->CurrentA);
	if (me->inBoldA == TRUE && me->inBoldH == FALSE)
	    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
#if defined(NOTUSED_FOTEMODS)
	/*
	 * Close an HREF-less NAMED-ed now if we aren't making their content
	 * bold, and let the check in HTML_end_element() deal with any dangling
	 * end tag this creates.  - FM
	 */
	if (href == NULL && me->inBoldA == FALSE) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#else
	/*Close an HREF-less NAMED-ed now if force_empty_hrefless_a was
	   requested - VH */
	if (href == NULL && force_empty_hrefless_a) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
#endif
	FREE(href);
	break;

    case HTML_IMG:		/* Images */
	/*
	 * If we're in an anchor, get the destination, and if it's a clickable
	 * image for the current anchor, set our flags for faking a 0,0
	 * coordinate pair, which typically returns the image's default.  - FM
	 */
	if (me->inA && me->CurrentA) {
	    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		 )) != NULL) {
		if (dest->isISMAPScript == TRUE) {
		    dest_ismap = TRUE;
		    CTRACE((tfp, "HTML: '%s' is an ISMAP script\n",
			    dest->address));
		} else if (present && present[HTML_IMG_ISMAP]) {
		    dest_ismap = TRUE;
		    dest->isISMAPScript = TRUE;
		    CTRACE((tfp, "HTML: Designating '%s' as an ISMAP script\n",
			    dest->address));
		}
	    }
	}

	intern_flag = FALSE;	/* unless set below - kw */
	/*
	 * If there's a USEMAP, resolve it.  - FM
	 */
	if (present && present[HTML_IMG_USEMAP] &&
	    non_empty(value[HTML_IMG_USEMAP])) {
	    StrAllocCopy(map_href, value[HTML_IMG_USEMAP]);
	    CHECK_FOR_INTERN(intern_flag, map_href);
	    (void) LYLegitimizeHREF(me, &map_href, TRUE, TRUE);
	    /*
	     * If map_href ended up zero-length or otherwise doesn't have a
	     * hash, it can't be valid, so ignore it.  - FM
	     */
	    if (findPoundSelector(map_href) == NULL) {
		FREE(map_href);
	    }
	}

	/*
	 * Handle a MAP reference if we have one at this point.  - FM
	 */
	if (map_href) {
	    /*
	     * If the MAP reference doesn't yet begin with a scheme, check
	     * whether a base tag is in effect.  - FM
	     */
	    /*
	     * If the USEMAP value is a lone fragment and LYSeekFragMAPinCur is
	     * set, we'll use the current document's URL for resolving. 
	     * Otherwise use the BASE.  - kw
	     */
	    Base = ((me->inBASE &&
		     !(*map_href == '#' && LYSeekFragMAPinCur == TRUE))
		    ? me->base_href
		    : me->node_anchor->address);
	    HTParseALL(&map_href, Base);

	    /*
	     * Prepend our client-side MAP access field.  - FM
	     */
	    StrAllocCopy(temp, STR_LYNXIMGMAP);
	    StrAllocCat(temp, map_href);
	    StrAllocCopy(map_href, temp);
	    FREE(temp);
	}

	/*
	 * Check whether we want to suppress the server-side ISMAP link if a
	 * client-side MAP is present.  - FM
	 */
	if (LYNoISMAPifUSEMAP && map_href && dest_ismap) {
	    dest_ismap = FALSE;
	    dest = NULL;
	}

	/*
	 * Check for a TITLE attribute.  - FM
	 */
	if (present && present[HTML_IMG_TITLE] &&
	    non_empty(value[HTML_IMG_TITLE])) {
	    StrAllocCopy(title, value[HTML_IMG_TITLE]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
	    LYTrimHead(title);
	    LYTrimTail(title);
	    if (*title == '\0') {
		FREE(title);
	    }
	}

	/*
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length or just spaces and we are making all SRCs links or have
	 * a USEMAP link.  - FM
	 */
	if (((present) &&
	     (present[HTML_IMG_ALT] && value[HTML_IMG_ALT])) &&
	    (!clickable_images ||
	     ((clickable_images || map_href) &&
	      *value[HTML_IMG_ALT] != '\0'))) {
	    StrAllocCopy(alt_string, value[HTML_IMG_ALT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
					    me->UsePlainSpace, me->HiddenValue);
	    /*
	     * If it's all spaces and we are making SRC or USEMAP links, treat
	     * it as zero-length.  - FM
	     */
	    if (clickable_images || map_href) {
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    if (map_href) {
			StrAllocCopy(alt_string, (title ? title :
						  (temp = MakeNewMapValue(value,
									  "USEMAP"))));
			FREE(temp);
		    } else if (dest_ismap) {
			StrAllocCopy(alt_string, (title ? title :
						  (temp = MakeNewMapValue(value,
									  "ISMAP"))));
			FREE(temp);

		    } else if (me->inA == TRUE && dest) {
			StrAllocCopy(alt_string, (title ?
						  title :
						  VERBOSE_IMG(value, HTML_IMG_SRC,
							      "[LINK]")));

		    } else {
			StrAllocCopy(alt_string,
				     (title ? title :
				      ((present &&
					present[HTML_IMG_ISOBJECT]) ?
				       "(OBJECT)" :
				       VERBOSE_IMG(value, HTML_IMG_SRC,
						   "[INLINE]"))));
		    }
		}
	    }

	} else if (map_href) {
	    StrAllocCopy(alt_string, (title ? title :
				      (temp = MakeNewMapValue(value, "USEMAP"))));
	    FREE(temp);

	} else if ((dest_ismap == TRUE) ||
		   (me->inA && present && present[HTML_IMG_ISMAP])) {
	    StrAllocCopy(alt_string, (title ? title :
				      (temp = MakeNewMapValue(value, "ISMAP"))));
	    FREE(temp);

	} else if (me->inA == TRUE && dest) {
	    StrAllocCopy(alt_string, (title ?
				      title :
				      VERBOSE_IMG(value, HTML_IMG_SRC,
						  "[LINK]")));

	} else {
	    if (pseudo_inline_alts || clickable_images)
		StrAllocCopy(alt_string, (title ? title :
					  ((present &&
					    present[HTML_IMG_ISOBJECT]) ?
					   "(OBJECT)" :
					   VERBOSE_IMG(value, HTML_IMG_SRC,
						       "[INLINE]"))));
	    else
		StrAllocCopy(alt_string, NonNull(title));
	}
	if (*alt_string == '\0' && map_href) {
	    StrAllocCopy(alt_string, (temp = MakeNewMapValue(value, "USEMAP")));
	    FREE(temp);
	}

	CTRACE((tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
		map_href ? 1 : 0,
		(dest_ismap == TRUE) ? 1 : 0,
		me->inA, me->inP));

	/*
	 * Check for an ID attribute.  - FM
	 */
	if (present && present[HTML_IMG_ID] &&
	    non_empty(value[HTML_IMG_ID])) {
	    StrAllocCopy(id_string, value[HTML_IMG_ID]);
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    if (*id_string == '\0') {
		FREE(id_string);
	    }
	}

	/*
	 * Create links to the SRC for all images, if desired.  - FM
	 */
	if (clickable_images &&
	    present && present[HTML_IMG_SRC] &&
	    non_empty(value[HTML_IMG_SRC])) {
	    StrAllocCopy(href, value[HTML_IMG_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     * If it's an ISMAP and/or USEMAP, or graphic for an anchor, end
	     * that anchor and start one for the SRC.  - FM
	     */
	    if (me->inA) {
		/*
		 * If we have a USEMAP, end this anchor and start a new one for
		 * the client-side MAP.  - FM
		 */
		if (map_href) {
		    if (dest_ismap) {
			HTML_put_character(me, ' ');
			me->in_word = NO;
			HTML_put_string(me,
					(temp = MakeNewMapValue(value, "ISMAP")));
			FREE(temp);
		    } else if (dest) {
			HTML_put_character(me, ' ');
			me->in_word = NO;
			HTML_put_string(me, "[LINK]");
		    }
		    if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    }
		    me->inBoldA = FALSE;
		    HText_endAnchor(me->text, me->CurrentANum);
		    me->CurrentANum = 0;
		    if (dest_ismap || dest)
			HTML_put_character(me, '-');
		    if (id_string) {
			if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							      id_string,	/* Tag */
							      NULL,	/* Addresss */
							      0)) != NULL) {	/* Type */
			    HText_beginAnchor(me->text, me->inUnderline, ID_A);
			    HText_endAnchor(me->text, 0);
			}
		    }
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     map_href,	/* Addresss */
							     INTERN_LT);	/* Type */
		    if (me->CurrentA && title) {
			if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			     )) != NULL) {
			    if (!HTAnchor_title(dest))
				HTAnchor_setTitle(dest, title);
			}
		    }
		    me->CurrentANum = HText_beginAnchor(me->text,
							me->inUnderline,
							me->CurrentA);
		    if (me->inBoldA == FALSE && me->inBoldH == FALSE) {
			HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		    }
		    me->inBoldA = TRUE;
		} else {
		    HTML_put_character(me, ' ');	/* space char may be ignored */
		    me->in_word = NO;
		}
		HTML_put_string(me, alt_string);
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		HTML_put_character(me, '-');
		FREE(newtitle);
		StrAllocCopy(alt_string,
			     ((present &&
			       present[HTML_IMG_ISOBJECT]) ?
			      ((map_href || dest_ismap) ?
			       "(IMAGE)" : "(OBJECT)") :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
		if (id_string && !map_href) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
		    }
		}
	    } else if (map_href) {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
		if (id_string) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
		    }
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 map_href,	/* Addresss */
							 INTERN_LT);	/* Type */
		if (me->CurrentA && title) {
		    if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
			 )) != NULL) {
			if (!HTAnchor_title(dest))
			    HTAnchor_setTitle(dest, title);
		    }
		}
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldA == FALSE && me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		me->inBoldA = TRUE;
		HTML_put_string(me, alt_string);
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		HTML_put_character(me, '-');
		FREE(newtitle);
		StrAllocCopy(alt_string,
			     ((present &&
			       present[HTML_IMG_ISOBJECT]) ?
			      "(IMAGE)" :
			      VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
	    } else {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
		if (id_string) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  id_string,	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
		    }
		}
	    }

	    /*
	     * Create the link to the SRC.  - FM
	     */
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    FREE(href);
	    me->CurrentANum = HText_beginAnchor(me->text,
						me->inUnderline,
						me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, alt_string);
	    if (!me->inA) {
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    } else {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
		me->inBoldA = TRUE;
	    }
	} else if (map_href) {
	    if (me->inA) {
		/*
		 * We're in an anchor and have a USEMAP, so end the anchor and
		 * start a new one for the client-side MAP.  - FM
		 */
		if (dest_ismap) {
		    HTML_put_character(me, ' ');	/* space char may be ignored */
		    me->in_word = NO;
		    HTML_put_string(me, (temp = MakeNewMapValue(value, "ISMAP")));
		    FREE(temp);
		} else if (dest) {
		    HTML_put_character(me, ' ');	/* space char may be ignored */
		    me->in_word = NO;
		    HTML_put_string(me, "[LINK]");
		}
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
		if (dest_ismap || dest) {
		    HTML_put_character(me, '-');
		}
	    } else {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     map_href,	/* Addresss */
						     INTERN_LT);	/* Type */
	    if (me->CurrentA && title) {
		if ((dest = HTAnchor_parent(HTAnchor_followLink(me->CurrentA)
		     )) != NULL) {
		    if (!HTAnchor_title(dest))
			HTAnchor_setTitle(dest, title);
		}
	    }
	    me->CurrentANum = HText_beginAnchor(me->text,
						me->inUnderline,
						me->CurrentA);
	    if (me->inBoldA == FALSE && me->inBoldH == FALSE) {
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    }
	    me->inBoldA = TRUE;
	    HTML_put_string(me, alt_string);
	    if (!me->inA) {
		if (me->inBoldA == TRUE && me->inBoldH == FALSE) {
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		}
		me->inBoldA = FALSE;
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
	    }
	} else {
	    /*
	     * Just put in the ALT or pseudo-ALT string for the current anchor
	     * or inline, with an ID link if indicated.  - FM
	     */
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	    if (id_string) {
		if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						      id_string,	/* Tag */
						      NULL,	/* Addresss */
						      (HTLinkType *) 0)) != NULL) {	/* Type */
		    HText_beginAnchor(me->text, me->inUnderline, ID_A);
		    HText_endAnchor(me->text, 0);
		}
	    }
	    HTML_put_string(me, alt_string);
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	}
	FREE(map_href);
	FREE(alt_string);
	FREE(id_string);
	FREE(title);
	FREE(newtitle);
	dest = NULL;
	break;

    case HTML_MAP:
	/*
	 * Load id_string if we have a NAME or ID.  - FM
	 */
	if (present && present[HTML_MAP_NAME] &&
	    non_empty(value[HTML_MAP_NAME])) {
	    StrAllocCopy(id_string, value[HTML_MAP_NAME]);
	} else if (present && present[HTML_MAP_ID] &&
		   non_empty(value[HTML_MAP_ID])) {
	    StrAllocCopy(id_string, value[HTML_MAP_ID]);
	}
	if (id_string) {
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    if (*id_string == '\0') {
		FREE(id_string);
	    }
	}

	/*
	 * Generate a target anchor in this place in the containing document. 
	 * MAP can now contain block markup, if it doesn't contain any AREAs
	 * (or A anchors with COORDS converted to AREAs) the current location
	 * can be used as a fallback for following a USEMAP link.  - kw
	 */
	if (!LYMapsOnly)
	    LYHandleID(me, id_string);

	/*
	 * Load map_address.  - FM
	 */
	if (id_string) {
	    /*
	     * The MAP must be in the current stream, even if it had a BASE
	     * tag, so we'll use its address here, but still use the BASE, if
	     * present, when resolving the AREA elements in it's content,
	     * unless the AREA's HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM && KW
	     */
	    StrAllocCopy(me->map_address, me->node_anchor->address);
	    if ((cp = StrChr(me->map_address, '#')) != NULL)
		*cp = '\0';
	    StrAllocCat(me->map_address, "#");
	    StrAllocCat(me->map_address, id_string);
	    FREE(id_string);
	    if (present && present[HTML_MAP_TITLE] &&
		non_empty(value[HTML_MAP_TITLE])) {
		StrAllocCopy(title, value[HTML_MAP_TITLE]);
		TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		LYTrimHead(title);
		LYTrimTail(title);
		if (*title == '\0') {
		    FREE(title);
		}
	    }
	    LYAddImageMap(me->map_address, title, me->node_anchor);
	    FREE(title);
	}
	break;

    case HTML_AREA:
	if (me->map_address &&
	    present && present[HTML_AREA_HREF] &&
	    non_empty(value[HTML_AREA_HREF])) {
	    /*
	     * Resolve the HREF.  - FM
	     */
	    StrAllocCopy(href, value[HTML_AREA_HREF]);
	    CHECK_FOR_INTERN(intern_flag, href);
	    (void) LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     * Check whether a BASE tag is in effect, and use it for resolving,
	     * even though we used this stream's address for locating the MAP
	     * itself, unless the HREF is a lone fragment and
	     * LYSeekFragAREAinCur is set.  - FM
	     */
	    Base = (((me->inBASE && *href != '\0') &&
		     !(*href == '#' && LYSeekFragAREAinCur == TRUE))
		    ? me->base_href
		    : me->node_anchor->address);
	    HTParseALL(&href, Base);

	    /*
	     * Check for an ALT.  - FM
	     */
	    if (present[HTML_AREA_ALT] &&
		non_empty(value[HTML_AREA_ALT])) {
		StrAllocCopy(alt_string, value[HTML_AREA_ALT]);
	    } else if (present[HTML_AREA_TITLE] &&
		       non_empty(value[HTML_AREA_TITLE])) {
		/*
		 * Use the TITLE as an ALT.  - FM
		 */
		StrAllocCopy(alt_string, value[HTML_AREA_TITLE]);
	    }
	    if (alt_string != NULL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
						me->UsePlainSpace,
						me->HiddenValue);
		/*
		 * Make sure it's not just space(s).  - FM
		 */
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    StrAllocCopy(alt_string, href);
		}
	    } else {
		/*
		 * Use the HREF as an ALT.  - FM
		 */
		StrAllocCopy(alt_string, href);
	    }

	    LYAddMapElement(me->map_address, href, alt_string,
			    me->node_anchor, intern_flag);
	    FREE(href);
	    FREE(alt_string);
	}
	break;

    case HTML_PARAM:
	/*
	 * We may need to look at this someday to deal with MAPs, OBJECTs or
	 * APPLETs optimally, but just ignore it for now.  - FM
	 */
	break;

    case HTML_BODYTEXT:
	CHECK_ID(HTML_BODYTEXT_ID);
	/*
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
	 */
	break;

    case HTML_TEXTFLOW:
	CHECK_ID(HTML_BODYTEXT_ID);
	/*
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
	 */
	break;

    case HTML_FIG:
	if (present)
	    LYHandleFIG(me, present, value,
			present[HTML_FIG_ISOBJECT],
			present[HTML_FIG_IMAGEMAP],
			present[HTML_FIG_ID] ? value[HTML_FIG_ID] : NULL,
			present[HTML_FIG_SRC] ? value[HTML_FIG_SRC] : NULL,
			YES, TRUE, &intern_flag);
	else
	    LYHandleFIG(me, NULL, NULL,
			0,
			0,
			NULL,
			NULL, YES, TRUE, &intern_flag);
	break;

    case HTML_OBJECT:
	if (!me->object_started) {
	    /*
	     * This is an outer OBJECT start tag, i.e., not a nested OBJECT, so
	     * save its relevant attributes.  - FM
	     */
	    if (present) {
		if (present[HTML_OBJECT_DECLARE])
		    me->object_declare = TRUE;
		if (present[HTML_OBJECT_SHAPES])
		    me->object_shapes = TRUE;
		if (present[HTML_OBJECT_ISMAP])
		    me->object_ismap = TRUE;
		if (present[HTML_OBJECT_USEMAP] &&
		    non_empty(value[HTML_OBJECT_USEMAP])) {
		    StrAllocCopy(me->object_usemap, value[HTML_OBJECT_USEMAP]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_usemap);
		    if (*me->object_usemap == '\0') {
			FREE(me->object_usemap);
		    }
		}
		if (present[HTML_OBJECT_ID] &&
		    non_empty(value[HTML_OBJECT_ID])) {
		    StrAllocCopy(me->object_id, value[HTML_OBJECT_ID]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_id);
		    if (*me->object_id == '\0') {
			FREE(me->object_id);
		    }
		}
		if (present[HTML_OBJECT_TITLE] &&
		    non_empty(value[HTML_OBJECT_TITLE])) {
		    StrAllocCopy(me->object_title, value[HTML_OBJECT_TITLE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_title, TRUE, FALSE);
		    LYTrimHead(me->object_title);
		    LYTrimTail(me->object_title);
		    if (me->object_title == '\0') {
			FREE(me->object_title);
		    }
		}
		if (present[HTML_OBJECT_DATA] &&
		    non_empty(value[HTML_OBJECT_DATA])) {
		    StrAllocCopy(me->object_data, value[HTML_OBJECT_DATA]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_data);
		    if (*me->object_data == '\0') {
			FREE(me->object_data);
		    }
		}
		if (present[HTML_OBJECT_TYPE] &&
		    non_empty(value[HTML_OBJECT_TYPE])) {
		    StrAllocCopy(me->object_type, value[HTML_OBJECT_TYPE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_type, TRUE, FALSE);
		    LYTrimHead(me->object_type);
		    LYTrimTail(me->object_type);
		    if (me->object_type == '\0') {
			FREE(me->object_type);
		    }
		}
		if (present[HTML_OBJECT_CLASSID] &&
		    non_empty(value[HTML_OBJECT_CLASSID])) {
		    StrAllocCopy(me->object_classid,
				 value[HTML_OBJECT_CLASSID]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_classid, TRUE, FALSE);
		    LYTrimHead(me->object_classid);
		    LYTrimTail(me->object_classid);
		    if (me->object_classid == '\0') {
			FREE(me->object_classid);
		    }
		}
		if (present[HTML_OBJECT_CODEBASE] &&
		    non_empty(value[HTML_OBJECT_CODEBASE])) {
		    StrAllocCopy(me->object_codebase,
				 value[HTML_OBJECT_CODEBASE]);
		    TRANSLATE_AND_UNESCAPE_TO_STD(&me->object_codebase);
		    if (*me->object_codebase == '\0') {
			FREE(me->object_codebase);
		    }
		}
		if (present[HTML_OBJECT_CODETYPE] &&
		    non_empty(value[HTML_OBJECT_CODETYPE])) {
		    StrAllocCopy(me->object_codetype,
				 value[HTML_OBJECT_CODETYPE]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_codetype,
						    TRUE,
						    FALSE);
		    LYTrimHead(me->object_codetype);
		    LYTrimTail(me->object_codetype);
		    if (me->object_codetype == '\0') {
			FREE(me->object_codetype);
		    }
		}
		if (present[HTML_OBJECT_NAME] &&
		    non_empty(value[HTML_OBJECT_NAME])) {
		    StrAllocCopy(me->object_name, value[HTML_OBJECT_NAME]);
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_name, TRUE, FALSE);
		    LYTrimHead(me->object_name);
		    LYTrimTail(me->object_name);
		    if (me->object_name == '\0') {
			FREE(me->object_name);
		    }
		}
	    }
	    /*
	     * If we can determine now that we are not going to do anything
	     * special to the OBJECT element's SGML contents, like skipping it
	     * completely or collecting it up in order to add something after
	     * it, then generate any output that should be emitted in the place
	     * of the OBJECT start tag NOW, then don't initialize special
	     * handling but return, letting our SGML parser know that further
	     * content is to be parsed normally not literally.  We could defer
	     * this until we have collected the contents and then recycle the
	     * contents (as was previously always done), but that has a higher
	     * chance of completely losing content in case of nesting errors in
	     * the input, incomplete transmissions, etc.  - kw
	     */
	    if ((!present ||
		 (me->object_declare == FALSE && me->object_name == NULL &&
		  me->object_shapes == FALSE && me->object_usemap == NULL))) {
		if (!LYMapsOnly) {
		    if (!clickable_images || me->object_data == NULL ||
			!(me->object_data != NULL &&
			  me->object_classid == NULL &&
			  me->object_codebase == NULL &&
			  me->object_codetype == NULL))
			FREE(me->object_data);
		    if (me->object_data) {
			HTStartAnchor5(me,
				       (me->object_id
					? value[HTML_OBJECT_ID]
					: NULL),
				       value[HTML_OBJECT_DATA],
				       value[HTML_OBJECT_TYPE],
				       tag_charset);
			if ((me->object_type != NULL) &&
			    !strncasecomp(me->object_type, "image/", 6))
			    HTML_put_string(me, "(IMAGE)");
			else
			    HTML_put_string(me, "(OBJECT)");
			HTML_end_element(me, HTML_A, NULL);
		    } else if (me->object_id)
			LYHandleID(me, me->object_id);
		}
		clear_objectdata(me);
		/*
		 * We do NOT want the HTML_put_* functions that are going to be
		 * called for the OBJECT's character content to add to the
		 * chunk, so we don't push on the stack.  Instead we keep a
		 * counter for open OBJECT tags that are treated this way, so
		 * HTML_end_element can skip handling the corresponding end tag
		 * that is going to arrive unexpectedly as far as our stack is
		 * concerned.
		 */
		status = HT_PARSER_OTHER_CONTENT;
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    ElementNumber = (HTMLElement) HTML_OBJECT_M;
		} else {
		    me->objects_mixed_open++;
		    SET_SKIP_STACK(HTML_OBJECT);
		}
	    } else if (me->object_declare == FALSE && me->object_name == NULL &&
		       me->object_shapes == TRUE) {
		LYHandleFIG(me, present, value,
			    1,
			    1 || me->object_ismap,
			    me->object_id,
			    ((me->object_data && !me->object_classid)
			     ? value[HTML_OBJECT_DATA]
			     : NULL),
			    NO, TRUE, &intern_flag);
		clear_objectdata(me);
		status = HT_PARSER_OTHER_CONTENT;
		me->objects_figged_open++;
		ElementNumber = HTML_FIG;

	    } else {
		/*
		 * Set flag that we are accumulating OBJECT content.  - FM
		 */
		me->object_started = TRUE;
	    }
	}
	break;

    case HTML_OVERLAY:
	if (clickable_images && me->inFIG &&
	    present && present[HTML_OVERLAY_SRC] &&
	    non_empty(value[HTML_OVERLAY_SRC])) {
	    StrAllocCopy(href, value[HTML_OVERLAY_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {

		if (me->inA) {
		    SET_SKIP_STACK(HTML_A);
		    HTML_end_element(me, HTML_A, include);
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
		HTML_put_character(me, ' ');
		HText_appendCharacter(me->text, '+');
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, "[OVERLAY]");
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    FREE(href);
	}
	break;

    case HTML_APPLET:
	me->inAPPLET = TRUE;
	me->inAPPLETwithP = FALSE;
	HTML_put_character(me, ' ');	/* space char may be ignored */
	/*
	 * Load id_string if we have an ID or NAME.  - FM
	 */
	if (present && present[HTML_APPLET_ID] &&
	    non_empty(value[HTML_APPLET_ID])) {
	    StrAllocCopy(id_string, value[HTML_APPLET_ID]);
	} else if (present && present[HTML_APPLET_NAME] &&
		   non_empty(value[HTML_APPLET_NAME])) {
	    StrAllocCopy(id_string, value[HTML_APPLET_NAME]);
	}
	if (id_string) {
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    LYHandleID(me, id_string);
	    FREE(id_string);
	}
	me->in_word = NO;

	/*
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
	 */
	if (present && present[HTML_APPLET_ALT] && value[HTML_APPLET_ALT] &&
	    (!clickable_images ||
	     (clickable_images && *value[HTML_APPLET_ALT] != '\0'))) {
	    StrAllocCopy(alt_string, value[HTML_APPLET_ALT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
					    me->UsePlainSpace, me->HiddenValue);
	    /*
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
	     */
	    if (clickable_images) {
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    StrAllocCopy(alt_string, "[APPLET]");
		}
	    }

	} else {
	    if (clickable_images)
		StrAllocCopy(alt_string, "[APPLET]");
	    else
		StrAllocCopy(alt_string, "");
	}

	/*
	 * If we're making all sources links, get the source.  - FM
	 */
	if (clickable_images && present && present[HTML_APPLET_CODE] &&
	    non_empty(value[HTML_APPLET_CODE])) {
	    char *base = NULL;

	    Base = (me->inBASE)
		? me->base_href
		: me->node_anchor->address;
	    /*
	     * Check for a CODEBASE attribute.  - FM
	     */
	    if (present[HTML_APPLET_CODEBASE] &&
		non_empty(value[HTML_APPLET_CODEBASE])) {
		StrAllocCopy(base, value[HTML_APPLET_CODEBASE]);
		LYRemoveBlanks(base);
		TRANSLATE_AND_UNESCAPE_TO_STD(&base);
		/*
		 * Force it to be a directory.  - FM
		 */
		if (*base == '\0')
		    StrAllocCopy(base, "/");
		LYAddHtmlSep(&base);
		LYLegitimizeHREF(me, &base, TRUE, FALSE);

		HTParseALL(&base, Base);
	    }

	    StrAllocCopy(href, value[HTML_APPLET_CODE]);
	    LYLegitimizeHREF(me, &href, TRUE, FALSE);
	    HTParseALL(&href, (base ? base : Base));
	    FREE(base);

	    if (*href) {
		if (me->inA) {
		    if (me->inBoldA == TRUE && me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    HTML_put_character(me, '-');
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, alt_string);
		if (me->inA == FALSE) {
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    me->CurrentANum = 0;
		}
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	} else if (*alt_string) {
	    /*
	     * Just put up the ALT string, if non-zero.  - FM
	     */
	    HTML_put_string(me, alt_string);
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	}
	FREE(alt_string);
	FREE(id_string);
	break;

    case HTML_BGSOUND:
	/*
	 * If we're making all sources links, get the source.  - FM
	 */
	if (clickable_images && present && present[HTML_BGSOUND_SRC] &&
	    non_empty(value[HTML_BGSOUND_SRC])) {
	    StrAllocCopy(href, value[HTML_BGSOUND_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href == '\0') {
		FREE(href);
		break;
	    }

	    if (me->inA) {
		if (me->inBoldA == TRUE && me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		HTML_put_character(me, '-');
	    } else {
		HTML_put_character(me, ' ');	/* space char may be ignored */
		me->in_word = NO;
	    }
	    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						     NULL,	/* Tag */
						     href,	/* Addresss */
						     (HTLinkType *) 0);		/* Type */
	    me->CurrentANum = HText_beginAnchor(me->text,
						me->inUnderline,
						me->CurrentA);
	    if (me->inBoldH == FALSE)
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
	    HTML_put_string(me, "[BGSOUND]");
	    if (me->inA == FALSE) {
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, me->CurrentANum);
		me->CurrentANum = 0;
	    }
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	    FREE(href);
	}
	break;

    case HTML_EMBED:
	if (pseudo_inline_alts || clickable_images)
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	/*
	 * Load id_string if we have an ID or NAME.  - FM
	 */
	if (present && present[HTML_EMBED_ID] &&
	    non_empty(value[HTML_EMBED_ID])) {
	    StrAllocCopy(id_string, value[HTML_EMBED_ID]);
	} else if (present && present[HTML_EMBED_NAME] &&
		   non_empty(value[HTML_EMBED_NAME])) {
	    StrAllocCopy(id_string, value[HTML_EMBED_NAME]);
	}
	if (id_string) {
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    LYHandleID(me, id_string);
	    FREE(id_string);
	}
	if (pseudo_inline_alts || clickable_images)
	    me->in_word = NO;

	/*
	 * If there's an ALT string, use it, unless the ALT string is
	 * zero-length and we are making all sources links.  - FM
	 */
	if (present && present[HTML_EMBED_ALT] && value[HTML_EMBED_ALT] &&
	    (!clickable_images ||
	     (clickable_images && *value[HTML_EMBED_ALT] != '\0'))) {
	    StrAllocCopy(alt_string, value[HTML_EMBED_ALT]);
	    TRANSLATE_AND_UNESCAPE_ENTITIES(&alt_string,
					    me->UsePlainSpace, me->HiddenValue);
	    /*
	     * If it's all spaces and we are making sources links, treat it as
	     * zero-length.  - FM
	     */
	    if (clickable_images) {
		LYTrimHead(alt_string);
		LYTrimTail(alt_string);
		if (*alt_string == '\0') {
		    StrAllocCopy(alt_string, "[EMBED]");
		}
	    }
	} else {
	    if (pseudo_inline_alts || clickable_images)
		StrAllocCopy(alt_string, "[EMBED]");
	    else
		StrAllocCopy(alt_string, "");
	}

	/*
	 * If we're making all sources links, get the source.  - FM
	 */
	if (clickable_images && present && present[HTML_EMBED_SRC] &&
	    non_empty(value[HTML_EMBED_SRC])) {
	    StrAllocCopy(href, value[HTML_EMBED_SRC]);
	    LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		if (me->inA) {
		    if (me->inBoldA == TRUE && me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    HTML_put_character(me, '-');
		}
		me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							 NULL,	/* Tag */
							 href,	/* Addresss */
							 (HTLinkType *) 0);	/* Type */
		me->CurrentANum = HText_beginAnchor(me->text,
						    me->inUnderline,
						    me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, alt_string);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		if (me->inA == FALSE) {
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, me->CurrentANum);
		    me->CurrentANum = 0;
		}
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    FREE(href);
	} else if (*alt_string) {
	    /*
	     * Just put up the ALT string, if non-zero.  - FM
	     */
	    HTML_put_string(me, alt_string);
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	    me->in_word = NO;
	}
	FREE(alt_string);
	FREE(id_string);
	break;

    case HTML_CREDIT:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCREDIT = TRUE;
	CHECK_ID(HTML_GEN_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "CREDIT:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	CAN_JUSTIFY_START;

	if (me->inFIG)
	    /*
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inFIGwithP = TRUE;

	if (me->inAPPLET)
	    /*
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inAPPLETwithP = TRUE;

	me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_CAPTION:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCAPTION = TRUE;
	CHECK_ID(HTML_CAPTION_ID);
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, "CAPTION:");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	CAN_JUSTIFY_START;

	if (me->inFIG)
	    /*
	     * Assume all text in the FIG container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inFIGwithP = TRUE;

	if (me->inAPPLET)
	    /*
	     * Assume all text in the APPLET container is intended to be
	     * paragraphed.  - FM
	     */
	    me->inAPPLETwithP = TRUE;

	me->inLABEL = TRUE;
	me->in_word = NO;
	me->inP = FALSE;
	break;

    case HTML_FORM:
	{
	    char *action = NULL;
	    char *method = NULL;
	    char *enctype = NULL;
	    const char *accept_cs = NULL;

	    HTChildAnchor *source;
	    HTAnchor *link_dest;

	    /*
	     * FORM may have been declared SGML_EMPTY in HTMLDTD.c, and
	     * SGML_character() in SGML.c may check for a FORM end tag to call
	     * HTML_end_element() directly (with a check in that to bypass
	     * decrementing of the HTML parser's stack), so if we have an open
	     * FORM, close that one now.  - FM
	     */
	    if (me->inFORM) {
		CTRACE((tfp, "HTML: Missing FORM end tag.  Faking it!\n"));
		SET_SKIP_STACK(HTML_FORM);
		HTML_end_element(me, HTML_FORM, include);
	    }

	    /*
	     * Set to know we are in a new form.
	     */
	    me->inFORM = TRUE;
	    EMIT_IFDEF_USE_JUSTIFY_ELTS(form_in_htext = TRUE);

	    if (present && present[HTML_FORM_ACCEPT_CHARSET]) {
		accept_cs = (value[HTML_FORM_ACCEPT_CHARSET]
			     ? value[HTML_FORM_ACCEPT_CHARSET]
			     : "UNKNOWN");
	    }

	    Base = (me->inBASE)
		? me->base_href
		: me->node_anchor->address;

	    if (present && present[HTML_FORM_ACTION] &&
		value[HTML_FORM_ACTION]) {

		StrAllocCopy(action, value[HTML_FORM_ACTION]);
		LYLegitimizeHREF(me, &action, TRUE, TRUE);

		/*
		 * Check whether a base tag is in effect.  Note that actions
		 * always are resolved w.r.t.  to the base, even if the action
		 * is empty.  - FM
		 */
		HTParseALL(&action, Base);

	    } else {
		StrAllocCopy(action, Base);
	    }

	    source = HTAnchor_findChildAndLink(me->node_anchor,
					       NULL,
					       action,
					       (HTLinkType *) 0);
	    if ((link_dest = HTAnchor_followLink(source)) != NULL) {
		/*
		 * Memory leak fixed.  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
		 */
		char *cp_freeme = HTAnchor_address(link_dest);

		if (cp_freeme != NULL) {
		    StrAllocCopy(action, cp_freeme);
		    FREE(cp_freeme);
		} else {
		    StrAllocCopy(action, "");
		}
	    }

	    if (present && present[HTML_FORM_METHOD])
		StrAllocCopy(method, (value[HTML_FORM_METHOD]
				      ? value[HTML_FORM_METHOD]
				      : "GET"));

	    if (present && present[HTML_FORM_ENCTYPE] &&
		non_empty(value[HTML_FORM_ENCTYPE])) {
		StrAllocCopy(enctype, value[HTML_FORM_ENCTYPE]);
		LYLowerCase(enctype);
	    }

	    if (present) {
		/*
		 * Check for a TITLE attribute, and if none is present, check
		 * for a SUBJECT attribute as a synonym.  - FM
		 */
		if (present[HTML_FORM_TITLE] &&
		    non_empty(value[HTML_FORM_TITLE])) {
		    StrAllocCopy(title, value[HTML_FORM_TITLE]);
		} else if (present[HTML_FORM_SUBJECT] &&
			   non_empty(value[HTML_FORM_SUBJECT])) {
		    StrAllocCopy(title, value[HTML_FORM_SUBJECT]);
		}
		if (non_empty(title)) {
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
		    LYTrimHead(title);
		    LYTrimTail(title);
		    if (*title == '\0') {
			FREE(title);
		    }
		}
	    }

	    HText_beginForm(action, method, enctype, title, accept_cs);

	    FREE(action);
	    FREE(method);
	    FREE(enctype);
	    FREE(title);
	}
	CHECK_ID(HTML_FORM_ID);
	break;

    case HTML_FIELDSET:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	CHECK_ID(HTML_GEN_ID);
	break;

    case HTML_LEGEND:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	CHECK_ID(HTML_CAPTION_ID);
	break;

    case HTML_LABEL:
	CHECK_ID(HTML_LABEL_ID);
	break;

    case HTML_KEYGEN:
	CHECK_ID(HTML_KEYGEN_ID);
	break;

    case HTML_BUTTON:
	{
	    InputFieldData I;
	    int chars;

	    /* init */
	    memset(&I, 0, sizeof(I));
	    I.name_cs = ATTR_CS_IN;
	    I.value_cs = ATTR_CS_IN;

	    UPDATE_STYLE;
	    if (present &&
		present[HTML_BUTTON_TYPE] &&
		value[HTML_BUTTON_TYPE]) {
		if (!strcasecomp(value[HTML_BUTTON_TYPE], "submit") ||
		    !strcasecomp(value[HTML_BUTTON_TYPE], "reset")) {
		    /*
		     * It's a button for submitting or resetting a form.  - FM
		     */
		    I.type = value[HTML_BUTTON_TYPE];
		} else {
		    /*
		     * Ugh, it's a button for a script.  - FM
		     */
		    I.type = value[HTML_BUTTON_TYPE];
		}
	    } else {
		/* default, if no type given, is a submit button */
		I.type = "submit";
	    }

	    /*
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
	     */
	    if (me->sp[0].tag_number != HTML_PRE && !me->inPRE &&
		me->sp->style->freeFormat) {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
		HTML_put_character(me, '\n');
		me->in_word = NO;
	    }
	    HTML_put_character(me, '(');

	    if (!(present && present[HTML_BUTTON_NAME] &&
		  value[HTML_BUTTON_NAME])) {
		I.name = "";
	    } else if (StrChr(value[HTML_BUTTON_NAME], '&') == NULL) {
		I.name = value[HTML_BUTTON_NAME];
	    } else {
		StrAllocCopy(I_name, value[HTML_BUTTON_NAME]);
		UNESCAPE_FIELDNAME_TO_STD(&I_name);
		I.name = I_name;
	    }

	    if (present && present[HTML_BUTTON_VALUE] &&
		non_empty(value[HTML_BUTTON_VALUE])) {
		/*
		 * Convert any HTML entities or decimal escaping.  - FM
		 */
		StrAllocCopy(I_value, value[HTML_BUTTON_VALUE]);
		me->UsePlainSpace = TRUE;
		TRANSLATE_AND_UNESCAPE_ENTITIES(&I_value, TRUE, me->HiddenValue);
		me->UsePlainSpace = FALSE;
		I.value = I_value;
		/*
		 * Convert any newlines or tabs to spaces, and trim any lead or
		 * trailing spaces.  - FM
		 */
		LYReduceBlanks(I.value);
	    } else if (!strcasecomp(I.type, "button")) {
		if (non_empty(I.name)) {
		    StrAllocCopy(I.value, I.name);
		} else {
		    StrAllocCopy(I.value, "BUTTON");
		}
	    } else if (I.value == 0) {
		StrAllocCopy(I.value, "BUTTON");
	    }

	    if (present && present[HTML_BUTTON_READONLY])
		I.readonly = YES;

	    if (present && present[HTML_BUTTON_DISABLED])
		I.disabled = YES;

	    if (present && present[HTML_BUTTON_CLASS] &&	/* Not yet used. */
		non_empty(value[HTML_BUTTON_CLASS]))
		I.iclass = value[HTML_BUTTON_CLASS];

	    if (present && present[HTML_BUTTON_ID] &&
		non_empty(value[HTML_BUTTON_ID])) {
		I.id = value[HTML_BUTTON_ID];
		CHECK_ID(HTML_BUTTON_ID);
	    }

	    if (present && present[HTML_BUTTON_LANG] &&		/* Not yet used. */
		non_empty(value[HTML_BUTTON_LANG]))
		I.lang = value[HTML_BUTTON_LANG];

	    chars = HText_beginInput(me->text, me->inUnderline, &I);
	    /*
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
	     */
	    if (me->sp[0].tag_number == HTML_PRE ||
		!me->sp->style->freeFormat) {
		/*
		 * We have a submit or reset button in a PRE block, so output
		 * the entire value from the markup.  If it extends to the
		 * right margin, it will wrap there, and only the portion
		 * before that wrap will be hightlighted on screen display
		 * (Yuk!) but we may as well show the rest of the full value on
		 * the next or more lines.  - FM
		 */
		while (I.value[i])
		    HTML_put_character(me, I.value[i++]);
	    } else {
		/*
		 * The submit or reset button is not in a PRE block.  Note that
		 * if a wrap occurs before outputting the entire value, the
		 * wrapped portion will not be highlighted or clearly indicated
		 * as part of the link for submission or reset (Yuk!).  We'll
		 * replace any spaces in the submit or reset button value with
		 * nbsp, to promote a wrap at the space we ensured would be
		 * present before the start of the string, as when we use all
		 * underscores instead of the INPUT's actual value, but we
		 * could still get a wrap at the right margin, instead, if the
		 * value is greater than a line width for the current style. 
		 * Also, if chars somehow ended up longer than the length of
		 * the actual value (shouldn't have), we'll continue padding
		 * with nbsp up to the length of chars.  - FM
		 */
		for (i = 0; I.value[i]; i++) {
		    HTML_put_character(me,
				       (char) ((I.value[i] == ' ')
					       ? HT_NON_BREAK_SPACE
					       : I.value[i]));
		}
		while (i++ < chars) {
		    HTML_put_character(me, HT_NON_BREAK_SPACE);
		}
	    }
	    HTML_put_character(me, ')');
	    if (me->sp[0].tag_number != HTML_PRE &&
		me->sp->style->freeFormat) {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    }
	    FREE(I_value);
	    FREE(I_name);
	}
	break;

    case HTML_INPUT:
	{
	    InputFieldData I;
	    int chars;
	    BOOL UseALTasVALUE = FALSE;
	    BOOL HaveSRClink = FALSE;
	    char *ImageSrc = NULL;
	    BOOL IsSubmitOrReset = FALSE;
	    HTkcode kcode = NOKANJI;
	    HTkcode specified_kcode = NOKANJI;

	    /* init */
	    memset(&I, 0, sizeof(I));
	    I.name_cs = ATTR_CS_IN;
	    I.value_cs = ATTR_CS_IN;

	    UPDATE_STYLE;

	    /*
	     * Before any input field, add a collapsible space if we're not in
	     * a PRE block, to promote a wrap there for any long values that
	     * would extend past the right margin from our current position in
	     * the line.  If we are in a PRE block, start a new line if the
	     * last line already is within 6 characters of the wrap point for
	     * PRE blocks.  - FM
	     */
	    if (me->sp[0].tag_number != HTML_PRE && !me->inPRE &&
		me->sp->style->freeFormat) {
		HTML_put_character(me, ' ');
		me->in_word = NO;
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcolLimit - 6)) {
		HTML_put_character(me, '\n');
		me->in_word = NO;
	    }

	    /*
	     * Get the TYPE and make sure we can handle it.  - FM
	     */
	    if (present && present[HTML_INPUT_TYPE] &&
		non_empty(value[HTML_INPUT_TYPE])) {
		const char *not_impl = NULL;
		char *usingval = NULL;

		I.type = value[HTML_INPUT_TYPE];

		if (!strcasecomp(I.type, "range")) {
		    if (present[HTML_INPUT_MIN] &&
			non_empty(value[HTML_INPUT_MIN]))
			I.min = value[HTML_INPUT_MIN];
		    if (present[HTML_INPUT_MAX] &&
			non_empty(value[HTML_INPUT_MAX]))
			I.max = value[HTML_INPUT_MAX];
		    /*
		     * Not yet implemented.
		     */
#ifdef NOTDEFINED
		    not_impl = "[RANGE Input]";
		    if (me->inFORM)
			HText_DisableCurrentForm();
#endif /* NOTDEFINED */
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"range\"\n"));
		    break;

		} else if (!strcasecomp(I.type, "file")) {
		    if (present[HTML_INPUT_ACCEPT] &&
			non_empty(value[HTML_INPUT_ACCEPT]))
			I.accept = value[HTML_INPUT_ACCEPT];
#ifndef USE_FILE_UPLOAD
		    not_impl = "[FILE Input]";
		    CTRACE((tfp, "Attempting to fake as: %s\n", I.type));
#ifdef NOTDEFINED
		    if (me->inFORM)
			HText_DisableCurrentForm();
#endif /* NOTDEFINED */
		    CTRACE((tfp, "HTML: Ignoring TYPE=\"file\"\n"));
#endif /* USE_FILE_UPLOAD */

		} else if (!strcasecomp(I.type, "button")) {
		    /*
		     * Ugh, a button for a script.
		     */
		    not_impl = "[BUTTON Input]";
		}
		if (not_impl != NULL) {
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_START_CHAR);
		    }
		    HTML_put_string(me, not_impl);
		    if (usingval != NULL) {
			HTML_put_string(me, usingval);
			FREE(usingval);
		    } else {
			HTML_put_string(me, " (not implemented)");
		    }
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_END_CHAR);
		    }
		}
	    }

	    CTRACE((tfp, "Ok, we're trying type=[%s]\n", NONNULL(I.type)));

	    /*
	     * Check for an unclosed TEXTAREA.
	     */
	    if (me->inTEXTAREA) {
		if (LYBadHTML(me)) {
		    LYShowBadHTML("Bad HTML: Missing TEXTAREA end tag.\n");
		}
	    }

	    /*
	     * Check for an unclosed SELECT, try to close it if found.
	     */
	    if (me->inSELECT) {
		CTRACE((tfp, "HTML: Missing SELECT end tag, faking it...\n"));
		if (me->sp->tag_number != HTML_SELECT) {
		    SET_SKIP_STACK(HTML_SELECT);
		}
		HTML_end_element(me, HTML_SELECT, include);
	    }

	    /*
	     * Handle the INPUT as for a FORM.  - FM
	     */
	    if (!(present && present[HTML_INPUT_NAME] &&
		  non_empty(value[HTML_INPUT_NAME]))) {
		I.name = "";
	    } else if (StrChr(value[HTML_INPUT_NAME], '&') == NULL) {
		I.name = value[HTML_INPUT_NAME];
	    } else {
		StrAllocCopy(I_name, value[HTML_INPUT_NAME]);
		UNESCAPE_FIELDNAME_TO_STD(&I_name);
		I.name = I_name;
	    }

	    if ((present && present[HTML_INPUT_ALT] &&
		 non_empty(value[HTML_INPUT_ALT]) &&
		 I.type && !strcasecomp(I.type, "image")) &&
		!(present && present[HTML_INPUT_VALUE] &&
		  non_empty(value[HTML_INPUT_VALUE]))) {
		/*
		 * This is a TYPE="image" using an ALT rather than VALUE
		 * attribute to indicate the link string for text clients or
		 * GUIs with image loading off, so set the flag to use that as
		 * if it were a VALUE attribute.  - FM
		 */
		UseALTasVALUE = TRUE;
	    }
	    if (verbose_img && !clickable_images &&
		present && present[HTML_INPUT_SRC] &&
		non_empty(value[HTML_INPUT_SRC]) &&
		I.type && !strcasecomp(I.type, "image")) {
		ImageSrc = MakeNewImageValue(value);
	    } else if (clickable_images == TRUE &&
		       present && present[HTML_INPUT_SRC] &&
		       non_empty(value[HTML_INPUT_SRC]) &&
		       I.type && !strcasecomp(I.type, "image")) {
		StrAllocCopy(href, value[HTML_INPUT_SRC]);
		/*
		 * We have a TYPE="image" with a non-zero-length SRC attribute
		 * and want clickable images.  Make the SRC's value a link if
		 * it's still not zero-length legitimizing it.  - FM
		 */
		LYLegitimizeHREF(me, &href, TRUE, TRUE);
		if (*href) {

		    if (me->inA) {
			SET_SKIP_STACK(HTML_A);
			HTML_end_element(me, HTML_A, include);
		    }
		    me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							     NULL,	/* Tag */
							     href,	/* Addresss */
							     (HTLinkType *) 0);		/* Type */
		    HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		    HTML_put_string(me, VERBOSE_IMG(value,
						    HTML_INPUT_SRC,
						    "[IMAGE]"));
		    FREE(newtitle);
		    if (me->inBoldH == FALSE)
			HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		    HText_endAnchor(me->text, 0);
		    HTML_put_character(me, '-');
		    HaveSRClink = TRUE;
		}
		FREE(href);
	    }
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n",
		    NONNULL(I.type),
		    present));
	    /* text+file don't go in here */
	    if ((UseALTasVALUE == TRUE) ||
		(present && present[HTML_INPUT_VALUE] &&
		 value[HTML_INPUT_VALUE] &&
		 (*value[HTML_INPUT_VALUE] ||
		  (I.type && (!strcasecomp(I.type, "checkbox") ||
			      !strcasecomp(I.type, "radio")))))) {

		/*
		 * Convert any HTML entities or decimal escaping.  - FM
		 */
		int CurrentCharSet = current_char_set;
		BOOL CurrentEightBitRaw = HTPassEightBitRaw;
		BOOLEAN CurrentUseDefaultRawMode = LYUseDefaultRawMode;
		HTCJKlang CurrentHTCJK = HTCJK;

		if (I.type && !strcasecomp(I.type, "hidden")) {
		    me->HiddenValue = TRUE;
		    current_char_set = LATIN1;	/* Default ISO-Latin1 */
		    LYUseDefaultRawMode = TRUE;
		    HTMLSetCharacterHandling(current_char_set);
		}

		CTRACE((tfp, "3.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
		if (!I.type)
		    me->UsePlainSpace = TRUE;
		else if (!strcasecomp(I.type, "text") ||
#ifdef USE_FILE_UPLOAD
			 !strcasecomp(I.type, "file") ||
#endif
			 !strcasecomp(I.type, "submit") ||
			 !strcasecomp(I.type, "image") ||
			 !strcasecomp(I.type, "reset")) {
		    CTRACE((tfp, "normal field type: %s\n", NONNULL(I.type)));
		    me->UsePlainSpace = TRUE;
		}

		StrAllocCopy(I_value,
			     ((UseALTasVALUE == TRUE)
			      ? value[HTML_INPUT_ALT]
			      : value[HTML_INPUT_VALUE]));
		if (me->UsePlainSpace && !me->HiddenValue) {
		    I.value_cs = current_char_set;
		}
		CTRACE((tfp, "4.Ok, we're trying type=[%s]\n", NONNULL(I.type)));
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						 ATTR_CS_IN,
						 I.value_cs,
						 (BOOL) (me->UsePlainSpace &&
							 !me->HiddenValue),
						 me->UsePlainSpace,
						 me->HiddenValue);
		I.value = I_value;
		if (me->UsePlainSpace == TRUE) {
		    /*
		     * Convert any newlines or tabs to spaces, and trim any
		     * lead or trailing spaces.  - FM
		     */
		    LYReduceBlanks(I.value);
		}
		me->UsePlainSpace = FALSE;

		if (I.type && !strcasecomp(I.type, "hidden")) {
		    me->HiddenValue = FALSE;
		    current_char_set = CurrentCharSet;
		    LYUseDefaultRawMode = CurrentUseDefaultRawMode;
		    HTMLSetCharacterHandling(current_char_set);
		    HTPassEightBitRaw = CurrentEightBitRaw;
		    HTCJK = CurrentHTCJK;
		}
	    } else if (HaveSRClink == TRUE) {
		/*
		 * We put up an [IMAGE] link and '-' for a TYPE="image" and
		 * didn't get a VALUE or ALT string, so fake a "Submit" value. 
		 * If we didn't put up a link, then HText_beginInput() will use
		 * "[IMAGE]-Submit".  - FM
		 */
		StrAllocCopy(I_value, "Submit");
		I.value = I_value;
	    } else if (ImageSrc) {
		/* [IMAGE]-Submit with verbose images and not clickable images.
		 * Use ImageSrc if no other alt or value is supplied. --LE
		 */
		I.value = ImageSrc;
	    }
	    if (present && present[HTML_INPUT_READONLY])
		I.readonly = YES;
	    if (present && present[HTML_INPUT_CHECKED])
		I.checked = YES;
	    if (present && present[HTML_INPUT_SIZE] &&
		non_empty(value[HTML_INPUT_SIZE]))
		I.size = atoi(value[HTML_INPUT_SIZE]);
	    LimitValue(I.size, MAX_LINE);
	    if (present && present[HTML_INPUT_MAXLENGTH] &&
		non_empty(value[HTML_INPUT_MAXLENGTH]))
		I.maxlength = value[HTML_INPUT_MAXLENGTH];
	    if (present && present[HTML_INPUT_DISABLED])
		I.disabled = YES;

	    if (present && present[HTML_INPUT_ACCEPT_CHARSET]) {	/* Not yet used. */
		I.accept_cs = (value[HTML_INPUT_ACCEPT_CHARSET]
			       ? value[HTML_INPUT_ACCEPT_CHARSET]
			       : "UNKNOWN");
	    }
	    if (present && present[HTML_INPUT_ALIGN] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_ALIGN]))
		I.align = value[HTML_INPUT_ALIGN];
	    if (present && present[HTML_INPUT_CLASS] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_CLASS]))
		I.iclass = value[HTML_INPUT_CLASS];
	    if (present && present[HTML_INPUT_ERROR] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_ERROR]))
		I.error = value[HTML_INPUT_ERROR];
	    if (present && present[HTML_INPUT_HEIGHT] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_HEIGHT]))
		I.height = value[HTML_INPUT_HEIGHT];
	    if (present && present[HTML_INPUT_WIDTH] &&		/* Not yet used. */
		non_empty(value[HTML_INPUT_WIDTH]))
		I.width = value[HTML_INPUT_WIDTH];
	    if (present && present[HTML_INPUT_ID] &&
		non_empty(value[HTML_INPUT_ID])) {
		I.id = value[HTML_INPUT_ID];
		CHECK_ID(HTML_INPUT_ID);
	    }
	    if (present && present[HTML_INPUT_LANG] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_LANG]))
		I.lang = value[HTML_INPUT_LANG];
	    if (present && present[HTML_INPUT_MD] &&	/* Not yet used. */
		non_empty(value[HTML_INPUT_MD]))
		I.md = value[HTML_INPUT_MD];

	    chars = HText_beginInput(me->text, me->inUnderline, &I);
	    CTRACE((tfp,
		    "I.%s have %d chars, or something\n",
		    NONNULL(I.type),
		    chars));
	    /*
	     * Submit and reset buttons have values which don't change, so
	     * HText_beginInput() sets I.value to the string which should be
	     * displayed, and we'll enter that instead of underscore
	     * placeholders into the HText structure to see it instead of
	     * underscores when dumping or printing.  We also won't worry about
	     * a wrap in PRE blocks, because the line editor never is invoked
	     * for submit or reset buttons.  - LE & FM
	     */
	    if (I.type &&
		(!strcasecomp(I.type, "submit") ||
		 !strcasecomp(I.type, "reset") ||
		 !strcasecomp(I.type, "image")))
		IsSubmitOrReset = TRUE;

	    if (I.type && chars == 3 &&
		!strcasecomp(I.type, "radio")) {
		/*
		 * Put a (_) placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
		 */
		HTML_put_string(me, "(_)");
		HText_endInput(me->text);
		chars = 0;
		me->in_word = YES;
		if (me->sp[0].tag_number != HTML_PRE &&
		    me->sp->style->freeFormat) {
		    HTML_put_character(me, ' ');
		    me->in_word = NO;
		}
	    } else if (I.type && chars == 3 &&
		       !strcasecomp(I.type, "checkbox")) {
		/*
		 * Put a [_] placeholder, and one space (collapsible) before
		 * the label that is expected to follow.  - FM
		 */
		HTML_put_string(me, "[_]");
		HText_endInput(me->text);
		chars = 0;
		me->in_word = YES;
		if (me->sp[0].tag_number != HTML_PRE &&
		    me->sp->style->freeFormat) {
		    HTML_put_character(me, ' ');
		    me->in_word = NO;
		}
	    } else if ((me->sp[0].tag_number == HTML_PRE ||
			!me->sp->style->freeFormat)
		       && chars > 6 &&
		       IsSubmitOrReset == FALSE) {
		/*
		 * This is not a submit or reset button, and we are in a PRE
		 * block with a field intended to exceed 6 character widths. 
		 * The code inadequately handles INPUT fields in PRE tags if
		 * wraps occur (at the right margin) for the underscore
		 * placeholders.  We'll put up a minimum of 6 underscores,
		 * since we should have wrapped artificially, above, if the
		 * INPUT begins within 6 columns of the right margin, and if
		 * any more would exceed the wrap column, we'll ignore them. 
		 * Note that if we somehow get tripped up and a wrap still does
		 * occur before all 6 of the underscores are output, the
		 * wrapped ones won't be treated as part of the editing window,
		 * nor be highlighted when not editing (Yuk!).  - FM
		 */
		for (i = 0; i < 6; i++) {
		    HTML_put_character(me, '_');
		    chars--;
		}
	    }
	    CTRACE((tfp, "I.%s, %d\n", NONNULL(I.type), IsSubmitOrReset));
	    if (IsSubmitOrReset == FALSE) {
		/*
		 * This is not a submit or reset button, so output the rest of
		 * the underscore placeholders, if any more are needed.  - FM
		 */
		if (chars > 0) {
		    for (; chars > 0; chars--)
			HTML_put_character(me, '_');
		    HText_endInput(me->text);
		}
	    } else {
		if (HTCJK == JAPANESE) {
		    kcode = HText_getKcode(me->text);
		    HText_updateKcode(me->text, kanji_code);
		    specified_kcode = HText_getSpecifiedKcode(me->text);
		    HText_updateSpecifiedKcode(me->text, kanji_code);
		}
		if (me->sp[0].tag_number == HTML_PRE ||
		    !me->sp->style->freeFormat) {
		    /*
		     * We have a submit or reset button in a PRE block, so
		     * output the entire value from the markup.  If it extends
		     * to the right margin, it will wrap there, and only the
		     * portion before that wrap will be hightlighted on screen
		     * display (Yuk!) but we may as well show the rest of the
		     * full value on the next or more lines.  - FM
		     */
		    while (I.value[i])
			HTML_put_character(me, I.value[i++]);
		} else {
		    /*
		     * The submit or reset button is not in a PRE block.  Note
		     * that if a wrap occurs before outputting the entire
		     * value, the wrapped portion will not be highlighted or
		     * clearly indicated as part of the link for submission or
		     * reset (Yuk!).  We'll replace any spaces in the submit or
		     * reset button value with nbsp, to promote a wrap at the
		     * space we ensured would be present before the start of
		     * the string, as when we use all underscores instead of
		     * the INPUT's actual value, but we could still get a wrap
		     * at the right margin, instead, if the value is greater
		     * than a line width for the current style.  Also, if chars
		     * somehow ended up longer than the length of the actual
		     * value (shouldn't have), we'll continue padding with nbsp
		     * up to the length of chars.  - FM
		     */
		    for (i = 0; I.value[i]; i++)
			HTML_put_character(me,
					   (char) (I.value[i] == ' '
						   ? HT_NON_BREAK_SPACE
						   : I.value[i]));
		    while (i++ < chars)
			HTML_put_character(me, HT_NON_BREAK_SPACE);
		}
		if (HTCJK == JAPANESE) {
		    HText_updateKcode(me->text, kcode);
		    HText_updateSpecifiedKcode(me->text, specified_kcode);
		}
	    }
	    if (chars != 0) {
		HText_endInput(me->text);
	    }
	    FREE(ImageSrc);
	    FREE(I_value);
	    FREE(I_name);
	}
	break;

    case HTML_TEXTAREA:
	/*
	 * Set to know we are in a textarea.
	 */
	me->inTEXTAREA = TRUE;

	/*
	 * Get ready for the value.
	 */
	HTChunkClear(&me->textarea);
	if (present && present[HTML_TEXTAREA_NAME] &&
	    value[HTML_TEXTAREA_NAME]) {
	    StrAllocCopy(me->textarea_name, value[HTML_TEXTAREA_NAME]);
	    me->textarea_name_cs = ATTR_CS_IN;
	    if (StrChr(value[HTML_TEXTAREA_NAME], '&') != NULL) {
		UNESCAPE_FIELDNAME_TO_STD(&me->textarea_name);
	    }
	} else {
	    StrAllocCopy(me->textarea_name, "");
	}

	if (present && present[HTML_TEXTAREA_ACCEPT_CHARSET]) {
	    if (value[HTML_TEXTAREA_ACCEPT_CHARSET]) {
		StrAllocCopy(me->textarea_accept_cs, value[HTML_TEXTAREA_ACCEPT_CHARSET]);
		TRANSLATE_AND_UNESCAPE_TO_STD(&me->textarea_accept_cs);
	    } else {
		StrAllocCopy(me->textarea_accept_cs, "UNKNOWN");
	    }
	} else {
	    FREE(me->textarea_accept_cs);
	}

	if (present && present[HTML_TEXTAREA_COLS] &&
	    value[HTML_TEXTAREA_COLS] &&
	    isdigit(UCH(*value[HTML_TEXTAREA_COLS]))) {
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
	} else {
	    int width;

	    width = LYcolLimit -
		me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately)	/* don't waste too much for this */
		width = HTMIN(width, DFT_TEXTAREA_COLS);
	    if (width > 1 && (width - 1) * 6 < MAX_LINE - 3 -
		me->new_style->leftIndent - me->new_style->rightIndent)
		me->textarea_cols = width;
	    else
		me->textarea_cols = DFT_TEXTAREA_COLS;
	}
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);

	if (present && present[HTML_TEXTAREA_ROWS] &&
	    value[HTML_TEXTAREA_ROWS] &&
	    isdigit(UCH(*value[HTML_TEXTAREA_ROWS]))) {
	    me->textarea_rows = atoi(value[HTML_TEXTAREA_ROWS]);
	} else {
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	}
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);

	/*
	 * Lynx treats disabled and readonly textarea's the same -
	 * unmodifiable in either case.
	 */
	me->textarea_readonly = NO;
	if (present && present[HTML_TEXTAREA_READONLY])
	    me->textarea_readonly = YES;

	me->textarea_disabled = NO;
	if (present && present[HTML_TEXTAREA_DISABLED])
	    me->textarea_disabled = YES;

	if (present && present[HTML_TEXTAREA_ID]
	    && non_empty(value[HTML_TEXTAREA_ID])) {
	    StrAllocCopy(id_string, value[HTML_TEXTAREA_ID]);
	    TRANSLATE_AND_UNESCAPE_TO_STD(&id_string);
	    if ((id_string != '\0') &&
		(ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
						  id_string,	/* Tag */
						  NULL,		/* Addresss */
						  (HTLinkType *) 0))) {		/* Type */
		HText_beginAnchor(me->text, me->inUnderline, ID_A);
		HText_endAnchor(me->text, 0);
		StrAllocCopy(me->textarea_id, id_string);
	    } else {
		FREE(me->textarea_id);
	    }
	    FREE(id_string);
	} else {
	    FREE(me->textarea_id);
	}
	break;

    case HTML_SELECT:
	/*
	 * Check for an already open SELECT block.  - FM
	 */
	if (me->inSELECT) {
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n");
	    }
	    if (me->sp->tag_number != HTML_SELECT) {
		SET_SKIP_STACK(HTML_SELECT);
	    }
	    HTML_end_element(me, HTML_SELECT, include);
	}

	/*
	 * Start a new SELECT block. - FM
	 */
	LYHandleSELECT(me,
		       present, (STRING2PTR) value,
		       include,
		       TRUE);
	break;

    case HTML_OPTION:
	{
	    /*
	     * An option is a special case of an input field.
	     */
	    InputFieldData I;

	    /*
	     * Make sure we're in a select tag.
	     */
	    if (!me->inSELECT) {
		if (LYBadHTML(me)) {
		    LYShowBadHTML("Bad HTML: OPTION tag not within SELECT tag\n");
		}

		/*
		 * Too likely to cause a crash, so we'll ignore it.  - FM
		 */
		break;
	    }

	    if (!me->first_option) {
		/*
		 * Finish the data off.
		 */
		HTChunkTerminate(&me->option);

		/*
		 * Finish the previous option @@@@@@@@@@
		 */
		HText_setLastOptionValue(me->text,
					 me->option.data,
					 me->LastOptionValue,
					 MIDDLE_ORDER,
					 me->LastOptionChecked,
					 me->UCLYhndl,
					 ATTR_CS_IN);
	    }

	    /*
	     * If it's not a multiple option list and select popups are
	     * enabled, then don't use the checkbox/button method, and don't
	     * put anything on the screen yet.
	     */
	    if (me->first_option ||
		HTCurSelectGroupType == F_CHECKBOX_TYPE ||
		LYSelectPopups == FALSE) {
		if (HTCurSelectGroupType == F_CHECKBOX_TYPE ||
		    LYSelectPopups == FALSE) {
		    /*
		     * Start a newline before each option.
		     */
		    LYEnsureSingleSpace(me);
		} else {
		    /*
		     * Add option list designation character.
		     */
		    HText_appendCharacter(me->text, '[');
		    me->in_word = YES;
		}

		/*
		 * Inititialize.
		 */
		memset(&I, 0, sizeof(I));
		I.name_cs = -1;
		I.value_cs = current_char_set;

		I.type = "OPTION";

		if ((present && present[HTML_OPTION_SELECTED]) ||
		    (me->first_option && LYSelectPopups == FALSE &&
		     HTCurSelectGroupType == F_RADIO_TYPE))
		    I.checked = YES;

		if (present && present[HTML_OPTION_VALUE] &&
		    value[HTML_OPTION_VALUE]) {
		    /*
		     * Convert any HTML entities or decimal escaping.  - FM
		     */
		    StrAllocCopy(I_value, value[HTML_OPTION_VALUE]);
		    me->HiddenValue = TRUE;
		    TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
		    I.value_cs = ATTR_CS_IN;
		    me->HiddenValue = FALSE;

		    I.value = I_value;
		}

		if (me->select_disabled ||
		    (0 && present && present[HTML_OPTION_DISABLED])) {
		    /* 2009/5/25 - suppress check for "disabled" attribute
		     * for Debian #525934 -TD
		     */
		    I.disabled = YES;
		}

		if (present && present[HTML_OPTION_ID]
		    && non_empty(value[HTML_OPTION_ID])) {
		    if ((ID_A = HTAnchor_findChildAndLink(me->node_anchor,	/* Parent */
							  value[HTML_OPTION_ID],	/* Tag */
							  NULL,		/* Addresss */
							  0)) != NULL) {	/* Type */
			HText_beginAnchor(me->text, me->inUnderline, ID_A);
			HText_endAnchor(me->text, 0);
			I.id = value[HTML_OPTION_ID];
		    }
		}

		HText_beginInput(me->text, me->inUnderline, &I);

		if (HTCurSelectGroupType == F_CHECKBOX_TYPE) {
		    /*
		     * Put a "[_]" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
		     */
		    HText_appendCharacter(me->text, '[');
		    HText_appendCharacter(me->text, '_');
		    HText_appendCharacter(me->text, ']');
		    HText_appendCharacter(me->text, ' ');
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
		    me->in_word = NO;
		} else if (LYSelectPopups == FALSE) {
		    /*
		     * Put a "(_)" placeholder, and one space (collapsible)
		     * before the label that is expected to follow.  - FM
		     */
		    HText_appendCharacter(me->text, '(');
		    HText_appendCharacter(me->text, '_');
		    HText_appendCharacter(me->text, ')');
		    HText_appendCharacter(me->text, ' ');
		    HText_setLastChar(me->text, ' ');	/* absorb white space */
		    me->in_word = NO;
		}
	    }

	    /*
	     * Get ready for the next value.
	     */
	    HTChunkClear(&me->option);
	    if ((present && present[HTML_OPTION_SELECTED]) ||
		(me->first_option && LYSelectPopups == FALSE &&
		 HTCurSelectGroupType == F_RADIO_TYPE))
		me->LastOptionChecked = TRUE;
	    else
		me->LastOptionChecked = FALSE;
	    me->first_option = FALSE;

	    if (present && present[HTML_OPTION_VALUE] &&
		value[HTML_OPTION_VALUE]) {
		if (!I_value) {
		    /*
		     * Convert any HTML entities or decimal escaping.  - FM
		     */
		    StrAllocCopy(I_value, value[HTML_OPTION_VALUE]);
		    me->HiddenValue = TRUE;
		    TRANSLATE_AND_UNESCAPE_ENTITIES6(&I_value,
						     ATTR_CS_IN,
						     ATTR_CS_IN,
						     NO,
						     me->UsePlainSpace, me->HiddenValue);
		    me->HiddenValue = FALSE;
		}
		StrAllocCopy(me->LastOptionValue, I_value);
	    } else {
		StrAllocCopy(me->LastOptionValue, me->option.data);
	    }

	    /*
	     * If this is a popup option, print its option for use in selecting
	     * option by number.  - LE
	     */
	    if (HTCurSelectGroupType == F_RADIO_TYPE &&
		LYSelectPopups &&
		fields_are_numbered()) {
		char marker[8];
		int opnum = HText_getOptionNum(me->text);

		if (opnum > 0 && opnum < 100000) {
		    sprintf(marker, "(%d)", opnum);
		    HTML_put_string(me, marker);
		    for (i = (int) strlen(marker); i < 5; ++i) {
			HTML_put_character(me, '_');
		    }
		}
	    }
	    FREE(I_value);
	}
	break;

    case HTML_TABLE:
	/*
	 * Not fully implemented.  Just treat as a division with respect to any
	 * ALIGN attribute, with a default of HT_LEFT, or leave as a PRE block
	 * if we are presently in one.  - FM
	 *
	 * Also notify simple table tracking code unless in a preformatted
	 * section, or (currently) non-left alignment.
	 *
	 * If page author is using a TABLE within PRE, it's probably formatted
	 * specifically to work well for Lynx without simple table tracking
	 * code.  Cancel tracking, it would only make things worse.  - kw
	 */
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	    HText_cancelStbl(me->text);

	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	me->inTABLE = TRUE;
	if (me->sp->style->id == ST_Preformatted) {
	    UPDATE_STYLE;
	    CHECK_ID(HTML_TABLE_ID);
	    break;
	}
	if (me->Division_Level < (MAX_NESTING - 1)) {
	    me->Division_Level++;
	} else {
	    CTRACE((tfp,
		    "HTML: ****** Maximum nesting of %d divisions/tables exceeded!\n",
		    MAX_NESTING));
	}
	if (present && present[HTML_TABLE_ALIGN] &&
	    non_empty(value[HTML_TABLE_ALIGN])) {
	    if (!strcasecomp(value[HTML_TABLE_ALIGN], "center")) {
		if (no_table_center) {
		    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		    change_paragraph_style(me, styles[HTML_DLEFT]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
			styles[HTML_DLEFT]->alignment;
		} else {
		    me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		    change_paragraph_style(me, styles[HTML_DCENTER]);
		    UPDATE_STYLE;
		    me->current_default_alignment =
			styles[HTML_DCENTER]->alignment;
		}

		stbl_align = HT_CENTER;

	    } else if (!strcasecomp(value[HTML_TABLE_ALIGN], "right")) {
		me->DivisionAlignments[me->Division_Level] = HT_RIGHT;
		change_paragraph_style(me, styles[HTML_DRIGHT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DRIGHT]->alignment;
		stbl_align = HT_RIGHT;
	    } else {
		me->DivisionAlignments[me->Division_Level] = HT_LEFT;
		change_paragraph_style(me, styles[HTML_DLEFT]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DLEFT]->alignment;
		if (!strcasecomp(value[HTML_TABLE_ALIGN], "left") ||
		    !strcasecomp(value[HTML_TABLE_ALIGN], "justify"))
		    stbl_align = HT_LEFT;
	    }
	} else {
	    me->DivisionAlignments[me->Division_Level] = HT_LEFT;
	    change_paragraph_style(me, styles[HTML_DLEFT]);
	    UPDATE_STYLE;
	    me->current_default_alignment = styles[HTML_DLEFT]->alignment;
	    /* stbl_align remains HT_ALIGN_NONE */
	}
	CHECK_ID(HTML_TABLE_ID);
	HText_startStblTABLE(me->text, stbl_align);
	break;

    case HTML_TR:
	/*
	 * Not fully implemented.  Just start a new row, if needed, act on an
	 * ALIGN attribute if present, and check for an ID link.  - FM
	 * Also notify simple table tracking code.  - kw
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb white space */
	    HText_appendCharacter(me->text, '\r');
	}
	me->in_word = NO;

	if (me->sp->style->id == ST_Preformatted) {
	    CHECK_ID(HTML_TR_ID);
	    me->inP = FALSE;
/*	    HText_cancelStbl(me->text);  seems unnecessary here - kw */
	    break;
	}
	if (LYoverride_default_alignment(me)) {
	    me->sp->style->alignment = styles[me->sp[0].tag_number]->alignment;
	} else if (me->List_Nesting_Level >= 0 ||
		   ((me->Division_Level < 0) &&
		    (me->sp->style->id == ST_Normal ||
		     me->sp->style->id == ST_Preformatted))) {
	    me->sp->style->alignment = HT_LEFT;
	} else {
	    me->sp->style->alignment = (short) me->current_default_alignment;
	}
	if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
	    if (!strcasecomp(value[HTML_TR_ALIGN], "center") &&
		!(me->List_Nesting_Level >= 0 && !me->inP)) {
		if (no_table_center)
		    me->sp->style->alignment = HT_LEFT;
		else
		    me->sp->style->alignment = HT_CENTER;
		stbl_align = HT_CENTER;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		       !(me->List_Nesting_Level >= 0 && !me->inP)) {
		me->sp->style->alignment = HT_RIGHT;
		stbl_align = HT_RIGHT;
	    } else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		       !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		me->sp->style->alignment = HT_LEFT;
		stbl_align = HT_LEFT;
	    }
	}

	CHECK_ID(HTML_TR_ID);
	me->inP = FALSE;
	HText_startStblTR(me->text, stbl_align);
	break;

    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
	HText_endStblTR(me->text);
	/*
	 * Not fully implemented.  Just check for an ID link.  - FM
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	if (me->inTABLE) {
	    if (present && present[HTML_TR_ALIGN] && value[HTML_TR_ALIGN]) {
		if (!strcasecomp(value[HTML_TR_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TR_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblRowGroup(me->text, stbl_align);
	}
	CHECK_ID(HTML_TR_ID);
	break;

    case HTML_COL:
    case HTML_COLGROUP:
	/*
	 * Not fully implemented.  Just check for an ID link.  - FM
	 */
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	if (me->inTABLE) {
	    int span = 1;

	    if (present && present[HTML_COL_SPAN] &&
		value[HTML_COL_SPAN] &&
		isdigit(UCH(*value[HTML_COL_SPAN])))
		span = atoi(value[HTML_COL_SPAN]);
	    if (present && present[HTML_COL_ALIGN] && value[HTML_COL_ALIGN]) {
		if (!strcasecomp(value[HTML_COL_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_COL_ALIGN], "left") ||
			   !strcasecomp(value[HTML_COL_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblCOL(me->text, span, stbl_align,
			       (BOOL) (ElementNumber == HTML_COLGROUP));
	}
	CHECK_ID(HTML_COL_ID);
	break;

    case HTML_TH:
    case HTML_TD:
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
	}
	UPDATE_STYLE;
	CHECK_ID(HTML_TD_ID);
	/*
	 * Not fully implemented.  Just add a collapsible space and break - FM
	 * Also notify simple table tracking code.  - kw
	 */
	HTML_put_character(me, ' ');
	{
	    int colspan = 1, rowspan = 1;

	    if (present && present[HTML_TD_COLSPAN] &&
		value[HTML_TD_COLSPAN] &&
		isdigit(UCH(*value[HTML_TD_COLSPAN])))
		colspan = atoi(value[HTML_TD_COLSPAN]);
	    if (present && present[HTML_TD_ROWSPAN] &&
		value[HTML_TD_ROWSPAN] &&
		isdigit(UCH(*value[HTML_TD_ROWSPAN])))
		rowspan = atoi(value[HTML_TD_ROWSPAN]);
	    if (present && present[HTML_TD_ALIGN] && value[HTML_TD_ALIGN]) {
		if (!strcasecomp(value[HTML_TD_ALIGN], "center")) {
		    stbl_align = HT_CENTER;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "right")) {
		    stbl_align = HT_RIGHT;
		} else if (!strcasecomp(value[HTML_TD_ALIGN], "left") ||
			   !strcasecomp(value[HTML_TD_ALIGN], "justify")) {
		    stbl_align = HT_LEFT;
		}
	    }
	    HText_startStblTD(me->text, colspan, rowspan, stbl_align,
			      (BOOL) (ElementNumber == HTML_TH));
	}
	me->in_word = NO;
	break;

    case HTML_MATH:
	/*
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
	 */
	HTChunkClear(&me->math);
	CHECK_ID(HTML_GEN_ID);
	break;

    default:
	break;

    }				/* end switch */

    if (ElementNumber >= HTML_ELEMENTS ||
	HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
	if (me->skip_stack > 0) {
	    CTRACE((tfp,
		    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
		    me->skip_stack, NONNULL(GetHTStyleName(me->sp->style))));
	    me->skip_stack--;
	    return status;
	}
	if (me->sp == me->stack) {
	    if (me->stack_overrun == FALSE) {
		HTAlert(HTML_STACK_OVERRUN);
		CTRACE((tfp,
			"HTML: ****** Maximum nesting of %d tags exceeded!\n",
			MAX_NESTING));
		me->stack_overrun = TRUE;
	    }
	    return HT_ERROR;
	}

	CTRACE((tfp,
		"HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		(int) STACKLEVEL(me),
		NONNULL(GetHTStyleName(me->new_style)),
		HTML_dtd.tags[ElementNumber].name));
	(me->sp)--;
	me->sp[0].style = me->new_style;	/* Stack new style */
	me->sp[0].tag_number = ElementNumber;
#ifdef USE_JUSTIFY_ELTS
	if (wait_for_this_stacked_elt < 0 &&
	    HTML_dtd.tags[ElementNumber].can_justify == FALSE)
	    wait_for_this_stacked_elt = (int) (me->stack - me->sp) + MAX_NESTING;
#endif
    }
#ifdef USE_JUSTIFY_ELTS
    if (in_DT && ElementNumber == HTML_DD)
	in_DT = FALSE;
    else if (ElementNumber == HTML_DT)
	in_DT = TRUE;
#endif

#if defined(USE_COLOR_STYLE)
/* end really empty tags straight away */

    if (ReallyEmptyTagNum(element_number)) {
	CTRACE2(TRACE_STYLE,
		(tfp, "STYLE.begin_element:ending \"EMPTY\" element style\n"));
	HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);

#  if !OMIT_SCN_KEEPING
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
#  endif
    }
#endif /* USE_COLOR_STYLE */
    return status;
}

/*		End Element
 *		-----------
 *
 *	When we end an element, the style must be returned to that
 *	in effect before that element.	Note that anchors (etc?)
 *	don't have an associated style, so that we must scan down the
 *	stack for an element with a defined style. (In fact, the styles
 *	should be linked to the whole stack not just the top one.)
 *	TBL 921119
 */
static int HTML_end_element(HTStructured * me, int element_number,
			    char **include)
{
    static char empty[1];

    int i = 0;
    int status = HT_OK;
    char *temp = NULL, *cp = NULL;
    BOOL BreakFlag = FALSE;
    BOOL intern_flag = FALSE;

#ifdef USE_COLOR_STYLE
    BOOL skip_stack_requested = FALSE;
#endif
    EMIT_IFDEF_USE_JUSTIFY_ELTS(BOOL reached_awaited_stacked_elt = FALSE);

#ifdef USE_PRETTYSRC
    if (psrc_view && !sgml_in_psrc_was_initialized) {
	if (!psrc_nested_call) {
	    HTTag *tag = &HTML_dtd.tags[element_number];
	    char buf[200];
	    int tag_charset = 0;

	    psrc_nested_call = TRUE;
	    PSRCSTART(abracket);
	    PUTS("</");
	    PSRCSTOP(abracket);
	    PSRCSTART(tag);
	    if (tagname_transform != 0)
		PUTS(tag->name);
	    else {
		LYStrNCpy(buf, tag->name, sizeof(buf) - 1);
		LYLowerCase(buf);
		PUTS(buf);
	    }
	    PSRCSTOP(tag);
	    PSRCSTART(abracket);
	    PUTC('>');
	    PSRCSTOP(abracket);
	    psrc_nested_call = FALSE;
	    return HT_OK;
	}
	/*fall through */
    }
#endif

    if ((me->sp >= (me->stack + MAX_NESTING - 1) ||
	 element_number != me->sp[0].tag_number) &&
	HTML_dtd.tags[element_number].contents != SGML_EMPTY) {
	CTRACE((tfp,
		"HTML: end of element %s when expecting end of %s\n",
		HTML_dtd.tags[element_number].name,
		(me->sp == me->stack + MAX_NESTING - 1) ? "none" :
		(me->sp->tag_number < 0) ? "*invalid tag*" :
		(me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
		HTML_dtd.tags[me->sp->tag_number].name));
    }

    /*
     * If we're seeking MAPs, skip everything that's not a MAP or AREA tag.  -
     * FM
     */
    if (LYMapsOnly) {
	if (!(element_number == HTML_MAP || element_number == HTML_AREA ||
	      element_number == HTML_OBJECT)) {
	    return HT_OK;
	}
    }

    /*
     * Pop state off stack if we didn't declare the element SGML_EMPTY in
     * HTMLDTD.c.  - FM & KW
     */
    if (HTML_dtd.tags[element_number].contents != SGML_EMPTY) {
#ifdef USE_COLOR_STYLE
	skip_stack_requested = (BOOL) (me->skip_stack > 0);
#endif
	if ((element_number != me->sp[0].tag_number) &&
	    me->skip_stack <= 0 &&
	    HTML_dtd.tags[HTML_LH].contents != SGML_EMPTY &&
	    (me->sp[0].tag_number == HTML_UL ||
	     me->sp[0].tag_number == HTML_OL ||
	     me->sp[0].tag_number == HTML_MENU ||
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
	    (element_number == HTML_H1 ||
	     element_number == HTML_H2 ||
	     element_number == HTML_H3 ||
	     element_number == HTML_H4 ||
	     element_number == HTML_H5 ||
	     element_number == HTML_H6)) {
	    /*
	     * Set the break flag if we're popping a dummy HTML_LH substituted
	     * for an HTML_H# encountered in a list.
	     */
	    BreakFlag = TRUE;
	}
	if (me->skip_stack == 0 && element_number == HTML_OBJECT &&
	    me->sp[0].tag_number == HTML_OBJECT_M &&
	    (me->sp < (me->stack + MAX_NESTING - 1)))
	    me->sp[0].tag_number = HTML_OBJECT;
	if (me->skip_stack > 0) {
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
		     me->skip_stack, NONNULL(GetHTStyleName(me->sp->style))));
	    me->skip_stack--;
	} else if (element_number == HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT &&
		   me->sp[0].tag_number != HTML_OBJECT_M &&
		   me->objects_mixed_open > 0 &&
		   !(me->objects_figged_open > 0 &&
		     me->sp[0].tag_number == HTML_FIG)) {
	    /*
	     * Ignore non-corresponding OBJECT tags that we didn't push because
	     * the SGML parser was supposed to go on parsing the contents
	     * non-literally.  - kw
	     */
	    CTRACE2(TRACE_STYLE,
		    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
		     (int) STACKLEVEL(me),
		     "Special OBJECT handling", me->objects_mixed_open,
		     "leaving on stack",
		     NONNULL(GetHTStyleName(me->sp->style))));
	    me->objects_mixed_open--;
	} else if (me->stack_overrun == TRUE &&
		   element_number != me->sp[0].tag_number) {
	    /*
	     * Ignore non-corresponding tags if we had a stack overrun.  This
	     * is not a completely fail-safe strategy for protection against
	     * any seriously adverse consequences of a stack overrun, and the
	     * rendering of the document will not be as intended, but we expect
	     * overruns to be rare, and this should offer reasonable protection
	     * against crashes if an overrun does occur.  - FM
	     */
	    return HT_OK;	/* let's pretend... */
	} else if (element_number == HTML_SELECT &&
		   me->sp[0].tag_number != HTML_SELECT) {
	    /*
	     * Ignore non-corresponding SELECT tags, since we probably popped
	     * it and closed the SELECT block to deal with markup which amounts
	     * to a nested SELECT, or an out of order FORM end tag.  - FM
	     */
	    return HT_OK;
	} else if ((element_number != me->sp[0].tag_number) &&
		   HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY &&
		   (me->sp[0].tag_number == HTML_UL ||
		    me->sp[0].tag_number == HTML_OL ||
		    me->sp[0].tag_number == HTML_MENU ||
		    me->sp[0].tag_number == HTML_DIR ||
		    me->sp[0].tag_number == HTML_LI) &&
		   (element_number == HTML_H1 ||
		    element_number == HTML_H2 ||
		    element_number == HTML_H3 ||
		    element_number == HTML_H4 ||
		    element_number == HTML_H5 ||
		    element_number == HTML_H6)) {
	    /*
	     * It's an H# for which we substituted an HTML_LH, which we've
	     * declared as SGML_EMPTY, so just return.  - FM
	     */
	    return HT_OK;
	} else if (me->sp < (me->stack + MAX_NESTING - 1)) {
#ifdef USE_JUSTIFY_ELTS
	    if (wait_for_this_stacked_elt == me->stack - me->sp + MAX_NESTING)
		reached_awaited_stacked_elt = TRUE;
#endif
	    if (element_number == HTML_OBJECT) {
		if (me->sp[0].tag_number == HTML_FIG &&
		    me->objects_figged_open > 0) {
		    /*
		     * It's an OBJECT for which we substituted a FIG, so pop
		     * the FIG and pretend that's what we are being called for. 
		     * - kw
		     */
		    CTRACE2(TRACE_STYLE,
			    (tfp,
			     "HTML:end_element[%d]: %s (level %d), %s - %s\n",
			     (int) STACKLEVEL(me),
			     "Special OBJECT->FIG handling",
			     me->objects_figged_open,
			     "treating as end FIG",
			     NONNULL(GetHTStyleName(me->sp->style))));
		    me->objects_figged_open--;
		    element_number = HTML_FIG;
		}
	    }
	    (me->sp)++;
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "HTML:end_element[%d]: Popped style off stack - %s\n",
		     (int) STACKLEVEL(me),
		     NONNULL(GetHTStyleName(me->sp->style))));
	} else {
	    CTRACE2(TRACE_STYLE, (tfp,
				  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
	}
    }
    if (BreakFlag == TRUE) {
#ifdef USE_JUSTIFY_ELTS
	if (reached_awaited_stacked_elt)
	    wait_for_this_stacked_elt = -1;
#endif
	return HT_OK;		/* let's pretend... */
    }

    /*
     * Check for unclosed TEXTAREA.  - FM
     */
    if (me->inTEXTAREA && element_number != HTML_TEXTAREA) {
	if (LYBadHTML(me)) {
	    LYShowBadHTML("Bad HTML: Missing TEXTAREA end tag\n");
	}
    }

    if (!me->text && !LYMapsOnly) {
	UPDATE_STYLE;
    }

    /*
     * Handle the end tag.  - FM
     */
    switch (element_number) {

    case HTML_HTML:
	if (me->inA || me->inSELECT || me->inTEXTAREA) {
	    if (LYBadHTML(me)) {
		char *msg = NULL;

		HTSprintf0(&msg,
			   "Bad HTML: %s%s%s%s%s not closed before HTML end tag *****\n",
			   me->inSELECT ? "SELECT" : "",
			   (me->inSELECT && me->inTEXTAREA) ? ", " : "",
			   me->inTEXTAREA ? "TEXTAREA" : "",
			   (((me->inSELECT || me->inTEXTAREA) && me->inA)
			    ? ", "
			    : ""),
			   me->inA ? "A" : "");
		LYShowBadHTML(msg);
		FREE(msg);
	    }
	}
	break;

    case HTML_HEAD:
	if (me->inBASE &&
	    (LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE, 0) ||
	     LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE, 0))) {
	    /* If we are parsing the List Page, and have a BASE after we are
	     * done with the HEAD element, propagate it back to the node_anchor
	     * object.  The base should have been inserted by showlist() to
	     * record what document the List Page is about, and other functions
	     * may later look for it in the anchor.  - kw
	     */
	    StrAllocCopy(me->node_anchor->content_base, me->base_href);
	}
	if (HText_hasToolbar(me->text))
	    HText_appendParagraph(me->text);
	break;

    case HTML_TITLE:
	HTChunkTerminate(&me->title);
	HTAnchor_setTitle(me->node_anchor, me->title.data);
	HTChunkClear(&me->title);
	/*
	 * Check if it's a bookmark file, and if so, and multiple bookmark
	 * support is on, or it's off but this isn't the default bookmark file
	 * (e.g., because it was on before, and this is another bookmark file
	 * that has been retrieved as a previous document), insert the current
	 * description string and filepath for it.  We pass the strings back to
	 * the SGML parser so that any 8 bit or multibyte/CJK characters will
	 * be handled by the parser's state and charset routines.  - FM
	 */
	if (non_empty(me->node_anchor->bookmark)) {
	    if ((LYMultiBookmarks != MBM_OFF) ||
		(non_empty(bookmark_page) &&
		 strcmp(me->node_anchor->bookmark, bookmark_page))) {
		if (!include)
		    include = &me->xinclude;
		for (i = 0; i <= MBM_V_MAXFILES; i++) {
		    if (MBM_A_subbookmark[i] &&
			!strcmp(MBM_A_subbookmark[i],
				me->node_anchor->bookmark)) {
			StrAllocCat(*include, "<H2><EM>");
			StrAllocCat(*include, gettext("Description:"));
			StrAllocCat(*include, "</EM> ");
			StrAllocCopy(temp,
				     ((MBM_A_subdescript[i] &&
				       *MBM_A_subdescript[i]) ?
				      MBM_A_subdescript[i] : gettext("(none)")));
			LYEntify(&temp, TRUE);
			StrAllocCat(*include, temp);
			StrAllocCat(*include, "<BR><EM>&nbsp;&nbsp;&nbsp;");
			StrAllocCat(*include, gettext("Filepath:"));
			StrAllocCat(*include, "</EM> ");
			StrAllocCopy(temp,
				     ((MBM_A_subbookmark[i] &&
				       *MBM_A_subbookmark[i])
				      ? MBM_A_subbookmark[i]
				      : gettext("(unknown)")));
			LYEntify(&temp, TRUE);
			StrAllocCat(*include, temp);
			FREE(temp);
			StrAllocCat(*include, "</H2>");
			break;
		    }
		}
	    }
	}
	break;

    case HTML_STYLE:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkTerminate(&me->style_block);
	CTRACE2(TRACE_STYLE,
		(tfp, "HTML: STYLE content =\n%s\n",
		 me->style_block.data));
	HTChunkClear(&me->style_block);
	break;

    case HTML_SCRIPT:
	/*
	 * We're getting it as Literal text, which, for now, we'll just ignore. 
	 * - FM
	 */
	HTChunkTerminate(&me->script);
	CTRACE((tfp, "HTML: SCRIPT content =\n%s\n",
		me->script.data));
	HTChunkClear(&me->script);
	break;

    case HTML_BODY:
	if (me->inA || me->inSELECT || me->inTEXTAREA) {
	    if (LYBadHTML(me)) {
		char *msg = NULL;

		HTSprintf0(&msg,
			   "Bad HTML: %s%s%s%s%s not closed before BODY end tag *****\n",
			   me->inSELECT ? "SELECT" : "",
			   (me->inSELECT && me->inTEXTAREA) ? ", " : "",
			   me->inTEXTAREA ? "TEXTAREA" : "",
			   (((me->inSELECT || me->inTEXTAREA) && me->inA)
			    ? ", "
			    : ""),
			   me->inA ? "A" : "");
		LYShowBadHTML(msg);
		FREE(msg);
	    }
	}
	break;

    case HTML_FRAMESET:
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_NOFRAMES:
    case HTML_IFRAME:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_BANNER:
    case HTML_MARQUEE:
    case HTML_BLOCKQUOTE:
    case HTML_BQ:
    case HTML_ADDRESS:
	/*
	 * Set flag to know that style has ended.  Fall through.
	 i_prior_style = -1;
	 */
	change_paragraph_style(me, me->sp->style);
	UPDATE_STYLE;
	if (me->sp->tag_number == element_number)
	    LYEnsureDoubleSpace(me);
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	break;

    case HTML_CENTER:
    case HTML_DIV:
	if (me->Division_Level >= 0)
	    me->Division_Level--;
	if (me->Division_Level >= 0) {
	    if (me->sp->style->alignment !=
		me->DivisionAlignments[me->Division_Level]) {
		if (me->inP)
		    LYEnsureSingleSpace(me);
		me->sp->style->alignment =
		    me->DivisionAlignments[me->Division_Level];
	    }
	}
	change_paragraph_style(me, me->sp->style);
	if (me->style_change) {
	    actually_set_style(me);
	    if (me->List_Nesting_Level >= 0)
		HText_NegateLineOne(me->text);
	} else if (me->inP)
	    LYEnsureSingleSpace(me);
	me->current_default_alignment = me->sp->style->alignment;
	break;

    case HTML_H1:		/* header styles */
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
	if (me->Division_Level >= 0) {
	    me->sp->style->alignment =
		me->DivisionAlignments[me->Division_Level];
	} else if (me->sp->style->id == ST_HeadingCenter ||
		   me->sp->style->id == ST_Heading1) {
	    me->sp->style->alignment = HT_CENTER;
	} else if (me->sp->style->id == ST_HeadingRight) {
	    me->sp->style->alignment = HT_RIGHT;
	} else {
	    me->sp->style->alignment = HT_LEFT;
	}
	change_paragraph_style(me, me->sp->style);
	UPDATE_STYLE;
	if (styles[element_number]->font & HT_BOLD) {
	    if (me->inBoldA == FALSE && me->inBoldH == TRUE) {
		HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	    }
	    me->inBoldH = FALSE;
	}
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	}
	break;

    case HTML_P:
	LYHandlePlike(me,
		      (const BOOL *) 0, (STRING2PTR) 0,
		      include, 0,
		      FALSE);
	break;

    case HTML_FONT:
	me->inFONT = FALSE;
	break;

    case HTML_B:		/* Physical character highlighting */
    case HTML_BLINK:
    case HTML_I:
    case HTML_U:

    case HTML_CITE:		/* Logical character highlighting */
    case HTML_EM:
    case HTML_STRONG:
	/*
	 * Ignore any emphasis end tags if the Underline_Level is not set.  -
	 * FM
	 */
	if (me->Underline_Level <= 0)
	    break;

	/*
	 * Adjust the Underline level counter, and turn off underlining if
	 * appropriate.  - FM
	 */
	me->Underline_Level--;
	if (me->inUnderline && me->Underline_Level < 1) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	    CTRACE((tfp, "Ending underline\n"));
	} else {
	    CTRACE((tfp, "Underline Level is %d\n", me->Underline_Level));
	}
	break;

    case HTML_ABBR:		/* Miscellaneous character containers */
    case HTML_ACRONYM:
    case HTML_AU:
    case HTML_AUTHOR:
    case HTML_BIG:
    case HTML_CODE:
    case HTML_DFN:
    case HTML_KBD:
    case HTML_SAMP:
    case HTML_SMALL:
    case HTML_SUP:
    case HTML_TT:
    case HTML_VAR:
	break;

    case HTML_SUB:
	HText_appendCharacter(me->text, ']');
	break;

    case HTML_DEL:
    case HTML_S:
    case HTML_STRIKE:
	HTML_put_character(me, ' ');
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, ":DEL]");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_INS:
	HTML_put_character(me, ' ');
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	HTML_put_string(me, ":INS]");
	if (me->inUnderline == FALSE)
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	HTML_put_character(me, ' ');
	me->in_word = NO;
	break;

    case HTML_Q:
	if (me->Quote_Level > 0)
	    me->Quote_Level--;
	/*
	 * Should check LANG and/or DIR attributes, and the
	 * me->node_anchor->charset and/or yet to be added structure elements,
	 * to determine whether we should use chevrons, but for now we'll
	 * always use double- or single-quotes.  - FM
	 */
	if (!(me->Quote_Level & 1))
	    HTML_put_character(me, '"');
	else
	    HTML_put_character(me, '\'');
	break;

    case HTML_PRE:		/* Formatted text */
	/*
	 * Set to know that we are no longer in a PRE block.
	 */
	HText_appendCharacter(me->text, '\n');
	me->inPRE = FALSE;
	/* FALLTHRU */
    case HTML_LISTING:		/* Literal text */
	/* FALLTHRU */
    case HTML_XMP:
	/* FALLTHRU */
    case HTML_PLAINTEXT:
	if (me->comment_start)
	    HText_appendText(me->text, me->comment_start);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
	break;

    case HTML_NOTE:
    case HTML_FN:
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	UPDATE_STYLE;
	if (me->sp->tag_number == element_number)
	    LYEnsureDoubleSpace(me);
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	me->inLABEL = FALSE;
	break;

    case HTML_OL:
	me->OL_Counter[me->List_Nesting_Level < 11 ?
		       me->List_Nesting_Level : 11] = OL_VOID;
	/* FALLTHRU */
    case HTML_DL:
	/* FALLTHRU */
    case HTML_UL:
	/* FALLTHRU */
    case HTML_MENU:
	/* FALLTHRU */
    case HTML_DIR:
	me->List_Nesting_Level--;
	CTRACE((tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		me->List_Nesting_Level));
#ifdef USE_JUSTIFY_ELTS
	if (element_number == HTML_DL)
	    in_DT = FALSE;	/*close the term that was without definition. */
#endif
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	UPDATE_STYLE;
	if (me->List_Nesting_Level >= 0)
	    LYEnsureSingleSpace(me);
	break;

    case HTML_SPAN:
	/*
	 * Should undo anything we did based on LANG and/or DIR attributes, and
	 * the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
	 */
	break;

    case HTML_BDO:
	/*
	 * Should undo anything we did based on DIR (and/or LANG) attributes,
	 * and the me->node_anchor->charset and/or yet to be added structure
	 * elements.  - FM
	 */
	break;

    case HTML_A:
	/*
	 * Ignore any spurious A end tags.  - FM
	 */
	if (me->inA == FALSE)
	    break;
	/*
	 * Set to know that we are no longer in an anchor.
	 */
	me->inA = FALSE;
#ifdef MARK_HIDDEN_LINKS
	if (non_empty(hidden_link_marker) &&
	    HText_isAnchorBlank(me->text, me->CurrentANum)) {
	    HText_appendText(me->text, hidden_link_marker);
	}
#endif
	UPDATE_STYLE;
	if (me->inBoldA == TRUE && me->inBoldH == FALSE)
	    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
	HText_endAnchor(me->text, me->CurrentANum);
	me->CurrentANum = 0;
	me->inBoldA = FALSE;
	if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    me->inUnderline = TRUE;
	}
	break;

    case HTML_MAP:
	FREE(me->map_address);
	break;

    case HTML_BODYTEXT:
	/*
	 * We may need to look at this someday to deal with OBJECTs optimally,
	 * but just ignore it for now.  - FM
	 */
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_TEXTFLOW:
	/*
	 * We may need to look at this someday to deal with APPLETs optimally,
	 * but just ignore it for now.  - FM
	 */
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_FIG:
	LYHandleFIG(me, NULL, NULL,
		    0,
		    0,
		    NULL,
		    NULL, NO, FALSE, &intern_flag);
	break;

    case HTML_OBJECT:
	/*
	 * Finish the data off.
	 */
	{
	    int s = 0, e = 0;
	    char *start = NULL, *first_end = NULL, *last_end = NULL;
	    char *first_map = NULL, *last_map = NULL;
	    BOOL have_param = FALSE;
	    char *data = NULL;

	    HTChunkTerminate(&me->object);
	    data = me->object.data;
	    while ((cp = StrChr(data, '<')) != NULL) {
		/*
		 * Look for nested OBJECTs.  This procedure could get tripped
		 * up if invalid comments are present in the content, or if an
		 * OBJECT end tag is present in a quoted attribute.  - FM
		 */
		if (!StrNCmp(cp, "<!--", 4)) {
		    data = LYFindEndOfComment(cp);
		    cp = data;
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6) &&
			   !IsNmChar(cp[6])) {
		    have_param = TRUE;
		} else if (!strncasecomp(cp, "<OBJECT", 7) &&
			   !IsNmChar(cp[7])) {
		    if (s == 0)
			start = cp;
		    s++;
		} else if (!strncasecomp(cp, "</OBJECT", 8) &&
			   !IsNmChar(cp[8])) {
		    if (e == 0)
			first_end = cp;
		    last_end = cp;
		    e++;
		} else if (!strncasecomp(cp, "<MAP", 4) &&
			   !IsNmChar(cp[4])) {
		    if (!first_map)
			first_map = cp;
		    last_map = cp;
		} else if (!strncasecomp(cp, "</MAP", 5) &&
			   !IsNmChar(cp[5])) {
		    last_map = cp;
		}
		data = ++cp;
	    }
	    if (s < e) {
		/*
		 * We had more end tags than start tags, so we have bad HTML or
		 * otherwise misparsed.  - FM
		 */
		if (LYBadHTML(me)) {
		    char *msg = NULL;

		    HTSprintf0(&msg,
			       "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			       me->object.data);
		    LYShowBadHTML(msg);
		    FREE(msg);
		}
		goto End_Object;
	    }
	    if (s > e) {
		if (!me->object_declare && !me->object_name &&
		    !(me->object_shapes && !LYMapsOnly) &&
		    !(me->object_usemap != NULL && !LYMapsOnly) &&
		    !(clickable_images && !LYMapsOnly &&
		      me->object_data != NULL &&
		      !have_param &&
		      me->object_classid == NULL &&
		      me->object_codebase == NULL &&
		      me->object_codetype == NULL)) {
		    /*
		     * We have nested OBJECT tags, and not yet all of the end
		     * tags, but have a case where the content needs to be
		     * parsed again (not dropped) and where we don't want to
		     * output anything special at the point when we
		     * *do* have accumulated all the end tags.  So recycle
		     * the incomplete contents now, and signal the SGML parser
		     * that it should not regard the current OBJECT ended but
		     * should treat its contents as mixed.  Normally these
		     * cases would have already handled in the real
		     * start_element call, so this block may not be necessary. 
		     * - kw
		     */
		    CTRACE((tfp, "%s:\n%s\n",
			    "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			    me->object.data));
		    status = HT_PARSER_OTHER_CONTENT;
		    me->object.size--;
		    HTChunkPuts(&me->object, "</OBJECT>");
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    StrnAllocCat(*include, me->object.data, (size_t) me->object.size);
		    clear_objectdata(me);
		    /* an internal fake call to keep our stack happy: */
		    HTML_start_element(me, HTML_OBJECT, NULL, NULL,
				       me->tag_charset, include);
		    break;
		}
		/*
		 * We have nested OBJECT tags, and not yet all of the end tags,
		 * and we want the end tags.  So restore an end tag to the
		 * content, and signal to the SGML parser that it should resume
		 * the accumulation of OBJECT content (after calling back to
		 * start_element) in a way that is equivalent to passing it a
		 * dummy start tag.  - FM, kw
		 */
		CTRACE((tfp, "HTML: Nested OBJECT tags.  Recycling.\n"));
		status = HT_PARSER_REOPEN_ELT;
		me->object.size--;
		HTChunkPuts(&me->object, "</OBJECT>");
		if (!LYMapsOnly)
		    change_paragraph_style(me, me->sp->style);
		break;
	    }

	    /*
	     * OBJECT start and end tags are fully matched, assuming we weren't
	     * tripped up by comments or quoted attributes.  - FM
	     */
	    CTRACE((tfp, "HTML:OBJECT content:\n%s\n", me->object.data));

	    /*
	     * OBJECTs with DECLARE should be saved but not instantiated, and
	     * if nested, can have only other DECLAREd OBJECTs.  Until we have
	     * code to handle these, we'll just create an anchor for the ID, if
	     * present, and discard the content (sigh 8-).  - FM
	     */
	    if (me->object_declare == TRUE) {
		if (non_empty(me->object_id) && !LYMapsOnly)
		    LYHandleID(me, me->object_id);
		CTRACE((tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n"));
		goto End_Object;
	    }

	    /*
	     * OBJECTs with NAME are for FORM submissions.  We'll just create
	     * an anchor for the ID, if present, and discard the content until
	     * we have code to handle these.  (sigh 8-).  - FM
	     */
	    if (me->object_name != NULL && !LYMapsOnly) {
		if (non_empty(me->object_id))
		    LYHandleID(me, me->object_id);
		CTRACE((tfp, "HTML: NAMEd OBJECT.  Ignoring!\n"));
		goto End_Object;
	    }

	    /*
	     * Deal with any nested OBJECTs by descending to the inner-most
	     * OBJECT.  - FM
	     */
	    if (s > 0) {
		if (start != NULL &&
		    first_end != NULL && first_end > start) {
		    /*
		     * Minumum requirements for the ad hoc parsing to have
		     * succeeded are met.  We'll hope that it did succeed.  -
		     * FM
		     */
		    if (LYMapsOnly) {
			/*
			 * Well we don't need to do this any more, nested
			 * objects should either not get here any more at all
			 * or can be handled fine by other code below.  Leave
			 * in place for now as a special case for LYMapsOnly. 
			 * - kw
			 */
			if (LYMapsOnly && (!last_map || last_map < first_end))
			    *first_end = '\0';
			else
			    e = 0;
			data = NULL;
			if (LYMapsOnly && (!first_map || first_map > start))
			    StrAllocCopy(data, start);
			else
			    StrAllocCopy(data, me->object.data);
			if (e > 0) {
			    for (i = e; i > 0; i--) {
				StrAllocCat(data, "</OBJECT>");
			    }
			}
			if (!include)	/* error, should not happen */
			    include = &me->xinclude;
			StrAllocCat(*include, data);
			CTRACE((tfp, "HTML: Recycling nested OBJECT%s.\n",
				(s > 1) ? "s" : ""));
			FREE(data);
			goto End_Object;
		    }
		} else {
		    if (LYBadHTML(me)) {
			LYShowBadHTML("Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n");
		    }
		    goto End_Object;
		}
	    }

	    /*
	     * If its content has SHAPES, convert it to FIG.  - FM
	     *
	     * This is now handled in our start_element without using include
	     * if the SGML parser cooperates, so this block may be unnecessary. 
	     * - kw
	     */
	    if (me->object_shapes == TRUE && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n"));
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
		StrAllocCat(*include, "<FIG ISOBJECT IMAGEMAP");
		if (me->object_ismap == TRUE)
		    StrAllocCat(*include, " IMAGEMAP");
		if (me->object_id != NULL) {
		    StrAllocCat(*include, " ID=\"");
		    StrAllocCat(*include, me->object_id);
		    StrAllocCat(*include, "\"");
		}
		if (me->object_data != NULL &&
		    me->object_classid == NULL) {
		    StrAllocCat(*include, " SRC=\"");
		    StrAllocCat(*include, me->object_data);
		    StrAllocCat(*include, "\"");
		}
		StrAllocCat(*include, ">");
		me->object.size--;
		HTChunkPuts(&me->object, "</FIG>");
		HTChunkTerminate(&me->object);
		StrAllocCat(*include, me->object.data);
		goto End_Object;
	    }

	    /*
	     * If it has a USEMAP attribute and didn't have SHAPES, convert it
	     * to IMG.  - FM
	     */
	    if (me->object_usemap != NULL && !LYMapsOnly) {
		CTRACE((tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n"));

		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
		StrAllocCat(*include, "<IMG ISOBJECT");
		if (me->object_id != NULL) {
		    /*
		     * Pass the ID.  - FM
		     */
		    StrAllocCat(*include, " ID=\"");
		    StrAllocCat(*include, me->object_id);
		    StrAllocCat(*include, "\"");
		}
		if (me->object_data != NULL &&
		    me->object_classid == NULL) {
		    /*
		     * We have DATA with no CLASSID, so let's hope it'
		     * equivalent to an SRC.  - FM
		     */
		    StrAllocCat(*include, " SRC=\"");
		    StrAllocCat(*include, me->object_data);
		    StrAllocCat(*include, "\"");
		}
		if (me->object_title != NULL) {
		    /*
		     * Use the TITLE for both the MAP and the IMGs ALT.  - FM
		     */
		    StrAllocCat(*include, " TITLE=\"");
		    StrAllocCat(*include, me->object_title);
		    StrAllocCat(*include, "\" ALT=\"");
		    StrAllocCat(*include, me->object_title);
		    StrAllocCat(*include, "\"");
		}
		/*
		 * Add the USEMAP, and an ISMAP if present.  - FM
		 */
		if (me->object_usemap != NULL) {
		    StrAllocCat(*include, " USEMAP=\"");
		    StrAllocCat(*include, me->object_usemap);
		    if (me->object_ismap == TRUE)
			StrAllocCat(*include, "\" ISMAP>");
		    else
			StrAllocCat(*include, "\">");
		} else {
		    StrAllocCat(*include, ">");
		}
		/*
		 * Add the content if it has <MAP, since that may be the MAP
		 * this usemap points to.  But if we have nested objects, try
		 * to eliminate portions that cannot contribute to the quest
		 * for MAP.  This is not perfect, we may get too much content;
		 * this seems preferable over losing too much.  - kw
		 */
		if (first_map) {
		    if (s == 0) {
			StrAllocCat(*include, me->object.data);
			CTRACE((tfp,
				"HTML: MAP found, recycling object contents.\n"));
			goto End_Object;
		    }
		    /* s > 0 and s == e */
		    data = NULL;
		    if (last_map < start) {
			*start = '\0';
			i = 0;
		    } else if (last_map < first_end) {
			*first_end = '\0';
			i = e;
		    } else if (last_map < last_end) {
			*last_end = '\0';
			i = 1;
		    } else {
			i = 0;
		    }
		    if (first_map > last_end) {
			/* fake empty object to keep stacks stack happy */
			StrAllocCopy(data, "<OBJECT><");
			StrAllocCat(data, last_end + 1);
			i = 0;
		    } else if (first_map > start) {
			StrAllocCopy(data, start);
		    } else {
			StrAllocCopy(data, me->object.data);
		    }
		    for (; i > 0; i--) {
			StrAllocCat(data, "</OBJECT>");
		    }
		    CTRACE((tfp, "%s:\n%s\n",
			    "HTML: MAP and nested OBJECT tags.  Recycling parts",
			    data));
		    StrAllocCat(*include, data);
		    FREE(data);
		}
		goto End_Object;
	    }

	    /*
	     * Add an ID link if needed.  - FM
	     */
	    if (non_empty(me->object_id) && !LYMapsOnly)
		LYHandleID(me, me->object_id);

	    /*
	     * Add the OBJECTs content if not empty.  - FM
	     */
	    if (me->object.size > 1) {
		if (!include)	/* error, should not happen */
		    include = &me->xinclude;
		StrAllocCat(*include, me->object.data);
	    }

	    /*
	     * Create a link to the DATA, if desired, and we can rule out that
	     * it involves scripting code.  This a risky thing to do, but we
	     * can toggle clickable_images mode off if it really screws things
	     * up, and so we may as well give it a try.  - FM
	     */
	    if (clickable_images) {
		if (!LYMapsOnly &&
		    me->object_data != NULL &&
		    !have_param &&
		    me->object_classid == NULL &&
		    me->object_codebase == NULL &&
		    me->object_codetype == NULL) {
		    /*
		     * We have a DATA value and no need for scripting code, so
		     * close the current Anchor, if one is open, and add an
		     * Anchor for this source.  If we also have a TYPE value,
		     * check whether it's an image or not, and set the link
		     * name accordingly.  - FM
		     */
		    if (!include)	/* error, should not happen */
			include = &me->xinclude;
		    if (me->inA)
			StrAllocCat(*include, "</A>");
		    StrAllocCat(*include, " -<A HREF=\"");
		    StrAllocCat(*include, me->object_data);
		    StrAllocCat(*include, "\">");
		    if ((me->object_type != NULL) &&
			!strncasecomp(me->object_type, "image/", 6)) {
			StrAllocCat(*include, "(IMAGE)");
		    } else {
			StrAllocCat(*include, "(OBJECT)");
		    }
		    StrAllocCat(*include, "</A> ");
		}
	    }
	}

	/*
	 * Re-intialize all of the OBJECT elements.  - FM
	 */
      End_Object:
	clear_objectdata(me);

	if (!LYMapsOnly)
	    change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_APPLET:
	if (me->inAPPLETwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');	/* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inAPPLETwithP = FALSE;
	me->inAPPLET = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_CAPTION:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCAPTION = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	me->inLABEL = FALSE;
	break;

    case HTML_CREDIT:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	me->inCREDIT = FALSE;
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	me->inLABEL = FALSE;
	break;

    case HTML_FORM:
	/*
	 * Check if we had a FORM start tag, and issue a message if not, but
	 * fall through to check for an open SELECT and ensure that the
	 * FORM-related globals in GridText.c are initialized.  - FM
	 */
	if (!me->inFORM) {
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: Unmatched FORM end tag\n");
	    }
	}
	EMIT_IFDEF_USE_JUSTIFY_ELTS(form_in_htext = FALSE);

	/*
	 * Check if we still have a SELECT element open.  FORM may have been
	 * declared SGML_EMPTY in HTMLDTD.c, and in that case SGML_character()
	 * in SGML.c is not able to ensure correct nesting; or it may have
	 * failed to enforce valid nesting.  If a SELECT is open, issue a
	 * message, then call HTML_end_element() directly (with a check in that
	 * to bypass decrementing of the HTML parser's stack) to close the
	 * SELECT.  - kw
	 */
	if (me->inSELECT) {
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n");
	    }
	    if (me->sp->tag_number != HTML_SELECT) {
		SET_SKIP_STACK(HTML_SELECT);
	    }
	    HTML_end_element(me, HTML_SELECT, include);
	}

	/*
	 * Set to know that we are no longer in an form.
	 */
	me->inFORM = FALSE;

	HText_endForm(me->text);
	/*
	 * If we are in a list and are on the first line with no text following
	 * a bullet or number, don't force a newline.  This could happen if we
	 * were called from HTML_start_element() due to a missing FORM end tag. 
	 * - FM
	 */
	if (!(me->List_Nesting_Level >= 0 && !me->inP))
	    LYEnsureSingleSpace(me);
	break;

    case HTML_FIELDSET:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_LEGEND:
	LYEnsureDoubleSpace(me);
	LYResetParagraphAlignment(me);
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    case HTML_LABEL:
	break;

    case HTML_BUTTON:
	break;

    case HTML_TEXTAREA:
	{
	    InputFieldData I;
	    int chars;
	    char *data;

	    /*
	     * Make sure we had a textarea start tag.
	     */
	    if (!me->inTEXTAREA) {
		if (LYBadHTML(me)) {
		    LYShowBadHTML("Bad HTML: Unmatched TEXTAREA end tag\n");
		}
		break;
	    }

	    /*
	     * Set to know that we are no longer in a textarea tag.
	     */
	    me->inTEXTAREA = FALSE;

	    /*
	     * Initialize.
	     */
	    memset(&I, 0, sizeof(I));
	    I.value_cs = current_char_set;

	    UPDATE_STYLE;
	    /*
	     * Before any input field add a space if necessary.
	     */
	    HTML_put_character(me, ' ');
	    me->in_word = NO;
	    /*
	     * Add a return.
	     */
	    HText_appendCharacter(me->text, '\r');

	    /*
	     * Finish the data off.
	     */
	    HTChunkTerminate(&me->textarea);
	    FREE(temp);

	    I.type = "textarea";
	    I.size = me->textarea_cols;
	    I.name = me->textarea_name;
	    I.name_cs = me->textarea_name_cs;
	    I.accept_cs = me->textarea_accept_cs;
	    me->textarea_accept_cs = NULL;
	    I.disabled = me->textarea_disabled;
	    I.readonly = me->textarea_readonly;
	    I.id = me->textarea_id;

	    /*
	     * Transform the TEXTAREA content as needed, then parse it into
	     * individual lines to be handled as a series series of INPUT
	     * fields (ugh!).  Any raw 8-bit or multibyte characters already
	     * have been handled in relation to the display character set in
	     * SGML_character().
	     *
	     * If TEXTAREA is handled as SGML_LITTERAL (the old way), we need
	     * to SGML-unescape any character references and NCRs here. 
	     * Otherwise this will already have happened in the SGML.c parsing. 
	     * - kw
	     */
	    me->UsePlainSpace = TRUE;

	    if (HTML_dtd.tags[element_number].contents == SGML_LITTERAL) {
		TRANSLATE_AND_UNESCAPE_ENTITIES6(&me->textarea.data,
						 me->UCLYhndl,
						 current_char_set,
						 NO,
						 me->UsePlainSpace, me->HiddenValue);
	    } else {
		/*
		 * This shouldn't have anything to do, normally, but just in
		 * case...  There shouldn't be lynx special character codes in
		 * the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not to
		 * generate them).  If there were, we could set the last
		 * parameter ('Back') below to YES, which would take them out
		 * of the data.  The data may however contain non break space,
		 * soft hyphen, or en space etc., in the me->UCLYhndl character
		 * encoding.  If that's a problem, perhaps for the (line or
		 * other) editor, setting 'Back' to YES should also help to
		 * always convert them to plain spaces (or drop them).  - kw
		 */
		TRANSLATE_HTML7(&me->textarea.data,
				me->UCLYhndl,
				current_char_set,
				NO,
				me->UsePlainSpace, me->HiddenValue,
				NO);
	    }
	    data = me->textarea.data;

	    /*
	     * Trim any trailing newlines and skip any lead newlines.  - FM
	     */
	    if (*data != '\0') {
		cp = (data + strlen(data)) - 1;
		while (cp >= data && *cp == '\n') {
		    *cp-- = '\0';
		}
		while (*data == '\n') {
		    data++;
		}
	    }
	    /*
	     * Load the first text line, or set up for all blank rows.  - FM
	     */
	    if ((cp = StrChr(data, '\n')) != NULL) {
		*cp = '\0';
		StrAllocCopy(temp, data);
		*cp = '\n';
		data = (cp + 1);
	    } else {
		if (*data != '\0') {
		    StrAllocCopy(temp, data);
		} else {
		    FREE(temp);
		}
		data = empty;
	    }
	    /*
	     * Display at least the requested number of text lines and/or blank
	     * rows.  - FM
	     */
	    for (i = 0; i < me->textarea_rows; i++) {
		int j;

		for (j = 0; temp && temp[j]; j++) {
		    if (temp[j] == '\r')
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
		}
		I.value = temp;
		chars = HText_beginInput(me->text, me->inUnderline, &I);
		for (; chars > 0; chars--)
		    HTML_put_character(me, '_');
		HText_appendCharacter(me->text, '\r');
		if (*data != '\0') {
		    if (*data == '\n') {
			FREE(temp);
			data++;
		    } else if ((cp = StrChr(data, '\n')) != NULL) {
			*cp = '\0';
			StrAllocCopy(temp, data);
			*cp = '\n';
			data = (cp + 1);
		    } else {
			StrAllocCopy(temp, data);
			data = empty;
		    }
		} else {
		    FREE(temp);
		}
	    }
	    /*
	     * Check for more data lines than the rows attribute.  We add them
	     * to the display, because we support only horizontal and not also
	     * vertical scrolling.  - FM
	     */
	    while (*data != '\0' || temp != NULL) {
		int j;

		for (j = 0; temp && temp[j]; j++) {
		    if (temp[j] == '\r')
			temp[j] = (char) (temp[j + 1] ? ' ' : '\0');
		}
		I.value = temp;
		(void) HText_beginInput(me->text, me->inUnderline, &I);
		for (chars = me->textarea_cols; chars > 0; chars--)
		    HTML_put_character(me, '_');
		HText_appendCharacter(me->text, '\r');
		if (*data == '\n') {
		    FREE(temp);
		    data++;
		} else if ((cp = StrChr(data, '\n')) != NULL) {
		    *cp = '\0';
		    StrAllocCopy(temp, data);
		    *cp = '\n';
		    data = (cp + 1);
		} else if (*data != '\0') {
		    StrAllocCopy(temp, data);
		    data = empty;
		} else {
		    FREE(temp);
		}
	    }
	    FREE(temp);
	    cp = NULL;
	    me->UsePlainSpace = FALSE;

	    HTChunkClear(&me->textarea);
	    FREE(me->textarea_name);
	    me->textarea_name_cs = -1;
	    FREE(me->textarea_id);
	    break;
	}

    case HTML_SELECT:
	{
	    char *ptr = NULL;

	    /*
	     * Make sure we had a select start tag.
	     */
	    if (!me->inSELECT) {
		if (LYBadHTML(me)) {
		    LYShowBadHTML("Bad HTML: Unmatched SELECT end tag *****\n");
		}
		break;
	    }

	    /*
	     * Set to know that we are no longer in a select tag.
	     */
	    me->inSELECT = FALSE;

	    /*
	     * Clear the disable attribute.
	     */
	    me->select_disabled = FALSE;

	    /*
	     * Make sure we're in a form.
	     */
	    if (!me->inFORM) {
		if (LYBadHTML(me)) {
		    LYShowBadHTML("Bad HTML: SELECT end tag not within FORM element *****\n");
		}
		/*
		 * Hopefully won't crash, so we'll ignore it.  - kw
		 */
	    }

	    /*
	     * Finish the data off.
	     */
	    HTChunkTerminate(&me->option);
	    /*
	     * Finish the previous option.
	     */
	    if (!me->first_option)
		ptr = HText_setLastOptionValue(me->text,
					       me->option.data,
					       me->LastOptionValue,
					       LAST_ORDER,
					       me->LastOptionChecked,
					       me->UCLYhndl,
					       ATTR_CS_IN);
	    FREE(me->LastOptionValue);

	    me->LastOptionChecked = FALSE;

	    if (HTCurSelectGroupType == F_CHECKBOX_TYPE ||
		LYSelectPopups == FALSE) {
		/*
		 * Start a newline after the last checkbox/button option.
		 */
		LYEnsureSingleSpace(me);
	    } else {
		/*
		 * Output popup box with the default option to screen, but use
		 * non-breaking spaces for output.
		 */
		if (ptr &&
		    (me->sp[0].tag_number == HTML_PRE || me->inPRE == TRUE ||
		     !me->sp->style->freeFormat) &&
		    strlen(ptr) > 6) {
		    /*
		     * The code inadequately handles OPTION fields in PRE tags. 
		     * We'll put up a minimum of 6 characters, and if any more
		     * would exceed the wrap column, we'll ignore them.
		     */
		    for (i = 0; i < 6; i++) {
			if (*ptr == ' ')
			    HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
			else
			    HText_appendCharacter(me->text, *ptr);
			ptr++;
		    }
		}
		for (; non_empty(ptr); ptr++) {
		    if (*ptr == ' ')
			HText_appendCharacter(me->text, HT_NON_BREAK_SPACE);
		    else {
			HTkcode kcode = NOKANJI;
			HTkcode specified_kcode = NOKANJI;

			if (HTCJK == JAPANESE) {
			    kcode = HText_getKcode(me->text);
			    HText_updateKcode(me->text, kanji_code);
			    specified_kcode = HText_getSpecifiedKcode(me->text);
			    HText_updateSpecifiedKcode(me->text, kanji_code);
			}
			HText_appendCharacter(me->text, *ptr);
			if (HTCJK == JAPANESE) {
			    HText_updateKcode(me->text, kcode);
			    HText_updateSpecifiedKcode(me->text, specified_kcode);
			}
		    }
		}
		/*
		 * Add end option character.
		 */
		if (!me->first_option) {
		    HText_appendCharacter(me->text, ']');
		    HText_endInput(me->text);
		    HText_setLastChar(me->text, ']');
		    me->in_word = YES;
		}
	    }
	    HTChunkClear(&me->option);

	    if (me->Underline_Level > 0 && me->inUnderline == FALSE) {
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
		me->inUnderline = TRUE;
	    }
	    if (me->needBoldH == TRUE && me->inBoldH == FALSE) {
		HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		me->inBoldH = TRUE;
		me->needBoldH = FALSE;
	    }
	}
	break;

    case HTML_TABLE:
#ifdef EXP_NESTED_TABLES
	if (!nested_tables)
#endif
	    me->inTABLE = FALSE;

	if (me->sp->style->id == ST_Preformatted) {
	    break;
	}
	if (me->Division_Level >= 0)
	    me->Division_Level--;
	if (me->Division_Level >= 0)
	    me->sp->style->alignment =
		me->DivisionAlignments[me->Division_Level];
	change_paragraph_style(me, me->sp->style);
	UPDATE_STYLE;

#ifdef EXP_NESTED_TABLES
	if (nested_tables) {
	    me->inTABLE = HText_endStblTABLE(me->text);
	} else {
	    HText_endStblTABLE(me->text);
	}
#else
	HText_endStblTABLE(me->text);
#endif

	me->current_default_alignment = me->sp->style->alignment;
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
	break;

/* These TABLE related elements may now not be SGML_EMPTY. - kw */
    case HTML_TR:
	HText_endStblTR(me->text);
	if (!HText_LastLineEmpty(me->text, FALSE)) {
	    HText_setLastChar(me->text, ' ');	/* absorb next white space */
	    HText_appendCharacter(me->text, '\r');
	}
	me->in_word = NO;
	break;

    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
	break;

    case HTML_COLGROUP:
	if (me->inTABLE)
	    HText_endStblCOLGROUP(me->text);
	break;

    case HTML_TH:
    case HTML_TD:
	HText_endStblTD(me->text);
	break;

/* More stuff that may now not be SGML_EMPTY any more: */
    case HTML_DT:
    case HTML_DD:
    case HTML_LH:
    case HTML_LI:
    case HTML_OVERLAY:
	break;

    case HTML_MATH:
	/*
	 * We're getting it as Literal text, which, until we can process it,
	 * we'll display as is, within brackets to alert the user.  - FM
	 */
	HTChunkPutc(&me->math, ' ');
	HTChunkTerminate(&me->math);
	if (me->math.size > 2) {
	    LYEnsureSingleSpace(me);
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, "[MATH:");
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    HTML_put_character(me, ' ');
	    HTML_put_string(me, me->math.data);
	    HText_appendCharacter(me->text, LY_UNDERLINE_START_CHAR);
	    HTML_put_string(me, ":MATH]");
	    if (me->inUnderline == FALSE)
		HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    LYEnsureSingleSpace(me);
	}
	HTChunkClear(&me->math);
	break;

    default:
	change_paragraph_style(me, me->sp->style);	/* Often won't really change */
	break;

    }				/* switch */

#ifdef USE_JUSTIFY_ELTS
    if (reached_awaited_stacked_elt)
	wait_for_this_stacked_elt = -1;
#endif

    if (me->xinclude) {
	HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	HText_appendText(me->text, me->xinclude);
	FREE(me->xinclude);
    }
#ifdef USE_COLOR_STYLE
    if (!skip_stack_requested) {	/*don't emit stylechanges if skipped stack element - VH */
# if !OMIT_SCN_KEEPING
	FastTrimColorClass(HTML_dtd.tags[element_number].name,
			   HTML_dtd.tags[element_number].name_len,
			   Style_className,
			   &Style_className_end, &hcode);
#  endif

	if (!ReallyEmptyTagNum(element_number)) {
	    CTRACE2(TRACE_STYLE,
		    (tfp,
		     "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
		     HTML_dtd.tags[element_number].name));
	    HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
	}
    }
#endif /* USE_COLOR_STYLE */
    return status;
}

/*		Expanding entities
 *		------------------
 */
/*	(In fact, they all shrink!)
*/
int HTML_put_entity(HTStructured * me, int entity_number)
{
    int nent = (int) HTML_dtd.number_of_entities;

    if (entity_number < nent) {
	HTML_put_string(me, p_entity_values[entity_number]);
	return HT_OK;
    }
    return HT_CANNOT_TRANSLATE;
}

/*	Free an HTML object
 *	-------------------
 *
 *	If the document is empty, the text object will not yet exist.
 *	So we could in fact abandon creating the document and return
 *	an error code.	In fact an empty document is an important type
 *	of document, so we don't.
 *
 *	If non-interactive, everything is freed off.   No: crashes -listrefs
 *	Otherwise, the interactive object is left.
 */
static void HTML_free(HTStructured * me)
{
    char *include = NULL;

    if (LYMapsOnly && !me->text) {
	/*
	 * We only handled MAP, AREA and BASE tags, and didn't create an HText
	 * structure for the document nor want one now, so just make sure we
	 * free anything that might have been allocated.  - FM
	 */
	FREE(me->base_href);
	FREE(me->map_address);
	clear_objectdata(me);
	FREE(me->xinclude);
	FREE(me);
	return;
    }

    UPDATE_STYLE;		/* Creates empty document here! */
    if (me->comment_end)
	HTML_put_string(me, me->comment_end);
    if (me->text) {
	/*
	 * Emphasis containers, A, FONT, and FORM may be declared SGML_EMPTY in
	 * HTMLDTD.c, and SGML_character() in SGML.c may check for their end
	 * tags to call HTML_end_element() directly (with a check in that to
	 * bypass decrementing of the HTML parser's stack).  So if we still
	 * have the emphasis (Underline) on, or any open A, FONT, or FORM
	 * containers, turn it off or close them now.  - FM & kw
	 *
	 * IF those tags are not declared SGML_EMPTY, but we let the SGML.c
	 * parser take care of correctly stacked ordering, and of correct
	 * wind-down on end-of-stream (in SGML_free SGML_abort), THEN these and
	 * other checks here in HTML.c should not be necessary.  Still it can't
	 * hurt to include them.  - kw
	 */
	if (me->inUnderline) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	    me->Underline_Level = 0;
	    CTRACE((tfp, "HTML_free: Ending underline\n"));
	}
	if (me->inA) {
	    HTML_end_element(me, HTML_A, &include);
	    me->inA = FALSE;
	    CTRACE((tfp, "HTML_free: Ending HTML_A\n"));
	}
	if (me->inFONT) {
	    HTML_end_element(me, HTML_FONT, &include);
	    me->inFONT = FALSE;
	}
	if (me->inFORM) {
	    HTML_end_element(me, HTML_FORM, &include);
	    me->inFORM = FALSE;
	}
	if (me->option.size > 0) {
	    /*
	     * If we still have data in the me->option chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
	     */
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: SELECT or OPTION not ended properly *****\n");
	    }
	    HTChunkTerminate(&me->option);
	    /*
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
	     */
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data));
	    HTML_put_string(me, me->option.data);
	    HTChunkClear(&me->option);
	}
	if (me->textarea.size > 0) {
	    /*
	     * If we still have data in the me->textarea chunk after forcing a
	     * close of a still-open form, something must have gone very wrong. 
	     * - kw
	     */
	    if (LYBadHTML(me)) {
		LYShowBadHTML("Bad HTML: TEXTAREA not used properly *****\n");
	    }
	    HTChunkTerminate(&me->textarea);
	    /*
	     * Output the left-over data as text, maybe it was invalid markup
	     * meant to be shown somewhere.  - kw
	     */
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data));
	    HTML_put_string(me, me->textarea.data);
	    HTChunkClear(&me->textarea);
	}
	/*
	 * If we're interactive and have hidden links but no visible links, add
	 * a message informing the user about this and suggesting use of the
	 * 'l'ist command.  - FM
	 */
	if (!dump_output_immediately &&
	    HText_sourceAnchors(me->text) < 1 &&
	    HText_HiddenLinkCount(me->text) > 0) {
	    HTML_start_element(me, HTML_P, 0, 0, -1, &include);
	    HTML_put_character(me, '[');
	    HTML_start_element(me, HTML_EM, 0, 0, -1, &include);
	    HTML_put_string(me,
			    gettext("Document has only hidden links.  Use the 'l'ist command."));
	    HTML_end_element(me, HTML_EM, &include);
	    HTML_put_character(me, ']');
	    HTML_end_element(me, HTML_P, &include);
	}
	if (me->xinclude) {
	    HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
	    HText_appendText(me->text, me->xinclude);
	    FREE(me->xinclude);
	}

	/*
	 * Now call the cleanup function.  - FM
	 */
	HText_endAppend(me->text);
    }
    if (me->option.size > 0) {
	/*
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
	 */
	if (LYBadHTML(me)) {
	    LYShowBadHTML("Bad HTML: SELECT or OPTION not ended properly *****\n");
	}
	if (TRACE) {
	    HTChunkTerminate(&me->option);
	    CTRACE((tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data));
	}
	HTChunkClear(&me->option);
    }
    if (me->textarea.size > 0) {
	/*
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
	 */
	if (LYBadHTML(me)) {
	    LYShowBadHTML("Bad HTML: TEXTAREA not used properly *****\n");
	}
	if (TRACE) {
	    HTChunkTerminate(&me->textarea);
	    CTRACE((tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data));
	}
	HTChunkClear(&me->textarea);
    }

    if (me->target) {
	(*me->targetClass._free) (me->target);
    }
    if (me->sp && me->sp->style && GetHTStyleName(me->sp->style)) {
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
	    me->sp->style->alignment = HT_CENTER;
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
	    me->sp->style->alignment = HT_RIGHT;
	} else {
	    me->sp->style->alignment = HT_LEFT;
	}
	styles[HTML_PRE]->alignment = HT_LEFT;
    }
    FREE(me->base_href);
    FREE(me->map_address);
    FREE(me->LastOptionValue);
    clear_objectdata(me);
    FREE(me);
}

static void HTML_abort(HTStructured * me, HTError e)
{
    char *include = NULL;

    if (me->text) {
	/*
	 * If we have emphasis on, or open A, FONT, or FORM containers, turn it
	 * off or close them now.  - FM
	 */
	if (me->inUnderline) {
	    HText_appendCharacter(me->text, LY_UNDERLINE_END_CHAR);
	    me->inUnderline = FALSE;
	    me->Underline_Level = 0;
	}
	if (me->inA) {
	    HTML_end_element(me, HTML_A, &include);
	    me->inA = FALSE;
	}
	if (me->inFONT) {
	    HTML_end_element(me, HTML_FONT, &include);
	    me->inFONT = FALSE;
	}
	if (me->inFORM) {
	    HTML_end_element(me, HTML_FORM, &include);
	    me->inFORM = FALSE;
	}

	/*
	 * Now call the cleanup function.  - FM
	 */
	HText_endAppend(me->text);
    }

    if (me->option.size > 0) {
	/*
	 * If we still have data in the me->option chunk after forcing a close
	 * of a still-open form, something must have gone very wrong.  - kw
	 */
	if (TRACE) {
	    CTRACE((tfp,
		    "HTML_abort: SELECT or OPTION not ended properly *****\n"));
	    HTChunkTerminate(&me->option);
	    CTRACE((tfp, "HTML_abort: ***** leftover option data: %s\n",
		    me->option.data));
	}
	HTChunkClear(&me->option);
    }
    if (me->textarea.size > 0) {
	/*
	 * If we still have data in the me->textarea chunk after forcing a
	 * close of a still-open form, something must have gone very wrong.  -
	 * kw
	 */
	if (TRACE) {
	    CTRACE((tfp, "HTML_abort: TEXTAREA not used properly *****\n"));
	    HTChunkTerminate(&me->textarea);
	    CTRACE((tfp, "HTML_abort: ***** leftover textarea data: %s\n",
		    me->textarea.data));
	}
	HTChunkClear(&me->textarea);
    }

    if (me->target) {
	(*me->targetClass._abort) (me->target, e);
    }
    if (me->sp && me->sp->style && GetHTStyleName(me->sp->style)) {
	if (me->sp->style->id == ST_DivCenter ||
	    me->sp->style->id == ST_HeadingCenter ||
	    me->sp->style->id == ST_Heading1) {
	    me->sp->style->alignment = HT_CENTER;
	} else if (me->sp->style->id == ST_DivRight ||
		   me->sp->style->id == ST_HeadingRight) {
	    me->sp->style->alignment = HT_RIGHT;
	} else {
	    me->sp->style->alignment = HT_LEFT;
	}
	styles[HTML_PRE]->alignment = HT_LEFT;
    }
    FREE(me->base_href);
    FREE(me->map_address);
    FREE(me->textarea_name);
    FREE(me->textarea_accept_cs);
    FREE(me->textarea_id);
    FREE(me->LastOptionValue);
    FREE(me->xinclude);
    clear_objectdata(me);
    FREE(me);
}

/*	Get Styles from style sheet
 *	---------------------------
 */
static void get_styles(void)
{
    HTStyle **st = NULL;

    styleSheet = DefaultStyle(&st);	/* sets st[] array */

    default_style = st[ST_Normal];

    styles[HTML_H1] = st[ST_Heading1];
    styles[HTML_H2] = st[ST_Heading2];
    styles[HTML_H3] = st[ST_Heading3];
    styles[HTML_H4] = st[ST_Heading4];
    styles[HTML_H5] = st[ST_Heading5];
    styles[HTML_H6] = st[ST_Heading6];
    styles[HTML_HCENTER] = st[ST_HeadingCenter];
    styles[HTML_HLEFT] = st[ST_HeadingLeft];
    styles[HTML_HRIGHT] = st[ST_HeadingRight];

    styles[HTML_DCENTER] = st[ST_DivCenter];
    styles[HTML_DLEFT] = st[ST_DivLeft];
    styles[HTML_DRIGHT] = st[ST_DivRight];

    styles[HTML_DL] = st[ST_Glossary];
    /* nested list styles */
    styles[HTML_DL1] = st[ST_Glossary1];
    styles[HTML_DL2] = st[ST_Glossary2];
    styles[HTML_DL3] = st[ST_Glossary3];
    styles[HTML_DL4] = st[ST_Glossary4];
    styles[HTML_DL5] = st[ST_Glossary5];
    styles[HTML_DL6] = st[ST_Glossary6];

    styles[HTML_UL] =
	styles[HTML_OL] = st[ST_List];
    /* nested list styles */
    styles[HTML_OL1] = st[ST_List1];
    styles[HTML_OL2] = st[ST_List2];
    styles[HTML_OL3] = st[ST_List3];
    styles[HTML_OL4] = st[ST_List4];
    styles[HTML_OL5] = st[ST_List5];
    styles[HTML_OL6] = st[ST_List6];

    styles[HTML_MENU] =
	styles[HTML_DIR] = st[ST_Menu];
    /* nested list styles */
    styles[HTML_MENU1] = st[ST_Menu1];
    styles[HTML_MENU2] = st[ST_Menu2];
    styles[HTML_MENU3] = st[ST_Menu3];
    styles[HTML_MENU4] = st[ST_Menu4];
    styles[HTML_MENU5] = st[ST_Menu5];
    styles[HTML_MENU6] = st[ST_Menu6];

    styles[HTML_DLC] = st[ST_GlossaryCompact];
    /* nested list styles */
    styles[HTML_DLC1] = st[ST_GlossaryCompact1];
    styles[HTML_DLC2] = st[ST_GlossaryCompact2];
    styles[HTML_DLC3] = st[ST_GlossaryCompact3];
    styles[HTML_DLC4] = st[ST_GlossaryCompact4];
    styles[HTML_DLC5] = st[ST_GlossaryCompact5];
    styles[HTML_DLC6] = st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] = st[ST_Address];
    styles[HTML_BANNER] = st[ST_Banner];
    styles[HTML_BLOCKQUOTE] = st[ST_Blockquote];
    styles[HTML_BQ] = st[ST_Bq];
    styles[HTML_FN] = st[ST_Footnote];
    styles[HTML_NOTE] = st[ST_Note];
    styles[HTML_PLAINTEXT] =
	styles[HTML_XMP] = st[ST_Example];
    styles[HTML_PRE] = st[ST_Preformatted];
    styles[HTML_LISTING] = st[ST_Listing];
}

/*
 * If we're called from another module, make sure we've initialized styles
 * array first.
 */
HTStyle *LYstyles(int style_number)
{
    if (styles[style_number] == 0)
	get_styles();
    return styles[style_number];
}

/*				P U B L I C
*/

/*	Structured Object Class
 *	-----------------------
 */
const HTStructuredClass HTMLPresentation =	/* As opposed to print etc */
{
    "Lynx_HTML_Handler",
    HTML_free,
    HTML_abort,
    HTML_put_character, HTML_put_string, HTML_write,
    HTML_start_element, HTML_end_element,
    HTML_put_entity
};

/*		New Structured Text object
 *		--------------------------
 *
 *	The structured stream can generate either presentation,
 *	or plain text, or HTML.
 */
HTStructured *HTML_new(HTParentAnchor *anchor,
		       HTFormat format_out,
		       HTStream *stream)
{

    HTStructured *me;

    CTRACE((tfp, "start HTML_new\n"));

    if (format_out != WWW_PLAINTEXT && format_out != WWW_PRESENT) {
	HTStream *intermediate = HTStreamStack(WWW_HTML, format_out,
					       stream, anchor);

	if (intermediate)
	    return HTMLGenerator(intermediate);
	fprintf(stderr, "\n** Internal error: can't parse HTML to %s\n",
		HTAtom_name(format_out));
	exit_immediately(EXIT_FAILURE);
    }

    me = typecalloc(HTStructured);
    if (me == NULL)
	outofmem(__FILE__, "HTML_new");
    assert(me != NULL);

    /*
     * This used to call 'get_styles()' only on the first time through this
     * function.  However, if the user reloads a page with ^R, the styles[]
     * array is not necessarily the same as it was from 'get_styles()'.  So
     * we reinitialize the whole thing.
     */
    get_styles();

    me->isa = &HTMLPresentation;
    me->node_anchor = anchor;

    me->CurrentA = NULL;
    me->CurrentANum = 0;
    me->base_href = NULL;
    me->map_address = NULL;

    HTChunkInit(&me->title, 128);

    HTChunkInit(&me->object, 128);
    me->object_started = FALSE;
    me->object_declare = FALSE;
    me->object_shapes = FALSE;
    me->object_ismap = FALSE;
    me->object_id = NULL;
    me->object_title = NULL;
    me->object_data = NULL;
    me->object_type = NULL;
    me->object_classid = NULL;
    me->object_codebase = NULL;
    me->object_codetype = NULL;
    me->object_usemap = NULL;
    me->object_name = NULL;

    HTChunkInit(&me->option, 128);
    me->first_option = TRUE;
    me->LastOptionValue = NULL;
    me->LastOptionChecked = FALSE;
    me->select_disabled = FALSE;

    HTChunkInit(&me->textarea, 128);
    me->textarea_name = NULL;
    me->textarea_name_cs = -1;
    me->textarea_accept_cs = NULL;
    me->textarea_cols = 0;
    me->textarea_rows = 4;
    me->textarea_id = NULL;

    HTChunkInit(&me->math, 128);

    HTChunkInit(&me->style_block, 128);

    HTChunkInit(&me->script, 128);

    me->text = 0;
    me->style_change = YES;	/* Force check leading to text creation */
    me->new_style = default_style;
    me->old_style = 0;
    me->current_default_alignment = HT_LEFT;
    me->sp = (me->stack + MAX_NESTING - 1);
    me->skip_stack = 0;
    me->sp->tag_number = -1;	/* INVALID */
    me->sp->style = default_style;	/* INVALID */
    me->sp->style->alignment = HT_LEFT;
    me->stack_overrun = FALSE;

    me->Division_Level = -1;
    me->Underline_Level = 0;
    me->Quote_Level = 0;

    me->UsePlainSpace = FALSE;
    me->HiddenValue = FALSE;
    me->lastraw = -1;

    /*
     * Used for nested lists.  - FM
     */
    me->List_Nesting_Level = -1;	/* counter for list nesting level */
    LYZero_OL_Counter(me);	/* Initializes OL_Counter[] and OL_Type[] */
    me->Last_OL_Count = 0;	/* last count in ordered lists */
    me->Last_OL_Type = '1';	/* last type in ordered lists */

    me->inA = FALSE;
    me->inAPPLET = FALSE;
    me->inAPPLETwithP = FALSE;
    me->inBadBASE = FALSE;
    me->inBadHREF = FALSE;
    me->inBadHTML = FALSE;
    me->inBASE = FALSE;
    me->node_anchor->inBASE = FALSE;
    me->inBoldA = FALSE;
    me->inBoldH = FALSE;
    me->inCAPTION = FALSE;
    me->inCREDIT = FALSE;
    me->inFIG = FALSE;
    me->inFIGwithP = FALSE;
    me->inFONT = FALSE;
    me->inFORM = FALSE;
    me->inLABEL = FALSE;
    me->inP = FALSE;
    me->inPRE = FALSE;
    me->inSELECT = FALSE;
    me->inTABLE = FALSE;
    me->inUnderline = FALSE;

    me->needBoldH = FALSE;

    me->comment_start = NULL;
    me->comment_end = NULL;

#ifdef USE_COLOR_STYLE
#ifdef LY_FIND_LEAKS
    if (Style_className == 0) {
	atexit(free_Style_className);
    }
#endif
    addClassName("", "", (size_t) 0);
    class_string[0] = '\0';
#endif

    /*
     * Create a chartrans stage info structure for the anchor, if it does not
     * exist already (in which case the default MIME stage info will be loaded
     * as well), and load the HTML stage info into me->UCI and me->UCLYhndl.  -
     * FM
     */
    LYGetChartransInfo(me);
    UCTransParams_clear(&me->T);

    /*
     * Load the existing or default input charset info into the holding
     * elements.  We'll believe what is indicated for UCT_STAGE_PARSER.  - FM
     */
    me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					  UCT_STAGE_PARSER);
    if (me->inUCLYhndl < 0) {
	me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					      UCT_STAGE_MIME);
	me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor,
					    UCT_STAGE_MIME);
    } else {
	me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor,
					    UCT_STAGE_PARSER);
    }

    /*
     * Load the existing or default output charset info into the holding
     * elements, UCT_STAGE_STRUCTURED should be the same as UCT_STAGE_TEXT at
     * this point, but we could check, perhaps.  - FM
     */
    me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor,
					 UCT_STAGE_STRUCTURED);
    me->outUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor,
					   UCT_STAGE_STRUCTURED);

    me->target = stream;
    if (stream)
	me->targetClass = *stream->isa;		/* Copy pointers */

    return (HTStructured *) me;
}

#ifdef USE_SOURCE_CACHE

/*
 * A flag set by a file write error.  Used for only generating an alert the
 * first time such an error happens, since Lynx should still be usable if the
 * temp space becomes full, and an alert each time a cache file cannot be
 * written would be annoying.  Reset when lynx.cfg is being reloaded (user may
 * change SOURCE_CACHE setting).  - kw
 */
BOOLEAN source_cache_file_error = FALSE;

/*
 * Pass-thru cache HTStream
 */

static void CacheThru_do_free(HTStream *me)
{
    if (me->anchor->source_cache_file) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous file %s\n",
		me->anchor->source_cache_file));
	(void) LYRemoveTemp(me->anchor->source_cache_file);
	FREE(me->anchor->source_cache_file);
    }
    if (me->anchor->source_cache_chunk) {
	CTRACE((tfp, "SourceCacheWriter: Removing previous memory chunk %p\n",
		(void *) me->anchor->source_cache_chunk));
	HTChunkFree(me->anchor->source_cache_chunk);
	me->anchor->source_cache_chunk = NULL;
    }
    if (me->fp) {
	fflush(me->fp);
	if (ferror(me->fp))
	    me->status = HT_ERROR;
	LYCloseTempFP(me->fp);
	if (me->status == HT_OK) {
	    char *cp_freeme = 0;

	    me->anchor->source_cache_file = me->filename;
	    CTRACE((tfp,
		    "SourceCacheWriter: Committing file %s for URL %s to anchor\n",
		    me->filename,
		    cp_freeme = HTAnchor_address((HTAnchor *) me->anchor)));
	    FREE(cp_freeme);
	} else {
	    if (source_cache_file_error == FALSE) {
		HTAlert(gettext("Source cache error - disk full?"));
		source_cache_file_error = TRUE;
	    }
	    (void) LYRemoveTemp(me->filename);
	    me->anchor->source_cache_file = NULL;
	}
    } else if (me->status != HT_OK) {
	if (me->chunk) {
	    CTRACE((tfp, "SourceCacheWriter: memory chunk %p had errors.\n",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	    me->chunk = me->last_chunk = NULL;
	}
	HTAlert(gettext("Source cache error - not enough memory!"));
    }
    if (me->chunk) {
	char *cp_freeme = NULL;

	me->anchor->source_cache_chunk = me->chunk;
	CTRACE((tfp,
		"SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",
		(void *) me->chunk,
		cp_freeme = HTAnchor_address((HTAnchor *) me->anchor)));
	FREE(cp_freeme);
    }
}

static void CacheThru_free(HTStream *me)
{
    CacheThru_do_free(me);
    (*me->actions->_free) (me->target);
    FREE(me);
}

static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, "SourceCacheWriter: Removing active file %s\n",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}

/*
 * FIXME: never used!
 */
static void CacheThru_put_character(HTStream *me, int c_in)
{
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputc(c_in, me->fp);
	} else if (me->chunk) {
	    me->last_chunk = HTChunkPutc2(me->last_chunk, c_in);
	    if (me->last_chunk == NULL || me->last_chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_character) (me->target, c_in);
}

/*
 * FIXME: never used!
 */
static void CacheThru_put_string(HTStream *me, const char *str)
{
    if (me->status == HT_OK) {
	if (me->fp) {
	    fputs(str, me->fp);
	} else if (me->chunk) {
	    me->last_chunk = HTChunkPuts2(me->last_chunk, str);
	    if (me->last_chunk == NULL || me->last_chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_string) (me->target, str);
}

static void CacheThru_write(HTStream *me, const char *str, int l)
{
    if (me->status == HT_OK && l != 0) {
	if (me->fp) {
	    if (fwrite(str, (size_t) 1, (size_t) l, me->fp) < (size_t) l
		|| ferror(me->fp)) {
		me->status = HT_ERROR;
	    }
	} else if (me->chunk) {
	    me->last_chunk = HTChunkPutb2(me->last_chunk, str, l);
	    if (me->last_chunk == NULL || me->last_chunk->allocated == 0)
		me->status = HT_ERROR;
	}
    }
    (*me->actions->put_block) (me->target, str, l);
}

static const HTStreamClass PassThruCache =
{
    "PassThruCache",
    CacheThru_free,
    CacheThru_abort,
    CacheThru_put_character,
    CacheThru_put_string,
    CacheThru_write
};

static HTStream *CacheThru_new(HTParentAnchor *anchor,
			       HTStream *target)
{
    char *cp_freeme = NULL;
    char filename[LY_MAXPATH];
    HTStream *stream = NULL;
    HTProtocol *p = (HTProtocol *) anchor->protocol;

    /*
     * Neatly and transparently vanish if source caching is disabled.
     */
    if (LYCacheSource == SOURCE_CACHE_NONE)
	return target;

#ifndef DEBUG_SOURCE_CACHE
    /*  Only remote HTML documents may benefit from HTreparse_document(),  */
    /*  oh, assume http protocol:                                          */
    if (strcmp(p->name, "http") != 0
	&& strcmp(p->name, "https") != 0) {
	CTRACE((tfp, "SourceCacheWriter: Protocol is \"%s\"; not cached\n", p->name));
	return target;
    }
#else
    /* all HTStreams will be cached */
#endif

    CTRACE((tfp, "start CacheThru_new\n"));

    stream = (HTStream *) malloc(sizeof(*stream));
    if (!stream)
	outofmem(__FILE__, "CacheThru_new");

    assert(stream != NULL);

    stream->isa = &PassThruCache;
    stream->anchor = anchor;
    stream->fp = NULL;
    stream->filename = NULL;
    stream->chunk = NULL;
    stream->target = target;
    stream->actions = target->isa;
    stream->status = HT_OK;

    if (LYCacheSource == SOURCE_CACHE_FILE) {

	if (anchor->source_cache_file) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace source cache file %s\n",
		    anchor->source_cache_file));
	}

	/*
	 * We open the temp file in binary mode to make sure that
	 * end-of-line stuff and high-bit Latin-1 (or other) characters
	 * don't get munged; this way, the file should (knock on wood)
	 * contain exactly what came in from the network.
	 */
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W))) {
	    CTRACE((tfp,
		    "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		    cp_freeme = HTAnchor_address((HTAnchor *) anchor)));
	    FREE(stream);
	    FREE(cp_freeme);
	    return target;
	}

	StrAllocCopy(stream->filename, filename);

	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in file %s\n",
		cp_freeme = HTAnchor_address((HTAnchor *) anchor),
		filename));
	FREE(cp_freeme);
    }

    if (LYCacheSource == SOURCE_CACHE_MEMORY) {
	if (anchor->source_cache_chunk) {
	    CTRACE((tfp,
		    "SourceCacheWriter: If successful, will replace memory chunk %p\n",
		    (void *) anchor->source_cache_chunk));
	}
	stream->chunk = stream->last_chunk = HTChunkCreateMayFail(4096, 1);
	if (!stream->chunk)	/* failed already? pretty bad... - kw */
	    stream->status = HT_ERROR;

	CTRACE((tfp,
		"SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
		cp_freeme = HTAnchor_address((HTAnchor *) anchor),
		(void *) stream->chunk));
	FREE(cp_freeme);
    }

    return stream;
}
#else
#define CacheThru_new(anchor, target) target
#endif

/*	HTConverter for HTML to plain text
 *	----------------------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but never actually used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToPlain(HTPresentation *pres,
		      HTParentAnchor *anchor,
		      HTStream *sink)
{
    CTRACE((tfp, "HTMLToPlain calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor,
				  HTML_new(anchor, pres->rep_out, sink)));
}

/*	HTConverter for HTML source to plain text
 *	-----------------------------------------
 *
 *	This will preparse HTML and convert back to presentation or plain text.
 *
 *	It is registered in HTInit.c and used by lynx if invoked with
 *	-preparsed.  The stream generated here will be fed with HTML text,
 *	It feeds that to the SGML.c parser, which in turn feeds an HTMLGen.c
 *	structured stream for regenerating flat text; the latter should
 *	end up being handled as text/plain. - kw
 */
HTStream *HTMLParsedPresent(HTPresentation *pres,
			    HTParentAnchor *anchor,
			    HTStream *sink)
{
    HTStream *intermediate = sink;

    if (!intermediate) {
	/*
	 * Trick to prevent HTPlainPresent from translating again.  Temporarily
	 * change UCT_STAGE_PARSER setting in anchor while the HTPlain stream
	 * is initialized, so that HTPlain sees its input and output charsets
	 * as the same.  - kw
	 */
	int old_parser_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_PARSER);
	int structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_STRUCTURED);

	if (structured_cset < 0)
	    structured_cset = HTAnchor_getUCLYhndl(anchor, UCT_STAGE_HTEXT);
	if (structured_cset < 0)
	    structured_cset = current_char_set;
	HTAnchor_setUCInfoStage(anchor, structured_cset,
				UCT_STAGE_PARSER, UCT_SETBY_MIME);
	if (pres->rep_out == WWW_SOURCE) {
	    /*  same effect as
	       intermediate = HTPlainPresent(pres, anchor, NULL);
	       just written in a more general way:
	     */
	    intermediate = HTStreamStack(WWW_PLAINTEXT, WWW_PRESENT,
					 NULL, anchor);
	} else {
	    /*  this too should amount to calling HTPlainPresent: */
	    intermediate = HTStreamStack(WWW_PLAINTEXT, pres->rep_out,
					 NULL, anchor);
	}
	if (old_parser_cset != structured_cset) {
	    HTAnchor_resetUCInfoStage(anchor, old_parser_cset,
				      UCT_STAGE_PARSER, UCT_SETBY_NONE);
	    if (old_parser_cset >= 0) {
		HTAnchor_setUCInfoStage(anchor, old_parser_cset,
					UCT_STAGE_PARSER,
					UCT_SETBY_DEFAULT + 1);
	    }
	}
    }
    if (!intermediate)
	return NULL;
    CTRACE((tfp, "HTMLParsedPresent calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor,
				  HTMLGenerator(intermediate)));
}

/*	HTConverter for HTML to C code
 *	------------------------------
 *
 *	C code is like plain text but all non-preformatted code
 *	is commented out.
 *	This will convert from HTML to presentation or plain text.
 *
 *	It is registered in HTInit.c, but normally not used by lynx.
 *	- kw 1999-03-15
 */
HTStream *HTMLToC(HTPresentation *pres GCC_UNUSED,
		  HTParentAnchor *anchor,
		  HTStream *sink)
{
    HTStructured *html;

    if (sink)
	(*sink->isa->put_string) (sink, "/* ");		/* Before even title */
    html = HTML_new(anchor, WWW_PLAINTEXT, sink);
    html->comment_start = "/* ";
    html->comment_end = " */\n";	/* Must start in col 1 for cpp */
    if (!sink)
	HTML_put_string(html, html->comment_start);
    CTRACE((tfp, "HTMLToC calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor, html));
}

/*	Presenter for HTML
 *	------------------
 *
 *	This will convert from HTML to presentation or plain text.
 *
 * (Comment from original libwww:)
 *	Override this if you have a windows version
 */
#ifndef GUI
HTStream *HTMLPresent(HTPresentation *pres GCC_UNUSED,
		      HTParentAnchor *anchor,
		      HTStream *sink GCC_UNUSED)
{
    CTRACE((tfp, "HTMLPresent calling CacheThru_new\n"));
    return CacheThru_new(anchor,
			 SGML_new(&HTML_dtd, anchor,
				  HTML_new(anchor, WWW_PRESENT, NULL)));
}
#endif /* !GUI */

/* (Comments from original libwww:) */
/*	Record error message as a hypertext object
 *	------------------------------------------
 *
 *	The error message should be marked as an error so that
 *	it can be reloaded later.
 *	This implementation just throws up an error message
 *	and leaves the document unloaded.
 *	A smarter implementation would load an error document,
 *	marking at such so that it is retried on reload.
 *
 * On entry,
 *	sink	is a stream to the output device if any
 *	number	is the HTTP error number
 *	message is the human readable message.
 *
 * On exit,
 *	returns a negative number to indicate lack of success in the load.
 */
/* (We don't actually do any of that hypertext stuff for errors,
   the trivial implementation for lynx just generates a message
   and returns. - kw 1999-03-15)
*/
int HTLoadError(HTStream *sink GCC_UNUSED, int number,
		const char *message)
{
    HTAlert(message);		/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */
    return -number;
}

static char *MakeNewTitle(STRING2PTR value, int src_type)
{
    char *ptr;
    char *newtitle = NULL;

    StrAllocCopy(newtitle, "[");
    if (value != 0 && value[src_type] != 0) {
	ptr = strrchr(value[src_type], '/');
	if (!ptr) {
	    StrAllocCat(newtitle, value[src_type]);
	} else {
	    StrAllocCat(newtitle, ptr + 1);
	}
    } else {
	ptr = 0;
    }
#ifdef SH_EX			/* 1998/04/02 (Thu) 16:02:00 */

    /* for proxy server 1998/12/19 (Sat) 11:53:30 */
    if (AS_casecomp(newtitle + 1, "internal-gopher-menu") == 0) {
	StrAllocCopy(newtitle, "+");
    } else if (AS_casecomp(newtitle + 1, "internal-gopher-unknown") == 0) {
	StrAllocCopy(newtitle, " ");
    } else {
	/* normal title */
	ptr = strrchr(newtitle, '.');
	if (ptr) {
	    if (AS_casecomp(ptr, ".gif") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpg") == 0)
		*ptr = '\0';
	    else if (AS_casecomp(ptr, ".jpeg") == 0)
		*ptr = '\0';
	}
	StrAllocCat(newtitle, "]");
    }
#else
    StrAllocCat(newtitle, "]");
#endif
    return newtitle;
}

static char *MakeNewImageValue(STRING2PTR value)
{
    char *ptr;
    char *newtitle = NULL;

    StrAllocCopy(newtitle, "[");
    ptr = (value[HTML_INPUT_SRC]
	   ? strrchr(value[HTML_INPUT_SRC], '/')
	   : 0);
    if (!ptr) {
	StrAllocCat(newtitle, value[HTML_INPUT_SRC]);
    } else {
	StrAllocCat(newtitle, ptr + 1);
    }
    StrAllocCat(newtitle, "]-Submit");
    return newtitle;
}

static char *MakeNewMapValue(STRING2PTR value, const char *mapstr)
{
    char *ptr;
    char *newtitle = NULL;

    StrAllocCopy(newtitle, "[");
    StrAllocCat(newtitle, mapstr);	/* ISMAP or USEMAP */
    if (verbose_img && non_empty(value[HTML_IMG_SRC])) {
	StrAllocCat(newtitle, ":");
	ptr = strrchr(value[HTML_IMG_SRC], '/');
	if (!ptr) {
	    StrAllocCat(newtitle, value[HTML_IMG_SRC]);
	} else {
	    StrAllocCat(newtitle, ptr + 1);
	}
    }
    StrAllocCat(newtitle, "]");
    return newtitle;
}
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: HTML.c,v 1.129 2009/06/23 19:47:33 tom Exp $
d18 2
d143 1
a143 1
			      const char **value,
d153 3
a155 3
static char *MakeNewTitle(const char **value, int src_type);
static char *MakeNewImageValue(const char **value);
static char *MakeNewMapValue(const char **value, const char *mapstr);
d256 3
d263 2
d267 7
a274 1
	CTRACE((tfp, "%s", message));
a276 3
    case BAD_HTML_WARN:
	CTRACE((tfp, "%s", message));
	break;
d300 1
a300 1
void HTML_put_character(HTStructured * me, char c)
d302 2
d310 2
d325 1
a325 1
    if (c == '\r')
d327 2
d342 1
a342 1
	    HTChunkPutc(&me->title, c);
d355 1
a355 1
	HTChunkPutc(&me->style_block, c);
d359 1
a359 1
	HTChunkPutc(&me->script, c);
d363 1
a363 1
	HTChunkPutc(&me->object, c);
d367 1
a367 1
	HTChunkPutc(&me->textarea, c);
d372 1
a372 1
	HTChunkPutc(&me->option, c);
d376 1
a376 1
	HTChunkPutc(&me->math, c);
d394 1
a394 1
	    HTChunkPutc(&me->option, c);
a494 7

	/*
	 * \r's are ignored.  In order to keep collapsing spaces correctly we
	 * must default back to the previous separator if there was one.
	 */
    } else if (c == '\r' && HText_getLastChar(me->text) == ' ') {
	HText_setLastChar(me->text, ' ');	/* set it to a generic separator */
d693 1
a693 1
 * *If DONT_TRACK_INTERNAL_LINKS is not defined, we keep track of whether a
d709 1
a709 1
 * *If DONT_TRACK_INTERNAL_LINKS is defined, URL-less URL-References are
d728 1
a728 1
   	flag = (BOOLEAN) ((s && (*s=='#' || *s=='\0')) ? TRUE : FALSE)
d732 2
a733 1
#define INTERN_LT (HTLinkType *)(intern_flag ? HTInternalLink : NULL)
d738 1
a738 1
static unsigned Style_className_len = 0;
d750 1
a750 1
			 unsigned length)
d752 3
a754 3
    unsigned offset = strlen(prefix);
    unsigned have = (unsigned) (Style_className_end - Style_className);
    unsigned need = (offset + length + 1);
d765 1
d783 1
a783 1
static void HTMLSRC_apply_markup(HTStructured * context, HTlexeme lexeme, BOOL start,
d800 1
a800 1
			       ts->element,
d802 1
a802 1
			       (const char **) ts->value,
d807 1
a807 1
			     ts->element,
d812 1
d854 3
a856 3
			const char **value,
			BOOL isobject,
			BOOL imagemap,
d859 2
a860 2
			BOOL convert,
			BOOL start,
d896 1
a896 1
							 INTERN_LT);	/* Type */
d962 1
a962 1
			      const char **value,
d1023 1
a1023 1
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
d1035 1
a1035 1
			    LYstrncpy(buf,
d1045 1
a1045 1
			    char kind = (char) (!strchr(value[i], '"') ?
d1047 1
a1047 1
						!strchr(value[i], '\'') ?
d1117 1
a1117 1
		 HTML_dtd.tags[element_number].name_len);
d1254 1
a1254 1
	    if (!strncmp(temp, "//", 2)) {
d1275 1
a1275 1
		char *p = strchr(temp, '?');
d1328 1
a1328 1
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
d2397 8
a2404 4
	change_paragraph_style(me, styles[ElementNumber]);
	UPDATE_STYLE;
	if (me->sp->tag_number == (int) ElementNumber)
	    LYEnsureDoubleSpace(me);
d2735 1
a2735 1
		    sprintf(number_string, LYUppercaseA_OL_String(seqnum));
d2737 1
a2737 1
		    sprintf(number_string, LYLowercaseA_OL_String(seqnum));
d2739 1
a2739 1
		    sprintf(number_string, LYUppercaseI_OL_String(seqnum));
d2741 1
a2741 1
		    sprintf(number_string, LYLowercaseI_OL_String(seqnum));
d2932 1
a2932 1
		if (!url_type && !strncmp(href, "/foo/..", 7) &&
a3025 1
	    dest_ismap = FALSE;
d3083 1
a3083 1
	    url_type = LYLegitimizeHREF(me, &map_href, TRUE, TRUE);
a3501 1
	dest_ismap = FALSE;
d3543 1
a3543 1
	    if ((cp = strchr(me->map_address, '#')) != NULL)
d3572 1
a3572 1
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
d4236 1
a4236 1
	    EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = TRUE);
d4398 1
a4398 1
	    } else if (strchr(value[HTML_BUTTON_NAME], '&') == NULL) {
d4422 1
a4422 1
		if (!isEmpty(I.name)) {
d4427 2
d4431 3
d4565 1
a4566 1
#ifdef NOTDEFINED
d4640 1
a4640 1
	    } else if (strchr(value[HTML_INPUT_NAME], '&') == NULL) {
d4791 1
a4791 1
		I.disabled = YES;
d4992 1
a4992 1
	    if (strchr(value[HTML_TEXTAREA_NAME], '&') != NULL) {
d5042 1
a5042 1
	me->textarea_disabled = NO;
d5044 1
a5044 1
	    me->textarea_disabled = YES;
d5046 1
d5089 1
a5089 1
		       present, (const char **) value,
d5565 1
a5565 1
		    me->skip_stack, NONNULL(me->sp->style->name)));
d5583 1
a5583 1
		NONNULL(me->new_style->name),
d5588 1
a5588 1
#ifdef EXP_JUSTIFY_ELTS
d5591 1
a5591 1
	    wait_for_this_stacked_elt = me->stack - me->sp + MAX_NESTING;
d5594 1
a5594 1
#ifdef EXP_JUSTIFY_ELTS
a5628 4
 *
 *	We don't turn on "CAREFUL" check because the parser produces
 *	(internal code errors apart) good nesting.  The parser checks
 *	incoming code errors, not this module.
d5633 2
d5640 2
d5643 2
a5644 1
    EMIT_IFDEF_EXP_JUSTIFY_ELTS(BOOL reached_awaited_stacked_elt = FALSE);
d5661 1
a5661 1
		LYstrncpy(buf, tag->name, sizeof(buf) - 1);
a5685 3
#ifdef CAREFUL			/* parser assumed to produce good nesting */
	/* panic */
#endif /* CAREFUL */
d5704 1
d5706 1
d5735 1
a5735 1
		     me->skip_stack, NONNULL(me->sp->style->name)));
d5753 1
a5753 1
		     NONNULL(me->sp->style->name)));
d5793 1
a5793 1
#ifdef EXP_JUSTIFY_ELTS
d5812 1
a5812 1
			     NONNULL(me->sp->style->name)));
d5822 1
a5822 1
		     NONNULL(me->sp->style->name)));
d5829 1
a5829 1
#ifdef EXP_JUSTIFY_ELTS
d6070 1
a6070 1
		      (const BOOL *) 0, (const char **) 0,
d6212 1
a6212 1
#ifdef EXP_JUSTIFY_ELTS
d6307 1
a6307 1
	    while ((cp = strchr(data, '<')) != NULL) {
d6313 1
a6313 1
		if (!strncmp(cp, "<!--", 4)) {
d6388 1
a6388 1
		    StrnAllocCat(*include, me->object.data, me->object.size);
d6729 1
a6729 1
	EMIT_IFDEF_EXP_JUSTIFY_ELTS(form_in_htext = FALSE);
d6835 1
d6895 1
a6895 1
	    if ((cp = strchr(data, '\n')) != NULL) {
d6906 1
a6906 1
		data = "";
d6928 1
a6928 1
		    } else if ((cp = strchr(data, '\n')) != NULL) {
d6935 1
a6935 1
			data = "";
d6954 1
a6954 1
		chars = HText_beginInput(me->text, me->inUnderline, &I);
d6961 1
a6961 1
		} else if ((cp = strchr(data, '\n')) != NULL) {
d6968 1
a6968 1
		    data = "";
d7206 1
a7206 1
#ifdef EXP_JUSTIFY_ELTS
d7420 1
a7420 1
    if (me->sp && me->sp->style && me->sp->style->name) {
d7505 1
a7505 1
    if (me->sp && me->sp->style && me->sp->style->name) {
d7660 1
a7706 1
    me->textarea_disabled = NO;
d7777 1
a7777 1
    addClassName("", "", 0);
d7843 1
a7843 1
	LYRemoveTemp(me->anchor->source_cache_file);
d7871 1
a7871 1
	    LYRemoveTemp(me->filename);
d7910 1
a7910 1
	    LYRemoveTemp(me->filename);
d7930 1
a7930 1
static void CacheThru_put_character(HTStream *me, char c_in)
d7965 2
a7966 2
	    fwrite(str, 1, (unsigned) l, me->fp);
	    if (ferror(me->fp))
d7968 1
d8020 2
d8245 1
a8245 1
static char *MakeNewTitle(const char **value, int src_type)
d8251 1
a8251 1
    if (value != 0 && value[src_type] != 0)
d8253 6
a8258 1
    else
a8259 4
    if (!ptr) {
	StrAllocCat(newtitle, value[src_type]);
    } else {
	StrAllocCat(newtitle, ptr + 1);
d8287 1
a8287 1
static char *MakeNewImageValue(const char **value)
d8305 1
a8305 1
static char *MakeNewMapValue(const char **value, const char *mapstr)
@


1.8
log
@Initialize all the InputFieldData members correctly.  Fixes a crash when
going for example to http://thawte.com/.
deraadt@@ otto@@ ok
@
text
@d1 4
a4 1
/*		Structured stream to Rich hypertext converter
d49 1
d218 4
d224 43
a266 4
    if (!TRACE && !me->inBadHTML) {
	HTUserMsg(BAD_HTML_USE_TRACE);
	me->inBadHTML = TRUE;
	return FALSE;
a267 1
    return TRUE;
d718 2
a719 1
#define CHECK_FOR_INTERN(flag,s) flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE
d740 1
a740 1
			 int length)
d742 2
a743 2
    int offset = strlen(prefix);
    unsigned have = (Style_className_end - Style_className);
d1111 3
a1113 3
	current_tag_style = class_name[0]
	    ? -1
	    : cached_tag_styles[element_number];
d1182 1
a1182 1
    HText_characterStyle(me->text, hcode, 1);
d1326 2
d1330 7
a1336 1
		present[HTML_LINK_REV] && value[HTML_LINK_REV]) {
d1338 1
a1338 1
		 * Handle REV="made" or REV="owner".  - LM & FM
d1340 3
a1342 8
		if (!strcasecomp("made", value[HTML_LINK_REV]) ||
		    !strcasecomp("owner", value[HTML_LINK_REV])) {
		    /*
		     * Load the owner element.  - FM
		     */
		    HTAnchor_setOwner(me->node_anchor, href);
		    CTRACE((tfp, "HTML: DOC OWNER '%s' found\n", href));
		    FREE(href);
d1344 14
a1357 16
		    /*
		     * Load the RevTitle element if a TITLE attribute and value
		     * are present.  - FM
		     */
		    if (present && present[HTML_LINK_TITLE] &&
			value[HTML_LINK_TITLE] &&
			*value[HTML_LINK_TITLE] != '\0') {
			StrAllocCopy(title, value[HTML_LINK_TITLE]);
			TRANSLATE_AND_UNESCAPE_ENTITIES(&title, TRUE, FALSE);
			LYTrimHead(title);
			LYTrimTail(title);
			if (*title != '\0')
			    HTAnchor_setRevTitle(me->node_anchor, title);
			FREE(title);
		    }
		    break;
d1359 1
d1579 1
a1579 1
		HText_characterStyle(me->text, hash_code(tmp), 1);
d1584 1
a1584 1
		HText_characterStyle(me->text, hash_code(tmp), 0);
d2246 1
a2246 1
    case HTML_ABBREV:		/* Miscellaneous character containers */
d2831 1
a2831 1
	CHECK_ID(HTML_FN_ID);
d4135 1
a4135 1
	CHECK_ID(HTML_CREDIT_ID);
d4315 1
a4315 1
	CHECK_ID(HTML_FIELDSET_ID);
d4321 1
a4321 1
	CHECK_ID(HTML_LEGEND_ID);
d4343 15
a4357 8
	    if ((present && present[HTML_BUTTON_TYPE] &&
		 value[HTML_BUTTON_TYPE]) &&
		(!strcasecomp(value[HTML_BUTTON_TYPE], "submit") ||
		 !strcasecomp(value[HTML_BUTTON_TYPE], "reset"))) {
		/*
		 * It's a button for submitting or resetting a form.  - FM
		 */
		I.type = value[HTML_BUTTON_TYPE];
d4359 2
a4360 20
		/*
		 * Ugh, it's a button for a script.  - FM
		 */
		HTML_put_string(me, " [BUTTON] ");
		break;
	    }

	    /*
	     * Make sure we're in a form.
	     */
	    if (!me->inFORM) {
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n"));
		/*
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
		 *
		 break;
		 */
d4407 6
d4472 3
a4474 3
				       (I.value[i] == ' ')
				       ? HT_NON_BREAK_SPACE
				       : I.value[i]);
d4572 1
a4572 2
		    HTML_put_string(me, "[BUTTON] ");
		    break;
a4592 15
	    /*
	     * Check if we're in a form.  - FM
	     */
	    if (!me->inFORM) {
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n"));
		/*
		 * We'll process it, since the chances of a crash are small,
		 * and we probably do have a form started.  - FM
		 *
		 break;
		 */
	    }

d4599 3
a4601 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag.\n"));
d4771 2
a4888 1
		HText_setIgnoreExcess(me->text, TRUE);
a4952 1
	    HText_setIgnoreExcess(me->text, FALSE);
a4960 13
	 * Make sure we're in a form.
	 */
	if (!me->inFORM) {
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA start tag not within FORM tag\n"));
	    /*
	     * Too likely to cause a crash, so we'll ignore it.  - FM
	     */
	    break;
	}

	/*
d4993 1
a4993 1
	    isdigit(UCH(*value[HTML_TEXTAREA_COLS])))
d4995 1
a4995 1
	else {
d5012 1
a5012 1
	    isdigit(UCH(*value[HTML_TEXTAREA_ROWS])))
d5014 1
a5014 1
	else
d5016 1
d5019 8
a5028 2
	else
	    me->textarea_disabled = NO;
d5056 3
a5058 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5085 3
a5087 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: OPTION tag not within SELECT tag\n"));
d5168 4
a5171 1
		    (present && present[HTML_OPTION_DISABLED]))
d5173 1
d5259 1
a5259 1
		    for (i = strlen(marker); i < 5; ++i) {
d5699 1
a5699 1
	     element_number == HTML_H6 ||
d5765 1
a5765 1
		    element_number == HTML_H6 ||
d5820 3
a5822 2
	if (LYBadHTML(me))
	    CTRACE((tfp, "Bad HTML: Missing TEXTAREA end tag\n"));
d5836 15
a5850 10
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: %s%s%s%s%s not closed before HTML end tag *****\n",
			me->inSELECT ? "SELECT" : "",
			(me->inSELECT && me->inTEXTAREA) ? ", " : "",
			me->inTEXTAREA ? "TEXTAREA" : "",
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
			me->inA ? "A" : ""));
d5946 15
a5960 10
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: %s%s%s%s%s not closed before BODY end tag *****\n",
			me->inSELECT ? "SELECT" : "",
			(me->inSELECT && me->inTEXTAREA) ? ", " : "",
			me->inTEXTAREA ? "TEXTAREA" : "",
			(((me->inSELECT || me->inTEXTAREA) && me->inA)
			 ? ", "
			 : ""),
			me->inA ? "A" : ""));
d6088 1
a6088 1
    case HTML_ABBREV:		/* Miscellaneous character containers */
d6326 9
a6334 4
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data));
d6466 3
a6468 3
		    if (LYBadHTML(me))
			CTRACE((tfp,
				"Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6705 3
a6707 2
	    if (LYBadHTML(me))
		CTRACE((tfp, "Bad HTML: Unmatched FORM end tag\n"));
d6721 3
a6723 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6774 3
a6776 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched TEXTAREA end tag\n"));
d6965 1
a6965 1
	    char *ptr;
d6971 3
a6973 2
		if (LYBadHTML(me))
		    CTRACE((tfp, "Bad HTML: Unmatched SELECT end tag *****\n"));
d6991 3
a6993 3
		if (LYBadHTML(me))
		    CTRACE((tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n"));
d7006 8
a7013 7
	    ptr = HText_setLastOptionValue(me->text,
					   me->option.data,
					   me->LastOptionValue,
					   LAST_ORDER,
					   me->LastOptionChecked,
					   me->UCLYhndl,
					   ATTR_CS_IN);
a7044 1
		    HText_setIgnoreExcess(me->text, TRUE);
a7074 1
		HText_setIgnoreExcess(me->text, FALSE);
d7223 1
a7223 1
    int nent = HTML_dtd.number_of_entities;
d7304 3
a7306 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7323 3
a7325 3
	    if (LYBadHTML(me))
		CTRACE((tfp,
			"Bad HTML: TEXTAREA not used properly *****\n"));
d7369 3
a7371 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n"));
d7385 3
a7387 3
	if (LYBadHTML(me))
	    CTRACE((tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n"));
d7856 1
a7856 1
		    me->chunk));
d7944 1
a7944 1
	    fwrite(str, 1, l, me->fp);
@


1.7
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d4289 1
a4289 20
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
	    I.accept_cs = NULL;
d4459 1
a4459 20
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
	    I.accept_cs = NULL;
d5115 1
a5115 1
		I.accept_cs = NULL;
a5116 1
		I.maxlength = NULL;
d6743 1
a6743 19
	    I.align = NULL;
	    I.accept = NULL;
	    I.checked = NO;
	    I.iclass = NULL;
	    I.disabled = NO;
	    I.error = NULL;
	    I.height = NULL;
	    I.id = NULL;
	    I.lang = NULL;
	    I.max = NULL;
	    I.maxlength = NULL;
	    I.md = NULL;
	    I.min = NULL;
	    I.name = NULL;
	    I.size = 0;
	    I.src = NULL;
	    I.type = NULL;
	    I.value = NULL;
	    I.width = NULL;
@


1.6
log
@make lynx(1) to use arc4random(4) instead of other random functions;

avoid a segfault by checking the value of TAB TO;
from Alexey Dobriyan <adobriyan@@gmail.com>; pushed by deraadt@@
@
text
@d2 12
a13 12
**		============================================
**
**	This generates a hypertext object.  It converts from the
**	structured stream interface of HTML events into the style-
**	oriented interface of the HText.h interface.  This module is
**	only used in clients and should not be linked into servers.
**
**	Override this module if making a new GUI browser.
**
**   Being Overidden
**
*/
d64 1
a64 1
# define HCODE_TO_STACK_OFF(x) /*(CSHASHSIZE+1)*/ 88888  /*special value.*/
d66 1
a66 1
# define HCODE_TO_STACK_OFF(x) x /*pass computed value*/
d97 1
a97 1
    CONST HTStreamClass *	isa;
d99 8
a106 7
    HTParentAnchor *		anchor;
    FILE *			fp;
    char *			filename;
    HTChunk *			chunk;
    CONST HTStreamClass *	actions;
    HTStream *			target;
    int				status;
d112 1
a112 1
PRIVATE HTStyleSheet * styleSheet = NULL;	/* Application-wide */
d116 2
a117 1
PRIVATE HTStyle *styles[HTML_ELEMENTS+LYNX_HTML_EXTRA_ELEMENTS];
d121 1
a121 1
PRIVATE HTStyle *default_style = NULL;
d123 1
a123 1
PUBLIC char *LYToolbarName = "LynxPseudoToolbar";
d126 1
a126 1
PRIVATE int i_prior_style = -1;
d132 8
a139 11
PRIVATE int HTML_end_element PARAMS((HTStructured *me,
				      int element_number,
				      char **include));

PRIVATE int HTML_start_element PARAMS((
	HTStructured *		me,
	int			element_number,
	CONST BOOL*		present,
	CONST char **		value,
	int			tag_charset,
	char **			include));
d147 3
a149 3
PRIVATE char* MakeNewTitle PARAMS((CONST char ** value, int src_type));
PRIVATE char* MakeNewImageValue PARAMS((CONST char ** value));
PRIVATE char* MakeNewMapValue PARAMS((CONST char ** value, CONST char* mapstr));
d152 2
a153 2
**	is only internal and the stack manipulation should be skipped. - kw
*/
d157 1
a157 1
PUBLIC void strtolower ARGS1(char*, i)
d159 6
a164 2
    if (!i) return;
    while (*i) { *i = (char)TOLOWER(*i); i++; }
d168 7
a174 7
**		------------------------------
**
On the NeXT, and on any read-only browser, it is simpler for the text to have
a sequence of styles, rather than a nested tree of styles.  In this
case we have to flatten the structure as it arrives from SGML tags into
a sequence of styles.
*/
d177 3
a179 3
**  If style really needs to be set, call this.
*/
PUBLIC void actually_set_style ARGS1(HTStructured *, me)
d181 1
a181 1
    if (!me->text) {			/* First time through */
d184 1
a184 1
		     me->UCLYhndl, me->UCI,
d203 3
a205 3
**  If you THINK you need to change style, call this.
*/
PRIVATE void change_paragraph_style ARGS2(HTStructured *, me, HTStyle *,style)
d214 1
a214 2
PUBLIC BOOL LYBadHTML ARGS1(
    HTStructured *,	me)
d225 3
a227 3
**
**			A C T I O N	R O U T I N E S
*/
d242 3
a244 3
**	------------------
*/
PUBLIC void HTML_put_character ARGS2(HTStructured *, me, char, c)
d247 1
a247 2
     *	Ignore all non-MAP content when just
     *	scanning a document for MAPs. - FM
d253 1
a253 1
     *	Do EOL conversion if needed. - FM
d255 4
a258 4
     *	Convert EOL styles:
     *	 macintosh:  cr    --> lf
     *	 ascii:      cr-lf --> lf
     *	 unix:	     lf    --> lf
d269 1
a269 1
     *	Handle SGML_LITTERAL tags that have HTChunk elements. - FM
d274 1
a274 1
	return; /* Do Nothing */
d320 9
a328 9
	     *	If we are within a SELECT not caught by the cases
	     *	above - HTML_SELECT or HTML_OPTION may not be the
	     *	last element pushed on the style stack if there were
	     *	invalid markup tags within a SELECT element.  For error
	     *	recovery, treat text as part of the OPTION text, it is
	     *	probably meant to show up as user-visible text.
	     *	Having A as an open element while in SELECT is really sick,
	     *	don't make anchor text part of the option text in that case
	     *	since the option text will probably just be discarded. - kw
d336 1
a336 1
    } /* end first switch */
d339 1
a339 1
     *	Handle all other tag content. - FM
d343 1
a343 1
    case HTML_PRE:				/* Formatted text */
d345 2
a346 2
	 *  We guarantee that the style is up-to-date in begin_litteral
	 *  But we still want to strip \r's
d358 1
a358 1
    case HTML_LISTING:				/* Literal text */
d362 2
a363 2
	 *  We guarantee that the style is up-to-date in begin_litteral
	 *  But we still want to strip \r's
d365 1
a365 1
	if (c != '\r')	{
d374 1
a374 1
	 *  Free format text.
d420 1
a420 1
	       /* ignore */
d429 1
a429 1
    } /* end second switch */
d432 1
a432 1
	HText_setLastChar(me->text, ' '); /* set it to a generic separator */
d435 2
a436 3
	 *  \r's are ignored.  In order to keep collapsing spaces
	 *  correctly we must default back to the previous
	 *  separator if there was one
d439 1
a439 1
	HText_setLastChar(me->text, ' '); /* set it to a generic separator */
d446 6
a451 6
**	---------------
**
**	This is written separately from put_character because the loop can
**	in some cases be promoted to a higher function call level for speed.
*/
PUBLIC void HTML_put_string ARGS2(HTStructured *, me, CONST char *, s)
d454 1
a454 1
    char* translated_string = NULL;
d461 1
a461 1
	StrAllocCopy(translated_string,s);
d463 1
a463 1
	s = (CONST char *) translated_string;
d470 1
a470 1
	break;					/* Do Nothing */
d484 2
a485 2
    case HTML_PRE:				/* Formatted text */
    case HTML_LISTING:				/* Literal text */
d489 1
a489 1
	 *  We guarantee that the style is up-to-date in begin_litteral
d511 1
a511 1
    default:					/* Free format text? */
d514 3
a516 3
	     *	If we are within a preformatted text style not caught
	     *	by the cases above (HTML_PRE or similar may not be the
	     *	last element pushed on the style stack). - kw
d526 1
a526 1
		for(; *s; ++s)
d530 1
a530 1
	    HText_appendText(me->text, s);
d533 1
a533 1
	    CONST char *p = s;
d535 1
d538 1
a538 2
			      (*p == ' ') || (*p == '\t')); p++)
		    ;	/* Ignore leaders */
d546 3
a548 3
		     *	Treat any '\r' which is not followed by '\n'
		     *	as '\n', to account for macintosh lineend in
		     *	ALT attributes etc. - kw
d556 1
a556 1
			continue;  /* Ignore it */
d569 1
a569 1
		   if (HText_getLastChar(me->text) != ' ')
d573 1
a573 1
			/* ignore */
d586 4
a589 4
		     *	\r's are ignored.  In order to keep collapsing
		     *	spaces correctly, we must default back to the
		     *	previous separator, if there was one.  So we
		     *	set LastChar to a generic separator.
d596 1
a596 1
	    } /* for */
d598 1
a598 1
    } /* end switch */
d608 3
a610 3
**	------------
*/
PUBLIC void HTML_write ARGS3(HTStructured *, me, CONST char*, s, int, l)
d612 2
a613 2
    CONST char* p;
    CONST char* e = s+l;
a677 1

d679 4
a682 4
PRIVATE char* Style_className = 0;
PRIVATE char* Style_className_end = 0;
PRIVATE unsigned Style_className_len = 0;
PRIVATE int hcode;
d685 1
a685 1
PRIVATE void free_Style_className NOARGS
d691 3
a693 4
PRIVATE void addClassName ARGS3(
	CONST char *,	prefix,
	CONST char *,	actual,
	int,		length)
d702 1
a702 1
	    Style_className = malloc(Style_className_len);
d704 1
a704 1
	    Style_className = realloc(Style_className, Style_className_len);
d720 1
a720 1
#define addClassName(prefix, actual, length) /* nothing */
a722 1

d725 2
a726 5
PRIVATE void HTMLSRC_apply_markup ARGS4(
	    HTStructured *,   context,
	    HTlexeme,	      lexeme,
	    BOOL,	      start,
	    int,	      tag_charset)
d728 1
a728 1
    HT_tagspec* ts = *( ( start ? lexeme_start : lexeme_end ) + lexeme);
d739 1
a739 1
	CTRACE((tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexeme));
d741 6
a746 7
	    HTML_start_element(
		context,
		ts->element,
		ts->present,
		(CONST char **)ts->value,
		tag_charset,
		NULL);
d748 3
a750 4
	    HTML_end_element(
		context,
		ts->element,
		NULL);
a756 1
#if defined(__STDC__) || defined(_WIN_CC)
a758 4
#else
#  define PSRCSTART(x)	HTMLSRC_apply_markup(me,HTL_/**/x,START,tag_charset)
#  define PSRCSTOP(x)  HTMLSRC_apply_markup(me,HTL_/**/x,STOP,tag_charset)
#endif
d763 1
a763 1
#endif /* USE_PRETTYSRC*/
d765 4
a768 6
PRIVATE void LYStartArea ARGS5(
	HTStructured *,		obj,
	CONST char *,		href,
	CONST char *,		alt,
	CONST char *,		title,
	int,			tag_charset)
d770 2
a771 2
    BOOL		new_present[HTML_AREA_ATTRIBUTES];
    CONST char *	new_value[HTML_AREA_ATTRIBUTES];
d775 1
a775 1
	 new_present[i] = NO;
d779 1
a779 1
	new_value[HTML_AREA_ALT] = (CONST char *)alt;
d781 1
a781 1
    if (title && *title) {
d783 1
a783 1
	new_value[HTML_AREA_TITLE] = (CONST char *)title;
d787 1
a787 1
	new_value[HTML_AREA_HREF] = (CONST char *)href;
d790 2
a791 2
    (*obj->isa->start_element)(obj, HTML_AREA, new_present, new_value,
			       tag_charset, 0);
d794 9
a802 11
PRIVATE void LYHandleFIG ARGS10(
	HTStructured *,		me,
	CONST BOOL*,		present,
	CONST char **,		value,
	BOOL,			isobject,
	BOOL,			imagemap,
	CONST char *,		id,
	CONST char *,		src,
	BOOL,			convert,
	BOOL,			start,
	BOOL *,			intern_flag GCC_UNUSED)
d816 1
a816 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d818 1
a818 1
	if (id && *id) {
d827 1
a827 1
	if (clickable_images && src && *src) {
d829 1
d831 1
a831 1
	    CHECK_FOR_INTERN(*intern_flag,href);
d834 4
a837 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					INTERN_LT);		/* Type */
d841 5
a845 2
		HTML_put_string(me, (isobject ?
		      (imagemap ? "(IMAGE)" : "(OBJECT)") : "[FIGURE]"));
d850 1
a850 1
		HTML_put_character(me, ' '); /* space char may be ignored */
d859 1
a859 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d864 1
a864 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d872 1
a872 2
PRIVATE void clear_objectdata ARGS1(
	HTStructured *,		me)
d899 7
a905 9
**	-------------
*/
PRIVATE int HTML_start_element ARGS6(
	HTStructured *,		me,
	int,			element_number,
	CONST BOOL*,		present,
	CONST char **,		value,
	int,			tag_charset,
	char **,		include)
d917 1
a917 1
    CONST char *Base = NULL;
d919 3
a921 3
    HTParentAnchor *dest = NULL;	     /* An anchor's destination */
    BOOL dest_ismap = FALSE;		     /* Is dest an image map script? */
    HTChildAnchor *ID_A = NULL;		     /* HTML_foo_ID anchor */
d924 1
a924 1
    HTMLElement ElementNumber = element_number;
d928 1
d937 1
a937 1
	    HTTag * tag = &HTML_dtd.tags[element_number];
d939 2
a940 1
	    CONST char* p;
d947 1
a947 1
		*/
d956 4
a959 2
	    /*write markup for tags and exit*/
	    PSRCSTART(abracket); PUTC('<'); PSRCSTOP(abracket);
d961 1
a961 1
	    if (tagname_transform!=0)
d964 1
a964 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d973 1
a973 1
			if (attrname_transform!=0)
d976 3
a978 1
			    LYstrncpy(buf, tag->attributes[i].name, sizeof(buf)-1);
d983 9
a991 7
			    char q='"';
				/*0 in dquotes, 1 - in quotes, 2 mixed*/
			    char kind= (char) ( !strchr(value[i], '"') ?
					 0 :
					 !strchr(value[i], '\'') ?
					 q='\'',1 :
					 2);
d998 2
a999 2
				HTStartAnchor(me,value[i],NULL);
				HTML_end_element(me,HTML_A,NULL);
d1002 1
a1002 1
				HTStartAnchor(me,NULL,value[i]);
d1004 1
a1004 1
			    if (kind!=2)
d1014 1
a1014 1
				HTML_end_element(me,HTML_A,NULL);
d1019 3
a1021 3
			} /* if value */
		    } /* if present[i] */
	    }/* if present*/
d1023 4
a1026 2
	    PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
	    psrc_nested_call=FALSE;
d1028 2
a1029 2
	} /*if (!psrc_nested_call) */
	/*fall through*/
d1041 1
a1041 3
    }

    {
d1045 2
a1046 2
	if ((me->tag_charset != j) || (j < 0  /* for trace entry */)) {
	    CTRACE((tfp, "me->tag_charset: %d -> %d", me->tag_charset, j ));
d1048 1
a1048 1
		   me->UCLYhndl, tag_charset));
d1056 3
a1058 3
    addClassName(";", 
	         HTML_dtd.tags[element_number].name,
	         HTML_dtd.tags[element_number].name_len);
d1065 2
a1066 2
			  ? -1
			  : cached_tag_styles[element_number];
d1080 1
a1080 1
	    if (!hashStyles[hcode].name) { /* None such -> classless version */
d1083 3
a1085 2
			(tfp, "STYLE.start_element: <%s> (class <%s> not configured), hcode=%d.\n",
			HTML_dtd.tags[element_number].name, class_name, hcode));
d1091 1
a1091 1
			HTML_dtd.tags[element_number].name, class_name, hcode));
d1098 1
a1098 1
    } else { /* (current_tag_style!=-1)	 */
d1106 1
a1106 1
		HTML_dtd.tags[element_number].name, hcode));
d1111 2
a1112 2
    if (!class_used && ElementNumber == HTML_INPUT) { /* For some other too? */
	CONST char *type = "";
d1120 1
a1120 1
	if (!hashStyles[hcode].name) { /* None such -> classless version */
d1124 1
a1124 1
			   type));
d1130 1
a1130 1
			  HTML_dtd.tags[element_number].name, type, hcode));
d1133 1
a1133 1
#endif	/* !OMIT_SCN_KEEPING */
d1139 1
a1139 1
     *	Handle the start tag. - FM
d1151 1
a1151 1
	    value[HTML_BASE_HREF] && *value[HTML_BASE_HREF]) {
d1153 1
a1153 1
	    CONST char *related = NULL;
d1160 1
a1160 1
			    NonNull(base)));
d1168 5
a1172 6
		 *  These have a non-standard form, basically
		 *  strip the prefix or the code below would insert
		 *  a nonsense host into the pseudo URL.  These
		 *  should never occur where they would be used for
		 *  resolution of relative URLs anyway.  We can
		 *  also strip the #map part. - kw
d1180 1
a1180 1
	     *	Get parent's address for defaulted fields.
d1185 1
a1185 1
	     *	Create the access field.
d1187 1
a1187 1
	    temp = HTParse(base, related, PARSE_ACCESS+PARSE_PUNCTUATION);
d1192 1
a1192 1
	     *	Create the host[:port] field.
d1194 1
a1194 1
	    temp = HTParse(base, "", PARSE_HOST+PARSE_PUNCTUATION);
d1206 1
a1206 1
					    PARSE_HOST+PARSE_PUNCTUATION)));
d1212 1
a1212 1
	     *	Create the path field.
d1214 1
a1214 1
	    temp = HTParse(base, "", PARSE_PATH+PARSE_PUNCTUATION);
d1217 1
d1222 1
a1222 1
		    *(p+1) = '\0';  /* strip after the last slash */
d1258 1
a1258 1
	    CHECK_FOR_INTERN(intern_flag,value[HTML_LINK_HREF]);
d1260 1
a1260 1
	     *	Prepare to do housekeeping on the reference. - FM
d1262 1
a1262 1
	    if (!value[HTML_LINK_HREF]) {
d1264 2
a1265 2
			? me->base_href
			: me->node_anchor->address;
d1272 2
a1273 2
			? me->base_href
			: me->node_anchor->address;
d1278 1
a1278 1
	     *	Handle links with a REV attribute. - FM
d1283 1
a1283 1
		 *  Handle REV="made" or REV="owner". - LM & FM
d1288 1
a1288 1
		     *	Load the owner element. - FM
d1295 2
a1296 2
		     *	Load the RevTitle element if a TITLE attribute
		     *	and value are present. - FM
d1314 1
a1314 1
	     *	Handle REL links. - FM
d1320 1
a1320 1
		 *  Ignore style sheets, for now. - FM
d1329 4
a1332 2
		    CTRACE2(TRACE_STYLE, (tfp, "HTML: StyleSheet link found.\n"));
		    CTRACE2(TRACE_STYLE, (tfp, "        StyleSheets not yet implemented.\n"));
d1339 6
a1344 6
		 *  Ignore anything not registered in the 28-Mar-95
		 *  IETF HTML 3.0 draft and W3C HTML 3.2 draft, or not
		 *  appropriate for Lynx banner links in the expired
		 *  Maloney and Quin relrev draft.  We'll make this more
		 *  efficient when the situation stabilizes, and for now,
		 *  we'll treat "Banner" as another toolbar element. - FM
d1375 17
a1391 18
		    pdoctitle = &title;	/* for setting HTAnchor's title */
		} else
		if (!strcasecomp(value[HTML_LINK_REL], "Up") ||
		    !strcasecomp(value[HTML_LINK_REL], "Next") ||
		    !strcasecomp(value[HTML_LINK_REL], "Previous") ||
		    !strcasecomp(value[HTML_LINK_REL], "Prev") ||
		    !strcasecomp(value[HTML_LINK_REL], "Child") ||
		    !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
		    !strcasecomp(value[HTML_LINK_REL], "Parent") ||
		    !strcasecomp(value[HTML_LINK_REL], "Meta") ||
		    !strcasecomp(value[HTML_LINK_REL], "URC") ||
		    !strcasecomp(value[HTML_LINK_REL], "Pointer") ||
		    !strcasecomp(value[HTML_LINK_REL], "Translation") ||
		    !strcasecomp(value[HTML_LINK_REL], "Definition") ||
		    !strcasecomp(value[HTML_LINK_REL], "Alternate") ||
		    !strcasecomp(value[HTML_LINK_REL], "Section") ||
		    !strcasecomp(value[HTML_LINK_REL], "Subsection") ||
		    !strcasecomp(value[HTML_LINK_REL], "Chapter")) {
d1413 1
a1413 1
				 value[HTML_LINK_REL]));
d1421 2
a1422 2
	     *	If no HREF was specified, handle special REL links
	     *	with self-designated HREFs. - FM
d1431 3
a1433 2
		CTRACE((tfp, "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			    value[HTML_LINK_REL]));
d1441 2
a1442 3
	     *	Create a title (link name) from the TITLE value,
	     *	if present, or default to the REL value that was
	     *	loaded into title. - FM
d1445 1
a1445 1
		value[HTML_LINK_TITLE] && *value[HTML_LINK_TITLE] != '\0') {
d1451 1
a1451 1
		FREE(temp); /* forget about recording RelTitle - kw */
d1453 1
a1453 1
	    if (!(title && *title)) {
d1461 3
a1463 4
		 *  Ugh!  The LINK tag, which is a HEAD element,
		 *  is in an Anchor, which is BODY element.  All
		 *  we can do is close the Anchor and cross our
		 *  fingers. - FM
d1470 1
a1470 2
	     *	Create anchors for the links that simulate
	     *	a toolbar. - FM
d1472 7
a1478 7
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				href,			/* Addresss */
				temp
				   ? (HTLinkType*)HTAtom_for(temp)
				   : INTERN_LT);	/* Type */
d1480 2
a1481 3
	    if ((dest = HTAnchor_parent(
			    HTAnchor_followLink(me->CurrentA)
				      )) != NULL) {
d1490 1
a1490 1
		    value[HTML_LINK_CHARSET] && *value[HTML_LINK_CHARSET] != '\0') {
d1502 4
a1505 5
		(ID_A = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					LYToolbarName,		/* Tag */
					NULL,			/* Addresss */
					(HTLinkType*)0))) {	/* Type */
d1507 1
a1507 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d1513 2
a1514 2
		 *  Add collapsible space to separate link from previous
		 *  generated links. - kw
d1523 1
a1523 2
	    value && *value[HTML_LINK_CLASS]!='\0')
	    {
d1525 1
d1537 1
a1537 2
	    }
	    else
d1539 1
a1539 1
	    HTML_put_string(me, title);
d1553 4
a1556 4
	     *	Lynx was supporting ACTION, which never made it into
	     *	the HTML 2.0 specs.  HTML 3.0 uses HREF, so we'll
	     *	use that too, but allow use of ACTION as an alternate
	     *	until people have fully switched over. - FM
d1565 2
a1566 2
		    ? me->base_href
		    : me->node_anchor->address;
d1573 1
a1573 1
			me->base_href : me->node_anchor->address;
d1577 1
a1577 1
	 *  Support HTML 3.0 PROMPT attribute. - FM
d1581 1
a1581 1
	    value[HTML_ISINDEX_PROMPT] && *value[HTML_ISINDEX_PROMPT]) {
d1603 2
a1604 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d1611 2
a1612 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d1628 1
a1628 1
	    value[HTML_FRAME_NAME] && *value[HTML_FRAME_NAME]) {
d1635 1
a1635 1
	    value[HTML_FRAME_SRC] && *value[HTML_FRAME_SRC]) {
d1643 4
a1646 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				href,			/* Addresss */
				(HTLinkType*)0);	/* Type */
d1681 1
a1681 1
	    value[HTML_IFRAME_NAME] && *value[HTML_IFRAME_NAME]) {
d1688 1
a1688 1
	    value[HTML_IFRAME_SRC] && *value[HTML_IFRAME_SRC]) {
d1695 4
a1698 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				href,			/* Addresss */
				(HTLinkType*)0);	/* Type */
d1701 1
a1701 1
	    LYResetParagraphAlignment(me);
d1734 2
a1735 3
	 *  Treat this as a toolbar if we don't have one
	 *  yet, and we are in the first half of the
	 *  first page. - FM
d1738 5
a1742 6
	     HText_getLines(me->text) < (display_lines/2)) &&
	    (ID_A = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					LYToolbarName,		/* Tag */
					NULL,			/* Addresss */
					(HTLinkType*)0))) {	/* Type */
d1756 2
a1757 2
		"HTML: ****** Maximum nesting of %d divisions exceeded!\n",
		MAX_NESTING));
d1760 1
a1760 1
	    LYEnsureSingleSpace(me); /* always at least break line - kw */
d1787 1
a1787 1
		   value[HTML_DIV_ALIGN] && *value[HTML_DIV_ALIGN]) {
d1820 10
a1829 10
	 *  Close the previous style if not done by HTML doc.
	 *  Added to get rid of core dumps in BAD HTML on the net.
	 *		GAB 07-07-94
	 *  But then again, these are actually allowed to nest.  I guess
	 *  I have to depend on the HTML writers correct style.
	 *		GAB 07-12-94
	if (i_prior_style != -1) {
	    HTML_end_element(me, i_prior_style);
	}
	i_prior_style = ElementNumber;
d1833 2
a1834 2
	 *  Check whether we have an H# in a list,
	 *  and if so, treat it as an LH. - FM
d1846 1
a1846 1
		ElementNumber = me->sp[0].tag_number;
d1850 6
a1855 8
	     *	Some authors use H# headers as a substitute for
	     *	FONT, so check if this one immediately followed
	     *	an LI.	If so, both me->inP and me->in_word will
	     *	be FALSE (though the line might not be empty due
	     *	to a bullet and/or nbsp) and we can assume it is
	     *	just for a FONT change.  We thus will not create
	     *	another line break nor add to the current left
	     *	indentation. - FM
d1869 1
a1869 1
	    value[HTML_H_ALIGN] && *value[HTML_H_ALIGN]) {
d1895 1
a1895 1
	    (styles[ElementNumber]->font&HT_BOLD)) {
d1911 6
a1916 6
	  /* Add a \r (new line) if these three conditions are true:
	   *   1. We are not collapsing BR's, and
	   *   2. The previous line has text on it, or
	   *   3. This line has text on it.
	   * Otherwise, don't do anything. -DH 980814, TD 980827
	   */
d1920 1
a1920 1
	    HText_setLastChar(me->text, ' ');  /* absorb white space */
d1945 3
a1947 4
	     *	Start a new line only if we had printable
	     *	characters following the previous newline,
	     *	or remove the previous line if both it and
	     *	the last line are blank. - FM
d1951 1
a1951 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d1960 1
a1960 1
	     *	Add an ID link if needed. - FM
d1964 6
a1969 7
	   /*
	    *  Center lines within the current margins, if
	    *  a right or left ALIGNment is not specified.
	    *  If WIDTH="#%" is given and not garbage,
	    *  use that to calculate the width, otherwise
	    *  use the default width. - FM
	    */
d1981 2
a1982 2
	    width = LYcols - 1 -
		    me->new_style->leftIndent - me->new_style->rightIndent;
d1985 1
a1985 1
		value[HTML_HR_WIDTH][strlen(value[HTML_HR_WIDTH])-1] == '%') {
d1988 1
d1990 1
a1990 1
		percent[strlen(percent)-1] = '\0';
d2012 2
a2013 2
	     *	Reset the alignment appropriately
	     *	for the division and/or block. - FM
d2018 1
a2018 1
				me->DivisionAlignments[me->Division_Level];
d2029 2
a2030 3
	     *	Add a blank line and set the second line
	     *	indentation for lists and addresses, or a
	     *	paragraph separator for other blocks. - FM
d2034 1
a2034 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d2043 1
a2043 1
	if (!present) { /* Bad tag.  Must have at least one attribute. - FM */
d2048 3
a2050 4
	 *  If page author is using TAB within a TABLE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
d2060 2
a2061 2
	     *	Just ensure a collapsible space, until we have
	     *	the ALIGN and DP attributes implemented. - FM
d2064 2
a2065 1
	    CTRACE((tfp, "HTML: ALIGN not 'left'.  Using space instead of TAB.\n"));
d2070 3
a2072 4
	     *	Just ensure a collapsible space, until we
	     *	can replace HText_getCurrentColumn() in
	     *	GridText.c with code which doesn't require
	     *	that the alignment be HT_LEFT. - FM
d2078 1
a2078 1
		    value[HTML_TAB_TO] && *value[HTML_TAB_TO]) ||
d2087 1
a2087 1
			value[HTML_TAB_TO] && *value[HTML_TAB_TO]) {
d2089 1
a2089 1
		 *  TO has priority over INDENT if both are present. - FM
d2096 1
a2096 1
	    } else if (!(temp && *temp) && present[HTML_TAB_INDENT] &&
d2100 2
a2101 2
		 *  The INDENT value is in "en" (enval per column) units.
		 *  Divide it by enval, rounding odd values up. - FM
d2104 1
a2104 1
		   (int)(((1.0 * atoi(value[HTML_TAB_INDENT]))/enval)+(0.5));
d2108 3
a2110 3
	     *	If we are being directed to a column too far to the left
	     *	or right, just add a collapsible space, otherwise, add the
	     *	appropriate number of spaces. - FM
d2116 2
a2117 1
		CTRACE((tfp, "HTML: Column out of bounds.  Using space instead of TAB.\n"));
d2121 1
a2121 1
		HText_setLastChar(me->text, ' ');  /* absorb white space */
d2127 2
a2128 2
	 *  If we have an ID attribute, save it together
	 *  with the value of the column we've reached. - FM
d2131 1
a2131 1
	    value[HTML_TAB_ID] && *value[HTML_TAB_ID]) {
d2146 6
a2151 7
	 *  FONT *may* have been declared SGML_EMPTY in HTMLDTD.c, and
	 *  SGML_character() in SGML.c *may* check for a FONT end
	 *  tag to call HTML_end_element() directly (with a
	 *  check in that to bypass decrementing of the HTML
	 *  parser's stack).  Or this may have been really a </FONT>
	 *  end tag, for which some incarnations of SGML.c would fake
	 *  a <FONT> start tag instead. - fm & kw
d2153 3
a2155 3
	 *  But if we have an open FONT, DON'T close that one now,
	 *  since FONT tags can be legally nested AFAIK, and Lynx
	 *  currently doesn't do anything with them anyway... - kw
d2163 2
a2164 2
	 *  Set flag to know we are in a FONT container, and
	 *  add code to do something about it, someday. - FM
d2169 1
a2169 1
    case HTML_B:			/* Physical character highlighting */
d2174 1
a2174 1
    case HTML_CITE:			/* Logical character highlighting */
d2181 2
a2182 2
	 *  Ignore this if inside of a bold anchor or header.
	 *  Can't display both underline and bold at same time.
d2191 1
a2191 1
	    CTRACE((tfp,"Beginning underline\n"));
d2193 1
a2193 1
	    CTRACE((tfp,"Underline Level is %d\n", me->Underline_Level));
d2197 1
a2197 1
    case HTML_ABBREV:	/* Miscellaneous character containers */
d2210 1
a2210 1
	break; /* ignore */
d2249 4
a2252 5
	 *  Should check LANG and/or DIR attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, to determine whether we should
	 *  use chevrons, but for now we'll always use double-
	 *  or single-quotes. - FM
d2261 1
a2261 1
    case HTML_PRE:				/* Formatted text */
d2263 5
a2267 6
	**  Set our inPRE flag to FALSE so that a newline
	**  immediately following the PRE start tag will
	**  be ignored.  HTML_put_character() will set it
	**  to TRUE when the first character within the
	**  PRE block is received. - FM
	*/
d2270 1
a2270 1
    case HTML_LISTING:				/* Literal text */
d2301 1
a2301 1
	     *	Indicate the type of NOTE.
d2344 1
a2344 1
	me->List_Nesting_Level++;  /* increment the List nesting level */
d2347 1
a2347 1
				      ? styles[HTML_DLC] : styles[HTML_DL]);
d2351 1
a2351 1
				      ? styles[HTML_DLC6] : styles[HTML_DL6]);
d2355 2
a2356 2
		 ? styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]
		 : styles[(HTML_DL1 - 1) + me->List_Nesting_Level]);
d2358 1
a2358 1
	UPDATE_STYLE;	  /* update to the new style */
d2364 1
a2364 1
	me->List_Nesting_Level++;  /* increment the List nesting level */
d2373 1
a2373 1
			    styles[(HTML_DLC1 - 1) + me->List_Nesting_Level]);
d2375 1
a2375 1
	UPDATE_STYLE;	  /* update to the new style */
d2385 1
d2387 5
a2391 5
	     *  If there are several DT elements and this is not the first,
	     *  and the preceding DT element's first (and normally only) line
	     *  has not yet been ended, suppress intervening blank line by
	     *  temporarily modifying the paragraph style in place.  Ugly
	     *  but there's ample precedence. - kw
d2394 1
a2394 1
		me->sp->style->spaceBefore = 0;	/* temporary change */
d2398 2
a2399 2
	    me->sp->style->spaceBefore = saved_spaceBefore; /* undo */
	    me->sp->style->spaceAfter = saved_spaceAfter; /* undo */
d2408 2
a2409 2
	HText_setLastChar(me->text, ' ');  /* absorb white space */
	if (!me->style_change)	{
d2428 2
a2429 2
	 me->OL_Type[(me->List_Nesting_Level < 11 ?
			 me->List_Nesting_Level+1 : 11)] = '1';
d2432 2
a2433 3
	 *  Check whether we have a starting sequence number,
	 *  or want to continue the numbering from a previous
	 *  OL in this nest. - FM
d2439 4
a2442 4
	     *	Give preference to the valid HTML 3.0 SEQNUM attribute name
	     *	over the Netscape START attribute name (too bad the Netscape
	     *	developers didn't read the HTML 3.0 specs before re-inventing
	     *	the "wheel" as "we'll"). - FM
d2445 1
a2445 1
		value[HTML_OL_SEQNUM] && *value[HTML_OL_SEQNUM]) {
d2448 1
a2448 1
		       value[HTML_OL_START] && *value[HTML_OL_START]) {
d2455 2
a2456 3
	     *	Don't allow negative numbers less than
	     *	or equal to our flags, or numbers less
	     *	than 1 if an Alphabetic or Roman TYPE. - FM
d2461 1
a2461 1
				    me->List_Nesting_Level+1 : 11)] = 'A';
d2466 1
a2466 1
				    me->List_Nesting_Level+1 : 11)] = 'a';
d2471 1
a2471 1
				    me->List_Nesting_Level+1 : 11)] = 'I';
d2476 1
a2476 1
				    me->List_Nesting_Level+1 : 11)] = 'i';
d2480 2
a2481 2
		  if (seqnum <= OL_VOID)
		      seqnum = OL_VOID + 1;
d2488 1
a2488 1
			       me->List_Nesting_Level+1 : 11)] = seqnum;
d2492 1
a2492 1
			      me->List_Nesting_Level+1 : 11] = OL_CONTINUE;
d2496 1
a2496 1
			       me->List_Nesting_Level+1 : 11)] = 1;
d2500 1
a2500 1
				    me->List_Nesting_Level+1 : 11)] = 'A';
d2503 1
a2503 1
				    me->List_Nesting_Level+1 : 11)] = 'a';
d2506 1
a2506 1
				    me->List_Nesting_Level+1 : 11)] = 'I';
d2509 1
a2509 1
				    me->List_Nesting_Level+1 : 11)] = 'i';
d2523 1
a2523 1
			  styles[HTML_OL1 + me->List_Nesting_Level - 1]);
d2525 1
a2525 1
	UPDATE_STYLE;  /* update to the new style */
d2536 1
a2536 1
		  0==strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2547 1
a2547 1
		  0==strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2558 1
a2558 1
		  0==strcasecomp(value[HTML_UL_TYPE], "PLAIN"))) {
d2560 2
a2561 1
			  styles[HTML_OL1 + me->List_Nesting_Level - 1]);
d2564 2
a2565 1
			  styles[HTML_MENU1 + me->List_Nesting_Level - 1]);
d2569 1
a2569 1
	UPDATE_STYLE;  /* update to the new style */
d2585 2
a2586 1
			  styles[HTML_MENU1 + me->List_Nesting_Level - 1]);
d2588 1
a2588 1
	UPDATE_STYLE;  /* update to the new style */
d2593 1
a2593 1
	UPDATE_STYLE;  /* update to the new style */
d2603 1
a2603 1
	UPDATE_STYLE;  /* update to the new style */
d2609 1
d2611 3
a2613 3
	     *  No, a LI should never occur directly within another LI,
	     *  but this may result from incomplete error recovery.
	     *  So check one more surrounding level in this case. - kw
d2683 1
a2683 1
		 *	Hack, because there is no append string!
d2692 6
a2697 7
		 *	Use HTML_put_character so that any other spaces
		 *	coming through will be collapsed.  We'll use
		 *	nbsp, so it won't break at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
d2703 1
a2703 1
		 *	Hack, because there is no append string!
d2707 1
a2707 1
		switch(me->List_Nesting_Level % 7) {
d2732 6
a2737 7
		 *	Keep using HTML_put_character so that any other
		 *	spaces coming through will be collapsed.  We use
		 *	nbsp, so we won't wrap at the spacing character
		 *	if there are no spaces in the subsequent text up
		 *	to the right margin, but will declare it as a
		 *	normal space to ensure collapsing if a normal
		 *	space does immediately follow it. - FM
d2743 1
a2743 1
		 *	Hack, because there is no append string!
d2758 3
a2760 3
	 *  Should check LANG and/or DIR attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, and do something here. - FM
d2767 3
a2769 3
	 *  Should check DIR (and LANG) attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, and do something here. - FM
d2790 1
a2790 1
	me->inLABEL = TRUE;
d2796 9
a2804 10
	    /*
	     *  If we are looking for client-side image maps,
	     *  then handle an A within a MAP that has a COORDS
	     *  attribute as an AREA tag.  Unfortunately we lose
	     *  the anchor text this way for the LYNXIMGMAP, we
	     *  would have to do much more parsing to collect it.
	     *  After potentially handling the A as AREA, always return
	     *  immediately if only looking for image maps, without
	     *  pushing anything on the style stack. - kw
	     */
d2815 5
a2819 6
	 *  A may have been declared SGML_EMPTY in HTMLDTD.c, and
	 *  SGML_character() in SGML.c may check for an A end
	 *  tag to call HTML_end_element() directly (with a
	 *  check in that to bypass decrementing of the HTML
	 *  parser's stack), so if we have an open A, close
	 *  that one now. - FM & kw
d2826 1
a2826 1
	 *  Set to know we are in an anchor.
d2831 1
a2831 1
	 *  Load id_string if we have an ID or NAME. - FM
d2834 1
a2834 1
	    value[HTML_A_ID] && *value[HTML_A_ID]) {
d2837 1
a2837 1
		   value[HTML_A_NAME] && *value[HTML_A_NAME]) {
d2844 1
a2844 1
	 *  Handle the reference. - FM
d2852 1
a2852 2
	    StrAllocCopy(href, value[HTML_A_HREF]);
	    if (isEmpty(href))
d2854 3
a2856 1
	    CHECK_FOR_INTERN(intern_flag,href);	 /* '#'*/
d2868 3
a2870 4
		      (isFTP_URL(me->node_anchor->address) ||
		       isFILE_URL(me->node_anchor->address))) {
		    for (i = 0; (href[i] = href[i+7]) != 0; i++)
			;
d2874 1
a2874 1
	    if (present[HTML_A_ISMAP]) /*???*/
d2890 3
a2892 3
		** Found TYPE="internal link" but not in a valid context
		** where we have written it. - kw
		*/
d2894 1
a2894 1
			    href, temp));
d2899 7
a2905 6
	me->CurrentA = HTAnchor_findChildAndLink(
			me->node_anchor,			/* Parent */
			id_string,				/* Tag */
			href,					/* Address */
			temp ?
		(HTLinkType*)HTAtom_for(temp) : INTERN_LT);  /* Type */
d2911 1
a2911 1
		value[HTML_A_TITLE] && *value[HTML_A_TITLE] != '\0') {
d2923 1
a2923 1
		value[HTML_A_CHARSET] && *value[HTML_A_CHARSET] != '\0') {
d2925 4
a2928 4
		**  Set up to load the anchor's chartrans structures
		**  appropriately for the current display character
		**  set if it can handle what's claimed. - FM
		*/
d2933 1
a2933 1
			dest_char_set = UCLYhndl_for_unrec;
d2937 2
a2938 3
		dest = HTAnchor_parent(
			HTAnchor_followLink(me->CurrentA)
				      );
d2948 4
a2951 5
		**  Load the anchor's chartrans structures.
		**  This should be done more intelligently
		**  when setting up the structured object,
		**  but it gets the job done for now. - FM
		*/
d2970 3
a2972 3
	 *  Close an HREF-less NAMED-ed now if we aren't making their
	 *  content bold, and let the check in HTML_end_element() deal
	 *  with any dangling end tag this creates. - FM
d2980 1
a2980 1
	    requested - VH*/
d2989 1
a2989 1
    case HTML_IMG:			/* Images */
d2991 3
a2993 4
	 *  If we're in an anchor, get the destination, and if it's a
	 *  clickable image for the current anchor, set our flags for
	 *  faking a 0,0 coordinate pair, which typically returns the
	 *  image's default. - FM
d2996 2
a2997 3
	    if ((dest = HTAnchor_parent(
			HTAnchor_followLink(me->CurrentA)
				      )) != NULL) {
d3001 1
a3001 1
				dest->address));
d3006 1
a3006 1
				dest->address));
d3013 1
a3013 1
	 *  If there's a USEMAP, resolve it. - FM
d3016 1
a3016 1
	    value[HTML_IMG_USEMAP] && *value[HTML_IMG_USEMAP]) {
d3018 1
a3018 1
	    CHECK_FOR_INTERN(intern_flag,map_href);
d3021 2
a3022 2
	     *	If map_href ended up zero-length or otherwise doesn't
	     *	have a hash, it can't be valid, so ignore it. - FM
d3030 1
a3030 1
	 *  Handle a MAP reference if we have one at this point. - FM
d3034 7
a3040 2
	     *	If the MAP reference doesn't yet begin with a scheme,
	     *	check whether a base tag is in effect. - FM
d3042 4
a3045 9
		/*
		 *  If the
		 *  USEMAP value is a lone fragment and LYSeekFragMAPinCur
		 *  is set, we'll use the current document's URL for
		 *  resolving.	Otherwise use the BASE. - kw
		 */
	    Base = (me->inBASE &&
			!(*map_href == '#' && LYSeekFragMAPinCur == TRUE)) ?
				me->base_href : me->node_anchor->address;
d3049 1
a3049 1
	     *	Prepend our client-side MAP access field. - FM
d3058 2
a3059 2
	 *  Check whether we want to suppress the server-side
	 *  ISMAP link if a client-side MAP is present. - FM
d3067 1
a3067 1
	 *  Check for a TITLE attribute. - FM
d3070 1
a3070 1
	    value[HTML_IMG_TITLE] && *value[HTML_IMG_TITLE]) {
d3081 3
a3083 3
	 *  If there's an ALT string, use it, unless the ALT string
	 *  is zero-length or just spaces and we are making all SRCs
	 *  links or have a USEMAP link. - FM
d3094 2
a3095 2
	     *	If it's all spaces and we are making SRC or
	     *	USEMAP links, treat it as zero-length. - FM
d3103 2
a3104 1
				     (temp = MakeNewMapValue(value,"USEMAP"))));
d3108 2
a3109 1
				     (temp = MakeNewMapValue(value,"ISMAP"))));
d3115 2
a3116 1
						  VERBOSE_IMG(value, HTML_IMG_SRC, "[LINK]")));
d3120 6
a3125 5
					     (title ? title :
						  ((present &&
						    present[HTML_IMG_ISOBJECT]) ?
						    "(OBJECT)" :
						    VERBOSE_IMG(value, HTML_IMG_SRC, "[INLINE]"))));
d3132 1
a3132 1
				      (temp = MakeNewMapValue(value,"USEMAP"))));
d3138 1
a3138 1
				      (temp = MakeNewMapValue(value,"ISMAP"))));
d3144 2
a3145 1
				      VERBOSE_IMG(value, HTML_IMG_SRC, "[LINK]")));
d3150 5
a3154 4
			  ((present &&
			    present[HTML_IMG_ISOBJECT]) ?
					     "(OBJECT)" :
					     VERBOSE_IMG(value, HTML_IMG_SRC, "[INLINE]"))));
d3156 1
a3156 2
		StrAllocCopy(alt_string, (title ?
					  title : ""));
d3159 1
a3159 1
	    StrAllocCopy(alt_string, (temp = MakeNewMapValue(value,"USEMAP")));
d3164 3
a3166 3
		    map_href ? 1 : 0,
		    (dest_ismap == TRUE) ? 1 : 0,
		    me->inA, me->inP));
d3169 1
a3169 1
	 *  Check for an ID attribute. - FM
d3172 1
a3172 1
	    value[HTML_IMG_ID] && *value[HTML_IMG_ID]) {
d3181 1
a3181 1
	 *  Create links to the SRC for all images, if desired. - FM
d3185 1
a3185 1
	    value[HTML_IMG_SRC] && *value[HTML_IMG_SRC]) {
d3190 2
a3191 2
	     *	If it's an ISMAP and/or USEMAP, or graphic for an
	     *	anchor, end that anchor and start one for the SRC. - FM
d3195 2
a3196 2
		 *  If we have a USEMAP, end this anchor and
		 *  start a new one for the client-side MAP. - FM
d3202 2
a3203 1
			HTML_put_string(me, (temp = MakeNewMapValue(value,"ISMAP")));
d3219 4
a3222 5
			if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3227 4
a3230 5
		    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				map_href,		/* Addresss */
				INTERN_LT);		/* Type */
d3232 2
a3233 3
			if ((dest = HTAnchor_parent(
				HTAnchor_followLink(me->CurrentA)
						  )) != NULL) {
d3246 1
a3246 1
		    HTML_put_character(me, ' ');/* space char may be ignored */
d3261 3
a3263 3
		   ((map_href || dest_ismap) ?
				   "(IMAGE)" : "(OBJECT)") :
				   VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3265 4
a3268 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3274 1
a3274 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3277 4
a3280 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3285 4
a3288 5
		me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				map_href,		/* Addresss */
				INTERN_LT);		/* Type */
d3290 2
a3291 3
		    if ((dest = HTAnchor_parent(
				HTAnchor_followLink(me->CurrentA)
					      )) != NULL) {
d3314 2
a3315 2
						 "(IMAGE)" :
						 VERBOSE_IMG(value, HTML_IMG_SRC, "[IMAGE]")));
d3317 1
a3317 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3320 4
a3323 5
		    if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3331 1
a3331 1
	     *	Create the link to the SRC. - FM
d3333 4
a3336 5
	    me->CurrentA = HTAnchor_findChildAndLink(
			me->node_anchor,		/* Parent */
			NULL,				/* Tag */
			href,				/* Addresss */
			(HTLinkType*)0);		/* Type */
d3349 1
a3349 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3352 1
a3352 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3359 2
a3360 2
		 *  We're in an anchor and have a USEMAP, so end the anchor
		 *  and start a new one for the client-side MAP. - FM
d3363 1
a3363 1
		    HTML_put_character(me, ' ');/* space char may be ignored */
d3365 1
a3365 1
		    HTML_put_string(me, (temp = MakeNewMapValue(value,"ISMAP")));
d3368 1
a3368 1
		    HTML_put_character(me, ' ');/* space char may be ignored */
d3385 4
a3388 5
	    me->CurrentA = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				NULL,			/* Tag */
				map_href,		/* Addresss */
				INTERN_LT);		/* Type */
d3390 2
a3391 3
		if ((dest = HTAnchor_parent(
				HTAnchor_followLink(me->CurrentA)
					  )) != NULL) {
d3414 2
a3415 3
	     *	Just put in the ALT or pseudo-ALT string
	     *	for the current anchor or inline, with an
	     *	ID link if indicated. - FM
d3417 1
a3417 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3420 4
a3423 5
		if ((ID_A = HTAnchor_findChildAndLink(
				  me->node_anchor,	/* Parent */
				  id_string,		/* Tag */
				  NULL,			/* Addresss */
				  (HTLinkType*)0)) != NULL) {	/* Type */
d3429 1
a3429 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3443 1
a3443 1
	 *  Load id_string if we have a NAME or ID. - FM
d3446 1
a3446 1
	    value[HTML_MAP_NAME] && *value[HTML_MAP_NAME]) {
d3449 1
a3449 1
		   value[HTML_MAP_ID] && *value[HTML_MAP_ID]) {
d3460 4
a3463 5
	 *  Generate a target anchor in this place in the containing
	 *  document.  MAP can now contain block markup, if it doesn't
	 *  contain any AREAs (or A anchors with COORDS converted to AREAs)
	 *  the current location can be used as a fallback for following
	 *  a USEMAP link. - kw
d3465 2
a3466 2
	 if (!LYMapsOnly)
	     LYHandleID(me, id_string);
d3469 1
a3469 1
	 *  Load map_address. - FM
d3473 5
a3477 6
	     *	The MAP must be in the current stream, even if it
	     *	had a BASE tag, so we'll use its address here, but
	     *	still use the BASE, if present, when resolving the
	     *	AREA elements in it's content, unless the AREA's
	     *	HREF is a lone fragment and LYSeekFragAREAinCur is
	     *	set. - FM && KW
d3486 1
a3486 1
		value[HTML_MAP_TITLE] && *value[HTML_MAP_TITLE] != '\0') {
d3503 1
a3503 1
	    value[HTML_AREA_HREF] && *value[HTML_AREA_HREF]) {
d3505 1
a3505 1
	     *	Resolve the HREF. - FM
d3508 1
a3508 1
	    CHECK_FOR_INTERN(intern_flag,href);
d3512 9
a3520 9
	     *	Check whether a BASE tag is in effect, and use it
	     *	for resolving, even though we used this stream's
	     *	address for locating the MAP itself, unless the
	     *	HREF is a lone fragment and LYSeekFragAREAinCur
	     *	is set. - FM
	     */
	    Base = ((me->inBASE && *href != '\0') &&
			!(*href == '#' && LYSeekFragAREAinCur == TRUE)) ?
				me->base_href : me->node_anchor->address;
d3524 1
a3524 1
	     *	Check for an ALT. - FM
d3527 1
a3527 1
		value[HTML_AREA_ALT] && *value[HTML_AREA_ALT]) {
d3530 1
a3530 1
		value[HTML_AREA_TITLE] && *value[HTML_AREA_TITLE]) {
d3532 1
a3532 1
		 *  Use the TITLE as an ALT. - FM
d3541 1
a3541 1
		 *  Make sure it's not just space(s). - FM
d3550 1
a3550 1
		 *  Use the HREF as an ALT. - FM
d3564 2
a3565 3
	 *  We may need to look at this someday to deal with
	 *  MAPs, OBJECTs or APPLETs optimally, but just ignore
	 *  it for now. - FM
d3572 2
a3573 2
	 *  We may need to look at this someday to deal with
	 *  OBJECTs optimally, but just ignore it for now. - FM
d3580 2
a3581 2
	 *  We may need to look at this someday to deal with
	 *  APPLETs optimally, but just ignore it for now. - FM
d3604 2
a3605 3
	     *	This is an outer OBJECT start tag,
	     *	i.e., not a nested OBJECT, so save
	     *	it's relevant attributes. - FM
d3615 1
a3615 1
		    value[HTML_OBJECT_USEMAP] && *value[HTML_OBJECT_USEMAP]) {
d3623 1
a3623 1
		    value[HTML_OBJECT_ID] && *value[HTML_OBJECT_ID]) {
d3631 1
a3631 1
		    value[HTML_OBJECT_TITLE] && *value[HTML_OBJECT_TITLE]) {
d3641 1
a3641 1
		    value[HTML_OBJECT_DATA] && *value[HTML_OBJECT_DATA]) {
d3649 1
a3649 1
		    value[HTML_OBJECT_TYPE] && *value[HTML_OBJECT_TYPE]) {
d3659 1
a3659 2
		    value[HTML_OBJECT_CLASSID] &&
		    *value[HTML_OBJECT_CLASSID]) {
d3670 1
a3670 2
		    value[HTML_OBJECT_CODEBASE] &&
		    *value[HTML_OBJECT_CODEBASE]) {
d3679 1
a3679 2
		    value[HTML_OBJECT_CODETYPE] &&
		    *value[HTML_OBJECT_CODETYPE]) {
d3682 3
a3684 1
		    TRANSLATE_AND_UNESCAPE_ENTITIES(&me->object_codetype, TRUE, FALSE);
d3692 1
a3692 1
		    value[HTML_OBJECT_NAME] && *value[HTML_OBJECT_NAME]) {
d3703 11
a3713 11
	     *  If we can determine now that we are not going to do anything
	     *  special to the OBJECT element's SGML contents, like skipping
	     *  it completely or collecting it up in order to add something
	     *  after it, then generate any output that should be emitted in the
	     *  place of the OBJECT start tag NOW, then don't initialize special
	     *  handling but return, letting our SGML parser know that further
	     *  content is to be parsed normally not literally.  We could defer
	     *  this until we have collected the contents and then recycle the
	     *  contents (as was previously always done), but that has a higher
	     *  chance of completely losing content in case of nesting errors
	     *  in the input, incomplete transmissions, etc. - kw
d3727 3
a3729 2
				       me->object_id ? value[HTML_OBJECT_ID]
					: NULL,
d3738 1
a3738 1
			HTML_end_element(me,HTML_A,NULL);
d3744 7
a3750 7
		 *  We do NOT want the HTML_put_* functions that are going
		 *  to be called for the OBJECT's character content to
		 *  add to the chunk, so we don't push on the stack.
		 *  Instead we keep a counter for open OBJECT tags that
		 *  are treated this way, so HTML_end_element can skip
		 *  handling the corresponding end tag that is going to
		 *  arrive unexpectedly as far as our stack is concerned.
d3755 1
a3755 1
		    ElementNumber = HTML_OBJECT_M;
d3763 7
a3769 5
		    1,
		    1 || me->object_ismap,
		    me->object_id,
		    (me->object_data && !me->object_classid) ? value[HTML_OBJECT_DATA] : NULL,
		    NO, TRUE, &intern_flag);
d3777 1
a3777 1
		 *	Set flag that we are accumulating OBJECT content. - FM
d3787 1
a3787 1
	    value[HTML_OVERLAY_SRC] && *value[HTML_OVERLAY_SRC]) {
d3796 4
a3799 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d3821 1
a3821 1
	HTML_put_character(me, ' ');  /* space char may be ignored */
d3823 1
a3823 1
	 *  Load id_string if we have an ID or NAME. - FM
d3826 1
a3826 1
	    value[HTML_APPLET_ID] && *value[HTML_APPLET_ID]) {
d3829 1
a3829 1
		   value[HTML_APPLET_NAME] && *value[HTML_APPLET_NAME]) {
d3840 2
a3841 2
	 *  If there's an ALT string, use it, unless the ALT string
	 *  is zero-length and we are making all sources links. - FM
d3848 1
a3848 1
						   me->UsePlainSpace, me->HiddenValue);
d3850 2
a3851 2
	     *	If it's all spaces and we are making sources links,
	     *	treat it as zero-length. - FM
d3869 1
a3869 1
	 *  If we're making all sources links, get the source. - FM
d3872 2
a3873 2
	    value[HTML_APPLET_CODE] && *value[HTML_APPLET_CODE]) {
	    char * base = NULL;
d3876 2
a3877 2
		    ? me->base_href
		    : me->node_anchor->address;
d3879 1
a3879 1
	     *	Check for a CODEBASE attribute. - FM
d3882 1
a3882 1
		value[HTML_APPLET_CODEBASE] && *value[HTML_APPLET_CODEBASE]) {
d3887 1
a3887 1
		 *  Force it to be a directory. - FM
d3909 4
a3912 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d3925 1
a3925 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3931 1
a3931 1
	     *	Just put up the ALT string, if non-zero. - FM
d3934 1
a3934 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3943 1
a3943 1
	 *  If we're making all sources links, get the source. - FM
d3946 1
a3946 1
	    value[HTML_BGSOUND_SRC] && *value[HTML_BGSOUND_SRC]) {
d3960 1
a3960 1
		HTML_put_character(me, ' ');  /* space char may be ignored */
d3963 4
a3966 5
	    me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d3979 1
a3979 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3987 1
a3987 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d3989 1
a3989 1
	 *  Load id_string if we have an ID or NAME. - FM
d3992 1
a3992 1
	    value[HTML_EMBED_ID] && *value[HTML_EMBED_ID]) {
d3995 1
a3995 1
		   value[HTML_EMBED_NAME] && *value[HTML_EMBED_NAME]) {
d4007 2
a4008 2
	 *  If there's an ALT string, use it, unless the ALT string
	 *  is zero-length and we are making all sources links. - FM
d4015 1
a4015 1
						   me->UsePlainSpace, me->HiddenValue);
d4017 2
a4018 2
	     *	If it's all spaces and we are making sources links,
	     *	treat it as zero-length. - FM
d4035 1
a4035 1
	 *  If we're making all sources links, get the source. - FM
d4038 1
a4038 1
	    value[HTML_EMBED_SRC] && *value[HTML_EMBED_SRC]) {
d4048 4
a4051 5
		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d4072 1
a4072 1
	     *	Just put up the ALT string, if non-zero. - FM
d4075 1
a4075 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d4097 2
a4098 2
	     *	Assume all text in the FIG container is intended
	     *	to be paragraphed. - FM
d4104 2
a4105 2
	     *	Assume all text in the APPLET container is intended
	     *	to be paragraphed. - FM
d4129 2
a4130 2
	     *	Assume all text in the FIG container is intended
	     *	to be paragraphed. - FM
d4136 2
a4137 2
	     *	Assume all text in the APPLET container is intended
	     *	to be paragraphed. - FM
d4148 4
a4151 4
	    char * action = NULL;
	    char * method = NULL;
	    char * enctype = NULL;
	    CONST char * accept_cs = NULL;
d4153 1
a4153 1
	    HTChildAnchor * source;
d4157 5
a4161 6
	     *	FORM may have been declared SGML_EMPTY in HTMLDTD.c, and
	     *	SGML_character() in SGML.c may check for a FORM end
	     *	tag to call HTML_end_element() directly (with a
	     *	check in that to bypass decrementing of the HTML
	     *	parser's stack), so if we have an open FORM, close
	     *	that one now. - FM
d4170 1
a4170 1
	     *	Set to know we are in a new form.
d4176 3
a4178 2
		accept_cs = value[HTML_FORM_ACCEPT_CHARSET] ?
			    value[HTML_FORM_ACCEPT_CHARSET] : "UNKNOWN";
d4182 2
a4183 2
		    ? me->base_href
		    : me->node_anchor->address;
d4192 3
a4194 3
		 *  Check whether a base tag is in effect.  Note that
		 *  actions always are resolved w.r.t. to the base,
		 *  even if the action is empty. - FM
d4203 3
a4205 3
						   NULL,
						   action,
						   (HTLinkType*)0);
d4208 1
a4208 2
		 *  Memory leak fixed.
		 *  05-28-94 Lynx 2-3-1 Garrett Arch Blythe
d4210 2
a4211 1
		char* cp_freeme = HTAnchor_address(link_dest);
d4221 3
a4223 2
		StrAllocCopy(method, value[HTML_FORM_METHOD] ?
				     value[HTML_FORM_METHOD] : "GET");
d4226 1
a4226 1
		value[HTML_FORM_ENCTYPE] && *value[HTML_FORM_ENCTYPE]) {
d4233 2
a4234 2
		 *  Check for a TITLE attribute, and if none is present,
		 *  check for a SUBJECT attribute as a synonym. - FM
d4237 1
a4237 2
		    value[HTML_FORM_TITLE] &&
		    *value[HTML_FORM_TITLE] != '\0') {
d4240 1
a4240 2
			   value[HTML_FORM_SUBJECT] &&
			   *value[HTML_FORM_SUBJECT] != '\0') {
d4243 1
a4243 1
		if (title != NULL && *title != '\0') {
d4289 19
a4307 5
	    I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
	    I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
	    I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
	    I.type=NULL; I.value=NULL; I.width=NULL;
d4318 1
a4318 1
		 *  It's a button for submitting or resetting a form. - FM
d4323 1
a4323 1
		 *  Ugh, it's a button for a script. - FM
d4325 1
a4325 1
		HTML_put_string(me," [BUTTON] ");
d4330 1
a4330 1
	     *	Make sure we're in a form.
d4337 2
a4338 2
		 *  We'll process it, since the chances of a crash are
		 *  small, and we probably do have a form started. - FM
d4340 1
a4340 1
		break;
d4345 6
a4350 7
	     *	Before any input field, add a collapsible space if
	     *	we're not in a PRE block, to promote a wrap there
	     *	for any long values that would extend past the right
	     *	margin from our current position in the line.  If
	     *	we are in a PRE block, start a new line if the last
	     *	line already is within 6 characters of the wrap point
	     *	for PRE blocks. - FM
d4356 1
a4356 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcols - 7)) {
d4374 1
a4374 1
		value[HTML_BUTTON_VALUE] && *value[HTML_BUTTON_VALUE]) {
d4376 1
a4376 1
		 *  Convert any HTML entities or decimal escaping. - FM
a4377 2
		int len;

d4384 2
a4385 2
		 *  Convert any newlines or tabs to spaces,
		 *  and trim any lead or trailing spaces. - FM
d4387 1
a4387 6
		convert_to_spaces(I.value, FALSE);
		while (I.value && I.value[0] == ' ')
		    I.value++;
		len = strlen(I.value) - 1;
		while (len > 0 && I.value[len] == ' ')
		    I.value[len--] = '\0';
d4393 3
a4395 3
	    if (present && present[HTML_BUTTON_CLASS] && /* Not yet used. */
		value[HTML_BUTTON_CLASS] && *value[HTML_BUTTON_CLASS])
		I.class = value[HTML_BUTTON_CLASS];
d4398 1
a4398 1
		value[HTML_BUTTON_ID] && *value[HTML_BUTTON_ID]) {
d4403 2
a4404 2
	    if (present && present[HTML_BUTTON_LANG] && /* Not yet used. */
		value[HTML_BUTTON_LANG] && *value[HTML_BUTTON_LANG])
d4409 7
a4415 8
	     *	Submit and reset buttons have values which don't change,
	     *	so HText_beginInput() sets I.value to the string which
	     *	should be displayed, and we'll enter that instead of
	     *	underscore placeholders into the HText structure to
	     *	see it instead of underscores when dumping or printing.
	     *	We also won't worry about a wrap in PRE blocks, because
	     *	the line editor never is invoked for submit or reset
	     *	buttons. - LE & FM
d4418 1
a4418 1
		    !me->sp->style->freeFormat) {
d4420 6
a4425 7
		 *  We have a submit or reset button in a PRE block,
		 *  so output the entire value from the markup.  If
		 *  it extends to the right margin, it will wrap
		 *  there, and only the portion before that wrap will
		 *  be hightlighted on screen display (Yuk!) but we
		 *  may as well show the rest of the full value on
		 *  the next or more lines. - FM
d4431 13
a4443 16
		 *  The submit or reset button is not in a PRE block.
		 *  Note that if a wrap occurs before outputting the
		 *  entire value, the wrapped portion will not be
		 *  highlighted or clearly indicated as part of the
		 *  link for submission or reset (Yuk!).
		 *  We'll replace any spaces in the submit or reset
		 *  button value with nbsp, to promote a wrap at the
		 *  space we ensured would be present before the start
		 *  of the string, as when we use all underscores
		 *  instead of the INPUT's actual value, but we could
		 *  still get a wrap at the right margin, instead, if
		 *  the value is greater than a line width for the
		 *  current style.  Also, if chars somehow ended up
		 *  longer than the length of the actual value
		 *  (shouldn't have), we'll continue padding with nbsp
		 *  up to the length of chars. - FM
d4447 3
a4449 2
				       (char)(I.value[i] ==  ' ' ?
					      HT_NON_BREAK_SPACE : I.value[i]));
d4472 1
a4472 1
	    char* ImageSrc = NULL;
d4474 3
a4476 2
	    HTkcode kcode = 0;
	    HTkcode specified_kcode = 0;
d4478 19
a4496 5
	    I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
	    I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
	    I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
	    I.type=NULL; I.value=NULL; I.width=NULL;
d4504 6
a4509 7
	     *	Before any input field, add a collapsible space if
	     *	we're not in a PRE block, to promote a wrap there
	     *	for any long values that would extend past the right
	     *	margin from our current position in the line.  If
	     *	we are in a PRE block, start a new line if the last
	     *	line already is within 6 characters of the wrap point
	     *	for PRE blocks. - FM
d4515 1
a4515 1
	    } else if (HText_LastLineSize(me->text, FALSE) > (LYcols - 7)) {
d4521 1
a4521 1
	     *	Get the TYPE and make sure we can handle it. - FM
d4524 2
a4525 2
		value[HTML_INPUT_TYPE] && *value[HTML_INPUT_TYPE]) {
		char *not_impl = NULL;
d4531 2
a4532 1
		    if (present[HTML_INPUT_MIN])
d4534 2
a4535 1
		    if (present[HTML_INPUT_MAX])
d4538 1
a4538 1
		     *	Not yet implemented.
d4549 2
a4550 1
		    if (present[HTML_INPUT_ACCEPT])
d4564 1
a4564 1
		     *	Ugh, a button for a script.
d4566 1
a4566 1
		    HTML_put_string(me,"[BUTTON] ");
d4589 1
a4589 1
	     *	Check if we're in a form. - FM
d4596 2
a4597 2
		 *  We'll process it, since the chances of a crash are
		 *  small, and we probably do have a form started. - FM
d4599 1
a4599 1
		break;
d4606 1
a4606 1
	     *	Check for an unclosed TEXTAREA.
d4614 1
a4614 1
	     *	Check for an unclosed SELECT, try to close it if found.
d4625 1
a4625 1
	     *	Handle the INPUT as for a FORM. - FM
d4628 1
a4628 1
		  value[HTML_INPUT_NAME])) {
d4637 1
d4639 1
a4639 1
		 value[HTML_INPUT_ALT] && *value[HTML_INPUT_ALT] &&
d4642 1
a4642 1
		  value[HTML_INPUT_VALUE] && *value[HTML_INPUT_VALUE])) {
d4644 4
a4647 5
		 *  This is a TYPE="image" using an ALT rather than
		 *  VALUE attribute to indicate the link string for
		 *  text clients or GUIs with image loading off, so
		 *  set the flag to use that as if it were a VALUE
		 *  attribute. - FM
d4653 1
a4653 1
		value[HTML_INPUT_SRC] && *value[HTML_INPUT_SRC] &&
d4657 3
a4659 3
		present && present[HTML_INPUT_SRC] &&
		value[HTML_INPUT_SRC] && *value[HTML_INPUT_SRC] &&
		I.type && !strcasecomp(I.type, "image")) {
d4662 3
a4664 4
		 *  We have a TYPE="image" with a non-zero-length SRC
		 *  attribute and want clickable images.  Make the
		 *  SRC's value a link if it's still not zero-length
		 *  legitimizing it. - FM
d4673 4
a4676 5
		    me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					(HTLinkType*)0);	/* Type */
d4680 3
a4682 1
		    HTML_put_string(me, VERBOSE_IMG(value,HTML_INPUT_SRC,"[IMAGE]"));
d4692 3
a4694 1
	    CTRACE((tfp, "2.Ok, we're trying type=[%s] (present=%p)\n", NONNULL(I.type), present));
d4699 3
a4701 3
		(*value[HTML_INPUT_VALUE] ||
		 (I.type && (!strcasecomp(I.type, "checkbox") ||
			     !strcasecomp(I.type, "radio")))))) {
d4704 1
a4704 1
		 *  Convert any HTML entities or decimal escaping. - FM
a4709 1
		int len;
d4733 3
a4735 3
			     ((UseALTasVALUE == TRUE) ?
				value[HTML_INPUT_ALT] :
				value[HTML_INPUT_VALUE]));
d4740 7
a4746 7
		TRANSLATE_AND_UNESCAPE_ENTITIES6(
		    &I_value,
		    ATTR_CS_IN,
		    I.value_cs,
		    (BOOL)(me->UsePlainSpace && !me->HiddenValue),
		    me->UsePlainSpace,
		    me->HiddenValue);
d4750 2
a4751 2
		     *	Convert any newlines or tabs to spaces,
		     *	and trim any lead or trailing spaces. - FM
d4753 1
a4753 6
		    convert_to_spaces(I.value, FALSE);
		    while (I.value && I.value[0] == ' ')
			I.value++;
		    len = strlen(I.value) - 1;
		    while (len > 0 && I.value[len] == ' ')
			I.value[len--] = '\0';
a4756 1

d4767 4
a4770 4
		 *  We put up an [IMAGE] link and '-' for a TYPE="image"
		 *  and didn't get a VALUE or ALT string, so fake a
		 *  "Submit" value.  If we didn't put up a link, then
		 *  HText_beginInput() will use "[IMAGE]-Submit". - FM
d4774 1
a4774 1
	    } else if ( ImageSrc ) {
d4783 1
a4783 1
		value[HTML_INPUT_SIZE] && *value[HTML_INPUT_SIZE])
d4785 1
d4787 1
a4787 1
		value[HTML_INPUT_MAXLENGTH] && *value[HTML_INPUT_MAXLENGTH])
d4792 4
a4795 3
	    if (present && present[HTML_INPUT_ACCEPT_CHARSET]) { /* Not yet used. */
		I.accept_cs = value[HTML_INPUT_ACCEPT_CHARSET] ?
			      value[HTML_INPUT_ACCEPT_CHARSET] : "UNKNOWN";
d4797 2
a4798 2
	    if (present && present[HTML_INPUT_ALIGN] && /* Not yet used. */
		value[HTML_INPUT_ALIGN] && *value[HTML_INPUT_ALIGN])
d4800 5
a4804 5
	    if (present && present[HTML_INPUT_CLASS] && /* Not yet used. */
		value[HTML_INPUT_CLASS] && *value[HTML_INPUT_CLASS])
		I.class = value[HTML_INPUT_CLASS];
	    if (present && present[HTML_INPUT_ERROR] && /* Not yet used. */
		value[HTML_INPUT_ERROR] && *value[HTML_INPUT_ERROR])
d4806 2
a4807 2
	    if (present && present[HTML_INPUT_HEIGHT] && /* Not yet used. */
		value[HTML_INPUT_HEIGHT] && *value[HTML_INPUT_HEIGHT])
d4809 2
a4810 2
	    if (present && present[HTML_INPUT_WIDTH] && /* Not yet used. */
		value[HTML_INPUT_WIDTH] && *value[HTML_INPUT_WIDTH])
d4813 1
a4813 1
		value[HTML_INPUT_ID] && *value[HTML_INPUT_ID]) {
d4817 2
a4818 2
	    if (present && present[HTML_INPUT_LANG] && /* Not yet used. */
		value[HTML_INPUT_LANG] && *value[HTML_INPUT_LANG])
d4820 2
a4821 2
	    if (present && present[HTML_INPUT_MD] && /* Not yet used. */
		value[HTML_INPUT_MD] && *value[HTML_INPUT_MD])
d4825 12
a4836 12
#ifndef USE_FILE_UPLOAD
	    CTRACE((tfp, "I.%s have %d chars, or something\n", NONNULL(I.type), chars));
#endif
	    /*
	     *	Submit and reset buttons have values which don't change,
	     *	so HText_beginInput() sets I.value to the string which
	     *	should be displayed, and we'll enter that instead of
	     *	underscore placeholders into the HText structure to
	     *	see it instead of underscores when dumping or printing.
	     *	We also won't worry about a wrap in PRE blocks, because
	     *	the line editor never is invoked for submit or reset
	     *	buttons. - LE & FM
d4839 3
a4841 3
		(!strcasecomp(I.type,"submit") ||
		 !strcasecomp(I.type,"reset") ||
		 !strcasecomp(I.type,"image")))
d4847 2
a4848 3
		 *  Put a (_) placeholder, and one space
		 *  (collapsible) before the label that is
		 *  expected to follow. - FM
d4860 1
a4860 1
		!strcasecomp(I.type, "checkbox")) {
d4862 2
a4863 3
		 *  Put a [_] placeholder, and one space
		 *  (collapsible) before the label that is
		 *  expected to follow. - FM
d4879 12
a4890 14
		 *  This is not a submit or reset button, and we are
		 *  in a PRE block with a field intended to exceed 6
		 *  character widths.  The code inadequately handles
		 *  INPUT fields in PRE tags if wraps occur (at the
		 *  right margin) for the underscore placeholders.
		 *  We'll put up a minimum of 6 underscores, since we
		 *  should have wrapped artificially, above, if the
		 *  INPUT begins within 6 columns of the right margin,
		 *  and if any more would exceed the wrap column, we'll
		 *  ignore them.  Note that if we somehow get tripped
		 *  up and a wrap still does occur before all 6 of the
		 *  underscores are output, the wrapped ones won't be
		 *  treated as part of the editing window, nor be
		 *  highlighted when not editing (Yuk!). - FM
a4897 1
#ifndef USE_FILE_UPLOAD
a4898 1
#endif
d4901 2
a4902 3
		 *  This is not a submit or reset button,
		 *  so output the rest of the underscore
		 *  placeholders, if any more are needed. - FM
d4919 6
a4924 7
		     *	We have a submit or reset button in a PRE block,
		     *	so output the entire value from the markup.  If
		     *	it extends to the right margin, it will wrap
		     *	there, and only the portion before that wrap will
		     *	be hightlighted on screen display (Yuk!) but we
		     *	may as well show the rest of the full value on
		     *	the next or more lines. - FM
d4930 14
a4943 16
		     *	The submit or reset button is not in a PRE block.
		     *	Note that if a wrap occurs before outputting the
		     *	entire value, the wrapped portion will not be
		     *	highlighted or clearly indicated as part of the
		     *	link for submission or reset (Yuk!).
		     *	We'll replace any spaces in the submit or reset
		     *	button value with nbsp, to promote a wrap at the
		     *	space we ensured would be present before the start
		     *	of the string, as when we use all underscores
		     *	instead of the INPUT's actual value, but we could
		     *	still get a wrap at the right margin, instead, if
		     *	the value is greater than a line width for the
		     *	current style.	Also, if chars somehow ended up
		     *	longer than the length of the actual value
		     *	(shouldn't have), we'll continue padding with nbsp
		     *	up to the length of chars. - FM
d4947 1
a4947 1
					   (char)(I.value[i] ==  ' '
d4970 1
a4970 1
	 *  Make sure we're in a form.
d4974 2
a4975 1
		CTRACE((tfp, "Bad HTML: TEXTAREA start tag not within FORM tag\n"));
d4977 1
a4977 1
	     *	Too likely to cause a crash, so we'll ignore it. - FM
d4983 1
a4983 1
	 *  Set to know we are in a textarea.
d4988 1
a4988 1
	 *  Get ready for the value.
d5019 4
a5022 3
	    width = LYcols - 1 -
		    me->new_style->leftIndent - me->new_style->rightIndent;
	    if (dump_output_immediately) /* don't waste too much for this */
d5024 1
a5024 1
	    if (width > 1 && (width-1)*6 < MAX_LINE - 3 -
d5046 1
a5046 1
	    && value[HTML_TEXTAREA_ID] && *value[HTML_TEXTAREA_ID]) {
d5050 4
a5053 5
		(ID_A = HTAnchor_findChildAndLink(
				me->node_anchor,	/* Parent */
				id_string,		/* Tag */
				NULL,			/* Addresss */
				(HTLinkType*)0))) {	/* Type */
d5068 1
a5068 1
	 *  Check for an already open SELECT block. - FM
d5072 2
a5073 1
		CTRACE((tfp, "Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n"));
d5084 1
a5084 1
		       present, (CONST char **)value,
d5092 1
a5092 1
	     *	An option is a special case of an input field.
d5097 1
a5097 1
	     *	Make sure we're in a select tag.
d5101 2
a5102 1
		    CTRACE((tfp, "Bad HTML: OPTION tag not within SELECT tag\n"));
d5105 1
a5105 1
		 *  Too likely to cause a crash, so we'll ignore it. - FM
d5112 1
a5112 1
		 *  Finish the data off.
d5117 1
a5117 1
		 *  Finish the previous option @@@@@@@@@@
d5129 3
a5131 3
	     *	If it's not a multiple option list and select popups
	     *	are enabled, then don't use the checkbox/button method,
	     *	and don't put anything on the screen yet.
d5139 1
a5139 1
		     *	Start a newline before each option.
d5144 1
a5144 1
		     *	Add option list designation character.
d5151 1
a5151 1
		 *  Inititialize.
a5152 5
		I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
		I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
		I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
		I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
		I.type=NULL; I.value=NULL; I.width=NULL;
d5155 1
d5163 1
a5163 1
		    I.checked=YES;
d5168 1
a5168 1
		     *	Convert any HTML entities or decimal escaping. - FM
d5173 4
a5176 4
						       ATTR_CS_IN,
						       ATTR_CS_IN,
							NO,
						       me->UsePlainSpace, me->HiddenValue);
d5184 2
a5185 2
		   (present && present[HTML_OPTION_DISABLED]))
		    I.disabled=YES;
d5188 5
a5192 6
		    && value[HTML_OPTION_ID] && *value[HTML_OPTION_ID]) {
		    if ((ID_A = HTAnchor_findChildAndLink(
				    me->node_anchor,	   /* Parent */
				    value[HTML_OPTION_ID], /* Tag */
				    NULL,		   /* Addresss */
				    (HTLinkType*)0)) != NULL) {    /* Type */
d5203 2
a5204 3
		     *	Put a "[_]" placeholder, and one space
		     *	(collapsible) before the label that is
		     *	expected to follow. - FM
d5210 1
a5210 1
		    HText_setLastChar(me->text, ' ');  /* absorb white space */
d5214 2
a5215 3
		     *	Put a "(_)" placeholder, and one space
		     *	(collapsible) before the label that is
		     *	expected to follow. - FM
d5221 1
a5221 1
		    HText_setLastChar(me->text, ' ');  /* absorb white space */
d5227 1
a5227 1
	     *	Get ready for the next value.
d5242 1
a5242 1
		     *	Convert any HTML entities or decimal escaping. - FM
d5247 4
a5250 4
						       ATTR_CS_IN,
						       ATTR_CS_IN,
							NO,
						       me->UsePlainSpace, me->HiddenValue);
d5259 2
a5260 2
	     *	If this is a popup option, print its option
	     *	for use in selecting option by number. - LE
d5269 1
a5269 1
		    sprintf(marker,"(%d)", opnum);
d5282 3
a5284 4
	 *  Not fully implemented.  Just treat as a division
	 *  with respect to any ALIGN attribute, with
	 *  a default of HT_LEFT, or leave as a PRE
	 *  block if we are presently in one. - FM
d5286 2
a5287 3
	 *  Also notify simple table tracking code unless
	 *  in a preformatted section, or (currently) non-left
	 *  alignment.
d5289 3
a5291 4
	 *  If page author is using a TABLE within PRE, it's probably
	 *  formatted specifically to work well for Lynx without simple
	 *  table tracking code.  Cancel tracking, it would only make
	 *  things worse. - kw
d5296 1
a5296 1
	HText_cancelStbl(me->text);
d5316 1
a5316 1
	    "HTML: ****** Maximum nesting of %d divisions/tables exceeded!\n",
d5320 1
a5320 1
	    value[HTML_TABLE_ALIGN] && *value[HTML_TABLE_ALIGN]) {
d5327 1
a5327 1
				styles[HTML_DLEFT]->alignment;
d5333 1
a5333 1
					styles[HTML_DCENTER]->alignment;
d5366 3
a5368 4
	 *  Not fully implemented.  Just start a new row,
	 *  if needed, act on an ALIGN attribute if present,
	 *  and check for an ID link. - FM
	 *  Also notify simple table tracking code. - kw
d5380 1
a5380 1
	    HText_setLastChar(me->text, ' ');  /* absorb white space */
d5397 1
a5397 1
		me->sp->style->alignment = HT_LEFT;
d5430 1
a5430 1
	 *  Not fully implemented.  Just check for an ID link. - FM
d5460 1
a5460 1
	 *  Not fully implemented.  Just check for an ID link. - FM
d5473 1
d5489 1
a5489 1
			       (BOOL)(ElementNumber == HTML_COLGROUP));
d5507 2
a5508 2
	 *  Not fully implemented.  Just add a collapsible space and break. - FM
	 *  Also notify simple table tracking code. - kw
d5513 1
d5533 1
a5533 1
			      (BOOL)(ElementNumber == HTML_TH));
d5540 2
a5541 2
	 *  We're getting it as Literal text, which, until we can process
	 *  it, we'll display as is, within brackets to alert the user. - FM
d5550 1
a5550 1
    } /* end switch */
d5556 2
a5557 2
    "HTML:begin_element: internal call (level %d), leaving on stack - `%s'\n",
			me->skip_stack, NONNULL(me->sp->style->name)));
d5572 5
a5576 4
	CTRACE((tfp, "HTML:begin_element[%d]: adding style to stack - %s (%s)\n",
		     (int) STACKLEVEL(me),
		     NONNULL(me->new_style->name),
		     HTML_dtd.tags[ElementNumber].name));
d5582 1
a5582 1
		HTML_dtd.tags[ElementNumber].can_justify == FALSE)
a5585 1

d5596 1
a5596 2
    if (ReallyEmptyTagNum(element_number))
    {
d5613 15
a5627 17
**		-----------
**
**	When we end an element, the style must be returned to that
**	in effect before that element.	Note that anchors (etc?)
**	don't have an associated style, so that we must scan down the
**	stack for an element with a defined style. (In fact, the styles
**	should be linked to the whole stack not just the top one.)
**	TBL 921119
**
**	We don't turn on "CAREFUL" check because the parser produces
**	(internal code errors apart) good nesting.  The parser checks
**	incoming code errors, not this module.
*/
PRIVATE int HTML_end_element ARGS3(
	HTStructured *,		me,
	int,			element_number,
	char **,		include)
d5640 1
a5640 1
	    HTTag * tag = &HTML_dtd.tags[element_number];
d5642 1
a5642 1
	    int tag_charset=0;
d5644 4
a5647 2
	    psrc_nested_call=TRUE;
	    PSRCSTART(abracket); PUTS("</"); PSRCSTOP(abracket);
d5649 1
a5649 1
	    if (tagname_transform!=0)
d5652 1
a5652 1
		LYstrncpy(buf, tag->name, sizeof(buf)-1);
d5657 4
a5660 2
	    PSRCSTART(abracket); PUTC('>'); PSRCSTOP(abracket);
	    psrc_nested_call=FALSE;
d5663 1
a5663 1
	/*fall through*/
d5673 3
a5675 3
	       (me->sp == me->stack + MAX_NESTING - 1) ? "none" :
	       (me->sp->tag_number < 0) ? "*invalid tag*" :
	       (me->sp->tag_number >= HTML_ELEMENTS) ? "special tag" :
d5678 1
a5678 1
		/* panic */
d5683 2
a5684 2
     *	If we're seeking MAPs, skip everything that's
     *	not a MAP or AREA tag. - FM
d5694 2
a5695 2
     *	Pop state off stack if we didn't declare the element
     *	SGML_EMPTY in HTMLDTD.c. - FM & KW
d5714 2
a5715 3
	     *	Set the break flag if we're popping
	     *	a dummy HTML_LH substituted for an
	     *	HTML_H# encountered in a list.
d5725 3
a5727 2
		    (tfp, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
			  me->skip_stack, NONNULL(me->sp->style->name)));
d5734 1
a5734 1
		       me->sp[0].tag_number == HTML_FIG)) {
d5736 3
a5738 3
	     *	Ignore non-corresponding OBJECT tags that we
	     *	didn't push because the SGML parser was supposed
	     *  to go on parsing the contents non-literally. - kw
d5742 4
a5745 4
			   (int) STACKLEVEL(me),
			   "Special OBJECT handling", me->objects_mixed_open,
			   "leaving on stack",
			   NONNULL(me->sp->style->name)));
d5748 1
a5748 1
	    element_number != me->sp[0].tag_number) {
d5750 6
a5755 9
	     *	Ignore non-corresponding tags if we had
	     *	a stack overrun.  This is not a completely
	     *	fail-safe strategy for protection against
	     *	any seriously adverse consequences of a
	     *	stack overrun, and the rendering of the
	     *	document will not be as intended, but we
	     *	expect overruns to be rare, and this should
	     *	offer reasonable protection against crashes
	     *	if an overrun does occur. - FM
d5757 1
a5757 1
	    return HT_OK; /* let's pretend... */
d5759 1
a5759 1
	    me->sp[0].tag_number != HTML_SELECT) {
d5761 3
a5763 4
	     *	Ignore non-corresponding SELECT tags, since we
	     *	probably popped it and closed the SELECT block
	     *	to deal with markup which amounts to a nested
	     *	SELECT, or an out of order FORM end tag. - FM
d5767 12
a5778 12
	    HTML_dtd.tags[HTML_LH].contents == SGML_EMPTY &&
	    (me->sp[0].tag_number == HTML_UL ||
	     me->sp[0].tag_number == HTML_OL ||
	     me->sp[0].tag_number == HTML_MENU ||
	     me->sp[0].tag_number == HTML_DIR ||
	     me->sp[0].tag_number == HTML_LI) &&
	    (element_number == HTML_H1 ||
	     element_number == HTML_H2 ||
	     element_number == HTML_H3 ||
	     element_number == HTML_H4 ||
	     element_number == HTML_H6 ||
	     element_number == HTML_H6)) {
d5780 2
a5781 3
	     *	It's an H# for which we substituted
	     *	an HTML_LH, which we've declared as
	     *	SGML_EMPTY, so just return. - FM
d5793 3
a5795 3
		     *  It's an OBJECT for which we substituted a FIG,
		     *  so pop the FIG and pretend that's what we are
		     *  being called for. - kw
d5798 7
a5804 6
			    (tfp, "HTML:end_element[%d]: %s (level %d), %s - %s\n",
				  (int) STACKLEVEL(me),
				  "Special OBJECT->FIG handling",
				  me->objects_figged_open,
				  "treating as end FIG",
				  NONNULL(me->sp->style->name)));
d5811 4
a5814 3
		    (tfp, "HTML:end_element[%d]: Popped style off stack - %s\n",
			  (int) STACKLEVEL(me),
			  NONNULL(me->sp->style->name)));
d5817 1
a5817 1
  "Stack underflow error!  Tried to pop off more styles than exist in stack\n"));
d5822 2
a5823 2
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
d5825 1
a5825 1
	return HT_OK; /* let's pretend... */
d5829 1
a5829 1
     *	Check for unclosed TEXTAREA. - FM
d5841 1
a5841 1
     *	Handle the end tag. - FM
d5843 1
a5843 1
    switch(element_number) {
d5853 3
a5855 1
			((me->inSELECT || me->inTEXTAREA) && me->inA) ? ", " : "",
d5864 5
a5868 6
	    /*	If we are parsing the List Page, and have a BASE after
	     *	we are done with the HEAD element, propagate it back
	     *	to the node_anchor object.  The base should have been
	     *	inserted by showlist() to record what document the List
	     *	Page is about, and other functions may later look for it
	     *	in the anchor. - kw
d5881 7
a5887 9
	 *  Check if it's a bookmark file, and if so, and multiple
	 *  bookmark support is on, or it's off but this isn't the
	 *  default bookmark file (e.g., because it was on before,
	 *  and this is another bookmark file that has been retrieved
	 *  as a previous document), insert the current description
	 *  string and filepath for it.  We pass the strings back to
	 *  the SGML parser so that any 8 bit or multibyte/CJK
	 *  characters will be handled by the parser's state and
	 *  charset routines. - FM
d5889 1
a5889 1
	if (me->node_anchor->bookmark && *me->node_anchor->bookmark) {
d5891 1
a5891 1
		((bookmark_page && *bookmark_page) &&
d5905 1
a5905 1
					 MBM_A_subdescript[i] : gettext("(none)")));
d5913 3
a5915 2
				       *MBM_A_subbookmark[i]) ?
					 MBM_A_subbookmark[i] : gettext("(unknown)")));
d5929 2
a5930 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d5935 1
a5935 1
		      me->style_block.data));
d5941 2
a5942 2
	 *  We're getting it as Literal text, which, for now,
	 *  we'll just ignore. - FM
d5946 1
a5946 1
			    me->script.data));
d5958 3
a5960 1
			((me->inSELECT || me->inTEXTAREA) && me->inA) ? ", " : "",
d5966 1
a5966 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d5973 1
a5973 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d5981 4
a5984 5
		/*
		 *  Set flag to know that style has ended.
		 *  Fall through.
		i_prior_style = -1;
		 */
d6003 1
a6003 1
				me->DivisionAlignments[me->Division_Level];
d6016 1
a6016 1
    case HTML_H1:			/* header styles */
d6024 1
a6024 1
				me->DivisionAlignments[me->Division_Level];
d6051 3
a6053 3
		 (CONST BOOL*)0, (CONST char **)0,
		 include, 0,
		 FALSE);
d6060 1
a6060 1
    case HTML_B:			/* Physical character highlighting */
d6065 1
a6065 1
    case HTML_CITE:			/* Logical character highlighting */
d6069 2
a6070 2
	 *  Ignore any emphasis end tags if the
	 *  Underline_Level is not set. - FM
d6076 2
a6077 2
	 *  Adjust the Underline level counter, and
	 *  turn off underlining if appropriate. - FM
d6089 1
a6089 1
    case HTML_ABBREV:	/* Miscellaneous character containers */
d6136 4
a6139 5
	 *  Should check LANG and/or DIR attributes, and the
	 *  me->node_anchor->charset and/or yet to be added
	 *  structure elements, to determine whether we should
	 *  use chevrons, but for now we'll always use double-
	 *  or single-quotes. - FM
d6147 1
a6147 1
    case HTML_PRE:				/* Formatted text */
d6149 1
a6149 1
	 *  Set to know that we are no longer in a PRE block.
d6151 1
d6154 1
a6154 1
    case HTML_LISTING:				/* Literal text */
d6161 1
a6161 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6170 1
a6170 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6181 1
a6181 1
			    me->List_Nesting_Level : 11] = OL_VOID;
d6192 1
a6192 1
		    me->List_Nesting_Level));
d6195 1
a6195 1
	    in_DT = FALSE; /*close the term that was without definition. */
d6197 1
a6197 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6205 3
a6207 3
	 *  Should undo anything we did based on LANG and/or DIR
	 *  attributes, and the me->node_anchor->charset and/or
	 *  yet to be added structure elements. - FM
d6213 3
a6215 3
	 *  Should undo anything we did based on DIR (and/or LANG)
	 *  attributes, and the me->node_anchor->charset and/or
	 *  yet to be added structure elements. - FM
d6221 1
a6221 1
	 *  Ignore any spurious A end tags. - FM
d6226 1
a6226 1
	 *  Set to know that we are no longer in an anchor.
d6230 3
a6232 3
	if (hidden_link_marker && *hidden_link_marker &&
		HText_isAnchorBlank(me->text, me->CurrentANum) ) {
	    HText_appendText(me->text,hidden_link_marker);
d6253 2
a6254 2
	 *  We may need to look at this someday to deal with
	 *  OBJECTs optimally, but just ignore it for now. - FM
d6256 1
a6256 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6261 2
a6262 2
	 *  We may need to look at this someday to deal with
	 *  APPLETs optimally, but just ignore it for now. - FM
d6264 1
a6264 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6277 1
a6277 1
	 *  Finish the data off.
d6290 3
a6292 4
		 *  Look for nested OBJECTs.  This procedure
		 *  could get tripped up if invalid comments
		 *  are present in the content, or if an OBJECT
		 *  end tag is present in a quoted attribute. - FM
d6298 1
a6298 1
		    !IsNmChar(cp[6])) {
d6301 1
a6301 1
		    !IsNmChar(cp[7])) {
d6306 1
a6306 1
		    !IsNmChar(cp[8])) {
d6312 1
a6312 1
		    !IsNmChar(cp[4])) {
d6317 1
a6317 1
		    !IsNmChar(cp[5])) {
d6324 2
a6325 2
		 *  We had more end tags than start tags, so
		 *  we have bad HTML or otherwise misparsed. - FM
d6328 2
a6329 1
		    CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
d6344 11
a6354 11
		     *  We have nested OBJECT tags, and not yet all of the
		     *  end tags, but have a case where the content needs
		     *  to be parsed again (not dropped) and where we don't
		     *  want to output anything special at the point when we
		     *  *do* have accumulated all the end tags.  So recycle
		     *  the incomplete contents now, and signal the SGML
		     *  parser that it should not regard the current OBJECT
		     *  ended but should treat its contents as mixed.
		     *  Normally these cases would have already handled
		     *  in the real start_element call, so this block may
		     *  not be necessary. - kw
d6357 2
a6358 2
			   "HTML: Nested OBJECT tags.  Recycling incomplete contents",
			   me->object.data));
d6367 1
a6367 1
		    HTML_start_element(me, HTML_OBJECT, NULL,NULL,
d6372 6
a6377 6
		 *  We have nested OBJECT tags, and not yet all of the
		 *  end tags, and we want the end tags.  So restore an
		 *  end tag to the content, and signal to the SGML parser
		 *  that it should resume the accumulation of OBJECT content
		 *  (after calling back to start_element) in a way that
		 *  is equivalent to passing it a dummy start tag. - FM, kw
d6389 2
a6390 3
	     *	OBJECT start and end tags are fully matched,
	     *	assuming we weren't tripped up by comments
	     *	or quoted attributes. - FM
d6395 4
a6398 6
	     *	OBJECTs with DECLARE should be saved but
	     *	not instantiated, and if nested, can have
	     *	only other DECLAREd OBJECTs.  Until we have
	     *	code to handle these, we'll just create an
	     *	anchor for the ID, if present, and discard
	     *	the content (sigh 8-). - FM
d6401 1
a6401 1
		if (me->object_id && *me->object_id && !LYMapsOnly)
d6408 3
a6410 4
	     *	OBJECTs with NAME are for FORM submissions.
	     *	We'll just create an anchor for the ID, if
	     *	present, and discard the content until we
	     *	have code to handle these. (sigh 8-). - FM
d6413 1
a6413 1
		if (me->object_id && *me->object_id)
d6420 2
a6421 2
	     *	Deal with any nested OBJECTs by descending
	     *	to the inner-most OBJECT. - FM
d6427 3
a6429 3
		     *	Minumum requirements for the ad hoc parsing
		     *	to have succeeded are met.  We'll hope that
		     *	it did succeed. - FM
d6433 5
a6437 5
			 *  Well we don't need to do this any more,
			 *  nested objects should either not get here
			 *  any more at all or can be handled fine by
			 *  other code below.  Leave in place for now
			 *  as a special case for LYMapsOnly. - kw
d6457 1
a6457 1
			       (s > 1) ? "s" : ""));
d6463 2
a6464 1
			CTRACE((tfp, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n"));
d6470 1
a6470 1
	     *	If its content has SHAPES, convert it to FIG. - FM
d6472 3
a6474 3
	     *  This is now handled in our start_element without using
	     *  include if the SGML parser cooperates, so this block
	     *  may be unnecessary. - kw
d6503 2
a6504 2
	     *	If it has a USEMAP attribute and didn't have SHAPES,
	     *	convert it to IMG. - FM
d6514 1
a6514 1
		     *	Pass the ID. - FM
d6523 2
a6524 2
		     *	We have DATA with no CLASSID, so let's
		     *	hope it' equivalent to an SRC. - FM
d6532 1
a6532 2
		     *	Use the TITLE for both the MAP
		     *	and the IMGs ALT. - FM
d6541 1
a6541 1
		 *  Add the USEMAP, and an ISMAP if present. - FM
d6554 5
a6558 6
		 *  Add the content if it has <MAP, since that may
		 *  be the MAP this usemap points to.  But if we have
		 *  nested objects, try to eliminate portions that
		 *  cannot contribute to the quest for MAP.  This is
		 *  not perfect, we may get too much content; this seems
		 *  preferable over losing too much. - kw
d6563 2
a6564 1
			CTRACE((tfp, "HTML: MAP found, recycling object contents.\n"));
d6595 2
a6596 2
			   "HTML: MAP and nested OBJECT tags.  Recycling parts",
			   data));
d6604 1
a6604 1
	     *	Add an ID link if needed. - FM
d6606 1
a6606 1
	    if (me->object_id && *me->object_id && !LYMapsOnly)
d6610 1
a6610 1
	     *	Add the OBJECTs content if not empty. - FM
d6619 4
a6622 6
	     *	Create a link to the DATA, if desired, and
	     *	we can rule out that it involves scripting
	     *	code.  This a risky thing to do, but we can
	     *	toggle clickable_images mode off if it really
	     *	screws things up, and so we may as well give
	     *	it a try. - FM
d6632 5
a6636 6
		     *	We have a DATA value and no need for scripting
		     *	code, so close the current Anchor, if one is
		     *	open, and add an Anchor for this source.  If
		     *	we also have a TYPE value, check whether it's
		     *	an image or not, and set the link name
		     *	accordingly. - FM
d6657 1
a6657 1
	 *  Re-intialize all of the OBJECT elements. - FM
d6659 1
a6659 1
End_Object:
d6663 1
a6663 1
	    change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6670 1
a6670 1
	    HTML_put_character(me, ' ');  /* space char may be ignored */
d6675 1
a6675 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6682 1
a6682 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6690 1
a6690 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6696 3
a6698 4
	 *  Check if we had a FORM start tag, and issue a
	 *  message if not, but fall through to check for
	 *  an open SELECT and ensure that the FORM-related
	 *  globals in GridText.c are initialized. - FM
d6707 7
a6713 9
	 *  Check if we still have a SELECT element open.
	 *  FORM may have been declared SGML_EMPTY in HTMLDTD.c,
	 *  and in that case SGML_character() in SGML.c is
	 *  not able to ensure correct nesting; or it may have
	 *  failed to enforce valid nesting.  If a SELECT is open,
	 *  issue a message, then
	 *  call HTML_end_element() directly (with a
	 *  check in that to bypass decrementing of the HTML
	 *  parser's stack) to close the SELECT. - kw
d6717 2
a6718 1
		CTRACE((tfp, "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n"));
d6726 1
a6726 1
	 *  Set to know that we are no longer in an form.
d6732 4
a6735 5
	 *  If we are in a list and are on the first line
	 *  with no text following a bullet or number,
	 *  don't force a newline.  This could happen if
	 *  we were called from HTML_start_element() due
	 *  to a missing FORM end tag. - FM
d6744 1
a6744 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6750 1
a6750 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d6766 1
a6766 1
	     *	Make sure we had a textarea start tag.
d6775 1
a6775 1
	     *	Set to know that we are no longer in a textarea tag.
d6780 1
a6780 1
	     *	Initialize.
d6782 19
a6800 5
	    I.align=NULL; I.accept=NULL; I.checked=NO; I.class=NULL;
	    I.disabled=NO; I.error=NULL; I.height= NULL; I.id=NULL;
	    I.lang=NULL; I.max=NULL; I.maxlength=NULL; I.md=NULL;
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
	    I.type=NULL; I.value=NULL; I.width=NULL;
d6805 1
a6805 1
	     *	Before any input field add a space if necessary.
d6810 1
a6810 1
	     *	Add a return.
d6815 1
a6815 1
	     *	Finish the data off.
d6830 5
a6834 6
	     *	Transform the TEXTAREA content as needed, then parse
	     *	it into individual lines to be handled as a series
	     *  series of INPUT fields (ugh!).
	     *	Any raw 8-bit or multibyte characters already have been
	     *	handled in relation to the display character set
	     *	in SGML_character().
d6836 4
a6839 4
	     *  If TEXTAREA is handled as SGML_LITTERAL (the old way),
	     *	we need to SGML-unescape any character references and NCRs
	     *  here.  Otherwise this will already have happened in the
	     *  SGML.c parsing. - kw
d6851 10
a6860 13
		 *  This shouldn't have anything to do, normally, but
		 *  just in case...
		 *  There shouldn't be lynx special character codes in
		 *  the chunk ("DTD" flag Tgf_nolyspcl tells SGML.c not
		 *  to generate them).  If there were, we could set the
		 *  last parameter ('Back') below to YES, which would
		 *  take them out of the data.
		 *  The data may however contain non break space, soft
		 *  hyphen, or en space etc., in the me->UCLYhndl character
		 *  encoding.  If that's a problem, perhaps for the (line
		 *  or other) editor, setting 'Back' to YES should also
		 *  help to always convert them to plain spaces (or drop
		 *  them). - kw
d6863 5
a6867 5
						    me->UCLYhndl,
						    current_char_set,
						    NO,
						    me->UsePlainSpace, me->HiddenValue,
						    NO);
d6872 1
a6872 2
	     *	Trim any trailing newlines and
	     *	skip any lead newlines. - FM
d6884 1
a6884 2
	     *	Load the first text line, or set
	     *	up for all blank rows. - FM
d6900 2
a6901 2
	     *	Display at least the requested number
	     *	of text lines and/or blank rows. - FM
d6905 1
d6908 1
a6908 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6933 3
a6935 3
	     *	Check for more data lines than the rows attribute.
	     *	We add them to the display, because we support only
	     *	horizontal and not also vertical scrolling. - FM
d6939 1
d6942 1
a6942 1
			temp[j] = (char) (temp[j+1] ? ' ' : '\0');
d6980 1
a6980 1
	     *	Make sure we had a select start tag.
d6989 1
a6989 1
	     *	Set to know that we are no longer in a select tag.
d6994 1
a6994 1
	     *	Clear the disable attribute.
d6999 1
a6999 1
	     *	Make sure we're in a form.
d7006 1
a7006 1
		 *  Hopefully won't crash, so we'll ignore it. - kw
d7011 1
a7011 1
	     *	Finish the data off.
d7015 1
a7015 1
	     *	Finish the previous option.
d7030 4
a7033 4
		    /*
		     *	Start a newline after the last checkbox/button option.
		     */
		    LYEnsureSingleSpace(me);
d7036 2
a7037 2
		 *  Output popup box with the default option to screen,
		 *  but use non-breaking spaces for output.
d7044 3
a7046 3
		     *	The code inadequately handles OPTION fields in PRE tags.
		     *	We'll put up a minimum of 6 characters, and if any
		     *	more would exceed the wrap column, we'll ignore them.
d7050 1
a7050 1
			    HText_appendCharacter(me->text,HT_NON_BREAK_SPACE);
d7052 1
a7052 1
			    HText_appendCharacter(me->text,*ptr);
d7057 1
a7057 1
		for (; ptr && *ptr != '\0'; ptr++) {
d7059 1
a7059 1
			HText_appendCharacter(me->text,HT_NON_BREAK_SPACE);
d7061 3
a7063 2
			HTkcode kcode = 0;
			HTkcode specified_kcode = 0;
d7070 1
a7070 1
			HText_appendCharacter(me->text,*ptr);
d7078 1
a7078 1
		 *  Add end option character.
d7106 1
a7106 1
	me->inTABLE = FALSE;
d7115 1
a7115 1
				me->DivisionAlignments[me->Division_Level];
d7138 1
a7138 1
	    HText_setLastChar(me->text, ' ');  /* absorb next white space */
d7169 2
a7170 2
	 *  We're getting it as Literal text, which, until we can process
	 *  it, we'll display as is, within brackets to alert the user. - FM
d7192 1
a7192 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d7195 1
a7195 1
    } /* switch */
d7198 2
a7199 2
	    if (reached_awaited_stacked_elt)
		wait_for_this_stacked_elt=-1;
a7206 1

d7208 1
a7208 1
    if (!skip_stack_requested) { /*don't emit stylechanges if skipped stack element - VH*/
d7216 1
a7216 2
	if (!ReallyEmptyTagNum(element_number))
	{
d7218 3
a7220 2
		    (tfp, "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",
			  HTML_dtd.tags[element_number].name));
d7229 2
a7230 2
**		------------------
*/
d7233 1
a7233 1
PUBLIC int HTML_put_entity ARGS2(HTStructured *, me, int, entity_number)
d7245 11
a7255 11
**	-------------------
**
**	If the document is empty, the text object will not yet exist.
**	So we could in fact abandon creating the document and return
**	an error code.	In fact an empty document is an important type
**	of document, so we don't.
**
**	If non-interactive, everything is freed off.   No: crashes -listrefs
**	Otherwise, the interactive object is left.
*/
PRIVATE void HTML_free ARGS1(HTStructured *, me)
d7261 3
a7263 4
	 *  We only handled MAP, AREA and BASE tags, and didn't
	 *  create an HText structure for the document nor want
	 *  one now, so just make sure we free anything that might
	 *  have been allocated. - FM
d7278 6
a7283 7
	 *  Emphasis containers, A, FONT, and FORM may be declared
	 *  SGML_EMPTY in HTMLDTD.c, and SGML_character() in SGML.c
	 *  may check for their end tags to call HTML_end_element()
	 *  directly (with a check in that to bypass decrementing
	 *  of the HTML parser's stack).  So if we still have the
	 *  emphasis (Underline) on, or any open A, FONT, or FORM
	 *  containers, turn it off or close them now. - FM & kw
d7285 5
a7289 6
	 *  IF those tags are not declared SGML_EMPTY, but we let
	 *  the SGML.c parser take care of correctly stacked ordering,
	 *  and of correct wind-down on end-of-stream (in SGML_free
	 *  SGML_abort),
	 *  THEN these and other checks here in HTML.c should not be
	 *  necessary.	Still it can't hurt to include them. - kw
d7312 3
a7314 3
	     *	If we still have data in the me->option chunk after
	     *	forcing a close of a still-open form, something must
	     *	have gone very wrong. - kw
d7321 2
a7322 2
	     *	Output the left-over data as text, maybe it was invalid
	     *	markup meant to be shown somewhere. - kw
d7325 1
a7325 1
			me->option.data));
d7331 3
a7333 3
	     *	If we still have data in the me->textarea chunk after
	     *	forcing a close of a still-open form, something must
	     *	have gone very wrong. - kw
d7340 2
a7341 2
	     *	Output the left-over data as text, maybe it was invalid
	     *	markup meant to be shown somewhere. - kw
d7344 1
a7344 1
			me->textarea.data));
d7349 3
a7351 3
	 *  If we're interactive and have hidden links but no visible
	 *  links, add a message informing the user about this and
	 *  suggesting use of the 'l'ist command. - FM
d7360 1
a7360 1
		gettext("Document has only hidden links.  Use the 'l'ist command."));
d7372 1
a7372 1
	 *  Now call the cleanup function. - FM
d7378 2
a7379 3
	 *  If we still have data in the me->option chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7387 1
a7387 1
			 me->option.data));
d7393 3
a7395 3
	 *  If we still have data in the me->textarea chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7403 1
a7403 1
			 me->textarea.data));
d7409 1
a7409 1
	(*me->targetClass._free)(me->target);
d7419 1
a7419 1
	} else	{
d7431 1
a7431 1
PRIVATE void HTML_abort ARGS2(HTStructured *, me, HTError, e)
d7437 2
a7438 2
	 *  If we have emphasis on, or open A, FONT, or FORM
	 *  containers, turn it off or close them now. - FM
d7459 1
a7459 1
	 *  Now call the cleanup function. - FM
d7466 2
a7467 3
	 *  If we still have data in the me->option chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7470 2
a7471 1
	    CTRACE((tfp, "HTML_abort: SELECT or OPTION not ended properly *****\n"));
d7474 1
a7474 1
			 me->option.data));
d7480 3
a7482 3
	 *  If we still have data in the me->textarea chunk after
	 *  forcing a close of a still-open form, something must
	 *  have gone very wrong. - kw
d7488 1
a7488 1
			 me->textarea.data));
d7494 1
a7494 1
	(*me->targetClass._abort)(me->target, e);
d7504 1
a7504 1
	} else	{
d7521 3
a7523 3
**	---------------------------
*/
PRIVATE void get_styles NOARGS
d7525 3
a7527 2
    HTStyle** st = NULL;
    styleSheet = DefaultStyle(&st);  /* sets st[] array */
d7529 1
a7529 1
    default_style =		st[ST_Normal];
d7531 22
a7552 22
    styles[HTML_H1] =		st[ST_Heading1];
    styles[HTML_H2] =		st[ST_Heading2];
    styles[HTML_H3] =		st[ST_Heading3];
    styles[HTML_H4] =		st[ST_Heading4];
    styles[HTML_H5] =		st[ST_Heading5];
    styles[HTML_H6] =		st[ST_Heading6];
    styles[HTML_HCENTER] =	st[ST_HeadingCenter];
    styles[HTML_HLEFT] =	st[ST_HeadingLeft];
    styles[HTML_HRIGHT] =	st[ST_HeadingRight];

    styles[HTML_DCENTER] =	st[ST_DivCenter];
    styles[HTML_DLEFT] =	st[ST_DivLeft];
    styles[HTML_DRIGHT] =	st[ST_DivRight];

    styles[HTML_DL] =		st[ST_Glossary];
	/* nested list styles */
    styles[HTML_DL1] =		st[ST_Glossary1];
    styles[HTML_DL2] =		st[ST_Glossary2];
    styles[HTML_DL3] =		st[ST_Glossary3];
    styles[HTML_DL4] =		st[ST_Glossary4];
    styles[HTML_DL5] =		st[ST_Glossary5];
    styles[HTML_DL6] =		st[ST_Glossary6];
d7555 8
a7562 8
    styles[HTML_OL] =		st[ST_List];
	/* nested list styles */
    styles[HTML_OL1] =		st[ST_List1];
    styles[HTML_OL2] =		st[ST_List2];
    styles[HTML_OL3] =		st[ST_List3];
    styles[HTML_OL4] =		st[ST_List4];
    styles[HTML_OL5] =		st[ST_List5];
    styles[HTML_OL6] =		st[ST_List6];
d7565 24
a7588 24
    styles[HTML_DIR] =		st[ST_Menu];
	/* nested list styles */
    styles[HTML_MENU1] =	st[ST_Menu1];
    styles[HTML_MENU2] =	st[ST_Menu2];
    styles[HTML_MENU3] =	st[ST_Menu3];
    styles[HTML_MENU4] =	st[ST_Menu4];
    styles[HTML_MENU5] =	st[ST_Menu5];
    styles[HTML_MENU6] =	st[ST_Menu6];

    styles[HTML_DLC] =		st[ST_GlossaryCompact];
	/* nested list styles */
    styles[HTML_DLC1] =		st[ST_GlossaryCompact1];
    styles[HTML_DLC2] =		st[ST_GlossaryCompact2];
    styles[HTML_DLC3] =		st[ST_GlossaryCompact3];
    styles[HTML_DLC4] =		st[ST_GlossaryCompact4];
    styles[HTML_DLC5] =		st[ST_GlossaryCompact5];
    styles[HTML_DLC6] =		st[ST_GlossaryCompact6];

    styles[HTML_ADDRESS] =	st[ST_Address];
    styles[HTML_BANNER] =	st[ST_Banner];
    styles[HTML_BLOCKQUOTE] =	st[ST_Blockquote];
    styles[HTML_BQ] =		st[ST_Bq];
    styles[HTML_FN] =		st[ST_Footnote];
    styles[HTML_NOTE] =		st[ST_Note];
d7590 3
a7592 3
    styles[HTML_XMP] =		st[ST_Example];
    styles[HTML_PRE] =		st[ST_Preformatted];
    styles[HTML_LISTING] =	st[ST_Listing];
d7599 1
a7599 1
PUBLIC  HTStyle *LYstyles ARGS1(int, style_number)
d7610 3
a7612 3
**	-----------------------
*/
PUBLIC CONST HTStructuredClass HTMLPresentation = /* As opposed to print etc */
d7614 6
a7619 6
	"Lynx_HTML_Handler",
	HTML_free,
	HTML_abort,
	HTML_put_character,	HTML_put_string,  HTML_write,
	HTML_start_element,	HTML_end_element,
	HTML_put_entity
d7623 8
a7630 9
**		--------------------------
**
**	The structured stream can generate either presentation,
**	or plain text, or HTML.
*/
PUBLIC HTStructured* HTML_new ARGS3(
	HTParentAnchor *,	anchor,
	HTFormat,		format_out,
	HTStream*,		stream)
d7633 3
a7635 1
    HTStructured * me;
d7638 3
a7640 2
	HTStream * intermediate = HTStreamStack(WWW_HTML, format_out,
						stream, anchor);
d7645 1
a7645 1
	exit_immediately (EXIT_FAILURE);
d7713 2
a7714 2
    me->sp->tag_number = -1;				/* INVALID */
    me->sp->style = default_style;			/* INVALID */
d7727 1
a7727 1
     *	Used for nested lists. - FM
d7729 4
a7732 4
    me->List_Nesting_Level = -1; /* counter for list nesting level */
    LYZero_OL_Counter(me);	 /* Initializes OL_Counter[] and OL_Type[] */
    me->Last_OL_Count = 0;	 /* last count in ordered lists */
    me->Last_OL_Type = '1';	 /* last type in ordered lists */
d7773 5
a7777 5
    **	Create a chartrans stage info structure for the anchor,
    **	if it does not exist already (in which case the default
    **	MIME stage info will be loaded as well), and load the
    **	HTML stage info into me->UCI and me->UCLYhndl. - FM
    */
d7782 3
a7784 4
    **	Load the existing or default input charset info
    **	into the holding elements.  We'll believe what
    **	is indicated for UCT_STAGE_PARSER. - FM
    */
d7798 4
a7801 5
    **	Load the existing or default output charset info
    **	into the holding elements, UCT_STAGE_STRUCTURED
    **	should be the same as UCT_STAGE_TEXT at this point,
    **	but we could check, perhaps. - FM
    */
d7809 1
a7809 1
	me->targetClass = *stream->isa;			/* Copy pointers */
d7811 1
a7811 1
    return (HTStructured*) me;
d7817 5
a7821 5
 *  A flag set by a file write error.  Used for only generating an alert
 *  the first time such an error happens, since Lynx should still be usable
 *  if the temp space becomes full, and an alert each time a cache file
 *  cannot be written would be annoying.  Reset when  lynx.cfg is being
 *  reloaded (user may change SOURCE_CACHE setting). - kw
d7823 1
a7823 1
PUBLIC BOOLEAN source_cache_file_error = FALSE;
d7829 1
a7829 2
PRIVATE void CacheThru_do_free ARGS1(
	HTStream *,	me)
d7839 1
a7839 1
		(void *)me->anchor->source_cache_chunk));
d7849 2
d7854 3
a7856 1
		    me->filename, HTAnchor_address((HTAnchor *)me->anchor)));
d7870 1
a7870 1
	    me->chunk = NULL;
d7875 2
d7880 3
a7882 1
		(void *)me->chunk, HTAnchor_address((HTAnchor *)me->anchor)));
d7886 1
a7886 2
PRIVATE void CacheThru_free ARGS1(
	HTStream *,	me)
d7889 1
a7889 1
    (*me->actions->_free)(me->target);
d7893 1
a7893 3
PRIVATE void CacheThru_abort ARGS2(
	HTStream *,	me,
	HTError,	e)
d7905 3
a7907 2
	    CTRACE((tfp, "SourceCacheWriter: Removing active memory chunk %p\n",
		    (void *)me->chunk));
d7911 1
a7911 1
	me->status = HT_OK;	/*fake it*/
d7914 1
a7914 1
    (*me->actions->_abort)(me->target, e);
d7918 4
a7921 3
PRIVATE void CacheThru_put_character ARGS2(
	HTStream *,	me,
	char,		c_in)
d7927 2
a7928 2
	    HTChunkPutc(me->chunk, c_in);
	    if (me->chunk->allocated == 0)
d7932 1
a7932 1
    (*me->actions->put_character)(me->target, c_in);
d7935 4
a7938 3
PRIVATE void CacheThru_put_string ARGS2(
	HTStream *,	me,
	CONST char *,	str)
d7944 2
a7945 2
	    HTChunkPuts(me->chunk, str);
	    if (me->chunk->allocated == 0 && *str)
d7949 1
a7949 1
    (*me->actions->put_string)(me->target, str);
d7952 1
a7952 4
PRIVATE void CacheThru_write ARGS3(
	HTStream *,	me,
	CONST char *,	str,
	int,		l)
d7954 1
a7954 1
    if (me->status == HT_OK) {
d7960 2
a7961 2
	    HTChunkPutb(me->chunk, str, l);
	    if (me->chunk->allocated == 0 && l != 0)
d7965 1
a7965 1
    (*me->actions->put_block)(me->target, str, l);
d7968 1
a7968 1
PRIVATE CONST HTStreamClass PassThruCache =
d7978 2
a7979 3
PRIVATE HTStream* CacheThru_new ARGS2(
	HTParentAnchor *,	anchor,
	HTStream *,		target)
d7981 1
d7984 1
a7984 1
    HTProtocol *p = (HTProtocol *)anchor->protocol;
d7996 2
a7997 2
     && strcmp(p->name, "https") != 0) {
	CTRACE((tfp, "SourceCacheWriter: Protocol is \"%s\"; not caching\n", p->name));
d8004 2
d8020 1
d8022 2
a8023 1
	    CTRACE((tfp, "SourceCacheWriter: If successful, will replace source cache file %s\n",
d8034 3
a8036 2
	    CTRACE((tfp, "SourceCacheWriter: Cannot open source cache file for URL %s\n",
		   HTAnchor_address((HTAnchor *)anchor)));
d8038 1
d8044 5
a8048 2
	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in file %s\n",
		     HTAnchor_address((HTAnchor *)anchor), filename));
d8055 1
a8055 1
		    (void *)anchor->source_cache_chunk));
d8057 1
a8057 6

#ifdef SAVE_TIME_NOT_SPACE
	stream->chunk = HTChunkCreateMayFail(4096, 1);
#else
	stream->chunk = HTChunkCreateMayFail(128, 1);
#endif
d8061 5
a8065 3
	CTRACE((tfp, "SourceCacheWriter: Caching source for URL %s in memory chunk %p\n",
	       HTAnchor_address((HTAnchor *)anchor), (void *)stream->chunk));

d8075 10
a8084 11
**	----------------------------------
**
**	This will convert from HTML to presentation or plain text.
**
**	It is registered in HTInit.c, but never actually used by lynx.
**	- kw 1999-03-15
*/
PUBLIC HTStream* HTMLToPlain ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d8086 1
d8093 13
a8105 14
**	-----------------------------------------
**
**	This will preparse HTML and convert back to presentation or plain text.
**
**	It is registered in HTInit.c and used by lynx if invoked with
**	-preparsed.  The stream generated here will be fed with HTML text,
**	It feeds that to the SGML.c parser, which in turn feeds an HTMLGen.c
**	structured stream for regenerating flat text; the latter should
**	end up being handled as text/plain. - kw
*/
PUBLIC HTStream* HTMLParsedPresent ARGS3(
	HTPresentation *,	pres,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d8107 2
a8108 1
    HTStream * intermediate = sink;
d8111 4
a8114 4
	 *  Trick to prevent HTPlainPresent from translating again.
	 *  Temporarily change UCT_STAGE_PARSER setting in anchor
	 *  while the HTPlain stream is initialized, so that HTPlain
	 *  sees its input and output charsets as the same.  - kw
d8116 3
a8118 2
	int old_parser_cset = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_PARSER);
	int structured_cset = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_STRUCTURED);
d8120 1
a8120 1
	    structured_cset = HTAnchor_getUCLYhndl(anchor,UCT_STAGE_HTEXT);
d8126 4
a8129 4
		/*  same effect as
	    intermediate = HTPlainPresent(pres, anchor, NULL);
		    just written in a more general way:
		 */
d8133 1
a8133 1
		/*  this too should amount to calling HTPlainPresent: */
d8143 1
a8143 1
					UCT_SETBY_DEFAULT+1);
d8149 1
d8156 12
a8167 13
**	------------------------------
**
**	C code is like plain text but all non-preformatted code
**	is commented out.
**	This will convert from HTML to presentation or plain text.
**
**	It is registered in HTInit.c, but normally not used by lynx.
**	- kw 1999-03-15
*/
PUBLIC HTStream* HTMLToC ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink)
d8169 2
a8170 1
    HTStructured * html;
d8172 1
a8172 1
	(*sink->isa->put_string)(sink, "/* ");	/* Before even title */
d8177 2
a8178 1
	HTML_put_string(html,html->comment_start);
d8184 7
a8190 7
**	------------------
**
**	This will convert from HTML to presentation or plain text.
**
** (Comment from original libwww:)
**	Override this if you have a windows version
*/
d8192 3
a8194 4
PUBLIC HTStream* HTMLPresent ARGS3(
	HTPresentation *,	pres GCC_UNUSED,
	HTParentAnchor *,	anchor,
	HTStream *,		sink GCC_UNUSED)
d8196 1
d8205 17
a8221 17
**	------------------------------------------
**
**	The error message should be marked as an error so that
**	it can be reloaded later.
**	This implementation just throws up an error message
**	and leaves the document unloaded.
**	A smarter implementation would load an error document,
**	marking at such so that it is retried on reload.
**
** On entry,
**	sink	is a stream to the output device if any
**	number	is the HTTP error number
**	message is the human readable message.
**
** On exit,
**	returns a negative number to indicate lack of success in the load.
*/
d8226 2
a8227 4
PUBLIC int HTLoadError ARGS3(
	HTStream *,	sink GCC_UNUSED,
	int,		number,
	CONST char *,	message)
d8233 1
a8233 1
PRIVATE char * MakeNewTitle ARGS2(CONST char **, value, int, src_type)
d8248 1
a8248 1
#ifdef SH_EX	/* 1998/04/02 (Thu) 16:02:00 */
d8259 6
a8264 6
	  if (AS_casecomp(ptr, ".gif") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpg") == 0)
	    *ptr = '\0';
	  else if (AS_casecomp(ptr, ".jpeg") == 0)
	    *ptr = '\0';
d8274 1
a8274 1
PRIVATE char * MakeNewImageValue ARGS1(CONST char **, value)
d8280 3
a8282 1
    ptr = strrchr(value[HTML_INPUT_SRC], '/');
d8292 1
a8292 1
PRIVATE char * MakeNewMapValue ARGS2(CONST char **, value, CONST char*, mapstr)
d8298 3
a8300 3
    StrAllocCat(newtitle,mapstr); /* ISMAP or USEMAP */
    if ( verbose_img && value[HTML_IMG_SRC] && *value[HTML_IMG_SRC] ) {
	StrAllocCat(newtitle,":");
@


1.5
log
@Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>
@
text
@d2107 2
a2108 1
	    if (present[HTML_TAB_TO]) {
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d83 13
d4332 1
a4332 1
	    I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
d4518 1
a4518 1
	    I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
d4810 1
a4810 1
		I.size = value[HTML_INPUT_SIZE];
d5049 1
a5049 1
	    StrAllocCopy(me->textarea_cols, value[HTML_TEXTAREA_COLS]);
d5055 1
a5055 1
		width = HTMIN(width, 60);
d5058 1
a5058 1
		HTSprintf0(&me->textarea_cols, "%d", width);
d5060 1
a5060 1
		StrAllocCopy(me->textarea_cols, "60");
d5062 1
d5069 2
a5070 1
	    me->textarea_rows = 4;
d5187 1
a5187 1
		I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
d6836 1
a6836 1
	    I.min=NULL; I.name=NULL; I.size=NULL; I.src=NULL;
d6987 1
a6987 1
		for (chars = atoi(me->textarea_cols); chars > 0; chars--)
a7011 1
	    FREE(me->textarea_cols);
a7557 1
    FREE(me->textarea_cols);
d7737 1
a7737 1
    me->textarea_cols = NULL;
@


1.4.2.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@a82 13
#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4

#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)

#define LimitValue(name, value) \
 	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}

d4319 1
a4319 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d4505 1
a4505 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d4797 1
a4797 1
		I.size = atoi(value[HTML_INPUT_SIZE]);
d5036 1
a5036 1
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
d5042 1
a5042 1
		width = HTMIN(width, DFT_TEXTAREA_COLS);
d5045 1
a5045 1
		me->textarea_cols = width;
d5047 1
a5047 1
		me->textarea_cols = DFT_TEXTAREA_COLS;
a5048 1
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);
d5055 1
a5055 2
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);
d5172 1
a5172 1
		I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d6821 1
a6821 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d6972 1
a6972 1
		for (chars = me->textarea_cols; chars > 0; chars--)
d6997 1
d7544 1
d7724 1
a7724 1
    me->textarea_cols = 0;
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@a62 5
#define OPT_SCN 1
#define OMIT_SCN_KEEPING 0 /* whether to omit keeping of Style_className
    when lss support is on. 1 to increase performance. The value must
    correspond to one in LYCurses.c. Should be 0 if OPT_SCN=0 */

d71 1
a71 1
#ifdef SOURCE_CACHE
d75 1
a82 7
extern BOOL HTPassEightBitRaw;

extern BOOLEAN HT_Is_Gopher_URL;

/* from Curses.h */
extern int LYcols;

d85 1
a85 1
#ifdef SOURCE_CACHE
d148 1
a148 1
    while (*i) { *i=(char)tolower(*i); i++; }
d362 1
a362 1
	if (!strcmp(me->sp->style->name,"Preformatted")) {
d372 2
a373 2
	} else if (!strcmp(me->sp->style->name,"Listing") ||
		   !strcmp(me->sp->style->name,"Example")) {
a652 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d663 1
a663 1
#define INTERN_LT (HTLinkType *)(intern_flag ? LINK_INTERNAL : NULL)
a664 1
#else  /* !DONT_TRACK_INTERNAL_LINKS */
d666 5
a670 2
#define CHECK_FOR_INTERN(flag,s)  /* do nothing */ ;
#define INTERN_LT (HTLinkType *)NULL
d672 33
a704 1
#endif /* DONT_TRACK_INTERNAL_LINKS */
d706 4
a709 10
#ifdef USE_COLOR_STYLE
# if !OPT_SCN
static char* Style_className = NULL;
static char myHash[128];
# else
PRIVATE char Style_className[4096];/* i hope it's enough :) HV */
PRIVATE char* Style_className_end=Style_className;/*this points to the
		    end of string in Style_className (it points to '\0') */
# endif
static int hcode;
d752 1
a752 1
#if defined(__STDC__) || _WIN_CC
d831 1
a831 1
	if (clickable_images && src && src != '\0') {
a836 21
		char *temp = NULL;
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));

d894 6
d921 1
a924 1
    BOOL UseBASE = TRUE;		     /* Resolved vs. BASE if present? */
d933 1
a933 1
    char* class_name;
a934 6
#  if OPT_SCN
#    if !OMIT_SCN_KEEPING
    char* Style_className_end_was = Style_className_end+1;
#    endif
    /* assume ';' will be appended*/
#  endif
d1052 4
a1055 11
#if !OPT_SCN
    HTSprintf (&Style_className, ";%s", HTML_dtd.tags[element_number].name);
#else
# if !OMIT_SCN_KEEPING
    *Style_className_end=';';
    memcpy(Style_className_end+1,
	   HTML_dtd.tags[element_number].name,
	   HTML_dtd.tags[element_number].name_len+1);
    Style_className_end += HTML_dtd.tags[element_number].name_len+1;
# endif
#endif
a1069 3
#if !OPT_SCN
	strcpy (myHash, HTML_dtd.tags[element_number].name);
#else
d1071 1
a1071 3
#endif
	if (class_name[0])
	{
a1072 12
	    char *oend = Style_className_end;
#if !OPT_SCN
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
	    HTSprintf (&Style_className, ".%s", class_name);
#else
#   if !OMIT_SCN_KEEPING
	    int l = strlen(class_name);
	    *Style_className_end = '.';
	    memcpy(Style_className_end+1, class_name, l+1 );
	    Style_className_end += l+1;
#   endif
a1075 1
#endif
a1077 1
		*oend = '\0';
d1082 2
a1090 4
#if !OPT_SCN
	strtolower(myHash);
	hcode = hash_code(myHash);
#endif
a1092 22
#if !OPT_SCN
    if (TRACE)
    {
	CTRACE((tfp, "CSSTRIM:%s -> %d", myHash, hcode));
	if (hashStyles[hcode].code != hcode) {
	    char *rp = strrchr(myHash, '.');
	    CTRACE((tfp, " (undefined) %s\n", myHash));
	    if (rp) {
		int hcd;
		*rp = '\0'; /* trim the class */
		hcd = hash_code(myHash);
		CTRACE((tfp, "CSS:%s -> %d", myHash, hcd));
		if (hashStyles[hcd].code!=hcd)
		    CTRACE((tfp, " (undefined) %s\n", myHash));
		else
		    CTRACE((tfp, " ca=%d\n", hashStyles[hcd].color));
	    }
	} else {
	    CTRACE((tfp, " ca=%d\n", hashStyles[hcode].color));
	}
    }
#endif
d1095 1
a1095 12
#if !OPT_SCN
	    int len = strlen(myHash);
	    sprintf(myHash, ".%.*s", (int)sizeof(myHash) - len - 2, class_name);
	    HTSprintf (&Style_className, ".%s", class_name);
#else
#     if !OMIT_SCN_KEEPING
	    int l = strlen(class_name);
	    *Style_className_end = '.';
	    memcpy(Style_className_end+1,class_name, l + 1 );
	    Style_className_end += l + 1;
#     endif
#endif
d1105 1
a1105 10
#if !OPT_SCN
    strtolower(Style_className);
#else
#  if !OMIT_SCN_KEEPING
    strtolower(Style_className_end_was);/*only the part that wasn't
					  lowercased yet*/
#   endif
#endif

#if OPT_SCN && !OMIT_SCN_KEEPING	/* Can be done in other cases too... */
d1108 1
a1108 2
	char *oend = Style_className_end;
	int l, ohcode = hcode;
a1111 1
	l = strlen(type);
a1112 4
	*Style_className_end = '.';
	memcpy(Style_className_end+1, "type.", 5 );
	memcpy(Style_className_end+6, type, l+1 );
	Style_className_end += l+6;
a1116 1
	    *oend = '\0';
d1121 2
d1128 1
a1128 1
#endif	/* OPT_SCN && !OMIT_SCN_KEEPING */
d1148 1
a1148 1
	    char *related = NULL;
d1151 2
d1155 1
a1155 1
			    (base ? base : "")));
d1170 3
a1172 8
		temp = HTParse(base + 11, "",
			       PARSE_ACCESS+PARSE_HOST+PARSE_PATH
			       +PARSE_PUNCTUATION);
		if (temp) {
		    FREE(base);
		    base = temp;
		    temp = NULL;
		}
d1178 1
a1178 1
	    StrAllocCopy(related, me->node_anchor->address);
d1183 2
a1184 9
	    if ((temp = HTParse(base, related,
				PARSE_ACCESS+PARSE_PUNCTUATION)) &&
		*temp != '\0') {
		StrAllocCopy(me->base_href, temp);
	    } else {
		FREE(temp);
		StrAllocCopy(me->base_href, (temp = HTParse(related, "",
					 PARSE_ACCESS+PARSE_PUNCTUATION)));
	    }
d1190 2
a1191 3
	    if ((temp = HTParse(base, "",
				PARSE_HOST+PARSE_PUNCTUATION)) &&
		!strncmp(temp, "//", 2)) {
d1197 1
a1197 1
		if (!strcmp(me->base_href, "file:")) {
d1199 1
a1199 1
		} else if (strcmp(me->base_href, "news:")) {
a1205 1
	    FREE(related);
d1210 9
a1218 3
	    if ((temp = HTParse(base, "",
				PARSE_PATH+PARSE_PUNCTUATION)) &&
		*temp != '\0') {
d1220 1
a1220 1
	    } else if (!strcmp(me->base_href, "news:")) {
d1222 3
a1224 3
	    } else if (!strncmp(me->base_href, "news:", 5) ||
		       !strncmp(me->base_href, "nntp:", 5) ||
		       !strncmp(me->base_href, "snews:", 6)) {
d1233 1
d1235 3
a1250 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a1251 1
#endif
d1258 4
a1261 5
		if (me->inBASE && me->base_href && *me->base_href) {
		    StrAllocCopy(href, me->base_href);
		} else {
		    StrAllocCopy(href, me->node_anchor->address);
		}
d1265 5
a1272 20
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));

	    /*
a1284 12
		    if (!is_url(href)) {
			temp = HTParse(href,
				       (me->inBASE ?
				     me->base_href : me->node_anchor->address),
					PARSE_ALL);
			StrAllocCopy(href, temp);
			FREE(temp);
			LYFillLocalFileURL(&href,
					   (me->inBASE ?
					 me->base_href :
					 me->node_anchor->address));
		    }
d1477 1
a1477 1
			    HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
a1550 3
	    char * action = NULL;
	    char * isindex_href = NULL;

d1558 1
a1558 1
		StrAllocCopy(isindex_href, value[HTML_ISINDEX_HREF]);
d1560 2
a1561 2
		StrAllocCopy(isindex_href, value[HTML_ISINDEX_ACTION]);
	    url_type = LYLegitimizeHREF(me, &isindex_href, TRUE, TRUE);
d1563 6
a1568 16
	    /*
	     *	Check whether a base tag is in effect.
	     */
	    if (me->inBASE && *isindex_href != '\0' && *isindex_href != '#')
		action = HTParse(isindex_href, me->base_href, PARSE_ALL);
	    if (!(action && *action))
		action = HTParse(isindex_href,
				 me->node_anchor->address, PARSE_ALL);
	    FREE(isindex_href);

	    if (action && *action) {
		HTAnchor_setIndex(me->node_anchor, action);
	    } else {
		HTAnchor_setIndex(me->node_anchor, me->node_anchor->address);
	    }
	    FREE(action);
d1571 3
a1573 10
	    if (me->inBASE)
		/*
		 *  Use base.
		 */
		HTAnchor_setIndex(me->node_anchor, me->base_href);
	    else
		/*
		 *  Use index's address.
		 */
		HTAnchor_setIndex(me->node_anchor, me->node_anchor->address);
d1634 1
a1634 1
	    value[HTML_FRAME_SRC] && *value[HTML_FRAME_SRC] != '\0') {
d1636 1
a1636 22
	    CHECK_FOR_INTERN(intern_flag,href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d1646 1
a1646 1
				INTERN_LT);		/* Type */
d1688 1
a1688 1
	    value[HTML_IFRAME_SRC] && *value[HTML_IFRAME_SRC] != '\0') {
d1690 1
a1690 22
	    CHECK_FOR_INTERN(intern_flag,href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d1694 1
d1699 1
a1699 1
				INTERN_LT);		/* Type */
d1923 2
a1924 2
	     HText_PreviousLineSize(me->text, FALSE)) ||
	    HText_LastLineSize(me->text, FALSE)) {
d1956 1
a1956 1
	    if (HText_LastLineSize(me->text, FALSE)) {
d1959 1
a1959 1
	    } else if (!HText_PreviousLineSize(me->text, FALSE)) {
d2025 2
a2026 2
	    } else if (!strcmp(me->sp->style->name, "HeadingCenter") ||
		       !strcmp(me->sp->style->name, "Heading1")) {
d2028 1
a2028 1
	    } else if (!strcmp(me->sp->style->name, "HeadingRight")) {
d2220 1
a2220 3
	if (isxdigit(UCH(HText_getLastChar(me->text)))) {
	    HText_appendCharacter(me->text, '^');
	}
d2418 1
a2418 1
	    if (HText_LastLineSize(me->text, FALSE)) {
d2850 1
a2850 1
	if (id_string) {
a2851 4
	    if (*id_string == '\0') {
		FREE(id_string);
	    }
	}
a2856 6
#ifndef DONT_TRACK_INTERNAL_LINKS
	    if (present[HTML_A_ISMAP])
		intern_flag = FALSE;
	    else
		CHECK_FOR_INTERN(intern_flag,value[HTML_A_HREF]);
#endif
d2858 1
a2858 1
	     *	Prepare to do housekeeping on the reference. - FM
d2860 6
a2865 11
	    if (!value[HTML_A_HREF] || *value[HTML_A_HREF] == '\0') {
		StrAllocCopy(href, me->node_anchor->address);
	    } else if (*value[HTML_A_HREF] == '#') {
		StrAllocCopy(href, me->node_anchor->address);
		if (strlen(value[HTML_A_HREF]) > 1) {
		    StrAllocCat(href, value[HTML_A_HREF]);
		}
	    } else {
		StrAllocCopy(href, value[HTML_A_HREF]);
	    }
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
d2867 2
a2868 9
	    /*
	     *	Deal with our ftp gateway kludge. - FM
	     */
	    if (!url_type && !strncmp(href, "/foo/..", 7) &&
		(!strncmp(me->node_anchor->address, "ftp:", 4) ||
		 !strncmp(me->node_anchor->address, "file:", 5))) {
		for (i = 0; (href[i] = href[i+7]) != 0; i++)
		    ;
	    }
d2870 2
a2871 4
	    /*
	     *	Set to know we are making the content bold.
	     */
	    me->inBoldA = TRUE;
a2872 6
	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
d2874 1
a2874 1
		 *  Use reference related to the base.
d2876 7
a2882 2
		StrAllocCopy(href, temp);
	    FREE(temp);
d2884 2
a2885 7
	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d2891 1
a2891 1
#ifndef DONT_TRACK_INTERNAL_LINKS
d2894 2
a2895 2
	    if (!intern_flag && href &&
		!strcasecomp(value[HTML_A_TYPE], HTAtom_name(LINK_INTERNAL)) &&
d2898 1
a2898 1
		0 != strncmp(me->node_anchor->address, "LYNXIMGMAP:", 11)) {
a2907 1
#endif /* DONT_TRACK_INTERNAL_LINKS */
d2947 1
a2947 1
			HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3009 1
a3009 1
			HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
a3023 1
#ifndef DONT_TRACK_INTERNAL_LINKS
a3024 1
#endif
d3037 1
a3037 1
	    if (strchr(map_href, '#') == NULL) {
a3049 1
	    if (!url_type && me->inBASE) {
d3056 4
a3059 37
		if ((*map_href == '#' &&
		     LYSeekFragMAPinCur == TRUE)) {
		    /*
		     *	Use reference related to the current stream. - FM
		     */
		    temp = HTParse(map_href, me->node_anchor->address,
				    PARSE_ALL);
		    StrAllocCopy(map_href, temp);
		    UseBASE = FALSE;
		} else {
		    /*
		     *	Use reference related to the base. - FM
		     */
		    temp = HTParse(map_href, me->base_href, PARSE_ALL);
		    StrAllocCopy(map_href, temp);
		    UseBASE = TRUE;
		}
		FREE(temp);
	    }

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&map_href,
			       ((UseBASE && me->inBASE) ?
			  me->base_href : me->node_anchor->address));
	    UseBASE = TRUE;

	    /*
	     *	If it's not yet a URL, resolve versus
	     *	the current document's address. - FM
	     */
	    if (!(url_type = is_url(map_href))) {
		temp = HTParse(map_href, me->node_anchor->address, PARSE_ALL);
		StrAllocCopy(map_href, temp);
		FREE(temp);
	    }
d3064 1
a3064 1
	    StrAllocCopy(temp, "LYNXIMGMAP:");
d3193 1
a3193 1
	    value[HTML_IMG_SRC] && *value[HTML_IMG_SRC] != '\0') {
d3195 1
a3195 21
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);

	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '\0' && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '\0' && *href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));
d3242 1
a3242 1
				HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3304 1
a3304 1
				HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3408 1
a3408 1
				HTAnchor_followMainLink((HTAnchor*)me->CurrentA)
d3502 1
a3502 1
	    if ((cp = strrchr(me->map_address, '#')) != NULL)
d3540 4
a3543 29
	    if (((me->inBASE && *href != '\0') &&
		 !(*href == '#' && LYSeekFragAREAinCur == TRUE)) &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((((me->inBASE && *href != '\0') &&
				  !(*href == '#' &&
				    LYSeekFragAREAinCur == TRUE)))
						?
				  me->base_href : me->node_anchor->address));
	    if (!(url_type = is_url(href))) {
		temp = HTParse(href, me->node_anchor->address, PARSE_ALL);
		if (!(temp && *temp)) {
		   FREE(href);
		   FREE(temp);
		   break;
		}
		StrAllocCopy(href, temp);
		FREE(temp);
	    }
d3809 1
a3809 1
	    value[HTML_OVERLAY_SRC] && *value[HTML_OVERLAY_SRC] != '\0') {
d3811 1
a3811 2
	    CHECK_FOR_INTERN(intern_flag,href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
a3812 19
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));
d3822 1
a3822 1
					INTERN_LT);		/* Type */
d3895 1
a3895 1
	    value[HTML_APPLET_CODE] && *value[HTML_APPLET_CODE] != '\0') {
a3896 1
	    char * code = NULL;
d3898 3
d3915 1
a3915 1
		url_type = LYLegitimizeHREF(me, &base, TRUE, FALSE);
d3917 1
a3917 26
		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&base,
				   (me->inBASE ?
				 me->base_href : me->node_anchor->address));

		if (!(url_type = is_url(base))) {
		    /*
		     *	Check whether a base tag is in effect.
		     */
		    if (me->inBASE) {
			temp = HTParse(base, me->base_href, PARSE_ALL);
		    } else {
			temp = HTParse(base, me->node_anchor->address,
							PARSE_ALL);
		    }
		    StrAllocCopy(base, temp);
		    FREE(temp);
		}
	    } else {
		if (me->inBASE) {
		    StrAllocCopy(base, me->base_href);
		} else {
		    StrAllocCopy(base, me->node_anchor->address);
		}
d3920 3
a3922 3
	    StrAllocCopy(code, value[HTML_APPLET_CODE]);
	    url_type = LYLegitimizeHREF(me, &code, TRUE, FALSE);
	    href = HTParse(code, base, PARSE_ALL);
a3923 1
	    FREE(code);
d3925 1
a3925 1
	    if (href && *href) {
d3970 1
a3970 1
	    value[HTML_BGSOUND_SRC] && *value[HTML_BGSOUND_SRC] != '\0') {
d3972 1
a3972 2
	    CHECK_FOR_INTERN(intern_flag,href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
a3977 20
	    /*
	     *	Check whether a base tag is in effect. - FM
	     */
	    if ((me->inBASE && *href != '#') &&
		(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		*temp != '\0')
		/*
		 *  Use reference related to the base.
		 */
		StrAllocCopy(href, temp);
	    FREE(temp);

	    /*
	     *	Check whether to fill in localhost. - FM
	     */
	    LYFillLocalFileURL(&href,
			       ((*href != '#' &&
				 me->inBASE) ?
			       me->base_href : me->node_anchor->address));

d3991 1
a3991 1
					INTERN_LT);		/* Type */
d4063 1
a4063 1
	    value[HTML_EMBED_SRC] && *value[HTML_EMBED_SRC] != '\0') {
d4065 2
a4066 23
	    CHECK_FOR_INTERN(intern_flag,href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href != '\0') {
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));

d4077 1
a4077 1
					INTERN_LT);		/* Type */
d4206 5
d4212 2
a4213 4
		value[HTML_FORM_ACTION])  {
		/*
		 *  Prepare to do housekeeping on the reference. - FM
		 */
d4215 1
a4215 1
		url_type = LYLegitimizeHREF(me, &action, TRUE, TRUE);
d4222 4
a4225 19
		if ((me->inBASE && me->base_href && *me->base_href) &&
		    (temp = HTParse(action, me->base_href, PARSE_ALL)) &&
		    *temp != '\0') {
		    /*
		     *	Use action related to the base.
		     */
		    StrAllocCopy(action, temp);
		} else if ((temp = HTParse(action,
					   me->node_anchor->address,
					   PARSE_ALL)) &&
		    *temp != '\0') {
		    /*
		     *	Use action related to the current document.
		     */
		    StrAllocCopy(action, temp);
		} else {
		    FREE(action);
		}
		FREE(temp);
d4227 2
a4228 9
	    if (!(action && *action)) {
		if (me->inBASE && me->base_href && *me->base_href) {
		     StrAllocCopy(action, me->base_href);
		} else {
		     StrAllocCopy(action, me->node_anchor->address);
		}
	    }
	    if (action) {
		source = HTAnchor_findChildAndLink(me->node_anchor,
d4232 11
a4242 12
		if ((link_dest = HTAnchor_followMainLink((HTAnchor *)source)) != NULL) {
		    /*
		     *	Memory leak fixed.
		     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
		     */
		    auto char *cp_freeme = HTAnchor_address(link_dest);
		    if (cp_freeme != NULL) {
			StrAllocCopy(action, cp_freeme);
			FREE(cp_freeme);
		    } else {
			StrAllocCopy(action, "");
		    }
d4536 3
d4549 1
a4549 1
		    HTML_put_string(me,"[RANGE Input] (Not yet implemented.)");
d4560 2
a4561 14
#ifdef EXP_FILE_UPLOAD
		    /*
		     *	Not yet implemented.
		     */
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_START_CHAR);
		    }
		    HTML_put_string(me,"[FILE Input] (Not yet implemented.)");
		    if (me->inUnderline == FALSE) {
			HText_appendCharacter(me->text,
					      LY_UNDERLINE_END_CHAR);
		    }
#else
a4562 1
#endif /* EXP_FILE_UPLOAD */
d4568 1
d4577 17
d4675 1
a4675 1
		url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
a4676 20
		    /*
		     *	Check whether a base tag is in effect. - FM
		     */
		    if ((me->inBASE && *href != '#') &&
			(temp = HTParse(href, me->base_href, PARSE_ALL)) &&
			*temp != '\0')
			/*
			 *  Use reference related to the base.
			 */
			StrAllocCopy(href, temp);
		    FREE(temp);

		    /*
		     *	Check whether to fill in localhost. - FM
		     */
		    LYFillLocalFileURL(&href,
				       ((*href != '#' &&
					 me->inBASE) ?
				       me->base_href :
				       me->node_anchor->address));
d4729 1
a4729 1
#ifdef EXP_FILE_UPLOAD
d4836 1
a4836 1
#ifndef EXP_FILE_UPLOAD
d4863 1
d4879 1
d4913 1
a4913 1
#ifndef EXP_FILE_UPLOAD
d4922 5
a4926 2
		for (; chars > 0; chars--)
		    HTML_put_character(me, '_');
d4979 3
d5145 1
a5145 1
	     *	If its not a multiple option list and select popups
a5260 1

d5287 1
a5287 1
		keypad_mode == LINKS_AND_FIELDS_ARE_NUMBERED) {
d5333 1
a5333 1
	if (!strcmp(me->sp->style->name, "Preformatted")) {
a5347 1
#ifdef SH_EX	/* 1998/10/09 (Fri) 15:20:09 */
d5361 1
a5361 6
#else
		me->DivisionAlignments[me->Division_Level] = HT_CENTER;
		change_paragraph_style(me, styles[HTML_DCENTER]);
		UPDATE_STYLE;
		me->current_default_alignment = styles[HTML_DCENTER]->alignment;
#endif
d5406 1
a5406 1
	if (HText_LastLineSize(me->text, FALSE)) {
d5412 1
a5412 1
	if (!strcmp(me->sp->style->name, "Preformatted")) {
d5422 2
a5423 2
		    (!strcmp(me->sp->style->name, "Normal") ||
		     !strcmp(me->sp->style->name, "Preformatted")))) {
a5430 1
#ifdef SH_EX
a5434 3
#else
		me->sp->style->alignment = HT_CENTER;
#endif
a5626 4
#if !OPT_SCN
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
#else
a5632 1
#endif
d6051 2
a6052 2
	} else if (!strcmp(me->sp->style->name, "HeadingCenter") ||
		   !strcmp(me->sp->style->name, "Heading1")) {
d6054 1
a6054 1
	} else if (!strcmp(me->sp->style->name, "HeadingRight")) {
d7108 1
d7134 1
a7134 1
	if (!strcmp(me->sp->style->name, "Preformatted")) {
d7144 1
d7148 5
a7152 1
	} else
a7153 1
	HText_endStblTABLE(me->text);
d7163 1
a7163 1
	if (HText_LastLineSize(me->text, FALSE)) {
a7235 4
#if !OPT_SCN
	TrimColorClass(HTML_dtd.tags[element_number].name,
		       Style_className, &hcode);
#else
a7241 1
#endif
d7443 3
a7445 3
	if (!strcmp(me->sp->style->name, "DivCenter") ||
	    !strcmp(me->sp->style->name, "HeadingCenter") ||
	    !strcmp(me->sp->style->name, "Heading1")) {
d7447 2
a7448 2
	} else if (!strcmp(me->sp->style->name, "DivRight") ||
		   !strcmp(me->sp->style->name, "HeadingRight")) {
a7454 5
#ifdef USE_COLOR_STYLE
# if !OPT_SCN
    FREE(Style_className);
# endif
#endif
d7528 3
a7530 3
	if (!strcmp(me->sp->style->name, "DivCenter") ||
	    !strcmp(me->sp->style->name, "HeadingCenter") ||
	    !strcmp(me->sp->style->name, "Heading1")) {
d7532 2
a7533 2
	} else if (!strcmp(me->sp->style->name, "DivRight") ||
		   !strcmp(me->sp->style->name, "HeadingRight")) {
a7539 5
#ifdef USE_COLOR_STYLE
# if !OPT_SCN
    FREE(Style_className);
# endif
#endif
d7557 4
a7560 2
    styleSheet = DefaultStyle();
    default_style =		HTStyleNamed(styleSheet, "Normal");
d7562 13
a7574 13
    styles[HTML_H1] =		HTStyleNamed(styleSheet, "Heading1");
    styles[HTML_H2] =		HTStyleNamed(styleSheet, "Heading2");
    styles[HTML_H3] =		HTStyleNamed(styleSheet, "Heading3");
    styles[HTML_H4] =		HTStyleNamed(styleSheet, "Heading4");
    styles[HTML_H5] =		HTStyleNamed(styleSheet, "Heading5");
    styles[HTML_H6] =		HTStyleNamed(styleSheet, "Heading6");
    styles[HTML_HCENTER] =	HTStyleNamed(styleSheet, "HeadingCenter");
    styles[HTML_HLEFT] =	HTStyleNamed(styleSheet, "HeadingLeft");
    styles[HTML_HRIGHT] =	HTStyleNamed(styleSheet, "HeadingRight");

    styles[HTML_DCENTER] =	HTStyleNamed(styleSheet, "DivCenter");
    styles[HTML_DLEFT] =	HTStyleNamed(styleSheet, "DivLeft");
    styles[HTML_DRIGHT] =	HTStyleNamed(styleSheet, "DivRight");
d7576 1
a7576 1
    styles[HTML_DL] =		HTStyleNamed(styleSheet, "Glossary");
d7578 6
a7583 6
    styles[HTML_DL1] =		HTStyleNamed(styleSheet, "Glossary1");
    styles[HTML_DL2] =		HTStyleNamed(styleSheet, "Glossary2");
    styles[HTML_DL3] =		HTStyleNamed(styleSheet, "Glossary3");
    styles[HTML_DL4] =		HTStyleNamed(styleSheet, "Glossary4");
    styles[HTML_DL5] =		HTStyleNamed(styleSheet, "Glossary5");
    styles[HTML_DL6] =		HTStyleNamed(styleSheet, "Glossary6");
d7586 1
a7586 1
    styles[HTML_OL] =		HTStyleNamed(styleSheet, "List");
d7588 6
a7593 6
    styles[HTML_OL1] =		HTStyleNamed(styleSheet, "List1");
    styles[HTML_OL2] =		HTStyleNamed(styleSheet, "List2");
    styles[HTML_OL3] =		HTStyleNamed(styleSheet, "List3");
    styles[HTML_OL4] =		HTStyleNamed(styleSheet, "List4");
    styles[HTML_OL5] =		HTStyleNamed(styleSheet, "List5");
    styles[HTML_OL6] =		HTStyleNamed(styleSheet, "List6");
d7596 1
a7596 1
    styles[HTML_DIR] =		HTStyleNamed(styleSheet, "Menu");
d7598 6
a7603 6
    styles[HTML_MENU1] =	HTStyleNamed(styleSheet, "Menu1");
    styles[HTML_MENU2] =	HTStyleNamed(styleSheet, "Menu2");
    styles[HTML_MENU3] =	HTStyleNamed(styleSheet, "Menu3");
    styles[HTML_MENU4] =	HTStyleNamed(styleSheet, "Menu4");
    styles[HTML_MENU5] =	HTStyleNamed(styleSheet, "Menu5");
    styles[HTML_MENU6] =	HTStyleNamed(styleSheet, "Menu6");
d7605 1
a7605 1
    styles[HTML_DLC] =		HTStyleNamed(styleSheet, "GlossaryCompact");
d7607 13
a7619 13
    styles[HTML_DLC1] =		HTStyleNamed(styleSheet, "GlossaryCompact1");
    styles[HTML_DLC2] =		HTStyleNamed(styleSheet, "GlossaryCompact2");
    styles[HTML_DLC3] =		HTStyleNamed(styleSheet, "GlossaryCompact3");
    styles[HTML_DLC4] =		HTStyleNamed(styleSheet, "GlossaryCompact4");
    styles[HTML_DLC5] =		HTStyleNamed(styleSheet, "GlossaryCompact5");
    styles[HTML_DLC6] =		HTStyleNamed(styleSheet, "GlossaryCompact6");

    styles[HTML_ADDRESS] =	HTStyleNamed(styleSheet, "Address");
    styles[HTML_BANNER] =	HTStyleNamed(styleSheet, "Banner");
    styles[HTML_BLOCKQUOTE] =	HTStyleNamed(styleSheet, "Blockquote");
    styles[HTML_BQ] =		HTStyleNamed(styleSheet, "Bq");
    styles[HTML_FN] =		HTStyleNamed(styleSheet, "Footnote");
    styles[HTML_NOTE] =		HTStyleNamed(styleSheet, "Note");
d7621 3
a7623 3
    styles[HTML_XMP] =		HTStyleNamed(styleSheet, "Example");
    styles[HTML_PRE] =		HTStyleNamed(styleSheet, "Preformatted");
    styles[HTML_LISTING] =	HTStyleNamed(styleSheet, "Listing");
d7770 1
d7792 6
a7797 5
# if !OPT_SCN
    FREE(Style_className);
# else
    Style_className_end = Style_className;
# endif
d7845 1
a7845 1
#ifdef SOURCE_CACHE
d8020 1
a8020 1
    /*  Only remote HTML documents may benefits from HTreparse_document(), */
d8022 2
a8023 1
    if (strcmp(p->name, "http") != 0) {
@


1.3.2.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@a86 13
#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4

#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)

#define LimitValue(name, value) \
	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}

d4712 1
a4712 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d4898 1
a4898 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d5202 1
a5202 1
		I.size = atoi(value[HTML_INPUT_SIZE]);
d5433 1
a5433 1
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
d5439 1
a5439 1
		width = HTMIN(width, DFT_TEXTAREA_COLS);
d5442 1
a5442 1
		me->textarea_cols = width;
d5444 1
a5444 1
		me->textarea_cols = DFT_TEXTAREA_COLS;
a5445 1
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);
d5452 1
a5452 2
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);
d5569 1
a5569 1
		I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d7234 1
a7234 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d7385 1
a7385 1
		for (chars = me->textarea_cols; chars > 0; chars--)
d7410 1
d7967 1
d8145 1
a8145 1
    me->textarea_cols = 0;
@


1.3.4.1
log
@MFC:
Fix by avsm@@

Backport from lynx-2.8.6dev.7b to prevent a memory exhaustion from crashing
lynx while parsing pages such as:
http://lcamtuf.coredump.cx/mangleme/gallery/lynx_die1.html

Submitted by: Thorsten Glaser <tg at 66h.42h.de>

ok deraadt@@
@
text
@a86 13
#define DFT_TEXTAREA_COLS 60
#define DFT_TEXTAREA_ROWS 4

#define MAX_TEXTAREA_COLS LYcolLimit
#define MAX_TEXTAREA_ROWS (3 * LYlines)

#define LimitValue(name, value) \
	if (name > value) { \
		CTRACE((tfp, "Limited " #name " to %d, was %d\n", \
			value, name)); \
		name = value; \
	}

d4712 1
a4712 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d4898 1
a4898 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d5202 1
a5202 1
		I.size = atoi(value[HTML_INPUT_SIZE]);
d5433 1
a5433 1
	    me->textarea_cols = atoi(value[HTML_TEXTAREA_COLS]);
d5439 1
a5439 1
		width = HTMIN(width, DFT_TEXTAREA_COLS);
d5442 1
a5442 1
		me->textarea_cols = width;
d5444 1
a5444 1
		me->textarea_cols = DFT_TEXTAREA_COLS;
a5445 1
	LimitValue(me->textarea_cols, MAX_TEXTAREA_COLS);
d5452 1
a5452 2
	    me->textarea_rows = DFT_TEXTAREA_ROWS;
	LimitValue(me->textarea_rows, MAX_TEXTAREA_ROWS);
d5569 1
a5569 1
		I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d7234 1
a7234 1
	    I.min=NULL; I.name=NULL; I.size=0; I.src=NULL;
d7385 1
a7385 1
		for (chars = me->textarea_cols; chars > 0; chars--)
d7410 1
d7967 1
d8145 1
a8145 1
    me->textarea_cols = 0;
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a37 1
#include <HTFont.h>
d51 1
a51 1
#ifdef USE_PSRC
d80 2
a87 1
extern HTCJKlang HTCJK;
d97 1
d99 1
d103 1
d113 2
a114 1
PRIVATE HTStyle *styles[HTML_ELEMENTS+31]; /* adding 24 nested list styles  */
d128 1
a128 1
PRIVATE void HTML_end_element PARAMS((HTStructured *me,
d132 1
a132 1
PRIVATE void HTML_start_element PARAMS((
a155 2
extern int hash_code PARAMS((char* i));

d158 2
a159 2
	if (!i) return;
	while (*i) { *i=tolower(*i); i++; }
d209 11
d246 1
a246 1
    if (LYMapsOnly)
d451 1
a451 1
#ifdef USE_PSRC
d455 1
a455 1
    if (LYMapsOnly || s == NULL)
d457 1
a457 1
#ifdef USE_PSRC
d462 1
a462 1
    };
d516 12
d562 1
a562 1
				me->in_word = NO;
d597 1
a597 1
#ifdef USE_PSRC
d613 1
a613 1
    if (LYMapsOnly)
d616 1
a616 1
    for (p = s; s < e; p++)
d670 2
a671 2
   for overriding non-caching similar to LYoverride_no_cache. - kw */
#define CHECK_FOR_INTERN(s) intern_flag = (s && (*s=='#' || *s=='\0')) ? TRUE : FALSE;
d679 1
a679 1
#define CHECK_FOR_INTERN(s)  /* do nothing */ ;
d697 1
a697 1
#ifdef USE_PSRC
d701 1
a701 1
	    HTlexem,	      lexem,
d705 1
a705 1
    HT_tagspec* ts = *( ( start ? lexem_start : lexem_end ) + lexem);
d716 1
a716 1
	CTRACE(tfp,ts->start ? "SRCSTART %d\n" : "SRCSTOP %d\n",(int)lexem);
d735 2
d739 4
d747 151
a897 1
#endif /* USE_PSRC*/
d902 1
a902 1
PRIVATE void HTML_start_element ARGS6(
d920 1
a920 1
    int dest_char_set = UCLYhndl_for_unrec;
d923 1
a923 1
    BOOL UseBASE = TRUE;		     /* Resoved vs. BASE if present? */
d927 1
a927 1
    int ElementNumber = element_number;
d929 2
d933 1
d942 1
a942 1
#ifdef USE_PSRC
d949 1
a949 1
		psrc_first_tag=FALSE;
d955 3
a957 3
		psrc_nested_call=TRUE;
		HTML_start_element(me,HTML_BODY, NULL,NULL,tag_charset,NULL);
		HTML_start_element(me,HTML_PRE, NULL,NULL,tag_charset,NULL);
d959 1
a959 1
		psrc_nested_call=FALSE;
d962 1
a962 1
	    psrc_nested_call=TRUE;
d969 1
a969 1
		strcpy(buf,tag->name);
d981 1
a981 1
			    strcpy(buf,tag->attributes[i].name);
d988 1
a988 1
			    char kind= ( !strchr(value[i], '"') ?
d1026 1
a1026 1
	    return;
d1030 1
a1030 1
#endif /* USE_PSRC */
d1034 3
a1036 2
	      ElementNumber == HTML_BASE)) {
	    return;
d1047 3
a1049 3
	    CTRACE(tfp, "me->tag_charset: %d -> %d", me->tag_charset, j );
	    CTRACE(tfp, " (me->UCLYhndl: %d, tag_charset: %d)\n",
		   me->UCLYhndl, tag_charset);
a1061 1
    /*strcpy(Style_className_end+1,HTML_dtd.tags[element_number].name);*/
d1079 1
d1081 1
a1081 1
    if (current_tag_style == -1) {
d1085 1
a1085 1
	hcode=hash_code_lowercase_on_fly(HTML_dtd.tags[element_number].name);
d1089 2
d1092 2
a1094 2
	    strcat (myHash, ".");
	    strcat (myHash, class_name);
a1095 1

d1097 1
a1097 1
	    int l=strlen(class_name);
d1106 12
d1119 1
d1129 5
a1133 7
	fprintf(tfp, "CSSTRIM:%s -> %d", myHash, hcode);
	if (hashStyles[hcode].code!=hcode)
	{
	    char *rp=strrchr(myHash, '.');
	    fprintf(tfp, " (undefined) %s\n", myHash);
	    if (rp)
	    {
d1135 1
a1135 1
		*rp='\0'; /* trim the class */
d1137 1
a1137 1
		fprintf(tfp, "CSS:%s -> %d", myHash, hcd);
d1139 1
a1139 1
		    fprintf(tfp, " (undefined) %s\n", myHash);
d1141 1
a1141 1
		    fprintf(tfp, " ca=%d\n", hashStyles[hcd].color);
d1143 2
a1145 2
	else
	    fprintf(tfp, " ca=%d\n", hashStyles[hcode].color);
a1147 7

	/* seems that this condition is always true - HV */
	if (displayStyles[element_number + STARTAT].color > -2) /* actually set */
	{
	    CTRACE(tfp, "CSSTRIM: start_element: top <%s>\n", HTML_dtd.tags[element_number].name);
	    HText_characterStyle(me->text, hcode, 1);
	}
d1151 2
a1153 2
	    strcat (myHash, ".");
	    strcat (myHash, class_name);
d1157 3
a1159 3
	    *Style_className_end='.';
	    memcpy(Style_className_end+1,class_name, l+1 );
	    Style_className_end+=l+1;
d1165 3
a1167 1
	HText_characterStyle(me->text, hcode , 1);
d1180 29
d1210 1
a1210 1

d1232 2
a1233 2
		CTRACE(tfp, "HTML: BASE '%s' is not an absolute URL.\n",
			    (base ? base : ""));
d1337 1
a1337 1
	    CHECK_FOR_INTERN(value[HTML_LINK_HREF]);
d1398 1
a1398 1
		    CTRACE(tfp, "HTML: DOC OWNER '%s' found\n", href);
d1428 4
a1432 4
/*  lss and css has different syntax - lynx shouldn't try to
    parse them now (it tries to parse them as lss, so it exits with
    error message the 1st non-empty line) - HVV
*/
d1436 2
a1437 32
		    CTRACE(tfp, "HTML: StyleSheet link found.\n");
#ifdef LINKEDSTYLES
		    if (href && *href != '\0')
		    {
			int res = -999;
			if ((url_type = is_url(href)) == 0 ||
			    (url_type == FILE_URL_TYPE && LYisLocalFile(href))) {
			    if (url_type == FILE_URL_TYPE) {
				temp = HTParse(href, "", PARSE_PATH+PARSE_PUNCTUATION);
				HTUnEscape(temp);
				if (temp && *temp != '\0') {
				    res = style_readFromFile(temp);
				    if (res != 0)
					StrAllocCopy(href, temp);
				}
				FREE(temp);
			    } else {
				res = style_readFromFile(href);
			    }
			}
			CTRACE(tfp, "CSS: StyleSheet=%s %d\n", href, res);
			if (res == 0)
			    HTAnchor_setStyle (me->node_anchor, href);
		    }
		    else {
			CTRACE(tfp,
				"        non-local StyleSheets not yet implemented.\n");
		    }
#else
		    CTRACE(tfp,
				"        StyleSheets not yet implemented.\n");
#endif
d1444 1
a1444 1
		 *  Ignore anything not registered in the the 28-Mar-95
d1509 8
d1518 2
a1519 2
		    CTRACE(tfp, "HTML: LINK with REL=\"%s\" ignored.\n",
				 value[HTML_LINK_REL]);
d1537 2
a1538 2
		CTRACE(tfp, "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
			    value[HTML_LINK_REL]);
d1593 5
a1597 1
		dest = NULL;
a1602 2
		    if (dest_char_set < 0)  /* recover if not defined :-( */
			dest_char_set = UCLYhndl_for_unspec; /* always >= 0 */
d1604 1
a1604 1
		if (dest)
d1621 6
d1637 2
a1638 1
		CTRACE(tfp, "CSSTRIM:link=%s\n", tmp);
a1729 2
	/* if (present && present[NEXTID_N] && value[NEXTID_N])
		HText_setNextId(me->text, atoi(value[NEXTID_N])); */
d1768 1
a1768 1
	    CHECK_FOR_INTERN(href);
d1800 1
d1808 1
d1820 1
d1843 1
a1843 1
	    CHECK_FOR_INTERN(href);
d1874 1
d1882 1
d1894 1
d1905 1
a1905 1
	if (me->sp->tag_number == ElementNumber)
d1931 1
a1931 1
	    CTRACE(tfp,
d1933 1
a1933 1
		MAX_NESTING);
d1935 2
d1942 20
d2016 2
a2017 1
	     me->sp[0].tag_number == HTML_DIR)) {
d2082 2
a2083 1
	LYHandleP(me, present, value, include, TRUE);
d2164 1
a2164 1
		isdigit(*value[HTML_HR_WIDTH]) &&
d2224 1
a2224 1
	    CTRACE(tfp, "HTML: TAB tag has no attributes.  Ignored.\n");
d2227 7
d2236 1
d2245 1
a2245 1
	    CTRACE(tfp, "HTML: ALIGN not 'left'.  Using space instead of TAB.\n");
d2256 1
a2256 1
	    CTRACE(tfp, "HTML: Not HT_LEFT.  Using space instead of TAB.\n");
d2262 1
a2262 1
		    isdigit(*value[HTML_TAB_INDENT]))) {
d2278 1
a2278 1
		       isdigit(*value[HTML_TAB_INDENT])) {
d2292 1
d2296 1
a2296 1
		CTRACE(tfp, "HTML: Column out of bounds.  Using space instead of TAB.\n");
d2365 1
a2365 1
	    CTRACE(tfp, "Underline Level is %d\n", me->Underline_Level);
d2371 1
a2371 1
	    CTRACE(tfp,"Beginning underline\n");
d2373 1
a2373 1
	    CTRACE(tfp,"Underline Level is %d\n", me->Underline_Level);
a2386 2
    case HTML_SUB:
    case HTML_SUP:
d2392 12
d2453 1
d2455 1
d2457 1
d2470 1
a2470 1
	if (me->sp->tag_number == ElementNumber)
d2478 1
a2478 1
	if (me->sp->tag_number == ElementNumber)
d2510 1
d2513 1
d2522 1
a2522 1
	if (me->sp->tag_number == ElementNumber)
d2544 1
d2789 42
a2830 38
	if (me->sp[0].tag_number == HTML_OL) {
	    char number_string[20];
	    int counter, seqnum;
	    char seqtype;

	    counter = me->List_Nesting_Level < 11 ?
			   me->List_Nesting_Level : 11;
	    if (present && present[HTML_LI_TYPE] && value[HTML_LI_TYPE]) {
		if (*value[HTML_LI_TYPE] == '1') {
		    me->OL_Type[counter] = '1';
		} else if (*value[HTML_LI_TYPE] == 'A') {
		    me->OL_Type[counter] = 'A';
		} else if (*value[HTML_LI_TYPE] == 'a') {
		    me->OL_Type[counter] = 'a';
		} else if (*value[HTML_LI_TYPE] == 'I') {
		    me->OL_Type[counter] = 'I';
		} else if (*value[HTML_LI_TYPE] == 'i') {
		    me->OL_Type[counter] = 'i';
		}
	    }
	    if (present && present[HTML_LI_VALUE] &&
		((value[HTML_LI_VALUE] != NULL) &&
		 (*value[HTML_LI_VALUE] != '\0')) &&
		((isdigit(*value[HTML_LI_VALUE])) ||
		 (*value[HTML_LI_VALUE] == '-' &&
		  isdigit(*(value[HTML_LI_VALUE] + 1))))) {
		seqnum = atoi(value[HTML_LI_VALUE]);
		if (seqnum <= OL_VOID)
		    seqnum = OL_VOID + 1;
		seqtype = me->OL_Type[counter];
		if (seqtype != '1' && seqnum < 1)
		    seqnum = 1;
		me->OL_Counter[counter] = seqnum + 1;
	    } else if (me->OL_Counter[counter] >= OL_VOID) {
		seqnum = me->OL_Counter[counter]++;
		seqtype = me->OL_Type[counter];
		if (seqtype != '1' && seqnum < 1) {
		    seqnum = 1;
d2832 17
d2850 10
a2859 9
	    } else {
		seqnum = me->Last_OL_Count + 1;
		seqtype = me->Last_OL_Type;
		for (i = (counter - 1); i >= 0; i--) {
		    if (me->OL_Counter[i] > OL_VOID) {
			seqnum = me->OL_Counter[i]++;
			seqtype = me->OL_Type[i];
			i = 0;
		    }
d2861 10
a2870 22
	    }
	    if (seqtype == 'A') {
		sprintf(number_string, LYUppercaseA_OL_String(seqnum));
	    } else if (seqtype == 'a') {
		sprintf(number_string, LYLowercaseA_OL_String(seqnum));
	    } else if (seqtype == 'I') {
		sprintf(number_string, LYUppercaseI_OL_String(seqnum));
	    } else if (seqtype == 'i') {
		sprintf(number_string, LYLowercaseI_OL_String(seqnum));
	    } else {
		sprintf(number_string, "%2d.", seqnum);
	    }
	    me->Last_OL_Count = seqnum;
	    me->Last_OL_Type = seqtype;
	    /*
	     *	Hack, because there is no append string!
	     */
	    for (i = 0; number_string[i] != '\0'; i++)
		if (number_string[i] == ' ')
		    HTML_put_character(me, HT_NON_BREAK_SPACE);
		else
		    HTML_put_character(me, number_string[i]);
d2872 18
a2889 18
	    /*
	     *	Use HTML_put_character so that any other spaces
	     *	coming through will be collapsed.  We'll use
	     *	nbsp, so it won't break at the spacing character
	     *	if there are no spaces in the subsequent text up
	     *	to the right margin, but will declare it as a
	     *	normal space to ensure collapsing if a normal
	     *	space does immediately follow it. - FM
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HText_setLastChar(me->text, ' ');
	} else if (me->sp[0].tag_number == HTML_UL) {
	    /*
	     *	Hack, because there is no append string!
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    switch(me->List_Nesting_Level % 7) {
d2912 19
a2931 18
	    /*
	     *	Keep using HTML_put_character so that any other
	     *	spaces coming through will be collapsed.  We use
	     *	nbsp, so we won't wrap at the spacing character
	     *	if there are no spaces in the subsequent text up
	     *	to the right margin, but will declare it as a
	     *	normal space to ensure collapsing if a normal
	     *	space does immediately follow it. - FM
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HText_setLastChar(me->text, ' ');
	} else {
	    /*
	     *	Hack, because there is no append string!
	     */
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HTML_put_character(me, HT_NON_BREAK_SPACE);
	    HText_setLastChar(me->text, ' ');
d2933 1
d2963 1
a2963 1
	if (me->sp->tag_number == ElementNumber)
d2972 1
d2979 19
d3040 1
a3040 1
		CHECK_FOR_INTERN(value[HTML_A_HREF]);
d3101 2
a3102 1
		0 != strcmp(me->node_anchor->address, LYlist_temp_url()) &&
d3108 2
a3109 2
		CTRACE(tfp, "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
			    href, temp);
a3148 2
		if (dest_char_set < 0) /* recover if not defined :-( */
			dest_char_set = UCLYhndl_for_unspec; /* always >= 0 */
d3160 3
a3162 1
	    if (dest) {
d3185 1
a3185 1
#ifdef NOTUSED_FOTEMODS
d3193 8
a3200 1
	    HTML_end_element(me, HTML_A, &include);
d3202 1
a3202 1
#endif /* NOTUSED_FOTEMODS */
d3219 2
a3220 2
		    CTRACE(tfp, "HTML: '%s' is an ISMAP script\n",
				dest->address);
d3224 2
a3225 2
		    CTRACE(tfp, "HTML: Designating '%s' as an ISMAP script\n",
				dest->address);
d3239 1
a3239 1
	    CHECK_FOR_INTERN(map_href);
d3413 1
a3413 1
	CTRACE(tfp, "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
d3416 1
a3416 1
		    me->inA, me->inP);
d3742 10
d3792 1
a3792 1
	    CHECK_FOR_INTERN(href);
d3896 14
a3909 17
	me->inFIG = TRUE;
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (!present ||
	    (present && !present[HTML_FIG_ISOBJECT])) {
	    LYEnsureDoubleSpace(me);
	    LYResetParagraphAlignment(me);
	    me->inFIGwithP = TRUE;
	} else {
	    me->inFIGwithP = FALSE;
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	CHECK_ID(HTML_FIG_ID);
	me->in_word = NO;
	me->inP = FALSE;
d3911 13
a3923 61
	if (clickable_images && present && present[HTML_FIG_SRC] &&
	    value[HTML_FIG_SRC] && *value[HTML_FIG_SRC] != '\0') {
	    StrAllocCopy(href, value[HTML_FIG_SRC]);
	    CHECK_FOR_INTERN(href);
	    url_type = LYLegitimizeHREF(me, &href, TRUE, TRUE);
	    if (*href) {
		/*
		 *  Check whether a base tag is in effect. - FM
		 */
		if ((me->inBASE && *href != '#') &&
		    (temp = HTParse(href, me->base_href, PARSE_ALL)) &&
		    *temp != '\0')
		    /*
		     *	Use reference related to the base.
		     */
		    StrAllocCopy(href, temp);
		FREE(temp);

		/*
		 *  Check whether to fill in localhost. - FM
		 */
		LYFillLocalFileURL(&href,
				   ((*href != '#' &&
				     me->inBASE) ?
				   me->base_href : me->node_anchor->address));

		me->CurrentA = HTAnchor_findChildAndLink(
					me->node_anchor,	/* Parent */
					NULL,			/* Tag */
					href,			/* Addresss */
					INTERN_LT);		/* Type */
		HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_START_CHAR);
		HTML_put_string(me, (present[HTML_FIG_ISOBJECT] ?
		      (present[HTML_FIG_IMAGEMAP] ?
					"(IMAGE)" : "(OBJECT)") : "[FIGURE]"));
		if (me->inBoldH == FALSE)
		    HText_appendCharacter(me->text, LY_BOLD_END_CHAR);
		HText_endAnchor(me->text, 0);
		HTML_put_character(me, '-');
		HTML_put_character(me, ' '); /* space char may be ignored */
		me->in_word = NO;
	    }
	    FREE(href);
	}
	break;

    case HTML_OBJECT:
	if (!me->object_started) {
	    /*
	     *	This is an outer OBJECT start tag,
	     *	i.e., not a nested OBJECT, so save
	     *	it's relevant attributes. - FM
	     */
	    if (present) {
		if (present[HTML_OBJECT_DECLARE])
		    me->object_declare = TRUE;
		if (present[HTML_OBJECT_SHAPES])
		    me->object_shapes = TRUE;
		if (present[HTML_OBJECT_ISMAP])
d4015 75
a4089 3
	     *	Set flag that we are accumulating OBJECT content. - FM
	     */
	    me->object_started = TRUE;
d4098 1
a4098 1
	    CHECK_FOR_INTERN(href);
d4303 1
a4303 1
	    CHECK_FOR_INTERN(href);
d4417 1
a4417 1
	    CHECK_FOR_INTERN(href);
d4492 1
d4524 1
d4564 1
a4564 1
		CTRACE(tfp, "HTML: Missing FORM end tag.  Faking it!\n");
d4573 1
d4739 3
a4741 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: BUTTON tag not within FORM tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d4866 2
a4867 2
				       (I.value[i] ==  ' ' ?
					HT_NON_BREAK_SPACE : I.value[i]));
d4869 1
a4869 1
		while (i < chars) {
d4892 2
a4893 1

d4944 1
a4944 1
		    CTRACE(tfp, "HTML: Ignoring TYPE=\"range\"\n");
d4950 1
d4963 3
d4970 1
a4970 2
		    CTRACE(tfp, "HTML: Ignoring TYPE=\"file\"\n");
		    break;
d4985 3
a4987 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: INPUT tag not within FORM tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d4996 2
d5002 2
a5003 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: Missing TEXTAREA end tag.\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d5010 1
a5010 1
		CTRACE(tfp, "HTML: Missing SELECT end tag, faking it...\n");
d5105 2
d5109 5
a5113 1
		 value[HTML_INPUT_VALUE] && *value[HTML_INPUT_VALUE])) {
d5130 1
d5134 3
d5139 2
a5140 1
			 !strcasecomp(I.type, "reset"))
d5142 2
d5151 1
d5156 3
a5158 2
		    (me->UsePlainSpace && !me->HiddenValue),
		    me->UsePlainSpace, me->HiddenValue);
d5241 3
d5307 1
a5307 1
		 *   treated as part of the editing window, nor be
d5316 3
d5328 6
d5368 4
a5371 3
					   (I.value[i] ==  ' ' ?
					    HT_NON_BREAK_SPACE : I.value[i]));
		    while (i < chars)
d5374 4
d5391 2
a5392 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: TEXTAREA start tag not within FORM tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d5432 1
a5432 1
	    isdigit((unsigned char)*value[HTML_TEXTAREA_COLS]))
d5434 12
a5445 2
	else
	    StrAllocCopy(me->textarea_cols, "60");
d5449 1
a5449 1
	    isdigit((unsigned char)*value[HTML_TEXTAREA_ROWS]))
d5486 2
a5487 7
	    if (TRACE) {
		fprintf(tfp,
		   "Bad HTML: SELECT start tag in SELECT element.  Faking SELECT end tag. *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d5514 2
a5515 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: OPTION tag not within SELECT tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d5685 1
a5685 1
		keypad_mode == LINKS_AND_FORM_FIELDS_ARE_NUMBERED) {
d5703 1
a5703 1
	 *  Not implemented.  Just treat as a division
d5707 9
d5717 5
d5739 1
a5739 1
	    CTRACE(tfp,
d5741 1
a5741 1
		    MAX_NESTING);
d5746 15
d5765 3
d5773 1
d5779 3
d5788 1
d5791 1
d5796 1
a5796 1
	 *  Not yet implemented.  Just start a new row,
d5799 1
d5819 1
d5830 1
a5830 1
	    me->sp->style->alignment = me->current_default_alignment;
d5834 7
a5840 1
		!(me->List_Nesting_Level >= 0 && !me->inP))
d5842 4
a5845 2
	    else if (!strcasecomp(value[HTML_TR_ALIGN], "right") &&
		!(me->List_Nesting_Level >= 0 && !me->inP))
d5847 3
a5849 2
	    else if (!strcasecomp(value[HTML_TR_ALIGN], "left") ||
		     !strcasecomp(value[HTML_TR_ALIGN], "justify"))
d5851 2
d5857 1
d5863 1
d5865 1
a5865 1
	 *  Not yet implemented.  Just check for an ID link. - FM
d5876 13
d5895 1
a5895 1
	 *  Not yet implemented.  Just check for an ID link. - FM
d5906 19
d5929 1
d5941 2
a5942 1
	 *  Not yet implemented.  Just add a collapsible space and break. - FM
d5945 22
a5966 11
	me->in_word = NO;
	break;

    case HTML_TD:
	if (me->inA) {
	    SET_SKIP_STACK(HTML_A);
	    HTML_end_element(me, HTML_A, include);
	}
	if (me->Underline_Level > 0) {
	    SET_SKIP_STACK(HTML_U);
	    HTML_end_element(me, HTML_U, include);
a5967 6
	UPDATE_STYLE;
	CHECK_ID(HTML_TD_ID);
	/*
	 *  Not yet implemented.  Just add a collapsible space and break. - FM
	 */
	HTML_put_character(me, ' ');
d5985 2
a5986 1
    if (HTML_dtd.tags[ElementNumber].contents != SGML_EMPTY) {
d5988 3
a5990 2
	    CTRACE(tfp, "HTML:begin_element: internal call (level %d), leaving on stack - %s\n",
			me->skip_stack, me->sp->style->name);
d5992 1
a5992 1
	    return;
d5996 2
a5997 2
		if (TRACE) {
		    fprintf(tfp,
d5999 1
a5999 5
			MAX_NESTING);

		} else {
		    HTAlert(HTML_STACK_OVERRUN);
		}
d6002 1
a6002 1
	    return;
d6005 4
a6008 3
	CTRACE(tfp,"HTML:begin_element[%d]: adding style to stack - %s\n",
							(int) STACKLEVEL(me),
							me->new_style->name);
d6012 5
d6019 7
a6027 2
#define REALLY_EMPTY(e) ((HTML_dtd.tags[e].contents == SGML_EMPTY) && \
			 !(HTML_dtd.tags[e].flags & Tgf_nreie))
d6029 1
a6029 1
    if (REALLY_EMPTY(element_number))
d6031 2
a6032 4
	CTRACE(tfp, "STYLE:begin_element:ending EMPTY element style\n");
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
a6033 1
#endif /* USE_HASH */
d6048 1
d6065 1
a6065 1
PRIVATE void HTML_end_element ARGS3(
d6071 1
d6074 3
d6078 1
a6078 1
#ifdef USE_PSRC
d6091 1
a6091 1
		strcpy(buf,tag->name);
d6098 1
a6098 1
	    return;
d6104 2
a6105 2
#ifdef CAREFUL			/* parser assumed to produce good nesting */
    if (element_number != me->sp[0].tag_number &&
d6107 2
a6108 2
	CTRACE(tfp,
		"HTMLText: end of element %s when expecting end of %s\n",
d6110 5
a6114 1
		HTML_dtd.tags[me->sp->tag_number].name);
d6116 1
a6117 1
#endif /* CAREFUL */
d6124 3
a6126 2
	if (!(element_number == HTML_MAP || element_number == HTML_AREA)) {
	    return;
d6135 1
d6142 2
a6143 1
	     me->sp[0].tag_number == HTML_DIR) &&
d6157 4
d6162 3
a6164 2
	     CTRACE(tfp, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
			me->skip_stack, me->sp->style->name);
d6166 18
d6197 1
a6197 1
	    return;
d6206 1
a6206 1
	    return;
d6212 2
a6213 1
	     me->sp[0].tag_number == HTML_DIR) &&
d6225 1
a6225 1
	    return;
d6227 23
d6251 4
a6254 3
	    CTRACE(tfp, "HTML:end_element[%d]: Popped style off stack - %s\n",
			(int) STACKLEVEL(me),
			me->sp->style->name);
d6256 2
a6257 2
	    CTRACE(tfp,
  "Stack underflow error!  Tried to pop off more styles than exist in stack\n");
d6260 7
a6266 2
    if (BreakFlag == TRUE)
	return;
d6272 2
a6273 6
	if (TRACE) {
	    fprintf(tfp, "Bad HTML: Missing TEXTAREA end tag\n");
	} else if (!me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
d6287 2
a6288 2
	    if (TRACE) {
		fprintf(tfp,
d6294 1
a6294 5
			me->inA ? "A" : "");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d6300 2
a6301 1
	    !strcmp(me->node_anchor->address, LYlist_temp_url())) {
d6331 1
a6331 1
	    if ((LYMultiBookmarks == TRUE) ||
d6334 2
d6373 3
a6375 2
	CTRACE(tfp, "HTML: STYLE content =\n%s\n",
			    me->style_block.data);
d6385 2
a6386 2
	CTRACE(tfp, "HTML: SCRIPT content =\n%s\n",
			    me->script.data);
d6392 2
a6393 2
	    if (TRACE) {
		fprintf(tfp,
d6399 1
a6399 5
			me->inA ? "A" : "");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d6436 6
a6441 2
	if (me->Division_Level >= 0)
	    me->sp->style->alignment =
d6443 2
d6446 6
a6451 1
	UPDATE_STYLE;
a6452 2
	if (me->List_Nesting_Level >= 0)
	    HText_NegateLineOne(me->text);
d6489 1
a6489 1
	LYHandleP(me,
d6491 1
a6491 1
		 include,
d6522 1
a6522 1
	    CTRACE(tfp, "Ending underline\n");
d6524 1
a6524 1
	    CTRACE(tfp, "Underline Level is %d\n", me->Underline_Level);
a6537 1
    case HTML_SUB:
d6543 4
d6592 1
d6594 1
d6596 1
d6621 1
d6623 1
d6625 1
d6627 1
d6630 6
a6635 2
	CTRACE(tfp, "HTML_end_element: Reducing List Nesting Level to %d\n",
		    me->List_Nesting_Level);
d6668 6
a6673 1

d6707 5
a6711 13
	if (me->inFIGwithP) {
	    LYEnsureDoubleSpace(me);
	} else {
	    HTML_put_character(me, ' ');  /* space char may be ignored */
	}
	LYResetParagraphAlignment(me);
	me->inFIGwithP = FALSE;
	me->inFIG = FALSE;
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
	if (me->List_Nesting_Level >= 0) {
	    UPDATE_STYLE;
	    HText_NegateLineOne(me->text);
	}
d6720 2
a6721 1
	    char *start = NULL, *first_end = NULL;
d6737 2
a6738 1
		} else if (s == 0 && !strncasecomp(cp, "<PARAM", 6)) {
d6740 2
a6741 1
		} else if (!strncasecomp(cp, "<OBJECT", 7)) {
d6745 2
a6746 1
		} else if (!strncasecomp(cp, "</OBJECT", 8)) {
d6749 1
d6751 8
d6762 10
d6773 37
d6812 8
a6819 12
		 *  end tags, so restore an end tag to the content, and
		 *  pass a dummy start tag to the SGML parser so that it
		 *  will resume the accumulation of OBJECT content. - FM
		 */
		CTRACE(tfp, "HTML: Nested OBJECT tags.  Recycling.\n");
		if (*include == NULL) {
		    StrAllocCopy(*include, "<OBJECT>");
		} else {
		    if (0 && strstr(*include, me->object.data) == NULL) {
			StrAllocCat(*include, "<OBJECT>");
		    }
		}
d6822 2
a6823 1
		change_paragraph_style(me, me->sp->style);
a6825 15
	    if (s < e) {
		/*
		 *  We had more end tags than start tags, so
		 *  we have bad HTML or otherwise misparsed. - FM
		 */
		if (TRACE) {
		    fprintf(tfp,
  "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",
			    me->object.data);
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
		goto End_Object;
	    }
d6832 1
a6832 1
	    CTRACE(tfp, "HTML:OBJECT content:\n%s\n", me->object.data);
d6843 1
a6843 1
		if (me->object_id && *me->object_id)
d6845 1
a6845 1
		CTRACE(tfp, "HTML: DECLAREd OBJECT.  Ignoring!\n");
d6855 1
a6855 1
	    if (me->object_name != NULL) {
d6858 1
a6858 1
		CTRACE(tfp, "HTML: NAMEd OBJECT.  Ignoring!\n");
d6874 21
a6894 6
		    *first_end = '\0';
		    data = NULL;
		    StrAllocCopy(data, start);
		    if (e > 1) {
			for (i = e; i > 1; i--) {
			    StrAllocCat(data, "</OBJECT><OBJECT>");
d6896 7
a6903 6
		    StrAllocCat(data, "</OBJECT>");
		    StrAllocCat(*include, data);
		    CTRACE(tfp, "HTML: Recycling nested OBJECT%s.\n",
					(e > 1) ? "s" : "");
		    FREE(data);
		    goto End_Object;
d6905 2
a6906 7
		    if (TRACE) {
			fprintf(tfp,
     "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n");
		    } else if (!me->inBadHTML) {
			HTUserMsg(BAD_HTML_USE_TRACE);
			me->inBadHTML = TRUE;
		    }
d6912 10
a6921 4
	     *	If it's content has SHAPES, convert it to FIG. - FM
	     */
	    if (me->object_shapes == TRUE) {
		CTRACE(tfp, "HTML: OBJECT has SHAPES.  Converting to FIG.\n");
d6948 2
a6949 2
	    if (me->object_usemap != NULL) {
		CTRACE(tfp, "HTML: OBJECT has USEMAP.  Converting to IMG.\n");
d6951 2
d6996 47
d7049 1
a7049 1
	    if (me->object_id && *me->object_id)
d7055 3
a7057 1
	    if (me->object.size > 1)
d7059 1
d7070 2
a7071 1
		if (me->object_data != NULL &&
d7084 2
d7106 1
a7106 14
	HTChunkClear(&me->object);
	me->object_started = FALSE;
	me->object_declare = FALSE;
	me->object_shapes = FALSE;
	me->object_ismap = FALSE;
	FREE(me->object_usemap);
	FREE(me->object_id);
	FREE(me->object_title);
	FREE(me->object_data);
	FREE(me->object_type);
	FREE(me->object_classid);
	FREE(me->object_codebase);
	FREE(me->object_codetype);
	FREE(me->object_name);
d7108 2
a7109 1
	change_paragraph_style(me, me->sp->style);  /* Often won't really change */
d7148 2
a7149 6
	    if (TRACE) {
		fprintf(tfp, "Bad HTML: Unmatched FORM end tag\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d7151 1
d7165 2
a7166 7
	    if (TRACE) {
		fprintf(tfp,
		   "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d7218 2
a7219 6
		if (TRACE) {
		    fprintf(tfp, "Bad HTML: Unmatched TEXTAREA end tag\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
a7252 1
	    data = me->textarea.data;
d7265 3
a7267 3
	     *	SGML unescape any character references in TEXTAREA
	     *	content, then parse it into individual lines
	     *	to be handled as a series of INPUT fields (ugh!).
d7271 5
d7279 23
a7301 1
	    TRANSLATE_AND_UNESCAPE_ENTITIES5(&me->textarea.data,
d7304 5
a7308 1
						    me->UsePlainSpace, me->HiddenValue);
d7348 1
a7348 1
			temp[j] = (temp[j+1] ? ' ' : '\0');
d7381 1
a7381 1
			temp[j] = (temp[j+1] ? ' ' : '\0');
d7423 2
a7424 6
		if (TRACE) {
		    fprintf(tfp, "Bad HTML: Unmatched SELECT end tag *****\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d7442 3
a7444 7
		if (TRACE) {
		    fprintf(tfp,
			    "Bad HTML: SELECT end tag not within FORM element *****\n");
		} else if (!me->inBadHTML) {
		    HTUserMsg(BAD_HTML_USE_TRACE);
		    me->inBadHTML = TRUE;
		}
d7500 9
a7508 1
		    else
d7510 5
d7541 3
d7545 1
d7556 7
d7570 1
d7584 2
a7588 2
	break;

d7590 1
d7630 12
d7643 1
d7645 2
a7646 2
    TrimColorClass(HTML_dtd.tags[element_number].name,
		   Style_className, &hcode);
d7649 4
a7652 4
    FastTrimColorClass(HTML_dtd.tags[element_number].name,
		       HTML_dtd.tags[element_number].name_len,
		       Style_className,
		       &Style_className_end, &hcode);
d7656 7
a7662 8
    if (!REALLY_EMPTY(element_number))
    {
	CTRACE(tfp, "STYLE:end_element: ending non-EMPTY style\n");
#if !defined(USE_HASH)
	HText_characterStyle(me->text, element_number+STARTAT, STACK_OFF);
#else
	HText_characterStyle(me->text, HCODE_TO_STACK_OFF(hcode), STACK_OFF);
#endif /* USE_HASH */
d7665 1
d7708 2
d7738 1
a7738 1
	    CTRACE(tfp,"HTML_free: Ending underline\n");
d7743 1
d7759 3
a7761 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: SELECT or OPTION not ended properly *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d7767 2
a7768 2
	    CTRACE(tfp, "HTML_free: ***** leftover option data: %s\n",
			me->option.data);
d7778 3
a7780 7
	    if (TRACE) {
		fprintf(tfp,
			"Bad HTML: TEXTAREA not used properly *****\n");
	    } else if (!me->inBadHTML) {
		HTUserMsg(BAD_HTML_USE_TRACE);
		me->inBadHTML = TRUE;
	    }
d7786 2
a7787 2
	    CTRACE(tfp, "HTML_free: ***** leftover textarea data: %s\n",
			me->textarea.data);
d7808 5
d7825 3
a7827 7
	if (TRACE) {
	    fprintf(tfp,
		    "Bad HTML: SELECT or OPTION not ended properly *****\n");
	} else if (!me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
d7830 2
a7831 2
	    fprintf(tfp, "HTML_free: ***** leftover option data: %s\n",
		    me->option.data);
d7841 3
a7843 7
	if (TRACE) {
	    fprintf(tfp,
		    "Bad HTML: TEXTAREA not used properly *****\n");
	} else if (!me->inBadHTML) {
	    HTUserMsg(BAD_HTML_USE_TRACE);
	    me->inBadHTML = TRUE;
	}
d7846 2
a7847 2
	    fprintf(tfp, "HTML_free: ***** leftover textarea data: %s\n",
		    me->textarea.data);
d7876 1
d7920 1
a7920 2
	    fprintf(tfp,
		    "HTML_abort: SELECT or OPTION not ended properly *****\n");
d7922 2
a7923 2
	    fprintf(tfp, "HTML_abort: ***** leftover option data: %s\n",
		    me->option.data);
d7934 1
a7934 2
	    fprintf(tfp,
		    "HTML_abort: TEXTAREA not used properly *****\n");
d7936 2
a7937 2
	    fprintf(tfp, "HTML_abort: ***** leftover textarea data: %s\n",
		    me->textarea.data);
d7970 2
d8095 1
a8095 1
	exit_immediately (-1);
d8098 1
a8098 1
    me = (HTStructured*) calloc(sizeof(*me),1);
d8118 3
a8120 9
    me->title.size = 0;
    me->title.growby = 128;
    me->title.allocated = 0;
    me->title.data = NULL;

    me->object.size = 0;
    me->object.growby = 128;
    me->object.allocated = 0;
    me->object.data = NULL;
d8135 1
a8135 4
    me->option.size = 0;
    me->option.growby = 128;
    me->option.allocated = 0;
    me->option.data = NULL;
d8141 1
a8141 4
    me->textarea.size = 0;
    me->textarea.growby = 128;
    me->textarea.allocated = 0;
    me->textarea.data = NULL;
d8150 5
a8154 14
    me->math.size = 0;
    me->math.growby = 128;
    me->math.allocated = 0;
    me->math.data = NULL;

    me->style_block.size = 0;
    me->style_block.growby = 128;
    me->style_block.allocated = 0;
    me->style_block.data = NULL;

    me->script.size = 0;
    me->script.growby = 128;
    me->script.allocated = 0;
    me->script.data = NULL;
a8219 47
#ifdef NOTUSED_FOTEMODS
    /*
    **	If the anchor already has stage info, make sure that it is
    **	appropriate for the current display charset.  HTMIMEConvert()
    **	does this for the http and https schemes, and HTCharsetFormat()
    **	does it for the file and and ftp schemes, be we need to do it,
    **	if necessary, for the gateway schemes. - FM
    */
    if (me->node_anchor->UCStages) {
	if (HTAnchor_getUCLYhndl(me->node_anchor,
				 UCT_STAGE_STRUCTURED) != current_char_set) {
	    /*
	    **	We are reloading due to a change in the display character
	    **	set.  Free the stage info and let the stage info creation
	    **	mechanisms create a new UCStages structure appropriate for
	    **	the current display character set. - FM
	    */
	    FREE(anchor->UCStages);
	} else if (HTAnchor_getUCLYhndl(me->node_anchor,
					UCT_STAGE_MIME) == current_char_set) {
	    /*
	    **	The MIME stage is set to the current display character
	    **	set.  If it is CJK, and HTCJK does not point to a CJK
	    **	character set, assume we are reloading due to a raw
	    **	mode toggle and reset the MIME and PARSER stages to
	    **	an ISO Latin 1 default. - FM
	    */
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(me->node_anchor,
							UCT_STAGE_MIME);
	    if (p_in->enc == UCT_ENC_CJK && HTCJK == NOCJK) {
		HTAnchor_resetUCInfoStage(me->node_anchor, LATIN1,
					  UCT_STAGE_MIME,
					  UCT_SETBY_DEFAULT);
		HTAnchor_setUCInfoStage(me->node_anchor, LATIN1,
					UCT_STAGE_MIME,
					UCT_SETBY_DEFAULT);
		HTAnchor_resetUCInfoStage(me->node_anchor, LATIN1,
					  UCT_STAGE_PARSER,
					  UCT_SETBY_DEFAULT);
		HTAnchor_setUCInfoStage(me->node_anchor, LATIN1,
					UCT_STAGE_PARSER,
					UCT_SETBY_DEFAULT);
	    }
	}
    }
#endif /* NOTUSED_FOTEMODS */

a8255 5
#ifdef NOTUSED_FOTEMODS
    UCSetTransParams(&me->T,
		     me->inUCLYhndl, me->inUCI,
		     me->outUCLYhndl, me->outUCI);
#endif
d8265 10
d8279 50
d8332 1
a8332 2
    if (me->fp)
	LYCloseTempFP(me->fp);
d8343 16
d8367 9
a8375 4
    if (me->fp)
	fputc(c_in, me->fp);
    else
	HTChunkPutc(me->chunk, c_in);
d8383 9
a8391 4
    if (me->fp)
	fputs(str, me->fp);
    else
	HTChunkPuts(me->chunk, str);
d8400 11
a8410 4
    if (me->fp)
	fwrite(str, 1, l, me->fp);
    else
	HTChunkPutb(me->chunk, str, l);
d8442 1
a8442 1
	CTRACE(tfp, "Protocol is \"%s\"; not caching\n", p->name);
d8454 1
d8456 1
d8460 1
d8463 3
a8465 5
	if (source_cache_filename) {
	    CTRACE(tfp, "Reusing source cache file %s\n",
		   source_cache_filename);
	    FREE(stream);
	    return target;
d8474 3
a8476 3
	if (!(stream->fp = LYOpenTemp(filename, HTML_SUFFIX, "wb"))) {
	    CTRACE(tfp, "Cannot get source cache file for URL %s\n",
		   HTAnchor_address((HTAnchor *)anchor));
d8481 1
a8481 4
	/*
	 * Yes, this is a Gross And Disgusting Hack(TM), I know...
	 */
	StrAllocCopy(source_cache_filename, filename);
d8483 2
a8484 2
	CTRACE(tfp, "Caching source for URL %s in file %s\n",
	       HTAnchor_address((HTAnchor *)anchor), filename);
d8488 4
a8491 5
	if (source_cache_chunk) {
	    CTRACE(tfp, "Reusing source memory cache %p\n",
		   (void *)source_cache_chunk);
	    FREE(stream);
	    return target;
d8494 10
a8503 4
	/* I think this is right... */
	source_cache_chunk = stream->chunk = HTChunkCreate(128);
	CTRACE(tfp, "Caching source for URL %s in memory cache %p\n",
	       HTAnchor_address((HTAnchor *)anchor), (void *)stream->chunk);
d8509 2
a8525 1
#ifdef SOURCE_CACHE
a8528 3
#else
    return SGML_new(&HTML_dtd, anchor, HTML_new(anchor, pres->rep_out, sink));
#endif
a8586 1
#ifdef SOURCE_CACHE
a8589 3
#else
    return SGML_new(&HTML_dtd, anchor, HTMLGenerator(intermediate));
#endif
d8599 1
a8599 1
**	It is registered in HTInit.c, but never actually used by lynx.
d8608 2
a8609 2

    (*sink->isa->put_string)(sink, "/* ");	/* Before even title */
d8613 2
a8614 2
/*    HTML_put_string(html,html->comment_start); */
#ifdef SOURCE_CACHE
a8616 3
#else
    return SGML_new(&HTML_dtd, anchor, html);
#endif
a8632 1
#ifdef SOURCE_CACHE
a8635 3
#else
    return SGML_new(&HTML_dtd, anchor, HTML_new(anchor, WWW_PRESENT, NULL));
#endif
d8686 21
d8708 1
d8735 1
a8735 1
    if ( verbose_img ) {
@


1.1
log
@Initial revision
@
text
@d14 2
a15 2
#include "HTUtils.h"
#include "tcp.h"
d18 29
a46 29
#include "HTChunk.h"
#include "HText.h"
#include "HTStyle.h"
#include "HTML.h"

#include "HTCJK.h"
#include "HTAtom.h"
#include "HTAnchor.h"
#include "HTMLGen.h"
#include "HTParse.h"
#include "HTList.h"
#include "UCMap.h"
#include "UCDefs.h"
#include "UCAux.h"

#include "LYGlobalDefs.h"
#include "LYCharUtils.h"
#include "LYCharSets.h"

#include "HTAlert.h"
#include "HTFont.h"
#include "HTForms.h"
#include "HTNestedList.h"
#include "GridText.h"
#include "LYSignal.h"
#include "LYUtils.h"
#include "LYMap.h"
#include "LYList.h"
#include "LYBookmark.h"
d49 1
a49 2
#include "LYCurses.h"
#include "HTVMSUtils.h"
d52 4
d57 4
a60 3
#include "AttrList.h"
#include "LYHash.h"
#include "LYStyle.h"
d63 16
a78 1
char Style_className[16384];
d81 2
a82 2
#include "LYexit.h"
#include "LYLeaks.h"
d84 1
a84 1
#define FREE(x) if (x) {free(x); x = NULL;}
d96 6
d103 1
d106 1
a106 1
PRIVATE HTStyleSheet * styleSheet;	/* Application-wide */
d110 1
a110 1
PUBLIC  HTStyle *styles[HTML_ELEMENTS+31]; /* adding 24 nested list styles  */
d113 1
a113 1
PRIVATE HTStyle *default_style;
d128 17
a144 5
/*		Forward declarations of routines
*/
PRIVATE void get_styles NOPARAMS;
PRIVATE void change_paragraph_style PARAMS((HTStructured * me,
					    HTStyle * style));
d164 1
a164 1
a sequence of styles, rather than a nested tree of styles. In this
d212 12
d263 1
a263 1
	if (c != '\n' && c != '\t' && c != '\r')
d265 7
a271 1
	else
d273 1
d385 8
a392 5
		if (me->in_word) {
		    if (HText_getLastChar(me->text) != ' ') {
			me->inP = TRUE;
			me->inLABEL = FALSE;
			HText_appendCharacter(me->text, ' ');
a393 1
		    me->in_word = NO;
d416 1
a416 1
	HText_setLastChar(me->text, ' '); /* set it to a generic seperater */
d421 1
a421 1
	 *  seperater if there was one
d424 1
a424 1
	HText_setLastChar(me->text, ' '); /* set it to a generic seperater */
d438 13
a450 2
   if (LYMapsOnly || s == NULL)
      return;
d513 1
a513 1
		    return;
d533 6
a538 4
		    if (me->in_word) {
			if (HText_getLastChar(me->text) != ' ')
			    HText_appendCharacter(me->text, ' ');
			me->in_word = NO;
d554 1
a554 1
		    /* set it to a generic seperater */
d561 2
a562 2
		     *	previous seperator, if there was one.  So we
		     *	set LastChar to a generic seperater.
d572 6
d622 1
a622 1
 *  c. HREF="mydoc.htm" 		  -> [...]/otherpath/mydoc.htm
d636 1
a636 1
 *  context an internal link makes no sense (e.g. IMG SRC=).
d641 1
a641 1
   had a real "URL" or not. In the latter case, it will be marked as
d643 1
a643 1
   string (resolution of relative URLs etc.). This variable only used
d660 9
a668 2
char class_string[TEMPSTRINGSIZE];
char prevailing_class[TEMPSTRINGSIZE];
d671 12
d684 6
a689 2
    char myHash[128];
    int hcode;
d691 26
d722 1
a722 1
	HTStructured *, 	me,
d731 2
d739 1
a739 1
    int dest_char_set  = -1;
d743 1
a743 1
    HTChildAnchor *ID_A = NULL; 	     /* HTML_foo_ID anchor */
d748 99
d857 11
a867 4
    if (tag_charset < 0)
	me->tag_charset = me->UCLYhndl;
    else
	me->tag_charset = tag_charset;
d871 27
a897 2
	strcat (Style_className, ";");
	strcat (Style_className, HTML_dtd.tags[element_number].name);
d899 4
a902 1
	if (class_string[0])
d904 15
a918 6
		strcat (Style_className, ".");
		strcat (Style_className, class_string);
		strcat (myHash, ".");
		strcat (myHash, class_string);
#ifdef PREVAIL
		strcpy (prevailing_class, class_string);
d921 1
a921 10
#ifdef PREVAIL
	else if (prevailing_class[0])
	{
		strcat (Style_className, ".");
		strcat (Style_className, prevailing_class);
		strcat (myHash, ".");
		strcat (myHash, prevailing_class);
	}
#endif /* PREVAIL */
	class_string[0]='\0';
d923 3
a925 2
	hcode=hash_code(myHash);
	strtolower(Style_className);
d927 5
a931 1
	if (TRACE)
d933 10
a942 17
		fprintf(stderr, "CSSTRIM:%s -> %d", myHash, hcode);
		if (hashStyles[hcode].code!=hcode)
		{
			char *rp=strrchr(myHash, '.');
			fprintf(stderr, " (undefined) %s\n", myHash);
			if (rp)
			{
				int hcd;
				*rp='\0'; /* trim the class */
				hcd = hash_code(myHash);
				fprintf(stderr, "CSS:%s -> %d", myHash, hcd);
				if (hashStyles[hcd].code!=hcd)
					fprintf(stderr, " (undefined) %s\n", myHash);
				else
					fprintf(stderr, " ca=%d\n", hashStyles[hcd].color);
			}
		}
d944 2
a945 1
			fprintf(stderr, " ca=%d\n", hashStyles[hcode].color);
d947 4
d952 25
a976 5
    if (displayStyles[element_number + STARTAT].color > -2) /* actually set */
    {
	if (TRACE)
		fprintf(stderr, "CSSTRIM: start_element: top <%s>\n", HTML_dtd.tags[element_number].name);
	HText_characterStyle(me->text, hcode, 1);
d978 12
d1010 2
a1011 5
	    if (!(url_type = LYLegitimizeHREF(me, (char**)&base,
					      TRUE, TRUE))) {
		if (TRACE)
		    fprintf(stderr,
			    "HTML: BASE '%s' is not an absolute URL.\n",
d1020 1
a1020 1
		 *  These have a are non-standard form, basically
d1023 1
a1023 1
		 *  should never occur where they would used for
d1104 1
a1104 1
	    LYHandleMETA(me, present, value, (char **)&include);
d1128 1
a1128 1
		url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d1146 1
a1146 1
	    LYFillLocalFileURL((char **)&href,
d1171 1
a1171 1
			LYFillLocalFileURL((char **)&href,
d1177 1
a1177 3
		    if (TRACE)
			fprintf(stderr,
				"HTML: DOC OWNER '%s' found\n", href);
d1202 1
d1208 5
d1215 1
a1215 4
		    if (TRACE) {
			fprintf(stderr,
				"HTML: StyleSheet link found.\n");
		    }
d1235 1
a1235 2
			if (TRACE)
			    fprintf(stderr, "CSS: StyleSheet=%s %d\n", href, res);
d1239 2
a1240 3
		    else
			if (TRACE)
			    fprintf(stderr,
d1242 1
d1244 1
a1244 2
		    if (TRACE)
			fprintf(stderr,
d1250 1
a1265 4
		    !strcasecomp(value[HTML_LINK_REL], "Up") ||
		    !strcasecomp(value[HTML_LINK_REL], "Next") ||
		    !strcasecomp(value[HTML_LINK_REL], "Previous") ||
		    !strcasecomp(value[HTML_LINK_REL], "Prev") ||
a1272 1
		    !strcasecomp(value[HTML_LINK_REL], "Child") ||
a1273 2
		    !strcasecomp(value[HTML_LINK_REL], "Sibling") ||
		    !strcasecomp(value[HTML_LINK_REL], "Parent") ||
a1277 2
		    !strcasecomp(value[HTML_LINK_REL], "Meta") ||
		    !strcasecomp(value[HTML_LINK_REL], "URC") ||
d1283 17
d1303 4
a1306 4
		    !strcasecomp(value[HTML_LINK_REL], "Chapter") ||
		    !strcasecomp(value[HTML_LINK_REL], "Documentation") ||
		    !strcasecomp(value[HTML_LINK_REL], "Biblioentry") ||
		    !strcasecomp(value[HTML_LINK_REL], "Bibliography")) {
d1308 10
d1319 1
a1319 3
		    if (TRACE) {
			fprintf(stderr,
				"HTML: LINK with REL=\"%s\" ignored.\n",
a1320 1
		    }
d1338 1
a1338 3
		if (TRACE) {
		    fprintf(stderr,
			    "HTML: LINK with REL=\"%s\" and no HREF ignored.\n",
a1339 1
		}
d1343 1
d1357 2
d1374 1
a1374 1
		HTML_end_element(me, HTML_A, (char **)&include);
d1385 4
a1388 1
				INTERN_LT);		/* Type */
d1392 2
a1393 2
		if (!HTAnchor_title(dest))
		    HTAnchor_setTitle(dest, title);
d1400 2
d1403 1
a1403 1
		if (dest && dest_char_set >= 0)
a1406 1
		dest_char_set = -1;
d1428 3
a1430 4
		char tmp[1024];
		sprintf(tmp, "link.%s.%s.%s", value[HTML_LINK_CLASS], title, value[HTML_LINK_CLASS]);
		if (TRACE)
			fprintf(stderr, "CSSTRIM:link=%s\n", tmp);
d1438 1
d1460 1
a1460 1
	     *  the HTML 2.0 specs.  HTML 3.0 uses HREF, so we'll
d1468 1
a1468 2
	    url_type = LYLegitimizeHREF(me, (char**)&isindex_href,
					TRUE, TRUE);
d1513 1
a1513 2
		HTAnchor_setPrompt(me->node_anchor,
				   "Enter a database query: ");
d1517 1
a1517 1
	    HTAnchor_setPrompt(me->node_anchor, "Enter a database query: ");
d1563 1
a1563 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d1580 1
a1580 1
	    LYFillLocalFileURL((char **)&href,
d1587 1
a1587 1
		HTML_end_element(me, HTML_A, (char **)&include);
d1635 1
a1635 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d1652 1
a1652 1
	    LYFillLocalFileURL((char **)&href,
d1658 1
a1658 1
		HTML_end_element(me, HTML_A, (char **)&include);
d1718 2
a1719 2
	} else if (TRACE) {
	    fprintf(stderr,
d1847 1
a1847 1
	LYHandleP(me, present, value, (char **)&include, TRUE);
d1853 8
a1860 1
	if ((LYCollapseBRs == FALSE) ||
d1988 1
a1988 3
	    if (TRACE)
		fprintf(stderr,
			"HTML: TAB tag has no attributes. Ignored.\n");
d2001 1
a2001 3
	    if (TRACE)
		fprintf(stderr,
		     "HTML: ALIGN not 'left'. Using space instead of TAB.\n");
d2012 1
a2012 3
	    if (TRACE)
		fprintf(stderr,
			"HTML: Not HT_LEFT. Using space instead of TAB.\n");
d2051 1
a2051 3
		if (TRACE)
		    fprintf(stderr,
		 "HTML: Column out of bounds. Using space instead of TAB.\n");
d2094 1
a2094 1
	    HTML_end_element(me, HTML_FONT, (char **)&include);
d2120 1
a2120 2
	    if (TRACE)
		fprintf(stderr,"Underline Level is %d\n", me->Underline_Level);
d2126 1
a2126 2
	    if (TRACE)
		fprintf(stderr,"Beginning underline\n");
d2128 1
a2128 2
	    if (TRACE)
		fprintf(stderr,"Underline Level is %d\n", me->Underline_Level);
d2234 1
a2234 2
		for (i = 0; note[i] != '\0'; i++)
		    note[i] = TOUPPER(note[i]);
d2241 1
a2241 2
		for (i = 0; note[i] != '\0'; i++)
		    note[i] = TOUPPER(note[i]);
d2305 14
d2320 2
d2334 2
d2715 1
a2715 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d2762 1
a2762 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d2770 2
a2771 2
		for (i = 0; href[i]; i++)
		    href[i] = href[i+7];
d2794 1
a2794 1
	    LYFillLocalFileURL((char **)&href,
d2814 1
a2814 3
		if (TRACE)
		    fprintf(stderr,
			    "HTML: Found invalid HREF=\"%s\" TYPE=\"%s\"!\n",
d2855 2
d2868 1
a2868 1
	    if (dest && dest_char_set >= 0) {
a2884 1
	    dest_char_set = -1;
d2899 1
a2899 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d2918 1
a2918 3
		    if (TRACE)
			fprintf(stderr,
				"HTML: '%s' is an ISMAP script\n",
d2923 1
a2923 3
		    if (TRACE)
			fprintf(stderr,
				"HTML: Designating '%s' as an ISMAP script\n",
d2939 1
a2939 1
	    url_type = LYLegitimizeHREF(me, (char**)&map_href, TRUE, TRUE);
d2987 1
a2987 1
	    LYFillLocalFileURL((char **)&map_href,
d3046 1
a3046 1
						   me->UsePlainSpace, me->HiddenValue);
d3056 3
a3058 2
			StrAllocCopy(alt_string, (title ?
						  title : "[USEMAP]"));
d3060 4
a3063 2
			StrAllocCopy(alt_string, (title ?
						  title : "[ISMAP]"));
d3066 3
a3068 1
						  title : "[LINK]"));
d3072 4
a3075 2
				(present[HTML_IMG_ISOBJECT] ?
						 "(OBJECT)" : "[INLINE]")));
d3081 3
a3083 2
	    StrAllocCopy(alt_string, (title ?
				      title : "[USEMAP]"));
d3087 3
a3089 2
	    StrAllocCopy(alt_string, (title ?
				      title : "[ISMAP]"));
d3093 2
a3094 1
				      title : "[LINK]"));
d3101 2
a3102 1
					     "(OBJECT)" : "[INLINE]")));
d3108 2
a3109 1
	    StrAllocCopy(alt_string, "[USEMAP]");
d3112 1
a3112 3
	if (TRACE) {
	    fprintf(stderr,
		    "HTML IMG: USEMAP=%d ISMAP=%d ANCHOR=%d PARA=%d\n",
a3115 1
	}
d3136 1
a3136 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d3153 1
a3153 1
	    LYFillLocalFileURL((char **)&href,
d3171 2
a3172 1
			HTML_put_string(me, "[ISMAP]");
d3190 1
a3190 1
				  NULL, 		/* Addresss */
d3228 1
d3233 2
a3234 1
				   "(IMAGE)" : "(OBJECT)") : "[IMAGE]"));
d3239 1
a3239 1
				  NULL, 		/* Addresss */
d3252 1
a3252 1
				  NULL, 		/* Addresss */
d3285 1
d3289 2
a3290 1
						  "(IMAGE)" : "[IMAGE]"));
d3298 1
a3298 1
				  NULL, 		/* Addresss */
d3342 2
a3343 1
		    HTML_put_string(me, "[ISMAP]");
d3403 1
a3403 1
				  NULL, 		/* Addresss */
d3417 1
d3482 1
a3482 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d3504 1
a3504 1
	    LYFillLocalFileURL((char **)&href,
d3536 2
a3537 1
						       me->UsePlainSpace, me->HiddenValue);
d3588 1
a3588 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d3607 1
a3607 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d3624 1
a3624 1
		LYFillLocalFileURL((char **)&href,
d3767 1
a3767 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d3784 1
a3784 1
		LYFillLocalFileURL((char **)&href,
d3791 1
a3791 1
		    HTML_end_element(me, HTML_A, (char **)&include);
d3880 1
a3880 1
		collapse_spaces(base);
d3887 2
a3888 3
		if (base[strlen(base)-1] != '/')
		    StrAllocCat(base, "/");
		url_type = LYLegitimizeHREF(me, (char**)&base, TRUE, FALSE);
d3893 1
a3893 1
		LYFillLocalFileURL((char **)&base,
d3919 1
a3919 1
	    url_type = LYLegitimizeHREF(me, (char**)&code, TRUE, FALSE);
d3972 1
a3972 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d3993 1
a3993 1
	    LYFillLocalFileURL((char **)&href,
d4086 1
a4086 1
	    url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d4103 1
a4103 1
		LYFillLocalFileURL((char **)&href,
d4230 1
a4230 4
		if (TRACE) {
		    fprintf(stderr,
			    "HTML: Missing FORM end tag. Faking it!\n");
		}
d4232 1
a4232 1
		HTML_end_element(me, HTML_FORM, (char **)&include);
d4250 1
a4250 1
		url_type = LYLegitimizeHREF(me, (char**)&action, TRUE, TRUE);
d4311 1
a4311 5
		/*
		 *  Force the enctype value to all lower case. - FM
		 */
		for (cp = enctype; *cp; cp++)
		    *cp = TOLOWER(*cp);
d4405 1
a4405 1
		    fprintf(stderr,
d4408 1
a4408 1
		    _statusline(BAD_HTML_USE_TRACE);
a4409 1
		    sleep(MessageSecs);
d4422 1
a4422 1
	     *	for any long values that would extent past the right
d4559 1
d4577 1
a4577 1
	     *	for any long values that would extent past the right
d4612 1
a4612 2
		    if (TRACE)
			fprintf(stderr, "HTML: Ignoring TYPE=\"range\"\n");
d4634 1
a4634 2
		    if (TRACE)
			fprintf(stderr, "HTML: Ignoring TYPE=\"file\"\n");
d4651 1
a4651 1
		    fprintf(stderr,
d4654 1
a4654 1
		    _statusline(BAD_HTML_USE_TRACE);
a4655 1
		    sleep(MessageSecs);
d4670 1
a4670 1
		    fprintf(stderr,
d4673 1
a4673 1
		    _statusline(BAD_HTML_USE_TRACE);
a4674 1
		    sleep(MessageSecs);
d4682 1
a4682 3
		if (TRACE) {
		    fprintf(stderr, "HTML: Missing SELECT end tag, faking it...\n");
		}
d4686 1
a4686 1
		HTML_end_element(me, HTML_SELECT, (char **)&include);
d4716 6
a4721 1
	    if (clickable_images == TRUE &&
d4730 1
a4730 1
		 *  legitiimizing it. - FM
d4732 1
a4732 1
		url_type = LYLegitimizeHREF(me, (char**)&href, TRUE, TRUE);
d4749 1
a4749 1
		    LYFillLocalFileURL((char **)&href,
d4757 1
a4757 1
			HTML_end_element(me, HTML_A, (char **)&include);
d4767 2
a4768 1
		    HTML_put_string(me, "[IMAGE]");
d4791 1
a4791 1
		    current_char_set = 0;	/* Default ISO-Latin1 */
d4849 5
d5020 1
d5032 1
a5032 1
		fprintf(stderr,
d5035 1
a5035 1
		_statusline(BAD_HTML_USE_TRACE);
a5036 1
		sleep(MessageSecs);
d5122 2
a5123 2
		fprintf(stderr,
		   "Bad HTML: SELECT start tag in SELECT element. Faking SELECT end tag. *****\n");
d5125 1
a5125 1
		_statusline(BAD_HTML_USE_TRACE);
a5126 1
		sleep(MessageSecs);
d5131 1
a5131 1
	    HTML_end_element(me, HTML_SELECT, (char **)&include);
d5139 1
a5139 1
		       (char **)&include,
d5155 1
a5155 1
		    fprintf(stderr,
d5158 1
a5158 1
		    _statusline(BAD_HTML_USE_TRACE);
a5159 1
		    sleep(MessageSecs);
d5355 1
a5355 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d5359 1
a5359 1
	    HTML_end_element(me, HTML_U, (char **)&include);
d5369 2
a5370 2
	} else if (TRACE) {
	    fprintf(stderr,
d5409 1
a5409 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d5413 1
a5413 1
	    HTML_end_element(me, HTML_U, (char **)&include);
d5461 1
a5461 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d5465 1
a5465 1
	    HTML_end_element(me, HTML_U, (char **)&include);
d5478 1
a5478 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d5482 1
a5482 1
	    HTML_end_element(me, HTML_U, (char **)&include);
d5491 1
a5491 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d5495 1
a5495 1
	    HTML_end_element(me, HTML_U, (char **)&include);
d5509 1
a5509 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d5513 1
a5513 1
	    HTML_end_element(me, HTML_U, (char **)&include);
d5540 1
a5540 3
	    if (TRACE)
		fprintf(stderr,
	    "HTML:begin_element: internal call (level %d), leaving on stack - %s\n",
d5548 1
a5548 1
		    fprintf(stderr,
d5560 3
a5565 4

	if (TRACE)
	    fprintf(stderr,"HTML:begin_element: adding style to stack - %s\n",
							me->new_style->name);
d5569 7
a5575 5
/* end empty tags straight away */
	if (HTML_dtd.tags[ElementNumber].contents == SGML_EMPTY)
	{
		if (TRACE)
			fprintf(stderr, "STYLE:begin_element:ending EMPTY element style\n");
d5579 1
a5579 1
	HText_characterStyle(me->text, hcode, STACK_OFF);
d5581 11
a5591 24
		{
			char *end, *start=NULL, *lookfrom;
			char tmp[64];
			sprintf(tmp, ";%s", HTML_dtd.tags[element_number].name);
			strtolower(tmp);

			lookfrom = Style_className;
			do
			{
				end = start;
				start = strstr(lookfrom, tmp);
				if (start)
				    lookfrom = start + 1;
			}
			while (start);
			if (end)
				*end='\0';

#if defined(PREVAIL)
			start=strrchr(Style_className, '.');
			if (start)
				strcpy(prevailing_class, (char*)(start+1));
			else
				strcpy(prevailing_class, "");
d5593 1
a5593 6


			if (TRACE)
			fprintf(stderr, "CSS:%s (trimmed %s, SGML_EMPTY)\n", Style_className, tmp);
		}
	}
d5608 1
a5608 1
**	(internal code errors apart) good nesting. The parser checks
d5612 1
a5612 1
	HTStructured *, 	me,
d5620 26
d5649 1
a5649 1
	fprintf(stderr,
d5693 1
a5693 3
	    if (TRACE)
		fprintf(stderr,
	    "HTML:end_element: Internal call (level %d), leaving on stack - %s\n",
d5739 2
a5740 3
	    if (TRACE)
		fprintf(stderr,
			"HTML:end_element: Popped style off stack - %s\n",
d5743 1
a5743 2
	    if (TRACE)
		fprintf(stderr,
d5755 1
a5755 1
	    fprintf(stderr, "Bad HTML: Missing TEXTAREA end tag\n");
d5757 1
a5757 1
	    _statusline(BAD_HTML_USE_TRACE);
a5758 1
	    sleep(MessageSecs);
d5772 1
a5772 1
	if (me->inA || me->inSELECT || me->inTEXTAREA)
d5774 1
a5774 1
		fprintf(stderr,
d5782 1
a5782 1
		_statusline(BAD_HTML_USE_TRACE);
a5783 1
		sleep(MessageSecs);
d5785 1
d5827 3
a5829 1
			StrAllocCat(*include, "<H2><EM>Description:</EM> ");
d5833 2
a5834 2
					 MBM_A_subdescript[i] : "(none)"));
			LYEntify((char **)&temp, TRUE);
d5836 3
a5838 2
			StrAllocCat(*include,
				"<BR><EM>&nbsp;&nbsp;&nbsp;Filepath:</EM> ");
d5842 2
a5843 2
					 MBM_A_subbookmark[i] : "(unknown)"));
			LYEntify((char **)&temp, TRUE);
d5860 1
a5860 2
	if (TRACE) {
	    fprintf(stderr, "HTML: STYLE content =\n%s\n",
a5861 1
	}
d5871 1
a5871 2
	if (TRACE) {
	    fprintf(stderr, "HTML: SCRIPT content =\n%s\n",
a5872 1
	}
d5877 1
a5877 1
	if (me->inA || me->inSELECT || me->inTEXTAREA)
d5879 1
a5879 1
		fprintf(stderr,
d5887 1
a5887 1
		_statusline(BAD_HTML_USE_TRACE);
a5888 1
		sleep(MessageSecs);
d5890 1
d5971 2
a5972 2
	    	 (CONST BOOL*)0, (CONST char **)0,
		 (char **)&include,
d6003 1
a6003 2
	    if (TRACE)
		fprintf(stderr,"Ending underline\n");
d6005 1
a6005 2
	    if (TRACE)
		fprintf(stderr,"Underline Level is %d\n", me->Underline_Level);
d6101 1
a6101 3
	if (TRACE) {
	    fprintf(stderr,
		    "HTML_end_element: Reducing List Nesting Level to %d\n",
a6102 1
	}
d6226 1
a6226 2
		if (TRACE)
		    fprintf(stderr, "HTML: Nested OBJECT tags.  Recycling.\n");
d6245 1
a6245 1
		    fprintf(stderr,
d6249 1
a6249 1
		    _statusline(BAD_HTML_USE_TRACE);
a6250 1
		    sleep(MessageSecs);
d6260 1
a6260 2
	    if (TRACE)
		fprintf(stderr, "HTML:OBJECT content:\n%s\n", me->object.data);
d6273 1
a6273 2
		if (TRACE)
		    fprintf(stderr, "HTML: DECLAREd OBJECT.  Ignoring!\n");
d6286 1
a6286 2
		if (TRACE)
		    fprintf(stderr, "HTML: NAMEd OBJECT.  Ignoring!\n");
d6312 1
a6312 2
		    if (TRACE)
			fprintf(stderr, "HTML: Recycling nested OBJECT%s.\n",
d6318 1
a6318 1
			fprintf(stderr,
a6319 1
			goto End_Object;
d6321 1
a6321 1
			_statusline(BAD_HTML_USE_TRACE);
a6322 2
			sleep(MessageSecs);
			goto End_Object;
d6324 1
d6332 1
a6332 3
		if (TRACE)
		    fprintf(stderr,
		    "HTML: OBJECT has SHAPES.  Converting to FIG.\n");
d6360 1
a6360 3
		if (TRACE)
		    fprintf(stderr,
		    "HTML: OBJECT has USEMAP.  Converting to IMG.\n");
d6517 1
a6517 1
		fprintf(stderr, "Bad HTML: Unmatched FORM end tag\n");
d6519 1
a6519 1
		_statusline(BAD_HTML_USE_TRACE);
a6520 1
		sleep(MessageSecs);
d6537 1
a6537 1
		fprintf(stderr,
d6540 1
a6540 1
		_statusline(BAD_HTML_USE_TRACE);
a6541 1
		sleep(MessageSecs);
d6546 1
a6546 1
	    HTML_end_element(me, HTML_SELECT, (char **)&include);
d6595 1
a6595 1
		    fprintf(stderr, "Bad HTML: Unmatched TEXTAREA end tag\n");
d6597 1
a6597 1
		    _statusline(BAD_HTML_USE_TRACE);
a6598 1
		    sleep(MessageSecs);
d6774 1
a6774 1
		    fprintf(stderr, "Bad HTML: Unmatched SELECT end tag *****\n");
d6776 1
a6776 1
		    _statusline(BAD_HTML_USE_TRACE);
a6777 1
		    sleep(MessageSecs);
d6797 1
a6797 1
		    fprintf(stderr,
d6800 1
a6800 1
		    _statusline(BAD_HTML_USE_TRACE);
a6801 1
		    sleep(MessageSecs);
d6904 5
d6963 11
a6973 24
    {
	char *end, *start=NULL, *lookfrom;
	char tmp[64];
	sprintf(tmp, ";%s", HTML_dtd.tags[element_number].name);
	strtolower(tmp);

	lookfrom = Style_className;
	do
	{
	    end = start;
	    start = strstr(lookfrom, tmp);
	    if (start)
		lookfrom = start + 1;
	}
	while (start);
/* trim the last matching element off the end
** - should match classes here as well (rp)
*/
	if (end)
	    *end='\0';
	hcode=hash_code(lookfrom && *lookfrom ? lookfrom : &tmp[1]);
	if (TRACE)
	    fprintf(stderr, "CSS:%s (trimmed %s, END_ELEMENT)\n", Style_className, tmp);
    }
d6975 1
a6975 1
    if (HTML_dtd.tags[element_number].contents != SGML_EMPTY)
d6977 1
a6977 2
	if (TRACE)
	    fprintf(stderr, "STYLE:end_element: ending non-EMPTY style\n");
d6981 1
a6981 1
	HText_characterStyle(me->text, hcode, STACK_OFF);
a6982 9
#if defined(PREVAIL)
	/* reset the prevailing class to the previous one */
	{
		char *dot=strrchr(Style_className,'.');
		LYstrncpy(prevailing_class,
			  dot ? (char*)(dot+1) : "",
			  (TEMPSTRINGSIZE - 1));
	}
#endif
d7055 1
a7055 2
	    if (TRACE)
		fprintf(stderr,"HTML_free: Ending underline\n");
d7058 1
a7058 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d7062 1
a7062 1
	    HTML_end_element(me, HTML_FONT, (char **)&include);
d7066 1
a7066 1
	    HTML_end_element(me, HTML_FORM, (char **)&include);
d7076 1
a7076 1
		fprintf(stderr,
d7079 1
a7079 1
		_statusline(BAD_HTML_USE_TRACE);
a7080 1
		sleep(MessageSecs);
d7087 1
a7087 2
	    if (TRACE)
		fprintf(stderr, "HTML_free: ***** leftover option data: %s\n",
d7099 1
a7099 1
		fprintf(stderr,
d7102 1
a7102 1
		_statusline(BAD_HTML_USE_TRACE);
a7103 1
		sleep(MessageSecs);
d7110 1
a7110 2
	    if (TRACE)
		fprintf(stderr, "HTML_free: ***** leftover textarea data: %s\n",
d7123 1
a7123 1
	    HTML_start_element(me, HTML_P, 0, 0, -1, (char **)&include);
d7125 1
a7125 1
	    HTML_start_element(me, HTML_EM, 0, 0, -1, (char **)&include);
d7127 2
a7128 2
		"Document has only hidden links. Use the 'l'ist command.");
	    HTML_end_element(me, HTML_EM, (char **)&include);
d7130 1
a7130 1
	    HTML_end_element(me, HTML_P, (char **)&include);
d7145 1
a7145 1
	    fprintf(stderr,
d7148 1
a7148 1
	    _statusline(BAD_HTML_USE_TRACE);
a7149 1
	    sleep(MessageSecs);
d7153 1
a7153 1
	    fprintf(stderr, "HTML_free: ***** leftover option data: %s\n",
d7165 1
a7165 1
	    fprintf(stderr,
d7168 1
a7168 1
	    _statusline(BAD_HTML_USE_TRACE);
a7169 1
	    sleep(MessageSecs);
d7173 1
a7173 1
	    fprintf(stderr, "HTML_free: ***** leftover textarea data: %s\n",
d7195 5
d7221 1
a7221 1
	    HTML_end_element(me, HTML_A, (char **)&include);
d7225 1
a7225 1
	    HTML_end_element(me, HTML_FONT, (char **)&include);
d7229 1
a7229 1
	    HTML_end_element(me, HTML_FORM, (char **)&include);
d7246 1
a7246 1
	    fprintf(stderr,
d7249 1
a7249 1
	    fprintf(stderr, "HTML_abort: ***** leftover option data: %s\n",
d7261 1
a7261 1
	    fprintf(stderr,
d7264 1
a7264 1
	    fprintf(stderr, "HTML_abort: ***** leftover textarea data: %s\n",
d7286 5
d7306 1
d7354 6
a7359 6
    styles[HTML_DLC1] = 	HTStyleNamed(styleSheet, "GlossaryCompact1");
    styles[HTML_DLC2] = 	HTStyleNamed(styleSheet, "GlossaryCompact2");
    styles[HTML_DLC3] = 	HTStyleNamed(styleSheet, "GlossaryCompact3");
    styles[HTML_DLC4] = 	HTStyleNamed(styleSheet, "GlossaryCompact4");
    styles[HTML_DLC5] = 	HTStyleNamed(styleSheet, "GlossaryCompact5");
    styles[HTML_DLC6] = 	HTStyleNamed(styleSheet, "GlossaryCompact6");
d7366 1
a7366 1
    styles[HTML_NOTE] = 	HTStyleNamed(styleSheet, "Note");
d7373 11
d7421 1
a7421 12
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit (-1);
a7433 1
    styleSheet = DefaultStyle();
d7559 5
a7563 1
    Style_className[0] = '\0';
a7564 1
    prevailing_class[0] = '\0';
d7597 1
a7597 1
		HTAnchor_resetUCInfoStage(me->node_anchor, 0,
d7600 1
a7600 1
		HTAnchor_setUCInfoStage(me->node_anchor, 0,
d7603 1
a7603 1
		HTAnchor_resetUCInfoStage(me->node_anchor, 0,
d7606 1
a7606 1
		HTAnchor_setUCInfoStage(me->node_anchor, 0,
d7658 1
a7658 1
	me->targetClass = *stream->isa; 		/* Copy pointers */
d7663 152
d7819 3
d7828 5
d7834 1
d7841 6
d7870 4
a7873 1
/*	    intermediate = HTPlainPresent(pres, anchor, NULL); */
d7877 1
d7893 5
d7899 1
d7908 3
d7924 4
d7929 1
d7937 1
d7946 5
d7952 1
d7956 1
d7975 4
d7986 55
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
