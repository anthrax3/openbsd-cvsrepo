head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.40;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.13;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.54;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.54;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYrcFile.c,v 1.92 2013/11/28 11:22:53 tom Exp $ */
#include <HTUtils.h>
#include <HTFTP.h>
#include <LYUtils.h>
#include <LYrcFile.h>
#include <LYStrings.h>
#include <LYGlobalDefs.h>
#include <LYCharSets.h>
#include <LYBookmark.h>
#include <LYCookie.h>
#include <LYKeymap.h>
#include <HTMLDTD.h>

#include <LYLeaks.h>

#define MSG_ENABLE_LYNXRC N_("Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n")
#define putBool(value) ((value) ? "on" : "off")
/* *INDENT-OFF* */
static Config_Enum tbl_DTD_recovery[] = {
    { "true",		TRUE },
    { "false",		FALSE },
    { "on",		TRUE },
    { "off",		FALSE },
    { "sortasgml",	TRUE },
    { "tagsoup",	FALSE },
    { NULL,		-1 },
};

static Config_Enum tbl_bad_html[] = {
    { "ignore",		BAD_HTML_IGNORE	 },
    { "trace",		BAD_HTML_TRACE	 },
    { "message",	BAD_HTML_MESSAGE },
    { "warn",		BAD_HTML_WARN	 },
    { NULL,		-1		 }
};

#ifdef DIRED_SUPPORT
static Config_Enum tbl_dir_list_style[] = {
    { "FILES_FIRST",	FILES_FIRST },
    { "DIRECTORIES_FIRST", DIRS_FIRST },
    { "MIXED_STYLE",	MIXED_STYLE },
    { NULL,		MIXED_STYLE },
};
#ifdef LONG_LIST
static Config_Enum tbl_dir_list_order[] = {
    { "ORDER_BY_NAME",	ORDER_BY_NAME },
    { "ORDER_BY_TYPE",	ORDER_BY_TYPE },
    { "ORDER_BY_SIZE",  ORDER_BY_SIZE },
    { "ORDER_BY_DATE",	ORDER_BY_DATE },
    { "ORDER_BY_MODE",	ORDER_BY_MODE },
#ifndef NO_GROUPS
    { "ORDER_BY_USER",	ORDER_BY_USER },
    { "ORDER_BY_GROUP",	ORDER_BY_GROUP },
#endif
    { NULL,		ORDER_BY_NAME },
};
#endif /* LONG_LIST */
#endif /* DIRED_SUPPORT */

static Config_Enum tbl_file_sort[] = {
    { "BY_FILENAME",	FILE_BY_NAME },
    { "BY_TYPE",	FILE_BY_TYPE },
    { "BY_SIZE",	FILE_BY_SIZE },
    { "BY_DATE",	FILE_BY_DATE },
    { NULL,		-1 },
};

Config_Enum tbl_keypad_mode[] = {
    { "FIELDS_ARE_NUMBERED", FIELDS_ARE_NUMBERED },
    { "LINKS_AND_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "LINKS_ARE_NUMBERED", LINKS_ARE_NUMBERED },
    { "LINKS_ARE_NOT_NUMBERED", NUMBERS_AS_ARROWS },
    /* obsolete variations: */
    { "LINKS_AND_FORM_FIELDS_ARE_NUMBERED", LINKS_AND_FIELDS_ARE_NUMBERED },
    { "NUMBERS_AS_ARROWS", NUMBERS_AS_ARROWS },
    { NULL,		DEFAULT_KEYPAD_MODE }
};

Config_Enum tbl_multi_bookmarks[] = {
    { "OFF",		MBM_OFF },
    { "STANDARD",	MBM_STANDARD },
    { "ON",		MBM_STANDARD },
    { "ADVANCED",	MBM_ADVANCED },
    { NULL,		-1 }
};

/* the names in this table are used as lowercase in HTTP.c */
Config_Enum tbl_preferred_encoding[] = {
    { "none",		encodingNONE },
#if defined(USE_ZLIB) || defined(GZIP_PATH)
    { "gzip",		encodingGZIP },
    { "deflate",	encodingDEFLATE },
#endif
#if defined(USE_ZLIB) || defined(COMPRESS_PATH)
    { "compress",	encodingCOMPRESS },
#endif
#if defined(USE_BZLIB) || defined(BZIP2_PATH)
    { "bzip2",		encodingBZIP2 },
#endif
    { "all",		encodingALL },
    { NULL,		-1 }
};

Config_Enum tbl_preferred_media[] = {
    { "INTERNAL",	mediaOpt1 },
    { "CONFIGFILE",	mediaOpt2 },
    { "USER",		mediaOpt3 },
    { "SYSTEM",		mediaOpt4 },
    { "ALL",		mediaALL },
    { NULL,		-1 }
};

static Config_Enum tbl_show_colors[] = {
    { "default",	SHOW_COLOR_UNKNOWN },
    { "default",	SHOW_COLOR_OFF },
    { "default",	SHOW_COLOR_ON },
    { "on",		SHOW_COLOR_UNKNOWN },
    { "off",		SHOW_COLOR_UNKNOWN },
    { "never",		SHOW_COLOR_NEVER },
    { "always",		SHOW_COLOR_ALWAYS },
    { NULL,		SHOW_COLOR_UNKNOWN }
};

Config_Enum tbl_transfer_rate[] = {
    { "NONE",		rateOFF },
    { "KB",		rateKB },
    { "TRUE",		rateKB },
    { "BYTES",		rateBYTES },
    { "FALSE",		rateBYTES },
#ifdef USE_READPROGRESS
    { "KB,ETA",		rateEtaKB },
    { "BYTES,ETA",	rateEtaBYTES },
    { "KB2,ETA",	rateEtaKB2 },
    { "BYTES2,ETA",	rateEtaBYTES2 },
#endif
#ifdef USE_PROGRESSBAR
    { "METER",		rateBAR },
    { "FALSE",		rateBAR },
#endif
    { NULL,		-1 },
};

Config_Enum tbl_user_mode[] = {
    { "ADVANCED",	ADVANCED_MODE },
    { "INTERMEDIATE",	INTERMEDIATE_MODE },
    { "NOVICE",		NOVICE_MODE },
    { NULL,		NOVICE_MODE }
};

static Config_Enum tbl_visited_links[] = {
    { "FIRST_REVERSED",	VISITED_LINKS_AS_FIRST_V | VISITED_LINKS_REVERSE },
    { "FIRST",		VISITED_LINKS_AS_FIRST_V },
    { "TREE",		VISITED_LINKS_AS_TREE    },
    { "LAST_REVERSED",	VISITED_LINKS_AS_LATEST | VISITED_LINKS_REVERSE },
    { "LAST",		VISITED_LINKS_AS_LATEST  },
    { NULL,		DEFAULT_VISITED_LINKS }
};

Config_Enum tbl_force_prompt[] = {
    { "prompt",		FORCE_PROMPT_DFT	},
    { "yes",		FORCE_PROMPT_YES	},
    { "no",		FORCE_PROMPT_NO		},
    { NULL,		-1			}
};
/* *INDENT-ON* */

static BOOL getBool(char *src)
{
    return (BOOL) (!strncasecomp(src, "on", 2) || !strncasecomp(src, "true", 4));
}

const char *LYputEnum(Config_Enum * table, int value)
{
    while (table->name != 0) {
	if (table->value == value) {
	    return table->name;
	}
	table++;
    }
    return "?";
}

BOOL LYgetEnum(Config_Enum * table, const char *name,
	       int *result)
{
    Config_Enum *found = 0;
    unsigned len = (unsigned) strlen(name);
    int match = 0;

    if (len != 0) {
	while (table->name != 0) {
	    if (!strncasecomp(table->name, name, (int) len)) {
		found = table;
		if (!strcasecomp(table->name, name)) {
		    match = 1;
		    break;
		}
		++match;
	    }
	    table++;
	}
	if (match == 1) {	/* if unambiguous */
	    *result = found->value;
	    return TRUE;
	}
    }
    return FALSE;		/* no match */
}

/* these are for data that are normally not read/written from .lynxrc */
#define PARSE_SET(n,v,h)   {n,    1, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define PARSE_ARY(n,v,t,h) {n,    1, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define PARSE_ENU(n,v,t,h) {n,    1, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define PARSE_LIS(n,v,h)   {n,    1, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_STR(n,v,h)   {n,    1, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define PARSE_FUN(n,v,w,h) {n,    1, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define PARSE_MBM(n,h)     {n,    1, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

/* these are for data that are optionally read/written from .lynxrc */
#define MAYBE_SET(n,v,h)   {n,    0, CONF_BOOL,  UNION_SET(v), 0, 0, 0, h}
#define MAYBE_ARY(n,v,t,h) {n,    0, CONF_ARRAY, UNION_INT(v), t, 0, 0, h}
#define MAYBE_ENU(n,v,t,h) {n,    0, CONF_ENUM,  UNION_INT(v), 0, t, 0, h}
#define MAYBE_LIS(n,v,h)   {n,    0, CONF_LIS,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_STR(n,v,h)   {n,    0, CONF_STR,   UNION_STR(v), 0, 0, 0, h}
#define MAYBE_FUN(n,v,w,h) {n,    0, CONF_FUN,   UNION_FUN(v), 0, 0, w, h}
#define MAYBE_MBM(n,h)     {n,    0, CONF_MBM,   UNION_DEF(0), 0, 0, 0, h}

#define PARSE_NIL          {NULL, 1, CONF_NIL,   UNION_DEF(0), 0, 0, 0, 0}

typedef enum {
    CONF_NIL = 0
    ,CONF_ARRAY
    ,CONF_BOOL
    ,CONF_FUN
    ,CONF_INT
    ,CONF_ENUM
    ,CONF_LIS
    ,CONF_MBM
    ,CONF_STR
} Conf_Types;

typedef struct config_type {
    const char *name;
    int enabled;		/* see lynx.cfg ENABLE_LYNXRC "off" lines */
    Conf_Types type;
      ParseData;
    const char **strings;
    Config_Enum *table;
    void (*write_it) (FILE *fp, struct config_type *);
    const char *note;
} Config_Type;

static int get_assume_charset(char *value)
{
    int i;

    for (i = 0; i < LYNumCharsets; ++i) {
	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
	    UCLYhndl_for_unspec = i;
	    break;
	}
    }
    return 0;
}

static void put_assume_charset(FILE *fp, struct config_type *tbl)
{
    int i;

    for (i = 0; i < LYNumCharsets; ++i)
	fprintf(fp, "#    %s\n", LYCharSet_UC[i].MIMEname);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
}

static int get_display_charset(char *value)
{
    int i = 0;

    i = UCGetLYhndl_byAnyName(value);	/* by MIME or full name */
    if (i >= 0)
	current_char_set = i;
    return 0;
}

static void put_display_charset(FILE *fp, struct config_type *tbl)
{
    int i;

    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "%s=%s\n\n", tbl->name, LYchar_set_names[current_char_set]);
}

static int get_editor(char *value)
{
    if (!system_editor)
	StrAllocCopy(editor, value);
    return 0;
}

static void put_editor(FILE *fp, struct config_type *tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, NonNull(editor));
}

int get_tagsoup(char *value)
{
    int found = Old_DTD;

    if (LYgetEnum(tbl_DTD_recovery, value, &found)
	&& Old_DTD != found) {
	Old_DTD = found;
	HTSwitchDTD(!Old_DTD);
    }
    return 0;
}

static void put_tagsoup(FILE *fp, struct config_type *tbl)
{
    fprintf(fp, "%s=%s\n\n", tbl->name, LYputEnum(tbl_DTD_recovery, Old_DTD));
}

/* This table is searched ignoring case */
/* *INDENT-OFF* */
static Config_Type Config_Table [] =
{
    PARSE_SET(RC_ACCEPT_ALL_COOKIES,    LYAcceptAllCookies, N_("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
")),
    MAYBE_FUN(RC_ASSUME_CHARSET,        get_assume_charset, put_assume_charset, MSG_ENABLE_LYNXRC),
#ifndef DISABLE_FTP
    PARSE_STR(RC_ANONFTP_PASSWORD,      anonftp_password, N_("\
anonftp_password allows the user to tell Lynx to use the personal\n\
email address as the password for anonymous ftp.  If no value is given,\n\
Lynx will use the personal email address.  Set anonftp_password\n\
to a different value if you choose.\n\
")),
#endif
    MAYBE_ENU(RC_BAD_HTML,              cfg_bad_html,      tbl_bad_html,
	      MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_BOOKMARK_FILE,         bookmark_page,     N_("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
")),
    PARSE_SET(RC_CASE_SENSITIVE_SEARCHING, LYcase_sensitive, N_("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
")),
    PARSE_FUN(RC_CHARACTER_SET,         get_display_charset, put_display_charset, N_("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
")),
    PARSE_LIS(RC_COOKIE_ACCEPT_DOMAINS, LYCookieAcceptDomains, N_("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
")),
#ifdef USE_PERSISTENT_COOKIES
    PARSE_STR(RC_COOKIE_FILE,	        LYCookieFile, N_("\
cookie_file specifies the file from which to read persistent cookies.\n\
The default is ~/" FNAME_LYNX_COOKIES ".\n\
")),
#endif
    PARSE_STR(RC_COOKIE_LOOSE_INVALID_DOMAINS, LYCookieLooseCheckDomains, N_("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
")),
    PARSE_STR(RC_COOKIE_QUERY_INVALID_DOMAINS, LYCookieQueryCheckDomains, NULL),
    PARSE_LIS(RC_COOKIE_REJECT_DOMAINS, LYCookieRejectDomains, NULL),
    PARSE_STR(RC_COOKIE_STRICT_INVALID_DOMAIN, LYCookieStrictCheckDomains, NULL),
#ifdef DIRED_SUPPORT
#ifdef LONG_LIST
    PARSE_ENU(RC_DIR_LIST_ORDER,        dir_list_order,     tbl_dir_list_order, N_("\
dir_list_order specifies the directory list order under DIRED_SUPPORT\n\
(if implemented).  The default is \"ORDER_BY_NAME\"\n\
")),
#endif
    PARSE_ENU(RC_DIR_LIST_STYLE,        dir_list_style,     tbl_dir_list_style, N_("\
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
")),
#endif
    MAYBE_STR(RC_DISPLAY,               x_display,          MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_EMACS_KEYS,            emacs_keys, N_("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
")),
    PARSE_FUN(RC_FILE_EDITOR,           get_editor,         put_editor, N_("\
file_editor specifies the editor to be invoked when editing local files\n\
or sending mail.  If no editor is specified, then file editing is disabled\n\
unless it is activated from the command line, and the built-in line editor\n\
will be used for sending mail.\n\
")),
#ifndef DISABLE_FTP
    PARSE_ENU(RC_FILE_SORTING_METHOD,   HTfileSortMethod,   tbl_file_sort, N_("\
The file_sorting_method specifies which value to sort on when viewing\n\
file lists such as FTP directories.  The options are:\n\
   BY_FILENAME -- sorts on the name of the file\n\
   BY_TYPE     -- sorts on the type of the file\n\
   BY_SIZE     -- sorts on the size of the file\n\
   BY_DATE     -- sorts on the date of the file\n\
")),
#endif
    MAYBE_ENU(RC_FORCE_COOKIE_PROMPT,   cookie_noprompt,    tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#ifdef USE_SSL
    MAYBE_ENU(RC_FORCE_SSL_PROMPT,      ssl_noprompt,       tbl_force_prompt,
	      MSG_ENABLE_LYNXRC),
#endif
#ifndef DISABLE_FTP
    MAYBE_SET(RC_FTP_PASSIVE,           ftp_passive,        MSG_ENABLE_LYNXRC),
#endif
    MAYBE_SET(RC_HTML5_CHARSETS,        html5_charsets,     MSG_ENABLE_LYNXRC),
#ifdef EXP_KEYBOARD_LAYOUT
    PARSE_ARY(RC_KBLAYOUT,              current_layout,     LYKbLayoutNames, NULL),
#endif
    PARSE_ENU(RC_KEYPAD_MODE,           keypad_mode,        tbl_keypad_mode, NULL),
    PARSE_ARY(RC_LINEEDIT_MODE,         current_lineedit,   LYEditorNames, N_("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
")),
#ifdef USE_LOCALE_CHARSET
    MAYBE_SET(RC_LOCALE_CHARSET,      LYLocaleCharset,        MSG_ENABLE_LYNXRC),
#endif
    MAYBE_SET(RC_MAKE_PSEUDO_ALTS_FOR_INLINES, pseudo_inline_alts, MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_MAKE_LINKS_FOR_ALL_IMAGES, clickable_images, MSG_ENABLE_LYNXRC),
    PARSE_MBM(RC_MULTI_BOOKMARK, N_("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
")),
    PARSE_STR(RC_PERSONAL_MAIL_ADDRESS, personal_mail_address, N_("\
personal_mail_address specifies your personal mail address.  The\n\
address will be sent during HTTP file transfers for authorization and\n\
logging purposes, and for mailed comments.\n\
If you do not want this information given out, set the NO_FROM_HEADER\n\
to TRUE in lynx.cfg, or use the -nofrom command line switch.  You also\n\
could leave this field blank, but then you won't have it included in\n\
your mailed comments.\n\
")),
    PARSE_STR(RC_PERSONAL_MAIL_NAME,    personal_mail_name, N_("\
personal_mail_name specifies your personal name, for mail.  The\n\
name is sent for mailed comments.  Lynx will prompt for this,\n\
showing the configured value as a default when sending mail.\n\
This is not necessarily the same as a name provided as part of the\n\
personal_mail_address.\n\
Lynx does not save your changes to that default value as a side-effect\n\
of sending email.  To update the default value, you must use the options\n\
menu, or modify this file directly.\n\
")),
    PARSE_STR(RC_PREFERRED_CHARSET,     pref_charset, N_("\
preferred_charset specifies the character set in MIME notation (e.g.,\n\
ISO-8859-2, ISO-8859-5) which Lynx will indicate you prefer in requests\n\
to http servers using an Accept-Charset header.  The value should NOT\n\
include ISO-8859-1 or US-ASCII, since those values are always assumed\n\
by default.  May be a comma-separated list.\n\
If a file in that character set is available, the server will send it.\n\
If no Accept-Charset header is present, the default is that any\n\
character set is acceptable.  If an Accept-Charset header is present,\n\
and if the server cannot send a response which is acceptable\n\
according to the Accept-Charset header, then the server SHOULD send\n\
an error response, though the sending of an unacceptable response\n\
is also allowed.\n\
")),
    MAYBE_ENU(RC_PREFERRED_ENCODING,    LYAcceptEncoding,   tbl_preferred_encoding,
	      MSG_ENABLE_LYNXRC),
    PARSE_STR(RC_PREFERRED_LANGUAGE,    language, N_("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in its default language.\n\
")),
    MAYBE_ENU(RC_PREFERRED_MEDIA_TYPES, LYAcceptMedia,      tbl_preferred_media,
	      MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_RAW_MODE,              LYRawMode,          MSG_ENABLE_LYNXRC),
#if defined(ENABLE_OPTS_CHANGE_EXEC) && (defined(EXEC_LINKS) || defined(EXEC_SCRIPTS))
    PARSE_SET(RC_RUN_ALL_EXECUTION_LINKS, local_exec, N_("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
    PARSE_SET(RC_RUN_EXECUTION_LINKS_LOCAL, local_exec_on_local_files, N_("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
")),
#endif
#ifdef USE_SCROLLBAR
    MAYBE_SET(RC_SCROLLBAR,             LYShowScrollbar, MSG_ENABLE_LYNXRC),
#endif
    PARSE_SET(RC_SELECT_POPUPS,         LYSelectPopups, N_("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
")),
    MAYBE_SET(RC_SEND_USERAGENT,        LYSendUserAgent,   MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_SET_COOKIES,           LYSetCookies,      MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_SHOW_COLOR,            LYrcShowColor,     tbl_show_colors, N_("\
show_color specifies how to set the color mode at startup.  A value of\n\
\"never\" will force color mode off (treat the terminal as monochrome)\n\
at startup even if the terminal appears to be color capable.  A value of\n\
\"always\" will force color mode on even if the terminal appears to be\n\
monochrome, if this is supported by the library used to build lynx.\n\
A value of \"default\" will yield the behavior of assuming\n\
a monochrome terminal unless color capability is inferred at startup\n\
based on the terminal type, or the -color command line switch is used, or\n\
the COLORTERM environment variable is set.  The default behavior always is\n\
used in anonymous accounts or if the \"option_save\" restriction is set.\n\
The effect of the saved value can be overridden via\n\
the -color and -nocolor command line switches.\n\
The mode set at startup can be changed via the \"show color\" option in\n\
the 'o'ptions menu.  If the option settings are saved, the \"on\" and\n\
\"off\" \"show color\" settings will be treated as \"default\".\n\
")),
    PARSE_SET(RC_SHOW_CURSOR,           LYShowCursor, N_("\
show_cursor specifies whether to 'hide' the cursor to the right (and\n\
bottom, if possible) of the screen, or to place it to the left of the\n\
current link in documents, or current option in select popup windows.\n\
Positioning the cursor to the left of the current link or option is\n\
helpful for speech or braille interfaces, and when the terminal is\n\
one which does not distinguish the current link based on highlighting\n\
or color.  A value of \"on\" will set positioning to the left as the\n\
default while a value of \"off\" will set 'hiding' of the cursor.\n\
The default can be overridden via the -show_cursor command line toggle.\n\
")),
    PARSE_SET(RC_SHOW_DOTFILES,         show_dotfiles, N_("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
")),
#ifdef USE_READPROGRESS
    MAYBE_ENU(RC_SHOW_KB_RATE,          LYTransferRate,    tbl_transfer_rate,
	      MSG_ENABLE_LYNXRC),
#endif
    PARSE_ENU(RC_SUB_BOOKMARKS,         LYMultiBookmarks,  tbl_multi_bookmarks, N_("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
")),
    MAYBE_FUN(RC_TAGSOUP,               get_tagsoup,        put_tagsoup,
              MSG_ENABLE_LYNXRC),
    MAYBE_SET(RC_UNDERLINE_LINKS,       LYUnderlineLinks,   MSG_ENABLE_LYNXRC),
    PARSE_ENU(RC_USER_MODE,             user_mode,          tbl_user_mode, N_("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
")),
    MAYBE_STR(RC_USERAGENT,             LYUserAgent,        MSG_ENABLE_LYNXRC),
    PARSE_SET(RC_VERBOSE_IMAGES,        verbose_img, N_("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
")),
    PARSE_SET(RC_VI_KEYS,               vi_keys, N_("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
")),
    PARSE_ENU(RC_VISITED_LINKS,         Visited_Links_As,   tbl_visited_links, N_("\
The visited_links setting controls how Lynx organizes the information\n\
in the Visited Links Page.\n\
")),
#ifdef USE_SESSIONS
    MAYBE_SET(RC_AUTO_SESSION,		LYAutoSession,	MSG_ENABLE_LYNXRC),
    MAYBE_STR(RC_SESSION_FILE,		LYSessionFile,	MSG_ENABLE_LYNXRC),
#endif
    MAYBE_SET(RC_NO_PAUSE,		no_pause,	MSG_ENABLE_LYNXRC),

    PARSE_NIL
};
/* *INDENT-ON* */

static Config_Type *lookup_config(const char *name)
{
    Config_Type *tbl = Config_Table;
    char ch = (char) TOUPPER(*name);

    while (tbl->name != 0) {
	if (tbl->enabled) {
	    char ch1 = tbl->name[0];

	    if ((ch == TOUPPER(ch1))
		&& (0 == strcasecomp(name, tbl->name)))
		break;
	}

	tbl++;
    }
    return tbl;
}

BOOL LYsetRcValue(const char *name, const char *param)
{
    char MBM_line[256];
    char *notes;
    int n;
    Config_Type *tbl;
    ParseUnionPtr q;
    BOOL changed = TRUE;
    char *value = NULL;

    StrAllocCopy(value, param);
    value = LYSkipBlanks(value);
    CTRACE2(TRACE_CFG, (tfp, "LYrcFile %s:%s\n", name, value));

    tbl = lookup_config(name);
    if (tbl->name == 0) {
	const char *special = RC_MULTI_BOOKMARK;

	if (!strncasecomp(name, special, (int) strlen(special))) {
	    tbl = lookup_config(special);
	}
	/*
	 * lynx ignores unknown keywords.
	 * This includes known keywords where there is no ENABLE_LYNXRC.
	 */
	if (tbl->name == 0) {
	    CTRACE((tfp, "LYrcFile: ignored %s=%s\n", name, value));
	    return FALSE;
	}
    }

    q = ParseUnionOf(tbl);
    switch (tbl->type) {
    case CONF_BOOL:
	if (q->set_value != 0)
	    *(q->set_value) = getBool(value);
	break;

    case CONF_FUN:
	if (q->fun_value != 0)
	    (*(q->fun_value)) (value);
	break;

    case CONF_ARRAY:
	for (n = 0; tbl->strings[n] != 0; ++n) {
	    if (!strcasecomp(value, tbl->strings[n])) {
		*(q->int_value) = n;
		break;
	    }
	}
	break;

    case CONF_ENUM:
	if (tbl->table != 0)
	    LYgetEnum(tbl->table, value, q->int_value);
	break;

    case CONF_INT:
	if (q->int_value != 0) {
	    int ival;

	    if (1 == sscanf(value, "%d", &ival))
		*(q->int_value) = ival;
	}
	break;

    case CONF_LIS:
	if (q->str_value != 0) {
	    if (*(q->str_value) != NULL)
		StrAllocCat(*(q->str_value), ",");
	    StrAllocCat(*(q->str_value), value);
	}
	break;

    case CONF_MBM:
	for (n = 1; n <= MBM_V_MAXFILES; n++) {
	    sprintf(MBM_line, "multi_bookmark%c", LYindex2MBM(n));

	    if (!strcasecomp(name, MBM_line)) {
		if ((notes = StrChr(value, ',')) != 0) {
		    *notes++ = '\0';
		    LYTrimTrailing(value);
		    notes = LYSkipBlanks(notes);
		} else {
		    notes = value + strlen(value);
		}
		StrAllocCopy(MBM_A_subbookmark[n], value);
		StrAllocCopy(MBM_A_subdescript[n], notes);
		break;
	    }
	}
	break;

    case CONF_STR:
	if (q->str_value != 0)
	    StrAllocCopy(*(q->str_value), value);
	break;

    default:
	changed = FALSE;
	break;
    }
    FREE(value);

    return changed;
}

/* Read and process user options.  If the passed-in fp is NULL, open the
 * regular user defaults file for reading, otherwise use fp which has to be a
 * file open for reading.  - kw
 */
void read_rc(FILE *fp)
{
    char *buffer = NULL;
    char rcfile[LY_MAXPATH];

    if (!fp) {
	/*
	 * Make an RC file name, open it for reading.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);
	if ((fp = fopen(rcfile, TXT_R)) == NULL) {
	    return;
	}
	CTRACE((tfp, "read_rc opened %s\n", rcfile));
    } else {
	CTRACE((tfp, "read_rc used passed-in stream\n"));
    }

    /*
     * Process the entries.
     */
    while (LYSafeGets(&buffer, fp) != NULL) {
	char *name, *value;

	/* Most lines in the config file are comment lines.  Weed them out
	 * now.  Also, leading whitespace is ok, so trim it.
	 */
	LYTrimTrailing(buffer);
	name = LYSkipBlanks(buffer);
	if (ispunct(UCH(*name)) || *name == '\0')
	    continue;

	/*
	 * Parse the "name=value" strings.
	 */
	if ((value = StrChr(name, '=')) == 0) {
	    CTRACE((tfp, "LYrcFile: missing '=' %s\n", name));
	    continue;
	}
	*value++ = '\0';
	LYTrimTrailing(name);
	LYsetRcValue(name, value);
    }

    LYCloseInput(fp);
    LYConfigCookies();		/* update cookie settings, if any */

#if defined(USE_SLANG) || defined(COLOR_CURSES)
    /*
     * We may override the commandline "-color" option with the .lynxrc file
     */
    switch (LYrcShowColor) {
    case SHOW_COLOR_ALWAYS:
	if (LYShowColor != SHOW_COLOR_NEVER)
	    LYShowColor = SHOW_COLOR_ALWAYS;
	break;
    case SHOW_COLOR_NEVER:
	if (LYShowColor == SHOW_COLOR_ON)
	    LYShowColor = SHOW_COLOR_OFF;
	break;
    default:
	/* don't override */
	break;
    }
#endif
    set_default_bookmark_page(bookmark_page);
}

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
static void write_list(FILE *fp, const char *list)
{
    int first = TRUE;

    while (*list != 0) {
	int ch = *list++;

	if (first) {
	    fputs("# ", fp);
	    first = FALSE;
	}
	if (ch == '\n') {
	    first = TRUE;
	}
	fputc(ch, fp);
    }
}

/*
 * This is too long for some compilers.
 */
static void explain_keypad_mode(FILE *fp)
{
    write_list(fp, gettext("\
If keypad_mode is set to \"NUMBERS_AS_ARROWS\", then the numbers on\n\
your keypad when the numlock is on will act as arrow keys:\n\
            8 = Up Arrow\n\
  4 = Left Arrow    6 = Right Arrow\n\
            2 = Down Arrow\n\
and the corresponding keyboard numbers will act as arrow keys,\n\
regardless of whether numlock is on.\n\
"));
    write_list(fp, gettext("\
If keypad_mode is set to \"LINKS_ARE_NUMBERED\", then numbers will\n\
appear next to each link and numbers are used to select links.\n\
"));
    write_list(fp, gettext("\
If keypad_mode is set to \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\", then\n\
numbers will appear next to each link and visible form input field.\n\
Numbers are used to select links, or to move the \"current link\" to a\n\
form input field or button.  In addition, options in popup menus are\n\
indexed so that the user may type an option number to select an option in\n\
a popup menu, even if the option isn't visible on the screen.  Reference\n\
lists and output from the list command also enumerate form inputs.\n\
"));
    write_list(fp, gettext("\
NOTE: Some fixed format documents may look disfigured when\n\
\"LINKS_ARE_NUMBERED\" or \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\" are\n\
enabled.\n\
"));
}

/* Save user options.  If the passed-in fp is NULL, open the regular user
 * defaults file for writing, otherwise use fp which has to be a temp file open
 * for writing.  - kw
 */
int save_rc(FILE *fp)
{
    Config_Type *tbl = Config_Table;
    char rcfile[LY_MAXPATH];
    BOOLEAN is_tempfile = (BOOL) (fp != NULL);
    int n;

    if (!fp) {
	/*
	 * Make a name.
	 */
	LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

	/*
	 * Open the file for write.
	 */
	if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	    return FALSE;
	}
    }

    write_list(fp, gettext("\
Lynx User Defaults File\n\
\n\
"));

    /*
     * We have either the HTML options form, or the older menu, or both.
     */
#ifndef NO_OPTION_FORMS
    write_list(fp, gettext("\
This file contains options saved from the Lynx Options Screen (normally\n\
with the 'o' key).  To save options with that screen, you must select the\n\
checkbox:\n\
"));
    fprintf(fp, "#\t%s\n", SAVE_OPTIONS);
    fprintf(fp, "#\n");
    write_list(fp, gettext("\
You must then save the settings using the link on the line above the\n\
checkbox:\n\
"));
    fprintf(fp, "#\t%s\n", ACCEPT_CHANGES);
    fprintf(fp, "#\n");
#ifndef NO_OPTION_MENU
    write_list(fp, gettext("\
You may also use the command-line option \"-forms_options\", which displays\n\
the simpler Options Menu instead.  Save options with that using the '>' key.\n\
\n\
"));
#endif
#else /* we only have old options-menu */
    write_list(fp, gettext("\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).\n\
\n\
"));
#endif

    write_list(fp, gettext("\
There is normally no need to edit this file manually, since the defaults\n\
here can be controlled from the Options Screen, and the next time options\n\
are saved from the Options Screen this file will be completely rewritten.\n\
You have been warned...\n\
\n\
If you are looking for the general configuration file - it is normally\n\
called \"lynx.cfg\".  It has different content and a different format.\n\
It is not this file.\n\
"));
    fprintf(fp, "\n");

    while (tbl->name != 0) {
	ParseUnionPtr q = ParseUnionOf(tbl);

	if (!tbl->enabled) {
	    tbl++;
	    continue;
	}
	if (tbl->note != NULL) {
	    write_list(fp, gettext(tbl->note));
	} else if (tbl->table == tbl_keypad_mode) {
	    explain_keypad_mode(fp);
	}

	switch (tbl->type) {
	case CONF_BOOL:
	    fprintf(fp, "%s=%s\n\n", tbl->name, putBool(*(q->set_value)));
	    break;

	case CONF_FUN:
	    if (tbl->write_it != 0)
		tbl->write_it(fp, tbl);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n)
		fprintf(fp, "#    %s\n", tbl->strings[n]);
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    tbl->strings[*(q->int_value)]);
	    break;

	case CONF_ENUM:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    LYputEnum(tbl->table, *(q->int_value)));
	    break;

	case CONF_INT:
	    fprintf(fp, "%s=%d\n\n", tbl->name, *(q->int_value));
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		fprintf(fp, "multi_bookmark%c=", LYindex2MBM(n));

		fprintf(fp, "%s", NonNull(MBM_A_subbookmark[n]));
		if (MBM_A_subdescript[n] != 0
		    && *MBM_A_subdescript[n] != 0)
		    fprintf(fp, ",%s", MBM_A_subdescript[n]);
		fprintf(fp, "\n");
	    }
	    fprintf(fp, "\n");
	    break;

	case CONF_LIS:
	    /* FALLTHRU */
	case CONF_STR:
	    fprintf(fp, "%s=%s\n\n", tbl->name,
		    (q->str_value != 0 && *(q->str_value) != 0)
		    ? *(q->str_value)
		    : "");
	    break;

	case CONF_NIL:
	    break;
	}
	tbl++;
    }

    /*
     * Close the RC file.
     */
    if (is_tempfile) {
	LYCloseTempFP(fp);
    } else {
	LYCloseOutput(fp);
	HTSYS_purge(rcfile);
    }

    return TRUE;
}

/*
 * Returns true if the given name would be saved in .lynxrc
 */
BOOL will_save_rc(const char *name)
{
    Config_Type *tbl = lookup_config(name);

    return (BOOL) (tbl->name != 0);
}

int enable_lynxrc(char *value)
{
    Config_Type *tbl;
    char *colon = StrChr(value, ':');

    if (colon != 0) {
	*colon++ = 0;
	LYTrimLeading(value);
	LYTrimTrailing(value);

	for (tbl = Config_Table; tbl->name != 0; tbl++) {
	    if (!strcasecomp(value, tbl->name)) {
		tbl->enabled = getBool(colon);
		break;
	    }
	}
    }
    return 0;
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYrcFile.c,v 1.81 2009/06/07 17:11:00 tom Exp $ */
d133 2
d183 1
a183 1
BOOL LYgetEnum(Config_Enum * table, char *name,
d187 1
a187 1
    unsigned len = strlen(name);
d349 1
a349 1
    PARSE_SET(RC_CASE_SENSITIVE_SEARCHING, case_sensitive, N_("\
d432 1
d437 1
a437 1
    PARSE_ARY(RC_LINEEDIT_MODE,         current_lineedit,   LYLineeditNames, N_("\
d470 10
d655 107
a769 2
    char MBM_line[256];
    int n;
d788 1
a788 3
	char *name, *value, *notes;
	Config_Type *tbl;
	ParseUnionPtr q;
d801 1
a801 1
	if ((value = strchr(name, '=')) == 0) {
d807 1
a807 87
	value = LYSkipBlanks(value);
	CTRACE2(TRACE_CFG, (tfp, "LYrcFile %s:%s\n", name, value));

	tbl = lookup_config(name);
	if (tbl->name == 0) {
	    const char *special = RC_MULTI_BOOKMARK;

	    if (!strncasecomp(name, special, (int) strlen(special))) {
		tbl = lookup_config(special);
	    }
	    /* lynx ignores unknown keywords */
	    if (tbl->name == 0) {
		CTRACE((tfp, "LYrcFile: ignored %s=%s\n", name, value));
		continue;
	    }
	}

	q = ParseUnionOf(tbl);
	switch (tbl->type) {
	case CONF_BOOL:
	    if (q->set_value != 0)
		*(q->set_value) = getBool(value);
	    break;

	case CONF_FUN:
	    if (q->fun_value != 0)
		(*(q->fun_value)) (value);
	    break;

	case CONF_ARRAY:
	    for (n = 0; tbl->strings[n] != 0; ++n) {
		if (!strcasecomp(value, tbl->strings[n])) {
		    *(q->int_value) = n;
		    break;
		}
	    }
	    break;

	case CONF_ENUM:
	    if (tbl->table != 0)
		LYgetEnum(tbl->table, value, q->int_value);
	    break;

	case CONF_INT:
	    if (q->int_value != 0) {
		int ival;

		if (1 == sscanf(value, "%d", &ival))
		    *(q->int_value) = ival;
	    }
	    break;

	case CONF_LIS:
	    if (q->str_value != 0) {
		if (*(q->str_value) != NULL)
		    StrAllocCat(*(q->str_value), ",");
		StrAllocCat(*(q->str_value), value);
	    }
	    break;

	case CONF_MBM:
	    for (n = 1; n <= MBM_V_MAXFILES; n++) {
		sprintf(MBM_line, "multi_bookmark%c", LYindex2MBM(n));

		if (!strcasecomp(name, MBM_line)) {
		    if ((notes = strchr(value, ',')) != 0) {
			*notes++ = '\0';
			LYTrimTrailing(value);
			notes = LYSkipBlanks(notes);
		    } else {
			notes = value + strlen(value);
		    }
		    StrAllocCopy(MBM_A_subbookmark[n], value);
		    StrAllocCopy(MBM_A_subdescript[n], notes);
		    break;
		}
	    }
	    break;

	case CONF_STR:
	    if (q->str_value != 0)
		StrAllocCopy(*(q->str_value), value);
	    break;

	case CONF_NIL:
	    break;
	}
d1057 1
a1057 1
    char *colon = strchr(value, ':');
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
a15 6
#ifdef FNAMES_8_3
#define FNAME_LYNXRC "lynx.rc"
#else
#define FNAME_LYNXRC ".lynxrc"
#endif /* FNAMES_8_3 */

d29 8
d134 4
d190 1
a190 1
	    if (!strncasecomp(table->name, name, len)) {
d332 1
d339 3
d369 1
a369 1
The default is ~/.lynx_cookies.\n\
d411 1
d420 1
d427 3
d447 1
a447 1
#ifdef EXP_LOCALE_CHARSET
d532 1
d613 5
d698 1
a698 1
	    if (!strncasecomp(name, special, strlen(special))) {
d815 4
a820 5
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
d888 7
d896 32
a927 4
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
d929 1
a929 1
called lynx.cfg, and it has different content and a different format.\n\
d1021 1
a1021 1
    return tbl->name != 0;
a1036 1
		CTRACE((tfp, "enable_lynxrc(%s) %s\n", value, putBool(tbl->enabled)));
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d23 2
a24 2

PUBLIC Config_Enum tbl_DTD_recovery[] = {
d35 1
a35 1
PRIVATE Config_Enum tbl_dir_list_style[] = {
d42 1
a42 1
PRIVATE Config_Enum tbl_dir_list_order[] = {
d57 1
a57 1
PRIVATE Config_Enum tbl_file_sort[] = {
d65 1
a65 1
PUBLIC Config_Enum tbl_keypad_mode[] = {
d76 1
a76 1
PUBLIC Config_Enum tbl_multi_bookmarks[] = {
d84 27
a110 1
PRIVATE Config_Enum tbl_show_colors[] = {
d121 1
a121 1
PUBLIC Config_Enum tbl_transfer_rate[] = {
d134 1
a134 1
PUBLIC Config_Enum tbl_user_mode[] = {
d141 1
a141 1
PRIVATE Config_Enum tbl_visited_links[] = {
d150 1
a150 1
PUBLIC Config_Enum tbl_force_prompt[] = {
d156 1
d158 1
a158 1
PRIVATE BOOL getBool ARGS1(char *, src)
d163 1
a163 3
PUBLIC CONST char *LYputEnum ARGS2(
    Config_Enum *,	table,
    int,		value)
d174 2
a175 4
PUBLIC BOOL LYgetEnum ARGS3(
    Config_Enum *,	table,
    char *,		name,
    int *,		result)
d219 1
a219 1
#define PARSE_NIL          {NULL, 1, 0,          UNION_DEF(0), 0, 0, 0, 0}
d222 1
a222 1
    CONF_UNSPECIFIED = 0
d233 2
a234 3
typedef struct config_type
{
    CONST char *name;
d237 2
a238 2
    ParseData;
    char **strings;
d240 2
a241 2
    void (*write_it) PARAMS((FILE * fp, struct config_type *));
    char *note;
d244 1
a244 1
PRIVATE int get_assume_charset ARGS1(char *, value)
d249 1
a249 1
    	if (!strcasecomp(value, LYCharSet_UC[i].MIMEname)) {
d257 1
a257 1
PRIVATE void put_assume_charset ARGS2(FILE *, fp, struct config_type *, tbl)
d266 1
a266 1
PRIVATE int get_display_charset ARGS1(char *, value)
d270 1
a270 1
    i = UCGetLYhndl_byAnyName(value); /* by MIME or full name */
d276 1
a276 1
PRIVATE void put_display_charset ARGS2(FILE *, fp, struct config_type *, tbl)
d285 1
a285 1
PRIVATE int get_editor ARGS1(char *, value)
d292 1
a292 1
PRIVATE void put_editor ARGS2(FILE *, fp, struct config_type *, tbl)
d297 1
a297 1
PUBLIC int get_tagsoup ARGS1(char *, value)
d302 1
a302 1
     && Old_DTD != found) {
d309 1
a309 1
PRIVATE void put_tagsoup ARGS2(FILE *, fp, struct config_type *, tbl)
d315 1
d325 6
d465 2
d474 2
d599 1
d601 1
a601 2
PRIVATE Config_Type *lookup_config ARGS1(
	char *,		name)
d611 1
a611 1
		&& (0 == strcasecomp (name, tbl->name)))
d620 3
a622 4
/*  Read and process user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for reading, otherwise use fp which has to be a file open for
 *  reading. - kw
d624 1
a624 1
PUBLIC void read_rc ARGS1(FILE *, fp)
d629 1
a629 1
    int  n;
d633 1
a633 1
	 *  Make an RC file name, open it for reading.
d645 1
a645 1
     *  Process the entries.
d674 2
a675 1
	    char *special = RC_MULTI_BOOKMARK;
d690 1
a690 1
		*(q->set_value) = getBool (value);
d715 2
a716 1
		if (1 == sscanf (value, "%d", &ival))
d753 1
a753 1
	case CONF_UNSPECIFIED:
d759 1
a759 1
    LYConfigCookies();	/* update cookie settings, if any */
d786 1
a786 3
PRIVATE void write_list ARGS2(
    	FILE *,		fp,
	char *,		list)
d789 1
d792 1
d808 1
a808 1
PRIVATE void explain_keypad_mode ARGS1(FILE *, fp)
d839 3
a841 4
/*  Save user options.
 *  If the passed-in fp is NULL, open the regular user defaults file
 *  for writing, otherwise use fp which has to be a temp file open for
 *  writing. - kw
d843 1
a843 1
PUBLIC int save_rc ARGS1(FILE *, fp)
d852 1
a852 1
	 *  Make a name.
d857 1
a857 1
	 *  Open the file for write.
d884 2
a885 1
	} if (tbl->note != NULL) {
d923 1
a923 1
		 && *MBM_A_subdescript[n] != 0)
d934 3
a936 3
			(q->str_value != 0 && *(q->str_value) != 0)
			    ? *(q->str_value)
			    : "");
d939 1
a939 1
	case CONF_UNSPECIFIED:
d946 1
a946 1
     *  Close the RC file.
d961 1
a961 1
PUBLIC BOOL will_save_rc ARGS1(char *, name)
d964 1
d968 1
a968 2
PUBLIC int enable_lynxrc ARGS1(
	char *,		value)
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d11 1
a21 1
#define NonNull(string) ((string) != 0 ? (string) : "")
d25 2
d37 1
a37 1
    { "DIRECTORIES_FIRST", 0 },
d41 10
d52 4
d66 1
d68 3
a71 1
    { "LINKS_ARE_NUMBERED", LINKS_ARE_NUMBERED },
d101 1
a101 1
#ifdef EXP_READPROGRESS
d124 7
d136 1
a136 1
PRIVATE CONST char *LYputEnum ARGS2(
d149 1
a149 1
PRIVATE BOOL LYgetEnum ARGS3(
d151 2
a152 2
    char *,		src,
    int *,		value)
d154 18
a171 3
    while (table->name != 0) {
	if (!strncasecomp(table->name, src, strlen(table->name))) {
	    *value = table->value;
a173 1
	table++;
d175 1
a175 3
    if (table->value >= 0) 	/* is there a default? */
	*value = table->value;
    return FALSE;
d213 1
a213 1
    int enabled;		/* see lynx.cfg ENABLE_LYNXRC */
d275 17
d295 1
a295 3
    MAYBE_ENU("DTD_recovery",          Old_DTD,            tbl_DTD_recovery,
              MSG_ENABLE_LYNXRC),
    PARSE_SET("accept_all_cookies",    LYAcceptAllCookies, N_("\
d301 2
a302 2
    MAYBE_FUN("assume_char_set",       get_assume_charset, put_assume_charset, MSG_ENABLE_LYNXRC),
    PARSE_STR("bookmark_file",         bookmark_page,     N_("\
d307 1
a307 1
    PARSE_SET("case_sensitive_searching", case_sensitive, N_("\
d312 1
a312 1
    PARSE_FUN("character_set",         get_display_charset, put_display_charset, N_("\
d319 1
a319 1
    PARSE_LIS("cookie_accept_domains", LYCookieAcceptDomains, N_("\
d326 2
a327 2
#ifdef EXP_PERSISTENT_COOKIES
    PARSE_STR("cookie_file",	       LYCookieFile, N_("\
d332 1
a332 1
    PARSE_STR("cookie_loose_invalid_domains", LYCookieLooseCheckDomains, N_("\
d341 3
a343 3
    PARSE_STR("cookie_query_invalid_domains", LYCookieQueryCheckDomains, NULL),
    PARSE_LIS("cookie_reject_domains", LYCookieRejectDomains, NULL),
    PARSE_STR("cookie_strict_invalid_domains", LYCookieStrictCheckDomains, NULL),
d345 7
a351 1
    PARSE_ENU("dir_list_style",        dir_list_style,     tbl_dir_list_style, N_("\
d358 2
a359 2
    MAYBE_STR("display",               x_display,          MSG_ENABLE_LYNXRC),
    PARSE_SET("emacs_keys",            emacs_keys, N_("\
d365 1
a365 1
    PARSE_FUN("file_editor",           get_editor,         put_editor, N_("\
d371 1
a371 1
    PARSE_ENU("file_sorting_method",   HTfileSortMethod,   tbl_file_sort, N_("\
d379 6
d386 1
a386 1
    PARSE_ARY("kblayout",              current_layout,     LYKbLayoutNames, NULL),
d388 2
a389 2
    PARSE_ENU("keypad_mode",           keypad_mode,        tbl_keypad_mode, NULL),
    PARSE_ARY("lineedit_mode",         current_lineedit,   LYLineeditNames, N_("\
d402 6
a407 3
    MAYBE_SET("make_pseudo_alts_for_inlines", pseudo_inline_alts, MSG_ENABLE_LYNXRC),
    MAYBE_SET("make_links_for_all_images", clickable_images, MSG_ENABLE_LYNXRC),
    PARSE_MBM("multi_bookmark", N_("\
d413 1
a413 1
    PARSE_STR("personal_mail_address", personal_mail_address, N_("\
d422 1
a422 1
    PARSE_STR("preferred_charset",     pref_charset, N_("\
d436 1
a436 1
    PARSE_STR("preferred_language",    language, N_("\
d441 1
a441 1
Otherwise, the server will send the file in it's default language.\n\
d443 1
a443 1
    MAYBE_SET("raw_mode",              LYRawMode,          MSG_ENABLE_LYNXRC),
d445 1
a445 1
    PARSE_SET("run_all_execution_links", local_exec, N_("\
d456 1
a456 1
    PARSE_SET("run_execution_links_on_local_files", local_exec_on_local_files, N_("\
d471 4
a474 1
    PARSE_SET("select_popups",         LYSelectPopups, N_("\
d483 2
a484 2
    MAYBE_SET("set_cookies",           LYSetCookies,      MSG_ENABLE_LYNXRC),
    PARSE_ENU("show_color",            LYrcShowColor,     tbl_show_colors, N_("\
d501 1
a501 1
    PARSE_SET("show_cursor",           LYShowCursor, N_("\
d512 1
a512 1
    PARSE_SET("show_dotfiles",         show_dotfiles, N_("\
d519 2
a520 2
#ifdef EXP_READPROGRESS
    MAYBE_ENU("show_rate",             LYTransferRate,    tbl_transfer_rate,
d523 1
a523 1
    PARSE_ENU("sub_bookmarks",         LYMultiBookmarks,  tbl_multi_bookmarks, N_("\
d534 4
a537 2
    MAYBE_STR("user_agent",            LYUserAgent,        MSG_ENABLE_LYNXRC),
    PARSE_ENU("user_mode",             user_mode,          tbl_user_mode, N_("\
d545 2
a546 1
    PARSE_SET("verbose_images",        verbose_img, N_("\
d551 1
a551 1
    PARSE_SET("vi_keys",               vi_keys, N_("\
d559 1
a559 1
    PARSE_ENU("visited_links",         Visited_Links_As,   tbl_visited_links, N_("\
d607 3
d631 2
a632 1
	if ((value = strchr(name, '=')) == 0)
d634 1
d638 2
d642 1
a642 1
	    char *special = "multi_bookmark";
d647 2
a648 1
	    if (tbl->name == 0)
d650 1
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d20 11
a30 3
#define FIND_KEYWORD(cp, keyword) \
    ((cp = LYstrstr(line_buffer, keyword)) != NULL && \
     (cp - line_buffer) < number_sign)
d32 74
a105 1
PRIVATE char *SkipEquals ARGS1(char *, src)
d107 1
a107 4
    char *tmp;
    if ((tmp = (char *)strchr(src, '=')) != NULL)
	src = tmp + 1;
    return LYSkipBlanks(src);
d110 3
a112 1
PUBLIC void read_rc NOPARAMS
d114 8
a121 9
    char *line_buffer = NULL;
    char rcfile[LY_MAXPATH];
    FILE *fp;
    char *cp;
    int number_sign;
    char MBM_line[256];
    int  MBM_counter;
    char *MBM_cp2, *MBM_cp1;
    int  MBM_i2;
d123 11
a133 10
    /*
     *  Make an RC file name.
     */
    LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

    /*
     *  Open the RC file for reading.
     */
    if ((fp = fopen(rcfile, "r")) == NULL) {
	return;
d135 4
d140 31
a170 8
    /*
     *  Process the entries.
     */
    while (LYSafeGets(&line_buffer, fp) != NULL) {
	/*
	 *  Remove any trailing white space.
	 */
	LYTrimTrailing(line_buffer);
d172 11
a182 5
	/*
	 *  Skip any comment or blank lines.
	 */
	if (line_buffer[0] == '\0' || line_buffer[0] == '#')
	    continue;
d184 3
a186 7
	/*
	 *  Find the line position of the number sign if there is one.
	 */
	if ((cp = (char *)strchr(line_buffer, '#')) == NULL)
	    number_sign = 999;
	else
	    number_sign = cp - line_buffer;
d188 8
a195 4
	/*
	 *  File editor.
	 */
	if (!system_editor && FIND_KEYWORD(cp, "file_editor")) {
d197 3
a199 2
	    cp = SkipEquals(cp);
	    StrAllocCopy(editor, cp);
d201 4
a204 4
	/*
	 *  Default bookmark file.
	 */
	} else if (FIND_KEYWORD(cp, "bookmark_file")) {
d206 3
a208 1
	    cp = SkipEquals(cp);
d210 5
a214 8
	    /*
	     *  Since this is the "Default Bookmark File", we save it
	     *  as a globals, and as the first MBM_A_subbookmark entry.
	     */
	    StrAllocCopy(bookmark_page, cp);
	    StrAllocCopy(BookmarkPage, cp);
	    StrAllocCopy(MBM_A_subbookmark[0], cp);
	    StrAllocCopy(MBM_A_subdescript[0], MULTIBOOKMARKS_DEFAULT);
d216 3
a218 4
	/*
	 *  Multiple (sub)bookmark support settings.
	 */
	} else if (FIND_KEYWORD(cp, "sub_bookmarks")) {
d220 4
a223 10
	   cp = SkipEquals(cp);
	   if (!strncasecomp(cp, "standard", 8)) {
	      LYMultiBookmarks = TRUE;
	      LYMBMAdvanced = FALSE;
	   } else if (!strncasecomp(cp, "advanced", 8)) {
	      LYMultiBookmarks = TRUE;
	      LYMBMAdvanced = TRUE;
	   } else {
	      LYMultiBookmarks = FALSE;
	   }
d225 6
a230 207
	/*
	 *  Multiple (sub)bookmark definitions and descriptions.
	 */
	} else if (FIND_KEYWORD(cp, "multi_bookmark")) {

	    /*
	     *  Found the root, now cycle through all the
	     *	possible spaces and match specific ones.
	     */
	    for (MBM_counter = 1;
		 MBM_counter <= MBM_V_MAXFILES; MBM_counter++) {
		sprintf(MBM_line, "multi_bookmark%c", (MBM_counter + 'A'));

		if (FIND_KEYWORD(cp, MBM_line)) {
		    if ((MBM_cp1 = (char *)strchr(cp, '=')) == NULL) {
			break;
		    } else {
			if ((MBM_cp2 = (char *)strchr(cp, ',')) == NULL) {
			    break;
			} else {
			    MBM_i2 = 0;
			    /*
			     *  skip over the '='.
			     */
			    MBM_cp1++;
			    while (MBM_cp1 && MBM_cp1 != MBM_cp2) {
				/*
				 *  Skip spaces.
				 */
				if (isspace(*MBM_cp1)) {
				    MBM_cp1++;
				    continue;
				} else {
				    MBM_line[MBM_i2++] = *MBM_cp1++;
				}
			    }
			    MBM_line[MBM_i2++] = '\0';

			    StrAllocCopy(MBM_A_subbookmark[MBM_counter],
					 MBM_line);

			    /*
			     *  Now get the description ',' and ->.
			     */
			    MBM_cp1 = (char *)strchr(cp, ',');

			    MBM_i2 = 0;
			    /*
			     *  Skip over the ','.
			     */
			    MBM_cp1++;
			    /*
			     *  Eat spaces in front of description.
			     */
			    MBM_cp1 = LYSkipBlanks(MBM_cp1);
			    while (*MBM_cp1)
				MBM_line[MBM_i2++] = *MBM_cp1++;
			    MBM_line[MBM_i2++] = '\0';

			    StrAllocCopy(MBM_A_subdescript[MBM_counter],
					 MBM_line);

			    break;
			}
		    }
		}
	    }

	/*
	 *  FTP/file sorting method.
	 */
	} else if (FIND_KEYWORD(cp, "file_sorting_method")) {

	   cp = SkipEquals(cp);
	   if (!strncasecomp(cp, "BY_FILENAME", 11))
		HTfileSortMethod = FILE_BY_NAME;
	   else if (!strncasecomp(cp, "BY_TYPE", 7))
		HTfileSortMethod = FILE_BY_TYPE;
	   else if (!strncasecomp(cp, "BY_SIZE", 7))
		HTfileSortMethod = FILE_BY_SIZE;
	   else if (!strncasecomp(cp, "BY_DATE", 7))
		HTfileSortMethod = FILE_BY_DATE;

	/*
	 *  Personal mail address.
	 */
	} else if (FIND_KEYWORD(cp, "personal_mail_address")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(personal_mail_address, cp);

	/*
	 *  Searching type.
	 */
	} else if (FIND_KEYWORD(cp, "case_sensitive_searching")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		case_sensitive = TRUE;
	    else
		case_sensitive = FALSE;

	/*
	 *  Character set.
	 */
	} else if (FIND_KEYWORD(cp, "character_set")) {

	    int i = 0;

	    cp = SkipEquals(cp);

	    i = UCGetLYhndl_byAnyName(cp); /* by MIME or full name */
	    if (i < 0)
		; /* do nothing here: so fallback to lynx.cfg */
	    else
		current_char_set = i;

	/*
	 *  Preferred language.
	 */
	} else if (FIND_KEYWORD(cp, "preferred_language")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(language, cp);

	/*
	 *  Preferred charset.
	 */
	} else if (FIND_KEYWORD(cp, "preferred_charset")) {

	    cp = SkipEquals(cp);
	    StrAllocCopy(pref_charset, cp);

	/*
	 *  VI keys.
	 */
	} else if (FIND_KEYWORD(cp, "vi_keys")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		vi_keys = TRUE;
	    else
		vi_keys = FALSE;

	/*
	 *  EMACS keys.
	 */
	} else if (FIND_KEYWORD(cp, "emacs_keys")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		emacs_keys = TRUE;
	    else
		emacs_keys=FALSE;

	/*
	 *  Show dot files.
	 */
	} else if (FIND_KEYWORD(cp, "show_dotfiles")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		show_dotfiles = TRUE;
	    else
		show_dotfiles = FALSE;

	/*
	 *  Show color.
	 */
	} else if (FIND_KEYWORD(cp, "show_color")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "always", 6)) {
		LYrcShowColor = SHOW_COLOR_ALWAYS;
#if defined(USE_SLANG) || defined(COLOR_CURSES)
		if (LYShowColor != SHOW_COLOR_NEVER)
		    LYShowColor = SHOW_COLOR_ALWAYS;
#endif /* USE_SLANG || COLOR_CURSES */
	    } else if (!strncasecomp(cp, "never", 5)) {
		LYrcShowColor = SHOW_COLOR_NEVER;
#if defined(COLOR_CURSES)
		if (LYShowColor == SHOW_COLOR_ON)
		    LYShowColor = SHOW_COLOR_OFF;
#endif /* COLOR_CURSES */
	    }

	/*
	 *  Select popups.
	 */
	} else if (FIND_KEYWORD(cp, "select_popups")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "off", 3))
		LYSelectPopups = FALSE;
	    else
		LYSelectPopups = TRUE;

	/*
	 *  Show cursor.
	 */
	} else if (FIND_KEYWORD(cp, "show_cursor")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "off", 3))
		LYShowCursor = FALSE;
	    else
		LYShowCursor = TRUE;
d232 1
a232 200
	/*
	 *  Keypad mode.
	 */
	} else if (FIND_KEYWORD(cp, "keypad_mode")) {

	    cp = SkipEquals(cp);
	    if (LYstrstr(cp, "LINKS_ARE_NUMBERED"))
		keypad_mode = LINKS_ARE_NUMBERED;
	    else if (LYstrstr(cp, "LINKS_AND_FORM_FIELDS_ARE_NUMBERED"))
		keypad_mode = LINKS_AND_FORM_FIELDS_ARE_NUMBERED;
	    else
		keypad_mode = NUMBERS_AS_ARROWS;

	/*
	 *  Keyboard layout.
	 */
#ifdef EXP_KEYBOARD_LAYOUT
	} else if (FIND_KEYWORD(cp, "kblayout")) {

	    int i = 0;

	    cp = SkipEquals(cp);
	    for (; LYKbLayoutNames[i]; i++) {
		if (!strcmp(cp, LYKbLayoutNames[i])) {
		    current_layout = i;
		    break;
		}
	    }
#endif /* EXP_KEYBOARD_LAYOUT */

	/*
	 *  Line edit mode.
	 */
	} else if (FIND_KEYWORD(cp, "lineedit_mode")) {

	    int i = 0;

	    cp = SkipEquals(cp);
	    for (; LYLineeditNames[i]; i++) {
		if (!strncmp(cp, LYLineeditNames[i], strlen(cp))) {
		    current_lineedit = i;
		    break;
		}
	    }

#ifdef DIRED_SUPPORT
	/*
	 *  Directory list style.
	 */
	} else if (FIND_KEYWORD(cp, "dir_list_style")) {

	    cp = SkipEquals(cp);
	    if (LYstrstr(cp, "FILES_FIRST") != NULL) {
		dir_list_style = FILES_FIRST;
	    } else if (LYstrstr(cp,"DIRECTORIES_FIRST") != NULL) {
		dir_list_style = 0;
	    } else {
		dir_list_style = MIXED_STYLE;
	    }
#endif /* DIRED_SUPPORT */

	/*
	 *  Accept cookies from all domains?
	 */
	} else if (FIND_KEYWORD(cp, "accept_all_cookies")) {
	    cp = SkipEquals(cp);
	    if (LYstrstr(cp,"TRUE") != NULL) {
		LYAcceptAllCookies = TRUE;
	    } else {
		LYAcceptAllCookies = FALSE;
	    }


	/*
	 *  Accept all cookies from certain domains?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_accept_domains")) {
	    cp = SkipEquals(cp);
	    cookie_domain_flag_set(cp, FLAG_ACCEPT_ALWAYS);
	    if(LYCookieAcceptDomains != NULL) {
		StrAllocCat(LYCookieAcceptDomains, ",");
	    }
	    StrAllocCat(LYCookieAcceptDomains, cp);


	/*
	 *  Reject all cookies from certain domains?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_reject_domains")) {
	    cp = SkipEquals(cp);
	    cookie_domain_flag_set(cp, FLAG_REJECT_ALWAYS);
	    if(LYCookieRejectDomains != NULL) {
		StrAllocCat(LYCookieRejectDomains, ",");
	    }
	    StrAllocCat(LYCookieRejectDomains, cp);

	/*
	 *  Cookie domains to perform loose checks?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_loose_invalid_domains")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieLooseCheckDomains, cp);
	    cookie_domain_flag_set(cp, FLAG_INVCHECK_LOOSE);

	/*
	 *  Cookie domains to perform strict checks?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_strict_invalid_domains")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieStrictCheckDomains, cp);
	    cookie_domain_flag_set(cp, FLAG_INVCHECK_STRICT);

	/*
	 *  Cookie domains to query user over invalid cookies?
	 */
	} else if (FIND_KEYWORD(cp, "cookie_query_invalid_domains")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieQueryCheckDomains, cp);
	    cookie_domain_flag_set(cp, FLAG_INVCHECK_QUERY);

#ifdef EXP_PERSISTENT_COOKIES
	/*
	 *  File in which to store persistent cookies.
	 */
	} else if (FIND_KEYWORD(cp, "cookie_file")) {
	    cp = SkipEquals(cp);
	    StrAllocCopy(LYCookieFile, cp);
#endif /* EXP_PERSISTENT_COOKIES */

	/*
	 *  User mode.
	 */
	} else if (FIND_KEYWORD(cp, "user_mode")) {

	    cp = SkipEquals(cp);
	    if (LYstrstr(cp, "ADVANCED") != NULL) {
		user_mode = ADVANCED_MODE;
	    } else if (LYstrstr(cp,"INTERMEDIATE") != NULL) {
		user_mode = INTERMEDIATE_MODE;
	    } else {
		user_mode = NOVICE_MODE;
	    }

#ifdef NOTUSED
#ifdef DISP_PARTIAL
	/*
	 *  Partial display logic--set the threshold # of lines before
	 *  Lynx redraws the screen
	 */
	} else if (FIND_KEYWORD(cp, "partial_thres")) {
	    cp = SkipEquals(cp);
	    if (atoi(cp) != 0)
		partial_threshold = atoi(cp);
#endif /* DISP_PARTIAL */
#endif /* NOTUSED */

#ifdef ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS
	/*
	 *  Local execution mode - all links.
	 */
	} else if (FIND_KEYWORD(cp, "run_all_execution_links")) {

	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		local_exec = TRUE;
	     else
		local_exec = FALSE;

	/*
	 *  Local execution mode - only links in local files.
	 */
	} else if (FIND_KEYWORD(cp, "run_execution_links_on_local_files")) {
	    cp = SkipEquals(cp);
	    if (!strncasecomp(cp, "on", 2))
		local_exec_on_local_files = TRUE;
	    else
		local_exec_on_local_files=FALSE;
#endif /* ALLOW_USERS_TO_CHANGE_EXEC_WITHIN_OPTIONS */

	} else if (FIND_KEYWORD(cp, "verbose_images")) {
	   cp = SkipEquals(cp);
	   if (!strncasecomp(cp, "on", 2))
		verbose_img = 1;
	   else if (!strncasecomp(cp, "off", 3))
		verbose_img = 0;

	} /* end of if */

    } /* end of while */

    fclose(fp);
} /* big end */

/*
 * Write a set of comments.  Doing it this way avoids preprocessor problems
 * with the leading '#', makes it simpler to use gettext.
 */
PRIVATE void write_list ARGS2(
    	FILE *,		fp,
	char *,		list)
d234 1
a234 13
    int first = TRUE;
    while (*list != 0) {
	int ch = *list++;
	if (ch == '\n') {
	    first = TRUE;
	} else {
	    if (first) {
		fputs("# ", fp);
		first = FALSE;
	    }
	}
	fputc(ch, fp);
    }
d237 2
a238 1
PUBLIC int save_rc NOPARAMS
d240 67
a306 38
    char rcfile[LY_MAXPATH];
    FILE *fp;
    int i;
    int MBM_c;

    /*
     *  Make a name.
     */
    LYAddPathToHome(rcfile, sizeof(rcfile), FNAME_LYNXRC);

    /*
     *  Open the file for write.
     */
    if ((fp = LYNewTxtFile(rcfile)) == NULL) {
	return FALSE;
    }

    /*
     *  Header.
     */
    write_list(fp, gettext("\
Lynx User Defaults File\n\
\n\
This file contains options saved from the Lynx Options Screen (normally\n\
with the '>' key).  There is normally no need to edit this file manually,\n\
since the defaults here can be controlled from the Options Screen, and the\n\
next time options are saved from the Options Screen this file will be\n\
completely rewritten.  You have been warned...\n\
If you are looking for the general configuration file - it is normally\n\
called lynx.cfg, and it has different content and a different format.\n\
It is not this file.\n\
"));
    fprintf(fp, "\n");

    /*
     *  File editor
     */
    write_list(fp, gettext("\
d311 2
a312 56
"));
    fprintf(fp, "file_editor=%s\n\n", (editor ? editor : ""));

    /*
     *  Default bookmark file.
     */
    write_list(fp, gettext("\
bookmark_file specifies the name and location of the default bookmark\n\
file into which the user can paste links for easy access at a later\n\
date.\n\
"));
    fprintf(fp, "bookmark_file=%s\n\n", (bookmark_page ? bookmark_page : ""));

    /*
     *  Multiple (sub)bookmark support settings.
     */
    write_list(fp, gettext("\
If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
been defined (see below), then all bookmark operations will first\n\
prompt the user to select an active sub-bookmark file.  If the default\n\
Lynx bookmark_file is defined (see above), it will be used as the\n\
default selection.  When this option is set to \"advanced\", and the\n\
user mode is advanced, the 'v'iew bookmark command will invoke a\n\
statusline prompt instead of the menu seen in novice and intermediate\n\
user modes.  When this option is set to \"standard\", the menu will be\n\
presented regardless of user mode.\n\
"));
    fprintf(fp, "sub_bookmarks=%s\n\n", (LYMultiBookmarks ?
					   (LYMBMAdvanced ?
					       "advanced" : "standard")
							  : "off"));

    /*
     *  Multiple (sub)bookmark definitions and descriptions.
     */
    write_list(fp, gettext("\
The following allow you to define sub-bookmark files and descriptions.\n\
The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
Up to 26 bookmark files (for the English capital letters) are allowed.\n\
We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n\
"));
    for (MBM_c = 1; MBM_c <= MBM_V_MAXFILES; MBM_c++)
       fprintf(fp, "multi_bookmark%c=%s%s%s\n",
		   (MBM_c + 'A'),
		   (MBM_A_subbookmark[MBM_c] ?
		    MBM_A_subbookmark[MBM_c] : ""),
		   (MBM_A_subbookmark[MBM_c] ?
					 "," : ""),
		   (MBM_A_subdescript[MBM_c] ?
		    MBM_A_subdescript[MBM_c] : ""));
    fprintf(fp, "\n");

    /*
     *  FTP/file sorting method.
     */
    write_list(fp, gettext("\
d319 27
a345 13
"));
    fprintf(fp, "file_sorting_method=%s\n\n",
		(HTfileSortMethod == FILE_BY_NAME ? "BY_FILENAME"
						  :
		(HTfileSortMethod == FILE_BY_SIZE ? "BY_SIZE"
						  :
		(HTfileSortMethod == FILE_BY_TYPE ? "BY_TYPE"
						  : "BY_DATE"))));

    /*
     *  Personal mail address.
     */
    write_list(fp, gettext("\
d353 2
a354 46
"));
    fprintf(fp, "personal_mail_address=%s\n\n",
		(personal_mail_address ? personal_mail_address : ""));

    /*
     *  Searching type.
     */
    write_list(fp, gettext("\
If case_sensitive_searching is \"on\" then when the user invokes a search\n\
using the 's' or '/' keys, the search performed will be case sensitive\n\
instead of case INsensitive.  The default is usually \"off\".\n\
"));
    fprintf(fp, "case_sensitive_searching=%s\n\n",
		(case_sensitive ? "on" : "off"));

    /*
     *  Character set.
     */
    write_list(fp, gettext("\
The character_set definition controls the representation of 8 bit\n\
characters for your terminal.  If 8 bit characters do not show up\n\
correctly on your screen you may try changing to a different 8 bit\n\
set or using the 7 bit character approximations.\n\
Current valid characters sets are:\n\
"));
    for (i = 0; LYchar_set_names[i]; i++)
	fprintf(fp, "#    %s\n", LYchar_set_names[i]);
    fprintf(fp, "character_set=%s\n\n", LYchar_set_names[current_char_set]);


    /*
     *  Preferred language.
     */
    write_list(fp, gettext("\
preferred_language specifies the language in MIME notation (e.g., en,\n\
fr, may be a comma-separated list in decreasing preference)\n\
which Lynx will indicate you prefer in requests to http servers.\n\
If a file in that language is available, the server will send it.\n\
Otherwise, the server will send the file in it's default language.\n\
"));
    fprintf(fp, "preferred_language=%s\n\n", (language ? language : ""));

    /*
     *  Preferred charset.
     */
    write_list(fp, gettext("\
d367 47
a413 9
"));
    fprintf(fp, "preferred_charset=%s\n\n",
		(pref_charset ? pref_charset : ""));

    /*
     *  Show color.
     */
    if (LYChosenShowColor != SHOW_COLOR_UNKNOWN) {
	write_list(fp, gettext("\
d429 2
a430 61
"));
     fprintf(fp, "show_color=%s\n\n",
	     ((LYChosenShowColor == SHOW_COLOR_NEVER  ? "never"  :
	       (LYChosenShowColor == SHOW_COLOR_ALWAYS ? "always" :
						      "default"))));
    }

    /*
     *  VI keys.
     */
    write_list(fp, gettext("\
If vi_keys is set to \"on\", then the normal VI movement keys:\n\
  j = down    k = up\n\
  h = left    l = right\n\
will be enabled.  These keys are only lower case.\n\
Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
and the keymap display, respectively.\n\
"));
     fprintf(fp, "vi_keys=%s\n\n", (vi_keys ? "on" : "off"));

    /*
     *  EMACS keys.
     */
    write_list(fp, gettext("\
If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
  ^N = down    ^P = up\n\
  ^B = left    ^F = right\n\
will be enabled.\n\
"));
    fprintf(fp, "emacs_keys=%s\n\n", (emacs_keys ? "on" : "off"));

    /*
     *  Show dot files.
     */
    write_list(fp, gettext("\
show_dotfiles specifies that the directory listing should include\n\
\"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
restricted via a command line switch.  If display of hidden files\n\
is disabled, creation of such files via Lynx also is disabled.\n\
"));
    fprintf(fp, "show_dotfiles=%s\n\n", (show_dotfiles ? "on" : "off"));

    /*
     *  Select popups.
     */
    write_list(fp, gettext("\
select_popups specifies whether the OPTIONs in a SELECT block which\n\
lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
present in the SELECT start tag, Lynx always will create a vertical list\n\
of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
as the default while a value of \"off\" will set use of radio boxes.\n\
The default can be overridden via the -popup command line toggle.\n\
"));
    fprintf(fp, "select_popups=%s\n\n", (LYSelectPopups ? "on" : "off"));

    /*
     *  Show cursor.
     */
    write_list(fp, gettext("\
d440 203
a642 2
"));
    fprintf(fp, "show_cursor=%s\n\n", (LYShowCursor ? "on" : "off"));
d644 1
d646 1
a646 1
     *  Keypad mode.
d648 45
d720 13
a732 4
    fprintf(fp, "keypad_mode=%s\n\n",
		((keypad_mode == NUMBERS_AS_ARROWS) ?  "NUMBERS_AS_ARROWS" :
	       ((keypad_mode == LINKS_ARE_NUMBERED) ? "LINKS_ARE_NUMBERED" :
				      "LINKS_AND_FORM_FIELDS_ARE_NUMBERED")));
d734 5
a738 15
#ifdef NOTUSED
#ifdef DISP_PARTIAL
    /*
     *  Partial display threshold
     */
    write_list(fp, gettext("\
partial_thres specifies the number of lines Lynx should download and render\n\
before we redraw the screen in Partial Display logic\n\
e.g., partial_thres=2\n\
would have Lynx redraw every 2 lines that it renders\n\
partial_thres=-1 would use the entire screensize\n\
"));
    fprintf(fp, "partial_thres=%d\n\n", partial_threshold);
#endif /* DISP_PARTIAL */
#endif /* NOTUSED */
d740 5
a744 21
    /*
     *  Line edit mode.
     */
    write_list(fp, gettext("\
lineedit_mode specifies the key binding used for inputting strings in\n\
prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
the following control characters are used for moving and deleting:\n\
\n\
             Prev  Next       Enter = Accept input\n\
   Move char: <-    ->        ^G    = Cancel input\n\
   Move word: ^P    ^N        ^U    = Erase line\n\
 Delete char: ^H    ^R        ^A    = Beginning of line\n\
 Delete word: ^B    ^F        ^E    = End of line\n\
\n\
Current lineedit modes are:\n\
"));
    {
	char **bindings = LYLineeditNames;
	while (*bindings) {
	    fprintf(fp, "#    %s\n", *bindings);
	    bindings++;
a746 4
    fprintf(fp, "lineedit_mode=%s\n\n", LYLineeditNames[current_lineedit]);
#ifdef EXP_KEYBOARD_LAYOUT
    fprintf(fp, "kblayout=%s\n\n", LYKbLayoutNames[current_layout]);
#endif
a747 4
#ifdef DIRED_SUPPORT
    /*
     *  Directory list style.
     */
d749 10
a758 4
dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
(if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
files and directories together.  \"FILES_FIRST\" lists files first and\n\
\"DIRECTORIES_FIRST\" lists directories first.\n\
d760 1
a760 6
    fprintf(fp, "dir_list_style=%s\n\n",
		(dir_list_style==FILES_FIRST ? "FILES_FIRST"
					     :
		(dir_list_style==MIXED_STYLE ? "MIXED_STYLE"
					     : "DIRECTORIES_FIRST")));
#endif /* DIRED_SUPPORT */
d762 2
a763 15
    /*
     *  User mode.
     */
    write_list(fp, gettext("\
user_mode specifies the users level of knowledge with Lynx.  The\n\
default is \"NOVICE\" which displays two extra lines of help at the\n\
bottom of the screen to aid the user in learning the basic Lynx\n\
commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
bottom of the screen.\n\
"));
    fprintf(fp, "user_mode=%s\n\n",
		(user_mode == NOVICE_MODE ? "NOVICE" :
			 (user_mode == ADVANCED_MODE ?
					  "ADVANCED" : "INTERMEDIATE")));
d765 8
a772 11
    /*
     *  Cookie options
     */
    write_list(fp, gettext("\
accept_all_cookies allows the user to tell Lynx to automatically\n\
accept all cookies if desired.  The default is \"FALSE\" which will\n\
prompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\n\
all cookies.\n\
"));
    fprintf(fp, "accept_all_cookies=%s\n\n",
		(LYAcceptAllCookies == FALSE ? "FALSE" : "TRUE"));
d774 38
a811 13
    write_list(fp, gettext("\
cookie_accept_domains and cookie_reject_domains are comma-delimited\n\
lists of domains from which Lynx should automatically accept or reject\n\
all cookies.  If a domain is specified in both options, rejection will\n\
take precedence.  The accept_all_cookies parameter will override any\n\
settings made here.\n\
"));
    fprintf(fp, "cookie_accept_domains=%s\n",
		    (LYCookieAcceptDomains == NULL ? ""
		    : LYCookieAcceptDomains));
    fprintf(fp, "cookie_reject_domains=%s\n\n",
		    (LYCookieRejectDomains == NULL ? ""
		    : LYCookieRejectDomains));
d813 8
d822 5
a826 19
    write_list(fp, gettext("\
cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\n\
cookie_query_invalid_domains are comma-delimited lists of which domains\n\
should be subjected to varying degrees of validity checking.  If a\n\
domain is set to strict checking, strict conformance to RFC2109 will\n\
be applied.  A domain with loose checking will be allowed to set cookies\n\
with an invalid path or domain attribute.  All domains will default to\n\
querying the user for an invalid path or domain.\n\
"));
    fprintf(fp, "cookie_loose_invalid_domains=%s\n",
	    (LYCookieLooseCheckDomains == NULL) ? ""
		    : LYCookieLooseCheckDomains);
    fprintf(fp, "cookie_strict_invalid_domains=%s\n",
	    (LYCookieStrictCheckDomains == NULL) ? ""
		    : LYCookieStrictCheckDomains);
    fprintf(fp, "cookie_query_invalid_domains=%s\n\n",
	    (LYCookieQueryCheckDomains == NULL) ? ""
		    : LYCookieQueryCheckDomains);

a827 1
#ifdef EXP_PERSISTENT_COOKIES
d829 1
a829 1
     *  Cookie file.
d831 6
a836 7
    write_list(fp, gettext("\
cookie_file specifies the file in which to store persistent cookies.\n\
The default is ~/.lynx_cookies.\n\
"));
    fprintf(fp, "cookie_file=%s\n\n",
		(LYCookieFile == NULL ? "~/.lynx_cookies" : LYCookieFile));
#endif /* EXP_PERSISTENT_COOKIES */
d838 2
d841 8
d850 5
a854 17
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    /*
     *  Local execution mode - all links.
     */
    write_list(fp, gettext("\
If run_all_execution_links is set \"on\" then all local execution links\n\
will be executed when they are selected.\n\
\n\
WARNING - This is potentially VERY dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
"));
    fprintf(fp, "run_all_execution_links=%s\n\n",
		(local_exec ? "on" : "off"));
d856 14
a869 37
    /*
     *  Local execution mode - only links in local files.
     */
    write_list(fp, gettext("\
If run_execution_links_on_local_files is set \"on\" then all local\n\
execution links that are found in LOCAL files will be executed when they\n\
are selected.  This is different from run_all_execution_links in that\n\
only files that reside on the local system will have execution link\n\
permissions.\n\
\n\
WARNING - This is potentially dangerous.  Since you may view\n\
          information that is written by unknown and untrusted sources\n\
          there exists the possibility that Trojan horse links could be\n\
          written.  Trojan horse links could be written to erase files\n\
          or compromise security.  This should only be set to \"on\" if\n\
          you are viewing trusted source information.\n\
"));
    fprintf(fp, "run_execution_links_on_local_files=%s\n\n",
		(local_exec_on_local_files ? "on" : "off"));
#endif /* defined(EXEC_LINKS) || defined(EXEC_SCRIPTS) */

    write_list(fp, gettext("\
If verbose_images is \"on\", lynx will print the name of the image\n\
source file in place of [INLINE], [LINK] or [IMAGE]\n\
See also VERBOSE_IMAGES in lynx.cfg\n\
"));
    fprintf(fp, "verbose_images=%s\n\n",
		verbose_img ? "on" : "off");

    /*
     *  Close the RC file.
     */
    fclose(fp);

    HTSYS_purge(rcfile);

    return TRUE;
@


1.1
log
@Initial revision
@
text
@d1 10
a10 9
#include "HTUtils.h"
#include "tcp.h"
#include "HTFTP.h"
#include "LYUtils.h"
#include "LYrcFile.h"
#include "LYStrings.h"
#include "LYGlobalDefs.h"
#include "LYCharSets.h"
#include "LYBookmark.h"
d12 19
a30 1
#include "LYLeaks.h"
d34 2
a35 2
    char line_buffer[256];
    char rcfile[256];
d37 1
a37 1
    char *cp, *cp2;
d47 1
a47 9
#ifdef DJGPP
    sprintf(rcfile, "%s/lynx.rc", Home_Dir());
#else
#ifdef VMS
    sprintf(rcfile, "sys$login:.lynxrc");
#else
    sprintf(rcfile, "%s/.lynxrc", Home_Dir());
#endif /* VMS */
#endif /* DJGPP */
d59 1
a59 7
    while (fgets(line_buffer, 256, fp) != NULL) {
	/*
	 *  Remove the /n from the end of the line.
	 */
	if (line_buffer[0] && line_buffer[strlen(line_buffer)-1] == '\n')
	    line_buffer[strlen(line_buffer)-1] = '\0';

d63 1
a63 2
	while (line_buffer[0] && isspace(line_buffer[strlen(line_buffer)-1]))
	    line_buffer[strlen(line_buffer)-1] = '\0';
d82 3
a84 8
	if (!system_editor &&
	    (cp = LYstrstr(line_buffer, "file_editor")) != NULL &&
	    cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d90 1
a90 2
	} else if ((cp = LYstrstr(line_buffer, "bookmark_file")) != NULL &&
		    cp-line_buffer < number_sign) {
d92 1
a92 4
	    if ((cp2 = (char *)strchr(cp,'=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d106 1
a106 2
	} else if ((cp = LYstrstr(line_buffer, "sub_bookmarks")) != NULL &&
		   cp-line_buffer < number_sign) {
d108 1
a108 4
	   if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = (cp2 + 1);
	   while (isspace(*cp))
	       cp++;  /* get rid of spaces */
d122 1
a122 2
	} else if ((cp = LYstrstr(line_buffer, "multi_bookmark")) != NULL &&
		   cp-line_buffer < number_sign) {
d132 1
a132 2
		if ((cp = LYstrstr(line_buffer, MBM_line)) != NULL &&
		    cp-line_buffer < number_sign) {
d173 1
a173 2
			    while (isspace(*MBM_cp1))
				MBM_cp1++;
d188 1
a188 1
	 * FTP/file sorting method.
d190 3
a192 8
	} else if ((cp = LYstrstr(line_buffer,
				  "file_sorting_method")) != NULL &&
		   cp-line_buffer < number_sign) {

	   if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	   while (isspace(*cp))
	       cp++;  /* get rid of spaces */
d205 3
a207 8
	} else if ((cp = LYstrstr(line_buffer,
				  "personal_mail_address")) != NULL &&
		   cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d213 3
a215 8
	} else if ((cp = LYstrstr(line_buffer,
				  "case_sensitive_searching")) != NULL &&
		   cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d224 1
a224 2
	} else if ((cp = LYstrstr(line_buffer, "character_set")) != NULL &&
		   cp-line_buffer < number_sign) {
d228 7
a234 11
	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
	    for (; LYchar_set_names[i]; i++) {
		if (!strncmp(cp, LYchar_set_names[i], strlen(cp))) {
		    current_char_set=i;
		    HTMLSetRawModeDefault(i);
		    break;
		}
	    }
d239 3
a241 8
	} else if ((cp = LYstrstr(line_buffer,
				  "preferred_language")) != NULL &&
		   cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d247 3
a249 8
	} else if ((cp = LYstrstr(line_buffer,
				  "preferred_charset")) != NULL &&
		   cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d253 1
a253 1
	 * VI keys.
d255 1
a255 2
	} else if ((cp = LYstrstr(line_buffer, "vi_keys")) != NULL &&
		   cp-line_buffer < number_sign) {
d257 1
a257 4
	    if ((cp2 = (char * )strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d266 1
a266 2
	} else if ((cp = LYstrstr(line_buffer, "emacs_keys")) != NULL &&
		   cp-line_buffer < number_sign) {
d268 1
a268 4
	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d277 1
a277 2
	} else if ((cp = LYstrstr(line_buffer, "show_dotfiles")) != NULL &&
		   cp-line_buffer < number_sign) {
d279 1
a279 4
	    if ((cp2 = (char * )strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d288 1
a288 2
	} else if ((cp = LYstrstr(line_buffer, "show_color")) != NULL &&
		   cp-line_buffer < number_sign) {
d290 1
a290 4
	    if ((cp2 = (char * )strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d308 1
a308 2
	} else if ((cp = LYstrstr(line_buffer, "select_popups")) != NULL &&
		   cp-line_buffer < number_sign) {
d310 1
a310 4
	    if ((cp2 = (char * )strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d319 1
a319 2
	} else if ((cp = LYstrstr(line_buffer, "show_cursor")) != NULL &&
		   cp-line_buffer < number_sign) {
d321 1
a321 4
	    if ((cp2 = (char * )strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d330 1
a330 2
	} else if ((cp = LYstrstr(line_buffer, "keypad_mode")) != NULL &&
		   cp-line_buffer < number_sign) {
d332 1
a332 4
	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d341 18
a358 1
	 *  Linedit mode.
d360 1
a360 2
	} else if ((cp = LYstrstr(line_buffer, "lineedit_mode")) != NULL &&
		   cp-line_buffer < number_sign) {
d364 1
a364 4
	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d374 1
a374 1
	 *  List directory style.
d376 1
a376 2
	} else if ((cp = LYstrstr(line_buffer, "dir_list_style")) != NULL &&
		   cp-line_buffer < number_sign) {
d378 1
a378 4
	    if ((cp2 = (char *)strchr(cp,'=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d389 68
d459 1
a459 2
	} else if ((cp = LYstrstr(line_buffer, "user_mode")) != NULL &&
		   cp-line_buffer < number_sign) {
d461 1
a461 4
	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d470 13
d487 1
a487 8
	} else if ((cp = LYstrstr(line_buffer,
				  "run_all_execution_links")) != NULL &&
		   cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d489 1
d498 2
a499 8
	} else if ((cp = LYstrstr(line_buffer,
			"run_execution_links_on_local_files")) != NULL &&
		   cp-line_buffer < number_sign) {

	    if ((cp2 = (char *)strchr(cp, '=')) != NULL)
		cp = cp2 + 1;
	    while (isspace(*cp))
		cp++;  /* get rid of spaces */
d506 7
d520 23
d545 1
a545 1
    char rcfile[256];
d553 1
a553 9
#ifdef DJGPP
    sprintf(rcfile, "%s/lynx.rc", Home_Dir());
#else
#ifdef VMS
    sprintf(rcfile, "sys$login:.lynxrc");
#else
    sprintf(rcfile, "%s/.lynxrc", Home_Dir());
#endif /* VMS */
#endif /* DJGPP */
a557 3
#if defined(__DJGPP__) || defined(_WINDOWS)
    _fmode = O_TEXT;
#endif /* __DJGPP__  or _WINDOWS */
d565 13
a577 9
    fprintf(fp, "# Lynx User Defaults File\n#\n\
# This file contains options saved from the Lynx Options Screen (normally\n\
# with the '>' key).  There is normally no need to edit this file manually,\n\
# since the defaults here can be controlled from the Options Screen, and the\n\
# next time options are saved from the Options Screen this file will be\n\
# completely rewritten.  You have been warned...\n\
# If you are looking for the general configuration file - it is normally\n\
# called lynx.cfg, and it has different content and a different format.\n\
# It is not this file.\n\n");
d582 6
a587 5
    fprintf(fp, "\
# file_editor specifies the editor to be invoked when editing local files\n\
# or sending mail.  If no editor is specified, then file editing is disabled\n\
# unless it is activated from the command line, and the built-in line editor\n\
# will be used for sending mail.\n");
d593 5
a597 4
    fprintf(fp, "\
# bookmark_file specifies the name and location of the default bookmark\n\
# file into which the user can paste links for easy access at a later\n\
# date.\n");
d603 11
a613 10
    fprintf(fp, "\
# If sub_bookmarks is not turned \"off\", and multiple bookmarks have\n\
# been defined (see below), then all bookmark operations will first\n\
# prompt the user to select an active sub-bookmark file.  If the default\n\
# Lynx bookmark_file is defined (see above), it will be used as the\n\
# default selection.  When this option is set to \"advanced\", and the\n\
# user mode is advanced, the 'v'iew bookmark command will invoke a\n\
# statusline prompt instead of the menu seen in novice and intermediate\n\
# user modes.  When this option is set to \"standard\", the menu will be\n\
# presented regardless of user mode.\n");
d622 6
a627 5
    fprintf(fp, "\
# The following allow you to define sub-bookmark files and descriptions.\n\
# The format is multi_bookmark<capital_letter>=<filename>,<description>\n\
# Up to 26 bookmark files (for the English capital letters) are allowed.\n\
# We start with \"multi_bookmarkB\" since 'A' is the default (see above).\n");
d642 8
a649 7
    fprintf(fp, "\
# The file_sorting_method specifies which value to sort on when viewing\n\
# file lists such as FTP directories.  The options are:\n\
#    BY_FILENAME -- sorts on the name of the file\n\
#    BY_TYPE     -- sorts on the type of the file\n\
#    BY_SIZE     -- sorts on the size of the file\n\
#    BY_DATE     -- sorts on the date of the file\n");
d661 9
a669 8
    fprintf(fp, "\
# personal_mail_address specifies your personal mail address.  The\n\
# address will be sent during HTTP file transfers for authorization and\n\
# logging purposes, and for mailed comments.\n\
# If you do not want this information given out, set the NO_FROM_HEADER\n\
# to TRUE in lynx.cfg, or use the -nofrom command line switch.  You also\n\
# could leave this field blank, but then you won't have it included in\n\
# your mailed comments.\n");
d676 5
a680 4
    fprintf(fp, "\
# If case_sensitive_searching is \"on\" then when the user invokes a search\n\
# using the 's' or '/' keys, the search performed will be case sensitive\n\
# instead of case INsensitive.  The default is usually \"off\".\n");
d687 7
a693 6
    fprintf(fp, "\
# The character_set definition controls the representation of 8 bit\n\
# characters for your terminal.  If 8 bit characters do not show up\n\
# correctly on your screen you may try changing to a different 8 bit\n\
# set or using the 7 bit character approximations.\n\
# Current valid characters sets are:\n");
d702 7
a708 6
    fprintf(fp, "\
# preferred_language specifies the language in MIME notation (e.g., en,\n\
# fr, may be a comma-separated list in decreasing preference)\n\
# which Lynx will indicate you prefer in requests to http servers.\n\
# If a file in that language is available, the server will send it.\n\
# Otherwise, the server will send the file in it's default language.\n");
d714 14
a727 13
    fprintf(fp, "\
# preferred_charset specifies the character set in MIME notation (e.g.,\n\
# ISO-8859-2, ISO-8859-5) which Lynx will indicate you prefer in requests\n\
# to http servers using an Accept-Charset header.  The value should NOT\n\
# include ISO-8859-1 or US-ASCII, since those values are always assumed\n\
# by default.  May be a comma-separated list.\n\
# If a file in that character set is available, the server will send it.\n\
# If no Accept-Charset header is present, the default is that any\n\
# character set is acceptable.  If an Accept-Charset header is present,\n\
# and if the server cannot send a response which is acceptable\n\
# according to the Accept-Charset header, then the server SHOULD send\n\
# an error response, though the sending of an unacceptable response\n\
# is also allowed.\n");
d735 17
a751 16
	fprintf(fp, "\
# show_color specifies how to set the color mode at startup.  A value of\n\
# \"never\" will force color mode off (treat the terminal as monochrome)\n\
# at startup even if the terminal appears to be color capable.  A value of\n\
# \"always\" will force color mode on even if the terminal appears to be\n\
# monochrome, if this is supported by the library used to build lynx.\n\
# A value of \"default\" will yield the behavior of assuming\n\
# a monochrome terminal unless color capability is inferred at startup\n\
# based on the terminal type, or the -color command line switch is used, or\n\
# the COLORTERM environment variable is set. The default behavior always is\n\
# used in anonymous accounts or if the \"option_save\" restriction is set.\n\
# The effect of the saved value can be overridden via\n\
# the -color and -nocolor command line switches.\n\
# The mode set at startup can be changed via the \"show color\" option in\n\
# the 'o'ptions menu.  If the option settings are saved, the \"on\" and\n\
# \"off\" \"show color\" settings will be treated as \"default\".\n");
d761 8
a768 7
    fprintf(fp, "\
# If vi_keys is set to \"on\", then the normal VI movement keys:\n\
#   j = down    k = up\n\
#   h = left    l = right\n\
# will be enabled.  These keys are only lower case.\n\
# Capital 'H', 'J' and 'K will still activate help, jump shortcuts,\n\
# and the keymap display, respectively.\n");
d774 6
a779 5
    fprintf(fp, "\
# If emacs_keys is to \"on\" then the normal EMACS movement keys:\n\
#   ^N = down    ^P = up\n\
#   ^B = left    ^F = right\n\
# will be enabled.\n");
d785 7
a791 6
    fprintf(fp, "\
# show_dotfiles specifies that the directory listing should include\n\
# \"hidden\" (dot) files/directories.  If set \"on\", this will be\n\
# honored only if enabled via userdefs.h and/or lynx.cfg, and not\n\
# restricted via a command line switch.  If display of hidden files\n\
# is disabled, creation of such files via Lynx also is disabled.\n");
d797 9
a805 8
    fprintf(fp, "\
# select_popups specifies whether the OPTIONs in a SELECT block which\n\
# lacks a MULTIPLE attribute are presented as a vertical list of radio\n\
# buttons or via a popup menu.  Note that if the MULTIPLE attribute is\n\
# present in the SELECT start tag, Lynx always will create a vertical list\n\
# of checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\n\
# as the default while a value of \"off\" will set use of radio boxes.\n\
# The default can be overridden via the -popup command line toggle.\n");
d811 11
a821 10
    fprintf(fp, "\
# show_cursor specifies whether to 'hide' the cursor to the right (and\n\
# bottom, if possible) of the screen, or to place it to the left of the\n\
# current link in documents, or current option in select popup windows.\n\
# Positioning the cursor to the left of the current link or option is\n\
# helpful for speech or braille interfaces, and when the terminal is\n\
# one which does not distingish the current link based on highlighting\n\
# or color.  A value of \"on\" will set positioning to the left as the\n\
# default while a value of \"off\" will set 'hiding' of the cursor.\n\
# The default can be overridden via the -show_cursor command line toggle.\n");
d827 27
a853 23
    fprintf(fp, "\
# If keypad_mode is set to \"NUMBERS_AS_ARROWS\", then the numbers on\n\
# your keypad when the numlock is on will act as arrow keys:\n\
#             8 = Up Arrow\n\
#   4 = Left Arrow    6 = Right Arrow\n\
#             2 = Down Arrow\n\
# and the corresponding keyboard numbers will act as arrow keys,\n\
# regardless of whether numlock is on.\n");
    fprintf(fp, "\
# If keypad_mode is set to \"LINKS_ARE_NUMBERED\", then numbers will\n\
# appear next to each link and numbers are used to select links.\n");
    fprintf(fp, "\
# If keypad_mode is set to \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\", then\n\
# numbers will appear next to each link and visible form input field.\n\
# Numbers are used to select links, or to move the \"current link\" to a\n\
# form input field or button.  In addition, options in popup menus are\n\
# indexed so that the user may type an option number to select an option in\n\
# a popup menu, even if the option isn't visible on the screen.  Reference\n\
# lists and output from the list command also enumerate form inputs.\n");
    fprintf(fp, "\
# NOTE: Some fixed format documents may look disfigured when\n\
# \"LINKS_ARE_NUMBERED\" or \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\" are\n\
# enabled.\n");
d859 2
d862 1
a862 1
     *  Lineedit mode.
d864 27
a890 12
    fprintf(fp, "\
# linedit_mode specifies the key binding used for inputting strings in\n\
# prompts and forms.  If lineedit_mode is set to \"Default Binding\" then\n\
# the following control characters are used for moving and deleting:\n\
#\n\
#              Prev  Next       Enter = Accept input\n\
#    Move char: <-    ->        ^G    = Cancel input\n\
#    Move word: ^P    ^N        ^U    = Erase line\n\
#  Delete char: ^H    ^R        ^A    = Beginning of line\n\
#  Delete word: ^B    ^F        ^E    = End of line\n\
#\n\
# Current lineedit modes are:\n");
d899 3
d905 1
a905 1
     *  List directory style.
d907 6
a912 5
    fprintf(fp, "\
# dir_list_styles specifies the directory list style under DIRED_SUPPORT\n\
# (if implemented).  The default is \"MIXED_STYLE\", which sorts both\n\
# files and directories together.  \"FILES_FIRST\" lists files first and\n\
# \"DIRECTORIES_FIRST\" lists directories first.\n");
d923 8
a930 7
    fprintf(fp, "\
# user_mode specifies the users level of knowledge with Lynx.  The\n\
# default is \"NOVICE\" which displays two extra lines of help at the\n\
# bottom of the screen to aid the user in learning the basic Lynx\n\
# commands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\n\
# Use \"ADVANCED\" to see the URL of the currently selected link at the\n\
# bottom of the screen.\n");
d936 61
d1001 11
a1011 10
    fprintf(fp, "\
# If run_all_execution_links is set \"on\" then all local exection links\n\
# will be executed when they are selected.\n\
#\n\
# WARNING - This is potentially VERY dangerous.  Since you may view\n\
#           information that is written by unknown and untrusted sources\n\
#           there exists the possibility that Trojan horse links could be\n\
#           written.  Trojan horse links could be written to erase files\n\
#           or compromise security.  This should only be set to \"on\" if\n\
#           you are viewing trusted source information.\n");
d1018 14
a1031 13
    fprintf(fp, "\
# If run_execution_links_on_local_files is set \"on\" then all local\n\
# execution links that are found in LOCAL files will be executed when they\n\
# are selected.  This is different from run_all_execution_links in that\n\
# only files that reside on the local system will have execution link\n\
# permissions.\n\
#\n\
# WARNING - This is potentially dangerous.  Since you may view\n\
#           information that is written by unknown and untrusted sources\n\
#           there exists the possibility that Trojan horse links could be\n\
#           written.  Trojan horse links could be written to erase files\n\
#           or compromise security.  This should only be set to \"on\" if\n\
#           you are viewing trusted source information.\n");
d1036 8
a1047 3
#if defined(__DJGPP__) || defined(_WINDOWS)
    _fmode = O_BINARY;
#endif /* __DJGPP__ or _WINDOWS */
d1049 1
a1049 10
#ifdef VMS
    /*
     *  Get rid of any copies of the .lynxrc file that VMS creates.
     */
    while (remove("sys$login:.lynxrc;-1") == 0) ;
	/*
	 *  Reset version number.
	 */
	rename("sys$login:.lynxrc", "sys$login:.lynxrc;1");
#endif /* VMS */
d1051 1
a1051 1
   return TRUE;
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
