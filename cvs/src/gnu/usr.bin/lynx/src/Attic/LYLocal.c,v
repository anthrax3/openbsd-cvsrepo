head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.09;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.56;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYLocal.c,v 1.127 2013/11/28 11:19:31 tom Exp $
 *
 *  Routines to manipulate the local filesystem.
 *  Written by: Rick Mallett, Carleton University
 *  Report problems to rmallett@@ccs.carleton.ca
 *  Modified 18-Dec-95 David Trueman (david@@cs.dal.ca):
 *	Added OK_PERMIT compilation option.
 *	Support replacement of compiled-in f)ull menu configuration via
 *	  DIRED_MENU definitions in lynx.cfg, so that more than one menu
 *	  can be driven by the same executable.
 *  Modified Oct-96 Klaus Weide (kweide@@tezcat.com):
 *	Changed to use the library's HTList_* functions and macros for
 *	  managing the list of tagged file URLs.
 *	Keep track of proper level of URL escaping, so that unusual filenames
 *	  which contain #% etc. are handled properly (some HTUnEscapeSome()'s
 *	  left in to be conservative, and to document where superfluous
 *	  unescaping took place before).
 *	Dynamic memory instead of fixed length buffers in a few cases.
 *	Other minor changes to make things work as intended.
 *  Modified Jun-97 Klaus Weide (kweide@@tezcat.com) & FM:
 *	Modified the code handling DIRED_MENU to do more careful
 *	  checking of the selected file.  In addition to "TAG", "FILE", and
 *	  "DIR", DIRED_MENU definitions in lynx.cfg now also recognize LINK as
 *	  a type.  DIRED_MENU definitions with a type field of "LINK" are only
 *	  used if the current selection is a symbolic link ("FILE" and "DIR"
 *	  definitions are not used in that case).  The default menu
 *	  definitions have been updated to reflect this change, and to avoid
 *	  the showing of menu items whose action would always fail - KW
 *	Cast all code into the Lynx programming style. - FM
 */

#include <HTUtils.h>
#include <HTAAProt.h>
#include <HTFile.h>
#include <HTAlert.h>
#include <HTParse.h>
#include <LYCurses.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <LYCharUtils.h>
#include <LYStructs.h>
#include <LYHistory.h>
#include <LYUpload.h>
#include <LYLocal.h>
#include <LYClean.h>
#include <www_wait.h>

#ifdef SUPPORT_CHDIR
#include <LYMainLoop.h>
#endif

#include <LYLeaks.h>

#undef USE_COMPRESS

#ifdef __DJGPP__
#define EXT_TAR_GZ ".tgz"
#define EXT_TAR_Z  ".taz"
#define EXT_Z      ".z"
#else
#define EXT_TAR_GZ ".tar.gz"
#define EXT_TAR_Z  ".tar.Z"
#define EXT_Z      ".Z"
#endif

#ifndef DIRED_MAXBUF
#define DIRED_MAXBUF 512
#endif

#ifdef DIRED_SUPPORT

#ifdef OK_INSTALL
#ifdef FNAMES_8_3
#define INSTALLDIRS_FILE "instdirs.htm"
#else
#define INSTALLDIRS_FILE ".installdirs.html"
#endif /* FNAMES_8_3 */
#endif /* OK_INSTALL */

static int get_filename(const char *prompt,
			bstring *buf);

#ifdef OK_PERMIT
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath);
#endif /* OK_PERMIT */
/* *INDENT-OFF* */
static char *render_item ( const char *	s,
	const char *	path,
	const char *	dir,
	char *		buf,
	size_t		bufsize,
	int		url_syntax);

struct dired_menu {
    int cond;
#define DE_TAG     1
#define DE_DIR     2
#define DE_FILE    3
#define DE_SYMLINK 4
    char *sfx;
    const char *c_sfx;
    char *link;
    const char *c_link;
    char *rest;
    const char *c_rest;
    char *href;
    const char *c_href;
    struct dired_menu *next;
};

#define GetDiredSuffix(p) ((p)->sfx  ? (p)->sfx  : (p)->c_sfx)
#define GetDiredLink(p)   ((p)->link ? (p)->link : (p)->c_link)
#define GetDiredRest(p)   ((p)->rest ? (p)->rest : (p)->c_rest)
#define GetDiredHref(p)   ((p)->href ? (p)->href : (p)->c_href)

#undef DATA
#define DATA(cond, sfx, link, rest, href) { \
	cond, \
	NULL, sfx, \
	NULL, link, \
	NULL, rest, \
	NULL, href, \
	NULL }

static struct dired_menu *menu_head = NULL;
static struct dired_menu defmenu[] = {

/*
 * The following initializations determine the contents of the f)ull menu
 * selection when in dired mode.  If any menu entries are defined in the
 * configuration file via DIRED_MENU lines, then these default entries are
 * discarded entirely.
 */
#ifdef SUPPORT_CHDIR
DATA( 0,              "", "Change directory",
                      "", "LYNXDIRED://CHDIR"),
#endif
DATA( 0,              "", "New File",
"(in current directory)", "LYNXDIRED://NEW_FILE%d"),

DATA( 0,              "", "New Directory",
"(in current directory)", "LYNXDIRED://NEW_FOLDER%d"),

#ifdef OK_INSTALL
DATA( DE_FILE,        "", "Install",
"selected file to new location", "LYNXDIRED://INSTALL_SRC%p"),
/* The following (installing a directory) doesn't work for me, at least
   with the "install" from GNU fileutils 4.0.  I leave it in anyway, in
   case one compiles with INSTALL_PATH / INSTALL_ARGS defined to some
   other command for which it works (like a script, or maybe "cp -a"). - kw
*/
DATA( DE_DIR,         "", "Install",
"selected directory to new location", "LYNXDIRED://INSTALL_SRC%p"),
#endif /* OK_INSTALL */

DATA( DE_FILE,        "", "Modify File Name",
"(of current selection)", "LYNXDIRED://MODIFY_NAME%p"),
DATA( DE_DIR,         "", "Modify Directory Name",
"(of current selection)", "LYNXDIRED://MODIFY_NAME%p"),
#ifdef S_IFLNK
DATA( DE_SYMLINK,     "", "Modify Name",
"(of selected symbolic link)", "LYNXDIRED://MODIFY_NAME%p"),
#endif  /* S_IFLNK */

#ifdef OK_PERMIT
DATA( DE_FILE,        "", "Modify File Permissions",
"(of current selection)", "LYNXDIRED://PERMIT_SRC%p"),
DATA( DE_DIR,         "", "Modify Directory Permissions",
"(of current selection)", "LYNXDIRED://PERMIT_SRC%p"),
#endif /* OK_PERMIT */

DATA( DE_FILE,        "", "Change Location",
"(of selected file)"    , "LYNXDIRED://MODIFY_LOCATION%p"),
DATA( DE_DIR,         "", "Change Location",
"(of selected directory)", "LYNXDIRED://MODIFY_LOCATION%p"),
#ifdef S_IFLNK
DATA( DE_SYMLINK,     "", "Change Location",
"(of selected symbolic link)", "LYNXDIRED://MODIFY_LOCATION%p"),
#endif /* S_IFLNK */

DATA( DE_FILE,        "", "Remove File",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p"),
DATA( DE_DIR,         "", "Remove Directory",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p"),
#ifdef S_IFLNK
DATA( DE_SYMLINK,     "", "Remove Symbolic Link",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p"),
#endif /* S_IFLNK */

#if defined(OK_UUDECODE) && !defined(ARCHIVE_ONLY)
DATA( DE_FILE,        "", "UUDecode",
   "(current selection)", "LYNXDIRED://UUDECODE%p"),
#endif /* OK_UUDECODE && !ARCHIVE_ONLY */

#if defined(OK_TAR) && !defined(ARCHIVE_ONLY)
DATA( DE_FILE,        EXT_TAR_Z, "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_Z%p"),
#endif /* OK_TAR && !ARCHIVE_ONLY */

#if defined(OK_TAR) && defined(OK_GZIP) && !defined(ARCHIVE_ONLY)
DATA( DE_FILE,        ".tar.gz", "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_GZ%p"),

DATA( DE_FILE,        ".tgz", "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_GZ%p"),
#endif /* OK_TAR && OK_GZIP && !ARCHIVE_ONLY */

#ifndef ARCHIVE_ONLY
DATA( DE_FILE,        EXT_Z, "Uncompress",
   "(current selection)", "LYNXDIRED://DECOMPRESS%p"),
#endif /* ARCHIVE_ONLY */

#if defined(OK_GZIP) && !defined(ARCHIVE_ONLY)
DATA( DE_FILE,        ".gz", "Uncompress",
   "(current selection)", "LYNXDIRED://UNGZIP%p"),
#endif /* OK_GZIP && !ARCHIVE_ONLY */

#if defined(OK_ZIP) && !defined(ARCHIVE_ONLY)
DATA( DE_FILE,        ".zip", "Uncompress",
   "(current selection)", "LYNXDIRED://UNZIP%p"),
#endif /* OK_ZIP && !ARCHIVE_ONLY */

#if defined(OK_TAR) && !defined(ARCHIVE_ONLY)
DATA( DE_FILE,        ".tar", "UnTar",
   "(current selection)", "LYNXDIRED://UNTAR%p"),
#endif /* OK_TAR && !ARCHIVE_ONLY */

#ifdef OK_TAR
DATA( DE_DIR,         "", "Tar",
   "(current selection)", "LYNXDIRED://TAR%p"),
#endif /* OK_TAR */

#if defined(OK_TAR) && defined(OK_GZIP)
DATA( DE_DIR,         "", "Tar and compress",
      "(using GNU gzip)", "LYNXDIRED://TAR_GZ%p"),
#endif /* OK_TAR && OK_GZIP */

#if defined(OK_TAR) && defined(USE_COMPRESS)
DATA( DE_DIR,         "", "Tar and compress",
      "(using compress)", "LYNXDIRED://TAR_Z%p"),
#endif /* OK_TAR && USE_COMPRESS */

#ifdef OK_ZIP
DATA( DE_DIR,         "", "Package and compress",
           "(using zip)", "LYNXDIRED://ZIP%p"),
#endif /* OK_ZIP */

DATA( DE_FILE,        "", "Compress",
 "(using Unix compress)", "LYNXDIRED://COMPRESS%p"),

#ifdef OK_GZIP
DATA( DE_FILE,        "", "Compress",
          "(using gzip)", "LYNXDIRED://GZIP%p"),
#endif /* OK_GZIP */

#ifdef OK_ZIP
DATA( DE_FILE,        "", "Compress",
           "(using zip)", "LYNXDIRED://ZIP%p"),
#endif /* OK_ZIP */

DATA( DE_TAG,         "", "Move all tagged items to another location.",
                      "", "LYNXDIRED://MOVE_TAGGED%d"),

#ifdef OK_INSTALL
DATA( DE_TAG,         "", "Install tagged files into another directory.",
                      "", "LYNXDIRED://INSTALL_SRC%00"),
#endif

DATA( DE_TAG,         "", "Remove all tagged files and directories.",
                      "", "LYNXDIRED://REMOVE_TAGGED"),

DATA( DE_TAG,         "", "Untag all tagged files and directories.",
                      "", "LYNXDIRED://CLEAR_TAGGED"),

DATA( 0,              NULL, NULL,
                      NULL, NULL),
};
#undef DATA
/* *INDENT-ON* */

static BOOLEAN cannot_stat(const char *name)
{
    char *tmpbuf = 0;

    HTSprintf0(&tmpbuf, gettext("Unable to get status of '%s'."), name);
    HTAlert(tmpbuf);
    FREE(tmpbuf);
    return FALSE;
}

#define OK_STAT(name, sb) (stat(name, sb) == 0)

static BOOLEAN ok_stat(const char *name, struct stat *sb)
{
    BOOLEAN rc = TRUE;

    CTRACE((tfp, "testing ok_stat(%s)\n", name));
    if (!OK_STAT(name, sb)) {
#ifdef DOSPATH
	size_t len = strlen(name);

	/*
	 * If a path ends with '\' or ':', we can guess that it may be
	 * a directory name.  Adding a '.' (after a '\') will produce a
	 * pathname that stat() will accept as a directory name.
	 */
	if (len != 0 && (name[len - 1] == '\\' || name[len - 1] == ':')) {
	    char *temp = malloc(len + 3);

	    if (temp != 0) {
		strcpy(temp, name);
		if (temp[len - 1] == '\\') {
		    strcpy(temp + len, ".");
		} else {
		    strcpy(temp + len, "\\.");
		}
		rc = OK_STAT(temp, sb);
		free(temp);
	    } else {
		rc = FALSE;
	    }
	} else
#endif
	    rc = FALSE;
    }

    if (rc == FALSE)
	rc = cannot_stat(name);

    return rc;
}

#ifdef HAVE_LSTAT
static BOOLEAN ok_lstat(char *name, struct stat *sb)
{
    CTRACE((tfp, "testing ok_lstat(%s)\n", name));
    if (lstat(name, sb) < 0) {
	return cannot_stat(name);
    }
    return TRUE;
}
#else
#define ok_lstat(name,sb) ok_stat(name,sb)
#endif

static BOOLEAN ok_file_or_dir(struct stat *sb)
{
    if (!S_ISDIR(sb->st_mode)
	&& !S_ISREG(sb->st_mode)) {
	HTAlert(gettext("The selected item is not a file or a directory!  Request ignored."));
	return FALSE;
    }
    return TRUE;
}

#ifdef OK_INSTALL		/* currently only used in local_install */
static BOOLEAN ok_localname(char *dst, const char *src)
{
    struct stat dir_info;

    if (!ok_stat(src, &dir_info)
	|| !ok_file_or_dir(&dir_info)) {
	return FALSE;
    }
    if (strlen(src) >= DIRED_MAXBUF) {
	CTRACE((tfp, "filename too long in ok_localname!\n"));
	return FALSE;
    }
    strcpy(dst, src);
    return TRUE;
}
#endif /* OK_INSTALL */

#define MAX_ARGC 10

static char **make_argv(const char *command,...)
{
    static char *result[MAX_ARGC];
    int argc = 0;
    char *value;
    va_list ap;

    va_start(ap, command);
    result[0] = 0;
    StrAllocCopy(result[argc++], command);
    do {
	result[argc] = 0;
	value = (char *) va_arg(ap, char *);

	if (value != 0)
	    StrAllocCopy(result[argc], value);
    } while (result[argc++] != 0);
    va_end(ap);

    return result;
}

static void free_argv(char **argv)
{
    int argc;

    for (argc = 0; argv[argc] != 0; ++argc) {
	free(argv[argc]);
    }
}

/*
 * Execute DIRED command, return -1 or 0 on failure, 1 success.
 */
static int LYExecv(const char *path,
		   char **argv,
		   char *msg)
{
    int rc = 0;

#if defined(VMS)
    CTRACE((tfp, "LYExecv:  Called inappropriately! (path=%s)\n", path));
#else
    int n;
    char *tmpbuf = 0;

#if defined(__DJGPP__) || defined(_WINDOWS)
    stop_curses();
    HTSprintf0(&tmpbuf, "%s", path);
    for (n = 1; argv[n] != 0; n++)
	HTSprintf(&tmpbuf, " %s", argv[n]);
    HTSprintf(&tmpbuf, "\n");
    rc = LYSystem(tmpbuf) ? 0 : 1;
#else
    int pid;

#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;

#else
    int wstatus;
#endif

    if (TRACE) {
	CTRACE((tfp, "LYExecv path='%s'\n", path));
	for (n = 0; argv[n] != 0; n++)
	    CTRACE((tfp, "argv[%d] = '%s'\n", n, argv[n]));
    }

    rc = 1;			/* It will work */
    stop_curses();
    pid = fork();		/* fork and execute command */

    switch (pid) {
    case -1:
	HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	rc = 0;
	break;			/* don't fall thru! - KW */

    case 0:			/* child */
#ifdef USE_EXECVP
	execvp(path, argv);	/* this uses our $PATH */
#else
	execv(path, argv);
#endif
	exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	/*NOTREACHED */

    default:			/* parent */
#if !HAVE_WAITPID
	while (wait(&wstatus) != pid) ;		/* do nothing */
#else
	while (-1 == waitpid(pid, &wstatus, 0)) {	/* wait for child */
#ifdef EINTR
	    if (errno == EINTR)
		continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
	    if (errno == ERESTARTSYS)
		continue;
#endif /* ERESTARTSYS */
	    break;
	}
#endif /* !HAVE_WAITPID */
	if ((WIFEXITED(wstatus)
	     && (WEXITSTATUS(wstatus) != 0))
	    || (WIFSIGNALED(wstatus)
		&& (WTERMSIG(wstatus) > 0))) {	/* error return */
	    HTSprintf0(&tmpbuf,
		       gettext("Probable failure to %s due to system error!"),
		       msg);
	    rc = 0;
	}
    }
#endif /* __DJGPP__ */

    if (rc == 0) {
	/*
	 * Screen may have message from the failed execv'd command.  Give user
	 * time to look at it before screen refresh.
	 */
	LYSleepAlert();
    }
    start_curses();
    if (tmpbuf != 0) {
	if (rc == 0)
	    HTAlert(tmpbuf);
	FREE(tmpbuf);
    }
#endif /* VMS || _WINDOWS */
    CTRACE((tfp, "LYexecv ->%d\n", rc));
    return (rc);
}

static int make_directory(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppMKDIR)) != NULL) {
	char **args;
	char *msg = 0;

	HTSprintf0(&msg, "make directory %s", path);
	args = make_argv("mkdir",
			 path,
			 NULL);
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
	free_argv(args);
    } else {
#ifdef _WINDOWS
	code = mkdir(path) ? -1 : 1;
#else
	code = mkdir(path, 0777) ? -1 : 1;
#endif
	CTRACE((tfp, "builtin mkdir ->%d\n\t%s\n", code, path));
    }
    return (code);
}

static int remove_file(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppRM)) != NULL) {
	char **args;
	char *tmpbuf = NULL;

	args = make_argv("rm",
			 "-f",
			 path,
			 NULL);
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
	free_argv(args);
    } else {
	code = remove(path) ? -1 : 1;
	CTRACE((tfp, "builtin remove ->%d\n\t%s\n", code, path));
    }
    return (code);
}

static int remove_directory(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppRMDIR)) != NULL) {
	char **args;
	char *tmpbuf = NULL;

	args = make_argv("rmdir",
			 path,
			 NULL);
	HTSprintf0(&tmpbuf, gettext("remove %s"), path);
	code = LYExecv(program, args, tmpbuf);
	FREE(tmpbuf);
	free_argv(args);
    } else {
	code = rmdir(path) ? -1 : 1;
	CTRACE((tfp, "builtin rmdir ->%d\n\t%s\n", code, path));
    }
    return (code);
}

static int touch_file(char *path)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppTOUCH)) != NULL) {
	char **args;
	char *msg = NULL;

	HTSprintf0(&msg, gettext("touch %s"), path);
	args = make_argv("touch",
			 path,
			 NULL);
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
	free_argv(args);
    } else {
	FILE *fp;

	if ((fp = fopen(path, BIN_W)) != 0) {
	    fclose(fp);
	    code = 1;
	} else {
	    code = -1;
	}
	CTRACE((tfp, "builtin touch ->%d\n\t%s\n", code, path));
    }
    return (code);
}

static int move_file(char *source, char *target)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppMV)) != NULL) {
	char *msg = 0;
	char **args;

	HTSprintf0(&msg, gettext("move %s to %s"), source, target);
	args = make_argv("mv",
			 source,
			 target,
			 NULL);
	code = (LYExecv(program, args, msg) <= 0) ? -1 : 1;
	FREE(msg);
	free_argv(args);
    } else {
	struct stat sb;
	char *actual = 0;

	/* the caller sets up a target directory; we need a file path */
	if (stat(target, &sb) == 0
	    && S_ISDIR(sb.st_mode)) {
	    HTSprintf0(&actual, "%s/%s", target, LYPathLeaf(source));
	    CTRACE((tfp, "move_file source=%s, target=%s\n", source, target));
	    target = actual;
	}
	code = rename(source, target);
	CTRACE((tfp, "builtin move ->%d\n\tsource=%s\n\ttarget=%s\n",
		code, source, target));
	if (code != 0) {	/* it failed */
	    if ((code = LYCopyFile(source, target)) >= 0) {
		code = remove(source);
		CTRACE((tfp, "...remove source after copying ->%d\n", code));
	    }
	}
	if (code == 0)
	    code = 1;
	if (actual != target) {
	    FREE(actual);
	}
    }
    return code;
}

static BOOLEAN not_already_exists(char *name)
{
    struct stat dir_info;

    if (!OK_STAT(name, &dir_info)) {
	if (errno != ENOENT) {
	    cannot_stat(name);
	} else {
	    return TRUE;
	}
    } else if (S_ISDIR(dir_info.st_mode)) {
	HTAlert(gettext("There is already a directory with that name!  Request ignored."));
    } else if (S_ISREG(dir_info.st_mode)) {
	HTAlert(gettext("There is already a file with that name!  Request ignored."));
    } else {
	HTAlert(gettext("The specified name is already in use!  Request ignored."));
    }
    return FALSE;
}

static BOOLEAN dir_has_same_owner(struct stat *dst_info,
				  struct stat *src_info)
{
    if (S_ISDIR(dst_info->st_mode)) {
	if (dst_info->st_uid == src_info->st_uid) {
	    return TRUE;
	} else {
	    HTAlert(gettext("Destination has different owner!  Request denied."));
	}
    } else {
	HTAlert(gettext("Destination is not a valid directory!  Request denied."));
    }
    return FALSE;
}

/*
 * Make sure the source and target are not the same location.
 */
static BOOLEAN same_location(struct stat *dst_info,
			     struct stat *src_info)
{
    BOOLEAN result = FALSE;

#ifdef UNIX
    if (src_info->st_dev == dst_info->st_dev &&
	src_info->st_ino == dst_info->st_ino) {
	HTAlert(gettext("Source and destination are the same location!  Request ignored!"));
	result = TRUE;
    }
#endif
    return result;
}

/*
 * Remove all tagged files and directories.
 */
static int remove_tagged(void)
{
    int ans;
    BOOL will_clear = TRUE;
    char *cp;
    char *tmpbuf = NULL;
    char *testpath = NULL;
    struct stat dir_info;
    int count;
    HTList *tag;

    if (HTList_isEmpty(tagged))	/* should never happen */
	return 0;

    ans = HTConfirm(gettext("Remove all tagged files and directories?"));

    count = 0;
    tag = tagged;
    while (ans == YES && (cp = (char *) HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) {	/* unnecessary check */
	    testpath = HTfullURL_toFile(cp);
	    LYTrimPathSep(testpath);
	    will_clear = TRUE;

	    /*
	     * Check the current status of the path to be deleted.
	     */
	    if (!ok_stat(testpath, &dir_info)) {
		will_clear = FALSE;
		break;
	    } else {
		if (remove_file(testpath) <= 0) {
		    if (count == 0)
			count = -1;
		    will_clear = FALSE;
		    break;
		}
		++count;
		FREE(testpath);
	    }
	}
    }
    FREE(testpath);
    FREE(tmpbuf);
    if (will_clear)
	clear_tags();
    return count;
}

static char *parse_directory(char *path)
{
    char *result;

    if (path) {
	path = strip_trailing_slash(path);
	path = HTParse(".", path, PARSE_PATH + PARSE_PUNCTUATION);
	result = HTURLPath_toFile(path, TRUE, FALSE);
	FREE(path);
    } else {			/* Last resort, should never happen. */
	result = HTURLPath_toFile(".", TRUE, FALSE);
    }
    return result;
}

/*
 * Move all tagged files and directories to a new location.
 *
 * The 'testpath' parameter is the current location, used for resolving
 * relative target specifications.
 */
static int modify_tagged(char *testpath)
{
    char *cp;
    bstring *given_target = NULL;
    char *dst_path = NULL;
    char *src_path = NULL;
    char *old_path = NULL;
    struct stat src_info;
    struct stat dst_info;
    int count = 0;
    HTList *tag;

    CTRACE((tfp, "modify_tagged(%s)\n", testpath));

    if (HTList_isEmpty(tagged))	/* should never happen */
	return 0;

    _statusline(gettext("Enter new location for tagged items: "));

    BStrCopy0(given_target, "");
    (void) LYgetBString(&given_target, FALSE, 0, NORECALL);
    if (!isBEmpty(given_target)) {
	/*
	 * Replace ~/ references to the home directory.
	 */
	if (LYIsTilde(given_target->str[0]) && LYIsPathSep(given_target->str[1])) {
	    char *cp1 = NULL;

	    StrAllocCopy(cp1, Home_Dir());
	    StrAllocCat(cp1, (given_target->str + 1));
	    BStrCopy0(given_target, cp1);
	    FREE(cp1);
	}

	/*
	 * If path is relative, prefix it with current location.
	 */
	if (!LYIsPathSep(given_target->str[0])) {
	    dst_path = HTLocalName(testpath);
	    LYAddPathSep(&dst_path);
	    StrAllocCat(dst_path, given_target->str);
	} else {
	    dst_path = HTLocalName(given_target->str);
	}

	if (!ok_stat(dst_path, &dst_info)) {
	    FREE(dst_path);
	    BStrFree(given_target);
	    return 0;
	}

	/*
	 * Determine the ownership of the current location, using the directory
	 * containing the file or subdir from each of the tagged files.
	 */
	for (tag = tagged; (cp = (char *) HTList_nextObject(tag)) != NULL;) {
	    src_path = parse_directory(cp);

	    if (isEmpty(old_path) || strcmp(old_path, src_path)) {
		if (!ok_stat(src_path, &src_info)
		    || same_location(&src_info, &dst_info)
		    || !dir_has_same_owner(&dst_info, &src_info)) {
		    FREE(src_path);
		    BStrFree(given_target);
		    return 0;
		}
	    }
	    StrAllocCopy(old_path, src_path);
	    FREE(src_path);
	}

	/*
	 * Move all tagged items to the target location.
	 */
	for (tag = tagged; (cp = (char *) HTList_nextObject(tag)) != NULL;) {
	    src_path = HTfullURL_toFile(cp);

	    if (move_file(src_path, dst_path) < 0) {
		if (count == 0)
		    count = -1;
		break;
	    }
	    FREE(src_path);
	    ++count;
	}
	clear_tags();
	FREE(src_path);
	FREE(dst_path);
    }
    BStrFree(given_target);
    return count;
}

/*
 * Modify the name of the specified item.
 */
static int modify_name(char *testpath)
{
    const char *cp;
    bstring *tmpbuf = NULL;
    char *newpath = NULL;
    struct stat dir_info;
    int code = 0;

    /*
     * Determine the status of the selected item.
     */
    testpath = strip_trailing_slash(testpath);

    if (ok_stat(testpath, &dir_info)) {

	/*
	 * Change the name of the file or directory.
	 */
	if (S_ISDIR(dir_info.st_mode)) {
	    cp = gettext("Enter new name for directory: ");
	} else if (S_ISREG(dir_info.st_mode)) {
	    cp = gettext("Enter new name for file: ");
	} else {
	    return ok_file_or_dir(&dir_info);
	}

	BStrCopy0(tmpbuf, LYPathLeaf(testpath));
	if (get_filename(cp, tmpbuf)) {

	    /*
	     * Do not allow the user to also change the location at this time.
	     */
	    if (LYLastPathSep(tmpbuf->str) != 0) {
		HTAlert(gettext("Illegal character (path-separator) found! Request ignored."));
	    } else if (strlen(tmpbuf->str)) {
		if ((cp = LYLastPathSep(testpath)) != NULL) {
		    HTSprintf0(&newpath, "%.*s%s",
			       (int) (cp - testpath + 1),
			       testpath, tmpbuf->str);
		} else {
		    StrAllocCopy(newpath, tmpbuf->str);
		}

		/*
		 * Make sure the destination does not already exist.
		 */
		if (not_already_exists(newpath)) {
		    code = move_file(testpath, newpath);
		}
		FREE(newpath);
	    }
	}
    }
    BStrFree(tmpbuf);
    return code;
}

/*
 * Change the location of a file or directory.
 */
static int modify_location(char *testpath)
{
    const char *cp;
    char *sp;
    bstring *tmpbuf = NULL;
    char *newpath = NULL;
    char *savepath = NULL;
    struct stat old_info;
    struct stat dir_info;
    int code = 0;

    /*
     * Determine the status of the selected item.
     */
    testpath = strip_trailing_slash(testpath);
    if (!ok_stat(testpath, &dir_info)) {
	return 0;
    }

    /*
     * Change the location of the file or directory.
     */
    if (S_ISDIR(dir_info.st_mode)) {
	cp = gettext("Enter new location for directory: ");
    } else if (S_ISREG(dir_info.st_mode)) {
	cp = gettext("Enter new location for file: ");
    } else {
	return ok_file_or_dir(&dir_info);
    }

    BStrCopy0(tmpbuf, testpath);
    *LYPathLeaf(tmpbuf->str) = '\0';
    if (get_filename(cp, tmpbuf)) {
	if (strlen(tmpbuf->str)) {
	    StrAllocCopy(savepath, testpath);
	    StrAllocCopy(newpath, testpath);

	    /*
	     * Allow ~/ references to the home directory.
	     */
	    if (LYIsTilde(tmpbuf->str[0])
		&& (tmpbuf->str[1] == '\0' || LYIsPathSep(tmpbuf->str[1]))) {
		StrAllocCopy(newpath, Home_Dir());
		StrAllocCat(newpath, (tmpbuf->str + 1));
		BStrCopy0(tmpbuf, newpath);
	    }
	    if (LYisAbsPath(tmpbuf->str)) {
		StrAllocCopy(newpath, tmpbuf->str);
	    } else if ((sp = LYLastPathSep(newpath)) != NULL) {
		*++sp = '\0';
		StrAllocCat(newpath, tmpbuf->str);
	    } else {
		HTAlert(gettext("Unexpected failure - unable to find trailing path separator"));
		FREE(newpath);
		FREE(savepath);
		BStrFree(tmpbuf);
		return 0;
	    }

	    /*
	     * Make sure the source and target have the same owner (uid).
	     */
	    old_info = dir_info;
	    if (!ok_stat(newpath, &dir_info)) {
		code = 0;
	    } else if (same_location(&old_info, &dir_info)) {
		code = 0;
	    } else if (dir_has_same_owner(&dir_info, &old_info)) {
		code = move_file(savepath, newpath);
	    }
	    FREE(newpath);
	    FREE(savepath);
	}
    }
    BStrFree(tmpbuf);
    return code;
}

/*
 * Modify name or location of a file or directory on localhost.
 */
int local_modify(DocInfo *doc, char **newpath)
{
    int ans;
    char *cp;
    bstring *testpath = NULL;
    int count;
    int code = 0;

    if (!HTList_isEmpty(tagged)) {
	cp = HTpartURL_toFile(doc->address);

	count = modify_tagged(cp);
	FREE(cp);

	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
	doc->link = ((doc->link < 0)
		     ? 0
		     : doc->link);

	return count;
    } else if (doc->link < 0 || doc->link > nlinks) {
	/*
	 * Added protection.
	 */
	return 0;
    }

    /*
     * Do not allow simultaneous change of name and location as in Unix.  This
     * reduces functionality but reduces difficulty for the novice.
     */
#ifdef OK_PERMIT
    _statusline(gettext("Modify name, location, or permission (n, l, or p): "));
#else
    _statusline(gettext("Modify name or location (n or l): "));
#endif /* OK_PERMIT */
    ans = LYgetch_single();

    if (StrChr("NLP", ans) != NULL) {
	cp = HTfullURL_toFile(links[doc->link].lname);
	if (strlen(cp) >= DIRED_MAXBUF) {
	    FREE(cp);
	    return 0;
	}
	BStrCopy0(testpath, cp);
	FREE(cp);

	if (ans == 'N') {
	    code = modify_name(testpath->str);
	} else if (ans == 'L') {
	    if (modify_location(testpath->str)) {
		if (doc->link == (nlinks - 1))
		    --doc->link;
		code = 1;
	    }
#ifdef OK_PERMIT
	} else if (ans == 'P') {
	    code = permit_location(NULL, testpath->str, newpath);
#endif /* OK_PERMIT */
	} else {
	    /*
	     * Code for changing ownership needed here.
	     */
	    HTAlert(gettext("This feature not yet implemented!"));
	}
    }
    BStrFree(testpath);
    return code;
}

#define BadChars() ((!no_dotfiles && show_dotfiles) \
		    ? "~/" \
		    : ".~/")

/*
 * Create a new empty file in the current directory.
 */
static int create_file(char *current_location)
{
    int code = FALSE;
    bstring *tmpbuf = NULL;
    char *testpath = NULL;

    BStrCopy0(tmpbuf, "");
    if (get_filename(gettext("Enter name of file to create: "), tmpbuf)) {

	if (strstr(tmpbuf->str, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf->str) &&
		   StrChr(BadChars(), tmpbuf->str[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);

	    /*
	     * Append the target filename to the current location.
	     */
	    StrAllocCat(testpath, tmpbuf->str);

	    /*
	     * Make sure the target does not already exist
	     */
	    if (not_already_exists(testpath)) {
		code = touch_file(testpath);
	    }
	    FREE(testpath);
	}
    }
    BStrFree(tmpbuf);
    return code;
}

/*
 * Create a new directory in the current directory.
 */
static int create_directory(char *current_location)
{
    int code = FALSE;
    bstring *tmpbuf = NULL;
    char *testpath = NULL;

    BStrCopy0(tmpbuf, "");
    if (get_filename(gettext("Enter name for new directory: "), tmpbuf)) {

	if (strstr(tmpbuf->str, "//") != NULL) {
	    HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
	} else if (strlen(tmpbuf->str) &&
		   StrChr(BadChars(), tmpbuf->str[0]) == NULL) {
	    StrAllocCopy(testpath, current_location);
	    LYAddPathSep(&testpath);

	    StrAllocCat(testpath, tmpbuf->str);

	    /*
	     * Make sure the target does not already exist.
	     */
	    if (not_already_exists(testpath)) {
		code = make_directory(testpath);
	    }
	    FREE(testpath);
	}
    }
    BStrFree(tmpbuf);
    return code;
}

/*
 * Create a file or a directory at the current location.
 */
int local_create(DocInfo *doc)
{
    int ans;
    char *cp;
    char testpath[DIRED_MAXBUF];

    cp = HTfullURL_toFile(doc->address);
    if (strlen(cp) >= DIRED_MAXBUF) {
	FREE(cp);
	return 0;
    }
    strcpy(testpath, cp);
    FREE(cp);

    _statusline(gettext("Create file or directory (f or d): "));
    ans = LYgetch_single();

    if (ans == 'F') {
	return (create_file(testpath));
    } else if (ans == 'D') {
	return (create_directory(testpath));
    } else {
	return 0;
    }
}

/*
 * Remove a single file or directory.
 */
static int remove_single(char *testpath)
{
    int code = 0;
    char *cp;
    char *tmpbuf = 0;
    struct stat dir_info;
    BOOL is_directory = FALSE;

    if (!ok_lstat(testpath, &dir_info)) {
	return 0;
    }

    /*
     * Locate the filename portion of the path.
     */
    if ((cp = LYLastPathSep(testpath)) != NULL) {
	++cp;
    } else {
	cp = testpath;
    }
    if (S_ISDIR(dir_info.st_mode)) {
	/*
	 * This strlen stuff will probably screw up intl translations.  Course,
	 * it's probably broken for screen sizes other 80, too -jes
	 */
	if (strlen(cp) < 37) {
	    HTSprintf0(&tmpbuf,
		       gettext("Remove directory '%s'?"), cp);
	} else {
	    HTSprintf0(&tmpbuf,
		       gettext("Remove directory?"));
	}
	is_directory = TRUE;
    } else if (S_ISREG(dir_info.st_mode)) {
	if (strlen(cp) < 60) {
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s'?"), cp);
	} else {
	    HTSprintf0(&tmpbuf, gettext("Remove file?"));
	}
#ifdef S_IFLNK
    } else if (S_ISLNK(dir_info.st_mode)) {
	if (strlen(cp) < 50) {
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s'?"), cp);
	} else {
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link?"));
	}
#endif
    } else {
	cannot_stat(testpath);
	FREE(tmpbuf);
	return 0;
    }

    if (HTConfirm(tmpbuf) == YES) {
	code = is_directory
	    ? remove_directory(testpath)
	    : remove_file(testpath);
    }
    FREE(tmpbuf);
    return code;
}

/*
 * Remove a file or a directory.
 */
int local_remove(DocInfo *doc)
{
    char *cp, *tp;
    char testpath[DIRED_MAXBUF];
    int count, i;

    if (!HTList_isEmpty(tagged)) {
	count = remove_tagged();
	if (doc->link > (nlinks - count - 1))
	    doc->link = (nlinks - count - 1);
	doc->link = ((doc->link < 0)
		     ? 0
		     : doc->link);
	return count;
    } else if (doc->link < 0 || doc->link > nlinks) {
	return 0;
    }
    cp = links[doc->link].lname;
    if (is_url(cp) == FILE_URL_TYPE) {
	tp = HTfullURL_toFile(cp);
	if (strlen(tp) >= DIRED_MAXBUF) {
	    FREE(tp);
	    return 0;
	}
	strcpy(testpath, tp);
	FREE(tp);

	if ((i = (int) strlen(testpath)) && testpath[i - 1] == '/')
	    testpath[(i - 1)] = '\0';

	if (remove_single(testpath)) {
	    if (doc->link == (nlinks - 1))
		--doc->link;
	    return 1;
	}
    }
    return 0;
}

#ifdef OK_PERMIT

static bstring *LYValidPermitFile = NULL;

static long permit_bits(char *string_mode)
{
    if (!strcmp(string_mode, "IRUSR"))
	return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR"))
	return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR"))
	return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP"))
	return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP"))
	return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP"))
	return S_IXGRP;
    if (!strcmp(string_mode, "IROTH"))
	return S_IROTH;
    if (!strcmp(string_mode, "IWOTH"))
	return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH"))
	return S_IXOTH;
    /* Don't include setuid and friends; use shell access for that. */
    return 0;
}

/*
 * Handle DIRED permissions.
 */
static int permit_location(char *destpath,
			   char *srcpath,
			   char **newpath)
{
    int code = 0;

#ifndef UNIX
    HTAlert(gettext("Sorry, don't know how to permit non-UNIX files yet."));
#else
    static char tempfile[LY_MAXPATH] = "\0";
    char *cp;
    char tmpdst[LY_MAXPATH];
    struct stat dir_info;
    const char *program;

    if (srcpath) {
	/*
	 * Create form.
	 */
	FILE *fp0;
	char *user_filename;
	const char *group_name;

	srcpath = strip_trailing_slash(srcpath);

	/*
	 * A couple of sanity tests.
	 */
	if (!ok_lstat(srcpath, &dir_info)
	    || !ok_file_or_dir(&dir_info))
	    return code;

	user_filename = LYPathLeaf(srcpath);

	(void) LYRemoveTemp(tempfile);
	if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	    HTAlert(gettext("Unable to open permit options file"));
	    return (code);
	}

	/*
	 * Make the tempfile a URL.
	 */
	LYLocalFileToURL(newpath, tempfile);
	LYRegisterUIPage(*newpath, UIP_PERMIT_OPTIONS);

	group_name = HTAA_GidToName((int) dir_info.st_gid);
	BStrCopy0(LYValidPermitFile, srcpath);

	fprintf(fp0, "<Html><Head>\n<Title>%s</Title>\n</Head>\n<Body>\n",
		PERMIT_OPTIONS_TITLE);
	fprintf(fp0, "<H1>%s%s</H1>\n", PERMISSIONS_SEGMENT, user_filename);
	{
	    /*
	     * Prevent filenames which include '#' or '?' from messing it up.
	     */
	    char *srcpath_url = HTEscape(srcpath, URL_PATH);

	    fprintf(fp0, "<Form Action=\"%s//PERMIT_LOCATION%s\">\n",
		    STR_LYNXDIRED, srcpath_url);
	    FREE(srcpath_url);
	}

	fprintf(fp0, "<Ol><Li>%s<Br><Br>\n",
		gettext("Specify permissions below:"));
	fprintf(fp0, "%s:<Br>\n", gettext("Owner:"));
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",
		(dir_info.st_mode & S_IRUSR) ? "checked" : "");
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",
		(dir_info.st_mode & S_IWUSR) ? "checked" : "");
	/*
	 * If restricted, only change eXecute permissions on directories.
	 */
	if (!no_change_exec_perms || S_ISDIR(dir_info.st_mode))
	    fprintf(fp0,
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXUSR) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");

	fprintf(fp0, "%s %s:<Br>\n", gettext("Group"), group_name);
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",
		(dir_info.st_mode & S_IRGRP) ? "checked" : "");
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",
		(dir_info.st_mode & S_IWGRP) ? "checked" : "");
	/*
	 * If restricted, only change eXecute permissions on directories.
	 */
	if (!no_change_exec_perms || S_ISDIR(dir_info.st_mode))
	    fprintf(fp0,
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXGRP) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");

	fprintf(fp0, "%s<Br>\n", gettext("Others:"));
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",
		(dir_info.st_mode & S_IROTH) ? "checked" : "");
	fprintf(fp0,
		"<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",
		(dir_info.st_mode & S_IWOTH) ? "checked" : "");
	/*
	 * If restricted, only change eXecute permissions on directories.
	 */
	if (!no_change_exec_perms || S_ISDIR(dir_info.st_mode))
	    fprintf(fp0,
		    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",
		    (dir_info.st_mode & S_IXOTH) ? "checked" : "",
		    S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");

	fprintf(fp0,
		"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
		gettext("form to permit"),
		S_ISDIR(dir_info.st_mode) ? "directory" : "file",
		user_filename);
	fprintf(fp0, "</Body></Html>");
	LYCloseTempFP(fp0);

	LYforce_no_cache = TRUE;
	code = PERMIT_FORM_RESULT;	/* Special flag for LYMainLoop */

    } else {			/* The form being activated. */
	mode_t new_mode = 0;

	/*
	 * Make sure we have a valid set-permission file comparison string
	 * loaded via a previous call with srcpath != NULL.  - KW
	 */
	if (isBEmpty(LYValidPermitFile)) {
	    if (LYCursesON)
		HTAlert(INVALID_PERMIT_URL);
	    else
		fprintf(stderr, "%s\n", INVALID_PERMIT_URL);
	    CTRACE((tfp, "permit_location: called for <%s>.\n",
		    (destpath ?
		     destpath : "NULL URL pointer")));
	    return code;
	}
	cp = destpath;
	while (*cp != '\0' && *cp != '?') {	/* Find filename */
	    cp++;
	}
	if (*cp == '\0') {
	    return (code);	/* Nothing to permit. */
	}
	*cp++ = '\0';		/* Null terminate file name and
				   start working on the masks. */

	/* Will now operate only on filename part. */
	if ((destpath = HTURLPath_toFile(destpath, TRUE, FALSE)) == 0)
	    return (code);
	if (strlen(destpath) >= LY_MAXPATH) {
	    FREE(destpath);
	    return (code);
	}
	strcpy(tmpdst, destpath);
	FREE(destpath);
	destpath = tmpdst;

	/*
	 * Make sure that the file string is the one from the last displayed
	 * File Permissions menu.  - KW
	 */
	if (strcmp(destpath, LYValidPermitFile->str)) {
	    if (LYCursesON)
		HTAlert(INVALID_PERMIT_URL);
	    else
		fprintf(stderr, "%s\n", INVALID_PERMIT_URL);
	    CTRACE((tfp, "permit_location: called for file '%s'.\n",
		    destpath));
	    return code;
	}

	/*
	 * A couple of sanity tests.
	 */
	destpath = strip_trailing_slash(destpath);
	if (!ok_stat(destpath, &dir_info)
	    || !ok_file_or_dir(&dir_info)) {
	    return code;
	}

	/*
	 * Cycle over permission strings.
	 */
	while (*cp != '\0') {
	    char *cr = cp;

	    while (*cr != '\0' && *cr != '&') {		/* GET data split by '&'. */
		cr++;
	    }
	    if (*cr != '\0') {
		*cr++ = '\0';
	    }
	    if (StrNCmp(cp, "mode=", 5) == 0) {		/* Magic string. */
		long mask = permit_bits(cp + 5);

		if (mask != 0) {
		    /*
		     * If restricted, only change eXecute permissions on
		     * directories.
		     */
		    if (!no_change_exec_perms
			|| StrChr(cp + 5, 'X') == NULL
			|| S_ISDIR(dir_info.st_mode)) {
			new_mode |= (mode_t) mask;
		    }
		} else {
		    HTAlert(gettext("Invalid mode format."));
		    return code;
		}
	    } else {
		HTAlert(gettext("Invalid syntax format."));
		return code;
	    }

	    cp = cr;
	}

	/*
	 * Call chmod().
	 */
	code = 1;
	if ((program = HTGetProgramPath(ppCHMOD)) != NULL) {
	    char **args;
	    char amode[10];
	    char *tmpbuf = NULL;

	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned) new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned) new_mode);
	    args = make_argv("chmod",
			     amode,
			     destpath,
			     NULL);
	    if (LYExecv(program, args, tmpbuf) <= 0) {
		code = -1;
	    }
	    FREE(tmpbuf);
	    free_argv(args);
	} else {
	    if (chmod(destpath, new_mode) < 0) {
		code = -1;
	    }
	    CTRACE((tfp, "builtin chmod %.4o ->%d\n\t%s\n",
		    (unsigned) new_mode, code, destpath));
	}
	if (code == 1)
	    LYforce_no_cache = TRUE;	/* Force update of dired listing. */
    }
#endif /* !UNIX */
    return code;
}
#endif /* OK_PERMIT */

/*
 * Display or remove a tag from a given link.
 */
void tagflag(int flag,
	     int cur)
{
    if (nlinks > 0) {
	LYmove(links[cur].ly, 2);
	lynx_stop_reverse();
	if (flag == TRUE) {
	    LYaddch('+');
	} else {
	    LYaddch(' ');
	}

#if defined(FANCY_CURSES) || defined(USE_SLANG)
	if (!LYShowCursor)
	    LYHideCursor();	/* get cursor out of the way */
	else
#endif /* FANCY CURSES || USE_SLANG */
	    /*
	     * Never hide the cursor if there's no FANCY CURSES.
	     */
	    LYmove(links[cur].ly, links[cur].lx);

	LYrefresh();
    }
}

/*
 * Handle DIRED tags.
 */
void showtags(HTList *t)
{
    int i;
    HTList *s;
    char *name;

    for (i = 0; i < nlinks; i++) {
	s = t;
	while ((name = (char *) HTList_nextObject(s)) != NULL) {
	    if (!strcmp(links[i].lname, name)) {
		tagflag(TRUE, i);
		break;
	    }
	}
    }
}

static char *DirectoryOf(char *pathname)
{
    char *result = 0;
    char *leaf;

    StrAllocCopy(result, pathname);
    leaf = LYPathLeaf(result);

    if (leaf != result) {
	const char *result1 = 0;

	*leaf = '\0';
	if (!LYisRootPath(result))
	    LYTrimPathSep(result);
	result1 = wwwName(result);
	StrAllocCopy(result, result1);
    }
    return result;
}

#ifdef __DJGPP__
/*
 * Convert filenames to acceptable 8+3 names when necessary.  Make a copy of
 * the parameter if we must modify it.
 */
static char *LYonedot(char *line)
{
    char *dot;
    static char line1[LY_MAXPATH];

    if (pathconf(line, _PC_NAME_MAX) <= 12) {
	LYStrNCpy(line1, line, sizeof(line1) - 1);
	for (;;) {
	    if ((dot = strrchr(line1, '.')) == 0
		|| LYLastPathSep(dot) != 0) {
		break;
	    } else if (strlen(dot) == 1) {
		*dot = 0;
	    } else {
		*dot = '_';
	    }
	}
	return (line1);
    }
    return (line);
}
#else
#define LYonedot(path) path
#endif /*  __DJGPP__ */

static char *match_op(const char *prefix,
		      char *data)
{
    size_t len = strlen(prefix);

    if (!StrNCmp("LYNXDIRED://", data, 12)
	&& !StrNCmp(prefix, data + 12, len)) {
	len += 12;
#if defined(USE_DOS_DRIVES)
	if (data[len] == '/') {	/* this is normal */
	    len++;
	}
#endif
	return data + len;
    }
    return 0;
}

/*
 * Construct the appropriate system command taking care to escape all path
 * references to avoid spoofing the shell.
 */
static char *build_command(char *line,
			   char *dirName,
			   char *arg)
{
    char *buffer = NULL;
    const char *program;
    const char *tar_path = HTGetProgramPath(ppTAR);

    if ((arg = match_op("DECOMPRESS", line)) != 0) {
#define FMT_UNCOMPRESS "%s %s"
	if ((program = HTGetProgramPath(ppUNCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, arg);
	    HTEndParam(&buffer, FMT_UNCOMPRESS, 2);
	}
	return buffer;
    }
#if defined(OK_UUDECODE) && !defined(ARCHIVE_ONLY)
    if ((arg = match_op("UUDECODE", line)) != 0) {
#define FMT_UUDECODE "%s %s"
	if ((program = HTGetProgramPath(ppUUDECODE)) != NULL) {
	    HTAddParam(&buffer, FMT_UUDECODE, 1, program);
	    HTAddParam(&buffer, FMT_UUDECODE, 2, arg);
	    HTEndParam(&buffer, FMT_UUDECODE, 2);
	    HTAlert(gettext("Warning!  UUDecoded file will exist in the directory you started Lynx."));
	}
	return buffer;
    }
#endif /* OK_UUDECODE && !ARCHIVE_ONLY */

#ifdef OK_TAR
    if (tar_path != NULL) {
# ifndef ARCHIVE_ONLY
#  ifdef OK_GZIP
	if ((arg = match_op("UNTAR_GZ", line)) != 0) {
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s %s %s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirName = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirName);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 4, tar_path);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_GZ, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_GZ, 6);
	    }
	    return buffer;
	}
#  endif /* OK_GZIP */
	if ((arg = match_op("UNTAR_Z", line)) != 0) {
#define FMT_UNTAR_Z "cd %s; %s %s |  %s %s %s"
	    if ((program = HTGetProgramPath(ppZCAT)) != NULL) {
		dirName = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirName);
		HTAddParam(&buffer, FMT_UNTAR_Z, 2, program);
		HTAddParam(&buffer, FMT_UNTAR_Z, 3, arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 4, tar_path);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 5, TAR_DOWN_OPTIONS);
		HTAddToCmd(&buffer, FMT_UNTAR_Z, 6, TAR_PIPE_OPTIONS);
		HTEndParam(&buffer, FMT_UNTAR_Z, 6);
	    }
	    return buffer;
	}
	if ((arg = match_op("UNTAR", line)) != 0) {
#define FMT_UNTAR "cd %s; %s %s %s"
	    dirName = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR, 1, dirName);
	    HTAddParam(&buffer, FMT_UNTAR, 2, tar_path);
	    HTAddToCmd(&buffer, FMT_UNTAR, 3, TAR_DOWN_OPTIONS);
	    HTAddParam(&buffer, FMT_UNTAR, 4, arg);
	    HTEndParam(&buffer, FMT_UNTAR, 4);
	    return buffer;
	}
# endif	/* !ARCHIVE_ONLY */

# ifdef OK_GZIP
	if ((arg = match_op("TAR_GZ", line)) != 0) {
#define FMT_TAR_GZ "cd %s; %s %s %s %s | %s -qc >%s%s"
	    if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
		dirName = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_GZ, 1, dirName);
		HTAddParam(&buffer, FMT_TAR_GZ, 2, tar_path);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_GZ, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_GZ, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_GZ, 6, program);
		HTAddParam(&buffer, FMT_TAR_GZ, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_GZ, 8, EXT_TAR_GZ);
		HTEndParam(&buffer, FMT_TAR_GZ, 8);
	    }
	    return buffer;
	}
# endif	/* OK_GZIP */

	if ((arg = match_op("TAR_Z", line)) != 0) {
#define FMT_TAR_Z "cd %s; %s %s %s %s | %s >%s%s"
	    if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
		dirName = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_Z, 1, dirName);
		HTAddParam(&buffer, FMT_TAR_Z, 2, tar_path);
		HTAddToCmd(&buffer, FMT_TAR_Z, 3, TAR_UP_OPTIONS);
		HTAddToCmd(&buffer, FMT_TAR_Z, 4, TAR_PIPE_OPTIONS);
		HTAddParam(&buffer, FMT_TAR_Z, 5, LYPathLeaf(arg));
		HTAddParam(&buffer, FMT_TAR_Z, 6, program);
		HTAddParam(&buffer, FMT_TAR_Z, 7, LYonedot(LYPathLeaf(arg)));
		HTAddParam(&buffer, FMT_TAR_Z, 8, EXT_TAR_Z);
		HTEndParam(&buffer, FMT_TAR_Z, 8);
	    }
	    return buffer;
	}

	if ((arg = match_op("TAR", line)) != 0) {
#define FMT_TAR "cd %s; %s %s %s %s.tar %s"
	    dirName = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_TAR, 1, dirName);
	    HTAddParam(&buffer, FMT_TAR, 2, tar_path);
	    HTAddToCmd(&buffer, FMT_TAR, 3, TAR_UP_OPTIONS);
	    HTAddToCmd(&buffer, FMT_TAR, 4, TAR_FILE_OPTIONS);
	    HTAddParam(&buffer, FMT_TAR, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 6, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_TAR, 6);
	    return buffer;
	}
    }
#endif /* OK_TAR */

#ifdef OK_GZIP
    if ((arg = match_op("GZIP", line)) != 0) {
#define FMT_GZIP "%s -q %s"
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_GZIP, 1, program);
	    HTAddParam(&buffer, FMT_GZIP, 2, arg);
	    HTEndParam(&buffer, FMT_GZIP, 2);
	}
	return buffer;
    }
#ifndef ARCHIVE_ONLY
    if ((arg = match_op("UNGZIP", line)) != 0) {
#define FMT_UNGZIP "%s -d %s"
	if ((program = HTGetProgramPath(ppGZIP)) != NULL) {
	    HTAddParam(&buffer, FMT_UNGZIP, 1, program);
	    HTAddParam(&buffer, FMT_UNGZIP, 2, arg);
	    HTEndParam(&buffer, FMT_UNGZIP, 2);
	}
	return buffer;
    }
#endif /* !ARCHIVE_ONLY */
#endif /* OK_GZIP */

#ifdef OK_ZIP
    if ((arg = match_op("ZIP", line)) != 0) {
#define FMT_ZIP "cd %s; %s -rq %s.zip %s"
	if ((program = HTGetProgramPath(ppZIP)) != NULL) {
	    dirName = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_ZIP, 1, dirName);
	    HTAddParam(&buffer, FMT_ZIP, 2, program);
	    HTAddParam(&buffer, FMT_ZIP, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_ZIP, 4);
	}
	return buffer;
    }
#if !defined(ARCHIVE_ONLY)
    if ((arg = match_op("UNZIP", line)) != 0) {
#define FMT_UNZIP "cd %s; %s -q %s"
	if ((program = HTGetProgramPath(ppUNZIP)) != NULL) {
	    dirName = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNZIP, 1, dirName);
	    HTAddParam(&buffer, FMT_UNZIP, 2, program);
	    HTAddParam(&buffer, FMT_UNZIP, 3, arg);
	    HTEndParam(&buffer, FMT_UNZIP, 3);
	}
	return buffer;
    }
# endif	/* !ARCHIVE_ONLY */
#endif /* OK_ZIP */

    if ((arg = match_op("COMPRESS", line)) != 0) {
#define FMT_COMPRESS "%s %s"
	if ((program = HTGetProgramPath(ppCOMPRESS)) != NULL) {
	    HTAddParam(&buffer, FMT_COMPRESS, 1, program);
	    HTAddParam(&buffer, FMT_COMPRESS, 2, arg);
	    HTEndParam(&buffer, FMT_COMPRESS, 2);
	}
	return buffer;
    }

    return NULL;
}

/*
 * Perform file management operations for LYNXDIRED URL's.  Attempt to be
 * consistent.  These are (pseudo) URLs - i.e., they should be in URL syntax: 
 * some bytes will be URL-escaped with '%'.  This is necessary because these
 * (pseudo) URLs will go through some of the same kinds of interpretations and
 * mutilations as real ones:  HTParse, stripping off #fragments etc.  (Some
 * access schemes currently have special rules about not escaping parsing '#'
 * "the URL way" built into HTParse, but that doesn't look like a clean way.)
 */
int local_dired(DocInfo *doc)
{
    char *line_url;		/* will point to doc's address, which is a URL */
    char *line = NULL;		/* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL;		/* ...will point into line[] */
    char *tp = NULL;
    char *tmpbuf = NULL;
    char *buffer = NULL;
    char *dirName = NULL;
    BOOL do_pop_doc = TRUE;

    line_url = doc->address;
    CTRACE((tfp, "local_dired: called for <%s>.\n",
	    (line_url
	     ? line_url
	     : gettext("NULL URL pointer"))));
    HTUnEscapeSome(line_url, "/");	/* don't mess too much with *doc */

    StrAllocCopy(line, line_url);
    HTUnEscape(line);		/* _file_ (not URL) syntax, for those functions
				   that need it.  Don't forget to FREE it. */
    if (match_op("CHDIR", line) != 0) {
#ifdef SUPPORT_CHDIR
	handle_LYK_CHDIR();
	do_pop_doc = FALSE;
#endif
	arg = 0;		/* do something to avoid cc's complaints */
    } else if ((arg = match_op("NEW_FILE", line)) != 0) {
	if (create_file(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("NEW_FOLDER", line)) != 0) {
	if (create_directory(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_INSTALL
    } else if ((arg = match_op("INSTALL_SRC", line)) != 0) {
	local_install(NULL, arg, &tp);
	if (tp) {
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("INSTALL_DEST", line)) != 0) {
	local_install(arg, NULL, &tp);
	LYpop(doc);
#endif /* OK_INSTALL */
    } else if ((arg = match_op("MODIFY_NAME", line)) != 0) {
	if (modify_name(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MODIFY_LOCATION", line)) != 0) {
	if (modify_location(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if ((arg = match_op("MOVE_TAGGED", line_url)) != 0) {
	if (modify_tagged(arg) > 0)
	    LYforce_no_cache = TRUE;
#ifdef OK_PERMIT
    } else if ((arg = match_op("PERMIT_SRC", line)) != 0) {
	permit_location(NULL, arg, &tp);
	if (tp) {
	    /*
	     * One of the checks may have failed.
	     */
	    FREE(doc->address);
	    doc->address = tp;
	}
	FREE(line);
	return 0;
    } else if ((arg = match_op("PERMIT_LOCATION", line_url)) != 0) {
	permit_location(arg, NULL, &tp);
#endif /* OK_PERMIT */
    } else if ((arg = match_op("REMOVE_SINGLE", line)) != 0) {
	if (remove_single(arg) > 0)
	    LYforce_no_cache = TRUE;
    } else if (match_op("REMOVE_TAGGED", line) != 0) {
	if (remove_tagged())
	    LYforce_no_cache = TRUE;
    } else if (match_op("CLEAR_TAGGED", line) != 0) {
	clear_tags();
    } else if ((arg = match_op("UPLOAD", line)) != 0) {
	/*
	 * They're written by LYUpload_options() HTUnEscaped; don't want to
	 * change that for now...  so pass through without more unescaping. 
	 * Directory names containing '#' will probably fail.
	 */
	if (LYUpload(line_url))
	    LYforce_no_cache = TRUE;
    } else {
	LYTrimPathSep(line);
	if (LYLastPathSep(line) == NULL) {
	    FREE(line);
	    return 0;
	}

	buffer = build_command(line, dirName, arg);

	if (buffer != 0) {
	    if ((int) strlen(buffer) < LYcolLimit - 14) {
		HTSprintf0(&tmpbuf, gettext("Executing %s "), buffer);
	    } else {
		HTSprintf0(&tmpbuf,
			   gettext("Executing system command. This might take a while."));
	    }
	    _statusline(tmpbuf);
	    stop_curses();
	    printf("%s\r\n", tmpbuf);
	    LYSystem(buffer);
#ifdef VMS
	    HadVMSInterrupt = FALSE;
#endif /* VMS */
	    start_curses();
	    LYforce_no_cache = TRUE;
	}
    }

    FREE(dirName);
    FREE(tmpbuf);
    FREE(buffer);
    FREE(line);
    FREE(tp);
    if (do_pop_doc)
	LYpop(doc);
    return 0;
}

/*
 * Provide a menu of file management options.
 */
int dired_options(DocInfo *doc, char **newfile)
{
    static char tempfile[LY_MAXPATH];
    const char *my_suffix;
    char *path = NULL;
    char *dir;
    lynx_list_item_type *nxt;
    struct stat dir_info;
    FILE *fp0;
    char *dir_url;
    char *path_url;
    BOOLEAN nothing_tagged;
    int count;
    struct dired_menu *mp;
    char buf[2048];

    if ((fp0 = InternalPageFP(tempfile, FALSE)) == 0)
	return (0);

    /*
     * Make the tempfile a URL.
     */
    LYLocalFileToURL(newfile, tempfile);
    LYRegisterUIPage(*newfile, UIP_DIRED_MENU);

    if (doc->link > -1 && doc->link < (nlinks + 1)) {
	path = HTfullURL_toFile(links[doc->link].lname);
	LYTrimPathSep(path);

	if (!ok_lstat(path, &dir_info)) {
	    LYCloseTempFP(fp0);
	    FREE(path);
	    return 0;
	}

    } else {
	StrAllocCopy(path, "");
	memset(&dir_info, 0, sizeof(dir_info));
    }

    dir = HTfullURL_toFile(doc->address);
    LYTrimPathSep(dir);

    nothing_tagged = (BOOL) (HTList_isEmpty(tagged));

    BeginInternalPage(fp0, DIRED_MENU_TITLE, DIRED_MENU_HELP);

    fprintf(fp0, "<em>%s</em> %s<br>\n", gettext("Current directory:"), dir);

    if (nothing_tagged) {
	fprintf(fp0, "<em>%s</em> ", gettext("Current selection:"));
	if (strlen(path)) {
	    fprintf(fp0, "%s<p>\n", path);
	} else {
	    fprintf(fp0, "%s.<p>\n", gettext("Nothing currently selected."));
	}
    } else {
	/*
	 * Write out number of tagged items, and names of first few of them
	 * relative to current (in the DIRED sense) directory.
	 */
	int n = HTList_count(tagged);
	char *cp1 = NULL;
	char *cd = NULL;
	int i, m;

#define NUM_TAGS_TO_WRITE 10
	fprintf(fp0, "<em>%s</em> %d %s",
		gettext("Current selection:"),
		n, ((n == 1)
		    ? gettext("tagged item:")
		    : gettext("tagged items:")));
	StrAllocCopy(cd, doc->address);
	HTUnEscapeSome(cd, "/");
	LYAddHtmlSep(&cd);
	m = (n < NUM_TAGS_TO_WRITE) ? n : NUM_TAGS_TO_WRITE;
	for (i = 1; i <= m; i++) {
	    cp1 = HTRelative((char *) HTList_objectAt(tagged, i - 1),
			     (*cd ? cd : "file://localhost"));
	    HTUnEscape(cp1);
	    LYEntify(&cp1, TRUE);	/* _should_ do this everywhere... */
	    fprintf(fp0, "%s<br>\n&nbsp;&nbsp;&nbsp;%s",
		    (i == 1 ? "" : " ,"), cp1);
	    FREE(cp1);
	}
	if (n > m) {
	    fprintf(fp0, " , ...");
	}
	fprintf(fp0, "<p>\n");
	FREE(cd);
    }

    /*
     * If menu_head is NULL then use defaults and link them together now.
     */
    if (menu_head == NULL) {
	for (mp = defmenu; GetDiredHref(mp) != NULL; mp++)
	    mp->next = (mp + 1);
	(--mp)->next = NULL;
	menu_head = defmenu;
    }

    for (mp = menu_head; mp != NULL; mp = mp->next) {
	if (mp->cond != DE_TAG && !nothing_tagged)
	    continue;
	if (mp->cond == DE_TAG && nothing_tagged)
	    continue;
	if (mp->cond == DE_DIR &&
	    (!*path || !S_ISDIR(dir_info.st_mode)))
	    continue;
	if (mp->cond == DE_FILE &&
	    (!*path || !S_ISREG(dir_info.st_mode)))
	    continue;
#ifdef S_IFLNK
	if (mp->cond == DE_SYMLINK &&
	    (!*path || !S_ISLNK(dir_info.st_mode)))
	    continue;
#endif
	my_suffix = GetDiredSuffix(mp);
	if (non_empty(my_suffix) &&
	    (strlen(path) < strlen(my_suffix) ||
	     strcmp(my_suffix, &path[(strlen(path) - strlen(my_suffix))]) != 0))
	    continue;
	dir_url = HTEscape(dir, URL_PATH);
	path_url = HTEscape(path, URL_PATH);
	fprintf(fp0, "<a href=\"%s",
		render_item(GetDiredHref(mp),
			    path_url, dir_url, buf, sizeof(buf), YES));
	fprintf(fp0, "\">%s</a> ",
		render_item(GetDiredLink(mp),
			    path, dir, buf, sizeof(buf), NO));
	fprintf(fp0, "%s<br>\n",
		render_item(GetDiredRest(mp),
			    path, dir, buf, sizeof(buf), NO));
	FREE(dir_url);
	FREE(path_url);
    }
    FREE(path);

    if (uploaders != NULL) {
	fprintf(fp0, "<p>Upload to current directory:<p>\n");
	for (count = 0, nxt = uploaders;
	     nxt != NULL;
	     nxt = nxt->next, count++) {
	    fprintf(fp0,
		    "<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",
		    count, dir, nxt->name);
	}
    }
    FREE(dir);

    EndInternalPage(fp0);
    LYCloseTempFP(fp0);

    LYforce_no_cache = TRUE;

    return (0);
}

/*
 * Check DIRED filename, return true on success
 */
static int get_filename(const char *prompt,
			bstring *buf)
{
    char *cp;

    _statusline(prompt);

    (void) LYgetBString(&buf, FALSE, 0, NORECALL);
    if (strstr(buf->str, "../") != NULL) {
	HTAlert(gettext("Illegal filename; request ignored."));
	return FALSE;
    } else if (no_dotfiles || !show_dotfiles) {
	cp = LYLastPathSep(buf->str);	/* find last slash */
	if (cp)
	    cp += 1;
	else
	    cp = buf->str;
	if (*cp == '.') {
	    HTAlert(gettext("Illegal filename; request ignored."));
	    return FALSE;
	}
    }
    return !isBEmpty(buf);
}

#ifdef OK_INSTALL

#define LYEXECV_MAX_ARGC 15
/* these are quasi-constant once they have been allocated: */
static char **install_argp = NULL;	/* args for execv install */
static char *install_path = NULL;	/* auxiliary */

#ifdef LY_FIND_LEAKS
static void clear_install_path(void)
{
    FREE(install_argp);
    FREE(install_path);
}
#endif /* LY_FIND_LEAKS */

/*
 * Fill in args array for execv (or execvp etc.) call, after first allocating
 * it if necessary.  No fancy parsing, cmd_args is just split at spaces.  Leave
 * room for reserve additional args to be added by caller.
 *
 * On success *argvp points to new args vector, *pathp is auxiliary.  On
 * success returns index of next argument, else -1.  This is generic enough
 * that it could be used for other calls than install, except the atexit call. 
 * Go through this trouble for install because INSTALL_ARGS may be significant,
 * and someone may configure it with more than one significant flags.  - kw
 */
static int fill_argv_for_execv(char ***argvp,
			       char **pathp,
			       char *cmd_path,
			       const char *cmd_args,
			       int reserve)
{
    int n = 0;

    char **args;
    char *cp;

    if (*argvp == NULL) {
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC + 1);

	if (!*argvp)
	    return (-1);
#ifdef LY_FIND_LEAKS
	atexit(clear_install_path);
#endif
    }
    args = *argvp;
    args[n++] = cmd_path;
    if (cmd_args) {
	StrAllocCopy(*pathp, cmd_args);
	cp = strtok(*pathp, " ");
	if (cp) {
	    while (cp && (n < LYEXECV_MAX_ARGC - reserve)) {
		args[n++] = cp;
		cp = strtok(NULL, " ");
	    }
	    if (cp && (n >= LYEXECV_MAX_ARGC - reserve)) {
		CTRACE((tfp, "Too many args for '%s' in '%s'!\n",
			NONNULL(cmd_path), cmd_args));
		return (-1);
	    }
	} else {
	    args[n++] = *pathp;
	}
    }
    args[n] = (char *) 0;
    return (n);
}

/*
 * Install the specified file or directory.
 */
BOOLEAN local_install(char *destpath,
		      char *srcpath,
		      char **newpath)
{
    char *tmpbuf = NULL;
    static char savepath[DIRED_MAXBUF];		/* This will be the link that

						   is to be installed. */
    struct stat dir_info;
    char **args;
    HTList *tag;
    char *cp = NULL;
    char *tmpdest = NULL;
    int count = 0;
    int n = 0;			/* indices into 'args[]' */
    static int src = -1;
    const char *program;

    if ((program = HTGetProgramPath(ppINSTALL)) == NULL) {
	HTAlert(gettext("Install in the selected directory not permitted."));
	return 0;
    }

    /*
     * Determine the status of the selected item.
     */
    if (srcpath) {
	srcpath = strip_trailing_slash(srcpath);
	if (is_url(srcpath)) {
	    char *local_src = HTfullURL_toFile(srcpath);

	    if (!ok_localname(savepath, local_src)) {
		FREE(local_src);
		return 0;
	    }
	    FREE(local_src);
	} else if (!HTList_isEmpty(tagged) &&
		   srcpath[0] == '\0') {
	    savepath[0] = '\0';	/* will always use tagged list - kw */
	} else if (!ok_localname(savepath, srcpath)) {
	    return 0;
	}
	LYforce_no_cache = TRUE;
	LYLocalFileToURL(newpath, Home_Dir());
	LYAddHtmlSep(newpath);
	StrAllocCat(*newpath, INSTALLDIRS_FILE);
	LYRegisterUIPage(*newpath, UIP_INSTALL);
	return 0;
    }

    /* deal with ~/ or /~/ at the beginning - kw */
    if (LYIsTilde(destpath[0]) &&
	(LYIsPathSep(destpath[1]) || destpath[1] == '\0')) {
	cp = &destpath[1];
    } else if (LYIsPathSep(destpath[0]) && LYIsTilde(destpath[1]) &&
	       (LYIsPathSep(destpath[2]) || destpath[2] == '\0')) {
	cp = &destpath[2];
    }
    if (cp) {
	/* If found, allocate new string, make destpath point to it - kw */
	StrAllocCopy(tmpdest, Home_Dir());
	if (cp[0] && cp[1]) {
	    LYAddPathSep(&tmpdest);
	    StrAllocCat(tmpdest, cp + 1);
	}
	destpath = tmpdest;
    }

    destpath = strip_trailing_slash(destpath);

    if (!ok_stat(destpath, &dir_info)) {
	FREE(tmpdest);
	return 0;
    } else if (!S_ISDIR(dir_info.st_mode)) {
	HTAlert(gettext("The selected item is not a directory!  Request ignored."));
	FREE(tmpdest);
	return 0;
    } else if (0 /*directory not writable */ ) {
	HTAlert(gettext("Install in the selected directory not permitted."));
	FREE(tmpdest);
	return 0;
    }

    statusline(gettext("Just a moment, ..."));

    /* fill in the fixed args, if not already done - kw */
    if (src > 0 && install_argp) {
	n = src;
	n++;
    } else {
	n = fill_argv_for_execv(&install_argp, &install_path,
				"install",
#ifdef INSTALL_ARGS
				INSTALL_ARGS,
#else
				NULL,
#endif /* INSTALL_ARGS */
				2);
	if (n <= 0) {
	    src = 0;
	    HTAlert(gettext("Error building install args"));
	    FREE(tmpdest);
	    return 0;
	}
	src = n++;
    }
    args = install_argp;

    args[n++] = destpath;
    args[n] = (char *) 0;
    tag = tagged;

    if (HTList_isEmpty(tagged)) {
	/* simplistic detection of identical src and dest - kw */
	if (!strcmp(savepath, destpath)) {
	    HTUserMsg2(gettext("Source and target are the same: %s"),
		       savepath);
	    FREE(tmpdest);
	    return (-1);	/* don't do it */
	} else if (!StrNCmp(savepath, destpath, strlen(destpath)) &&
		   LYIsPathSep(savepath[strlen(destpath)]) &&
		   LYLastPathSep(savepath + strlen(destpath) + 1) == 0) {
	    HTUserMsg2(gettext("Already in target directory: %s"),
		       savepath);
	    FREE(tmpdest);
	    return 0;		/* don't do it */
	}
	args[src] = savepath;
	HTSprintf0(&tmpbuf, "install %s in %s", savepath, destpath);
	if (LYExecv(program, args, tmpbuf) <= 0) {
	    FREE(tmpbuf);
	    FREE(tmpdest);
	    return (-1);
	}
	count++;
    } else {
	char *name;

	HTSprintf0(&tmpbuf, "install in %s", destpath);
	while ((name = (char *) HTList_nextObject(tag))) {
	    int err;

	    args[src] = HTfullURL_toFile(name);

	    /* simplistic detection of identical src and dest - kw */
	    if (!strcmp(args[src], destpath)) {
		HTUserMsg2(gettext("Source and target are the same: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    } else if (!StrNCmp(args[src], destpath, strlen(destpath)) &&
		       LYIsPathSep(args[src][strlen(destpath)]) &&
		       LYLastPathSep(args[src] + strlen(destpath) + 1) == 0) {
		HTUserMsg2(gettext("Already in target directory: %s"),
			   args[src]);
		FREE(args[src]);
		continue;	/* skip this source file */
	    }
	    err = (LYExecv(program, args, tmpbuf) <= 0);
	    FREE(args[src]);
	    if (err) {
		FREE(tmpbuf);
		FREE(tmpdest);
		return ((count == 0) ? -1 : count);
	    }
	    count++;
	}
	clear_tags();
    }
    FREE(tmpbuf);
    FREE(tmpdest);
    HTInfoMsg(gettext("Installation complete"));
    return count;
}
#endif /* OK_INSTALL */

/*
 * Clear DIRED tags.
 */
void clear_tags(void)
{
    char *cp = NULL;

    while ((cp = (char *) HTList_removeLastObject(tagged)) != NULL) {
	FREE(cp);
    }
    if (HTList_isEmpty(tagged))
	FREE(tagged);
}

/*
 * Handle DIRED menu item.
 */
void add_menu_item(char *str)
{
    struct dired_menu *tmp, *mp;
    char *cp;
    BOOL used = FALSE;

    /*
     * First custom menu definition causes entire default menu to be discarded.
     */
    if (menu_head == defmenu)
	menu_head = NULL;

    tmp = typecalloc(struct dired_menu);

    if (tmp == NULL)
	outofmem(__FILE__, "add_menu_item");

    assert(tmp != NULL);

    /*
     * Conditional on tagged != NULL ?
     */
    if ((cp = StrChr(str, ':')) != 0) {
	*cp++ = '\0';
	if (strcasecomp(str, "tag") == 0) {
	    tmp->cond = DE_TAG;
	} else if (strcasecomp(str, "dir") == 0) {
	    tmp->cond = DE_DIR;
	} else if (strcasecomp(str, "file") == 0) {
	    tmp->cond = DE_FILE;
#ifdef S_IFLNK
	} else if (strcasecomp(str, "link") == 0) {
	    tmp->cond = DE_SYMLINK;
#endif /* S_IFLNK */
	}

	/*
	 * Conditional on matching suffix.
	 */
	str = cp;
	if ((cp = StrChr(str, ':')) != 0) {
	    *cp++ = '\0';
	    StrAllocCopy(tmp->sfx, str);

	    str = cp;
	    if ((cp = StrChr(str, ':')) != 0) {
		*cp++ = '\0';
		StrAllocCopy(tmp->link, str);

		str = cp;
		if ((cp = StrChr(str, ':')) != 0) {
		    *cp++ = '\0';
		    StrAllocCopy(tmp->rest, str);

		    StrAllocCopy(tmp->href, cp);

		    if (menu_head) {
			for (mp = menu_head;
			     mp && mp->next != NULL;
			     mp = mp->next) {
			    ;
			}
			if (mp != NULL) {
			    mp->next = tmp;
			    used = TRUE;
			}
		    } else {
			menu_head = tmp;
			used = TRUE;
		    }
		}
	    }
	}
    }
    if (!used)
	FREE(tmp);
}

void reset_dired_menu(void)
{
    if (menu_head != defmenu) {
	struct dired_menu *mp, *mp_next = NULL;

	for (mp = menu_head; mp != NULL; mp = mp_next) {
	    FREE(mp->sfx);
	    FREE(mp->link);
	    FREE(mp->rest);
	    FREE(mp->href);
	    mp_next = mp->next;
	    FREE(mp);
	}
	menu_head = NULL;
    }
}

/*
 * Create URL for DIRED HREF value.
 */
static char *render_item(const char *s,
			 const char *path,
			 const char *dir,
			 char *buf,
			 size_t bufsize,
			 int url_syntax)
{
    const char *cp;
    char *bp;
    char overrun = '\0';
    char *taglist = NULL;

#define BP_INC (bp>buf+bufsize-2 ?  &overrun : bp++)
    /* Buffer overrun could happen for very long
       tag list, if %l or %t are used */
    bp = buf;
    while (*s && !overrun) {
	if (*s == '%') {
	    s++;
	    switch (*s) {
	    case '%':
		*BP_INC = '%';
		break;
	    case 'p':
		cp = path;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'd':
		cp = dir;
		if (!LYIsHtmlSep(*cp))
		    *BP_INC = '/';
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'f':
		cp = LYLastPathSep(path);
		if (cp)
		    cp++;
		else
		    cp = path;
		while (*cp)
		    *BP_INC = *cp++;
		break;
	    case 'l':
	    case 't':
		if (!HTList_isEmpty(tagged)) {
		    HTList *cur = tagged;
		    char *name;

		    while (!overrun &&
			   (name = (char *) HTList_nextObject(cur)) != NULL) {
			if (*s == 'l' && (cp = strrchr(name, '/')))
			    cp++;
			else
			    cp = name;
			StrAllocCat(taglist, cp);
			StrAllocCat(taglist, " ");	/* should this be %20? */
		    }
		}
		if (taglist) {
		    /* could HTUnescape here... */
		    cp = taglist;
		    while (*cp)
			*BP_INC = *cp++;
		    FREE(taglist);
		}
		break;
	    default:
		*BP_INC = '%';
		*BP_INC = *s;
		break;
	    }
	} else {
	    /*
	     * Other chars come from the lynx.cfg or the default.  Let's assume
	     * there isn't anything weird there that needs escaping.
	     */
	    *BP_INC = *s;
	}
	s++;
    }
    if (overrun & url_syntax) {
	HTAlert(gettext("Temporary URL or list would be too long."));
	bp = buf;		/* set to start, will return empty string as URL */
    }
    *bp = '\0';
    return buf;
}

#endif /* DIRED_SUPPORT */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYLocal.c,v 1.86 2009/01/01 21:52:45 tom Exp $
d82 2
a83 3
static char *get_filename(const char *prompt,
			  char *buf,
			  size_t bufsize);
d95 2
a96 2
	int		bufsize,
	BOOLEAN		url_syntax);
d105 1
d107 1
d109 1
d111 1
d115 14
d139 2
a140 2
{ 0,		      "", "Change directory",
		      "", "LYNXDIRED://CHDIR",			NULL },
d142 2
a143 2
{ 0,		      "", "New File",
"(in current directory)", "LYNXDIRED://NEW_FILE%d",		NULL },
d145 2
a146 2
{ 0,		      "", "New Directory",
"(in current directory)", "LYNXDIRED://NEW_FOLDER%d",		NULL },
d149 2
a150 2
{ DE_FILE,	      "", "Install",
"selected file to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
d156 2
a157 2
{ DE_DIR,	      "", "Install",
"selected directory to new location", "LYNXDIRED://INSTALL_SRC%p",	NULL },
d160 4
a163 4
{ DE_FILE,	      "", "Modify File Name",
"(of current selection)", "LYNXDIRED://MODIFY_NAME%p",		NULL },
{ DE_DIR,	      "", "Modify Directory Name",
"(of current selection)", "LYNXDIRED://MODIFY_NAME%p",		NULL },
d165 2
a166 2
{ DE_SYMLINK,	      "", "Modify Name",
"(of selected symbolic link)", "LYNXDIRED://MODIFY_NAME%p",	NULL },
d170 4
a173 4
{ DE_FILE,	      "", "Modify File Permissions",
"(of current selection)", "LYNXDIRED://PERMIT_SRC%p",		NULL },
{ DE_DIR,	      "", "Modify Directory Permissions",
"(of current selection)", "LYNXDIRED://PERMIT_SRC%p",		NULL },
d176 4
a179 4
{ DE_FILE,	      "", "Change Location",
"(of selected file)"	, "LYNXDIRED://MODIFY_LOCATION%p",	NULL },
{ DE_DIR,	      "", "Change Location",
"(of selected directory)", "LYNXDIRED://MODIFY_LOCATION%p",	NULL },
d181 2
a182 2
{ DE_SYMLINK,	      "", "Change Location",
"(of selected symbolic link)", "LYNXDIRED://MODIFY_LOCATION%p", NULL },
d185 4
a188 4
{ DE_FILE,	      "", "Remove File",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p",	NULL },
{ DE_DIR,	      "", "Remove Directory",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p",	NULL },
d190 2
a191 2
{ DE_SYMLINK,	      "", "Remove Symbolic Link",
   "(current selection)", "LYNXDIRED://REMOVE_SINGLE%p",	NULL },
d195 2
a196 2
{ DE_FILE,	      "", "UUDecode",
   "(current selection)", "LYNXDIRED://UUDECODE%p",		NULL },
d200 2
a201 2
{ DE_FILE,	EXT_TAR_Z, "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_Z%p",		NULL },
d205 2
a206 2
{ DE_FILE,     ".tar.gz", "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_GZ%p",		NULL },
d208 2
a209 2
{ DE_FILE,	  ".tgz", "Expand",
   "(current selection)", "LYNXDIRED://UNTAR_GZ%p",		NULL },
d213 2
a214 2
{ DE_FILE,	   EXT_Z, "Uncompress",
   "(current selection)", "LYNXDIRED://DECOMPRESS%p",		NULL },
d218 2
a219 2
{ DE_FILE,	   ".gz", "Uncompress",
   "(current selection)", "LYNXDIRED://UNGZIP%p",		NULL },
d223 2
a224 2
{ DE_FILE,	  ".zip", "Uncompress",
   "(current selection)", "LYNXDIRED://UNZIP%p",		NULL },
d228 2
a229 2
{ DE_FILE,	  ".tar", "UnTar",
   "(current selection)", "LYNXDIRED://UNTAR%p",		NULL },
d233 2
a234 2
{ DE_DIR,	      "", "Tar",
   "(current selection)", "LYNXDIRED://TAR%p",			NULL },
d238 2
a239 2
{ DE_DIR,	      "", "Tar and compress",
      "(using GNU gzip)", "LYNXDIRED://TAR_GZ%p",		NULL },
d243 2
a244 2
{ DE_DIR,	      "", "Tar and compress",
      "(using compress)", "LYNXDIRED://TAR_Z%p",		NULL },
d248 2
a249 2
{ DE_DIR,	      "", "Package and compress",
	   "(using zip)", "LYNXDIRED://ZIP%p",			NULL },
d252 2
a253 2
{ DE_FILE,	      "", "Compress",
 "(using Unix compress)", "LYNXDIRED://COMPRESS%p",		NULL },
d256 2
a257 2
{ DE_FILE,	      "", "Compress",
	  "(using gzip)", "LYNXDIRED://GZIP%p",			NULL },
d261 2
a262 2
{ DE_FILE,	      "", "Compress",
	   "(using zip)", "LYNXDIRED://ZIP%p",			NULL },
d265 2
a266 2
{ DE_TAG,	      "", "Move all tagged items to another location.",
		      "", "LYNXDIRED://MOVE_TAGGED%d",		NULL },
d269 2
a270 2
{ DE_TAG,	      "", "Install tagged files into another directory.",
		      "", "LYNXDIRED://INSTALL_SRC%00",		NULL },
d273 2
a274 2
{ DE_TAG,	      "", "Remove all tagged files and directories.",
		      "", "LYNXDIRED://REMOVE_TAGGED",		NULL },
d276 2
a277 2
{ DE_TAG,	      "", "Untag all tagged files and directories.",
		      "", "LYNXDIRED://CLEAR_TAGGED",		NULL },
d279 2
a280 2
{ 0,		    NULL, NULL,
		    NULL, NULL,					NULL }
d282 1
d299 2
d303 26
a328 1
	return cannot_stat(name);
d330 5
a334 1
    return TRUE;
d378 33
d420 1
a420 1
#if defined(VMS) || defined(_WINDOWS)
d426 1
a426 1
#ifdef __DJGPP__
d510 1
d520 1
a520 1
	char *args[5];
d524 3
a526 3
	args[0] = "mkdir";
	args[1] = path;
	args[2] = (char *) 0;
d529 1
d536 1
d547 1
a547 1
	char *args[5];
d550 4
a553 4
	args[0] = "rm";
	args[1] = "-f";
	args[2] = path;
	args[3] = (char *) 0;
d557 1
d560 1
d571 1
a571 1
	char *args[5];
d574 3
a576 3
	args[0] = "rmdir";
	args[1] = path;
	args[2] = (char *) 0;
d580 1
d583 1
d594 1
a594 1
	char *args[5];
d598 3
a600 3
	args[0] = "touch";
	args[1] = path;
	args[2] = (char *) 0;
d603 1
d607 1
a607 1
	if ((fp = fopen(path, "w")) != 0) {
d613 1
d625 1
a625 1
	char *args[5];
d628 4
a631 4
	args[0] = "mv";
	args[1] = source;
	args[2] = target;
	args[3] = (char *) 0;
d634 1
d646 5
a650 2
	if ((code = rename(source, target)) != 0)
	    if ((code = LYCopyFile(source, target)) >= 0)
d652 3
d684 2
a685 1
static BOOLEAN dir_has_same_owner(struct stat *info, int owner)
d687 2
a688 2
    if (S_ISDIR(info->st_mode)) {
	if ((int) info->st_uid == owner) {
d700 18
d769 15
d785 4
a788 5
 * Move all tagged files and directories to a new location.  Input is current
 * directory.  The tests in this function can, at best, prevent some user
 * mistakes - anybody who relies on them for security is seriously misguided. 
 * If a user has enough permissions to move a file somewhere, the same uid with
 * Lynx & dired can do the same thing.
d793 6
a798 7
    dev_t dev;
    ino_t inode;
    int owner;
    char tmpbuf[MAX_LINE];
    char *savepath;
    char *srcpath = NULL;
    struct stat dir_info;
d802 2
d809 3
a811 59
    tmpbuf[0] = '\0';
    LYgetstr(tmpbuf, VISIBLE, sizeof(tmpbuf), NORECALL);
    if (strlen(tmpbuf)) {
	/*
	 * Determine the ownership of the current location.
	 */
	/*
	 * This test used to always fail from the dired menu...  changed to
	 * something that hopefully makes more sense - KW
	 */
	if (non_empty(testpath) && 0 != strcmp(testpath, "/")) {
	    /*
	     * testpath passed in and is not empty and not a single "/" (which
	     * would probably be bogus) - use it.
	     */
	    cp = testpath;
	} else {
	    /*
	     * Prepare to get directory path from one of the tagged files.
	     */
	    cp = (char *) HTList_lastObject(tagged);
	    testpath = NULL;	/* Won't be needed any more in this function,
				   set to NULL as a flag. */
	}

	if (testpath == NULL) {
	    /*
	     * Get the directory containing the file or subdir.
	     */
	    if (cp) {
		cp = strip_trailing_slash(cp);
		cp = HTParse(".", cp, PARSE_PATH + PARSE_PUNCTUATION);
		savepath = HTURLPath_toFile(cp, TRUE, FALSE);
		FREE(cp);
	    } else {		/* Last resort, should never happen. */
		savepath = HTURLPath_toFile(".", TRUE, FALSE);
	    }
	} else {
	    if (!strncmp(cp, "file://localhost", 16)) {
		cp += 16;
	    } else if (isFILE_URL(cp)) {
		cp += LEN_FILE_URL;
	    }
	    savepath = HTURLPath_toFile(cp, TRUE, FALSE);
	}

	if (!ok_stat(savepath, &dir_info)) {
	    FREE(savepath);
	    return 0;
	}

	/*
	 * Save the owner of the current location for later use.  Also save the
	 * device and inode for location checking/
	 */
	dev = dir_info.st_dev;
	inode = dir_info.st_ino;
	owner = (int) dir_info.st_uid;

d815 1
a815 1
	if (LYIsTilde(tmpbuf[0]) && LYIsPathSep(tmpbuf[1])) {
d819 2
a820 8
	    StrAllocCat(cp1, (tmpbuf + 1));
	    if (strlen(cp1) > (sizeof(tmpbuf) - 1)) {
		HTAlert(gettext("Path too long"));
		FREE(savepath);
		FREE(cp1);
		return 0;
	    }
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf) - 1);
d827 4
a830 3
	if (!LYIsPathSep(tmpbuf[0])) {
	    LYAddPathSep(&savepath);
	    StrAllocCat(savepath, tmpbuf);
d832 1
a832 1
	    StrAllocCopy(savepath, tmpbuf);
d835 3
a837 5
	/*
	 * stat() the target location to determine type and ownership.
	 */
	if (!ok_stat(savepath, &dir_info)) {
	    FREE(savepath);
d842 2
a843 1
	 * Make sure the source and target locations are not the same place.
d845 14
a858 4
	if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
	    HTAlert(gettext("Source and destination are the same location - request ignored!"));
	    FREE(savepath);
	    return 0;
d862 1
a862 2
	 * Make sure the target location is a directory which is owned by the
	 * same uid as the owner of the current location.
d864 2
a865 3
	if (dir_has_same_owner(&dir_info, owner)) {
	    count = 0;
	    tag = tagged;
d867 4
a870 13
	    /*
	     * Move all tagged items to the target location.
	     */
	    while ((cp = (char *) HTList_nextObject(tag)) != NULL) {
		srcpath = HTfullURL_toFile(cp);

		if (move_file(srcpath, savepath) < 0) {
		    if (count == 0)
			count = -1;
		    break;
		}
		FREE(srcpath);
		++count;
d872 2
a873 2
	    clear_tags();
	    FREE(srcpath);
d875 3
a877 2
	FREE(savepath);
	return count;
d879 2
a880 1
    return 0;
d889 1
a889 1
    char tmpbuf[DIRED_MAXBUF];
d900 1
a910 3
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf) - 1);
	if (get_filename(cp, tmpbuf, sizeof(tmpbuf)) == NULL)
	    return 0;
d912 2
a913 11
	/*
	 * Do not allow the user to also change the location at this time.
	 */
	if (LYLastPathSep(tmpbuf) != 0) {
	    HTAlert(gettext("Illegal character (path-separator) found! Request ignored."));
	} else if (strlen(tmpbuf)) {
	    if ((cp = LYLastPathSep(testpath)) != NULL)
		HTSprintf0(&newpath, "%.*s%s",
			   (int) (cp - testpath + 1), testpath, tmpbuf);
	    else
		StrAllocCopy(newpath, tmpbuf);
d916 1
a916 1
	     * Make sure the destination does not already exist.
d918 18
a935 2
	    if (not_already_exists(newpath)) {
		code = move_file(testpath, newpath);
a936 2
	    FREE(newpath);

d939 1
d950 1
a950 4
    dev_t dev;
    ino_t inode;
    int owner;
    char tmpbuf[MAX_LINE];
d953 1
d969 1
a969 6
	if (HTGetProgramPath(ppMV) != NULL) {
	    cp = gettext("Enter new location for directory: ");
	} else {
	    HTAlert(COULD_NOT_ACCESS_DIR);
	    return 0;
	}
d975 41
a1015 24
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf) - 1);
    *LYPathLeaf(tmpbuf) = '\0';
    if (get_filename(cp, tmpbuf, sizeof(tmpbuf)) == NULL)
	return 0;
    if (strlen(tmpbuf)) {
	StrAllocCopy(savepath, testpath);
	StrAllocCopy(newpath, testpath);

	/*
	 * Allow ~/ references to the home directory.
	 */
	if (LYIsTilde(tmpbuf[0])
	    && (tmpbuf[1] == '\0' || LYIsPathSep(tmpbuf[1]))) {
	    StrAllocCopy(newpath, Home_Dir());
	    StrAllocCat(newpath, (tmpbuf + 1));
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf) - 1);
	}
	if (LYisAbsPath(tmpbuf)) {
	    StrAllocCopy(newpath, tmpbuf);
	} else if ((sp = LYLastPathSep(newpath)) != NULL) {
	    *++sp = '\0';
	    StrAllocCat(newpath, tmpbuf);
	} else {
	    HTAlert(gettext("Unexpected failure - unable to find trailing path separator"));
a1017 23
	    return 0;
	}

	/*
	 * Make sure the source and target have the same owner (uid).
	 */
	dev = dir_info.st_dev;
	inode = dir_info.st_ino;
	owner = (int) dir_info.st_uid;
	if (!ok_stat(newpath, &dir_info)) {
	    code = 0;
	}
#ifdef UNIX
	/*
	 * Make sure the source and target are not the same location.
	 */
	else if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
	    HTAlert(gettext("Source and destination are the same location!  Request ignored!"));
	    code = 0;
	}
#endif
	else if (dir_has_same_owner(&dir_info, owner)) {
	    code = move_file(savepath, newpath);
a1018 2
	FREE(newpath);
	FREE(savepath);
d1020 1
d1031 1
a1031 1
    char testpath[DIRED_MAXBUF];	/* a bit ridiculous */
d1033 1
d1043 3
a1045 2
	doc->link = (doc->link < 0) ?
	    0 : doc->link;
d1066 1
a1066 1
    if (strchr("NLP", ans) != NULL) {
d1072 1
a1072 1
	LYstrncpy(testpath, cp, sizeof(testpath) - 1);
d1076 1
a1076 1
	    return (modify_name(testpath));
d1078 1
a1078 1
	    if (modify_location(testpath)) {
d1081 1
a1081 1
		return 1;
d1085 1
a1085 1
	    return (permit_location(NULL, testpath, newpath));
d1094 2
a1095 1
    return 0;
d1108 1
a1108 1
    char tmpbuf[DIRED_MAXBUF];
d1111 2
a1112 3
    tmpbuf[0] = '\0';
    if (get_filename(gettext("Enter name of file to create: "),
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d1114 1
a1114 1
	if (strstr(tmpbuf, "//") != NULL) {
d1116 2
a1117 1
	} else if (strlen(tmpbuf) && strchr(BadChars(), tmpbuf[0]) == NULL) {
d1124 1
a1124 1
	    StrAllocCat(testpath, tmpbuf);
d1135 1
d1145 1
a1145 1
    char tmpbuf[DIRED_MAXBUF];
d1148 2
a1149 3
    tmpbuf[0] = '\0';
    if (get_filename(gettext("Enter name for new directory: "),
		     tmpbuf, sizeof(tmpbuf)) != NULL) {
d1151 1
a1151 1
	if (strstr(tmpbuf, "//") != NULL) {
d1153 2
a1154 1
	} else if (strlen(tmpbuf) && strchr(BadChars(), tmpbuf[0]) == NULL) {
d1158 1
a1158 1
	    StrAllocCat(testpath, tmpbuf);
d1169 1
d1280 3
a1282 2
	doc->link = (doc->link < 0) ?
	    0 : doc->link;
d1311 1
a1311 1
static char LYValidPermitFile[LY_MAXPATH] = "\0";
d1344 2
a1347 1
    return (0);
d1370 1
a1370 1
	    return 0;
d1374 1
a1374 1
	LYRemoveTemp(tempfile);
d1377 1
a1377 1
	    return (0);
d1387 1
a1387 3
	LYstrncpy(LYValidPermitFile,
		  srcpath,
		  (sizeof(LYValidPermitFile) - 1));
d1462 1
a1462 1
	return (PERMIT_FORM_RESULT);	/* Special flag for LYMainLoop */
d1471 1
a1471 1
	if (LYValidPermitFile[0] == '\0') {
d1479 1
a1479 1
	    return 0;
d1486 1
a1486 1
	    return (0);		/* Nothing to permit. */
d1493 1
a1493 1
	    return (0);
d1496 1
a1496 1
	    return (0);
d1506 1
a1506 1
	if (strcmp(destpath, LYValidPermitFile)) {
d1513 1
a1513 1
	    return 0;
d1522 1
a1522 1
	    return 0;
d1537 1
a1537 1
	    if (strncmp(cp, "mode=", 5) == 0) {		/* Magic string. */
d1546 4
a1549 3
			|| strchr(cp + 5, 'X') == NULL
			|| S_ISDIR(dir_info.st_mode))
			new_mode |= mask;
d1552 1
a1552 1
		    return 0;
d1556 1
a1556 1
		return 0;
d1565 1
d1567 1
a1567 1
	    char *args[5];
d1571 6
a1576 6
	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int) new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int) new_mode);
	    args[0] = "chmod";
	    args[1] = amode;
	    args[2] = destpath;
	    args[3] = (char *) 0;
d1578 1
a1578 2
		FREE(tmpbuf);
		return (-1);
d1581 1
d1583 5
a1587 2
	    if (chmod(destpath, new_mode) < 0)
		return (-1);
d1589 2
a1590 2
	LYforce_no_cache = TRUE;	/* Force update of dired listing. */
	return 1;
d1593 1
d1606 1
a1606 1
	if (flag == ON) {
d1639 1
a1639 1
		tagflag(ON, i);
d1677 1
a1677 1
	LYstrncpy(line1, line, sizeof(line1) - 1);
d1699 1
a1699 1
    int len = (int) strlen(prefix);
d1701 2
a1702 2
    if (!strncmp("LYNXDIRED://", data, 12)
	&& !strncmp(prefix, data + 12, (unsigned) len)) {
d1766 1
a1766 1
#  endif			/* OK_GZIP */
d1791 1
a1791 1
# endif				/* !ARCHIVE_ONLY */
d1810 1
a1810 1
# endif				/* OK_GZIP */
d1892 1
a1892 1
# endif				/* !ARCHIVE_ONLY */
d1938 1
a1938 1
    if ((arg = match_op("CHDIR", line)) != 0) {
d1943 1
a1943 1
	arg = "blah";		/* do something to avoid cc's complaints */
d1990 1
a1990 1
    } else if ((arg = match_op("REMOVE_TAGGED", line)) != 0) {
d1993 1
a1993 1
    } else if ((arg = match_op("CLEAR_TAGGED", line)) != 0) {
d2047 2
a2048 1
    char *path;
d2081 1
d2140 1
a2140 1
	for (mp = defmenu; mp->href != NULL; mp++)
d2162 4
a2165 3
	if (*mp->sfx &&
	    (strlen(path) < strlen(mp->sfx) ||
	     strcmp(mp->sfx, &path[(strlen(path) - strlen(mp->sfx))]) != 0))
d2170 2
a2171 1
		render_item(mp->href, path_url, dir_url, buf, sizeof(buf), YES));
d2173 2
a2174 1
		render_item(mp->link, path, dir, buf, sizeof(buf), NO));
d2176 2
a2177 1
		render_item(mp->rest, path, dir, buf, sizeof(buf), NO));
d2204 1
a2204 1
 * Check DIRED filename.
d2206 2
a2207 3
static char *get_filename(const char *prompt,
			  char *buf,
			  size_t bufsize)
d2213 2
a2214 2
    LYgetstr(buf, VISIBLE, bufsize, NORECALL);
    if (strstr(buf, "../") != NULL) {
d2216 3
a2218 5
	return NULL;
    }

    if (no_dotfiles || !show_dotfiles) {
	cp = LYLastPathSep(buf);	/* find last slash */
d2222 1
a2222 1
	    cp = buf;
d2225 1
a2225 1
	    return NULL;
d2228 1
a2228 1
    return buf;
d2422 1
a2422 1
	} else if (!strncmp(savepath, destpath, strlen(destpath)) &&
d2453 1
a2453 1
	    } else if (!strncmp(args[src], destpath, strlen(destpath)) &&
d2500 1
d2513 2
d2518 8
a2525 8
    cp = strchr(str, ':');
    *cp++ = '\0';
    if (strcasecomp(str, "tag") == 0) {
	tmp->cond = DE_TAG;
    } else if (strcasecomp(str, "dir") == 0) {
	tmp->cond = DE_DIR;
    } else if (strcasecomp(str, "file") == 0) {
	tmp->cond = DE_FILE;
d2527 2
a2528 2
    } else if (strcasecomp(str, "link") == 0) {
	tmp->cond = DE_SYMLINK;
d2530 39
d2570 2
a2571 26

    /*
     * Conditional on matching suffix.
     */
    str = cp;
    cp = strchr(str, ':');
    *cp++ = '\0';
    StrAllocCopy(tmp->sfx, str);

    str = cp;
    cp = strchr(str, ':');
    *cp++ = '\0';
    StrAllocCopy(tmp->link, str);

    str = cp;
    cp = strchr(str, ':');
    *cp++ = '\0';
    StrAllocCopy(tmp->rest, str);

    StrAllocCopy(tmp->href, cp);

    if (menu_head) {
	for (mp = menu_head; mp && mp->next != NULL; mp = mp->next) ;
	mp->next = tmp;
    } else
	menu_head = tmp;
d2584 1
a2584 1
	    mp_next = mp_next;
d2598 2
a2599 2
			 int bufsize,
			 BOOLEAN url_syntax)
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d665 1
a665 1
    char tmpbuf[1024];
d734 1
a734 1
	owner = dir_info.st_uid;
d739 1
a739 1
	if (!strncmp(tmpbuf, "~/", 2)) {
d878 1
a878 1
    char tmpbuf[1024];
d918 2
a919 2
	if (!strncmp(tmpbuf, "~/", 2)
	    || !strcmp(tmpbuf, "~")) {
d941 1
a941 1
	owner = dir_info.st_uid;
d1034 4
a1045 1
    const char *bad_chars = ".~/";
a1050 4
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}

d1053 1
a1053 1
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
a1081 1
    const char *bad_chars = ".~/";
a1086 4
	if (!no_dotfiles && show_dotfiles) {
	    bad_chars = "~/";
	}

d1089 1
a1089 1
	} else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
d1230 1
a1230 1
	if ((i = strlen(testpath)) && testpath[i - 1] == '/')
d1318 1
a1318 1
	group_name = HTAA_GidToName(dir_info.st_gid);
d1627 1
a1627 1
    int len = strlen(prefix);
d1647 1
a1647 1
			   char *dirname,
d1683 2
a1684 2
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirname);
d1698 2
a1699 2
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirname);
d1711 2
a1712 2
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR, 1, dirname);
d1725 2
a1726 2
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_GZ, 1, dirname);
d1743 2
a1744 2
		dirname = DirectoryOf(arg);
		HTAddParam(&buffer, FMT_TAR_Z, 1, dirname);
d1759 2
a1760 2
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_TAR, 1, dirname);
d1799 2
a1800 2
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_ZIP, 1, dirname);
d1812 2
a1813 2
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNZIP, 1, dirname);
d1853 1
a1853 1
    char *dirname = NULL;
d1938 1
a1938 1
	buffer = build_command(line, dirname, arg);
d1959 1
a1959 1
    FREE(dirname);
d2279 2
a2280 2
    if (destpath[0] == '~' &&
	(destpath[1] == '/' || destpath[1] == '\0')) {
d2282 2
a2283 2
    } else if (destpath[0] == '/' && destpath[1] == '~' &&
	       (destpath[2] == '/' || destpath[2] == '\0')) {
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 28
a29 28
**  Routines to manipulate the local filesystem.
**  Written by: Rick Mallett, Carleton University
**  Report problems to rmallett@@ccs.carleton.ca
**  Modified 18-Dec-95 David Trueman (david@@cs.dal.ca):
**	Added OK_PERMIT compilation option.
**	Support replacement of compiled-in f)ull menu configuration via
**	  DIRED_MENU definitions in lynx.cfg, so that more than one menu
**	  can be driven by the same executable.
**  Modified Oct-96 Klaus Weide (kweide@@tezcat.com):
**	Changed to use the library's HTList_* functions and macros for
**	  managing the list of tagged file URLs.
**	Keep track of proper level of URL escaping, so that unusual filenames
**	  which contain #% etc. are handled properly (some HTUnEscapeSome()'s
**	  left in to be conservative, and to document where superfluous
**	  unescaping took place before).
**	Dynamic memory instead of fixed length buffers in a few cases.
**	Other minor changes to make things work as intended.
**  Modified Jun-97 Klaus Weide (kweide@@tezcat.com) & FM:
**	Modified the code handling DIRED_MENU to do more careful
**	  checking of the selected file.  In addition to "TAG", "FILE", and
**	  "DIR", DIRED_MENU definitions in lynx.cfg now also recognize LINK as
**	  a type.  DIRED_MENU definitions with a type field of "LINK" are only
**	  used if the current selection is a symbolic link ("FILE" and "DIR"
**	  definitions are not used in that case).  The default menu
**	  definitions have been updated to reflect this change, and to avoid
**	  the showing of menu items whose action would always fail - KW
**	Cast all code into the Lynx programming style. - FM
*/
d80 3
a82 4
PRIVATE char *get_filename PARAMS((
	char *		prompt,
	char *		buf,
	size_t		bufsize));
d85 3
a87 4
PRIVATE int permit_location PARAMS((
	char *		destpath,
	char *		srcpath,
	char **		newpath));
d89 4
a92 5

PRIVATE char *render_item PARAMS((
	CONST char *	s,
	CONST char *	path,
	CONST char *	dir,
d95 1
a95 1
	BOOLEAN		url_syntax));
a96 1
PRIVATE struct dired_menu *menu_head = NULL;
d108 4
a111 1
} defmenu[] = {
d114 4
a117 4
 *  The following initializations determine the contents of the f)ull menu
 *  selection when in dired mode.  If any menu entries are defined in the
 *  configuration file via DIRED_MENU lines, then these default entries
 *  are discarded entirely.
d263 1
d265 1
a265 1
PRIVATE BOOLEAN cannot_stat ARGS1(CONST char *, name)
d268 1
d277 1
a277 1
PRIVATE BOOLEAN ok_stat ARGS2(CONST char *, name, struct stat*, sb)
d287 1
a287 1
PRIVATE BOOLEAN ok_lstat ARGS2(char *, name, struct stat*, sb)
d299 1
a299 1
PRIVATE BOOLEAN ok_file_or_dir ARGS1(struct stat*, sb)
d302 1
a302 1
     && !S_ISREG(sb->st_mode)) {
d310 1
a310 1
PRIVATE BOOLEAN ok_localname ARGS2(char*, dst, CONST char*, src)
d315 1
a315 1
     || !ok_file_or_dir(&dir_info)) {
d328 1
a328 1
 *  Execute DIRED command, return -1 or 0 on failure, 1 success.
d330 3
a332 4
PRIVATE int LYExecv ARGS3(
	CONST char *,	path,
	char **,	argv,
	char *,		msg)
d335 1
d341 1
d351 1
d354 1
d365 1
a365 1
    rc = 1;		/* It will work */
d367 1
a367 1
    pid = fork();	/* fork and execute command */
d370 4
a373 4
	case -1:
	    HTSprintf0(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	    rc = 0;
	    break;	/* don't fall thru! - KW */
d375 1
a375 1
	case 0:  /* child */
d377 1
a377 1
	    execvp(path, argv);	/* this uses our $PATH */
d379 1
a379 1
	    execv(path, argv);
d381 2
a382 2
	    exit(EXIT_FAILURE);	/* execv failed, give wait() something to look at */
	    /*NOTREACHED*/
d384 1
a384 1
	default:  /* parent */
d386 1
a386 2
	    while (wait(&wstatus) != pid)
		; /* do nothing */
d388 1
a388 1
	    while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
d390 2
a391 2
		if (errno == EINTR)
		    continue;
d394 2
a395 2
		if (errno == ERESTARTSYS)
		    continue;
d397 2
a398 2
		break;
	    }
d400 9
a408 8
	    if ((WIFEXITED(wstatus)
	      && (WEXITSTATUS(wstatus) != 0))
	     || (WIFSIGNALED(wstatus)
	      && (WTERMSIG(wstatus) > 0)))	{ /* error return */
		HTSprintf0(&tmpbuf, gettext("Probable failure to %s due to system error!"),
				   msg);
		rc = 0;
	    }
d414 2
a415 2
	 *  Screen may have message from the failed execv'd command.
	 *  Give user time to look at it before screen refresh.
a424 1

d426 1
a426 1
    return(rc);
d429 1
a429 1
PRIVATE int make_directory ARGS1(char *, path)
d432 1
a432 1
    CONST char *program;
d438 1
a438 1
	HTSprintf0(&msg,"make directory %s", path);
d454 1
a454 1
PRIVATE int remove_file ARGS1(char *, path)
d457 1
a457 1
    CONST char *program;
d476 1
a476 1
PRIVATE int remove_directory ARGS1(char *, path)
d479 1
a479 1
    CONST char *program;
d497 1
a497 1
PRIVATE int touch_file ARGS1(char *, path)
d500 1
a500 1
    CONST char *program;
d514 1
d525 1
a525 1
PRIVATE int move_file ARGS2(char *, source, char *, target)
d528 1
a528 1
    CONST char *program;
d544 1
d547 1
a547 1
	 && S_ISDIR(sb.st_mode)) {
d564 1
a564 1
PRIVATE BOOLEAN not_already_exists ARGS1(char *, name)
d584 1
a584 1
PRIVATE BOOLEAN dir_has_same_owner ARGS2(struct stat *, info, int, owner)
d599 1
a599 1
 *  Remove all tagged files and directories.
d601 1
a601 1
PRIVATE int remove_tagged NOARGS
d612 1
a612 1
    if (HTList_isEmpty(tagged))  /* should never happen */
d619 2
a620 2
    while (ans == YES && (cp = (char *)HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) { /* unnecessary check */
d626 1
a626 1
	     *	Check the current status of the path to be deleted.
d633 2
a634 1
		    if (count == 0) count = -1;
d651 5
a655 6
 *  Move all tagged files and directories to a new location.
 *  Input is current directory.
 *  The tests in this function can, at best, prevent some user mistakes -
 *   anybody who relies on them for security is seriously misguided.
 *  If a user has enough permissions to move a file somewhere, the same
 *   uid with Lynx & dired can do the same thing.
d657 1
a657 2
PRIVATE int modify_tagged ARGS1(
	char *,		testpath)
d670 1
a670 1
    if (HTList_isEmpty(tagged))  /* should never happen */
a677 3
    /*
     *	Determine the ownership of the current location.
     */
d679 5
a683 2
	 *  This test used to always fail from the dired menu...
	 *  changed to something that hopefully makes more sense - KW
d685 1
a685 1
	if (testpath && *testpath && 0!=strcmp(testpath,"/")) {
d687 2
a688 2
	     *	testpath passed in and is not empty and not a single "/"
	     *	(which would probably be bogus) - use it.
d693 1
a693 1
	     *	Prepare to get directory path from one of the tagged files.
d695 1
a695 1
	    cp = HTList_lastObject(tagged);
d702 1
a702 1
	     *	Get the directory containing the file or subdir.
d706 1
a706 1
		cp = HTParse(".", cp, PARSE_PATH+PARSE_PUNCTUATION);
d709 1
a709 1
	    } else {	/* Last resort, should never happen. */
d727 2
a728 2
	 *  Save the owner of the current location for later use.
	 *  Also save the device and inode for location checking/
d735 1
a735 1
	 *  Replace ~/ references to the home directory.
d739 1
d748 1
a748 1
	    LYstrncpy(tmpbuf, cp1, sizeof(tmpbuf)-1);
d753 1
a753 1
	 *  If path is relative, prefix it with current location.
d757 1
a757 1
	    StrAllocCat(savepath,tmpbuf);
d759 1
a759 1
	    StrAllocCopy(savepath,tmpbuf);
d763 1
a763 1
	 *  stat() the target location to determine type and ownership.
d771 1
a771 1
	 *  Make sure the source and target locations are not the same place.
d780 2
a781 2
	 *  Make sure the target location is a directory which is owned
	 *  by the same uid as the owner of the current location.
d788 1
a788 1
	     *  Move all tagged items to the target location.
d790 1
a790 1
	    while ((cp = (char *)HTList_nextObject(tag)) != NULL) {
d811 1
a811 1
 *  Modify the name of the specified item.
d813 1
a813 2
PRIVATE int modify_name ARGS1(
	char *,		testpath)
d815 1
a815 1
    char *cp;
d822 1
a822 1
     *	Determine the status of the selected item.
d828 1
a828 1
	 *  Change the name of the file or directory.
d831 1
a831 1
	     cp = gettext("Enter new name for directory: ");
d833 1
a833 1
	     cp = gettext("Enter new name for file: ");
d835 1
a835 1
	     return ok_file_or_dir(&dir_info);
d837 1
a837 1
	LYstrncpy(tmpbuf, LYPathLeaf(testpath), sizeof(tmpbuf)-1);
d842 1
a842 1
	 *  Do not allow the user to also change the location at this time.
d848 2
a849 1
		HTSprintf0(&newpath, "%.*s%s", (cp - testpath + 1), testpath, tmpbuf);
d854 1
a854 1
	     *	Make sure the destination does not already exist.
d867 1
a867 1
 *  Change the location of a file or directory.
d869 1
a869 2
PRIVATE int modify_location ARGS1(
	char *,		testpath)
d871 2
a872 1
    char *cp;
d883 1
a883 1
     *	Determine the status of the selected item.
d891 1
a891 1
     *	Change the location of the file or directory.
d905 1
a905 1
    LYstrncpy(tmpbuf, testpath, sizeof(tmpbuf)-1);
d914 1
a914 1
	 *  Allow ~/ references to the home directory.
d917 1
a917 1
	 || !strcmp(tmpbuf,"~")) {
d920 1
a920 1
	    LYstrncpy(tmpbuf, newpath, sizeof(tmpbuf)-1);
d924 2
a925 2
	} else if ((cp = LYLastPathSep(newpath)) != NULL) {
	    *++cp = '\0';
d935 1
a935 1
	 *  Make sure the source and target have the same owner (uid).
d945 1
a945 1
	 *  Make sure the source and target are not the same location.
d953 1
a953 1
	    code = move_file(savepath,newpath);
d962 1
a962 1
 *  Modify name or location of a file or directory on localhost.
d964 1
a964 3
PUBLIC int local_modify ARGS2(
	DocInfo *,	doc,
	char **,	newpath)
d968 1
a968 1
    char testpath[DIRED_MAXBUF]; /* a bit ridiculous */
d977 2
a978 2
	if (doc->link > (nlinks-count - 1))
	    doc->link = (nlinks-count - 1);
d980 1
a980 1
				  0 : doc->link;
d985 1
a985 1
	 *  Added protection.
d991 2
a992 2
     *	Do not allow simultaneous change of name and location as in Unix.
     *	This reduces functionality but reduces difficulty for the novice.
d1007 1
a1007 1
	LYstrncpy(testpath, cp, sizeof(testpath)-1);
d1011 1
a1011 1
	    return(modify_name(testpath));
d1014 1
a1014 1
		if (doc->link == (nlinks-1))
d1020 1
a1020 1
	    return(permit_location(NULL, testpath, newpath));
d1024 1
a1024 1
	     *	Code for changing ownership needed here.
d1033 1
a1033 1
 *  Create a new empty file in the current directory.
d1035 1
a1035 2
PRIVATE int create_file ARGS1(
	char *,		current_location)
d1040 1
a1040 1
    char *bad_chars = ".~/";
d1057 1
a1057 1
	     *  Append the target filename to the current location.
d1062 1
a1062 1
	     *  Make sure the target does not already exist
d1074 1
a1074 1
 *  Create a new directory in the current directory.
d1076 1
a1076 2
PRIVATE int create_directory ARGS1(
	char *,		current_location)
d1081 1
a1081 1
    char *bad_chars = ".~/";
d1100 1
a1100 1
	     *  Make sure the target does not already exist.
d1112 1
a1112 1
 *  Create a file or a directory at the current location.
d1114 1
a1114 2
PUBLIC int local_create ARGS1(
	DocInfo *,	doc)
d1125 1
a1125 1
    strcpy(testpath,cp);
d1132 1
a1132 1
	return(create_file(testpath));
d1134 1
a1134 1
	return(create_directory(testpath));
d1141 1
a1141 1
 *  Remove a single file or directory.
d1143 1
a1143 2
PRIVATE int remove_single ARGS1(
	char *,		testpath)
d1156 1
a1156 1
     *	Locate the filename portion of the path.
d1164 4
a1167 2
	/*** This strlen stuff will probably screw up intl translations /jes ***/
	/*** Course, it's probably broken for screen sizes other 80, too     ***/
d1198 2
a1199 2
	     ? remove_directory(testpath)
	     : remove_file(testpath);
d1206 1
a1206 1
 *  Remove a file or a directory.
d1208 1
a1208 2
PUBLIC int local_remove ARGS1(
	DocInfo *,	doc)
d1216 2
a1217 2
	if (doc->link > (nlinks-count - 1))
	    doc->link = (nlinks-count - 1);
d1219 1
a1219 1
				  0 : doc->link;
d1248 1
a1248 1
PRIVATE char LYValidPermitFile[LY_MAXPATH] = "\0";
d1250 1
a1250 1
PRIVATE long permit_bits ARGS1(char *, string_mode)
d1252 18
a1269 9
    if (!strcmp(string_mode, "IRUSR")) return S_IRUSR;
    if (!strcmp(string_mode, "IWUSR")) return S_IWUSR;
    if (!strcmp(string_mode, "IXUSR")) return S_IXUSR;
    if (!strcmp(string_mode, "IRGRP")) return S_IRGRP;
    if (!strcmp(string_mode, "IWGRP")) return S_IWGRP;
    if (!strcmp(string_mode, "IXGRP")) return S_IXGRP;
    if (!strcmp(string_mode, "IROTH")) return S_IROTH;
    if (!strcmp(string_mode, "IWOTH")) return S_IWOTH;
    if (!strcmp(string_mode, "IXOTH")) return S_IXOTH;
d1275 1
a1275 1
 *  Handle DIRED permissions.
d1277 3
a1279 4
PRIVATE int permit_location ARGS3(
	char *,		destpath,
	char *,		srcpath,
	char **,	newpath)
d1283 1
a1283 1
    return(0);
d1289 1
a1289 1
    CONST char *program;
d1293 1
a1293 1
	 *  Create form.
d1296 2
a1297 2
	char * user_filename;
	char * group_name;
d1302 1
a1302 1
	 *  A couple of sanity tests.
d1305 1
a1305 1
	 || !ok_file_or_dir(&dir_info))
d1313 1
a1313 1
	    return(0);
d1322 1
a1322 1
	group_name = HTAA_GidToName (dir_info.st_gid);
d1329 4
a1332 3
      fprintf(fp0,"<H1>%s%s</H1>\n", PERMISSIONS_SEGMENT, user_filename);
	{   /*
	     *	Prevent filenames which include '#' or '?' from messing it up.
d1334 2
a1335 1
	    char * srcpath_url = HTEscape(srcpath, URL_PATH);
d1341 2
a1342 1
	fprintf(fp0, "<Ol><Li>%s<Br><Br>\n", gettext("Specify permissions below:"));
d1345 1
a1345 1
     "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",
d1348 1
a1348 1
    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",
d1351 1
a1351 1
	 *  If restricted, only change eXecute permissions on directories.
d1355 3
a1357 3
       "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",
		(dir_info.st_mode & S_IXUSR) ? "checked" : "",
		S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1361 1
a1361 1
     "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",
d1364 1
a1364 1
    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",
d1367 1
a1367 1
	 *  If restricted, only change eXecute permissions on directories.
d1371 3
a1373 3
       "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",
		(dir_info.st_mode & S_IXGRP) ? "checked" : "",
		S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1377 1
a1377 1
     "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",
d1380 1
a1380 1
    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",
d1383 1
a1383 1
	 *  If restricted, only change eXecute permissions on directories.
d1387 3
a1389 3
       "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",
		(dir_info.st_mode & S_IXOTH) ? "checked" : "",
		S_ISDIR(dir_info.st_mode) ? "Search" : "Execute");
d1391 2
a1392 2
      fprintf(fp0,
"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
d1400 1
a1400 1
	return(PERMIT_FORM_RESULT);	 /* Special flag for LYMainLoop */
d1402 1
a1402 1
    } else {				 /* The form being activated. */
d1406 2
a1407 3
	 *  Make sure we have a valid set-permission
	 *  file comparison string loaded via a previous
	 *  call with srcpath != NULL. - KW
d1415 2
a1416 2
			(destpath ?
			 destpath : "NULL URL pointer")));
d1420 1
a1420 1
	while (*cp != '\0' && *cp != '?') { /* Find filename */
d1424 1
a1424 1
	    return(0);	/* Nothing to permit. */
d1426 2
a1427 2
	*cp++ = '\0';	/* Null terminate file name and
			   start working on the masks. */
d1431 1
a1431 1
		return(0);
d1434 1
a1434 1
	    return(0);
d1441 2
a1442 2
	 *  Make sure that the file string is the one from
	 *  the last displayed File Permissions menu. - KW
d1450 1
a1450 1
			destpath));
d1455 1
a1455 1
	 *  A couple of sanity tests.
d1459 1
a1459 1
	 || !ok_file_or_dir(&dir_info)) {
d1464 1
a1464 1
	 *  Cycle over permission strings.
d1466 1
a1466 1
	while(*cp != '\0') {
d1469 1
a1469 1
	    while(*cr != '\0' && *cr != '&') { /* GET data split by '&'. */
d1475 1
a1475 1
	    if (strncmp(cp, "mode=", 5) == 0) { /* Magic string. */
d1480 2
a1481 2
		     *  If restricted, only change eXecute
		     *  permissions on directories.
d1484 2
a1485 2
		     || strchr(cp+5, 'X') == NULL
		     || S_ISDIR(dir_info.st_mode))
d1500 1
a1500 1
	 *  Call chmod().
d1507 2
a1508 2
	    HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
	    sprintf(amode, "%.4o", (unsigned int)new_mode);
d1530 1
a1530 1
 *  Display or remove a tag from a given link.
d1532 2
a1533 3
PUBLIC void tagflag ARGS2(
	int,		flag,
	int,		cur)
d1546 1
a1546 1
	    LYHideCursor(); /* get cursor out of the way */
d1550 1
a1550 1
	     *	Never hide the cursor if there's no FANCY CURSES.
d1559 1
a1559 1
 *  Handle DIRED tags.
d1561 1
a1561 2
PUBLIC void showtags ARGS1(
	HTList *,	t)
d1569 1
a1569 1
	while ((name = HTList_nextObject(s)) != NULL) {
d1578 1
a1578 2
PRIVATE char * DirectoryOf ARGS1(
	char *,		pathname)
d1587 1
a1587 1
	CONST char *result1 = 0;
d1593 1
a1593 1
	StrAllocCopy (result, result1);
d1603 1
a1603 2
PRIVATE char * LYonedot ARGS1(
	char *,		line)
d1608 2
a1609 2
    if (pathconf (line, _PC_NAME_MAX) <= 12) {
	LYstrncpy(line1, line, sizeof(line1)-1);
d1612 1
a1612 1
	     || LYLastPathSep(dot) != 0) {
d1620 1
a1620 1
	return(line1);
d1622 1
a1622 1
    return(line);
d1628 2
a1629 3
PRIVATE char * match_op ARGS2(
	CONST char *,	prefix,
	char *,		data)
d1634 1
a1634 1
     && !strncmp(prefix, data + 12, (unsigned)len)) {
d1647 2
a1648 2
 *  Construct the appropriate system command taking care to
 *  escape all path references to avoid spoofing the shell.
d1650 3
a1652 4
PRIVATE char *build_command ARGS3(
	char *,		line,
	char *,		dirname,
	char *,		arg)
d1655 2
a1656 2
    CONST char *program;
    CONST char *tar_path = HTGetProgramPath(ppTAR);
a1666 1

d1698 1
a1698 1
#  endif /* OK_GZIP */
d1723 1
a1723 1
# endif /* !ARCHIVE_ONLY */
d1742 1
a1742 1
# endif /* OK_GZIP */
d1824 1
a1824 1
# endif /* !ARCHIVE_ONLY */
d1841 13
a1853 15
 *  Perform file management operations for LYNXDIRED URL's.
 *  Attempt to be consistent.  These are (pseudo) URLs - i.e., they should
 *  be in URL syntax: some bytes will be URL-escaped with '%'.	This is
 *  necessary because these (pseudo) URLs will go through some of the same
 *  kinds of interpretations and mutilations as real ones: HTParse, stripping
 *  off #fragments etc.  (Some access schemes currently have special rules
 *  about not escaping parsing '#' "the URL way" built into HTParse, but that
 *  doesn't look like a clean way.)
 */
PUBLIC int local_dired ARGS1(
	DocInfo *,	doc)
{
    char *line_url;    /* will point to doc's address, which is a URL */
    char *line = NULL; /* same as line_url, but HTUnEscaped, will be alloced */
    char *arg = NULL; /* ...will point into line[] */
d1862 3
a1864 2
		(line_url ?
		 line_url : gettext("NULL URL pointer"))));
d1868 2
a1869 2
    HTUnEscape(line);	/* _file_ (not URL) syntax, for those functions
			   that need it.  Don't forget to FREE it. */
d1875 1
a1875 1
	arg = "blah";	/* do something to avoid cc's complaints */
d1909 1
a1909 1
	     *	One of the checks may have failed.
d1929 3
a1931 4
	 *  They're written by LYUpload_options() HTUnEscaped;
	 *  don't want to change that for now... so pass through
	 *  without more unescaping.  Directory names containing
	 *  '#' will probably fail.
d1945 1
a1945 1
	    if ((int) strlen(buffer) < LYcols - 15) {
d1974 1
a1974 1
 *  Provide a menu of file management options.
d1976 1
a1976 3
PUBLIC int dired_options ARGS2(
	DocInfo *,	doc,
	char **,	newfile)
d1992 1
a1992 1
	return(0);
d1995 1
a1995 1
     *  Make the tempfile a URL.
d2000 1
a2000 1
    if (doc->link > -1 && doc->link < (nlinks+1)) {
d2032 2
a2033 3
	 *  Write out number of tagged items, and names of first
	 *  few of them relative to current (in the DIRED sense)
	 *  directory.
d2039 1
d2043 3
a2045 1
		n, ((n == 1) ? gettext("tagged item:") : gettext("tagged items:")));
d2051 1
a2051 1
	    cp1 = HTRelative(HTList_objectAt(tagged, i-1),
d2054 1
a2054 1
	    LYEntify(&cp1, TRUE); /* _should_ do this everywhere... */
d2056 1
a2056 1
			 (i == 1 ? "" : " ,"), cp1);
d2060 1
a2060 1
	    fprintf(fp0," , ...");
d2067 1
a2067 1
     *	If menu_head is NULL then use defaults and link them together now.
d2096 1
a2096 1
	dir_url  = HTEscape(dir, URL_PATH);
d2099 1
a2099 1
		render_item(mp->href, path_url, dir_url, buf,sizeof(buf), YES));
d2101 1
a2101 1
		render_item(mp->link, path, dir, buf,sizeof(buf), NO));
d2103 1
a2103 1
		render_item(mp->rest, path, dir, buf,sizeof(buf), NO));
d2115 1
a2115 1
		"<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",
d2126 1
a2126 1
    return(0);
d2130 1
a2130 1
 *  Check DIRED filename.
d2132 3
a2134 4
PRIVATE char *get_filename ARGS3(
	char *,		prompt,
	char *,		buf,
	size_t,		bufsize)
d2147 1
a2147 1
	cp = LYLastPathSep(buf); /* find last slash */
d2164 3
a2166 2
static char ** install_argp = NULL;	/* args for execv install */
static char * install_path = NULL;	/* auxiliary */
d2168 1
a2168 1
PRIVATE void clear_install_path NOARGS
d2176 15
a2190 17
 *  Fill in args array for execv (or execvp etc.) call, after first
 *  allocating it if necessary.  No fancy parsing, cmd_args is just
 *  split at spaces.  Leave room for reserve additional args to be
 *  added by caller.
 *  On success *argvp points to new args vector, *pathp is auxiliary.
 *  On success returns index of next argument, else -1.
 *  This is generic enough that it could be used for other calls than
 *  install, except the atexit call.  Go through this trouble for install
 *  because INSTALL_ARGS may be significant, and someone may configure it
 *  with more than one significant flags. - kw
 */
PRIVATE int fill_argv_for_execv ARGS5(
    char ***,		argvp,
    char **,		pathp,
    char *,		cmd_path,
    CONST char *,	cmd_args,
    int,		reserve)
d2196 1
d2198 2
a2199 1
	*argvp = typecallocn(char *, LYEXECV_MAX_ARGC+1);
d2201 1
a2201 1
	    return(-1);
d2218 2
a2219 2
		       NONNULL(cmd_path), cmd_args));
		return(-1);
d2225 2
a2226 2
    args[n] = (char *)0;
    return(n);
d2230 1
a2230 1
 *  Install the specified file or directory.
d2232 3
a2234 4
PUBLIC BOOLEAN local_install ARGS3(
	char *,		destpath,
	char *,		srcpath,
	char **,	newpath)
d2237 3
a2239 2
    static char savepath[DIRED_MAXBUF]; /* This will be the link that
					   is to be installed. */
d2246 1
a2246 1
    int n = 0;		/* indices into 'args[]' */
d2248 1
a2248 1
    CONST char *program;
d2256 1
a2256 1
     *	Determine the status of the selected item.
d2262 1
d2309 1
a2309 1
    } else if (0 /*directory not writable*/) {
d2332 1
a2332 1
	    HTAlert(gettext("Error buiding install args"));
d2341 1
a2341 1
    args[n] = (char *)0;
d2350 1
a2350 1
	    return(-1);		/* don't do it */
d2369 1
d2371 1
a2371 1
	while ((name = (char *)HTList_nextObject(tag))) {
d2373 1
d2409 1
a2409 1
 *  Clear DIRED tags.
d2411 1
a2411 1
PUBLIC void clear_tags NOARGS
d2415 1
a2415 1
    while ((cp = HTList_removeLastObject(tagged)) != NULL) {
d2423 1
a2423 1
 *  Handle DIRED menu item.
d2425 1
a2425 2
PUBLIC void add_menu_item ARGS1(
	char *,		str)
d2427 1
a2427 1
    struct dired_menu *new, *mp;
d2431 1
a2431 2
     *	First custom menu definition causes entire default menu to be
     *	discarded.
d2436 3
a2438 2
    new = typecalloc(struct dired_menu);
    if (new == NULL)
d2442 1
a2442 1
     *	Conditional on tagged != NULL ?
d2447 1
a2447 1
	new->cond = DE_TAG;
d2449 1
a2449 1
	new->cond = DE_DIR;
d2451 1
a2451 1
	new->cond = DE_FILE;
d2454 1
a2454 1
	new->cond = DE_SYMLINK;
d2459 1
a2459 1
     *	Conditional on matching suffix.
d2464 1
a2464 1
    StrAllocCopy(new->sfx, str);
d2469 1
a2469 1
    StrAllocCopy(new->link, str);
d2474 1
a2474 1
    StrAllocCopy(new->rest, str);
d2476 1
a2476 1
    StrAllocCopy(new->href, cp);
d2479 2
a2480 3
	for (mp = menu_head; mp && mp->next != NULL; mp = mp->next)
	    ;
	mp->next = new;
d2482 1
a2482 1
	menu_head = new;
d2485 1
a2485 1
PUBLIC void reset_dired_menu NOARGS
d2489 1
d2503 1
a2503 1
 *  Create URL for DIRED HREF value.
d2505 6
a2510 7
PRIVATE char * render_item ARGS6(
	CONST char *,	s,
	CONST char *,	path,
	CONST char *,	dir,
	char *,		buf,
	int,		bufsize,
	BOOLEAN,	url_syntax)
d2512 1
a2512 1
    CONST char *cp;
d2516 1
d2518 2
a2519 2
				/* Buffer overrun could happen for very long
				   tag list, if %l or %t are used */
d2525 22
a2546 4
		case '%':
		    *BP_INC = '%';
		    break;
		case 'p':
d2548 22
a2569 2
		    if (!LYIsHtmlSep(*cp))
			*BP_INC = '/';
d2572 7
a2578 45
		    break;
		case 'd':
		    cp = dir;
		    if (!LYIsHtmlSep(*cp))
			*BP_INC = '/';
		    while (*cp)
			*BP_INC = *cp++;
		    break;
		case 'f':
		    cp = LYLastPathSep(path);
		    if (cp)
			cp++;
		    else
			cp = path;
		    while (*cp)
			*BP_INC = *cp++;
		    break;
		case 'l':
		case 't':
		    if (!HTList_isEmpty(tagged)) {
			HTList *cur = tagged;
			char *name;

			while (!overrun &&
			       (name = (char *)HTList_nextObject(cur))!=NULL) {
			    if (*s == 'l' && (cp = strrchr(name, '/')))
				cp++;
			    else
				cp = name;
			    StrAllocCat(taglist, cp);
			    StrAllocCat(taglist, " "); /* should this be %20?*/
			}
		    }
		    if (taglist) {
			/* could HTUnescape here... */
			cp = taglist;
			while (*cp)
			    *BP_INC = *cp++;
			FREE(taglist);
		    }
		    break;
		default:
		    *BP_INC = '%';
		    *BP_INC = *s;
		    break;
d2582 2
a2583 3
	     *	Other chars come from the lynx.cfg or
	     *	the default.  Let's assume there isn't
	     *	anything weird there that needs escaping.
d2585 1
a2585 1
	    *BP_INC =*s;
d2591 1
a2591 1
	bp = buf;	/* set to start, will return empty string as URL */
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d113 1
d330 1
a330 1
	char *,		path,
d335 2
a336 19
#if defined(VMS)
    CTRACE((tfp, "LYExecv:  Called inappropriately!\n"));
#else
#if defined(_WINDOWS)
    if (!strcmp(path, TOUCH_PATH)) {
#if defined(__BORLANDC__) || defined(__MINGW32__)
	int fd = _creat(argv[1], S_IREAD | S_IWRITE);
#else /* Visual C++ */
	int fd = _creat(argv[1], _S_IREAD | _S_IWRITE);
#endif
	if (fd >= 0) {
	    close(fd);
	    return(1);
	}
    } else if (!strcmp(path, RM_PATH)) {
	rc = remove(argv[2]);
    } else {
	CTRACE((tfp, "LYExecv:  Called inappropriately! (path=%s)\n", path));
    }
d348 1
a348 1
    pid_t pid;
d397 4
a400 2
	    if (WEXITSTATUS(wstatus) != 0 ||
		WTERMSIG(wstatus) > 0)	{ /* error return */
d422 1
a422 2
#endif /* _WINDOWS */
#endif /* VMS */
d425 96
d524 5
a528 9
#ifdef WIN_EX	/* 1999/01/02 (Sat) 23:24:20 */
    if ((code = rename(source, target)) != 0)
	if ((code = LYCopyFile(source, target)) >= 0)
	    code = remove(source);
    if (code == 0)
	code = 1;
#else
    char *msg = 0;
    char *args[5];
d530 26
a555 8
    HTSprintf0(&msg, gettext("move %s to %s"), source, target);
    args[0] = "mv";
    args[1] = source;
    args[2] = target;
    args[3] = (char *) 0;
    code = (LYExecv(MV_PATH, args, msg) <= 0) ? -1 : 1;
    FREE(msg);
#endif
a605 1
    char *args[5];
d627 1
a627 6
		args[0] = "rm";
		args[1] = "-rf";
		args[2] = testpath;
		args[3] = (char *) 0;
		HTSprintf0(&tmpbuf, gettext("remove %s"), testpath);
		if (LYExecv(RM_PATH, args, tmpbuf) <= 0) {
d703 1
a703 1
		savepath = HTURLPath_toFile(cp, TRUE);
d706 1
a706 1
		savepath = HTURLPath_toFile(".", TRUE);
d711 2
a712 2
	    } else if (!strncmp(cp, "file:", 5)) {
		cp += 5;
d714 1
a714 1
	    savepath = HTURLPath_toFile(cp, TRUE);
d776 1
a776 1
	 * by the same uid as the owner of the current location.
d833 1
a880 1

d889 6
a894 1
	cp = gettext("Enter new location for directory: ");
d900 2
d938 1
a938 1

d945 3
a947 1
	} else if (dir_has_same_owner(&dir_info, owner)) {
d960 1
a960 1
	document *,	doc,
a1037 1
    char *args[5];
d1040 1
d1063 1
a1063 7
		char *msg = 0;
		HTSprintf0(&msg,gettext("create %s"),testpath);
		args[0] = "touch";
		args[1] = testpath;
		args[2] = (char *) 0;
		code = (LYExecv(TOUCH_PATH, args, msg) <= 0) ? -1 : 1;
		FREE(msg);
a1079 1
    char *args[5];
d1082 1
d1102 1
a1102 7
		char *msg = 0;
		HTSprintf0(&msg,"make directory %s",testpath);
		args[0] = "mkdir";
		args[1] = testpath;
		args[2] = (char *) 0;
		code = (LYExecv(MKDIR_PATH, args, msg) <= 0) ? -1 : 1;
		FREE(msg);
d1114 1
a1114 1
	document *,	doc)
d1150 1
a1150 1
    char *args[5];
d1169 1
a1169 1
		       gettext("Remove '%s' and all of its contents?"), cp);
d1172 1
a1172 1
		       gettext("Remove directory and all of its contents?"));
d1174 1
d1196 3
a1198 6
	HTSprintf0(&tmpbuf,"remove %s",testpath);
	args[0] = "rm";
	args[1] = "-rf";
	args[2] = testpath;
	args[3] = (char *) 0;
	code = (LYExecv(RM_PATH, args, tmpbuf) <= 0) ? -1 : 1;
d1208 1
a1208 1
	document *,	doc)
a1278 1
    char *tmpbuf = NULL;
d1281 1
d1326 2
a1327 2
	    fprintf(fp0, "<Form Action=\"LYNXDIRED://PERMIT_LOCATION%s\">\n",
		    srcpath_url);
a1392 2
	char *args[5];
	char amode[10];
d1420 1
a1420 1
	if ((destpath = HTURLPath_toFile(destpath, TRUE)) == 0)
a1488 1
#ifdef UNIX
d1492 15
a1506 7
	HTSprintf0(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
	sprintf(amode, "%.4o", (unsigned int)new_mode);
	args[0] = "chmod";
	args[1] = amode;
	args[2] = destpath;
	args[3] = (char *) 0;
	if (LYExecv(CHMOD_PATH, args, tmpbuf) <= 0) {
d1508 3
a1510 1
	    return (-1);
a1511 2
	FREE(tmpbuf);
#endif /* UNIX */
d1528 1
a1528 1
	stop_reverse();
a1573 1
    char *result1 = 0;
d1578 1
d1580 2
d1631 1
a1631 1
#if defined(DOSPATH) || defined(__EMX__)
d1642 196
d1848 1
a1848 1
	document *,	doc)
d1941 1
a1941 125
	/*
	 *  Construct the appropriate system command taking care to
	 *  escape all path references to avoid spoofing the shell.
	 */
	if ((arg = match_op("DECOMPRESS", line)) != 0) {
#define FMT_UNCOMPRESS "%s %s"
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 1, UNCOMPRESS_PATH);
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, arg);
	    HTEndParam(&buffer, FMT_UNCOMPRESS, 2);

#if defined(OK_UUDECODE) && !defined(ARCHIVE_ONLY)
	} else if ((arg = match_op("UUDECODE", line)) != 0) {
#define FMT_UUDECODE "%s %s"
	    HTAddParam(&buffer, FMT_UUDECODE, 1, UUDECODE_PATH);
	    HTAddParam(&buffer, FMT_UUDECODE, 2, arg);
	    HTEndParam(&buffer, FMT_UUDECODE, 2);
	    HTAlert(gettext("Warning!  UUDecoded file will exist in the directory you started Lynx."));
#endif /* OK_UUDECODE && !ARCHIVE_ONLY */

#ifdef OK_TAR
# ifndef ARCHIVE_ONLY
#  ifdef OK_GZIP
	} else if ((arg = match_op("UNTAR_GZ", line)) != 0) {
#define FMT_UNTAR_GZ "cd %s; %s -qdc %s |  %s -xf -"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 1, dirname);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 2, GZIP_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 3, arg);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 4, TAR_PATH);
	    HTEndParam(&buffer, FMT_UNTAR_GZ, 4);
#  endif /* OK_GZIP */

	} else if ((arg = match_op("UNTAR_Z", line)) != 0) {
#define FMT_UNTAR_Z "cd %s; %s %s |  %s -xf -"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 1, dirname);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 2, ZCAT_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 3, arg);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 4, TAR_PATH);
	    HTEndParam(&buffer, FMT_UNTAR_Z, 4);

	} else if ((arg = match_op("UNTAR", line)) != 0) {
#define FMT_UNTAR "cd %s; %s -xf %s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNTAR, 1, dirname);
	    HTAddParam(&buffer, FMT_UNTAR, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_UNTAR, 3, arg);
	    HTEndParam(&buffer, FMT_UNTAR, 3);
# endif /* !ARCHIVE_ONLY */

# ifdef OK_GZIP
	} else if ((arg = match_op("TAR_GZ", line)) != 0) {
#define FMT_TAR_GZ "cd %s; %s -cf - %s | %s -qc >%s%s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_TAR_GZ, 1, dirname);
	    HTAddParam(&buffer, FMT_TAR_GZ, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_TAR_GZ, 3, LYPathLeaf(arg));
	    HTAddParam(&buffer, FMT_TAR_GZ, 4, GZIP_PATH);
	    HTAddParam(&buffer, FMT_TAR_GZ, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR_GZ, 6, EXT_TAR_GZ);
	    HTEndParam(&buffer, FMT_TAR_GZ, 6);
# endif /* OK_GZIP */

	} else if ((arg = match_op("TAR_Z", line)) != 0) {
#define FMT_TAR_Z "cd %s; %s -cf - %s | %s >%s%s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_TAR_Z, 1, dirname);
	    HTAddParam(&buffer, FMT_TAR_Z, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_TAR_Z, 3, LYPathLeaf(arg));
	    HTAddParam(&buffer, FMT_TAR_Z, 4, COMPRESS_PATH);
	    HTAddParam(&buffer, FMT_TAR_Z, 5, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR_Z, 6, EXT_TAR_Z);
	    HTEndParam(&buffer, FMT_TAR_Z, 6);

	} else if ((arg = match_op("TAR", line)) != 0) {
#define FMT_TAR "cd %s; %s -cf %s.tar %s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_TAR, 1, dirname);
	    HTAddParam(&buffer, FMT_TAR, 2, TAR_PATH);
	    HTAddParam(&buffer, FMT_TAR, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_TAR, 4, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_TAR, 4);
#endif /* OK_TAR */

#ifdef OK_GZIP
	} else if ((arg = match_op("GZIP", line)) != 0) {
#define FMT_GZIP "%s -q %s"
	    HTAddParam(&buffer, FMT_GZIP, 1, GZIP_PATH);
	    HTAddParam(&buffer, FMT_GZIP, 2, arg);
	    HTEndParam(&buffer, FMT_GZIP, 2);
#ifndef ARCHIVE_ONLY
	} else if ((arg = match_op("UNGZIP", line)) != 0) {
#define FMT_UNGZIP "%s -d %s"
	    HTAddParam(&buffer, FMT_UNGZIP, 1, GZIP_PATH);
	    HTAddParam(&buffer, FMT_UNGZIP, 2, arg);
	    HTEndParam(&buffer, FMT_UNGZIP, 2);
#endif /* !ARCHIVE_ONLY */
#endif /* OK_GZIP */

#ifdef OK_ZIP
	} else if ((arg = match_op("ZIP", line)) != 0) {
#define FMT_ZIP "cd %s; %s -rq %s.zip %s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_ZIP, 1, dirname);
	    HTAddParam(&buffer, FMT_ZIP, 2, ZIP_PATH);
	    HTAddParam(&buffer, FMT_ZIP, 3, LYonedot(LYPathLeaf(arg)));
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(arg));
	    HTEndParam(&buffer, FMT_ZIP, 4);
#ifndef ARCHIVE_ONLY
	} else if ((arg = match_op("UNZIP", line)) != 0) {
#define FMT_UNZIP "cd %s; %s -q %s"
	    dirname = DirectoryOf(arg);
	    HTAddParam(&buffer, FMT_UNZIP, 1, dirname);
	    HTAddParam(&buffer, FMT_UNZIP, 2, UNZIP_PATH);
	    HTAddParam(&buffer, FMT_UNZIP, 3, arg);
	    HTEndParam(&buffer, FMT_UNZIP, 3);
# endif /* !ARCHIVE_ONLY */
#endif /* OK_ZIP */

	} else if ((arg = match_op("COMPRESS", line)) != 0) {
#define FMT_COMPRESS "%s %s"
	    HTAddParam(&buffer, FMT_COMPRESS, 1, COMPRESS_PATH);
	    HTAddParam(&buffer, FMT_COMPRESS, 2, arg);
	    HTEndParam(&buffer, FMT_COMPRESS, 2);
	}
d1976 1
a1976 1
	document *,	doc,
d1992 1
a1992 3
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(gettext("Unable to open file management menu file."));
a1993 1
    }
a2139 1
    *buf = '\0';
d2173 1
d2227 1
d2247 6
d2351 1
a2351 4
#ifdef DOSPATH
		   !strchr(savepath + strlen(destpath) + 1, '\\') &&
#endif
		   !strchr(savepath + strlen(destpath) + 1, '/')) {
d2359 1
a2359 1
	if (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0) {
d2380 1
a2380 4
#ifdef DOSPATH
		       !strchr(args[src] + strlen(destpath) + 1, '\\') &&
#endif
		       !strchr(args[src] + strlen(destpath) + 1, '/')) {
d2386 1
a2386 1
	    err = (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0);
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d46 1
d48 2
a49 4
#ifndef VMS
#ifndef _WINDOWS
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
a50 2
#endif /*_WINDOWS */
#endif /* VMS */
d52 12
a63 6
#ifndef WEXITSTATUS
# ifdef HAVE_TYPE_UNIONWAIT
#  define	WEXITSTATUS(status)	(status.w_retcode)
# else
#  define	WEXITSTATUS(status)	(((status) & 0xff00) >> 8)
# endif
d66 2
a67 6
#ifndef WTERMSIG
# ifdef HAVE_TYPE_UNIONWAIT
#  define	WTERMSIG(status)	(status.w_termsig)
# else
#  define	WTERMSIG(status)	((status) & 0x7f)
# endif
d70 1
a70 1
#include <LYLeaks.h>
d72 7
a78 8
PRIVATE int LYExecv PARAMS((
	char *		path,
	char ** 	argv,
	char *		msg));

#ifdef DIRED_SUPPORT
PUBLIC char LYPermitFileURL[LY_MAXPATH] = "\0";
PUBLIC char LYDiredFileURL[LY_MAXPATH] = "\0";
d86 1
a86 1
PRIVATE BOOLEAN permit_location PARAMS((
d89 1
a89 1
	char ** 	newpath));
d94 2
a95 2
	char *		path,
	char *		dir,
d98 1
a98 1
	BOOLEAN 	url_syntax));
d119 4
d129 1
d131 6
a136 1
"(of current selection)", "LYNXDIRED://INSTALL_SRC%p",		NULL },
d138 2
a139 1
"(of current selection)", "LYNXDIRED://INSTALL_SRC%p",		NULL },
d145 1
d148 1
d161 1
d164 1
d170 1
d173 1
d181 1
a181 1
{ DE_FILE,	".tar.Z", "Expand",
d194 1
a194 1
{ DE_FILE,	    ".Z", "Uncompress",
d223 5
d238 1
a238 1
	  "(using gzip)", "LYNXDIRED://GZIP%p", 		NULL },
d249 5
d261 1
a261 1
		    NULL, NULL, 				NULL }
d264 1
a264 1
PRIVATE BOOLEAN cannot_stat ARGS1(char *, name)
d267 1
a267 1
    HTSprintf(&tmpbuf, gettext("Unable to get status of '%s'."), name);
d273 3
a275 1
PRIVATE BOOLEAN ok_stat ARGS2(char *, name, struct stat*, sb)
d277 2
a278 2
    CTRACE(tfp, "testing ok_stat(%s)\n", name);
    if (stat(name, sb) < 0) {
d287 1
a287 1
    CTRACE(tfp, "testing ok_lstat(%s)\n", name);
d307 2
a308 1
PRIVATE BOOLEAN ok_localname ARGS2(char*, dst, char*, src)
a309 1
    char *s = HTfullURL_toFile(strip_trailing_slash(src));
d312 1
a312 1
    if (!ok_stat(s, &dir_info)
a313 1
	FREE(s);
d316 5
a320 2
    strcpy(dst, s);
    FREE(s);
d323 98
d422 18
d443 7
d453 1
a453 1
    HTSprintf(&msg, gettext("move %s to %s"), source, target);
d460 1
d468 1
a468 1
    if (stat(name, &dir_info) == -1) {
d484 1
a484 1
PRIVATE BOOLEAN dir_has_same_owner ARGS2(struct stat *, info, uid_t, owner)
d487 1
a487 1
	if (info->st_uid == owner) {
d501 1
a501 1
PRIVATE BOOLEAN remove_tagged NOARGS
d516 1
a516 1
    ans = HTConfirm(gettext("Remove all tagged files and directories "));
d544 1
d563 2
a564 2
PRIVATE BOOLEAN modify_tagged ARGS1(
	char *, 	testpath)
d569 1
a569 1
    uid_t owner;
d571 1
a571 1
    char *savepath = NULL;
a604 2
	    if (!cp)	/* Last resort, should never happen. */
		cp = "/";
d611 8
a618 2
	    cp = HTfullURL_toFile(strip_trailing_slash(cp));
	    savepath = HTParse(".", cp, PARSE_PATH+PARSE_PUNCTUATION);
d620 6
a625 2
	    cp = HTfullURL_toFile(cp);
	    StrAllocCopy(savepath, cp);
a626 1
	FREE(cp);
d654 1
a654 1
	    strcpy(tmpbuf, cp1);
d697 1
a697 2
		cp = HTfullURL_toFile(cp);
		StrAllocCopy(srcpath, cp);
a699 1
		    FREE(cp);
d704 1
a704 1
		FREE(cp);
d719 2
a720 2
PRIVATE BOOLEAN modify_name ARGS1(
	char *, 	testpath)
d723 2
a724 3
    char tmpbuf[512];
    char newpath[512];
    char savepath[512];
d726 1
d750 7
a756 8
	if (strchr(tmpbuf, '/') != NULL) {
	    HTAlert(gettext("Illegal character \"/\" found! Request ignored."));
	} else if (strlen(tmpbuf) &&
		   (cp = strrchr(testpath, '/')) != NULL) {
	    strcpy(savepath,testpath);
	    *(++cp) = '\0';
	    strcpy(newpath,testpath);
	    strcat(newpath,tmpbuf);
d762 1
a762 1
		return move_file(savepath, newpath);
d764 2
d768 1
a768 1
    return 0;
d774 2
a775 2
PRIVATE BOOLEAN modify_location ARGS1(
	char *, 	testpath)
d780 1
a780 1
    uid_t owner;
d782 2
a783 2
    char newpath[512];
    char savepath[512];
d785 1
d809 2
a810 2
	strcpy(savepath, testpath);
	strcpy(newpath, testpath);
d817 9
a825 12
	    strcpy(newpath, Home_Dir());
	    strcat(newpath, (tmpbuf + 1));
	    strcpy(tmpbuf, newpath);
	}
	if (!LYIsPathSep(tmpbuf[0])) {
	    if ((cp = strrchr(newpath,'/')) != NULL) {
		*++cp = '\0';
		strcat(newpath,tmpbuf);
	    } else {
		HTAlert(gettext("Unexpected failure - unable to find trailing \"/\""));
		return 0;
	    }
d827 4
a830 1
	    strcpy(newpath,tmpbuf);
d840 1
a840 1
	    return 0;
d846 1
a846 1
	if (dev == dir_info.st_dev && inode == dir_info.st_ino) {
d848 3
a850 4
	    return 0;
	}
	if (dir_has_same_owner(&dir_info, owner)) {
	    return move_file(savepath,newpath);
d852 2
d855 1
a855 1
    return 0;
d861 1
a861 1
PUBLIC BOOLEAN local_modify ARGS2(
d865 1
a865 1
    int c, ans;
d867 1
a867 1
    char testpath[512]; /* a bit ridiculous */
d872 2
a873 1
	strcpy(testpath, cp);
a875 2
	count = modify_tagged(testpath);

d896 1
a896 1
    _statusline(gettext("Modify name, or location (n or l): "));
d898 1
a898 2
    c = LYgetch();
    ans = TOUPPER(c);
d902 5
a906 1
	strcpy(testpath, cp);
d934 2
a935 2
PRIVATE BOOLEAN create_file ARGS1(
	char *, 	current_location)
d938 2
a939 2
    char tmpbuf[512];
    char testpath[512];
d944 1
a944 3
		     tmpbuf, sizeof(tmpbuf)) == NULL) {
	return code;
    }
d946 3
a948 3
    if (!no_dotfiles && show_dotfiles) {
	bad_chars = "~/";
    }
d950 5
a954 5
    if (strstr(tmpbuf, "//") != NULL) {
	HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
    } else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	strcpy(testpath,current_location);
	LYAddPathSep0(testpath);
d956 4
a959 4
	/*
	 *  Append the target filename to the current location.
	 */
	strcat(testpath, tmpbuf);
d961 13
a973 11
	/*
	 *  Make sure the target does not already exist
	 */
	if (not_already_exists(testpath)) {
	    char *msg = 0;
	    HTSprintf(&msg,gettext("create %s"),testpath);
	    args[0] = "touch";
	    args[1] = testpath;
	    args[2] = (char *) 0;
	    code = (LYExecv(TOUCH_PATH, args, msg) <= 0) ? -1 : 1;
	    FREE(msg);
d982 2
a983 2
PRIVATE BOOLEAN create_directory ARGS1(
	char *, 	current_location)
d986 2
a987 2
    char tmpbuf[512];
    char testpath[512];
d992 1
a992 3
		     tmpbuf, sizeof(tmpbuf)) == NULL) {
	return code;
    }
d994 3
a996 3
    if (!no_dotfiles && show_dotfiles) {
	bad_chars = "~/";
    }
d998 5
a1002 5
    if (strstr(tmpbuf, "//") != NULL) {
	HTAlert(gettext("Illegal redirection \"//\" found! Request ignored."));
    } else if (strlen(tmpbuf) && strchr(bad_chars, tmpbuf[0]) == NULL) {
	strcpy(testpath,current_location);
	LYAddPathSep0(testpath);
d1004 1
a1004 1
	strcat(testpath, tmpbuf);
d1006 13
a1018 11
	/*
	 *  Make sure the target does not already exist.
	 */
	if (not_already_exists(testpath)) {
	    char *msg = 0;
	    HTSprintf(&msg,"make directory %s",testpath);
	    args[0] = "mkdir";
	    args[1] = testpath;
	    args[2] = (char *) 0;
	    code = (LYExecv(MKDIR_PATH, args, msg) <= 0) ? -1 : 1;
	    FREE(msg);
d1027 1
a1027 1
PUBLIC BOOLEAN local_create ARGS1(
d1030 1
a1030 1
    int c, ans;
d1032 1
a1032 5
    char testpath[512];

    _statusline(gettext("Create file or directory (f or d): "));
    c = LYgetch();
    ans = TOUPPER(c);
d1035 4
d1042 3
d1057 2
a1058 2
PRIVATE BOOLEAN remove_single ARGS1(
	char *, 	testpath)
d1073 1
a1073 1
    if ((cp = strrchr(testpath, '/')) != NULL) {
d1083 1
a1083 1
		       gettext("Remove '%s' and all of its contents: "), cp);
d1086 1
a1086 1
		       gettext("Remove directory and all of its contents: "));
d1090 1
a1090 1
	    HTSprintf0(&tmpbuf, gettext("Remove file '%s': "), cp);
d1092 1
a1092 1
	    HTSprintf0(&tmpbuf, gettext("Remove file: "));
d1097 1
a1097 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link '%s': "), cp);
d1099 1
a1099 1
	    HTSprintf0(&tmpbuf, gettext("Remove symbolic link: "));
d1123 1
a1123 1
PUBLIC BOOLEAN local_remove ARGS1(
d1127 1
a1127 1
    char testpath[512];
d1143 4
a1162 20
/*
 *  Table of permission strings and chmod values.
 *  Makes the code a bit cleaner.
 */
static struct {
    CONST char *string_mode;	/* Key for  value below */
    long permit_bits;		/* Value for chmod/whatever */
} permissions[] = {
    {"IRUSR", S_IRUSR},
    {"IWUSR", S_IWUSR},
    {"IXUSR", S_IXUSR},
    {"IRGRP", S_IRGRP},
    {"IWGRP", S_IWGRP},
    {"IXGRP", S_IXGRP},
    {"IROTH", S_IROTH},
    {"IWOTH", S_IWOTH},
    {"IXOTH", S_IXOTH},
    {NULL, 0}			/* Don't include setuid and friends;
				   use shell access for that. */
};
d1166 15
d1184 3
a1186 3
PRIVATE BOOLEAN permit_location ARGS3(
	char *, 	destpath,
	char *, 	srcpath,
a1203 1
	char local_src[LY_MAXPATH];
d1207 1
a1207 3
	cp = HTfullURL_toFile(strip_trailing_slash(srcpath));
	strcpy(local_src, cp);
	FREE(cp);
d1212 1
a1212 1
	if (!ok_lstat(local_src, &dir_info)
d1216 1
a1216 1
	user_filename = LYPathLeaf(local_src);
d1228 1
a1228 1
	strcpy(LYPermitFileURL, *newpath);
d1232 1
a1232 1
		  local_src,
d1322 1
a1322 1
	    CTRACE(tfp, "permit_location: called for <%s>.\n",
d1324 1
a1324 1
			 destpath : "NULL URL pointer"));
d1337 2
a1338 1
	if ((destpath = HTfullURL_toFile(destpath)) == 0)
d1340 5
a1344 2

	strcpy(tmpdst, destpath);	/* operate only on filename */
d1357 2
a1358 2
	    CTRACE(tfp, "permit_location: called for file '%s'.\n",
			destpath);
d1384 1
a1384 1
		int i;
d1386 10
a1395 14
		for(i = 0; permissions[i].string_mode != NULL; i++) {
		    if (strcmp(permissions[i].string_mode, cp+5) == 0) {
			/*
			 *  If restricted, only change eXecute
			 *  permissions on directories.
			 */
			if (!no_change_exec_perms ||
			    strchr(cp+5,'X') == NULL ||
			    S_ISDIR(dir_info.st_mode))
			    new_mode |= permissions[i].permit_bits;
			break;
		    }
		}
		if (permissions[i].string_mode == NULL) {
d1411 1
a1411 1
	HTSprintf(&tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
d1438 1
a1438 1
	move(links[cur].ly, 2);
d1441 1
a1441 1
	    addch('+');
d1443 1
a1443 1
	    addch(' ');
d1448 1
a1448 1
	    move((LYlines - 1), (LYcols - 1)); /* get cursor out of the way */
d1454 1
a1454 1
	    move(links[cur].ly, links[cur].lx);
d1456 1
a1456 1
	refresh();
d1485 1
d1492 4
a1495 1
	LYTrimPathSep(result);
d1500 50
d1565 1
d1570 1
d1573 1
a1573 1
    CTRACE(tfp, "local_dired: called for <%s>.\n",
d1575 1
a1575 1
		 line_url : gettext("NULL URL pointer")));
d1581 8
a1588 3

    if (!strncmp(line, "LYNXDIRED://NEW_FILE", 20)) {
	if (create_file(&line[20]) > 0)
d1590 2
a1591 2
    } else if (!strncmp(line, "LYNXDIRED://NEW_FOLDER", 22)) {
	if (create_directory(&line[22]) > 0)
d1593 7
a1599 4
    } else if (!strncmp(line, "LYNXDIRED://INSTALL_SRC", 23)) {
	local_install(NULL, &line[23], &tp);
	StrAllocCopy(doc->address, tp);
	FREE(tp);
d1602 2
a1603 2
    } else if (!strncmp(line, "LYNXDIRED://INSTALL_DEST", 24)) {
	local_install(&line[24], NULL, &tp);
d1605 6
a1610 5
    } else if (!strncmp(line, "LYNXDIRED://MODIFY_NAME", 23)) {
	if (modify_name(&line[23]) > 0)
	LYforce_no_cache = TRUE;
    } else if (!strncmp(line, "LYNXDIRED://MODIFY_LOCATION", 27)) {
	if (modify_location(&line[27]) > 0)
d1612 2
a1613 2
    } else if (!strncmp(line, "LYNXDIRED://MOVE_TAGGED", 23)) {
	if (modify_tagged(&line_url[23]) > 0)
d1616 3
a1618 3
    } else if (!strncmp(line, "LYNXDIRED://PERMIT_SRC", 22)) {
	permit_location(NULL, &line[22], &tp);
	if (tp)
d1622 3
a1624 1
	    StrAllocCopy(doc->address, tp);
a1625 1
	FREE(tp);
d1627 2
a1628 2
    } else if (!strncmp(line, "LYNXDIRED://PERMIT_LOCATION", 27)) {
	permit_location(&line_url[27], NULL, &tp);
d1630 2
a1631 2
    } else if (!strncmp(line, "LYNXDIRED://REMOVE_SINGLE", 25)) {
	if (remove_single(&line[25]) > 0)
d1633 1
a1633 1
    } else if (!strncmp(line, "LYNXDIRED://REMOVE_TAGGED", 25)) {
d1636 1
a1636 1
    } else if (!strncmp(line, "LYNXDIRED://CLEAR_TAGGED", 24)) {
d1638 1
a1638 1
    } else if (!strncmp(line, "LYNXDIRED://UPLOAD", 18)) {
d1649 1
a1649 1
	if (strrchr(line, '/') == NULL) {
d1658 1
a1658 1
	if (!strncmp(line, "LYNXDIRED://DECOMPRESS", 22)) {
d1661 1
a1661 1
	    HTAddParam(&buffer, FMT_UNCOMPRESS, 2, line+22);
d1665 1
a1665 1
	} else if (!strncmp(line, "LYNXDIRED://UUDECODE", 20)) {
d1668 1
a1668 1
	    HTAddParam(&buffer, FMT_UUDECODE, 2, line+20);
d1676 6
a1681 6
	} else if (!strncmp(line, "LYNXDIRED://UNTAR_GZ", 20)) {
#define FMT_UNTAR_GZ "%s -qdc %s | (cd %s; %s -xf -)"
	    dirname = DirectoryOf(line+20);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 1, GZIP_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 2, line+20);
	    HTAddParam(&buffer, FMT_UNTAR_GZ, 3, dirname);
d1686 6
a1691 6
	} else if (!strncmp(line, "LYNXDIRED://UNTAR_Z", 19)) {
#define FMT_UNTAR_Z "%s %s | (cd %s; %s -xf -)"
	    dirname = DirectoryOf(line+19);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 1, ZCAT_PATH);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 2, line+19);
	    HTAddParam(&buffer, FMT_UNTAR_Z, 3, dirname);
d1695 1
a1695 1
	} else if (!strncmp(line, "LYNXDIRED://UNTAR", 17)) {
d1697 1
a1697 1
	    dirname = DirectoryOf(line+17);
d1700 1
a1700 1
	    HTAddParam(&buffer, FMT_UNTAR, 3, line+17);
d1705 3
a1707 3
	} else if (!strncmp(line, "LYNXDIRED://TAR_GZ", 18)) {
#define FMT_TAR_GZ "(cd %s; %s -cf - %s) | %s -qc >%s/%s.tar.gz"
	    dirname = DirectoryOf(line+18);
d1710 1
a1710 1
	    HTAddParam(&buffer, FMT_TAR_GZ, 3, LYPathLeaf(line+18));
d1712 2
a1713 2
	    HTAddParam(&buffer, FMT_TAR_GZ, 5, dirname);
	    HTAddParam(&buffer, FMT_TAR_GZ, 6, LYPathLeaf(line+18));
d1717 3
a1719 3
	} else if (!strncmp(line, "LYNXDIRED://TAR_Z", 17)) {
#define FMT_TAR_Z "(cd %s; %s -cf - %s) | %s >%s/%s.tar.Z"
	    dirname = DirectoryOf(line+17);
d1722 1
a1722 1
	    HTAddParam(&buffer, FMT_TAR_Z, 3, LYPathLeaf(line+17));
d1724 2
a1725 2
	    HTAddParam(&buffer, FMT_TAR_Z, 5, dirname);
	    HTAddParam(&buffer, FMT_TAR_Z, 6, LYPathLeaf(line+17));
d1728 3
a1730 3
	} else if (!strncmp(line, "LYNXDIRED://TAR", 15)) {
#define FMT_TAR "(cd %s; %s -cf %s.tar %s)"
	    dirname = DirectoryOf(line+15);
d1733 2
a1734 2
	    HTAddParam(&buffer, FMT_TAR, 3, LYPathLeaf(line+15));
	    HTAddParam(&buffer, FMT_TAR, 4, LYPathLeaf(line+15));
d1739 1
a1739 1
	} else if (!strncmp(line, "LYNXDIRED://GZIP", 16)) {
d1742 1
a1742 1
	    HTAddParam(&buffer, FMT_GZIP, 2, line+16);
d1745 1
a1745 1
	} else if (!strncmp(line, "LYNXDIRED://UNGZIP", 18)) {
d1748 1
a1748 1
	    HTAddParam(&buffer, FMT_UNGZIP, 2, line+18);
d1754 1
a1754 1
	} else if (!strncmp(line, "LYNXDIRED://ZIP", 15)) {
d1756 1
a1756 1
	    dirname = DirectoryOf(line+15);
d1759 2
a1760 2
	    HTAddParam(&buffer, FMT_ZIP, 3, line+15);
	    HTAddParam(&buffer, FMT_ZIP, 4, LYPathLeaf(line+15));
d1763 1
a1763 1
	} else if (!strncmp(line, "LYNXDIRED://UNZIP", 17)) {
d1765 1
a1765 1
	    dirname = DirectoryOf(line+17);
d1768 1
a1768 1
	    HTAddParam(&buffer, FMT_UNZIP, 3, line+17);
d1773 1
a1773 1
	} else if (!strncmp(line, "LYNXDIRED://COMPRESS", 20)) {
d1776 1
a1776 1
	    HTAddParam(&buffer, FMT_COMPRESS, 2, line+20);
d1781 1
a1781 1
	    if (strlen(buffer) < 60) {
d1789 1
a1789 1
	    printf("%s\n", tmpbuf);
d1804 2
a1805 1
    LYpop(doc);
d1817 3
a1819 2
    char path[512], dir[512]; /* much too large */
    lynx_html_item_type *nxt;
a1821 1
    char *cp = NULL;
d1839 1
a1839 6
    strcpy(LYDiredFileURL, *newfile);

    cp = HTpartURL_toFile(doc->address);
    strcpy(dir, cp);
    LYTrimPathSep(dir);
    FREE(cp);
d1842 1
a1842 2
	cp = HTfullURL_toFile(links[doc->link].lname);
	strcpy(path, cp);
a1843 1
	FREE(cp);
d1847 1
d1852 1
a1852 1
	path[0] = '\0';
d1855 4
a1858 1
    nothing_tagged = (HTList_isEmpty(tagged));
d1946 1
d1958 1
d1972 3
a1974 3
	char *, 	prompt,
	char *, 	buf,
	size_t, 	bufsize)
d1988 1
a1988 1
	cp = strrchr(buf, '/'); /* find last slash */
d2001 66
d2071 2
a2072 2
	char *, 	destpath,
	char *, 	srcpath,
d2076 2
a2077 1
    char savepath[512]; /* This will be the link that is to be installed. */
d2079 1
a2079 1
    char *args[6];
d2081 2
d2084 2
a2085 1
    int n = 0, src;	/* indices into 'args[]' */
d2091 12
a2102 1
	if (!ok_localname(savepath, srcpath))
d2104 1
a2104 1

d2107 3
a2109 1
	StrAllocCat(*newpath, "/.installdirs.html");
d2113 18
d2134 1
d2138 1
d2142 1
d2147 8
a2154 1
    args[n++] = "install";
d2156 3
a2158 1
    args[n++] = INSTALL_ARGS;
d2160 11
a2170 1
    src = n++;
a2172 1
    HTSprintf(&tmpbuf, "install %s", destpath);
d2176 17
d2194 4
a2197 1
	if (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0)
d2199 1
d2203 1
d2207 18
d2227 3
a2229 1
	    if (err)
d2231 1
d2237 1
d2241 1
d2261 1
a2261 1
	char *, 	str)
d2273 1
a2273 1
    new = (struct dired_menu *)calloc(1, sizeof(*new));
d2288 1
d2291 1
d2322 16
d2342 4
a2345 4
	CONST char *, 	s,
	char *, 	path,
	char *, 	dir,
	char *, 	buf,
d2349 1
a2349 1
    char *cp;
d2379 1
a2379 1
		    cp = strrchr(path, '/');
d2413 1
a2413 1
		    *BP_INC =*s;
d2427 1
a2427 2
	strcpy(buf,gettext("Temporary URL or list would be too long."));
	HTAlert(buf);
d2433 1
a2434 85

/*
 *  Execute DIRED command.
 */
PRIVATE int LYExecv ARGS3(
	char *, 	path,
	char **,	argv,
	char *, 	msg)
{
#if defined(VMS) || defined(_WINDOWS)
    CTRACE(tfp, "LYExecv:  Called inappropriately!\n");
    return(0);
#else
    int rc;
    char *tmpbuf = 0;
    pid_t pid;
#ifdef HAVE_TYPE_UNIONWAIT
    union wait wstatus;
#else
    int wstatus;
#endif

    if (TRACE) {
	int n;
	CTRACE(tfp, "LYExecv path='%s'\n", path);
	for (n = 0; argv[n] != 0; n++)
	    CTRACE(tfp, "argv[%d] = '%s'\n", n, argv[n]);
    }

    rc = 1;		/* It will work */
    stop_curses();
    pid = fork();	/* fork and execute rm */
    switch (pid) {
	case -1:
	    HTSprintf(&tmpbuf, gettext("Unable to %s due to system error!"), msg);
	    rc = 0;
	    break;	/* don't fall thru! - KW */
	case 0:  /* child */
#ifdef USE_EXECVP
	    execvp(path, argv);	/* this uses our $PATH */
#else
	    execv(path, argv);
#endif
	    exit(-1);	/* execv failed, give wait() something to look at */
	default:  /* parent */
#if !HAVE_WAITPID
	    while (wait(&wstatus) != pid)
		; /* do nothing */
#else
	    while (-1 == waitpid(pid, &wstatus, 0)) { /* wait for child */
#ifdef EINTR
		if (errno == EINTR)
		    continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
		if (errno == ERESTARTSYS)
		    continue;
#endif /* ERESTARTSYS */
		break;
	    }
#endif /* !HAVE_WAITPID */
	    if (WEXITSTATUS(wstatus) != 0 ||
		WTERMSIG(wstatus) > 0)	{ /* error return */
		HTSprintf(&tmpbuf, gettext("Probable failure to %s due to system error!"),
				   msg);
		rc = 0;
	    }
    }

    if (rc == 0) {
	/*
	 *  Screen may have message from the failed execv'd command.
	 *  Give user time to look at it before screen refresh.
	 */
	sleep(AlertSecs);
    }
    start_curses();
    if (tmpbuf != 0) {
	HTAlert(tmpbuf);
	FREE(tmpbuf);
    }

    return(rc);
#endif /* VMS */
}
@


1.1
log
@Initial revision
@
text
@d31 15
a45 15
#include "HTUtils.h"
#include "tcp.h"
#include "HTAlert.h"
#include "HTParse.h"
#include "LYCurses.h"
#include "LYGlobalDefs.h"
#include "LYUtils.h"
#include "LYStrings.h"
#include "LYCharUtils.h"
#include "LYStructs.h"
#include "LYGetFile.h"
#include "LYHistory.h"
#include "LYUpload.h"
#include "LYLocal.h"
#include "LYSystem.h"
a51 2
#include <errno.h>
#include <grp.h>
d56 1
a56 1
# if HAVE_TYPE_UNIONWAIT
d64 1
a64 1
# if HAVE_TYPE_UNIONWAIT
d71 1
a71 4
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

d79 2
a80 2
PUBLIC char LYPermitFileURL[256] = "\0";
PUBLIC char LYDiredFileURL[256] = "\0";
d82 1
a82 1
PRIVATE char *filename PARAMS((
d95 1
a95 1
	char *		s,
d137 1
a137 1
"(of selected symbolic link)", "LYNXDIRED://MODIFY_NAME%p",		NULL },
d239 106
d350 4
a353 3
    int c, ans;
    char *cp, *tp;
    char tmpbuf[1024];
d356 1
a356 1
    int count, i;
d363 1
a363 3
    _statusline("Remove all tagged files and directories (y or n): ");
    c = LYgetch();
    ans = TOUPPER(c);
d367 5
a371 12
    while (ans == 'Y' && (cp = (char *)HTList_nextObject(tag)) != NULL) {
	if (is_url(cp) == FILE_URL_TYPE) { /* unecessary check */
	    tp = cp;
	    if (!strncmp(tp, "file://localhost", 16)) {
		tp += 16;
	    } else if (!strncmp(tp, "file:", 5)) {
		tp += 5;
	    }
	    StrAllocCopy(testpath, tp);
	    HTUnEscape(testpath);
	    if ((i = strlen(testpath)) && testpath[i-1] == '/')
		testpath[(i - 1)] = '\0';
d376 3
a378 7
	    if (stat(testpath,&dir_info) == -1) {
		sprintf(tmpbuf,
			"System error - failed to get status of '%s'.",
			testpath);
		_statusline(tmpbuf);
		sleep(AlertSecs);
		return count;
d384 1
a384 1
		sprintf(tmpbuf, "remove %s", testpath);
d386 3
a388 2
		    FREE(testpath);
		    return ((count == 0) ? -1 : count);
d395 3
a397 1
    clear_tags();
a419 1
    char *args[5];
d426 1
a426 1
    _statusline("Enter new location for tagged items: ");
d454 1
a454 5
	if (!strncmp(cp, "file://localhost", 16)) {
	    cp += 16;
	} else if (!strncmp(cp, "file:", 5)) {
	    cp += 5;
	}
d459 1
a459 1
	    cp = strip_trailing_slash(cp);
d462 1
d465 3
a467 5
	HTUnEscape(savepath);
	if (stat(savepath, &dir_info) == -1) {
	    sprintf(tmpbuf, "Unable to get status of '%s'.", savepath);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
d488 1
a488 3
		sprintf(tmpbuf, "%s", "Path too long");
		_statusline(tmpbuf);
		sleep(AlertSecs);
d500 2
a501 3
	if (tmpbuf[0] != '/') {
	    if (savepath[(strlen(savepath) - 1)] != '/')
		StrAllocCat(savepath,"/");
d510 1
a510 4
	if (stat(savepath, &dir_info) == -1) {
	    sprintf(tmpbuf,"Unable to get status of '%s'.",savepath);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
d519 1
a519 3
	    _statusline(
	   "Source and destination are the same location - request ignored!");
	    sleep(AlertSecs);
d528 3
a530 16
	if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
	    if (dir_info.st_uid == owner) {
		count = 0;
		tag = tagged;

		/*
		 *  Move all tagged items to the target location.
		 */
		while ((cp = (char *)HTList_nextObject(tag)) != NULL) {
		    if (!strncmp(cp, "file://localhost", 16)) {
			cp += 16;
		    } else if (!strncmp(cp, "file:", 5)) {
			cp += 5;
		    }
		    StrAllocCopy(srcpath, cp);
		    HTUnEscape(srcpath);
d532 12
a543 11
		    sprintf(tmpbuf, "move %s to %s", srcpath, savepath);
		    args[0] = "mv";
		    args[1] = srcpath;
		    args[2] = savepath;
		    args[3] = (char *) 0;
		    if (LYExecv(MV_PATH, args, tmpbuf) <= 0) {
			if (count == 0)
			    count = -1;
			break;
		    }
		    ++count;
d545 2
a546 11
		FREE(srcpath);
		FREE(savepath);
		clear_tags();
		return count;
	    } else {
		_statusline(
			"Destination has different owner! Request denied.");
		sleep(AlertSecs);
		FREE(srcpath);
		FREE(savepath);
		return 0;
d548 2
a549 6
	} else {
	    _statusline(
		   "Destination is not a valid directory! Request denied.");
	    sleep(AlertSecs);
	    FREE(savepath);
	    return 0;
d551 2
a567 1
    char *args[5];
d574 1
a574 5
    if (stat(testpath, &dir_info) == -1) {
	sprintf(tmpbuf, "Unable to get status of '%s'.", testpath);
	_statusline(tmpbuf);
	sleep(AlertSecs);
    } else {
d578 4
a581 4
	if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
	     cp = "Enter new name for directory: ";
	} else if ((dir_info.st_mode & S_IFMT) == S_IFREG) {
	     cp = "Enter new name for file: ";
d583 1
a583 4
	     _statusline(
	 "The selected item is not a file or a directory! Request ignored.");
	     sleep(AlertSecs);
	     return 0;
d585 1
a585 1
	if (filename(cp, tmpbuf, sizeof(tmpbuf)) == NULL)
d592 1
a592 2
	    _statusline("Illegal character \"/\" found! Request ignored.");
	    sleep(AlertSecs);
d603 2
a604 28
	    if (stat(newpath, &dir_info) == -1) {
		if (errno != ENOENT) {
		    sprintf(tmpbuf,
			    "Unable to determine status of '%s'.", newpath);
		    _statusline(tmpbuf);
		    sleep(AlertSecs);
		} else {
		    sprintf(tmpbuf, "move %s to %s", savepath, newpath);
		    args[0] = "mv";
		    args[1] = savepath;
		    args[2] = newpath;
		    args[3] = (char *) 0;
		    if (LYExecv(MV_PATH, args, tmpbuf) <= 0)
			return (-1);
		    return 1;
		}
	    } else if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
		_statusline(
	    "There is already a directory with that name! Request ignored.");
		sleep(AlertSecs);
	    } else if ((dir_info.st_mode & S_IFMT) == S_IFREG) {
		_statusline(
		 "There is already a file with that name! Request ignored.");
		sleep(AlertSecs);
	    } else {
		_statusline(
		   "The specified name is already in use! Request ignored.");
		sleep(AlertSecs);
a616 1
    int mode;
a624 1
    char *args[5];
d631 1
a631 4
    if (stat(testpath, &dir_info) == -1) {
	sprintf(tmpbuf, "Unable to get status of '%s'.", testpath);
	_statusline(tmpbuf);
	sleep(AlertSecs);
d638 4
a641 4
    if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
	cp = "Enter new location for directory: ";
    } else if ((dir_info.st_mode & S_IFMT) == S_IFREG) {
	cp = "Enter new location for file: ";
d643 1
a643 4
	_statusline(
	"The specified item is not a file or a directory - request ignored.");
	sleep(AlertSecs);
	return 0;
d645 1
a645 1
    if (filename(cp, tmpbuf, sizeof(tmpbuf)) == NULL)
d654 2
a655 1
	if (!strncmp(tmpbuf,"~/",2)) {
d660 1
a660 1
	if (tmpbuf[0] != '/') {
d665 1
a665 2
	    _statusline("Unexpected failure - unable to find trailing \"/\"");
		sleep(AlertSecs);
a675 1
	mode = dir_info.st_mode;
d678 1
a678 10
	if (stat(newpath, &dir_info) == -1) {
	    sprintf(tmpbuf,"Unable to get status of '%s'.",newpath);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
	    return 0;
	}
	if ((dir_info.st_mode & S_IFMT) != S_IFDIR) {
	    _statusline(
		"Destination is not a valid directory! Request denied.");
	    sleep(AlertSecs);
d686 1
a686 3
	    _statusline(
	   "Source and destination are the same location! Request ignored!");
	    sleep(AlertSecs);
d689 2
a690 13
	if (dir_info.st_uid == owner) {
	    sprintf(tmpbuf,"move %s to %s",savepath,newpath);
	    args[0] = "mv";
	    args[1] = savepath;
	    args[2] = newpath;
	    args[3] = (char *) 0;
	    if (LYExecv(MV_PATH, args, tmpbuf) <= 0)
		return (-1);
	    return 1;
	} else {
	 _statusline("Destination has different owner! Request denied.");
	    sleep(AlertSecs);
	    return 0;
d709 1
a709 6
	cp = doc->address;
	if (!strncmp(cp, "file://localhost", 16)) {
	    cp += 16;
	} else if (!strncmp(cp, "file:", 5)) {
	    cp += 5;
	}
d711 2
a712 1
	HTUnEscapeSome(testpath, "/");
d733 1
a733 1
    _statusline("Modify name, location, or permission (n, l, or p): ");
d735 1
a735 1
    _statusline("Modify name, or location (n or l): ");
d741 1
a741 6
	cp = links[doc->link].lname;
	if (!strncmp(cp, "file://localhost", 16)) {
	    cp += 16;
	} else if(!strncmp(cp, "file:", 5)) {
	    cp += 5;
	}
d743 1
a743 1
	HTUnEscape(testpath);
d761 1
a761 2
	     _statusline("This feature not yet implemented!");
	    sleep(AlertSecs);
d773 1
a775 1
    struct stat dir_info;
d779 3
a781 3
    if (filename("Enter name of file to create: ",
		 tmpbuf, sizeof(tmpbuf)) == NULL) {
	return 0;
d789 1
a789 2
	_statusline("Illegal redirection \"//\" found! Request ignored.");
	sleep(AlertSecs);
d792 1
a792 3
	if (testpath[(strlen(testpath) - 1)] != '/') {
	    strcat(testpath,"/");
	}
d802 3
a804 9
	if (stat(testpath, &dir_info) == -1) {
	    if (errno != ENOENT) {
		sprintf(tmpbuf,
			"Unable to determine status of '%s'.", testpath);
		_statusline(tmpbuf);
		sleep(AlertSecs);
		return 0;
	    }
	    sprintf(tmpbuf,"create %s",testpath);
d808 2
a809 15
	    if (LYExecv(TOUCH_PATH, args, tmpbuf) <= 0)
		return (-1);
	    return 1;
	} else if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
	    _statusline(
	   "There is already a directory with that name! Request ignored.");
	    sleep(AlertSecs);
	} else if ((dir_info.st_mode & S_IFMT) == S_IFREG) {
	    _statusline(
		"There is already a file with that name! Request ignored.");
	    sleep(AlertSecs);
	} else {
	    _statusline(
		  "The specified name is already in use! Request ignored.");
	    sleep(AlertSecs);
d812 1
a812 1
    return 0;
d821 1
a823 1
    struct stat dir_info;
d827 3
a829 3
    if (filename("Enter name for new directory: ",
		 tmpbuf, sizeof(tmpbuf)) == NULL) {
	return 0;
d837 1
a837 2
	_statusline("Illegal redirection \"//\" found! Request ignored.");
	sleep(AlertSecs);
d840 2
a841 3
	if (testpath[(strlen(testpath) - 1)] != '/') {
	    strcat(testpath,"/");
	}
d847 3
a849 9
	if (stat(testpath, &dir_info) == -1) {
	    if (errno != ENOENT) {
		sprintf(tmpbuf,
			"Unable to determine status of '%s'.", testpath);
		_statusline(tmpbuf);
		sleep(AlertSecs);
		return 0;
	    }
	    sprintf(tmpbuf,"make directory %s",testpath);
d853 2
a854 15
	    if (LYExecv(MKDIR_PATH, args, tmpbuf) <= 0)
		return (-1);
	    return 1;
	} else if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
	    _statusline(
	   "There is already a directory with that name! Request ignored.");
	    sleep(AlertSecs);
	} else if ((dir_info.st_mode & S_IFMT) == S_IFREG) {
	    _statusline(
		"There is already a file with that name! Request ignored.");
	    sleep(AlertSecs);
	} else {
	    _statusline(
		  "The specified name is already in use! Request ignored.");
	    sleep(AlertSecs);
d857 1
a857 1
    return 0;
d870 1
a870 1
    _statusline("Create file or directory (f or d): ");
d874 1
a874 6
    cp = doc->address;
    if (!strncmp(cp, "file://localhost", 16)) {
	cp += 16;
    } else if (!strncmp(cp, "file:", 5)) {
	cp += 5;
    }
d876 1
a876 1
    HTUnEscape(testpath);
d893 1
a893 1
    int c;
d895 1
a895 1
    char tmpbuf[1024];
d899 1
a899 9
    /*
     *	lstat() first in case its a symbolic link.
     */
    if (lstat(testpath, &dir_info) == -1 &&
	stat(testpath, &dir_info) == -1) {
	sprintf(tmpbuf,
		"System error - failed to get status of '%s'.", testpath);
	_statusline(tmpbuf);
	sleep(AlertSecs);
d911 3
a913 1
    if ((dir_info.st_mode & S_IFMT) == S_IFDIR) {
d915 2
a916 2
	    sprintf(tmpbuf,
		    "Remove '%s' and all of its contents (y or n): ", cp);
d918 2
a919 2
	    sprintf(tmpbuf,
		    "Remove directory and all of its contents (y or n): ");
d921 1
a921 1
    } else if ((dir_info.st_mode & S_IFMT) == S_IFREG) {
d923 1
a923 1
	    sprintf(tmpbuf, "Remove file '%s' (y or n): ", cp);
d925 1
a925 1
	    sprintf(tmpbuf, "Remove file (y or n): ");
d928 1
a928 1
    } else if ((dir_info.st_mode & S_IFMT) == S_IFLNK) {
d930 1
a930 1
	    sprintf(tmpbuf, "Remove symbolic link '%s' (y or n): ", cp);
d932 1
a932 1
	    sprintf(tmpbuf, "Remove symbolic link (y or n): ");
d936 2
a937 3
	sprintf(tmpbuf, "Unable to determine status of '%s'.", testpath);
	_statusline(tmpbuf);
	sleep(AlertSecs);
a939 1
    _statusline(tmpbuf);
d941 2
a942 3
    c = LYgetch();
    if (TOUPPER(c) == 'Y') {
	sprintf(tmpbuf,"remove %s",testpath);
d947 1
a947 3
	if (LYExecv(RM_PATH, args, tmpbuf) <= 0)
	    return (-1);
	return 1;
d949 2
a950 1
    return 0;
d975 1
a975 6
	tp = cp;
	if (!strncmp(tp, "file://localhost", 16)) {
	    tp += 16;
	} else if (!strncmp(tp, "file:", 5)) {
	    tp += 5;
	}
d977 2
a978 1
	HTUnEscape(testpath);
d981 1
d997 2
a998 2
    char *string_mode;	/* Key for  value below */
    long permit_bits;	/* Value for chmod/whatever */
d1013 1
a1013 5
#ifndef S_ISDIR
#define S_ISDIR(mode)   ((mode&0xF000) == 0x4000)
#endif /* !S_ISDIR */

PRIVATE char LYValidPermitFile[256] = "\0";
d1024 1
a1024 2
    _statusline("Sorry, don't know how to permit non-UNIX files yet.");
    sleep(AlertSecs);
d1027 1
a1027 2
    static char tempfile[256] = "\0";
    static BOOLEAN first = TRUE;
d1029 2
a1030 1
    char tmpbuf[LINESIZE];
d1038 1
a1039 1
	struct group * grp;
d1042 4
d1049 2
a1050 7
	srcpath = strip_trailing_slash(srcpath);
	if (strncmp(srcpath, "file://localhost", 16) == 0)
	    srcpath += 16;
	if (lstat(srcpath, &dir_info) == -1) {
	    sprintf(tmpbuf, "Unable to get status of '%s'.", srcpath);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
a1051 7
	} else if ((dir_info.st_mode & S_IFMT) != S_IFDIR &&
	    (dir_info.st_mode & S_IFMT) != S_IFREG) {
	    _statusline(
	"The specified item is not a file nor a directory - request ignored.");
	    sleep(AlertSecs);
	    return(0);
	}
d1053 1
a1053 5
	user_filename = srcpath;
	cp = strrchr(srcpath, '/');
	if (cp != NULL) {
	    user_filename = (cp + 1);
	}
d1055 4
a1058 5
	if (first) {
	    /*
	     *	Get an unused tempfile name. - FM
	     */
	    tempname(tempfile, NEW_FILE);
d1062 1
a1062 3
	 *  Open the tempfile for writing and set its
	 *  protection in case this wasn't done via an
	 *  external umask. - FM
d1064 2
a1065 22
	if ((fp0 = LYNewTxtFile(tempfile)) == NULL) {
	    _statusline("Unable to open permit options file");
	    sleep(AlertSecs);
	    return(0);
	}

	if (first) {
	    /*
	     *	Make the tempfile a URL.
	     */
	    strcpy(LYPermitFileURL, "file://localhost");
	    strcat(LYPermitFileURL, tempfile);
	    first = FALSE;
	}
	StrAllocCopy(*newpath, LYPermitFileURL);

	grp = getgrgid(dir_info.st_gid);
	if (grp == NULL) {
	    group_name = "";
	} else {
	    group_name = grp->gr_name;
	}
d1067 1
d1069 1
a1069 1
		  srcpath,
d1074 1
a1074 1
	fprintf(fp0,"<H1>Permissions for %s</H1>\n", user_filename);
d1084 2
a1085 2
	fprintf(fp0, "<Ol><Li>Specify permissions below:<Br><Br>\n");
	fprintf(fp0, "Owner:<Br>\n");
d1101 1
a1101 1
	fprintf(fp0, "Group %s:<Br>\n", group_name);
d1117 1
a1117 1
	fprintf(fp0, "Others:<Br>\n");
d1133 4
a1136 4
	fprintf(fp0,
"<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\"> \
form to permit %s %s.\n</Ol>\n</Form>\n",
		(dir_info.st_mode & S_IFMT) == S_IFDIR ? "directory" : "file",
d1139 1
a1139 1
	fclose(fp0);
d1159 1
a1159 2
	    if (TRACE)
		fprintf(stderr, "permit_location: called for <%s>.\n",
d1174 6
a1179 1
	HTUnEscape(destpath);	/* Will now operate only on filename part. */
d1190 1
a1190 2
	    if (TRACE)
		fprintf(stderr, "permit_location: called for file '%s'.\n",
d1199 2
a1200 10
	if (stat(destpath, &dir_info) == -1) {
	    sprintf(tmpbuf, "Unable to get status of '%s'.", destpath);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
	    return 0;
	} else if ((dir_info.st_mode & S_IFMT) != S_IFDIR &&
	    (dir_info.st_mode & S_IFMT) != S_IFREG) {
	    _statusline(
	"The specified item is not a file nor a directory - request ignored.");
	    sleep(AlertSecs);
d1233 1
a1233 2
		    _statusline("Invalid mode format.");
		    sleep(AlertSecs);
d1237 1
a1237 2
		_statusline("Invalid syntax format.");
		sleep(AlertSecs);
d1248 1
a1248 1
	sprintf(tmpbuf, "chmod %.4o %s", (unsigned int)new_mode, destpath);
d1255 1
d1258 1
d1318 15
d1335 1
a1335 1
 *  Attempt to be consistent.  These are (pseudo) URLs - i.e. they should
d1348 4
a1351 3
    char *cp, *tp, *bp;
    char tmpbuf[256];
    char buffer[512];
d1354 1
a1354 2
    if (TRACE)
	fprintf(stderr, "local_dired: called for <%s>.\n",
d1356 1
a1356 1
		 line_url : "NULL URL pointer"));
a1362 1
    tp = NULL;
d1372 1
d1396 1
d1419 2
a1420 3
	if (line[(strlen(line) - 1)] == '/')
	    line[strlen(line)-1] = '\0';
	if ((cp = strrchr(line, '/')) == NULL) {
a1428 1
	*buffer = '\0';
d1430 4
a1433 3
	    tp = quote_pathname(line + 22);
	    sprintf(buffer,"%s %s", UNCOMPRESS_PATH, tp);
	    FREE(tp);
d1437 5
a1441 6
	    tp = quote_pathname(line + 20);
	    sprintf(buffer,"%s %s", UUDECODE_PATH, tp);
	    _statusline(
      "Warning! UUDecoded file will exist in the directory you started Lynx.");
	    sleep(AlertSecs);
	    FREE(tp);
d1448 7
a1454 7
	    tp = quote_pathname(line+20);
	    *cp++ = '\0';
	    cp = quote_pathname(line + 20);
	    sprintf(buffer, "%s -qdc %s | (cd %s; %s -xf -)",
			    GZIP_PATH, tp, cp, TAR_PATH);
	    FREE(cp);
	    FREE(tp);
d1458 7
a1464 7
	    tp = quote_pathname(line + 19);
	    *cp++ = '\0';
	    cp = quote_pathname(line + 19);
	    sprintf(buffer, "%s %s | (cd %s; %s -xf -)",
			    ZCAT_PATH, tp, cp, TAR_PATH);
	    FREE(cp);
	    FREE(tp);
d1467 6
a1472 6
	    tp = quote_pathname(line + 17);
	    *cp++ = '\0';
	    cp = quote_pathname(line + 17);
	    sprintf(buffer, "cd %s; %s -xf %s", cp, TAR_PATH, tp);
	    FREE(cp);
	    FREE(tp);
d1477 9
a1485 7
	    *cp++ = '\0';
	    cp = quote_pathname(cp);
	    tp = quote_pathname(line + 18);
	    sprintf(buffer, "(cd %s; %s -cf - %s) | %s -qc >%s/%s.tar.gz",
			    tp, TAR_PATH, cp, GZIP_PATH, tp, cp);
	    FREE(cp);
	    FREE(tp);
d1489 9
a1497 7
	    *cp++ = '\0';
	    cp = quote_pathname(cp);
	    tp = quote_pathname(line + 17);
	    sprintf(buffer, "(cd %s; %s -cf - %s) | %s >%s/%s.tar.Z",
			    tp, TAR_PATH, cp, COMPRESS_PATH, tp, cp);
	    FREE(cp);
	    FREE(tp);
d1500 7
a1506 7
	    *cp++ = '\0';
	    cp = quote_pathname(cp);
	    tp = quote_pathname(line + 15);
	    sprintf(buffer, "(cd %s; %s -cf %s.tar %s)",
			    tp, TAR_PATH, cp, cp);
	    FREE(cp);
	    FREE(tp);
d1511 4
a1514 3
	    tp = quote_pathname(line + 16);
	    sprintf(buffer, "%s -q %s", GZIP_PATH, tp);
	    FREE(tp);
d1517 4
a1520 3
	    tp = quote_pathname(line + 18);
	    sprintf(buffer, "%s -d %s", GZIP_PATH, tp);
	    FREE(tp);
d1526 7
a1532 8
	    tp = quote_pathname(line + 15);
	    *cp++ = '\0';
	    bp = quote_pathname(cp);
	    cp = quote_pathname(line + 15);
	    sprintf(buffer, "cd %s; %s -rq %s.zip %s", cp, ZIP_PATH, tp, bp);
	    FREE(cp);
	    FREE(bp);
	    FREE(tp);
d1535 6
a1540 6
	    tp = quote_pathname(line + 17);
	    *cp = '\0';
	    cp = quote_pathname(line + 17);
	    sprintf(buffer, "cd %s; %s -q %s", cp, UNZIP_PATH, tp);
	    FREE(cp);
	    FREE(tp);
d1545 4
a1548 3
	    tp = quote_pathname(line + 20);
	    sprintf(buffer, "%s %s", COMPRESS_PATH, tp);
	    FREE(tp);
d1551 1
a1551 1
	if (strlen(buffer)) {
d1553 1
a1553 1
		sprintf(tmpbuf, "Executing %s ", buffer);
d1555 2
a1556 2
		sprintf(tmpbuf,
			"Executing system command. This might take a while.");
d1561 1
a1561 2
	    fflush(stdout);
	    system(buffer);
a1562 1
	    extern BOOLEAN HadVMSInterrupt
d1570 3
d1574 1
d1586 1
a1586 2
    static char tempfile[256];
    static BOOLEAN first = TRUE;
a1587 1
    char tmpbuf[LINESIZE];
d1592 2
a1593 7
    char *dir_url = NULL;	/* Will hold URL-escaped path of
				   directory from where DIRED_MENU was
				   invoked (NOT its full URL). */
    char *path_url = NULL;	/* Will hold URL-escaped path of file
				   (or directory) which was selected
				   when DIRED_MENU was invoked (NOT
				   its full URL). */
d1599 4
a1602 6

    if (first) {
	/*
	 *  Get an unused tempfile name. - FM
	 */
	tempname(tempfile, NEW_FILE);
d1606 1
a1606 3
     *	Open the tempfile for writing and set its
     *	protection in case this wasn't done via an
     *	external umask. - FM
d1608 2
a1609 15
    if ((fp0 = LYNewTxtFile(tempfile)) == NULL) {
	_statusline("Unable to open file management menu file.");
	sleep(AlertSecs);
	return(0);
    }

    if (first) {
	/*
	 *  Make the tempfile a URL.
	 */
	strcpy(LYDiredFileURL, "file://localhost");
	strcat(LYDiredFileURL, tempfile);
	first = FALSE;
    }
    StrAllocCopy(*newfile, LYDiredFileURL);
d1611 1
a1611 6
    cp = doc->address;
    if (!strncmp(cp, "file://localhost", 16)) {
	cp += 16;
    } else if (!strncmp(cp, "file:", 5)) {
	cp += 5;
    }
d1613 2
a1614 6
    StrAllocCopy(dir_url, cp);
    if (dir_url[(strlen(dir_url) - 1)] == '/')
	dir_url[(strlen(dir_url) - 1)] = '\0';
    HTUnEscape(dir);
    if (dir[(strlen(dir) - 1)] == '/')
	dir[(strlen(dir) - 1)] = '\0';
d1617 1
a1617 6
	cp = links[doc->link].lname;
	if (!strncmp(cp, "file://localhost", 16)) {
	    cp += 16;
	} else if (!strncmp(cp, "file:", 5)) {
	    cp += 5;
	}
d1619 2
a1620 6
	StrAllocCopy(path_url, cp);
	if (*path_url && path_url[1] && path_url[(strlen(path_url) - 1)] == '/')
	    path_url[(strlen(path_url) - 1)] = '\0';
	HTUnEscape(path);
	if (*path && path[1] && path[(strlen(path) - 1)] == '/')
	    path[(strlen(path) - 1)] = '\0';
d1622 2
a1623 6
	if (lstat(path, &dir_info) == -1 && stat(path, &dir_info) == -1) {
	    sprintf(tmpbuf, "Unable to get status of '%s'.", path);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
	    FREE(dir_url);
	    FREE(path_url);
a1628 1
	StrAllocCopy(path_url, path);
d1633 1
a1633 2
    fprintf(fp0,
	    "<head>\n<title>%s</title></head>\n<body>\n", DIRED_MENU_TITLE);
d1635 1
a1635 5
    fprintf(fp0,
	    "\n<h1>File Management Options (%s Version %s)</h1>",
	    LYNX_NAME, LYNX_VERSION);

    fprintf(fp0, "Current directory is %s<br>\n", dir);
d1638 1
d1640 1
a1640 1
	    fprintf(fp0, "Current selection is %s<p>\n", path);
d1642 1
a1642 1
	    fprintf(fp0, "Nothing currently selected.<p>\n");
d1655 3
a1657 2
	fprintf(fp0, "Current selection is %d tagged item%s",
		     n, ((n == 1) ? ":" : "s:"));
d1660 1
a1660 2
	if (*cd && cd[(strlen(cd) - 1)] != '/')
	    StrAllocCat(cd, "/");
d1667 1
a1667 1
	    fprintf(fp0, "%s <br>\n &nbsp;&nbsp;&nbsp;%s",
d1694 1
a1694 1
	    (!*path || (dir_info.st_mode & S_IFMT) != S_IFDIR))
d1697 1
a1697 1
	    (!*path || (dir_info.st_mode & S_IFMT) != S_IFREG))
d1701 1
a1701 1
	    (!*path || (dir_info.st_mode & S_IFMT) != S_IFLNK))
d1708 2
d1711 1
a1711 1
		render_item(mp->href, path_url, dir_url, buf,2048, YES));
d1713 1
a1713 1
		render_item(mp->link, path, dir, buf,2048, NO));
d1715 3
a1717 1
		render_item(mp->rest, path, dir, buf,2048, NO));
d1731 2
a1732 5
    fprintf(fp0, "</body>\n");
    fclose(fp0);

    FREE(dir_url);
    FREE(path_url);
d1742 1
a1742 1
PRIVATE char *filename ARGS3(
d1745 1
a1745 1
	size_t,		bufsize)
d1754 1
a1754 2
	_statusline("Illegal filename; request ignored.");
	sleep(AlertSecs);
d1765 1
a1765 2
	    _statusline("Illegal filename; request ignored.");
	    sleep(AlertSecs);
d1780 2
a1781 3
    char tmpbuf[512];
    static char savepath[512]; /* This will be the link that
				  is to be installed. */
d1792 1
a1792 7
	srcpath = strip_trailing_slash(srcpath);
	if (strncmp(srcpath, "file://localhost", 16) == 0)
	    srcpath += 16;
	if (stat(srcpath, &dir_info) == -1) {
	    sprintf(tmpbuf, "Unable to get status of '%s'.", srcpath);
	    _statusline(tmpbuf);
	    sleep(AlertSecs);
d1794 1
a1794 8
	} else if ((dir_info.st_mode & S_IFMT) != S_IFDIR &&
		   (dir_info.st_mode & S_IFMT) != S_IFREG) {
	    _statusline(
	  "The selected item is not a file or a directory! Request ignored.");
	    sleep(AlertSecs);
	    return 0;
	}
	strcpy(savepath, srcpath);
d1796 2
a1797 4
	strcpy(tmpbuf, "file://localhost");
	strcat(tmpbuf, Home_Dir());
	strcat(tmpbuf, "/.installdirs.html");
	StrAllocCopy(*newpath, tmpbuf);
d1803 1
a1803 4
    if (stat(destpath,&dir_info) == -1) {
	sprintf(tmpbuf,"Unable to get status of '%s'.",destpath);
	_statusline(tmpbuf);
	sleep(AlertSecs);
d1805 2
a1806 4
    } else if ((dir_info.st_mode & S_IFMT) != S_IFDIR) {
	_statusline(
		"The selected item is not a directory! Request ignored.");
	sleep(AlertSecs);
d1808 2
a1809 3
    } else if (0 /*directory not writeable*/) {
	_statusline("Install in the selected directory not permitted.");
	sleep(AlertSecs);
d1813 1
a1813 1
    statusline("Just a moment, ...");
d1821 1
a1821 1
    sprintf(tmpbuf, "install %s", destpath);
d1832 5
a1836 5
	    args[src] = name;
	    if (strncmp("file://localhost", args[src], 16) == 0)
		 args[src] = (name + 16);

	    if (LYExecv(INSTALL_PATH, args, tmpbuf) <= 0)
d1842 2
a1843 2
    statusline("Installation complete");
    sleep(InfoSecs);
d1878 2
d1928 1
a1928 1
	char *, 	s,
a1948 11
#ifdef NOTDEFINED
		    /*
		     *	These chars come from lynx.cfg or the default, let's
		     *	just assume there won't be any improper %'s there that
		     *	would need escaping.
		     */
		    if(url_syntax) {
			*BP_INC = '2';
			*BP_INC = '5';
		    }
#endif /* NOTDEFINED */
d1952 2
d1959 2
a1998 6
#ifdef NOTDEFINED
		    if (url_syntax) {
			*BP_INC = '2';
			*BP_INC = '5';
		    }
#endif /* NOTDEFINED */
d2005 1
a2005 1
	     *	the default. Let's assume there isn't
d2013 2
a2014 3
	sprintf(buf,"Temporary URL or list would be too long.");
	_statusline(buf);
	sleep(AlertSecs);
d2031 1
a2031 3
    if (TRACE) {
	fprintf(stderr, "LYExecv:  Called inappropriately!\n");
    }
d2035 1
a2035 1
    char tmpbuf[512];
d2037 1
a2037 1
#if HAVE_TYPE_UNIONWAIT
d2043 7
a2050 1
    tmpbuf[0] = '\0';	/* empty buffer for alert messages */
d2055 1
a2055 1
	    sprintf(tmpbuf, "Unable to %s due to system error!", msg);
d2059 3
d2063 1
d2084 2
a2085 2
		sprintf(tmpbuf, "Probable failure to %s due to system error!",
				msg);
d2098 3
a2100 3
    if (tmpbuf[0]) {
	_statusline(tmpbuf);
	sleep(AlertSecs);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
