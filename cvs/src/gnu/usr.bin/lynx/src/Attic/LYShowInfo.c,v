head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.12;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYShowInfo.c,v 1.76 2013/10/03 01:01:34 tom Exp $ */
#include <HTUtils.h>
#include <HTFile.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <HTTP.h>
#include <LYCurses.h>
#include <LYUtils.h>
#include <LYStructs.h>
#include <LYGlobalDefs.h>
#include <LYShowInfo.h>
#include <LYCharUtils.h>
#include <GridText.h>
#include <LYReadCFG.h>
#include <LYCharSets.h>
#include <LYStrings.h>

#include <LYLeaks.h>

#ifdef DIRED_SUPPORT
#include <HTAAProt.h>
#include <time.h>
#include <LYLocal.h>
#endif /* DIRED_SUPPORT */

#define ADVANCED_INFO 1		/* to get more info in advanced mode */

#define BEGIN_DL(text) fprintf(fp0, "<h2>%s</h2>\n<dl compact>", LYEntifyTitle(&buffer, text))
#define END_DL()       fprintf(fp0, "\n</dl>\n")

#define ADD_SS(label,value)       dt_String(fp0, label, value)
#define ADD_NN(label,value,units) dt_Number(fp0, label, (long) value, units)

static int label_columns;

/*
 * LYNX_VERSION and LYNX_DATE are automatically generated by PRCS, the tool
 * which we use to archive versions of Lynx.  We use a convention for naming
 * the successive versions:
 *	{release}{status}{patch}
 * where
 *	{release} is the release that we are working on, e.g., 2.8.4
 *	{status} is one of "dev", "pre" or "rel", and
 *	{patch} is a number assigned by PRCS.
 */
BOOL LYVersionIsRelease(void)
{
    return (BOOL) (strstr(LYNX_VERSION, "rel") != 0);
}

const char *LYVersionStatus(void)
{
    if (LYVersionIsRelease())
	return REL_VERSION;
    else if (strstr(LYNX_VERSION, "pre") != 0)
	return PRE_VERSION;
    return DEV_VERSION;
}

const char *LYVersionDate(void)
{
    static char temp[LYNX_DATE_LEN + 1];

    LYStrNCpy(temp, &LYNX_DATE[LYNX_DATE_OFF], LYNX_DATE_LEN);
    return temp;
}

static void dt_String(FILE *fp,
		      const char *label,
		      const char *value)
{
    int have;
    int need;
    char *the_label = 0;
    char *the_value = 0;

    StrAllocCopy(the_label, label);
    StrAllocCopy(the_value, value);

    have = (int) strlen(the_label);
    need = LYstrExtent(the_label, have, label_columns);

    LYEntify(&the_label, TRUE);
    LYEntify(&the_value, TRUE);

    fprintf(fp, "<dt>");
    while (need++ < label_columns)
	fprintf(fp, "&nbsp;");
    fprintf(fp, "<em>%s</em> %s\n", the_label, the_value);

    FREE(the_label);
    FREE(the_value);
}

static void dt_Number(FILE *fp0,
		      const char *label,
		      long number,
		      const char *units)
{
    char *value = NULL;
    char *buffer = NULL;

    HTSprintf(&value, "%ld %s", number, LYEntifyTitle(&buffer, units));
    ADD_SS(label, value);
    FREE(value);
    FREE(buffer);
}

static void dt_URL(FILE *fp0, const char *address)
{
    ADD_SS(gettext("URL:"), address);

    /*
     * If the display handles UTF-8, and if the address uses %xy formatted
     * characters, show the decoded URL on the next line.
     */
    if (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	char *working = 0;

	StrAllocCopy(working, address);
	if (strcmp(HTUnEscape(working), address)) {
	    fprintf(fp0, "\n<br>%s\n", working);
	}
	free(working);
    }
}

/*
 * LYShowInfo prints a page of info about the current file and the link that
 * the cursor is on.
 */
int LYShowInfo(DocInfo *doc,
	       DocInfo *newdoc,
	       char *owner_address)
{
    static char tempfile[LY_MAXPATH] = "\0";

    int url_type;
    FILE *fp0;
    char *Title = NULL;
    const char *cp;
    char *temp = 0;
    char *buffer = 0;

#ifdef ADVANCED_INFO
    BOOLEAN LYInfoAdvanced = (BOOL) (user_mode == ADVANCED_MODE);
#endif
#ifdef DIRED_SUPPORT
    struct stat dir_info;
    const char *name;
#endif /* DIRED_SUPPORT */

    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(tempfile, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(tempfile);
	fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
	return (-1);
    }

    /*
     * Point the address pointer at this Url
     */
    LYLocalFileToURL(&newdoc->address, tempfile);

    if (nlinks > 0 && links[doc->link].lname != NULL &&
	(url_type = is_url(links[doc->link].lname)) != 0 &&
	(url_type == LYNXEXEC_URL_TYPE ||
	 url_type == LYNXPROG_URL_TYPE)) {
	char *last_slash = strrchr(links[doc->link].lname, '/');
	int next_to_last = (int) strlen(links[doc->link].lname) - 1;

	if ((last_slash - links[doc->link].lname) == next_to_last) {
	    links[doc->link].lname[next_to_last] = '\0';
	}
    }

    label_columns = 9;

    WriteInternalTitle(fp0, SHOWINFO_TITLE);

    fprintf(fp0, "<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",
	    LYNX_NAME, LYNX_VERSION,
	    LYVersionDate(),
	    (LYVersionIsRelease()? LYNX_WWW_HOME : LYNX_WWW_DIST),
	    LYVersionStatus());

    fprintf(fp0, "</h1>\n");	/* don't forget to close <h1> */

#ifdef DIRED_SUPPORT
    if (lynx_edit_mode && nlinks > 0) {

	BEGIN_DL(gettext("Directory that you are currently viewing"));

	temp = HTfullURL_toFile(doc->address);
	ADD_SS(gettext("Name:"), temp);
	FREE(temp);

	dt_URL(fp0, doc->address);

	END_DL();

	temp = HTfullURL_toFile(links[doc->link].lname);

	if (lstat(temp, &dir_info) == -1) {
	    CTRACE((tfp, "lstat(%s) failed, errno=%d\n", temp, errno));
	    HTAlert(CURRENT_LINK_STATUS_FAILED);
	} else {
	    char modes[80];

	    label_columns = 16;
	    if (S_ISDIR(dir_info.st_mode)) {
		BEGIN_DL(gettext("Directory that you have currently selected"));
	    } else if (S_ISREG(dir_info.st_mode)) {
		BEGIN_DL(gettext("File that you have currently selected"));
#ifdef S_IFLNK
	    } else if (S_ISLNK(dir_info.st_mode)) {
		BEGIN_DL(gettext("Symbolic link that you have currently selected"));
#endif
	    } else {
		BEGIN_DL(gettext("Item that you have currently selected"));
	    }
	    ADD_SS(gettext("Full name:"), temp);
#ifdef S_IFLNK
	    if (S_ISLNK(dir_info.st_mode)) {
		char buf[MAX_LINE];
		int buf_size;
		size_t limit = sizeof(buf) - 1;

		if ((buf_size = (int) readlink(temp, buf, limit)) != -1) {
		    if (buf_size > (int) limit)
			buf_size = (int) limit;
		    buf[buf_size] = '\0';
		} else {
		    sprintf(buf, "%.*s", (int) limit,
			    gettext("Unable to follow link"));
		}
		ADD_SS(gettext("Points to file:"), buf);
	    }
#endif
	    name = HTAA_UidToName((int) dir_info.st_uid);
	    if (*name)
		ADD_SS(gettext("Name of owner:"), name);
	    name = HTAA_GidToName((int) dir_info.st_gid);
	    if (*name)
		ADD_SS(gettext("Group name:"), name);
	    if (S_ISREG(dir_info.st_mode)) {
		ADD_NN(gettext("File size:"),
		       (long) dir_info.st_size,
		       gettext("(bytes)"));
	    }
	    /*
	     * Include date and time information.
	     */
	    ADD_SS(gettext("Creation date:"),
		   ctime(&dir_info.st_ctime));

	    ADD_SS(gettext("Last modified:"),
		   ctime(&dir_info.st_mtime));

	    ADD_SS(gettext("Last accessed:"),
		   ctime(&dir_info.st_atime));

	    END_DL();

	    label_columns = 9;
	    BEGIN_DL(gettext("Access Permissions"));
	    modes[0] = '\0';
	    modes[1] = '\0';	/* In case there are no permissions */
	    modes[2] = '\0';
	    if ((dir_info.st_mode & S_IRUSR))
		strcat(modes, ", read");
	    if ((dir_info.st_mode & S_IWUSR))
		strcat(modes, ", write");
	    if ((dir_info.st_mode & S_IXUSR)) {
		if (S_ISDIR(dir_info.st_mode))
		    strcat(modes, ", search");
		else {
		    strcat(modes, ", execute");
		    if ((dir_info.st_mode & S_ISUID))
			strcat(modes, ", setuid");
		}
	    }
	    ADD_SS(gettext("Owner:"), &modes[2]);

	    modes[0] = '\0';
	    modes[1] = '\0';	/* In case there are no permissions */
	    modes[2] = '\0';
	    if ((dir_info.st_mode & S_IRGRP))
		strcat(modes, ", read");
	    if ((dir_info.st_mode & S_IWGRP))
		strcat(modes, ", write");
	    if ((dir_info.st_mode & S_IXGRP)) {
		if (S_ISDIR(dir_info.st_mode))
		    strcat(modes, ", search");
		else {
		    strcat(modes, ", execute");
		    if ((dir_info.st_mode & S_ISGID))
			strcat(modes, ", setgid");
		}
	    }
	    ADD_SS(gettext("Group:"), &modes[2]);

	    modes[0] = '\0';
	    modes[1] = '\0';	/* In case there are no permissions */
	    modes[2] = '\0';
	    if ((dir_info.st_mode & S_IROTH))
		strcat(modes, ", read");
	    if ((dir_info.st_mode & S_IWOTH))
		strcat(modes, ", write");
	    if ((dir_info.st_mode & S_IXOTH)) {
		if (S_ISDIR(dir_info.st_mode))
		    strcat(modes, ", search");
		else {
		    strcat(modes, ", execute");
#ifdef S_ISVTX
		    if ((dir_info.st_mode & S_ISVTX))
			strcat(modes, ", sticky");
#endif
		}
	    }
	    ADD_SS(gettext("World:"), &modes[2]);
	    END_DL();
	}
	FREE(temp);
    } else {
#endif /* DIRED_SUPPORT */

	BEGIN_DL(gettext("File that you are currently viewing"));

	LYformTitle(&Title, doc->title);
	HTSprintf(&temp, "%s%s",
		  LYEntifyTitle(&buffer, Title),
		  ((doc->isHEAD &&
		    !strstr(Title, " (HEAD)") &&
		    !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));
	ADD_SS(gettext("Linkname:"), temp);
	FREE(temp);

	dt_URL(fp0, doc->address);

	if (HTLoadedDocumentCharset()) {
	    ADD_SS(gettext("Charset:"),
		   HTLoadedDocumentCharset());
	} else {
	    LYUCcharset *p_in = HTAnchor_getUCInfoStage(HTMainAnchor,
							UCT_STAGE_PARSER);

	    if (!p_in || isEmpty(p_in->MIMEname) ||
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_PARSER) < 0) {
		p_in = HTAnchor_getUCInfoStage(HTMainAnchor, UCT_STAGE_MIME);
	    }
	    if (p_in && non_empty(p_in->MIMEname) &&
		HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_MIME) >= 0) {
		HTSprintf(&temp, "%s %s",
			  LYEntifyTitle(&buffer, p_in->MIMEname),
			  gettext("(assumed)"));
		ADD_SS(gettext("Charset:"), p_in->MIMEname);
		FREE(temp);
	    }
	}

	if ((cp = HText_getServer()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Server:"), cp);

	if ((cp = HText_getDate()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Date:"), cp);

	if ((cp = HText_getLastModified()) != NULL && *cp != '\0')
	    ADD_SS(gettext("Last Mod:"), cp);

#ifdef ADVANCED_INFO
	if (LYInfoAdvanced) {
	    if (HTMainAnchor && HTMainAnchor->expires) {
		ADD_SS(gettext("Expires:"), HTMainAnchor->expires);
	    }
	    if (HTMainAnchor && HTMainAnchor->cache_control) {
		ADD_SS(gettext("Cache-Control:"), HTMainAnchor->cache_control);
	    }
	    if (HTMainAnchor && HTMainAnchor->content_length > 0) {
		ADD_NN(gettext("Content-Length:"),
		       HTMainAnchor->content_length,
		       gettext("bytes"));
	    } else {
		ADD_NN(gettext("Length:"),
		       HText_getNumOfBytes(),
		       gettext("bytes"));
	    }
	    if (HTMainAnchor && HTMainAnchor->content_language) {
		ADD_SS(gettext("Language:"), HTMainAnchor->content_language);
	    }
	}
#endif /* ADVANCED_INFO */

	if (doc->post_data) {
	    fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		    LYEntifyTitle(&buffer, gettext("Post Data:")),
		    BStrLen(doc->post_data),
		    BStrData(doc->post_data));
	    ADD_SS(gettext("Post Content Type:"), doc->post_content_type);
	}

	ADD_SS(gettext("Owner(s):"),
	       (owner_address
		? owner_address
		: NO_NOTHING));

	ADD_NN(gettext("size:"),
	       HText_getNumOfLines(),
	       gettext("lines"));

	StrAllocCopy(temp,
		     ((lynx_mode == FORMS_LYNX_MODE)
		      ? gettext("forms mode")
		      : (HTisDocumentSource()
			 ? gettext("source")
			 : gettext("normal"))));
	if (doc->safe)
	    StrAllocCat(temp, gettext(", safe"));
	if (doc->internal_link)
	    StrAllocCat(temp, gettext(", via internal link"));

#ifdef ADVANCED_INFO
	if (LYInfoAdvanced) {
	    if (HText_hasNoCacheSet(HTMainText))
		StrAllocCat(temp, gettext(", no-cache"));
	    if (HTAnchor_isISMAPScript((HTAnchor *) HTMainAnchor))
		StrAllocCat(temp, gettext(", ISMAP script"));
	    if (doc->bookmark)
		StrAllocCat(temp, gettext(", bookmark file"));
	}
#endif /* ADVANCED_INFO */

	ADD_SS(gettext("mode:"), temp);
	FREE(temp);

	END_DL();

	if (nlinks > 0) {
	    BEGIN_DL(gettext("Link that you currently have selected"));
	    ADD_SS(gettext("Linkname:"),
		   LYGetHiliteStr(doc->link, 0));
	    if (lynx_mode == FORMS_LYNX_MODE &&
		links[doc->link].type == WWW_FORM_LINK_TYPE) {
		if (links[doc->link].l_form->submit_method) {
		    int method = links[doc->link].l_form->submit_method;
		    char *enctype = links[doc->link].l_form->submit_enctype;

		    ADD_SS(gettext("Method:"),
			   ((method == URL_POST_METHOD) ? "POST" :
			    ((method == URL_MAIL_METHOD) ? "(email)" :
			     "GET")));
		    ADD_SS(gettext("Enctype:"),
			   (non_empty(enctype)
			    ? enctype
			    : "application/x-www-form-urlencoded"));
		}
		if (links[doc->link].l_form->submit_action) {
		    ADD_SS(gettext("Action:"),
			   links[doc->link].l_form->submit_action);
		}
		if (!(links[doc->link].l_form->submit_method &&
		      links[doc->link].l_form->submit_action)) {
		    fprintf(fp0, "<dt>&nbsp;%s\n",
			    LYEntifyTitle(&buffer, gettext("(Form field)")));
		}
	    } else {
		dt_URL(fp0, NonNull(links[doc->link].lname));
	    }
	    END_DL();

	} else {
	    fprintf(fp0, "<h2>%s</h2>",
		    LYEntifyTitle(&buffer,
				  gettext("No Links on the current page")));
	}

#ifdef EXP_HTTP_HEADERS
	if ((cp = HText_getHttpHeaders()) != 0) {
	    fprintf(fp0, "<h2>%s</h2>",
		    LYEntifyTitle(&buffer, gettext("Server Headers:")));
	    fprintf(fp0, "<pre>%s</pre>",
		    LYEntifyTitle(&buffer, cp));
	}
#endif

#ifdef DIRED_SUPPORT
    }
#endif /* DIRED_SUPPORT */
    EndInternalPage(fp0);

    LYrefresh();

    LYCloseTemp(tempfile);
    FREE(Title);
    FREE(buffer);

    return (0);
}
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYShowInfo.c,v 1.69 2009/01/19 23:42:23 tom Exp $ */
d32 1
a32 1
#define ADD_NN(label,value,units) dt_Number(fp0, label, value, units)
d64 1
a64 1
    LYstrncpy(temp, &LYNX_DATE[LYNX_DATE_OFF], LYNX_DATE_LEN);
d109 19
d202 1
a202 1
	ADD_SS(gettext("URL:"), doc->address);
d231 1
d233 3
a235 1
		if ((buf_size = readlink(temp, buf, sizeof(buf) - 1)) != -1) {
d238 1
a238 1
		    sprintf(buf, "%.*s", (int) sizeof(buf) - 1,
d343 1
a343 1
	ADD_SS("URL:", doc->address);
d471 1
a471 2
		ADD_SS("URL:",
		       NonNull(links[doc->link].lname));
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d28 1
a28 1
#define BEGIN_DL(text) fprintf(fp0, "<h2>%s</h2>\n<dl compact>", text)
d80 1
a80 1
    have = strlen(the_label);
d101 1
d103 1
a103 1
    HTSprintf(&value, "%ld %s", number, units);
d106 1
d118 1
a121 1
    const char *name;
d124 1
d131 1
d155 1
a155 1
	int next_to_last = strlen(links[doc->link].lname) - 1;
d210 1
a210 1
		char buf[1025];
d216 2
a217 1
		    sprintf(buf, "%.1024s", gettext("Unable to follow link"));
d222 1
a222 1
	    name = HTAA_UidToName(dir_info.st_uid);
d225 1
a225 1
	    name = HTAA_GidToName(dir_info.st_gid);
d314 1
a314 1
		  Title,
d337 1
a337 1
			  p_in->MIMEname,
d378 1
a378 1
		    gettext("Post Data:"),
d445 2
a446 1
		    fprintf(fp0, "<dt>&nbsp;%s\n", gettext("(Form field)"));
d455 3
a457 1
	    fprintf(fp0, "<h2>%s</h2>", gettext("No Links on the current page"));
d462 4
a465 2
	    fprintf(fp0, "<h2>%s</h2>", gettext("Server Headers:"));
	    fprintf(fp0, "<pre>%s</pre>", cp);
d478 1
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d27 8
d45 1
a45 1
PUBLIC BOOL LYVersionIsRelease NOARGS
d47 1
a47 1
    return (BOOL)(strstr(LYNX_VERSION, "rel") != 0);
d50 1
a50 1
PUBLIC char *LYVersionStatus NOARGS
d59 1
a59 1
PUBLIC char *LYVersionDate NOARGS
d61 2
a62 1
    static char temp[LYNX_DATE_LEN+1];
d67 39
d107 2
a108 2
 *  LYShowInfo prints a page of info about the current file and the link
 *  that the cursor is on.
d110 3
a112 6

PUBLIC int LYShowInfo ARGS4(
	DocInfo *,	doc,
	int,		size_of_file,
	DocInfo *,	newdoc,
	char *, 	owner_address)
d117 5
a121 3
    char *Address = NULL, *Title = NULL;
    char *name;
    CONST char *cp;
d137 1
a137 1
	return(-1);
d141 1
a141 1
     *	Point the address pointer at this Url
d149 1
a149 1
	char *last_slash = strrchr(links[doc->link].lname,'/');
d157 3
a159 4
    fprintf(fp0, "<html>\n<head>\n");
    LYAddMETAcharsetToFD(fp0, -1);
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n",
		 SHOWINFO_TITLE);
d162 4
a165 6
		 LYNX_NAME, LYNX_VERSION,
		 LYVersionDate(),
		 (LYVersionIsRelease() ? LYNX_WWW_HOME     : LYNX_WWW_DIST),
		 LYVersionStatus());

    fprintf(fp0, "</h1>\n");  /* don't forget to close <h1> */
d167 1
a170 1
	char *temp;
d172 1
a172 2
	fprintf(fp0, "<pre>\n");
	fprintf(fp0, "\n%s\n\n", gettext("Directory that you are currently viewing"));
d175 1
a175 1
	fprintf(fp0, "   <em>%4s</em>  %s\n", gettext("Name:"), temp);
d178 3
a180 1
	fprintf(fp0, "   <em>%4s</em>  %s\n", gettext("URL:"), doc->address);
d189 2
d192 1
a192 2
		fprintf(fp0, "\n%s\n\n",
			gettext("Directory that you have currently selected"));
d194 1
a194 2
		fprintf(fp0, "\n%s\n\n",
			gettext("File that you have currently selected"));
d197 1
a197 2
		fprintf(fp0, "\n%s\n\n",
			gettext("Symbolic link that you have currently selected"));
d200 1
a200 2
		fprintf(fp0, "\n%s\n\n",
			gettext("Item that you have currently selected"));
d202 1
a202 1
	    fprintf(fp0, "       <em>%s</em>  %s\n", gettext("Full name:"), temp);
d208 1
a208 1
		if ((buf_size = readlink(temp, buf, sizeof(buf)-1)) != -1) {
d213 1
a213 1
		fprintf(fp0, "  <em>%s</em>  %s\n", gettext("Points to file:"), buf);
d218 2
a219 2
		fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Name of owner:"), name);
	    name = HTAA_GidToName (dir_info.st_gid);
d221 1
a221 1
		fprintf(fp0, "      <em>%s</em>  %s\n", gettext("Group name:"), name);
d223 3
a225 2
		fprintf(fp0, "       <em>%s</em>  %ld (bytes)\n",
			gettext("File size:"), (long)dir_info.st_size);
d228 1
a228 1
	     *	Include date and time information.
d230 2
a231 2
	    cp = ctime(&dir_info.st_ctime);
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Creation date:"), cp);
d233 2
a234 2
	    cp = ctime(&dir_info.st_mtime);
	    fprintf(fp0, "   <em>%s</em>  %s", gettext("Last modified:"), cp);
d236 2
a237 2
	    cp = ctime(&dir_info.st_atime);
	    fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Last accessed:"), cp);
d239 4
a242 2
	    fprintf(fp0, "   %s\n", gettext("Access Permissions"));
	    fprintf(fp0, "      <em>%s</em>  ", gettext("Owner:"));
d244 1
a244 1
	    modes[1] = '\0';   /* In case there are no permissions */
d259 1
a259 1
	    fprintf(fp0, "%s\n", (char *)&modes[2]); /* Skip leading ', ' */
a260 1
	    fprintf(fp0, "      <em>Group:</em>  ");
d262 1
a262 1
	    modes[1] = '\0';   /* In case there are no permissions */
d277 1
a277 1
	    fprintf(fp0, "%s\n", (char *)&modes[2]);  /* Skip leading ', ' */
a278 1
	    fprintf(fp0, "      <em>World:</em>  ");
d280 1
a280 1
	    modes[1] = '\0';   /* In case there are no permissions */
d297 2
a298 1
	    fprintf(fp0, "%s\n", (char *)&modes[2]);  /* Skip leading ', ' */
a300 1
	fprintf(fp0,"</pre>\n");
d304 19
a322 2
    fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
	    gettext("File that you are currently viewing"));
d324 13
a336 32
    LYformTitle(&Title, doc->title);
    LYEntify(&Title, TRUE);
    fprintf(fp0, "<dt><em>%s</em> %s%s\n",
		 gettext("Linkname:"),
		 Title,
		 ((doc->isHEAD &&
		   !strstr(Title, " (HEAD)") &&
		   !strstr(Title, " - HEAD")) ? " (HEAD)" : ""));

    StrAllocCopy(Address, doc->address);
    LYEntify(&Address, TRUE);
    fprintf(fp0,
	    "<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Address);

    if (HTLoadedDocumentCharset()) {
	fprintf(fp0, "<dt><em>&nbsp;%s</em> %s\n",
		     gettext("Charset:"),
		     HTLoadedDocumentCharset());
    } else {
      LYUCcharset * p_in = HTAnchor_getUCInfoStage(HTMainAnchor,
							     UCT_STAGE_PARSER);
      if (!p_in || isEmpty(p_in->MIMEname) ||
	   HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_PARSER) < 0) {
	   p_in = HTAnchor_getUCInfoStage(HTMainAnchor, UCT_STAGE_MIME);
      }
      if (p_in && p_in->MIMEname && *(p_in->MIMEname) &&
	  HTAnchor_getUCLYhndl(HTMainAnchor, UCT_STAGE_MIME) >= 0) {
	fprintf(fp0, "<dt><em>&nbsp;%s</em> %s (assumed)\n",
		     gettext("Charset:"),
		     p_in->MIMEname);
      }
    }
d338 2
a339 2
    if ((cp = HText_getServer()) != NULL && *cp != '\0')
	fprintf(fp0, "<dt><em>&nbsp;&nbsp;%s</em> %s\n", gettext("Server:"), cp);
d341 2
a342 2
    if ((cp = HText_getDate()) != NULL && *cp != '\0')
	fprintf(fp0, "<dt><em>&nbsp;&nbsp;&nbsp;&nbsp;%s</em> %s\n", gettext("Date:"), cp);
d344 2
a345 2
    if ((cp = HText_getLastModified()) != NULL && *cp != '\0')
	fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Last Mod:"), cp);
d348 19
a366 8
    if (LYInfoAdvanced) {
	if (HTMainAnchor && HTMainAnchor->expires) {
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("&nbsp;Expires:"), HTMainAnchor->expires);
	}
	if (HTMainAnchor && HTMainAnchor->cache_control) {
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Cache-Control:"), HTMainAnchor->cache_control);
a367 10
	if (HTMainAnchor && HTMainAnchor->content_length > 0) {
	    fprintf(fp0, "<dt><em>%s</em> %d %s\n",
		    gettext("Content-Length:"),
		    HTMainAnchor->content_length, gettext("bytes"));
	}
	if (HTMainAnchor && HTMainAnchor->content_language) {
	    fprintf(fp0, "<dt><em>%s</em> %s\n",
		    gettext("Language:"), HTMainAnchor->content_language);
	}
    }
d370 7
a376 16
    if (doc->post_data) {
	fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n",
		gettext("Post Data:"),
		BStrLen(doc->post_data),
		BStrData(doc->post_data));
	fprintf(fp0, "<dt><em>%s</em> %s\n",
		gettext("Post Content Type:"), doc->post_content_type);
    }

    if (owner_address) {
	StrAllocCopy(Address, owner_address);
	LYEntify(&Address, TRUE);
    } else {
	StrAllocCopy(Address, NO_NOTHING);
    }
    fprintf(fp0, "<dt><em>%s</em> %s\n", gettext("Owner(s):"), Address);
d378 19
a396 2
    fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %d %s\n",
	    gettext("size:"), size_of_file, gettext("lines"));
a397 9
    fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>%s</em> %s%s%s",
		 gettext("mode:"),
		 (lynx_mode == FORMS_LYNX_MODE ?
				  gettext("forms mode") :
		  HTisDocumentSource() ?
				  gettext("source") : gettext("normal")),
		 (doc->safe ? gettext(", safe") : ""),
		 (doc->internal_link ? gettext(", via internal link") : "")
	    );
d399 8
a406 10
    if (LYInfoAdvanced) {
	fprintf(fp0, "%s%s%s\n",
		(HText_hasNoCacheSet(HTMainText) ?
				  gettext(", no-cache") : ""),
		(HTAnchor_isISMAPScript((HTAnchor *)HTMainAnchor) ?
				  gettext(", ISMAP script") : ""),
		(doc->bookmark ?
				  gettext(", bookmark file") : "")
	    );
    }
d409 2
a410 1
    fprintf(fp0, "\n</dl>\n");  /* end of list */
d412 32
a443 33
    if (nlinks > 0) {
	fprintf(fp0, "<h2>%s</h2>\n<dl compact>",
		gettext("Link that you currently have selected"));
	StrAllocCopy(Title, LYGetHiliteStr(doc->link, 0));
	LYEntify(&Title, TRUE);
	fprintf(fp0, "<dt><em>%s</em> %s\n",
		gettext("Linkname:"),
		Title);
	if (lynx_mode == FORMS_LYNX_MODE &&
	    links[doc->link].type == WWW_FORM_LINK_TYPE) {
	    if (links[doc->link].l_form->submit_method) {
		int method = links[doc->link].l_form->submit_method;
		char *enctype = links[doc->link].l_form->submit_enctype;

		fprintf(fp0, "<dt>&nbsp;&nbsp;<em>%s</em> %s\n",
			     gettext("Method:"),
			     (method == URL_POST_METHOD) ? "POST" :
			     (method == URL_MAIL_METHOD) ? "(email)" :
							   "GET");
		fprintf(fp0, "<dt>&nbsp;<em>%s</em> %s\n",
			     gettext("Enctype:"),
			     (enctype &&
			      *enctype ?
			       enctype : "application/x-www-form-urlencoded"));
	    }
	    if (links[doc->link].l_form->submit_action) {
		StrAllocCopy(Address, links[doc->link].l_form->submit_action);
		LYEntify(&Address, TRUE);
		fprintf(fp0, "<dt>&nbsp;&nbsp;<em>Action:</em> %s\n", Address);
	    }
	    if (!(links[doc->link].l_form->submit_method &&
		  links[doc->link].l_form->submit_action)) {
		fprintf(fp0, "<dt>&nbsp;%s\n", gettext("(Form field)"));
d445 2
d448 1
a448 8
	    if (links[doc->link].lname) {
		StrAllocCopy(Title, links[doc->link].lname);
		LYEntify(&Title, TRUE);
	    } else {
		StrAllocCopy(Title, "");
	    }
	    fprintf(fp0,
	       "<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Title);
a449 1
	fprintf(fp0, "</dl>\n");  /* end of list */
d451 6
a456 2
    } else
	fprintf(fp0, "<h2>%s</h2>", gettext("No Links on the current page"));
a465 1
    FREE(Address);
d468 1
a468 1
    return(0);
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d64 1
a64 1
	document *,	doc,
d66 1
a66 1
	document *,	newdoc,
d284 1
a284 1
      if (!p_in || !(p_in->MIMEname) || !*(p_in->MIMEname) ||
d328 4
a331 2
	fprintf(fp0, "<dt><em>%s</em> <xmp>%s</xmp>\n",
		gettext("Post Data:"), doc->post_data);
d374 1
a374 1
	StrAllocCopy(Title, links[doc->link].hightext);
d381 3
a383 3
	    if (links[doc->link].form->submit_method) {
		int method = links[doc->link].form->submit_method;
		char *enctype = links[doc->link].form->submit_enctype;
d396 2
a397 2
	    if (links[doc->link].form->submit_action) {
		StrAllocCopy(Address, links[doc->link].form->submit_action);
d401 2
a402 2
	    if (!(links[doc->link].form->submit_method &&
		  links[doc->link].form->submit_action)) {
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d14 2
d28 32
a59 1
 *  Showinfo prints a page of info about the current file and the link
d63 1
a63 1
PUBLIC int showinfo ARGS4(
d69 1
a69 1
    static char tempfile[LY_MAXPATH];
d76 1
a76 1
    BOOLEAN LYInfoAdvanced = (user_mode == ADVANCED_MODE);
a77 1

a78 1
    char temp[LY_MAXPATH];
d82 7
a88 2
    LYRemoveTemp(tempfile);
    if ((fp0 = LYOpenTemp (tempfile, HTML_SUFFIX, "w")) == 0) {
d115 1
a115 1
    fprintf(fp0, "<h1>%s %s (%.*s) (<a href=\"%s\">%s</a>)",
d117 4
a120 14
		 LYNX_DATE_LEN,
		 (LYNX_RELEASE ? LYNX_RELEASE_DATE : &LYNX_DATE[LYNX_DATE_OFF]),
		 (LYNX_RELEASE ? LYNX_WWW_HOME     : LYNX_WWW_DIST),
		 (LYNX_RELEASE ? REL_VERSION       : DEV_VERSION) );

    if (!LYRestricted) {
#if defined(HAVE_CONFIG_H) && !defined(NO_CONFIG_INFO)
	fprintf(fp0, " - <a href=\"LYNXCOMPILEOPTS:\">%s</a>\n",
		COMPILE_OPT_SEGMENT);
#else
	fprintf(fp0, " - <a href=\"LYNXCFG:\">%s lynx.cfg</a>\n",
		YOUR_SEGMENT);
#endif
    }
d126 1
a126 1
	char *s;
d131 3
a133 3
	s = HTfullURL_toFile(doc->address);
	strcpy(temp, s);
	FREE(s);
a134 1
	fprintf(fp0, "   <em>%4s</em>  %s\n", gettext("Name:"), temp);
d137 1
a137 3
	s = HTfullURL_toFile(links[doc->link].lname);
	strcpy(temp, s);
	FREE(s);
d140 1
a140 1
	    CTRACE(tfp, "lstat(%s) failed, errno=%d\n", temp, errno);
d168 1
a168 1
		    strcpy(buf, gettext("Unable to follow link"));
d175 1
a175 1
		fprintf(fp0, "   <em>%s</em>  %s\n", gettext("Name of owner"), name);
d187 1
a187 1
	    fprintf(fp0, "   <em>%s</em>  %s", cp, gettext("Creation date:"));
d190 1
a190 1
	    fprintf(fp0, "   <em>%s</em>  %s", cp, gettext("Last modified:"));
d193 1
a193 1
	    fprintf(fp0, "   <em>%s</em>  %s\n", cp, gettext("Last accessed:"));
d255 1
d263 1
a263 1
    StrAllocCopy(Title, doc->title);
d267 4
a270 1
		 Title, (doc->isHEAD ? " (HEAD)" : ""));
d352 1
a352 1
		 (doc->internal_link ? gettext(", internal link") : "")
d423 1
a423 1
    refresh();
@


1.1
log
@Initial revision
@
text
@d1 13
a13 14
#include "HTUtils.h"
#include "tcp.h"
#include "HTParse.h"
#include "HTAlert.h"
#include "HTTP.h"
#include "LYCurses.h"
#include "LYStrings.h"
#include "LYUtils.h"
#include "LYStructs.h"
#include "LYGlobalDefs.h"
#include "LYShowInfo.h"
#include "LYSignal.h"
#include "LYCharUtils.h"
#include "GridText.h"
d15 1
a15 1
#include "LYLeaks.h"
d18 1
a18 2
#include <pwd.h>
#include <grp.h>
d20 1
a20 1
#include "LYLocal.h"
d23 1
a23 1
#define FREE(x) if (x) {free(x); x = NULL;}
d25 1
a25 1
/* 
d29 1
a29 1
	     
d34 1
a34 1
	char *,		owner_address)
d36 1
a36 3
    static char tempfile[256];
    static BOOLEAN first = TRUE;
    static char info_url[256];
d40 5
a44 1
    char *cp;
d47 1
a47 1
    char temp[300];
a48 2
    struct passwd *pw;
    struct group *grp;
a49 16
    if (first) {
        tempname(tempfile, NEW_FILE);
	/*
	 *  Make the temporary file a URL now.
	 */
#if defined (VMS) || defined (DOSPATH)
	sprintf(info_url, "file://localhost/%s", tempfile);
#else
	sprintf(info_url, "file://localhost%s", tempfile);
#endif /* VMS */
	first = FALSE;
#ifdef VMS
    } else {
        remove(tempfile);   /* Remove duplicates on VMS. */
#endif /* VMS */
    }
d51 4
a54 3
    if ((fp0 = LYNewTxtFile(tempfile)) == NULL) {
        HTAlert(CANNOT_OPEN_TEMP);
        return(0);
d58 1
a58 1
     *  Point the address pointer at this Url
d60 1
a60 1
    StrAllocCopy(newdoc->address, info_url);
d74 1
a74 1
    fprintf(fp0, "<head>\n");
d78 19
a96 2
    fprintf(fp0,"<h1>You have reached the Information Page</h1>\n");
    fprintf(fp0,"<h2>%s Version %s</h2>\n", LYNX_NAME, LYNX_VERSION);
d100 15
a114 2
	fprintf(fp0,
	 "<h2>Directory that you are currently viewing</h2>\n<pre>");
a115 18
	cp = doc->address;
	if (!strncmp(cp, "file://localhost", 16)) 
	    cp += 16;
	else if (!strncmp(cp, "file:", 5))
	    cp += 5;
	strcpy(temp, cp);
	HTUnEscape(temp);

	fprintf(fp0,"   <em>Name:</em>  %s\n", temp);
	fprintf(fp0,"   <em> URL:</em>  %s\n", doc->address);

	cp = links[doc->link].lname;
	if (!strncmp(cp, "file://localhost", 16)) 
	    cp += 16;
	else if (!strncmp(cp, "file:", 5))
	    cp += 5;
	strcpy(temp, cp);
	HTUnEscape(temp);
d117 2
a118 2
	    _statusline(CURRENT_LINK_STATUS_FAILED);
	    sleep(AlertSecs);
d121 6
a126 6
	    if (((dir_info.st_mode) & S_IFMT) == S_IFDIR) {
		fprintf(fp0,
		 "\nDirectory that you have currently selected\n\n");
	    } else if (((dir_info.st_mode) & S_IFMT) == S_IFREG) {
		fprintf(fp0, 
		      "\nFile that you have currently selected\n\n");
d128 3
a130 3
	    } else if (((dir_info.st_mode) & S_IFMT) == S_IFLNK) {
		fprintf(fp0,
	     "\nSymbolic link that you have currently selected\n\n");
d133 2
a134 2
		fprintf(fp0,
		      "\nItem that you have currently selected\n\n");
d136 1
a136 1
	    fprintf(fp0,"       <em>Full name:</em>  %s\n", temp);
d138 1
a138 1
	    if (((dir_info.st_mode) & S_IFMT) == S_IFLNK) {
d145 1
a145 1
		    strcpy(buf, "Unable to follow link");
d147 1
a147 1
		fprintf(fp0, "  <em>Points to file:</em>  %s\n", buf);
d150 9
a158 10
	    pw = getpwuid(dir_info.st_uid);
	    if (pw)
	        fprintf(fp0, "   <em>Name of owner:</em>  %s\n", pw->pw_name);
	    grp = getgrgid(dir_info.st_gid);
	    if (grp && grp->gr_name)
	        fprintf(fp0, "      <em>Group name:</em>  %s\n", grp->gr_name);
	    if (((dir_info.st_mode) & S_IFMT) == S_IFREG) {
		sprintf(temp, "       <em>File size:</em>  %ld (bytes)\n",
		 	      (long)dir_info.st_size);
		fprintf(fp0, "%s", temp);
d161 1
a161 1
	     *  Include date and time information.
d164 1
a164 1
	    fprintf(fp0, "   <em>Creation date:</em>  %s", cp);
d166 2
a167 2
	    cp = ctime(&dir_info.st_mtime);	      
	    fprintf(fp0, "   <em>Last modified:</em>  %s", cp);
d170 1
a170 1
	    fprintf(fp0, "   <em>Last accessed:</em>  %s\n", cp);
d172 2
a173 2
	    fprintf(fp0, "   <em>Access Permissions</em>\n");
	    fprintf(fp0, "      <em>Owner:</em>  ");
d182 1
a182 1
		if (((dir_info.st_mode) & S_IFMT) == S_IFDIR) 
d184 1
a184 1
	        else {
d187 2
a188 2
		        strcat(modes, ", setuid");
	        }
d196 1
a196 1
	    if ((dir_info.st_mode & S_IRGRP)) 
d201 1
a201 1
		if (((dir_info.st_mode) & S_IFMT) == S_IFDIR) 
d203 1
a203 1
	        else {
d206 2
a207 2
		        strcat(modes, ", setgid");
	        }
d220 1
a220 1
		if (((dir_info.st_mode) & S_IFMT) == S_IFDIR) 
d222 1
a222 1
	        else {
d226 1
a226 1
		        strcat(modes, ", sticky");
d228 1
a228 1
	        }
d236 2
a237 2
    fprintf(fp0,
       "<h2>File that you are currently viewing</h2>\n<dl compact>");
d241 3
a243 2
    fprintf(fp0, "<dt><em>Linkname:</em> %s%s\n",
    		 Title, (doc->isHEAD ? " (HEAD)" : ""));
d248 1
a248 1
    	    "<dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>URL:</em> %s\n", Address);
d251 2
a252 1
        fprintf(fp0, "<dt><em>&nbsp;Charset:</em> %s\n",
d256 1
a256 1
                                                             UCT_STAGE_PARSER);
d263 2
a264 1
        fprintf(fp0, "<dt><em>&nbsp;Charset:</em> %s (assumed)\n",
d270 1
a270 1
        fprintf(fp0, "<dt><em>&nbsp;&nbsp;Server:</em> %s\n", cp);
d273 1
a273 1
        fprintf(fp0, "<dt><em>&nbsp;&nbsp;&nbsp;&nbsp;Date:</em> %s\n", cp);
d276 23
a298 1
        fprintf(fp0, "<dt><em>Last Mod:</em> %s\n", cp);
d301 4
a304 4
	fprintf(fp0,
		"<dt><em>Post Data:</em> <xmp>%s</xmp>\n", doc->post_data);
	fprintf(fp0,
	     "<dt><em>Post Content Type:</em> %s\n", doc->post_content_type);
d308 1
a308 1
        StrAllocCopy(Address, owner_address);
d311 1
a311 1
        StrAllocCopy(Address, "None");
d313 1
a313 1
    fprintf(fp0, "<dt><em>Owner(s):</em> %s\n", Address);
d315 2
a316 2
    fprintf(fp0,
	"<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>size:</em> %d lines\n", size_of_file);
d318 2
a319 1
    fprintf(fp0, "<dt>&nbsp;&nbsp;&nbsp;&nbsp;<em>mode:</em> %s%s%s\n",
d321 15
a335 3
				  "forms mode" : "normal"),
		 (doc->safe ? ", safe" : ""),
		 (doc->internal_link ? ", internal link" : "")
d337 2
d340 1
a340 1
    fprintf(fp0, "</dl>\n");  /* end of list */
d343 2
a344 2
	fprintf(fp0,
      "<h2>Link that you currently have selected</h2>\n<dl compact>");
d347 3
a349 1
	fprintf(fp0, "<dt><em>Linkname:</em> %s\n", Title);
d353 2
a354 2
	        int method = links[doc->link].form->submit_method;
	        char *enctype = links[doc->link].form->submit_enctype;
d356 2
a357 1
		fprintf(fp0, "<dt>&nbsp;&nbsp;<em>Method:</em> %s\n",
d361 2
a362 1
		fprintf(fp0, "<dt>&nbsp;<em>Enctype:</em> %s\n",
d368 1
a368 1
	        StrAllocCopy(Address, links[doc->link].form->submit_action);
d370 1
a370 1
	        fprintf(fp0, "<dt>&nbsp;&nbsp;<em>Action:</em> %s\n", Address);
d374 1
a374 1
	        fprintf(fp0,"<dt>&nbsp;(Form field)\n");
d378 1
a378 1
	        StrAllocCopy(Title, links[doc->link].lname);
d381 1
a381 1
	        StrAllocCopy(Title, "");
d389 1
a389 1
	fprintf(fp0, "<h2>No Links on the current page</h2>");
d394 1
a394 1
    fprintf(fp0, "</body>\n");
d398 1
a398 1
    fclose(fp0);
d402 1
a402 1
    return(1);
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
