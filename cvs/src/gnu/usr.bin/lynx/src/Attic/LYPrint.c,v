head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.16
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.14
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.12
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.10
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.8
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.8;
commitid	EcR8E7r0stjLUV4p;

1.8
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.7;
commitid	lGGuvDWEniklWrQe;

1.7
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.06.01.36.12;	author cloder;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.11;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches;
next	;


desc
@@


1.9
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYPrint.c,v 1.104 2014/02/04 01:58:51 tom Exp $
 */
#include <HTUtils.h>
#include <HTAccess.h>
#include <HTList.h>
#include <HTAlert.h>
#include <HTFile.h>
#include <LYCurses.h>
#include <GridText.h>
#include <LYUtils.h>
#include <LYPrint.h>
#include <LYGlobalDefs.h>
#include <LYSignal.h>
#include <LYStrings.h>
#include <LYClean.h>
#include <LYGetFile.h>
#include <LYHistory.h>
#include <LYList.h>
#include <LYCharSets.h>		/* To get current charset for mail header. */

#include <LYLeaks.h>

#define CancelPrint(msg) HTInfoMsg(msg); goto done
#define CannotPrint(msg) HTAlert(msg); goto done

/*
 * printfile prints out the current file minus the links and targets to a
 * variety of places
 */

/* it parses an incoming link that looks like
 *
 * LYNXPRINT://LOCAL_FILE/lines=##
 * LYNXPRINT://MAIL_FILE/lines=##
 * LYNXPRINT://TO_SCREEN/lines=##
 * LYNXPRINT://LPANSI/lines=##
 * LYNXPRINT://PRINTER/lines=##/number=#
 */

#define TO_FILE   1
#define TO_SCREEN 2
/*
 * "lpansi.c"
 * Original author: Gary Day (gday@@comp.uark.edu), 11/30/93
 * Current version: 2.1 by Noel Hunter (noel@@wfu.edu), 10/20/94
 *
 * Basic structure based on print -- format files for printing from
 * _Practical_C_Programming by Steve Oualline, O'Reilly & Associates
 *
 * adapted from the README for lpansi.c v2.1, dated 10/20/1994:
 *		    Print to ANSI printer on local terminal
 *     The VT100 standard defines printer on and off escape sequences,
 *     esc[5i is printer on, and esc[4i is printer off.
 *
 * incorporate the idea of "lpansi" directly into LYPrint.c - HN
 */
#define LPANSI	  3
#define MAIL	  4
#define PRINTER   5

#if USE_VMS_MAILER
static int remove_quotes(char *string);
#endif /* USE_VMS_MAILER */

static char *subject_translate8bit(char *source);

#define LYNX_PRINT_TITLE   0
#define LYNX_PRINT_URL     1
#define LYNX_PRINT_DATE    2
#define LYNX_PRINT_LASTMOD 3

#define MAX_PUTENV 4

static void set_environ(int name,
			const char *value,
			const char *no_value)
{
    static const char *names[MAX_PUTENV] =
    {
	"LYNX_PRINT_TITLE",
	"LYNX_PRINT_URL",
	"LYNX_PRINT_DATE",
	"LYNX_PRINT_LASTMOD",
    };
    static char *pointers[MAX_PUTENV];
    char *envbuffer = 0;

#ifdef VMS
#define SET_ENVIRON(name, value, no_value) set_environ(name, value, no_value)
    char temp[80];

    StrAllocCopy(envbuffer, value);
    if (isEmpty(envbuffer))
	StrAllocCopy(envbuffer, no_value);
    Define_VMSLogical(strcpy(temp, names[name]), envbuffer);
    FREE(envbuffer);
#else
#define SET_ENVIRON(name, value, no_value) set_environ(name, value, "")
    /*
     * Once we've given a string to 'putenv()', we must not free it until we
     * give it a string to replace it.
     */
    StrAllocCopy(envbuffer, names[name]);
    StrAllocCat(envbuffer, "=");
    StrAllocCat(envbuffer, value ? value : no_value);
    putenv(envbuffer);
    FREE(pointers[name]);
    pointers[name] = envbuffer;
#endif
}

static char *suggested_filename(DocInfo *newdoc)
{
    char *sug_filename = 0;
    int rootlen;

    /*
     * Load the suggested filename string.  - FM
     */
    if (HText_getSugFname() != 0)
	StrAllocCopy(sug_filename, HText_getSugFname());	/* must be freed */
    else
	StrAllocCopy(sug_filename, newdoc->address);	/* must be freed */
    /*
     * Strip suffix for compressed-files, if present.
     */
    if (HTCompressFileType(sug_filename, ".", &rootlen) != cftNone)
	sug_filename[rootlen] = '\0';

    CTRACE((tfp, "suggest %s\n", sug_filename));
    return sug_filename;
}

static void SetupFilename(bstring **filename,
			  const char *sug_filename)
{
    HTFormat format;
    HTAtom *encoding;
    char *cp;

    BStrCopy0(*filename, sug_filename);		/* add suggestion info */
    BStrAlloc(*filename, LY_MAXPATH);	/* FIXME */
    change_sug_filename((*filename)->str);
    if (!(HTisDocumentSource())
	&& (cp = strrchr((*filename)->str, '.')) != NULL) {
	format = HTFileFormat((*filename)->str, &encoding, NULL);
	CTRACE((tfp, "... format %s\n", format->name));
	if (!strcasecomp(format->name, "text/html") ||
	    !IsUnityEnc(encoding)) {
	    (*filename)->len = (int) (cp - (*filename)->str);
	    BStrCat0(*filename, TEXT_SUFFIX);
	}
    }
    CTRACE((tfp, "... result %s\n", (*filename)->str));
}

#define FN_INIT 0
#define FN_READ 1
#define FN_DONE 2
#define FN_QUIT 3

#define PRINT_FLAG   0
#define GENERIC_FLAG 1

static int RecallFilename(bstring **filename,
			  BOOLEAN *first,
			  int *now,
			  int *total,
			  int flag)
{
    int ch;
    char *cp;
    RecallType recall;

    /*
     * Set up the sug_filenames recall buffer.
     */
    if (*now < 0) {
	*total = (sug_filenames ? HTList_count(sug_filenames) : 0);
	*now = *total;
    }
    recall = ((*total >= 1) ? RECALL_URL : NORECALL);

    if ((ch = LYgetBString(filename, FALSE, 0, recall)) < 0 ||
	isBEmpty(*filename) || ch == UPARROW_KEY || ch == DNARROW_KEY) {
	if (recall && ch == UPARROW_KEY) {
	    if (*first) {
		*first = FALSE;
		/*
		 * Use the last Fname in the list.  - FM
		 */
		*now = 0;
	    } else {
		/*
		 * Go back to the previous Fname in the list.  - FM
		 */
		*now += 1;
	    }
	    if (*now >= *total) {
		/*
		 * Reset the *first flag, and use sug_file or a blank.  -
		 * FM
		 */
		*first = TRUE;
		*now = *total;
		_statusline(FILENAME_PROMPT);
		return FN_INIT;
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		BStrCopy0(*filename, cp);
		if (*total == 1) {
		    _statusline(EDIT_THE_PREV_FILENAME);
		} else {
		    _statusline(EDIT_A_PREV_FILENAME);
		}
		return FN_READ;
	    }
	} else if (recall && ch == DNARROW_KEY) {
	    if (*first) {
		*first = FALSE;
		/*
		 * Use the first Fname in the list. - FM
		 */
		*now = *total - 1;
	    } else {
		/*
		 * Advance to the next Fname in the list. - FM
		 */
		*now -= 1;
	    }
	    if (*now < 0) {
		/*
		 * Set the *first flag, and use sug_file or a blank.  - FM
		 */
		*first = TRUE;
		*now = *total;
		_statusline(FILENAME_PROMPT);
		return FN_INIT;
	    } else if ((cp = (char *) HTList_objectAt(sug_filenames,
						      *now)) != NULL) {
		BStrCopy0(*filename, cp);
		if (*total == 1) {
		    _statusline(EDIT_THE_PREV_FILENAME);
		} else {
		    _statusline(EDIT_A_PREV_FILENAME);
		}
		return FN_READ;
	    }
	}

	/*
	 * Operation cancelled.
	 */
	if (flag == PRINT_FLAG)
	    HTInfoMsg(SAVE_REQUEST_CANCELLED);
	else if (flag == GENERIC_FLAG)
	    return FN_QUIT;

	return FN_QUIT;
    }
    return FN_DONE;
}

static BOOLEAN confirm_by_pages(const char *prompt,
				int lines_in_file,
				int lines_per_page)
{
    int pages = lines_in_file / (lines_per_page + 1);
    int c;

    /* count fractional pages ! */
    if ((lines_in_file % (LYlines + 1)) > 0)
	pages++;

    if (pages > 4) {
	char *msg = 0;

	HTSprintf0(&msg, prompt, pages);
	c = HTConfirmDefault(msg, YES);
	FREE(msg);

	if (c == YES) {
	    LYaddstr("   Ok...");
	} else {
	    HTInfoMsg(PRINT_REQUEST_CANCELLED);
	    return FALSE;
	}
    }
    return TRUE;
}

static void send_file_to_file(DocInfo *newdoc,
			      char *content_base,
			      char *sug_filename)
{
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN use_cte;
    const char *disp_charset;
    FILE *outfile_fp;
    bstring *buffer = NULL;
    bstring *filename = NULL;
    int FnameNum = -1;
    int FnameTotal;
    int c = 0;

    _statusline(FILENAME_PROMPT);

  retry:
    SetupFilename(&filename, sug_filename);
    if (lynx_save_space) {
	BStrCopy0(buffer, lynx_save_space);
	BStrCat(buffer, filename);
	BStrCopy(filename, buffer);
    } else {
	BStrCopy0(buffer, "");
    }

  check_recall:
    switch (RecallFilename(&filename, &FirstRecall, &FnameNum,
			   &FnameTotal, PRINT_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto done;
    default:
	break;
    }

    if (!LYValidateFilename(&buffer, &filename)) {
	CancelPrint(SAVE_REQUEST_CANCELLED);
    }

    /*
     * See if it already exists.
     */
    switch (c = LYValidateOutput(buffer->str)) {
    case 'Y':
	break;
    case 'N':
	_statusline(NEW_FILENAME_PROMPT);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    default:
	goto done;
    }

    /*
     * See if we can write to it.
     */
    CTRACE((tfp, "LYPrint: filename is %s, action is `%c'\n", buffer->str, c));

#ifdef HAVE_POPEN
    if (buffer->str[0] == '|') {
	if (no_shell) {
	    HTUserMsg(SPAWNING_DISABLED);
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	} else if ((outfile_fp = popen(buffer->str + 1, "w")) == NULL) {
	    CTRACE((tfp, "LYPrint: errno is %d\n", errno));
	    HTAlert(CANNOT_WRITE_TO_FILE);
	    _statusline(NEW_FILENAME_PROMPT);
	    FirstRecall = TRUE;
	    FnameNum = FnameTotal;
	    goto retry;
	}
    } else
#endif
	if ((outfile_fp = (TOUPPER(c) == 'A'
			   ? LYAppendToTxtFile(buffer->str)
			   : LYNewTxtFile(buffer->str))) == NULL) {
	CTRACE((tfp, "LYPrint: errno is %d\n", errno));
	HTAlert(CANNOT_WRITE_TO_FILE);
	_statusline(NEW_FILENAME_PROMPT);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    }

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the file.  May
	 * create technically invalid HTML, but will help get any partial or
	 * relative URLs resolved properly if no BASE tag is present to replace
	 * it.  - FM
	 *
	 * Add timestamp (last reload).
	 */

	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n", newdoc->address);
	if (HText_getDate() != NULL) {
	    fprintf(outfile_fp,
		    "<!-- Date: %s -->\n", HText_getDate());
	    if (HText_getLastModified() != NULL
		&& strcmp(HText_getLastModified(), HText_getDate())
		&& strcmp(HText_getLastModified(),
			  "Thu, 01 Jan 1970 00:00:01 GMT")) {
		fprintf(outfile_fp,
			"<!-- Last-Modified: %s -->\n", HText_getLastModified());
	    }
	}

	fprintf(outfile_fp,
		"<BASE HREF=\"%s\">\n", content_base);
    }

    if (LYPrependCharsetToSource && HTisDocumentSource()) {
	/*
	 * Added the document's charset as a META CHARSET tag to the top of the
	 * file.  May create technically invalid HTML, but will help to resolve
	 * properly the document converted via chartrans:  printed document
	 * correspond to a display charset and we *should* override both
	 * assume_local_charset and original document's META CHARSET (if any).
	 *
	 * Currently, if several META CHARSETs are found Lynx uses the first
	 * only, and it is opposite to BASE where the original BASE in the
	 * <HEAD> overrides ones from the top.
	 *
	 * As in print-to-email we write charset only if the document has 8-bit
	 * characters, and we have no CJK or an unofficial "x-" charset.
	 */
	use_cte = HTLoadedDocumentEightbit();
	disp_charset = LYCharSet_UC[current_char_set].MIMEname;
	if (!use_cte || LYHaveCJKCharacterSet ||
	    strncasecomp(disp_charset, "x-", 2) == 0) {
	} else {
	    fprintf(outfile_fp,
		    "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
		    disp_charset);
	}
    }

    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* FILE */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

#ifdef HAVE_POPEN
    if (LYIsPipeCommand(buffer->str))
	pclose(outfile_fp);
    else
#endif
	LYCloseOutput(outfile_fp);

#ifdef VMS
    if (0 == strncasecomp(buffer->str, "sys$disk:", 9)) {
	if (0 == StrNCmp((buffer->str + 9), "[]", 2)) {
	    HTAddSugFilename(buffer->str + 11);
	} else {
	    HTAddSugFilename(buffer->str + 9);
	}
    } else {
	HTAddSugFilename(buffer->str);
    }
#else
    HTAddSugFilename(buffer->str);
#endif /* VMS */

  done:
    BStrFree(buffer);
    BStrFree(filename);
    return;
}

static void send_file_to_mail(DocInfo *newdoc,
			      char *content_base,
			      char *content_location)
{
    static BOOLEAN first_mail_preparsed = TRUE;

#if USE_VMS_MAILER
    BOOLEAN isPMDF = LYMailPMDF();
    FILE *hfd;
    char hdrfile[LY_MAXPATH];
#endif
    BOOL use_mime;

#if !CAN_PIPE_TO_MAILER
    char my_temp[LY_MAXPATH];
#endif

    BOOL use_cte;
    BOOL use_type;
    const char *disp_charset;
    FILE *outfile_fp;
    char *buffer = NULL;
    char *subject = NULL;
    bstring *user_response = NULL;

    if (!LYSystemMail())
	return;

    if (LYPreparsedSource && first_mail_preparsed &&
	HTisDocumentSource()) {
	if (HTConfirmDefault(CONFIRM_MAIL_SOURCE_PREPARSED, NO) == YES) {
	    LYaddstr("   Ok...");
	    first_mail_preparsed = FALSE;
	} else {
	    CancelPrint(MAIL_REQUEST_CANCELLED);
	}
    }

    _statusline(MAIL_ADDRESS_PROMPT);
    BStrCopy0(user_response, NonNull(personal_mail_address));
    if (LYgetBString(&user_response, FALSE, 0, RECALL_MAIL) < 0 ||
	isBEmpty(user_response)) {
	CancelPrint(MAIL_REQUEST_CANCELLED);
    }

    /*
     * Determine which mail headers should be sent.  Use Content-Type and
     * MIME-Version headers only if needed.  We need them if we are mailing
     * HTML source, or if we have 8-bit characters and will be sending
     * Content-Transfer-Encoding to indicate this.  We will append a charset
     * parameter to the Content-Type if we do not have an "x-" charset, and we
     * will include the Content-Transfer-Encoding only if we are appending the
     * charset parameter, because indicating an 8-bit transfer without also
     * indicating the charset can cause problems with many mailers.  - FM & KW
     */
    disp_charset = LYCharSet_UC[current_char_set].MIMEname;
    use_cte = HTLoadedDocumentEightbit();
    if (!(use_cte && strncasecomp(disp_charset, "x-", 2))) {
	disp_charset = NULL;
#if USE_VMS_MAILER
	use_cte = FALSE;
#endif
    }
#if USE_VMS_MAILER
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
#endif

    /*
     * Use newdoc->title as a subject instead of sug_filename:  MORE readable
     * and 8-bit letters shouldn't be a problem - LP
     */
    /* change_sug_filename(sug_filename); */
    subject = subject_translate8bit(newdoc->title);

    if (newdoc->isHEAD) {
	/*
	 * Special case for mailing HEAD responce:  this is rather technical
	 * information, show URL.
	 */
	FREE(subject);
	StrAllocCopy(subject, "HEAD  ");
	StrAllocCat(subject, newdoc->address);
    }
#if USE_VMS_MAILER
    if (StrChr(user_response->str, '@@') &&
	!StrChr(user_response->str, ':') &&
	!StrChr(user_response->str, '%') &&
	!StrChr(user_response->str, '"')) {
	char *temp = 0;

	HTSprintf0(&temp, mail_adrs, user_response->str);
	BStrCopy0(user_response, temp);
	FREE(temp);
    }

    outfile_fp = LYOpenTemp(my_temp,
			    (HTisDocumentSource())
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
			    "w");
    if (outfile_fp == NULL) {
	CannotPrint(UNABLE_TO_OPEN_TEMPFILE);
    }

    if (isPMDF) {
	if ((hfd = LYOpenTemp(hdrfile, TEXT_SUFFIX, "w")) == NULL) {
	    CannotPrint(UNABLE_TO_OPEN_TEMPFILE);
	}
	if (use_type) {
	    fprintf(hfd, "Mime-Version: 1.0\n");
	    if (use_cte) {
		fprintf(hfd, "Content-Transfer-Encoding: 8bit\n");
	    }
	}
	if (HTisDocumentSource()) {
	    /*
	     * Add Content-Type, Content-Location, and Content-Base headers for
	     * HTML source.  - FM
	     */
	    fprintf(hfd, "Content-Type: text/html");
	    if (disp_charset != NULL) {
		fprintf(hfd, "; charset=%s\n", disp_charset);
	    } else {
		fprintf(hfd, "\n");
	    }
	    fprintf(hfd, "Content-Base: %s\n", content_base);
	    fprintf(hfd, "Content-Location: %s\n", content_location);
	} else {
	    /*
	     * Add Content-Type:  text/plain if we have 8-bit characters and a
	     * valid charset for non-source documents.  - FM
	     */
	    if (disp_charset != NULL) {
		fprintf(hfd,
			"Content-Type: text/plain; charset=%s\n",
			disp_charset);
	    }
	}
	/*
	 * X-URL header.  - FM
	 */
	fprintf(hfd, "X-URL: %s\n", newdoc->address);
	/*
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
    }

    /*
     * Write the contents to a temp file.
     */
    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the message
	 * body.  May create technically invalid HTML, but will help get any
	 * partial or relative URLs resolved properly if no BASE tag is present
	 * to replace it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    } else if (!isPMDF) {
	fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);
    }
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);
    LYCloseTempFP(outfile_fp);

    buffer = NULL;
    if (isPMDF) {
	/*
	 * Now set up the command.  - FM
	 */
	HTSprintf0(&buffer,
		   "%s %s %s,%s %s",
		   system_mail,
		   system_mail_flags,
		   hdrfile,
		   my_temp,
		   user_response->str);
    } else {
	/*
	 * For "generic" VMS MAIL, include the subject in the command.  - FM
	 */
	remove_quotes(subject);
	HTSprintf0(&buffer,
		   "%s %s/subject=\"%.70s\" %s %s",
		   system_mail,
		   system_mail_flags,
		   subject,
		   my_temp,
		   user_response->str);
    }

    stop_curses();
    SetOutputMode(O_TEXT);
    printf(MAILING_FILE);
    LYSystem(buffer);
    LYSleepAlert();
    start_curses();
    SetOutputMode(O_BINARY);

    if (isPMDF)
	(void) LYRemoveTemp(hdrfile);
    (void) LYRemoveTemp(my_temp);
#else /* !VMS (Unix or DOS) */

#if CAN_PIPE_TO_MAILER
    outfile_fp = LYPipeToMailer();
#else
    outfile_fp = LYOpenTemp(my_temp, TEXT_SUFFIX, "w");
#endif
    if (outfile_fp == NULL) {
	CannotPrint(MAIL_REQUEST_FAILED);
    }

    /*
     * Determine which mail headers should be sent.  Use Content-Type and
     * MIME-Version headers only if needed.  We need them if we are mailing
     * HTML source, or if we have 8-bit characters and will be sending
     * Content-Transfer-Encoding to indicate this.
     *
     * Send Content-Transfer-Encoding only if the document has 8-bit
     * characters.  Send a charset parameter only if the document has 8-bit
     * characters and we seem to have a valid charset.  - kw
     */
    use_cte = HTLoadedDocumentEightbit();
    disp_charset = LYCharSet_UC[current_char_set].MIMEname;
    /*
     * Don't send a charset if we have a CJK character set selected, since it
     * may not be appropriate for mail...  Also don't use an unofficial "x-"
     * charset.  - kw
     */
    if (!use_cte || LYHaveCJKCharacterSet ||
	strncasecomp(disp_charset, "x-", 2) == 0) {
	disp_charset = NULL;
    }
#ifdef NOTDEFINED
    /* Enable this if indicating an 8-bit transfer without also indicating the
     * charset causes problems.  - kw */
    if (use_cte && !disp_charset)
	use_cte = FALSE;
#endif /* NOTDEFINED */
    use_type = (BOOL) (disp_charset || HTisDocumentSource());
    use_mime = (BOOL) (use_cte || use_type);

    if (use_mime) {
	fprintf(outfile_fp, "Mime-Version: 1.0\n");
	if (use_cte) {
	    fprintf(outfile_fp, "Content-Transfer-Encoding: 8bit\n");
	}
    }

    if (HTisDocumentSource()) {
	/*
	 * Add Content-Type, Content-Location, and Content-Base headers for
	 * HTML source.  - FM
	 */
	fprintf(outfile_fp, "Content-Type: text/html");
	if (disp_charset != NULL) {
	    fprintf(outfile_fp, "; charset=%s\n", disp_charset);
	} else {
	    fprintf(outfile_fp, "\n");
	}
    } else {
	/*
	 * Add Content-Type:  text/plain if we have 8-bit characters and a
	 * valid charset for non-source documents.  - KW
	 */
	if (disp_charset != NULL) {
	    fprintf(outfile_fp,
		    "Content-Type: text/plain; charset=%s\n",
		    disp_charset);
	}
    }
    /*
     * If we are using MIME headers, add content-base and content-location if
     * we have them.  This will always be the case if the document is source.
     * - kw
     */
    if (use_mime) {
	if (content_base)
	    fprintf(outfile_fp, "Content-Base: %s\n", content_base);
	if (content_location)
	    fprintf(outfile_fp, "Content-Location: %s\n", content_location);
    }

    /*
     * Add the To, Subject, and X-URL headers.  - FM
     */
    fprintf(outfile_fp, "To: %s\nSubject: %s\n", user_response->str, subject);
    fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the message
	 * body.  May create technically invalid HTML, but will help get any
	 * partial or relative URLs resolved properly if no BASE tag is present
	 * to replace it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    }
    print_wwwfile_to_fd(outfile_fp, TRUE, FALSE);	/* MAIL */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

#if CAN_PIPE_TO_MAILER
    pclose(outfile_fp);
#else
    LYCloseOutput(outfile_fp);
    LYSendMailFile(user_response->str,
		   my_temp,
		   subject,
		   "",
		   "");
    (void) LYRemoveTemp(my_temp);	/* Delete the tmpfile. */
#endif /* CAN_PIPE_TO_MAILER */
#endif /* USE_VMS_MAILER */

  done:			/* send_file_to_mail() */
    BStrFree(user_response);
    FREE(buffer);
    FREE(subject);
    return;
}

static void send_file_to_printer(DocInfo *newdoc,
				 char *content_base,
				 char *sug_filename,
				 int printer_number)
{
    BOOLEAN FirstRecall = TRUE;
    FILE *outfile_fp;
    char *the_command = 0;
    bstring *my_file = NULL;
    char my_temp[LY_MAXPATH];
    int FnameTotal, FnameNum = -1;
    lynx_list_item_type *cur_printer;

    outfile_fp = LYOpenTemp(my_temp,
			    (HTisDocumentSource())
			    ? HTML_SUFFIX
			    : TEXT_SUFFIX,
			    "w");
    if (outfile_fp == NULL) {
	CannotPrint(FILE_ALLOC_FAILED);
    }

    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the file.  May
	 * create technically invalid HTML, but will help get any partial or
	 * relative URLs resolved properly if no BASE tag is present to replace
	 * it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    }
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* PRINTER */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);

    LYCloseTempFP(outfile_fp);

    /* find the right printer number */
    {
	int count = 0;

	for (cur_printer = printers;
	     count < printer_number;
	     count++, cur_printer = cur_printer->next) ;	/* null body */
    }

    /*
     * Commands have the form "command %s [%s] [etc]" where %s is the filename
     * and the second optional %s is the suggested filename.
     */
    if (cur_printer->command == NULL) {
	CannotPrint(PRINTER_MISCONF_ERROR);
    }

    /*
     * Check for two '%s' and ask for the second filename argument if there
     * is.
     */
    BStrCopy0(my_file, "");
    if (HTCountCommandArgs(cur_printer->command) >= 2) {
	_statusline(FILENAME_PROMPT);
      again:
	SetupFilename(&my_file, sug_filename);
      check_again:
	switch (RecallFilename(&my_file, &FirstRecall, &FnameNum,
			       &FnameTotal, PRINT_FLAG)) {
	case FN_INIT:
	    goto again;
	case FN_READ:
	    goto check_again;
	case FN_QUIT:
	    goto done;
	default:
	    break;
	}

	if (no_dotfiles || !show_dotfiles) {
	    if (*LYPathLeaf(my_file->str) == '.') {
		HTAlert(FILENAME_CANNOT_BE_DOT);
		_statusline(NEW_FILENAME_PROMPT);
		FirstRecall = TRUE;
		FnameNum = FnameTotal;
		goto again;
	    }
	}
	/*
	 * Cancel if the user entered "/dev/null" on Unix, or an "nl:" path
	 * on VMS.  - FM
	 */
	if (LYIsNullDevice(my_file->str)) {
	    CancelPrint(PRINT_REQUEST_CANCELLED);
	}
	HTAddSugFilename(my_file->str);
    }
#ifdef SH_EX			/* 1999/01/04 (Mon) 09:37:03 */
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    if (!isBEmpty(my_file)) {
	HTAddParam(&the_command, cur_printer->command, 2, my_file->str);
	HTEndParam(&the_command, cur_printer->command, 3);
    } else {
	HTEndParam(&the_command, cur_printer->command, 2);
    }
#else
    HTAddParam(&the_command, cur_printer->command, 1, my_temp);
    HTAddParam(&the_command, cur_printer->command, 2, my_file->str);
    HTEndParam(&the_command, cur_printer->command, 2);
#endif

    /*
     * Move the cursor to the top of the screen so that output from system'd
     * commands don't scroll up the screen.
     */
    LYmove(1, 1);

    stop_curses();
    CTRACE((tfp, "command: %s\n", the_command));
    SetOutputMode(O_TEXT);
    printf(PRINTING_FILE);
    /*
     * Set various bits of document information as environment variables, for
     * use by external print scripts/etc.  On UNIX, We assume there are values,
     * and leave NULL value checking up to the external PRINTER:  cmd/script -
     * KED
     */
    SET_ENVIRON(LYNX_PRINT_TITLE, HText_getTitle(), "No Title");
    SET_ENVIRON(LYNX_PRINT_URL, newdoc->address, "No URL");
    SET_ENVIRON(LYNX_PRINT_DATE, HText_getDate(), "No Date");
    SET_ENVIRON(LYNX_PRINT_LASTMOD, HText_getLastModified(), "No LastMod");

    LYSystem(the_command);
    FREE(the_command);
    (void) LYRemoveTemp(my_temp);

    /*
     * Remove the various LYNX_PRINT_xxxx logicals.  - KED
     * [could use unsetenv(), but it's not portable]
     */
    SET_ENVIRON(LYNX_PRINT_TITLE, "", "");
    SET_ENVIRON(LYNX_PRINT_URL, "", "");
    SET_ENVIRON(LYNX_PRINT_DATE, "", "");
    SET_ENVIRON(LYNX_PRINT_LASTMOD, "", "");

    fflush(stdout);
#ifndef VMS
    signal(SIGINT, cleanup_sig);
#endif /* !VMS */
#ifdef SH_EX
    fprintf(stdout, gettext(" Print job complete.\n"));
    fflush(stdout);
#endif
    SetOutputMode(O_BINARY);
    LYSleepMsg();
    start_curses();

  done:			/* send_file_to_printer() */
    BStrFree(my_file);
    return;
}

static void send_file_to_screen(DocInfo *newdoc,
				char *content_base,
				int Lpansi)
{
    FILE *outfile_fp;
    bstring *prompt = NULL;

    if (Lpansi) {
	_statusline(CHECK_PRINTER);
    } else {
	_statusline(PRESS_RETURN_TO_BEGIN);
    }

    BStrCopy0(prompt, "");
    if (LYgetBString(&prompt, FALSE, 0, NORECALL) < 0) {
	CancelPrint(PRINT_REQUEST_CANCELLED);
    } else {
	outfile_fp = stdout;

	stop_curses();
	SetOutputMode(O_TEXT);

#ifndef VMS
	signal(SIGINT, SIG_IGN);
#endif /* !VMS */

	if (LYPrependBaseToSource && HTisDocumentSource()) {
	    /*
	     * Added the document's base as a BASE tag to the top of the file.  May
	     * create technically invalid HTML, but will help get any partial or
	     * relative URLs resolved properly if no BASE tag is present to replace
	     * it.  - FM
	     */
	    fprintf(outfile_fp,
		    "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		    newdoc->address, content_base);
	}
	if (Lpansi)
	    printf("\033[5i");
	print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* SCREEN */
	if (keypad_mode)
	    printlist(outfile_fp, FALSE);

#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    start_curses();
	    CancelPrint(PRINT_REQUEST_CANCELLED);
	}
#endif /* VMS */
	if (Lpansi) {
	    printf("\n\014");	/* Form feed */
	    printf("\033[4i");
	    fflush(stdout);	/* refresh to screen */
	} else {
	    fprintf(stdout, "\n\n%s", PRESS_RETURN_TO_FINISH);
	    fflush(stdout);	/* refresh to screen */
	    (void) LYgetch();	/* grab some user input to pause */
#ifdef VMS
	    HadVMSInterrupt = FALSE;
#endif /* VMS */
	}
#ifdef SH_EX
	fprintf(stdout, "\n");
#endif
	SetOutputMode(O_BINARY);
	start_curses();
    }

  done:			/* send_file_to_screen() */
    BStrFree(prompt);
    return;
}

int printfile(DocInfo *newdoc)
{
    BOOLEAN Lpansi = FALSE;
    DocAddress WWWDoc;
    char *content_base = NULL;
    char *content_location = NULL;
    char *cp = NULL;
    char *link_info = NULL;
    char *sug_filename = NULL;
    int lines_in_file = 0;
    int pagelen = 0;
    int printer_number = 0;
    int type = 0;

    /*
     * Extract useful info from URL.
     */
    StrAllocCopy(link_info, newdoc->address + 12);

    /*
     * Reload the file we want to print into memory.
     */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    if (!HTLoadAbsolute(&WWWDoc))
	return (NOT_FOUND);

    /*
     * If we have an explicit content-base, we may use it even if not in source
     * mode.  - kw
     */
    if (HText_getContentBase()) {
	StrAllocCopy(content_base, HText_getContentBase());
	LYRemoveBlanks(content_base);
	if (isEmpty(content_base)) {
	    FREE(content_base);
	}
    }
    /*
     * If document is source, load the content_base and content_location
     * strings.  - FM
     */
    if (HTisDocumentSource()) {
	if (HText_getContentLocation()) {
	    StrAllocCopy(content_location, HText_getContentLocation());
	    LYRemoveBlanks(content_location);
	    if (isEmpty(content_location)) {
		FREE(content_location);
	    }
	}
	if (!content_base) {
	    if ((content_location) && is_url(content_location)) {
		StrAllocCopy(content_base, content_location);
	    } else {
		StrAllocCopy(content_base, newdoc->address);
	    }
	}
	if (!content_location) {
	    StrAllocCopy(content_location, newdoc->address);
	}
    }

    sug_filename = suggested_filename(newdoc);

    /*
     * Get the number of lines in the file.
     */
    if ((cp = strstr(link_info, "lines=")) != NULL) {
	/*
	 * Terminate prev string here.
	 */
	*cp = '\0';
	/*
	 * Number of characters in "lines=".
	 */
	cp += 6;

	lines_in_file = atoi(cp);
    }

    /*
     * Determine the type.
     */
    if (strstr(link_info, "LOCAL_FILE")) {
	type = TO_FILE;
    } else if (strstr(link_info, "TO_SCREEN")) {
	type = TO_SCREEN;
    } else if (strstr(link_info, "LPANSI")) {
	Lpansi = TRUE;
	type = TO_SCREEN;
    } else if (strstr(link_info, "MAIL_FILE")) {
	type = MAIL;
    } else if (strstr(link_info, "PRINTER")) {
	type = PRINTER;

	if ((cp = strstr(link_info, "number=")) != NULL) {
	    /* number of characters in "number=" */
	    cp += 7;
	    printer_number = atoi(cp);
	}
	if ((cp = strstr(link_info, "pagelen=")) != NULL) {
	    /* number of characters in "pagelen=" */
	    cp += 8;
	    pagelen = atoi(cp);
	} else {
	    /* default to 66 lines */
	    pagelen = 66;
	}
    }

    /*
     * Act on the request.  - FM
     */
    switch (type) {

    case TO_FILE:
	send_file_to_file(newdoc, content_base, sug_filename);
	break;

    case MAIL:
	send_file_to_mail(newdoc, content_base, content_location);
	break;

    case TO_SCREEN:
	if (confirm_by_pages(CONFIRM_LONG_SCREEN_PRINT, lines_in_file, LYlines))
	    send_file_to_screen(newdoc, content_base, Lpansi);
	break;

    case PRINTER:
	if (confirm_by_pages(CONFIRM_LONG_PAGE_PRINT, lines_in_file, pagelen))
	    send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
	break;

    }				/* end switch */

    FREE(link_info);
    FREE(sug_filename);
    FREE(content_base);
    FREE(content_location);
    return (NORMAL);
}

#if USE_VMS_MAILER
static int remove_quotes(char *string)
{
    int i;

    for (i = 0; string[i] != '\0'; i++)
	if (string[i] == '"')
	    string[i] = ' ';
	else if (string[i] == '&')
	    string[i] = ' ';
	else if (string[i] == '|')
	    string[i] = ' ';

    return (0);
}
#endif /* USE_VMS_MAILER */

/*
 * Mail subject may have 8-bit characters and they are in display charset.
 * There is no stable practice for 8-bit subject encodings:  MIME defines
 * "quoted-printable" which holds charset info but most mailers still don't
 * support it.  On the other hand many mailers send open 8-bit subjects without
 * charset info and use local assumption for certain countries.  Besides that,
 * obsolete SMTP software is not 8bit clean but still in use, it strips the
 * characters in 128-160 range from subjects which may be a fault outside
 * iso-8859-XX.
 *
 * We translate subject to "outgoing_mail_charset" (defined in lynx.cfg) it may
 * correspond to US-ASCII as the safest value or any other lynx character
 * handler, -1 for no translation (so display charset).
 *
 * Always returns a new allocated string which has to be freed.
 */
#include <LYCharUtils.h>
static char *subject_translate8bit(char *source)
{
    char *target = NULL;

    int charset_in, charset_out;

    int i = outgoing_mail_charset;	/* from lynx.cfg, -1 by default */

    StrAllocCopy(target, source);
    if (i < 0
	|| i == current_char_set
	|| LYCharSet_UC[current_char_set].enc == UCT_ENC_CJK
	|| LYCharSet_UC[i].enc == UCT_ENC_CJK) {
	return (target);	/* OK */
    } else {
	charset_out = i;
	charset_in = current_char_set;
    }

    LYUCTranslateBackHeaderText(&target, charset_in, charset_out, YES);

    return (target);
}

/*
 * print_options writes out the current printer choices to a file
 * so that the user can select printers in the same way that
 * they select all other links
 * printer links look like
 *
 * LYNXPRINT://LOCAL_FILE/lines=#	     print to a local file
 * LYNXPRINT://TO_SCREEN/lines=#	     print to the screen
 * LYNXPRINT://LPANSI/lines=#		     print to the local terminal
 * LYNXPRINT://MAIL_FILE/lines=#	     mail the file
 * LYNXPRINT://PRINTER/lines=#/number=#      print to printer number #
 */
int print_options(char **newfile,
		  const char *printed_url,
		  int lines_in_file)
{
    static char my_temp[LY_MAXPATH] = "\0";
    char *buffer = 0;
    int count;
    int pages;
    FILE *fp0;
    lynx_list_item_type *cur_printer;

    if ((fp0 = InternalPageFP(my_temp, TRUE)) == 0)
	return (-1);

    LYLocalFileToURL(newfile, my_temp);

    BeginInternalPage(fp0, PRINT_OPTIONS_TITLE, PRINT_OPTIONS_HELP);

    fprintf(fp0, "<pre>\n");

    /*  pages = lines_in_file/66 + 1; */
    pages = (lines_in_file + 65) / 66;
    HTSprintf0(&buffer,
	       "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
	       gettext("Document:"), printed_url,
	       gettext("Number of lines:"), lines_in_file,
	       gettext("Number of pages:"), pages,
	       (pages > 1 ? gettext("pages") : gettext("page")),
	       gettext("(approximately)"));
    fputs(buffer, fp0);
    FREE(buffer);

    if (no_print || no_disk_save || no_mail)
	fprintf(fp0,
		"   <em>%s</em>\n",
		gettext("Some print functions have been disabled!"));

    fprintf(fp0, "\n%s\n",
	    (user_mode == NOVICE_MODE)
	    ? gettext("Standard print options:")
	    : gettext("Print options:"));

    if (no_disk_save == FALSE && no_print == FALSE) {
	fprintf(fp0,
		"   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
		lines_in_file,
		gettext("Save to a local file"));
    } else {
	fprintf(fp0, "   <em>%s</em>\n", gettext("Save to disk disabled"));
    }
    if (no_mail == FALSE && local_host_only == FALSE)
	fprintf(fp0,
		"   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n",
		STR_LYNXPRINT,
		lines_in_file,
		gettext("Mail the file"));

#if defined(UNIX) || defined(VMS)
    fprintf(fp0,
	    "   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
	    lines_in_file,
	    gettext("Print to the screen"));
    fprintf(fp0,
	    "   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n",
	    STR_LYNXPRINT,
	    lines_in_file,
	    gettext("Print out on a printer attached to your vt100 terminal"));
#endif

    if (user_mode == NOVICE_MODE)
	fprintf(fp0, "\n%s\n", gettext("Local additions:"));

    for (count = 0, cur_printer = printers; cur_printer != NULL;
	 cur_printer = cur_printer->next, count++)
	if (no_print == FALSE || cur_printer->always_enabled) {
	    fprintf(fp0,
		    "   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		    STR_LYNXPRINT,
		    count, cur_printer->pagelen, lines_in_file);
	    fprintf(fp0, "%s", (cur_printer->name ?
				cur_printer->name : "No Name Given"));
	    fprintf(fp0, "</a>\n");
	}
    fprintf(fp0, "</pre>\n");
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);

    LYforce_no_cache = TRUE;
    return (0);
}

/*
 * General purpose filename getter.
 *
 * Returns a pointer to an absolute filename string, if the input filename
 * exists, and is readable.  Returns NULL if the input was cancelled (^G, or CR
 * on empty input).
 *
 * The pointer to the filename string needs to be free()'d by the caller (when
 * non-NULL).
 *
 * --KED 02/21/99
 */
char *GetFileName(void)
{
    struct stat stat_info;

    bstring *fbuf = NULL;
    bstring *tbuf = NULL;
    char *result = NULL;

    BOOLEAN FirstRecall = TRUE;
    int FnameNum = -1;
    int FnameTotal;

    _statusline(FILENAME_PROMPT);

  retry:
    /*
     * No initial filename.
     */
    SetupFilename(&fbuf, "");

  check_recall:
    /*
     * Go get a filename (it would be nice to do TAB == filename-completion as
     * the name is entered, but we'll save doing that for another time.
     */
    switch (RecallFilename(&fbuf, &FirstRecall, &FnameNum,
			   &FnameTotal, GENERIC_FLAG)) {
    case FN_INIT:
	goto retry;
    case FN_READ:
	goto check_recall;
    case FN_QUIT:
	goto cleanup;
    default:
	break;
    }

    /*
     * Add raw input form to list ...  we may want to reuse/edit it on a
     * subsequent call, etc.
     */
#ifdef VMS
    if (0 == strncasecomp(fbuf->str, "sys$disk:", 9)) {
	if (0 == StrNCmp((fbuf->str + 9), "[]", 2)) {
	    HTAddSugFilename(fbuf->str + 11);
	} else {
	    HTAddSugFilename(fbuf->str + 9);
	}
    } else {
	HTAddSugFilename(fbuf->str);
    }
#else
    HTAddSugFilename(fbuf->str);
#endif /* VMS */

    /*
     * Expand tilde's, make filename absolute, etc.
     */
    BStrCopy0(tbuf, "");
    if (!LYValidateFilename(&tbuf, &fbuf))
	goto cleanup;

    /*
     * Check for file existence; readability.
     */
    if ((stat(tbuf->str, &stat_info) < 0) ||
	(!(S_ISREG(stat_info.st_mode)
#ifdef S_IFLNK
	   || S_ISLNK(stat_info.st_mode)
#endif /* S_IFLNK */
	 ))) {
	HTInfoMsg(FILE_DOES_NOT_EXIST);
	_statusline(FILE_DOES_NOT_EXIST_RE);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    }

    if (!LYCanReadFile(tbuf->str)) {
	HTInfoMsg(FILE_NOT_READABLE);
	_statusline(FILE_NOT_READABLE_RE);
	FirstRecall = TRUE;
	FnameNum = FnameTotal;
	goto retry;
    }

    /*
     * We have a valid filename, and readable file.  Return it to the caller.
     *
     * The returned pointer should be free()'d by the caller.
     */
    StrAllocCopy(result, tbuf->str);

  cleanup:
    BStrFree(fbuf);
    BStrFree(tbuf);
    return (result);
}
@


1.8
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.7
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYPrint.c,v 1.85 2009/05/24 22:28:27 tom Exp $
d135 1
a135 1
static void SetupFilename(char *filename,
d142 3
a144 3
    LYstrncpy(filename, sug_filename, LY_MAXPATH - 1);	/* add suggestion info */
    /* make the sug_filename conform to system specs */
    change_sug_filename(filename);
d146 2
a147 3
	&& (cp = strrchr(filename, '.')) != NULL
	&& (cp - filename) < (LY_MAXPATH - (int) (sizeof(TEXT_SUFFIX) + 1))) {
	format = HTFileFormat(filename, &encoding, NULL);
d151 2
a152 1
	    strcpy(cp, TEXT_SUFFIX);
d155 1
a155 1
    CTRACE((tfp, "... result %s\n", filename));
d166 1
a166 1
static int RecallFilename(char *filename,
d185 3
a187 3
    if ((ch = LYgetstr(filename, VISIBLE, LY_MAXPATH, recall)) < 0 ||
	*filename == '\0' || ch == UPARROW || ch == DNARROW) {
	if (recall && ch == UPARROW) {
d211 1
a211 1
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
d219 1
a219 1
	} else if (recall && ch == DNARROW) {
d242 1
a242 1
		LYstrncpy(filename, cp, LY_MAXPATH - 1);
d301 2
a302 2
    char buffer[LY_MAXPATH];
    char filename[LY_MAXPATH];
d308 1
d310 7
a316 6
    SetupFilename(filename, sug_filename);
    if (lynx_save_space
	&& (strlen(lynx_save_space) + strlen(filename)) < sizeof(filename)) {
	strcpy(buffer, lynx_save_space);
	strcat(buffer, filename);
	strcpy(filename, buffer);
d318 1
d320 1
a320 1
    switch (RecallFilename(filename, &FirstRecall, &FnameNum,
d332 1
a332 1
    if (!LYValidateFilename(buffer, filename)) {
d339 1
a339 1
    switch (LYValidateOutput(buffer)) {
d354 1
a354 1
    CTRACE((tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c));
d357 1
a357 1
    if (*buffer == '|') {
d363 1
a363 1
	} else if ((outfile_fp = popen(buffer + 1, "w")) == NULL) {
d374 2
a375 2
			   ? LYAppendToTxtFile(buffer)
			   : LYNewTxtFile(buffer))) == NULL) {
d443 1
a443 1
    if (LYIsPipeCommand(buffer))
d450 3
a452 3
    if (0 == strncasecomp(buffer, "sys$disk:", 9)) {
	if (0 == strncmp((buffer + 9), "[]", 2)) {
	    HTAddSugFilename(buffer + 11);
d454 1
a454 1
	    HTAddSugFilename(buffer + 9);
d457 1
a457 1
	HTAddSugFilename(buffer);
d460 1
a460 1
    HTAddSugFilename(buffer);
d464 2
d492 1
a492 1
    char user_response[LINESIZE];
d508 3
a510 6
    LYstrncpy(user_response, personal_mail_address, sizeof(user_response) - 1);
    if (LYgetstr(user_response,
		 VISIBLE,
		 sizeof(user_response),
		 RECALL_MAIL) < 0 ||
	*user_response == '\0') {
d528 1
d530 1
d532 1
d534 1
d553 4
a556 2
    if (strchr(user_response, '@@') && !strchr(user_response, ':') &&
	!strchr(user_response, '%') && !strchr(user_response, '"')) {
d559 2
a560 2
	HTSprintf0(&temp, mail_adrs, user_response);
	LYstrncpy(user_response, temp, sizeof(user_response) - 1);
d650 1
a650 1
		   user_response);
d662 1
a662 1
		   user_response);
d674 2
a675 2
	LYRemoveTemp(hdrfile);
    LYRemoveTemp(my_temp);
d761 1
a761 1
    fprintf(outfile_fp, "To: %s\nSubject: %s\n", user_response, subject);
d783 1
a783 1
    LYSendMailFile(user_response,
d788 1
a788 1
    LYRemoveTemp(my_temp);	/* Delete the tmpfile. */
d793 1
d807 1
a807 1
    char my_file[LY_MAXPATH];
d859 1
d863 1
a863 1
	SetupFilename(my_file, sug_filename);
d865 1
a865 1
	switch (RecallFilename(my_file, &FirstRecall, &FnameNum,
d878 1
a878 1
	    if (*LYPathLeaf(my_file) == '.') {
d890 1
a890 1
	if (LYIsNullDevice(my_file)) {
d893 1
a893 1
	HTAddSugFilename(my_file);
a895 4
    else {
	my_file[0] = '\0';
    }

d897 2
a898 2
    if (my_file[0]) {
	HTAddParam(&the_command, cur_printer->command, 2, my_file);
d905 1
a905 1
    HTAddParam(&the_command, cur_printer->command, 2, my_file);
d932 1
a932 1
    LYRemoveTemp(my_temp);
d956 1
d962 1
a962 1
				BOOLEAN Lpansi)
d965 1
a965 1
    char prompt[80];
d973 2
a974 2
    *prompt = '\0';
    if (LYgetstr(prompt, VISIBLE, sizeof(prompt), NORECALL) < 0) {
d976 2
a977 1
    }
d979 2
a980 4
    outfile_fp = stdout;

    stop_curses();
    SetOutputMode(O_TEXT);
d983 1
a983 1
    signal(SIGINT, SIG_IGN);
d986 16
a1001 16
    if (LYPrependBaseToSource && HTisDocumentSource()) {
	/*
	 * Added the document's base as a BASE tag to the top of the file.  May
	 * create technically invalid HTML, but will help get any partial or
	 * relative URLs resolved properly if no BASE tag is present to replace
	 * it.  - FM
	 */
	fprintf(outfile_fp,
		"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
		newdoc->address, content_base);
    }
    if (Lpansi)
	printf("\033[5i");
    print_wwwfile_to_fd(outfile_fp, FALSE, FALSE);	/* SCREEN */
    if (keypad_mode)
	printlist(outfile_fp, FALSE);
d1004 5
a1008 5
    if (HadVMSInterrupt) {
	HadVMSInterrupt = FALSE;
	start_curses();
	CancelPrint(PRINT_REQUEST_CANCELLED);
    }
d1010 8
a1017 9
    if (Lpansi) {
	printf("\n\014");	/* Form feed */
	printf("\033[4i");
	fflush(stdout);		/* refresh to screen */
	Lpansi = FALSE;
    } else {
	fprintf(stdout, "\n\n%s", PRESS_RETURN_TO_FINISH);
	fflush(stdout);		/* refresh to screen */
	(void) LYgetch();	/* grab some user input to pause */
d1019 1
a1019 1
	HadVMSInterrupt = FALSE;
d1021 1
a1021 1
    }
d1023 1
a1023 1
    fprintf(stdout, "\n");
d1025 3
a1027 2
    SetOutputMode(O_BINARY);
    start_curses();
d1030 1
d1360 3
a1362 3
    char fbuf[LY_MAXPATH];
    char tbuf[LY_MAXPATH];
    char *fn;
d1374 1
a1374 1
    SetupFilename(fbuf, "");
d1381 1
a1381 1
    switch (RecallFilename(fbuf, &FirstRecall, &FnameNum,
d1388 1
a1388 1
	goto quit;
d1398 3
a1400 3
    if (0 == strncasecomp(fbuf, "sys$disk:", 9)) {
	if (0 == strncmp((fbuf + 9), "[]", 2)) {
	    HTAddSugFilename(fbuf + 11);
d1402 1
a1402 1
	    HTAddSugFilename(fbuf + 9);
d1405 1
a1405 1
	HTAddSugFilename(fbuf);
d1408 1
a1408 1
    HTAddSugFilename(fbuf);
d1414 3
a1416 2
    if (!LYValidateFilename(tbuf, fbuf))
	goto quit;
d1421 1
a1421 1
    if ((stat(tbuf, &stat_info) < 0) ||
d1434 1
a1434 1
    if (!LYCanReadFile(tbuf)) {
a1445 4
     *
     * [For some silly reason, if we use StrAllocCopy() here, we get an
     * "invalid pointer" reported in the Lynx.leaks file (if compiled with
     * --enable-find-leaks turned on.  Dumb.]
d1447 1
a1447 2
    if ((fn = typecallocn(char, strlen(tbuf) + 1)) == NULL)
	  outofmem(__FILE__, "GetFileName");
d1449 4
a1452 7
    return (strcpy(fn, tbuf));

  quit:
    /*
     * The user cancelled the input (^G, or CR on empty input field).
     */
    return (NULL);
@


1.6
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d293 2
a294 1
static void send_file_to_file(DocInfo *newdoc, char *content_base,
d464 2
a465 1
static void send_file_to_mail(DocInfo *newdoc, char *content_base,
d790 2
a791 1
static void send_file_to_printer(DocInfo *newdoc, char *content_base,
d953 2
a954 1
static void send_file_to_screen(DocInfo *newdoc, char *content_base,
d1192 1
a1192 1
 * Mail subject may have 8-bit characters and they are in display charset. 
d1276 1
a1276 1
    if (no_print || no_disk_save || child_lynx || no_mail)
d1286 1
a1286 1
    if (child_lynx == FALSE && no_disk_save == FALSE && no_print == FALSE) {
d1295 1
a1295 1
    if (child_lynx == FALSE && no_mail == FALSE && local_host_only == FALSE)
@


1.5
log
@Use fprintf correctly.
OK deraadt@@
@
text
@d17 1
a17 1
#include <LYCharSets.h>  /* To get current charset for mail header. */
d25 2
a26 2
 *  printfile prints out the current file minus the links and targets
 *  to a variety of places
d31 5
a35 5
 *  LYNXPRINT://LOCAL_FILE/lines=##
 *  LYNXPRINT://MAIL_FILE/lines=##
 *  LYNXPRINT://TO_SCREEN/lines=##
 *  LYNXPRINT://LPANSI/lines=##
 *  LYNXPRINT://PRINTER/lines=##/number=#
d60 1
a60 1
PRIVATE int remove_quotes PARAMS((char *string));
d63 1
a63 1
PRIVATE  char* subject_translate8bit PARAMS((char *source));
d72 3
a74 4
PRIVATE void set_environ ARGS3(
	int,		name,
	CONST char *,	value,
	CONST char *,	no_value)
d76 2
a77 1
    static CONST char *names[MAX_PUTENV] = {
d85 1
d89 1
d91 1
a91 1
    if (!(envbuffer && *envbuffer))
d110 1
a110 2
PRIVATE char *suggested_filename ARGS1(
	DocInfo *,	newdoc)
d112 2
a113 1
    char *cp, *sug_filename = 0;
d116 1
a116 1
     *	Load the suggested filename string. - FM
d119 1
a119 1
	StrAllocCopy(sug_filename, HText_getSugFname()); /* must be freed */
d121 1
a121 1
	StrAllocCopy(sug_filename, newdoc->address); /* must be freed */
d123 1
a123 1
     *	Strip any gzip or compress suffix, if present. - FM
d125 4
a128 17
    cp = NULL;
    if (strlen(sug_filename) > 3) {
	cp = (char *)&sug_filename[(strlen(sug_filename) - 3)];
	if ((*cp == '.' || *cp == '-' || *cp == '_') &&
	    !strcasecomp((cp + 1), "gz")) {
	    *cp = '\0';
	} else {
	    cp = NULL;
	}
    }
    if ((cp == NULL) && strlen(sug_filename) > 2) {
	cp = (char *)&sug_filename[(strlen(sug_filename) - 2)];
	if ((*cp == '.' || *cp == '-' || *cp == '_') &&
	    !strcasecomp((cp + 1), "Z")) {
	    *cp = '\0';
	}
    }
d132 2
a133 3
PRIVATE void SetupFilename ARGS2(
	char *,		filename,
	char *,		sug_filename)
d139 1
a139 1
    LYstrncpy(filename, sug_filename, LY_MAXPATH-1);  /* add suggestion info */
d143 2
a144 2
     && (cp = strrchr(filename, '.')) != NULL
     && (cp - filename) < LY_MAXPATH-5) {
d146 1
d152 1
d163 5
a167 6
PRIVATE int RecallFilename ARGS5(
	char *,		filename,
	BOOLEAN *,	first,
	int *,		now,
	int *,		total,
	int,		flag)
d171 1
a171 1
    int recall;
d206 3
a208 4
	    } else if ((cp = (char *)HTList_objectAt(
					    sug_filenames,
					    *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH-1);
d237 3
a239 4
	    } else if ((cp = (char *)HTList_objectAt(
					    sug_filenames,
					    *now)) != NULL) {
		LYstrncpy(filename, cp, LY_MAXPATH-1);
d262 3
a264 4
PRIVATE BOOLEAN confirm_by_pages ARGS3(
	char *,		prompt,
	int,		lines_in_file,
	int,		lines_per_page)
d266 1
a266 1
    int pages = lines_in_file/(lines_per_page+1);
d270 1
a270 1
    if ((lines_in_file % (LYlines+1)) > 0)
d290 2
a291 4
PRIVATE void send_file_to_file ARGS3(
	DocInfo *,	newdoc,
	char *,		content_base,
	char *,		sug_filename)
d295 1
a295 1
    CONST char *disp_charset;
d304 1
a304 1
retry:
d307 1
a307 1
     && (strlen(lynx_save_space) + strlen(filename)) < sizeof(filename)) {
d312 11
a322 11
check_recall:
    switch (RecallFilename(filename,    &FirstRecall, &FnameNum,
			   &FnameTotal, PRINT_FLAG))  {
	case FN_INIT:
	    goto retry;
	case FN_READ:
	    goto check_recall;
	case FN_QUIT:
	    goto done;
	default:
	    break;
d356 1
a356 1
	} else if ((outfile_fp = popen(buffer+1, "w")) == NULL) {
d366 3
a368 3
    if ((outfile_fp = (TOUPPER(c) == 'A'
	    ? LYAppendToTxtFile(buffer)
	    : LYNewTxtFile(buffer))) == NULL) {
d391 1
a391 1
		"<!-- Date: %s -->\n", HText_getDate());
d393 3
a395 2
			&& strcmp(HText_getLastModified(), HText_getDate())
			&& strcmp(HText_getLastModified(), "Thu, 01 Jan 1970 00:00:01 GMT")) {
d397 1
a397 1
		    "<!-- Last-Modified: %s -->\n", HText_getLastModified());
d431 1
a431 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* FILE */
d433 1
a433 1
	printlist(outfile_fp,FALSE);
d444 2
a445 2
	if (0 == strncmp((buffer+9), "[]", 2)) {
	    HTAddSugFilename(buffer+11);
d447 1
a447 1
	    HTAddSugFilename(buffer+9);
d456 1
a456 1
done:
d460 2
a461 4
PRIVATE void send_file_to_mail ARGS3(
	DocInfo *,	newdoc,
	char *,		content_base,
	char *,		content_location)
d471 1
d478 1
a478 1
    CONST char *disp_charset;
d492 1
a492 1
	} else	{
d498 5
a502 2
    LYstrncpy(user_response, personal_mail_address, sizeof(user_response)-1);
    if (LYgetstr(user_response, VISIBLE, sizeof(user_response), RECALL_MAIL) < 0 ||
a540 1

d542 2
a543 2
    if (strchr(user_response,'@@') && !strchr(user_response,':') &&
       !strchr(user_response,'%') && !strchr(user_response,'"')) {
d545 1
d547 1
a547 1
	LYstrncpy(user_response, temp, sizeof(user_response)-1);
d553 2
a554 2
				    ? HTML_SUFFIX
				    : TEXT_SUFFIX,
d595 1
a595 1
	 *	X-URL header. - FM
d606 1
a606 1
     *  Write the contents to a temp file.
d621 1
a621 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
d632 6
a637 6
		"%s %s %s,%s %s",
		system_mail,
		system_mail_flags,
		hdrfile,
		my_temp,
		user_response);
d644 6
a649 6
		"%s %s/subject=\"%.70s\" %s %s",
		system_mail,
		system_mail_flags,
		subject,
		my_temp,
		user_response);
d653 1
a653 1
    SetOutputMode( O_TEXT );
d658 1
a658 1
    SetOutputMode( O_BINARY );
d696 2
a697 2
    /*  Enable this if indicating an 8-bit transfer without
     *  also indicating the charset causes problems. - kw */
d746 1
a746 1
     *  Add the To, Subject, and X-URL headers. - FM
d762 1
a762 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* MAIL */
d770 6
a775 7
    LYSendMailFile (
	    user_response,
	    my_temp,
	    subject,
	    "",
	    "");
    LYRemoveTemp(my_temp); /* Delete the tmpfile. */
d779 1
a779 1
done:	/* send_file_to_mail() */
d785 3
a787 5
PRIVATE void send_file_to_printer ARGS4(
	DocInfo *,	newdoc,
	char *,		content_base,
	char *,		sug_filename,
	int,		printer_number)
d799 2
a800 2
				    ? HTML_SUFFIX
				    : TEXT_SUFFIX,
d817 1
a817 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* PRINTER */
d825 2
a826 1
	int count=0;
d829 1
a829 2
	     count++, cur_printer = cur_printer->next)
	    ; /* null body */
d844 1
a844 1
    if (HTCountCommandArgs (cur_printer->command) >= 2) {
d846 1
a846 1
again:
d848 11
a858 11
check_again:
	switch (RecallFilename(my_file,     &FirstRecall, &FnameNum,
			       &FnameTotal, PRINT_FLAG))  {
	    case FN_INIT:
		goto again;
	    case FN_READ:
		goto check_again;
	    case FN_QUIT:
		goto done;
	    default:
		break;
d879 1
a879 1
#ifdef SH_EX	/* 1999/01/04 (Mon) 09:37:03 */
d884 1
a884 1
    HTAddParam (&the_command, cur_printer->command, 1, my_temp);
d886 2
a887 2
	HTAddParam (&the_command, cur_printer->command, 2, my_file);
	HTEndParam (&the_command, cur_printer->command, 3);
d889 1
a889 1
	HTEndParam (&the_command, cur_printer->command, 2);
d892 3
a894 3
    HTAddParam (&the_command, cur_printer->command, 1, my_temp);
    HTAddParam (&the_command, cur_printer->command, 2, my_file);
    HTEndParam (&the_command, cur_printer->command, 2);
d901 1
a901 1
    LYmove(1,1);
d905 1
a905 1
    SetOutputMode( O_TEXT );
d913 3
a915 3
    SET_ENVIRON(LYNX_PRINT_TITLE,   HText_getTitle(),        "No Title");
    SET_ENVIRON(LYNX_PRINT_URL,     newdoc->address,         "No URL");
    SET_ENVIRON(LYNX_PRINT_DATE,    HText_getDate(),         "No Date");
d926 3
a928 3
    SET_ENVIRON(LYNX_PRINT_TITLE,   "", "");
    SET_ENVIRON(LYNX_PRINT_URL,     "", "");
    SET_ENVIRON(LYNX_PRINT_DATE,    "", "");
d939 1
a939 1
    SetOutputMode( O_BINARY );
d943 1
a943 1
done:	/* send_file_to_printer() */
d947 2
a948 4
PRIVATE void send_file_to_screen ARGS3(
	DocInfo *,	newdoc,
	char *,		content_base,
	BOOLEAN,	Lpansi)
d967 1
a967 1
    SetOutputMode( O_TEXT );
d986 1
a986 1
    print_wwwfile_to_fd(outfile_fp, FALSE);	/* SCREEN */
d1000 1
a1000 1
	fflush(stdout);  /* refresh to screen */
d1003 1
a1003 1
	fprintf(stdout,"\n\n%s", PRESS_RETURN_TO_FINISH);
d1011 1
a1011 1
    fprintf(stdout,"\n");
d1013 1
a1013 1
    SetOutputMode( O_BINARY );
d1016 1
a1016 1
done:	/* send_file_to_screen() */
d1020 1
a1020 2
PUBLIC int printfile ARGS1(
	DocInfo *,	newdoc)
d1035 1
a1035 1
     *	Extract useful info from URL.
d1037 1
a1037 1
    StrAllocCopy(link_info, newdoc->address+12);
d1040 1
a1040 1
     *	Reload the file we want to print into memory.
d1050 1
a1050 1
	return(NOT_FOUND);
d1053 2
a1054 2
     *	If we have an explicit content-base, we may use it even
     *	if not in source mode. - kw
d1059 1
a1059 1
	if (!(content_base && *content_base)) {
d1064 2
a1065 2
     *	If document is source, load the content_base
     *	and content_location strings. - FM
d1071 1
a1071 1
	    if (!(content_location && *content_location)) {
d1090 1
a1090 1
     *	Get the number of lines in the file.
d1094 1
a1094 1
	 *  Terminate prev string here.
d1098 1
a1098 1
	 *  Number of characters in "lines=".
d1106 1
a1106 1
     *	Determine the type.
d1136 1
a1136 1
     *	Act on the request. - FM
d1140 3
a1142 3
	case TO_FILE:
	    send_file_to_file(newdoc, content_base, sug_filename);
	    break;
d1144 3
a1146 3
	case MAIL:
	    send_file_to_mail(newdoc, content_base, content_location);
	    break;
d1148 4
a1151 4
	case TO_SCREEN:
	    if (confirm_by_pages(CONFIRM_LONG_SCREEN_PRINT, lines_in_file, LYlines))
		send_file_to_screen(newdoc, content_base, Lpansi);
	    break;
d1153 4
a1156 4
	case PRINTER:
	    if (confirm_by_pages(CONFIRM_LONG_PAGE_PRINT, lines_in_file, pagelen))
		send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
	    break;
d1158 1
a1158 1
    } /* end switch */
d1164 1
a1164 1
    return(NORMAL);
d1168 1
a1168 2
PRIVATE int remove_quotes ARGS1(
	char *,		string)
d1170 1
a1170 1
   int i;
d1172 7
a1178 7
   for(i = 0; string[i] != '\0'; i++)
	if(string[i] == '"')
	   string[i] = ' ';
	else if(string[i] == '&')
	   string[i] = ' ';
	else if(string[i] == '|')
	   string[i] = ' ';
d1180 1
a1180 1
   return(0);
d1185 8
a1192 9
 *  Mail subject may have 8-bit characters and they are in display charset.
 *  There is no stable practice for 8-bit subject encodings:
 *  MIME defines "quoted-printable" which holds charset info
 *  but most mailers still don't support it.  On the other hand
 *  many mailers send open 8-bit subjects without charset info
 *  and use local assumption for certain countries.  Besides that,
 *  obsolete SMTP software is not 8bit clean but still in use,
 *  it strips the characters in 128-160 range from subjects
 *  which may be a fault outside iso-8859-XX.
d1194 3
a1196 3
 *  We translate subject to "outgoing_mail_charset" (defined in lynx.cfg)
 *  it may correspond to US-ASCII as the safest value or any other
 *  lynx character handler, -1 for no translation (so display charset).
d1198 1
a1198 1
 *  Always returns a new allocated string which has to be freed.
d1201 1
a1201 1
PRIVATE char* subject_translate8bit ARGS1(char *, source)
d1207 1
a1207 1
    int i = outgoing_mail_charset;  /* from lynx.cfg, -1 by default */
d1211 4
a1214 4
     || i == current_char_set
     || LYCharSet_UC[current_char_set].enc == UCT_ENC_CJK
     || LYCharSet_UC[i].enc == UCT_ENC_CJK) {
	return(target); /* OK */
d1217 1
a1217 1
	charset_in  = current_char_set;
d1222 1
a1222 1
    return(target);
d1230 6
a1235 5
 *  LYNXPRINT://LOCAL_FILE/lines=#	     print to a local file
 *  LYNXPRINT://TO_SCREEN/lines=#	     print to the screen
 *  LYNXPRINT://LPANSI/lines=#		     print to the local terminal
 *  LYNXPRINT://MAIL_FILE/lines=#	     mail the file
 *  LYNXPRINT://PRINTER/lines=#/number=#   print to printer number #
d1237 3
a1239 4
PUBLIC int print_options ARGS3(
	char **,	newfile,
	CONST char *,	printed_url,
	int,		lines_in_file)
d1249 1
a1249 1
	return(-1);
d1258 8
a1265 7
    pages = (lines_in_file+65)/66;
    HTSprintf0(&buffer, "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
	    gettext("Document:"), printed_url,
	    gettext("Number of lines:"), lines_in_file,
	    gettext("Number of pages:"), pages,
	    (pages > 1 ? gettext("pages") : gettext("page")),
	    gettext("(approximately)"));
d1270 3
a1272 1
	fprintf(fp0, "   <em>%s</em>\n", gettext("Some print functions have been disabled!"));
d1286 1
a1286 1
	fprintf(fp0,"   <em>%s</em>\n", gettext("Save to disk disabled"));
d1312 10
a1321 10
	cur_printer = cur_printer->next, count++)
    if (no_print == FALSE || cur_printer->always_enabled) {
	fprintf(fp0,
		"   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
		STR_LYNXPRINT,
		count, cur_printer->pagelen, lines_in_file);
	fprintf(fp0, "%s", (cur_printer->name ?
		      cur_printer->name : "No Name Given"));
	fprintf(fp0, "</a>\n");
    }
d1327 1
a1327 1
    return(0);
a1329 1

d1331 1
a1331 1
 *  General purpose filename getter.
d1333 3
a1335 3
 *  Returns a pointer to an absolute filename string, if the input
 *  filename exists, and is readable.  Returns NULL if the input
 *  was cancelled (^G, or CR on empty input).
d1337 2
a1338 2
 *  The pointer to the filename string needs to be free()'d by the
 *  caller (when non-NULL).
d1340 1
a1340 1
 *  --KED  02/21/99
d1342 1
a1342 1
PUBLIC char * GetFileName NOARGS
d1346 2
a1347 2
    char  fbuf[LY_MAXPATH];
    char  tbuf[LY_MAXPATH];
d1351 2
a1352 3
    int     FnameNum    = -1;
    int     FnameTotal;

d1356 1
a1356 1
retry:
d1358 1
a1358 1
     *  No initial filename.
d1360 1
a1360 1
    SetupFilename (fbuf, "");
d1362 1
a1362 1
check_recall:
d1364 2
a1365 2
     *  Go get a filename (it would be nice to do TAB == filename-completion
     *  as the name is entered, but we'll save doing that for another time.
d1367 10
a1376 10
    switch (RecallFilename (fbuf,        &FirstRecall,  &FnameNum,
			    &FnameTotal, GENERIC_FLAG)) {
	case FN_INIT:
	    goto retry;
	case FN_READ:
	    goto check_recall;
	case FN_QUIT:
	    goto quit;
	default:
	    break;
d1380 2
a1381 2
     *  Add raw input form to list ... we may want to reuse/edit it on a
     *  subsequent call, etc.
d1384 3
a1386 3
    if (0 == strncasecomp (fbuf, "sys$disk:", 9)) {
	if (0 == strncmp ((fbuf+9), "[]", 2)) {
	    HTAddSugFilename (fbuf+11);
d1388 1
a1388 1
	    HTAddSugFilename (fbuf+9);
d1391 1
a1391 1
	HTAddSugFilename (fbuf);
d1394 1
a1394 1
    HTAddSugFilename (fbuf);
d1398 1
a1398 1
     *  Expand tilde's, make filename absolute, etc.
d1400 1
a1400 1
    if (!LYValidateFilename (tbuf, fbuf))
d1404 1
a1404 1
     *  Check for file existence; readability.
d1406 2
a1407 2
    if ((stat (tbuf, &stat_info) < 0) ||
       (!(S_ISREG(stat_info.st_mode)
d1409 1
a1409 1
	 || S_ISLNK(stat_info.st_mode)
d1411 2
a1412 2
	))) {
	HTInfoMsg (FILE_DOES_NOT_EXIST);
d1415 1
a1415 1
	FnameNum    = FnameTotal;
d1420 1
a1420 1
	HTInfoMsg (FILE_NOT_READABLE);
d1423 1
a1423 1
	FnameNum    = FnameTotal;
d1428 1
a1428 2
     *  We have a valid filename, and readable file.  Return it to the
     *  caller.
d1430 1
a1430 1
     *  The returned pointer should be free()'d by the caller.
d1432 3
a1434 3
     *  [For some silly reason, if we use StrAllocCopy() here, we get an
     *   "invalid pointer" reported in the Lynx.leaks file (if compiled
     *   with  --enable-find-leaks  turned on.  Dumb.]
d1436 2
a1437 3
    if ((fn = typecallocn(char, strlen (tbuf) + 1)) == NULL)
	outofmem(__FILE__, "GetFileName");
    return (strcpy (fn, tbuf));
d1439 1
d1441 1
a1441 1
quit:
d1443 1
a1443 1
     *  The user cancelled the input (^G, or CR on empty input field).
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d1336 1
a1336 1
	fprintf(fp0, (cur_printer->name ?
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d109 1
a109 1
	document *,	newdoc)
d160 1
a160 1
	    strcpy(cp, ".txt");
d305 1
a305 1
	document *,	newdoc,
d365 1
a365 1
#if HAVE_POPEN
d450 1
a450 1
#if HAVE_POPEN
d476 1
a476 1
	document *,	newdoc,
d500 3
d567 1
a567 1
				    : ".txt",
d574 1
a574 1
	if ((hfd = LYOpenTemp(hdrfile, ".txt", "w")) == NULL) {
d681 1
a681 1
    outfile_fp = LYOpenTemp(my_temp, ".txt", "w");
d800 1
a800 1
	document *,	newdoc,
d816 1
a816 1
				    : ".txt",
d888 1
a888 1
	 * (case-insensitive) on VMS.  - FM
d890 1
a890 11
#ifdef VMS
	if (!strncasecomp(my_file, "nl:", 3) ||
	    !strncasecomp(my_file, "/nl/", 4))
#else
#if defined(DOSPATH)	/* 1997/10/15 (Wed) 16:41:30 */
	if (!strcmp(my_file, "nul"))
#else
	if (!strcmp(my_file, "/dev/null"))
#endif /* DOSPATH */
#endif /* VMS */
	{
d964 1
a964 1
	document *,	newdoc,
d1039 1
a1039 1
	document *,	newdoc)
d1207 2
a1208 2
 *  MIME define "quoted-printable" which holds charset info
 *  but most mailers still don't support it, on the other hand
d1269 1
a1269 8
    if (LYReuseTempfiles) {
	fp0 = LYOpenTempRewrite(my_temp, HTML_SUFFIX, "w");
    } else {
	LYRemoveTemp(my_temp);
	fp0 = LYOpenTemp(my_temp, HTML_SUFFIX, "w");
    }
    if (fp0 == NULL) {
	HTAlert(UNABLE_TO_OPEN_PRINTOP_FILE);
a1270 1
    }
d1299 2
a1300 1
		"   <a href=\"LYNXPRINT://LOCAL_FILE/lines=%d\">%s</a>\n",
d1308 2
a1309 1
		"   <a href=\"LYNXPRINT://MAIL_FILE/lines=%d\">%s</a>\n",
d1313 1
a1313 1
#ifndef DOSPATH
d1315 2
a1316 1
	    "   <a href=\"LYNXPRINT://TO_SCREEN/lines=%d\">%s</a>\n",
d1320 2
a1321 1
	    "   <a href=\"LYNXPRINT://LPANSI/lines=%d\">%s</a>\n",
d1333 2
a1334 1
		"   <a href=\"LYNXPRINT://PRINTER/number=%d/pagelen=%d/lines=%d\">",
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d59 1
a59 1
#ifdef VMS
d61 1
a61 1
#endif /* VMS */
d191 1
a191 1
    recall = ((*total >= 1) ? RECALL : NORECALL);
d295 1
a295 1
	    addstr("   Ok...");
d363 1
a363 1
    CTRACE(tfp, "LYPrint: filename is %s, action is `%c'\n", buffer, c);
d373 1
a373 1
	    CTRACE(tfp, "LYPrint: errno is %d\n", errno);
d385 1
a385 1
	CTRACE(tfp, "LYPrint: errno is %d\n", errno);
d405 2
a406 2
	if (HText_getDate() != NULL)
	     fprintf(outfile_fp,
d408 8
d446 1
a446 1
    print_wwwfile_to_fd(outfile_fp,0);
d455 2
a456 1
    fclose(outfile_fp);
d482 2
a483 2
#ifdef VMS
    BOOLEAN isPMDF = !strncasecomp(system_mail, "PMDF SEND", 9);
a485 1
    char my_temp[LY_MAXPATH];
d487 2
a488 1
#ifdef DOSPATH
a492 1
    BOOL use_mime;
d503 1
a503 1
	    addstr("   Ok...");
d512 1
a512 1
    if (LYgetstr(user_response, VISIBLE, sizeof(user_response), NORECALL) < 0 ||
d533 1
a533 1
    use_type =  (disp_charset || HTisDocumentSource());
d540 1
a540 1
   subject = subject_translate8bit(newdoc->title);
d542 8
a549 8
   if (newdoc->isHEAD) {
	   /*
	    * Special case for mailing HEAD responce:  this is rather technical
	    * information, show URL.
	    */
	   FREE(subject);
	   StrAllocCopy(subject, "HEAD  ");
	   StrAllocCat(subject, newdoc->address);
d552 1
a552 1
#ifdef VMS
d608 5
d631 1
a631 1
    print_wwwfile_to_fd(outfile_fp, 0);
d636 1
a638 5
	 * For PMDF, put the subject in the header file and close it.  - FM
	 */
	fprintf(hfd, "Subject: %.70s\n\n", subject);
	LYCloseTempFP(hfd);
	/*
d663 1
d666 1
a666 1
    sleep(AlertSecs);
d668 2
d673 1
a673 1
#else /* Unix or DOS */
d675 3
a677 1
#ifdef DOSPATH
a678 3
#else
    HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
    outfile_fp = popen(buffer, "w");
d711 2
a712 2
    use_type = (disp_charset || HTisDocumentSource());
    use_mime = (use_cte || use_type);
d772 1
a772 1
    print_wwwfile_to_fd(outfile_fp, 0);
d776 10
a785 8
#ifdef DOSPATH
    HTSprintf0(&buffer, "%s -t \"%s\" -F %s", system_mail, user_response, my_temp);
    LYCloseTempFP(outfile_fp);	/* Close the tmpfile. */
    stop_curses();
    printf("%s\n\n$ %s\n\n%s", gettext("Sending"), buffer, PLEASE_WAIT);
    LYSystem(buffer);
    sleep(MessageSecs);
    start_curses();
d787 2
a788 4
#else
    pclose(outfile_fp);
#endif
#endif /* VMS */
d790 1
a790 1
done:
d808 1
a808 1
    lynx_printer_item_type *cur_printer;
d830 1
a830 1
    print_wwwfile_to_fd(outfile_fp, 0);
d891 3
d895 1
d902 4
d908 8
d918 1
d924 1
a924 1
    move(1,1);
d927 2
a928 1
    CTRACE(tfp, "command: %s\n", the_command);
d958 6
a963 1
    sleep(MessageSecs);
d966 1
a966 1
done:
d992 2
d1011 1
a1011 1
    print_wwwfile_to_fd(outfile_fp, 0);
d1025 1
d1029 2
a1030 1
	LYgetch();  /* grab some user input to pause */
d1035 4
a1038 1
    fflush(stdout);  /* refresh to screen */
d1041 1
a1041 1
done:
d1118 1
a1118 1
    if ((cp = (char *)strstr(link_info, "lines=")) != NULL) {
d1146 1
a1146 1
	if ((cp = (char *)strstr(link_info, "number=")) != NULL) {
d1151 1
a1151 1
	if ((cp = (char *)strstr(link_info, "pagelen=")) != NULL) {
d1193 1
a1193 1
#ifdef VMS
d1209 1
a1209 1
#endif /* VMS */
d1228 1
a1230 2
    CONST char *p = source;
    char temp[2];
a1233 1
    char replace_buf [10];
d1237 1
a1241 1
	StrAllocCopy(target, source);
d1248 1
a1248 10
    for ( ; *p; p++) {
	LYstrncpy(temp, p, sizeof(temp)-1);
	if ((unsigned char)*temp <= 127) {
	    StrAllocCat(target, temp);
	} else {
	    if (UCTransCharStr(replace_buf, sizeof(replace_buf), *temp,
				charset_in, charset_out, YES) > 0)
		StrAllocCat(target, replace_buf);
	}
    }
d1266 1
a1266 1
	char **,	printed_url,
d1269 1
a1269 1
    static char my_temp[LY_MAXPATH];
d1274 1
a1274 1
    lynx_printer_item_type *cur_printer;
d1276 7
a1282 2
    LYRemoveTemp(my_temp);
    if ((fp0 = LYOpenTemp(my_temp, HTML_SUFFIX, "w")) == NULL) {
d1296 1
a1296 1
	    gettext("Document:"), *printed_url,
a1374 2
    FILE *fp;

d1449 1
a1449 1
    if ((fp = fopen (tbuf, "r")) == NULL) {
a1454 2
    } else {
	fclose (fp);
d1467 1
a1467 1
    if ((fn = (char *) calloc (1, (strlen (tbuf) + 1))) == NULL)
@


1.1
log
@Initial revision
@
text
@d1 17
a17 25
#include "HTUtils.h"
#include "tcp.h"
#include "HTAccess.h"
#include "HTList.h"
#include "HTAlert.h"
#include "HTFile.h"
#include "LYCurses.h"
#include "GridText.h"
#include "LYUtils.h"
#include "LYPrint.h"
#include "LYGlobalDefs.h"
#include "LYSignal.h"
#include "LYStrings.h"
#include "LYClean.h"
#include "LYGetFile.h"
#include "LYHistory.h"
#include "LYSystem.h"
#include "LYList.h"
#include "LYCharSets.h"  /* To get current charset for mail header. */
#ifdef VMS
#include "HTVMSUtils.h"
#endif /* VMS */
#ifdef DOSPATH
#include "HTDOS.h"
#endif
d19 1
a19 1
#include "LYLeaks.h"
d21 2
a22 1
#define FREE(x) if (x) {free(x); x = NULL;}
d26 1
a26 1
 *  to a veriaty of places
d34 1
d40 18
a57 2
#define MAIL	  3
#define PRINTER   4
d63 13
a75 2
PUBLIC int printfile ARGS1(
	document *,	newdoc)
d77 18
a94 37
    static char tempfile[256];
    static BOOLEAN first = TRUE;
    char buffer[LINESIZE];
    char filename[LINESIZE];
    char user_response[256];
    int lines_in_file = 0;
    int printer_number = 0;
    int pages = 0;
    int type = 0, c, len;
    FILE *outfile_fp;
    char *cp = NULL;
    lynx_printer_item_type *cur_printer;
    char *sug_filename = NULL;
    char *link_info = NULL;
    DocAddress WWWDoc;
    int pagelen = 0;
    int ch, recall;
    int FnameTotal;
    int FnameNum;
    BOOLEAN FirstRecall = TRUE;
    char *content_base = NULL, *content_location = NULL;
    HTFormat format;
    HTAtom *encoding;
    BOOL use_mime, use_cte, use_type;
    CONST char *disp_charset;
    static BOOLEAN first_mail_preparsed = TRUE;
    char *envbuffer = NULL;
#ifdef VMS
    BOOLEAN isPMDF = FALSE;
    char hdrfile[256];
    FILE *hfd;

    if (!strncasecomp(system_mail, "PMDF SEND", 9)) {
	isPMDF = TRUE;
    }
#endif /* VMS */

d96 2
a97 1
     *	Extract useful info from URL.
d99 8
a106 1
    StrAllocCopy(link_info, newdoc->address+12);
d108 4
a111 47
    /*
     *	Reload the file we want to print into memory.
     */
    LYpop(newdoc);
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    if (!HTLoadAbsolute(&WWWDoc))
	return(NOT_FOUND);

    /*
     *	If we have an explicit content-base, we may use it even
     *	if not in source mode. - kw
     */
    if (HText_getContentBase()) {
	StrAllocCopy(content_base, HText_getContentBase());
	collapse_spaces(content_base);
	if (!(content_base && *content_base)) {
	    FREE(content_base);
	}
    }
    /*
     *	If document is source, load the content_base
     *	and content_location strings. - FM
     */
    if (HTisDocumentSource()) {
	if (HText_getContentLocation()) {
	    StrAllocCopy(content_location, HText_getContentLocation());
	    collapse_spaces(content_location);
	    if (!(content_location && *content_location)) {
		FREE(content_location);
	    }
	}
	if (!content_base) {
	    if ((content_location) && is_url(content_location)) {
		StrAllocCopy(content_base, content_location);
	    } else {
		StrAllocCopy(content_base, newdoc->address);
	    }
	}
	if (!content_location) {
	    StrAllocCopy(content_location, newdoc->address);
	}
    }
d116 1
a116 1
    if (HText_getSugFname() != NULL)
d140 43
a182 1
    cp = NULL;
d185 1
a185 1
     *	Get the number of lines in the file.
d187 75
a261 1
    if ((cp = (char *)strstr(link_info, "lines=")) != NULL) {
d263 1
a263 5
	 *  Terminate prev string here.
	 */
	*cp = '\0';
	/*
	 *  Number of characters in "lines=".
d265 4
a268 1
	cp += 6;
d270 1
a270 2
	lines_in_file = atoi(cp);
	pages = lines_in_file/66;
d272 2
d275 18
a292 11
    /*
     *	Determine the type.
     */
    if (strstr(link_info, "LOCAL_FILE")) {
	type = TO_FILE;
    } else if (strstr(link_info, "TO_SCREEN")) {
	type = TO_SCREEN;
    } else if (strstr(link_info, "MAIL_FILE")) {
	type = MAIL;
    } else if (strstr(link_info, "PRINTER")) {
	type = PRINTER;
d294 2
a295 9
	if ((cp = (char *)strstr(link_info, "number=")) != NULL) {
	    /* number of characters in "number=" */
	    cp += 7;
	    printer_number = atoi(cp);
	}
	if ((cp = (char *)strstr(link_info, "pagelen=")) != NULL) {
	    /* number of characters in "pagelen=" */
	    cp += 8;
	    pagelen = atoi(cp);
d297 2
a298 2
	    /* default to 66 lines */
	    pagelen = 66;
d301 43
d346 1
a346 1
     *	Set up the sug_filenames recall buffer.
d348 11
a358 3
    FnameTotal = (sug_filenames ? HTList_count(sug_filenames) : 0);
    recall = ((FnameTotal >= 1) ? RECALL : NORECALL);
    FnameNum = FnameTotal;
d361 1
a361 1
     *	Act on the request. - FM
d363 74
a436 103
    switch (type) {
	case TO_FILE:
#if defined(__DJGPP__) || defined(_WINDOWS)
		_fmode = O_TEXT;
#endif /* __DJGPP__  or _WINDOWS */
		_statusline(FILENAME_PROMPT);
	retry:	strcpy(filename, sug_filename);  /* add suggestion info */
		/* make the sug_filename conform to system specs */
		change_sug_filename(filename);
		if (!(HTisDocumentSource()) &&
		    (cp = strrchr(filename, '.')) != NULL) {
		    format = HTFileFormat(filename, &encoding, NULL);
		    if (!strcasecomp(format->name, "text/html") ||
			!IsUnityEnc(encoding)) {
			*cp = '\0';
			strcat(filename, ".txt");
		    }
		}
		if (lynx_save_space && *lynx_save_space) {
		    strcpy(buffer, lynx_save_space);
		    strcat(buffer, filename);
		    strcpy(filename, buffer);
		}
	check_recall:
		if ((ch = LYgetstr(filename, VISIBLE,
				   sizeof(filename), recall)) < 0 ||
		    *filename == '\0' || ch == UPARROW || ch == DNARROW) {
		    if (recall && ch == UPARROW) {
			if (FirstRecall) {
			    FirstRecall = FALSE;
			    /*
			     *	Use the last Fname in the list. - FM
			     */
			    FnameNum = 0;
			} else {
			    /*
			     *	Go back to the previous Fname
			     *	in the list. - FM
			     */
			    FnameNum++;
			}
			if (FnameNum >= FnameTotal) {
			    /*
			     *	Reset the FirstRecall flag,
			     *	and use sug_file or a blank. - FM
			     */
			    FirstRecall = TRUE;
			    FnameNum = FnameTotal;
			    _statusline(FILENAME_PROMPT);
			    goto retry;
			} else if ((cp = (char *)HTList_objectAt(
							sug_filenames,
							FnameNum)) != NULL) {
			    strcpy(filename, cp);
			    if (FnameTotal == 1) {
				_statusline(EDIT_THE_PREV_FILENAME);
			    } else {
				_statusline(EDIT_A_PREV_FILENAME);
			    }
			    goto check_recall;
			}
		    } else if (recall && ch == DNARROW) {
			if (FirstRecall) {
			    FirstRecall = FALSE;
			    /*
			     * Use the first Fname in the list. - FM
			     */
			    FnameNum = FnameTotal - 1;
			} else {
			    /*
			     * Advance to the next Fname in the list. - FM
			     */
			    FnameNum--;
			}
			if (FnameNum < 0) {
			    /*
			     *	Set the FirstRecall flag,
			     *	and use sug_file or a blank. - FM
			     */
			    FirstRecall = TRUE;
			    FnameNum = FnameTotal;
			    _statusline(FILENAME_PROMPT);
			    goto retry;
			} else if ((cp = (char *)HTList_objectAt(
							sug_filenames,
							FnameNum)) != NULL) {
			    strcpy(filename, cp);
			    if (FnameTotal == 1) {
				_statusline(EDIT_THE_PREV_FILENAME);
			    } else {
				_statusline(EDIT_A_PREV_FILENAME);
			    }
			    goto check_recall;
			}
		    }

		    /*
		     *	Save cancelled.
		     */
		    _statusline(SAVE_REQUEST_CANCELLED);
		    sleep(InfoSecs);
		    break;
		}
d438 10
a447 2
		if (no_dotfiles || !show_dotfiles) {
		    if (*filename == '.' ||
d449 9
a457 18
			((cp = strrchr(filename, ':')) && *(cp+1) == '.') ||
			((cp = strrchr(filename, ']')) && *(cp+1) == '.') ||
#endif /* VMS */
			((cp = strrchr(filename, '/')) && *(cp+1) == '.')) {
			HTAlert(FILENAME_CANNOT_BE_DOT);
			_statusline(NEW_FILENAME_PROMPT);
			FirstRecall = TRUE;
			FnameNum = FnameTotal;
			goto retry;
		    }
		}
		/*
		 *  Cancel if the user entered "/dev/null" on Unix,
		 *  or an "nl:" path (case-insensitive) on VMS. - FM
		 */
#ifdef VMS
		if (!strncasecomp(filename, "nl:", 3) ||
		    !strncasecomp(filename, "/nl/", 4))
d459 1
a459 1
		if (!strcmp(filename, "/dev/null"))
d461 12
a472 13
		{
		    _statusline(SAVE_REQUEST_CANCELLED);
		    sleep(InfoSecs);
		    break;
		}
		if ((cp = strchr(filename, '~'))) {
		    *(cp++) = '\0';
		    strcpy(buffer, filename);
		    if ((len=strlen(buffer)) > 0 && buffer[len-1] == '/')
			buffer[len-1] = '\0';
#ifdef DOSPATH
		    strcat(buffer, HTDOS_wwwName((char *)Home_Dir()));
#else
d474 4
a477 31
		    strcat(buffer, HTVMS_wwwName((char *)Home_Dir()));
#else
		    strcat(buffer, Home_Dir());
#endif /* VMS */
#endif /* DOSPATH */
		    strcat(buffer, cp);
		    strcpy(filename, buffer);
		}
#ifdef VMS
		if (strchr(filename, '/') != NULL) {
		    strcpy(buffer, HTVMS_name("", filename));
		    strcpy(filename, buffer);
		}
		if (filename[0] != '/' && strchr(filename, ':') == NULL) {
		    strcpy(buffer, "sys$disk:");
		    if (strchr(filename, ']') == NULL)
		    strcat(buffer, "[]");
		    strcat(buffer, filename);
		} else {
		    strcpy(buffer, filename);
		}
#else
		if (*filename != '/')
		    cp = getenv("PWD");
		else
		    cp = NULL;
		if (cp)
#ifdef DOSPATH
		    sprintf(buffer, "%s/%s", cp, HTDOS_name(filename));
#else
		    sprintf(buffer, "%s/%s", cp, filename);
a478 1
		else
d480 1
a480 3
		    strcpy(buffer, HTDOS_name(filename));
#else
		    strcpy(buffer, filename);
a481 1
#endif /* VMS */
d483 18
a500 34
		/*
		 *  See if it already exists.
		 */
		if ((outfile_fp = fopen(buffer, "r")) != NULL) {
		    fclose(outfile_fp);
#ifdef VMS
		    _statusline(FILE_EXISTS_HPROMPT);
#else
		    _statusline(FILE_EXISTS_OPROMPT);
#endif /* VMS */
		    c = 0;
		    while (TOUPPER(c)!='Y' && TOUPPER(c)!='N' &&
			   c != 7 && c != 3)
			c = LYgetch();
#ifdef VMS
		    if (HadVMSInterrupt) {
			HadVMSInterrupt = FALSE;
			_statusline(SAVE_REQUEST_CANCELLED);
			sleep(InfoSecs);
			break;
		    }
#endif /* VMS */
		    if (c == 7 || c == 3) { /* Control-G or Control-C */
			_statusline(SAVE_REQUEST_CANCELLED);
			sleep(InfoSecs);
			break;
		    }
		    if (TOUPPER(c) == 'N') {
			_statusline(NEW_FILENAME_PROMPT);
			FirstRecall = TRUE;
			FnameNum = FnameTotal;
			goto retry;
		    }
		}
d502 6
a507 7
		if ((outfile_fp = LYNewTxtFile(buffer)) == NULL) {
		    HTAlert(CANNOT_WRITE_TO_FILE);
		    _statusline(NEW_FILENAME_PROMPT);
		    FirstRecall = TRUE;
		    FnameNum = FnameTotal;
		    goto retry;
		}
d509 17
a525 13
		if (LYPrependBaseToSource && HTisDocumentSource()) {
		    /*
		     *	Added the document's base as a BASE tag
		     *	to the top of the file.  May create
		     *	technically invalid HTML, but will help
		     *	get any partial or relative URLs resolved
		     *	properly if no BASE tag is present to
		     *	replace it. - FM
		     */
		    fprintf(outfile_fp,
			    "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n",
			    newdoc->address, content_base);
		}
d527 6
a532 29
		if (LYPrependCharsetToSource && HTisDocumentSource()) {
		    /*
		     *	Added the document's charset as a META CHARSET tag
		     *	to the top of the file.  May create
		     *	technically invalid HTML, but will help to resolve
		     *	properly the document converted via chartrans:
		     *	printed document correspond to a display charset
		     *	and we *should* override both assume_local_charset
		     *	and original document's META CHARSET (if any).
		     *
		     *	Currently, if several META CHARSETs are found Lynx uses
		     *	the first only, and it is opposite to BASE where the
		     *	original BASE in the <HEAD> overrides ones from the
		     *	top.
		     *
		     *	As in print-to-email we write charset only if the
		     *	document has 8-bit characters, and we have no CJK or an
		     *	unofficial "x-" charset.
		     */
		     use_cte = HTLoadedDocumentEightbit();
		     disp_charset = LYCharSet_UC[current_char_set].MIMEname;
		     if (!use_cte || LYHaveCJKCharacterSet ||
			  strncasecomp(disp_charset, "x-", 2) == 0) {
		     } else {
			fprintf(outfile_fp,
				"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
				disp_charset);
			}
		}
d534 9
a542 3
		print_wwwfile_to_fd(outfile_fp,0);
		if (keypad_mode)
		    printlist(outfile_fp,FALSE);
a543 1
		fclose(outfile_fp);
d545 16
a560 16
		if (0 == strncasecomp(buffer, "sys$disk:", 9)) {
		    if (0 == strncmp((buffer+9), "[]", 2)) {
			HTAddSugFilename(buffer+11);
		    } else {
			HTAddSugFilename(buffer+9);
		    }
		} else {
		    HTAddSugFilename(buffer);
		}
#else
		HTAddSugFilename(buffer);
#endif /* VMS */
#if defined(__DJGPP__) || defined(_WINDOWS)
		_fmode = O_BINARY;
#endif /* __DJGPP__ or _WINDOWS */
		break;
d562 32
a593 25
	case MAIL:
	    if (LYPreparsedSource && first_mail_preparsed &&
		HTisDocumentSource()) {
		_statusline(CONFIRM_MAIL_SOURCE_PREPARSED);
		c = 0;
		while (TOUPPER(c)!='Y' && TOUPPER(c)!='N' &&
		       c != 7 && c != 3)
		    c = LYgetch();
#ifdef VMS
		if (HadVMSInterrupt) {
		    HadVMSInterrupt = FALSE;
		    _statusline(MAIL_REQUEST_CANCELLED);
		    sleep(InfoSecs);
		    break;
		}
#endif /* VMS */
		if (c == RTARROW || c == 'y' || c== 'Y'
		    || c == '\n' || c == '\r') {
		    addstr("   Ok...");
		    first_mail_preparsed = FALSE;
		} else	{
		    _statusline(MAIL_REQUEST_CANCELLED);
		    sleep(InfoSecs);
		    break;
		}
d595 27
d623 39
a661 10
		_statusline(MAIL_ADDRESS_PROMPT);
		strcpy(user_response, (personal_mail_address ?
				       personal_mail_address : ""));
		if (LYgetstr(user_response, VISIBLE,
			     sizeof(user_response), NORECALL) < 0 ||
		    *user_response == '\0') {
		    _statusline(MAIL_REQUEST_CANCELLED);
		    sleep(InfoSecs);
		    break;
		}
d663 9
a671 21
		/*
		 *  Determine which mail headers should be sent.
		 *  Use Content-Type and MIME-Version headers only
		 *  if needed.	We need them if we are mailing HTML
		 *  source, or if we have 8-bit characters and will
		 *  be sending Content-Transfer-Encoding to indicate
		 *  this.  We will append a charset parameter to the
		 *  Content-Type if we do not have an "x-" charset,
		 *  and we will include the Content-Transfer-Encoding
		 *  only if we are appending the charset parameter,
		 *  because indicating an 8-bit transfer without also
		 *  indicating the charset can cause problems with
		 *  many mailers. - FM & KW
		 */
		disp_charset = LYCharSet_UC[current_char_set].MIMEname;
		use_cte = HTLoadedDocumentEightbit();
		if (!(use_cte && strncasecomp(disp_charset, "x-", 2))) {
		    disp_charset = NULL;
		    use_cte = FALSE;
		}
		use_type =  (disp_charset || HTisDocumentSource());
d673 29
a701 7
		change_sug_filename(sug_filename);
#ifdef VMS
		if (strchr(user_response,'@@') && !strchr(user_response,':') &&
		   !strchr(user_response,'%') && !strchr(user_response,'"')) {
		    sprintf(filename, mail_adrs, user_response);
		    strcpy(user_response, filename);
		}
d703 6
a708 35
		if (first) {
		    tempname(tempfile, NEW_FILE);
		    if (isPMDF) {
			tempname(hdrfile, NEW_FILE);
			if ((len = strlen(hdrfile)) > 4) {
			    len -= 5;
			    if (!strcasecomp((hdrfile + len), ".html")) {
				hdrfile[len] = '\0';
				strcat(hdrfile, ".txt");
			    }
			}
		    }
		    first = FALSE;
		} else {
		    remove(tempfile);	/* remove duplicates */
		}
		if (HTisDocumentSource()) {
		    if ((len = strlen(tempfile)) > 3) {
			len -= 4;
			if (!strcasecomp((tempfile + len), ".txt")) {
			    tempfile[len] = '\0';
			    strcat(tempfile, ".html");
			}
		    }
		} else if ((len = strlen(tempfile)) > 4) {
		    len -= 5;
		    if (!strcasecomp((tempfile + len), ".html")) {
			tempfile[len] = '\0';
			strcat(tempfile, ".txt");
		    }
		}
		if ((outfile_fp = LYNewTxtFile(tempfile)) == NULL) {
		    HTAlert(UNABLE_TO_OPEN_TEMPFILE);
		    break;
		}
d710 33
a742 48
		if (isPMDF) {
		    if ((hfd = LYNewTxtFile(hdrfile)) == NULL) {
			HTAlert(UNABLE_TO_OPEN_TEMPFILE);
			break;
		    }
		    if (use_type) {
			fprintf(hfd, "Mime-Version: 1.0\n");
			if (use_cte) {
			    fprintf(hfd,
				    "Content-Transfer-Encoding: 8bit\n");
			}
		    }
		    if (HTisDocumentSource()) {
			/*
			 *  Add Content-Type, Content-Location, and
			 *  Content-Base headers for HTML source. - FM
			 */
			fprintf(hfd, "Content-Type: text/html");
			if (disp_charset != NULL) {
			    fprintf(hfd,
				    "; charset=%s\n",
				    disp_charset);
			} else {
			    fprintf(hfd, "\n");
			}
			fprintf(hfd,
				"Content-Base: %s\n",
				content_base);
			fprintf(hfd,
				"Content-Location: %s\n",
				content_location);
		    } else {
			/*
			 *  Add Content-Type: text/plain if we have 8-bit
			 *  characters and a valid charset for non-source
			 *  documents. - FM
			 */
			if (disp_charset != NULL) {
			    fprintf(hfd,
				    "Content-Type: text/plain; charset=%s\n",
				    disp_charset);
			}
		    }
		    /*
		     *	X-URL header. - FM
		     */
		    fprintf(hfd, "X-URL: %s\n", newdoc->address);
		}
d744 5
a748 54
		/*
		 *  Write the contents to a temp file.
		 */
		if (LYPrependBaseToSource && HTisDocumentSource()) {
		    /*
		     *	Added the document's base as a BASE tag to
		     *	the top of the message body.  May create
		     *	technically invalid HTML, but will help
		     *	get any partial or relative URLs resolved
		     *	properly if no BASE tag is present to
		     *	replace it. - FM
		     */
		    fprintf(outfile_fp,
			    "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
			    newdoc->address, content_base);
		} else if (!isPMDF) {
		    fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);
		}
		print_wwwfile_to_fd(outfile_fp, 0);
		if (keypad_mode)
		    printlist(outfile_fp, FALSE);
		fclose(outfile_fp);

		if (isPMDF) {
		    /*
		     *	For PMDF, put the subject in the
		     *	header file and close it. - FM
		     */
		    fprintf(hfd, "Subject: %.70s\n\n", sug_filename);
		    fclose(hfd);
		    /*
		     *	Now set up the command. - FM
		     */
		    sprintf(buffer,
			    "%s %s %s,%s %s",
			    system_mail,
			    system_mail_flags,
			    hdrfile,
			    tempfile,
			    user_response);
		} else {
		    /*
		     *	For "generic" VMS MAIL, include
		     *	the subject in the command. - FM
		     */
		    remove_quotes(sug_filename);
		    sprintf(buffer,
			    "%s %s/subject=\"%.70s\" %s %s",
			    system_mail,
			    system_mail_flags,
			    sug_filename,
			    tempfile,
			    user_response);
		}
d750 14
a763 15
		stop_curses();
		printf(MAILING_FILE);
		fflush(stdout);
		system(buffer);
		fflush(stdout);
		sleep(AlertSecs);
		start_curses();
		if (isPMDF) {
		    /*
		     *	Delete the header file. - FM
		     */
		    remove(hdrfile);
		}
#else /* Unix: */
		sprintf(buffer, "%s %s", system_mail, system_mail_flags);
d766 8
a773 6
		sprintf(tempfile, "%s%s", lynx_temp_space, "temp_mail.txt");
		if ((outfile_fp = LYNewTxtFile(tempfile)) == NULL) {
			_statusline(MAIL_REQUEST_FAILED);
			sleep(AlertSecs);
			return;
		}
d775 1
a775 5
		if ((outfile_fp = popen(buffer, "w")) == NULL) {
			_statusline(MAIL_REQUEST_FAILED);
			sleep(AlertSecs);
			break;
		}
d777 1
d779 28
a806 32
		/*
		 *  Determine which mail headers should be sent.
		 *  Use Content-Type and MIME-Version headers only
		 *  if needed.	We need them if we are mailing HTML
		 *  source, or if we have 8-bit characters and will
		 *  be sending Content-Transfer-Encoding to indicate
		 *  this.
		 *
		 *  Send Content-Transfer-Encoding only if the document
		 *  has 8-bit characters.  Send a charset parameter only
		 *  if the document has 8-bit characters and we we seem
		 *  to have a valid charset.  - kw
		 */
		use_cte = HTLoadedDocumentEightbit();
		disp_charset = LYCharSet_UC[current_char_set].MIMEname;
		/*
		 *  Don't send a charset if we have a CJK character set
		 *  selected, since it may not be appropriate for mail...
		 *  Also don't use an inofficial "x-" charset. - kw
		 */
		if (!use_cte || LYHaveCJKCharacterSet ||
		    strncasecomp(disp_charset, "x-", 2) == 0) {
		    disp_charset = NULL;
		}
#ifdef NOTDEFINED
		/*  Enable this if indicating an 8-bit transfer without
		 *  also indicating the charset causes problems. - kw */
		if (use_cte && !disp_charse)
		    use_cte = FALSE;
#endif /* NOTDEFINED */
		use_type =  (disp_charset || HTisDocumentSource());
		use_mime = (use_cte || use_type);
d808 25
a832 7
		if (use_mime) {
		    fprintf(outfile_fp, "Mime-Version: 1.0\n");
		    if (use_cte) {
			fprintf(outfile_fp,
				"Content-Transfer-Encoding: 8bit\n");
		    }
		}
d834 7
a840 37
		if (HTisDocumentSource()) {
		    /*
		     *	Add Content-Type, Content-Location, and
		     *	Content-Base headers for HTML source. - FM
		     */
		    fprintf(outfile_fp, "Content-Type: text/html");
		    if (disp_charset != NULL) {
			fprintf(outfile_fp, "; charset=%s\n",
					    disp_charset);
		    } else {
			fprintf(outfile_fp, "\n");
		    }
		} else {
		    /*
		     *	Add Content-Type: text/plain if we have 8-bit
		     *	characters and a valid charset for non-source
		     *	documents. - KW
		     */
		    if (disp_charset != NULL) {
			fprintf(outfile_fp,
				"Content-Type: text/plain; charset=%s\n",
				disp_charset);
		    }
		}
		/*
		 *  If we are using MIME headers, add content-base and
		 *  content-location if we have them.  This will always
		 *  be the case if the document is source. - kw
		 */
		if (use_mime) {
		    if (content_base)
			fprintf(outfile_fp, "Content-Base: %s\n",
				content_base);
		    if (content_location)
			fprintf(outfile_fp, "Content-Location: %s\n",
				content_location);
		}
d842 20
a861 22
		/*
		 *  Add the To, Subject, and X-URL headers. - FM
		 */
		fprintf(outfile_fp, "To: %s\nSubject: %s\n",
				     user_response, sug_filename);
		fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);
		if (LYPrependBaseToSource && HTisDocumentSource()) {
		    /*
		     *	Added the document's base as a BASE tag to
		     *	the top of the message body.  May create
		     *	technically invalid HTML, but will help
		     *	get any partial or relative URLs resolved
		     *	properly if no BASE tag is present to
		     *	replace it. - FM
		     */
		    fprintf(outfile_fp,
			    "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
			    newdoc->address, content_base);
		}
		print_wwwfile_to_fd(outfile_fp, 0);
		if (keypad_mode)
		    printlist(outfile_fp, FALSE);
d863 16
a878 9
#ifdef DOSPATH
		sprintf(buffer, "%s -t \"%s\" -F %s", system_mail, user_response, tempfile);
		fclose(outfile_fp);	/* Close the tmpfile. */
		stop_curses();
		printf("Sending \n\n$ %s\n\nPlease wait...", buffer);
		system(buffer);
		sleep(MessageSecs);
		start_curses();
		remove(tempfile);	/* Delete the tmpfile. */
d880 63
a942 4
		pclose(outfile_fp);
#endif
#endif /* VMS */
		break;
d944 5
a948 26
	case TO_SCREEN:
		pages = lines_in_file/(LYlines+1);
		/* count fractional pages ! */
		if ((lines_in_file % (LYlines+1)) > 0)
		    pages++;
		if (pages > 4) {
		    sprintf(filename, CONFIRM_LONG_SCREEN_PRINT, pages);
		    _statusline(filename);
		    c=LYgetch();
#ifdef VMS
		    if (HadVMSInterrupt) {
			HadVMSInterrupt = FALSE;
			_statusline(PRINT_REQUEST_CANCELLED);
			sleep(InfoSecs);
			break;
		    }
#endif /* VMS */
		    if (c == RTARROW || c == 'y' || c== 'Y'
			 || c == '\n' || c == '\r') {
			addstr("   Ok...");
		    } else {
			_statusline(PRINT_REQUEST_CANCELLED);
			sleep(InfoSecs);
			break;
		    }
		}
d950 4
a953 8
		_statusline(PRESS_RETURN_TO_BEGIN);
		*filename = '\0';
		if (LYgetstr(filename, VISIBLE,
			     sizeof(filename), NORECALL) < 0) {
		      _statusline(PRINT_REQUEST_CANCELLED);
		      sleep(InfoSecs);
		      break;
		}
d955 1
a955 1
		outfile_fp = stdout;
d957 1
a957 1
		stop_curses();
d959 1
a959 1
		signal(SIGINT, SIG_IGN);
d962 16
a977 16
		if (LYPrependBaseToSource && HTisDocumentSource()) {
		    /*
		     *	Added the document's base as a BASE tag
		     *	to the top of the file.  May create
		     *	technically invalid HTML, but will help
		     *	get any partial or relative URLs resolved
		     *	properly if no BASE tag is present to
		     *	replace it. - FM
		     */
		    fprintf(outfile_fp,
			    "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
			    newdoc->address, content_base);
		}
		print_wwwfile_to_fd(outfile_fp, 0);
		if (keypad_mode)
		    printlist(outfile_fp, FALSE);
d980 5
a984 5
		if (HadVMSInterrupt) {
		     HadVMSInterrupt = FALSE;
		     start_curses();
		     break;
		}
d986 7
a992 4
		fprintf(stdout,"\n\n%s", PRESS_RETURN_TO_FINISH);

		fflush(stdout);  /* refresh to screen */
		LYgetch();  /* grab some user input to pause */
d994 1
a994 1
		HadVMSInterrupt = FALSE;
d996 90
a1085 2
		start_curses();
		break;
d1087 2
a1088 26
	case PRINTER:
		pages = lines_in_file/pagelen;
		/* count fractional pages ! */
		if ((lines_in_file % pagelen) > 0)
		    pages++;
		if (pages > 4) {
		    sprintf(filename, CONFIRM_LONG_PAGE_PRINT, pages);
		    _statusline(filename);
		    c=LYgetch();
#ifdef VMS
		    if (HadVMSInterrupt) {
			HadVMSInterrupt = FALSE;
			_statusline(PRINT_REQUEST_CANCELLED);
			sleep(InfoSecs);
			break;
		    }
#endif /* VMS */
		    if (c == RTARROW || c == 'y' || c== 'Y'
			 || c == '\n' || c == '\r') {
			addstr("   Ok...");
		    } else  {
			_statusline(PRINT_REQUEST_CANCELLED);
			sleep(InfoSecs);
			break;
		    }
		}
d1090 14
a1103 25
		if (first) {
		    tempname(tempfile, NEW_FILE);
		    first = FALSE;
		} else {
		    remove(tempfile);	/* Remove previous tempfile. */
		}
		if (((cp = strrchr(tempfile, '.')) != NULL) &&
#ifdef VMS
		    NULL == strchr(cp, ']') &&
#endif /* VMS */
		    NULL == strchr(cp, '/')) {
		    if (HTisDocumentSource() &&
			strcasecomp(cp, HTML_SUFFIX)) {
			*cp = '\0';
			strcat(tempfile, HTML_SUFFIX);
		    } else if (!HTisDocumentSource() &&
			       strcasecomp(cp, ".txt")) {
			*cp = '\0';
			strcat(tempfile, ".txt");
		    }
		}
		if ((outfile_fp = LYNewTxtFile(tempfile)) == NULL) {
		    HTAlert(FILE_ALLOC_FAILED);
		    break;
		}
d1105 14
a1118 27
		if (LYPrependBaseToSource && HTisDocumentSource()) {
		    /*
		     *	Added the document's base as a BASE tag
		     *	to the top of the file.  May create
		     *	technically invalid HTML, but will help
		     *	get any partial or relative URLs resolved
		     *	properly if no BASE tag is present to
		     *	replace it. - FM
		     */
		    fprintf(outfile_fp,
			    "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",
			    newdoc->address, content_base);
		}
		print_wwwfile_to_fd(outfile_fp, 0);
		if (keypad_mode)
		    printlist(outfile_fp, FALSE);

		fclose(outfile_fp);

		/* find the right printer number */
		{
		    int count=0;
		    for (cur_printer = printers;
			 count < printer_number;
			 count++, cur_printer = cur_printer->next)
			; /* null body */
		}
d1120 4
a1123 106
		/*
		 *  Commands have the form "command %s [%s] [etc]"
		 *  where %s is the filename and the second optional
		 *  %s is the suggested filename.
		 */
		if (cur_printer->command != NULL) {
		    /*
		     *	Check for two '%s' and ask for the second filename
		     *	argument if there is.
		     */
		    char *first_s = strstr(cur_printer->command, "%s");
		    if (first_s && strstr(first_s+1, "%s")) {
			_statusline(FILENAME_PROMPT);
		again:	strcpy(filename, sug_filename);
			change_sug_filename(filename);
			if (!(HTisDocumentSource()) &&
			    (cp = strrchr(filename, '.')) != NULL) {
			    format = HTFileFormat(filename, &encoding, NULL);
			    if (!strcasecomp(format->name, "text/html") ||
				!IsUnityEnc(encoding)) {
				*cp = '\0';
				strcat(filename, ".txt");
			    }
			}
		check_again:
			if ((ch = LYgetstr(filename, VISIBLE,
					   sizeof(filename), recall)) < 0 ||
			    *filename == '\0' ||
			    ch == UPARROW || ch == DNARROW) {
			    if (recall && ch == UPARROW) {
				if (FirstRecall) {
				    FirstRecall = FALSE;
				    /*
				     *	Use the last Fname in the list. - FM
				     */
				    FnameNum = 0;
				} else {
				    /*
				     *	Go back to the previous Fname
				     *	in the list. - FM
				     */
				    FnameNum++;
				}
				if (FnameNum >= FnameTotal) {
				    /*
				     *	Reset the FirstRecall flag,
				     *	and use sug_file or a blank. - FM
				     */
				    FirstRecall = TRUE;
				    FnameNum = FnameTotal;
				    _statusline(FILENAME_PROMPT);
				    goto again;
				} else if ((cp = (char *)HTList_objectAt(
							sug_filenames,
							FnameNum)) != NULL) {
				    strcpy(filename, cp);
				    if (FnameTotal == 1) {
					_statusline(EDIT_THE_PREV_FILENAME);
				    } else {
					_statusline(EDIT_A_PREV_FILENAME);
				    }
				    goto check_again;
				}
			    } else if (recall && ch == DNARROW) {
				if (FirstRecall) {
				    FirstRecall = FALSE;
				    /*
				     *	Use the first Fname in the list. - FM
				     */
				    FnameNum = FnameTotal - 1;
				} else {
				    /*
				     *	Advance to the next Fname
				     *	in the list. - FM
				     */
				    FnameNum--;
				}
				if (FnameNum < 0) {
				    /*
				     *	Set the FirstRecall flag,
				     *	and use sug_file or a blank. - FM
				     */
				    FirstRecall = TRUE;
				    FnameNum = FnameTotal;
				    _statusline(FILENAME_PROMPT);
				    goto again;
				} else if ((cp = (char *)HTList_objectAt(
							sug_filenames,
							FnameNum)) != NULL) {
				    strcpy(filename, cp);
				    if (FnameTotal == 1) {
					_statusline(EDIT_THE_PREV_FILENAME);
				    } else {
					_statusline(EDIT_A_PREV_FILENAME);
				    }
				    goto check_again;
				}
			    }

			    /*
			     *	Printer cancelled.
			     */
			    _statusline(PRINT_REQUEST_CANCELLED);
			    sleep(InfoSecs);
			    break;
			}
d1125 3
a1127 34
			if (no_dotfiles || !show_dotfiles) {
			    if (*filename == '.' ||
#ifdef VMS
			       ((cp = strrchr(filename, ':')) &&
						*(cp+1) == '.') ||
			       ((cp = strrchr(filename, ']')) &&
						*(cp+1) == '.') ||
#endif /* VMS */
			       ((cp = strrchr(filename, '/')) &&
						*(cp+1) == '.')) {
				HTAlert(FILENAME_CANNOT_BE_DOT);
				_statusline(NEW_FILENAME_PROMPT);
				FirstRecall = TRUE;
				FnameNum = FnameTotal;
				goto again;
			    }
			}
			/*
			 *  Cancel if the user entered "/dev/null" on Unix,
			 *  or an "nl:" path (case-insensitive) on VMS. - FM
			 */
#ifdef VMS
			if (!strncasecomp(filename, "nl:", 3) ||
			    !strncasecomp(filename, "/nl/", 4))
#else
			if (!strcmp(filename, "/dev/null"))
#endif /* VMS */
			{
			    _statusline(PRINT_REQUEST_CANCELLED);
			    sleep(InfoSecs);
			    break;
			}
			HTAddSugFilename(filename);
		    }
d1129 3
a1131 12
#ifdef VMS
		    sprintf(buffer, cur_printer->command, tempfile, filename,
				    "", "", "", "", "", "", "", "", "", "");
#else /* Unix: */
		    /*
		     *	Prevent spoofing of the shell.
		     */
		    cp = quote_pathname(filename);
		    sprintf(buffer, cur_printer->command, tempfile, cp,
				    "", "", "", "", "", "", "", "", "", "");
		    FREE(cp);
#endif /* !VMS */
d1133 4
a1136 4
		} else {
		    HTAlert(PRINTER_MISCONF_ERROR);
		    break;
		}
d1138 4
a1141 6
		/*
		 *  Move the cursor to the top of the screen so that
		 *  output from system'd commands don't scroll up
		 *  the screen.
		 */
		move(1,1);
a1142 42
		stop_curses();
		if (TRACE)
		    fprintf(stderr, "command: %s\n", buffer);
		printf(PRINTING_FILE);
#ifdef VMS
		/*
		 *  Set document's title as a VMS logical. -  FM
		 */
		StrAllocCopy(envbuffer, HText_getTitle());
		if (!(envbuffer && *envbuffer))
		    StrAllocCopy(envbuffer, "No Title");
		Define_VMSLogical("LYNX_PRINT_TITLE", envbuffer);
#else
		/*
		 *  Set document's title as an environment variable. - JKT
		 */
		StrAllocCopy(envbuffer, "LYNX_PRINT_TITLE=");
		StrAllocCat(envbuffer, HText_getTitle());
		putenv(envbuffer);
#endif /* VMS */
		fflush(stdout);
		system(buffer);
#ifdef VMS
		/*
		 *  Remove LYNX_PRINT_TITLE logical. - FM
		 */
		Define_VMSLogical("LYNX_PRINT_TITLE", "");
#else
		/*
		 *  Remove LYNX_PRINT_TITLE value from environment. - KW
		 */
		envbuffer[17] = '\0'; /* truncate after '=' */
		putenv(envbuffer);
#endif /* VMS */
		FREE(envbuffer);
		fflush(stdout);
#ifndef VMS
		signal(SIGINT, cleanup_sig);
#endif /* !VMS */
		sleep(MessageSecs);
		start_curses();
		/* don't remove(tempfile); */
d1154 1
a1154 1
	char *, 	string)
d1171 53
d1230 1
d1234 1
a1234 1
PUBLIC int print_options ARGS2(
d1236 1
d1239 2
a1240 4
    static char tempfile[256];
    static BOOLEAN first = TRUE;
    static char print_filename[256];
    char buffer[LINESIZE];
d1246 2
a1247 17
    pages = lines_in_file/66 + 1;

    if (first) {
	tempname(tempfile, NEW_FILE);
#if defined (VMS) || defined (DOSPATH)
	sprintf(print_filename, "file://localhost/%s", tempfile);
#else
	sprintf(print_filename, "file://localhost%s", tempfile);
#endif /* VMS */
	first = FALSE;
#ifdef VMS
    } else {
	remove(tempfile);   /* Remove duplicates on VMS. */
#endif /* !VMS */
    }

    if ((fp0 = LYNewTxtFile(tempfile)) == NULL) {
d1252 1
a1252 2
    StrAllocCopy(*newfile, print_filename);
    LYforce_no_cache = TRUE;
d1254 1
a1254 2
    fprintf(fp0, "<head>\n<title>%s</title>\n</head>\n<body>\n",
		 PRINT_OPTIONS_TITLE);
d1256 1
a1256 2
    fprintf(fp0,"<h1>Printing Options (%s Version %s)</h1><pre>\n",
				       LYNX_NAME, LYNX_VERSION);
d1258 1
d1260 8
a1267 4
    sprintf(buffer,
	   "   There are %d lines, or approximately %d page%s, to print.\n",
	    lines_in_file, pages, (pages > 1 ? "s" : ""));
    fputs(buffer,fp0);
d1270 1
a1270 1
	fprintf(fp0, "   Some print functions have been disabled!!!\n");
d1272 4
a1275 2
    fprintf(fp0, "   You have the following print choices.\n");
    fprintf(fp0, "   Please select one:\n\n");
d1277 9
a1285 1
    if (child_lynx == FALSE && no_disk_save == FALSE && no_print == FALSE)
d1287 9
a1295 8
   "   <a href=\"LYNXPRINT://LOCAL_FILE/lines=%d\">Save to a local file</a>\n",
		lines_in_file);
    else
	fprintf(fp0,"   Save to disk disabled.\n");
    if (child_lynx == FALSE && no_mail == FALSE)
	 fprintf(fp0,
   "   <a href=\"LYNXPRINT://MAIL_FILE/lines=%d\">Mail the file</a>\n",
		lines_in_file);
d1297 7
a1303 2
   "   <a href=\"LYNXPRINT://TO_SCREEN/lines=%d\">Print to the screen</a>\n",
		lines_in_file);
d1309 1
a1309 1
   "   <a href=\"LYNXPRINT://PRINTER/number=%d/pagelen=%d/lines=%d\">",
d1315 3
a1317 2
    fprintf(fp0, "</pre>\n</body>\n");
    fclose(fp0);
d1321 125
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
