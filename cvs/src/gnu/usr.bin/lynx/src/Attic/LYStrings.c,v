head	1.11;
access;
symbols
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.10;
commitid	EcR8E7r0stjLUV4p;

1.10
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.9;
commitid	lGGuvDWEniklWrQe;

1.9
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.04.04.24.03;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.25.14.29.10;	author margarida;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.12;	author maja;	state Exp;
branches
	1.2.10.1
	1.2.12.1;
next	1.1;

1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.55;	author maja;	state Exp;
branches;
next	;

1.2.10.1
date	2003.01.22.23.54.24;	author miod;	state Exp;
branches;
next	;

1.2.12.1
date	2002.12.04.15.50.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.11
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYStrings.c,v 1.258 2013/11/28 11:57:39 tom Exp $ */
#include <HTUtils.h>
#include <HTCJK.h>
#include <UCAux.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYStrings.h>
#include <GridText.h>
#include <LYKeymap.h>
#include <LYClean.h>
#include <LYMail.h>
#include <LYNews.h>
#include <LYOptions.h>
#include <LYCharSets.h>
#include <HTAlert.h>
#include <HTString.h>
#include <LYCharUtils.h>
#include <HTList.h>
#include <HTParse.h>
#ifdef USE_MOUSE
#include <LYMainLoop.h>
#endif

#ifdef DJGPP_KEYHANDLER
#include <pc.h>
#include <keys.h>
#endif /* DJGPP_KEYHANDLER */

#ifdef USE_COLOR_STYLE
#include <LYHash.h>
#include <AttrList.h>
#endif

#ifdef USE_SCROLLBAR
#include <LYMainLoop.h>
#endif

#ifdef USE_CMD_LOGGING
#include <LYReadCFG.h>
#include <LYrcFile.h>
#endif

#include <LYShowInfo.h>
#include <LYLeaks.h>

#if defined(WIN_EX)
#undef  BUTTON_CTRL
#define BUTTON_CTRL	0	/* Quick hack */
#endif

#ifdef DEBUG_EDIT
#define CTRACE_EDIT(p) CTRACE(p)
#else
#define CTRACE_EDIT(p)		/*nothing */
#endif

#ifdef SUPPORT_MULTIBYTE_EDIT
#define IsWordChar(c) (isalnum(UCH(c)) || is8bits(c))
#else
#define IsWordChar(c) isalnum(UCH(c))
#endif

/*
 * The edit_history lists allow the user to press tab when entering URL to get
 * the closest match in the closet
 */
#define LYClosetSize 100

static HTList *URL_edit_history;
static HTList *MAIL_edit_history;

/* If you want to add mouse support for some new platform, it's fairly
 * simple to do.  Once you've determined the X and Y coordinates of
 * the mouse event, loop through the elements in the links[] array and
 * see if the coordinates fall within a highlighted link area.	If so,
 * the code must set mouse_link to the index of the chosen link,
 * and return a key value that corresponds to LYK_ACTIVATE.  The
 * LYK_ACTIVATE code in LYMainLoop.c will then check mouse_link
 * and activate that link.  If the mouse event didn't fall within a
 * link, the code should just set mouse_link to -1 and return -1. --AMK
 */

/* The number of the link selected w/ the mouse (-1 if none) */
static int mouse_link = -1;

static int have_levent;

#if defined(USE_MOUSE) && defined(NCURSES)
static MEVENT levent;
#endif

/* Return the value of mouse_link */
int peek_mouse_levent(void)
{
#if defined(USE_MOUSE) && defined(NCURSES)
    if (have_levent > 0) {
	ungetmouse(&levent);
	have_levent--;
	return 1;
    }
#endif
    return 0;
}

/* Return the value of mouse_link, erasing it */
int get_mouse_link(void)
{
    int t;

    t = mouse_link;
    mouse_link = -1;
    if (t < 0)
	t = -1;			/* Backward compatibility. */
    return t;
}

/* Return the value of mouse_link */
int peek_mouse_link(void)
{
    return mouse_link;
}

int fancy_mouse(WINDOW * win, int row,
		int *position)
{
    int cmd = LYK_DO_NOTHING;

#ifdef USE_MOUSE
/*********************************************************************/

#if defined(WIN_EX) && defined(PDCURSES)

    request_mouse_pos();

    if (BUTTON_STATUS(1)
	&& (MOUSE_X_POS >= getbegx(win) &&
	    MOUSE_X_POS < (getbegx(win) + getmaxx(win)))) {
	int mypos = MOUSE_Y_POS - getbegy(win);
	int delta = mypos - row;

	if (mypos + 1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (BUTTON_STATUS(1) & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (BUTTON_STATUS(1) & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (BUTTON_STATUS(1) & (BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (BUTTON_STATUS(1) & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
#endif
	} else if (BUTTON_STATUS(1) & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (BUTTON_STATUS(1) & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#else
#if defined(NCURSES)
#define ButtonModifiers (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)
    MEVENT event;

    getmouse(&event);
    if ((event.bstate & (BUTTON1_CLICKED |
			 BUTTON1_DOUBLE_CLICKED |
			 BUTTON1_TRIPLE_CLICKED))) {
	int mypos = event.y - getbegy(win);
	int delta = mypos - row;

	if ((event.x < getbegx(win) ||
	     event.x >= (getbegx(win) + getmaxx(win)))
	    && !(event.bstate & ButtonModifiers))
	    return LYK_QUIT;	/* User clicked outside, wants to quit? */
	if (mypos + 1 == getmaxy(win)) {
	    /* At the decorative border: scroll forward */
	    if (event.bstate & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_END;
	    else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_NEXT_PAGE;
	    else
		cmd = LYK_NEXT_LINK;
	} else if (mypos >= getmaxy(win)) {
	    if (event.bstate & (BUTTON1_DOUBLE_CLICKED |
				BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_END;
	    else
		cmd = LYK_NEXT_PAGE;
	} else if (mypos == 0) {
	    /* At the decorative border: scroll back */
	    if (event.bstate & BUTTON1_TRIPLE_CLICKED)
		cmd = LYK_HOME;
	    else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
		cmd = LYK_PREV_PAGE;
	    else
		cmd = LYK_PREV_LINK;
	} else if (mypos < 0) {
	    if (event.bstate & (BUTTON1_DOUBLE_CLICKED |
				BUTTON1_TRIPLE_CLICKED))
		cmd = LYK_HOME;
	    else
		cmd = LYK_PREV_PAGE;
#ifdef KNOW_HOW_TO_TOGGLE
	} else if (event.bstate & (BUTTON_CTRL)) {
	    cur_selection += delta;
	    cmd = LYX_TOGGLE;
#endif
	} else if (event.x <= getbegx(win) + 1 ||
		   event.x >= getbegx(win) + getmaxx(win) - 2) {
	    /* Click on left or right border for positioning without
	     * immediate action: select, but do nothing else.
	     * Actually, allow an error of one position inwards. - kw
	     */
	    *position += delta;
	    cmd = -1;
	} else if (event.bstate & ButtonModifiers) {
	    /* Probably some unrelated activity, such as selecting some text.
	     * Select, but do nothing else.
	     */
	    /* Possibly this is never returned by ncurses, so this case
	     * may be useless depending on situation (kind of mouse support
	     * and library versions). - kw
	     */
	    *position += delta;
	    cmd = -1;
	} else {
	    /* No scrolling or overflow checks necessary. */
	    *position += delta;
	    cmd = LYK_ACTIVATE;
	}
    } else if (event.bstate & (BUTTON3_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED)) {
	cmd = LYK_QUIT;
    }
#endif /* NCURSES */
#endif /* PDCURSES */

/************************************************************************/
#endif /* USE_MOUSE */
    (void) win;
    (void) row;
    (void) position;

    return cmd;
}

/*
 * Manage the collection of edit-histories
 */
static HTList *whichRecall(RecallType recall)
{
    HTList **list;

    switch (recall) {
    case RECALL_CMD:
	return LYcommandList();
    case RECALL_MAIL:
	list = &MAIL_edit_history;
	break;
    default:
	list = &URL_edit_history;
	break;
    }
    if (*list == 0)
	*list = HTList_new();
    return *list;
}

/*
 * Remove the oldest item in the closet
 */
static void LYRemoveFromCloset(HTList *list)
{
    void *data = HTList_removeFirstObject(list);

    if (data != 0)
	FREE(data);
}

void LYCloseCloset(RecallType recall)
{
    HTList *list = whichRecall(recall);

    while (!HTList_isEmpty(list)) {
	LYRemoveFromCloset(list);
    }
    HTList_delete(list);	/* should already be empty */
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
static char *LYFindInCloset(RecallType recall, char *base)
{
    HTList *list = whichRecall(recall);
    char *data;
    size_t len = strlen(base);

    while (!HTList_isEmpty(list)) {
	data = (char *) HTList_nextObject(list);
	if (data != NULL && !StrNCmp(base, data, len))
	    return (data);
    }

    return (0);
}

static void LYAddToCloset(RecallType recall, char *str)
{
    HTList *list = whichRecall(recall);
    char *data = NULL;

    StrAllocCopy(data, str);
    HTList_addObject(list, data);
    while (HTList_count(list) > LYClosetSize)
	LYRemoveFromCloset(list);
}

#ifdef USE_MOUSE
static int XYdist(int x1,
		  int y1,
		  int x2,
		  int y2,
		  int dx2)
{
    int xerr = 3 * (x2 - x1), yerr = 9 * (y2 - y1);

    if (xerr < 0)
	xerr = 3 * (x1 - x2 - dx2) + 1;		/* pos after string not really in it */
    if (xerr < 0)
	xerr = 0;
    if (yerr < 0)
	yerr = -yerr;
    if (!yerr)			/* same line is good */
	return (xerr > 0) ? (xerr * 2 - 1) : 0;
    if (xerr < 9 && yerr)	/* x-dist of 3 cell better than y-dist of 1 cell */
	yerr += (9 - xerr);
    return 2 * xerr + yerr;	/* Subjective factor; ratio -> approx. 6 / 9 */
/*
old: (IZ 1999-07-30)
 3  2  2  2  1  1  1 XX XX XX XX XX  0  1  1  1  2  2  2  3  3
 4\ 3  3  3  2  2  2  2  2  2  2  2  2  2  2  2  3  3  3/ 4  4
 5  4  4  4\ 3  3  3  3  3  3  3  3  3  3  3  3/ 4  4  4  5  5
 6  5  5  5  4  4  4  4  4  4  4  4  4  4  4  4  5  5  5  6  5
now: (kw 1999-10-23)
41 35 29|23 17 11  5 XX XX XX XX XX  1  7 13 19 25|31 37 43 49
   45 39 33\27 24 21 18 18 18 18 18 19 22 25 28/34 40 46 50
      48 42 36 33 30\27 27 27 27 27 28/31 34 37 43 49
         51 45 42 39 36 36 36 36 36 37 40 43 46 49
               51 48 45 45 45 45 45 46 49 52
*/
}

/* Given X and Y coordinates of a mouse event, set mouse_link to the
 * index of the corresponding hyperlink, or set mouse_link to -1 if no
 * link matches the event.  Returns -1 if no link matched the click,
 * or a keycode that must be returned from LYgetch() to activate the
 * link.
 */

static int set_clicked_link(int x,
			    int y,
			    int code,
			    int clicks)
{
    int left = 6;
    int right = LYcolLimit - 5;

    /* yes, I am assuming that my screen will be a certain width. */
    int i;
    int c = -1;

    if (y == (LYlines - 1) || y == 0) {		/* First or last row */
	/* XXXX In fact # is not always at x==0?  KANJI_CODE_OVERRIDE? */
	int toolbar = (y == 0 && HText_hasToolbar(HTMainText));

	mouse_link = -2;
	if (x == 0 && toolbar)	/* On '#' */
	    c = LAC_TO_LKC0(LYK_TOOLBAR);
#if defined(CAN_CUT_AND_PASTE) && defined(USE_COLOR_STYLE)
	else if (y == 0 && x == LYcolLimit && s_hot_paste != NOSTYLE)
	    c = LAC_TO_LKC0(LYK_PASTE_URL);
#endif
	else if (clicks > 1) {
	    if (x < left + toolbar)
		c = (code == FOR_PROMPT && y)
		    ? HOME_KEY : LAC_TO_LKC0(LYK_MAIN_MENU);
	    else if (x > right)
		c = (code == FOR_PROMPT && y)
		    ? END_KEY : LAC_TO_LKC0(LYK_VLINKS);
	    else if (y)		/* Last row */
		c = LAC_TO_LKC0(LYK_END);
	    else		/* First row */
		c = LAC_TO_LKC0(LYK_HOME);
	} else {
	    if (x < left + toolbar)
		c = (code == FOR_PROMPT && y)
		    ? LTARROW_KEY
		    : (
#ifdef USE_COLOR_STYLE
			  (s_forw_backw != NOSTYLE && x - toolbar >= 3)
			  ? LAC_TO_LKC0(LYK_NEXT_DOC)
			  : LAC_TO_LKC0(LYK_PREV_DOC)
#else
			  LAC_TO_LKC0(LYK_NEXT_DOC)
#endif
		    );
	    else if (x > right)
		c = (code == FOR_PROMPT && y)
		    ? RTARROW_KEY : LAC_TO_LKC0(LYK_HISTORY);
	    else if (y)		/* Last row */
		c = LAC_TO_LKC0(LYK_NEXT_PAGE);
	    else		/* First row */
		c = LAC_TO_LKC0(LYK_PREV_PAGE);
	}
#ifdef USE_SCROLLBAR
    } else if (x == (LYcols - 1) && LYShowScrollbar && LYsb_begin >= 0) {
	int h = display_lines - 2 * (LYsb_arrow != 0);

	mouse_link = -2;
	y -= 1 + (LYsb_arrow != 0);
	if (y < 0)
	    return LAC_TO_LKC0(LYK_UP_TWO);
	if (y >= h)
	    return LAC_TO_LKC0(LYK_DOWN_TWO);

	if (clicks >= 2) {
	    double frac = (1. * y) / (h - 1);
	    int l = HText_getNumOfLines() + 1;	/* NOL() off by one? */

	    l -= display_lines;
	    if (l > 0)
		LYSetNewline((int) (frac * l + 1 + 0.5));
	    return LYReverseKeymap(LYK_DO_NOTHING);
	}

	if (y < LYsb_begin)
	    return LAC_TO_LKC0(LYK_PREV_PAGE);
	if (y >= LYsb_end)
	    return LAC_TO_LKC0(LYK_NEXT_PAGE);
	mouse_link = -1;	/* No action in edit fields */
#endif
    } else {
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */ cur_err;

	/* Loop over the links and see if we can get a match */
	for (i = 0; i < nlinks; i++) {
	    int len, lx = links[i].lx, is_text = 0;
	    int count = 0;
	    const char *text = LYGetHiliteStr(i, count);

	    if (links[i].type == WWW_FORM_LINK_TYPE
		&& F_TEXTLIKE(links[i].l_form->type))
		is_text = 1;

	    /* Check the first line of the link */
	    if (text != NULL) {
		if (is_text)
		    len = links[i].l_form->size;
		else
		    len = (int) LYstrCells(text);
		cur_err = XYdist(x, y, links[i].lx, links[i].ly, len);
		/* Check the second line */
		while (cur_err > 0
		       && (text = LYGetHiliteStr(i, ++count)) != NULL) {
		    /* Note that there is at most one hightext if is_text */
		    int cur_err_2 = XYdist(x, y,
					   LYGetHilitePos(i, count),
					   links[i].ly + count,
					   (int) LYstrCells(text));

		    cur_err = HTMIN(cur_err, cur_err_2);
		}
		if (cur_err > 0 && is_text)
		    cur_err--;	/* a bit of preference for text fields,
				   enter field if hit exactly at end - kw */
		if (cur_err == 0) {
		    int cury, curx;

		    LYGetYX(cury, curx);
		    /* double-click, if we care:
		       submit text submit fields. - kw */
		    if (clicks > 1 && is_text &&
			links[i].l_form->type == F_TEXT_SUBMIT_TYPE) {
			if (code != FOR_INPUT
			/* submit current input field directly */
			    || !(cury == y &&
				 (curx >= lx) &&
				 ((curx - lx) <= len))) {
			    c = LAC_TO_LKC0(LYK_MOUSE_SUBMIT);
			    mouse_link = i;
			} else {
			    c = LAC_TO_LKC0(LYK_MOUSE_SUBMIT);
			    mouse_link = -1;
			}
			mouse_err = 0;
			break;
		    }
		    if (code != FOR_INPUT
		    /* Do not pick up the current input field */
			|| !((cury == y && (curx >= lx) && ((curx - lx) <= len)))) {
			if (is_text) {
			    have_levent = 1;
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
			    if (x == links[i].lx && y == links[i].ly)
				textinput_redrawn = FALSE;
#endif /* TEXTFIELDS_MAY_NEED_ACTIVATION && INACTIVE_INPUT_STYLE_VH */
			}
			mouse_link = i;
		    } else
			mouse_link = -1;
		    mouse_err = 0;
		    break;
		} else if (cur_err < mouse_err) {
		    mouse_err = cur_err;
		    mouse_link = i;
		}
	    }
	}
	/*
	 * If a link was hit, we must look for a key which will activate
	 * LYK_ACTIVATE We expect to find LYK_ACTIVATE (it's usually mapped to
	 * the Enter key).
	 */
	if (mouse_link >= 0) {
	    if (mouse_err == 0) {
		if (c == -1)
		    c = LAC_TO_LKC0(LYK_ACTIVATE);
	    } else if (mouse_err >= 0)
		c = LAC_TO_LKC0(LYK_CHANGE_LINK);
	} else {
	    if (2 * y > LYlines) {	/* Bottom Half of the screen */
		if (4 * y < 3 * LYlines) {
		    c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
		} else
		    c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	    } else {		/* Upper Half of the screen */
		if (4 * y < LYlines) {
		    c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
		} else
		    c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	    }
	}
    }
    return c;
}
#endif /* USE_MOUSE */

/*
 * LYstrncpy() ensures that the copied strings end with a nul byte.
 * The nul is written to the n+1 position of the target.
 */
char *LYstrncpy(char *target,
		const char *source,
		int n)
{
    char *val = target;
    int len;

    if (source == 0)
	source = "";
    len = (int) strlen(source);

    if (n > 0) {
	if (n > len)
	    n = len;
	(void) StrNCpy(target, source, n);
    } else {
	n = 0;
    }
    target[n] = '\0';
    return val;
}

#define IS_NEW_GLYPH(ch) (utf_flag && (UCH(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && (UCH(ch)&0xc0) == 0x80)

/*
 * LYmbcsstrncpy() terminates strings with a null byte.  It takes account of
 * multibyte characters.  The source string is copied until either end of string
 * or max number of either bytes or glyphs (mbcs sequences) (CJK or UTF8).  The
 * utf_flag argument should be TRUE for UTF8.  - KW & FM
 */
char *LYmbcsstrncpy(char *target,
		    const char *source,
		    int n_bytes,
		    int n_glyphs,
		    int utf_flag)
{
    char *val = target;
    int i_bytes = 0, i_glyphs = 0;

    if (n_bytes < 0)
	n_bytes = 0;
    if (n_glyphs < 0)
	n_glyphs = 0;

    for (; *source != '\0' && i_bytes < n_bytes; i_bytes++) {
	if (IS_NEW_GLYPH(*source)) {
	    if (i_glyphs++ >= n_glyphs) {
		*target = '\0';
		return val;
	    }
	}
	*(target++) = *(source++);
    }
    *target = '\0';

    return val;
}

/*
 * LYmbcs_skip_glyphs() skips a given number of character positions in a string
 * and returns the resulting pointer.  It takes account of UTF-8 encoded
 * characters.  - KW
 */
const char *LYmbcs_skip_glyphs(const char *data,
			       int n_glyphs,
			       int utf_flag)
{
    int i_glyphs = 0;

    if (n_glyphs < 0)
	n_glyphs = 0;

    if (non_empty(data)) {
	if (!utf_flag) {
	    while (n_glyphs-- > 0) {
		if (!*++data)
		    break;
	    }
	} else {
	    while (*data) {
		if (IS_NEW_GLYPH(*data)) {
		    if (i_glyphs++ >= n_glyphs) {
			break;
		    }
		}
		data++;
	    }
	}
    }
    return data;
}

/*
 * LYmbcs_skip_cells() skips a given number of display positions in a string
 * and returns the resulting pointer.  It takes account of UTF-8 encoded
 * characters.  - TD
 */
const char *LYmbcs_skip_cells(const char *data,
			      int n_cells,
			      int utf_flag)
{
    const char *result;
    int actual;
    int target = n_cells;

    do {
	result = LYmbcs_skip_glyphs(data, target--, utf_flag);
	actual = LYstrExtent2(data, (int) (result - data));
    } while ((actual > 0) && (actual > n_cells));
    return result;
}

/*
 * LYmbcsstrlen() returns the printable length of a string that might contain
 * IsSpecial or multibyte (CJK or UTF8) characters.  - FM
 *
 * Counts glyph cells if count_gcells is set.  (Full-width characters in CJK
 * mode count as two.) Counts character glyphs if count_gcells is unset. 
 * (Full- width characters in CJK mode count as one.) - kw
 */
int LYmbcsstrlen(const char *str,
		 int utf_flag,
		 int count_gcells)
{
    int i, j, len = 0;

    if (non_empty(str)) {
#ifdef WIDEC_CURSES
	if (count_gcells) {
	    len = LYstrCells(str);
	} else
#endif
	{
	    for (i = 0; str[i] != '\0'; i++) {
		if (!IsSpecialAttrChar(str[i])) {
		    len++;
		    if (IS_NEW_GLYPH(str[i])) {
			j = 0;
			while (IsNormalChar(str[(i + 1)]) &&
			       j < 5 &&
			       IS_UTF_EXTRA(str[(i + 1)])) {
			    i++;
			    j++;
			}
		    } else if (!utf_flag && IS_CJK_TTY && !count_gcells &&
			       is8bits(str[i]) &&
			       IsNormalChar(str[(i + 1)])) {
			i++;
		    }
		}
	    }
	}
    }
    return (len);
}

#undef GetChar

#ifdef USE_SLANG
#if defined(VMS)
#define GetChar() ttgetc()
#elif defined(__DJGPP__)
#define GetChar() getxkey()	/* HTDos.c */
#elif defined(__CYGWIN__)
#define GetChar SLkp_getkey
#else
#define GetChar (int)SLang_getkey
#endif
#else /* curses */
#if defined(DJGPP)
#define GetChar() (djgpp_idle_loop(), wgetch(LYtopwindow()))
#elif defined(NCURSES_VERSION) && defined(__BEOS__)
#define GetChar() myGetCharNodelay()
#elif defined(NCURSES)
#define GetChar() wgetch(LYtopwindow())
#endif
#endif

#ifdef USE_CURSES_NODELAY
/* PDCurses - until version 2.7 in 2005 - defined ERR as 0, unlike other
 * versions of curses.  Generally both EOF and ERR are defined as -1's. 
 * However, there is a special case (see HTCheckForInterrupt()) to handle a
 * case where no select() function is used in the win32 environment.
 *
 * HTCheckForInterrupt() uses nodelay() in this special case to check for
 * pending input.  That normally returns ERR.  But LYgetch_for() checks the
 * return value of this function for EOF (to handle some antique runtime
 * libraries which did not set the state for feof/ferror).  Returning a zero
 * (0) is safer since normally that is not mapped to any commands, and will be
 * ignored by lynx.
 */
static int myGetCharNodelay(void)
{
    int c = wgetch(LYwin);

    if (c == -1)
	c = 0;

    return c;
}
#else
#define myGetCharNodelay() wgetch(LYwin)
#endif

#if !defined(GetChar) && defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
/* PDCurses sends back key-modifiers that we don't use, but would waste time
 * upon, e.g., repainting the status line
 */
static int myGetChar(void)
{
    int c;
    BOOL done = FALSE;

    do {
	switch (c = myGetCharNodelay()) {
	case KEY_SHIFT_L:
	case KEY_SHIFT_R:
	case KEY_CONTROL_L:
	case KEY_CONTROL_R:
	case KEY_ALT_L:
	case KEY_ALT_R:
	case KEY_RESIZE:
	    break;
	default:
	    done = TRUE;
	    break;
	}
    } while (!done);

    return c;
}
#define GetChar() myGetChar()
#endif

#if !defined(GetChar) && defined(SNAKE)
#define GetChar() wgetch(LYwin)
#endif

#if !defined(GetChar) && defined(VMS)
#define GetChar() ttgetc()
#endif

#if !defined(GetChar)
#ifdef HAVE_KEYPAD
#define GetChar() getch()
#else
#ifndef USE_GETCHAR
#define USE_GETCHAR
#endif /* !USE_GETCHAR */
#define GetChar() getchar()	/* used to be "getc(stdin)" and "getch()" */
#endif /* HAVE_KEYPAD */
#endif /* !defined(GetChar) */

#if defined(USE_SLANG) && defined(USE_MOUSE)
static int sl_parse_mouse_event(int *x, int *y, int *button)
{
    /* "ESC [ M" has already been processed.  There more characters are
     * expected:  BUTTON X Y
     */
    *button = (int) SLang_getkey();
    switch (*button) {
    case 040:			/* left button */
    case 041:			/* middle button */
    case 042:			/* right button */
	*button -= 040;
	break;

    default:			/* Hmmm.... */
	SLang_flush_input();
	return -1;
    }

    *x = (int) SLang_getkey();
    if (*x == CH_ESC)		/* Undo 7-bit replace for large x - kw */
	*x = (int) SLang_getkey() + 64 - 33;
    else
	*x -= 33;
    *y = (int) SLang_getkey();
    if (*y == CH_ESC)		/* Undo 7-bit replace for large y - kw */
	*y = (int) SLang_getkey() + 64 - 33;
    else
	*y -= 33;
    return 0;
}

static int sl_read_mouse_event(int code)
{
    int mouse_x, mouse_y, button;

    mouse_link = -1;
    if (-1 != sl_parse_mouse_event(&mouse_x, &mouse_y, &button)) {
	if (button == 0)	/* left */
	    return set_clicked_link(mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)	/* middle */
	    return LYReverseKeymap(LYK_VIEW_BOOKMARK);

	if (button == 2)	/* right */
	{
	    /* Right button: go back to prev document.
	     * The problem is that we need to determine
	     * what to return to achieve this.
	     */
	    return LYReverseKeymap(LYK_PREV_DOC);
	}
    }
    if (code == FOR_INPUT || code == FOR_PROMPT)
	return DO_NOTHING;
    else
	return -1;
}
#endif /* USE_SLANG and USE_MOUSE */

static BOOLEAN csi_is_csi = TRUE;
void ena_csi(int flag)
{
    csi_is_csi = (BOOLEAN) flag;
}

#if defined(USE_KEYMAPS)

#ifdef USE_SLANG
#define define_key(string, code) \
	SLkm_define_keysym ((SLFUTURE_CONST char*)(string), \
			    (unsigned) code, \
			    Keymap_List)
#if SLANG_VERSION < 20000
#define expand_substring(target, first, last, final) \
 	(SLexpand_escaped_string(target, \
				 DeConst(first), \
				 DeConst(last), 1)
static int SLang_get_error(void)
{
    return SLang_Error;
}
#else
int LY_Slang_UTF8_Mode = 0;

#define expand_substring(target, first, last, final) \
	(SLexpand_escaped_string(target, \
				 DeConst(first), \
				 DeConst(last), \
				 LY_Slang_UTF8_Mode), 1)
#endif

static SLKeyMap_List_Type *Keymap_List;

/* This value should be larger than anything in LYStrings.h */
#define MOUSE_KEYSYM 0x0400
#endif

/*
 * For ncurses, we use the predefined keysyms, since that lets us also reuse
 * the CSI logic and other special cases for VMS, NCSA telnet, etc.
 */
#ifdef USE_SLANG
# ifdef VMS
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx}
# else
#  define EXTERN_KEY(string,string1,lynx,curses) {string,lynx},{string1,lynx}
# endif
# define INTERN_KEY(string,lynx,curses)          {string,lynx,lynx}
#else
# define INTERN_KEY(string,lynx,curses)          {string,curses,lynx}
# define EXTERN_KEY(string,string1,lynx,curses)  {string,curses,lynx}
#endif

typedef struct {
    const char *string;
    int value;
    LYExtraKeys internal;
} Keysym_String_List;
/* *INDENT-OFF* */
static Keysym_String_List Keysym_Strings [] =
{
    INTERN_KEY( "UPARROW",	UPARROW_KEY,	KEY_UP ),
    INTERN_KEY( "DNARROW",	DNARROW_KEY,	KEY_DOWN ),
    INTERN_KEY( "RTARROW",	RTARROW_KEY,	KEY_RIGHT ),
    INTERN_KEY( "LTARROW",	LTARROW_KEY,	KEY_LEFT ),
    INTERN_KEY( "PGDOWN",	PGDOWN_KEY,	KEY_NPAGE ),
    INTERN_KEY( "PGUP",		PGUP_KEY,	KEY_PPAGE ),
    INTERN_KEY( "HOME",		HOME_KEY,	KEY_HOME ),
    INTERN_KEY( "END",		END_KEY,	KEY_END ),
    INTERN_KEY( "F1",		F1_KEY,		KEY_F(1) ),
    INTERN_KEY( "F2",		F2_KEY,		KEY_F(2) ),
    INTERN_KEY( "F3",		F3_KEY,		KEY_F(3) ),
    INTERN_KEY( "F4",		F4_KEY,		KEY_F(4) ),
    INTERN_KEY( "F5",		F5_KEY,		KEY_F(5) ),
    INTERN_KEY( "F6",		F6_KEY,		KEY_F(7) ),
    INTERN_KEY( "F7",		F7_KEY,		KEY_F(7) ),
    INTERN_KEY( "F8",		F8_KEY,		KEY_F(8) ),
    INTERN_KEY( "F9",		F9_KEY,		KEY_F(9) ),
    INTERN_KEY( "F10",		F10_KEY,	KEY_F(10) ),
    INTERN_KEY( "F11",		F11_KEY,	KEY_F(11) ),
    INTERN_KEY( "F12",		F12_KEY,	KEY_F(12) ),
    INTERN_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    INTERN_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    INTERN_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    INTERN_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    INTERN_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    INTERN_KEY( "DO_NOTHING",	DO_NOTHING,	DO_NOTHING|LKC_ISLKC ),
    INTERN_KEY( "BACKTAB_KEY",	BACKTAB_KEY,	BACKTAB_KEY ),
    INTERN_KEY( NULL,		UNKNOWN_KEY,	ERR )
};
/* *INDENT-ON* */

#ifdef NCURSES_VERSION
/*
 * Ncurses stores the termcap/terminfo names in arrays sorted to match the
 * array of strings in the TERMTYPE struct.
 */
static int lookup_tiname(char *name, NCURSES_CONST char *const *names)
{
    int code;

    for (code = 0; names[code] != 0; code++)
	if (!strcmp(names[code], name))
	    return code;
    return -1;
}

static const char *expand_tiname(const char *first, size_t len, char **result, char *final)
{
    char name[BUFSIZ];
    int code;

    LYStrNCpy(name, first, len);
    if ((code = lookup_tiname(name, strnames)) >= 0
	|| (code = lookup_tiname(name, strfnames)) >= 0) {
	if (cur_term->type.Strings[code] != 0) {
	    LYStrNCpy(*result, cur_term->type.Strings[code], (final - *result));
	    (*result) += strlen(*result);
	}
    }
    return first + len;
}

static const char *expand_tichar(const char *first, char **result, char *final)
{
    int ch;
    int limit = 0;
    int radix = 0;
    int value = 0;
    const char *name = 0;

    switch (ch = *first++) {
    case 'E':
    case 'e':
	value = 27;
	break;
    case 'a':
	name = "bel";
	break;
    case 'b':
	value = '\b';
	break;
    case 'f':
	value = '\f';
	break;
    case 'n':
	value = '\n';
	break;
    case 'r':
	value = '\r';
	break;
    case 't':
	value = '\t';
	break;
    case 'v':
	value = '\v';
	break;
    case 'd':
	radix = 10;
	limit = 3;
	break;
    case 'x':
	radix = 16;
	limit = 2;
	break;
    default:
	if (isdigit(ch)) {
	    radix = 8;
	    limit = 3;
	    first--;
	} else {
	    value = *first;
	}
	break;
    }

    if (radix != 0) {
	char *last = 0;
	char tmp[80];

	LYStrNCpy(tmp, first, limit);
	value = (int) strtol(tmp, &last, radix);
	if (last != 0 && last != tmp)
	    first += (last - tmp);
    }

    if (name != 0) {
	(void) expand_tiname(name, strlen(name), result, final);
    } else {
	**result = (char) value;
	(*result) += 1;
    }

    return first;
}

static BOOLEAN expand_substring(char *target,
				const char *first,
				const char *last,
				char *final)
{
    int ch;

    while (first < last) {
	switch (ch = *first++) {
	case ESCAPE:
	    first = expand_tichar(first, &target, final);
	    break;
	case '^':
	    ch = *first++;
	    if (ch == LPAREN) {
		const char *s = StrChr(first, RPAREN);
		char *was = target;

		if (s == 0)
		    s = first + strlen(first);
		first = expand_tiname(first, (size_t) (s - first), &target, final);
		if (target == was)
		    return FALSE;
		if (*first)
		    first++;
	    } else if (ch == '?') {	/* ASCII delete? */
		*target++ = 127;
	    } else if ((ch & 0x3f) < 0x20) {	/* ASCII control char? */
		*target++ = (char) (ch & 0x1f);
	    } else {
		*target++ = '^';
		first--;	/* not legal... */
	    }
	    break;
	case 0:		/* convert nulls for terminfo */
	    ch = 0200;
	    /* FALLTHRU */
	default:
	    *target++ = (char) ch;
	    break;
	}
    }
    *target = '\0';
    return TRUE;
}
#endif

static void unescaped_char(const char *parse, int *keysym)
{
    size_t len = strlen(parse);
    char buf[BUFSIZ];

    if (len >= 3) {
	(void) expand_substring(buf,
				parse + 1,
				parse + len - 1,
				buf + sizeof(buf) - 1);
	if (strlen(buf) == 1)
	    *keysym = *buf;
    }
}

static BOOLEAN unescape_string(char *source, char *target, char *final)
{
    BOOLEAN ok = FALSE;

    if (*source == SQUOTE) {
	int keysym = -1;

	unescaped_char(source, &keysym);
	if (keysym >= 0) {
	    target[0] = (char) keysym;
	    target[1] = '\0';
	    ok = TRUE;
	}
    } else if (*source == DQUOTE) {
	if (expand_substring(target, source + 1, source + strlen(source) - 1, final))
	    ok = TRUE;
	(void) final;
    }
    return ok;
}

static Keysym_String_List *lookupKeysymByName(const char *name)
{
    Keysym_String_List *k;
    Keysym_String_List *result = 0;

    k = Keysym_Strings;
    while (k->string != NULL) {
	if (0 == strcasecomp(k->string, name)) {
	    result = k;
	    break;
	}
	k++;
    }
    return result;
}

int map_string_to_keysym(const char *str, int *keysym)
{
    int modifier = 0;

    *keysym = -1;

    if (strncasecomp(str, "LAC:", 4) == 0) {
	char *other = StrChr(str + 4, ':');

	if (other) {
	    int othersym = lecname_to_lec(other + 1);
	    char buf[BUFSIZ];

	    if (othersym >= 0 && other - str - 4 < BUFSIZ) {
		LYStrNCpy(buf, str + 4, (other - str - 4));
		*keysym = lacname_to_lac(buf);
		if (*keysym >= 0) {
		    *keysym = LACLEC_TO_LKC0(*keysym, othersym);
		    return (*keysym);
		}
	    }
	}
	*keysym = lacname_to_lac(str + 4);
	if (*keysym >= 0) {
	    *keysym = LAC_TO_LKC0(*keysym);
	    return (*keysym);
	}
    } else if (strncasecomp(str, "Meta-", 5) == 0) {
	str += 5;
	modifier = LKC_MOD2;
	if (*str) {
	    size_t len = strlen(str);

	    if (len == 1) {
		return (*keysym = (UCH(str[0])) | modifier);
	    } else if (len == 2 && str[0] == '^' &&
		       (isalpha(UCH(str[1])) ||
			(TOASCII(str[1]) >= '@@' && TOASCII(str[1]) <= '_'))) {
		return (*keysym = FROMASCII(UCH(str[1] & 0x1f)) | modifier);
	    } else if (len == 2 && str[0] == '^' &&
		       str[1] == '?') {
		return (*keysym = CH_DEL | modifier);
	    }
	    if (*str == '^' || *str == '\\') {
		char buf[BUFSIZ];

		(void) expand_substring(buf,
					str,
					str + HTMIN(len, 28),
					buf + sizeof(buf) - 1);
		if (strlen(buf) <= 1)
		    return (*keysym = (UCH(buf[0])) | modifier);
	    }
	}
    } else if (*str == SQUOTE) {
	unescaped_char(str, keysym);
    } else if (isdigit(UCH(*str))) {
	char *tmp;
	long value = strtol(str, &tmp, 0);

	if (!isalnum(UCH(*tmp))) {
	    *keysym = (int) value;
#ifndef USE_SLANG
	    if (*keysym > 255)
		*keysym |= LKC_ISLKC;	/* caller should remove this flag - kw */
#endif
	}
    } else {
	Keysym_String_List *k = lookupKeysymByName(str);

	if (k != 0) {
	    *keysym = k->value;
	}
    }

    if (*keysym >= 0)
	*keysym |= modifier;
    return (*keysym);
}

LYExtraKeys LYnameToExtraKeys(const char *name)
{
    Keysym_String_List *k = lookupKeysymByName(name);
    LYExtraKeys result = UNKNOWN_KEY;

    if (k != 0)
	result = k->internal;
    return result;
}

const char *LYextraKeysToName(LYExtraKeys code)
{
    Keysym_String_List *k;
    const char *result = 0;

    k = Keysym_Strings;
    while (k->string != NULL) {
	if (k->internal == code) {
	    result = k->string;
	    break;
	}
	k++;
    }
    return result;
}

/*
 * Starting at a nonblank character, skip over a token, counting quoted and
 * escaped characters.
 */
static char *skip_keysym(char *parse)
{
    int quoted = 0;
    int escaped = 0;

    while (*parse) {
	if (escaped) {
	    escaped = 0;
	} else if (quoted) {
	    if (*parse == ESCAPE) {
		escaped = 1;
	    } else if (*parse == quoted) {
		quoted = 0;
	    }
	} else if (*parse == ESCAPE) {
	    escaped = 1;
	} else if (*parse == DQUOTE || *parse == SQUOTE) {
	    quoted = *parse;
	} else if (isspace(UCH(*parse))) {
	    break;
	}
	parse++;
    }
    return (quoted || escaped) ? 0 : parse;
}

/*
 * The first token is the string to define, the second is the name (of the
 * keysym) to define it to.
 */
#define MY_TRACE(p) CTRACE2(TRACE_CFG, p)

static int setkey_cmd(char *parse)
{
    char *s, *t;
    int keysym;
    char buf[BUFSIZ];

    MY_TRACE((tfp, "KEYMAP(PA): in=%s", parse));	/* \n-terminated */
    if ((s = skip_keysym(parse)) != 0) {
	if (isspace(UCH(*s))) {
	    *s++ = '\0';
	    s = LYSkipBlanks(s);
	    if ((t = skip_keysym(s)) == 0) {
		MY_TRACE((tfp, "KEYMAP(SKIP) no key expansion found\n"));
		return -1;
	    }
	    if (t != s)
		*t = '\0';
	    if (map_string_to_keysym(s, &keysym) >= 0) {
		if (!unescape_string(parse, buf, buf + sizeof(buf) - 1)) {
		    MY_TRACE((tfp, "KEYMAP(SKIP) could unescape key\n"));
		    return 0;	/* Trace the failure and continue. */
		}
		if (LYTraceLogFP == 0) {
		    MY_TRACE((tfp, "KEYMAP(DEF) keysym=%#x\n", keysym));
		} else {
		    MY_TRACE((tfp, "KEYMAP(DEF) keysym=%#x, seq='%s'\n",
			      keysym, buf));
		}
		return define_key(buf, keysym);
	    } else {
		MY_TRACE((tfp, "KEYMAP(SKIP) could not map to keysym\n"));
	    }
	} else {
	    MY_TRACE((tfp, "KEYMAP(SKIP) junk after key description: '%s'\n", s));
	}
    } else {
	MY_TRACE((tfp, "KEYMAP(SKIP) no key description\n"));
    }
    return -1;
}
#undef MY_TRACE

static int unsetkey_cmd(char *parse)
{
    char *s = skip_keysym(parse);

    if (s != parse) {
	*s = '\0';
#ifdef NCURSES_VERSION
	/*
	 * This won't work with Slang.  Remove the definition for the given
	 * keysym.
	 */
	{
	    int keysym;

	    if (map_string_to_keysym(parse, &keysym) >= 0)
		define_key((char *) 0, keysym);
	}
#endif
#ifdef USE_SLANG
	/* Slang implements this, for undefining the string which is associated
	 * with a keysym (the reverse of what we normally want, but may
	 * occasionally find useful).
	 */
	SLang_undefine_key(parse, Keymap_List);
	if (SLang_get_error())
	    return -1;
#endif
    }
    return 0;
}

#ifdef FNAMES_8_3
#define FNAME_LYNX_KEYMAPS "_lynxkey.map"
#else
#define FNAME_LYNX_KEYMAPS ".lynx-keymaps"
#endif /* FNAMES_8_3 */

static int read_keymap_file(void)
{
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	int (*func) (char *s);
    } table[] = {
	{ "setkey",   setkey_cmd },
	{ "unsetkey", unsetkey_cmd },
    };
    /* *INDENT-ON* */

    char *line = NULL;
    FILE *fp;
    char file[LY_MAXPATH];
    int linenum;
    size_t n;

    LYAddPathToHome(file, sizeof(file), FNAME_LYNX_KEYMAPS);

    if ((fp = fopen(file, "r")) == 0)
	return 0;

    linenum = 0;
    while (LYSafeGets(&line, fp) != 0) {
	char *s = LYSkipBlanks(line);

	linenum++;

	if ((*s == 0) || (*s == '#'))
	    continue;

	for (n = 0; n < TABLESIZE(table); n++) {
	    size_t len = strlen(table[n].name);

	    if (strlen(s) > len && !StrNCmp(s, table[n].name, len)
		&& (*(table[n].func)) (LYSkipBlanks(s + len)) < 0)
		fprintf(stderr, FAILED_READING_KEYMAP, linenum, file);
	}
    }
    FREE(line);
    LYCloseInput(fp);
    return 0;
}

static void setup_vtXXX_keymap(void)
{
    /* *INDENT-OFF* */
    static Keysym_String_List table[] = {
	INTERN_KEY( "\033[A",	UPARROW_KEY,	KEY_UP ),
	INTERN_KEY( "\033OA",	UPARROW_KEY,	KEY_UP ),
	INTERN_KEY( "\033[B",	DNARROW_KEY,	KEY_DOWN ),
	INTERN_KEY( "\033OB",	DNARROW_KEY,	KEY_DOWN ),
	INTERN_KEY( "\033[C",	RTARROW_KEY,	KEY_RIGHT ),
	INTERN_KEY( "\033OC",	RTARROW_KEY,	KEY_RIGHT ),
	INTERN_KEY( "\033[D",	LTARROW_KEY,	KEY_LEFT ),
	INTERN_KEY( "\033OD",	LTARROW_KEY,	KEY_LEFT ),
	INTERN_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	INTERN_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY( "\033[5~",	PGUP_KEY,	KEY_PPAGE ),
	INTERN_KEY( "\033[6~",	PGDOWN_KEY,	KEY_NPAGE ),
	INTERN_KEY( "\033[7~",	HOME_KEY,	KEY_HOME),
	INTERN_KEY( "\033[8~",	END_KEY,	KEY_END ),
	INTERN_KEY( "\033[11~",	F1_KEY,		KEY_F(1) ),
	INTERN_KEY( "\033[28~",	F1_KEY,		KEY_F(1) ),
	INTERN_KEY( "\033OP",	F1_KEY,		KEY_F(1) ),
	INTERN_KEY( "\033[OP",	F1_KEY,		KEY_F(1) ),
	INTERN_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
#if defined(USE_SLANG)
#if defined(__WIN32__) || defined(__MINGW32__)
	INTERN_KEY( "\xE0H",	UPARROW_KEY,	KEY_UP ),
	INTERN_KEY( "\xE0P",	DNARROW_KEY,	KEY_DOWN ),
	INTERN_KEY( "\xE0M",	RTARROW_KEY,	KEY_RIGHT ),
	INTERN_KEY( "\xE0K",	LTARROW_KEY,	KEY_LEFT ),
	INTERN_KEY( "\xE0R",	INSERT_KEY,	KEY_IC ),
	INTERN_KEY( "\xE0S",	REMOVE_KEY,	KEY_DC ),
	INTERN_KEY( "\xE0I",	PGUP_KEY,	KEY_PPAGE ),
	INTERN_KEY( "\xE0Q",	PGDOWN_KEY,	KEY_NPAGE ),
	INTERN_KEY( "\xE0G",	HOME_KEY,	KEY_HOME),
	INTERN_KEY( "\xE0O",	END_KEY,	KEY_END ),
#endif
#if !defined(VMS)
	INTERN_KEY(	"^(ku)", UPARROW_KEY,	KEY_UP ),
	INTERN_KEY(	"^(kd)", DNARROW_KEY,	KEY_DOWN ),
	INTERN_KEY(	"^(kr)", RTARROW_KEY,	KEY_RIGHT ),
	INTERN_KEY(	"^(kl)", LTARROW_KEY,	KEY_LEFT ),
	INTERN_KEY(	"^(@@0)", FIND_KEY,	KEY_FIND ),
	INTERN_KEY(	"^(kI)", INSERT_KEY,	KEY_IC ),
	INTERN_KEY(	"^(kD)", REMOVE_KEY,	KEY_DC ),
	INTERN_KEY(	"^(*6)", SELECT_KEY,	KEY_SELECT ),
	INTERN_KEY(	"^(kP)", PGUP_KEY,	KEY_PPAGE ),
	INTERN_KEY(	"^(kN)", PGDOWN_KEY,	KEY_NPAGE ),
	INTERN_KEY(	"^(@@7)", END_KEY,	KEY_END ),
	INTERN_KEY(	"^(kh)", HOME_KEY,	KEY_HOME),
	INTERN_KEY(	"^(k1)", F1_KEY,	KEY_F(1) ),
	INTERN_KEY(	"^(k2)", F2_KEY,	KEY_F(2) ),
	INTERN_KEY(	"^(k3)", F3_KEY,	KEY_F(3) ),
	INTERN_KEY(	"^(k4)", F4_KEY,	KEY_F(4) ),
	INTERN_KEY(	"^(k5)", F5_KEY,	KEY_F(5) ),
	INTERN_KEY(	"^(k6)", F6_KEY,	KEY_F(6) ),
	INTERN_KEY(	"^(k7)", F7_KEY,	KEY_F(7) ),
	INTERN_KEY(	"^(k8)", F8_KEY,	KEY_F(8) ),
	INTERN_KEY(	"^(k9)", F9_KEY,	KEY_F(9) ),
	INTERN_KEY(	"^(k;)", F10_KEY,	KEY_F(10) ),
	INTERN_KEY(	"^(F1)", F11_KEY,	KEY_F(11) ),
	INTERN_KEY(	"^(F2)", F12_KEY,	KEY_F(12) ),
	INTERN_KEY(	"^(F6)", DO_KEY,	KEY_F(16) ),
#endif /* !VMS */
#endif /* SLANG */
    };
    /* *INDENT-ON* */

    size_t n;

    for (n = 0; n < TABLESIZE(table); n++)
	define_key(table[n].string, table[n].value);
}

int lynx_initialize_keymaps(void)
{
#ifdef USE_SLANG
    int i;
    char keybuf[2];

    /* The escape sequences may contain embedded termcap strings.  Make
     * sure the library is initialized for that.
     */
    SLtt_get_terminfo();

    if (NULL == (Keymap_List = SLang_create_keymap("Lynx", NULL)))
	return -1;

    keybuf[1] = 0;
    for (i = 1; i < 256; i++) {
	keybuf[0] = (char) i;
	define_key(keybuf, i);
    }

    setup_vtXXX_keymap();
    define_key("\033[M", MOUSE_KEYSYM);

    if (SLang_get_error())
	SLang_exit_error("Unable to initialize keymaps");
#else
    setup_vtXXX_keymap();
#endif
    return read_keymap_file();
}

#endif /* USE_KEYMAPS */

#if defined(USE_MOUSE) && (defined(NCURSES))
static int LYmouse_menu(int x, int y, int atlink, int code)
{
#define ENT_ONLY_DOC	1
#define ENT_ONLY_LINK	2
    /* *INDENT-OFF* */
    static const struct {
	const char *txt;
	int  action;
	unsigned int  flag;
    } possible_entries[] = {
	{"Quit",			LYK_ABORT,		ENT_ONLY_DOC},
	{"Home page",			LYK_MAIN_MENU,		ENT_ONLY_DOC},
	{"Previous document",		LYK_PREV_DOC,		ENT_ONLY_DOC},
	{"Beginning of document",	LYK_HOME,		ENT_ONLY_DOC},
	{"Page up",			LYK_PREV_PAGE,		ENT_ONLY_DOC},
	{"Half page up",		LYK_UP_HALF,		ENT_ONLY_DOC},
	{"Two lines up",		LYK_UP_TWO,		ENT_ONLY_DOC},
	{"History",			LYK_HISTORY,		ENT_ONLY_DOC},
	{"Help",			LYK_HELP,		0},
	{"Do nothing (refresh)",	LYK_REFRESH,		0},
	{"Load again",			LYK_RELOAD,		ENT_ONLY_DOC},
	{"Edit Doc URL and load",	LYK_ECGOTO,		ENT_ONLY_DOC},
	{"Edit Link URL and load",	LYK_ELGOTO,		ENT_ONLY_LINK},
	{"Show info",			LYK_INFO,		0},
	{"Search",			LYK_WHEREIS,		ENT_ONLY_DOC},
	{"Print",			LYK_PRINT,		ENT_ONLY_DOC},
	{"Two lines down",		LYK_DOWN_TWO,		ENT_ONLY_DOC},
	{"Half page down",		LYK_DOWN_HALF,		ENT_ONLY_DOC},
	{"Page down",			LYK_NEXT_PAGE,		ENT_ONLY_DOC},
	{"End of document",		LYK_END,		ENT_ONLY_DOC},
	{"Bookmarks",			LYK_VIEW_BOOKMARK,	ENT_ONLY_DOC},
	{"Cookie jar",			LYK_COOKIE_JAR,		ENT_ONLY_DOC},
#ifdef USE_CACHEJAR
	{"Cache jar",			LYK_CACHE_JAR,		ENT_ONLY_DOC},
#endif
	{"Search index",		LYK_INDEX_SEARCH,	ENT_ONLY_DOC},
	{"Set Options",			LYK_OPTIONS,		ENT_ONLY_DOC},
	{"Activate this link",		LYK_MOUSE_SUBMIT,	ENT_ONLY_LINK},
	{"Download",			LYK_DOWNLOAD,		ENT_ONLY_LINK}
    };
    /* *INDENT-ON* */

#define TOTAL_MENUENTRIES	TABLESIZE(possible_entries)
    const char *choices[TOTAL_MENUENTRIES + 1];
    int actions[TOTAL_MENUENTRIES];

    int c, c1, retlac;
    unsigned filter_out = (unsigned) (atlink ? ENT_ONLY_DOC : ENT_ONLY_LINK);

    c = c1 = 0;
    while (c < (int) TOTAL_MENUENTRIES) {
	if (!(possible_entries[c].flag & filter_out)) {
	    choices[c1] = possible_entries[c].txt;
	    actions[c1++] = possible_entries[c].action;
	}
	c++;
    }
    choices[c1] = NULL;

    /* Somehow the mouse is over the number instead of being over the
       name, so we decrease x. */
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x - 5 : 1),
		      choices, c1, FALSE, TRUE);

    /*
     * LYhandlePopupList() wasn't really meant to be used outside of old-style
     * Options menu processing.  One result of mis-using it here is that we
     * have to deal with side-effects regarding SIGINT signal handler and the
     * term_options global variable.  - kw
     */
    if (term_options) {
	retlac = LYK_DO_NOTHING;
	term_options = FALSE;
    } else {
	retlac = actions[c];
    }

    if (code == FOR_INPUT && mouse_link == -1) {
	switch (retlac) {
	case LYK_ABORT:
	    retlac = LYK_QUIT;	/* a bit softer... */
	    /* fall through */
	case LYK_MAIN_MENU:
	case LYK_PREV_DOC:
	case LYK_HOME:
	case LYK_PREV_PAGE:
	case LYK_UP_HALF:
	case LYK_UP_TWO:
	case LYK_HISTORY:
	case LYK_HELP:
/*	    case LYK_REFRESH:*/
	case LYK_RELOAD:
	case LYK_ECGOTO:
	case LYK_INFO:
	case LYK_WHEREIS:
	case LYK_PRINT:
	case LYK_DOWN_TWO:
	case LYK_DOWN_HALF:
	case LYK_NEXT_PAGE:
	case LYK_END:
	case LYK_VIEW_BOOKMARK:
	case LYK_COOKIE_JAR:
#ifdef USE_CACHEJAR
	case LYK_CACHE_JAR:
#endif
	case LYK_INDEX_SEARCH:
	case LYK_OPTIONS:
	    mouse_link = -3;	/* so LYgetch_for() passes it on - kw */
	}
    }
    if (retlac == LYK_DO_NOTHING ||
	retlac == LYK_REFRESH) {
	mouse_link = -1;	/* mainloop should not change cur link - kw */
    }
    if (code == FOR_INPUT && retlac == LYK_DO_NOTHING) {
	repaint_main_statusline(FOR_INPUT);
    }
    return retlac;
}
#endif /* USE_MOUSE && (NCURSES || PDCURSES) */

#if defined(USE_KEYMAPS) && defined(USE_SLANG)
/************************************************************************/

static int current_sl_modifier = 0;

/* We cannot guarantee the type for 'GetChar', and should not use a cast. */
static int myGetChar(void)
{
    int i = GetChar();

    if (i == 0)			/* trick to get NUL char through - kw */
	current_sl_modifier = LKC_ISLKC;
    return i;
}

static int LYgetch_for(int code)
{
    SLang_Key_Type *key;
    int keysym;

    current_sl_modifier = 0;

    key = SLang_do_key(Keymap_List, myGetChar);
    if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
#if defined(__WIN32__) || defined(__MINGW32__)
	if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
	    key = SLang_do_key(Keymap_List, myGetChar);
	    keysym = key->f.keysym;
	    switch (keysym) {
	    case 'H':
		keysym = UPARROW_KEY;
		break;
	    case 'P':
		keysym = DNARROW_KEY;
		break;
	    case 'M':
		keysym = RTARROW_KEY;
		break;
	    case 'K':
		keysym = LTARROW_KEY;
		break;
	    case 'R':
		keysym = INSERT_KEY;
		break;
	    case 'S':
		keysym = REMOVE_KEY;
		break;
	    case 'I':
		keysym = PGUP_KEY;
		break;
	    case 'Q':
		keysym = PGDOWN_KEY;
		break;
	    case 'G':
		keysym = HOME_KEY;
		break;
	    case 'O':
		keysym = END_KEY;
		break;
	    case ';':
		keysym = F1_KEY;
		break;
	    }
	    return (keysym);
	}
#endif
	return (current_sl_modifier ? 0 : DO_NOTHING);
    } else {
	keysym = (int) key->f.keysym;

#if defined (USE_MOUSE)
	if (keysym == MOUSE_KEYSYM)
	    return sl_read_mouse_event(code);
#endif

	if (keysym < 0) {
	    return 0;

	} else if (keysym & (LKC_ISLECLAC | LKC_ISLAC)) {
	    return (keysym);
	} else {
	    current_sl_modifier = 0;
	    if (LKC_HAS_ESC_MOD(keysym)) {
		current_sl_modifier = LKC_MOD2;
		keysym &= LKC_MASK;
	    }

	    if (keysym + 1 >= KEYMAP_SIZE) {
		return 0;
	    } else {
		return (keysym | current_sl_modifier);
	    }
	}
    }
}

/************************************************************************/
#else /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

/*
 * LYgetch() translates some escape sequences and may fake noecho.
 */
#define found_CSI(first,second) ((second) == '[' || (first) == 155)
#define found_TLD(value)	((value) == '~')

static int LYgetch_for(int code)
{
    int a, b, c, d = -1;
    int current_modifier = 0;
    BOOLEAN done_esc = FALSE;

    (void) code;

    have_levent = 0;

  re_read:
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
    if (errno == EINTR)
	set_errno(0);		/* reset - kw */
#endif /* UCX && VAXC */
#ifndef USE_SLANG
    clearerr(stdin);		/* needed here for ultrix and SOCKETSHR, but why? - FM */
#endif /* !USE_SLANG */
#if !defined(USE_SLANG) || defined(VMS) || defined(DJGPP_KEYHANDLER)
    c = GetChar();
    lynx_nl2crlf(FALSE);
#else
    if (LYCursesON) {
	c = GetChar();
	lynx_nl2crlf(FALSE);
    } else {
	c = getchar();
	if (c == EOF && errno == EINTR)		/* Ctrl-Z causes EINTR in getchar() */
	    clearerr(stdin);
	if (feof(stdin) || ferror(stdin) || c == EOF) {
#ifdef IGNORE_CTRL_C
	    if (sigint)
		sigint = FALSE;
#endif /* IGNORE_CTRL_C */
	    CTRACE((tfp, "GETCH: Translate ^C to ^G.\n"));
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
	}
    }
#endif /* !USE_SLANG || VMS */

    CTRACE((tfp, "GETCH%d: Got %#x.\n", code, c));
#ifdef MISC_EXP
    if (LYNoZapKey > 1 && errno != EINTR &&
	(c == EOF
#ifdef USE_SLANG
	 || (c == 0xFFFF)
#endif
	)) {

	CTRACE((tfp,
		"nozap: Got EOF, curses %s, stdin is %p, LYNoZapKey reduced from %d to 0.\n",
		LYCursesON ? "on" : "off", (void *) stdin, LYNoZapKey));
	LYNoZapKey = 0;		/* 2 -> 0 */
	if (LYReopenInput() > 0) {
	    if (LYCursesON) {
		stop_curses();
		start_curses();
		LYrefresh();
	    }
	    goto re_read;
	}
    }
#endif /* MISC_EXP */

#ifdef USE_GETCHAR
    if (c == EOF && errno == EINTR)	/* Ctrl-Z causes EINTR in getchar() */
	goto re_read;
#else
    if (c == EOF && errno == EINTR) {

#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		recent_sizechange));
	if (!recent_sizechange) {	/* not yet detected by ourselves */
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	}
#else /* HAVE_SIZECHANGE || USE_SLANG */
	CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ? */
	set_errno(0);		/* reset - kw */
#endif /* UCX && VAXC */
	return (DO_NOTHING);
    }
#endif /* USE_GETCHAR */

#ifdef USE_SLANG
    if (c == 0xFFFF && LYCursesON) {
#ifdef IGNORE_CTRL_C
	if (sigint) {
	    sigint = FALSE;
	    goto re_read;
	}
#endif /* IGNORE_CTRL_C */
	return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
    }
#else /* not USE_SLANG: */
    if (feof(stdin) || ferror(stdin) || c == EOF) {
	if (recent_sizechange)
	    return (LYCharINTERRUPT2);	/* use ^G to cancel whatever called us. */
#ifdef IGNORE_CTRL_C
	if (sigint) {
	    sigint = FALSE;
	    /* clearerr(stdin);  don't need here if stays above - FM */
	    goto re_read;
	}
#endif /* IGNORE_CTRL_C */
#if !defined(USE_GETCHAR) && !defined(VMS) && !defined(NCURSES)
	if (c == ERR && errno == EINTR)		/* may have been handled signal - kw */
	    goto re_read;
#endif /* USE_GETCHAR */

	cleanup();
	exit_immediately(EXIT_SUCCESS);
    }
#endif /* USE_SLANG */

    if (!escape_bound
	&& (c == CH_ESC || (csi_is_csi && c == UCH(CH_ESC_PAR)))) {
	/* handle escape sequence  S/390 -- gil -- 2024 */
	done_esc = TRUE;	/* Flag: we did it, not keypad() */
	b = GetChar();

	if (b == '[' || b == 'O') {
	    a = GetChar();
	} else {
	    a = b;
	}

	switch (a) {
	case 'A':
	    c = UPARROW_KEY;
	    break;
	case 'B':
	    c = DNARROW_KEY;
	    break;
	case 'C':
	    c = RTARROW_KEY;
	    break;
	case 'D':
	    c = LTARROW_KEY;
	    break;
	case 'q':		/* vt100 application keypad 1 */
	    c = END_KEY;
	    break;
	case 'r':		/* vt100 application keypad 2 */
	    c = DNARROW_KEY;
	    break;
	case 's':		/* vt100 application keypad 3 */
	    c = PGDOWN_KEY;
	    break;
	case 't':		/* vt100 application keypad 4 */
	    c = LTARROW_KEY;
	    break;
	case 'v':		/* vt100 application keypad 6 */
	    c = RTARROW_KEY;
	    break;
	case 'w':		/* vt100 application keypad 7 */
	    c = HOME_KEY;
	    break;
	case 'x':		/* vt100 application keypad 8 */
	    c = UPARROW_KEY;
	    break;
	case 'y':		/* vt100 application keypad 9 */
	    c = PGUP_KEY;
	    break;
	case 'M':
#if defined(USE_SLANG) && defined(USE_MOUSE)
	    if (found_CSI(c, b)) {
		c = sl_read_mouse_event(code);
	    } else
#endif
		c = '\n';	/* keypad enter on pc ncsa telnet */
	    break;

	case 'm':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = '-';	/* keypad on pc ncsa telnet */
	    break;
	case 'k':
	    if (b == 'O')
		c = '+';	/* keypad + on my xterminal :) */
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case 'l':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = '+';	/* keypad on pc ncsa telnet */
	    break;
	case 'P':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = F1_KEY;
	    break;
	case 'u':
#ifdef VMS
	    if (b != 'O')
#endif /* VMS */
		c = F1_KEY;	/* macintosh help button */
	    break;
	case 'p':
#ifdef VMS
	    if (b == 'O')
#endif /* VMS */
		c = '0';	/* keypad 0 */
	    break;
	case '1':		/* VTxxx  Find  */
	    if (found_CSI(c, b) && found_TLD(d = GetChar()))
		c = FIND_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '2':
	    if (found_CSI(c, b)) {
		if (found_TLD(d = GetChar()))	/* VTxxx Insert */
		    c = INSERT_KEY;
		else if ((d == '8' ||
			  d == '9') &&
			 found_TLD(GetChar())) {
		    if (d == '8')	/* VTxxx   Help */
			c = F1_KEY;
		    else if (d == '9')	/* VTxxx    Do  */
			c = DO_KEY;
		    d = -1;
		}
	    } else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '3':			     /** VTxxx Delete **/
	    if (found_CSI(c, b) && found_TLD(d = GetChar()))
		c = REMOVE_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '4':			     /** VTxxx Select **/
	    if (found_CSI(c, b) && found_TLD(d = GetChar()))
		c = SELECT_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '5':			     /** VTxxx PrevScreen **/
	    if (found_CSI(c, b) && found_TLD(d = GetChar()))
		c = PGUP_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '6':			     /** VTxxx NextScreen **/
	    if (found_CSI(c, b) && found_TLD(d = GetChar()))
		c = PGDOWN_KEY;
	    else
		done_esc = FALSE;	/* we have another look below - kw */
	    break;
	case '[':			     /** Linux F1-F5: ^[[[A etc. **/
	    if (found_CSI(c, b)) {
		if ((d = GetChar()) == 'A')
		    c = F1_KEY;
		break;
	    }
	    /* FALLTHRU */
	default:
	    if (c == CH_ESC && a == b && !found_CSI(c, b)) {
		current_modifier = LKC_MOD2;
		c = a;
		/* We're not yet done if ESC + curses-keysym: */
		done_esc = (BOOL) ((a & ~0xFF) == 0);
		break;
	    }
	    CTRACE((tfp, "Unknown key sequence: %d:%d:%d\n", c, b, a));
	    CTRACE_SLEEP(MessageSecs);
	    break;
	}
	if (isdigit(a) && found_CSI(c, b) && d != -1 && !found_TLD(d))
	    d = GetChar();
	if (!done_esc && (a & ~0xFF) == 0) {
	    if (a == b && !found_CSI(c, b) && c == CH_ESC) {
		current_modifier = LKC_MOD2;
		c = a;
		done_esc = TRUE;
	    } else {
		done_esc = TRUE;
	    }
	}
    }
#ifdef USE_KEYMAPS
    /* Extract a single code if two are merged: */
    if (c >= 0 && (c & LKC_ISLECLAC)) {
	if (!(code == FOR_INPUT || code == FOR_PROMPT))
	    c = LKC2_TO_LKC(c);
    } else if (c >= 0 && (c & LKC_ISLKC)) {
	c &= ~LKC_ISLKC;
	done_esc = TRUE;	/* already a lynxkeycode, skip keypad switches - kw */
    }
    if (c >= 0 && LKC_HAS_ESC_MOD(c)) {
	current_modifier = LKC_MOD2;
	c &= LKC_MASK;
    }
    if (c >= 0 && (c & (LKC_ISLECLAC | LKC_ISLAC))) {
	done_esc = TRUE;	/* already a lynxactioncode, skip keypad switches - iz */
    }
#endif
    if (done_esc) {
	/* don't do keypad() switches below, we already got it - kw */
    } else {
#ifdef HAVE_KEYPAD
	/*
	 * Convert keypad() mode keys into Lynx defined keys.
	 */
	switch (c) {
	case KEY_DOWN:		/* The four arrow keys ... */
	    c = DNARROW_KEY;
	    break;
	case KEY_UP:
	    c = UPARROW_KEY;
	    break;
	case KEY_LEFT:
	    c = LTARROW_KEY;
	    break;
	case KEY_RIGHT:	/* ... */
	    c = RTARROW_KEY;
	    break;
#if defined(PDCURSES)		/* for NEC PC-9800 1998/08/30 (Sun) 21:50:35 */
	case KEY_C2:
	    c = DNARROW_KEY;
	    break;
	case KEY_A2:
	    c = UPARROW_KEY;
	    break;
	case KEY_B1:
	    c = LTARROW_KEY;
	    break;
	case KEY_B3:
	    c = RTARROW_KEY;
	    break;
	case PAD0:		/* PC-9800 Ins */
	    c = INSERT_KEY;
	    break;
	case PADSTOP:		/* PC-9800 DEL */
	    c = REMOVE_KEY;
	    break;
#endif /* PDCURSES */
	case KEY_HOME:		/* Home key (upward+left arrow) */
	    c = HOME_KEY;
	    break;
	case KEY_CLEAR:	/* Clear screen */
	    c = 18;		/* CTRL-R */
	    break;
	case KEY_NPAGE:	/* Next page */
	    c = PGDOWN_KEY;
	    break;
	case KEY_PPAGE:	/* Previous page */
	    c = PGUP_KEY;
	    break;
	case KEY_LL:		/* home down or bottom (lower left) */
	    c = END_KEY;
	    break;
#if defined(KEY_A1) && defined(KEY_C3)
	    /* The keypad is arranged like this: */
	    /*    a1    up    a3   */
	    /*   left   b2  right  */
	    /*    c1   down   c3   */
	case KEY_A1:		/* upper left of keypad */
	    c = HOME_KEY;
	    break;
	case KEY_A3:		/* upper right of keypad */
	    c = PGUP_KEY;
	    break;
	case KEY_B2:		/* center of keypad */
	    c = DO_NOTHING;
	    break;
	case KEY_C1:		/* lower left of keypad */
	    c = END_KEY;
	    break;
	case KEY_C3:		/* lower right of keypad */
	    c = PGDOWN_KEY;
	    break;
#endif /* defined(KEY_A1) && defined(KEY_C3) */
#ifdef KEY_ENTER
	case KEY_ENTER:	/* enter/return      */
	    c = '\n';
	    break;
#endif /* KEY_ENTER */
#ifdef PADENTER			/* PDCURSES */
	case PADENTER:
	    c = '\n';
	    break;
#endif /* PADENTER */
#ifdef KEY_END
	case KEY_END:		/* end key           001 */
	    c = END_KEY;
	    break;
#endif /* KEY_END */
#ifdef KEY_HELP
	case KEY_HELP:		/* help key          001 */
	    c = F1_KEY;
	    break;
#endif /* KEY_HELP */
#ifdef KEY_BACKSPACE
	case KEY_BACKSPACE:
	    c = CH_DEL;		/* backspace key (delete, not Ctrl-H)  S/390 -- gil -- 2041 */
	    break;
#endif /* KEY_BACKSPACE */
	case KEY_F(1):
	    c = F1_KEY;		/* VTxxx Help */
	    break;
#if defined(KEY_F) && !defined(__DJGPP__) && !defined(_WINDOWS)
	case KEY_F(16):
	    c = DO_KEY;		/* VTxxx Do */
	    break;
#endif /* KEY_F */
#ifdef KEY_REDO
	case KEY_REDO:		/* VTxxx Do */
	    c = DO_KEY;
	    break;
#endif /* KEY_REDO */
#ifdef KEY_FIND
	case KEY_FIND:
	    c = FIND_KEY;	/* VTxxx Find */
	    break;
#endif /* KEY_FIND */
#ifdef KEY_SELECT
	case KEY_SELECT:
	    c = SELECT_KEY;	/* VTxxx Select */
	    break;
#endif /* KEY_SELECT */
#ifdef KEY_IC
	case KEY_IC:
	    c = INSERT_KEY;	/* VTxxx Insert */
	    break;
#endif /* KEY_IC */
#ifdef KEY_DC
	case KEY_DC:
	    c = REMOVE_KEY;	/* VTxxx Remove */
	    break;
#endif /* KEY_DC */
#ifdef KEY_BTAB
	case KEY_BTAB:
	    c = BACKTAB_KEY;	/* Back tab, often Shift-Tab */
	    break;
#endif /* KEY_BTAB */
#ifdef KEY_RESIZE
	case KEY_RESIZE:	/* size change detected by ncurses */
#if defined(HAVE_SIZECHANGE) || defined(USE_SLANG)
	    /* Make call to detect new size, if that may be implemented.
	     * The call may set recent_sizechange (except for USE_SLANG),
	     * which will tell mainloop() to refresh. - kw
	     */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange so far is %d\n",
		    recent_sizechange));
	    size_change(0);
	    CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
#else /* HAVE_SIZECHANGE || USE_SLANG */
	    CTRACE((tfp, "Got KEY_RESIZE, recent_sizechange is %d\n",
		    recent_sizechange));
#endif /* HAVE_SIZECHANGE || USE_SLANG */
	    if (!recent_sizechange) {
#if defined(NCURSES)
		/*
		 * Work-around for scenario (Linux libc5) where we got a
		 * recent sizechange before reading KEY_RESIZE.  If we do
		 * not reset the flag, we'll next get an EOF read, which
		 * causes Lynx to exit.
		 */
		recent_sizechange = TRUE;
#endif
		/*
		 * May be just the delayed effect of mainloop()'s call to
		 * resizeterm().  Pretend we haven't read anything yet, don't
		 * return.  - kw
		 */
		goto re_read;
	    }
	    /*
	     * Yep, we agree there was a change.  Return now so that the caller
	     * can react to it.  - kw
	     */
	    c = DO_NOTHING;
	    break;
#endif /* KEY_RESIZE */

/* The following maps PDCurses keys away from lynx reserved values */
#if (defined(_WINDOWS) || defined(__DJGPP__)) && !defined(USE_SLANG)
	case KEY_F(2):
	    c = 0x213;
	    break;
	case KEY_F(3):
	    c = 0x214;
	    break;
	case KEY_F(4):
	    c = 0x215;
	    break;
	case KEY_F(5):
	    c = 0x216;
	    break;
	case KEY_F(6):
	    c = 0x217;
	    break;
	case KEY_F(7):
	    c = 0x218;
	    break;
#endif /* PDCurses */

#if defined(USE_MOUSE)
/********************************************************************/

#if defined(NCURSES) || defined(PDCURSES)
	case KEY_MOUSE:
	    CTRACE((tfp, "KEY_MOUSE\n"));
	    if (code == FOR_CHOICE) {
		c = MOUSE_KEY;	/* Will be processed by the caller */
	    }
#if defined(NCURSES)
	    else if (code == FOR_SINGLEKEY) {
		MEVENT event;

		getmouse(&event);	/* Completely ignore event - kw */
		c = DO_NOTHING;
	    }
#endif
	    else {
#if defined(NCURSES)
		MEVENT event;
		int err;
		int lac = LYK_UNKNOWN;

		c = -1;
		mouse_link = -1;
		err = getmouse(&event);
		if (err != OK) {
		    CTRACE((tfp, "Mouse error: no event available!\n"));
		    return (code == FOR_PANEL ? 0 : DO_NOTHING);
		}
		levent = event;	/* Allow setting pos in entry fields */
		if (event.bstate & BUTTON1_CLICKED) {
		    c = set_clicked_link(event.x, event.y, code, 1);
		} else if (event.bstate & BUTTON1_DOUBLE_CLICKED) {
		    c = set_clicked_link(event.x, event.y, code, 2);
		    if (c == LAC_TO_LKC0(LYK_MOUSE_SUBMIT) &&
			code == FOR_INPUT)
			lac = LYK_MOUSE_SUBMIT;
		} else if (event.bstate & BUTTON3_CLICKED) {
		    c = LAC_TO_LKC0(LYK_PREV_DOC);
		} else if (code == FOR_PROMPT
		    /* Cannot ignore: see LYCurses.c */
			   || (event.bstate &
			       (BUTTON1_PRESSED | BUTTON1_RELEASED
				| BUTTON2_PRESSED | BUTTON2_RELEASED
				| BUTTON3_PRESSED | BUTTON3_RELEASED))) {
		    /* Completely ignore - don't return anything, to
		       avoid canceling the prompt - kw */
		    goto re_read;
		} else if (event.bstate & BUTTON2_CLICKED) {
		    int atlink;

		    c = set_clicked_link(event.x, event.y, code, 1);
		    atlink = (c == LAC_TO_LKC0(LYK_ACTIVATE));
		    if (!atlink)
			mouse_link = -1;	/* Forget about approx stuff. */

		    lac = LYmouse_menu(event.x, event.y, atlink, code);
		    if (lac == LYK_MOUSE_SUBMIT) {
			if (mouse_link == -1)
			    lac = LYK_ACTIVATE;
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
			else if (mouse_link >= 0 &&
				 textfields_need_activation &&
				 links[mouse_link].type == WWW_FORM_LINK_TYPE &&
				 F_TEXTLIKE(links[mouse_link].l_form->type))
			    lac = LYK_ACTIVATE;
#endif
		    }
		    if (lac == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert(gettext("No link chosen"));
			lac = LYK_REFRESH;
		    }
		    c = LAC_TO_LKC(lac);
		}
#if NCURSES_MOUSE_VERSION > 1
		else if (event.bstate & BUTTON4_PRESSED) {
		    c = LAC_TO_LKC(LYK_UP_HALF);
		} else if (event.bstate & BUTTON5_PRESSED) {
		    c = LAC_TO_LKC(LYK_DOWN_HALF);
		}
#endif
		if (code == FOR_INPUT && mouse_link == -1 &&
		    lac != LYK_REFRESH &&
		    lac != LYK_MOUSE_SUBMIT) {
		    ungetmouse(&event);		/* Caller will process this. */
		    wgetch(LYwin);	/* ungetmouse puts KEY_MOUSE back */
		    c = MOUSE_KEY;
		}
#else /* pdcurses version */

#define H_CMD_AREA	6
#define HIST_CMD_2	12
#define V_CMD_AREA	1

		int left = H_CMD_AREA;
		int right = (LYcolLimit - H_CMD_AREA - 1);

		/* yes, I am assuming that my screen will be a certain width. */

		int tick_count;
		char *p = NULL;
		char mouse_info[128];
		static int old_click = 0;	/* [m Sec] */

		c = -1;
		mouse_link = -1;

		if (!system_is_NT) {
		    tick_count = GetTickCount();

		    /* Guard Mouse button miss click */
		    if ((tick_count - old_click) < 700) {
			c = DO_NOTHING;
			break;
		    } else {
			old_click = tick_count;
		    }
		}
		request_mouse_pos();

		if (BUTTON_STATUS(1) & BUTTON_PRESSED) {
		    if (MOUSE_Y_POS > (LYlines - V_CMD_AREA - 1)) {
			/* Screen BOTTOM */
			if (MOUSE_X_POS < left) {
			    c = LTARROW_KEY;
			    p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW_KEY;
			    p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';
			    p = "Cancel";
			} else {
			    c = PGDOWN_KEY;
			    p = "PGDOWN";
			}
		    } else if (MOUSE_Y_POS < V_CMD_AREA) {
			/* Screen TOP */
			if (MOUSE_X_POS < left) {
			    c = LTARROW_KEY;
			    p = "<-";
			} else if (MOUSE_X_POS < HIST_CMD_2) {
			    c = RTARROW_KEY;
			    p = "->";
			} else if (MOUSE_X_POS > right) {
			    c = 'z';
			    p = "Cancel";
			} else {
			    c = PGUP_KEY;
			    p = "PGUP";
			}
		    } else {
			c = set_clicked_link(MOUSE_X_POS,
					     MOUSE_Y_POS,
					     FOR_PANEL, 1);
		    }
		}
		if (p && c != -1) {
		    sprintf(mouse_info, "Mouse = 0x%x, [%s]", c, p);
		    SetConsoleTitle(mouse_info);
		}
#endif /* !(WIN_EX) */
		if ((c + 1) >= KEYMAP_SIZE && (c & LKC_ISLAC))
		    return (c);
	    }
	    break;
#endif /* NCURSES || PDCURSES */

/********************************************************************/
#endif /* USE_MOUSE */

	}
#endif /* HAVE_KEYPAD */
#ifdef DJGPP_KEYHANDLER
	switch (c) {
	case K_Down:		/* The four arrow keys ... */
	case K_EDown:
	    c = DNARROW_KEY;
	    break;
	case K_Up:
	case K_EUp:
	    c = UPARROW_KEY;
	    break;
	case K_Left:
	case K_ELeft:
	    c = LTARROW_KEY;
	    break;
	case K_Right:		/* ... */
	case K_ERight:
	    c = RTARROW_KEY;
	    break;
	case K_Home:		/* Home key (upward+left arrow) */
	case K_EHome:
	    c = HOME_KEY;
	    break;
	case K_PageDown:	/* Next page */
	case K_EPageDown:
	    c = PGDOWN_KEY;
	    break;
	case K_PageUp:		/* Previous page */
	case K_EPageUp:
	    c = PGUP_KEY;
	    break;
	case K_End:		/* home down or bottom (lower left) */
	case K_EEnd:
	    c = END_KEY;
	    break;
	case K_F1:		/* F1 key */
	    c = F1_KEY;
	    break;
	case K_Insert:		/* Insert key */
	case K_EInsert:
	    c = INSERT_KEY;
	    break;
	case K_Delete:		/* Delete key */
	case K_EDelete:
	    c = REMOVE_KEY;
	    break;
	case K_Alt_Escape:	/* Alt-Escape */
	    c = 0x1a7;
	    break;
	case K_Control_At:	/* CTRL-@@ */
	    c = 0x1a8;
	    break;
	case K_Alt_Backspace:	/* Alt-Backspace */
	    c = 0x1a9;
	    break;
	case K_BackTab:	/* BackTab */
	    c = BACKTAB_KEY;
	    break;
	}
#endif /* DGJPP_KEYHANDLER */
#if defined(USE_SLANG) && (defined(__DJGPP__) || defined(__CYGWIN__)) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
	switch (c) {
	case SL_KEY_DOWN:	/* The four arrow keys ... */
	    c = DNARROW_KEY;
	    break;
	case SL_KEY_UP:
	    c = UPARROW_KEY;
	    break;
	case SL_KEY_LEFT:
	    c = LTARROW_KEY;
	    break;
	case SL_KEY_RIGHT:	/* ... */
	    c = RTARROW_KEY;
	    break;
	case SL_KEY_HOME:	/* Home key (upward+left arrow) */
	case SL_KEY_A1:	/* upper left of keypad */
	    c = HOME_KEY;
	    break;
	case SL_KEY_NPAGE:	/* Next page */
	case SL_KEY_C3:	/* lower right of keypad */
	    c = PGDOWN_KEY;
	    break;
	case SL_KEY_PPAGE:	/* Previous page */
	case SL_KEY_A3:	/* upper right of keypad */
	    c = PGUP_KEY;
	    break;
	case SL_KEY_END:	/* home down or bottom (lower left) */
	case SL_KEY_C1:	/* lower left of keypad */
	    c = END_KEY;
	    break;
	case SL_KEY_F(1):	/* F1 key */
	    c = F1_KEY;
	    break;
	case SL_KEY_IC:	/* Insert key */
	    c = INSERT_KEY;
	    break;
	case SL_KEY_DELETE:	/* Delete key */
	    c = REMOVE_KEY;
	    break;
	}
#endif /* USE_SLANG && __DJGPP__ && !DJGPP_KEYHANDLER && !USE_KEYMAPS */
    }

    if (c & (LKC_ISLAC | LKC_ISLECLAC)) {
	return (c);
    } else if ((c + 1) >= KEYMAP_SIZE) {
	/*
	 * Don't return raw values for KEYPAD symbols which we may have missed
	 * in the switch above if they are obviously invalid when used as an
	 * index into (e.g.) keypad[].  - KW
	 */
	return (0);
    } else {
	return (c | current_modifier);
    }
}

/************************************************************************/
#endif /* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

int LYgetch(void)
{
    return LYReadCmdKey(FOR_PANEL);
}

/*
 * Read a single keystroke, allows mouse-selection.
 */
int LYgetch_choice(void)
{
    int ch = LYReadCmdKey(FOR_CHOICE);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, allows mouse events.
 */
int LYgetch_input(void)
{
    int ch = LYReadCmdKey(FOR_INPUT);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    return ch;
}

/*
 * Read a single keystroke, ignoring case by translating it to uppercase.
 * Ignore mouse events, if any.
 */
int LYgetch_single(void)
{
    int ch = LYReadCmdKey(FOR_SINGLEKEY);

    if (ch == LYCharINTERRUPT1)
	ch = LYCharINTERRUPT2;	/* treat ^C the same as ^G */
    else if (ch > 0 && ch < 256)
	ch = TOUPPER(ch);	/* will ignore case of result */
    return ch;
}

/*
 * Convert a null-terminated string to lowercase
 */
void LYLowerCase(char *arg_buffer)
{
    register unsigned char *buffer = (unsigned char *) arg_buffer;
    size_t i;

    for (i = 0; buffer[i]; i++) {
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:04:55 */
	if ((buffer[i] & 0x80) != 0
	    && buffer[i + 1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOLOWER(buffer[i]));
	}
#else
	buffer[i] = TOLOWER(buffer[i]);
#endif
    }
}

/*
 * Convert a null-terminated string to uppercase
 */
void LYUpperCase(char *arg_buffer)
{
    register unsigned char *buffer = (unsigned char *) arg_buffer;
    size_t i;

    for (i = 0; buffer[i]; i++) {
#ifdef SUPPORT_MULTIBYTE_EDIT	/* 1998/11/23 (Mon) 17:05:10 */
	if ((buffer[i] & 0x80) != 0
	    && buffer[i + 1] != 0) {
	    if ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH((buffer[i])))) {
		continue;
	    }
	    i++;
	} else {
	    buffer[i] = UCH(TOUPPER(buffer[i]));
	}
#else
	buffer[i] = UCH(TOUPPER(buffer[i]));
#endif
    }
}

/*
 * Remove newlines from a string, returning true if we removed any.
 */
BOOLEAN LYRemoveNewlines(char *buffer)
{
    BOOLEAN result = FALSE;

    if (buffer != 0) {
	register char *buf = buffer;

	for (; *buf && *buf != '\n' && *buf != '\r'; buf++) ;
	if (*buf) {
	    /* runs very seldom */
	    char *old = buf;

	    for (; *old; old++) {
		if (*old != '\n' && *old != '\r')
		    *buf++ = *old;
	    }
	    *buf = '\0';
	    result = TRUE;
	}
    }
    return result;
}

/*
 * Remove leading/trailing whitespace from a string, reduce runs of embedded
 * whitespace to single blanks.
 */
char *LYReduceBlanks(char *buffer)
{
    if (non_empty(buffer)) {
	LYTrimLeading(buffer);
	LYTrimTrailing(buffer);
	convert_to_spaces(buffer, TRUE);
    }
    return buffer;
}

/*
 * Remove ALL whitespace from a string (including embedded blanks), and returns
 * a pointer to the end of the trimmed string.
 */
char *LYRemoveBlanks(char *buffer)
{
    char *result = NULL;

    if (buffer != 0) {
	register char *buf = buffer;

	for (; *buf && !isspace(UCH(*buf)); buf++) ;
	if (*buf) {
	    /* runs very seldom */
	    char *old = buf;

	    for (; *old; old++) {
		if (!isspace(UCH(*old)))
		    *buf++ = *old;
	    }
	    *buf = '\0';
	}
	result = buf;
    }
    return result;
}

/*
 * Skip whitespace
 */
char *LYSkipBlanks(char *buffer)
{
    while (isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip non-whitespace
 */
char *LYSkipNonBlanks(char *buffer)
{
    while (*buffer != 0 && !isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip const whitespace
 */
const char *LYSkipCBlanks(const char *buffer)
{
    while (isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Skip const non-whitespace
 */
const char *LYSkipCNonBlanks(const char *buffer)
{
    while (*buffer != 0 && !isspace(UCH((*buffer))))
	buffer++;
    return buffer;
}

/*
 * Trim leading blanks from a string
 */
void LYTrimLeading(char *buffer)
{
    char *skipped = LYSkipBlanks(buffer);

    while ((*buffer++ = *skipped++) != 0) ;
}

/*
 * Trim trailing newline(s) from a string
 */
char *LYTrimNewline(char *buffer)
{
    size_t i = strlen(buffer);

    while (i != 0 && (buffer[i - 1] == '\n' || buffer[i - 1] == '\r'))
	buffer[--i] = 0;
    return buffer;
}

/*
 * Trim trailing blanks from a string
 */
void LYTrimTrailing(char *buffer)
{
    size_t i = strlen(buffer);

    while (i != 0 && isspace(UCH(buffer[i - 1])))
	buffer[--i] = 0;
}

/* 1997/11/10 (Mon) 14:26:10, originally string_short() in LYExterns.c, but
 * moved here because LYExterns is not always configured.
 */
char *LYElideString(char *str,
		    int cut_pos)
{
    char buff[MAX_LINE], *s, *d;
    static char s_str[MAX_LINE];
    int len;

    LYStrNCpy(buff, str, sizeof(buff) - 1);
    len = (int) strlen(buff);
    if (len > (LYcolLimit - 9)) {
	buff[cut_pos] = '.';
	buff[cut_pos + 1] = '.';
	for (s = (buff + len) - (LYcolLimit - 9) + cut_pos + 1,
	     d = (buff + cut_pos) + 2;
	     s >= buff &&
	     d >= buff &&
	     d < buff + LYcols &&
	     (*d++ = *s++) != 0;) ;
	buff[LYcols] = 0;
    }
    strcpy(s_str, buff);
    return (s_str);
}

/*
 * Trim a startfile, returning true if it looks like one of the Lynx tags.
 */
BOOLEAN LYTrimStartfile(char *buffer)
{
    BOOLEAN result = FALSE;

    LYTrimHead(buffer);
    if (isLYNXEXEC(buffer) ||
	isLYNXPROG(buffer)) {
	/*
	 * The original implementations of these schemes expected white space
	 * without hex escaping, and did not check for hex escaping, so we'll
	 * continue to support that, until that code is redone in conformance
	 * with SGML principles.  - FM
	 */
	HTUnEscapeSome(buffer, " \r\n\t");
	convert_to_spaces(buffer, TRUE);
	result = TRUE;
    }
    return result;
}

/*
 * Escape unsafe characters in startfile, except for lynx internal URLs.
 */
void LYEscapeStartfile(char **buffer)
{
    if (!LYTrimStartfile(*buffer)) {
	char *escaped = HTEscapeUnsafe(*buffer);

	StrAllocCopy(*buffer, escaped);
	FREE(escaped);
    }
}

/*
 * Trim all blanks from startfile, except for lynx internal URLs.
 */
void LYTrimAllStartfile(char *buffer)
{
    if (!LYTrimStartfile(buffer)) {
	LYRemoveBlanks(buffer);
    }
}

/*
 * Display the current value of the string and allow the user to edit it.
 */

/*
 * Shorthand to get rid of the "edit->suchandsos".
 */
#define IsDirty   edit->efIsDirty
#define IsHidden  edit->efIsMasked
#define StartX    edit->efStartX
#define StartY    edit->efStartY
#define Buffer    edit->efBuffer
#define EditAt    edit->efEditAt	/* current editing position (bytes) */
#define BufInUse  edit->efBufInUse	/* length (bytes) */
#define BufAlloc  edit->efBufAlloc
#define BufLimit  edit->efBufLimit
#define DpyWidth  edit->efWidth
#define DpyStart  edit->efDpyStart	/* display-start (columns) */
#define PanMargin edit->efPanMargin
#define IsPanned  edit->efIsPanned
#define PadChar   edit->efPadChar
#ifdef ENHANCED_LINEEDIT
#define EditMark  edit->efEditMark
#endif
#define InputMods edit->efInputMods
#define Offs2Col  edit->efOffs2Col

#define enableEditMark() \
	if (EditMark < 0) \
	    EditMark = -(1 + EditMark)

#define disableEditMark() \
	if (EditMark >= 0) \
	    EditMark = -(1 + EditMark)

#ifdef ENHANCED_LINEEDIT
static bstring *killbuffer;
#endif

static void updateMargin(FieldEditor * edit)
{
    if ((int) BufAlloc > DpyWidth) {	/* Need panning? */
	if (DpyWidth > 4)
	    IsPanned = TRUE;

	/*
	 * Figure out margins.  If too big, we do a lot of unnecessary
	 * scrolling.  If too small, user doesn't have sufficient look-ahead. 
	 * Let's say 25% for each margin, upper bound is 10 columns.
	 */
	PanMargin = DpyWidth / 4;
	if (PanMargin > 10)
	    PanMargin = 10;
    }
}

/*
 * Before using an array position, make sure that the array is long enough.
 * Reallocate if needed.
 */
static void ExtendEditor(FieldEditor * edit, int position)
{
    size_t need = (size_t) (++position);

    if (need >= BufAlloc && (BufLimit == 0 || need < BufLimit)) {
	CTRACE((tfp, "ExtendEditor from %lu to %lu\n",
		(unsigned long) BufAlloc,
		(unsigned long) need));
	Buffer = typeRealloc(char, Buffer, need);
	Offs2Col = typeRealloc(int, Offs2Col, need + 1);

	BufAlloc = need;
	updateMargin(edit);
    }
}

void LYFinishEdit(FieldEditor * edit)
{
    CTRACE((tfp, "LYFinishEdit:%s\n", NonNull(Buffer)));

    FREE(Buffer);
    FREE(Offs2Col);
}

void LYSetupEdit(FieldEditor * edit, char *old_value, size_t buffer_limit, int display_limit)
{
    CTRACE((tfp, "LYSetupEdit buffer %lu, display %d:%s\n",
	    (unsigned long) buffer_limit,
	    display_limit,
	    old_value));

    BufLimit = buffer_limit;
    if (buffer_limit == 0)
	buffer_limit = strlen(old_value) + 1;

    /*
     * Initialize edit record
     */
    LYGetYX(StartY, StartX);
    PadChar = ' ';
    IsDirty = TRUE;
    IsPanned = FALSE;
    InputMods = 0;

    BufAlloc = buffer_limit;
    DpyWidth = display_limit;
    PanMargin = 0;
    EditAt = (int) strlen(old_value);
#ifdef ENHANCED_LINEEDIT
    EditMark = -1;		/* pos=0, but do not show it yet */
#endif
    DpyStart = 0;

    updateMargin(edit);

    BufInUse = strlen(old_value);
    Buffer = typecallocn(char, BufAlloc + 1);

    if (Buffer == 0)
	outofmem(__FILE__, "LYSetupEdit");

    LYStrNCpy(Buffer, old_value, buffer_limit);
    Offs2Col = typecallocn(int, BufAlloc + 1);

    if (Offs2Col == 0)
	outofmem(__FILE__, "LYSetupEdit");
}

#ifdef SUPPORT_MULTIBYTE_EDIT

/*
 * MBCS positioning routines below are specific to SUPPORT_MULTIBYTE_EDIT code.
 * Currently they handle UTF-8 and (hopefully) CJK.
 * Current encoding is recognized using defines below.
 *
 * LYmbcs* functions don't look very convenient to use here...
 * Do we really need utf_flag as an argument?
 *
 * It is set (see IS_UTF8_TTY) for every invocation out there, and they use
 * HTCJK flag internally anyway.  Something like LYmbcsstrnlen == mbcs_glyphs
 * would be useful to work with string slices -Sergej Kvachonok 
 */

#define IS_UTF8_EXTRA(x) (((unsigned char)(x) & 0300) == 0200)

/*
 * Counts glyphs in a multibyte (sub)string s of length len.
 */
static int mbcs_glyphs(char *s, int len)
{
    int glyphs = 0;
    int i;

    if (IS_UTF8_TTY) {
	for (i = 0; s[i] && i < len; i++)
	    if (!IS_UTF8_EXTRA(s[i]))
		glyphs++;
    } else if (IS_CJK_TTY) {
	for (i = 0; s[i] && i < len; i++, glyphs++)
	    if (is8bits(s[i]))
		i++;
    } else {
	glyphs = len;
    }
    return glyphs;
}

/*
 * Calculates offset in bytes of a glyph at cell position pos.
 */
static int mbcs_skip(char *s, int pos)
{
    int p, i;

    if (IS_UTF8_TTY) {
	for (i = 0, p = 0; s[i]; i++) {
	    if (!IS_UTF8_EXTRA(s[i]))
		p++;
	    if (p > pos)
		break;
	}
    } else if (IS_CJK_TTY) {
	for (p = i = 0; s[i] && p < pos; p++, i++)
	    if (is8bits(s[i]))
		i++;
    } else {
	i = pos;
    }

    return i;
}

/*
 * Given a string that would display (at least) the given number of cells,
 * determine the number of multibyte characters that comprised those cells.
 */
static int cell2char(char *s, int cells)
{
    int result = 0;
    int len = (int) strlen(s);
    int pos;
    int have;

    CTRACE_EDIT((tfp, "cell2char(%d) %d:%s\n", cells, len, s));
    /* FIXME - make this a binary search */
    if (len != 0) {
	for (pos = 0; pos <= len; ++pos) {
	    have = LYstrExtent2(s, pos);
	    CTRACE_EDIT((tfp, "  %2d:%2d:%.*s\n", pos, have, pos, s));
	    if (have >= cells) {
		break;
	    }
	}
	if (pos > len)
	    pos = len;
    } else {
	pos = 0;
    }
    result = mbcs_glyphs(s, pos);
    CTRACE_EDIT((tfp, "->%d\n", result));
    return result;
}

#endif /* SUPPORT_MULTIBYTE_EDIT */

#ifdef EXP_KEYBOARD_LAYOUT
static int map_active = 0;

#else
#define map_active 0
#endif

int LYEditInsert(FieldEditor * edit, unsigned const char *s,
		 int len,
		 int map GCC_UNUSED,
		 int maxMessage)
{
    int length = (int) strlen(Buffer);
    int remains = (int) BufAlloc - (length + len);
    int edited = 0, overflow = 0;

    /*
     * ch is (presumably) printable character.
     */
    if (remains < 0) {
	overflow = 1;
	len = 0;
	if ((int) BufAlloc > length)	/* Insert as much as we can */
	    len = (int) BufAlloc - length;
	else
	    goto finish;
    }
    ExtendEditor(edit, length + len);
    Buffer[length + len] = '\0';
    for (; length >= EditAt; length--)	/* Make room */
	Buffer[length + len] = Buffer[length];
#ifdef EXP_KEYBOARD_LAYOUT
    if (map < 0)
	map = map_active;
    if (map && IS_UTF8_TTY) {
	int off = EditAt;
	unsigned const char *e = s + len;
	char *tail = 0;

	while (s < e) {
	    char utfbuf[8];
	    int l = 1;

	    utfbuf[0] = (char) *s;
	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
		UCode_t ucode = LYKbLayouts[current_layout][*s];

		if (ucode > 127) {
		    if (UCConvertUniToUtf8(ucode, utfbuf)) {
			l = (int) strlen(utfbuf);
			remains -= l - 1;
			if (remains < 0) {
			    if (tail)
				strcpy(Buffer + off, tail);
			    FREE(tail);
			    len = off;
			    overflow = 1;
			    goto finish;
			}
			if (l > 1 && !tail)
			    StrAllocCopy(tail, Buffer + EditAt + len);
		    } else
			utfbuf[0] = '?';
		} else
		    utfbuf[0] = (char) ucode;
	    }
	    StrNCpy(Buffer + off, utfbuf, l);
	    edited = 1;
	    off += l;
	    s++;
	}
	if (tail)
	    strcpy(Buffer + off, tail);
	len = off - EditAt;
	FREE(tail);
    } else if (map) {
	unsigned const char *e = s + len;
	unsigned char *t = (unsigned char *) Buffer + EditAt;

	while (s < e) {
	    int ch;

	    if (*s < 128 && LYKbLayouts[current_layout][*s]) {
		ch = UCTransUniChar((UCode_t) LYKbLayouts[current_layout][*s],
				    current_char_set);
		if (ch < 0)
		    ch = '?';
	    } else
		ch = *s;
	    *t = UCH(ch);
	    t++, s++;
	}
	edited = 1;
    } else
#endif /* defined EXP_KEYBOARD_LAYOUT */
    {
	StrNCpy(Buffer + EditAt, (const char *) s, len);
	edited = 1;
    }

  finish:
    EditAt += len;
    BufInUse += (size_t) len;
    if (edited)
	IsDirty = TRUE;
    if (overflow && maxMessage)
	_statusline(MAXLEN_REACHED_DEL_OR_MOV);
#ifdef ENHANCED_LINEEDIT
    if (EditMark > EditAt)
	EditMark += len;
    else if (EditMark < -(1 + EditAt))
	EditMark -= len;
    disableEditMark();
#endif
    return edited;
}

/*
 * Do one edit-operation, given the input 'ch' and working buffer 'edit'.
 *
 * If the input is processed, returns zero.
 * If the action should be performed outside of line-editing mode, return -ch.
 * Otherwise, e.g., returns 'ch'.
 */
int LYDoEdit(FieldEditor * edit, int ch,
	     int action,
	     int maxMessage)
{
    int i;
    int length;
    unsigned char uch;
    int offset;

    if ((int) BufAlloc <= 0)
	return (0);		/* Be defensive */

    BufInUse = strlen(&Buffer[0]);
    length = (int) BufInUse;

    switch (action) {
#ifdef EXP_KEYBOARD_LAYOUT
    case LYE_SWMAP:
	/*
	 * Turn input character mapping on or off.
	 */
	map_active = ~map_active;
	break;
#endif
#ifndef CJK_EX
    case LYE_AIX:
	/*
	 * Handle CJK characters, or as a valid character in the current
	 * display character set.  Otherwise, we treat this as LYE_ENTER.
	 */
	if (!IS_CJK_TTY && LYlowest_eightbit[current_char_set] > 0x97)
	    return (ch);
	/* FALLTHRU */
#endif
    case LYE_CHAR:
	uch = UCH(ch);
	LYEditInsert(edit, &uch, 1, map_active, maxMessage);
	return 0;		/* All changes already registered */

    case LYE_C1CHAR:
	/*
	 * ch is the second part (in most cases, a capital letter) of a 7-bit
	 * replacement for a character in the 8-bit C1 control range.
	 *
	 * This is meant to undo transformations like 0x81 -> 0x1b 0x41 (ESC A)
	 * etc., done by slang on Unix and possibly some comm programs.  It's
	 * an imperfect workaround that doesn't work for all such characters.
	 */
	ch &= 0xFF;
	if (ch + 64 >= LYlowest_eightbit[current_char_set])
	    ch += 64;

	if (EditAt <= ((int) BufAlloc) && BufInUse < BufAlloc) {
#ifdef ENHANCED_LINEEDIT
	    if (EditMark > EditAt)
		EditMark++;
	    else if (EditMark < -(1 + EditAt))
		EditMark--;
	    disableEditMark();
#endif
	    ExtendEditor(edit, length + 1);
	    for (i = length; i >= EditAt; i--)	/* Make room */
		Buffer[i + 1] = Buffer[i];
	    Buffer[length + 1] = '\0';
	    Buffer[EditAt] = (char) ch;
	    EditAt++;
	} else {
	    if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	    return (ch);
	}
	break;

    case LYE_BACKW:		/* go backward one word */
	while (EditAt && !IsWordChar(Buffer[EditAt - 1]))
	    EditAt--;
	while (EditAt && IsWordChar(UCH(Buffer[EditAt - 1])))
	    EditAt--;
	break;

    case LYE_FORWW:		/* go forward one word */
	while (IsWordChar(UCH(Buffer[EditAt])))
	    EditAt++;
	while (!IsWordChar(Buffer[EditAt]) && Buffer[EditAt])
	    EditAt++;
	break;

    case LYE_ERASE:		/* erase the line */
	Buffer[0] = '\0';
#ifdef ENHANCED_LINEEDIT
	EditMark = -1;		/* Do not show the mark */
#endif
	/* FALLTHRU */

    case LYE_BOL:		/* go to beginning of line  */
	EditAt = 0;
	break;

    case LYE_EOL:		/* go to end of line  */
	EditAt = length;
	break;

    case LYE_DELNW:		/* delete next word  */
	offset = EditAt;
	LYDoEdit(edit, 0, LYE_FORWW, FALSE);
	offset = EditAt - offset;
	EditAt -= offset;

	goto shrink;		/* right below */

    case LYE_DELPW:		/* delete previous word  */
	offset = EditAt;
	LYDoEdit(edit, 0, LYE_BACKW, FALSE);
	offset -= EditAt;

      shrink:
	for (i = EditAt; i < length - offset + 1; i++)
	    Buffer[i] = Buffer[i + offset];
#ifdef ENHANCED_LINEEDIT
	disableEditMark();
	if (EditMark <= -(1 + EditAt + offset))
	    EditMark += offset;	/* Shift it */
	if (-(1 + EditAt + offset) < EditMark && EditMark < -(1 + EditAt))
	    EditMark = -(1 + EditAt);	/* Set to the current position */
#endif

	break;

    case LYE_DELBL:		/* delete from cursor to beginning of line */
	for (i = EditAt; i < length + 1; i++)
	    Buffer[i - EditAt] = Buffer[i];

#ifdef ENHANCED_LINEEDIT
	disableEditMark();
	if (EditMark <= -(1 + EditAt))
	    EditMark += EditAt;	/* Shift it */
	else
	    EditMark = -1;	/* Reset it */
#endif
	EditAt = 0;
	break;

    case LYE_DELEL:		/* delete from cursor to end of line */
	Buffer[EditAt] = '\0';
#ifdef ENHANCED_LINEEDIT
	disableEditMark();
	if (EditMark <= -(1 + EditAt))
	    EditMark = -1;	/* Reset it */
#endif
	break;

    case LYE_DELN:		/* delete next character */
	if (EditAt >= length)
	    break;
#ifndef SUPPORT_MULTIBYTE_EDIT
	EditAt++;
#else
	EditAt += mbcs_skip(Buffer + EditAt, 1);
#endif
	/* FALLTHRU */

    case LYE_DELP:		/* delete previous character */
	if (length == 0 || EditAt == 0)
	    break;

#ifndef SUPPORT_MULTIBYTE_EDIT
#ifdef ENHANCED_LINEEDIT
	disableEditMark();
	if (EditMark <= -(1 + EditAt))
	    EditMark++;
#endif
	EditAt--;
	for (i = EditAt; i < length; i++)
	    Buffer[i] = Buffer[i + 1];
#else /* SUPPORT_MULTIBYTE_EDIT */
	offset = EditAt - mbcs_skip(Buffer, mbcs_glyphs(Buffer, EditAt) - 1);
	EditAt -= offset;
	for (i = EditAt; i < length - offset + 1; i++)
	    Buffer[i] = Buffer[i + offset];

#ifdef ENHANCED_LINEEDIT
	disableEditMark();
	if (EditMark <= -(1 + EditAt))
	    EditMark += offset;	/* Shift it */
#endif

#endif /* SUPPORT_MULTIBYTE_EDIT */
	break;

    case LYE_FORW_RL:
    case LYE_FORW:		/* move cursor forward */
#ifndef SUPPORT_MULTIBYTE_EDIT
	if (EditAt < length)
	    EditAt++;
#else
	if (EditAt < length)
	    EditAt += mbcs_skip(Buffer + EditAt, 1);
#endif
	else if (action == LYE_FORW_RL)
	    return -ch;
	break;

    case LYE_BACK_LL:
    case LYE_BACK:		/* move cursor backward */
#ifndef SUPPORT_MULTIBYTE_EDIT
	if (EditAt > 0)
	    EditAt--;
#else
	if (EditAt > 0)
	    EditAt = mbcs_skip(Buffer, mbcs_glyphs(Buffer, EditAt) - 1);
#endif
	else if (action == LYE_BACK_LL)
	    return -ch;
	break;

#ifdef ENHANCED_LINEEDIT
    case LYE_TPOS:
	/*
	 * Transpose characters - bash or ksh(emacs not gmacs) style
	 */

#ifdef SUPPORT_MULTIBYTE_EDIT
	if (IS_UTF8_TTY || IS_CJK_TTY)
	    break;		/* Can't help it now */
#endif

	if (length <= 1 || EditAt == 0)
	    return (ch);
	if (EditAt == length)
	    EditAt--;
	enableEditMark();
	if (EditMark == EditAt || EditMark == EditAt + 1)
	    EditMark = EditAt - 1;
	disableEditMark();
	if (Buffer[EditAt - 1] == Buffer[EditAt]) {
	    EditAt++;
	    break;
	}
	i = Buffer[EditAt - 1];
	Buffer[EditAt - 1] = Buffer[EditAt];
	Buffer[EditAt++] = (char) i;
	break;

    case LYE_SETMARK:		/* Emacs-like set-mark-command */
	EditMark = EditAt;
	return (0);

    case LYE_XPMARK:		/* Emacs-like exchange-point-and-mark */
	enableEditMark();
	if (EditMark == EditAt)
	    return (0);
	i = EditAt;
	EditAt = EditMark;
	EditMark = i;
	break;

    case LYE_KILLREG:		/* Emacs-like kill-region */
	enableEditMark();
	if (EditMark == EditAt) {
	    BStrFree(killbuffer);
	    return (0);
	}
	if (EditMark > EditAt)
	    LYDoEdit(edit, 0, LYE_XPMARK, FALSE);
	{
	    int reglen = EditAt - EditMark;

	    BStrCopy1(killbuffer, Buffer + EditMark, reglen);
	    for (i = EditMark; Buffer[i + reglen]; i++)
		Buffer[i] = Buffer[i + reglen];
	    Buffer[i] = Buffer[i + reglen];	/* terminate */
	    EditAt = EditMark;
	}
	disableEditMark();
	break;

    case LYE_YANK:		/* Emacs-like yank */
	if (!killbuffer) {
	    EditMark = -(1 + EditAt);
	    return (0);
	} else {
	    int yanklen = killbuffer->len;

	    if ((EditAt + yanklen) <= (int) BufAlloc &&
		BufInUse + (size_t) yanklen <= BufAlloc) {

		ExtendEditor(edit, EditAt + yanklen);

		EditMark = -(1 + EditAt);

		for (i = length; i >= EditAt; i--)	/* Make room */
		    Buffer[i + yanklen] = Buffer[i];
		for (i = 0; i < yanklen; i++)
		    Buffer[EditAt++] = killbuffer->str[i];

	    } else if (maxMessage) {
		_statusline(MAXLEN_REACHED_DEL_OR_MOV);
	    }
	}
	break;

#endif /* ENHANCED_LINEEDIT */

    case LYE_UPPER:
	LYUpperCase(Buffer);
	break;

    case LYE_LOWER:
	LYLowerCase(Buffer);
	break;

    default:
	return (ch);
    }
    IsDirty = TRUE;
    BufInUse = strlen(&Buffer[0]);
    return (0);
}

/*
 *  This function prompts for a choice or page number.
 *  If a 'g' or 'p' suffix is included, that will be
 *  loaded into c.  Otherwise, c is zeroed. - FM & LE
 */
int get_popup_number(const char *msg,
		     int *c,
		     int *rel)
{
    bstring *temp = NULL;
    int result = 0;

    /*
     * Load the c argument into the prompt buffer.
     */
    BStrCopy0(temp, "?");
    temp->str[0] = (char) *c;

    _statusline(msg);

    /*
     * Get the number, possibly with a suffix, from the user.
     */
    if (LYgetBString(&temp, FALSE, 0, NORECALL) < 0 || isBEmpty(temp)) {
	HTInfoMsg(CANCELLED);
	*c = '\0';
	*rel = '\0';
    } else {
	char *p = temp->str;

	*rel = '\0';
	result = atoi(p);
	while (isdigit(UCH(*p)))
	    ++p;
	switch (*p) {
	case '+':
	case '-':
	    /* 123+ or 123- */
	    *rel = *p++;
	    *c = *p;
	    break;
	default:
	    *c = *p++;
	    *rel = *p;
	    break;
	case 0:
	    break;
	}

	/*
	 * If we had a 'g' or 'p' suffix, load it into c.  Otherwise, zero c.  Then
	 * return the number.
	 */
	if (*p == 'g' || *p == 'G') {
	    *c = 'g';
	} else if (*p == 'p' || *p == 'P') {
	    *c = 'p';
	} else {
	    *c = '\0';
	}
	if (*rel != '+' && *rel != '-')
	    *rel = 0;
    }
    BStrFree(temp);
    return result;
}

#ifdef USE_COLOR_STYLE
#  define TmpStyleOn(s)		curses_style((s), STACK_ON)
#  define TmpStyleOff(s)	curses_style((s), STACK_OFF)
#else
#  define TmpStyleOn(s)
#  define TmpStyleOff(s)
#endif /* defined USE_COLOR_STYLE */

static void remember_column(FieldEditor * edit, int offset)
{
    int y0, x0;

#if defined(USE_SLANG)
    y0 = 0;
    x0 = SLsmg_get_column();
#elif defined(USE_CURSES_PADS)
    getyx(LYwin, y0, x0);
#else
    getyx(stdscr, y0, x0);
#endif
    Offs2Col[offset] = x0;

    (void) y0;
    (void) x0;
}

static void fill_edited_line(int prompting GCC_UNUSED, int length, int ch)
{
    int i;

    TmpStyleOn(prompting ? s_prompt_edit_pad : s_aedit_pad);

    for (i = 0; i < length; i++) {
	LYaddch(UCH(ch));
    }

    TmpStyleOff(prompting ? s_prompt_edit_pad : s_aedit_pad);
}

/*
 * Multibyte string display subroutine.
 * FieldEditor fields retain their values as byte offsets.
 * All external logic still works fine with byte values.
 */
void LYRefreshEdit(FieldEditor * edit)
{
    /* bytes and characters are not the same thing */
#if defined(DEBUG_EDIT)
    int all_bytes;
#endif
    int pos_bytes = EditAt;
    int dpy_bytes;
    int lft_bytes;		/* base of string which is displayed */

    /* cells refer to display-columns on the screen */
    int all_cells;		/* total of display-cells in Buffer */
    int dpy_cells;		/* number of cells which are displayed */
    int lft_cells;		/* number of cells before display (on left) */
    int pos_cells;		/* number of display-cells up to EditAt */

#if defined(SUPPORT_MULTIBYTE_EDIT)
    int dpy_chars;
    int lft_chars;

#if defined(DEBUG_EDIT)
    int all_chars;
    int pos_chars;
#endif
#endif

    /* other data */
    int i;
    int padsize;
    char *str;
    int lft_shift = 0;
    int rgt_shift = 0;

#ifdef USE_COLOR_STYLE
    int estyle;
#endif
    int prompting = 0;

    (void) pos_bytes;

    /*
     * If we've made no changes, or if there is nothing to display, just leave.
     */
    if (!IsDirty || (DpyWidth == 0))
	return;

    CTRACE((tfp, "LYRefreshEdit:%s\n", Buffer));

    IsDirty = FALSE;

    BufInUse = strlen(&Buffer[0]);

    all_cells = LYstrCells(Buffer);
    pos_cells = LYstrExtent2(Buffer, EditAt);

#if defined(SUPPORT_MULTIBYTE_EDIT) && defined(DEBUG_EDIT)
    all_bytes = (int) BufInUse;
    lft_chars = mbcs_glyphs(Buffer, DpyStart);
    pos_chars = mbcs_glyphs(Buffer, EditAt);
    all_chars = mbcs_glyphs(Buffer, all_bytes);
#endif

    /*
     * Now we have:
     *                .--DpyWidth--.
     *      +---------+=============+-----------+
     *      |         |M           M|           |   (M=PanMargin)
     *      +---------+=============+-----------+
     *      0         DpyStart                   BufInUse
     *
     * Insertion point can be anywhere between 0 and stringlength.  Calculate
     * a new display starting point.
     *
     * First, make Lynx scroll several columns at a time as needed when
     * extending the string.   Doing this helps with lowspeed connections.
     */

    lft_bytes = DpyStart;
    lft_cells = LYstrExtent2(Buffer, DpyStart);

    if ((lft_cells + DpyWidth) <= all_cells) {
	if (pos_cells >= (lft_cells + DpyWidth) - PanMargin) {
	    lft_cells = (pos_cells - DpyWidth) + PanMargin;
#ifdef SUPPORT_MULTIBYTE_EDIT
	    lft_chars = cell2char(Buffer, lft_cells);
	    lft_bytes = mbcs_skip(Buffer, lft_chars);
#else
	    lft_bytes = lft_cells;
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }

    if (pos_cells < lft_cells + PanMargin) {
	lft_cells = pos_cells - PanMargin;
	if (lft_cells < 0)
	    lft_cells = 0;
#ifdef SUPPORT_MULTIBYTE_EDIT
	lft_chars = cell2char(Buffer, lft_cells);
	lft_bytes = mbcs_skip(Buffer, lft_chars);
#else
	lft_bytes = lft_cells;
#endif /* SUPPORT_MULTIBYTE_EDIT */
    }

    LYmove(StartY, StartX);

    /*
     * Draw the left scrolling-indicator now, to avoid the complication of
     * overwriting part of a multicolumn character which may lie in the first
     * position.
     */
    if (IsPanned && lft_cells) {
	CTRACE_EDIT((tfp, "Draw left scroll-indicator\n"));
	TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	LYmove(StartY, StartX);
	LYaddch(ACS_LARROW);
	TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	lft_shift = 1;
    }

    str = &Buffer[lft_bytes];
    DpyStart = lft_bytes;

    dpy_cells = all_cells - lft_cells;
    CTRACE_EDIT((tfp, "Comparing dpy_cells %d > (%d - %d)\n",
		 dpy_cells, DpyWidth, lft_shift));
    if (dpy_cells > (DpyWidth - lft_shift)) {
	rgt_shift = 1;
	dpy_cells = (DpyWidth - lft_shift - rgt_shift);
    }
    for (;;) {
#ifdef SUPPORT_MULTIBYTE_EDIT
	dpy_chars = cell2char(str, dpy_cells);
	dpy_bytes = mbcs_skip(str, dpy_chars);
#else
	dpy_bytes = dpy_cells;
#endif /* SUPPORT_MULTIBYTE_EDIT */
	/*
	 * The last character on the display may be multicolumn, and if we take
	 * away a single cell for the right scroll-indicator, that would force
	 * us to display fewer characters.  Check for that, and recompute.
	 */
	if (rgt_shift && *str) {
	    int old_cells = dpy_cells;

	    dpy_cells = LYstrExtent2(str, dpy_bytes);
	    if (dpy_cells > old_cells)
		dpy_cells = old_cells - 1;

	    CTRACE_EDIT((tfp, "Comparing cells %d vs %d\n", dpy_cells, old_cells));
	    if (dpy_cells < old_cells) {
		CTRACE_EDIT((tfp, "Recomputing...\n"));
		continue;
	    }
	}
	break;
    }

    CTRACE_EDIT((tfp, "BYTES left %2d pos %2d dpy %2d all %2d\n",
		 lft_bytes, pos_bytes, dpy_bytes, all_bytes));
    CTRACE_EDIT((tfp, "CELLS left %2d pos %2d dpy %2d all %2d\n",
		 lft_cells, pos_cells, dpy_cells, all_cells));
    CTRACE_EDIT((tfp, "CHARS left %2d pos %2d dpy %2d all %2d\n",
		 lft_chars, pos_chars, dpy_chars, all_chars));

#ifdef USE_COLOR_STYLE
    /*
     * If this is the last screen line, set attributes to normal, should only
     * be needed for color styles.  The curses function may be used directly to
     * avoid complications.  - kw
     */
    if (StartY == (LYlines - 1))
	prompting = 1;
    if (prompting) {
	estyle = s_prompt_edit;
    } else {
	estyle = s_aedit;
    }
    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.getstr: switching to <edit.%s>.\n",
	     prompting ? "prompt" : "active"));
    if (estyle != NOSTYLE) {
	curses_style(estyle, STACK_ON);
    } else {
	(void) wattrset(LYwin, A_NORMAL);	/* need to do something about colors? */
    }
#endif
    if (IsHidden) {
	BOOL utf_flag = IS_UTF8_TTY;
	int cell = 0;

	fill_edited_line(0, dpy_cells, '*');

	i = 0;
	do {
	    const char *last = str + i;
	    const char *next = LYmbcs_skip_glyphs(last, 1, utf_flag);
	    int j = (int) (next - str);

	    while (i < j) {
		Offs2Col[i++] = cell + StartX;
	    }
	    cell += LYstrExtent2(last, (int) (next - last));
	} while (i < dpy_bytes);
	Offs2Col[i] = cell + StartX;
    } else {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (EditMark >= 0 && DpyStart > EditMark)
	    TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	remember_column(edit, 0);
	for (i = 0; i < dpy_bytes; i++) {
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	    if (EditMark >= 0 && ((DpyStart + i == EditMark && EditAt > EditMark)
				  || (DpyStart + i == EditAt && EditAt < EditMark)))
		TmpStyleOn(prompting ? s_prompt_sel : s_aedit_sel);
	    if (EditMark >= 0 && ((DpyStart + i == EditMark && EditAt < EditMark)
				  || (DpyStart + i == EditAt && EditAt > EditMark)))
		TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
#endif
	    if (str[i] == 1 || str[i] == 2 ||
		(UCH(str[i]) == 160 &&
		 !(HTPassHighCtrlRaw || IS_CJK_TTY ||
		   (LYCharSet_UC[current_char_set].enc != UCT_ENC_8859 &&
		    !(LYCharSet_UC[current_char_set].like8859
		      & UCT_R_8859SPECL))))) {
		LYaddch(' ');
	    } else if (str[i] == '\t') {
		int col = Offs2Col[i] - StartX;

		/*
		 * Like LYwaddnstr(), expand tabs from the beginning of the
		 * field.
		 */
		while (++col % 8)
		    LYaddch(' ');
		LYaddch(' ');
	    } else {
		LYaddch(UCH(str[i]));
	    }
	    remember_column(edit, i + 1);
	}
#if defined(ENHANCED_LINEEDIT) && defined(USE_COLOR_STYLE)
	if (EditMark >= 0 &&
	    ((DpyStart + dpy_bytes <= EditMark && DpyStart + dpy_bytes > EditAt)
	     || (DpyStart + dpy_bytes > EditMark
		 && DpyStart + dpy_bytes <= EditAt))) {
	    TmpStyleOff(prompting ? s_prompt_sel : s_aedit_sel);
	}
#endif
    }

    /*
     * Erase rest of input area.
     */
    padsize = DpyWidth - (Offs2Col[dpy_bytes] - StartX);
    fill_edited_line(prompting, padsize, PadChar);

    /*
     * Scrolling indicators.
     */
    if (IsPanned && dpy_bytes && rgt_shift) {
	CTRACE((tfp, "Draw right-scroller offset (%d + %d)\n",
		dpy_cells, lft_shift));
	TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	LYmove(StartY, StartX + dpy_cells + lft_shift);
	LYaddch(ACS_RARROW);
	TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
    }

    /*
     * Finally, move the cursor to the point where the next edit will occur.
     */
    LYmove(StartY, Offs2Col[EditAt - DpyStart]);

#ifdef USE_COLOR_STYLE
    if (estyle != NOSTYLE)
	curses_style(estyle, STACK_OFF);
#endif
    LYrefresh();
}

static void reinsertEdit(FieldEditor * edit, char *result)
{
    if (result != 0) {
	LYDoEdit(edit, '\0', LYE_ERASE, FALSE);
	while (*result != '\0') {
	    LYLineEdit(edit, (int) (*result), FALSE);
	    result++;
	}
    }
}

static int caselessCmpList(const void *a,
			   const void *b)
{
    return strcasecomp(*(STRING2PTR) a, *(STRING2PTR) b);
}

static int normalCmpList(const void *a,
			 const void *b)
{
    return strcmp(*(STRING2PTR) a, *(STRING2PTR) b);
}

static char **sortedList(HTList *list, int ignorecase)
{
    size_t count = (unsigned) HTList_count(list);
    size_t j = 0;
    size_t k, jk;
    char **result = typecallocn(char *, count + 1);

    if (result == 0)
	outofmem(__FILE__, "sortedList");

    assert(result != 0);

    while (!HTList_isEmpty(list))
	result[j++] = (char *) HTList_nextObject(list);

    if (count > 1) {
	qsort((char *) result, count, sizeof(*result),
	      ignorecase ? caselessCmpList : normalCmpList);

	/* remove duplicate entries from the sorted index */
	for (j = 0; result[j] != 0; j++) {
	    k = j;
	    while (result[k] != 0
		   && !strcmp(result[j], result[k])) {
		k++;
	    }
	    k--;
	    if (j != k) {
		for (jk = j;; jk++) {
		    result[jk] = result[jk + k - j];
		    if (result[jk] == 0)
			break;
		}
	    }
	}
    }

    return result;
}

int LYarrayLength(STRING2PTR list)
{
    int result = 0;

    while (*list++ != 0)
	result++;
    return result;
}

int LYarrayWidth(STRING2PTR list)
{
    int result = 0;
    int check;

    while (*list != 0) {
	check = (int) strlen(*list++);
	if (check > result)
	    result = check;
    }
    return result;
}

static void FormatChoiceNum(char *target,
			    int num_choices,
			    int choice,
			    const char *value)
{
    if (num_choices >= 0) {
	int digits = (num_choices > 9) ? 2 : 1;

	sprintf(target, "%*d: %.*s",
		digits, (choice + 1),
		MAX_LINE - 9 - digits, value);
    } else {
	LYStrNCpy(target, value, MAX_LINE - 1);
    }
}

static unsigned options_width(STRING2PTR list)
{
    unsigned width = 0;
    int count = 0;

    while (list[count] != 0) {
	unsigned ncells = (unsigned) LYstrCells(list[count]);

	if (ncells > width) {
	    width = ncells;
	}
	count++;
    }
    return width;
}

static void draw_option(WINDOW * win, int entry,
			int width,
			int reversed,
			int num_choices,
			int number,
			const char *value)
{
    char Cnum[MAX_LINE];

    (void) width;

    FormatChoiceNum(Cnum, num_choices, number, "");
#ifdef USE_SLANG
    SLsmg_gotorc(win->top_y + entry, (win->left_x + 2));
    LYaddstr(Cnum);
    if (reversed)
	SLsmg_set_color(2);
    SLsmg_write_nstring((SLFUTURE_CONST char *) value, (unsigned) win->width);
    if (reversed)
	SLsmg_set_color(0);
#else
    wmove(win, entry, 1);
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
    LynxWChangeStyle(win, s_menu_number, STACK_ON);
    waddstr(win, Cnum);
    LynxWChangeStyle(win, s_menu_number, STACK_OFF);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_ON);
#else
    if (reversed)
	wstart_reverse(win);
#endif
    LYpaddstr(win, width, value);
#ifdef USE_COLOR_STYLE
    LynxWChangeStyle(win, reversed ? s_menu_active : s_menu_entry, STACK_OFF);
#else
    if (reversed)
	wstop_reverse(win);
#endif
    LynxWChangeStyle(win, s_menu_entry, STACK_ON);
    waddch(win, ' ');
    LynxWChangeStyle(win, s_menu_entry, STACK_OFF);
#endif /* USE_SLANG */
}

/*
 * This function offers the choices for values of an option via a popup window
 * which functions like that for selection of options in a form.  - FM
 *
 * Also used for mouse popups with ncurses; this is indicated by for_mouse.
 */
int LYhandlePopupList(int cur_choice,
		      int ly,
		      int lx,
		      STRING2PTR choices,
		      int width,
		      int i_length,
		      int disabled,
		      int for_mouse)
{
    BOOLEAN numbered = (BOOLEAN) (keypad_mode != NUMBERS_AS_ARROWS);
    int c = 0, cmd = 0, i = 0, j = 0, rel = 0;
    int orig_choice;
    WINDOW *form_window;
    int num_choices = 0;
    int max_choices = 0;
    int top, bottom, length = -1;
    int window_offset = 0;
    int lines_to_show;
    char Cnum[64];
    int Lnum;
    int npages;
    static bstring *prev_target = NULL;		/* Search string buffer */
    static bstring *next_target = NULL;		/* Next search buffer */
    static BOOL first = TRUE;
    char *cp;
    int ch = 0;
    RecallType recall;
    int QueryTotal;
    int QueryNum;
    BOOLEAN FirstRecall = TRUE;
    BOOLEAN ReDraw = FALSE;
    int number;
    char buffer[MAX_LINE];
    const char *popup_status_msg = NULL;
    STRING2PTR Cptr = NULL;

#define CAN_SCROLL_DOWN	1
#define CAN_SCROLL_UP	2
#define CAN_SCROLL	4
    int can_scroll = 0, can_scroll_was = 0;

    orig_choice = cur_choice;
    if (cur_choice < 0)
	cur_choice = 0;

    /*
     * Initialize the search string buffer. - FM
     */
    if (first) {
	BStrCopy0(next_target, "");
	first = FALSE;
    }
    BStrCopy0(prev_target, "");
    QueryTotal = (search_queries ? HTList_count(search_queries) : 0);
    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
    QueryNum = QueryTotal;

    /*
     * Count the number of choices to be displayed, where num_choices ranges
     * from 0 to n, and set width to the longest choice string length.  Also
     * set Lnum to the length for the highest choice number, then decrement
     * num_choices so as to be zero-based.  The window width will be based on
     * the sum of width and Lnum.  - FM
     */
    num_choices = LYarrayLength(choices) - 1;
    if (width <= 0)
	width = (int) options_width(choices);
    if (numbered) {
	sprintf(Cnum, "%d: ", num_choices);
	Lnum = (int) strlen(Cnum);
	max_choices = num_choices;
    } else {
	Lnum = 0;
	max_choices = -1;
    }

    /*
     * Let's assume for the sake of sanity that ly is the number corresponding
     * to the line the choice is on.
     *
     * Let's also assume that cur_choice is the number of the item that should
     * be initially selected, as 0 being the first item.
     *
     * So what we have, is the top equal to the current screen line subtracting
     * the cur_choice + 1 (the one must be for the top line we will draw in a
     * box).  If the top goes under 0, consider it 0.
     */
    top = ly - (cur_choice + 1);
    if (top < 0)
	top = 0;

    /*
     * Check and see if we need to put the i_length parameter up to the number
     * of real choices.
     */
    if (i_length < 1) {
	i_length = num_choices;
    } else {
	/*
	 * Otherwise, it is really one number too high.
	 */
	i_length--;
    }

    /*
     * The bottom is the value of the top plus the number of options to view
     * plus 3 (one for the top line, one for the bottom line, and one to offset
     * the 0 counted in the num_choices).
     */
    bottom = top + i_length + 3;

    /*
     * Set lines_to_show based on the user_mode global.
     */
    if (user_mode == NOVICE_MODE)
	lines_to_show = LYlines - 4;
    else
	lines_to_show = LYlines - 2;

    if (for_mouse && user_mode == NOVICE_MODE && lines_to_show > 2)
	lines_to_show--;

    /*
     * Hmm...  If the bottom goes beyond the number of lines available,
     */
    if (bottom > lines_to_show) {
	/*
	 * Position the window at the top if we have more choices than will fit
	 * in the window.
	 */
	if ((i_length + 3) > lines_to_show) {
	    top = 0;
	    bottom = (top + (i_length + 3));
	    if (bottom > lines_to_show)
		bottom = (lines_to_show + 1);
	} else {
	    /*
	     * Try to position the window so that the selected choice will
	     * appear where the selection box currently is positioned.  It
	     * could end up too high, at this point, but we'll move it down
	     * latter, if that has happened.
	     */
	    top = (lines_to_show + 1) - (i_length + 3);
	    bottom = (lines_to_show + 1);
	}
    }

    /*
     * This is really fun, when the length is 4, it means 0 to 4, or 5.
     */
    length = (bottom - top) - 2;
    if (length <= num_choices)
	can_scroll = CAN_SCROLL;

    /*
     * Move the window down if it's too high.
     */
    if (bottom < ly + 2) {
	bottom = ly + 2;
	if (bottom > lines_to_show + 1)
	    bottom = lines_to_show + 1;
	top = bottom - length - 2;
    }

    if (for_mouse) {
	int check = (Lnum + (int) width + 4);
	int limit = LYcols;

	/* shift horizontally to lie within screen width, if possible */
	if (check < limit) {
	    if (lx - 1 + check > limit)
		lx = limit + 1 - check;
	    else if (lx <= 0)
		lx = 1;
	}
    }

    /*
     * Set up the overall window, including the boxing characters ('*'), if it
     * all fits.  Otherwise, set up the widest window possible.  - FM
     */
    width += Lnum;
    bottom -= top;

    if (num_choices <= 0
	|| cur_choice > num_choices
	|| (form_window = LYstartPopup(&top,
				       &lx,
				       &bottom,
				       &width)) == 0)
	return (orig_choice);

    width -= Lnum;
    bottom += top;

    /*
     * Clear the command line and write the popup statusline.  - FM
     */
    if (disabled) {
	popup_status_msg = CHOICE_LIST_UNM_MSG;
    } else if (!for_mouse) {
	popup_status_msg = CHOICE_LIST_MESSAGE;
#if defined(USE_MOUSE) && (defined(NCURSES) || defined(PDCURSES))
    } else {
	popup_status_msg =
	    gettext("Left mouse button or return to select, arrow keys to scroll.");
#endif
    }
    _statusline(popup_status_msg);

    /*
     * Set up the window_offset for choices.
     * cur_choice ranges from 0...n
     * length ranges from 0...m
     */
    if (cur_choice >= length) {
	window_offset = cur_choice - length + 1;
    }

    /*
     * Compute the number of popup window pages.  - FM
     */
    npages = ((num_choices + 1) > length) ?
	(((num_choices + 1) + (length - 1)) / (length))
	: 1;
    /*
     * OH!  I LOVE GOTOs!  hack hack hack
     */
  redraw:

    /*
     * Display the boxed choices.
     */
    for (i = 0; i <= num_choices; i++) {
	if (i >= window_offset && i - window_offset < length) {
	    draw_option(form_window, ((i + 1) - window_offset), width, FALSE,
			max_choices, i, choices[i]);
	}
    }
    LYbox(form_window, !numbered);
    Cptr = NULL;

    /*
     * Loop on user input.
     */
    while (cmd != LYK_ACTIVATE) {
	int row = ((i + 1) - window_offset);

	/* Show scroll indicators. */
	if (can_scroll) {
	    can_scroll = ((window_offset ? CAN_SCROLL_UP : 0)
			  | (num_choices - window_offset >= length
			     ? CAN_SCROLL_DOWN : 0));
	    if (~can_scroll & can_scroll_was) {		/* Need to redraw */
		LYbox(form_window, !numbered);
		can_scroll_was = 0;
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_UP) {
		wmove(form_window, 1, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_UARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	    if (can_scroll & ~can_scroll_was & CAN_SCROLL_DOWN) {
		wmove(form_window, length, Lnum + width + 3);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_ON);
		waddch(form_window, ACS_DARROW);
		LynxWChangeStyle(form_window, s_menu_sb, STACK_OFF);
	    }
	}

	/*
	 * Unreverse cur choice.
	 */
	if (Cptr != NULL) {
	    draw_option(form_window, row, width, FALSE,
			max_choices, i, Cptr[i]);
	}
	Cptr = choices;
	i = cur_choice;
	row = ((cur_choice + 1) - window_offset);
	draw_option(form_window, row, width, TRUE,
		    max_choices, cur_choice, Cptr[cur_choice]);
	LYstowCursor(form_window, row, 1);

	c = LYgetch_choice();
	if (term_options || LYCharIsINTERRUPT(c)) {	/* Control-C or Control-G */
	    cmd = LYK_QUIT;
#ifndef USE_SLANG
	} else if (c == MOUSE_KEY) {
	    if ((cmd = fancy_mouse(form_window, row, &cur_choice)) < 0)
		goto redraw;
	    if (cmd == LYK_ACTIVATE)
		break;
#endif
	} else {
	    cmd = LKC_TO_LAC(keymap, c);
	}
#ifdef VMS
	if (HadVMSInterrupt) {
	    HadVMSInterrupt = FALSE;
	    cmd = LYK_QUIT;
	}
#endif /* VMS */

	switch (cmd) {
	case LYK_F_LINK_NUM:
	    c = '\0';
	    /* FALLTHRU */
	case LYK_1:		/* FALLTHRU */
	case LYK_2:		/* FALLTHRU */
	case LYK_3:		/* FALLTHRU */
	case LYK_4:		/* FALLTHRU */
	case LYK_5:		/* FALLTHRU */
	case LYK_6:		/* FALLTHRU */
	case LYK_7:		/* FALLTHRU */
	case LYK_8:		/* FALLTHRU */
	case LYK_9:
	    /*
	     * Get a number from the user, possibly with a 'g' or 'p' suffix
	     * (which will be loaded into c).  - FM & LE
	     */
	    number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);

	    /* handle + or - suffix */
	    CTRACE((tfp, "got popup option number %d, ", number));
	    CTRACE((tfp, "rel='%c', c='%c', cur_choice=%d\n",
		    rel, c, cur_choice));
	    if (c == 'p') {
		int curpage = ((cur_choice + 1) > length) ?
		(((cur_choice + 1) + (length - 1)) / (length))
		: 1;

		CTRACE((tfp, "  curpage=%d\n", curpage));
		if (rel == '+')
		    number = curpage + number;
		else if (rel == '-')
		    number = curpage - number;
	    } else if (rel == '+') {
		number = cur_choice + number + 1;
	    } else if (rel == '-') {
		number = cur_choice - number + 1;
	    }
	    if (rel)
		CTRACE((tfp, "new number=%d\n", number));
	    /*
	     * Check for a 'p' suffix.  - FM
	     */
	    if (c == 'p') {
		/*
		 * Treat 1 or less as the first page.  - FM
		 */
		if (number <= 1) {
		    if (window_offset == 0) {
			HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			_statusline(popup_status_msg);
			break;
		    }
		    window_offset = 0;
		    cur_choice = 0;
		    _statusline(popup_status_msg);
		    goto redraw;
		}

		/*
		 * Treat a number equal to or greater than the number of pages
		 * as the last page.  - FM
		 */
		if (number >= npages) {
		    if (window_offset >= ((num_choices - length) + 1)) {
			HTUserMsg(ALREADY_AT_OPTION_END);
			_statusline(popup_status_msg);
			break;
		    }
		    window_offset = ((npages - 1) * length);
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }
		    if (cur_choice < window_offset)
			cur_choice = window_offset;
		    _statusline(popup_status_msg);
		    goto redraw;
		}

		/*
		 * We want an intermediate page.  - FM
		 */
		if (((number - 1) * length) == window_offset) {
		    char *msg = 0;

		    HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
		    HTUserMsg(msg);
		    FREE(msg);
		    _statusline(popup_status_msg);
		    break;
		}
		cur_choice = window_offset = ((number - 1) * length);
		_statusline(popup_status_msg);
		goto redraw;

	    }

	    /*
	     * Check for a positive number, which signifies that a choice
	     * should be sought.  - FM
	     */
	    if (number > 0) {
		/*
		 * Decrement the number so as to correspond with our cur_choice
		 * values.  - FM
		 */
		number--;

		/*
		 * If the number is in range and had no legal suffix, select
		 * the indicated choice.  - FM
		 */
		if (number <= num_choices && c == '\0') {
		    cur_choice = number;
		    cmd = LYK_ACTIVATE;
		    break;
		}

		/*
		 * Verify that we had a 'g' suffix, and act on the number.  -
		 * FM
		 */
		if (c == 'g') {
		    if (cur_choice == number) {
			/*
			 * The choice already is current.  - FM
			 */
			char *msg = 0;

			HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
		    }

		    if (number <= num_choices) {
			/*
			 * The number is in range and had a 'g' suffix, so make
			 * it the current option, scrolling if needed.  - FM
			 */
			j = (number - cur_choice);
			cur_choice = number;
			if ((j > 0) &&
			    (cur_choice - window_offset) >= length) {
			    window_offset += j;
			    if (window_offset > (num_choices - length + 1))
				window_offset = (num_choices - length + 1);
			} else if ((cur_choice - window_offset) < 0) {
			    window_offset -= abs(j);
			    if (window_offset < 0)
				window_offset = 0;
			}
			_statusline(popup_status_msg);
			goto redraw;
		    }

		    /*
		     * Not in range.  - FM
		     */
		    HTUserMsg(BAD_OPTION_NUM_ENTERED);
		}
	    }

	    /*
	     * Restore the popup statusline.  - FM
	     */
	    _statusline(popup_status_msg);
	    break;

	case LYK_PREV_LINK:
	case LYK_LPOS_PREV_LINK:
	case LYK_FASTBACKW_LINK:
	case LYK_UP_LINK:

	    if (cur_choice > 0)
		cur_choice--;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset--;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_LINK:
	case LYK_LPOS_NEXT_LINK:
	case LYK_FASTFORW_LINK:
	case LYK_DOWN_LINK:
	    if (cur_choice < num_choices)
		cur_choice++;

	    /*
	     * Scroll the window down if necessary
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset++;
		goto redraw;
	    }
	    break;

	case LYK_NEXT_PAGE:
	    /*
	     * Okay, are we on the last page of the list?  If not then,
	     */
	    if (window_offset != (num_choices - length + 1)) {
		/*
		 * Modify the current choice to not be a coordinate in the
		 * list, but a coordinate on the item selected in the window.
		 */
		cur_choice -= window_offset;

		/*
		 * Page down the proper length for the list.  If simply to far,
		 * back up.
		 */
		window_offset += length;
		if (window_offset > (num_choices - length)) {
		    window_offset = (num_choices - length + 1);
		}

		/*
		 * Readjust the current selection to be a list coordinate
		 * rather than window.  Redraw this thing.
		 */
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice < num_choices) {
		/*
		 * Already on last page of the list so just redraw it with the
		 * last item selected.
		 */
		cur_choice = num_choices;
	    }
	    break;

	case LYK_PREV_PAGE:
	    /*
	     * Are we on the first page of the list?  If not then,
	     */
	    if (window_offset != 0) {
		/*
		 * Modify the current selection to not be a list coordinate,
		 * but a window coordinate.
		 */
		cur_choice -= window_offset;

		/*
		 * Page up the proper length.  If too far, back up.
		 */
		window_offset -= length;
		if (window_offset < 0) {
		    window_offset = 0;
		}

		/*
		 * Readjust the current choice.
		 */
		cur_choice += window_offset;
		goto redraw;
	    } else if (cur_choice > 0) {
		/*
		 * Already on the first page so just back up to the first item.
		 */
		cur_choice = 0;
	    }
	    break;

	case LYK_HOME:
	    cur_choice = 0;
	    if (window_offset > 0) {
		window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_END:
	    cur_choice = num_choices;
	    if (window_offset != (num_choices - length + 1)) {
		window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_DOWN_TWO:
	    cur_choice += 2;
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += 2;
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_TWO:
	    cur_choice -= 2;
	    if (cur_choice < 0)
		cur_choice = 0;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= 2;
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_DOWN_HALF:
	    cur_choice += (length / 2);
	    if (cur_choice > num_choices)
		cur_choice = num_choices;

	    /*
	     * Scroll the window down if necessary.
	     */
	    if ((cur_choice - window_offset) >= length) {
		window_offset += (length / 2);
		if (window_offset > (num_choices - length + 1))
		    window_offset = (num_choices - length + 1);
		goto redraw;
	    }
	    break;

	case LYK_UP_HALF:
	    cur_choice -= (length / 2);
	    if (cur_choice < 0)
		cur_choice = 0;

	    /*
	     * Scroll the window up if necessary.
	     */
	    if ((cur_choice - window_offset) < 0) {
		window_offset -= (length / 2);
		if (window_offset < 0)
		    window_offset = 0;
		goto redraw;
	    }
	    break;

	case LYK_REFRESH:
	    lynx_force_repaint();
	    LYrefresh();
	    break;

	case LYK_NEXT:
	    if (recall && isBEmpty(next_target)) {
		/*
		 * We got a 'n'ext command with no prior query specified within
		 * the popup window.  See if one was entered when the popup was
		 * retracted, and if so, assume that's what's wanted.  Note
		 * that it will become the default within popups, unless
		 * another is entered within a popup.  If the within popup
		 * default is to be changed at that point, use WHEREIS ('/')
		 * and enter it, or the up- or down-arrow keys to seek any of
		 * the previously entered queries, regardless of whether they
		 * were entered within or outside of a popup window.  - FM
		 */
		if ((cp = (char *) HTList_objectAt(search_queries,
						   0)) != NULL) {
		    BStrCopy0(next_target, cp);
		    QueryNum = 0;
		    FirstRecall = FALSE;
		}
	    }
	    BStrCopy(prev_target, next_target);
	    /* FALLTHRU */
	case LYK_WHEREIS:
	    if (isBEmpty(prev_target)) {
		_statusline(ENTER_WHEREIS_QUERY);
		if ((ch = LYgetBString(&prev_target, FALSE, 0, recall)) < 0) {
		    /*
		     * User cancelled the search via ^G.  - FM
		     */
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}
	    }

	  check_recall:
	    if (isBEmpty(prev_target) &&
		!(recall && (ch == UPARROW_KEY || ch == DNARROW_KEY))) {
		/*
		 * No entry.  Simply break.  - FM
		 */
		HTInfoMsg(CANCELLED);
		goto restore_popup_statusline;
	    }

	    if (recall && ch == UPARROW_KEY) {
		if (FirstRecall) {
		    /*
		     * Use the current string or last query in the list.  - FM
		     */
		    FirstRecall = FALSE;
		    if (!isBEmpty(next_target)) {
			for (QueryNum = (QueryTotal - 1);
			     QueryNum > 0; QueryNum--) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(next_target->str, cp)) {
				break;
			    }
			}
		    } else {
			QueryNum = 0;
		    }
		} else {
		    /*
		     * Go back to the previous query in the list.  - FM
		     */
		    QueryNum++;
		}
		if (QueryNum >= QueryTotal) {
		    /*
		     * Roll around to the last query in the list.  - FM
		     */
		    QueryNum = 0;
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    BStrCopy0(prev_target, cp);
		    if (!isBEmpty(next_target) &&
			!strcmp(next_target->str, prev_target->str)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((!isBEmpty(next_target) && QueryTotal == 2) ||
			       (isBEmpty(next_target) && QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
		    if ((ch = LYgetBString(&prev_target,
					   FALSE, 0, recall)) < 0) {
			/*
			 * User cancelled the search via ^G.  - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
		}
	    } else if (recall && ch == DNARROW_KEY) {
		if (FirstRecall) {
		    /*
		     * Use the current string or first query in the list.  - FM
		     */
		    FirstRecall = FALSE;
		    if (!isBEmpty(next_target)) {
			for (QueryNum = 0;
			     QueryNum < (QueryTotal - 1); QueryNum++) {
			    if ((cp = (char *) HTList_objectAt(search_queries,
							       QueryNum))
				!= NULL &&
				!strcmp(next_target->str, cp)) {
				break;
			    }
			}
		    } else {
			QueryNum = (QueryTotal - 1);
		    }
		} else {
		    /*
		     * Advance to the next query in the list.  - FM
		     */
		    QueryNum--;
		}
		if (QueryNum < 0) {
		    /*
		     * Roll around to the first query in the list.  - FM
		     */
		    QueryNum = (QueryTotal - 1);
		}
		if ((cp = (char *) HTList_objectAt(search_queries,
						   QueryNum)) != NULL) {
		    BStrCopy0(prev_target, cp);
		    if (isBEmpty(next_target) &&
			!strcmp(next_target->str, prev_target->str)) {
			_statusline(EDIT_CURRENT_QUERY);
		    } else if ((!isBEmpty(next_target) && QueryTotal == 2) ||
			       (isBEmpty(next_target) && QueryTotal == 1)) {
			_statusline(EDIT_THE_PREV_QUERY);
		    } else {
			_statusline(EDIT_A_PREV_QUERY);
		    }
		    if ((ch = LYgetBString(&prev_target,
					   FALSE, 0, recall)) < 0) {
			/*
			 * User cancelled the search via ^G. - FM
			 */
			HTInfoMsg(CANCELLED);
			goto restore_popup_statusline;
		    }
		    goto check_recall;
		}
	    }
	    /*
	     * Replace the search string buffer with the new target.  - FM
	     */
	    BStrCopy(next_target, prev_target);
	    HTAddSearchQuery(next_target->str);

	    /*
	     * Start search at the next choice.  - FM
	     */
	    for (j = 1; Cptr[i + j] != NULL; j++) {
		FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i + j]);
		if (LYcase_sensitive) {
		    if (strstr(buffer, next_target->str) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, next_target->str) != NULL)
			break;
		}
	    }
	    if (Cptr[i + j] != NULL) {
		/*
		 * We have a hit, so make that choice the current.  - FM
		 */
		cur_choice += j;
		/*
		 * Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += j;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    ReDraw = TRUE;
		}
		goto restore_popup_statusline;
	    }

	    /*
	     * If we started at the beginning, it can't be present.  - FM
	     */
	    if (cur_choice == 0) {
		HTUserMsg2(STRING_NOT_FOUND, next_target->str);
		goto restore_popup_statusline;
	    }

	    /*
	     * Search from the beginning to the current choice.  - FM
	     */
	    for (j = 0; j < cur_choice; j++) {
		FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		if (LYcase_sensitive) {
		    if (strstr(buffer, next_target->str) != NULL)
			break;
		} else {
		    if (LYstrstr(buffer, next_target->str) != NULL)
			break;
		}
	    }
	    if (j < cur_choice) {
		/*
		 * We have a hit, so make that choice the current.  - FM
		 */
		j = (cur_choice - j);
		cur_choice -= j;
		/*
		 * Scroll the window up if necessary.
		 */
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= j;
		    if (window_offset < 0)
			window_offset = 0;
		    ReDraw = TRUE;
		}
		goto restore_popup_statusline;
	    }

	    /*
	     * Didn't find it in the preceding choices either.  - FM
	     */
	    HTUserMsg2(STRING_NOT_FOUND, next_target->str);

	  restore_popup_statusline:
	    /*
	     * Restore the popup statusline and reset the search variables.  -
	     * FM
	     */
	    _statusline(popup_status_msg);
	    BStrCopy0(prev_target, "");
	    QueryTotal = (search_queries ? HTList_count(search_queries)
			  : 0);
	    recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
	    QueryNum = QueryTotal;
	    if (ReDraw == TRUE) {
		ReDraw = FALSE;
		goto redraw;
	    }
	    break;

	case LYK_QUIT:
	case LYK_ABORT:
	case LYK_PREV_DOC:
	case LYK_INTERRUPT:
	    cur_choice = orig_choice;
	    cmd = LYK_ACTIVATE;	/* to exit */
	    break;
	}
    }
    LYstopPopup();

    return (disabled ? orig_choice : cur_choice);
}

/*
 * Allow the user to edit a string.
 */
int LYgetBString(bstring **inputline,
		 int hidden,
		 size_t max_cols,
		 RecallType recall)
{
    int x, y;
    int ch;
    int xlec = -2;
    int last_xlec = -1;
    int last_xlkc = -1;
    FieldEditor MyEdit, *edit = &MyEdit;

#ifdef SUPPORT_MULTIBYTE_EDIT
    BOOL refresh_mb = TRUE;
#endif /* SUPPORT_MULTIBYTE_EDIT */
    BOOL done = FALSE;
    int result = -1;

    CTRACE((tfp, "called LYgetBString hidden %d, recall %d\n", hidden, (int) recall));

    LYGetYX(y, x);		/* Use screen from cursor position to eol */

    (void) y;
    (void) x;

    if (*inputline == NULL)	/* caller may not have initialized this */
	BStrCopy0(*inputline, "");

    LYSetupEdit(edit, (*inputline)->str, max_cols, LYcolLimit - x);
    IsHidden = (BOOL) hidden;
#ifdef FEPCTRL
    fep_on();
#endif

    while (!done) {
      beginning:
#ifndef SUPPORT_MULTIBYTE_EDIT
	LYRefreshEdit(edit);
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (refresh_mb)
	    LYRefreshEdit(edit);
#endif /* SUPPORT_MULTIBYTE_EDIT */
	ch = LYReadCmdKey(FOR_PROMPT);
#ifdef SUPPORT_MULTIBYTE_EDIT
#ifdef CJK_EX			/* for SJIS code */
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR))
	    goto beginning;
#else
	if (!refresh_mb
	    && (EditBinding(ch) != LYE_CHAR)
	    && (EditBinding(ch) != LYE_AIX))
	    goto beginning;
#endif
#endif /* SUPPORT_MULTIBYTE_EDIT */

	if (term_letter || term_options
#ifdef VMS
	    || HadVMSInterrupt
#endif /* VMS */
#ifndef DISABLE_NEWS
	    || term_message
#endif
	    ) {
#ifdef VMS
	    HadVMSInterrupt = FALSE;
#endif /* VMS */
	    ch = LYCharINTERRUPT2;
	}

	if (recall != NORECALL && (ch == UPARROW_KEY || ch == DNARROW_KEY)) {
	    BStrCopy0(*inputline, Buffer);
	    LYAddToCloset(recall, Buffer);
	    CTRACE((tfp, "LYgetstr(%s) recall\n", (*inputline)->str));
#ifdef FEPCTRL
	    fep_off();
#endif
	    LYFinishEdit(edit);
	    result = ch;
	    done = TRUE;
	    break;
	}
	ch |= InputMods;
	InputMods = 0;
	if (last_xlkc != -1) {
	    if (ch == last_xlkc)
		ch |= LKC_MOD3;
	    last_xlkc = -1;	/* consumed */
	}
#ifndef WIN_EX
	if (LKC_TO_LAC(keymap, ch) == LYK_REFRESH)
	    goto beginning;
#endif
	last_xlec = xlec;
	xlec = EditBinding(ch);
	if ((xlec & LYE_DF) && !(xlec & LYE_FORM_LAC)) {
	    last_xlkc = ch;
	    xlec &= ~LYE_DF;
	} else {
	    last_xlkc = -1;
	}
	switch (xlec) {
	case LYE_SETM1:
	    InputMods |= LKC_MOD1;
	    break;
	case LYE_SETM2:
	    InputMods |= LKC_MOD2;
	    break;
	case LYE_TAB:
	    if (xlec == last_xlec && recall != NORECALL) {
		HTList *list = whichRecall(recall);

		if (!HTList_isEmpty(list)) {
		    char **data = sortedList(list, (BOOL) (recall == RECALL_CMD));
		    int old_y, old_x;
		    int cur_choice = 0;
		    int num_options = LYarrayLength((STRING2PTR) data);

		    while (cur_choice < num_options
			   && strcasecomp(data[cur_choice], Buffer) < 0)
			cur_choice++;

		    LYGetYX(old_y, old_x);
		    cur_choice = LYhandlePopupList(cur_choice,
						   0,
						   old_x,
						   (STRING2PTR) data,
						   -1,
						   -1,
						   FALSE,
						   FALSE);
		    if (cur_choice >= 0) {
			if (recall == RECALL_CMD)
			    _statusline(": ");
			reinsertEdit(edit, data[cur_choice]);
		    }
		    LYmove(old_y, old_x);
		    FREE(data);
		}
	    } else {
		reinsertEdit(edit, LYFindInCloset(recall, Buffer));
	    }
	    break;

#ifndef CJK_EX
	case LYE_AIX:
	    /*
	     * Handle CJK characters, or as a valid character in the current
	     * display character set.  Otherwise, we treat this as LYE_ENTER.
	     */
	    if (ch != '\t' &&
		(IS_CJK_TTY ||
		 LYlowest_eightbit[current_char_set] <= 0x97)) {
		LYLineEdit(edit, ch, FALSE);
		break;
	    }
	    /* FALLTHRU */
#endif
	case LYE_ENTER:
	    BStrCopy0(*inputline, Buffer);
	    if (!hidden)
		LYAddToCloset(recall, Buffer);
	    CTRACE((tfp, "LYgetstr(%s) LYE_ENTER\n", (*inputline)->str));
#ifdef FEPCTRL
	    fep_off();
#endif
	    LYFinishEdit(edit);
	    result = ch;
	    done = TRUE;
	    break;

#ifdef CAN_CUT_AND_PASTE
	case LYE_PASTE:
	    {
		unsigned char *s = (unsigned char *) get_clip_grab(), *e;
		size_t len;

		if (!s)
		    break;
		len = strlen((const char *) s);
		e = s + len;

		if (len != 0) {
		    unsigned char *e1 = s;

		    while (e1 < e) {
			if (*e1 < ' ') {	/* Stop here? */
			    if (e1 > s)
				LYEditInsert(edit, s, (int) (e1 - s),
					     map_active, TRUE);
			    s = e1;
			    if (*e1 == '\t') {	/* Replace by space */
				LYEditInsert(edit,
					     (unsigned const char *) " ",
					     1,
					     map_active,
					     TRUE);
				s = ++e1;
			    } else {
				break;
			    }
			} else {
			    ++e1;
			}
		    }
		    if (e1 > s) {
			LYEditInsert(edit, s, (int) (e1 - s), map_active, TRUE);
		    }
		}
		get_clip_release();
		break;
	    }
#endif

	case LYE_ABORT:
	    CTRACE((tfp, "LYgetstr LYE_ABORT\n"));
#ifdef FEPCTRL
	    fep_off();
#endif
	    LYFinishEdit(edit);
	    BStrCopy0(*inputline, "");
	    done = TRUE;
	    break;

	case LYE_STOP:
	    CTRACE((tfp, "LYgetstr LYE_STOP\n"));
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	    textfields_need_activation = TRUE;
	    LYFinishEdit(edit);
	    BStrCopy0(*inputline, "");
	    done = TRUE;
	    break;
#else
#ifdef ENHANCED_LINEEDIT
	    disableEditMark();
#endif
	    break;
#endif

	case LYE_LKCMD:
	    /*
	     * Used only in form_getstr() for invoking the LYK_F_LINK_NUM
	     * prompt when in form text fields.  - FM
	     */
	    break;

	case LYE_FORM_PASS:
	    /*
	     * Used in form_getstr() to end line editing and pass on the input
	     * char/lynxkeycode.  Here it is just ignored.  - kw
	     */
	    break;

	default:
	    if (xlec & LYE_FORM_LAC) {
		/*
		 * Used in form_getstr() to end line editing and pass on the
		 * lynxkeycode already containing a lynxactioncode.  Here it is
		 * just ignored.  - kw
		 */
		break;
	    }
#ifndef SUPPORT_MULTIBYTE_EDIT
	    LYLineEdit(edit, ch, FALSE);
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (LYLineEdit(edit, ch, FALSE) == 0) {
		if (refresh_mb && IS_CJK_TTY && (0x81 <= ch) && (ch <= 0xfe))
		    refresh_mb = FALSE;
		else
		    refresh_mb = TRUE;
	    } else {
		if (!refresh_mb) {
		    LYDoEdit(edit, 0, LYE_DELP, FALSE);
		}
	    }
#endif /* SUPPORT_MULTIBYTE_EDIT */
	}
    }
    return result;
}

/*
 * Use this for fixed-buffer edits which have not been converted to use
 * LYgetBString().
 */
int LYgetstr(char *inputline,	/* fixed-size buffer for input/output */
	     int hidden,	/* true to suppress from command-history */
	     size_t bufsize,	/* sizeof(inputline) */
	     RecallType recall)	/* type of command-history */
{
    int ch;
    bstring *my_bstring = NULL;

    BStrCopy0(my_bstring, inputline);
    if (my_bstring != 0) {
	ch = LYgetBString(&my_bstring, hidden, bufsize, recall);
	if (ch >= 0 && my_bstring != 0)
	    LYStrNCpy(inputline, my_bstring->str, bufsize);
	BStrFree(my_bstring);
    } else {
	ch = -1;
    }
    return ch;
}

const char *LYLineeditHelpURL(void)
{
    static int lasthelp_lineedit = -1;
    static char helpbuf[LY_MAXPATH] = "\0";
    static char *phelp = &helpbuf[0];
    const char *result = NULL;

    if (lasthelp_lineedit == current_lineedit) {
	result = helpbuf;
    } else {
	const char *source = LYLineeditHelpURLs[current_lineedit];
	size_t available;

	if (lasthelp_lineedit == -1) {
	    LYStrNCpy(helpbuf, helpfilepath, sizeof(helpbuf) - 1);
	    phelp += strlen(helpbuf);
	}
	available = (sizeof(helpbuf) - (size_t) (phelp - helpbuf));
	if (non_empty(source) &&
	    (strlen(source) <= available)) {
	    LYStrNCpy(phelp, source, available);
	    lasthelp_lineedit = current_lineedit;
	    result = helpbuf;
	}
    }
    return result;
}

/*
 * Wrapper for sscanf to ensure that lynx can "always" read a POSIX float.
 * In some locales, the decimal point changes.
 */
int LYscanFloat2(const char **source, float *result)
{
    int count = 0;
    char *temp;
    const char *src = *source;

    src = LYSkipCBlanks(src);
    *result = 0.0;
    if (StrChr(src, '.') != 0) {
	long frc_part = 0;
	float scale = 1.0;

	if (*src != '.') {
	    temp = NULL;
	    frc_part = strtol(src, &temp, 10);
	    *result = (float) frc_part;
	    src = temp;
	}
	if (src != 0 && *src == '.') {
	    ++src;
	    if (isdigit(UCH(*src))) {
		temp = NULL;
		frc_part = strtol(src, &temp, 10);
		if (temp != 0) {
		    int digits = (int) (temp - src);

		    while (digits-- > 0)
			scale *= (float) 10.0;
		    *result += ((float) frc_part / scale);
		}
		src = temp;
	    }
	}
	if (src != 0 && *src != '\0' && StrChr(" \t+", *src) == 0) {
	    char *extra = (char *) malloc(2 + strlen(src));

	    if (extra != 0) {
		extra[0] = '1';
		strcpy(extra + 1, src);
		if (sscanf(extra, "%f", &scale) == 1) {
		    *result *= scale;
		}
		FREE(extra);
		src = LYSkipCNonBlanks(src);
	    } else {
		src = 0;
	    }
	}
	if (src != 0)
	    count = 1;
    } else {
	count = sscanf(src, "%f", result);
	src = LYSkipCNonBlanks(src);
    }
    CTRACE2(TRACE_CFG,
	    (tfp, "LYscanFloat \"%s\" -> %f (%s)\n",
	     *source, *result,
	     count ? "ok" : "error"));
    *source = src;
    return count;
}

int LYscanFloat(const char *source, float *result)
{
    const char *temp = source;

    return LYscanFloat2(&temp, result);
}

/*
 * A replacement for 'strsep()'
 */
char *LYstrsep(char **stringp,
	       const char *delim)
{
    char *marker;
    char *result = 0;

    if (non_empty(stringp)) {
	result = *stringp;	/* will return the old value */
	marker = strpbrk(*stringp, delim);
	if (marker) {
	    *marker = '\0';	/* terminate the substring */
	    *stringp = ++marker;	/* point to the next substring */
	} else {
	    *stringp = 0;	/* this was the last */
	}
    }
    return result;
}

/*
 * LYstrstr finds the first occurrence of the string pointed to by needle
 * in the string pointed to by haystack.
 *
 * It returns NULL if the string is not found.
 *
 * It is a case insensitive search.
 */
char *LYstrstr(char *haystack,
	       const char *needle)
{
    int len = (int) strlen(needle);
    char *result = NULL;

    for (; *haystack != '\0'; haystack++) {
	if (0 == UPPER8(*haystack, *needle)) {
	    if (0 == strncasecomp8(haystack + 1, needle + 1, len - 1)) {
		result = haystack;
		break;
	    }
	}
    }

    return (result);
}

#define SkipSpecialChars(p) \
	while (IsSpecialAttrChar(*p) && *p != '\0') \
	    p++

/*
 * LYno_attr_char_case_strstr finds the first occurrence of the
 * string pointed to by needle in the string pointed to by haystack.
 *
 * It ignores special characters, e.g., LY_UNDERLINE_START_CHAR in haystack.
 *
 * It is a case insensitive search.
 */
const char *LYno_attr_char_case_strstr(const char *haystack,
				       const char *needle)
{
    const char *refptr, *tstptr;
    const char *result = NULL;

    if (haystack != NULL && needle != NULL) {

	SkipSpecialChars(haystack);

	for (; *haystack != '\0' && (result == NULL); haystack++) {
	    if (0 == UPPER8(*haystack, *needle)) {
		refptr = haystack + 1;
		tstptr = needle + 1;

		if (*tstptr == '\0') {
		    result = haystack;
		    break;
		}

		while (1) {
		    if (!IsSpecialAttrChar(*refptr)) {
			if (0 != UPPER8(*refptr, *tstptr))
			    break;
			refptr++;
			tstptr++;
		    } else {
			refptr++;
		    }
		    if (*tstptr == '\0') {
			result = haystack;
			break;
		    }
		    if (*refptr == '\0')
			break;
		}
	    }
	}
    }

    return (result);
}

/*
 * LYno_attr_char_strstr finds the first occurrence of the
 * string pointed to by needle in the string pointed to by haystack.
 * It ignores special characters, e.g., LY_UNDERLINE_START_CHAR in haystack.
 *
 * It is a case sensitive search.
 */
const char *LYno_attr_char_strstr(const char *haystack,
				  const char *needle)
{
    const char *refptr, *tstptr;
    const char *result = NULL;

    if (haystack != NULL && needle != NULL) {

	SkipSpecialChars(haystack);

	for (; *haystack != '\0' && (result == NULL); haystack++) {
	    if ((*haystack) == (*needle)) {
		refptr = haystack + 1;
		tstptr = needle + 1;

		if (*tstptr == '\0') {
		    result = haystack;
		    break;
		}

		while (1) {
		    if (!IsSpecialAttrChar(*refptr)) {
			if ((*refptr) != (*tstptr))
			    break;
			refptr++;
			tstptr++;
		    } else {
			refptr++;
		    }
		    if (*tstptr == '\0') {
			result = haystack;
			break;
		    } else if (*refptr == '\0') {
			break;
		    }
		}
	    }
	}
    }

    return (result);
}

/*
 * LYno_attr_mbcs_case_strstr finds the first occurrence of the string pointed
 * to by needle in the string pointed to by haystack.  It takes account of
 * MultiByte Character Sequences (UTF8).  The physical lengths of the displayed
 * string up to the start and end (= next position after) of the target string
 * are returned in *nstartp and *nendp if the search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
 * It ignores special characters, e.g., LY_UNDERLINE_START_CHAR in haystack.
 *
 * It assumes UTF8 if utf_flag is set.
 *
 * It is a case insensitive search.
 */
const char *LYno_attr_mbcs_case_strstr(const char *haystack,
				       const char *needle,
				       int utf_flag,
				       int count_gcells,
				       int *nstartp,
				       int *nendp)
{
    const char *refptr;
    const char *tstptr;
    int len = 0;
    int offset;
    const char *result = NULL;

    if (haystack != NULL && needle != NULL) {

	SkipSpecialChars(haystack);

	for (; *haystack != '\0' && (result == NULL); haystack++) {
	    if ((!utf_flag && IS_CJK_TTY && is8bits(*haystack) &&
		 *haystack == *needle &&
		 IsNormalChar(*(haystack + 1))) ||
		(0 == UPPER8(*haystack, *needle))) {
		int tarlen = 0;

		offset = len;
		len++;

		refptr = (haystack + 1);
		tstptr = (needle + 1);

		if (*tstptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len;
		    result = haystack;
		    break;
		}
		if (!utf_flag && IS_CJK_TTY && is8bits(*haystack) &&
		    *haystack == *needle &&
		    IsNormalChar(*refptr)) {
		    /* handle a CJK multibyte string */
		    if (*refptr == *tstptr) {
			refptr++;
			tstptr++;
			if (count_gcells)
			    tarlen++;
			if (*tstptr == '\0') {
			    if (nstartp)
				*nstartp = offset;
			    if (nendp)
				*nendp = len + tarlen;
			    result = haystack;
			    break;
			}
		    } else {
			/* not a match */
			haystack++;
			if (count_gcells)
			    len++;
			continue;
		    }
		}
		/* compare the remainder of the string */
		while (1) {
		    if (!IsSpecialAttrChar(*refptr)) {
			if (!utf_flag && IS_CJK_TTY && is8bits(*refptr)) {
			    if (*refptr == *tstptr &&
				*(refptr + 1) == *(tstptr + 1) &&
				!IsSpecialAttrChar(*(refptr + 1))) {
				refptr++;
				tstptr++;
				if (count_gcells)
				    tarlen++;
			    } else {
				break;
			    }
			} else if (0 != UPPER8(*refptr, *tstptr)) {
			    break;
			}

			if (!IS_UTF_EXTRA(*tstptr)) {
			    tarlen++;
			}
			refptr++;
			tstptr++;

		    } else {
			refptr++;
		    }

		    if (*tstptr == '\0') {
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			result = haystack;
			break;
		    }
		    if (*refptr == '\0')
			break;
		}
	    } else if (!(IS_UTF_EXTRA(*haystack) ||
			 IsSpecialAttrChar(*haystack))) {
		if (!utf_flag && IS_CJK_TTY && is8bits(*haystack) &&
		    IsNormalChar(*(haystack + 1))) {
		    haystack++;
		    if (count_gcells)
			len++;
		}
		len++;
	    }
	}
    }

    return (result);
}

/*
 * LYno_attr_mbcs_strstr finds the first occurrence of the string pointed
 * to by needle in the string pointed to by haystack.
 *
 * It takes account of CJK and MultiByte Character Sequences (UTF8).  The
 * physical lengths of the displayed string up to the start and end (= next
 * position after) the target string are returned in *nstartp and *nendp if the
 * search is successful.
 *
 * These lengths count glyph cells if count_gcells is set.  (Full-width
 * characters in CJK mode count as two.) Normally that's what we want.  They
 * count actual glyphs if count_gcells is unset.  (Full-width characters in CJK
 * mode count as one.)
 *
 * It ignores special characters, e.g., LY_UNDERLINE_START_CHAR in haystack.
 *
 * It assumes UTF8 if utf_flag is set.
 *
 * It is a case sensitive search.
 */
const char *LYno_attr_mbcs_strstr(const char *haystack,
				  const char *needle,
				  int utf_flag,
				  int count_gcells,
				  int *nstartp,
				  int *nendp)
{
    const char *refptr;
    const char *tstptr;
    int len = 0;
    int offset;
    const char *result = NULL;

    if (haystack != NULL && needle != NULL) {

	SkipSpecialChars(haystack);

	for (; *haystack != '\0' && (result == NULL); haystack++) {
	    if ((*haystack) == (*needle)) {
		int tarlen = 0;

		offset = len;
		len++;

		refptr = (haystack + 1);
		tstptr = (needle + 1);

		if (*tstptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len;
		    result = haystack;
		    break;
		} else if (!utf_flag &&
			   IS_CJK_TTY &&
			   is8bits(*haystack) &&
			   IsNormalChar(*refptr)) {
		    /* handle a CJK multibyte string */
		    if (*refptr == *tstptr) {
			/* found match */
			refptr++;
			tstptr++;
			if (count_gcells)
			    tarlen++;
			if (*tstptr == '\0') {
			    if (nstartp)
				*nstartp = offset;
			    if (nendp)
				*nendp = len + tarlen;
			    result = haystack;
			    break;
			}
		    } else {
			/* not a match - restart comparison */
			haystack++;
			if (count_gcells)
			    len++;
			continue;
		    }
		}
		/* compare the remainder of the string */
		while (1) {
		    if (!IsSpecialAttrChar(*refptr)) {
			if (!utf_flag && IS_CJK_TTY && is8bits(*refptr)) {
			    if (*refptr == *tstptr &&
				*(refptr + 1) == *(tstptr + 1) &&
				!IsSpecialAttrChar(*(refptr + 1))) {
				refptr++;
				tstptr++;
				if (count_gcells)
				    tarlen++;
			    } else {
				break;
			    }
			} else if ((*refptr) != (*tstptr)) {
			    break;
			}

			if (!IS_UTF_EXTRA(*tstptr)) {
			    tarlen++;
			}
			refptr++;
			tstptr++;
		    } else {
			refptr++;
		    }

		    if (*tstptr == '\0') {
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			result = haystack;
			break;
		    }
		    if (*refptr == '\0')
			break;
		}
	    } else if (!(IS_UTF_EXTRA(*haystack) ||
			 IsSpecialAttrChar(*haystack))) {
		if (!utf_flag && IS_CJK_TTY && is8bits(*haystack) &&
		    IsNormalChar(*(haystack + 1))) {
		    haystack++;
		    if (count_gcells)
			len++;
		}
		len++;
	    }
	}
    }
    return (result);
}

/*
 * Allocate and return a copy of a string.
 * see StrAllocCopy
 */
char *SNACopy(char **target,
	      const char *source,
	      size_t n)
{
    FREE(*target);
    if (source) {
	*target = typeMallocn(char, n + 1);

	if (*target == NULL) {
	    CTRACE((tfp, "Tried to malloc %lu bytes\n", (unsigned long) n));
	    outofmem(__FILE__, "SNACopy");
	    assert(*target != NULL);
	}
	LYStrNCpy(*target, source, n);
    }
    return *target;
}

/*
 * Combinate string allocation and concatenation.
 * see StrAllocCat
 */
char *SNACat(char **target,
	     const char *source,
	     size_t n)
{
    if (non_empty(source)) {
	if (*target) {
	    size_t length = strlen(*target);

	    *target = typeRealloc(char, *target, length + n + 1);

	    if (*target == NULL)
		outofmem(__FILE__, "SNACat");
	    assert(*target != NULL);
	    LYStrNCpy(*target + length, source, n);
	} else {
	    *target = typeMallocn(char, n + 1);

	    if (*target == NULL)
		outofmem(__FILE__, "SNACat");
	    assert(*target != NULL);
	    MemCpy(*target, source, n);
	    (*target)[n] = '\0';	/* terminate */
	}
    }
    return *target;
}

#include <caselower.h>

/*
 * Returns lowercase equivalent for unicode,
 * transparent output if no equivalent found.
 */
static long UniToLowerCase(long upper)
{
    size_t i, high, low;
    long diff = 0;
    long result = upper;

    if (upper > 0) {
	/*
	 * Try unicode_to_lower_case[].
	 */
	low = 0;
	high = TABLESIZE(unicode_to_lower_case);
	while (low < high) {
	    /*
	     * Binary search.
	     */
	    i = (low + (high - low) / 2);
	    diff = (unicode_to_lower_case[i].upper - upper);
	    if (diff < 0) {
		low = i + 1;
	    } else if (diff > 0) {
		high = i;
	    } else if (diff == 0) {
		result = unicode_to_lower_case[i].lower;
		break;
	    }
	}
    }

    return result;
}

/*
 *   UPPER8 ?
 *   it was "TOUPPER(a) - TOUPPER(b)" in its previous life...
 *
 *   It was realized that case-insensitive user search
 *   got information about upper/lower mapping from TOUPPER
 *   (precisely from "(TOUPPER(a) - TOUPPER(b))==0")
 *   and depends on locale in its 8bit mapping. -
 *   Usually fails with DOS/WINDOWS display charsets
 *   as well as on non-UNIX systems.
 *
 *   So use unicode case mapping.
 */
int UPPER8(int ch1, int ch2)
{
    int result = 0;

    if (ch1 == ch2) {
	result = 0;
    } else if (!ch2) {
	result = UCH(ch1);
    } else if (!ch1) {
	result = -UCH(ch2);
    } else if (UCH(TOASCII(ch1)) < 128 && UCH(TOASCII(ch2)) < 128) {
	/* case-insensitive match for us-ascii */
	result = (TOUPPER(ch1) - TOUPPER(ch2));
    } else if (UCH(TOASCII(ch1)) > 127 &&
	       UCH(TOASCII(ch2)) > 127) {
	/* case-insensitive match for upper half */
	if (DisplayCharsetMatchLocale) {
	    result = (TOUPPER(ch1) - TOUPPER(ch2));	/* old-style */
	} else {
	    long uni_ch2 = UCTransToUni((char) ch2, current_char_set);
	    long uni_ch1;

	    if (uni_ch2 < 0) {
		result = UCH(ch1);
	    } else {
		uni_ch1 = UCTransToUni((char) ch1, current_char_set);
		result = (int) (UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
	    }
	}
    } else {
	result = -10;		/* mismatch */
    }

    return result;
}

/*
 * Replaces 'fgets()' calls into a fixed-size buffer with reads into a buffer
 * that is allocated.  When an EOF or error is found, the buffer is freed
 * automatically.
 */
char *LYSafeGets(char **target,
		 FILE *fp)
{
    char buffer[BUFSIZ];
    char *result = 0;

    if (target != 0)
	result = *target;
    if (result != 0)
	*result = 0;

    while (fgets(buffer, (int) sizeof(buffer), fp) != NULL) {
	if (*buffer)
	    result = StrAllocCat(result, buffer);
	if (StrChr(buffer, '\n') != 0)
	    break;
    }
    if (ferror(fp)) {
	FREE(result);
    } else if (feof(fp) && result && *result == '\0') {
	/*
	 * If the file ends in the middle of a line, return the partial line;
	 * if another call is made after this, it will return NULL.  - kw
	 */
	FREE(result);
    }
    if (target != 0)
	*target = result;
    return result;
}

#ifdef USE_CMD_LOGGING
static FILE *cmd_logfile;
static FILE *cmd_script;

void LYOpenCmdLogfile(int argc,
		      char **argv)
{
    int n;

    if (lynx_cmd_logfile != 0) {
	cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
	if (cmd_logfile != 0) {
	    fprintf(cmd_logfile, "# Command logfile created by %s %s (%s)\n",
		    LYNX_NAME, LYNX_VERSION, LYVersionDate());
	    for (n = 0; n < argc; n++) {
		fprintf(cmd_logfile, "# Arg%d = %s\n", n, argv[n]);
	    }
	}
    }
}

BOOL LYHaveCmdScript(void)
{
    return (BOOL) (cmd_script != 0);
}

void LYOpenCmdScript(void)
{
    if (lynx_cmd_script != 0) {
	cmd_script = fopen(lynx_cmd_script, TXT_R);
	CTRACE((tfp, "LYOpenCmdScript(%s) %s\n",
		lynx_cmd_script,
		cmd_script != 0 ? "SUCCESS" : "FAIL"));
    }
}

int LYReadCmdKey(int mode)
{
    int ch = -1;

    if (cmd_script != 0) {
	char *buffer = 0;
	char *src;
	char *tmp;

	while ((ch < 0) && LYSafeGets(&buffer, cmd_script) != 0) {
	    LYTrimTrailing(buffer);
	    src = LYSkipBlanks(buffer);
	    tmp = LYSkipNonBlanks(src);
	    switch ((unsigned) (tmp - src)) {
	    case 4:
		if (!strncasecomp(src, "exit", 4))
		    exit_immediately(EXIT_SUCCESS);
		break;
	    case 3:
		if (!strncasecomp(src, "key", 3)) {
		    ch = LYStringToKeycode(LYSkipBlanks(tmp));
		} else if (!strncasecomp(src, "set", 3)) {
		    src = LYSkipBlanks(tmp);
		    tmp = src;
		    while (*tmp != '\0') {
			if (isspace(UCH(*tmp)) || *tmp == '=')
			    break;
			++tmp;
		    }
		    if (*tmp != '\0') {
			*tmp++ = '\0';
			tmp = LYSkipBlanks(tmp);
		    }
		    if (LYSetConfigValue(src, tmp)) {
			CTRACE((tfp, "LYSetConfigValue(%s, %s)\n", src, tmp));
		    } else if (LYsetRcValue(src, tmp)) {
			CTRACE((tfp, "LYsetRcValue(%s, %s)\n", src, tmp));
		    } else {
			CTRACE((tfp, "?? set ignored %s\n", src));
		    }
		}
		break;
	    }
	}
	if (feof(cmd_script)) {
	    fclose(cmd_script);
	    cmd_script = 0;
	}
	if (ch >= 0) {
	    LYSleepReplay();
	    LYrefresh();
	}
	FREE(buffer);
    } else {
	ch = LYgetch_for(mode);
    }
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n",
	    mode, LYKeycodeToString(ch, TRUE), ch));
    LYWriteCmdKey(ch);
    return ch;
}

/*
 * Write a LYKeymapCode 'ch' to the logfile.
 */
void LYWriteCmdKey(int ch)
{
    if (cmd_logfile != 0) {
	fprintf(cmd_logfile, "key %s\n", LYKeycodeToString(ch, FALSE));
    }
}

void LYCloseCmdLogfile(void)
{
    if (cmd_logfile != 0) {
	LYCloseOutput(cmd_logfile);
	cmd_logfile = 0;
    }
    if (cmd_script != 0) {
	LYCloseInput(cmd_script);
	cmd_script = 0;
    }
    FREE(lynx_cmd_logfile);
    FREE(lynx_cmd_script);
}
#endif /* USE_CMD_LOGGING */
@


1.10
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.9
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYStrings.c,v 1.166 2009/06/07 19:32:16 tom Exp $ */
d38 1
a38 1
#ifdef EXP_CMD_LOGGING
d40 1
d57 6
d325 1
a325 1
    unsigned len = strlen(base);
d329 1
a329 1
	if (!strncmp(base, data, len))
d415 1
a415 1
		    ? HOME : LAC_TO_LKC0(LYK_MAIN_MENU);
d426 1
a426 1
		    ? LTARROW
d438 1
a438 1
		    ? RTARROW : LAC_TO_LKC0(LYK_HISTORY);
d515 4
a518 2
			    || !(cury == y && (curx >= lx) && ((curx - lx) <= len))) {
			    c = LAC_TO_LKC0(LYK_SUBMIT);
d521 1
a521 1
			    c = LAC_TO_LKC0(LYK_SUBMIT);
d578 2
a579 2
 * LYstrncpy() terminates strings with a null byte.  Writes a null byte into
 * the n+1 byte of dst.
d581 2
a582 2
char *LYstrncpy(char *dst,
		const char *src,
d585 1
a585 1
    char *val;
d588 9
a596 5
    if (src == 0)
	src = "";
    len = (int) strlen(src);

    if (n < 0)
d598 2
a599 6

    val = strncpy(dst, src, (unsigned) n);
    if (len < n)
	*(dst + len) = '\0';
    else
	*(dst + n) = '\0';
d608 1
a608 1
 * multibyte characters.  The src string is copied until either end of string
d612 2
a613 2
char *LYmbcsstrncpy(char *dst,
		    const char *src,
d616 1
a616 1
		    BOOL utf_flag)
d618 1
a618 1
    char *val = dst;
d626 2
a627 2
    for (; *src != '\0' && i_bytes < n_bytes; i_bytes++) {
	if (IS_NEW_GLYPH(*src)) {
d629 1
a629 1
		*dst = '\0';
d633 1
a633 1
	*(dst++) = *(src++);
d635 1
a635 1
    *dst = '\0';
d647 1
a647 1
			       BOOL utf_flag)
d654 1
a654 1
    if (!isEmpty(data)) {
d681 1
a681 1
			      BOOL utf_flag)
d689 1
a689 1
	actual = LYstrExtent2(data, result - data);
d703 2
a704 2
		 BOOL utf_flag,
		 BOOL count_gcells)
d841 1
a841 1
    *button = SLang_getkey();
d854 1
a854 1
    *x = SLang_getkey();
d856 1
a856 1
	*x = SLang_getkey() + 64 - 33;
d859 1
a859 1
    *y = SLang_getkey();
d861 1
a861 1
	*y = SLang_getkey() + 64 - 33;
d896 1
a896 1
void ena_csi(BOOLEAN flag)
d898 1
a898 1
    csi_is_csi = flag;
d905 3
a907 1
	SLkm_define_keysym ((char*)(string), code, Keymap_List)
d909 4
a912 2
#define expand_substring(dst, first, last, final) \
 	(SLexpand_escaped_string(dst, (char *)first, (char *)last), 1)
d920 5
a924 2
#define expand_substring(dst, first, last, final) \
	(SLexpand_escaped_string(dst, (char *)first, (char *)last, LY_Slang_UTF8_Mode), 1)
a932 6
#define SQUOTE '\''
#define DQUOTE '"'
#define ESCAPE '\\'
#define LPAREN '('
#define RPAREN ')'

d943 1
a943 1
# define INTERN_KEY(string,lynx,curses)          {string,lynx}
d945 2
a946 2
#define INTERN_KEY(string,lynx,curses)           {string,curses}
#define EXTERN_KEY(string,string1,lynx,curses)   {string,curses}
d952 1
d957 7
a963 7
    INTERN_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    INTERN_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    INTERN_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    INTERN_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    INTERN_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    INTERN_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    INTERN_KEY( "HOME",		HOME,		KEY_HOME ),
d965 12
a976 1
    INTERN_KEY( "F1",		F1,		KEY_F(1) ),
d983 2
a984 1
    INTERN_KEY( NULL,		-1,		ERR )
d1008 1
a1008 2
    strncpy(name, first, len);
    name[len] = '\0';
d1012 1
a1012 1
	    LYstrncpy(*result, cur_term->type.Strings[code], final - *result);
d1076 2
a1077 2
	LYstrncpy(tmp, first, limit);
	value = strtol(tmp, &last, radix);
d1092 1
a1092 1
static BOOLEAN expand_substring(char *dst,
d1102 1
a1102 1
	    first = expand_tichar(first, &dst, final);
d1107 2
a1108 2
		const char *s = strchr(first, RPAREN);
		char *was = dst;
d1112 2
a1113 2
		first = expand_tiname(first, (unsigned) (s - first), &dst, final);
		if (dst == was)
d1118 1
a1118 1
		*dst++ = 127;
d1120 1
a1120 1
		*dst++ = (char) (ch & 0x1f);
d1122 1
a1122 1
		*dst++ = '^';
d1130 1
a1130 1
	    *dst++ = (char) ch;
d1134 1
a1134 1
    *dst = '\0';
d1145 4
a1148 1
	expand_substring(buf, parse + 1, parse + len - 1, buf + sizeof(buf) - 1);
d1154 1
a1154 1
static BOOLEAN unescape_string(char *src, char *dst, char *final)
d1158 1
a1158 1
    if (*src == SQUOTE) {
d1161 1
a1161 1
	unescaped_char(src, &keysym);
d1163 2
a1164 2
	    dst[0] = (char) keysym;
	    dst[1] = '\0';
d1167 3
a1169 2
    } else if (*src == DQUOTE) {
	ok = expand_substring(dst, src + 1, src + strlen(src) - 1, final);
d1175 16
d1198 1
a1198 1
	char *other = strchr(str + 4, ':');
d1205 1
a1205 2
		strncpy(buf, str + 4, (unsigned) (other - str - 4));
		buf[other - str - 4] = '\0';
d1218 1
a1218 2
    }
    if (strncasecomp(str, "Meta-", 5) == 0) {
d1237 4
a1240 4
		expand_substring(buf,
				 str,
				 str + HTMIN(len, 28),
				 buf + sizeof(buf) - 1);
d1245 1
a1245 2
    }
    if (*str == SQUOTE) {
d1252 1
a1252 1
	    *keysym = value;
d1259 1
a1259 1
	Keysym_String_List *k;
d1261 2
a1262 7
	k = Keysym_Strings;
	while (k->string != NULL) {
	    if (0 == strcmp(k->string, str)) {
		*keysym = k->value;
		break;
	    }
	    k++;
d1271 26
d1447 1
a1447 1
	    if (strlen(s) > len && !strncmp(s, table[n].name, len)
d1461 8
a1468 8
	INTERN_KEY( "\033[A",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033OA",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	INTERN_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
d1473 3
a1475 3
	INTERN_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\033[7~",	HOME,		KEY_HOME),
d1477 4
a1480 4
	INTERN_KEY( "\033[11~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[28~",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033OP",	F1,		KEY_F(1) ),
	INTERN_KEY( "\033[OP",	F1,		KEY_F(1) ),
d1482 6
a1487 5
#if defined(USE_SLANG) && (defined(__WIN32__) || defined(__MINGW32__))
	INTERN_KEY( "\xE0H",	UPARROW,	KEY_UP ),
	INTERN_KEY( "\xE0P",	DNARROW,	KEY_DOWN ),
	INTERN_KEY( "\xE0M",	RTARROW,	KEY_RIGHT ),
	INTERN_KEY( "\xE0K",	LTARROW,	KEY_LEFT ),
d1490 3
a1492 3
	INTERN_KEY( "\xE0I",	PGUP,		KEY_PPAGE ),
	INTERN_KEY( "\xE0Q",	PGDOWN,		KEY_NPAGE ),
	INTERN_KEY( "\xE0G",	HOME,		KEY_HOME),
d1495 5
a1499 5
#if defined(USE_SLANG) && !defined(VMS)
	INTERN_KEY(	"^(ku)", UPARROW,	KEY_UP ),
	INTERN_KEY(	"^(kd)", DNARROW,	KEY_DOWN ),
	INTERN_KEY(	"^(kr)", RTARROW,	KEY_RIGHT ),
	INTERN_KEY(	"^(kl)", LTARROW,	KEY_LEFT ),
d1504 2
a1505 2
	INTERN_KEY(	"^(kP)", PGUP,		KEY_PPAGE ),
	INTERN_KEY(	"^(kN)", PGDOWN,	KEY_NPAGE ),
d1507 13
a1519 2
	INTERN_KEY(	"^(kh)", HOME,		KEY_HOME),
	INTERN_KEY(	"^(k1)", F1,		KEY_F(1) ),
d1521 2
a1522 1
#endif /* SLANG && !VMS */
d1603 1
a1603 1
	{"Activate this link",		LYK_SUBMIT,		ENT_ONLY_LINK},
d1612 2
a1613 1
    int c, c1, retlac, filter_out = (atlink ? ENT_ONLY_DOC : ENT_ONLY_LINK);
d1717 1
a1717 1
		keysym = UPARROW;
d1720 1
a1720 1
		keysym = DNARROW;
d1723 1
a1723 1
		keysym = RTARROW;
d1726 1
a1726 1
		keysym = LTARROW;
d1735 1
a1735 1
		keysym = PGUP;
d1738 1
a1738 1
		keysym = PGDOWN;
d1741 1
a1741 1
		keysym = HOME;
d1747 1
a1747 1
		keysym = F1;
a1752 1

d1754 2
a1755 3
    }

    keysym = key->f.keysym;
d1758 2
a1759 2
    if (keysym == MOUSE_KEYSYM)
	return sl_read_mouse_event(code);
d1762 2
a1763 2
    if (keysym < 0)
	return 0;
d1765 8
a1772 2
    if (keysym & (LKC_ISLECLAC | LKC_ISLAC))
	return (keysym);
d1774 6
a1779 4
    current_sl_modifier = 0;
    if (LKC_HAS_ESC_MOD(keysym)) {
	current_sl_modifier = LKC_MOD2;
	keysym &= LKC_MASK;
a1780 5

    if (keysym + 1 >= KEYMAP_SIZE)
	return 0;

    return (keysym | current_sl_modifier);
d1832 1
a1832 1
    CTRACE((tfp, "GETCH: Got %#x.\n", c));
d1925 1
a1925 1
	    c = UPARROW;
d1928 1
a1928 1
	    c = DNARROW;
d1931 1
a1931 1
	    c = RTARROW;
d1934 1
a1934 1
	    c = LTARROW;
d1940 1
a1940 1
	    c = DNARROW;
d1943 1
a1943 1
	    c = PGDOWN;
d1946 1
a1946 1
	    c = LTARROW;
d1949 1
a1949 1
	    c = RTARROW;
d1952 1
a1952 1
	    c = HOME;
d1955 1
a1955 1
	    c = UPARROW;
d1958 1
a1958 1
	    c = PGUP;
d1991 1
a1991 1
		c = F1;
d1997 1
a1997 1
		c = F1;		/* macintosh help button */
d2019 1
a2019 1
			c = F1;
d2041 1
a2041 1
		c = PGUP;
d2047 1
a2047 1
		c = PGDOWN;
d2054 1
a2054 1
		    c = F1;
d2108 1
a2108 1
	    c = DNARROW;
d2111 1
a2111 1
	    c = UPARROW;
d2114 1
a2114 1
	    c = LTARROW;
d2117 1
a2117 1
	    c = RTARROW;
d2121 1
a2121 1
	    c = DNARROW;
d2124 1
a2124 1
	    c = UPARROW;
d2127 1
a2127 1
	    c = LTARROW;
d2130 1
a2130 1
	    c = RTARROW;
d2140 1
a2140 1
	    c = HOME;
d2146 1
a2146 1
	    c = PGDOWN;
d2149 1
a2149 1
	    c = PGUP;
d2160 1
a2160 1
	    c = HOME;
d2163 1
a2163 1
	    c = PGUP;
d2172 1
a2172 1
	    c = PGDOWN;
d2192 1
a2192 1
	    c = F1;
d2201 1
a2201 1
	    c = F1;		/* VTxxx Help */
a2253 9
#if 0				/* assumption seems flawed? */
		/* Not detected by us or already processed by us.  It can
		 * happens that ncurses lags behind us in detecting the change,
		 * since its own SIGTSTP handler is not installed so detecting
		 * happened *at the end* of the last refresh.  Tell it to
		 * refresh again...  - kw
		 */
		LYrefresh();
#endif
d2335 3
a2337 2
		    if (c == LAC_TO_LKC0(LYK_SUBMIT) && code == FOR_INPUT)
			lac = LYK_SUBMIT;
d2358 1
a2358 1
		    if (lac == LYK_SUBMIT) {
a2373 4
#if 0				/* Probably not necessary any more - kw */
		    lynx_force_repaint();
		    LYrefresh();
#endif
d2383 2
a2384 1
		    lac != LYK_REFRESH && lac != LYK_SUBMIT) {
d2425 1
a2425 1
			    c = LTARROW;
d2428 1
a2428 1
			    c = RTARROW;
d2434 1
a2434 1
			    c = PGDOWN;
d2440 1
a2440 1
			    c = LTARROW;
d2443 1
a2443 1
			    c = RTARROW;
d2449 1
a2449 1
			    c = PGUP;
d2478 1
a2478 1
	    c = DNARROW;
d2482 1
a2482 1
	    c = UPARROW;
d2486 1
a2486 1
	    c = LTARROW;
d2490 1
a2490 1
	    c = RTARROW;
d2494 1
a2494 1
	    c = HOME;
d2498 1
a2498 1
	    c = PGDOWN;
d2502 1
a2502 1
	    c = PGUP;
d2509 1
a2509 1
	    c = F1;
d2536 1
a2536 1
	    c = DNARROW;
d2539 1
a2539 1
	    c = UPARROW;
d2542 1
a2542 1
	    c = LTARROW;
d2545 1
a2545 1
	    c = RTARROW;
d2549 1
a2549 1
	    c = HOME;
d2553 1
a2553 1
	    c = PGDOWN;
d2557 1
a2557 1
	    c = PGUP;
d2564 1
a2564 1
	    c = F1;
d2576 1
a2576 1
    if (c & (LKC_ISLAC | LKC_ISLECLAC))
d2578 1
a2578 1
    if ((c + 1) >= KEYMAP_SIZE) {
d2645 1
a2645 1
    for (i = 0; buffer[i]; i++)
a2646 1
    {
a2655 1
    }
d2659 1
d2670 1
a2670 1
    for (i = 0; buffer[i]; i++)
a2671 1
    {
a2680 1
    }
d2684 1
d2692 2
d2707 1
a2707 1
	    return TRUE;
d2710 1
a2710 1
    return FALSE;
d2733 2
d2749 1
a2749 1
	return buf;
d2751 1
a2751 1
    return NULL;
d2837 1
a2837 1
    LYstrncpy(buff, str, sizeof(buff) - 1);
d2859 2
d2872 1
a2872 1
	return TRUE;
d2874 1
a2874 1
    return FALSE;
d2901 1
a2901 2
 *  Display the current value of the string and allow the user
 *  to edit it.
a2903 2
#define EDREC	 EditFieldData

d2907 14
a2920 13
#define IsDirty  edit->dirty
#define IsHidden edit->hidden
#define StartX	 edit->sx
#define StartY	 edit->sy
#define Buf	 edit->buffer
#define Pos	 edit->pos	/* current editing position (bytes) */
#define StrLen	 edit->strlen	/* length (bytes) */
#define MaxLen	 edit->maxlen
#define DspWdth  edit->dspwdth
#define DspStart edit->xpan	/* display-start (columns) */
#define Margin	 edit->margin
#define PanOn	 edit->panon
#define PadChar  edit->pad
d2922 1
a2922 1
#define Mark	 edit->mark
d2924 10
d2936 1
a2936 1
static char killbuffer[MAX_EDIT] = "\0";
d2939 22
a2960 3
void LYSetupEdit(EDREC * edit, char *old,
		 int maxstr,
		 int maxdsp)
d2962 33
d3001 2
a3002 2
    PanOn = FALSE;
    edit->current_modifiers = 0;
d3004 4
a3007 4
    MaxLen = maxstr;
    DspWdth = maxdsp;
    Margin = 0;
    Pos = (int) strlen(old);
d3009 1
a3009 1
    Mark = -1;			/* pos=0, but do not show it yet */
d3011 6
a3016 1
    DspStart = 0;
d3018 2
a3019 3
    if (maxstr > maxdsp) {	/* Need panning? */
	if (DspWdth > 4)	/* Else "{}" take up precious screen space */
	    PanOn = TRUE;
d3021 2
a3022 9
	/*
	 * Figure out margins.  If too big, we do a lot of unnecessary
	 * scrolling.  If too small, user doesn't have sufficient look-ahead. 
	 * Let's say 25% for each margin, upper bound is 10 columns.
	 */
	Margin = DspWdth / 4;
	if (Margin > 10)
	    Margin = 10;
    }
d3024 2
a3025 2
    LYstrncpy(Buf, old, maxstr);
    StrLen = (int) strlen(Buf);
d3105 7
a3111 5
    for (pos = 0; pos <= len; ++pos) {
	have = LYstrExtent2(s, pos);
	CTRACE_EDIT((tfp, "  %2d:%2d:%.*s\n", pos, have, pos, s));
	if (have >= cells) {
	    break;
d3113 4
a3117 2
    if (pos > len)
	pos = len;
d3132 1
a3132 1
int LYEditInsert(EDREC * edit, unsigned const char *s,
d3135 1
a3135 1
		 BOOL maxMessage)
d3137 2
a3138 2
    int length = (int) strlen(Buf);
    int remains = MaxLen - (length + len);
d3147 2
a3148 2
	if (MaxLen > length)	/* Insert as much as we can */
	    len = MaxLen - length;
d3152 4
a3155 3
    Buf[length + len] = '\0';
    for (; length >= Pos; length--)	/* Make room */
	Buf[length + len] = Buf[length];
d3160 1
a3160 1
	int off = Pos;
d3178 1
a3178 1
				strcpy(Buf + off, tail);
d3185 1
a3185 1
			    StrAllocCopy(tail, Buf + Pos + len);
d3191 1
a3191 1
	    strncpy(Buf + off, utfbuf, (unsigned) l);
d3197 2
a3198 2
	    strcpy(Buf + off, tail);
	len = off - Pos;
d3202 1
a3202 1
	unsigned char *t = (unsigned char *) Buf + Pos;
d3208 1
a3208 1
		ch = UCTransUniChar(LYKbLayouts[current_layout][*s],
d3221 1
a3221 1
	strncpy(Buf + Pos, (const char *) s, (unsigned) len);
d3226 2
a3227 2
    Pos += len;
    StrLen += len;
d3233 5
a3237 6
    if (Mark > Pos)
	Mark += len;
    else if (Mark < -1 - Pos)
	Mark -= len;
    if (Mark >= 0)
	Mark = -1 - Mark;	/* Disable it */
d3242 10
a3251 7
/* returns 0    character processed
 *         -ch  if action should be performed outside of line-editing mode
 *         ch   otherwise
 */
int LYEdit1(EDREC * edit, int ch,
	    int action,
	    BOOL maxMessage)
d3258 1
a3258 1
    if (MaxLen <= 0)
d3261 2
a3262 2
    length = (int) strlen(&Buf[0]);
    StrLen = length;
d3276 2
a3277 4
	 * Hex 97.
	 * Fall through as a character for CJK, or if this is a valid character
	 * in the current display character set.  Otherwise, we treat this as
	 * LYE_ENTER.
d3294 1
a3294 1
	 * etc.  done by slang on Unix and possibly some comm programs.  It's
d3301 1
a3301 1
	if (Pos <= (MaxLen) && StrLen < (MaxLen)) {
d3303 12
a3314 12
	    if (Mark > Pos)
		Mark++;
	    else if (Mark < -1 - Pos)
		Mark--;
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
#endif
	    for (i = length; i >= Pos; i--)	/* Make room */
		Buf[i + 1] = Buf[i];
	    Buf[length + 1] = '\0';
	    Buf[Pos] = (char) ch;
	    Pos++;
d3323 5
a3327 16
    case LYE_BACKW:
	/*
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters.
	 */
#ifndef SUPPORT_MULTIBYTE_EDIT
	while (Pos && !isalnum(UCH(Buf[Pos - 1])))
	    Pos--;
	while (Pos && isalnum(UCH(Buf[Pos - 1])))
	    Pos--;
#else
	while (Pos && !(isalnum(UCH(Buf[Pos - 1])) || is8bits(Buf[Pos - 1])))
	    Pos--;
	while (Pos && (isalnum(UCH(Buf[Pos - 1])) || is8bits(Buf[Pos - 1])))
	    Pos--;
#endif
d3330 5
a3334 15
    case LYE_FORWW:
	/*
	 * Word forward.
	 */
#ifndef SUPPORT_MULTIBYTE_EDIT
	while (isalnum(UCH(Buf[Pos])))
	    Pos++;		/* '\0' is not a/n */
	while (!isalnum(UCH(Buf[Pos])) && Buf[Pos])
	    Pos++;
#else
	while (isalnum(UCH(Buf[Pos])) || is8bits(Buf[Pos]))
	    Pos++;		/* '\0' is not a/n */
	while (!(isalnum(UCH(Buf[Pos])) || is8bits(Buf[Pos])) && Buf[Pos])
	    Pos++;
#endif
d3337 2
a3338 5
    case LYE_ERASE:
	/*
	 * Erase the line to start fresh.
	 */
	Buf[0] = '\0';
d3340 1
a3340 1
	Mark = -1;		/* Do not show the mark */
d3342 1
a3342 1
	/* fall through */
d3344 2
a3345 5
    case LYE_BOL:
	/*
	 * Go to first column.
	 */
	Pos = 0;
d3348 2
a3349 5
    case LYE_EOL:
	/*
	 * Go to last column.
	 */
	Pos = length;
d3352 5
a3356 8
    case LYE_DELNW:
	/*
	 * Delete next word.
	 */
	offset = Pos;
	LYEdit1(edit, 0, LYE_FORWW, FALSE);
	offset = Pos - offset;
	Pos -= offset;
d3360 4
a3363 7
    case LYE_DELPW:
	/*
	 * Delete previous word.
	 */
	offset = Pos;
	LYEdit1(edit, 0, LYE_BACKW, FALSE);
	offset -= Pos;
d3366 2
a3367 2
	for (i = Pos; i < length - offset + 1; i++)
	    Buf[i] = Buf[i + offset];
d3369 5
a3373 6
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos - offset)
	    Mark += offset;	/* Shift it */
	if (-1 - Pos - offset < Mark && Mark < -1 - Pos)
	    Mark = -1 - Pos;	/* Set to the current position */
d3378 3
a3380 6
    case LYE_DELBL:
	/*
	 * Delete from current cursor position back to BOL.
	 */
	for (i = Pos; i < length + 1; i++)
	    Buf[i - Pos] = Buf[i];
d3383 3
a3385 4
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark += Pos;	/* Shift it */
d3387 1
a3387 1
	    Mark = -1;		/* Reset it */
d3389 1
a3389 1
	Pos = 0;
d3392 2
a3393 5
    case LYE_DELEL:		/* @@@@@@ */
	/*
	 * Delete from current cursor position thru EOL.
	 */
	Buf[Pos] = '\0';
d3395 3
a3397 4
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark = -1;		/* Reset it */
d3401 2
a3402 6
    case LYE_DELN:
	/*
	 * Delete next character (I-beam style cursor), or current character
	 * (box/underline style cursor).
	 */
	if (Pos >= length)
d3405 1
a3405 1
	Pos++;
d3407 1
a3407 1
	Pos += mbcs_skip(Buf + Pos, 1);
d3409 1
a3409 1
	/* fall through - DO NOT RELOCATE the LYE_DELN case wrt LYE_DELP */
d3411 2
a3412 5
    case LYE_DELP:
	/*
	 * Delete preceding character.
	 */
	if (length == 0 || Pos == 0)
d3417 7
a3423 8
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark++;
#endif
	Pos--;
	for (i = Pos; i < length; i++)
	    Buf[i] = Buf[i + 1];
d3425 4
a3428 4
	offset = Pos - mbcs_skip(Buf, mbcs_glyphs(Buf, Pos) - 1);
	Pos -= offset;
	for (i = Pos; i < length - offset + 1; i++)
	    Buf[i] = Buf[i + offset];
d3431 3
a3433 4
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Mark <= -1 - Pos)
	    Mark += offset;	/* Shift it */
d3440 1
a3440 4
    case LYE_FORW:
	/*
	 * Move cursor to the right.
	 */
d3442 2
a3443 2
	if (Pos < length)
	    Pos++;
d3445 2
a3446 2
	if (Pos < length)
	    Pos += mbcs_skip(Buf + Pos, 1);
d3453 1
a3453 4
    case LYE_BACK:
	/*
	 * Left-arrow move cursor to the left.
	 */
d3455 2
a3456 2
	if (Pos > 0)
	    Pos--;
d3458 2
a3459 2
	if (Pos > 0)
	    Pos = mbcs_skip(Buf, mbcs_glyphs(Buf, Pos) - 1);
d3476 1
a3476 1
	if (length <= 1 || Pos == 0)
d3478 8
a3485 10
	if (Pos == length)
	    Pos--;
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Temporary enable it */
	if (Mark == Pos || Mark == Pos + 1)
	    Mark = Pos - 1;
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
	if (Buf[Pos - 1] == Buf[Pos]) {
	    Pos++;
d3488 3
a3490 3
	i = Buf[Pos - 1];
	Buf[Pos - 1] = Buf[Pos];
	Buf[Pos++] = (char) i;
d3493 2
a3494 5
    case LYE_SETMARK:
	/*
	 * primitive emacs-like set-mark-command
	 */
	Mark = Pos;
d3497 3
a3499 7
    case LYE_XPMARK:
	/*
	 * emacs-like exchange-point-and-mark
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Enable it */
	if (Mark == Pos)
d3501 3
a3503 3
	i = Pos;
	Pos = Mark;
	Mark = i;
d3506 4
a3509 8
    case LYE_KILLREG:
	/*
	 * primitive emacs-like kill-region
	 */
	if (Mark < 0)
	    Mark = -1 - Mark;	/* Enable it */
	if (Mark == Pos) {
	    killbuffer[0] = '\0';
d3512 2
a3513 2
	if (Mark > Pos)
	    LYEdit1(edit, 0, LYE_XPMARK, FALSE);
d3515 1
a3515 1
	    int reglen = Pos - Mark;
d3517 5
a3521 6
	    LYstrncpy(killbuffer, &Buf[Mark],
		      HTMIN(reglen, (int) sizeof(killbuffer) - 1));
	    for (i = Mark; Buf[i + reglen]; i++)
		Buf[i] = Buf[i + reglen];
	    Buf[i] = Buf[i + reglen];	/* terminate */
	    Pos = Mark;
d3523 1
a3523 2
	if (Mark >= 0)
	    Mark = -1 - Mark;	/* Disable it */
d3526 3
a3528 6
    case LYE_YANK:
	/*
	 * primitive emacs-like yank
	 */
	if (!killbuffer[0]) {
	    Mark = -1 - Pos;
d3530 2
a3531 2
	} {
	    int yanklen = (int) strlen(killbuffer);
d3533 2
a3534 2
	    if (Pos + yanklen <= (MaxLen) && StrLen + yanklen <= (MaxLen)) {
		Mark = -1 - Pos;
d3536 6
a3541 2
		for (i = length; i >= Pos; i--)		/* Make room */
		    Buf[i + yanklen] = Buf[i];
d3543 1
a3543 1
		    Buf[Pos++] = killbuffer[i];
d3554 1
a3554 1
	LYUpperCase(Buf);
d3558 1
a3558 1
	LYLowerCase(Buf);
d3565 1
a3565 1
    StrLen = (int) strlen(&Buf[0]);
d3578 2
a3579 3
    char temp[120];
    char *p = temp;
    int num;
d3584 3
a3586 2
    temp[0] = (char) *c;
    temp[1] = '\0';
d3592 1
a3592 1
    if (LYgetstr(temp, VISIBLE, sizeof(temp), NORECALL) < 0 || *temp == 0) {
d3596 2
a3597 2
	return (0);
    }
d3599 18
a3616 18
    *rel = '\0';
    num = atoi(p);
    while (isdigit(UCH(*p)))
	++p;
    switch (*p) {
    case '+':
    case '-':
	/* 123+ or 123- */
	*rel = *p++;
	*c = *p;
	break;
    default:
	*c = *p++;
	*rel = *p;
	break;
    case 0:
	break;
    }
d3618 13
a3630 10
    /*
     * If we had a 'g' or 'p' suffix, load it into c.  Otherwise, zero c.  Then
     * return the number.
     */
    if (*p == 'g' || *p == 'G') {
	*c = 'g';
    } else if (*p == 'p' || *p == 'P') {
	*c = 'p';
    } else {
	*c = '\0';
d3632 2
a3633 3
    if (*rel != '+' && *rel != '-')
	*rel = 0;
    return num;
d3644 1
a3644 1
static void remember_column(EDREC * edit, int offset)
d3656 4
a3659 1
    edit->offset2col[offset] = x0;
d3677 1
a3677 1
 * EDREC fields retain their values as byte offsets.
d3680 1
a3680 1
void LYRefreshEdit(EDREC * edit)
d3683 1
d3685 2
a3686 1
    int pos_bytes = Pos;
d3691 1
a3691 1
    int all_cells;		/* total of display-cells in Buf */
d3694 1
a3694 1
    int pos_cells;		/* number of display-cells up to Pos */
d3696 1
a3696 2
#ifdef SUPPORT_MULTIBYTE_EDIT
    int all_chars;
d3699 3
d3704 1
d3723 1
a3723 1
    if (!IsDirty || (DspWdth == 0))
d3726 2
d3730 1
a3730 2
    all_bytes = (int) strlen(&Buf[0]);
    StrLen = all_bytes;
d3732 2
a3733 2
    all_cells = LYstrCells(Buf);
    pos_cells = LYstrExtent2(Buf, Pos);
d3735 5
a3739 4
#ifdef SUPPORT_MULTIBYTE_EDIT
    lft_chars = mbcs_glyphs(Buf, DspStart);
    pos_chars = mbcs_glyphs(Buf, Pos);
    all_chars = mbcs_glyphs(Buf, all_bytes);
d3744 1
a3744 1
     *                .--DspWdth---.
d3746 1
a3746 1
     *      |         |M           M|           |   (M=margin)
d3748 1
a3748 1
     *      0         DspStart                   StrLen
d3750 2
a3751 2
     * Insertion point can be anywhere between 0 and stringlength.  Figure out
     * new display starting point.
d3753 2
a3754 3
     * The first "if" below makes Lynx scroll several columns at a time when
     * extending the string.  Looks awful, but that way we can keep up with
     * data entry at low baudrates.
d3757 2
a3758 2
    lft_bytes = DspStart;
    lft_cells = LYstrExtent2(Buf, DspStart);
d3760 3
a3762 3
    if ((lft_cells + DspWdth) <= all_cells) {
	if (pos_cells >= (lft_cells + DspWdth) - Margin) {
	    lft_cells = (pos_cells - DspWdth) + Margin;
d3764 2
a3765 2
	    lft_chars = cell2char(Buf, lft_cells);
	    lft_bytes = mbcs_skip(Buf, lft_chars);
d3772 2
a3773 2
    if (pos_cells < lft_cells + Margin) {
	lft_cells = pos_cells - Margin;
d3777 2
a3778 2
	lft_chars = cell2char(Buf, lft_cells);
	lft_bytes = mbcs_skip(Buf, lft_chars);
d3791 1
a3791 1
    if (PanOn && lft_cells) {
d3800 2
a3801 2
    str = &Buf[lft_bytes];
    DspStart = lft_bytes;
d3805 2
a3806 2
		 dpy_cells, DspWdth, lft_shift));
    if (dpy_cells > (DspWdth - lft_shift)) {
d3808 1
a3808 1
	dpy_cells = (DspWdth - lft_shift - rgt_shift);
d3822 1
a3822 1
	if (rgt_shift) {
d3864 1
a3864 1
	wattrset(LYwin, A_NORMAL);	/* need to do something about colors? */
d3877 1
a3877 1
	    int j = (next - str);
d3880 1
a3880 1
		edit->offset2col[i++] = cell + StartX;
d3882 1
a3882 1
	    cell += LYstrExtent2(last, (next - last));
d3884 1
a3884 1
	edit->offset2col[i] = cell + StartX;
d3887 1
a3887 1
	if (Mark >= 0 && DspStart > Mark)
d3893 2
a3894 2
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			      || (DspStart + i == Pos && Pos < Mark)))
d3896 2
a3897 2
	    if (Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			      || (DspStart + i == Pos && Pos > Mark)))
d3908 1
a3908 1
		int col = edit->offset2col[i] - StartX;
d3923 4
a3926 4
	if (Mark >= 0 &&
	    ((DspStart + dpy_bytes <= Mark && DspStart + dpy_bytes > Pos)
	     || (DspStart + dpy_bytes > Mark
		 && DspStart + dpy_bytes <= Pos))) {
d3935 1
a3935 1
    padsize = DspWdth - (edit->offset2col[dpy_bytes] - StartX);
d3941 1
a3941 1
    if (PanOn && dpy_bytes && rgt_shift) {
d3953 1
a3953 1
    LYmove(StartY, edit->offset2col[Pos - DspStart]);
d3962 1
a3962 1
static void reinsertEdit(EditFieldData *edit, char *result)
d3965 1
a3965 1
	LYEdit1(edit, '\0', LYE_ERASE, FALSE);
d3976 1
a3976 1
    return strcasecomp(*(const char *const *) a, *(const char *const *) b);
d3982 1
a3982 1
    return strcmp(*(const char *const *) a, *(const char *const *) b);
d3985 1
a3985 1
static char **sortedList(HTList *list, BOOL ignorecase)
d3987 3
a3989 3
    unsigned count = (unsigned) HTList_count(list);
    unsigned j = 0;
    unsigned k, jk;
d3995 2
d4025 1
a4025 1
int LYarrayLength(const char **list)
d4034 1
a4034 1
int LYarrayWidth(const char **list)
d4047 1
a4047 1
static void FormatChoiceNum(char *dst,
d4055 1
a4055 1
	sprintf(dst, "%*d: %.*s",
d4059 1
a4059 1
	LYstrncpy(dst, value, MAX_LINE - 1);
d4063 1
a4063 1
static unsigned options_width(const char **list)
d4069 1
a4069 1
	unsigned ncells = LYstrCells(list[count]);
d4081 1
a4081 1
			BOOL reversed,
d4096 1
a4096 1
    SLsmg_write_nstring((char *) value, win->width);
d4135 1
a4135 1
		      const char **choices,
d4139 1
a4139 1
		      BOOLEAN for_mouse)
d4153 2
a4154 2
    static char prev_target[MAX_LINE];	/* Search string buffer */
    static char prev_target_buffer[MAX_LINE];	/* Next search buffer */
d4166 1
a4166 1
    const char **Cptr = NULL;
d4181 1
a4181 1
	*prev_target_buffer = '\0';
d4184 1
a4184 1
    *prev_target = '\0';
d4371 1
a4371 1
    LYbox(form_window, (BOOLEAN) !numbered);
d4386 1
a4386 1
		LYbox(form_window, (BOOLEAN) !numbered);
d4793 1
a4793 1
	    if (recall && *prev_target_buffer == '\0') {
d4807 1
a4807 3
		    LYstrncpy(prev_target_buffer,
			      cp,
			      sizeof(prev_target_buffer) - 1);
d4812 1
a4812 1
	    strcpy(prev_target, prev_target_buffer);
d4815 1
a4815 1
	    if (*prev_target == '\0') {
d4817 1
a4817 3
		if ((ch = LYgetstr(prev_target, VISIBLE,
				   sizeof(prev_target_buffer),
				   recall)) < 0) {
d4827 2
a4828 2
	    if (*prev_target == '\0' &&
		!(recall && (ch == UPARROW || ch == DNARROW))) {
d4836 1
a4836 1
	    if (recall && ch == UPARROW) {
d4842 1
a4842 1
		    if (*prev_target_buffer) {
d4848 1
a4848 1
				!strcmp(prev_target_buffer, cp)) {
d4869 3
a4871 3
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
d4873 2
a4874 3
		    } else if ((*prev_target_buffer && QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
d4879 2
a4880 2
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer), recall)) < 0) {
d4889 1
a4889 1
	    } else if (recall && ch == DNARROW) {
d4895 1
a4895 1
		    if (*prev_target_buffer) {
d4901 1
a4901 1
				!strcmp(prev_target_buffer, cp)) {
d4922 3
a4924 3
		    LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
		    if (*prev_target_buffer &&
			!strcmp(prev_target_buffer, prev_target)) {
d4926 2
a4927 4
		    } else if ((*prev_target_buffer &&
				QueryTotal == 2) ||
			       (!(*prev_target_buffer) &&
				QueryTotal == 1)) {
d4932 2
a4933 3
		    if ((ch = LYgetstr(prev_target, VISIBLE,
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
d4946 2
a4947 2
	    strcpy(prev_target_buffer, prev_target);
	    HTAddSearchQuery(prev_target_buffer);
d4954 2
a4955 2
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
d4958 1
a4958 1
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
d4983 1
a4983 1
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d4992 2
a4993 2
		if (case_sensitive) {
		    if (strstr(buffer, prev_target_buffer) != NULL)
d4996 1
a4996 1
		    if (LYstrstr(buffer, prev_target_buffer) != NULL)
d5021 1
a5021 1
	    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d5029 1
a5029 1
	    *prev_target = '\0';
d5054 7
a5060 6
#define CurModif MyEdit.current_modifiers

int LYgetstr(char *inputline,
	     int hidden,
	     size_t bufsize,
	     RecallType recall)
d5062 1
a5062 1
    int x, y, MaxStringSize;
d5067 1
a5067 1
    EditFieldData MyEdit;
d5072 4
a5077 5
    MaxStringSize = (int) ((bufsize < sizeof(MyEdit.buffer))
			   ? (bufsize - 1)
			   : (sizeof(MyEdit.buffer) - 1));
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, LYcolLimit - x);
    MyEdit.hidden = (BOOL) hidden;
d5079 14
a5092 3
    CTRACE((tfp, "called LYgetstr\n"));
    for (;;) {
      again:
d5094 1
a5094 1
	LYRefreshEdit(&MyEdit);
d5097 1
a5097 1
	    LYRefreshEdit(&MyEdit);
d5104 1
a5104 1
	    goto again;
d5109 1
a5109 1
	    goto again;
d5127 11
a5137 5
	if (recall != NORECALL && (ch == UPARROW || ch == DNARROW)) {
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
	    LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) recall\n", inputline));
	    return (ch);
d5139 2
a5140 2
	ch |= CurModif;
	CurModif = 0;
d5148 1
a5148 1
	    goto again;
d5160 1
a5160 4
	    /*
	     * Set flag for modifier 1.
	     */
	    CurModif |= LKC_MOD1;
d5163 1
a5163 4
	    /*
	     * Set flag for modifier 2.
	     */
	    CurModif |= LKC_MOD2;
d5173 1
a5173 1
		    int num_options = LYarrayLength((const char **) data);
d5176 1
a5176 1
			   && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
d5183 1
a5183 1
						   (const char **) data,
d5191 1
a5191 1
			reinsertEdit(&MyEdit, data[cur_choice]);
d5197 1
a5197 1
		reinsertEdit(&MyEdit, LYFindInCloset(recall, MyEdit.buffer));
d5201 1
a5201 1
#ifndef CJK_EX			/* 1997/11/03 (Mon) 20:13:45 */
d5204 2
a5205 4
	     * Hex 97.
	     * Treat as a character for CJK, or if this is a valid character in
	     * the current display character set.  Otherwise, we treat this as
	     * LYE_ENTER.
d5210 1
a5210 1
		LYLineEdit(&MyEdit, ch, FALSE);
d5216 1
a5216 4
	    /*
	     * Terminate the string and return.
	     */
	    LYstrncpy(inputline, MyEdit.buffer, (int) bufsize);
d5218 9
a5226 3
		LYAddToCloset(recall, MyEdit.buffer);
	    CTRACE((tfp, "LYgetstr(%s) LYE_ENTER\n", inputline));
	    return (ch);
a5228 2
	    /* 1998/10/01 (Thu) 15:05:49 */

d5232 1
a5232 1
		int len;
d5236 1
a5236 1
		len = (int) strlen((const char *) s);
d5239 1
a5239 1
		if (len > 0) {
d5245 2
a5246 1
				LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
d5249 1
a5249 1
				LYEditInsert(&MyEdit,
d5255 1
a5255 1
			    } else
d5257 2
a5258 1
			} else
d5260 4
a5264 2
		    if (e1 > s)
			LYEditInsert(&MyEdit, s, e1 - s, map_active, TRUE);
a5271 4
	    /*
	     * Control-C or Control-G aborts.
	     */
	    inputline[0] = '\0';
d5273 7
a5279 1
	    return (-1);
a5281 3
	    /*
	     * Deactivate.
	     */
d5285 4
a5288 1
	    return (-1);
d5291 1
a5291 2
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
d5293 1
a5294 1
	    break;
d5320 1
a5320 1
	    LYLineEdit(&MyEdit, ch, FALSE);
d5322 1
a5322 1
	    if (LYLineEdit(&MyEdit, ch, FALSE) == 0) {
d5329 1
a5329 1
		    LYEdit1(&MyEdit, 0, LYE_DELP, FALSE);
d5335 25
d5367 7
d5375 11
a5385 14
    if (lasthelp_lineedit == current_lineedit)
	return &helpbuf[0];
    if (lasthelp_lineedit == -1) {
	LYstrncpy(helpbuf, helpfilepath, sizeof(helpbuf) - 1);
	phelp += strlen(helpbuf);
    }
    if (LYLineeditHelpURLs[current_lineedit] &&
	strlen(LYLineeditHelpURLs[current_lineedit]) &&
	(strlen(LYLineeditHelpURLs[current_lineedit]) <=
	 sizeof(helpbuf) - (unsigned) (phelp - helpbuf))) {
	LYstrncpy(phelp, LYLineeditHelpURLs[current_lineedit],
		  (int) (sizeof(helpbuf) - (unsigned) (phelp - helpbuf) - 1));
	lasthelp_lineedit = current_lineedit;
	return (&helpbuf[0]);
d5387 1
a5387 1
    return NULL;
d5401 2
a5402 1
    if (strchr(src, '.') != 0) {
d5408 2
a5409 6
#ifdef _WIN32_WINNT
#define WIN32_FIX (float)
#else
#define WIN32_FIX /* nothing */
#endif
	    *result = WIN32_FIX strtol(src, &temp, 10);
d5418 1
a5418 1
		    int digits = temp - src;
d5421 2
a5422 2
			scale *= 10.0;
		    *result += (frc_part / scale);
d5427 1
a5427 1
	if (src != 0 && *src != '\0' && strchr(" \t+", *src) == 0) {
d5436 1
d5469 2
a5470 1
    char *tmp, *out;
d5472 11
a5482 12
    if (isEmpty(stringp))	/* nothing to do? */
	return 0;		/* then don't fall on our faces */

    out = *stringp;		/* save the start of the string */
    tmp = strpbrk(*stringp, delim);
    if (tmp) {
	*tmp = '\0';		/* terminate the substring with \0 */
	*stringp = ++tmp;	/* point at the next substring */
    } else
	*stringp = 0;		/* this was the last substring: */
    /* let caller see he's done */
    return out;
d5486 6
a5491 3
 * LYstrstr will find the first occurrence of the string pointed to by tarptr
 * in the string pointed to by chptr.  It returns NULL if string not found.  It
 * is a case insensitive search.
d5493 2
a5494 2
char *LYstrstr(char *chptr,
	       const char *tarptr)
d5496 2
a5497 1
    int len = (int) strlen(tarptr);
d5499 6
a5504 4
    for (; *chptr != '\0'; chptr++) {
	if (0 == UPPER8(*chptr, *tarptr)) {
	    if (0 == strncasecomp8(chptr + 1, tarptr + 1, len - 1))
		return (chptr);
d5506 1
a5506 1
    }				/* end for */
d5508 1
a5508 1
    return (NULL);		/* string not found or initial chptr was empty */
d5511 4
d5516 5
a5520 8
 * LYno_attr_char_case_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
 *			       LY_UNDERLINE_END_CHAR
 *			       LY_BOLD_START_CHAR
 *			       LY_BOLD_END_CHAR
 *			       LY_SOFT_HYPHEN
 *			       if present in chptr.
d5523 2
a5524 2
const char *LYno_attr_char_case_strstr(const char *chptr,
				       const char *tarptr)
d5526 2
a5527 1
    register const char *tmpchptr, *tmptarptr;
d5529 1
a5529 2
    if (!chptr)
	return (NULL);
d5531 1
a5531 2
    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;
d5533 4
a5536 7
    for (; *chptr != '\0'; chptr++) {
	if (0 == UPPER8(*chptr, *tarptr)) {
	    /*
	     * See if they line up.
	     */
	    tmpchptr = chptr + 1;
	    tmptarptr = tarptr + 1;
d5538 4
a5541 2
	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);
d5543 14
a5556 3
	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (0 != UPPER8(*tmpchptr, *tmptarptr))
a5557 4
		    tmpchptr++;
		    tmptarptr++;
		} else {
		    tmpchptr++;
a5558 4
		if (*tmptarptr == '\0')
		    return (chptr);
		if (*tmpchptr == '\0')
		    break;
d5561 1
a5561 1
    }				/* end for */
d5563 1
a5563 1
    return (NULL);
d5567 4
a5570 8
 * LYno_attr_char_strstr will find the first occurrence of the
 * string pointed to by tarptr in the string pointed to by chptr.
 * It ignores the characters:  LY_UNDERLINE_START_CHAR and
 *			       LY_UNDERLINE_END_CHAR
 *			       LY_BOLD_START_CHAR
 *			       LY_BOLD_END_CHAR
 *			       LY_SOFT_HYPHEN
 *			       if present in chptr.
d5573 2
a5574 2
const char *LYno_attr_char_strstr(const char *chptr,
				  const char *tarptr)
d5576 2
a5577 1
    register const char *tmpchptr, *tmptarptr;
d5579 1
a5579 2
    if (!chptr)
	return (NULL);
d5581 1
a5581 2
    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;
d5583 4
a5586 7
    for (; *chptr != '\0'; chptr++) {
	if ((*chptr) == (*tarptr)) {
	    /*
	     * See if they line up.
	     */
	    tmpchptr = chptr + 1;
	    tmptarptr = tarptr + 1;
d5588 4
a5591 2
	    if (*tmptarptr == '\0')	/* one char target */
		return (chptr);
d5593 11
a5603 3
	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if ((*tmpchptr) != (*tmptarptr))
d5605 3
a5607 4
		    tmpchptr++;
		    tmptarptr++;
		} else {
		    tmpchptr++;
a5608 4
		if (*tmptarptr == '\0')
		    return (chptr);
		if (*tmpchptr == '\0')
		    break;
d5611 1
a5611 1
    }				/* end for */
d5613 1
a5613 1
    return (NULL);
d5617 2
a5618 2
 * LYno_attr_mbcs_case_strstr will find the first occurrence of the string
 * pointed to by tarptr in the string pointed to by chptr.  It takes account of
d5628 2
a5629 6
 * It ignores the characters: LY_UNDERLINE_START_CHAR and
 *			      LY_UNDERLINE_END_CHAR
 *			      LY_BOLD_START_CHAR
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
 *			      if present in chptr.
d5631 2
a5632 1
 * It is a case insensitive search.  - KW & FM
d5634 4
a5637 4
const char *LYno_attr_mbcs_case_strstr(const char *chptr,
				       const char *tarptr,
				       BOOL utf_flag,
				       BOOL count_gcells,
d5641 2
a5642 2
    const char *tmpchptr;
    const char *tmptarptr;
d5645 1
d5647 1
a5647 2
    if (!(chptr && tarptr))
	return (NULL);
d5649 1
a5649 5
    /*
     * Skip initial IsSpecial chars.  - FM
     */
    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;
d5651 6
a5656 9
    /*
     * Seek a first target match.  - FM
     */
    for (; *chptr != '\0'; chptr++) {
	if ((!utf_flag && IS_CJK_TTY && is8bits(*chptr) &&
	     *chptr == *tarptr &&
	     IsNormalChar(*(chptr + 1))) ||
	    (0 == UPPER8(*chptr, *tarptr))) {
	    int tarlen = 0;
d5658 2
a5659 2
	    offset = len;
	    len++;
d5661 2
a5662 5
	    /*
	     * See if they line up.
	     */
	    tmpchptr = (chptr + 1);
	    tmptarptr = (tarptr + 1);
d5664 31
a5694 33
	    if (*tmptarptr == '\0') {
		/*
		 * One char target.
		 */
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
	    }
	    if (!utf_flag && IS_CJK_TTY && is8bits(*chptr) &&
		*chptr == *tarptr &&
		IsNormalChar(*tmpchptr)) {
		/*
		 * Check the CJK multibyte.  - FM
		 */
		if (*tmpchptr == *tmptarptr) {
		    /*
		     * It's a match.  Advance to next char.  - FM
		     */
		    tmpchptr++;
		    tmptarptr++;
		    if (count_gcells)
			tarlen++;
		    if (*tmptarptr == '\0') {
			/*
			 * One character match.  - FM
			 */
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
a5695 9
		} else {
		    /*
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
		     */
		    chptr++;
		    if (count_gcells)
			len++;
		    continue;
d5697 15
a5711 15
	    }
	    /*
	     * See if the rest of the target matches.  - FM
	     */
	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && IS_CJK_TTY && is8bits(*tmpchptr)) {
			if (*tmpchptr == *tmptarptr &&
			    *(tmpchptr + 1) == *(tmptarptr + 1) &&
			    !IsSpecialAttrChar(*(tmpchptr + 1))) {
			    tmpchptr++;
			    tmptarptr++;
			    if (count_gcells)
				tarlen++;
			} else {
d5714 9
a5722 2
		    } else if (0 != UPPER8(*tmpchptr, *tmptarptr)) {
			break;
d5725 7
a5731 2
		    if (!IS_UTF_EXTRA(*tmptarptr)) {
			tarlen++;
d5733 2
a5734 5
		    tmpchptr++;
		    tmptarptr++;

		} else {
		    tmpchptr++;
d5736 7
a5742 7

		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
d5744 1
a5744 2
		if (*tmpchptr == '\0')
		    break;
a5745 9
	} else if (!(IS_UTF_EXTRA(*chptr) ||
		     IsSpecialAttrChar(*chptr))) {
	    if (!utf_flag && IS_CJK_TTY && is8bits(*chptr) &&
		IsNormalChar(*(chptr + 1))) {
		chptr++;
		if (count_gcells)
		    len++;
	    }
	    len++;
d5747 1
a5747 1
    }				/* end for */
d5749 1
a5749 1
    return (NULL);
d5753 2
a5754 2
 * LYno_attr_mbcs_strstr will find the first occurrence of the string pointed
 * to by tarptr in the string pointed to by chptr.
d5766 2
a5767 6
 * It ignores the characters: LY_UNDERLINE_START_CHAR and
 *			      LY_UNDERLINE_END_CHAR
 *			      LY_BOLD_START_CHAR
 *			      LY_BOLD_END_CHAR
 *			      LY_SOFT_HYPHEN
 *			      if present in chptr.
d5769 2
a5770 1
 * It is a case sensitive search.  - KW & FM
d5772 4
a5775 4
const char *LYno_attr_mbcs_strstr(const char *chptr,
				  const char *tarptr,
				  BOOL utf_flag,
				  BOOL count_gcells,
d5779 2
a5780 2
    const char *tmpchptr;
    const char *tmptarptr;
d5783 1
d5785 1
a5785 2
    if (!(chptr && tarptr))
	return (NULL);
d5787 1
a5787 5
    /*
     * Skip initial IsSpecial chars.  - FM
     */
    while (IsSpecialAttrChar(*chptr) && *chptr != '\0')
	chptr++;
d5789 3
a5791 6
    /*
     * Seek a first target match.  - FM
     */
    for (; *chptr != '\0'; chptr++) {
	if ((*chptr) == (*tarptr)) {
	    int tarlen = 0;
d5793 2
a5794 2
	    offset = len;
	    len++;
d5796 2
a5797 5
	    /*
	     * See if they line up.
	     */
	    tmpchptr = (chptr + 1);
	    tmptarptr = (tarptr + 1);
d5799 32
a5830 32
	    if (*tmptarptr == '\0') {
		/*
		 * One char target.
		 */
		if (nstartp)
		    *nstartp = offset;
		if (nendp)
		    *nendp = len;
		return (chptr);
	    }
	    if (!utf_flag && IS_CJK_TTY && is8bits(*chptr) &&
		IsNormalChar(*tmpchptr)) {
		/*
		 * Check the CJK multibyte.  - FM
		 */
		if (*tmpchptr == *tmptarptr) {
		    /*
		     * It's a match.  Advance to next char.  - FM
		     */
		    tmpchptr++;
		    tmptarptr++;
		    if (count_gcells)
			tarlen++;
		    if (*tmptarptr == '\0') {
			/*
			 * One character match.  - FM
			 */
			if (nstartp)
			    *nstartp = offset;
			if (nendp)
			    *nendp = len + tarlen;
			return (chptr);
a5831 9
		} else {
		    /*
		     * It's not a match, so go back to seeking a first target
		     * match.  - FM
		     */
		    chptr++;
		    if (count_gcells)
			len++;
		    continue;
d5833 15
a5847 15
	    }
	    /*
	     * See if the rest of the target matches.  - FM
	     */
	    while (1) {
		if (!IsSpecialAttrChar(*tmpchptr)) {
		    if (!utf_flag && IS_CJK_TTY && is8bits(*tmpchptr)) {
			if (*tmpchptr == *tmptarptr &&
			    *(tmpchptr + 1) == *(tmptarptr + 1) &&
			    !IsSpecialAttrChar(*(tmpchptr + 1))) {
			    tmpchptr++;
			    tmptarptr++;
			    if (count_gcells)
				tarlen++;
			} else {
d5850 8
a5857 2
		    } else if ((*tmpchptr) != (*tmptarptr)) {
			break;
d5860 7
a5866 2
		    if (!IS_UTF_EXTRA(*tmptarptr)) {
			tarlen++;
d5868 2
a5869 4
		    tmpchptr++;
		    tmptarptr++;
		} else {
		    tmpchptr++;
d5871 7
a5877 7

		if (*tmptarptr == '\0') {
		    if (nstartp)
			*nstartp = offset;
		    if (nendp)
			*nendp = len + tarlen;
		    return (chptr);
d5879 1
a5879 10
		if (*tmpchptr == '\0')
		    break;
	    }
	} else if (!(IS_UTF_EXTRA(*chptr) ||
		     IsSpecialAttrChar(*chptr))) {
	    if (!utf_flag && IS_CJK_TTY && is8bits(*chptr) &&
		IsNormalChar(*(chptr + 1))) {
		chptr++;
		if (count_gcells)
		    len++;
a5880 1
	    len++;
d5882 2
a5883 3
    }				/* end for */

    return (NULL);
d5887 2
a5888 1
 * Allocate a new copy of a string, and returns it.
d5890 3
a5892 3
char *SNACopy(char **dest,
	      const char *src,
	      int n)
d5894 3
a5896 3
    FREE(*dest);
    if (src) {
	*dest = typeMallocn(char, (unsigned) n + 1);
d5898 2
a5899 2
	if (*dest == NULL) {
	    CTRACE((tfp, "Tried to malloc %d bytes\n", n));
d5901 1
d5903 1
a5903 2
	strncpy(*dest, src, (unsigned) n);
	*(*dest + n) = '\0';	/* terminate */
d5905 1
a5905 1
    return *dest;
d5909 2
a5910 1
 * String Allocate and Concatenate.
d5912 3
a5914 3
char *SNACat(char **dest,
	     const char *src,
	     int n)
d5916 5
a5920 3
    if (non_empty(src)) {
	if (*dest) {
	    int length = (int) strlen(*dest);
d5922 1
a5922 2
	    *dest = (char *) realloc(*dest, (unsigned) (length + n + 1));
	    if (*dest == NULL)
d5924 2
a5925 2
	    strncpy(*dest + length, src, (unsigned) n);
	    *(*dest + length + n) = '\0';	/* terminate */
d5927 1
a5927 1
	    *dest = typeMallocn(char, (unsigned) n + 1);
d5929 1
a5929 1
	    if (*dest == NULL)
d5931 3
a5933 2
	    memcpy(*dest, src, (unsigned) n);
	    (*dest)[n] = '\0';	/* terminate */
d5936 1
a5936 1
    return *dest;
d5949 1
d5951 1
a5951 12
    /*
     * Make check for sure.
     */
    if (upper <= 0)
	return (upper);

    /*
     * Try unicode_to_lower_case[].
     */
    low = 0;
    high = TABLESIZE(unicode_to_lower_case);
    while (low < high) {
d5953 1
a5953 1
	 * Binary search.
d5955 17
a5971 8
	i = (low + (high - low) / 2);
	diff = (unicode_to_lower_case[i].upper - upper);
	if (diff < 0)
	    low = i + 1;
	if (diff > 0)
	    high = i;
	if (diff == 0)
	    return (unicode_to_lower_case[i].lower);
d5974 1
a5974 1
    return (upper);		/* if we came here */
d5992 17
a6008 18
    /* if they are the same or one is a null characters return immediately. */
    if (ch1 == ch2)
	return 0;
    if (!ch2)
	return UCH(ch1);
    else if (!ch1)
	return -UCH(ch2);

    /* case-insensitive match for us-ascii */
    if (UCH(TOASCII(ch1)) < 128 && UCH(TOASCII(ch2)) < 128)
	return (TOUPPER(ch1) - TOUPPER(ch2));

    /* case-insensitive match for upper half */
    if (UCH(TOASCII(ch1)) > 127 &&	/* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127) {
	if (DisplayCharsetMatchLocale)
	    return (TOUPPER(ch1) - TOUPPER(ch2));	/* old-style */
	else {
d6012 6
a6017 4
	    if (uni_ch2 < 0)
		return UCH(ch1);
	    uni_ch1 = UCTransToUni((char) ch1, current_char_set);
	    return (UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d6019 2
d6023 1
a6023 1
    return (-10);		/* mismatch, if we come to here */
d6031 1
a6031 1
char *LYSafeGets(char **src,
d6037 2
a6038 2
    if (src != 0)
	result = *src;
d6042 1
a6042 1
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
d6045 1
a6045 1
	if (strchr(buffer, '\n') != 0)
d6057 2
a6058 2
    if (src != 0)
	*src = result;
d6062 1
a6062 1
#ifdef EXP_CMD_LOGGING
a6105 1
	unsigned len;
d6111 1
a6111 1
	    switch (len = (unsigned) (tmp - src)) {
d6114 1
a6114 1
		    exit_immediately(0);
d6131 7
a6137 2
		    CTRACE((tfp, "LYSetConfigValue(%s, %s)\n", src, tmp));
		    LYSetConfigValue(src, tmp);
d6183 1
a6183 1
#endif /* EXP_CMD_LOGGING */
@


1.8
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d50 6
d129 2
a130 2
	&& (MOUSE_X_POS >= getbegx(win)
	    && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
d181 1
d185 3
a187 3
    if ((event.bstate & (BUTTON1_CLICKED
			 | BUTTON1_DOUBLE_CLICKED
			 | BUTTON1_TRIPLE_CLICKED))) {
d191 3
a193 2
	if ((event.x < getbegx(win) || event.x >= (getbegx(win) + getmaxx(win)))
	    && !(event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)))
d204 2
a205 2
	    if (event.bstate & (BUTTON1_DOUBLE_CLICKED
				| BUTTON1_TRIPLE_CLICKED))
d218 2
a219 2
	    if (event.bstate & (BUTTON1_DOUBLE_CLICKED
				| BUTTON1_TRIPLE_CLICKED))
d236 1
a236 1
	} else if (event.bstate & (BUTTON_ALT | BUTTON_SHIFT | BUTTON_CTRL)) {
d482 1
a482 1
		    len = strlen(text);
d491 1
a491 1
					   strlen(text));
d581 1
a581 1
    len = strlen(src);
d586 1
a586 1
    val = strncpy(dst, src, n);
d632 1
a632 1
 * LYmbcs_skip_glyphs() skips a given number of display positions in a string
d645 14
a658 9
    if (!data)
	return NULL;
    if (!utf_flag)
	return (data + n_glyphs);

    while (*data) {
	if (IS_NEW_GLYPH(*data)) {
	    if (i_glyphs++ >= n_glyphs) {
		return data;
a660 1
	data++;
d666 20
d717 1
a717 1
		    } else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
d767 1
d1063 1
a1063 1
	**result = value;
d1070 4
a1073 1
static int expand_substring(char *dst, const char *first, const char *last, char *final)
d1090 1
a1090 1
		first = expand_tiname(first, s - first, &dst, final);
d1092 1
a1092 1
		    return 0;
d1098 1
a1098 1
		*dst++ = (ch & 0x1f);
d1108 1
a1108 1
	    *dst++ = ch;
d1113 1
a1113 1
    return 1;
d1138 1
a1138 1
	    dst[0] = keysym;
d1163 1
a1163 1
		strncpy(buf, str + 4, other - str - 4);
d1271 2
d1279 1
a1279 1
    CTRACE((tfp, "KEYMAP(PA): in=%s", parse));	/* \n-terminated */
d1285 1
a1285 1
		CTRACE((tfp, "KEYMAP(SKIP) no key expansion found\n"));
d1292 1
a1292 1
		    CTRACE((tfp, "KEYMAP(SKIP) could unescape key\n"));
d1296 1
a1296 1
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x\n", keysym));
d1298 2
a1299 1
		    CTRACE((tfp, "KEYMAP(DEF) keysym=%#x, seq='%s'\n", keysym, buf));
d1303 1
a1303 1
		CTRACE((tfp, "KEYMAP(SKIP) could not map to keysym\n"));
d1306 1
a1306 1
	    CTRACE((tfp, "KEYMAP(SKIP) junk after key description: '%s'\n", s));
d1309 1
a1309 1
	CTRACE((tfp, "KEYMAP(SKIP) no key description\n"));
d1313 1
d1525 3
d1594 3
d1715 1
d1768 1
a1768 1
		LYCursesON ? "on" : "off", stdin, LYNoZapKey));
d1931 1
a1931 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1938 1
a1938 1
		if ((d = GetChar()) == '~')	/* VTxxx Insert */
d1942 1
a1942 1
			 GetChar() == '~') {
d1953 1
a1953 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1959 1
a1959 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1965 1
a1965 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1971 1
a1971 1
	    if (found_CSI(c, b) && (d = GetChar()) == '~')
d1995 1
a1995 1
	if (isdigit(a) && found_CSI(c, b) && d != -1 && d != '~')
d2044 1
a2044 1
#if defined(SH_EX) && defined(DOSPATH)	/* for NEC PC-9800 1998/08/30 (Sun) 21:50:35 */
d2063 1
a2063 1
#endif /* SH_EX */
d2312 7
d2772 1
a2772 1
    len = strlen(buff);
d2840 1
a2840 1
 * Shorthand to get rid of all most of the "edit->suchandsos".
d2842 4
d2847 2
a2848 2
#define Pos	 edit->pos
#define StrLen	 edit->strlen
d2851 1
a2851 1
#define DspStart edit->xpan
d2853 2
d2860 1
a2860 1
static char killbuffer[1024] = "\0";
d2870 4
a2873 4
    LYGetYX(edit->sy, edit->sx);
    edit->pad = ' ';
    edit->dirty = TRUE;
    edit->panon = FALSE;
d2879 1
a2879 1
    Pos = strlen(old);
d2887 1
a2887 1
	    edit->panon = TRUE;
d2899 2
a2900 2
    LYstrncpy(edit->buffer, old, maxstr);
    StrLen = strlen(edit->buffer);
d2905 19
a2923 1
static int prev_pos(EDREC * edit, int pos)
d2925 2
a2926 1
    int i = 0;
d2928 31
a2958 11
    if (pos <= 0)
	return 0;
    if (HTCJK == NOCJK)
	return (pos - 1);
    else {
	while (i < pos - 1) {
	    int c;

	    c = Buf[i];
	    if (is8bits(c) &&
		!((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
d2960 25
a2984 2
	    }
	    i++;
a2985 4
	if (i == pos)
	    return (i - 2);
	else
	    return i;
d2987 5
d2993 1
d3008 1
a3008 1
    int length = strlen(Buf);
d3029 1
a3029 1
    if (map && LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
d3038 1
a3038 1
	    utfbuf[0] = *s;
d3044 1
a3044 1
			l = strlen(utfbuf);
d3059 1
a3059 1
		    utfbuf[0] = UCH(ucode);
d3061 1
a3061 1
	    strncpy(Buf + off, utfbuf, l);
d3091 1
a3091 1
	strncpy(Buf + Pos, (const char *) s, len);
d3099 1
a3099 1
	edit->dirty = TRUE;
d3113 4
d3120 1
a3120 4
{				/* returns 0    character processed
				 *         -ch  if action should be performed outside of line-editing mode
				 *         ch   otherwise
				 */
d3124 1
d3129 1
a3129 1
    length = strlen(&Buf[0]);
d3149 1
a3149 1
	if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
d3183 1
a3183 1
	    Buf[Pos] = UCH(ch);
a3193 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d3198 2
a3199 1
	while (Pos && !isalnum(Buf[Pos - 1]))
d3201 1
a3201 1
	while (Pos && isalnum(Buf[Pos - 1]))
d3203 6
a3208 31
#else /* SUPPORT_MULTIBYTE_EDIT */
	/*
	 * Backword.
	 * Definition of word is very naive:  1 or more a/n characters, or 1 or
	 * more multibyte character.
	 */
	{
	    int pos0;

	    pos0 = prev_pos(edit, Pos);
	    while (Pos &&
		   (HTCJK == NOCJK || !is8bits(Buf[pos0])) &&
		   !isalnum(UCH(Buf[pos0]))) {
		Pos = pos0;
		pos0 = prev_pos(edit, Pos);
	    }
	    if (HTCJK != NOCJK && is8bits(Buf[pos0])) {
		while (Pos && is8bits(Buf[pos0])) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    } else {
		while (Pos
		       && !is8bits(Buf[pos0])
		       && isalnum(UCH(Buf[pos0]))) {
		    Pos = pos0;
		    pos0 = prev_pos(edit, Pos);
		}
	    }
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
d3216 1
a3216 1
	while (isalnum(Buf[Pos]))
d3218 1
a3218 1
	while (!isalnum(Buf[Pos]) && Buf[Pos])
d3220 4
a3223 10
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK && is8bits(Buf[Pos])) {
	    while (is8bits(Buf[Pos]))
		Pos += 2;
	} else {
	    while (!is8bits(Buf[Pos]) && isalnum(Buf[Pos]))
		Pos++;		/* '\0' is not a/n */
	}
	while ((HTCJK == NOCJK || !is8bits(Buf[Pos])) &&
	       !isalnum(UCH(Buf[Pos])) && Buf[Pos])
d3225 1
a3225 1
#endif /* SUPPORT_MULTIBYTE_EDIT */
d3256 4
a3259 2
	{
	    int pos0 = Pos;
d3261 1
a3261 5
	    LYEdit1(edit, 0, LYE_FORWW, FALSE);
	    while (Pos > pos0)
		LYEdit1(edit, 0, LYE_DELP, FALSE);
	}
	break;
d3267 15
a3281 2
	{
	    int pos0 = Pos;
a3282 5
	    LYEdit1(edit, 0, LYE_BACKW, FALSE);
	    pos0 -= Pos;
	    while (pos0--)
		LYEdit1(edit, 0, LYE_DELN, FALSE);
	}
d3289 2
a3290 2
	{
	    int pos0 = Pos;
d3292 9
a3300 3
	    while (pos0--)
		LYEdit1(edit, 0, LYE_DELP, FALSE);
	}
d3307 7
a3313 8
	{
	    int pos0 = Pos;

	    LYEdit1(edit, 0, LYE_EOL, FALSE);
	    pos0 = Pos - pos0;
	    while (pos0--)
		LYEdit1(edit, 0, LYE_DELP, FALSE);
	}
d3323 4
a3326 3
#ifdef SUPPORT_MULTIBYTE_EDIT
	if (HTCJK != NOCJK && is8bits(Buf[Pos]))
	    Pos++;
a3327 1
	Pos++;
a3333 1
#ifndef SUPPORT_MULTIBYTE_EDIT
d3336 2
a3346 1
	i--;
d3348 4
a3351 3
	{
	    int offset = 1;
	    int pos0 = Pos;
a3352 10
	    if (length == 0 || Pos == 0)
		break;
	    if (HTCJK != NOCJK) {
		Pos = prev_pos(edit, pos0);
		offset = pos0 - Pos;
	    } else
		Pos--;
	    for (i = Pos; i < length; i++)
		Buf[i] = Buf[i + offset];
	    i -= offset;
d3354 4
a3357 4
	    if (Mark >= 0)
		Mark = -1 - Mark;	/* Disable it */
	    if (Mark <= -1 - Pos)
		Mark += offset;
d3359 1
a3359 1
	}
a3360 1
	Buf[i] = 0;
d3371 4
a3374 7
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos < length) {
	    Pos++;
	    if (HTCJK != NOCJK && is8bits(Buf[Pos - 1]))
		Pos++;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
d3387 4
a3390 8
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (Pos > 0) {
	    if (HTCJK != NOCJK)
		Pos = prev_pos(edit, Pos);
	    else
		Pos--;
	}
#endif /* SUPPORT_MULTIBYTE_EDIT */
d3400 6
d3479 1
a3479 1
	    int yanklen = strlen(killbuffer);
d3487 1
a3487 1
		    Buf[Pos++] = UCH(killbuffer[i]);
d3508 2
a3509 2
    edit->dirty = TRUE;
    StrLen = strlen(&Buf[0]);
d3586 33
d3621 20
a3641 2
    int length;
    int nrdisplayed;
d3644 2
a3645 1
    char buffer[3];
a3646 4
#ifdef SUPPORT_MULTIBYTE_EDIT
    int begin_multi = 0;
    int end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d3648 1
a3648 1
    int estyle, prompting = 0;
d3650 1
d3652 6
a3657 2
    buffer[0] = buffer[1] = buffer[2] = '\0';
    if (!edit->dirty || (DspWdth == 0))
a3658 1
    edit->dirty = FALSE;
d3660 14
a3673 2
    length = strlen(&Buf[0]);
    edit->strlen = length;
d3680 1
a3680 1
     *      0         DspStart                   length
a3688 7
    if ((DspStart + DspWdth) <= length) {
	if (Pos >= (DspStart + DspWdth) - Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	    DspStart = (Pos - DspWdth) + Margin;
#else /* SUPPORT_MULTIBYTE_EDIT */
	    if (HTCJK != NOCJK) {
		int tmp = (Pos - DspWdth) + Margin;
d3690 11
a3700 8
		while (DspStart < tmp) {
		    if (is8bits(Buf[DspStart]))
			DspStart++;
		    DspStart++;
		}
	    } else {
		DspStart = (Pos - DspWdth) + Margin;
	    }
d3705 9
a3713 20
    if (Pos < DspStart + Margin) {
#ifndef SUPPORT_MULTIBYTE_EDIT
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
#else /* SUPPORT_MULTIBYTE_EDIT */
	if (HTCJK != NOCJK) {
	    int tmp = Pos - Margin;

	    DspStart = 0;
	    while (DspStart < tmp) {
		if (is8bits(Buf[DspStart]))
		    DspStart++;
		DspStart++;
	    }
	} else {
	    DspStart = Pos - Margin;
	    if (DspStart < 0)
		DspStart = 0;
	}
d3717 27
a3743 1
    str = &Buf[DspStart];
d3745 4
a3748 2
    if (HTCJK != NOCJK && is8bits(str[0]))
	begin_multi = 1;
d3750 7
d3758 19
a3776 3
    nrdisplayed = length - DspStart;
    if (nrdisplayed > DspWdth)
	nrdisplayed = DspWdth;
a3777 1
    LYmove(edit->sy, edit->sx);
d3784 1
a3784 1
    if (edit->sy == (LYlines - 1))
d3786 1
a3786 1
    if (prompting)
d3788 1
a3788 1
    else
d3790 1
d3794 1
a3794 1
    if (estyle != NOSTYLE)
d3796 1
a3796 1
    else
d3798 1
d3800 18
a3817 3
    if (edit->hidden) {
	for (i = 0; i < nrdisplayed; i++)
	    LYaddch('*');
d3823 2
a3824 1
	for (i = 0; i < nrdisplayed; i++) {
d3833 3
a3835 3
	    if ((buffer[0] = str[i]) == 1 || buffer[0] == 2 ||
		(UCH(buffer[0]) == 160 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK ||
d3840 10
a3849 3
#ifdef SUPPORT_MULTIBYTE_EDIT
		end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
d3851 1
a3851 26
		/* For CJK strings, by Masanobu Kimura */
		if (HTCJK != NOCJK && is8bits(buffer[0])) {
		    if (i < (nrdisplayed - 1))
			buffer[1] = str[++i];
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = (i < nrdisplayed);
#if !(defined(USE_SLANG) || defined(WIDEC_CURSES))
		    {
			int ii, yy, xx;

			LYGetYX(yy, xx);
			for (ii = 0; buffer[ii] != '\0'; ++ii)
			    LYaddch(' ');
			LYrefresh();
			LYmove(yy, xx);
		    }
#endif /* USE_SLANG */
#endif /* SUPPORT_MULTIBYTE_EDIT */
		    LYaddstr(buffer);
		    buffer[1] = '\0';
		} else {
		    LYaddstr(buffer);
#ifdef SUPPORT_MULTIBYTE_EDIT
		    end_multi = 0;
#endif /* SUPPORT_MULTIBYTE_EDIT */
		}
d3853 1
d3857 3
a3859 3
	    ((DspStart + nrdisplayed <= Mark && DspStart + nrdisplayed > Pos)
	     || (DspStart + nrdisplayed > Mark
		 && DspStart + nrdisplayed <= Pos)))
d3861 1
d3868 2
a3869 7
    padsize = DspWdth - nrdisplayed;
    if (padsize) {
	TmpStyleOn(prompting ? s_prompt_edit_pad : s_aedit_pad);
	while (padsize--)
	    LYaddch(UCH(edit->pad));
	TmpStyleOff(prompting ? s_prompt_edit_pad : s_aedit_pad);
    }
d3874 7
a3880 25
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    int add_space = 0;

	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (end_multi)
		add_space = 1;
#endif
	    LYmove(edit->sy, edit->sx + nrdisplayed - 1 - add_space);
	    if (add_space)
		LYaddch(' ');	/* Needed with styles? */
	    LYaddch(ACS_RARROW);
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
	if (DspStart) {
	    TmpStyleOn(prompting ? s_prompt_edit_arr : s_aedit_arr);
	    LYmove(edit->sy, edit->sx);
	    LYaddch(ACS_LARROW);
#ifdef SUPPORT_MULTIBYTE_EDIT
	    if (begin_multi)
		LYaddch(' ');	/* Needed with styles? */
#endif /* SUPPORT_MULTIBYTE_EDIT */
	    TmpStyleOff(prompting ? s_prompt_edit_arr : s_aedit_arr);
	}
d3883 4
a3886 1
    LYmove(edit->sy, edit->sx + Pos - DspStart);
d3920 1
a3920 1
    unsigned count = HTList_count(list);
d3971 1
a3971 1
	check = strlen(*list++);
d4000 4
a4003 2
	if (strlen(list[count]) > width) {
	    width = strlen(list[count]);
d4070 1
a4070 2
		      BOOLEAN for_mouse,
		      BOOLEAN numbered)
d4072 1
d4129 1
a4129 1
	width = options_width(choices);
d4132 1
a4132 1
	Lnum = strlen(Cnum);
a4260 2
    LYmove((LYlines - 2), 0);
    LYclrtoeol();
d5012 3
a5014 2
    MaxStringSize = (bufsize < sizeof(MyEdit.buffer)) ?
	(bufsize - 1) : (sizeof(MyEdit.buffer) - 1);
d5115 1
a5115 2
						   FALSE,
						   TRUE);
d5138 1
a5138 1
		(HTCJK != NOCJK ||
d5165 1
a5165 1
		len = strlen((const char *) s);
d5247 1
a5247 1
		if (refresh_mb && HTCJK != NOCJK && (0x81 <= ch) && (ch <= 0xfe))
d5276 1
a5276 1
	 sizeof(helpbuf) - (phelp - helpbuf))) {
d5278 1
a5278 1
		  sizeof(helpbuf) - (phelp - helpbuf) - 1);
d5286 75
d5390 1
a5390 1
    int len = strlen(tarptr);
d5554 1
a5554 1
	if ((!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d5579 1
a5579 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d5619 1
a5619 1
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
d5656 1
a5656 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d5739 1
a5739 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d5778 1
a5778 1
		    if (!utf_flag && HTCJK != NOCJK && is8bits(*tmpchptr)) {
d5814 1
a5814 1
	    if (!utf_flag && HTCJK != NOCJK && is8bits(*chptr) &&
d5836 1
a5836 1
	*dest = typeMallocn(char, n + 1);
d5842 1
a5842 1
	strncpy(*dest, src, n);
d5857 1
a5857 1
	    int length = strlen(*dest);
d5859 1
a5859 1
	    *dest = (char *) realloc(*dest, length + n + 1);
d5862 1
a5862 1
	    strncpy(*dest + length, src, n);
d5865 1
a5865 1
	    *dest = typeMallocn(char, n + 1);
d5869 1
a5869 1
	    memcpy(*dest, src, n);
d6047 1
a6047 1
	    switch (len = (tmp - src)) {
@


1.7
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d59 9
a67 9
** simple to do.  Once you've determined the X and Y coordinates of
** the mouse event, loop through the elements in the links[] array and
** see if the coordinates fall within a highlighted link area.	If so,
** the code must set mouse_link to the index of the chosen link,
** and return a key value that corresponds to LYK_ACTIVATE.  The
** LYK_ACTIVATE code in LYMainLoop.c will then check mouse_link
** and activate that link.  If the mouse event didn't fall within a
** link, the code should just set mouse_link to -1 and return -1. --AMK
**/
d79 1
a79 1
PUBLIC int peek_mouse_levent NOARGS
d92 1
a92 1
PUBLIC int get_mouse_link NOARGS
d95 1
d104 1
a104 1
PUBLIC int peek_mouse_link NOARGS
d109 2
a110 5

PUBLIC int fancy_mouse ARGS3(
    WINDOW *,	win,
    int,	row,
    int *,	position)
d113 1
d122 2
a123 2
      && (MOUSE_X_POS >= getbegx(win)
      && (MOUSE_X_POS < (getbegx(win) + getmaxx(win))))) {
d127 1
a127 1
	if (mypos+1 == getmaxy(win)) {
d174 1
a174 1
    MEVENT	event;
d178 2
a179 2
			      | BUTTON1_DOUBLE_CLICKED
			      | BUTTON1_TRIPLE_CLICKED))) {
d186 1
a186 1
	if (mypos+1 == getmaxy(win)) {
d196 1
a196 1
			      | BUTTON1_TRIPLE_CLICKED))
d210 1
a210 1
			      | BUTTON1_TRIPLE_CLICKED))
d249 5
a253 1
#endif  /* USE_MOUSE */
d260 1
a260 2
PRIVATE HTList *whichRecall ARGS1(
    RecallType,		recall)
d282 1
a282 1
PRIVATE void LYRemoveFromCloset ARGS1(HTList *, list)
d284 1
a284 1
    char *data = HTList_removeFirstObject(list);
d290 1
a290 1
PUBLIC void LYCloseCloset ARGS1(RecallType, recall)
d294 1
a294 1
    while (!HTList_isEmpty(list) ) {
d305 1
a305 1
PRIVATE char * LYFindInCloset ARGS2(RecallType, recall, char*, base)
d312 1
a312 1
	data = HTList_nextObject(list);
d314 1
a314 1
	    return(data);
d317 1
a317 1
    return(0);
d320 1
a320 1
PRIVATE void LYAddToCloset ARGS2(RecallType, recall, char*, str)
d332 5
a336 6
PRIVATE int XYdist ARGS5(
    int,	x1,
    int,	y1,
    int,	x2,
    int,	y2,
    int,	dx2)
d341 1
a341 1
	xerr = 3 * (x1 - x2 - dx2) + 1;	/* pos after string not really in it */
d347 2
a348 2
	return (xerr > 0) ? (xerr*2 - 1) : 0;
    if (xerr < 9 && yerr)   /* x-dist of 3 cell better than y-dist of 1 cell */
d350 1
a350 1
    return 2 * xerr + yerr; /* Subjective factor; ratio -> approx. 6 / 9 */
d367 10
a376 11
** index of the corresponding hyperlink, or set mouse_link to -1 if no
** link matches the event.  Returns -1 if no link matched the click,
** or a keycode that must be returned from LYgetch() to activate the
** link.
**/

PRIVATE int set_clicked_link ARGS4(
    int,	x,
    int,	y,
    int,	code,
    int,	clicks)
d379 2
a380 1
    int right = LYcols-6;
d385 1
a385 1
    if (y == (LYlines-1) || y == 0) {	/* First or last row */
d390 1
a390 1
	if (x == 0 && toolbar)		/* On '#' */
d393 1
a393 1
	else if (y == 0 && x == LYcols - 1 && s_hot_paste != NOSTYLE)
d398 1
a398 1
		c = (code==FOR_PROMPT && y)
d401 1
a401 1
		c = (code==FOR_PROMPT && y)
d403 1
a403 1
	    else if (y)			/* Last row */
d405 1
a405 1
	    else			/* First row */
d409 1
a409 1
		c = (code==FOR_PROMPT && y)
d413 3
a415 3
			(s_forw_backw != NOSTYLE && x - toolbar >= 3)
			? LAC_TO_LKC0(LYK_NEXT_DOC)
			: LAC_TO_LKC0(LYK_PREV_DOC)
d417 1
a417 1
			LAC_TO_LKC0(LYK_NEXT_DOC)
d419 1
a419 1
			);
d421 1
a421 1
		c = (code==FOR_PROMPT && y)
d423 1
a423 1
	    else if (y)			/* Last row */
d425 1
a425 1
	    else			/* First row */
d429 2
a430 2
    } else if (x == LYcols - 1 && LYShowScrollbar && LYsb_begin >= 0) {
	int h = display_lines - 2*(LYsb_arrow != 0);
d440 1
a440 1
	    double frac = (1. * y)/(h - 1);
d445 1
a445 1
		LYSetNewline((int)(frac * l + 1 + 0.5));
d453 1
a453 1
	mouse_link = -1;		/* No action in edit fields */
d456 1
a456 2
	int mouse_err = 29, /* subjctv-dist better than this for approx stuff */
	    cur_err;
d462 1
a462 1
	    char *text = LYGetHiliteStr(i, count);
d477 1
a477 1
		   && (text = LYGetHiliteStr(i, ++count)) != NULL) {
d483 1
d492 1
a492 1
		    LYGetYX(cury,curx);
d498 1
a498 1
			    /* submit current input field directly */
d510 1
a510 1
			/* Do not pick up the current input field */
d541 12
a552 13
	}
	else {
	   if (2*y > LYlines){		/* Bottom Half of the screen */
	      if (4*y < 3*LYlines){
		c = LAC_TO_LKC0(LYK_DOWN_TWO);	/* Third quarter */
	      } else
		c = LAC_TO_LKC0(LYK_DOWN_HALF);	/* Fourth quarter */
	   } else {			/* Upper Half of the screen */
	      if (4*y < LYlines){
		c = LAC_TO_LKC0(LYK_UP_HALF);	/* First quarter */
	      } else
		c = LAC_TO_LKC0(LYK_UP_TWO);	/* Second quarter */
	   }
d560 2
a561 2
 *  LYstrncpy() terminates strings with a null byte.
 *  Writes a null byte into the n+1 byte of dst.
d563 3
a565 4
PUBLIC char *LYstrncpy ARGS3(
	char *,		dst,
	CONST char *,	src,
	int,		n)
d579 1
a579 1
	*(dst+len) = '\0';
d581 1
a581 1
	*(dst+n) = '\0';
d589 10
a598 12
 *  LYmbcsstrncpy() terminates strings with a null byte.
 *  It takes account of multibyte characters.
 *  The src string is copied until either end of string or max number of
 *  either bytes or glyphs (mbcs sequences) (CJK or UTF8).  The utf_flag
 *  argument should be TRUE for UTF8. - KW & FM
 */
PUBLIC char * LYmbcsstrncpy ARGS5(
	char *,		dst,
	CONST char *,	src,
	int,		n_bytes,
	int,		n_glyphs,
	BOOL,		utf_flag)
d623 7
a629 8
 *  LYmbcs_skip_glyphs() skips a given number of display positions
 *  in a string and returns the resulting pointer.  It takes account
 *  of UTF-8 encoded characters. - KW
 */
PUBLIC char * LYmbcs_skip_glyphs ARGS3(
	char *,		data,
	int,		n_glyphs,
	BOOL,		utf_flag)
d653 10
a662 12
 *  LYmbcsstrlen() returns the printable length of a string
 *  that might contain IsSpecial or multibyte (CJK or UTF8)
 *  characters. - FM
 *  Counts glyph cells if count_gcells is set. (Full-width
 *  characters in CJK mode count as two.)
 *  Counts character glyphs if count_gcells is unset. (Full-
 *  width characters in CJK mode count as one.) - kw
 */
PUBLIC int LYmbcsstrlen ARGS3(
	char *,		str,
	BOOL,		utf_flag,
	BOOL,		count_gcells)
d666 24
a689 17
    if (!non_empty(str))
	return(len);

    for (i = 0; str[i] != '\0'; i++) {
	if (IsSpecialAttrChar(str[i])) {
	    continue;
	} else {
	    len++;
	}
	if (IS_NEW_GLYPH(str[i])) {
	    j = 0;
	    while (str[(i + 1)] != '\0' &&
		   !IsSpecialAttrChar(str[(i + 1)]) &&
		   j < 5 &&
		   IS_UTF_EXTRA(str[(i + 1)])) {
		i++;
		j++;
a690 4
	} else if (!utf_flag && HTCJK != NOCJK && !count_gcells &&
		   is8bits(str[i]) && str[(i + 1)] != '\0' &&
		    !IsSpecialAttrChar(str[(i + 1)])) {
	    i++;
d693 1
a693 2

    return(len);
d699 1
a699 1
#ifdef VMS
d701 3
a703 9
#else
#ifdef __DJGPP__
#ifdef DJGPP_KEYHANDLER
#define GetChar getxkey
#else
#define GetChar SLkp_getkey
#endif /* DJGPP_KEYHANDLER */
#else
#ifdef __CYGWIN__
d707 29
a735 4
#endif /* __CYGWIN__ */
#endif /* __DJGPP__ */
#endif /* VMS */
#endif /* USE_SLANG */
d737 4
a740 2
#if !defined(GetChar) && defined(NCURSES)
#define GetChar() wgetch(LYtopwindow())
d747 1
a747 1
PRIVATE int myGetChar NOARGS
d753 8
a760 9
	switch (c = wgetch(LYwin))
	{
	case KEY_SHIFT_L :
	case KEY_SHIFT_R :
	case KEY_CONTROL_L :
	case KEY_CONTROL_R :
	case KEY_ALT_L :
	case KEY_ALT_R :
	case KEY_RESIZE :
d767 1
d788 1
a788 1
#define GetChar() getchar()  /* used to be "getc(stdin)" and "getch()" */
d793 1
a793 1
PRIVATE int sl_parse_mouse_event ARGS3(int *, x, int *, y, int *, button)
d798 2
a799 3
    *button = SLang_getkey ();
    switch (*button)
    {
d807 1
a807 1
	SLang_flush_input ();
d811 1
a811 1
    *x = SLang_getkey ();
d813 1
a813 1
	*x = SLang_getkey () + 64 - 33;
d816 1
a816 1
    *y = SLang_getkey ();
d818 1
a818 1
	*y = SLang_getkey () + 64 - 33;
d824 1
a824 2
PRIVATE int sl_read_mouse_event ARGS1(
    int,	code)
d826 25
a850 1
   int mouse_x, mouse_y, button;
d852 2
a853 29
   mouse_link = -1;
   if (-1 != sl_parse_mouse_event (&mouse_x, &mouse_y, &button))
     {
	if (button == 0)  /* left */
	  return set_clicked_link (mouse_x, mouse_y, FOR_PANEL, 1);

	if (button == 1)  /* middle */
	  return LYReverseKeymap (LYK_VIEW_BOOKMARK);

	if (button == 2)   /* right */
	  {
	     /* Right button: go back to prev document.
	      * The problem is that we need to determine
	      * what to return to achieve this.
	      */
	     return LYReverseKeymap (LYK_PREV_DOC);
	  }
     }
   if (code == FOR_INPUT || code == FOR_PROMPT)
       return DO_NOTHING;
   else
       return -1;
}
#endif  /* USE_SLANG and USE_MOUSE */


PRIVATE BOOLEAN csi_is_csi = TRUE;
PUBLIC void ena_csi ARGS1(
    BOOLEAN,	flag)
d862 11
a872 1
	SLkm_define_keysym (string, code, Keymap_List)
d874 3
a876 1
	(SLexpand_escaped_string(dst, (char *)first, (char *)last), 1)
d878 1
d905 5
a909 8

typedef struct
{
   char *string;
   int value;
}
Keysym_String_List;

d929 1
d936 1
a936 1
PRIVATE int lookup_tiname (char *name, NCURSES_CONST char *CONST *names)
d946 1
a946 1
PRIVATE CONST char *expand_tiname (CONST char *first, size_t len, char **result, char *final)
d954 1
a954 1
     || (code = lookup_tiname(name, strfnames)) >= 0) {
d963 1
a963 1
PRIVATE CONST char *expand_tichar (CONST char *first, char **result, char *final)
d969 1
a969 1
    char *name = 0;
d972 33
a1004 10
    case 'E': case 'e':	value = 27;			break;
    case 'a':		name  = "bel";			break;
    case 'b':		value = '\b';			break;
    case 'f':		value = '\f';			break;
    case 'n':		value = '\n';			break;
    case 'r':		value = '\r';			break;
    case 't':		value = '\t';			break;
    case 'v':		value = '\v';			break;
    case 'd':		radix = 10;	limit = 3;	break;
    case 'x':		radix = 16;	limit = 2;	break;
d1019 1
d1036 1
a1036 1
PRIVATE int expand_substring (char* dst, CONST char* first, CONST char* last, char *final)
d1048 1
a1048 1
		CONST char *s = strchr(first, RPAREN);
d1050 1
d1053 1
a1053 1
		first = expand_tiname(first, s-first, &dst, final);
d1058 1
a1058 1
	    } else if (ch == '?') {		/* ASCII delete? */
d1067 1
a1067 1
	case 0:					/* convert nulls for terminfo */
d1080 1
a1080 1
PRIVATE void unescaped_char ARGS2(CONST char*, parse, int*,keysym)
d1092 1
a1092 1
PRIVATE BOOLEAN unescape_string ARGS3(char*, src, char *, dst, char *, final)
d1097 2
a1098 1
	int keysym = 0;
d1105 1
a1105 1
    } else if (*src == DQUOTE)
d1107 2
d1112 1
a1112 1
PUBLIC int map_string_to_keysym ARGS2(CONST char*, str, int*,keysym)
d1115 1
d1119 1
a1119 1
	char *other = strchr(str+4, ':');
d1122 2
a1123 2
	   int othersym = lecname_to_lec(other + 1);
	   char buf[BUFSIZ];
d1125 1
a1125 1
	   if (othersym >= 0 && other - str - 4 < BUFSIZ ) {
d1133 1
a1133 1
	   }
d1146 11
a1156 9
	    if (len == 1)
		return (*keysym = (UCH(str[0]))|modifier);
	    else if (len == 2 && str[0] == '^' &&
		     (isalpha(UCH(str[1])) ||
		      (TOASCII(str[1]) >= '@@' && TOASCII(str[1]) <= '_')))
		return (*keysym = FROMASCII(UCH(str[1]&0x1f))|modifier);
	    else if (len == 2 && str[0] == '^' &&
		     str[1] == '?')
		return (*keysym = CH_DEL|modifier);
d1159 5
a1163 1
		expand_substring(buf, str, str + HTMIN(len, 28), buf + sizeof(buf) - 1);
d1165 1
a1165 1
		    return (*keysym = (UCH(buf[0]))|modifier);
d1174 1
d1179 1
a1179 1
		*keysym |= LKC_ISLKC; /* caller should remove this flag - kw */
d1187 1
a1187 1
	    if (0 == strcmp (k->string, str)) {
d1204 1
a1204 1
PRIVATE char *skip_keysym ARGS1(char *, parse)
d1234 1
a1234 1
PRIVATE int setkey_cmd (char *parse)
d1251 1
a1251 1
	    if (map_string_to_keysym (s, &keysym) >= 0) {
d1254 1
a1254 1
		    return 0;		/* Trace the failure and continue. */
d1262 1
a1262 2
	    }
	    else {
d1265 1
a1265 2
	}
	else {
d1268 1
a1268 2
    }
    else {
d1274 1
a1274 1
PRIVATE int unsetkey_cmd (char *parse)
d1277 1
d1287 3
a1289 2
	    if (map_string_to_keysym (parse, &keysym) >= 0)
		define_key((char *)0, keysym);
d1297 3
a1299 2
	SLang_undefine_key (parse, Keymap_List);
	if (SLang_Error) return -1;
d1311 1
a1311 1
PRIVATE int read_keymap_file NOARGS
d1313 1
d1315 2
a1316 2
	CONST char *name;
	int (*func) PARAMS((char *s));
d1318 2
a1319 2
	{"setkey",   setkey_cmd },
	{"unsetkey", unsetkey_cmd },
d1321 1
d1331 1
a1331 1
    if ((fp = fopen (file, "r")) == 0)
d1346 3
a1348 3
	    if ( strlen(s) > len && !strncmp(s, table[n].name, len)
		 && (*(table[n].func))(LYSkipBlanks(s+len)) < 0 )
		fprintf (stderr, FAILED_READING_KEYMAP, linenum, file);
d1352 1
a1352 1
    LYCloseInput (fp);
d1356 1
a1356 1
PRIVATE void setup_vtXXX_keymap NOARGS
d1358 1
d1381 1
a1381 1
#if defined(USE_SLANG) && defined(__MINGW32__)
d1410 2
d1413 1
d1418 1
a1418 1
PUBLIC int lynx_initialize_keymaps NOARGS
d1429 1
a1429 1
    if (NULL == (Keymap_List = SLang_create_keymap ("Lynx", NULL)))
d1433 1
a1433 2
    for (i = 1; i < 256; i++)
    {
d1435 1
a1435 1
	define_key (keybuf, i);
d1439 1
a1439 1
    define_key ("\033[M", MOUSE_KEYSYM);
d1441 2
a1442 2
    if (SLang_Error)
	SLang_exit_error ("Unable to initialize keymaps");
d1449 1
a1449 2
#endif				       /* USE_KEYMAPS */

d1452 1
a1452 1
PRIVATE int LYmouse_menu ARGS4(int, x, int, y, int, atlink, int, code)
d1456 1
d1458 1
a1458 1
	char *txt;
d1489 2
d1492 1
a1492 1
    char *choices[TOTAL_MENUENTRIES + 1];
d1509 2
a1510 2
    c = LYChoosePopup((atlink ? 2 : 10) - 1, y, (x > 5 ? x-5 : 1),
		     choices, c1, FALSE, TRUE);
d1513 4
a1516 5
     *  LYhandlePopupList() wasn't really meant to be used
     *  outside of old-style Options menu processing.  One result of
     *  mis-using it here is that we have to deal with side-effects
     *  regarding SIGINT signal handler and the term_options global
     *  variable. - kw
d1527 11
a1537 11
	    case LYK_ABORT:
		retlac = LYK_QUIT; /* a bit softer... */
		/* fall through */
	    case LYK_MAIN_MENU:
	    case LYK_PREV_DOC:
	    case LYK_HOME:
	    case LYK_PREV_PAGE:
	    case LYK_UP_HALF:
	    case LYK_UP_TWO:
	    case LYK_HISTORY:
	    case LYK_HELP:
d1539 14
a1552 14
	    case LYK_RELOAD:
	    case LYK_ECGOTO:
	    case LYK_INFO:
	    case LYK_WHEREIS:
	    case LYK_PRINT:
	    case LYK_DOWN_TWO:
	    case LYK_DOWN_HALF:
	    case LYK_NEXT_PAGE:
	    case LYK_END:
	    case LYK_VIEW_BOOKMARK:
	    case LYK_COOKIE_JAR:
	    case LYK_INDEX_SEARCH:
	    case LYK_OPTIONS:
		mouse_link = -3; /* so LYgetch_for() passes it on - kw */
a1565 1

d1569 1
a1569 1
PRIVATE int current_sl_modifier = 0;
d1572 1
a1572 1
PRIVATE int myGetChar NOARGS
d1575 1
d1581 1
a1581 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
d1583 48
a1630 25
   SLang_Key_Type *key;
   int keysym;
   current_sl_modifier = 0;

   key = SLang_do_key (Keymap_List, myGetChar);
   if ((key == NULL) || (key->type != SLKEY_F_KEYSYM)) {
#ifdef __MINGW32__
	   if ((key == NULL) && (current_sl_modifier == LKC_ISLKC)) {
		   key = SLang_do_key (Keymap_List, myGetChar);
		   keysym = key->f.keysym;
		   switch (keysym) {
			   case 'H': keysym = UPARROW; break;
			   case 'P': keysym = DNARROW; break;
			   case 'M': keysym = RTARROW; break;
			   case 'K': keysym = LTARROW; break;
			   case 'R': keysym = INSERT_KEY; break;
			   case 'S': keysym = REMOVE_KEY; break;
			   case 'I': keysym = PGUP; break;
			   case 'Q': keysym = PGDOWN; break;
			   case 'G': keysym = HOME; break;
			   case 'O': keysym = END_KEY; break;
			   case ';': keysym = F1; break;
		   }
		   return(keysym);
	   }
d1633 2
a1634 2
     return (current_sl_modifier ? 0 : DO_NOTHING);
   }
d1636 1
a1636 1
   keysym = key->f.keysym;
d1639 2
a1640 2
   if (keysym == MOUSE_KEYSYM)
     return sl_read_mouse_event (code);
d1643 2
a1644 2
   if (keysym < 0)
       return 0;
d1646 2
a1647 2
   if (keysym & (LKC_ISLECLAC|LKC_ISLAC))
       return (keysym);
d1649 5
a1653 5
   current_sl_modifier = 0;
   if (LKC_HAS_ESC_MOD(keysym)) {
       current_sl_modifier = LKC_MOD2;
       keysym &= LKC_MASK;
   }
d1655 2
a1656 2
   if (keysym+1 >= KEYMAP_SIZE)
     return 0;
d1658 1
a1658 1
   return (keysym|current_sl_modifier);
d1662 1
a1662 2
#else	/* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

d1665 1
a1665 1
 *  LYgetch() translates some escape sequences and may fake noecho.
d1669 1
a1669 2
PRIVATE int LYgetch_for ARGS1(
	int,	code)
d1675 2
d1679 2
a1680 2
re_read:
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
d1683 1
a1683 1
#endif  /* UCX && VAXC */
d1685 1
a1685 1
    clearerr(stdin); /* needed here for ultrix and SOCKETSHR, but why? - FM */
d1696 1
a1696 1
	if (c == EOF && errno == EINTR) /* Ctrl-Z causes EINTR in getchar() */
d1704 1
a1704 1
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1716 2
a1717 2
	    )) {
	int fd, kbd_fd;
d1722 5
a1726 27
	if ((fd = fileno(stdin)) == 0 && !isatty(fd) &&
	    (kbd_fd = LYConsoleInputFD(FALSE)) == fd) {
	    char *term_name;
	    int new_fd = INVSOC;
	    if ((term_name = ttyname(fileno(stdout))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC &&
		(term_name = ttyname(fileno(stderr))) != NULL)
		new_fd = open(term_name, O_RDONLY);
	    if (new_fd == INVSOC) {
		term_name = ctermid(NULL);
		new_fd = open(term_name, O_RDONLY);
	    }
	    CTRACE((tfp, "nozap: open(%s) returned %d.\n", term_name, new_fd));
	    if (new_fd >= 0) {
		FILE *frp;
		close(new_fd);
		frp = freopen(term_name, "r", stdin);
		CTRACE((tfp,
		"nozap: freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
			term_name, frp, stdin, fileno(stdin)));
		if (LYCursesON) {
		    stop_curses();
		    start_curses();
		    LYrefresh();
		}
		goto re_read;
d1728 1
d1740 6
a1745 6
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange so far is %d\n",
		  recent_sizechange));
	   if (!recent_sizechange) { /* not yet detected by ourselves */
	       size_change(0);
	       CTRACE((tfp, "Now recent_sizechange is %d\n", recent_sizechange));
	   }
d1747 2
a1748 2
	   CTRACE((tfp, "Got EOF with EINTR, recent_sizechange is %d\n",
		  recent_sizechange));
d1750 1
a1750 1
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ? */
d1752 2
a1753 2
#endif  /* UCX && VAXC */
	return(DO_NOTHING);
d1765 1
a1765 1
	return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1767 1
a1767 1
#else  /* not USE_SLANG: */
d1770 1
a1770 1
	    return(LYCharINTERRUPT2); /* use ^G to cancel whatever called us. */
d1779 1
a1779 1
	if (c == ERR && errno == EINTR) /* may have been handled signal - kw */
d1791 1
a1791 1
	done_esc = TRUE;		/* Flag: we did it, not keypad() */
d1801 36
a1836 12
	case 'A': c = UPARROW; break;
	case 'B': c = DNARROW; break;
	case 'C': c = RTARROW; break;
	case 'D': c = LTARROW; break;
	case 'q': c = END_KEY; break;	/* vt100 application keypad 1 */
	case 'r': c = DNARROW; break;	/* vt100 application keypad 2 */
	case 's': c = PGDOWN;  break;	/* vt100 application keypad 3 */
	case 't': c = LTARROW; break;	/* vt100 application keypad 4 */
	case 'v': c = RTARROW; break;	/* vt100 application keypad 6 */
	case 'w': c = HOME;    break;	/* vt100 application keypad 7 */
	case 'x': c = UPARROW; break;	/* vt100 application keypad 8 */
	case 'y': c = PGUP;    break;	/* vt100 application keypad 9 */
d1839 3
a1841 5
	   if (found_CSI(c,b))
	     {
		c = sl_read_mouse_event (code);
	     }
	   else
d1843 2
a1844 2
	     c = '\n';		/* keypad enter on pc ncsa telnet */
	   break;
d1856 1
a1856 1
		done_esc = FALSE; /* we have another look below - kw */
d1882 2
a1883 2
	case '1':		/** VTxxx  Find  **/
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1886 1
a1886 1
		done_esc = FALSE; /* we have another look below - kw */
d1889 2
a1890 2
	    if (found_CSI(c,b)) {
		if ((d=GetChar())=='~')     /** VTxxx Insert **/
d1894 2
a1895 3
			 GetChar() == '~')
		 {
		    if (d == '8')	     /** VTxxx	Help **/
d1897 1
a1897 1
		    else if (d == '9')	     /** VTxxx	 Do  **/
d1900 3
a1902 4
		 }
	    }
	    else
		done_esc = FALSE; /* we have another look below - kw */
d1905 1
a1905 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1908 1
a1908 1
		done_esc = FALSE; /* we have another look below - kw */
d1911 1
a1911 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1914 1
a1914 1
		done_esc = FALSE; /* we have another look below - kw */
d1917 1
a1917 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1920 1
a1920 1
		done_esc = FALSE; /* we have another look below - kw */
d1923 1
a1923 1
	    if (found_CSI(c,b) && (d=GetChar()) == '~')
d1926 1
a1926 1
		done_esc = FALSE; /* we have another look below - kw */
d1929 2
a1930 2
	    if (found_CSI(c,b)) {
		if ((d=GetChar()) == 'A')
d1936 1
a1936 1
	    if (c == CH_ESC && a == b && !found_CSI(c,b)) {
d1943 1
a1943 1
	    CTRACE((tfp,"Unknown key sequence: %d:%d:%d\n",c,b,a));
d1947 1
a1947 1
	if (isdigit(a) && found_CSI(c,b) && d != -1 && d != '~')
d1950 1
a1950 1
	    if (a == b && !found_CSI(c,b) && c == CH_ESC) {
d1961 1
a1961 1
    if (c >= 0 && (c&LKC_ISLECLAC)) {
d1964 1
a1964 1
    } else if (c >= 0 && (c&LKC_ISLKC)) {
d1966 1
a1966 1
	done_esc = TRUE; /* already a lynxkeycode, skip keypad switches - kw */
d1972 2
a1973 2
    if (c >= 0 && (c&(LKC_ISLECLAC|LKC_ISLAC))) {
	done_esc = TRUE; /* already a lynxactioncode, skip keypad switches - iz */
d1981 1
a1981 1
	 *  Convert keypad() mode keys into Lynx defined keys.
d1983 4
a1986 4
	switch(c) {
	case KEY_DOWN:		   /* The four arrow keys ... */
	   c = DNARROW;
	   break;
d1988 2
a1989 2
	   c = UPARROW;
	   break;
d1991 5
a1995 5
	   c = LTARROW;
	   break;
	case KEY_RIGHT:		   /* ... */
	   c = RTARROW;
	   break;
d1998 2
a1999 2
	   c = DNARROW;
	   break;
d2001 2
a2002 2
	   c = UPARROW;
	   break;
d2004 2
a2005 2
	   c = LTARROW;
	   break;
d2007 8
a2014 8
	   c = RTARROW;
	   break;
	case PAD0:		   /* PC-9800 Ins */
	   c = INSERT_KEY;
	   break;
	case PADSTOP:		   /* PC-9800 DEL */
	   c = REMOVE_KEY;
	   break;
d2016 15
a2030 15
	case KEY_HOME:		   /* Home key (upward+left arrow) */
	   c = HOME;
	   break;
	case KEY_CLEAR:		   /* Clear screen */
	   c = 18; /* CTRL-R */
	   break;
	case KEY_NPAGE:		   /* Next page */
	   c = PGDOWN;
	   break;
	case KEY_PPAGE:		   /* Previous page */
	   c = PGUP;
	   break;
	case KEY_LL:		   /* home down or bottom (lower left) */
	   c = END_KEY;
	   break;
d2032 19
a2050 19
					/* The keypad is arranged like this:*/
					/*    a1    up	  a3   */
					/*   left   b2	right  */
					/*    c1   down   c3   */
	case KEY_A1:		   /* upper left of keypad */
	   c = HOME;
	   break;
	case KEY_A3:		   /* upper right of keypad */
	   c = PGUP;
	   break;
	case KEY_B2:		   /* center of keypad */
	   c = DO_NOTHING;
	   break;
	case KEY_C1:		   /* lower left of keypad */
	   c = END_KEY;
	   break;
	case KEY_C3:		   /* lower right of keypad */
	   c = PGDOWN;
	   break;
d2053 3
a2055 3
	case KEY_ENTER:		   /* enter/return	*/
	   c = '\n';
	   break;
d2057 1
a2057 1
#ifdef PADENTER			   /* PDCURSES */
d2059 2
a2060 2
	   c = '\n';
	   break;
d2063 3
a2065 3
	case KEY_END:		   /* end key		001 */
	   c = END_KEY;
	   break;
d2068 3
a2070 3
	case KEY_HELP:		   /* help key		001 */
	   c = F1;
	   break;
d2074 2
a2075 2
	   c = CH_DEL;		   /* backspace key (delete, not Ctrl-H)  S/390 -- gil -- 2041 */
	   break;
d2078 2
a2079 2
	   c = F1;		   /* VTxxx Help */
	   break;
d2082 2
a2083 2
	   c = DO_KEY;		   /* VTxxx Do */
	   break;
d2086 3
a2088 3
	case KEY_REDO:		   /* VTxxx Do */
	   c = DO_KEY;
	   break;
d2092 2
a2093 2
	   c = FIND_KEY;	   /* VTxxx Find */
	   break;
d2097 2
a2098 2
	   c = SELECT_KEY;	   /* VTxxx Select */
	   break;
d2102 2
a2103 2
	   c = INSERT_KEY;	   /* VTxxx Insert */
	   break;
d2107 2
a2108 2
	   c = REMOVE_KEY;	   /* VTxxx Remove */
	   break;
d2112 2
a2113 2
	   c = BACKTAB_KEY;	   /* Back tab, often Shift-Tab */
	   break;
d2116 1
a2116 1
	case KEY_RESIZE:	   /* size change detected by ncurses */
d2123 1
a2123 1
		  recent_sizechange));
d2128 1
a2128 1
		  recent_sizechange));
d2131 6
a2136 6
#if 0			/* assumption seems flawed? */
		/*  Not detected by us or already processed by us.  It can
		 *  happens that ncurses lags behind us in detecting the
		 *  change, since its own SIGTSTP handler is not installed
		 *  so detecting happened *at the end* of the last refresh.
		 *  Tell it to refresh again... - kw
d2150 3
a2152 3
		 *  May be just the delayed effect of mainloop()'s call
		 *  to resizeterm().  Pretend we haven't read anything
		 *  yet, don't return. - kw
d2157 2
a2158 2
	     *  Yep, we agree there was a change.  Return now so that
	     *  the caller can react to it. - kw
d2193 1
a2193 1
		c = MOUSE_KEY;		/* Will be processed by the caller */
d2198 1
d2214 1
a2214 1
		    return(code==FOR_PANEL ? 0 : DO_NOTHING);
d2216 1
a2216 1
		levent = event;		/* Allow setting pos in entry fields */
d2226 1
a2226 1
				 /* Cannot ignore: see LYCurses.c */
d2228 3
a2230 3
				( BUTTON1_PRESSED | BUTTON1_RELEASED
				  | BUTTON2_PRESSED | BUTTON2_RELEASED
				  | BUTTON3_PRESSED | BUTTON3_RELEASED))) {
d2240 1
a2240 1
			mouse_link = -1; /* Forget about approx stuff. */
d2259 1
a2259 1
#if 0	/* Probably not necessary any more - kw */
d2266 1
a2266 1
		    ungetmouse(&event);	/* Caller will process this. */
d2277 2
a2278 1
		int right = (LYcols - H_CMD_AREA);
d2306 2
a2307 1
			    c = LTARROW;	p = "<-";
d2309 2
a2310 1
			    c = RTARROW;	p = "->";
d2312 2
a2313 1
			    c = 'z';		p = "Cancel";
d2315 2
a2316 1
			    c = PGDOWN;		p = "PGDOWN";
d2321 2
a2322 1
			    c = LTARROW;	p = "<-";
d2324 2
a2325 1
			    c = RTARROW;	p = "->";
d2327 2
a2328 1
			    c = 'z';		p = "Cancel";
d2330 2
a2331 1
			    c = PGUP;		p = "PGUP";
d2334 3
a2336 1
			c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL, 1);
d2344 2
a2345 2
		if ((c+1) >= KEYMAP_SIZE && (c&LKC_ISLAC))
		    return(c);
d2351 1
a2351 1
#endif  /* USE_MOUSE */
d2356 2
a2357 2
	switch(c) {
	case K_Down:		   /* The four arrow keys ... */
d2359 2
a2360 2
	   c = DNARROW;
	   break;
d2363 2
a2364 2
	   c = UPARROW;
	   break;
d2367 3
a2369 3
	   c = LTARROW;
	   break;
	case K_Right:		   /* ... */
d2371 3
a2373 3
	   c = RTARROW;
	   break;
	case K_Home:		   /* Home key (upward+left arrow) */
d2375 3
a2377 3
	   c = HOME;
	   break;
	case K_PageDown:	   /* Next page */
d2379 3
a2381 3
	   c = PGDOWN;
	   break;
	case K_PageUp:		   /* Previous page */
d2383 3
a2385 3
	   c = PGUP;
	   break;
	case K_End:		   /* home down or bottom (lower left) */
d2387 6
a2392 6
	   c = END_KEY;
	   break;
	case K_F1:		   /* F1 key */
	   c = F1;
	   break;
	case K_Insert:		   /* Insert key */
d2394 3
a2396 3
	   c = INSERT_KEY;
	   break;
	case K_Delete:		   /* Delete key */
d2398 14
a2411 14
	   c = REMOVE_KEY;
	   break;
	case K_Alt_Escape:	   /* Alt-Escape */
	   c = 0x1a7;
	   break;
	case K_Control_At:	   /* CTRL-@@ */
	   c = 0x1a8;
	   break;
	case K_Alt_Backspace:	   /* Alt-Backspace */
	   c = 0x1a9;
	   break;
	case K_BackTab:		   /* BackTab */
	   c = BACKTAB_KEY;
	   break;
d2415 4
a2418 4
	switch(c) {
	case SL_KEY_DOWN:	   /* The four arrow keys ... */
	   c = DNARROW;
	   break;
d2420 2
a2421 2
	   c = UPARROW;
	   break;
d2423 30
a2452 30
	   c = LTARROW;
	   break;
	case SL_KEY_RIGHT:	   /* ... */
	   c = RTARROW;
	   break;
	case SL_KEY_HOME:	   /* Home key (upward+left arrow) */
	case SL_KEY_A1:		   /* upper left of keypad */
	   c = HOME;
	   break;
	case SL_KEY_NPAGE:	   /* Next page */
	case SL_KEY_C3:		   /* lower right of keypad */
	   c = PGDOWN;
	   break;
	case SL_KEY_PPAGE:	   /* Previous page */
	case SL_KEY_A3:		   /* upper right of keypad */
	   c = PGUP;
	   break;
	case SL_KEY_END:	   /* home down or bottom (lower left) */
	case SL_KEY_C1:		   /* lower left of keypad */
	   c = END_KEY;
	   break;
	case SL_KEY_F(1):	   /* F1 key */
	   c = F1;
	   break;
	case SL_KEY_IC:		   /* Insert key */
	   c = INSERT_KEY;
	   break;
	case SL_KEY_DELETE:	   /* Delete key */
	   c = REMOVE_KEY;
	   break;
d2457 3
a2459 3
    if (c&(LKC_ISLAC|LKC_ISLECLAC))
	return(c);
    if ((c+1) >= KEYMAP_SIZE) {
d2461 3
a2463 3
	 *  Don't return raw values for KEYPAD symbols which we may have
	 *  missed in the switch above if they are obviously invalid when
	 *  used as an index into (e.g.) keypad[]. - KW
d2467 1
a2467 1
	return(c|current_modifier);
d2472 1
a2472 2
#endif	/* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */

d2474 1
a2474 1
PUBLIC int LYgetch NOARGS
d2482 1
a2482 1
PUBLIC int LYgetch_choice NOARGS
d2485 1
d2487 1
a2487 1
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
d2494 1
a2494 1
PUBLIC int LYgetch_input NOARGS
d2497 1
d2499 1
a2499 1
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
d2507 1
a2507 1
PUBLIC int LYgetch_single NOARGS
d2510 1
d2512 1
a2512 1
	ch = LYCharINTERRUPT2;			/* treat ^C the same as ^G */
d2521 1
a2521 2
PUBLIC void LYLowerCase ARGS1(
	 char *,	arg_buffer)
d2525 1
d2530 1
a2530 1
	 && buffer[i+1] != 0) {
d2547 1
a2547 2
PUBLIC void LYUpperCase ARGS1(
	 char *,	arg_buffer)
d2551 1
d2556 1
a2556 1
	 && buffer[i+1] != 0) {
d2573 1
a2573 2
PUBLIC BOOLEAN LYRemoveNewlines ARGS1(
	char *,		buffer)
d2576 3
a2578 3
	register char* buf = buffer;
	for ( ; *buf && *buf != '\n' && *buf != '\r'; buf++)
	    ;
d2581 3
a2583 2
	    char * old = buf;
	    for ( ; *old; old++) {
d2595 14
d2612 1
a2612 2
PUBLIC char * LYRemoveBlanks ARGS1(
	char *,		buffer)
d2615 3
a2617 3
	register char* buf = buffer;
	for ( ; *buf && !isspace(UCH(*buf)); buf++)
	    ;
d2620 3
a2622 2
	    char * old = buf;
	    for ( ; *old; old++) {
d2636 1
a2636 2
PUBLIC char * LYSkipBlanks ARGS1(
	char *,		buffer)
d2646 1
a2646 2
PUBLIC char * LYSkipNonBlanks ARGS1(
	char *,		buffer)
d2654 1
a2654 1
 * Skip CONST whitespace
d2656 1
a2656 2
PUBLIC CONST char * LYSkipCBlanks ARGS1(
	CONST char *,	buffer)
d2664 1
a2664 1
 * Skip CONST non-whitespace
d2666 1
a2666 2
PUBLIC CONST char * LYSkipCNonBlanks ARGS1(
	CONST char *,	buffer)
d2676 1
a2676 2
PUBLIC void LYTrimLeading ARGS1(
	char *,		buffer)
d2679 2
a2680 2
    while ((*buffer++ = *skipped++) != 0)
	;
d2686 1
a2686 2
PUBLIC char * LYTrimNewline ARGS1(
	char *,		buffer)
d2689 2
a2690 1
    while (i != 0 && (buffer[i-1] == '\n' || buffer[i-1] == '\r'))
d2698 1
a2698 2
PUBLIC void LYTrimTrailing ARGS1(
	char *,		buffer)
d2701 2
a2702 1
    while (i != 0 && isspace(UCH(buffer[i-1])))
d2709 2
a2710 3
PUBLIC char *LYElideString ARGS2(
	char *,		str,
	int,		cut_pos)
d2716 1
a2716 1
    LYstrncpy(buff, str, sizeof(buff)-1);
d2718 1
a2718 1
    if (len > (LYcols - 10)) {
d2721 1
a2721 1
	for (s = (buff + len) - (LYcols - 10) + cut_pos + 1,
d2726 1
a2726 2
	     (*d++ = *s++) != 0; )
	    ;
d2736 1
a2736 2
PUBLIC BOOLEAN LYTrimStartfile ARGS1(
	char *,		buffer)
d2742 4
a2745 5
	 *  The original implementations of these schemes expected
	 *  white space without hex escaping, and did not check
	 *  for hex escaping, so we'll continue to support that,
	 *  until that code is redone in conformance with SGML
	 *  principles.  - FM
d2757 1
a2757 2
PUBLIC void LYEscapeStartfile ARGS1(
	char **,		buffer)
d2761 1
d2770 1
a2770 2
PUBLIC void LYTrimAllStartfile ARGS1(
	char *,		buffer)
d2778 3
a2780 3
**  Display the current value of the string and allow the user
**  to edit it.
*/
d2785 1
a2785 1
 *  Shorthand to get rid of all most of the "edit->suchandsos".
d2799 1
a2799 1
PRIVATE char killbuffer[1024] = "\0";
d2802 3
a2804 5
PUBLIC void LYSetupEdit ARGS4(
	EDREC *,	edit,
	char *,		old,
	int,		maxstr,
	int,		maxdsp)
d2807 1
a2807 1
     *	Initialize edit record
d2810 1
a2810 1
    edit->pad	= ' ';
d2815 1
a2815 1
    MaxLen  = maxstr;
d2817 1
a2817 1
    Margin  = 0;
d2824 2
a2825 2
    if (maxstr > maxdsp) {  /* Need panning? */
	if (DspWdth > 4)    /* Else "{}" take up precious screen space */
d2829 3
a2831 4
	 *  Figure out margins.  If too big, we do a lot of unnecessary
	 *  scrolling.	If too small, user doesn't have sufficient
	 *  look-ahead.  Let's say 25% for each margin, upper bound is
	 *  10 columns.
d2833 1
a2833 1
	Margin = DspWdth/4;
d2844 1
a2844 3
PRIVATE int prev_pos ARGS2(
	EDREC *,	edit,
	int,		pos)
d2855 1
d2858 1
a2858 1
		  !((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c)))) {
d2873 1
d2878 4
a2881 6
PUBLIC int LYEditInsert ARGS5(
	EDREC *,	edit,
	unsigned char *,s,
	int,		len,
	int,		map,
	BOOL,		maxMessage)
d2888 1
a2888 1
     *  ch is (presumably) printable character.
d2899 1
a2899 1
    for(; length >= Pos; length--)    /* Make room */
d2906 1
a2906 1
	unsigned char *e = s + len;
d2914 1
a2914 1
	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
d2946 2
a2947 1
	unsigned char *e = s + len, *t = (unsigned char *)Buf + Pos;
d2952 1
a2952 1
	    if ( *s < 128 && LYKbLayouts[current_layout][*s] ) {
d2963 5
d2969 3
a2971 9
    else
#endif	/* defined EXP_KEYBOARD_LAYOUT */
	{
	    strncpy(Buf + Pos, (char *) s, len);
	    edited = 1;
	}

  finish:
    Pos += len;
d2983 1
a2983 1
	Mark = -1 - Mark;		/* Disable it */
d2988 7
a2994 9
PUBLIC int LYEdit1 ARGS4(
	EDREC *,	edit,
	int,		ch,
	int,		action,
	BOOL,		maxMessage)
{   /* returns 0    character processed
     *         -ch  if action should be performed outside of line-editing mode
     *	       ch   otherwise
     */
d3000 1
a3000 1
	return(0); /* Be defensive */
d3009 1
a3009 1
	 *  Turn input character mapping on or off.
d3017 4
a3020 4
	 *  Hex 97.
	 *  Fall through as a character for CJK, or if this is a valid
	 *  character in the current display character set.
	 *  Otherwise, we treat this as LYE_ENTER.
d3023 1
a3023 1
	    return(ch);
d3029 1
a3029 1
	return 0;			/* All changes already registered */
d3033 6
a3038 7
	 *  ch is the second part (in most cases, a capital letter) of
	 *  a 7-bit replacement for a character in the 8-bit C1 control
	 *  range.
	 *  This is meant to undo transformations like
	 *  0x81 -> 0x1b 0x41 (ESC A) etc. done by slang on Unix and
	 *  possibly some comm programs.  It's an imperfect workaround
	 *  that doesn't work for all such characters.
d3051 1
a3051 1
		Mark = -1 - Mark;		/* Disable it */
d3053 3
a3055 3
	    for(i = length; i >= Pos; i--)    /* Make room */
		Buf[i+1] = Buf[i];
	    Buf[length+1]='\0';
d3060 3
a3062 3
	    _statusline(MAXLEN_REACHED_DEL_OR_MOV);
	}
	    return(ch);
d3069 2
a3070 2
	 *  Backword.
	 *  Definition of word is very naive: 1 or more a/n characters.
d3072 1
a3072 1
	while (Pos && !isalnum(Buf[Pos-1]))
d3074 1
a3074 1
	while (Pos &&  isalnum(Buf[Pos-1]))
d3078 3
a3080 3
	 *  Backword.
	 *  Definition of word is very naive: 1 or more a/n characters,
	 *  or 1 or more multibyte character.
d3099 2
a3100 2
		 && !is8bits(Buf[pos0])
		 && isalnum(UCH(Buf[pos0]))) {
d3111 1
a3111 1
	 *  Word forward.
d3115 1
a3115 1
	    Pos++;   /* '\0' is not a/n */
d3117 1
a3117 1
	    Pos++ ;
d3124 1
a3124 1
		Pos++;	/* '\0' is not a/n */
d3134 1
a3134 1
	 *  Erase the line to start fresh.
d3136 1
a3136 1
	 Buf[0] = '\0';
d3140 1
a3140 1
	 /* fall through */
d3144 1
a3144 1
	 *  Go to first column.
d3151 1
a3151 1
	 *  Go to last column.
d3158 1
a3158 1
	 *  Delete next word.
d3162 2
a3163 1
	    LYEdit1 (edit, 0, LYE_FORWW, FALSE);
d3171 1
a3171 1
	 *  Delete previous word.
d3175 2
a3176 1
	    LYEdit1 (edit, 0, LYE_BACKW, FALSE);
d3185 1
a3185 1
	 *  Delete from current cursor position back to BOL.
d3189 1
d3195 1
a3195 1
    case LYE_DELEL:	/* @@@@@@ */
d3197 1
a3197 1
	 *  Delete from current cursor position thru EOL.
d3201 1
d3211 2
a3212 2
	 *  Delete next character (I-beam style cursor), or current
	 *  character (box/underline style cursor).
d3225 1
a3225 1
	 *  Delete preceding character.
d3232 1
a3232 1
	    Mark = -1 - Mark;		/* Disable it */
d3238 1
a3238 1
	    Buf[i] = Buf[i+1];
d3257 1
a3257 1
		Mark = -1 - Mark;		/* Disable it */
d3269 1
a3269 1
	 *  Move cursor to the right.
d3277 1
a3277 1
	    if (HTCJK != NOCJK && is8bits(Buf[Pos-1]))
d3288 1
a3288 1
	 *  Left-arrow move cursor to the left.
d3308 1
a3308 1
	 *  Transpose characters - bash or ksh(emacs not gmacs) style
d3311 1
a3311 1
	    return(ch);
d3315 3
a3317 3
	    Mark = -1 - Mark;		/* Temporary enable it */
	if (Mark == Pos || Mark == Pos+1)
	    Mark = Pos-1;
d3319 2
a3320 2
	    Mark = -1 - Mark;		/* Disable it */
	if (Buf[Pos-1] == Buf[Pos]) {
d3324 3
a3326 1
	i = Buf[Pos-1]; Buf[Pos-1] = Buf[Pos]; Buf[Pos++] = (char) i;
d3331 1
a3331 1
	 *  primitive emacs-like set-mark-command
d3334 1
a3334 1
	return(0);
d3338 1
a3338 1
	 *  emacs-like exchange-point-and-mark
d3341 1
a3341 1
	    Mark = -1 - Mark;		/* Enable it */
d3343 4
a3346 2
	    return(0);
	i = Pos; Pos = Mark; Mark = i;
d3351 1
a3351 1
	 *  primitive emacs-like kill-region
d3354 1
a3354 1
	    Mark = -1 - Mark;		/* Enable it */
d3357 1
a3357 1
	    return(0);
d3365 4
a3368 4
		      HTMIN(reglen, (int)sizeof(killbuffer)-1));
	    for (i = Mark; Buf[i+reglen]; i++)
		Buf[i] = Buf[i+reglen];
	    Buf[i] = Buf[i+reglen]; /* terminate */
d3372 1
a3372 1
	    Mark = -1 - Mark;		/* Disable it */
d3377 1
a3377 1
	 *  primitive emacs-like yank
d3381 2
a3382 3
	    return(0);
	}
	{
d3385 1
a3385 1
	    if (Pos+yanklen <= (MaxLen) && StrLen+yanklen <= (MaxLen)) {
d3388 2
a3389 2
		for(i = length; i >= Pos; i--)    /* Make room */
		    Buf[i+yanklen] = Buf[i];
d3410 1
a3410 1
	return(ch);
d3414 1
a3414 1
    return(0);
d3418 7
a3424 8
**  This function prompts for a choice or page number.
**  If a 'g' or 'p' suffix is included, that will be
**  loaded into c.  Otherwise, c is zeroed. - FM & LE
*/
PUBLIC int get_popup_number ARGS3(
	char *,		msg,
	int *,		c,
	int *,		rel)
d3431 1
a3431 1
     *  Load the c argument into the prompt buffer.
d3438 1
a3438 1
     *  Get the number, possibly with a suffix, from the user.
d3444 1
a3444 1
	return(0);
d3449 1
a3449 1
    while ( isdigit(UCH(*p)) )
d3451 3
a3453 2
    switch ( *p ) {
    case '+': case '-':
d3455 2
a3456 1
	*rel = *p++; *c = *p;
d3467 2
a3468 2
     *  If we had a 'g' or 'p' suffix, load it into c.
     *  Otherwise, zero c.  Then return the number.
d3470 1
a3470 1
    if ( *p == 'g' || *p == 'G' ) {
d3472 1
a3472 1
    } else if (*p == 'p' || *p == 'P' ) {
d3477 1
a3477 1
    if ( *rel != '+' && *rel != '-' )
d3488 1
a3488 1
#endif	/* defined USE_COLOR_STYLE */
d3490 1
a3490 2
PUBLIC void LYRefreshEdit ARGS1(
	EDREC *,	edit)
d3498 1
d3512 1
a3512 1
    length=strlen(&Buf[0]);
d3514 15
a3528 15
/*
 *  Now we have:
 *                .--DspWdth---.
 *      +---------+=============+-----------+
 *      |         |M           M|           |   (M=margin)
 *      +---------+=============+-----------+
 *      0         DspStart                   length
 *
 *  Insertion point can be anywhere between 0 and stringlength.
 *  Figure out new display starting point.
 *
 *   The first "if" below makes Lynx scroll several columns at a time when
 *   extending the string.  Looks awful, but that way we can keep up with
 *   data entry at low baudrates.
 */
d3532 1
a3532 1
	    DspStart=(Pos - DspWdth) + Margin;
d3565 4
a3568 4
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
    }
d3578 1
a3578 1
    nrdisplayed = length-DspStart;
d3585 3
a3587 3
     *  If this is the last screen line, set attributes to normal,
     *  should only be needed for color styles.  The curses function
     *  may be used directly to avoid complications. - kw
d3597 1
a3597 1
		  prompting ? "prompt" : "active"));
d3601 1
a3601 1
	wattrset(LYwin,A_NORMAL); /* need to do something about colors? */
d3613 2
a3614 2
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos > Mark)
			       || (DspStart + i == Pos && Pos < Mark) ))
d3616 2
a3617 2
	    if ( Mark >= 0 && ((DspStart + i == Mark && Pos < Mark)
			       || (DspStart + i == Pos && Pos > Mark) ))
d3669 1
a3669 1
     *	Erase rest of input area.
d3671 1
a3671 1
    padsize = DspWdth-nrdisplayed;
d3680 1
a3680 1
     *	Scrolling indicators.
d3693 1
a3693 1
		LYaddch(' ');		/* Needed with styles? */
d3703 1
a3703 1
		LYaddch(' ');		/* Needed with styles? */
d3718 1
a3718 3
PRIVATE void reinsertEdit ARGS2(
    EditFieldData *,	edit,
    char *,		result)
d3723 1
a3723 1
	    LYLineEdit(edit, (int)(*result), FALSE);
d3729 2
a3730 3
PRIVATE int caselessCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
d3732 1
a3732 1
    return strcasecomp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
d3735 2
a3736 3
PRIVATE int normalCmpList ARGS2(
    CONST void *,	a,
    CONST void *,	b)
d3738 1
a3738 1
    return strcmp(*(CONST char *CONST *)a, *(CONST char *CONST *)b);
d3741 1
a3741 3
PRIVATE char **sortedList ARGS2(
    HTList *,	list,
    BOOL,	ignorecase)
d3752 1
a3752 1
	result[j++] = HTList_nextObject(list);
d3755 1
a3755 1
	qsort((char *)result, count, sizeof(*result),
d3762 1
a3762 1
	     && !strcmp(result[j], result[k])) {
d3767 1
a3767 1
		for (jk = j; ; jk++) {
d3779 1
a3779 2
PUBLIC int LYarrayLength ARGS1(
    CONST char **,	list)
d3788 1
a3788 2
PUBLIC int LYarrayWidth ARGS1(
    CONST char **,	list)
d3801 4
a3804 5
PRIVATE void FormatChoiceNum ARGS4(
	char *,		dst,
	int,		num_choices,
	int,		choice,
	CONST char *,	value)
d3808 1
d3810 2
a3811 2
			digits, (choice + 1),
			MAX_LINE - 9 - digits, value);
d3813 1
a3813 1
	LYstrncpy(dst, value, MAX_LINE-1);
d3817 1
a3817 2
PRIVATE unsigned options_width ARGS1(
	CONST char **,	list)
d3831 6
a3836 8
PRIVATE void draw_option ARGS7(
    WINDOW *,		win,
    int,		entry,
    int,		width,
    BOOL,		reversed,
    int,		num_choices,
    int,		number,
    CONST char *,	value)
d3840 2
d3848 1
a3848 1
    SLsmg_write_nstring((char *)value, win->width);
d3879 2
a3880 3
 *  This function offers the choices for values of an
 *  option via a popup window which functions like
 *  that for selection of options in a form. - FM
d3882 1
a3882 2
 *  Also used for mouse popups with ncurses; this is indicated
 *  by for_mouse.
d3884 9
a3892 10
PUBLIC int LYhandlePopupList ARGS9(
	int,		cur_choice,
	int,		ly,
	int,		lx,
	CONST char **,	choices,
	int,		width,
	int,		i_length,
	int,		disabled,
	BOOLEAN,	for_mouse,
	BOOLEAN,	numbered)
d3896 1
a3896 1
    WINDOW * form_window;
d3905 1
a3905 1
    static char prev_target[MAX_LINE];		/* Search string buffer */
d3909 2
a3910 1
    int ch = 0, recall;
d3917 3
a3919 2
    char *popup_status_msg = NULL;
    CONST char **Cptr = NULL;
d3942 5
a3946 6
     *	Count the number of choices to be displayed, where
     *	num_choices ranges from 0 to n, and set width to the
     *	longest choice string length.  Also set Lnum to the
     *	length for the highest choice number, then decrement
     *	num_choices so as to be zero-based.  The window width
     *	will be based on the sum of width and Lnum. - FM
d3961 9
a3969 9
     *  Let's assume for the sake of sanity that ly is the number
     *   corresponding to the line the choice is on.
     *  Let's also assume that cur_choice is the number of the
     *   item that should be initially selected, as 0 being the
     *   first item.
     *  So what we have, is the top equal to the current screen line
     *   subtracting the cur_choice + 1 (the one must be for the
     *   top line we will draw in a box).  If the top goes under 0,
     *   consider it 0.
d3976 2
a3977 2
     *  Check and see if we need to put the i_length parameter up to
     *  the number of real choices.
d3983 1
a3983 1
	 *  Otherwise, it is really one number too high.
d3989 3
a3991 3
     *  The bottom is the value of the top plus the number of options
     *  to view plus 3 (one for the top line, one for the bottom line,
     *  and one to offset the 0 counted in the num_choices).
d3996 1
a3996 1
     *  Set lines_to_show based on the user_mode global.
d3999 1
a3999 1
	lines_to_show = LYlines-4;
d4001 1
a4001 1
	lines_to_show = LYlines-2;
d4007 1
a4007 1
     *  Hmm...  If the bottom goes beyond the number of lines available,
d4011 2
a4012 2
	 *  Position the window at the top if we have more
	 *  choices than will fit in the window.
d4021 4
a4024 4
	     *  Try to position the window so that the selected choice will
	     *    appear where the selection box currently is positioned.
	     *  It could end up too high, at this point, but we'll move it
	     *    down latter, if that has happened.
d4032 1
a4032 1
     *  This is really fun, when the length is 4, it means 0 to 4, or 5.
d4039 1
a4039 1
     *  Move the window down if it's too high.
d4049 3
d4053 3
a4055 3
	if (Lnum + (int)width + 4 < LYcols) {
	    if (lx - 1 + (Lnum + (int)width + 4) > LYcols)
		lx = LYcols + 1 - (Lnum + width + 4);
d4062 2
a4063 2
     *  Set up the overall window, including the boxing characters ('*'),
     *  if it all fits.  Otherwise, set up the widest window possible. - FM
d4065 3
d4069 9
a4077 3
     || cur_choice > num_choices
     || (form_window = LYstartPopup(top, lx, bottom - top, Lnum + width)) == 0)
	return(orig_choice);
d4080 1
a4080 2
     *	Clear the command line and write
     *	the popup statusline. - FM
d4090 2
a4091 2
	popup_status_msg = gettext(
		"Left mouse button or return to select, arrow keys to scroll.");
d4097 3
a4099 3
     *  Set up the window_offset for choices.
     *   cur_choice ranges from 0...n
     *   length ranges from 0...m
d4106 1
a4106 1
     *  Compute the number of popup window pages. - FM
d4109 6
a4114 6
		(((num_choices + 1) + (length - 1))/(length))
					  : 1;
/*
 *  OH!  I LOVE GOTOs! hack hack hack
 */
redraw:
d4117 1
a4117 1
     *  Display the boxed choices.
d4121 2
a4122 2
	    draw_option (form_window, ((i + 1) - window_offset), width, FALSE,
			 max_choices, i, choices[i]);
d4125 1
a4125 1
    LYbox(form_window, (BOOLEAN)!numbered);
d4129 1
a4129 1
     *  Loop on user input.
d4139 2
a4140 2
	    if (~can_scroll & can_scroll_was) {	/* Need to redraw */
		LYbox(form_window, (BOOLEAN)!numbered);
d4158 1
a4158 1
	 *  Unreverse cur choice.
d4161 2
a4162 2
	    draw_option (form_window, row, width, FALSE,
			 max_choices, i, Cptr[i]);
d4167 2
a4168 2
	draw_option (form_window, row, width, TRUE,
		     max_choices, cur_choice, Cptr[cur_choice]);
d4172 1
a4172 1
	if (term_options || LYCharIsINTERRUPT(c)) { /* Control-C or Control-G */
d4178 1
a4178 1
	    if  (cmd == LYK_ACTIVATE)
d4182 1
a4182 1
	    cmd = LKC_TO_LAC(keymap,c);
d4191 18
a4208 19
	switch(cmd) {
	    case LYK_F_LINK_NUM:
		c = '\0';
		/* FALLTHRU */
	    case LYK_1: /* FALLTHRU */
	    case LYK_2: /* FALLTHRU */
	    case LYK_3: /* FALLTHRU */
	    case LYK_4: /* FALLTHRU */
	    case LYK_5: /* FALLTHRU */
	    case LYK_6: /* FALLTHRU */
	    case LYK_7: /* FALLTHRU */
	    case LYK_8: /* FALLTHRU */
	    case LYK_9:
		/*
		 *  Get a number from the user, possibly with
		 *  a 'g' or 'p' suffix (which will be loaded
		 *  into c). - FM & LE
		 */
		number = get_popup_number(SELECT_OPTION_NUMBER, &c, &rel);
d4210 25
a4234 19
		/* handle + or - suffix */
		CTRACE((tfp,"got popup option number %d, ",number));
		CTRACE((tfp,"rel='%c', c='%c', cur_choice=%d\n",
				rel, c, cur_choice));
		if ( c == 'p' ) {
		    int curpage = ((cur_choice + 1) > length) ?
			(((cur_choice + 1) + (length - 1))/(length))
					  : 1;
		    CTRACE((tfp,"  curpage=%d\n",curpage));
		    if ( rel == '+' )
			number = curpage + number;
		    else if ( rel == '-' )
			number = curpage - number;
		} else if ( rel == '+' ) {
		    number = cur_choice + number + 1;
		} else if ( rel == '-' ) {
		    number = cur_choice - number + 1;
		}
		if ( rel ) CTRACE((tfp,"new number=%d\n",number));
d4236 1
a4236 1
		 *  Check for a 'p' suffix. - FM
d4238 3
a4240 12
		if (c == 'p') {
		    /*
		     *  Treat 1 or less as the first page. - FM
		     */
		    if (number <= 1) {
			if (window_offset == 0) {
			    HTUserMsg(ALREADY_AT_OPTION_BEGIN);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = 0;
			cur_choice = 0;
d4242 1
a4242 1
			goto redraw;
d4244 5
d4250 7
a4256 16
		    /*
		     *  Treat a number equal to or greater than the
		     *  number of pages as the last page. - FM
		     */
		    if (number >= npages) {
			if (window_offset >= ((num_choices - length) + 1)) {
			    HTUserMsg(ALREADY_AT_OPTION_END);
			    _statusline(popup_status_msg);
			    break;
			}
			window_offset = ((npages - 1) * length);
			if (window_offset > (num_choices - length)) {
			    window_offset = (num_choices - length + 1);
			}
			if (cur_choice < window_offset)
			    cur_choice = window_offset;
d4258 1
a4258 1
			goto redraw;
d4260 3
a4262 11

		    /*
		     *  We want an intermediate page. - FM
		     */
		    if (((number - 1) * length) == window_offset) {
			char *msg = 0;
			HTSprintf0(&msg, ALREADY_AT_OPTION_PAGE, number);
			HTUserMsg(msg);
			FREE(msg);
			_statusline(popup_status_msg);
			break;
d4264 2
a4265 1
		    cur_choice = window_offset = ((number - 1) * length);
d4268 7
d4276 5
d4282 3
d4286 7
d4294 2
a4295 2
		 *  Check for a positive number, which signifies
		 *  that a choice should be sought. - FM
d4297 29
a4325 6
		if (number > 0) {
		    /*
		     *  Decrement the number so as to correspond
		     *  with our cur_choice values. - FM
		     */
		    number--;
d4327 6
a4332 5
		    /*
		     *  If the number is in range and had no legal
		     *  suffix, select the indicated choice. - FM
		     */
		    if (number <= num_choices && c == '\0') {
d4334 12
a4345 2
			cmd = LYK_ACTIVATE;
			break;
d4349 1
a4349 2
		     *  Verify that we had a 'g' suffix,
		     *  and act on the number. - FM
d4351 3
a4353 12
		    if (c == 'g') {
			if (cur_choice == number) {
			    /*
			     *  The choice already is current. - FM
			     */
			    char *msg = 0;
			    HTSprintf0(&msg, OPTION_ALREADY_CURRENT, (number + 1));
			    HTUserMsg(msg);
			    FREE(msg);
			    _statusline(popup_status_msg);
			    break;
			}
d4355 5
a4359 21
			if (number <= num_choices) {
			    /*
			     *  The number is in range and had a 'g'
			     *  suffix, so make it the current option,
			     *  scrolling if needed. - FM
			     */
			    j = (number - cur_choice);
			    cur_choice = number;
			    if ((j > 0) &&
				(cur_choice - window_offset) >= length) {
				window_offset += j;
				if (window_offset > (num_choices - length + 1))
				    window_offset = (num_choices - length + 1);
			    } else if ((cur_choice - window_offset) < 0) {
				window_offset -= abs(j);
				if (window_offset < 0)
				    window_offset = 0;
			    }
			    _statusline(popup_status_msg);
			    goto redraw;
			}
d4361 4
a4364 6
			/*
			 *  Not in range. - FM
			 */
			HTUserMsg(BAD_OPTION_NUM_ENTERED);
		    }
		}
d4366 2
a4367 5
		/*
		 *  Restore the popup statusline. - FM
		 */
		_statusline(popup_status_msg);
		break;
d4369 8
a4376 4
	    case LYK_PREV_LINK:
	    case LYK_LPOS_PREV_LINK:
	    case LYK_FASTBACKW_LINK:
	    case LYK_UP_LINK:
d4378 6
a4383 2
		if (cur_choice > 0)
		    cur_choice--;
d4385 14
d4400 2
a4401 1
		 *  Scroll the window up if necessary.
d4403 1
a4403 12
		if ((cur_choice - window_offset) < 0) {
		    window_offset--;
		    goto redraw;
		}
		break;

	    case LYK_NEXT_LINK:
	    case LYK_LPOS_NEXT_LINK:
	    case LYK_FASTFORW_LINK:
	    case LYK_DOWN_LINK:
		if (cur_choice < num_choices)
		    cur_choice++;
d4406 2
a4407 1
		 *  Scroll the window down if necessary
d4409 3
a4411 3
		if ((cur_choice - window_offset) >= length) {
		    window_offset++;
		    goto redraw;
a4412 1
		break;
a4413 1
	    case LYK_NEXT_PAGE:
d4415 2
a4416 2
		 *  Okay, are we on the last page of the list?
		 *  If not then,
d4418 10
a4427 7
		if (window_offset != (num_choices - length + 1)) {
		    /*
		     *	Modify the current choice to not be a
		     *  coordinate in the list, but a coordinate
		     *  on the item selected in the window.
		     */
		    cur_choice -= window_offset;
d4429 10
a4438 8
		    /*
		     *  Page down the proper length for the list.
		     *  If simply to far, back up.
		     */
		    window_offset += length;
		    if (window_offset > (num_choices - length)) {
			window_offset = (num_choices - length + 1);
		    }
d4440 6
a4445 14
		    /*
		     *  Readjust the current selection to be a
		     *  list coordinate rather than window.
		     *  Redraw this thing.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		}
		else if (cur_choice < num_choices) {
		    /*
		     *  Already on last page of the list so just
		     *  redraw it with the last item selected.
		     */
		    cur_choice = num_choices;
a4446 1
		break;
a4447 1
	    case LYK_PREV_PAGE:
d4449 7
a4455 2
		 *  Are we on the first page of the list?
		 *  If not then,
d4457 19
a4475 6
		if (window_offset != 0) {
		    /*
		     *  Modify the current selection to not be a
		     *  list coordinate, but a window coordinate.
		     */
		    cur_choice -= window_offset;
d4477 4
a4480 8
		    /*
		     *  Page up the proper length.
		     *  If too far, back up.
		     */
		    window_offset -= length;
		    if (window_offset < 0) {
			window_offset = 0;
		    }
d4482 10
a4491 13
		    /*
		     *  Readjust the current choice.
		     */
		    cur_choice += window_offset;
		    goto redraw;
		} else if (cur_choice > 0) {
		    /*
		     *  Already on the first page so just
		     *  back up to the first item.
		     */
		    cur_choice = 0;
		}
		break;
d4493 3
a4495 1
	    case LYK_HOME:
d4497 7
a4503 1
		if (window_offset > 0) {
d4505 3
a4507 3
		    goto redraw;
		}
		break;
d4509 3
a4511 1
	    case LYK_END:
d4513 7
a4519 1
		if (window_offset != (num_choices - length + 1)) {
d4521 3
a4523 3
		    goto redraw;
		}
		break;
d4525 4
a4528 4
	    case LYK_DOWN_TWO:
		cur_choice += 2;
		if (cur_choice > num_choices)
		    cur_choice = num_choices;
d4530 10
a4539 10
		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += 2;
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
		}
		break;
d4541 4
a4544 4
	    case LYK_UP_TWO:
		cur_choice -= 2;
		if (cur_choice < 0)
		    cur_choice = 0;
d4546 2
d4549 9
a4557 1
		 *  Scroll the window up if necessary.
d4559 7
a4565 5
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= 2;
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
d4567 14
a4580 15
		break;

	    case LYK_DOWN_HALF:
		cur_choice += (length/2);
		if (cur_choice > num_choices)
		    cur_choice = num_choices;

		/*
		 *  Scroll the window down if necessary.
		 */
		if ((cur_choice - window_offset) >= length) {
		    window_offset += (length/2);
		    if (window_offset > (num_choices - length + 1))
			window_offset = (num_choices - length + 1);
		    goto redraw;
d4582 1
a4582 6
		break;

	    case LYK_UP_HALF:
		cur_choice -= (length/2);
		if (cur_choice < 0)
		    cur_choice = 0;
d4584 3
d4588 1
a4588 1
		 *  Scroll the window up if necessary.
d4590 3
a4592 7
		if ((cur_choice - window_offset) < 0) {
		    window_offset -= (length/2);
		    if (window_offset < 0)
			window_offset = 0;
		    goto redraw;
		}
		break;
d4594 2
a4595 7
	    case LYK_REFRESH:
		lynx_force_repaint();
		LYrefresh();
		break;

	    case LYK_NEXT:
		if (recall && *prev_target_buffer == '\0') {
d4597 1
a4597 12
		     *  We got a 'n'ext command with no prior query
		     *  specified within the popup window.  See if
		     *  one was entered when the popup was retracted,
		     *  and if so, assume that's what's wanted.  Note
		     *  that it will become the default within popups,
		     *  unless another is entered within a popup.  If
		     *  the within popup default is to be changed at
		     *  that point, use WHEREIS ('/') and enter it,
		     *  or the up- or down-arrow keys to seek any of
		     *  the previously entered queries, regardless of
		     *  whether they were entered within or outside
		     *  of a popup window. - FM
d4599 12
a4610 3
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      0)) != NULL) {
			LYstrncpy(prev_target_buffer, cp, sizeof(prev_target_buffer) - 1);
a4611 1
			FirstRecall = FALSE;
d4613 5
d4619 19
a4637 5
		strcpy(prev_target, prev_target_buffer);
		/* FALLTHRU */
	    case LYK_WHEREIS:
		if (*prev_target == '\0' ) {
		    _statusline(ENTER_WHEREIS_QUERY);
d4639 1
a4639 2
				       sizeof(prev_target_buffer),
				       recall)) < 0) {
d4641 1
a4641 1
			 *  User cancelled the search via ^G. - FM
d4646 1
d4648 2
a4649 4

check_recall:
		if (*prev_target == '\0' &&
		    !(recall && (ch == UPARROW || ch == DNARROW))) {
d4651 1
a4651 1
		     *  No entry.  Simply break.   - FM
d4653 9
a4661 20
		    HTInfoMsg(CANCELLED);
		    goto restore_popup_statusline;
		}

		if (recall && ch == UPARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  last query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = (QueryTotal - 1);
				 QueryNum > 0; QueryNum--) {
				if ((cp = (char *)HTList_objectAt(
							search_queries,
							QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
				    break;
				}
a4662 2
			} else {
			    QueryNum = 0;
d4665 1
a4665 4
			/*
			 *  Go back to the previous query in the list. - FM
			 */
			QueryNum++;
d4667 23
a4689 49
		    if (QueryNum >= QueryTotal) {
			/*
			 *  Roll around to the last query in the list. - FM
			 */
			QueryNum = 0;
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer && QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				      QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
				sizeof(prev_target_buffer), recall)) < 0) {
			    /*
			     *  User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
		    }
		} else if (recall && ch == DNARROW) {
		    if (FirstRecall) {
			/*
			 *  Use the current string or
			 *  first query in the list. - FM
			 */
			FirstRecall = FALSE;
			if (*prev_target_buffer) {
			    for (QueryNum = 0;
				 QueryNum < (QueryTotal - 1); QueryNum++) {
				if ((cp = (char *)HTList_objectAt(
							    search_queries,
							    QueryNum)) != NULL &&
				    !strcmp(prev_target_buffer, cp)) {
					break;
				}
			    }
			} else {
			    QueryNum = (QueryTotal - 1);
			}
d4691 1
a4691 4
			/*
			 *  Advance to the next query in the list. - FM
			 */
			QueryNum--;
d4693 3
a4695 1
		    if (QueryNum < 0) {
d4697 1
a4697 1
			 *  Roll around to the first query in the list. - FM
d4699 2
a4700 26
			QueryNum = (QueryTotal - 1);
		    }
		    if ((cp = (char *)HTList_objectAt(search_queries,
						      QueryNum)) != NULL) {
			LYstrncpy(prev_target, cp, sizeof(prev_target) - 1);
			if (*prev_target_buffer &&
			    !strcmp(prev_target_buffer, prev_target)) {
			    _statusline(EDIT_CURRENT_QUERY);
			} else if ((*prev_target_buffer &&
				    QueryTotal == 2) ||
				   (!(*prev_target_buffer) &&
				    QueryTotal == 1)) {
			    _statusline(EDIT_THE_PREV_QUERY);
			} else {
			    _statusline(EDIT_A_PREV_QUERY);
			}
			if ((ch = LYgetstr(prev_target, VISIBLE,
					   sizeof(prev_target_buffer),
					   recall)) < 0) {
			    /*
			     * User cancelled the search via ^G. - FM
			     */
			    HTInfoMsg(CANCELLED);
			    goto restore_popup_statusline;
			}
			goto check_recall;
d4702 20
d4723 2
d4726 1
a4726 1
		 *  Replace the search string buffer with the new target. - FM
d4728 1
a4728 3
		strcpy(prev_target_buffer, prev_target);
		HTAddSearchQuery(prev_target_buffer);

d4730 1
a4730 1
		 *  Start search at the next choice. - FM
d4732 5
a4736 9
		for (j = 1; Cptr[i+j] != NULL; j++) {
		    FormatChoiceNum(buffer, max_choices, (i + j), Cptr[i+j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
d4738 22
a4759 15
		if (Cptr[i+j] != NULL) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    cur_choice += j;
		    /*
		     *  Scroll the window down if necessary.
		     */
		    if ((cur_choice - window_offset) >= length) {
			window_offset += j;
			if (window_offset > (num_choices - length + 1))
			    window_offset = (num_choices - length + 1);
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
d4761 2
a4762 1

d4764 1
a4764 1
		 *  If we started at the beginning, it can't be present. - FM
d4766 2
a4767 5
		if (cur_choice == 0) {
		    HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
		    goto restore_popup_statusline;
		}

d4769 1
a4769 1
		 *  Search from the beginning to the current choice. - FM
d4771 5
a4775 26
		for (j = 0; j < cur_choice; j++) {
		    FormatChoiceNum(buffer, max_choices, (j + 1), Cptr[j]);
		    if (case_sensitive) {
			if (strstr(buffer, prev_target_buffer) != NULL)
			    break;
		    } else {
			if (LYstrstr(buffer, prev_target_buffer) != NULL)
			    break;
		    }
		}
		if (j < cur_choice) {
		    /*
		     *  We have a hit, so make that choice the current. - FM
		     */
		    j = (cur_choice - j);
		    cur_choice -= j;
		    /*
		     *  Scroll the window up if necessary.
		     */
		    if ((cur_choice - window_offset) < 0) {
			window_offset -= j;
			if (window_offset < 0)
			    window_offset = 0;
			ReDraw = TRUE;
		    }
		    goto restore_popup_statusline;
d4777 2
d4780 4
a4783 4
		/*
		 *  Didn't find it in the preceding choices either. - FM
		 */
		HTUserMsg2(STRING_NOT_FOUND, prev_target_buffer);
d4785 16
a4800 16
restore_popup_statusline:
		/*
		 *  Restore the popup statusline and
		 *  reset the search variables. - FM
		 */
		_statusline(popup_status_msg);
		*prev_target = '\0';
		QueryTotal = (search_queries ? HTList_count(search_queries)
					     : 0);
		recall = ((QueryTotal >= 1) ? RECALL_URL : NORECALL);
		QueryNum = QueryTotal;
		if (ReDraw == TRUE) {
		    ReDraw = FALSE;
		    goto redraw;
		}
		break;
d4802 7
a4808 7
	    case LYK_QUIT:
	    case LYK_ABORT:
	    case LYK_PREV_DOC:
	    case LYK_INTERRUPT:
		cur_choice = orig_choice;
		cmd = LYK_ACTIVATE; /* to exit */
		break;
d4813 1
a4813 1
    return(disabled ? orig_choice : cur_choice);
d4818 4
a4821 5
PUBLIC int LYgetstr ARGS4(
	char *,		inputline,
	int,		hidden,
	size_t,		bufsize,
	RecallType,	recall)
d4829 1
d4836 3
a4838 3
		    (bufsize - 1) : (sizeof(MyEdit.buffer) - 1);
    LYSetupEdit(&MyEdit, inputline, MaxStringSize, (LYcols-1)-x);
    MyEdit.hidden = (BOOL) hidden ;
d4842 1
a4842 1
again:
d4851 1
a4851 1
#ifdef CJK_EX	/* for SJIS code */
d4853 1
a4853 1
	 && (EditBinding(ch) != LYE_CHAR))
d4857 2
a4858 2
	 && (EditBinding(ch) != LYE_CHAR)
	 && (EditBinding(ch) != LYE_AIX))
d4865 1
a4865 1
	      || HadVMSInterrupt
d4868 1
a4868 1
	      || term_message
d4870 1
a4870 1
	      ) {
d4878 1
a4878 1
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
d4881 1
a4881 1
	    return(ch);
d4891 1
a4891 1
	if (LKC_TO_LAC(keymap,ch) == LYK_REFRESH)
d4905 1
a4905 1
	     *  Set flag for modifier 1.
d4911 1
a4911 1
	     *  Set flag for modifier 2.
d4918 1
d4920 1
a4920 1
		    char **data = sortedList(list, (BOOL)(recall == RECALL_CMD));
d4923 1
a4923 1
		    int num_options = LYarrayLength((CONST char **)data);
d4926 1
a4926 1
		     && strcasecomp(data[cur_choice], MyEdit.buffer) < 0)
d4930 9
a4938 10
		    cur_choice = LYhandlePopupList(
			cur_choice,
			0,
			old_x,
			(CONST char **)data,
			-1,
			-1,
			FALSE,
			FALSE,
			TRUE);
d4944 1
a4944 1
		    wmove(LYwin, old_y, old_x);
d4952 1
a4952 1
#ifndef CJK_EX	/* 1997/11/03 (Mon) 20:13:45 */
d4955 4
a4958 4
	     *	Hex 97.
	     *	Treat as a character for CJK, or if this is a valid
	     *	character in the current display character set.
	     *	Otherwise, we treat this as LYE_ENTER.
d4962 2
a4963 3
		 LYlowest_eightbit[current_char_set] <= 0x97))
	    {
		LYLineEdit(&MyEdit,ch, FALSE);
d4970 1
a4970 1
	     *	Terminate the string and return.
d4972 1
a4972 1
	    LYstrncpy(inputline, MyEdit.buffer, (int)bufsize);
d4976 1
a4976 1
	    return(ch);
d4979 1
a4979 1
	/* 1998/10/01 (Thu) 15:05:49 */
d4995 1
a4995 1
			if (*e1 < ' ') { /* Stop here? */
d4999 6
a5004 2
			    if (*e1 == '\t') { /* Replace by space */
				LYEditInsert(&MyEdit, (unsigned char * ) " ", 1, map_active, TRUE);
d5021 1
a5021 1
	     *	Control-C or Control-G aborts.
d5025 1
a5025 1
	    return(-1);
d5029 1
a5029 1
	     *	Deactivate.
d5034 1
a5034 1
	    return(-1);
d5038 1
a5038 1
		Mark = -1 - Mark;		/* Disable it */
d5045 2
a5046 3
	     *	Used only in form_getstr() for invoking
	     *	the LYK_F_LINK_NUM prompt when in form
	     *	text fields. - FM
d5052 2
a5053 3
	     *	Used in form_getstr() to end line editing and
	     *	pass on the input char/lynxkeycode.  Here it
	     *	is just ignored. - kw
d5060 3
a5062 3
		 *	Used in form_getstr() to end line editing and
		 *	pass on the lynxkeycode already containing a
		 *	lynxactioncode.  Here it is just ignored. - kw
a5065 1

d5084 1
a5084 1
PUBLIC CONST char * LYLineeditHelpURL NOARGS
d5089 1
d5109 1
a5109 1
 *  A replacement for 'strsep()'
d5111 2
a5112 3
PUBLIC char *LYstrsep ARGS2(
	char **,	stringp,
	CONST char *,	delim)
d5116 2
a5117 2
    if (isEmpty(stringp))		/* nothing to do? */
	return 0;			/* then don't fall on our faces */
d5119 1
a5119 1
    out = *stringp;			/* save the start of the string */
d5122 5
a5126 5
	*tmp = '\0';			/* terminate the substring with \0 */
	*stringp = ++tmp;		/* point at the next substring */
    }
    else *stringp = 0;			/* this was the last substring: */
					/* let caller see he's done */
d5131 6
a5136 8
 *  LYstrstr will find the first occurrence of the string
 *  pointed to by tarptr in the string pointed to by chptr.
 *  It returns NULL if string not found.
 *  It is a case insensitive search.
 */
PUBLIC char * LYstrstr ARGS2(
	char *,		chptr,
	CONST char *,	tarptr)
d5140 1
a5140 1
    for(; *chptr != '\0'; chptr++) {
d5142 2
a5143 2
	    if (0 == strncasecomp8(chptr+1, tarptr+1, len-1))
		return(chptr);
d5145 1
a5145 1
    } /* end for */
d5147 1
a5147 1
    return(NULL); /* string not found or initial chptr was empty */
d5151 3
a5153 3
 *  LYno_attr_char_case_strstr will find the first occurrence of the
 *  string pointed to by tarptr in the string pointed to by chptr.
 *  It ignores the characters: LY_UNDERLINE_START_CHAR and
d5159 1
a5159 1
 *  It is a case insensitive search.
d5161 2
a5162 3
PUBLIC char * LYno_attr_char_case_strstr ARGS2(
	char *,		chptr,
	char *,		tarptr)
d5164 1
a5164 1
    register char *tmpchptr, *tmptarptr;
d5167 1
a5167 1
	return(NULL);
d5173 1
a5173 1
	 if (0 == UPPER8(*chptr, *tarptr)) {
d5175 1
a5175 1
	     *	See if they line up.
d5177 2
a5178 2
	    tmpchptr = chptr+1;
	    tmptarptr = tarptr+1;
d5180 2
a5181 2
	    if (*tmptarptr == '\0')  /* one char target */
		 return(chptr);
d5193 1
a5193 1
		    return(chptr);
d5198 1
a5198 1
    } /* end for */
d5200 1
a5200 1
    return(NULL);
d5204 3
a5206 3
 *  LYno_attr_char_strstr will find the first occurrence of the
 *  string pointed to by tarptr in the string pointed to by chptr.
 *  It ignores the characters: LY_UNDERLINE_START_CHAR and
d5212 1
a5212 1
 *  It is a case sensitive search.
d5214 2
a5215 3
PUBLIC char * LYno_attr_char_strstr ARGS2(
	char *,		chptr,
	char *,		tarptr)
d5217 1
a5217 1
    register char *tmpchptr, *tmptarptr;
d5220 1
a5220 1
	return(NULL);
d5228 1
a5228 1
	     *	See if they line up.
d5233 2
a5234 2
	    if (*tmptarptr == '\0')  /* one char target */
		 return(chptr);
d5237 1
a5237 1
		 if (!IsSpecialAttrChar(*tmpchptr)) {
d5242 1
a5242 1
		 } else {
d5244 5
a5248 5
		 }
		 if (*tmptarptr == '\0')
		     return(chptr);
		 if (*tmpchptr == '\0')
		     break;
d5251 1
a5251 1
    } /* end for */
d5253 1
a5253 1
    return(NULL);
d5258 10
a5267 9
 * pointed to by tarptr in the string pointed to by chptr.
 * It takes account of MultiByte Character Sequences (UTF8).
 * The physical lengths of the displayed string up to the start and
 * end (= next position after) of the target string are returned in *nstartp
 * and *nendp if the search is successful.
 *   These lengths count glyph cells if count_gcells is set. (Full-width
 *   characters in CJK mode count as two.)  Normally that's what we want.
 *   They count actual glyphs if count_gcells is unset. (Full-width
 *   characters in CJK mode count as one.)
d5275 1
a5275 1
 *  It is a case insensitive search. - KW & FM
d5277 6
a5282 7
PUBLIC char * LYno_attr_mbcs_case_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
	BOOL,		utf_flag,
	BOOL,		count_gcells,
	int *,		nstartp,
	int *,		nendp)
d5284 2
a5285 2
    char *tmpchptr;
    CONST char *tmptarptr;
d5290 1
a5290 1
	return(NULL);
d5293 1
a5293 1
     *	Skip initial IsSpecial chars. - FM
d5299 1
a5299 1
     *	Seek a first target match. - FM
d5304 1
a5304 2
	     *(chptr + 1) != '\0' &&
	     !IsSpecialAttrChar(*(chptr + 1))) ||
d5307 1
d5312 1
a5312 1
	     *	See if they line up.
d5319 1
a5319 1
		 *  One char target.
d5321 5
a5325 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
d5328 2
a5329 3
		 *chptr == *tarptr &&
		 *tmpchptr != '\0' &&
		 !IsSpecialAttrChar(*tmpchptr)) {
d5331 1
a5331 1
		 *  Check the CJK multibyte. - FM
d5335 1
a5335 1
		     *	It's a match.  Advance to next char. - FM
d5339 2
a5340 1
		    if (count_gcells) tarlen++;
d5343 1
a5343 1
			 *  One character match. - FM
d5345 5
a5349 3
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
			return(chptr);
d5353 2
a5354 2
		     *	It's not a match, so go back to
		     *	seeking a first target match. - FM
d5357 2
a5358 1
		    if (count_gcells) len++;
d5363 1
a5363 1
	     *	See if the rest of the target matches. - FM
d5373 2
a5374 1
			    if (count_gcells) tarlen++;
d5393 5
a5397 3
		    if (nstartp)	*nstartp = offset;
		    if (nendp)		*nendp = len + tarlen;
		    return(chptr);
d5403 1
a5403 1
		      IsSpecialAttrChar(*chptr))) {
d5405 1
a5405 2
		*(chptr + 1) != '\0' &&
		!IsSpecialAttrChar(*(chptr + 1))) {
d5407 2
a5408 1
		if (count_gcells) len++;
d5412 1
a5412 1
    } /* end for */
d5414 1
a5414 1
    return(NULL);
d5418 13
a5430 10
 * LYno_attr_mbcs_strstr will find the first occurrence of the string
 * pointed to by tarptr in the string pointed to by chptr.
 *  It takes account of CJK and MultiByte Character Sequences (UTF8).
 *  The physical lengths of the displayed string up to the start and
 *  end (= next position after) the target string are returned in *nstartp
 *  and *nendp if the search is successful.
 *    These lengths count glyph cells if count_gcells is set. (Full-width
 *    characters in CJK mode count as two.)  Normally that's what we want.
 *    They count actual glyphs if count_gcells is unset. (Full-width
 *    characters in CJK mode count as one.)
d5438 1
a5438 1
 *  It is a case sensitive search. - KW & FM
d5440 6
a5445 7
PUBLIC char * LYno_attr_mbcs_strstr ARGS6(
	char *,		chptr,
	CONST char *,	tarptr,
	BOOL,		utf_flag,
	BOOL,		count_gcells,
	int *,		nstartp,
	int *,		nendp)
d5447 2
a5448 2
    char *tmpchptr;
    CONST char *tmptarptr;
d5453 1
a5453 1
	return(NULL);
d5456 1
a5456 1
     *	Skip initial IsSpecial chars. - FM
d5462 1
a5462 1
     *	Seek a first target match. - FM
d5467 1
d5472 1
a5472 1
	     *	See if they line up.
d5479 1
a5479 1
		 *  One char target.
d5481 5
a5485 3
		if (nstartp)	*nstartp = offset;
		if (nendp)	*nendp = len;
		return(chptr);
d5488 1
a5488 2
		 *tmpchptr != '\0' &&
		 !IsSpecialAttrChar(*tmpchptr)) {
d5490 1
a5490 1
		 *  Check the CJK multibyte. - FM
d5494 1
a5494 1
		     *	It's a match.  Advance to next char. - FM
d5498 2
a5499 1
		    if (count_gcells) tarlen++;
d5502 1
a5502 1
			 *  One character match. - FM
d5504 5
a5508 3
			if (nstartp)	*nstartp = offset;
			if (nendp)	*nendp = len + tarlen;
			return(chptr);
d5512 2
a5513 2
		     *	It's not a match, so go back to
		     *	seeking a first target match. - FM
d5516 2
a5517 1
		    if (count_gcells) len++;
d5522 1
a5522 1
	     *	See if the rest of the target matches. - FM
d5525 1
a5525 1
		 if (!IsSpecialAttrChar(*tmpchptr)) {
d5532 2
a5533 1
			    if (count_gcells) tarlen++;
d5546 1
a5546 1
		 } else {
d5548 1
a5548 1
		 }
d5550 7
a5556 5
		 if (*tmptarptr == '\0') {
		     if (nstartp)	*nstartp = offset;
		     if (nendp)		*nendp = len + tarlen;
		     return(chptr);
		 }
d5558 1
a5558 1
		     break;
d5561 1
a5561 1
		      IsSpecialAttrChar(*chptr))) {
d5563 1
a5563 2
		*(chptr + 1) != '\0' &&
		!IsSpecialAttrChar(*(chptr + 1))) {
d5565 2
a5566 1
		if (count_gcells) len++;
d5570 1
a5570 1
    } /* end for */
d5572 1
a5572 1
    return(NULL);
d5576 1
a5576 1
 *  Allocate a new copy of a string, and returns it.
d5578 3
a5580 4
PUBLIC char * SNACopy ARGS3(
	char **,	dest,
	CONST char *,	src,
	int,		n)
d5585 1
d5590 2
a5591 2
	strncpy (*dest, src, n);
	*(*dest + n) = '\0'; /* terminate */
d5597 1
a5597 1
 *  String Allocate and Concatenate.
d5599 3
a5601 4
PUBLIC char * SNACat ARGS3(
	char **,	dest,
	CONST char *,	src,
	int,		n)
d5606 2
a5607 1
	    *dest = (char *)realloc(*dest, length + n + 1);
d5611 1
a5611 1
	    *(*dest + length + n) = '\0'; /* terminate */
d5614 1
d5618 1
a5618 1
	    (*dest)[n] = '\0'; /* terminate */
d5630 1
a5630 1
PRIVATE long UniToLowerCase ARGS1(long, upper)
d5636 1
a5636 1
     *	Make check for sure.
d5639 1
a5639 1
	return(upper);
d5642 1
a5642 1
     *	Try unicode_to_lower_case[].
d5648 3
a5650 3
	**  Binary search.
	*/
	i = (low + (high-low)/2);
d5653 1
a5653 1
	    low = i+1;
d5660 1
a5660 1
    return(upper); /* if we came here */
d5664 13
a5676 13
**   UPPER8 ?
**   it was "TOUPPER(a) - TOUPPER(b)" in its previous life...
**
**   It was realized that case-insensitive user search
**   got information about upper/lower mapping from TOUPPER
**   (precisely from "(TOUPPER(a) - TOUPPER(b))==0")
**   and depends on locale in its 8bit mapping. -
**   Usually fails with DOS/WINDOWS display charsets
**   as well as on non-UNIX systems.
**
**   So use unicode case mapping.
*/
PUBLIC int UPPER8 ARGS2(int,ch1, int,ch2)
d5688 1
a5688 1
	return(TOUPPER(ch1) - TOUPPER(ch2));
d5691 2
a5692 3
    if (UCH(TOASCII(ch1)) > 127 &&  /* S/390 -- gil -- 2066 */
	UCH(TOASCII(ch2)) > 127)
    {
d5694 3
a5696 4
	   return(TOUPPER(ch1) - TOUPPER(ch2)); /* old-style */
	else
	{
	    long uni_ch2 = UCTransToUni((char)ch2, current_char_set);
d5698 1
d5701 2
a5702 2
	    uni_ch1 = UCTransToUni((char)ch1, current_char_set);
	    return(UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
d5706 1
a5706 1
    return(-10);  /* mismatch, if we come to here */
d5714 2
a5715 3
PUBLIC char *LYSafeGets ARGS2(
	char **,	src,
	FILE *,		fp)
d5735 2
a5736 3
	 *  If the file ends in the middle of a line, return the
	 *  partial line; if another call is made after this, it
	 *  will return NULL. - kw
d5746 2
a5747 2
PRIVATE FILE *cmd_logfile;
PRIVATE FILE *cmd_script;
d5749 2
a5750 3
PUBLIC void LYOpenCmdLogfile ARGS2(
	int,		argc,
	char **,	argv)
d5758 1
a5758 1
		LYNX_NAME, LYNX_VERSION, LYVersionDate());
d5766 1
a5766 1
PUBLIC BOOL LYHaveCmdScript NOARGS
d5768 1
a5768 1
    return (BOOL)(cmd_script != 0);
d5771 1
a5771 1
PUBLIC void LYOpenCmdScript NOARGS
d5781 1
a5781 2
PUBLIC int LYReadCmdKey ARGS1(
	int,	mode)
d5798 1
a5798 1
		    exit(0);
d5833 2
a5834 1
    CTRACE((tfp, "LYReadCmdKey(%d) ->%s (%#x)\n", mode, LYKeycodeToString(ch, TRUE), ch));
d5842 1
a5842 2
PUBLIC void LYWriteCmdKey ARGS1(
	int,	ch)
d5849 1
a5849 1
PUBLIC void LYCloseCmdLogfile NOARGS
@


1.6
log
@update to lynx2.8.5rel.4; fixes CAN-2005-3120 among other things.
prompted by naddy@@, cloder@@ ok.
@
text
@d5615 1
a5615 1
    while (fgets(buffer, sizeof(buffer), fp) != 0) {
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d1049 1
a1049 1
	int keysym;
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d37 4
a43 2
extern BOOL HTPassHighCtrlRaw;

d247 1
a247 1
#endif	/* _WINDOWS */
d329 1
a329 1

d391 4
d428 1
a428 1
    } else if (x == LYcols - 1 && LYsb && LYsb_begin >= 0) {
d461 2
d465 1
a465 1
		&& F_TEXTLIKE(links[i].form->type))
a467 5
	    if (is_text)
		len = links[i].form->size;
	    else
		len = strlen(links[i].hightext );

d469 5
a473 1
	    if ( links[i].hightext != NULL) {
d476 3
a478 2
		if (cur_err > 0 && links[i].hightext2 != NULL) {
		    /* Note that there is never hightext2 if is_text */
d480 3
a482 3
					   links[i].hightext2_offset,
					   links[i].ly+1,
					   strlen(links[i].hightext2));
d495 1
a495 1
			links[i].form->type == F_TEXT_SUBMIT_TYPE) {
d541 13
d557 1
a557 2


d672 1
a672 1
    if (!str && *str)
d691 1
a691 1
		   !isascii(str[i]) && str[(i + 1)] != '\0' &&
d723 1
a723 1
#define GetChar() wgetch(my_subwindow ? my_subwindow : LYwin)
d726 1
a726 1
#if !defined(GetChar) && defined(PDCURSES)
d765 1
a765 1
#if HAVE_KEYPAD
a774 31
/*
 * Workaround a bug in ncurses order-of-refresh by setting a pointer to
 * the topmost window that should be displayed.
 *
 * FIXME: the associated call on 'keypad()' is not needed for Unix, but
 * something in the OS/2 EMX port requires it.
 */
#ifndef USE_SLANG
PRIVATE WINDOW *my_subwindow;

PUBLIC void LYsubwindow ARGS1(WINDOW *, param)
{
    if (param != 0) {
	my_subwindow = param;
#if defined(NCURSES) || defined(PDCURSES)
	keypad(my_subwindow, TRUE);
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
	wbkgd(my_subwindow, getbkgd(LYwin));
	wbkgdset(my_subwindow, getbkgd(LYwin));
#endif
#endif
	scrollok(my_subwindow, TRUE);
    } else {
	touchwin(LYwin);
	delwin(my_subwindow);
	my_subwindow = 0;
    }
}
#endif


d819 3
d1319 12
d1524 22
a1545 1
   if ((key == NULL) || (key->type != SLKEY_F_KEYSYM))
d1547 1
d1673 1
a1673 1
#if HAVE_SIZECHANGE || defined(USE_SLANG)
a1735 1
	case 'x': c = UPARROW; break;	/* keypad up on pc ncsa telnet */
a1736 1
	case 'r': c = DNARROW; break;	/* keypad down on pc ncsa telnet */
a1737 1
	case 'v': c = RTARROW; break;	/* keypad right on pc ncsa telnet */
d1739 8
a1746 5
	case 't': c = LTARROW; break;	/* keypad left on pc ncsa telnet */
	case 'y': c = PGUP;    break;	/* keypad on pc ncsa telnet */
	case 's': c = PGDOWN;  break;	/* keypad on pc ncsa telnet */
	case 'w': c = HOME;    break;	/* keypad on pc ncsa telnet */
	case 'q': c = END_KEY; break;	/* keypad on pc ncsa telnet */
d1893 1
a1893 1
#if HAVE_KEYPAD
d2031 1
a2031 1
#if HAVE_SIZECHANGE || defined(USE_SLANG)
d2163 1
a2163 1
				 F_TEXTLIKE(links[mouse_link].form->type))
a2184 2
	/* _WINDOWS 1997/10/18 (Sat) 19:41:59 */

d2201 1
a2201 33
		if (system_is_NT) {
		/* for Windows NT */
		  request_mouse_pos();

		  if (BUTTON_STATUS(1) & BUTTON_PRESSED) {
			if (MOUSE_Y_POS > (LYlines - V_CMD_AREA)) {
			    /* Screen BOTTOM */
			    if (MOUSE_X_POS < left) {
				c = LTARROW;		p = "<-";
			    } else if (MOUSE_X_POS < HIST_CMD_2) {
				c = RTARROW;		p = "->";
			    } else if (MOUSE_X_POS > right) {
				c = 'z';		p = "Cancel";
			    } else {
				c = PGDOWN;		p = "PGDOWN";
			    }
			} else if (MOUSE_Y_POS < V_CMD_AREA) {
			    /* Screen TOP */
			    if (MOUSE_X_POS < left) {
				c = LTARROW;		p = "<-";
			    } else if (MOUSE_X_POS < HIST_CMD_2) {
				c = RTARROW;		p = "->";
			    } else if (MOUSE_X_POS > right) {
				c = 'z';		p = "Cancel";
			    } else {
				c = PGUP;		p = "PGUP";
			    }
			} else {
			    c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL, 1);
			}
		    }
		} else {
		    /* for Windows 95 */
d2211 5
a2215 2
		    request_mouse_pos();
		    if (MOUSE_Y_POS > (LYlines - V_CMD_AREA)) {
d2222 1
a2222 1
			    c = '\b';		p = "History";
d2429 2
a2430 1
	if (buffer[i] & 0x80) {
d2455 2
a2456 1
	if (buffer[i] & 0x80) {
d2471 1
a2471 1
 * Remove ALL whitespace from a string (including embedded blanks).
d2473 1
a2473 1
PUBLIC void LYRemoveBlanks ARGS1(
d2477 13
a2489 5
	size_t i, j;
	for (i = j = 0; buffer[i]; i++)
	    if (!isspace(UCH((buffer[i]))))
		buffer[j++] = buffer[i];
	buffer[j] = 0;
d2491 26
d2575 12
d2633 2
a2634 2
    if (!strncasecomp(buffer, "lynxexec:", 9) ||
	!strncasecomp(buffer, "lynxprog:", 9)) {
d2757 2
a2758 2
	    if (!(isascii(c) ||
		  ((kanji_code == SJIS) && IS_SJIS_X0201KANA(UCH(c))))) {
d2991 1
a2991 1
		   (HTCJK == NOCJK || isascii(Buf[pos0])) &&
d2996 2
a2997 2
	    if (HTCJK != NOCJK && !isascii(Buf[pos0])) {
		while (Pos && !isascii(Buf[pos0])) {
d3003 1
a3003 1
		 && isascii(UCH(Buf[pos0]))
d3023 2
a3024 2
	if (HTCJK != NOCJK && !isascii(Buf[Pos])) {
	    while (!isascii(Buf[Pos]))
d3027 1
a3027 1
	    while (isascii(UCH(Buf[Pos])) && isalnum(UCH(Buf[Pos])))
d3030 1
a3030 1
	while ((HTCJK == NOCJK || isascii(UCH(Buf[Pos]))) &&
d3117 1
a3117 1
	if (HTCJK != NOCJK && !isascii(Buf[Pos]))
d3177 1
a3177 1
	    if (HTCJK != NOCJK && !isascii(Buf[Pos-1]))
d3434 1
a3434 1
		    if (!isascii(Buf[DspStart]))
d3456 1
a3456 1
		if (!isascii(Buf[DspStart]))
d3470 1
a3470 1
    if (HTCJK != NOCJK && !isascii(str[0]))
d3528 1
a3528 2
		if (HTCJK != NOCJK && !isascii(buffer[0])) {
#ifndef SUPPORT_MULTIBYTE_EDIT
d3531 13
a3543 6
#else /* SUPPORT_MULTIBYTE_EDIT */
		    if (i < (nrdisplayed - 1)) {
			buffer[1] = str[++i];
			end_multi = 1;
		    } else
			end_multi = 0;
a3605 6
#ifdef SUPPORT_MULTIBYTE_EDIT
#if (!USE_SLANG && !defined(USE_MULTIBYTE_CURSES))
    if (HTCJK != NOCJK)
	lynx_force_repaint();
#endif /* !USE_SLANG && !defined(USE_MULTIBYTE_CURSES) */
#endif /* SUPPORT_MULTIBYTE_EDIT */
d4465 1
a4465 1
			LYstrncpy(prev_target_buffer, cp, sizeof(prev_target_buffer));
a4830 6
#ifdef USE_SLANG
		    old_y = SLsmg_get_row();
		    old_x = SLsmg_get_column();
#else
		    getyx(LYwin, old_y, old_x);
#endif
d4832 1
a4847 3
#ifdef USE_SLANG
		    SLsmg_gotorc(old_y, old_x);
#else
a4848 1
#endif
d4888 1
a4888 1
		unsigned char *s = get_clip_grab(), *e;
d4893 1
a4893 1
		len = strlen(s);
d4905 1
a4905 1
				LYEditInsert(&MyEdit, " ", 1, map_active, TRUE);
d5010 1
d5020 1
a5020 1
    if (!stringp || !*stringp)		/* nothing to do? */
d5210 1
a5210 1
	if ((!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5233 1
a5233 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5270 1
a5270 1
		    if (!utf_flag && HTCJK != NOCJK && !isascii(*tmpchptr)) {
d5304 1
a5304 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5382 1
a5382 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5418 1
a5418 1
		    if (!utf_flag && HTCJK != NOCJK && !isascii(*tmpchptr)) {
d5451 1
a5451 1
	    if (!utf_flag && HTCJK != NOCJK && !isascii(*chptr) &&
d5474 1
a5474 1
	*dest = typecallocn(char, n + 1);
d5476 1
a5476 1
	    CTRACE((tfp, "Tried to calloc %d bytes\n", n));
d5493 1
a5493 1
    if (src && *src) {
d5502 1
a5502 1
	    *dest = typecallocn(char, n + 1);
a5635 68
#ifdef EXP_FILE_UPLOAD
static char basis_64[] =
   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

#define B64_LINE       76

PUBLIC void base64_encode ARGS3(
    char *,	dest,
    char *,	src,
    int,	len)
{
    int rlen;   /* length of result string */
    unsigned char c1, c2, c3;
    char *eol, *r, *str;
    int eollen;
    int chunk;

    str = src;
    eol = "\n";
    eollen = 1;

    /* calculate the length of the result */
    rlen = (len+2) / 3 * 4;	/* encoded bytes */
    if (rlen) {
	/* add space for EOL */
	rlen += ((rlen-1) / B64_LINE + 1) * eollen;
    }

    /* allocate a result buffer */
    r = dest;

    /* encode */
    for (chunk=0; len > 0; len -= 3, chunk++) {
	if (chunk == (B64_LINE/4)) {
	    char *c = eol;
	    char *e = eol + eollen;
	    while (c < e)
		*r++ = *c++;
	    chunk = 0;
	}
	c1 = *str++;
	c2 = *str++;
	*r++ = basis_64[c1>>2];
	*r++ = basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];
	if (len > 2) {
	    c3 = *str++;
	    *r++ = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
	    *r++ = basis_64[c3 & 0x3F];
	} else if (len == 2) {
	    *r++ = basis_64[(c2 & 0xF) << 2];
	    *r++ = '=';
	} else { /* len == 1 */
	    *r++ = '=';
	    *r++ = '=';
	}
    }
    if (rlen) {
	/* append eol to the result string */
	char *c = eol;
	char *e = eol + eollen;
	while (c < e)
	    *r++ = *c++;
    }
    *r = '\0';  /* every SV in perl should be NUL-terminated */
}

#endif /* EXP_FILE_UPLOAD */

d5682 1
d5684 1
a5684 1
	while (LYSafeGets(&buffer, cmd_script) != 0) {
d5688 23
a5710 6
	    if (tmp - src != 3
	     || strncasecomp(src, "key", 3))
		continue;
	    src = LYSkipBlanks(tmp);
	    if ((ch = LYStringToKeycode(src)) >= 0) {
		LYrefresh();
d5714 8
d5726 1
a5726 1
    CTRACE((tfp, "LYReadCmdKey(%d) ->%c (%#x)\n", mode, ch, ch));
@


1.3
log
@Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@d3 2
a6 1
#include <LYGlobalDefs.h>
d17 1
d19 3
d33 5
a39 1
extern unsigned short *LYKbLayout;
a40 1
extern HTCJKlang HTCJK;
d42 9
a50 2
/*Allowing the user to press tab when entering URL to get the closest
  match in the closet*/
a51 2
static char* LYCloset[LYClosetSize]; /* Closet with LYClosetSize shelves */
static int LYClosetTop = 0;		/*Points to the next empty shelf */
d53 2
a54 4
PRIVATE char *LYFindInCloset PARAMS((
	char*		base));
PRIVATE int LYAddToCloset PARAMS((
	char*		str));
d72 1
a72 1
#ifdef NCURSES_MOUSE_VERSION
d79 2
a80 2
#ifdef NCURSES_MOUSE_VERSION
    if (have_levent) {
d82 1
d106 1
d113 43
a155 6
#ifdef NCURSES_MOUSE_VERSION
#ifndef getbegx
#define getbegx(win) ((win)->_begx)
#endif
#ifndef getbegy
#define getbegy(win) ((win)->_begy)
d157 16
d177 2
a178 4
		       | BUTTON1_DOUBLE_CLICKED
		       | BUTTON1_TRIPLE_CLICKED))
    && (event.x >= getbegx(win)
    && (event.x < (getbegx(win) + getmaxx(win))))) {
d182 3
d218 8
d230 4
a238 9
#if 0
	    /* Immediate action looks reasonable since we have no help
	     * available for individual options.  Moreover, one can position
	     * active element with shift-click-1.  (;-)
	     */
	    if (!(event.bstate & (BUTTON1_DOUBLE_CLICKED
				| BUTTON1_TRIPLE_CLICKED)))
		goto redraw;
#endif
d244 5
a248 1
#endif
d252 76
d335 1
a335 1
    int xerr = x2 - x1, yerr = y2 - y1;
d338 1
a338 1
	xerr = x1 - x2 - dx2;
d343 18
a360 1
    return xerr + yerr;
d370 1
a370 1
PRIVATE int set_clicked_link ARGS3(
d373 2
a374 1
    int,	code)
d382 4
a385 1
    if (y == (LYlines-1)) {
d387 38
a424 4
	if (x < left) c = LTARROW;
	else if (x > right) c = '\b';
	else c = PGDOWN;
    } else if (y == 0) {
d426 22
a447 3
	if (x < left) c = LTARROW;
	else if (x > right) c = '\b';
	else c = PGUP;
d449 2
a450 1
	int mouse_err = -1, cur_err;
d457 1
a457 3
		/* XXXX What else? */
		&& (links[i].form->type == F_TEXTAREA_TYPE
		 || links[i].form->type == F_TEXT_TYPE))
d468 12
d484 16
d503 1
a503 1
			if (is_text)
d505 5
a519 15
	    /* Check the second line */
	    if (links[i].hightext2 != NULL) {
		cur_err = XYdist(x, y,
				 links[i].hightext2_offset,
				 links[i].ly+1,
				 strlen(links[i].hightext2));
		if (cur_err == 0) {
		    mouse_link = i;
		    mouse_err = 0;
		    break;
		} else if (cur_err < mouse_err) {
		    mouse_err = cur_err;
		    mouse_link = i;
		}
	    }
d527 5
a531 4
	    if (mouse_err == 0)
		c = lookup_keymap(LYK_ACTIVATE);
	    else if (mouse_err >= 0)
		c = lookup_keymap(LYK_CHANGE_LINK);
a537 14
/*
 *  LYstrerror emulates the ANSI strerror() function.
 */
#ifdef LYStrerror
    /* defined as macro in .h file. */
#else
PUBLIC char *LYStrerror ARGS1(int, code)
{
    static char temp[80];
    sprintf(temp, "System errno is %d.\r\n", code);
    return temp;
}
#endif /* HAVE_STRERROR */

d544 1
a544 1
	char *, 	dst,
d566 2
a567 2
#define IS_NEW_GLYPH(ch) (utf_flag && ((unsigned char)(ch)&0xc0) != 0x80)
#define IS_UTF_EXTRA(ch) (utf_flag && ((unsigned char)(ch)&0xc0) == 0x80)
d577 1
a577 1
	char *, 	dst,
d611 1
a611 1
	char *, 	data,
d640 4
d645 4
a648 3
PUBLIC int LYmbcsstrlen ARGS2(
	char *, 	str,
	BOOL,		utf_flag)
d670 2
a671 2
	} else if (!utf_flag && HTCJK != NOCJK && !isascii(str[i]) &&
		    str[(i + 1)] != '\0' &&
d693 3
d697 1
d703 31
a733 1
#define GetChar() wgetch(my_subwindow ? my_subwindow : stdscr)
d737 1
a737 1
#define GetChar() wgetch(stdscr)
d746 1
a746 1
#define GetChar getch
a754 1
#if defined(NCURSES)
d762 1
d767 15
a781 2
    if ((my_subwindow = param) != 0)
	keypad(param, TRUE);
d785 2
a786 1
#ifdef USE_SLANG_MOUSE
d806 10
a815 2
    *x = SLang_getkey () - 33;
    *y = SLang_getkey () - 33;
d819 2
a820 1
PRIVATE int sl_read_mouse_event NOARGS
d828 1
a828 1
	  return set_clicked_link (mouse_x, mouse_y, FOR_PANEL);
d839 4
a842 1
   return -1;
d844 2
a845 1
#endif
d859 2
a860 2
#define expand_substring(dst, first, last) \
	SLexpand_escaped_string(dst, first, last)
d863 1
a863 1
#define MOUSE_KEYSYM 0x1000
a865 1

d877 6
a882 1
#define DEFINE_KEY(string,lynx,curses) {string,lynx}
d884 2
a885 1
#define DEFINE_KEY(string,lynx,curses) {string,curses}
d888 1
d898 16
a913 16
    DEFINE_KEY( "UPARROW",	UPARROW,	KEY_UP ),
    DEFINE_KEY( "DNARROW",	DNARROW,	KEY_DOWN ),
    DEFINE_KEY( "RTARROW",	RTARROW,	KEY_RIGHT ),
    DEFINE_KEY( "LTARROW",	LTARROW,	KEY_LEFT ),
    DEFINE_KEY( "PGDOWN",	PGDOWN,		KEY_NPAGE ),
    DEFINE_KEY( "PGUP",		PGUP,		KEY_PPAGE ),
    DEFINE_KEY( "HOME",		HOME,		KEY_HOME ),
    DEFINE_KEY( "END",		END_KEY,	KEY_END ),
    DEFINE_KEY( "F1",		F1,		KEY_F(1) ),
    DEFINE_KEY( "DO_KEY",	DO_KEY,		KEY_F(16) ),
    DEFINE_KEY( "FIND_KEY",	FIND_KEY,	KEY_FIND ),
    DEFINE_KEY( "SELECT_KEY",	SELECT_KEY,	KEY_SELECT ),
    DEFINE_KEY( "INSERT_KEY",	INSERT_KEY,	KEY_IC ),
    DEFINE_KEY( "REMOVE_KEY",	REMOVE_KEY,	KEY_DC ),
    DEFINE_KEY( "DO_NOTHING",	DO_NOTHING,	0 ),
    DEFINE_KEY( NULL, 		-1,		ERR )
d931 1
a931 1
PRIVATE char *expand_tiname (char *first, size_t len, char **result)
d941 1
a941 1
	    strcpy(*result, cur_term->type.Strings[code]);
d948 1
a948 1
PRIVATE char *expand_tichar (char *first, char **result)
d979 6
a984 6
	char *last;
	int save = first[limit];
	first[limit] = '\0';
	value = strtol(first, &last, radix);
	first[limit] = save;
	first = last;
d988 1
a988 1
	(void) expand_tiname(name, strlen(name), result);
d997 1
a997 1
PRIVATE void expand_substring (char* dst, char* first, char* last)
d1000 1
d1004 1
a1004 1
	    first = expand_tichar(first, &dst);
d1009 2
a1010 1
		char *s = strchr(first, RPAREN);
d1013 3
a1015 1
		first = expand_tiname(first, s-first, &dst);
d1036 1
d1040 1
a1040 1
PRIVATE void unescaped_char ARGS2(char*, parse, int*,keysym)
d1046 1
a1046 1
	expand_substring(buf, parse + 1, parse + len - 1);
d1052 1
a1052 1
PRIVATE BOOLEAN unescape_string ARGS2(char*, src, char *, dst)
d1064 2
a1065 4
    } else if (*src == DQUOTE) {
	expand_substring(dst, src + 1, src + strlen(src) - 1);
	ok = TRUE;
    }
d1069 1
a1069 1
PRIVATE int map_string_to_keysym ARGS2(char*, str, int*,keysym)
d1071 1
d1074 45
d1121 1
a1121 1
    } else if (isdigit(*str)) {
d1124 1
a1124 1
	if (!isalnum(*tmp))
d1126 5
d1144 2
d1171 1
a1171 1
	} else if (isspace(*parse)) {
d1189 1
d1191 1
a1191 1
	if (isspace(*s)) {
d1194 2
a1195 1
	    if ((t = skip_keysym(s)) == 0)
d1197 1
d1200 10
a1209 2
	    if (map_string_to_keysym (s, &keysym) >= 0
	     && unescape_string(parse, buf)) {
d1212 3
d1216 6
a1272 1
    int ret;
d1282 1
a1282 3
    ret = 0;
    while (LYSafeGets(&line, fp) != 0 && (ret == 0))
    {
d1292 4
a1295 7
	    if (strlen(s) > len
	     && !strncmp(s, table[n].name, len)) {
		if ((*(table[n].func))(LYSkipBlanks(s+len)) < 0) {
		    ret = -1;
		    break;
		}
	    }
d1299 2
a1300 7

    fclose (fp);

    if (ret == -1)
	fprintf (stderr, FAILED_READING_KEYMAP, linenum, file);

    return ret;
d1306 37
a1342 20
	DEFINE_KEY( "\033[A",	UPARROW,	KEY_UP ),
	DEFINE_KEY( "\033OA",	UPARROW,	KEY_UP ),
	DEFINE_KEY( "\033[B",	DNARROW,	KEY_DOWN ),
	DEFINE_KEY( "\033OB",	DNARROW,	KEY_DOWN ),
	DEFINE_KEY( "\033[C",	RTARROW,	KEY_RIGHT ),
	DEFINE_KEY( "\033OC",	RTARROW,	KEY_RIGHT ),
	DEFINE_KEY( "\033[D",	LTARROW,	KEY_LEFT ),
	DEFINE_KEY( "\033OD",	LTARROW,	KEY_LEFT ),
	DEFINE_KEY( "\033[1~",	FIND_KEY,	KEY_FIND ),
	DEFINE_KEY( "\033[2~",	INSERT_KEY,	KEY_IC ),
	DEFINE_KEY( "\033[3~",	REMOVE_KEY,	KEY_DC ),
	DEFINE_KEY( "\033[4~",	SELECT_KEY,	KEY_SELECT ),
	DEFINE_KEY( "\033[5~",	PGUP,		KEY_PPAGE ),
	DEFINE_KEY( "\033[6~",	PGDOWN,		KEY_NPAGE ),
	DEFINE_KEY( "\033[8~",	END_KEY,	KEY_END ),
	DEFINE_KEY( "\033[7~",	HOME,		KEY_HOME),
	DEFINE_KEY( "\033[28~",	F1,		KEY_F(1) ),
	DEFINE_KEY( "\033OP",	F1,		KEY_F(1) ),
	DEFINE_KEY( "\033[OP",	F1,		KEY_F(1) ),
	DEFINE_KEY( "\033[29~",	DO_KEY,		KEY_F(16) ),
d1346 1
a1346 1
    	define_key(table[n].string, table[n].value);
d1355 5
d1373 2
a1374 4
    if (SLang_Error
    || (-1 == read_keymap_file ()))
    SLang_exit_error ("Unable to initialize keymaps");
    return 0;
d1377 1
a1378 1
#endif
d1383 3
a1385 2
#ifdef NCURSES_MOUSE_VERSION
PRIVATE int LYmouse_menu ARGS3(int, x, int, y, int, atlink)
d1387 33
a1419 25
    static char *choices[] = {
	"Quit",
	"Home page",
	"Previous document",
	"Beginning of document",
	"Page up",
	"Half page up",
	"Two lines up",
	"History",
	"Help",
	"Do nothing (refresh)",
	"Load again",
	"Edit URL and load",
	"Show info",
	"Search",
	"Print",
	"Two lines down",
	"Half page down",
	"Page down",
	"End of document",
	"Bookmarks",
 	"Cookie jar",
	"Search index",
	"Set Options",
	NULL
d1421 15
a1435 41
    static char *choices_link[] = {
	"Help",
	"Do nothing",
	"Activate this link",
	"Show info",
	"Download",
	NULL
    };
    static int actions[] = {
	LYK_ABORT,
	LYK_MAIN_MENU,
	LYK_PREV_DOC,
	LYK_HOME,
	LYK_PREV_PAGE,
	LYK_UP_HALF,
	LYK_UP_TWO,
	LYK_HISTORY,
	LYK_HELP,
	LYK_REFRESH,
	LYK_RELOAD,
	LYK_ECGOTO,
	LYK_INFO,
	LYK_WHEREIS,
	LYK_PRINT,
	LYK_DOWN_TWO,
	LYK_DOWN_HALF,
	LYK_NEXT_PAGE,
	LYK_END,
	LYK_VIEW_BOOKMARK,
 	LYK_COOKIE_JAR,
	LYK_INDEX_SEARCH,
	LYK_OPTIONS
    };
    static int actions_link[] = {
	LYK_HELP,
	LYK_REFRESH,
	LYK_ACTIVATE,
	LYK_INFO,
	LYK_DOWNLOAD
    };
    int c;
d1439 16
a1454 5
    c = popup_choice((atlink ? 2 : 9) - 1, y, (x >= 5 ? x-5 : 0),
		     (atlink ? choices_link : choices),
		     (atlink
		      ? (sizeof(actions_link)/sizeof(int))
		      : (sizeof(actions)/sizeof(int))), FALSE);
d1456 38
a1493 1
    return atlink ? (actions_link[c]) : (actions[c]);
d1495 2
a1496 1
#endif
d1499 3
d1506 4
a1509 1
   return GetChar();
d1512 2
a1513 1
PUBLIC int LYgetch NOARGS
d1517 1
d1521 1
a1521 1
     return DO_NOTHING;
d1525 1
a1525 1
#if defined (USE_SLANG_MOUSE)
d1527 1
a1527 1
     return sl_read_mouse_event ();
d1530 13
a1542 1
   if ((keysym+1 >= KEYMAP_SIZE) || (keysym < 0))
d1545 1
a1545 1
   return keysym;
d1548 2
a1549 5
PUBLIC int LYgetch_for ARGS1(
	int, 	code)
{
    return LYgetch();
}
a1550 1
#else	/* NOT  defined(USE_KEYMAPS) && defined(USE_SLANG) */
d1557 2
a1558 7
PUBLIC int LYgetch NOARGS
{
    return LYgetch_for(FOR_PANEL);
}

PUBLIC int LYgetch_for ARGS1(
	int, 	code)
d1561 2
a1565 1
#if defined(IGNORE_CTRL_C) || defined(USE_GETCHAR) || !defined(NCURSES)
d1567 4
a1570 1
#endif /* IGNORE_CTRL_C || USE_GETCHAR */
d1576 1
d1580 1
d1590 2
a1591 1
	    return(7); /* use ^G to cancel whatever called us. */
d1596 45
d1644 19
d1673 1
a1673 1
	return(7); /* use ^G to cancel whatever called us. */
d1675 1
a1675 1
#else
d1678 1
a1678 1
	    return(7); /* use ^G to cancel whatever called us. */
d1692 1
a1692 1
	exit_immediately(0);
d1696 4
a1699 1
    if (c == CH_ESC || (csi_is_csi && c == (unsigned char)CH_ESC_PAR)) { /* handle escape sequence  S/390 -- gil -- 2024 */
d1710 1
a1710 1
	case 'x': c = UPARROW; break;  /* keypad up on pc ncsa telnet */
d1712 1
a1712 1
	case 'r': c = DNARROW; break; /* keypad down on pc ncsa telnet */
d1714 1
a1714 1
	case 'v': c = RTARROW; break; /* keypad right on pc ncsa telnet */
d1716 5
a1720 5
	case 't': c = LTARROW; break;  /* keypad left on pc ncsa telnet */
	case 'y': c = PGUP;    break;  /* keypad on pc ncsa telnet */
	case 's': c = PGDOWN;  break;  /* keypad on pc ncsa telnet */
	case 'w': c = HOME;    break;  /* keypad on pc ncsa telnet */
	case 'q': c = END_KEY; break;  /* keypad on pc ncsa telnet */
d1722 1
a1722 1
#ifdef USE_SLANG_MOUSE
d1725 1
a1725 1
		c = sl_read_mouse_event ();
d1729 1
a1729 1
	     c = '\n'; /* keypad enter on pc ncsa telnet */
d1736 1
a1736 1
		c = '-';  /* keypad on pc ncsa telnet */
d1740 3
a1742 1
		c = '+';  /* keypad + on my xterminal :) */
d1748 1
a1748 1
		c = '+';  /* keypad on pc ncsa telnet */
d1760 1
a1760 1
		c = F1;  /* macintosh help button */
d1766 1
a1766 1
		c = '0';  /* keypad 0 */
d1768 1
a1768 1
	case '1':			    /** VTxxx  Find  **/
d1771 2
d1789 2
d1795 2
d1801 2
d1807 2
d1813 2
d1822 1
d1824 8
a1831 1
	    CTRACE(tfp,"Unknown key sequence: %d:%d:%d\n",c,b,a);
d1837 22
d1860 7
a1867 1
    else {
d1881 14
a1894 1
	case KEY_RIGHT: 	   /* ... */
d1897 7
d1907 1
a1907 1
	case KEY_CLEAR: 	   /* Clear screen */
d1910 1
a1910 1
	case KEY_NPAGE: 	   /* Next page */
d1913 1
a1913 1
	case KEY_PPAGE: 	   /* Previous page */
d1919 1
d1939 1
d2003 48
d2055 2
a2056 2
	   c = 0x213;
	   break;
d2058 2
a2059 2
	   c = 0x214;
	   break;
d2061 2
a2062 2
	   c = 0x215;
	   break;
d2064 2
a2065 2
	   c = 0x216;
	   break;
d2067 2
a2068 2
	   c = 0x217;
	   break;
d2070 2
a2071 2
	   c = 0x218;
	   break;
d2073 5
a2077 1
#ifdef NCURSES_MOUSE_VERSION
d2079 1
d2082 10
a2091 2
	    } else {
#ifndef DOSPATH
d2094 1
d2099 4
d2105 1
a2105 1
		    c = set_clicked_link(event.x, event.y, code);
d2107 3
a2109 7
		    c = set_clicked_link(event.x, event.y, code);
		    if (c == PGDOWN)
			c = END_KEY;
		    else if (c == PGUP)
			c = HOME;
		    else if (c == LTARROW)
			c = LYReverseKeymap(LYK_MAIN_MENU);
d2111 10
a2120 1
		    c = LYReverseKeymap (LYK_PREV_DOC);
d2124 2
a2125 2
		    c = set_clicked_link(event.x, event.y, code);
		    atlink = c == LYReverseKeymap (LYK_ACTIVATE);
d2129 11
a2139 5
		    c = LYmouse_menu(event.x, event.y, atlink);
		    if (c == LYK_ACTIVATE && mouse_link == -1) {
			HTAlert("No link chosen");
			c = LYK_DO_NOTHING;
			c = LYK_REFRESH; /* refresh() below does not work... */
d2141 6
a2146 1
		    c = LYReverseKeymap(c);
d2148 2
a2149 1
		    refresh();
d2151 2
a2152 1
		if (code == FOR_INPUT && mouse_link == -1) {
d2154 1
a2154 1
		    getch();		/* ungetmouse puts KEY_MOUSE back */
d2158 16
d2176 69
a2244 5
		request_mouse_pos();
		if (BUTTON_STATUS(1) & BUTTON_CLICKED) {
		    c = set_clicked_link(MOUSE_X_POS, MOUSE_Y_POS, FOR_PANEL);
		} else if (BUTTON_STATUS(3) & BUTTON_CLICKED) {
		    c = LYReverseKeymap (LYK_PREV_DOC);
d2246 7
a2252 1
#endif /* DOSPATH */
d2255 5
a2259 1
#endif /* NCURSES_MOUSE_VERSION */
a2260 1
    }
a2262 1
    else {
d2276 1
a2276 1
	case K_Right: 		   /* ... */
d2284 1
a2284 1
	case K_PageDown: 	   /* Next page */
d2288 1
a2288 1
	case K_PageUp:	 	   /* Previous page */
a2319 1
    }
d2321 1
a2321 2
#if defined(USE_SLANG) && defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)  && !defined(USE_KEYMAPS)
    else {
d2332 1
a2332 1
	case SL_KEY_RIGHT: 	   /* ... */
d2339 1
a2339 1
	case SL_KEY_NPAGE: 	   /* Next page */
d2343 1
a2343 1
	case SL_KEY_PPAGE: 	   /* Previous page */
d2361 1
a2362 1
#endif /* USE_SLANG && __DJGPP__ && !DJGPP_KEYHANDLER && !USE_KEYMAPS */
d2364 2
d2374 1
a2374 1
	return(c);
d2378 1
d2381 42
d2427 1
a2427 1
	char *, 	buffer)
d2429 1
d2432 12
d2445 1
d2452 1
a2452 1
	char *, 	buffer)
d2454 1
d2457 14
a2470 1
	buffer[i] = TOUPPER(buffer[i]);
d2477 1
a2477 1
	char *, 	buffer)
d2482 1
a2482 1
	    if (!isspace((unsigned char)(buffer[i])))
d2492 1
a2492 1
	char *, 	buffer)
d2494 1
a2494 1
    while (isspace((unsigned char)(*buffer)))
d2503 1
a2503 1
	char *, 	buffer)
d2505 1
a2505 1
    while (*buffer != 0 && !isspace((unsigned char)(*buffer)))
d2516 1
a2516 1
    while (isspace((unsigned char)(*buffer)))
d2527 1
a2527 1
    while (*buffer != 0 && !isspace((unsigned char)(*buffer)))
d2536 1
a2536 1
	char *, 	buffer)
d2547 1
a2547 1
	char *, 	buffer)
d2550 1
a2550 1
    while (i != 0 && isspace((unsigned char)buffer[i-1]))
d2554 29
d2610 1
a2610 1
       char **,			buffer)
d2612 1
a2612 1
     if (!LYTrimStartfile(*buffer)) {
d2616 1
a2616 1
	}
d2623 1
a2623 1
       char *,         buffer)
d2626 1
a2626 1
       LYRemoveBlanks(buffer);
d2647 7
d2657 1
a2657 1
	char *, 	old,
d2668 1
a2669 1
    StrLen  = strlen(old);
d2674 3
d2694 51
d2746 74
a2819 13
     *	We expect the called function to pass us a default (old) value
     *	with a length that is less than or equal to maxstr, and to
     *	handle any messaging associated with actions to achieve that
     *	requirement.  However, in case the calling function screwed
     *	up, we'll check it here, and ensure that no buffer overrun can
     *	occur by loading only as much of the head as fits. - FM
     */
    if (strlen(old) >= (unsigned)maxstr) {
	strncpy(edit->buffer, old, maxstr);
	edit->buffer[maxstr] = '\0';
	StrLen = maxstr;
    } else {
	strcpy(edit->buffer, old);
d2821 23
d2852 2
a2853 1
     *         ch   otherwise
d2857 1
a2857 3
#ifdef EXP_KEYBOARD_LAYOUT
    static int map_active = 0;
#endif
d2874 1
d2882 4
a2885 2
	 if (HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 0x97)
	     return(ch);
d2887 5
a2891 6
#ifdef EXP_KEYBOARD_LAYOUT
	if (map_active && ch < 128 && ch >= 0 &&
	    LYKbLayouts[current_layout][ch])
	    ch = UCTransUniChar((long) LYKbLayouts[current_layout][ch],
		current_char_set);
#endif
d2893 7
a2899 1
	 *  ch is printable or ISO-8859-1 escape character.
d2901 4
d2906 8
d2917 1
a2917 1
	    Buf[Pos] = (unsigned char) ch;
d2919 2
a2920 1
	} else if (maxMessage) {
d2923 2
d2928 1
d2937 31
d2974 1
d2979 12
d2998 3
d3053 1
a3053 1
    case LYE_DELEL:
d3073 4
d3084 1
d3087 6
d3097 23
d3123 1
d3128 1
d3131 9
d3142 1
d3147 1
d3150 101
d3253 2
d3271 71
d3352 7
d3382 3
a3384 2
    if ((DspStart + DspWdth) <= length)
	if (Pos >= (DspStart + DspWdth) - Margin)
d3386 1215
d4602 7
a4608 5
    if (Pos < DspStart + Margin) {
	DspStart = Pos - Margin;
	if (DspStart < 0)
	    DspStart = 0;
    }
d4610 30
a4639 1
    str = &Buf[DspStart];
d4641 4
a4644 3
    nrdisplayed = length-DspStart;
    if (nrdisplayed > DspWdth)
	nrdisplayed = DspWdth;
d4646 14
a4659 36
    move(edit->sy, edit->sx);
#ifdef USE_COLOR_STYLE
    /*
     *  If this is the last screen line, set attributes to normal,
     *  should only be needed for color styles.  The curses function
     *  may be used directly to avoid complications. - kw
     */
    if (edit->sy == (LYlines - 1)) {
	if (s_normal != NOSTYLE) {
	    curses_style(s_normal, ABS_ON);
	} else {
	    attrset(A_NORMAL);	/* need to do something about colors? */
	}
    }
#endif
    if (edit->hidden) {
	for (i = 0; i < nrdisplayed; i++)
	    addch('*');
    } else {
	for (i = 0; i < nrdisplayed; i++)
	    if ((buffer[0] = str[i]) == 1 || buffer[0] == 2 ||
		((unsigned char)buffer[0] == 160 &&
		 !(HTPassHighCtrlRaw || HTCJK != NOCJK ||
		   (LYCharSet_UC[current_char_set].enc != UCT_ENC_8859 &&
		    !(LYCharSet_UC[current_char_set].like8859
		      & UCT_R_8859SPECL))))) {
		addch(' ');
	    } else {
		/* For CJK strings, by Masanobu Kimura */
		if (HTCJK != NOCJK && !isascii(buffer[0])) {
		    if (i < (nrdisplayed - 1))
			buffer[1] = str[++i];
		    addstr(buffer);
		    buffer[1] = '\0';
		} else {
		    addstr(buffer);
d4661 1
a4661 2
	    }
    }
d4663 7
a4669 18
    /*
     *	Erase rest of input area.
     */
    padsize = DspWdth-nrdisplayed;
    while (padsize--)
	addch((unsigned char)edit->pad);

    /*
     *	Scrolling indicators.
     */
    if (edit->panon) {
	if ((DspStart + nrdisplayed) < length) {
	    move(edit->sy, edit->sx+nrdisplayed-1);
	    addch('}');
	}
	if (DspStart) {
	    move(edit->sy, edit->sx);
	    addch('{');
d4672 1
d4674 1
a4674 2
    move(edit->sy, edit->sx + Pos - DspStart);
    refresh();
d4677 1
d4680 1
a4680 1
	char *, 	inputline,
d4682 2
a4683 2
	size_t, 	bufsize,
	int,		recall)
d4687 3
d4691 3
a4693 1
    char *res;
d4699 1
a4699 1
    MyEdit.hidden = hidden ;
d4701 1
d4704 1
d4706 19
a4724 1
	ch = LYgetch();
d4726 2
a4727 1
	if (term_letter || term_options ||
d4729 1
a4729 1
	      term_message
d4731 2
a4732 1
	      || HadVMSInterrupt) {
d4734 2
a4735 1
	    ch = 7;
d4737 5
a4741 11
#else
      if (term_letter || term_options
#ifndef DISABLE_NEWS
	      || term_message
#endif
	      )
	    ch = 7;
#endif /* VMS */
	if (recall && (ch == UPARROW || ch == DNARROW)) {
	    strcpy(inputline, MyEdit.buffer);
	    LYAddToCloset(MyEdit.buffer);
d4744 9
a4752 1
	if (keymap[ch + 1] == LYK_REFRESH)
d4754 22
a4775 1
	switch (EditBinding(ch)) {
d4777 39
a4815 9
	    ch = '\t';
	    /* This used to fall through to the next case before
	     tab completion was introduced */
	    res = LYFindInCloset(MyEdit.buffer);
	    if (res != 0) {
		LYEdit1(&MyEdit, '\0', LYE_ERASE, FALSE);
		while (*res != '\0') {
		    LYLineEdit(&MyEdit, (int)(*res), FALSE);
		    res++;
d4818 1
a4818 1
		ch = '\0';
d4821 2
d4832 2
a4833 1
		 LYlowest_eightbit[current_char_set] <= 0x97)) {
d4837 2
d4843 4
a4846 2
	    strcpy(inputline, MyEdit.buffer);
	    LYAddToCloset(MyEdit.buffer);
d4849 37
d4891 10
d4902 7
d4927 10
d4938 12
d4954 22
a4987 5
    if (!**stringp) {			/* empty string: */
	*stringp = 0;			/* let caller see he's done; */
	return 0;			/* no tokens in an empty string */
    }

d5006 2
a5007 2
	char *, 	chptr,
	CONST char *, 	tarptr)
d5033 2
a5034 2
	char *, 	chptr,
	char *, 	tarptr)
d5087 2
a5088 2
	char *, 	chptr,
	char *, 	tarptr)
d5133 7
a5139 2
 * The physical length of the displayed string up to the end of the target
 * string is returned in *nendp if the search is successful.
d5143 2
a5144 2
 *				LY_BOLD_END_CHAR
 *				LY_SOFT_HYPHEN
d5149 3
a5151 3
PUBLIC char * LYno_attr_mbcs_case_strstr ARGS5(
	char *, 	chptr,
	char *, 	tarptr,
d5153 1
d5157 2
a5158 1
    register char *tmpchptr, *tmptarptr;
d5194 3
a5196 3
		*nstartp = offset;
		*nendp = len;
		 return(chptr);
d5211 1
d5216 2
a5217 2
			*nstartp = offset;
			*nendp = len + tarlen;
a5219 1
		    tarlen++;
d5226 1
d5234 1
a5234 1
		 if (!IsSpecialAttrChar(*tmpchptr)) {
d5241 1
d5243 1
a5243 1
			break;
d5255 1
a5255 1
		 } else {
d5257 1
a5257 1
		 }
d5259 7
a5265 8
		 if (*tmptarptr == '\0') {
		    *nstartp = offset;
		     *nendp = len + tarlen;
		     return(chptr);
		 }
		if (*tmpchptr == '\0') {
		     break;
	    }
d5273 1
d5287 6
a5292 2
 *  end of the target string are returned in *nstartp and *nendp if
 *  the search is successful.
d5297 1
a5297 1
 *				LY_SOFT_HYPHEN
d5302 3
a5304 3
PUBLIC char * LYno_attr_mbcs_strstr ARGS5(
	char *, 	chptr,
	char *, 	tarptr,
d5306 1
d5310 2
a5311 1
    register char *tmpchptr, *tmptarptr;
d5343 3
a5345 3
		*nstartp = offset;
		*nendp = len + 1;
		 return(chptr);
d5359 1
d5364 2
a5365 2
			*nstartp = offset;
			*nendp = len + tarlen;
a5367 1
		    tarlen++;
d5374 1
d5389 1
d5407 2
a5408 2
		    *nstartp = offset;
		     *nendp = len + tarlen;
d5411 1
a5411 1
		if (*tmpchptr == '\0') {
a5413 1
	    }
d5420 1
a5428 57
PUBLIC void LYOpenCloset NOARGS
{
    /* We initialize the list-looka-like, i.e., the Closet */
    int i = 0;
    while(i < LYClosetSize){
	LYCloset[i] = NULL;
	i = i + 1;
    }
    LYClosetTop = 0;
}

PUBLIC void LYCloseCloset NOARGS
{
    int i = 0;

    /* Clean up the list-looka-like, i.e., the Closet */
    while (i < LYClosetSize){
	FREE(LYCloset[i]);
	i = i + 1;
    }
}

/*
 * Strategy:  We begin at the top and search downwards.  We return the first
 * match, i.e., the newest since we search from the top.  This should be made
 * more intelligent, but works for now.
 */
PRIVATE char * LYFindInCloset ARGS1(char*, base)
{
    int shelf;
    unsigned len = strlen(base);

    shelf = (LYClosetTop - 1 + LYClosetSize) % LYClosetSize;

    while (LYCloset[shelf] != NULL){
	if (!strncmp(base, LYCloset[shelf], len)) {
	    return(LYCloset[shelf]);
	}
	shelf = (shelf - 1 + LYClosetSize) % LYClosetSize;
    }
    return(0);
}

PRIVATE int LYAddToCloset ARGS1(char*, str)
{
    unsigned len = strlen(str);

    LYCloset[LYClosetTop] = malloc(len+1);
    if (!LYCloset[LYClosetTop])
	outofmem(__FILE__, "LYAddToCloset");
    strcpy(LYCloset[LYClosetTop], str);

    LYClosetTop = (LYClosetTop + 1) % LYClosetSize;
    FREE(LYCloset[LYClosetTop]);
    return(1);
}

d5439 1
a5439 1
	*dest = (char *)calloc(1, n + 1);
d5441 1
a5441 1
	    CTRACE(tfp, "Tried to calloc %d bytes\n", n);
d5467 1
a5467 1
	    *dest = (char *)calloc(1, strlen(src) + 1);
d5470 2
a5471 2
	    strncpy(*dest, src, n);
	    *dest[n] = '\0'; /* terminate */
d5498 1
a5498 1
    high = sizeof(unicode_to_lower_case)/sizeof(unicode_to_lower_case[0]);
d5531 7
d5540 1
a5540 44
    if ((unsigned char)TOASCII(ch1) < 128 && (unsigned char)TOASCII(ch2) < 128)
	return(TOUPPER(ch1) - TOUPPER(ch2));

    /* case-insensitive match for upper half */
    if ((unsigned char)TOASCII(ch1) > 127 &&  /* S/390 -- gil -- 2066 */
	(unsigned char)TOASCII(ch2) > 127)
    {
	if (DisplayCharsetMatchLocale)
	   return(TOUPPER(ch1) - TOUPPER(ch2)); /* old-style */
	else
	{
	long uni_ch1 = UCTransToUni(ch1, current_char_set);
	long uni_ch2 = UCTransToUni(ch2, current_char_set);
	return(UniToLowerCase(uni_ch1) - UniToLowerCase(uni_ch2));
	}
    }

    return(-10);  /* mismatch, if we come to here */
}


#ifdef NOTUSED
/*
**   We extend this function for 8bit letters
**   using Lynx internal chartrans feature:
**   we assume that upper/lower case letters
**   have their "7bit approximation" images (in def7_uni.tbl)
**   matched case-insensitive (7bit).
**
**   By this technique we automatically cover *any* charset
**   known for Lynx chartrans and need no any extra information for it.
**
**   The cost of this assumption is that several differently accented letters
**   may be interpreted as equal, but this side effect is negligible
**   if the user search string is more than one character long.  - LP
**
**   We enable new technique only if  DisplayCharsetMatchLocale = FALSE
**   (see description in LYCharSets.c)
*/
PUBLIC int UPPER8 ARGS2(int,ch1, int,ch2)
{

    /* case-insensitive match for us-ascii */
    if ((unsigned char)TOASCII(ch1) < 128 && (unsigned char)TOASCII(ch2) < 128)
d5544 2
a5545 2
    if ((unsigned char)TOASCII(ch1) > 127 &&  /* S/390 -- gil -- 2066 */
	(unsigned char)TOASCII(ch2) > 127)
d5551 6
a5556 23
	/* compare "7bit approximation" for letters >127   */
	/* BTW, if we remove the check for >127 above	   */
	/* we get even more "relaxed" insensitive match... */

	int charset_in, charset_out, uck1, uck2;
	char replace_buf1 [10], replace_buf2 [10];

	charset_in  = current_char_set;  /* display character set */
	charset_out = UCGetLYhndl_byMIME("us-ascii");

	uck1 = UCTransCharStr(replace_buf1, sizeof(replace_buf1), ch1,
			      charset_in, charset_out, YES);
	uck2 = UCTransCharStr(replace_buf2, sizeof(replace_buf2), ch2,
			      charset_in, charset_out, YES);

	if ((uck1 > 0) && (uck2 > 0))  /* both replacement strings found */
	    return (strcasecomp(replace_buf1, replace_buf2));

	/* check to be sure we have not lost any strange characters */
	/* which are not found in def7_uni.tbl but _equal_ in fact. */
	/* this also applied for "x-transparent" display mode.	    */
	if ((unsigned char)ch1==(unsigned char)ch2)
	    return(0);	 /* match */
a5561 1
#endif /* NOTUSED */
d5586 8
a5593 2
    if (feof(fp)
     || ferror(fp)) {
d5600 163
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d1761 24
@


1.2.10.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html
@
text
@a1760 24
 * Escape unsafe characters in startfile, except for lynx internal URLs.
 */
PUBLIC void LYEscapeStartfile ARGS1(
       char **,			buffer)
{
     if (!LYTrimStartfile(*buffer)) {
	char *escaped = HTEscapeUnsafe(*buffer);
	StrAllocCopy(*buffer, escaped);
	FREE(escaped);
	}
}

/*
 * Trim all blanks from startfile, except for lynx internal URLs.
 */
PUBLIC void LYTrimAllStartfile ARGS1(
       char *,         buffer)
{
    if (!LYTrimStartfile(buffer)) {
       LYRemoveBlanks(buffer);
    }
}

/*
@


1.2.12.1
log
@Pull in patch from current:
Fix (margarida):
Fix URL CRLF Injection bug.
--
A CRLF injection vulnerability has been reported for Lynx that
may allow an attacker to include extra HTTP headers when viewing
web pages.
If Lynx is called from the command line, carriage return and line
feed (CRLF) characters may be included in the specified URL.
These characters are not escaped when the input is used to construct
a HTTP request.

URL: http://www.flora.org/lynx-dev/html/month082002/msg00211.html

henning@@ fgs@@ pjanzen@@ pvalchev@@ ok
@
text
@a1760 24
 * Escape unsafe characters in startfile, except for lynx internal URLs.
 */
PUBLIC void LYEscapeStartfile ARGS1(
       char **,			buffer)
{
     if (!LYTrimStartfile(*buffer)) {
	char *escaped = HTEscapeUnsafe(*buffer);
	StrAllocCopy(*buffer, escaped);
	FREE(escaped);
	}
}

/*
 * Trim all blanks from startfile, except for lynx internal URLs.
 */
PUBLIC void LYTrimAllStartfile ARGS1(
       char *,         buffer)
{
    if (!LYTrimStartfile(buffer)) {
       LYRemoveBlanks(buffer);
    }
}

/*
@


1.1
log
@Initial revision
@
text
@d1 26
a26 18
#include "HTUtils.h"
#include "tcp.h"
#include "HTCJK.h"
#include "LYCurses.h"
#include "LYUtils.h"
#include "LYStrings.h"
#include "LYGlobalDefs.h"
#include "GridText.h"
#include "LYKeymap.h"
#include "LYSignal.h"
#include "LYClean.h"
#include "LYMail.h"
#include "LYNews.h"
#include "LYOptions.h"
#include "LYCharSets.h"
#include "HTString.h"

#include <ctype.h>
d28 1
a28 3
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}
d30 1
d34 11
d59 18
d80 114
a193 4
  int t;
  t=mouse_link;
  mouse_link = -1;
  return t;
d203 100
a302 1
PRIVATE int set_clicked_link ARGS2(int,x,int,y)
d304 3
a306 35
  int i;

  /* Loop over the links and see if we can get a match */
  for(i=0; i < nlinks && mouse_link == -1; i++) {
    /* Check the first line of the link */
    if ( links[i].hightext != NULL &&
	 links[i].ly == y &&
	 (x - links[i].lx) < (int)strlen(links[i].hightext ) ) {
      mouse_link=i;
    }
    /* Check the second line */
    if (links[i].hightext2 != NULL &&
	1+links[i].ly == y &&
	(x - links[i].hightext2_offset) < (int)strlen(links[i].hightext2) ) {
      mouse_link=i;
    }
  }
  /* If no link was found, just return a do-nothing code */
  if (mouse_link == -1) return -1;

  /* If a link was hit, we must look for a key which will activate LYK_ACTIVATE
  ** XXX The 127 in the following line will depend on the size of the keymap[]
  ** array.  However, usually we'll find LYK_ACTIVATE somewhere in the first
  ** 127 keys (it's usually mapped to the Enter key)
  **/
  for (i=0; i<127; i++) {
    if (LYisNonAlnumKeyname(i, LYK_ACTIVATE)) {
      return i;
    }
  }
    /* Whoops!	Nothing's defined as LYK_ACTIVATE!
       Well, who are we to argue with the user?
       Forget about the mouse click */
  mouse_link = -1;
  return -1;
d308 1
d321 5
a325 1
    int len=strlen(src);
d453 7
d461 1
d492 3
d500 2
a501 1
	my_subwindow = param;
d508 9
a516 9
   /* "ESC [ M" has already been processed.  There more characters are
    * expected:  BUTTON X Y
    */
   *button = SLang_getkey ();
   switch (*button)
     {
      case 040: 		       /* left button */
      case 041: 		       /* middle button */
      case 042: 		       /* right button */
d520 1
a520 1
      default:			       /* Hmmm.... */
d523 1
a523 1
     }
d525 3
a527 3
   *x = SLang_getkey () - 33;
   *y = SLang_getkey () - 33;
   return 0;
a528 1
#endif
d530 1
a530 2
#if defined(USE_SLANG_MOUSE) || defined(NCURSES_MOUSE_VERSION)
PRIVATE int map_function_to_key ARGS1(char, keysym)
d532 1
a532 1
   int i;
d534 2
a535 4
   /* I would prefer to use sizeof keymap but its size is not available.
    * A better method would be to declare it as some fixed size.
    */
   for (i = 1; i < 256; i++)
d537 11
a547 2
	if (keymap[i] == keysym)
	  return i - 1;
d559 560
d1122 2
d1126 6
d1134 2
d1142 1
a1142 1
#if !defined(USE_SLANG) || defined(VMS)
d1158 1
a1158 1
   }
a1160 18
#ifdef RAWDOSKEYHACK
    if (raw_dos_key_hack) {
	if (c == 0) c = '/';
	if (c > 255) {	    /* handle raw dos keys */
	    switch (c)
	    {
		case 464: c = '-';	break;	/* keypad minus*/
		case 465: c = '+';	break;	/* keypad plus*/
		case 459: c = 13;	break;	/* keypad enter*/
		case 463: c = '*';	break;	/* keypad * */
		case 440: c = 'Q';	break;	/* alt x */
		case 265: c = 'H';	break;	/* F1 */
		default: break;
	    }
	}
    }
#endif /* RAWDOSKEYHACK */

d1193 1
a1193 12
#ifndef NOSIGHUP
	(void) signal(SIGHUP, SIG_DFL);
#endif /* NOSIGHUP */
	(void) signal(SIGTERM, SIG_DFL);
#ifndef VMS
	(void) signal(SIGINT, SIG_DFL);
#endif /* !VMS */
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(0);
d1197 1
a1197 1
    if (c == 27 || (csi_is_csi && c == 155)) {	    /* handle escape sequence */
d1214 5
a1218 5
	case 't': c = LTARROW; break; /* keypad left on pc ncsa telnet */
	case 'y': c = PGUP; break;  /* keypad on pc ncsa telnet */
	case 's': c = PGDOWN; break;  /* keypad on pc ncsa telnet */
	case 'w': c = HOME; break;  /* keypad on pc ncsa telnet */
	case 'q': c = END; break;  /* keypad on pc ncsa telnet */
d1221 1
a1221 1
	   if ((c == 27) && (b == '['))
d1223 1
a1223 17
		int mouse_x, mouse_y, button;

		mouse_link = -1;
		c = -1;
		if (-1 != sl_parse_mouse_event (&mouse_x, &mouse_y, &button))
		  {
		     if (button == 0)  /* left */
		       c = set_clicked_link (mouse_x, mouse_y);
		     else if (button == 2)   /* right */
		       {
			  /* Right button: go back to prev document.
			   * The problem is that we need to determine
			   * what to return to achieve this.
			   */
			  c = map_function_to_key (LYK_PREV_DOC);
		       }
		  }
d1265 1
a1265 1
	    if ((b == '[' || c == 155) && (d=GetChar()) == '~')
d1269 1
a1269 1
	    if (b == '[' || c == 155) {
d1285 1
a1285 1
	    if ((b == '[' || c == 155) && (d=GetChar()) == '~')
d1289 1
a1289 1
	    if ((b == '[' || c == 155) && (d=GetChar()) == '~')
d1293 1
a1293 1
	    if ((b == '[' || c == 155) && (d=GetChar()) == '~')
d1297 1
a1297 1
	    if ((b == '[' || c == 155) && (d=GetChar()) == '~')
d1301 1
a1301 1
	    if (b == '[' || c == 155) {
d1307 3
a1309 6
	   if (TRACE) {
		fprintf(stderr,"Unknown key sequence: %d:%d:%d\n",c,b,a);
		if (!LYTraceLogFP) {
		    sleep(MessageSecs);
		}
	   }
d1311 1
a1311 1
	if (isdigit(a) && (b == '[' || c == 155) && d != -1 && d != '~')
d1345 1
a1345 1
	   c = END;
d1361 1
a1361 1
	   c = END;
d1366 10
d1378 1
a1378 1
	   c = END;
d1388 1
a1388 1
	   c = 127;		   /* backspace key (delete, not Ctrl-H) */
a1390 1
#ifdef KEY_F
d1394 1
d1424 27
d1453 3
a1455 1
	  {
d1457 2
a1458 2
	   MEVENT event;
	   int err;
d1460 39
a1498 8
	   c = -1;
	   mouse_link = -1;
	   err=getmouse(&event);
	   if (event.bstate & BUTTON1_CLICKED) {
	     c = set_clicked_link(event.x, event.y);
	   } else if (event.bstate & BUTTON3_CLICKED) {
	     c = map_function_to_key (LYK_PREV_DOC);
	   }
d1500 11
a1510 21
	      int left,right;
	      /* yes, I am assuming that my screen will be a certain width. */
	      left = 6;
	      right = LYcols-6;
	      c = -1;
	      mouse_link = -1;
	      request_mouse_pos();
	      if (Mouse_status.button[0] & BUTTON_CLICKED) {
		if (Mouse_status.y == (LYlines-1))
		       if (Mouse_status.x < left) c=LTARROW;
		       else if (Mouse_status.x > right) c='\b';
		       else c=PGDOWN;
		else if (Mouse_status.y == 0)
		       if (Mouse_status.x < left) c=LTARROW;
		       else if (Mouse_status.x > right) c='\b';
		       else c=PGUP;
		else c = set_clicked_link(Mouse_status.x, Mouse_status.y);
	      }
#endif /* _WINDOWS */
	  }
	  break;
d1515 104
d1620 1
a1620 1
    if (c > DO_NOTHING) {
d1632 127
d1822 1
a1822 1
    if (strlen(old) >= maxstr) {
d1837 1
a1837 1
     *	       ch   otherwise
d1841 3
d1848 1
a1848 1
    length=strlen(&Buf[0]);
d1852 8
d1870 6
d1957 24
d1983 2
a1984 1
	 *  Delete next character
d1989 1
a1989 1
	/* fall through */
a2003 12
    case LYE_DELC:
	/*
	 *  Delete current character.
	 */
	if (length == 0 || Pos == length)
	    break;
	for (i = Pos; i < length; i++)
	    Buf[i] = Buf[i+1];
	i--;
	Buf[i] = 0;
	break;

d2021 1
a2021 2
	for (i = 0; Buf[i]; i++)
	   Buf[i] = TOUPPER(Buf[i]);
d2025 1
a2025 2
	for (i = 0; Buf[i]; i++)
	   Buf[i] = TOLOWER(Buf[i]);
d2056 5
a2060 5
 *		  .--DspWdth---.
 *	+---------+=============+-----------+
 *	|	  |M	       M|	    |	(M=margin)
 *	+---------+=============+-----------+
 *	0	  DspStart		     length
d2066 1
a2066 1
 *   extending the string. Looks awful, but that way we can keep up with
d2086 14
d2160 1
d2173 5
a2177 1
	if (term_letter || term_options || term_message || HadVMSInterrupt) {
d2182 5
a2186 1
	if (term_letter || term_options || term_message)
d2191 1
d2199 13
a2211 1
	    /* fall through */
d2230 1
a2231 1
	    break;
a2238 1
	    break;
d2248 8
d2263 28
d2298 1
a2298 1
	char *, 	tarptr)
d2373 1
a2373 1
 *				LY_SOFT_HYPHEN
d2703 57
d2772 1
a2772 2
	    if (TRACE)
		fprintf(stderr, "Tried to calloc %d bytes\n", n);
d2808 38
d2853 3
a2855 3
**   (precisely from "(TOUPPER(a) - TOUPPER(b))==0").
**   This function depends on locale in its 8bit mapping
**   and usually fails with DOS/WINDOWS display charsets
d2858 29
d2900 2
a2901 2
**   Currently we enable new technique only for DOS/WINDOWS display charsets
**   and also for EXP_8BIT_TOUPPER compilation symbol.
d2907 1
a2907 1
    if ((unsigned char)ch1 < 128 && (unsigned char)ch2 < 128)
d2911 2
a2912 1
    if ((unsigned char)ch1 > 127 && (unsigned char)ch2 >127)
d2914 3
a2916 10
	CONST char *disp_charset;
	disp_charset = LYCharSet_UC[current_char_set].MIMEname;

#if !defined(EXP_8BIT_TOUPPER)
	if  (!(strncasecomp(disp_charset, "cp", 2) ||
		strncasecomp(disp_charset, "windows", 7))) {

	return(TOUPPER(ch1) - TOUPPER(ch2)); /* old-style */
	} else 
#endif
d2925 1
a2925 1
	charset_in  = UCGetLYhndl_byMIME(disp_charset);
d2938 1
d2945 33
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
