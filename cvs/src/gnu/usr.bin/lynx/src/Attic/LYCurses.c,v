head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.47;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.08;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/* $LynxId: LYCurses.c,v 1.179 2014/02/20 23:14:31 Thomas.Klausner Exp $ */
#include <HTUtils.h>
#include <HTAlert.h>

#ifdef __MINGW32__
#ifdef UNIX
#undef UNIX
#endif /* UNIX */
#endif /* __MINGW32__ */

#ifdef __DJGPP__
#include <pc.h>
#endif /* __DJGPP__ */

#include <LYCurses.h>
#include <LYStyle.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYSignal.h>
#include <LYClean.h>
#include <LYReadCFG.h>
#include <LYStrings.h>
#include <LYCharSets.h>
#include <UCAux.h>
#include <HTFont.h>

#include <LYexit.h>
#include <LYLeaks.h>

#ifdef VMS
#include <LYMainLoop.h>
#endif

#if defined(VMS) && defined(__GNUC__)
#include <gnu_hacks.h>
#undef LINES
#undef COLS
#define LINES lines
#define COLS cols
extern int _NOSHARE(LINES);
extern int _NOSHARE(COLS);
#endif /* VMS && __GNUC__ */

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#endif

#ifdef NEED_WCHAR_H
#include <wchar.h>
#endif

#if defined(COLOR_CURSES)
int lynx_has_color = FALSE;
#endif

#ifdef HAVE_XCURSES
char *XCursesProgramName = "Lynx";
#endif

#ifdef PDCURSES
#undef HAVE_NEWTERM		/* not needed, since /dev/tty is unused */
#endif

#if defined(USE_COLOR_STYLE) && !defined(USE_COLOR_TABLE)
#define COLOR_BKGD ((s_normal != NOSTYLE) ? hashStyles[s_normal].color : A_NORMAL)
#else
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? (chtype) get_color_pair(9) : A_NORMAL)
#endif

#ifdef USE_CURSES_PADS
WINDOW *LYwin = 0;
int LYshiftWin = 0;
int LYwideLines = FALSE;
int LYtableCols = 0;		/* in 1/12 of screen width */
BOOLEAN LYuseCursesPads = TRUE;	/* use pads for left/right shifting */
#endif

/*
 * These are routines to start and stop curses and to cleanup the screen at the
 * end.
 */

static int dumbterm(char *terminal);
BOOLEAN LYCursesON = FALSE;

#if defined(USE_BLINK) && defined(__EMX__)
static void make_blink_boldbg(void);
#endif

#if defined(USE_COLOR_TABLE) || defined(USE_SLANG)
int Current_Attr;
static int Masked_Attr;
#endif

#ifdef USE_SLANG
unsigned Lynx_Color_Flags = 0;
BOOLEAN FullRefresh = FALSE;
int curscr = 0;

#ifdef SLANG_MBCS_HACK
/*
 * Will be set by size_change.  - KW
 */
int PHYSICAL_SLtt_Screen_Cols = 10;
#endif /* SLANG_MBCS_HACK */

void LY_SLrefresh(void)
{
    if (FullRefresh) {
	SLsmg_suspend_smg();
	SLsmg_resume_smg();
	FullRefresh = FALSE;
    } else {
	SLsmg_refresh();
    }

    return;
}

/* the following renamed from LY_SLclear since it is more like erase()
   described in curses man pages than like clear(); but for USE_SLANG
   clear() is still a macro calling this, and will do the same thing as
   erase(). - kw */
void LY_SLerase(void)
{
    SLsmg_gotorc(0, 0);
    SLsmg_erase_eos();
}

#ifdef VMS
void VTHome(void)
{
    printf("\033[;H");

    return;
}
#endif /* VMS */

void LYaddAttr(int a)
{
    Current_Attr |= a;
    SLsmg_set_color((SLsmg_Color_Type) (Current_Attr & ~Masked_Attr));
}

void LYsubAttr(int a)
{
    Current_Attr &= ~a;
    SLsmg_set_color((SLsmg_Color_Type) (Current_Attr & ~Masked_Attr));
}

static void lynx_setup_attrs(void)
{
    static int monoattr[] =
    {
	0,
	SLTT_BOLD_MASK,
	SLTT_REV_MASK,
	SLTT_REV_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK,
	SLTT_ULINE_MASK | SLTT_REV_MASK,
	SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK
    };
    int n;

    for (n = 1; n <= 7; n++)
	SLtt_set_mono(n, NULL, (SLtt_Char_Type) (monoattr[n] & ~Masked_Attr));
}

void lynx_setup_colors(void)
{
    CTRACE((tfp, "lynx_setup_colors\n"));
    SLtt_set_color(0, NULL, DEFAULT_FG, DEFAULT_BG);
    SLtt_set_color(1, NULL, "blue", DEFAULT_BG);	/* bold */
    SLtt_set_color(2, NULL, "yellow", "blue");	/* reverse */
    SLtt_set_color(4, NULL, "magenta", DEFAULT_BG);	/* underline */
    /*
     * The other objects are '|'ed together to get rest.
     */
    SLtt_set_color(3, NULL, "green", DEFAULT_BG);	/* bold-reverse */
    SLtt_set_color(5, NULL, "blue", DEFAULT_BG);	/* bold-underline */
    SLtt_set_color(6, NULL, "red", DEFAULT_BG);		/* reverse-underline */
    SLtt_set_color(7, NULL, "magenta", "cyan");		/* reverse-underline-bold */
    /*
     * Now set monochrome attributes.
     */
    lynx_setup_attrs();
}

static void sl_suspend(int sig)
{
#ifdef SIGSTOP
#ifndef VMS
    int r, c;

    lynx_enable_mouse(0);
    if (sig == SIGTSTP)
	SLsmg_suspend_smg();
    SLang_reset_tty();
    kill(getpid(), SIGSTOP);
#if SLANG_VERSION > 9929
    SLang_init_tty(-1, 0, 1);
#else
    SLang_init_tty(3, 0, 1);
#endif /* SLANG_VERSION > 9929 */
    signal(SIGTSTP, sl_suspend);
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
    SLtty_set_suspend_state(1);
#endif
    if (sig == SIGTSTP)
	SLsmg_resume_smg();
    /*
     * Get new window size in case it changed.
     */
    r = SLtt_Screen_Rows;
    c = SLtt_Screen_Cols;
    size_change(0);
    if ((r != SLtt_Screen_Rows) || (c != SLtt_Screen_Cols)) {
	recent_sizechange = TRUE;
    }
    lynx_enable_mouse(1);
#endif /* !VMS */
#endif /* SIGSTOP */
    return;
}
#else

#ifdef FANCY_CURSES

#ifndef VMS
/* *INDENT-OFF* */
/* definitions for the mono attributes we can use */
static struct {
    const char *name;
    int code;
} Mono_Attrs[7] =
{
    { "normal",		A_NORMAL },
    { "bold",		A_BOLD },
    { "reverse",	A_REVERSE },
    { "underline",	A_UNDERLINE },
    { "standout",	A_STANDOUT },
    { "blink",		A_BLINK },
    { "dim",		A_DIM },
};
/* *INDENT-ON* */

int string_to_attr(const char *name)
{
    unsigned i;

    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (!strcasecomp(Mono_Attrs[i].name, name)) {
	    return Mono_Attrs[i].code;
	}
    }
    return 0;
}
#endif /* VMS */

#ifdef USE_COLOR_STYLE
static char *attr_to_string(int code)
{
    static char *result;

    if (code >= 0) {
	unsigned i;
	int pair = PAIR_NUMBER((unsigned) code);
	int bold = (pair != 0 && ((unsigned) code & A_BOLD) != 0);

	StrAllocCopy(result, "");

	if (bold)
	    code &= (int) ~A_BOLD;

	for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	    if (Mono_Attrs[i].code & code) {
		if (non_empty(result))
		    StrAllocCat(result, "+");
		StrAllocCat(result, Mono_Attrs[i].name);
	    }
	}
	if (pair != 0) {
	    short f, b;

	    if (pair_content((short) pair, &f, &b) != ERR) {
		if (non_empty(result))
		    StrAllocCat(result, "+");
		StrAllocCat(result, lookup_color(bold ? f + COLORS : f));
		StrAllocCat(result, "/");
		StrAllocCat(result, lookup_color(b));
	    }
	}
    } else {
	FREE(result);
    }
    return result;
}
#endif /* USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* USE_SLANG */

/*
 *  This function boxes windows for (n)curses.
 */
void LYbox(WINDOW * win, int formfield GCC_UNUSED)
{
#ifdef USE_SLANG
    SLsmg_draw_box(win->top_y,
		   win->left_x,
		   (unsigned) win->height,
		   (unsigned) win->width + 4);
#else
#ifdef VMS
    /*
     * This should work for VAX-C and DEC-C, since they both have the same
     * win._max_y and win._max_x members -TD
     *
     * (originally VMSbox by FM)
     */
    int i;

    wmove(win, 0, 0);
    waddstr(win, "\033)0\016l");
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
    waddch(win, 'k');
    for (i = 1; i < win->_max_y - 1; i++) {
	wmove(win, i, 0);
	waddch(win, 'x');
	wmove(win, i, win->_max_x - 1);
	waddch(win, 'x');
    }
    wmove(win, i, 0);
    waddch(win, 'm');
    for (i = 1; i < win->_max_x; i++)
	waddch(win, 'q');
    waddstr(win, "j\017");
#else /* !VMS */
    int boxvert, boxhori;

    UCSetBoxChars(current_char_set, &boxvert, &boxhori, BOXVERT, BOXHORI);
#ifdef CSS
    if (formfield)
	wcurses_css(win, "frame", ABS_ON);
#endif
    /*
     * If we don't have explicitly specified characters for either vertical or
     * horizontal lines, the characters that box() would use for the corners
     * probably also won't work well.  So we specify our own ASCII characters
     * for the corners and call wborder() instead of box().  - kw
     */
    LynxWChangeStyle(win, s_menu_frame, STACK_ON);
#ifdef HAVE_WBORDER
    if (!boxvert || !boxhori) {
	box(win,
	    (chtype) boxvert,
	    (chtype) boxhori);
    } else if (boxvert == '*' || boxhori == '*') {
	wborder(win,
		(chtype) boxvert,
		(chtype) boxvert,
		(chtype) boxhori,
		(chtype) boxhori,
		'*', '*', '*', '*');
    } else {
	wborder(win,
		(chtype) boxvert,
		(chtype) boxvert,
		(chtype) boxhori,
		(chtype) boxhori,
		'/', '\\', '\\', '/');
    }
#else
    box(win, boxvert, boxhori);
#endif
    LynxWChangeStyle(win, s_menu_frame, STACK_OFF);
#ifdef CSS
    if (formfield)
	wcurses_css(win, "frame", ABS_OFF);
#endif
#endif /* VMS */
    wrefresh(win);
#endif /* USE_SLANG */
}

#if defined(USE_COLOR_STYLE)
/* Ok, explanation of the USE_COLOR_STYLE styles.  The basic styles (ie non
 * HTML) are set the same as the SLANG version for ease of programming.  The
 * other styles are simply the HTML enum from HTMLDTD.h + 16.
 */
HTCharStyle displayStyles[DSTYLE_ELEMENTS];

/*
 * set a style's attributes - RP
 */
void setStyle(int style,
	      int color,
	      int cattr,
	      int mono)
{
    displayStyles[style].color = color;
    displayStyles[style].cattr = cattr;
    displayStyles[style].mono = mono;
}

void setHashStyle(int style,
		  int color,
		  int cattr,
		  int mono,
		  const char *element)
{
    bucket *ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE,
	    (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n",
	     element, style, color, mono));

    ds->color = color;
    ds->cattr = cattr;
    ds->mono = mono;
    ds->code = style;
    FREE(ds->name);
    StrAllocCopy(ds->name, element);
}

/*
 * set the curses attributes to be color or mono - RP
 */
static void LYAttrset(WINDOW * win, int color,
		      int mono)
{
    char *shown = NULL;

    if (lynx_has_color
	&& LYShowColor >= SHOW_COLOR_ON
	&& color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color %#x -> (%s)\n",
			      color, shown = attr_to_string(color)));
	(void) wattrset(win, (unsigned) color);
    } else if (mono >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono %#x -> (%s)\n",
			      mono, shown = attr_to_string(mono)));
	(void) wattrset(win, (unsigned) mono);
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset (A_NORMAL)\n"));
	(void) wattrset(win, A_NORMAL);
    }
    if (shown != NULL)
	(void) attr_to_string(-1);
}

void curses_w_style(WINDOW * win, int style,
		    int dir)
{
#if OMIT_SCN_KEEPING
# define SPECIAL_STYLE /*(CSHASHSIZE+1) */ 88888
/* if TRACEs are not compiled in, this macro is redundant - we needn't valid
'ds' to stack off. */
#endif

    int YP, XP;
    bucket *ds;
    BOOL free_ds = TRUE;

    switch (style) {
#if OMIT_SCN_KEEPING
    case SPECIAL_STYLE:
	ds = special_bucket();
	break;
#endif
    case NOSTYLE:
	ds = nostyle_bucket();
	break;
    default:
	ds = &hashStyles[style];
	free_ds = FALSE;
	break;
    }

    if (!ds->name) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n", style));
#if !OMIT_SCN_KEEPING
	if (free_ds)
	    free(ds);
	return;
#endif
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> style %d code %#x, color %#x\n",
			  (dir ? "" : "/"),
			  ds->name, style, ds->code, ds->color));

    getyx(win, YP, XP);

    if (style == s_normal && dir) {
	LYAttrset(win, ds->color, ds->mono);
	if (win == LYwin)
	    SetCachedStyle(YP, XP, (unsigned) s_normal);
	if (free_ds)
	    free(ds);
	return;
    }

    switch (dir) {
	/* ABS_OFF is the same as STACK_OFF for the moment */
    case STACK_OFF:
	if (last_colorattr_ptr) {
	    int last_attr = last_styles[--last_colorattr_ptr];

	    LYAttrset(win, last_attr, last_attr);
	} else
	    LYAttrset(win, A_NORMAL, -1);
	break;

    case STACK_ON:		/* remember the current attributes */
	if (last_colorattr_ptr >= MAX_LAST_STYLES) {
	    CTRACE2(TRACE_STYLE, (tfp, "........... %s (0x%x) %s\r\n",
				  "attribute cache FULL, dropping last",
				  last_styles[last_colorattr_ptr],
				  "in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr = MAX_LAST_STYLES - 1;
	}
	last_styles[last_colorattr_ptr++] = (int) LYgetattrs(win);
	/* don't cache style changes for active links */
#if OMIT_SCN_KEEPING
	/* since we don't compute the hcode to stack off in HTML.c, we
	 * don't know whether this style is configured.  So, we
	 * shouldn't simply return on stacking on unconfigured
	 * styles, we should push curr attrs on stack.  -HV
	 */
	if (!ds->name)
	    break;
#endif
	/* FALL THROUGH */
    case ABS_ON:		/* change without remembering the previous style */
	/* don't cache style changes for active links and edits */
	if (style != s_alink
	    && style != s_curedit
	    && style != s_aedit
	    && style != s_aedit_sel
	    && style != s_aedit_pad
	    && style != s_aedit_arr) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n",
				  ds->name, YP, XP));
	    if (win == LYwin)
		SetCachedStyle(YP, XP, (unsigned) style);
	}
	LYAttrset(win, ds->color, ds->mono);
	break;
    }

    if (free_ds)
	free(ds);

    return;
}

/*
 * wrapper function to set on-screen styles - RP
 */
void wcurses_css(WINDOW * win, char *name,
		 int dir)
{
    int try_again = 1;

    while (try_again) {
	int tmpHash = hash_code(name);

	CTRACE2(TRACE_STYLE, (tfp, "CSSTRIM:trying to set [%s] style - ", name));
	if (tmpHash == NOSTYLE) {
	    char *pclass = strrchr(name, '.');

	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", pclass));
	    if (pclass)
		*pclass = '\0';
	    else
		try_again = 0;
	} else {
	    CTRACE2(TRACE_STYLE, (tfp, "ok (%d)\n", hash_code(name)));
	    curses_w_style(win, hash_code(name), dir);
	    try_again = 0;
	}
    }
}

void curses_css(char *name,
		int dir)
{
    wcurses_css(LYwin, name, dir);
}

void curses_style(int style,
		  int dir)
{
    curses_w_style(LYwin, style, dir);
}
#endif /* USE_COLOR_STYLE */

static BOOL lynx_called_initscr = FALSE;

#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
#define COLOR_CFG_MAX 8

/*
 * This block of code is designed to produce the same color effects using SVr4
 * curses as the slang library's implementation in this module.  That maps the
 * SGR codes into a 0-7 index into the color table, with special treatment for
 * backgrounds.  There's a bit of convoluted (but necessary) code handling the
 * special case of initialization before 'initscr()' is called.
 * 1997/1/19 - T.E.Dickey <dickey@@clark.net>
 */
/* *INDENT-OFF* */
#define COLOR_CFG(c) c, (c) == DEFAULT_COLOR
static struct {
    int fg, dft_fg, bg, dft_bg;
} lynx_color_cfg[] = {
    /*0*/ { COLOR_CFG(DEFAULT_FG),       COLOR_CFG(DEFAULT_BG)},
    /*1*/ { COLOR_CFG(COLOR_BLUE),       COLOR_CFG(DEFAULT_BG)},
    /*2*/ { COLOR_CFG((COLOR_YELLOW)+8), COLOR_CFG(COLOR_BLUE)},
    /*3*/ { COLOR_CFG(COLOR_GREEN),      COLOR_CFG(DEFAULT_BG)},
    /*4*/ { COLOR_CFG(COLOR_MAGENTA),    COLOR_CFG(DEFAULT_BG)},
    /*5*/ { COLOR_CFG(COLOR_BLUE),       COLOR_CFG(DEFAULT_BG)},
    /*6*/ { COLOR_CFG(COLOR_RED),        COLOR_CFG(DEFAULT_BG)},
    /*7*/ { COLOR_CFG(COLOR_MAGENTA),    COLOR_CFG(COLOR_CYAN)}
};
/* *INDENT-ON* */

#define COLOR_PAIRS_MAX (COLOR_CFG_MAX * 3 + 1)

/*
 * Hold the codes for color-pairs here until 'initscr()' is called.
 */
static struct {
    int fg;
    int bg;
} lynx_color_pairs[COLOR_PAIRS_MAX];

/*
 * If we find an exact match for the given default colors, force curses to use
 * color pair 0, which corresponds to the terminal's default colors.  Normally
 * curses assumes white-on-black, but we can override the assumption with this
 * function.
 */
static int get_color_pair(int n)
{
#ifdef USE_CURSES_PAIR_0
    if ((n < (int) TABLESIZE(lynx_color_pairs))
	&& lynx_color_pairs[n].fg == default_fg
	&& lynx_color_pairs[n].bg == default_bg)
	return 0;
#endif
    return (int) COLOR_PAIR(n);
}

/*
 * Lynx "knows" about 16 colors.  ANSI colors (and most color terminal
 * emulators) only go to 8, though some curses implementations (ncurses and
 * PDCurses) handle 16.  If lynx's configuration calls for a color past the
 * number of colors that the terminal handles (COLORS), map the extra value
 * to bold.
 */
#define is_boldc(c) ((c) > (COLORS-1))
#define map2bold(c) (is_boldc(c) ? ((c) & (COLORS-1)) : (c))

/*
 * Return the extra color as A_BOLD.
 * If there is no extra color, return A_NORMAL.
 */
static int lynx_color_cfg_attr(int code)
{
    int result = A_NORMAL;

    if (code >= 0 && code < COLOR_CFG_MAX) {
	int fg = lynx_color_cfg[code].fg;

	if (is_boldc(fg) && (fg & COLORS))
	    result = A_BOLD;
    }
    return result;
}

static int encode_color_attr(int color_attr)
{
    int result;
    int code = 0;
    int offs = 1;

    if ((unsigned) color_attr & A_BOLD)
	code |= 1;
    if ((unsigned) color_attr & (A_REVERSE | A_DIM))
	code |= 2;
    if ((unsigned) color_attr & A_UNDERLINE)
	code |= 4;
    result = lynx_color_cfg_attr(code);

    if (code + offs < COLOR_PAIRS) {
	result |= get_color_pair(code + offs);
    }
    return result;
}

static int decode_mono_code(int mono_code)
{
    unsigned result = 0;

    if (mono_code & 1)
	result |= A_BOLD;
    if (mono_code & 2)
	result |= A_REVERSE;
    if (mono_code & 4)
	result |= A_UNDERLINE;

    return (int) result;
}

/*
 * Map the SGR attributes (0-7) into ANSI colors, modified with the actual BOLD
 * attribute to get 16 colors.
 */
int LYgetTableAttr(void)
{
    int result;

    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON) {
	result = encode_color_attr(Current_Attr);
    } else {
	result = Current_Attr;
    }
    return result & ~Masked_Attr;
}

#ifdef USE_COLOR_STYLE
/*
 * Return a string that corresponds to the attributes that would be returned by
 * LYgetTableAttr().
 */
char *LYgetTableString(int code)
{
    int mask = decode_mono_code(code);
    int second = encode_color_attr(mask);
    int pair = PAIR_NUMBER((unsigned) second);
    int mono = (int) ((unsigned) mask & A_ATTRIBUTES);
    int fg = lynx_color_pairs[pair].fg;
    int bg = lynx_color_pairs[pair].bg;
    unsigned n;
    char *result = 0;

    CTRACE((tfp, "LYgetTableString(%d)\n", code));

    if (fg == 0 && bg == 0) {
	fg = COLOR_WHITE;
    }
    CTRACE((tfp, "%#x -> %#x (mono %#x pair %d) fg=%d, bg=%d\n",
	    mask, second, mono, pair, fg, bg));
    for (n = 0; n < TABLESIZE(Mono_Attrs); ++n) {
	if ((Mono_Attrs[n].code & mono) != 0) {
	    if (result != 0)
		StrAllocCat(result, "+");
	    StrAllocCat(result, Mono_Attrs[n].name);
	}
    }
    if (result == 0)
	StrAllocCopy(result, "normal");
    StrAllocCat(result, ":");
    StrAllocCat(result, lookup_color(fg));
    if (bg >= 0) {
	StrAllocCat(result, ":");
	StrAllocCat(result, lookup_color(bg));
    }
    CTRACE((tfp, "->%s\n", result));
    return result;
}
#endif

/*
 * Initialize a curses color-pair based on our configured color values.
 */
static void lynx_init_color_pair(int n)
{
#ifdef USE_COLOR_STYLE
    (void) n;			/* we only use lynx_color_pairs[] data */
#else
    int m;

    if (lynx_called_initscr) {
	for (m = 0; m <= 16; m += 8) {
	    int pair = n + m + 1;

	    if (pair < COLOR_PAIRS)
		init_pair((short) pair,
			  (short) map2bold(lynx_color_pairs[pair].fg),
			  (short) map2bold(lynx_color_pairs[pair].bg));
	}
	if (n == 0 && LYShowColor >= SHOW_COLOR_ON) {
	    wbkgd(LYwin, COLOR_BKGD | ' ');
	}
    }
#endif
}

static void lynx_map_color(int n)
{
    int j;

    CTRACE((tfp, "lynx_map_color(%d)\n", n));

    if (n + 1 < (int) TABLESIZE(lynx_color_pairs)
	&& n < (int) TABLESIZE(lynx_color_cfg)) {
	for (j = n + 1; j < COLOR_PAIRS_MAX; j += COLOR_CFG_MAX) {
	    lynx_color_pairs[j].fg = lynx_color_cfg[n].fg;
	    lynx_color_pairs[j].bg = lynx_color_cfg[n].bg;
	}

	/* special case (does not apply to 3rd set) */
	lynx_color_pairs[n + 1 + COLOR_CFG_MAX].bg = lynx_color_cfg[0].bg;
    }

    lynx_init_color_pair(n);
}

/*
 * Change a configured color value.  This may be called before initscr(), so
 * we may not be able to call init_pair() to finish the change.
 */
int lynx_chg_color(int color,
		   int fg,
		   int bg)
{
    CTRACE((tfp, "lynx_chg_color(color=%d, fg=%d, bg=%d)\n", color, fg, bg));

    if (fg == ERR_COLOR || bg == ERR_COLOR)
	return -1;
    if (color >= 0 && color < COLOR_CFG_MAX) {
	lynx_color_cfg[color].fg = fg;
	lynx_color_cfg[color].bg = bg;
	lynx_map_color(color);
    } else {
	return -1;
    }
    return 0;
}

void lynx_set_color(int a)
{
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON) {
	(void) wattrset(LYwin, (unsigned) lynx_color_cfg_attr(a)
			| (((a + 1) < COLOR_PAIRS)
			   ? (chtype) get_color_pair(a + 1)
			   : A_NORMAL));
    }
}

void lynx_standout(int flag)
{
    if (flag)
	LYaddAttr(A_REVERSE);
    else
	LYsubAttr(A_REVERSE);
}

static void lynx_init_colors(void)
{
    if (lynx_has_color) {
	size_t n;

	CTRACE((tfp, "lynx_init_colors (default %d/%d)\n",
		default_fg, default_bg));

	lynx_color_cfg[0].fg = default_fg;
	lynx_color_cfg[0].bg = default_bg;

	for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
	    lynx_init_color_pair((int) n);
	}
    } else if (LYShowColor != SHOW_COLOR_NEVER) {
	LYShowColor = SHOW_COLOR_OFF;
    }
}

void lynx_setup_colors(void)
{
    int n;

    CTRACE((tfp, "lynx_setup_colors\n"));
#ifdef USE_DEFAULT_COLORS
    if (!LYuse_default_colors) {
	for (n = 0; n < COLOR_CFG_MAX; n++) {
	    if (lynx_color_cfg[n].dft_fg)
		lynx_color_cfg[n].fg = COLOR_BLACK;
	    if (lynx_color_cfg[n].dft_bg)
		lynx_color_cfg[n].bg = COLOR_WHITE;
	}
    }
#endif
    for (n = 0; n < COLOR_CFG_MAX; n++)
	lynx_map_color(n);
}
#endif /* USE_COLOR_TABLE */

void LYnoVideo(int a)
{
    CTRACE((tfp, "LYnoVideo(%d)\n", a));
#ifdef USE_SLANG
    if (a & 1)
	Masked_Attr |= (int) SLTT_BOLD_MASK;
    if (a & 2)
	Masked_Attr |= (int) SLTT_REV_MASK;
    if (a & 4)
	Masked_Attr |= (int) SLTT_ULINE_MASK;
    lynx_setup_attrs();
#else
#ifdef USE_COLOR_TABLE
    Masked_Attr = decode_mono_code(a);
#endif
#endif
}

#define NEWTERM_NAME "newterm"

#if !defined(VMS) && !defined(USE_SLANG)
#if defined(NCURSES) && defined(HAVE_RESIZETERM)

static SCREEN *LYscreen = NULL;

#define LYDELSCR()		/* ncurses does not need this */

#elif defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN)

static SCREEN *LYscreen = NULL;

#define LYDELSCR() { \
if (recent_sizechange) { \
    CTRACE((tfp, "Screen size: delscreen()\n")); \
    delscreen(LYscreen); \
    LYscreen = NULL; } }

#else /* HAVE_NEWTERM   */

    /*
     * If newterm is not defined, assume a curses subset which
     * supports only initscr.  --gil
     */
static WINDOW *LYscreen = NULL;

#undef  NEWTERM_NAME
#define NEWTERM_NAME "initscr"
#undef  newterm
#define newterm(type, out, in) (initscr())
#define LYDELSCR()		/* nothing */
#endif /* HAVE_NEWTERM   */

#else /* !defined(VMS) && !defined(USE_SLANG) */

    /*
     * Provide last recourse definitions of LYscreen and LYDELSCR for
     * stop_curses, which only tests LYscreen for zero/nonzero but
     * never uses it as a pointer or L-value.
     */
#define LYscreen TRUE
#define LYDELSCR()		/* nothing */
#endif /* !defined(VMS) && !defined(USE_SLANG) */

#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
int saved_scrsize_x = 0;
int saved_scrsize_y = 0;

int saved_scrsize_x2 = 0;
int saved_scrsize_y2 = 0;
int saved_winpos_x2 = 0;
int saved_winpos_y2 = 0;
#endif

#ifdef USE_MAXSCREEN_TOGGLE
static HWND currentWindowHandle = NULL;
static char dummyWindowTitle[256];

static int CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)
{
    char this_title[256];

    if (GetWindowText(hwnd, this_title, sizeof(this_title) - 1) &&
	(strncmp(dummyWindowTitle, this_title, 256) == 0)) {
	currentWindowHandle = hwnd;
	return FALSE;
    }
    return TRUE;
}

static void setCurrentWindowHandle(void)
{
    char org_title[256];
    DWORD pid;
    int i;

    if (currentWindowHandle != NULL) {
	return;
    }
    pid = GetCurrentProcessId();
    sprintf(dummyWindowTitle, "Lynx for Win32 (pid=%ld)", pid);
    GetConsoleTitle(org_title, sizeof(org_title) - 1);
    SetConsoleTitle(dummyWindowTitle);
    for (i = 0; i < 10; i++) {
	EnumWindows(EnumWindowsProc, (LPARAM) 0);
	if (currentWindowHandle != NULL) {
	    break;
	}
	CTRACE((tfp,
		"Failed to get current window handle. Try again...(%d)\n", i));
	Sleep(100);
    }
    SetConsoleTitle(org_title);
}

static void moveWindowHXY(HWND hwnd, int x, int y)
{
    int win_height, win_width;
    RECT winrect;

    GetWindowRect(hwnd, &winrect);
    win_width = winrect.right - winrect.left;
    win_height = winrect.bottom - winrect.top;

    if ((x != winrect.left) || (y != winrect.top)) {
	MoveWindow(hwnd, x, y, win_width, win_height, TRUE);
	CTRACE((tfp, "move window from (%d,%d) to (%d,%d).\n",
		(int) winrect.left,
		(int) winrect.top, x, y));
    }
}

static void adjustWindowPos(void)
{
    int disp_height, disp_width, win_height, win_width;
    int newwin_left, newwin_top;
    RECT winrect;
    DWORD pid;

    setCurrentWindowHandle();
    if (currentWindowHandle == NULL) {
	return;
    }
    GetWindowThreadProcessId(currentWindowHandle, &pid);
    disp_width = GetSystemMetrics(SM_CXFULLSCREEN);
    disp_height = GetSystemMetrics(SM_CYFULLSCREEN);
    Sleep(100);			/* If not, GetWindowRect sometimes return wrong value. */
    GetWindowRect(currentWindowHandle, &winrect);
    win_width = winrect.right - winrect.left;
    win_height = winrect.bottom - winrect.top;
    CTRACE((tfp, "Display Size: (%4d,%3d)\n", disp_width, disp_height));
    CTRACE((tfp, "Orig WinRect: (%4d,%4d,%3d,%3d), ",
	    (int) winrect.left, (int) winrect.right,
	    (int) winrect.top, (int) winrect.bottom));
    CTRACE((tfp, "Size: (%4d,%3d)\n", win_width, win_height));

    newwin_left = winrect.left;
    newwin_top = winrect.top;
    if (disp_width < winrect.right) {
	if (win_width <= disp_width) {
	    newwin_left = disp_width - win_width;
	} else {
	    newwin_left = 0;
	}
    }
    if (disp_height < winrect.bottom) {
	if (win_height <= disp_height) {
	    newwin_top = disp_height - win_height;
	} else {
	    newwin_top = 0;
	}
    }

    moveWindowHXY(currentWindowHandle, newwin_left, newwin_top);
}

void maxmizeWindowSize(void)
{
    int disp_height, disp_width, win_height, win_width;
    RECT winrect;
    DWORD pid;
    int font_width, font_height;

    setCurrentWindowHandle();
    if (currentWindowHandle == NULL) {
	return;
    }
    GetWindowThreadProcessId(currentWindowHandle, &pid);
    disp_width = GetSystemMetrics(SM_CXFULLSCREEN);
    disp_height = GetSystemMetrics(SM_CYFULLSCREEN);
    GetWindowRect(currentWindowHandle, &winrect);
    win_width = winrect.right - winrect.left;
    win_height = winrect.bottom - winrect.top;
    saved_winpos_x2 = winrect.left;
    saved_winpos_y2 = winrect.top;

    if ((win_width <= disp_width) && (win_height <= disp_height)) {
	GetClientRect(currentWindowHandle, &winrect);
	win_width = winrect.right - winrect.left;
	win_height = winrect.bottom - winrect.top;
	CTRACE((tfp, "Current Rect: (%4d,%4d,%3d,%3d), ",
		(int) winrect.left, (int) winrect.right,
		(int) winrect.top, (int) winrect.bottom));
	CTRACE((tfp, "Size: (%4d,%3d)\n", win_width, win_height));

	if (scrsize_x == 0) {
	    scrsize_x = COLS;
	    scrsize_y = LINES + 1;
	}
	if ((scrsize_x == 0) || (scrsize_y == 0)) {
	    CTRACE((tfp, "Illegal value: scrsize_x=%d, scrsize_y=%d\n",
		    scrsize_x, scrsize_y));
	} else {
	    font_width = win_width / scrsize_x;
	    font_height = win_height / scrsize_y;
	    CTRACE((tfp, "Font Size: (%2d,%2d)\n", font_width, font_height));
	    if ((font_width == 0) || (font_height == 0)) {
		CTRACE((tfp, "Illegal font size.\n"));
	    } else {
		LYcols = scrsize_x = (disp_width - 4) / font_width;
		LYlines = scrsize_y = (disp_height - 32) / font_height;
		LYlines--;
		CTRACE((tfp, "Request maximum screen size: %dx%d\n",
			scrsize_y, scrsize_x));
		resize_term(scrsize_y, scrsize_x);
		Sleep(100);
		moveWindowHXY(currentWindowHandle, 0, 0);
		LYlines = LYscreenHeight();
		LYcols = LYscreenWidth();
		CTRACE((tfp, "...actual maximum screen size: %dx%d\n",
			LYlines, LYcols));
		LYStatusLine = -1;
		recent_sizechange = TRUE;
	    }
	}
    }
}

void recoverWindowSize(void)
{
    if ((0 < saved_scrsize_x2) && (0 < saved_scrsize_y2)) {
	LYcols = scrsize_x = saved_scrsize_x2;
	LYlines = scrsize_y = saved_scrsize_y2;
	LYlines--;
	LYStatusLine = -1;
	wclear(curscr);
	doupdate();
	resize_term(scrsize_y, scrsize_x);

	setCurrentWindowHandle();
	if (currentWindowHandle != NULL) {
	    Sleep(100);
	    moveWindowHXY(currentWindowHandle, saved_winpos_x2, saved_winpos_y2);
	}
	recent_sizechange = TRUE;
    } else {
	CTRACE((tfp, "scrsize_{xy} is not saved yet.\n"));
    }
}
#endif

#if defined(USE_DEFAULT_COLORS)
void restart_curses(void)
{
    SCREEN *oldscreen = LYscreen;

    if (!(LYscreen = newterm(NULL, stdout, stdin))) {	/* start curses */
	fprintf(tfp, "%s\n",
		gettext("Terminal reinitialisation failed - unknown terminal type?"));
	exit_immediately(EXIT_FAILURE);
    }

    /* force xterm mouse-mode off in the physical terminal */
    lynx_enable_mouse(0);
    keypad(LYwin, FALSE);
    wrefresh(LYwin);

    LYwin = stdscr;
    /* reenable xterm mouse-mode in the new screen */
    keypad(LYwin, TRUE);
    lynx_enable_mouse(1);

#if defined(USE_KEYMAPS)  
    if (-1 == lynx_initialize_keymaps()) {
	endwin();
	exit_immediately(EXIT_FAILURE);
    }
#endif
    if (has_colors()) {
	start_color();
    }

    delscreen(oldscreen);
}
#endif

void start_curses(void)
{
#ifdef USE_SLANG
    static int slinit;

    if (LYCursesON) {
	CTRACE((tfp, "start_curses: Hmm, already ON.\n"));
	return;
    }

    if (slinit == 0) {
#if defined(HAVE_TTYNAME)
	if (isatty(fileno(stdout)) && LYReopenInput() < 0) {
	    fprintf(stderr, "Cannot open tty input\n");
	    exit_immediately(EXIT_FAILURE);
	}
#endif
#if defined(USE_KEYMAPS)
	if (-1 == lynx_initialize_keymaps())
	    exit_immediately(EXIT_FAILURE);
#else
	SLtt_get_terminfo();
#endif
#if (defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)) || defined(__CYGWIN__)
	SLkp_init();
#endif /* __DJGPP__ && !DJGPP_KEYHANDLER */

#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
#if SLANG_VERSION >= 9935
	SLang_TT_Read_FD = fileno(stdin);
#endif /* SLANG_VERSION >= 9935 */
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */

#if !defined(USE_KEYMAPS) && defined(ENHANCED_LINEEDIT) && defined(ESCDELAY)
	/* way to get ESC that's not part of a recognized sequence through */
	ESCDELAY = 2000;
#endif
	/*
	 * Check whether a saved show_color:off override is in effect.  - kw
	 */
	if (LYrcShowColor == SHOW_COLOR_NEVER) {
	    SLtt_Use_Ansi_Colors = 0;
	}
	/*
	 * Check whether we're forcing color on.  - FM
	 */
	if ((LYShowColor > 1) && (Lynx_Color_Flags & SL_LYNX_USE_COLOR))
	    SLtt_Use_Ansi_Colors = 1;
	/*
	 * Check whether a -nocolor override is in effect.  - kw
	 */
	if (Lynx_Color_Flags & SL_LYNX_OVERRIDE_COLOR)
	    SLtt_Use_Ansi_Colors = 0;
	/*
	 * Make sure our flags are in register.  - FM
	 */
	if (SLtt_Use_Ansi_Colors == 1) {
	    if (LYShowColor != SHOW_COLOR_ALWAYS) {
		LYShowColor = SHOW_COLOR_ON;
	    }
	} else {
	    if (LYShowColor != SHOW_COLOR_NEVER) {
		LYShowColor = SHOW_COLOR_OFF;
	    }
	}
	size_change(0);

#if (defined(VMS) || defined(REAL_UNIX_SYSTEM)) && !defined(__CYGWIN__)
	if ((Masked_Attr & (int) SLTT_ULINE_MASK) == 0) {
	    SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	    SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
	}
	/*
	 * If set, the blink escape sequence will turn on high intensity
	 * background (rxvt and maybe Linux console).
	 */
	SLtt_Blink_Mode = term_blink_is_boldbg;
#endif /* (VMS || REAL_UNIX_SYSTEM) && !__CYGWIN__  */
    }
#ifdef __DJGPP__
    _eth_init();
#endif /* __DJGPP__ */

    slinit = 1;
    Current_Attr = 0;
#ifndef VMS
#if SLANG_VERSION > 9929
    SLang_init_tty(-1, 0, 1);
#else
    SLang_init_tty(3, 0, 1);
#endif /* SLANG_VERSION > 9929 */
#endif /* !VMS */
    SLsmg_init_smg();
    SLsmg_Display_Eight_Bit = LYlowest_eightbit[current_char_set];
    if (SLsmg_Display_Eight_Bit > 191)
	SLsmg_Display_Eight_Bit = 191;	/* may print ctrl chars otherwise - kw */
    scrollok(0, 0);
    SLsmg_Backspace_Moves = 1;
#if SLANG_VERSION > 10306
    SLsmg_touch_screen();
#endif
#ifndef VMS
#if defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__)
    SLtty_set_suspend_state(1);
#endif /* REAL_UNIX_SYSTEM && !__CYGWIN__ */
#ifdef SIGTSTP
    if (!no_suspend)
	signal(SIGTSTP, sl_suspend);
#endif /* SIGTSTP */
    signal(SIGINT, cleanup_sig);
#endif /* !VMS */

    lynx_enable_mouse(1);

#else /* USE_SLANG; Now using curses: */
    int keypad_on = 0;

#ifdef VMS
    /*
     * If we are VMS then do initscr() everytime start_curses() is called!
     */
    CTRACE((tfp, "Screen size: initscr()\n"));
    initscr();			/* start curses */
#else /* Unix: */

#if defined(HAVE_TTYNAME)
    if (isatty(fileno(stdout)) && LYReopenInput() < 0) {
	fprintf(stderr, "Cannot open tty input\n");
	exit_immediately(EXIT_FAILURE);
    }
#endif

#ifdef __CYGWIN__
    /*
     * Workaround for buggy Cygwin, which breaks subprocesses of a
     * full-screen application (tested with cygwin dll, dated
     * 2002/6/23 -TD)
     */
    if (!lynx_called_initscr) {
	FILE *fp = fopen("/dev/tty", "w");

	if (fp != 0)
	    stdout = fp;
    }
#endif

    if (!LYscreen) {
	/*
	 * If we're not VMS then only do initscr() one time, and one time only!
	 */
#if defined(HAVE_NEWTERM)
#if !(defined(NCURSES) && !defined(HAVE_RESIZETERM))
	BOOLEAN savesize;

	savesize = recent_sizechange;
	size_change(0);
	recent_sizechange = savesize;	/* avoid extra redraw */
#if defined(__MVS__)
	{
	    /*
	     * The requirement to do this may be a bug in OS/390.
	     *
	     * Put screen geometry in environment variables used by
	     * XOpen curses before calling newterm().  I believe this
	     * completes work left unfinished by AJL & FM -- gil
	     */
	    static char lines_putenv[] = "LINES=abcde", cols_putenv[] = "COLUMNS=abcde";

	    sprintf(lines_putenv + 6, "%d", LYlines & 0xfff);
	    sprintf(cols_putenv + 8, "%d", LYcols & 0xfff);
	    putenv(lines_putenv);
	    putenv(cols_putenv);
	    CTRACE((tfp, "start_curses putenv %s, %s\n", lines_putenv, cols_putenv));
	}
#endif /* defined(__MVS__) */
#endif /* !(defined(NCURSES) && defined(HAVE_RESIZETERM)) */
	CTRACE((tfp, "Screen size: %s()\n", NEWTERM_NAME));
	if (!(LYscreen = newterm(NULL, stdout, stdin))) {	/* start curses */
	    fprintf(tfp, "%s\n",
		    gettext("Terminal initialisation failed - unknown terminal type?"));
	    exit_immediately(EXIT_FAILURE);
	}
#else
	CTRACE((tfp, "Screen size: initscr()\n"));
	initscr();
#endif /* HAVE_NEWTERM */
	lynx_called_initscr = TRUE;
	LYlines = LYscreenHeight();
	LYcols = LYscreenWidth();

#if defined(SIGWINCH) && defined(NCURSES_VERSION)
	size_change(0);
	recent_sizechange = FALSE;	/* prevent mainloop drawing 1st doc twice */
#endif /* SIGWINCH */
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols));

#ifdef USE_CURSES_PADS
	if (LYuseCursesPads) {
	    CTRACE((tfp, "using curses-pads\n"));
	    LYwin = newpad(LYlines, MAX_COLS);
	    LYshiftWin = 0;
	    LYwideLines = FALSE;
	} else {
	    LYwin = stdscr;
	}
#endif

#if defined(USE_KEYMAPS) && defined(NCURSES_VERSION)
#  if HAVE_KEYPAD
	/* Need to switch keypad on before initializing keymaps, otherwise
	   when the keypad is switched on, some keybindings may be overriden. */
	keypad(LYwin, TRUE);
	keypad_on = 1;
#  endif /* HAVE_KEYPAD */

	if (-1 == lynx_initialize_keymaps()) {
	    endwin();
	    exit_immediately(EXIT_FAILURE);
	}
#endif /* ncurses-keymaps */

	/*
	 * This is a workaround for a bug in SVr4 curses, observed on Solaris
	 * 2.4:  if your terminal's alternate-character set contains codes in
	 * the range 128-255, they'll be sign-extended in the acs_map[] table,
	 * which in turn causes their values to be emitted as 255 (0xff).
	 * "Fix" this by forcing the table to 8-bit codes (it has to be
	 * anyway).
	 */
#if defined(ALT_CHAR_SET) && !defined(NCURSES_VERSION)
	{
	    int n;

	    for (n = 0; n < 128; n++)
		if (ALT_CHAR_SET[n] & 0x80) {
		    ALT_CHAR_SET[n] &= 0xff;
		    ALT_CHAR_SET[n] |= A_ALTCHARSET;
		}
	}
#endif

#if defined(USE_COLOR_STYLE) || defined(USE_COLOR_TABLE)
	if (has_colors()) {
	    lynx_has_color = TRUE;
	    start_color();

#ifndef COLORS
	    /* map2boldc() relies on COLORS being a power of 2 */
	    if (COLORS > 16)
		COLORS = 16;
	    if (COLORS < 8)
		COLORS = 2;
	    if (COLORS > 8 && COLORS != 16)
		COLORS = 8;
#endif

#ifdef USE_DEFAULT_COLORS
	    update_default_colors();
	    if (LYuse_default_colors) {
#if defined(EXP_ASSUMED_COLOR) && defined(USE_COLOR_TABLE)
		/*
		 * Adjust the color mapping table to match the ASSUMED_COLOR
		 * setting in lynx.cfg
		 */
		if (assume_default_colors(default_fg, default_bg) != OK) {
		    default_fg = COLOR_WHITE;
		    default_bg = COLOR_BLACK;
		}
		CTRACE((tfp, "initializing default colors %d/%d\n",
			default_fg, default_bg));
		if (default_fg >= 0 || default_bg >= 0) {
		    unsigned n;

		    for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
			if (default_fg >= 0 && lynx_color_cfg[n].fg < 0)
			    lynx_color_cfg[n].fg = default_fg;
			if (default_bg >= 0 && lynx_color_cfg[n].bg < 0)
			    lynx_color_cfg[n].bg = default_bg;
			CTRACE((tfp, "color_cfg[%u] = %d/%d\n", n,
				lynx_color_cfg[n].fg,
				lynx_color_cfg[n].bg));
		    }
		    lynx_setup_colors();
		}
#else
#if defined(HAVE_USE_DEFAULT_COLORS)
		if (!default_color_reset) {
		    if (lynx_called_initscr) {
			if (LYuse_default_colors && (use_default_colors() == OK)) {
			    default_fg = DEFAULT_COLOR;
			    default_bg = DEFAULT_COLOR;
			} else {
			    default_fg = COLOR_WHITE;
			    default_bg = COLOR_BLACK;
			    default_color_reset = TRUE;
			}
		    }
		}
#endif /* HAVE_USE_DEFAULT_COLORS */
#endif /* EXP_ASSUMED_COLOR */
	    }
#endif /* USE_DEFAULT_COLORS */
	}
#endif /* USE_COLOR_STYLE || USE_COLOR_TABLE */

#ifdef USE_COLOR_STYLE
	/* Curses forgets color settings when we call delscreen() */
	if (non_empty(lynx_lss_file) && LYCanReadFile(lynx_lss_file)) {
	    style_readFromFile(lynx_lss_file);
	}
	parse_userstyles();
#endif
#ifdef USE_COLOR_TABLE
	lynx_init_colors();
#endif
    }
#ifdef __DJGPP__
    _eth_init();
#endif /* __DJGPP__ */
#endif /* not VMS */

#ifdef VMS
    crmode();
    raw();
#else
#ifdef HAVE_CBREAK
    cbreak();
#else
    crmode();
#endif /* HAVE_CBREAK */
    signal(SIGINT, cleanup_sig);
#endif /* VMS */

    noecho();

#ifdef HAVE_KEYPAD
    if (!keypad_on)
	keypad(LYwin, TRUE);
#endif /* HAVE_KEYPAD */

    lynx_enable_mouse(1);

    fflush(stdin);
    fflush(stdout);
    fflush(stderr);
#endif /* USE_SLANG */

#if defined(WIN_EX)
    LYclear();
#endif

#if defined(USE_BLINK) && defined(__EMX__)
    if (term_blink_is_boldbg)	/* Now actually make it so! */
	make_blink_boldbg();
#endif

    LYCursesON = TRUE;
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    if ((scrsize_x != 0) && (scrsize_y != 0)) {
	if (saved_scrsize_x == 0) {
	    saved_scrsize_x = COLS;
	    saved_scrsize_y = LINES + 1;
	}
	CTRACE((tfp, "resize_term: x=%d, y=%d\n", scrsize_x, scrsize_y));
	CTRACE((tfp, "saved terminal size: x=%d, y=%d\n", saved_scrsize_x, saved_scrsize_y));
	resize_term(scrsize_y, scrsize_x);
	LYlines = LYscreenHeight();
	LYcols = LYscreenWidth();
	LYStatusLine = -1;
	LYclear();
#ifdef _WINDOWS
	adjustWindowPos();
#endif
    }
    if (saved_scrsize_x2 == 0) {
	if (saved_scrsize_x == 0) {
	    saved_scrsize_x2 = COLS;
	    saved_scrsize_y2 = LINES + 1;
	} else {
	    saved_scrsize_x2 = scrsize_x;
	    saved_scrsize_y2 = scrsize_y;
	}
    }
#endif
    CTRACE((tfp, "start_curses: done.\n"));
}				/* end of start_curses() */

void lynx_enable_mouse(int state)
{
#ifdef USE_MOUSE
/***********************************************************************/

#if defined(WIN_EX)
/* modify lynx_enable_mouse() for pdcurses configuration so that mouse support
   is disabled unless -use_mouse is specified
*/
    HANDLE hConIn = INVALID_HANDLE_VALUE;

    hConIn = GetStdHandle(STD_INPUT_HANDLE);
    if (LYUseMouse == 0) {
	SetConsoleMode(hConIn, ENABLE_WINDOW_INPUT);
	FlushConsoleInputBuffer(hConIn);
	return;
    }
#endif

    (void) state;

    if (LYUseMouse == 0)
	return;

#if defined(USE_SLANG)
    SLtt_set_mouse_mode(state, 0);
    SLtt_flush_output();
#else

#if defined(WIN_EX) && defined(PDCURSES)
    if (state) {
	SetConsoleMode(hConIn, ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT);
	FlushConsoleInputBuffer(hConIn);
    }
#else
#if defined(NCURSES)
    if (state) {
	/* Compensate for small value of maxclick in ncurses.  */
	static int was = 0;

	if (!was) {
	    int old = mouseinterval(-1);

	    was++;
	    if (old < 200)	/* Default 166 */
		mouseinterval(300);
	}
	/* Inform ncurses which mouse events we're interested in.
	 * We shouldn't need to include BUTTONn_PRESSED and BUTTONn_RELEASED
	 * events, since ncurses should translate them to click events. - kw
	 * However, if we do not include them, then ncurses effectively
	 * ignores mouseinterval(), thus translates *any* sequence of
	 * press/release to a click, which leads to inconveniences.
	 * We special-case these events in LYStrings.c.
	 */
	mousemask(BUTTON_CTRL | BUTTON_ALT
		  | BUTTON1_PRESSED | BUTTON1_RELEASED
		  | BUTTON1_CLICKED
		  | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
		  | BUTTON2_PRESSED | BUTTON2_RELEASED
		  | BUTTON2_CLICKED
		  | BUTTON3_PRESSED | BUTTON3_RELEASED
		  | BUTTON3_CLICKED
		  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED
#if NCURSES_MOUSE_VERSION >= 2
		  | BUTTON4_PRESSED | BUTTON4_RELEASED
		  | BUTTON4_CLICKED
		  | BUTTON4_DOUBLE_CLICKED | BUTTON4_TRIPLE_CLICKED
		  | BUTTON5_PRESSED | BUTTON5_RELEASED
		  | BUTTON5_CLICKED
		  | BUTTON5_DOUBLE_CLICKED | BUTTON5_TRIPLE_CLICKED
#endif
		  ,NULL);
    } else
	mousemask(0, NULL);
#endif /* NCURSES */
#endif /* WIN_EX and PDCURSES */

#if defined(PDCURSES)
    if (state)
	mouse_set(
		     BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		     BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		     BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
#endif
#endif /* NOT USE_SLANG */

/***********************************************************************/
#endif /* USE_MOUSE */
}

/*
 * SVr4 curses (and ncurses) initialize the terminal I/O to raw mode, and
 * simulate other modes in the library.  This means that when running, it
 * simulates the OCRNL setting.  Normally that is not a problem.  However, when
 * spawning a subprocess (e.g., xli), the subprocess may write to the screen.
 * Fine so far - curses resets the terminal I/O to the normal state on exit.
 * But the subprocess's messages can still be coming to the screen when lynx
 * returns to the screen mode.  This function delays restoring OCRNL until
 * after the first getch() call.
 *
 * The OCRNL setting is controlled by nl()/nonl() of course - but we do not
 * want to give up that optimization since it would be a bit slower.  (Note -
 * slang does not use this optimization; if it did, the same screen glitch
 * would occur).
 *
 * FIXME:  for simplicity, only ncurses is implemented here - the TTY and
 * SET_TTY definitions are ncurses-specific.  The same effect could be done for
 * other curses implementations, since the "cur_term->Nttyb" part is common to
 * SVr4 curses.
 */
void lynx_nl2crlf(int normal GCC_UNUSED)
{
#if defined(NCURSES_VERSION_PATCH) && defined(SET_TTY) && defined(TERMIOS) && defined(ONLCR)
    static TTY saved_tty;
    static int did_save = FALSE;
    static int waiting = FALSE;
    static int can_fix = TRUE;

    if (!did_save) {
	if (cur_term == 0) {
	    can_fix = FALSE;
	} else {
	    saved_tty = cur_term->Nttyb;
	    did_save = TRUE;
#if NCURSES_VERSION_PATCH < 20010529
	    /* workaround for optimizer bug with nonl() */
	    if ((tigetstr("cud1") != 0 && *tigetstr("cud1") == '\n')
		|| (tigetstr("ind") != 0 && *tigetstr("ind") == '\n'))
		can_fix = FALSE;
#endif
	}
    }
    if (can_fix) {
	if (normal) {
	    if (!waiting) {
		cur_term->Nttyb.c_oflag |= ONLCR;
		waiting = TRUE;
		nonl();
	    }
	} else {
	    if (waiting) {
		cur_term->Nttyb = saved_tty;
		SET_TTY(fileno(stdout), &saved_tty);
		waiting = FALSE;
		nl();
		LYrefresh();
	    }
	}
    }
#endif
}

void stop_curses(void)
{
    if (LYCursesON) {
#ifdef USE_COLOR_STYLE
	FreeCachedStyles();
#endif
	echo();
    }
#if defined(PDCURSES) && defined(PDC_BUILD) && PDC_BUILD >= 2401
    resetty();
#endif

#ifdef __DJGPP__
    _eth_release();
#endif /* __DJGPP__ */

/* ifdef's for non-Unix curses or slang */
#if defined(__MINGW32__)
    {
	chtype bb;

	bb = getbkgd(stdscr);
	bkgdset(0);
	clear();
	refresh();
	bkgdset(bb);
    }
#if defined(PDCURSES)
    endwin();
#endif /* PDCURSES */

#elif defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC))

#if defined(PDCURSES)
    endwin();
#endif /* PDCURSES */

#ifdef __DJGPP__
    ScreenClear();
#elif !defined(PDCURSES) /* some flavor of win32?  */
    clrscr();
#endif /* win32 */

#else /* Unix, etc */

    if (LYCursesON == TRUE) {
	lynx_nl2crlf(TRUE);
	lynx_enable_mouse(0);
	if (LYscreen || lynx_called_initscr) {
	    endwin();		/* stop curses */
	    LYDELSCR();
	}
    } else {
#ifdef SH_EX
	int i;

	for (i = 0; i <= 3; i++) {
	    printf("\r\n");
	}
#endif
    }

    fflush(stdout);
#endif /* ifdef's for non-Unix curses or slang */
    fflush(stderr);

    LYCursesON = FALSE;
    CTRACE((tfp, "stop_curses: done.\n"));

#if defined(SIGTSTP) && defined(USE_SLANG)
#ifndef VMS
    if (!no_suspend)
	signal(SIGTSTP, SIG_DFL);
#endif /* !VMS */
#endif /* SIGTSTP && USE_SLANG */

#ifndef VMS
    signal(SIGINT, SIG_DFL);
#endif /* !VMS */
}

#ifdef VMS

#ifdef USE_SLANG
extern void longname(char *, char *);
#endif /* USE_SLANG */

/*
 * Check terminal type, start curses & setup terminal.
 */
BOOLEAN setup(char *terminal)
{
    int c;
    int status;
    char *dummy = 0, *cp, term[81];

    /*
     * If the display was not set by a command line option then see if it is
     * available from the environment.
     */
    if ((cp = LYgetXDisplay()) != 0) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }

    /*
     * Get terminal type, and convert to lower case.
     */
    term[0] = '\0';
    longname(dummy, term);
    if (term[0] == '\0' && (form_get_data || form_post_data)) {
	/*
	 * Some yoyo used these under conditions which require -dump, so force
	 * that mode here.  - FM
	 */
	dump_output_immediately = TRUE;
	LYcols = DFT_COLS;
	if (keypad_mode == NUMBERS_AS_ARROWS)
	    keypad_mode = LINKS_ARE_NUMBERED;
	status = mainloop();
	exit_immediately(status);
    }
    LYLowerCase(term);

    printf("%s%s\n", gettext("Terminal ="), term);
    if ((strlen(term) < 5) ||
	StrNCmp(term, "vt", 2) || !isdigit(term[2])) {
	printf("%s\n",
	       gettext("You must use a vt100, 200, etc. terminal with this program."));
	printf(CONFIRM_PROCEED, "n/y");
	c = getchar();
	if (c != 'y' && c != 'Y') {
	    printf("\n");
	    return (FALSE);
	}
	strcpy(term, "vt100");
    }

    ttopen();
    start_curses();

    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();

    return (TRUE);
}

#else /* Not VMS: */

/*
 * Check terminal type, start curses & setup terminal.
 */
BOOLEAN setup(char *terminal)
{
    char *term_putenv = NULL;
    char *buffer = NULL;
    char *cp;

    /*
     * If the display was not set by a command line option then see if it is
     * available from the environment .
     */
    if ((cp = LYgetXDisplay()) != NULL) {
	StrAllocCopy(x_display, cp);
    } else {
	FREE(x_display);
    }

    if (terminal != NULL) {
	HTSprintf0(&term_putenv, "TERM=%.106s", terminal);
	(void) putenv(term_putenv);
    }

    /*
     * Query the terminal type.
     */
    if (dumbterm(LYGetEnv("TERM"))) {
	printf("\n\n  %s\n\n", gettext("Your Terminal type is unknown!"));
	printf("  %s [vt100] ", gettext("Enter a terminal type:"));

	if (LYSafeGets(&buffer, stdin) != 0) {
	    LYTrimLeading(buffer);
	    LYTrimTrailing(buffer);
	}

	if (isEmpty(buffer))
	    StrAllocCopy(buffer, "vt100");

	HTSprintf0(&term_putenv, "TERM=%.106s", buffer);
	FREE(buffer);

	(void) putenv(term_putenv);
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"),
	       LYGetEnv("TERM"));
	LYSleepMsg();
    }

    start_curses();

#ifdef HAVE_TTYTYPE
    /*
     * Account for lossage on the 'sun' terminal type (80x24) Sun text console
     * driver.  It only supports reverse video, but all SGR sequences produce
     * that same reverse video, and the terminfo entry lists different SGRs for
     * 'bold' and 'rev'.  As a result, the current link is indistinguishable
     * from all other links.  The workaround here is to disable the 'rev'
     * capability.
     */
    if ((StrNCmp((const char *) ttytype, "sun", 3) == 0)) {
	LYnoVideo(2);
    }
#endif /* HAVE_TTYTYPE */

    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();

    return (1);
}

static int dumbterm(char *terminal)
{
    int dumb = FALSE;

    /*
     * Began checking for terminal == NULL in case that TERM environment
     * variable is not set.  Thanks to Dick Wesseling (ftu@@fi.ruu.nl).
     */
    if (terminal == NULL ||
	!strcasecomp(terminal, "network") ||
	!strcasecomp(terminal, "unknown") ||
	!strcasecomp(terminal, "dialup") ||
	!strcasecomp(terminal, "dumb") ||
	!strcasecomp(terminal, "switch") ||
	!strcasecomp(terminal, "ethernet"))
	dumb = TRUE;
    return (dumb);
}

#ifdef FANCY_CURSES
#ifndef USE_COLOR_STYLE
#ifdef USE_COLOR_TABLE
static void LYsetWAttr(WINDOW * win)
{
    (void) wattrset(win, LYgetTableAttr());
}

void LYaddWAttr(WINDOW * win, int a)
{
    Current_Attr |= a;
    LYsetWAttr(win);
}

void LYaddAttr(int a)
{
    LYaddWAttr(LYwin, a);
}

void LYsubWAttr(WINDOW * win, int a)
{
    Current_Attr &= ~a;
    LYsetWAttr(win);
}

void LYsubAttr(int a)
{
    LYsubWAttr(LYwin, a);
}
#endif /* USE_COLOR_TABLE */
#endif /* !USE_COLOR_STYLE */
#endif /* FANCY_CURSES */
#endif /* VMS */

/* Use this rather than the 'wprintw()' function to write a blank-padded
 * string to the given window, since someone's asserted that printw doesn't
 * handle 8-bit characters unlike addstr (though more info would be useful).
 *
 * We're blank-filling so that with SVr4 curses, it'll show the background
 * color to a uniform width in the popup-menu.
 */
#ifndef USE_SLANG
void LYpaddstr(WINDOW * the_window, int width, const char *the_string)
{
    int y, x1, x2;
    int length = (int) strlen(the_string);

#ifdef WIDEC_CURSES
    int actual = (int) LYstrCells(the_string);
#endif

    getyx(the_window, y, x1);
    (void) y;
    if (width + x1 > LYcolLimit)
	width = LYcolLimit - x1;
#ifdef WIDEC_CURSES
    if (actual > width) {
	actual = width;
	/* FIXME: a binary search might be faster */
	while (LYstrExtent(the_string, length, length) > actual) {
	    --length;
	}
    }
#endif
    LYwaddnstr(the_window, the_string, (size_t) length);
    getyx(the_window, y, x2);
    width -= (x2 - x1);
    while (width-- > 0)
	waddstr(the_window, " ");
}

/*
 * Work around limitation of curses's order-of-refresh by setting a pointer to
 * the topmost window that should be displayed.
 *
 * FIXME: the associated call on 'keypad()' is not needed for Unix, but
 * something in the OS/2 EMX port requires it.
 */
static WINDOW *my_subwindow;

void LYsubwindow(WINDOW * param)
{
    if (param != 0) {
	my_subwindow = param;
#if defined(NCURSES) || defined(PDCURSES)
	keypad(my_subwindow, TRUE);
#if defined(USE_COLOR_STYLE)
	LynxWChangeStyle(my_subwindow, s_menu_bg, STACK_ON);
	{
	    long b = LYgetattrs(my_subwindow);

	    wbkgd(my_subwindow, (chtype) (b | ' '));
	}
	LynxWChangeStyle(my_subwindow, s_menu_bg, STACK_OFF);
#elif defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
	wbkgd(my_subwindow, getbkgd(LYwin));
#endif
#endif
	scrollok(my_subwindow, TRUE);
    } else {
	touchwin(LYwin);
	delwin(my_subwindow);
	my_subwindow = 0;
    }
}

WINDOW *LYtopwindow(void)
{
    return (my_subwindow ? my_subwindow : LYwin);
}
#endif

WINDOW *LYstartPopup(int *top_y,
		     int *left_x,
		     int *height,
		     int *width)
{
    WINDOW *form_window = 0;

#ifdef USE_SLANG
    static WINDOW fake_window;

    if (*left_x < 1 || (*left_x + *width + 4) >= LYcolLimit) {
	*left_x = 1;
	*width = LYcolLimit - 5;
    }

    SLsmg_fill_region(*top_y,
		      *left_x - 1,
		      (unsigned) *height,
		      (unsigned) *width + 4,
		      ' ');
    form_window = &fake_window;
    form_window->top_y = *top_y;
    form_window->left_x = *left_x;
    form_window->height = *height;
    form_window->width = *width;
#else
    if (*left_x > 0 && (*left_x + *width + 4) < LYcolLimit)
	form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
    if (form_window == 0) {
	if (*width > LYcolLimit - 4) {
	    *width = LYcolLimit - 4;
	    *left_x = 1;
	} else {
	    *left_x = LYcolLimit - 4 - *width;
	    if (*left_x <= 0)
		*left_x = 1;
	}
	form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
    }
    if (form_window == 0) {
	HTAlert(POPUP_FAILED);
    } else {
	LYsubwindow(form_window);
    }
#endif /* USE_SLANG */
    return form_window;
}

void LYstartTargetEmphasis(void)
{
#ifdef USE_COLOR_STYLE
    if (s_whereis != NOSTYLE) {
	curses_style(s_whereis, STACK_ON);
	return;
    }
#endif
#if defined(FANCY_CURSES) || defined(USE_SLANG)
    lynx_start_bold();
    lynx_start_reverse();
#endif /* FANCY_CURSES || USE_SLANG */
    lynx_start_underline();
}

void LYstopTargetEmphasis(void)
{
#ifdef USE_COLOR_STYLE
    if (s_whereis != NOSTYLE) {
	curses_style(s_whereis, STACK_OFF);
	return;
    }
#endif
    lynx_stop_underline();
#if defined(FANCY_CURSES) || defined(USE_SLANG)
    lynx_stop_reverse();
    lynx_stop_bold();
#endif /* FANCY_CURSES || USE_SLANG */
}

/*
 * Accommodate the different flavors of touchline
 */
void LYtouchline(int row)
{
#if defined(HAVE_WREDRAWLN) && !defined(NCURSES_VERSION)
    wredrawln(LYwin, row, 1);
#else
#if defined(HAVE_TOUCHLINE)
    /* touchline() is not available on VMS before version 7.0, and then only on
     * Alpha, since prior ports of curses were broken.  BSD touchline() has a
     * 4th parameter since it is used internally by touchwin().
     */
#if defined(HAVE_BSD_TOUCHLINE)
    touchline(LYwin, row, 0, COLS);
#else
    touchline(LYwin, row, 1);
#endif
#else
#if !defined(USE_SLANG)
    touchwin(LYwin);
#else
    SLsmg_touch_lines(row, 1);
#endif
#endif
#endif
}

/*
 * Wrapper for waddnstr().
 */
void LYwaddnstr(WINDOW * w GCC_UNUSED,
		const char *src,
		size_t len)
{
    int y0, x0;
    int y, x;
    size_t inx;

#ifdef USE_CURSES_PADS
    /*
     * If we've configured to use pads for left/right scrolling, that can
     * interfere with calls to this function that assume they're wrapping. 
     * Writing to a pad which is wider than the screen will simply not wrap.
     *
     * Link-highlighting uses wrapping.  You can see this by viewing the
     * options screen in a terminal which is narrower than 80 columns.
     *
     * Check for that case, and use curses's wrapping in a derived window to
     * simplify things, e.g., in case the string contains multibyte or
     * multicolumn characters.
     */
    getyx(LYwin, y0, x0);

    if (LYuseCursesPads
	&& (LYwin == w)
	&& (LYshiftWin == 0)
	&& LYwideLines == FALSE
	&& ((int) len > (LYcolLimit - x0))
	&& (y0 >= 0)
	&& (x0 >= 0)
	&& (x0 < LYcolLimit)) {
	WINDOW *sub = derwin(LYwin, LYlines, LYcolLimit, 0, 0);

	if (sub != 0) {
	    wmove(sub, y0, x0);
	    LYwideLines = TRUE;
	    LYwaddnstr(sub, src, len);
	    getyx(sub, y0, x0);
	    delwin(sub);
	    wmove(LYwin, y0, x0);
	}
	LYwideLines = FALSE;

	return;
    }
#endif
    /*
     * We only want to trace this function for the color-style code.  It would
     * be too much logging if not needed.
     */
#ifdef USE_COLOR_STYLE
    if (TRACE) {
	LYGetYX(y, x);
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s, %u)\n",
			      y, x, (int) len, src, (unsigned) len));
    }
#endif
    LYGetYX(y0, x0);

    for (inx = 0; inx < len; ++inx) {
	/*
	 * Do tab-expansion relative to the base of the string (rather than
	 * the screen) so that tabs in a TEXTAREA will look right.
	 */
	if (src[inx] == '\t') {
	    LYGetYX(y, x);
	    while ((++x - x0) % 8)
		waddch(w, ' ');
	    waddch(w, ' ');
	} else {
	    waddch(w, UCH(src[inx]));
	}
    }
}

/*
 * Determine the number of cells the given string would take up on the screen,
 * limited (in the case of wide characters) by the maxCells parameter.
 *
 * If the returnCellNum parameter is TRUE, return the number of cells;
 * otherwise, return the length (limited by the len parameter) of the prefix of
 * the string that fits in maxCells cells.
 */
static
int LYstrExtent0(const char *string,
		 int len,
		 int maxCells GCC_UNUSED,
		 int retCellNum GCC_UNUSED)
{
    int used = (len < 0 ? (int) strlen(string) : len);
    int result = used;

#ifdef WIDEC_CURSES
    if (used > 0 && lynx_called_initscr) {
	static WINDOW *fake_win;
	static int fake_max;

	if (fake_max < maxCells) {
	    fake_max = (maxCells + 1) * 2;
	    if (fake_win != 0) {
		delwin(fake_win);
		fake_win = 0;
	    }
	}
	if (fake_win == 0) {
	    fake_win = newwin(2, fake_max, 0, 0);
	}
	if (fake_win != 0) {
	    int new_x = 0;
	    int new_y = 0;
	    int x = 0;
	    int n;

	    wmove(fake_win, 0, 0);
	    for (n = 0; n < used; ++n) {
		if (IsNormalChar(string[n])) {
		    waddch(fake_win, UCH(string[n]));
		    getyx(fake_win, new_y, new_x);
		    if (new_y > 0 || new_x > maxCells)
			break;
		    x = new_x;
		}
	    }
	    result = (retCellNum ? x : n);
	}
    }
#endif
    return result;
}

/*
 * Determine the number of cells the given string would take up on the screen,
 * limited by the maxCells parameter.  This is used for constructing aligned
 * text in the options and similar forms.
 *
 * FIXME: make this account for wrapping, too.
 * FIXME: make this useful for "lynx -dump", which hasn't initialized curses.
 */
int LYstrExtent(const char *string, int len, int maxCells)
{
    int result = LYstrExtent0(string, len, maxCells, TRUE);

    return (result > maxCells ? maxCells : result);
}

/*
 * Return the number of cells in the first 'len' bytes of the string.
 *
 * This relies upon the coincidence that multicell characters use at least as
 * many bytes as cells.  But we have to account for tab, which can use 8, and
 * control characters which use 2.
 */
int LYstrExtent2(const char *string, int len)
{
    return LYstrExtent(string, len, 8 * len);
}

/*
 * Determine the longest prefix of a string that fits in a given number of
 * cells and return its length.
 */
int LYstrFittable(const char *string, int maxCells)
{
    return LYstrExtent0(string, -1, maxCells, FALSE);
}

/*
 * Returns the total number of cells that the string would use.
 */
int LYstrCells(const char *string)
{
    return LYstrExtent2(string, (int) strlen(string));
}

#ifdef VMS
/*
 *	Cut-down termio --
 *		Do character-oriented stream input for Jeff.
 *		Code ripped off from Micro-Emacs 3.7 by Daniel Lawrence.
 *
 *		Ever-so-slightly modified by Kathryn Huxtable.	29-Jan-1991.
 *		Cut down for Lou.  8 Sep 1992.
 *		Cut down farther for Lou.  19 Apr 1993.
 *			We don't set PASSALL or PASTHRU since we don't
 *			want to block CTRL/C, CTRL/Y, CTRL/S or CTRL/Q.
 *			Simply setting NOECHO and doing timed reads
 *			is sufficient.
 *		Further mods by Fote.  29-June-1993
 *			ttopen() and ttclose() are now terminal initialization
 *			 and restoration procedures, called once at startup
 *			 and at exit, respectively, of the LYNX image.
 *			ttclose() should be called before an exit from LYNX
 *			 no matter how the exit is invoked.
 *			setup(terminal) does the ttopen().
 *			cleanup() calls cleanup_files() and ttclose().
 *			ttgetc() now handles NOECHO and NOFLITR (instead of
 *			 setting the terminal itself to NOECHO in ttopen()).
 *			VMSsignal() added for handling both Ctrl-C *and* Ctrl-Y
 *			 interrupts, and disabling system response to Ctrl-T.
 *		Further mods by Fote.  15-Dec-1993
 *			Added edit handler in ttopen() which will invoke
 *			 VMSexit() and behave intelligently on ACCVIO's.
 *		Further mods by Fote.  29-Dec-1993
 *			Simplified ttgetc().
 *		Further mods by Fote.  16-Jan-1994
 *			Added code in ttopen() which will invoke VMSVersion()
 *			 to get the version of VMS as VersionVMS for use by
 *			 by new or modified interrupt or spawning routines.
 *		Further mods by Fote.  27-Jan-1994
 *			Added back a typeahead() which supports 'z' or 'Z' as
 *			an "Zap transfer" command via HTCheckForInterrupt()
 *			in LYUtils.c.
 */

#include <descrip.h>
#include <iodef.h>
#include <ssdef.h>
#include <msgdef.h>
#include <ttdef.h>
#include <tt2def.h>
#include <libclidef.h>
#include <lib$routines.h>
#include <starlet.h>
#include <clidef.h>
#include <syidef.h>
#ifdef signal
#undef signal
#endif /* signal */
#include <signal.h>
#ifdef system
#undef system
#endif /* system */
#include <processes.h>
#include <LYVMSdef.h>

#define EFN	0		/* Event flag                   */

static unsigned char buffer[20];	/* Input buffer                 */
static int in_pos, in_len;	/* For escape sequences         */
static int oldmode[3];		/* Old TTY mode bits            */
static int newmode[3];		/* New TTY mode bits            */
static short iochan;		/* TTY I/O channel              */
static $DESCRIPTOR(term_nam_dsc, "TT");		/* Descriptor for iochan        */
static unsigned long mask = LIB$M_CLI_CTRLY | LIB$M_CLI_CTRLT;	/* ^Y and ^T */
static unsigned long old_msk;	/* Saved control mask           */
static short trap_flag = FALSE;	/* TRUE if AST is set           */
BOOLEAN DidCleanup = FALSE;	/* Exit handler flag            */
static char VersionVMS[20];	/* Version of VMS               */

int VMSVersion(char *VerString,
	       int VerLen)
{
    unsigned long status, itm_cod = SYI$_VERSION;
    int i, verlen = 0;
    struct dsc$descriptor version;
    char *m;

    version.dsc$a_pointer = VerString;
    version.dsc$w_length = VerLen - 1;
    version.dsc$b_dtype = DSC$K_DTYPE_B;
    version.dsc$b_class = DSC$K_CLASS_S;

    status = lib$getsyi(&itm_cod, 0, &version, &verlen, 0, 0);
    if (!(status & 1) || verlen == 0)
	return 0;

    /*
     * Cut out trailing spaces
     */
    for (m = VerString + verlen, i = verlen - 1; i > 0 && VerString[i] == ' '; --i)
	*(--m) = '\0';

    return strlen(VerString) + 1;	/* Transmit ending 0 too */
}

void VMSexit(void)
{
    /*
     * If we get here and DidCleanup is not set, it was via an ACCVIO, or
     * outofmemory forced exit, so make *sure* we attempt a cleanup and reset
     * the terminal.
     */
    if (!DidCleanup) {
	if (LYOutOfMemory == FALSE) {
	    fprintf(stderr,
		    gettext("\nA Fatal error has occurred in %s Ver. %s\n"),
		    LYNX_NAME, LYNX_VERSION);
	    fprintf(stderr,
		    gettext("\nPlease notify your system administrator to confirm a bug, and if\n\
confirmed, to notify the lynx-dev list.  Bug reports should have concise\n\
descriptions of the command and/or URL which causes the problem, the\n\
operating system name with version number, the TCPIP implementation, the\n\
TRACEBACK if it can be captured, and any other relevant information.\n"));

	    if (LYTraceLogFP == NULL) {
		fprintf(stderr, RETURN_TO_CLEANUP);
		(void) getchar();
	    }
	} else if (LYCursesON) {
	    HTAlert(MEMORY_EXHAUSTED_ABORT);
	}
	cleanup();
    }
    if (LYOutOfMemory == TRUE) {
	printf("\r\n%s\r\n\r\n", MEMORY_EXHAUSTED_ABORT);
	fflush(stdout);
	fflush(stderr);
    }
}

/*
 *	TTOPEN --
 *		This function is called once to set up the terminal
 *		device streams.  It translates TT until it finds
 *		the terminal, then assigns a channel to it, sets it
 *		to EDIT, and sets up the Ctrl-C and Ctrl-Y interrupt
 *		handling.
 */
int ttopen(void)
{
    int iosb[2];
    int status;
    static unsigned long condition;
    static struct _exit_block {
	unsigned long forward;
	unsigned long address;
	unsigned long zero;
	unsigned long condition;
    } exit_handler_block;

    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = sys$qiow(EFN, iochan, IO$_SENSEMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit_immediately(status);

    newmode[0] = oldmode[0];
    newmode[1] = oldmode[1];
    newmode[2] = oldmode[2] | TT2$M_EDIT;

    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &newmode, sizeof(newmode), 0, 0, 0, 0);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    status = iosb[0] & 0xFFFF;
    if (status != SS$_NORMAL)
	exit_immediately(status);

    /*
     * Declare the exit handler block.
     */
    exit_handler_block.forward = 0;
    exit_handler_block.address = (unsigned long) &VMSexit;
    exit_handler_block.zero = 0;
    exit_handler_block.condition = (unsigned long) &condition;
    status = sys$dclexh(&exit_handler_block);
    if (status != SS$_NORMAL)
	exit_immediately(status);

    /*
     * Set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      &cleanup_sig, SIGINT, 0, 0, 0, 0);
    if (status != SS$_NORMAL) {
	lib$enable_ctrl(&old_msk);
	exit_immediately(status);
    }

    /*
     * Get the version of VMS.
     */
    if (VMSVersion(VersionVMS, 20) < 3)
	/*
	 * Load zeros on error.
	 */
	strcpy(VersionVMS, "V0.0-0");

    return (0);
}				/*  ttopen  */

/*
 *	TTCLOSE --
 *		This function gets called just before we go back home
 *		to the command interpreter.  It puts the terminal back
 *		in a reasonable state.
 */
int ttclose(void)
{
    int status;
    int iosb[1];

    status = sys$qiow(EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
		      &oldmode, sizeof(oldmode), 0, 0, 0, 0);

    if (status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL)
	exit_immediately(status);

    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }
    return (0);
}				/*  ttclose  */

/*
 *	TTGETC --
 *		Read a character from the terminal, with NOECHO and NOFILTR.
 */
int ttgetc(void)
{
    int status;
    unsigned short iosb[4];

    if (in_pos < in_len)
	return (buffer[in_pos++]);

    status = sys$qiow(EFN, iochan,
		      IO$_READVBLK | IO$M_NOECHO | IO$M_NOFILTR,
		      &iosb, 0, 0,
		      &buffer, 1, 0, 0, 0, 0);
    if ((status & 1) == 1)
	status = iosb[0];
    if (status == SS$_PARTESCAPE) {
	/*
	 * Escape sequence in progress.  Fake a successful read.
	 */
	status = 1;
    }
    if ((status & 1) != 1 && status != SS$_DATAOVERUN)
	exit_immediately(status);
    in_pos = 1;
    in_len = iosb[1] + iosb[3];
    return (buffer[0]);
}

/*
 *	TYPEAHEAD -- Fote Macrides 27-Jan-1994
 *		Check whether a keystroke has been entered, and return
 *		 it, or -1 if none was entered.
 */
int typeahead(void)
{
    int status;
    unsigned short iosb[4];

    if (dump_output_immediately)
	return -1;

    if (in_pos < in_len)
	return (buffer[in_pos++]);

  again:
    status = sys$qiow(EFN, iochan,
		      IO$_READVBLK | IO$M_TIMED | IO$M_NOECHO | IO$M_NOFILTR,
		      &iosb, 0, 0,
		      &buffer, 1, 0, 0, 0, 0);
    if ((status & 1) == 1)
	status = iosb[0];
    if (status == SS$_PARTESCAPE) {
	/*
	 * Escape sequence in progress, finish reading it.
	 */
	goto again;
    }

    in_pos = 1;
    in_len = iosb[1] + iosb[3];
    if (status == SS$_TIMEOUT || status == SS$_DATAOVERUN)
	return (-1);
    return (buffer[0]);
}

/*
 *	VMSSIGNAL -- Fote Macrides 29-Jun-1993
 *		Sets up AST for both Ctrl-C and Ctrl-Y, with system response
 *		 to Ctrl-T disabled.  If called with a sig other than SIGINT,
 *		 it will use the C library's system(sig, func).
 *		The equivalent of VMSsignal(SIGINT, cleanup_sig) is done on
 *		 intialization by ttopen(), so don't do it again.
 *		VMSsignal(SIGINT, SIG_DFL) is treated as a call to ttclose().
 *		Call VMSsignal(SIGINT, SIG_IGN) before system() calls to
 *		 enable Ctrl-C and Ctrl-Y in the subprocess, and then call
 *		 VMSsignal(SIG_INT, cleanup_sig) on return from the subprocess.
 *		For func's which set flags and do not invoke an exit from
 *		 LYNX, the func should reassert itself.
 *		The VMS signal() calls do not fully emulate the Unix calls,
 *		 and VMSsignal() is just a "helper", also not a full emulation.
 */

void VMSsignal(int sig,
	       void (*func) ())
{
    int status;
    short iosb[4];
    static int SIG_IGN_flag;

    /*
     * Pass all signals other than SIGINT to signal().
     * Also pass SIGINT to signal() if we're dumping.
     */
    if (sig != SIGINT || dump_output_immediately) {
	signal(sig, func);
	return;
    }

    /*
     * If func is SIG_DFL, treat it as ttclose().
     */
    if (func == SIG_DFL) {
	ttclose();
	return;
    }

    /*
     * Clear any previous AST.
     */
    if (trap_flag) {
	status = sys$dassgn(iochan);
	status = lib$enable_ctrl(&old_msk);
	trap_flag = FALSE;
    }

    /*
     * If func is SIG_IGN, leave the TT channel closed and the system response
     * to interrupts enabled for system() calls.
     */
    if (func == SIG_IGN)
	return;

    /*
     * If we get to here, we have a LYNX func, so set the AST.
     */
    lib$disable_ctrl(&mask, &old_msk);
    trap_flag = TRUE;
    status = sys$assign(&term_nam_dsc, &iochan, 0, 0);
    status = sys$qiow(EFN, iochan,
		      IO$_SETMODE | IO$M_CTRLCAST | IO$M_CTRLYAST,
		      &iosb, 0, 0,
		      func, SIGINT, 0, 0, 0, 0);

}				/* VMSsignal */

/*
 * DCLspawn_exception, spawn_DCLprocess, DCLsystem -- F.Macrides 16-Jan-1994
 *	Exception-handler routines for regulating interrupts and enabling
 *	Control-T during spawns.  Includes TRUSTED flag for versions of VMS
 *	which require it in captive accounts.  This code should be used
 *	instead of the VAXC or DECC system(), by including LYUtils.h in
 *	modules which have system() calls.  It helps ensure that we return
 *	to Lynx instead of breaking out to DCL if a user issues interrupts
 *	or generates an ACCVIO during spawns.
 */
#ifdef __DECC
static unsigned int DCLspawn_exception(void *sigarr,
				       void *mecharr)
#else
static int DCLspawn_exception(void *sigarr,
			      void *mecharr)
#endif				/* __DECC */
{
    int status;

    status = lib$sig_to_ret(sigarr, mecharr);
    return (SS$_UNWIND);
}

static int spawn_DCLprocess(char *command)
{
    int status;
    unsigned long Status = 0;

    /*
     * Keep DECC from complaining.
     */
    struct dsc$descriptor_s command_desc;

    command_desc.dsc$w_length = strlen(command);
    command_desc.dsc$b_class = DSC$K_CLASS_S;
    command_desc.dsc$b_dtype = DSC$K_DTYPE_T;
    command_desc.dsc$a_pointer = command;

    VAXC$ESTABLISH(DCLspawn_exception);

#ifdef __ALPHA /** OpenVMS/AXP lacked the TRUSTED flag before v6.1 **/
    if (VersionVMS[1] > '6' ||
	(VersionVMS[1] == '6' && VersionVMS[2] == '.' &&
	 VersionVMS[3] >= '1'))
#else
    if (VersionVMS[1] >= '6')
#endif /* __ALPHA */
    {
	/*
	 * Include TRUSTED flag.
	 */
	unsigned long trusted = CLI$M_TRUSTED;

	status = lib$spawn(&command_desc, 0, 0, &trusted,
			   0, 0, &Status);
	/*
	 * If it was invalid, try again without the flag.
	 */
	if (status == LIB$_INVARG)
	    status = lib$spawn(&command_desc, 0, 0, 0,
			       0, 0, &Status);
    } else
	status = lib$spawn(&command_desc, 0, 0, 0,
			   0, 0, &Status);
    /*
     * Return -1 on error.
     */
    if ((status & 1) != 1 || (Status & 1) != 1)
	return (-1);
    /*
     * Return 0 on success.
     */
    return (0);
}

int DCLsystem(char *command)
{
    int status;

    VMSsignal(SIGINT, SIG_IGN);
    status = spawn_DCLprocess(command);
    VMSsignal(SIGINT, cleanup_sig);
    /*
     * Returns 0 on success, -1 any error.
     */
    return (status);
}
#endif /* VMS */

/*
 * Return the physical screen dimensions that we're allowed to use.
 */
int LYscreenHeight(void)
{
    int result = LINES;

    if (result <= 0)
	result = DFT_ROWS;
    return result;
}

int LYscreenWidth(void)
{
    int result = COLS;

#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX)		/* 1999/08/26 (Thu) 17:53:38 */
    {
	extern int current_codepage;	/* PDCurses lib. */

	if (current_codepage == 932)
	    result--;
    }
#endif
    if (result <= 0)
	result = DFT_COLS;
    return result;
}

/*
 * Set the window's background color (make the pad's color agree), e.g., when
 * we have just parsed it from the config file, or after clearing the screen.
 */
void LYnormalColor(void)
{
#if defined(USE_COLOR_STYLE) && defined(USE_CURSES_PADS)
    if (LYwin != stdscr) {
	int color = displayStyles[DSTYLE_NORMAL].color;

	if (color >= 0) {
	    wbkgd(LYwin, (chtype) (color | ' '));
	    LYrefresh();
	}
    }
#endif
}

/*
 * The functions ifdef'd with USE_CURSES_PADS are implemented that way so we
 * don't break the slang configuration.
 */
void LYclear(void)
{
#ifdef USE_CURSES_PADS
    wclear(LYwin);
#else
    clear();
#endif
    LYnormalColor();
}

void LYclrtoeol(void)
{
#ifdef USE_CURSES_PADS
    wclrtoeol(LYwin);
#else
    clrtoeol();
#endif
}

void LYerase(void)
{
#ifdef USE_CURSES_PADS
    werase(LYwin);
#else
    erase();
#endif
    LYnormalColor();
}

void LYmove(int y, int x)
{
#ifdef USE_CURSES_PADS
    wmove(LYwin, y, x);
#else
    move(y, x);
#endif
}

void LYrefresh(void)
{
#ifdef USE_CURSES_PADS
    if (LYwin != stdscr) {
	/*
	 * Workaround for special case where lynx is prompting for a mailto,
	 * and has a subject line that is wider than the screen.  The
	 * wnoutrefresh() call resets newscr's position to match stdscr's,
	 * which happens to be the window's origin because we were not updating
	 * that, and other stray wmove's in lynx fail because the coordinate
	 * is on/after the right margin.  Force things to look ok here.
	 */
	int y, x;

	getyx(LYwin, y, x);
	if (y < 0)
	    y = 0;
	if (x < 0)
	    x = 0;
	if (x > LYcolLimit)
	    x = LYcolLimit;
	wmove(stdscr, y, x);

	wnoutrefresh(stdscr);
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth() - 1);

	/*
	 * Keep a popup window visible.  This can happen if the user presses
	 * '/' to do a search within a popup.
	 */
	if (my_subwindow != 0) {
	    touchwin(my_subwindow);
	    wnoutrefresh(my_subwindow);
	}
	doupdate();
    } else {
	refresh();
    }
#else
    refresh();
#endif
}

void lynx_force_repaint(void)
{
    clearok(curscr, TRUE);
}

void lynx_start_title_color(void)
{
#ifdef SH_EX
    lynx_start_reverse();
#endif
}

void lynx_stop_title_color(void)
{
#ifdef SH_EX
    lynx_stop_reverse();
#endif
}

void lynx_start_link_color(int flag,
			   int pending)
{
    if (flag) {
	/* makes some terminals work wrong because
	 * they can't handle two attributes at the
	 * same time
	 */
	/* lynx_start_bold();  */
	lynx_start_reverse();
#if defined(USE_SLANG)
#ifndef __DJGPP__
	if (SLtt_Use_Ansi_Colors)
#endif /* !__DJGPP__ */
	    lynx_start_underline();
#endif /* USE_SLANG */
#if defined(FANCY_CURSES) && defined(COLOR_CURSES)
	if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	    lynx_start_underline();
#endif /* USE_SLANG */
    } else {
	lynx_start_bold();
	/*
	 * Make sure when flag is OFF that "unhighlighted" links will be
	 * underlined if appropriate.  - LE & FM
	 */
	if (pending)
	    lynx_start_underline();
    }
}

void lynx_stop_link_color(int flag,
			  int pending GCC_UNUSED)
{
#ifdef USE_COLOR_STYLE
    LynxChangeStyle(flag == TRUE ? s_alink : s_a, ABS_OFF);
#else
    if (flag) {
	lynx_stop_reverse();
#if defined(USE_SLANG)
#ifndef __DJGPP__
	if (SLtt_Use_Ansi_Colors)
#endif /* !__DJGPP__ */
	    lynx_stop_underline();
#endif /* USE_SLANG */
#if defined(FANCY_CURSES) && defined(COLOR_CURSES)
	if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	    lynx_stop_underline();
#endif /* FANCY_CURSES && COLOR_CURSES */
    } else {
	lynx_stop_bold();
	/*
	 * If underlining was turned on above, turn it off.  - LE & FM
	 */
	if (pending)
	    lynx_stop_underline();
    }
#endif
}

/* FIXME: consider inlining these */

void lynx_stop_target_color(void)
{
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
}

void lynx_start_target_color(void)
{
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
}

void lynx_start_status_color(void)
{
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	lynx_set_color(2);
    else
#endif
	lynx_start_reverse();
}

void lynx_stop_status_color(void)
{
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
    if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
	lynx_set_color(0);
    else
#endif
	lynx_stop_reverse();
}

void lynx_start_h1_color(void)
{
    if (bold_H1 || bold_headers)
	lynx_start_bold();
}

void lynx_stop_h1_color(void)
{
    if (bold_H1 || bold_headers)
	lynx_stop_bold();
}

void lynx_start_prompt_color(void)
{
    lynx_start_reverse();
}

void lynx_stop_prompt_color(void)
{
    lynx_stop_reverse();
}

void lynx_start_radio_color(void)
{
    lynx_start_bold();
}

void lynx_stop_radio_color(void)
{
    lynx_stop_bold();
}

void lynx_stop_all_colors(void)
{
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
}

/*
 * Wrappers for LYUnderlineLinks flag.
 */
void lynx_start_bold(void)
{
    start_bold();
}

void lynx_start_reverse(void)
{
    start_reverse();
}

void lynx_start_underline(void)
{
    start_underline();
}

void lynx_stop_bold(void)
{
    stop_bold();
}

void lynx_stop_reverse(void)
{
    stop_reverse();
}

void lynx_stop_underline(void)
{
    stop_underline();
}

void LYSetDisplayLines(void)
{
    if (!no_title) {
	if (user_mode == NOVICE_MODE)
	    display_lines = LYlines - 4;
	else
	    display_lines = LYlines - 2;
    } else if (user_mode == NOVICE_MODE) {
	display_lines = LYlines - 3;
    } else {
	display_lines = LYlines - 1;
    }
}

/*
 * If LYShowCursor is ON, move the cursor to the left of the current option, so
 * that blind users, who are most likely to have LYShowCursor ON, will have
 * it's string spoken or passed to the braille interface as each option is made
 * current.  Otherwise, move it to the bottom, right column of the screen, to
 * "hide" the cursor as for the main document, and let sighted users rely on
 * the current option's highlighting or color without the distraction of a
 * blinking cursor in the window.  - FM
 */
void LYstowCursor(WINDOW * win, int row, int col)
{
    if (LYShowCursor) {
	wmove(win, row, col);
    } else {
	LYHideCursor();
    }
#ifdef USE_SLANG
    SLsmg_refresh();
#else
    wrefresh(win);
#endif /* USE_SLANG  */
}

#if defined(USE_BLINK) && defined(__EMX__)	/* Can't put it earler due to BOOLEAN conflict */
#  define BOOLEAN os2BOOLEAN
#  define INCL_VIO
#  include "os2.h"
static void make_blink_boldbg(void)
{
    VIOINTENSITY buf;		/* VIO windows have it anyway, */

    /* but FS session need a switch */
    buf.cb = sizeof(buf);
    buf.type = 2;		/* VIOINTENSITY request */
    buf.fs = 1;			/* Intensity == boldbg */
    VioSetState(&buf, 0);
}
#endif

#if defined(HAVE_WATTR_GET)
/*
 * getattrs() is not in X/Open curses, but it is more convenient than this.
 */
long LYgetattrs(WINDOW * win)
{
    long result;

#if ( defined(HAVE_GETATTRS) && ( !defined(NCURSES_VERSION_MAJOR) || NCURSES_VERSION_MAJOR < 5 ) )

    result = getattrs(win);
#else
    attr_t attrs = 0;
    short pair = 0;

    /*
     * FIXME: this ignores the color-pair, which for most implementations is
     * not stored in the attribute value.
     */
    (void) wattr_get(win, &attrs, &pair, NULL);
    result = (long) attrs;
#endif
    return result;
}
#endif /* HAVE_WATTR_GET */

#if defined(NCURSES_VERSION_PATCH) && NCURSES_VERSION_PATCH > 20021012
#ifndef HAVE_USE_LEGACY_CODING
/*
 * Between ncurses 5.3 and 5.4 as part of fixes for wide-character mode, the
 * locale support no longer allows characters in the range 128-159 to be
 * treated as printable characters.  Here is a workaround to fool
 * waddch_nosync() into treating "all" 8-bit characters as printable.
 */
NCURSES_CONST char *unctrl(chtype ch)
{
    static char result[3];
    unsigned data = (unsigned char) ch;

    if (data < 32) {
	result[0] = '^';
	result[1] = ch | '@@';
	result[2] = 0;
    } else if (data == 127) {
	result[0] = '^';
	result[1] = '?';
	result[2] = 0;
    } else {
	result[0] = data;
	result[1] = 0;
    }
    return result;
}
#endif /* HAVE_USE_LEGACY_CODING */
#endif
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d1 1
a1 1
/* $LynxId: LYCurses.c,v 1.141 2009/04/07 00:00:40 tom Exp $ */
d61 4
d143 1
a143 1
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
d149 1
a149 1
    SLsmg_set_color(Current_Attr & ~Masked_Attr);
d168 1
a168 1
	SLtt_set_mono(n, NULL, (monoattr[n] & ~Masked_Attr));
d249 1
a249 1
int string_to_attr(char *name)
d265 1
a265 4
    static char result[sizeof(Mono_Attrs) + 80];
    unsigned i;
    int pair = PAIR_NUMBER(code);
    int bold = (pair != 0 && (code & A_BOLD) != 0);
d267 19
a285 2
    if (bold)
	code &= (int) ~A_BOLD;
d287 7
a293 18
    *result = 0;
    for (i = 0; i < TABLESIZE(Mono_Attrs); i++) {
	if (Mono_Attrs[i].code & code) {
	    if (*result)
		strcat(result, "+");
	    strcat(result, Mono_Attrs[i].name);
	}
    }
    if (pair != 0) {
	short f, b;

	if (pair_content((short) pair, &f, &b) != ERR) {
	    const char *fg = lookup_color(bold ? f + COLORS : f);
	    const char *bg = lookup_color(b);

	    if (*result)
		strcat(result, "+");
	    sprintf(result + strlen(result), "%s/%s", fg, bg);
d295 2
d307 1
a307 1
void LYbox(WINDOW * win, BOOLEAN formfield GCC_UNUSED)
d310 4
a313 1
    SLsmg_draw_box(win->top_y, win->left_x, win->height, win->width + 4);
d412 1
a412 1
		  char *element)
d434 2
d440 2
a441 2
			      color, attr_to_string(color)));
	wattrset(win, color);
d444 2
a445 2
			      mono, attr_to_string(mono)));
	wattrset(win, mono);
d448 1
a448 1
	wattrset(win, A_NORMAL);
d450 2
d464 2
d467 5
a471 6
#if !OMIT_SCN_KEEPING
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);

#else
    bucket *ds = (style == NOSTYLE ? &nostyle_bucket :
		  (style == SPECIAL_STYLE ? &special_bucket : &hashStyles[style]));
d473 8
d485 2
d500 3
a502 1
	    SetCachedStyle(YP, XP, s_normal);
d525 1
a525 1
	last_styles[last_colorattr_ptr++] = LYgetattrs(win);
d548 1
a548 1
		SetCachedStyle(YP, XP, style);
d553 5
d654 1
a654 1
    return COLOR_PAIR(n);
d690 1
a690 1
    if (color_attr & A_BOLD)
d692 1
a692 1
    if (color_attr & (A_REVERSE | A_DIM))
d694 1
a694 1
    if (color_attr & A_UNDERLINE)
d743 2
a744 2
    int pair = PAIR_NUMBER(second);
    int mono = (int) (mask & A_ATTRIBUTES);
d809 2
a810 1
    if (n + 1 < (int) TABLESIZE(lynx_color_pairs)) {
d848 4
a851 4
	wattrset(LYwin, lynx_color_cfg_attr(a)
		 | (((a + 1) < COLOR_PAIRS)
		    ? (chtype) get_color_pair(a + 1)
		    : A_NORMAL));
d907 1
a907 1
	Masked_Attr |= SLTT_BOLD_MASK;
d909 1
a909 1
	Masked_Attr |= SLTT_REV_MASK;
d911 1
a911 1
	Masked_Attr |= SLTT_ULINE_MASK;
d921 10
a930 6
#if       !defined(VMS) && !defined(USE_SLANG)
/*
 * If newterm is not defined, assume a curses subset which
 * supports only initscr.  --gil
 */
#if defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN) && !defined(PDCURSES) && !(defined(NCURSES) && defined(HAVE_RESIZETERM))
d938 1
a938 3
/*
 * Surrogates for newterm and delscreen
 */
d940 5
d953 1
d955 6
a960 5
/*
 * Provide last recourse definitions of LYscreen and LYDELSCR for
 * stop_curses, which only tests LYscreen for zero/nonzero but
 * never uses it as a pointer or L-value.
 */
d968 227
d1265 1
a1265 1
	if ((Masked_Attr & SLTT_ULINE_MASK) == 0) {
d1395 1
d1410 1
a1410 1
#  endif			/* HAVE_KEYPAD */
d1416 1
a1416 1
#endif
d1454 1
d1504 1
a1504 1
	if (!isEmpty(lynx_lss_file) && LYCanReadFile(lynx_lss_file)) {
a1517 2
/* nonl();   *//* seems to slow things down */

d1558 1
a1558 1
	    saved_scrsize_y = LINES;
d1563 3
d1567 12
d1755 2
a1756 1
    chtype bb;
d1758 6
a1763 5
    bb = getbkgd(stdscr);
    bkgdset(0);
    clear();
    refresh();
    bkgdset(bb);
d1776 1
a1776 1
#else /* some flavor of win32?  */
d1864 1
a1864 1
	strncmp(term, "vt", 2) || !isdigit(term[2])) {
d1946 1
a1946 1
    if ((strncmp((const char *) ttytype, "sun", 3) == 0)) {
d1981 1
a1981 1
    wattrset(win, LYgetTableAttr());
d2021 3
d2025 1
a2025 1
    int length = (int) strlen(the_string);
d2028 1
d2031 1
a2033 1
#ifdef WIDEC_CURSES
d2038 1
a2039 1
    }
d2070 1
a2070 1
#elif defined(HAVE_GETBKGD)	/* not defined in ncurses 1.8.7 */
d2103 5
a2107 1
    SLsmg_fill_region(*top_y, *left_x - 1, *height, *width + 4, ' ');
d2225 2
d2274 1
a2274 2
 * limited by the maxCells parameter.  This is used for constructing aligned
 * text in the options and similar forms.
d2276 9
a2284 4
 * FIXME: make this account for wrapping, too.
 * FIXME: make this useful for "lynx -dump", which hasn't initialized curses.
 */
int LYstrExtent(const char *string, int len, int maxCells)
d2286 2
a2287 2
    int result = 0;
    int used;
a2288 6
    if (len < 0)
	used = (int) strlen(string);
    else
	used = len;

    result = used;
a2292 1
	int n;
d2307 2
a2309 1
	    result = 0;
d2317 1
a2317 1
		    result = new_x;
d2320 1
a2323 2
    if (result > maxCells)
	result = maxCells;
d2328 15
d2355 9
d2947 4
d3029 1
a3029 1
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF);
d3234 1
a3234 1
    wattr_get(win, &attrs, &pair, NULL);
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 1
d11 4
d72 1
a72 1
BOOL LYuseCursesPads = TRUE;	/* use pads for left/right shifting */
d267 1
a267 1
	code &= ~A_BOLD;
d344 19
a362 6
    if (!boxvert || !boxhori)
	box(win, boxvert, boxhori);
    else if (boxvert == '*' || boxhori == '*')
	wborder(win, boxvert, boxvert, boxhori, boxhori, '*', '*', '*', '*');
    else
	wborder(win, boxvert, boxvert, boxhori, boxhori, '/', '\\', '\\', '/');
d472 2
a473 2
	if (win == LYwin && CACHE_VALIDATE_YX(YP, XP))
	    cached_styles[YP][XP] = s_normal;
d518 2
a519 2
	    if (win == LYwin && CACHE_VALIDATE_YX(YP, XP))
		cached_styles[YP][XP] = style;
d585 8
a592 8
    /*0*/ { COLOR_CFG(DEFAULT_FG),     COLOR_CFG(DEFAULT_BG)},
    /*1*/ { COLOR_CFG(COLOR_BLUE),     COLOR_CFG(DEFAULT_BG)},
    /*2*/ { COLOR_CFG(COLOR_YELLOW+8), COLOR_CFG(COLOR_BLUE)},
    /*3*/ { COLOR_CFG(COLOR_GREEN),    COLOR_CFG(DEFAULT_BG)},
    /*4*/ { COLOR_CFG(COLOR_MAGENTA),  COLOR_CFG(DEFAULT_BG)},
    /*5*/ { COLOR_CFG(COLOR_BLUE),     COLOR_CFG(DEFAULT_BG)},
    /*6*/ { COLOR_CFG(COLOR_RED),      COLOR_CFG(DEFAULT_BG)},
    /*7*/ { COLOR_CFG(COLOR_MAGENTA),  COLOR_CFG(COLOR_CYAN)}
d672 1
a672 1
    int result = 0;
d681 1
a681 1
    return result;
d710 1
a710 1
    int mono = mask & A_ATTRIBUTES;
d840 1
a840 1
	    lynx_init_color_pair(n);
d1361 10
a1370 2
		  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED,
		  NULL);
d1418 5
a1422 2
	saved_tty = cur_term->Nttyb;
	did_save = TRUE;
d1424 4
a1427 4
	/* workaround for optimizer bug with nonl() */
	if ((tigetstr("cud1") != 0 && *tigetstr("cud1") == '\n')
	    || (tigetstr("ind") != 0 && *tigetstr("ind") == '\n'))
	    can_fix = FALSE;
d1429 1
d1454 3
d1467 15
a1481 1
#if defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC))
d1484 2
a1485 1
#else /* !PDCURSES */
a1488 3
#ifdef __MINGW32__
    clear();
#else
a1489 1
#endif
d1491 2
a1492 2
#endif /* PDCURSES */
#else
d1512 1
a1512 1
#endif /* defined(DOSPATH) && !(defined(USE_SLANG) || defined(_WIN_CC)) */
d1730 1
a1730 2
void LYpaddstr(WINDOW * the_window, int width,
	       const char *the_string)
d1732 8
a1739 7
    int y, x;
    int actual = strlen(the_string);

    getyx(the_window, y, x);
    if (width + x > LYcolLimit)
	width = LYcolLimit - x;
    if (actual > width)
d1741 10
a1750 2
    LYwaddnstr(the_window, the_string, actual);
    width -= actual;
d1775 1
a1775 1
	    wbkgd(my_subwindow, b | ' ');
d1826 2
d1905 4
a1921 2
    int y0, x0;

d1925 2
a1926 2
	&& (LYwin == w)		/* popups do not wrap */
	&&LYshiftWin == 0
a1950 2
	int y, x;

d1956 15
a1970 12
    /*
     * There's no guarantee that a library won't temporarily write on its input.
     * Be safe and copy it when we have const-data.
     */
    while ((int) len > 0) {
	char temp[MAX_LINE];
	size_t use = (len >= MAX_LINE) ? MAX_LINE - 1 : len;

	memcpy(temp, src, use);
	temp[use] = 0;
	waddstr(w, temp);
	len -= use;
d1988 1
a1988 1
	used = strlen(string);
d2033 5
a2037 2
 * A simple call that relies upon the coincidence that multicell characters
 * use at least as many bytes as cells.
d2041 1
a2041 1
    return LYstrExtent(string, len, len);
d2049 1
a2049 1
    return LYstrExtent2(string, strlen(string));
d2564 1
a2564 1
	    wbkgd(LYwin, color | ' ');
d2839 14
d2898 2
a2900 1
    long result = 0;
d2904 1
a2904 1
    attr_t result = 0;
d2911 2
a2912 1
    wattr_get(win, &result, &pair, NULL);
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d20 1
d59 1
a59 1
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? get_color_pair(9) : A_NORMAL)
d71 2
a72 2
 *  These are routines to start and stop curses and to cleanup
 *  the screen at the end.
d75 1
a75 1
PRIVATE int dumbterm PARAMS((char *terminal));
d79 1
a79 1
PRIVATE void make_blink_boldbg NOARGS;
d83 2
a84 1
PUBLIC int Current_Attr, Masked_Attr;
d88 3
a90 3
PUBLIC unsigned int Lynx_Color_Flags = 0;
PUBLIC BOOLEAN FullRefresh = FALSE;
PUBLIC int curscr = 0;
d94 1
a94 1
 *  Will be set by size_change. - KW
d96 1
a96 1
PUBLIC int PHYSICAL_SLtt_Screen_Cols = 10;
d99 1
a99 2

PUBLIC void LY_SLrefresh NOARGS
d116 1
a116 1
PUBLIC void LY_SLerase NOARGS
d118 2
a119 2
    SLsmg_gotorc (0, 0);
    SLsmg_erase_eos ();
d123 1
a123 1
PUBLIC void VTHome NOARGS
d131 1
a131 2
PUBLIC void LYaddAttr ARGS1(
	int,		a)
d137 1
a137 2
PUBLIC void LYsubAttr ARGS1(
	int,		a)
d143 1
a143 1
PRIVATE void lynx_setup_attrs NOARGS
d145 2
a146 1
    static int monoattr[] = {
d162 1
a162 1
PUBLIC void lynx_setup_colors NOARGS
d166 10
a175 10
    SLtt_set_color(1, NULL, "blue",	DEFAULT_BG); /* bold */
    SLtt_set_color(2, NULL, "yellow",	"blue");     /* reverse */
    SLtt_set_color(4, NULL, "magenta",	DEFAULT_BG); /* underline */
    /*
     *	The other objects are '|'ed together to get rest.
     */
    SLtt_set_color(3, NULL, "green",	DEFAULT_BG); /* bold-reverse */
    SLtt_set_color(5, NULL, "blue",	DEFAULT_BG); /* bold-underline */
    SLtt_set_color(6, NULL, "red",	DEFAULT_BG); /* reverse-underline */
    SLtt_set_color(7, NULL, "magenta",	"cyan");     /* reverse-underline-bold */
d177 1
a177 1
     *	Now set monochrome attributes.
d182 1
a182 2
PRIVATE void sl_suspend ARGS1(
	int,		sig)
d188 1
a188 1
    lynx_enable_mouse (0);
d192 1
a192 1
    kill(getpid(),SIGSTOP);
d205 1
a205 1
     *	Get new window size in case it changed.
d213 1
a213 1
    lynx_enable_mouse (1);
d223 1
d226 1
a226 1
    char *name;
d238 1
d240 1
a240 2
PUBLIC int string_to_attr ARGS1(
    char *,	name)
d254 1
a254 2
PRIVATE char *attr_to_string ARGS1(
    int,	code)
d274 5
a278 3
	if (pair_content(pair, &f, &b) != ERR) {
	    CONST char *fg = lookup_color(bold ? f+COLORS : f);
	    CONST char *bg = lookup_color(b);
d291 3
a293 5
**  This function boxes windows for (n)curses.
*/
PUBLIC void LYbox ARGS2(
	WINDOW *,	win,
	BOOLEAN,	formfield GCC_UNUSED)
d312 1
a312 1
    for (i = 1; i < win->_max_y-1; i++) {
d315 1
a315 1
	wmove(win, i, win->_max_x-1);
a323 8
    /*
     *	If the terminal is in UTF-8 mode, it probably cannot understand
     *	box drawing characters as (n)curses handles them.  (This may also
     *	be true for other display character sets, but isn't currently
     *	checked.)  In that case, substitute ASCII characters for BOXVERT
     *	and BOXHORI if they were defined to 0 for automatic use of box
     *	drawing characters.  They'll stay as they are otherwise. - KW & FM
     */
d332 4
a335 5
     *	If we don't have explicitly specified characters for either
     *	vertical or horizontal lines, the characters that box() would
     *	use for the corners probably also won't work well.  So we
     *	specify our own ASCII characters for the corners and call
     *	wborder() instead of box(). - kw
d363 1
a363 1
PUBLIC HTCharStyle displayStyles[DSTYLE_ELEMENTS];
d368 4
a371 5
PUBLIC void setStyle ARGS4(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono)
d378 11
a388 10
PUBLIC void setHashStyle ARGS5(
    int,	style,
    int,	color,
    int,	cattr,
    int,	mono,
    char *,	element)
{
    bucket* ds = &hashStyles[style];

    CTRACE2(TRACE_STYLE, (tfp, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n", element, style, color, mono));
d401 2
a402 4
PRIVATE void LYAttrset ARGS3(
    WINDOW *,	win,
    int,	color,
    int,	mono)
d405 4
a408 3
     && LYShowColor >= SHOW_COLOR_ON
     && color >= 0) {
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset color (%s)\n", attr_to_string(color)));
d411 2
a412 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS:LYAttrset mono (%s)\n", attr_to_string(mono)));
d420 2
a421 4
PUBLIC void curses_w_style ARGS3(
	WINDOW*,	win,
	int,		style,
	int,		dir)
d429 2
a430 1
    int YP,XP;
d432 2
a433 1
    bucket* ds= (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);
d435 2
a436 2
    bucket* ds= (style == NOSTYLE ?	     &nostyle_bucket :
	    (style== SPECIAL_STYLE ? &special_bucket :&hashStyles[style]) );
a438 1

d440 1
a440 1
	CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:Style %d not configured\n",style));
d446 3
a448 1
    CTRACE2(TRACE_STYLE, (tfp, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code));
d450 1
a450 1
    getyx (win, YP, XP);
d453 3
a455 2
	wattrset(win,A_NORMAL);
	if (win == LYwin) cached_styles[YP][XP] = s_normal;
d459 1
a459 2
    switch (dir)
    {
d464 4
a467 4
	    LYAttrset(win,last_attr,last_attr);
	}
	else
	    LYAttrset(win,A_NORMAL,-1);
d470 7
a476 7
    case STACK_ON: /* remember the current attributes */
	if (last_colorattr_ptr > 127) {
	    CTRACE2(TRACE_STYLE, (tfp,"........... %s (0x%x) %s\r\n",
			"attribute cache FULL, dropping last",
			last_styles[last_colorattr_ptr],
			"in LynxChangeStyle(curses_w_style)"));
	    last_colorattr_ptr = 127;
d486 2
a487 1
	if (!ds->name) break;
d490 12
a501 10
    case ABS_ON: /* change without remembering the previous style */
	    /* don't cache style changes for active links and edits */
	if ( style != s_alink
	     && style != s_curedit
	     && style != s_aedit
	     && style != s_aedit_sel
	     && style != s_aedit_pad
	     && style != s_aedit_arr ) {
	    CTRACE2(TRACE_STYLE, (tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP));
	    if (win == LYwin) cached_styles[YP][XP] = style;
d511 2
a512 4
PUBLIC void wcurses_css ARGS3(
    WINDOW *,	win,
    char*,	name,
    int,	dir)
d518 1
d521 7
a527 4
	    char *class = strrchr(name, '.');
	    CTRACE2(TRACE_STYLE, (tfp, "undefined, trimming at %p\n", class));
	    if (class)	*class = '\0';
	    else	try_again = 0;
d536 2
a537 3
PUBLIC void curses_css ARGS2(
    char *,	name,
    int,	dir)
d542 2
a543 3
PUBLIC void curses_style ARGS2(
	int,	style,
	int,	dir)
d549 1
a549 1
PRIVATE BOOL lynx_called_initscr = FALSE;
d551 2
a552 19
#if defined(HAVE_USE_DEFAULT_COLORS) && defined(USE_DEFAULT_COLORS)
/*
 * If we find a "default" color while reading the config-file, set default
 * colors on the screen.
 */
PUBLIC int lynx_default_colors NOARGS
{
    int code = 0;
    if (lynx_called_initscr) {
	code = -1;
	if (!default_color_reset && use_default_colors() == OK) {
	    default_fg = DEFAULT_COLOR;
	    default_bg = DEFAULT_COLOR;
	    code = 1;
	}
    }
    return code;
}
#endif /* HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS */
a553 1
#if defined(USE_COLOR_TABLE) && defined(COLOR_CURSES)
d562 4
a565 3

PRIVATE struct {
    int fg, bg;
d567 8
a574 8
    /*0*/ { DEFAULT_FG,    DEFAULT_BG},
    /*1*/ { COLOR_BLUE,    DEFAULT_BG},
    /*2*/ { COLOR_YELLOW+8,COLOR_BLUE},
    /*3*/ { COLOR_GREEN,   DEFAULT_BG},
    /*4*/ { COLOR_MAGENTA, DEFAULT_BG},
    /*5*/ { COLOR_BLUE,    DEFAULT_BG},
    /*6*/ { COLOR_RED,	   DEFAULT_BG},
    /*7*/ { COLOR_MAGENTA, COLOR_CYAN}
d576 3
d583 1
a583 1
PRIVATE struct {
d586 1
a586 1
} lynx_color_pairs[25];
d594 1
a594 1
PRIVATE int get_color_pair ARGS1(int, n)
d597 3
a599 2
    if (lynx_color_pairs[n].fg == default_fg
     && lynx_color_pairs[n].bg == default_bg)
d619 1
a619 1
PRIVATE int lynx_color_cfg_attr ARGS1(int, code)
d622 2
a623 1
    if (code >= 0 && code < 8) {
d625 1
d632 34
d668 1
a668 1
 * attribute we'll get 16 colors.
d670 1
a670 1
PRIVATE void LYsetWAttr ARGS1(WINDOW *, win)
d672 2
d675 6
a680 11
	int code = 0;
	int attr = A_NORMAL;
	int offs = 1;

	if (Current_Attr & A_BOLD)
	    code |= 1;
	if (Current_Attr & A_REVERSE)
	    code |= 2;
	if (Current_Attr & A_UNDERLINE)
	    code |= 4;
	attr = lynx_color_cfg_attr(code);
d682 37
a718 7
	if (code+offs < COLOR_PAIRS) {
	    attr |= get_color_pair(code+offs);
	}

	wattrset(win, attr & ~Masked_Attr);
    } else {
	wattrset(win, Current_Attr & ~Masked_Attr);
d720 2
d723 1
d728 1
a728 1
PRIVATE void lynx_init_color_pair ARGS1(int, n)
d730 3
d738 1
d740 3
a742 3
		init_pair((short)pair,
		    (short)map2bold(lynx_color_pairs[pair].fg),
		    (short)map2bold(lynx_color_pairs[pair].bg));
d744 1
a744 1
	if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
d746 1
d748 1
d751 1
a751 1
PRIVATE void lynx_map_color ARGS1(int, n)
d753 2
d757 5
a761 2
    lynx_color_pairs[n+1].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n+1].bg = lynx_color_cfg[n].bg;
d763 3
a765 5
    lynx_color_pairs[n+9].fg = lynx_color_cfg[n].fg;
    lynx_color_pairs[n+9].bg = lynx_color_cfg[0].bg;

    lynx_color_pairs[n+17].fg = lynx_color_cfg[n].bg;
    lynx_color_pairs[n+17].bg = lynx_color_cfg[n].bg;
d774 3
a776 5
PUBLIC int lynx_chg_color ARGS3(
	int, color,
	int, fg,
	int, bg
	)
d778 5
a782 2
    if (fg == ERR_COLOR || bg == ERR_COLOR) return -1;
    if (color >= 0 && color < 8) {
d792 1
a792 1
PUBLIC void lynx_set_color ARGS1(int, a)
d796 3
a798 3
		| (((a+1) < COLOR_PAIRS)
			? get_color_pair(a+1)
			: A_NORMAL));
d802 1
a802 1
PUBLIC void lynx_standout ARGS1(int, flag)
d810 1
a810 1
PRIVATE void lynx_init_colors NOARGS
d816 1
a816 1
		     default_fg, default_bg));
d829 1
a829 1
PUBLIC void lynx_setup_colors NOARGS
d832 1
d834 11
a844 1
    for (n = 0; n < 8; n++)
d849 1
a849 2
PUBLIC void LYnoVideo ARGS1(
	int,		a)
d853 6
a858 3
    if (a & 1) Masked_Attr |= SLTT_BOLD_MASK;
    if (a & 2) Masked_Attr |= SLTT_REV_MASK;
    if (a & 4) Masked_Attr |= SLTT_ULINE_MASK;
d862 1
a862 3
    if (a & 1) Masked_Attr |= A_BOLD;
    if (a & 2) Masked_Attr |= A_REVERSE;
    if (a & 4) Masked_Attr |= A_UNDERLINE;
d873 1
a873 1
#if defined(HAVE_NEWTERM) && defined(HAVE_DELSCREEN) && !(defined(NCURSES) && defined(HAVE_RESIZETERM))
d875 1
d882 1
a882 1
 * Surrogates for newterm annd delscreen
d884 1
a884 1
#else  /* HAVE_NEWTERM   */
d886 1
d891 1
a891 1
#define LYDELSCR()  /* nothing */
d893 1
a893 1
#else  /* !defined(VMS) && !defined(USE_SLANG) */
d900 1
a900 1
#define LYDELSCR()  /* nothing */
d904 2
a905 2
PUBLIC int saved_scrsize_x = 0;
PUBLIC int saved_scrsize_y = 0;
d908 1
a908 1
PUBLIC void start_curses NOARGS
d919 6
d926 2
a927 2
	if (-1 == lynx_initialize_keymaps ())
	    exit (EXIT_FAILURE);
d932 1
a932 1
	SLkp_init ();
d946 1
a946 1
	 *  Check whether a saved show_color:off override is in effect. - kw
d952 1
a952 1
	 *  Check whether we're forcing color on. - FM
d957 1
a957 1
	 *  Check whether a -nocolor override is in effect. - kw
d962 1
a962 1
	 *  Make sure our flags are in register. - FM
d981 2
a982 2
	 *  If set, the blink escape sequence will turn on high
	 *  intensity background (rxvt and maybe Linux console).
d1003 2
a1004 2
	SLsmg_Display_Eight_Bit = 191; /* may print ctrl chars otherwise - kw */
    scrollok(0,0);
d1007 1
a1007 1
    SLsmg_touch_screen ();
d1020 1
a1020 1
    lynx_enable_mouse (1);
d1027 1
a1027 2
     *	If we are VMS then do initscr() everytime start_curses()
     *	is called!
d1030 9
a1038 2
    initscr();	/* start curses */
#else  /* Unix: */
d1048 1
d1056 1
a1056 2
	 *  If we're not VMS then only do initscr() one time,
	 *  and one time only!
d1064 1
a1064 1
	recent_sizechange = savesize;    /* avoid extra redraw */
d1074 1
a1074 2
	    static char lines_putenv[] = "LINES=abcde",
			cols_putenv[]  = "COLUMNS=abcde";
d1077 1
a1077 1
	    sprintf(cols_putenv  + 8, "%d", LYcols  & 0xfff);
d1085 1
a1085 1
	if (!(LYscreen = newterm(NULL,stdout,stdin))) {  /* start curses */
d1087 2
a1088 2
		gettext("Terminal initialisation failed - unknown terminal type?"));
	    exit_immediately (EXIT_FAILURE);
d1100 1
a1100 1
	recent_sizechange = FALSE; /* prevent mainloop drawing 1st doc twice */
d1102 1
a1102 1
	CTRACE((tfp, "Screen size is now %d x %d\n", LYlines, LYcols ));
d1118 1
a1118 1
	keypad(LYwin,TRUE);
d1120 1
a1120 1
#  endif /* HAVE_KEYPAD */
d1122 1
a1122 1
	if (-1 == lynx_initialize_keymaps ()) {
d1124 1
a1124 1
	    exit (EXIT_FAILURE);
d1139 1
d1164 1
d1166 23
a1188 20
	    /*
	     * Adjust the color mapping table to match the ASSUMED_COLOR
	     * setting in lynx.cfg
	     */
	    if (assume_default_colors(default_fg, default_bg) != OK) {
		default_fg = COLOR_WHITE;
		default_bg = COLOR_BLACK;
	    }
	    CTRACE((tfp, "initializing default colors %d/%d\n",
			 default_fg, default_bg));
	    if (default_fg >= 0 || default_bg >= 0) {
		unsigned n;
		for (n = 0; n < TABLESIZE(lynx_color_cfg); n++) {
		    if (default_fg >= 0 && lynx_color_cfg[n].fg < 0)
			lynx_color_cfg[n].fg = default_fg;
		    if (default_bg >= 0 && lynx_color_cfg[n].bg < 0)
			lynx_color_cfg[n].bg = default_bg;
		    CTRACE((tfp, "color_cfg[%d] = %d/%d\n", n,
			    lynx_color_cfg[n].fg,
			    lynx_color_cfg[n].bg));
a1189 2
		lynx_setup_colors();
	    }
d1192 12
a1203 1
	    lynx_default_colors();
d1206 1
d1212 4
d1220 1
a1220 1
#endif /* USE_COLOR_TABLE */
d1227 1
a1227 1
    /* nonl();	 */ /* seems to slow things down */
d1245 1
a1245 1
	keypad(LYwin,TRUE);
d1248 1
a1248 1
    lynx_enable_mouse (1);
d1260 1
a1260 1
    if (term_blink_is_boldbg)		/* Now actually make it so! */
d1274 1
a1274 1
        LYclear();
d1278 1
a1278 1
}  /* end of start_curses() */
d1280 1
a1280 2

PUBLIC void lynx_enable_mouse ARGS1(int,state)
d1290 1
d1292 1
a1292 2
    if (LYUseMouse == 0)
    {
d1299 2
d1305 2
a1306 2
    SLtt_set_mouse_mode (state, 0);
    SLtt_flush_output ();
d1310 1
a1310 2
    if (state)
    {
d1324 1
a1324 1
	    if (old < 200)		/* Default 166 */
d1353 3
a1355 3
		BUTTON1_CLICKED | BUTTON1_PRESSED | BUTTON1_RELEASED |
		BUTTON2_CLICKED | BUTTON2_PRESSED | BUTTON2_RELEASED |
		BUTTON3_CLICKED | BUTTON3_PRESSED | BUTTON3_RELEASED);
d1357 1
a1357 1
#endif      /* NOT USE_SLANG */
d1383 1
a1383 1
PUBLIC void lynx_nl2crlf ARGS1(int, normal GCC_UNUSED)
d1397 1
a1397 1
	 || (tigetstr("ind")  != 0 && *tigetstr("ind")  == '\n'))
d1421 1
a1421 1
PUBLIC void stop_curses NOARGS
d1423 1
a1423 1
    if (LYCursesON)
d1425 1
d1427 1
a1427 1
    resetty ();
d1429 1
d1435 3
d1440 1
a1440 1
#else
d1446 2
a1447 1
#endif
d1450 1
a1450 1
    if(LYCursesON == TRUE)	{
d1452 3
a1454 7
	lynx_enable_mouse (0);
#if 1 /* (!defined(WIN_EX) || defined(__CYGWIN__)) */	/* @@@@@@ */
#ifdef WIN_EX
	if (system_is_NT)
#endif
	if(LYscreen || lynx_called_initscr) {
	    endwin();	/* stop curses */
d1457 1
a1457 2
#endif
    }
a1458 1
    {
d1460 3
a1462 2
	for (i=0; i <= 3; i++) {
	    fprintf(stdout, "\r\n");
d1464 1
a1465 1
#endif
d1487 5
d1493 1
a1493 1
 *  Check terminal type, start curses & setup terminal.
d1495 1
a1495 2
PUBLIC BOOLEAN setup ARGS1(
	char *,		terminal)
a1499 3
#ifdef USE_SLANG
    extern void longname();
#endif /* USE_SLANG */
d1502 2
a1503 2
     *	If the display was not set by a command line option then
     *	see if it is available from the environment.
d1512 1
a1512 1
     *	Get terminal type, and convert to lower case.
d1518 2
a1519 2
	 *  Some yoyo used these under conditions which require
	 *  -dump, so force that mode here. - FM
d1526 1
a1526 7
	(void) signal (SIGHUP, SIG_DFL);
	(void) signal (SIGTERM, SIG_DFL);
#ifdef SIGTSTP
	if (no_suspend)
	  (void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	exit(status);
d1534 1
a1534 1
	    gettext("You must use a vt100, 200, etc. terminal with this program."));
d1539 1
a1539 1
	    return(FALSE);
d1541 1
a1541 1
	strcpy(term,"vt100");
d1550 1
a1550 1
    return(TRUE);
d1553 1
a1553 1
#else	/* Not VMS: */
d1556 1
a1556 1
 *  Check terminal type, start curses & setup terminal.
d1558 1
a1558 2
PUBLIC BOOLEAN setup ARGS1(
	char *,		terminal)
d1565 2
a1566 2
     *  If the display was not set by a command line option then
     *  see if it is available from the environment .
d1580 1
a1580 1
     *	Query the terminal type.
d1592 1
a1592 1
	    StrAllocCopy(buffer,"vt100");
d1594 1
a1594 1
	HTSprintf0(&term_putenv,"TERM=%.106s", buffer);
d1598 2
a1599 1
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"), LYGetEnv("TERM"));
d1607 6
a1612 6
     *  Account for lossage on the 'sun' terminal type (80x24) Sun text
     *  console driver. It only supports reverse video, but all SGR
     *  sequences produce that same reverse video, and the terminfo
     *  entry lists different SGRs for 'bold' and 'rev'. As a result,
     *  the current link is indistinguishable from all other links.
     *  The workaround here is to disable the 'rev' capability.
d1614 1
a1614 1
    if ((strncmp((CONST char *)ttytype, "sun", 3) == 0)) {
d1622 1
a1622 1
    return(1);
d1625 1
a1625 2
PRIVATE int dumbterm ARGS1(
	char *,		terminal)
d1630 2
a1631 2
     *	Began checking for terminal == NULL in case that TERM environment
     *	variable is not set.  Thanks to Dick Wesseling (ftu@@fi.ruu.nl).
d1636 4
a1639 4
	!strcasecomp(terminal, "dialup")  ||
	!strcasecomp(terminal, "dumb")	  ||
	!strcasecomp(terminal, "switch")  ||
	!strcasecomp(terminal, "ethernet")  )
d1641 1
a1641 1
    return(dumb);
d1647 6
a1652 3
PUBLIC void LYaddWAttr ARGS2(
	WINDOW *,	win,
	int,		a)
d1658 1
a1658 2
PUBLIC void LYaddAttr ARGS1(
	int,		a)
d1663 1
a1663 3
PUBLIC void LYsubWAttr ARGS2(
	WINDOW *,	win,
	int,		a)
d1669 1
a1669 2
PUBLIC void LYsubAttr ARGS1(
	int,		a)
d1686 2
a1687 4
PUBLIC void LYpaddstr ARGS3(
	WINDOW *,	the_window,
	int,		width,
	CONST char *,	the_string)
d1693 2
a1694 2
    if (width + x >= LYcols)
	width = LYcols - x - 1;
d1704 1
a1704 1
 * Workaround a bug in ncurses order-of-refresh by setting a pointer to
d1710 1
a1710 1
PRIVATE WINDOW *my_subwindow;
d1712 1
a1712 1
PUBLIC void LYsubwindow ARGS1(WINDOW *, param)
d1718 9
a1726 1
#if defined(HAVE_GETBKGD) /* not defined in ncurses 1.8.7 */
a1727 1
	wbkgdset(my_subwindow, getbkgd(LYwin));
d1738 1
a1738 1
PUBLIC WINDOW *LYtopwindow NOARGS
d1744 4
a1747 5
PUBLIC WINDOW *LYstartPopup ARGS4(
    int,	top_y,
    int,	left_x,
    int,	height,
    int,	width)
d1750 1
d1753 7
a1759 1
    SLsmg_fill_region(top_y, left_x - 1, height, width + 4, ' ');
d1761 17
a1777 7
    form_window->top_y  = top_y;
    form_window->left_x = left_x;
    form_window->height = height;
    form_window->width  = width;
#else
    if (!(form_window = newwin(height, width + 4, top_y, left_x - 1)) &&
	!(form_window = newwin(height, 0, top_y, 0))) {
a1780 16
#  ifdef USE_COLOR_STYLE
	{
	    long b;

	    /* Get a proper value for the attribute */
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_ON);
	    b = LYgetattrs(form_window);
	    LynxWChangeStyle(form_window, s_menu_bg, STACK_OFF);
	    wbkgd(form_window, b | ' ');
	    /* wbkgdset does not make a lot of sense with USE_COLOR_STYLE
	       since it *forces* attributes on all the cells in the window.
	       Undo the change done in LYsubwindow, since we set our styles.
	     */
	    wbkgdset(form_window, (b & ~(A_BOLD|A_BLINK)) | ' ');
	}
#  endif
d1786 1
a1786 1
PUBLIC void LYstartTargetEmphasis NOARGS
d1801 1
a1801 1
PUBLIC void LYstopTargetEmphasis NOARGS
d1819 1
a1819 2
PUBLIC void LYtouchline ARGS1(
	int,		row)
d1847 3
a1849 4
PUBLIC void LYwaddnstr ARGS3(
	WINDOW *,	w,
	CONST char *,	src,
	size_t,		len)
d1851 38
d1896 1
d1898 2
a1899 110
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n", y, x, (int) len, src));
    }
#endif
    /*
     * Wide (multibyte) characters are always written as part of a string.  So
     * we can handle the conversion in one place.
     *
     * X/Open curses documents addstr() as able to handle multibyte sequences
     * directly, but that is not (2001/11/5) yet implemented in ncurses.  Two
     * alternatives are possible:  translating the string to an array of
     * wchar_t's or to an array of cchar_t's.  The former is more direct.  Both
     * have problems with combining-characters in this version of ncurses
     * (successive calls are not merged), so I'm using them for testing -TD
     */
#if 0	/* defined(WIDEC_CURSES) && defined(HAVE_MBSTATE_T) */
#if 1	/* array of wchar_t's */
    {
	static wchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	unsigned j;
	size_t need;

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(wchar_t, used);
	}
	for (j = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t)(-1) || rc == (size_t)(-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    temp[l++] = wch;
	}
	temp[l] = L'\0';
	waddnwstr(w, temp, l);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
    }
#else	/* array of cchar_t's */
    {
	static cchar_t *temp = 0;
	static size_t used = 0;

	wchar_t wch;
	wchar_t wstr[CCHARW_MAX + 1];
	int l = 0;
	mbstate_t state;
	size_t rc;
	int width;
	int y, x;
	unsigned j, k;
	size_t need;
	attr_t attr;
	short pair;

	wattr_get(w, &attr, &pair, (void *)0);

	memset(&state, 0, sizeof(state));
	need = 1 + len;
	if (need > used) {
	    used = 2 * need;
	    CTRACE((tfp, "allocated %d (%d)\n", used, len));
	    FREE(temp);
	    temp = typecallocn(cchar_t, used);
	}
	for (j = k = 0; j < len; j++) {
	    rc = mbrtowc(&wch, src + j, len - j, &state);
	    if (rc == 0 || rc == (size_t)(-1) || rc == (size_t)(-2))
		break;
	    j += rc - 1;
	    if ((width = wcwidth(wch)) < 0)
		break;
	    if ((width > 0 && l > 0) || l == CCHARW_MAX) {
		wstr[l] = L'\0';
		l = 0;
		if (setcchar(temp + k, wstr, attr, 0, NULL) != OK)
		    break;
		++k;
	    }
	    if (width == 0 && l == 0)
		wstr[l++] = L' ';
	    wstr[l++] = wch;
	}
	if (l > 0) {
	    wstr[l] = L'\0';
	    if (setcchar(temp + k, wstr, attr, 0, NULL) == OK)
		++k;
	}
	setcchar(temp + k, L"", 0, 0, NULL);
	wadd_wchnstr (w, temp, k);
	getyx(w, y, x);		/* we didn't move - do it now */
	wmove(w, y, x + k);
#ifdef LY_FIND_LEAKS
	FREE(temp);
	used = 0;
#endif
a1901 1
#else
d1906 1
a1906 1
    while (len > 0) {
d1909 1
d1915 54
d1970 20
d2053 1
a2053 1
#define EFN	0			/* Event flag			*/
d2055 44
a2098 45
static	unsigned char buffer[20];	/* Input buffer			*/
static	int	in_pos, in_len;		/* For escape sequences		*/
static	int	oldmode[3];		/* Old TTY mode bits		*/
static	int	newmode[3];		/* New TTY mode bits		*/
static	short	iochan;			/* TTY I/O channel		*/
static	$DESCRIPTOR(term_nam_dsc,"TT"); /* Descriptor for iochan	*/
static	unsigned long mask = LIB$M_CLI_CTRLY|LIB$M_CLI_CTRLT; /* ^Y and ^T */
static	unsigned long old_msk;		/* Saved control mask		*/
static	short	trap_flag = FALSE;	/* TRUE if AST is set		*/
BOOLEAN DidCleanup = FALSE;		/* Exit handler flag		*/
static char VersionVMS[20];		/* Version of VMS		*/

PUBLIC int VMSVersion ARGS2(
	char *,		VerString,
	int,		VerLen)
{
     unsigned long status, itm_cod = SYI$_VERSION;
     int i, verlen = 0;
     struct dsc$descriptor version;
     char *m;

     version.dsc$a_pointer = VerString;
     version.dsc$w_length = VerLen - 1;
     version.dsc$b_dtype = DSC$K_DTYPE_B;
     version.dsc$b_class = DSC$K_CLASS_S;

     status = lib$getsyi(&itm_cod, 0, &version, &verlen, 0, 0);
     if (!(status&1) || verlen == 0)
	  return 0;

     /*
      *  Cut out trailing spaces
      */
     for (m = VerString+verlen, i = verlen-1; i > 0 && VerString[i] == ' '; --i)
	  *(--m) = '\0';

     return strlen(VerString)+1;	/* Transmit ending 0 too */
}

PUBLIC void VMSexit NOARGS
{
    /*
     *	If we get here and DidCleanup is not set, it was via an
     *	ACCVIO, or outofmemory forced exit, so make *sure* we
     *	attempt a cleanup and reset the terminal.
d2103 2
a2104 1
gettext("\nA Fatal error has occurred in %s Ver. %s\n"), LYNX_NAME, LYNX_VERSION);
d2106 1
a2106 1
gettext("\nPlease notify your system administrator to confirm a bug, and if\n\
d2113 1
a2113 1
		fprintf(stderr,RETURN_TO_CLEANUP);
d2136 1
a2136 1
PUBLIC int ttopen NOARGS
d2138 35
a2172 35
	int	iosb[2];
	int	status;
	static unsigned long condition;
	static struct _exit_block {
	    unsigned long forward;
	    unsigned long address;
	    unsigned long zero;
	    unsigned long condition;
	} exit_handler_block;

	status = sys$assign( &term_nam_dsc, &iochan, 0, 0 );
	if( status != SS$_NORMAL )
		exit( status );

	status = sys$qiow( EFN, iochan, IO$_SENSEMODE, &iosb, 0, 0,
			  &oldmode, sizeof(oldmode), 0, 0, 0, 0 );
	if( status != SS$_NORMAL )
		exit( status );

	status = iosb[0] & 0xFFFF;
	if( status != SS$_NORMAL )
		exit( status );

	newmode[0] = oldmode[0];
	newmode[1] = oldmode[1];
	newmode[2] = oldmode[2] | TT2$M_EDIT;

	status = sys$qiow( EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
			  &newmode, sizeof(newmode), 0, 0, 0, 0 );
	if( status != SS$_NORMAL )
		exit( status );

	status = iosb[0] & 0xFFFF;
	if( status != SS$_NORMAL )
		exit( status );
d2174 10
a2183 10
	/*
	 *  Declare the exit handler block.
	 */
	exit_handler_block.forward   = 0;
	exit_handler_block.address   = (unsigned long) &VMSexit;
	exit_handler_block.zero      = 0;
	exit_handler_block.condition = (unsigned long) &condition;
	status = sys$dclexh(&exit_handler_block);
	if (status != SS$_NORMAL)
		exit( status );
d2185 13
a2197 13
	/*
	 *  Set the AST.
	 */
	lib$disable_ctrl(&mask, &old_msk);
	trap_flag = TRUE;
	status = sys$qiow ( EFN, iochan,
			    IO$_SETMODE|IO$M_CTRLCAST|IO$M_CTRLYAST,
			    &iosb, 0, 0,
			    &cleanup_sig, SIGINT, 0, 0, 0, 0 );
	if ( status != SS$_NORMAL ) {
		lib$enable_ctrl(&old_msk);
		exit ( status );
	}
d2199 4
d2204 1
a2204 1
	 *  Get the version of VMS.
d2206 1
a2206 5
	if (VMSVersion(VersionVMS, 20) < 3)
		/*
		 *  Load zeros on error.
		 */
		strcpy(VersionVMS, "V0.0-0");
d2208 2
a2209 2
	return(0);
}	/*  ttopen  */
d2217 1
a2217 1
PUBLIC int ttclose NOARGS
d2219 2
a2220 2
	int	status;
	int	iosb[1];
d2222 2
a2223 2
	status = sys$qiow( EFN, iochan, IO$_SETMODE, &iosb, 0, 0,
			  &oldmode, sizeof(oldmode), 0, 0, 0, 0 );
d2225 2
a2226 2
	if( status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL )
		exit( status );
d2228 7
a2234 7
	if (trap_flag) {
	    status = sys$dassgn (iochan);
	    status = lib$enable_ctrl(&old_msk);
	    trap_flag = FALSE;
	}
	return(0);
}	/*  ttclose  */
d2240 1
a2240 1
PUBLIC int ttgetc NOARGS
d2246 1
a2246 1
	return(buffer[in_pos++]);
d2249 1
a2249 1
		      IO$_READVBLK|IO$M_NOECHO|IO$M_NOFILTR,
d2252 1
a2252 1
    if ((status&1) == 1)
d2256 1
a2256 1
	 *  Escape sequence in progress.  Fake a successful read.
d2260 2
a2261 2
    if ((status&1) != 1 && status != SS$_DATAOVERUN)
	exit(status);
d2264 1
a2264 1
    return(buffer[0]);
d2272 1
a2272 1
PUBLIC int typeahead NOARGS
d2281 1
a2281 1
	return(buffer[in_pos++]);
d2283 6
a2288 6
again:
    status = sys$qiow (EFN, iochan,
		       IO$_READVBLK|IO$M_TIMED|IO$M_NOECHO|IO$M_NOFILTR,
		       &iosb, 0, 0,
		       &buffer, 1, 0, 0, 0, 0);
    if ((status&1) == 1)
d2292 1
a2292 1
	 *  Escape sequence in progress, finish reading it.
d2300 1
a2300 1
	return(-1);
d2321 6
a2326 7
PUBLIC void VMSsignal (sig,func)
int sig;
void (*func)();
{
	int status;
	short iosb[4];
	static int SIG_IGN_flag;
d2328 8
a2335 8
	/*
	 *  Pass all signals other than SIGINT to signal().
	 *  Also pass SIGINT to signal() if we're dumping.
	 */
	if (sig != SIGINT || dump_output_immediately) {
	    signal(sig, func);
	    return;
	}
d2337 7
a2343 7
	/*
	 *  If func is SIG_DFL, treat it as ttclose().
	 */
	if (func == SIG_DFL) {
	    ttclose();
	    return;
	}
d2345 8
a2352 8
	/*
	 *  Clear any previous AST.
	 */
	if (trap_flag) {
	    status = sys$dassgn (iochan);
	    status = lib$enable_ctrl(&old_msk);
	    trap_flag = FALSE;
	}
d2354 6
a2359 6
	/*
	 *  If func is SIG_IGN, leave the TT channel closed and the
	 *  system response to interrupts enabled for system() calls.
	 */
	if (func == SIG_IGN)
	    return;
d2361 10
a2370 10
	/*
	 *  If we get to here, we have a LYNX func, so set the AST.
	 */
	lib$disable_ctrl(&mask, &old_msk);
	trap_flag = TRUE;
	status = sys$assign (&term_nam_dsc, &iochan, 0, 0 );
	status = sys$qiow ( EFN, iochan,
			    IO$_SETMODE|IO$M_CTRLCAST|IO$M_CTRLYAST,
			    &iosb, 0, 0,
			    func, SIGINT, 0, 0, 0, 0 );
d2372 1
a2372 1
}	/* VMSsignal */
d2375 1
a2375 1
 *  DCLspawn_exception, spawn_DCLprocess, DCLsystem -- F.Macrides 16-Jan-1994
d2385 8
a2392 28
PRIVATE unsigned int DCLspawn_exception ARGS2(
	void *,		sigarr,
	void *,		mecharr)
#else
PRIVATE int DCLspawn_exception ARGS2(
	void *,		sigarr,
	void *,		mecharr)
#endif /* __DECC */
{
     int status;

     status = lib$sig_to_ret(sigarr, mecharr);
     return(SS$_UNWIND);
}

PRIVATE int spawn_DCLprocess ARGS1(
	char *,		command)
{
     int status;
     unsigned long Status = 0;
     /*
      *  Keep DECC from complaining.
      */
     struct dsc$descriptor_s  command_desc;
     command_desc.dsc$w_length	= strlen(command);
     command_desc.dsc$b_class	= DSC$K_CLASS_S;
     command_desc.dsc$b_dtype	= DSC$K_DTYPE_T;
     command_desc.dsc$a_pointer = command;
d2394 20
a2413 1
     VAXC$ESTABLISH(DCLspawn_exception);
d2416 3
a2418 3
     if (VersionVMS[1] > '6' ||
	 (VersionVMS[1] == '6' && VersionVMS[2] == '.' &&
	  VersionVMS[3] >= '1'))
d2420 1
a2420 1
     if (VersionVMS[1] >= '6')
d2422 39
a2460 39
     {
	 /*
	  *  Include TRUSTED flag.
	  */
	 unsigned long trusted = CLI$M_TRUSTED;
	 status = lib$spawn(&command_desc,0,0,&trusted,
			    0,0,&Status);
	 /*
	  *  If it was invalid, try again without the flag.
	  */
	 if (status == LIB$_INVARG)
	    status = lib$spawn(&command_desc,0,0,0,
			       0,0,&Status );
     } else
	 status = lib$spawn(&command_desc,0,0,0,
			    0,0,&Status);
     /*
      *  Return -1 on error.
      */
     if ((status&1) != 1 || (Status&1) != 1)
	 return(-1);
     /*
      *  Return 0 on success.
      */
     return(0);
}

PUBLIC int DCLsystem ARGS1(
	char *,		command)
{
     int status;

     VMSsignal(SIGINT, SIG_IGN);
     status = spawn_DCLprocess(command);
     VMSsignal(SIGINT, cleanup_sig);
     /*
      *  Returns 0 on success, -1 any error.
      */
     return(status);
d2467 1
a2467 1
PUBLIC int LYscreenHeight NOARGS
d2470 1
d2476 1
a2476 1
PUBLIC int LYscreenWidth NOARGS
d2479 2
a2480 1
#if defined(PDCURSES_EXP) && defined(WIN_EX) && defined(CJK_EX) /* 1999/08/26 (Thu) 17:53:38 */
d2494 18
d2515 1
a2515 1
PUBLIC void LYclear NOARGS
d2522 1
d2525 1
a2525 1
PUBLIC void LYclrtoeol NOARGS
d2534 1
a2534 1
PUBLIC void LYerase NOARGS
d2541 1
d2544 1
a2544 1
PUBLIC void LYmove ARGS2(int, y, int, x)
d2553 1
a2553 1
PUBLIC void LYrefresh NOARGS
d2566 1
d2568 2
a2569 1
	if (x >= LYcols) x = LYcols-1;
d2573 1
a2573 1
	pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, LYscreenWidth()-1);
d2592 1
a2592 1
PUBLIC void lynx_force_repaint NOARGS
d2597 1
a2597 1
PUBLIC void lynx_start_title_color NOARGS
d2604 1
a2604 1
PUBLIC void lynx_stop_title_color NOARGS
d2611 2
a2612 3
PUBLIC void lynx_start_link_color ARGS2(
	int,	flag,
	int,	pending)
d2625 1
a2625 1
	    lynx_start_underline ();
d2629 1
a2629 1
	    lynx_start_underline ();
d2631 1
a2631 1
     } else {
d2634 2
a2635 2
	 *  Make sure when flag is OFF that "unhighlighted" links
	 *  will be underlined if appropriate. - LE & FM
d2639 1
a2639 1
     }
d2642 2
a2643 3
PUBLIC void lynx_stop_link_color ARGS2(
	int,	flag,
	int,	pending GCC_UNUSED)
d2654 1
a2654 1
	lynx_stop_underline ();
d2658 1
a2658 1
	    lynx_stop_underline ();
d2663 1
a2663 1
	 *  If underlining was turned on above, turn it off. - LE & FM
d2673 1
a2673 1
PUBLIC void lynx_stop_target_color NOARGS
d2680 1
a2680 1
PUBLIC void lynx_start_target_color NOARGS
d2687 1
a2687 2

PUBLIC void lynx_start_status_color NOARGS
d2691 1
a2691 1
	lynx_set_color (2);
d2694 1
a2694 1
	lynx_start_reverse ();
d2697 1
a2697 1
PUBLIC void lynx_stop_status_color NOARGS
d2701 1
a2701 1
	lynx_set_color (0);
d2704 1
a2704 1
	lynx_stop_reverse ();
d2707 1
a2707 1
PUBLIC void lynx_start_h1_color NOARGS
d2713 1
a2713 1
PUBLIC void lynx_stop_h1_color NOARGS
d2719 1
a2719 1
PUBLIC void lynx_start_prompt_color NOARGS
d2721 1
a2721 1
    lynx_start_reverse ();
d2724 1
a2724 1
PUBLIC void lynx_stop_prompt_color NOARGS
d2726 1
a2726 1
    lynx_stop_reverse ();
d2729 1
a2729 1
PUBLIC void lynx_start_radio_color NOARGS
d2731 1
a2731 1
    lynx_start_bold ();
d2734 1
a2734 1
PUBLIC void lynx_stop_radio_color NOARGS
d2736 1
a2736 1
    lynx_stop_bold ();
d2739 1
a2739 1
PUBLIC void lynx_stop_all_colors NOARGS
d2741 3
a2743 3
    lynx_stop_underline ();
    lynx_stop_reverse ();
    lynx_stop_bold ();
d2749 1
a2749 1
PUBLIC void lynx_start_bold NOARGS
d2754 1
a2754 1
PUBLIC void lynx_start_reverse NOARGS
d2759 1
a2759 1
PUBLIC void lynx_start_underline NOARGS
d2764 1
a2764 1
PUBLIC void lynx_stop_bold NOARGS
d2769 1
a2769 1
PUBLIC void lynx_stop_reverse NOARGS
d2774 1
a2774 1
PUBLIC void lynx_stop_underline NOARGS
d2788 1
a2788 4
PUBLIC void LYstowCursor ARGS3(
    WINDOW *,	win,
    int,	row,
    int,	col)
d2790 1
a2790 1
    if (LYShowCursor)
d2792 1
a2792 1
    else
d2794 1
d2802 1
a2802 1
#if defined(USE_BLINK) && defined(__EMX__) /* Can't put it earler due to BOOLEAN conflict */
d2806 1
a2806 1
PRIVATE void make_blink_boldbg NOARGS
d2809 2
a2810 1
				/* but FS session need a switch */
d2814 1
a2814 1
    VioSetState(&buf,0);
d2822 1
a2822 1
PUBLIC long LYgetattrs ARGS1(WINDOW *, win)
d2824 1
a2824 1
#if (defined(NCURSES_VERSION_MAJOR) && NCURSES_VERSION_MAJOR < 5) || !defined(NCURSES_MAJOR_VERSION)
d2826 1
d2832 4
d2841 30
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d3 7
d43 4
d55 1
a55 1
#if defined(USE_COLOR_STYLE) && !USE_COLOR_TABLE
d58 1
a58 1
#define COLOR_BKGD ((COLOR_PAIRS >= 9) ? COLOR_PAIR(9) : A_NORMAL)
d65 1
a65 1
int LYtableCols = 0;			/* in 1/12 of screen width */
d81 1
a81 1
#if USE_COLOR_TABLE || defined(USE_SLANG)
a84 4
#define OMIT_SCN_KEEPING 0 /* whether to omit keeping of Style_className
    in HTML.c when lss support is on. 1 to increase performance. The value
    must correspond to the value of macro OMIT_SCN_KEEPING defined in HTML.c*/

d411 1
a411 1
PRIVATE int LYAttrset ARGS3(
a420 1
	return color;
a423 1
	return mono;
a426 1
	return A_NORMAL;
d485 1
a485 1
	    last_colorattr_ptr--;
d487 1
a487 1
	last_styles[last_colorattr_ptr++] = getattrs(win);
d557 1
a557 1
#if HAVE_USE_DEFAULT_COLORS && USE_DEFAULT_COLORS
d577 1
a577 1
#if USE_COLOR_TABLE && defined(COLOR_CURSES)
a588 1
    chtype attr;
d590 8
a597 8
    /*0*/ { DEFAULT_FG,    DEFAULT_BG,	A_NORMAL}, /* A_NORMAL */
    /*1*/ { COLOR_BLUE,    DEFAULT_BG,	A_NORMAL}, /* A_BOLD */
    /*2*/ { COLOR_YELLOW,  COLOR_BLUE,	A_BOLD},   /* A_REVERSE */
    /*3*/ { COLOR_GREEN,   DEFAULT_BG,	A_NORMAL}, /* A_REVERSE | A_BOLD */
    /*4*/ { COLOR_MAGENTA, DEFAULT_BG,	A_NORMAL}, /* A_UNDERLINE */
    /*5*/ { COLOR_BLUE,    DEFAULT_BG,	A_NORMAL}, /* A_UNDERLINE | A_BOLD */
    /*6*/ { COLOR_RED,	   DEFAULT_BG,	A_NORMAL}, /* A_UNDERLINE | A_REVERSE */
    /*7*/ { COLOR_MAGENTA, COLOR_CYAN,	A_NORMAL}  /* A_UNDERLINE | A_BOLD | A_REVERSE */
d609 41
d661 1
a661 1
		code |= 1;
d663 1
a663 1
		code |= 2;
d665 2
a666 2
		code |= 4;
	attr = lynx_color_cfg[code].attr;
d669 1
a669 1
		attr |= COLOR_PAIR(code+offs);
d678 4
a681 1
PRIVATE void lynx_map_color ARGS1(int, n)
d685 15
d711 1
a711 11
    if (lynx_called_initscr) {
	for (m = 0; m <= 16; m += 8) {
	    int pair = n + m + 1;
	    if (pair < COLOR_PAIRS)
		init_pair((short)pair,
		    (short)lynx_color_pairs[pair].fg,
		    (short)lynx_color_pairs[pair].bg);
	}
	if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
	    wbkgd(LYwin, COLOR_BKGD | ' ');
    }
d714 4
d726 2
a727 3
	lynx_color_cfg[color].fg = (fg > 7) ? (fg & 7) : fg;
	lynx_color_cfg[color].bg = (bg > 7) ? (bg & 7) : bg;
	lynx_color_cfg[color].attr = ((fg > 7) && (fg & 8)) ? A_BOLD : A_NORMAL;
d738 1
a738 1
	wattrset(LYwin, lynx_color_cfg[a].attr
d740 1
a740 1
			? COLOR_PAIR(a+1)
d756 1
a756 1
	size_t n, m;
d758 2
a759 1
	CTRACE((tfp, "lynx_init_colors\n"));
d765 1
a765 9
	    for (m = 0; m <= 16; m += 8) {
		int pair = n + m + 1;
		if (pair < COLOR_PAIRS)
		    init_pair((short)pair,
			(short)lynx_color_pairs[pair].fg,
			(short)lynx_color_pairs[pair].bg);
	    }
	    if (n == 0 && LYShowColor >= SHOW_COLOR_ON)
		wbkgd(LYwin, COLOR_BKGD | ' ');
d791 1
a791 1
#if USE_COLOR_TABLE
d799 1
d809 1
d817 2
d833 5
a911 1
#ifdef WATT32
a912 3
#else
    else sock_init();
#endif /* WATT32 */
d954 1
d958 13
d1003 1
d1010 1
d1014 2
d1021 1
d1070 13
a1082 2
#if USE_DEFAULT_COLORS
#ifdef EXP_ASSUMED_COLOR
d1091 2
d1107 1
d1109 1
d1118 1
a1118 1
#if USE_COLOR_TABLE
a1122 1
#ifdef WATT32
a1123 3
#else
    else sock_init();
#endif /* WATT32 */
d1133 1
a1133 1
#if HAVE_CBREAK
d1143 1
a1143 1
#if HAVE_KEYPAD
d1165 12
d1188 1
a1188 2
   is disabled unless -use_mouse is specified.  This is ifdef'd with
   __BORLANDC__ for the time being (WB).
a1202 1

d1325 3
a1328 1
#ifdef WATT32
d1330 8
a1338 4
    sock_exit();
#endif /* WATT32 */
#endif /* __DJGPP__ */
#if defined(DOSPATH) && !(defined(USE_SLANG) || _WIN_CC)
d1340 2
a1343 4
    /*
     *	Fixed for better dumb terminal support.
     *	05-28-94 Lynx 2-3-1 Garrett Arch Blythe
     */
d1347 4
a1350 1
#if (!defined(WIN_EX) || defined(__CYGWIN__))	/* @@@@@@ */
d1367 1
a1367 1
#endif /* defined(DOSPATH) && !(defined(USE_SLANG) || _WIN_CC) */
d1487 1
a1487 3
    if (dumbterm(getenv("TERM"))) {
	char *s;

d1491 4
a1494 3
	if (LYSafeGets(&buffer, stdin) != 0)
	    if ((s = strchr(buffer, '\n')) != NULL)
		*s = '\0';
d1496 1
a1496 1
	if (buffer == 0 || *buffer == 0)
d1503 1
a1503 1
	printf("\n%s %s\n", gettext("TERMINAL TYPE IS SET TO"), getenv("TERM"));
d1509 1
a1509 8
#if HAVE_TTYTYPE
    /*
     *	Get terminal type (strip 'dec-' from vms style types).
     */
    if (strncmp((CONST char*)ttytype, "dec-vt", 6) == 0) {
	(void) setterm(ttytype + 4);
    }

d1551 1
a1551 1
#if USE_COLOR_TABLE
d1598 2
d1603 4
a1606 2
    LYwaddnstr(the_window, the_string, width);
    width -= strlen(the_string);
d1610 33
d1672 1
a1672 1
	    b = getattrs(form_window);
d1696 2
a1697 2
    start_bold();
    start_reverse();
d1699 1
a1699 1
    start_underline();
d1710 1
a1710 1
    stop_underline();
d1712 2
a1713 2
    stop_reverse();
    stop_bold();
d1747 1
a1747 2
 * There's no guarantee that a library won't temporarily write on its input.
 * Be safe and copy it when we have const-data.
d1751 1
a1751 1
	CONST char *,	s,
d1754 4
d1762 51
a1812 1
	CTRACE2(TRACE_STYLE, (tfp, "[%2d,%2d] LYwaddnstr(%.*s)\n", y, x, (int) len, s));
d1814 57
d1872 7
d1882 1
a1882 1
	memcpy(temp, s, use);
d1887 1
a2035 1
	extern	void cleanup_sig();
a2352 1
     extern void controlc();
d2450 9
d2476 1
a2476 1
    start_reverse();
d2483 1
a2483 1
    stop_reverse();
d2496 2
a2497 2
	/* start_bold();  */
	start_reverse();
d2502 1
a2502 1
	    start_underline ();
d2506 1
a2506 1
	    start_underline ();
d2509 1
a2509 1
	start_bold();
d2515 1
a2515 1
	    start_underline();
d2527 1
a2527 1
	stop_reverse();
d2532 1
a2532 1
	stop_underline ();
d2536 1
a2536 1
	    stop_underline ();
d2539 1
a2539 1
	stop_bold();
d2544 1
a2544 1
	    stop_underline();
d2549 1
d2553 3
a2555 3
    stop_underline();
    stop_reverse();
    stop_bold();
d2560 3
a2562 3
    start_bold();
    start_reverse();
    start_underline();
d2568 1
a2568 1
#if USE_COLOR_TABLE && defined(COLOR_CURSES)
d2573 1
a2573 1
	start_reverse ();
d2578 1
a2578 1
#if USE_COLOR_TABLE && defined(COLOR_CURSES)
d2583 1
a2583 1
	stop_reverse ();
d2589 1
a2589 1
	start_bold();
d2595 1
a2595 1
	stop_bold();
d2600 1
a2600 1
    start_reverse ();
d2605 1
a2605 1
    stop_reverse ();
d2610 1
a2610 1
    start_bold ();
d2615 1
a2615 1
    stop_bold ();
d2620 36
a2655 3
    stop_underline ();
    stop_reverse ();
    stop_bold ();
a2671 1
#ifdef USE_SLANG
d2673 1
a2673 1
	SLsmg_gotorc(win->top_y + row, win->left_x + col);
d2676 1
a2678 4
    if (LYShowCursor)
	wmove(win, row, col);
    else
	LYHideCursor();
d2697 19
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a6 1
#include <LYMainLoop.h>
d17 4
d40 4
d50 8
d66 4
d71 1
a71 1
PRIVATE int Current_Attr;
a77 1

d82 1
a90 1

d127 1
a127 1
    SLsmg_set_color(Current_Attr);
d134 19
a152 1
    SLsmg_set_color(Current_Attr);
d157 1
a168 1

d172 1
a172 7
    SLtt_set_mono(1, NULL, SLTT_BOLD_MASK);
    SLtt_set_mono(2, NULL, SLTT_REV_MASK);
    SLtt_set_mono(3, NULL, SLTT_REV_MASK | SLTT_BOLD_MASK);
    SLtt_set_mono(4, NULL, SLTT_ULINE_MASK);
    SLtt_set_mono(5, NULL, SLTT_ULINE_MASK | SLTT_BOLD_MASK);
    SLtt_set_mono(6, NULL, SLTT_ULINE_MASK | SLTT_REV_MASK);
    SLtt_set_mono(7, NULL, SLTT_ULINE_MASK | SLTT_BOLD_MASK | SLTT_REV_MASK);
d193 1
a193 1
#if !defined(_WINDOWS) && !defined(__DJGPP__)
d210 1
a210 1
   return;
d212 3
d216 65
a280 1
#else  /* Not slang: */
a281 1
#ifdef VMS
d283 1
a283 3
**  This function boxes windows with graphic characters for
**  VMS curses.  Pass it the window, it's height, and it's
**  width. - FM
d285 1
a285 1
PUBLIC void VMSbox ARGS3(
d287 1
a287 2
	int,		height,
	int,		width)
d289 10
d303 2
a304 2
    for (i = 1; i < width; i++)
       waddch(win, 'q');
d306 1
a306 1
    for (i = 1; i < height-1; i++) {
d309 1
a309 1
	wmove(win, i, width-1);
d314 2
a315 2
    for (i = 1; i < width; i++)
       waddch(win, 'q');
d317 1
a317 10
}
#else
/*
**  This function boxes windows for non-VMS (n)curses.
**  Pass it the window. - FM
*/
PUBLIC void LYbox ARGS2(
	WINDOW *,	win,
	BOOLEAN,	formfield GCC_UNUSED)
{
d340 1
d351 1
a355 1
}
d357 1
d359 1
d371 26
a396 15
PUBLIC void setStyle ARGS4(int,style,int,color,int,cattr,int,mono)
{
	displayStyles[style].color=color;
	displayStyles[style].cattr=cattr;
	displayStyles[style].mono=mono;
}

PUBLIC void setHashStyle ARGS5(int,style,int,color,int,cattr,int,mono,char*,element)
{
    bucket* ds=&hashStyles[style];
    CTRACE(tfp, "CSS(SET): <%s> hash=%d, ca=%d, ma=%d\n", element, style, color, mono);
    ds->color=color;
    ds->cattr=cattr;
    ds->mono=mono;
    ds->code=style;
d398 1
a398 4
    ds->name=malloc(sizeof(char)*(strlen(element)+2));
    if(!ds->name)
	outofmem(__FILE__, "setHashStyle");
    strcpy(ds->name, element);
d404 18
a421 14
PRIVATE int LYAttrset ARGS3(WINDOW*,win,int,color,int,mono)
{
	CTRACE(tfp, "CSS:LYAttrset (%#x, %#x)\n", color, mono);
	if (lynx_has_color && LYShowColor >= SHOW_COLOR_ON && color > -1)
	{
		wattrset(win,color);
		return color;
	}
	if (mono > -1)
	{
		wattrset(win,mono);
		return mono;
	}
	wattrset(win,A_NORMAL);
d423 1
d433 2
a434 2
  /* if TRACEs are not compiled in, this macro is redundant - we neend't valid
    'ds' to stack off. */
d437 1
a437 1
	int YP,XP;
d439 1
a439 1
	bucket* ds= (style == NOSTYLE ? &nostyle_bucket : &hashStyles[style]);
d441 2
a442 2
        bucket* ds= (style == NOSTYLE ?      &nostyle_bucket :
                (style== SPECIAL_STYLE ? &special_bucket :&hashStyles[style]) );
d446 2
a447 3
	if (!ds->name)
	{
		CTRACE(tfp, "CSS.CS:Style %d not configured\n",style);
d449 1
a449 1
		return;
d451 3
a453 1
	}
d455 1
a455 1
	CTRACE(tfp, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code);
d457 5
a461 1
	getyx (win, YP, XP);
d463 19
a481 5
	if (style == s_normal && dir)
	{
		wattrset(win,A_NORMAL);
		if (win==stdscr) cached_styles[YP][XP]=s_normal;
		return;
d483 2
a484 23

	switch (dir)
	{
		/* ABS_OFF is the same as STACK_OFF for the moment */
	case STACK_OFF:
		if (last_colorattr_ptr) {
		    int last_attr = last_styles[--last_colorattr_ptr];
		    LYAttrset(win,last_attr,last_attr);
		}
		else
			LYAttrset(win,A_NORMAL,-1);
		return;

	case STACK_ON: /* remember the current attributes */
		if (last_colorattr_ptr > 127) {
		    CTRACE(tfp,"........... %s (0x%x) %s\r\n",
				"attribute cache FULL, dropping last",
				last_styles[last_colorattr_ptr],
				"in LynxChangeStyle(curses_w_style)");
		    last_colorattr_ptr--;
		}
		last_styles[last_colorattr_ptr++] = getattrs(stdscr);
		/* don't cache style changes for active links */
d486 18
a503 24
                /* since we don't compute the hcode
                  to stack off in HTML.c, we don't know whether this style is
                  configured. So, we shouldn't simply return on stacking on on
                  unconfigured styles, we should push curr attrs on stack. -HV
                */
                if (!ds->name) return;
#endif
		if (style != s_alink)
		{
			CTRACE(tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP);
			if (win==stdscr) cached_styles[YP][XP]=style;
		}
		LYAttrset(win, ds->color, ds->mono);
		return;

	case ABS_ON: /* change without remembering the previous style */
		/* don't cache style changes for active links */
		if (style != s_alink)
		{
			CTRACE(tfp, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP);
			if (win==stdscr) cached_styles[YP][XP]=style;
		}
                LYAttrset(win, ds->color, ds->mono);
		return;
d505 3
d513 19
a531 17
PUBLIC void wcurses_css ARGS3(WINDOW *,win,char*,name,int,dir)
{
	int try_again=1;
	while (try_again)
	{
		int tmpHash=hash_code(name);
		CTRACE(tfp, "CSSTRIM:trying to set [%s] style - ", name);
		if (tmpHash==NOSTYLE) {
			char *class=strrchr(name, '.');
			CTRACE(tfp, "undefined, trimming at %p\n", class);
			if (class)	*class='\0';
			else		try_again=0;
		} else {
			CTRACE(tfp, "ok (%d)\n", hash_code(name));
			curses_w_style(win, hash_code(name), dir);
			try_again=0;
		}
d533 1
d536 3
a538 1
PUBLIC void curses_css ARGS2(char *,name,int,dir)
d540 1
a540 1
    wcurses_css(stdscr, name, dir);
d547 1
a547 1
    curses_w_style(stdscr, style, dir);
d549 1
d551 8
a558 2
#ifdef NOT_USED
void attribute ARGS2(int,style,int,dir)
d560 10
a569 1
    curses_style(style, dir, 0);
d571 1
a571 2
#endif
#endif /* USE_COLOR_STYLE */
a581 1
PRIVATE int lynx_called_initscr;
a614 9
	static int NoColorVideo = -1;

#ifdef UNIX
	if (NoColorVideo < 0) {
		NoColorVideo = tigetnum("ncv");
	}
	if (NoColorVideo < 0)
		NoColorVideo = 0;
#endif /* UNIX */
a623 12
	/*
	 * no_color_video isn't implemented (97/4/14) in ncurses 4.1, but may
	 * be in SVr4 (which would make this redundant for the latter).
	 */
	if ((Current_Attr & A_BOLD) && !(NoColorVideo & 33)) {
		attr |= A_BOLD;
	}

	if ((Current_Attr == A_UNDERLINE) && !(NoColorVideo & 2)) {
		attr |= A_UNDERLINE;
	}

d628 1
a628 1
	wattrset(win, attr);
d630 1
a630 1
	wattrset(win, Current_Attr);
d638 2
d653 3
a655 3
		init_pair(pair,
		    lynx_color_pairs[pair].fg,
		    lynx_color_pairs[pair].bg);
d658 1
a658 1
	    bkgd(COLOR_BKGD | ' ');
d683 1
a683 1
	attrset(lynx_color_cfg[a].attr
d703 2
d708 1
a708 1
	for (n = 0; n < sizeof(lynx_color_cfg)/sizeof(lynx_color_cfg[0]); n++) {
d712 3
a714 3
		    init_pair(pair,
			lynx_color_pairs[pair].fg,
			lynx_color_pairs[pair].bg);
d717 1
a717 1
		bkgd(COLOR_BKGD | ' ');
d727 1
d733 2
a734 7
#ifdef NOTUSED
#if defined (DJGPP) && !defined (USE_SLANG)
/*
 * Sorry about making a completely new function,
 * but the real one is messy! WB
 */
PUBLIC void start_curses NOARGS
d736 13
a748 30
    static BOOLEAN first_time = TRUE;

    if(first_time)
    {
	initscr();		/* start curses */
	first_time = FALSE;
	cbreak();
	keypad(stdscr, TRUE);
	fflush(stdin);
	fflush(stdout);
	if (has_colors()) {
	    lynx_has_color = TRUE;
	    start_color();
	}
	lynx_init_colors();
	lynx_called_initscr = TRUE;

	/* Inform pdcurses that we're interested in knowing when mouse buttons
	 * are clicked.  Maybe someday pdcurses will support it.
	 */
	if (LYUseMouse)
	    lynx_enable_mouse (1);

    } else
	sock_init();

    LYCursesON = TRUE;
    CTRACE(tfp, "start_curses: done.\n");
    clear();
    noecho();
a749 3
#else
#endif /* defined (DJGPP) && !defined (USE_SLANG) */
#endif /* NOTUSED */
d751 29
d787 1
a787 1
	CTRACE(tfp, "start_curses: Hmm, already ON.\n");
d792 4
d797 2
a798 1
#if defined(__DJGPP__) && !defined(DJGPP_KEYHANDLER)
d802 1
a802 1
#ifdef UNIX
d806 1
a806 1
#endif /* UNIX */
d808 4
d842 5
a846 3
#if defined(VMS) || defined(UNIX)
	SLtt_add_color_attribute(4, SLTT_ULINE_MASK);
	SLtt_add_color_attribute(5, SLTT_ULINE_MASK);
d851 2
a852 6
	if (LYShowColor && (Lynx_Color_Flags & SL_LYNX_USE_BLINK)) {
	    SLtt_Blink_Mode = 1;
	} else {
	    SLtt_Blink_Mode = 0;
	}
#endif /* VMS || UNIX */
d855 3
d859 1
d877 3
d881 1
a881 1
#if !defined(_WINDOWS) && !defined(__DJGPP__)
d883 1
a883 1
#endif /* !_WINDOWS */
d891 1
a891 3
   lynx_enable_mouse (1);

#else /* Using curses: */
d893 2
d904 1
a904 3
    static BOOLEAN first_time = TRUE;

    if (first_time) {
d909 28
a936 1
	if (initscr() == NULL) {  /* start curses */
d939 1
a939 1
	    exit_immediately (-1);
d941 5
d950 11
d962 11
a972 2
	if (-1 == lynx_initialize_keymaps ())
	    exit (-1);
d998 9
a1006 4
#if HAVE_USE_DEFAULT_COLORS
	    if (use_default_colors() == OK) {
		default_fg = DEFAULT_COLOR;
		default_bg = DEFAULT_COLOR;
d1008 17
a1024 1
#endif /* HAVE_USE_DEFAULT_COLORS */
a1030 1
	first_time = FALSE;
a1032 1
	lynx_called_initscr = TRUE;
d1036 3
d1040 1
d1061 2
a1062 1
    keypad(stdscr,TRUE);
d1065 1
a1065 1
   lynx_enable_mouse (1);
d1072 7
a1078 2
#ifdef _WINDOWS
    clear();
d1082 2
a1083 2
    CTRACE(tfp, "start_curses: done.\n");
}
d1088 2
d1091 1
a1091 1
#ifdef __BORLANDC__
d1109 2
a1110 1
#ifdef USE_SLANG_MOUSE
d1115 1
a1115 2
#ifdef NCURSES_MOUSE_VERSION
#if defined(__BORLANDC__) && defined(__PDCURSES__)
d1122 1
a1122 5
    /* Inform ncurses that we're interested in knowing when mouse
     * button 1 is clicked.  We cannot just specify
     * BUTTON1_CLICKED | BUTTON3_CLICKED, since ncurses will try hard
     * to translate other events to single-clicks.
     * Compensate for small value of maxclick in ncurses.  */
d1124 1
d1134 18
a1151 1
	mousemask(ALL_MOUSE_EVENTS, NULL);
d1154 2
a1155 2
#endif /* __BORLANDC__ and __PDCURSES__ */
#endif /* NCURSES_MOUSE_VERSION */
d1157 1
a1157 1
#if defined(DJGPP) && !defined(USE_SLANG)
d1159 66
a1224 1
	mouse_set(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED);
a1225 1
#endif				       /* NOT USE_SLANG_MOUSE */
d1230 6
a1235 2
    echo();
#ifdef DJGPP
d1237 3
a1239 2
#endif
#if defined (DOSPATH) && !defined(USE_SLANG)
d1248 15
a1262 2
	 lynx_enable_mouse (0);
	 endwin();	/* stop curses */
d1264 1
d1267 1
a1267 1
#endif /* DJGPP */
d1271 1
a1271 1
    CTRACE(tfp, "stop_curses: done.\n");
d1290 1
a1290 1
	char *, 	terminal)
d1320 1
a1320 1
	LYcols = 80;
a1334 1
    sleep(InfoSecs);
d1351 2
a1352 6
    LYlines = LINES;
    LYcols = COLS;
    if (LYlines <= 0)
	LYlines = 24;
    if (LYcols <= 0)
	LYcols = 80;
d1363 1
a1363 1
	char *, 	terminal)
a1367 14
#if defined(HAVE_SIZECHANGE) && !defined(USE_SLANG) && defined(NOTDEFINED)
/*
 *  Hack to deal with a problem in sysV curses, that screen can't be
 *  resized to greater than the size used by initscr, which can only
 *  be called once.  So set environment variables LINES and COLUMNS
 *  to some suitably large size to force initscr to allocate enough
 *  space.  Later we get the real window size for setting LYlines
 *  and LYcols. - AJL & FM
 *
 *  Has problems, so we don't use this hack, but the code is here
 *  if someone wants to play with it some more. - FM
 */
    char *lines_putenv = NULL;
    char *cols_putenv = NULL;
d1369 4
a1372 12
    if (getenv("LINES") == NULL && getenv("COLUMNS") == NULL) {
	StrAllocCopy(lines_putenv, "LINES=120");
	(void) putenv(lines_putenv);
	StrAllocCopy(cols_putenv, "COLUMNS=240");
	(void) putenv(cols_putenv);
    }
#endif /* HAVE_SIZECHANGE && !USE_SLANG && NOTDEFINED */

   /*
    *  If the display was not set by a command line option then
    *  see if it is available from the environment .
    */
d1405 1
a1405 1
	sleep(MESSAGESECS);
d1417 12
d1431 2
a1432 27
#if defined(HAVE_SIZECHANGE) && !defined(USE_SLANG) && defined(NOTDEFINED)
    if (lines_putenv != NULL) {
	/*
	 *  Use SIGWINCH handler to set the true window size. - AJL && FM
	 *
	 *  Has problems, so we don't use this hack, but the code is here
	 *  if someone wants to play with it some more. - FM
	 */
	size_change(0);
	lines_putenv[6] = '\0';
	(void) putenv(lines_putenv);
	cols_putenv[8] = '\0';
	(void) putenv(cols_putenv);
	FREE(lines_putenv);
	FREE(cols_putenv);
    } else {
	LYlines = LINES;
	LYcols = COLS;
    }
#else
    LYlines = LINES;
    LYcols = COLS;
#endif /* HAVE_SIZECHANGE && !USE_SLANG && USE_NOTDEFINED */
    if (LYlines <= 0)
	LYlines = 24;
    if (LYcols <= 0)
	LYcols = 80;
d1438 1
a1438 1
	char *, 	terminal)
d1471 1
a1471 1
    LYaddWAttr(stdscr, a);
d1485 1
a1485 1
    LYsubWAttr(stdscr, a);
d1492 66
d1588 55
d1706 2
a1707 2
static	unsigned char buffer[20];	/* Input buffer 		*/
static	int	in_pos, in_len; 	/* For escape sequences 	*/
d1710 1
a1710 1
static	short	iochan; 		/* TTY I/O channel		*/
d1719 1
a1719 1
	char *, 	VerString,
d2039 2
a2040 2
	void *, 	sigarr,
	void *, 	mecharr)
d2043 2
a2044 2
	void *, 	sigarr,
	void *, 	mecharr)
d2054 1
a2054 1
	char *, 	command)
d2104 1
a2104 1
	char *, 	command)
d2119 95
a2215 12
#if defined(COLOR_CURSES)
    chtype a;
    if (LYShowColor >= SHOW_COLOR_ON)
	a = COLOR_BKGD;
    else
	a = A_NORMAL;
    bkgdset(a | ' ');
#ifndef USE_COLOR_STYLE
    bkgd(a | ' ');
#endif
    attrset(a);
#endif /* COLOR_CURSES */
d2221 3
d2228 3
d2270 1
a2270 1
    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_OFF, 0);
d2298 3
a2300 3
   stop_underline();
   stop_reverse();
   stop_bold();
d2305 3
a2307 3
   start_bold();
   start_reverse();
   start_underline();
d2333 2
a2334 2
   if (bold_H1 || bold_headers)
     start_bold();
d2339 2
a2340 2
   if (bold_H1 || bold_headers)
     stop_bold();
d2345 1
a2345 1
   start_reverse ();
d2350 1
a2350 1
   stop_reverse ();
d2355 1
a2355 1
   start_bold ();
d2360 1
a2360 1
   stop_bold ();
d2365 3
a2367 3
   stop_underline ();
   stop_reverse ();
   stop_bold ();
d2369 44
@


1.1
log
@Initial revision
@
text
@d1 13
a13 13
#include "HTUtils.h"
#include "tcp.h"
#include "LYCurses.h"
#include "LYStyle.h"
#include "LYUtils.h"
#include "LYGlobalDefs.h"
#include "LYMainLoop.h"
#include "LYSignal.h"
#include "LYClean.h"
#include "LYReadCFG.h"
#include "LYStrings.h"
#include "LYCharSets.h"
#include "UCAux.h"
d15 2
a16 10
#include "LYexit.h"
#include "LYLeaks.h"

#define FREE(x) if (x) {free(x); x = NULL;}

#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */
d29 2
a30 2
#include "AttrList.h"
#include "LYHash.h"
d37 3
d41 1
d55 5
d71 2
d163 1
a163 1
#ifndef _WINDOWS
d222 1
a222 1
	BOOLEAN,	formfield)
a264 5
PRIVATE int last_styles[128];
PRIVATE int last_ptr=0;
#endif

#if defined(USE_COLOR_STYLE)
d284 1
a284 2
    if (TRACE)
	fprintf(stderr, "CSS(SET): <%s> hash=%d, ca=%d, ma=%d\n", element, style, color, mono);
d291 2
d301 1
a301 2
	if (TRACE)
		fprintf(stderr, "CSS:LYAttrset (%d, %d)\n", color, mono);
d316 11
a326 2
PUBLIC void curses_w_style ARGS4(WINDOW*,win,int,style,int,dir,int,previous)
{
d328 7
a334 1
	bucket* ds=&hashStyles[style];
d338 2
a339 2
		if (TRACE)
		fprintf(stderr, "CSS.CS:Style %d not configured\n",style);
d341 1
d343 2
a344 2
	if (TRACE)
		fprintf(stderr, "CSS.CS:<%s%s> (%d)\n",(dir?"":"/"),ds->name,ds->code);
d359 4
a362 2
		if (last_ptr)
			LYAttrset(win,last_styles[--last_ptr],-1);
d368 2
a369 3
		if (last_ptr > 127) {
		    if (TRACE)
			fprintf(stderr,"........... %s (0x%x) %s\r\n",
d371 3
a373 3
				last_styles[last_ptr],
				"in LynxChangStyle(curses_w_style)");
		    last_ptr--;
d375 1
a375 1
		last_styles[last_ptr++] = getattrs(stdscr);
d377 8
d387 1
a387 2
			if (TRACE)
				fprintf(stderr, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP);
a388 5
			LYAttrset(win, ds->color, ds->mono);
		}
		else
		{
			LYAttrset(win, ds->color, ds->mono);
d390 1
d397 1
a397 2
			if (TRACE)
				fprintf(stderr, "CACHED: <%s> @@(%d,%d)\n", ds->name, YP, XP);
a398 5
			LYAttrset(win, ds->color, ds->mono);
		}
		else
		{
			LYAttrset(win, ds->color, ds->mono);
d400 1
d414 1
a414 2
		if (TRACE)
			fprintf(stderr, "CSSTRIM:trying to set [%s] style - ", name);
d417 1
a417 1
			if (TRACE) fprintf(stderr, "undefined, trimming at %p\n", class);
d421 2
a422 2
			if (TRACE) fprintf(stderr, "ok (%d)\n", hash_code(name));
			curses_w_style(win, hash_code(name), dir, 0);
d430 1
a430 1
	wcurses_css(stdscr, name, dir);
d433 3
a435 1
PUBLIC void curses_style ARGS3(int,style,int,dir,int,previous)
d437 1
a437 1
    curses_w_style(stdscr, style, dir, previous);
d491 1
a491 2
	static int have_underline = -1;
	static int no_color_video = -1;
d493 3
a495 6
	if (have_underline < 0) {
#ifndef DOSPATH
		have_underline = tigetstr("smul") != 0;
#else
		have_underline = 1;
#endif /* DOSPATH */
d497 3
a499 8

#if ( !defined(__DJGPP__) && !defined(_WINDOWS) )
	if (no_color_video < 0) {
		no_color_video = tigetnum("ncv");
	}
	if (no_color_video < 0)
		no_color_video = 0;
#endif /* !__DJGPP__ and !_WINDOWS */
d510 2
a511 2
	 * FIXME:  no_color_video isn't implemented (97/4/14) in ncurses 4.x,
	 * but may be in SVr4 (which would make this redundant for the latter).
d513 1
a513 1
	if ((Current_Attr & A_BOLD) && !(no_color_video & 33)) {
d517 1
a517 1
	if ((Current_Attr == A_UNDERLINE) && !(no_color_video & 2)) {
d563 1
d625 1
d633 1
a633 1
	 static BOOLEAN first_time = TRUE;
d635 14
a648 14
	 if(first_time)
	 {
		  initscr();	  /* start curses */
		  first_time = FALSE;
		  cbreak();
		  keypad(stdscr, TRUE);
		  fflush(stdin);
		  fflush(stdout);
		  if (has_colors()) {
		      lynx_has_color = TRUE;
		      start_color();
		  }
		  lynx_init_colors();
		  lynx_called_initscr = TRUE;
d650 5
a654 5
 /* Inform pdcurses that we're interested in knowing when mouse
    buttons are clicked.  Maybe someday pdcurses will support it.
 */
	 if (LYUseMouse)
	      lynx_enable_mouse (1);
d656 2
a657 1
	 } else sock_init();
d659 4
a662 3
	 LYCursesON = TRUE;
	 clear();
	 noecho();
d665 4
d674 2
a675 1
    if (LYCursesON)
d677 1
d681 4
d721 1
d733 1
d735 4
d751 1
a751 1
       SLsmg_Display_Eight_Bit = 191; /* may print ctrl chars otherwise - kw */
d755 2
a756 2
#ifndef _WINDOWS
   SLtty_set_suspend_state(1);
d769 1
d772 1
a772 1
     *	If we are VMS then do initsrc() everytime start_curses()
d776 2
a777 1
#else /* Unix: */
d786 3
a788 12
	    fprintf(stderr,
		"Terminal initialisation failed - unknown terminal type?\n");
#ifndef NOSIGHUP
	    (void) signal(SIGHUP, SIG_DFL);
#endif /* !NOSIGHUP */
	    (void) signal(SIGTERM, SIG_DFL);
	    (void) signal(SIGINT, SIG_DFL);
#ifdef SIGTSTP
	    if (no_suspend)
		(void) signal(SIGTSTP,SIG_DFL);
#endif /* SIGTSTP */
	    exit (-1);
d792 1
d794 4
d811 3
a813 3
		if (acs_map[n] & 0x80) {
		    acs_map[n] &= 0xff;
		    acs_map[n] |= A_ALTCHARSET;
d840 4
a843 1
#endif /* VMS */
d877 1
d879 1
a879 1
#endif /* defined (DJGPP) && !defined (USE_SLANG) */
d883 18
a900 2
   if (LYUseMouse == 0)
     return;
d903 2
a904 2
   SLtt_set_mouse_mode (state, 0);
   SLtt_flush_output ();
d906 1
d908 6
a913 7
     /* Inform ncurses that we're interested in knowing when mouse
      button 1 is clicked */
#ifndef _WINDOWS
   if (state)
     mousemask(BUTTON1_CLICKED | BUTTON3_CLICKED, NULL);
   else
     mousemask(0, NULL);
d915 19
a933 2
   if (state) mouse_set(BUTTON1_CLICKED && BUTTON2_CLICKED && BUTTON3_CLICKED);
#endif /* !_WINDOWS */
d937 2
a938 2
     if (state)
       mouse_set(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED);
d967 1
d971 2
a972 2
   if (!no_suspend)
       signal(SIGTSTP, SIG_DFL);
d990 1
a990 1
    char *dummy, *cp, term[81];
d999 2
a1000 2
    if ((cp = getenv(DISPLAY)) != NULL && *cp != '\0') {
	StrAllocCopy(display, cp);
d1002 1
a1002 1
	FREE(display);
d1028 1
a1028 3
    for (cp = term; *cp != '\0'; cp++)
	if (isupper(*cp))
	    *cp = TOLOWER(*cp);
d1030 1
a1030 1
    printf("Terminal = %s\n", term);
d1034 3
a1036 3
	printf(
	    "You must use a vt100, 200, etc. terminal with this program.\n");
	printf("Proceed (n/y)? ");
d1066 2
a1067 2
    static char term_putenv[120];
    char buffer[120];
d1096 2
a1097 2
    if ((cp = getenv(DISPLAY)) != NULL && *cp != '\0') {
	StrAllocCopy(display, cp);
d1099 1
a1099 1
	FREE(display);
d1103 1
a1103 1
	sprintf(term_putenv, "TERM=%s", terminal);
d1113 15
a1127 13
	printf("\n\n  Your Terminal type is unknown!\n\n");
	printf("  Enter a terminal type: [vt100] ");
	*buffer = '\0';
	fgets(buffer, sizeof(buffer), stdin);
	if ((s = strchr(buffer, '\n')) != NULL)
	    *s = '\0';

	if (strlen(buffer) == 0)
	    strcpy(buffer,"vt100");

	sprintf(term_putenv,"TERM=%s", buffer);
	putenv(term_putenv);
	printf("\nTERMINAL TYPE IS SET TO %s\n",getenv("TERM"));
d1230 6
d1245 6
a1300 1
#include <stdlib.h>
d1317 1
a1317 1
#include "LYVMSdef.h"
d1370 1
a1370 9
"\nA Fatal error has occurred in %s Ver. %s\n", LYNX_NAME, LYNX_VERSION);
	    fprintf(stderr,
"\nPlease notify your system administrator to confirm a bug, and if\n");
	    fprintf(stderr,
"confirmed, to notify the lynx-dev list.  Bug reports should have concise\n");
	    fprintf(stderr,
"descriptions of the command and/or URL which causes the problem, the\n");
	    fprintf(stderr,
"operating system name with version number, the TCPIP implementation, the\n");
d1372 5
a1376 1
"TRACEBACK if it can be captured, and any other relevant information.\n");
d1379 1
a1379 1
		fprintf(stderr,"\nPress RETURN to clean up: ");
d1383 1
a1383 2
	    _statusline(MEMORY_EXHAUSTED_ABORT);
	    sleep(AlertSecs);
d1588 1
a1588 1
PUBLIC void *VMSsignal (sig,func)
d1647 1
a1647 1
 *	instead of the VAXC or DECC system(), by including LYSystem.h in
a1655 1
{
d1660 1
a1661 1
#endif /* __DECC */
d1687 1
a1687 1
	  VersionVMS[3] >= '1')) {
d1689 1
a1689 1
     if (VersionVMS[1] >= '6') {
d1691 1
a1737 1
#ifndef USE_COLOR_STYLE
a1740 1
#endif
d1771 1
d1773 1
d1793 1
a1793 1
	int,	pending)
d1801 1
d1803 1
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
