head	1.10;
access;
symbols
	OPENBSD_5_5:1.8.0.14
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.8
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.6
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.14
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.12
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.10
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.9;
commitid	EcR8E7r0stjLUV4p;

1.9
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.8;
commitid	lGGuvDWEniklWrQe;

1.8
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.27.21.45.20;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.04.01.50;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.25.18.17.13;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	98.12.21.03.31.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.48.00;	author maja;	state Exp;
branches;
next	;


desc
@@


1.10
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYUtils.c,v 1.266 2014/03/09 14:27:06 tom Exp $
 */
#include <HTUtils.h>
#include <HTTCP.h>
#include <HTParse.h>
#include <HTAccess.h>
#include <HTCJK.h>
#include <HTAlert.h>

#if defined(__MINGW32__)

extern int kbhit(void);		/* FIXME: use conio.h */

#undef UNIX

#elif defined(_WINDOWS)

#ifdef DONT_USE_GETTEXT
#undef gettext
#elif defined(HAVE_GETTEXT)
#undef gettext
#define gettext conio_gettext
#else
#undef gettext
#endif

#include <conio.h>

#ifdef DONT_USE_GETTEXT
#define gettext(s) s
#elif defined(HAVE_GETTEXT)
#undef gettext
#ifdef _INTL_REDIRECT_MACROS
#define gettext libintl_gettext	/* restore definition from libintl.h */
#endif
#else
#undef gettext
#define gettext(s) s
#endif

#if !defined(kbhit) && defined(_WCONIO_DEFINED)
#define kbhit() _kbhit()	/* reasonably recent conio.h */
#endif

#endif /* __MINGW32__ */

#include <LYCurses.h>
#include <LYHistory.h>
#include <LYStrings.h>
#include <LYGlobalDefs.h>
#include <LYUtils.h>
#include <LYSignal.h>
#include <GridText.h>
#include <LYClean.h>
#include <LYCharSets.h>
#include <LYCharUtils.h>

#include <LYMainLoop.h>
#include <LYKeymap.h>

#ifdef __DJGPP__
#include <go32.h>
#include <sys/exceptn.h>
#endif /* __DJGPP__ */

#ifndef NO_GROUPS
#include <HTFile.h>
#endif

#ifdef _WINDOWS			/* 1998/04/30 (Thu) 19:04:25 */
#define GETPID()	(unsigned) (getpid() & 0xffff)
#else
#define GETPID()	(unsigned) getpid()
#endif /* _WINDOWS */

#ifdef FNAMES_8_3
#define PID_FMT "%04x"
#else
#define PID_FMT "%u"
#endif

#ifdef DJGPP_KEYHANDLER
#include <bios.h>
#endif /* DJGPP_KEYHANDLER */

#ifdef __EMX__
#  define BOOLEAN OS2_BOOLEAN	/* Conflicts, but is used */
#  undef HT_ERROR		/* Conflicts too */
#  define INCL_PM		/* I want some PM functions.. */
#  define INCL_DOSPROCESS	/* TIB PIB. */
#  include <os2.h>
#  undef BOOLEAN
#endif

#ifdef VMS
#include <descrip.h>
#include <libclidef.h>
#include <lib$routines.h>
#endif /* VMS */

#ifdef HAVE_UTMP
#include <pwd.h>
#ifdef UTMPX_FOR_UTMP
#include <utmpx.h>
#define utmp utmpx
#ifdef UTMPX_FILE
#ifdef UTMP_FILE
#undef UTMP_FILE
#endif /* UTMP_FILE */
#define UTMP_FILE UTMPX_FILE
#else
#ifdef __UTMPX_FILE
#define UTMP_FILE __UTMPX_FILE	/* at least in OS/390  S/390 -- gil -- 2100 */
#else
#ifndef UTMP_FILE
#define UTMP_FILE "/var/adm/utmpx"	/* Digital Unix 4.0 */
#endif
#endif
#endif /* UTMPX_FILE */
#else
#include <utmp.h>
#endif /* UTMPX_FOR_UTMP */
#endif /* HAVE_UTMP */

#ifdef NEED_PTEM_H
/* they neglected to define struct winsize in termios.h -- it's only in
 * termio.h and ptem.h (the former conflicts with other definitions).
 */
#include	<sys/stream.h>
#include	<sys/ptem.h>
#endif

#include <LYLeaks.h>

#ifdef USE_COLOR_STYLE
#include <AttrList.h>
#include <LYHash.h>
#include <LYStyle.h>
#endif

#ifdef SVR4_BSDSELECT
extern int BSDselect(int nfds, fd_set * readfds, fd_set * writefds,
		     fd_set * exceptfds, struct timeval *timeout);

#ifdef select
#undef select
#endif /* select */
#define select BSDselect
#ifdef SOCKS
#ifdef Rselect
#undef Rselect
#endif /* Rselect */
#define Rselect BSDselect
#endif /* SOCKS */
#endif /* SVR4_BSDSELECT */

#ifdef __DJGPP__
#undef select			/* defined to select_s in www_tcp.h */
#endif

#ifndef UTMP_FILE
#if defined(__FreeBSD__) || defined(__bsdi__)
#define UTMP_FILE _PATH_UTMP
#else
#define UTMP_FILE "/etc/utmp"
#endif /* __FreeBSD__ || __bsdi__ */
#endif /* !UTMP_FILE */

/*
 * experimental - make temporary filenames random to make the scheme less
 * obvious.  However, as noted by KW, there are instances (such as the
 * 'O'ption page, for which Lynx will store a temporary filename even when
 * it no longer applies, since it will reuse that filename at a later time.
 */
#ifdef USE_RAND_TEMPNAME
#if defined(LYNX_RAND_MAX)
#define HAVE_RAND_TEMPNAME 1
#define MAX_TEMPNAME 10000
#ifndef BITS_PER_CHAR
#define BITS_PER_CHAR 8
#endif
#endif
#endif

#define COPY_COMMAND "%s %s %s"

static HTList *localhost_aliases = NULL;	/* Hosts to treat as local */
static char *HomeDir = NULL;	/* HOME directory */

HTList *sug_filenames = NULL;	/* Suggested filenames   */

/*
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
 */
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    BOOLEAN outs;
    FILE *file;
} LY_TEMP;

static LY_TEMP *ly_temp;

static LY_TEMP *FindTempfileByName(const char *name)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    break;
	}
    }
    return p;
}

static LY_TEMP *FindTempfileByFP(FILE *fp)
{
    LY_TEMP *p;

    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    break;
	}
    }
    return p;
}

#if defined(_WIN32)
/*
 * Use RegQueryValueExA() rather than RegQueryValueEx() for compatibility
 * with non-Unicode winvile
 */
static int w32_get_reg_sz(HKEY hkey, const char *name, char *value, unsigned length)
{
    int result;
    DWORD dwSzBuffer = length;

    CTRACE((tfp, "w32_get_reg_sz(%s)\n", name));
    result = RegQueryValueExA(hkey,
			      name,
			      NULL,
			      NULL,
			      (LPBYTE) value,
			      &dwSzBuffer);
    if (result == ERROR_SUCCESS) {
	value[dwSzBuffer] = 0;
	CTRACE((tfp, "->%s\n", value));
    }
    return result;
}

static char *w32_get_shell_folder(const char *name)
{
    static HKEY rootkey = HKEY_CURRENT_USER;

    char *result = 0;
    HKEY hkey;
    char buffer[LY_MAXPATH];

    if (RegOpenKeyEx(rootkey,
		     W32_STRING("Software"
				"\\Microsoft"
				"\\Windows"
				"\\CurrentVersion"
				"\\Explorer"
				"\\Shell Folders"),
		     0,
		     KEY_READ,
		     &hkey) == ERROR_SUCCESS) {
	if (w32_get_reg_sz(hkey, name, buffer, sizeof(buffer)) == ERROR_SUCCESS) {

	    result = strdup(buffer);
	    (void) RegCloseKey(hkey);
	}

	(void) RegCloseKey(hkey);
    }
    return non_empty(result) ? result : 0;
}
#endif

/*
 * Get an environment variable, rejecting empty strings
 */
char *LYGetEnv(const char *name)
{
    char *result = getenv(name);

#if defined(_WIN32)
    if (result == 0) {
	static HKEY rootkeys[] =
	{HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE};

	int j;
	HKEY hkey;
	char buffer[256];

	for (j = 0; j < (int) TABLESIZE(rootkeys); ++j) {
	    if (RegOpenKeyEx(rootkeys[j],
			     LYNX_SUBKEY W32_STRING("\\Environment"),
			     0,
			     KEY_READ,
			     &hkey) == ERROR_SUCCESS) {
		if (w32_get_reg_sz(hkey, name, buffer, sizeof(buffer)) == ERROR_SUCCESS) {

		    result = strdup(buffer);
		    (void) RegCloseKey(hkey);
		    break;
		}

		(void) RegCloseKey(hkey);
	    }
	}
    }
#endif
    return non_empty(result) ? result : 0;
}

/*
 * ascii versions of locale sensitive functions needed because in
 * Turkish locales tolower("I") is not "i". That's fatal for case
 * sensitive operations with charset names, HTML tags etc.
 */
#ifdef USE_ASCII_CTYPES
int ascii_tolower(int i)
{
    if (91 > i && i > 64)
	return (i + 32);
    else
	return i;
}

int ascii_toupper(int i)
{
    if (123 > i && i > 96)
	return (i - 32);
    else
	return i;
}

int ascii_isupper(int i)
{
    if (91 > i && i > 64)
	return 1;
    else
	return 0;
}
#endif /* USE_ASCII_CTYPES */

/*
 * Check for UTF-8 data, returning the length past the first character.
 * Return zero if we found an ordinary character rather than UTF-8.
 */
size_t utf8_length(int utf_flag,
		   const char *data)
{
    size_t utf_extra = 0;

    if (utf_flag && is8bits(*data)) {
	if ((*data & 0xe0) == 0xc0) {
	    utf_extra = 1;
	} else if ((*data & 0xf0) == 0xe0) {
	    utf_extra = 2;
	} else if ((*data & 0xf8) == 0xf0) {
	    utf_extra = 3;
	} else if ((*data & 0xfc) == 0xf8) {
	    utf_extra = 4;
	} else if ((*data & 0xfe) == 0xfc) {
	    utf_extra = 5;
	} else {
	    /*
	     * Garbage.
	     */
	    utf_extra = 0;
	}
	if (strlen(data + 1) < utf_extra) {
	    /*
	     * Shouldn't happen.
	     */
	    utf_extra = 0;
	}
    }
    return utf_extra;
}

/*
 * Free storage used for the link-highlighting.
 */
void LYFreeHilites(int first, int last)
{
    int i;

    for (i = first; i < last; i++) {
	LYSetHilite(i, NULL);
	FREE(links[i].lname);
    }
}

#define LXP (links[cur].lx)
#define LYP (links[cur].ly)

/*
 * Set the initial highlight information for a given link.
 */
void LYSetHilite(int cur,
		 const char *text)
{
    links[cur].list.hl_base.hl_text = DeConst(text);
    links[cur].list.hl_len = (short) ((text != NULL) ? 1 : 0);
    FREE(links[cur].list.hl_info);
}

/*
 * Add highlight information for the next line of a link.
 */
void LYAddHilite(int cur,
		 char *text,
		 int x)
{
    HiliteList *list = &(links[cur].list);
    HiliteInfo *have = list->hl_info;
    size_t need = (unsigned) (list->hl_len - 1);
    size_t want;

    list->hl_len = (short) (list->hl_len + 1);
    want = (size_t) list->hl_len;

    if (have != NULL) {
	have = typeRealloc(HiliteInfo, have, want);
    } else {
	have = typeMallocn(HiliteInfo, want);
    }
    list->hl_info = have;
    have[need].hl_text = text;
    have[need].hl_x = (short) x;
}

/*
 * Get the highlight text, counting from zero.
 */
const char *LYGetHiliteStr(int cur,
			   int count)
{
    const char *result;

    if (count >= links[cur].list.hl_len)
	result = NULL;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_text;
    else
	result = links[cur].list.hl_base.hl_text;
    return result;
}

/*
 * Get the X-ordinate at which to draw the corresponding highlight-text
 */
int LYGetHilitePos(int cur,
		   int count)
{
    int result;

    if (count >= links[cur].list.hl_len)
	result = -1;
    else if (count > 0)
	result = links[cur].list.hl_info[count - 1].hl_x;
    else
	result = LXP;
    return result;
}

#ifdef SHOW_WHEREIS_TARGETS

#define SKIP_GLYPHS(theFlag, theData, theOffset) \
	(theFlag \
	    ? LYmbcs_skip_glyphs(theData, (theOffset), theFlag) \
	    : (theData + (theOffset)))

/*
 * If we have an emphasized WHEREIS hit in the highlighted text, restore the
 * emphasis.  Note that we never emphasize the first and last characters of the
 * highlighted text when we are making the link current, so the link attributes
 * for the current link will persist at the beginning and end, providing an
 * indication to the user that it has been made current.  Also note that we use
 * HText_getFirstTargetInLine() to determine if there's a hit in the HText
 * structure line containing the link, and if so, get back a copy of the line
 * starting at that first hit (which might be before or after our link), and
 * with all IsSpecial characters stripped, so we don't need to deal with them
 * here.  -FM
 */
static BOOL show_whereis_targets(int flag,
				 int cur,
				 int count,
				 const char *target,
				 int TargetEmphasisON,
				 int utf_flag)
{
    const char *Data = NULL;
    const char *cp;
    char *theData = NULL;
    char buffer[MAX_LINE];
    char tmp[7];
    int HitOffset;
    int LenNeeded;
    int Offset;
    int tLen;

    tmp[0] = tmp[1] = tmp[2] = '\0';

    if (non_empty(target)
	&& (links[cur].type & WWW_LINK_TYPE)
	&& non_empty(LYGetHiliteStr(cur, count))
	&& LYP + count < display_lines
	&& HText_getFirstTargetInLine(HTMainText,
				      links[cur].anchor_line_num + count,
				      utf_flag,
				      &Offset,
				      &tLen,
				      &theData,
				      target)) {
	int itmp, written, len, y, offset;
	const char *data;
	int tlen = (int) strlen(target);
	int hlen, hLen;
	int hLine = LYP + count;
	int hoffset = LYGetHilitePos(cur, count);
	size_t utf_extra = 0;

	/*
	 * Copy into the buffer only what will fit up to the right border of
	 * the screen.  -FM
	 */
	LYmbcsstrncpy(buffer,
		      NonNull(LYGetHiliteStr(cur, count)),
		      (int) (sizeof(buffer) - 1),
		      (LYcolLimit - LYGetHilitePos(cur, count)),
		      utf_flag);
	hlen = (int) strlen(buffer);
	hLen = ((IS_CJK_TTY || utf_flag) ?
		LYmbcsstrlen(buffer, utf_flag, YES) : hlen);

	/*
	 * Break out if the first hit in the line starts after this link.  -FM
	 */
	if (Offset < (hoffset + hLen)) {
	    /*
	     * Recursively skip hits that end before this link, and break out
	     * if there is no hit beyond those.  -FM
	     */
	    Data = theData;
	    while ((Offset < hoffset) &&
		   ((Offset + tLen) <= hoffset)) {
		data = (Data + tlen);
		offset = (Offset + tLen);
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols) {
		    Data = cp;
		    Offset = (offset + HitOffset);
		} else {
		    goto highlight_search_done;
		}
	    }
	    data = buffer;
	    offset = hoffset;

	    /*
	     * If the hit starts before the hightext, and ends in or beyond the
	     * hightext, restore the emphasis, skipping the first and last
	     * characters of the hightext if we're making the link current.
	     * -FM
	     */
	    if (offset >= 0 &&
		(Offset < offset) &&
		((Offset + tLen) > offset)) {
		itmp = 0;
		written = 0;
		len = (tlen - (offset - Offset));

		/*
		 * Go to the start of the hightext and handle its first
		 * character.  -FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		utf_extra = utf8_length(utf_flag, data + itmp);
		if (utf_extra) {
		    LYStrNCpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += (int) utf_extra;
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
		     */
		    if (flag != TRUE) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (int) (utf_extra + 1);
		} else if (IS_CJK_TTY && is8bits(tmp[0])) {
		    /*
		     * For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
		     */
		    if (flag != TRUE) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current.  -FM
		     */
		    if (flag != TRUE) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    written++;
		}
		itmp++;
		/*
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
		 */
		if (!TargetEmphasisON &&
		    data[itmp] != '\0') {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		}

		/*
		 * Handle the remaining characters.  -FM
		 */
		for (;
		     written < len && (tmp[0] = data[itmp]) != '\0';
		     itmp++) {
		    /*
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
		     */
		    utf_extra = utf8_length(utf_flag, data + itmp);
		    if (utf_extra) {
			LYStrNCpy(&tmp[1], &data[itmp + 1], utf_extra);
			itmp += (int) utf_extra;
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == TRUE && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    (void) y;
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += (int) (utf_extra + 1);
		    } else if (IS_CJK_TTY && is8bits(tmp[0])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			tmp[1] = data[++itmp];
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == TRUE && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += 2;
		    } else {
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == TRUE && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			written++;
		    }
		}

		/*
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or or we are making the link current and it
		 * is the last character of the hightext, we are done.  -FM
		 */
		if (TargetEmphasisON) {
		    LYstopTargetEmphasis();
		    TargetEmphasisON = FALSE;
		}
		LYGetYX(y, offset);
		if (offset < (hoffset + (flag == TRUE ? (hLen - 1) : hLen))
		/*
		 * See if we have another hit that starts within the
		 * hightext.  -FM
		 */
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset +
		     (flag == TRUE ? (hLen - 1) : hLen))) {
		    /*
		     * Set up the data and offset for the hit, and let the code
		     * for within hightext hits handle it.  -FM
		     */
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext;
		}
		goto highlight_search_done;
	    }

	  highlight_hit_within_hightext:
	    /*
	     * If we get to here, the hit starts within the hightext.  If we
	     * are making the link current and it's the last character in the
	     * hightext, we are done.  Otherwise, move there and start
	     * restoring the emphasis.  -FM
	     */
	    if ((Offset - offset) <= (flag == TRUE ? (hLen - 1) : hLen)) {
		data = SKIP_GLYPHS(utf_flag, data, Offset - offset);
		if (utf_flag) {
		    LYrefresh();
		}
		offset = Offset;
		itmp = 0;
		written = 0;
		len = tlen;

		/*
		 * Go to the start of the hit and handle its first character.
		 * -FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		utf_extra = utf8_length(utf_flag, data + itmp);
		if (utf_extra) {
		    LYStrNCpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += (int) utf_extra;
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != TRUE ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (int) (utf_extra + 1);
		} else if (IS_CJK_TTY && is8bits(tmp[0])) {
		    /*
		     * For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != TRUE ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 2));
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     * Start emphasis immediately if we are making the link
		     * non-current, or we are making it current but this is not
		     * the first or last character of the hightext.  -FM
		     */
		    if (flag != TRUE ||
			(offset > hoffset && data[itmp + 1] != '\0')) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    written++;
		}
		itmp++;
		/*
		 * Start emphasis after the first character if we are making
		 * the link current and this is not the last character.  -FM
		 */
		if (!TargetEmphasisON &&
		    data[itmp] != '\0') {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		}

		for (;
		     written < len && (tmp[0] = data[itmp]) != '\0';
		     itmp++) {
		    /*
		     * Print all the other target chars, except the last
		     * character if it is also the last character of hightext
		     * and we are making the link current.  -FM
		     */
		    utf_extra = utf8_length(utf_flag, data + itmp);
		    if (utf_extra) {
			LYStrNCpy(&tmp[1], &data[itmp + 1], utf_extra);
			itmp += (int) utf_extra;
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == TRUE && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += (int) (utf_extra + 1);
		    } else if (IS_CJK_TTY && is8bits(tmp[0])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			tmp[1] = data[++itmp];
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == TRUE && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			tmp[1] = '\0';
			written += 2;
		    } else {
			/*
			 * Make sure we don't restore emphasis to the last
			 * character of hightext if we are making the link
			 * current.  -FM
			 */
			if (flag == TRUE && data[(itmp + 1)] == '\0') {
			    LYstopTargetEmphasis();
			    TargetEmphasisON = FALSE;
			    LYGetYX(y, offset);
			    LYmove(hLine, (offset + 1));
			} else {
			    LYaddstr(tmp);
			}
			written++;
		    }
		}

		/*
		 * Stop the emphasis if we haven't already, then reset the
		 * offset to our current position in the line, and if that is
		 * beyond the link, or we are making the link current and it is
		 * the last character in the hightext, we are done.  -FM
		 */
		if (TargetEmphasisON) {
		    LYstopTargetEmphasis();
		    TargetEmphasisON = FALSE;
		}
		LYGetYX(y, offset);
		if (offset < (hoffset + (flag == TRUE ? (hLen - 1) : hLen))
		/*
		 * See if we have another hit that starts within the
		 * hightext.  -FM
		 */
		    && ((cp =
			 LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag,
								Data,
								offset - Offset),
					     target,
					     utf_flag, YES,
					     &HitOffset,
					     &LenNeeded)) != NULL)
		    && (offset + LenNeeded) < LYcols
		/*
		 * If the hit starts after the end of the hightext, or we
		 * are making the link current and the hit starts at its
		 * last character, we are done.  -FM
		 */
		    && (HitOffset + offset) <
		    (hoffset + (flag == TRUE ? (hLen - 1) : hLen))) {
		    /*
		     * If the target extends beyond our buffer, emphasize
		     * everything in the hightext starting at this hit.
		     * Otherwise, set up the data and offsets, and loop back.
		     * -FM
		     */
		    if ((HitOffset + (offset + tLen)) >= (hoffset + hLen)) {
			offset = (HitOffset + offset);
			data = SKIP_GLYPHS(utf_flag, Data, offset - hoffset);
			if (utf_flag) {
			    LYrefresh();
			}
			LYmove(hLine, offset);
			itmp = 0;
			written = 0;
			len = (int) strlen(data);

			/*
			 * Turn the emphasis back on.  -FM
			 */
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			for (;
			     written < len && (tmp[0] = data[itmp]) != '\0';
			     itmp++) {
			    /*
			     * Print all the other target chars, except the
			     * last character if it is also the last character
			     * of hightext and we are making the link current.
			     * -FM
			     */
			    utf_extra = utf8_length(utf_flag, data + itmp);
			    if (utf_extra) {
				LYStrNCpy(&tmp[1], &data[itmp + 1], utf_extra);
				itmp += (int) utf_extra;
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == TRUE && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				    LYGetYX(y, offset);
				    LYmove(hLine, (offset + 1));
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += (int) (utf_extra + 1);
			    } else if (IS_CJK_TTY && is8bits(tmp[0])) {
				/*
				 * For CJK strings, by Masanobu Kimura.
				 */
				tmp[1] = data[++itmp];
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == TRUE && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				tmp[1] = '\0';
				written += 2;
			    } else {
				/*
				 * Make sure we don't restore emphasis to the
				 * last character of hightext if we are making
				 * the link current.  -FM
				 */
				if (flag == TRUE && data[(itmp + 1)] == '\0') {
				    LYstopTargetEmphasis();
				    TargetEmphasisON = FALSE;
				} else {
				    LYaddstr(tmp);
				}
				written++;
			    }
			}
			/*
			 * Turn off the emphasis if we haven't already, and
			 * then we're done.  -FM
			 */
			if (TargetEmphasisON) {
			    LYstopTargetEmphasis();
			}
		    } else {
			Data = cp;
			Offset = (offset + HitOffset);
			data = buffer;
			offset = hoffset;
			goto highlight_hit_within_hightext;
		    }
		}
	    }
	}
    }
  highlight_search_done:
    FREE(theData);
    return (BOOLEAN) TargetEmphasisON;
}
#endif /* SHOW_WHEREIS_TARGETS */

#ifdef USE_COLOR_STYLE
static int find_cached_style(int cur,
			     int flag)
{
    int s = s_alink;

#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
    if (textfields_need_activation
	&& links[cur].type == WWW_FORM_LINK_TYPE
	&& F_TEXTLIKE(links[cur].l_form->type))
	s = s_curedit;
#endif

    if (flag != TRUE) {
	int x;

	/*
	 * This is where we try to restore the original style when a link is
	 * unhighlighted.  The cached styles array saves the original style
	 * just for this case.  If it doesn't have a color change saved at just
	 * the right position, we look at preceding positions in the same line
	 * until we find one.
	 */
	if (ValidCachedStyle(LYP, LXP)) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: cached style @@(%d,%d): ",
		     LYP, LXP));
	    s = (int) GetCachedStyle(LYP, LXP);
	    if (s == 0) {
		for (x = LXP - 1; x >= 0; x--) {
		    s = (int) GetCachedStyle(LYP, x);
		    if (s != 0) {
			SetCachedStyle(LYP, LXP, (unsigned) s);
			CTRACE2(TRACE_STYLE,
				(tfp, "found %d, x_offset=%d.\n", s, x - LXP));
			break;
		    }
		}
		if (s == 0) {
		    CTRACE2(TRACE_STYLE, (tfp, "not found, assume <a>.\n"));
		    s = s_a;
		}
	    } else {
		CTRACE2(TRACE_STYLE, (tfp, "found %d.\n", s));
	    }
	} else {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: can't use cache.\n"));
	    s = s_a;
	}
    } else {
	CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.on: @@(%d,%d).\n", LYP, LXP));
    }
    return s;
}
#endif /* USE_COLOR_STYLE */

/*
 * Highlight (or unhighlight) a given link.
 */
void LYhighlight(int flag,
		 int cur,
		 const char *target)
{
    char buffer[MAX_LINE];
    int i;
    int hi_count;
    int hi_offset;
    int title_adjust = (no_title ? -TITLE_LINES : 0);
    char tmp[7];
    const char *hi_string;

#ifdef SHOW_WHEREIS_TARGETS
    BOOL TargetEmphasisON = FALSE;
    BOOL target1_drawn = NO;
#endif
    BOOL utf_flag = (BOOL) IS_UTF8_TTY;
    BOOL hl1_drawn = NO;

    tmp[0] = tmp[1] = tmp[2] = '\0';

    /*
     * Bugs in the history code might cause -1 to be sent for cur, which yields
     * a crash when LYStrNCpy() is called with a nonsense pointer.  As far as I
     * know, such bugs have been squashed, but if they should reappear, this
     * works around them.  -FM
     */
    if (cur < 0) {
	CTRACE((tfp, "LYhighlight cur %d (bug workaround)\n", cur));
	cur = 0;
    }

    CTRACE((tfp, "LYhighlight at(%2d,%2d) %s %d [%d]:%s\n",
	    links[cur].ly, links[cur].lx,
	    (flag
	     ? "on"
	     : "off"),
	    cur,
	    links[cur].anchor_number,
	    NONNULL(target)));

#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (flag == FALSE)
	textinput_redrawn = FALSE;
#endif

    if (nlinks > 0) {
#ifdef USE_COLOR_STYLE
	if (flag == TRUE || links[cur].type == WWW_FORM_LINK_TYPE) {
	    LYmove(LYP + title_adjust, LXP);
	    LynxChangeStyle(find_cached_style(cur, flag), STACK_ON);
	}
#else
	if (links[cur].type == WWW_FORM_LINK_TYPE
	    || LYGetHiliteStr(cur, 0) == NULL) {
	    LYMoveToLink(cur, target, NULL,
			 flag, links[cur].inUnderline, utf_flag);
	    lynx_start_link_color(flag == TRUE, links[cur].inUnderline);
	} else {
	    LYMoveToLink(cur, target, LYGetHiliteStr(cur, 0),
			 flag, links[cur].inUnderline, utf_flag);
	    hl1_drawn = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    target1_drawn = YES;
#endif
	}
#endif

	if (links[cur].type == WWW_FORM_LINK_TYPE) {
	    int len;
	    int avail_space = (LYcolLimit - LXP) + (LYcolLimit * (LYlines - LYP));
	    const char *text = LYGetHiliteStr(cur, 0);

	    if (text == 0)
		text = "";

	    if (avail_space > links[cur].l_form->size)
		avail_space = links[cur].l_form->size;

	    len = (int) (LYmbcs_skip_cells(text, avail_space, utf_flag) - text);
	    LYwaddnstr(LYwin, text, (size_t) len);
	    while (len++ < avail_space)
		LYaddch('_');

#ifdef USE_COLOR_STYLE
	} else if (flag == FALSE) {
	    redraw_lines_of_link(cur);
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n",
		     LYP, LXP));
#endif
	} else if (!hl1_drawn) {
	    /*
	     * Copy into the buffer only what will fit within the width of the
	     * screen.
	     */
	    LYmbcsstrncpy(buffer,
			  NonNull(LYGetHiliteStr(cur, 0)),
			  (int) (sizeof(buffer) - 1),
			  (LYcolLimit - LXP),
			  utf_flag);
	    LYaddstr(buffer);
	}

	/*
	 * Display a second line as well.
	 */
	for (hi_count = 1;
	     (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
	     && LYP + hi_count <= display_lines;
	     ++hi_count) {
	    int row = LYP + hi_count + title_adjust;

	    hi_offset = LYGetHilitePos(cur, hi_count);
	    if (hi_offset < 0)
		continue;
	    lynx_stop_link_color(flag == TRUE, links[cur].inUnderline);
	    LYmove(row, hi_offset);

#ifdef USE_COLOR_STYLE
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
		     row, hi_offset,
		     flag == TRUE ? s_alink : s_a));
	    LynxChangeStyle(flag == TRUE ? s_alink : s_a, ABS_ON);
#else
	    lynx_start_link_color(flag == TRUE, links[cur].inUnderline);
#endif

	    for (i = 0; (tmp[0] = hi_string[i]) != '\0'
		 && (i + hi_offset) < LYcols; i++) {
		if (!IsSpecialAttrChar(hi_string[i])) {
		    /*
		     * For CJK strings, by Masanobu Kimura.
		     */
		    if (IS_CJK_TTY && is8bits(tmp[0])) {
			tmp[1] = hi_string[++i];
			LYaddstr(tmp);
			tmp[1] = '\0';
		    } else {
			LYaddstr(tmp);
		    }
		}
	    }
	}
	lynx_stop_link_color(flag == TRUE, links[cur].inUnderline);
#ifdef SHOW_WHEREIS_TARGETS
	for (hi_count = target1_drawn ? 1 : 0;
	     LYGetHiliteStr(cur, hi_count) != NULL;
	     hi_count++) {
	    TargetEmphasisON = show_whereis_targets(flag,
						    cur,
						    hi_count,
						    target,
						    TargetEmphasisON,
						    utf_flag);
	}

	if (!LYShowCursor)
	    /*
	     * Get cursor out of the way.
	     */
	    LYHideCursor();
	else
#endif /* SHOW_WHEREIS_TARGETS */
	    /*
	     * Never hide the cursor if there's no FANCY CURSES or SLANG.
	     */
	    LYmove(LYP + title_adjust, ((LXP > 0) ? (LXP - 1) : 0));

	if (flag)
	    LYrefresh();
    }
    return;
}

/*
 * free_and_clear will free a pointer if it is non-zero and then set it to
 * zero.
 */
void free_and_clear(char **pointer)
{
    if (*pointer) {
	FREE(*pointer);
	*pointer = 0;
    }
    return;
}

/*
 * Convert single or serial newlines to single spaces throughout a string
 * (ignore newlines if the preceding character is a space) and convert tabs to
 * single spaces.  Don't ignore any explicit tabs or spaces if the condense
 * argument is FALSE, otherwise, condense any serial spaces or tabs to one
 * space.  - FM
 */
void convert_to_spaces(char *string,
		       int condense)
{
    char *s = string;
    char *ns;
    BOOL last_is_space = FALSE;

    if (!s)
	return;

    s = LYSkipNonBlanks(s);
    ns = s;

    while (*s) {
	switch (*s) {
	case ' ':
	case '\t':
	    if (!(condense && last_is_space))
		*(ns++) = ' ';
	    last_is_space = TRUE;
	    break;

	case '\r':
	case '\n':
	    if (!last_is_space) {
		*(ns++) = ' ';
		last_is_space = TRUE;
	    }
	    break;

	default:
	    *(ns++) = *s;
	    last_is_space = FALSE;
	    break;
	}
	s++;
    }
    *ns = '\0';
    return;
}

/*
 * Strip trailing slashes from directory paths.
 */
char *strip_trailing_slash(char *dirname)
{
    int i;

    i = (int) strlen(dirname) - 1;
    while (i >= 0 && dirname[i] == '/')
	dirname[i--] = '\0';
    return (dirname);
}

/*
 * Remove most blanks, but restore one trailing blank to make prompts nicer.
 */
static void remove_most_blanks(char *buffer)
{
    int length = (int) strlen(buffer);
    BOOL trailing = (BOOL) ((length != 0) && (buffer[length - 1] == ' '));

    LYReduceBlanks(buffer);
    if (trailing)
	strcat(buffer, " ");
}

/*
 * Display (or hide) the status line.
 */
BOOLEAN mustshow = FALSE;

void statusline(const char *text)
{
    char buffer[MAX_LINE];
    unsigned char *temp = NULL;
    int max_length, len, i, j;
    int at_lineno;
    unsigned char k;
    char *p;
    char text_buff[MAX_LINE];

    if (text == NULL)
	return;

    /*
     * Don't print statusline messages if dumping to stdout.
     */
    if (dump_output_immediately)
	return;

    /*
     * Don't print statusline message if turned off.
     */
    if (mustshow != TRUE) {
	if (no_statusline == TRUE) {
	    return;
	}
    }
    mustshow = FALSE;

    /* "LYNXDOWNLOAD://Method=-1/File=%s/SugFile=%s%s\">Save to disk</a>\n" */
    LYStrNCpy(text_buff, text, sizeof(text_buff) - 1);
    p = StrChr(text_buff, '\n');
    if (p)
	*p = '\0';

    /*
     * Deal with any CJK escape sequences and Kanji if we have a CJK character
     * set selected, otherwise, strip any escapes.  Also, make sure text is not
     * longer than the statusline window.  - FM
     */
    max_length = (((LYcolLimit - 1) < (int) sizeof(buffer))
		  ? (LYcolLimit - 1)
		  : (int) sizeof(buffer) - 1);
    if ((text_buff[0] != '\0') &&
	(LYHaveCJKCharacterSet)) {
	/*
	 * Translate or filter any escape sequences.  - FM
	 */
	if ((temp = typecallocn(unsigned char, strlen(text_buff) + 1)) == NULL)
	      outofmem(__FILE__, "statusline");

	assert(temp != NULL);

	if (kanji_code == EUC) {
	    TO_EUC((const unsigned char *) text_buff, temp);
	} else if (kanji_code == SJIS) {
#ifdef KANJI_CODE_OVERRIDE
	    if (!LYRawMode || last_kcode == SJIS)
		strcpy(temp, text_buff);
	    else
		TO_SJIS((const unsigned char *) text_buff, temp);
#else
	    strcpy((char *) temp, text_buff);
#endif
	} else {
	    for (i = 0, j = 0; text_buff[i]; i++) {
		if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
		    temp[j++] = UCH(text_buff[i]);
		}
	    }
	    temp[j] = '\0';
	}

	/*
	 * Deal with any newlines or tabs in the string.  - FM
	 */
	remove_most_blanks((char *) temp);

	/*
	 * Handle the Kanji, making sure the text is not longer than the
	 * statusline window.  - FM
	 */
	for (i = 0, j = 0, len = 0, k = '\0';
	     temp[i] != '\0' && len < max_length; i++) {
	    if (k != '\0') {
		buffer[j++] = (char) k;
		buffer[j++] = (char) temp[i];
		k = '\0';
		len += 2;
	    } else if ((temp[i] & 0200) != 0) {
		k = temp[i];
	    } else {
		buffer[j++] = (char) temp[i];
		len++;
	    }
	}
	buffer[j] = '\0';
	FREE(temp);
    } else {
	/*
	 * Deal with any newlines or tabs in the string.  - FM
	 */
	remove_most_blanks(text_buff);
#ifdef WIDEC_CURSES
	len = (int) strlen(text_buff);
	if (len >= (int) (sizeof(buffer) - 1))
	    len = (int) (sizeof(buffer) - 1);
	LYStrNCpy(buffer, text_buff, len);
	/* FIXME: a binary search might be faster */
	while (len > 0 && LYstrExtent(buffer, len, len) > max_length)
	    buffer[--len] = '\0';
#else
	/*
	 * Strip any escapes, and shorten text if necessary.  Note that we
	 * don't deal with the possibility of UTF-8 characters in the string. 
	 * This is unlikely, but if strings with such characters are used in
	 * LYMessages_en.h, a compilation symbol of HAVE_UTF8_STATUSLINES could
	 * be added there, and code added here for determining the displayed
	 * string length, as we do above for CJK.  - FM
	 */
	for (i = 0, len = 0; text_buff[i] != '\0' && len < max_length; i++) {
	    if (text_buff[i] != CH_ESC) {	/* S/390 -- gil -- 2119 */
		buffer[len++] = text_buff[i];
	    }
	}
	buffer[len] = '\0';
#endif
    }

    /*
     * Move to the desired statusline window and output the text highlighted. 
     * - FM
     */
    if (LYStatusLine >= 0) {
	if (LYStatusLine < LYlines - 1) {
	    at_lineno = LYStatusLine;
	} else {
	    at_lineno = LYlines - 1;
	}
    } else if (user_mode == NOVICE_MODE) {
	at_lineno = LYlines - 3;
    } else {
	at_lineno = LYlines - 1;
    }
    LYmove(at_lineno, 0);
    LYclrtoeol();

    if (buffer[0] != '\0') {
	BOOLEAN has_CJK = FALSE;

	if (IS_CJK_TTY) {
	    for (i = 0; buffer[i] != '\0'; i++) {
		if (buffer[i] & 0x80) {
		    has_CJK = TRUE;
		    break;
		}
	    }
	}

	if (has_CJK
#ifdef HAVE_UTF8_STATUSLINES
	    || IS_UTF8_TTY
#endif
	    ) {
	    LYrefresh();
	}
#ifndef USE_COLOR_STYLE
	lynx_start_status_color();
	LYaddstr(buffer);
	lynx_stop_status_color();
#else
	/* draw the status bar in the STATUS style */
	{
	    int y, x;
	    int a = ((StrNCmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
		      || !hashStyles[s_alert].name)
		     ? s_status
		     : s_alert);

	    LynxChangeStyle(a, STACK_ON);
	    LYaddstr(buffer);
	    wbkgdset(LYwin,
		     ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
		      ? (chtype) hashStyles[a].color
		      : A_NORMAL) | ' ');
	    LYGetYX(y, x);
	    (void) x;
	    if (y == at_lineno) {
		LYclrtoeol();
	    }
	    if (!(lynx_has_color && LYShowColor >= SHOW_COLOR_ON))
		wbkgdset(LYwin, A_NORMAL | ' ');
	    else if (s_normal != NOSTYLE)
		wbkgdset(LYwin, (chtype) (hashStyles[s_normal].color | ' '));
	    else
		wbkgdset(LYwin, (chtype) (displayStyles[DSTYLE_NORMAL].color | ' '));
	    LynxChangeStyle(a, STACK_OFF);
	}
#endif
    }
    LYrefresh();

    return;
}

static const char *novice_lines(int lineno)
{
    switch (lineno) {
    case 0:
	return NOVICE_LINE_TWO_A;
    case 1:
	return NOVICE_LINE_TWO_B;
    case 2:
	return NOVICE_LINE_TWO_C;
    default:
	return "";
    }
}

static int lineno = 0;

void toggle_novice_line(void)
{
    lineno++;
    if (*novice_lines(lineno) == '\0')
	lineno = 0;
    return;
}

void noviceline(int more_flag GCC_UNUSED)
{
    if (dump_output_immediately)
	return;

    LYmove(LYlines - 2, 0);
    LYclrtoeol();
    LYaddstr(NOVICE_LINE_ONE);

    LYParkCursor();
#if defined(DIRED_SUPPORT ) && defined(OK_OVERRIDE)
    if (lynx_edit_mode && !no_dired_support)
	LYaddstr(DIRED_NOVICELINE);
    else
#endif /* DIRED_SUPPORT && OK_OVERRIDE */

    if (LYUseNoviceLineTwo)
	LYaddstr(NOVICE_LINE_TWO);
    else
	LYaddstr(novice_lines(lineno));

    LYrefresh();
    return;
}

#if defined(MISC_EXP) || defined(TTY_DEVICE) || defined(HAVE_TTYNAME)
/*
 * If the standard input is not a tty, and Lynx is really reading from the
 * standard input, attempt to reopen it, pointing to a real tty.  Normally
 * this would happen if the user pipes data to Lynx and wants to run
 * interactively after that.
 *
 * Returns:
 *     1  if successfully reopened
 *    -1  if we cannot reopen
 *     0  if we do not have to reopen
 */
int LYReopenInput(void)
{
    int result = 0;
    int fd;

    if ((fd = fileno(stdin)) == 0
	&& !isatty(fd)
	&& LYConsoleInputFD(FALSE) == fd) {
	const char *term_name = NULL;
	int new_fd = -1;

#ifdef HAVE_TTYNAME
	if (isatty(fileno(stdout)) &&
	    (term_name = ttyname(fileno(stdout))) != NULL)
	    new_fd = open(term_name, O_RDONLY);

	if (new_fd == -1 &&
	    isatty(fileno(stderr)) &&
	    (term_name = ttyname(fileno(stderr))) != NULL)
	    new_fd = open(term_name, O_RDONLY);
#endif

#ifdef HAVE_CTERMID
	if (new_fd == -1 &&
	    (term_name = ctermid(NULL)) != NULL)
	    new_fd = open(term_name, O_RDONLY);
#endif

#ifdef TTY_DEVICE
	if (new_fd == -1)
	    new_fd = open(term_name = TTY_DEVICE, O_RDONLY);
#endif

	CTRACE((tfp, "LYReopenInput open(%s) returned %d.\n", term_name, new_fd));
	if (new_fd >= 0) {
	    FILE *frp;

	    close(new_fd);
	    frp = freopen(term_name, "r", stdin);
	    CTRACE((tfp,
		    "LYReopenInput freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
		    term_name, (void *) frp, (void *) stdin, fileno(stdin)));
	    result = 1;
	} else {
	    result = -1;
	}
    }
    return result;
}
#endif

#if defined(NSL_FORK) || defined(MISC_EXP) || defined (TTY_DEVICE) || defined(HAVE_TTYNAME)
/*
 * Returns the file descriptor from which keyboard input is expected, or INVSOC
 * (-1) if not available.  If need_selectable is true, returns non-INVSOC fd
 * only if select() is possible - actually, currently only checks if fd is
 * connected to a tty.  - kw
 */
int LYConsoleInputFD(int need_selectable)
{
    int fd = INVSOC;

#ifdef USE_SLANG
    if (!LYCursesON)
	fd = fileno(stdin);
#if ((SLANG_VERSION >= 9919) && defined(REAL_UNIX_SYSTEM) && !defined(__CYGWIN__))
    /* SLang_TT_Read_FD introduced in slang 0.99.19, from its changelog: 
     * SLang_TT_Read_FD variable is now available for unix.  This is the file
     * descriptor used by SLang_getkey.  */
    else
	fd = SLang_TT_Read_FD;
#endif /* SLANG_VERSION >= 9919 */
#else /* !USE_SLANG */
    fd = fileno(stdin);
#endif /* !USE_SLANG */

    if (need_selectable && fd != INVSOC) {
	if (isatty(fd)) {
	    return fd;
	} else {
	    return INVSOC;
	}
    }
    return fd;
}
#endif /* NSL_FORK || MISC_EXP */

static int fake_zap = 0;

void LYFakeZap(int set)
{
    if (set && fake_zap < 1) {
	CTRACE((tfp, "\r *** Set simulated 'Z'"));
	if (fake_zap)
	    CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
	fake_zap++;
    } else if (!set && fake_zap) {
	CTRACE((tfp, "\r *** Unset simulated 'Z'"));
	CTRACE((tfp, ", %d pending", fake_zap));
	CTRACE((tfp, " ***\n"));
	fake_zap = 0;
    }

}

static int DontCheck(void)
{
    static time_t last;
    time_t next;

    /** Curses or slang setup was not invoked **/
    if (dump_output_immediately)
	return (TRUE);

    if (LYHaveCmdScript())	/* we may be running from a script */
	return (TRUE);

#ifdef MISC_EXP
    if (LYNoZapKey)
	return (TRUE);
#endif
    /*
     * Avoid checking interrupts more than one per second, since it is a slow
     * and expensive operation - TD
     */
#ifdef HAVE_GETTIMEOFDAY
#undef timezone			/* U/Win defines a conflicting macro */
    {
	struct timeval tv;

	gettimeofday(&tv, (struct timezone *) 0);
	next = tv.tv_usec / 100000L;	/* 0.1 seconds is a compromise */
    }
#else
    next = time((time_t *) 0);
#endif
    if (next == last)
	return (TRUE);

    last = next;
    return FALSE;
}

int HTCheckForInterrupt(void)
{
    int c;
    int cmd;

    if (fake_zap > 0) {
	fake_zap--;
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
	CTRACE_FLUSH(tfp);
	CTRACE_SLEEP(AlertSecs);
	return ((int) TRUE);
    }

    /** Curses or slang setup was not invoked **/
    if (DontCheck())
	return ((int) FALSE);

#ifndef VMS			/* UNIX stuff: */

#if !defined(_WINDOWS) || defined(__MINGW32__)

    /*
     * First, check if there is a character.
     */
#ifdef USE_SLANG
    /** No keystroke was entered
	Note that this isn't taking possible SOCKSification
	and the socks_flag into account, and may fail on the
	slang library's select() when SOCKSified. - FM **/
#ifdef DJGPP_KEYHANDLER
    if (0 == _bios_keybrd(_NKEYBRD_READY))
	return (FALSE);
#else
    if (0 == SLang_input_pending(0))
	return (FALSE);
#endif /* DJGPP_KEYHANDLER */

#else /* Unix curses: */
    {
	struct timeval socket_timeout;
	int ret = 0;
	fd_set readfds;

	socket_timeout.tv_sec = 0;
	socket_timeout.tv_usec = 0;
	FD_ZERO(&readfds);
	FD_SET(0, &readfds);
#ifdef SOCKS
	if (socks_flag)
	    ret = Rselect(1, &readfds, NULL, NULL, &socket_timeout);
	else
#endif /* SOCKS */
	    ret = select(1, &readfds, NULL, NULL, &socket_timeout);

	/** Suspended? **/
	if ((ret == -1) && (SOCKET_ERRNO == EINTR))
	    return ((int) FALSE);

	/** No keystroke was entered? **/
	if (!FD_ISSET(0, &readfds))
	    return ((int) FALSE);
    }
#endif /* USE_SLANG */

#endif /* !_WINDOWS */

    /*
     * Now, read the character.
     */
#if defined(USE_CURSES_NODELAY)
    nodelay(LYwin, TRUE);
    c = LYgetch();
    nodelay(LYwin, FALSE);
#elif defined(USE_SLANG) && defined(_WINDOWS)
    if (!SLang_input_pending(0))
	return ((int) FALSE);
    c = LYgetch();
#else
    c = LYgetch();
#endif

#else /* VMS: */
    extern int typeahead(void);

    /** Control-C or Control-Y and a 'N'o reply to exit query **/
    if (HadVMSInterrupt) {
	HadVMSInterrupt = FALSE;
	return ((int) TRUE);
    }

    c = typeahead();

#endif /* !VMS */

    /*
     * 'c' contains whatever character we're able to read from keyboard
     */

    /** Keyboard 'Z' or 'z', or Control-G or Control-C **/
    if (LYCharIsINTERRUPT(c))
	return ((int) TRUE);

    /* There is a subset of mainloop() actions available at this stage:  no new
     * getfile() cycle is possible until the previous finished.  Currently we
     * have scrolling in partial mode, toggling of trace log, and pasting. 
     * User search now in progress...
     */
    cmd = (LKC_TO_LAC(keymap, c));
    switch (cmd) {
    case LYK_TRACE_TOGGLE:	/*  Toggle TRACE mode. */
	handle_LYK_TRACE_TOGGLE();
	break;
#ifdef CAN_CUT_AND_PASTE
    case LYK_TO_CLIPBOARD:{	/* ^S */
	    const char *s = LYDownLoadAddress();

	    if (!s || !*s || put_clip(s))
		HTInfoMsg(gettext("Copy to clipboard failed."));
	    else
		HTInfoMsg(gettext("Download document URL put to clipboard."));
	    break;
	}
#endif /* defined CAN_CUT_AND_PASTE */
    default:
#ifdef DISP_PARTIAL
	/* OK, we got several lines from new document and want to scroll... */
	if (display_partial && (NumOfLines_partial > 2)) {
	    BOOLEAN do_refresh;
	    int res;
	    int Newline_partial = LYGetNewline();

	    switch (cmd) {
	    case LYK_WHEREIS:	/* search within the document */
	    case LYK_NEXT:	/* search for the next occurrence in the document */
	    case LYK_PREV:	/* search for the previous occurrence in the document */
		handle_LYK_WHEREIS(cmd, &do_refresh);
		if (www_search_result != -1) {
		    Newline_partial = www_search_result;
		    www_search_result = -1;	/* reset */
		}
		break;

	    case LYK_FASTBACKW_LINK:
		if (Newline_partial <= (display_lines) + 1) {
		    Newline_partial -= display_lines;
		} else if ((res =
			    HTGetLinkOrFieldStart(-1,
						  &Newline_partial, NULL,
						  -1, TRUE)) == LINK_LINE_FOUND) {
		    Newline_partial++;
		} else if (res == LINK_DO_ARROWUP) {
		    Newline_partial -= display_lines;
		}
		break;
	    case LYK_FASTFORW_LINK:
		if (HText_canScrollDown()) {
		    /* This is not an exact science... - kw */
		    if (HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								 Newline_partial,
								 display_lines)
					      - 1,
					      &Newline_partial, NULL,
					      1, TRUE) == LINK_LINE_FOUND) {
			Newline_partial++;
		    }
		}
		break;
	    case LYK_PREV_PAGE:
		if (Newline_partial > 1)
		    Newline_partial -= display_lines;
		break;
	    case LYK_NEXT_PAGE:
		if (HText_canScrollDown())
		    Newline_partial += display_lines;
		break;
	    case LYK_UP_HALF:
		if (Newline_partial > 1)
		    Newline_partial -= (display_lines / 2);
		break;
	    case LYK_DOWN_HALF:
		if (HText_canScrollDown())
		    Newline_partial += (display_lines / 2);
		break;
	    case LYK_UP_TWO:
		if (Newline_partial > 1)
		    Newline_partial -= 2;
		break;
	    case LYK_DOWN_TWO:
		if (HText_canScrollDown())
		    Newline_partial += 2;
		break;
	    case LYK_HOME:
		if (Newline_partial > 1)
		    Newline_partial = 1;
		break;
	    case LYK_END:
		if (HText_canScrollDown())
		    Newline_partial = HText_getNumOfLines() - display_lines + 1;
		/* calculate for "current" bottom value */
		break;
	    case LYK_REFRESH:
		break;
	    default:
		/** Other or no keystrokes **/
		return ((int) FALSE);
	    }			/* end switch */
	    if (Newline_partial < 1)
		Newline_partial = 1;
	    if (LYMainLoop_pageDisplay(Newline_partial))
		NumOfLines_partial = HText_getNumOfLines();
	}
#endif /* DISP_PARTIAL */
	break;
    }				/* end switch */
    /** Other or no keystrokes **/
    return ((int) FALSE);
}

/*
 * Check if the given filename looks like it's an absolute pathname, i.e.,
 * references a directory.
 */
BOOLEAN LYisAbsPath(const char *path)
{
    BOOLEAN result = FALSE;

    if (non_empty(path)) {
#ifdef VMS
	result = TRUE;
#else
#if defined(USE_DOS_DRIVES)
	result = (BOOLEAN) (LYIsPathSep(path[0])
			    || (LYIsDosDrive(path)
				&& LYIsPathSep(path[2])));
#else
	result = (BOOLEAN) (LYIsPathSep(path[0]));
#endif /* USE_DOS_DRIVES */
#endif
    }
    return result;
}

/*
 * Check if the given filename is the root path, e.g., "/" on Unix.
 */
BOOLEAN LYisRootPath(const char *path)
{
#if defined(USE_DOS_DRIVES)
    if (strlen(path) == 3
	&& LYIsDosDrive(path)
	&& LYIsPathSep(path[2]))
	return TRUE;
#endif
    return (BOOL) ((strlen(path) == 1) && LYIsPathSep(path[0]));
}

/*
 * A file URL for a remote host is an obsolete ftp URL.
 * Return YES only if we're certain it's a local file.  - FM
 */
BOOLEAN LYisLocalFile(const char *filename)
{
    char *host = NULL;
    char *acc_method = NULL;
    char *cp;

    if (!filename)
	return NO;
    if (!(host = HTParse(filename, "", PARSE_HOST)))
	return NO;
    if (!*host) {
	FREE(host);
	return NO;
    }

    if ((cp = StrChr(host, ':')) != NULL)
	*cp = '\0';

    if ((acc_method = HTParse(filename, "", PARSE_ACCESS))) {
	if (0 == strcmp("file", acc_method) &&
	    (0 == strcmp(host, "localhost") ||
	     LYSameFilename(host, HTHostName()))) {
	    FREE(host);
	    FREE(acc_method);
	    return YES;
	}
    }

    FREE(host);
    FREE(acc_method);
    return NO;
}

/*
 * Utility for checking URLs with a host field.  Return YES only if we're
 * certain it's the local host.  - FM
 */
BOOLEAN LYisLocalHost(const char *filename)
{
    char *host = NULL;
    char *cp;

    if (!filename)
	return NO;
    if (!(host = HTParse(filename, "", PARSE_HOST)))
	return NO;
    if (!*host) {
	FREE(host);
	return NO;
    }

    if ((cp = StrChr(host, ':')) != NULL)
	*cp = '\0';

    if ((LYSameFilename(host, "localhost") ||
	 LYSameFilename(host, LYHostName) ||
	 LYSameFilename(host, HTHostName()))) {
	FREE(host);
	return YES;
    }

    FREE(host);
    return NO;
}

/*
 * Free an HTList that contains strings.
 */
void LYFreeStringList(HTList *list)
{
    if (list != NULL) {
	char *argument;
	HTList *cur = list;

	while (NULL != (argument = (char *) HTList_nextObject(cur))) {
	    FREE(argument);
	}
	HTList_delete(list);
    }
}

/*
 * Utility for freeing the list of local host aliases.  - FM
 */
void LYLocalhostAliases_free(void)
{
    LYFreeStringList(localhost_aliases);
    localhost_aliases = NULL;
}

/*
 * Utility for listing hosts to be treated as local aliases.  - FM
 */
void LYAddLocalhostAlias(char *alias)
{
    char *LocalAlias = NULL;

    if (!non_empty(alias))
	return;

    if (!localhost_aliases) {
	localhost_aliases = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(LYLocalhostAliases_free);
#endif
    }

    StrAllocCopy(LocalAlias, alias);
    HTList_addObject(localhost_aliases, LocalAlias);

    return;
}

/*
 * Utility for checking URLs with a host field.  Return YES only if we've
 * listed the host as a local alias.  - FM
 */
BOOLEAN LYisLocalAlias(const char *filename)
{
    char *host = NULL;
    char *alias;
    char *cp;
    HTList *cur = localhost_aliases;

    if (!cur || !filename)
	return NO;
    if (!(host = HTParse(filename, "", PARSE_HOST)))
	return NO;
    if (!(*host)) {
	FREE(host);
	return NO;
    }

    if ((cp = StrChr(host, ':')) != NULL)
	*cp = '\0';

    while (NULL != (alias = (char *) HTList_nextObject(cur))) {
	if (LYSameFilename(host, alias)) {
	    FREE(host);
	    return YES;
	}
    }

    FREE(host);
    return NO;
}

/*
 *  This function checks for a URL with an unknown scheme,
 *  but for which proxying has been set up, and if so,
 *  returns PROXY_URL_TYPE. - FM
 *
 *  If a colon is present but the string segment which
 *  precedes it is not being proxied, and we can be sure
 *  that what follows the colon is not a port field,
 *  it returns UNKNOWN_URL_TYPE.  Otherwise, it returns
 *  0 (not a URL). - FM
 */
UrlTypes LYCheckForProxyURL(char *filename)
{
    char *cp = filename;
    char *cp1;
    char *cp2 = NULL;

    /*
     * Don't crash on an empty argument.
     */
    if (isEmpty(cp))
	return (NOT_A_URL_TYPE);

    /* kill beginning spaces */
    cp = LYSkipBlanks(cp);

    /*
     * Check for a colon, and if present,
     * see if we have proxying set up.
     */
    if ((cp1 = StrChr((cp + 1), ':')) != NULL) {
	if ((cp2 = StrChr((cp + 1), '/')) != NULL && cp2 < cp1)
	    return (NOT_A_URL_TYPE);
	*cp1 = '\0';
	cp2 = NULL;
	StrAllocCopy(cp2, cp);
	*cp1 = ':';
	StrAllocCat(cp2, "_proxy");
	if (LYGetEnv(cp2) != NULL) {
	    FREE(cp2);
	    return (PROXY_URL_TYPE);
	}
	FREE(cp2);
#if defined (USE_DOS_DRIVES)
	if (LYIsDosDrive(cp))
	    return (NOT_A_URL_TYPE);
#endif
	cp1++;
	if (!*cp) {
	    return (NOT_A_URL_TYPE);
	} else if (isdigit(UCH(*cp1))) {
	    while (*cp1 && isdigit(UCH(*cp1)))
		cp1++;
	    if (*cp1 && !LYIsHtmlSep(*cp1))
		return (UNKNOWN_URL_TYPE);
	} else {
	    return (UNKNOWN_URL_TYPE);
	}
    }

    return (NOT_A_URL_TYPE);
}

/*
 * Compare a "type:" string, replacing it by the comparison-string if it
 * matches (and return true in that case).
 */
static BOOLEAN compare_type(char *tst,
			    const char *cmp,
			    size_t len)
{
    if (!strncasecomp(tst, cmp, (int) len)) {
	if (StrNCmp(tst, cmp, len)) {
	    size_t i;

	    for (i = 0; i < len; i++)
		tst[i] = cmp[i];
	}
	return TRUE;
    }
    return FALSE;
}
#define CompareType(tst,cmp,len) compare_type((tst),(cmp),(size_t)(len))

#define DoubleHtmlSep(s) (LYIsHtmlSep((s)[0]) && LYIsHtmlSep((s)[1]))
#define compare_two(tst,cmp,len,limit) \
	((len + 2) <= limit \
	&& DoubleHtmlSep(tst + len) \
	&& CompareType(tst, cmp, len))

/*
 * Must recognize a URL and return the type.  If recognized, based on a
 * case-insensitive analysis of the scheme field, ensures that the scheme field
 * has the expected case.
 *
 * Returns 0 (not a URL) for a NULL argument, one which lacks a colon.
 *
 * Chains to LYCheckForProxyURL() if a colon is present but the type is not
 * recognized.
 */
UrlTypes is_url(char *filename)
{
    char *cp = filename;
    char *cp1;
    UrlTypes result = NOT_A_URL_TYPE;
    int limit;

    /*
     * Don't crash on an empty argument.
     */
    if (isEmpty(cp))
	return (result);

    /*
     * Can't be a URL if it lacks a colon and if it starts with '[' it's
     * probably IPv6 adress.
     */
    if (NULL == StrChr(cp, ':') || cp[0] == '[')
	return (result);

    /*
     * Kill beginning spaces.
     */
    cp = LYSkipBlanks(cp);

    /*
     * Can't be a URL if it starts with a slash.  So return immediately for
     * this common case, also to avoid false positives if there was a colon
     * later in the string.  Also can't be a URL if it starts with a colon.  -
     * KW
     */
    if (*cp == ':' || LYIsHtmlSep(*cp)) {
	result = NOT_A_URL_TYPE;

    } else {
	limit = (int) strlen(cp);
	switch (*cp) {
	case 'L':
	case 'l':
	    /*
	     * Lynx internal pages ("LYNXfoo:" or "lynxfoo:") start with 'l' or
	     * 'L', other URLs aren't.
	     */
	    if (CompareType(cp, STR_LYNXEXEC, LEN_LYNXEXEC)) {
		/*
		 * Special External Lynx type to handle execution of commands
		 * or scripts which require a pause to read the screen upon
		 * completion.
		 */
		result = LYNXEXEC_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXPROG, LEN_LYNXPROG)) {
		/*
		 * Special External Lynx type to handle execution of commands,
		 * scripts or programs which do not require a pause to read
		 * screen upon completion.
		 */
		result = LYNXPROG_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXCGI, LEN_LYNXCGI)) {
		result = LYNXCGI_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXPRINT, LEN_LYNXPRINT)) {
		result = LYNXPRINT_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
		result = LYNXOPTIONS_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXCFG, LEN_LYNXCFG)) {
		result = LYNXCFG_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXMESSAGES, LEN_LYNXMESSAGES)) {
		result = LYNXMESSAGES_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXCFLAGS, LEN_LYNXCFLAGS)) {
		result = LYNXCOMPILE_OPTS_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXDOWNLOAD, LEN_LYNXDOWNLOAD)) {
		result = LYNXDOWNLOAD_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXDIRED, LEN_LYNXDIRED)) {
		result = LYNXDIRED_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXEDITMAP, LEN_LYNXEDITMAP)) {
		result = LYNXEDITMAP_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXHIST, LEN_LYNXHIST)) {
		result = LYNXHIST_URL_TYPE;

#ifdef USE_CACHEJAR
	    } else if (CompareType(cp, STR_LYNXCACHE, LEN_LYNXCACHE)) {
		result = LYNXCACHE_URL_TYPE;
#endif
	    } else if (CompareType(cp, STR_LYNXKEYMAP, LEN_LYNXKEYMAP)) {
		result = LYNXKEYMAP_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXIMGMAP, LEN_LYNXIMGMAP)) {
		/* force lower/uppercase of next part */
		(void) is_url(&cp[LEN_LYNXIMGMAP]);
		result = LYNXIMGMAP_URL_TYPE;

	    } else if (CompareType(cp, STR_LYNXCOOKIE, LEN_LYNXCOOKIE)) {
		result = LYNXCOOKIE_URL_TYPE;

	    }
	    break;
#ifndef DISABLE_NEWS
	    /*
	     * NEWSfoo:  schemes -
	     */
	case 'N':
	case 'n':
	    if (CompareType(cp, STR_NEWS_URL, LEN_NEWS_URL)) {
		result = NEWS_URL_TYPE;

	    } else if (CompareType(cp, STR_NNTP_URL, LEN_NNTP_URL)) {
		result = NNTP_URL_TYPE;

	    } else if (CompareType(cp, "newspost:", 9)) {
		/*
		 * Special Lynx type to handle news posts.
		 */
		result = NEWSPOST_URL_TYPE;

	    } else if (CompareType(cp, "newsreply:", 10)) {
		/*
		 * Special Lynx type to handle news replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;

	    /*
	     * SNEWSfoo:  schemes -
	     */
	case 'S':
	case 's':
	    if (CompareType(cp, STR_SNEWS_URL, LEN_SNEWS_URL)) {
		result = SNEWS_URL_TYPE;

	    } else if (CompareType(cp, "snewspost:", 10)) {
		/*
		 * Special Lynx type to handle snews posts.
		 */
		result = NEWSPOST_URL_TYPE;

	    } else if (CompareType(cp, "snewsreply:", 11)) {
		/*
		 * Special Lynx type to handle snews replies (followups).
		 */
		result = NEWSREPLY_URL_TYPE;
	    }
	    break;
#endif
	case 'M':
	case 'm':
	    if (CompareType(cp, STR_MAILTO_URL, LEN_MAILTO_URL)) {
		result = MAILTO_URL_TYPE;
	    }
	    break;

	case 'F':
	case 'f':
	    if (CompareType(cp, STR_FILE_URL, LEN_FILE_URL)) {
		if (LYisLocalFile(cp)) {
		    result = FILE_URL_TYPE;
		} else if (DoubleHtmlSep(cp + LEN_FILE_URL)) {
		    result = FTP_URL_TYPE;
		}
	    }
#ifndef DISABLE_FTP
	    else if (compare_two(cp, STR_FTP_URL, LEN_FTP_URL, limit)) {
		result = FTP_URL_TYPE;
	    }
#endif
#ifndef DISABLE_FINGER
	    else if (compare_two(cp, STR_FINGER_URL, LEN_FINGER_URL, limit)) {
		result = FINGER_URL_TYPE;
	    }
#endif
	    break;

	case 'B':
	case 'b':
#ifndef DISABLE_BIBP
	    if (CompareType(cp, STR_BIBP_URL, LEN_BIBP_URL)) {
		result = BIBP_URL_TYPE;
	    }
#endif
	    break;

	case 'D':
	case 'd':
	    if (CompareType(cp, "data:", 5)) {
		result = DATA_URL_TYPE;
	    }
	    break;

	default:
	    if (limit >= 3
		&& ((cp1 = StrChr(cp + 3, ':')) == NULL
		    || !DoubleHtmlSep(cp1 + 1))) {
		/*
		 * If it doesn't contain "://", and it's not one of the the
		 * above, it can't be a URL with a scheme we know, so check if
		 * it's an unknown scheme for which proxying has been set up.
		 * - FM
		 */
		if (cp1 != NULL
		    && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		    && LYisAbsPath(cp1 + 1)) {
		    result = NCFTP_URL_TYPE;
		}

	    } else {
		switch (*cp) {
		case 'H':
		case 'h':
		    if (CompareType(cp, STR_HTTP_URL, LEN_HTTP_URL)) {
			result = HTTP_URL_TYPE;

		    } else if (CompareType(cp, STR_HTTPS_URL, LEN_HTTPS_URL)) {
			result = HTTPS_URL_TYPE;
		    }
		    break;

#ifndef DISABLE_GOPHER
		case 'G':
		case 'g':
		    if (CompareType(cp, STR_GOPHER_URL, LEN_GOPHER_URL)) {
			if (strlen(cp) >= 11
			    && (cp1 = StrChr(cp + 11, '/')) != NULL) {

			    if (TOUPPER(*(cp1 + 1)) == 'H' || *(cp1 + 1) == 'w')
				/* if this is a gopher html type */
				result = HTML_GOPHER_URL_TYPE;
			    else if (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')
				result = TELNET_GOPHER_URL_TYPE;
			    else if (*(cp1 + 1) == '7')
				result = INDEX_GOPHER_URL_TYPE;
			    else
				result = GOPHER_URL_TYPE;
			} else {
			    result = GOPHER_URL_TYPE;
			}
		    }
		    break;
#endif
		case 'W':
		case 'w':
		    if (CompareType(cp, STR_WAIS_URL, LEN_WAIS_URL)) {
			result = WAIS_URL_TYPE;
		    }
		    break;

		case 'T':
		case 't':
		    if (CompareType(cp, STR_TELNET_URL, LEN_TELNET_URL)) {
			result = TELNET_URL_TYPE;

		    } else if (CompareType(cp, STR_TN3270_URL, LEN_TN3270_URL)) {
			result = TN3270_URL_TYPE;
		    }
		    break;

		case 'R':
		case 'r':
		    if (CompareType(cp, STR_RLOGIN_URL, LEN_RLOGIN_URL)) {
			result = RLOGIN_URL_TYPE;
		    }
		    break;

		case 'C':
		case 'c':
		    if (CompareType(cp, STR_CSO_URL, LEN_CSO_URL)) {
			result = CSO_URL_TYPE;
		    }
		    break;

		case 'A':
		case 'a':
		    if (CompareType(cp, "afs:", 4)) {
			result = AFS_URL_TYPE;
		    }
		    break;

		case 'P':
		case 'p':
		    if (CompareType(cp, "prospero:", 9)) {
			result = PROSPERO_URL_TYPE;
		    }
		    break;
		}
	    }
	}
	/*
	 * Check if it is an unknown scheme for which proxying has been set up.
	 */
	if (result == NOT_A_URL_TYPE)
	    result = LYCheckForProxyURL(filename);
    }
    return result;
}

/*
 * Sometimes it is just expected that curses is on when an alert or other
 * statusline message needs to be shown and we are not just dumping
 * immediately.  Calling this will 'fix' it, but may not always be appropriate. 
 * - kw
 */
void LYFixCursesOn(const char *reason)
{
    if (dump_output_immediately || LYCursesON)
	return;
    if (reason) {
	CTRACE((tfp, "Forcing curses on to %s\n", reason));
    }
    start_curses();
}

/*
 * Most protocol modules called through HTLoad* expect that curses is on unless
 * dump_output_immediately is set, so that statusline messages can be shown. 
 * Some protocols expect the opposite, namely telnet and friends.  This
 * function should be called after the 'physical' URL for accessing addr has
 * been established.  It does the right thing to the degree that curses is
 * turned on for known problem cases.  In any normal circumstances this should
 * never apply, but proxying or rule substitution is not prevented for
 * telnet-like URLs, and this 'fix' avoids some crashes that can otherwise
 * occur.  - kw
 */
BOOLEAN LYFixCursesOnForAccess(const char *addr,
			       const char *physical)
{
    /*
     * If curses is off when maybe it shouldn't...
     */
    if (!dump_output_immediately && !LYCursesON && physical) {
	char *cp1;

	/*
	 * If requested resource wants to be accessed with curses off, and
	 * getfile() would indeed have turned curses off for it...
	 */
	if (strstr(addr, "://") != NULL &&
	    (isTELNET_URL(addr) ||
	     isRLOGIN_URL(addr) ||
	     isTN3270_URL(addr) ||
	     (!isGOPHER_URL(addr) &&
	      (cp1 = StrChr(addr + 11, '/')) != NULL &&
	      (*(cp1 + 1) == 'T' || *(cp1 + 1) == '8')))) {
	    /*
	     * If actual access that will be done is ok with curses off, then
	     * do nothing special, else force curses on.  - kw
	     */
	    if (!isTELNET_URL(physical) &&
		!isRLOGIN_URL(physical) &&
		!isTN3270_URL(physical)) {
		start_curses();
		HTAlert(gettext("Unexpected access protocol for this URL scheme."));
		return TRUE;
	    }
	}
    }
    return FALSE;
}

/*
 * Determine whether we allow HEAD and related flags for a URL.  - kw
 */
BOOLEAN LYCanDoHEAD(const char *address)
{
    char *temp0 = NULL;
    int isurl;

    if (!non_empty(address))
	return FALSE;
    if (!StrNCmp(address, "http", 4))
	return TRUE;
    /* Make copy for is_url() since caller may not care for case changes */
    StrAllocCopy(temp0, address);
    isurl = is_url(temp0);
    if (!isurl) {
	FREE(temp0);
	return FALSE;
    }
    if (isurl == LYNXCGI_URL_TYPE) {
	FREE(temp0);
#if defined(LYNXCGI_LINKS) && !defined(VMS)
	return TRUE;
#else
	return FALSE;
#endif
    }
    /*
     * The idea of the following is to allow HEAD for news URLs that identify
     * single articles, not those that identify ranges of articles or groups or
     * a list of groups.  - kw
     */
    if (isurl == NEWS_URL_TYPE || isurl == NNTP_URL_TYPE) {
	char *temp = HTParse(address, "", PARSE_PATH);
	char *cp = strrchr(temp, '/');

	if (StrChr((cp ? cp : temp), '@@') != NULL) {
	    FREE(temp0);
	    FREE(temp);
	    return TRUE;
	}
	if (cp && isdigit(UCH(cp[1])) && StrChr(cp, '-') == NULL) {
	    FREE(temp0);
	    FREE(temp);
	    return TRUE;
	}
	FREE(temp);
    }
#define ALLOW_PROXY_HEAD
/* If defined, also allow head requests for URLs proxied through the "http" or
 * "lynxcgi" protocols, which understand HEAD.  Only the proxy environment
 * variables are checked, not the HTRules system.  - kw
 */
#ifdef ALLOW_PROXY_HEAD
    if (isurl != FILE_URL_TYPE) {
	char *acc_method = HTParse(temp0, "", PARSE_ACCESS);

	if (non_empty(acc_method)) {
	    char *proxy;

	    StrAllocCat(acc_method, "_proxy");
	    proxy = LYGetEnv(acc_method);
	    if (proxy && (isHTTP_URL(proxy) ||
			  isLYNXCGI(proxy)) &&
		!override_proxy(temp0)) {
		FREE(temp0);
		FREE(acc_method);
		return TRUE;
	    }
	}
	FREE(acc_method);
    }
#endif /* ALLOW_PROXY_HEAD */

    FREE(temp0);
    return FALSE;
}

/*
 * Close an input file.
 */
BOOLEAN LYCloseInput(FILE *fp)
{
    int result = FALSE;

    if (fp != 0) {
	int err = ferror(fp);
	LY_TEMP *p = FindTempfileByFP(fp);

	fclose(fp);
	if (p != 0) {
	    p->file = 0;
	}
	if (!err) {
	    result = TRUE;
	}
    }
    return (BOOLEAN) result;
}

/*
 * Close an output file, reporting any problems with writing to it.
 */
BOOLEAN LYCloseOutput(FILE *fp)
{
    int result = FALSE;

    if (fp != 0) {
	int err = ferror(fp);
	LY_TEMP *p = FindTempfileByFP(fp);

	fclose(fp);
	if (p != 0) {
	    p->file = 0;
	}
	if (!err) {
	    result = TRUE;
	}
    }
    if (!result) {
	HTAlert(CANNOT_WRITE_TO_FILE);
    }
    return (BOOLEAN) result;
}

/*
 * Test if we'll be able to write a file.  If not, warn the user.
 */
BOOLEAN LYCanWriteFile(const char *filename)
{
    BOOLEAN result = FALSE;

    if (LYCloseOutput(fopen(filename, "w"))) {
	if (remove(filename) == 0) {
	    result = TRUE;
	}
    } else {
	_statusline(NEW_FILENAME_PROMPT);
    }
    return result;
}

/*
 * Test if we'll be able to read a file.
 */
BOOLEAN LYCanReadFile(const char *filename)
{
    FILE *fp;
    BOOLEAN result = FALSE;

    if (non_empty(filename)) {
	if ((fp = fopen(filename, "r")) != 0) {
	    result = LYCloseInput(fp);
	}
    }
    return result;
}

char *LYFindConfigFile(const char *nominal, const char *dftfile)
{
    char *result = 0;
    char *path = 0;
    char *head = 0;
    char *leaf;
    char *item;

    if (non_empty(nominal)) {
	StrAllocCopy(result, nominal);

	/*
	 * Look for it in as-is - first expanding any tilde.
	 */
	LYTildeExpand(&result, TRUE);
	if (!LYCanReadFile(result)) {
	    const char *cfg_path;
	    char *list = 0;
	    BOOLEAN found = FALSE;

	    /*
	     * Now try in the config-path.
	     */
	    if ((cfg_path = LYGetEnv("LYNX_CFG_PATH")) == NULL)
		cfg_path = LYNX_CFG_PATH;

	    StrAllocCopy(list, cfg_path);
	    path = list;
	    while ((item = LYstrsep(&path, PATH_SEPARATOR)) != 0) {
		if (isEmpty(item))
		    continue;
		FREE(result);
		HTSprintf0(&result, "%s%s%s", item, FILE_SEPARATOR, nominal);
		LYTildeExpand(&result, TRUE);
		if (LYCanReadFile(result)) {
		    found = TRUE;
		    break;
		}
	    }
	    FREE(list);

	    if (!found) {
		/*
		 * If not found, try finding it in the same directory as the
		 * compiled-in location of the default file.
		 */
		StrAllocCopy(head, dftfile);
		if (strcmp(nominal, dftfile) &&
		    (leaf = LYPathLeaf(head)) != head) {

		    head[leaf - head] = '\0';
		    StrAllocCopy(result, head);
		    StrAllocCat(result, nominal);

		    if (!LYCanReadFile(result)) {
			FREE(result);
		    }
		}
#ifdef USE_PROGRAM_DIR
		else {
		    /*
		     * Finally, try in the same directory as the executable.
		     */
		    StrAllocCopy(result, program_dir);
		    LYAddPathSep(&result);
		    StrAllocCat(result, nominal);
		    LYTildeExpand(&result, TRUE);
		    if (!LYCanReadFile(result)) {
			FREE(result);
		    }
		}
#endif
	    }
	}

    }
    FREE(head);
    return result;
}

/*
 * Remove backslashes from any string.
 */
void remove_backslashes(char *buf)
{
    char *cp;

    for (cp = buf; *cp != '\0'; cp++) {

	if (*cp != '\\') {	/* don't print slashes */
	    *buf = *cp;
	    buf++;
	} else if (*cp == '\\' &&	/* print one slash if there */
		   *(cp + 1) == '\\') {		/* are two in a row         */
	    *buf = *cp;
	    buf++;
	}
    }
    *buf = '\0';
    return;
}

/*
 * Checks to see if the current process is attached via a terminal in the local
 * domain.
 */
BOOLEAN inlocaldomain(void)
{
    BOOLEAN result = TRUE;

#ifdef HAVE_UTMP
    int n;
    FILE *fp;
    struct utmp me;
    char *cp, *mytty = NULL;

    if ((cp = ttyname(0)))
	mytty = LYLastPathSep(cp);

    result = FALSE;
    if (mytty && (fp = fopen(UTMP_FILE, "r")) != NULL) {
	mytty++;
	do {
	    n = (int) fread((char *) &me, sizeof(struct utmp), (size_t) 1, fp);
	} while (n > 0 && !STREQ(me.ut_line, mytty));
	(void) LYCloseInput(fp);

	if (n > 0) {
	    if (strlen(me.ut_host) > strlen(LYLocalDomain) &&
		STREQ(LYLocalDomain,
		      me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain))) {
		result = TRUE;
	    }
#ifdef LINUX
	    /* Linux fix to check for local user. J.Cullen 11Jul94              */
	    else if (strlen(me.ut_host) == 0) {
		result = TRUE;
	    }
#endif /* LINUX */
	}

    } else {
	CTRACE((tfp,
		"Could not get ttyname (returned %s) or open UTMP file %s\n",
		NONNULL(cp), UTMP_FILE));
    }
#else
    CTRACE((tfp, "LYUtils: inlocaldomain() not supported.\n"));
#endif /* HAVE_UTMP */
    return (result);
}

#ifdef HAVE_SIGACTION
/*
 * An extended alternative for calling signal(), sets some flags for signal
 * handler as we want them if that functionality is available.  (We don't
 * return anything from this function since the return value would currently be
 * ignored anyway.) - kw
 */
void LYExtSignal(int sig,
		 LYSigHandlerFunc_t *handler)
{
#ifdef SIGWINCH
    /* add more cases to if(condition) if required... */
    if (sig == SIGWINCH && LYNonRestartingSIGWINCH) {
	struct sigaction act;

	act.sa_handler = handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	sigaction(sig, &act, NULL);
    } else
#endif /* defined(SIGWINCH) */
	signal(sig, handler);
}
#endif /* HAVE_SIGACTION */

#if defined(SIGTSTP) && !defined(USE_SLANG)
#ifdef HAVE_SIGACTION
/*
 * For switching a signal's handling between SIG_DFL and something (possibly)
 * different that may have been set up by lynx code or e.g. by curses library. 
 * Uses sigaction to preserve / restore as much state as possible.
 *
 * Second arg is where to save or restore from.
 *
 * Third arg to_dfl specifies what to do:
 *	1	Save current state in where, set handling to SIG_DFL
 *	0	Restore current state to previously saved one in where
 *
 * Currently only used for SIGTSTP without SLANG, to prevent (n)curses signal
 * handler from running while lynx is waiting in system() for an interactive
 * command like an editor.  - kw
 */
static BOOLEAN LYToggleSigDfl(int sig,
			      struct sigaction *where,
			      int to_dfl)
{
    int rv = -1;
    struct sigaction oact;

    if (to_dfl == 1) {
	rv = sigaction(sig, NULL, &oact);
	if (rv == 0) {
	    if (oact.sa_handler != SIG_DFL) {
		oact.sa_handler = SIG_DFL;
		rv = sigaction(sig, &oact, where);
	    } else if (where) {
		memcpy(where, &oact, sizeof(oact));
		rv = 0;
	    }
	}
    } else {
	rv = sigaction(sig, where, NULL);
    }
    if (rv != 0) {
	CTRACE((tfp, "Error in LYToggleSigDfl: %s\n", LYStrerror(errno)));
	return FALSE;
    } else
	return TRUE;
}
#endif /* HAVE_SIGACTION */
#endif /* SIGTSTP && !USE_SLANG */

/**************
 * This bit of code catches window size change signals
 */

#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

/* For systems that have both, but both can't be included, duh (or neither) */
/* FIXME: this whole chunk may be redundant */
#ifdef TERMIO_AND_CURSES
# ifdef TERMIO_AND_TERMIOS
#  include <termio.h>
# else
#  ifdef HAVE_TERMIOS_H
#   include <termios.h>
#  else
#   ifdef HAVE_TERMIO_H
#    include <termio.h>
#   endif /* HAVE_TERMIO_H */
#  endif /* HAVE_TERMIOS_H */
# endif	/* TERMIO_AND_TERMIOS */
#endif /* TERMIO_AND_CURSES */

void size_change(int sig GCC_UNUSED)
{
    int old_lines = LYlines;
    int old_cols = LYcols;

#ifdef USE_SLANG
#if defined(VMS) || defined(UNIX)
    SLtt_get_screen_size();
#endif /* VMS || UNIX */
    LYlines = SLtt_Screen_Rows;
    LYcols = SLtt_Screen_Cols;
#ifdef SLANG_MBCS_HACK
    PHYSICAL_SLtt_Screen_Cols = LYcols;
#ifdef SLANG_NO_LIMIT		/* define this if slang has been fixed */
    SLtt_Screen_Cols = LYcolLimit * 6;
#else
    /* Needs to be limited: fixed buffer bugs in slang can cause crash,
       see slang's SLtt_smart_puts - kw */
    SLtt_Screen_Cols = HTMIN(LYcolLimit * 6, 255);
#endif
#endif /* SLANG_MBCS_HACK */
    if (sig == 0)
	/*
	 * Called from start_curses().
	 */
	return;
#else /* Curses: */
#ifdef HAVE_SIZECHANGE
#ifdef TIOCGSIZE
    struct ttysize win;

#else
#ifdef TIOCGWINSZ
    struct winsize win;
#endif /* TIOCGWINSZ */
#endif /* TIOCGSIZE */

#ifdef TIOCGSIZE
    if (ioctl(0, TIOCGSIZE, &win) == 0) {
	if (win.ts_lines != 0) {
	    LYlines = win.ts_lines;
	}
	if (win.ts_cols != 0) {
	    LYcols = win.ts_cols;
	}
    }
#else
#ifdef TIOCGWINSZ
    if (ioctl(0, (long) TIOCGWINSZ, &win) == 0) {
	if (win.ws_row != 0) {
	    LYlines = win.ws_row;
	}
	if (win.ws_col != 0) {
	    LYcols = win.ws_col;
	}
    }
#endif /* TIOCGWINSZ */
#endif /* TIOCGSIZE */
#endif /* HAVE_SIZECHANGE */

#ifdef __EMX__
    {
	int scrsize[2];

	_scrsize(scrsize);
	LYcols = scrsize[0];
	LYlines = scrsize[1];
    }
#endif

    if (LYlines <= 0)
	LYlines = DFT_ROWS;
    if (LYcols <= 0)
	LYcols = DFT_COLS;
#endif /* USE_SLANG */

    /*
     * Check if the screen size has actually changed.  - AJL
     */
    if (LYlines != old_lines || LYcols != old_cols) {
	recent_sizechange = TRUE;
	CTRACE((tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols));
#if defined(CAN_SWITCH_DISPLAY_CHARSET) && defined(CAN_AUTODETECT_DISPLAY_CHARSET)
	/* May need to reload the font due to different char-box size */
	if (current_char_set != auto_display_charset)
	    Switch_Display_Charset(current_char_set, SWITCH_DISPLAY_CHARSET_RESIZE);
#endif
    }
#ifdef SIGWINCH
    LYExtSignal(SIGWINCH, size_change);
#endif /* SIGWINCH */

    return;
}

/*
 * Utility for freeing the list of previous suggested filenames.  - FM
 */
void HTSugFilenames_free(void)
{
    LYFreeStringList(sug_filenames);
    sug_filenames = NULL;
}

/*
 * Utility for listing suggested filenames, making any repeated filenames the
 * most current in the list.  - FM
 */
void HTAddSugFilename(char *fname)
{
    char *tmp = NULL;
    char *old;
    HTList *cur;

    if (!non_empty(fname))
	return;

    StrAllocCopy(tmp, fname);

    if (!sug_filenames) {
	sug_filenames = HTList_new();
#ifdef LY_FIND_LEAKS
	atexit(HTSugFilenames_free);
#endif
	HTList_addObject(sug_filenames, tmp);
	return;
    }

    cur = sug_filenames;
    while (NULL != (old = (char *) HTList_nextObject(cur))) {
	if (!strcmp(old, tmp)) {
	    HTList_removeObject(sug_filenames, old);
	    FREE(old);
	    break;
	}
    }
    HTList_addObject(sug_filenames, tmp);

    return;
}

/*
 * CHANGE_SUG_FILENAME -- Foteos Macrides 29-Dec-1993 Upgraded for use with
 * Lynx2.2 - FM 17-Jan-1994
 */
void change_sug_filename(char *fname)
{
    const char *cp2;
    char *temp = 0, *cp, *cp1, *end;

#ifdef VMS
    char *dot;
    int j, k;
#endif /* VMS */

    /*
     * Establish the current end of fname.
     */
    end = fname + strlen(fname);

    /*
     * Unescape fname.
     */
    HTUnEscape(fname);

    /*
     * Rename any temporary files.
     */
    cp2 = wwwName(lynx_temp_space);
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s" PID_FMT, cp2, GETPID());
    } else {
	HTSprintf0(&temp, "file://localhost/%s" PID_FMT, cp2, GETPID());
    }
    if (!StrNCmp(fname, temp, strlen(temp))) {
	if ((cp = strrchr(fname, '.')) != 0) {
	    if (strlen(cp) > (strlen(temp) - 4))
		cp = NULL;
	}
	StrAllocCopy(temp, NonNull(cp));
	sprintf(fname, "temp%.*s", LY_MAXPATH - 10, temp);
    }
    FREE(temp);

    if (fname[strlen(fname) - 1] == '/')
	/*
	 * Hmm...  we have a directory name.  It is annoying to see a
	 * scheme+host+path name as a suggested one, let's remove the
	 * last_slash and go ahead like we have a file name.  - LP
	 */
	fname[strlen(fname) - 1] = '\0';

    /*
     * Remove everything up the the last_slash if there is one.
     */
    if ((cp = strrchr(fname, '/')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 * Go past the slash.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#ifdef _WINDOWS			/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname, '=')) != NULL && strlen(cp) > 1) {
	cp1 = fname;
	/*
	 * Go past the '='.
	 */
	cp++;
	for (; *cp != '\0'; cp++, cp1++) {
	    *cp1 = *cp;
	}
	*cp1 = '\0';
    }
#endif

    /*
     * Trim off date-size suffix, if present.
     */
    if ((*(end - 1) == ']') && ((cp = strrchr(fname, '[')) != NULL) &&
	(cp > fname) && *(--cp) == ' ') {
	while (*cp == ' ') {
	    *(cp--) = '\0';
	}
    }
#ifdef VMS
    /*
     * Trim off VMS device and/or directory specs, if present.
     */
    if ((cp = StrChr(fname, '[')) != NULL &&
	(cp1 = strrchr(cp, ']')) != NULL && strlen(cp1) > 1) {
	cp1++;
	for (cp = fname; *cp1 != '\0'; cp1++) {
	    *(cp++) = *cp1;
	}
	*cp = '\0';
    }
    /*
     * Replace illegal or problem characters.
     */
    dot = fname + strlen(fname);
    for (cp = fname; cp < dot; cp++) {
	/*
	 * Replace with underscores.
	 */
	if (*cp == ' ' || *cp == '/' || *cp == ':' ||
	    *cp == '[' || *cp == ']' || *cp == '&') {
	    *cp = '_';
	    /*
	     * Replace with dashes.
	     */
	} else if (*cp == '!' || *cp == '?' || *cp == '\'' ||
		   *cp == ',' || *cp == ':' || *cp == '"' ||
		   *cp == '+' || *cp == '@@' || *cp == '\\' ||
		   *cp == '(' || *cp == ')' || *cp == '=' ||
		   *cp == '<' || *cp == '>' || *cp == '#' ||
		   *cp == '%' || *cp == '*' || *cp == '`' ||
		   *cp == '~' || *cp == '^' || *cp == '|' ||
		   *cp < ' ' || (UCH(*cp)) > 126) {
	    *cp = '-';
	}
    }

    /*
     * Collapse any serial underscores.
     */
    cp = fname + 1;
    j = 0;
    while (cp < dot) {
	if (fname[j] == '_' && *cp == '_') {
	    cp++;
	} else {
	    fname[++j] = *cp++;
	}
    }
    fname[++j] = '\0';

    /*
     * Collapse any serial dashes.
     */
    dot = fname + (strlen(fname));
    cp = fname + 1;
    j = 0;
    while (cp < dot) {
	if (fname[j] == '-' && *cp == '-') {
	    cp++;
	} else {
	    fname[++j] = *cp++;
	}
    }
    fname[++j] = '\0';

    /*
     * Trim any trailing or leading underscores or dashes.
     */
    cp = fname + (strlen(fname)) - 1;
    while (*cp == '_' || *cp == '-') {
	*cp-- = '\0';
    }
    if (fname[0] == '_' || fname[0] == '-') {
	dot = fname + (strlen(fname));
	cp = fname;
	while ((*cp == '_' || *cp == '-') && cp < dot) {
	    cp++;
	}
	j = 0;
	while (cp < dot) {
	    fname[j++] = *cp++;
	}
	fname[j] = '\0';
    }

    /*
     * Replace all but the last period with _'s, or second to last if last is
     * followed by a terminal Z or z, or GZ or gz,
     * e.g., convert foo.tar.Z to foo.tar_Z
     * or, convert foo.tar.gz to foo.tar-gz
     */
    j = strlen(fname) - 1;
    if ((dot = strrchr(fname, '.')) != NULL) {
	if (TOUPPER(fname[j]) == 'Z') {
	    if ((fname[j - 1] == '.') &&
		(((cp = StrChr(fname, '.')) != NULL) && cp < dot)) {
		*dot = '_';
		dot = strrchr(fname, '.');
	    } else if (((TOUPPER(fname[j - 1]) == 'G') &&
			fname[j - 2] == '.') &&
		       (((cp = StrChr(fname, '.')) != NULL) && cp < dot)) {
		*dot = '-';
		dot = strrchr(fname, '.');
	    }
	}
	cp = fname;
	while ((cp = StrChr(cp, '.')) != NULL && cp < dot) {
	    *cp = '_';
	}

	/*
	 * But if the root is > 39 characters, move the period appropriately to
	 * the left.
	 */
	while (dot - fname > 39) {
	    *dot = '\0';
	    if ((cp = strrchr(fname, '_')) != NULL) {
		*cp = '.';
		*dot = '_';
	    } else if ((cp = strrchr(fname, '-')) != NULL) {
		*cp = '.';
		*dot = '_';
	    } else if (*(dot + 1) == '\0') {
		j = strlen(fname);
		while (j > 39) {
		    fname[j] = fname[j - 1];
		    j--;
		}
		fname[j] = '.';
	    } else {
		*dot = '.';
		j = 39;
		k = 0;
		while (dot[k] != '\0') {
		    fname[j++] = dot[k++];
		}
		fname[j] = '\0';
	    }
	    dot = strrchr(fname, '.');
	}

	/*
	 * Make sure the extension is < 40 characters.
	 */
	if ((fname + strlen(fname) - dot) > 39) {
	    *(dot + 40) = '\0';
	}

	/*
	 * Trim trailing dashes or underscores.
	 */
	j = (strlen(fname) - 1);
	while (fname[j] == '_' || fname[j] == '-') {
	    fname[j--] = '\0';
	}
    } else {
	/*
	 * No period, so put one on the end, or after the 39th character,
	 * trimming trailing dashes or underscores.
	 */
	if (strlen(fname) > 39) {
	    fname[39] = '\0';
	}
	j = (strlen(fname) - 1);
	while ((fname[j] == '_') || (fname[j] == '-')) {
	    j--;
	}
	fname[++j] = '.';
	fname[++j] = '\0';
    }

#else /* Not VMS (UNIX): */

    /*
     * Replace problem characters.
     */
    for (cp = fname; *cp != '\0'; cp++) {
	switch (*cp) {
	case '\'':
	case '"':
	case '/':
	case ' ':
	    *cp = '-';
	}
    }
#endif /* VMS (UNIX) */

    /*
     * Make sure the rest of the original string in nulled.
     */
    cp = fname + strlen(fname);
    while (cp < end) {
	*cp++ = '\0';
    }

    return;
}

/*
 * Construct a temporary-filename.  Assumes result is LY_MAXPATH chars long.
 */
static int fmt_tempname(char *result,
			const char *prefix,
			const char *suffix)
{
    int code;

#ifdef HAVE_RAND_TEMPNAME
#define SIZE_TEMPNAME ((MAX_TEMPNAME / BITS_PER_CHAR) + 1)
    static BOOL first = TRUE;
    static int names_used = 0;
    static unsigned char used_tempname[SIZE_TEMPNAME];
    unsigned offset, mask;
#endif
    static unsigned counter;
    char leaf[LY_MAXPATH];

    if (prefix == 0)
	prefix = "";
    if (suffix == 0)
	suffix = "";
    /*
     * Prefer a random value rather than a counter.
     */
#ifdef HAVE_RAND_TEMPNAME
    if (first) {
	lynx_srand((unsigned) ((long) time((time_t *) NULL) + (long) result));
	first = FALSE;
    }

    /* We don't really need all of the bits from rand().  The high-order bits
     * are the more-random portion in any case, but limiting the width of the
     * generated name is done partly to avoid problems on systems that may not
     * support long filenames.
     */
    counter = MAX_TEMPNAME;
    if (names_used < MAX_TEMPNAME) {
	long get_rand = lynx_rand();
	long max_rand = LYNX_RAND_MAX;

	counter = (unsigned) (((float) MAX_TEMPNAME * (float) get_rand) /
			      (float) max_rand + 1);
	/*
	 * Avoid reusing a temporary name, since there are places in the code
	 * which can refer to a temporary filename even after it has been
	 * closed and removed from the filesystem.
	 */
	do {
	    counter %= MAX_TEMPNAME;
	    offset = counter / BITS_PER_CHAR;
	    mask = (unsigned) (1 << (counter % BITS_PER_CHAR));
	    if ((used_tempname[offset] & mask) == 0) {
		names_used++;
		used_tempname[offset] |= UCH(mask);
		break;
	    }
	} while ((used_tempname[offset] & mask) == 0);
    }
    if (names_used >= MAX_TEMPNAME)
	HTAlert(gettext("Too many tempfiles"));
#else
    counter++;
#endif

#ifdef FNAMES_8_3
    /*
     * The 'lynx_temp_space' string ends with a '/' or '\\', so we only have to
     * limit the length of the leaf.  As received (e.g., from HTCompressed),
     * the suffix may contain more than a ".htm", e.g., "-txt.gz", so we trim
     * off from the filename portion to make room.
     */
    sprintf(leaf, PID_FMT PID_FMT, counter, GETPID());
    if (strlen(leaf) > 8)
	leaf[8] = 0;
    if (strlen(suffix) > 4 || *suffix != '.') {
	const char *tail = StrChr(suffix, '.');

	if (tail == 0)
	    tail = suffix + strlen(suffix);
	if (8 - (tail - suffix) >= 0)
	    leaf[8 - (tail - suffix)] = 0;
    }
    strcat(leaf, suffix);
#else
    sprintf(leaf, "L" PID_FMT "-%uTMP%s", GETPID(), counter, suffix);
#endif
    /*
     * Someone could have configured the temporary pathname to be too long.
     */
    if ((strlen(prefix) + strlen(leaf)) < LY_MAXPATH) {
	sprintf(result, "%s%s", prefix, leaf);
	code = TRUE;
    } else {
	sprintf(result, "%.*s", LY_MAXPATH - 1, leaf);
	code = FALSE;
    }
    CTRACE((tfp, "-> '%s'\n", result));
    return (code);
}

/*
 * Convert 4, 6, 2, 8 to left, right, down, up, etc.
 */
int number2arrows(int number)
{
    switch (number) {
    case '1':
	number = END_KEY;
	break;
    case '2':
	number = DNARROW_KEY;
	break;
    case '3':
	number = PGDOWN_KEY;
	break;
    case '4':
	number = LTARROW_KEY;
	break;
    case '5':
	number = DO_NOTHING;
	break;
    case '6':
	number = RTARROW_KEY;
	break;
    case '7':
	number = HOME_KEY;
	break;
    case '8':
	number = UPARROW_KEY;
	break;
    case '9':
	number = PGUP_KEY;
	break;
    }

    return (number);
}

/*
 * parse_restrictions takes a string of comma-separated restrictions and sets
 * the corresponding flags to restrict the facilities available.
 */
/* The first two are special:  we want to record whether "default" or "all"
 * restrictions were applied, in addition to the detailed effects of those
 * options.  - kw
 */
/* skip the special flags when processing "all" and "default": */
#define N_SPECIAL_RESTRICT_OPTIONS 2
/* *INDENT-OFF* */
static const struct {
    const char *name;
    BOOLEAN *flag;
    BOOLEAN can;
} restrictions[] = {
    { "default",	&had_restrictions_default, TRUE },
    { "all",		&had_restrictions_all,	TRUE },
    { "inside_telnet",	&no_inside_telnet,	CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET },
    { "outside_telnet",	&no_outside_telnet,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET },
    { "telnet_port",	&no_telnet_port,	CAN_ANONYMOUS_GOTO_TELNET_PORT },
    { "inside_ftp",	&no_inside_ftp,		CAN_ANONYMOUS_INSIDE_DOMAIN_FTP },
    { "outside_ftp",	&no_outside_ftp,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP },
    { "inside_rlogin",	&no_inside_rlogin,	CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN },
    { "outside_rlogin",	&no_outside_rlogin,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN },
    { "suspend",	&no_suspend,		FALSE },
    { "editor",		&no_editor,		FALSE },
    { "shell",		&no_shell,		FALSE },
    { "bookmark",	&no_bookmark,		FALSE },
    { "multibook",	&no_multibook,		FALSE },
    { "bookmark_exec",	&no_bookmark_exec,	FALSE },
    { "option_save",	&no_option_save,	FALSE },
    { "print",		&no_print,		CAN_ANONYMOUS_PRINT },
    { "download",	&no_download,		FALSE },
    { "disk_save",	&no_disk_save,		FALSE },
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
    { "exec",		&no_exec,		LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS },
#endif
    { "lynxcgi",	&no_lynxcgi,		FALSE },
    { "exec_frozen",	&exec_frozen,		FALSE },
    { "goto",		&no_goto,		CAN_ANONYMOUS_GOTO },
    { "jump",		&no_jump,		CAN_ANONYMOUS_JUMP },
    { "file_url",	&no_file_url,		FALSE },
#ifndef DISABLE_NEWS
    { "news_post",	&no_newspost,		FALSE },
    { "inside_news",	&no_inside_news,	CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS },
    { "outside_news",	&no_outside_news,	CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS },
#endif
    { "mail",		&no_mail,		CAN_ANONYMOUS_MAIL },
    { "dotfiles",	&no_dotfiles,		FALSE },
    { "useragent",	&no_useragent,		FALSE },
#ifdef SUPPORT_CHDIR
    { "chdir",		&no_chdir,		FALSE },
#endif
#ifdef DIRED_SUPPORT
    { "dired_support",	&no_dired_support,	FALSE },
#ifdef OK_PERMIT
    { "change_exec_perms", &no_change_exec_perms, FALSE },
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
#ifdef USE_EXTERNALS
    { "externals",	&no_externals,		FALSE },
#endif
    { "lynxcfg_info",	&no_lynxcfg_info,	CAN_ANONYMOUS_VIEW_LYNXCFG_INFO },
#ifndef NO_CONFIG_INFO
    { "lynxcfg_xinfo",	&no_lynxcfg_xinfo,	CAN_ANONYMOUS_VIEW_LYNXCFG_EXTENDED_INFO },
#ifdef HAVE_CONFIG_H
    { "compileopts_info", &no_compileopts_info,	CAN_ANONYMOUS_VIEW_COMPILEOPTS_INFO },
#endif
#endif
    /* put "goto" restrictions on the end, since they are a refinement */
#ifndef DISABLE_BIBP
    { "goto_bibp",	&no_goto_bibp,		CAN_ANONYMOUS_GOTO_BIBP	},
#endif
#ifdef HAVE_CONFIG_H
#ifndef NO_CONFIG_INFO
    { "goto_configinfo", &no_goto_configinfo,	CAN_ANONYMOUS_GOTO_CONFIGINFO },
#endif
#endif
    { "goto_cso",	&no_goto_cso,		CAN_ANONYMOUS_GOTO_CSO },
    { "goto_file",	&no_goto_file,		CAN_ANONYMOUS_GOTO_FILE },
#ifndef DISABLE_FINGER
    { "goto_finger",	&no_goto_finger,	CAN_ANONYMOUS_GOTO_FINGER },
#endif
    { "goto_ftp",	&no_goto_ftp,		CAN_ANONYMOUS_GOTO_FTP },
#ifndef DISABLE_GOPHER
    { "goto_gopher",	&no_goto_gopher,	CAN_ANONYMOUS_GOTO_GOPHER },
#endif
    { "goto_http",	&no_goto_http,		CAN_ANONYMOUS_GOTO_HTTP },
    { "goto_https",	&no_goto_https,		CAN_ANONYMOUS_GOTO_HTTPS },
    { "goto_lynxcgi",	&no_goto_lynxcgi,	CAN_ANONYMOUS_GOTO_LYNXCGI },
    { "goto_lynxexec",	&no_goto_lynxexec,	CAN_ANONYMOUS_GOTO_LYNXEXEC },
    { "goto_lynxprog",	&no_goto_lynxprog,	CAN_ANONYMOUS_GOTO_LYNXPROG },
    { "goto_mailto",	&no_goto_mailto,	CAN_ANONYMOUS_GOTO_MAILTO },
#ifndef DISABLE_NEWS
    { "goto_news",	&no_goto_news,		CAN_ANONYMOUS_GOTO_NEWS },
    { "goto_nntp",	&no_goto_nntp,		CAN_ANONYMOUS_GOTO_NNTP },
#endif
    { "goto_rlogin",	&no_goto_rlogin,	CAN_ANONYMOUS_GOTO_RLOGIN },
#ifndef DISABLE_NEWS
    { "goto_snews",	&no_goto_snews,		CAN_ANONYMOUS_GOTO_SNEWS },
#endif
    { "goto_telnet",	&no_goto_telnet,	CAN_ANONYMOUS_GOTO_TELNET },
    { "goto_tn3270",	&no_goto_tn3270,	CAN_ANONYMOUS_GOTO_TN3270 },
    { "goto_wais",	&no_goto_wais,		CAN_ANONYMOUS_GOTO_WAIS },
};
/* *INDENT-ON* */

/* This will make no difference between '-' and '_'.  It does only in/equality
 * compare.  It assumes that p2 can't contain dashes, but p1 can.  This
 * function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have value of
 * zero) for compare of commandline options -VH
 */
BOOL strn_dash_equ(const char *p1,
		   const char *p2,
		   int len)
{
    while (len--) {
	if (!*p2)
	    return 0;		/* canonical name is shorter */
	switch (*p1) {
	case 0:
	    return 0;
	case '-':
	case '_':
	    if (*p2 != '_')
		return 0;
	    else
		break;
	default:
	    if (*p1 != *p2)
		return 0;
	}
	++p1;
	++p2;
    }
    return 1;
}

/* Uncomment following lines to allow only exact string matching */
/* #define RESTRICT_NM_ALLOW_DASHES 0 */

#ifndef RESTRICT_NM_ALLOW_DASHES
# define RESTRICT_NM_ALLOW_DASHES 1
#endif

#if RESTRICT_NM_ALLOW_DASHES
#	define RESTRICT_NM_EQU(a,b,len) strn_dash_equ(a,b,len)
#else
#	define RESTRICT_NM_EQU(a,b,len) STRNEQ(a,b,len)
#endif

/*
 * Returns the inx'th name from the restrictions table, or null if inx is
 * out of range.
 */
const char *index_to_restriction(unsigned inx)
{
    if (inx < TABLESIZE(restrictions))
	return restrictions[inx].name;
    return NULL;
}

/*
 * Returns the value TRUE/FALSE of a given restriction, or -1 if it is not
 * one that we recognize.
 */
int find_restriction(const char *name,
		     int len)
{
    unsigned i;

    if (len < 0)
	len = (int) strlen(name);
    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (RESTRICT_NM_EQU(name, restrictions[i].name, len)) {
	    return (*restrictions[i].flag);
	}
    }
    return -1;
}

void parse_restrictions(const char *s)
{
    const char *p;
    const char *word;
    unsigned i;
    BOOLEAN found;

    p = s;
    while (*p) {
	p = LYSkipCBlanks(p);
	if (*p == '\0')
	    break;
	word = p;
	while (*p != ',' && *p != '\0')
	    p++;

	found = FALSE;
	if (RESTRICT_NM_EQU(word, "all", (int) (p - word))) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
		*(restrictions[i].flag) = TRUE;
	} else if (RESTRICT_NM_EQU(word, "default", (int) (p - word))) {
	    found = TRUE;
	    for (i = N_SPECIAL_RESTRICT_OPTIONS;
		 i < TABLESIZE(restrictions);
		 i++)
		*(restrictions[i].flag) = (BOOLEAN) !restrictions[i].can;
	} else {
	    for (i = 0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, (int) (p - word))) {
		    *(restrictions[i].flag) = TRUE;
		    found = TRUE;
		    break;
		}
	    }
	}
	if (!found) {
	    printf("%s: %.*s\n", gettext("unknown restriction"),
		   (int) (p - word), word);
	    exit_immediately(EXIT_FAILURE);
	}
	if (*p)
	    p++;
    }

    /*
     * If shell is restricted, set restrictions on related topics.
     */
    if (no_shell) {
	no_goto_lynxexec = TRUE;
	no_goto_lynxprog = TRUE;
	no_goto_lynxcgi = TRUE;
#ifdef EXEC_LINKS
	local_exec_on_local_files = TRUE;
#endif
    }
}

void print_restrictions_to_fd(FILE *fp)
{
    unsigned i, count = 0;

    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    count++;
	}
    }
    if (!count) {
	fprintf(fp, gettext("No restrictions set.\n"));
	return;
    }
    fprintf(fp, gettext("Restrictions set:\n"));
    for (i = 0; i < TABLESIZE(restrictions); i++) {
	if (*(restrictions[i].flag) == TRUE) {
	    /* if "goto" is restricted, don't bother tell about its
	     * refinements
	     */
	    if (StrNCmp(restrictions[i].name, "goto_", 5)
		|| !no_goto)
		fprintf(fp, "   %s\n", restrictions[i].name);
	}
    }
}

#ifdef VMS
#include <jpidef.h>
#include <maildef.h>
#include <starlet.h>

typedef struct _VMSMailItemList {
    short buffer_length;
    short item_code;
    void *buffer_address;
    long *return_length_address;
} VMSMailItemList;

void LYCheckMail(void)
{
    static BOOL firsttime = TRUE, failure = FALSE;
    static char user[13], dir[252];
    static long userlen = 0, dirlen;
    static time_t lastcheck = 0;
    time_t now;
    static short new, lastcount;
    long ucontext = 0, status;
    short flags = MAIL$M_NEWMSG;
    /* *INDENT-OFF* */
    VMSMailItemList
      null_list[] = {{0,0,0,0}},
      jpi_list[]  = {{sizeof(user) - 1,JPI$_USERNAME,(void *)user,&userlen},
		     {0,0,0,0}},
      uilist[]	  = {{0,MAIL$_USER_USERNAME,0,0},
		     {0,0,0,0}},
      uolist[]	  = {{sizeof(new),MAIL$_USER_NEW_MESSAGES,&new,0},
		     {sizeof(dir),MAIL$_USER_FULL_DIRECTORY,dir,&dirlen},
		     {0,0,0,0}};
    /* *INDENT-ON* */

    extern long mail$user_begin();
    extern long mail$user_get_info();
    extern long mail$user_end();

    if (failure)
	return;

    if (firsttime) {
	firsttime = FALSE;
	/* Get the username. */
	status = sys$getjpiw(0, 0, 0, jpi_list, 0, 0, 0);
	if (!(status & 1)) {
	    failure = TRUE;
	    return;
	}
	user[userlen] = '\0';
	LYTrimTrailing(user);
    }

    /* Minimum report interval is 60 sec. */
    time(&now);
    if (now - lastcheck < 60)
	return;
    lastcheck = now;

    /* Get the current newmail count. */
    status = mail$user_begin(&ucontext, null_list, null_list);
    if (!(status & 1)) {
	failure = TRUE;
	return;
    }
    uilist[0].buffer_length = strlen(user);
    uilist[0].buffer_address = user;
    status = mail$user_get_info(&ucontext, uilist, uolist);
    if (!(status & 1)) {
	failure = TRUE;
	return;
    }

    /* Should we report anything to the user? */
    if (new > 0) {
	if (lastcount == 0)
	    /* Have newmail at startup of Lynx. */
	    HTUserMsg(HAVE_UNREAD_MAIL_MSG);
	else if (new > lastcount)
	    /* Have additional mail since last report. */
	    HTUserMsg(HAVE_NEW_MAIL_MSG);
	lastcount = new;
	return;
    }
    lastcount = new;

    /* Clear the context */
    mail$user_end((long *) &ucontext, null_list, null_list);
    return;
}
#else
void LYCheckMail(void)
{
    static BOOL firsttime = TRUE;
    static char *mf;
    static time_t lastcheck;
    static time_t lasttime;
    static long lastsize;
    time_t now;
    struct stat st;

    if (firsttime) {
	mf = LYGetEnv("MAIL");
	firsttime = FALSE;
	time(&lasttime);
    }

    if (mf == NULL)
	return;

    time(&now);
    if (now - lastcheck < 60)
	return;
    lastcheck = now;

    if ((stat(mf, &st) < 0)
	|| !S_ISREG(st.st_mode)) {
	mf = NULL;
	return;
    }

    if (st.st_size > 0) {
	if (((lasttime != st.st_mtime) && (st.st_mtime > st.st_atime))
	    || ((lastsize != 0) && (st.st_size > lastsize)))
	    HTUserMsg(HAVE_NEW_MAIL_MSG);
	else if (lastsize == 0)
	    HTUserMsg(HAVE_MAIL_MSG);
    }
    lastsize = (long) st.st_size;
    lasttime = st.st_mtime;
    return;
}
#endif /* VMS */

/*
 *  This function ensures that an href will be
 *  converted to a fully resolved, absolute URL,
 *  with guessing of the host or expansions of
 *  lead tildes via LYConvertToURL() if needed,
 *  and tweaking/simplifying via HTParse().  It
 *  is used for LynxHome, startfile, homepage,
 *  and 'g'oto entries, after they have been
 *  passed to LYFillLocalFileURL(). - FM
 *  Such URLs have no `base' reference to which they
 *  could be resolved.  LYLegitimizeHREF could not be used.
 */
void LYEnsureAbsoluteURL(char **href,
			 const char *name,
			 int fixit)
{
    char *temp = NULL;

    if (isEmpty(*href))
	return;

    /*
     * Check whether to fill in localhost.  - FM
     */
    LYFillLocalFileURL(href, "file://localhost");

    /*
     * If it is not a URL then make it one.
     */
    if (!strcasecomp(*href, STR_NEWS_URL)) {
	StrAllocCat(*href, "*");
    } else if (!strcasecomp(*href, STR_SNEWS_URL)) {
	StrAllocCat(*href, "/*");
    }

    if (!is_url(*href)) {
	CTRACE((tfp, "%s%s'%s' is not a URL\n",
		NonNull(name), (name ? " " : ""), *href));
	LYConvertToURL(href, fixit);
    }

    temp = HTParse(*href, "", PARSE_ALL);
    if (non_empty(temp))
	StrAllocCopy(*href, temp);
    FREE(temp);
}

/*
 * Rewrite and reallocate a previously allocated string as a file URL if the
 * string resolves to a file or directory on the local system, otherwise as an
 * http URL.  - FM
 */
void LYConvertToURL(char **AllocatedString,
		    int fixit)
{
    char *old_string = *AllocatedString;
    char *temp = NULL;
    char *cp = NULL;

#ifndef VMS
    struct stat st;
#endif /* !VMS */

    if (isEmpty(old_string))
	return;

#if defined(USE_DOS_DRIVES)
    {
	char *cp_url = *AllocatedString;

	for (; *cp_url != '\0'; cp_url++)
	    if (*cp_url == '\\')
		*cp_url = '/';
	cp_url--;
	if (LYIsDosDrive(*AllocatedString) && *cp_url == ':')
	    LYAddPathSep(AllocatedString);
    }
#endif /* USE_DOS_DRIVES */

    *AllocatedString = NULL;	/* so StrAllocCopy doesn't free it */
    StrAllocCopy(*AllocatedString, "file://localhost");

    if (*old_string != '/') {
	char *fragment = NULL;

#if defined(USE_DOS_DRIVES)
	StrAllocCat(*AllocatedString, "/");
#endif /* USE_DOS_DRIVES */
#ifdef VMS
	/*
	 * Not a SHELL pathspec.  Get the full VMS spec and convert it.
	 */
	char *cur_dir = NULL;
	static char url_file[LY_MAXPATH], file_name[LY_MAXPATH], dir_name[LY_MAXPATH];
	unsigned long context = 0;

	$DESCRIPTOR(url_file_dsc, url_file);
	$DESCRIPTOR(file_name_dsc, file_name);
	if (LYIsTilde(*old_string)) {
	    /*
	     * On VMS, we'll accept '~' on the command line as Home_Dir(), and
	     * assume the rest of the path, if any, has SHELL syntax.
	     */
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
	    if ((cp = StrChr(old_string, '/')) != NULL) {
		/*
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		StrAllocCopy(temp, cp);
		LYTrimRelFromAbsPath(temp);
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
	    }
	    goto have_VMS_URL;
	} else {
	    fragment = trimPoundSelector(old_string);
	    LYStrNCpy(url_file, old_string, sizeof(url_file) - 1);
	}
	url_file_dsc.dsc$w_length = (short) strlen(url_file);
	if (1 & lib$find_file(&url_file_dsc, &file_name_dsc, &context,
			      0, 0, 0, 0)) {
	    /*
	     * We found the file.  Convert to a URL pathspec.
	     */
	    if ((cp = StrChr(file_name, ';')) != NULL) {
		*cp = '\0';
	    }
	    LYLowerCase(file_name);
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(file_name));
	    if ((cp = StrChr(old_string, ';')) != NULL) {
		StrAllocCat(*AllocatedString, cp);
	    }
	    if (fragment != NULL) {
		restorePoundSelector(fragment);
		StrAllocCat(*AllocatedString, fragment);
		fragment = NULL;
	    }
	} else if ((NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) &&
		   0 == chdir(old_string)) {
	    /*
	     * Probably a directory.  Try converting that.
	     */
	    StrAllocCopy(cur_dir, dir_name);
	    restorePoundSelector(fragment);
	    if (NULL != getcwd(dir_name, sizeof(dir_name) - 1, 0)) {
		/*
		 * Yup, we got it!
		 */
		LYLowerCase(dir_name);
		StrAllocCat(*AllocatedString, dir_name);
		if (fragment != NULL) {
		    StrAllocCat(*AllocatedString, fragment);
		    fragment = NULL;
		}
	    } else {
		/*
		 * Nope.  Assume it's an http URL with the "http://" defaulted,
		 * if we can't rule out a bad VMS path.
		 */
		fragment = NULL;
		if (StrChr(old_string, '[') ||
		    ((cp = StrChr(old_string, ':')) != NULL &&
		     !isdigit(UCH(cp[1]))) ||
		    !LYExpandHostForURL(&old_string,
					URLDomainPrefixes,
					URLDomainSuffixes)) {
		    /*
		     * Probably a bad VMS path (but can't be sure).  Use
		     * original pathspec for the error message that will
		     * result.
		     */
		    sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		    CTRACE((tfp,
			    "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string));
		    StrAllocCat(*AllocatedString, url_file);
		} else {
		    /*
		     * Assume a URL is wanted, so guess the scheme with
		     * "http://" as the default.  - FM
		     */
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
			StrAllocCopy(*AllocatedString, "http://");
			StrAllocCat(*AllocatedString, old_string);
		    } else {
			StrAllocCopy(*AllocatedString, old_string);
		    }
		}
	    }
	} else {
	    /*
	     * Nothing found.  Assume it's an http URL with the "http://"
	     * defaulted, if we can't rule out a bad VMS path.
	     */
	    restorePoundSelector(fragment);
	    fragment = NULL;

	    if (StrChr(old_string, '[') ||
		((cp = StrChr(old_string, ':')) != NULL &&
		 !isdigit(UCH(cp[1]))) ||
		!LYExpandHostForURL(&old_string,
				    URLDomainPrefixes,
				    URLDomainSuffixes)) {
		/*
		 * Probably a bad VMS path (but can't be sure).  Use original
		 * pathspec for the error message that will result.
		 */
		sprintf(url_file, "/%.*s", sizeof(url_file) - 2, old_string);
		CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			old_string));
		StrAllocCat(*AllocatedString, url_file);
	    } else {
		/*
		 * Assume a URL is wanted, so guess the scheme with "http://"
		 * as the default.  - FM
		 */
		if (!LYAddSchemeForURL(&old_string, "http://")) {
		    StrAllocCopy(*AllocatedString, "http://");
		    StrAllocCat(*AllocatedString, old_string);
		} else {
		    StrAllocCopy(*AllocatedString, old_string);
		}
	    }
	}
	lib$find_file_end(&context);
	FREE(cur_dir);
      have_VMS_URL:
	CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
#else /* not VMS: */
#if defined(USE_DOS_DRIVES)
#ifdef _WINDOWS
	if (*old_string == '.') {
	    char fullpath[MAX_PATH + 1];
	    char *filepart = NULL;
	    DWORD chk;

	    chk = GetFullPathNameA(old_string, MAX_PATH + 1,
				   fullpath, &filepart);
	    if (chk != 0) {
		StrAllocCopy(temp, wwwName(fullpath));
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
	    } else {
		StrAllocCat(*AllocatedString, old_string);
	    }
	}
#else
	if (strlen(old_string) == 1 && *old_string == '.') {
	    /*
	     * They want .
	     */
	    char curdir[LY_MAXPATH];

	    StrAllocCopy(temp, wwwName(Current_Dir(curdir)));
	    StrAllocCat(*AllocatedString, temp);
	    FREE(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
	}
#endif
	else
#endif /* USE_DOS_DRIVES */
	if (LYIsTilde(*old_string)) {
	    char *his_home = NULL;

	    StrAllocCopy(his_home, old_string);
	    LYTildeExpand(&his_home, FALSE);
	    StrAllocCat(*AllocatedString, his_home);
	    FREE(his_home);

	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
	} else {
	    /*
	     * Create a full path to the current default directory.
	     */
	    char curdir[LY_MAXPATH];
	    char *temp2 = NULL;
	    BOOL is_local = FALSE;

	    Current_Dir(curdir);
	    /*
	     * Concatenate and simplify, trimming any residual relative
	     * elements.  - FM
	     */
#if defined (USE_DOS_DRIVES)
	    if (old_string[1] != ':' && old_string[1] != '|') {
		StrAllocCopy(temp, wwwName(curdir));
		LYAddHtmlSep(&temp);
		LYStrNCpy(curdir, temp, (sizeof(curdir) - 1));
		StrAllocCat(temp, old_string);
	    } else {
		curdir[0] = '\0';
		/* 1998/01/13 (Tue) 12:24:33 */
		if (old_string[1] == '|')
		    old_string[1] = ':';
		StrAllocCopy(temp, old_string);

		if (strlen(temp) == 2 && LYIsDosDrive(temp))
		    LYAddPathSep(&temp);
	    }
#else
	    StrAllocCopy(temp, curdir);
	    StrAllocCat(temp, "/");
	    StrAllocCat(temp, old_string);
#endif /* USE_DOS_DRIVES */
	    LYTrimRelFromAbsPath(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
	    if ((stat(temp, &st) > -1) ||
		LYCanReadFile(temp)) {
		/*
		 * It is a subdirectory or file on the local system.
		 */
#if defined (USE_DOS_DRIVES)
		/* Don't want to see DOS local paths like c: escaped  */
		/* especially when we really have file://localhost/   */
		/* at the beginning.  To avoid any confusion we allow */
		/* escaping the path if URL specials % or # present.  */
		if (StrChr(temp, '#') == NULL && StrChr(temp, '%') == NULL)
		    StrAllocCopy(cp, temp);
		else
		    cp = HTEscape(temp, URL_PATH);
#else
		cp = HTEscape(temp, URL_PATH);
#endif /* USE_DOS_DRIVES */
		StrAllocCat(*AllocatedString, cp);
		FREE(cp);
		CTRACE((tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString));
		is_local = TRUE;
	    } else {
		char *cp2 = NULL;

		StrAllocCopy(temp2, curdir);
		LYAddPathSep(&temp2);
		StrAllocCopy(cp, old_string);
		fragment = trimPoundSelector(cp);
		HTUnEscape(cp);	/* unescape given path without fragment */
		StrAllocCat(temp2, cp);		/* append to current dir  */
		StrAllocCopy(cp2, temp2);	/* keep a copy in cp2     */
		LYTrimRelFromAbsPath(temp2);
#ifdef WIN_EX			/* 1998/07/31 (Fri) 09:09:03 */
		HTUnEscape(temp2);	/* for LFN */
#endif

		if (strcmp(temp2, temp) != 0 &&
		    ((stat(temp2, &st) > -1) ||
		     LYCanReadFile(temp2))) {
		    /*
		     * It is a subdirectory or file on the local system with
		     * escaped characters and/or a fragment to be appended to
		     * the URL.  - FM
		     */

		    FREE(temp);
		    if (strcmp(cp2, temp2) == 0) {
			/*
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
			 */
			temp = HTEscape(curdir, URL_PATH);
			LYAddHtmlSep(&temp);
			StrAllocCat(temp, old_string);
		    } else {
			temp = HTEscape(temp2, URL_PATH);
			if (fragment != NULL) {
			    restorePoundSelector(fragment);
			    StrAllocCat(temp, fragment);
			}
		    }
		    StrAllocCat(*AllocatedString, temp);
		    CTRACE((tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString));
		    is_local = TRUE;

		} else if (StrChr(curdir, '#') != NULL ||
			   StrChr(curdir, '%') != NULL) {
		    /*
		     * If PWD has some unusual characters, construct a filename
		     * in temp where those are escaped.  This is mostly to
		     * prevent this function from returning with some weird URL
		     * if the LYExpandHostForURL tests further down fail.  - kw
		     */
		    FREE(temp);
		    if (strcmp(cp2, temp2) == 0) {
			/*
			 * LYTrimRelFromAbsPath did nothing, use old_string as
			 * given.  - kw
			 */
			temp = HTEscape(curdir, URL_PATH);
			LYAddHtmlSep(&temp);
			StrAllocCat(temp, old_string);
		    } else {
			temp = HTEscape(temp2, URL_PATH);
			if (fragment != NULL) {
			    restorePoundSelector(fragment);
			    StrAllocCat(temp, fragment);
			}
		    }
		}
		FREE(cp);
		FREE(cp2);
	    }
	    if (is_local == FALSE) {
		/*
		 * It's not an accessible subdirectory or file on the local
		 * system, so assume it's a URL request and guess the scheme
		 * with "http://" as the default.
		 */
		CTRACE((tfp, "Can't stat() or fopen() '%s'\n",
			temp2 ? temp2 : temp));
#ifdef WIN_EX			/* 1998/01/13 (Tue) 09:07:37 */
		{
		    const char *p, *q;
		    char buff[LY_MAXPATH + 128];

		    p = Home_Dir();
		    q = temp2 ? temp2 : temp;

		    if (strlen(q) == 3 && LYIsDosDrive(q)) {
			sprintf(buff,
				"'%s' not exist, Goto LynxHome '%s'.", q, p);
			_statusline(buff);
			LYSleepAlert();
			FREE(temp);
			StrAllocCat(*AllocatedString, p);
			goto Retry;
		    }
		}
#endif
		if (LYExpandHostForURL(&old_string,
				       URLDomainPrefixes,
				       URLDomainSuffixes)) {
		    if (!LYAddSchemeForURL(&old_string, "http://")) {
			StrAllocCopy(*AllocatedString, "http://");
			StrAllocCat(*AllocatedString, old_string);
		    } else {
			StrAllocCopy(*AllocatedString, old_string);
		    }
		} else if (fixit) {
		    /* RW 1998Mar16  Restore AllocatedString to 'old_string' */
		    StrAllocCopy(*AllocatedString, old_string);
		} else {
		    /* Return file URL for the file that does not exist */
		    StrAllocCat(*AllocatedString, temp);
		}
#ifdef WIN_EX
	      Retry:
#endif
		CTRACE((tfp, "Trying: '%s'\n", *AllocatedString));
	    }
	    FREE(temp);
	    FREE(temp2);
	}
#endif /* VMS */
    } else {
	/*
	 * Path begins with a slash.  Simplify and use it.
	 */
	if (old_string[1] == '\0') {
	    /*
	     * Request for root.  Respect it on Unix, but on VMS we treat that
	     * as a listing of the login directory.  - FM
	     */
#ifdef VMS
	    StrAllocCat(*AllocatedString, HTVMS_wwwName(Home_Dir()));
#else
	    StrAllocCat(*AllocatedString, "/");
	} else if ((stat(old_string, &st) > -1) ||
		   LYCanReadFile(old_string)) {
	    /*
	     * It is an absolute directory or file on the local system.  - KW
	     */
	    StrAllocCopy(temp, old_string);
	    LYTrimRelFromAbsPath(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n", old_string, temp));
	    cp = HTEscape(temp, URL_PATH);
	    StrAllocCat(*AllocatedString, cp);
	    FREE(cp);
	    FREE(temp);
	    CTRACE((tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString));
#endif /* VMS */
	} else if (LYIsTilde(old_string[1])) {
	    /*
	     * Has a Home_Dir() reference.  Handle it as if there weren't a
	     * lead slash.  - FM
	     */
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
	    if ((cp = StrChr((old_string + 1), '/')) != NULL) {
		/*
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		StrAllocCopy(temp, cp);
		LYTrimRelFromAbsPath(temp);
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
	    }
	} else {
	    /*
	     * Normal absolute path.  Simplify, trim any residual relative
	     * elements, and append it.  - FM
	     */
	    StrAllocCopy(temp, old_string);
	    LYTrimRelFromAbsPath(temp);
	    StrAllocCat(*AllocatedString, temp);
	    FREE(temp);
	}
	CTRACE((tfp, "Converted '%s' to '%s'\n",
		old_string, *AllocatedString));
    }
    FREE(old_string);
    /* Pause so we can read the messages before invoking curses */
    CTRACE_SLEEP(AlertSecs);
}

#if defined(_WINDOWS)		/* 1998/06/23 (Tue) 16:45:20 */

int win32_check_interrupt(void)
{
    int c;

    if (kbhit()) {
	c = LYgetch();
	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
	if (LYCharIsINTERRUPT(c) || c == 0x1b) {
	    return TRUE;
	}
    }
    return FALSE;
}

#if (!defined(__MINGW32__) && !defined(sleep)) || (defined(__MINGW32__) && !HAVE_SLEEP)
void sleep(unsigned sec)
{
    unsigned int i, j;

    for (j = 0; j < sec; j++) {
	for (i = 0; i < 10; i++) {
	    Sleep(100);
	    if (kbhit()) {
		(void) LYgetch();
		return;
	    }
	}
    }
}
#endif /* !__MINGW32__ */
#endif /* _WINDOWS */

/*
 * This function rewrites and reallocates a previously allocated string so that
 * the first element is a confirmed Internet host, and returns TRUE, otherwise
 * it does not modify the string and returns FALSE.  It first tries the element
 * as is, then, if the element does not end with a dot, it adds prefixes from
 * the (comma separated) prefix list argument, and, if the element does not
 * begin with a dot, suffixes from the (comma separated) suffix list arguments
 * (e.g., www.host.com, then www.host,edu, then www.host.net, then
 * www.host.org).  The remaining path, if one is present, will be appended to
 * the expanded host.  It also takes into account whether a colon is in the
 * element or suffix, and includes that and what follows as a port field for
 * the expanded host field (e.g, wfbr:8002/dir/lynx should yield
 * www.wfbr.edu:8002/dir/lynx).  The calling function should prepend the scheme
 * field (e.g., http://), or pass the string to LYAddSchemeForURL(), if this
 * function returns TRUE.  - FM
 */
BOOLEAN LYExpandHostForURL(char **AllocatedString,
			   char *prefix_list,
			   char *suffix_list)
{
    char *DomainPrefix = NULL;
    const char *StartP, *EndP;
    char *DomainSuffix = NULL;
    const char *StartS, *EndS;
    char *Str = NULL, *StrColon = NULL, *MsgStr = NULL;
    char *Host = NULL, *HostColon = NULL, *host = NULL;
    char *Path = NULL;
    char *Fragment = NULL;
    BOOLEAN GotHost = FALSE;
    BOOLEAN Startup = (BOOL) (helpfilepath == NULL);

#ifdef INET6
    struct addrinfo hints, *res;
    int error;
    char *begin;
    char *end = NULL;
#endif /* INET6 */

    /*
     * If it's a NULL or zero-length string, or if it begins with a slash or
     * hash, don't continue pointlessly.  - FM
     */
    if (!(*AllocatedString) || *AllocatedString[0] == '\0' ||
	*AllocatedString[0] == '/' || *AllocatedString[0] == '#') {
	return GotHost;
    }

    /*
     * If it's a partial or relative path, don't continue pointlessly.  - FM
     */
    if (!StrNCmp(*AllocatedString, "..", 2) ||
	!StrNCmp(*AllocatedString, "./", 2)) {
	return GotHost;
    }

    /*
     * Make a clean copy of the string, and trim off the path if one is
     * present, but save the information so we can restore the path after
     * filling in the Host[:port] field.  - FM
     */
    StrAllocCopy(Str, *AllocatedString);
    if ((Path = StrChr(Str, '/')) != NULL) {
	/*
	 * Have a path.  Any fragment should already be included in Path.  - FM
	 */
	*Path = '\0';
    } else {
	/*
	 * No path, so check for a fragment and trim that, to be restored after
	 * filling in the Host[:port] field.  - FM
	 */
	Fragment = trimPoundSelector(Str);
    }

    /*
     * If the potential host string has a colon, assume it begins a port field,
     * and trim it off, but save the information so we can restore the port
     * field after filling in the host field.  - FM
     */
    if ((StrColon = strrchr(Str, ':')) != NULL &&
	isdigit(UCH(StrColon[1])) && StrChr(StrColon, ']') == NULL) {
	if (StrColon == Str) {
	    goto cleanup;
	}
	*StrColon = '\0';
    }

    /*
     * Do a DNS test on the potential host field as presently trimmed.  - FM
     */
    StrAllocCopy(host, Str);
    HTUnEscape(host);
    if (LYCursesON) {
	StrAllocCopy(MsgStr, WWW_FIND_MESSAGE);
	StrAllocCat(MsgStr, host);
	StrAllocCat(MsgStr, FIRST_SEGMENT);
	HTProgress(MsgStr);
    } else if (Startup && !dump_output_immediately) {
	fprintf(stdout, "%s '%s'%s\r\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
    }
#ifdef INET6
    begin = host;
    if (host[0] == '[' && ((end = strrchr(host, ']')))) {
	/*
	 * cut '[' and ']' from the IPv6 address, e.g. [::1]
	 */
	begin = host + 1;
	*end = '\0';
    }
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(begin, "80", &hints, &res);
    if (end)
	*end = ']';

    if (!error && res)
#else
    if (LYGetHostByName(host) != NULL)
#endif /* INET6 */
    {
	/*
	 * Clear any residual interrupt.  - FM
	 */
	if (LYCursesON && HTCheckForInterrupt()) {
	    CTRACE((tfp,
		    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
		    host));
	}

	/*
	 * Return success.  - FM
	 */
	GotHost = TRUE;
	goto cleanup;
    } else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
	/*
	 * Give the user chance to interrupt lookup cycles.  - KW & FM
	 */
	CTRACE((tfp,
		"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		host));

	/*
	 * Return failure.  - FM
	 */
	goto cleanup;
    }

    /*
     * Set the first prefix, making it a zero-length string if the list is NULL
     * or if the potential host field ends with a dot.  - FM
     */
    StartP = ((prefix_list && Str[strlen(Str) - 1] != '.')
	      ? prefix_list
	      : "");
    /*
     * If we have a prefix, but the allocated string is one of the common host
     * prefixes, make our prefix a zero-length string.  - FM
     */
    if (*StartP && *StartP != '.') {
	if (!strncasecomp(*AllocatedString, "www.", 4) ||
	    !strncasecomp(*AllocatedString, "ftp.", 4) ||
	    !strncasecomp(*AllocatedString, "gopher.", 7) ||
	    !strncasecomp(*AllocatedString, "wais.", 5) ||
	    !strncasecomp(*AllocatedString, "cso.", 4) ||
	    !strncasecomp(*AllocatedString, "ns.", 3) ||
	    !strncasecomp(*AllocatedString, "ph.", 3) ||
	    !strncasecomp(*AllocatedString, "finger.", 7) ||
	    !strncasecomp(*AllocatedString, "news.", 5) ||
	    !strncasecomp(*AllocatedString, "nntp.", 5)) {
	    StartP = "";
	}
    }
    while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
	StartP++;		/* Skip whitespace and separators */
    }
    EndP = StartP;
    while (*EndP && !WHITE(*EndP) && *EndP != ',') {
	EndP++;			/* Find separator */
    }
    StrAllocCopy(DomainPrefix, StartP);
    DomainPrefix[EndP - StartP] = '\0';

    /*
     * Test each prefix with each suffix.  - FM
     */
    do {
	/*
	 * Set the first suffix, making it a zero-length string if the list is
	 * NULL or if the potential host field begins with a dot.  - FM
	 */
	StartS = ((suffix_list && *Str != '.')
		  ? suffix_list
		  : "");
	while ((*StartS) && (WHITE(*StartS) || *StartS == ',')) {
	    StartS++;		/* Skip whitespace and separators */
	}
	EndS = StartS;
	while (*EndS && !WHITE(*EndS) && *EndS != ',') {
	    EndS++;		/* Find separator */
	}
	StrAllocCopy(DomainSuffix, StartS);
	DomainSuffix[EndS - StartS] = '\0';

	/*
	 * Create domain names and do DNS tests.  - FM
	 */
	do {
	    StrAllocCopy(Host, DomainPrefix);
	    StrAllocCat(Host, ((*Str == '.') ? (Str + 1) : Str));
	    if (Host[strlen(Host) - 1] == '.') {
		Host[strlen(Host) - 1] = '\0';
	    }
	    StrAllocCat(Host, DomainSuffix);
	    if ((HostColon = strrchr(Host, ':')) != NULL &&
		isdigit(UCH(HostColon[1]))) {
		*HostColon = '\0';
	    }
	    StrAllocCopy(host, Host);
	    HTUnEscape(host);
	    if (LYCursesON) {
		StrAllocCopy(MsgStr, WWW_FIND_MESSAGE);
		StrAllocCat(MsgStr, host);
		StrAllocCat(MsgStr, GUESSING_SEGMENT);
		HTProgress(MsgStr);
	    } else if (Startup && !dump_output_immediately) {
		fprintf(stdout, "%s '%s'%s\n", WWW_FIND_MESSAGE, host, GUESSING_SEGMENT);
	    }
	    GotHost = (BOOL) (LYGetHostByName(host) != NULL);
	    if (HostColon != NULL) {
		*HostColon = ':';
	    }
	    if (GotHost == FALSE) {
		/*
		 * Give the user chance to interrupt lookup cycles.  - KW
		 */
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
		    CTRACE((tfp,
			    "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
			    host));
		    goto cleanup;	/* We didn't find a valid name. */
		}

		/*
		 * Advance to the next suffix, or end of suffix list.  - FM
		 */
		StartS = ((*EndS == '\0') ? EndS : (EndS + 1));
		while ((*StartS) && (WHITE(*StartS) || *StartS == ',')) {
		    StartS++;	/* Skip whitespace and separators */
		}
		EndS = StartS;
		while (*EndS && !WHITE(*EndS) && *EndS != ',') {
		    EndS++;	/* Find separator */
		}
		LYStrNCpy(DomainSuffix, StartS, (EndS - StartS));
	    }
	} while ((GotHost == FALSE) && (*DomainSuffix != '\0'));

	if (GotHost == FALSE) {
	    /*
	     * Advance to the next prefix, or end of prefix list.  - FM
	     */
	    StartP = ((*EndP == '\0') ? EndP : (EndP + 1));
	    while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
		StartP++;	/* Skip whitespace and separators */
	    }
	    EndP = StartP;
	    while (*EndP && !WHITE(*EndP) && *EndP != ',') {
		EndP++;		/* Find separator */
	    }
	    LYStrNCpy(DomainPrefix, StartP, (EndP - StartP));
	}
    } while ((GotHost == FALSE) && (*DomainPrefix != '\0'));

    /*
     * If a test passed, restore the port field if we had one and there is no
     * colon in the expanded host, and the path if we had one, and reallocate
     * the original string with the expanded Host[:port] field included.  - FM
     */
    if (GotHost) {
	if (StrColon && StrChr(Host, ':') == NULL) {
	    *StrColon = ':';
	    StrAllocCat(Host, StrColon);
	}
	if (Path) {
	    *Path = '/';
	    StrAllocCat(Host, Path);
	} else if (Fragment) {
	    StrAllocCat(Host, "/");
	    restorePoundSelector(Fragment);
	    StrAllocCat(Host, Fragment);
	}
	StrAllocCopy(*AllocatedString, Host);
    }

    /*
     * Clear any residual interrupt.  - FM
     */
    if (LYCursesON && HTCheckForInterrupt()) {
	CTRACE((tfp,
		"LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
		host,
		(GotHost ? "resolved" : "timed out")));
    }

    /*
     * Clean up and return the last test result.  - FM
     */
  cleanup:
    FREE(DomainPrefix);
    FREE(DomainSuffix);
    FREE(Str);
    FREE(MsgStr);
    FREE(Host);
    FREE(host);
    return GotHost;
}

/*
 * This function rewrites and reallocates a previously allocated string that
 * begins with an Internet host name so that the string begins with its guess
 * of the scheme based on the first field of the host name, or the default
 * scheme if no guess was made, and returns TRUE, otherwise it does not modify
 * the string and returns FALSE.  It also returns FALSE without modifying the
 * string if the default_scheme argument was NULL or zero-length and no guess
 * was made.  - FM
 */
BOOLEAN LYAddSchemeForURL(char **AllocatedString,
			  const char *default_scheme)
{
    char *Str = NULL;
    BOOLEAN GotScheme = FALSE;

    /*
     * If we were passed a NULL or zero-length string, don't continue
     * pointlessly.  - FM
     */
    if (!(*AllocatedString) || *AllocatedString[0] == '\0') {
	return GotScheme;
    }

    /*
     * Try to guess the appropriate scheme. - FM
     */
    if (0 == strncasecomp(*AllocatedString, "www", 3)) {
	/*
	 * This could be either http or https, so check the default and
	 * otherwise use "http".  - FM
	 */
	if (default_scheme != NULL &&
	    NULL != strstr(default_scheme, "http")) {
	    StrAllocCopy(Str, default_scheme);
	} else {
	    StrAllocCopy(Str, "http://");
	}
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "ftp", 3)) {
	StrAllocCopy(Str, "ftp://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "gopher", 6)) {
	StrAllocCopy(Str, "gopher://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "wais", 4)) {
	StrAllocCopy(Str, "wais://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "cso", 3) ||
	       0 == strncasecomp(*AllocatedString, "ns.", 3) ||
	       0 == strncasecomp(*AllocatedString, "ph.", 3)) {
	StrAllocCopy(Str, "cso://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "finger", 6)) {
	StrAllocCopy(Str, "finger://");
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "news", 4)) {
	/*
	 * This could be either news, snews, or nntp, so check the default, and
	 * otherwise use news.  - FM
	 */
	if ((default_scheme != NULL) &&
	    (NULL != strstr(default_scheme, "news") ||
	     NULL != strstr(default_scheme, "nntp"))) {
	    StrAllocCopy(Str, default_scheme);
	} else {
	    StrAllocCopy(Str, "news://");
	}
	GotScheme = TRUE;

    } else if (0 == strncasecomp(*AllocatedString, "nntp", 4)) {
	StrAllocCopy(Str, "nntp://");
	GotScheme = TRUE;

    }

    /*
     * If we've make a guess, use it.  Otherwise, if we were passed a default
     * scheme prefix, use that.  - FM
     */
    if (GotScheme == TRUE) {
	StrAllocCat(Str, *AllocatedString);
	StrAllocCopy(*AllocatedString, Str);
	FREE(Str);
	return GotScheme;

    } else if (non_empty(default_scheme)) {
	StrAllocCopy(Str, default_scheme);
	GotScheme = TRUE;
	StrAllocCat(Str, *AllocatedString);
	StrAllocCopy(*AllocatedString, Str);
	FREE(Str);
	return GotScheme;
    }

    return GotScheme;
}

/*
 * This function expects an absolute Unix or VMS SHELL path spec as an
 * allocated string, simplifies it, and trims out any residual relative
 * elements.  It also checks whether the path had a terminal slash, and if it
 * didn't, makes sure that the simplified path doesn't either.  If it's a
 * directory, our convention is to exclude "Up to parent" links when a terminal
 * slash is present.  - FM
 */
void LYTrimRelFromAbsPath(char *path)
{
    char *cp;
    int i;
    BOOL TerminalSlash;

    /*
     * Make sure we have a pointer to an absolute path.  - FM
     */
    if (path == NULL || !LYIsPathSep(*path))
	return;

    /*
     * Check whether the path has a terminal slash.  - FM
     */
    TerminalSlash = (BOOL) (LYIsPathSep(path[(strlen(path) - 1)]));

    /*
     * Simplify the path and then do any necessary trimming.  - FM
     */
    HTSimplify(path);
    cp = path;
    while (cp[1] == '.') {
	if (cp[2] == '\0') {
	    /*
	     * Eliminate trailing dot.  - FM
	     */
	    cp[1] = '\0';
	} else if (LYIsPathSep(cp[2])) {
	    /*
	     * Skip over the "/." of a "/./".  - FM
	     */
	    cp += 2;
	} else if (cp[2] == '.' && cp[3] == '\0') {
	    /*
	     * Eliminate trailing dotdot.  - FM
	     */
	    cp[1] = '\0';
	} else if (cp[2] == '.' && cp[3] == '/') {
	    /*
	     * Skip over the "/.." of a "/../".  - FM
	     */
	    cp += 3;
	} else {
	    /*
	     * Done trimming.  - FM
	     */
	    break;
	}
    }

    /*
     * Load any shifts into path, and eliminate any terminal slash created by
     * HTSimplify() or our walk, but not present originally.  - FM
     */
    if (cp > path) {
	for (i = 0; cp[i] != '\0'; i++)
	    path[i] = cp[i];
	path[i] = '\0';
    }
    if (TerminalSlash == FALSE) {
	LYTrimPathSep(path);
    }
}

/*
 * Example Client-Side Include interface.
 *
 * This is called from SGML.c and simply returns markup for reporting the URL
 * of the document being loaded if a comment begins with "<!--#lynxCSI".  The
 * markup will be included as if it were in the document.  Move this function
 * to a separate module for doing this kind of thing seriously, someday.  - FM
 */
void LYDoCSI(char *url,
	     const char *comment,
	     char **csi)
{
    const char *cp = comment;

    if (cp == NULL)
	return;

    if (StrNCmp(cp, "!--#", 4))
	return;

    cp += 4;
    if (!strncasecomp(cp, "lynxCSI", 7)) {
	StrAllocCat(*csi, "\n<p align=\"center\">URL: ");
	StrAllocCat(*csi, url);
	StrAllocCat(*csi, "</p>\n\n");
    }

    return;
}

#ifdef VMS
/*
 * Define_VMSLogical -- Fote Macrides 04-Apr-1995
 * Define VMS logicals in the process table.
 */
void Define_VMSLogical(char *LogicalName,
		       char *LogicalValue)
{
    $DESCRIPTOR(lname, "");
    $DESCRIPTOR(lvalue, "");
    $DESCRIPTOR(ltable, "LNM$PROCESS");

    if (isEmpty(LogicalName))
	return;

    lname.dsc$w_length = strlen(LogicalName);
    lname.dsc$a_pointer = LogicalName;

    if (isEmpty(LogicalValue)) {
	lib$delete_logical(&lname, &ltable);
	return;
    }

    lvalue.dsc$w_length = strlen(LogicalValue);
    lvalue.dsc$a_pointer = LogicalValue;
    lib$set_logical(&lname, &lvalue, &ltable, 0, 0);
    return;
}
#endif /* VMS */

#ifdef LY_FIND_LEAKS
static void LYHomeDir_free(void)
{
    FREE(HomeDir);
}
#endif /* LY_FIND_LEAKS */

char *Current_Dir(char *pathname)
{
    char *result;

#ifdef HAVE_GETCWD
    result = getcwd(pathname, (size_t) LY_MAXPATH);
#else
    result = getwd(pathname);
#endif /* NO_GETCWD */
    if (result == 0)
	strcpy(pathname, ".");
    return pathname;
}

/*
 * Verify that the given path refers to an existing directory, returning the
 * string if the directory exists.  If not, return null.
 */
static char *CheckDir(char *path)
{
    struct stat stat_info;

    if (!LYisAbsPath(path)
	|| (HTStat(path, &stat_info) < 0
	    || !S_ISDIR(stat_info.st_mode))) {
	path = NULL;
    }
    CTRACE((tfp, "CheckDir(%s) %s\n", path, path ? "OK" : "ERR"));
    return path;
}

/*
 * Lookup various possibilities for $HOME, and check that the directory exists.
 */
static char *HomeEnv(void)
{
    char *result = CheckDir(LYGetEnv("HOME"));

#if defined (USE_DOS_DRIVES)
    if (result == 0) {
	char *head;
	char *leaf;
	static char *temp = NULL;

	result = w32_get_shell_folder("Personal");
	if (result == 0) {
	    /* Windows Vista/7 */
	    if ((head = LYGetEnv("USERPROFILE")) != 0) {
		HTSprintf0(&temp, "%s%sDocuments", head, FILE_SEPARATOR);
		result = CheckDir(temp);
		if (result == 0) {
		    /* Windows 2000 */
		    HTSprintf0(&temp, "%s%sMy Documents", head, FILE_SEPARATOR);
		    result = CheckDir(temp);
		}
	    }
	}
	/* NT4 */
	if (result == 0) {
	    if ((head = LYGetEnv("HOMEDRIVE")) != 0) {
		if ((leaf = LYGetEnv("HOMEPATH")) != 0) {
		    HTSprintf0(&temp, "%s%s%s", head, FILE_SEPARATOR, leaf);
		    result = CheckDir(temp);
		}
	    }
	}
	/* General M$ */
#ifdef USE_PROGRAM_DIR
	if (result == 0)
	    result = CheckDir(program_dir);
#endif
	if (result == 0)
	    result = CheckDir(LYGetEnv("TEMP"));
	if (result == 0)
	    result = CheckDir(LYGetEnv("TMP"));
	if (result == 0) {
	    if ((head = LYGetEnv("SystemDrive")) != 0) {
		HTSprintf0(&temp, "%s%s", head, FILE_SEPARATOR);
		result = CheckDir(temp);
	    }
	}
	if (result == 0)
	    result = CheckDir("C:" FILE_SEPARATOR);
    }
#endif

    return result;
}

const char *Home_Dir(void)
{
    static const char *homedir = NULL;
    char *cp = NULL;

    if (homedir == NULL) {
	if ((cp = HomeEnv()) == NULL) {
#ifdef VMS
	    if ((cp = LYGetEnv("SYS$LOGIN")) == NULL
		&& (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
		cp = "sys$scratch:";
	    }
	    StrAllocCopy(HomeDir, cp);
#else
#ifdef UNIX
#ifdef HAVE_UTMP
	    /*
	     * One could use getlogin() and getpwnam() here instead.
	     */
	    struct passwd *pw = getpwuid(geteuid());

	    if (pw && pw->pw_dir) {
		StrAllocCopy(HomeDir, pw->pw_dir);
	    } else
#endif
	    {
		/*
		 * Use /tmp; it should be writable.
		 */
		StrAllocCopy(HomeDir, "/tmp");
	    }
#endif
#endif /* VMS */
	} else {
	    StrAllocCopy(HomeDir, cp);
	}
	homedir = (const char *) HomeDir;
#ifdef LY_FIND_LEAKS
	atexit(LYHomeDir_free);
#endif
    }
    if (homedir == NULL) {
	printf("%s\n", gettext("Cannot find HOME directory"));
	exit_immediately(EXIT_FAILURE);
    }
    return homedir;
}

/*
 * Return a pointer to the final leaf of the given pathname, If no pathname
 * separators are found, returns the original pathname.  The leaf may be
 * empty.
 */
char *LYPathLeaf(char *pathname)
{
    char *leaf;

#ifdef UNIX
    if ((leaf = strrchr(pathname, '/')) != 0) {
	leaf++;
    }
#else
#ifdef VMS
    if ((leaf = strrchr(pathname, ']')) == 0)
	leaf = strrchr(pathname, ':');
    if (leaf != 0)
	leaf++;
#else
    int n;

    for (leaf = 0, n = strlen(pathname) - 1; n >= 0; n--) {
	if (StrChr("\\/:", pathname[n]) != 0) {
	    leaf = pathname + n + 1;
	    break;
	}
    }
#endif
#endif
    return (leaf != 0) ? leaf : pathname;
}

/*
 * This function checks the acceptability of file paths that are intended to be
 * off the home directory.  The file path should be passed in fbuffer, together
 * with the size of the buffer.  The function simplifies the file path, and if
 * it is acceptable, loads it into fbuffer and returns TRUE.  Otherwise, it
 * does not modify fbuffer and returns FALSE.  If a subdirectory is present and
 * the path does not begin with "./", that is prefixed to make the situation
 * clear.  - FM
 */
BOOLEAN LYPathOffHomeOK(char *fbuffer,
			size_t fbuffer_size)
{
    char *file = NULL;
    char *cp, *cp1;

    /*
     * Make sure we have an fbuffer and a string in it.  - FM
     */
    if (fbuffer_size < 2 || isEmpty(fbuffer)) {
	return (FALSE);
    }
    StrAllocCopy(file, fbuffer);
    cp = file;

    /*
     * Check for an inappropriate reference to the home directory, and correct
     * it if we can.  - FM
     */
#ifdef VMS
    if (!strncasecomp(cp, "sys$login", 9)) {
	if (*(cp + 9) == '\0') {
	    /*
	     * Reject "sys$login".  - FM
	     */
	    FREE(file);
	    return (FALSE);
	}
	if (*(cp + 9) == ':') {
	    cp += 10;
	    if (*cp == '\0') {
		/*
		 * Reject "sys$login:".  Otherwise, we have converted
		 * "sys$login:file" to "file", or have left a strange path for
		 * VMS as it was originally.  - FM
		 */
		FREE(file);
		return (FALSE);
	    }
	}
    }
#endif /* VMS */
    if (LYIsTilde(cp[0])) {
	if (LYIsPathSep(cp[1])) {
	    if (cp[2] != '\0') {
		if (StrChr((cp + 2), '/') != NULL) {
		    /*
		     * Convert "~/subdir(s)/file" to "./subdir(s)/file".  - FM
		     */
		    *cp = '.';
		} else {
		    /*
		     * Convert "~/file" to "file".  - FM
		     */
		    cp += 2;
		}
	    } else {
		/*
		 * Reject "~/".  - FM
		 */
		FREE(file);
		return (FALSE);
	    }
	} else if ((*(cp + 1) != '\0') &&
		   (cp1 = StrChr((cp + 1), '/')) != NULL) {
	    cp = (cp1 - 1);
	    if (*(cp + 2) != '\0') {
		if (StrChr((cp + 2), '/') != NULL) {
		    /*
		     * Convert "~user/subdir(s)/file" to "./subdir(s)/file". 
		     * If user is someone else, we covered a spoof.  Otherwise,
		     * we simplified.  - FM
		     */
		    *cp = '.';
		} else {
		    /*
		     * Convert "~user/file" to "file".  - FM
		     */
		    cp += 2;
		}
	    } else {
		/*
		 * Reject "~user/".  - FM
		 */
		FREE(file);
		return (FALSE);
	    }
	} else {
	    /*
	     * Reject "~user".  - FM
	     */
	    FREE(file);
	    return (FALSE);
	}
    }
#ifdef VMS
    /*
     * Check for VMS path specs, and reject if still present.  - FM
     */
    if (StrChr(cp, ':') != NULL || StrChr(cp, ']') != NULL) {
	FREE(file);
	return (FALSE);
    }
#endif /* VMS */

    /*
     * Check for a URL or absolute path, and reject if present.  - FM
     */
    if (is_url(cp) || LYIsPathSep(*cp)) {
	FREE(file);
	return (FALSE);
    }

    /*
     * Simplify it.  - FM
     */
    HTSimplify(cp);

    /*
     * Check if it has a pointless "./".  - FM
     */
    if (!StrNCmp(cp, "./", 2)) {
	if (StrChr((cp + 2), '/') == NULL) {
	    cp += 2;
	}
    }

    /*
     * Check for spoofing.  - FM
     */
    if (*cp == '\0'
	|| LYIsPathSep(*cp)
	|| LYIsPathSep(cp[(strlen(cp) - 1)])
	|| strstr(cp, "..") != NULL
	|| !strcmp(cp, ".")) {
	FREE(file);
	return (FALSE);
    }

    /*
     * Load what we have at this point into fbuffer, trimming if too long, and
     * claim it's OK.  - FM
     */
    if (fbuffer_size > 3 && StrNCmp(cp, "./", 2) && StrChr(cp, '/')) {
	/*
	 * We have a subdirectory and no lead "./", so prefix it to make the
	 * situation clear.  - FM
	 */
	strcpy(fbuffer, "./");
	if (strlen(cp) > (fbuffer_size - 3))
	    cp[(fbuffer_size - 3)] = '\0';
	strcat(fbuffer, cp);
    } else {
	if (strlen(cp) > (fbuffer_size - 1))
	    cp[(fbuffer_size - 1)] = '\0';
	strcpy(fbuffer, cp);
    }
    FREE(file);
    return (TRUE);
}

/*
 * Search for a leading tilde, optionally embedded.  If found, return a pointer
 * to the tilde.  If not found, return the original parameter.
 */
static char *FindLeadingTilde(char *pathname, int embedded)
{
    char *result = pathname;

    if (pathname != NULL) {
	if (embedded) {
	    while (pathname[0] != '\0') {
		if (LYIsPathSep(pathname[0])) {
		    if (LYIsTilde(pathname[1])) {
			++pathname;
			break;
		    }
		}
		++pathname;
	    }
	}
	if (LYIsTilde(*pathname))
	    result = pathname;
    }
    return result;
}

/*
 * Convert a non-absolute path to one which is off the home directory.  Expand
 * tildes as a side-effect.  Return a pointer to the converted result.
 */
char *LYAbsOrHomePath(char **fname)
{
    if (*fname && !LYisAbsPath(*fname)) {
	if (LYIsTilde((*fname)[0])) {
	    LYTildeExpand(fname, FALSE);
	} else {
	    char temp[LY_MAXPATH];

	    LYAddPathToHome(temp, sizeof(temp), *fname);
	    StrAllocCopy(*fname, temp);
	}
    }
    return *fname;
}

/*
 * Expand a "leading" tilde into the user's home directory in WWW format.  If
 * "embedded" is true, allow that "leading" tilde to follow a path separator.
 */
char *LYTildeExpand(char **pathname,
		    int embedded)
{
    char *temp = FindLeadingTilde(*pathname, embedded);

    if (LYIsTilde(temp[0])) {

	CTRACE((tfp, "LYTildeExpand %s\n", *pathname));
	if (LYIsPathSep(temp[1])) {
	    char *first = NULL;
	    char *second = NULL;

	    StrAllocCopy(first, *pathname);
	    first[temp - *pathname] = '\0';

	    StrAllocCopy(second, temp + 2);

	    StrAllocCopy(*pathname, first);
	    StrAllocCat(*pathname, wwwName(Home_Dir()));
	    LYAddPathSep(pathname);
	    StrAllocCat(*pathname, second);

	    FREE(first);
	    FREE(second);
	} else if (temp[1] == '\0') {
	    StrAllocCopy(*pathname, wwwName(Home_Dir()));
#ifndef NOUSERS
	} else {
	    char *save;
	    char saved = '\0';
	    struct passwd *pw;

	    for (save = temp; *save != '\0'; ++save) {
		if (LYIsPathSep(*save)) {
		    saved = *save;
		    *save = '\0';
		    break;
		}
	    }
	    pw = getpwnam(temp + 1);
	    *save = saved;
	    if (pw != 0 && non_empty(pw->pw_dir)) {
		temp = NULL;
		StrAllocCopy(temp, save);
		StrAllocCopy(*pathname, pw->pw_dir);
		StrAllocCat(*pathname, temp);
		FREE(temp);
	    }
#endif
	}
	CTRACE((tfp, "expanded path %s\n", *pathname));
    }
    return *pathname;
}

/*
 * This function appends fname to the home path and returns the full path and
 * filename.  The fname string can be just a filename (e.g.,
 * "lynx_bookmarks.html"), or include a subdirectory off the home directory, in
 * which case fname should begin with "./" (e.g., ./BM/lynx_bookmarks.html) Use
 * LYPathOffHomeOK() to check and/or fix up fname before calling this function. 
 * On VMS, the resultant full path and filename are converted to VMS syntax.  -
 * FM
 */
void LYAddPathToHome(char *fbuffer,
		     size_t fbuffer_size,
		     const char *fname)
{
    char *home = NULL;
    const char *file = fname;
    int len;

    /*
     * Make sure we have a buffer.  - FM
     */
    if (!fbuffer)
	return;
    if (fbuffer_size < 2) {
	fbuffer[0] = '\0';
	return;
    }
    fbuffer[(fbuffer_size - 1)] = '\0';

    /*
     * Make sure we have a file name.  - FM
     */
    if (!file)
	file = "";

    /*
     * Set up home string and length.  - FM
     */
    StrAllocCopy(home, Home_Dir());

#ifdef VMS
#define NO_HOMEPATH "Error:"
#else
#define NO_HOMEPATH "/error"
#endif /* VMS */
    if (!non_empty(home))
	/*
	 * Home_Dir() has a bug if this ever happens.  - FM
	 */
	StrAllocCopy(home, NO_HOMEPATH);

    len = (int) fbuffer_size - ((int) strlen(home) + 1);
    if (len <= 0) {
	/*
	 * Buffer is smaller than or only big enough for the home path.  Load
	 * what fits of the home path and return.  This will fail, but we need
	 * something in the buffer.  - FM
	 */
	LYStrNCpy(fbuffer, home, (fbuffer_size - 1));
	FREE(home);
	return;
    }
#ifdef VMS
    /*
     * Check whether we have a subdirectory path or just a filename.  - FM
     */
    if (!StrNCmp(file, "./", 2)) {
	/*
	 * We have a subdirectory path.  - FM
	 */
	if (home[strlen(home) - 1] == ']') {
	    /*
	     * We got the home directory, so convert it to SHELL syntax and
	     * append subdirectory path, then convert that to VMS syntax.  - FM
	     */
	    char *temp = NULL;

	    HTSprintf0(&temp, "%s%s", HTVMS_wwwName(home), (file + 1));
	    sprintf(fbuffer, "%.*s",
		    (fbuffer_size - 1), HTVMS_name("", temp));
	    FREE(temp);
	} else {
	    /*
	     * This will fail, but we need something in the buffer.  - FM
	     */
	    sprintf(fbuffer, "%s%.*s", home, len, file);
	}
    } else {
	/*
	 * We have a file in the home directory.  - FM
	 */
	sprintf(fbuffer, "%s%.*s", home, len, file);
    }
#else
    /*
     * Check whether we have a subdirectory path or just a filename.  - FM
     */
    sprintf(fbuffer, "%s/%.*s", home, len,
	    (StrNCmp(file, "./", 2) ? file : (file + 2)));
#endif /* VMS */
    FREE(home);
}

/*
 * Given a filename, concatenate it to the save-space pathname, unless it is
 * an absolute pathname.  If there is no save-space defined, use the home
 * directory. Return a new string with the result.
 */
char *LYAddPathToSave(char *fname)
{
    char *result = NULL;

    if (LYisAbsPath(fname)) {
	StrAllocCopy(result, fname);
    } else {
	if (lynx_save_space != NULL) {
	    StrAllocCopy(result, lynx_save_space);
	} else {
	    char temp[LY_MAXPATH];

	    LYAddPathToHome(temp, sizeof(temp), fname);
	    StrAllocCopy(result, temp);
	}
    }
    return result;
}

#if !defined(HAVE_PUTENV) && !defined(_WINDOWS)
/*
 * No putenv on the NeXT so we use this code instead!
 */

/* Copyright (C) 1991 Free Software Foundation, Inc.
This file is part of the GNU C Library.

The GNU C Library is free software; you can  redistribute it and/or
modify it under the terms of the GNU Library General  Public License as
published by the Free Software Foundation; either  version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it  will be useful,
but WITHOUT ANY WARRANTY; without even the implied  warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library  General Public
License along with the GNU C Library; see the file  COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675  Mass Ave,
Cambridge, MA 02139, USA.  */

#if defined(STDC_HEADERS) || defined(USG)
#include <string.h>
#else /* Not (STDC_HEADERS or USG): */
#include <strings.h>
#endif /* STDC_HEADERS or USG */

#ifndef NULL
#define NULL 0
#endif /* !NULL */

extern char **environ;

/*
 * Put STRING, which is of the form "NAME=VALUE", in the environment.
 */
int putenv(const char *string)
{
    char *name_end = StrChr(string, '=');
    register size_t size;
    register char **ep;

    if (name_end == NULL) {
	/* Remove the variable from the environment.  */
	size = strlen(string);
	for (ep = environ; *ep != NULL; ++ep)
	    if (!StrNCmp(*ep, string, size) && (*ep)[size] == '=') {
		while (ep[1] != NULL) {
		    ep[0] = ep[1];
		    ++ep;
		}
		*ep = NULL;
		return 0;
	    }
    }

    size = 0;
    for (ep = environ; *ep != NULL; ++ep)
	if (!StrNCmp(*ep, string, name_end - string) &&
	    (*ep)[name_end - string] == '=')
	    break;
	else
	    ++size;

    if (*ep == NULL) {
	static char **last_environ = NULL;
	char **new_environ = (char **) malloc((size + 2) * sizeof(char *));

	if (new_environ == NULL)
	    return -1;
	(void) memcpy((char *) new_environ, (char *) environ, size * sizeof(char *));

	new_environ[size] = (char *) string;
	new_environ[size + 1] = NULL;
	if (last_environ != NULL)
	    FREE(last_environ);
	last_environ = new_environ;
	environ = new_environ;
    } else
	*ep = (char *) string;

    return 0;
}
#endif /* !HAVE_PUTENV */

#ifdef NEED_REMOVE
int remove(char *name)
{
    return unlink(name);
}
#endif

#if defined(MULTI_USER_UNIX)

#if defined(HAVE_LSTAT) && defined(S_IFLNK)
/*
 * If IsOurFile() is checking a symbolic link, ensure that the target
 * points to the user's file as well.
 */
static BOOL IsOurSymlink(const char *name)
{
    BOOL result = FALSE;
    size_t size = LY_MAXPATH;
    size_t used;
    char *buffer = typeMallocn(char, (unsigned) size);
    char *check;

    if (buffer != 0) {
	while ((used = (size_t) readlink(name, buffer, (size - 1))) == size - 1) {
	    check = typeRealloc(char, buffer, (unsigned) (size *= 2));

	    if (check == 0)
		break;
	    buffer = check;
	}
	if (buffer != 0) {
	    if ((int) used > 0) {
		buffer[used] = '\0';
	    } else {
		FREE(buffer);
	    }
	}
    }
    if (buffer != 0) {
	if (!LYisAbsPath(buffer)) {
	    char *cutoff = LYLastPathSep(name);
	    char *clone = NULL;

	    if (cutoff != 0) {
		HTSprintf0(&clone, "%.*s%s%s",
			   (int) (cutoff - name),
			   name, FILE_SEPARATOR, buffer);
		FREE(buffer);
		buffer = clone;
	    }
	}
	CTRACE2(TRACE_CFG, (tfp, "IsOurSymlink(%s -> %s)\n", name, buffer));
	result = IsOurFile(buffer);
	FREE(buffer);
    }
    return result;
}
#endif

/*
 * Verify if this is really a file, not accessed by a link, except for the
 * special case of its directory being pointed to by a link from a directory
 * owned by root and not writable by other users.
 */
BOOL IsOurFile(const char *name)
{
    BOOL result = FALSE;
    struct stat data;

    if (!LYIsTilde(name[0])
	&& lstat(name, &data) == 0
	&& ((S_ISREG(data.st_mode)
	     && (data.st_mode & (S_IWOTH | S_IWGRP)) == 0
	     && data.st_nlink == 1
	     && data.st_uid == getuid())
#if defined(HAVE_LSTAT) && defined(S_IFLNK)
	    || (S_ISLNK(data.st_mode) && IsOurSymlink(name))
#endif
	)) {
	int linked = FALSE;

	/*
	 * ( If this is not a single-user system, the other user is presumed by
	 * some people busy trying to use a symlink attack on our files ;-)
	 */
#if defined(HAVE_LSTAT)
	char *path = 0;
	char *leaf;

	StrAllocCopy(path, name);
	do {
	    if ((leaf = LYPathLeaf(path)) != path)
		*--leaf = '\0';	/* write a null on the '/' */
	    if (lstat(*path ? path : "/", &data) != 0) {
		break;
	    }
	    /*
	     * If we find a symbolic link, it has to be in a directory that's
	     * protected.  Otherwise someone could have switched it to point
	     * to one of the real user's files.
	     */
	    if (S_ISLNK(data.st_mode)) {
		linked = TRUE;	/* could be link-to-link; doesn't matter */
	    } else if (S_ISDIR(data.st_mode)) {
		if (linked) {
		    linked = FALSE;
		    /*
		     * We assume that a properly-configured system has the
		     * unwritable directories owned by root.  This is not
		     * necessarily so (bin, news, etc., may), but the only
		     * uid we can count on is 0.  It would be nice to add a
		     * check for the gid also, but that wouldn't be
		     * portable.
		     */
		    if (data.st_uid != 0
			|| (data.st_mode & S_IWOTH) != 0) {
			linked = TRUE;	/* force an error-return */
			break;
		    }
		}
	    } else if (linked) {
		break;
	    }
	} while (leaf != path);
	FREE(path);
#endif
	result = (BOOLEAN) !linked;
    }
    CTRACE2(TRACE_CFG, (tfp, "IsOurFile(%s) %d\n", name, result));
    return result;
}

/*
 * Open a file that we don't want other users to see.
 */
static FILE *OpenHiddenFile(const char *name, const char *mode)
{
    FILE *fp = 0;
    struct stat data;
    BOOLEAN binary = (BOOLEAN) (StrChr(mode, 'b') != 0);

#if defined(O_CREAT) && defined(O_EXCL)		/* we have fcntl.h or kindred? */
    /*
     * This is the preferred method for creating new files, since it ensures
     * that no one has an existing file or link that they happen to own.
     */
    if (*mode == 'w') {
	int fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);

	if (fd < 0
	    && errno == EEXIST
	    && IsOurFile(name)) {
	    if (remove(name) == 0) {
		/* FIXME: there's a race at this point if directory is open */
		fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);
	    }
	}
	if (fd >= 0) {
#if defined(O_BINARY) && defined(__CYGWIN__)
	    if (binary)
		setmode(fd, O_BINARY);
#endif
	    fp = fdopen(fd, mode);
	}
    } else
#endif
    if (*mode == 'a') {
	if (IsOurFile(name)
	    && chmod(name, HIDE_CHMOD) == 0)
	    fp = fopen(name, mode);
	else if (lstat(name, &data) != 0)
	    fp = OpenHiddenFile(name, binary ? BIN_W : TXT_W);
	/*
	 * This is less stringent, but reasonably portable.  For new files, the
	 * umask will suffice; however if the file already exists we'll change
	 * permissions first, before opening it.  If the chmod fails because of
	 * some reason other than a non-existent file, there's no point in trying
	 * to open it.
	 *
	 * This won't work properly if the user is root, since the chmod succeeds.
	 */
    } else if (*mode != 'a') {
	mode_t save = umask(HIDE_UMASK);

	if (chmod(name, HIDE_CHMOD) == 0 || errno == ENOENT)
	    fp = fopen(name, mode);
	(void) umask(save);
    }
    return fp;
}
#else
#define OpenHiddenFile(name, mode) fopen(name, mode)
#endif /* MULTI_USER_UNIX */

FILE *LYNewBinFile(const char *name)
{
#ifdef VMS
    FILE *fp = fopen(name, BIN_W, "mbc=32");

    (void) chmod(name, HIDE_CHMOD);
#else
    FILE *fp = OpenHiddenFile(name, BIN_W);
#endif
    return fp;
}

FILE *LYNewTxtFile(const char *name)
{
    FILE *fp;

#ifdef VMS
    fp = fopen(name, TXT_W, "shr=get");
    (void) chmod(name, HIDE_CHMOD);
#else
    SetDefaultMode(O_TEXT);

    fp = OpenHiddenFile(name, TXT_W);

    SetDefaultMode(O_BINARY);
#endif

    return fp;
}

FILE *LYAppendToTxtFile(const char *name)
{
    FILE *fp;

#ifdef VMS
    fp = fopen(name, TXT_A, "shr=get");
    (void) chmod(name, HIDE_CHMOD);
#else
    SetDefaultMode(O_TEXT);

    fp = OpenHiddenFile(name, TXT_A);

    SetDefaultMode(O_BINARY);
#endif
    return fp;
}

#if defined(MULTI_USER_UNIX)
/*
 * Restore normal permissions to a copy of a file that we have created with
 * temp file restricted permissions.  The normal umask should apply for user
 * files.  - kw
 */
void LYRelaxFilePermissions(const char *name)
{
    mode_t mode;
    struct stat stat_buf;

    if (stat(name, &stat_buf) == 0 &&
	S_ISREG(stat_buf.st_mode) &&
	(mode = (stat_buf.st_mode & 0777)) == HIDE_CHMOD) {
	/*
	 * It looks plausible that this is a file we created with temp file
	 * paranoid permissions (and the umask wasn't even more restrictive
	 * when it was copied).  - kw
	 */
	mode_t save = umask(HIDE_UMASK);

	mode = ((mode & 0700) | 0066) & ~save;
	(void) umask(save);
	(void) chmod(name, mode);
    }
}
#endif

/*
 * Check if the given anchor has an associated file-cache.
 */
BOOLEAN LYCachedTemp(char *target,
		     char **cached)
{
    BOOLEAN result = FALSE;

    if (*cached) {
	LYStrNCpy(target, *cached, LY_MAXPATH);
	FREE(*cached);
	if (LYCanReadFile(target)) {
	    if (remove(target) != 0) {
		CTRACE((tfp, "cannot remove %s\n", target));
	    }
	}
	result = TRUE;
    }
    return result;
}

#ifndef HAVE_MKDTEMP
#define mkdtemp(path) ((mktemp(path) != 0) && (mkdir(path, 0700) == 0))
#endif

/*
 * Open a temp-file, ensuring that it is unique, and not readable by other
 * users.
 *
 * The mode can be one of: "w", "a", "wb".
 */
FILE *LYOpenTemp(char *result,
		 const char *suffix,
		 const char *mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    LY_TEMP *p;

    CTRACE((tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode));
    if (result == 0)
	return 0;

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
	default:
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return 0;
	}
    }

    /*
     * Verify if the given space looks secure enough.  Otherwise, make a
     * secure subdirectory of that.
     */
#if defined(MULTI_USER_UNIX) && (defined(HAVE_MKTEMP) || defined(HAVE_MKDTEMP))
    if (lynx_temp_subspace == 0) {
	BOOL make_it = FALSE;
	struct stat sb;

	if (lstat(lynx_temp_space, &sb) == 0
	    && S_ISDIR(sb.st_mode)) {
	    if (sb.st_uid != getuid()
		|| (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
		make_it = TRUE;
		CTRACE((tfp,
			"lynx_temp_space is not our directory %s owner %d mode %03o\n",
			lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
	    }
	} else {
	    make_it = TRUE;
	    CTRACE((tfp, "lynx_temp_space is not a directory %s\n", lynx_temp_space));
	}
	if (make_it) {
	    mode_t old_mask = umask(HIDE_UMASK);

	    StrAllocCat(lynx_temp_space, "lynxXXXXXXXXXX");
	    if (mkdtemp(lynx_temp_space) == 0) {
		printf("%s: %s\n", lynx_temp_space, LYStrerror(errno));
		exit_immediately(EXIT_FAILURE);
	    }
	    (void) umask(old_mask);
	    lynx_temp_subspace = 1;
	    StrAllocCat(lynx_temp_space, "/");
	    CTRACE((tfp, "made subdirectory %s\n", lynx_temp_space));
	} else {
	    lynx_temp_subspace = -1;
	}
    }
#endif

    do {
	if (!fmt_tempname(result, lynx_temp_space, suffix))
	    return 0;
	if (txt) {
	    switch (wrt) {
	    case 'w':
		fp = LYNewTxtFile(result);
		break;
	    case 'a':
		fp = LYAppendToTxtFile(result);
		break;
	    }
	} else {
	    fp = LYNewBinFile(result);
	}
	/*
	 * If we get a failure to make a temporary file, don't bother to try a
	 * different name unless the failure was because the file already
	 * exists.
	 */
#ifdef EEXIST			/* FIXME (need a better test) in fcntl.h or unistd.h */
	if ((fp == 0) && (errno != EEXIST)) {
	    CTRACE((tfp, "... LYOpenTemp(%s) failed: %s\n",
		    result, LYStrerror(errno)));
	    return 0;
	}
#endif
    } while (fp == 0);

    if ((p = typecalloc(LY_TEMP)) != 0) {
	p->next = ly_temp;
	StrAllocCopy((p->name), result);
	p->file = fp;
	p->outs = (BOOLEAN) (wrt != 'r');
	ly_temp = p;
    } else {
	outofmem(__FILE__, "LYOpenTemp");
    }

    CTRACE((tfp, "... LYOpenTemp(%s)\n", result));
    return fp;
}

/*
 * Reopen a temporary file
 */
FILE *LYReopenTemp(char *name)
{
    LY_TEMP *p;
    FILE *fp = 0;

    LYCloseTemp(name);
    if ((p = FindTempfileByName(name)) != 0) {
	fp = p->file = LYAppendToTxtFile(name);
    }
    return fp;
}

/*
 * Open a temp-file for writing, possibly re-using a previously used
 * name and file.
 * If a non-empty fname is given, it is reused if it indicates a file
 * previously registered as a temp file and, in case the file still
 * exists, if it looks like we can write to it safely.  Otherwise a
 * new temp file (with new name) will be generated and returned in fname.
 *
 * File permissions are set so that the file is not readable by unprivileged
 * other users.
 *
 * Suffix is only used if fname is not being reused.
 * The mode should be "w", others are possible (they may be passed on)
 * but probably don't make sense. - kw
 */
FILE *LYOpenTempRewrite(char *fname,
			const char *suffix,
			const char *mode)
{
    FILE *fp = 0;
    BOOL txt = TRUE;
    char wrt = 'r';
    BOOL registered = NO;
    BOOL writable_exists = NO;
    BOOL is_ours = NO;
    BOOL still_open = NO;
    LY_TEMP *p;
    struct stat stat_buf;

    CTRACE((tfp, "LYOpenTempRewrite(%s,%s,%s)\n", fname, suffix, mode));
    if (*fname == '\0')		/* first time, no filename yet */
	return (LYOpenTemp(fname, suffix, mode));

    if ((p = FindTempfileByName(fname)) != 0) {
	registered = YES;
	if (p->file != 0)
	    still_open = YES;
	CTRACE((tfp, "...used before%s\n", still_open ? ", still open!" : "."));
    }

    if (registered) {
#ifndef NO_GROUPS
	writable_exists = HTEditable(fname);	/* existing, can write */
#define CTRACE_EXISTS "exists and is writable, "
#else
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0);		/* existing, assume can write */
#define CTRACE_EXISTS "exists, "
#endif

	if (writable_exists) {
	    is_ours = IsOurFile(fname);
	}
	CTRACE((tfp, "...%s%s\n",
		writable_exists ? CTRACE_EXISTS : "",
		is_ours ? "is our file." : "is NOT our file."));
    }

    /*
     * Note that in cases where LYOpenTemp is called as fallback below, we
     * don't call LYRemoveTemp first.  That may be appropriate in some cases,
     * but not trying to remove a weird existing file seems safer and could
     * help diagnose an unusual situation.  (They may be removed anyway later.)
     */
    if (still_open) {
	/*
	 * This should probably not happen.  Make a new one.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (!registered) {
	/*
	 * Not registered.  It should have been registered at one point though,
	 * otherwise we wouldn't be called like this.
	 */
	return (LYOpenTemp(fname, suffix, mode));
    } else if (writable_exists && !is_ours) {
	/*
	 * File exists, writable if we checked, but something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#ifndef NO_GROUPS
    } else if (!is_ours && (lstat(fname, &stat_buf) == 0)) {
	/*
	 * Exists but not writable, and something is wrong with it.
	 */
	return (LYOpenTemp(fname, suffix, mode));
#endif
    }

    while (*mode != '\0') {
	switch (*mode++) {
	case 'w':
	    wrt = 'w';
	    break;
	case 'a':
	    wrt = 'a';
	    break;
	case 'b':
	    txt = FALSE;
	    break;
	default:
	    CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
	    return fp;
	}
    }

    if (is_ours) {
	/*
	 * Yes, it exists, is writable if we checked, and everything looks ok
	 * so far.  This should be the most regular case.  - kw
	 */
#ifdef HAVE_TRUNCATE
	if (txt == TRUE) {	/* limitation of LYReopenTemp.  shrug */
	    /*
	     * We truncate and then append, this avoids having a small window
	     * in which the file doesn't exist.  - kw
	     */
	    if (truncate(fname, (off_t) 0) != 0) {
		CTRACE((tfp, "... truncate(%s,0) failed: %s\n",
			fname, LYStrerror(errno)));
		return (LYOpenTemp(fname, suffix, mode));
	    } else {
		return (LYReopenTemp(fname));
	    }
	}
#endif
	remove(fname);

    }

    /* We come here in two cases:  either the file existed and was ours and we
     * just got rid of it.  Or the file did and does not exist, but is
     * registered as a temp file.  It must have been removed by some means
     * other than LYRemoveTemp.  In both cases, reuse the name!  - kw
     */

    if (txt) {
	switch (wrt) {
	case 'w':
	    fp = LYNewTxtFile(fname);
	    break;
	case 'a':
	    fp = LYAppendToTxtFile(fname);
	    break;
	}
    } else {
	fp = LYNewBinFile(fname);
    }
    p->file = fp;

    CTRACE((tfp, "... LYOpenTempRewrite(%s), %s\n", fname,
	    (fp) ? "ok" : "failed"));
    /*
     * We could fall back to trying LYOpenTemp() here in case of failure. 
     * After all the checks already done above a filure here should be pretty
     * unusual though, so maybe it's better to let the user notice that
     * something went wrong, and not try to fix it up.  - kw
     */
    return fp;
}

/*
 * Special case of LYOpenTemp, used for manipulating bookmark file, i.e., with
 * renaming.
 */
FILE *LYOpenScratch(char *result,
		    const char *prefix)
{
    FILE *fp;
    LY_TEMP *p;

    if (!fmt_tempname(result, prefix, HTML_SUFFIX))
	return 0;

    if ((fp = LYNewTxtFile(result)) != 0) {
	if ((p = typecalloc(LY_TEMP)) != 0) {
	    p->next = ly_temp;
	    StrAllocCopy((p->name), result);
	    p->file = fp;
	    ly_temp = p;
	} else {
	    outofmem(__FILE__, "LYOpenScratch");
	}
    }
    CTRACE((tfp, "LYOpenScratch(%s)\n", result));
    return fp;
}

static void LY_close_temp(LY_TEMP * p)
{
    if (p->file != 0) {
	if (p->outs) {
	    LYCloseOutput(p->file);
	} else {
	    LYCloseInput(p->file);
	}
	p->file = 0;
    }
}

/*
 * Close a temp-file, given its name
 */
void LYCloseTemp(char *name)
{
    LY_TEMP *p;

    CTRACE((tfp, "LYCloseTemp(%s)\n", name));
    if ((p = FindTempfileByName(name)) != 0) {
	CTRACE((tfp, "...LYCloseTemp(%s)%s\n", name,
		(p->file != 0) ? ", closed" : ""));
	LY_close_temp(p);
    }
}

/*
 * Close a temp-file, given its file-pointer
 */
void LYCloseTempFP(FILE *fp)
{
    LY_TEMP *p;

    CTRACE((tfp, "LYCloseTempFP\n"));
    if ((p = FindTempfileByFP(fp)) != 0) {
	LY_close_temp(p);
	CTRACE((tfp, "...LYCloseTempFP(%s)\n", p->name));
    }
}

/*
 * Close a temp-file, removing it.
 */
int LYRemoveTemp(char *name)
{
    LY_TEMP *p, *q;
    int code = -1;

    if (non_empty(name)) {
	CTRACE((tfp, "LYRemoveTemp(%s)\n", name));
	for (p = ly_temp, q = 0; p != 0; q = p, p = p->next) {
	    if (!strcmp(name, p->name)) {
		if (q != 0) {
		    q->next = p->next;
		} else {
		    ly_temp = p->next;
		}
		LY_close_temp(p);
		code = HTSYS_remove(name);
		CTRACE((tfp, "...LYRemoveTemp done(%d)%s\n", code,
			(p->file != 0) ? ", closed" : ""));
		CTRACE_FLUSH(tfp);
		FREE(p->name);
		FREE(p);
		break;
	    }
	}
    }
    return code;
}

/*
 * Remove all of the temp-files.  Note that this assumes that they are closed,
 * since some systems will not allow us to remove a file which is open.
 */
void LYCleanupTemp(void)
{
    while (ly_temp != 0) {
	(void) LYRemoveTemp(ly_temp->name);
    }
#if defined(MULTI_USER_UNIX)
    if (lynx_temp_subspace > 0) {
	char result[LY_MAXPATH];

	LYStrNCpy(result, lynx_temp_space, sizeof(result) - 1);
	LYTrimPathSep(result);
	CTRACE((tfp, "LYCleanupTemp removing %s\n", result));
	rmdir(result);
	lynx_temp_subspace = -1;
    }
#endif
}

/*
 * We renamed a temporary file.  Keep track so we can remove it on exit.
 */
void LYRenamedTemp(char *oldname,
		   char *newname)
{
    LY_TEMP *p;

    CTRACE((tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname));
    if ((p = FindTempfileByName(oldname)) != 0) {
	StrAllocCopy((p->name), newname);
    }
}

#ifndef DISABLE_BIBP
/*
 * Check that bibhost defines the BibP icon.
 */
void LYCheckBibHost(void)
{
    DocAddress bibhostIcon;
    BOOLEAN saveFlag;

    bibhostIcon.address = NULL;
    StrAllocCopy(bibhostIcon.address, BibP_bibhost);
    StrAllocCat(bibhostIcon.address, "bibp1.0/bibpicon.jpg");
    bibhostIcon.post_data = NULL;
    bibhostIcon.post_content_type = NULL;
    bibhostIcon.bookmark = FALSE;
    bibhostIcon.isHEAD = FALSE;
    bibhostIcon.safe = FALSE;
    saveFlag = traversal;
    traversal = TRUE;		/* Hack to force error response. */
    BibP_bibhost_available = (BOOLEAN) (HTLoadAbsolute(&bibhostIcon) == YES);
    traversal = saveFlag;
    BibP_bibhost_checked = TRUE;
}
#endif /* !DISABLE_BIBP */

/*
 * Management of User Interface Pages.  - kw
 *
 * These are mostly temp files.  Pages which can be recognized by their special
 * URL (after having been loaded) need not be tracked here.
 *
 * First some private stuff:
 */
typedef struct uipage_entry {
    UIP_t type;
    unsigned flags;
    char *url;
    HTList *alturls;
    char *file;
} uip_entry;

#define UIP_F_MULTI	0x0001	/* flag: track multiple instances */
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturls list */
#define UIP_F_LMULTI   (UIP_F_MULTI | UIP_F_LIMIT)
/* *INDENT-OFF* */
static uip_entry ly_uip[] =
{
    { UIP_HISTORY		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_DOWNLOAD_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_PRINT_OPTIONS		, 0	      , NULL, NULL, NULL }
  , { UIP_SHOWINFO		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_LIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
  , { UIP_VLINKS		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_OPTION_FORMS)
  , { UIP_OPTIONS_MENU		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef DIRED_SUPPORT
  , { UIP_DIRED_MENU		, 0	      , NULL, NULL, NULL }
  , { UIP_PERMIT_OPTIONS	, 0	      , NULL, NULL, NULL }
  , { UIP_UPLOAD_OPTIONS	, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
#ifdef USE_ADDRLIST_PAGE
  , { UIP_ADDRLIST_PAGE		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
  , { UIP_LYNXCFG		, UIP_F_LMULTI, NULL, NULL, NULL }
#if !defined(NO_CONFIG_INFO)
  , { UIP_CONFIG_DEF		, UIP_F_LMULTI, NULL, NULL, NULL }
#endif
/* The following are not generated tempfiles: */
  , { UIP_TRACELOG		, 0	     , NULL, NULL, NULL }
#if defined(DIRED_SUPPORT) && defined(OK_INSTALL)
  , { UIP_INSTALL		, 0	     , NULL, NULL, NULL }
#endif

};
/* *INDENT-ON* */

/*  Public entry points for User Interface Page management: */

BOOL LYIsUIPage3(const char *url,
		 UIP_t type,
		 int flagparam)
{
    unsigned int i;
    size_t l;
    BOOL result = NO;

    if (url) {
	for (i = 0; i < TABLESIZE(ly_uip); i++) {
	    if (ly_uip[i].type == type) {
		if (!ly_uip[i].url) {
		    break;
		} else if ((flagparam & UIP_P_FRAG) ?
			   (!StrNCmp(ly_uip[i].url, url, (l = strlen(ly_uip[i].url)))
			    && (url[l] == '\0' || url[l] == '#')) :
			   !strcmp(ly_uip[i].url, url)) {
		    result = YES;
		} else if (ly_uip[i].flags & UIP_F_MULTI) {
		    char *p;
		    HTList *l0 = ly_uip[i].alturls;

		    while ((p = (char *) HTList_nextObject(l0)) != NULL) {
			if ((flagparam & UIP_P_FRAG)
			    ? (!StrNCmp(p, url, (l = strlen(p))) &&
			       (url[l] == '\0' || url[l] == '#'))
			    : !strcmp(p, url)) {
			    result = YES;
			    break;
			}
		    }
		}
		break;
	    }
	}
    }
    return result;
}

void LYRegisterUIPage(const char *url,
		      UIP_t type)
{
    unsigned int i;

    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (ly_uip[i].url && url &&
		!strcmp(ly_uip[i].url, url)) {

	    } else if (!ly_uip[i].url || !url ||
		       !(ly_uip[i].flags & UIP_F_MULTI)) {
		StrAllocCopy(ly_uip[i].url, url);

	    } else {
		char *p;
		int n = 0;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = (char *) HTList_nextObject(l0)) != NULL) {
		    if (!strcmp(p, url))
			return;
		    if (!strcmp(p, ly_uip[i].url)) {
			StrAllocCopy(ly_uip[i].url, url);
			return;
		    }
		    n++;
		}
		if (!ly_uip[i].alturls)
		    ly_uip[i].alturls = HTList_new();

		if (n >= HTCacheSize && (ly_uip[i].flags & UIP_F_LIMIT))
		    HTList_removeFirstObject(ly_uip[i].alturls);
		HTList_addObject(ly_uip[i].alturls, ly_uip[i].url);
		ly_uip[i].url = NULL;
		StrAllocCopy(ly_uip[i].url, url);
	    }

	    return;
	}
    }
}

void LYUIPages_free(void)
{
    unsigned int i;

    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	FREE(ly_uip[i].url);
	FREE(ly_uip[i].file);
	LYFreeStringList(ly_uip[i].alturls);
	ly_uip[i].alturls = NULL;
    }
}

/*
 * Convert local pathname to www name
 * (do not bother about file://localhost prefix at this point).
 */
const char *wwwName(const char *pathname)
{
    const char *cp = NULL;

#if defined(USE_DOS_DRIVES)
    cp = HTDOS_wwwName(pathname);
#else
#ifdef VMS
    cp = HTVMS_wwwName(pathname);
#else
    cp = pathname;
#endif /* VMS */
#endif

    return cp;
}

/*
 * Given a user-specified filename, e.g., for download or print, validate and
 * expand it.  Expand home-directory expressions in the given string.  Only
 * allow pipes if the user can spawn shell commands.
 */
BOOLEAN LYValidateFilename(bstring **result,
			   bstring **given)
{
    BOOLEAN code = TRUE;
    char *cp = NULL;

    /*
     * Cancel if the user entered "/dev/null" on Unix, or an "nl:" path on VMS. 
     * - FM
     */
    if (LYIsNullDevice((*given)->str)) {
	/* just ignore it */
	code = FALSE;
#ifdef HAVE_POPEN
    } else if (LYIsPipeCommand((*given)->str)) {
	if (no_shell) {
	    HTUserMsg(SPAWNING_DISABLED);
	    code = FALSE;
	} else {
	    BStrCopy(*result, (*given));
	}
#endif
    } else {
	if (FindLeadingTilde((*given)->str, TRUE) != 0) {
	    char *cp1 = NULL;

	    StrAllocCopy(cp1, (*given)->str);
	    LYTildeExpand(&cp1, TRUE);
	    BStrCopy0(*result, cp1);
	    BStrCopy0(*given, cp1);
	    FREE(cp1);
	}
#ifdef VMS
	if (StrChr((*given)->str, '/') != NULL) {
	    BStrCopy0(*result, HTVMS_name("", (*given)->str));
	    BStrCopy(*given, *result);
	}
	if ((*given)->str[0] != '/'
	    && StrChr((*given)->str, ':') == NULL) {
	    BStrCopy0(*result, "sys$disk:");
	    if (StrChr((*given)->str, ']') == NULL)
		BStrCat0(*result, "[]");
	    BStrCat(*result, (*given));
	} else {
	    BStrCopy(*result, (*given));
	}
#else

#ifndef __EMX__
	if (!LYisAbsPath((*given)->str)) {
#if defined(__DJGPP__) || defined(_WINDOWS)
	    if (StrChr((*result)->str, ':') != NULL)
		cp = NULL;
	    else
#endif /*  __DJGPP__ || _WINDOWS */
	    {
#ifdef SUPPORT_CHDIR
		static char buf[LY_MAXPATH];

		cp = Current_Dir(buf);
#else
		cp = original_dir;
#endif
	    }
	} else
#endif /* __EMX__ */
	    cp = NULL;

	if (cp) {
	    LYTrimPathSep(cp);
	    BStrCopy0(*result, cp);
	    BStrCat0(*result, "/");
	} else {
	    BStrCopy0(*result, "");
	}
	if (code) {
	    cp = HTSYS_name((*given)->str);
	    BStrCat0(*result, cp);
	}
#endif /* VMS */
    }
    return code;
}

/*
 * Given a valid filename, check if it exists.  If so, we'll have to worry
 * about overwriting it.
 *
 * Returns:
 *	'Y' (yes/success)
 *	'N' (no/retry)
 *	3   (cancel)
 */
int LYValidateOutput(char *filename)
{
    int c;

    CTRACE((tfp, "LYValidateOutput '%s'\n", filename));

    /*
     * Assume we can write to a pipe
     */
#ifdef HAVE_POPEN
    if (LYIsPipeCommand(filename))
	return 'Y';
#endif

    if (no_dotfiles || !show_dotfiles) {
	if (*LYPathLeaf(filename) == '.') {
	    HTAlert(FILENAME_CANNOT_BE_DOT);
	    return 'N';
	}
    }

    /*
     * See if it already exists.
     */
    if (LYCanReadFile(filename)) {
#ifdef VMS
	c = HTConfirm(FILE_EXISTS_HPROMPT);
#else
	c = HTConfirm(FILE_EXISTS_OPROMPT);
#endif /* VMS */
	if (HTLastConfirmCancelled()) {
	    HTInfoMsg(SAVE_REQUEST_CANCELLED);
	    return 3;
	} else if (c == NO) {
	    return 'N';
	}
    } else if (!LYCanWriteFile(filename)) {
	return 'N';
    }
    return 'Y';
}

/*
 * Convert a local filename to a URL
 */
void LYLocalFileToURL(char **target,
		      const char *source)
{
    const char *leaf;

    StrAllocCopy(*target, "file://localhost");

    leaf = wwwName(source);

    if (!LYisAbsPath(source)) {
	char temp[LY_MAXPATH];

	Current_Dir(temp);
	if (!LYIsHtmlSep(*temp))
	    LYAddHtmlSep(target);
	StrAllocCat(*target, temp);
    }
    if (leaf && !LYIsHtmlSep(*leaf))
	LYAddHtmlSep(target);
    StrAllocCat(*target, leaf);
}

#define MY_DOCTYPE "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
#define PUT_STRING(buf)    (*(target)->isa->put_string)(target, buf)

/*
 * Like WriteInternalTitle, used for writing title on pages constructed via
 * streams.
 */
void WriteStreamTitle(HTStream *target, const char *Title)
{
    char *buf = 0;

    PUT_STRING(MY_DOCTYPE);
    PUT_STRING("<html>\n<head>\n");
    LYAddMETAcharsetToStream(target, -1);
    HTSprintf0(&buf, "<title>%s</title>\n</head>\n<body>\n", Title);
    PUT_STRING(buf);
    FREE(buf);
}

/*
 * Open a temporary file for internal-pages, optionally reusing an existing
 * filename.
 */
FILE *InternalPageFP(char *filename,
		     int reuse_flag)
{
    FILE *fp;

    if (LYReuseTempfiles && reuse_flag) {
	fp = LYOpenTempRewrite(filename, HTML_SUFFIX, BIN_W);
    } else {
	(void) LYRemoveTemp(filename);
	fp = LYOpenTemp(filename, HTML_SUFFIX, BIN_W);
    }
    if (fp == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
    }
    return fp;
}

/*
 * This part is shared by all internal pages.
 */
void WriteInternalTitle(FILE *fp0, const char *Title)
{
    fprintf(fp0, MY_DOCTYPE);

    fprintf(fp0, "<html>\n<head>\n");
    LYAddMETAcharsetToFD(fp0, -1);
    if (LYIsListpageTitle(Title)) {
	if (StrChr(HTLoadedDocumentURL(), '"') == NULL) {
	    char *Address = NULL;

	    /*
	     * Insert a BASE tag so there is some way to relate the List Page
	     * file to its underlying document after we are done.  It won't be
	     * actually used for resolving relative URLs.  - kw
	     */
	    StrAllocCopy(Address, HTLoadedDocumentURL());
	    LYEntify(&Address, FALSE);
	    fprintf(fp0, "<base href=\"%s\">\n", Address);
	    FREE(Address);
	}
    }
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n", Title);
}

/*
 * This is used to start most internal pages, except for special cases where
 * the embedded HREF's in the title differ.
 */
void BeginInternalPage(FILE *fp0, const char *Title,
		       const char *HelpURL)
{
    WriteInternalTitle(fp0, Title);

    if ((user_mode == NOVICE_MODE)
	&& LYwouldPush(Title, NULL)
	&& (HelpURL != 0)) {
	fprintf(fp0, "<h1>%s (%s%s%s), <a href=\"%s%s\">help</a></h1>\n",
		Title, LYNX_NAME, VERSION_SEGMENT, LYNX_VERSION,
		helpfilepath, HelpURL);
    } else {
	fprintf(fp0, "<h1>%s (%s%s%s)</h1>\n",
		Title, LYNX_NAME, VERSION_SEGMENT, LYNX_VERSION);
    }
}

void EndInternalPage(FILE *fp0)
{
    fprintf(fp0, "</body>\n</html>");
}

char *trimPoundSelector(char *address)
{
    char *pound = findPoundSelector(address);

    if (pound != 0)
	*pound = '\0';
    return pound;
}

/*
 * Trim a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to local filesystems.
 */
void LYTrimPathSep(char *path)
{
    size_t len;

    if (path != 0
	&& (len = strlen(path)) != 0
	&& LYIsPathSep(path[len - 1]))
	path[len - 1] = 0;
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to local filesystems.
 */
void LYAddPathSep(char **path)
{
    size_t len;
    char *temp;

    if ((path != 0)
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsPathSep(temp[len - 1])) {
	StrAllocCat(*path, FILE_SEPARATOR);
    }
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to local filesystems.
 */
void LYAddPathSep0(char *path)
{
    size_t len;

    if ((path != 0)
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsPathSep(path[len - 1])) {
	strcat(path, FILE_SEPARATOR);
    }
}

/*
 * Check if a given string contains a path separator
 */
char *LYLastPathSep(const char *path)
{
    char *result;

#if defined(USE_DOS_DRIVES)
    if ((result = strrchr(path, '\\')) == 0)
	result = strrchr(path, '/');
#else
    result = strrchr(path, '/');
#endif
    return result;
}

/*
 * Trim a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to HTML paths.
 */
void LYTrimHtmlSep(char *path)
{
    size_t len;

    if (path != 0
	&& (len = strlen(path)) != 0
	&& LYIsHtmlSep(path[len - 1]))
	path[len - 1] = 0;
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to HTML paths.
 */
void LYAddHtmlSep(char **path)
{
    size_t len;
    char *temp;

    if ((path != 0)
	&& ((temp = *path) != 0)
	&& (len = strlen(temp)) != 0
	&& !LYIsHtmlSep(temp[len - 1])) {
	StrAllocCat(*path, "/");
    }
}

/*
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
 * to it.  This only applies to HTML paths.
 */
void LYAddHtmlSep0(char *path)
{
    size_t len;

    if ((path != 0)
	&& (len = strlen(path)) != 0
	&& (len < LY_MAXPATH - 2)
	&& !LYIsHtmlSep(path[len - 1])) {
	strcat(path, "/");
    }
}

/*
 * Copy a file
 */
int LYCopyFile(char *src,
	       char *dst)
{
    int code;
    const char *program;

    if ((program = HTGetProgramPath(ppCOPY)) != NULL) {
	char *the_command = 0;

	HTAddParam(&the_command, COPY_COMMAND, 1, program);
	HTAddParam(&the_command, COPY_COMMAND, 2, src);
	HTAddParam(&the_command, COPY_COMMAND, 3, dst);
	HTEndParam(&the_command, COPY_COMMAND, 3);

	CTRACE((tfp, "command: %s\n", the_command));
	stop_curses();
	code = LYSystem(the_command);
	start_curses();

	FREE(the_command);
    } else {
	FILE *fin, *fout;
	unsigned char buff[BUFSIZ];
	size_t len;

	code = EOF;
	if ((fin = fopen(src, BIN_R)) != 0) {
	    if ((fout = fopen(dst, BIN_W)) != 0) {
		code = 0;
		while ((len = fread(buff, (size_t) 1, sizeof(buff), fin)) != 0) {
		    if (fwrite(buff, (size_t) 1, len, fout) < len
			|| ferror(fout)) {
			code = EOF;
			break;
		    }
		}
		LYCloseOutput(fout);
	    }
	    LYCloseInput(fin);
	}
	CTRACE((tfp, "builtin copy ->%d\n\tsource=%s\n\ttarget=%s\n",
		code, src, dst));
    }

    if (code) {
	HTAlert(CANNOT_WRITE_TO_FILE);
    }
    return code;
}

#ifdef __DJGPP__
static char *escape_backslashes(char *source)
{
    char *result = 0;
    int count = 0;
    int n;

    for (n = 0; source[n] != '\0'; ++n) {
	if (source[n] == '\\')
	    ++count;
    }
    if (count != 0) {
	result = malloc(count + n + 1);
	if (result != 0) {
	    int ch;
	    char *target = result;

	    while ((ch = *source++) != '\0') {
		if (ch == '\\')
		    *target++ = ch;
		*target++ = ch;
	    }
	    *target = '\0';
	}
    }
    return result;
}
#endif /* __DJGPP__ */
/*
 * Invoke a shell command, return nonzero on error.
 */
int LYSystem(char *command)
{
    int code;
    int do_free = 0;

#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    struct sigaction saved_sigtstp_act;
    BOOLEAN sigtstp_saved = FALSE;
#endif
    int saved_errno = 0;

#ifdef __EMX__
    int scrsize[4];
#endif

    fflush(stdout);
    fflush(stderr);
    CTRACE((tfp, "LYSystem(%s)\n", command));
    CTRACE_FLUSH(tfp);

#ifdef __DJGPP__
    __djgpp_set_ctrl_c(0);
    _go32_want_ctrl_break(1);
#endif /* __DJGPP__ */

#ifdef VMS
    code = DCLsystem(command);
#else
#  ifdef __EMX__		/* FIXME: Should be LY_CONVERT_SLASH? */
    /* Configure writes commands which contain direct slashes.
       Native command-(non)-shell will not tolerate this. */
    {
	char *space = command, *slash = command;

	_scrsize(scrsize);
	while (*space && *space != ' ' && *space != '\t')
	    space++;
	while (slash < space && *slash != '/')
	    slash++;
	if (slash != space) {
	    char *old = command;

	    command = NULL;
	    StrAllocCopy(command, old);
	    do_free = 1;
	    slash = (slash - old) + command - 1;
	    space = (space - old) + command;
	    while (++slash < space)
		if (*slash == '/')
		    *slash = '\\';
	}
    }
#  endif

    /*
     * This chunk of code does not work, for two reasons:
     * a) the Cygwin system() function edits out the backslashes
     * b) it does not account for more than one parameter, e.g., +number
     */
#if defined(__CYGWIN__) && defined(DOSPATH)	/* 1999/02/26 (Fri) */
    {
	char cmd[LY_MAXPATH];
	char win32_name[LY_MAXPATH];
	char new_cmd[LY_MAXPATH];
	char new_command[LY_MAXPATH * 2 + 10];
	char *p, *q;

	p = command;
	q = cmd;
	while (*p) {
	    if (*p == ' ')
		break;
	    else
		*q = *p;
	    p++;
	    q++;
	}
	*q = '\0';

	if (cmd[0] == '/')
	    cygwin_conv_to_full_posix_path(cmd, new_cmd);
	else
	    strcpy(new_cmd, cmd);

	while (*p == ' ')
	    p++;

	if (StrChr(p, '\\') == NULL) {
	    /* for Windows Application */
	    cygwin_conv_to_full_win32_path(p, win32_name);
	    sprintf(new_command, "%.*s \"%.*s\"",
		    LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	} else {
	    /* for DOS like editor */
	    q = win32_name;
	    while (*p) {
		if (*p == '\\') {
		    if (*(p + 1) == '\\')
			p++;
		}
		*q = *p;
		q++, p++;
	    }
	    *q = '\0';
	    sprintf(new_command, "%.*s %.*s", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
	}
	command = new_command;
    }
#endif

#ifdef __DJGPP__
    if (dj_is_bash) {
	char *new_command = escape_backslashes(command);

	if (new_command != 0) {
	    if (do_free)
		free(command);
	    command = new_command;
	}
    }
#endif /* __DJGPP__ */

#ifdef _WIN_CC
    code = exec_command(command, TRUE);		/* Wait exec */
#else /* !_WIN_CC */
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_DFL);	/* Some commands expect the default */
#endif
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (!dump_output_immediately && !LYCursesON && !no_suspend)
	sigtstp_saved = LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 1);
#endif
    code = system(command);
    saved_errno = errno;
#if defined(HAVE_SIGACTION) && defined(SIGTSTP) && !defined(USE_SLANG)
    if (sigtstp_saved)
	LYToggleSigDfl(SIGTSTP, &saved_sigtstp_act, 0);
#endif
#ifdef SIGPIPE
    if (restore_sigpipe_for_children)
	signal(SIGPIPE, SIG_IGN);	/* Ignore it again - kw */
#endif
#endif
#endif

#ifdef __DJGPP__
    __djgpp_set_ctrl_c(1);
    _go32_want_ctrl_break(0);
#endif /* __DJGPP__ */

    fflush(stdout);
    fflush(stderr);

    if (do_free)
	FREE(command);
#if !defined(UCX) || !defined(VAXC)	/* errno not modifiable ?? */
    set_errno(saved_errno);	/* may have been clobbered */
#endif
#ifdef __EMX__			/* Check whether the screen size changed */
    size_change(0);
#endif
    return code;
}

/*
 * Return a string which can be used in LYSystem() for spawning a subshell
 */
#if defined(__CYGWIN__)		/* 1999/02/26 (Fri) */
int Cygwin_Shell(void)
{
    char *shell;
    int code;
    STARTUPINFO startUpInfo;
    PROCESS_INFORMATION procInfo;
    SECURITY_ATTRIBUTES sa;

    /* Set up security attributes to allow inheritance of the file handle */

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = 0;
    sa.bInheritHandle = TRUE;

    /* Init a startup structure */
    GetStartupInfo(&startUpInfo);

    shell = LYGetEnv("COMSPEC");

    /* Create the child process, specifying
       inherited handles. Pass the value of the
       handle as a command line parameter */
    code = 0;
    if (shell) {
	code = CreateProcess(0, shell, 0, 0,
			     TRUE, 0,
			     0, 0, &startUpInfo, &procInfo);

	if (!code) {
	    printf("shell = [%s], code = %ld\n", shell, (long) GetLastError());
	}

	/* wait for the child to return (this is not a requirement
	   since the child is its own independent process) */
	WaitForSingleObject(procInfo.hProcess, INFINITE);
    }

    return code;
}
#endif

#ifdef WIN_EX
/*
 * Quote the path to make it safe for shell command processing.
 *  We always quote it not only includes spaces in it.
 *  At least we should quote paths which include "&".
 */
char *quote_pathname(char *pathname)
{
    char *result = NULL;

    HTSprintf0(&result, "\"%s\"", pathname);
    return result;
}
#endif

const char *LYSysShell(void)
{
    const char *shell = 0;

#ifdef DOSPATH
#ifdef WIN_EX
    shell = LYGetEnv("SHELL");
    if (shell) {
	if (access(shell, 0) != 0)
	    shell = LYGetEnv("COMSPEC");
    } else {
	shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	if (system_is_NT)
	    shell = "cmd.exe";
	else
	    shell = "command.com";
    }
#else
    shell = LYGetEnv("SHELL");
    if (shell == NULL) {
	shell = LYGetEnv("COMSPEC");
    }
    if (shell == NULL) {
	shell = "command.com";
    }
#endif /* WIN_EX */
#else
#ifdef __EMX__
    if (LYGetEnv("SHELL") != NULL) {
	shell = LYGetEnv("SHELL");
    } else {
	shell = (LYGetEnv("COMSPEC") == NULL) ? "cmd.exe" : LYGetEnv("COMSPEC");
    }
#else
#ifdef VMS
    shell = "";
#else
    shell = "exec $SHELL";
#endif /* __EMX__ */
#endif /* VMS */
#endif /* DOSPATH */
    return shell;
}

#ifdef VMS
#define DISPLAY "DECW$DISPLAY"
#else
#define DISPLAY "DISPLAY"
#endif /* VMS */

/*
 * Return the X-Window $DISPLAY string if it is nonnull/nonempty
 */
char *LYgetXDisplay(void)
{
    return LYGetEnv(DISPLAY);
}

/*
 * Set the value of the X-Window $DISPLAY variable (yes it leaks memory, but
 * that is putenv's fault).
 */
void LYsetXDisplay(char *new_display)
{
    if (new_display != 0) {
#ifdef VMS
	LYUpperCase(new_display);
	Define_VMSLogical(DISPLAY, new_display);
#else
	static char *display_putenv_command;

	display_putenv_command = NULL;	/* yes, this is a leak - cannot fix */
	HTSprintf0(&display_putenv_command, "DISPLAY=%s", new_display);
	putenv(display_putenv_command);
#endif /* VMS */
	if ((new_display = LYgetXDisplay()) != 0) {
	    StrAllocCopy(x_display, new_display);
	}
    }
}

#ifdef CAN_CUT_AND_PASTE
#ifdef __EMX__

static int proc_type = -1;
static PPIB pib;
static HAB hab;
static HMQ hmq;

static void morph_PM(void)
{
    PTIB tib;
    int first = 0;

    if (proc_type == -1) {
	DosGetInfoBlocks(&tib, &pib);
	proc_type = pib->pib_ultype;
	first = 1;
    }
    if (pib->pib_ultype != 3)	/* 2 is VIO */
	pib->pib_ultype = 3;	/* 3 is PM */
    if (first)
	hab = WinInitialize(0);
    /* 64 messages if before OS/2 3.0, ignored otherwise */
    hmq = WinCreateMsgQueue(hab, 64);
    WinCancelShutdown(hmq, 1);	/* Do not inform us on shutdown */
}

static void unmorph_PM(void)
{
    WinDestroyMsgQueue(hmq);
    pib->pib_ultype = proc_type;
}

int size_clip(void)
{
    return 8192;
}

/* Code partially stolen from FED editor. */

int put_clip(const char *s)
{
    int sz = strlen(s) + 1;
    int ret = EOF, nl = 0;
    char *pByte = 0, *s1 = s, c, *t;

    while ((c = *s1++)) {
	if (c == '\r' && *s1 == '\n')
	    s1++;
	else if (c == '\n')
	    nl++;
    }
    if (DosAllocSharedMem((PPVOID) & pByte, 0, sz + nl,
			  PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE))
	return ret;

    if (!nl)
	memcpy(pByte, s, sz);
    else {
	t = pByte;
	while ((c = *t++ = *s++))
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
    }

    morph_PM();
    if (!hab)
	goto fail;

    WinOpenClipbrd(hab);
    WinEmptyClipbrd(hab);
    if (WinSetClipbrdData(hab, (ULONG) pByte, CF_TEXT, CFI_POINTER))
	ret = 0;
    WinCloseClipbrd(hab);
    unmorph_PM();
    if (ret == 0)
	return 0;
  fail:
    DosFreeMem((PPVOID) & pByte);
    return EOF;
}

static int clip_open;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

char *get_clip_grab(void)
{
    char *ClipData;
    ULONG ulFormat;
    int sz;

    morph_PM();
    if (!hab)
	return 0;
    if (clip_open)
	get_clip_release();

    WinQueryClipbrdFmtInfo(hab, CF_TEXT, &ulFormat);
    if (ulFormat != CFI_POINTER) {
	unmorph_PM();
	return 0;
    }
    WinOpenClipbrd(hab);
    clip_open = 1;
    ClipData = (char *) WinQueryClipbrdData(hab, CF_TEXT);
    sz = strlen(ClipData);
    if (!ClipData || !sz) {
	get_clip_release();
	return 0;
    }
    return ClipData;
}

void get_clip_release(void)
{
    if (!clip_open)
	return;
    WinCloseClipbrd(hab);
    clip_open = 0;
    unmorph_PM();
}

#else /* !( defined __EMX__ ) */

#  if !defined(WIN_EX) && defined(HAVE_POPEN)

static FILE *paste_handle = 0;
static char *paste_buf = NULL;

void get_clip_release(void)
{
    if (paste_handle != 0)
	pclose(paste_handle);
    if (paste_buf)
	FREE(paste_buf);
}

static int clip_grab(void)
{
    char *cmd = LYGetEnv("RL_PASTE_CMD");

    if (paste_handle)
	pclose(paste_handle);
    if (!cmd)
	return 0;

    paste_handle = popen(cmd, TXT_R);
    if (!paste_handle)
	return 0;
    return 1;
}

#define PASTE_BUFFER 1008
#define CF_TEXT 0		/* Not used */

char *get_clip_grab(void)
{
    int len;
    unsigned size = PASTE_BUFFER;
    int off = 0;

    if (!clip_grab())
	return NULL;
    if (!paste_handle)
	return NULL;
    if (paste_buf)
	FREE(paste_buf);
    paste_buf = typeMallocn(char, PASTE_BUFFER);

    while (1) {
	len = (int) fread(paste_buf + off,
			  (size_t) 1,
			  (size_t) PASTE_BUFFER - 1,
			  paste_handle);
	paste_buf[off + len] = '\0';
	if (len < PASTE_BUFFER - 1)
	    break;
	if (StrChr(paste_buf + off, '\r')
	    || StrChr(paste_buf + off, '\n'))
	    break;
	paste_buf = typeRealloc(char, paste_buf, size += PASTE_BUFFER - 1);

	off += len;
    }
    return paste_buf;
}

int put_clip(const char *s)
{
    char *cmd = LYGetEnv("RL_CLCOPY_CMD");
    FILE *fh;
    size_t l = strlen(s), res;

    if (!cmd)
	return -1;

    fh = popen(cmd, TXT_W);
    if (!fh)
	return -1;
    res = fwrite(s, (size_t) 1, l, fh);
    if (pclose(fh) != 0 || res != l)
	return -1;
    return 0;
}

#  endif /* !defined(WIN_EX) && defined(HAVE_POPEN) */

#endif /* __EMX__ */

/*
 * Sleep for a number of milli-sec.
 */
void LYmsec_delay(unsigned msec)
{
#if defined(_WINDOWS)
    Sleep(msec);

#elif defined(HAVE_NAPMS)
    napms((int) msec);

#elif defined(DJGPP) || defined(HAVE_USLEEP)
    usleep(1000 * msec);

#else
    struct timeval tv;
    unsigned long usec = 1000UL * msec;

    tv.tv_sec = usec / 1000000UL;
    tv.tv_usec = usec % 1000000UL;
    select(0, NULL, NULL, NULL, &tv);
#endif
}

#if defined(WIN_EX)		/* 1997/10/16 (Thu) 20:13:28 */

int put_clip(const char *szBuffer)
{
    HANDLE hWnd;
    HANDLE m_hLogData;
    LPTSTR pLogData;
    HANDLE hClip;
    int len;

    if (szBuffer == NULL)
	return EOF;

    len = strlen(szBuffer);
    if (len == 0)
	return EOF;
    else
	len++;

    m_hLogData = GlobalAlloc(GHND, len);
    if (m_hLogData == NULL) {
	return EOF;
    }

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return EOF;
    }
    /* Remove the current Clipboard contents */
    if (!EmptyClipboard()) {
	GlobalFree(m_hLogData);
	return EOF;
    }

    /* Lock the global memory while we write to it. */
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    lstrcpy((LPTSTR) pLogData, szBuffer);
    GlobalUnlock(m_hLogData);

    /* If there were any lines at all then copy them to clipboard. */
    hClip = SetClipboardData(CF_TEXT, m_hLogData);
    if (!hClip) {
	/* If we couldn't clip the data then free the global handle. */
	GlobalFree(m_hLogData);
    }

    CloseClipboard();
    return 0;
}

static HANDLE m_hLogData;
static int m_locked;

/* get_clip_grab() returns a pointer to the string in the system area.
   get_clip_release() should be called ASAP after this. */

char *get_clip_grab()
{
    HANDLE hWnd;
    LPTSTR pLogData;

    hWnd = NULL;
    if (!OpenClipboard(hWnd)) {
	return 0;
    }

    m_hLogData = GetClipboardData(CF_TEXT);

    if (m_hLogData == NULL) {
	CloseClipboard();
	m_locked = 0;
	return 0;
    }
    pLogData = (LPTSTR) GlobalLock(m_hLogData);

    m_locked = 1;
    return pLogData;
}

void get_clip_release()
{
    if (!m_locked)
	return;
    GlobalUnlock(m_hLogData);
    CloseClipboard();
    m_locked = 0;
}
#endif /* WIN_EX */
#endif /* CAN_CUT_AND_PASTE */

#if defined(WIN_EX)

#ifndef WSABASEERR
#define WSABASEERR 10000
#endif

#ifdef ENABLE_IPV6
#define WSOCK_NAME  "ws2_32"
#else
#define WSOCK_NAME  "wsock32"
#endif

/*
 * Description: the windows32 version of perror()
 *
 * Returns:  a pointer to a static error
 *
 * Notes/Dependencies:  I got this from
 *	comp.os.ms-windows.programmer.win32
 */
char *w32_strerror(DWORD ercode)
{
/*  __declspec(thread) necessary if you will use multiple threads */
#ifdef __CYGWIN__
    static char msg_buff[256];

#else
    __declspec(thread) static char msg_buff[256];
#endif
    HMODULE hModule;
    int i, msg_type;
    unsigned char *p, *q, tmp_buff[256];
    DWORD rc;

    hModule = NULL;
    msg_type = FORMAT_MESSAGE_FROM_SYSTEM;
    /* Fill message buffer with a default message in
     * case FormatMessage fails
     */
    wsprintf(msg_buff, "Error %ld", ercode);

    /*
     * Special code for winsock error handling.
     */
    if (ercode > WSABASEERR) {
	hModule = GetModuleHandle(WSOCK_NAME);
	if (hModule)
	    msg_type = FORMAT_MESSAGE_FROM_HMODULE;
    }
    /*
     * message handling. If not found in module, retry from system.
     */
    rc = FormatMessage(msg_type, hModule, ercode, LANG_NEUTRAL,
		       msg_buff, sizeof(msg_buff), NULL);

    if (rc == 0 && msg_type == FORMAT_MESSAGE_FROM_HMODULE) {
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ercode,
		      LANG_NEUTRAL, msg_buff, sizeof(msg_buff), NULL);
    }

    strcpy((char *) tmp_buff, msg_buff);
    p = q = tmp_buff;
    i = 0;
    while (*p) {
	if (!(*p == '\n' || *p == '\r'))
	    msg_buff[i++] = *p;
	p++;
    }
    msg_buff[i] = '\0';

    return msg_buff;
}

#endif

#if defined(SYSLOG_REQUESTED_URLS)
/*
 * syslog() interface
 */
void LYOpenlog(const char *banner)
{
    if (syslog_requested_urls) {
	CTRACE((tfp, "LYOpenlog(%s)\n", NONNULL(banner)));
#if defined(DJGPP)
	openlog("lynx", LOG_PID | LOG_NDELAY, LOG_LOCAL5);
#else
	openlog("lynx", LOG_PID, LOG_LOCAL5);
#endif

	if (banner) {
	    syslog(LOG_INFO, "Session start:%s", banner);
	} else {
	    syslog(LOG_INFO, "Session start");
	}
    }
}

static BOOLEAN looks_like_password(char *first,
				   char *last)
{
    BOOLEAN result = FALSE;

    while (first <= last) {
	if (*first == '/'
	    || *first == ':') {
	    result = FALSE;
	    break;
	}
	result = TRUE;
	first++;
    }
    return result;
}

void LYSyslog(char *arg)
{
    char *colon1;
    char *colon2;
    char *atsign;

    if (syslog_requested_urls) {

	CTRACE((tfp, "LYSyslog %s\n", arg));

	if (is_url(arg)) {	/* proto://user:password@@host/path:port */
	    /*      ^this colon                 */
	    if ((colon1 = StrChr(arg, ':')) != 0
		&& !StrNCmp(colon1, "://", 3)
		&& (colon2 = StrChr(colon1 + 3, ':')) != 0
		&& (atsign = StrChr(colon1, '@@')) != 0
		&& (colon2 < atsign)
		&& looks_like_password(colon2 + 1, atsign - 1)) {
		char *buf = NULL;

		StrAllocCopy(buf, arg);
		buf[colon2 - arg + 1] = 0;
		StrAllocCat(buf, "******");
		StrAllocCat(buf, atsign);
		syslog(LOG_INFO | LOG_LOCAL5, "%s", buf);
		CTRACE((tfp, "...alter %s\n", buf));
		FREE(buf);
		return;
	    }
	}
	syslog(LOG_INFO | LOG_LOCAL5, "%s", NONNULL(arg));
    }
}

void LYCloselog(void)
{
    if (syslog_requested_urls) {
	syslog(LOG_INFO, "Session over");
	closelog();
    }
}

#endif /* SYSLOG_REQUESTED_URLS */

#if defined(WIN_EX) || defined(__CYGWIN__)	/* 2000/03/07 (Tue) 17:17:46 */

#define IS_SEP(p)	((p == '\\') || (p == '/') || (p == ':'))

static char *black_list[] =
{
    "con",
    "prn",
    "clock$",
    "config$",
    NULL
};

static int is_device(char *fname)
{
    HANDLE fileHandle;
    DWORD val;
    int i;

    i = 0;
    while (black_list[i] != NULL) {
	if (strcasecomp(fname, black_list[i]) == 0) {
	    return 1;		/* device file */
	}
	i++;
    }

    fileHandle = CreateFile(fname, 0, 0, 0, OPEN_EXISTING, 0, 0);

    if (fileHandle == INVALID_HANDLE_VALUE) {
	return 0;		/* normal file */
    } else {
	val = GetFileType(fileHandle);
	switch (val) {
	case 1:
	    val = 0;
	    break;
	case 2:
	    val = 1;		/* device file */
	    break;
	default:
	    val = 0;
	    break;
	}

	CloseHandle(fileHandle);
    }
    return val;
}

static char *device_list[] =
{
    "con",
    "nul",
    "aux",
    "prn",
    NULL
};

int unsafe_filename(const char *fname)
{
    int i, len, sum;
    char *cp;
    char *save;

    i = 0;
    while (device_list[i] != NULL) {
	if (strcasecomp(fname, device_list[i]) == 0) {
	    return 0;		/* device file (open OK) */
	}
	i++;
    }

    save = cp = strdup(fname);

    while (*cp) {
	if (IS_SJIS_HI1(UCH(*cp)) || IS_SJIS_HI2(UCH(*cp)))
	    cp += 2;		/* KANJI skip */
	if (IS_SEP(*cp)) {
	    *cp = '\0';
	}
	cp++;
    }

    sum = 0;
    cp = save;
    len = strlen(fname);
    while (cp < (save + len)) {
	if (*cp == '\0') {
	    cp++;
	} else {
	    char *q;

	    q = StrChr(cp, '.');
	    if (q)
		*q = '\0';
	    if (is_device(cp)) {
		sum++;
		break;
	    }
	    if (q)
		cp = q + 1;
	    while (*cp)
		cp++;
	}
    }
    free(save);

    return (sum != 0);
}

FILE *safe_fopen(const char *fname, const char *mode)
{
    if (unsafe_filename(fname)) {
	return (FILE *) NULL;
    } else {
	return fopen(fname, mode);
    }
}

#endif /* defined(WIN_EX) || defined(__CYGWIN__) */
@


1.9
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.8
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYUtils.c,v 1.187 2009/05/25 21:46:24 tom Exp $
d21 5
d32 8
d176 1
a176 1
#ifdef EXP_RAND_TEMPNAME
d178 1
a178 1
#define USE_RAND_TEMPNAME 1
d235 1
a235 1
int w32_get_reg_sz(HKEY hkey, const char *name, char *value, unsigned length)
d253 29
d300 1
a300 1
	for (j = 0; j < TABLESIZE(rootkeys); ++j) {
d326 1
a326 1
#ifdef EXP_ASCII_CTYPES
d350 1
a350 1
#endif /* EXP_ASCII_CTYPES */
d356 1
a356 1
size_t utf8_length(BOOL utf_flag,
d410 1
a410 1
    links[cur].list.hl_base.hl_text = (char *) text;
d424 5
a428 2
    unsigned need = (unsigned) (list->hl_len - 1);
    unsigned want = (unsigned) (list->hl_len += 1);
d497 2
a498 2
				 BOOL TargetEmphasisON,
				 BOOL utf_flag)
d537 1
a537 1
		      (sizeof(buffer) - 1),
d578 2
a579 1
	    if ((Offset < offset) &&
d593 1
a593 1
		    LYstrncpy(&tmp[1], &data[itmp + 1], (int) utf_extra);
d599 1
a599 1
		    if (flag != ON) {
a607 1
		    utf_extra = 0;
d617 1
a617 1
		    if (flag != ON) {
d631 1
a631 1
		    if (flag != ON) {
d664 1
a664 1
			LYstrncpy(&tmp[1], &data[itmp + 1], (int) utf_extra);
d671 1
a671 1
			if (flag == ON && data[(itmp + 1)] == '\0') {
d675 1
a681 1
			utf_extra = 0;
d692 1
a692 1
			if (flag == ON && data[(itmp + 1)] == '\0') {
d708 1
a708 1
			if (flag == ON && data[(itmp + 1)] == '\0') {
d731 1
a731 1
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
d752 1
a752 1
		     (flag == ON ? (hLen - 1) : hLen))) {
d773 1
a773 1
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen)) {
d791 1
a791 1
		    LYstrncpy(&tmp[1], &data[itmp + 1], (int) utf_extra);
d798 1
a798 1
		    if (flag != ON ||
a807 1
		    utf_extra = 0;
d818 1
a818 1
		    if (flag != ON ||
d834 1
a834 1
		    if (flag != ON ||
d865 1
a865 1
			LYstrncpy(&tmp[1], &data[itmp + 1], (int) utf_extra);
d872 1
a872 1
			if (flag == ON && data[(itmp + 1)] == '\0') {
a881 1
			utf_extra = 0;
d892 1
a892 1
			if (flag == ON && data[(itmp + 1)] == '\0') {
d908 1
a908 1
			if (flag == ON && data[(itmp + 1)] == '\0') {
d931 1
a931 1
		if (offset < (hoffset + (flag == ON ? (hLen - 1) : hLen))
d951 1
a951 1
		    (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
d985 1
a985 1
				LYstrncpy(&tmp[1], &data[itmp + 1], (int) utf_extra);
d992 1
a992 1
				if (flag == ON && data[(itmp + 1)] == '\0') {
a1001 1
				utf_extra = 0;
d1012 1
a1012 1
				if (flag == ON && data[(itmp + 1)] == '\0') {
d1026 1
a1026 1
				if (flag == ON && data[(itmp + 1)] == '\0') {
d1055 1
a1055 1
    return TargetEmphasisON;
d1072 1
a1072 1
    if (flag != ON) {
a1137 5
#ifdef USE_COLOR_STYLE
    BOOL hl2_drawn = FALSE;	/* whether links[cur].l_hightext2 is already drawn

				   properly */
#endif
d1142 1
a1142 1
     * a crash when LYstrncpy() is called with a nonsense pointer.  As far as I
d1161 1
a1161 1
    if (flag == OFF)
d1167 1
a1167 1
	if (flag == ON || links[cur].type == WWW_FORM_LINK_TYPE) {
d1176 1
a1176 1
	    lynx_start_link_color(flag == ON, links[cur].inUnderline);
d1188 1
a1188 1
	    int len, gllen;
d1198 2
a1199 3
	    gllen = LYmbcsstrlen(text, utf_flag, YES);
	    len = LYmbcs_skip_cells(text, avail_space, utf_flag) - text;
	    LYwaddnstr(LYwin, text, (unsigned) len);
d1204 1
a1204 2
	} else if (flag == OFF) {
	    hl2_drawn = TRUE;
d1217 1
a1217 1
			  (sizeof(buffer) - 1),
d1226 11
a1236 13
#ifdef USE_COLOR_STYLE
	if (hl2_drawn == FALSE)
#endif
	{
	    for (hi_count = 1;
		 (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		 && LYP + hi_count <= display_lines;
		 ++hi_count) {
		int row = LYP + hi_count + title_adjust;

		hi_offset = LYGetHilitePos(cur, hi_count);
		lynx_stop_link_color(flag == ON, links[cur].inUnderline);
		LYmove(row, hi_offset);
d1239 7
a1245 7
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
			 row, hi_offset,
			 flag == ON ? s_alink : s_a));
		LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON);
#else
		lynx_start_link_color(flag == ON, links[cur].inUnderline);
d1248 12
a1259 13
		for (i = 0; (tmp[0] = hi_string[i]) != '\0'
		     && (i + hi_offset) < LYcols; i++) {
		    if (!IsSpecialAttrChar(hi_string[i])) {
			/*
			 * For CJK strings, by Masanobu Kimura.
			 */
			if (IS_CJK_TTY && is8bits(tmp[0])) {
			    tmp[1] = hi_string[++i];
			    LYaddstr(tmp);
			    tmp[1] = '\0';
			} else {
			    LYaddstr(tmp);
			}
a1262 1
	    lynx_stop_link_color(flag == ON, links[cur].inUnderline);
d1264 1
d1316 1
a1316 1
		       BOOL condense)
d1417 2
a1418 2
    LYstrncpy(text_buff, text, sizeof(text_buff) - 1);
    p = strchr(text_buff, '\n');
d1420 1
a1420 1
	p = '\0';
d1438 2
d1491 1
a1491 1
	len = strlen(text_buff);
d1494 1
a1494 1
	strncpy(buffer, text_buff, len)[len] = '\0';
d1561 1
a1561 1
	    int a = ((strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
d1573 1
d1625 1
a1625 2
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
d1661 1
a1661 1
	char *term_name = NULL;
d1711 1
a1711 1
int LYConsoleInputFD(BOOLEAN need_selectable)
d1742 1
a1742 1
void LYFakeZap(BOOL set)
d1761 2
a1762 2
    static long last;
    long next;
d1954 6
a1959 7
		    if ((res =
			 HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								  Newline_partial,
								  display_lines)
					       - 1,
					       &Newline_partial, NULL,
					       1, TRUE)) == LINK_LINE_FOUND) {
d2072 1
a2072 1
    if ((cp = strchr(host, ':')) != NULL)
d2108 1
a2108 1
    if ((cp = strchr(host, ':')) != NULL)
d2190 1
a2190 1
    if ((cp = strchr(host, ':')) != NULL)
d2234 2
a2235 2
    if ((cp1 = strchr((cp + 1), ':')) != NULL) {
	if ((cp2 = strchr((cp + 1), '/')) != NULL && cp2 < cp1)
d2276 1
a2276 1
	if (strncmp(tst, cmp, len)) {
d2286 1
d2292 1
a2292 1
	&& compare_type(tst, cmp, len))
d2295 3
a2297 4
 *  Must recognize a URL and return the type.
 *  If recognized, based on a case-insensitive
 *  analysis of the scheme field, ensures that
 *  the scheme field has the expected case.
d2299 1
a2299 2
 *  Returns 0 (not a URL) for a NULL argument,
 *  one which lacks a colon.
d2301 2
a2302 2
 *  Chains to LYCheckForProxyURL() if a colon
 *  is present but the type is not recognized.
d2318 2
a2319 1
     * Can't be a URL if it lacks a colon.
d2321 1
a2321 1
    if (NULL == strchr(cp, ':'))
d2347 1
a2347 1
	    if (compare_type(cp, STR_LYNXEXEC, LEN_LYNXEXEC)) {
d2355 1
a2355 1
	    } else if (compare_type(cp, STR_LYNXPROG, LEN_LYNXPROG)) {
d2358 1
a2358 1
		 * scripts or programs with do not require a pause to read
d2363 1
a2363 4
	    } else if (compare_type(cp, STR_LYNXCGI, LEN_LYNXCGI)) {
		/*
		 * Special External Lynx type to handle cgi scripts.
		 */
d2366 1
a2366 4
	    } else if (compare_type(cp, STR_LYNXPRINT, LEN_LYNXPRINT)) {
		/*
		 * Special Internal Lynx type.
		 */
d2369 1
a2369 4
	    } else if (compare_type(cp, STR_LYNXOPTIONS, LEN_LYNXOPTIONS)) {
		/*
		 * Special Internal Lynx type.
		 */
d2372 1
a2372 4
	    } else if (compare_type(cp, STR_LYNXCFG, LEN_LYNXCFG)) {
		/*
		 * Special Internal Lynx type.
		 */
d2375 1
a2375 4
	    } else if (compare_type(cp, STR_LYNXMESSAGES, LEN_LYNXMESSAGES)) {
		/*
		 * Special Internal Lynx type.
		 */
d2378 1
a2378 4
	    } else if (compare_type(cp, STR_LYNXCFLAGS, LEN_LYNXCFLAGS)) {
		/*
		 * Special Internal Lynx type.
		 */
d2381 1
a2381 4
	    } else if (compare_type(cp, STR_LYNXDOWNLOAD, LEN_LYNXDOWNLOAD)) {
		/*
		 * Special Internal Lynx type.
		 */
d2384 1
a2384 4
	    } else if (compare_type(cp, STR_LYNXDIRED, LEN_LYNXDIRED)) {
		/*
		 * Special Internal Lynx type.
		 */
d2387 4
a2390 4
	    } else if (compare_type(cp, STR_LYNXHIST, LEN_LYNXHIST)) {
		/*
		 * Special Internal Lynx type.
		 */
d2394 1
a2394 4
	    } else if (compare_type(cp, STR_LYNXCACHE, LEN_LYNXCACHE)) {
		/* 
		 * Special Internal Lynx type.
		 */
d2397 1
a2397 5

	    } else if (compare_type(cp, STR_LYNXKEYMAP, LEN_LYNXKEYMAP)) {
		/*
		 * Special Internal Lynx type.
		 */
d2400 1
a2400 4
	    } else if (compare_type(cp, STR_LYNXIMGMAP, LEN_LYNXIMGMAP)) {
		/*
		 * Special Internal Lynx type.
		 */
d2405 1
a2405 4
	    } else if (compare_type(cp, STR_LYNXCOOKIE, LEN_LYNXCOOKIE)) {
		/*
		 * Special Internal Lynx type.
		 */
d2407 1
d2416 1
a2416 1
	    if (compare_type(cp, STR_NEWS_URL, LEN_NEWS_URL)) {
d2419 1
a2419 1
	    } else if (compare_type(cp, STR_NNTP_URL, LEN_NNTP_URL)) {
d2422 1
a2422 1
	    } else if (compare_type(cp, "newspost:", 9)) {
d2428 1
a2428 1
	    } else if (compare_type(cp, "newsreply:", 10)) {
d2441 1
a2441 1
	    if (compare_type(cp, STR_SNEWS_URL, LEN_SNEWS_URL)) {
d2444 1
a2444 1
	    } else if (compare_type(cp, "snewspost:", 10)) {
d2450 1
a2450 1
	    } else if (compare_type(cp, "snewsreply:", 11)) {
d2460 1
a2460 1
	    if (compare_type(cp, STR_MAILTO_URL, LEN_MAILTO_URL)) {
d2467 1
a2467 1
	    if (compare_type(cp, STR_FILE_URL, LEN_FILE_URL)) {
d2489 1
a2489 1
	    if (compare_type(cp, STR_BIBP_URL, LEN_BIBP_URL)) {
d2497 1
a2497 1
	    if (compare_type(cp, "data:", 5)) {
d2504 1
a2504 1
		&& ((cp1 = strchr(cp + 3, ':')) == NULL
d2522 1
a2522 1
		    if (compare_type(cp, STR_HTTP_URL, LEN_HTTP_URL)) {
d2525 1
a2525 1
		    } else if (compare_type(cp, STR_HTTPS_URL, LEN_HTTPS_URL)) {
d2533 1
a2533 1
		    if (compare_type(cp, STR_GOPHER_URL, LEN_GOPHER_URL)) {
d2535 1
a2535 1
			    && (cp1 = strchr(cp + 11, '/')) != NULL) {
d2554 1
a2554 1
		    if (compare_type(cp, STR_WAIS_URL, LEN_WAIS_URL)) {
d2561 1
a2561 1
		    if (compare_type(cp, STR_TELNET_URL, LEN_TELNET_URL)) {
d2564 1
a2564 1
		    } else if (compare_type(cp, STR_TN3270_URL, LEN_TN3270_URL)) {
d2571 1
a2571 1
		    if (compare_type(cp, STR_RLOGIN_URL, LEN_RLOGIN_URL)) {
d2578 1
a2578 1
		    if (compare_type(cp, STR_CSO_URL, LEN_CSO_URL)) {
d2585 1
a2585 1
		    if (compare_type(cp, "afs:", 4)) {
d2592 1
a2592 1
		    if (compare_type(cp, "prospero:", 9)) {
d2653 1
a2653 1
	      (cp1 = strchr(addr + 11, '/')) != NULL &&
d2681 1
a2681 1
    if (!strncmp(address, "http", 4))
d2707 1
a2707 1
	if (strchr((cp ? cp : temp), '@@') != NULL) {
d2712 1
a2712 1
	if (cp && isdigit(UCH(cp[1])) && strchr(cp, '-') == NULL) {
d2754 2
d2758 1
d2761 3
d2765 1
a2765 1
	    return TRUE;
d2768 1
a2768 1
    return FALSE;
d2776 2
d2780 1
d2783 3
d2787 1
a2787 1
	    return TRUE;
d2790 4
a2793 2
    HTAlert(CANNOT_WRITE_TO_FILE);
    return FALSE;
d2801 2
d2804 3
a2806 2
	remove(filename);
	return TRUE;
a2808 1
	return FALSE;
d2810 1
d2819 1
d2821 1
a2821 1
    if (!isEmpty(filename)) {
d2823 79
a2901 1
	    return LYCloseInput(fp);
d2903 1
d2905 2
a2906 1
    return FALSE;
d2952 1
a2952 1
	    n = (int) fread((char *) &me, sizeof(struct utmp), 1, fp);
d2989 1
a2989 1
		 LYSigHandlerFunc_t * handler)
a2998 4
#ifdef SA_RESTART
	if (sig != SIGWINCH)
	    act.sa_flags |= SA_RESTART;
#endif /* SA_RESTART */
d3072 3
a3074 3
#   endif			/* HAVE_TERMIO_H */
#  endif			/* HAVE_TERMIOS_H */
# endif				/* TERMIO_AND_TERMIOS */
d3125 1
a3125 1
    if (ioctl(0, TIOCGWINSZ, &win) == 0) {
d3252 5
a3256 4
    if (!strncmp(fname, temp, strlen(temp))) {
	cp = strrchr(fname, '.');
	if (strlen(cp) > (strlen(temp) - 4))
	    cp = NULL;
d3307 1
a3307 1

d3311 1
a3311 1
    if ((cp = strchr(fname, '[')) != NULL &&
a3318 1
#ifdef VMS
d3404 1
a3404 1
		(((cp = strchr(fname, '.')) != NULL) && cp < dot)) {
d3409 1
a3409 1
		       (((cp = strchr(fname, '.')) != NULL) && cp < dot)) {
d3415 1
a3415 1
	while ((cp = strchr(cp, '.')) != NULL && cp < dot) {
d3516 1
a3516 1
#ifdef USE_RAND_TEMPNAME
d3533 1
a3533 1
#ifdef USE_RAND_TEMPNAME
d3535 1
a3535 1
	lynx_srand((unsigned) ((long) time((time_t *) 0) + (long) result));
d3546 5
a3550 2
	counter = (unsigned) (((float) MAX_TEMPNAME * lynx_rand()) /
			      LYNX_RAND_MAX + 1);
d3584 1
a3584 1
	const char *tail = strchr(suffix, '.');
d3619 1
a3619 1
	number = DNARROW;
d3622 1
a3622 1
	number = PGDOWN;
d3625 1
a3625 1
	number = LTARROW;
d3631 1
a3631 1
	number = RTARROW;
d3634 1
a3634 1
	number = HOME;
d3637 1
a3637 1
	number = UPARROW;
d3640 1
a3640 1
	number = PGUP;
d3846 1
a3846 1
	if (RESTRICT_NM_EQU(word, "all", p - word)) {
d3852 1
a3852 1
	} else if (RESTRICT_NM_EQU(word, "default", p - word)) {
d3860 1
a3860 1
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p - word)) {
d3908 1
a3908 1
	    if (strncmp(restrictions[i].name, "goto_", 5)
d4112 1
a4112 1
    if (!old_string || *old_string == '\0')
d4153 1
a4153 1
	    if ((cp = strchr(old_string, '/')) != NULL) {
d4167 1
a4167 1
	    LYstrncpy(url_file, old_string, sizeof(url_file) - 1);
d4175 1
a4175 1
	    if ((cp = strchr(file_name, ';')) != NULL) {
d4180 1
a4180 1
	    if ((cp = strchr(old_string, ';')) != NULL) {
d4211 2
a4212 2
		if (strchr(old_string, '[') ||
		    ((cp = strchr(old_string, ':')) != NULL &&
d4248 2
a4249 2
	    if (strchr(old_string, '[') ||
		((cp = strchr(old_string, ':')) != NULL &&
d4316 7
a4322 15
	    /*
	     * On Unix, convert '~' to Home_Dir().
	     */
	    StrAllocCat(*AllocatedString, wwwName(Home_Dir()));
	    if ((cp = strchr(old_string, '/')) != NULL) {
		/*
		 * Append rest of path, if present, skipping "user" if "~user"
		 * was entered, simplifying, and eliminating any residual
		 * relative elements.  - FM
		 */
		StrAllocCopy(temp, cp);
		LYTrimRelFromAbsPath(temp);
		StrAllocCat(*AllocatedString, temp);
		FREE(temp);
	    }
d4342 1
a4342 1
		LYstrncpy(curdir, temp, (sizeof(curdir) - 1));
d4371 1
a4371 1
		if (strchr(temp, '#') == NULL && strchr(temp, '%') == NULL)
d4428 2
a4429 2
		} else if (strchr(curdir, '#') != NULL ||
			   strchr(curdir, '%') != NULL) {
d4542 1
a4542 1
	    if ((cp = strchr((old_string + 1), '/')) != NULL) {
d4587 1
a4590 1
    int c;
d4596 1
a4596 1
		c = LYgetch();
d4602 2
a4603 1
#endif
d4639 2
d4655 2
a4656 2
    if (!strncmp(*AllocatedString, "..", 2) ||
	!strncmp(*AllocatedString, "./", 2)) {
d4666 1
a4666 1
    if ((Path = strchr(Str, '/')) != NULL) {
d4685 1
a4685 1
	isdigit(UCH(StrColon[1]))) {
d4706 8
d4717 3
a4719 1
    error = getaddrinfo(host, "80", &hints, &res);
d4860 1
a4860 1
		LYstrncpy(DomainSuffix, StartS, (EndS - StartS));
d4876 1
a4876 1
	    LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
d4886 1
a4886 1
	if (StrColon && strchr(Host, ':') == NULL) {
d5117 1
a5117 1
    if (strncmp(cp, "!--#", 4))
d5142 1
a5142 1
    if (!LogicalName || *LogicalName == '\0')
d5148 1
a5148 1
    if (!LogicalValue || *LogicalValue == '\0') {
d5172 1
a5172 1
    result = getcwd(pathname, LY_MAXPATH);
d5194 1
d5211 12
a5222 4
	/* Windows 2000 */
	if ((result = LYGetEnv("USERPROFILE")) != 0) {
	    HTSprintf0(&temp, "%s%sMy Documents", result, PATHSEP_STR);
	    result = CheckDir(temp);
d5228 1
a5228 1
		    HTSprintf0(&temp, "%s%s%s", head, PATHSEP_STR, leaf);
d5234 4
d5244 1
a5244 1
		HTSprintf0(&temp, "%s%s", head, PATHSEP_STR);
d5249 1
a5249 1
	    result = CheckDir("C:" PATHSEP_STR);
d5327 1
a5327 1
	if (strchr("\\/:", pathname[n]) != 0) {
d5355 1
a5355 1
    if (!fbuffer || fbuffer_size < 2 || fbuffer[0] == '\0') {
d5391 1
a5391 1
		if ((cp1 = strchr((cp + 2), '/')) != NULL) {
d5410 1
a5410 1
		   (cp1 = strchr((cp + 1), '/')) != NULL) {
d5413 1
a5413 1
		if ((cp1 = strchr((cp + 2), '/')) != NULL) {
d5445 1
a5445 1
    if (strchr(cp, ':') != NULL || strchr(cp, ']') != NULL) {
d5467 2
a5468 2
    if (!strncmp(cp, "./", 2)) {
	if ((cp1 = strchr((cp + 2), '/')) == NULL) {
d5489 1
a5489 1
    if (fbuffer_size > 3 && strncmp(cp, "./", 2) && strchr(cp, '/')) {
d5511 1
a5511 1
static char *FindLeadingTilde(char *pathname, BOOL embedded)
d5539 1
a5539 1
    if (!LYisAbsPath(*fname)) {
d5557 1
a5557 1
		    BOOL embedded)
d5582 23
d5668 1
a5668 1
	LYstrncpy(fbuffer, home, (int) (fbuffer_size - 1));
d5676 1
a5676 1
    if (!strncmp(file, "./", 2)) {
d5708 1
a5708 1
	    (strncmp(file, "./", 2) ? file : (file + 2)));
d5777 1
a5777 1
    char *name_end = strchr(string, '=');
d5785 1
a5785 1
	    if (!strncmp(*ep, string, size) && (*ep)[size] == '=') {
d5797 1
a5797 1
	if (!strncmp(*ep, string, name_end - string) &&
d5841 2
a5842 2
    int size = LY_MAXPATH;
    int used;
d5844 1
d5847 2
a5848 3
	while ((used = readlink(name, buffer, (unsigned) (size - 1))) == size
	       - 1) {
	    buffer = typeRealloc(char, buffer, (unsigned) (size *= 2));
d5850 1
a5850 1
	    if (buffer == 0)
d5852 1
d5854 6
a5859 4
	if (used > 0) {
	    buffer[used] = '\0';
	} else {
	    FREE(buffer);
d5870 1
a5870 1
			   name, PATHSEP_STR, buffer);
d5963 1
a5963 1
    BOOLEAN binary = (BOOLEAN) (strchr(mode, 'b') != 0);
d5976 4
a5979 3
	    remove(name);
	    /* FIXME: there's a race at this point if directory is open */
	    fd = open(name, O_CREAT | O_EXCL | O_WRONLY, HIDE_CHMOD);
d6010 1
a6010 1
	umask(save);
d6023 1
a6023 1
    chmod(name, HIDE_CHMOD);
d6036 1
a6036 1
    chmod(name, HIDE_CHMOD);
d6054 1
a6054 1
    chmod(name, HIDE_CHMOD);
d6087 2
a6088 2
	umask(save);
	chmod(name, mode);
d6096 1
a6096 1
BOOLEAN LYCachedTemp(char *result,
d6099 2
d6102 1
a6102 1
	LYstrncpy(result, *cached, LY_MAXPATH);
d6104 4
a6107 2
	if (LYCanReadFile(result)) {
	    remove(result);
d6109 1
a6109 1
	return TRUE;
d6111 1
a6111 1
    return FALSE;
d6184 1
a6184 1
	    umask(old_mask);
d6368 1
a6368 1
	    if (truncate(fname, 0) != 0) {
d6518 1
a6518 1
	LYRemoveTemp(ly_temp->name);
d6524 1
a6524 1
	LYstrncpy(result, lynx_temp_space, sizeof(result) - 1);
d6608 1
a6608 1
#ifdef EXP_ADDRLIST_PAGE
d6632 1
d6634 23
a6656 21
    if (!url)
	return NO;
    for (i = 0; i < TABLESIZE(ly_uip); i++) {
	if (ly_uip[i].type == type) {
	    if (!ly_uip[i].url) {
		return NO;
	    } else if ((flagparam & UIP_P_FRAG) ?
		       (!strncmp(ly_uip[i].url, url, (l = strlen(ly_uip[i].url)))
			&& (url[l] == '\0' || url[l] == '#')) :
		       !strcmp(ly_uip[i].url, url)) {
		return YES;
	    } else if (ly_uip[i].flags & UIP_F_MULTI) {
		char *p;
		HTList *l0 = ly_uip[i].alturls;

		while ((p = (char *) HTList_nextObject(l0)) != NULL) {
		    if ((flagparam & UIP_P_FRAG) ?
			(!strncmp(p, url, (l = strlen(p)))
			 && (url[l] == '\0' || url[l] == '#')) :
			!strcmp(p, url))
			return YES;
d6658 1
a6659 1
	    return NO;
d6662 1
a6662 1
    return NO;
a6744 2
 *
 * Both strings are fixed buffer sizes, LY_MAXPATH.
d6746 2
a6747 2
BOOLEAN LYValidateFilename(char *result,
			   char *given)
a6750 1
    const char *cp2 = NULL;
d6756 1
a6756 1
    if (LYIsNullDevice(given)) {
d6760 1
a6760 1
    } else if (LYIsPipeCommand(given)) {
d6765 1
a6765 1
	    LYstrncpy(result, given, LY_MAXPATH);
d6769 8
a6776 11
	if ((cp = FindLeadingTilde(given, TRUE)) != 0
	    && (cp2 = wwwName(Home_Dir())) != 0
	    && strlen(cp2) + strlen(given) < LY_MAXPATH) {
	    if (LYIsTilde(cp[0]) && LYIsPathSep(cp[1])) {
		*(cp++) = '\0';
		strcpy(result, given);
		LYTrimPathSep(result);
		strcat(result, cp2);
		strcat(result, cp);
		strcpy(given, result);
	    }
d6779 10
a6788 11
	if (strchr(given, '/') != NULL) {
	    strcpy(result, HTVMS_name("", given));
	    strcpy(given, result);
	}
	if (given[0] != '/'
	    && strchr(given, ':') == NULL
	    && strlen(given) < LY_MAXPATH - 13) {
	    strcpy(result, "sys$disk:");
	    if (strchr(given, ']') == NULL)
		strcat(result, "[]");
	    strcat(result, given);
d6790 1
a6790 1
	    strcpy(result, given);
d6795 1
a6795 1
	if (!LYisAbsPath(given)) {
d6797 1
a6797 1
	    if (strchr(result, ':') != NULL)
a6813 1
	*result = 0;
d6816 4
a6819 5
	    if (strlen(cp) >= LY_MAXPATH - 2) {
		code = FALSE;
	    } else {
		sprintf(result, "%s/", cp);
	    }
d6822 2
a6823 6
	    cp = HTSYS_name(given);
	    if (strlen(result) + strlen(cp) >= LY_MAXPATH - 1) {
		code = FALSE;
	    } else {
		strcat(result, cp);
	    }
d6843 2
d6875 2
d6901 1
a6901 1
    if (!LYIsHtmlSep(*leaf))
d6906 19
d6937 1
a6937 1
	LYRemoveTemp(filename);
d6951 1
a6951 2
    fprintf(fp0,
	    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
d6956 1
a6956 1
	if (strchr(HTLoadedDocumentURL(), '"') == NULL) {
d7035 1
a7035 1
	StrAllocCat(*path, PATHSEP_STR);
d7051 1
a7051 1
	strcat(path, PATHSEP_STR);
d7144 1
a7144 1
	unsigned len;
d7150 3
a7152 3
		while ((len = fread(buff, 1, sizeof(buff), fin)) != 0) {
		    fwrite(buff, 1, len, fout);
		    if (ferror(fout)) {
d7161 2
d7289 1
a7289 1
	if (strchr(p, '\\') == NULL) {
d7400 1
a7400 1
	    printf("shell = [%s], code = %ld\n", shell, GetLastError());
d7500 1
d7679 2
a7680 1
    paste_buf = (char *) malloc(PASTE_BUFFER);
d7682 4
a7685 1
	len = (int) fread(paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
d7689 2
a7690 2
	if (strchr(paste_buf + off, '\r')
	    || strchr(paste_buf + off, '\n'))
d7703 1
a7703 1
    unsigned l = strlen(s), res;
d7711 1
a7711 1
    res = fwrite(s, 1, l, fh);
d7717 1
a7717 1
#  endif			/* !defined(WIN_EX) && defined(HAVE_POPEN) */
d7896 1
a7896 1
    strcpy(tmp_buff, msg_buff);
d7962 4
a7965 4
	    if ((colon1 = strchr(arg, ':')) != 0
		&& !strncmp(colon1, "://", 3)
		&& (colon2 = strchr(colon1 + 3, ':')) != 0
		&& (atsign = strchr(colon1, '@@')) != 0
d7993 122
@


1.7
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d1 3
d11 3
a13 2
#ifdef __MINGW32__
int kbhit(void);		/* FIXME: use conio.h */
a14 1
#ifdef UNIX
d16 17
a32 1
#endif /* UNIX */
d59 1
a59 1
#define GETPID()	(getpid() & 0xffff)
d61 1
a61 1
#define GETPID()	getpid()
d64 6
d103 1
d106 1
d217 25
d249 27
d369 1
a369 1
    links[cur].list.hl_len = (text != NULL) ? 1 : 0;
d382 2
a383 2
    unsigned need = (list->hl_len - 1);
    unsigned want = (list->hl_len += 1);
d392 1
a392 1
    have[need].hl_x = x;
d480 1
a480 1
	int tlen = strlen(target);
d495 2
a496 2
	hlen = strlen(buffer);
	hLen = ((HTCJK != NOCJK || utf_flag) ?
d547 2
a548 2
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += utf_extra;
d561 1
a561 1
		    written += (utf_extra + 1);
d563 1
a563 1
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d619 2
a620 2
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
			itmp += utf_extra;
d635 1
a635 1
			written += (utf_extra + 1);
d637 1
a637 1
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d746 2
a747 2
		    LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
		    itmp += utf_extra;
d762 1
a762 1
		    written += (utf_extra + 1);
d764 1
a764 1
		} else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d821 2
a822 2
			LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
			itmp += utf_extra;
d837 1
a837 1
			written += (utf_extra + 1);
d839 1
a839 1
		    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d924 1
a924 1
			len = strlen(data);
d942 2
a943 2
				LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
				itmp += utf_extra;
d958 1
a958 1
				written += (utf_extra + 1);
d960 1
a960 1
			    } else if (HTCJK != NOCJK && is8bits(tmp[0])) {
d1035 4
a1038 4
	 * unhighlighted.  The purpose of cached_styles[][] is to save the
	 * original style just for this case.  If it doesn't have a color
	 * change saved at just the right position, we look at preceding
	 * positions in the same line until we find one.
d1040 1
a1040 1
	if (CACHE_VALIDATE_YX(LYP, LXP)) {
d1044 1
a1044 1
	    s = cached_styles[LYP][LXP];
d1047 5
a1051 7
		    if (cached_styles[LYP][x]) {
			if (cached_styles[LYP][x] > 0) {
			    s = cached_styles[LYP][x];
			    cached_styles[LYP][LXP] = s;
			}
			CTRACE((tfp, "found %u, x_offset=%d.\n",
				cached_styles[LYP][x], (int) x - LXP));
d1056 1
a1056 1
		    CTRACE((tfp, "not found, assume <a>.\n"));
d1060 1
a1060 1
		CTRACE((tfp, "found %d.\n", s));
d1093 1
a1093 1
    BOOL utf_flag = (BOOL) (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
d1114 2
a1115 1
    CTRACE((tfp, "LYhighlight %s %d [%d]:%s\n",
d1151 1
a1151 1
	    int len;
d1155 3
a1159 2
	    if (avail_space > (int) sizeof(buffer) - 1)
		avail_space = (int) sizeof(buffer) - 1;
d1161 5
a1165 7
	    LYstrncpy(buffer, NonNull(text), avail_space);
	    len = strlen(buffer);
	    while (len < avail_space) {
		buffer[len++] = '_';
	    }
	    buffer[len] = 0;
	    LYaddstr(buffer);
d1221 1
a1221 1
			if (HTCJK != NOCJK && is8bits(tmp[0])) {
d1293 1
a1293 1
    for (; (*s && !isspace(*s)); s++) ;
d1331 1
a1331 1
    i = strlen(dirname) - 1;
d1342 2
a1343 2
    int length = strlen(buffer);
    BOOL trailing = (length != 0) && (buffer[length - 1] == ' ');
d1420 1
a1420 1
		    temp[j++] = text_buff[i];
d1438 2
a1439 2
		buffer[j++] = k;
		buffer[j++] = temp[i];
d1445 1
a1445 1
		buffer[j++] = temp[i];
d1500 1
a1500 1
    if (non_empty(buffer)) {
d1503 1
a1503 1
	if (HTCJK != NOCJK) {
d1514 1
a1514 1
	    || (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8)
d1545 1
a1545 1
		wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
d1547 1
a1547 1
		wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
d1660 1
a1660 1
		    term_name, frp, stdin, fileno(stdin)));
d1995 3
a1997 3
	result = (BOOL) (LYIsPathSep(path[0])
			 || (LYIsDosDrive(path)
			     && LYIsPathSep(path[2])));
d1999 1
a1999 1
	result = (LYIsPathSep(path[0]));
d2242 1
a2242 1
    if (!strncasecomp(tst, cmp, len)) {
a2276 1
    int len;
d2306 1
a2306 1
	limit = strlen(cp);
d2384 8
d2470 1
a2470 1
	    if (compare_type(cp, STR_FILE_URL, len = LEN_FILE_URL)) {
d2473 1
a2473 1
		} else if (DoubleHtmlSep(cp + len)) {
d2842 2
d2851 1
a2851 1
	mytty = strrchr(cp, '/');
d2853 1
d2857 1
a2857 1
	    n = fread((char *) &me, sizeof(struct utmp), 1, fp);
d2861 6
a2866 5
	if (n > 0 &&
	    strlen(me.ut_host) > strlen(LYLocalDomain) &&
	    STREQ(LYLocalDomain,
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)))
	    return (TRUE);
d2868 4
a2871 3
/* Linux fix to check for local user. J.Cullen 11Jul94		*/
	if ((n > 0) && (strlen(me.ut_host) == 0))
	    return (TRUE);
d2873 1
a2879 2

    return (FALSE);
d2881 1
a2881 2
    CTRACE((tfp, "LYUtils: inlocaldomain() not support.\n"));
    return (TRUE);
d2883 1
a3155 7
#ifdef FNAMES_8_3
    if (LYIsHtmlSep(*cp2)) {
	HTSprintf0(&temp, "file://localhost%s%04x", cp2, GETPID());
    } else {
	HTSprintf0(&temp, "file://localhost/%s%04x", cp2, GETPID());
    }
#else
d3157 1
a3157 1
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int) getpid());
d3159 1
a3159 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int) getpid());
a3160 1
#endif
d3444 1
a3444 3
#if !defined(__OpenBSD__)
	lynx_srand((unsigned)((long)time((time_t *)0) + (long)result));
#endif
d3465 1
a3465 1
	    mask = 1 << (counter % BITS_PER_CHAR);
d3468 1
a3468 1
		used_tempname[offset] |= mask;
d3486 1
a3486 5
#ifdef _WINDOWS
    sprintf(leaf, "%04x%04x", counter, (unsigned) GETPID());
#else
    sprintf(leaf, "%u%u", counter, (unsigned) getpid());
#endif
d3499 1
a3499 1
    sprintf(leaf, "L%u-%uTMP%s", (unsigned) getpid(), counter, suffix);
d3709 1
a3709 1
const char *index_to_restriction(int inx)
d3711 1
a3711 1
    if (inx >= 0 && inx < (int) TABLESIZE(restrictions))
d3726 1
a3726 1
	len = strlen(name);
d3763 1
a3763 1
		*(restrictions[i].flag) = !restrictions[i].can;
d3949 1
a3949 1
    lastsize = st.st_size;
d4053 1
a4053 1
	if (*old_string == '~') {
d4221 1
a4221 1
	if (*old_string == '~') {
d4450 1
a4450 1
	} else if (old_string[1] == '~') {
d5276 3
a5278 3
    if (*cp == '~') {
	if (*(cp + 1) == '/') {
	    if (*(cp + 2) != '\0') {
d5396 81
d5526 1
a5526 1
    len = fbuffer_size - (strlen(home) + 1);
d5533 1
a5533 1
	LYstrncpy(fbuffer, home, (fbuffer_size - 1));
a5601 253
/*
 * This function takes a string in the format
 *	"Mon, 01-Jan-96 13:45:35 GMT" or
 *	"Mon,  1 Jan 1996 13:45:35 GMT"" or
 *	"dd-mm-yyyy"
 * as an argument, and returns its conversion to clock format (seconds since
 * 00:00:00 Jan 1 1970), or 0 if the string doesn't match the expected pattern. 
 * It also returns 0 if the time is in the past and the "absolute" argument is
 * FALSE.  It is intended for handling 'expires' strings in Version 0 cookies
 * homologously to 'max-age' strings in Version 1 cookies, for which 0 is the
 * minimum, and greater values are handled as '[max-age seconds] + time(NULL)'. 
 * If "absolute" if TRUE, we return the clock format value itself, but if
 * anything goes wrong when parsing the expected patterns, we still return 0. 
 * - FM
 */
time_t LYmktime(char *string,
		BOOL absolute)
{
    char *s;
    time_t now, clock2;
    int day, month, year, hour, minutes, seconds;
    char *start;
    char temp[8];

    /*
     * Make sure we have a string to parse.  - FM
     */
    if (!non_empty(string))
	return (0);
    s = string;
    CTRACE((tfp, "LYmktime: Parsing '%s'\n", s));

    /*
     * Skip any lead alphabetic "Day, " field and seek a numeric day field.  -
     * FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);

    /*
     * Get the numeric day and convert to an integer.  - FM
     */
    start = s;
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
    if (*s == '\0' || (s - start) > 2)
	return (0);
    LYstrncpy(temp, start, (int) (s - start));
    day = atoi(temp);
    if (day < 1 || day > 31)
	return (0);

    /*
     * Get the month string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isalnum(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);
    start = s;
    while (*s != '\0' && isalnum(UCH(*s)))
	s++;
    if ((*s == '\0') ||
	(s - start) < (isdigit(UCH(*(s - 1))) ? 2 : 3) ||
	(s - start) > (isdigit(UCH(*(s - 1))) ? 2 : 9))
	return (0);
    LYstrncpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
    switch (TOUPPER(temp[0])) {
    case '0':
    case '1':
	month = atoi(temp);
	if (month < 1 || month > 12) {
	    return (0);
	}
	break;
    case 'A':
	if (!strcasecomp(temp, "Apr")) {
	    month = 4;
	} else if (!strcasecomp(temp, "Aug")) {
	    month = 8;
	} else {
	    return (0);
	}
	break;
    case 'D':
	if (!strcasecomp(temp, "Dec")) {
	    month = 12;
	} else {
	    return (0);
	}
	break;
    case 'F':
	if (!strcasecomp(temp, "Feb")) {
	    month = 2;
	} else {
	    return (0);
	}
	break;
    case 'J':
	if (!strcasecomp(temp, "Jan")) {
	    month = 1;
	} else if (!strcasecomp(temp, "Jun")) {
	    month = 6;
	} else if (!strcasecomp(temp, "Jul")) {
	    month = 7;
	} else {
	    return (0);
	}
	break;
    case 'M':
	if (!strcasecomp(temp, "Mar")) {
	    month = 3;
	} else if (!strcasecomp(temp, "May")) {
	    month = 5;
	} else {
	    return (0);
	}
	break;
    case 'N':
	if (!strcasecomp(temp, "Nov")) {
	    month = 11;
	} else {
	    return (0);
	}
	break;
    case 'O':
	if (!strcasecomp(temp, "Oct")) {
	    month = 10;
	} else {
	    return (0);
	}
	break;
    case 'S':
	if (!strcasecomp(temp, "Sep")) {
	    month = 9;
	} else {
	    return (0);
	}
	break;
    default:
	return (0);
    }

    /*
     * Get the numeric year string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);
    start = s;
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
    if ((s - start) == 4) {
	LYstrncpy(temp, start, 4);
    } else if ((s - start) == 2) {
	now = time(NULL);
	/*
	 * Assume that received 2-digit dates >= 70 are 19xx; others
	 * are 20xx.  Only matters when dealing with broken software
	 * (HTTP server or web page) which is not Y2K compliant.  The
	 * line is drawn on a best-guess basis; it is impossible for
	 * this to be completely accurate because it depends on what
	 * the broken sender software intends.  (This totally breaks
	 * in 2100 -- setting up the next crisis...) - BL
	 */
	if (atoi(start) >= 70)
	    LYstrncpy(temp, "19", 2);
	else
	    LYstrncpy(temp, "20", 2);
	strncat(temp, start, 2);
	temp[4] = '\0';
    } else {
	return (0);
    }
    year = atoi(temp);

    /*
     * Get the numeric hour string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0') {
	hour = 0;
	minutes = 0;
	seconds = 0;
    } else {
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s != ':' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	hour = atoi(temp);

	/*
	 * Get the numeric minutes string and convert to an integer.  - FM
	 */
	while (*s != '\0' && !isdigit(UCH(*s)))
	    s++;
	if (*s == '\0')
	    return (0);
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s != ':' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	minutes = atoi(temp);

	/*
	 * Get the numeric seconds string and convert to an integer.  - FM
	 */
	while (*s != '\0' && !isdigit(UCH(*s)))
	    s++;
	if (*s == '\0')
	    return (0);
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s == '\0' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	seconds = atoi(temp);
    }

    /*
     * Convert to clock format (seconds since 00:00:00 Jan 1 1970), but then
     * zero it if it's in the past and "absolute" is not TRUE.  - FM
     */
    month -= 3;
    if (month < 0) {
	month += 12;
	year--;
    }
    day += (year - 1968) * 1461 / 4;
    day += ((((month * 153) + 2) / 5) - 672);
    clock2 = (time_t) ((day * 60 * 60 * 24) +
		       (hour * 60 * 60) +
		       (minutes * 60) +
		       seconds);
    if (absolute == FALSE && (long) (time((time_t *) 0) - clock2) >= 0)
	clock2 = (time_t) 0;
    if (clock2 > 0)
	CTRACE((tfp, "LYmktime: clock=%ld, ctime=%s",
		(long) clock2,
		ctime(&clock2)));

    return (clock2);
}

d5697 48
d5755 10
a5764 5
    if (lstat(name, &data) == 0
	&& S_ISREG(data.st_mode)
	&& (data.st_mode & (S_IWOTH | S_IWGRP)) == 0
	&& data.st_nlink == 1
	&& data.st_uid == getuid()) {
d5812 1
a5812 1
	result = !linked;
d5825 1
a5825 1
    BOOLEAN binary = strchr(mode, 'b') != 0;
d6034 1
a6034 1
	    int old_mask = umask(HIDE_UMASK);
d6084 1
a6084 1
	p->outs = (wrt != 'r');
d6423 1
a6423 1
    BibP_bibhost_available = HTLoadAbsolute(&bibhostIcon) == YES;
d6605 3
a6607 2
    char *cp;
    const char *cp2;
d6615 1
a6615 2
	return FALSE;
    }
d6617 1
a6617 1
    if (LYIsPipeCommand(given)) {
d6620 3
a6622 1
	    return FALSE;
a6623 3
	LYstrncpy(result, given, LY_MAXPATH);
	return TRUE;
    }
d6625 13
a6637 10
    if ((cp = strchr(given, '~')) != 0
	&& (cp2 = wwwName(Home_Dir())) != 0
	&& strlen(cp2) + strlen(given) < LY_MAXPATH) {
	*(cp++) = '\0';
	strcpy(result, given);
	LYTrimPathSep(result);
	strcat(result, cp2);
	strcat(result, cp);
	strcpy(given, result);
    }
d6639 14
a6652 14
    if (strchr(given, '/') != NULL) {
	strcpy(result, HTVMS_name("", given));
	strcpy(given, result);
    }
    if (given[0] != '/'
	&& strchr(given, ':') == NULL
	&& strlen(given) < LY_MAXPATH - 13) {
	strcpy(result, "sys$disk:");
	if (strchr(given, ']') == NULL)
	    strcat(result, "[]");
	strcat(result, given);
    } else {
	strcpy(result, given);
    }
d6656 1
a6656 1
    if (!LYisAbsPath(given)) {
d6658 3
a6660 3
	if (strchr(result, ':') != NULL)
	    cp = NULL;
	else
d6662 1
a6662 1
	{
d6664 1
a6664 1
	    static char buf[LY_MAXPATH];
d6666 1
a6666 1
	    cp = Current_Dir(buf);
d6668 1
a6668 1
	    cp = original_dir;
d6670 2
a6671 2
	}
    } else
d6673 1
a6673 1
	cp = NULL;
d6675 18
a6692 6
    *result = 0;
    if (cp) {
	LYTrimPathSep(cp);
	if (strlen(cp) >= LY_MAXPATH - 2)
	    return FALSE;
	sprintf(result, "%s/", cp);
d6694 1
a6694 6
    cp = HTSYS_name(given);
    if (strlen(result) + strlen(cp) >= LY_MAXPATH - 1)
	return FALSE;
    strcat(result, cp);
#endif /* VMS */
    return TRUE;
d6989 1
a6989 1
	int len;
d6995 1
a6995 1
		while ((len = fread(buff, 1, sizeof(buff), fin)) > 0) {
d7255 15
d7512 1
a7512 1
    int size = PASTE_BUFFER;
d7523 1
a7523 1
	len = fread(paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
d7541 1
a7541 1
    int l = strlen(s), res;
d7568 1
a7568 1
    napms(msec);
@


1.6
log
@make lynx(1) to use arc4random(4) instead of other random functions;

avoid a segfault by checking the value of TAB TO;
from Alexey Dobriyan <adobriyan@@gmail.com>; pushed by deraadt@@
@
text
@d9 2
a10 1
int kbhit(void);
d39 1
a39 5
#ifdef _WIN_CC
extern int exec_command(char * cmd, int wait_flag); /* xsystem.c */
#endif

#ifdef _WINDOWS	/* 1998/04/30 (Thu) 19:04:25 */
d50 4
a53 4
#  define BOOLEAN OS2_BOOLEAN		/* Conflicts, but is used */
#  undef HT_ERROR			/* Conflicts too */
#  define INCL_PM			/* I want some PM functions.. */
#  define INCL_DOSPROCESS		/* TIB PIB. */
d76 1
a76 1
#define UTMP_FILE __UTMPX_FILE  /* at least in OS/390  S/390 -- gil -- 2100 */
d78 1
a78 1
#define UTMP_FILE "/var/adm/utmpx" /* Digital Unix 4.0 */
d103 3
a105 2
extern int BSDselect PARAMS((int nfds, fd_set * readfds, fd_set * writefds,
			     fd_set * exceptfds, struct timeval * timeout));
d148 2
a149 2
PRIVATE HTList * localhost_aliases = NULL;	/* Hosts to treat as local */
PRIVATE char *HomeDir = NULL;			/* HOME directory */
d151 1
a151 1
PUBLIC	HTList * sug_filenames = NULL;		/* Suggested filenames	 */
d164 1
a164 1
PRIVATE LY_TEMP *ly_temp;
d166 1
a166 1
PRIVATE LY_TEMP *FindTempfileByName ARGS1(CONST char *, name)
d178 1
a178 1
PRIVATE LY_TEMP *FindTempfileByFP ARGS1(FILE *, fp)
d193 1
a193 1
PUBLIC char *LYGetEnv ARGS1(CONST char *, name)
d196 1
d206 1
a206 1
PUBLIC int ascii_tolower ARGS1(int, i)
d208 2
a209 2
    if ( 91 > i && i > 64 )
	return (i+32);
d214 1
a214 1
PUBLIC int ascii_toupper ARGS1(int, i)
d216 2
a217 2
    if ( 123 > i && i > 96 )
	return (i-32);
d222 1
a222 1
PUBLIC int ascii_isupper ARGS1(int, i)
d224 1
a224 1
    if ( 91 > i && i > 64 )
d235 2
a236 3
PUBLIC size_t utf8_length ARGS2(
	BOOL,		utf_flag,
	CONST char *,	data)
d253 1
a253 1
	     *  Garbage.
d257 1
a257 1
	if (strlen(data+1) < utf_extra) {
d259 1
a259 1
	     *  Shouldn't happen.
d268 16
d286 2
a287 3
PUBLIC void LYSetHilite ARGS2(
	int,		cur,
	char *,		text)
d289 1
a289 1
    links[cur].list.hl_base.hl_text = text;
d297 3
a299 4
PUBLIC void LYAddHilite ARGS3(
	int,		cur,
	char *,		text,
	int,		x)
d304 1
a304 1
    unsigned want = (list->hl_len += 1) * sizeof(HiliteInfo);
d307 1
a307 1
	have = realloc(have, want);
d309 1
a309 1
	have = malloc(want);
d319 2
a320 3
PUBLIC char *LYGetHiliteStr ARGS2(
	int,		cur,
	int,		count)
d322 1
a322 1
    char *result;
d336 2
a337 3
PUBLIC int LYGetHilitePos ARGS2(
	int,		cur,
	int,		count)
d346 1
a346 1
	result = links[cur].lx;
a349 3
#define LXP (links[cur].lx)
#define LYP (links[cur].ly)

d369 6
a374 7
PRIVATE BOOL show_whereis_targets ARGS6(
	int,	flag,
	int,	cur,
	int,	count,
	char *,	target,
	BOOL,	TargetEmphasisON,
	BOOL,	utf_flag)
d376 2
a377 2
    char *Data = NULL;
    char *cp;
d389 10
a398 10
     && (links[cur].type & WWW_LINK_TYPE)
     && non_empty(LYGetHiliteStr(cur, count))
     && links[cur].ly + count < display_lines
     && HText_getFirstTargetInLine(HTMainText,
				   links[cur].anchor_line_num + count,
				   utf_flag,
				   &Offset,
				   &tLen,
				   &theData,
				   target)) {
d400 1
a400 1
	char *data;
d403 1
a403 1
	int hLine = links[cur].ly + count;
d412 1
a412 2
		      (LYGetHiliteStr(cur, count) ?
		       LYGetHiliteStr(cur, count) : ""),
d414 1
a414 1
		      ((LYcols - 1) - LYGetHilitePos(cur, count)),
d418 1
a418 1
	      LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
d438 1
a438 1
		 && (offset + LenNeeded) < LYcols) {
d468 1
a468 1
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d532 1
a532 1
		     itmp++)  {
d540 1
a540 1
			LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d608 21
a628 18
		    /*
		     * See if we have another hit that starts within the
		     * hightext.  -FM
		     */
		 && ((cp = LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag, Data, offset - Offset),
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols
		    /*
		     * If the hit starts after the end of the hightext, or we
		     * are making the link current and the hit starts at its
		     * last character, we are done.  -FM
		     */
		 && (HitOffset + offset) <
		     (hoffset +
		      (flag == ON ? (hLen - 1) : hLen)))  {
d642 1
a642 1
highlight_hit_within_hightext:
d649 1
a649 1
	    if ((Offset - offset) <= (flag == ON ? (hLen - 1) : hLen))  {
d667 1
a667 1
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d675 1
a675 1
			(offset > hoffset && data[itmp+1] != '\0')) {
d696 1
a696 1
			(offset > hoffset && data[itmp+1] != '\0')) {
d712 1
a712 1
			(offset > hoffset && data[itmp+1] != '\0')) {
d734 1
a734 1
		     itmp++)  {
d742 1
a742 1
			LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d810 20
a829 16
		    /*
		     * See if we have another hit that starts within the
		     * hightext.  -FM
		     */
		 && ((cp = LYno_attr_mb_strstr(data = SKIP_GLYPHS(utf_flag, Data, offset - Offset),
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL)
		 && (offset + LenNeeded) < LYcols
		    /*
		     * If the hit starts after the end of the hightext, or we
		     * are making the link current and the hit starts at its
		     * last character, we are done.  -FM
		     */
		 && (HitOffset + offset) < (hoffset + (flag == ON ? (hLen - 1) : hLen))) {
d854 1
a854 1
			     itmp++)  {
d863 1
a863 1
				LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
d932 1
a932 1
highlight_search_done:
d939 2
a940 3
PRIVATE int find_cached_style ARGS2(
	int,	cur,
	int,	flag)
d945 3
a947 3
    if ( textfields_need_activation
     && links[cur].type == WWW_FORM_LINK_TYPE
     && F_TEXTLIKE(links[cur].l_form->type) )
d953 1
d961 1
a961 1
	if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW) {
d964 1
a964 1
			  LYP, LXP));
d967 1
a967 1
		for (x = LXP-1; x >= 0; x--) {
d973 2
a974 2
			CTRACE((tfp, "found %d, x_offset=%d.\n",
				cached_styles[LYP][x], (int)x-LXP));
d986 2
a987 1
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: can't use cache.\n"));
d998 1
a998 1
 *  Highlight (or unhighlight) a given link.
d1000 3
a1002 4
PUBLIC void LYhighlight ARGS3(
	int,		flag,
	int,		cur,
	char *,		target)
d1008 1
d1010 2
a1011 1
    char *hi_string;
d1016 1
a1016 1
    BOOL utf_flag = (BOOL)(LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
d1018 1
d1021 1
d1032 2
a1033 1
    if (cur < 0)
d1035 10
d1053 1
a1053 1
	    LYmove(LYP, LXP);
d1058 1
a1058 1
	 || LYGetHiliteStr(cur, 0) == NULL) {
d1061 1
a1061 1
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
d1074 2
a1075 2
	    int avail_space = (LYcols - links[cur].lx) - 1;
	    char *text = LYGetHiliteStr(cur, 0);
d1083 5
a1089 4
	    len = strlen(buffer);
	    for (; len < links[cur].l_form->size && len < avail_space; len++)
		LYaddch('_');

d1094 3
a1096 1
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n", LYP, LXP));
d1104 1
a1104 2
			  (LYGetHiliteStr(cur, 0) ?
			   LYGetHiliteStr(cur, 0) : ""),
d1106 1
a1106 1
			  ((LYcols - 1) - links[cur].lx),
d1112 1
a1112 1
	 *  Display a second line as well.
d1119 4
a1122 3
		    (hi_string = LYGetHiliteStr(cur, hi_count)) != NULL
		    && links[cur].ly + hi_count <= display_lines;
			++hi_count) {
d1125 2
a1126 2
		lynx_stop_link_color (flag == ON, links[cur].inUnderline);
		LYmove(links[cur].ly + hi_count, hi_offset);
d1131 2
a1132 2
			      links[cur].ly + hi_count, hi_offset,
			      flag == ON ? s_alink : s_a));
d1135 1
a1135 1
		lynx_start_link_color (flag == ON, links[cur].inUnderline);
d1139 1
a1139 1
			   && (i + hi_offset) < LYcols; i++) {
d1151 1
a1151 1
		     }
d1154 1
a1154 1
	    lynx_stop_link_color (flag == ON, links[cur].inUnderline);
a1155 1

d1158 2
a1159 2
		LYGetHiliteStr(cur, hi_count) != NULL;
			hi_count++) {
d1170 1
a1170 1
	     *	Get cursor out of the way.
d1176 1
a1176 1
	     *	Never hide the cursor if there's no FANCY CURSES or SLANG.
d1178 1
a1178 2
	    LYmove(links[cur].ly,
		 ((links[cur].lx > 0) ? (links[cur].lx - 1) : 0));
d1187 2
a1188 2
 *  free_and_clear will free a pointer if it
 *  is non-zero and then set it to zero.
d1190 1
a1190 2
PUBLIC void free_and_clear ARGS1(
	char **,	pointer)
d1200 8
a1207 9
 *  Convert single or serial newlines to single spaces throughout a string
 *  (ignore newlines if the preceding character is a space) and convert
 *  tabs to single spaces.  Don't ignore any explicit tabs or spaces if
 *  the condense argument is FALSE, otherwise, condense any serial spaces
 *  or tabs to one space. - FM
 */
PUBLIC void convert_to_spaces ARGS2(
	char *,		string,
	BOOL,		condense)
d1216 1
a1216 2
    for ( ; (*s && !isspace(*s)); s++)
	;
d1221 11
a1231 4
	    case ' ':
	    case '\t':
		if (!(condense && last_is_space))
		    *(ns++) = ' ';
d1233 2
a1234 1
		break;
d1236 4
a1239 12
	    case '\r':
	    case '\n':
		if (!last_is_space) {
		    *(ns++) = ' ';
		    last_is_space = TRUE;
		}
		break;

	    default:
		*(ns++) = *s;
		last_is_space = FALSE;
		break;
d1248 1
a1248 1
 *  Strip trailing slashes from directory paths.
d1250 1
a1250 2
PUBLIC char * strip_trailing_slash ARGS1(
	char *,		dirname)
d1257 14
a1270 1
    return(dirname);
d1274 1
a1274 1
 *  Display (or hide) the status line.
d1278 1
a1278 2
PUBLIC void statusline ARGS1(
	CONST char *,	text)
d1283 1
d1292 1
a1292 1
     *	Don't print statusline messages if dumping to stdout.
d1298 1
a1298 1
     *	Don't print statusline message if turned off.
d1308 1
a1308 1
    LYstrncpy(text_buff, text, sizeof(text_buff)-1);
d1311 1
a1311 1
	p= '\0';
d1314 3
a1316 3
     *	Deal with any CJK escape sequences and Kanji if we have a CJK
     *	character set selected, otherwise, strip any escapes.  Also,
     *	make sure text is not longer than the statusline window. - FM
d1318 3
a1320 2
    max_length = ((LYcols - 2) < (int)sizeof(buffer))
		? (LYcols - 2) : (int)sizeof(buffer)-1;
d1324 1
a1324 1
	 *  Translate or filter any escape sequences. - FM
d1327 2
a1328 1
	    outofmem(__FILE__, "statusline");
d1330 1
a1330 1
	    TO_EUC((CONST unsigned char *)text_buff, temp);
d1336 1
a1336 1
		TO_SJIS((CONST unsigned char *)text_buff, temp);
d1342 1
a1342 1
		if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
d1350 1
a1350 1
	 *  Deal with any newlines or tabs in the string. - FM
d1352 1
a1352 1
	convert_to_spaces((char *)temp, FALSE);
d1355 2
a1356 2
	 *  Handle the Kanji, making sure the text is not
	 *  longer than the statusline window. - FM
d1376 19
a1394 7
	 *  Strip any escapes, and shorten text if necessary.  Note
	 *  that we don't deal with the possibility of UTF-8 characters
	 *  in the string.  This is unlikely, but if strings with such
	 *  characters are used in LYMessages_en.h, a compilation
	 *  symbol of HAVE_UTF8_STATUSLINES could be added there, and
	 *  code added here for determining the displayed string length,
	 *  as we do above for CJK. - FM
d1397 1
a1397 1
	    if (text_buff[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
d1402 1
a1402 4
	/*
	 *  Deal with any newlines or tabs in the string. - FM
	 */
	convert_to_spaces(buffer, FALSE);
d1406 2
a1407 2
     *	Move to the desired statusline window and
     *	output the text highlighted. - FM
d1410 2
a1411 2
	if (LYStatusLine < LYlines-1) {
	    LYmove(LYStatusLine, 0);
d1413 1
a1413 1
	    LYmove(LYlines-1, 0);
d1416 1
a1416 1
	LYmove(LYlines-3, 0);
d1418 1
a1418 1
	LYmove(LYlines-1, 0);
d1420 1
d1423 1
a1423 1
    if (text != NULL && text[0] != '\0') {
a1441 1

d1443 3
a1445 3
	lynx_start_status_color ();
	LYaddstr (buffer);
	lynx_stop_status_color ();
d1449 14
a1462 10
		int a = (strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN)
			|| !hashStyles[s_alert].name)
			? s_status
			: s_alert;
		LynxChangeStyle (a, STACK_ON);
		LYaddstr(buffer);
		wbkgdset(LYwin,
			 ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
			  ? hashStyles[a].color
			  :A_NORMAL) | ' ');
d1464 8
a1471 7
		if (!(lynx_has_color && LYShowColor >= SHOW_COLOR_ON))
		    wbkgdset(LYwin, A_NORMAL | ' ');
		else if (s_normal != NOSTYLE)
		    wbkgdset(LYwin, hashStyles[s_normal].color | ' ');
		else
		    wbkgdset(LYwin, displayStyles[DSTYLE_NORMAL].color | ' ');
		LynxChangeStyle (a, STACK_OFF);
d1480 1
a1480 2
PRIVATE char *novice_lines ARGS1(
	int,		lineno)
d1496 1
a1496 1
PUBLIC void toggle_novice_line NOARGS
d1498 4
a1501 4
	lineno++;
	if (*novice_lines(lineno) == '\0')
		lineno = 0;
	return;
d1504 1
a1504 2
PUBLIC void noviceline ARGS1(
	int,		more_flag GCC_UNUSED)
a1505 1

d1509 1
a1509 2
    LYmove(LYlines-2,0);
    /* lynx_stop_reverse(); */
d1512 2
d1524 1
a1524 1
	LYaddstr((char *)novice_lines(lineno));
d1530 1
a1530 1
#if defined(NSL_FORK) || defined(MISC_EXP)
d1532 67
a1598 5
 *  Returns the file descriptor from which keyboard input is expected,
 *  or INVSOC (-1) if not available.
 *  If need_selectable is true, returns non-INVSOC fd only if select()
 *  is possible - actually, currently only checks if fd is connected
 *  to a tty. - kw
d1600 1
a1600 2
PUBLIC int LYConsoleInputFD ARGS1(
    BOOLEAN,		need_selectable)
d1603 1
d1608 3
a1610 3
    /* SLang_TT_Read_FD introduced in slang 0.99.19, from its changelog:
     *   SLang_TT_Read_FD variable is now available for unix.  This is the file
     *   descriptor used by SLang_getkey. */
d1614 1
a1614 1
#else  /* !USE_SLANG */
d1629 1
a1629 1
PRIVATE int fake_zap = 0;
d1631 1
a1631 2
PUBLIC void LYFakeZap ARGS1(
    BOOL,	set)
d1648 1
a1648 1
PRIVATE int DontCheck NOARGS
d1655 1
a1655 1
	return(TRUE);
d1657 2
a1658 2
    if (LYHaveCmdScript()) /* we may be running from a script */
	return(TRUE);
d1662 1
a1662 1
	return(TRUE);
d1672 2
a1673 1
	gettimeofday(&tv, (struct timezone *)0);
d1677 1
a1677 1
    next = time((time_t*)0);
d1686 1
a1686 1
PUBLIC int HTCheckForInterrupt NOARGS
a1689 6
#ifndef VMS /* UNIX stuff: */
#if !defined(USE_SLANG)
    struct timeval socket_timeout;
    int ret = 0;
    fd_set readfds;
#endif /* !USE_SLANG */
d1696 1
a1696 1
	return((int)TRUE);
d1701 3
a1703 1
	return((int)FALSE);
d1706 4
d1717 1
d1720 1
a1721 1
	return(FALSE);
d1724 9
a1732 5

    socket_timeout.tv_sec = 0;
    socket_timeout.tv_usec = 0;
    FD_ZERO(&readfds);
    FD_SET(0, &readfds);
d1734 3
a1736 4
    if (socks_flag)
	ret = Rselect(1, (void *)&readfds, NULL, NULL,
		      &socket_timeout);
    else
d1738 1
a1738 2
	ret = select(1, (void *)&readfds, NULL, NULL,
		     &socket_timeout);
d1740 8
a1747 7
    /** Suspended? **/
    if ((ret == -1) && (SOCKET_ERRNO == EINTR))
	 return((int)FALSE);

    /** No keystroke was entered? **/
    if (!FD_ISSET(0,&readfds))
	 return((int)FALSE);
d1749 1
a1751 3
#if defined(PDCURSES)
    nodelay(LYwin,TRUE);
#endif /* PDCURSES */
d1753 1
a1753 1
     * 'c' contains whatever character we're able to read from keyboard
d1755 9
d1765 1
a1765 3
#if defined(PDCURSES)
    nodelay(LYwin,FALSE);
#endif /* PDCURSES */
d1768 1
a1768 13
    extern int typeahead();

    if (fake_zap > 0) {
	fake_zap--;
	CTRACE((tfp, "\r *** Got simulated 'Z' ***\n"));
	CTRACE_FLUSH(tfp);
	CTRACE_SLEEP(AlertSecs);
	return((int)TRUE);
    }

    /** Curses or slang setup was not invoked **/
    if (DontCheck())
	return((int)FALSE);
d1773 1
a1773 1
	return((int)TRUE);
a1775 3
    /*
     * 'c' contains whatever character we're able to read from keyboard
     */
d1784 1
a1784 1
	/** Keyboard 'Z' or 'z', or Control-G or Control-C **/
d1786 1
a1786 1
	return((int)TRUE);
d1788 6
a1793 6
	/* There is a subset of mainloop() actions available at this stage:
	** no new getfile() cycle is possible until the previous finished.
	** Currently we have scrolling in partial mode, toggling of trace
	** log, and pasting. User search now in progress...
	*/
    cmd = (LKC_TO_LAC(keymap,c));
d1795 1
a1795 1
    case LYK_TRACE_TOGGLE :	/*  Toggle TRACE mode. */
d1799 2
a1800 2
    case LYK_TO_CLIPBOARD: {	/* ^S */
	char *s = LYDownLoadAddress();
d1802 8
a1809 8
	if (!s || !*s || put_clip(s))
	    HTInfoMsg(gettext("Copy to clipboard failed."));
	else
	    HTInfoMsg(gettext("Download document URL put to clipboard."));
	break;
    }
#endif	/* defined CAN_CUT_AND_PASTE */
    default :
d1828 3
a1830 3
	    case LYK_FASTBACKW_LINK :
		if (Newline_partial <= (display_lines)+1) {
		    Newline_partial -= display_lines ;
d1837 1
a1837 1
		    Newline_partial -= display_lines ;
d1840 1
a1840 1
	    case LYK_FASTFORW_LINK :
d1844 6
a1849 6
			HTGetLinkOrFieldStart(HText_LinksInLines(HTMainText,
								 Newline_partial,
								 display_lines)
					      - 1,
					      &Newline_partial, NULL,
					      1, TRUE)) == LINK_LINE_FOUND) {
d1854 1
a1854 1
	    case LYK_PREV_PAGE :
d1856 3
a1858 3
		    Newline_partial -= display_lines ;
		break ;
	    case LYK_NEXT_PAGE :
d1860 3
a1862 3
		    Newline_partial += display_lines ;
		break ;
	    case LYK_UP_HALF :
d1864 3
a1866 3
		    Newline_partial -= (display_lines/2) ;
		break ;
	    case LYK_DOWN_HALF :
d1868 3
a1870 3
		    Newline_partial += (display_lines/2) ;
		break ;
	    case LYK_UP_TWO :
d1872 3
a1874 3
		    Newline_partial -= 2 ;
		break ;
	    case LYK_DOWN_TWO :
d1876 2
a1877 2
		    Newline_partial += 2 ;
		break ;
d1885 1
a1885 1
		    /* calculate for "current" bottom value */
d1887 3
a1889 3
	    case LYK_REFRESH :
		break ;
	    default :
d1891 2
a1892 2
		return ((int)FALSE) ;
	    } /* end switch */
d1900 1
a1900 1
    } /* end switch */
d1902 1
a1902 1
    return((int)FALSE);
d1909 1
a1909 2
PUBLIC BOOLEAN LYisAbsPath ARGS1(
	CONST char *,	path)
d1912 1
d1919 2
a1920 2
	 || (LYIsDosDrive(path)
	   && LYIsPathSep(path[2])));
d1932 1
a1932 2
PUBLIC BOOLEAN LYisRootPath ARGS1(
	CONST char *,		path)
d1936 2
a1937 2
     && LYIsDosDrive(path)
     && LYIsPathSep(path[2]))
d1944 2
a1945 2
 *  A file URL for a remote host is an obsolete ftp URL.
 *  Return YES only if we're certain it's a local file. - FM
d1947 1
a1947 2
PUBLIC BOOLEAN LYisLocalFile ARGS1(
	CONST char *,		filename)
d1966 2
a1967 2
	if (0==strcmp("file", acc_method) &&
	    (0==strcmp(host, "localhost") ||
d1981 2
a1982 2
 *  Utility for checking URLs with a host field.
 *  Return YES only if we're certain it's the local host. - FM
d1984 1
a1984 2
PUBLIC BOOLEAN LYisLocalHost ARGS1(
	CONST char *,		filename)
d2013 1
a2013 1
 *  Utility for freeing the list of local host aliases. - FM
d2015 1
a2015 1
PUBLIC void LYLocalhostAliases_free NOARGS
d2017 3
a2019 2
    char *alias;
    HTList *cur = localhost_aliases;
d2021 6
a2026 2
    if (!cur)
	return;
d2028 6
a2033 4
    while (NULL != (alias = (char *)HTList_nextObject(cur))) {
	FREE(alias);
    }
    HTList_delete(localhost_aliases);
a2034 1
    return;
d2038 1
a2038 1
 *  Utility for listing hosts to be treated as local aliases. - FM
d2040 1
a2040 2
PUBLIC void LYAddLocalhostAlias ARGS1(
	char *,		alias)
d2061 2
a2062 2
 *  Utility for checking URLs with a host field.
 *  Return YES only if we've listed the host as a local alias. - FM
d2064 1
a2064 2
PUBLIC BOOLEAN LYisLocalAlias ARGS1(
	CONST char *,		filename)
d2083 1
a2083 1
    while (NULL != (alias = (char *)HTList_nextObject(cur))) {
d2095 11
a2105 12
**  This function checks for a URL with an unknown scheme,
**  but for which proxying has been set up, and if so,
**  returns PROXY_URL_TYPE. - FM
**
**  If a colon is present but the string segment which
**  precedes it is not being proxied, and we can be sure
**  that what follows the colon is not a port field,
**  it returns UNKNOWN_URL_TYPE.  Otherwise, it returns
**  0 (not a URL). - FM
*/
PUBLIC int LYCheckForProxyURL ARGS1(
	char *,		filename)
d2112 1
a2112 1
     *	Don't crash on an empty argument.
d2115 1
a2115 1
	return(NOT_A_URL_TYPE);
d2124 3
a2126 1
    if ((cp1 = strchr((cp+1), ':')) != NULL) {
d2128 1
d2134 1
a2134 1
	    return(PROXY_URL_TYPE);
d2139 1
a2139 1
	    return(NOT_A_URL_TYPE);
d2143 1
a2143 1
	    return(NOT_A_URL_TYPE);
d2148 1
a2148 1
		return(UNKNOWN_URL_TYPE);
d2150 1
a2150 1
	    return(UNKNOWN_URL_TYPE);
d2154 1
a2154 1
    return(NOT_A_URL_TYPE);
d2161 3
a2163 4
static BOOLEAN compare_type ARGS3(
	char *,		tst,
	CONST char *,	cmp,
	size_t,		len)
d2168 1
d2184 12
a2195 13
**  Must recognize a URL and return the type.
**  If recognized, based on a case-insensitive
**  analysis of the scheme field, ensures that
**  the scheme field has the expected case.
**
**  Returns 0 (not a URL) for a NULL argument,
**  one which lacks a colon.
**
**  Chains to LYCheckForProxyURL() if a colon
**  is present but the type is not recognized.
*/
PUBLIC int is_url ARGS1(
	char *,		filename)
d2199 1
a2199 1
    int result = NOT_A_URL_TYPE;
d2204 1
a2204 1
     *	Don't crash on an empty argument.
d2207 1
a2207 1
	return(result);
d2210 1
a2210 1
     *	Can't be a URL if it lacks a colon.
d2213 1
a2213 1
	return(result);
d2216 1
a2216 1
     *	Kill beginning spaces.
d2221 4
a2224 5
     *	Can't be a URL if it starts with a slash.
     *	So return immediately for this common case,
     *	also to avoid false positives if there was
     *	a colon later in the string.  Also can't be
     *  a URL if it starts with a colon. - KW
d2235 2
a2236 2
	     *  Lynx internal pages ("LYNXfoo:" or "lynxfoo:")
	     *  start with 'l' or 'L', other URLs aren't.
d2240 3
a2242 3
		 *  Special External Lynx type to handle execution
		 *  of commands or scripts which require a pause to
		 *  read the screen upon completion.
d2248 3
a2250 3
		 *  Special External Lynx type to handle execution
		 *  of commands, scripts or programs with do not
		 *  require a pause to read screen upon completion.
d2256 1
a2256 1
		 *  Special External Lynx type to handle cgi scripts.
d2262 1
a2262 1
		 *  Special Internal Lynx type.
d2268 1
a2268 1
		 *  Special Internal Lynx type.
d2274 1
a2274 1
		 *  Special Internal Lynx type.
d2280 1
a2280 1
		 *  Special Internal Lynx type.
d2286 1
a2286 1
		 *  Special Internal Lynx type.
d2292 1
a2292 1
		 *  Special Internal Lynx type.
d2298 1
a2298 1
		 *  Special Internal Lynx type.
d2304 1
a2304 1
		 *  Special Internal Lynx type.
d2310 1
a2310 1
		 *  Special Internal Lynx type.
d2316 1
a2316 1
		 *  Special Internal Lynx type.
d2319 1
a2319 1
		(void)is_url(&cp[LEN_LYNXIMGMAP]);
d2324 1
a2324 1
		 *  Special Internal Lynx type.
d2331 1
a2331 1
	     *  NEWSfoo: schemes -
d2343 1
a2343 1
		 *  Special Lynx type to handle news posts.
d2349 1
a2349 1
		 *  Special Lynx type to handle news replies (followups).
d2356 1
a2356 1
	     *  SNEWSfoo: schemes -
d2365 1
a2365 1
		 *  Special Lynx type to handle snews posts.
d2371 1
a2371 1
		 *  Special Lynx type to handle snews replies (followups).
d2423 2
a2424 2
	    && ((cp1 = strchr(cp + 3, ':')) == NULL
	     || !DoubleHtmlSep(cp1 + 1))) {
d2432 2
a2433 2
		 && (cp1 - cp) > 1	/* exclude DOS-style device:/path */
		 && LYisAbsPath(cp1+1)) {
d2454 1
a2454 1
			 && (cp1 = strchr(cp+11,'/')) != NULL) {
d2456 1
a2456 1
			    if (TOUPPER(*(cp1+1)) == 'H' || *(cp1+1) == 'w')
d2459 1
a2459 1
			    else if (*(cp1+1) == 'T' || *(cp1+1) == '8')
d2461 1
a2461 1
			    else if (*(cp1+1) == '7')
d2528 4
a2531 4
 *  Sometimes it is just expected that curses is on when an alert or
 *  other statusline message needs to be shown and we are not just
 *  dumping immediately.  Calling this will 'fix' it, but may not
 *  always be appropriate. - kw
d2533 1
a2533 2
PUBLIC void LYFixCursesOn ARGS1(
    CONST char *,	reason)
d2544 12
a2555 13
 *  Most protocol modules called through HTLoad* expect that curses is on
 *  unless dump_output_immediately is set, so that statusline messages
 *  can be shown.  Some protocols expect the opposite, namely telnet and
 *  friends.  This function should be called after the 'physical' URL
 *  for accessing addr has been established.  It does the right thing
 *  to the degree that curses is turned on for known problem cases.
 *  In any normal circumstances this should never apply, but proxying
 *  or rule substitution is not prevented for telnet-like URLs, and
 *  this 'fix' avoids some crashes that can otherwise occur. - kw
 */
PUBLIC BOOLEAN LYFixCursesOnForAccess ARGS2(
    CONST char *,	addr,
    CONST char *,	physical)
d2558 1
a2558 1
     *  If curses is off when maybe it shouldn't...
d2562 1
d2564 2
a2565 2
	 *  If requested resource wants to be accessed with curses off, and
	 *  getfile() would indeed have turned curses off for it...
d2572 2
a2573 2
	      (cp1 = strchr(addr+11,'/')) != NULL &&
	      (*(cp1+1) == 'T' || *(cp1+1) == '8')))) {
d2575 2
a2576 2
	     *  If actual access that will be done is ok with curses off,
	     *  then do nothing special, else force curses on. - kw
d2582 1
a2582 2
		HTAlert(
		    gettext("Unexpected access protocol for this URL scheme."));
d2587 1
a2587 1
	return FALSE;
d2591 1
a2591 1
 *  Determine whether we allow HEAD and related flags for a URL. - kw
d2593 1
a2593 2
PUBLIC BOOLEAN LYCanDoHEAD ARGS1(
    CONST char *,	address)
d2597 1
d2618 3
a2620 3
     *  The idea of the following is to allow HEAD for news URLs that
     *  identify single articles, not those that identify ranges of
     *  articles or groups or a list of groups. - kw
d2625 1
a2637 1

d2639 3
a2641 3
/*  If defined, also allow head requests for URLs proxied through the
 *  "http" or "lynxcgi" protocols, which understand HEAD.  Only the
 *  proxy environment variables are checked, not the HTRules system. - kw
d2646 1
d2649 1
d2671 1
a2671 2
PUBLIC BOOLEAN LYCloseInput ARGS1(
	FILE *,		fp)
d2675 1
d2687 1
a2687 2
PUBLIC BOOLEAN LYCloseOutput ARGS1(
	FILE *,		fp)
d2691 1
d2704 1
a2704 2
PUBLIC BOOLEAN LYCanWriteFile ARGS1(
	CONST char*,	filename)
d2718 1
a2718 2
PUBLIC BOOLEAN LYCanReadFile ARGS1(
	CONST char*,	filename)
d2722 4
a2725 2
    if ((fp = fopen(filename, "r")) != 0) {
	return LYCloseInput(fp);
d2731 1
a2731 1
 *  Remove backslashes from any string.
d2733 1
a2733 2
PUBLIC void remove_backslashes ARGS1(
	char *,		buf)
d2737 1
a2737 1
    for (cp = buf; *cp != '\0' ; cp++) {
d2739 1
a2739 1
	if (*cp != '\\') { /* don't print slashes */
d2743 1
a2743 1
		   *(cp+1) == '\\') {	/* are two in a row	    */
d2753 2
a2754 3
 *  Checks to see if the current process is attached
 *  via a terminal in the local domain.
 *
d2756 1
a2756 1
PUBLIC BOOLEAN inlocaldomain NOARGS
d2777 2
a2778 2
		  me.ut_host + strlen(me.ut_host) - strlen(LYLocalDomain)) )
	    return(TRUE);
d2782 1
a2782 1
	    return(TRUE);
d2786 3
a2788 2
	CTRACE((tfp, "Could not get ttyname (returned %s) or open UTMP file %s\n",
		      (cp != 0) ? cp : "<null>", UTMP_FILE));
d2791 1
a2791 1
    return(FALSE);
d2794 1
a2794 1
    return(TRUE);
d2800 4
a2803 5
 *  An extended alternative for calling signal(), sets some flags for
 *  signal handler as we want them if that functionality is available.
 *  (We don't return anything from this function since the return
 *  value would currently be ignored anyway.) - kw
 *
d2805 2
a2806 3
PUBLIC void LYExtSignal ARGS2(
    int,			sig,
    LYSigHandlerFunc_t *,	handler)
d2812 1
d2830 7
a2836 6
 *  For switching a signal's handling between SIG_DFL and something
 *  (possibly) different that may have been set up by lynx code or
 *  e.g. by curses library.  Uses sigaction to preserve / restore as
 *  much state as possible.
 *  Second arg is where to save or restore from.
 *  Third arg to_dfl specifies what to do:
d2840 7
a2846 8
 *  Currently only used for SIGTSTP without SLANG, to prevent (n)curses
 *  signal handler from running while lynx is waiting in system() for
 *  an interactive command like an editor. - kw
 */
PRIVATE BOOLEAN LYToggleSigDfl ARGS3(
    int,			sig,
    struct sigaction *,		where,
    int,			to_dfl)
d2875 2
a2876 2
** This bit of code catches window size change signals
**/
d2893 3
a2895 3
#   endif /* HAVE_TERMIO_H */
#  endif /* HAVE_TERMIOS_H */
# endif	/* TERMIO_AND_TERMIOS */
d2898 1
a2898 2
PUBLIC void size_change ARGS1(
	int,		sig GCC_UNUSED)
d2908 1
a2908 1
    LYcols  = SLtt_Screen_Cols;
d2912 1
a2912 1
    SLtt_Screen_Cols = (LYcols-1) * 6;
d2916 1
a2916 1
    SLtt_Screen_Cols = HTMIN((LYcols-1) * 6, 255);
d2921 1
a2921 1
	 *  Called from start_curses().
d2928 1
d2975 1
a2975 1
     *	Check if the screen size has actually changed. - AJL
d2988 1
a2988 1
    LYExtSignal (SIGWINCH, size_change);
d2995 1
a2995 1
 *  Utility for freeing the list of previous suggested filenames. - FM
d2997 1
a2997 1
PUBLIC void HTSugFilenames_free NOARGS
d2999 1
a2999 10
    char *fname;
    HTList *cur = sug_filenames;

    if (!cur)
	return;

    while (NULL != (fname = (char *)HTList_nextObject(cur))) {
	FREE(fname);
    }
    HTList_delete(sug_filenames);
a3000 1
    return;
d3004 2
a3005 2
 *  Utility for listing suggested filenames, making any
 *  repeated filenames the most current in the list. - FM
d3007 1
a3007 2
PUBLIC void HTAddSugFilename ARGS1(
	char *,		fname)
d3009 1
a3009 1
    char *new = NULL;
d3016 1
a3016 1
    StrAllocCopy(new, fname);
d3023 1
a3023 1
	HTList_addObject(sug_filenames, new);
d3028 2
a3029 2
    while (NULL != (old = (char *)HTList_nextObject(cur))) {
	if (!strcmp(old, new)) {
d3035 1
a3035 1
    HTList_addObject(sug_filenames, new);
d3041 2
a3042 2
 *  CHANGE_SUG_FILENAME -- Foteos Macrides 29-Dec-1993
 *	Upgraded for use with Lynx2.2 - FM 17-Jan-1994
d3044 1
a3044 2
PUBLIC void change_sug_filename ARGS1(
	char *,		fname)
d3046 1
a3046 1
    CONST char *cp2;
d3048 1
d3055 1
a3055 1
     *	Establish the current end of fname.
d3060 1
a3060 1
     *	Unescape fname.
d3065 1
a3065 1
     *	Rename any temporary files.
d3076 1
a3076 1
	HTSprintf0(&temp, "file://localhost%s%d", cp2, (int)getpid());
d3078 1
a3078 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp2, (int)getpid());
d3092 3
a3094 3
	 *  Hmm... we have a directory name.
	 *  It is annoying to see a scheme+host+path name as a suggested one,
	 *  let's remove the last_slash and go ahead like we have a file name. - LP
d3099 1
a3099 1
     *	Remove everything up the the last_slash if there is one.
d3101 1
a3101 1
    if ((cp = strrchr(fname,'/')) != NULL && strlen(cp) > 1) {
d3104 1
a3104 1
	 *  Go past the slash.
d3112 2
a3113 2
#ifdef _WINDOWS	/* 1998/05/05 (Tue) 10:08:05 */
    if ((cp = strrchr(fname,'=')) != NULL && strlen(cp) > 1) {
d3116 1
a3116 1
	 *  Go past the '='.
d3127 1
a3127 1
     *	Trim off date-size suffix, if present.
d3137 1
a3137 1
     *	Trim off VMS device and/or directory specs, if present.
d3139 2
a3140 2
    if ((cp = strchr(fname,'[')) != NULL &&
	(cp1 = strrchr(cp,']')) != NULL && strlen(cp1) > 1) {
d3142 1
a3142 1
	for (cp=fname; *cp1 != '\0'; cp1++) {
a3146 1

d3149 1
a3149 1
     *	Replace illegal or problem characters.
d3154 1
a3154 1
	 *  Replace with underscores.
d3159 3
a3161 3
	/*
	 *  Replace with dashes.
	 */
d3163 1
a3163 1
		   *cp == ',' || *cp == ':' || *cp == '\"' ||
d3169 1
a3169 1
		   *cp <  ' ' || (UCH(*cp)) > 126) {
d3175 1
a3175 1
     *	Collapse any serial underscores.
d3189 1
a3189 1
     *	Collapse any serial dashes.
d3197 1
a3197 1
	}  else {
d3204 1
a3204 2
     *	Trim any trailing or leading
     *	underscores or dashes.
d3224 4
a3227 7
     *	Replace all but the last period with _'s, or second
     *	to last if last is followed by a terminal Z or z,
     *	or GZ or gz,
     *	e.g., convert foo.tar.Z to
     *		      foo.tar_Z
     *	  or, convert foo.tar.gz to
     *		      foo.tar-gz
d3232 1
a3232 1
	    if ((fname[j-1] == '.') &&
d3236 2
a3237 2
	    } else if (((TOUPPER(fname[j-1]) == 'G') &&
			fname[j-2] == '.') &&
d3249 2
a3250 2
	 *  But if the root is > 39 characters, move
	 *  the period appropriately to the left.
d3255 1
a3255 1
		*cp  = '.';
d3258 1
a3258 1
		*cp  = '.';
d3263 1
a3263 1
		    fname[j] = fname[j-1];
d3280 1
a3280 1
	 *  Make sure the extension is < 40 characters.
d3287 1
a3287 1
	 *  Trim trailing dashes or underscores.
d3295 2
a3296 3
	 *  No period, so put one on the end, or after
	 *  the 39th character, trimming trailing dashes
	 *  or underscores.
d3312 1
a3312 1
     *	Replace problem characters.
d3316 5
a3320 5
	    case '\'':
	    case '\"':
	    case '/':
	    case ' ':
		*cp = '-';
d3326 1
a3326 1
     *	Make sure the rest of the original string in nulled.
d3339 3
a3341 4
PRIVATE int fmt_tempname ARGS3(
	char *,		result,
	CONST char *,	prefix,
	CONST char *,	suffix)
d3344 1
d3376 3
a3378 3
    while (names_used < MAX_TEMPNAME) {
	counter = (unsigned)(( (float)MAX_TEMPNAME * lynx_rand() ) / LYNX_RAND_MAX + 1);
	counter %= SIZE_TEMPNAME;	/* just in case... */
d3384 10
a3393 7
	offset = counter / BITS_PER_CHAR;
	mask = 1 << (counter % BITS_PER_CHAR);
	if ((used_tempname[offset] & mask) == 0) {
	    names_used++;
	    used_tempname[offset] |= mask;
	    break;
	}
d3409 1
a3409 1
    sprintf(leaf, "%04x%04x", counter, (unsigned)GETPID());
d3411 1
a3411 1
    sprintf(leaf, "%u%u", counter, (unsigned)getpid());
d3416 2
a3417 1
	CONST char *tail = strchr(suffix, '.');
d3425 1
a3425 1
    sprintf(leaf, "L%u-%uTMP%s", (unsigned)getpid(), counter, suffix);
d3434 1
a3434 1
	sprintf(result, "%.*s", LY_MAXPATH-1, leaf);
d3442 1
a3442 1
 *  Convert 4, 6, 2, 8 to left, right, down, up, etc.
d3444 1
a3444 2
PUBLIC int number2arrows ARGS1(
	int,		number)
d3446 28
a3473 28
    switch(number) {
	case '1':
	    number=END_KEY;
	    break;
	case '2':
	    number=DNARROW;
	    break;
	case '3':
	    number=PGDOWN;
	    break;
	case '4':
	    number=LTARROW;
	    break;
	case '5':
	    number=DO_NOTHING;
	    break;
	case '6':
	    number=RTARROW;
	    break;
	case '7':
	    number=HOME;
	    break;
	case '8':
	    number=UPARROW;
	    break;
	case '9':
	    number=PGUP;
	    break;
d3476 1
a3476 1
    return(number);
d3480 2
a3481 2
 *  parse_restrictions takes a string of comma-separated restrictions
 *  and sets the corresponding flags to restrict the facilities available.
d3483 3
a3485 3
/* The first two are special: we want to record whether "default" or
 * "all" restrictions were applied, in addition to the detailed effects
 * of those options. - kw
d3489 3
a3491 3

PRIVATE CONST struct {
    CONST char *name;
d3585 1
d3587 8
a3594 9
/*  This will make no difference between '-' and '_'. It does only in/equality
    compare. It assumes that p2 can't contain dashes, but p1 can.
    This function is also used (if macro OPTNAME_ALLOW_DASHES doesn't have
    value of zero) for compare of commandline options -VH
 */
PUBLIC BOOL strn_dash_equ ARGS3(
	CONST char*,	p1,
	CONST char*,	p2,
	int,		len)
d3598 1
a3598 1
	    return 0;/* canonical name is shorter */
d3600 10
a3609 1
	    case 0:
a3610 9
	    case '-':
	    case '_':
		if (*p2!='_')
		    return 0;
		else
		    break;
	    default:
		if (*p1!=*p2)
		    return 0;
d3612 2
a3613 1
	++p1; ++p2;
d3635 1
a3635 2
PUBLIC CONST char *index_to_restriction ARGS1(
    int,	inx)
d3646 2
a3647 3
PUBLIC int find_restriction ARGS2(
    CONST char *,	name,
    int,		len)
d3650 1
d3653 1
a3653 1
    for (i=0; i < TABLESIZE(restrictions); i++) {
d3661 1
a3661 2
PUBLIC void parse_restrictions ARGS1(
    CONST char *,	s)
d3663 2
a3664 2
    CONST char *p;
    CONST char *word;
d3678 1
a3678 1
	if (RESTRICT_NM_EQU(word, "all", p-word)) {
d3680 3
a3682 1
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
d3684 1
a3684 1
	} else if (RESTRICT_NM_EQU(word, "default", p-word)) {
d3686 3
a3688 1
	    for (i = N_SPECIAL_RESTRICT_OPTIONS; i < TABLESIZE(restrictions); i++)
d3691 2
a3692 2
	    for (i=0; i < TABLESIZE(restrictions); i++) {
		if (RESTRICT_NM_EQU(word, restrictions[i].name, p-word)) {
d3700 3
a3702 2
	    printf("%s: %.*s\n", gettext("unknown restriction"), p-word, word);
	    exit(EXIT_FAILURE);
d3721 1
a3721 2
PUBLIC void print_restrictions_to_fd ARGS1(
    FILE *,	fp)
d3725 1
a3725 1
    for (i=0; i < TABLESIZE(restrictions); i++) {
d3735 1
a3735 1
    for (i=0; i < TABLESIZE(restrictions); i++) {
d3741 1
a3741 1
	     || !no_goto)
d3752 5
a3756 6
typedef struct _VMSMailItemList
{
  short buffer_length;
  short item_code;
  void *buffer_address;
  long *return_length_address;
d3759 1
a3759 1
PUBLIC void LYCheckMail NOARGS
d3769 1
d3779 2
d3791 1
a3791 1
	status = sys$getjpiw(0,0,0,jpi_list,0,0,0);
d3807 1
a3807 1
    status = mail$user_begin(&ucontext,null_list,null_list);
d3814 1
a3814 1
    status = mail$user_get_info(&ucontext,uilist,uolist);
d3834 1
a3834 1
    mail$user_end((long *)&ucontext,null_list,null_list);
d3838 1
a3838 1
PUBLIC void LYCheckMail NOARGS
d3862 2
a3863 2
    if ((stat(mf,&st) < 0)
     || !S_ISREG(st.st_mode)) {
d3870 1
a3870 1
	 || ((lastsize != 0) && (st.st_size > lastsize)))
d3882 14
a3895 15
**  This function ensures that an href will be
**  converted to a fully resolved, absolute URL,
**  with guessing of the host or expansions of
**  lead tildes via LYConvertToURL() if needed,
**  and tweaking/simplifying via HTParse().  It
**  is used for LynxHome, startfile, homepage,
**  and 'g'oto entries, after they have been
**  passed to LYFillLocalFileURL(). - FM
**  Such URLs have no `base' reference to which they
**  could be resolved.  LYLegitimizeHREF could not be used.
*/
PUBLIC void LYEnsureAbsoluteURL ARGS3(
	char **,	href,
	CONST char *,	name,
	int,		fixit)
d3902 3
a3904 3
   /*
    *  Check whether to fill in localhost. - FM
    */
d3908 1
a3908 1
     *	If it is not a URL then make it one.
d3918 1
a3918 1
		    NonNull(name), (name ? " " : ""), *href));
d3929 6
a3934 8
 *  Rewrite and reallocate a previously allocated string
 *  as a file URL if the string resolves to a file or
 *  directory on the local system, otherwise as an
 *  http URL. - FM
 */
PUBLIC void LYConvertToURL ARGS2(
	char **,	AllocatedString,
	int,		fixit)
d3939 1
d3950 2
a3951 1
	for(; *cp_url != '\0'; cp_url++)
d3960 1
a3960 1
    *AllocatedString = NULL;  /* so StrAllocCopy doesn't free it */
d3965 1
d3967 1
a3967 1
	StrAllocCat(*AllocatedString,"/");
d3971 1
a3971 1
	 *  Not a SHELL pathspec.  Get the full VMS spec and convert it.
d3976 1
d3981 2
a3982 3
	     *	On VMS, we'll accept '~' on the command line as
	     *	Home_Dir(), and assume the rest of the path, if
	     *	any, has SHELL syntax.
d3987 3
a3989 3
		 *  Append rest of path, if present, skipping "user" if
		 *  "~user" was entered, simplifying, and eliminating
		 *  any residual relative elements. - FM
d3999 1
a3999 1
	    LYstrncpy(url_file, old_string, sizeof(url_file)-1);
d4002 2
a4003 2
	if (1&lib$find_file(&url_file_dsc, &file_name_dsc, &context,
			    0, 0, 0, 0)) {
d4005 1
a4005 1
	     *	We found the file.  Convert to a URL pathspec.
d4020 1
a4020 1
	} else if ((NULL != getcwd(dir_name, sizeof(dir_name)-1, 0)) &&
d4027 1
a4027 1
	    if (NULL != getcwd(dir_name, sizeof(dir_name)-1, 0)) {
d4039 2
a4040 3
		 *  Nope.  Assume it's an http URL with
		 *  the "http://" defaulted, if we can't
		 *  rule out a bad VMS path.
d4046 1
a4046 1
		    !LYExpandHostForURL((char **)&old_string,
d4050 3
a4052 3
		     *	Probably a bad VMS path (but can't be
		     *	sure).	Use original pathspec for the
		     *	error message that will result.
d4054 4
a4057 3
		    sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
		    CTRACE((tfp, "Can't find '%s'  Will assume it's a bad path.\n",
				old_string));
d4061 2
a4062 2
		     *	Assume a URL is wanted, so guess the
		     *	scheme with "http://" as the default. - FM
d4064 1
a4064 1
		    if (!LYAddSchemeForURL((char **)&old_string, "http://")) {
d4074 2
a4075 3
	     *	Nothing found.	Assume it's an http URL
	     *	with the "http://" defaulted, if we can't
	     *	rule out a bad VMS path.
d4083 1
a4083 1
		!LYExpandHostForURL((char **)&old_string,
d4087 2
a4088 3
		 *  Probably a bad VMS path (but can't be
		 *  sure).  Use original pathspec for the
		 *  error message that will result.
d4090 1
a4090 1
		sprintf(url_file, "/%.*s", sizeof(url_file)-2, old_string);
d4092 1
a4092 1
			    old_string));
d4096 2
a4097 2
		 *  Assume a URL is wanted, so guess the
		 *  scheme with "http://" as the default. - FM
d4099 1
a4099 1
		if (!LYAddSchemeForURL((char **)&old_string, "http://")) {
d4109 1
a4109 1
have_VMS_URL:
d4120 1
a4120 1
			fullpath, &filepart);
d4126 1
a4126 1
				old_string, *AllocatedString));
d4134 1
a4134 1
	     *	They want .
d4137 1
d4142 1
a4142 1
			old_string, *AllocatedString));
d4149 1
a4149 1
	     *	On Unix, convert '~' to Home_Dir().
d4154 3
a4156 3
		 *  Append rest of path, if present, skipping "user" if
		 *  "~user" was entered, simplifying, and eliminating
		 *  any residual relative elements. - FM
d4164 1
a4164 1
			old_string, *AllocatedString));
d4167 1
a4167 1
	     *	Create a full path to the current default directory.
d4172 2
a4173 1
	    Current_Dir (curdir);
d4175 2
a4176 2
	     *	Concatenate and simplify, trimming any
	     *	residual relative elements. - FM
d4204 1
a4204 1
		 *  It is a subdirectory or file on the local system.
d4221 1
a4221 1
			    old_string, *AllocatedString));
d4225 1
d4230 1
a4230 1
		HTUnEscape(cp);   /* unescape given path without fragment */
d4232 1
a4232 1
		StrAllocCopy(cp2, temp2);	/* keep a copy in cp2	  */
d4234 1
a4234 1
#ifdef WIN_EX	/* 1998/07/31 (Fri) 09:09:03 */
d4242 3
a4244 3
		     *	It is a subdirectory or file on the local system
		     *	with escaped characters and/or a fragment to be
		     *	appended to the URL. - FM
d4250 2
a4251 2
			 *  LYTrimRelFromAbsPath did nothing, use
			 *  old_string as given. - kw
d4265 1
a4265 1
				old_string, *AllocatedString));
d4271 4
a4274 5
		     *	If PWD has some unusual characters, construct a
		     *	filename in temp where those are escaped.  This
		     *	is mostly to prevent this function from returning
		     *	with some weird URL if the LYExpandHostForURL tests
		     *	further down fail. - kw
d4279 2
a4280 2
			 *  LYTrimRelFromAbsPath did nothing, use
			 *  old_string as given. - kw
d4298 3
a4300 3
		 *  It's not an accessible subdirectory or file on the
		 *  local system, so assume it's a URL request and guess
		 *  the scheme with "http://" as the default.
d4303 2
a4304 2
			    temp2 ? temp2 : temp));
#ifdef WIN_EX  /* 1998/01/13 (Tue) 09:07:37 */
d4306 1
a4306 1
		    CONST char *p, *q;
d4314 1
a4314 1
			    "'%s' not exist, Goto LynxHome '%s'.", q, p);
d4323 1
a4323 1
		if (LYExpandHostForURL((char **)&old_string,
d4325 2
a4326 3
				       URLDomainSuffixes))
		{
		    if (!LYAddSchemeForURL((char **)&old_string, "http://")) {
d4333 1
a4333 1
		  /* RW 1998Mar16  Restore AllocatedString to 'old_string' */
d4340 1
a4340 1
	Retry:
d4350 1
a4350 1
	 *  Path begins with a slash.  Simplify and use it.
d4354 2
a4355 3
	     *	Request for root.  Respect it on Unix, but
	     *	on VMS we treat that as a listing of the
	     *	login directory. - FM
d4364 1
a4364 2
	     *	It is an absolute directory or file
	     *	on the local system. - KW
d4374 1
a4374 1
			old_string, *AllocatedString));
d4378 2
a4379 2
	     *	Has a Home_Dir() reference.  Handle it
	     *	as if there weren't a lead slash. - FM
d4384 3
a4386 3
		 *  Append rest of path, if present, skipping "user" if
		 *  "~user" was entered, simplifying, and eliminating
		 *  any residual relative elements. - FM
d4395 2
a4396 2
	     *	Normal absolute path.  Simplify, trim any
	     *	residual relative elements, and append it. - FM
d4404 1
a4404 1
		    old_string, *AllocatedString));
d4411 1
a4411 1
#if defined(_WINDOWS) /* 1998/06/23 (Tue) 16:45:20 */
d4413 1
a4413 1
PUBLIC int win32_check_interrupt(void)
d4445 23
a4467 24
 *  This function rewrites and reallocates a previously allocated
 *  string so that the first element is a confirmed Internet host,
 *  and returns TRUE, otherwise it does not modify the string and
 *  returns FALSE.  It first tries the element as is, then, if the
 *  element does not end with a dot, it adds prefixes from the
 *  (comma separated) prefix list argument, and, if the element
 *  does not begin with a dot, suffixes from the (comma separated)
 *  suffix list arguments (e.g., www.host.com, then www.host,edu,
 *  then www.host.net, then www.host.org).  The remaining path, if
 *  one is present, will be appended to the expanded host.  It also
 *  takes into account whether a colon is in the element or suffix,
 *  and includes that and what follows as a port field for the
 *  expanded host field (e.g, wfbr:8002/dir/lynx should yield
 *  www.wfbr.edu:8002/dir/lynx).  The calling function should
 *  prepend the scheme field (e.g., http://), or pass the string
 *  to LYAddSchemeForURL(), if this function returns TRUE. - FM
 */
PUBLIC BOOLEAN LYExpandHostForURL ARGS3(
	char **,	AllocatedString,
	char *,		prefix_list,
	char *,		suffix_list)
{
    char DomainPrefix[80], *StartP, *EndP;
    char DomainSuffix[80], *StartS, *EndS;
d4474 1
d4481 2
a4482 3
     *	If it's a NULL or zero-length string,
     *	or if it begins with a slash or hash,
     *	don't continue pointlessly. - FM
d4490 1
a4490 2
     *	If it's a partial or relative path,
     *	don't continue pointlessly. - FM
d4498 3
a4500 4
     *	Make a clean copy of the string, and trim off the
     *	path if one is present, but save the information
     *	so we can restore the path after filling in the
     *	Host[:port] field. - FM
d4505 1
a4505 2
	 *  Have a path.  Any fragment should
	 *  already be included in Path. - FM
d4510 2
a4511 3
	 *  No path, so check for a fragment and
	 *  trim that, to be restored after filling
	 *  in the Host[:port] field. - FM
d4517 3
a4519 4
     *	If the potential host string has a colon, assume it
     *	begins a port field, and trim it off, but save the
     *	information so we can restore the port field after
     *	filling in the host field. - FM
d4524 1
a4524 2
	    FREE(Str);
	    return GotHost;
d4530 1
a4530 2
     *	Do a DNS test on the potential host field
     *	as presently trimmed. - FM
a4541 1

d4554 1
a4554 1
	 *  Clear any residual interrupt. - FM
d4558 2
a4559 2
	    "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
			host));
d4563 1
a4563 1
	 *  Return success. - FM
d4566 2
a4567 7
	FREE(host);
	FREE(Str);
	FREE(MsgStr);
	return GotHost;
    }
    else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED))
    {
d4569 1
a4569 1
	 *  Give the user chance to interrupt lookup cycles. - KW & FM
d4572 2
a4573 2
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		    host));
d4576 1
a4576 1
	 *  Return failure. - FM
d4578 1
a4578 4
	FREE(host);
	FREE(Str);
	FREE(MsgStr);
	return FALSE;
d4582 9
a4590 10
     *	Set the first prefix, making it a zero-length string
     *	if the list is NULL or if the potential host field
     *	ends with a dot. - FM
     */
    StartP = ((prefix_list && Str[strlen(Str)-1] != '.') ?
					     prefix_list : "");
    /*
     *	If we have a prefix, but the allocated string is
     *	one of the common host prefixes, make our prefix
     *	a zero-length string. - FM
d4607 1
a4607 1
	StartP++;	/* Skip whitespace and separators */
d4611 1
a4611 1
	EndP++;		/* Find separator */
d4613 2
a4614 1
    LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
d4617 1
a4617 1
     *	Test each prefix with each suffix. - FM
d4621 2
a4622 3
	 *  Set the first suffix, making it a zero-length string
	 *  if the list is NULL or if the potential host field
	 *  begins with a dot. - FM
d4624 3
a4626 2
	StartS = ((suffix_list && *Str != '.') ?
				   suffix_list : "");
d4628 1
a4628 1
	    StartS++;	/* Skip whitespace and separators */
d4632 1
a4632 1
	    EndS++;	/* Find separator */
d4634 2
a4635 1
	LYstrncpy(DomainSuffix, StartS, (EndS - StartS));
d4638 1
a4638 1
	 *  Create domain names and do DNS tests. - FM
d4643 2
a4644 2
	    if (Host[strlen(Host)-1] == '.') {
		Host[strlen(Host)-1] = '\0';
d4667 1
a4667 1
		 *  Give the user chance to interrupt lookup cycles. - KW
d4669 1
a4669 2
		if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED))
		{
d4671 3
a4673 7
	"LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
				host));
		    FREE(Str);
		    FREE(MsgStr);
		    FREE(Host);
		    FREE(host);
		    return FALSE; /* We didn't find a valid name. */
d4677 1
a4677 1
		 *  Advance to the next suffix, or end of suffix list. - FM
d4689 1
a4689 1
	}  while ((GotHost == FALSE) && (*DomainSuffix != '\0'));
d4692 12
a4703 12
	   /*
	    *  Advance to the next prefix, or end of prefix list. - FM
	    */
	   StartP = ((*EndP == '\0') ? EndP : (EndP + 1));
	   while ((*StartP) && (WHITE(*StartP) || *StartP == ',')) {
	       StartP++;	/* Skip whitespace and separators */
	   }
	   EndP = StartP;
	   while (*EndP && !WHITE(*EndP) && *EndP != ',') {
	       EndP++;		/* Find separator */
	   }
	   LYstrncpy(DomainPrefix, StartP, (EndP - StartP));
d4708 3
a4710 4
     *	If a test passed, restore the port field if we had one
     *	and there is no colon in the expanded host, and the path
     *	if we had one, and reallocate the original string with
     *	the expanded Host[:port] field included. - FM
d4729 1
a4729 1
     *	Clear any residual interrupt. - FM
d4732 4
a4735 3
	CTRACE((tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
		    host,
		    (GotHost ? "resolved" : "timed out")));
d4739 1
a4739 1
     *	Clean up and return the last test result. - FM
d4741 3
d4752 10
a4761 12
 *  This function rewrites and reallocates a previously allocated
 *  string that begins with an Internet host name so that the string
 *  begins with its guess of the scheme based on the first field of
 *  the host name, or the default scheme if no guess was made, and
 *  returns TRUE, otherwise it does not modify the string and returns
 *  FALSE.  It also returns FALSE without modifying the string if the
 *  default_scheme argument was NULL or zero-length and no guess was
 *  made. - FM
  */
PUBLIC BOOLEAN LYAddSchemeForURL ARGS2(
	char **,	AllocatedString,
	char *,		default_scheme)
d4767 2
a4768 2
     *	If we were passed a NULL or zero-length string,
     *	don't continue pointlessly. - FM
d4779 2
a4780 2
	 *  This could be either http or https, so check
	 *  the default and otherwise use "http". - FM
d4814 2
a4815 2
	 *  This could be either news, snews, or nntp, so
	 *  check the default, and otherwise use news. - FM
d4833 2
a4834 2
     *	If we've make a guess, use it.	Otherwise, if we
     *	were passed a default scheme prefix, use that. - FM
d4855 6
a4860 7
 *  This function expects an absolute Unix or VMS SHELL path
 *  spec as an allocated string, simplifies it, and trims out
 *  any residual relative elements.  It also checks whether
 *  the path had a terminal slash, and if it didn't, makes
 *  sure that the simplified path doesn't either.  If it's
 *  a directory, our convention is to exclude "Up to parent"
 *  links when a terminal slash is present. - FM
d4862 1
a4862 2
PUBLIC void LYTrimRelFromAbsPath ARGS1(
	char *,		path)
d4869 1
a4869 1
     *	Make sure we have a pointer to an absolute path. - FM
d4875 1
a4875 1
     *	Check whether the path has a terminal slash. - FM
d4880 1
a4880 1
     *	Simplify the path and then do any necessary trimming. - FM
d4887 1
a4887 1
	     *	Eliminate trailing dot. - FM
d4892 1
a4892 1
	     *	Skip over the "/." of a "/./". - FM
d4897 1
a4897 1
	     *	Eliminate trailing dotdot. - FM
d4902 1
a4902 1
	     *	Skip over the "/.." of a "/../". - FM
d4907 1
a4907 1
	     *	Done trimming. - FM
d4914 2
a4915 3
     *	Load any shifts into path, and eliminate any
     *	terminal slash created by HTSimplify() or our
     *	walk, but not present originally. - FM
d4928 1
a4928 1
 *  Example Client-Side Include interface.
d4930 8
a4937 10
 *  This is called from SGML.c and simply returns markup for reporting
 *  the URL of the document being loaded if a comment begins with
 *  "<!--#lynxCSI".  The markup will be included as if it were in the
 *  document.  Move this function to a separate module for doing this
 *  kind of thing seriously, someday. - FM
 */
PUBLIC void LYDoCSI ARGS3(
	char *,		url,
	CONST char *,	comment,
	char **,	csi)
d4939 1
a4939 1
    CONST char *cp = comment;
d4959 2
a4960 2
 *  Define_VMSLogical -- Fote Macrides 04-Apr-1995
 *	Define VMS logicals in the process table.
d4962 2
a4963 3
PUBLIC void Define_VMSLogical ARGS2(
	char *,		LogicalName,
	char *,		LogicalValue)
d4988 1
a4988 1
PRIVATE void LYHomeDir_free NOARGS
d4994 1
a4994 2
PUBLIC char * Current_Dir ARGS1(
	char *,	pathname)
d4997 1
d4999 1
a4999 1
    result = getcwd (pathname, LY_MAXPATH);
d5001 1
a5001 1
    result = getwd (pathname);
d5012 1
a5012 2
PRIVATE char * CheckDir ARGS1(
    char *,	path)
d5015 1
d5018 1
a5018 1
	 || !S_ISDIR(stat_info.st_mode))) {
d5027 1
a5027 1
PRIVATE char *HomeEnv NOARGS
d5070 1
a5070 1
PUBLIC CONST char * Home_Dir NOARGS
d5072 1
a5072 1
    static CONST char *homedir = NULL;
d5079 1
a5079 1
	     && (cp = LYGetEnv("SYS$SCRATCH")) == NULL) {
d5087 1
a5087 1
	     *	One could use getlogin() and getpwnam() here instead.
d5097 1
a5097 1
		 *  Use /tmp; it should be writable.
d5106 1
a5106 1
	homedir = (CONST char *)HomeDir;
d5113 1
a5113 1
	exit(EXIT_FAILURE);
d5123 1
a5123 1
PUBLIC char *LYPathLeaf ARGS1(char *, pathname)
d5126 1
d5139 2
a5140 1
    for (leaf = 0, n = strlen(pathname)-1; n >= 0; n--) {
d5152 10
a5161 12
 *  This function checks the acceptability of file paths that
 *  are intended to be off the home directory.	The file path
 *  should be passed in fbuffer, together with the size of the
 *  buffer.  The function simplifies the file path, and if it
 *  is acceptable, loads it into fbuffer and returns TRUE.
 *  Otherwise, it does not modify fbuffer and returns FALSE.
 *  If a subdirectory is present and the path does not begin
 *  with "./", that is prefixed to make the situation clear. - FM
 */
PUBLIC BOOLEAN LYPathOffHomeOK ARGS2(
	char *,		fbuffer,
	size_t,		fbuffer_size)
d5167 1
a5167 1
     *	Make sure we have an fbuffer and a string in it. - FM
d5170 1
a5170 1
	return(FALSE);
d5176 2
a5177 2
     *	Check for an inappropriate reference to the
     *	home directory, and correct it if we can. - FM
d5183 1
a5183 1
	     *	Reject "sys$login". - FM
d5186 1
a5186 1
	    return(FALSE);
d5192 3
a5194 4
		 *  Reject "sys$login:".  Otherwise, we have
		 *  converted "sys$login:file" to "file", or
		 *  have left a strange path for VMS as it
		 *  was originally. - FM
d5197 1
a5197 1
		return(FALSE);
d5207 1
a5207 2
		     *	Convert "~/subdir(s)/file"
		     *	to "./subdir(s)/file". - FM
d5212 1
a5212 1
		     *	Convert "~/file" to "file". - FM
d5218 1
a5218 1
		 *  Reject "~/". - FM
d5221 1
a5221 1
		return(FALSE);
d5225 1
a5225 1
	    cp = (cp1 - 1) ;
d5229 3
a5231 4
		     *	Convert "~user/subdir(s)/file" to
		     *	"./subdir(s)/file".  If user is someone
		     *	else, we covered a spoof.  Otherwise,
		     *	we simplified. - FM
d5236 1
a5236 1
		     *	Convert "~user/file" to "file". - FM
d5242 1
a5242 1
		 *  Reject "~user/". - FM
d5245 1
a5245 1
		return(FALSE);
d5249 1
a5249 1
	     *	Reject "~user". - FM
d5252 1
a5252 1
	    return(FALSE);
a5254 1

d5257 1
a5257 1
     *	Check for VMS path specs, and reject if still present. - FM
d5261 1
a5261 1
	return(FALSE);
d5266 1
a5266 1
     *	Check for a URL or absolute path, and reject if present. - FM
d5270 1
a5270 1
	return(FALSE);
d5274 1
a5274 1
     *	Simplify it. - FM
d5279 1
a5279 1
     *	Check if it has a pointless "./". - FM
d5288 1
a5288 1
     *	Check for spoofing. - FM
d5291 4
a5294 4
     || LYIsPathSep(*cp)
     || LYIsPathSep(cp[(strlen(cp) - 1)])
     || strstr(cp, "..") != NULL
     || !strcmp(cp, ".")) {
d5296 1
a5296 1
	return(FALSE);
d5300 2
a5301 2
     *	Load what we have at this point into fbuffer,
     *	trimming if too long, and claim it's OK. - FM
d5305 2
a5306 2
	 *  We have a subdirectory and no lead "./", so
	 *  prefix it to make the situation clear. - FM
d5318 1
a5318 1
    return(TRUE);
d5322 11
a5332 13
 *  This function appends fname to the home path and returns
 *  the full path and filename.  The fname string can be just
 *  a filename (e.g., "lynx_bookmarks.html"), or include a
 *  subdirectory off the home directory, in which case fname
 *  should begin with "./" (e.g., ./BM/lynx_bookmarks.html)
 *  Use LYPathOffHomeOK() to check and/or fix up fname before
 *  calling this function.  On VMS, the resultant full path
 *  and filename are converted to VMS syntax. - FM
 */
PUBLIC void LYAddPathToHome ARGS3(
	char *,		fbuffer,
	size_t,		fbuffer_size,
	char *,		fname)
d5335 1
a5335 1
    char *file = fname;
d5339 1
a5339 1
     *	Make sure we have a buffer. - FM
d5350 1
a5350 1
     *	Make sure we have a file name. - FM
d5356 1
a5356 1
     *	Set up home string and length. - FM
d5367 1
a5367 1
	 *  Home_Dir() has a bug if this ever happens. - FM
d5374 3
a5376 3
	 *  Buffer is smaller than or only big enough for the home path.
	 *  Load what fits of the home path and return.  This will fail,
	 *  but we need something in the buffer. - FM
a5381 1

d5384 1
a5384 1
     *	Check whether we have a subdirectory path or just a filename. - FM
d5388 1
a5388 1
	 *  We have a subdirectory path. - FM
d5390 1
a5390 1
	if (home[strlen(home)-1] == ']') {
d5392 2
a5393 3
	     *	We got the home directory, so convert it to
	     *	SHELL syntax and append subdirectory path,
	     *	then convert that to VMS syntax. - FM
d5396 1
d5403 1
a5403 1
	     *	This will fail, but we need something in the buffer. - FM
d5409 1
a5409 1
	 *  We have a file in the home directory. - FM
d5415 1
a5415 1
     *	Check whether we have a subdirectory path or just a filename. - FM
d5418 1
a5418 1
		     (strncmp(file, "./", 2) ? file : (file + 2)));
d5428 1
a5428 2
PUBLIC char * LYAddPathToSave ARGS1(
	char *,		fname)
d5439 1
d5448 1
a5448 1
 *  This function takes a string in the format
d5452 12
a5463 14
 *  as an argument, and returns its conversion to clock format
 *  (seconds since 00:00:00 Jan 1 1970), or 0 if the string
 *  doesn't match the expected pattern.  It also returns 0 if
 *  the time is in the past and the "absolute" argument is FALSE.
 *  It is intended for handling 'expires' strings in Version 0
 *  cookies homologously to 'max-age' strings in Version 1 cookies,
 *  for which 0 is the minimum, and greater values are handled as
 *  '[max-age seconds] + time(NULL)'.	If "absolute" if TRUE, we
 *  return the clock format value itself, but if anything goes wrong
 *  when parsing the expected patterns, we still return 0. - FM
 */
PUBLIC time_t LYmktime ARGS2(
	char *,		string,
	BOOL,		absolute)
d5472 1
a5472 1
     *	Make sure we have a string to parse. - FM
d5475 1
a5475 1
	return(0);
d5480 2
a5481 2
     *	Skip any lead alphabetic "Day, " field and
     *	seek a numeric day field. - FM
d5486 1
a5486 1
	return(0);
d5489 1
a5489 1
     *	Get the numeric day and convert to an integer. - FM
d5495 2
a5496 2
	return(0);
    LYstrncpy(temp, start, (int)(s - start));
d5499 1
a5499 1
	return(0);
d5502 1
a5502 1
     *	Get the month string and convert to an integer. - FM
d5507 1
a5507 1
	return(0);
d5514 1
a5514 1
	return(0);
d5517 73
a5589 73
	case '0':
	case '1':
	    month = atoi(temp);
	    if (month < 1 || month > 12) {
		return(0);
	    }
	    break;
	case 'A':
	    if (!strcasecomp(temp, "Apr")) {
		month = 4;
	    } else if (!strcasecomp(temp, "Aug")) {
		month = 8;
	    } else {
		return(0);
	    }
	    break;
	case 'D':
	    if (!strcasecomp(temp, "Dec")) {
		month = 12;
	    } else {
		return(0);
	    }
	    break;
	case 'F':
	    if (!strcasecomp(temp, "Feb")) {
		month = 2;
	    } else {
		return(0);
	    }
	    break;
	case 'J':
	    if (!strcasecomp(temp, "Jan")) {
		month = 1;
	    } else if (!strcasecomp(temp, "Jun")) {
		month = 6;
	    } else if (!strcasecomp(temp, "Jul")) {
		month = 7;
	    } else {
		return(0);
	    }
	    break;
	case 'M':
	    if (!strcasecomp(temp, "Mar")) {
		month = 3;
	    } else if (!strcasecomp(temp, "May")) {
		month = 5;
	    } else {
		return(0);
	    }
	    break;
	case 'N':
	    if (!strcasecomp(temp, "Nov")) {
		month = 11;
	    } else {
		return(0);
	    }
	    break;
	case 'O':
	    if (!strcasecomp(temp, "Oct")) {
		month = 10;
	    } else {
		return(0);
	    }
	    break;
	case 'S':
	    if (!strcasecomp(temp, "Sep")) {
		month = 9;
	    } else {
		return(0);
	    }
	    break;
	default:
	    return(0);
d5593 1
a5593 1
     *	Get the numeric year string and convert to an integer. - FM
d5598 1
a5598 1
	return(0);
d5612 1
a5612 1
	 * the broken sender software intends.	(This totally breaks
d5622 1
a5622 1
	return(0);
d5627 1
a5627 1
     *	Get the numeric hour string and convert to an integer. - FM
d5640 2
a5641 2
	    return(0);
	LYstrncpy(temp, start, (int)(s - start));
d5645 1
a5645 1
	 *  Get the numeric minutes string and convert to an integer. - FM
d5650 1
a5650 1
	    return(0);
d5655 2
a5656 2
	    return(0);
	LYstrncpy(temp, start, (int)(s - start));
d5660 1
a5660 1
	 *  Get the numeric seconds string and convert to an integer. - FM
d5665 1
a5665 1
	    return(0);
d5670 2
a5671 2
	    return(0);
	LYstrncpy(temp, start, (int)(s - start));
d5676 2
a5677 3
     *	Convert to clock format (seconds since 00:00:00 Jan 1 1970),
     *	but then zero it if it's in the past and "absolute" is not
     *	TRUE.  - FM
d5681 2
a5682 2
	 month += 12;
	 year--;
d5684 8
a5691 8
    day += (year - 1968)*1461/4;
    day += ((((month*153) + 2)/5) - 672);
    clock2 = (time_t)((day * 60 * 60 * 24) +
		     (hour * 60 * 60) +
		     (minutes * 60) +
		     seconds);
    if (absolute == FALSE && (long)(time((time_t *)0) - clock2) >= 0)
	clock2 = (time_t)0;
d5694 2
a5695 2
		    (long) clock2,
		    ctime(&clock2)));
d5697 1
a5697 1
    return(clock2);
d5702 1
a5702 1
 *  No putenv on the NeXT so we use this code instead!
d5736 1
a5736 1
 *  Put STRING, which is of the form "NAME=VALUE", in  the environment.
d5738 1
a5738 2
PUBLIC int putenv ARGS1(
	CONST char *,	string)
d5740 16
a5755 19
  char *name_end = strchr(string, '=');
  register size_t size;
  register char **ep;

  if (name_end == NULL)
    {
      /* Remove the variable from the environment.  */
      size = strlen (string);
      for (ep = environ; *ep != NULL; ++ep)
	if (!strncmp (*ep, string, size) && (*ep)[size]  == '=')
	  {
	    while (ep[1] != NULL)
	      {
		ep[0] = ep[1];
		++ep;
	      }
	    *ep = NULL;
	    return 0;
	  }
d5758 7
a5764 6
  size = 0;
  for (ep = environ; *ep != NULL; ++ep)
    if (!strncmp (*ep, string, name_end - string) && (*ep)[name_end - string] == '=')
      break;
    else
      ++size;
d5766 16
a5781 16
  if (*ep == NULL)
    {
      static char **last_environ = NULL;
      char **new_environ = (char **) malloc ((size + 2) * sizeof (char *));
      if (new_environ == NULL)
	return -1;
      (void) memcpy((char *)new_environ, (char *)environ, size * sizeof(char *));
      new_environ[size] = (char *) string;
      new_environ[size + 1] = NULL;
      if (last_environ != NULL)
	FREE (last_environ);
      last_environ = new_environ;
      environ = new_environ;
    }
  else
    *ep = (char *) string;
d5783 1
a5783 1
  return 0;
d5788 1
a5788 1
int remove ARGS1(char *, name)
a5793 6
/*
 * Default, for single-user systems such as Cygwin and OS/2 EMX:
 */
#define IsOurFile(name) TRUE
#define OpenHiddenFile(name, mode) fopen(name, mode)

a5794 4

#undef IsOurFile
#undef OpenHiddenFile

d5800 1
a5800 1
PRIVATE BOOL IsOurFile ARGS1(char *, name)
d5802 1
d5806 4
a5809 3
    && S_ISREG(data.st_mode)
    && data.st_nlink == 1
    && data.st_uid == getuid()) {
d5811 1
d5846 1
a5846 1
		     || (data.st_mode & S_IWOTH) != 0) {
d5857 1
a5857 1
	return !linked;
d5859 2
a5860 1
    return FALSE;
d5866 1
a5866 1
PRIVATE FILE *OpenHiddenFile ARGS2(char *, name, char *, mode)
d5872 1
a5872 1
#if defined(O_CREAT) && defined(O_EXCL) /* we have fcntl.h or kindred? */
d5878 2
a5879 1
	int fd = open(name, O_CREAT|O_EXCL|O_WRONLY, HIDE_CHMOD);
d5881 2
a5882 2
	 && errno == EEXIST
	 && IsOurFile(name)) {
d5885 1
a5885 1
	    fd = open(name, O_CREAT|O_EXCL|O_WRONLY, HIDE_CHMOD);
d5894 1
a5894 2
    }
    else
d5898 1
a5898 1
	 && chmod(name, HIDE_CHMOD) == 0)
d5902 9
a5910 9
    /*
     * This is less stringent, but reasonably portable.  For new files, the
     * umask will suffice; however if the file already exists we'll change
     * permissions first, before opening it.  If the chmod fails because of
     * some reason other than a non-existent file, there's no point in trying
     * to open it.
     *
     * This won't work properly if the user is root, since the chmod succeeds.
     */
d5913 1
d5920 2
d5924 1
a5924 1
PUBLIC FILE *LYNewBinFile ARGS1(char *, name)
d5927 2
a5928 1
    FILE *fp = fopen (name, BIN_W, "mbc=32");
d5936 1
a5936 1
PUBLIC FILE *LYNewTxtFile ARGS1(char *, name)
d5941 1
a5941 1
    fp = fopen (name, TXT_W, "shr=get");
d5954 1
a5954 1
PUBLIC FILE *LYAppendToTxtFile ARGS1(char *, name)
d5959 1
a5959 1
    fp = fopen (name, TXT_A, "shr=get");
d5973 3
a5975 3
 *  Restore normal permissions to a copy of a file that we have created
 *  with temp file restricted permissions.  The normal umask should
 *  apply for user files. - kw
d5977 1
a5977 1
PUBLIC void LYRelaxFilePermissions ARGS1(CONST char *, name)
d5981 1
d5986 3
a5988 3
	 *  It looks plausible that this is a file we created with
	 *  temp file paranoid permissions (and the umask wasn't even
	 *  more restrictive when it was copied). - kw
d5991 1
d6002 2
a6003 3
PUBLIC BOOLEAN LYCachedTemp ARGS2(
	char *,		result,
	char **,	cached)
d6026 3
a6028 4
PUBLIC FILE *LYOpenTemp ARGS3(
	char *,		result,
	CONST char *,	suffix,
	CONST char *,	mode)
d6041 9
a6049 3
	case 'w':	wrt = 'w';	break;
	case 'a':	wrt = 'a';	break;
	case 'b':	txt = FALSE;	break;
d6051 2
a6052 2
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return 0;
d6061 1
a6061 2
    if (lynx_temp_subspace == 0)
    {
d6066 1
a6066 1
	 && S_ISDIR(sb.st_mode)) {
d6068 1
a6068 1
	     || (sb.st_mode & (S_IWOTH | S_IWGRP)) != 0) {
d6070 3
a6072 2
		CTRACE((tfp, "lynx_temp_space is not our directory %s owner %d mode %03o\n",
			     lynx_temp_space, (int) sb.st_uid, (int) sb.st_mode & 0777));
d6080 2
a6081 1
	    StrAllocCat(lynx_temp_space, "XXXXXXXXXX");
d6084 1
a6084 1
		exit(EXIT_FAILURE);
d6102 1
a6102 1
		fp = LYNewTxtFile (result);
d6105 1
a6105 1
		fp = LYAppendToTxtFile (result);
d6109 1
a6109 1
	    fp = LYNewBinFile (result);
d6116 1
a6116 1
#ifdef EEXIST	/* FIXME (need a better test) in fcntl.h or unistd.h */
d6119 1
a6119 1
		   result, LYStrerror(errno)));
d6142 1
a6142 2
PUBLIC FILE *LYReopenTemp ARGS1(
	char *,		name)
d6149 1
a6149 1
	fp = p->file = LYAppendToTxtFile (name);
d6169 3
a6171 4
PUBLIC FILE *LYOpenTempRewrite ARGS3(
	char *,		fname,
	CONST char *,	suffix,
	CONST char *,	mode)
d6196 1
a6196 1
	writable_exists = HTEditable(fname); /* existing, can write */
d6199 1
a6199 1
	writable_exists = (BOOL) (stat(fname, &stat_buf) == 0); /* existing, assume can write */
d6207 2
a6208 2
	       writable_exists ? CTRACE_EXISTS : "",
	       is_ours ? "is our file." : "is NOT our file."));
d6212 4
a6215 5
     *  Note that in cases where LYOpenTemp is called as fallback below,
     *  we don't call LYRemoveTemp first.  That may be appropriate in some
     *  cases, but not trying to remove a weird existing file seems safer
     *  and could help diagnose an unusual situation.  (They may be removed
     *  anyway later.)
d6224 2
a6225 2
	 *  Not registered.  It should have been registered at one point
	 *  though, otherwise we wouldn't be called like this.
d6230 1
a6230 2
	 *  File exists, writable if we checked, but something is wrong
	 *  with it.
d6236 1
a6236 1
	 *  Exists but not writable, and something is wrong with it.
d6244 9
a6252 3
	case 'w':	wrt = 'w';	break;
	case 'a':	wrt = 'a';	break;
	case 'b':	txt = FALSE;	break;
d6254 2
a6255 2
		CTRACE((tfp, "%s @@%d: BUG\n", __FILE__, __LINE__));
		return fp;
d6261 2
a6262 2
	 *  Yes, it exists, is writable if we checked, and everything
	 *  looks ok so far.  This should be the most regular case. - kw
d6267 2
a6268 2
	     *  We truncate and then append, this avoids having a small
	     *  window in which the file doesn't exist. - kw
d6283 5
a6287 7
	/*  We come here in two cases: either the file existed and was
	 *  ours and we just got rid of it.
	 *  Or the file did and does not exist, but is registered as a
	 *  temp file.  It must have been removed by some means other than
	 *  LYRemoveTemp.
	 *  In both cases, reuse the name! - kw
	 */
d6292 1
a6292 1
	    fp = LYNewTxtFile (fname);
d6295 1
a6295 1
	    fp = LYAppendToTxtFile (fname);
d6299 1
a6299 1
	fp = LYNewBinFile (fname);
d6304 1
a6304 1
	   (fp) ? "ok" : "failed"));
d6306 4
a6309 4
     *  We could fall back to trying LYOpenTemp() here in case of failure.
     *  After all the checks already done above a filure here should be
     *  pretty unusual though, so maybe it's better to let the user notice
     *  that something went wrong, and not try to fix it up. - kw
d6318 2
a6319 3
PUBLIC FILE *LYOpenScratch ARGS2(
	char *,		result,
	CONST char *,	prefix)
d6327 1
a6327 1
    if ((fp = LYNewTxtFile (result)) != 0) {
d6341 1
a6341 2
PRIVATE void LY_close_temp ARGS1(
	LY_TEMP *,	p)
d6356 1
a6356 2
PUBLIC void LYCloseTemp ARGS1(
	char *, name)
d6363 1
a6363 1
	    (p->file != 0) ? ", closed" : ""));
d6371 1
a6371 2
PUBLIC void LYCloseTempFP ARGS1(
	FILE *, fp)
d6385 1
a6385 2
PUBLIC int LYRemoveTemp ARGS1(
	char *, name)
d6402 1
a6402 1
		       (p->file != 0) ? ", closed" : ""));
d6417 1
a6417 1
PUBLIC void LYCleanupTemp NOARGS
d6425 2
a6426 1
	LYstrncpy(result, lynx_temp_space, sizeof(result)-1);
d6438 2
a6439 3
PUBLIC void LYRenamedTemp ARGS2(
	char *,		oldname,
	char *,		newname)
d6451 1
a6451 1
 *  Check that bibhost defines the BibP icon.
d6453 1
a6453 1
PUBLIC void LYCheckBibHost NOARGS
d6467 1
a6467 1
    traversal = TRUE;  /* Hack to force error response. */
d6475 1
a6475 1
 *  Management of User Interface Pages. - kw
d6477 2
a6478 2
 *  These are mostly temp files.  Pages which can be recognized by their
 *  special URL (after having been loaded) need not be tracked here.
d6480 1
a6480 1
 *  First some private stuff:
d6483 5
a6487 5
    UIP_t	type;
    unsigned	flags;
    char *	url;
    HTList *	alturls;
    char *	file;
d6491 1
a6491 1
#define UIP_F_LIMIT	0x0002	/* flag: limit size of alturl list */
d6493 1
a6493 1

d6524 1
d6528 3
a6530 4
PUBLIC BOOL LYIsUIPage3 ARGS3(
    CONST char *,	url,
    UIP_t,		type,
    int,		flagparam)
d6534 1
d6542 1
a6542 1
		       (!strncmp(ly_uip[i].url, url, (l=strlen(ly_uip[i].url)))
d6550 1
a6550 1
		while ((p = HTList_nextObject(l0)) != NULL) {
d6552 2
a6553 2
		       (!strncmp(p, url, (l=strlen(p)))
			&& (url[l] == '\0' || url[l] == '#')) :
d6564 2
a6565 3
PUBLIC void LYRegisterUIPage ARGS2(
    CONST char *,	url,
    UIP_t,		type)
d6568 1
d6583 1
a6583 1
		while ((p = HTList_nextObject(l0)) != NULL) {
d6607 1
a6607 1
PUBLIC void LYUIPages_free NOARGS
d6610 1
a6610 2
    char *p;
    HTList *l0;
d6614 1
a6614 5
	l0 = ly_uip[i].alturls;
	while ((p = HTList_nextObject(l0)) != NULL) {
	    FREE(p);
	}
	HTList_delete(ly_uip[i].alturls);
d6620 2
a6621 2
 *  Convert local pathname to www name
 *  (do not bother about file://localhost prefix at this point).
d6623 1
a6623 2
PUBLIC  CONST char * wwwName ARGS1(
	CONST char *,	pathname)
d6625 1
a6625 1
    CONST char *cp = NULL;
d6647 2
a6648 3
PUBLIC BOOLEAN LYValidateFilename ARGS2(
	char *,		result,
	char *,		given)
d6651 1
a6651 1
    CONST char *cp2;
d6654 2
a6655 2
     *  Cancel if the user entered "/dev/null" on Unix,
     *  or an "nl:" path on VMS. - FM
d6657 1
a6657 2
    if (LYIsNullDevice(given))
    {
d6672 2
a6673 2
     && (cp2 = wwwName(Home_Dir())) != 0
     && strlen(cp2) + strlen(given) < LY_MAXPATH) {
d6687 2
a6688 2
     && strchr(given, ':') == NULL
     && strlen(given) < LY_MAXPATH - 13) {
d6701 3
a6703 3
    if (strchr(result, ':') != NULL)
	cp = NULL;
    else
d6708 1
d6714 2
a6715 3
    }
    else
#endif /* __EMX__*/
d6742 1
a6742 2
PUBLIC int LYValidateOutput ARGS1(
	char *,		filename)
d6762 1
a6762 1
     *  See if it already exists.
d6783 2
a6784 3
PUBLIC void LYLocalFileToURL ARGS2(
	char **,	target,
	CONST char *,	source)
d6786 1
a6786 1
    CONST char *leaf;
d6794 1
d6809 2
a6810 3
PUBLIC FILE *InternalPageFP ARGS2(
	char *, filename,
	int,	reuse_flag)
d6826 4
a6829 4
PUBLIC void BeginInternalPage ARGS3(
	FILE *, fp0,
	char*, Title,
	char*, HelpURL)
d6831 2
a6832 1
    fprintf(fp0, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
d6839 1
d6851 11
a6861 2
    fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n",
		 Title);
d6864 2
a6865 2
     && LYwouldPush(Title, NULL)
     && (HelpURL != 0)) {
d6875 1
a6875 2
PUBLIC void EndInternalPage ARGS1(
	FILE *, fp0)
d6880 1
a6880 2
PUBLIC char *trimPoundSelector ARGS1(
	char *,		address)
d6883 1
d6893 1
a6893 2
PUBLIC void LYTrimPathSep ARGS1(
	char *,	path)
d6898 3
a6900 3
     && (len = strlen(path)) != 0
     && LYIsPathSep(path[len-1]))
	path[len-1] = 0;
d6907 1
a6907 2
PUBLIC void LYAddPathSep ARGS1(
	char **,	path)
d6913 3
a6915 3
     && ((temp = *path) != 0)
     && (len = strlen(temp)) != 0
     && !LYIsPathSep(temp[len-1])) {
d6924 1
a6924 2
PUBLIC void LYAddPathSep0 ARGS1(
	char *,		path)
d6929 3
a6931 3
     && (len = strlen(path)) != 0
     && (len < LY_MAXPATH - 2)
     && !LYIsPathSep(path[len-1])) {
d6939 1
a6939 2
PUBLIC char * LYLastPathSep ARGS1(
	CONST char *,	path)
d6942 1
d6956 1
a6956 2
PUBLIC void LYTrimHtmlSep ARGS1(
	char *,	path)
d6961 3
a6963 3
     && (len = strlen(path)) != 0
     && LYIsHtmlSep(path[len-1]))
	path[len-1] = 0;
d6970 1
a6970 2
PUBLIC void LYAddHtmlSep ARGS1(
	char **,	path)
d6976 3
a6978 3
     && ((temp = *path) != 0)
     && (len = strlen(temp)) != 0
     && !LYIsHtmlSep(temp[len-1])) {
d6987 1
a6987 2
PUBLIC void LYAddHtmlSep0 ARGS1(
	char *,		path)
d6992 3
a6994 3
     && (len = strlen(path)) != 0
     && (len < LY_MAXPATH - 2)
     && !LYIsHtmlSep(path[len-1])) {
d7002 2
a7003 3
PUBLIC int LYCopyFile ARGS2(
	char *,		src,
	char *,		dst)
d7006 1
a7006 1
    CONST char *program;
d7051 1
a7051 1
PRIVATE char *escape_backslashes ARGS1(char *, source)
d7066 1
d7081 1
a7081 2
PUBLIC int LYSystem ARGS1(
	char *,	command)
d7085 1
d7091 1
d7109 1
a7109 1
#  ifdef __EMX__			/* FIXME: Should be LY_CONVERT_SLASH? */
d7171 2
a7172 1
	    sprintf(new_command, "%.*s \"%.*s\"", LY_MAXPATH, new_cmd, LY_MAXPATH, win32_name);
d7178 1
a7178 1
		    if (*(p+1) == '\\')
d7194 1
d7204 1
a7204 1
    code = exec_command(command, TRUE);	/* Wait exec */
d7208 1
a7208 1
	signal(SIGPIPE, SIG_DFL); /* Some commands expect the default */
d7222 1
a7222 1
	signal(SIGPIPE, SIG_IGN); /* Ignore it again - kw */
d7237 1
a7237 1
#if !defined(UCX) || !defined(VAXC) /* errno not modifiable ?? */
d7249 2
a7250 2
#if defined(__CYGWIN__)	/* 1999/02/26 (Fri) */
PUBLIC int Cygwin_Shell NOARGS
d7262 1
a7262 1
    sa.bInheritHandle=TRUE;
d7270 2
a7271 2
     inherited handles. Pass the value of the
     handle as a command line parameter */
d7275 2
a7276 2
			TRUE, 0,
			0, 0, &startUpInfo, &procInfo);
d7291 1
a7291 1
PUBLIC char *LYSysShell NOARGS
d7293 2
a7294 1
    char *shell = 0;
d7301 2
d7346 1
a7346 1
PUBLIC char *LYgetXDisplay NOARGS
d7355 1
a7355 2
PUBLIC void LYsetXDisplay ARGS1(
	char *,	new_display)
d7381 1
a7381 1
PRIVATE void morph_PM NOARGS
d7391 2
a7392 2
    if (pib->pib_ultype != 3)		/* 2 is VIO */
	pib->pib_ultype = 3;		/* 3 is PM */
d7400 1
a7400 1
PRIVATE void unmorph_PM NOARGS
d7406 1
a7406 1
PUBLIC int size_clip NOARGS
d7413 1
a7413 1
PUBLIC int put_clip ARGS1(char *, s)
d7425 1
a7425 1
    if (DosAllocSharedMem((PPVOID)&pByte, 0, sz + nl,
d7439 1
a7439 1
    if(!hab)
d7451 1
a7451 1
    DosFreeMem((PPVOID)&pByte);
d7460 1
a7460 1
PUBLIC char* get_clip_grab NOARGS
d7467 1
a7467 1
    if(!hab)
d7473 1
a7473 1
    if(ulFormat != CFI_POINTER) {
d7479 1
a7479 1
    ClipData = (char *)WinQueryClipbrdData(hab, CF_TEXT);
d7481 1
a7481 1
    if(!ClipData || !sz) {
d7488 1
a7488 1
PUBLIC void get_clip_release NOARGS
d7497 1
a7497 1
#else	/* !( defined __EMX__ ) */
d7501 1
a7501 1
static FILE* paste_handle = 0;
d7504 1
a7504 1
PUBLIC void get_clip_release NOARGS
d7509 1
a7509 1
	FREE (paste_buf);
d7512 1
a7512 1
PRIVATE int clip_grab NOARGS
d7521 1
a7521 1
    paste_handle = popen(cmd, "rt");
d7528 1
a7528 1
#define CF_TEXT 0			/* Not used */
d7530 1
a7530 1
PUBLIC char* get_clip_grab NOARGS
d7541 2
a7542 2
	FREE (paste_buf);
    paste_buf = (char*)malloc (PASTE_BUFFER);
d7544 1
a7544 1
	len = fread (paste_buf + off, 1, PASTE_BUFFER - 1, paste_handle);
a7546 3
	break;
	if (strchr (paste_buf + off, '\r')
	 || strchr (paste_buf + off, '\n'))
d7548 5
a7552 1
	paste_buf = realloc (paste_buf, size += PASTE_BUFFER - 1);
d7558 1
a7558 2
PUBLIC int
put_clip ARGS1(char *, s)
d7567 1
a7567 1
    fh = popen (cmd, "wt");
d7570 2
a7571 2
    res = fwrite (s, 1, l, fh);
    if (pclose (fh) != 0 || res != l)
d7576 1
a7576 1
#  endif	/* !defined(WIN_EX) && defined(HAVE_POPEN) */
d7580 13
a7592 1
#if defined(WIN_EX)	/* 1997/10/16 (Thu) 20:13:28 */
d7594 13
a7606 1
PUBLIC int put_clip(char *szBuffer)
d7621 1
a7621 1
	len ++;
d7661 1
a7661 1
PUBLIC char* get_clip_grab()
d7684 1
a7684 1
PUBLIC void get_clip_release()
d7692 1
a7692 1
#endif	/* WIN_EX */
d7701 6
d7713 1
a7713 1
 *      comp.os.ms-windows.programmer.win32
d7715 1
a7715 1
PUBLIC char * w32_strerror(DWORD ercode)
d7720 1
d7727 1
d7737 1
a7737 1
     *  Special code for winsock error handling.
d7740 2
a7741 4
	hModule = GetModuleHandle("wsock32");
	if (hModule == NULL)
	    ercode = GetLastError();
	else
d7745 1
a7745 1
     *  message handling
d7747 7
a7753 7
    FormatMessage(msg_type,
		  hModule,
		  ercode,
		  LANG_NEUTRAL,
		  msg_buff,
		  sizeof(msg_buff),
		  NULL);
d7770 1
a7770 1
#if !defined(VMS) && defined(SYSLOG_REQUESTED_URLS)
d7774 1
a7774 2
PUBLIC void LYOpenlog ARGS1(
	CONST char *, banner)
d7776 2
d7779 1
a7779 1
    openlog("lynx", LOG_PID|LOG_NDELAY, LOG_LOCAL5);
d7781 1
a7781 1
    openlog("lynx", LOG_PID, LOG_LOCAL5);
d7784 5
a7788 4
    if (banner) {
	syslog(LOG_INFO, "Session start:%s", banner);
    } else {
	syslog(LOG_INFO, "Session start");
d7792 2
a7793 3
PRIVATE BOOLEAN looks_like_password ARGS2(
	char *,		first,
	char *,		last)
d7799 1
a7799 1
	 || *first == ':') {
d7809 1
a7809 2
PUBLIC void LYSyslog ARGS1(
	char *,		arg)
d7815 1
a7815 1
    CTRACE((tfp, "LYSyslog %s\n", arg));
d7817 21
a7837 18
    if (is_url(arg)) {	/* proto://user:password@@host/path:port */
			/*	^this colon		    */
	if ((colon1 = strchr(arg, ':')) != 0
	 && !strncmp(colon1, "://", 3)
	 && (colon2 = strchr(colon1+3, ':')) != 0
	 && (atsign = strchr(colon1, '@@')) != 0
	 && (colon2 < atsign)
	 && looks_like_password(colon2 + 1, atsign - 1)) {
	    char *buf = NULL;

	    StrAllocCopy(buf, arg);
	    buf[colon2 - arg + 1] = 0;
	    StrAllocCat(buf, "******");
	    StrAllocCat(buf, atsign);
	    syslog (LOG_INFO|LOG_LOCAL5, "%s", buf);
	    CTRACE((tfp, "...alter %s\n", buf));
	    FREE(buf);
	    return;
d7839 1
a7840 1
    syslog (LOG_INFO|LOG_LOCAL5, "%s", NONNULL(arg));
d7843 1
a7843 1
PUBLIC void LYCloselog NOARGS
d7845 4
a7848 2
  syslog(LOG_INFO, "Session over");
  closelog();
d7851 1
a7851 1
#endif /* !VMS && SYSLOG_REQUESTED_URLS */
@


1.5
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d3275 1
d3277 1
@


1.4
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d7 8
d38 1
a38 1
#if _WIN_CC
d67 1
a67 1
#if HAVE_UTMP
d120 3
a122 3
#ifndef FD_SETSIZE
#define FD_SETSIZE 256
#endif /* !FD_SETSIZE */
a149 2
extern BOOLEAN LYHaveCJKCharacterSet;

d152 1
d195 1
a195 1
PRIVATE char *getenv_text ARGS1(char *, name)
d198 1
a198 1
    return (result != 0 && *result != 0) ? result : 0;
d202 3
a204 1
 *  Highlight (or unhighlight) a given link.
d206 2
a207 4
PUBLIC void highlight ARGS3(
	int,		flag,
	int,		cur,
	char *,		target)
d209 5
a213 19
    char buffer[200];
    int i;
    char tmp[7];
#ifdef SHOW_WHEREIS_TARGETS
    char *cp;
    char *theData = NULL;
    char *Data = NULL;
    int Offset, HitOffset, tLen;
    int LenNeeded;
    BOOL TargetEmphasisON = FALSE;
    BOOL target1_drawn = NO;
#endif
    BOOL utf_flag = (BOOL)(LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
    BOOL hl1_drawn = NO;
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
    BOOL hl2_drawn=FALSE;	/* whether links[cur].hightext2 is already drawn
				   properly */
#endif
    tmp[0] = tmp[1] = tmp[2] = '\0';
d215 7
a221 12
    /*
     *	Bugs in the history code might cause -1 to be sent for cur, which
     *	yields a crash when LYstrncpy() is called with a nonsense pointer.
     *	As far as I know, such bugs have been squashed, but if they should
     *	reappear, this works around them. - FM
     */
    if (cur < 0)
	cur = 0;
#if defined(TEXTFIELDS_MAY_NEED_ACTIVATION) && defined(INACTIVE_INPUT_STYLE_VH)
    if (flag == OFF)
	textinput_redrawn = FALSE;
#endif
d223 8
a230 21
    if (nlinks > 0) {
#if  defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	if (flag == ON || links[cur].type == WWW_FORM_LINK_TYPE)
#endif
	{
#ifndef USE_COLOR_STYLE
	if (links[cur].type == WWW_FORM_LINK_TYPE ||
	    !links[cur].hightext) {
	    LYMoveToLink(cur, target, NULL,
			 flag, links[cur].inUnderline, utf_flag);
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
	} else {
	    LYMoveToLink(cur, target, links[cur].hightext,
			 flag, links[cur].inUnderline, utf_flag);
	    hl1_drawn = YES;
#ifdef SHOW_WHEREIS_TARGETS
	    target1_drawn = YES;
#endif
	}
#else	/* here USE_COLOR_STYLE defined */
	int s = s_alink;
d232 21
a252 48
#ifdef TEXTFIELDS_MAY_NEED_ACTIVATION
	if ( textfields_need_activation &&
	     links[cur].type == WWW_FORM_LINK_TYPE &&
	     F_TEXTLIKE(links[cur].form->type) )
	    s = s_curedit;
#endif


#  define LXP (links[cur].lx)
#  define LYP (links[cur].ly)
	if (flag != ON) {
	    int x;
		/*
		 *  This is where we try to restore the original style when
		 *  a link is unhighlighted.  The purpose of cached_styles[][]
		 *  is to save the original style just for this case.
		 *  If it doesn't have a color change saved at just the right
		 *  position, we look at preceding positions in the same line
		 *  until we find one.
		 */
	    if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW) {
		CTRACE2(TRACE_STYLE,
			(tfp, "STYLE.highlight.off: cached style @@(%d,%d): ",
			      LYP, LXP));
		s = cached_styles[LYP][LXP];
		if (s == 0) {
		    for (x = LXP-1; x >= 0; x--) {
			if (cached_styles[LYP][x]) {
			    if (cached_styles[LYP][x] > 0) {
				s = cached_styles[LYP][x];
				cached_styles[LYP][LXP] = s;
			    }
			    CTRACE((tfp, "found %d, x_offset=%d.\n",
				    cached_styles[LYP][x], (int)x-LXP));
			    break;
			}
		    }
		    if (s == 0) {
			CTRACE((tfp, "not found, assume <a>.\n"));
			s = s_a;
		    }
		} else {
		    CTRACE((tfp, "found %d.\n", s));
		}
	    } else {
		CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: can't use cache.\n"));
		s = s_a;
	    }
d254 4
a257 1
	    CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.on: @@(%d,%d).\n", LYP, LXP));
d259 5
a263 3
	LYmove(LYP, LXP);
	LynxChangeStyle(s, STACK_ON);
#endif
d265 15
d281 12
d294 9
a302 3
	if (links[cur].type == WWW_FORM_LINK_TYPE) {
	    int len;
	    int avail_space = (LYcols - links[cur].lx) - 1;
d304 8
a311 6
	    LYstrncpy(buffer,
		      (links[cur].hightext ?
		       links[cur].hightext : ""),
		      (avail_space > links[cur].form->size ?
				      links[cur].form->size : avail_space));
	    LYaddstr(buffer);
d313 8
a320 3
	    len = strlen(buffer);
	    for (; len < links[cur].form->size && len < avail_space; len++)
		LYaddch('_');
d322 8
a329 22
	} else {
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	    if (flag == OFF) {
		hl2_drawn = TRUE;
		redraw_lines_of_link(cur);
		CTRACE2(TRACE_STYLE, (tfp, "STYLE.highlight.off: NOFIX branch @@(%d,%d).\n", LYP, LXP));
	    } else
#endif
	    if (!hl1_drawn) {
	    /*
	     *	Copy into the buffer only what will fit
	     *	within the width of the screen.
	     */
		LYmbcsstrncpy(buffer,
			      (links[cur].hightext ?
			       links[cur].hightext : ""),
			      (sizeof(buffer) - 1),
			      ((LYcols - 1) - links[cur].lx),
			      utf_flag);
		LYaddstr(buffer);
	    }
	}
d331 8
a338 19
	/*
	 *  Display a second line as well.
	 */
	if ( links[cur].hightext2 && links[cur].ly < display_lines
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	  && hl2_drawn == FALSE
#endif
	) {
	    lynx_stop_link_color (flag == ON, links[cur].inUnderline);
	    LYmove((links[cur].ly + 1), links[cur].hightext2_offset);
#ifndef USE_COLOR_STYLE
	    lynx_start_link_color (flag == ON, links[cur].inUnderline);
#else
	    CTRACE2(TRACE_STYLE,
		    (tfp, "STYLE.highlight.line2: @@(%d,%d), style=%d.\n",
			  links[cur].ly + 1, links[cur].hightext2_offset,
			  flag == ON ? s_alink : s_a));
	    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON);
#endif
d340 2
a341 20
	    for (i = 0; (tmp[0] = links[cur].hightext2[i]) != '\0' &&
			i+links[cur].hightext2_offset < LYcols; i++) {
		if (!IsSpecialAttrChar(links[cur].hightext2[i])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    if (HTCJK != NOCJK && !isascii(tmp[0])) {
			tmp[1] = links[cur].hightext2[++i];
			LYaddstr(tmp);
			tmp[1] = '\0';
		    } else {
			LYaddstr(tmp);
		    }
		 }
	    }
	}
#if defined(USE_COLOR_STYLE) && !defined(NO_HILIT_FIX)
	if ( hl2_drawn == FALSE )
#endif
	lynx_stop_link_color (flag == ON, links[cur].inUnderline);
a343 30
	if (!target1_drawn)
	/*
	 *  If we have an emphasized WHEREIS hit in the highlighted
	 *  text, restore the emphasis.  Note that we never emphasize
	 *  the first and last characters of the highlighted text when
	 *  we are making the link current, so the link attributes for
	 *  the current link will persist at the beginning and end,
	 *  providing an indication to the user that it has been made
	 *  current.   Also note that we use HText_getFirstTargetInLine()
	 *  to determine if there's a hit in the HText structure line
	 *  containing the link, and if so, get back a copy of the line
	 *  starting at that first hit (which might be before or after
	 *  our link), and with all IsSpecial characters stripped, so we
	 *  don't need to deal with them here. - FM
	 */
	if (target && *target && (links[cur].type & WWW_LINK_TYPE) &&
	    links[cur].hightext && *links[cur].hightext &&
	    HText_getFirstTargetInLine(HTMainText,
				       links[cur].anchor_line_num,
				       utf_flag,
				       (int *)&Offset,
				       (int *)&tLen,
				       (char **)&theData,
				       target)) {
	    int itmp, written, len, y, offset;
	    char *data;
	    int tlen = strlen(target);
	    int hlen, hLen;
	    int hLine = links[cur].ly, hoffset = links[cur].lx;
	    size_t utf_extra = 0;
d345 36
a380 13
	    /*
	     *	Copy into the buffer only what will fit
	     *	up to the right border of the screen. - FM
	     */
	    LYmbcsstrncpy(buffer,
			  (links[cur].hightext ?
			   links[cur].hightext : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].lx),
			  utf_flag);
	    hlen = strlen(buffer);
	    hLen = ((HTCJK != NOCJK || utf_flag) ?
		  LYmbcsstrlen(buffer, utf_flag, YES) : hlen);
d382 32
a413 7
	    /*
	     *	Break out if the first hit in the line
	     *	starts after this link. - FM
	     */
	    if (Offset >= (hoffset + hLen)) {
		goto highlight_search_hightext2;
	    }
d415 4
d420 2
a421 2
	     *	Recursively skip hits that end before this link, and
	     *	break out if there is no hit beyond those. - FM
d432 2
a433 2
					       &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
d437 1
a437 1
		    goto highlight_search_hightext2;
d444 4
a447 4
	     *	If the hit starts before the hightext, and ends
	     *	in or beyond the hightext, restore the emphasis,
	     *	skipping the first and last characters of the
	     *	hightext if we're making the link current. - FM
d456 2
a457 2
		 *  Go to the start of the hightext and
		 *  handle its first character. - FM
d461 1
a461 24
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
d466 2
a467 2
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
d479 1
a479 1
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d481 1
a481 1
		     *	For CJK strings, by Masanobu Kimura.
d485 2
a486 2
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
d499 2
a500 2
		     *	Start emphasis immediately if we are making
		     *	the link non-current. - FM
d513 2
a514 3
		 *  Start emphasis after the first character
		 *  if we are making the link current and this
		 *  is not the last character. - FM
d523 1
a523 1
		 *  Handle the remaining characters. - FM
d529 3
a531 4
		     *	Print all the other target chars, except
		     *	the last character if it is also the last
		     *	character of hightext and we are making
		     *	the link current. - FM
d533 1
a533 24
		    if (utf_flag && !isascii(tmp[0])) {
			if ((*tmp & 0xe0) == 0xc0) {
			    utf_extra = 1;
			} else if ((*tmp & 0xf0) == 0xe0) {
			    utf_extra = 2;
			} else if ((*tmp & 0xf8) == 0xf0) {
			    utf_extra = 3;
			} else if ((*tmp & 0xfc) == 0xf8) {
			    utf_extra = 4;
			} else if ((*tmp & 0xfe) == 0xfc) {
			    utf_extra = 5;
			} else {
			    /*
			     *	Garbage.
			     */
			    utf_extra = 0;
			}
			if (strlen(&data[itmp+1]) < utf_extra) {
			    /*
			     *	Shouldn't happen.
			     */
			    utf_extra = 0;
			}
		    }
d538 3
a540 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext if we
			 *  are making the link current. - FM
d553 1
a553 1
		    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d555 1
a555 1
			 *  For CJK strings, by Masanobu Kimura.
d559 3
a561 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext if we
			 *  are making the link current. - FM
d575 3
a577 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext if we
			 *  are making the link current. - FM
d592 4
a595 6
		 *  Stop the emphasis if we haven't already, then
		 *  reset the offset to our current position in
		 *  the line, and if that is beyond the link, or
		 *  or we are making the link current and it is
		 *  the last character of the hightext, we are
		 *  done. - FM
d602 6
a607 19
		if (offset >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_hightext2;
		}

		/*
		 *  See if we have another hit that starts
		 *  within the hightext. - FM
		 */
		data = (Data + (offset - Offset));
		if (!utf_flag) {
		    data = Data + (offset - Offset);
		} else {
		    data = LYmbcs_skip_glyphs(Data,
					      (offset - Offset),
					      utf_flag);
		}
		if (((cp = LYno_attr_mb_strstr(data,
d611 2
a612 2
					       &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
d614 3
a616 3
		     *	If the hit starts after the end of the hightext,
		     *	or we are making the link current and the hit
		     *	starts at its last character, we are done. - FM
d618 3
a620 6
		    if ((HitOffset + offset) >=
			(hoffset +
			 (flag == ON ? (hLen - 1) : hLen)))  {
			goto highlight_search_hightext2;
		    }

d622 2
a623 2
		     *	Set up the data and offset for the hit, and let
		     *	the code for within hightext hits handle it. - FM
d631 1
a631 1
		goto highlight_search_hightext2;
d636 14
a649 22
	     *	If we get to here, the hit starts within the
	     *	hightext.  If we are making the link current
	     *	and it's the last character in the hightext,
	     *	we are done.  Otherwise, move there and start
	     *	restoring the emphasis. - FM
	     */
	    if ((Offset - offset) >
		(flag == ON ? (hLen - 1) : hLen))  {
		goto highlight_search_hightext2;
	    }
	    if (!utf_flag) {
		data += (Offset - offset);
	    } else {
		LYrefresh();
		data = LYmbcs_skip_glyphs(data,
					  (Offset - offset),
					  utf_flag);
	    }
	    offset = Offset;
	    itmp = 0;
	    written = 0;
	    len = tlen;
a650 51
	    /*
	     *	Go to the start of the hit and
	     *	handle its first character. - FM
	     */
	    LYmove(hLine, offset);
	    tmp[0] = data[itmp];
	    if (utf_flag && !isascii(tmp[0])) {
		if ((*tmp & 0xe0) == 0xc0) {
		    utf_extra = 1;
		} else if ((*tmp & 0xf0) == 0xe0) {
		    utf_extra = 2;
		} else if ((*tmp & 0xf8) == 0xf0) {
		    utf_extra = 3;
		} else if ((*tmp & 0xfc) == 0xf8) {
		    utf_extra = 4;
		} else if ((*tmp & 0xfe) == 0xfc) {
		    utf_extra = 5;
		} else {
		    /*
		     *	Garbage.
		     */
		    utf_extra = 0;
		}
		if (strlen(&data[itmp+1]) < utf_extra) {
		    /*
		     *	Shouldn't happen.
		     */
		    utf_extra = 0;
		}
	    }
	    if (utf_extra) {
		LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		itmp += utf_extra;
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    LYaddstr(tmp);
		} else {
		    LYmove(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += (utf_extra + 1);
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d652 2
a653 1
		 *  For CJK strings, by Masanobu Kimura.
d655 3
a657 79
		tmp[1] = data[++itmp];
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    LYaddstr(tmp);
		} else {
		    LYmove(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += 2;
	    } else {
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    LYaddstr(tmp);
		} else {
		    LYmove(hLine, (offset + 1));
		}
		written++;
	    }
	    itmp++;
	    /*
	     *	Start emphasis after the first character
	     *	if we are making the link current and this
	     *	is not the last character. - FM
	     */
	    if (!TargetEmphasisON &&
		data[itmp] != '\0') {
		LYstartTargetEmphasis();
		TargetEmphasisON = TRUE;
	    }

	    for (;
		 written < len && (tmp[0] = data[itmp]) != '\0';
		 itmp++)  {
		/*
		 *  Print all the other target chars, except
		 *  the last character if it is also the last
		 *  character of hightext and we are making
		 *  the link current. - FM
		 */
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
d662 3
a664 3
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext if we
		     *	are making the link current. - FM
d666 6
a671 4
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
a672 2
		    } else {
			LYaddstr(tmp);
d677 1
a677 1
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d679 1
a679 1
		     *	For CJK strings, by Masanobu Kimura.
d683 3
a685 3
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext if we
		     *	are making the link current. - FM
d687 5
a691 5
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			LYmove(hLine, (offset + 1));
d693 1
a693 336
			LYaddstr(tmp);
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			LYmove(hLine, (offset + 1));
		    } else {
			LYaddstr(tmp);
		    }
		    written++;
		}
	    }

	    /*
	     *	Stop the emphasis if we haven't already, then reset
	     *	the offset to our current position in the line, and
	     *	if that is beyond the link, or we are making the link
	     *	current and it is the last character in the hightext,
	     *	we are done. - FM
	     */
	    if (TargetEmphasisON) {
		LYstopTargetEmphasis();
		TargetEmphasisON = FALSE;
	    }
	    LYGetYX(y, offset);
	    if (offset >=
		(hoffset + (flag == ON ? (hLen - 1) : hLen))) {
		goto highlight_search_hightext2;
	    }

	    /*
	     *	See if we have another hit that starts
	     *	within the hightext. - FM
	     */
	    if (!utf_flag) {
		data = Data + (offset - Offset);
	    } else {
		data = LYmbcs_skip_glyphs(Data,
					  (offset - Offset),
					  utf_flag);
	    }
	    if (((cp = LYno_attr_mb_strstr(data,
					   target,
					   utf_flag, YES,
					   &HitOffset,
					   &LenNeeded)) != NULL) &&
		(offset + LenNeeded) < LYcols) {
		/*
		 *  If the hit starts after the end of the hightext,
		 *  or we are making the link current and the hit
		 *  starts at its last character, we are done. - FM
		 */
		if ((HitOffset + offset) >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_hightext2;
		}

		/*
		 *  If the target extends beyond our buffer, emphasize
		 *  everything in the hightext starting at this hit.
		 *  Otherwise, set up the data and offsets, and loop
		 *  back. - FM
		 */
		if ((HitOffset + (offset + tLen)) >=
		    (hoffset + hLen)) {
		    offset = (HitOffset + offset);
		    if (!utf_flag) {
			data = buffer + (offset - hoffset);
		    } else {
			LYrefresh();
			data = LYmbcs_skip_glyphs(buffer,
						  (offset - hoffset),
						  utf_flag);
		    }
		    LYmove(hLine, offset);
		    itmp = 0;
		    written = 0;
		    len = strlen(data);

		    /*
		     *	Turn the emphasis back on. - FM
		     */
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    for (;
			 written < len && (tmp[0] = data[itmp]) != '\0';
			 itmp++)  {
			/*
			 *  Print all the other target chars, except
			 *  the last character if it is also the last
			 *  character of hightext and we are making
			 *  the link current. - FM
			 */
			if (utf_flag && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
			if (utf_extra) {
			    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
			    itmp += utf_extra;
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
				LYGetYX(y, offset);
				LYmove(hLine, (offset + 1));
			    } else {
				LYaddstr(tmp);
			    }
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
			    /*
			     *	For CJK strings, by Masanobu Kimura.
			     */
			    tmp[1] = data[++itmp];
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				LYaddstr(tmp);
			    }
			    tmp[1] = '\0';
			    written += 2;
			} else {
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				LYaddstr(tmp);
			    }
			    written++;
			}
		    }
		    /*
		     *	Turn off the emphasis if we haven't already,
		     *	and then we're done. - FM
		     */
		    if (TargetEmphasisON) {
			LYstopTargetEmphasis();
		    }
		    goto highlight_search_hightext2;
		} else {
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext;
		}
	    }
	    goto highlight_search_hightext2;
	}
highlight_search_hightext2:
	if (target && *target && (links[cur].type & WWW_LINK_TYPE) &&
	    links[cur].hightext2 && *links[cur].hightext2 &&
	    links[cur].ly < display_lines &&
	    HText_getFirstTargetInLine(HTMainText,
				       (links[cur].anchor_line_num + 1),
				       utf_flag,
				       (int *)&Offset,
				       (int *)&tLen,
				       (char **)&theData,
				       target)) {
	    int itmp, written, len, y, offset;
	    char *data;
	    int tlen = strlen(target);
	    int hlen, hLen;
	    int hLine = (links[cur].ly + 1);
	    int hoffset = links[cur].hightext2_offset;
	    size_t utf_extra = 0;

	    /*
	     *	Copy into the buffer only what will fit
	     *	up to the right border of the screen. - FM
	     */
	    LYmbcsstrncpy(buffer,
			  (links[cur].hightext2 ?
			   links[cur].hightext2 : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].hightext2_offset),
			  utf_flag);
	    hlen = strlen(buffer);
	    hLen = ((HTCJK != NOCJK || utf_flag) ?
		  LYmbcsstrlen(buffer, utf_flag, YES) : hlen);

	    /*
	     *	Break out if the first hit in the line
	     *	starts after this link. - FM
	     */
	    if (Offset >= (hoffset + hLen)) {
		goto highlight_search_done;
	    }

	    /*
	     *	Recursively skip hits that end before this link, and
	     *	break out if there is no hit beyond those. - FM
	     */
	    Data = theData;
	    while ((Offset < hoffset) &&
		   ((Offset + tLen) <= hoffset)) {
		data = (Data + tlen);
		offset = (Offset + tLen);
		if (((cp = LYno_attr_mb_strstr(data,
					       target,
					       utf_flag, YES,
					       &HitOffset,
					       &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
		    Data = cp;
		    Offset = (offset + HitOffset);
		} else {
		    goto highlight_search_done;
		}
	    }
	    data = buffer;
	    offset = hoffset;

	    /*
	     *	If the hit starts before the hightext2, and ends
	     *	in or beyond the hightext2, restore the emphasis,
	     *	skipping the first and last characters of the
	     *	hightext2 if we're making the link current. - FM
	     */
	    if ((Offset < offset) &&
		((Offset + tLen) > offset)) {
		itmp = 0;
		written = 0;
		len = (tlen - (offset - Offset));

		/*
		 *  Go to the start of the hightext2 and
		 *  handle its first character. - FM
		 */
		LYmove(hLine, offset);
		tmp[0] = data[itmp];
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		    itmp += utf_extra;
		    /*
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     *	Start emphasis immediately if we are
		     *	making the link non-current. - FM
		     */
		    if (flag != ON) {
			LYstartTargetEmphasis();
			TargetEmphasisON = TRUE;
			LYaddstr(tmp);
		    } else {
			LYmove(hLine, (offset + 1));
d699 3
a701 2
		     *	Start emphasis immediately if we are making
		     *	the link non-current. - FM
d703 2
a704 1
		    if (flag != ON) {
d715 2
a716 3
		 *  Start emphasis after the first character
		 *  if we are making the link current and this
		 *  is not the last character. - FM
a723 3
		/*
		 *  Handle the remaining characters. - FM
		 */
d728 3
a730 4
		     *	Print all the other target chars, except
		     *	the last character if it is also the last
		     *	character of hightext2 and we are making
		     *	the link current. - FM
d732 1
a732 24
		    if (utf_flag && !isascii(tmp[0])) {
			if ((*tmp & 0xe0) == 0xc0) {
			    utf_extra = 1;
			} else if ((*tmp & 0xf0) == 0xe0) {
			    utf_extra = 2;
			} else if ((*tmp & 0xf8) == 0xf0) {
			    utf_extra = 3;
			} else if ((*tmp & 0xfc) == 0xf8) {
			    utf_extra = 4;
			} else if ((*tmp & 0xfe) == 0xfc) {
			    utf_extra = 5;
			} else {
			    /*
			     *	Garbage.
			     */
			    utf_extra = 0;
			}
			if (strlen(&data[itmp+1]) < utf_extra) {
			    /*
			     *	Shouldn't happen.
			     */
			    utf_extra = 0;
			}
		    }
d737 3
a739 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext2 if we
			 *  are making the link current. - FM
d752 1
a752 1
		    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
d754 1
a754 1
			 *  For CJK strings, by Masanobu Kimura.
d758 3
a760 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext2 if we
			 *  are making the link current. - FM
d774 3
a776 3
			 *  Make sure we don't restore emphasis to
			 *  the last character of hightext2 if we
			 *  are making the link current. - FM
d791 4
a794 6
		 *  Stop the emphasis if we haven't already, then
		 *  reset the offset to our current position in
		 *  the line, and if that is beyond the link, or
		 *  or we are making the link current and it is
		 *  the last character of the hightext2, we are
		 *  done. - FM
d801 6
a806 18
		if (offset >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_done;
		}

		/*
		 *  See if we have another hit that starts
		 *  within the hightext2. - FM
		 */
		if (!utf_flag) {
		    data = Data + (offset - Offset);
		} else {
		    data = LYmbcs_skip_glyphs(Data,
					      (offset - Offset),
					      utf_flag);
		}
		if (((cp = LYno_attr_mb_strstr(data,
d810 2
a811 2
					       &LenNeeded)) != NULL) &&
		    (offset + LenNeeded) < LYcols) {
d813 3
a815 3
		     *	If the hit starts after the end of the hightext2,
		     *	or we are making the link current and the hit
		     *	starts at its last character, we are done. - FM
d817 1
a817 6
		    if ((HitOffset + offset) >=
			(hoffset +
			 (flag == ON ? (hLen - 1) : hLen)))  {
			goto highlight_search_done;
		    }

d819 4
a822 2
		     *	Set up the data and offset for the hit, and let
		     *	the code for within hightext2 hits handle it. - FM
d824 92
a915 5
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext2;
a916 1
		goto highlight_search_done;
d918 7
d926 6
a931 24
highlight_hit_within_hightext2:
	    /*
	     *	If we get to here, the hit starts within the
	     *	hightext2.  If we are making the link current
	     *	and it's the last character in the hightext2,
	     *	we are done.  Otherwise, move there and start
	     *	restoring the emphasis. - FM
	     */
	    if ((Offset - offset) >
		(flag == ON ? (hLen - 1) : hLen))  {
		goto highlight_search_done;
	    }
	    if (!utf_flag) {
		data += (Offset - offset);
	    } else {
		LYrefresh();
		data = LYmbcs_skip_glyphs(data,
					  (Offset - offset),
					  utf_flag);
	    }
	    offset = Offset;
	    itmp = 0;
	    written = 0;
	    len = tlen;
d933 32
a964 22
	    /*
	     *	Go to the start of the hit and
	     *	handle its first character. - FM
	     */
	    LYmove(hLine, offset);
	    tmp[0] = data[itmp];
	    if (utf_flag && !isascii(tmp[0])) {
		if ((*tmp & 0xe0) == 0xc0) {
		    utf_extra = 1;
		} else if ((*tmp & 0xf0) == 0xe0) {
		    utf_extra = 2;
		} else if ((*tmp & 0xf8) == 0xf0) {
		    utf_extra = 3;
		} else if ((*tmp & 0xfc) == 0xf8) {
		    utf_extra = 4;
		} else if ((*tmp & 0xfe) == 0xfc) {
		    utf_extra = 5;
		} else {
		    /*
		     *	Garbage.
		     */
		    utf_extra = 0;
d966 3
a968 45
		if (strlen(&data[itmp+1]) < utf_extra) {
		    /*
		     *	Shouldn't happen.
		     */
		    utf_extra = 0;
		}
	    }
	    if (utf_extra) {
		LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		itmp += utf_extra;
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext2. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    LYaddstr(tmp);
		} else {
		    LYmove(hLine, (offset + 1));
		}
		tmp[1] = '\0';
		written += (utf_extra + 1);
		utf_extra = 0;
	    } else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		/*
		 *  For CJK strings, by Masanobu Kimura.
		 */
		tmp[1] = data[++itmp];
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext2. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    LYaddstr(tmp);
		} else {
		    LYmove(hLine, (offset + 1));
a969 2
		tmp[1] = '\0';
		written += 2;
d971 1
a971 116
		/*
		 *  Start emphasis immediately if we are making
		 *  the link non-current, or we are making it
		 *  current but this is not the first or last
		 *  character of the hightext2. - FM
		 */
		if (flag != ON ||
		    (offset > hoffset && data[itmp+1] != '\0')) {
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    LYaddstr(tmp);
		} else {
		    LYmove(hLine, (offset + 1));
		}
		written++;
	    }
	    itmp++;
	    /*
	     *	Start emphasis after the first character
	     *	if we are making the link current and this
	     *	is not the last character. - FM
	     */
	    if (!TargetEmphasisON &&
		data[itmp] != '\0') {
		LYstartTargetEmphasis();
		TargetEmphasisON = TRUE;
	    }

	    for (;
		 written < len && (tmp[0] = data[itmp]) != '\0';
		 itmp++)  {
		/*
		 *  Print all the other target chars, except
		 *  the last character if it is also the last
		 *  character of hightext2 and we are making
		 *  the link current. - FM
		 */
		if (utf_flag && !isascii(tmp[0])) {
		    if ((*tmp & 0xe0) == 0xc0) {
			utf_extra = 1;
		    } else if ((*tmp & 0xf0) == 0xe0) {
			utf_extra = 2;
		    } else if ((*tmp & 0xf8) == 0xf0) {
			utf_extra = 3;
		    } else if ((*tmp & 0xfc) == 0xf8) {
			utf_extra = 4;
		    } else if ((*tmp & 0xfe) == 0xfc) {
			utf_extra = 5;
		    } else {
			/*
			 *  Garbage.
			 */
			utf_extra = 0;
		    }
		    if (strlen(&data[itmp+1]) < utf_extra) {
			/*
			 *  Shouldn't happen.
			 */
			utf_extra = 0;
		    }
		}
		if (utf_extra) {
		    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
		    itmp += utf_extra;
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext2 if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			LYmove(hLine, (offset + 1));
		    } else {
			LYaddstr(tmp);
		    }
		    tmp[1] = '\0';
		    written += (utf_extra + 1);
		    utf_extra = 0;
		} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
		    /*
		     *	For CJK strings, by Masanobu Kimura.
		     */
		    tmp[1] = data[++itmp];
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext2 if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			LYmove(hLine, (offset + 1));
		    } else {
			LYaddstr(tmp);
		    }
		    tmp[1] = '\0';
		    written += 2;
		} else {
		    /*
		     *	Make sure we don't restore emphasis to
		     *	the last character of hightext2 if we
		     *	are making the link current. - FM
		     */
		    if (flag == ON && data[(itmp + 1)] == '\0') {
			LYstopTargetEmphasis();
			TargetEmphasisON = FALSE;
			LYGetYX(y, offset);
			LYmove(hLine, (offset + 1));
		    } else {
			LYaddstr(tmp);
		    }
		    written++;
		}
d973 88
d1062 7
d1070 2
a1071 5
	     *	Stop the emphasis if we haven't already, then reset
	     *	the offset to our current position in the line, and
	     *	if that is beyond the link, or we are making the link
	     *	current and it is the last character in the hightext2,
	     *	we are done. - FM
d1073 8
a1080 9
	    if (TargetEmphasisON) {
		LYstopTargetEmphasis();
		TargetEmphasisON = FALSE;
	    }
	    LYGetYX(y, offset);
	    if (offset >=
		(hoffset + (flag == ON ? (hLen - 1) : hLen))) {
		goto highlight_search_done;
	    }
d1082 15
a1096 27
	    /*
	     *	See if we have another hit that starts
	     *	within the hightext2. - FM
	     */
	    if (!utf_flag) {
		data = (Data + (offset - Offset));
	    } else {
		data = LYmbcs_skip_glyphs(Data,
					  (offset - Offset),
					  utf_flag);
	    }
	    if (((cp = LYno_attr_mb_strstr(data,
					   target,
					   utf_flag, YES,
					   &HitOffset,
					   &LenNeeded)) != NULL) &&
		(offset + LenNeeded) < LYcols) {
		/*
		 *  If the hit starts after the end of the hightext2,
		 *  or we are making the link current and the hit
		 *  starts at its last character, we are done. - FM
		 */
		if ((HitOffset + offset) >=
		    (hoffset +
		     (flag == ON ? (hLen - 1) : hLen)))  {
		    goto highlight_search_done;
		}
d1098 9
a1106 21
		/*
		 *  If the target extends beyond our buffer, emphasize
		 *  everything in the hightext2 starting at this hit.
		 *  Otherwise, set up the data and offsets, and loop
		 *  back. - FM
		 */
		if ((HitOffset + (offset + tLen)) >=
		    (hoffset + hLen)) {
		    offset = (HitOffset + offset);
		    if (!utf_flag) {
			data = buffer + (offset - hoffset);
		    } else {
			LYrefresh();
			data = LYmbcs_skip_glyphs(buffer,
						  (offset - hoffset),
						  utf_flag);
		    }
		    LYmove(hLine, offset);
		    itmp = 0;
		    written = 0;
		    len = strlen(data);
d1108 3
a1110 8
		    /*
		     *	Turn the emphasis back on. - FM
		     */
		    LYstartTargetEmphasis();
		    TargetEmphasisON = TRUE;
		    for (;
			 written < len && (tmp[0] = data[itmp]) != '\0';
			 itmp++)  {
d1112 1
a1112 4
			 *  Print all the other target chars, except
			 *  the last character if it is also the last
			 *  character of hightext2 and we are making
			 *  the link current. - FM
d1114 3
a1116 59
			if (utf_flag && !isascii(tmp[0])) {
			    if ((*tmp & 0xe0) == 0xc0) {
				utf_extra = 1;
			    } else if ((*tmp & 0xf0) == 0xe0) {
				utf_extra = 2;
			    } else if ((*tmp & 0xf8) == 0xf0) {
				utf_extra = 3;
			    } else if ((*tmp & 0xfc) == 0xf8) {
				utf_extra = 4;
			    } else if ((*tmp & 0xfe) == 0xfc) {
				utf_extra = 5;
			    } else {
				/*
				 *  Garbage.
				 */
				utf_extra = 0;
			    }
			    if (strlen(&data[itmp+1]) < utf_extra) {
				/*
				 *  Shouldn't happen.
				 */
				utf_extra = 0;
			    }
			}
			if (utf_extra) {
			    LYstrncpy(&tmp[1], &data[itmp+1], utf_extra);
			    itmp += utf_extra;
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext2 if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
				LYGetYX(y, offset);
				LYmove(hLine, (offset + 1));
			    } else {
				LYaddstr(tmp);
			    }
			    tmp[1] = '\0';
			    written += (utf_extra + 1);
			    utf_extra = 0;
			} else if (HTCJK != NOCJK && !isascii(tmp[0])) {
			    /*
			     *	For CJK strings, by Masanobu Kimura.
			     */
			    tmp[1] = data[++itmp];
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext2 if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				LYaddstr(tmp);
			    }
a1117 1
			    written += 2;
d1119 1
a1119 12
			    /*
			     *	Make sure we don't restore emphasis to
			     *	the last character of hightext2 if we
			     *	are making the link current. - FM
			     */
			    if (flag == ON && data[(itmp + 1)] == '\0') {
				LYstopTargetEmphasis();
				TargetEmphasisON = FALSE;
			    } else {
				LYaddstr(tmp);
			    }
			    written++;
d1121 1
a1121 15
		    }
		    /*
		     *	Turn off the emphasis if we haven't already,
		     *	and then we're done. - FM
		     */
		    if (TargetEmphasisON) {
			LYstopTargetEmphasis();
		    }
		    goto highlight_search_done;
		} else {
		    Data = cp;
		    Offset = (offset + HitOffset);
		    data = buffer;
		    offset = hoffset;
		    goto highlight_hit_within_hightext2;
d1124 13
a1136 1
	    goto highlight_search_done;
a1137 2
highlight_search_done:
	FREE(theData);
d1184 1
a1184 1
    char *ns = string;
d1187 1
a1187 1
    if (!string)
d1190 4
d1401 4
a1404 2
		int a=(strncmp(buffer, ALERT_FORMAT, ALERT_PREFIX_LEN) ||
		       !hashStyles[s_alert].name) ? s_status : s_alert;
d1460 1
a1460 1
    /* stop_reverse(); */
d1556 1
a1556 1
#if HAVE_GETTIMEOFDAY
d1578 1
a1578 1
#if !defined(USE_SLANG) && (defined(UNIX) || defined(__DJGPP__))
d1612 1
a1612 1
    socket_timeout.tv_usec = 100;
d1636 1
a1636 1
#endif /* DOSPATH */
d1643 1
a1643 1
#endif /* DOSPATH */
d1658 1
a1658 1
	  return((int)FALSE);
d1683 2
a1684 2
	** Currently we have scrolling in partial mode and toggling of trace
	** log. User search now in progress...
d1687 1
a1687 2
    switch (cmd)
    {
d1689 13
a1701 2
	   handle_LYK_TRACE_TOGGLE();
	   break;
a1702 1

a1703 1
	if (display_partial && (NumOfLines_partial > 2))
d1705 1
a1705 1
	{
d1710 1
a1710 2
	    switch (cmd)
	    {
d1788 2
a1789 2
	    NumOfLines_partial = HText_getNumOfLines();
	    LYMainLoop_pageDisplay(Newline_partial);
d1805 2
d1808 1
a1808 1
    return TRUE;
d1810 4
a1813 6
    BOOLEAN result;
#if defined(DOSPATH) || defined(__EMX__)
    result = (BOOL) (LYIsPathSep(path[0])
     || (isalpha(UCH(path[0]))
      && (path[1] == ':')
       && LYIsPathSep(path[2])));
d1815 4
a1818 2
    result = (LYIsPathSep(path[0]));
#endif /* DOSPATH */
a1819 1
#endif
d1826 1
a1826 1
	char *,		path)
d1828 1
a1828 1
#if defined(DOSPATH) || defined(__EMX__)
d1830 1
a1830 2
     && isalpha(UCH(path[0]))
     && path[1] == ':'
d1842 1
a1842 1
	char *,		filename)
d1857 1
a1857 1
    if ((cp=strchr(host, ':')) != NULL)
d1863 1
a1863 7
#ifdef VMS
	     0==strcasecomp(host, HTHostName())
#else
	     0==strcmp(host, HTHostName())
#endif /* VMS */
	    ))
	{
d1880 1
a1880 1
	char *,		filename)
d1897 5
a1901 12
#ifdef VMS
    if ((0==strcasecomp(host, "localhost") ||
	 0==strcasecomp(host, LYHostName) ||
	 0==strcasecomp(host, HTHostName())))
#else
    if ((0==strcmp(host, "localhost") ||
	 0==strcmp(host, LYHostName) ||
	 0==strcmp(host, HTHostName())))
#endif /* VMS */
    {
	    FREE(host);
	    return YES;
d1935 1
a1935 1
    if (!(alias && *alias))
d1956 1
a1956 1
	char *,		filename)
d1976 1
a1976 6
#ifdef VMS
	if (0==strcasecomp(host, alias))
#else
	if (0==strcmp(host, alias))
#endif /* VMS */
	{
d2007 1
a2007 1
    if (cp == NULL || *cp == '\0')
d2022 1
a2022 1
	if (getenv(cp2) != NULL) {
d2027 3
a2029 3
#if defined (DOSPATH)
	if (cp[1] == ':')
	    return(NOT_A_URL_TYPE);	/* could be drive letter? - kw */
d2067 6
d2090 3
d2097 2
a2098 2
    if (cp == NULL || *cp == '\0')
	return(0);
d2104 1
a2104 1
	return(0);
d2118 2
a2119 2
    if (*cp == ':' || LYIsHtmlSep(*cp))
	return(0);
d2121 16
a2136 2
    if (compare_type(cp, "news:", 5)) {
	return(NEWS_URL_TYPE);
d2138 7
a2144 2
    } else if (compare_type(cp, "nntp:", 5)) {
	return(NNTP_URL_TYPE);
d2146 5
a2150 2
    } else if (compare_type(cp, "snews:", 6)) {
	return(SNEWS_URL_TYPE);
d2152 5
a2156 5
    } else if (compare_type(cp, "newspost:", 9)) {
	/*
	 *  Special Lynx type to handle news posts.
	 */
	return(NEWSPOST_URL_TYPE);
d2158 5
a2162 5
    } else if (compare_type(cp, "newsreply:", 10)) {
	/*
	 *  Special Lynx type to handle news replies (followups).
	 */
	return(NEWSREPLY_URL_TYPE);
d2164 5
a2168 5
    } else if (compare_type(cp, "snewspost:", 10)) {
	/*
	 *  Special Lynx type to handle snews posts.
	 */
	return(NEWSPOST_URL_TYPE);
d2170 5
a2174 5
    } else if (compare_type(cp, "snewsreply:", 11)) {
	/*
	 *  Special Lynx type to handle snews replies (followups).
	 */
	return(NEWSREPLY_URL_TYPE);
d2176 5
a2180 2
    } else if (compare_type(cp, "mailto:", 7)) {
	return(MAILTO_URL_TYPE);
d2182 5
a2186 4
#ifndef DISABLE_BIBP
    } else if (compare_type(cp, "bibp:", 5)) {
	return(BIBP_URL_TYPE);
#endif
d2188 5
a2192 8
    } else if (compare_type(cp, "file:", 5)) {
	if (LYisLocalFile(cp)) {
	    return(FILE_URL_TYPE);
	} else if (LYIsHtmlSep(cp[5]) && LYIsHtmlSep(cp[6])) {
	    return(FTP_URL_TYPE);
	} else {
	    return(0);
	}
d2194 5
a2198 2
    } else if (compare_type(cp, "data:", 5)) {
	return(DATA_URL_TYPE);
d2200 5
a2204 7
    } else if (compare_type(cp, "lynxexec:", 9)) {
	/*
	 *  Special External Lynx type to handle execution
	 *  of commands or scripts which require a pause to
	 *  read the screen upon completion.
	 */
	return(LYNXEXEC_URL_TYPE);
d2206 7
a2212 7
    } else if (compare_type(cp, "lynxprog:", 9)) {
	/*
	 *  Special External Lynx type to handle execution
	 *  of commands, scripts or programs with do not
	 *  require a pause to read screen upon completion.
	 */
	return(LYNXPROG_URL_TYPE);
d2214 15
a2228 5
    } else if (compare_type(cp, "lynxcgi:", 8)) {
	/*
	 *  Special External Lynx type to handle cgi scripts.
	 */
	return(LYNXCGI_URL_TYPE);
d2230 2
a2231 5
    } else if (compare_type(cp, "LYNXPRINT:", 10)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXPRINT_URL_TYPE);
d2233 5
a2237 5
    } else if (compare_type(cp, "LYNXOPTIONS:", 12)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXOPTIONS_URL_TYPE);
d2239 7
a2245 5
    } else if (compare_type(cp, "LYNXCFG:", 8)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXCFG_URL_TYPE);
d2247 7
a2253 5
    } else if (compare_type(cp, "LYNXMESSAGES:", 13)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXMESSAGES_URL_TYPE);
d2255 5
a2259 5
    } else if (compare_type(cp, "LYNXCOMPILEOPTS:", 16)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXCOMPILE_OPTS_URL_TYPE);
d2261 14
a2274 36
    } else if (compare_type(cp, "LYNXDOWNLOAD:", 13)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXDOWNLOAD_URL_TYPE);

    } else if (compare_type(cp, "LYNXDIRED:", 10)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXDIRED_URL_TYPE);

    } else if (compare_type(cp, "LYNXHIST:", 9)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXHIST_URL_TYPE);

    } else if (compare_type(cp, "LYNXKEYMAP:", 11)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXKEYMAP_URL_TYPE);

    } else if (compare_type(cp, "LYNXIMGMAP:", 11)) {
	/*
	 *  Special Internal Lynx type.
	 */
	(void)is_url(&cp[11]);	/* forces lower/uppercase of next part */
	return(LYNXIMGMAP_URL_TYPE);

    } else if (compare_type(cp, "LYNXCOOKIE:", 11)) {
	/*
	 *  Special Internal Lynx type.
	 */
	return(LYNXCOOKIE_URL_TYPE);
d2276 20
a2295 8
    } else if (strstr((cp+3), "://") == NULL) {
	/*
	 *  If it doesn't contain "://", and it's not one of the
	 *  the above, it can't be a URL with a scheme we know,
	 *  so check if it's an unknown scheme for which proxying
	 *  has been set up. - FM
	 */
	return(LYCheckForProxyURL(filename));
d2297 8
a2304 2
    } else if (compare_type(cp, "http:", 5)) {
	return(HTTP_URL_TYPE);
d2306 6
a2311 2
    } else if (compare_type(cp, "https:", 6)) {
	return(HTTPS_URL_TYPE);
d2313 15
a2327 2
    } else if (compare_type(cp, "gopher:", 7)) {
	if ((cp1 = strchr(cp+11,'/')) != NULL) {
d2329 6
a2334 12
	    if (TOUPPER(*(cp1+1)) == 'H' || *(cp1+1) == 'w')
		/* if this is a gopher html type */
		return(HTML_GOPHER_URL_TYPE);
	    else if (*(cp1+1) == 'T' || *(cp1+1) == '8')
		return(TELNET_GOPHER_URL_TYPE);
	    else if (*(cp1+1) == '7')
		return(INDEX_GOPHER_URL_TYPE);
	    else
		return(GOPHER_URL_TYPE);
	} else {
	    return(GOPHER_URL_TYPE);
	}
d2336 4
a2339 2
    } else if (compare_type(cp, "ftp:", 4)) {
	return(FTP_URL_TYPE);
d2341 28
a2368 2
    } else if (compare_type(cp, "wais:", 5)) {
	return(WAIS_URL_TYPE);
d2370 4
a2373 2
    } else if (compare_type(cp, "telnet:", 7)) {
	return(TELNET_URL_TYPE);
d2375 4
a2378 2
    } else if (compare_type(cp, "tn3270:", 7)) {
	return(TN3270_URL_TYPE);
d2380 6
a2385 2
    } else if (compare_type(cp, "rlogin:", 7)) {
	return(RLOGIN_URL_TYPE);
d2387 6
a2392 2
    } else if (compare_type(cp, "cso:", 4)) {
	return(CSO_URL_TYPE);
d2394 6
a2399 2
    } else if (compare_type(cp, "finger:", 7)) {
	return(FINGER_URL_TYPE);
d2401 9
a2409 7
    } else if (compare_type(cp, "afs:", 4)) {
	return(AFS_URL_TYPE);

    } else if (compare_type(cp, "prospero:", 9)) {
	return(PROSPERO_URL_TYPE);

    } else {
d2411 1
a2411 2
	 *  Check if it's an unknown scheme for which
	 *  proxying has been set up. - FM
d2413 2
a2414 1
	return(LYCheckForProxyURL(filename));
d2416 1
d2461 4
a2464 4
	    (!strncmp(addr, "telnet:", 7) ||
	     !strncmp(addr, "rlogin:", 7) ||
	     !strncmp(addr, "tn3270:", 7) ||
	     (strncmp(addr, "gopher:", 7) &&
d2471 3
a2473 3
	    if (strncmp(physical, "telnet:", 7) &&
		strncmp(physical, "rlogin:", 7) &&
		strncmp(physical, "tn3270:", 7)) {
d2488 1
a2488 2
    CONST char *,	address
    )
d2492 1
a2492 1
    if (!(address && *address))
d2540 1
a2540 1
	if (acc_method && *acc_method) {
d2543 3
a2545 3
	    proxy = getenv(acc_method);
	    if (proxy && (!strncmp(proxy, "http:", 5) ||
			  !strncmp(proxy, "lynxcgi:", 8)) &&
d2652 1
a2652 1
#if HAVE_UTMP
d2680 2
a2681 1
	CTRACE((tfp, "Could not get ttyname or open UTMP file %s\n", UTMP_FILE));
d2691 1
a2691 1
#if HAVE_SIGACTION
d2722 1
a2722 1
#if HAVE_SIGACTION
d2820 1
a2820 1
#if HAVE_SIZECHANGE
d2878 1
a2878 1
	    Switch_Display_Charset(current_char_set, SWITCH_DISPLAY_CHARSET_SIZECHANGE);
d2918 1
a2918 1
    if (!(fname && *fname))
d2952 1
d2972 1
a2972 1
    cp = wwwName(lynx_temp_space);
d2974 2
a2975 2
    if (LYIsHtmlSep(*cp)) {
	HTSprintf0(&temp, "file://localhost%s%04x", cp, GETPID());
d2977 1
a2977 1
	HTSprintf0(&temp, "file://localhost/%s%04x", cp, GETPID());
d2980 2
a2981 2
    if (LYIsHtmlSep(*cp)) {
	HTSprintf0(&temp, "file://localhost%s%d", cp, (int)getpid());
d2983 1
a2983 1
	HTSprintf0(&temp, "file://localhost/%s%d", cp, (int)getpid());
d2990 1
a2990 1
	StrAllocCopy(temp, (cp ? cp : ""));
d2996 6
a3001 6
    /*
     *  Hmm... we have a directory name.
     *  It is annoying to see a scheme+host+path name as a suggested one,
     *  let's remove the last_slash and go ahead like we have a file name. - LP
     */
    fname[strlen(fname) - 1] = '\0';
a3255 15
#if defined(USE_MKSTEMP) && defined(HAVE_MKSTEMP)
    int fd;
    char interim[LY_MAXPATH];
    sprintf(interim, "%.*sXXXXXX", LY_MAXPATH - 8, prefix);
    if (strlen(interim) + strlen(suffix) < LY_MAXPATH - 2
    && (fd = mkstemp(interim)) >= 0) {
	sprintf(result, "%s%s", interim, suffix);
	rename(interim, result);
	chmod(result, HIDE_CHMOD); /* (yes, some mkstemps are broken ;-) */
	close(fd);
	code = TRUE;
    } else {
	code = FALSE;
    }
#else
a3341 1
#endif
d3603 1
a3603 1
	    printf("%s: %.*s", gettext("unknown restriction"), p-word, word);
d3750 1
a3750 1
	mf = getenv("MAIL");
d3789 1
a3789 1
**  an 'g'oto entries, after they have been
d3791 2
d3801 1
a3801 1
    if (!(*href && *(*href)))
d3804 5
d3812 1
a3812 1
    if (!strcasecomp(*href, "news:")) {
d3814 1
a3814 2
    } else if (!strcasecomp(*href, "nntp:") ||
	       !strcasecomp(*href, "snews:")) {
d3817 1
d3820 1
a3820 1
		    (name ? name : ""), (name ? " " : ""), *href));
d3823 3
a3825 1
    if ((temp = HTParse(*href, "", PARSE_ALL)) != NULL && *temp != '\0')
d3850 1
a3850 1
#if defined(DOSPATH) || defined(__EMX__)
d3852 7
a3858 6
	 char *cp_url = *AllocatedString;
	 for(; *cp_url != '\0'; cp_url++)
		if(*cp_url == '\\') *cp_url = '/';
	 cp_url--;
	 if(*cp_url == ':')
		 StrAllocCat(*AllocatedString,"/");
d3860 1
a3860 1
#endif /* DOSPATH */
d3867 1
a3867 1
#if defined(DOSPATH) || defined(__EMX__)
d3869 1
a3869 1
#endif /* DOSPATH */
d3899 1
a3899 2
	    if ((fragment = strchr(old_string, '#')) != NULL)
		*fragment = '\0';
d3917 1
a3917 1
		*fragment = '#';
d3927 1
a3927 3
	    if (fragment != NULL) {
		*fragment = '#';
	    }
d3979 3
a3981 4
	    if (fragment != NULL) {
		*fragment = '#';
		fragment = NULL;
	    }
d4015 1
a4015 1
#if defined(DOSPATH)
d4048 1
a4048 1
#endif /* DOSPATH */
d4079 1
a4079 1
#if defined (DOSPATH) || defined (__EMX__) || defined (WIN_EX)
d4092 2
a4093 2
		if (strlen(temp) == 2 && temp[1] == ':')
		    StrAllocCat(temp, "/");
d4099 1
a4099 1
#endif /* DOSPATH */
d4107 1
a4107 1
#if defined (DOSPATH) || defined (__EMX__)
d4118 1
a4118 1
#endif /* DOSPATH */
d4129 1
a4129 2
		if ((fragment = strchr(cp, '#')) != NULL)
		    *fragment = '\0';	/* keep as pointer into cp string */
d4159 1
a4159 1
			    *fragment = '#';
d4189 1
a4189 1
			    *fragment = '#';
d4207 2
a4208 1
		    char *p, *q, buff[LY_MAXPATH + 128];
d4210 1
a4210 1
		    p = (char *)Home_Dir();
d4213 1
a4213 1
		    if (strlen(q) == 3 && isalpha(UCH(q[0])) && q[1] == ':') {
d4322 1
a4322 1
	c = wgetch(LYwin);
d4340 1
a4340 1
		c = wgetch(LYwin);
a4383 5
#ifdef _WINDOWS
    int hoststat;
    struct hostent  *phost;	/* Pointer to host - See netdb.h */
#endif

d4416 1
a4416 1
    } else if ((Fragment = strchr(Str, '#')) != NULL) {
d4422 1
a4422 1
	*Fragment = '\0';
d4484 1
a4484 7
    else if (LYCursesON &&
#if defined(__DJGPP__) && !defined(WATT32)
	HTCheckForInterrupt()
#else /* normal systems */
	(lynx_nsl_status == HT_INTERRUPTED)
#endif
	)
a4588 3
#if defined(__DJGPP__) && !defined(WATT32)
		if (LYCursesON && HTCheckForInterrupt())
#else /* normal systems */
a4589 1
#endif
d4648 1
a4648 1
	    *Fragment = '#';
d4766 1
a4766 1
    } else if (default_scheme != NULL && *default_scheme != '\0') {
d4928 1
a4928 1
#if HAVE_GETCWD
d4938 62
d5006 1
a5006 9
	if ((cp = getenv_text("HOME")) == NULL
	 || !LYisAbsPath(cp)) {
#if defined (DOSPATH) || defined (__EMX__) /* BAD!	WSB */
	    if ((cp = getenv_text("TEMP")) == NULL
	     && (cp = getenv_text("TMP")) == NULL) {
		cp = "C:\\";
	    }
	    StrAllocCopy(HomeDir, cp);
#else
d5008 2
a5009 2
	    if ((cp = getenv_text("SYS$LOGIN")) == NULL
	     && (cp = getenv_text("SYS$SCRATCH")) == NULL) {
d5014 2
a5015 1
#if HAVE_UTMP
a5030 3
#ifdef UNIX
	    if (cp && *cp)
		HTAlwaysAlert(NULL, gettext("Ignoring invalid HOME"));
a5032 1
#endif /* DOSPATH */
a5033 8
#if defined(_WINDOWS) || defined(DOSPATH)
	    char *hp = getenv_text("HOMEDRIVE");
	    if (hp != 0
	     && (LYIsPathSep(*cp) || !LYisAbsPath(cp))) {
		StrAllocCopy(HomeDir, hp);
		StrAllocCat(HomeDir, cp);
	    } else
#endif
d5041 4
d5301 1
a5301 1
    if (!(home && *home))
d5361 24
d5413 1
a5413 1
    if (!(string && *string))
d5642 1
a5642 1
 *  No putenv on the next so we use this code instead!
d5737 11
a5747 1
#if defined(UNIX)
d5766 1
a5766 1
#if defined(HAVE_LSTAT) && !(defined(DOSPATH) || defined(__EMX__))
d5868 1
a5868 5
#else	/* !UNIX */
# ifndef VMS
#  define OpenHiddenFile(name, mode) fopen(name, mode)
# endif
#endif
d5916 1
a5916 1
#ifdef UNIX
d5960 4
d5999 1
a5999 2
#if 0
#if defined(UNIX) && defined(HAVE_MKTEMP)
d6019 2
a6020 3
	    StrAllocCat(lynx_temp_space, "XXXXXX");
	    if (mktemp(lynx_temp_space) == 0
	     || mkdir(lynx_temp_space, 0700) < 0) {
a6032 1
#endif
a6143 1
#ifdef UNIX
a6144 3
#else
	    is_ours = TRUE;	/* assume ok, if we get to here */
#endif
d6200 1
a6200 1
#if HAVE_TRUNCATE
d6333 1
a6333 1
    if (name != 0 && *name != 0) {
d6365 1
a6365 1
#ifdef UNIX
d6570 1
a6570 1
PUBLIC  char * wwwName ARGS1(
d6573 1
a6573 1
    char *cp = NULL;
d6575 1
a6575 1
#ifdef DOSPATH
d6581 1
a6581 1
    cp = (char *)pathname;
d6583 1
a6583 1
#endif /* DOSPATH */
d6599 2
a6600 1
    char *cp, *cp2;
d6604 1
a6604 1
     *  or an "nl:" path (case-insensitive) on VMS. - FM
d6606 1
a6606 6
#ifdef VMS
    if (!strncasecomp(given, "nl:", 3) ||
	!strncasecomp(given, "/nl/", 4))
#else
    if (!strcmp(given, "/dev/null"))
#endif /* VMS */
d6611 1
a6611 1
#if HAVE_POPEN
d6700 1
a6700 1
#if HAVE_POPEN
d6738 1
a6738 1
    char *leaf;
d6747 2
d6756 22
d6783 2
d6822 9
a6845 6
#ifdef DOSPATH
#define PATHSEP_STR "\\"
#else
#define PATHSEP_STR "/"
#endif

d6847 1
a6847 1
 * Add a trailing path-separator to avoid confusing other programs when we concateate
d6888 1
a6888 1
#ifdef DOSPATH
d6955 1
d6957 2
a6958 1
#if defined(DOSPATH) || defined(__CYGWIN__) /* thanks to Hiroyuki Senshu */
d6960 9
a6968 1
#define BUF_SIZE	1024
d6970 16
a6985 13
    FILE *fin, *fout;
    unsigned char buff[BUF_SIZE];
    int len;

    code = EOF;
    if ((fin = fopen(src, BIN_R)) != 0) {
	if ((fout = fopen(dst, BIN_W)) != 0) {
	    code = 0;
	    while ((len = fread(buff, 1, BUF_SIZE, fin)) > 0) {
		fwrite(buff, 1, len, fout);
		if (ferror(fout)) {
		    code = EOF;
		    break;
d6987 1
d6989 1
a6989 1
	    LYCloseOutput(fout);
a6990 1
	LYCloseInput(fin);
a6991 15
#else
    char *the_command = 0;

    HTAddParam(&the_command, COPY_COMMAND, 1, COPY_PATH);
    HTAddParam(&the_command, COPY_COMMAND, 2, src);
    HTAddParam(&the_command, COPY_COMMAND, 3, dst);
    HTEndParam(&the_command, COPY_COMMAND, 3);

    CTRACE((tfp, "command: %s\n", the_command));
    stop_curses();
    code = LYSystem(the_command);
    start_curses();

    FREE(the_command);
#endif
d6999 27
d7034 1
a7034 1
#if HAVE_SIGACTION && defined(SIGTSTP) && !defined(USE_SLANG)
d7082 5
d7137 12
a7148 1
#if _WIN_CC
d7150 2
a7151 1
#else
d7154 2
a7155 1
#if HAVE_SIGACTION && defined(SIGTSTP) && !defined(USE_SLANG)
d7161 1
a7161 1
#if HAVE_SIGACTION && defined(SIGTSTP) && !defined(USE_SLANG)
d7165 1
d7170 1
d7212 1
a7212 1
    shell = getenv_text("COMSPEC");
d7224 1
a7224 1
	    printf("shell = [%s], code = %d\n", shell, GetLastError());
d7241 1
a7241 1
    shell = getenv_text("SHELL");
d7244 1
a7244 1
	    shell = getenv_text("COMSPEC");
d7253 1
a7253 1
    shell = getenv_text("SHELL");
d7255 1
a7255 1
	shell = getenv_text("COMSPEC");
d7263 2
a7264 2
    if (getenv_text("SHELL") != NULL) {
	shell = getenv_text("SHELL");
d7266 1
a7266 1
	shell = (getenv_text("COMSPEC") == NULL) ? "cmd.exe" : getenv_text("COMSPEC");
d7290 1
a7290 4
    char *cp;
    if ((cp = getenv_text(DISPLAY)) == NULL)
	cp = 0;
    return cp;
d7316 1
d7321 2
a7322 2
HAB hab;
HMQ hmq;
d7354 1
a7354 1
/* Code partialy stolen from FED editor. */
d7440 82
a7521 1
#endif
a7524 2
#define	MAX_DOS_PATH	128	/* exactly 80 */

d7611 2
a7612 23


PUBLIC char *HTDOS_short_name(char *path)
{
    static char sbuf[MAX_DOS_PATH];
    char *ret;
    DWORD r;

    r = GetShortPathName(path, sbuf, sizeof sbuf);
    if (r >= sizeof sbuf) {
#if 0	/* DEBUG */
	fprintf(stderr, "bug: recompile with MAX_DOS_PATH > %d\n", r);
#endif
	ret = path;
    }
    if (r == 0) {
	ret = path;
    } else {
	ret = sbuf;
    }
    return ret;
}
#endif
d7690 1
a7690 1
#if defined(WATT32)
d7744 1
a7744 1
	    syslog (LOG_INFO|LOG_LOCAL5, buf);
a7759 1

@


1.3
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@a8 1
#include <LYUtils.h>
d11 1
d17 1
d21 19
d44 9
d64 1
a67 1
#ifdef    UTMPX_FILE
d70 1
d72 3
d124 16
a141 1
extern HTkcode kanji_code;
a142 1
extern HTCJKlang HTCJK;
d149 46
d205 1
a205 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d212 1
d214 2
a215 1
    BOOL utf_flag = (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8);
d230 4
d240 16
d257 5
a261 3
#ifdef USE_COLOR_STYLE
#define LXP (links[cur].lx)
#define LYP (links[cur].ly)
d263 6
a268 8
	move(links[cur].ly, links[cur].lx);
#ifndef USE_COLOR_STYLE
	lynx_start_link_color (flag == ON, links[cur].inUnderline);
#else
	if (flag == ON) {
	    LynxChangeStyle(s_alink, STACK_ON, 0);
	} else {
	    int s, x;
d278 3
d289 2
d294 2
a295 1
		    if (s == 0)
d297 3
d302 1
d305 2
a306 1
	    LynxChangeStyle(s, STACK_ON, 0);
d308 2
d323 1
a323 1
	    addstr(buffer);
d327 1
a327 1
		addch('_');
d334 1
d337 1
a337 1
	    {
d342 7
a348 7
	    LYmbcsstrncpy(buffer,
			  (links[cur].hightext ?
			   links[cur].hightext : ""),
			  (sizeof(buffer) - 1),
			  ((LYcols - 1) - links[cur].lx),
			  utf_flag);
	    addstr(buffer);
d361 1
a361 1
	    move((links[cur].ly + 1), links[cur].hightext2_offset);
d365 5
a369 1
	    LynxChangeStyle(flag == ON ? s_alink : s_a, ABS_ON, 0);
d380 1
a380 1
			addstr(tmp);
d383 1
a383 1
			addstr(tmp);
d393 2
a394 1
#if defined(FANCY_CURSES) || defined(USE_SLANG)
d437 1
a437 1
		  LYmbcsstrlen(buffer, utf_flag) : hlen);
d456 5
a460 11
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
d487 1
a487 1
		move(hLine, offset);
d523 1
a523 1
			addstr(tmp);
d525 1
a525 1
			move(hLine, (offset + 1));
d542 1
a542 1
			addstr(tmp);
d544 1
a544 1
			move(hLine, (offset + 1));
d556 1
a556 1
			addstr(tmp);
d558 1
a558 1
			move(hLine, (offset + 1));
d622 1
a622 1
			    move(hLine, (offset + 1));
d624 1
a624 1
			    addstr(tmp);
d643 1
a643 1
			    move(hLine, (offset + 1));
d645 1
a645 1
			    addstr(tmp);
d659 1
a659 1
			    move(hLine, (offset + 1));
d661 1
a661 1
			    addstr(tmp);
d698 5
a702 11
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
d743 1
a743 1
		refresh();
d757 1
a757 1
	    move(hLine, offset);
d796 1
a796 1
		    addstr(tmp);
d798 1
a798 1
		    move(hLine, (offset + 1));
d818 1
a818 1
		    addstr(tmp);
d820 1
a820 1
		    move(hLine, (offset + 1));
d835 1
a835 1
		    addstr(tmp);
d837 1
a837 1
		    move(hLine, (offset + 1));
d898 1
a898 1
			move(hLine, (offset + 1));
d900 1
a900 1
			addstr(tmp);
d919 1
a919 1
			move(hLine, (offset + 1));
d921 1
a921 1
			addstr(tmp);
d935 1
a935 1
			move(hLine, (offset + 1));
d937 1
a937 1
			addstr(tmp);
d971 5
a975 11
	    if ((case_sensitive ?
		 (cp = LYno_attr_mbcs_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL :
		 (cp = LYno_attr_mbcs_case_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL) &&
d1000 1
a1000 1
			refresh();
d1005 1
a1005 1
		    move(hLine, offset);
d1060 1
a1060 1
				move(hLine, (offset + 1));
d1062 1
a1062 1
				addstr(tmp);
d1081 1
a1081 1
				addstr(tmp);
d1095 1
a1095 1
				addstr(tmp);
d1149 1
a1149 1
		  LYmbcsstrlen(buffer, utf_flag) : hlen);
d1168 5
a1172 11
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
d1199 1
a1199 1
		move(hLine, offset);
d1235 1
a1235 1
			addstr(tmp);
d1237 1
a1237 1
			move(hLine, (offset + 1));
d1254 1
a1254 1
			addstr(tmp);
d1256 1
a1256 1
			move(hLine, (offset + 1));
d1268 1
a1268 1
			addstr(tmp);
d1270 1
a1270 1
			move(hLine, (offset + 1));
d1334 1
a1334 1
			    move(hLine, (offset + 1));
d1336 1
a1336 1
			    addstr(tmp);
d1355 1
a1355 1
			    move(hLine, (offset + 1));
d1357 1
a1357 1
			    addstr(tmp);
d1371 1
a1371 1
			    move(hLine, (offset + 1));
d1373 1
a1373 1
			    addstr(tmp);
d1409 5
a1413 11
		if ((case_sensitive ?
		     (cp = LYno_attr_mbcs_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL :
		     (cp = LYno_attr_mbcs_case_strstr(data,
						 target,
						 utf_flag,
						 &HitOffset,
						 &LenNeeded)) != NULL) &&
d1454 1
a1454 1
		refresh();
d1468 1
a1468 1
	    move(hLine, offset);
d1507 1
a1507 1
		    addstr(tmp);
d1509 1
a1509 1
		    move(hLine, (offset + 1));
d1529 1
a1529 1
		    addstr(tmp);
d1531 1
a1531 1
		    move(hLine, (offset + 1));
d1546 1
a1546 1
		    addstr(tmp);
d1548 1
a1548 1
		    move(hLine, (offset + 1));
d1609 1
a1609 1
			move(hLine, (offset + 1));
d1611 1
a1611 1
			addstr(tmp);
d1630 1
a1630 1
			move(hLine, (offset + 1));
d1632 1
a1632 1
			addstr(tmp);
d1646 1
a1646 1
			move(hLine, (offset + 1));
d1648 1
a1648 1
			addstr(tmp);
d1682 5
a1686 11
	    if ((case_sensitive ?
		 (cp = LYno_attr_mbcs_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL :
		 (cp = LYno_attr_mbcs_case_strstr(data,
					     target,
					     utf_flag,
					     &HitOffset,
					     &LenNeeded)) != NULL) &&
d1711 1
a1711 1
			refresh();
d1716 1
a1716 1
		    move(hLine, offset);
d1771 1
a1771 1
				move(hLine, (offset + 1));
d1773 1
a1773 1
				addstr(tmp);
d1792 1
a1792 1
				addstr(tmp);
d1806 1
a1806 1
				addstr(tmp);
d1836 1
a1836 1
	    move((LYlines - 1), (LYcols - 1));
d1838 1
a1838 1
#endif /* FANCY CURSES || USE_SLANG */
d1842 1
a1842 1
	    move(links[cur].ly,
d1846 1
a1846 1
	    refresh();
d1933 1
a1933 1
    char buffer[256];
d1937 2
d1959 6
d1972 1
a1972 1
    if ((text[0] != '\0') &&
d1977 1
a1977 1
	if ((temp = (unsigned char *)calloc(1, strlen(text) + 1)) == NULL)
d1980 1
a1980 1
	    TO_EUC((CONST unsigned char *)text, temp);
d1982 8
a1989 1
	    TO_SJIS((CONST unsigned char *)text, temp);
d1991 3
a1993 3
	    for (i = 0, j = 0; text[i]; i++) {
		if (text[i] != CH_ESC) {  /* S/390 -- gil -- 2119 */
		    temp[j++] = text[i];
d2034 3
a2036 3
	for (i = 0, len = 0; text[i] != '\0' && len < max_length; i++) {
	    if (text[i] != CH_ESC) {  /* S/390 -- gil -- 2136 */
		buffer[len++] = text[i];
d2052 1
a2052 1
	    move(LYStatusLine, 0);
d2054 1
a2054 1
	    move(LYlines-1, 0);
d2057 1
a2057 1
	move(LYlines-3, 0);
d2059 1
a2059 1
	move(LYlines-1, 0);
d2061 2
a2062 1
    clrtoeol();
d2064 12
d2077 4
a2080 2
	if (LYCharSet_UC[current_char_set].enc == UCT_ENC_UTF8) {
	    refresh();
d2082 1
a2082 1
#endif /* HAVE_UTF8_STATUSLINES */
d2085 1
a2085 1
	addstr (buffer);
d2092 3
a2094 3
		LynxChangeStyle (a, STACK_ON, 1);
		addstr(buffer);
		wbkgdset(stdscr,
d2098 1
a2098 1
		clrtoeol();
d2100 1
a2100 1
		    wbkgdset(stdscr, A_NORMAL | ' ');
d2102 1
a2102 1
		    wbkgdset(stdscr, hashStyles[s_normal].color | ' ');
d2104 2
a2105 2
		    wbkgdset(stdscr, displayStyles[DSTYLE_NORMAL].color | ' ');
		LynxChangeStyle (a, STACK_OFF, 0);
d2109 1
a2109 1
    refresh();
d2146 1
a2146 1
    move(LYlines-2,0);
d2148 3
a2150 4
    clrtoeol();
    addstr(NOVICE_LINE_ONE);
    clrtoeol();

d2153 1
a2153 1
       addstr(DIRED_NOVICELINE);
d2158 1
a2158 1
	addstr(NOVICE_LINE_TWO);
d2160 1
a2160 1
	addstr((char *)novice_lines(lineno));
d2162 1
a2162 1
    refresh();
d2166 1
a2166 1
#ifdef NSL_FORK
d2181 1
a2181 1
#if SLANG_VERSION >= 9919
d2201 1
a2201 1
#endif /* NSL_FORK */
d2209 1
a2209 1
	CTRACE(tfp, "\r *** Set simulated 'Z'");
d2211 2
a2212 2
	    CTRACE(tfp, ", %d pending", fake_zap);
	CTRACE(tfp, " ***\n");
d2215 3
a2217 3
	CTRACE(tfp, "\r *** Unset simulated 'Z'");
	CTRACE(tfp, ", %d pending", fake_zap);
	CTRACE(tfp, " ***\n");
d2232 7
d2244 1
d2263 1
d2265 1
a2265 1
#ifndef USE_SLANG
d2273 1
a2273 1
	CTRACE(tfp, "\r *** Got simulated 'Z' ***\n");
d2283 1
d2312 1
a2312 1
    if ((ret == -1) && (errno == EINTR))
d2319 1
d2321 2
a2322 2
#if defined (DOSPATH) && defined (NCURSES)
    nodelay(stdscr,TRUE);
d2328 2
a2329 2
#if defined (DOSPATH) && defined (NCURSES)
    nodelay(stdscr,FALSE);
d2337 1
a2337 1
	CTRACE(tfp, "\r *** Got simulated 'Z' ***\n");
d2365 1
a2365 1
    if (TOUPPER(c) == 'Z' || c == 7 || c == 3)
d2369 3
a2371 2
	** no new getfile() cyrcle possible until the previous finished.
	** Currently we have scrolling in partial mode and toggling of trace log.
d2373 2
a2374 1
    switch (keymap[c+1])
d2376 3
a2378 5
    case LYK_TRACE_TOGGLE :	       /*  Toggle TRACE mode. */
	WWW_TraceFlag = ! WWW_TraceFlag;
	if (LYOpenTraceLog())
	    HTUserMsg(WWW_TraceFlag ? TRACE_ON : TRACE_OFF);
	break ;
d2385 1
d2387 3
a2389 1
	    switch (keymap[c+1])
d2391 10
d2469 1
a2469 1
	    HText_pageDisplay(Newline_partial, "");
d2479 39
d2544 1
a2544 1
	     0==strcasecomp(host, HTHostName())))
d2546 1
a2546 1
	     0==strcmp(host, HTHostName())))
d2548 1
d2626 1
a2626 1
    char *LocalAlias;
d2638 1
a2638 3
    if ((LocalAlias = (char *)calloc(1, (strlen(alias) + 1))) == NULL)
	outofmem(__FILE__, "HTAddLocalhosAlias");
    strcpy(LocalAlias, alias);
d2732 2
a2733 2
	} else if (isdigit((unsigned char)*cp1)) {
	    while (*cp1 && isdigit((unsigned char)*cp1))
d2846 5
d2943 1
a2943 1
	(void)is_url(&cp[11]);
d3020 65
d3100 2
a3101 2
    FREE(temp0);
    if (!isurl)
d3103 1
d3105 1
d3112 5
d3121 1
d3125 2
a3126 1
	if (cp && isdigit(cp[1]) && strchr(cp, '-') == NULL) {
d3132 88
a3245 4
#if HAVE_UTMP
extern char *ttyname PARAMS((int fd));
#endif

d3253 1
a3253 3
#if ! HAVE_UTMP
    return(TRUE);
#else
d3259 1
a3259 1
    if ((cp=ttyname(0)))
d3262 12
a3273 12
    if (mytty && (fp=fopen(UTMP_FILE, "r")) != NULL) {
	    mytty++;
	    do {
		n = fread((char *) &me, sizeof(struct utmp), 1, fp);
	    } while (n>0 && !STREQ(me.ut_line,mytty));
	    (void) fclose(fp);

	    if (n > 0 &&
		strlen(me.ut_host) > strlen(LYLocalDomain) &&
		STREQ(LYLocalDomain,
		  me.ut_host+strlen(me.ut_host)-strlen(LYLocalDomain)) )
		return(TRUE);
d3276 2
a3277 2
	    if ((n > 0) && (strlen(me.ut_host) == 0))
		return(TRUE);
d3281 1
a3281 1
	CTRACE(tfp,"Could not get ttyname or open UTMP file %s\n", UTMP_FILE);
d3285 79
a3363 1
#endif /* !HAVE_UTMP */
d3365 2
d3406 7
a3412 1
    SLtt_Screen_Cols = (LYcols * 6);
d3452 10
d3463 1
a3463 1
	LYlines = 24;
d3465 1
a3465 1
	LYcols = 80;
d3473 7
a3479 2
	CTRACE(tfp, "Window size changed from (%d,%d) to (%d,%d)\n",
		old_lines, old_cols, LYlines, LYcols);
d3482 1
a3482 1
    (void)signal (SIGWINCH, size_change);
d3514 1
a3514 1
    char *new;
d3521 1
a3521 3
    if ((new = (char *)calloc(1, (strlen(fname) + 1))) == NULL)
	outofmem(__FILE__, "HTAddSugFilename");
    strcpy(new, fname);
d3552 1
a3552 1
    char *temp, *cp, *cp1, *end;
a3570 3
    temp = (char *)calloc(1, (strlen(lynx_temp_space) + 60));
    if (temp == NULL)
	outofmem(__FILE__, "change_sug_filename");
d3572 7
d3580 1
a3580 1
	sprintf(temp, "file://localhost%s%d", cp, (int)getpid());
d3582 1
a3582 1
	sprintf(temp, "file://localhost/%s%d", cp, (int)getpid());
d3584 1
d3589 2
a3590 3
	strcpy(temp, (cp ? cp : ""));
	strcpy(fname, "temp");
	strcat(fname, temp);
d3616 13
d3674 1
a3674 1
		   *cp <  ' ' || ((unsigned char)*cp) > 126) {
d3854 23
a3878 1
    int code;
d3884 34
d3919 2
d3928 3
d3932 1
d3939 2
a3940 1
	leaf[8 - (tail - suffix)] = 0;
d3956 2
a3957 1
    CTRACE(tfp, "-> '%s'\n", result);
d4004 39
a4042 24
PRIVATE CONST char *restrict_name[] = {
       "inside_telnet" ,
       "outside_telnet",
       "telnet_port"   ,
       "inside_ftp"    ,
       "outside_ftp"   ,
       "inside_rlogin" ,
       "outside_rlogin",
       "suspend"       ,
       "editor"        ,
       "shell"	       ,
       "bookmark"      ,
       "multibook"     ,
       "bookmark_exec" ,
       "option_save"   ,
       "print"	       ,
       "download"      ,
       "disk_save"     ,
       "exec"	       ,
       "lynxcgi"       ,
       "exec_frozen"   ,
       "goto"	       ,
       "jump"	       ,
       "file_url"      ,
d4044 10
a4053 7
       "news_post"     ,
       "inside_news"   ,
       "outside_news"  ,
#endif
       "mail"	       ,
       "dotfiles"      ,
       "useragent"     ,
d4055 1
a4055 1
       "dired_support" ,
d4057 1
a4057 1
       "change_exec_perms",
d4061 7
a4067 1
       "externals" ,
a4068 46
       (char *) 0     };

	/* restrict_name and restrict_flag structure order
	 * must be maintained exactly!
	 */

PRIVATE BOOLEAN *restrict_flag[] = {
       &no_inside_telnet,
       &no_outside_telnet,
       &no_telnet_port,
       &no_inside_ftp,
       &no_outside_ftp,
       &no_inside_rlogin,
       &no_outside_rlogin,
       &no_suspend  ,
       &no_editor   ,
       &no_shell    ,
       &no_bookmark ,
       &no_multibook ,
       &no_bookmark_exec,
       &no_option_save,
       &no_print    ,
       &no_download ,
       &no_disk_save,
       &no_exec     ,
       &no_lynxcgi  ,
       &exec_frozen ,
       &no_goto     ,
       &no_jump     ,
       &no_file_url ,
#ifndef DISABLE_NEWS
       &no_newspost ,
       &no_inside_news,
       &no_outside_news,
#endif
       &no_mail     ,
       &no_dotfiles ,
       &no_useragent ,
#ifdef DIRED_SUPPORT
       &no_dired_support,
#ifdef OK_PERMIT
       &no_change_exec_perms,
#endif /* OK_PERMIT */
#endif /* DIRED_SUPPORT */
#ifdef USE_EXTERNALS
       &no_externals ,
d4070 8
a4077 27
       (BOOLEAN *) 0  };

PUBLIC void parse_restrictions ARGS1(
	CONST char *,	s)
{
      CONST char *p;
      CONST char *word;
      int i;

      if (STREQ("all", s)) {
	   /* set all restrictions */
	  for (i=0; restrict_flag[i]; i++)
	      *restrict_flag[i] = TRUE;
	  return;
      }

      if (STREQ("default", s)) {
	   /* set all restrictions */
	  for (i=0; restrict_flag[i]; i++)
	      *restrict_flag[i] = TRUE;

	     /* reset these to defaults */
	     no_inside_telnet = !(CAN_ANONYMOUS_INSIDE_DOMAIN_TELNET);
	    no_outside_telnet = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_TELNET);
#ifndef DISABLE_NEWS
	       no_inside_news = !(CAN_ANONYMOUS_INSIDE_DOMAIN_READ_NEWS);
	      no_outside_news = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_READ_NEWS);
d4079 2
a4080 7
		no_inside_ftp = !(CAN_ANONYMOUS_INSIDE_DOMAIN_FTP);
	       no_outside_ftp = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_FTP);
	     no_inside_rlogin = !(CAN_ANONYMOUS_INSIDE_DOMAIN_RLOGIN);
	    no_outside_rlogin = !(CAN_ANONYMOUS_OUTSIDE_DOMAIN_RLOGIN);
		      no_goto = !(CAN_ANONYMOUS_GOTO);
		  no_goto_cso = !(CAN_ANONYMOUS_GOTO_CSO);
		 no_goto_file = !(CAN_ANONYMOUS_GOTO_FILE);
d4082 1
a4082 1
	       no_goto_finger = !(CAN_ANONYMOUS_GOTO_FINGER);
d4084 1
a4084 1
		  no_goto_ftp = !(CAN_ANONYMOUS_GOTO_FTP);
d4086 1
a4086 1
	       no_goto_gopher = !(CAN_ANONYMOUS_GOTO_GOPHER);
d4088 6
a4093 6
		 no_goto_http = !(CAN_ANONYMOUS_GOTO_HTTP);
		no_goto_https = !(CAN_ANONYMOUS_GOTO_HTTPS);
	      no_goto_lynxcgi = !(CAN_ANONYMOUS_GOTO_LYNXCGI);
	     no_goto_lynxexec = !(CAN_ANONYMOUS_GOTO_LYNXEXEC);
	     no_goto_lynxprog = !(CAN_ANONYMOUS_GOTO_LYNXPROG);
	       no_goto_mailto = !(CAN_ANONYMOUS_GOTO_MAILTO);
d4095 2
a4096 2
		 no_goto_news = !(CAN_ANONYMOUS_GOTO_NEWS);
		 no_goto_nntp = !(CAN_ANONYMOUS_GOTO_NNTP);
d4098 1
a4098 1
	       no_goto_rlogin = !(CAN_ANONYMOUS_GOTO_RLOGIN);
d4100 134
a4233 1
		no_goto_snews = !(CAN_ANONYMOUS_GOTO_SNEWS);
d4235 28
a4262 32
	       no_goto_telnet = !(CAN_ANONYMOUS_GOTO_TELNET);
	       no_goto_tn3270 = !(CAN_ANONYMOUS_GOTO_TN3270);
		 no_goto_wais = !(CAN_ANONYMOUS_GOTO_WAIS);
	       no_telnet_port = !(CAN_ANONYMOUS_GOTO_TELNET_PORT);
		      no_jump = !(CAN_ANONYMOUS_JUMP);
		      no_mail = !(CAN_ANONYMOUS_MAIL);
		     no_print = !(CAN_ANONYMOUS_PRINT);
#if defined(EXEC_LINKS) || defined(EXEC_SCRIPTS)
		      no_exec = LOCAL_EXECUTION_LINKS_ALWAYS_OFF_FOR_ANONYMOUS;
#endif /* EXEC_LINKS || EXEC_SCRIPTS */
	  return;
      }

      p = s;
      while (*p) {
	  p = LYSkipCBlanks(p);
	  if (*p == '\0')
	      break;
	  word = p;
	  while (*p != ',' && *p != '\0')
	      p++;

	  for (i=0; restrict_name[i]; i++) {
	     if (STRNEQ(word, restrict_name[i], p-word)) {
		 *restrict_flag[i] = TRUE;
		 break;
	     }
	  }
	  if (*p)
	      p++;
      }
      return;
d4427 2
a4428 2
	CTRACE(tfp, "%s%s'%s' is not a URL\n",
		    (name ? name : ""), (name ? " " : ""), *href);
a4450 1
    FILE *fptemp = NULL;
d4468 1
a4468 1
    StrAllocCopy(*AllocatedString,"file://localhost");
d4490 1
a4490 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName((char *)Home_Dir()));
d4506 1
a4506 1
	    strcpy(url_file, old_string);
d4555 1
a4555 1
		     !isdigit((unsigned char)cp[1])) ||
d4564 3
a4566 4
		    strcpy(url_file, "/");
		    strcat(url_file, old_string);
		    CTRACE(tfp, "Can't find '%s'  Will assume it's a bad path.\n",
				old_string);
d4593 1
a4593 1
		 !isdigit((unsigned char)cp[1])) ||
d4602 3
a4604 4
		strcpy(url_file, "/");
		strcat(url_file, old_string);
		CTRACE(tfp, "Can't find '%s'  Will assume it's a bad path.\n",
			    old_string);
d4622 22
a4643 3
	CTRACE(tfp, "Trying: '%s'\n", *AllocatedString);
#else /* Unix: */
#ifdef DOSPATH
d4652 5
a4656 3
	    CTRACE(tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString);
	} else
d4662 1
a4662 1
	    StrAllocCat(*AllocatedString, Home_Dir());
d4674 2
a4675 2
	    CTRACE(tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString);
d4688 1
a4688 1
#if defined (DOSPATH) || defined (__EMX__)
d4696 3
d4700 3
d4710 1
a4710 1
	    CTRACE(tfp, "Converted '%s' to '%s'\n", old_string, temp);
d4712 1
a4712 1
		(fptemp = fopen(temp, "r")) != NULL) {
d4721 2
a4722 3
		if (strchr(temp, '#') == NULL &&
			   strchr(temp, '%') == NULL)
		StrAllocCopy(cp, temp);
d4724 3
a4727 1
		cp = HTEscape(temp, URL_PATH);
d4730 2
a4731 2
		CTRACE(tfp, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString);
d4744 3
d4750 1
a4750 1
		     (fptemp = fopen(temp2, "r")) != NULL)) {
d4774 2
a4775 2
		    CTRACE(tfp, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString);
d4813 20
a4832 2
		CTRACE(tfp, "Can't stat() or fopen() '%s'\n",
			    temp2 ? temp2 : temp);
d4835 2
a4836 1
				       URLDomainSuffixes)) {
d4846 3
d4850 4
a4853 1
		CTRACE(tfp, "Trying: '%s'\n", *AllocatedString);
a4856 4
	    if (fptemp) {
		fclose(fptemp);
		fptemp = NULL;
	    }
d4870 1
a4870 1
	    StrAllocCat(*AllocatedString, HTVMS_wwwName((char *)Home_Dir()));
d4874 1
a4874 1
		   (fptemp = fopen(old_string, "r")) != NULL) {
d4881 1
a4881 1
	    CTRACE(tfp, "Converted '%s' to '%s'\n", old_string, temp);
d4886 2
a4887 6
	    if (fptemp) {
		fclose(fptemp);
		fptemp = NULL;
	    }
	    CTRACE(tfp, "Converted '%s' to '%s'\n",
			old_string, *AllocatedString);
d4894 1
a4894 5
#ifdef VMS
	    StrAllocCat(*AllocatedString, HTVMS_wwwName((char *)Home_Dir()));
#else
	    StrAllocCat(*AllocatedString, Home_Dir());
#endif /* VMS */
d4916 2
a4917 2
	CTRACE(tfp, "Converted '%s' to '%s'\n",
		    old_string, *AllocatedString);
d4924 33
d4987 10
a4996 1
    BOOLEAN Startup = (helpfilepath == NULL);
d5046 1
a5046 1
	isdigit((unsigned char)StrColon[1])) {
d5066 1
a5066 1
	fprintf(stdout, "%s '%s'%s\n", WWW_FIND_MESSAGE, host, FIRST_SEGMENT);
d5068 9
a5076 1
#ifndef DJGPP
d5078 1
a5078 3
#else
    if (resolve(host) != 0)
#endif /* DJGPP */
d5084 3
a5086 2
	    CTRACE(tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
			host);
d5097 9
a5105 5
#ifndef DJGPP
    } else if (LYCursesON && (lynx_nsl_status == HT_INTERRUPTED)) {
#else /* DJGPP */
    } else if (LYCursesON && HTCheckForInterrupt()) {
#endif /* DJGPP */
d5109 3
a5111 2
	CTRACE(tfp, "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
		    host);
d5188 1
a5188 1
		isdigit((unsigned char)HostColon[1])) {
d5201 1
a5201 5
#ifndef DJGPP
	    GotHost = (LYGetHostByName(host) != NULL);
#else
	    GotHost = (resolve(host) != 0);
#endif /* DJGPP */
d5209 3
a5211 1
#ifndef DJGPP
d5213 1
a5213 3
#else /* DJGPP */
		if (LYCursesON && HTCheckForInterrupt())
#endif /* DJGPP */
d5215 3
a5217 2
		    CTRACE(tfp, "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
				host);
d5282 1
a5282 1
	CTRACE(tfp, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
d5284 1
a5284 1
		    (GotHost ? "resolved" : "timed out"));
d5427 1
a5427 1
    TerminalSlash = LYIsPathSep(path[(strlen(path) - 1)]);
d5568 2
a5569 5
	if ((cp = getenv("HOME")) == NULL || *cp == '\0'
#ifdef UNIX
	    || *cp != '/'
#endif /* UNIX */
	    ) {
d5571 3
a5573 8
	    if ((cp = getenv("TEMP")) == NULL || *cp == '\0') {
		if ((cp = getenv("TMP")) == NULL || *cp == '\0') {
		    StrAllocCopy(HomeDir, "C:\\");
		} else {
		    StrAllocCopy(HomeDir, cp);
		}
	    } else {
		StrAllocCopy(HomeDir, cp);
d5575 1
d5578 3
a5580 8
	    if ((cp = getenv("SYS$LOGIN")) == NULL || *cp == '\0') {
		if ((cp = getenv("SYS$SCRATCH")) == NULL || *cp == '\0') {
		    StrAllocCopy(HomeDir, "sys$scratch:");
		} else {
		    StrAllocCopy(HomeDir, cp);
		}
	    } else {
		StrAllocCopy(HomeDir, cp);
d5582 1
d5607 8
d5872 6
d5882 2
a5883 5
#ifdef VMS
	StrAllocCopy(home, "Error:");
#else
	StrAllocCopy(home, "/error");
#endif /* VMS */
d5910 2
a5911 5
	    char *temp = (char *)calloc(1,
					(strlen(home) + strlen(file) + 10));
	    if (temp == NULL)
		outofmem(__FILE__, "LYAddPathToHome");
	    sprintf(temp, "%s%s", HTVMS_wwwName(home), (file + 1));
d5969 1
a5969 1
    CTRACE(tfp, "LYmktime: Parsing '%s'\n", s);
d5975 1
a5975 1
    while (*s != '\0' && !isdigit((unsigned char)*s))
d5984 2
a5985 2
    while (*s != '\0' && isdigit((unsigned char)*s))
       s++;
d5996 1
a5996 1
    while (*s != '\0' && !isalnum((unsigned char)*s))
d6001 1
a6001 1
    while (*s != '\0' && isalnum((unsigned char)*s))
d6004 2
a6005 2
	(s - start) < (isdigit((unsigned char)*(s - 1)) ? 2 : 3) ||
	(s - start) > (isdigit((unsigned char)*(s - 1)) ? 2 : 9))
d6007 1
a6007 1
    LYstrncpy(temp, start, (isdigit((unsigned char)*(s - 1)) ? 2 : 3));
d6087 1
a6087 1
    while (*s != '\0' && !isdigit((unsigned char)*s))
d6092 1
a6092 1
    while (*s != '\0' && isdigit((unsigned char)*s))
d6121 1
a6121 1
    while (*s != '\0' && !isdigit((unsigned char)*s))
d6129 1
a6129 1
	while (*s != '\0' && isdigit((unsigned char)*s))
d6139 1
a6139 1
	while (*s != '\0' && !isdigit((unsigned char)*s))
d6144 1
a6144 1
	while (*s != '\0' && isdigit((unsigned char)*s))
d6154 1
a6154 1
	while (*s != '\0' && !isdigit((unsigned char)*s))
d6159 1
a6159 1
	while (*s != '\0' && isdigit((unsigned char)*s))
d6183 1
a6183 1
    if (absolute == FALSE && clock2 <= time(NULL))
d6186 1
a6186 1
	CTRACE(tfp, "LYmktime: clock=%ld, ctime=%s",
d6188 1
a6188 1
		    ctime(&clock2));
d6193 1
a6193 1
#if ! HAVE_PUTENV
d6290 1
a6290 1
#ifdef UNIX
d6305 5
a6309 1
#if HAVE_LSTAT
d6339 1
a6339 1
		     || data.st_mode & S_IWOTH) {
d6362 1
d6379 4
d6393 1
a6393 1
	    fp = OpenHiddenFile(name, "w");
d6411 1
a6411 1
#else
d6420 1
a6420 1
    FILE *fp = fopen (name, "wb", "mbc=32");
d6423 1
a6423 1
    FILE *fp = OpenHiddenFile(name, "wb");
d6433 1
a6433 1
    fp = fopen (name, "w", "shr=get");
d6438 1
a6438 1
    fp = OpenHiddenFile(name, "w");
d6451 1
a6451 1
    fp = fopen (name, "a+", "shr=get");
d6456 1
a6456 1
    fp = OpenHiddenFile(name, "a+");
a6495 2
    FILE *fp;

d6497 1
a6497 1
	strcpy(result, *cached);
d6499 1
a6499 2
	if ((fp = fopen(result, "r")) != NULL) {
	    fclose(fp);
a6507 12
 * Maintain a list of all of the temp-files we create so that we can remove
 * them during the cleanup.
 */
typedef struct _LYTemp {
    struct _LYTemp *next;
    char *name;
    FILE *file;
} LY_TEMP;

static LY_TEMP *ly_temp;

/*
d6520 1
a6520 1
    BOOL wrt = 'r';
d6523 1
a6523 1
    CTRACE(tfp, "LYOpenTemp(,%s,%s)\n", suffix, mode);
d6533 42
a6574 2
		CTRACE(tfp, "%s @@%d: BUG\n", __FILE__, __LINE__);
		return fp;
d6577 2
d6602 2
a6603 2
	    CTRACE(tfp, "... LYOpenTemp(%s) failed: %s\n",
		   result, LYStrerror(errno));
d6609 1
a6609 1
    if ((p = (LY_TEMP *)calloc(1, sizeof(LY_TEMP))) != 0) {
d6613 1
d6619 1
a6619 1
    CTRACE(tfp, "... LYOpenTemp(%s)\n", result);
d6633 151
a6783 3
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(p->name, name)) {
	    fp = p->file = LYAppendToTxtFile (name);
d6786 2
d6789 10
d6817 1
a6817 1
	if ((p = (LY_TEMP *)calloc(1, sizeof(LY_TEMP))) != 0) {
d6826 1
a6826 1
    CTRACE(tfp, "LYOpenScratch(%s)\n", result);
d6830 13
d6851 5
a6855 11
    CTRACE(tfp, "LYCloseTemp(%s)\n", name);
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(name, p->name)) {
	    CTRACE(tfp, "...LYCloseTemp(%s)%s\n", name,
		(p->file != 0) ? ", closed" : "");
	    if (p->file != 0) {
		fclose(p->file);
		p->file = 0;
	    }
	    break;
	}
d6867 4
a6870 8
    CTRACE(tfp, "LYCloseTempFP\n");
    for (p = ly_temp; p != 0; p = p->next) {
	if (p->file == fp) {
	    fclose(p->file);
	    p->file = 0;
	    CTRACE(tfp, "...LYCloseTempFP(%s)\n", p->name);
	    break;
	}
d6877 1
a6877 1
PUBLIC void LYRemoveTemp ARGS1(
d6881 1
a6881 1
    int code;
d6884 1
a6884 1
	CTRACE(tfp, "LYRemoveTemp(%s)\n", name);
d6892 1
a6892 2
		if (p->file != 0)
		    fclose(p->file);
d6894 2
a6895 2
		CTRACE(tfp, "...LYRemoveTemp done(%d)%s\n", code,
		       (p->file != 0) ? ", closed" : "");
d6903 1
d6915 10
d6936 174
a7109 5
    CTRACE(tfp, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname);
    for (p = ly_temp; p != 0; p = p->next) {
	if (!strcmp(oldname, p->name)) {
	    StrAllocCopy((p->name), newname);
	    break;
d7111 2
d7126 1
a7126 1
    cp = HTDOS_wwwName((char *)pathname);
d7129 1
a7129 1
    cp = HTVMS_wwwName((char *)pathname);
d7142 2
d7149 1
a7149 1
    char *cp;
d7171 1
a7171 1
	strcpy(result, given);
d7175 3
a7177 1
    if ((cp = strchr(given, '~'))) {
d7181 1
a7181 1
	strcat(result, wwwName(Home_Dir()));
d7190 3
a7192 1
    if (given[0] != '/' && strchr(given, ':') == NULL) {
d7203 1
a7203 1
    if (!LYIsPathSep(*given)) {
d7209 8
a7216 1
	cp = original_dir;
d7222 1
d7225 3
a7227 3
	sprintf(result, "%s/%s", cp, HTSYS_name(given));
    } else {
	strcpy(result, HTSYS_name(given));
d7229 4
a7248 1
    FILE *fp;
d7269 1
a7269 2
    if ((fp = fopen(filename, "r")) != NULL) {
	fclose(fp);
d7298 5
a7307 21
#ifdef NOTDEFINED
/* FIXME: this may be useful for pages that do not allow nested pages */
PUBLIC int LYOpenInternalPage ARGS2(
	FILE **,  fp0,
	char **, newfile)
{
    static char tempfile[LY_MAXPATH];

    LYRemoveTemp(tempfile);
    if ((*fp0 = LYOpenTemp(tempfile, HTML_SUFFIX, "w")) == NULL) {
	HTAlert(CANNOT_OPEN_TEMP);
	return(-1);
    }

    LYLocalFileToURL(newfile, tempfile);
    LYforce_no_cache = TRUE;  /* don't cache this doc */

    return(0);  /* OK */
}
#endif

d7333 1
a7333 1
     && LYwouldPush(Title)
d7372 1
a7372 1
 * Add a trailing path-separator to avoid confusing other programs when we concatenate
d7394 1
a7394 1
	char *,	path)
d7400 1
d7407 16
d7466 1
d7480 25
d7512 1
a7512 1
    CTRACE(tfp, "command: %s\n", the_command);
d7518 1
d7520 3
d7527 1
a7527 1
 * Invoke a shell command
d7534 8
d7545 1
a7545 1
    CTRACE(tfp, "LYSystem(%s)\n", command);
d7561 2
d7581 60
d7642 8
d7662 6
d7674 42
d7720 19
a7738 4
    if (getenv("SHELL") != NULL) {
	shell = getenv("SHELL");
    } else {
	shell = (getenv("COMSPEC") == NULL) ? "command.com" : getenv("COMSPEC");
d7740 1
d7743 2
a7744 2
    if (getenv("SHELL") != NULL) {
	shell = getenv("SHELL");
d7746 1
a7746 1
	shell = (getenv("COMSPEC") == NULL) ? "cmd.exe" : getenv("COMSPEC");
d7771 1
a7771 1
    if ((cp = getenv(DISPLAY)) == NULL || *cp == '\0')
d7783 1
a7783 1
    if (new_display != 0 && *new_display != '\0') {
a7788 3
	display_putenv_command = malloc(strlen(new_display) + 12);
	if (!display_putenv_command)
	    outofmem(__FILE__, "LYsetXDisplay");
d7790 1
a7790 1
	sprintf(display_putenv_command, "DISPLAY=%s", new_display);
d7798 387
@


1.2
log
@cheaper select() call
@
text
@d1 22
a22 14
#include "HTUtils.h"
#include "tcp.h"
#include <ctype.h>
#include "HTParse.h"
#include "HTAccess.h"
#include "HTCJK.h"
#include "HTAlert.h"
#include "LYCurses.h"
#include "LYUtils.h"
#include "LYStrings.h"
#include "LYGlobalDefs.h"
#include "LYSignal.h"
#include "GridText.h"
#include "LYCharSets.h"
a23 3
#ifdef DOSPATH
#include "HTDOS.h"
#endif
a27 1
#include "HTVMSUtils.h"
d38 1
d41 3
d48 1
a48 1
#if NEED_PTEM_H
d56 1
a56 1
#include "LYLeaks.h"
d59 3
a61 3
#include "AttrList.h"
#include "LYHash.h"
#include "LYStyle.h"
a63 2
#undef hline   /* FIXME: this is a curses feature used as a variable here */

d91 1
a91 1
#define FREE(x) if (x) {free(x); x = NULL;}
d107 1
a107 1
	char *, 	target)
d111 3
a113 1
    char tmp[7], *cp;
d119 1
d121 4
a124 1

d137 5
d151 1
a151 1
	    LynxChangeStyle(s_alink, ABS_ON, 0);
d153 26
a178 9
		/* the logic is flawed here - no provision is made for links that
		** aren't coloured as [s_a] by default - rjp
		*/
	    if (LYP >= 0 && LYP < CACHEH && LXP >= 0 && LXP < CACHEW &&
		cached_styles[LYP][LXP]) {
		LynxChangeStyle(cached_styles[LYP][LXP], ABS_ON, 0);
	    }
	    else {
		LynxChangeStyle(s_a, ABS_ON, 0);
d180 1
d183 2
d202 7
d220 1
d226 5
a230 1
	if (links[cur].hightext2 && links[cur].ly < display_lines) {
d255 3
d1761 1
a1761 1
	free(*pointer);
a1767 20
 *  Collapse (REMOVE) all spaces in the string.
 */
PUBLIC void collapse_spaces ARGS1(
	char *, 	string)
{
    int i=0;
    int j=0;

    if (!string)
	return;

    for (; string[i] != '\0'; i++)
	if (!isspace((unsigned char)string[i]))
	    string[j++] = string[i];

    string[j] = '\0';  /* terminate */
    return;
}

/*
d1775 1
a1775 1
	char *, 	string,
d1817 1
a1817 1
	char *, 	dirname)
d1864 2
a1865 1
    max_length = ((LYcols - 2) < 256) ? (LYcols - 2) : 255;
d1874 1
a1874 1
	    TO_EUC((unsigned char *)text, temp);
d1876 1
a1876 1
	    TO_SJIS((unsigned char *)text, temp);
d1879 1
a1879 1
		if (text[i] != '\033') {
d1922 1
a1922 1
	    if (text[i] != '\033') {
d1962 3
a1964 2
		int a=(strncmp(buffer, "Alert", 5) || !hashStyles[s_alert].name ? s_status : s_alert);
		LynxChangeStyle (a, ABS_ON, 1);
d1971 3
a1973 1
		if (s_normal != NOSTYLE)
d1976 2
a1977 5
		    wbkgdset(stdscr,
			     ((lynx_has_color && LYShowColor >= SHOW_COLOR_ON)
			      ? displayStyles[DSTYLE_NORMAL].color
			      : A_NORMAL) | ' ');
		LynxChangeStyle (a, ABS_OFF, 0);
d1986 15
a2000 11
static char *novice_lines[] = {
#ifndef NOVICE_LINE_TWO_A
#define NOVICE_LINE_TWO_A	NOVICE_LINE_TWO
#define NOVICE_LINE_TWO_B	""
#define NOVICE_LINE_TWO_C	""
#endif /* !NOVICE_LINE_TWO_A */
  NOVICE_LINE_TWO_A,
  NOVICE_LINE_TWO_B,
  NOVICE_LINE_TWO_C,
  ""
};
d2006 1
a2006 1
	if (*novice_lines[lineno] == '\0')
d2033 5
a2037 1
	addstr(novice_lines[lineno]);
d2039 25
a2063 16
#ifdef NOTDEFINED
    if (is_www_index && more_flag) {
	addstr("This is a searchable index.  Use ");
	addstr(key_for_func(LYK_INDEX_SEARCH));
	addstr(" to search:");
	stop_reverse();
	addstr("                ");
	start_reverse();
	addstr("space for more");

    } else if (is_www_index) {
	addstr("This is a searchable index.  Use ");
	addstr(key_for_func(LYK_INDEX_SEARCH));
	addstr(" to search:");
    } else {
	addstr("Type a command or ? for help:");
d2065 5
a2069 5
	if (more_flag) {
	    stop_reverse();
	    addstr("                       ");
	    start_reverse();
	    addstr("Press space for next page");
d2072 1
a2072 5

#endif /* NOTDEFINED */

    refresh();
    return;
d2074 1
d2082 4
a2085 6
	if (TRACE) {
	    fprintf(stderr, "\r *** Set simulated 'Z'");
	    if (fake_zap)
		fprintf(stderr, ", %d pending", fake_zap);
	    fprintf(stderr, " ***\n");
	}
d2088 3
a2090 5
	if (TRACE) {
	    fprintf(stderr, "\r *** Unset simulated 'Z'");
	    fprintf(stderr, ", %d pending", fake_zap);
	    fprintf(stderr, " ***\n");
	}
d2096 29
d2127 1
a2128 1
    int c;
d2137 3
a2139 6
	if (TRACE) {
	    fprintf(stderr, "\r *** Got simulated 'Z' ***\n");
	    fflush(stderr);
	    if (!LYTraceLogFP)
		sleep(AlertSecs);
	}
d2144 1
a2144 1
    if (dump_output_immediately)
d2152 3
d2156 1
a2182 1
    /** Keyboard 'Z' or 'z', or Control-G or Control-C **/
d2186 3
a2192 5
    if (TOUPPER(c) == 'Z' || c == 7 || c == 3)
	return((int)TRUE);

    /** Other keystrokes **/
    return((int)FALSE);
a2194 3

    int c;
    extern BOOLEAN HadVMSInterrupt;
d2199 3
a2201 6
	if (TRACE) {
	    fprintf(stderr, "\r *** Got simulated 'Z' ***\n");
	    fflush(stderr);
	    if (!LYTraceLogFP)
		sleep(AlertSecs);
	}
d2206 1
a2206 1
    if (dump_output_immediately)
d2215 3
a2217 1
    /** Keyboard 'Z' or 'z', or Control-G or Control-C **/
d2219 8
d2230 93
a2324 1
#endif /* !VMS */
d2332 1
a2332 1
	char *, 	filename)
d2375 1
a2375 1
	char *, 	filename)
d2395 1
a2395 1
	 0==strcasecomp(host, HTHostName()))) {
d2399 1
a2399 1
	 0==strcmp(host, HTHostName()))) {
d2401 1
d2433 1
a2433 1
	char *, 	alias)
d2442 1
d2444 1
d2460 1
a2460 1
	char *, 	filename)
d2481 1
a2481 1
	if (0==strcasecomp(host, alias)) {
d2483 1
a2483 1
	if (0==strcmp(host, alias)) {
d2485 1
d2501 2
a2502 2
**  precedes it is not being proxied, and we can rule
**  out that what follows the colon is not a port field,
d2507 1
a2507 1
	char *, 	filename)
d2517 1
a2517 1
	return(0);
d2520 1
a2520 2
    while (isspace((unsigned char)*cp))
	cp++;
d2536 4
d2541 3
a2543 1
	if (isdigit((unsigned char)*cp1)) {
d2546 1
a2546 1
	    if (*cp1 && *cp1 != '/')
d2548 2
d2553 21
a2573 1
    return(0);
d2579 1
a2579 1
**  analyis of the scheme field, ensures that
d2589 1
a2589 1
	char *, 	filename)
a2592 1
    int i;
d2609 1
a2609 2
    while (isspace((unsigned char)*cp))
	cp++;
d2615 2
a2616 1
     *	a colon later in the string. - KW
d2618 1
a2618 1
    if (*cp == '/')
d2621 1
a2621 11
#ifdef DOSPATH /* sorry! */
	if (strncmp(cp, "file:///", 8) && strlen(cp) == 19 &&
	    cp[strlen(cp)-1] == ':')
	    StrAllocCat(cp,"/");
#endif

    if (!strncasecomp(cp, "news:", 5)) {
	if (strncmp(cp, "news", 4)) {
	    for (i = 0; i < 4; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2624 1
a2624 5
    } else if (!strncasecomp(cp, "nntp:", 5)) {
	if (strncmp(cp, "nntp", 4)) {
	    for (i = 0; i < 4; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2627 1
a2627 5
    } else if (!strncasecomp(cp, "snews:", 6)) {
	if (strncmp(cp, "snews", 5)) {
	    for (i = 0; i < 5; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2630 1
a2630 1
    } else if (!strncasecomp(cp, "newspost:", 9)) {
a2633 4
	if (strncmp(cp, "newspost", 8)) {
	    for (i = 0; i < 8; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2636 1
a2636 1
    } else if (!strncasecomp(cp, "newsreply:", 10)) {
a2639 4
	if (strncmp(cp, "newsreply", 9)) {
	    for (i = 0; i < 9; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2642 1
a2642 1
    } else if (!strncasecomp(cp, "snewspost:", 10)) {
a2645 4
	if (strncmp(cp, "snewspost", 9)) {
	    for (i = 0; i < 9; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2648 1
a2648 1
    } else if (!strncasecomp(cp, "snewsreply:", 11)) {
a2651 4
	if (strncmp(cp, "snewsreply", 10)) {
	    for (i = 0; i < 10; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2654 1
a2654 5
    } else if (!strncasecomp(cp, "mailto:", 7)) {
	if (strncmp(cp, "mailto", 6)) {
	    for (i = 0; i < 6; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2657 1
a2657 5
    } else if (!strncasecomp(cp, "file:", 5)) {
	if (strncmp(cp, "file", 4)) {
	    for (i = 0; i < 4; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2660 1
a2660 1
	} else if (cp[5] == '/' && cp[6] == '/') {
d2666 1
a2666 5
    } else if (!strncasecomp(cp, "data:", 5)) {
	if (strncmp(cp, "data", 4)) {
	    for (i = 0; i < 4; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2669 1
a2669 1
    } else if (!strncasecomp(cp, "lynxexec:", 9)) {
a2674 4
	if (strncmp(cp, "lynxexec", 8)) {
	    for (i = 0; i < 8; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2677 1
a2677 1
    } else if (!strncasecomp(cp, "lynxprog:", 9)) {
d2680 1
a2680 1
	 *  of commans, sriptis or programs with do not
a2682 4
	if (strncmp(cp, "lynxprog", 8)) {
	    for (i = 0; i < 8; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2685 1
a2685 1
    } else if (!strncasecomp(cp, "lynxcgi:", 8)) {
a2688 4
	if (strncmp(cp, "lynxcgi", 7)) {
	    for (i = 0; i < 7; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2691 1
a2691 1
    } else if (!strncasecomp(cp, "LYNXPRINT:", 10)) {
a2694 4
	if (strncmp(cp, "LYNXPRINT", 9)) {
	    for (i = 0; i < 9; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2697 25
a2721 1
    } else if (!strncasecomp(cp, "LYNXDOWNLOAD:", 13)) {
a2724 4
	if (strncmp(cp, "LYDOWNLOAD", 12)) {
	    for (i = 0; i < 12; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2727 1
a2727 1
    } else if (!strncasecomp(cp, "LYNXDIRED:", 10)) {
a2730 4
	if (strncmp(cp, "LYNXDIRED", 9)) {
	    for (i = 0; i < 9; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2733 1
a2733 1
    } else if (!strncasecomp(cp, "LYNXHIST:", 9)) {
a2736 4
	if (strncmp(cp, "LYNXHIST", 8)) {
	    for (i = 0; i < 8; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2739 1
a2739 1
    } else if (!strncasecomp(cp, "LYNXKEYMAP:", 11)) {
a2742 4
	if (strncmp(cp, "LYNXKEYMAP", 10)) {
	    for (i = 0; i < 10; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2745 1
a2745 1
    } else if (!strncasecomp(cp, "LYNXIMGMAP:", 11)) {
a2748 4
	if (strncmp(cp, "LYNXIMGMAP", 10)) {
	    for (i = 0; i < 10; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2752 1
a2752 1
    } else if (!strncasecomp(cp, "LYNXCOOKIE:", 11)) {
a2755 4
	if (strncmp(cp, "LYNXCOOKIE", 10)) {
	    for (i = 0; i < 10; i++)
		cp[i] = TOUPPER(cp[i]);
	}
d2767 1
a2767 5
    } else if (!strncasecomp(cp, "http:", 5)) {
	if (strncmp(cp, "http", 4)) {
	    for (i = 0; i < 4; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2770 1
a2770 5
    } else if (!strncasecomp(cp, "https:", 6)) {
	if (strncmp(cp, "https", 5)) {
	    for (i = 0; i < 5; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2773 1
a2773 5
    } else if (!strncasecomp(cp, "gopher:", 7)) {
	if (strncmp(cp, "gopher", 6)) {
	    for (i = 0; i < 6; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2789 1
a2789 5
    } else if (!strncasecomp(cp, "ftp:", 4)) {
	if (strncmp(cp, "ftp", 3)) {
	    for (i = 0; i < 3; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2792 1
a2792 5
    } else if (!strncasecomp(cp, "wais:", 5)) {
	if (strncmp(cp, "wais", 4)) {
	    for (i = 0; i < 4; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2795 1
a2795 5
    } else if (!strncasecomp(cp, "telnet:", 7)) {
	if (strncmp(cp, "telnet", 6)) {
	    for (i = 0; i < 6; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2798 1
a2798 5
    } else if (!strncasecomp(cp, "tn3270:", 7)) {
	if (strncmp(cp, "tn", 2)) {
	    for (i = 0; i < 2; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2801 1
a2801 5
    } else if (!strncasecomp(cp, "rlogin:", 7)) {
	if (strncmp(cp, "rlogin", 6)) {
	    for (i = 0; i < 6; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2804 1
a2804 5
    } else if (!strncasecomp(cp, "cso:", 4)) {
	if (strncmp(cp, "cso", 3)) {
	    for (i = 0; i < 3; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2807 1
a2807 5
    } else if (!strncasecomp(cp, "finger:", 7)) {
	if (strncmp(cp, "finger", 6)) {
	    for (i = 0; i < 6; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2810 1
a2810 5
    } else if (!strncasecomp(cp, "afs:", 4)) {
	if (strncmp(cp, "afs", 3)) {
	    for (i = 0; i < 3; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2813 1
a2813 5
    } else if (!strncasecomp(cp, "prospero:", 9)) {
	if (strncmp(cp, "prospero", 8)) {
	    for (i = 0; i < 8; i++)
		cp[i] = TOLOWER(cp[i]);
	}
d2871 1
a2871 1
	char *, 	buf)
a2889 36
/*
 *  Quote the path to make it safe for shell command processing.
 *
 *  We use a simple technique which involves quoting the entire
 *  string using single quotes, escaping the real single quotes
 *  with double quotes. This may be gross but it seems to work.
 */
PUBLIC char * quote_pathname ARGS1(
	char *, 	pathname)
{
    size_t i, n = 0;
    char * result;

    for (i=0; i < strlen(pathname); ++i)
	if (pathname[i] == '\'') ++n;

    result = (char *)malloc(strlen(pathname) + 5*n + 3);
    if (result == NULL)
	outofmem(__FILE__, "quote_pathname");

    result[0] = '\'';
    for (i = 0, n = 1; i < strlen(pathname); i++)
	if (pathname[i] == '\'') {
	    result[n++] = '\'';
	    result[n++] = '"';
	    result[n++] = '\'';
	    result[n++] = '"';
	    result[n++] = '\'';
	} else {
	    result[n++] = pathname[i];
	}
    result[n++] = '\'';
    result[n] = '\0';
    return result;
}

d2926 2
a2927 2
		if ((n > 0) && (strlen(me.ut_host) == 0))
			return(TRUE);
d2931 1
a2931 2
	if (TRACE)
	   fprintf(stderr,"Could not get ttyname or open UTMP file");
d2946 5
a2950 6
/* For systems that have both, but both can't be included, duh */
#ifdef TERMIO_AND_TERMIOS
# include <termio.h>
#else
# ifdef HAVE_TERMIOS_H
#  include <termios.h>
d2952 9
a2960 5
#  ifdef HAVE_TERMIO_H
#   include <termio.h>
#  endif /* HAVE_TERMIO_H */
# endif /* HAVE_TERMIOS_H */
#endif	/* TERMIO_AND_TERMIOS */
d2969 1
d2971 1
d3027 1
a3027 4
    }
    if (TRACE) {
	fprintf(stderr,
		"Window size changed from (%d,%d) to (%d,%d)\n",
d3058 1
a3058 1
 *  repeated filenanmes the most current in the list. - FM
d3061 1
a3061 1
	char *, 	fname)
d3076 1
d3078 1
d3101 1
a3101 1
	char *, 	fname)
d3123 4
a3126 6
#if defined(FNAMES_8_3) && defined(DOSPATH)
    cp = HTDOS_wwwName(lynx_temp_space);
#else
    cp = lynx_temp_space;
#endif
    if (*cp == '/') {
d3141 8
d3244 1
a3244 1
     *	underscrores or dashes.
d3340 1
a3340 1
	 *  or underscrores.
d3381 1
a3381 1
 *  To create standard temporary file names.
d3383 14
a3396 6
PUBLIC void tempname ARGS2(
	char *, 	namebuffer,
	int,		action)
{
    static int counter = 0;
    FILE *fp = NULL;
d3398 16
a3413 1
    int LYMaxTempCount = 1000; /* Arbitrary limit.  Make it configurable? */
d3415 8
a3422 28
    int LYMaxTempCount = 10000; /* Arbitrary limit.  Make it configurable? */
#endif /* FNAMES_8_3 */

    if (action == REMOVE_FILES) {
	/*
	 *  Remove all temporary files with .txt or .html suffixes. - FM
	 */
	for (; counter > 0; counter--) {
#ifdef FNAMES_8_3
	    sprintf(namebuffer,
		    "%s%d%u.txt",
		    lynx_temp_space, (int)getpid(), counter-1);
	    remove(namebuffer);
	    sprintf(namebuffer,
		    "%s%d%u%s",
		    lynx_temp_space, (int)getpid(), counter-1, HTML_SUFFIX);
	    remove(namebuffer);
#else
	    sprintf(namebuffer,
		    "%sL%d-%uTMP.txt",
		    lynx_temp_space, (int)getpid(), counter-1);
	    remove(namebuffer);
	    sprintf(namebuffer,
		    "%sL%d-%uTMP%s",
		    lynx_temp_space, (int)getpid(), counter-1, HTML_SUFFIX);
	    remove(namebuffer);
#endif /* FNAMES_8_3 */
	}
d3424 2
a3425 91
	/*
	 *  Load a tentative temporary file name into namebuffer. - FM
	 */
	while (counter < LYMaxTempCount) {
	    /*
	     *	Create names with .txt, then .bin, then
	     *	.html suffixes, and check for their prior
	     *	existence.  If any already exist, someone
	     *	might be trying to spoof us, so increment
	     *	the count and try again.  Otherwise, return
	     *	with the name which has the .html suffix
	     *	loaded in namebuffer. - FM
	     *
	     *	Some systems may use .htm instead of .html.  This
	     *	should be done consistently by always using HTML_SUFFIX
	     *	where filenames are generated for new local files. - kw
	     */
#ifdef FNAMES_8_3
	    sprintf(namebuffer,
		    "%s%d%u.txt",
		    lynx_temp_space, (int)getpid(), counter);
#else
	    sprintf(namebuffer,
		    "%sL%d-%uTMP.txt",
		    lynx_temp_space, (int)getpid(), counter);
#endif /* FNAMES_8_3 */
	    if ((fp = fopen(namebuffer, "r")) != NULL) {
		fclose(fp);
		if (TRACE)
		    fprintf(stderr,
			    "tempname: file '%s' already exists!\n",
			    namebuffer);
		counter++;
		continue;
	    }
#ifdef FNAMES_8_3
	    sprintf(namebuffer,
		    "%s%d%u.bin",
		    lynx_temp_space, (int)getpid(), counter);
#else
	    sprintf(namebuffer,
		    "%sL%d-%uTMP.bin",
		    lynx_temp_space, (int)getpid(), counter);
#endif /* FNAMES_8_3 */
	    if ((fp = fopen(namebuffer, "r")) != NULL) {
		fclose(fp);
		if (TRACE)
		    fprintf(stderr,
			    "tempname: file '%s' already exists!\n",
			    namebuffer);
		counter++;
		continue;
	    }
#ifdef FNAMES_8_3
	    sprintf(namebuffer,
		    "%s%d%u%s",
		    lynx_temp_space, (int)getpid(), counter++, HTML_SUFFIX);
#else
	    sprintf(namebuffer,
		    "%sL%d-%uTMP%s",
		    lynx_temp_space, (int)getpid(), counter++, HTML_SUFFIX);
#endif /* FNAMES_8_3 */
	    if ((fp = fopen(namebuffer, "r")) != NULL) {
		fclose(fp);
		if (TRACE)
		    fprintf(stderr,
			    "tempname: file '%s' already exists!\n",
			    namebuffer);
		continue;
	    }
	    /*
	     *	Return to the calling function, with the tentative
	     *	temporary file name loaded in namebuffer.  Note that
	     *	if the calling function will use a suffix other than
	     *	.txt, .bin, or .html, it similarly should do tests for
	     *	a spoof.  The file name can be reused if it is written
	     *	to on receipt of this name, and thereafter accessed
	     *	for reading.  Note that if writing to a file is to
	     *	be followed by reading it, as it the usual case for
	     *	Lynx, the spoof attempt will be apparent, and the user
	     *	can take appropriate action. - FM
	     */
	    return;
	}
	/*
	 *  The tempfile maximum count has been reached.
	 *  Issue a message and exit. - FM
	 */
	_statusline(MAX_TEMPCOUNT_REACHED);
	sleep(AlertSecs);
	exit(-1);
d3427 2
a3428 5

    /*
     *	We were called for a clean up, and have done it. - FM
     */
    return;
d3439 1
a3439 1
	    number=END;
d3474 1
a3474 1
PRIVATE char *restrict_name[] = {
d3498 1
d3502 1
d3545 1
d3549 1
d3565 1
a3565 1
	char *, 	s)
d3567 2
a3568 2
      char *p;
      char *word;
d3586 1
d3589 1
d3597 1
d3599 1
d3601 1
d3603 1
d3610 1
d3613 1
d3615 1
d3617 1
d3633 1
a3633 2
	  while (isspace((unsigned char)*p))
	      p++;
a3638 2
	  if (*p)
	      *p++ = '\0';
d3640 2
a3641 2
	  for (i=0; restrict_name[i]; i++)
	     if (STREQ(word, restrict_name[i])) {
d3645 3
d3665 1
a3665 1
PUBLIC int LYCheckMail NOARGS
d3689 1
a3689 1
	return 0;
d3697 1
a3697 1
	    return 0;
d3700 1
a3700 6
	while (user[0] &&
	       /*
		*  Suck up trailing spaces.
		*/
	       isspace((unsigned char)user[--userlen]))
	    user[userlen] = '\0';
d3706 1
a3706 1
	return 0;
d3713 1
a3713 1
	return 0;
d3720 1
a3720 1
	return 0;
d3727 1
a3727 1
	    _statusline(HAVE_UNREAD_MAIL_MSG);
d3730 1
a3730 1
	    _statusline(HAVE_NEW_MAIL_MSG);
d3732 1
a3732 1
	return 1;
d3738 1
a3738 1
    return 0;
d3741 1
a3741 1
PUBLIC int LYCheckMail NOARGS
d3746 1
d3754 1
d3758 1
a3758 1
	return 0;
d3762 1
a3762 1
	return 0;
d3765 2
a3766 1
    if (stat(mf,&st) < 0) {
d3768 1
a3768 1
	return 0;
d3772 3
a3774 3
	if (st.st_mtime > st.st_atime ||
	    (lastsize && st.st_size > lastsize))
	    _statusline(HAVE_NEW_MAIL_MSG);
d3776 1
a3776 3
	    _statusline(HAVE_MAIL_MSG);
	lastsize = st.st_size;
	return 1;
d3779 2
a3780 1
    return 0;
d3794 1
a3794 1
PUBLIC void LYEnsureAbsoluteURL ARGS2(
d3796 2
a3797 1
	char *, 	name)
d3814 1
a3814 2
	if (TRACE)
	    fprintf(stderr, "%s%s'%s' is not a URL\n",
d3816 1
a3816 1
	LYConvertToURL(href);
d3829 3
a3831 2
PUBLIC void LYConvertToURL ARGS1(
	char **,	AllocatedString)
d3844 1
a3844 1
#ifdef DOSPATH
d3852 1
a3852 5
#ifdef NOTDEFINED
	 if(strlen(old_string) > 3 && *cp_url == '/')
		*cp_url = '\0';
#endif
    }
d3860 1
a3860 1
#ifdef DOSPATH
d3868 1
a3868 1
	static char url_file[256], file_name[256], dir_name[256];
d3905 1
a3905 3
	    for (cp = file_name; *cp; cp++) {
		*cp = TOLOWER(*cp);
	    }
d3915 1
a3915 1
	} else if ((NULL != getcwd(dir_name, 255, 0)) &&
d3924 1
a3924 1
	    if (NULL != getcwd(dir_name, 255, 0)) {
d3928 1
a3928 3
		for (cp = dir_name; *cp; cp++) {
		    *cp = TOLOWER(*cp);
		}
d3954 1
a3954 3
		    if (TRACE) {
			fprintf(stderr,
			    "Can't find '%s'  Will assume it's a bad path.\n",
a3955 1
		    }
d3993 2
a3994 5
		if (TRACE) {
		    fprintf(stderr,
			    "Can't find '%s'  Will assume it's a bad path.\n",
				old_string);
		}
d4012 1
a4012 3
	if (TRACE) {
	    fprintf(stderr, "Trying: '%s'\n", *AllocatedString);
	}
d4019 2
a4020 3
	    char curdir[DIRNAMESIZE];
	    getcwd (curdir, DIRNAMESIZE);
	    StrAllocCopy(temp, HTDOS_wwwName(curdir));
d4023 2
a4024 4
	    if (TRACE) {
		fprintf(stderr, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString);
	    }
d4029 1
a4029 1
	     *	On Unix, covert '~' to Home_Dir().
d4043 2
a4044 4
	    if (TRACE) {
		fprintf(stderr, "Converted '%s' to '%s'\n",
				old_string, *AllocatedString);
	    }
d4049 1
a4049 1
	    char curdir[DIRNAMESIZE];
d4052 1
a4052 5
#if HAVE_GETCWD
	    getcwd (curdir, DIRNAMESIZE);
#else
	    getwd (curdir);
#endif /* NO_GETCWD */
d4057 1
a4057 5
#ifndef DOSPATH
	    StrAllocCopy(temp, curdir);
	    StrAllocCat(temp, "/");
	    StrAllocCat(temp, old_string);
#else
d4059 3
a4061 4
		StrAllocCopy(temp, HTDOS_wwwName(curdir));
		if(curdir[strlen(curdir)-1] != '/')
		    StrAllocCat(temp, "/");
		LYstrncpy(curdir, temp, (DIRNAMESIZE - 1));
d4067 4
d4073 1
a4073 3
	    if (TRACE) {
		fprintf(stderr, "Converted '%s' to '%s'\n", old_string, temp);
	    }
d4079 5
a4083 5
#ifdef DOSPATH
		/* Don't want to see DOS local paths like c: escaped */
		/* especially when we really have file://localhost/  */
		/* at the beginning. To avoid any confusion we allow */
		/* escaping the path if URL specials % or # present. */
d4092 2
a4093 4
		if (TRACE) {
		    fprintf(stderr, "Converted '%s' to '%s'\n",
				    old_string, *AllocatedString);
		}
d4098 1
a4098 2
		if (curdir[0] != '\0' && curdir[strlen(curdir)-1] != '/')
		    StrAllocCat(temp2, "/");
d4103 1
a4103 1
		StrAllocCat(temp2, cp); 	/* append to current dir  */
d4123 1
a4123 2
			if (curdir[0] != '\0' && curdir[strlen(curdir)-1] != '/')
			    StrAllocCat(temp, "/");
d4133 2
a4134 4
		    if (TRACE) {
			fprintf(stderr, "Converted '%s' to '%s'\n",
					old_string, *AllocatedString);
		    }
d4153 1
a4153 2
			if (curdir[0] != '\0' && curdir[strlen(curdir)-1] != '/')
			    StrAllocCat(temp, "/");
d4172 1
a4172 2
		if (TRACE) {
		    fprintf(stderr, "Can't stat() or fopen() '%s'\n",
a4173 1
		}
d4183 3
a4185 5
		} else {
		    StrAllocCat(*AllocatedString, temp);
		}
		if (TRACE) {
		    fprintf(stderr, "Trying: '%s'\n", *AllocatedString);
d4187 1
d4219 1
a4219 3
	    if (TRACE) {
		fprintf(stderr, "Converted '%s' to '%s'\n", old_string, temp);
	    }
d4228 1
a4228 2
	    if (TRACE) {
		fprintf(stderr, "Converted '%s' to '%s'\n",
a4229 1
	    }
d4262 2
a4263 4
	if (TRACE) {
	    fprintf(stderr, "Converted '%s' to '%s'\n",
			    old_string, *AllocatedString);
	}
d4266 2
a4267 5
    if (TRACE) {
	/* Pause so we can read the messages before invoking curses */
	if (!LYTraceLogFP)
	    sleep(AlertSecs);
    }
d4276 1
a4276 1
 *  (comma separated) prefix list arguement, and, if the element
d4290 2
a4291 2
	char *, 	prefix_list,
	char *, 	suffix_list)
a4298 1
    struct hostent  *phost;
d4365 1
a4365 1
	StrAllocCopy(MsgStr, "Looking up ");
d4367 1
a4367 1
	StrAllocCat(MsgStr, " first.");
d4370 1
a4370 1
	fprintf(stdout, "Looking up '%s' first.\n", host);
d4373 1
a4373 1
    if ((phost = gethostbyname(host)) != NULL)
d4382 1
a4382 3
	    if (TRACE) {
		fprintf(stderr,
	 "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n",
a4383 1
	    }
d4394 3
d4398 1
d4402 1
a4402 3
	if (TRACE) {
	    fprintf(stderr,
	 "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
a4403 1
	}
d4445 1
a4445 1
	EndP++; 	/* Find separator */
d4486 1
a4486 1
		StrAllocCopy(MsgStr, "Looking up ");
d4488 1
a4488 1
		StrAllocCat(MsgStr, ", guessing...");
d4491 1
a4491 1
		fprintf(stdout, "Looking up '%s', guessing...\n", host);
d4494 1
a4494 1
	    GotHost = ((phost = gethostbyname(host)) != NULL);
d4505 7
a4511 4
		if (LYCursesON && HTCheckForInterrupt()) {
		    if (TRACE) {
			fprintf(stderr,
	 "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n",
a4512 1
			    }
d4577 1
a4577 3
	if (TRACE) {
	    fprintf(stderr,
	 "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n",
a4579 1
	}
d4604 1
a4604 1
	char *, 	default_scheme)
d4707 1
a4707 1
	char *, 	path)
d4716 1
a4716 1
    if (path == NULL || *path != '/')
d4722 1
a4722 1
    TerminalSlash = (path[(strlen(path) - 1)] == '/');
d4735 1
a4735 1
	} else if (cp[2] == '/') {
d4768 2
a4769 3
    if (TerminalSlash == FALSE &&
	path[(strlen(path) - 1)] == '/') {
	path[(strlen(path) - 1)] = '\0';
d4783 1
a4783 1
	char *, 	url,
d4811 2
a4812 2
	char *, 	LogicalName,
	char *, 	LogicalValue)
d4836 1
d4841 15
d4863 6
a4868 2
	if ((cp = getenv("HOME")) == NULL || *cp == '\0') {
#ifdef DOSPATH /* BAD!	WSB */
d4906 4
d4916 1
d4918 1
d4924 31
d4959 1
a4959 1
 *  is acceptible, loads it into fbuffer and returns TRUE.
d4965 2
a4966 2
	char *, 	fbuffer,
	size_t, 	fbuffer_size)
d5077 1
a5077 1
    if (is_url(cp) || *cp == '/') {
d5099 5
a5103 2
    if (*cp == '\0' || *cp == '/' || cp[(strlen(cp) - 1)] == '/' ||
	strstr(cp, "..") != NULL || !strcmp(cp, ".")) {
d5141 3
a5143 3
	char *, 	fbuffer,
	size_t, 	fbuffer_size,
	char *, 	fname)
d5207 2
d5252 1
a5252 1
	char *, 	string,
d5267 1
a5267 2
    if (TRACE)
	fprintf(stderr, "LYmktime: Parsing '%s'\n", s);
d5271 1
a5271 1
     *	seek a numberic day field. - FM
d5483 4
a5486 3
    if (TRACE && clock2 > 0)
	fprintf(stderr,
		"LYmktime: clock=%ld, ctime=%s", (long) clock2, ctime(&clock2));
a5513 8
#include <sys/types.h>
#include <errno.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#else
extern int errno;
#endif /* STDC_HEADERS */

a5515 4
#ifdef NOTDEFINED
#define index strchr
#define bcopy(s, d, n) memcpy((d), (s), (n))
#endif /* NOTDEFINED */
a5523 4
#if !__STDC__
#define const
#endif /* !__STDC__ */

d5570 1
a5570 1
	free ((char *) last_environ);
d5590 61
a5650 4
 * Open a file that we don't want other users to see.  For new files, the umask
 * will suffice; however if the file already exists we'll change permissions
 * first, before opening it.  If the chmod fails because of some reason other
 * than a non-existent file, there's no point in trying to open it.
a5653 1
    int save = umask(HIDE_UMASK);
d5655 43
a5697 3
    if (chmod(name, HIDE_CHMOD) == 0 || errno == ENOENT)
	fp = fopen(name, mode);
    umask(save);
d5719 2
d5722 1
a5722 1
    FILE *fp = fopen (name, "w", "shr=get");
d5725 5
a5729 1
    FILE *fp = OpenHiddenFile(name, "w");
d5731 1
d5737 2
d5740 1
a5740 1
    FILE *fp = fopen (name, "a+", "shr=get");
d5743 5
a5747 1
    FILE *fp = OpenHiddenFile(name, "a+");
d5754 1
a5754 1
 *  Restore normal permisions to a copy of a file that we have created
d5760 1
a5760 1
    int mode;
d5770 1
a5770 1
	int save = umask(HIDE_UMASK);
d5777 752
@


1.1
log
@Initial revision
@
text
@d2094 1
a2094 1
	ret = Rselect(FD_SETSIZE, (void *)&readfds, NULL, NULL,
d2098 1
a2098 1
	ret = select(FD_SETSIZE, (void *)&readfds, NULL, NULL,
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
