head	1.8;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.8
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	LYNX_2_8:1.1.1.1
	LYNX:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.23.19.13.26;	author deraadt;	state dead;
branches;
next	1.7;
commitid	EcR8E7r0stjLUV4p;

1.7
date	2014.07.09.04.11.35;	author daniel;	state Exp;
branches;
next	1.6;
commitid	lGGuvDWEniklWrQe;

1.6
date	2011.07.22.14.10.39;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.31.09.16.52;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.04.01.48;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.01.18.59.39;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.18.17.09;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	98.03.11.17.47.52;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.11.17.47.52;	author maja;	state Exp;
branches;
next	;


desc
@@


1.8
log
@delinked from tree, now it goes to the bit bucket
@
text
@/*
 * $LynxId: LYLeaks.c,v 1.37 2013/12/07 13:46:58 tom Exp $
 *
 *	Copyright (c) 1994, University of Kansas, All Rights Reserved
 *	(this file was rewritten twice - 1998/1999 and 2003/2004)
 *
 *	This code will be used only if LY_FIND_LEAKS is defined.
 *
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 *	10-30-97	modified to handle StrAllocCopy() and
 *			  StrAllocCat(). - KW & FM
 *	07-23-07	free leaks of THIS module too -TD
 *	02-09-12	add bstring functions -TD
 */

/*
 *	Disable the overriding of the memory routines for this file.
 */
#define NO_MEMORY_TRACKING

#include <HTUtils.h>
#include <LYexit.h>
#include <LYLeaks.h>
#include <LYUtils.h>
#include <LYGlobalDefs.h>

#ifdef LY_FIND_LEAKS

static AllocationList *ALp_RunTimeAllocations = NULL;

#define LEAK_SUMMARY

#ifdef LEAK_SUMMARY

static size_t now_allocated = 0;
static size_t peak_alloced = 0;

static size_t total_alloced = 0;
static size_t total_freed = 0;

static long count_mallocs = 0;
static long count_frees = 0;

static void CountMallocs(size_t size)
{
    ++count_mallocs;
    total_alloced += size;
    now_allocated += size;
    if (peak_alloced < now_allocated)
	peak_alloced = now_allocated;
}

static void CountFrees(size_t size)
{
    ++count_frees;
    total_freed += size;
    now_allocated -= size;
}

#else
#define CountMallocs(size) ++count_mallocs
#define CountFrees(size)	/* nothing */
#endif

/*
 *  Purpose:	Add a new allocation item to the list.
 *  Arguments:		ALp_new The new item to add.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects beyond
 *		Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void AddToList(AllocationList * ALp_new)
{
    /*
     * Just make this the first item in the list.
     */
    ALp_new->ALp_Next = ALp_RunTimeAllocations;
    ALp_RunTimeAllocations = ALp_new;
}

/*
 *  Purpose:	Find the place in the list where vp_find is currently
 *		tracked.
 *  Arguments:		vp_find A pointer to look for in the list.
 *  Return Value:	AllocationList *	Either vp_find's place in the
 *						list or NULL if not found.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static AllocationList *FindInList(void *vp_find)
{
    AllocationList *ALp_find = ALp_RunTimeAllocations;

    /*
     * Go through the list of allocated pointers until end of list or vp_find
     * is found.
     */
    while (ALp_find != NULL) {
	if (ALp_find->vp_Alloced == vp_find) {
	    break;
	}
	ALp_find = ALp_find->ALp_Next;
    }

    return (ALp_find);
}

/*
 *  Purpose:	Remove the specified item from the list.
 *  Arguments:		ALp_del The item to remove from the list.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		Static function made to make code reusable in projects outside
 *		of Lynx (some might ask why not use HTList).
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
static void RemoveFromList(AllocationList * ALp_del)
{
    AllocationList *ALp_findbefore = ALp_RunTimeAllocations;

    /*
     * There is one special case, where the item to remove is the first in the
     * list.
     */
    if (ALp_del == ALp_findbefore) {
	ALp_RunTimeAllocations = ALp_del->ALp_Next;
    } else {

	/*
	 * Loop through checking all of the next values, if a match don't
	 * continue.  Always assume the item will be found.
	 */
	while (ALp_findbefore->ALp_Next != ALp_del) {
	    ALp_findbefore = ALp_findbefore->ALp_Next;
	}

	/*
	 * We are one item before the one to get rid of.  Get rid of it.
	 */
	ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
    }
}

/*
 * Make the malloc-sequence available for debugging/tracing.
 */
#ifndef LYLeakSequence
long LYLeakSequence(void)
{
    return count_mallocs;
}
#endif

/*
 *  Purpose:	Print a report of all memory left unallocated by
 *		Lynx code or attempted unallocations on
 *		pointers that are not valid and then free
 *		all unfreed memory.
 *  Arguments:		void
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		This function should be registered for execution with the
 *		atexit (stdlib.h) function as the first statement
 *		in main.
 *		All output of this function is sent to the file defined in
 *		the header LYLeaks.h (LEAKAGE_SINK).
 */
void LYLeaks(void)
{
    AllocationList *ALp_head;
    size_t st_total = (size_t) 0;
    FILE *Fp_leakagesink;

    CTRACE((tfp, "entering LYLeaks, flag=%d\n", LYfind_leaks));

    if (LYfind_leaks == FALSE) {
	/*
	 * Free MY leaks too, in case someone else is watching.
	 */
	while (ALp_RunTimeAllocations != NULL) {
	    ALp_head = ALp_RunTimeAllocations;
	    ALp_RunTimeAllocations = ALp_head->ALp_Next;
	    free(ALp_head);
	}
	return;
    }

    /*
     * Open the leakage sink to take all the output.  Recreate the file each
     * time.  Do nothing if unable to open the file.
     */
    Fp_leakagesink = LYNewTxtFile(LEAKAGE_SINK);
    if (Fp_leakagesink == NULL) {
	return;
    }

    while (ALp_RunTimeAllocations != NULL) {
	/*
	 * Take the head off of the run time allocation list.
	 */
	ALp_head = ALp_RunTimeAllocations;
	ALp_RunTimeAllocations = ALp_head->ALp_Next;

	/*
	 * Print the type of leak/error.  Release memory when we no longer
	 * need it.
	 */
	if (ALp_head->vp_Alloced == NULL) {
	    /*
	     * If there is realloc information on the bad request, then it was
	     * a bad pointer value in a realloc statement.
	     */
	    fprintf(Fp_leakagesink, "%s.\n",
		    gettext("Invalid pointer detected."));
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
	    fprintf(Fp_leakagesink, "%s\t%p\n",
		    gettext("Pointer:"), ALp_head->vp_BadRequest);

	    /*
	     * Don't free the bad request, it is an invalid pointer.  If the
	     * free source information is empty, we should check the realloc
	     * information too since it can get passed bad pointer values also.
	     */
	    if (ALp_head->SL_memory.cp_FileName == NULL) {
		fprintf(Fp_leakagesink, "%s\t%s\n",
			gettext("FileName:"),
			ALp_head->SL_realloc.cp_FileName);
		fprintf(Fp_leakagesink, "%s\t%d\n",
			gettext("LineCount:"),
			ALp_head->SL_realloc.ssi_LineNumber);
	    } else {
		fprintf(Fp_leakagesink, "%s\t%s\n",
			gettext("FileName:"),
			ALp_head->SL_memory.cp_FileName);
		fprintf(Fp_leakagesink, "%s\t%d\n",
			gettext("LineCount:"),
			ALp_head->SL_memory.ssi_LineNumber);
	    }
	} else {
	    size_t i_counter;
	    char *value = (char *) (ALp_head->vp_Alloced);

	    /*
	     * Increment the count of total memory lost and then print the
	     * information.
	     */
	    st_total += ALp_head->st_Bytes;

	    fprintf(Fp_leakagesink, "%s\n",
		    gettext("Memory leak detected."));
	    fprintf(Fp_leakagesink, "%s\t%ld\n",
		    gettext("Sequence:"),
		    ALp_head->st_Sequence);
	    fprintf(Fp_leakagesink, "%s\t%p\n",
		    gettext("Pointer:"),
		    ALp_head->vp_Alloced);
	    fprintf(Fp_leakagesink, "%s\t",
		    gettext("Contains:"));
	    for (i_counter = 0;
		 i_counter < ALp_head->st_Bytes &&
		 i_counter < MAX_CONTENT_LENGTH;
		 i_counter++) {
		if (isprint(UCH(value[i_counter]))) {
		    fprintf(Fp_leakagesink, "%c", value[i_counter]);
		} else {
		    fprintf(Fp_leakagesink, "|");
		}
	    }
	    fprintf(Fp_leakagesink, "\n");
	    fprintf(Fp_leakagesink, "%s\t%d\n",
		    gettext("ByteSize:"),
		    (int) (ALp_head->st_Bytes));
	    fprintf(Fp_leakagesink, "%s\t%s\n",
		    gettext("FileName:"),
		    ALp_head->SL_memory.cp_FileName);
	    fprintf(Fp_leakagesink, "%s\t%d\n",
		    gettext("LineCount:"),
		    ALp_head->SL_memory.ssi_LineNumber);
	    /*
	     * Give the last time the pointer was realloced if it happened
	     * also.
	     */
	    if (ALp_head->SL_realloc.cp_FileName != NULL) {
		fprintf(Fp_leakagesink, "%s\t%s\n",
			gettext("realloced:"),
			ALp_head->SL_realloc.cp_FileName);
		fprintf(Fp_leakagesink, "%s\t%d\n",
			gettext("LineCount:"),
			ALp_head->SL_realloc.ssi_LineNumber);
	    }
	    fflush(Fp_leakagesink);
	    FREE(ALp_head->vp_Alloced);
	}

	/*
	 * Create a blank line and release the memory held by the item.
	 */
	fprintf(Fp_leakagesink, "\n");
	FREE(ALp_head);
    }

    /*
     * Give a grand total of the leakage.  Close the output file.
     */
    fprintf(Fp_leakagesink, "%s\t%u\n",
	    gettext("Total memory leakage this run:"),
	    (unsigned) st_total);
#ifdef LEAK_SUMMARY
    fprintf(Fp_leakagesink,
	    "%s\t%lu\n", gettext("Peak allocation"), (unsigned long) peak_alloced);
    fprintf(Fp_leakagesink,
	    "%s\t%lu\n", gettext("Bytes allocated"), (unsigned long) total_alloced);
    fprintf(Fp_leakagesink,
	    "%s\t%ld\n", gettext("Total mallocs"), count_mallocs);
    fprintf(Fp_leakagesink,
	    "%s\t%ld\n", gettext("Total frees"), count_frees);
#endif
    fclose(Fp_leakagesink);

    HTSYS_purge(LEAKAGE_SINK);
}

/*
 *  Purpose:	Capture allocations using malloc (stdlib.h) and track
 *		the information in a list.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure as per malloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakMalloc(size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
{
    void *vp_malloc;

    if (LYfind_leaks == FALSE) {
	vp_malloc = (void *) malloc(st_bytes);
    } else {

	/*
	 * Do the actual allocation.
	 */
	vp_malloc = (void *) malloc(st_bytes);
	CountMallocs(st_bytes);

	/*
	 * Only on successful allocation do we track any information.
	 */
	if (vp_malloc != NULL) {
	    /*
	     * Further allocate memory to store the information.  Just return
	     * on failure to allocate more.
	     */
	    AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new != NULL) {
		/*
		 * Copy over the relevant information.  There is no need to
		 * allocate more memory for the file name as it is a static
		 * string anyway.
		 */
		ALp_new->st_Sequence = count_mallocs;
		ALp_new->vp_Alloced = vp_malloc;
		ALp_new->st_Bytes = st_bytes;
		ALp_new->SL_memory.cp_FileName = cp_File;
		ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

		/*
		 * Add the new item to the allocation list.
		 */
		AddToList(ALp_new);
	    }
	}
    }
    return (vp_malloc);
}

/*
 *  Purpose:	Add information about new allocation to the list,
 *		after a call to malloc or calloc or an equivalent
 *		function which may or may not have already created
 *		a list entry.
 *  Arguments:	vp_malloc	The pointer to newly allocated memory.
 *  Arguments:	st_bytes	The size of the allocation requested
 *				in bytes.
 *		cp_File		The file from which the request for
 *				allocation came from.
 *		ssi_Line	The line number in cp_File where the
 *				allocation request came from.
 *  Return Value:	void *	A pointer to the allocated memory or NULL on
 *				failure.
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory is allocated, then no entry is added to the
 *		allocation list.
 *  Revision History:
 *	1999-02-08	created, modelled after LYLeakMalloc - kw
 */
AllocationList *LYLeak_mark_malloced(void *vp_malloced,
				     size_t st_bytes,
				     const char *cp_File,
				     const short ssi_Line)
{
    AllocationList *ALp_new = NULL;

    if (LYfind_leaks != FALSE) {
	/*
	 * The actual allocation has already been done!
	 *
	 * Only on successful allocation do we track any information.
	 */
	if (vp_malloced != NULL) {
	    /*
	     * See if there is already an entry.  If so, just update the source
	     * location info.
	     */
	    ALp_new = FindInList(vp_malloced);
	    if (ALp_new) {
		ALp_new->SL_memory.cp_FileName = cp_File;
		ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
	    } else {
		/*
		 * Further allocate memory to store the information.  Just
		 * return on failure to allocate more.
		 */
		ALp_new = typecalloc(AllocationList);
		if (ALp_new != NULL) {
		    /*
		     * Copy over the relevant information.
		     */
		    ALp_new->vp_Alloced = vp_malloced;
		    ALp_new->st_Bytes = st_bytes;
		    ALp_new->SL_memory.cp_FileName = cp_File;
		    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

		    /*
		     * Add the new item to the allocation list.
		     */
		    AddToList(ALp_new);
		    CountMallocs(st_bytes);
		}
	    }
	}
    }
    return (ALp_new);
}

/*
 *  Purpose:	Capture allocations by calloc (stdlib.h) and
 *		save relevant information in a list.
 *  Arguments:	st_number	The number of items to allocate.
 *		st_bytes	The size of each item.
 *		cp_File		The file which wants to allocation.
 *		ssi_Line	The line number in cp_File requesting
 *				the allocation.
 *  Return Value:	void *	The allocated memory, or NULL on failure as
 *				per calloc (stdlib.h)
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If no memory can be allocated, then no entry will be added
 *		to the list.
 *  Revision History:
 *		05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakCalloc(size_t st_number, size_t st_bytes, const char *cp_File,
		   const short ssi_Line)
{
    void *vp_calloc;

    if (LYfind_leaks == FALSE) {
	vp_calloc = (void *) calloc(st_number, st_bytes);
    } else {

	/*
	 * Allocate the requested memory.
	 */
	vp_calloc = (void *) calloc(st_number, st_bytes);
	CountMallocs(st_bytes * st_number);

	/*
	 * Only if the allocation was a success do we track information.
	 */
	if (vp_calloc != NULL) {
	    /*
	     * Allocate memory for the item to be in the list.  If unable, just
	     * return.
	     */
	    AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new != NULL) {

		/*
		 * Copy over the relevant information.  There is no need to
		 * allocate memory for the file name as it is a static string
		 * anyway.
		 */
		ALp_new->st_Sequence = count_mallocs;
		ALp_new->vp_Alloced = vp_calloc;
		ALp_new->st_Bytes = (st_number * st_bytes);
		ALp_new->SL_memory.cp_FileName = cp_File;
		ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

		/*
		 * Add the item to the allocation list.
		 */
		AddToList(ALp_new);
	    }
	}
    }
    return (vp_calloc);
}

/*
 *  Purpose:	Capture any realloc (stdlib.h) calls in order to
 *		properly keep track of our run time allocation
 *		table.
 *  Arguments:	vp_Alloced	The previously allocated block of
 *				memory to resize.  If NULL,
 *				realloc works just like
 *				malloc.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file containing the realloc.
 *		ssi_Line	The line containing the realloc in cp_File.
 *  Return Value:	void *	The new pointer value (could be the same) or
 *				NULL if unable to resize (old block
 *				still exists).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If unable to resize vp_Alloced, then no change in the
 *		allocation list will be made.
 *		If vp_Alloced is an invalid pointer value, the program will
 *		exit after one last entry is added to the allocation list.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void *LYLeakRealloc(void *vp_Alloced,
		    size_t st_newBytes,
		    const char *cp_File,
		    const short ssi_Line)
{
    void *vp_realloc;
    AllocationList *ALp_renew;

    if (LYfind_leaks == FALSE) {
	vp_realloc = (void *) realloc(vp_Alloced, st_newBytes);

    } else if (vp_Alloced == NULL) {
	/*
	 * If we are asked to resize a NULL pointer, this is just a malloc
	 * call.
	 */
	vp_realloc = LYLeakMalloc(st_newBytes, cp_File, ssi_Line);

    } else {

	/*
	 * Find the current vp_Alloced block in the list.  If NULL, this is an
	 * invalid pointer value.
	 */
	ALp_renew = FindInList(vp_Alloced);
	if (ALp_renew == NULL) {
	    /*
	     * Track the invalid pointer value and then exit.  If unable to
	     * allocate, just exit.
	     */
	    AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit_immediately(EXIT_FAILURE);
	    }

	    /*
	     * Set the information up; no need to allocate file name since it is a
	     * static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_Alloced;
	    ALp_new->SL_realloc.cp_FileName = cp_File;
	    ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	    /*
	     * Add the item to the list.  Exit.
	     */
	    AddToList(ALp_new);
	    exit_immediately(EXIT_FAILURE);
	}

	/*
	 * Perform the resize.  If not NULL, record the information.
	 */
	vp_realloc = (void *) realloc(vp_Alloced, st_newBytes);
	CountFrees(ALp_renew->st_Bytes);
	CountMallocs(st_newBytes);

	if (vp_realloc != NULL) {
	    ALp_renew->st_Sequence = count_mallocs;
	    ALp_renew->vp_Alloced = vp_realloc;
	    ALp_renew->st_Bytes = st_newBytes;

	    /*
	     * Update the realloc information, too.  No need to allocate file name,
	     * static string.
	     */
	    ALp_renew->SL_realloc.cp_FileName = cp_File;
	    ALp_renew->SL_realloc.ssi_LineNumber = ssi_Line;
	}
    }
    return (vp_realloc);
}

/*
 *  Purpose:	Add information about reallocated memory to the list,
 *		after a call to realloc or an equivalent
 *		function which has not already created or updated
 *		a list entry.
 *  Arguments:	ALp_old		List entry for previously allocated
 *				block of memory to resize.  If NULL,
 *				mark_realloced works just like
 *				mark_malloced.
 *		vp_realloced	The new pointer, after resizing.
 *		st_newBytes	The new size of the chunk of memory.
 *		cp_File		The file to record.
 *		ssi_Line	The line to record.
 *  Return Value:		Pointer to new or updated list entry
 *				for this memory block.
 *				NULL on allocation error.
 *  Revision History:
 *	1999-02-11	created kw
 */
#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)
static AllocationList *mark_realloced(AllocationList * ALp_old, void *vp_realloced,
				      size_t st_newBytes,
				      const char *cp_File,
				      const short ssi_Line)
{
    /*
     * If there is no list entry for the old allocation, treat this as if a new
     * allocation had happened.
     */
    if (ALp_old == NULL) {
	return (LYLeak_mark_malloced(vp_realloced, st_newBytes, cp_File, ssi_Line));
    }

    /*
     * ALp_old represents the memory block before reallocation.  Assume that if
     * we get here, there isn't yet a list entry for the new, possibly
     * different, address after realloc, that is our list hasn't been updated -
     * so we're going to do that now.
     */

    if (vp_realloced != NULL) {
	ALp_old->vp_Alloced = vp_realloced;
	ALp_old->st_Bytes = st_newBytes;
	ALp_old->SL_realloc.cp_FileName = cp_File;
	ALp_old->SL_realloc.ssi_LineNumber = ssi_Line;
    }

    return (ALp_old);
}
#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */

/*
 *  Purpose:	Capture all requests to free information and also
 *		remove items from the allocation list.
 *  Arguments:	vp_Alloced	The memory to free.
 *		cp_File		The file calling free.
 *		ssi_Line	The line of cp_File calling free.
 *  Return Value:	void
 *  Remarks/Portability/Dependencies/Restrictions:
 *		If the pointer value is invalid, then an item will be added
 *		to the list and nothing else is done.
 *		I really like the name of this function and one day hope
 *		that Lynx is Leak Free.
 *  Revision History:
 *	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
 */
void LYLeakFree(void *vp_Alloced,
		const char *cp_File,
		const short ssi_Line)
{
    AllocationList *ALp_free;

    if (LYfind_leaks == FALSE) {
	free(vp_Alloced);
    } else {

	/*
	 * Find the pointer in the allocated list.  If not found, bad pointer. 
	 * If found, free list item and vp_Alloced.
	 */
	ALp_free = FindInList(vp_Alloced);
	if (ALp_free == NULL) {
	    /*
	     * Create the final entry before exiting marking this error.  If
	     * unable to allocate more memory just exit.
	     */
	    AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit_immediately(EXIT_FAILURE);
	    }

	    /*
	     * Set up the information, no memory need be allocated for the file
	     * name since it is a static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_Alloced;
	    ALp_new->SL_memory.cp_FileName = cp_File;
	    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	    /*
	     * Add the entry to the list and then return.
	     */
	    AddToList(ALp_new);
	} else {
	    /*
	     * Free off the memory.  Take entry out of allocation list.
	     */
	    CountFrees(ALp_free->st_Bytes);
	    RemoveFromList(ALp_free);
	    FREE(ALp_free);
	    free(vp_Alloced);
	}
    }
}

/*
 *  Allocates a new copy of a string, and returns it.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACopy in HTString.c - KW
 */
char *LYLeakSACopy(char **dest,
		   const char *src,
		   const char *cp_File,
		   const short ssi_Line)
{
    if (src != NULL && src == *dest) {
	CTRACE((tfp,
		"LYLeakSACopy: *dest equals src, contains \"%s\"\n",
		src));
    } else {
	if (*dest) {
	    LYLeakFree(*dest, cp_File, ssi_Line);
	    *dest = NULL;
	}
	if (src) {
	    *dest = (char *) LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
	    if (*dest == NULL)
		outofmem(__FILE__, "LYLeakSACopy");
	    strcpy(*dest, src);
	}
    }
    return *dest;
}

/*
 *  String Allocate and Concatenate.
 *  Tracks allocations by using other LYLeakFoo functions.
 *  Equivalent to HTSACat in HTUtils.c - KW
 */
char *LYLeakSACat(char **dest,
		  const char *src,
		  const char *cp_File,
		  const short ssi_Line)
{
    if (src && *src) {
	if (src == *dest) {
	    CTRACE((tfp,
		    "LYLeakSACat:  *dest equals src, contains \"%s\"\n",
		    src));
	} else if (*dest) {
	    size_t length = strlen(*dest);

	    *dest = (char *) LYLeakRealloc(*dest,
					   (length + strlen(src) + 1),
					   cp_File,
					   ssi_Line);
	    if (*dest == NULL)
		outofmem(__FILE__, "LYLeakSACat");
	    strcpy(*dest + length, src);
	} else {
	    *dest = (char *) LYLeakMalloc((strlen(src) + 1),
					  cp_File,
					  ssi_Line);
	    if (*dest == NULL)
		outofmem(__FILE__, "LYLeakSACat");
	    strcpy(*dest, src);
	}
    }
    return *dest;
}

/******************************************************************************/

/*
 * Equivalents for bstring functions in HTString.c -TD
 */
/* same as HTSABAlloc */
void LYLeakSABAlloc(bstring **dest,
		    int len,
		    const char *cp_File,
		    const short ssi_Line)
{
    if (*dest == 0) {
	*dest = LYLeakCalloc(1, sizeof(bstring), cp_File, ssi_Line);
    }

    if ((*dest)->len != len) {
	(*dest)->str = (char *) LYLeakRealloc((*dest)->str,
					      (size_t) len,
					      cp_File,
					      ssi_Line);
	if ((*dest)->str == NULL)
	    outofmem(__FILE__, "LYLeakSABalloc");

	(*dest)->len = len;
    }
}

/* same as HTSABCopy */
void LYLeakSABCopy(bstring **dest,
		   const char *src,
		   int len,
		   const char *cp_File,
		   const short ssi_Line)
{
    bstring *t;
    unsigned need = (unsigned) (len + 1);

    CTRACE2(TRACE_BSTRING,
	    (tfp, "HTSABCopy(%p, %p, %d)\n",
	     (void *) dest, (const void *) src, len));
    LYLeakSABFree(dest, cp_File, ssi_Line);
    if (src) {
	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if ((t = (bstring *) LYLeakMalloc(sizeof(bstring), cp_File, ssi_Line))
	    == NULL)
	      outofmem(__FILE__, "HTSABCopy");

	assert(t != NULL);

	if ((t->str = (char *) LYLeakMalloc(need, cp_File, ssi_Line)) == NULL)
	    outofmem(__FILE__, "HTSABCopy");

	assert(t->str != NULL);

	MemCpy(t->str, src, len);
	t->len = len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/* same as HTSABCopy0 */
void LYLeakSABCopy0(bstring **dest,
		    const char *src,
		    const char *cp_File,
		    const short ssi_Line)
{
    LYLeakSABCopy(dest, src, (int) strlen(src), cp_File, ssi_Line);
}

/* same as HTSABCat */
void LYLeakSABCat(bstring **dest,
		  const char *src,
		  int len,
		  const char *cp_File,
		  const short ssi_Line)
{
    bstring *t = *dest;

    CTRACE2(TRACE_BSTRING,
	    (tfp, "HTSABCat(%p, %p, %d)\n",
	     (void *) dest, (const void *) src, len));
    if (src) {
	unsigned need = (unsigned) (len + 1);

	if (TRACE_BSTRING) {
	    CTRACE((tfp, "===    %4d:", len));
	    trace_bstring2(src, len);
	    CTRACE((tfp, "\n"));
	}
	if (t) {
	    unsigned length = (unsigned) t->len + need;

	    t->str = (char *) LYLeakRealloc(t->str, length, cp_File, ssi_Line);
	} else {
	    if ((t = (bstring *) LYLeakCalloc(1, sizeof(bstring), cp_File,
					      ssi_Line)) == NULL)
		  outofmem(__FILE__, "HTSACat");

	    assert(t != NULL);

	    t->str = (char *) LYLeakMalloc(need, cp_File, ssi_Line);
	}
	if (t->str == NULL)
	    outofmem(__FILE__, "HTSACat");

	assert(t->str != NULL);

	MemCpy(t->str + t->len, src, len);
	t->len += len;
	t->str[t->len] = '\0';
	*dest = t;
    }
    if (TRACE_BSTRING) {
	CTRACE((tfp, "=>     %4d:", BStrLen(*dest)));
	trace_bstring(*dest);
	CTRACE((tfp, "\n"));
    }
}

/* same as HTSABCat0 */
void LYLeakSABCat0(bstring **dest,
		   const char *src,
		   const char *cp_File,
		   const short ssi_Line)
{
    LYLeakSABCat(dest, src, (int) strlen(src), cp_File, ssi_Line);
}

/* same as HTSABFree */
void LYLeakSABFree(bstring **ptr,
		   const char *cp_File,
		   const short ssi_Line)
{
    if (*ptr != NULL) {
	if ((*ptr)->str)
	    LYLeakFree((*ptr)->str, cp_File, ssi_Line);
	LYLeakFree(*ptr, cp_File, ssi_Line);
	*ptr = NULL;
    }
}

/******************************************************************************/

#if defined(LY_FIND_LEAKS) && defined(LY_FIND_LEAKS_EXTENDED)

const char *leak_cp_File_hack = __FILE__;
short leak_ssi_Line_hack = __LINE__;

/*
 * Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
 *		HTSprintf/HTSprintf0, implemented in HTString.c) that
 *		tries to make sure that our allocation list is always
 *		properly updated, whether StrAllocVsprintf itself was
 *		compiled with memory tracking or not (or even a mixture,
 *		like tracking the freeing but not the new allocation).
 *		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
 *		in effect while others only have LY_FIND_LEAKS in effect,
 *		and as long as HTString.c is complied with memory tracking
 *		(of either kind) string objects allocated by HTSprintf/
 *		HTSprintf0 (or otherwise) can be passed around among them and
 *		manipulated both ways.
 *  Arguments:	dest		As for StrAllocVsprintf.
 *		cp_File		The source file of the caller (i.e. the
 *				caller of HTSprintf/HTSprintf0, hopefully).
 *		ssi_Line	The line of cp_File calling.
 *		inuse,fmt,ap	As for StrAllocVsprintf.
 *  Return Value:	The char pointer to resulting string, as set
 *			by StrAllocVsprintf, or
 *			NULL if dest==0 (wrong use!).
 *  Remarks/Portability/Dependencies/Restrictions:
 *		The price for generality is severe inefficiency: several
 *		list lookups are done to be on the safe side.
 *		We don't get the real allocation size, only a minimum based
 *		on the string length of the result.  So the amount of memory
 *		leakage may get underestimated.
 *		If *dest is an invalid pointer value on entry (i.e. was not
 *		tracked), the program will exit after one last entry is added
 *		to the allocation list.
 *		If StrAllocVsprintf fails to return a valid string via the
 *		indirect string pointer (its first parameter), invalid memory
 *		access will result and the program will probably terminate
 *		with a signal.  This can happen if, on entry, *dest is NULL
 *		and fmt is empty or NULL, so just Don't Do That.
 *  Revision History:
 *	1999-02-11	created kw
 *	1999-10-15	added comments kw
 */
static char *LYLeakSAVsprintf(char **dest,
			      const char *cp_File,
			      const short ssi_Line,
			      size_t inuse,
			      const char *fmt,
			      va_list * ap)
{
    AllocationList *ALp_old;
    void *vp_oldAlloced;

    const char *old_cp_File = __FILE__;
    short old_ssi_Line = __LINE__;

    if (!dest)
	return NULL;

    if (LYfind_leaks == FALSE) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	return (*dest);
    }

    vp_oldAlloced = *dest;
    if (!vp_oldAlloced) {
	StrAllocVsprintf(dest, inuse, fmt, ap);
	LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
	return (*dest);
    } else {
	void *vp_realloced;

	ALp_old = FindInList(vp_oldAlloced);
	if (ALp_old == NULL) {
	    /*
	     * Track the invalid pointer value and then exit.  If unable to
	     * allocate, just exit.
	     */
	    AllocationList *ALp_new = typecalloc(AllocationList);

	    if (ALp_new == NULL) {
		exit_immediately(EXIT_FAILURE);
	    }

	    /*
	     * Set the information up; no need to allocate file name since it
	     * is a static string.
	     */
	    ALp_new->vp_Alloced = NULL;
	    ALp_new->vp_BadRequest = vp_oldAlloced;
	    ALp_new->SL_realloc.cp_FileName = cp_File;
	    ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;

	    /*
	     * Add the item to the list.  Exit.
	     */
	    AddToList(ALp_new);
	    exit_immediately(EXIT_FAILURE);
	}

	old_cp_File = ALp_old->SL_memory.cp_FileName;
	old_ssi_Line = ALp_old->SL_memory.ssi_LineNumber;
	/*
	 * DO THE REAL WORK, by calling StrAllocVsprintf.  If result is not
	 * NULL, record the information.
	 */
	StrAllocVsprintf(dest, inuse, fmt, ap);
	vp_realloced = (void *) *dest;
	if (vp_realloced != NULL) {
	    AllocationList *ALp_new = FindInList(vp_realloced);

	    if (!ALp_new) {
		/* Look up again, list may have changed! - kw */
		ALp_old = FindInList(vp_oldAlloced);
		if (ALp_old == NULL) {
		    LYLeak_mark_malloced(*dest, strlen(*dest) + 1, cp_File, ssi_Line);
		    return (*dest);
		}
		mark_realloced(ALp_old, *dest, strlen(*dest) + 1, cp_File, ssi_Line);
		return (*dest);
	    }
	    if (vp_realloced == vp_oldAlloced) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
		return (*dest);
	    }
	    /* Look up again, list may have changed! - kw */
	    ALp_old = FindInList(vp_oldAlloced);
	    if (ALp_old == NULL) {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    } else {
		ALp_new->SL_memory.cp_FileName = old_cp_File;
		ALp_new->SL_memory.ssi_LineNumber = old_ssi_Line;
		ALp_new->SL_realloc.cp_FileName = cp_File;
		ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
	    }
	}
	return (*dest);
    }
}

/* Note: the following may need updating if HTSprintf in HTString.c
 * is changed. - kw */
static char *LYLeakHTSprintf(char **pstr, const char *fmt,...)
{
    char *str;
    size_t inuse = 0;
    va_list ap;

    LYva_start(ap, fmt);

    if (pstr != 0 && *pstr != 0)
	inuse = strlen(*pstr);
    str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			   inuse, fmt, &ap);

    va_end(ap);
    return str;
}

/* Note: the following may need updating if HTSprintf0 in HTString.c
 * is changed. - kw */
static char *LYLeakHTSprintf0(char **pstr, const char *fmt,...)
{
    char *str;
    va_list ap;

    LYva_start(ap, fmt);

    str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			   0, fmt, &ap);

    va_end(ap);
    return str;
}

/*
 * HTSprintf and HTSprintf0 will be defined such that they effectively call one
 * of the following two functions that store away a copy to the File & Line
 * info in temporary hack variables, and then call the real function (which is
 * returned here as a function pointer) to the regular HTSprintf/HTSprintf0
 * arguments.  It's probably a bit inefficient, but that shouldn't be
 * noticeable compared to all the time that memory tracking takes up for list
 * traversal.  - kw
 */
HTSprintflike *Get_htsprintf_fn(const char *cp_File,
				const short ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf;
}

HTSprintflike *Get_htsprintf0_fn(const char *cp_File,
				 const short ssi_Line)
{
    leak_cp_File_hack = cp_File;
    leak_ssi_Line_hack = ssi_Line;
    return &LYLeakHTSprintf0;
}

#endif /* LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */
#else
/* Standard C forbids an empty file */
void no_leak_checking(void);
void no_leak_checking(void)
{
}
#endif /* LY_FIND_LEAKS */
@


1.7
log
@update to lynx 2.8.8rel2, keeping local changes. primarily to get these
changes from 2.8.8dev.16:

* fix most issues found by clang 3.2 analyze
* fix most issues found by Coverity scan

tested on i386, sparc64, and macppc by myself.
tested on vax by miod@@ (including https)
helpful discussion with avsm@@, sthen@@

ok deraadt@@
@
text
@@


1.6
log
@update to lynx2.8.7rel.2, with local patches:
- restore local lynx.cfg settings [avsm]
- fix makefile races [espie]
- read/write result checking fixes to avoid unsigned comparisons vs -1 [krw]
- initialize all the InputFieldData members correctly [fgsch]
- fix socklen_t test to include <sys/types.h> [miod]
- fgets(3) returns NULL on error, not 0. No functional change [cloder]

ok krw@@, tests by Simon Kuhnle and Martin Pieuchot
@
text
@d2 1
a2 1
 * $LynxId: LYLeaks.c,v 1.32 2007/07/23 22:54:46 tom Exp $
d13 2
d36 2
a37 2
static long now_allocated = 0;
static long peak_alloced = 0;
d39 2
a40 2
static long total_alloced = 0;
static long total_freed = 0;
d45 1
a45 1
static void CountMallocs(long size)
d54 1
a54 1
static void CountFrees(long size)
d62 2
a63 2
#define CountMallocs() ++count_mallocs
#define CountFrees()		/* nothing */
d319 8
a326 4
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Peak allocation"), peak_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Bytes allocated"), total_alloced);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total mallocs"), count_mallocs);
    fprintf(Fp_leakagesink, "%s\t%ld\n", gettext("Total frees"), count_frees);
d458 1
d495 1
a495 1
	CountMallocs(st_bytes);
d608 1
a609 1
	CountFrees(ALp_renew->st_Bytes);
d747 1
a747 1
 *  Equivalent to HTSACopy in HTUtils.c - KW
d789 1
a789 1
	    int length = strlen(*dest);
d810 153
d992 1
a992 1
 *		We don't get he real allocation size, only a minimum based
@


1.5
log
@Update to lynx-2.8.6.rel5, with our local patches maintained where relevant.
tests from miod@@ sthen@@ jmc@@ jsing@@
two additional fixes from miod:
- fix uninitialized stack variable use, leading to occasional crash.
- modify the socklen_t test to include <sys/types.h>, fixes gcc2 build failures
@
text
@d2 2
d5 1
d133 9
a141 2
	return;
    }
d143 4
a146 6
    /*
     * Loop through checking all of the next values, if a match don't continue. 
     * Always assume the item will be found.
     */
    while (ALp_findbefore->ALp_Next != ALp_del) {
	ALp_findbefore = ALp_findbefore->ALp_Next;
a147 5

    /*
     * We are one item before the one to get rid of.  Get rid of it.
     */
    ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
d180 11
a190 1
    if (LYfind_leaks == FALSE)
d192 1
d211 1
a211 1
	 * Print the type of leak/error.  Free off memory when we no longer
a324 3
#if defined(NCURSES) && defined(HAVE__NC_FREEALL)
    _nc_freeall();
#endif
d349 3
a351 8
    if (LYfind_leaks == FALSE)
	return (void *) malloc(st_bytes);

    /*
     * Do the actual allocation.
     */
    vp_malloc = (void *) malloc(st_bytes);
    CountMallocs(st_bytes);
a352 4
    /*
     * Only on successful allocation do we track any information.
     */
    if (vp_malloc != NULL) {
d354 1
a354 2
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
d356 2
a357 1
	AllocationList *ALp_new = typecalloc(AllocationList);
a358 3
	if (ALp_new == NULL) {
	    return (vp_malloc);
	}
d360 1
a360 2
	 * Copy over the relevant information.  There is no need to allocate
	 * more memory for the file name as it is a static string anyhow.
d362 6
a367 5
	ALp_new->st_Sequence = count_mallocs;
	ALp_new->vp_Alloced = vp_malloc;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
d369 18
a386 4
	/*
	 * Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
a387 1

d418 1
a418 9
    if (LYfind_leaks == FALSE)
	return NULL;

    /*
     * The actual allocation has already been done!
     *
     * Only on successful allocation do we track any information.
     */
    if (vp_malloced != NULL) {
d420 3
a422 2
	 * See if there is already an entry.  If so, just update the source
	 * location info.
d424 30
a453 5
	ALp_new = FindInList(vp_malloced);
	if (ALp_new) {
	    ALp_new->SL_memory.cp_FileName = cp_File;
	    ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
	    return (ALp_new);
a454 21
	/*
	 * Further allocate memory to store the information.  Just return on
	 * failure to allocate more.
	 */
	ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return (NULL);
	}
	/*
	 * Copy over the relevant information.
	 */
	ALp_new->vp_Alloced = vp_malloced;
	ALp_new->st_Bytes = st_bytes;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;

	/*
	 * Add the new item to the allocation list.
	 */
	AddToList(ALp_new);
a455 1

d480 3
a482 8
    if (LYfind_leaks == FALSE)
	return (void *) calloc(st_number, st_bytes);

    /*
     * Allocate the requested memory.
     */
    vp_calloc = (void *) calloc(st_number, st_bytes);
    CountMallocs(st_bytes);
a483 4
    /*
     * Only if the allocation was a success do we track information.
     */
    if (vp_calloc != NULL) {
d485 1
a485 2
	 * Allocate memory for the item to be in the list.  If unable, just
	 * return.
d487 2
a488 5
	AllocationList *ALp_new = typecalloc(AllocationList);

	if (ALp_new == NULL) {
	    return (vp_calloc);
	}
d491 1
a491 2
	 * Copy over the relevant information.  There is no need to allocate
	 * memory for the file name as it is a static string anyway.
d493 8
a500 5
	ALp_new->st_Sequence = count_mallocs;
	ALp_new->vp_Alloced = vp_calloc;
	ALp_new->st_Bytes = (st_number * st_bytes);
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
d502 17
a518 4
	/*
	 * Add the item to the allocation list.
	 */
	AddToList(ALp_new);
a519 1

d553 2
a554 9
    if (LYfind_leaks == FALSE)
	return (void *) realloc(vp_Alloced, st_newBytes);

    /*
     * If we are asked to resize a NULL pointer, this is just a malloc call.
     */
    if (vp_Alloced == NULL) {
	return (LYLeakMalloc(st_newBytes, cp_File, ssi_Line));
    }
d556 1
a556 6
    /*
     * Find the current vp_Alloced block in the list.  If NULL, this is an
     * invalid pointer value.
     */
    ALp_renew = FindInList(vp_Alloced);
    if (ALp_renew == NULL) {
d558 2
a559 2
	 * Track the invalid pointer value and then exit.  If unable to
	 * allocate, just exit.
d561 1
a561 1
	auto AllocationList *ALp_new = typecalloc(AllocationList);
d563 1
a563 3
	if (ALp_new == NULL) {
	    exit_immediately(EXIT_FAILURE);
	}
d566 2
a567 2
	 * Set the information up; no need to allocate file name since it is a
	 * static string.
d569 7
a575 4
	ALp_new->vp_Alloced = NULL;
	ALp_new->vp_BadRequest = vp_Alloced;
	ALp_new->SL_realloc.cp_FileName = cp_File;
	ALp_new->SL_realloc.ssi_LineNumber = ssi_Line;
d577 3
a579 6
	/*
	 * Add the item to the list.  Exit.
	 */
	AddToList(ALp_new);
	exit_immediately(EXIT_FAILURE);
    }
d581 8
a588 6
    /*
     * Perform the resize.  If not NULL, record the information.
     */
    vp_realloc = (void *) realloc(vp_Alloced, st_newBytes);
    CountMallocs(st_newBytes);
    CountFrees(ALp_renew->st_Bytes);
d590 6
a595 4
    if (vp_realloc != NULL) {
	ALp_renew->st_Sequence = count_mallocs;
	ALp_renew->vp_Alloced = vp_realloc;
	ALp_renew->st_Bytes = st_newBytes;
d598 1
a598 2
	 * Update the realloc information, too.  No need to allocate file name,
	 * static string.
d600 16
a615 2
	ALp_renew->SL_realloc.cp_FileName = cp_File;
	ALp_renew->SL_realloc.ssi_LineNumber = ssi_Line;
a616 1

d694 1
a694 2
	return;
    }
a695 6
    /*
     * Find the pointer in the allocated list.  If not found, bad pointer.  If
     * found, free list item and vp_Allloced.
     */
    ALp_free = FindInList(vp_Alloced);
    if (ALp_free == NULL) {
d697 2
a698 2
	 * Create the final entry before exiting marking this error.  If unable
	 * to allocate more memory just exit.
d700 7
a706 1
	AllocationList *ALp_new = typecalloc(AllocationList);
d708 3
a710 3
	if (ALp_new == NULL) {
	    exit_immediately(EXIT_FAILURE);
	}
d712 8
a719 8
	/*
	 * Set up the information, no memory need be allocated for the file
	 * name since it is a static string.
	 */
	ALp_new->vp_Alloced = NULL;
	ALp_new->vp_BadRequest = vp_Alloced;
	ALp_new->SL_memory.cp_FileName = cp_File;
	ALp_new->SL_memory.ssi_LineNumber = ssi_Line;
d721 13
a733 13
	/*
	 * Add the entry to the list and then return.
	 */
	AddToList(ALp_new);
	return;
    } else {
	/*
	 * Free off the memory.  Take entry out of allocation list.
	 */
	CountFrees(ALp_free->st_Bytes);
	RemoveFromList(ALp_free);
	FREE(ALp_free);
	FREE(vp_Alloced);
d751 11
a761 11
	return *dest;
    }
    if (*dest) {
	LYLeakFree(*dest, cp_File, ssi_Line);
	*dest = NULL;
    }
    if (src) {
	*dest = (char *) LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
	if (*dest == NULL)
	    outofmem(__FILE__, "LYLeakSACopy");
	strcpy(*dest, src);
d781 1
a781 3
	    return *dest;
	}
	if (*dest) {
d882 1
a882 1
	    auto AllocationList *ALp_new = typecalloc(AllocationList);
a951 1
#ifdef ANSI_VARARGS
a952 4
#else
static char *LYLeakHTSprintf(va_alist)
    va_dcl
#endif
d959 6
a964 10
    {
#ifndef ANSI_VARARGS
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
#endif
	if (pstr != 0 && *pstr != 0)
	    inuse = strlen(*pstr);
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       inuse, fmt, &ap);
    }
a970 1
#ifdef ANSI_VARARGS
a971 4
#else
static char *LYLeakHTSprintf0(va_alist)
    va_dcl
#endif
d977 4
a980 8
    {
#ifndef ANSI_VARARGS
	char **pstr = va_arg(ap, char **);
	const char *fmt = va_arg(ap, const char *);
#endif
	str = LYLeakSAVsprintf(pstr, leak_cp_File_hack, leak_ssi_Line_hack,
			       0, fmt, &ap);
    }
@


1.4
log
@update to lynx 2.8.5rel.1
tested todd@@,naddy@@. millert@@ deraadt@@ ok
@
text
@d2 9
a10 9
**	Copyright (c) 1994, University of Kansas, All Rights Reserved
**
**	This code will be used only if LY_FIND_LEAKS is defined.
**
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
**	10-30-97	modified to handle StrAllocCopy() and
**			  StrAllocCat(). - KW & FM
*/
d13 2
a14 2
**	Disable the overriding of the memory routines for this file.
*/
d25 1
a25 1
PRIVATE AllocationList *ALp_RunTimeAllocations = NULL;
d31 2
a32 2
PRIVATE long now_allocated = 0;
PRIVATE long peak_alloced = 0;
d34 2
a35 2
PRIVATE long total_alloced = 0;
PRIVATE long total_freed = 0;
d37 2
a38 2
PRIVATE long count_mallocs = 0;
PRIVATE long count_frees = 0;
d40 1
a40 1
PRIVATE void CountMallocs ARGS1(long, size)
d49 1
a49 1
PRIVATE void CountFrees ARGS1(long, size)
d55 1
d58 1
a58 1
#define CountFrees() /* nothing */
d62 10
a71 11
**  Purpose:	Add a new allocation item to the list.
**  Arguments:		ALp_new The new item to add.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects beyond
**		Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void AddToList ARGS1(
	AllocationList *,	ALp_new)
d74 1
a74 1
     *	Just make this the first item in the list.
d81 12
a92 13
**  Purpose:	Find the place in the list where vp_find is currently
**		tracked.
**  Arguments:		vp_find A pointer to look for in the list.
**  Return Value:	AllocationList *	Either vp_find's place in the
**						list or NULL if not found.
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE AllocationList *FindInList ARGS1(
	void *,		vp_find)
d97 2
a98 2
     *	Go through the list of allocated pointers until end of list
     *		or vp_find is found.
d107 1
a107 1
    return(ALp_find);
d111 10
a120 11
**  Purpose:	Remove the specified item from the list.
**  Arguments:		ALp_del The item to remove from the list.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void RemoveFromList ARGS1(
	AllocationList *,	ALp_del)
d125 2
a126 2
     *	There is one special case, where the item to remove is the
     *		first in the list.
d134 2
a135 2
     *	Loop through checking all of the next values, if a match
     *	don't continue.  Always assume the item will be found.
d142 1
a142 2
     *	We are one item before the one to get rid of.
     *	Get rid of it.
d148 1
a148 1
 *  Make the malloc-sequence available for debugging/tracing.
d150 2
a151 1
PUBLIC long LYLeakSequence NOARGS
d155 1
d158 14
a171 14
**  Purpose:	Print a report of all memory left unallocated by
**		Lynx code or attempted unallocations on
**		pointers that are not valid and then free
**		all unfreed memory.
**  Arguments:		void
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		This function should be registered for execution with the
**		atexit (stdlib.h) function as the first statement
**		in main.
**		All output of this function is sent to the file defined in
**		the header LYLeaks.h (LEAKAGE_SINK).
*/
PUBLIC void LYLeaks NOARGS
d174 1
a174 1
    size_t st_total = (size_t)0;
d181 2
a182 3
     *	Open the leakage sink to take all the output.
     *	Recreate the file each time.
     *	Do nothing if unable to open the file.
d191 1
a191 1
	 *  Take the head off of the run time allocation list.
d197 2
a198 2
	 *  Print the type of leak/error.
	 *  Free off memory when we no longer need it.
d202 2
a203 3
	     *	If there is realloc information on the
	     *	bad request, then it was a bad pointer
	     *	value in a realloc statement.
d214 3
a216 5
	     *	Don't free the bad request, it is an invalid pointer.
	     *	If the free source information is empty, we
	     *	should check the realloc information
	     *	too since it can get passed bad pointer
	     *	values also.
d235 1
a235 1
	    char *value = (char *)(ALp_head->vp_Alloced);
d238 2
a239 2
	     *	Increment the count of total memory lost and
	     *	then print the information.
d265 2
a266 2
				    gettext("ByteSize:"),
				    (int)(ALp_head->st_Bytes));
d268 2
a269 2
				    gettext("FileName:"),
				    ALp_head->SL_memory.cp_FileName);
d271 2
a272 2
				    gettext("LineCount:"),
				    ALp_head->SL_memory.ssi_LineNumber);
d274 2
a275 2
	     *	Give the last time the pointer was realloced
	     *	if it happened also.
d290 1
a290 2
	 *  Create a blank line and release the memory held
	 *  by the item.
d297 1
a297 2
     *	Give a grand total of the leakage.
     *	Close the output file.
d301 1
a301 1
	    (unsigned)st_total);
d317 18
a334 20
**  Purpose:	Capture allocations using malloc (stdlib.h) and track
**		the information in a list.
**  Arguments:	st_bytes	The size of the allocation requested
**				in bytes.
**		cp_File		The file from which the request for
**				allocation came from.
**		ssi_Line	The line number in cp_File where the
**				allocation request came from.
**  Return Value:	void *	A pointer to the allocated memory or NULL on
**				failure as per malloc (stdlib.h)
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory is allocated, then no entry is added to the
**		allocation list.
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PUBLIC void *LYLeakMalloc ARGS3(
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d339 1
a339 1
	return (void *)malloc(st_bytes);
d342 1
a342 1
     *	Do the actual allocation.
d344 1
a344 1
    vp_malloc = (void *)malloc(st_bytes);
d348 1
a348 1
     *	Only on successful allocation do we track any information.
d352 2
a353 2
	 *  Further allocate memory to store the information.
	 *  Just return on failure to allocate more.
d358 1
a358 1
	    return(vp_malloc);
d361 2
a362 3
	 *  Copy over the relevant information.
	 *  There is no need to allocate more memory for the
	 *  file name as it is a static string anyhow.
d371 1
a371 1
	 *  Add the new item to the allocation list.
d376 1
a376 1
    return(vp_malloc);
d380 23
a402 24
**  Purpose:	Add information about new allocation to the list,
**		after a call to malloc or calloc or an equivalent
**		function which may or may not have already created
**		a list entry.
**  Arguments:	vp_malloc	The pointer to newly allocated memory.
**  Arguments:	st_bytes	The size of the allocation requested
**				in bytes.
**		cp_File		The file from which the request for
**				allocation came from.
**		ssi_Line	The line number in cp_File where the
**				allocation request came from.
**  Return Value:	void *	A pointer to the allocated memory or NULL on
**				failure.
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory is allocated, then no entry is added to the
**		allocation list.
**  Revision History:
**	1999-02-08	created, modelled after LYLeakMalloc - kw
*/
PUBLIC AllocationList *LYLeak_mark_malloced ARGS4(
	void *,		vp_malloced,
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d410 1
a410 1
     *	The actual allocation has already been done!
d412 1
a412 1
     *	Only on successful allocation do we track any information.
d416 2
a417 2
	 *  See if there is already an entry.  If so, just
	 *  update the source location info.
d423 1
a423 1
	    return(ALp_new);
d426 2
a427 2
	 *  Further allocate memory to store the information.
	 *  Just return on failure to allocate more.
d432 1
a432 1
	    return(NULL);
d435 1
a435 1
	 *  Copy over the relevant information.
d443 1
a443 1
	 *  Add the new item to the allocation list.
d448 1
a448 1
    return(ALp_new);
d452 17
a468 20
**  Purpose:	Capture allocations by calloc (stdlib.h) and
**		save relevant information in a list.
**  Arguments:	st_number	The number of items to allocate.
**		st_bytes	The size of each item.
**		cp_File		The file which wants to allocation.
**		ssi_Line	The line number in cp_File requesting
**				the allocation.
**  Return Value:	void *	The allocated memory, or NULL on failure as
**				per calloc (stdlib.h)
**  Remarks/Portability/Dependencies/Restrictions:
**		If no memory can be allocated, then no entry will be added
**		to the list.
**  Revision History:
**		05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PUBLIC void *LYLeakCalloc ARGS4(
	size_t,		st_number,
	size_t,		st_bytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d473 1
a473 1
	return (void *)calloc(st_number, st_bytes);
d476 1
a476 1
     *	Allocate the requested memory.
d478 1
a478 1
    vp_calloc = (void *)calloc(st_number, st_bytes);
d482 1
a482 1
     *	Only if the allocation was a success do we track information.
d486 2
a487 2
	 *  Allocate memory for the item to be in the list.
	 *  If unable, just return.
d492 1
a492 1
		return(vp_calloc);
d496 2
a497 3
	 *  Copy over the relevant information.
	 *  There is no need to allocate memory for the file
	 *  name as it is a static string anyway.
d506 1
a506 1
	 *	Add the item to the allocation list.
d511 1
a511 1
    return(vp_calloc);
d515 25
a539 26
**  Purpose:	Capture any realloc (stdlib.h) calls in order to
**		properly keep track of our run time allocation
**		table.
**  Arguments:	vp_Alloced	The previously allocated block of
**				memory to resize.  If NULL,
**				realloc works just like
**				malloc.
**		st_newBytes	The new size of the chunk of memory.
**		cp_File		The file containing the realloc.
**		ssi_Line	The line containing the realloc in cp_File.
**  Return Value:	void *	The new pointer value (could be the same) or
**				NULL if unable to resize (old block
**				still exists).
**  Remarks/Portability/Dependencies/Restrictions:
**		If unable to resize vp_Alloced, then no change in the
**		allocation list will be made.
**		If vp_Alloced is an invalid pointer value, the program will
**		exit after one last entry is added to the allocation list.
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PUBLIC void *LYLeakRealloc ARGS4(
	void *,		vp_Alloced,
	size_t,		st_newBytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d545 1
a545 1
	return (void *)realloc(vp_Alloced, st_newBytes);
d548 1
a548 2
     *	If we are asked to resize a NULL pointer, this is just a
     *	malloc call.
d551 1
a551 1
	return(LYLeakMalloc(st_newBytes, cp_File, ssi_Line));
d555 2
a556 2
     *	Find the current vp_Alloced block in the list.
     *	If NULL, this is an invalid pointer value.
d561 2
a562 2
	 *  Track the invalid pointer value and then exit.
	 *  If unable to allocate, just exit.
d567 1
a567 1
	    exit(EXIT_FAILURE);
d571 2
a572 2
	 *  Set the information up; no need to allocate file name
	 *  since it is a static string.
d580 1
a580 2
	 *  Add the item to the list.
	 *  Exit.
d583 1
a583 1
	exit(EXIT_FAILURE);
d587 1
a587 2
     *	Perform the resize.
     *	If not NULL, record the information.
d589 1
a589 1
    vp_realloc = (void *)realloc(vp_Alloced, st_newBytes);
d599 2
a600 2
	 *  Update the realloc information, too.
	 *  No need to allocate file name, static string.
d606 1
a606 1
    return(vp_realloc);
d610 18
a627 18
**  Purpose:	Add information about reallocated memory to the list,
**		after a call to realloc or an equivalent
**		function which has not already created or updated
**		a list entry.
**  Arguments:	ALp_old		List entry for previously allocated
**				block of memory to resize.  If NULL,
**				mark_realloced works just like
**				mark_malloced.
**		vp_realloced	The new pointer, after resizing.
**		st_newBytes	The new size of the chunk of memory.
**		cp_File		The file to record.
**		ssi_Line	The line to record.
**  Return Value:		Pointer to new or updated list entry
**				for this memory block.
**				NULL on allocation error.
**  Revision History:
**	1999-02-11	created kw
*/
d629 4
a632 6
PRIVATE AllocationList *mark_realloced ARGS5(
	AllocationList *, ALp_old,
	void *,		vp_realloced,
	size_t,		st_newBytes,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d635 2
a636 2
     *	If there is no list entry for the old allocation, treat this
     *	as if a new allocation had happened.
d639 1
a639 2
	return(LYLeak_mark_malloced(
	    vp_realloced, st_newBytes, cp_File, ssi_Line));
d643 4
a646 5
     *	ALp_old represents the memory block before reallocation.
     *  Assume that if we get here, there isn't yet a list entry
     *  for the new, possibly different, address after realloc,
     *  that is our list hasn't been updated - so we're going to
     *  do that now.
d656 1
a656 1
    return(ALp_old);
d661 17
a677 18
**  Purpose:	Capture all requests to free information and also
**		remove items from the allocation list.
**  Arguments:	vp_Alloced	The memory to free.
**		cp_File		The file calling free.
**		ssi_Line	The line of cp_File calling free.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		If the pointer value is invalid, then an item will be added
**		to the list and nothing else is done.
**		I really like the name of this function and one day hope
**		that Lynx is Leak Free.
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PUBLIC void LYLeakFree ARGS3(
	void *,		vp_Alloced,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d687 2
a688 3
     *	Find the pointer in the allocated list.
     *	If not found, bad pointer.
     *	If found, free list item and vp_Allloced.
d693 2
a694 2
	 *  Create the final entry before exiting marking this error.
	 *  If unable to allocate more memory just exit.
d699 1
a699 1
	    exit(EXIT_FAILURE);
d703 2
a704 2
	 *  Set up the information, no memory need be allocated
	 *  for the file name since it is a static string.
d712 1
a712 1
	 *  Add the entry to the list and then return.
d718 1
a718 2
	 *  Free off the memory.
	 *  Take entry out of allocation list.
d728 8
a735 9
**  Allocates a new copy of a string, and returns it.
**  Tracks allocations by using other LYLeakFoo functions.
**  Equivalent to HTSACopy in HTUtils.c - KW
*/
PUBLIC char * LYLeakSACopy ARGS4(
	char **,	dest,
	CONST char *,	src,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d739 2
a740 2
	       "LYLeakSACopy: *dest equals src, contains \"%s\"\n",
	       src));
d748 1
a748 1
	*dest = (char *)LYLeakMalloc(strlen(src) + 1, cp_File, ssi_Line);
d751 1
a751 1
	strcpy (*dest, src);
d757 8
a764 9
**  String Allocate and Concatenate.
**  Tracks allocations by using other LYLeakFoo functions.
**  Equivalent to HTSACat in HTUtils.c - KW
*/
PUBLIC char * LYLeakSACat ARGS4(
	char **,	dest,
	CONST char *,	src,
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d769 2
a770 2
		   "LYLeakSACat:  *dest equals src, contains \"%s\"\n",
		   src));
d775 5
a779 4
	    *dest = (char *)LYLeakRealloc(*dest,
					  (length + strlen(src) + 1),
					  cp_File,
					  ssi_Line);
d782 1
a782 1
	    strcpy (*dest + length, src);
d784 3
a786 3
	    *dest = (char *)LYLeakMalloc((strlen(src) + 1),
					 cp_File,
					 ssi_Line);
d789 1
a789 1
	    strcpy (*dest, src);
d797 2
a798 2
PUBLIC CONST char * leak_cp_File_hack = __FILE__;
PUBLIC short leak_ssi_Line_hack = __LINE__;
d801 44
a844 45
** Purpose:	A wrapper around StrAllocVsprintf (the workhorse of
**		HTSprintf/HTSprintf0, implemented in HTString.c) that
**		tries to make sure that our allocation list is always
**		properly updated, whether StrAllocVsprintf itself was
**		compiled with memory tracking or not (or even a mixture,
**		like tracking the freeing but not the new allocation).
**		Some source files can be compiled with LY_FIND_LEAKS_EXTENDED
**		in effect while others only have LY_FIND_LEAKS in effect,
**		and as long as HTString.c is complied with memory tracking
**		(of either kind) string objects allocated by HTSprintf/
**		HTSprintf0 (or otherwise) can be passed around among them and
**		manipulated both ways.
**  Arguments:	dest		As for StrAllocVsprintf.
**		cp_File		The source file of the caller (i.e. the
**				caller of HTSprintf/HTSprintf0, hopefully).
**		ssi_Line	The line of cp_File calling.
**		inuse,fmt,ap	As for StrAllocVsprintf.
**  Return Value:	The char pointer to resulting string, as set
**			by StrAllocVsprintf, or
**			NULL if dest==0 (wrong use!).
**  Remarks/Portability/Dependencies/Restrictions:
**		The price for generality is severe inefficiency: several
**		list lookups are done to be on the safe side.
**		We don't get he real allocation size, only a minimum based
**		on the string length of the result.  So the amount of memory
**		leakage may get underestimated.
**		If *dest is an invalid pointer value on entry (i.e. was not
**		tracked), the program will exit after one last entry is added
**		to the allocation list.
**		If StrAllocVsprintf fails to return a valid string via the
**		indirect string pointer (its first parameter), invalid memory
**		access will result and the program will probably terminate
**		with a signal.  This can happen if, on entry, *dest is NULL
**		and fmt is empty or NULL, so just Don't Do That.
**  Revision History:
**	1999-02-11	created kw
**	1999-10-15	added comments kw
*/
PRIVATE char * LYLeakSAVsprintf ARGS6(
	char **,	dest,
	CONST char *,	cp_File,
	CONST short,	ssi_Line,
	size_t,		inuse,
	CONST char *,	fmt,
	va_list *,	ap)
d849 1
a849 1
    CONST char * old_cp_File = __FILE__;
d864 1
a864 1
	return(*dest);
d866 2
a867 1
	void * vp_realloced;
d871 2
a872 2
	     *  Track the invalid pointer value and then exit.
	     *  If unable to allocate, just exit.
d877 1
a877 1
		exit(EXIT_FAILURE);
d881 2
a882 2
	     *  Set the information up; no need to allocate file name
	     *  since it is a static string.
d890 1
a890 2
	     *  Add the item to the list.
	     *  Exit.
d893 1
a893 1
	    exit(EXIT_FAILURE);
d899 2
a900 2
	 *	DO THE REAL WORK, by calling StrAllocVsprintf.
	 *	If result is not NULL, record the information.
d903 1
a903 1
	vp_realloced = (void *)*dest;
d906 1
d912 1
a912 1
		    return(*dest);
d915 1
a915 1
		return(*dest);
d922 1
a922 1
		return(*dest);
d938 1
a938 1
	return(*dest);
d945 1
a945 1
PRIVATE char * LYLeakHTSprintf (char **pstr, CONST char *fmt, ...)
d947 1
a947 1
PRIVATE char * LYLeakHTSprintf (va_alist)
d954 2
a955 1
    LYva_start(ap,fmt);
d958 2
a959 2
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
d973 1
a973 1
PRIVATE char * LYLeakHTSprintf0 (char **pstr, CONST char *fmt, ...)
d975 1
a975 1
PRIVATE char * LYLeakHTSprintf0 (va_alist)
d981 2
a982 1
    LYva_start(ap,fmt);
d985 2
a986 2
	char **		pstr = va_arg(ap, char **);
	CONST char *	fmt  = va_arg(ap, CONST char *);
d996 7
a1002 8
 *  HTSprintf and HTSprintf0 will be defined such that they effectively
 *  call one of the following two functions that store away a copy to
 *  the File & Line info in temporary hack variables, and then call
 *  the real function (which is returned here as a function pointer)
 *  to the regular HTSprintf/HTSprintf0 arguments.
 *  It's probably a bit inefficient, but that shouldn't be noticeable
 *  compared to all the time that memory tracking takes up for list
 *  traversal. - kw
d1004 2
a1005 3
PUBLIC HTSprintflike *Get_htsprintf_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d1012 2
a1013 3
PUBLIC HTSprintflike *Get_htsprintf0_fn ARGS2(
	CONST char *,	cp_File,
	CONST short,	ssi_Line)
d1023 4
a1026 2
void no_leak_checking NOPARAMS;
void no_leak_checking NOARGS { }
@


1.3
log
@Update to lynx-2.8.4-rel1, patchset d, now with IPv6 as well

Local patches we maintain to the distribution are:
- replace unbounded fscanf with fgets (avsm)
- spelling fixes (deraadt)
- hppa -O0 workaround (mickey)
- default to ftp passive (deraadt)
- work with non-exec scripts (deraadt,hin,maja)
- be more careful with rlogin username (art)
- default to our webpage (deraadt)
- install helpfiles locally (maja)
- mkdtemp temp space directory (art)
- install more recent config.guess (avsm)

Tested by beck,millert,grange,fries,miod and others, deraadt@@ ok
@
text
@d5 5
d21 3
d27 130
a156 6
PRIVATE void AddToList PARAMS((
	AllocationList *	ALp_new));
PRIVATE AllocationList *FindInList PARAMS((
	void *			vp_find));
PRIVATE void RemoveFromList PARAMS((
	AllocationList *	ALp_del));
a170 4
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
**	10-30-97	modified to handle StrAllocCopy() and
**			  StrAllocCat(). - KW & FM
d178 3
d210 3
d250 3
d306 1
a306 1
    fprintf(Fp_leakagesink, "\n%s\t%u\n",
d309 6
d318 3
d345 5
d353 2
a354 1
    void *vp_malloc = (void *)malloc(st_bytes);
d374 1
d394 1
a394 1
**  Arguments:	vp_malloc	The pointer to newly allocate memory.
d416 4
d484 5
d492 2
a493 1
    void *vp_calloc = (void *)calloc(st_number, st_bytes);
d514 1
d560 3
d609 3
d613 1
d705 5
d746 1
d823 1
d883 5
d971 1
a971 1
#if ANSI_VARARGS
d983 1
a983 1
#if !ANSI_VARARGS
d998 1
a998 1
#if ANSI_VARARGS
d1009 1
a1009 1
#if !ANSI_VARARGS
d1048 6
a1053 91
#endif /* not LY_FIND_LEAKS and LY_FIND_LEAKS_EXTENDED */

/*
**  Purpose:	Add a new allocation item to the list.
**  Arguments:		ALp_new The new item to add.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects beyond
**		Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void AddToList ARGS1(
	AllocationList *,	ALp_new)
{
    /*
     *	Just make this the first item in the list.
     */
    ALp_new->ALp_Next = ALp_RunTimeAllocations;
    ALp_RunTimeAllocations = ALp_new;
}

/*
**  Purpose:	Find the place in the list where vp_find is currently
**		tracked.
**  Arguments:		vp_find A pointer to look for in the list.
**  Return Value:	AllocationList *	Either vp_find's place in the
**						list or NULL if not found.
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE AllocationList *FindInList ARGS1(
	void *,		vp_find)
{
    AllocationList *ALp_find = ALp_RunTimeAllocations;

    /*
     *	Go through the list of allocated pointers until end of list
     *		or vp_find is found.
     */
    while (ALp_find != NULL) {
	if (ALp_find->vp_Alloced == vp_find) {
	    break;
	}
	ALp_find = ALp_find->ALp_Next;
    }

    return(ALp_find);
}

/*
**  Purpose:	Remove the specified item from the list.
**  Arguments:		ALp_del The item to remove from the list.
**  Return Value:	void
**  Remarks/Portability/Dependencies/Restrictions:
**		Static function made to make code reusable in projects outside
**		of Lynx (some might ask why not use HTList).
**  Revision History:
**	05-26-94	created Lynx 2-3-1 Garrett Arch Blythe
*/
PRIVATE void RemoveFromList ARGS1(
	AllocationList *,	ALp_del)
{
    AllocationList *ALp_findbefore = ALp_RunTimeAllocations;

    /*
     *	There is one special case, where the item to remove is the
     *		first in the list.
     */
    if (ALp_del == ALp_findbefore) {
	ALp_RunTimeAllocations = ALp_del->ALp_Next;
	return;
    }

    /*
     *	Loop through checking all of the next values, if a match
     *	don't continue.  Always assume the item will be found.
     */
    while (ALp_findbefore->ALp_Next != ALp_del) {
	ALp_findbefore = ALp_findbefore->ALp_Next;
    }

    /*
     *	We are one item before the one to get rid of.
     *	Get rid of it.
     */
    ALp_findbefore->ALp_Next = ALp_del->ALp_Next;
}
@


1.2
log
@Upgrade to Lynx 2.8.2. -moj
@
text
@d119 1
a119 1
	    fprintf(Fp_leakagesink, "%s:\t",
d125 1
a125 1
		if (isprint(value[i_counter])) {
a131 1
	    FREE(ALp_head->vp_Alloced);
d153 2
d212 1
a212 2
	AllocationList *ALp_new =
			(AllocationList *)calloc(1, sizeof(AllocationList));
d237 69
d340 1
a340 2
	AllocationList *ALp_new =
			(AllocationList *)calloc(1, sizeof(AllocationList));
d414 1
a414 3
	auto AllocationList *ALp_new =
			     (AllocationList *)calloc(1,
						      sizeof(AllocationList));
d417 1
a417 1
	    exit(-1);
d434 1
a434 1
	exit(-1);
d458 55
d545 1
a545 3
	AllocationList *ALp_new =
			(AllocationList *)calloc(1,
						 sizeof(AllocationList));
d548 1
a548 1
	    exit(-1);
d588 1
a588 1
	CTRACE(tfp,
d590 1
a590 1
	       src);
d619 1
a619 1
	    CTRACE(tfp,
d621 1
a621 1
		   src);
d644 222
@


1.1
log
@Initial revision
@
text
@d12 4
a15 9
#include "HTUtils.h"
#include "tcp.h"
#include "LYexit.h"
#include "LYLeaks.h"
#include "LYUtils.h"
#include <ctype.h>
/*#include <stdio.h> included by HTUtils.h -- FM */

#define FREE(x) if (x) {free(x); x = NULL;}
d77 4
a80 4
	    fprintf(Fp_leakagesink,
		    "Invalid pointer detected.\n");
	    fprintf(Fp_leakagesink,
		    "Pointer:\t%p\n", ALp_head->vp_BadRequest);
d90 2
a91 1
		fprintf(Fp_leakagesink, "FileName:\t%s\n",
d93 2
a94 1
		fprintf(Fp_leakagesink, "LineCount:\t%d\n",
d97 6
a102 4
		fprintf(Fp_leakagesink, "FileName:\t%s\n",
				ALp_head->SL_memory.cp_FileName);
		fprintf(Fp_leakagesink, "LineCount:\t%d\n",
				ALp_head->SL_memory.ssi_LineNumber);
d106 1
d114 7
a120 3
	    fprintf(Fp_leakagesink, "Memory leak detected.\n");
	    fprintf(Fp_leakagesink, "Pointer:\t%p\n", ALp_head->vp_Alloced);
	    fprintf(Fp_leakagesink, "Contains:\t");
d125 2
a126 3
		if (isprint(((char *)(ALp_head->vp_Alloced))[i_counter])) {
		    fprintf(Fp_leakagesink, "%c",
			    ((char *)(ALp_head->vp_Alloced))[i_counter]);
d133 2
a134 1
	    fprintf(Fp_leakagesink, "ByteSize:\t%d\n",
d136 2
a137 1
	    fprintf(Fp_leakagesink, "FileName:\t%s\n",
d139 2
a140 1
	    fprintf(Fp_leakagesink, "LineCount:\t%d\n",
d147 2
a148 1
		fprintf(Fp_leakagesink, "realloced:\t%s\n",
d150 2
a151 1
		fprintf(Fp_leakagesink, "LineCount:\t%d\n",
d168 3
a170 2
    fprintf(Fp_leakagesink, "\nTotal memory leakage this run:\t%u\n",
		(unsigned)st_total);
d172 2
a173 16
#ifdef VMS
    {
	char VMSfilename[256];
	/*
	 *  Purge lower versions of the file.
	 */
	sprintf(VMSfilename, "%s;-1", LEAKAGE_SINK);
	while (remove(VMSfilename) == 0)
	    ;
	/*
	 *  Reset version number.
	 */
	sprintf(VMSfilename, "%s;1", LEAKAGE_SINK);
	rename(LEAKAGE_SINK, VMSfilename);
    }
#endif /* VMS */
d181 1
a181 1
**		cp_File 	The file from which the request for
d194 1
a194 1
	size_t, 	st_bytes,
d241 1
a241 1
**		cp_File 	The file which wants to allocation.
d253 2
a254 2
	size_t, 	st_number,
	size_t, 	st_bytes,
d306 1
a306 1
**		cp_File 	The file containing the realloc.
d320 2
a321 2
	void *, 	vp_Alloced,
	size_t, 	st_newBytes,
d395 1
a395 1
**		cp_File 	The file calling free.
d407 1
a407 1
	void *, 	vp_Alloced,
d468 6
d499 6
d559 1
a559 1
	void *, 	vp_find)
@


1.1.1.1
log
@Lynx 2.8
@
text
@@
